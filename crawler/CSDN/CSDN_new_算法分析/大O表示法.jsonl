{"Answer": "大O表示法是渐近上界，不是上确界。O（n^2）自然也满足O（n^3），一般取上确界", "Konwledge_Point": "大O表示法", "Question": "请问算法设计与分析中的 大O表示法 是不是和我们一般情况下用的 大O表示法 不一样？\n\n\n\n\n\n\n对于这道例题，一般情况下不就是 O(n^2) 吗？为什么还要搞一个 O(n^3)？", "Tag": "算法分析"}
{"Answer": "9和10都是O(n²)，11是O(n)", "Konwledge_Point": "大O表示法", "Question": "数据的时间复杂度用O来表示\n\n\n\n", "Tag": "算法分析"}
{"Answer": "O(n)就一个循环", "Konwledge_Point": "大O表示法", "Question": "关于#算法#的问题：帮看一下这串代码的时间复杂程度（用大O表示法）#include \n帮看一下这串代码的时间复杂程度（用大O表示法）\n\n\n#\ninclude\n \n\n\n\nint\n \nmain\n()\n\n\n{\n\n    \nint\n sum = \n0\n;\n    \nint\n i;\n    \nint\n N;\n    \nfor\n (i = \n1\n; i <= N; i++)\n        sum += i * i * i;\n\n}\n\n", "Tag": "算法分析"}
{"Answer": "\nSince it's sorted, you can find the value closest to zero in O(log(n)) time through binary search. That value splits the array in two subarrays, one with values less than zero (call it A) and one with values greater than zero (call it B). Obvisouly, two values a and b sum up to zero if and only if a = -b. So you can do:\nvar i = 0;\nvar j = 0;\nwhile (i < A.length && j < B.length) {\n    if (A[i] == -B[j]) {\n         return true;\n    } else if (A[i] < -B[j]) {\n        i++;\n    } else {\n        j++;\n    }\n}\nreturn false;\n\nThe complexity of the algorithm above is O(n/2)=O(n), and since O(n) > O(log(n)) (binary search), then the overall complexity is still O(n). Note then, that you could have iterated over the array instead of using binary search and the complexity would have been the same.\nThat actually makes me think you can do it all in a single loop. Just keep two pointers, one at the start of the array, one at the end, and move the progressively towards the middle. Complexity is is still O(n/2) = O(n):\nvar i = myArray.length-1;\nvar j = 0;\nwhile (i > j) {\n    if (myArray[i] == -myArray[j]) {\n         return true;\n    } else if (myArray[i] > -myArray[j]) {\n        i--;\n    } else {\n        j++;\n    }\n}\nreturn false;\n\n", "Konwledge_Point": "大O表示法", "Question": "Big-O表示法如何通过它php或javascript工作\n\n\n\nOk I am just learning about Big-O and someone gave me a conceptual question, to take as a means of trying to learn. However just barely starting out with Big-O I only know concept per say. \n\n\n\nI've been told If I take an array of sorted INT values how would I write a function that essentially would return true (or false) if the sum of any two of the numbers in the array equal zero. So my assumption is I would have an array like.\n\n\n\narray(\"0\",\"1\",\"2\",\"3\",\"4\")\n\n\n\n\nJust an example Im sure the array is much larger. What I am trying to figure out how is how can I really do that? I don't want to iterate over the array x times where x is the count of the array and then some to try every combination, thats just insane and if the array is large enough all Ill do is run out of memory and either bottle neck myself server side or client side depending on the route I run with it javascript or php.\n\n\n\nSo whats a good way of tackling that cause I sure have no decent clue at the moment.\n\n    ", "Tag": "算法分析"}
{"Answer": "30位常用符号和数字，不知道怎么对应位置顺序，目前只处理了全是英文字母的情况\nif __name__ == '__main__':\n    # 读取keyword.txt处理\n    uni_gram_list = []\n    with open(\"keyword.txt\", \"r\", encoding=\"utf-8\") as f:\n        text_line_list = f.read().splitlines()\n    for text in text_line_list:\n        uni_gram_dict = {}\n        uni_gram_item_list = []\n        for c in text:\n            if c.isalpha():\n                if c not in uni_gram_dict.keys():\n                    uni_gram_dict[c] = 1\n                else:\n                    uni_gram_dict[c] = uni_gram_dict[c] + 1\n                uni_gram_item_list.append(c + str(uni_gram_dict[c]))\n        uni_gram_list.append(uni_gram_item_list)\n    # uni-gram set.txt输出处理\n    f = open('uni-gram set.txt', 'w')\n    for line in uni_gram_list:\n        f.write(','.join(line)+'\\n')\n    f.close()\n    # uni-gram vector.txt输出处理\n    f = open('uni-gram vector.txt', 'w')\n    uni_gram_vector_list = [[0 for j in range(160)] for i in range(len(uni_gram_list))]\n    for index, value in enumerate(uni_gram_list):\n        # 用ascill码处理\n        uni_gram_list[index] = sorted(list(map(lambda x: ord(x[0:1]) - 97 + (int(x[1:2]) - 1) * 26, value)))\n        for i, v in enumerate(uni_gram_list[index]):\n            uni_gram_vector_list[index][v] = 1\n    for line in uni_gram_vector_list:\n        f.write(','.join(list(map(str, line))) + '\\n')\n    f.close()\n    print(\"success\")\n", "Konwledge_Point": "大O表示法", "Question": "编程实现:1-gram sequence、uni-gram set和uni-gram vector\n不限语言编程实现：choose a 1-gram sequence to parse a keyword, we name this representation as the uni-gram set. For example, the keyword “secure” is transformed to {s1, e1, c1, u1, r1, e2}, where “e1” is the first “e” in “secure” and “e2” is the second “e”. The uni-gram set is presented with a 160-bit long vector which named the uni-gram vector. The uni-gram vector consists of 26 ∗ 5 + 30 bits, where 26∗5 bits represent 26∗5 letters, 30 bits represent symbols and numbers those are in common use. A given bit is set to 1 if it characterizes a corresponding uni-gram; otherwise it remains 0.\n\n\n题目翻译：选择一个1-gram的序列来解析一个关键字，我们将这个表示法命名为uni-gram set。例如，关键字“secure”转换为集合{s1、e1、c1、u1、r1、e2}，其中“e1”是“secure”中的第一个“e”，“e2”是第二个“e”。uni-gram set被表示为一个160位长的向量，它被命名为uni-gram vector。单克向量由26∗5 + 30位组成，其中26∗5位代表26∗5个字母，30位表示常用的符号和数字。如果uni-gram vector中的一个给定的bit位描述了一个相应的uni-gram，则它被设置为1；否则它保持0。\n\n\n测试文件：keyword.txt\nstategov\nselfempnotinc\nfederalgov\nlocalgov\npriv\n\n\n期望输出结果1：uni-gram set.txt\ns1,t1,a1,t2,e1,g1,o1,v1,\ns1,e1,l1,f1,e2,m1,p1,n1,o1,t1,i1,n2,c1\nf1,e1,d1,e2,r1,a1,l1,g1,o1,v1\nl1,o1,c1,a1,l2,g1,o2,v1\np1,r1,i1,v1\n\n\n期望输出结果2：uni-gram vector.txt\n{1,0,0,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,...}\n{0,0,1,0,1,1,0,0,1,0,0,1,1,1,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,...}\n{1,0,0,1,1,1,1,0,0,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...}\n{1,0,1,0,0,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,...}\n{0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...}", "Tag": "算法分析"}
{"Answer": "\nimport re\n\ns = '''(1) s: string, 字符串;\n(2) d: decimal integer, 十进制数;\n(3) i: integer, 用法同%d;\n(4) u: unsigned integer, 无符号十进制数;\n(5) f: float, 浮点数(默认保留小数点后6位);\n(6) F: Float, 浮点数(默认保留小数点后6位);\n(7) e: exponent, 将数字表示为科学计数法(小写e, 默认保留小数点后6位);\n(8) E: Exponent, 将数字表示为科学计数法(大写E, 默认保留小数点后6位);\n(9) o: octal, 八进制数(即0-7);\n(10) x: hexdecimal, 十六进制数(即0-9a-f);\n(11) X: Hexdecimal, 十六进进制数(0-9A-F);\n(12) g: general format, 通用格式，详见如下...;\n(13) G: General format, 通用格式，详见如下...;\n(14) %c: character, 将十进制数转换为所对应的unicode值;\n(15) %r: representation, 调用__repr__魔法方法输出;\n(16) %%: 转义%，输出百分号。'''\n\nl = {}\nfor index, line in enumerate(s.split('\\n')):\n    # print(line)\n    try:\n        word = re.search('\\).*(\\w+):', line).group(1).lower()\n        l[index] = word\n    except:\n        pass\ns_l = sorted(l.items(), key=lambda x:x[1])\nfor temp in s_l:\n    print(s.split('\\n')[temp[0]])\n\n\n", "Konwledge_Point": "大O表示法", "Question": "以下文字，怎么按照a,b,c,d重新编号排列？\ns = '''\n3.type\n\n(1) s\n:\n \nstring, 字符串;\n\n\n(2) d\n:\n \ndecimal integer, 十进制数;\n\n\n(3) i\n:\n \ninteger, 用法同%d;\n\n\n(4) u\n:\n \nunsigned integer, 无符号十进制数;\n\n\n(5) f\n:\n \nfloat, 浮点数(默认保留小数点后6位);\n\n\n(6) F\n:\n \nFloat, 浮点数(默认保留小数点后6位);\n\n\n(7) e\n:\n \nexponent, 将数字表示为科学计数法(小写e, 默认保留小数点后6位);\n\n\n(8) E\n:\n \nExponent, 将数字表示为科学计数法(大写E, 默认保留小数点后6位);\n\n\n(9) o\n:\n \noctal, 八进制数(即0-7);\n\n\n(10) x\n:\n \nhexdecimal, 十六进制数(即0-9a-f);\n\n\n(11) X\n:\n \nHexdecimal, 十六进进制数(0-9A-F);\n\n\n(12) g\n:\n \ngeneral format, 通用格式，详见如下...;\n\n\n(13) G\n:\n \nGeneral format, 通用格式，详见如下...;\n\n\n(14) %c\n:\n \ncharacter, 将十进制数转换为所对应的unicode值;\n\n\n(15) %r\n:\n \nrepresentation, 调用__repr__魔法方法输出;\n\n\n(16) %%\n:\n \n转义%，输出百分号。\n\n4.补充\n'''\n不贴出print打印结果，你们懂我的意思吧？\n", "Tag": "算法分析"}
{"Answer": "1、学2、换行业", "Konwledge_Point": "大O表示法", "Question": "请问不会下面的技术怎么办\n不会\nHTML+CSS:\nHTML进阶、CSS进阶、div+css布局、HTML+css整站开发、JavaScript基础：\nJs基础教程、js内置对象常用方法、常见DOM树操作大全、ECMAscript、DOM、BOM、定时器和焦点图。\nJS基本特效：\n常见特效、例如：tab、导航、整页滚动、轮播图、JS制作幻灯片、弹出层、手风琴菜单、瀑布流布局、滚动事件、滚差视图。\nJS高级特征：\n正则表达式、排序算法、递归算法、闭包、函数节流、作用域链、基于距离运动框架、面向对象基础、\nJQuery：基础使用\n悬着器、DOM操作、特效和动画、方法链、拖拽、变形、JQueryUI组件基本使用。\nHTML5和移动Web开发\nHTML5：\nHTML5新语义标签、HTML5表单、音频和视频、离线和本地存储、SVG、WebSocket、Canvas.\nCSS3:\nCSS3新选择器、伪元素、脸色表示法、边框、阴影、background系列属性改变、Transition、动画、景深和深透、3D效果制作、Velocity.js框架、元素进场、出场策略、炫酷CSS3网页制作。\nBootstrap:\n响应式概念、媒体查询、响应式网站制作、删格系统、删格系统原理、Bootstrap常用模板、LESS和SASS。\n移动Web开发：\n跨终端WEB和主流设备简介、视口、流式布局、弹性盒子、rem、移动终端JavaScript事件、手机中常见JS效果制作、Zepto.js、手机聚划算页面、手机滚屏。\nHTTP服务和AJAX编程\nWEB服务器基础：\n服务器基础知识、Apache服务器和其他WEB服务器介绍、Apache服务器搭建、HTTP介绍。\nPHP基础：\nPHP基础语法、使用PHP处理简单的GET或者POST请求、\nAJAX上篇：\nAjax简介和异步的概念、Ajax框架的封装、XMLHttpRequest对象详细介绍方法、兼容性处理方法、Ajax框架的封装、Ajax中缓存问题、XML介绍和使用。\nAJAX下篇：\nJSON和JSON解析、数据绑定和模板技术、JSONP、跨域技术、图片预读取和lazy-load技术、JQuery框架中的AjaxAPI、使用Ajax实现爆布流案例额。\n面向对象进阶\n面向对象终极篇：\n从内存角度到理解JS面向对象、基本类型、复杂类型、原型链、ES6中的面向对象、属性读写权限、设置器、访问器。\n面向对象三大特征：\n继承性、多态性、封装性、接口。\n设计模式：\n面向对象编程思维、单例模式、工厂模式、策略模式、观察者模式、模板方法模式、代理模式、装饰者模式、适配器模式、面向切面编程。\n封装一个属于自己的框架\n框架封装基础：\n事件流、冒泡、捕获、事件对象、事件框架、选择框架。\n框架封装中级：\n运动原理、单物体运动框架、多物体运动框架、运动框架面向对象封装。\n框架封装高级和补充：\nJQuery框架雏形、可扩展性、模块化、封装属于传智自己的框架。\n模块化组件开发\n面向组件编程：\n面向组件编程的方式、面向组件编程的实现原理、面向组件编程实战、基于组件化思想开发网站应用程序。\n面向模块编程：\nAMD设计规范、CMD设计规范、RequireJS，LoadJS、淘宝的SeaJS。\n主流的流行框架\nWeb开发工作流：\nGIT/SVN、Yeoman脚手架、NPM/Bower依赖管理工具、Grunt/Gulp/Webpack。\nMVC/MVVM/MVW框架：\nAngular.js、Backbone.js、Knockout/Ember。\n常用库：\nReact.js、Vue.js、Zepto.js。\nHTML5原生移动应用开发\nCordova：\nWebApp/NativeApp/HybirdApp简介、Cordova简介、与PhoneGap之间的关系、开发环境搭建、Cordova实战(创建项目，配置，编译，调试，部署发布)。\nIonic：\nIonic简介和同类对比、模板项目解析、常见组件及使用、结合Angular构建APP、常见效果(下拉刷新，上拉加载，侧滑导航，选项卡)。\nReactNative：\nReactNative简介、ReactNative环境配置、创建项目，配置，编译，调试，部署发布、原生模块和UI组件、原生常用API。\nHTML5+：\nHTML5+中国产业联盟、HTML5PlusRuntime环境、HBuilder开发工具、MUI框架、H5+开发和部署。\nNode.js全栈开发：\n快速入门：\nNode.js发展、生态圈、Io.js、Linux/Windows/OSX环境配置、REPL环境和控制台程序、异步编程，非阻塞I/O、模块概念，模块管理工具、开发流程，调试，测试。\n核心模块和对象：\n全局对象global，process，console，util、事件驱动，事件发射器、加密解密，路径操作，序列化和反序列化、文件流操作、HTTP服务端与客户端。\nWeb开发基础：\nHTTP协议，请求响应处理过程、关系型数据库操作和数据访问、非关系型数据库操作和数据访问、原生的Node.js开发Web应用程序、Web开发工作流、Node.js开发Blog案例。\n快速开发框架：\nExpress简介+MVC简介、Express常用API、Express路由模块、Jade/Ejs模板引擎、使用Express重构Blog案例、Koa等其他常见MVC框架。", "Tag": "算法分析"}
{"Answer": "", "Konwledge_Point": "大O表示法", "Question": "别人的代码我运行不出来\n发的文件main. c运行出来是这个样子的，但在的项目里面又运行的出来，的复制粘贴过来我项目里也没有运行出来，请问是什么问题\n\n\n\n\n\n\n\n\n#include \n\n\n#include \n\n\n\n/* run this program using the console pauser or add your own getch, system(\"pause\") or input loop */\n\ntypedef \nint\n* Elemtype;\n\n#define overflow -2\n\n\n#define error -1\n\n\ntypedef \nint\n Elemtype;\n\n\n/*双链表链表结点结构体定义*/\n\ntypedef struct DuLNode{\n    Elemtype data;                           \n//数据域\n\n    struct DuLNode *prior;                   \n//指针域，指向前驱 \n\n    struct DuLNode *next;                    \n//指针域，指向后继 \n\n}DuLNode,*DuLinkList; \n\n\n/*尾插法，建立双向循环链表*/\n\n\nvoid\n CreateListR(DuLinkList *DL, \nint\n n){\n    \n/************头结点*************/\n \n    *DL = (DuLNode*)malloc(sizeof(DuLNode));\n    \nif\n(!(*DL)) \nexit\n(overflow);\n    (*DL)->prior = \nNULL\n;\n    (*DL)->next = \nNULL\n;\n    \n/************头结点*************/\n \n    \n    \nint\n i;\n    DuLinkList DR;\n    DR=*DL;     \n//DR指向尾结点 \n\n    \n/************循环建立新结点，并将新结点尾插在当前尾结点后*************/\n \n    \nfor\n(i=\n0\n;idata = i+\n1\n;\n        DP->prior = DR;    \n//尾插操作序列 \n\n        DR->next = DP;\n        DR = DP;\n    } \n    \n/************循环建立新结点，并将新结点尾插在当前尾结点后*************/\n \n    \n    \n/************建立循环链表，尾结点next域指向头结点，头结点prior域指向尾结点*************/\n \n    DR->next = (*DL);\n    (*DL)->prior = DR; \n    \n/************建立循环链表，尾结点next域指向头结点，头结点prior域指向尾结点*************/\n\n}\n\n\n\n/*遍历双向循环链表，返回链表长度*/\n\n\nint\n ListTraverse(DuLinkList DL){\n    \n/*************判断链表是否为空，请思考下判断双循环链表是否为空的条件*************/\n \n    \nif\n(DL->next == DL || DL->prior == DL) {\n        printf(\n\"DuLinkList is NULL\\n\"\n);\n        \nreturn\n \n0\n;\n    } \n    \n/*************判断链表是否为空，请思考下判断双循环链表是否为空的条件*************/\n \n    \n    \nint\n length = \n0\n;\n    printf(\n\" DuLinkList is:\\n\"\n); \n    DuLinkList DR = DL->next;\n    \n    \n/*************DR向后遍历链表，打印数据，请思考下循环结束的条件*************/\n\n    \nwhile\n(!(DR == DL)){\n        printf(\n\"%d\\t\"\n,DR->data);\n        DR=DR->next;\n        length++;\n    }\n    \n/*************DR向后遍历链表，打印数据，请思考下循环结束的条件*************/\n\n    printf(\n\"\\n\"\n);\n    \nreturn\n length;\n} \n\n\n\n/*设以带头结点的双向循环链表表示的线性表为L=(a1,a2,a3,…,an)。\n试写一时间复杂度O(n)的算法，将L改造为L=(a1,a3,…,an,…,a4,a2)。*/\n\n\nvoid\n ListTransform(DuLinkList *DL,\nint\n ListLength){\n    \n/*************判断链表是否为空，判断链表长度是否小于等于2，若满足则不做修改*************/\n\n    \nif\n( (*DL) == \nNULL\n || (*DL)->next == DL || (*DL)->prior == DL) \nreturn\n;\n    \nif\n(ListLength ==\n1\n || ListLength==\n2\n )\nreturn\n;\n    \n/*************判断链表是否为空，判断链表长度是否小于等于2，若满足则不做修改*************/\n\n    \n    DuLinkList DP,DQ,DR,DW;\n//DP指向第1个结点，DQ指向第2个结点，DR指向奇数结点，DW指向偶数结点 \n\n    \n    \n/*************将尾结点的next域断开，是否需要断开呢？*************/\n \n    (*DL)->prior->next = \nNULL\n;\n    (*DL)->prior = \nNULL\n;\n    \n/*************将尾结点的next域断开，是否需要断开呢？*************/\n\n    \n    \n/*************断开链表，只保留头结点后的两个结点DP和DQ，\n    并用DR保留第三个结点后的链表*************/\n\n    DP = (*DL)->next; DQ = DP->next; DR = DQ->next; \n    DQ->next = (*DL); (*DL)->prior = DQ;\n    DP->next = \nNULL\n; DQ->prior = \nNULL\n; DR->prior = \nNULL\n; \n//断开DP和DQ \n\n    \n/*************断开链表，只保留头结点后的两个结点DP和DQ，\n    并用DR保留第三个结点后的链表*************/\n\n    \n    \n/*************遍历第三个结点后的链表数据，奇数结点尾插至DP后面，\n    偶数结点头插至DQ前面*************/\n\n    \nwhile\n(!(DR == \nNULL\n)){\n        \n/*************更新DW**************/\n \n        DW=\nNULL\n;     \n//这是关键一步，同学们思考下如果没有这步会发生什么情况 \n\n        \nif\n(!(DR->next==\nNULL\n)) {\n            DW=DR->next;\n        }\n        \n/*************更新DW**************/\n \n        \n        \n/*************DR尾插至DP之后**************/\n \n         DR->next = \nNULL\n;\n         DR->prior = DP;\n         DP->next = DR;\n         DP=DR;\n         \n/*************DR尾插至DP之后**************/\n \n         \n         \n/*************DW头插至DQ之前，并更新DR**************/\n \n         \nif\n(!(DW==\nNULL\n)){\n             DR = DW->next;\n             DW->prior = \nNULL\n;\n             DW->next = DQ;\n             DQ->prior = DW;\n             DQ=DW;\n         }\nelse\n{\n             DR = \nNULL\n;\n         }\n         \n/*************DW头插至DQ之前，并更新DR**************/\n \n    }\n    \n/*************遍历第三个结点后的链表数据，奇数结点尾插至DP后面，\n    偶数结点头插至DQ前面*************/\n\n    \n    DP->next = DQ; DQ->prior = DP;\n//连接DP和DQ \n\n} \n\n\n\nint\n main(\nint\n argc, char *argv[]) {\n    DuLinkList DL;\n    printf(\n\"\\n************************建立双循环链表**************************\\n\"\n);\n    CreateListR(&DL,\n9\n);\n    \nint\n ListLength = ListTraverse(DL);\n    printf(\n\"\\n************************变换双循环链表**************************\\n\"\n);\n    ListTransform(&DL,ListLength);\n    ListTraverse(DL);\n    \nreturn\n \n0\n;\n}\n", "Tag": "算法分析"}
