{"Answer": "从算法思想找现实案例的基本都是少数，绝大部分都是，从案例分析到匹配算法。\r\n所以你可能学了很多种不同的算法，没有用到现实中，你会觉得学那么多没用。\r\n但是你的潜意识懂得了这种思想，然后当你在现实生活中遇到实际问题的时候，你会很快反应到那些算法可能会有用，哪些又是最优方法。\r\n\r\n那我自己来说，我当初学排序和查找时候，没觉得什么东西需要排序，需要查找，总是觉得生活中乱乱的，你这种查找或者排序肯定不行。\r\n后来工作了，关于游戏排行榜这里的处理的逻辑，查找一个玩家应该排序到哪里，然后立马想到了二分查找。这就是从现实问题找思想。体会很深。\r\n\r\n这种算法思想是通过生活例子抽象出来的一种总结，你再从这种抽象出来的去还原，相比从生活中抽象，肯定不是那么容易，所以学了就学了，\r\n先总结着，或许你可以一边思考生活中，什么事情，什么东西可以在程序中怎么设计，熟练了，再反向思维。", "Konwledge_Point": "最长递增子序列", "Question": "最长递增子序列问题可以在实际的工作中解决什么样的需求？\n给定一个序列A及它的长度n(长度小于等于500)，请返回LIS的长度。\n\n测试样例：\n\n[1,4,2,5,3],5\n\n返回 3\n\n\n\n# -*- coding:utf-8 -*-\n\nclass LongestIncreasingSubsequence:\n    def getLIS(self, A, n):\n        dp = [1 for i in range(n)]\n        for i in range(n):\n            maxtemp = 0\n            for j in range(i):\n                if A[j] < A[i] and dp[j] > maxtemp:\n                    maxtemp = dp[j]\n            dp[i] = maxtemp + 1\n        return max(dp)\n\n\n\n\n\n以上是这个经典问题的解法。在百度一搜 LIS（最长递增子序列） 或者 LCS（最长公共子序列） 通篇都在讲什么解法最优，解的过程如何，就是没有人解释这个算法可以解决现实中的什么问题，在工作中解决什么需求，动不动就在谈思想，如果你所学的算法、技术不是为了业务服务，那学习这些东西还有什么意义？\n\n话说回来，有木有大佬能解答一下小弟的疑问", "Tag": "算法分析"}
{"Answer": "参考：https://blog.csdn.net/lucienduan/article/details/24397949\r\n\r\n```\r\n /************************************************************************/  \r\n/* 算法导论15.4-5 \r\n * 找出n个数的序列中最长的单调递增子序列 \r\n * 利用动态规划思想，时间复杂度为O(n^2)*/  \r\n/************************************************************************/  \r\n#include  \r\nusing namespace std;  \r\nvoid printSequence(int *b,int* nums,int last);  \r\nint main()  \r\n{  \r\n    int n=8;  \r\n    int nums[9]={0,1,7,8,9,2,3,4,5};  \r\n    //b存储当前元素所在递增子序列中当前元素的前一个元素序号  \r\n    //c存储以当前元素结尾的递增子序列长度  \r\n    //last存储当前元素为止的序列中最长递增子序列的最后一个元素的序号  \r\n    //maxLen存储当前最长递增子序列的长度  \r\n    int b[9]={0},c[9]={0},last[9]={0},maxLen=0;  \r\n    c[1]=1,last[1]=1;  \r\n    for (int i=1;i<=n;i++)  \r\n    {  \r\n        for (int j=1;jc[i])  \r\n            {  \r\n                c[i]=c[j]+1;  \r\n                b[i]=j;  \r\n                last[i]=i;  \r\n                maxLen=c[i];  \r\n            }else if(c[j]>c[i]){  \r\n                maxLen=c[j];  \r\n                last[i]=last[j];  \r\n            }  \r\n        }  \r\n    }  \r\n    cout<<\"原序列长度为\"<0)  \r\n        printSequence(b,nums,b[last]);  \r\n    cout<<nums[last]<<\" \";  \r\n}  \r\n```", "Konwledge_Point": "最长递增子序列", "Question": "C++语言编程 单调递增最长子序列\n7-1 单调递增最长子序列\n\n设计一个O(n2)时间的算法，找出由n个数组成的序列的最长单调递增子序列。\n\n输入格式:\n\n\n\n输入有两行： 第一行：n，代表要输入的数列的个数 第二行：n个数，数字之间用空格格开\n\n输出格式:\n\n\n\n最长单调递增子序列的长度\n\n输入样例:\n\n\n\n在这里给出一组输入。例如：\n\n5\n\n1 3 5 2 9\n\n输出样例:\n\n\n\n在这里给出相应的输出。例如：\n\n4", "Tag": "算法分析"}
{"Answer": "那我来个优化的，动态规划的\n\ndef lengthOfLIS():\n    n = eval(input())\n    nums = list(map(int,input().split()))\n    dp = [1 for _ in range(n)] # 动态转换数组\n    max_length = 1 # 最短一个词长度为1不是0\n    for i in range(1,n):\n        for j in range(i):\n            if nums[i]>nums[j]: # 代表遍历到当前为递增，可以加入\n                dp[i] = max(dp[i],dp[j]+1) # 判断是之前的大，还是现在dp[j]加了1大\n        max_length = max(dp[i], max_length) # 当前的长度的最大值和全局长度最大值比较\n    print(max_length)\n\nlengthOfLIS()\n", "Konwledge_Point": "最长递增子序列", "Question": "用Python，输出给定数列的最长递增子序列的长度，写一下注释\n问题遇到的现象和发生背景\n\n\n给定一个由 nn个整数组成的序列 AA。找到最大的 k有一个索引序列 满足不等式a≤a2≤ak\n例如，序列 A=(5 3  2  4  6 1) 具有最长的递增子序列 (3 4  6) 和 (2 4 6)\n\n\n测试输入输出例子如图\n\n\n\n\n数据输入例子解释\n第一个输入行包含一个整数 n(1≤n≤2000)，A中的元素个数。\n第二个输入行包含 n 个整数 ai（1≤ai ≤1000）\n\n\n数据输出解释\n打印一个整数 k，即最长递增子序列的长度。\n\n\n我想要达到的结果\n\n\n用Python实现编写满足图片和任意的例子，输出打印一个整数 k，输出给定数列的最长递增子序列的长度\n数据输入第一行使用 n= int(input())\n第二行使用li = input().split()接收任意参数\n最后输出打印满足任意条件的结果", "Tag": "算法分析"}
{"Answer": "三方库应该没有。但是你可以自己创建一个库啊代码如下：https://www.runoob.com/w3cnote/python-longest-increasing-subsequence.html", "Konwledge_Point": "最长递增子序列", "Question": "有没有算最长递增子序列的三方库\n有没有算 最长递增子序列的 三方库，有没有哪位知道的帮下忙    有没有算 最长递增子序列的 三方库，有没有哪位知道的帮下忙 ", "Tag": "算法分析"}
{"Answer": "该回答引用GPT，有帮助的话请帮我点个采纳\nLCS通常使用动态规划法进行计算，其时间复杂度为O(mn)，其中m和n分别是两个序列的长度。\n而LIS可以使用O(nlogn)的算法，如二分查找法或者动态规划法。\n所以，LCS不一定通过LIS的方法来降低其时间复杂度到O（nlogn）。", "Konwledge_Point": "最长递增子序列", "Question": "关于#c语言#的问题：LCS（最长公共子序列）能否都能通过LIS（最长递增子序列）把时间复杂度降到O（nlogn）\nLCS（最长公共子序列）能否都能通过LIS（最长递增子序列）把时间复杂度降到O（nlogn）", "Tag": "算法分析"}
{"Answer": "每两个数比较，符合规则时计数加1.不符合规则时判断当前计数是否最大。然后重新开始计数\n#include <stdio.h>\nint main()\n{\n    int i,t=0,max=0,n,a[10000] = {0};\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++)\n        scanf(\"%d\",&a[i]);\n    for(i=1;i<n;i++)\n    {\n        if(a[i] > a[i-1])\n            t++;\n        else\n        {\n            if(t>max)\n                max = t;\n            t=0;\n        }\n    }\n    if(t > max)\n        max = t;\n    if(max > 0)\n        max++;\n    printf(\"最长递增长度：%d\\n\",max);\n    return 0;\n}\n\n", "Konwledge_Point": "最长递增子序列", "Question": "芒课 —— 3268试题\n问题遇到的现象和发生背景\n\n\n如果序列中相邻两个数的左边一个值小于右边的值，则我们说这两个值是递增的。给定一个数值序列，请输出序列中最长的递增子序列（子序列是指原始序列中的连续的一段）的长度。\n\n\n输入说明\n第一行一个整数，表示序列中数值的个数n(1<n<10000)。第二行，n个用空格隔开的整数，表示序列\n\n\n输出说明\n一个整数，表示符合条件的序列长度。如果不存在递增子序列，输出0.\n\n\n问题相关代码，请勿粘贴截图\n\n\n运行结果及报错内容\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果", "Tag": "算法分析"}
