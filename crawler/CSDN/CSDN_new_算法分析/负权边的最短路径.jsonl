{"Answer": "Dijkstra算法伪代码 \n\nfor each node v    \n    dis(v) ← +∞    \n    previous (v) ← undefined    \n    dis(source) ← 0    \n    while num(S) < n    ▷ S为顶点集合\n        u ← node with smallest distance    \n        Remove u    \n        for each node v in S    \n            alt ← dis(u) + dis(u,v)    \n            if alt < dis(v) then    \n                dis(v) ← alt    ▷ 更新距离\n                previous(v) ← u    \n\n可以参考这篇博客（含MATLAB代码）：https://blog.csdn.net/lishan132/article/details/108527271这篇里面有讲解（有示例讲解）：https://blog.csdn.net/L_J_Kin/article/details/103061420", "Konwledge_Point": "负权边的最短路径", "Question": "Matlab 最短路径 起始点出发，回到起始点，经过所有点\n利用matlab图论知识求解，从起始点出发，经过其他所有点，然后返回起始点，求最短路径", "Tag": "算法分析"}
{"Answer": "TSP问题本质和城市间最短路径寻优问题一样，都是求两个点的最优路径，这种问题你要把这些实际数据想成是图的操作\r\nhttp://www.cnblogs.com/biaoyu/archive/2012/09/26/2704456.html", "Konwledge_Point": "负权边的最短路径", "Question": "蚁群算法 寻找最短路径的问题\n想搞个城市间最短路径寻优，网上全都是tsp问题，我只想要起点到终点的最优路径，不需要返回，该怎么写。。。能不能给点代码……", "Tag": "算法分析"}
{"Answer": "https://cloud.tencent.com/developer/article/1073087", "Konwledge_Point": "负权边的最短路径", "Question": "这个最短路径的问题，用C语言怎么解决\nProblem Description\n\nThere are N cities in the country. Each city is represent by a matrix size of M*M. If city A, B and C satisfy that A*B = C, we say that there is a road from A to C with distance 1 (but that does not means there is a road from C to A).\n\nNow the king of the country wants to ask me some problems, in the format:\n\nIs there is a road from city X to Y?\n\nI have to answer the questions quickly, can you help me?\n\n\n\nInput\n\nEach test case contains a single integer N, M, indicating the number of cities in the country and the size of each city. The next following N blocks each block stands for a matrix size of M*M. Then a integer K means the number of questions the king will ask, the following K lines each contains two integers X, Y(1-based).The input is terminated by a set starting with N = M = 0. All integers are in the range [0, 80].\n\n\n\nOutput\n\nFor each test case, you should output one line for each question the king asked, if there is a road from city X to Y? Output the shortest distance from X to Y. If not, output \"Sorry\".\n\n\n\nSample Input\n\n3 2\n\n1 1\n\n2 2\n\n1 1\n\n1 1\n\n2 2\n\n4 4\n\n1\n\n1 3\n\n3 2\n\n1 1\n\n2 2\n\n1 1\n\n1 1\n\n2 2\n\n4 3\n\n1\n\n1 3\n\n0 0\n\n\n\nSample Output\n\n1\n\nSorry", "Tag": "算法分析"}
{"Answer": "已找到，使用图网络模型可以实现。", "Konwledge_Point": "负权边的最短路径", "Question": "神经网络能否不失一般性地解图的最短路径问题？\n\n\n\n解最短路径问题，我看了一些网上的例子，多是训练DQN能够在某一特定图中找到最短路径（如图，在这个特定图中学习如何绕过黑点到达黄点）\n\n\n\n这种训练，相当于特定图的拓扑存储在了Q Matrix中，当图（环境）改变时则需要重新训练。\n\n问题：请问神经网络能否不失一般性地解图的最短路径问题？也就是不依赖某种特定的图拓扑，每次输入图拓扑和起点终点，输出最优路径", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/alphapi/article/details/19770749", "Konwledge_Point": "负权边的最短路径", "Question": "求无向不带权图某点C到各点的最短路径dai'ma\n一个无向不带权图，有N个节点，M条路径\n\n求某一节点C到其他各路径的最短路径，并按顺序输出", "Tag": "算法分析"}
{"Answer": "你这个是最短路径计算，运费应该两个地点之间经过节点数计算，比如a到c，，经过5个节点，每个节点收费5元，运费就25元。你的要求包括了好几种最短路径算法，具体可以参考https://blog.csdn.net/printfxgd/article/details/80791847", "Konwledge_Point": "负权边的最短路径", "Question": "城市交通查询系统设计\n题目3: 城市交通查询系统设计内容：设计一个交通查询系统，能够查询：1)从一个城市到其它各城市之间的最短路径或运费最少的路径;2）多个城市中任意一对城市之间的最短路径或运费最少的路径。设计要求：（1）建立关于城市信息结点的结构体；（2）定义城市信息链表的结点结构；（3）建立交通网络图的存储结构；（4）写出采用Dijksta算法求每对顶点之间最短路径的算法函数；  （5）写出采用Floyed算法求任意一对顶点之间最短路径的算法函数；（6）输入交通网络图中的路径信息或费用信息；（7）根据Dijksta算法计算从太原到其它各大城市的最短路径或最小费用；（8）根据Floyed算法计算任意一对大城市之间的最短路径或最小费用；（9）对于不同的查询要求可以输入已知城市间的路程或所需费用信息。", "Tag": "算法分析"}
{"Answer": "graphminspan tree，这里多了两个空格，将空格删去即可，matlab这样相当于直接识别成两个函数，是自定义函数还是系统自带的，可以用实时脚本编程，那个可以实时报错", "Konwledge_Point": "负权边的最短路径", "Question": "matlab最短路径问题\n\n\n这个错误应该怎么改呀？", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/ShiWaiGaoRen12345/article/details/69808597", "Konwledge_Point": "负权边的最短路径", "Question": "最短路径的数据结构的问题，C语言的问题，具体怎么解决的思路的问题\nProblem Description\n\nThere are n points on the plane, Pi(xi, yi)(1 <= i <= n), and xi < xj (i\nBefore you reach the rightmost point Pn, you can only visit the points those have the bigger x-coordinate value. For example, you are at Pi now, then you can only visit Pj(j > i). When you reach Pn, the rule is changed, from now on you can only visit the points those have the smaller x-coordinate value than the point you are in now, for example, you are at Pi now, then you can only visit Pj(j < i). And in the end you back to P1 and the tour is over.\n\nYou should visit all points in this tour and you can visit every point only once.\n\n\n\nInput\n\nThe input consists of multiple test cases. Each case begins with a line containing a positive integer n(2 <= n <= 200), means the number of points. Then following n lines each containing two positive integers Pi(xi, yi), indicating the coordinate of the i-th point in the plane.\n\n\n\nOutput\n\nFor each test case, output one line containing the shortest path to visit all the points with the rule mentioned above.The answer should accurate up to 2 decimal places.\n\n\n\nSample Input\n\n3\n\n1 1\n\n2 3\n\n3 1\n\n\n\nSample Output\n\n6.47", "Tag": "算法分析"}
{"Answer": "#include \"stdio.h\"\nusing namespace std;\nstruct OP {\n    int next[10001], num = 0;  //  记入它接下来抵达的地方,num 为个数\n}op[10001];                    //  表示点个数,0为出发地,10000为目的地\n\nint f[10001],key[10001],k_len=50000;\nvoid find_MinRoad(int now,int num){  // 当前位置,当前走的步数\n    if(now==10000){\n        if(num<k_len) for(k_len=0;k_len<num;k_len++) key[k_len] = f[k_len];\n    }\n    if(now!=10000){\n        for(int z=0;z<op[now].num;z++) {\n            f[num] = op[now].next[z];\n            find_MinRoad(op[now].next[z],num+1);\n        }\n    }\n\n}\nint main()\n{\n    int road,a,b;                      //  road : 输入中间路的总个数，你的图为13,如果更多点把int 换成long op那的数组也再开大点\n    scanf(\"%d\",&road);\n\n    while (road--){\n        scanf(\"%d %d\",&a,&b); // a->b\n        op[a].next[op[a].num++] = b;\n    }\n\n    find_MinRoad(0,1);\n\n    printf(\"%d\\n\",k_len-1);\n    for(int z=0;z<k_len;z++) printf(\"%d \",key[z]);\n    return 0;\n}\n", "Konwledge_Point": "负权边的最短路径", "Question": "对于下图，利用最短路径算法，找到从家到学校最短路径长度（能够输出对应路径更好）\n对于下图，利用最短路径算法，找到从家到学校最短路径长度（能够输出对应路径更好）（C语言）", "Tag": "算法分析"}
{"Answer": "边(2,4)的长度看不清，姑且认为是3吧。那么算法的过程是：取点2，用2的最短路0更新1(5)、4(3)、6(10)；取点4，用4的最短路3更新6(5)；取点1，用1的最短路5更新3(9)、5(12)；取点6，用6的最短路5更新5(11)......括号里是更新后该点的最短路，每次枚举的点的最短路一定是当前已经更新的点中最小的", "Konwledge_Point": "负权边的最短路径", "Question": "数据结构最短距离（迪杰斯特拉）的算法\n\n\n这个2到5好像存在问题到底应该走哪一条我记得有讲过还没更新的不能走2到6还没更新可是答案是走的2到4，4到6，6到5", "Tag": "算法分析"}
{"Answer": "弄一个数组，下标是当前节点，里面的值是下一个节点", "Konwledge_Point": "负权边的最短路径", "Question": "图的最短路径问题，滴杰斯特拉算法\n\n\n友友们，这个是一个关于图的最短路径求解代码，只显示了求最短路径的函数，在我构造的这个图里，我要输出一个点到另一个点的最短路径长度，但我不会输出走的过程，友友教教我怎么把经过点输出来，想了一个下午了", "Tag": "算法分析"}
{"Answer": "https://github.com/daancode/a-star，可以参考这个项目如有帮助，请采纳，谢谢。", "Konwledge_Point": "负权边的最短路径", "Question": "使用Astar找最短路径\n\n\n使用Astar找最短路径  当到图中标记的那个点后  再往后就会到右边 无法继续行走  报错，\n代价的计算应该怎么改？ 有什么优化的方法吗 ", "Tag": "算法分析"}
{"Answer": "不同于网上找到的答案的\n#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\ntypedef struct data\n{\n    int x;\n    int y;\n    int len;\n} QDataType; //数据类型\n\ntypedef struct ListNode //通过链表实现的\n{\n    QDataType _data;\n    struct ListNode *_pNext;\n} ListNode, *pListNode;\n\ntypedef struct Queue\n{\n    pListNode _pHead; //头指针\n    pListNode _pTail; //尾指针\n} Queue;\n\npListNode BuyNode(QDataType d)\n{\n    pListNode new = malloc(sizeof(ListNode));\n    new->_data = d;\n    new->_pNext = NULL;\n    return new;\n}\n\nvoid QueueInit(Queue *q)\n{\n    assert(q);\n    QDataType d;\n    q->_pHead = BuyNode(d);\n    q->_pTail = q->_pHead;\n}\n\nvoid QueuePush(Queue *q, QDataType d)\n{\n    assert(q);\n    q->_pTail->_pNext = BuyNode(d);\n    q->_pTail = q->_pTail->_pNext;\n}\n\nvoid QueuePop(Queue *q)\n{\n    pListNode dNode = q->_pHead->_pNext;\n    if (dNode)\n    {\n        q->_pHead->_pNext = dNode->_pNext;\n        if (q->_pHead->_pNext == NULL)\n        {\n            q->_pTail = q->_pHead;\n        } //如果只有一个元素，删完后ptail会悬空\n        free(dNode);\n    }\n}\n\nint QueueSize(Queue *q)\n{\n    assert(q);\n    pListNode pre = q->_pHead->_pNext;\n    int count = 0;\n    while (pre)\n    {\n        count++;\n        pre = pre->_pNext;\n    }\n    return count;\n}\nint QueueEmpty(Queue *q)\n{\n    return NULL == q->_pHead->_pNext;\n}\nQDataType Front(Queue *q)\n{\n    return q->_pHead->_pNext->_data;\n}\nQDataType Back(Queue *q)\n{\n    return q->_pTail->_data;\n}\n\nQueue *q;\nint ds[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\nint m, n;\nint a[100][100];\n\nint bfs(int x, int y, int x2, int y2)\n{\n    QDataType d = {x, y, 0};\n    QueuePush(q, d);\n    a[x][y] = 2;\n    while (!QueueEmpty(q))\n    {\n        d = Front(q);\n        QueuePop(q);\n        for (int i = 0; i < 4; i++)\n        {\n            int tx = d.x + ds[i][0];\n            int ty = d.y + ds[i][1];\n            if (tx == x2 && ty == y2)\n            {\n                return d.len+1;\n            }\n            if (tx >= 0 && tx < m && ty >= 0 && ty < n && a[tx][ty] == 0)\n            {\n                QDataType t = {tx, ty, d.len+1};\n                QueuePush(q, t);\n                a[tx][ty] = 2;\n           }\n        }\n    }\n    return 0;\n}\n\nint main()\n{\n    int x1, y1, x2, y2;\n    int i, j;\n    q = (Queue *)malloc(sizeof(Queue));\n    QueueInit(q);\n    scanf(\"%d %d\", &m, &n);\n    for (i = 0; i < m; i++)\n    {\n        for (j = 0; j < n; j++)\n            scanf(\"%d\", &a[i][j]);\n    }\n    scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n    int len = bfs(x1, y1, x2, y2);\n    if (len>0)\n    {\n        printf(\"%d\", len);\n    }\n    else\n    {\n        printf(\"no path!\");\n    }\n    return 0;\n}\n\n", "Konwledge_Point": "负权边的最短路径", "Question": "c语言，运用队列的数据结构知识求解迷宫问题的最短路径步数。\n问题遇到的现象和发生背景\n\n\n给定一迷宫以及入口和出口的坐标，要求寻找从入口到出口的最短距离。\nInput\n第一行两个数m和n表示迷宫的行数和列数。迷宫大小不超过45×45。\n\n\n接下来是m行n列的数，用来表示迷宫，1表示墙，0表示通路。\n\n\n第二行四个数x1,y1,x2,y2分别表示起点和终点的坐标。\n\n\nOutput\n从起点到终点所经过的最短路径长度，如果不存在，输出\"no path!\"\n\n\nSample Input\n8 8\n0 0 0 0 0 0 0 1\n0 1 1 1 1 0 0 0\n0 1 0 1 1 1 1 0\n0 1 1 0 0 0 0 0\n0 0 0 1 0 1 1 1\n0 1 0 0 0 0 0 0\n0 1 1 1 1 1 1 0\n0 0 0 0 0 0 0 0\n0 0 1 7\nSample Output\n8\n\n\n问题相关代码，请勿粘贴截图\n\n\n运行结果及报错内容\n\n\n我的解答思路和尝试过的方法\n\n\n用队列求解。\n\n\n我想要达到的结果\n\n\n不同于网上找到的答案的，运用c语言的知识。", "Tag": "算法分析"}
{"Answer": "基于最新版ChatGPT4的回答，望采纳!!!有其他问题也可以询问我哦、”(最新版更智能，功能更加强大)\n你可以通过修改遗传算法来解决这个问题。在这种情况下，你可以将问题建模为一个从起点到三个终点之一的最短路径问题。首先，需要创建一个适应度函数来评估路径的总长度。然后，通过模拟退火算法来搜索最佳解。以下是一个简化的MATLAB实现：\nfunction [best_path, shortest_dist] = sa_tsp(dist_matrix, start_node, end_nodes, num_iterations, T0, alpha)\n\n    n = size(dist_matrix, 1);\n    num_end_nodes = numel(end_nodes);\n\n    % 初始化路径\n    path = [start_node, setdiff(1:n, [start_node, end_nodes])];\n\n    % 初始化温度\n    T = T0;\n\n    best_path = path;\n    shortest_dist = Inf;\n\n    for i = 1:num_iterations\n        % 产生新解\n        new_path = generate_new_path(path);\n\n        % 计算适应度值\n        new_dist = calc_path_distance(new_path, dist_matrix, end_nodes);\n\n        % Metropolis准则\n        if new_dist < shortest_dist || exp((shortest_dist - new_dist) / T) > rand()\n            path = new_path;\n            if new_dist < shortest_dist\n                shortest_dist = new_dist;\n                best_path = new_path;\n            end\n        end\n\n        % 降低温度\n        T = alpha * T;\n    end\nend\n\nfunction new_path = generate_new_path(path)\n    n = numel(path);\n    idx = randperm(n - 1, 2) + 1; % 随机选择两个点，但不包括起点\n    new_path = path;\n    new_path(idx) = path(fliplr(idx)); % 交换两个点\nend\n\nfunction total_dist = calc_path_distance(path, dist_matrix, end_nodes)\n    n = numel(path);\n    total_dist = sum(dist_matrix(sub2ind(size(dist_matrix), path(1:n-1), path(2:n))));\n\n    % 计算到所有终点的距离\n    end_dists = dist_matrix(path(end), end_nodes);\n    total_dist = total_dist + min(end_dists); % 只保留最短的距离\nend\n\n使用此函数时，你需要提供距离矩阵、起始点、终点、迭代次数、初始温度和温度衰减系数。示例如下：\n% 创建距离矩阵\ndist_matrix = ...\n\n% 设置起点和终点\nstart_node = 1;\nend_nodes = [10, 11, 12];\n\n% 设置模拟退火参数\nnum_iterations = 10000;\nT0 = 100;\nalpha = 0.99;\n\n% 调用函数\n[best_path, shortest_dist] = sa_tsp(dist_matrix, start_node, end_nodes, num_iterations, T0, alpha);\n\n请注意，这个实现是一个简化版，你可能需要根据问题规模和计算能力来调整参数。", "Konwledge_Point": "负权边的最短路径", "Question": "matlab加上模拟退火算法求解最短路问题\n从一个点出发，在剩余的点中搜索，终点有三个但是要求到其中一个终点的最短距离。我试了用tsp方法求解，但是我不需要形成回路所以不对。", "Tag": "算法分析"}
{"Answer": "可以使用 Network Analyst 工具来计算最小成本路径。要做的第一步是构建网络数据集，其中包含了您要使用的道路、铁路和公路数据。然后，可以使用权值表达式来定义成本函数，指定坡度、海拔和铁路/公路缓冲区对成本的影响。最后，使用 Network Analyst 工具中的最短路径分析工具来计算起点和终点之间的最小成本路径。", "Konwledge_Point": "负权边的最短路径", "Question": "ARCGIS最小成本路径计算\n计算最小成本路径，出行成本为1000*(1+坡度/10)^2*(1+海拔/2000)，铁路周边1000米缓冲区内出行成本为500，公路周边500米缓冲区内出行成本为800", "Tag": "算法分析"}
{"Answer": "i表示步数，从a顶点出发到b顶点只需要1步，故i=1。到其他顶点，以此类推；从a到d有3种走法，最短路径和是5（2+3，即 a -> b -> d），其他两种走法是  a -> c -> d， a -> b -> c -> d；∞表无穷大，即从某个节点到某个顶点之间是不可达。", "Konwledge_Point": "负权边的最短路径", "Question": "迪杰斯特拉算法求最短路径\n看不大懂以下这种迪杰斯特拉求最短路径的方法\n\n\n\n\n\n\n主要疑惑如下：\n1.答案中的i代表的是什么？\n2.为什么会有多个重复的结果出现，例如d行中有三个是完全一模一样的\n3.不是很能理解∞代表的是什么", "Tag": "算法分析"}
{"Answer": "最短路径不对，路径最短不代表它是由最短的边组成的比如最短的路径是1,100，第二短的路径是102条长度为1的路径组成，很显然最短路径跟这题完全不是同一个问题而且求最短路径你需要验证每个路径，很耗费时间这题其实最适合用贪心算法求，反正每路过一个节点，你都走最短的那条就对了", "Konwledge_Point": "负权边的最短路径", "Question": "与无向图最短路径有关\n问题\n：一个无向图有n个点，m条边，你现在在1号点，每条边有个对能力值的限制，要大于等于这个限制才能通过它。他们想知道他们至少要有多大的能力值，才能从1号点到n号点。\n\n\n输入\n：第一行两个正整数n,m。分别表示图的大小和边的数量。\n接下来m行，每行3个整数 u,v,l 。表示有一条u到v的边，至少要l能力值才能通过。地图保证1和n是连通的。\n\n\n数据规模\n：对于30%的数据： n<=m<=8\n对于100%的数据 , n<=m<=10^6,1<=u,v<=n,0<=l<=10^9\n\n\n输出描述\n：需要获得的最小的能力值，能够从1到n\n\n\n我的想法和出现的问题\n：我本来打算先求最短路径的，再找出最短路径上最长的一条边的值，但是它测试数据太大了，我邻接矩阵一开数组就爆栈了。有没有什么不爆数组的思路啊。", "Tag": "算法分析"}
{"Answer": "D\n最短路径算法：一个是迪杰斯特拉算法，求从某个源点到其余各顶点的最短路径，求解过程按路径长度递增的次序产生的最短路径，时间复杂度是O(n^2) ; 另一种算法是弗洛伊德算法，求 每一对顶点之间的最短路径，时间复杂度为O(n^3)。", "Konwledge_Point": "负权边的最短路径", "Question": "与费洛伊德算法中最短路径的时间复杂度相关的疑问\n请教图片中的这个内容该怎么做呢，我能该如何去解决，与费洛伊德算法中最短路径的时间复杂度相关的疑问", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/H_Anonymity/article/details/78107354", "Konwledge_Point": "负权边的最短路径", "Question": "C语言解决一个关于最短路径的花费的问题，怎么利用C解决\nProblem Description\n\nThere is an old country and the king fell in love with a devil. The devil always ask the king to do some crazy things. Although the king used to be wise and beloved by his people. Now he is just like a boy in love and can’t refuse any request from the devil. Also, this devil is looking like a very cute Loli.\n\n\n\nSomething bad actually happen. The devil makes this kingdom's people infected by a disease called lolicon. Lolicon will take away people's life in silence. \n\n\n\nAlthough z*p is died, his friend, y*wan is not a lolicon. Y*wan is the only one in the country who is immune of lolicon, because he like the adult one so much. \n\n\n\nAs this country is going to hell, y*wan want to save this country from lolicon, so he starts his journey.\n\n\n\nYou heard about it and want to help y*wan, but y*wan questioned your IQ, and give you a question, so you should solve it to prove your IQ is high enough.\n\n\n\nThe problem is about counting. How many undirected graphs satisfied the following constraints?\n\n\n\n\n\nThis graph is a complete graph of size n. \n\n\nEvery edge has integer cost from 1 to L.\n\n\nThe cost of the shortest path from 1 to n is k.\n\n\nCan you solve it?\n\n\n\noutput the answer modulo 10^9+7\n\n\n\nInput\n\nThe first line contains an integer T, denoting the number of the test cases.\n\nFor each test case, the first line contains 3 integers n,k,L.\n\n\n\nT<=5 n,k<=12,L<=10^9.\n\n\n\nOutput\n\nFor each test case, output the answer in one line.\n\n\n\nSample Input\n\n2\n\n3 3 3\n\n4 4 4\n\n\n\nSample Output\n\n8\n\n668", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/lin375691011/article/details/38405413", "Konwledge_Point": "负权边的最短路径", "Question": "Single-Player Games             \nDescription\n\n\n\nPlaying games is the most fun if other people take part. But other players are not always available if you need them, which led to the invention of single-player games. One of the most well-known examples is the infamous \nSolitaire'' packaged with Windows, probably responsible for more wasted hours in offices around the world than any other game. \n\nThe goal of a single-player game is usually to make\nmoves'' until one reaches a final state of the game, which results in a win or loss, or a score assigned to that final state. Most players try to optimize the result of the game by employing good strategies. In this problem we are interested in what happens if one plays randomly. After all, these games are mostly used to waste time, and playing randomly achieves this goal as well as any other strategy. \n\n\n\nGames can very compactly represented as (possibly infinite) trees. Every node of the tree repre- sents a possible game state. The root of the tree corresponds to the starting position of the game. For an inner node, its children are the game states to which one can move in a single move. The leaf nodes are the final states, and every one of them is assigned a number, which is the score one receives when ending up at that leaf. \n\n\n\n\nTrees are defined using the following grammar. \n\n\n\nDefinition ::= Identifier \"=\" RealTree \n\nRealTree ::= \"(\"Tree+\")\" \n\nTree ::= Identifier | Integer | \"(\"Tree+\")\" \n\nIdentifier ::= a|b|...|z \n\nInteger ∈ {...,-3,-2,-1,0,1,2,3,...,} \n\n\n\nBy using a Definition, the RealTree on the right-hand side of the equation is assigned to the Identifier on the left. A RealTree consists of a root node and one or more children, given as a sequence enclosed in brackets. And a Tree is either \n\n\n\n. the tree represented by a given Identifier, or \n\n\n\n. a leaf node, represented by a single Integer, or \n\n\n\n. an inner node, represented by a sequence of one or more Trees (its children), enclosed in brackets. \n\n\n\nYour goal is to compute the expected score, if one plays randomly, i.e. at each inner node selects one of the children uniformly at random. This expected score is well-defined even for the infinite trees definable in our framework as long as the probability that the game ends (playing randomly) is 1. \n\nInput\n\n\n\nThe input file contains several gametree descriptions. Each description starts with a line containing the number n of identifiers used in the description. The identifiers used will be the first n lowercase letters of the alphabet. The following n lines contain the definitions of these identifiers (in the order a, b, ...). Each definition may contain arbitrary whitespace (but of course there will be no spaces within a single integer). The right hand side of a definition will contain only identifiers from the first n lowercase letters. The inputs ends with a test case starting with n = 0. This test case should not be processed.\n\nOutput\n\n\n\nFor each gametree description in the input, first output the number of the game. Then, for all n identifiers in the order a, b, ..., output the following. If an identifier represents a gametree for which the probability of finishing the game is 1, print the expected score (when playing randomly). This value should be exact to three digits to the right of the decimal point. \n\n\n\nIf the game described by the variable does not end with probability 1, print ``Expected score of id undefined'' instead. Output a blank line after each test case.\n\nSample Input\n\n\n\n1\n\na = ((1 7) 6 ((8 3) 4))\n\n2\n\na = (1 b)\n\nb = (4 a)\n\n1\n\na = (a a a)\n\n0\n\nSample Output\n\n\n\nGame 1\n\nExpected score for a = 4.917\n\n\n\nGame 2\n\nExpected score for a = 2.000\n\nExpected score for b = 3.000\n\n\n\nGame 3\n\nExpected score for a undefined", "Tag": "算法分析"}
{"Answer": "超时了，换个算法", "Konwledge_Point": "负权边的最短路径", "Question": "洛谷P4779最短路径问题TLE\n\n\n#include\nusing namespace std;\nint  a[10005][10005];\nint  d[10005],i,j;\nconst int INF=1e9;\nint t;\nint read()\n{\n    int x=0,y=1;\n    char c;\n    while(c<'0'||c>'9'){if(c=='-')y=-1;c=getchar();}\n    while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}\n    return x*y;\n}\nvoid dij(int n)//单源最短路径\n{\n    bool f[10005]={0};\n    f[1]=1;\n    int v;\n    for(i=1;id[j])//找未标记中最小的\n            {\n                min=d[j];\n                v=j;\n            }\n        }\n        f[v]=1;//标记\n        for(j=v;j<=n;j++)\n        {\n            if(!f[j]&&a[v][j]+d[v]<d[j])//更新路径长度\n            {\n                d[j]=a[v][j]+d[v];\n            }\n        }\n    }\n}\n\n\nint main()\n{\n    int n,m,x,y,z;\n    n=read(),m=read(),t=read();\n    for(i=1;i<=m;i++)\n    {\n        x=read(),y=read(),z=read();\n        a[x][y]=z;\n    }\n    for(i=1;i<=n;i++)\n    {\n        d[i]=a[t][i];//路径长度初始化]]\n    }\n    dij(n);\n    for(i=1;i<=n;i++)\n    {\n        printf(\"%d\\n\",d[i]);\n    }\n    return 0;\n}\n爆TLE，请问这个程序哪里出了问题？", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/xs18952904/article/details/84670271", "Konwledge_Point": "负权边的最短路径", "Question": "利用C语言的程序设计的技术，计算这个图中的最长最短路径的算法怎么实现\nProblem Description\n\nThe graph diameter is the length of the \"longest shortest path\" between any two vertices of a graph. In other words, a graph's diameter is the longest path which must be traversed in order to travel from any vertex to another when paths which backtrack, detour, or loop are excluded from consideration.\n\nGiven an undirected graph, your mission is to count the number of diameters of it.\n\n\n\nInput\n\nThe input contains multiple test cases. \n\nFor each test case, it contains n+1 lines. \n\nLine 1: two integers m, n (2<= m <= 100, 1 <= n <= 4000) indicating that there are m vertices and n edges in the city. \n\nLine 2~n+1: each contains three integers i, j, d (1 <= i, j <= m, 1 <= d <= 100), indicating that there is an edge of length d connecting vertex i and vertex j.\n\n\n\nOutput\n\nOutput the value of the diameter and the number of diameters in a single line, separated by a single space.\n\n\n\nSample Input\n\n4 5 \n\n1 2 1 \n\n2 3 1 \n\n3 4 1 \n\n1 4 1 \n\n1 3 2 \n\n\n\nSample Output\n\n2 5", "Tag": "算法分析"}
{"Answer": "#include<bits/stdc++.h>using namespace std;char a[1005],b[1005],e,f;int n,d[27][27],s=0;int main(){    cin>>a>>b;    cin>>n;    for(int i=0;i<n;i++){        cin>>e>>f;        d[e-'a'][f-'a']=d[f-'a'][e-'a']=1;    }    for(int k=0;k<27;k++){        for(int i=0;i<27;i++){            for(int j=0;j<27;j++){                if(d[i][k]!=0&&d[k][j]!=0&&i!=j){                    if(d[i][j]==0) d[i][j]=d[i][k]+d[k][j];                    else d[i][j]=min(d[i][j],d[i][k]+d[k][j]);                }            }        }    }    for(int i=0;i<strlen(a);i++){        s+=d[a[i]-'a'][b[i]-'a'];    }    cout<<s;    return 0;} ", "Konwledge_Point": "负权边的最短路径", "Question": "弗洛伊德算法求多源最短路径\n\n\n\n", "Tag": "算法分析"}
{"Answer": "\n \n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 100;\nstruct Edge{\n    int next;\n    int to;\n    int len;\n    int speed;\n}edge[MAXN];\nint cnt;\nint head[MAXN];\nvoid Add_Edge(int u, int v, int speed, int len){\n    edge[cnt].next = head[u];\n    edge[cnt].to = v;\n    edge[cnt].speed = speed;\n    edge[cnt].len = len;\n    head[u] = cnt++;\n}\nint dis[MAXN];\nstruct st{\n    int id;\n    int dis;\n    bool operator < (const st &B)const{\n        return dis > B.dis;\n    }\n};\nint vis[MAXN];\nconst int INF = 0x3f3f3f3f;\nvoid dijkstra(int s){\n    dis[s] = 0;\n    priority_queue<st> q;\n    q.push(st{s, dis[s]});\n    while(!q.empty()){\n        auto u = q.top();\n        q.pop();\n        if(vis[u.id]) continue;\n        vis[u.id] = 1;\n        for(int i=head[u.id];~i;i=edge[i].next){\n            int v = edge[i].to;\n            if(!vis[v] && dis[u.id] + edge[i].len < dis[v]){\n                dis[v] = dis[u.id] + edge[i].len;\n                q.push(st{v, dis[v]});\n            }\n        }\n    }\n}\nconst double eps = 1e-10;\nint dcmp(double x){\n    if(fabs(x) < eps) return 0;\n    return x < 0 ? -1 : 1;\n}\nstruct st2{\n    int id;\n    double t;\n    bool operator < (const st2 &B)const{\n        return dcmp(t - B.t) > 0;\n    }\n};\ndouble dis2[MAXN];\nconst double INF2 = 999999999.0;\nvoid dijkstra2(int s){\n    dis2[s] = 0.0;\n    priority_queue<st2> q;\n    q.push(st2{s, dis2[s]});\n    while(!q.empty()){\n        auto u = q.top();\n        q.pop();\n        if(vis[u.id]) continue;\n        vis[u.id] = 1;\n        for(int i=head[u.id];~i;i=edge[i].next){\n            int v = edge[i].to;\n            if(!vis[v] && dcmp(dis2[v] - dis2[u.id] - edge[i].len * 1.0 / edge[i].speed) > 0){\n                dis2[v] = dis2[u.id] + edge[i].len * 1.0 / edge[i].speed;\n                q.push(st2{v, dis2[v]});\n            }\n        }\n    }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin >> n >> m;\n    memset(head, -1, sizeof head);\n    memset(dis, 0x3f, sizeof dis);\n    for(int i=0;i<m;i++){\n        int u, v, speed, len;\n        cin >> u >> v >> speed >> len;\n        Add_Edge(u, v, speed, len);\n        Add_Edge(v, u, speed, len);\n    }\n    int q;\n    dijkstra(1);\n    memset(vis, 0, sizeof vis);\n    for(int i=0;i<=n;i++) dis2[i] = INF2;\n    dijkstra2(1);\n    cin >> q;\n    while(q--){\n        int j;\n        char c;\n        cin >> j >> c;\n        if(c == 's'){\n            if(dis[j] == INF) cout << \"IMPOSSIBLE\\n\";\n            else cout << dis[j] << ' ' << \"km\\n\";\n        }else{\n            if(dcmp(dis2[j] - INF2) == 0) cout << \"IMPOSSIBLE\\n\";\n            else cout << fixed << setprecision(8) << dis2[j] << ' ' << \"h\\n\";\n        }\n    }\n    return 0;\n}\n", "Konwledge_Point": "负权边的最短路径", "Question": "算法题求解！最短路径+动态规划 C++\n题目设计：\n你怀疑你的导航系统有时会选择低效的路线。\n所以你决定收集一些关于你所在地区的道路系统的数据并编写一个程序，计算出从你的家到你所在地区的最短（综合道路长度）和最快（预期旅行时间）的路线。\n为了使这一任务易于管理，你想出了一个简单的模型。道路系统道路系统由路口（数字从1到N）和连接它们的道路组成，每条道路都有一个限速（单位：km/h）和一个长度（单位：km）。\n在其中一个路口转换道路既不耗费时间也不耗费距离。\n为了简单起见，你还假设所有的道路都是双向的，并且你可以一直以限速行驶。\n\n\n输入的内容包括\n\n\n一行包含N和M(2 ≤ N ≤ 5 · 10^4^, 1 ≤ M ≤ 2 · 10^5^) --分别表示路口和道路的数量\nM行描述道路，第 i 行包含bi, ei, vi和 i (1 ≤ bi，ei≤N，20≤vi≤150，1≤ i ≤300）分别代表第i条道路，与其连接的路口，速度限制和长度（所有这些输入都是整数)\n一行包含 Q（1 ≤ Q ≤ 1000）--查询的数量\nQ行给出查询，每行包括一个整数 j：目的地路口的索引和一个字符c∈{'s', 'f'}\n\n\n 输出\n\n\n对于's'类型的查询，输出从你的家（1号路口）到指定目的地的最短路线的长度。\n对于'f'类型的查询，输出从你的家到指定目的地的最短旅行时间（假设一直按限速行驶），精度为10^-3^\n使用与输入相同的单位，用空格分隔数量和单位。如果一个给定的目的地不能到达，输出 \"IMPOSSIBLE\"。\n\n\n例如：\n\n\n\n\n第三组：\n20 80\n19 15 57 179\n20 20 125 175\n5 4 60 34\n9 10 24 85\n18 8 114 244\n19 9 23 245\n1 5 115 132\n7 17 45 117\n6 12 24 109\n1 12 116 83\n3 3 83 270\n20 20 145 65\n9 13 78 47\n11 14 40 152\n9 15 79 70\n18 9 72 101\n19 5 105 282\n2 3 120 90\n20 13 105 186\n2 4 72 145\n13 18 103 90\n1 3 26 143\n19 13 45 7\n5 14 39 295\n9 7 74 218\n15 5 73 131\n6 15 79 255\n6 15 56 113\n14 5 40 157\n17 17 57 216\n17 14 106 260\n18 9 121 201\n7 11 76 25\n14 17 20 144\n10 6 49 285\n6 16 88 95\n6 4 82 96\n10 16 121 187\n19 11 100 294\n6 9 129 241\n4 4 90 99\n11 15 79 130\n5 8 95 108\n19 15 29 285\n19 20 122 280\n19 13 76 13\n12 16 67 88\n18 10 107 56\n2 18 147 300\n6 15 27 130\n16 6 80 28\n8 5 101 96\n16 16 76 130\n12 3 134 1\n17 4 145 284\n14 9 24 203\n5 13 39 140\n12 9 116 254\n5 12 141 52\n16 3 68 95\n17 1 44 14\n12 20 62 161\n18 16 129 72\n16 18 117 114\n20 17 128 271\n2 1 92 255\n1 19 74 115\n15 2 57 240\n18 7 41 140\n14 1 107 280\n4 6 66 205\n6 10 60 209\n17 2 112 42\n8 2 45 14\n7 16 59 33\n13 16 40 270\n17 6 41 59\n4 13 57 245\n19 11 55 97\n2 8 115 80\n10\n2 s\n15 f\n7 s\n17 f\n8 f\n9 f\n17 s\n16 f\n2 s\n3 f\n\n\n输出：\n56 km\n2.87883212 h\n131 km\n0.31818182 h\n1.00429293 h\n2.31217371 h\n14 km\n2.02895008 h\n56 km\n0.72297993 h\n\n\n关于这道题应该要用到Dijkstra算法或者Moore-Bellman-Ford 算法？希望可以给个详细点的代码，谢谢！\n学到的算法如下代码\n\n\nvoid\n dijkstra_set (\nint\n s, \nint\n n) {\n    fill (d, d + n + \n1\n, INF ) ;\n    d[s] = \n0\n;\n\n    \nset\n  > dst ;\n    dst . \ninsert\n ({d[s], s}) ;\n\n    \nwhile\n (! dst. empty () ) {\n        \nint\n v = dst . \nbegin\n () -> second ;\n        dst . erase ( dst . \nbegin\n () );\n        \nfor\n ( auto e: edges [v])\n              \nif\n (d[v] + e. \ncost\n < d[e.u]) {\n                  dst . erase ({d[e.u], e.u}) ;\n                  d[e.u] = d[v] + e. \ncost\n ;\n                  dst . \ninsert\n ({d[e.u], e.u}) ;\n              }\n     }\n}\n", "Tag": "算法分析"}
{"Answer": "http://xueshu.baidu.com/s?wd=paperuri:(bf07b4fc89e69e391ee525c9d6ddee1c)&filter=sc_long_sign≻_ks_para=q%3D%E5%9F%BA%E4%BA%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%9A%84%E6%97%A0%E4%BA%BA%E6%9C%BA%E8%88%AA%E8%B7%AF%E8%A7%84%E5%88%92&tn=SE_baiduxueshu_c1gjeupa&ie=utf-8≻_us=14669995398736205306", "Konwledge_Point": "负权边的最短路径", "Question": "无人机最短飞行路径问题\n假设无人机有扫描半径r，给定一待测区域，要求无人机能够扫描到区域中的所有位置，并返回无人机起飞点，总飞行路程尽可能短（省电啊）。\n\n求问飞行路线怎么设计，给出大致思路就行。\n\n        1.矩形区域\n\n                 矩形区域尺寸为W×H，起飞点在矩形的边上任一点\n\n                2.圆形区域\n\n                   圆形区域半径为R，起飞点在圆边上任一点", "Tag": "算法分析"}
{"Answer": "邻接表：\n#include<iostream>\n#include<cstring>\n#include<string>\n#include<iomanip>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\n#include<queue>\n#include<deque>\n#include<vector>\nint i,j,a,b,n1,m1;\nusing namespace std;\n\nstruct node\n{\n    int v;\n    int w;\n};\nvector<node> e[105];\nint n,m,vis[100001],mapa[1001][1001],ans=1000000001;\nvoid dfs(int x,int dis)\n{\n    int i;\n    if(dis>=ans)//小剪枝 \n        return;\n        \n    if(x==n)\n    {\n        ans=min(ans,dis);\n        return;\n    }\n    node tt; \n    for(int i=0;i<e[x].size();i++)\n    {\n        tt=e[x][i];\n        if(vis[tt.v]==0)\n        {\n            vis[tt.v]=1;\n            dfs(tt.v,dis+tt.w);\n            vis[tt.v]=0;\n        }\n    } \n}\nint main()\n{\n    node t;\n    cin>>n>>m>>n1>>m1;\n    //memset(mapa,0x3f,sizeof(mapa));//初始化\n     \n    for(j=0;j<m;j++)\n    {\n        cin>>a>>b;\n        t.v=b;\n        t.w=1;\n        e[a].push_back(t);\n        t.v=a;\n        t.w=1;\n        e[b].push_back(t);\n       \n    }\n    vis[1]=1;\n    dfs(1,0);\n    cout<<ans<<endl;\n    return 0;\n}\n\n\n邻接矩阵：\n#include<bits/stdc++.h>\nusing namespace std;\nint n,m,vis[100001],mapa[1001][1001],ans=1000000001;\nvoid dfs(int x,int dis)\n{\n    int i;\n    if(dis>ans)//小剪枝 \n        return;\n    if(x==n)\n    {\n        ans=min(ans,dis);\n        return;\n    }\n    for(i=1;i<=n;i++) //不一定向前走，可能绕一下更近 \n    if(mapa[x][i]!=0x3f3f3f3f&&vis[i]==0) \n    {\n        vis[i]=1;\n        dfs(i,dis+mapa[x][i]);\n        vis[i]=0;\n     } \n}\nint main()\n{\n    int i,j,a,b,n1,m1;\n    cin>>n>>m>>n1>>m1;\n    memset(mapa,0x3f,sizeof(mapa));\n    for(j=0;j<m;j++)\n    {\n        cin>>a>>b;\n        mapa[b][a]=1;//保证单向 \n        mapa[a][b]=1;\n    }\n    vis[1]=1;\n    dfs(1,0);\n    cout<<ans<<endl;\n    return 0;\n}\n\n\n链式前向星\n#include<iostream>\n#include<cstring>\n#include<string>\n#include<iomanip>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\n#include<queue>\n#include<deque>\nusing namespace std;\n\nstruct edge\n{\n    int to;\n    int nxt;\n}e[300]; \nint cnt;\nint h[105];\nvoid addedge(int u,int v)\n{\n    cnt++;\n    e[cnt].to=v;\n    e[cnt].nxt=h[u];\n    h[u]=cnt;\n}\nint n,m,vis[100001],mapa[1001][1001],ans=1000000001;\nvoid dfs(int x,int dis)\n{\n    int i;\n    if(dis>=ans)\n        return;\n    if(x==n)\n    {\n        ans=min(ans,dis);\n        return;\n    }\n    for(int i=h[x];i>0;i=e[i].nxt)\n    {\n        int to=e[i].to;\n        if(vis[to]==0)\n        {\n            vis[to]=1;\n            dfs(to,dis+1);\n            vis[to]=0;\n        }\n    }\n}\nint main()\n{\n    int n1,m1; \n    cin>>n>>m>>n1>>m1;\n    int i,j,a,b,c;\n    for(j=0;j<m;j++)\n    {\n        cin>>a>>b;\n        addedge(a,b);\n        addedge(b,a);\n    }\n    vis[1]=1;\n    dfs(1,0);\n    cout<<ans<<endl;\n    return 0;\n}\n\n", "Konwledge_Point": "负权边的最短路径", "Question": "最小换乘，求最短路径的问题\n设某城市有n个车站，并有m条公交线路连接这些车站。设这些公交\n车都是单向的，这n个车站被顺序编号为0-n-l。本程序，输入该城市的公交线\n路数、车站个数、以及各公交线路上的各站编号。\n要求:\n\n\n（1求从站0出发乘公交车至其他车站的最少换车次数，并输出所经过的站点序\n列;\n(2利用输入信息构建一张有向图，分别用邻接矩阵和邻接表表示，并输出邻接\n矩阵和邻接表信息;\n\n\n(3从站0出发，对公交线路图进行遍历。\n\n\n收起全部 ", "Tag": "算法分析"}
{"Answer": "i=1, 2, 3, 4, 5, 6表示第几次迭代", "Konwledge_Point": "负权边的最短路径", "Question": "数据结构，最短路径问题求解？\n这个表里的i时什么意思？那个i=1 2 3 4 5 6，这个i是什么意思？", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/qq_35710556/article/details/79583229\n五种最短路径算法，自己研究一下", "Konwledge_Point": "负权边的最短路径", "Question": "C++求给出图的最短路径问题\n\n\n\n ", "Tag": "算法分析"}
{"Answer": "迷宫问题算法的根本思想来源于回溯思想，就是从某点出发，根据深度或广度原则不断查找并记录所有走过的路径 遇到不可达或该节点相邻节点遍历完毕即退回如果说走路径符合题目要求就记录，不符合不记录所以这个题关键是选对和理解回溯算法回溯思想有很多介绍的资源，建议仔细阅读而那两个原则是回溯算法中的采取的遍历原则换一种角度去理解，这个题就不那么难了，自己也能写出答案", "Konwledge_Point": "负权边的最短路径", "Question": "python迷宫问题输出所有路径的条数，，最好用BFS或者DFS解决\n我能用BFS和DFS输出路径和最短路径，但是所有路径条数没思路，下面是我的代码，请大佬们帮个忙。最好能在我的代码基础上写出来\n\n", "Tag": "算法分析"}
{"Answer": "\nPlenty of reading/algorithms:\nShortest path problem. You effectively just have every edge (\"link\", as you called it) with an equal weight.\n", "Konwledge_Point": "负权边的最短路径", "Question": "线性阵列，节点随机链接到阵列中的其他节点，最短路径\n\n\n\nINFO:\nI have an Array of 100 nodes, [ 0 .. 99 ].  Each node can have an arbitrary number of linked nodes:\n\n\n\neg1, 0 links to 5, 10, 15, 20.\neg2, 1 links to 30, 40, 50.\neg3, etc..\n\n\n\nAll 100 nodes have at least one linked node, nodes do not know who links to them.\n\n\n\nQUESTION:\nHow can I find the shortest link-path if provided with START and END.\n\n\n\neg. START=5, END=80, Link Path (example) : [5]->10->24->36->[80]?\n\n\n\nI'm using Pascal and/or PHP, but understanding how is what I'm looking for [code helps too].\n\n    ", "Tag": "算法分析"}
{"Answer": "\nDijkstra should pass, I just make a submission using JAVA, and it took less than a second to complete each task.\nAs I have mentioned, each value in the matrix can go up to 10^9, your solution can encounter a number overflow problem, which can effect the running time.\nMy code:\n<!-- language:java -->\n\nstatic int[]X = {0,1,0,-1};\nstatic int[]Y = {1,0,-1,0};\npublic static void main(String[] args) throws FileNotFoundException {\n    // PrintWriter out = new PrintWriter(new FileOutputStream(new File(\n    // \"output.txt\")));\n    PrintWriter out = new PrintWriter(System.out);\n    Scanner in = new Scanner();        \n    int n = in.nextInt();\n    long[][]map = new long[n][n];\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            map[i][j] = in.nextLong();\n        }\n    }\n    PriorityQueue<Pos> q= new PriorityQueue();\n    long[][]dist = new long[n][n];\n    for(long[]a : dist){\n        Arrays.fill(a,Long.MAX_VALUE);\n    }\n    q.add(new Pos(0,0,map[0][0]));\n    dist[0][0] = map[0][0];\n    while(!q.isEmpty()){\n        Pos p = q.poll();\n        if(dist[p.x][p.y] == p.cost){\n            for(int i = 0; i < 4; i++){\n                int x = p.x + X[i];\n                int y = p.y + Y[i];\n                if(x >= 0 && y >= 0 && x < n && y < n && dist[x][y] > dist[p.x][p.y] + map[x][y] ){\n                    dist[x][y] = dist[p.x][p.y] + map[x][y];\n                    q.add(new Pos(x,y,dist[x][y]));\n                }\n            }\n        }\n    }\n    out.println(dist[n - 1][n - 1]);\n    out.close();\n}\n\nstatic class Pos implements Comparable<Pos>{\n    int x, y;\n    long cost;\n    public Pos(int x, int y, long cost) {\n        super();\n        this.x = x;\n        this.y = y;\n        this.cost = cost;\n    }\n    @Override\n    public int compareTo(Pos o) {\n        // TODO Auto-generated method stub\n        return Long.compare(cost, o.cost );\n    }\n}\n\nUpdate:\nI think your Dijkstra implementation is not correct:\nfor frontier.Len() > 0 {\n    element := heap.Pop(&frontier).(*Item)\n    vertex, cost := element.value, element.priority\n    //You didn't check for visited vertex here!\n    visited[vertex] = true\n    neighbors := graph[vertex]\n    for vertex_new, cost_new := range(neighbors){\n        if !visited[vertex_new]{//You can add same vertex multiple times here!\n            if vertex_new == end{\n                return cost + cost_new\n            }\n            heap.Push(&frontier, &Item{\n                value: vertex_new,\n                priority: cost + cost_new,\n            })\n        }\n    }\n}\n\nIn your implementation, you only update visited when the vertex pop out of the heap, thus, one vertex can be added and processed multiple time, so, it will significantly increase your time complexity.\nTo fix\nfor frontier.Len() > 0 {\n    element := heap.Pop(&frontier).(*Item)\n    vertex, cost := element.value, element.priority\n    if !visited[vertex]{\n        visited[vertex] = true\n        neighbors := graph[vertex]\n        for vertex_new, cost_new := range(neighbors){\n            if !visited[vertex_new]{\n                if vertex_new == end{\n                   return cost + cost_new\n                }\n                heap.Push(&frontier, &Item{\n                   value: vertex_new,\n                   priority: cost + cost_new,\n                })\n            }\n        }   \n    }\n\n", "Konwledge_Point": "负权边的最短路径", "Question": "在矩阵中找到最短路径总和。  Dijkstra是否不适用于这种情况？\n\n\n\nI am trying to solve \nthe following problem from project euler\n (please take a look at description and the example in the link, but here is the short explanation).\n\n\n\n\n  \nin the matrix, find the  minimal path sum from the top left to the bottom right, by moving left, right, up, and down\n\n\n\n\n\nRight after I looked at the problem, the obvious solution which came to mind is to create a graph from the matrix and then use \nDijkstra\n to find the shortest path.\n\n\n\nTo construct a graph from a \nN*M\n matrix, for every \n(i, j)\n element I create a vertex \ni * N + j\n and connect it to any other vertex (to which it is possible to connect with UP, RIGHT, DOWN, LEFT) and the edge will be the value of the element I am connecting to in the matrix. After that I create 2 other vertices \n-1\n connected to vertex \n0\n and \n-2\n connected to \nN*M - 1\n which will be my start and end vertices (both connection have 0 cost).\n\n\n\nAfter this I am doing Dijkstra to find shortest path cost from \n-1\n to \n-2\n. My Dijkstra implementation uses priority queue and looks this way:\n\n\n\nfunc dijkstraCost(graph map[int]map[int]int, start, end int) int{\n    if start == end{\n        return 0\n    }\n    frontier := make(PriorityQueue, 1)\n    frontier[0] = &Item{value: start, priority: 0, index: 0}\n    visited := map[int]bool{}\n    heap.Init(&frontier)\n\n    for frontier.Len() > 0 {\n        element := heap.Pop(&frontier).(*Item)\n        vertex, cost := element.value, element.priority\n        visited[vertex] = true\n        neighbors := graph[vertex]\n        for vertex_new, cost_new := range(neighbors){\n            if !visited[vertex_new]{\n                if vertex_new == end{\n                    return cost + cost_new\n                }\n                heap.Push(&frontier, &Item{\n                    value: vertex_new,\n                    priority: cost + cost_new,\n                })\n            }\n        }\n    }\n    return -1\n}\n\n\n\n\nwhere Priority Queue implementation is taken from heap container (example PriorityQueue) with one minor modification:\n\n\n\nfunc (pq PriorityQueue) Less(i, j int) bool {\n    return pq[i].priority > pq[j].priority // changed to <\n}\n\n\n\n\nThe graph that I am providing to the function looks like:\n\n\n\nmap[13:map[8:965 18:121 12:746 14:111] 16:map[11:803 21:732 15:537 17:497] 3:map[8:965 2:234 4:18] 4:map[9:150 3:103] 22:map[17:497 21:732 23:37] -1:map[0:131] 17:map[16:699 18:121 12:746 22:524] 1:map[6:96 0:131 2:234] 9:map[4:18 14:111 8:965] 11:map[6:96 16:699 10:630 12:746] 19:map[14:111 24:331 18:121] 24:map[23:37 -2:0 19:956] 2:map[3:103 7:342 1:673] 15:map[10:630 20:805 16:699] 18:map[13:422 23:37 17:497 19:956] 10:map[5:201 15:537 11:803] 14:map[19:956 13:422 9:150] 0:map[5:201 1:673] 6:map[5:201 7:342 1:673 11:803] 8:map[9:150 3:103 13:422 7:342] -2:map[] 12:map[7:342 17:497 11:803 13:422] 20:map[15:537 21:732] 21:map[16:699 20:805 22:524] 5:map[0:131 10:630 6:96] 23:map[18:121 22:524 24:331] 7:map[2:234 12:746 6:96 8:965]]\n\n\n\n\n\n\nThis works correctly but the problem is that it is considered inefficient (judging by \nHackerrank version of the problem\n). It should run find the value of the best solution for \n700x700\n matrix in less than 4 seconds, whereas my solution takes 10 seconds.\n\n\n\nI thought that I am doing something wrong in go, so I reimplemented the same solution in python (where it took approximately 70 seconds for 700x700 matrix)\n\n\n\n\n\nMy question is:\n Am I using the right approach to find the best solution in a matrix. If so what am I doing wrong with my implementation?\n\n\n\nP.S. I have full go and python solution, just thought that even without them the question is too long.\n\n    ", "Tag": "算法分析"}
{"Answer": "ryn 安装和python代码都是python2版本的？", "Konwledge_Point": "负权边的最短路径", "Question": "看到您一篇关于ryu最短路径转发的文章，想咨询您一点问题\n在Ubuntu执行自定义的ryu控制器脚本时出现的问题\nwjc@wjc-virtual-machine:~/ryu/ryu/app$ ryu-manager example_shortestForwarding.py --observe-links\nTraceback (most recent call last):\n  File \"/home/wjc/.local/bin/ryu-manager\", line 5, in \n    from ryu.cmd.manager import main\n  File \"/home/wjc/.local/lib/python2.7/site-packages/ryu/cmd/manager.py\", line 33, in \n    from ryu.app import wsgi\n  File \"/home/wjc/.local/lib/python2.7/site-packages/ryu/app/wsgi.py\", line 23, in \n    from tinyrpc.server import RPCServer\n  File \"/home/wjc/.local/lib/python2.7/site-packages/tinyrpc/\ninit\n.py\", line 4, in \n    from .protocols import *\n  File \"/home/wjc/.local/lib/python2.7/site-packages/tinyrpc/protocols/\ninit\n.py\", line 15\n    def \ninit\n(self) -> None:\n                       ^\nSyntaxError: invalid syntax\n\n\n不知道这个问题应该如何解决", "Tag": "算法分析"}
{"Answer": "我这里以计算x轴方向最小距离举例，设要求的最小距离为dmin\r\n1.以小圆的圆心为坐标原点建立XOY坐标系\r\n2.则小圆的方程为： pow(x,2)+pow(y,2)=pow(r,2) 其中r为小圆的半径，也就是说r是常数\r\n3.则大圆的方程为： pow(x-a,2)+pow(y-b,2)=pow(R,2) 其中R为大圆的半径,（a,b）为大圆的圆心，所以a，b，R也都是常数\r\n4.设y=y0与小圆相交与点A，B（设其中A在B左边）,与大圆相较于C，D两点（设C在D左边），则两圆在x轴方向上的距离则为A点横坐标与C点横坐标之差的绝对值（其中因为直线要与两圆都相交，所以y0的取值范围为[-r,r]）\r\n5.将y=y0带入小圆方程，则可以得到A点横坐标为：- sqrt（pow(r,2)-pow(y0,2)）,C点横坐标为 - sqrt(pow(R,2)-pow(y0-b,2)) + a\r\n6.则两圆x轴方向上的距离有关y0的方程为 dmin=f(y0)= - sqrt（pow(r,2)-pow(y0,2)）- （- sqrt(pow(R,2)-pow(y0-b,2)) + a）\r\n7.对f(y0)求导,得到f(y0)的导函数设为g(y0)\r\n8.令g(y0)=0，取得f(y0)的极值点，并且根据极值点获得f(y0)的单调性\r\n9.根据f(y0)的单调性取得函数的最小值\r\n\r\n备注：因为常数太多我这里就不替你计算了，自己计算导函数以及获得函数的单调性并且根据单调性取得最小值即可", "Konwledge_Point": "负权边的最短路径", "Question": "两个圆弧在坐标轴方向上的最短距离怎么求？\n\n\n\n如上图两个圆，它们在Y轴或者X轴方向上的最短距离怎么算？\n\n最好有方便编程实现的方法", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/u012969412/article/details/44818029", "Konwledge_Point": "负权边的最短路径", "Question": "希望大神解答一下，这道题用bfs+优先队列为什么不对，只能用最短路径来写\nBessie and the rest of Farmer John's cows are taking a trip this winter to go skiing. One day Bessie finds herself at the top left corner of an R (1 <= R <= 100) by C (1 <= C <= 100) grid of elevations E (-25 <= E <= 25). In order to join FJ and the other cows at a discow party, she must get down to the bottom right corner as quickly as she can by travelling only north, south, east, and west.\n\nBessie starts out travelling at a initial speed V (1 <= V <= 1,000,000). She has discovered a remarkable relationship between her speed and her elevation change. When Bessie moves from a location of height A to an adjacent location of eight B, her speed is multiplied by the number 2^(A-B). The time it takes Bessie to travel from a location to an adjacent location is the reciprocal of her speed when she is at the first location.\n\nFind the both smallest amount of time it will take Bessie to join her cow friends.\n\n\n\n\nInput\n\n    * Line 1: Three space-separated integers: V, R, and C, which respectively represent Bessie's initial velocity and the number of rows and columns in the grid.\n\n\n\n* Lines 2..R+1: C integers representing the elevation E of the corresponding location on the grid. \n\n\n\n\nOutput\n\n    A single number value, printed to two exactly decimal places: the minimum amount of time that Bessie can take to reach the bottom right corner of the grid. \n\nSample Input\n\n\n\n1 3 3\n1 5 3\n6 3 5\n2 4 3\n\n\n\n\nSample Output\n\n\n\n29.00\n\n\n\n\nHint\n\n    Bessie's best route is:\n\n    Start at 1,1 time 0 speed 1\n\n    East to 1,2 time 1 speed 1/16\n\n    South to 2,2 time 17 speed 1/4\n\n    South to 3,2 time 21 speed 1/8\n\n    East to 3,3 time 29 speed 1/4 ", "Tag": "算法分析"}
{"Answer": "\"carbohydrate\" 能被缩略成\"carboh\", 但是不能被缩略成\"carbo\" (或其余更短的前缀) 因为已经有一个单词用\"carbo\"开始\r\n\r\n如果是这样的话，那就得建立英语单词库了。。不然的话那就不知道如何去缩写了！！", "Konwledge_Point": "负权边的最短路径", "Question": "最短前缀                             \n描述\n\n一个字符串的前缀是从该字符串的第一个字符起始的一个子串。例如 \"carbon\"的字串是: \"c\", \"ca\", \"car\", \"carb\", \"carbo\", 和 \"carbon\"。注意到这里我们不认为空串是字串, 但是每个非空串是它自身的字串. 我们现在希望能用前缀来缩略的表示单词。例如, \"carbohydrate\" 通常用\"carb\"来缩略表示. 现在给你一组单词, 要求你找到唯一标识每个单词的最短前缀\n\n在下面的例子中，\"carbohydrate\" 能被缩略成\"carboh\", 但是不能被缩略成\"carbo\" (或其余更短的前缀) 因为已经有一个单词用\"carbo\"开始\n\n一个精确匹配会覆盖一个前缀匹配，例如，前缀\"car\"精确匹配单词\"car\". 因此 \"car\" 是 \"car\"的缩略语是没有二义性的 , “car”不会被当成\"carriage\"或者任何在列表中以\"car\"开始的单词.\n\n输入\n\n输入包括至少2行，至多1000行. 每行包括一个以小写字母组成的单词，单词长度至少是1，至多是20.\n\n输出\n\n输出的行数与输入的行数相同。每行输出由相应行输入的单词开始，后面跟着一个空格接下来是相应单词的没有二义性的最短前缀标识符。\n\n样例输入\n\ncarbohydrate\n\ncart\n\ncarburetor\n\ncaramel\n\ncaribou\n\ncarbonic\n\ncartilage\n\ncarbon\n\ncarriage\n\ncarton\n\ncar\n\ncarbonate\n\n样例输出\n\ncarbohydrate carboh\n\ncart cart\n\ncarburetor carbu\n\ncaramel cara\n\ncaribou cari\n\ncarbonic carboni\n\ncartilage carti\n\ncarbon carbon\n\ncarriage carr\n\ncarton carto\n\ncar car\n\ncarbonate carbona", "Tag": "算法分析"}
{"Answer": "\nYou can use the base_convert function for what you want, but note that a hash is something else entirely.\n", "Konwledge_Point": "负权边的最短路径", "Question": "什么是最短的哈希/\n\n\n\nIs there any hashing method for php to hash (just integer to string) in shortest lenght?\n\n\n\nfor example \n\n\n\ninput : \n10565\n \noutput : \nrwk4\n\n\n\ninput : \n40853353246\n\noutput : \norhg0ut04h\n\n\n\nif there is not hashing like this\n\n\n\nIs there any way(function) to do it?\n\n    ", "Tag": "算法分析"}
{"Answer": "参考：http://zhidao.baidu.com/link?url=z6bWEi7X6DVMTYXYi-nAxUD26klYLPcH2_n5XQNzL6rID2MlmPa-7Ws5AOaNqscHxrTnrP6jxntvthty7DrvKUh994JhsIndxHKtdq2FW0u", "Konwledge_Point": "负权边的最短路径", "Question": "求最短哈密尔顿回路怎么实现？\n求最短哈密尔顿回路怎么实现？\n\n是不是要用到动态规划算法？有没有人能用Java或者C++解释下？", "Tag": "算法分析"}
{"Answer": "\nWhen you adjust the new path distance here\n   if D[edge.Destination] > D[edge.Source]+edge.Weight {\n      D[edge.Destination] = D[edge.Source] + edge.Weight\n\nSet some array element (say, P for \"parent\") to point that you have come to Destination from Source.\nP[edge.Destination] = edge.Source\n\nAfter the algorithm ends, in this array each vertex will have its predecessor on the path leading from the starting vertex.\nPS. OK, not with arrays and indices ...\nAdd a new field Prev to the Vertex:\ntype Vertex struct {\n    Id      string\n    Visited bool\n    AdjEdge []*Edge\n    Prev *Vertex\n}\n\nWhen adjusting distance:\nif D[edge.Destination] > D[edge.Source]+edge.Weight {\n    D[edge.Destination] = D[edge.Source] + edge.Weight\n    edge.Destination.Prev = edge.Source\n\nAnd when you display the results:\nfor vertex1, distance1 := range distmap1 {\n    fmt.Println(vertex1.Id, \"=\", distance1)\n    if vertex1.Prev != nil {\n        fmt.Println (vertex1.Id, \" -> \", vertex1.Prev.Id)\n    }\n}\n\n", "Konwledge_Point": "负权边的最短路径", "Question": "开始，Dijkstra：打印出路径，而不仅仅是计算最短距离\n\n\n\nGo, Dijkstra : print out the path, not just calculate the shortest distance.\n\n\n\nhttp://play.golang.org/p/A2jnzKcbWD\n\n\n\nI was able to find the shortest distance using Dijkstra algorithm, maybe not.\nThe code can be found here.\n\n\n\nBut it would be useless if I can't print out the path.\nWith a lot of pointers going on, I can't figure out how to print out the final path that takes the least amount of weights.\n\n\n\nIn short, how do I not only find the shortest distance, but also print out the shortest path on this given code?\n\n\n\nThe link is here: \n\n\n\nhttp://play.golang.org/p/A2jnzKcbWD\n\n\n\nAnd the snippet of the code is below:\n\n\n\nconst MAXWEIGHT = 1000000\n\ntype MinDistanceFromSource map[*Vertex]int\n\nfunc (G *Graph) Dijks(StartSource, TargetSource *Vertex) MinDistanceFromSource {\n  D := make(MinDistanceFromSource)\n  for _, vertex := range G.VertexArray {\n    D[vertex] = MAXWEIGHT\n  }\n  D[StartSource] = 0\n\n  for edge := range StartSource.GetAdEdg() {\n    D[edge.Destination] = edge.Weight\n  }\n  CalculateD(StartSource, TargetSource, D)\n  return D\n}\n\nfunc CalculateD(StartSource, TargetSource *Vertex, D MinDistanceFromSource) {\n  for edge := range StartSource.GetAdEdg() {\n    if D[edge.Destination] > D[edge.Source]+edge.Weight {\n      D[edge.Destination] = D[edge.Source] + edge.Weight\n    } else if D[edge.Destination] < D[edge.Source]+edge.Weight {\n      continue\n    }\n    CalculateD(edge.Destination, TargetSource, D)\n  }\n}\n\n\n\n\nI did something with array to see what is being updated.\n\n\n\nhttp://play.golang.org/p/bRXYjnIGxy\n\n\n\nThis gives ms\n\n\n\n   [A->D D->E E->F F->T B->E E->D E->F F->T]\n\n\n    ", "Tag": "算法分析"}
{"Answer": "\nDefault PHP way\nWhat http_build_query does is a common way to serialize arrays to URL. PHP automatically deserializes it in $_GET.\nWhen wanting to serialize just a (non-associative) array of integers, you have other options.\nSmall arrays\nFor small arrays, conversion to underscore-separated list is quite convenient and efficient. It is done by $fs = implode('_', $fs). Then your URL would look like this:\nhttp://example.com/?c=asdf&fs=5_12_99\n\nThe downside is that you’ll have to explicitly explode('_', $_GET['fs']) to get the values back as an array.\nOther delimiters may be used too. Underscore is considered alphanumeric and as such rarely has special meaning. In URLs, it is usually used as space replacement (e.g. by MediaWiki). It is hard to distinguish when used in underlined text. Hyphen is another common replacement for space. It is also often used as minus sign. Comma is a typical list separator, but unlike underscore and hyphen in is percent-encoded by http_build_query and has special meaning almost everywhere. Similar situation is with vertical bar (“pipe”).\nLarge arrays\nWhen having large arrays in URLs, you should first stop coding a start thinking. This almost always indicates bad design. Wouldn’t POST HTTP method be more appropriate? Don’t you have any more readable and space efficient way of identifying the addressed resource?\nURLs should ideally be easy to understand and (at least partially) remember. Placing a large blob inside is really a bad idea.\nNow I warned you. If you still need to embed a large array in URL, go ahead. Compress the data as much as you can, base64-encode them to convert the binary blob to text and url-encode the text to sanitize it for embedding in URL.\nModified base64\nMmm. Or better use a modified version of base64. The one of my choice is using\n\n- instead of +,\n_ instead of / and\nomits the padding =.\n\ndefine('URL_BASE64_FROM', '+/');\ndefine('URL_BASE64_TO', '-_');\nfunction url_base64_encode($data) {\n    $encoded = base64_encode($data);\n    if ($encoded === false) {\n        return false;\n    }\n    return str_replace('=', '', strtr($encoded, URL_BASE64_FROM, URL_BASE64_TO));\n}\nfunction url_base64_decode($data) {\n    $len = strlen($data);\n    if (is_null($len)) {\n        return false;\n    }\n    $padded = str_pad($data, 4 - $len % 4, '=', STR_PAD_RIGHT);\n    return base64_decode(strtr($padded, URL_BASE64_TO, URL_BASE64_FROM));\n}\n\nThis saves two bytes on each character, that would be percent-encoded otherwise. There is no need to call urlencode function, too.\nCompression\nChoice between gzip (gzcompress) and bzip2 (bzcompress) should be made. Do not want to invest time in their comparison, gzip looks better on several relatively small inputs (around 100 chars) for any setting of block size.\nPacking\nBut what data should be fed into the compression algorithm?\nIn C, one would cast array of integers to array of chars (bytes) and hand it over to the compression function. That’s the most obvious way to do things. In PHP the most obvious way to do things is converting all the integers to their decimal representation as strings, then concatenation using delimiters, and only after that compression. What a waste of space!\nSo, let’s use the C approach! We’ll get rid of the delimiters and otherwise wasted space and encode each integer in 2 bytes using pack:\ndefine('PACK_NUMS_FORMAT', 'n*');\nfunction pack_nums($num_arr) {\n    array_unshift($num_arr, PACK_NUMS_FORMAT);\n    return call_user_func_array('pack', $num_arr);\n}\nfunction unpack_nums($packed_arr) {\n    return unpack(PACK_NUMS_FORMAT, $packed_arr);\n}\n\nWarning: pack and unpack behavior is machine-dependent in this case. Byte order could change between machines. But I think it will not be a problem in practice, because the application will not run on two systems with different endianity at the same time. When integrating multiple systems, though, the problem might arise. Also if you switch to a system with different endianity, links using the original one will break.\nEncoding together\nNow packing, compression and modified base64, all in one:\nfunction url_embed_array($arr) {\n    return url_base64_encode(gzcompress(pack_nums($arr)));\n}\nfunction url_parse_array($data) {\n    return unpack_nums(gzuncompress(url_base64_decode($data)));\n}\n\nSee the result on IdeOne. It is better than OP’s answer where on his 40-element array my solution produced 91 chars while his one 98. When using range(1, 1000) (generates array(1, 2, 3, …, 1000)) as a benchmark, OP’s solution produces 2712 characters while mine just 2032 characters. This is about 25 % better.\nFor the sake of completeness, OP’s solution is\nfunction url_embed_array($arr) {\n    return urlencode(base64_encode(gzcompress(implode(',', $arr))));\n}\n\n", "Konwledge_Point": "负权边的最短路径", "Question": "PHP中数字索引数组的最短可能查询字符串\n\n\n\nI’m looking for the most concise URL rather than the shortest PHP code. I don’t want my users to be scared by the hideous URLs that PHP creates when encoding arrays.\n\n\n\nPHP will do a lot of repetition in query string if you just stuff an array (\n$fn\n) through \nhttp_build_query\n:\n\n\n\n$fs = array(5, 12, 99);\n$url = \"http://$_SERVER[HTTP_HOST]/?\" .\n    http_build_query(array('c' => 'asdf', 'fs' => $fs));\n\n\n\n\nThe resulting \n$url\n is\n\n\n\nhttp://example.com/?c=asdf&fs[0]=5&fs[1]=12&fs[3]=99\n\n\n\n\nHow do I get it down to a minimum (using PHP or methods easily implemented in PHP)?\n\n    ", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/ecttx/article/details/8372486参考一下这个", "Konwledge_Point": "负权边的最短路径", "Question": "请帮帮忙，有N个点，保证连线是最短的。或者使用循环嵌套，但是需要进行N个嵌套，递归不知道怎么写\nC#问题，请帮帮忙，有N个点，我需要将其排序，保证连线是最短的。或者使用循环嵌套，但是需要进行N个嵌套，递归不知道怎么写，求大神，新手一枚，没啥分，帮帮忙！", "Tag": "算法分析"}
{"Answer": "\nYour way of doing it is fine. You could use the ternary ? operator to create a shorter if statement though:\nreturn (count($a)<count($b)) ? $a : $b;\n\n", "Konwledge_Point": "负权边的最短路径", "Question": "返回具有较少元素的数组的最短方法\n\n\n\nI have two arrays.  I wish to return the array containing fewer elements.\n\n\n\nMy code so far:\n\n\n\n<?php\n\nif ( count($a) < count($b) )\n    return $a;\nelse\n    return $b;\n\n\n\n\nThanks in Advance.\n\n    ", "Tag": "算法分析"}
{"Answer": "你的程序一直停在了    while(scanf(\"%s\",s[count])!=EOF)    {        count++;    }所以没看到输出，你可以在while循环后面加一行打印，就会发现问题了", "Konwledge_Point": "负权边的最短路径", "Question": "为什么这个代码没有输出啊，oj中的最短前缀问题\n问题遇到的现象和发生背景\n\n\n问题相关代码，请勿粘贴截图\n\n\n运行结果及报错内容\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果\n\n\n#include\n#include\nint main()\n{\n    char s[1001][21];\n    char re[1001][21];\n    int i,j,k,l,count=0;\n    while(scanf(\"%s\",s[count])!=EOF)\n    {\n        count++;\n    }\n    for(i=0;i<count;i++)\n    {\n        int len=strlen(s[count]);\n        for(j=0;j<len;j++)\n        {\n            re[i][j]=s[i][j];\n            for(k=1;k<count;++k)\n            {\n                for(l=0;l<j;++l)\n                {\n                    if(re[i][l]!=s[k][l])\n                        break;\n                }\n                if(l==j)\n                    break;\n            }\n            if(k==count)\n                break;\n        }\n    }\n    for(i=0;i<count;i++)\n    {\n        printf(\"%s \",s[count]);\n        printf(\"%s\\n\",re[count]);\n    }\n    return 0;\n}", "Tag": "算法分析"}
{"Answer": "下面用python的set的union方法实现的（这里安装了boltons，如果直接用set，会自动排序），输出[1, 3, 4, 2, 5]\r\n\r\n```\r\nfrom boltons.setutils import IndexedSet\r\n\r\na=[1,3,4]\r\nb=[3,2,5]\r\nc=[1,3,5]\r\n\r\nresult = IndexedSet(a).union(IndexedSet(b)).union(IndexedSet(c))\r\n\r\nprint(result)\r\n\r\n```\r\nhttps://stackoverflow.com/questions/1653970/does-python-have-an-ordered-set\r\n\r\n你研究下union方法\r\n\r\nc#实现如下：\r\n\r\n```\r\nint[] a = { 1, 3, 4 };\r\nint[] b = { 3, 2, 5 };\r\nint[] c = { 1, 3, 5 };\r\n\r\nvar result = a.Union(b).Union(c);\r\n\r\nforeach(var item in result)\r\n{\r\n    Console.WriteLine(item);\r\n}            \r\n```\r\n其Union的源码地址：https://github.com/dotnet/runtime/blob/master/src/libraries/System.Linq/src/System/Linq/Union.cs", "Konwledge_Point": "负权边的最短路径", "Question": "怎么把多个有序的数组合并成一个数组，并且保证数组最短，同时保证合并后的数组还能保持各个数组的顺序？\n例如：\n\n数组1：[1,3,4]\n\n数组2：[3,2,5]\n\n数组3：[1,3,5]\n\n\n\n合并后的最短数组 :[1,3,2,4,5] 或者 [1,3,4,2,5] 或者 [1,3,2,5,4],求出其中\n\n一种情况就行。这个数组能够同时满足原来三个数组的元素排列顺序。\n\n求大佬指点算法，什么语言都行", "Tag": "算法分析"}
{"Answer": "\nyou may try LENGTH().\n select product_name ,length(product_name) as the_length from your_table \n where product_name LIKE '%dead space%'\n ORDER BY  length(product_name)\n limit 1\n\nDEMO HERE\n", "Konwledge_Point": "负权边的最短路径", "Question": "我可以用GROUP BY（MySql）选择最短的字段名称吗？\n\n\n\nLet's say, I have 2 product names: dead space and dead space limited edition, and I want to group them by \"product_name\" to select \"dead space\" in a mysql query. So I want the query to select the \"product_name\" with the shortest string if the where caluse is \"product_name LIKE '%dead space%'\".\n\n\n\nThanks a lot,\n\n    ", "Tag": "算法分析"}
{"Answer": "\nYou could just do the math on the database side, order your result set by distance and select the one with the lowest value.\nAnd I took the liberty of updating your database access methods. Don't, under any circumstances, use mysql_* functions.\n$lat1 = 123.245;\n$lon1 = 48.123;\n\n$dbhost = \"localhost\";\n$dbname = \"database\";\n$username = \"user\";\n$password = \"pass\";\n\n$db = new PDO(\"mysql:host=$dbhost;dbname=$dbname\", $username, $password);\n\n$query = \"SELECT *, DEGREES(ACOS(SIN(RADIANS(?)) * SIN(RADIANS(`lat`)) +  COS(RADIANS(?)) * COS(RADIANS(`lat`)) * COS(RADIANS(? - `lon`)))) * 60 * 1.1515 AS distance\n    FROM store\n    ORDER BY distance ASC\n    LIMIT 1\";\n$stmt = $db->prepare($query);\n$stmt->execute(array($lat1, $lat1, $lon1));\n$result = $stmt->fetch(PDO::FETCH_ASSOC);\nprint_r($result);\n\n", "Konwledge_Point": "负权边的最短路径", "Question": "找到2个坐标与存储在表格中的1个集合之间的最短距离\n\n\n\nI have a MySQL table with the following attributes:\nstore_name\nlat\nlon\n\n\n\nI have 1500 records.\n\n\n\nI need to find the closest store to the user (based on IP).\n\n\n\nI have figured the IP translation part using a 3rd party API. I know how to calculate the distance between 2 coordinates. However, I don't know how to return the store name that is the closest.\n\n\n\nMy function to calculate distance\n\n\n\nfunction distance($lat1, $lon1, $lat2, $lon2) \n{\n$minus = $lon1 - $lon2;\n$dist = sin(deg2rad($lat1)) * sin(deg2rad($lat2)) +  cos(deg2rad($lat1))*cos(deg2rad($lat2)) * cos(deg2rad($minus));\n$dist = acos($dist);\n$dist = rad2deg($dist);\n$miles = $dist * 60 * 1.1515;\nreturn $miles;\n}\n\n\n\n\nI can find the distance between user and each store.\n\n\n\nNote: $lat1 and $lat1 are obtained by a 3rd party API service.\n\n\n\n$store = mysql_query(\"SELECT * FROM store\") or die(mysql_error());\nwhile($row=mysql_fetch_assoc($store))\n{\n$lat2 = $row[\"lat\"];\n$lon2 = $row[\"lon\"];\n$distance = distance($lat1, $lon1, $lat2,$lon2);\n}\n\n\n\n\nHow do I calculate run the distance function and store the distance value in an array and then sort the distances to find the nearest store? Is this the correct methodology? And how do I proceed with the array code? I have no experience with arrays in PHP.\n\n\n\nThank you.\n\n    ", "Tag": "算法分析"}
{"Answer": "\nMatch and capture key-value pairs and then combine into an array:\n$re = '/(\\w+)\\s*=\\s*([^;]*)/';\n$str = 'FIRM_ID = MC0356400000; TAG = EQTV; CURR_CODE = SUR; CLIENT_CODE = FR334; LIMIT_KIND = 1; OPEN_BALANCE = 4822.84; OPEN_LIMIT = 0.00; LEVERAGE = 0;';\npreg_match_all($re, $str, $matches);\nprint_r(array_combine($matches[1],$matches[2]));\n\nSee the PHP demo, result:\nArray\n(\n    [FIRM_ID] => MC0356400000\n    [TAG] => EQTV\n    [CURR_CODE] => SUR\n    [CLIENT_CODE] => FR334\n    [LIMIT_KIND] => 1\n    [OPEN_BALANCE] => 4822.84\n    [OPEN_LIMIT] => 0.00\n    [LEVERAGE] => 0\n)\n\nThe regex is\n/(\\w+)\\s*=\\s*([^;]*)/\n\nSee is demo online.\nDetails:\n\n(\\w+) - Group 1: one or more word chars\n\\s*=\\s* - a = enclosed with optional whitespace(s)\n([^;]*) - Group 2: zero or more chars other than ;.\n\nTo \"initialize\" the variables each at a time, you may use a \n$var_name = 'FIRM_ID';\n$re = '/' . $var_name . '\\s*=\\s*\\K[^;]*/';\n$str = 'FIRM_ID = MC0356400000; TAG = EQTV; CURR_CODE = SUR; CLIENT_CODE = FR334; LIMIT_KIND = 1; OPEN_BALANCE = 4822.84; OPEN_LIMIT = 0.00; LEVERAGE = 0;';\npreg_match($re, $str, $m);\nprint_r($m);\n\nSee the PHP demo. \nThe \\K is the match reset operator that omits all text matched so far within the current match iteration.\n", "Konwledge_Point": "负权边的最短路径", "Question": "使用正则表达式从字符串中获取匹配模式的最短方法\n\n\n\nI have pretty long string to parse, that looks like that (part of it)\n\n\n\n$string = 'FIRM_ID = MC0356400000; TAG = EQTV; CURR_CODE = SUR; CLIENT_CODE = FR334; LIMIT_KIND = 1; OPEN_BALANCE = 4822.84; OPEN_LIMIT = 0.00; LEVERAGE = 0;'\n\n\n\n\nI need to get values for php variables from that string, which I do with preg_match:\n\n\n\n preg_match(\"/FIRM_ID = (.*?);/\", $string, $m);\n $firm_id = trim($m[1]);\n\n preg_match(\"/CLIENT_CODE = (.*?);/\", $string, $m);\n $client_code = trim($m[1]);\n\n\n\n\n... and so on\n\n\n\nI was wondering is there a way to do the same in one line? May be with preg_replace or other functions, so I would not have to declare $m variable first and then take out from that [1] element.\n\n\n\nSo the code supposed to look like\n\n\n\n $firm_id = somefunction($string);\n $client_code = somefunction($string);\n\n\n\n\nIts not practical question, more theoretical. I know how to get result that I need, I want to know if there is a simpler and more elegant way.\n\n\n\nThanks.\n\n    ", "Tag": "算法分析"}
{"Answer": "用int 和 unsigned long long比较，当int 为负值，会转换为最大的unsigned long long - n，通常这是一个天文数字，所以此时的 -1 在计算机里是2^64-1 ,这个数基本会大于程序中所有出现的数字，无论你右侧的数有多大，都小于这个数。", "Konwledge_Point": "负权边的最短路径", "Question": "KMP代码中的while循环部分出现问题\n问题是在写KMP算法过程中出现的，但好像不是算法问题，先po出代码\n\n\n#include\n\n\n#include\n\nusing namespace std;\nvoid Match_KMP(string T,string P)\n{\n    \n//\n先找子串的NEXT数组\n    int \nnext\n[P.length()];\n    \nnext\n[\n0\n] = -\n1\n;\n    \nnext\n[\n1\n] = \n0\n;\n    int j = \n1\n,k = \n0\n,i;\n    \nwhile\n(j < P.length()){\n        \nif\n(P[k] == P[j] || k == -\n1\n)\n            \nnext\n[++j] = ++k;\n        \nelse\n{\n            k = \nnext\n[k];\n        }\n    }\n    \n//\n开始查找\n    i = \n0\n; j = \n0\n;\n    \nwhile\n(i < T.length() && j < P.length()){\n        \nif\n(T[i] == P[i] || j == -\n1\n){\n            cout<>father;\n    cin>>son;\n    Match_KMP(father,son);\n    return \n0\n;\n}\n\n\n\n\n\n\n\n\n由于运行过程中用debug看，始终查找子串的while部分只进入了一次循环，所以在注释部分输出了一些结果，发现是第二个条件不\n\n\n符合，但我的疑问是-1 < 3为什么输出结果是0呢？", "Tag": "算法分析"}
{"Answer": "\nIf you have a fixed set of strings and you will only need to look those up then find a minimal perfect hash function. http://en.wikipedia.org/wiki/Perfect_hash_function\n", "Konwledge_Point": "负权边的最短路径", "Question": "字符串上的最小校验和\n\n\n\nscratching my head over this.\n\n\n\ni have 350 strings average 90 chars long, all strings are unique.\nNow, i wanna generate a unique id for each string.\n\n\n\ni tried the sum of chars in the string wich gave two doubles, the returned sum\nis not unique enough. Anybody any idea how to approach this? I thought of hash(), is that the best solution?\n\n\n\nabcdef will return the same as abcdfe\n\n    ", "Tag": "算法分析"}
{"Answer": "使用模数\r\n\r\n    count = (count + 1) % 7", "Konwledge_Point": "负权边的最短路径", "Question": "循环计数器-最短算法 \n功能：每次按钮按下，就会生成一个整数，然后达到最大值再返回0。\n\n\n\n我想要最短的实现算法。\n\n\n\n比如像这样。从0到6，再从6到0。\n\n\n\ncount ++;\ncount *= (count != 7);\n", "Tag": "算法分析"}
{"Answer": "可能是min初始值太小了，min=251;试试？(不确定）\n（string a，完全可以改成char a[252]={0};然后读取是cin.getline(a,250);len=strlen(a);或者不求len,算到a[i]==0就是到最后了；其他不变）（...&& a[i]!= ',' 好像没用？题目提到输入只包含小写字母和空格）", "Konwledge_Point": "负权边的最短路径", "Question": "2444 - 最长最短单词\n2444 - 最长最短单词\n题目描述\n输入一行长度不超过250位的字符串，其中只有小写字母和空格，小写字母组成单词，单词之间只用一个空格隔开，字符串的开始和结束都没有多余空格，输出长度最长的单词和最短的单词，若有多个单词符合要求，只要求输出从前往后数第一个满足要求的单词。\n\n\n输入\n输入文件只有一行字符串，由小写字母和空格组成。\n\n\n输出\n输出文件有两行，第一行为最长的单词，第二行为最短的单词。\n\n\n样例\n输入\nthis is my book\n输出\nthis\nis\n标签\n字符串\n\n\n#include\n\nusing namespace std;\nint main() {\n    string a;\n    int i,len,\nl\n=0,max=0,min=101,x,y;\n    getline(cin,a);\n    \nlen\n=a.size();\n    a[len]=\n' '\n;\n    \nfor\n(\ni\n=0; i<=len; i++) {\n        \nif\n(a[i]!=\n' '\n&&a[i]!=\n','\n) {\n            l++;\n        } \nelse\n \nif\n(l>0) {\n            \nif\n(l>max) {\n                \nmax\n=l;\n                \nx\n=i-l;\n            }\n            \nif\n(l<min) {\n                \nmin\n=l;\n                \ny\n=i-l;\n            }\n            \nl\n=0;\n        }\n    }\n    \nfor\n(\ni\n=x; i<max+x; i++)\n        cout<<a[i];\n    cout<<endl;\n    \nfor\n(\ni\n=y; i<min+y; i++)\n        cout<<a[i];\n    return 0;\n}\n\n\n\n测试点1： Accepted， 用时: 0 ms， 内存: 256 KB\n测试点2： Accepted， 用时: 0 ms， 内存: 256 KB\n测试点3： Accepted， 用时: 0 ms， 内存: 256 KB\n测试点4： Accepted， 用时: 0 ms， 内存: 256 KB\n测试点5： Accepted， 用时: 0 ms， 内存: 252 KB\n测试点6： Accepted， 用时: 0 ms， 内存: 252 KB\n测试点7： Wrong Answer， 用时: 0 ms， 内存: 256 KB\n各位朋友，帮我看一下这个代码哪里错了！", "Tag": "算法分析"}
{"Answer": "\nmethods that read data into byte slices return the number of bytes read.  You should save that number and then use it to create your string.  n being the number of bytes read, your code would look like this:\ns := string(byteArray[:n])\n\nIf for some reason you don't have n, you could use the bytes package to find it, assuming your input doesn't have a null character in it.\nn := bytes.Index(byteArray, []byte{0})\n\nOr as icza pointed out, you can use the code below:\nn := bytes.IndexByte(byteArray, 0)\n\n", "Konwledge_Point": "负权边的最短路径", "Question": "将字节数组转换为字符串的最佳方法是什么？\n\n\n\nI need to read \n[100]byte\n to transfer a bunch of \nstring\n data.\n\n\n\nBecause not all of the \nstring\ns are precisely 100 characters long, the remaining part of the \nbyte array\n are padded with \n0\ns.\n\n\n\nIf I tansfer \n[100]byte\n to \nstring\n by: \nstring(byteArray[:])\n, the tailing \n0\ns are displayed as \n^@^@\ns.\n\n\n\nIn C the \nstring\n will terminate upon \n0\n, so I wonder what's the best way of smartly transfer a \nbyte array\n to \nstring\n in Golang.\n\n    \n\n\n\n转载于:https://stackoverflow.com/questions/14230145/what-is-the-best-way-to-convert-byte-array-to-string", "Tag": "算法分析"}
{"Answer": "是那个测试页面的问题。保存成独立的html文件没问题", "Konwledge_Point": "负权边的最短路径", "Question": "为什么这段js一直提示找不到文件？？？？   要求一个数组方阵从左上到右下的最短距离\n\n\n\n最小路径是：\n\n\n\n\n\n\n\n\n\n\n ", "Tag": "算法分析"}
{"Answer": "代码如下：（完整代码包含了GUI界面的设计）\n\nimport random\nimport math\nimport heapq\nimport tkinter as tk\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __str__(self):\n        return f\"{self.x},{self.y}\"\n\nclass Edge:\n    def __init__(self, p1, p2, weight):\n        self.p1 = p1\n        self.p2 = p2\n        self.weight = weight\n\n    def __lt__(self, other):\n        return self.weight < other.weight\n\nclass Graph:\n    def __init__(self):\n        self.points = []\n        self.edges = []\n        self.colors = [\"red\", \"blue\", \"green\", \"purple\", \"orange\", \"brown\"]\n\n    def add_point(self, point):\n        self.points.append(point)\n\n    def add_edge(self, p1, p2, weight):\n        self.edges.append(Edge(p1, p2, weight))\n\n    def get_distance(self, p1, p2):\n        return math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2)\n\n    def generate_points(self, n, width, height):\n        self.points = []\n        for i in range(n):\n            x = random.randint(0, width)\n            y = random.randint(0, height)\n            self.points.append(Point(x, y))\n\n    def draw_points(self, canvas):\n        for i, point in enumerate(self.points):\n            canvas.create_oval(point.x-2, point.y-2, point.x+2, point.y+2, fill=self.colors[i%len(self.colors)])\n\n    def draw_edge(self, canvas, p1, p2, color=\"black\"):\n        canvas.create_line(p1.x, p1.y, p2.x, p2.y, fill=color)\n\n    def generate_edges(self, rule):\n        self.edges = []\n        for i in range(len(self.points)):\n            for j in range(i+1, len(self.points)):\n                p1 = self.points[i]\n                p2 = self.points[j]\n                if rule == \"straight\":\n                    if p1.x == p2.x or p1.y == p2.y:\n                        self.add_edge(p1, p2, self.get_distance(p1, p2))\n                elif rule == \"diag\":\n                    self.add_edge(p1, p2, self.get_distance(p1, p2))\n                else:\n                    if self.get_distance(p1, p2) <= 100:\n                        self.add_edge(p1, p2, self.get_distance(p1, p2))\n\n    def kruskal(self):\n        self.edges.sort()\n        parent = {}\n        for point in self.points:\n            parent[point] = point\n        mst = []\n        for edge in self.edges:\n            p1 = edge.p1\n            p2 = edge.p2\n            root1 = self.find(parent, p1)\n            root2 = self.find(parent, p2)\n            if root1 != root2:\n                mst.append(edge)\n                parent[root1] = root2\n        return mst\n\n    def find(self, parent, point):\n        if parent[point] == point:\n            return point\n        return self.find(parent, parent[point])\n\nclass App:\n    def __init__(self, master):\n        self.master = master\n        self.width = 800\n        self.height = 500\n        master.title(\"Shortest Path\")\n\n        tk.Label(master, text=\"Number of Points:\").grid(row=0, column=0)\n        self.num_points_entry = tk.Entry(master)\n        self.num_points_entry.grid(row=0, column=1)\n        self.num_points_entry.insert(0, \"10\")\n\n        tk.Label(master, text=\"Size of Grid:\").grid(row=1, column=0)\n        self.grid_size_entry = tk.Entry(master)\n        self.grid_size_entry.grid(row=1, column=1)\n        self.grid_size_entry.insert(0, \"800x500\")\n\n        tk.Label(master, text=\"Connection Rule:\").grid(row=2, column=0)\n        self.rule_var = tk.StringVar()\n        self.rule_var.set(\"straight\")\n        tk.Radiobutton(master, text=\"Straight\", variable=self.rule_var, value=\"straight\").grid(row=2, column=1)\n        tk.Radiobutton(master, text=\"Diagonal\", variable=self.rule_var, value=\"diag\").grid(row=2, column=2)\n        tk.Radiobutton(master, text=\"Distance < 100\", variable=self.rule_var, value=\"dist\").grid(row=2, column=3)\n\n        self.generate_button = tk.Button(master, text=\"Generate\", command=self.generate_points)\n        self.generate_button.grid(row=3, column=0)\n\n        self.canvas = tk.Canvas(master, width=self.width, height=self.height)\n        self.canvas.grid(row=4, column=0, columnspan=4)\n\n        self.solve_button = tk.Button(master, text=\"Solve\", command=self.solve)\n        self.solve_button.grid(row=5, column=0)\n\n        self.show_all_button = tk.Button(master, text=\"Show All\", command=self.show_all)\n        self.show_all_button.grid(row=5, column=1)\n\n        self.quit_button = tk.Button(master, text=\"Quit\", command=master.quit)\n        self.quit_button.grid(row=5, column=3, sticky=tk.W)\n\n        self.rule_var.trace(\"w\", lambda *_: self.generate_points())\n\n        self.graph = Graph()\n\n    def generate_points(self):\n        self.graph.generate_points(int(self.num_points_entry.get()), *map(int, self.grid_size_entry.get().split(\"x\")))\n        self.graph.generate_edges(self.rule_var.get())\n        self.redraw()\n\n    def solve(self):\n        self.canvas.delete(\"all\")\n        self.graph.generate_edges(self.rule_var.get())\n        mst = self.graph.kruskal()\n        for i, edge in enumerate(mst):\n            self.graph.draw_edge(self.canvas, edge.p1, edge.p2, color=self.graph.colors[i%len(self.graph.colors)])\n        self.graph.draw_points(self.canvas)\n        self.canvas.create_text(self.width//2, self.height-20, text=f\"Minimum Total Weight: {min_total_weight:.2f}\", font=(\"Arial\", 16, \"bold\"))\n        self.canvas.update()\n\n    def redraw(self):\n        self.canvas.delete(\"all\")\n        self.graph.draw_edges(self.canvas)\n        self.graph.draw_points(self.canvas)\n        self.canvas.update()\n\nroot = tk.Tk()\napp = App(root)\nroot.mainloop()\n\n运行结果界面截图如下：", "Konwledge_Point": "负权边的最短路径", "Question": "Python编写最短连线程序\n\n\nfrom\n tkinter \nimport\n *\n\nimport\n tkinter.messagebox\n\nimport\n itertools\n\nimport\n random\n\nimport\n math\n\nimport\n itertools\n\nsize = \n50\n  \n# 定义方格的大小\n\nr = \n5\n  \n# 定义原点的半径\n\nprecision = \n10\n  \n# 定义点击圆点精度范围\n\nEntry_Width = \n60\n\nEntry_Height = \n40\n\n\n\n\nclass\n \nGUI\n(\nTk\n):\n    \ndef\n \n__init__\n(\nself\n):\n        Tk.__init__(self)\n        self.Width_Number = \n0\n\n        self.Height_Number = \n0\n\n        self.Width = \nmax\n((self.Width_Number + \n2\n) * size, \n400\n)\n        self.Height = (self.Height_Number + \n3\n) * size\n        self.cv = \nNone\n\n        self.Sign = [[\n0\n \nfor\n j \nin\n \nrange\n(\n0\n, \n101\n)] \nfor\n i \nin\n \nrange\n(\n0\n, \n101\n)]\n        self.Entry_W = \nNone\n\n        self.Entry_H = \nNone\n\n        self.Entry_Points = \nNone\n\n        self.title(\n\"最短连线程序\"\n)\n        self.geometry(\nstr\n(self.Width) + \n'x'\n + \nstr\n(self.Height) + \n'+10+10'\n)\n        self.init_input()\n        self.Min_Distance = \n1e20\n\n        self.Line_Connect = \nNone\n\n        self.distance = []\n\n    \ndef\n \nDraw_Point\n(\nself, x_Num, y_Num\n):\n        x_Pos = x_Num * size\n        y_Pos = y_Num * size\n        \nif\n self.Sign[x_Num - \n1\n][y_Num - \n1\n]:\n            self.cv.delete(\nstr\n(x_Pos) + \n'-'\n + \nstr\n(y_Pos))\n            self.Sign[x_Num - \n1\n][y_Num - \n1\n] = \n0\n\n        \nelse\n:\n            self.cv.create_oval(x_Pos - r, y_Pos - r, x_Pos + r, y_Pos + r, fill=\n\"black\"\n,\n                                tags=\nstr\n(x_Pos) + \n'-'\n + \nstr\n(y_Pos))\n            self.Sign[x_Num - \n1\n][y_Num - \n1\n] = \n1\n\n\n    \ndef\n \nMouse_Button_Event\n(\nself, event\n):\n        \n# 获得点击位置最近的坐标\n\n        x_Num = \nround\n(event.x / size)\n        y_Num = \nround\n(event.y / size)\n        \nif\n x_Num > self.Width_Number + \n1\n \nor\n y_Num > self.Height_Number + \n1\n \nor\n x_Num == \n0\n \nor\n y_Num == \n0\n:\n            \nreturn\n\n        x_Pos = x_Num * size\n        y_Pos = y_Num * size\n        \nif\n \nabs\n(event.x - x_Pos) < precision \nand\n \nabs\n(event.y - y_Pos) < precision:\n            self.Draw_Point(x_Num, y_Num)\n\n    \ndef\n \nGenerate\n(\nself\n):\n        \ntry\n:\n            self.Width_Number = \nint\n(self.Entry_W.get())\n            self.Height_Number = \nint\n(self.Entry_H.get())\n            \nif\n self.Width_Number == \n0\n \nor\n self.Height_Number == \n0\n \nor\n self.Width_Number >= \n100\n \nor\n self.Height_Number >= \n100\n:\n                tkinter.messagebox.showinfo(\n'警告'\n, \n'数字超出范围'\n)\n                \nreturn\n\n        \nexcept\n ValueError:\n            tkinter.messagebox.showinfo(\n'警告'\n, \n'请输入数字'\n)\n            \nreturn\n\n\n        self.Width = \nmax\n((self.Width_Number + \n2\n) * size, \n400\n)\n        self.Height = (self.Height_Number + \n3\n) * size\n        self.geometry(\nstr\n(self.Width) + \n'x'\n + \nstr\n(self.Height) + \n'+10+10'\n)\n        \nif\n self.cv \nis\n \nnot\n \nNone\n:\n            self.cv.delete(\n'all'\n)\n            self.cv.config(width=self.Width, height=self.Height)\n        \nelse\n:\n            self.cv = Canvas(self, width=self.Width, height=self.Height, bg=\n'white'\n)\n            self.cv.pack()\n        \nfor\n i \nin\n \nrange\n(\n0\n, self.Width_Number):\n            \nfor\n j \nin\n \nrange\n(\n0\n, self.Height_Number):\n                self.cv.create_rectangle((i + \n1\n) * size, (j + \n1\n) * size, (i + \n2\n) * size, (j + \n2\n) * size)\n        self.cv.bind_all(\n\"\"\n, self.Mouse_Button_Event)\n        Label(self, text=\n'点数:'\n).place(x=\n0\n, y=(self.Height_Number + \n2\n) * size, width=Entry_Width, height=Entry_Height)\n        self.Entry_Points = Entry(self.cv)\n        self.Entry_Points.place(x=Entry_Width, y=(self.Height_Number + \n2\n) * size, width=Entry_Width,\n                                height=Entry_Height)\n        Button(self.cv, text=\n'随机'\n, command=self.Random_Number).place(x=Entry_Width * \n2\n,\n                                                                     y=(self.Height_Number + \n2\n) * size,\n                                                                     width=Entry_Width, height=Entry_Height)\n        Button(self.cv, text=\n'计算'\n, command=self.WorkOut).place(x=Entry_Width * \n3\n,\n                                                               y=(self.Height_Number + \n2\n) * size,\n                                                               width=Entry_Width, height=Entry_Height)\n        self.init_input()\n\n    \ndef\n \ninit_input\n(\nself\n):\n        Label(self, text=\n'列数:'\n).place(x=\n0\n, y=\n0\n, width=Entry_Width, height=Entry_Height)\n        self.Entry_W = Entry(self)\n        self.Entry_W.place(x=Entry_Width, y=\n0\n, width=Entry_Width, height=Entry_Height)\n        Label(self, text=\n'行数:'\n).place(x=Entry_Width * \n2\n, y=\n0\n, width=Entry_Width, height=Entry_Height)\n        self.Entry_H = Entry(self)\n        self.Entry_H.place(x=Entry_Width * \n3\n, y=\n0\n, width=Entry_Width, height=Entry_Height)\n        self.Button_Generate = Button(self, text=\n'生成'\n, command=self.Generate)\n        self.Button_Generate.place(x=Entry_Width * \n4\n, y=\n0\n, width=Entry_Width, height=Entry_Height)\n        self.Sign = [[\n0\n \nfor\n j \nin\n \nrange\n(\n0\n, \nlen\n(self.Sign[\n0\n]))] \nfor\n i \nin\n \nrange\n(\n0\n, \nlen\n(self.Sign))]\n        self.Button_Clear = Button(self, text=\n'清空'\n, command=self.clear_Sign)\n        self.Button_Clear.place(x=Entry_Width * \n5\n, y=\n0\n, width=Entry_Width, height=Entry_Height)\n\n    \ndef\n \nclear_Sign\n(\nself\n):\n        self.clear_Line()\n        \nfor\n i \nin\n \nrange\n(\n0\n, self.Width_Number + \n1\n):\n            \nfor\n j \nin\n \nrange\n(\n0\n, self.Height_Number + \n1\n):\n                \nif\n self.Sign[i][j] == \n1\n:\n                    self.Draw_Point(i + \n1\n, j + \n1\n)\n\n    \ndef\n \nclear_Line\n(\nself\n):\n        self.cv.delete(\n\"line\"\n)\n\n    \ndef\n \nRandom_Number\n(\nself\n):\n        \ntry\n:\n            temp = \nint\n(self.Entry_Points.get())\n        \nexcept\n ValueError:\n            tkinter.messagebox.showinfo(\n'警告'\n, \n'请输入数字'\n)\n            \nreturn\n\n        self.clear_Sign()\n        random_list = \nlist\n(itertools.product(\nrange\n(\n1\n, self.Width_Number + \n2\n), \nrange\n(\n1\n, self.Height_Number + \n2\n)))\n        number = random.sample(random_list, temp)\n        \nfor\n each \nin\n number:\n            x_Num = each[\n0\n]\n            y_Num = each[\n1\n]\n            self.Draw_Point(x_Num, y_Num)\n\n    \ndef\n \nGetDistance\n(\nself, Point_List, i, j\n):\n        \nreturn\n math.sqrt(((Point_List[i][\n0\n] - Point_List[j][\n0\n]) ** \n2\n) + ((Point_List[i][\n1\n] - Point_List[j][\n1\n]) ** \n2\n))\n\n    \n# dfs计算出最短路径连线\n\n    \ndef\n \ndfs\n(\nself,flag, index, \nsum\n, stack\n):\n        \nif\n \nsum\n > self.Min_Distance:\n            \nreturn\n\n        \nif\n \nlen\n(stack) == \nlen\n(flag):\n            \nif\n \nsum\n < self.Min_Distance:\n                self.Min_Distance = \nsum\n\n                self.Line_Connect = []\n                self.Line_Connect.append(\nlist\n(stack))\n                \nreturn\n\n            \nelif\n \nsum\n == self.Min_Distance:\n                self.Line_Connect.append(\nlist\n(stack))\n                \nreturn\n\n            \nelse\n:\n                \nreturn\n\n        \nfor\n j \nin\n \nrange\n(\n0\n, \nlen\n(flag)):\n            \nif\n flag[j] == \n0\n:\n                flag[j] = \n1\n\n                stack.append(j)\n                self.dfs(flag, j, \nsum\n+self.distance[index][j],stack)\n                flag[j] = \n0\n\n                stack.pop()\n\n    \ndef\n \nWorkOut\n(\nself\n):\n        Point_List = []\n        \nfor\n i \nin\n \nrange\n(\n0\n, self.Width_Number + \n1\n):\n            \nfor\n j \nin\n \nrange\n(\n0\n, self.Height_Number + \n1\n):\n                \nif\n self.Sign[i][j] == \n1\n:\n                    Point_List.append([i, j])\n        length = \nlen\n(Point_List)\n        self.distance = [[self.GetDistance(Point_List, i, j) \nfor\n j \nin\n \nrange\n(\n0\n, length)] \nfor\n i \nin\n \nrange\n(\n0\n, length)]\n        self.Min_Distance = \n10\n**\n10\n\n        self.Line_Connect = []\n        self.clear_Line()\n        stack = []\n        flag = [\n0\n \nfor\n i \nin\n \nrange\n(\n0\n, length)]\n        \nfor\n i \nin\n \nrange\n(\n0\n, length):\n            flag[i] = \n1\n\n            stack.append(i)\n            self.dfs(flag, i, \n0\n, stack)\n            flag[i] = \n0\n\n            stack.pop()\n\n        \nfor\n each1 \nin\n self.Line_Connect:\n            \nfor\n each2 \nin\n self.Line_Connect:\n                \nif\n each1[\n0\n] == each2[-\n1\n] \nand\n each1[-\n1\n] == each2[\n0\n]:\n                    each2.reverse()\n        self.Line_Connect = \nlist\n(\nset\n([\ntuple\n(t) \nfor\n t \nin\n self.Line_Connect]))\n        colors = [\n\"pink\"\n,\n\"red\"\n,\n\"blue\"\n,\n\"Violet\"\n,\n\"Purple\"\n,\n\"Navy\"\n,\n\"SkyBlue\"\n,\n\"Cyan\"\n,\n\"Green\"\n,\n\"Yellow\"\n,\n\"White\"\n]\n        \nfor\n j \nin\n \nrange\n(\n0\n,\nlen\n(self.Line_Connect)):\n            temp = random.randint(-\n5\n,\n5\n)\n            each = self.Line_Connect[j]\n            \nfor\n i \nin\n \nrange\n(\n0\n, \nlen\n(each)-\n1\n):\n                x1 = (Point_List[each[i]][\n0\n]+\n1\n)*size+temp\n                y1 = (Point_List[each[i]][\n1\n]+\n1\n)*size+temp\n                x2 = (Point_List[each[i+\n1\n]][\n0\n]+\n1\n)*size+temp\n                y2 = (Point_List[each[i+\n1\n]][\n1\n]+\n1\n)*size+temp\n                self.cv.create_line(x1,y1,x2,y2,width=\n3\n,fill=colors[j%\nlen\n(colors)],tags=(\n\"line\"\n,\nstr\n(j)),dash=(\n4\n,\n4\n))\n\n\n\n\nif\n __name__ == \n\"__main__\"\n:\n    window = GUI()\n    window.mainloop()\n\n\n\n\n（1）可以自定义方格地图大小（aXb）\n（2）可以设定点数，可以随机生成点，也可预置点的坐标\n（3）生成最短连线，如不止一种结果，用多种颜色显示。\n（4）可自定义连线规则（如只能直线，或者可以斜线）\n现在前3个功能已经能实现，需要在次基础上加上第四个功能，给出完善后能够正确运行的代码，以及正确的运行结果界面截图", "Tag": "算法分析"}
{"Answer": "矩阵里的数字是啥？两点之间的距离吗？0到1的距离和1到0的距离不一样？最短路径[0, 7, 6, 3, 1, 2, 5, 4, 8, 0]最短距离655", "Konwledge_Point": "负权边的最短路径", "Question": "0出发最后回到0求最短距离\n从0出发最后回到0 并且经过1 2 3 4 5 6 7 8求最短距离  每个点只能经过一次", "Tag": "算法分析"}
{"Answer": "求最短回路算法", "Konwledge_Point": "负权边的最短路径", "Question": "请教大家一下，数据结构 最短回路模型建立\n遇到问题了，想不明白，请教大家一下：数据结构，最短回路模型建立。", "Tag": "算法分析"}
{"Answer": "自定义室内地图以及路径规划百度地图之路径规划百度地图之路径规划----------------------同志你好，我是CSDN问答机器人小N，奉组织之命为你提供参考答案，编程尚未成功，同志仍需努力！", "Konwledge_Point": "负权边的最短路径", "Question": "地图模块_路径规划的问题\n输入某一位置查询附近（如3公里）的客户信息，查询后根据输入的位置（起始位置）和部分的客户的地址（客户地址可选）规划出最短的路径；\n\n希望得到：\n\n    1：解决思路\n\n    2：百度、高德是否有这样的接口", "Tag": "算法分析"}
{"Answer": "很简单呀，这是linux基本命令运用的题，就比如说第一道题新建目录 mkdir hisdir  进入目录 cd hisdir  创建文件 touch t1.txt,t2.txt 移动并改名是 mv  test1 ../f1 复制命令是cp,到主目录命令是 cp f2 /剩下的你自己来吧，你可以参考我的博客里写的进行相关操作\nLinux基础学习四：Linux常用的命令（非常详细）_CSDN专家-微编程的博客-CSDN博客\n常用的命令文档帮助命令help用法： 命令 --help示例： dhclient --helpman用法: man 命令示例：man dhclient 空格：下一页 b:上一页 q:退出基本操作命令echo作用：输出数据到窗口示例：echo \"hello world\"\techo $PATH //输出path环境变量的值ip作用：查看ip用法：ip addrifconfig作用：centOS7之前版本查看ip...\n\n\n\nhttps://blog.csdn.net/technologist_28/article/details/119506195\n\n", "Konwledge_Point": "负权边的最短路径", "Question": "三道linux操作题不会解\n假设用户jack在当前目录/home/jack下，新建一个目录hisdir；进入hisdir目录，并在hisdir 目录下新建2个文件t1和t2；然后把test1移到其父目录中并改名为f1；将t2复制到主目录中。 \n新建用户exp1，UID为1005，指定其所属的私有组为linux5（linux5组的标识符为1000），用户的主目录为/home/exp1，用户的Shell为/bin/bash，帐户10天过期。设置完成后查看各该用户相关信息。设置密码为123456。设置exp11用户的最短口令存活期为20天，最长口令存\n活期为60天，账户过期日期 2016-11-1，口令到期前5天提醒用户修改口令。  \n设文件 file 当前的权限为 rwx rw- r--。要求取消拥有者的执行权限、取消组内成员的写权限、并且增加其它用户的执行权限。分别用符号表示法和数字表示法修改该文件的权限。", "Tag": "算法分析"}
{"Answer": "这个是NP hard的问题，除非死算，没有什么好的办法，但是如果你只是需要近似最优解，可以用启发式算法，比如模拟退火、遗传算法之类。\r\n所谓启发算法，就是说结果很好算，但是算法本身很难，可以通过随机和试探逼近最优解的方法。\r\n也就是先随机选取一些点，然后向某个方向移动，看距离是否缩小，如果是，那么就移动到那个点，再选取周围点，继续。直到选取的点往四周都增大。", "Konwledge_Point": "负权边的最短路径", "Question": "点到直线的最短距离和问题，优化算法\n求空间中一个点的坐标，这个坐标到n多个直线的距离和最短，n已知，直线方程已知", "Tag": "算法分析"}
{"Answer": "\n public static void main(String[] args) {\n//        Scanner scanner = new Scanner(System.in);\n        int[] arrs = {1,2,3,4,5};\n        Arrays.sort(arrs);\n        int n= arrs.length;\n        int m = 3;\n        int sum = Arrays.stream(arrs).sum();\n        int ave = sum%m == 0? sum/m:sum/m + 1 ;\n        Map<Integer,List<Integer>> map = new HashMap<>();\n        Map<Integer,Integer> sumMap = new HashMap<>();\n        int step = 1;\n        int j=0;\n        for (int i=arrs.length-1;i>=0;){\n\n\n\n            Integer preSum = sumMap.getOrDefault(j, 0);\n            if (preSum == 0 || preSum+arrs[i]<= ave){\n                List<Integer> list = map.getOrDefault(j, new ArrayList<>());\n                list.add(arrs[i]);\n                map.put(j,list);\n                sumMap.put(j,preSum+arrs[i]);\n                i--;\n            }\n\n            j=j+step;\n\n            if(j>= m-1){\n                step = -1;\n            }\n            if (j<= 0){\n                step = 1;\n\n            }\n\n        }\n\n        System.out.println(map);\n        System.out.println(sumMap);\n        System.out.println(\"耗时:\"+ sumMap.values().stream().max(Integer::compareTo).get());\n    }\n", "Konwledge_Point": "负权边的最短路径", "Question": "m个线程，n个任务，求最短解决时间\n今天遇到一个题：假设有m个线程，同时解决n个任务，求最短解决时间。\n\n\n输入示例：3                    （3个线程）\n                  1 4 2 3 5        （各个任务的解决时间）\n输出示例：5                    （全部任务最短解决时间）\n\n\n求解决一下给个代码，最好是java的，感谢感谢了", "Tag": "算法分析"}
{"Answer": "\nn = int(input(\"输入材料长度：\"))\nm = n\ncx = cy = 0\nfor x in range(1,n//19+1):\n    for y in range(1,n//23+1):\n        z = n-x*19-y*23\n        if z>=0 and (z<m or z==m and x<cx):\n            m=z\n            cx=x\n            cy=y\nprint(f'19米短管 {cx} 根, 23米短管 {cy} 根，剩余材料 {m} 米。')\n\n\n ", "Konwledge_Point": "负权边的最短路径", "Question": "刚学python，求解\n任务描述\n\n\n\n本关任务：求出剩余材料最短的切割方案。 一根长度为n米的钢管，需要截成长度为19米和23米的两种短管。求两种短管各截多少根时剩余的材料最少？ （钢管的长度大于等于42） 注意：1、每种短管必须大于等于一根。 2、如果存在多种方案时，请输出19米的数目最少的方案。\n\n\n\n相关知识\n\n\n\n为了完成本关任务，你需要掌握：循环嵌套", "Tag": "算法分析"}
{"Answer": "\nn = int(input(\"输入材料长度：\"))\nm = n\ncx = cy = 0\n\nfor x in range(1,n//19+1):\n    for y in range(1,n//23+1):\n        z = n-x*19-y*23\n        if z>=0 and (z<m or z==m and x<cx):\n            m=z\n            cx=x\n            cy=y\n\nprint(f'19米短管 {cx} 根, 23米短管 {cy} 根，剩余材料 {m} 米。')\n\n ", "Konwledge_Point": "负权边的最短路径", "Question": "求助遍历循环中的嵌套循环\n本关任务：求出剩余材料最短的切割方案。 一根长度为n米的钢管，需要截成长度为19米和23米的两种短管。求两种短管各截多少根时剩余的材料最少？ （钢管的长度大于等于42） 注意：1、每种短管必须大于等于一根。 2、如果存在多种方案时，请输出19米的数目最少的方案。", "Tag": "算法分析"}
{"Answer": "C更新server就得是管理员。所以问非管理员身份登录怎么办，那就得换管理员身份登录才能更新。题目的“ 在最短的时间内 ”是唬人的，好像能有其他办法似的，如果能有的话，那管理员身份岂不是虚设的", "Konwledge_Point": "负权边的最短路径", "Question": "计算机上执行常规升级，怎样才能在最短的时间内更新布丁\n计算机上执行常规升级，怎样才能在最短的时间内更新服务器上所有的系统文件和布丁呢", "Tag": "算法分析"}
{"Answer": "\nbool fun(char* pData, int n) //回文串判断\n{\n\tfor (int i = 0; i < n / 2; i++)\n\t{\n\t\tif (pData[i] != pData[n - i - 1])\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nvoid fun1(char *pData, int n, int m)//将char的前m个字符颠倒后加到char数组尾部\n{\n\tint pos = n;\n\tfor (int i = m-1; i >= 0; i--)\n\t{\n\t\tpData[pos++] = pData[i];\n\t}\n}\n\n\n#define N 1000\nint main(void){\n\tint n;\n\tscanf_s(\"%d\", &n);\n\tchar ch[N] = { 0 };\n\tscanf_s(\"%s\", ch, N);\n\n\tint i = 0;\n\twhile (true)\n\t{\n\t\tfun1(ch, n, i);\n\t\tif (fun(ch, n + i))\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tch[n + i] = '\\0';\n\tprintf(\"%s\", ch);\n\n\t\n\treturn 0;\n}\n ", "Konwledge_Point": "负权边的最短路径", "Question": "判断是否为回文字符串，如果不是补齐为最短回文字符串\n如题，判断是否为回文字符串，如果不是补齐为最短回文字符串，求一段代码，用c语言实现", "Tag": "算法分析"}
{"Answer": "这个问题可以用图论来解决。图论是一门研究图形结构的数学分支，可以用来描述网络、流程、导航等问题。\n具体来说，这个问题可以用有向图来表示，其中每个地点对应一个图中的结点，每条路径对应一条有向边。要求求出A地到B地的最短路径，就可以使用最短路径算法来解决。\n最短路径算法有很多种，常用的有贪心算法和动态规划算法。这里介绍一种经典的最短路径算法——迪杰斯特拉算法。\n迪杰斯特拉算法的基本思想是从起点开始，每次找到一条到达不同结点的最短路径，直到找到终点为止。\n算法步骤如下：\n初始化：将起点设为已经访问过，并将起点到其它所有结点的距离设为无穷大（或某个极大值）。\n更新距离：遍历起点的所有出边，更新从起点出发能够到达的结点的距离值。如果从起点到某个结点的距离加上从该结点到另一个结点的距离，则更新从起点到该结点的距离为前者。\n找到最近结点：从未访问过的结点中找到离起点最近的结点，将其设为已访问过。\n重复步骤2和步骤3，直到找到终点为止。\n\n算法结束后，起点到终点的距离即为从起点到终点的最短路径。\n举个例子，假设有一张图如下：\nA ---3---> B ---2---> C\n| /\n1 /\n| /\nv /\nD ---2---> E\n起点为A，终点为E。\n首先将A设为已访问过，并将A到其它所有结点的距离设为无穷大。\n然后更新距离。遍历A的出边，可以发现A到B的距离为3，A到D的距离为1。将这两条路径的距离设为3和1。\n接下来找到最近结点。可以发现A到D的距离最小，因此将D设为已访问过。\n然后更新距离。遍历D的出边，可以发现A到D到E的距离为3，比A到E的距离小，因此将A到E的距离更新为3。\n找到最近结点，发现A到E的距离最小，因此将E设为已访问过。由于E是终点，因此算法结束。\n最终，A到E的距离为3，即为A到E的最短路径。\n在迪杰斯特拉算法中，需要用到一些数据结构来存储图的信息。通常可以使用邻接矩阵或邻接表来表示图，也可以使用堆来优化算法的执行效率。", "Konwledge_Point": "负权边的最短路径", "Question": "从A地到B地有多条路径可以到达，现要从A地到B地运物资问题\n从A地到B地有多条路径可以到达，现要从A地到B地运物资，设计一个求走那条路径最短的算法，这个题目用了哪些数据结构？大致的算法思想是什么？", "Tag": "算法分析"}
{"Answer": "#include <iostream>\nusing namespace std;\nint main()\n{\n  int n,i;\n  string *A;\n  int max=0;\n  int min = 0;\n  int avg = 0;\n  cin>>n;\n  if(n>0)\n  {\n    A = new string[n];\n    for(i=0;i<n;i++)\n    {\n      cin>>A[i];\n      if(A[max].length() < A[i].length())\n          max = i;\n      if(A[min].length() > A[i].length())\n          min = i;\n      avg += A[i].length();\n    }\n    cout<<\"最长的串:\"<<A[max]<<endl;\n    cout<<\"最短的串:\"<<A[min]<<endl;\n    cout<<\"平均长度:\"<<avg/n<<endl;\n    \n    delete []A;\n  }\n  return 0;\n}\n", "Konwledge_Point": "负权边的最短路径", "Question": "自考C++，问个练习题\n1，编写一个程序，将从键盘输入的n个字符串保存在一个一维数组A中，在输入字符串之前，先输入n的值，要求数组A需要动态申请空间，程序运行结束前再释放掉。\n2，在题目一的基础上，输出n个字符串中最长的和最短的串，计算n个串的平均长度，并输出结果。\n\n\n自学的，没有老师同学，挺尴尬的，给讲详细点吧。谢谢了。", "Tag": "算法分析"}
{"Answer": "https://www.nowcoder.com/questionTerminal/9929785afd364470bc8da265087d1aaf", "Konwledge_Point": "负权边的最短路径", "Question": "平面直角坐标系上距离点的计算，一个优化的算法，采用C语言谢谢\nProblem Description\n\nACboy is playing a new stone game. There's a rectangular grid board, and some stones placed at the initial location Bi(Xi, Yi) and the targets are at the location Si(Pj, Qj), the time that moving between them is Di,j = |Xi - Pj| + |Yi - Qj| + 1 minutes. And at different places may have different stones, and different target places have different capacity. In the following picture, B1,2,3 stands for the initial places, S1,2,3,4 stands for the target places. In detail, B1(5) means there are 5 stones at this location, S2(4) means you can move at most 4 stones to this target location.\n\n\n\nThe one who moves the stones from the initial places to the target places using less time will win. So ACboy now telling you his play plan, and you should tell hime whether his plan is the best, or he can do it better.\n\n\n\nInput\n\nThe input file consists of The game board description and the play plan description. The first line of the input file consists of two numbers N and M separated by a space. N (1 <= N <= 100) is a number of initial places(numbered from 1 to N). M (1 <= M <= 100) is a number of target places(numbered from 1 to M).\n\n\n\nThe following N lines describe initial places. Each line contains there integer numbers Xi, Yi, and Bi separated by spaces, where Xi, Yi (-1000 <= Xi, Yi <= 1000) are the coordinates of initial places, and Bi (1 <= Bi <= 1000) is the number of stones at this location.\n\n\n\nThe description of initial places is followed by M lines that describe target places. Each line contains three integer numbers Pj, Qj, and Cj separated by spaces, where Pi, Qi (-1000 <= Pj, Qj <= 1000) are the coordinates of the target places, and Cj (1 <= Cj <= 1000) is the capacity of this place.\n\n\n\nThe description of the play plan follows on the next N lines. The play plan of ith initial place consists of M integer numbers Ei,j separated by spaces. Ei,j (0 <= Ei, j <= 1000) is a number of stones that shall move from the ith initial place to the jth target place.\n\n\n\nThe plan in the input file is guaranteed to be valid. Namely, B1+B2+....+Bn <= S1+S2+....+Sn.\n\n\n\nProcess to the end of file.\n\n\n\nOutput\n\nIf ACboy's plan is the best, print \"good\", otherwise, print\"I can do it better\".\n\n\n\nSample Input\n\n2 1\n\n0 0 5\n\n1 1 5\n\n2 2 5\n\n5\n\n0\n\n\n\nSample Output\n\nI can do it better", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/hero5201/article/details/51812963", "Konwledge_Point": "负权边的最短路径", "Question": "一个有关最短时间的计算的算法的问题，谢谢\nProblem Description\n\n在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？\n\n\n\nInput\n\n输入包括多组数据。每组数据第一行是两个整数N、M（N<=100，M<=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1<=A,B<=N,1<=C<=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。\n\n输入保证至少存在1条商店到赛场的路线。\n\n\n\nOutput\n\n对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间\n\n\n\nSample Input\n\n2 1\n\n1 2 3\n\n3 3\n\n1 2 5\n\n2 3 5\n\n3 1 2\n\n0 0\n\n\n\nSample Output\n\n3\n\n2", "Tag": "算法分析"}
{"Answer": "\nYou could sort the strings by length using for example usort and get the first item using reset.\n$array = array(\n    'Google',\n    'Facebook',\n    'Twitter',\n    'Slack',\n    'Twilio',\n);\n\nusort($array, function ($a, $b) {\n    return strlen($a) < strlen($b);\n});\n\necho reset($array); // Facebook\n\nIf there could be more strings with equal length, you could use a foreach and break out of the loop when the length is not equal to the current length of the item to prevent looping the whole list.\n$item = reset($array);\n$result = [];\n\nif ($item) {\n    $len = strlen($item);\n    foreach($array as $value) {\n        if (strlen($value) === $len) {\n            $result[] = $value;\n            continue;\n        }\n        break;\n    }\n}\n\nprint_r($result);\n\nResult\nArray\n(\n    [0] => Facebook\n    [1] => Test1112\n)\n\nPhp demo\n", "Konwledge_Point": "负权边的最短路径", "Question": "PHP在没有循环的情况下获取数组中最长的字符\n\n\n\nGiven an array, I want to get the longest string by length without using the foreach loop.\n\n\n\nBelow is my array\n\n\n\n$array = array(\n    'Google',\n    'Facebook',\n    'Twitter',\n    'Slack',\n    'Twilio',\n);\n\n\n\n\nThis question returns the maximum length but I want to get the value of the string.\n\nPHP shortest/longest string in array\n\n    ", "Tag": "算法分析"}
{"Answer": "这个叫做 中国邮递员问题，你可以google下\r\nhttps://www.cnblogs.com/WABoss/p/5140531.html", "Konwledge_Point": "负权边的最短路径", "Question": "欧拉回路避桥法的扩展：遍历无向图里的所有边，当这个图不是欧拉回路时，怎样使得走过的重复边最少？\n遍历所有点的问题是tsp问题，但是如果需要遍历所有的边呢？\n\n欧拉回路的避桥法可以对于欧拉回路，实现不重复的遍历所有边，\n\n但是如果该图不是欧拉回路，该怎样在最短行驶路径下遍历所有边呢？\n\n\n\n问题：\n\n\n\n\n给定一个无向连通图，不是欧拉图，需要遍历其中所有**边**，\n\n可以重复走边，问：怎样使得走过的重复路径最少？\n\n做课设需要解决这个问题，有相关的算法吗，\n\n如果没有，该怎样修改对于欧拉回路的避桥法呢？", "Tag": "算法分析"}
{"Answer": "http://download.csdn.net/download/zy841958835/9913574", "Konwledge_Point": "负权边的最短路径", "Question": "求java笔试面试题目 大神们\n各位大神马上准备去面试华为 求java的一些面试笔试题目 \n\n最好基础点的 有解答", "Tag": "算法分析"}
{"Answer": "http://www.cnblogs.com/CheeseZH/archive/2012/04/29/2476134.html", "Konwledge_Point": "负权边的最短路径", "Question": "买票的问题求解           \nDescription\n\n\n\nRailway tickets were difficult to buy around the Lunar New Year in China, so we must get up early and join a long queue…\n\n\n\nThe Lunar New Year was approaching, but unluckily the Little Cat still had schedules going here and there. Now, he had to travel by train to Mianyang, Sichuan Province for the winter camp selection of the national team of Olympiad in Informatics.\n\n\n\nIt was one o’clock a.m. and dark outside. Chill wind from the northwest did not scare off the people in the queue. The cold night gave the Little Cat a shiver. Why not find a problem to think about? That was none the less better than freezing to death!\n\n\n\nPeople kept jumping the queue. Since it was too dark around, such moves would not be discovered even by the people adjacent to the queue-jumpers. “If every person in the queue is assigned an integral value and all the information about those who have jumped the queue and where they stand after queue-jumping is given, can I find out the final order of people in the queue?” Thought the Little Cat.\n\n\n\nInput\n\n\n\nThere will be several test cases in the input. Each test case consists of N + 1 lines where N (1 ≤ N ≤ 200,000) is given in the first line of the test case. The next N lines contain the pairs of values Posi and Vali in the increasing order of i (1 ≤ i ≤ N). For each i, the ranges and meanings of Posi and Vali are as follows:\n\n\n\nPosi ∈ [0, i − 1] — The i-th person came to the queue and stood right behind the Posi-th person in the queue. The booking office was considered the 0th person and the person at the front of the queue was considered the first person in the queue.\n\nVali ∈ [0, 32767] — The i-th person was assigned the value Vali.\n\nThere no blank lines between test cases. Proceed to the end of input.\n\n\n\nOutput\n\n\n\nFor each test cases, output a single line of space-separated integers which are the values of people in the order they stand in the queue.\n\n\n\nSample Input\n\n\n\n4\n\n0 77\n\n1 51\n\n1 33\n\n2 69\n\n4\n\n0 20523\n\n1 19243\n\n1 3890\n\n0 31492\n\nSample Output\n\n\n\n77 33 69 51\n\n31492 20523 3890 19243", "Tag": "算法分析"}
{"Answer": "\nCheck out uniqid().  If you are ultra paranoid, put the filename generation in a loop where you check to see if it exists or not.\n$prefix   = hash('sha256', $bits) . '-';\n$filename = uniqid($prefix, true);\n\nThis creates a SHA-256 hash of the bits as the prefix to the file, and uses uniqid to create a unique file name with the prefix of the file being the hash of the bits followed by a -.\nThis should generate a unique filename that you can identify by hashing the bits.\n", "Konwledge_Point": "负权边的最短路径", "Question": "将2025位转换为最短文件名\n\n\n\nI have some information represented by 2025 bits. For caching purposes i need to create a unique filename ( not too long of course so fs will handle this ) which will represent these bits. Every set of bits should have unique filename.\n\n\n\nIs md5 suitable for this ? If not , what should i use ?\n\n    ", "Tag": "算法分析"}
{"Answer": "\nFirst get the minimum length of all the sub-arrays:\n$min_length = min(array_map('count', $array));\n\nThen filter the array to get the elements that have that length:\n$new_array = array_filter($array, function ($el) use ($min_length) {\n    return count($el) == $min_length);\n});\n\n", "Konwledge_Point": "负权边的最短路径", "Question": "获取最短阵列列的所有值\n\n\n\nI have this array :\n\n\n\nArray\n(\n    [0] => Array        // count 2 values\n        (\n            [0] => 3\n            [1] => 1\n        )\n\n    [1] => Array        // count 2 values\n        (\n            [0] => 2\n            [1] => 2\n        )\n\n    [2] => Array        // count 4 values\n        (\n            [0] => 1\n            [1] => 1\n            [2] => 1\n            [3] => 1\n        )\n\n)\n\n\n\n\nand I want to get all of the value of the shortest column. in this case :\n\n\n\nArray\n(\n    [0] => Array\n        (\n            [0] => 3\n            [1] => 1\n        )\n\n    [1] => Array\n        (\n            [0] => 2\n            [1] => 2\n        )\n\n)\n\n\n\n\nI post about this case before here : \nHow To Get ALL Minimum Value Within Multidimensional Array?\n\n\n\nbut unfortunately that case was using associative array. while in this case isn't associative array.\n\n\n\nhow to get the value from array like this?\n\n    ", "Tag": "算法分析"}
{"Answer": "\n\n#include <stdio.h>\n#include <string.h>\n\nvoid bubble_sort(char a[][100], int n)\n{\n    int i ,j;\n    char temp[100] = {0};\n    for(i = 0; i < n - 1; i++)\n    {\n          for(j = 0; j <n - 1 - i; j++)\n         {\n            if(strlen(a[j]) < strlen(a[j+1]))\n            {\n                memset(temp, 0,sizeof(temp));\n                memcpy(temp, a[j], strlen(a[j]));\n                memset(a[j], 0,sizeof(a[j]));\n                memcpy(a[j], a[j+1], strlen(a[j+1]));\n                memset(a[j+1], 0,sizeof(a[j+1]));\n                memcpy(a[j+1], temp, strlen(temp));\n            }\n         }\n    }\n}\n\nint main()\n{\n    char x[3][100] = {0}, v[100] = {0};\n    printf(\"input 3 str\\n\");\n    scanf(\"%s%s%s\", x[0], x[1], x[2]);\n    bubble_sort(x, 3);\n    printf(\"%s\\n\", strcat(x[0], x[2]));\n    return 0;\n}\n", "Konwledge_Point": "负权边的最短路径", "Question": "输入三个字符串，再将最长字符串和最短字符串连接，再将结果输出\n输入三个字符串，再将最长字符串和最短字符串连接，再将结果输出。很多报错，请讲解一下", "Tag": "算法分析"}
{"Answer": "echo '最长'.$arr3[0].\"\";  //最长的if($x1-$x2>=3){  //x1是所有字符串个数,包括空字符串; x2不包括空字符串的个数  我随便设置空的至少3个    echo \"空\";    return;}else{  //没有空的或者空小于2的    echo $arr3[$x2-1].\"\";    echo $arr3[$x2-2].\"\";}", "Konwledge_Point": "负权边的最短路径", "Question": "PHP如何从n个字符串中挑选出那个不为空的最短字符串m\n如何从n个字符串（其中有x个空字符串，0≤x≤n）中挑选出那个不为空的最短字符串（m）。\n与此同时还需要兼顾考虑以下特例：如果n个字符串中有x个为空（x<n），则m为空。\n\n\n比如我们可以定义n=10，x=5，这就意味着：\n1、当10个字符串中有2个是空字符串(2显然是小于5的)，则m=最短的那个非空字符串\n2、当10个中有5个或6个是空字符串时，则m=''（m=空）", "Tag": "算法分析"}
{"Answer": "参考GPT和自己的思路：首先，需要将输入的字符串按照空格分隔为各个子串，可以使用字符串分割的方法来实现。接下来，遍历每个子串，记录最长和最短的子串以及其中出现的最大和最小字符。这些都可以通过比较字符串长度和字符的ASCII码值来完成。最后，将记录的结果输出即可。以下是一段示例代码：\ninput_string = input(\"请输入字符串：\")\nsubstrings = input_string.split(\" \")\n\nmin_substring = substrings[0]\nmax_substring = substrings[0]\nmin_char = input_string[0]\nmax_char = input_string[0]\n\nfor substring in substrings:\n    if len(substring) < len(min_substring):\n        min_substring = substring\n    elif len(substring) > len(max_substring):\n        max_substring = substring\n\n    for char in substring:\n        if ord(char) < ord(min_char):\n            min_char = char\n        elif ord(char) > ord(max_char):\n            max_char = char\n\nprint(\"最短子串为：\" + min_substring)\nprint(\"最长子串为：\" + max_substring)\nprint(\"最小字符为：\" + min_char)\nprint(\"最大字符为：\" + max_char)\n\n希望这能解决你的问题！", "Konwledge_Point": "负权边的最短路径", "Question": "我想知道怎么显示出最长，最短子串呢？\n按空格分隔开以后怎样可以是子串之间相互比较然后显示出最长最短子串啊？\n题目如下:\n输入一字符串，各个子串之间按空白字符隔开，分别显式其中最长、最短子串，以及最大、最小字符。", "Tag": "算法分析"}
{"Answer": "d没传进去，还有类名、包名最好不要用汉字哈\n\npublic static void main(String[] args) {\n      double d = 3.1415926;\n        String result = String.format(\"%.2f\", d);\n        System.out.println(result);\n    }\n", "Konwledge_Point": "负权边的最短路径", "Question": "这个保留小数为什么运行报错啊还有 为什么JAVA保留个小数都这么磨叽 找了好几种方法 就这个最短 哭了\n 这个保留小数为什么运行报错啊还有 为什么JAVA保留个小数都这么磨叽 找了好几种方法 就这个最短 哭了", "Tag": "算法分析"}
{"Answer": "设材料的长度为l，可以写成 l = 19x+23y+a，于是题目的意思就是当x，y取何值时，a的值最小。于是我们可以穷举出所有的a，打印最小值即可。另外不难得出，x的取值范围为0到l//19，y的取值范围为0到l//23，而当剩下的材料小于0时，则取值不成立，于是可列出代码如下\nl = int(input())\nb = []\nfor x in range(l//19+1):\n    for y in range(l//23+1):\n        a = l-19*x-23*y\n        if a<0:\n            break\n        b.append((a,x,y))\nres = min(b)\nprint(f\"19米{res[1]}段,23米{res[2]}段,剩余{res[0]}米\")\n", "Konwledge_Point": "负权边的最短路径", "Question": "剩余最短木料，怎么是剩余木料大于0\n问一下怎么限定剩余木料长度大于0啊！麻烦用简单的代码，才开始学习的学生，社区里能够搜到的答案所用代码没学过啊", "Tag": "算法分析"}
{"Answer": "\nThe Pythagorean distance between two points is calculated by:\ndistance = sqrt( (x1-x0)^2 + (y1-y0)^2 )\n\nThat's  not what your query is calculating:\nSELECT regid, sqrt(latitude-$lati)+sqrt(longitude-$longi) AS SQRT_DIST FROM GPS_tbl ORDER BY SQRT_DIST limit 1\n\nYou've got the square root of two values added together, not the square root of the sum. Try this instead:\nSELECT regid, sqrt( (latitude-$lati)*(latitude-$lati) +(longitude-$longi)*(longitude-$longi) ) AS SQRT_DIST FROM GPS_tbl ORDER BY SQRT_DIST limit 1\n\nNow, a couple of things.\n\nThis distance calculation is an adequate approximation if the distance between the two points is small, but once you get into larger values, it will get farther and farther from the true value. Why? Because the surface of the earth is the surface of a sphere, not a plane. To calculate the correct value, google \"Great Circle Distance\"\nSomebody else will probably mention this, but here goes 1) don't use mysql_ functions: they're deprecated; and 2) your code is vulnerable to SQL injection attacks.\n\n", "Konwledge_Point": "负权边的最短路径", "Question": "如何根据给定条件选择最短的GPS坐标？\n\n\n\nI have table \nGPS_tbl\n in mysql database \nmy_db\n. In \nGPS_tbl\n there are five columns \n1)uid 2)latitude 3)longitude 4)regid 5)status\n. In column \n5)status\n there are two types of values are stored as varchar one is \nfree\n and other is \nmove\n. What i am doing right now is when user send his/her gps coordinates in terms of \nlatitude\n and \nlongitude\n through \nPOST()\n, so to select the shortest coordinate from columns \n2)latitude 3)longitude\n  i am using \nPythagorean theorem\n so by using this i compare these user sent coordinate with already stored coordinates in columns \n2)latitude 3)longitude\n and select the \n4)regid\n against it. Now what i want is only select that \n4)regid\n against shortest coordinate from \n2)latitude 3)longitude\n whose \n5)status\n value is \nfree\n. \n\n\n\nAt the moment i am using this query, which is only selecting \n4)regid\n against \nshortest coordinate\n and not taking care of \nstatus\n value:\n\n\n\n$result = mysql_query(\"SELECT regid, sqrt(latitude-$lati)+sqrt(longitude-$longi) AS SQRT_DIST FROM GPS_tbl ORDER BY SQRT_DIST limit 1\");\n\n\n\n\nGPS_tbl\n\n\n\n+--------------+------------+-------------+-------------+-------------+\n|     uid      | latitude   | longitude   |   regid     |   status    |\n+--------------+------------+-------------+-------------+-------------+\n|      1       |  73.3433   |  18.5223    |APA91W-ClDoS |   move      |\n|              |            |             |             |             |\n+--- ----------+------------+-------------+-------------+-------------+\n|      2       |  43.3433   |  24.5523    |BON91W-ClDoS |   free      |\n|              |            |             |             |             |\n+--- ----------+------------+-------------+-------------+-------------+\n|      3       |  55.3433   |  37.5323    |WCD71P-ClDoS |   free      |\n|              |            |             |             |             |\n+--- ----------+------------+-------------+-------------+-------------+\n|      4       |  65.3433   |  47.5323    |ZCF71D-ClDoS |   move      |\n|              |            |             |             |             |\n+--- ----------+------------+-------------+-------------+-------------+\n|      5       |  85.3433   |  27.5323    |XVD73A-ClDoS |   free      |\n|              |            |             |             |             |\n+--- ----------+------------+-------------+-------------+-------------+\n\n\n    ", "Tag": "算法分析"}
{"Answer": "\nThe algorithm you describe is could be OK but it is less clearly specified when it comes to \"... this way I would need to go through the whole array\". \nOnce you have done the clean up and splitting into words, It will be easier to create a map for the key words, so you can know quickly if a word from the text matches (with isset()). Then you could just reduce the text array to an array of matching words (using array_filter()), still keeping the index of where they appear in the original array of words.\nThe algorithm would then walk through that reduced array and keep track of a window (range) of these words. At the right side that window enlarges as long as not all necessary words are inside of it, and it shrinks at the left side when the left side word already occurs elsewhere in the window, or just after you have found a candidate solution. That way your window will travel through the whole (reduced) text array. You'll keep track only of the window that represents the shortest phrase. So at the end you have the optimal solution and just need to translate the window boundaries back to a phrase taken from the original text array.\nCase insensitive matching can be achieved by storing things in lower case (with strtolower), and by using the original cased string (in array format) for generating the output. \nHere is a function that implements the above described algorithm:\nfunction findFragment($text, $words) {\n    // Remove non-A-Z letters\n    $text = preg_replace(\"/[^a-z ]/i\", \"\", $text);\n    $words = preg_replace(\"/[^a-z ]/i\", \"\", $words);\n    // Create a map keyed by the words to find, with as value \n    // the number of occurrences in current sub-phrase\n    $words_map = array_fill_keys(str_word_count(strtolower($words), 2), 0);\n    // Put all words of text in an array\n    $text_arr = str_word_count($text, 1);\n    $text_low_arr = str_word_count(strtolower($text), 1);\n    // Filter only matching words from the text, keeping their original indexes.\n    $matches = array_filter($text_low_arr, function ($word) use ($words_map) {\n        return isset($words_map[$word]);\n    });\n    // How many distinct words need to be matched to have a candidate phrase\n    $matches_left = count($words_map);\n    // Keep track of how long the shortest phrase is\n    $min_words = count($text_arr) + 1; // start \"infinite\"\n    // Loop over all matching words as the last word of a possible phrase\n    foreach($matches as $i => $match) {\n        $phrase[$i] = $match; // Add to the phrase\n        $words_map[$match]++; // Increase count for this particular word\n        if ($words_map[$match] > 1) continue; // Nothing new was added\n        // Additional word found\n        $matches_left--;\n        if ($matches_left) continue; // Still need more words\n        // Phrase has all words\n        // Remove words from left which occur elsewhere in the phrase\n        while ($words_map[reset($phrase)] > 1) {\n            $words_map[reset($phrase)]--;\n            unset($phrase[key($phrase)]);\n        }\n        // How many words are in this phrase?\n        $num_words = $i - key($phrase) +1;\n        if ($num_words < $min_words) {\n            // It is shorter than we had so far\n            $min_words = $num_words;\n            $best_start = key($phrase);\n        }\n        // Remove first word from phrase before finding new candidate phrases\n        $words_map[reset($phrase)]--;\n        unset($phrase[key($phrase)]);\n        $matches_left++;\n    }\n    // return best result\n    return implode(\" \", array_slice($text_arr, $best_start, $min_words));\n}\n\nYou would call it like this:\necho findFragment($text, $words);\n\nFor the sample data you have given in the question, it returns the desired answer:\n\nBeispieltext der ein paar Wrter \n\nSee it run on eval.in. \n", "Konwledge_Point": "负权边的最短路径", "Question": "在Textblock中搜索给定关键字的最短通道\n\n\n\ni have a task and i am not sure how i should solve the problem. I have an idead but i do not know if it is the best way to solve it.\n\n\n\nHere is the task:\nGiven is a block of text and some keywords to find. We need to find a passage where all words can be found and where least words are used. Only the letters from A-Z and a-z need to be taken into account.\n\n\n\nHere is an example:\n\nTextblock:\n\nEin toller Beispieltext ist der Blindtext. Er hat ein paar Wörter. Dies ist\nein Beispieltext, der ein paar Wörter hat und auch noch ein paar mehr, um\ndie Zeile etwas länger zu machen. Darüber hinaus ist er nur dafür da, um\ngenügend Testtext zusammenzubekommen. Dem Text selbst macht das nicht so\nviel aus. Früher einmal mehr, als er noch nicht so selbstbewusst war. Heute\nkennt er seine Rolle als Blindtext und fügt sich selbstbewusst ein. Er ist\nja irgendwie wichtig. Manchmal jedoch, ganz manchmal, weint er in der Nacht,\nweil er niemals bis zum Ende gelesen wird. Doch das hat ja jetzt zum Glück\nein Ende.\n\n\n\nAnd here the words that need to be found:\nein\nBeispieltext\nder\npaar\nWörter\n\n\n\nThe result would be\nBeispieltext der ein paar Wrter\n\n\n\nFollowing passage would also be a passage where all the words can be found but it has more words inside of the passage and therefore is not the solution:\nEin toller Beispieltext ist Blindtext. Er hat ein paar Wörter.\n\n\n\nMy idea is to cut all unnecessary letters and then split the textblock on spaces to have an array of all words. so i can get the position of the words and calculate how much words are inbetween the first occurence of one of the searched words and the first occurence of all other searched words. this way i would need to go through the whole array and compare all possible lengths of passages and just take the shortest one.\n\n\n\ndo you think this is the best approach or can you point me to a better idea how to solve this problem?\n\n    ", "Tag": "算法分析"}
{"Answer": "ArrayList是一个顺序存储的数据结构，只能顺序存储吧，查询数据也就只能用顺序遍历。。。。\r\n如果是已经排序的，那么二分查找是可以的，没排序的话顺序遍历吧\r\n\r\n一般吧 要想快，用HashMap或者HashSet之类的", "Konwledge_Point": "负权边的最短路径", "Question": "最快的方法从list中取指定的值\nList list = new ArrayList();\n\nlist.add(\"aa\");\n\nlist.add(\"bb\");\n\nlist.add(\"cc\");\n\nlist.add(\"dd\");\n\n      .\n\n      .\n\n      .\n\n假设我不知道list中各个值的下标，在这种情况下用最快的方法，取出“cc”。", "Tag": "算法分析"}
{"Answer": "x0=x1=y0=y1=0\nwhile True:\n    inp = input('请输入方向和数字空格隔开，或q退出：')    \n    if inp == 'q':\n        break\n    a=inp.split()[0].lower()\n    b=int(inp.split()[1])\n\n    if a=='up':\n        y1+=b\n    elif a=='down':\n        y1-=b\n    elif a=='left':\n        x1-=b\n    elif a=='right':\n        x1+=b\ndis=round(((x1-x0)**2+(y1-y0)**2)**0.5)\nprint(f'distance:{dis}')\n\n运行结果：\n请输入方向和数字空格隔开，或q退出：UP 5    \n请输入方向和数字空格隔开，或q退出：DOWN 3\n请输入方向和数字空格隔开，或q退出：LEFT 3\n请输入方向和数字空格隔开，或q退出：RIGHT 2\n请输入方向和数字空格隔开，或q退出：q\ndistance:2\n\n", "Konwledge_Point": "负权边的最短路径", "Question": "python练习题，关于点的移动的问题\n【编程题】机器人从原点（0,0）开始在平面中移动。 机器人可以通过给定的步骤向上，向下，向左和向右移动。 机器人运动的痕迹如下所示：\n\n\nUP 5\n\n\nDOWN 3\n\n\nLETF 3\n\n\nRIGHT 2\n\n\n方向之后的数字是步骤。 请编写一个程序来计算一系列运动和原点（由input输入）之后距当前位置的距离。如果距离是浮点数，则只打印最接近的整数。\n\n\n例：如果给出以下元组作为程序的输入：\n\n\nUP 5\n\n\nDOWN 3\n\n\nLETF 3\n\n\nRIGHT 2\n\n\n然后，程序的输出应该是：2", "Tag": "算法分析"}
{"Answer": "主要使用到Split()用来分割字符串，for循环进行判断，以及System.Text.Encoding.Default.GetByteCount()获取字符长度。\n static void Main(string[] args)\n        {\n            string str = \"wsd1132大江东去，浪淘尽wsd1132，千古风流人物。#故垒西边wsd1132，人道是，#三国周郎赤壁wsd1132。#乱石穿空，惊涛拍岸wsd1132，卷起千堆雪。#江山如画，一时多少豪杰。#\";\n            var list = str.Split('#');//分隔符#\n            string m = \"\";//最短字符\n            int num = 0;//为空次数\n            for (int i = 0; i < list.Length; i++)\n            {\n                string n = list[i];//单个分割字符串\n                if (m == \"\" || (n != \"\" && System.Text.Encoding.Default.GetByteCount(m) > System.Text.Encoding.Default.GetByteCount(n)))\n                {\n                    m = n;\n                }\n                if (n == \"\")\n                {\n                    num++;//记录为空的次数\n                }\n            }\n            if (num > 3)\n            {//如果这n个字符串中有3个以上的是空字符串，则m也等于空\n                m = \"\";\n            }\n            Console.WriteLine(\"你获取的最短字符：\" + m);\n        }\n\n这是结果\n", "Konwledge_Point": "负权边的最短路径", "Question": "C#如何从分割的n个字符串中挑选出那个不为空的最短字符串m呢？\n字符串如下：\n\n\n\n\nwsd1132大江东去，浪淘尽wsd1132，千古风流人物。#\n@#故垒西边wsd1132，人道是，#三国周郎赤壁wsd1132。#乱石穿空，惊涛拍岸wsd1132，卷起千堆雪#。@#江山如画，一时多少豪杰。#@#\n\n\n\n\n分隔符  \n#和@\n 【因为CSDN不允许提问时有连续的#出现，不得已换成了#\n@的组合，也就是说，分隔符都是#亦可】\n分割后的字符串如下（注意其中有空字符串）\n\n\nwsd1132大江东去，浪淘尽wsd1132，千古风流人物。\n\n\n\n故垒西边wsd1132，人道是，\n三国周郎赤壁wsd1132。\n乱石穿空，惊涛拍岸wsd1132，卷起千堆雪。\n\n\n江山如画，一时多少豪杰。\n\n\n\n\n\n\n然后，分以下3种情况去找m的值\n\n\n\n\n1、如果这n个字符串全部不为空，则m就等于最短的那个字符串\n2、如果这n个字符串中有2个以下的是空字符串，则m依然等于最短的那个字符串\n3、如果这n个字符串中有3个以上的是空字符串，则m也等于空。\n\n\n\n\n最后，分情况输出m的值。", "Tag": "算法分析"}
{"Answer": "\n<?php\n$arr = array();\nfor($i=0; $i<20; $i++){\n  $random_num = rand(1,200);\n  array_push($arr, $random_num);\n}\n\n?>\n\n", "Konwledge_Point": "负权边的最短路径", "Question": "生成具有特定范围的20个随机数的最短方法\n\n\n\nI need to generate an array containing 20 random numbers between 1 and 200. Is there a shorter/cleaner code I can use?\n\n\n\n'; print_r($x); echo '';\n?>\n\n\n    ", "Tag": "算法分析"}
{"Answer": "\nYou could have done it like this as well:\nif (isset($_GET['page']) && $_GET['page'] == 'items') {\n    if (isset($_GET['action']) && ($_GET['action'] == 'new' || $_GET['action'] == 'edit')) {\n\n    }\n}\n\n", "Konwledge_Point": "负权边的最短路径", "Question": "如果条件，这个PHP多重编码的最短方式\n\n\n\nI am trying to do a query like:\n\n\n\nIf \n$_GET['page'] == 'items'\n AND \n$_GET['action'] == 'new' OR 'edit'\n\n\n\nHere's what I have:\n\n\n\nif (isset($_GET['page']) && $_GET['page'] == 'items') {\n    if (isset($_GET['action']) && $_GET['action'] == 'new' || isset($_GET['action']) && $_GET['action'] == 'edit') {\n\n        // This is what Im looking for\n\n    }\n}\n\n\n\n\nIs this correct, and is this the easiest way to make this query?\n\n    ", "Tag": "算法分析"}
{"Answer": "\nYou can use this function ... it works with unlimited arguments \nFunction\n<?php\n\nfunction prepare() {\n    $arg = func_get_args ();\n    $new = array ();\n    foreach ( $arg as $value ) {\n        $new [] = strtolower ( str_replace ( array (\n                \" \" \n        ), \"-\", $value ) );\n    }\n    return implode ( \" \", $new );\n}\n\n?>\n\nUsage \n<body class=\"<?php echo prepare($c->getCollectionName(),$c->getCollectionTypeName()); ?>\">\n\nDemo \n<body class=\"<?php echo prepare(\"ABC CLASS\",\"DEF\",\"MORE CLASSES\") ?>\">\n\nOutput \n<body class=\"abc-class def more-classes\">   \n\n", "Konwledge_Point": "负权边的最短路径", "Question": "在PHP中转换大小写和空格的最短方法\n\n\n\nI'm trying to add class name in my Concrete 5 theme. What's the elegant way to strip spaces and replace it with dashes then transform them to lower case?\n\n\n\nI already tried lowering the case but I also need to replace the space with dashes (-)\n\n\n\nHere's what my code look like:\n\n\n\n\n\n\n\n\nshould look like this\n\n\n\n\n\n\n\n\nThanks.\n\n    ", "Tag": "算法分析"}
{"Answer": "是：\r\n\r\n```\r\n Alt+Shift+B\r\n```", "Konwledge_Point": "负权边的最短路径", "Question": "eclipse的快捷键问题，希望大家知道的说一下\n\n请问显示这个行级结构的快捷键是什么？", "Tag": "算法分析"}
{"Answer": "\n//汉诺塔问题\n#include <stdio.h>\nvoid move(char pose1,char pose2)\n{\n    printf(\"%c-->%c  \",pose1,pose2);//模拟鼠标移动盘子的过程\n}\nhanoi(int n,char pose1,char pose2,char pose3)\n{\n    if (n == 1)\n    {\n        move(pose1, pose3);//只有一个时我们可以直接从A-->C\n    }\n    if (n > 1)\n    {\n        hanoi(n - 1, pose1, pose3, pose2);//多个盘子时，先将上面n-1个，通过B->C\n        move(pose1, pose3);//第二步，将A上剩下的一个移动到目的地C\n        hanoi(n - 1, pose2, pose1, pose3);\n        //第三步，将B上n-1个借助C移动到A；再将B剩下一个移动到C\n    }\n}\nint main()\n{\n    int n = 0;\n    scanf(\"%d\", &n);\n    hanoi(n, 'A','B','C');\n    return 0;\n}\n", "Konwledge_Point": "负权边的最短路径", "Question": "汉诺塔问题四个盘子四个塔座，用最短步骤\n1.求怎么样用Ｃ语言去描述\n2.也想有一个调用过程可以帮助我理解", "Tag": "算法分析"}
{"Answer": "\n<?php\n\n$items = [\n    'whatever',\n    'something else',\n    'foobar'\n];\n\n$matches  = preg_grep ('/foobar/', $items);\nvar_dump($matches);\n\n?>\n\nYou don't need to iterate over the array, you can use preg_grep and pass your array instead.\nHappy coding\n", "Konwledge_Point": "负权边的最短路径", "Question": "使用正则表达式在数组中查找某个值的最短代码？\n\n\n\nLets say I have an array with these elements:\n\n\n\n[\n    'whatever',\n    'something else',\n    'foobar'\n]\n\n\n\n\nI know I can iterate over the array and check for foobar using a regex for example. The question is, is there a shorter way of doing that?\n\n\n\nThanks?\n\n    ", "Tag": "算法分析"}
{"Answer": "#include <iostream>\n#include <cstring>\nusing namespace std;\n \nint main() {\n    char s[512], *p = s, t[512], m[512];\n    int len=0, max=0;\n    gets(s);\n \n    do {\n        if ((*p>='a' && *p<='z') || (*p>='A' && *p<='Z')) {\n            t[len++] = *p;\n        } else {\n            if (len>max) {\n                t[len] = 0;\n                strcpy(m, t);\n                max = len;\n            }\n            len = 0;\n        }\n        p++;\n    } while (*p!=0);\n    if (len>max) {\n        t[len] = 0;\n        strcpy(m, t);\n        max = len;\n    }\n \n    cout <<\"-------------------\" << endl;\n    cout << m << endl;\n    cout <<\"-------------------\" << endl;\n \n    return 0;\n}\n", "Konwledge_Point": "负权边的最短路径", "Question": "C++获取字符串中的最长单词\n编写程序，求出所给出的字符串中最长的字母字串(以非字母隔开),例如，字符串”Apple$12pear watermelon $ # Banana“中最长的字母字串为\"watermelon\".\n\n\n答:\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n\nusing\n \nnamespace\n std;\n\n\nint\n \nmain\n()\n\n\n{\n    ios::\nsync_with_stdio\n(\nfalse\n);\n//不用管\n\n    cin.\ntie\n(\nnullptr\n);            \n//不用管\n\n\n    \nint\n n = \n0\n;\n    \nint\n maxlen = \n0\n;\n    \nchar\n t[\n100\n];\n    \nchar\n max[\n100\n];\n    \nchar\n s[\n100\n];\n    cin.\ngetline\n(s, \n100\n);\n    \nfor\n (\nint\n i = \n0\n; s[i\n-1\n]; i++)\n//当遍历到最后一项时如果也是字母 判断条件为s[i]则不会考虑最后一串单词。\n\n    {                            \n//判断条件为s[i-1]时 可以遍历到'\\0'所以会考虑最后一串单词。\n\n        \nif\n (\nisalpha\n(s[i]))\n//isalpha()判断字符是否为字母 不是则返回0 头文件为numeric\n\n        {\n            t[n++] = s[i];\n        }\n        \nelse\n\n        {\n            \nif\n (maxlen < n)\n            {    \n                \nint\n i;\n                maxlen = n;\n                \nfor\n ( i = \n0\n; i < n; i++)\n                {\n                    max[i] = t[i];\n                }\n                max[i] = \n'\\0'\n;\n//最长单词字符数组末尾加上'\\0'\n\n            }\n            n = \n0\n;\n//抽取一个单词后 不管长度是否比上一个单词大 临时储存的t字符数组的下标\n\n                \n//都要初始化为0 .\n\n        }\n    }\n    cout << max << endl;\n    \nreturn\n \n0\n;\n}\n\n", "Tag": "算法分析"}
{"Answer": "\n$foo = \"2, 4, 33, 25, 66\";\necho preg_replace(\"/(\\d+)(,?)/\", \"'1-$1'$2\", $foo );\n\nAs requested by @roullie, here's a fast regex solution.  In the regex, \\d+ matches 1 or more digits. ,? matches 0 or 1 comma (the last item does not have a common so I must match on 0 or 1.\n", "Konwledge_Point": "负权边的最短路径", "Question": "在PHP中修改逗号分隔列表中的字符串的最短方法\n\n\n\nIf I want to modify a comma separated list like this:\n\n\n\n$foo = \"2, 4, 33, 25, 66\"\n\n\n\n\nto become\n\n\n\n$foo = \"'1-2', '1-4', '1-33', '1-25', '1-66'\"\n\n\n\n\nWhat would be the fastest and most efficient way to achieve that in PHP?\n\n\n\nEDIT:\n\nI have tried this, but looking for a better way:\n\n\n\n$foo = \"2, 4, 33, 25, 66\";\n$bar = implode(\"', '1-\",explode(\",\",$foo));\n$foo = \"'1-\". $bar .\"'\";\n\n\n    ", "Tag": "算法分析"}
{"Answer": "改为 <=实际上代码可以很简单\n#include \"stdio.h\"\nint main()\n{\n  int N, A, B;\n  scanf(\"%d%d%d\", &N, &A, &B);\n  A -= (N - 1) % A + 1;\n  B -= (N - 1) % B + 1;\n  if (A < B)\n    printf(\"%d\", A);\n  else\n    printf(\"%d\", B);\n}\n\n", "Konwledge_Point": "负权边的最短路径", "Question": "最短米数问题，能帮我看看代码哪里错了吗？\n\n\n这个代码哪里出问题了吗，调试的时候会绕过while那里是正常的吗？代数之后运行数据出来很离谱，哪里错了吗？麻烦各位朋友帮我看看，万分感谢！", "Tag": "算法分析"}
{"Answer": "在字符串数组中用strcmp逐个比较输入字符串的所有位置下标。然后用下标进行循环比较求最小值", "Konwledge_Point": "负权边的最短路径", "Question": "定义一个字符串数组，用以接受用户输入的英文单词列表，随后再接受另外两个单词的输入，随后判断这两个单词在字符串数组中的最短距离，要求使用函数调用实现。\n问题遇到的现象和发生背景 2、    定义一个字符串数组，用以接受用户输入的英文单词列表（单词数不少于十个），随后再接受另外两个单词的输入（这两个单词必须是包含在前面的单词列表里面的单词），随后判断这两个单词在字符串数组中的最短距离，要求使用函数调用实现。\n\n\n问题相关代码，请勿粘贴截图\n\n\n运行结果及报错内容 2、    定义一个字符串数组，用以接受用户输入的英文单词列表（单词数不少于十个），随后再接受另外两个单词的输入（这两个单词必须是包含在前面的单词列表里面的单词），随后判断这两个单词在字符串数组中的最短距离，要求使用函数调用实现。\n\n\n输入：I am a Chinese I come from china and I am a college student\n输入：am Chinese\n输出：2\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果", "Tag": "算法分析"}
{"Answer": "\nUPDATE: This answer relates to older versions of go. For Go 1.8 and newer, see the AndreKR's answer below.\n\nIf you want something a bit less verbose than the standard library sort package, you could use the third party github.com/bradfitz/slice package.  It uses some tricks to generate the Len and Swap methods needed to sort your slice, so you only need to provide a Less method.\nWith this package, you can perform the sort with:\nslice.Sort(planets[:], func(i, j int) bool {\n    return planets[i].Axis < planets[j].Axis\n})\n\nThe planets[:] part is necessary to produce a slice covering your array.  If you make planets a slice instead of an array you could skip that part.\n", "Konwledge_Point": "负权边的最短路径", "Question": "用（任意）字段名称对结构数组进行简单排序的最短方法是什么？\n\n\n\nI just had a problem where I had an array of structs, e.g.\n\n\n\npackage main\n\nimport \"log\"\n\ntype Planet struct {\n    Name       string  `json:\"name\"`\n    Aphelion   float64 `json:\"aphelion\"`   // in million km\n    Perihelion float64 `json:\"perihelion\"` // in million km\n    Axis       int64   `json:\"Axis\"`       // in km\n    Radius     float64 `json:\"radius\"`\n}\n\nfunc main() {\n    var mars = new(Planet)\n    mars.Name = \"Mars\"\n    mars.Aphelion = 249.2\n    mars.Perihelion = 206.7\n    mars.Axis = 227939100\n    mars.Radius = 3389.5\n\n    var earth = new(Planet)\n    earth.Name = \"Earth\"\n    earth.Aphelion = 151.930\n    earth.Perihelion = 147.095\n    earth.Axis = 149598261\n    earth.Radius = 6371.0\n\n    var venus = new(Planet)\n    venus.Name = \"Venus\"\n    venus.Aphelion = 108.939\n    venus.Perihelion = 107.477\n    venus.Axis = 108208000\n    venus.Radius = 6051.8\n\n    planets := [...]Planet{*mars, *venus, *earth}\n    log.Println(planets)\n}\n\n\n\n\nLets say you want to sort it by \nAxis\n. How do you do that?\n\n\n\n(Note: I have seen \nhttp://golang.org/pkg/sort/\n and it seems to work, but I have to add about 20 lines just for simple sorting by a very simple key. I have a python background where it is as simple as \nsorted(planets, key=lambda n: n.Axis)\n - is there something similar simple in Go?)\n\n    ", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/huayunhualuo/article/details/51161933", "Konwledge_Point": "负权边的最短路径", "Question": "向量和欧几里得的距离的计算，求最短的距离，给定的点，采用C语言算法怎么实现\nProblem Description\n\nThe government in a foreign country is looking into the possibility of establishing a subway system in its capital. Because of practical reasons, they would like each subway line to start at the central station and then go in a straight line in some angle as far as necessary. You have been hired to investigate whether such an approach is feasible. Given the coordinates of important places in the city as well as the maximum distance these places can be from a subway station (possibly the central station, which is already built), your job is to calculate the minimum number of subway lines needed. You may assume that any number of subway stations can be\n\nbuilt along a subway line.\n\n\n\nFigure 1: The figure above corresponds to the first data set in the example input.\n\n\n\nInput\n\nThe first line in the input file contains an integer N, the number of data sets to follow. Each set starts with two integers, n and d (1 <= n <= 500, 0 <= d < 150). n is the number of important places in the city that must have a subway station nearby, and d is the maximum distance allowed\n\nbetween an important place and a subway station. Then comes n lines, each line containing two integers x and y (-100 <= x, y <= 100), the coordinates of an important place in the capital. The central station will always have coordinates 0, 0. All pairs of coordinates within a data set\n\nwill be distinct (and none will be 0, 0).\n\n\n\nOutput\n\nFor each data set, output a single integer on a line by itself: the minimum number of subway lines needed to make sure all important places in the city is at a distance of at most d from a subway station.\n\n\n\nSample Input\n\n2\n\n7 1\n\n-1 -4\n\n-3 1\n\n-3 -1\n\n2 3\n\n2 4\n\n2 -2\n\n6 -2\n\n4 0\n\n0 4\n\n-12 18\n\n0 27\n\n-34 51\n\n\n\nSample Output\n\n4\n\n2", "Tag": "算法分析"}
{"Answer": "\n\n#include <stdio.h>\n\nint main(){\n    char ch[4][112];\n    int i;\n    for(i=0;i<4;i++){\n        scanf(\"%s\",ch[i]);\n    }\n    for(i=0;i<4;i++){\n        printf(\"%.2s\",ch[i]);\n    }\n    return 0;\n}\n\n", "Konwledge_Point": "负权边的最短路径", "Question": "输入-首中文藏头诗，一共四句，每句-行，但句子不一定是等长的，最短一个汉字，最长九个汉字(注意:一个汉字占两个字节)。取出每句的第一个汉字并连接在一起形成一个字符串并输出。\n程序功能利用字符数组设计并实现一个解密藏头诗的程序。输入-首中文藏头诗，一共四句，每句-行，但句子不一定是等长的，最短一个汉字，最长九个汉字(注意:一个汉字占两个字节)。取出每句的第一个汉字并连接在一起形成一个字符串并输出。", "Tag": "算法分析"}
{"Answer": "各位人家都给分了，稍微耐心点嘛，代码改了一下你看看，基本按照你思路弄的：\r\n\r\n```\r\n#include \r\n#include \r\n#include \r\n#define N 7\r\n#define M 15\r\n\r\nint main()\r\n{\r\n\tint i, j, changdu[N];\r\n\tchar m[N][M], min[M], max[M];\r\n\tint maxlen, minlen;\r\n\tprintf(\"input 6 strings:\\n\");\r\n\tfor (i = 0; i < 6; i++)\r\n\t{\r\n\t\tscanf(\"%s\", &m[i]);\r\n\t}\r\n\tstrcpy(min, m[0]);\r\n\tstrcpy(max, m[0]);\r\n\r\n\tchangdu[0] = strlen(m[0]);\r\n\tmaxlen = changdu[0];\r\n\tminlen = changdu[0];\r\n\tfor (j = 1; j < 6; j++)\r\n\t{\r\n\t\tchangdu[j] = strlen(m[j]);\r\n\t\tif (maxlen < changdu[j])\r\n\t\t{\r\n\t\t\tstrcpy(max, m[j]);\r\n\t\t\tmaxlen = changdu[j];\r\n\t\t}\r\n\t\telse if (minlen > changdu[j])\r\n\t\t{\r\n\t\t\tstrcpy(min, m[j]);\r\n\t\t\tminlen = changdu[j];\r\n\t\t}\r\n\t}\r\n\r\n\tprintf(\"max string is %s,min is %s\", max, min);\r\n\r\n}\r\n```\r\n执行结果，最长的可不是java是第一行的：\r\n![图片说明](https://img-ask.csdn.net/upload/201901/15/1547523899_237370.png)", "Konwledge_Point": "负权边的最短路径", "Question": "c语言，输入6个字符串，求最大串和最小串\n输入6个字符串，输出最大串及最小串，如\n\n输入：\n\nhello,world\n\nc\n\njava\n\nc++\n\n#c\n\ncp\n\n运行结果：\n\n最大串：java\n\n最小串：c\n\n\n\n以下是我的代码，请问哪里有错，怎么改\n\n\n\n#include \n#include \n#include \n#define N 7\n#define M 15\n\nint main()\n{\n    int i,j,changdu[N];\n    char *m[M],min[M],max[M];\n    printf(\"input 6 strings:\\n\");\n    for(i = 0; i < 6; i++)\n    {\n        scanf(\"%s\",&m[i]);\n    }\n    strcpy(min[M],m[0]);\n    strcpy(max[M],m[0]);\n    for(i = 0; i < 5;i++)\n    {\n        changdu[i] = strlen(m[i]);\n        for(j = i+1; j < 6 ; j++)\n        {\n            changdu[j] = strlen(m[j]);\n            if(changdu[i] < changdu[j])\n            {\n                strcpy(max[M] , m[j]);\n                strcpy(min[M] , m[i]);\n\n            }\n        }\n    }\n    printf(\"max string is %s,min is %s\",max[M],min[M]);\n\n}\n\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "%u%d%d %o %x%c%f%2.3f\\t%2.3f", "Konwledge_Point": "负权边的最短路径", "Question": "以无符号十进制整数形式同时输出20和-5；\n（1）以无符号十进制整数形式同时输出20和-5；\n（2）以带符号十进制整数形式同时输出20和-5；\n（3）分别以十进制、八进制、十六进制的形式同时输出010；\n（4）以字符型的形式输出‘A’；\n（5）分别以浮点型、指数型和最短宽度的形式同时输出3.14；\n（6）以数据宽度为6、小数位数为4位的形式输出3.14；\n（7）以数据宽度为6、小数位数为4位、数据整体靠左的形式输出3.14；", "Tag": "算法分析"}
{"Answer": "这个问题已经跟VB.NET没有多少关系了，它可能比你想象的要复杂得多。首先，你得获得路网数据，即所有的道路矢量数据。这个百度地图似乎不提供，不过可以购买商用的地图数据。其次，你要会最优路径搜索算法，这个问题就更加有点大了，涉及路径规划算法。这个你可以通过《算法导论》这本书来入门，再通过阅读路径优化相关的最新学术文献来学习。\r\n\r\n然而，更加复杂的是，你得知道哪些道路是可以行车的，哪些道路红绿灯多，哪些道路是单行线，哪些道路单双号限行，哪些道路容易堵车，哪些道路会收费...........所以这其实是一个比最短路径规划更复杂的优化问题。", "Konwledge_Point": "负权边的最短路径", "Question": "vb.net 求百度地图两点间的行车距离\n采用vb.net 如何获取百度地图上两点间的最短行车距离？", "Tag": "算法分析"}
{"Answer": "\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<string>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<algorithm>\n#include<utility>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#define PI acos(-1.0)\n#define INF 0x3f3f3f3f\n#define LL long long\n#define Pair pair<int,int>\nLL quickPow(LL a,LL b){ LL res=1; while(b){if(b&1)res*=a; a*=a; b>>=1;} return res; }\nLL multMod(LL a,LL b,LL mod){ a%=mod; b%=mod; LL res=0; while(b){if(b&1)res=(res+a)%mod; a=(a<<=1)%mod; b>>=1; } return res%mod;}\nLL quickMultPowMod(LL a, LL b,LL mod){ LL res=1,k=a; while(b){if((b&1))res=multMod(res,k,mod)%mod; k=multMod(k,k,mod)%mod; b>>=1;} return res%mod;}\nLL quickPowMod(LL a,LL b,LL mod){ LL res=1; while(b){if(b&1)res=(a*res)%mod; a=(a*a)%mod; b>>=1; } return res; }\nLL getInv(LL a,LL mod){ return quickPowMod(a,mod-2,mod); }\nLL GCD(LL x,LL y){ return !y?x:GCD(y,x%y); }\nLL LCM(LL x,LL y){ return x/GCD(x,y)*y; }\nconst double EPS = 1E-6;\nconst int MOD = 1000000000+7;\nconst int N = 1000+5;\nconst int dx[] = {0,0,-1,1,1,-1,1,1};\nconst int dy[] = {1,-1,0,0,-1,1,-1,1};\nusing namespace std;\n \nstruct Node {\n    int val;\n    int step;\n    Node() {}\n    Node(int val, int step) : val(val), step(step) {}\n};\nint vis[65536 + 10];\nvoid BFS(Node st, Node ed) {\n    memset(vis, 0, sizeof(vis));\n    queue<Node> Q;\n    Q.push(st);\n    while (!Q.empty()) {\n        Node now = Q.front();\n        Q.pop();\n        if (now.val == ed.val) {\n            cout << now.step << endl;\n            return;\n        }\n \n        int val = now.val;\n        int step = now.step;\n        for (int i = 15; i >= 0; i--) { //从高到低枚举每一位\n            int x = (15 - i) / 4, y = (15 - i) % 4; //横纵坐标\n            int nowPos = 1 << i; //当前位置代表权值\n            int rightPos = 1 << (i - 1); //当前位置右方位置代表权值\n            int downPos = 1 << (i - 4);  //当前位置下方位置代表权值\n            if (y < 3 && ((val & nowPos) != (val & rightPos))) { //向右交换\n                int nextVal = val ^ nowPos ^ rightPos; //交换后的状态\n                if (!vis[nextVal]) {\n                    vis[nextVal] = true;\n                    Q.push(Node(nextVal, step + 1));\n                }\n            }\n            if (x < 3 && ((val & nowPos) != (val & downPos))) { //向下交换\n                int nextVal = val ^ nowPos ^ downPos; //交换后的状态\n                if (!vis[nextVal]) {\n                    vis[nextVal] = true;\n                    Q.push(Node(nextVal, step + 1));\n                }\n            }\n        }\n    }\n}\nint main() {\n    char ch;\n    int st = 0, ed = 0;\n    for (int i = 15; i >= 0; i--) {\n        cin >> ch;\n        if (ch == '1')\n            st += 1 << i;\n    }\n    for (int i = 15; i >= 0; i--) {\n        cin >> ch;\n        if (ch == '1')\n            ed += 1 << i;\n    }\n    if (st == ed)\n        printf(\"0\\n\");\n    else\n        BFS(Node(st, 0), Node(ed, 0));\n    return 0;\n}\n", "Konwledge_Point": "负权边的最短路径", "Question": "信息学一本通（1451:棋盘游戏）\n输出结果不对 大家看看哪错了\n\n\n今日程序内容：\n棋盘游戏。在一个4 x 4的棋盘上有 8个黑棋和 8个白棋，当且仅当两个格子有公共边，这两个格子上的棋是相邻的。移动棋子的规则是交换相邻两个棋子。给出一个初始棋盘和一个最终棋盘，请找出一个最短的移动序列使初始棋盘变为最终棋盘。\n\n\n输入：\n前四行，每行4个数字（ 1或者0 ），描述了初始棋盘；接着是一个空行；\n第六到第九行，每行 4个数字（ 1或者0），描述了最终棋盘。\n\n\n\n输出：\n输出的第一行是一个整数\nn\n，表示最少的移动步数。\n\n\n\n\n\n#include \nint A,B;\nint vis[100000];\nstruct P\n{\n    int num,d;\n};\nstruct P p[100];\nvoid bfs()\n{\n    p[0].num=A,p[0].d=0;\n    while(p[0].num!=0)\n    {\n        int tmp=p[0].num;\n        int k=0;\n        if(tmp==B)\n        {\n            printf(\"%d\\n\",p[0].d);\n            return;\n        }\n        for(int i=15;i>=0;i--)\n        {\n            int x=(15-i)/4,y=(15-i)%4,w=1<=0;i--)\n    {\n        scanf(\"%c\",&ch);\n\n\n    \nif\n(ch==\n'1'\n)\n    {\n        A+=\n1\n<=\n0\n;i--)\n{\n    scanf(\n\"%c\"\n,&ch);\n    \nif\n(ch==\n'1'\n)\n    {\n        B+=\n1\n<<i;\n    }\n}\n\nprintf\n(\n\"%d %d\"\n,A,B);\n\nif\n(A==B)\n{\n    \nprintf\n(\n\"0\\n\"\n);\n}\n\nelse\n\n{\n    bfs();\n}\n\nreturn\n \n0\n;\n\n\n\n}", "Tag": "算法分析"}
{"Answer": "你可以参考图的最短路径算法\n图论：图的四种最短路径算法_钟一淼的博客-CSDN博客_图论 最短路径算法\n最短路径的四种算法\n\n\n\nhttps://blog.csdn.net/m0_64045085/article/details/123504469\n\n", "Konwledge_Point": "负权边的最短路径", "Question": "选取距离之和最小的点\n平面上有一些点称为固定点，还有另外一些点为可选点，对于每一个固定点，我们可以从可选点中找出距离其最短的点，令z=所有最短距离之和，我们的要求是从可选点中选取部分点，使得z最小", "Tag": "算法分析"}
{"Answer": "电子盘不存在物理寻磁道的操作，所以选择先来先服务FCFS", "Konwledge_Point": "负权边的最短路径", "Question": "若所有硬盘全部设计成电子硬盘，哪个磁盘调度算法最合适？\n三种调度算法：先来先服务FCFS，最短寻道时间优先算法SSTF，电梯法SCAN", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/odaynot/article/details/8117682", "Konwledge_Point": "负权边的最短路径", "Question": "快，急急急急急急急急急急急急急\nC语言计算汉诺塔的最短移动步数，用C语言实现，快，急急急急急急急急急急急急急", "Tag": "算法分析"}
{"Answer": "islower返回的就是布尔值啊你如果要的是小写，用lower()就行了", "Konwledge_Point": "负权边的最短路径", "Question": "for i in licensePlate: TypeError: 'bool' object is not iterable出现这个怎么办\n\n\n题目求的是最短补全词\n遇到这种情况要怎么办，我根本没有bool类型为什么会报错，求帮助", "Tag": "算法分析"}
{"Answer": "先学基础，而后边实践边学习", "Konwledge_Point": "负权边的最短路径", "Question": "如何迅速搭建项目框架\n如何迅速搭建项目框架 ，如何在最短的时间内学会一套语言，如何入手力扣，走出新手村", "Tag": "算法分析"}
{"Answer": "其实，这个和旅行商问题是一样的。\r\n旅行商问题是：A,B,C,D,E……\r\n从A出发，经过B,C,D,E……最终还要回到A。\r\n\r\n你可以参考我的这篇博客\r\nhttp://keating.iteye.com/admin/blogs/403454\r\n\r\n如果看不懂，我再给你找找说明文档～～～", "Konwledge_Point": "负权边的最短路径", "Question": "一个算法问题？？？\n题目是这样的，有任意多个公交站点，比如：A,B,C,D,E……，他们各个站点的距离确定（自定义），然后求出任意一个站点到另外一个站点的最短距离，并且得到他经过的站点。比如，求A到D的最短路程，并且经过哪些站点。程序的实现是这样的：输入AB5（就表示A到B，距离为5），然后输入BC3，……。这样把所有数据输入给程序，最后任意输入两点,比如BD，然后程序打印出最短距离和经过的站点。\n\n\n\n这个算法用java怎么实现呢？尽量用面向对象的思想", "Tag": "算法分析"}
{"Answer": "txt文件中只存具体的数据，然后用sql语句LOAD DATA... INFILE", "Konwledge_Point": "负权边的最短路径", "Question": "mysql从一个txt文件中 插入1200w条数据，如何编写sql语句，使得效率最高\nmysql从一个txt文件中 插入1200w条数据，如何编写sql语句，使得效率最高，所用时间最短。", "Tag": "算法分析"}
{"Answer": "Python 技能树这里有一个可以：\n技能树答题\n技能树答题\n\n\n\nhttps://bbs.csdn.net/skill/practice/python-3-14/79?typeId=17371\n\nPython 技能树->基础语法->数据类型->Python 元组，里面就有一个“计算黑客帝国的滤镜颜色” 的代码。\n", "Konwledge_Point": "负权边的最短路径", "Question": "如何用 Python 计算黑客帝国的滤镜颜色？\n最好使用元组来计算，如果有其他的滤镜公式提供就更好了。使用 Python 元组的话，如何把代码压缩到最短？\n\n", "Tag": "算法分析"}
{"Answer": "BankQueue CompareS(BankQueue Q[4])//找出最短队列\r\n{\r\n\tint i;\r\n\ti=Q[0].rear-Q[0].front <= Q[1].rear-Q[1].front ?  0 : 1 ;\r\n\ti=Q[i].rear-Q[i].front <= Q[2].rear-Q[2].front ?  i : 2 ;\r\n\treturn Q[i].rear-Q[i].front<= Q[3].rear-Q[3].front ?  Q[i] : Q[3] ;\r\n}", "Konwledge_Point": "负权边的最短路径", "Question": "C++ 队列操作，新人小白，在线等，挺急的\n已知4只队列，如何选中其中最短的队列，进行后续操作？\n\n求大神，讲下思路和代码，要求是原队列进行后续操作", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/w3071206219/article/details/52573783\r\n这是最长的，看完之后只要智力没有问题，应该能举一反三写出最短的", "Konwledge_Point": "负权边的最短路径", "Question": "C语言编程问题，求大神帮助\n输入一行字符串，输出最长的单词和最短的单词。\n\n请尽量有简单语句编写(我是c语言初学者)，感谢！感谢！感谢！", "Tag": "算法分析"}
{"Answer": "if代码块要加大括号啊if (len > max2){max2 = len; max1.erase(); max1.replace(0, len, s);}、 if (len < min2){min2 = len; min1.erase(); min1.replace(0, len, s);}", "Konwledge_Point": "负权边的最短路径", "Question": "C++代码中的判断语句出现错误\n【题目描述】\n输入1行句子(不多于200个单词，每个单词长度不超过100)，只包含字母、空格和逗号。单词由至少一个连续的字母构成，空格和逗号都是单词间的间隔。\n\n\n 试输出第1个最长的单词和第1个最短单词。\n\n\n【输入】\n一行句子。\n\n\n【输出】\n第1行，第一个最长的单词。\n\n\n第2行，第一个最短的单词。\n\n\n【输入样例】\nI am studying Programming language C in Peking University\n【输出样例】\nProgramming\nI\n【提示】\n提示：\n\n\n如果所有单词长度相同，那么第一个单词既是最长单词也是最短单词。\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n \n\n\n\nusing\n \nnamespace\n std;\nstring s;\n\nint\n \nmain\n()\n \n{\n    string max1, min1;\n    \nint\n max2=\n0\n, min2=\n200\n;\n    \nint\n len; \n    \nwhile\n (cin>>s&&s.\nsize\n()!=\n0\n) {\n        len = s.\nsize\n();\n        \nif\n (len > max2) max2 = len; max1.\nerase\n(); max1.\nreplace\n(\n0\n, len, s);\n        \nif\n (len < min2) min2 = len; min1.\nerase\n(); min1.\nreplace\n(\n0\n, len, s);\n    }\n    cout << max1 << \n\" \"\n<<min1 << endl;\n    \nreturn\n \n0\n;\n}\n\n\n\n\n如图，他好像没有进行判断便运行了。是不是我的代码有些问题？\n我想要求最长单词和最短单词", "Tag": "算法分析"}
{"Answer": "\n$arr1=array(strlen($len1)=>$len1,strlen($len2)=>$len2,strlen($len3)=>$len3); //用循环像这样添加，添加之前判断是否为空\narsort($arr1); //按照键的大小排序\n// print_r($arr1);//按照键的大小输出关联数组\n$arr2=array_values($arr1);//关联数组转普通数组,\necho $arr2[0].\"<br>\"; //字符最长的下标是0,第二是1，最小的是数组长度-1\necho $arr2[1].\"<br>\" ;\necho $arr2[count($arr2)-1].\"<br>\" ;\n", "Konwledge_Point": "负权边的最短路径", "Question": "关于PHP比较字符串长度的简洁方法请教\n$\nle\nn1\n=\n'大江东去，浪淘尽，'\n;\n$\nle\nn2\n=\n'大江东去，浪淘尽，千古风流人物。故垒西边，'\n;\n$\nle\nn3\n=\n'大江东去，浪淘尽，千古风流人物。故垒西边，人道是，三国周郎赤壁。人生如梦，一尊还酹江月。'\n;\n$\nle\nn7\n=\n''\n;\n$\nle\nn4\n=\n'大江东去，浪淘尽，千古风流人物。'\n;\n$\nle\nn5\n=\n'大江东去，浪淘尽，千古风流人物。故垒西边，人道是，三国周郎赤壁。'\n;\n$\nle\nn6\n=\n'大江东去，浪淘尽，千古风流人物。故垒西边，人道是，'\n;\n$\nle\nn8\n=\n''\n;\n\n\n\n如何一次性比较出以上8个字符串的长度（或者循环比较出），并分别输出以下3组字符串呢？\n1、最短的字符串（不含空字符串）\n2、第二短的字符串\n3、最长的字符串\n\n\n以下是我写的找出最短字符串的代码（按三个字符串），但是感觉好复杂啊～结果好像也有问题～\n\n\n$str\n=\n$len1\n<\n$len2\n?(\n$len1\n<\n$len3\n?\n$len1\n:\n$len3\n):(\n$len2\n<\n$len3\n?\n$len2\n:\n$len3\n);\n\necho\n \n\"最短字符串内容如下：\"\n \n$str\n;\n\n\n\n目前的难点是如果有几组空字符串混杂其中时，如何找出最短的那个非空字符串呢？那么第二短的也就好找了，相对的，最长的好像已经解决了。", "Tag": "算法分析"}
{"Answer": "为了解决这个问题，我们可以使用贪心的思想，每次选择最少的时间办理业务的窗口。\n首先，我们需要定义一个数组time[3]来保存每个窗口办理业务的时间。然后，我们依次遍历每一位客户，每当有一个客户需要办理业务时，我们就在time数组中选择最少的时间办理业务的窗口，并把该客户办理业务的时间加入time数组中对应的窗口。\n代码如下：\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin >> n; // 输入客户数量\n\n    int time[3] = {0}; // 定义并初始化time数组\n\n    for (int i = 1; i <= n; i++)\n    {\n        int t;\n        cin >> t; // 输入客户i办理业务的时间\n\n        // 选择最少的时间办理业务的窗口\n        int minTime = min(time[0], min(time[1], time[2]));\n        if (time[0] == minTime)\n        {\n            time[0] += t; // 把客户i办理业务的时间加入窗口1的时间\n        }\n        else if (time[1] == minTime)\n        {\n            time[1] += t; // 把客户i办理业务的时间加入窗口2的时间\n        }\n        else\n        {\n            time[2] += t; // 把客户i办理业务的时间加入窗口3的时间\n        }\n    }\n\n    // 输出最短时间\n    cout << min(time[0], min(time[1], time[2])) << endl;\n\n    return 0;\n}\n\n\n在这个代码中，我们使用了C++的min函数来选择time数组中最少的时间办理业务的窗口，然后将该客户办理业务的时间加入time数组中对应的窗口。最后，我们使用min函数再次计算time数组中的最小值，并输出。\n这个算法的时间复杂度是O(n)，可以在很短的时间内解决问题。\n我们可以通过下面的代码来测试这个算法的正确性：\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin >> n; // 输入客户数量\n\n    int time[3] = {0}; // 定义并初始化time数组\n\n    for (int i = 1; i <= n; i++)\n    {\n        int t;\n        cin >> t; // 输入客户i办理业务的时间\n\n        // 选择最少的时间办理业务的窗口\n        int minTime = min(time[0], min(time[1], time[2]));\n        if (time[0] == minTime)\n        {\n            time[0] += t; // 把客户i办理业务的时间加入窗口1的时间\n        }\n        else if (time[1] == minTime)\n        {\n            time[1] += t; // 把客户i办理业务的时间加入窗口2的时间\n        }\n        else\n        {\n            time[2] += t; // 把客户i办理业务的时间加入窗口3的时间\n        }\n    }\n\n    // 输出最短时间\n    cout << min(time[0], min(time[1], time[2])) << endl;\n\n    return 0;\n}\n\n\n这样子我们可以输入5位客户的办理业务的时间，然后根据我们前面提到的贪心算法的思路，选择最少的时间办理业务的窗口，并将该客户办理业务的时间加入time数组中对应的窗口。最后，我们输出time数组中的最小值，就可以得到最短的办理业务的时间。\n例如，如果我们输入的办理业务的时间分别为3、5、2、4、1，那么最终time数组的值分别为10、9、6，最短的办理业务的时间就是6。\n这个算法的正确性是基于贪心算法的思路，每次都选择最少的时间办理业务的窗口，最终可以得到最优的解。\n希望这些内容对你有帮助！可以话请给博主点个采纳！", "Konwledge_Point": "负权边的最短路径", "Question": "业务办理时间问题C++\n\n\n【题目描述】某服务大厅同时开放3个窗口为客户办理业务，窗口编号分别为1、2、3。现有N（2≤N≤50）位客户需要办理业务，客户编号为1~N，作为办理业务的先后顺序。起初三个窗口为空闲状态，空闲的窗口会按照客户编号顺序呼叫下一位客户。如果多个窗口同时为空闲状态，按照窗口编号顺序呼叫（1优先于2，2优先于3）。现给出每位客户办理业务的时间（单位：分钟），请计算出N位客户全部办理完业务后，哪一个窗口合计办理业务的时间最短，并输出最短时间", "Tag": "算法分析"}
{"Answer": "傻子做法：\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N=1e6+10;\nint treee[N];\nint sum=0,flag=0;\n\nint find_public_father(int u,int v){\n    int t1=1,t2=1,arr1[10000],arr2[10000];\n    arr1[0]=u; arr2[0]=v;\n    while(u>1){\n        u/=2;\n        arr1[t1++]=u;\n    }\n    while(v>1){\n        v/=2;\n        arr2[t2++]=v;\n    }\n    for(int i=0;i<t1;i++){\n        for(int j=0;j<t2;j++){\n            if(arr1[i]==arr2[j]){\n                return arr1[i];\n            }\n        }\n    }\n}\n\nvoid add(int u,int v,int w){\n    if(u==v){\n        flag=1;\n        return;\n    }else if(u>v){\n        return;\n    }\n    add(2*u,v,w);\n    if(flag){\n        treee[2*u]+=w;\n        return;\n    }\n    add(2*u+1,v,w);\n    if(flag){\n        treee[2*u+1]+=w;\n        return;\n    }\n}\n\nvoid travel(int u,int v){\n    if(u==v){\n        flag=1;\n        return;\n    }else if(u>v){\n        return;\n    }\n    travel(2*u,v);\n    if(flag){\n        sum+=treee[2*u];\n        return;\n    }\n    travel(2*u+1,v);\n    if(flag){\n        sum+=treee[2*u+1];\n        return;\n    }\n}\n\nint main(){\n    int q; cin >> q;\n    while(q--){\n        int x,u,v,w;; cin >> x;\n        if(x==1){\n            cin >> u >> v >> w;\n            int father=find_public_father(u,v); \n            // cout << \"their father is:\" << father << endl;\n            flag=0; add(father,u,w);\n            flag=0; add(father,v,w);\n        }else if(x==2){\n            cin >> u >> v;\n            int father=find_public_father(u,v);\n            sum=0;\n            flag=0; travel(father,u);\n            flag=0; travel(father,v);\n            cout << sum << endl;\n        }\n        // for(int i=0;i<8;i++){\n        //     cout << treee[i] << \" \";\n        // }\n    }\n    // system(\"pause\");\n    return 0;\n}\n\n正解：https://www.cnblogs.com/wzl19981116/p/10087302.html\nvoid Add(ll x,ll y,ll w)\n{\n    while(1)\n    {\n        if(x>y)\n        {\n            a[x]+=w;\n            x/=2;\n        }else if(x<y)\n        {\n            a[y]+=w;\n            y/=2;\n        }else\n            break;\n    }\n}\nll query(ll x,ll y)\n{\n    ll ans=0;\n    while(1)\n    {\n        if(x>y)\n        {\n            ans+=a[x];\n            x/=2;\n        }else if(x<y)\n        {\n            ans+=a[y];\n            y/=2;\n        }else\n        {\n            return ans;\n        }\n    }\n}\n", "Konwledge_Point": "负权边的最短路径", "Question": "数据结构程序设计实践-收费\n问题遇到的现象和发生背景\n\n\n算法与数据结构\n\n\n★实验任务\n\n\n有一张无限大的图，图中的节点编号从1开始。图中节点由无向边连接，编号为i的节点分别与2i号节点和2i+1号节点连接，显然任意两个点之间的最短路是确定的且唯一的。最开始每条边上的花费都是0。 接下来有两种操作\n\n\n给从u到v的最短路上的每条边都加上w的花费\n\n\n计算走最短路从u到v的总花费（即路上所有边的花费和）\n\n\n★数据输入\n\n\n第一行输入一个整数q，表示操作的数量，接下来q行，每行第一个数字代表操作的类型，如果是1号操作，则紧接着输入u，v，w三个整数；如果是2号操作，接着输入u，v两个整数。\n\n\n★数据输出\n\n\n对于每一个2号操作，输出一行一个数字，代表路上的总花费\n\n\n输入示例\n7\n1 3 4 30\n1 4 1 2\n1 3 6 8\n2 4 3\n1 6 1 40\n2 3 7\n2 2 4\n输出示例\n94\n0\n32\n★数据范围\n\n\n50% : q <= 10, 1≤u,v,w≤1000\n\n\n100% : q <= 1000, 1≤u,v≤1000000,w <= 1e9\n\n\n我的解答思路和尝试过的方法\n\n\n毫无思路，没有学习图的话，如何通过树来完成呢？", "Tag": "算法分析"}
{"Answer": "分别找出m和n所在的行号和列号，求出行列的差值相加\n#include <stdio.h>\n#include <math.h>\nint main()\n{\n    int w,m,n;\n    int row1,col1,row2,col2;\n    scanf(\"%d%d%d\",&w,&m,&n);\n    row1 = m/w;\n    row2 = n/w;\n    if(row1%2==0)\n        col1 = m%w-1;\n    else\n        col1 = w-m%w;\n    if(row2%2==0)\n        col2 = n%w-1;\n    else\n        col2 = w-n%w;\n    printf(\"%d\\n\",abs(col1-col2) + abs(row1-row2));\n    return 0;\n}\n\n", "Konwledge_Point": "负权边的最短路径", "Question": "简单的程序题c语言请教一下\nx星球居民小区的楼房都是一样的，并且按矩阵样式排列，其楼房的编号为1，2，3等等\n当排满一行时，从下一行相邻的楼往反方向排号\n比如:当小区排号为6时，开始情形如下\n1  2  3  4  5  6\n12 11 10 9  8 7\n13  14  15等等\n我们的问题是已知两个楼号m和n，需要求出它们之间的最短移动距离（不能斜线方向移动）\n输入为3个整数w m n，空格分开，都在1到10000范围内，w为排号宽度，m，n为待计算的楼号\n要求输入一个整数，表示m，n两楼间的最短移动距离\n例如:\n用户输入\n6 8 2\n则，程序该输出\n4", "Tag": "算法分析"}
{"Answer": "tree[i]代表第i棵树的高度假设dp[i][j][0] 代表[i，j]区间最大值，dp[i][j][1]代表[i，j]区间最小值可知dp[i][j][0] = dp[i][j][1] = tree[i]  当i=j时dp[i][j][0]= Max(tree[j]，dp[i][j-1][0])  j>idp[i][j][1]= Min(tree[j]，dp[i][j-1][1])  j>i最后求解[x，y]区间，为dp[x][y][0] - dp[x][y][1] ", "Konwledge_Point": "负权边的最短路径", "Question": "范围内最高最矮树高度差问题\n问题：N棵树排成一排。考虑到每棵树的高度H，小明被要求回答M个问题。每个问题包含两个数字L和R，询问间隔[L，R]中最高树和最短树之间的高度差。帮助小明解决这个问题\n\n\n输入的第一行包含两个整数N和M，表示树的数量和问题的数量\n以下N行中的每一行都包含一个整数Hi，表示每棵树的高度。以下M行中的每一行都包含两个整数Li和Ri，表示每个问题的间隔。\n输出：从第1行到第m行，每行包含一个整数，表示从第Lth树到第Rth树的最高树和最短树之间的高度差。\n\n", "Tag": "算法分析"}
{"Answer": "没有中转，那就是判断当前航班的Dest是否作为其他航班的Source", "Konwledge_Point": "负权边的最短路径", "Question": "关于python结合sql的问题，如何解决？\n在Python中写SQL语句，这里需要筛选出所有可以直达目的地的航班（没有中转），我的理解筛选出出发地到目的地消耗时间最短的航班（不知道对不对），在sql变量里面要怎么表示？\n\n\n表名叫做Flights.\n\n\n\n", "Tag": "算法分析"}
{"Answer": "数据结构中的图所有路径以及最短路径的算法", "Konwledge_Point": "负权边的最短路径", "Question": "有趣的问题，进来看看\n  1、北京地铁图。已知两条线路交汇处的结点处，可以知道邻近线路的地铁运行时间、间隔时间...\n\n       设计一种数据结构，编程实现：\n\n       （1）从一站点到另一站点的所有线路。\n\n       （2）从一站点到另一站点的时间最短线路。\n", "Tag": "算法分析"}
{"Answer": "根据题意，空格和逗号都是分割符\r\nif(ch[i]==' ')\r\n->\r\nif(ch[i]==' ' || ch[i] == ',')\r\n\r\n\r\n\r\n```\r\n\r\n#include\r\n#include\r\nint main()\r\n{\r\n    char ch[22222];\r\n    int i,max=0,min=120,a,b,c,d,t=0;\r\n\ta=b=c=d=0;\r\n    gets(ch);\r\n    int len=strlen(ch);\r\n    for(i=0;i<=len;i++)\r\n    {\r\n\r\n        if(ch[i]==' ' || ch[i]==',' || ch[i]=='\\0')\r\n        {\r\n\r\n            int n=i-t;\r\n\t\t\tif (n > 0)\r\n\t\t\t{\r\n            if(n>max) {max=n;a=t;b=i-1;}\r\n            if(n<min) {min=n;c=t,d=i-1;}\r\n\t\t\t}\r\n            t=i+1;\r\n        }\r\n    }\r\n\r\n    for(i=a;i<=b;i++)\r\n        printf(\"%c\",ch[i]);\r\n        printf(\"\\n\");\r\n    for(i=c;i<=d;i++)\r\n        printf(\"%c\",ch[i]);\r\n    return 0;\r\n}\r\n```\r\nhttp://noi.openjudge.cn/ch0107/solution/22519898/\r\naccepted了", "Konwledge_Point": "负权边的最短路径", "Question": "字符串的一道题，我的答案超时了，希望大神在原有基础上帮我改正\n描述\n\n输入1行句子（不多于200个单词，每个单词长度不超过100），只包含字母、空格和逗号。单词由至少一个连续的字母构成，空格和逗号都是单词间的间隔。\n\n试输出第1个最长的单词和第1个最短单词。 \n\n输入\n\n一行句子。\n\n输出\n\n两行输出：\n\n第1行，第一个最长的单词。\n\n第2行，第一个最短的单词。\n\n样例输入\n\nI am studying Programming language C in Peking University\n\n样例输出\n\nProgramming\n\nI\n\n提示\n\n如果所有单词长度相同，那么第一个单词既是最长单词也是最短单词。\n\n\n\n#include\n#include\nint main()\n{\n    char ch[222222];\n    int i,max=0,min=120,a,b,c,d,t=0;\n    gets(ch);\n    int len=strlen(ch);\n    for(i=0;imax) {max=n;a=t;b=i-1;}\n            if(n<min) {min=n;c=t,d=i-1;}\n            t=i+1;\n        }\n    }\n\n    for(i=a;i<=b;i++)\n        printf(\"%c\",ch[i]);\n        printf(\"\\n\");\n    for(i=c;i<=d;i++)\n        printf(\"%c\",ch[i]);\n    return 0;\n}\n\n\n\n\n\n地址\nhttp://noi.openjudge.cn/ch0107/25/", "Tag": "算法分析"}
{"Answer": "虚拟机防火墙关闭么，1158的端口是否占用，vm里面是否可以此命令登入", "Konwledge_Point": "负权边的最短路径", "Question": "本机链接虚拟机数据库，出现ORA-12569: TNS:packet checksum failure错误提醒\n本机和虚拟机可以联通，访问虚拟机数据出错\n\n\n\n```C:\\Users\\liuye>ping 192.168.88.130\n\n\n\n正在 Ping 192.168.88.130 具有 32 字节的数据:\n\n来自 192.168.88.130 的回复: 字节=32 时间<1ms TTL=128\n\n来自 192.168.88.130 的回复: 字节=32 时间<1ms TTL=128\n\n来自 192.168.88.130 的回复: 字节=32 时间<1ms TTL=128\n\n来自 192.168.88.130 的回复: 字节=32 时间<1ms TTL=128\n\n\n\n192.168.88.130 的 Ping 统计信息:\n\n    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，\n\n往返行程的估计时间(以毫秒为单位):\n\n    最短 = 0ms，最长 = 0ms，平均 = 0ms\n\n\n\nC:\\Users\\liuye>sqlplus scott/tiger@192.168.88.130:1158/orcl\n\n\n\nSQL*Plus: Release 12.1.0.1.0 Production on Tue Jun 11 18:54:47 2019\n\n\n\nCopyright (c) 1982, 2013, Oracle.  All rights reserved.\n\n\n\nERROR:\n\nORA-12569: TNS:packet checksum failure\n\n\n\nEnter user-name:\n\n\n", "Tag": "算法分析"}
{"Answer": "//存在数组 int[] input = {0,1,2,3,4,...,49}\r\n\r\n//随即一个 属于[0,49] 的整数  i\r\n\r\n//因为你要5个均衡随机数，所以设置平均步长  step = input.length / 5 = 10\r\n\r\n//循环五次,结果为 result[]\r\n\r\nfor(int j = 0, j < 5, j++){\r\n     result[j] = input [ i % 50 ];\r\n     i  =  i  +  step;\r\n}\r\n\r\n//其实我也不太明白你的问题，题意我是猜的", "Konwledge_Point": "负权边的最短路径", "Question": "找一个数组里面的随机数问题\n有这样一个问题 ，例如有一个【0,50】的数组，数组下标从0开始一直到49，数组的值和数组下标值一样，我怎么样在最短的时间里面找出我要的5个随机数， 例如 ：1,5,9,7,42 。重要的一点是要保持随即数要均衡。", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/u012774187/article/details/41734977", "Konwledge_Point": "负权边的最短路径", "Question": "HDU-3751 找最短路必经点，超时了\n代码：\n代码\n\n\n\n我的思路：先存这个图上从小偷家到各点的最短时间在d1数组，存警察到图上各点最短时间在d2数组， 然后遍历小偷以最短路回家可能经过的位置，这个位置是不是一定经过，然后求出最小时间", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/hero5201/article/details/51812963", "Konwledge_Point": "负权边的最短路径", "Question": "最短路                                算法问题\nProblem Description\n\n在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？\n\n\n\nInput\n\n输入包括多组数据。每组数据第一行是两个整数N、M（N<=100，M<=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1<=A,B<=N,1<=C<=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。\n\n输入保证至少存在1条商店到赛场的路线。\n\n\n\nOutput\n\n对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间\n\n\n\nSample Input\n\n2 1\n\n1 2 3\n\n3 3\n\n1 2 5\n\n2 3 5\n\n3 1 2\n\n0 0\n\n\n\nSample Output\n\n3\n\n2", "Tag": "算法分析"}
{"Answer": "http://www.cnblogs.com/pblr/p/4748902.html", "Konwledge_Point": "负权边的最短路径", "Question": "Dijkstra Or Floyd Or dfs \nProblem Description\n\n在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？\n\n\n\nInput\n\n输入包括多组数据。每组数据第一行是两个整数N、M（N<=100，M<=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1<=A,B<=N,1<=C<=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。 输入保证至少存在1条商店到赛场的路线。\n\n\n\nOutput\n\n对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间\n\n\n\nSample Input\n\n 2 1\n\n 1 2 3\n\n 3 3\n\n 1 2 5\n\n 2 3 5\n\n 3 1 2\n\n 0 0\n\n\n\nSample Output\n\n 3\n\n 2", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/u013885699/article/details/21111601", "Konwledge_Point": "负权边的最短路径", "Question": "最短路                  \nProblem Description\n\n\n\n在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？\n\n\n\nInput\n\n\n\n输入包括多组数据。每组数据第一行是两个整数N、M（N<=100，M<=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1<=A,B<=N,1<=C<=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。\n\n\n\n输入保证至少存在1条商店到赛场的路线\n\n\n\nOutput\n\n\n\n对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间\n\n\n\nSample Input\n\n\n\n2 1\n\n\n\n1 2 3\n\n\n\n3 3\n\n\n\n1 2 5\n\n\n\n2 3 5\n\n\n\n3 1 2\n\n\n\n0 0\n\n\n\nSample Output\n\n\n\n3\n\n\n\n2", "Tag": "算法分析"}
{"Answer": "你题目的解答代码如下：\n#include<stdio.h>\n#include<string.h>\nint main(){\n    int n;\n    printf(\"请输入句子数: \");\n    scanf(\"%d\",&n);\n    getchar();\n    char str[n][100];\n    int min,max;\n    for(int i=0;i<n;i++){\n        gets(str[i]);\n    }\n    min=0;\n    max=min;\n    printf(\"你输入了下面这几句话\");\n    for(int i=0;i<n;i++){\n        printf(\"%s\\n\",str[i]);\n        int temp=strlen(str[i]);\n        min = temp < strlen(str[min]) ? i : min;\n        max = temp > strlen(str[max]) ? i : max;\n    }\n     printf(\"其中最长的是：%s\\n\", str[max]);\n     printf(\"其中最短的是：%s\\n\", str[min]);\n     return 0;\n}\n\n\n如有帮助，请点击我的回答下方的【采纳该答案】按钮帮忙采纳下，谢谢!\n", "Konwledge_Point": "负权边的最短路径", "Question": "输入有问题 不知道该怎么改\n写一个程序，让用户输入 n 句话，并计算出最长和最短的两句。\n使用 1 个二维数组存储用户输入的 n句话。\n\n\n\n```c\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\nint\n \nmain\n()\n{\n    \nint\n n;\n    \nprintf\n(\n\"请输入句子数: \"\n)； \n    \nscanf\n(\n\"%d\"\n,&n);\n    \nchar\n str[n][\n100\n];\n    \nint\n min,max;\n    \nfor\n(\nint\n i=\n0\n;i \nstrlen\n(str[max]) ? i : max;\n    }\n     \nprintf\n(\n\"其中最长的是：%s\\n\"\n, str[max]);\n     \nprintf\n(\n\"其中最短的是：%s\\n\"\n, str[min]);\n     \nreturn\n \n0\n;\n    \n}\n\n\n\n\n```", "Tag": "算法分析"}
{"Answer": "我提供一个思路：一个字符串和它的逆序字符串肯定是回文，所以，将字符串的逆序依次附加到原始字符串上，判断是否为回文即可。\ndef build_palindrome(s):\n    r = s[::-1]\n    length = len(r)\n    for i in range(1,length+1):\n        s0 = s + r[-i:]\n        if s0 == s0[::-1]:\n            print(s0)\n            break\n", "Konwledge_Point": "负权边的最短路径", "Question": "问python的一道题\n请问这题应该如何思考 ?\n一点思路都没有:(\n\n\n\n\n\"\"\"\n给定一个字符串str，\n通过在初始字符串的末尾添加字符使其成为回文，\n找到可能最短的字符串。\n对于str=“abcdc”，输出应为“abcdcba”。\n\"\"\"\n\n\ndef\n \nbuild_palindrome\n(\ns\n):\n    \npass\n\n\n\nprint\n(build_palindrome(\n\"abcdc\"\n))\n\n#\"abcdcba\"\n\n\nprint\n(build_palindrome(\n\"ababab\"\n))\n\n#\"abababa\"\n\n", "Tag": "算法分析"}
{"Answer": "\nimport re\ns='[0.0005, 0.0005, 0.0005]'\nregexp = re.compile(r\"\\d+\\.\\d+\")\nget = regexp.findall(s)\nprint(get)\n", "Konwledge_Point": "负权边的最短路径", "Question": "关于#正则表达式#的问题：希望有这样一个正则表达式，可以实现对于方括号内部的数字字符串的提取\n现有一个字符串\n[0.0005, 0.0005, 0.0005]\n，希望有这样一个正则表达式，可以实现对于方括号内部的数字字符串的提取。但是要注意的是，方括号中的数字字符串列表数量不是固定的，最短可以是\n[0.0005]\n, 最多无上限\n[0.0005, 0.0005, ... (n个), 0.0005]\n。\n如何简洁高效的提取里面的所有\n0.0005\n？", "Tag": "算法分析"}
{"Answer": "```\r\n from __future__ import print_function\r\n\r\nimport sys\r\n\r\nfrom pyspark.sql import SparkSession\r\n\r\ndef min(a,b):\r\n    return a if a < b else b\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    if len(sys.argv) != 2:\r\n        print(\"Usage:  odcount \", file=sys.stderr)\r\n        exit(-1)\r\n\r\n    spark = SparkSession\\\r\n        .builder\\\r\n        .appName(\"PythonODCount\")\\\r\n        .getOrCreate()\r\n\r\n    lines = spark.read.text(sys.argv[1]).rdd.map(lambda r: r[0])\r\n    lines = lines.filter( lambda line: len(line.strip()) > 0 )\r\n    mintimes = lines.flatMap(lambda x: [x[1:-1]]) \\\r\n                  .map( lambda x: (x.split(',')[0], int(x.split(',')[2])) ) \\\r\n                  .reduceByKey(min)\r\n    mintime_list = mintimes.collect()\r\n    mintime_map = {}\r\n    print(\"min time:\")\r\n    for (od, mintime) in mintime_list:\r\n        mintime_map[od] = mintime\r\n        print(\"%s: %i\" % (od.encode('utf-8'), mintime))\r\n        \r\n    largelines = lines.flatMap(lambda x: [x[1:-1]]) \\\r\n                  .filter( lambda x: int(x.split(',')[2]) > 2 * mintime_map.get(x.split(',')[0]) )\r\n    \r\n    print(\"large time line:\")\r\n    for line in largelines.collect():\r\n        print(\"%s\" % line.encode('utf-8'))\r\n\r\n    spark.stop()\r\n```", "Konwledge_Point": "负权边的最短路径", "Question": "还是昨天的Spark数据分析的问题，求代码，有帮助的可以再加C币\n现在我有一组数据，第一列是入站口到出站口（OD），第二列是刷卡的卡号，第三列是出行总时间。\n\n现在我想研究在相同的OD下，出行时长的分布，并从中筛选出出行时长异常的卡号，默认出行时长超过该OD最短出行时长2倍为异常。", "Tag": "算法分析"}
{"Answer": "1、调试发现这个代码还是有问题的，在取最短字符串的没有赋值a[0]而是赋值为空，导致第二个测试数据在寻找最小字符串时候为空。2、寻找最长字符串可以嵌套三层循环 news = a[0]for i in a[ 1: ]:  for j in news:    for k in i :      将news中的每一个与剩下a数组中的每一个对比，相同保留，不相同跳下一个", "Konwledge_Point": "负权边的最短路径", "Question": "这个是查找字符串数组中开头的最长公共字符串，怎么改成查找字符串数组中最长的公共字符串\n问题相关代码\n\n\ndef\n \nget_commonstr\n(\na\n):\n    \nif\n \nlen\n(a)==\n0\n:\n        \nreturn\n \n\"\"\n\n    cd,zcd=\nlen\n(a),\nlen\n(a[\n0\n])\n    news=\n\"\"\n#公共字符串\n\n    \nfor\n i \nin\n a[\n1\n:]:\n        \nif\n zcd>\nlen\n(i):\n            zcd=\nlen\n(i) \n#最短字符串长度\n\n            news=i \n#最短字符串\n\n    \nfor\n m \nin\n \nrange\n(zcd):\n        flag=\nFalse\n \n#退出外部循环标志\n\n        \nfor\n i \nin\n a:\n#2；取值0,1\n\n            \nif\n news[m]!=i[m]: \n#根据字符位置比较是否相等\n\n                news=news[:m]\n                flag=\nTrue\n\n                \nbreak\n\n        \nif\n flag:\n            \nbreak\n\n    \nreturn\n news\n\n\n\n# s1=[\"fliower\",\"fliowe\",\"flight\"]\n\ns1=[[\n'fliower'\n,\n  \n'wesaawsfliower'\n,\n  \n'dowflight'\n,\n  \n'abcdefg!fliower.exe'\n,\n  \n\"{'aw1qwf': 'fliower.exe', 'Bu': 'fliower'}\"\n]]\n\nif\n __name__==\n\"__main__\"\n:\n    \nprint\n[(\n\"结果:\"\n+get_commonstr(s1))]\n\n\n\n\n运行结果\n\n\nIndexError: string index out of range\n\n\n我想要达到的结果\n\n\n这个是查找字符串数组中开头的最长公共字符串，怎么改成查找字符串数组中最长的公共字符串\n比如上边的数组中，最长的公共字符串就是fliower", "Tag": "算法分析"}
{"Answer": "#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    string str;\n    cin>>str;\n    int n;\n    n=str.length();\n    while(n%2==0)\n    {\n        for(int i=0;i<n/2;i++)\n        {\n            if(str[i]!=str[n-1-i])\n            {\n                cout<<n<<endl;\n                return 0;\n            }\n        }\n        n=n/2;\n    }\n    cout<<n<<endl;\n    return 0;\n}\n\n", "Konwledge_Point": "负权边的最短路径", "Question": "输出答案没有问题，但显示时间超限怎么解决\nM队长几经辗转成为了学院组织的邪恶科学家。有一天他在研究FEV强制进化病毒。他发现FEV病毒有一种神奇的复制模式。FEV病毒进入生物体内，会将有害DNA片段注入宿主DNA，并在宿主的DNA上进行复制。\n\n\n为了简化说明该过程，我们把有害DNA片段抽象成1~26个小写拉丁字母的字符串S1。假设初始片段为ab，那么他会自我镜像复制并连接成为abba的字符串，复制若干次可能变成abbaabba。\n\n\n现在M队长会给你复制之后的字符串S2，请你帮助他推断出初始串的可能最短长度。", "Tag": "算法分析"}
{"Answer": "https://www.cnblogs.com/mis-xiao/p/3921401.html", "Konwledge_Point": "负权边的最短路径", "Question": "HDU Today                     \nProblem Description\n\n经过锦囊相助，海东集团终于度过了危机，从此，HDU的发展就一直顺风顺水，到了2050年，集团已经相当规模了，据说进入了钱江肉丝经济开发区500强。这时候，XHD夫妇也退居了二线，并在风景秀美的诸暨市浬浦镇陶姚村买了个房子，开始安度晚年了。\n\n这样住了一段时间，徐总对当地的交通还是不太了解。有时很郁闷，想去一个地方又不知道应该乘什么公交车，在什么地方转车，在什么地方下车（其实徐总自己有车，却一定要与民同乐，这就是徐总的性格）。\n\n徐总经常会问蹩脚的英文问路：“Can you help me?”。看着他那迷茫而又无助的眼神，热心的你能帮帮他吗？\n\n请帮助他用最短的时间到达目的地（假设每一路公交车都只在起点站和终点站停，而且随时都会开）。\n\n\n\nInput\n\n输入数据有多组，每组的第一行是公交车的总数N(0<=N<=10000)；\n\n第二行有徐总的所在地start，他的目的地end；\n\n接着有n行，每行有站名s，站名e，以及从s到e的时间整数t(0<t<100)(每个地名是一个长度不超过30的字符串)。\n\nnote：一组数据中地名数不会超过150个。\n\n如果N==-1，表示输入结束。\n\n\n\nOutput\n\n如果徐总能到达目的地，输出最短的时间；否则，输出“-1”。\n\n\n\nSample Input\n\n6\n\nxiasha westlake\n\nxiasha station 60\n\nxiasha ShoppingCenterofHangZhou 30\n\nstation westlake 20\n\nShoppingCenterofHangZhou supermarket 10\n\nxiasha supermarket 50\n\nsupermarket westlake 10\n\n-1\n\n\n\nSample Output\n\n50", "Tag": "算法分析"}
{"Answer": "在OpenCASCADE（OCE）中，可以使用BRepIntCurveSurface_Inter.hxx头文件中的BRepIntCurveSurface_Inter类求射线与TopoDS_Shape的交点。\n下面是一个简单的代码示例：\n这是一个简单的代码示例，你可以根据自己的需求修改。希望对您有所帮助！", "Konwledge_Point": "负权边的最短路径", "Question": "怎么求射线与TopoDS_Shape的交点？\n\n\n我现在想要从某点发射一条射线与TopoDS_Shape相交并获取交点。\n因为我没找到射线与TopoDS_Shape相交的方法，所以只能通过射线与TopoDS_Face逐个求交，取距离源点最短那个交点的办法来获取交点。\n但是由图中可知所求出来的交点不只1个，于是选择哪个就是个问题。\n我想通过判定点是否在曲面上的办法求出交点，但是发现指定精度阈值以后，感官看上去的交点丢失了。于是怎么设置阈值又是个问题。\n所以我想问的问题是\n怎么求射线与TopoDS_Shape的交点？这里我想要的是最佳实践。\nOpenCascade版本是7.5.0", "Tag": "算法分析"}
{"Answer": "已经用脚本写出来了，其实不用游标也可以，写的脚本如下\n\nUPDATE elevator_enterprise_sy_analyse t1 JOIN (SELECT t1.id,t2.ent_extend2 FROM\n(\nSELECT ent_extend2,MIN(ent_extend3) ent_extend3 FROM elevator_enterprise_sy_analyse WHERE ent_extend1=1 GROUP BY ent_extend2\n) t2\nLEFT JOIN elevator_enterprise_sy_analyse t1 ON t1.ent_extend2=t2.ent_extend2 AND t1.ent_extend3=t2.ent_extend3) \nt2 ON t1.ent_extend2 = t2.ent_extend2\nSET t1.fk_root_id = t2.id,t1.fk_ent_pid=t2.id WHERE t1.ent_extend1=1 AND t1.fk_root_id=t1.id  ;\n ", "Konwledge_Point": "负权边的最短路径", "Question": "mysql存储过程数据问题处理，游标\nMySQL现在遇到这个问题需要写存储过程进行处理，问题场景如下：\n\n\n\n对同一张表数据循环更新，如表test，中存在，a，b，c，d，e，f，g，其中a为主键，现阶段a与b数据一致，如果数据量在500，其中c列存在一部分相同数据（如500条去重后可能只有100多条数据），现需要将c字段中相同的字段的b列更新为d列长度最短的那条（d列数据是c+其他字符）记录的a列id主键，如图，红框内容更新为黄框中，用游标写但是逻辑上没搞清楚，在线等\n\n\n\n\n\n\n ", "Tag": "算法分析"}
{"Answer": "telnet 命令需要加端口，如果有具体的端口就加具体的端口  没有加个80", "Konwledge_Point": "负权边的最短路径", "Question": "win10在控制面板明明已经启用了telnet,可是在服务里找不到telnet，telnet用不了 ！\nwin10在控制面板明明已经启用了telnet,可是在服务里找不到telnet，telnet用不了：\n\n\n可以ping成功：\n\n\nC:\\Users\\11917>ping 192.168.10.18\n\n正在\n Ping \n192.168.10.18 具有 32 字节的数据:\n来自 192.168.10.18 的回复: 字节=32 时间=1ms \nTTL\n=64\n来自 192.168.10.18 的回复: 字节=32 时间=1ms \nTTL\n=64\n来自 192.168.10.18 的回复: 字节=32 时间=1ms \nTTL\n=64\n来自 192.168.10.18 的回复: 字节=32 时间=1ms \nTTL\n=64\n\n192.168.10.18 的\n Ping \n统计信息:\n    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，\n往返行程的估计时间(以毫秒为单位):\n    最短 = 1ms，最长 = 1ms，平均 = 1ms\n\n\n\n但是telnet用不了：\n\n\nC:\\Users\\\n11917\n>telnet \n127.0.0.1\n\n正在连接\n127.0.0.1\n...无法打开到主机的连接。 在端口 \n23\n: 连接失败\n\nMicrosoft Telnet> o                                                                                                     \n( to ) \n192.168.10.17\n                                                                                                 \n 正在连接...无法打开到主机的连接。 在端口 \n192.168.10.17\n: 连接失败\n", "Tag": "算法分析"}
{"Answer": "\n\n\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-\n\"\"\"\n@author: Roc-xb\n\"\"\"\n\nimport os\nimport re\n\nipadd = '39.97.4.86'\ncommand = \"ping -n 1 \" + ipadd + \">ip.txt\"\nos.system(command)\ntxt = open('ip.txt', encoding=\"gbk\").read().replace(\" \", \"\")\nres = re.findall(\"=(\\d+)\", txt)\nprint(res)\n\n", "Konwledge_Point": "负权边的最短路径", "Question": "python问题，返回值去内容问题\n\n# *\n--coding:utf-8 --*\n\n\n\nimport\n \nos\n\n\nimport\n re\n\nimport\n \nstring\n\n\nimport\n subprocess\n\n\nipadd = \n'193.168.70.2'\n\n\np = \nos\n.popen(\n'ping -n 1 '\n  + ipadd)\npin = p.read()\np.close\n\n\n\nprint\n (pin)\n\n\n\n打印结果：\n正在 Ping 193.168.70.2 具有 32 字节的数据:\n来自 193.168.70.2 的回复: 字节=\n32\n 时间<\n1\nms TTL=\n128\n\n\n193.168.70.2 的 Ping 统计信息:\n    数据包: 已发送 = \n1\n，已接收 = \n1\n，丢失 = \n0\n (0% 丢失)，\n往返行程的估计时间(以毫秒为单位):\n    最短 = \n0\nms，最长 = \n0\nms，平均 = \n0\nms\n\n\n想分别取出ping输出结果，取出字节=后的32数字，取出时间<后的秒数，取出TTL=后的128，取出的内容均为数字。需要取出的数字都已经加粗，请问究竟应该怎么取出啊？求指点，感激不尽，谢谢", "Tag": "算法分析"}
{"Answer": "【有帮助请采纳】\nn = int(input())                        #输入n\ndata = list(map(str,input().split()))   #将编号数据存储到列表data中\nk = int(input())                        #输入查询次数\nfor i in range(k):                      #遍历查询次数\n    x = input()                         #输入查询书号\n    if x in data:print(data.index(x))   #判断存在，输出顺序号\n    else:print(-1)                      #判断为否，输出-1\n\n【有帮助请采纳】", "Konwledge_Point": "负权边的最短路径", "Question": "输入书序号，输出书的位置\n某书库的书不是乱七八糟摆放的，而是按照书的编号（也就是每本书有一个唯一整数编号）顺序摆放的。书库为了提供服务质量，委托了你开发图书查询系统，要求开发的系统提供查询服务具有最短平均响应时间。在此假定，读者查询每一本的概率都是相等的，如果书不存在，也要求尽可能快地得到结果。\n输入格式\n第一行一个整数n，表示书库中书的总本数，0<n<=10,000,000。其后n个按升序排列的正整数，每个编号代表一本书。接下来的一行包含一个整数k，表示读者的查询次数，0<k<10000。此后的k行，每行一个整数，表示读者查询的书号，书号取值范围[1 , 10的19次方]。\n输出格式\n输出每次查询的结果，如果书号存在，再输出该书号对应的顺序号（顺序号是从0开始的），如果没有则输出-1。\n输入样例 复制\n10\n2 3 7 100 168 2018 3125 5196 712513 1234567890123\n4\n100\n101\n1234567890123\n2018\n输出样例 复制\n3\n-1\n9\n5", "Tag": "算法分析"}
{"Answer": "手打的，希望有帮助：", "Konwledge_Point": "负权边的最短路径", "Question": "pta 时间类型-设置时间\n定义如下时间结构类型\ntypedef struct\n{\n    char hour, minute, second;\n} MYTIME;\n注：为了节约内存，由于小时数最大为23，分钟数和秒数最大为59，因此小时数、分钟数和秒数均采用最短的整数(char)，最大值可达127。\n请编写函数，设置时间结构类型变量的值。\n函数原型\nvoid TimeSet(MYTIME *time, int hour, int minute, int second);\n说明：参数 time 为指示时间结构类型变量的指针，hour、minute和second 为时、分和秒数。若参数 hour、minute 和 second 正确有效，则函数将 time 所指示的时间结构类型变量设置成此时间，否则报告错误，不修改时间结构类型变量的值。\n\n\n裁判程序\n#include \n\n\n......\n\n\ntypedef struct\n{\n    char hour, minute, second;\n} MYTIME;\n\n\nint IsValidTime(int hour, int minute, int second);\nvoid TimeSet(MYTIME *time, int hour, int minute, int second);\n\n\nint main()\n{\n    MYTIME a = {12, 15, 30};\n    int h, m, s;\n    scanf(\"%d %d %d\", &h, &m, &s);\n    TimeSet(&a, h, m, s);\n    printf(\"%d %d %d\\n\", a.hour, a.minute, a.second);\n    return 0;\n}\n输入样例1\n8 30 45\n输出样例1\n8 30 45\n输入样例2\n20 60 -15\n输出样例2\n不正确参数！\n12 15 30", "Tag": "算法分析"}
{"Answer": "for(j=n-1;j<2*n;j++)第二个循环应该从n开始，而不是n-1。现在和for(j=0;j<n;j++)重复了j=n-1", "Konwledge_Point": "负权边的最短路径", "Question": "C语言文本读取内容错误\n就是我在执行ticket()函数时readtxt()这个函数时从文本里读取出来的数字跟我文本里存的不一样\n自己写的，可能有些地方不太对\n\n\n#include\"stdio.h\"\n\n\n#include\"stdlib.h\"\n\n\n#include\"string.h\"\n\n\n\n#define max 50\n\n\nint Bian[max][max][\n2\n];\n//\n第一层存放相连站点的距离，第二层存放到各点的最短距离\n//\n \n\nstruct subway\n{\n    char no[max];\n//\n编号\n//\n \n    char ostation[max];\n//\n线路起始站\n//\n\n    char estation[max];\n//\n线路终点站\n//\n\n}sub[max];\n\nint n,z=\n1\n;\n\nvoid readtxt();\n//\n读取文本\n//\n\nint money(int a);\n//\n计算票价\n//\n\nint jisuan(int i,int h,int c);\n//\n辅助计算最短距离\n//\n \nvoid shortest();\n//\n计算最短距离\n//\n \nvoid save();\n//\n保存文件\n//\n\nvoid add();\n//\n增加站点\n//\n\nvoid Delete();\n//\n删除站点\n//\n\nvoid Print();\n//\n存储信息的浏览\n//\n\nvoid Search();\n//\n对单一站点信息查询\n//\n \nvoid ticket();\n//\n计算票价\n//\n \nvoid menu();\n//\n主菜单\n//\n \n\n\nint main()\n{\n    \nwhile\n(z)\n    menu();\n    system(\n\"pause\"\n);\n    return \n0\n;\n}\n\n\nvoid readtxt()\n//\n读取文本\n//\n\n{\n    int i=\n0\n,j,k=\n0\n;\n    FILE *fp;\n    \nif\n((fp=fopen(\n\"subway.txt\"\n,\n\"r\"\n))==NULL)\n    {\n        printf(\n\"subway.txt读取失败\"\n);\n        system(\n\"pause\"\n);\n        \nexit\n(\n0\n);\n    }\n    FILE *B;\n    \nif\n((B=fopen(\n\"Bow.txt\"\n,\n\"r\"\n))==NULL)\n    {\n        printf(\n\"Bow.txt读取失败\"\n);\n        system(\n\"pause\"\n);\n        \nexit\n(\n0\n);\n    }\n    \nwhile\n(fscanf(fp,\n\"%s %s %s\"\n,sub[i].no,sub[i].ostation,sub[i].estation)==\n3\n)\n//\n站点的读取\n//\n \n    {\n        i++;\n    }\n    fclose(fp);\n    n=i;\n    \n    \nfor\n(i=\n0\n;i<\n2\n*n;i++)\n//\n边的读取\n//\n \n    {\n        \nfor\n(j=\n0\n;j\n4\n&&a<=\n12\n)\n      i=\n2\n+(a-\n4\n)/\n4\n;\n    \nelse\n \nif\n(a>\n12\n&&a<=\n24\n)\n      i=\n4\n+(a-\n12\n)/\n6\n;\n    \nelse\n\n      i=\n6\n+(a-\n24\n)/\n8\n;\n    return i;\n}\n\nint road[max][max];\n//\n记录是否走过\n//\n \n\n\n#define kon 999\n\n\nint jisuan(int i,int h,int c)\n//\n计算最短距离\n//\n \n{\n    int j,k=\n0\n,l;\n    int a=kon,b,d,e;\n    \nfor\n(j=\n0\n;j=Bian[h][j][\n0\n])\n            {\n                a=Bian[h][j][\n0\n];\n                \nif\n(a<=Bian[h][j][\n1\n])\n                {\n                    \nif\n(h!=i)\n                    {\n                        l=c+a;\n                    }\n                    \nelse\n\n                    {\n                        l=a;    \n                    }\n                    \nif\n(l ;相连站点数量 \n//\n \n    int a[\n10\n];\n//\n相连地铁编号\n//\n \n    int b[\n10\n];\n//\n相连距离\n//\n \n    FILE *fp;\n    FILE *B;\n    \nif\n((fp=fopen(\n\"subway.txt\"\n,\n\"a+\"\n))==NULL)\n    {\n        printf(\n\"subway.txt读取失败\"\n);\n        system(\n\"pause\"\n);\n        \nexit\n(\n0\n);\n    }\n    \nif\n((B=fopen(\n\"Bow.txt\"\n,\n\"a+\"\n))==NULL)\n    {\n        printf(\n\"Bow.txt读取失败\"\n);\n        system(\n\"pause\"\n);\n        \nexit\n(\n0\n);\n    }\n    \nwhile\n(fscanf(fp,\n\"%s %s %s\"\n,sub[i].no,sub[i].ostation,sub[i].estation)==\n3\n)\n//\n站点的读取\n//\n \n    {\n        i++;\n    }\n    fclose(fp);\n    n=i;\n    \nif\n(n==\n0\n)\n    {\n        p=\n1\n;\n    }\n    printf(\n\"%d\\n\"\n,i);\n    \nfor\n(g=\n0\n;g<n;g++)\n//\n边的读取\n//\n \n    {\n        \nfor\n(j=\n0\n;j<n;j++)\n        {\n            fscanf(B,\n\"%d\"\n,&Bian[g][j][\n0\n]);\n        }\n        fscanf(B,\n\"\\n\"\n);\n    }\n    \nfor\n(i=\n0\n;i<n;i++)\n//\n最短距离的读取\n//\n \n    {\n        \nfor\n(j=\n0\n;j<n;j++)\n        {\n            fscanf(B,\n\"%d\"\n,&Bian[i][j][\n1\n]);\n        }\n        fscanf(B,\n\"\\n\"\n);\n    }\n    fclose(B);\n    \n    \n//\n分割\n//\n \n    printf(\n\"请输入待增加的地铁站点数量：\\n\"\n);\n    scanf(\n\"%d\"\n,&l);\n    \ndo\n\n    {\n        flag=\n1\n;\n        \nwhile\n(flag)\n        {\n            flag=\n0\n;\n            printf(\n\"请输入第%d个地铁站点的编号:\\n\"\n,i+\n1\n);\n            scanf(\n\"%s\"\n,sub[i].no);\n            \nfor\n(j=\n0\n;j<i;j++)\n            {\n                \nif\n(strcmp(sub[i].no,sub[j].no)==\n0\n)\n                {\n                    printf(\n\"已有该地铁编号，请重新登入。\\n\"\n);\n                    flag=\n1\n;\n                    system(\n\"pause\"\n); \n                    \nbreak\n;\n                }\n            }\n            printf(\n\"请输入第%d个地铁站点的起始站：\\n\"\n,i+\n1\n);\n            scanf(\n\"%s\"\n,sub[i].ostation);\n            printf(\n\"请输入第%d个地铁站点的终点站：\\n\"\n,i+\n1\n);\n            scanf(\n\"%s\"\n,sub[i].estation);\n            \n            printf(\n\"与该地铁站点相连的地铁站点数量：\\n\"\n);\n            scanf(\n\"%d\"\n,&h);\n            \n            \nfor\n(j=\n0\n;j<h;j++)\n            {\n                printf(\n\"请输入与第%d号地铁站点相连的地铁编号：\\n\"\n,i+\n1\n);\n                scanf(\n\"%d\"\n,&a[j]);    \n            }\n            \nfor\n(j=\n0\n;j<h;j++)\n            {\n                printf(\n\"请输入与第%d号地铁编号相连站点的距离：(一次一个)\\n\"\n,i+\n1\n);\n                scanf(\n\"%d\"\n,&Bian[i][a[j]-\n1\n][\n0\n]);\n                Bian[a[j]-\n1\n][i][\n0\n]=Bian[i][a[j]-\n1\n][\n0\n];\n            }\n            \n            \nif\n(flag==\n0\n)\n            {\n                i++;\n            }\n        }\n    }\n    \nwhile\n(i<n+l);\n    n+=l;\n    \n//\n分割\n//\n \n    \nfor\n(j=\n0\n;j<n;j++)\n    {\n        \nfor\n(g=\n0\n;g<n;g++)\n        {\n            \n            \nif\n(Bian[j][g][\n0\n]==\n0\n&&j!=g)\n            {\n                Bian[j][g][\n1\n]=kon;\n            }\n            \nelse\n\n            {\n                Bian[j][g][\n1\n]=Bian[j][g][\n0\n];\n            }\n        }\n    }\n    \nif\n(p==\n0\n)\n    {\n        shortest();\n    }\n    \nelse\n\n        save();\n//\n保存\n//\n \n    printf(\n\"录入完毕！\\n\\n\"\n);\n    return ;\n}\n\nvoid Delete()\n{\n    int i=\n0\n,k=\n0\n,j,g;\n    char a[\n10\n];\n//\n相连地铁编号\n//\n \n    int b[\n10\n];\n//\n相连距离\n//\n \n    FILE *fp;\n    FILE *B;\n    \nif\n((fp=fopen(\n\"subway.txt\"\n,\n\"r\"\n))==NULL)\n    {\n        printf(\n\"subway.txt读取失败\"\n);\n        system(\n\"pause\"\n);\n        \nexit\n(\n0\n);\n    }\n    \nif\n((B=fopen(\n\"Bow.txt\"\n,\n\"r\"\n))==NULL)\n    {\n        printf(\n\"Bow.txt读取失败\"\n);\n        system(\n\"pause\"\n);\n        \nexit\n(\n0\n);\n    }\n    \nwhile\n(fscanf(fp,\n\"%s %s %s\"\n,sub[i].no,sub[i].ostation,sub[i].estation)==\n3\n)\n//\n站点的读取\n//\n \n    {\n        i++;\n    }\n    fclose(fp);\n    n=i;\n    \nfor\n(g=\n0\n;g<n;g++)\n//\n边的读取\n//\n \n    {\n        \nfor\n(j=\n0\n;j<n;j++)\n        {\n            fscanf(B,\n\"%d\"\n,&Bian[g][j][\n0\n]);\n        }\n        fscanf(B,\n\"\\n\"\n);\n    }\n    \nfor\n(i=\n0\n;i<n;i++)\n//\n最短距离的读取\n//\n \n    {\n        \nfor\n(j=\n0\n;j<n;j++)\n        {\n            fscanf(B,\n\"%d\"\n,&Bian[i][j][\n1\n]);\n        }\n        fscanf(B,\n\"\\n\"\n);\n    }\n    fclose(B);\n    \n//\n分割\n//\n \n    int t,flag=\n0\n;\n    char s1[\n30\n];\n    printf(\n\"请输入要删除的地铁编号:\\n\"\n);\n    scanf(\n\"%s\"\n,s1);\n    \nfor\n(t=\n0\n;t<n;t++)\n    {\n        \nif\n(strcmp(sub[t].no,s1)==\n0\n)\n        {\n            flag=\n1\n;\n            \nfor\n(j=t;j<n-\n1\n;j++)\n            {\n                sub[j]=sub[j+\n1\n]; \n            }\n        }\n        \nif\n(flag==\n1\n)\n        {\n            \nfor\n(j=t;j<n-\n1\n;j++)\n            {\n                \nfor\n(g=\n0\n;g<n;g++)\n                {\n                    Bian[j][g][\n0\n]=Bian[j+\n1\n][g][\n0\n];\n                    Bian[g][j][\n0\n]=Bian[g][j+\n1\n][\n0\n];\n                }\n            }\n        }\n    }\n    \nfor\n(j=\n0\n;j<n;j++)\n    {\n        \nfor\n(g=\n0\n;g<n;g++)\n        {\n            \nif\n(Bian[j][g][\n0\n]=NULL)\n            {\n                Bian[j][g][\n1\n]=kon;\n            }\n            \nelse\n\n            {\n                Bian[j][g][\n1\n]=Bian[j][g][\n0\n];\n            }\n        }\n    }\n    \nif\n(flag==\n0\n)\n    {\n        printf(\n\"该编号不存在！\\n\"\n);\n    }\n    \nif\n(flag==\n1\n)\n    {\n        printf(\n\"站点删除成功！\\n\"\n);\n        n--;\n    }\n    shortest();\n    save();\n}\n\nvoid Search()\n//\n查找 \n{\n    FILE *fp;\n//\n要读取的文件指针 \n    int i=\n0\n;\n//\n数组移动\n    \nif\n((fp=fopen(\n\"subway.txt\"\n,\n\"r\"\n))==NULL)\n    {\n        printf(\n\"subway.txt读取失败\"\n);\n        system(\n\"pause\"\n);\n        \nexit\n(\n0\n);\n    }\n    printf(\n\"hi\\n\"\n);\n    system(\n\"pause\"\n);\n    \nwhile\n(fscanf(fp,\n\"%s %s %s\"\n,sub[i].no,sub[i].ostation,sub[i].estation)==\n3\n)\n    {\n        i++;\n    }\n     \n    n=i;\n    int j,item,flag=\n0\n;\n    char s1[\n10\n];\n    printf(\n\"----------------------------------------------------------\\n\"\n);\n    printf(\n\"------------------◎ 1.按编号查询   ◎--------------------\\n\"\n);\n    printf(\n\"------------------◎ 2.按起始站查询 ◎--------------------\\n\"\n);\n    printf(\n\"------------------◎ 3.按终点站查询 ◎--------------------\\n\"\n);\n    printf(\n\"------------------◎ 4.退出本菜单   ◎--------------------\\n\"\n);\n    printf(\n\"----------------------------------------------------------\\n\"\n);\n    \nwhile\n(\n1\n)\n       {\n           printf(\n\"请选择子菜单编号:\"\n);\n           scanf(\n\"%d\"\n,&item);\n           flag=\n0\n;\n           switch(item)\n          {\n            case \n1\n:\n            printf(\n\"请输入要查询的地铁站点编号：\"\n);\n//\n通过地铁线路查找 \n            scanf(\n\"%s\"\n,s1);\n            \nfor\n(j=\n0\n;j<n;j++)\n            \nif\n(strcmp(sub[j].no,s1)==\n0\n)\n            {\n                flag=\n1\n;\n                printf(\n\"地铁编号   起始站    终点站\\n\"\n); \n                printf(\n\"---------------------------\\n\"\n);\n                printf(\n\"  %s          %s         %s       \\n\"\n,sub[j].no,sub[j].ostation,sub[j].estation);\n                \n            }         \n            \nif\n(flag==\n0\n)\n            printf(\n\"查询错误，无该信息!\\n\"\n); \nbreak\n;\n            case \n2\n:\n            printf(\n\"请输入查询的地铁起始站：\"\n);\n//\n通过地铁起始站查找 \n            scanf(\n\"%s\"\n,s1);\n            \nfor\n(j=\n0\n;j<n;j++)\n             \nif\n(strcmp(sub[j].ostation,s1)==\n0\n)\n            {\n                flag=\n1\n;\n                printf(\n\"地铁编号   起始站    终点站\\n\"\n); \n                printf(\n\"---------------------------\\n\"\n);\n                printf(\n\"  %s          %s         %s       \\n\"\n,sub[j].no,sub[j].ostation,sub[j].estation);\n            }\n                     \n            \nif\n(flag==\n0\n)\n            printf(\n\"查询错误，无该信息!\\n\"\n); \nbreak\n;    \n            case \n3\n:\n            printf(\n\"请输入查询的地铁终点站：\"\n);\n//\n通过地铁终点站查找 \n            scanf(\n\"%s\"\n,s1);\n            \nfor\n(j=\n0\n;j<n;j++)\n            \nif\n(strcmp(sub[j].estation,s1)==\n0\n) \n            {\n                flag=\n1\n;\n                printf(\n\"地铁编号   起始站    终点站\\n\"\n); \n                printf(\n\"---------------------------\\n\"\n);\n                printf(\n\"  %s          %s         %s       \\n\"\n,sub[j].no,sub[j].ostation,sub[j].estation);\n                \n            }\n            \nif\n(flag==\n0\n)\n            printf(\n\"查询错误，无该信息\\n\"\n); \nbreak\n;    \n            case \n4\n: return;\n            default:printf(\n\"请在1-4之间选择\\n\"\n);\n//\n提示用户在有效范围中选择 \n        }\n    }\n}\n\nvoid Print()\n//\n存储信息的浏览\n//\n\n{\n    int i; \n    printf(\n\"欢迎查询地铁线路!所有信息为:\\n\"\n);\n    printf(\n\"地铁编号   起始站    终点站\\n\"\n); \n    printf(\n\"---------------------------\\n\"\n);\n    readtxt();\n//\n调用函数 \n    \nfor\n(i=\n0\n;i<n;i++)\n    {\n    printf(\n\"  %s          %s         %s       \\n\"\n,sub[i].no,sub[i].ostation,sub[i].estation);\n    }\n    system(\n\"pause\"\n);\n}\n\nvoid ticket()\n{\n    int i,j,l;\n    readtxt();\n    system(\n\"pause\"\n);\n    \n    printf(\n\"请输入起点站编号：\\n\"\n);\n    scanf(\n\"%d\"\n,&i);\n    printf(\n\"请输入终点站编号：\\n\"\n);\n    scanf(\n\"%d\"\n,&j);\n    l=Bian[i-\n1\n][j-\n1\n][\n1\n];\n    printf(\n\"从第%d号地铁站到第%d号地铁站的地铁票需要%d元。\\n\\n\"\n,i,j,money(l));\n}\n\nvoid menu()\n//\n主菜单\n//\n \n{\n    int num;\n    system(\n\"color 75\"\n);\n//\n更改界面颜色为灰色背景浅紫色字体 \n    printf(\n\"******************************广州地铁线网票价查询系统**************************\\n\"\n);\n    printf(\n\"***********************友情提示：浏览和更新前请先刷新系统***********************\\n\"\n);\n    printf(\n\"                       **********************************                       \\n\"\n);\n    printf(\n\"                       *     0     刷新地铁信息         *                       \\n\"\n);\n    printf(\n\"                       *     1     地铁信息的增加       *                       \\n\"\n);\n    printf(\n\"                       *     2     地铁信息的浏览       *                       \\n\"\n);\n    printf(\n\"                       *     3     地铁信息的查询       *                       \\n\"\n);\n    printf(\n\"                       *     4     地铁票价的查询       *                       \\n\"\n);\n    printf(\n\"                       *     5     地铁信息的删除       *                       \\n\"\n);\n    printf(\n\"                       *     6          退出            *                       \\n\"\n);\n    printf(\n\"                       **********************************                       \\n\"\n);\n    printf(\n\"请输入选择序号:\\n\"\n);\n    scanf(\n\"%d\"\n,#);\n    switch(num)\n    { \n        case \n0\n:readtxt();  \nbreak\n; \n        case \n1\n:add();  \nbreak\n;\n        case \n2\n:Print();  \nbreak\n;\n        case \n3\n:Search();  \nbreak\n;\n        case \n4\n:ticket();  \nbreak\n;\n        case \n5\n:Delete();  \nbreak\n;\n        case \n6\n:z=\n0\n;  printf(\n\"Bye!\\n\"\n);  \nbreak\n;\n        default:printf(\n\"请在0-6之间选择\\n\"\n);\n    }\n}\n\n\n\n\n图一是readtxt()读取出来的数，图二是文本里的数\n\n", "Tag": "算法分析"}
{"Answer": "m1&1和n1&1是判断奇数偶数的，\r\n\r\n最后输出abs（m1-n1）这个没问题吧？就是两个楼差的行数，比如7和20，这部分就是3\r\nabs（m2-n2）的部分就是判断两楼在同一行时需要走的路。如果m1或者n1是奇数，w-1-m1表示楼离最左边的距离。也就是最后求两个楼离最左边距离的差的绝对值\r\n\r\n最初的时候m--和n--，表示把整个矩阵改变为从0开始。\r\n\r\n比如4 7 20\r\n\r\n矩阵：\r\n0 1 2 3\r\n7 6 5 4\r\n8 9 10 11\r\n15 14 13 12\r\n16 17 18 19\r\n               20\r\n这样就是求6和19的距离了\r\n\r\n其实如果不做m--和n--改变下算法也是可以的", "Konwledge_Point": "负权边的最短路径", "Question": "蓝桥杯—移动距离的问题，走过的路过，千万不要错过\n移动距离\n\n\n\nX星球居民小区的楼房全是一样的，并且按矩阵样式排列。其楼房的编号为1,2,3...\n\n当排满一行时，从下一行相邻的楼往反方向排号。\n\n比如：当小区排号宽度为6时，开始情形如下：\n\n\n\n1  2  3  4  5  6\n\n12 11 10 9  8  7\n\n13 14 15 .....\n\n\n\n我们的问题是：已知了两个楼号m和n，需要求出它们之间的最短移动距离（不能斜线方向移动）\n\n\n\n输入为3个整数w m n，空格分开，都在1到10000范围内\n\nw为排号宽度，m,n为待计算的楼号。\n\n要求输出一个整数，表示m n 两楼间最短移动距离。\n\n\n\n例如：\n\n用户输入：\n\n6 8 2\n\n则，程序应该输出：\n\n4\n\n\n\n再例如：\n\n用户输入：\n\n4 7 20\n\n则，程序应该输出：\n\n5\n\n\n\n资源约定：\n\n峰值内存消耗 < 256M\n\nCPU消耗  < 1000ms\n\n\n\n请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。\n\n\n\n所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。\n\n\n\n注意: main函数需要返回0\n\n注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。\n\n注意: 所有依赖的函数必须明确地在源文件中 #include ， 不能通过工程设置而省略常用头文件。\n\n\n\n提交时，注意选择所期望的编译器类型。\n\n\n\n我找到的解答方案如下：\n\n\n\n #include \n#include \nusing namespace std;\nint main()\n{\n    int w,m,n;\n    cin>>w>>m>>n;\n\n    m--;\n    n--;\n\n    int m1=m/w, m2=m%w;\n    if(m1&1)\n    {\n        m2=w-1-m2;\n    }\n\n    int n1=n/w, n2=n%w;\n    if(n1&1)\n    {\n        n2=w-1-n2;\n    }       \n\n    cout<<abs(m1-n1)+abs(m2-n2)<<endl;\n    return 0;\n}\n\n\n\n", "Tag": "算法分析"}
{"Answer": "同学你好，你用sparse函数构成的连接矩阵不是方阵，导致后面那个函数graphshortestpath内部调用的另外一个函数graphalgs算法产生错误。改正的办法是把sparse内部调用设置为方阵，这样就不会有问题啦！\na=[1,1,1,2,2,3,3,4,4,5,6,6,7,8,8,8,8,9,9,9,10,10,11,11,12,13,13,14,14,15,17];\nb=[2,5,6,3,5,4,9,10,11,8,7,12,8,9,13,12,14,10,13,15,11,15,15,16,14,14,15,15,17,16,18];\nweight=[48 45 48 51 36 48 39 42 48 27 48 51 27 30 27 27 75 30 27 39 39 45 45 45 57 23 30 42 48 42 48 ];\nN = max([a(:);b(:)]);%N是方阵的大小\ndg=sparse(a,b,weight, N, N);%稀疏矩阵设置为N×N大小的方阵即可\n[m,n]=graphshortestpath(dg,1,2)\n", "Konwledge_Point": "负权边的最短路径", "Question": "graphshortestpath调用时报错\n我想用该函数求解最短路程，结果出现这样一句话\n下面是我的代码\na=[1,1,1,2,2,3,3,4,4,5,6,6,7,8,8,8,8,9,9,9,10,10,11,11,12,13,13,14,14,15,17];\nb=[2,5,6,3,5,4,9,10,11,8,7,12,8,9,13,12,14,10,13,15,11,15,15,16,14,14,15,15,17,16,18];\n\n\nweight=[48 45 48 51 36 48 39 42 48 27 48 51 27 30 27 27 75 30 27 39 39 45 45 45 57 23 30 42 48 42 48 ];\ndg=sparse(a,b,weight);\n[m,n]=graphshortestpath(dg,1,2)\n请问各位怎么回事呀", "Tag": "算法分析"}
{"Answer": "升级电脑的Git工具到最新版本，再试一试", "Konwledge_Point": "负权边的最短路径", "Question": "能ping通github.com却不能clone项目。\n\n\nD:\\myapp>ping github.com\n\n正在 Ping github.com [13.229.188.59] 具有 32 字节的数据:\n来自 13.229.188.59 的回复: 字节=32 时间=84ms TTL=43\n来自 13.229.188.59 的回复: 字节=32 时间=83ms TTL=43\n来自 13.229.188.59 的回复: 字节=32 时间=83ms TTL=43\n来自 13.229.188.59 的回复: 字节=32 时间=83ms TTL=43\n\n13.229.188.59 的 Ping 统计信息:\n    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，\n往返行程的估计时间(以毫秒为单位):\n    最短 = 83ms，最长 = 84ms，平均 = 83ms\n\nD:\\myapp>git clone https://github.com/aave/flashloan-box\nCloning into 'flashloan-box'...\nfatal: unable to access 'https://github.com/aave/flashloan-box/': OpenSSL SSL_connect: Connection was reset in connection to github.com:443\n\nD:\\myapp>\n\n\n\n浏览器能直接访问到项目。", "Tag": "算法分析"}
{"Answer": "前端是不行的，  nodejs可以的，你参考一下这个基本现成的https://blog.csdn.net/qq_34310906/article/details/109582102", "Konwledge_Point": "负权边的最短路径", "Question": "javascript怎样实现类似windows中的ping命令\n请问javascript是否可以实现类似windows 的ping命令那样对多个内网IP地址的通断进行判断，ip地址绑定的设备有可能是电脑，有可能是路由，将结果返回以数组形式输出到txt中保存。\n\n\n通的话将下方内容写进txt\n正在 Ping 193.168.13.2 具有 32 字节的数据:\n来自 193.168.13.2 的回复: 字节=32 时间=5ms TTL=124\n来自 193.168.13.2 的回复: 字节=32 时间=5ms TTL=124\n来自 193.168.13.2 的回复: 字节=32 时间=4ms TTL=124\n来自 193.168.13.2 的回复: 字节=32 时间=4ms TTL=124\n\n\n193.168.13.2 的 Ping 统计信息:\n    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，\n往返行程的估计时间(以毫秒为单位):\n    最短 = 4ms，最长 = 5ms，平均 = 4ms\n\n\n请帮忙解答，查了好多资料都是外网的解决方法，因为是内网所有不能用", "Tag": "算法分析"}
{"Answer": "代码如下，望采纳，谢谢！\ndef check_password(password):\n    # fill your codes after this line\n    s=[0,0,0,0]\n    for c in password:\n        if c >= '0' and c <= '9':\n            s[0]=1\n        if c >= 'A' and c <= 'Z':\n            s[1]=1\n        if c >= 'a' and c <= 'z':\n            s[2]=1\n        if c in '@#$%&':\n            s[3]+=1\n        if c == ' ':\n            return False\n    if sum(s) >= 5 and s[3] >= 2 and len(password) >= 7 and len(password) <= 13:\n        return True\n    else:\n        return False\n    # end of your codes\n# do not modify\nif __name__ == \"__main__\":\n    passwords = input().split(',')\n    oks=[]\n    for password in passwords:\n        if check_password(password):\n            oks.append(password)\n    print(\"符号密码设定标准的结果为:\",','.join(oks))\n\n", "Konwledge_Point": "负权边的最短路径", "Question": "python编程实现密码检测\n假定某系统密码设定规则如下：\n(1). [a-z]之间至少有1个字母 【判断条件提示：j >= 'a' and j <= 'z'，以下类似】\n(2). [A-Z]之间至少有1个字母\n(3). [0-9]之间至少有1个数字\n(4). [\n@#$%&\n]中至少有2个字符\n(5).密码的最短长度：7\n(6).密码的最大长度：13\n(7).密码不能包含空格\n请编程实现下述问题：程序接受键盘输入的多个逗号分隔的密码，并根据上述密码设定规则对所有密码进行检测，将符合条件的密码以字符串形式打印，每个密码用逗号分隔。\n例：\n如果以下密码作为程序的输入：ABd1#234\n@1,a \nF1#\n@12,2w&a3E\n,2We3345,dHuD&u\n12=e, ABd1234\n@1，则程序的输出应该是：符合密码设定标准的结果为：ABd1#234@1,2w&a3E", "Tag": "算法分析"}
{"Answer": "封装成函数了\nfrom haversine import haversine\n\na = {111: (-37.4168610028693, 145.005372256037),\n     222: (-37.7032933463858, 144.572524145218),\n     333: (-37.7292612709136, 144.650631483984),\n     444: (-37.7777637471456, 144.772303608804),\n     555: (-37.5792063872414, 144.72816450831),\n     666: (-37.7830652929363, 144.802188066669),\n     777: (-37.6019247988331, 144.943306014347)}\n\nb = [(-38.04683, 145.1261),\n     (-37.78122000000001, 145.0336),\n     (-37.7709, 145.1104),\n     (-37.7076, 144.9097),\n     (-37.7762, 145.0958),\n     (-37.97593, 145.18931)]\n\ndef getMinDist(a:dict, b:list): \n     minDist = 2**31-1\n     key = 0\n     for k in a.keys():\n          for i in range(len(b)):\n               d = haversine(a[k], b[i])\n               if(d<minDist):\n                    minDist = d\n                    key = k\n     return key, minDist\n\nk, d = getMinDist(a, b)\nprint(f\"关键字是{k}, 最短距离是{d}\")\n\n\n", "Konwledge_Point": "负权边的最短路径", "Question": "python找最小值\n有一个字典a\na = {111: (-37.4168610028693, 145.005372256037),\n 222: (-37.7032933463858, 144.572524145218),\n 333: (-37.7292612709136, 144.650631483984),\n 444: (-37.7777637471456, 144.772303608804),\n 555: (-37.5792063872414, 144.72816450831),\n 666: (-37.7830652929363, 144.802188066669),\n 777: (-37.6019247988331, 144.943306014347)}\n\n\n列表b\nb = [(-38.04683, 145.1261)\n(-37.78122000000001, 145.0336)\n(-37.7709, 145.1104)\n(-37.7076, 144.9097)\n(-37.7762, 145.0958)\n(-37.97593, 145.18931)]\n\n\n我想用haversine包计算出b列表每个元素到字典a中的每个values的距离，并找到每个列表元素到字典value的最小值然后返回字典key，比如b[0]到字典a['111']的距离是b[0]到字典a的所有value中的距离最短，那么打印key111和距离。请问要如何实现呢", "Tag": "算法分析"}
{"Answer": "print(Cmd_out) 之前判断下   Cmd_out是不是空字符串即可\n    if Cmd_out.strip(' \\r\\n')!=\"\":\n        print(Cmd_out)\n\n\n如有帮助，请点击我的回答下方的【采纳该答案】按钮帮忙采纳下，谢谢!\n", "Konwledge_Point": "负权边的最短路径", "Question": "print输出有空行，怎么删除\n代码如下：import subprocess\n\n\np = subprocess.Popen('ping baidu.com',\n                     shell=True,\n                     stdin=subprocess.PIPE,\n                     stdout=subprocess.PIPE, )\nwhile True:\n    result = p.stdout.readline()\n\n\nif\n result != \nb''\n:  \n    \ntry\n:\n        Cmd_out = \nstr\n(result.decode(\n'gbk'\n).strip(\n' \\r\\n'\n))  \n    \nexcept\n:\n        Cmd_out = \nstr\n(result.decode(\n'utf-8'\n).strip(\n' \\r\\n'\n))  \n\nelse\n:\n    \nbreak\n\nkeyword = Cmd_out.find(\n'来自'\n)  \n# 行是否有关键字‘来自’\n\n\nif\n keyword != -\n1\n:\n    Cmd_out = \n'\\b'\n\n\n\nprint\n(Cmd_out)\n\n\n\n输出结果：\n正在 Ping baidu.com [220.181.38.148] 具有 32 字节的数据:\n\n\n220.181.38.148 的 Ping 统计信息:\n数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，\n往返行程的估计时间(以毫秒为单位):\n最短 = 56ms，最长 = 57ms，平均 = 56ms\n\n\n中间有几行空行，怎样才能把输出的空行删除，连续输出\n\n\n只删除空行，其他格式保持不变", "Tag": "算法分析"}
{"Answer": "如果不考虑线程的复用性，直接做个ThreadGroup就能很容易做个循环判断出来线程是否执行完了\r\nThreadPoolExecutor 主要是考虑线程的复用", "Konwledge_Point": "负权边的最短路径", "Question": "主线程 如果判断 N个子线程都执行完了？\n需求：一个方法（主线程）开启了N个子线程，每个子线程去执行各自的任务，且执行的时间不一样，现在主线程需要将所有子线程执行完后的结果进行处理，并返回。\n\n    那如果判断所有的子线程都执行完了呢？\n\n    目前我的做法是：\n\n\n\n            TestThread t2= new TestThread();\n    TestThread t3= new TestThread();\n    TestThread t1= new TestThread();\n    System.out.println(\"start...\");\n    t1.start();\n    t2.start();\n    t3.start();\n    try{\n        t1.join();\n        t2.join();\n        t3.join();\n\n                  //此处得到t1，t2,t3,的执行结果，\n                  //返回处理后的最终结果。\n\n    }catch(Exception e){\n\n    }\n\n    System.out.println(\"end!!!\");\n\n现在，我是不知道这样处理性能上好不好， 因为调用这个是很需要性能好， 希望时间上最短好越好，因为可能调用的比较频繁，调用者需要将结果返回页面的。 \n 求大家给一个好的解决方法或是思路。\n 谢谢！！！\n", "Tag": "算法分析"}
{"Answer": "请问要代码还是思路", "Konwledge_Point": "负权边的最短路径", "Question": "一道搜索题，始终做不对\n传球游戏\n\n\n题目背景\n\n\n终于下课了，小A都等不及了。今天小A和他的朋友们在操场上玩着传球游戏。\n\n\n题目描述\n\n\n这些同学排成n排，每一排人数不等。一些同学穿着红衣服，一些同学穿着蓝衣服，不同颜色队服的同学可以互相传球(A为红色队服，B为蓝色队服），相同队服颜色的同学不能互相传球，传球的时候，只有排数相邻且坐标差距相邻（如第一排球员坐标为2，则可以传给第二排坐标为1,2,3的队员）的队员之间可以传球（每排的队员队服颜色可能不同），每排之间的间距为x[i]，每排有y[i]个球员。小A在第一排，小B在第n排，小A需要通过他的同学将球传给小B，可以往前传，也可以往后传（顺序可以为1-2-1），求出小A能否把球传给小B，如果可以求出最短距离。（本题有多组数据）\n\n\n输入格式\n\n\n第1行输入m，表示有m组数据；\n\n\n每组数据第1行输入n,代表有n排；\n\n\n每组数据第2行输入x[i],共n-1个数字，空格隔开，表示每排间距；\n\n\n接下来2n行，第一行输入y[i],表示每排人数，第二行输入y[i]个字符，表示每个队员的队服颜色，从上到下，\"R\"表示红色，\"B\"表示蓝色。\n\n\n接下来一行，两个数，表示A点和B点在所在排数中的坐标(每一排的坐标默认从上往下，从1开始）。\n\n\n输出格式\n\n\n每组数据都要输出，如果小A可以把球传给小B，输出\"Yes\"后紧跟\":\",在冒号后面输出最短距离；\n\n\n如果不能，则输出\"No\"。\n\n\n每组数据换行符隔开。\n\n\n样例 #1\n\n\n样例输入 #1\n\n\n2\n\n\n4\n\n\n1\n \n1\n \n1\n\n\n3\n\n\nB\n R \nB\n\n\n4\n\nR \nB\n R R\n\n2\n\nR \nB\n\n\n1\n\n\nB\n\n\n2\n \n1\n\n\n4\n\n\n2\n \n3\n \n1\n\n\n4\n\nR \nB\n R \nB\n\n\n5\n\n\nB\n \nB\n \nB\n \nB\n \nB\n\n\n5\n\nR \nB\n \nB\n \nB\n \nB\n\n\n1\n\nR\n\n3\n \n1\n\n\n\n\n样例输出 #1\n\n\nYes\n:\n3\n\n\nYes\n:\n10\n\n\n\n\n样例 #2\n\n\n样例输入 #2\n\n\n3\n\n\n3\n\n\n2\n \n2\n \n\n2\n\n\nB\n \nB\n\n\n3\n \n\nB\n \nB\n \nB\n\n\n1\n\n\nB\n\n\n1\n \n1\n\n\n4\n\n\n5\n \n5\n \n5\n\n\n4\n\nR R R R\n\n4\n \n\nB\n \nB\n \nB\n \nB\n\n\n4\n\nR R R R\n\n4\n\n\nB\n \nB\n \nB\n \nB\n\n\n1\n \n1\n\n\n4\n\n\n2\n \n2\n \n2\n\n\n3\n\n\nB\n R \nB\n\n\n4\n\nR \nB\n \nB\n R\n\n5\n\n\nB\n \nB\n \nB\n \nB\n R\n\n1\n\nR\n\n2\n \n1\n\n\n\n\n样例输出 #2\n\n\nNo\n\n\nYes\n:\n15\n\n\nNo\n\n\n\n\n提示\n\n\n样例解释：见附件\n\n\n数据范围：1≤m≤100,1≤n≤1000,1≤x[i]≤100,1≤y[i]≤5000。\n\n\n此题我自己出的，思路用广搜做，RE了，不知道怎么做", "Tag": "算法分析"}
{"Answer": "AcWing y总题解\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nconst int N = 2e5 + 10;\nint n,k;\nint q[N];\nint dist[N];\n\nint bfs()\n{\n    memset(dist, -1, sizeof(dist));\n    dist[n] = 0;\n    q[0] = n;\n    int hh = 0, tt = 0;\n    while(hh <= tt)\n    {\n        int t = q[hh++];\n        if(t == k) return dist[k];\n        if(t + 1 < N && dist[t + 1] == -1)\n        {\n            dist[t + 1] = dist[t] + 1;\n            q[++tt] = t + 1;\n        }\n        if(t - 1 >= 0 && dist[t - 1] == -1)\n        {\n            dist[t - 1] = dist[t] + 1;\n            q[++tt] = t - 1;\n        }\n        if(t * 2 < N && dist[t * 2] == -1)\n        {\n            dist[t * 2] = dist[t] + 1;\n            q[++tt] = t * 2;\n        }\n    }\n    return -1;\n}\n\nint main()\n{   \n    cin>>n>>k;\n    cout<<bfs()<<endl;\n    return 0;\n}\n", "Konwledge_Point": "负权边的最短路径", "Question": "我不知道怎么判断哪个更近，如下\n抓住那头牛\n背景\n农夫知道一头牛的位置，想要抓住它。\n\n\n题目描述\n农夫和牛都位于数轴上，农夫起始位于点 N(0≤N≤100000)，牛位于点 K(0≤K≤100000)。农夫有两种移动方式：\n\n\n1.从 X 移动到 X−1 或 X+1，每次移动花费1分钟\n\n\n2.从 X 移动到  2∗X ，每次移动花费1分钟\n\n\n假设牛没有意识到农夫的行动，站在原地不动。农夫最少要花多少时间才能抓住牛?\n\n\n编写程序计算最短需要花费的时间。\n\n\n输入格式\n两个整数，N和K\n\n\n输出格式\n一个整数，表示农夫抓到牛所需要花费的最小分钟数\n\n\n样例输入\n5 17\n样例输出\n4\n样例解释\n5->10->9->18->17\n\n\nusing\n \nnamespace\n std;\n                \n\nint\n \nmain\n()\n{\n    \nint\n n,k,g=\n0\n;\n    cin >> n >> k;\n    \nif\n(n>=k){\n        cout << n-k;\n    }\nelse\n{\n        \nfor\n(\nint\n i=\n1\n;i<=\n10000000\n;i++){\n            \nif\n(n=k){\n                \nbreak\n;\n            }\nelse\n{\n                 ______?________\n            }\n        }\n    }\n    \nreturn\n \n0\n;\n} \n", "Tag": "算法分析"}
{"Answer": "回答：结果出来了，修改了前面的i部分，截图如下：\n\n#include<stdio.h>\n\nint main()\n{\n    int a, b, c, d;\n    int h = 0, M = 0;\n    scanf(\"%d %d %d %d\", &a, &b, &c, &d);\n    \n    if (a > c) {\n        h = 24 + c - a;\n    }    \n    else if (a < c) {\n        h = c - a;\n    }    \n    else if (a = c) {\n        if (d < b) {\n            h = 24;\n        }\n        else {\n            h = 0;\n        }\n    }\n    \n    int m = d - b;\n    \n    if (m < 0) {\n        M = m + 60;\n        h = h - 1;\n    }\n    else {\n        M = m;\n    }\n    \n    printf(\"O JOGO DUROU %d HORA(S) E %d MINUTO(S)\", h, M);\n    return 0;\n}\n\n\n", "Konwledge_Point": "负权边的最短路径", "Question": "为什么感觉代码没错，却结果不对？\n问题：读取四个整数 A,B,C,D，用来表示游戏的开始时间和结束时间。\n           其中 A 和 B 为开始时刻的小时和分钟数，C 和 D 为结束时刻的小时和分钟数。\n           请你计算游戏的持续时间。\n           比赛最短持续 1 分钟，最长持续 24 小时。\n          输入格式\n          共一行，包含四个整数 A,B,C,D。\n          输出格式\n          O JOGO DUROU X HORA(S) E Y MINUTO(S)，表示游戏共持续了 X 小时 Y 分钟。\n代码：\n\n\n#include\n\nint main()\n{\n    int a,b,c,d;\n    int \nh\n=0,M=0;\n    scanf(\n\"%d %d %d %d\"\n,&a,&b,&c,&d);\n    \nif\n(a>c){\n      \nh\n=24+c-a;  \n    }\n    \nif\n(a<c){\n      \nh\n=c-a;\n    }\n    \nif\n(\na\n=c){\n        \nif\n(d<b){\n            \nh\n=24;\n        }\nelse\n{\n            \nh\n=0;\n        }\n    }\n    int \nm\n=d-b;\n    \nif\n(m<0){\n      \nM\n=m+60;\n      \nh\n=h-1;\n    }\nelse\n{\n      \nM\n=m;\n    }\n    \n    printf(\n\"O JOGO DUROU %d HORA(S) E %d MINUTO(S)\"\n,h,M);\n    return 0;\n}\n\n\n", "Tag": "算法分析"}
{"Answer": "#include<bits/stdc++.h>\nusing namespace std;\nint lcm(int x,int y)\n{\n     if(x*y==0)\n        return 0;\n      int max = a > b ? a : b ;\n      while(1)\n      {\n          if(max%a==0 && max%b==0)\n              break;\n          max--;\n      }\n      return max;\n}\nint main(){\n      int a,b,h;\n      cin>>a>>b>>h;\n      cout<<lcm(lcm(a,b),h);\n      return 0;\n}\n\n", "Konwledge_Point": "负权边的最短路径", "Question": "JZOJ：：【WJOI】TT的立方体\n题目描述\n  在积木星球上，所有的楼房都是活的。积木星球的国王TT是世界上最伟大的建筑师。也只有他，才配得上做积木星球的国王。积木星球上全都是散落的巨大积木，这是天然的好建筑材料，TT拥有最聪明的头脑和最灵巧的双手。他搭建起尖顶红砖的房子，搭建起300层高的房子，搭建起五角星形的房子，搭建起水晶般透明的房子。\n  有一天，TT想利用的无数块长宽高分别为a,b,h的长方体积木，搭建一个正方体，当然中间不能有缝隙，要不然就不牢固了。他的问题是，搭出的正方体棱长最少是多少？\n输入\n三个整数：a, b, h。\n输出\n一个整数：正方体最短的棱长，数据保证答案<263。\n样例\n输入  复制\n3 2 4\n输出  复制\n12\n提示\n样例解释：\n所有的积木长是3，宽是2，高是4。可以一排摆4个，摆6排，摆3层，这样搭出的正方体棱长是12。\n数据范围：\n40%的数据：1<=a,b,h<=200。\n100%的数据：1<=a,b,h<=2*109。 ", "Tag": "算法分析"}
{"Answer": "你题目的解答代码如下：\n/^([+\\-_\\(\\)\\{\\}\\s\\.,]*\\d){7,15}[+\\-_\\(\\)\\{\\}\\s\\.,]*$/.test(str)\n\n还需要什么其他分隔符可以自己加在[]中\n\n如有帮助，请点击我的回答下方的【采纳该答案】按钮帮忙采纳下，谢谢!\n", "Konwledge_Point": "负权边的最短路径", "Question": "识别号码的正则表达式，求帮助\n问题遇到的现象和发生背景\n\n\n谷歌搜索，从描述和标题找电话号码\n传整个描述的字符串进去，通过正则表达式，把各种类型的号码找出来\n\n\n号码规则：\n程序需要识别全球电话和号码，长度7-15位数字【最短加拿大的7位数字，最长的15位数字008613925553088，中间有空格.等括号-_*等分隔符号各种（比例0086.139.2555.308.8）】\n\n\n支持以下样例方式:\n07.08.711.08.39  号码之间任意加.或者其他分隔符\n86-010-40020020\n+86.139.2555.3088\n010-40020020\n010-400 200 20 各种空格分开）\n0 8 0 0 9 7 0 0 0 0 1 0\n1 (205) 3191273.\n0809(955) (5577)\n0708.711.0839\n1(213)761-5248\n1(213) 444-6481}\n1(213) 444-6481}\n44 7770 192847.\n86-10-13523458056,\n086-13523458056\n0086-13523458056 ，\n10-13523458056 ，\n13523458056\n+1(949)228-9436\n\n\n\n\n操作环境、软件版本等信息\n\n\nC#网络调用\n\n\n尝试过的解决方法\n\n\n网上下载了感觉不满足需求\n\n\n我想要达到的结果\n\n\n需要写成对应的正则表达式，输入整个谷歌搜索的描述字符，能把号码匹配找出来\n例如\nFace mask for sale WhatsApp +1(949)228-9436. Watch later. Share. Copy link. Info. Shopping. Tap to unmute. If playback\n\n", "Tag": "算法分析"}
{"Answer": "看看是不是挂了代理服务器，或者修改了hosts，或者你的dns服务器有屏蔽。", "Konwledge_Point": "负权边的最短路径", "Question": "Why does the *.github.io pointed to 127.0.0.1?\n最近当我访问github page个人博客时，好像出现了问题，当我使用ping工具查找ip时，发现它指向了127.0.0.1。\n\n\n\nvisit error info:\n\n\n\n无法访问此网站\nyansheng836.github.io 拒绝了我们的连接请求。\n请试试以下办法：\n\n检查网络连接\n检查代理服务器和防火墙\nERR_CONNECTION_REFUSED\n\n\n\n\n\nping info:\n\n\n\nC:\\>ping yansheng836.github.io\n\n正在 Ping yansheng836.github.io [127.0.0.1] 具有 32 字节的数据:\n来自 127.0.0.1 的回复: 字节=32 时间<1ms TTL=64\n来自 127.0.0.1 的回复: 字节=32 时间<1ms TTL=64\n来自 127.0.0.1 的回复: 字节=32 时间<1ms TTL=64\n来自 127.0.0.1 的回复: 字节=32 时间<1ms TTL=64\n\n127.0.0.1 的 Ping 统计信息:\n    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，\n往返行程的估计时间(以毫秒为单位):\n    最短 = 0ms，最长 = 0ms，平均 = 0ms\n\n\n\n\n这个情况是最近才出现的（我最近重装了一次Windows系统，不知道是否和这个情况有关），起初在逛github时，访问别人的博客会失败。一开始我以为是个人情况，但是今天我尝试了好几个博客，发现都是如此，我意识到这可能是一个比较普遍的问题。然而我并没有在搜索网站找到合适的解决办法，于是我想请教大家该如何解决这个问题？先行谢过！", "Tag": "算法分析"}
{"Answer": "该回答引用GPTᴼᴾᴱᴺᴬᴵ在你的代码中，有几个问题：\n函数返回类型应该是字符串类型，而不是整型0。当出现不匹配的情况时，应该立即返回公共前缀，而不是输出当前已经找到的公共前缀并继续循环。在第二个循环内，每次循环结束后，计数器c应该被重置为0，以确保正确计算每个字符的匹配情况。\n-以下是修改后的代码：\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string pub = \"\";\n        int size = strs.size();\n        int smix = 100;\n        for(int m = 0; m < size; m++) {\n            if(smix > strs[m].size())\n                smix = strs[m].size();\n        }\n        int i, c;\n        for(int t = 0; t < smix; t++) {\n            c = 0;\n            for(i = 0; i < size-1; i++) {\n                if(strs[i][t] == strs[i+1][t])\n                    c++;\n                else\n                    break;\n            }\n            if(c == i-1)\n                pub.push_back(strs[0][t]);\n            else\n                return pub;\n        }\n        return pub;\n    }\n};\n\n在这个修改后的代码中，我们使用return pub来立即返回公共前缀，而不是使用std::cout输出当前找到的公共前缀并继续循环。", "Konwledge_Point": "负权边的最短路径", "Question": "查找字符串数组中的最长公共前缀\n题目是：编写一个函数来查找字符串数组中的最长公共前缀。\n如果不存在公共前缀，返回空字符串 \"\"。\n\n\n我的解决思路是\n先用变量smix取得最短字符串长度\n双重循环 不断将字符压入到一个空字符串中\n\n\n现在报错：\nLine 522: Char 69: runtime error: applying non-zero offset 18446744073709551615 to null pointer (basic_string.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:531:69\n\n\nclass Solution {\npublic:\n    \nstring\n longestCommonPrefix(\nvector\n<\nstring\n>& strs) {\n    \nstring\n pub = \n\"\"\n;\n    \nint\n \nsize\n = strs.\nsize\n();\n    \nint\n smix = \n100\n;\n    \nfor\n(\nint\n m = \n0\n;m<\nsize\n;m++){\n        \nif\n(smix>strs[m].\nsize\n())\n        smix = strs[m].\nsize\n();\n    }\n    \nint\n c = \n0\n;\n    \nint\n i;\n    \nfor\n(\nint\n t = \n0\n;t<smix;t++){\n    \nfor\n(i = \n0\n;i<\nsize\n-1\n;i++){\n        \nif\n(strs[i][t]==strs[i+\n1\n][t])\n        c++;\n    }\n    \nif\n(c==i\n-1\n)\n    pub.push_back(strs[\n0\n][t]);\n    \nelse\n{\n        std::cout<<pub<<std::endl;\n    }\n    }\n    \nreturn\n \n0\n;\n    }\n    \n};\n\n", "Tag": "算法分析"}
{"Answer": "你改变a的类型了\nimport math\n\na = {0: (-37.4168610028693, 145.005372256037),\n     1: (-37.7032933463858, 144.572524145218),\n     2: (-37.7292612709136, 144.650631483984),\n     3: (-37.7777637471456, 144.772303608804),\n     4: (-37.5792063872414, 144.72816450831)}\n\n\ndef get_min_dis2(data: dict, b: tuple):\n    min_dist = float('inf')\n    for k in data.keys():\n        lat1, lon1 = data[k]\n        lat2, lon2 = b\n        dlat = math.radians(lat2 - lat1)\n        dlon = math.radians(lon2 - lon1)\n        a = (math.sin(dlat / 2) * math.sin(dlat / 2) + math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) *\n             math.sin(dlon / 2) * math.sin(dlon / 2))\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = c * 6378\n        if distance < min_dist:\n            min_dist = distance\n            key = k\n    return (key, b, min_dist)\n\n\nprint(get_min_dis2(a, (1, 1)))\n", "Konwledge_Point": "负权边的最短路径", "Question": "关于函数type error的问题\n有一个字典a\na = {0: (-37.4168610028693, 145.005372256037),\n 1: (-37.7032933463858, 144.572524145218),\n 2: (-37.7292612709136, 144.650631483984),\n 3: (-37.7777637471456, 144.772303608804),\n 4: (-37.5792063872414, 144.72816450831)}\n\n\n我想写一个函数来计算某个点到a字典中所有点的haversine距离并且返回最短距离和字典的key，我的代码如下：\n\n\ndef get_min_dis2(\na\n:dict,b:tuple):\n    min_dist = \n10000\n\n    \nfor\n k \nin\n \na\n.\nkeys\n():\n        lat1, lon1 = \na\n[k]\n        lat2, lon2 = b\n        dlat = math.radians(lat2-lat1)\n        dlon = math.radians(lon2-lon1)\n        \na\n = (math.\nsin\n(dlat / \n2\n) * math.\nsin\n(dlat / \n2\n) + math.\ncos\n(math.radians(lat1)) * math.\ncos\n(math.radians(lat2))*\n            math.\nsin\n(dlon / \n2\n) * math.\nsin\n(dlon / \n2\n))\n        c = \n2\n * math.\natan2\n(math.\nsqrt\n(\na\n), math.\nsqrt\n(\n1\n-\na\n))\n        distance = c * \n6378\n\n        \nif\n distance < min_dist:\n            min_dist = distance\n            key = k\n    \nreturn\n (key,b,min_dist)\n\n\n\n\nget_min_dis2(a,(-37.8438,145.0303))\n但是我运行时会一直报错TypeError: 'float' object is not subscriptable\n请问要如何解决呢", "Tag": "算法分析"}
{"Answer": "\n#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\nint x1, y1;\nint x2, y2;\nint n, m;\nint MIN = 0x7f7f7f7f;\nint G[15][15];\nint A[15][15];\nint HP = 6;\nint dir[4][2] = {1, 0, -1, 0, 0, 1, 0, -1};\nvoid dfs(int x, int y, int hp, int ANS) {\n    if (hp <= 0) {\n        return ;\n    }\n    if (G[x][y] == 3) {\n        MIN = min(MIN, ANS);\n        return ;\n    }\n    if (G[x][y] == 4) {\n        hp = 6;\n    }\n    ANS++;\n    for (int i = 0; i < 4; i++) {\n        int tx = x + dir[i][0];\n        int ty = y + dir[i][1];\n        if (G[tx][ty] != 0 && A[tx][ty] <= 1 && tx >= 1 && tx <= n && ty >= 1 && ty <= m) {\n            A[tx][ty]++;\n            dfs(tx, ty, hp - 1, ANS);\n            A[tx][ty]--; \n        }\n    }\n}\nint main() {\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            cin >> G[i][j];\n            if (G[i][j] == 0) {\n                A[i][j] = false;\n            }\n            if (G[i][j] == 2) {\n                x1 = i;\n                y1 = j;\n            }\n            if (G[i][j] == 3) {\n                x2 = i;\n                y2 = j;\n            }\n        }\n    }\n    dfs(x1, y1, HP, 0);\n    if(MIN == 0x7f7f7f7f) MIN = -1;\n    cout << MIN << endl;\n    return 0;\n}\n", "Konwledge_Point": "负权边的最短路径", "Question": "这道题哪里错了？（C++）\n题目描述\n小\nH\n在一个划分成了n*m个方格的长方形封锁线上。 每次他能向上下左右四个方向移动一格（当然小\nH\n不可以静止不动）， 但不能离开封锁线，否则就被打死了。 刚开始时他有满血\n6\n点，每移动一格他要消耗\n1\n点血量。一旦小\nH\n的 血量降到 \n0\n， 他将死去。 他可以沿路通过拾取鼠标（什么鬼。。。）来补满血量。只要他走到有鼠标的格子，他不需要任何时间即可拾取。格子上的鼠标可以瞬间补满，所以每次经过这个格子都有鼠标。就算到了某个有鼠标的格子才死去， 他也不能通过拾取鼠标补满 HP。 即使在家门口死去， 他也不能算完成任务回到家中。\n\n地图上有 \n5\n 种格子：\n\n数字 \n0\n： 障碍物。\n\n数字 \n1\n： 空地， 小\nH\n可以自由行走。\n\n数字 \n2\n： 小\nH\n出发点， 也是一片空地。\n\n数字 \n3\n： 小\nH\n的家。\n\n数字 \n4\n： 有鼠标在上面的空地。\n\n小\nH\n能否安全回家？如果能， 最短需要多长时间呢？\n\n输入格式\n第一行两个整数n,m， 表示地图的大小为n*m。\n\n下面 n 行， 每行 m 个数字来描述地图。\n\n输出格式\n一行， 若小\nH\n不能回家， 输出\n-1\n,否则输出他回家所需最短时间。\n\n输入输出样例\n输入 \n#1复制\n\n\n3\n \n3\n\n\n2\n \n1\n \n1\n\n\n1\n \n1\n \n0\n\n\n1\n \n1\n \n3\n\n输出 \n#1复制\n\n\n4\n\n说明/提示\n\n1\n<=n,m<=\n9\n\n\n\n\n\n\n#include \n\n\n#include \n\n\nusing\n namespace std;\n\nint\n x1, y1;\n\nint\n x2, y2;\n\nint\n n, m;\n\nint\n min = \n0x7f7f7f7f\n;\n\nint\n G[\n15\n][\n15\n];\n\nbool\n A[\n15\n][\n15\n];\n\nint\n HP = \n6\n;\n\nint\n ans = \n0\n;\n\nint\n dir[\n4\n][\n2\n] = {\n1\n, \n0\n, \n-1\n, \n0\n, \n0\n, \n1\n, \n0\n, \n-1\n};\n\nint\n dfs(\nint\n x, \nint\n y, \nint\n hp, \nint\n ANS) {\n    hp\n--;\n\n    \nif\n (hp <= \n0\n) {\n        \nreturn\n \n-1\n;\n    }\n    \nif\n (G[x][y] == \n3\n) {\n        \nreturn\n ans;\n    }\n    \nif\n (G[x][y] == \n4\n) {\n        hp = \n6\n;\n    }\n    ans++;\n    \nfor\n (\nint\n i = \n0\n; i < \n4\n; i++) {\n        \nint\n tx = x + dir[i][\n0\n];\n        \nint\n ty = y + dir[i][\n1\n];\n        \nif\n (A[tx][ty] == \ntrue\n && tx >= \n1\n && tx <= n && ty >= \n1\n && ty <= m) {\n            A[tx][ty] = \nfalse\n;\n            dfs(tx, ty, hp, ans);\n            A[tx][ty] = \ntrue\n; \n        }\n    }\n}\n\nint\n main() {\n    memset(A, \ntrue\n, sizeof(A));\n    cin >> n >> m;\n    \nfor\n (\nint\n i = \n1\n; i <= n; i++) {\n        \nfor\n (\nint\n j = \n1\n; j <= m; j++) {\n            cin >> G[i][j];\n            \nif\n (G[i][j] == \n0\n) {\n                A[i][j] = \nfalse\n;\n            }\n            \nif\n (G[i][j] == \n2\n) {\n                x1 = i;\n                x2 = j;\n            }\n            \nif\n (G[i][j] == \n3\n) {\n                x2 = i;\n                x2 = j;\n            }\n        }\n    }\n    cout << dfs(x1, y1, HP, ans) << endl;\n    \nreturn\n \n0\n;\n}\n\n\n\n为什么样例输出是4，而我的是3", "Tag": "算法分析"}
{"Answer": "\n面试笔试算法之排列组合与搜索走地图问题_gjpzl的博客-CSDN博客\n排列组合与搜索走地图问题Oj-235.递归实现指数型枚举题目描述从 1−n 这 n 个整数中随机选取任意多个，每种方案里的数从小到大排列，按字典序输出所有可能的选择方案。输入输入一个整数 n。（1≤n≤10）输出每行一组方案，每组方案中两个数之间用空格分隔。注意每行最后一个数后没有空格。样例输入3样例输出11 21 2 31 322 33样例输入24样例输出211 21 2 31 2 3 41 2 41 31 3 41 422 32\n\n\n\nhttps://blog.csdn.net/gjpzl/article/details/110671145\n\n看这个", "Konwledge_Point": "负权边的最短路径", "Question": "C++编程题目，龙&虫 改了好几遍还是不对\n有一道题不太明白，关于C++联系题，在刷题的时候改了好几次都没有改对，希望大家帮帮我,有没有一些代码的思路或者想法，伪代码也可以，内容中没有办法打出英文的大写哦，所以用了0代替\n\n\n龙&虫\n时间限制：1秒        内存限制：128M\n题目描述\n给出一张NxM的地图，在地图上有一只虫，样子却很像龙，而且嘴能快速的喷出一种毒液，瞬间杀死敌人 \n\n\n现在假设虫的初始位置在（X1,Y1），另外在（X2,Y2）处有一个敌人。假设虫移动一步需要单位1的时间，而杀死敌人不需要时间，并且虫的毒液射程无穷大，但毒液不能穿透阻碍物，虫只能攻击上下左右、左上、右上、左下、右下八个方向 请求出虫最少需要用多少时间才能消灭敌人\n\n\n输入描述\n第一行两个数N和M，表示矩阵的规模 \n\n\n接下来是NxM的矩阵，0代表空地，X代表障碍物 \n\n\n下面是若干行数据，每行为一对数据，分别是敌人的位置和虫的位置。显然，敌人和虫都不可能在障碍物上 \n\n\n以“0 0 0 0”为输入结束标志\n\n\n输出描述\n输出第一行为虫能消灭掉敌人的最短时间 \n\n\n显然，若能直接打到敌人，则时间为0，若无法消灭，则第二行再输出“Impossible”\n\n\n\n\n样例\n输入\n3 3\n000\nXX0\n0X0\n2 3 3 1\n0 0 0 0\n输出\nImpossible!\n\n\n\n\n提示\n对于30%的数据：NXM<=5000 \n\n\n对于50%的数据：NXM<=10000 \n\n\n对于100%的数据：NXM<=20000", "Tag": "算法分析"}
{"Answer": "这个问题应该不难吧，这里给你说一下简单思路使用次数：用一个变量cnt计数，它输入一次，你就加一次。日期的读取可以用字符串，然后再将它转成数。转数时只需要转小时，分钟，秒。日期不用转。使用频率：根据使用次数算。最长时间：每次它输入后你都将使用时间算出来，然后和当前的最大时间比。最短时间：也是每次它输入后你都将使用时间算出来，然后和当前的最短时间比。平均时间：将每次你算出来的时间加在一起，最后除以使用次数。先给你一个简单的思路，你自己想想，如果还有什么地方不明白，我再告诉你", "Konwledge_Point": "负权边的最短路径", "Question": "c++ 初级 ，我该怎么做，🙏🙏\nstart: 2021-03-03 09:00:00, stop: 2021-03-03 21:51:38\nstart: 2021-03-03 22:51:38, stop: 2021-03-04 02:10:44\nstart: 2021-03-04 03:10:44, stop: 2021-03-04 15:15:41\nstart: 2021-03-04 16:15:41, stop: 2021-03-05 03:37:11\nstart: 2021-03-05 04:37:11, stop: 2021-03-05 13:43:33\nstart: 2021-03-05 14:43:33, stop: 2021-03-05 22:04:12\nstart: 2021-03-05 23:04:12, stop: 2021-03-06 11:02:25\nstart: 2021-03-06 12:02:25, stop: 2021-03-06 21:32:53\nstart: 2021-03-06 22:32:53, stop: 2021-03-07 07:48:56\nstart: 2021-03-07 08:48:56, stop: 2021-03-07 18:46:56\nstart: 2021-03-07 19:46:56, stop: 2021-03-07 22:33:49\nstart: 2021-03-07 23:33:49, stop: 2021-03-08 07:19:41\nstart: 2021-03-08 08:19:41, stop: 2021-03-08 19:59:41\nstart: 2021-03-08 20:59:41, stop: 2021-03-09 07:31: \n\n\n这是打印机这个月的使用次数，时间跟日期，如何读取，并输出，这台打印机的这个月的使用频率，最长时间，最短时间，跟平均时间", "Tag": "算法分析"}
{"Answer": "这个问题想了很久 ,像是递归,又有一些差别\r\n分析一下如何过河吧,得出一个结论就是 ,数值最小的两个需要当勤劳的搬运工\r\n1,2,5,10\r\n不计手电的情况 ,就是  10,5   和 2,1,总计 12 ,\r\n但是需要手电,在上述过程中先是 1 搬运一次 然后是2 搬运一次 ,由于搬运产生的额外开销 1,2 加2\r\n也就是 12+1+2+2\r\n分析1,2,3,5,10,\r\n不计手电的情况 就是 10,5 和3,2 和 1 总计14\r\n但是需要手电,在上述过程中先是 1 搬运一次 +1然后是2 搬运一次+2 ,由于搬运产生的额外开销 1,2 加2  ,然后 1又开始搬运  +1 \r\n14+1+2+2+1\r\n分析1,2,3,5,7,10\r\n不计手电的情况 就是10,7 和 5,3  和 2,1总计17\r\n但是需要手电,在上述过程中先是 1 搬运一次+1 然后是2 搬运一次+2 ,由于搬运产生的额外开销 1,2 加2  ,然后 1又开始搬运  +1 ,然后 2搬运一次+2 额外开销2 \r\n17+1+2+2+1+2+2\r\n然后就找出规程了,搬运一次+1 搬运第二次加4 ,第三次 加1 第四次加2  \r\n搬运的次数为 数组长度-2  \r\n接下来上代码 .....不必要了\r\n就是先总结次数,然后加起来就可以了,", "Konwledge_Point": "负权边的最短路径", "Question": "2017完美世界研发部笔试题_取经\n一、题目概述\n\n\n\n师徒四人西天取经，途中必需跨过一座桥，四个人从桥的同一端出发，你得帮助他们到达另一端，天色很暗而他们只有一支手电筒，一次同时最多可以有两个人一起经过桥。而过桥的时候必须持有手电筒，所以就得有人把手电筒带来带去，来回桥两端。手电筒不能用丢的方式来传递，四个人的步行速度各不同，若两人同行则以较慢者的速度为准，大师兄需花1分钟过桥，二师兄需花2分钟过桥，三师兄需花5分钟过桥，师傅需花10分钟过桥。请问他们最短在多少分钟内过桥？（）\n\nA. 18\n\nB. 17\n\nC. 19\n\nD. 16\n\n\n\n一开始直接想到，用最小的那个数来回跑，也就是大师兄来回跑，算出来是19，可是又想了下，如下： \n\n1、大师兄和二师兄过桥，算二师兄的时间也就是2分钟 \n\n2、大师兄独自拿手电回来 1分钟 \n\n3、三师弟和师傅那手电过桥，算师傅的时间也就是10分钟 \n\n4、二师弟拿手电回来 2分钟 \n\n5、最后大师兄和二师弟过桥 2分钟 \n\n总共17分钟\n\n\n\n虽然结果出来了，感觉有点不实在，这其中的规律是怎样的呢？有没有什么规律解决这类似的问题呢，比如只有三个人过桥呢？二师兄不过桥，结果又是什么呢？再比如，多一个人过桥呢？多了个白龙马过桥，白龙马过桥的时间时6分钟，结果又是什么呢？有没有什么规律呢，或者说有没有个公式来计算呢？用编程怎么解？\n\n\n\n具体看链接：\nhttp://blog.csdn.net/Two_Water/article/details/52590899", "Tag": "算法分析"}
{"Answer": "忘记初始化了\n\n\n        min = 201;\n        scanf(\"%d\",&k);\n        num = 0;\n        \n", "Konwledge_Point": "负权边的最短路径", "Question": "共同的前缀，给你K个字符串，请求出它们的最长公共前缀。 输入 第一行是一个整数N，表示测试样例的个数。\nDescription\n给你K个字符串，请求出它们的最长公共前缀。 输入 第一行是一个整数N，表示测试样例的个数。 每个测试样例的第一行是一个整数K（2 <= k <= 20），表示有多少个字符串；以后每行是一个字符串，每个字符串的长度不超过200个字符。 输出 每行输出一个样例的结果。先输出“Case #: ”，其中’#’为样例的序号（从1开始），冒号为英文冒号，后接一个空格；然后是对应样例的结果。如果没有公共前缀，则无需输出前缀，但Case信息仍需要输出。\n\n\nSample Input\n2\n3\nACD\nACDEF\nACDFE\n2\nABC\nBCD\n\n\nSample Output\nCase 1: ACD\nCase 2:\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\nint\n \nmain\n()\n \n\n{\n    \nint\n n,k,i,min = \n201\n,j,temp,x = \n1\n,num;\n    \nchar\n str[\n22\n][\n202\n];\n    \nscanf\n(\n\"%d\"\n,&n);\n    \nwhile\n(n--)\n    {\n        \nscanf\n(\n\"%d\"\n,&k);\n        num = \n0\n;\n        \nfor\n(i = \n0\n;i < k;i++)\n        {\n            \nscanf\n(\n\"%s\"\n,str[i]);\n        }\n        \nprintf\n(\n\"Case %d: \"\n,x);\n        x++;\n        \nfor\n(i=\n0\n;i<k;i++)\n        {\n               temp = \nstrlen\n(str[i]);\n               \nif\n(temp < min)\n            {\n                min = temp;\n//min为最短字符串的长度\n\n            }\n        }\n        \nfor\n(j = \n0\n;j < min;j++)\n        {\n            \nfor\n(i = \n0\n;i < k - \n1\n;i++)\n            {\n                \nif\n(str[i][j]==str[i+\n1\n][j])\n                {\n                    \ncontinue\n;\n                } \n                \nelse\n\n                {\n                    num = \n1\n;\n                    \nbreak\n;\n                }\n            }\n            \nif\n(num!=\n1\n)\n            {\n                   \nprintf\n(\n\"%c\"\n,str[\n0\n][j]);\n            }\n        }\n        \nprintf\n(\n\"\\n\"\n);\n    }\n    \nreturn\n \n0\n;\n}\n \n\n\n\n\nWA", "Tag": "算法分析"}
{"Answer": "我是C菜鸡，首先看这个是堆栈信息，应该是if(s[m]==s[m+j])，m+j越界了。第二，刚开始学算法，还是多看看题解，没必要自己解，有很多惯用的算法，理解之后在遇到能想到，就是你的东西。从头研究算法，意义不大，我们都是普通人，太费时间，会打击积极性。当然不只有题解才是对的，你的思路解不出来，再看题解也很合理。题解看懂，在分析一下你的代码，是超时间限制了，还是边界判断的有问题。报错信息，如果分析不对，就得C大佬看看了", "Konwledge_Point": "负权边的最短路径", "Question": "力扣第三题：无重复字符的最长子串 想知道哪里出错？\n问题遇到的现象和发生背景\n\n\n力扣第三题：无重复字符的最长子串 求问哪里出错？\n\n\n\n\n问题相关代码，请勿粘贴截图\n\n\nint lengthOfLongestSubstring(char * s){\n    int i,j,m,n,k1,k2,k3=\n0\n;           \n//i\n为子串起始下标\n    \nfor\n(i=\n0\n;s[i+\n1\n]!=\n'0'\n;i++) \n//\n每个元素依次作为子串起始\n    {\n        \nfor\n(k2=\n0\n;s[k2]!=\n'0'\n;k2++);\n//\n使k2等于数组长度\n        \nfor\n(m=i;s[m+\n1\n]!=\n'0'\n,m<(k2+i);m++)\n//\n检验字符m，从首字符到已知最短长度（k2+i)或最后一位依次循环\n        {\n            \nfor\n(j=\n1\n,k1=(m-i+\n1\n);s[m+j]!=\n'0'\n;j++)\n            {\n                \nif\n(s[m]==s[m+j])\n                {\n                    \nbreak\n;\n                }\n                \nelse\n k1++;\n//\nk1保存不含有与检验字符m重复字符的子串长度\n            }\n            \nif\n(k1k3)\n        {\n            k3=k2;\n//\nk3保存不含有重复字符的最长子串的长度\n        }\n    }\n    return k3;\n}\n\n\n\n\n运行结果及报错内容\n\n\n\n\n我的解答思路和尝试过的方法\n\n\n①一串字符串 从头到尾每个元素依次作为子串的首元素。\n②判断以某位元素作为首元素的这个子串的长度，再次（在这个子串中）从头到尾每个元素依次循环，遇到相同的就返回。\n③同时记录当前长度，通过k三个变量记录长度来达到传递最终正确长度的效果\n\n\n我想要达到的结果\n\n\n虽然可能有更好的办法，但我还是想知道我的这个错在哪里，我无法相信我无法理解，我甚至自己举例子一步步试了，完全没有问题！！令人费解！", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/u011542204/article/details/47105911", "Konwledge_Point": "负权边的最短路径", "Question": "C程序输出题目所要求的序列，序列中每个元素一行。如果存在两个符合要求的序列\nProblem Description\n\n由于整日整夜地对着这个棋盘，Lele终于走火入魔。每天一睡觉，他就会梦到自己会被人被扔进一个棋盘中，一直找不到出路，然后从梦中惊醒。久而久之，Lele被搞得精神衰弱。梦境是否会成为现实，谁也说不准，不过不怕一万只怕万一。现在Lele每次看到一个棋盘，都会想象一下自己被关进去以后要如何逃生。\n\n\n\nLele碰到的棋盘都是正方形的，其中有些格子是坏的，不可以走，剩下的都是可以走的。只要一走到棋盘的边沿（最外面的一圈），就算已经逃脱了。Lele梦见自己一定会被扔在一个可以走的格子里，但是不确定具体是哪一个，所以他要做好被扔在任意一个格子的准备。\n\n\n\n现在Lele请你帮忙，对于任意一个棋盘，找出一个最短的序列，序列里可以包括\"north\"(地图里向上),\"east\"(地图里向右),\"south\"(地图里向下),\"west\"(地图里向左)，这四个方向命令。不论Lele被扔在棋盘里的哪个好的格子里，都能按这个序列行走逃出棋盘。\n\n逃脱的具体方法是：不论Lele被扔在哪里，Lele按照序列里的方向命令一个一个地走，每个命令走一格，如果走的时候会碰到坏的格子，则忽略这条命令。当然，如果已经逃脱了，就可以不考虑序列中剩下的命令了。\n\n\n\nInput\n\n本题目包含多组测试，请处理至文件结束。\n\n每组测试第一行包含一个正整数 N (0<N<9)，代表棋盘的大小是 N*N\n\n接下来有N行，每行N个字符代表这个棋盘。\n\n其中0代表该位置是好的，可以走，1代表该位置是坏的，不可以走。\n\n\n\n题目数据保证，对于任意一个棋盘，都存在题目中所要求的序列\n\n\n\nOutput\n\n对于每组数据，输出题目所要求的序列，序列中每个元素一行。\n\n如果存在两个符合要求的序列，请输出字典序最小的那个序列。\n\n\n\n两个测试之间请用一个空行隔开。\n\n\n\nSample Input\n\n4\n\n1101\n\n0001\n\n1100\n\n1001\n\n\n\nSample Output\n\neast\n\nnorth", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/acm_cxlove/article/details/7750207", "Konwledge_Point": "负权边的最短路径", "Question": "Escape from Tetris                  \nProblem Description\n\n由于整日整夜地对着这个棋盘，Lele终于走火入魔。每天一睡觉，他就会梦到自己会被人被扔进一个棋盘中，一直找不到出路，然后从梦中惊醒。久而久之，Lele被搞得精神衰弱。梦境是否会成为现实，谁也说不准，不过不怕一万只怕万一。现在Lele每次看到一个棋盘，都会想象一下自己被关进去以后要如何逃生。\n\n\n\nLele碰到的棋盘都是正方形的，其中有些格子是坏的，不可以走，剩下的都是可以走的。只要一走到棋盘的边沿（最外面的一圈），就算已经逃脱了。Lele梦见自己一定会被扔在一个可以走的格子里，但是不确定具体是哪一个，所以他要做好被扔在任意一个格子的准备。\n\n\n\n现在Lele请你帮忙，对于任意一个棋盘，找出一个最短的序列，序列里可以包括\"north\"(地图里向上),\"east\"(地图里向右),\"south\"(地图里向下),\"west\"(地图里向左)，这四个方向命令。不论Lele被扔在棋盘里的哪个好的格子里，都能按这个序列行走逃出棋盘。\n\n逃脱的具体方法是：不论Lele被扔在哪里，Lele按照序列里的方向命令一个一个地走，每个命令走一格，如果走的时候会碰到坏的格子，则忽略这条命令。当然，如果已经逃脱了，就可以不考虑序列中剩下的命令了。\n\n\n\nInput\n\n本题目包含多组测试，请处理至文件结束。\n\n每组测试第一行包含一个正整数 N (0<N<9)，代表棋盘的大小是 N*N\n\n接下来有N行，每行N个字符代表这个棋盘。\n\n其中0代表该位置是好的，可以走，1代表该位置是坏的，不可以走。\n\n\n\n题目数据保证，对于任意一个棋盘，都存在题目中所要求的序列\n\n\n\nOutput\n\n对于每组数据，输出题目所要求的序列，序列中每个元素一行。\n\n如果存在两个符合要求的序列，请输出字典序最小的那个序列。\n\n\n\n两个测试之间请用一个空行隔开。\n\n\n\nSample Input\n\n4\n\n1101\n\n0001\n\n1100\n\n1001\n\n\n\nSample Output\n\neast\n\nnorth", "Tag": "算法分析"}
{"Answer": "\nimport tkinter as tk\nimport random\nfrom random import randint\n \ndef tick():\n    global clock_val, after_id\n    if clock_started:\n        clock_val += 1\n        clock_lab[\"text\"] = str(clock_val)\n        after_id = clock_lab.after(1000, tick)\n        \ndef click1(event):\n    global clock_started\n    if not clock_started:#需要，主要是为了不执行clock_lab.after(1000, tick)这句，要不连续点击会生成多个延时,这样假设1秒内点了3次按钮，那么将会在1s后同时执行tick+3，这样计时就错误了\n        clock_started = True\n        clock_lab.after(1000, tick)\n    clicked_btn = event.widget#widget是当前点击的按钮控件，更多属性参考这篇文章http://c.biancheng.net/tkinter/event.html\n    clicked_val = int(clicked_btn[\"text\"])\n    if clicked_val == number[0]:\n        clicked_btn[\"state\"] = tk.DISABLED\n        del number[0]\n    if len(number) == 0:\n        clock_started = False\n        clock_lab.after_cancel(after_id)\n \n \nwindow=tk.Tk()\n \nwindow.title(\"Clicker\")\n \nnumber=[]\nfor i in range(25):\n    ran_number=random.randint(1,999)\n    while ran_number in number:\n        ran_number=random.randint(1,999)\n    number.append(ran_number)\nfor i in range(25):\n    button_1=tk.Button(window, text=str(number[i]),width=10)\n    button_1.grid(row=i%5,column=i//5)\n    button_1.bind(\"<Button-1>\",click1)\n \n \nnumber.sort()\nprint(number)\nclock_val = 0\nclock_lab = tk.Label(window, text=str(clock_val))\nclock_lab.grid(column=2, row=5)\nclock_started = False#这个是标记是否开始游戏的变量，默认为False尚未开始，在点击按钮后再开始并且计时\nwindow.mainloop()\n", "Konwledge_Point": "负权边的最短路径", "Question": "python tkinter\n对这段代码中一些步骤不理解\n\n\n\n\n\n\n一个窗口拥有5*5按钮的划分，按钮上的数字是随机赋予的，最下面那条label是计时器，游戏规则\n是从25个数字中找到最小的数字，然后点击，按钮上的数字立刻DISABLED（变成灰色），当点击\n第一个按钮的同时，下面label也开始计时（按秒数算），然后找第二小的数字, 以此类推，25个数\n字全部点到，看谁用时最短\n提问在注释里\n\n\nimport tkinter \nas\n tk\nimport \nrandom\n\n\nfrom\n \nrandom\n import randint\n\ndef \ntick\n():\n    \nglobal\n clock_val, after_id\n    \nif\n clock_started:\n        clock_val += \n1\n\n        clock_lab[\n\"text\"\n] = str(clock_val)\n        after_id = clock_lab.\nafter\n(\n1000\n, \ntick\n)\n        \ndef click1(event):\n    \nglobal\n clock_started\n    \nif\n \nnot\n clock_started:\n#下面已经把clock_started设置成False了，not clock_started就是True，clock_started的状态一直是False，这里的if应该用不到吧\n\n        clock_started = True\n        clock_lab.\nafter\n(\n1000\n, \ntick\n)\n    clicked_btn = event.widget\n#这条代码在这里起什么作用？\n\n    clicked_val = int(clicked_btn[\n\"text\"\n])\n    \nif\n clicked_val == \nnumber\n[\n0\n]:\n        clicked_btn[\n\"state\"\n] = tk.DISABLED\n        del \nnumber\n[\n0\n]\n    \nif\n \nlen\n(\nnumber\n) == \n0\n:\n        clock_started = False\n        clock_lab.after_cancel(after_id)\n\n\nwindow=tk.Tk()\n\nwindow.title(\n\"Clicker\"\n)\n\n\nnumber\n=[]\n\nfor\n i \nin\n range(\n25\n):\n    ran_number=\nrandom\n.randint(\n1\n,\n999\n)\n    \nwhile\n ran_number \nin\n \nnumber\n:\n        ran_number=\nrandom\n.randint(\n1\n,\n999\n)\n    \nnumber\n.append(ran_number)\n\nfor\n i \nin\n range(\n25\n):\n    button_1=tk.Button(window, \ntext\n=str(\nnumber\n[i]),width=\n10\n)\n    button_1.grid(row=i%\n5\n,column=\ni//5)\n\n    button_1.bind(\n\"\"\n,click1)\n\n\n\nnumber\n.\nsort\n()\nclock_val = \n0\n\nclock_lab = tk.Label(window, \ntext\n=str(clock_val))\nclock_lab.grid(column=\n2\n, row=\n5\n)\nclock_started = False\n#这里为什么要设置成False\n\nwindow.mainloop()\n\n\n\n\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "你具体哪个问题不懂？可以看看 https://blog.csdn.net/uniqsa/article/details/78519140 ", "Konwledge_Point": "负权边的最短路径", "Question": "关于c++转python的问题\n请问有人能帮我把以下这段c++代码转成python代码吗？十分感谢！\n\n\n问题描述：\n地图每个位置都有一个数字表示经过这个位置需要用的时间，地图如下：\n1 6 6 6\n15 7 6 6\n15 3 6 6\n15 15 1 1\n输入：第一行包含两个正整数 N 和 M(1\nusing namespace std;\n\nint a\n[101]\n[101]\n,m,n,sum=0,mins=2147483647;\nint f\n[4]\n[2]\n={{0,1},{-1,0},{1,0},{0,-1}};\nint sx,sy,ex,ey,book\n[101]\n[101]\n;\n\nvoid dfs(int x,int y){\n    book\n[x]\n[y]\n=1;\n    sum+=a\n[x]\n[y]\n;\n    if(x==ex && y==ey){\n        mins=sum=1 && xx<=n && yy>=1 && yy<=m && a\n[xx]\n[yy]\n && book\n[xx]\n[yy]\n==0){\n            dfs(xx,yy);\n        }\n    }\n    book\n[x]\n[y]\n=0;\n    sum-=a\n[x]\n[y]\n;\n    return;\n}\nint main(){\n    cin >> n >> m;\n    cin >> sx >> sy >> ex >> ey;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=m;j++){\n            cin >> a\n[i]\n[j]\n;\n        }\n    }\n    dfs(sx,sy);\n    cout << mins;\n    return 0;\n}\n\n", "Tag": "算法分析"}
{"Answer": "sum = 1 放到if外面去", "Konwledge_Point": "负权边的最短路径", "Question": "水题全WA|最大连续组长度|非常感谢\n水题全WA，麻烦各位帮忙看看，谢谢！\n\n\n问题：自己检查n遍觉得无懈可击（汗），样例都过了，测评就全\nWA\n了\n\n\n部分代码意义已注释\n\n\n题目：\n\n\n\n\n最大连续组长度\n\n\n小X在黑板上任意写下一串由26个英文字母组成的字母序列。然后，要求同学们在最短的时间里找出这个字母序列中哪个字母连续出现的次数最多，并且指出该字母一共连续出现了多少次。\n例如：字母序列为\nABBAAAACC\n，其中左边起第1个字母A没有连续出现。第二字母B连续出现了2次。第4个字母A连续出现了4次，第8个字母C连续出现了两次。则在这个字母序列中，第4个字母A连续出现的次数最多，共4次。\n编程解决这个问题。\n\n\n\n\n\n\n输入格式\n\n\n输入文件名：len.in\n第一行为正整数t(≤5)，表示数据组数；每组数据中，第一行为字母序列中的字母个数n(<10000），第二行为字母序列，全部由大写字母组成。\n\n\n\n\n\n\n输出格式\n\n\n输出文件名：len.out\n对于每组数据，输出两行结果：第一行为最多连续出现的次数，第二行为连续出现次数最多的字母。（如果最多的次数有多个，输出最早出现的字母）。\n\n\n\n\n\n\n输入/输出例子1\n\n\n输入：\n2\n9\nABBAAAACC\n20\nAAABBBAAAABBBBBBBCCC\n输出：\n4\nA\n7\nB\n\n\n\n\n本蒟蒻的代码\n\n\n#include \nusing namespace std;\nstring s;\n\nint\n main (){\n    //freopen (\n\"len.in\"\n,\n\"r\"\n,stdin);\n    //freopen (\n\"len.out\"\n,\n\"w\"\n,stdout);\n    \nint\n \nt\n;\n    cin>>\nt\n;\n    while (\nt\n--){\n        \nint\n \nn\n,\nmax\n=\n1\n,\nsum\n=\n1\n;//\nmax\n：最多连续出现的次数|\nsum\n：目前连续出现的次数 \n        \nchar\n v,maxv;//v：目前的字母|maxv：最多连续出现次数最多的字母 \n        cin>>\nn\n>>s;\n        maxv=s[\n0\n];//以防万一序列中的元素各不相同，不然maxv就没赋值啦 \n        for (\nint\n i=\n1\n;i<=\nn\n;i++){\n            \nif\n (s[i]==s[i-\n1\n]){//如果和上一个重复 \n                \nsum\n++;\n                v=s[i];\n            }\n            else{//如果不同 \n                \nif\n (\nsum\n>\nmax\n){//如果大于\nmax\n \n                    \nmax\n=\nsum\n;\n                    maxv=v;\n                    \nsum\n=\n1\n;\n                }\n                v=s[i];\n            }\n        }\n        cout<<\nmax\n<<endl<<maxv<<endl;\n    }\n    return \n0\n;\n} \n\n\n\n过样例：\n\n\n\n\n去测评：\n\n\n\n\n非常感谢", "Tag": "算法分析"}
{"Answer": "\nchar s[200001] = {0},st[201][101] = {0};\nint j = 0;\nfor(int i=0; i<strlen(s); i++)\n{\n    if(s[i]==' ')\n    {\n        p++;\n        j=0;\n    }\n    st[p][j++]=s[i];\n}\nfor(j=0; j<p-1; j++)\n    for(i=0; i<p-j-1; i++)\n        if(strlen(st[i])>strlen(st[i+1]))\n        {\n            strcpy(t,st[i]);\n            strcpy(st[i],st[i+1]);\n            strcpy(st[i+1],t);\n        }\nputs(st[p-1]);\nputs(st[0]);", "Konwledge_Point": "负权边的最短路径", "Question": "为什么会测不出来啊？\n输入字母之后弹出Program received signal SIGSEGV, Segmentation fault.，不知为什么,调试时箭头停在st[p][j]=s[i];这一行，编译时没有报错\n\n\n\n用DevC++写的，TDM-GCC 4.9.2 64-bit Release\n\n\n\n代码目的是从一行英文子串中找到并输出最长最短单词\n\n\n\n是新手，在oj上测试是显示运行错误\n\n\n\n\n\n#include\n#include\n#include\nusing namespace std;\nchar s[200001],st[201][101],t[101];\nint main()\n{\n\tint p=0;\n\tgets(s);\n\tfor(int i=0; istrlen(st[i+1]))\n\t\t\t{\n\t\t\t\tstrcpy(t,st[i]);\n\t\t\t\tstrcpy(st[i],st[i+1]);\n\t\t\t\tstrcpy(st[i+1],t);\n\t\t\t}\n\tputs(st[p]);\n\tputs(st[1]);\n\treturn 0;\n}", "Tag": "算法分析"}
{"Answer": "\n照你这个说法，这两个红框都代表的皮炎平，可是价格却不一样？ 咋合并\n ", "Konwledge_Point": "负权边的最短路径", "Question": "pandas的merge函数多键合并的问题\n原始数据如下\n\n\n\n\n\na = pd.DataFrame({'药品名':['感康','感冒灵','皮炎平'], '商品号':['8124','0023','0045'],'条形码':['69000000001','69000002103','69000000003'], '规格':['12片','8袋','15克']})\nb = pd.DataFrame({'批准文号':['国药准字Z43018942','国药准字Z23010042','国药准字H13018942', '国药准字B12018332'], '商品号':['0012','0023','1023','0045'],'条形码':['69000000001','69000000002','69000000003', '69000000553'], '零售价':[10, 9, 7.5, 25]})\n\n\n\n\n\n\n我想通过‘商品号’和‘条形码’这两列，合并这两个表格\n\n但这两列，只要其中一列相等即可合并，我要的结果如下：\n\n\n\n\n\n\n如何用最短的代码实现这个目的呢", "Tag": "算法分析"}
{"Answer": "可以直接关闭订单，自解决", "Konwledge_Point": "负权边的最短路径", "Question": "微信扫码支付，关闭订单和撤销订单？\n /**\n        * \n        * 关闭订单\n        * @param WxPayData inputObj 提交给关闭订单API的参数\n        * @param int timeOut 接口超时时间\n        * @throws WxPayException\n        * @return 成功时返回，其他抛异常\n        */\n        public static WxPayData CloseOrder(WxPayData inputObj, int timeOut = 6)\n        {\n            string url = \"https://api.mch.weixin.qq.com/pay/closeorder\";\n            //检测必填参数\n            if(!inputObj.IsSet(\"out_trade_no\"))\n            {\n                throw new WxPayException(\"关闭订单接口中，out_trade_no必填！\");\n            }\n\n            inputObj.SetValue(\"appid\",WxPayConfig.APPID);//公众账号ID\n            inputObj.SetValue(\"mch_id\",WxPayConfig.MCHID);//商户号\n            inputObj.SetValue(\"nonce_str\",GenerateNonceStr());//随机字符串     \n            inputObj.SetValue(\"sign\",inputObj.MakeSign());//签名\n            string xml = inputObj.ToXml();\n\n            var start = DateTime.Now;//请求开始时间\n\n            string response = HttpService.Post(xml, url, false, timeOut);\n\n            var end = DateTime.Now;\n            int timeCost = (int)((end - start).TotalMilliseconds);\n\n            WxPayData result = new WxPayData();\n            result.FromXml(response);\n\n            ReportCostTime(url, timeCost, result);//测速上报\n\n            return result;\n        }\n            /**\n        * \n        * 撤销订单API接口\n        * @param WxPayData inputObj 提交给撤销订单API接口的参数，out_trade_no和transaction_id必填一个\n        * @param int timeOut 接口超时时间\n        * @throws WxPayException\n        * @return 成功时返回API调用结果，其他抛异常\n        */\n        public static WxPayData Reverse(WxPayData inputObj, int timeOut = 6)\n        {\n            string url = \"https://api.mch.weixin.qq.com/secapi/pay/reverse\";\n            //检测必填参数\n            if (!inputObj.IsSet(\"out_trade_no\") && !inputObj.IsSet(\"transaction_id\"))\n            {\n                throw new WxPayException(\"撤销订单API接口中，参数out_trade_no和transaction_id必须填写一个！\");\n            }\n\n            inputObj.SetValue(\"appid\", WxPayConfig.APPID);//公众账号ID\n            inputObj.SetValue(\"mch_id\", WxPayConfig.MCHID);//商户号\n            inputObj.SetValue(\"nonce_str\", GenerateNonceStr());//随机字符串\n            inputObj.SetValue(\"sign\", inputObj.MakeSign());//签名\n            string xml = inputObj.ToXml();\n\n            var start = DateTime.Now;//请求开始时间\n\n            Log.Debug(\"WxPayApi\", \"Reverse request : \" + xml);\n\n            string response = HttpService.Post(xml, url, true, timeOut);\n\n            Log.Debug(\"WxPayApi\", \"Reverse response : \" + response);\n\n            var end = DateTime.Now;\n            int timeCost = (int)((end - start).TotalMilliseconds);\n\n            WxPayData result = new WxPayData();\n            result.FromXml(response);\n\n            ReportCostTime(url, timeCost, result);//测速上报\n\n            return result;\n        }\n\n\n\n\n注意：订单生成后不能马上调用关单接口，最短调用时间间隔为5分钟。\n\n我生成订单想立即关闭，怎么做", "Tag": "算法分析"}
{"Answer": "给你写出来了，看我的。\n\n//最大公共子序列的问题\n#include <stdio.h>\n#include <string.h>\n#define MAXSIZE 200\nint c[200][200];\nint b[200][200];\nchar f[200];\nvoid print(int i, int j, int s, char x[], char y[]);\nint max(int m, int n, int i, int j) // c[i][j-1].c[i-1][j]\n{\n    if (m > n) {\n        b[i][j] = 1;\n        return m;\n    } else {\n        b[i][j] = -1;\n        return n;\n    }\n}\nint LCS(char x[], char y[]) {\n    int i, j;\n    int m, n;\n    m = strlen(x);\n    n = strlen(y);\n    for (i = 0; i < m + 1; i++)\n        c[i][0] = 0;\n    for (j = 0; j < n + 1; j++)\n        c[0][j] = 0;\n    for (i = 1; i <= m; i++) {\n        for (j = 1; j <= n; j++) {\n            if (x[i - 1] == y[j - 1]) {\n                b[i][j] = 0;\n                c[i][j] = c[i - 1][j - 1] + 1;\n            } else {\n                c[i][j] = max(c[i][j - 1], c[i - 1][j], i, j);\n            }\n        }\n    }\n    printf(\"X和Y的LCS是：\");\n    print(m, n, c[m][n], x, y);\n    printf(\"%s\\n\", f);\n    return c[i - 1][j - 1];\n}\nvoid print(int i, int j, int s, char x[], char y[]) {\n    if (b[i][j] == 0) {\n        f[s - 1] = x[i - 1];\n        i--;\n        j--;\n        s--;\n        print(i, j, s, x, y);\n    } else if (b[i][j] == 1) {\n        j--;\n        print(i, j, s, x, y);\n    } else if (b[i][j] == 1) {\n        i--;\n        print(i, j, s, x, y);\n    }\n}\nint main() {\n    char x[MAXSIZE];\n    char y[MAXSIZE];\n    printf(\"你要输入的X字符串为：\");\n    scanf(\"%s\", x);\n    printf(\"你要输入的Y字符串为：\");\n    scanf(\"%s\", y);\n    int s = LCS(x, y);\n    printf(\"公共子序列长度为：%d\\n\", s);\n    return 0;\n}\n\n", "Konwledge_Point": "负权边的最短路径", "Question": "求最长子序列代码错误如何修改？\n问题遇到的现象和发生背景\n\n\n求最长子序列，怎么输入都是输出最短的那个，或是一个拼接答案，该怎么改？\n\n\n问题相关代码，请勿粘贴截图\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ndefine\n MAX 64\n\n\n\ntypedef\n \nstruct\n \nnode\n{\n    \nchar\n data[MAX];\n    \nint\n length;\n}SqString;\n\n\nvoid\n \nStrAssign\n(SqString *s,\nchar\n cstr[])\n\n\n{ \n    \nint\n i;\n    \nfor\n (i=\n0\n;cstr[i]!=\n'\\0'\n;i++)\n    s->data[i]=cstr[i];\n    s->data[i]=\n'\\0'\n;\n    s->length=i;\n}\n\n\nSqString* \nSubStr\n(SqString *s,\nint\n i,\nint\n j)\n\n\n{ \n    SqString* str;\n    \nint\n k;\n    str->length=\n0\n;\n    \nif\n (i<\n0\n || i>s->length || j<\n0\n || i+j\n-1\n>s->length)\n    \nreturn\n str; \n//参数不正确时返回空串\n\n    \nfor\n (k=i;kdata[i..i+j]?str\n\n    str->data[k-i]=s->data[k];\n    str->length=j\n-1\n;\n    \nreturn\n str;\n}\n\n\nbool\n \nSubContains\n(SqString* s1,SqString* temp)\n\n\n{\n    \nint\n i = \n0\n, j = \n0\n, flag = \n-1\n;\n    \nwhile\n (i < s1->length && j < temp->length)\n    {\n        \nif\n (s1->data[i] == temp->data[j])\n        { \n            i++;\n            j++;\n        }\n        \nelse\n\n        {\n            i = i - j + \n1\n; \n//主串字符回到比较最开始比较的后一个字符\n\n            j = \n0\n;         \n//字串字符重新开始\n\n        }\n        \nif\n (j == temp->length)\n        {             \n//如果匹配成功\n\n            flag = \n1\n; \n//字串出现\n\n            \nbreak\n;\n        }\n    }\n    \nreturn\n flag;\n}\n\n\nSqString* \nMaxSubstring\n(SqString* s1,SqString* s2)\n{  \n    SqString* max,*min; \n    max=(s1->length>s2->length)?s1:s2;  \n    min=(max==s1)?s2:s1;  \n    \nfor\n(\nint\n i=\n0\n;ilength;i++)  \n    {  \n        \nfor\n(\nint\n j=\n0\n,k=min->length-i;k!=min->length+\n1\n;j++,k++)  \n        {  \n            SqString* temp=\nSubStr\n(min,j,k-j\n-1\n);  \n            \nif\n(\nSubContains\n(max,temp))  \n                \nreturn\n temp;  \n        }  \n    }  \n    \nreturn\n \n0\n;  \n}  \n\nint\n \nmain\n()\n{\n    \nchar\n a1[\n100\n],a2[\n100\n];\n    SqString* s,s1,s2; \n    \nprintf\n(\n\"请输入第一个字符串：\"\n); \n    \ngets\n(a1);\n    \nprintf\n(\n\"请输入第二个字符串：\"\n); \n    \ngets\n(a2);\n    \nStrAssign\n(&s1,a1);\n    \nStrAssign\n(&s2,a2);\n    s=\nMaxSubstring\n(&s1,&s2);  \n    \nprintf\n(\n\"%s\"\n,s->data);\n    \nreturn\n \n0\n;\n}\n\n\n\n\n\n运行结果及报错内容\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/triple_wdf/article/details/51023080", "Konwledge_Point": "负权边的最短路径", "Question": "状态压缩BFS                            拯救大兵瑞恩\nProblem Description\n\n　　　1944年，特种兵麦克接到国防部的命令，要求立即赶赴太平洋上的一个孤岛，营救被敌军俘虏的大兵瑞恩。瑞恩被关押在一个迷宫里，迷宫地形复杂，但是幸好麦克得到了迷宫的地形图。\n\n　　　迷宫的外形是一个长方形，其在南北方向被划分为N行，在东西方向被划分为M列，于是整个迷宫被划分为N*M个单元。我们用一个有序数对（单元的行号，单元的列号）来表示单元位置。南北或东西方向相邻的两个单元之间可以互通，或者存在一扇锁着的门，又或者存在一堵不可逾越的墙。迷宫中有一些单元存放着钥匙，并且所有的门被分为P类，打开同一类的门的钥匙相同，打开不同类的门的钥匙不同。\n\n　　　大兵瑞恩被关押在迷宫的东南角，即（N,M）单元里，并已经昏迷。迷宫只有一个入口，在西北角，也就是说，麦克可以直接进入(1,1)单元。另外，麦克从一个单元移动到另一个相邻单元的时间为1，拿取所在单元的钥匙的时间以及用钥匙开门的时间忽略不计。\n\n　　　你的任务是帮助麦克以最快的方式抵达瑞恩所在单元，营救大兵瑞恩。\n\n\n\nInput\n\n有多组数据对于每一组数据来说：\n\n第一行是三个整数，依次表示N,M,P的值；\n\n第二行是一个整数K，表示迷宫中门和墙的总个数；\n\n第I+2行（1<=I<=K），有5个整数，依次为Xi1,Yi1,Xi2,Yi2,Gi：\n\n当Gi>=1时，表示(Xi1,Yi1)单元与(Xi2,Yi2)单元之间有一扇第Gi类的门，当Gi=0时，表示(Xi1,Yi1)单元与(Xi2,Yi2)单元之间有一堵不可逾越的墙；\n\n（其中，|Xi1-Xi2|+|Yi1-Yi2|=1，0<=Gi<=P）\n\n第K+3行是一个整数S，表示迷宫中存放的钥匙总数；\n\n第K+3+J行(1<=J<=S)，有3个整数，依次为Xi1,Yi1,Qi：表示第J把钥匙存放在(Xi1,Yi1)单元里，并且第J把钥匙是用来开启第Qi类门的。（其中1<=Qi<=P）\n\n注意：输入数据中同一行各相邻整数之间用一个空格分隔。\n\n\n\n参数设定：\n\n3<=N,M<=15;\n\n1<=P<=10;\n\n\n\nOutput\n\n对于每一组数据，输出一行，只包含一个整数T，表示麦克营救到大兵瑞恩的最短时间的值，若不存在可行的营救方案则输出-1。\n\n\n\nSample Input\n\n4 4 9\n\n9\n\n1 2 1 3 2\n\n1 2 2 2 0\n\n2 1 2 2 0\n\n2 1 3 1 0\n\n2 3 3 3 0\n\n2 4 3 4 1\n\n3 2 3 3 0\n\n3 3 4 3 0\n\n4 3 4 4 0\n\n2\n\n2 1 2\n\n4 2 1\n\n\n\nSample Output\n\n14", "Tag": "算法分析"}
{"Answer": "status InitQueue(Queue *Q)\n{\nQ=(Queue*)malloc(sizeof(Node));\n(*Q).front=(*Q).rear=0;\nreturn OK;\n}//队列初始化\n\n\n完全没有必要malloc啊，你main调用的时候，传入的是一个Queue变量的地址，不是一个Queue指针变量", "Konwledge_Point": "负权边的最短路径", "Question": "队列排队求长问题，运行出来结果不对，可以看看哪里错了吗\n这是原题：\n有3个队列A、队列B、队列C，原队列长度分别为10人、13人、16人。在5秒钟间隔内有1人到达，他以排队的规则是：哪个队列越短，他选中该队列的概率就越大；每个人离队的规律是：在6秒钟内，以概率P离队。当离队概率P=0.45时，计算500秒内队列A、队列B、队列C的长度分别是多少？\n\n\n这是我的程序代码：\n#include\n#include\n#define OK 1\n#define ERROR 0\n#define OVERFLOW -2\n#define MAXQSIZE 1000\ntypedef int status; \n\n\ntypedef struct Node\n{\n    int front;//头指针，指向队头元素\n    int rear;//尾指针，指向队尾元素的下一个位置\n}Queue;//队列的顺序存储结构 \n\n\nstatus InitQueue(Queue \nQ)\n{\n    Q=(Queue\n)malloc(sizeof(Node));\n    (*Q).front=(*Q).rear=0;\n    return OK;\n}//队列初始化\n\n\nint QueueLength(Queue Q)\n{\n    return (Q.rear-Q.front+MAXQSIZE)%MAXQSIZE;\n}//返回Q的长度\n\n\nstatus EnQueue(Queue *Q)\n{\n    if(((*Q).rear+1)%MAXQSIZE==(*Q).front)//队列满\n        return ERROR;\n    (*Q).rear=((*Q).rear+1)%MAXQSIZE;\n    return OK;\n}//入队\n\n\nstatus DeQueue(Queue *Q)\n{\n    if((*Q).front==(*Q).rear)\n        return ERROR;\n    (*Q).front=((*Q).front+1)%MAXQSIZE;\n    return OK;\n}//出队 \n\n\nQueue Minimun(Queue A,Queue B,Queue C)\n{\n    int l1=QueueLength(A);\n    int l2=QueueLength(B);\n    int l3=QueueLength(C);\n    if(l1<=l2&&l1<=l3)\n        return A;\n    if(l2<=l1&&l2<=l3)\n        return B;\n    if(l3<=l2&&l3<=l1)\n        return C;\n}//返回最短队列 \n\n\nint main()\n{\n    while(1)\n    {\n        int t;float P;\n        Queue A;\n        Queue B;\n        Queue C;\n        InitQueue(&A);\n        InitQueue(&B);\n        InitQueue(&C);\n        for(int i=1;i<=10;i++)\n            EnQueue(&A);\n        for(int i=1;i<=13;i++)\n            EnQueue(&B);\n        for(int i=1;i<=16;i++)\n            EnQueue(&C);\n        printf(\"请输入离队概率（以0到1之间的小数表示，输入0退出）：\");\n        scanf(\"%f\",&P);\n        if(P==0)\n        {\n            printf(\"结束退出......\\n\");\n            exit(-1);\n        }\n        P=P*100;\n        printf(\"请输入时长：\");\n        scanf(\"%d\",&t);\n        int c=0;\n        while(++c<=t)\n        {\n            if(c%5==0)\n            {\n                Queue Q=Minimun(A,B,C);\n                EnQueue(&Q);\n            }\n            if(c%6==0)\n            {\n                int r1=rand()%101;\n                int r2=rand()%101;\n                int r3=rand()%101;\n                if(r1<P)\n                    DeQueue(&A);\n                if(r2<P)\n                    DeQueue(&B);\n                if(r3<P)\n                    DeQueue(&C);\n            }\n        }\n        printf(\"A:%d\\nB:%d\\nC:%d\\n\\n\",QueueLength(A),QueueLength(B),QueueLength(C));\n    }\n    return 0;\n}\n\n\n结果出来是这个样子的：\n但是正确的结果应该是这样的：\n我不知道哪里出问题了...", "Tag": "算法分析"}
{"Answer": "编译不了看报错信息呀告诉你scanf函数是unsafe的，应该换成scanf_s，你照做呀", "Konwledge_Point": "负权边的最短路径", "Question": "在书上看的代码，编译不出来\n/**\n   开发团队：明日科技\n   明日学院网站：www.mingrisoft.com\n   一起来测试情商\n*/\n\n\n#\ninclude\n \n\n\n\nvoid\n \nQ1\n()\n;\n\nvoid\n \nQ2\n()\n;\n\nvoid\n \nQ3\n()\n;\n\nvoid\n \nQ4\n()\n;\n\nvoid\n \nQ5\n()\n;\n\nvoid\n \nQ6\n()\n;\n\nvoid\n \nQ7\n()\n;\n\nvoid\n \nQ8\n()\n;\n\nvoid\n \nQ9\n()\n;\n\nvoid\n \nQ10\n()\n;\n\nvoid\n \ngameOver\n()\n;\n\nvoid\n \nOut\n()\n;\n\nvoid\n \nagain\n(\nint\n i, \nint\n As, \nint\n Bs, \nint\n Cs, \nint\n Ds)\n;\n\nstatic\n  \nint\n q1, q2, q3, q4, q5, q6, q7, q8, q9, q10;\n\nint\n \nmain\n()\n\n\n{\n\n    \nOut\n();\n    \nreturn\n \n0\n;\n}\n\n\nvoid\n \nOut\n()\n \n{\n    \nprintf\n(\n\"=============情商测试（共10题总分200分）=================\\n\"\n);\n    \nprintf\n(\n\"人的情商比智商重要得多，它反映了一个人认知与表达自身情感；共10题。\\n\"\n);\n    \nprintf\n(\n\"了解、体会他人情感的能力。本测试由美国著名心理学家、哈佛心理学博士Daniel Goleman（1946.3.7 - ）所设计，\\n\"\n);\n    \nprintf\n(\n\"通过对这一系列问题的回答，您可以获得一个关于自己EQ（情商）的简单印象分数。最高分为200，一般人平均分为100左右。\\n\"\n);\n    \nQ1\n();\n}\n\n\n\nvoid\n \nQ1\n()\n\n\n{\n    \nchar\n sq;\n    \nprintf\n(\n\"------------第一题------------------\\n\"\n);\n    \nprintf\n(\n\"1. 坐飞机时，突然受到很大的震动，你开始随着机身左右摇摆。这时候，您会怎样做呢?\\n\"\n);\n    \nprintf\n(\n\"   A. 继续读书或看杂志，或继续看电影，不太注意正在发生的骚乱\\n\"\n);\n    \nprintf\n(\n\"   B. 注意事态的变化，仔细听播音员的播音，并翻看紧急情况应付手，以备万一\\n\"\n);\n    \nprintf\n(\n\"   C. A和B都有一点\\n\"\n);\n    \nprintf\n(\n\"   D. 不能确定--根本没注意到\\n\"\n);\n\n    \nprintf\n(\n\"请输入你的答案(单选)：\\n\"\n);\n    \nscanf\n(\n\"%c\"\n, &sq);\n    \nif\n (sq == \n'A'\n) {\n        q1 = \n20\n;\n    }\n    \nelse\n \nif\n (sq == \n'B'\n) {\n        q1 = \n20\n;\n    }\n    \nelse\n \nif\n (sq == \n'C'\n) {\n        q1 = \n20\n;\n    }\n    \nelse\n \nif\n (sq == \n'D'\n) {\n        q1 = \n0\n;\n    }\n    \nelse\n {\n        \nagain\n(\n1\n, \n20\n, \n20\n, \n20\n, \n0\n);\n        \nreturn\n \n0\n;\n    }\n    \nQ2\n();\n}\n\n//    　　2. B是最好的选择\n\n\n//    　　情商高的父母善于利用孩子情绪状态不好的时机对孩子进行情绪教育，帮助孩子明白是什么使他们感到不安，他们正在感受的情绪状态是怎样的，以及他们能进行的选择\n\n\n//    　　A=0，B=20，C=0，D=0\n\n\nvoid\n \nQ2\n()\n\n\n{\n    \nchar\n sq;\n    \nprintf\n(\n\"------------第二题------------------\\n\"\n);\n    \nprintf\n(\n\"2. 带一群4岁的孩子去公园玩，其中一个孩子由于别人都不和他玩而大哭起来。这个时候，您该怎么办呢?\\n\"\n);\n    \nprintf\n(\n\"   A. 置身事外--让孩子们自己处理\\n\"\n);\n    \nprintf\n(\n\"   B. 和这个孩子交谈，并帮助她想办法\\n\"\n);\n    \nprintf\n(\n\"   C. 轻轻地告诉她不要哭\\n\"\n);\n    \nprintf\n(\n\"   D. 想办法转移这个孩子的注意力，给她一些其他的东西让她玩\\n\"\n);\n    \nprintf\n(\n\"请输入你的答案(单选)：\\n\"\n);\n    \nscanf\n(\n\"%c\"\n, &sq);\n    \nif\n (sq == \n'A'\n) {\n        q2 = \n0\n;\n    }\n    \nelse\n \nif\n (sq == \n'B'\n) {\n        q2 = \n20\n;\n    }\n    \nelse\n \nif\n (sq == \n'C'\n) {\n        q2 = \n0\n;\n    }\n    \nelse\n \nif\n (sq == \n'D'\n) {\n        q2 = \n0\n;\n    }\n    \nelse\n {\n        \nagain\n(\n2\n, \n0\n, \n20\n, \n0\n, \n0\n);\n        \nreturn\n \n0\n;\n    }\n    \nQ3\n();\n}\n\n//    　　3. A自我激励的一个标志是能制定一个克服障碍和挫折的计划，并严格执行它\n\n\n//    　　A=20，B=0，C=20，D=0\n\n\nvoid\n \nQ3\n()\n \n{\n\n    \nchar\n sq;\n    \nprintf\n(\n\"------------第三题------------------\\n\"\n);\n    \nprintf\n(\n\"3. 假设您是一个大学生，想在某门课程上得优秀，但是在其中考试时却只得了及格。这时候，您该怎么办呢?\\n\"\n);\n    \nprintf\n(\n\"   A. 制定一个详细的学习，并决心按计划进行\\n\"\n);\n    \nprintf\n(\n\"   B. 决心以后好好学\\n\"\n);\n    \nprintf\n(\n\"   C. 告诉自己在这门课上考不好没什么大不了的，把精力集中在其他可能考得好的课程上\\n\"\n);\n    \nprintf\n(\n\"   D. 去拜访任课教授，试图让他给您高一点的分数\\n\"\n);\n    \nprintf\n(\n\"请输入你的答案(单选)：\\n\"\n);\n    \nscanf\n(\n\"%c\"\n, &sq);\n    \nif\n (sq == \n'A'\n) {\n        q3 = \n20\n;\n    }\n    \nelse\n \nif\n (sq == \n'B'\n) {\n        q3 = \n0\n;\n    }\n    \nelse\n \nif\n (sq == \n'C'\n) {\n        q3 = \n20\n;\n    }\n    \nelse\n \nif\n (sq == \n'D'\n) {\n        q3 = \n0\n;\n    }\n    \nelse\n {\n        \nagain\n(\n3\n, \n20\n, \n0\n, \n20\n, \n0\n);\n        \nreturn\n \n0\n;\n    }\n    \nQ4\n();\n}\n\n//    　　4. C为最佳答案\n\n\n//    　　情商高的一个标志是面对挫折时，能把它看成一种可以从中学到东西的挑战，坚持下去，尝试新的方法，而不是放弃努力，怨天尤人，变得萎靡不振\n\n\n//    　　A=0，B=0，C=20，D=0\n\n\nvoid\n \nQ4\n()\n \n{\n\n    \nchar\n sq;\n    \nprintf\n(\n\"------------第四题------------------\\n\"\n);\n    \nprintf\n(\n\"4. 假设您是一个保险推销员，去访问一些有希望成为您的顾客的人。可是一连十五个人都只是对您敷衍，并不明确表态，您变得很失望。这时候，您会怎么做呢?\\n\"\n);\n    \nprintf\n(\n\"   A. 认为这只不过是一天的遭遇而已，希望明天会有好运气\\n\"\n);\n    \nprintf\n(\n\"   B. 考虑一下自己是否适合做推销员\\n\"\n);\n    \nprintf\n(\n\"   C. 在下一次拜访时再做努力，保持勤勤恳恳工作的状态\\n\"\n);\n    \nprintf\n(\n\"   D. 考虑去争取其他的顾客\"\n);\n    \nprintf\n(\n\"请输入你的答案(单选)：\\n\"\n);\n    \nscanf\n(\n\"%c\"\n, &sq);\n    \nif\n (sq == \n'A'\n) {\n        q4 = \n0\n;\n    }\n    \nelse\n \nif\n (sq == \n'B'\n) {\n        q4 = \n0\n;\n    }\n    \nelse\n \nif\n (sq == \n'C'\n) {\n        q4 = \n20\n;\n    }\n    \nelse\n \nif\n (sq == \n'D'\n) {\n        q4 = \n0\n;\n    }\n    \nelse\n {\n        \nagain\n(\n4\n, \n0\n, \n0\n, \n20\n, \n0\n);\n        \nreturn\n \n0\n;\n    }\n    \nQ5\n();\n}\n\n\n//    　　5. C形成一种欢迎多样化的气氛的最有效的方法是公开挑明这一点\n\n\n//    　　当有人违反时，明确告诉他您的组织的规范不容许这种情况发生。不是力图改变这种偏见(这是一个更困难的任务)，而只是让人们遵照规范去行事\n\n\n//    　　A=0，B=0，C=20，D=0\n\n\nvoid\n \nQ5\n()\n \n{\n    \nchar\n sq;\n    \nprintf\n(\n\"------------第五题------------------\\n\"\n);\n    \nprintf\n(\n\"5. 您是一个经理，提倡在公司中不要搞种族歧视。一天您偶然听到有人正在开有关种族歧视的玩笑。您会怎么办呢?\\n\"\n);\n    \nprintf\n(\n\"   A. 不理它--这只是一个玩笑而已\\n\"\n);\n    \nprintf\n(\n\"   B. 把那人叫到办公室去，严厉斥责他一顿\\n\"\n);\n    \nprintf\n(\n\"   C. 当场大声告诉他，这种玩笑是不恰当的，在您这里是不能容忍的\\n\"\n);\n    \nprintf\n(\n\"   D. 建议开玩笑的人去参加一个有关反对种族歧视的培训班\\n\"\n);\n    \nprintf\n(\n\"请输入你的答案(单选)：\\n\"\n);\n    \nscanf\n(\n\"%c\"\n, &sq);\n    \nif\n (sq == \n'A'\n) {\n        q5 = \n0\n;\n    }\n    \nelse\n \nif\n (sq == \n'B'\n) {\n        q5 = \n0\n;\n    }\n    \nelse\n \nif\n (sq == \n'C'\n) {\n        q5 = \n20\n;\n    }\n    \nelse\n \nif\n (sq == \n'D'\n) {\n        q5 = \n0\n;\n    }\n    \nelse\n {\n        \nagain\n(\n5\n, \n0\n, \n0\n, \n20\n, \n0\n);\n        \nreturn\n \n0\n;\n    }\n    \nQ6\n();\n}\n\n//    　　6.D有资料表明，当一个人处于愤怒状态时，使他平静下来的最有效的办法是转移他愤怒的焦点，理解并认可他的感受，用一种不激怒他的方式让他看清现状，并给他以希望\n\n\n//    　　A=0，B=5，C=5，D=20\n\n\nvoid\n \nQ6\n()\n \n{\n    \nchar\n sq;\n    \nprintf\n(\n\"------------第六题------------------\\n\"\n);\n    \nprintf\n(\n\"6. 您的朋友开车时别人的车突然危险地抢到你们前面，您的朋友勃然大怒，而您试图让他平静下来。您会怎么做呢?\\n\"\n);\n    \nprintf\n(\n\"   A. 告诉他忘掉它吧--现在没事了，这不是什么大不了的事\\n\"\n);\n    \nprintf\n(\n\"   B. 放一盘他喜欢听的磁带，转移他的注意力\\n\"\n);\n    \nprintf\n(\n\"   C. 一起责骂那个司机，表示自己站在他那一边\\n\"\n);\n    \nprintf\n(\n\"   D. 告诉他您也曾有同样的经历，当时您也一样气得发疯，可是后来您看到那个司机出了车祸，被送到医院急救室\\n\"\n);\n    \nprintf\n(\n\"请输入你的答案(单选)：\\n\"\n);\n    \nscanf\n(\n\"%c\"\n, &sq);\n    \nif\n (sq == \n'A'\n) {\n        q6 = \n0\n;\n    }\n    \nelse\n \nif\n (sq == \n'B'\n) {\n        q6 = \n5\n;\n    }\n    \nelse\n \nif\n (sq == \n'C'\n) {\n        q6 = \n5\n;\n    }\n    \nelse\n \nif\n (sq == \n'D'\n) {\n        q6 = \n20\n;\n    }\n    \nelse\n {\n        \nagain\n(\n6\n, \n0\n, \n5\n, \n5\n, \n20\n);\n        \nreturn\n \n0\n;\n    }\n    \nQ7\n();\n}\n\n//    　　7.A中断20分钟或更长的时间\n\n\n//    　　这是使愤怒引起的生理状态平息下来的最短时间。否则，种状态会歪曲您的理解力，使您更可能出口伤人。平静了情绪后，你们的讨论才会更富有成效\n\n\n//    　　A=20，B=0，C=0，D=0\n\n\nvoid\n \nQ7\n()\n \n{\n    \nchar\n sq;\n    \nprintf\n(\n\"------------第七题------------------\\n\"\n);\n    \nprintf\n(\n\"7. 您和伴侣发生了争论，两人激烈地争吵;盛怒之下，互相进行人身攻击，虽然你们并不是真的想这样做。这时候，最好怎么办呢?\\n\"\n);\n    \nprintf\n(\n\"   A. 停止20分钟，然后继续争论\\n\"\n);\n    \nprintf\n(\n\"   B. 停止争吵……保持沉默，不管对方说什么\\n\"\n);\n    \nprintf\n(\n\"   C. 向对方说抱歉，并要求他(她)也向您道歉\\n\"\n);\n    \nprintf\n(\n\"   D. 先停一会儿，整理一下自己的想法，然后尽可能清楚地阐明自己的立场\\n\"\n);\n    \nprintf\n(\n\"请输入你的答案(单选)：\\n\"\n);\n    \nscanf\n(\n\"%c\"\n, &sq);\n    \nif\n (sq == \n'A'\n) {\n        q7 = \n20\n;\n    }\n    \nelse\n \nif\n (sq == \n'B'\n) {\n        q7 = \n0\n;\n    }\n    \nelse\n \nif\n (sq == \n'C'\n) {\n        q7 = \n0\n;\n    }\n    \nelse\n \nif\n (sq == \n'D'\n) {\n        q7 = \n0\n;\n    }\n    \nelse\n {\n        \nagain\n(\n7\n, \n20\n, \n0\n, \n0\n, \n0\n);\n        \nreturn\n \n0\n;\n    }\n    \nQ8\n();\n}\n\n//    　　8.B当一个组织的成员之间关系融洽、亲善，每一个人都感到心情舒畅时，组织的工作效率才会最高。在这种情况下，人们才能自由地做出他们最大的贡献\n\n\n//    　　A=0，B=20，C=0，D=0\n\n\nvoid\n \nQ8\n()\n \n{\n\n    \nchar\n sq;\n    \nprintf\n(\n\"------------第八题------------------\\n\"\n);\n    \nprintf\n(\n\"8. 您被分到一个单位当领导，想提出一些解决工作中烦难问题的好方法。这时候，您第一件要做的是什么呢?\\n\"\n);\n    \nprintf\n(\n\"   A. 起草一个议事日程，以便充分利用和大家在一起讨论的时间。\\n\"\n);\n    \nprintf\n(\n\"   B. 给人们一定的时间相互了解\\n\"\n);\n    \nprintf\n(\n\"   C. 让每一个人说出如何解决问题的想法\\n\"\n);\n    \nprintf\n(\n\"   D. 采用一种创造性地发表意见的形式，鼓励每一个人说出此时进入他脑子里的任何想法，而不管该想法有多疯狂\\n\"\n);\n    \nprintf\n(\n\"请输入你的答案(单选)：\\n\"\n);\n    \nscanf\n(\n\"%c\"\n, &sq);\n    \nif\n (sq == \n'A'\n) {\n        q8 = \n0\n;\n    }\n    \nelse\n \nif\n (sq == \n'B'\n) {\n        q8 = \n20\n;\n    }\n    \nelse\n \nif\n (sq == \n'C'\n) {\n        q8 = \n0\n;\n    }\n    \nelse\n \nif\n (sq == \n'D'\n) {\n        q8 = \n0\n;\n    }\n    \nelse\n {\n        \nagain\n(\n8\n, \n0\n, \n20\n, \n0\n, \n0\n);\n        \nreturn\n \n0\n;\n    }\n    \nQ9\n();\n}\n\n//    　　9.D生来带有害羞气质的孩子，如果他们父母能安排一系列渐进的针对他们害羞的挑战，并且这种挑战是能逐个应付得了的，那么他们通常会变得喜欢外出起来\n\n\n//    　　A=0，B=5，C=0，D=20\n\n\nvoid\n \nQ9\n()\n \n{\n    \nchar\n sq;\n    \nprintf\n(\n\"------------第九题------------------\\n\"\n);\n    \nprintf\n(\n\"9. 您3岁的儿子非常胆小，实际上，从他出生起就对陌生地方和陌生人有些神经过敏或者说有些恐惧。您该怎么办呢?\\n\"\n);\n    \nprintf\n(\n\"   A. 接受他具有害羞气质的事实，想办法让他避开他感到不安的环境\\n\"\n);\n    \nprintf\n(\n\"   B. 带他去看儿童精神科医生，寻求帮助\\n\"\n);\n    \nprintf\n(\n\"   C. 有目的地让他一下子接触许多人，带他到各种陌生的地方，克服他的恐惧心理\\n\"\n);\n    \nprintf\n(\n\"   D. 设计渐进的系列挑战性计划，每一个相对来说都是容易对付的，从而让他渐渐懂得他能够应付陌生的人和陌生的地方\\n\"\n);\n    \nprintf\n(\n\"请输入你的答案(单选)：\\n\"\n);\n    \nscanf\n(\n\"%c\"\n, &sq);\n    \nif\n (sq == \n'A'\n) {\n        q9 = \n0\n;\n    }\n    \nelse\n \nif\n (sq == \n'B'\n) {\n        q9 = \n5\n;\n    }\n    \nelse\n \nif\n (sq == \n'C'\n) {\n        q9 = \n0\n;\n    }\n    \nelse\n \nif\n (sq == \n'D'\n) {\n        q9 = \n20\n;\n    }\n    \nelse\n {\n        \nagain\n(\n9\n, \n0\n, \n5\n, \n0\n, \n20\n);\n        \nreturn\n \n0\n;\n    }\n    \nQ10\n();\n}\n\n//    　　10.B给自己适度的挑战，最有可能激发自己最大的热情\n\n\n//\n\n\n//    　　这既能使您学得愉快，又能使您完成得最好\n\n\n//\n\n\n//    　　A=0，B=20，C=0，D=0\n\n\nvoid\n \nQ10\n()\n \n{\n\n    \nchar\n sq;\n    \nprintf\n(\n\"------------第十题------------------\\n\"\n);\n    \nprintf\n(\n\"10. 多年以来，您一起想重学一种您在儿时学过的乐器，而现在只是为了娱乐，您又开始学了。您想最有效的利用时间。您该怎么做呢?\\n\"\n);\n    \nprintf\n(\n\"    A. 每天坚持严格的练习\\n\"\n);\n    \nprintf\n(\n\"    B. 选择能稍微扩展能力的有针对性的曲子去练习\\n\"\n);\n    \nprintf\n(\n\"    C. 只有当自己有情绪的时候才去练习\\n\"\n);\n    \nprintf\n(\n\"    D. 选择远远超出您的能力但通过勤奋的努力能掌握的乐曲去练习\\n\"\n);\n    \nprintf\n(\n\"请输入你的答案(单选)：\\n\"\n);\n    \nscanf\n(\n\"%c\"\n, &sq);\n    \nif\n (sq == \n'A'\n) {\n        q10 = \n0\n;\n    }\n    \nelse\n \nif\n (sq == \n'B'\n) {\n        q10 = \n20\n;\n    }\n    \nelse\n \nif\n (sq == \n'C'\n) {\n        q10 = \n0\n;\n    }\n    \nelse\n \nif\n (sq == \n'D'\n) {\n        q10 = \n0\n;\n    }\n    \nelse\n {\n        \nagain\n(\n10\n, \n0\n, \n20\n, \n0\n, \n0\n);\n        \nreturn\n \n0\n;\n    }\n    \ngameOver\n();\n}\n\nvoid\n \ngameOver\n()\n \n{\n    \nint\n z = q1 + q2 + q3 + q4 + q5 + q6 + q7 + q8 + q9 + q10;\n    \nprintf\n(\n\"------------答题结束------------------\\n\"\n);\n    \nprintf\n(\n\"测试结果：获得分数共计：%d分\\n\"\n, z);\n    \nif\n (z >= \n0\n && z < \n50\n) {\n        \nprintf\n(\n\"低情商\\n\"\n);\n        \nprintf\n(\n\"尊重所有人的人权和人格尊严。\\n不将自己的价值观强加于他人。\\n对自己有清醒的认识，能承受压力。\\n自信而不自满。\\n人际关系良好，和朋友或同事能友好相处。\\n善于处理生活中遇到的各方面的问题。\\n 认真对待每一件事情。\\n\"\n);\n    }\n    \nelse\n \nif\n (z >= \n50\n && z < \n100\n) {\n        \nprintf\n(\n\"较低情商\\n\"\n);\n        \nprintf\n(\n\"是负责任的“好”公民。\\n自尊。\\n有独立人格，但在一些情况下易受别人焦虑情绪的感染。\\n比较自信而不自满。\\n较好的人际关系。\\n能应对大多数的问题，不会有太大的心理压力。\\n\"\n);\n    }\n    \nelse\n \nif\n (z >= \n100\n && z < \n150\n) {\n        \nprintf\n(\n\"较高情商\\n\"\n);\n        \nprintf\n(\n\"易受他人影响，自己的目标不明确。\\n比低情商者善于原谅，能控制大脑。\\n能应付较轻的焦虑情绪。\\n把自尊建立在他人认同的基础上。\\n缺乏坚定的自我意识。\\n 人际关系较差。\\n\"\n);\n    }\n    \nelse\n \nif\n (z >= \n150\n && z < \n200\n) {\n        \nprintf\n(\n\"高情商\\n\"\n);\n        \nprintf\n(\n\"自我意识差。\\n无确定的目标，也不打算付诸实践。\\n严重依赖他人。\\n处理人际关系能力差。\\n 应对焦虑能力差。\\n 生活无序。\\n无责任感，爱抱怨。\\n\"\n);\n    }\n}\n\nvoid\n \nagain\n(\nint\n i, \nint\n As, \nint\n Bs, \nint\n Cs, \nint\n Ds)\n \n{\n    \nchar\n sq;\n    \nint\n y = \n0\n;\n    \n//printf(\"输入错误，请再次输入你的答案(单选)：\\n\");\n\n    \nscanf\n(\n\"%c\"\n, &sq);\n    \nif\n (sq == \n'A'\n) {\n        y = As;\n    }\n    \nelse\n \nif\n (sq == \n'B'\n) {\n        y = Bs;\n    }\n    \nelse\n \nif\n (sq == \n'C'\n) {\n        y = Cs;\n    }\n    \nelse\n \nif\n (sq == \n'D'\n) {\n        y = Ds;\n    }\n    \nelse\n {\n        \nagain\n(i, As, Bs, Cs, Ds);\n\n    }\n    \nif\n (i == \n1\n) {\n        q1 = y;\n        \nQ2\n();\n    }\n    \nelse\n \nif\n (i == \n2\n) {\n        q2 = y;\n        \nQ3\n();\n    }\n    \nelse\n \nif\n (i == \n3\n) {\n        q3 = y;\n        \nQ4\n();\n    }\n    \nelse\n \nif\n (i == \n4\n) {\n        q4 = y;\n        \nQ5\n();\n    }\n    \nelse\n \nif\n (i == \n5\n) {\n        q5 = y;\n        \nQ6\n();\n    }\n    \nelse\n \nif\n (i == \n6\n) {\n        q6 = y;\n        \nQ7\n();\n    }\n    \nelse\n \nif\n (i == \n7\n) {\n        q7 = y;\n        \nQ8\n();\n    }\n    \nelse\n \nif\n (i == \n8\n) {\n        q8 = y;\n        \nQ9\n();\n    }\n    \nelse\n \nif\n (i == \n9\n) {\n        q9 = y;\n        \nQ10\n();\n    }\n    \nelse\n \nif\n (i == \n10\n) {\n        q10 = y;\n        \ngameOver\n();\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n在书上看的代码，编译不出来", "Tag": "算法分析"}
{"Answer": "格式你自己调整一下：另外这些命令都是非常简单的，建议研究下\n1、mkdir /tmp/test; chmod 664 /tmp/test\n2、cd /home; pwd\n3、mkdir /worker; mkdir /worker/hosts01; mkdir /worker/hosts02; mkdir /worker/hosts01/h01; mkdir /worker/hosts01/h02\n4、rm -rf /worker/hosts01/h01; rmdir /worker/hosts01\n5、touch /worker/hosts02/test.txt; passwd\n6、useradd -s /bin/bash -m 200880101-user01; useradd -s /bin/bash -m 200880101-user02; useradd -s /bin/bash -m 200880101-user03; echo 123456 | passwd --stdin 200880101-user01; echo 123456 | passwd --stdin 200880101-user02; echo 123456 | passwd --stdin 200880101-user03; cut -d: -f1-5 /etc/passwd | tail -5\n7、chage -M 7 -m 60 -W 2 200880101-user01; chage -l 200880101-user01\n8、echo $(id -u 200880101-user02); usermod -u 3000 200880101-user02; id -u 200880101-user02\n9、userdel -r 200880101-user03; cut -d: -f1-5 /etc/passwd\n10、groupadd workgroup-01; groupadd workgroup-02; groupadd workgroup-03; cat /etc/group\n11、groupmod -n test-group -g 4000 workgroup-02; cat /etc/group\n12、groupdel workgroup-03; cat /etc/group\n13、usermod -aG workgroup-01 200880101-user01; cat /etc/group\n14、touch test01.txt; chown user02:user02 test01.txt; ls -l test01.txt\n", "Konwledge_Point": "负权边的最短路径", "Question": "Linux 虚拟机命令解答\n1、在／ tmp 下新建目录 test ．并指定权限664 2、进入／ home 目录，使用 pwd 显示当前目录\n3、在／下新建目录 worker ，在 worker 下成立新建目录host01,hosts02,在hosts01下新建h01,h02文件。\n4、删除hosts01下的h01目录，若host01目录为空，则删除host01\n5、在hosts02下新建文件 test . txt ，更改 root 用户密码\n6、以自己的学号为前缀创建三个用户，如200880101-user01、200880101-user02、200880101-user03，密码均为123456，用户账户永不过期，使用命令查看新建用户信息（查看后5行内容）。\n7、修改用户user01属性值，最短口令存活期为7天，最长口令存活期为60天，口令到期前2天提醒用户修改口令，设置完成后查看各属性值。\n8、查看用户user02的 UID ，并修改用户user02的 UID 值为3000，修改完成后查看用户user02的 UID 。\n9、删除用户user03，同时删除主目录以及目录中的所有文件，查看当前用户信息以及用户目录情况。\n10、创建组群 workgroup -01、 workgroup -02、 workgroup -03，并查看组群文件信息内容。\n11、更改组群 workgroup -02的名称为 test - group ，并且修改组 ID 为4000．查看修改信息结果。\n12、删除组群 workgroup -03，并查看组群文件信息内容。\n13、将用户user01添加到组群 workgroup -01中，并查看组群文件信息内容。\n14、创建文件test01.txt，修改文件的所有者属主为user02，属组为user02，并查看文件test01.txt属性信息。", "Tag": "算法分析"}
