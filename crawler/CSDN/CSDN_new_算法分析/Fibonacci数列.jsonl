{"Answer": "非递归实现：\r\n```\r\nint fb(int a1,int a2,int n);\r\n{\r\n\tint a[10000],s,i;\r\n\ta[0]=a1;\r\n\ta[1]=a2;\r\n\ts=a[0]+a[1];\r\n\tfor(i=2;i<n;i++){\r\n\t\ta[i]=a[i-1]+a[i-2];\r\n\t\ts+=a[i];\r\n\t}\r\n\treturn s;\r\n}\r\n```\r\n递归实现：\r\n\r\n```\r\n#include\"stdio.h\"\r\nint fb(int a1,int a2,int s,int n); \r\nint main()\r\n{\r\n    int a,b,n,s;\r\n    scanf(\"%d%d%d\",&a,&b,&n);\r\n    s=fb(a,b,a+b,n);\r\n    printf(\"%d\\n\",s);\r\n}\r\n\r\nint fb(int a1,int a2,int s,int n){\r\n\tint t=a1+a2;\r\n\tif(n==2) return s;\r\n    s=t+fb(a2,t,s,n-1);\r\n    return s;\r\n}\r\n```", "Konwledge_Point": "Fibonacci数列", "Question": "求解答！C语言-斐波那契数列前n项和问题\n斐波那契数列前n项和问题\n\n\n\n如果数列的前前两项不为1，而是a1和a2，那应该怎么设计这个函数呢？\n\n\n\n#include\"stdio.h\"\nint fb(int a1,int a2,int n); \nint main()\n{\n    int a,b,n,s;\n    scanf(\"%d%d%d\",&a,&b,&n);\n    s=fb(a,b,n);\n    printf(\"%d\\n\",s);\n}\n\n\n\n\nint fb(int a1,int a2,int n);\n{\n\n}\n\n", "Tag": "算法分析"}
{"Answer": "#请定义一个函数返回斐波那契数列的第n项，并输出斐波那契数列的前10项。\n\ndef fib(n):\n    if n==1 or n==2:\n        return n\n    else:\n        return fib(n-1) + fib(n-2)\n\nn = int(input('斐波那契数列的第n项:'))\nprint(\"斐波那契数列的第{}项:{}\".format(n,fib(n)))\n\nfor i in range(1,11):\n    print(fib(i))\n    \n\n", "Konwledge_Point": "Fibonacci数列", "Question": "请定义一个函数返回斐波那契数列的第n项，并输出斐波那契数列的前10项。\n请定义一个函数返回斐波那契数列的第n项，并输出斐波那契数列的前10项。", "Tag": "算法分析"}
{"Answer": "首先给出一个定理吧：\r\n(a+b)%d=(a%d+b%d)%d.\r\n所以如果你把每一次的运算修改成\r\na[i] = (a[i - 1] + a[i - 2])%10007;\r\n就会保证a[i]的数值恒在int范围内，并且可以支持比较大的n运行。", "Konwledge_Point": "Fibonacci数列", "Question": "Fibonacci数列求第n项值，当n的数值比较大时，结果会变成负数，请问有没有更好的解决方法？如下，我在求Fibonacci数列求第n项值除以10007的余数，当输入的n为几十，结果就是负数了。\n#define N 100000\n\n...\n\n\n\nint main()\n\n{\n\n    long qiujiecheng(long n);\n\n    long n;\n\n    scanf_s(\"%ld\", &n);\n\n    n = qiujiecheng(n);\n\n    printf(\"%ld\", n);\n\n    if (n < 10007)\n\n    {\n\n        printf(\"%d\", n);\n\n    }\n\n    else {\n\n        n %= 10007;\n\n        printf(\"%ld\", n);\n\n    }\n\n}\n\nlong qiujiecheng(long n)\n\n{\n\n    static int a[N];\n\n    a[1] = a[0] = 1;\n\n    for (int i = 2; i < n; i++)\n\n    {\n\n        a[i] = a[i - 1] + a[i - 2];\n\n    }\n\n    return a[n - 1];\n\n}", "Tag": "算法分析"}
{"Answer": "#include<stdio.h>\nint main() {\n    int Fibonacci[40];\n    Fibonacci[0] = 0;\n    Fibonacci[1] = 1;\n    for(int i = 2; i <= 39; i++) {\n        Fibonacci[i] = Fibonacci[i - 1] + Fibonacci[i - 2];\n    }\n    int j = 1;\n    for(int i = 0; i <= 39; i++) {\n        printf(\"%d \", Fibonacci[i]);\n        j++;\n        if(j == 4) {\n            printf(\"\\n\");\n            j = 1;\n        }\n    }\n    return 0;\n}\n\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "编写程序计算Fibonacci数列的前40项。（要求每行输出4个数）\ninclude \n\n\nint main()\n{\n    //在此处定义一个int类型的数组Fibonacci，大小为40\n    Fibonacci[0]=0;\n    Fibonacci[1]=1;\n    for()//在括号内填入从数组下标2到数组末尾的循环\n    {\n        //在此处填入计算当前下标下的斐波那契数的计算式\n    }\n    int j=1;\n    for(int i=0;i<=39;i++)\n    {\n        printf(\"%d  \",Fibonacci[i]);\n        j++;\n        if(j==4){\n            printf(\"\\n\");\n            j=1;\n        }\n    }\n    return 0;\n}", "Tag": "算法分析"}
{"Answer": "\npublic static void main(String[] args) {\n        int[] arr = new int[20];\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = count(i);\n        }\n\n        for (int num : arr) {\n            System.out.print(num + \" \");\n        }\n    }\n\n    public static int count(int num) {\n        if ((num == 0) || (num == 1))\n            return num;\n        else\n            return count(num - 1) + count(num - 2);\n    }\n", "Konwledge_Point": "Fibonacci数列", "Question": "用java数组求斐波那契数列前20项\n题目描述\n创建一个数组，用来存放斐波拉契数列（0、1、1、2、3、5、8、13、21、34、……)的前20项，然后遍历数组，将该数列显示出来。\n\n\n输入描述\n无\n\n\n输出描述\n斐波拉契数列的前20项，项与项之间用空格分隔\n\n\n输出样例\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181", "Tag": "算法分析"}
{"Answer": "http://www.2cto.com/kf/201306/222126.html", "Konwledge_Point": "Fibonacci数列", "Question": "2、从键盘输入n（>2），计算斐波那契数列的前n项并按每行10个数据输出。\n2、从键盘输入n（>2），计算斐波那契数列的前n项并按每行10个数据输出。", "Tag": "算法分析"}
{"Answer": "\n# -*- coding: UTF-8 -*-\n\n# Filename : test.py\n\n# 获取用户输入数据\nnterms = int(input('请输入一个正整数:'))\n\n# 第一和第二项\nn1 = 1\nn2 = 1\ncount = 2\n\n# 判断输入的值是否合法\nif nterms <= 0:\n    print(\"请输入一个正整数。\")\nelif nterms == 1:\n    print(n1)\nelse:\n    print(n1, n2, end=\" \")\n    while count < nterms:\n        nth = n1 + n2\n        print(nth, end=\" \")\n        # 更新值\n        n1 = n2\n        n2 = nth\n        count += 1\n \n ", "Konwledge_Point": "Fibonacci数列", "Question": "Python斐波那契数列\n斐波那契数列又称为兔子数列，因数学家列昂纳多·斐波那契以兔子繁殖为例子引入，这个数列中的数据满足以下公式：\n\nF(1)=1, F(2)=1, F(n)= F(n-1) + F(n-2) （n>=3，n∈N*）\n\n要求编写程序，实现根据用户输入的数字输出斐波那契数列的功能。\n\n \n\n基本要求：根据题目描述中的公式，可以定义一个递归函数fibonacci (n)，该函数中n表示指定的斐波那契数，边界条件为n=1或n=2，递归公式为fibonacci (n-1)+ fibonacci (n-2)。\n\n\n\n\n\n\n ", "Tag": "算法分析"}
{"Answer": "n=int(input())\nf1=0\nf2=1\nl=[str(f1),str(f2)]\nfor i in range(2,n):\n    f3=f1+f2\n    f1,f2=f2,f3\n    l.append(str(f3))\nprint(','.join(l))\n", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列,这个数列从第3项开始，每一项都等于前两项之和。求斐波那契数列的前n项。\n斐波那契数列，指的是这样一个数列，这个数列从第3项开始，每一项都等于前两项之和。求斐波那契数列的前n项。\n\n\n输入格式:\n输入一个n（n>=3）的值。\n\n\n输出格式:\n输出斐波那契数列的前n项。", "Tag": "算法分析"}
{"Answer": "public int fibonacci(int n){\r\n\tif(n<=0){\r\n\t\tprintf(\"出错了\");\r\n\t\treturn -1;\r\n\t}\r\n\tif(n==1){\r\n\t\treturn 0;\r\n\t}\r\n\telse if(n==2){\r\n\t\treturn 1;\r\n\t}\r\n\telse{\r\n\t\treturn fibonacci(n-2)+fibonacci(n-1);\r\n\t}\r\n}\r\n如果不这样实现可以用递归实现的。\r\n你问的问题1和问题2请看下面的推导过程，你就会明白了。\r\nf(n+1)=f(n)+g(n);       g(n+1)= f(n+1)-g(n);  (数学中的数列，自己慢慢理解)  \r\n这样推导出来就是g(n+1)=f(n);\r\n当n变成n+1则变成f(n+2)=f(n+1)+g(n+1);即f(n+2)=f(n+1)+f(n);\r\n综上所述，即得出斐波那契数列。", "Konwledge_Point": "Fibonacci数列", "Question": "Fibonacci数列 的疑问（一增一减的迭代法）\n程序如下：\n\n        int f = 0;\n\n        int g = 1;\n\n        for (int i = 0; i <= 15; i++)\n\n        {\n\n            println(f);\n\n            f = f + g;\n\n            g = f - g;\n\n        }\n\n\n\n输出：0  1 1  2  3 5 8 13 21 34 55 89 144 233 377 610\n\n\n\n问题1：为什么是用一增一减实现的？\n\n问题2：还有关初值f和g是怎么设定的？\n\n\n\n谢谢！", "Tag": "算法分析"}
{"Answer": "static变量和递归两者不要同时用\r\n\r\n用static的写法\r\n```\r\n#include \r\n#include \r\nusing namespace std;\r\nint Fibonacci(int n)\r\n{\r\n\tstatic int a = 1;\r\n\tstatic int b = 1;\r\n\tif (n == 1 || n == 2) return 1;\r\n\tint c = a + b;\r\n\ta = b;\r\n\tb = c;\r\n\treturn c;\r\n}\r\nint main () {\r\n\tint n;\r\n\tcin>>n; \r\n\tfor(int i=1;i<=n;i++){\r\n\tcout<\r\n#include \r\nusing namespace std;\r\nint Fibonacci(int n)\r\n{\r\n\tif (n == 1 || n == 2) return 1;\r\n\treturn Fibonacci(n - 2) + Fibonacci(n - 1);\r\n}\r\nint main () {\r\n\tint n;\r\n\tcin>>n; \r\n\tfor(int i=1;i<=n;i++){\r\n\tcout<<setw(10)<<setiosflags(ios::left)<<Fibonacci(i);\r\n\tif (i%4==0) cout<<endl;\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\n```", "Konwledge_Point": "Fibonacci数列", "Question": "6-5 输出Fibonacci数列的前n项 (15分)\n已知Fibonacci数列的规律是1，1，2，3，5，8，…，即数列的前两项是1，其后的每一项都是其前两项的和。输出Fibonacci数列的前n（1<=n<=40）项。要求定义并调用含静态变量的函数Fibonacci(n)计算Fibonacci数列的第n项。\n\n输入格式:\n\n        输入n值\n\n输出格式:\n\n        以每行4个的格式输出Fibonacci数列的前n项。每项占10位列宽并左对齐。\n\n 我看不出来我的问题，还请哥哥们指教：\n\n#include \n\n#include \n\nusing namespace std;\n\nint f(int n)\n\n{\n\n    static int y;\n\n    if(n==1)\n\n     y=1;\n\n    if(n==2)\n\n     y=1;\n\n    else \n\n     y=y+f(n-2);\n\n     return y; \n\n\n\n}\n\nint main()\n\n{\n\n    int n,j=1;\n\n    cin>>n;\n\n    for(int i=1;i<=n;i++){\n\n        cout<<setw(10)<<setiosflags(ios::left)<<f(n);\n\n    j++;\n\n    while (j%4==0) cout<<endl;\n\n    }\n\n    return 0;\n\n}", "Tag": "算法分析"}
{"Answer": "\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int num[45];\n    int m,k;\n    int sum=0;\n    num[0]=1;\n    num[1]=1;\n    for(int i=2;i<45;i++)//算出斐波那契数列前45项\n    {\n        num[i]=num[i-1]+num[i-2];\n    }\n    scanf(\"%d %d\",&m,&k);\n    if(m<=k&&m>0&&k<45)//满足条件计算和\n    {\n        for(int i=m-1;i<k;i++)\n        {\n            sum+=num[i];\n        }\n        printf(\"sum = %d\",sum);\n    }\n    else\n    {\n        printf(\"ERROR\");\n    }\n    return 0;\n}\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "利用数组生成斐波那契数列（1,1,2,3,.…）的前45项，然后求出 m 到 k 项之和，(0< m <= k <45)，包括 m 和 k 项的值。\n利用数组生成斐波那契数列（1,1,2,3,.…）的前45项，然后求出 m 到 k 项之和，(0< m <= k <45)，包括 m 和 k 项的值。( m , k 指项，数组的下标是从0开始的，即第1项为 a [0])", "Tag": "算法分析"}
{"Answer": "使用分支条件一一判断当第几项该返回什么值即可实现递归求斐波那契数列某一项的值，依据你给的代码及例子，修改如下： 参考链接：斐波那契数列_百度百科\n\n#include <stdio.h>\n\nint F(int n);\n\nint main(void){\n    \n    int n,y,i;\n    scanf(\"%d\",&n);\n    \n    //printf(\"n=%d\\n\",n);\n    \n    for(i=0;i<=n;i++){ //从数列的第1项开始，到输入的第n项结束 \n        y=F(i);\n        printf(\"%d \",y);\n    }\n    printf(\"\\n\");\n    return 0;\n    \n}\n//https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/99145\nint F(int n){\n    \n//    printf(\"n=%d\\n\",n);\n    if(n==0){ //如果是数列的第一项，则返回1 \n        return 1;\n    }else if(n==1){ //如果是数列的第二项，则返回1 \n        return 1;\n    }else{  //如果是数列的其他项，则返回前面两项数列的和 \n        return F(n-1)+F(n-2);\n    }\n    \n\n}\n\n\n\n \n\n\n\n \n \n\n", "Konwledge_Point": "Fibonacci数列", "Question": "输入整数N，打印Fibonacci数列的前N项，用递归函数\n输入整数N，打印Fibonacci数列打印前N项\n测试输入7\n预期1 1 2 3 5 8 13 21", "Tag": "算法分析"}
{"Answer": "对第一个， 第二个单独判断， 从第三个开始就要等于前两个的和。代码如下：\n#include <stdio.h>\nint func(int num)\n{\n    if(num%3 == 0)\n        return 1;\n    return 0;\n}\nint main()\n{\n    int f0=7, f1=11;\n    int tmp;\n    int n;\n    scanf(\"%d\", &n);\n    if(n<0 || n>=1000000) return -1;\n    if(n == 1) printf(\"no\");\n    else if(n == 2) printf(\"no no\");\n    else if(n >= 3)\n    {\n        for(int i=0; i<n; i++)\n        {\n            if(i == 0) printf(\"no \");\n            else if(i == 1) printf(\"no \");\n            else if(i > 1)\n            {\n                tmp = f0 + f1;\n                f0 = f1;\n                f1 = tmp;\n                printf(\"%s\", func(f1)?\"yes\":\"no\");\n                if(i != n-1) printf(\" \");\n            }\n        }\n\n    }\n\n    return 0;\n}\n", "Konwledge_Point": "Fibonacci数列", "Question": "程序设计   斐波那契数列\n斐波那契数，亦称之为斐波那契数列，指的是这样一个数列：0、1、1、2、3、5、8、13、21、……，这个数列从第3项开始，每一项都等于前两项之和。这里我们定义另外一种斐波那契数列： F(0) = 7, F(1) = 11, F(n) = F(n-1) + F(n-2) (n>=2)。编程计算该数列的前n（n<1000000）项是否能被3整除。\n\n\n输入格式:\n输入为一个正整数n（n<1000000）。\n\n\n输出格式:\n输出上述数列前n项能否被3整除，能则输出“yes ”,否则输出\"no \"。注意：每个\"yes\"和\"no\"后面都有一个空格。\n\n\n输入样例1:\n2\n结尾无空行\n输出样例1:\nno no\n结尾无空行\n输入样例2:\n6\n结尾无空行\n输出样例2:\nno no yes no no no\n结尾无空行", "Tag": "算法分析"}
{"Answer": "#include<stdio.h>\nint main(){\n    int n;\n    int f[10001];\n    f[1] = 1;\n    f[2] = 1;\n    scanf(\"%d\",&n);\n    for(int i = 3;i <= n;i++){\n        f[i] = f[i-1]+f[i-2];\n    }\n    printf(\"%d\\n\",f[n]);\n}\n", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列例题11\n斐波那契数列是指这样的数列：数列的第一个和第二个数都为 11，接下来每个数都等于前面 22 个数之和。\n\n\n给出一个正整数 kk，要求斐波那契数列中第 kk 个数是多少。\n\n\n输入格式\n输入一行，包含一个正整数 kk。（1 \\le k \\le 461≤k≤46）\n\n\n输出格式\n输出一行，包含一个正整数，表示斐波那契数列中的第 kk 个数。", "Tag": "算法分析"}
{"Answer": "用turbo c写了一个\r\n\r\n```\r\n#include \r\nint foo(int n)\r\n{\r\n  if (n <= 2) return 1;\r\n  return foo(n - 1) + foo(n - 2);\r\n}\r\nmain()\r\n{\r\n  int i;\r\n  for (i = 1; i < 10; i++)\r\n    printf(\"%d \", foo(i));\r\n  return 0;\r\n}\t\r\n```\r\n得到如下汇编（帮你注释了下）\r\n```\r\n\tifndef\t??version\r\n?debug\tmacro\r\n\tendm\r\n\tendif\r\n\t?debug\tS \"..\\project\\app1.c\"\r\n_TEXT\tsegment\tbyte public 'CODE'\r\nDGROUP\tgroup\t_DATA,_BSS\r\n\tassume\tcs:_TEXT,ds:DGROUP,ss:DGROUP\r\n_TEXT\tends\r\n_DATA\tsegment word public 'DATA'\r\nd@\tlabel\tbyte\r\nd@w\tlabel\tword\r\n_DATA\tends\r\n_BSS\tsegment word public 'BSS'\r\nb@\tlabel\tbyte\r\nb@w\tlabel\tword\r\n\t?debug\tC E9440EAA50112E2E5C70726F6A6563745C617070312E63\r\n\t?debug\tC E9A460A840122E2E5C696E636C7564655C737464696F2E68\r\n\t?debug\tC E9A460A840132E2E5C696E636C7564655C7374646172672E68\r\n_BSS\tends\r\n_TEXT\tsegment\tbyte public 'CODE'\r\n;\t?debug\tL 2\r\n_foo\tproc\tnear ;foo函数\r\n\tpush\tbp\r\n\tmov\tbp,sp\r\n\tpush\tsi\r\n\tmov\tsi,word ptr [bp+4] ;n参数放入si\r\n;\t?debug\tL 4\r\n\tcmp\tsi,2 ;判断n和2的大小\r\n\tjg\t@2 ;大于2跳转到后面\r\n\tmov\tax,1 ;n<2则返回1\r\n\tjmp\tshort @1\r\n@2:\r\n;\t?debug\tL 5\r\n\tmov\tax,si\r\n\tdec\tax ;这里就是计算n-1\r\n\tpush\tax\r\n\tcall\tnear ptr _foo ;递归调用foo\r\n\tpop\tcx\r\n\tpush\tax\r\n\tmov\tax,si\r\n\tadd\tax,-2 ;这里是计算n-2\r\n\tpush\tax ;结果放在堆栈上\r\n\tcall\tnear ptr _foo ;递归调用foo\r\n\tpop\tcx\r\n\tmov\tdx,ax ;foo(n-2)的结果放在dx\r\n\tpop\tax ;从堆栈上得到 foo(n-1)的结果\r\n\tadd\tax,dx //相加放在ax上作为返回值\r\n\tjmp\tshort @1\r\n@1: ;这里是函数返回部分\r\n;\t?debug\tL 6\r\n\tpop\tsi\r\n\tpop\tbp\r\n\tret\t\r\n_foo\tendp\r\n_TEXT\tends\r\n_DATA\tsegment word public 'DATA'\r\n_DATA\tends\r\n_TEXT\tsegment\tbyte public 'CODE'\r\n;\t?debug\tL 7\r\n_main\tproc\tnear\r\n\tpush\tsi\r\n;\t?debug\tL 10\r\n\tmov\tsi,1 ;si保存的是循环变量i，这里是i=1\r\n\tjmp\tshort @7\r\n@6: ;循环开始\r\n;\t?debug\tL 11\r\n\tpush\tsi ;将i作为参数放入堆栈\r\n\tcall\tnear ptr _foo ;调用foo(i)\r\n\tpop\tcx\r\n\tpush\tax ;把结果放入堆栈\r\n\tmov\tax,offset DGROUP:s@ ;把\"%d \"放入堆栈\r\n\tpush\tax\r\n\tcall\tnear ptr _printf ;调用printf\r\n\tpop\tcx\r\n\tpop\tcx\r\n@5:\r\n\tinc\tsi ;i++\r\n@7:\r\n\tcmp\tsi,10 ;i == 10?\r\n\tjl\t@6 ;小于10返回循环开始处（6）\r\n@4:\r\n;\t?debug\tL 12\r\n\txor\tax,ax\r\n\tjmp\tshort @3\r\n@3:\r\n;\t?debug\tL 13\r\n\tpop\tsi\r\n\tret\t\r\n_main\tendp\r\n_TEXT\tends\r\n\t?debug\tC E9\r\n_DATA\tsegment word public 'DATA'\r\ns@\tlabel\tbyte\r\n\tdb\t37 ;%\r\n\tdb\t100 ;d\r\n\tdb\t32 ;空格\r\n\tdb\t0\r\n_DATA\tends\r\n_TEXT\tsegment\tbyte public 'CODE'\r\n\textrn\t_printf:near ;外部函数printf\r\n_TEXT\tends\r\n\tpublic\t_main\r\n\tpublic\t_foo\r\n\tend\r\n\t\r\n```\r\n你可以用tasm汇编得到exe\r\n\r\n运行\r\n![图片说明](https://img-ask.csdn.net/upload/202005/10/1589048096_205385.png)\r\n\r\n# 相关的工具程序下载\r\n# https://download.csdn.net/download/caozhy/12404953\r\n\r\n# 问题解决的话，请点采纳", "Konwledge_Point": "Fibonacci数列", "Question": "汇编递归求斐波那契数列前N项\n汇编怎么用递归求斐波那契数列啊\n\n救救孩子吧\n\n已经几天了还是对堆栈不够理解\n\n大佬最好别调用库做，萌新看不懂，\n\n比如 输入个4\n\n那么输出是 1 1 2 3 这四项", "Tag": "算法分析"}
{"Answer": "\n#include <stdio.h>\n\nint func(int n)\n{\n    if (n) return n + func(n - 1);\n    else    return 0;\n}\n\nvoid main()\n{\n    printf(\"%d\", func(6));\n}\n", "Konwledge_Point": "Fibonacci数列", "Question": "如何用C++递归写出斐波那契数列呢？\n刚学递归，请问如何用C++递归写出斐波那契数列呢？给点提示就行", "Tag": "算法分析"}
{"Answer": "你是要存储到数组吗？\n\nvoid f(int *a,int n)\n{\n    a[0] = 1;\n    a[1] = 1;\n\n    for(int k=2;k<=n;k++)\n    {\n        a[k] = a[k-1] + a[k-2];\n    }\n}\n\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    int *a = (int*)malloc(n*sizeof(int));\n    f(a,n);\n    for(int i=0;i<n;i++)\n        printf(\"%d \",a[i]);\n    return 0;\n}\n ", "Konwledge_Point": "Fibonacci数列", "Question": "用数组来处理求Fibonacci数列问题，要求结合调用函数来编写程序\n不会写程序，数组和调用函数不知道如何结合起来处理这个问题，不知道怎么将数组和调用函数整合在一起", "Tag": "算法分析"}
{"Answer": "第21行方法名后面的点去掉", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列使用数组实现\n这个报错了，应该怎么改正", "Tag": "算法分析"}
{"Answer": "因为定义在函数内的系统默认类型变量是在栈中分配内存的，而全局变量是在堆中分配内存的，一般在栈中分配的内存远小于在堆中分配的内存，所以在函数中\r\n定于数组变量所占的内存大小大于所能容纳最大容许分配的栈空间，所以会出现运行错误。如果你把第二个函数中的数组大小改小就可以了。如果觉得解释的\r\n不错，请点赞，谢谢。", "Konwledge_Point": "Fibonacci数列", "Question": "Fibonacci数列 (蓝桥杯试题集)\n#include \n\nusing namespace std;  \n\n#define mod 10007     //定义除数  \n#define max 1000001  //定义数组长度  \n\nint n,i,F[max];  \n\nint main()  \n{  \n    while(cin >> n)\n    {\n        F[1] = F[2] = 1;  \n        for(i = 3;i <= n;i ++)  \n        {  \n            F[i] = (F[i - 1] + F[i - 2]) % mod;  \n        }  \n        cout << F[n] << endl;\n    }\n\n    return 0;  \n}  \n\n\n\n\n\n\n这样就正确，下面这样就不能运行，为什么呢？求解\n\n\n\n #include \n\nusing namespace std;  \n\n#define mod 10007     //定义除数  \n#define max 1000001  //定义数组长度  \n\n\n\nint main()  \n{  \n        int n,i,F[max];  \n    while(cin >> n)\n    {\n        F[1] = F[2] = 1;  \n        for(i = 3;i <= n;i ++)  \n        {  \n            F[i] = (F[i - 1] + F[i - 2]) % mod;  \n        }  \n        cout << F[n] << endl;\n    }\n\n    return 0;  \n}  \n\n\n", "Tag": "算法分析"}
{"Answer": "n=int(input())\na=[1,1]\nfor i in range(2,n):\n    a.append(a[i-1]+a[i-2])\nprint(','.join([str(i) for i in a]))\n", "Konwledge_Point": "Fibonacci数列", "Question": "python求斐波那契数列Ⅰ，求前n项，n的值从键盘输入\n求斐波纳契（Fibonacci）数列：1，1，2，3，5， 8的前n项，n的值从键盘输入", "Tag": "算法分析"}
{"Answer": "\na = 0\nb = 1\nf=[]\nfor i in range(50):\n    a, b = b, a + b\n    f.append(a)\nprint(f)\n\n#\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049, 12586269025]\n ", "Konwledge_Point": "Fibonacci数列", "Question": "N个斐波那契数列的输出，要列表\n数学中有一个有名的数列，叫做斐波那契数列，它的第n项的值(n >= 0)：\n\n\n\nF(0)=1，F(1)=1，F(n)=F(n-1)+F(n-2) (n >=2)\n\n\n\n（要求：使用一个长度为50的列表存放斐波那契数列的前面50项，将这个列表打印出来）", "Tag": "算法分析"}
{"Answer": "public static long CalcA(int n)\r\n{\r\n  if (n <= 0) return 0;\r\n  if (n <= 2) return 1;\r\n  return checked(CalcA(n - 2) + CalcA(n - 1));\r\n}", "Konwledge_Point": "Fibonacci数列", "Question": "算法题求解Fibonacci数列\n若有一只兔子每个月生一只小兔子，一个月后也开\n\n始生产。起初只有一只兔子，一个月后就有两只兔子，二个月后就有三只兔子，三个月后有五只兔子(小兔子投入\n\n生产)……", "Tag": "算法分析"}
{"Answer": "因为在中间运算的过程中，比如说 a + b 算出来的数超过 int 的范围的话，会导致存入 c 中的数出现错误，从而导致接下来的计算出现错误，所以需要在每一步都给他 % 上 10007，这样才能保证数不会出现错误。（斐波那契在后面的增长速度非常快）tips ： 在每一步都 % 上 10007，这样所以运算的数都在0 ~ 10007 ，只会在这个数范围内进行相加减，不会爆范围问题。相当于只进行斐波那契数中的所有数在 0 ~ 10007 范围内的运算，可以自己写几个数试试。", "Konwledge_Point": "Fibonacci数列", "Question": "蓝桥杯基础练习--Fibonacci数列\n问题遇到的现象和发生背景\n\n\n问题描述\nFibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。\n当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。\n输入格式\n输入包含一个整数n。\n输出格式\n输出一行，包含一个整数，表示Fn除以10007的余数。\n**说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。\n**\n\n\n问题相关代码，请勿粘贴截图\n\n\n只通过部分用例：\nimport java.util.*;\n\n\npublic class Main {\n\n\npublic\n static \nvoid\n main(String[] args) {\n    // TODO Auto-\ngenerated\n \nmethod\n stub\n    Scanner \nin\n = \nnew\n Scanner(\nSystem\n.\nin\n);\n    \nint\n n = \nin\n.nextInt();\n    \nint\n a = \n1\n;\n    \nint\n b = \n1\n;\n    \nint\n c = \n0\n;\n    \nif\n(n == \n1\n||n==\n2\n)\n        c = \n1\n;\n    \nelse\n\n        \nfor\n(\nint\n i = \n3\n;i<=n;i++) {\n            c = a + b;\n            a = b;\n            b = c;\n        }\n    \nSystem\n.\nout\n.println(c%\n10007\n);\n}\n\n\n\n}\n可以通过全部用例：\nimport java.util.*;\n\n\npublic class Main {\n\n\npublic static void main(String[] args) {\n    Scanner \nin\n = new Scanner(System.\nin\n);\n    int \nn\n = \nin\n.nextInt();\n    int \na\n = \n1\n;\n    int \nb\n = \n1\n;\n    int \nc\n = \n0\n;\n    \nif\n(\nn\n == \n1\n||\nn\n == \n2\n)\n        \nc\n = \n1\n;\n    \nelse\n\n        for(int \ni\n = \n3\n;i<=n;i++) {\n            \nc\n = (a + b)%\n10007\n;\n            \na\n = b%\n10007\n;\n            \nb\n = c%\n10007\n;\n        }\n    System.out.println(c);\n}\n\n\n\n}\n\n\n运行结果及报错内容\n\n\n我的解答思路和尝试过的方法\n\n\n在遇到本题后首先是想用递归先求出第n个斐波那契数，再对10007取余，但提交后显示运行超时。于是我想到可能是因为递归耗时过多，便采用了非递归，提交后只有部分测试用例通过。之后又仔细看了题目和说明，便直接在求斐波那契数列的过程中求出了该斐波那契数对10007取余的结果，提交后通过全部测试用例。\n\n\n我想要达到的结果\n\n\n之后在网上查找看了很多资料，但还是不太明白直接在过程中求余数和先算出斐波那契数在求余有什么区别，麻烦有知道的人解答一下，谢谢！", "Tag": "算法分析"}
{"Answer": "\nl = []\nfor i in range(20):\n    if i == 0 or i == 1:\n        l.append(int(1))\n    else:\n        l.append(l[-2]+l[-1])\n\nfor i in range(len(l)):\n    if (i + 1) % 5 == 0:\n        print(l[i])\n    else:\n        print(l[i], end=',')\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "编程显示Fibonacci数列\n编程显示Fibonacci数列：1、1、2、3、5、8……的前20项。要求每行显示5项。", "Tag": "算法分析"}
{"Answer": "因为数值过大超出了c语言的数值范围\n改成unsigned long c=1可以计算到1002，但再大还是会出错\n", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列想问一下为什么到输入到1002就变成负数了\n为什么到输入到1002就变成负数了\n\n\n问题相关代码，请勿粘贴截图\n\n\n前1000都是正常输出\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果\n\n\n#include \n\nusing namespace std;\n\nint main()\n{\n    int \na\n=0,b=0,c=1,n;\n    cin >> n;\n    \nfor\n(int \ni\n=1;i<=n;i++)\n    {\n        \na\n=b;\n        \nb\n=c;\n        \nc\n=a+b;\n    }\n     cout << c << endl;\n } \n\n", "Tag": "算法分析"}
{"Answer": "public class Test {    public static void main(String[] args) {        int arr[] = new int[100];        arr[0] = arr[1] = 1;        System.out.println(\"斐波那契数列前20项为：\");        System.out.print(arr[0] + \"\\t\" + arr[1] + \"\\t\");        for (int i = 2; i < arr.length; i++) {            arr[i] = arr[i - 1] + arr[i - 2];            System.out.print(arr[i] + \"\\t\");            if ((i + 1) % 10 == 0)                System.out.println();        }  \n}\n\n}", "Konwledge_Point": "Fibonacci数列", "Question": "输出斐波那契数列前100项，每10项换行输出\n请各位大大帮帮忙\n输出斐波那契数列前100项，每10项换行输出", "Tag": "算法分析"}
{"Answer": "\n#include <iostream>\nusing namespace std;\n\nvoid Fibonacci(long long *x, int n)\n{\n    if (n == 1 || n == 2)\n    {\n        *x = 1;\n        return;\n    }\n    long long a, b;\n    Fibonacci(&a, n - 1);\n    Fibonacci(&b, n - 2);\n    *x = a + b;\n}\nint main()\n{\n    long long a, sum = 0;\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n    {\n        a = 0;\n        Fibonacci(&a, i);\n        // cout << a << \" \";\n        sum += a;\n    }\n    // cout << endl;\n    cout << sum;\n    return 0;\n}\n", "Konwledge_Point": "Fibonacci数列", "Question": "采用地址传递的方式编写一个递归函数，求斐波那契数列的第N项，并调用此函数求这个数列前N项的和\n如何采用地址传递的方式\n编写一个递归函数，求斐波那契数列的第N项，并调用此函数求这个数列前N项的和\n\n\n地址传递与递归如何同时使用", "Tag": "算法分析"}
{"Answer": "我用#CSDN#这个app发现了有技术含量的博客，小伙伴们求同去《斐波那契数列 C语言 数组 非数组 函数》, 一起来围观吧 https://blog.csdn.net/weixin_62264287/article/details/122829674?utm_source=app&app_version=5.0.1&code=app_1562916241&uLinkId=usr1mkqgl919blen", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列  递推方法！\n，斐波那契数列以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n - 1)+F(n - 2)（n≥3，n∈N*）【注意：n<=80】\n\n\n\n\n#\ninclude\n \n\n\n\n\nlong\n \nlong\n \nfib\n(\nint\n n)\n;\n\nint\n \nmain\n(\nvoid\n)\n \n{\n    \nint\n n;\n    \nscanf\n(\n\"%d\"\n,&n);\n    \nprintf\n(\n\"fib(%d)=%lld\"\n,n,\nfib\n(n));\n    \nreturn\n \n0\n;\n}\n\n/*提交以下代码*/\n\n\n\nlong\n \nlong\n \nfib\n(\nint\n n)\n \n{\n\n}\n", "Tag": "算法分析"}
{"Answer": "\n斐波那契数列 --- 四层优化 - zkfopen - 博客园\n斐波那契数列 起源 兔子问题：“假定一对大兔子每月能生一对小兔子，且每对新生的小兔子经过一个月可以长成一对大兔子,具备繁殖能力，如果不发生死亡，且每次均生下一雌一雄，问一年后共有多少对兔子？” 分析:\n\n\n\nhttps://www.cnblogs.com/zkfopen/p/11245857.html\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "C语言 按以下要求编写程序 fibonacci数列\n编写程序求fibonacci数列，有40阶楼梯，从底往上爬，每次爬1阶或2阶，编算法说明共有多少走法。", "Tag": "算法分析"}
{"Answer": "def febo(n):\n    if n <= 2:\n        return 1\n    else:\n        return febo(n - 1) + febo(n - 2)\nfor i in range(1, int(input())+1):\n    print(febo(i),end=' ')\n", "Konwledge_Point": "Fibonacci数列", "Question": "求斐波那契数列的前n项\n求斐波那契数列的前n项，n的值从键盘输入。例如，10\n1，1，2，3，5，8，13，21，34，55", "Tag": "算法分析"}
{"Answer": "第一个问题，在for循环里，首先给i赋值为0，然后判断f[0]和m的大小关系，发现f[0]<m 不成立，于是跳出for循环，顺序执行后面的代码\r\n第二个问题，最后一个for循环改成这样：\r\n```\r\n for (; f[i]<=n; i++)\r\n        printf(\"%d \",f[i]);\r\n```", "Konwledge_Point": "Fibonacci数列", "Question": "C语言问题求解答，帮忙看一下这个编程~~~~ \n输出[m,n]范围内的所有斐波那契（Fibonacci）数，m,n这两个数由键盘输入。\n\n【提示】\n\n1,1,2,3,5,8,13,21,34,……这是斐波那契（Fibonacci）数列的前几项。斐波那契数列的特点：前两项均为1，后面任意一项都是其前面两项之和。\n\n本实验虽然只要求输出在[m,n]范围内的斐波那契数，但是依然需要从第1个Fibonacci数开始依次得到下一个，并判断是否是需要输出的那个。\n\n#include\n\nint main()\n\n{\n\nint f[100];\n\nint m, n, i;\n\nf[0] = 1; f[1] = 1;\n\nfor (i = 2; i < 100; i++)\n\n{\n\n    f[i] = f[i - 1] + f[i - 2];\n\n}\n\nscanf(\"%d%d\", &m, &n);\n\nfor (i = 0; f[i] < m; i++);\n\nfor (; f[i]<n; i++) \n\n    printf(\"%d \",f[i]);\n\n\n\nreturn 0;\n\n}\n\n两个疑问\n\n第一个疑问： 你看这个程序 ，我输入 1 3 ，也就是m是1，n是3，运行第二个for时，f[0]<m 不成立 那么程序会怎么样走呢，整个程序也就一个printf 但也要第三个for成立时候才能执行，那要是之前不成立呢，程序怎么运行？\n\n第二个疑问 \n\n我输入 1 3 输出 1 1 2，怎么改能让他输出 1 1 2 3或者 1 2 3 呢？", "Tag": "算法分析"}
{"Answer": "\n#include<stdio.h>\n//先声明函数\nint fun(int n);\n\nint main()\n{\n    int n;\n    printf(\"请输入要输出多少项（自然数）斐波那契数列：\");\n    scanf(\"%d\",&n);\n    //int *a = (int *)malloc((n+1)*sizeof(int));//如需存储，使用动态内存分配n+1个空间进行存储\n    int i;\n    for (i = 0; i < n+1; i++)         //输出所有项\n    {\n        printf(\"%d, \", fun(i));\n        if (i != 0 && i%5 == 0)     //每五项进行一次换行（第一行多一个第0项）\n            printf(\"\\n\");\n    }\n    printf(\"第 %d 项是：%d\\n\", n, fun(n)); //输出要求的项\n    return 0;\n}\n\nint fun(int n)      //n代表第几项。特别指出：0是第0项，不是第1项。\n{\n    if (n <= 1)\n        return n;\n    else\n        return fun(n-1) + fun(n-2);\n}\n \n\n ", "Konwledge_Point": "Fibonacci数列", "Question": "使用C语言用递归法求斐波那契数列，（套用函数）\n不知道怎么编写函数\n\n\n\n#include\n\nint fun(int n)      //n代表第几项。特别指出：0是第0项，不是第1项。\n\n{\n\n    if (n <= 1)\n\n        return n;\n\n    else\n\n        return fun(n-1) + fun(n-2);\n\n}\n\n \n\n\nint main()\n\n{\n\n    int n;\n\n    printf(\"请输入要输出多少项（自然数）斐波那契数列：\");\n\n    scanf(\"%d\",&n);\n\n    //int *a = (int *)malloc((n+1)*sizeof(int));//如需存储，使用动态内存分配n+1个空间进行存储\n\n    int i;\n\n    for (i = 0; i < n+1; i++)         //输出所有项\n\n    {\n\n        printf(\"%d, \", fun(i));\n\n        if (i != 0 && i%5 == 0)     //每五项进行一次换行（第一行多一个第0项）\n\n            printf(\"\\n\");\n\n    }\n\n    printf(\"第 %d 项是：%d\\n\", n, fun(n)); //输出要求的项\n\n    return 0;\n\n}\n\n如果把int main()放在头文件的下面这个程序该怎么改\n\n\n\n谢谢您", "Tag": "算法分析"}
{"Answer": "#include<stdio.h>\nint main() {\n    int i,f1=0,f2=1,f3,cnt=0;\n    printf(\"%d %d \",f1,f2);\n    for(i=3;i<=20;i++){\n        f3=f1+f2;\n        printf(\"%d \",f3);\n        cnt++;\n        f1=f2;\n        f2=f3;\n        if(cnt%5==0)printf(\"\\n\");\n    }\n    return 0;\n}\n", "Konwledge_Point": "Fibonacci数列", "Question": "有关C语言的斐波那契数列\n斐波纳契数列中的头两个数分别是0,1，从第3个数开始，每个数等于前两个数的和。即0,1,1,2,3…求该数列前20个数，要求每行输出5个。不能用数组。", "Tag": "算法分析"}
{"Answer": "可以，这种方法没有问题，只是用列表保存所有的值，会占用内存空间。如果题目要求空间复杂度是O(1)的就不符合题目要求了", "Konwledge_Point": "Fibonacci数列", "Question": "用python编写斐波那契数列的方法很多，这种方法有什么问题吗\n用python编写斐波那契数列的方法很多，采用这种方式编写会有什么弊端吗？", "Tag": "算法分析"}
{"Answer": "//递归算法\r\nlong long Fibonacci(unsigned int n)\r\n{\r\n\tif (n < 0)\r\n\t\treturn 0;\r\n\tif (n == 1)\r\n\t\treturn 1;\r\n\treturn Fibonacci(n - 1) + Fibonacci(n - 2);\r\n}\r\n\r\n//非递归算法\r\nlong long Fibonacci(unsigned int n)\r\n{\r\n\tint result[2] = { 0,1 };\r\n\tif (n < 2)\r\n\t\treturn result[n];\r\n\tlong long fibone = 1;\r\n\tlong long fibtwo = 0;\r\n\tlong long fibn = 0;\r\n\tfor (unsigned int i = 2; i <= n; i++)\r\n\t{\r\n\t\tfibn = fibone + fibtwo;\r\n\t\tfibtwo = fibone;\r\n\t\tfibone = fibn;\r\n\t}\r\n\treturn fibn;\r\n}", "Konwledge_Point": "Fibonacci数列", "Question": "Fibonacci数列大数处理\n如何输出大数的fibonacci数列?分别用递推，递归的算法实现", "Tag": "算法分析"}
{"Answer": "问题处在input的返回值上，在python2里边会根据你的输入返回不同的类型，如果你输入整数，这返回的是一个整型，但是eval需求的是str类型，所以会报错。\r\npython3中，input所有的数据都会转化为str返回，所以在python3中，eval不报错。\r\n\r\nint（）函数的参数可以是str，也可以是整型，所以使用int（）时没有报错。", "Konwledge_Point": "Fibonacci数列", "Question": "python 求斐波那契数列，用int()和eval()得出来的结果为什么不同\n一个求斐波那契数列的程序，报错说eval的参数不是string，我明明是string啊？？\n\n\n\ndef fbnq(a):\n    n=eval(a)\n    if type(n)==type(1):\n        if n==0:\n            return 0\n        elif n==1:\n            return 1\n        else:\n            return fbnq(n-1)+fbnq(n-2)\ndef main():\n    a=input('请输入求解第几项:')\n    print(fbnq(a))\nmain()\n\nTraceback (most recent call last):\nFile \"E:\\a python\\No.2\\1.py\", line 13, in \nmain()\nFile \"E:\\a python\\No.2\\1.py\", line 12, in main\nprint(fbnq(a))\nFile \"E:\\a python\\No.2\\1.py\", line 9, in fbnq\nreturn fbnq(n-1)+fbnq(n-2)\nFile \"E:\\a python\\No.2\\1.py\", line 2, in fbnq\nn=eval(a)\nTypeError: eval() arg 1 must be a string, bytes or code object\n\n\n\n\n\n然后我把eval()换成int()就正常输出了，为什么？？\n\n\n\ndef fbnq(a):\n    n=int(a)\n    if type(n)==type(1):\n        if n==0:\n            return 0\n        elif n==1:\n            return 1\n        else:\n            return fbnq(n-1)+fbnq(n-2)\ndef main():\n    a=input('请输入求解第几项:')\n    print(fbnq(a))\nmain()\n\n", "Tag": "算法分析"}
{"Answer": "int fib( int n )//返回第几位的斐波那契数 \n{\n    int i=0,a=0,b=1,c;\n    while(i<n)//使用i来判断第几位 这里我们从0 1开始计数因此需要考虑特殊情况 这里的数字经过测试应该是没有第0个数字一说的。 \n    {\n        if(i==1)\n            c=1;\n        else\n        {\n             c=a+b;\n            a=b;\n            b=c;\n        }\n        i+=1;\n    }\n    return c;\n}\n\n\n\n你看看可以不", "Konwledge_Point": "Fibonacci数列", "Question": "关于c语言斐波那契数列的实现\n\nunsigned long \nFibonacci(\nunsigned\n \nn\n)\n\n{\n    \nif\n (n > \n2\n)\n        return \nFibonacci(\nn\n - 1)\n + \nFibonacci(\nn\n - 2)\n;\n    \nelse\n\n        return \n1\n;\n}\n\n\n\n这是使用双递归的方法去实现斐波那契数列\n我想问一下，能不能用循环去实现呢，输入一个正整数，然后得到对应位置的斐波那契数", "Tag": "算法分析"}
{"Answer": "你要边算边取余，不是算到最后一起取余一个对n余数为a的数加一个对n余数b的数，两数相加对n取余余数是a+b，可以证明把第一个数记为xn+a,第二个数记为yn+b两数相加是xn+yn+a+b，取余之后xn和yn都没了，就是a+b", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列超大数用什么整型?\n我要求斐波那契数列第100000000项的取余，但是用longlong或者double转int取余都不行，输出是负数，，还有更大的整型吗？还是说问题其实不在这里?", "Tag": "算法分析"}
{"Answer": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\nstring line;\nwhile( getline(cin, line)){\n    cout << line << endl;\n    int n = atoi(line.c_str());\n    int a1 = 0,a2 = 1,a3;\n    for(int i=2;i<=n;i++)\n    {\n        a3 = a2+a1;\n        a1=a2;\n        a2=a3;\n    }\n    cout<<a3<<endl;\n}\nreturn 0;\n}\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "如何用C++写出斐波那契数列\n请问如何用C++写出斐波那契数列，F（0）=0；F（1）=1；F（n）=F（n-1）+F（n-2），n大于1\n例如input是5，output为5\ninput为12，output 为144\n代码开头为\n#include \n#include \nusing namespace std;\n\n\nint main() {\n   string line;\n   while( getline(cin, line)){\n        cout << line << endl;\n  }\n}", "Tag": "算法分析"}
{"Answer": "用c++随便写的\r\n#include\r\n#include \r\n#include \r\nusing namespace std;\r\nint main()\r\n{\r\n\tint sum=1;\r\n\tint *a = new int[10];\r\n\tvectorv;\r\n\ta[0] = 0;\r\n\ta[1] = 1;\r\n\tfor (int i = 2; i < 10; i++)\r\n\t{\r\n\t\ta[i] = a[i - 1] + a[i - 2];\r\n\t\tv.push_back(a[i]);\r\n\t}\r\n\tsum+=accumulate(v.begin(), v.end(), 0);\r\n\tcout << sum << endl;\r\n\treturn 0;\r\n}", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列求和～～～～～\n如何用C语言程序求斐波那契数列的前10项和，哪位大牛帮帮忙。还有什么水仙花问题", "Tag": "算法分析"}
{"Answer": "def fib(n):\n    if n<=2:\n        return 1\n    else:\n        return fib(n-1)+fib(n-2)\nif __name__ == '__main__':\n    print(fib(int(input('输入n的值'))))\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "使用函数实现斐波那契数列的第n项，并在主程序中调用，用户从键盘输入n的数值，程序打印显示对于的斐波那契数列项\n提示文本及输出文本要和样例一致，否则会被判错\n提示输入n的值8\n结果：21 ", "Tag": "算法分析"}
{"Answer": "\nn1 = 0\nn2 = 1\ncount = 1\nwhile True:\n    nth = n1 + n2\n    n1 = n2\n    n2 = nth\n    count += 1\n    if nth>1000:\n        print(count)\n        break\n ", "Konwledge_Point": "Fibonacci数列", "Question": "兔子养殖场可饲养1000对兔子。如果有一对小兔子，按照斐波那契数列，求兔子在第几个月就放不下了。\n你建了一个兔子养殖场，能同时饲养1000对兔子。如果你现在有一对小兔子，按照斐波那契数列，求兔子在第几个月就放不下了。", "Tag": "算法分析"}
{"Answer": "void fibo(int a[],int n )\n{\n    a[0]=1;\n    a[1]=1;\n    int s;\n    for(s=2;s<n;s++)\n    {\n        a[s]=a[s-1]+a[s-2];\n    }\n    \n}", "Konwledge_Point": "Fibonacci数列", "Question": "C++:本题要求实现求Fabonacci数列项的函数?\n本题要求实现求Fabonacci数列项的函数。\n\n\n\nFabonacci数列的定义如下：f(n)=f(n-2)+f(n-1) (n≥2)，其中：f(0)=1，f(1)=1。\n\n\n\n函数接口定义：\n\n\n\n\n\nvoid fibo(int a[],int n );\n\n\n\n\n其中数组 \na\n最终存储计算出的斐波那契数列的值。参数\nn\n是计算前n项。\n\n\n\n裁判测试程序样例：\n\n\n\n\n\n#include \nusing namespace std;\nvoid fibo(int a[],int n ); \nint main()\n{\n    int a[20],n,i;\n    cout<<\"请输入n（<=20）：\";\n    cin>>n;\n    fibo(a,n);\n    for(i=0;i<n;i++)\n        cout<<a[i]<<\"  \";\n    cout<<endl;\n    return 0;\n}\n/* 你的代码将被嵌在这里 */\n\n\n\n输入样例：\n\n\n\n\n\n请输入n（<20）：5\n\n\n\n输出样例：\n\n\n\n\n\n1 1 2 3 5 ", "Tag": "算法分析"}
{"Answer": "迭代就是，已知前两个月的数量求第三个月的数量，为了节省空间，前两个月的数量可以用2个变量来表示，每次只要修改一下这两个变量。自己debug一下就懂了", "Konwledge_Point": "Fibonacci数列", "Question": "python关于斐波那契数列的实现，举例计算小兔子的数量，用迭代的方法没搞明白\npython关于斐波那契数列的实现，举例计算小兔子繁衍的数量，第一个月数量为1，第二个月数量为1，第三个月开始，当月数量等于前两个月数量之和，计算第20个月的时候一共多少只兔子。用递归的方法能想明白，但是用迭代的方法有些地方看不懂，请各位指教。\n\n\n\n\n# 递归方法实现\n\n\ndef\n fab(n):\n    \nif\n n < \n1\n:\n        \nprint\n(\n\"输入有误\"\n)\n        \nreturn\n -\n1\n\n\n    \nif\n n == \n1\n or n == \n2\n:\n        \nreturn\n \n1\n\n    \nelse\n:\n        \nreturn\n fab(n-\n1\n) + fab(n-\n2\n)\n\n\nresult\n = fab(\n20\n)\n\nif\n result != -\n1\n:\n    \nprint\n(result)\n\n\n", "Tag": "算法分析"}
{"Answer": "int i=0,j=1,这是数组的前两项，k=几无所谓，只要max-k=14就行，循环里每次打印两项，所以k = k+2，然后i = i+j，用当前两项计算下一项，j=i+j，用当前后一项和下一项求下下项，其实你按逻辑单步调试一下就很明白了", "Konwledge_Point": "Fibonacci数列", "Question": "计算Fibonacci序列的前16项。\n为什么要int i=0,j=1,k=1，这个程序里的循环体也没有看懂，为什么要这样", "Tag": "算法分析"}
{"Answer": "clearsca x = 1sca y = 0sca k = 0sca i = 1while(i<11){di xsca k = xsca x = x+ysca y = ksca i=i+1}", "Konwledge_Point": "Fibonacci数列", "Question": "如何在stata输出斐波那契数列前十项\n 想要得到数据 然后赋值出现问题（朋友和我说不能赋值）\ngenerate x = 1\ngenerate y = 0\ngenerate k = 0\nlocal i =1\nwhile(\ni'<11){     display x     gen k = x     gen x = x+y     gen y = k     local i=\ni'+1\n}\n现在很苦恼哎", "Tag": "算法分析"}
{"Answer": "\n#include<stdio.h>\n#define F1 300\n#define F2 1000\nint main()\n{\n    int F[F1][F2]={0};\n    int k;\n    scanf(\"%d\",&k);\n    F[0][F2-1]=0;\n    F[1][F2-1]=1;\n    for(int d=2;d<k;d++)\n    {\n        for(int i=F2-1;i>=0;i--)\n           {\n              F[d][i]=F[d-1][i]+F[d-2][i];\n            }\n        int r=F2-1;\n        while(r>=0){\n            if(F[d][r]>=10)\n            {\n                F[d][r-1]+=1;\n                F[d][r]=F[d][r]-10;\n            }\n            r--;\n            }\n    }\n    int j=0;\n    while(j<F2)\n    {\n        if(F[k-1][j]!=0)\n        {\n            while(j<F2)\n            {\n                printf(\"%d\",F[k-1][j]);\n                j++;\n            }\n        }\n    j++;\n    }\n     return 0;\n}\n\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "用C语言（不是C++）求解Fibonacci数列的第110项、第200项的值。\n用C语言（不是C++）求解Fibonacci数列的第110项、第200项的值。", "Tag": "算法分析"}
{"Answer": "先将数列存储到数组，然后倒过来数10个数出来\n#include <stdio.h>\nint main()\n{\n    int a[10000];\n    int n=2,i=0,j=0;\n    int t;\n    scanf(\"%d\",&t);\n    a[0] = a[1] = 1;\n    while(1)\n    {\n        a[n] = a[n-1] + a[n-2];\n        if(a[n] > t)\n            break;\n        n++;\n    }\n    if(n>10)\n        i=n-10;\n    for(;i<n;i++)\n    {\n        printf(\"%d \",a[i]);\n        j++;\n        if(j%5==0)\n            printf(\"\\n\");\n    }\n    return 0;\n}\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列，输入一个个t，求小于t的最大十个数，每5个一行\n斐波那契数列，输入一个个t，求小于t的最大十个数，每5个一行", "Tag": "算法分析"}
{"Answer": "\n#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n\tios::sync_with_stdio(false);\n\tunsigned long long dp[51];\n\tdp[1]=dp[2]=1;\n\tint n;\n\tcin>>n;\n\tfor(int i=3;i<=n;i++)\n\t{\n\t\tdp[i]=dp[i-1]+dp[i-2];\n\t}\n\tcout<<dp[n];\n}\n ", "Konwledge_Point": "Fibonacci数列", "Question": "c语言求图形Fibonacci\n求Fibonacci数列的前40项。Fibonacci数列的特点是：  \n\n第1项是1；  \n\n第2项是1；  \n\n以后各项都等于前两项的和。 \n\n\n\n\n\n\n请编制程序输出Fibonacci数列的前40项，每行4列，第一列和第三列宽度为12个字符，第二列和第四列宽度为13个字符。最后一条输出后，不要再输出回车换行符。", "Tag": "算法分析"}
{"Answer": "有两个小问题，改正如下：\n\nunsigned long fibonacci1(unsigned m)\n{\n    int i;\n    unsigned long pol, num[2] = { 1,1 };\n    if (m >= 2)   //将i>2换成m>= 2\n    {\n        for (i = 2; i <=m; i++)   //将i<m换成i<=m\n        {\n            pol = num[0] + num[1];\n            num[0] = num[1];\n            num[1] = pol;\n        }\n        return pol;\n    }\n    else\n    {\n        return 1;\n    }\n}\n", "Konwledge_Point": "Fibonacci数列", "Question": "用循环计算斐波那契数列（fibonacci），我自己写了一个，找不出错误。\nunsigned long fibonacci1(unsigned m)\n{\n    int i;\n    unsigned long pol,num[2]={1,1};\n\n\nif\n(i>\n2\n)\n{\n    \nfor\n(i=\n2\n;i<m;i++)\n    {\n        pol=\nnum\n[\n0\n]+\nnum\n[\n1\n];\n        \nnum\n[\n0\n]=\nnum\n[\n1\n];\n        \nnum\n[\n1\n]=pol;\n    }\n    \nreturn\n pol;    \n}\n\nelse\n \n{\n    \nreturn\n \n1\n;\n}\n\n\n\n}", "Tag": "算法分析"}
{"Answer": "def fib(n):\n    f1,f2 = 1,1\n    for i in range(0,n):\n        f1,f2 = f2,f1+f2\n    return f1\n\nn = int(input())\ni = 0\nwhile fib(i)<=n:\n    i += 1\n\nprint(f'第{i-1}个,值为{fib(i-1)}')\n", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数斐波那契数列1,2,3,5813根据这样的规律，编程求出输入的数以内最大的斐波那契数，并求出他是第几个斐波那契数\n。\n输入格式:最大范围数值输出格式:第m个,值为n输入样例:1000输出样例：第十五个，值为987\n\n", "Tag": "算法分析"}
{"Answer": "帮你找了个相似的问题, 你可以看下: https://ask.csdn.net/questions/7618555我还给你找了一篇非常好的博客，你可以看看是否有帮助，链接：矩阵求斐波那契数列第n项", "Konwledge_Point": "Fibonacci数列", "Question": "求斐波那契数列第n项是否为素数，一直报错，麻了\n\n\nimport\n java.util.Scanner;\n\npublic\n \nclass\n Main {\n    \npublic\n static \nvoid\n main(String[] args) {\n        Scanner sc = \nnew\n Scanner(\nSystem\n.\nin\n);\n        \nint\n n = sc.nextInt();\n        \nif\n(n < \n3\n) \nSystem\n.\nout\n.print(\"false\");\n        \nelse\n {\n            \nint\n ans = \n0\n;\n            \nint\n ans2 = \n0\n;\n            \nint\n a[] = \nnew\n \nint\n[\n1005\n];\n            a[\n1\n] = \n1\n;\n            a[\n2\n] = \n1\n;\n            \nfor\n (\nint\n i = \n3\n; i <= n; i++) {\n                a[i] = a[i - \n1\n] + a[i - \n2\n];\n            }\n            \nfor\n (\nint\n i = \n2\n; i < a[n]; i++) {\n                \nif\n (a[n] % i != \n0\n) ans++;\n            }\n            \nfor\n (\nint\n i = \n2\n; i < a[n]; i++) {\n                ans2++;\n            }\n            \nif\n (ans == ans2) \nSystem\n.\nout\n.print(\"true\");\n            \nelse\n \nSystem\n.\nout\n.print(\"false\");\n        }\n\n    }\n}\n\n", "Tag": "算法分析"}
{"Answer": "首先你要知道斐波那契数列的规律也就是0、1、1、2、3、5、8、13、21、……,通过这个就可以知道从第三个元素开始，他的值等于前面两个元素的和，下面分析代码\r\n\r\nlong fib[41] = {0,1};   定义了一个数组，设置了0 1 坐标元素的值为 0 1\r\n\r\nfor (i=2;i<41;i++) fib[i] = fib[i-1]+fib[i-2];  这个循环是冲i等于2开始运算的，也就是数组的第三个元素，fib[i] = fib[i-1]+fib[i-2]  因为斐波那契数列的规律是从第三个元素开始等于前面两个相加，也就是fib[i-1]，fib[i-2]这两个\r\n\r\nfor (i=1;i<41;i++) printf(\"F%d==%d\\n\",i,fib[i]); 这里是打印，上面的代码可以看出，数组第一个和第二个元素没有参与运算，但long fib[41] = {0,1};这里已经声明了，所以第一个第二个元素固定为0、1，第三个开始就是前面两个相加。\r\n\r\n不知道说的详细不详细，你明白不明白。", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列 利用循环输出前40项 （初学者）\n我在查了资料之后找到以下解决方法：\n\n#include \n\n　　int main()\n\n　　{\n\n　　long fib[41] = {0,1};\n\n　　int i;\n\n　　for (i=2;i<41;i++) fib[i] = fib[i-1]+fib[i-2];\n\n　　for (i=1;i<41;i++) printf(\"F%d==%d\\n\",i,fib[i]);\n\n　　getch();\n\n　　return 0;\n\n　　}\n\n\n\n有些看不懂，希望可以帮我详细分析一下运算过程，或者提供相关的知识点以供研究。\n\n谢谢。", "Tag": "算法分析"}
{"Answer": "#include<stdio.h>\nint main() {\n    int k1,k2;\n    scanf(\"%d %d\",&k1,&k2);\n    int f1=1,f2=1,s=0,f3,i;\n    if(k1==1) s+=f1;\n    if(k2>=2) s+=f2;\n    for(i=3;i<=k2;i++){\n        f3=f1+f2;\n        f1=f2;\n        f2=f3;\n        if(i>=k1){\n            s+=f3;\n        }\n    } \n    printf(\"%d\",s);\n    return 0;\n}\n", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列求和（按照格式来）\n", "Tag": "算法分析"}
{"Answer": "n大一点的时候，数据会溢出。需要在循环里每次都进行取余操作。\nf3 = (f1+f2)%10007;\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "请问斐波那契数列对10007取余哪里有问题\n", "Tag": "算法分析"}
{"Answer": "#解法一：用join函数\nlist = []\nfor i in range(1,n+1):\n    list.append(i)\nprint(','.join(list))\n\n#解法二：用strip函数\nout = ''\nfor i in range(2,n+1):\n    out +='i'+','\nprint(out.strip(','))\n", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列的前n项\n我的代码是这样的，怎样处理55后面的逗号可以去掉？\n\n", "Tag": "算法分析"}
{"Answer": "溢出了，就是超出了int的取值范围了啊，把类型改成long long吧", "Konwledge_Point": "Fibonacci数列", "Question": "C语言斐波那契数列第45个数错误\n#include\nint main()\n{\nint sum,f1=1,f2=1;\nint i;\nprintf(\"%d\\n%d\\n\",f1,f2);\nfor(i=1;i<=45;i++)\n{\n  sum=f1+f2;\n  f1=f2;\n  f2=sum;\n  printf(\"%d %d\\n\",i,sum);\n}\nreturn 0;\n｝\n\n\nrun code后\n前面正确，后面第45个就开始不正确了\n44 1836311903\n45 -1323752223\n之前以为是超出了int的数值范围\n最后发现不是，不知道为什么", "Tag": "算法分析"}
{"Answer": "", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列的第100个项目\n定义fib（）的函数\n用\nF1 = 1, F2 = 1,\nFn+2 =Fn+1 +Fn的方式\n\n\n求f（100）的数", "Tag": "算法分析"}
{"Answer": "\n    public static void main(String[] args) {\n        int[] arr = new int[21];\n        arr[0] = 0;\n        arr[1] = 1;\n        for (int i = 2; i < 21; i++) {\n            arr[i] = arr[i - 1] + arr[i - 2];\n        }\n        for (int i = 0; i < 21; i++) {\n            System.out.println(arr[i]);\n        }\n    }\n}\n\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "输出前二十项斐波那契数列\n输出前二十项斐波那契数列，运行底下出现了一行这个红色的是什么意思，应该怎么改才是对的呢", "Tag": "算法分析"}
{"Answer": "char数组, 可以显示到100位\r\n\r\n如果感觉效率差可以用动态规划改一下\r\n\r\n```\r\n#include \r\n#include \r\nusing namespace std;\r\n\r\nclass Number {\r\nprivate:\r\n\tchar storage[100];\r\n\tint length;\r\n\r\npublic:\r\n\tNumber(int n) {\r\n\t\tfor (int i = 0; i < 100; i++) {\r\n\t\t\tthis->storage[i] = 0;\r\n\t\t}\r\n\t\tthis->length = 0;\r\n\r\n\t\tint cnt = 0;\r\n\t\tfor (; n > 0; cnt++) {\r\n\t\t\tthis->storage[cnt] = n % 10;\r\n\t\t\tn = (n - this->storage[cnt]) / 10;\r\n\t\t}\r\n\t\tthis->length = cnt;\r\n\t}\r\n\r\n\tint GetLength() {\r\n\t\treturn this->length;\r\n\t}\r\n\r\n\tint GetDigit(int index) {\r\n\t\treturn this->storage[index];\r\n\t}\r\n\r\n\tvoid Print() {\r\n\t\tfor (int i = this->length - 1; i >= 0; i--) {\r\n\t\t\tcout << int(this->storage[i]);\r\n\t\t}\r\n\t\tcout << endl;\r\n\t}\r\n\r\n\tvoid Add(Number that) {\r\n\t\tint length = max(this->length, that.GetLength());\r\n\t\tfor (int i = 0; i < length; i++) {\r\n\t\t\tint sum = this->storage[i] + that.GetDigit(i);\r\n\t\t\tif (sum < 10) {\r\n\t\t\t\tthis->storage[i] = sum;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis->storage[i] = sum - 10;\r\n\t\t\t\tthis->storage[i + 1]++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (int i = 99; i >= this->length; i--) {\r\n\t\t\tif (this->storage[i] != 0) {\r\n\t\t\t\tthis->length = i + 1;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nvoid f(int n) {\r\n\tif (n == 0 || n == 1) {\r\n\t\tcout << 1 << endl;\r\n\t\treturn;\r\n\t}\r\n\r\n\tauto a = Number(1);\r\n\tauto b = Number(1);\r\n\tfor (int i = 1; i < n; i++) {\r\n\t\tif (i % 2 == 1) {\r\n\t\t\ta.Add(b);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tb.Add(a);\r\n\t\t}\r\n\t}\r\n\r\n\tif (n % 2 == 0) {\r\n\t\ta.Print();\r\n\t}\r\n\telse {\r\n\t\tb.Print();\r\n\t}\r\n}\r\n\r\n\r\nint main()\r\n{\r\n\tfor (int i = 0; i < 80; i++) {\r\n\t\tf(i);\r\n\t}\r\n}\r\n```", "Konwledge_Point": "Fibonacci数列", "Question": "请教一个问，写了斐波那契数列，想显示第80项，尝试了改为long没有效果，该怎么改进呢？谢谢大家！\n#include \nusing namespace std;\n\nlong f(int n)\n{\n    long f , g, v;\n    f = g = 1;\n\n    if (n == 0 || n == 1)\n        return 1;\n    else \n        while ( 0 < n--)\n        {\n            v = f + g;\n            g = f;\n            f = v;\n        }\n    return g;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n\n    while ( !(0 <= n && n <= 80) )\n    {\n        printf(\"重新输入！\\n\");\n        cin >> n;\n    }\n\n    cout << f(n) << \"\\n\";\n\n    system(\"pause\");\n    return 0;\n}\n", "Tag": "算法分析"}
{"Answer": "你的n不能超过20，超过就内存越界了，你说的随机数\n用这个方法\n\n    int count=70;\n    int N1=1,N2=1;\n    int res=0;\n    for(int i=3;i<=count;++i)\n    {\n        res = N1+N2;\n        N1=N2;\n        N2=res;\n    }\n         \n         \n    printf(\"%d\\n\",res);\n", "Konwledge_Point": "Fibonacci数列", "Question": "编写计算斐波那契数列的第n项（数组）\n\n\n大神帮我看看我写的有啥问题，为啥输出要么是0，要么是个随机很大的数", "Tag": "算法分析"}
{"Answer": "第一个数是1，第二个数是1，这是已经知道的，那么需要算出来的就是第三个到第n个数，总共算n-2次，for里面的i就是用来计数的。。。\r\n每次计算出的结果都是前面两个数的和，第一次计算就是求第一个数和第二个数的和作为第三个数，a=1,b=1,m=a+b=2,算出m以后，为了计算第四个数，那么就把a里面放上第二个数的值，所以放了b\r\nb里面再放上m，也就是第三个数的值，本轮计算结束，到第二次计算了，计算第二个数和第三个数的和作为第四个数，刚好a是第二个数，b是第三个数了，所以表达式还是m=a+b,算出第四个数，然后再往后推。。。直到计算完成", "Konwledge_Point": "Fibonacci数列", "Question": "新手求助：关于菲波那契数问题怎么写？\n菲波那契数\n\n\n\n【题目描述】\n\n菲波那契数列是指这样的数列: 数列的第一个和第二个数都为1，接下来每个数都等于前面2个数之和。给出一个正整数k，要求菲波那契数列中第k个数是多少。\n\n\n\n【输入】\n\n输入一行，包含一个正整数k。（1 ≤ k ≤ 46）\n\n\n\n【输出】\n\n输出一行，包含一个正整数，表示菲波那契数列中第k个数的大小。\n\n\n\n【输入样例】\n\n19\n\n【输出样例】\n\n4181\n\n\n\n#include\nusing namespace std;\nint main()\n{int n,m,a=1,b=1;\ncin>>n;\nfor(int i=1;i<=n-2;i++)\n{\nm=a+b;\na=b;\nb=m;\n}\ncout<<b<<endl;\nreturn 0;\n}\n\n\n\n\n\n看不懂for语句里面的关系，求讲解", "Tag": "算法分析"}
{"Answer": "\n#include<stdio.h>\nint main() {\n    long long a[51];\n    a[0] = a[1] = 1;\n    for (int i = 2; i < 50; ++i)\n        a[i] = a[i - 1] + a[i - 2];\n    printf(\"%lld\", a[49]);\n}\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列求出第50项的值\nF(1)=1，F(2)=1，F(n)=F(n-1)+F(n-2)，试求F(50)值", "Tag": "算法分析"}
{"Answer": "代码如下，后面附加了前15项的测试\n#include<stdio.h>\n\nint Fibonacci(int n)\n{\n    int a = 1;\n    int b = 1;\n    int c;\n    if (n == 1 || n == 2) return 1;\n    for(int i=3;i<=n;i++){\n        c = a+b;\n        a = b;\n        b = c;\n    }\n    return c;\n}\n\nint main () {\n    int n;\n    scanf(\"%d\",&n); \n    printf(\"%d\\n\",Fibonacci(n));\n    \n    printf(\"测试前15项：\\n\");\n    for(int i=1;i<=15;i++)\n        printf(\"F(%d) = %d\\n\",i,Fibonacci(i));\n        \n    return 0;\n}\n\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "为啥我这个计算斐波那契数列的程序没有输出？\n\n\n\n\n我这个程序意思大概是，先令前两项a和b，然后循环一次一下加两项，n也一下加二。然后看最后那个num是奇数还是偶数，要是偶数就输出b，奇数就输出a。可是最后没有输出，哪里卡住了？？", "Tag": "算法分析"}
{"Answer": "num才是你要找的数啊，maxitem是下一个，也就是大于5000的。所以打印num就可以了不过问题是你这输入的a和b都没用到啊，反正初始值肯定是1和1是吗？", "Konwledge_Point": "Fibonacci数列", "Question": "若 Fibonacci 数列的第 n 项记为 fib(a,b,n)，求解\n不知道这个程序出了什么问题，出现的结果非常离谱，希望解答，非常感谢\n\n", "Tag": "算法分析"}
{"Answer": "把y=fib(i)写进循环里否则你的y值一直不变啊", "Konwledge_Point": "Fibonacci数列", "Question": "求解答！利用递归调用法求斐波那契数列前n个数（大一）\n调用函数出错，但又不知道咋改，大佬们可以帮忙看看吗？谢谢啦！\n\n", "Tag": "算法分析"}
{"Answer": "因为那个for循环已经把 i 加到最大了，所以最后输出的时候就是最大值", "Konwledge_Point": "Fibonacci数列", "Question": "c语言递归，函数 斐波拉契函数问题\n输入2以上的数字，则输出极大数？\n标题\nFibonacci数列\n\n\n类别\n函数与递归\n\n\n时间限制\n2S\n\n\n内存限制\n1000Kb\n\n\n问题描述\n有一种形式的Fibonacci数列定义如下：\nF(0)=7\nF(1)=11\nF(n)=F(n-1)+F(n-2)（n>=2）\n\n\n按以下声明写一个函数fib\nint fib(int n);\nfib函数用来计算参数n对应的F(n)。\nfib(n)的返回值是F(n)\n\n\n输入说明\n函数参数为一个整数n（0<=n<40）。\n\n\n输出说明\n函数返回值为整数，表示n对应的F(n)值。\n\n\n输入样例\n2\n\n\n我所写的代码：\n\n\n\n\n#\ninclude\n\n\n\n\nint\n \nmain\n()\n\n\n{\n    \nint\n fib[\n40\n];\n    \nint\n n,i;\n    fib[\n0\n]=\n7\n;\n    fib[\n1\n]=\n11\n;\n    \nscanf\n(\n\"%d\"\n,&n);\n    \nif\n(n>\n1\n)\n    {\n     \n     \nfor\n(i=\n2\n;i<=n;i++)\n    {\n        fib[i]=fib[i\n-1\n]+fib[i\n-2\n];\n    }\n    }\n    \nelse\n\n    fib[i]=fib[n];\n    \n    \nprintf\n(\n\"%d\"\n,fib[i]);\n    \nreturn\n \n0\n;\n}\n", "Tag": "算法分析"}
{"Answer": "for i in range(1,20+1):\n    print(\"{:>8}\".format(fibo(i)), end=\"\")\n    if i % 5 == 0:\n        print()\n", "Konwledge_Point": "Fibonacci数列", "Question": "用递归函数fibo求斐波拉且数列的第n项。程序中输出斐波拉且数列的前20项，要求每行输出5个数据，每个数据输出宽度为8并在宽度内右对齐。\ndef fibo(n):\n    if n==1 or n==2:\n        return 1\n    else:\n        return (fibo(n-1)+fibo(n-2))\nfor i in range(1,20+1):\n    print(\"{:>8}\".format(fibo(i)), end=\" \",)\n\n\n我已经完成上面的代码了，但是不清楚如何每行输出五个\n效果图如下：\n\n\n   \n1\n       \n1\n       \n2\n       \n3\n       \n5\n\n   \n8\n      \n13\n      \n21\n      \n34\n      \n55\n\n  \n89\n     \n144\n     \n233\n     \n377\n     \n610\n\n \n987\n    \n1597\n    \n2584\n    \n4181\n    \n6765\n\n", "Tag": "算法分析"}
{"Answer": "\nn = int(input(\"Input N: \"))\na = 0\nb = 1\nsum = 0\nfor i in range(n):\n    a, b = b, a + b\n    sum += a\n    print(a)\nprint(\"The sum of\", n, \"FIB is\", sum,\"!\")\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "利用Python编程\n利用Python编程:\n\n\n\n（1）从键盘输入若干个整数，当输入某个特定的英文字母时，输入结束；计算并输出这些数中奇数的和、偶数的和，以及这些数的平均值。\n\n\n\n（2）利用列表计算斐波那契数列的前若干项及它们的和，并输出计算结果。", "Tag": "算法分析"}
{"Answer": "\n#include \"stdio.h\"\n/*\n编写函数fun，它的功能是:求Fibonacci数 列中大于t的最小的一个数，结果由函数返回。\n其中Fibonacci数列F (n)的定义为:F(0)=0，F(1)= 1 , F(n)=F(n- 1) +F(n- 2) #include #include Int Fun(int n)\n*/\nint fun(int n){\n\tint f0 = 0;\n\tint f1 = 1;\n\tint f2=0;\n\twhile(f2<n){\n\t\tf2 = f1+f0;\n\t\tf0 = f1;\n\t\tf1 = f2;\t\t\n\t}\n\treturn f2;\n}\nvoid main()\n{\n\tint n;\n\tprintf(\"请输入一个数:\");\n\tscanf(\"%d\",&n);\n\tprintf(\"大于%d的最小数是%d\",n,fun(n));\n    \n}\n ", "Konwledge_Point": "Fibonacci数列", "Question": "C语言编程题，救救孩子吧。这个math.h有啥用啊。难道不是多余的嘛。求大佬给个程序\n编写函数fun，它的功能是:求Fibonacci数 列中大于t的最小的一个数，结果由函数返回。其中Fibonacci数列F (n)的定义为:F(0)=0，F(1)= 1 , F(n)=F(n- 1) +F(n- 2)\n #include \n#include \nInt Fun(int n)", "Tag": "算法分析"}
{"Answer": "\nnum=0\nfor i in range(2,200):\n    k=True\n    for j in range(2,i):#for j in range(2,i/2+1)\n       if(i%j==0):\n         k=False\n         break\n    if(k==True):\n       print(\"%d\"%i)\n       num=num+1\nprint(\"素数个数%d\"%num)\n \n\ndef Fibonacci(n):\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 1\n    elif n > 2:\n        return Fibonacci(n - 1) + Fibonacci(n - 2)\n \ndef printFib():\n    n = eval(input(\"请输入一个整数：\"))\n    print(Fibonacci(n))\n \nprintFib()\n\n \n \n\ndef sprime(num):\n    try:\n        # 质数大于 1\n        if num > 1:\n            # 查看因子\n            for i in range(2, num):\n                if (num % i) == 0:\n                    print(num, \"不是质数\")\n                    print(i, \"乘于\", num // i, \"是\", num)\n                    break\n            else:\n                print(num, \"是质数\")\n                return True\n    \n        # 如果输入的数字小于或等于 1，不是质数\n        else:\n            print(num, \"不是质数\")\n            return False\n    except:\n        pass\n ", "Konwledge_Point": "Fibonacci数列", "Question": "用python编程，，，\n大一的程序设计，求求了，救救孩子吧，越简单越好\n1、编写函数，输出200以内的所有素数，以空格分割输出\n\n2、编写函数，参数为一个整数n。利用递归获取斐波那契数列中的第n个数并返回\n\n3、实 现sprime()函数，参数为整数，要有异常处理。如果整数是质数，返回True，否则返回False", "Tag": "算法分析"}
{"Answer": "```\r\n#include \r\n#include \r\nusing namespace std;\r\nint main()\r\n{\r\n\tint n = 0;\r\n\tcin >> n;\r\n\tstring s(n, 'o');\r\n\tint a = 1, b = 1;\r\n\ts[0] = 'O';\r\n\twhile(true)\r\n\t{\r\n\t\tint tmp = a + b;\r\n\t\tif (tmp > n)\r\n\t\t\tbreak;\r\n\t\ts[tmp - 1] = 'O';\r\n\t\ta = b;\r\n\t\tb = tmp;\r\n\t}\r\n\tcout << s;\r\n\treturn 0;\r\n}\r\n```", "Konwledge_Point": "Fibonacci数列", "Question": "求判断是否为斐波那切数列(含高精度)\n输入n(1<=n<=1000)。\n\n\n\n输出n个o，如果i是斐波那契数列中的数，则第i个o为大写，否则为小写。", "Tag": "算法分析"}
{"Answer": "def fib(m):\n    if m<3:\n        return 1\n    return fib(m-1)+fib(m-2)\n\nn = int(input())\nSum = 0\nfor i in range(1,n+1):\n    Sum += fib(i)\n\nprint(Sum)\n", "Konwledge_Point": "Fibonacci数列", "Question": "python提问 求Fibonacci数列前n项和\n用递归方法编写求Fibonacci数列第m项值的函数fib(m)，并应用该函数求Fibonacci数列前n项的累加和，其中n由input输入。", "Tag": "算法分析"}
{"Answer": "网上有很多啊\n#include <stdio.h>\nint  Fib(int n)\n{\n    if(n==1 || n==2)\n      return 1;\n   return Fib(n-1) + Fib(n-2);\n}\nint main()\n{\n    int n,sum=0;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++)\n        sum += Fib(i+1);\n    printf(\"%d\\n\",sum);\n    return 0;\n}\n", "Konwledge_Point": "Fibonacci数列", "Question": "C语言编写一个递归函数 Fib，用于求Fabonacci的第n项数列。\n题目描述:编写一个递归函数 Fib，用于求Fabonacci的第n项数列。\n如图所示", "Tag": "算法分析"}
{"Answer": "\n#include<stdio.h>\n \nint main(){\n    int i, j, sum;\n    int cnt = 50;        // 需要输出的项数 \n    double fib[200] = {1.0, 1.0}; // int溢出，需要把数组类型改为 double \n    for(i = 2; i < cnt + 1; i++){\n        fib[i] = fib[i-2] + fib[i-1];    \n    }\n    \n    for(i = 0; i < cnt + 1; i++){\n        sum = 0;\n        for(j = 1; j < i; j++){\n            if(i%j == 0){\n                sum += j;\n            }\n      }\n      if(i == sum){\n            printf(\"%12.0lf\",fib[i]);        // 右对齐12字符 \n        }\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}\n", "Konwledge_Point": "Fibonacci数列", "Question": "找出斐波那契数列中的不是完数的数\n找出斐波那契数列前20项中不是完数的数。列如6的因子上1，2，3，而6=1+2+3，因此6是完数。", "Tag": "算法分析"}
{"Answer": "\n斐波那契数列的四种实现方式（C语言）_cherrydreamsover的博客-CSDN博客_斐波那契数列c语言\n斐波那契数列是一组第一位和第二位为1，从第三位开始，后一位是前两位和的一组递增数列，像这样的：1、1、2、3、5、8、13、21、34、55......今天，我们用四种方式来进行实现：1.递归int Fibon1(int n){\tif (n == 1 || n == 2)\t{\t\treturn 1;\t}\telse\t{\t\treturn Fibon1(n - 1) + Fibon1(n ...\n\n\n\nhttps://blog.csdn.net/cherrydreamsover/article/details/80026343\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "看一下这个怎么做，斐波那契数列\nC【语法基础】斐波那契数列\n时间限制 : 10000 MS   空间限制 : 65536 KB\n问题描述\n数列1,1,2,3,5,8,13,21,……称为非波拉楔数列。\n从键盘输入一整数N (2<N<40)，求出非波拉楔数列的第N项。\n\n\n输入格式\n一个整数N\n\n\n输出格式\n一个整数，表示数列的第N项\n\n\n样例输入\n6\n\n\n样例输出\n8\n时间限制 : 10000 MS   空间限制 : 65536 KB\n问题描述\n数列1,1,2,3,5,8,13,21,……称为非波拉楔数列。\n从键盘输入一整数N (2<N<40)，求出非波拉楔数列的第N项。\n\n\n输入格式\n一个整数N\n\n\n输出格式\n一个整数，表示数列的第N项\n\n\n样例输入\n6\n\n\n样例输出\n8", "Tag": "算法分析"}
{"Answer": "我算了一下，第五十位斐波那契数列太大了，已经超出了int 类型可以表示的范围了，这个数太大了，换成double都小，int我这好像最多算到第44位数，double最多算到49好像，为啥要算这么大的数呢，没有搞懂，int四个字节32位，加上一个符号位，最多表示2的31次方，这个已经超出了它可以表示的范围了建议重新算一位斐波那契数列，哈哈！", "Konwledge_Point": "Fibonacci数列", "Question": "裴波那契数列的第五十项的求解\n#include\nint main()\n{\n    int a[50];\n    a[0]=1;\n    a[1]=1;\n    int i;\n    for(i=2;i<=50;i++)\n    {\n        a[i]=a[i-1]+a[i-2];\n    }\n     printf(\"%d\",a[50]);\n\n\nreturn\n \n0\n;\n\n\n\n}", "Tag": "算法分析"}
{"Answer": "用递归方式解决，f(n)=f(n-1)+f(n-2)\n#include<iostream> \n#include<stdio.h>\nusing namespace std;\n \n//Fibonacci数列递归解法 C++ 实现\nint Fib(int n) \n{\n    if(n==1) \n        return 1;\n    else if(n==2)\n        return 1;\n    else\n        return Fib(n-1)+Fib(n-2);\n}\nint main()\n{\n    int k;\n    cin>>k;\n    cout<<Fib(k)<<endl;\n    return 0;\n}\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "🎉️ 程序设计-斐波那契数列\n小明最近学习了斐波那契数列。\n\n\n斐波那契数列是指这样的数列：数列的第一个和第二个数都为 1，接下来每个数都等于前面 2个数之和。\n\n\n给出一个正整数 k，要求斐波那契数列中第 k个数是多少。\n\n\n输入格式\n输入一行，包含一个正整数 k。（1≤k≤46）\n\n\n输出格式\n输出一行，包含一个正整数，表示斐波那契数列中的第 kk 个数。\n\n\n输入样例\n19\n输出样例\n4181", "Tag": "算法分析"}
{"Answer": "```\r\n int foo(int n)\r\n{\r\n    if (n == 1 || n == 2)\r\n        return 1;\r\n    return foo(n - 1) + foo(n - 2);\r\n}\r\n\r\nint main()\r\n{\r\n    for (int i = 1; i < 20; i++)\r\n    {\r\n        cout << foo(i) / (double)foo(i + 1) << endl;\r\n    }\r\n}\r\n```\r\n\r\n1\r\n0.5\r\n0.666667\r\n0.6\r\n0.625\r\n0.615385\r\n0.619048\r\n0.617647\r\n0.618182\r\n0.617978\r\n0.618056\r\n0.618026\r\n0.618037\r\n0.618033\r\n0.618034\r\n0.618034\r\n0.618034\r\n0.618034\r\n0.618034", "Konwledge_Point": "Fibonacci数列", "Question": "用C语言证明费波拉契数列中Fn/Fn+1等于黄金分割。要求有输入输\n用C语言证明费波拉契数列中Fn/Fn+1等于黄金分割。要求有输入输出", "Tag": "算法分析"}
{"Answer": "你提的俩问题 一起采纳下呗 谢谢您\n\ndef feb(n):\n    if n== 1 or n == 0:\n        return n\n    return feb(n-1) + feb(n-2)\n\nfor i in range(2, 22):\n    if (i-1) % 5 == 0:\n        print(feb(i))\n        continue\n    print(feb(i), end =' ')\n\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列用Python咋写\n输出斐波那契数列前20项，每5个一行\n这个咋写问一下，不太明白怎么整这个斐波那契数列", "Tag": "算法分析"}
{"Answer": "把题目的意思转换为代码就可以了。一个实现，仅供参考：\ndef F(n):\n\n    if n==0:  #当前n为0时，返回0\n \n        return 0   \n \n    elif n==1:  #当n为1时，返回1\n \n        return 1   \n \n    else:   #当大于1时就返回前两个斐波那契数的和\n \n        return F(n-1) + F(n-2)\n    \nn=int(input(\"输入一个正整数n：\"))\n\nif n>=0:\n\n    for i in range(n+1):  #打印斐波那契数的F(0) 到F(n)\n \n        print(  F(i)  ,end=\" \")  \nelse:\n\n    print(\"输入数据有误\")\n\n\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列输入正整数n，输出斐波纳契数列F(0)  F(1)  ……  F(n)，各项以空格分隔。\n斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：0 1 1 2 3 5 8 13 21 34……在数学上，斐波纳契数列以如下递归的方法定义：F(0)=0，F(1)=1, F(n)=F(n-1)+F(n-2)。\n\n\n输入正整数n，输出斐波纳契数列F(0)  F(1)  ……  F(n)，各项以空格分隔。\n\n\n填入合适代码，使程序完整。\n\n\ndef F(n):\n\n\nif\n \nn\n==0:\n\n    ①   \n\nelif \nn\n==1:\n\n    ②   \n\n\nelse\n:\n\n    ③   \n\n\n\nn=int(input(\"输入一个正整数n：\"))\n\n\nif n>=0:\n\n\nfor\n i \nin\n range(n+1):\n\n    \nprint\n(  ④  ,\nend\n=\n\" \"\n)\n\n\n\nelse:\n\n\nprint\n(\n\"输入数据有误\"\n)\n\n", "Tag": "算法分析"}
{"Answer": "请问要输出几个数呢？ 我这里是输出31个的，如果需要多少，把代码中对应的31改成你需要的值即可、\n#include<iostream>\nusing namespace std;\n\n// fib() 函数\nvoid fib() {\n    int a[31] = {0};\n    a[0] = 1;\n    a[1] = 1;\n    for (int i = 2; i < 31 ; i++) {\n        a[i] = a[i-1] + a[i-2];\n    }\n    \n    for (int i = 1; i < 31 ; i++){\n        cout << a[i] << endl;\n    }\n\n}\n\nint main() {\n    fib();\n    return 0;\n}\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "Fibonacci数列 改错\n想问下这道Fibonacci数列这样编写哪里有问题呢，麻烦帮忙改错，谢谢！", "Tag": "算法分析"}
{"Answer": "可以先定义一个函数求某一项的斐波那契数列的值，然后在一个循环中调用这个函数，判断其值是否超过5000，如果没有超过则计算下一项斐波那契数列的值，同时记录项数，如果查过了，则打印第几项超过了5000，代码如下：参考链接：java斐波那契前100项以及求和_pyh2358的博客-CSDN博客_斐波那契数列前100项\ndef fib(n):\n    if n==1 or n==2: #如果项数为第1项或第2项，则返回斐波那契数列的值为1\n        return 1\n    else: #否则，返回前两项的斐波那契数列的和\n        return fib(n-1)+fib(n-2)\n\nif __name__ == \"__main__\":\n\n    i=1  #初始项数为第1项\n    result=fib(i) #计算第1项斐波那契数列的值\n    while result<=5000:  #如果斐波那契数列的某一项的值小于等于5000，则计算下一项斐波那契数列的值\n        i+=1  # 项数变为下一项\n        result=fib(i)  #计算下一项斐波那契数列的值\n\n #当循环退出，则计算出数列值超过5000的项数，打印这个结果       \nprint(\"第\"+str(i)+\"项的斐波那契数列其值超过5000，其值是\"+str(result)+\".\")\n        \n\n\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "python斐波那契数列相关问题\n刚刚开始学，不太懂怎么写，求懂得人麻烦指教\n斐波那契数列相关的问题", "Tag": "算法分析"}
{"Answer": "\ndef fbnq(n):\n    if n==1:\n        return a\n    elif n==2:\n        return b\n    elif n >= 3:\n        return fbnq(n-2)+fbnq(n-1)\n\n\na =  int(input(\"Enter the first number \"))\nb =  int(input(\"Enter the second number \"))\nc =  int(input(\"Enter the number of iterations \"))\nList = []\nfor i in range(1,c+1):\n    List.append(fbnq(i))\nprint(List)\n\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "使用递归显示斐波那契数列\n接受一个number.\n接受第二次number.\n接受迭代次数\n根据输入的数字显示斐波那契数列。", "Tag": "算法分析"}
{"Answer": "\ndef fib(n):\n    a, b = 1, 1\n    for i in range(n-1):\n        a, b = b, a+b\n    return a\n\ndef get_res(x):\n    sum_a = 0\n    for item in range(3, x+3):\n        a = fib(item) / fib(item-1)\n        sum_a += a\n    return sum_a\n\nres = get_res(5)\nprint(res)\n", "Konwledge_Point": "Fibonacci数列", "Question": "python斐波那契数列及同步赋值\n分子分母同时为斐波那契数列时，如何同步赋值？不要使用yield之类函数能否做到呢？", "Tag": "算法分析"}
{"Answer": "child\r\ngrade_school", "Konwledge_Point": "Fibonacci数列", "Question": "大家猜猜这个运行结果\n父类：\n\npackage com.huawei.test;\n\n\n\npublic class Parent {\n\n    protected String name = \"parent\";\n\n    protected String school = \"grade_school\";\n\n\n\npublic void printName(){\n    System.out.println(name);\n}\n\n\n\n\n}\n\n\n\n子类：\n\npackage com.huawei.test;\n\n\n\npublic class Child extends Parent{\n\n    private String name = \"child\";\n\n    private String school = \"colleage_school\";\n\n\n\npublic static void main(String[] args) {\n    Parent parent = new Child();\n    parent.printName();\n    System.out.println(parent.school);\n}\n\npublic void printName(){\n    System.out.println(name);\n}\n\n\n\n\n}\n\n求打印结果是________?", "Tag": "算法分析"}
{"Answer": "图片上的问题是fb没有给初始值，所以编译器会报错。两个变量计算第n个斐波那契数的逻辑如下：second = first+second;first = second - first;比如前三个：1,1,2。首先first=1,second=1是，计算第三个数的过程：\n将first+second 赋值新的second，此时second相当于向后移动一位,second = 2;second此时前一个数值等于当前second-first=2-1=1;将此值赋值于first;此后相当于first,second各向后推一位。循环此步骤，就能求解第n个值。\n\npublic static int fb(int n) {\n    int i = 0, first = 0, second = 1;\n    while (i < n-1) {\n        second = first+second;\n        first = second - first;\n        i++;\n    }\n    return second;\n}\n\npublic static void main(String[] args) {\n    System.out.println(fb(6));\n}\n", "Konwledge_Point": "Fibonacci数列", "Question": "利用while编写斐波那契数列\n麻烦请教如何仅使用2个储存变量利用while编写斐波那契数列 希望大家可以将不好理解的地方给予解释 我很多基础的东西都忘记了 麻烦大家指点一下\n\n\n\n", "Tag": "算法分析"}
{"Answer": "你试试unsigned long long看看，范围更大些", "Konwledge_Point": "Fibonacci数列", "Question": "用C语言打印斐波那契数列前50项\n用C语言打印斐波那契数列前50项，最后几个是负数，如何解决。", "Tag": "算法分析"}
{"Answer": "没有办法，除非你求的是第n个斐波那契数是比较小的（n<50）可能50还大了\n因为用递归的方式你进行了大量的重复计算。你可以在你函数中写个count 计数看你函数调用了多少次。斐波那契用迭代的方法是最佳选择", "Konwledge_Point": "Fibonacci数列", "Question": "利用递推运算计算斐波那契数列超时\n如题，在计算斐波那契数列时想到构造函数，但是报了超时错误。有没有办法使递归法不超时的写法，求指点", "Tag": "算法分析"}
{"Answer": "\n#include <iostream>\n\nint fib(int n) {\n    if (n == 1 && n == 2)\n        return 1;\n    int fn1 = 1;\n    int fn2 = 1;\n    int res = 0;\n    for (int i = 3; i <= n; i++)\n    {\n        res = fn1 + fn2;\n        fn1 = fn2;\n        fn2 = res;\n    }\n    return res;\n\n}\nint main()\n{\n    int n;\n    std::cin >> n;\n    int ans = fib(n);\n    std::cout << ans;\n}\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列2-递推方法\n斐波那契数列在数学上，斐波那契数列以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n - 1)+F(n - 2)（n≥3，n∈N*）【注意：n<=80】\n\n\n#\ninclude\n \n\n\n\n\nlong\n \nlong\n \nfib\n(\nint\n n)\n;\n\nint\n \nmain\n(\nvoid\n)\n \n{\n    \nint\n n;\n    \nscanf\n(\n\"%d\"\n,&n);\n    \nprintf\n(\n\"fib(%d)=%lld\"\n,n,\nfib\n(n));\n    \nreturn\n \n0\n;\n}\n\n/*提交以下代码*/\n\n\n\nlong\n \nlong\n \nfib\n(\nint\n n)\n \n{\n\n}\n\n\n\n\n输入\n1行，第几项n\n输出\n见样例\n样例输入 Copy\n5\n样例输出 Copy\nfib(5)=5\n提示\n递推求解的时间复杂度比较低，是O（N）", "Tag": "算法分析"}
{"Answer": "\n#include <stdio.h>\nint F(int n) //斐波那契数列函数 递归形式\n{\n    if(n == 0) //初始化\n        return 0;\n    if(n == 1 || n == 2)\n        return 1;\n    return F(n-1) + F(n-2);  //如果n != 1 && n != 2 进行递归运算\n}\n \nint main()\n{\n    int t,n;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        scanf(\"%d\",&n);\n        printf(\"%d\\n\", F(n));\n    }\n    return 0;\n}\n", "Konwledge_Point": "Fibonacci数列", "Question": "未输入就自己运行斐波那契数列\n为什么这个我还没输入他就自己运行了\n想求的是斐波那契数列的第n项 用数组", "Tag": "算法分析"}
{"Answer": "算加法别用double型，用long long intdouble型有精度误差，最后你跟1和2去判断总是不相等，无限递归了", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列的代码运行结果\n 用函数递归求斐波那契数列，发现数字一大就不能有结果了\n\n\n#\ninclude\n\n#\ninclude\n\n\nint\n main\n()\n\n{\n    double \nFibonacci(\ndouble\n \na\n)\n;\n//声明Fibonacci函数\n\n    \nint\n n = \n0\n;\n    scanf\n_s(\n\"%d\"\n, &\nn\n)\n;\n    \nFibonacci(\nn\n)\n;\n//调用Fibonacci函数\n\n    printf(\n\"%.0f\\n\"\n, \nFibonacci(\nn\n)\n);\n    system(\n\"pause\"\n);\n    return \n0\n;\n\n}\ndouble \nFibonacci(\ndouble\n \na\n)\n//定义Fibonacci函数\n\n{\n    double result = \n0\n;\n    \nif\n (a\n == \n1\n || \na\n == \n2\n) {\n        result = \n1\n;\n    }\n    \nelse\n {\n        result = \nFibonacci(\na\n - 1)\n + \nFibonacci(\na\n - 2)\n;\n    }\n    return(result);\n}\n\n", "Tag": "算法分析"}
{"Answer": "def fabo(x):\n    a,b=1,1\n    for i in range(2,x):\n        a,b=b%10007,(a+b)%10007\n    return b\n        \ndef fabo1(x):\n    a,b=1,1\n    for i in range(2,x):\n        a,b=b,(a+b)\n    return b\n\nfor i in range(1,20000):\n    if fabo(i)!=fabo1(i):\n        print(i,fabo(i))\n        print(i,fabo1(i))\n        print(i-1,fabo(i-1))\n        print(i-1,fabo1(i-1))\n        print(i-2,fabo(i-2))\n        print(i-2,fabo1(i-2))\n        break\n\n21 93921 1094620 676520 676519 418119 4181\n\n6765+41811094610946%10007939\n\nx<21时，两函数相等的，x=21时 a+b>10007就不相等了", "Konwledge_Point": "Fibonacci数列", "Question": "有关斐波那契数列Python\n要求求斐波那契数列F（n）除以10007所得余数 n是整数\n\n\ndef\n fabo(x):\n    \na\n,b=\n1\n,\n1\n\n    \nfor\n i in range(\n2\n,x):\n        \na\n,b=b%\n10007\n,(a+b)%\n10007\n\n    \nreturn\n b\n        \n\n\n\n\ndef\n fabo1(x):\n    \na\n,b=\n1\n,\n1\n\n    \nfor\n i in range(\n2\n,x):\n        \na\n,b=b,(a+b)\n    \nreturn\n b\n\n\n\n\n在F(n)<10007这两个结果等价，但是F（n）>10007的时候这两个为什么等价（我运行一下结果一样），我感觉我用数学解释不来，请求指导", "Tag": "算法分析"}
{"Answer": "[quote]我可以只展示根节点下一级的节点，然后他点什么 我同过ajax 来实现 在下一个层次的节点展示，不知道这样是否合理？ [/quote]\r\n我觉得合理,EXJTS 就可以这么做..\r\n你的ID ,PID ,之前EXTJS项目也这么做过..", "Konwledge_Point": "Fibonacci数列", "Question": "递归性能的提问\n最近遇到了一个老问题，树状结构的无限级的分类，本来数据库设计的合理的话，其实也不是什么难题，但是数据库设计的定了，我也没有权利去修改，具体数据库设计室 id name url gif parentId，这样的设计大家应该很眼熟吧，呵呵，关键的字段就是id 和pid，这样的情况下，除了递归的求解，我实在想不出更好的解决办法，但是递归的问题对于性能的消耗是比较大的，递归来地归去，每次都是对象的在一起引用，大数据量的情况下，程序不死已经是万幸了。 \n\n    由此，我就联想到了其他需要递归的api上，比如 xml的文件解析，json 传递 页面 js的eval解析，已经 后台的json.jar 的都是如何解析的？ \n\n    我也看过一些源码，可是单步调我已经调晕了，朋友们谁有研究的，留下个思路，和解决办法。不必留源码，一个伪代码也可，只要能表明思路的就行，感谢大家。 \n\n\n\n\n\n\n注： \n\n\n\n我个人回头想了一下，关于无限级分类的问题，是不是不一定非得在后台把所有的数据都取出来呢？我可以只展示根节点下一级的节点，然后他点什么 我同过ajax 来实现 在下一个层次的节点展示，不知道这样是否合理？ \n", "Tag": "算法分析"}
{"Answer": "那就一边产生数列，一边将数列存储到数组。", "Konwledge_Point": "Fibonacci数列", "Question": "c语言，一个关于斐波那契数列的问题……\n请问，有没有什么方法可以用数组来求斐波那契数列中的第n项？要用数组……", "Tag": "算法分析"}
{"Answer": "while循环内开始时将f1=f2=1;", "Konwledge_Point": "Fibonacci数列", "Question": "Fibonacci斐波那契数列求多组数据的时候就行不通了\n#include\nint main()\n{\n    int f0,f1,f2,f3;\n    int n,i;\n    f0=0;\n    f1=f2=1;\n    while(~scanf(\"%d\",&n)&&n!=-1){\n        if(n==0) printf(\"0\\n\");\n        else if(n==1||n==2) printf(\"1\\n\");\n        else\n        {\n            for(i=3;i<=n;i++)\n            {\n                f3=f1+f2;\n                f1=f2;\n                f2=f3;\n            }\n            printf(\"%d\\n\",f3);\n        }\n    }\n    return 0;\n}\n怎么改，拜托了这对我真的很重要", "Tag": "算法分析"}
{"Answer": "循环里每次相加都取余，不要最后变成一个超大的数再取余", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列超长数字用什么整型?\n我要求斐波那契数列的第100000000项取余，用longlong和double转int取余都不行，会输出负数……还有更长的整型吗？还是说其实问题不在这里？(p_q）", "Tag": "算法分析"}
{"Answer": "f[n]=f[n-2]+f[n-1]", "Konwledge_Point": "Fibonacci数列", "Question": "C语言 按以下要求编写程序 fibonacci数列\n编写程序求fibonacci数列，有40阶楼梯，从底往上爬，每次爬1阶或2阶，编算法说明共有多少走法。", "Tag": "算法分析"}
{"Answer": "我这里没什么问题啊\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列问题，求解答\n  def fib(n):\n    ''' 生成并返回斐波那契数列的前n项组成的列表 '''\n    lt = [1, 1]\n    for i in range(2, n):\n        lt.append(lt[i-1] +lt[i-2])\n    return lt\n为什么我运行这行代码出现===？请问是哪里错了？", "Tag": "算法分析"}
{"Answer": "#include <stdio.h>\n\nint main()\n{\n    int f1 = 1, f2 = 1;\n    for (int i = 1; i <= 20; i++)\n    {\n        if (i > 2)\n        {\n            int f = f1 + f2;\n            f1 = f2;\n            f2 = f;\n        }\n        printf(\"%8d\", f2);\n        if (i % 5 == 0)\n            printf(\"\\n\");\n    }\n    return 0;\n}\n", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列简单运用，简单运用\n斐波那契数列是指这样的一个数列：1，1，2，3，5，8，13，21，...，\n\n\n这个数列从第3个数开始每个数都等于前两个数的和，请输出这个数列的前20项。\n\n\n输入格式:\n没有输入。\n\n\n输出格式:\n数据占域宽为8，每行输出5个数。\n\n\n输入样例:\n在这里给出一组输入。例如：\n\n\n输出样例:\n在这里给出相应的输出。例如：\n\n\n   \n1\n       \n1\n       \n2\n       \n3\n       \n5\n\n   \n8\n      \n13\n      \n21\n      \n34\n      \n55\n\n  \n89\n     \n144\n     \n233\n     \n377\n     \n610\n\n \n987\n    \n1597\n    \n2584\n    \n4181\n    \n6765\n\n", "Tag": "算法分析"}
{"Answer": "大佬要不来看看我写的这篇http://t.csdn.cn/sOeFe", "Konwledge_Point": "Fibonacci数列", "Question": "关于#斐波那契数列#的问题，如何解决？\n哎，搞了2个小时，面对斐波那契数列的问题以及一些基础概念还是不了解，有谁可以来讲解一下或者发个链接呀，困扰了我好长时间了", "Tag": "算法分析"}
{"Answer": "循环\n##  将斐波那契额序列\n## 获取用户输入数据\n# nmber=input()\ndef fib_loop_while(n):\n    a, b = 0, 1\n    for i in range(0, n):\n        a, b = b, a + b\n        yield a\n\n#\n# for i in fib_loop_while(nmber):\n#     print(i, end=' ')\nfor i in fib_loop_while(50):\n    print(i, end=' ')\n\nfor i in fib_loop_while(100):\n    print(i, end=' ')\n\nfor i in fib_loop_while(1000):\n    print(i, end=' ')\n\n递归\n# 递归\ndef rabbit2(n):\n    if (n==1 or n==2):\n        return 1\n    else:\n        return rabbit2(n-1)+rabbit2(n-2)\nfor i in range(1,50):\n    print(rabbit2(i),end=' ')\nfor i in range(1,100):\n    print(rabbit2(i),end=' ')\nfor i in range(1,1000):\n    print(rabbit2(i),end=' ')\n", "Konwledge_Point": "Fibonacci数列", "Question": "2021.10.21 斐波那契数列\n【每日一题】2021.10.21\n\n\n\n斐波那契数列F(1)=F(2)=1;n>2时 F(n)=F(n-1)+F(n-2)\n\n用递归和循环两种方法编程求F(50), F(100), F(1000)的值\n\n\n\n编程语言：包括但不限于Python", "Tag": "算法分析"}
{"Answer": "https://www.cnblogs.com/panlq/p/9307203.html", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列步骤不懂?\nimport sys\n\n\ndef fibonacci(n): # 生成器函数 - 斐波那契\n    a, b, counter = 0, 1, 0\n    while True:\n        if (counter > n):\n            return\n        yield a\n        a, b = b, a + b\n        counter += 1\nf = fibonacci(10) # f 是一个迭代器，由生成器返回生成\n\n\nwhile True:\n    try:\n        print (next(f), end=\" \")\n    except StopIteration:\n        sys.exit()\n\n\n这个步骤不懂，哪里有详细教程嘛？", "Tag": "算法分析"}
{"Answer": "\nIts compiler isn't as smart or mature as C's (at least not yet), but Go is still closer to C in its time performance than Python (space performance is a separate thing, and not what you asked about).  Just being a compiled language instead of an interpreted language gives it a major leg up in time performance over Python (and it is still faster than PyPy in general, but not as much faster).\nWhy compiled languages generally offer greater time performance than interpreted languages has been thoroughly covered elsewhere.  You can research this question on stackoverflow and elsewhere on the internet.  For example, here's the TL;DR in one stackoverflow answer to that question:\n\nNative programs run using instructions written for the processor they run on.\n\nAnd here's the TL;DR in another answer:\n\nInterpreted languages are slower because their method, object and global variable space model is dynamic\n\nYou can also find plenty of benchmark case studies and results comparing implementations in different languages if you look for them.\nPerformance improvements to the Go compiler and Go toolchain are also frequently made, which you can read about in the release notes (and elsewhere) such as this excerpt about version 1.8:\n\nThe new back end, based on static single assignment form (SSA), generates more compact, more efficient code and provides a better platform for optimizations such as bounds check elimination. The new back end reduces the CPU time required by our benchmark programs by 20-30% on 32-bit ARM systems.\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "Go如何如此快速地计算斐波那契递归？\n\n\n\nThis is not a correct version of it, I am just playing around Go but I was shocked how fast Go calculated the 42nd(43 actually) number in Fibonacci sequence.\n\n\n\nCan someone please explain how come it calculates it this fast? I tried comparing it to python(I know its slow compared to other languages) but python took > 1 minute and I had to break the recursion.\n\n\n\npackage main\n\nimport \"fmt\"\n\nfunc fib(a uint) uint {\n    if a <= 1 {\n        return 1\n    }\n    return fib(a-1) + fib(a-2)\n}\n\nfunc main() {\n    fmt.Println(fib(42))\n}\n\n\n[ `go run Hello.go` | done: 2.316821835s ]\n433494437\n\n\n    ", "Tag": "算法分析"}
{"Answer": "\ndef fab(max): #\n    n,a,b=0,0,1  # n 为循环次数，ab为数列中两个连续值\n    fab_reasult=[] # 存放结果的数组\n    while n<max:  # 循环不够max次则继续\n        fab_reasult.append(b) # 将第二个数放入结果里\n        a,b=b,a+b  # a,b = b,a+b  ，如 a,b=0,1，运行后，a==1,b==1，再次运行则 a == 1,b==2\n        n=n+1 # 循环次数加1\n    return fab_reasult\nprint(fab(9))  # 参数为9\n", "Konwledge_Point": "Fibonacci数列", "Question": "python设计的斐波那契数列的程序\n以下是用python设计的斐波那契数列的程序，请帮忙解答一下：\n1、fab(max)里的max是参数，但是下面的程序中只有n<max这个判断式用到了，但是并没有定义max是多少？这是为什么？\n2、函数中定义了变量n，但是n和a，b的关系并没有定义，所以n和a，b的关系是什么？\n3、要形成数列，a，b需要自增长，这里有没有定义，只有n的自加运算，请帮忙解释一下，谢谢\n\n\n\ndef fab(max):\n    n,a,\nb\n=0,0,1\n    fab_reasult=[]\n    \nwhile\n n<max:\n        fab_reasult.append(b)\n        a,\nb\n=b,a+b\n        \nn\n=n+1\n    return fab_reasult\n\nprint\n(fab(9))\n", "Tag": "算法分析"}
{"Answer": "应该是a=b*1.0/c\n", "Konwledge_Point": "Fibonacci数列", "Question": "分数斐波那契数列求和，哪里错了？\n题目描述 \n\n\n给定一个数列 1/1  1/2  2/3  3/5  5/8  8/13  13/21  求该数列的前n项之和。 \n\n\n输入 \n\n\n一行，1个整数，表示要求和的总项数n (n>=1)。 \n\n\n输出 \n\n\n一行，包含1个浮点数，表示该数列的前n项之和。结果保留两位小数 \n\n\n样例输入Copy\n2\n样例输出 Copy\n1.50\n\n\n写法如下，哪里不对？\n\n", "Tag": "算法分析"}
{"Answer": "C语言 -- 数学问题求解黑马程序员--汉诺塔问题的递归求解C语言C语言数组初始化问题----------------------biu~biu~biu~~~在下问答机器人小D，这是我依靠自己的聪明才智给出的答案，如果不正确，你来咬我啊！", "Konwledge_Point": "Fibonacci数列", "Question": "求解   C语言的数组问题\n", "Tag": "算法分析"}
{"Answer": "理解没问题，i=3的时候就只是返回test（2）+test（1）i=3 的时候test(3)  --test（2）+test（1）=1+1=2\ni=4test(4) -- test(3)+test(2)=3", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列中的return有疑问\ndef\n test(i):\n    \nif\n i == \n1\n:\n        \nreturn\n \n1\n\n    \nif\n i == \n2\n:\n        \nreturn\n \n1\n\n    \nif\n i >= \n3\n:\n        \nreturn\n test(i - \n1\n) + test(i - \n2\n)\n\n\n\n\n这是求第i项的数字是多少的函数。\n\n\n这里对return有个疑问，如果函数参数i=1 返回1，然后退出函数。i=2，返回2，退出函数。\n\n\n如果i=3，他会返回一个test（2）+test（1）。重点是：我记得当执行return后，自动退出函数，所以函数不会再回到前两行找到test2与test1对应的数值，所有当i=3时候，只返回test（2）+test（1）。我不知道这样理解哪里错了，求各位指正，🙏！", "Tag": "算法分析"}
{"Answer": "\ndef fibonacci(index):\n  a,b = 0,1\n  for value in range(index):\n    a,b = b,a+b\n  return a\n\n# while 循环查找小于t的最大数\nmax_num = 0\nindex = 0\nt = 1000\nwhile True:\n  value = fibonacci(index)\n  if value > t:\n    break\n  else:\n    max_num = value\n    index += 1\n\nprint(f'小于{t}的最大数：{max_num}')\n\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "请问要怎么用python写函数fun()，它的功能是求Fibonacci数列中小于t的最大的一个数，结果由函数返回。\n请问要怎么用python写函数fun()，它的功能是求Fibonacci数列中小于t的最大的一个数，结果由函数返回。其中Fibonacci数列F(n)的定义为\nF(0)＝0，F(1)＝1\nF(n)=F(n-1)+F(n-2)\n例如：t=1000时，函数值为987。\n没有思路，请指导", "Tag": "算法分析"}
{"Answer": "你可以参考一下，希望采纳\n#include <iostream>\nusing namespace std;\n\nclass  Fibon\n{\n    int* p;    //数组首元素地址\n    int len;   //数组长度\npublic:\n    Fibon(int  n = 1)\n    {\n         //这里用new定义长度为n的数组\n        len = n;\n        p = new int[len];\n    }\n\n    ~Fibon()\n    {\n        //这里释放数组内存空间\n        delete p;\n    }\n\n    void Disp();  //计算斐波那契数列，并打印数列\n};\n\n//计算斐波那契数列，并打印数列\nvoid Fibon::Disp(){\n    p[0] = 1;\n    p[1] = 1;\n    cout << p[0] << \" \" << p[1] << \" \";\n\n    int i,cnt = 0;\n    for (i = 2; i < len; i++) {\n        p[i] = p[i - 1] + p[i - 2];\n        cout << p[i] << \" \";\n        cnt++;\n        \n        if (cnt % 5 == 0)   //每5个换行，不需要可以删除\n            cout << endl;\n    }\n    cout << endl;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    Fibon  f(n);\n    f.Disp();\n    return 0;\n}\n\n运行结果：\n", "Konwledge_Point": "Fibonacci数列", "Question": "C++完善如下有关斐波那契数列的类Fibon，并在主函数中进行测试\nclass\n  \nFibon\n\n{   \nint\n *p;    \n//数组首元素地址\n\n    \nint\n len;   \n//数组长度\n\n  \npublic\n:\n\nFibon\n( \nint\n  n=\n1\n)\n{    …     \n//这里用new定义长度为n的数组\n\n      }\n ~\nFibon\n()\n  {    \n   … \n//这里释放数组内存空间\n\n  }\n\nvoid\n \nDisp\n()\n;  \n//计算斐波那契数列，并打印数列\n\n};\n\nint\n \nmain\n()\n\n\n{\n    \nint\n n;\n    cin >> n;\n    \nFibon  \nf\n(n)\n;\n    f.\nDisp\n();\n    \nreturn\n \n0\n;\n}\n", "Tag": "算法分析"}
{"Answer": "这个看着没什么问题，具体的题目是怎样的？", "Konwledge_Point": "Fibonacci数列", "Question": "使用数组编程计算Fibonacci数列前30个数\n用数组计算Fibonacci数列的前30个数，并按每行五个数的格式输出。间隔为每个数据占8列，空格在后，“%-8d”.\n问题：总是提示输出格式错误\n\n\n#\ninclude\n\n\n\nint\n \nmain\n()\n\n\n{\n \nint\n F[\n30\n] = { \n1\n,\n1\n };\n \nfor\n (\nint\n i = \n2\n; i < \n30\n; i++)\n {\n  F[i] = F[i - \n1\n] + F[i - \n2\n];\n }\n \nfor\n (\nint\n i = \n0\n; i < \n30\n; i++)\n {\n  \nprintf\n(\n\"%-8d\\t\"\n, F[i]);\n    \nif\n((i+\n1\n)%\n5\n==\n0\n)\n  {\n   \nprintf\n(\n\"\\n\"\n);\n  }\n }\n \nreturn\n \n0\n;\n}\n\n", "Tag": "算法分析"}
{"Answer": "首先def定义函数，就是一个方法，方便之后随便用这个方法的功能。蓝色的就是方法名字，里面的n是一个参数，必须要填，而且根据后面的代码来看，必须得是整数。（a，b）=（0，1）就是相当于 a = 0, b = 1，定义了两个变量， 分别赋予了值。while循环，a<n就是直到a大于等于n之前，这个循环里面包括的代码都会不停的被编译。print，就是输出，end = \" \"，正常的print是会输出之后换行的，就是默认end = \"\\n\"，这里面改成了一个空格，就是为了让输出排成一行。（a，b）=（b，a+b）就是斐波那契数列的运算方法，这个数学方面，不多解释。然后n = int(input())， input就是获取你输入进来的东西，因为input返回的是str类型，而n需要是int（前面def说过），所以加一个int，确保n是int最后就是调用，方法+参数，达到输出斐波那契数列的效果", "Konwledge_Point": "Fibonacci数列", "Question": "这个斐波那契数列的代码怎么解释呀，哪位明白人给解释一下每一行的意思\n问题遇到的现象和发生背景\n\n\n问题相关代码，请勿粘贴截图\n\n\n运行结果及报错内容\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果\n\n\n\n\n这个斐波那契数列的代码怎么解释呀，哪位明白人给解释一下每一行的意思，谢谢大家", "Tag": "算法分析"}
{"Answer": "\n#include <iostream>\nusing namespace std;\n \nint main()\n{\n    long long a[50],s=0;\n    int i, n;\n    cin >> n;\n    a[1] = 1;\n    a[2] = 1;\n    if (n == 1)\n    {\n        cout << \"1\" << endl;\n    }\n    else if (n == 2)\n    {\n        cout << \"2\" << endl;\n    }\n    else\n    {\n        for (i = 3; i <= n; i++)\n        {\n            a[i] = a[i - 1] + a[i - 2];\n            s += a[i];\n        }\n        cout << s+2 << endl;\n    }\n    return 0;\n}\n", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列求和，可能是取模取不对\n斐波那契数列，F1=F2=1，从第三项开始，每项等于前两项之和。约定S1=1，Sn<=Fn+1时，Sn+1=Sn+Fn+1，否则Sn+1=Sn-Fn+1。p=1000000007，因为结果可能很大，将计算过程中所有Fn和Sn取模。输入n，输出Sn。\n计算规则例如：S6=1+1+2-3+5+8=14。\n\n\n#include \nusing namespace std;\nint main()\n{\n    long int n;\n    long int p = 1000000007;\n    long int count;\n    long int a = 1;\n    long int b = 1;\n    long int sum = 1;\n    cin >> n;\n    for (count = 2; count <= n; count++) {\n        if (sum % p <= b % p) {\n            sum = sum + b;\n        } else if (sum % p > b % p) {\n            sum = sum - b;\n        }\n        b = b + a;\n        a = b - a;\n    }\n    cout << sum;\n    return 0;\n}\n不知道为什么总是不对，个人认为可能是取模的问题，求指点！🥺🥺", "Tag": "算法分析"}
{"Answer": "\npackage com.wf.fx.demo01;\n\nimport javafx.application.Application;\nimport javafx.event.EventType;\nimport javafx.scene.Scene;\nimport javafx.scene.control.Button;\nimport javafx.scene.control.Label;\nimport javafx.scene.control.TextField;\nimport javafx.stage.Stage;\nimport org.kordamp.bootstrapfx.scene.layout.Panel;\n\nimport java.util.Arrays;\n\npublic class HelloApplication extends Application {\n    @Override\n    public void start(Stage stage) {\n        Panel panel = new Panel();\n        Label label = new Label();\n        TextField textField = new TextField();\n        Button button = new Button(\"计算\");\n        button.addEventHandler(EventType.ROOT,event -> {\n            label.setText(Arrays.toString(getF(Integer.parseInt(textField.getText()))));\n        });\n        panel.setBody(textField);\n        panel.setFooter(button);\n        panel.setHeading(label);\n        Scene scene = new Scene(panel, 320, 240);\n        stage.setTitle(\"Hello!\");\n        stage.setScene(scene);\n        stage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n\n    public static int[] getF(int value) {\n        int n = value;\n        int[] a = new int[n];\n        a[0] = 1;\n        if (n > 1) {\n            a[1] = 1;\n            for (int i = 2; i < a.length; i++) {\n                a[i] = a[i - 1] + a[i - 2];\n            }\n        }\n        return a;\n    }\n\n}\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列，求解答\n必须在JavaFX技术框架下做，不可采用AWT或Swing技术。\n编写 GUI 程序。当用户在界面上输入任一个正整数 n 后，界面可显示 Fibonacci （斐波那契）数列第 n 项的值。", "Tag": "算法分析"}
{"Answer": "\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int a=1,b=1,n,i=1,k=3;\n    cin>>n;\n    while(n>=3 && k<=n){\n        i=a+b;\n        a=b;\n        b=i;\n        k++;\n    }\n    cout<<i;\n    return 0;\n}\n", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列的第n项，哪里出错了？要用循环语句。\n题目描述\n给定一个数列 1  1  2  3  5  8  13 求该数列的第n项\n\n\n输入\n一个整数n。\n输出\n一行，包含一个整数，表示该数列的第n项的值。\n\n\n样例输入 Copy\n1\n样例输出 Copy\n1\n\n\n写法如下，哪里有问题，最好能提供完整代码。\n\n", "Tag": "算法分析"}
{"Answer": "\n#include <stdio.h>\nint main()\n{\n    long long i, n=0, t1 = 1, t2 = 1, nextTerm;\n    for (i = 1; i <= 50; ++i)\n    {\n        n++;\n        printf(\"%lld \", t1);\n        nextTerm = t1 + t2;\n        t1 = t2;\n        t2 = nextTerm;\n        if(n%5==0)\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列前五十，每行五个\nC语言打出斐波那西数列前五十个，每行五个怎么搞啊，磨半天了", "Tag": "算法分析"}
{"Answer": "输出函数是什么", "Konwledge_Point": "Fibonacci数列", "Question": "关于求斐波那契数列溢出的问题\n关于求斐波那契数列的问题：\n\n\n我64位电脑，返回unsighed long long怎么才到47项就溢出了，不应该能算更多吗？谢谢！", "Tag": "算法分析"}
{"Answer": "如果我的回答对你有帮助，可以点击【采纳】按钮，给采纳一下吗，谢谢。", "Konwledge_Point": "Fibonacci数列", "Question": "求大佬帮忙解答这个python斐波那契数列代码怎么续\n\n\ndef fib(n):\n    if n==1:\n        print(1)\n    elif n==2:\n        print(1,1)\n    elif n>2:\n        print(1,1,end=\" \")\n    count = 0\n    n1 = 1\n    n2 = 1\n    while count < n-2:\n        nth = n1 + n2\n        print(nth,end=\" \")\n        # add your program here to complete it", "Tag": "算法分析"}
{"Answer": "条件改为a[i]+a[i+1] > 100", "Konwledge_Point": "Fibonacci数列", "Question": "输出小于100的斐波那契数列，为啥总是多一个\n代码如下：\na=[1,1]\nfor i in range(100):\n    if a[-1]>100:\n        break\n    a.append(a[i]+a[i+1])\nfor i in a:\n    print(i)\n总是多一个144", "Tag": "算法分析"}
{"Answer": "for(b=1;b<=n;b++)z定义为long long，那么建议x,d也定义成long long", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列求第n项这样写为什么不对？\n#include \n#include \nint main(void)\n{\nint n,b=0,x=1,d=0;\nlong long z=0;\nscanf(\"%d\",&n);\nfor(b=0;b<=n;b++)\n {\nz=x+d;\nx=d;\nd=z;\n }\nprintf(\"%lld\",z);\nreturn 0;\n}", "Tag": "算法分析"}
{"Answer": "", "Konwledge_Point": "Fibonacci数列", "Question": "求斐波那契数列，用数组求，不知道错哪了。\n此处凑一下字数，请忽略额西，啊加无，以，额，打，哭，求不呀不洗可以", "Tag": "算法分析"}
{"Answer": "这是递归调用。调用过程是，首先 System.out.println(fib(4));调用fib(4)在fib(4)中n=4，执行到 fib1=fib(n-1);时等于是调用fib(3)在fib(3)中n=3，又执行到 fib1=fib(n-1);时等于是调用fib(2)在fib(2)中 直接return 1;又回到在fib(3)中执行到 fib2=fib(n-2);时等于是调用fib(1)在fib(1)中也是直接return 1;又回到在fib(3)中继承执行 fib2=fib(n-2);之后的代码，输出:n=3n1:2n2:1fib1=1:fib2=1fib3=2\n\n等执行到return fib3;会回到fib(4)中又执行 fib2=fib(n-2);等于是又调用fib(2)一次。在fib(2)中return 1;又回到在fib(4)中继承执行 fib2=fib(n-2);之后的代码，输出:n=4n1:3n2:2fib1=2:fib2=1fib3=3\n", "Konwledge_Point": "Fibonacci数列", "Question": "java关于不死神兔子的繁殖理解（斐波那契数列--兔子繁殖）\n第一次发贴求解，自学java，关于不死神兔代码的理解卡壳了，原理基本懂:f(n)=f(n-1)+f(n-2);\n代码如下：\n\n\npublic\n \nclass\n DiGui {\n    \n    \npublic\n static \nvoid\n main(String[] args) {\n        \nSystem\n.\nout\n.println(fib(\n4\n));\n        \n    }\n    \npublic\n static \nint\n fib(\nint\n n) {\n        \nif\n(n == \n1\n || n == \n2\n) {\n            \nreturn\n \n1\n;\n        }\nelse\n {\n            \nint\n fib1,fib2,fib3;\n            fib1=fib(n\n-1\n);\n                        fib2=fib(n\n-2\n);\n                        fib3=fib1+fib2;\n            \nSystem\n.\nout\n.println(\"n=\"+n);\n            \nSystem\n.\nout\n.println(\"n1:\"+(n\n-1\n));\n            \nSystem\n.\nout\n.println(\"n2:\"+(n\n-2\n));\n            \nSystem\n.\nout\n.println(\"fib1=\"+fib1+\":\"+\"fib2=\"+fib2);\n            \nSystem\n.\nout\n.println(\"fib3=\"+fib3);\n            \nSystem\n.\nout\n.println(\"--------------------\");\n            \nreturn\n fib3;\n        \n        }\n    }\n\n}\n\n\n\n\n\n运行的如果如下：\n\n\nn=3\nn1:2\nn2:1\nfib1=1:fib2=1\n\nfib3=2\n--------------------\n\nn=4\nn1:3\nn2:2\nfib1=2:fib2=1\n\nfib3=3\n--------------------\n\n3\n\n\n\n\n不理解的地方是：fib(n-1)和fib(n-2)，输出的结果是：\n                                           fib1=fib(n-1); 当n=4时：fib1=2、当n=3时：fib1=1\n                                           fib2=fib(n-2); 当n=4时：fib2=1、当n=3时：fib2=1\n请问该如何理解？", "Tag": "算法分析"}
{"Answer": "printf(\"s=%lf\",s);", "Konwledge_Point": "Fibonacci数列", "Question": "有关斐波那契数列的1000项加减 求纠正       求s=2/1-3/2+5/3-...\n#include\n#include\nint main()\n{\n    int a=1,b=1,i=1,e,n=1000;\n    double d,s=0;\n    for(i=1;i<=n;i++)\n        {\n            d=(a+b)/b;\n            s+=((i%2)*2-1)*d;\n            e=a+b;\n            a=b;\n            b=e;\n        }\n    printf(\"s=%lf\",&s);\n    return 0;\n}", "Tag": "算法分析"}
{"Answer": "你好。\r\n首先，mun的值没有变成mun1+mun2。因为，先将mun2的值复制给了mun,此处仅仅是把mun2的值复制给mun,随后mun 和mun2便没有任何联系了。\r\n对于上述三行代码：斐波那契数列是：1、1、2、3、5、8、13、21、34....开始时，mun1=1,mun2=2    然后经过一次循环上述三行代码后，mun1=1,mun2=2\r\n再经过一次循环后，mun1=2,mun2=3  由此可见这三行代码是将mun1,mun2依次后移\r\n由斐波那契数列公式可知：f(n)=f(n-1)+f(n-2)\r\n希望能够帮助你理解", "Konwledge_Point": "Fibonacci数列", "Question": "求解答《斐波那契数列算法》的代码注释— 题目：古典问题：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？\npublic static void rabbit() {\n        int mun1=1,mun2=1;\n        int mun;\n        int month=10;\n        for(int i=1;i<=month;i++) {\n        if(i<=2) {\n        System.out.println(\"第\"+i+\"个月的兔子总数量是1对\");\n                 }else {\n                mun=mun2;\n                mun2=mun1+mun2;\n                mun1=mun;\n        System.out.println(\"第\"+i+\"个月的兔子\n            总数量是\"+mun2+\"对\");\n            }\n        }\n\n\n\n\n```重点解答一下\n\n\n\n\n                mun=mun2;\n                mun2=mun1+mun2;\n                mun1=mun;\n            System.out.println(\"第\"+i+\"个月的兔子\n            总数量是\"+mun2+\"对\");\n\n\n\n\n这串代码的意思，数学不好搞了一个小时没搞明白为什么是这样子写，\n**mun**的值在**mun2=mun1+mun2**这串代码里是否也变成**了mun1+mun2?**\n", "Tag": "算法分析"}
{"Answer": "\npublic static Integer getNumF(List<Integer> list){\n        if (list.size() == 40){\n            return list.get(list.size() - 1);\n        }else{\n            if (list.size() < 2){\n                list.add(1);\n                return getNumF(list);\n            }else{\n                Integer integer = list.get(list.size() - 1);\n                Integer integer2 = list.get(list.size() - 2);\n                list.add(integer + integer2);\n                return getNumF(list);\n            }\n        }\n    }\n ", "Konwledge_Point": "Fibonacci数列", "Question": "求Fibonacci数列：1,1,2,3,5,8…第四十个数的值，（使用递归）\n求解答，必定采纳。求解答，必定采纳。求解求解", "Tag": "算法分析"}
{"Answer": "\n\n#include <stdio.h>\nint main()\n{\n   int a,b,c,i;\n   a = 1;\n   b = 1;\n   printf(\"1 1 \");\n   for(i = 2;i < 30;i++){\n       c = a + b;\n       printf(\"%d \",c);\n       a = b;\n       b = c;\n   }\n}\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "求数列 1 1 2 3 5 8 13 21…的前30个数\n用for循环语句输出斐波那契数列的前三十个数…………………………………………", "Tag": "算法分析"}
{"Answer": "就是右对齐输出 你可以百度c语言右对齐输出，如果编译器不支持，可以试试其他设置方案喽，应该还是设置printf的输出，感觉是你这个编译器不支持吧，我在vs2019上测试是可以的：\n", "Konwledge_Point": "Fibonacci数列", "Question": "c语言 数列分行输出格式\n要求是分行输出斐波那契数列\n这种格式怎么输出啊？\n好像是右对齐，又不是右对齐？？\n请教各位\n我的意思是怎么输出这种要求格式，第一行前两个右对齐，但后三个不是右对齐？好难弄\n(图像: auto-orient,1)", "Tag": "算法分析"}
{"Answer": "def fib_n(n):\n    if n == 1:\n        return 0, 0\n    else:        \n        a = [0, 1]        \n        i = 2\n        while True:\n            t =  a[i-2] + a[i-1]\n            if len(str(t)) == n:\n                return t, i\n            a.append(t)\n            i += 1\nb = int(input(\">>>\"))\ns,j = fib_n(b)\n\nprint(f\"Fib({j}) = {s}\")\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "python如何寻找第一个n位的斐波那契数\n自定义函数Fib_n(n)计算斐波那契数列中第一次出现n位数字的是哪一项，返回项的序号及该数。输入待寻找的斐波那契数列中第一次出现的位数n，调用Fib_n()函数计算并输出满足要求的项的序号及数。\n输入\n[1,1000]范围内的一个整数\n输出\n第一次出现的该数长度的斐波那契数\n样例输入\n10\n样例输出\nFib(45)=1134903170\n\n\n我的问题是 如何递归？", "Tag": "算法分析"}
{"Answer": "首先先开一个数组，把斐波那契数列存到数组里，然后再读入两个数字m和n，寻找数组中满足条件数字，输出来\r\n\r\n```\r\n #include\r\nint main()\r\n{\r\n\tint f[100];\r\n\tint m, n, i;\r\n\r\n\tf[0] = 1; f[1] = 1;\r\n\tfor (i = 2; i < 100; i++)f[i] = f[i - 1] + f[i - 2];\r\n\r\n\tscanf(\"%d%d\", &m, &n);\r\n\t\r\n\tfor (i = 0; f[i] < m; i++);\r\n\tfor (; f[i]<n; i++) printf(\"%d \",f[i]);\r\n\r\n\treturn 0;\r\n}\r\n```\r\n程序有些小毛病没有太细致的修改。比如斐波那契数列后续的数目越来越大，int很有可能存不下，如果m和n比较大的话会出错。如果出现这种情况，建议你用long或者更大的数来存。再有，我默认了m比较小而n比较大。如果程序有其他要求或条件的话，需要进行相应的修改", "Konwledge_Point": "Fibonacci数列", "Question": "新人求解一道C语言问题！！！！\n输出[m,n]范围内的所有斐波那契（Fibonacci）数，m,n这两个数由键盘输入。\n\n【提示】\n\n1,1,2,3,5,8,13,21,34,……这是斐波那契（Fibonacci）数列的前几项。斐波那契数列的特点：前两项均为1，后面任意一项都是其前面两项之和。\n\n本实验虽然只要求输出在[m,n]范围内的斐波那契数，但是依然需要从第1个Fibonacci数开始依次得到下一个，并判断是否是需要输出的那个。", "Tag": "算法分析"}
{"Answer": "#include<iostream>\nusing namespace std;\ndouble Power(double x, int n)\n{\n    int i;\n    double sum = 1;\n    if( n >= 1 )\n    {\n        for(i=0; i<n ;i++)\n        {\n            sum *= x;\n        }\n    }\n    return sum;\n}\nint Fi( int n )\n{\n    if(n==1)\n        return 1;\n    else if(n==2)\n        return 1;\n    else\n        return  Fi(n-1) + Fi(n-2) ;\n}\ndouble fun(int n,double x) {\n     double t=x;\n    if( n==1)\n        return t;\n    else{\n        int i;\n        for(i=2;i<=n;i++){\n\n            t+=Power(-1,i-1)*Fi(i-1) * Fi(i)*Power(x,i*2-1);\n        }\n    }\n    return t;\n\n}\nint main() {\n    int n = 0;\n    double x;\n    cin >> x>>n;\n    cout<<fun(n,x);\n    return 0;\n\n}\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契级数和的计算\n如何将斐波那契数列和后面的x级数结合递归求和，是否能通过一个函数完成，还是需要将斐波那契单独为一个函数", "Tag": "算法分析"}
{"Answer": "兔子的规律为数列，1，1，2，3，5，8，13，21 \r\npublic class Fobonacci1 {  \r\n    public static void main(String[]args){       int f1 = 1;      int f2 = 1;      int sum = 0; \r\n     for(int i = 3; i <= 12; i++){       sum = f1 + f2;       f1 = f2;       f2 = sum;      \r\n \r\n     } \r\nSystem.out.println(\"一对兔子一年内（12个月）能繁殖成\" + sum + \"对。\"); \r\n } }", "Konwledge_Point": "Fibonacci数列", "Question": "JAVA初学者，学了，if  while for 了，有个人想知道，一年之内一对兔子能繁殖多少对？\n有个人想知道，一年之内一对兔子能繁殖多少对？于是就筑了一道围墙把一对兔子关在里面。已知一对兔子每个月可以生一对小兔子，而一对兔子从出生后第3个月起每月生一对小兔子。假如一年内没有发生死亡现象，那么，一对兔子一年内（12个月）能繁殖成多少对？（提示：斐波那契数列）\n\n顺便说下思路数！感谢》", "Tag": "算法分析"}
{"Answer": "\nint main(void)\n{\n    long fib = 1, a = 0, b = 0;\n    for (int i = 1; i <= 10; i++)\n    {\n        if (i % 2 != 0)\n            printf(\"%d %ld\\n\",i, fib);\n\n        b = fib;\n        fib += a;\n        a = b;\n    }\n\n    return 0;\n}\n", "Konwledge_Point": "Fibonacci数列", "Question": "这两个问题的代码 以及分析过程和算法\n求Fibonacci数列的前10项中奇数项的累和（显示项序号和项值）\n求Fibonacci数列的前十项中第一个值超过10的的项（显示项序号和项值）", "Tag": "算法分析"}
{"Answer": "\n#include <stdio.h>\n \nint main()\n{\n    int i, n, t1 = 1, t2 = 1, nextTerm;\n \n    printf(\"输出几项: \");\n    scanf(\"%d\", &n);\n \n    printf(\"斐波那契数列: \");\n \n    for (i = 1; i <= n; ++i)\n    {\n        printf(\"%d \", t1);\n        nextTerm = t1 + t2;\n        t1 = t2;\n        t2 = nextTerm;\n    }\n    return 0;\n}\n", "Konwledge_Point": "Fibonacci数列", "Question": "再来看看这一个测试题\n编程输出斐波那契数列的前n项。隻波那契数列是前两项为1，从第3项开始，每项都是前两项之和。输入正整数n (n<=30)，输出斐波那契数列的前n项。项之间用一个空格分隔，最后一项之后也有一个空格，\n输入\n10\n输出", "Tag": "算法分析"}
{"Answer": "假设重复输入一个大数，那么每次都会对这个大数进行F(n)求解，即每一次你都是从0开始，所以你可以用数组arr暂存F(n)的解，如果arr[n] = 0，则求解arr[n]=arr[n-1]+arr[n-2]，否则返回arr[n]", "Konwledge_Point": "Fibonacci数列", "Question": "代码输出时间超限怎么解决？\n问题:\n小D这几天喜欢上了斐波那契数列！我们都知道，斐波那契数列的递归定义是：\n (F1=1，F2=1，Fn=Fn-1+Fn-2(n≥3))，现在他想知道数列的第n项是奇数还是偶数，请你帮他算一算。\n输入\n输入数据包含多组测试数据，每个测试实例占一行，每行为一个数，表示斐波那契数列的第n项(1≤n<10^9)\n输出\n输出斐波那契数列的第n项是奇数还是偶数，奇数输出even，偶数输出odd，对于每个测试实例，输出一行。\n代码:\n#include \nint F(int n)\n{\n    if(n==1||n==2)\n        return 1;\n    else\n        return F(n-1)+F(n-2);\n}\n\n\nint main()\n{\n    int n;\n    while(scanf(\"%d\",&n)!=EOF)\n    {\n        if(F(n)%2!=0)\n            printf(\"even\\n\");\n        else\n            printf(\"odd\\n\");\n    }\n    return 0;\n}\n这个代码时间超限，有什么解决办法吗？", "Tag": "算法分析"}
{"Answer": "应该是‘\\t’'/t'会输出12148，'/u'会输出12149，对应acall码发现不对，暂时不知道为什么", "Konwledge_Point": "Fibonacci数列", "Question": "水平制表符怎么使用（c++）\n输出斐波那契数列的前20项，想水平制表，并且每5个数字换一行，可是使用了'/t'之后整体就都不对了\n\n", "Tag": "算法分析"}
{"Answer": "使用System.nanoTime()要比System.currentTimeMillis()精确：\r\nlong start = System.nanoTime();\r\nFuction A  process.........\r\nlong end = System.nanoTime();\r\nLog.e(\"TimeCost: \", String.valueOf(end - start));", "Konwledge_Point": "Fibonacci数列", "Question": "Java Eclipse  怎么来对代码执行时间计时呢？\n我写了一段求斐波那契数列的java代码，没有用递归   想和使用递归的方式求斐波那契数列进行一个计算时间对比。     Eclipse有工具可以计时代码执行时间吗？  如果没有的话，应该插入什么来进行计时呢？\n\n\n\n貌似可以用系统时间来进行计时，开始和结束的时候都输出系统时间。但是有没有更好的方式呢？", "Tag": "算法分析"}
{"Answer": "换行的决定在这个语句\nif((i+1)%5==0)/*每输出5个数就换行*/\n    printf(\"\\n\");\n\n如果你不想换行可以将其删除如果你想改变换行数可以改变%后面的数字,现在是5,你可以将其改变为任何\n\n有帮助请采纳,有问题继续交流,你的采纳是对我回答的最大的肯定和动力\n", "Konwledge_Point": "Fibonacci数列", "Question": "为什么每输入五个就要换行啊\n#include\nint main (void)\n{\n    int i;\n    int fib[10]={1,1};//数组初始化，生成斐波那契数列前两个数\n    //动态数组未初始化，其余元素不能确定\n\n\n/*计算斐波那契数列剩余的8个数*/\n\n\nfor\n(i=\n2\n;i<\n10\n;i++){\n\nfib\n[i]=\nfib\n[i-\n1\n]+\nfib\n[i-\n2\n];}\n\n\n/*输出斐波那契数列*/\n\n \nfor\n(i=\n0\n;i<\n10\n;i++){\n    \nprintf\n(\n\"%d \"\n,\nfib\n[i]);\n    \nif\n((i+\n1\n)\n%\n5\n==\n0\n)\n/*每输出5个数就换行*/\n\n    \nprintf\n(\n\"\\n\"\n);\n}\n\nreturn\n \n0\n;\n\n\n\n}", "Tag": "算法分析"}
{"Answer": "# 如果问题得到解决，请点我回答左上角的采纳和向上的箭头，谢谢\r\n\r\n```\r\n#include \r\nusing namespace std;\r\n\r\nclass A\r\n{\r\nprivate:\r\n\tint n;\r\npublic:\r\n\tA(int x) { n = x; }\r\n\tvoid print()\r\n\t{\r\n\t\tint a = 1;\r\n\t\tint b = 1;\r\n\t\tfor (int i = 0; i < n; i++)\r\n\t\t{\r\n\t\t\tcout << a << endl;\r\n\t\t\tb = b + a;\r\n\t\t\ta = b - a;\r\n\t\t}\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tA a(10);\r\n\ta.print();\r\n\treturn 0;\r\n}\r\n```\r\n![图片说明](https://img-ask.csdn.net/upload/201811/28/1543384825_150413.gif)", "Konwledge_Point": "Fibonacci数列", "Question": "这个题目啥意思，看不懂\n题目:请编写一个类，这个类需要有一个正整数的私有属性，并且有一个公有方法能够求出并打印属性值所斐波那契数列对应的项目，比如这个类的整数属性为n，则该方法需更找出斐波那契数列的n项。需要编写主函数验证。(斐波那契数列为f1=1\n\n,f2=1,f3=2,fn=fn-1+fn+1", "Tag": "算法分析"}
{"Answer": "\nL=[1,1]\nwhile len(L)<30:\n    L.append(L[-1]+L[-2])\nprint(L)\n", "Konwledge_Point": "Fibonacci数列", "Question": "Python列表的相关简单问题\n我会求斐波那契数列，但是不会用列表的形势输出\n。asddwosjdhdbdksiwjsnzjwjskebxgukenz", "Tag": "算法分析"}
{"Answer": "PTA  oj的特色 不用管", "Konwledge_Point": "Fibonacci数列", "Question": "C语言，忽略了scanf返回值\n题目如下：\n斐波那契数，亦称之为斐波那契数列，指的是这样一个数列：0、1、1、2、3、5、8、13、21、……，这个数列从第3项开始，每一项都等于前两项之和。这里我们定义另外一种斐波那契数列： F(0) = 7, F(1) = 11, F(n) = F(n-1) + F(n-2) (n>=2)。编程计算该数列的前n（n<1000000）项是否能被3整除。\n我的代码如图：\n\n\n\n\n问题如图：\n\n\n请问忽略了返回值是什么意思，我的问题该怎么处理呢？谢谢解答", "Tag": "算法分析"}
{"Answer": "\ndef fqn_list(n):\n    list1 = []\n    a, b = 1, 1\n    for i in range(n-1):\n        a, b = b, a+b\n        list1.append(a)\n    list1.append(b)\n    return list1\n\nprint(fqn_list(10))", "Konwledge_Point": "Fibonacci数列", "Question": "小白来提问！Python\n写一个函数实现斐波那契数列(1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377…)。要求：接收一个参数，返回一个存着等量值的列表。如接收的参数值为5，则返回斐波那契数列前5个数的列表。", "Tag": "算法分析"}
{"Answer": "你这fun函数只有一个输入参数，没法用n-1项来计算第n项，但是仍然可以用递归。运行结果如下：\n代码如下：\n\n#include <iostream>\n#include <math.h>\nusing namespace std;\ndouble fun(double x)\n{\n    static int a = 1, b = 2;\n    static int tm = 0;\n    static double sum = 0;\n    double fi = (double)a / b * pow(x, 2 * tm);\n    if (fi < 1.0e-6)\n        return sum;\n    else\n    {\n        if (tm % 2 == 0)\n            sum = sum + fi;\n        else\n            sum = sum - fi;\n        tm++;\n        int t = a + b;\n        a = b;\n        b = t;\n    }\n    fun(x);\n    return sum;\n}\n\nint main()\n{\n    double x;\n    while (1)\n    {\n        cin >> x;\n        if (x > -1 && x < 1)\n            cout <<\"f(x)=\" << fun(x) << endl;\n        else\n        {\n            cout << \"输入参数错误\";\n            break;\n        }\n            \n    }\n    return 0;\n}\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "递归求级数问题，cosx的幂级数\n如何将斐波那契数列和后面的x结合，是否可以使用迭代法，比如n项待等于n-1项乘以一个式子", "Tag": "算法分析"}
{"Answer": "数组的，顺带把前面的几个问题都采纳了吧。\r\n```\r\n  #include \r\n\r\nint main()\r\n{\r\nint f[100];\r\nf[0]=1,f[1]=1,f[2]=2;\r\nint m,n;\r\nscanf(\"%d%d\",&m,&n);\r\n//获取输入的m，n的值\r\nint i=2;\r\nwhile(f[i]m)\r\n        printf(\"%d ,\",f[i]);\r\n        f[i+1]=f[i]+f[i-1];\r\n        i+=1;\r\n}\r\n\r\n   return 0;\r\n}\r\n```", "Konwledge_Point": "Fibonacci数列", "Question": "C语言问题新人求解 一道编程题目 \n输出[m,n]范围内的所有斐波那契（Fibonacci）数，m,n这两个数由键盘输入。\n\n【提示】\n\n1,1,2,3,5,8,13,21,34,……这是斐波那契（Fibonacci）数列的前几项。斐波那契数列的特点：前两项均为1，后面任意一项都是其前面两项之和。\n\n本实验虽然只要求输出在[m,n]范围内的斐波那契数，但是依然需要从第1个Fibonacci数开始依次得到下一个，并判断是否是需要输出的那个。\n\n\n\n用一维数组的？怎么写   要有一维数组啊！！！！", "Tag": "算法分析"}
{"Answer": "int i = 1;\nint j = 1;\nint n = Convert.ToInt32(Console.ReadLine());\nfor (int x = 3; x < n; x++)\n{\nj = i + j;\ni = j - i;\n}\nConsole.WriteLine(j);\n\n\n纯手工一笔一划写的。可能也就只有我一个人手工回答了", "Konwledge_Point": "Fibonacci数列", "Question": "没啥思路，给点思路吧\n本关任务：编写一个程序,计算斐波那契数列前N项的和。N由键盘输入。", "Tag": "算法分析"}
{"Answer": "```\r\nwhile(f[i]m){\r\n        printf(\"%d ,\",f[i]);\r\n}else{\r\nbreak;}\r\n}\r\n \r\n```", "Konwledge_Point": "Fibonacci数列", "Question": "一道C语言编程问题求解答如何写呢\n输出[m,n]范围内的所有斐波那契（Fibonacci）数，m,n这两个数由键盘输入。\n\n【提示】\n\n1,1,2,3,5,8,13,21,34,……这是斐波那契（Fibonacci）数列的前几项。斐波那契数列的特点：前两项均为1，后面任意一项都是其前面两项之和。\n\n本实验虽然只要求输出在[m,n]范围内的斐波那契数，但是依然需要从第1个Fibonacci数开始依次得到下一个，并判断是否是需要输出的那个。\n\n用一维数组的？怎么写 要有一维数组啊！！！！", "Tag": "算法分析"}
{"Answer": "递归实现斐波那契数列的时候，递归式类似下面的式子：\r\n[align=center][/align]f(n) = f(n-1) + f(n-2)\r\n所以对于每一项f(i)，都可视为一棵二叉树的根节点，层层向下扩展。整个递归树有许多重复的节点，也就意味着许多重复的运算。递归运算本来就存在入栈出栈时间空间消耗的问题，所以重复运算多的时候，开销就大了。\r\n  而循环实现斐波那契数列的时候，不存在重复运算的问题。\r\n\r\n  递归实现阶乘的时候，类似下面的式子：\r\n[align=center][/align]f(n) = n * f(n-1)\r\n  不存在每次递归多出一项的问题，跟循环其实没啥区别。", "Konwledge_Point": "Fibonacci数列", "Question": "关于递归的一个小疑惑\n总共有四个方法, 两个递归方法, 两个循环方法.\n我分别用递归A和循环A实现斐波那契数列, 递归B和循环B实现阶乘计算.\n可是我很好奇, 同样是计算:\n前者中,递归的实现明显比循环实现的性能要低很多(或者说慢很多), 但是后者所用的时间几乎相当(甚至循环还要高点) ?", "Tag": "算法分析"}
{"Answer": "可以在基类里定义 IsError 抽象方法\r\n\r\n三个类重载这个方法,把各自的判断写里面。", "Konwledge_Point": "Fibonacci数列", "Question": "不同类型的error应该怎么输出呢\n需要三个class\n\n1.Reverse.cpp\n\n包含两个函数一个反转正整数，一个反转字符，需要使用递归的方法\n\nint reverseDigit(int value)\n\nstring reverseString(string letters)\n\n2.Fibonacci.cpp\n\n用递归法计算斐波那契的数列\n\n3.EfficientFibonacci.cpp\n\n用优化的方法计算斐波那契数列\n\n\n\n输入四个值\n\n第一个i是非零正整数。如果输入是负数或者是字符就输出ERROR\n\n第二个s是字符串，如何输入时数字就输出ERROR\n\n第三个n1是非零正整数，使用Fibonacci.cpp计算的,如果输入不是非零正整数就输出ERROR\n\n第四个n2是非零正整数，使用EfficientFibonacci.cpp计算的，如果输入不是非零正整数就输出ERROR\n\n\n\nSample input 1:  12345 apple 6 6\n\nSample output 1:  54321 elppa 8 8\n\nSample input 2:  -1 appa 20 3\n\nSample output 2:  ERROR appa 6765 2\n\nSample input 3:  11900 Beer sa 11\n\nSample output 3:  911 reeB ERROR 89\n\n\n\n写了的三个函数\n\n\n\nFibonacci::Fibonacci(int n)\n{\n    if(n==1||n==2)\n    {\n        return 1;\n\n    }else \n    {\n        return Fibonacci(n-1)+Fibonacci(n-2);\n    }\n};\n\n\n\n\nint EfficientFibonacci::calculate(int n)\n{\n    if (n <= 2 && top == 0)\n    {\n      top = 2;\n      arr[0] = 1;\n      arr[1] = 1;\n      return arr[n - 1];\n    }\n    if (top == n - 1)\n    {\n      top = n;\n      arr[n - 1] = arr[n - 2] + arr[n - 3];\n      return arr[n - 1];\n    }\n      else if (top > n - 1)\n    {\n      return arr[n - 1];\n    }\n    return Fibonacci(n - 2) + Fibonacci(n - 3);\n};\n\n\n\n\nint Reverse::reverseDigital(int value)\n{\n    if(value<10&&value>0)\n    {\n        printf(\"%d\",n);\n        return;\n    }else if(value>=10)\n    {\n        printf(\"%d\",n%10);\n        inverted(n/10);\n\n    }else   \n    {\n        printf(\"%s\\n\",\"ERROR\");  \n    }\n    return;\n\n\n};\n", "Tag": "算法分析"}
{"Answer": "CD明显不对，去摸了运算不会溢出，更不会访问无效内存看AB递归层数过多没有跳出会因为系统分配栈空间溢出，导致错误所以选择B", "Konwledge_Point": "Fibonacci数列", "Question": "CSP初赛模拟笔试题递归函数报错原因\n求本题答案及方法\n小恺编写了如下函数，希望计算斐波那契数列 f(n)第 n 项对 10000 取余数的值：\n\n\nint\n \nf\n(\nint\n x)\n \n{\n  \nif\n(x <= \n2\n)\n    \nreturn\n \n1\n;\n  \nint\n ans = \nf\n(x - \n1\n) + \nf\n(x - \n2\n);\n  ans %= \n10000\n;\n  \nreturn\n ans;\n}\n\n\n\n在运行空间限制 128MB、栈空间不超过空间限制、运行时限 1 秒的情况\n下，在主函数中运行函数 f(12345)，则最有可能首先发生什么问题？\nA. 运行时间超时 B. 栈溢出\nC. 访问无效内存 D. 返回错误的答案", "Tag": "算法分析"}
{"Answer": "\nint main()\n{\n    int k, find = 0;\n    int n, t;\n    cin >> k;\n    for (n = 2; n < 100; ++n)\n    {\n        t = f(n);\n        if (k == t)\n        {\n            find = n;\n            break;\n        }\n        else if (t > k) // int装不下46项之后的数，数列值超过k后没必要再找了。\n            break;\n    }\n    if (find)\n        cout << n << endl;\n\n    else\n        cout << -1;\n}\n", "Konwledge_Point": "Fibonacci数列", "Question": "循环避免判断多次的问题\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\nint\n \nf\n(\nint\n n)\n\n\n{\n \nif\n (n == \n1\n) \nreturn\n \n1\n;\n \nif\n (n == \n2\n) \nreturn\n \n1\n;\n \nelse\n\n     \nreturn\n  \nf\n(n - \n1\n) + \nf\n(n - \n2\n);\n}\n\nint\n \nmain\n()\n \n\n{\n \nint\n k;\n \nint\n n;\n cin>>k; \n \nfor\n(n=\n2\n;n<\n100\n;++n)\n {\nif\n (k== \nf\n(n)) {\n cout << n;\n \nbreak\n;}\n \nelse\n {\n cout<<\n-1\n;} \n }\n}\n\n\n\n\n我想判断输入的数是不是斐波那契数列里的，但else里的-1每次输入都会判断一次\n如何让他只判断一次呢？我加入n>100也不行", "Tag": "算法分析"}
{"Answer": "", "Konwledge_Point": "Fibonacci数列", "Question": "for嵌套循环为何不执行\n建立一个一维数组a，数组要预留足够的长度，以完成以下任务：\n（1）    自动生成斐波那契数列前10项的值，存入数组a，并输出。（斐波那契数列前两项的值为1，从第三项开始，每一项的值是前两项值的和）；\n（2）    插入操作：将键盘输入的一个整数插入数组a，使得数组a中的元素仍有序。要求可重复插入数据直到数组空间用完，或者用户不再需要插入数据为止\n\n\n代码如下：\n\n\n#include\"stdio.h\"\n\n\nint main()\n{\n    int a[100],\ni\n=0,b=0,j=0,k=0,o,n;char m;\n    a[0]=1;a[1]=1;\n    \nfor\n(\ni\n=1;i<=8;i++)\n        a[i+1]=a[i-1]+a[i];\n    \nfor\n(\ni\n=0;i<=9;i++)\n        printf(\n\"%d \"\n,a[i]);\n    \nfor\n(\nn\n=10;;n++)\n    {\n    printf(\n\"请输入待插入的数据：\"\n);\n    scanf(\n\"%d\"\n,&b);\n    a[n]=b;\n    \nfor\n(\ni\n=0;ia[j]){\nk\n=a[j];a[j]=a[j+1];a[j]=k;}\n    printf(\n\"插入数据%d后的有序数列：\\n\"\n,b);\n    \nfor\n(\no\n=0;o<=n;o++)\n        printf(\n\"%d \"\n,a[o]);\n    putchar(\n'\\n'\n);\n    printf(\n\"是否继续插入数据？（y/n）:\"\n);\n    scanf(\n\"%c\"\n,&m);\n    \nif\n(\nm\n=\n'y'\n)continue;\n    \nelse\n break;\n    }\n}\n\n\n\n\n为什么第四个for循环不执行？？", "Tag": "算法分析"}
{"Answer": "```\r\n不要用递归\r\nint main()\r\n{\r\n    int n;\r\n    cin >> n;\r\n    if (n == 1 || n== 2) cout << 1;\r\n\t\tint a = 1;\r\n\t\tint b = 1;\r\n\t\tfor (int i = 2; i < n; i++)\r\n\t\t{\r\n\t\tb = a + b;\r\n\t\ta = b - a;\r\n\t\t}\r\n\t\tcout << b % 10007;\r\n    return 0;\r\n}\r\n```", "Konwledge_Point": "Fibonacci数列", "Question": "怎样的做法才能做到运行不超时？所以这道题不能用递归吗？\n\n//Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。\n\n当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。\n\n\n\n#include \nusing namespace std;\nint fun(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fun(n - 1) + fun(n - 2);\n}\nint main()\n{\n    int n;\n    cin >> n;\n    cout << (fun(n) % 10007);\n    return 0;\n}\n", "Tag": "算法分析"}
{"Answer": "\n# 第一题\nd = {'k1': [], 'k2': []}\nfor i in [6,29,32,45,50,60,77,80,100,90]:\n    if i >= 60:\n        d['k1'].append(i)\n    else:\n        d['k2'].append(i)\nprint(d)\n\n# 第二题\ndef fun(n):\n   if n == 1:\n       return [0]\n   elif n == 2:\n       return [0, 1]\n   l = [0, 1] \n   for i in range(2, n):\n       l.append(l[-2] + l[-1])\n   return l\n\nprint(fun(15))\n", "Konwledge_Point": "Fibonacci数列", "Question": "有关Python的基础问答题\n1、有如下值的列表[6,29,32,45,50,60,77,80,100,90]，请编程实现：构造字典将所有大于60的值保存至字典的第一个key中，将小于60值保存至第二个key的值中，并打印字典数据，即打印结果：{'k1': [6, 29, 32, 45, 50], 'k2': [77, 80, 100, 90]}。\n\n\n\n \n\n\n\n2、定义一个类Myclasss及方法factorial，实例化类对象并调用方法factorial打印用户输入的数n的斐波那契数列。斐波那契数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递归的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n>=2，n∈N*）。如用户输入10， 则打印结果：1,1,2,3,5,8,13,21,34,55， 请编程实现\n\n\n\n \n\n\n\n \n\n\n\n3、定义一个教师类Teacher，教师对象有teac_id、teac_name、age三个成员变量，成员方法display_info用于显示教师的基本信息。定义完类Teacher后，创建一个教师对象，并输出该教师的基本信息。\n\n\n\n \n\n\n\n4. 利用random库随机产生2个整数列表，每个列表10个元素，元素取值范围1~100，判断两个列表中是否存在相同元素，若存在，则打印出所有相同元素及其在两个列表中的下标，若不存在，将两个列表合并为一个列表后打印出来。\n\n\n\n \n\n\n\n \n\n\n\n5.利用jieba和wordcloud库，绘制出文件“中国共产党十九届五中全会公报.txt”中前1000个热点词云。\n\n\n\n【提示】词云形状自选，中国共产党十九届五中全会公报.txt文件及可能用到的其它文件见文件夹data。\n\n\n\n \n\n\n\n6．输入两个数x 和y，如果x 或y 小于等于0，提示请输入正整数，求这两个数的最大公约数和最小公倍数。\n\n\n\n注意：可以采用欧几里得辗转相除算法来求最大公约数。最小公倍数的计算方法是两数的乘积除以两数最大公约数的结果。\n\n\n\n \n\n\n\n \n\n\n\n7．定义一个函数fsum，求1+2+3……+n-1+n的值。用此函数计算机n=1000的值\n\n\n\n \n\n\n\n8. 编写一个程序，打印出如下图所示的金字塔。\n\n\n\n \n\n\n\n下图附第八题\n\n\n\n\n\n\n ", "Tag": "算法分析"}
{"Answer": "int fun(int n)\r\n{\r\n    if (n == 1 || n == 2)\r\n        return 1;\r\n    else\r\n        return fun(n - 1) + fun(n - 2);\r\n}\r\n这个方法最慢\r\n可以用\r\nint fun(int n)\r\n{\r\nint a = 1;\r\nint b = 1;\r\nfor (int i = 1; i < n; i++)\r\n{\r\nb = a + b;\r\na = b - a;\r\n}\r\nreturn b % 10007;\r\n}", "Konwledge_Point": "Fibonacci数列", "Question": "用什么方法才能不超时？不求和要怎样直接求余数？\n\n\n\n/*Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。\n当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。*/\n#include \n#include \n#define M 10007\nusing namespace std;\nint fun(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fun(n - 1) + fun(n - 2);\n}\nint main()\n{\n    int n;\n    cin >> n;\n    cout << fun(n)%M << endl;\n    return 0;\n}\n", "Tag": "算法分析"}
{"Answer": "直接写sql不好搞，除非是存储过程。用其它语言生成sql语句是最简单，比如用python:\nclass Fibonacci(object):\n\n    def __init__(self, n):\n        self.n = n\n        self.current = 0\n        self.a = 14\n        self.b = 8\n\n    def __next__(self):\n        if self.current == 0:\n            self.current += 1\n            return self.a\n\n        if self.current < self.n:\n            self.a, self.b = self.b, self.a + self.b\n            self.current += 1\n            return self.a\n        else:\n            raise StopIteration\n\n    def __iter__(self):\n        return self\n\n\nif __name__ == '__main__':\n    day = 1\n    fib = Fibonacci(30)\n    # INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)\n    for num in fib:\n        print(f\"insert into oth.power (month，day，fee) values (6, {day}, {num});\")\n        day += 1\n\n结果是：\ninsert into oth.power (month，day，fee) values (6, 1, 14);\ninsert into oth.power (month，day，fee) values (6, 2, 8);\ninsert into oth.power (month，day，fee) values (6, 3, 22);\ninsert into oth.power (month，day，fee) values (6, 4, 30);\ninsert into oth.power (month，day，fee) values (6, 5, 52);\ninsert into oth.power (month，day，fee) values (6, 6, 82);\ninsert into oth.power (month，day，fee) values (6, 7, 134);\ninsert into oth.power (month，day，fee) values (6, 8, 216);\ninsert into oth.power (month，day，fee) values (6, 9, 350);\ninsert into oth.power (month，day，fee) values (6, 10, 566);\ninsert into oth.power (month，day，fee) values (6, 11, 916);\ninsert into oth.power (month，day，fee) values (6, 12, 1482);\ninsert into oth.power (month，day，fee) values (6, 13, 2398);\ninsert into oth.power (month，day，fee) values (6, 14, 3880);\ninsert into oth.power (month，day，fee) values (6, 15, 6278);\ninsert into oth.power (month，day，fee) values (6, 16, 10158);\ninsert into oth.power (month，day，fee) values (6, 17, 16436);\ninsert into oth.power (month，day，fee) values (6, 18, 26594);\ninsert into oth.power (month，day，fee) values (6, 19, 43030);\ninsert into oth.power (month，day，fee) values (6, 20, 69624);\ninsert into oth.power (month，day，fee) values (6, 21, 112654);\ninsert into oth.power (month，day，fee) values (6, 22, 182278);\ninsert into oth.power (month，day，fee) values (6, 23, 294932);\ninsert into oth.power (month，day，fee) values (6, 24, 477210);\ninsert into oth.power (month，day，fee) values (6, 25, 772142);\ninsert into oth.power (month，day，fee) values (6, 26, 1249352);\ninsert into oth.power (month，day，fee) values (6, 27, 2021494);\ninsert into oth.power (month，day，fee) values (6, 28, 3270846);\ninsert into oth.power (month，day，fee) values (6, 29, 5292340);\ninsert into oth.power (month，day，fee) values (6, 30, 8563186);\n\n然后把生成好的sql去数据库执行一下就好了", "Konwledge_Point": "Fibonacci数列", "Question": "postgresql如何循环读取填充同一张表\n例如我现在在oth模式下有一张表oth.power\n有三个属性month，day，fee\n目前有两行数据：6 1 14\n               6 2 8\n这张表格第一第二列的规律分别是：第一列永远是6，第二列每到一行就+1\n而第三列的规律是满足斐波那契数列关系，从第三行开始，每一行的fee值都是上面两行的fee值之和\n可以推断，第三行的数据为：6 3 22， 第四行为：6 4 30。。。。。。依次类推\n现在需要我在这两行数据的基础上把这张表填充到共有30行为止。\n虽然我可以类推，但是这样需要我人工去一行一行的用insert 的语句去插入数据，请问能否写一个sql语言使得可以自动进行这个插入的步骤？", "Tag": "算法分析"}
{"Answer": "因为题目是要计算前20项的和，你写的是数组，数组下标从0开始所以，所以要从2开始；从0开始也是同理，你写的是以i为下标计算，所以要从0开始。", "Konwledge_Point": "Fibonacci数列", "Question": "#C语言 数组 为什么循环从2和0开始\n图片里第7和10行 为什么i的初始值是2和0？\n第一个for不是要从f[3]开始循环吗，怎么i=2呢？\n#include \n/\n使用[数组]输出Fibonacci数列前20项中的偶数之和。\n从第三项开始后一项是前两项之和（和值为3382）。\n/\nint fib(int f[],int n)\n{\n    int s=0,i;\n    for(i=2;i<n;i++)//求第三项开始的其他元素的值\n    f[i]=f[i-1]+f[i-2];\n\n\nfor\n(i=\n0\n;i<\n20\n;i++)\n\nif\n(f[i]%\n2\n==\n0\n)//逐一判断数值为偶数的数组元素\n\ns\n+=f[i];\n\nreturn\n s;\n\n\n\n}\nvoid main()\n{\n    int f[20]={1,1};\n    printf(\"%d\",fib(f,20));\n}", "Tag": "算法分析"}
{"Answer": "f3是作为临时变量的，只在for循环中使用，f1，f2记录前两轮计算的结果，而且需要考虑int长度不足问题，建议使用long类型。\r\n完整的代码示例：\r\n\r\n```\r\n \tpublic static long fabonacci(int date){\r\n\t\tlong f1 = 0;\r\n\t\tlong f2 = 1;\r\n\t\tfor (int i = 3; i <= date; i++) {\r\n\t        long f3;\r\n\t        f3 = f2;\r\n\t        f2 = f1 + f2;\r\n\t        f1 = f3;\r\n\t        System.out.println(\"第\" + i + \"月的兔子数量是：\" + f2);\r\n\t    }\r\n\r\n\t\treturn f2;\r\n\t}\r\n```", "Konwledge_Point": "Fibonacci数列", "Question": "古典问题，斐波那契兔子的问题\nfor (int i = 3; i < date; i++) {\n        int f3;\n        f3 = f2;\n        f2 = f1 + f2;\n        f1 = f3;\n        System.out.println(\"第\" + i + \"月的兔子数量是：\" + f2);\n    }\n\n我这样写的一串判断，为什么 f1 = f3;  f3=f1就不行吗，能讲解下吗\n", "Tag": "算法分析"}
{"Answer": "printf(\"%d %d\", fib(a),i); 参数从右往左入栈，入栈时i为0.把2个参数调换一下试试", "Konwledge_Point": "Fibonacci数列", "Question": "C语言printf输出不显示\n如题 我在用递归写 斐波那契数列的时候\n想知道他一共重复过几次 第一位和第二位\n于是我创建了这个代码：\n\n\nint\n i = \n0\n;\n\nint\n \nfib\n(\nint\n n)\n\n\n{\n    \nif\n (n > \n2\n)\n        \nreturn\n \nfib\n(n - \n1\n) + \nfib\n(n - \n2\n);\n    \nelse\n\n    {\n        ++i;  \n//我用这一行来计算重复过几次 第一位和第二位\n\n        \nreturn\n \n1\n;\n    }\n}\n\n\nint\n \nmain\n()\n\n\n{\n    \nint\n a = \n0\n;\n    \nscanf\n(\n\"%d\"\n, &a);\n    \nprintf\n(\n\"%d %d\"\n, \nfib\n(a),i);\n    \nreturn\n \n0\n;\n}\n\n\n\n结果无论输入什么 最后打印的fib(a)都是正确的 打印出的“i”却一直是0\n于是我选择了监视“i”\n但监视里\"i\"又有了正确的值 并非打印出的0\n于是我把主函数改成了这样\n\n\nint\n main()\n{\n    \nint\n a = \n0\n;\n    scanf(\n\"%d\"\n, &a);\n    \nprintf\n(\n\"%d\\n\"\n, fib(a));\n    \nprintf\n(\n\"%d\"\n,i);  \n//\n就是把 fit(a) 和 i 分两条打印\n    \nreturn\n \n0\n;\n}\n\n\n\n当我把\"fib(a)\",\"i\"用两个printf打印之后\n他们两个打印的效果又正常了\n\n\n想知道为什么刚刚一个printf打印两个值的时候  后者会一直变成0", "Tag": "算法分析"}
{"Answer": "int类型不能直接转list\ns=[]\ndef getFibonacci(n):\n       if n<3:\n        return 1 \n       else:return getFibonacci(n-1)+getFibonacci (n-2)\nN =int(input())\nfor i in range(N):\n    line = list(map(int,input().split(\", \")))\n    n=line[0]\n    d=line[1]\nfor j in range(n):\n     s.append(getFibonacci(j))\nif(n>=d and d!=0):\n    for x in range(n-1,n-d,-1):\n        print(s[x],end=\", \")\n    print(s[n-d-1])\nelif(d==0):\n    print()\nelse:\n    print('invalid')\n", "Konwledge_Point": "Fibonacci数列", "Question": "写Python程序遇到的问题\n问题遇到的现象和发生背景\n\n\n我想写一个Python程序输出一个指定长度的斐波那契数列然后在得到他的倒数几项，写的时候出现了一个问题我不知道如何解决\n\n\n遇到的现象和发生背景，请写出第一个错误信息\n\n\ndef getFibonacci(n):\n       \nif\n n<\n3\n:\n        \nreturn\n \n1\n \n       \nelse\n:\nreturn\n getFibonacci(n-\n1\n)+getFibonacci (n-\n2\n)\n\n\nN\n =\nint\n(\ninput\n())\n\nfor\n i in \nrange\n(\nN\n):\n    \nline\n = \nlist\n(\nmap\n(\nint\n,\ninput\n().\nsplit\n(\n\", \"\n)))\n    n=\nline\n[\n0\n]\n    d=\nline\n[\n1\n]\n\nfor\n \nj\n in \nrange\n(n):\n     s = \nlist\n(getFibonacci(\nj\n))\n\nif\n(n>=d \nand\n d!=\n0\n):\n    \nfor\n \nx\n in \nrange\n(n-\n1\n,n-d,-\n1\n):\n        \nprint\n(s[\nx\n],end=\n\", \"\n)\n    \nprint\n(s[n-d-\n1\n])\nelif(d==\n0\n):\n    \nprint\n()\n\nelse\n:\n    \nprint\n(\n'invalid'\n)\n\n\n\n\n\n\n用代码块功能插入代码，请勿粘贴截图。 不用代码块回答率下降 50%\n\n\n运行结果及详细报错内容\n\n\n显示的异常是：\n'int' object is not iterable\n  File \"C:\\Users\\admin\\Desktop\\新建文件夹 (3)\\Untitled-1.py\", line 12, in \n    s = list(getFibonacci(j))\n\n\n我的解答思路和尝试过的方法，不写自己思路的，回答率下降 60%\n\n\n我想要达到的结果，如果你需要快速回答，请尝试 “付费悬赏”", "Tag": "算法分析"}
{"Answer": "缩进和输出倒数第几项代码逻辑都有问题\n\ndef getFibonacci(n):\n       if n<3:\n        return 1 \n       else:return getFibonacci(n-1)+getFibonacci (n-2)\nN =int(input())\nfor i in range(N):\n    line = list(map(int,input().split(\", \")))\n    n=line[0]\n    d=line[1]\n    s=[]\n    for j in range(1,n):\n         s.append(getFibonacci(j))\n\n    if(n>=d and d!=0):\n        print(', '.join(map(str,s[-d:])))#取后n项直接切片就行了，题主原来的代码会越界\n    elif(d==0):\n        print()\n    else:\n        print('invalid')\n\n\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "Python程序输出结果不正确\n问题遇到的现象和发生背景\n\n\n我在用Python写一个得到一个指定长度的斐波那契数列的倒数几项时，发现我的程序要输出的结果不对，我一时看不出哪里有问题，希望能帮我看看\ninput：\n4\n5, 3\n7, 0\n7, 7\n7, 8\nexpected output\n5, 3, 2\n\n\n13, 8, 5, 3, 2, 1, 1\ninvalid\n\n\n遇到的现象和发生背景，请写出第一个错误信息\n\n\ns=[]\ndef getFibonacci(n):\n       \nif\n n<\n3\n:\n        \nreturn\n \n1\n \n       \nelse\n:\nreturn\n getFibonacci(n-\n1\n)+getFibonacci (n-\n2\n)\n\n\nN\n =\nint\n(\ninput\n())\n\nfor\n i in \nrange\n(\nN\n):\n    \nline\n = \nlist\n(\nmap\n(\nint\n,\ninput\n().\nsplit\n(\n\", \"\n)))\n    n=\nline\n[\n0\n]\n    d=\nline\n[\n1\n]\n\nfor\n \nj\n in \nrange\n(\n1\n,n):\n     s.\nappend\n(getFibonacci(\nj\n))\n\nif\n(n>=d \nand\n d!=\n0\n):\n    \nfor\n \nx\n in \nrange\n(n-\n1\n,n-d,-\n1\n):\n        \nprint\n(s[\nx\n],end=\n\", \"\n)\n    \nprint\n(s[n-d-\n1\n])\nelif(d==\n0\n):\n    \nprint\n()\n\nelse\n:\n    \nprint\n(\n'invalid'\n)\n\n\n\n\n\n\n用代码块功能插入代码，请勿粘贴截图。 不用代码块回答率下降 50%\n\n\n运行结果及详细报错内容\n\n\n我的输入和我输出来的结果：\n4\n5, 3\n7, 0\n7, 7\n7, 8\ninvalid\n我有点不明白是为啥只输出最后一行的结果\n\n\n我的解答思路和尝试过的方法，不写自己思路的，回答率下降 60%\n\n\n我想要达到的结果，如果你需要快速回答，请尝试 “付费悬赏”", "Tag": "算法分析"}
{"Answer": "你数组越界了，定义的时候定义了数组包含2个，也就是数组下标最大就是1，你后面都越界了。\n你可以直接定义一个大一点的数组 类似这样 int a[30] = {0};", "Konwledge_Point": "Fibonacci数列", "Question": "C语言问题，这个程序段输出结果发生错误（错误的原因是数组元素的计算和输出不能同时进行吗？）\n \n\n\n\n程序段先要实现输出斐波那契数列，就是输出1,1,2,3,5,8.。。。。\n\n\n\n错误程序段\n\n\n\n #include\n\nint main()\n\n{\n\n    int i,a[]={1,1};//此处定义数组大小是为了防止内存冲突的发生，有可能内存用来做其他事\n\n    for(i=0;i<20;i++)\n\n    {\n\n        printf(\"%d \",a[i]);\n\n        a[i+2]=a[i]+a[i+1];\n\n    }\n\n    return 0;\n\n}\n\n\n\n 输出结果\n\n\n\n\n\n\n \n\n\n\n \n\n\n\n \n\n\n\n ", "Tag": "算法分析"}
{"Answer": "\n <script>\n      // 等待页面加载完毕后，执行JS代码。\n      window.onload = function(){\n        // 获取class=\"re\"的第一个元素\n        var box=this.document.getElementsByClassName(\"re\")[0];\n        // 获取标签名称为li的元素\n        var lik=box.getElementsByTagName(\"li\");\n        //转换图片函数，就是把透明度改了一下\n        function fun(i,j){\n          // lik[i]的透明度变为不透明\n          lik[i].style.opacity=1;\n          // lik[j]的透明度变为透明\n          lik[j].style.opacity=0;\n\n          // lik[i]的z轴变为10\n          lik[i].style.zIndex=10;\n          // lik[j]的z轴变为0\n          lik[j].style.zIndex=0;\n          // lik[i+5]的背景颜色变为#ffffff\n          lik[i+5].style.backgroundColor=\"#ffffff\";//改一下小图标\n          // lik[j+5]的背景颜色变为#00000000\n          lik[j+5].style.backgroundColor=\"#00000000\"\n        }\n        //初始化下\n        fun(0,1);\n        \n        var i =0;\n        function auto(){//轮播循环函数\n          // 当i比5大的时候，执行fun函数，li变换第1个和第5个的透明度、z轴和背景色\n          if(++i>=5){\n            i=0;\n            fun(0,4);\n          }\n          // 当i在0~5之间的时候，执行fun函数，li变换第1个和第5个的透明度、z轴和背景色\n          else fun(i,i-1);\n        }\n        // 每2秒执行一次auto函数\n        timer=this.setInterval(auto,2000);\n        // 鼠标划上去，停止轮播\n        box.onmouseover = function () { \n          console.log('good');\n          clearInterval(timer);\n        }\n        //鼠标划出，继续轮播\n        box.onmouseout = function () { \n          timer = setInterval(auto, 2000); //调用定时器\n        }\n        var j =0;\n        for(;j<5;j++){//点击小图标也可以转换图片\n          lik[j+5].ind=j;\n          lik[j+5].onclick=function(){\n            fun(this.ind,i)\n            i=this.ind;\n          }\n        }\n\n      }\n\n    </script>\n", "Konwledge_Point": "Fibonacci数列", "Question": "html javascript这串代码每句话都是什么意思？\n如题。 我是一个初学者，没学过js,能告诉我每句话都是什么意思吗？\n\n\n<\nscript\n>\n\n\nwindow\n.\nonload\n = \nfunction\n(\n){\n  \nvar\n box=\nthis\n.\ndocument\n.\ngetElementsByClassName\n(\n\"re\"\n)[\n0\n];\n  \nvar\n lik=box.\ngetElementsByTagName\n(\n\"li\"\n);\n  \nfunction\n \nfun\n(\ni,j\n){\n//转换图片函数，就是把透明度改了一下\n\n    lik[i].\nstyle\n.\nopacity\n=\n1\n;\n    lik[j].\nstyle\n.\nopacity\n=\n0\n;\n \n   lik[i].\nstyle\n.\nzIndex\n=\n10\n;\n    lik[j].\nstyle\n.\nzIndex\n=\n0\n;\n \n    lik[i+\n5\n].\nstyle\n.\nbackgroundColor\n=\n\"#ffffff\"\n;\n//改一下小图标\n\n    lik[j+\n5\n].\nstyle\n.\nbackgroundColor\n=\n\"#00000000\"\n\n  }\n  \nfun\n(\n0\n,\n1\n);\n//初始化下\n\n  \nvar\n i =\n0\n;\n  \nfunction\n \nauto\n(\n){\n//轮播循环函数\n\n    \nif\n(++i>=\n5\n){\n      i=\n0\n;\n      \nfun\n(\n0\n,\n4\n);\n    }\n    \nelse\n \nfun\n(i,i-\n1\n);\n  }\n  timer=\nthis\n.\nsetInterval\n(auto,\n2000\n);\n  box.\nonmouseover\n = \nfunction\n (\n) { \n//鼠标划上去，停止轮播\n\n    \nconsole\n.\nlog\n(\n'good'\n);\n    \nclearInterval\n(timer);\n  }\n  box.\nonmouseout\n = \nfunction\n (\n) { \n//鼠标划出，继续轮播\n\n    timer = \nsetInterval\n(auto, \n2000\n); \n//调用定时器\n\n  }\n  \nvar\n j =\n0\n;\n  \nfor\n(;j<\n5\n;j++){\n//点击小图标也可以转换图片\n\n    lik[j+\n5\n].\nind\n=j;\n    lik[j+\n5\n].\nonclick\n=\nfunction\n(\n){\n      \nfun\n(\nthis\n.\nind\n,i)\n      i=\nthis\n.\nind\n;\n    }\n  }\n\n}\n\n\n\n\n<\nstyle\n>\n\n\n#max\n{\n  \nwidth\n: \n900px\n;\n  \nheight\n: \n500px\n;\n  \nalign-items\n: center;\n  \nmargin\n: \n5%\n auto;\n  \nmargin-top\n: \n0%\n;\n  \nposition\n: absolute;\n  \nleft\n: \n190px\n;\n  \ntop\n: \n130px\n;\n}\n\n.re\n{\n  \nposition\n: relative;\n  \nheight\n: \n400px\n;\n}\n\n.re\n \nul\n{\n  \nlist-style-type\n:none ;\n}\n\n.re\n \nul\n>\nli\n{\n  \nwidth\n: \n600px\n;\n  \nheight\n: \n300px\n;\n  \nposition\n: absolute;\n  \nleft\n: \n100px\n;\n  \ntop\n: \n30px\n;\n  \ntransition\n: \n1s\n;\n  \nopacity\n: \n0\n;\n}\n\n.re\n \nul\n>\nli\n \nimg\n{\n  \nwidth\n: \n700px\n;\n  \nheight\n: \n370px\n;\n  \nborder-radius\n: \n10%\n;\n  \nborder\n: \n15px\n solid \n#fffbd6\n;\n}\n\n#max\n \nol\n {\n  \nposition\n: relative;\n  \ndisplay\n: grid;\n  grid-template-\ncolumns\n: \nrepeat\n(\n5\n,\n75px\n);\n  grid-template-rows: auto;\n  grid-gap: \n1em\n;\n  \nfloat\n: right;\n  \nmargin-top\n: \n450px\n;\n  \nlist-style\n: none;\n  \ntop\n:\n0\n;\nleft\n:-\n150px\n;\n}\n\n#max\n \nol\n \nli\n {\n  \nwidth\n: \n25px\n;\n  \nheight\n: \n10px\n;\n  \nfont-size\n: \n15px\n;\n  \nline-height\n: \n20px\n;\n  \nfloat\n: left;\n  \ntext-align\n: center;\n  \nborder-radius\n: \n2em\n;\n  \nborder\n: \n5px\n solid \n#999999\n;\n}\n\n\n\n\n<\nbody\n>\n\n\n<\ndiv\n \nid\n=\n\"max\"\n>\n\n        \n<\ndiv\n \nclass\n=\n\"re\"\n>\n\n            \n<\nul\n>\n\n                \n<\nli\n>\n<\na\n \nhref\n=\n\"Fibonacci数列.html\"\n>\n<\nimg\n \nsrc\n=\n\"../images/我的数学笔记002.png\"\n \nalt\n=\n\"\"\n \ntitle\n=\n\"Fibonacci数列\"\n \nclass\n=\n\"imgd\"\n>\n\n\n\n                \n<\nli\n>\n<\na\n \nhref\n=\n\"Euler常数.html\"\n>\n<\nimg\n \nsrc\n=\n\"../images/我的数学笔记015.png\"\n \nalt\n=\n\"\"\n \ntitle\n=\n\"Euler常数\"\n \nclass\n=\n\"imgd\"\n>\n\n\n\n                \n<\nli\n>\n<\na\n \nhref\n=\n\"Wallis公式.html\"\n>\n<\nimg\n \nsrc\n=\n\"../images/我的数学笔记037.png\"\n \nalt\n=\n\"\"\n \ntitle\n=\n\"Wallis公式\"\n \nclass\n=\n\"imgd\"\n>\n\n>\n\n\n                \n<\nli\n>\n<\na\n \nhref\n=\n\"Newton-Leibniz公式.html\"\n>\n<\nimg\n \nsrc\n=\n\"../images/我的数学笔记061.png\"\n \nalt\n=\n\"\"\n \ntitle\n=\n\"Newton-Leibniz公式\"\n \nclass\n=\n\"imgd\"\n>\n\n>\n\n\n                \n<\nli\n>\n<\na\n \nhref\n=\n\"Ceva定理.html\"\n>\n<\nimg\n \nsrc\n=\n\"../images/我的数学笔记154.png\"\n \nalt\n=\n\"\"\n \ntitle\n=\n\"Ceva定理\"\n \nclass\n=\n\"imgd\"\n>\n\n\n\n\n            \n<\nol\n>\n\n                \n<\nli\n>\n\n\n                \n<\nli\n>\n\n\n                \n<\nli\n>\n\n\n                \n<\nli\n>\n\n\n                \n<\nli\n>\n\n\n\n\n\n\n\n\n\n这是效果图。", "Tag": "算法分析"}
{"Answer": "调整一下显示层级\n\nfunction fun(i,j){//转换图片函数，就是把透明度改了一下\n    lik[i].style.opacity=1;\n    lik[j].style.opacity=0;\n\n   lik[i].style.zIndex=10;\n    lik[j].style.zIndex=0;\n\n    lik[i+5].style.backgroundColor=\"#ffffff\";//改一下小图标\n    lik[j+5].style.backgroundColor=\"#00000000\"\n  }\n", "Konwledge_Point": "Fibonacci数列", "Question": "轮播图片为什么每张都链接到同一个网页？\n如题。\n\n\n代码如下。代码是\n@学习是人类进化的阶梯 \n的，我在粘贴代码的过程中遇到了这个问题。\n\n\n\n\n<\nscript\n>\n\n\nwindow\n.\nonload\n = \nfunction\n(\n){\n  \nvar\n box=\nthis\n.\ndocument\n.\ngetElementsByClassName\n(\n\"re\"\n)[\n0\n];\n  \nvar\n lik=box.\ngetElementsByTagName\n(\n\"li\"\n);\n  \nfunction\n \nfun\n(\ni,j\n){\n//转换图片函数，就是把透明度改了一下\n\n    lik[i].\nstyle\n.\nopacity\n=\n1\n;\n    lik[j].\nstyle\n.\nopacity\n=\n0\n;\n    lik[i+\n5\n].\nstyle\n.\nbackgroundColor\n=\n\"#ffffff\"\n;\n//改一下小图标\n\n    lik[j+\n5\n].\nstyle\n.\nbackgroundColor\n=\n\"#00000000\"\n\n  }\n  \nfun\n(\n0\n,\n1\n);\n//初始化下\n\n  \nvar\n i =\n0\n;\n  \nfunction\n \nauto\n(\n){\n//轮播循环函数\n\n    \nif\n(++i>=\n5\n){\n      i=\n0\n;\n      \nfun\n(\n0\n,\n4\n);\n    }\n    \nelse\n \nfun\n(i,i-\n1\n);\n  }\n  timer=\nthis\n.\nsetInterval\n(auto,\n2000\n);\n  box.\nonmouseover\n = \nfunction\n (\n) { \n//鼠标划上去，停止轮播\n\n    \nconsole\n.\nlog\n(\n'good'\n);\n    \nclearInterval\n(timer);\n  }\n  box.\nonmouseout\n = \nfunction\n (\n) { \n//鼠标划出，继续轮播\n\n    timer = \nsetInterval\n(auto, \n2000\n); \n//调用定时器\n\n  }\n  \nvar\n j =\n0\n;\n  \nfor\n(;j<\n5\n;j++){\n//点击小图标也可以转换图片\n\n    lik[j+\n5\n].\nind\n=j;\n    lik[j+\n5\n].\nonclick\n=\nfunction\n(\n){\n      \nfun\n(\nthis\n.\nind\n,i)\n      i=\nthis\n.\nind\n;\n    }\n  }\n\n}\n\n\n\n<\nstyle\n>\n\n\n#max\n{\n  \nwidth\n: \n900px\n;\n  \nheight\n: \n500px\n;\n  \nalign-items\n: center;\n  \nmargin\n: \n5%\n auto;\n  \nmargin-top\n: \n0%\n;\n  \nposition\n: absolute;\n  \nleft\n: \n190px\n;\n  \ntop\n: \n130px\n;\n}\n\n.re\n{\n  \nposition\n: relative;\n  \nheight\n: \n400px\n;\n}\n\n.re\n \nul\n{\n  \nlist-style-type\n:none ;\n}\n\n.re\n \nul\n>\nli\n{\n  \nwidth\n: \n600px\n;\n  \nheight\n: \n300px\n;\n  \nposition\n: absolute;\n\n  \ntransition\n: \n1s\n;\n  \nopacity\n: \n0\n;\n}\n\n.re\n \nul\n>\nli\n \nimg\n{\n  \nwidth\n: \n900px\n;\n  \nheight\n: \n500px\n;\n  \nborder-radius\n: \n10%\n;\n  \nborder\n: \n15px\n solid \n#fffbd6\n;\n}\n\n#max\n \nol\n {\n  \nposition\n: relative;\n  \ndisplay\n: grid;\n  grid-template-\ncolumns\n: \nrepeat\n(\n5\n,\n75px\n);\n  grid-template-rows: auto;\n  grid-gap: \n1em\n;\n  \nfloat\n: right;\n  \nmargin-top\n: \n450px\n;\n  \nlist-style\n: none;\n  \ntop\n:\n0\n;\nleft\n:\n0\n;\n}\n\n#max\n \nol\n \nli\n {\n  \nwidth\n: \n25px\n;\n  \nheight\n: \n10px\n;\n  \nfont-size\n: \n15px\n;\n  \nline-height\n: \n20px\n;\n  \nfloat\n: left;\n  \ntext-align\n: center;\n  \nborder-radius\n: \n2em\n;\n  \nborder\n: \n5px\n solid \n#999999\n;\n}\n\n\n\n\n<\nbody\n>\n\n\n<\ndiv\n \nid\n=\n\"max\"\n>\n\n        \n<\ndiv\n \nclass\n=\n\"re\"\n>\n\n            \n<\nul\n>\n\n                \n<\nli\n>\n<\na\n \nhref\n=\n\"Fibonacci数列.html\"\n>\n<\nimg\n \nsrc\n=\n\"file:///C|Users/Lenovo/Desktop/数学/图片/我的数学笔记002.png\"\n \nalt\n=\n\"\"\n \ntitle\n=\n\"Fibonacci数列\"\n>\n\n\n\n                \n<\nli\n>\n<\na\n \nhref\n=\n\"Euler常数.html\"\n>\n<\nimg\n \nsrc\n=\n\"file:///C|Users/Lenovo/Desktop/数学/图片/我的数学笔记015.png\"\n \nalt\n=\n\"\"\n \ntitle\n=\n\"Euler常数\"\n>\n\n\n\n                \n<\nli\n>\n<\na\n \nhref\n=\n\"Wallis公式.html\"\n>\n<\nimg\n \nsrc\n=\n\"file:///C|Users/Lenovo/Desktop/数学/图片/我的数学笔记037.png\"\n \nalt\n=\n\"\"\n \ntitle\n=\n\"Wallis公式\"\n\n>\n\n\n                \n<\nli\n>\n<\na\n \nhref\n=\n\"Newton-Leibniz公式.html\"\n>\n<\nimg\n \nsrc\n=\n\"file:///C|Users/Lenovo/Desktop/数学/图片/我的数学笔记061.png\"\n \nalt\n=\n\"\"\n \ntitle\n=\n\"Newton-Leibniz公式\"\n\n>\n\n\n                \n<\nli\n>\n<\na\n \nhref\n=\n\"Ceva定理.html\"\n>\n<\nimg\n \nsrc\n=\n\"file:///C|Users/Lenovo/Desktop/数学/图片/我的数学笔记154.png\"\n \nalt\n=\n\"\"\n \ntitle\n=\n\"Ceva定理\"\n>\n\n\n\n\n            \n<\nol\n>\n\n                \n<\nli\n>\n\n\n                \n<\nli\n>\n\n\n                \n<\nli\n>\n\n\n                \n<\nli\n>\n\n\n                \n<\nli\n>\n\n\n\n\n\n\n\n\n\n运行结果如下\n\n\n\n\n我实在不会了。麻烦大家帮帮我。谢谢。\n\n\n我希望让图片轮播到那一张就链接到哪一个相应的网页。", "Tag": "算法分析"}
{"Answer": "斐波那契数列吗？有什么理解不了的拿出来讲讲\r\n至于为什么不直接用公式，因为现在是考你程序知识，而不是数学知识", "Konwledge_Point": "Fibonacci数列", "Question": "c语言100道题中，兔子生兔子程序怎么理解\n这个程序完全理解不了，这100道题有很多关于数列的，为什么不是求数列公式直接输出啊，是要我练习什么吗", "Tag": "算法分析"}
{"Answer": "\nint FibonacciX(int x)\n{\n    if(x == 1 || x==2)\n    {\n        return 1;\n    }\n    else\n    {\n        return FibonacciX(x-1) + FibonacciX(x-2);\n    }\n}\n\nint main()\n{\n    int sum=0,n;\n    for(int i=1;i<20;i++)\n    {\n        n = FibonacciX(i);\n        sum += n;\n        printf(\"%d,\",n);\n    }\n    printf(\"\\nSum =%d\",sum);\n}\n", "Konwledge_Point": "Fibonacci数列", "Question": "利用c++循环与嵌套\nc++编程实现：求斐波那契（Fibonacci）数列，1，1，2，3，5，8，… …的前20项及前20项和。", "Tag": "算法分析"}
{"Answer": "# 获取用户输入数据\nnmber=input()\n# 第一和第二项\nn1 = 0\nn2 = 1\n\n\nprint(n2)\nwhile True:\n        nth = n1 + n2\n        if nth<=int(nmber):\n            print(nth)\n        else:\n            break\n        # 更新值\n        n1 = n2\n        n2 = nth\n\n\n有帮助请采纳,有问题继续交流,你的采纳是对我回答的最大的肯定和动力\n", "Konwledge_Point": "Fibonacci数列", "Question": "将斐波那契额序列输出？\n写一个程序输出菲波那切数列直到最大的数字。\n输出格式：\n1\n1\n2\n3\n5\n8\n13\n21\n34\n55\n89\n144\n233\n377\n610\n987", "Tag": "算法分析"}
{"Answer": "#include <stdio.h>\nint main()\n{\n    int a[30],i;\n    a[0] =1;\n    a[1]=1;\n    for (i=2;i<30;i++)\n    {\n        a[i] = a[i-1]+a[i-2];\n    }\n    for (i=0;i<30;i++)\n    {\n        printf(\"%d \",a[i]);\n        if(i!=0 && i%5==0)\n            printf(\"\\n\");\n    }\n    return 0;\n}\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "C语言定义数组和数组元素赋值\n1、定义一个大小为30的整型一维数组x，并将该数组的前2个元素初始化为1，使用循环语句将Fibonacci(斐波那契)数列的前30项依次赋给x[0]、x[1]、x[2]……。(Fibonacci数列为：数列的第1项、第2项均为1，从第3项开始，后一项是前两项之和。对应数组，则：　x[0]=1，x[1]=1，x[2]=x[0]+x[1]，　x[3]=x[1]+x[2]，依此类推。\n2、输出数组x(指数组x的元素)，要求每行只输出5个元素，相邻两个数之间至少有一个空格。\n按以上要求编写程序。", "Tag": "算法分析"}
{"Answer": "你不能最后输出才求余啊，那已经完了。在k = m+j之后，就需要对k进行求余了", "Konwledge_Point": "Fibonacci数列", "Question": "请大家看看这怎么错了？\n输入n，求斐波那契（Fibonacci）数列的第n项\n (n>2)\n\n\n由于结果可能会非常大，请输出结果对1000000007取模后的值。\n#include \nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    int m=1,j=1,i,k=1;\n    for(i=3;i<=n;i++){\n        k=m+j;\n        m=j;\n        j=k;\n\n\n}\n\nprintf\n(\n\"%d\"\n,k%1000000007);\n\nreturn\n \n0\n;\n\n\n\n}", "Tag": "算法分析"}
{"Answer": "OK了", "Konwledge_Point": "Fibonacci数列", "Question": "有一题我不会写，各位帮帮忙\n破解密码 【问题描述】 一个侦探来到罪犯的据点，发现了一个密码锁。密码锁旁写着几行字：此锁的密码会不断变化，每次要输入时，密码锁会随机给出六个数s,t,a,b,c,d（1<=s<=t<=500,1<=a,b,c,d<=10000)。在第s个斐波那契数到第t个斐波那契数之间（包括第s个和第t个）所有不能被a，b，c，d任一数整除的斐波那契数所组成的数列就是密码。 斐波那契数(Fibonacci数)是组合数学中非常重要的一个数列，它的递推公式是： F(1)=0，F(2)=1 F(n)=F(n-1)+F(n-2) 请你编一个程序，读入s,t,a,b,c,d六个数，然后求出密码锁的密码。  【输入格式】 第一行有s，t（1<=s<=t<=500)两个数； 第二行有a,b,c,d(1<=a,b,c,d<=10000)四个数。  【输出格式】 依次输出组成密码的每个斐波那契数（相邻的数用空格隔开）。  【样例输入】 1 5 2 3 5 7  【样例输出】 1 1  注：有两个斐波拉契数1、1，中间是用空格隔开。  【注释】 对于30%的数据，每个斐波那契数小于215-1。 对于50%的数据，每个斐波那契数小于263-1。 对于100%的数据，每个斐波那契数小于10200-1。 ", "Tag": "算法分析"}
{"Answer": "你写的form  不是from ？", "Konwledge_Point": "Fibonacci数列", "Question": "无法导入head.py\n我的使用的vsCode中无法导入我自定义的模块head.py，如图 \n\n\n虽然不能使用form [模块名] import*但是可以使用import\n如图：\n\n\n另外，我的Python版本为Python3.11.0\nhead.py代码：\n\n\n## head.py\n\n\n## Pyhton 3 语法代码文件\n\n\n## 版权所有 Copyright ©\n\n\n## Copyright © 2022 高宇涵.330205201010157010 All Rights Reserved.\n\n\nimport\n sys\n\nimport\n os\n\nimport\n time\n\nimport\n math\n\nimport\n cmath\n\nimport\n ctypes\n\nimport\n copy\n\nimport\n cmd\n\nimport\n string\n\nimport\n abc\n\nimport\n random\n\nimport\n collections\n\nfrom\n collections \nimport\n Counter,OrderedDict \nas\n Ordir\n\nimport\n json\n\nimport\n csv\n\nimport\n datetime\n\nimport\n threading\n\nimport\n enum\n\nfrom\n enum \nimport\n Enum,IntEnum\n\nimport\n const\n\ntry\n:\n    \nimport\n urllib2\n\nexcept\n ImportError:\n    \nimport\n urllib\n\n\ntry\n:\n    \nimport\n pygame\n\nexcept\n ImportError:\n    \npass\n\n\n\ntry\n:\n    \nimport\n pygal\n\nexcept\n ImportError:\n    \npass\n\n\n\ntry\n:\n    \nimport\n matplotlib\n\nexcept\n ImportError:\n    \npass\n\n\n\ntry\n:\n    \nimport\n requests\n\nexcept\n ImportError:\n    \npass\n\n\n\n\ndef\n \nprintf\n(\n*strings, sep:\nstr\n=\n''\n,end:\nstr\n=\n''\n):\n    \n\"\"\"\n    默认末尾没有换行符的输出\n    \"\"\"\n\n    sept = sep\n    cstr:\nstr\n = \n''\n\n    \nfor\n \nstr\n \nin\n strings:\n        cstr += \nstr\n\n    cstr += end\n    \nprint\n(cstr,sep=sept, end=\n''\n)\n    \nreturn\n \n0\n\n\n\ndef\n \nfac\n(\nnumber:\nint\n):\n    \n\"\"\"\n    返回斐波那契（Fibonacci）数列中的第{number}员\n    \"\"\"\n\n    \nif\n number == \n1\n:\n        \nreturn\n \n1\n\n    \nif\n number == \n2\n:\n        \nreturn\n \n1\n\n    \nif\n number <= \n0\n:\n        \nreturn\n \nNone\n\n    \nelse\n:\n        \n# number -= 1\n\n        \nreturn\n fac(number-\n2\n) + fac(number-\n1\n)\n\n\ndef\n \nType_int\n(\nnum:\nany\n):\n    \n\"\"\"int()的升级版\"\"\"\n\n    \ntry\n:\n        \nreturn\n \nint\n(num)\n    \nexcept\n ValueError:\n        \nreturn\n \nint\n(\nfloat\n(num))\n\n\ndef\n \nType_float\n(\nn:\nany\n):\n    \n\"\"\"给float()取别名\"\"\"\n\n    \nreturn\n \nfloat\n(n)\n\n\ndef\n \nType_bool\n(\nn:\nany\n):\n    \n\"\"\"给bool()取别名\"\"\"\n\n    \nreturn\n \nbool\n(n)\n\n\ndef\n \nInput\n(\nstr\n:\nstr\n):\n    \n\"\"\"\n    兼容Python2与Python3的input()版本\n    \"\"\"\n\n    l:\nstr\n\n    \ntry\n:\n        l = raw_input(\nstr\n)\n    \nexcept\n NameError:\n        l = \ninput\n(\nstr\n)\n    \nreturn\n l\n\n\ndef\n \ncolorRGB\n(\ncolor_text=\n''\n):\n    \n\"\"\"\n    返回RGB颜色\n    \"\"\"\n\n    \nif\n color_text.lower() == \n'white'\n:\n        \nreturn\n (\n0\n,\n0\n,\n0\n)\n    \nif\n color_text.lower() == \n'black'\n:\n        \nreturn\n (\n255\n,\n255\n,\n255\n)\n    \nif\n color_text.lower() == \n'yellow'\n:\n        \nreturn\n (\n255\n,\n255\n,\n0\n)\n    \nif\n color_text.lower() == \n'blue'\n:\n        \nreturn\n (\n0\n,\n0\n,\n255\n)\n    \nif\n color_text.lower() == \n'green'\n:\n        \nreturn\n (\n0\n,\n255\n,\n0\n)\n    \nif\n color_text.lower() == \n'orange'\n:\n        \nreturn\n (\n255\n,\n128\n,\n0\n)\n    \nif\n color_text.lower() == \n'purple'\n:\n        \nreturn\n (\n255\n,\n0\n,\n255\n)\n    \nif\n color_text.lower() == \n'orange red'\n:\n        \nreturn\n (\n255\n,\n69\n,\n0\n)\n    \nif\n color_text.lower() == \n'orange yellow'\n:\n        \nreturn\n (\n254\n,\n183\n,\n42\n)\n    \nif\n color_text.lower() == \n'yellow green'\n:\n        \nreturn\n (\n128\n,\n255\n,\n0\n)\n    \nif\n color_text.lower() == \n'green blue'\n:\n        \nreturn\n (\n17\n,\n100\n,\n180\n)\n    \nif\n color_text.lower() == \n'blue purple'\n:\n        \nreturn\n (\n50\n,\n74\n,\n178\n)\n    \nif\n color_text.lower() == \n'red purple'\n:\n        \nreturn\n (\n9\n,\n164\n,\n174\n)\n    \nelse\n:\n       \nreturn\n (\nNone\n,\nNone\n,\nNone\n)\n\n\n\nconst.py源代码：\n\n\n\n\nimport\n sys\n\nfrom\n threading \nimport\n RLock\n\n\nsingle_lock = RLock()\n\n\n\ndef\n \nSingleton\n(\ncls\n):\n    instance = {}\n\n    \ndef\n \n_singleton_wrapper\n(\n*args, **kargs\n):\n        \nwith\n single_lock:\n            \nif\n cls \nnot\n \nin\n instance:\n                instance[cls] = cls(*args, **kargs)\n        \nreturn\n instance[cls]\n\n    \nreturn\n _singleton_wrapper\n\n\n@Singleton\n\n\nclass\n \nConst\n:\n    \n# 自定义异常处理\n\n    \nclass\n \nConstValueError\n(\nPermissionError\n):\n        \npass\n\n    \nclass\n \nConstCaseError\n(\nPermissionError\n):\n        \npass\n\n\n    \ndef\n \n__setattr__\n(\nself, name, value\n):\n        \nif\n name \nin\n self.__dict__:\n            \nraise\n self.ConstValueError(\n\"不能修改常量 {0} 的值 \"\n.\nformat\n(name))\n\n        \nif\n \nnot\n name.isupper():\n            \nraise\n self.ConstCaseError(\n\"常量名称 {0} 必须大写\"\n.\nformat\n(name))\n\n        self.__dict__[name] = value\n\n\nsys.modules[__name__] = Const()\n\n\n\n各位广大网友，请求回答，谢谢！", "Tag": "算法分析"}
{"Answer": "不知道你这个问题是否已经解决, 如果还没有解决的话: 你可以参考下这个问题的回答, 看看是否对你有帮助, 链接: https://ask.csdn.net/questions/7563685如果你已经解决了该问题, 非常希望你能够分享一下解决方案, 写成博客, 将相关链接放在评论区, 以帮助更多的人 ^-^", "Konwledge_Point": "Fibonacci数列", "Question": "怎么减少运行时间且能正确运行\n\n\n斐波那契数列递归调用计算次数\n\n\n斐波那契数列用递归方式计算f(n)=f(n-1)+f(n-2)，重复子问题会进行大量的重复计算，给定n和m，求计算f(n)时计算f(m)的次数。f(0)和f(1)已知，不需递归。\n\n\n输入格式：\n\n\n每一行两个整数n和m（0<=n-m<=40，m>2），两个数之间有一个空格\n\n\n直至“0 0”，这一行不用计算\n\n\n输出格式：\n\n\n一行对应一个结果\n\n\n输入样例：\n\n\n5 3\n\n\n6 3\n\n\n0 0\n\n\n输出样例：\n\n\n2\n\n\n3\n\n\n图1在平台上提交时间长了，图二是我想着减少运行时间，但是却直接没有输出了，想问题在哪里", "Tag": "算法分析"}
{"Answer": "参考一下\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    int n;\n    cout << \"请输入项数 n：\";\n    cin >> n;\n\n    int a = 2, b = 4; // 类斐波那契数列的前两项为2和4\n    double sum = 0;\n    for (int i = 1; i <= n; i++) {\n        double numerator = i * 2 - 1; // 分子为奇数项\n        double denominator = b; // 分母为类斐波那契数列的当前项\n        sum += numerator / denominator; // 累加当前项的值\n        int c = a + b; // 计算类斐波那契数列的下一项\n        a = b;\n        b = c;\n    }\n\n    cout << \"前 \" << n << \" 项的和为：\" << sum << endl;\n\n    return 0;\n}\n\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "递推求合  鸡丁咯爹咪！！\n计算数列二分之一，四分之三，六分之五，十分之七，的前n项和，分母为类斐波那契数列，前两项为2和4", "Tag": "算法分析"}
{"Answer": "供参考：\n#include <stdio.h>\nint main()\n{\n    int i, n;\n    int list[31] = { 0 };\n    list[0] = 0;\n    list[1] = 1;\n    scanf(\"%d\", &n);\n    if (n < 1 || n >30)\n        printf(\"input error!\");\n    else {\n        for (i = 2; i <= n; i++)\n            list[i] = list[i - 1] + list[i - 2];\n        for (i = 1; i <= n; i++) {\n            printf(\"%-8d\", list[i]);\n            if (!(i % 5) && i != n)\n                printf(\"\\n\");\n        }\n    }\n    return 0;\n}\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "c语言编程中遇到的疑惑\n请问怎样定义数组才能使其不错误？\n\n\n对应以下实例\n首先，提示用户：“您想计算斐波那契数列的项数（1~30）：”，并将用户输入的数值存放到变量n中。\n然后，判断用户输入数据是否正确，如果不正确则输出错误信息并终止程序运行。\n接着，计算斐波那契数列的前n项，并存放到数组list中。\n最后，输出计算结果，每个结果输出域宽为8，左对齐，每行最多输出5个结果(不能出现首行为空的情况)。\n\n\n我找不到对应的确定值定义数组，请问该怎样处理？", "Tag": "算法分析"}
{"Answer": "c=aa=bb=c这三句表示，a和b交换数值，c就是一个临时变量\n第1次循环： a = a+b = 2, 交换值后 a=1,b=2 输出c=2第2次循环： a = a+b = 3, 交换值后 a=2,b=3 输出c=3第3次循环： a = a+b = 5, 交换值后 a=3,b=5 输出c=5第4次循环： a = a+b = 8, 交换值后 a=5,b=8 输出c=8....\n另外在python中不用临时变量，只要 a,b = b,a 就可以交换了所以这些代码可以简化成：\na,b = 1,1\nfor i in range(20):\n    print(b)\n    a,b=a+b,a\n", "Konwledge_Point": "Fibonacci数列", "Question": "Python斐波那契数列不引用函数怎么搞\n\n\n求大佬解释一下这串代码什么意思（ﾟдﾟlll）", "Tag": "算法分析"}
{"Answer": "需要分数结果吗？\nfrom fractions import Fraction\n\nn=int(input())\ni=a=1\nb=2\ns=Fraction(b,a)\nwhile i<n:\n    a,b=b,a+b\n    s+=Fraction(b,a)\n    i+=1\nprint(0) if n<=0 else print(s)\n", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列多项式求和\n问题遇到的现象和发生背景\n\n\n有一个分数序列： 2/1   3/2    5/3    8/5   13/8    21/13等等。求出这个数列的前 n 项之 和， n 由键盘输入 。\n\n\n问题相关代码，请勿粘贴截图\n\n\n运行结果及报错内容\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果", "Tag": "算法分析"}
{"Answer": "为什么是1+1？还有return 需要先计算return后面的值啊？所以说会先计算出n-1和n-2的斐波那契数列并加起来再返回", "Konwledge_Point": "Fibonacci数列", "Question": "求解java斐波那契数列原理\npublic static long fibonacci(long number==5) {\n if ((number == 0) || (number == 1))\n return number;\n else\n return fibonacci(number - 1) + fibonacci(number - 2);\n}\n当递归完后是返回1+1吗 而且都已经return了 函数不应该结束吗", "Tag": "算法分析"}
{"Answer": "\nChange your function to return res to this:\n return func () int {\n\n    res := y\n    y = z\n    z = res + z\n\n    return res\n\n}\n\nThis way you output the initial values first, and calculate the next values. Your current solution overwrites the initial values before they are returned.\n", "Konwledge_Point": "Fibonacci数列", "Question": "我应该在代码中进行哪些更改以生成从0 1 1开始的斐波那契数列\n\n\n\nI've searched older questions, there are tons of them. However I couldn't find the answer to my case.\n\n\n\n\nfunc fibonacci() func() int {\n    y := 0\n    z := 1\n\n    return func () int {\n\n        res := y + z\n        y = z\n        z = res\n\n        return res\n\n    }\n}\n\nfunc main() {\n    f := fibonacci()\n    for i := 0; i < 10; i++ {\n        fmt.Println(f())\n    }\n}\n\n\n\n\nThis produces 1 2 3 5 8 \n\n\n\nWhat should I change (as little as possible) to get 0 1 1 2 3 5 8 ?\n\n\n\nActually I managed to solve that if initial \ny\n and \nz\n were like this:\n\n\n\n    y := -1\n    z := 1\n\n\n\n\nBut that's a fortunate hack, and I want a logical solution.\n\n    ", "Tag": "算法分析"}
{"Answer": "优化：if 循环一般是if……elif……else  ，不是if……if……if", "Konwledge_Point": "Fibonacci数列", "Question": "【提问】斐波那契数列\ndef \ntest\n(\nn\n):\n    x = []\n    \nfor\n i \nin\n \nrange\n(1, \nn\n + 1):\n        \nif\n i == 1:\n            \nreturn\n 1\n        \nif\n i == 2:\n            \nreturn\n 1\n        \nif\n i >= 3:\n            \nreturn\n \ntest\n(i - 1) + \ntest\n(i - 2)\n```css\n\n\n\n\n```        x.\nappend\n(\ntest\n(i))\n    \nif\n \nn\n == 1:\n        \nreturn\n 1\n    \nif\n \nn\n == 2:\n        \nreturn\n 1\n    \nif\n \nn\n >= 3:\n        \nreturn\n \ntest\n(\nn\n - 1) + \ntest\n(\nn\n - 2)\n\n\n\nprint\n(\ntest\n(5))\n\n\n\n\n执行test（5）结果是1\n（用i控制数列中的每项数字，将其放入f数组。n为第n项数字）希望最后，x数组存入前n项的数字，n现实第n项的数字。", "Tag": "算法分析"}
{"Answer": "你这个可以把第一项改成1，提高速度而且 n 是全局变量，在 gcd() 和 main() 中又定义了修改代码如下：\n#include<iostream>\nusing namespace std;\nint gcd(int n){\n    if(n==1)    return 1;\n    if(n==2)    return 1;\n    else    return gcd(n-1)+gcd(n-2);\n}\nint main(){\n    int n;\n    cin>>n;\n    cout<<gcd(n)<<endl;\n    return 0;\n}\n", "Konwledge_Point": "Fibonacci数列", "Question": "程序设计 -- 斐波那契数列\n观察数列规律，求这个数列的第 \nn\n个数。\n1\n、\n1\n、\n2\n、\n3\n、\n5\n、\n8\n、\n13\n、…\n输入格式\n一行，一个整数 \nn\n\n输出格式\n一行， 一个整数\n输入样例\n1\n\n\n5\n\n输出样例\n1\n\n\n5\n\n输入样例\n2\n\n\n12\n\n输出样例\n2\n\n\n144\n\n能改一改这下面吗\n\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\nint\n n;\n\nint\n \ngcd\n(\nint\n n)\n{\n    \nif\n(n==\n1\n)    \nreturn\n \n0\n;\n    \nif\n(n==\n2\n)    \nreturn\n \n1\n;\n    \nelse\n    \nreturn\n \ngcd\n(n\n-1\n)+\ngcd\n(n\n-2\n);\n}\n\nint\n \nmain\n()\n{\n    \nint\n n;\n    cin>>n;\n    cout<<\ngcd\n(n+\n1\n)<<endl;\n    \nreturn\n \n0\n;\n}\n\n", "Tag": "算法分析"}
{"Answer": "第15行输出数列这里，每个数之间最好有间隔。", "Konwledge_Point": "Fibonacci数列", "Question": "fibonacci数列这样写算不算正确写法（指数组由数组计算赋值）\n考研需要标准写法，问一下这样的写法符不符合规范\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n\nint\n \nmain\n()\n\n\n{\n\nint\n a[\n40\n],i;\na[\n0\n]=\n1\n;\na[\n1\n]=\n1\n;\n\nfor\n(i=\n2\n;i<\n40\n;i++)\n{\n    a[i]=a[i\n-1\n]+a[i\n-2\n];\n}\n\nfor\n(i=\n0\n;i<\n40\n;i++)\n{\n    \nprintf\n(\n\"%d\"\n,a[i]);\n}\n\nreturn\n \n0\n;\n}\n\n\n", "Tag": "算法分析"}
{"Answer": "一个问题是你这结果肯定不行，第60项int类型肯定不够用，也用double类型吧。如果超时，建议不要用递归，用迭代吧。递归消耗比较大", "Konwledge_Point": "Fibonacci数列", "Question": "C语言 函数斐波那契数列\nn=60的时候运行超时了，有什么优化的方法嘛\n#include \nint F(double n);\nint main()\n{\n    double n;\n    scanf(\"%lf\",&n);\n    printf(\"%d\",F(n));\n    return 0;\n}\nint F(double n)\n{\n    int result;\n    if(n==1) result = 1;\n    else if(n==2) result = 1;\n    else result = F(n-1)+F(n-2);\n    return result;\n }", "Tag": "算法分析"}
{"Answer": "这个可能你对scanf的理解有误。输入-1，只会使n的值等于-1，而scanf函数的返回值是1。因为scanf返回值表示接收到了几个数，而不是输入的是什麽值。因此你应该先scanf(\"%d\",&n)，然后判断n!=-1\n#include <iostream>\nusing namespace std;\nint main()\n{\n    int f[50],n;\n    f[0] = f[1] = 1;\n    cin>>n;   //既然是C++语言，还是用cin比较好\n    while(n!=-1)\n    {\n        for(int j=2;j<=n;j++)\n              f[j] = f[j-1]+ f[j-2];\n        cout<<f[n]<<endl;\n    }\n    return 0;\n}\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列求和1111\n当输入-1时 循环不应该结束了吗 为什么还会继续输出呢  哪里错了呀\n\n\n\n", "Tag": "算法分析"}
{"Answer": "因为你定义的Fibonacci()函数是返回空类型，你想表达的意思应该是通过这个函数来实现对num[]数组的计算。但是函数就相当于是一个盒子，在一个盒子里面的定义的变量就只有这个盒子可见，所以说main()函数里面的num[]数组和你在Fibonacci()函数中定义的num[]数组其实不是同一个数组，他们只不过是有相同的名字罢了。这里如果你想利用自己定义的函数解题的话可能会涉及到指针相关的知识，不知道同学有没有学习到指针。提前了解一下没有坏处，指针可是C语言的灵魂，有一句话叫做“没学指针，就是没学C语言”。建议自己翻翻书，或者搜搜相关的博客，当然我自己写的也有一篇关于指针的博客，欢迎观看哦  嘿嘿嘿下面是我在你的代码上进行的修改，不出意外的话应该就是你想表达的意思，自己慢慢琢磨，指针还是有一定难度的值得赞同的是思路没问题，剩下的就交给知识储备了，慢慢来快期末考试了   加油加油  一起进步  \n\n#include<stdio.h>\nvoid Fibonacci(int *num,int n);\nint main()\n{\n    int n,num[40],i;\n    num[0]=1;\n    num[1]=1;\n    scanf(\"%d\",&n);\n    Fibonacci(num,n);\n    for(i=0;i<n;i++)\n    {\n        if(i%4==0)\n            printf(\"\\n\");\n        printf(\"%4d\",num[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\nvoid Fibonacci(int *num,int n)\n{\n    int i;\n    for(i=2;i<n;i++)\n    {\n        num[i]=num[i-2]+num[i-1];\n    }\n}\n", "Konwledge_Point": "Fibonacci数列", "Question": "为什么运行不起来?斐波那契数列\n求菲波拉契数列的前N（小于40）项；在main函数中定义数组，用数组做函数参数。", "Tag": "算法分析"}
{"Answer": "非递归的话是不断更新两个斐波那契数来实现求n个斐波那契数，递归的话是不断的把一个斐波那契数表示成两个斐波那契数的和的形式，然后找到最低端的斐波那契数，然后不断的回溯。", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列的递归和非递归法两种表示方法能解释一下是为什么呢？\n非递归法\n\n    unsigned long long Fibonacci(unsigned long long n)\n\n    {\n\n    int n1, n2, temp, i;\n\n    if (n > 2)\n\n        for (n1 = 1, n2 = 1, i = 3; i <= n; i++)\n\n        {\n\n            temp = n1 + n2;\n\n            n1 = n2;\n\n            n2 = temp;\n\n        }\n\n    else n2 = 1;\n\n\n\nreturn n2;\n\n\n\n\n}\n\n递归法\n\n    unsigned long long Fibonacci(unsigned long long n)\n\n    {\n\n        if(n > 2)\n\n                return Fibonacci(n - 1) + Fibonacci(n - 2);\n\n            else\n\n                return 1;\n\n    }", "Tag": "算法分析"}
{"Answer": "函数最后你要加上return s;", "Konwledge_Point": "Fibonacci数列", "Question": "递归求斐波那契数列：,为何会造成这？为何呀\n问题遇到的现象和发生背景\n\n\n问题相关代码，请勿粘贴截图\n\n\n运行结果及报错内容\n\n\n我的解答思路和尝试过的方法\n\n\n###### 我想要达到的结果\n```c\n\n#\ninclude\n \n\n\n\nint\n \nf\n(\nint\n n)\n;\n\nint\n \nmain\n()\n\n\n{\n  \nint\n n;\n\nscanf\n(\n\"%d\"\n,&n);\n\nf\n(n);\n\nreturn\n \n0\n;\n}\n\nint\n \nf\n(\nint\n n)\n\n\n{\n  \nint\n s;\n  \nif\n(n==\n0\n)\n      s=\n0\n;\n  \nif\n(n==\n1\n)\n      s=\n1\n;\n   \nif\n(n>=\n2\n)\n        s=\nf\n(n\n-2\n)+\nf\n(n\n-1\n);\n\nprintf\n(\n\"%d  \"\n,s);\n}\n\n\n", "Tag": "算法分析"}
{"Answer": "解题思路：先写一个方法，判断是否是合数；然后再写一个方法，用于获取要求的值；最后在主方法中调用即可。所以我是由下至上的写的，如果有所帮助的话，希望博主采纳。运行结果：\n\npublic class Test01 {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        System.out.print(\"请输入一个整数：\");\n        int num = sc.nextInt();\n\n        int result = returnNUmber(num);\n        System.out.println(result);\n    }\n\n    //返回最后的结果值\n    public static int returnNUmber(int n) {\n        //设置合数个数变量\n        int k = 0;\n        int num1 = 1;\n        int num2 = 1;\n        int num3 = 0;\n        //设置循环\n        while (k != n) {\n            num3 = num1 + num2;\n            num1 = num2;\n            num2 = num3;\n            if (ifNumber(num3)==true){\n                k++;\n            }\n        }\n        return num3;\n    }\n\n    //判断该数是否是合数，合数：除1和它本身以外，还能被其他正整数整除\n    public static boolean ifNumber(int n) {\n        for (int i = 2; i < n - 1; i++) {\n            if (n % i == 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n", "Konwledge_Point": "Fibonacci数列", "Question": "java写斐波那契数列求合数\nimport java. util. * ;\npublic class Fibonacci{\n      public static void main(String args[ ]){\n            Scanner in=new Scanner(System.in);\n            int n=in.nextInt( );\n            int k1=1,k2=1,k3;\n            for(int i=3;i<n;i++){\n                  k3=k1+k2;\n                  k1=k2;\n                  k2=k3;0000\n                  int sqrt=(int)Math.sqrt(n);\n                  for(int j=2;i<=sqrt;i++)\n                  {\n                        if(k3 % i != 0)\n                  System.out.printf(\"%d\",k3);\n                  }\n}      }}\n\n", "Tag": "算法分析"}
{"Answer": "c=aa=bb=c这三句表示，a和b交换数值，c就是一个临时变量\n第1次循环： a = a+b = 2, 交换值后 a=1,b=2 输出c=2第2次循环： a = a+b = 3, 交换值后 a=2,b=3 输出c=3第3次循环： a = a+b = 5, 交换值后 a=3,b=5 输出c=5第4次循环： a = a+b = 8, 交换值后 a=5,b=8 输出c=8....\n另外在python中不用临时变量，只要 a,b = b,a 就可以交换了所以这些代码可以简化成：\na,b = 1,1\nfor i in range(20):\n    print(b)\n    a,b=a+b,a\n", "Konwledge_Point": "Fibonacci数列", "Question": "Python斐波那契数列不引用函数怎么搞\n\n\n求大佬解释一下这串代码什么意思（ﾟдﾟlll）", "Tag": "算法分析"}
{"Answer": "需要分数结果吗？\nfrom fractions import Fraction\n\nn=int(input())\ni=a=1\nb=2\ns=Fraction(b,a)\nwhile i<n:\n    a,b=b,a+b\n    s+=Fraction(b,a)\n    i+=1\nprint(0) if n<=0 else print(s)\n", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列多项式求和\n问题遇到的现象和发生背景\n\n\n有一个分数序列： 2/1   3/2    5/3    8/5   13/8    21/13等等。求出这个数列的前 n 项之 和， n 由键盘输入 。\n\n\n问题相关代码，请勿粘贴截图\n\n\n运行结果及报错内容\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果", "Tag": "算法分析"}
{"Answer": "为什么是1+1？还有return 需要先计算return后面的值啊？所以说会先计算出n-1和n-2的斐波那契数列并加起来再返回", "Konwledge_Point": "Fibonacci数列", "Question": "求解java斐波那契数列原理\npublic static long fibonacci(long number==5) {\n if ((number == 0) || (number == 1))\n return number;\n else\n return fibonacci(number - 1) + fibonacci(number - 2);\n}\n当递归完后是返回1+1吗 而且都已经return了 函数不应该结束吗", "Tag": "算法分析"}
{"Answer": "\nChange your function to return res to this:\n return func () int {\n\n    res := y\n    y = z\n    z = res + z\n\n    return res\n\n}\n\nThis way you output the initial values first, and calculate the next values. Your current solution overwrites the initial values before they are returned.\n", "Konwledge_Point": "Fibonacci数列", "Question": "我应该在代码中进行哪些更改以生成从0 1 1开始的斐波那契数列\n\n\n\nI've searched older questions, there are tons of them. However I couldn't find the answer to my case.\n\n\n\n\nfunc fibonacci() func() int {\n    y := 0\n    z := 1\n\n    return func () int {\n\n        res := y + z\n        y = z\n        z = res\n\n        return res\n\n    }\n}\n\nfunc main() {\n    f := fibonacci()\n    for i := 0; i < 10; i++ {\n        fmt.Println(f())\n    }\n}\n\n\n\n\nThis produces 1 2 3 5 8 \n\n\n\nWhat should I change (as little as possible) to get 0 1 1 2 3 5 8 ?\n\n\n\nActually I managed to solve that if initial \ny\n and \nz\n were like this:\n\n\n\n    y := -1\n    z := 1\n\n\n\n\nBut that's a fortunate hack, and I want a logical solution.\n\n    ", "Tag": "算法分析"}
{"Answer": "优化：if 循环一般是if……elif……else  ，不是if……if……if", "Konwledge_Point": "Fibonacci数列", "Question": "【提问】斐波那契数列\ndef \ntest\n(\nn\n):\n    x = []\n    \nfor\n i \nin\n \nrange\n(1, \nn\n + 1):\n        \nif\n i == 1:\n            \nreturn\n 1\n        \nif\n i == 2:\n            \nreturn\n 1\n        \nif\n i >= 3:\n            \nreturn\n \ntest\n(i - 1) + \ntest\n(i - 2)\n```css\n\n\n\n\n```        x.\nappend\n(\ntest\n(i))\n    \nif\n \nn\n == 1:\n        \nreturn\n 1\n    \nif\n \nn\n == 2:\n        \nreturn\n 1\n    \nif\n \nn\n >= 3:\n        \nreturn\n \ntest\n(\nn\n - 1) + \ntest\n(\nn\n - 2)\n\n\n\nprint\n(\ntest\n(5))\n\n\n\n\n执行test（5）结果是1\n（用i控制数列中的每项数字，将其放入f数组。n为第n项数字）希望最后，x数组存入前n项的数字，n现实第n项的数字。", "Tag": "算法分析"}
{"Answer": "你这个可以把第一项改成1，提高速度而且 n 是全局变量，在 gcd() 和 main() 中又定义了修改代码如下：\n#include<iostream>\nusing namespace std;\nint gcd(int n){\n    if(n==1)    return 1;\n    if(n==2)    return 1;\n    else    return gcd(n-1)+gcd(n-2);\n}\nint main(){\n    int n;\n    cin>>n;\n    cout<<gcd(n)<<endl;\n    return 0;\n}\n", "Konwledge_Point": "Fibonacci数列", "Question": "程序设计 -- 斐波那契数列\n观察数列规律，求这个数列的第 \nn\n个数。\n1\n、\n1\n、\n2\n、\n3\n、\n5\n、\n8\n、\n13\n、…\n输入格式\n一行，一个整数 \nn\n\n输出格式\n一行， 一个整数\n输入样例\n1\n\n\n5\n\n输出样例\n1\n\n\n5\n\n输入样例\n2\n\n\n12\n\n输出样例\n2\n\n\n144\n\n能改一改这下面吗\n\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\nint\n n;\n\nint\n \ngcd\n(\nint\n n)\n{\n    \nif\n(n==\n1\n)    \nreturn\n \n0\n;\n    \nif\n(n==\n2\n)    \nreturn\n \n1\n;\n    \nelse\n    \nreturn\n \ngcd\n(n\n-1\n)+\ngcd\n(n\n-2\n);\n}\n\nint\n \nmain\n()\n{\n    \nint\n n;\n    cin>>n;\n    cout<<\ngcd\n(n+\n1\n)<<endl;\n    \nreturn\n \n0\n;\n}\n\n", "Tag": "算法分析"}
{"Answer": "第15行输出数列这里，每个数之间最好有间隔。", "Konwledge_Point": "Fibonacci数列", "Question": "fibonacci数列这样写算不算正确写法（指数组由数组计算赋值）\n考研需要标准写法，问一下这样的写法符不符合规范\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n\nint\n \nmain\n()\n\n\n{\n\nint\n a[\n40\n],i;\na[\n0\n]=\n1\n;\na[\n1\n]=\n1\n;\n\nfor\n(i=\n2\n;i<\n40\n;i++)\n{\n    a[i]=a[i\n-1\n]+a[i\n-2\n];\n}\n\nfor\n(i=\n0\n;i<\n40\n;i++)\n{\n    \nprintf\n(\n\"%d\"\n,a[i]);\n}\n\nreturn\n \n0\n;\n}\n\n\n", "Tag": "算法分析"}
{"Answer": "一个问题是你这结果肯定不行，第60项int类型肯定不够用，也用double类型吧。如果超时，建议不要用递归，用迭代吧。递归消耗比较大", "Konwledge_Point": "Fibonacci数列", "Question": "C语言 函数斐波那契数列\nn=60的时候运行超时了，有什么优化的方法嘛\n#include \nint F(double n);\nint main()\n{\n    double n;\n    scanf(\"%lf\",&n);\n    printf(\"%d\",F(n));\n    return 0;\n}\nint F(double n)\n{\n    int result;\n    if(n==1) result = 1;\n    else if(n==2) result = 1;\n    else result = F(n-1)+F(n-2);\n    return result;\n }", "Tag": "算法分析"}
{"Answer": "这个可能你对scanf的理解有误。输入-1，只会使n的值等于-1，而scanf函数的返回值是1。因为scanf返回值表示接收到了几个数，而不是输入的是什麽值。因此你应该先scanf(\"%d\",&n)，然后判断n!=-1\n#include <iostream>\nusing namespace std;\nint main()\n{\n    int f[50],n;\n    f[0] = f[1] = 1;\n    cin>>n;   //既然是C++语言，还是用cin比较好\n    while(n!=-1)\n    {\n        for(int j=2;j<=n;j++)\n              f[j] = f[j-1]+ f[j-2];\n        cout<<f[n]<<endl;\n    }\n    return 0;\n}\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列求和1111\n当输入-1时 循环不应该结束了吗 为什么还会继续输出呢  哪里错了呀\n\n\n\n", "Tag": "算法分析"}
{"Answer": "因为你定义的Fibonacci()函数是返回空类型，你想表达的意思应该是通过这个函数来实现对num[]数组的计算。但是函数就相当于是一个盒子，在一个盒子里面的定义的变量就只有这个盒子可见，所以说main()函数里面的num[]数组和你在Fibonacci()函数中定义的num[]数组其实不是同一个数组，他们只不过是有相同的名字罢了。这里如果你想利用自己定义的函数解题的话可能会涉及到指针相关的知识，不知道同学有没有学习到指针。提前了解一下没有坏处，指针可是C语言的灵魂，有一句话叫做“没学指针，就是没学C语言”。建议自己翻翻书，或者搜搜相关的博客，当然我自己写的也有一篇关于指针的博客，欢迎观看哦  嘿嘿嘿下面是我在你的代码上进行的修改，不出意外的话应该就是你想表达的意思，自己慢慢琢磨，指针还是有一定难度的值得赞同的是思路没问题，剩下的就交给知识储备了，慢慢来快期末考试了   加油加油  一起进步  \n\n#include<stdio.h>\nvoid Fibonacci(int *num,int n);\nint main()\n{\n    int n,num[40],i;\n    num[0]=1;\n    num[1]=1;\n    scanf(\"%d\",&n);\n    Fibonacci(num,n);\n    for(i=0;i<n;i++)\n    {\n        if(i%4==0)\n            printf(\"\\n\");\n        printf(\"%4d\",num[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\nvoid Fibonacci(int *num,int n)\n{\n    int i;\n    for(i=2;i<n;i++)\n    {\n        num[i]=num[i-2]+num[i-1];\n    }\n}\n", "Konwledge_Point": "Fibonacci数列", "Question": "为什么运行不起来?斐波那契数列\n求菲波拉契数列的前N（小于40）项；在main函数中定义数组，用数组做函数参数。", "Tag": "算法分析"}
{"Answer": "非递归的话是不断更新两个斐波那契数来实现求n个斐波那契数，递归的话是不断的把一个斐波那契数表示成两个斐波那契数的和的形式，然后找到最低端的斐波那契数，然后不断的回溯。", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列的递归和非递归法两种表示方法能解释一下是为什么呢？\n非递归法\n\n    unsigned long long Fibonacci(unsigned long long n)\n\n    {\n\n    int n1, n2, temp, i;\n\n    if (n > 2)\n\n        for (n1 = 1, n2 = 1, i = 3; i <= n; i++)\n\n        {\n\n            temp = n1 + n2;\n\n            n1 = n2;\n\n            n2 = temp;\n\n        }\n\n    else n2 = 1;\n\n\n\nreturn n2;\n\n\n\n\n}\n\n递归法\n\n    unsigned long long Fibonacci(unsigned long long n)\n\n    {\n\n        if(n > 2)\n\n                return Fibonacci(n - 1) + Fibonacci(n - 2);\n\n            else\n\n                return 1;\n\n    }", "Tag": "算法分析"}
{"Answer": "函数最后你要加上return s;", "Konwledge_Point": "Fibonacci数列", "Question": "递归求斐波那契数列：,为何会造成这？为何呀\n问题遇到的现象和发生背景\n\n\n问题相关代码，请勿粘贴截图\n\n\n运行结果及报错内容\n\n\n我的解答思路和尝试过的方法\n\n\n###### 我想要达到的结果\n```c\n\n#\ninclude\n \n\n\n\nint\n \nf\n(\nint\n n)\n;\n\nint\n \nmain\n()\n\n\n{\n  \nint\n n;\n\nscanf\n(\n\"%d\"\n,&n);\n\nf\n(n);\n\nreturn\n \n0\n;\n}\n\nint\n \nf\n(\nint\n n)\n\n\n{\n  \nint\n s;\n  \nif\n(n==\n0\n)\n      s=\n0\n;\n  \nif\n(n==\n1\n)\n      s=\n1\n;\n   \nif\n(n>=\n2\n)\n        s=\nf\n(n\n-2\n)+\nf\n(n\n-1\n);\n\nprintf\n(\n\"%d  \"\n,s);\n}\n\n\n", "Tag": "算法分析"}
{"Answer": "解题思路：先写一个方法，判断是否是合数；然后再写一个方法，用于获取要求的值；最后在主方法中调用即可。所以我是由下至上的写的，如果有所帮助的话，希望博主采纳。运行结果：\n\npublic class Test01 {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        System.out.print(\"请输入一个整数：\");\n        int num = sc.nextInt();\n\n        int result = returnNUmber(num);\n        System.out.println(result);\n    }\n\n    //返回最后的结果值\n    public static int returnNUmber(int n) {\n        //设置合数个数变量\n        int k = 0;\n        int num1 = 1;\n        int num2 = 1;\n        int num3 = 0;\n        //设置循环\n        while (k != n) {\n            num3 = num1 + num2;\n            num1 = num2;\n            num2 = num3;\n            if (ifNumber(num3)==true){\n                k++;\n            }\n        }\n        return num3;\n    }\n\n    //判断该数是否是合数，合数：除1和它本身以外，还能被其他正整数整除\n    public static boolean ifNumber(int n) {\n        for (int i = 2; i < n - 1; i++) {\n            if (n % i == 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n", "Konwledge_Point": "Fibonacci数列", "Question": "java写斐波那契数列求合数\nimport java. util. * ;\npublic class Fibonacci{\n      public static void main(String args[ ]){\n            Scanner in=new Scanner(System.in);\n            int n=in.nextInt( );\n            int k1=1,k2=1,k3;\n            for(int i=3;i<n;i++){\n                  k3=k1+k2;\n                  k1=k2;\n                  k2=k3;0000\n                  int sqrt=(int)Math.sqrt(n);\n                  for(int j=2;i<=sqrt;i++)\n                  {\n                        if(k3 % i != 0)\n                  System.out.printf(\"%d\",k3);\n                  }\n}      }}\n\n", "Tag": "算法分析"}
{"Answer": "实际来说这可不止是两个scanf，因为还有一个scanf在循环里边，执行多少次取决于你第一次输入的值，第一次scanf是为了确定你后边输入的次数。后边循环的scanf 是为了接收你后边输入的值，比如第一次输入3，你后边就得输入三次\n", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列输入格式问题\n问题遇到的现象和发生背景\n\n\n\n\n有点读不懂题目和输入格式，为什么要用两个scanf。\n\n\n用代码块功能插入代码，请勿粘贴截图", "Tag": "算法分析"}
{"Answer": "\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    int a = 1, b = 1, n, k = 3, sum = 0, i = 1;\n    while (true)\n    {\n        cout << \"n = \";\n        cin >> n;\n\n        while (n >= 3 && k <= n) {\n            i = a + b;\n            a = b;\n            b = i;\n            k++;\n            //sum += i;\n        }\n        cout << \"num = \" << i << endl;\n    }\n    \n    return 0;\n}\n", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列求和，看着简单，就是写不对。\n题目描述\n给定一个数列 1  1  2  3  5  8  13  21求该数列的前n项之和。 \n\n\n输入\n一行，1个整数，表示要求和的总项数n (n>=1)。\n输出\n一行，包含1个整数，表示该数列的前n项之和。 \n\n\n样例输入 Copy\n4\n样例输出 Copy\n7\n\n\n写法如下，谁帮我看下哪里不对，谢谢啦。\n\n", "Tag": "算法分析"}
{"Answer": "\nI assume you are talking about improving the time complexity (and not the code complexity).\nYour solution computes the Fibonacci numbers in O(n) time. Interestingly, there exists an O(log n) solution as well. \nThe algorithm is simple enough: Find the nth power of matrix A using a Divide and Conquer approach and report (0,0)th element, where\n A = |1     1 |\n     |1     0 |\n\nThe recursion being \n A^n = A^(n/2) * A^(n/2)\n\nTime complexity:\nT(n) = T(n/2) + O(1) = O(logn)\n\nIf you think about it with a piece of paper, you'd find that the proof is simple and is based upon the principle of induction.\nIf you still need help, refer to this link\nNOTE: Of course, the O(logn) time is true only if you want to find the nth Fibonacci number. If, however, you intend to print ALL of the n fib numbers, theoretically, you can not have a better time complexity than you already have.\n", "Konwledge_Point": "Fibonacci数列", "Question": "转到斐波那契数列生成器\n\n\n\nThis is my fibonacci generator:\n\n\n\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    for i, j := 0, 1; j < 100; i, j = i+j,i {\n        fmt.Println(i)\n    }\n}\n\n\n\n\nIt's working, but I don't know how can I improve it, I'd like more expert approaches about it, Thanks...\n\n    ", "Tag": "算法分析"}
{"Answer": "加一句int n;printf(\"%d\",i);改成scanf(\"%d\",&n);最后一个for循环拿掉，最后return前加一句printf(\"%d\",a[n]);", "Konwledge_Point": "Fibonacci数列", "Question": "求斐波那契数列，求解!\n哪儿错了，求解答!谢谢\n\n\n这是题目\n\n", "Tag": "算法分析"}
{"Answer": "最后一行的意思是，把back2的值赋值给back1, 再把back1+back2的和赋值给back2。fib()函数是一个生成器函数，它的作用是，当每次调用next()方法，就可以返回这个函数计算出的当前项的斐波那契数列的值。测试代码如下：参考链接：\n\n\n\n\n\n         https://www.codenong.com/41615756/\n        \n\n\n\n\n\n\n         https://blog.csdn.net/weixin_44992737/article/details/125860953\n        \n\n\n\n\n\n\n         https://qb.zuoyebang.com/xfe-question/question/b1565033a69fae0837095a71193fcdee.html\n        \n\n\ndef fib():  # 生成器函数，用于返回当前项斐波那契数列的值\n    #  https://www.codenong.com/41615756/\n    back1, back2 = 0,1 # back1赋值第一个值0，back2赋值为第二个值1\n    while True:\n        \n        yield back1  # 返回back1的值，但是函数不会退出，等待下一次调用next()方法\n        #  下面的作用相当于，把back2的值赋值给back1, back1+back2的和赋值给back2\n        #  back1  back2  back1+back2\n        #     1     1      2\n        # print(\"before: back1=\",back1,\",back2=\",back2)\n        back1,back2 = back2,back1+back2\n        # print(\"after: back1=\",back1,\",back2=\",back2)\n        \n\nfibNum = fib()\nfor i in range(0,11):\n    \n    # https://blog.csdn.net/weixin_44992737/article/details/125860953\n    # https://qb.zuoyebang.com/xfe-question/question/b1565033a69fae0837095a71193fcdee.html\n    # 调用next()方法来获取一项斐波那契数列的值\n    print(\"斐波那契数列第\"+str(i)+\"项为：\"+str(next(fibNum)))\n\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "python生成器实现斐波那契数列\n\n\n以上是生成斐波那契数列的代码，问最后一行是什么意思\n并解释一下代码", "Tag": "算法分析"}
{"Answer": "range范围把40改成N+1，可以参考下面代码\nN = int(input())\nf = [0] * 40\nf[0], f[1] = 1, 1\nprint(f\"{f[0]}\\t{f[1]}\", end=\"\\t\")\nfor index in range(2, N + 1):\n    f[index] = f[index - 1] + f[index - 2]\n    print(f[index], end=\"\\t\")\n", "Konwledge_Point": "Fibonacci数列", "Question": "python循环输出斐波那契数列串\n麻烦大家帮我看看，请问要如何输出N个斐波那契数？要如何在f里面切出N个数？谢谢大家！不胜感激\n\n\n\n", "Tag": "算法分析"}
{"Answer": "第一个循环里面把a[0]和a[1]的值改变了，可以试试下面这样改：\n#include <stdio.h>\nint main () {\n    int a[20]={1,1},i,t;\n    for(i=2;i<=19;i++){\n        a[i]=a[i-1]+a[i-2];\n    }\n    for(i=0;i<20;i++){\n        if(i%5==0) printf(\"\\n\");\n        printf(\"%12d\", a[i]);\n    }\n    return 0;\n}  \n", "Konwledge_Point": "Fibonacci数列", "Question": "用数组元素输出斐波那契数列\n\n\n哪里写错了吗？为什么第一项和第二项不正确啊？程序和结果都附上了，帮忙看一下子。", "Tag": "算法分析"}
{"Answer": "有具体的，if(n==0||n==1) return 1这部分有具体实现了，然后f(2)=f(1)+f(0)=2f(3)=f(2)+f(1)=3以此类推", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列，采用递归时\n为啥最后return返回的是两个函数相加的结果呢，那个函数没有具体，可是那个函数没有具体运算呀！不应该返回的是(n-1)+(n-2)吗", "Tag": "算法分析"}
{"Answer": "\n#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int f1 = 1, f2 = 1, f3;\n    int i;\n\n    printf(\"%12d \\n%12d \\n\", f1, f2);\n\n    for (i = 3; i <= 38; i++) {\n        f3 = f1 + f2;\n        printf(\"%12d \\n\", f3);\n        f1 = f2;\n        f2 = f3;\n    }\n\n    return 0;\n}\n", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列不知道哪里有问题\n斐波那契数列不知道哪里有问题看了好多次的就是想不明白问题出在哪里", "Tag": "算法分析"}
{"Answer": "n是输入参数n，为啥结果也用n，这样可能会导致fac传参错误\nint fac(int n)\n{\n    if (n == 1 || n == 2)\n        n = 1;\n    else\n        n = fac(n - 1) + fac(n - 2);\n    return n;\n}\n修改为\nint fac(int n)\n{\n    if (n == 1 || n == 2)\n       return 1;\n    else\n        return fac(n - 1) + fac(n - 2);\n}\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "对斐波那契数列进行前n项和求解\n\n\n#\ninclude\n\n\n\nint\n \nfac\n(\nint\n n)\n\n\n{\n    \nif\n (n == \n1\n || n == \n2\n)\n        n = \n1\n;\n    \nelse\n\n        n = \nfac\n(n - \n1\n) + \nfac\n(n - \n2\n);\n    \nreturn\n n;\n}\n\nint\n \nmain\n()\n\n\n{\n    \nint\n n, i, c = \n0\n;\n    \nprintf\n(\n\"输入项数：\"\n);\n    \nscanf\n(\n\"%d\"\n, &n);\n    \nfor\n (i = n; i > \n1\n; i--)\n    {\n        c = c + \nfac\n(i) + \nfac\n(i - \n1\n);\n    }\n    \nprintf\n(\n\"和为%d\"\n, c/\n2\n+(\nfac\n(\n1\n)+\nfac\n(n))/\n2\n);\n}\n\n\n\n\n如上所示，我准备通过该代码实现对斐波那契数列进行前n项和求解\n首先，我通过递归函数实现对斐波那契数列的第n项求值，其后，通过一个for循环实现求取n项和。\n但根据分析，for函数输出的值应是前n项和的两倍（除去首项与尾项）\n如：输入4，即n，i被赋值为4，进入for循环，当i=4时，c=fac（4）+fac（3），随即i减一，i=3，将多加一次fac（3），以此类推，除去首项尾项，其它项都多加了一次。\n故最后输出时用c/2+（fac（1）+fac（n））/2来消去多加的中间项，得出的答案即为斐波那契数列的前n项和。\n如图\n\n\n\n\n但当我验证时，却发现有一种情况不符合我的猜想，当输入3的倍数时得出的值不符，如输入3，应得4，输出却为3，输入6应得20，但输出值却是19，输入9，应得88，输出却为87，但输入除3倍数的其它值均正常，为正确结果，符合预期。\n研究了半天，终究没有找到问题所在，故来寻求帮助。\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "#include <stdio.h>\nint main()\n{\n    int a[25],s,i;\n    scanf(\"%d %d\",&a[0],&a[1]);\n    printf(\"%d %d \",a[0],a[1]);\n    for(i=2;i<=20;i++){\n        a[i]=a[i-1]+a[i-2];\n        printf(\"%d \",a[i]);\n    }\n    return 0;\n}\n\n 觉得有用的话采纳一下哈", "Konwledge_Point": "Fibonacci数列", "Question": "Fibonacci数列在c 语言中的算法\n", "Tag": "算法分析"}
{"Answer": "通过多次提交，我发现有三个问题，一是没有多次循环，二是没用long long，三是不用判断是否为1或2", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列求解C++，提交后W了\nDescription\n已知a[1]=1,a[2]=1,a[n]=a[n-1]+a[n-2]，求解a[n]的值，n<=90\n\n\nInput\n多组输入，每组一行，输入n，n<=90\n\n\nOutput\n一行一个a[n]\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\nint\n \nmain\n()\n \n{\n    \nint\n n;\n    \nwhile\n (cin >> n) {\n        \nint\n a[\n100\n];\n        \nfor\n (\nint\n i = \n3\n; i <= n; i++) {\n\n            a[\n1\n] = \n1\n;\n            a[\n2\n] = \n1\n;\n            a[i] = a[i - \n1\n] + a[i - \n2\n];\n        }\n        cout << a[n];\n    }\n    \nreturn\n \n0\n;\n}\n\n\n\n\nOJ提交后结果：\nWrong Answer50%    ", "Tag": "算法分析"}
{"Answer": "你定义了febnaqi(m)函数并没有调用它，而且fib(m - 1) 和fib(m - 2) 肯定会出现小于1的情况\ndef fib(n):\n    if n < 1:\n        return print(\"Error\");\n    elif n == 1 or n == 2:\n        return 1;\n    else:\n        return fib(n - 1) + fib(n - 2);\nnum = int(input());\nfor i in range(1, n + 1):\n        print(fib(i), end=\"  \")\n\n望采纳", "Konwledge_Point": "Fibonacci数列", "Question": "用Python写斐波那契数列，为啥报错啊\nPython 写斐波那契数列，出现报错，返回相加那里出现报错，说是不可操作类型。\n\n", "Tag": "算法分析"}
{"Answer": "\n int fib(int n) {\n  if (n == 0 || n==1)\n   return n;\n\n  int a = 1, b = 0;\n  for (int i = 1; i < n; i++) {\n   a = a + b;\n   b = a - b;\n   a %= 1000000007;\n  }\n  return a;\n }\n", "Konwledge_Point": "Fibonacci数列", "Question": "斐波那契数列实现问题，不知道哪儿错了\nint\n fib(\nint\n \nn\n) {\n    \nif\n (\nn\n == \n0\n )\n        return \nn\n;\n\n    \nint\n a = \n1\n, b = \n0\n;\n    for (\nint\n i = \n1\n; i < \nn\n; i++) {\n        a = a + b;\n        b = a - b;\n        a %= \n1000000007\n;\n    }\n    return a;\n}\n", "Tag": "算法分析"}
{"Answer": "或，11行是||(m<0 || m>k || k>=45)其他的看起来像没问题。有帮助的话采纳一下哦！", "Konwledge_Point": "Fibonacci数列", "Question": "求m与k项之间的斐波那契数列之和\n哪里有错?实在看不出来，大一一枚，初学者刚刚接触数组，还望各位神仙行行好教我一下", "Tag": "算法分析"}
{"Answer": "#include<stdio.h>\nint fun(int t)\n{\n    int a = 1, b = 1,c;\n    c = a + b;\n    for (int i = 2; c <= t; i++)\n    {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return c;\n}\nint main()\n{\n    int n;\n    printf(\"Input n please:\");\n    scanf(\"%d\", &n);\n    printf(\"n=%d,f=%d\\n\", n, fun(n));\n    return 0;\n}\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "用自定义函数求出斐波那契数列的下一项\n明明是很基础的东西，但我还是觉得C语言好难学啊\n凑够三十个字好难啊", "Tag": "算法分析"}
{"Answer": "if(n==1)if(n==2)你只写了一个等号啊", "Konwledge_Point": "Fibonacci数列", "Question": "请问我这代码哪里错了（山寨斐波那契数列）\n这是题目：\n这是我粗写的代码：\n\n\n这是不是得调用函数啊\n刚学函数不知道怎么运用", "Tag": "算法分析"}
{"Answer": "def fib(i):\n    if i == 1 or i == 2:\n        return 1\n    else:\n        return fib(i-1)+fib(i-2)\n\nn = int(input(\"输入你要得到项：\"))\nprint('第%d项为%d' % (n,fib(n)))\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "请问各位朋友可以帮我解决一下么？\n请问为什么用这个编码解决不了斐波那契数列，运行出来就是打出数字就是数字几？", "Tag": "算法分析"}
{"Answer": "print缩进不对，还有你的n要输入的，你要定义。修改后的代码如下，有帮助的话记得采纳一下哦！\ndef fib(i):\n    if i == 1 or i == 2:\n        return 1\n    else:\n        return fib(i-1)+fib(i-2)\n \nn = int(input(\"输入你要得到项：\"))\nprint('第%d项为%d' % (n,fib(n)))\n", "Konwledge_Point": "Fibonacci数列", "Question": "请各位朋友们帮我解决下问题\n请问为什么用这个编码解决不了斐波那契数列，运行出来就是打出数字就是数字几？", "Tag": "算法分析"}
{"Answer": "修改后的代码如下：\r\n```asm\r\n.model small\r\n.stack \r\n.data\r\n\ttotal equ 10\r\n\tcount dw 0\t;count=0相当于宏替换，不是在内存中的，不能给值\r\n\tid    dw 0  ;id=0问题同count\r\n\tFibonacci dw total dup(0)\r\n.code\r\nstart: \r\n\tmov ax,@data\r\n\tmov ds,ax\r\n\tmov ax,1\r\n\tmov bx,0\r\n\tmov cx,total\r\n\t;mov count,0\t      ;变量不能做索引\t  \r\n\tmov si,0              ;因此，我们用si做索引\r\nagain:\r\n\tmov Fibonacci[si],ax  ;变量不能做索引\r\n\tmov id,ax\r\n\tadd ax,bx\r\n\tmov bx,id\r\n\t;inc count\r\n\tinc si\r\n\tinc si\t\t\t\t   ;dw为字长，索引增长2\r\n\tloop again\r\n\t;mov ah,4ch或mov ax,4c00h才是退出\r\n\t;原先的mov ax,4ch相当于mov al,4ch，没有选择功能号，无意义\r\n\tmov ax,4c00h\t\t\t\t\r\n\tint 21h\r\nend start\r\n```\r\n问题已在注释中说明，主要是语法错误，经检验算法正确，运行结果如下：\r\n![运行情况](https://img-ask.csdn.net/upload/201711/13/1510585833_343114.png)\r\n\r\n即\r\n> 1 1 2 3 5 8 13 21 34 55\r\n\r\n主要语法问题：\r\n- `=`和`equ`都是宏替换，汇编器不为为二者开辟内存空间，向此处赋值不予通过\r\n- 某块内存不能作索引，可作索引的有`bx`，`si`，`di`以及栈指针寄存器`bp`和`sp`\r\n- 数组每个元素为字长，因此`si`作索引每次循环后加2\r\n- `ah`赋值`4ch`才是调用`int 21h`的`4ch号`功能，而不是给`ax`赋值4ch", "Konwledge_Point": "Fibonacci数列", "Question": "斐波契那数列，汇编问题，求找出问题。急急急\n .model small\n\n.stack \n\n.data\n\ntotal equ 10\n\ncount = 0\nid    =0\nFibonacci  dw total dup(0)\n\n\n.code\n\nstart: \n\n          mov ax,@data\n\n            mov ds,ax\n\n            mov ax,1\n\n            mov bx,0\n\n            mov cx,total\n\n            mov count,0\n\n\nwhile:      mov Fibonacci[count], ax\n\n            mov id,ax\n\n            add ax,bx\n\n            mov bx,id\n\n            inc count\n\n            loop while\n\n            mov ax,4ch\n\n            int 21h\n\n            end start\n\n\n\n\n出现好几个错误，汇编新手，急用，谢谢。求告知问题所在。", "Tag": "算法分析"}
{"Answer": "\n#include <stdio.h>\n#include <malloc.h>\nint main(){\n    int n,i,dp[2]={1,1};\n    char *s;\n    scanf(\"%d\",&n);\n    s=(char *)malloc(sizeof(char)*(n+1));\n    for(i=0;i<n;i++){\n        s[i]='o';\n    }\n    s[n]='\\0';\n    for(i=1;dp[i]<=n;i=!i){\n        s[dp[i]-1]='O';//dp[i]为斐波那契数 \n        dp[i]=dp[0]+dp[1];\n    }\n    printf(\"%s\",s);\n    return 0;\n}\n", "Konwledge_Point": "Fibonacci数列", "Question": "不会做，谁能帮个忙嘛\n题目描述\n斐波那契数列以如下递推的形式定义：F(0)=1，F(1)=1,F(n)=F(n−1)+F(n−2)（n≥2，n∈N∗）。\n\n\n如果一个数出现在斐波那契数列之中，那么我们就称这个数为斐波那契数。\n\n\n现在，给定一个整数 n，请你构造一个长度为 n 的字符串 s1s2…sn。\n\n\n对于字符串中的第 i 个字符 si：\n\n\n如果 i 是斐波那契数，则 si 为大写字母 O。 如果 i 不是斐波那契数，则 si 为小写字母 o。 输出构造好的字符串。\n\n\n注意，字符下标从 1 到 n。", "Tag": "算法分析"}
{"Answer": "望采纳\n这是一个简单的递归函数，用来求解斐波那契数列的某一项的值：\ndef fibonacci(n):\n  if n == 0:\n    return 0\n  elif n == 1:\n    return 1\n  else:\n    return fibonacci(n - 1) + fibonacci(n - 2)\n\n下面是一个使用该函数的测试程序，它从键盘输入指定项，并输出斐波那契数列指定项的值：\n# Get the n-th item in the Fibonacci sequence\nn = int(input(\"Enter the item number in the Fibonacci sequence: \"))\n\n# Compute the value of the n-th item in the sequence\nvalue = fibonacci(n)\n\n# Print the result\nprint(f\"The value of the {n}-th item in the Fibonacci sequence is {value}.\")\n\n请注意，上面的代码假定斐波那契数列的第一项为0，第二项为1。如果需要，可以修改函数的定义来更改这个假定。", "Konwledge_Point": "Fibonacci数列", "Question": "python问题求解\n编写一个递归函数，求解Fibonacci数的问题的某项的值，编写测试程序从键盘输入指负项，并输出Fibonacci数列指定项的值", "Tag": "算法分析"}
{"Answer": "![图片说明](https://img-ask.csdn.net/upload/202006/22/1592834285_730672.png)\r\n\r\n\r\n```\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.ComponentModel;\r\nusing System.Data;\r\nusing System.Drawing;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Windows.Forms;\r\n\r\nnamespace Q1086908\r\n{\r\n    public partial class Form1 : Form\r\n    {\r\n        public Form1()\r\n        {\r\n            InitializeComponent();\r\n        }\r\n\r\n        private int f(int n)\r\n        {\r\n            if (n == 1 || n == 2) return 1;\r\n            return f(n - 2) + f(n - 1);\r\n        }\r\n\r\n        private void button1_Click(object sender, EventArgs e)\r\n        {\r\n            label1.Text = f(int.Parse(textBox1.Text)).ToString();\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n# 问题解决的话，请点下采纳", "Konwledge_Point": "Fibonacci数列", "Question": "C#构建窗体类应用程序\n如何在C#中构建窗体类应用程序，实现计算斐波那契数列的第n项。。。。。。。。。。。。。。", "Tag": "算法分析"}
{"Answer": "从图可以看出后位是前1位或前2位的和，以及二分法查找，以及数组左右移位，共4种算法。", "Konwledge_Point": "Fibonacci数列", "Question": "求用数组和循环解决该问题\n现在不知道该如何解决，只知道斐波那契数列如何输出其余的不会，希望有人能将注释写清楚些，谢谢了\n\n", "Tag": "算法分析"}
{"Answer": "\n#include <stdio.h>\n \nint main()\n{\n    int i, n, t1 = 0, t2 = 1, nextTerm;\n \n    printf(\"输出几项: \");\n    scanf(\"%d\", &n);\n \n    printf(\"斐波那契数列: \");\n \n    for (i = 1; i <= n; ++i)\n    {\n        printf(\"%d, \", t1);\n        nextTerm = t1 + t2;\n        t1 = t2;\n        t2 = nextTerm;\n    }\n    return 0;\n}\n\n ", "Konwledge_Point": "Fibonacci数列", "Question": "帮忙看看，谢谢了，马上要期末考试了\n斐波那契数列在c语言中有几种方法可以做出来呀，可以列举出来嘛", "Tag": "算法分析"}
{"Answer": "就是迭代的时候把数值存进一个list，然后return list就好了。python的return没有限制，return啥都行", "Konwledge_Point": "Fibonacci数列", "Question": "这道斐波那契题怎么实现？（python）\n问题遇到的现象和发生背景\n\n\n“求列表 递归函数return必须直接是列表 刚才那题也是，都不需要考虑本身跟n比较大小，但必须是递归函数return一个列表或集合\n不可以是递归一个数，然后再设计个函数或者在函数外部用for之类的组合成列表”\n这是要求\n\n\n问题相关代码，请勿粘贴截图\n\n\n编写函数，使用递归函数f(n)实现斐波那契数列中前n个值（递归函数返回值要求是列表）。\n\n\n我的解答思路和尝试过的方法\n\n\n正常的递归都是直接返回一个数，但是这里要求返回列表，有点懵逼了", "Tag": "算法分析"}
{"Answer": "l=[1,1]\nfor i in range(2,21):\n    l.append(l[i-1]+l[i-2])\nn=int(input())\nprint(l[n-1])\n", "Konwledge_Point": "Fibonacci数列", "Question": "用python语言解决列表问题\n裴波那契数列也称兔子数列 ，它的第一项是一 ，第二项是一 ，从第三项开始 每项为前两项之和。\n计算斐波那契数列的前20项的值 ，并保存到列表中 ，用户输入一个整数n，输出列表中第n项值。", "Tag": "算法分析"}
{"Answer": "n=int(input())\nf1=f2=1\nf3=f1+f2\nwhile n>f3:\n    f1=f2\n    f2=f3\n    f3=f1+f2\nprint(f3)\n", "Konwledge_Point": "Fibonacci数列", "Question": "请问这个该怎么解决呢\n输入一个自然数，输出不小于该自然数的最小的一个Fibonacci数。（Fibonacci数列：1，1，2，3，5，8，13，······  前面相邻两项之和，构成了后一项。）", "Tag": "算法分析"}
{"Answer": "我用#CSDN#这个app发现了有技术含量的博客，小伙伴们求同去《C++---006---斐波那契数列与哥德巴赫猜想》, 一起来围观吧 https://blog.csdn.net/m0_62469100/article/details/125264945?utm_source=app&app_version=5.5.0&code=app_1562916241&uLinkId=usr1mkqgl919blen", "Konwledge_Point": "Fibonacci数列", "Question": "c＋＋入门函数组成问题\n1.\n用递归函数求Fibonacci数列。\n#include\nlongf((1)){\nlong   s;\nif(n==1||n==2)return(2);\ns=\n(3)\n+\n(4)\n;\nreturns;\n}\nintmain(void){\nint\nn;\nprintf(\"pleaseinputn:\");\nscanf(\"%d\",&n);\nif(n<0)\nprintf(\"error!\\n\");\nelse\nprintf(\"第%d项Fibonacci数列的值为%ld\",n,f(n));\nreturn0;\n}\n答案：(1)int\nn\n(2)1\n(3)f(n-1)\n(4)f(n-2)\n想请问一下return后面的数字是如何确定的", "Tag": "算法分析"}
{"Answer": "经典的斐波那契数列：\nnterms = int(input(\"你需要几项？\"))\n \n# 第一和第二项\nn1 = 0\nn2 = 1\ncount = 2\n \n# 判断输入的值是否合法\nif nterms <= 0:\n   print(\"请输入一个正整数。\")\nelif nterms == 1:\n   print(\"斐波那契数列：\")\n   print(n1)\nelse:\n   print(\"斐波那契数列：\")\n   print(n1,\",\",n2,end=\" , \")\n   while count < nterms:\n       nth = n1 + n2\n       print(nth,end=\" , \")\n       # 更新值\n       n1 = n2\n       n2 = nth\n       count += 1\n", "Konwledge_Point": "Fibonacci数列", "Question": "Python 一个计算题，这个怎么计算\n题目如下：斐波那契数列指的是这样一个数列 0, 1, 1, 2, 3, 5, 8, 13,特别指出：第0项是0，第1项是第一个1。从第三项开始，每一项都等于前两项之和。\n麻烦给个能跑的代码", "Tag": "算法分析"}
{"Answer": "\nfunction test(len) {\n        let fibonacciArr = [1, 1]\n        let i = 0\n        function fibonacci(len) {\n            let leng = fibonacciArr.length\n            if (leng < len) {\n                fibonacciArr.push(fibonacciArr[i] + fibonacciArr[i + 1])\n                i++\n            } else {\n                return fibonacciArr\n            }\n            fibonacci(len)\n        }\n        fibonacci(len)\n        return fibonacciArr\n    }\n    console.log(test(8))\n    return test(8)\n", "Konwledge_Point": "Fibonacci数列", "Question": "JavaScript如何在全局拿到函数作用域内的变量\n以下是求斐波那契数列的一个函数，我想\nreturn\n出新的数组，但是似乎只能\nreturn\n出函数\n\n\n\nlet\n fibonacciArr = [\n1\n, \n1\n]\n\nlet\n i = \n0\n\n\nfunction\n \nfibonacci\n(\nquantity\n) {\n  \nlet\n leng = fibonacciArr.\nlength\n\n  \nif\n (leng < quantity) {\n    fibonacciArr.\npush\n(fibonacciArr[i] + fibonacciArr[i + \n1\n])\n    i++\n  } \nelse\n {\n    \n// return console.log(fibonacciArr)\n\n    \nreturn\n (\nfunction\n (\nnewArr\n) { \nreturn\n \nconsole\n.\nlog\n(newArr) }(fibonacciArr))\n  }\n  \nfibonacci\n(quantity)\n}\n\nfibonacci\n(\n8\n)\n\n\n", "Tag": "算法分析"}
{"Answer": "if后边加上大括号，不然你这个else就是无用的，会报错", "Konwledge_Point": "Fibonacci数列", "Question": "else后面应该加什么，还有什么要修改的吗\n求公式1- 1/1+ 1 /2- 1/3十1/ 5+·…的结果，要求每一项的绝对值大于10的-6次方（提示：每\n的分母的绝对值来自于Fibonacci数列)\n\n", "Tag": "算法分析"}
{"Answer": "第一张图片已经初始化了，后面再重复那样写的错误的第二张图是对的但是你int类型有点小了超出整形范围了所以为负数了  你可以用long long类型定义这个数组存放的数就不是负数了", "Konwledge_Point": "Fibonacci数列", "Question": "大一c语言，99我啦\nVC6.0  题目是输出斐波那契数列前50位\n1.为什么我像图一第五行那样初始化数组就会报错，而像图二第六行那样初始化数组就能运行呢？\n2.为什么图二的输出结果会有负数呢？\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "#  问题1\nlst1=[1,2,3,4,78,9,6,5]\nlst2=[1,2,55,4,56,8]\nlst=[]\nfor i in lst1:\n    if not i in lst2:\n        lst.append(i)\nlst.sort()\nprint(lst)\n# 问题2\nnums=[2,5,2,5,2,4,2,1,5,2,151,5,4,21,54]\nnums1=[]\nfor i in nums:\n    a=nums.count(i)\n    nums1.append(a)\nprint(max(nums1))\n#  问题4\nl=[1,1,2,3,5,8,13,21,34,55]\nn=int(input())\ni=10\nwhile i <n:\n    x=l[i-1]+l[i-2]\n    l.append(x)\n    i+=1\nprint(x)\n#  问题5\nn=int(input())\nm=int(input())\ni=n\nl1=[]\nwhile i <m:\n    l1.append(i)\n    i+=2\nprint(l1)\n#  问题5\nimport numpy as np\nmessage={'姓名':'','性别':'','平均成绩':''}\na=input('请输入姓名：')\nb=input('请输入性别：')\nc=input('请输入成绩：')\nd=c.split(' ')\ne=[]\nprint(d)\nfor i in d:\n    i=int(i)\n    e.append(i)\nmessage['姓名']=a\nmessage['性别']=b\nmessage['平均成绩']=np.mean(e)\nprint(message)\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "请问以下几问怎么写呀？\n1、给定两个整型列表，找出不是两者共有的元素。这些元素不重复的放入新的列表，并升序排列。输出结果列表\n2、对于一个包含自然数的列表nums，计算他的度。列表的度定义为列表里任一元素出现的频率的最大值。\n3、给定两个整型列表，找出不是两者共有的元素。这些元素不重复的放入新的列表，并升序排列。输出结果列表\n4、编写函数获得第n项斐波那契数列的值。斐波那契数列前10项如下：[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]。第1项为1，第二项为1，从第三项开始，每一项等于前两项之和。\n5、输入两个数，n,m。n是奇数，产生n和m之间的奇数列。不包含m。输出奇数列表\n6、录入学生的基本信息，取得学生的姓名、性别和平均成绩（科目数量不确定,但至少有一项）", "Tag": "算法分析"}
{"Answer": "\\t代表一个制表符，也就是一个tab键", "Konwledge_Point": "Fibonacci数列", "Question": "怎么对齐啊  \\t 到底怎么用啊\npublic class Homework13 {\n    public static void main(String[] args) {\n        //斐波那契数列的第1和第2个数分别为1和1，从第三个数开始，\n        // 每个数等于其前两个数之和（1 1 2 3 5 8 13）。\n        // 编写一个程序输出斐波那契数列中的前20个数，要求每行输出5个数。\n        int a = 1\n        int b = 1\n        int c = 0\n        System.out.print(a+\"\\t\\t\"+b+\"\\t\\t\");\n        for(int i=3;i<=20;i++){\n            c = a + b\n            a = b\n            b = c\n            System.out.print(c+\"\\t\\t\")\n            if(i%5==0){\n                System.out.println()\n            }\n        }\n    }\n}\n怎么就对其不了啊  \\t咋用啊", "Tag": "算法分析"}
{"Answer": "#include<stdio.h>\nint main() {\n    int i,f1=1,f2=1,f3;\n    for(i=3; i<=30; i++) {\n        f3=f1+f2;\n        if(i>=20){\n            printf(\"第%d项%d与第%d项%d的商为%.12lf\\n\",i-1,f2,i,f3,f2*1.0/f3);\n        }\n        f1=f2;\n        f2=f3;\n    }\n}\n\n\n觉得有用的话采纳一下哈", "Konwledge_Point": "Fibonacci数列", "Question": "c语言问题求完整代码\nFibonacci数列的前两项为1，1，以后每项的值是它前两项的和。输出其20项到30项中，每一项的前一项与该项的商，看是否越来越接近黄金分割比例0.618。", "Tag": "算法分析"}
{"Answer": "简单粗暴系列：\nlist1=[6,8,10,20]\nnumbers=[]\nlists=[1,1]\ni=0\nwhile i!=100:\n    numbers\n    lists.append(lists[-2]+lists[-1])\n    i=i+1\nfor list in list1:\n    numbers.append(lists[list-1])\nprint(numbers)\nprint('\\n***********************\\n')\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "运用python程序编写下面的的代码\n第1题-斐波那契数列\n在数学上，斐波那契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 3，n ∈ N*）斐波那契\n请完成求第n项斐波那契数的程序并输出结果\n\n\n\n\n\n```list1=[\n6\n,\n8\n,\n10\n,\n20\n] #n的取值列表list1\nnumbers = [] #用来存放结果的 \n#for n \nin\n list1:  #依次从列表中取出数据赋值给n，求第n项的结果并保存到numbers[]列表中   \n#请在下面编写代码\n# ********** Begin ********** #\n\n\n\n\n     \n\n     \n    \n# ********** End ********** #\n#请不要修改下面的代码\nprint(numbers)\nprint(\n'\\n***********************\\n'\n)\n\n```python\n\n\n", "Tag": "算法分析"}
{"Answer": "他写了个数组,用来模拟整数数组中的每一个元素代表了长整数中的某一位,比如数组第一项代表长整数的个位,第二项代表十位等如果数组中的某一位超过10,则将其-10并进位到数组的下一项计算完毕后输出数组中每个元素,合起来就是一个长整数", "Konwledge_Point": "Fibonacci数列", "Question": "想要解决斐波拉契数列输出数据过大问题\n第3关：兔子问题\n\n\n题目描述：\n\n\n求解Fibonacci数列的第110项、第200项的值。\n\n\n测试输入: 110\n\n\n预期输出： 26925748508234281076009\n\n\n提示：\n注意溢出及大数问题\n第一项为 0 ，第二项为1\n\n\n求解思路是 直接使用递归 ，但是数字过大会直接溢出\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\nint\n \nFibonacci\n(\nint\n n)\n; \n\nint\n \nmain\n()\n\n\n{\n    \nint\n n;\n    \nint\n f;\n    \nscanf\n(\n\"%d\"\n,&n);\n    f = \nFibonacci\n(n);\n    \nprintf\n(\n\"%d\"\n,f);\n \nreturn\n \n0\n;\n}\n\n\nint\n \nFibonacci\n(\nint\n n)\n \n{\n    \nif\n(n == \n1\n) \n    {\n        \nreturn\n \n0\n;\n    }\n    \nelse\n \nif\n (n == \n2\n) \n    {\n        \nreturn\n \n1\n;\n    } \n    \nelse\n {\n        \nreturn\n \nFibonacci\n(n\n-1\n)+\nFibonacci\n(n\n-2\n);\n    }\n\n}\n\n\n\n\n\n找到了运行成功的代码，但是实在看不太懂，求问有没有人够解释一下\n\n\n\n\n#\ninclude\n\n\n\n#\ndefine\n F1 300\n\n\n#\ndefine\n F2 1000\n\n\nint\n \nmain\n()\n\n\n{\n    \n//设置二维数组 \n\n    \nint\n F[F1][F2]={\n0\n};\n    \nint\n k;\n    \n//输入较大值 \n\n    \nscanf\n(\n\"%d\"\n,&k); \n    F[\n0\n][F2\n-1\n]=\n0\n;\n//第0行第299个为0 \n\n    F[\n1\n][F2\n-1\n]=\n1\n;\n//第1行第299个为1 \n\n    \nfor\n(\nint\n d=\n2\n;d=\n0\n;i--)\n           {\n              F[d][i]=F[d\n-1\n][i]+F[d\n-2\n][i];\n\n//              printf(\"%d\\n\",F[d][i]);\n\n            }\n            \n        \nint\n r=F2\n-1\n;\n    \n//将其一个一个放入数组? \n\n        \nwhile\n(r>=\n0\n){\n            \nif\n(F[d][r]>=\n10\n)\n            {\n                F[d][r\n-1\n]+=\n1\n;\n                F[d][r]=F[d][r]\n-10\n;\n            }\n            r--;\n            }\n    }\n    \n    \nfor\n(\nint\n i = \n0\n; i <= F1; i++){\n        \nfor\n(\nint\n j = \n0\n; j <= F2; j++) {\n            \nprintf\n(\n\"%d \"\n,F[i][j]);\n        }\n        \nprintf\n(\n\"\\n\"\n);\n    }\n    \n    \nint\n j=\n0\n;\n    \nwhile\n(j<F2)\n    {\n        \nif\n(F[k\n-1\n][j]!=\n0\n)\n        {\n            \nwhile\n(j<F2)\n            {\n                \nprintf\n(\n\"%d\"\n,F[k\n-1\n][j]);\n                j++;\n            }\n        }\n        j++;\n    \n    }\n     \nreturn\n \n0\n;\n}\n\n\n\n\n原文链接：\nhttps://blog.csdn.net/xingcheng12345/article/details/115910547?ops_request_misc=&request_id=&biz_id=102&utm_term=%E7%AC%AC3%E5%85%B3%EF%BC%9A%E5%85%94%E5%AD%90%E9%97%AE%E9%A2%98%20%E6%B1%82%E8%A7%A3Fibonacci%E6%95%B0%E5%88%97%E7%9A%84%E7%AC%AC110%E9%A1%B9%E3%80%81%E7%AC%AC&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-115910547.pc_search_result_control_group&spm=1018.2226.3001.4187", "Tag": "算法分析"}
{"Answer": "拿i+1模5就行了", "Konwledge_Point": "Fibonacci数列", "Question": "对教材例题的一点改动\n这个表示的是，斐波那契数列\nf(x+2)＝f(x＋1)＋f（x）\nf（2）=f（1）＝1\n然后要求每输出五个数字，换一行。\n我感觉我就是换了一个表达，可是为什么会和教材的结果不一样呀", "Tag": "算法分析"}
{"Answer": "不知道题目具体要求，但是可以通过代码的逻辑猜测出它的行为。使用[:n]的时候，当n小于给定列表的长度时，它会将列表的前n项切片出来，然后利用这前n项的后三项计算n-3次泰波那契数，所以生成的列表长度应为n+(n-3)=2n-3如果删去该行，当n小于给定列表的长度时，它会直接利用传入列表的后三项计算n-3次泰波那契数，生成的列表长度应为len(signature)+(n-3)其中n<len(signature)，同时因为取的三项数在列表不同位置，生成的n-3个数也基本不同（除非signature[:n][-3:]=signature[-3:]）当n大于等于给定列表的长度时，使用[:n]进行切片不会影响原列表，所以结果一样", "Konwledge_Point": "Fibonacci数列", "Question": "关于Tribonacci的题，解释代码\nTribonacci数列,它的工作原理基本上类似于斐波那契数列，\n但将序列的最后 3 个（而不是 2 个）数字相加以生成下一个。\n为什么要用[:n]\n\n\ndef\n tribonacci(signature, n):\n  \nsignature\n = signature[:n]\n  \nfor\n i in range(n - \n3\n):\n      \nsignature\n.append(sum(signature[-\n3\n:]))\n  \nreturn\n signature\n\nprint\n(tribonacci([\n1\n,\n1\n,\n1\n], \n10\n))\n", "Tag": "算法分析"}
{"Answer": "n=1 n=2，你看你结果是什么？", "Konwledge_Point": "Fibonacci数列", "Question": "请问我哪还有错，为什么还是部分正确\n我的代码；\n#include\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    int a=1,b=1,c=2;\n    int i=1;\n    while(i<=n)\n        {\n        if(i==1||i==2){\n        printf(\"1,\");}\n        else{\n            c=a+b;\n            a=b;\n            b=c;\n            if(i=n){\n                printf(\"%d\",c);}\n    }\n    i++;\n    }\n    return 0;\n}\n题；Fibonacci数列的递推公式为：\n3333333333.png\n\n\n编程读入整数n(1<=n<=40)，输出Fibonacci数列的前n项。\n\n\n输入样例:\n1\n输出样例:\n1\n输入样例:\n2\n输出样例:\n1,1\n输入样例:\n5\n输出样例:\n1,1,2,3,5\n输入样例:\n10\n输出样例:\n1,1,2,3,5,8,13,21,34,55", "Tag": "算法分析"}
{"Answer": "代码如下，如有帮助，请采纳一下，谢谢。\n\n#include <stdio.h>\n\nint func(int n)\n{\n\tif (n ==0)\n\t{\n\t\treturn 0;\n\t}else if (n == 1)\n\t{\n\t\treturn 1;\n\t}else if (n >1)\n\t{\n\t\treturn func(n-1)+func(n-2);\n\t}else\n\t\treturn -1;\n}\n\nvoid main()\n{\n\tint n;\n\twhile(1)\n\t{\n\t\tprintf(\"请输入n:\");\n\t\tscanf(\"%d\",&n);\n\t\tint d = func(n);\n\n\t\tprintf(\"总数=%d\\n\",d);\n\t}\n\t\n}\n ", "Konwledge_Point": "Fibonacci数列", "Question": "求求大佬们救救孩子吧\n编写功能函数fun( )，计算并返回Fibonacci数列(生兔子问题)的第n项的值。Fibonacci数列：1  1  2  3  5  8  13  21……‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬\n\n注：必须使用递归函数法\n\n#include \nint fun(int n)\n{//必须使用递归函数\n补全\n\n\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tprintf(\"%d\",fun(n));\n\treturn 0;\n}", "Tag": "算法分析"}
{"Answer": "\n#include <iostream>\nusing namespace std;\n\nlong long fun(int n)\n{\n    int i;\n    long long a1= 1,a2 = 1,an;\n    if(n<3) return 1;\n    for(i=3;i<=n;i++)\n    {\n        an = a1 + a2;\n        a1 = a2;\n        a2 = an;\n    }\n    return an;\n}\n\n\nint main()\n{\n    int n;\n    int *p;\n    cin >> n;\n    p = new int[n];\n    for(int i = 0;i<n;i++)\n        cin >> p[i];\n\n    for(int i =0;i<n;i++)\n        cout << fun(p[i]) << endl;\n    delete[] p;\n    p = 0;\n    return 0;\n}\n", "Konwledge_Point": "Fibonacci数列", "Question": "用C++完成菲波数小程序\n问题：\n斐波那契数列，定义如下\n\n\nf(1)=f(2)=1\nf(n)=f(n-1)+f(n-2) n>=3\n计算第n项菲波数值\n\n\n输入第一行为一个整数N，接下来N行为整数Pi（1<=Pi<=60）\n输出为N行，每行为对应的f（Pi）", "Tag": "算法分析"}
{"Answer": "C语言代码：\n#include<stdio.h>\n#include<math.h>\nint main()\n{\n    int a,b,i;\n    long long a_b=0,a_0=0,a_1=1;\n    scanf(\"%d%d\",&a,&b);\n    for(i=0;i<=60;i++)\n    {\n        if(i==a)\n        a_0=a_1;\n        if(i==b)\n        a_b=a_1;\n        a_1=a_0+a_1;\n        a_0=a_1-a_0;\n    }\n    printf(\"%lld\\n\",a_0+a_b);\n    return 0;\n}\n\n\n看起来程序的代码逻辑是正确的。但是，有一些小的问题。\n数组的定义不正确：您定义的数组大小为 60，而斐波那契数列的项数较多，因此定义数组的大小要足够大。\n数组的遍历不正确：您的代码中的循环语句有些不对。第 4 行的循环只会执行一次，因为在第 9 行您递增了 i。第 10 行的数组 b 是不需要的，请将其删除。\n输出格式不正确：您需要输出 Fibonacci 数列中任意两项之和，而不是所有项之和。\n修正以上问题后的代码如下：\n#include<stdio.h>\n#include<math.h>\n\nint main()\n{\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    int n = fmax(a, b);\n    int f[n];\n    f[0] = 1;\n    f[1] = 1;\n    for (int i = 2; i < n; i++)\n    {\n        f[i] = f[i-1] + f[i-2];\n    }\n    printf(\"%d\\n\", f[a-1] + f[b-1]);\n    return 0;\n}\n\n", "Konwledge_Point": "Fibonacci数列", "Question": "请问我写的有什么问题，要怎么改\n任务描述\n输出Fibonacci数列中任意两项之和。\n\n\n输入格式:\n两个整数a,b(大于0小于 等于60的正整数)，以空格分隔。\n\n\n输出格式:\n输出Fibonacci数列中第a项和第b项之和。\n\n\n输入样例:\n4 6\n输出样例:\n11\n输入样例:\n20 30\n输出样例:\n838805\n输入样例:\n56 52\n输出样例:\n258802713816\n\n\n\n\n#include\n\nint main(){\n    int \nc\n=0,d=0,e=0,f=0,sum=0,k=0,i;\n    int a[60],b[60];\n    scanf(\n\"%d %d\"\n,&c,&d);\n    a[0]=1;\n    a[1]=1;\n    \nfor\n(\ni\n=0;i<60;i++){\n        a[i]=a[i-1]+a[i-2];\n        b[k++]=a[i++];\n    }\n    \nfor\n(\ni\n=1;i<=k;i++){\n        \nif\n(\ni\n==c)\n            \ne\n=b[i];\n        \nif\n(\ni\n==d)\n            \nf\n=b[i];\n    }\n    \nsum\n=e+f;\n    printf(\n\"%d\"\n,sum);\n}\n", "Tag": "算法分析"}
{"Answer": "这个程序完全符合要求了，不要再问了。。\r\n```\r\n #include \r\n \r\nint main()\r\n{\r\n  int f[100];\r\nint m, n, i;\r\nf[0] = 1; f[1] = 1;\r\nscanf(\"%d,%d\", &m, &n);\r\n\r\nfor (i = 2; i < 100; i++)\r\n{\r\n    f[i] = f[i - 1] + f[i - 2];\r\n    if(f[i]>n){\r\n        break;\r\n    }\r\n}\r\n\r\nfor (i=0; f[i]<=n; i++){\r\n    if(m<=f[i]&&f[i]<=n){\r\n    printf(\"%d \",f[i]);\r\n    }\r\n}\r\n  return 0;\r\n}\r\n```", "Konwledge_Point": "Fibonacci数列", "Question": "C语言问题求解答，帮忙看一下这个编程~~~~\n输出[m,n]范围内的所有斐波那契（Fibonacci）数，m,n这两个数由键盘输入。\n\n【提示】\n\n1,1,2,3,5,8,13,21,34,……这是斐波那契（Fibonacci）数列的前几项。斐波那契数列的特点：前两项均为1，后面任意一项都是其前面两项之和。\n\n本实验虽然只要求输出在[m,n]范围内的斐波那契数，但是依然需要从第1个Fibonacci数开始依次得到下一个，并判断是否是需要输出的那个。\n\n#include\n\nint main()\n\n{\n\n    int f[100];\n\n    int m, n, i;\n\n\n\nf[0] = 1; f[1] = 1;\nfor (i = 2; i < 100; i++)\n{\n    f[i] = f[i - 1] + f[i - 2];\n}\nscanf(\"%d%d\", &m, &n);\nfor (i = 0; f[i] < m; i++);\nfor (; f[i]<n; i++) \n    printf(\"%d \",f[i]);\n\nreturn 0;\n\n\n\n\n}\n\n两个疑问\n\n第一个疑问： 你看这个程序 ，我输入 1 3 ，也就是m是1，n是3，运行第二个for时，f[0]<m 不成立 那么程序会怎么样走呢，整个程序也就一个printf 但也要第三个for成立时候才能执行，那要是之前不成立呢，程序怎么运行？\n\n第二个疑问 \n\n我输入 1 3 输出 1 1  2，怎么改能让他输出 1  1  2  3或者 1  2  3 呢？", "Tag": "算法分析"}
