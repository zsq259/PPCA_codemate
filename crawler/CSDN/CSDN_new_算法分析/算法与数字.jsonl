{"Answer": "做梦。\r\n明文/密文可表示的数量一致（比如三位的数字两边都是1000个），又要可逆，只能一一对应，无论算法再复杂，实质还是置换，把1000个数字都加密一遍，就得到完整的置换表了。", "Konwledge_Point": "算法与数字", "Question": "求一个可逆的数字加密算法，将固定长度的数字转换为相同长度的数字\n求一个可逆的数字加密算法，将固定长度的数字转换为相同长度的数字。\n\n比如输入三位的数字就输出一个三位的数字（第一位可以是0），输入4位数字，则输出4位数字\n\n要求具有一定的复杂度，不能是经典的加密算法（置换，移位之类的）", "Tag": "算法分析"}
{"Answer": "64bit=2的64次方。\r\n2的10次方约等于10的3次方。\r\n2的60次方约等于10的18次方。\r\n2的4次方=8\r\n所以用10进制表示，差不多就是18~19位", "Konwledge_Point": "算法与数字", "Question": "雪花算法生成位数的问题\n雪花算法的原则是生成64bit的唯一编码，为什么存储在数据库是18个数字，怎么算都不对，请教给位，谢谢", "Tag": "算法分析"}
{"Answer": "name = input(\">>>\")\nN = int(input(\">>>\"))\n\ns = ''\nfor i in name:\n    s += str((ord(i) - 65) + N)\n    \nwhile s != '100' and len(s) >2:\n    r = [str((int(s[i]) + int(s[i+1])) % 10) for i in range(len(s) - 1)]\n    s = ''.join(r)\n   \nprint(int(s))\n\n", "Konwledge_Point": "算法与数字", "Question": "Python幸运数字问题 算法求解\n45、我们经常喜欢说自己的幸运数是多少，但是你认为的幸运数和你的契合度真的那么高吗？其实我们可以通过一段程序来对这点进行一个验证，我们现在有一种很神奇的计算方法：\n第一步： 取出你姓名的缩写，例如，我们上课的珊珊的名字缩写就可以写为SHANSHAN。\n第二步： 将每个字母用数字字符串取代。首先找到一个正整数N表示你的幸运数,之后用N来取代A,N+1来取代 B,N+2 来取代 C,……, N+25来取代Z。例如，如果珊珊觉得他的幸运数字是6，那么N就是6，A就被 6 取代，B 就被7取代，……，Z 则被32取代。上面的例子SHANSHAN则被 24136192413619取代。\n第三步：重复以下操作：将相邻的两位数相加，并写下和的个位数。不难发现这个操作每进行一次，这个数字字符串就会少一位数。当这个数字变成 100 或不超过两位数（第一位是 0 也算两位数）时，这个程序便停止。所得的数字就是你跟你幸运数的契合度。用上面的例子来说，处理的过程如下：\n24136192413619\n6549701654970\n193671719367\n——\n096\n95\n所以如果N为6的话，SHANSHAN跟数字6的契合度高达95！\n相信同学们一定很想知道自己名字和幸运数的契合度吧，你可以尝试着写一个程序，只要输入一个姓名和一个N值，就输出他们的契合度。\n输入格式：\n第一行包括一个仅包含大写字母的姓名字符串\n第二行是一个正整数N\n输出格式：\n一行，输出一个整数，表示契合度。\n输入输出样例：\n输入1:\nDLLSS\n478\n输出1:\n100", "Tag": "算法分析"}
{"Answer": "如果是20之内的纯数字，那么如果生成2*10^20+1个，必然重复，无论什么算法。\r\n要不重复，唯一的办法就是必须每次生成都记录下来，并且每次生成都比较，看是否重复，或者顺序生成，每次生成已有记录+1的编号。", "Konwledge_Point": "算法与数字", "Question": "求 产品编号生成算法 ，20位之内的纯数字 或者数字和字母搭配都可以\n求 产品编号生成算法 ，20位之内的纯数字 或者数字和字母搭配都可以\n\n\n\n但是要求就是编号都不一样 比如 ：  31312323  31312424 算法怎么实现呢 随机生成 \n\n不能重复  求好点的算法", "Tag": "算法分析"}
{"Answer": "\nWhat you're looking for is called a selection algorithm. The Wikipedia page on the subject has a few subsections in the selecting k smallest or largest elements section. When the list is large enough, you can beat the time required for the naive \"sort the whole list and choose the first 10\" algorithm.\n", "Konwledge_Point": "算法与数字", "Question": "收集最低数字算法\n\n\n\nI'm looking for an algorithm (or PHP code, I suppose) to end up with the 10 lowest numbers from a group of numbers. I was thinking of making a ten item array, checking to see if the current number is lower than one of the numbers in the array, and if so, finding the highest number in the array and replacing it with the current number. \n\n\n\nHowever, I'm planning on finding the lowest 10 numbers from thousands, and was thinking there might be a faster way to do it. I plan on implementing this in PHP, so any native PHP functions are usable.\n\n    ", "Tag": "算法分析"}
{"Answer": "设有一个顺序串s，其字符仅由数字和小写字母组成。设计一个算法将s中所有数字字符放在前半部分，所有小写字母字符放在后半部分。并给出你所设计的算法的时间和空间复杂度。\r\n#include <algorithm>\r\n#include <string>\r\n#include <iostream>\r\nstd::string s;\r\ncin >> s;\r\nsort(&s[0],&s[s.length() - 1]);\r\n\r\n空间复杂度和时间复杂度均为O(n * log(n))。", "Konwledge_Point": "算法与数字", "Question": "C++数据结构串算法题目.........\n设有一个顺序串s，其字符仅由数字和小写字母组成。设计一个算法将s中所有数字字符放在前半部分，所有小写字母字符放在后半部分。并给出你所设计的算法的时间和空间复杂度。", "Tag": "算法分析"}
{"Answer": "#include <iostream>  \n#include <vector>    \n#define maxn 100005  \nusing namespace std;    \nvector<int> E[maxn], dp(maxn), v(maxn);    \nint dfs(int u, int fa) {    \n    int bo = (v[u] ? 1 : 0);    \n    for(int i = 0; i < (int)E[u].size(); i++) {  \n        int  t = E[u][i];\n        if(t != fa) {\n             if(dfs(t, u)) {  \n                bo = 1;  \n                dp[u] += dp[t] + 2;  \n            }\n        }    \n    }   \n    return bo;    \n}    \nint main(void) {    \n    int n, m, s, t, k;  \n    cin >> n >> m;  \n    for(int i = 0; i < n - 1; i++) {  \n        cin >> s >> t;  \n        if(s > t) swap(s, t);\n        E[s].push_back(t);    \n        E[t].push_back(s);\n    }   \n    for(int i = 0; i < m; i++) {  \n        cin >> k, v[k] = 1;  \n    }  \n    dfs(1, -1);\n    cout << dp[1] << endl;    \n    return 0;    \n}    \n\n", "Konwledge_Point": "算法与数字", "Question": "算法与数据结构实验题 6.1 小明的果树\n算法与数据结构实验题 6.1 小明的果树\n\n\n★实验任务\n\n\n小明种了一棵果树，这棵树有 n 个节点，树根为 1 号节点，现在这颗果树上有 m 个节 点长出果实(根节点 1 有可能长出果实)，小明要从节点 1 出发采集这些果实，从一个节点爬 到相邻的另一个节点所需要的时间为 1，采集果实不需要时间，问小明如果要采集这 m 个果 实，从节点 1 出发，并且最后需要回到节点 1，最少需要多少的时间。\n\n\n★数据输入\n\n\n第 1 行输入两个数字 n 和 m 第 2 行到第 n 行每行输入两个数字 a 和 b 表示节点 a 和节点 b 之间有一条边 第 n+1 行输入 m 个数字，第 i 个数字 v[i]表示在 v[i]号节点上长有果实 n<=100000 0<m<=n\n\n\n★数据输出\n\n\n对于每个输入，输出一个数字，表示最少需要花费的时间。\n输入：\n4 2\n1 2\n1 3\n2 4\n2 3\n输出：\n4", "Tag": "算法分析"}
{"Answer": "将 数组 int[] arr={35,47,26,18,14,35,98,52,48,23,49,32} 进行 由大到小的排序，\r\n那么 从头遍历 累计，累加和 第一大于350 的数据 即符合条件的数据。", "Konwledge_Point": "算法与数字", "Question": "java数据结构算法问题，几个数相加得到满足条件的最小和\n我假设一种情况吧：\n\nint[] arr={35,47,26,18,14,35,98,52,48,23,49,32}\n\n假如我需要一个数：360\n\n我现在想知道，上面数组里面的哪几个数相加能大于350\n\n但是所有加起来大于350的组合里数据个数是最少的\n\n需要算法优化，遍历所有情况耗费太大", "Tag": "算法分析"}
{"Answer": "取决于加密函数需要什么类型，openssl一般都是要求byte数组。你的十六进制很好转换", "Konwledge_Point": "算法与数字", "Question": "关于C++的RSA算法。求教\n公钥私钥不用自己生成，公钥已经有了，要对一段随机数进行公钥加密。\n\n问题1：如果公钥是一段数据，比如：“123A123A123F13123F123F123F12F1F1FFF”这样的16进数据，在调用RSA_PUBLIC_ENTRYCPT时，如何将公钥赋给函数？这段公钥要转成什么类型啊？\n\n问题2：对于要加密的数据，比如一串16进制数据“F12F45F123A123F123FFF2FF1FF”.这样的，这段数据也是如何传给函数啊？要转成什么类型吗？", "Tag": "算法分析"}
{"Answer": "https://www.92to.com/xuexi/2017/03-04/18054845.html", "Konwledge_Point": "算法与数字", "Question": "自我复制数字的程序，这个算法怎么用C语言\nProblem Description\n\nSherlock is fond of playing with numbers. Two days ago he discovered that 9376^2 = 87909376 - the last four digits constitute 9376 again. He called such numbers self-replicating.\n\n\n\nMore precisely, an n-digit number is called self-replicating if it is equal to the number formed by the last n digits of its square. Now Sherlock often asks Xay to help him to find new such numbers. To make the things worse, Sherlock already knows what the scales of notation are, so he asks Xay to find, for example, hexadecimal or binary self-replicating numbers.\n\n\n\nXay wants to help Sherlock, but unfortunately he is very busy now: he is seriously preparing and training for the next ACM Regional Contest. So he asked you to write a program that for a given base b and length n will find all n-digit self-replicating numbers in the scale of notation with base b.\n\n\n\nInput\n\nthere are multiple test cases. one line of each test case contains two integer numbers b and n separated by a single space, the base b of the scale of notation (2 ≤ b ≤ 36) and the required length n (1 ≤ n ≤ 2000).\n\n\n\nOutput\n\nFor eacho test case, the first line contains K - the total number of self-replicating numbers of length n in base b. Next K lines contain one n-digit number in base b each. Uppercase Latin letters from A to Z must be used to represent digits from 10 to 35. The self-replicating numbers should be output int lexicographic order.\n\n\n\nSample Input\n\n2 1\n\n10 4\n\n\n\nSample Output\n\n2\n\n0\n\n1\n\n1\n\n9376", "Tag": "算法分析"}
{"Answer": "这种相等概率的不是最好做吗？\n设数组q[n]，n为券的总数初始化q[0至m]=\"经\"，q[m至2m]=\"统\"，...，q[5m至6m]=\"油\"，其中的文字也可以用数字表示，这个应该不用多说吧。设数组flag[n]，初始化flag[0至n]=0设数组out[n]设i=0\nwhile(i<n){r=rand(0至n) //不含nif(flag[r]==0){out[i]=q[r];flag[r]=1;i++;}}\n然后保存好out，按照out顺序从0开始，卖一个少一个。", "Konwledge_Point": "算法与数字", "Question": "求此题的算法，还有设计算法的一般思路方法\n在生活中，我们常常会遇到某些食品商家采用一种游戏的方式提供商品的优惠券。商家在每件商品中附一张优惠券，每张券上只印一个字，商家要求消费者集齐所有字即可兑换奖励。现在我们以6个字为例，例如“经统学院加油”，并且这6个字的商品是相等数量的。那么消费者购买12件商品，能享受优惠的可能性有多大", "Tag": "算法分析"}
{"Answer": "\nimport random\na = [random.randint(1,100) for n in range(100)]\nb = [n for n in a if n>=90]\nprint(a)\nprint('大于等于90的有：',len(b))\nprint(sum(a),sum(b))\nprint(sum(a)/len(a),sum(b)/len(b))\n\n", "Konwledge_Point": "算法与数字", "Question": "使用Python设计算法，计算100个元素的一维数组，分别统计其中大于等于90的个数，并求和与平均值。\n使用Python设计算法，计算100个元素的一维数组，分别统计其中大于等于90的个数，并求和与平均值。", "Tag": "算法分析"}
{"Answer": "//说实在话，我又想起旅行商问题来了~\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n *\r\n * @author Administrator\r\n */\r\npublic class NewClass {\r\n    /*\r\n    {2,3,5,7,12,10}\r\n    {2,3,6,4,12,9}\r\n    {3,8,5,11,12,4}\r\n     */\r\n\r\n    ArrayList list1;\r\n    ArrayList list2;\r\n    ArrayList list3;\r\n    ArrayList list;\r\n\r\n    public static void main(String[] args) {\r\n        new NewClass().printFirst();\r\n    }\r\n\r\n    //打印列表的第一个元素\r\n    public void printFirst(){\r\n        this.toOne();\r\n        for (int i = 0; i < this.list1.size(); i++) {\r\n            System.out.print(list.get(0).get(i) + \"  \");\r\n        }\r\n    }\r\n\r\n    //算法在这里\r\n    private ArrayList toOne() {\r\n        this.initList(); //初始化各个List\r\n        //前提条件还是你说的那些...\r\n        int length = this.list1.size();\r\n        int flag = 0;\r\n        for(int i = 0 ; i < list.size() - 1; i++){\r\n            for(int j = i + 1 ; j < list.size(); j++){\r\n                if(i == j){\r\n                    continue;\r\n                }\r\n                if(Integer.parseInt(list.get(i).get(flag).toString().trim()) < Integer.parseInt(list.get(i).get(flag).toString().trim())){\r\n                    list.remove(j);\r\n                }else if(Integer.parseInt(list.get(i).get(flag).toString().trim()) > Integer.parseInt(list.get(i).get(flag).toString().trim())){\r\n                    list.remove(i);\r\n                }\r\n            }\r\n            flag ++ ;\r\n            if(list.size() == 1){\r\n                break;\r\n            }\r\n        }\r\n        return list;\r\n    }\r\n\r\n    //初始化列表\r\n    private void initList() {\r\n        this.list1 = new ArrayList();\r\n        this.list2 = new ArrayList();\r\n        this.list3 = new ArrayList();\r\n        //list1变成{2,3,5,7,12,10}\r\n        list1.add(2);\r\n        list1.add(3);\r\n        list1.add(5);\r\n        list1.add(7);\r\n        list1.add(12);\r\n        list1.add(10);\r\n        //list2变成{2,3,6,4,12,9}\r\n        list2.add(2);\r\n        list2.add(3);\r\n        list2.add(6);\r\n        list2.add(4);\r\n        list2.add(12);\r\n        list2.add(9);\r\n        //list3变成{3,8,5,11,12,4}\r\n        list3.add(3);\r\n        list3.add(8);\r\n        list3.add(5);\r\n        list3.add(11);\r\n        list3.add(12);\r\n        list3.add(4);\r\n        //那个大的ArrayList是这样的\r\n        this.list = new ArrayList();\r\n        list.add(list1);\r\n        list.add(list2);\r\n        list.add(list3);\r\n    }\r\n}", "Konwledge_Point": "算法与数字", "Question": "小算法\n例如如下数据:\n\n{2,3,5,7,12,10}\n\n{2,3,6,4,12,9}\n\n{3,8,5,11,12,4}\n\n\n\n上面的三条记录放在ArrayList里面，并且每条数据本身也是一个ArrayLis，每条记录的长度是一样的，现在想找出其中最小的一条记录，即只要前面的数字小就认为它是小的。也就是说我要得到的数据是{2,3,5,7,12,10}\n\n\n\n用java有好的算法吗？最好能易读一点的\n\n[b]问题补充：[/b]\n\n能帮着写一下吗？", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/sunlianglong/article/details/80412258", "Konwledge_Point": "算法与数字", "Question": "机器学习k近邻算法算出结果不对\n输入代码\n\n\n\nfrom numpy import *\nimport operator\n\ndef createDataSet():\n    group = array([[ 1.0, 1.1],[ 1.0, 1.0],[0,0],[0, 0.1]])\n    labels = ['A','A','B','B']\n    return group, labels\n\ndef classify0(inX,dataSet,labels,k):\n    dataSetSize = dataSet.shape[0]\n    #❶（以下三行）距离计算\n    diffMat = tile(inX,(dataSetSize,1)) - dataSet\n    sqDiffMat = diffMat**2\n    sqDistances=sqDiffMat.sum(axis=1)\n    distances = sqDistances**0.5\n    sortedDistIndicies=distances.argsort()\n    classCount={}\n    #❷（以下两行）选择距离最小的k个点\n    for i in range(k):\n        voteIlabel = labels[sortedDistIndicies[i]]\n        classCount[voteIlabel] = classCount.get(voteIlabel,0)+1\n        #❸排序\n        sortedClassCount = sorted(classCount.items(),key=operator.itemgetter(1), reverse=True)\n        return sortedClassCount[0][0]\n\ndef file2matrix(filename):\n    fr = open(filename)\n    arrayOlines= fr.readlines()\n    numberOfLines = len(arrayOlines) #❶ 得到文件行数\n    returnMat = zeros((numberOfLines,3)) #❷ 创建返回的Numpy 矩阵 classLabelVector = []\n    classLabelVector = []\n    index = 0\n    #❸ （以下三行）解析文件数据到列表\n    for line in arrayOlines:\n        line = line.strip()\n        listFromLine = line.split('\\t')\n        returnMat[index,:] = listFromLine[0:3]\n        classLabelVector.append(int(listFromLine[-1]))\n        index += 1\n    return returnMat,classLabelVector\n\n\n\n\n\n错误执行结果\n\n\n\n>>> datingDataMat\narray([[4.092000e+04, 8.326976e+00, 9.539520e-01],\n       [0.000000e+00, 0.000000e+00, 0.000000e+00],\n       [0.000000e+00, 0.000000e+00, 0.000000e+00],\n       ...,\n       [0.000000e+00, 0.000000e+00, 0.000000e+00],\n       [0.000000e+00, 0.000000e+00, 0.000000e+00],\n       [0.000000e+00, 0.000000e+00, 0.000000e+00]])\n>>> datingLabels[0:20]\n[3]\n\n\n\n\n\n正确的应该是\n\n\n\n>>> datingDataMat \narray([[ 7. 29170000e+ 04, 7. 10627300e+ 00, 2. 23600000e- 01], \n[ 1. 42830000e+ 04, 2. 44186700e+ 00, 1. 90838000e- 01], \n[ 7. 34750000e+ 04, 8. 31018900e+ 00, 8. 52795000e- 01], \n..., \n[ 1. 24290000e+ 04, 4. 43233100e+ 00, 9. 24649000e- 01], \n[ 2. 52880000e+ 04, 1. 31899030e+ 01, 1. 05013800e+ 00], \n[ 4. 91800000e+ 03, 3. 01112400e+ 00, 1. 90663000e- 01]]) \n>>> datingLabels[ 0: 20] \n[3, 2, 1, 1, 1, 1, 3, 3, 1, 3, 1, 1, 2, 1, 1, 1, 1, 1, 2, 3]\n\n\n\n\n\n请大佬看下哪里出错了", "Tag": "算法分析"}
{"Answer": "\nOk, after much deliberation, I decided to go the \"sort every column\" route.\nFor future reference by anyone interested, here's the function I've added to my class - it's called once per every column I need ranked:\n   private function calculateRankings(&$employees, $columnName) {\n        $comparer = \"return (\\$a[$columnName][0] == \\$b[$columnName][0]) ? 0 :  (\\$a[$columnName][0] > \\$b[$columnName][0] ? -1 : 1);\";\n        usort($employees, create_function('$a,$b', $comparer));\n        foreach($employees as $key => &$employee) {\n            $employee[$columnName][1] = $key + 1;\n        }\n    }\n\nThe +1 is due to the keys being zero-based. \nYou prepare for this function by turning each field you need ranked into a 2-element array: the first ([0]) contains the value, and the second ([1]) will contain the rank in the end.\nI.e.: $employees['salary'] = array(1550, 0);.\nYou then call the function like this:\n$this->calculateRankings($employees, 'salary');.\nI sincerely hope this helps someone, someday. Thanks to all responders/commenters!\nUPDATE 4/9: The function I supplied before couldn't work - there's no way to pass a third parameter (in our case, the column name) into the comparer function. The only way to do it is to use a static class variable, or a create_function hack that I ended up with. Sorry for any confusion.\n", "Konwledge_Point": "算法与数字", "Question": "高效排名算法（PHP）\n\n\n\nI have a PHP array (retrieved from a DB) of employees calculated data. There are about 10 columns per employee, 8 of them numerical (the other 2 are id and name). Here's a short sample: \n\n\n\n\nDavid: 1024, 75,  22  \nMike:  500,  100, 25  \nJeff:  700,  82,  10  \n\n\n\n\nI can easily sort the array on any of the (numerical) fields to show who's at the top/bottom, but what I'd really like to show in the final table view is ranking by the value, so people won't have to sort and re-sort the table to get what they want. Here's an example of the table sorted by the first column, showing rankings in parentheses:\n\n\n\n\nDavid: 1024 (#1), 75  (#3), 22 (#2)  \nJeff:  700  (#2), 82  (#2), 10 (#3)  \nMike:  500  (#3), 100 (#1), 25 (#1)  \n\n\n\n\nNow, I know the easiest approach is just to sort the table by column, use the row indexes as the ranking and repeat per every column. I just wondered if I could find a more efficient way.\n\n\n\nI thought about using ordered queues (one per column that needs ranking), scanning the array once and pushing values into the queues. But:\n\n\n\n\n\nPHP does not have any data structures other than arrays (unless you use external additions)  \n\n\nI'm not convinced this is more efficient.\n\n\n\n\nCould anyone please suggest the best approach, and/or confirm I should just re-sort the array several times?\n\n\n\nThanks for your time!\n\n    ", "Tag": "算法分析"}
{"Answer": "1 可以参考我的一篇博文\r\nhttp://robblog.iteye.com/admin/blogs/566114\r\n使用堆排序进行多路数组合并。\r\n\r\n2 \r\n\tpublic static char[] reverseStr(final char[] oriStr) {\r\n\t\tchar[] ret = new char[oriStr.length];\r\n\t\tfor (int i = 0; i < oriStr.length; i++)\r\n\t\t\tret[i] = oriStr[oriStr.length - i - 1];\r\n\t\treturn ret;\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tchar[] oriStr = { 'b', 'c', 'd', 'a', 'f' };\r\n\t\tSystem.out.println(reverseStr(oriStr));\r\n\t}\r\n\r\n3 说下思路\r\n使用一个数组保存进入队列的值，分别用两个变量保存队头和队尾，需要考虑：\r\n - 入队： 在队尾插入元素，队尾加1\r\n - 出队： 返回队头，队头加1\r\n - 空队列： 队头索引和队尾索引相同\r\n - 数组扩张和缩小： 由于数组定义时必须指定长度，可以先指定一个长度，当队列中的元素个数将要大于这个长度是，扩张数组，队列长度过小时缩小数组。如果扩张数组： 可以参考ArrayList中的实现。", "Konwledge_Point": "算法与数字", "Question": "java高级算法问题求解 牛人请进\n1）N个已经排序好的数组，每个数组有M个数字，给出一个算法把这N个数组合并成一个排好序的大数组，并分析该算法的时间和空间复杂度。\n\n\n\n2）写一个Java函数最高效的实现字符串倒序（不能直接使用类库API）。\n\n\n\n3）用Java数组实现一个先进先出的Queue。", "Tag": "算法分析"}
{"Answer": "有一个三位数，个位数字比百位数字大，而百位数字又比十位数字大，并且各位数字之和等于各位数字相乘之积，此三位数的结果是先得到各位数字，判断和与积是否相等，相等再比较三个数大小\nvoid main();\n{\n  for(int i=100;i<1000;i++)\n  {\n    int a = i/100;\n    int c = i%10;\n    int b = (i-a*100-c)/10;\n    if(a*b*c == a+b+c && a>b && b>c)\n      printf(\"这个数是:%d\\n\",i);\n  }\n}\n", "Konwledge_Point": "算法与数字", "Question": "请问如何用代码解决以下问题？\n大佬们，请问如何用代码解决以下问题？\n有一个三位数，个位数字比百位数字大，而百位数字又比十位数字大，并且各位数字之和等于各位数字相乘之积，此三位数的结果是", "Tag": "算法分析"}
{"Answer": "java 写的, 其实就是递归....\r\n\r\npackage demo;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\n/**\r\n * @author yeyong\r\n */\r\npublic class Test24 {\r\n\r\n  public static void main(String args[]) {\r\n    int a = 100;\r\n    int b = 200;\r\n    int c = 300;\r\n\r\n    String A = \"a+b\"; // 300\r\n    String B = \"A+b\"; // 500\r\n    String C = \"A+B\"; // 800\r\n    String D = \"C+A+b\"; // 1300\r\n\r\n    Map context = new HashMap();\r\n    context.put(\"a\", a);\r\n    context.put(\"b\", b);\r\n    context.put(\"c\", c);\r\n    context.put(\"A\", A);\r\n    context.put(\"B\", B);\r\n    context.put(\"C\", C);\r\n    context.put(\"D\", D);\r\n\r\n    System.out.println(\"D = \" + getVarValue(context, \"D\"));\r\n    System.out.println(\"data : \" + context);\r\n  }\r\n\r\n  private static int getVarValue(Map data, String var) {\r\n    Object o = data.get(var);\r\n    if (o instanceof Integer) {\r\n      return (Integer) o;\r\n    } else if (o instanceof String) {\r\n      String exp = (String) o;\r\n      int sum = 0;\r\n      for (String v : exp.split(\"\\\\s*\\\\+\\\\s*\")) {\r\n        int value = getVarValue(data, v);\r\n        sum += value;\r\n      }\r\n      data.put(var, sum);\r\n      return sum;\r\n    }\r\n    throw new RuntimeException(\"ERROR\");\r\n  }\r\n}", "Konwledge_Point": "算法与数字", "Question": "求一个算法问题...分数不够可以再加...\n \n\n\n\n \n\n\n\n有如下2组数据\n\n\n\n  int a=100;\n  int b=200;\n  int c=300;\n\n\n\n \n\n\n\n  String A=\"a+b\";\n  String B=\"A+b\";\n  String C=\"A+B\";\n  String D=\"C+A+b\";\n\n\n\n \n\n\n\n \n\n\n\n即B的结果为..A+b也就是a+b+b=600;以此为算法.算出D的计算结果.\n\n\n\n..要求.大写字母的计算过程只能有一次.\n\n\n\n比如说.D,,应该为A+B+A+b; 其中第一次算出了A..则下面的A直接引用其值便可..不需再算.\n\n\n\nD算出来了..则D包含的子项.C,A,B的结果都要算出来.而且要保留..以便如果有E产生..则可直接引用.\n\n\n\n注意..大小写字母的项目都有很多.\n\n\n\n \n\n\n\n此题为我用JAVA转换过来的..\n\n\n\n原本是一张数据库表..本来是要求用存储过程..函数.或者sql算的..\n\n\n\n \n\n\n\n如附件所示:\n\n\n\n \n\n\n\n其实也就是在算D的过程中把其中包含的子项..求出来..并赋值到.val...以便下一个公式可能用到..\n\n\n\n \n\n\n\n因考虑效率问题..\n\n\n\n每一个大写字母只能算一次..\n\n\n\n \n\n\n\n \n\n\n\n \n\n\n\n ", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/effective_coder/article/details/8736718", "Konwledge_Point": "算法与数字", "Question": "请问哪位大神可以帮忙解决一个算法题？\n具体内容如下:用贪心法解决多仓库 ，( 每个仓库)多库位，库存商品多品牌的出库调度问题", "Tag": "算法分析"}
{"Answer": "http://blog.sina.com.cn/s/blog_7e1aec770100r4fb.html\r\njava的你自己改改", "Konwledge_Point": "算法与数字", "Question": "基于优先级的时间片轮转调度算法\n求一个基于优先级的时间片轮转调度算法。实在是不太会做了，没思路。要求java\n\n要求：\n\n（1）设系统中有n个进程，每个进程PCB格式如下：\n\n进程ID；\n\n进程名称：p1,..., pn；\n\n进程状态：1-运行，2-就绪，3-等待，0-完成；\n\n进程类型：0-系统进程，1-用户进程；\n\n请求资源时刻；\n\n需要的CPU时间；\n\n已运行时间；\n\n优先级：数字小的优先级高；\n\n指向下一进程的指针。\n\n（2）在调度程序运行之前，输入进程名称、所需CPU时间等。\n\n（3）设计4个队列，完成队列，运行队列，就绪队列和等待队列。\n\n（4）调度程序选择就绪队列首进程运行，采用时间片轮转法，输出调度过程。", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/ESESZB/article/details/52004669", "Konwledge_Point": "算法与数字", "Question": "这个关于数字搜索和输出的算法，用c语言怎么实现会比较效率高\nProblem Description\n\nThere are n numbers A1,A2....An,your task is to check whether there exists there different positive integers i, j, k (1≤i,j,k≤n) such that Ai−Aj=Ak\n\n\n\nInput\n\nThere are multiple test cases, no more than 1000 cases.\n\nFirst line of each case contains a single integer n.(3≤n≤100).\n\nNext line contains n integers A1,A2....An.(0≤Ai≤1000)\n\n\n\nOutput\n\nFor each case output \"YES\" in a single line if you find such i, j, k, otherwise output \"NO\".\n\n\n\nSample Input\n\n3\n\n3 1 2\n\n3\n\n1 0 2\n\n4\n\n1 1 0 2\n\n\n\nSample Output\n\nYES\n\nNO\n\nYES", "Tag": "算法分析"}
{"Answer": "你这个代码跟题目的要求不太符合，主要修改了一下LinkList_createR函数和main函数中的调用，运行结果：\n\n代码修改如下：\n#include<stdio.h>\n#include<stdlib.h>\n#define N 10\ntypedef int SLTDateType;\ntypedef struct Node\n{\n    SLTDateType date;\n    struct Node *next;\n}Node,*LinkList;\nSLTDateType LinkList_Init(LinkList &L)\n{\n    L=(LinkList)malloc(sizeof(Node));\n    if(L==NULL)\n        exit(-1);\n    L->next=NULL;\n    return 1;\n}\nvoid LinkList_createR(LinkList L)  //,i)\n{\n    int x;\n    char ch;\n    Node *p,*r;\n    r=L;\n\n    while(1)\n    {\n        p=(LinkList)malloc(sizeof(Node));\n        p->next = NULL;\n        scanf(\"%d\",&p->date);\n        r->next = p; //p插入链表末尾\n        r = p;\n        ch = getchar();\n        if(ch == '\\n')\n            break;\n    }\n\n    scanf(\"%d\",&x);//读取x\n    p = L;\n    while(p->next)\n    {\n        if(p->next->date == x)\n        {\n            r = p->next;\n            p->next = r->next;\n            free(r);\n        }else\n            p = p->next;\n    }\n}\nvoid LinkList_print(LinkList L)\n{\n    Node *p;\n    p=L->next;\n    while(p)\n    {\n        printf(\"%d \",p->date);\n        p=p->next;\n    }\n    printf(\"\\n\");\n}\n\nint main()\n{\n    LinkList L;\n    int i;\n    int n=N;\n    LinkList_Init(L);\n    LinkList_createR(L);//,N);\n    //printf(\"%d\");\n    LinkList_print(L);\n    return 0;\n}\n\n", "Konwledge_Point": "算法与数字", "Question": "有一个整数单链表L，涉及一个算法删除其中所有值为x的结点。\n有一个整数单链表L，涉及一个算法删除其中所有值为x的结点。\n输入格式:\n第一行，直接给出相关的输入（整形），数据间英文字符的空格，最后回车结束输入。\n第二行，给出要删除的数字（整形）。\n输出格式:\n输出整形结果，数据间一个英文空格隔开。\n1.输入样例:\n1 2 2 3 1\n2\n1.输出样例:\n1 3 1\n2.输入样例:\n1 3 5 5 5 4 2 1 6 7 5 4 1\n5\n2.输出样例:\n1 3 4 2 1 6 7 4 1\n\n\n在成功构建单链表之后应该怎么做呢？\n\n\n本人代码：\n#include\n#include\n#define N 10\ntypedef int SLTDateType;\ntypedef struct Node\n{\n    SLTDateType date;\n    struct Node *next;\n}Node,*LinkList;\nSLTDateType LinkList_Init(LinkList &L)\n{\n    L=(LinkList)malloc(sizeof(Node));\n    if(L==NULL)\n        exit(-1);\n    L->next=NULL;\n    return 1;\n}\nvoid LinkList_createR(LinkList L,int n)\n{\n    int i;\n    Node *p,*r;\n    r=L;\n    scanf(\"%d\",n);\n    for(i=0;idate);\n        p->next=NULL;\n        r->next=p;\n        r=p;\n    }\n}\nvoid LinkList_print(LinkList L)\n{\n   Node *p;\n   p=L->next;\n   while(p)\n   {\n       printf(\"%d \",p->date);\n       p=p->next;\n   }\n   printf(\"\\n\");\n}\n\n\nint main()\n{\n    LinkList L;\n    int i;\n    int n=N;\n    LinkList_Init(L);\n    LinkList_createR(L,N);\n    printf(\"%d\");\n    LinkList_print(L);\n    return 0;\n}", "Tag": "算法分析"}
{"Answer": "我写了一个，但是感觉没那么满意\r\n```\r\n public class Red {\r\n\tprivate int remain;//金额，单位厘\r\n\tprivate int count;//个数\r\n\tprivate Precision precision;//精度\r\n\tprivate int max;//上限，单位厘 \r\n\tprivate int min;//下限，单位厘\r\n\tprivate int[] redPool;\r\n\tprivate int index;\r\n\t\r\n\tpublic static void main(String[] args) {\r\n\t\tint count = 100;\r\n\t\tRed red = Red.newInstance(10 * 1000, count, Precision.FEN, 1 * 1000, 5 * Precision.FEN.getPre());\r\n\t\tint sum = 0;\r\n\t\tfor (int i = 0; i < count; i++) {\r\n\t\t\tint money = red.getRed();\r\n\t\t\tsum += money;\r\n\t\t\tSystem.out.println(money);\r\n\t\t}\r\n\t\tSystem.out.println(\"---------------\" + sum);\r\n\t}\r\n\t\r\n\tpublic int getRed() {\r\n\t\treturn index < count ? redPool[index++] : 0;\r\n\t}\r\n\t\r\n\tpublic static Red newInstance(int money, int count, Precision precision, int max, int min) {\r\n\t\tRed red = new Red(money, count, precision, max, min);\r\n\t\tString msg;\r\n\t\tif (\"\".equals(msg = red.validate())) return red;\r\n\t\telse throw new RuntimeException(msg);\r\n\t}\r\n\t\r\n\tprivate Red(int money, int count, Precision precision, int max, int min) {\r\n\t\tthis.remain = money;\r\n\t\tthis.count = count;\r\n\t\tthis.precision = precision;\r\n\t\tthis.max = max;\r\n\t\tthis.min = min;\r\n\t\tinit();\r\n\t}\r\n\r\n\tprivate void init() {\r\n\t\tredPool = new int[count];\r\n\t\tint remain_ = remain;\r\n\t\tfor (int i = 0; i < count - 1; i++) {\r\n\t\t\tint max = getRealMax(remain_, count - i);\r\n\t\t\tint min = getRealMin(remain_, count - i);\r\n\t\t\tint money = ((int)(Math.random() * (max - min + precision.getPre())) + min) \r\n\t\t\t\t\t/ precision.getPre() * precision.getPre();//[min, realMax]\r\n\t\t\tremain_ -= money;\r\n\t\t\tredPool[i] = money;\r\n\t\t}\r\n\t\tredPool[count - 1] = remain_;\r\n\t\trandomPool();\r\n\t}\r\n\t\r\n\tprivate void randomPool() {\r\n\t\tfor (int i = 0; i < count; i++) {\r\n\t\t\tint index = (int) (Math.random() * count);\r\n\t\t\tint temp = redPool[i];\r\n\t\t\tredPool[i] = redPool[index];\r\n\t\t\tredPool[index] = temp;\r\n\t\t}\r\n\t}\r\n\r\n\tprivate int getRealMax(int remain, int count) {\r\n\t\tint calMax = remain - ((count - 1) * min);\r\n\t\treturn Math.min(calMax, max);\r\n\t}\r\n\t\r\n\tprivate int getRealMin(int remain, int count) {\r\n\t\tint calMin = remain - ((count - 1) * max);\r\n\t\treturn Math.max(calMin, min);\r\n\t}\r\n\t\r\n\tpublic int getRemain() {\r\n\t\treturn remain;\r\n\t}\r\n\r\n\tpublic void setRemain(int remain) {\r\n\t\tthis.remain = remain;\r\n\t}\r\n\r\n\tpublic int getCount() {\r\n\t\treturn count;\r\n\t}\r\n\r\n\tpublic void setCount(int count) {\r\n\t\tthis.count = count;\r\n\t}\r\n\r\n\tpublic int getMax() {\r\n\t\treturn max;\r\n\t}\r\n\r\n\tpublic void setMax(int max) {\r\n\t\tthis.max = max;\r\n\t}\r\n\r\n\tpublic int getMin() {\r\n\t\treturn min;\r\n\t}\r\n\r\n\tpublic void setMin(int min) {\r\n\t\tthis.min = min;\r\n\t}\r\n\r\n\tpublic Precision getPrecision() {\r\n\t\treturn precision;\r\n\t}\r\n\r\n\tpublic void setPrecision(Precision precision) {\r\n\t\tthis.precision = precision;\r\n\t}\r\n\t\r\n\tprivate String validate() {\r\n\t\tString msg = \"\";\r\n\t\tif (remain <= 0) {\r\n\t\t\tmsg = \"余额不能为0\";\r\n\t\t} else if (remain % precision.getPre() != 0) {\r\n\t\t\tmsg = \"余额的精度不对\";\r\n\t\t} else if (count <= 0) {\r\n\t\t\tmsg = \"红包个数必须为正数\";\r\n\t\t} else if (max % precision.getPre() != 0) {\r\n\t\t\tmsg = \"上限的精度不对\";\r\n\t\t} else if (max <= min) {\r\n\t\t\tmsg = \"上限必须大于下限\";\r\n\t\t} else if (min % precision.getPre() != 0) {\r\n\t\t\tmsg = \"下限的精度不对\";\r\n\t\t} else if (min <= 0) {\r\n\t\t\tmsg = \"下限必须大于0\";\r\n\t\t} else if (getRealMax(remain, count) < getRealMin(remain, count)) {\r\n\t\t\tmsg = \"上下限设置错误\";\r\n\t\t}\r\n\t\treturn msg;\r\n\t}\r\n\t\r\n}\r\nenum Precision {\r\n\tLI(1),\r\n\tFEN(10),\r\n\tJIAO(100),\r\n\tYUAN(1000);\r\n\t\r\n\tprivate int pre;\r\n\tprivate Precision(int pre) {\r\n\t\tthis.pre = pre;\r\n\t}\r\n\tpublic int getPre() {\r\n\t\treturn pre;\r\n\t}\r\n}\r\n```", "Konwledge_Point": "算法与数字", "Question": "使用java进行红包分配算法\n公司有个红包分发业务模块，需要红包随机生成金额，克提供参数为：\n\n1、红包金额（最小精确到厘：0.001，数据库是用int表示，1元也就是1000厘）\n\n2、红包发放数量\n\n3、红包金额上限\n\n4、红包金额下限\n\n5、金额精度（精度可以理解为随机数能精确到小数哪一位，如范围为：0.01~0.5，如果精确到分的随机数为0.34 or 0.340，如果精确到厘：0.345）\n\n\n\n1,2,3,4,5都可以由用户输入或选择，程序可进行判断是否参数不符计算，意思就是：\n\n如果金额为10元，数量为10个，上限就不能大于10-0.001*9=9.991之类的\n\n而且，金额是随用户输入，没有限制10的倍数或者100的倍数，可能会是2546\n\n数量也是由用户输入，也可能为3254等不规则数字\n\n需要程序使用用户金额生成在上限下限范围内随机缺固定的数量的红包个数，我想了好久了\n\n由于数学比较差，而且红包金额可以根据精度调控后面小数位数", "Tag": "算法分析"}
{"Answer": "", "Konwledge_Point": "算法与数字", "Question": "算法 一个特殊的数字 怎么缩短运行时间\n一个特殊的数字，可以分成左右两部分，并且左右两部分相同，如11，2020。但202，2112不算特殊的数。求1到n中有多少个特殊的数\n输入:n\n案例:\n输入22\n输出:2\n因为11，22是特殊的数\n范围n≤1e19", "Tag": "算法分析"}
{"Answer": "http://www.apkbus.com/android-124533-1-1.html", "Konwledge_Point": "算法与数字", "Question": "安卓图像识别算法推荐\n我想做一个安卓app，能通过摄像头识别数字和字幕，求推荐相关算法", "Tag": "算法分析"}
{"Answer": "guess=0\r\na1=0\r\na2=1\r\na3=2\r\na4=3\r\na=[a1,a2,a3,a4]\r\nb1=0\r\nb2=1\r\nb3=2\r\nb4=3\r\nb=[b1,b2,b3,b4]\r\ndef A(guess):\r\nA=0\r\nif a1==b1:\r\nA=A+1\r\nif a2==b2:\r\nA=A+1\r\nif a3==b3:\r\nA=A+1\r\nif a4==b4:\r\nA=A+1\r\nreturn(A)\r\n\r\ndef B(guess):\r\nB=0\r\nfor i in range(0,4):\r\nfor k in range(0,4):\r\nif a[i]==b[k]:\r\nB=B+1\r\nreturn(B)\r\n\r\ne=[i for i in range(1,10000)]\r\nfor i in range(0,9999):\r\nb1=int(e[(9998-i)]/1000)\r\nb2=int((e[(9998-i)]-1000*b1)/100)\r\nb3=int((e[(9998-i)]-1000*b1-100*b2)/10)\r\nb4=int(e[(9998-i)]-1000*b1-100*b2-10*b3)\r\nif b1==b2 or b1==b3 or b1==b4 or b2==b3 or b2==b4 or b3==b4:\r\ndel(e[9998-i])\r\nf=len(e)\r\n\r\ndef number(e):\r\nq=10000\r\np=0\r\nf=len(e)\r\nfor g in range(0,f):\r\nguess=e[g]\r\na1=int(e[g]/1000)\r\na2=int((e[g]-1000*a1)/100)\r\na3=int((e[g]-1000*a1-100*a2)/10)\r\na4=int(e[g]-1000*a1-100*a2-10*a3)\r\na=[a1,a2,a3,a4]\r\nj=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\r\nfor h in range(0,f):\r\nb1=int(e[h]/1000)\r\nb2=int((e[h]-1000*b1)/100)\r\nb3=int((e[h]-1000*b1-100*b2)/10)\r\nb4=int(e[h]-1000*b1-100*b2-10*b3)\r\nb=[b1,b2,b3,b4]\r\nj[int((B(guess)+1)*B(guess)/2+A(guess))]=j[int((B(guess)+1)*B(guess)/2+A(guess))]+1\r\nif q>max(j):\r\nq=max(j)\r\np=e[g]\r\nreturn(p)\r\n\r\nfor i in range(1,8):\r\nif i ==1:\r\nprint('第',i,'轮')\r\nprint('电脑给出的数字是')\r\nprint(e[0])\r\nc=int(input('数字与位置都猜对的数量'))\r\nd=int(input('猜对数字的数量'))\r\nif (c==4):\r\nbreak\r\na1=int(e[0]/1000)\r\na2=int((e[0]-1000*a1)/100)\r\na3=int((e[0]-1000*a1-100*a2)/10)\r\na4=int(e[0]-1000*a1-100*a2-10*a3)\r\na=[a1,a2,a3,a4]\r\nfor k in range(0,f):\r\nguess=e[f-1-k]\r\nb1=int(guess/1000)\r\nb2=int((guess-1000*b1)/100)\r\nb3=int((guess-1000*b1-100*b2)/10)\r\nb4=int(guess-1000*b1-100*b2-10*b3)\r\nb=[b1,b2,b3,b4]\r\nif A(guess)!=c or B(guess)!=d:\r\ndel(e[f-1-k])\r\nf=len(e)\r\nif i>1:", "Konwledge_Point": "算法与数字", "Question": "猜数字python代码，画流程图，关键地方的流程图即可\nguess=0\n\na1=0\n\na2=1\n\na3=2\n\na4=3\n\na=[a1,a2,a3,a4]\n\nb1=0\n\nb2=1\n\nb3=2\n\nb4=3\n\nb=[b1,b2,b3,b4]\n\ndef A(guess):\n\n    A=0\n\n    if a1==b1:\n\n        A=A+1\n\n    if a2==b2:\n\n        A=A+1\n\n    if a3==b3:\n\n        A=A+1\n\n    if a4==b4:\n\n        A=A+1\n\n    return(A)\n\n\n\ndef B(guess):\n\n    B=0\n\n    for i in range(0,4):\n\n        for k in range(0,4):\n\n            if a[i]==b[k]:\n\n                B=B+1\n\n    return(B)\n\n\n\ne=[i for i in range(1,10000)]\n\nfor i in range(0,9999):\n\n    b1=int(e[(9998-i)]/1000)\n\n    b2=int((e[(9998-i)]-1000*b1)/100)\n\n    b3=int((e[(9998-i)]-1000*b1-100*b2)/10)\n\n    b4=int(e[(9998-i)]-1000*b1-100*b2-10*b3)\n\n    if b1==b2 or b1==b3 or b1==b4 or b2==b3 or b2==b4 or b3==b4:\n\n        del(e[9998-i])\n\n    f=len(e)\n\n\n\ndef number(e):\n\n    q=10000\n\n    p=0\n\n    f=len(e)\n\n    for g in range(0,f):\n\n        guess=e[g]\n\n        a1=int(e[g]/1000)\n\n        a2=int((e[g]-1000*a1)/100)\n\n        a3=int((e[g]-1000*a1-100*a2)/10)\n\n        a4=int(e[g]-1000*a1-100*a2-10*a3)\n\n        a=[a1,a2,a3,a4]\n\n        j=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n\n        for h in range(0,f):\n\n            b1=int(e[h]/1000)\n\n            b2=int((e[h]-1000*b1)/100)\n\n            b3=int((e[h]-1000*b1-100*b2)/10)\n\n            b4=int(e[h]-1000*b1-100*b2-10*b3)\n\n            b=[b1,b2,b3,b4]\n\n            j[int((B(guess)+1)*B(guess)/2+A(guess))]=j[int((B(guess)+1)*B(guess)/2+A(guess))]+1\n\n        if q>max(j):\n\n            q=max(j)\n\n            p=e[g]\n\n    return(p)\n\n\n\nfor i in range(1,8):\n\n    if i ==1:\n\n        print('第',i,'轮')\n\n        print('电脑给出的数字是')\n\n        print(e[0])\n\n        c=int(input('数字与位置都猜对的数量'))\n\n        d=int(input('猜对数字的数量'))\n\n        if (c==4):\n\n            break\n\n        a1=int(e[0]/1000)\n\n        a2=int((e[0]-1000*a1)/100)\n\n        a3=int((e[0]-1000*a1-100*a2)/10)\n\n        a4=int(e[0]-1000*a1-100*a2-10*a3)\n\n        a=[a1,a2,a3,a4]\n\n        for k in range(0,f):\n\n            guess=e[f-1-k]\n\n            b1=int(guess/1000)\n\n            b2=int((guess-1000*b1)/100)\n\n            b3=int((guess-1000*b1-100*b2)/10)\n\n            b4=int(guess-1000*b1-100*b2-10*b3)\n\n            b=[b1,b2,b3,b4]\n\n            if A(guess)!=c or B(guess)!=d:\n\n                 del(e[f-1-k])\n\n        f=len(e)\n\n    if i>1:\n\n\n\n    print('第',i,'轮')\n    print('电脑给出的数字是')\n    print(number(e))\n    c=int(input('数字与位置都猜对的数量'))\n    d=int(input('猜对数字的数量'))\n    if (c==4):\n        break\n    a1=int(number(e)/1000)\n    a2=int((number(e)-1000*a1)/100)\n    a3=int((number(e)-1000*a1-100*a2)/10)\n    a4=int(number(e)-1000*a1-100*a2-10*a3)\n    a=[a1,a2,a3,a4]\n    for k in range(0,f):\n        guess=e[f-1-k]\n        b1=int(guess/1000)\n        b2=int((guess-1000*b1)/100)\n        b3=int((guess-1000*b1-100*b2)/10)\n        b4=int(guess-1000*b1-100*b2-10*b3)\n        b=[b1,b2,b3,b4]\n        if A(guess)!=c or B(guess)!=d:\n            del(e[f-1-k])\n\n    f=len(e)\n", "Tag": "算法分析"}
{"Answer": "程序很长，基本没人会给你调试找错误的。会花费很长时间。\r\n建议你自己学会调试程序，掌握设置断点，查看变量，单步执行等手段。\r\n怀疑是哪里出了问题，就单步执行去试试。", "Konwledge_Point": "算法与数字", "Question": "c语言扫雷算法有问题求助\n自己写了个控制台的扫雷\n\n输入坐标然后显示地图\n\n但是输入某些坐标的时候卡住不动了 不知道是陷入死循环还是什么问题\n\n求大神解答         已考虑无雷区自动翻开的死循环  可能是双击时陷入死循环 但看不出是不是这个问题 不知道怎么修改代码\n\n\n\n#include \n\n#include \n\n#include \n\n#include \n\n\n\n#define len 20                          //边数\n\nint mine[len+2][len+2] = {0};                 //+2是为了在计算周围一圈雷数时不必分四周顶点边界区域，不越界\n\nint dispMine[len+2][len+2] = {0};          //记录当前格子状态：0为未点开、1为已点开、2为双击、3为插旗、4为周围一圈无雷自动翻开\n\nint endindex = 0;                     //点击到地雷的结束标志\n\nint mines = 0;                       //记录已排除的地雷数\n\n\n\nvoid SetMine(int n)        //布雷\n\n{\n\n    srand(time(0));\n\n    int k, row, col;\n\n    if(n == 1)             //初级难度\n\n        k = 25;\n\n    else if(n == 2)         //中级难度\n\n        k = 50;\n\n    else                   //高级难度\n\n        k = 75;\n\n    mines = k;\n\n    while(k)\n\n    {\n\n        row = rand() % len + 1;              //+1是为了将地雷分布在除四边以外的区域     显示地图时实际只显示中间部分 不显示四周\n\n        col = rand() % len + 1;\n\n        if(!mine[row][col])\n\n        {\n\n            mine[row][col] = 9;\n\n            k--;\n\n        }\n\n    }\n\n}\n\n\n\nvoid round(int mine[][len+2], int x, int y)\n\n{\n\n    int k = 0;   //地雷数\n\n    if(mine[x][y] == 9 && dispMine[x][y] != 3)  //点击到地雷\n\n        endindex++;\n\n    else \n\n    {\n\n        if(mine[x][y+1] == 9)             //计算周围一圈是否有雷\n\n            k++;\n\n        if(mine[x+1][y+1] == 9)\n\n            k++;\n\n        if(mine[x+1][y] == 9)\n\n            k++;\n\n        if(mine[x+1][y-1] == 9)\n\n            k++;\n\n        if(mine[x][y-1] == 9)\n\n            k++;\n\n        if(mine[x-1][y-1] == 9)\n\n            k++;\n\n        if(mine[x-1][y] == 9)\n\n            k++;\n\n        if(mine[x-1][y+1] == 9)\n\n            k++;\n\n        mine[x][y] = k;                  //记录当前位置地雷数\n\n    }\n\n\n\n}\n\n\n\nvoid open(int mine[][len+2], int x, int y)           //翻开\n\n{\n\n    if(mine[x][y] == 9)                          //点击到雷直接返回\n\n        return;\n\n    if(dispMine[x][y] == 3)                //输入坐标位置为插旗的位置\n\n        return;\n\n    if(mine[x][y] == 0)                    //无雷区自动翻开\n\n    { \n\n        dispMine[x][y] = 4;                 //无雷区标志为4\n\n        if(x != 1 && y != 1)                //考虑各个特殊位置的坐标\n\n        {\n\n            round(mine, x-1, y-1);\n\n            if(!mine[x-1][y-1] && dispMine[x-1][y-1] != 4)            //若无雷自动翻开区域里又有无雷区 继续自动翻开 为了防止死循环\n\n                open(mine, x-1, y-1);                                                                          //要标志已翻开的\n\n            else if(mine[x-1][y-1] && !dispMine[x-1][y-1])       //若是周围一周有雷的，则直接显示，标志为1\n\n                dispMine[x-1][y-1] = 1;\n\n        }\n\n        if(x != 1 && y != len)\n\n        {\n\n            round(mine, x-1, y+1);\n\n            if(!mine[x-1][y+1] && dispMine[x-1][y+1] != 4)\n\n                open(mine, x-1, y+1);\n\n            else if(mine[x-1][y+1] && !dispMine[x-1][y+1])\n\n                dispMine[x-1][y+1] = 1;\n\n        }\n\n        if(x != len && y != 1)\n\n        {\n\n            round(mine, x+1, y-1); \n\n            if(!mine[x+1][y-1] && dispMine[x+1][y-1] != 4)\n\n                open(mine, x+1, y-1);\n\n            else if(mine[x+1][y-1] && !dispMine[x+1][y-1])\n\n                dispMine[x+1][y-1] = 1;\n\n        }\n\n        if(x != len && y != len)\n\n        {\n\n            round(mine, x+1, y+1);\n\n            if(!mine[x+1][y+1] && dispMine[x+1][y+1] != 4)\n\n                open(mine, x+1, y+1);\n\n            else if(mine[x+1][y+1] && !dispMine[x+1][y+1])\n\n                dispMine[x+1][y+1] = 1;\n\n        }\n\n        if(x != 1)\n\n        {\n\n            round(mine, x-1, y);\n\n            if(!mine[x-1][y] && dispMine[x-1][y] != 4)\n\n                open(mine, x-1, y);\n\n            else if(mine[x-1][y] && !dispMine[x-1][y])\n\n                dispMine[x-1][y] = 1;\n\n        }\n\n        if(x != len)\n\n        {\n\n            round(mine, x+1, y);\n\n            if(!mine[x+1][y] && dispMine[x+1][y] != 4)\n\n                open(mine, x+1, y);\n\n            else if(mine[x+1][y] && !dispMine[x+1][y])\n\n                dispMine[x+1][y] = 1;\n\n        }\n\n        if(y != 1)\n\n        {\n\n            round(mine, x, y-1);\n\n            if(!mine[x][y-1] && dispMine[x][y-1] != 4)\n\n                open(mine, x, y-1);\n\n            else if(mine[x][y-1] && !dispMine[x][y-1])\n\n                dispMine[x][y-1] = 1;\n\n        }\n\n        if(y != len)\n\n        {\n\n            round(mine, x, y+1);\n\n            if(!mine[x][y+1] && dispMine[x][y+1] != 4)\n\n                open(mine, x, y+1);\n\n            else if(mine[x][y+1] && !dispMine[x][y+1])\n\n                dispMine[x][y+1] = 1;\n\n        }\n\n    }\n\n    if(dispMine[x][y] = 2)           //如果双击\n\n    {\n\n        dispMine[x][y] = 1;             //置为已点击防止死循环\n\n        int flag = 0;                  //记录周围一周插旗数\n\n        if(dispMine[x-1][y] == 3)            //若周围有旗子，flag++\n\n            flag++;\n\n        if(dispMine[x-1][y+1] == 3)\n\n            flag++;\n\n        if(dispMine[x][y+1] == 3)\n\n            flag++;\n\n        if(dispMine[x+1][y+1] == 3)\n\n            flag++;\n\n        if(dispMine[x+1][y] == 3)\n\n            flag++;\n\n        if(dispMine[x+1][y-1] == 3)\n\n            flag++;\n\n        if(dispMine[x][y-1] == 3)\n\n            flag++;\n\n        if(dispMine[x-1][y-1] == 3)\n\n            flag++;\n\n        if(mine[x][y] == flag)            //双击的当前位置插旗数与该位置地雷数相同时自动翻开周围一圈未点击的位置\n\n        {\n\n            if(y != len && dispMine[x][y+1] == 0)        //考虑各个特殊位置防止越界以及是否为未翻开位置\n\n            {\n\n                round(mine, x, y+1);\n\n                dispMine[x][y+1] = 1;\n\n                if(!mine[x][y+1])                  //若翻开为无雷区则递归调用\n\n                    open(mine, x, y+1);\n\n            }\n\n            if(x != len && y != len && dispMine[x+1][y+1] == 0)\n\n            {\n\n                round(mine, x+1, y+1);\n\n                dispMine[x+1][y+1] = 1;\n\n                if(!mine[x+1][y+1])\n\n                    open(mine, x+1, y+1);\n\n            }\n\n            if(x != len && dispMine[x+1][y] == 0)\n\n            {\n\n                round(mine, x+1, y);\n\n                dispMine[x+1][y] = 1;\n\n                if(!mine[x+1][y])\n\n                    open(mine, x+1, y);\n\n            }\n\n            if(x != len && y != 1 && dispMine[x+1][y-1] == 0)\n\n            {\n\n                round(mine, x+1, y-1); \n\n                dispMine[x+1][y-1] = 1;\n\n                if(!mine[x+1][y-1])\n\n                    open(mine, x+1, y-1);\n\n            }\n\n            if(y != 1 && dispMine[x][y-1] == 0)\n\n            {\n\n                round(mine, x, y-1);\n\n                dispMine[x][y-1] = 1;\n\n                if(!mine[x][y-1])\n\n                    open(mine, x, y-1);\n\n            }\n\n            if(x != 1 && y != 1 && dispMine[x-1][y-1] == 0)\n\n            {\n\n                round(mine, x-1, y-1);\n\n                dispMine[x-1][y-1] = 1;\n\n                if(!mine[x-1][y-1])\n\n                    open(mine, x-1, y-1);\n\n            }\n\n            if(x != 1 && dispMine[x-1][y] == 0)\n\n            {\n\n                round(mine, x-1, y);\n\n                dispMine[x-1][y] = 1;\n\n                if(!mine[x-1][y])\n\n                    open(mine, x-1, y);\n\n            }\n\n            if(x != 1 && y != len && dispMine[x-1][y+1] == 0)\n\n            {\n\n                round(mine, x-1, y+1);\n\n                dispMine[x-1][y+1] = 1;\n\n                if(!mine[x-1][y+1])\n\n                    open(mine, x-1, y+1);\n\n            }\n\n        }\n\n    }\n\n\n\n}\n\n\n\nvoid chaqi(int x, int y)           //插旗\n\n{\n\n    if(dispMine[x][y] == 3)      //已经插旗的位置再次插旗视为取消插旗\n\n    {\n\n        dispMine[x][y] = 0;       //置为0表示未点击区域\n\n        return;\n\n    }\n\n    else if(dispMine[x][y])        //若该位置已点开则不改变\n\n        return;\n\n    dispMine[x][y] = 3;     //插旗标志为3\n\n\n\n}\n\n\n\nvoid disp(int x, int y)           //显示地图\n\n{\n\n    cout<<\"  \";\n\n    for(int k = 1; k < len+1; k++)\n\n        cout<>rank;\n\n        if(rank < 1 || rank > 3)\n\n            cout<<\"输入有误，请重新输入：\";\n\n        else\n\n        {\n\n            system(\"CLS\");\n\n            break;\n\n        }\n\n    }\n\n    SetMine(rank);\n\n    disp(x, y);\n\n    while(1)\n\n    {\n\n        cout<<\"1.点击  2.插旗  3.双击\"<\n        cout\n        int n;\n\n        while(1)\n\n        {\n\n            cin>>n;\n\n            cin>>x>>y;\n\n            if(n < 1 || n > 3)\n\n            {\n\n                cout<<\"输入有误，请重新输入：\";\n\n                continue;\n\n            }\n\n            else if(x < 1 || x > 20 || y < 1 || y > 20)\n\n            {\n\n                cout<<\"输入有误，请重新输入：\";\n\n                continue;\n\n            }\n\n            break;\n\n        }\n\n\n\n    if(n == 1 || n == 3)\n    {\n        if(n == 3 && dispMine[x][y] == 3)\n            continue;\n        round(mine, x, y);\n        if(dispMine[x][y] < 2)\n            dispMine[x][y]++;       \n        open(mine, x, y);\n\n    }\n    else if(n == 2)\n        chaqi(x, y);\n\n    system(\"CLS\");\n    disp(x, y);\n    if(endindex)\n    {\n        cout<<\"你输了！\"<<endl;\n        break;\n    }   \n    if(win(mines))\n    {\n        cout<<\"你赢了！\"<<endl;\n        break;\n    }\n}\n\n\n\n\n}", "Tag": "算法分析"}
{"Answer": "http://blog.chinaunix.net/uid-24683784-id-3061386.html\r\n按照这个算法看，它应该是4个字节32位，也就是8个16进制数", "Konwledge_Point": "算法与数字", "Question": "ELFHash算法只会生成一个最多8位的数字是吗？\n不太了解hash算法，ELFHash算法每次都最多返回8位的数值是吗？重复数字的概率大不大？\n\n源码：\n\nlong hash = 0;\n\nlong x = 0;\n\nfor(int i = 0; i < str.length(); i++){\n\nhash = (hash << 4) + str.charAt(i);\n\nif((x = hash & 0xF0000000L) != 0){\n\n\n\nhash ^= (x >> 24);\n\n hash &= ~x;\n\n\n\n}\n\n}\n\nreturn (hash & 0x7FFFFFFF);", "Tag": "算法分析"}
{"Answer": "```\r\n 不需要9层循环，只需要两层循环\r\n思路（C伪代码）\r\nint arr[3][3];\r\nsum = arr[0][1]+arr[0][2]+arr[0][3];\r\nfor (i = 1; i < 3; i++)\r\n{\r\nsum1 = 0;\r\nfor (int j=1;j<3;j++)\r\n{\r\nsum1 += arr[i][j];\r\n}\r\nif sum1 != sum return false;\r\n}\r\nfor (i = 1; i < 3; i++)\r\n{\r\nsum1 = 0;\r\nfor (int j=1;j<3;j++)\r\n{\r\nsum1 += arr[j][i];\r\n}\r\nif sum1 != sum return false;\r\n}\r\nsum1 = 0;\r\nfor (int j=1;j<3;j++)\r\n{\r\nsum1 += arr[j][j];\r\n}\r\nif sum1 != sum return false;\r\nsum1 = 0;\r\nfor (int j=1;j<3;j++)\r\n{\r\nsum1 += arr[j][3-j];\r\n}\r\nif sum1 != sum return false;\r\n```", "Konwledge_Point": "算法与数字", "Question": "用php代码，这一个九宫格\n使得九宫格的横竖斜的三个球相加都相等。注意：不要九层for的循环套用。", "Tag": "算法分析"}
{"Answer": "final static char[] digits = {\r\n\t\t'0' , '1' , '2' , '3' , '4' , '5' ,\r\n\t\t'6' , '7' , '8' , '9' , 'a' , 'b' ,\r\n\t\t'c' , 'd' , 'e' , 'f' , 'g' , 'h' ,\r\n\t\t'i' , 'j' , 'k' , 'l' , 'm' , 'n' ,\r\n\t\t'o' , 'p' , 'q' , 'r' , 's' , 't' ,\r\n\t\t'u' , 'v' , 'w' , 'x' , 'y' , 'z' ,\r\n\t\t'A' , 'B' , 'C' , 'D' , 'E' , 'F' ,\r\n\t\t'G' , 'H' , 'I' , 'J' , 'K' , 'L' ,\r\n\t\t'M' , 'N' , 'O' , 'P' , 'Q' , 'R' ,\r\n\t\t'S' , 'T' , 'U' , 'V' , 'W' , 'X' ,\r\n\t\t'Y' , 'Z'\r\n\t    };\r\n\r\nprivate static String to62String(long i, int radix) {\r\n        if (radix < Character.MIN_RADIX || radix > 62)\r\n\t    radix = 10;\r\n        if (radix == 10)\r\n            return String.valueOf(i);\r\n        char[] buf = new char[65];\r\n        int charPos = 64;\r\n        boolean negative = (i < 0);\r\n        if (!negative) {\r\n            i = -i;\r\n        }\r\n        while (i <= -radix) {\r\n            buf[charPos--] = digits[(int)(-(i % radix))];\r\n            i = i / radix;\r\n        }\r\n        buf[charPos] = digits[(int)(-i)];\r\n        if (negative) { \r\n            buf[--charPos] = '-';\r\n        }\r\n        return new String(buf, charPos, (65 - charPos));\r\n    }", "Konwledge_Point": "算法与数字", "Question": "求一字符转化的算法\n问题大致是这样的，把当前的时间毫秒数转化成一个7个字符的字符串，与时间一一对应的，此字符串包括数字和字母，最好是一种可逆的算法。。", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/settingsun1225/article/details/10285137", "Konwledge_Point": "算法与数字", "Question": "C语言模拟类型算法问题，怎么才能做到\n题目描述 Description\n\n小明玩一个数字游戏，取个n行n列数字矩阵（其中n为不超过100的奇数），数字的填补方法为：在矩阵中心从1开始以逆时针方向绕行，逐圈扩大，直到n行n列填满数字，请输出该n行n列正方形矩阵以及其的对角线数字之和.\n\n\n\n输入描述 Input Description\n\nn（即n行n列）\n\n\n\n输出描述 Output Description\n\nn+1行，n行为组成的矩阵，最后一行为对角线数字之和\n\n\n\n样例输入 Sample Input\n\n3\n\n\n\n样例输出 Sample Output\n\n5 4 3\n\n6 1 2\n\n7 8 9\n\n25\n\n怎么写可以建立一个组，然后模仿人填写(跟手写一样转一圈再转一圈)，从1依次往下填", "Tag": "算法分析"}
{"Answer": "部分伪代码实现，接下来Lz锻炼锻炼coding！ :o  :o \r\n\r\n\r\npublic class Util(){\r\n\r\n\tpublic int parse(int argInput){\r\n\t//将整数单个分解存于数组arr中。\r\n\tString str = argInput+\"\";\r\n\tint length =str.length();\r\n\tint[] arr = new int(length );\r\n\tfor(int i = 0;iarr[--index])break;\r\n\t\t}\r\n\t\r\n\tif(index==0){//添加一个0，处理.这中情况如“321”\r\n\t\r\n\t//将0放在数组的第二个位置，数组的第一个位置放原来数值中的最小数，比如321中的“1”\r\n\t//这是数组为“1 0 ..”\r\n\t...\r\n\t//数组第二个位置后面的数从小到大排列。\r\n\t...\r\n\r\n\t}else{//不添加0 这种情况如“2563”\r\n\t\r\n\t//将index位置的值与index-1的值互换。如将6与5互换，“2653”。\r\n\t...\r\n\t//将index后面（包含index位置）的数值从小到大排列。这时将“5 3”从小到大排列。\r\n\t...\r\n\t}\r\n\t///将int数组arr各个数值按顺序生成一个整数。返回所需要的值。\r\n\r\n}//end parse\r\n\t\r\n}", "Konwledge_Point": "算法与数字", "Question": "急求解一算法（感谢）\n题：求一下个数\n\n给出一个数字 152，它以125，152，215，251，512，512，1025...排列（位数不足补0）\n\n现在要得到 152 后面的下一个数，即答案是512\n\n\n\n求一通用的java算法\n\n\n\n列（给出以下3个数字）：\n\n115\n\n1051\n\n6233\n\n结果输出：\n\n151\n\n1105\n\n6323\n\n\n\n希望高手帮我解决下，感谢！", "Tag": "算法分析"}
{"Answer": "该回答引用ChatGPT是的，使用启发式算法求解数字华容道类似的拼图游戏是可行的。启发式算法是一种高效的解决问题的方法，它使用简单的估价函数和最优化策略来找到最优解。在数字华容道拼图游戏中，启发式算法可以把每个可能的移动作为一个状态，然后根据估价函数的结果选择最有可能的状态。这样，它可以快速找到最短路径，从而解决拼图游戏的问题。", "Konwledge_Point": "算法与数字", "Question": "9宫格拼图游戏算法问题\n您好，我想做一个数字华容道类似9宫格拼图游戏，毕业设计需要算法，我报上去了启发式算法求拼图游戏最优解，这个可行么？", "Tag": "算法分析"}
{"Answer": "```\r\n #include \r\nusing namespace std;\r\nvoid foo(int x)\r\n{\r\n    if (x == 0) return;\r\n    cout << x % 10;\r\n    foo(x / 10);\r\n}\r\nint main()\r\n{\r\n    int i = 123;\r\n    foo(i);\r\n}\r\n```", "Konwledge_Point": "算法与数字", "Question": "C++算法：通过递归算法实现非零数字反转\n事例：\n\n321------123\n\n1568-----8651", "Tag": "算法分析"}
{"Answer": "大概类似这样吧：", "Konwledge_Point": "算法与数字", "Question": "输入三个整数，输出最大值，用N-S流程图表示该算法\n输入三个整数，输出最大值，用N-S流程图表示该算法", "Tag": "算法分析"}
{"Answer": "public class TestList\r\n{\r\n    /**\r\n     * \r\n     * @param sourceList 基准数据\r\n     * @param targetList 要比较的数据\r\n     * @return 差异数据\r\n     */\r\n    private List findNumber(List sourceList,\r\n            List targetList)\r\n    {\r\n        List resultList = new ArrayList();\r\n        for (Integer i : sourceList)\r\n        {\r\n            if (targetList.contains(i))\r\n            {\r\n                continue;\r\n            }\r\n            resultList.add(i);\r\n        }\r\n        return resultList;\r\n    }\r\n    \r\n    @Test\r\n    public void test()\r\n    {\r\n        List sourceList = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\r\n        List targetList = Arrays.asList(1, 3, 4, 8, 10);\r\n        List resultList = findNumber(sourceList, targetList);\r\n        System.out.println(\"缺少的数字:\");\r\n        for(Integer i : resultList){\r\n            System.out.print(i + \"、\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n打印出的结果：\r\n[quote]\r\n缺少的数字:\r\n2、5、6、7、9、\r\n[/quote]", "Konwledge_Point": "算法与数字", "Question": "数组查找算法的实现\n一组数据，顺序排列，比如这样（1,2,3,4,5,6,9,12,16,18,19,25）从中找出缺少的数字（7-8,10-11,13-15,17,20-24），这个程序怎么实现，或者用到什么函数谢谢大家了，", "Tag": "算法分析"}
{"Answer": "你在想什么？`scene_id`的UTF-8编码长度原超过8字节，你只传8字节怎么可能还原全部？\r\n必须把整个字节数组都传过去啊。", "Konwledge_Point": "算法与数字", "Question": "非数字string 转 int（32位非零），传给另一方，在转回到原string，求助 \n非数字string 转成 int（32位非零），传给另一方，在转回到原string，求助 ：\n\n我尝试了 string--byte[]--int32       然后 int32--byte[]--string的转换，结果只得到原string的前几位\n\n代码\n\nstring scene_id = \"SYSTEM000000000000018428#0000000001\";\n\n\n\n        byte[] myBytes = Encoding.UTF8.GetBytes(scene_id);\n        long iscene = BitConverter.ToInt64(myBytes,0);\n\n        byte[] tb = BitConverter.GetBytes(iscene);\n        string ts = Encoding.UTF8.GetString(tb);\n", "Tag": "算法分析"}
{"Answer": "可以这样想，假设有数字a,b,c,d,e，取其两两相减的绝对值。将这10个数字做从小到大排序，最好构建成结构体，用于记录每个数字是由哪两个数相减所得。\n\n之后遍历排序好以后的数列\n例:取最小的值作为起始数列，比如为a-b\n那么第二个数字中必要含有a或者b，依次逐步遍历即可得到所有数列情况![图片](https://img-ask.csdn.net/upload/201803/23/1521796790_875281.jpg)", "Konwledge_Point": "算法与数字", "Question": "初学者 求助排序算法相关问题啊。\n大学生初学算法 求助大神，一堆数字排序，要求排序后每相邻两数差的绝对值是不断递增的，找出所有满足的排序方案，并找出相邻差值绝对值和最小的那个方案，能做到吗？请给一下思路，或者该使用什么算法，谢谢各位了。", "Tag": "算法分析"}
{"Answer": "二分法可以吗？\r\n或则，48个区间的话应该可以设计出一个哈希函数，直接映射", "Konwledge_Point": "算法与数字", "Question": "点投射到区间的算法问题求解\n有48个区间，分别是负无穷到-121，-120到-115，-115到-114，（不规律的）一直到第\n\n48个区间是-44到0 ，怎么设计一个算法快速判断一个数字比如-88是在哪个区间里的呢", "Tag": "算法分析"}
{"Answer": "\n\nfunction sum(n){\n    if(1 > n || n > 10) throw new Error(\"输入一个正整数n（1⩽n⩽10 ）\")\n    var t = 1;\n    var c = new Array(n).fill(1).map(_ => new Array(n).fill(1));\n    var f = 1;\n    for(var i = n-1; i >= 0; i--){\n        for(var j = n-1; j >= 0; j--){\n            if(f) c[j][i] = t++;\n            else c[n-j-1][i] = t++;\n        }\n        f = !f;\n    }\n    \n    ////////////// 打印输出\n    console.log(c.map(e => e.join(\" \")).join(\"\\n\"))\n\n}\n\nsum(3)\nsum(4)\nsum(5)\n\n\n\n\n有用望采纳\n", "Konwledge_Point": "算法与数字", "Question": "这道怎么写啊各位（js算法题）\n输入格式:\n输入一个正整数n（1⩽n⩽10 ）\n\n\n输出格式:\n输出n×n的往返跑方阵。每行n个数字，每个数字占3位，右对齐。", "Tag": "算法分析"}
{"Answer": "\n没有了~~~ \n ", "Konwledge_Point": "算法与数字", "Question": "Java 带字母和数字的排序算法\n按照作业的要求写出来的代码，但是总感觉过于麻烦了。因为规定是只能import java.io.*; 所以很多东西比如ArrayList都用不了。之前想用node写，但是最后给我自己绕晕了，就还是用了普通的array。有没有大神能帮忙看看哪里能精简一下？感谢\n\n\n\n\n\n\n\n\nimport java.io.*;\n\npublic class Sorter{\n\tpublic static String InputFile;\n\tpublic static String OutputFile;\n\tprivate String[] list;\n\t\n\t//constructor\n\tpublic Sorter() {\n\t\tlist=new String[100];\n\t}\n\t\n\t//sort the numbers in ascending order, and return a string array\n\tpublic String[] sortNumbs(double[] arr){\n\t    if(arr != null && arr.length > 1){\n\t        for(int i = 0; i < arr.length - 1; i++){\n\t            boolean flag = true;\n\t            for(int j = 0; j < arr.length - i - 1 ; j++){\n\t                if(arr[j] > arr[j+1]){\n\t                    double temp;\n\t                    temp = arr[j];\n\t                    arr[j] = arr[j+1];\n\t                    arr[j+1] = temp;\n\t                    flag = false;\n\t                }\n\t            }\n\t            if(flag){\n\t                break;\n\t            }\n\t        }\n\t    }\n\t    //convert the ordered double array to string\n\t    String[] ascending=new String [arr.length];\n\t    for(int i=0;i=0;) {\n\t\t\tif(str.charAt(i)<48||str.charAt(i)>57)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\t//clear all empty elements in a double array\n\tpublic static double[] replaceNull(double[] str){\n\t\tint length=str.length;\t\n\t\t//count the number of the 0 and calculate the length of the new array;\n\t\tfor(int i=0;i0) {\n\t\t\t\tfor(int k=0;k<str.length;k++) {\n\t\t\t\t\tsort.list[k]=str[k];\n\t\t\t\t}\n\t\t\t}\n\t\t\t//if there is no 666, the result list should be sorted in descending order;\n\t\t\telse {\n\t\t\t\tint reverse=str.length;\n\t\t\t\tfor(int k=0;k<str.length;k++) {\n\t\t\t\t\tsort.list[reverse-1]=str[k];\n\t\t\t\t\treverse--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort.list=replaceNull(sort.list);\n\t\t\t\n\t\t\t//if there is 0 originally, change it back because it was changed to 0.1 before\n\t\t\tfor(int j=0;j<sort.list.length;j++) {\n\t\t\t\tif(sort.list[j].equals(\"0.1\")) {\n\t\t\t\t\tsort.list[j]=\"0\";\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j=0;j<sort.list.length-1;j++) {\n\t\t\t\tWriteOutput(sort.list[j]+\"\\n\");\n\t\t\t\t//System.out.println(sort.list[j]);\n\t\t\t}\n\t\t\tWriteOutput(sort.list[sort.list.length-1]);\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\t//close the file\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\treader.close();\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}", "Tag": "算法分析"}
{"Answer": "\nimport itertools\nlist = [1,2,3,4,5,6,7,8]\nnum = 12\nn=len(list)\nfor i in range(1,n+1):\n    data = itertools.combinations(list,i)\n    for s in data:\n        if sum(s) == num:\n            print(\"组合:{}元素相加等于{}\".format(s,num))\n", "Konwledge_Point": "算法与数字", "Question": "如何从一组数里选出相加等于给定值的组合？(语言-python)\n输入一组数，并给定一个数值，要求程序自动打印出相加之和等于给定值的组合，不一定是两数。\n\n\n求帮忙。语言是python ", "Tag": "算法分析"}
{"Answer": "#include\r\n#include\r\n\r\n#define MAX 70\r\n#define BIG 62\r\n\r\nint temp[BIG];\r\nvoid main()\r\n{\r\n\tint arr[MAX];\r\n\tint i=0,j=0;\r\n\r\n\tfor (i=0; i= 10 && arr[i] < 36)\r\n\t\t\tprintf(\" %c\",'A'+arr[i]-10);\r\n\t\telse if (arr[i] >= 36)\r\n\t\t    printf(\" %c\",'a'+arr[i]-36);\r\n\t\telse printf(\" %c\",'0'+arr[i]);\r\n\t}\r\n\tprintf(\"\\n\\n\");\r\n\r\n\tfor (i=0; i 0)\r\n\t   {\r\n\t\t   arr[j++] = i;\r\n\t\t   temp[i]--;\r\n\t\t   goto\r\n\t\t\t   fuwei;\r\n\t   }\r\n\t}\r\n\r\n\tprintf(\"经过排序后数值数组如下：\\n\");\r\n    for (i=0; i= 10 && arr[i] < 36)\r\n\t\t\tprintf(\" %c\",'A'+arr[i]-10);\r\n\t\telse if (arr[i] >= 36)\r\n\t\t\tprintf(\" %c\",'a'+arr[i]-36);\r\n\t\telse printf(\" %c\",'0'+arr[i]);\r\n\t}\r\n\tsystem(\"pause\");\r\n}\r\n\r\n```\r\n \r\n```\r\n上面是源代码。下面是运行图片\r\n![图片说明](https://img-ask.csdn.net/upload/201506/25/1435219165_343790.png)\r\n\r\n题主若有疑问的话，请私信我，谢谢！", "Konwledge_Point": "算法与数字", "Question": "排序算法用什么最好？\n题目要求：随机产生70个字符放在一个数组里，字符只能是数字或英文字母（一共62个字符），然后用程序将它们重新排序并打印出来。\n\n\n\n优先排序规则：数字最优先，字母按照字母表顺序，比如 a 优先于 b 打印，但大写字母优先于小写字母！", "Tag": "算法分析"}
{"Answer": "\npublic static void main(String[] args) {\n        elevator();\n    }\n\n    public static void elevator(){\n        Scanner scanner = new Scanner(System.in);\n\n        int n = scanner.nextInt();\n        if(n < 0){\n            System.out.println(\"请输入大于等于0的数字\");\n        }\n        if(n == 0){\n            System.out.println(\"此组数据不做处理\");\n        }\n        System.out.println(\"请输入层数:\");\n        int[] m = new int[n];\n        for(int i=0; i<n; i++){\n            m[i] = scanner.nextInt();\n        }\n        int sum = 0;\n        sum += 6 * m[0];\n\n        for(int j = 0;j < n-1 ;j++){\n            if(m[j] > m[j+1]){\n                sum += Math.abs(m[j] - m[j+1])*4;  //下降\n            }else if(m[j] < m[j+1]){\n                sum += Math.abs(m[j] - m[j+1])*6;  //上升\n            }\n        }\n        sum += n * 5;\n        System.out.println(sum);\n    }\n", "Konwledge_Point": "算法与数字", "Question": "电梯上下问题的ACM算法(语言-java)\n问题遇到的现象和发生背景\n\n\n电梯\n\n\n问题相关代码，请勿粘贴截图\n\n\njava题目描述\n在我们的城市最高的建筑只有一个电梯。电梯请求列表包括N个正数。该数字序列表示电梯将要到达的楼层顺序。电梯每上一层楼用时6秒，下一层楼用时4秒，停一次用时5秒。\n\n\n对于给定的请求列表，请计算花费执行列表中的请求的总时间。电梯初始在第0层。\n\n\n输入格式\n输入数据有多组。每组输入数据包含一个正整数N和N个正整数（N和楼层值不会超过100），表示电梯要到达的楼层数量和楼层。当N=0时输入结束，此组数据不进行处理。\n\n\n输出格式\n对于每组输入数据，计算电梯完成请求列表需要的时间，每组输出占一行。\n样例输入\n1 2\n3 2 3 1\n0\n样例输出\n17\n41", "Tag": "算法分析"}
{"Answer": "1、可以使用树遍历的方式回溯，一层层遍历、回溯\r\n2、数学方法，\r\n\t\t\t17+(X1*-1)* 6，(X2*-1)* 25+(X3*-1)* 49+(X4*-1)* 27+(X5*-1)* 65+(X6*-1)* 42+(X7*-1)* 48\r\n\t\t\t解向量X1……X7", "Konwledge_Point": "算法与数字", "Question": "算法：17，6，25，49，27，65，42，48 按顺序加减得99\n遇到一道算法题，题目是将指定数字按照顺序的方式加上加号和减号的到指定结果，请问该问题的解法，是不是采用遍历树的方式来解决该问题？", "Tag": "算法分析"}
{"Answer": "http://gouwu.baidu.com/question/2204084031584739588.html?entry=qb_browse_default", "Konwledge_Point": "算法与数字", "Question": "C++的一题OJ算法竞赛题，求解析（最好附上代码）\n小明的密码由N（1<=N<=12）个数字构成，每个数字都可以是0至9中任意一个数字，但小明的密码还有\n\n一个特点就是密码中连续的M（1<=M<=4）个数字的和是质数，现给定M和N，求满足条件的密码共有多少\n\n个？", "Tag": "算法分析"}
{"Answer": "so easy..\r\nint[] ints = new int[8001] ;\r\n#1遍历所有数字.按照下标放入ints 中设置为1\r\n\r\nints[0]=1\r\nints[3]=1\r\n...\r\n\r\n\r\n#2.遍历这个ints数组.一个开关程序.双向输出就可以了", "Konwledge_Point": "算法与数字", "Question": "兄弟们帮忙想个算法，在存储过程中实现\n一张表，ID字段，可以存储0~~8000的数字，但是存储的时候可以不连续，\n\n比如：\n\nID\n\n0\n\n3\n\n5\n\n99\n\n100\n\n1000\n\n5000\n\n现在的问题是，根据已经存入ID字段的数字，将没有使用的数字算出来，而且要分段显示，\n\n比如：\n\n开始ID    结束ID\n\n  1         2\n\n  4         4\n\n  6         98\n\n  101       999\n\n  1001      4999\n\n  5001      8000\n\n各位大拿有没有好一点的算法，\n\n多谢多谢！！", "Tag": "算法分析"}
{"Answer": "用的着那么多循环？能完全平方的三位数也就从10开始到40左右，去计算其他数值乘积就不是完全平方数了，如4和7的乘积不可能是完全平方数，根本就没必要去计算，基本数学知识，没必要画蛇添足，完全平方数2个值相等的乘积，小学基础知识99乘法表。https://ask.csdn.net/questions/7553530", "Konwledge_Point": "算法与数字", "Question": "哪里出错了？编写程序寻找既是完全平方数，又有两位数字相同的三位正整数，例如121、144等。要求统计满足该条件的整数个数，并从大到小打印这些整数。\n哪里出错了？", "Tag": "算法分析"}
{"Answer": "不好意思，之前发的那个没验证发现有点问题，误导了，这个验证了一下没问题。你的题目总没有说明翻译成几进制，所以我就按原样翻译了\r\n例如字符\"1234\"，翻译为数字1234.\r\n\r\n```\r\n void GetNumFromString(char *c,unsigned long *num);\r\nvoid _tmain(int argc, _TCHAR* argv[])\r\n{\r\n\tunsigned long x;\r\n\tchar *pp = \"1234\";\r\n\tx = 0;\r\n\tGetNumFromString(pp,(unsigned long *)&x);\r\n\tpp = \"8234\";\r\n\tx = 0;\r\n\tGetNumFromString(pp,(unsigned long *)&x);\r\n\twhile(1)\r\n\t{\r\n\r\n\t}\r\n}\r\n\r\nvoid GetNumFromString(char *c,unsigned long *num)\r\n{\r\n\tif(*c != '\\0')\r\n\t{\r\n\t\t*num *= 10;\r\n\t\tif(*c >= '0' && *c <= '9')\r\n\t\t\t*num += *c - '0';\r\n\t\tGetNumFromString(++c,num);\r\n\t}\r\n}\r\n```", "Konwledge_Point": "算法与数字", "Question": "从键盘输入一个字符如（“12345”只有0-9）用递归算法将字符串转换为数字，\n完整题目：从键盘输入一个字符如（“12345”只有0-9）用递归算法将字符串转换为数字，求算法复杂性，并验证排序正确性", "Tag": "算法分析"}
{"Answer": "需要定制么？", "Konwledge_Point": "算法与数字", "Question": "数字图像处理—铆钉缺失检测\n实验目的：\n\n\n\n通过对所拍摄的二维码图片进行大面积缺失检测\n\n\n\n题目要求：\n\n\n\n（1）图像定位，寻找铆钉扣位置\n\n\n\n（2）指定区域彩色图像二值化操作\n\n\n\n（3）根据铆钉反光在二值化图像上确定指定区域是否存在铆钉\n\n\n\n（4）统计算法准确度\n\n\n\n结果要求：\n\n\n\n程序显示测量值和检测结果，将不合格图片显示和存储。和人工核对比较算法准确率，使用c++或python实现", "Tag": "算法分析"}
{"Answer": "Java 的 Collections 集合工具中的排序方法会根据对象的 Comparator 接口进行排序的，字符串的比较操是基于字典顺序的：\r\n\r\n```\r\nList list = new ArrayList();\r\n\t\tlist.add(\"a\");\r\n\t\tlist.add(\"A11\");\r\n\t\tlist.add(\"c\");\r\n\t\tlist.add(\"F\");\r\n\t\tlist.add(\"111\");\r\n\t\tSystem.out.println(list);\r\n\t\tCollections.sort(list);\r\n\t\tSystem.out.println(list);\r\n```", "Konwledge_Point": "算法与数字", "Question": "Java语言高分悬赏：在排序算法中，如果比较的是对象不是数字或者字符串，程序怎么实现呢\nJava语言高分悬赏：在排序算法中，如果比较的是对象不是数字或者字符串，程序怎么实现呢", "Tag": "算法分析"}
{"Answer": "![图片说明](https://img-ask.csdn.net/upload/201806/12/1528789625_194165.png)![图片说明](https://img-ask.csdn.net/upload/201806/12/1528789638_805909.png)\r\n帮你写了个详细的代码", "Konwledge_Point": "算法与数字", "Question": "同一个包下，怎么调用另一个类里面的算法。\n\nJ算法是将数字转化为汉字的算法，我现在希望将前台传来的salary工资数字变为汉字，在addservlet里面应该怎么调用呢？", "Tag": "算法分析"}
{"Answer": "额，不是有自带的排列组合模块吗。。。\nfrom itertools import product\nn = int(input())\nfor i in product([1,2,3], repeat=n):\n    print(*i)\n\n当n=3的时候，输出如下：1 1 11 1 21 1 31 2 11 2 21 2 31 3 11 3 21 3 32 1 12 1 22 1 32 2 12 2 22 2 32 3 12 3 22 3 33 1 13 1 23 1 33 2 13 2 23 2 33 3 13 3 23 3 3", "Konwledge_Point": "算法与数字", "Question": "算法py 数字排列可能性\npython\n\n\n输入一个n长度， 代表n个位置，每个位置有3种可能， 求出所有排序方式。求解\n\n\n例如：n = 2\n\n\n1 1\n1 2\n1 3\n2 1\n2 2\n2 3\n3 1\n3 2\n3 3", "Tag": "算法分析"}
{"Answer": "首先，你用a数组来存储输入的字符，那么每个字符的权重应该是字符-'A'+1才对。\r\n所以，你的求sum的代码应该是sum+=a[i]-'A'+1。", "Konwledge_Point": "算法与数字", "Question": "26个字母对应1~26的数字，然后计算输入单词的权重之和\n#include \n\n#include \n\n\n\nint main(void)\n\n{\n\n    int A =1, B =2,C =3, D =4, E =5, F =6, G =7, H =8, I =9, J =10,\n\n        K =11, L =12, M =13, N =14, O =15, P =16, Q =17, R =18, S =19, \n\n        T =20, U =21, V =22, W =23, X =24, Y =25, Z =26;  //对每个字母赋值// \n\n    char a[100];\n\n    int sum=0,i;  //初始化sum 和 i// \n\n    a[0] = getchar();   //输入第一个首字母// \n\n    for(i=0;a[i] != '\\n';i++)  //输入剩余的字母 //\n\n       a[i+1] = getchar();\n\n    for(i=0;a[i]!='\\n';i++)\n\n    sum+=a[i];  //对个字母对应的数字求和// \n\n    printf(\"%d\\n\",sum);\n\n    return 0;\n\n}\n\n\n\n\n\n\nLOVE 的计算结果应该是54，为什么我的程序会是这么大？ 求大侠指点", "Tag": "算法分析"}
{"Answer": "对于你这个问题可以参考如下链接：\n数组中和为x的所有组合_电子楼战地记者的博客-CSDN博客\n数组：给定一个数组，求出数组中和为某个值的所有组合。例子：数组{3,2,1,1,1,5,6}中和为10的所有组合思路：通过递归加回溯的办法解决，具体思路看代码：void getSum(vector&lt;int&gt; &amp;nums,int pos,int sum,vector&lt;int&gt; &amp;v){    if(sum &lt; 0)    ...\n\n\n\nhttps://blog.csdn.net/nbawj/article/details/83109735\n\n用c语言是\n#include <stdio.h>\nint tv[1000],vl = 0;\nvoid getSum(int *nums,int pos,int n,int sum)\n{\n    if(sum < 0)\n    {\n        return;\n    }\n    if(sum == 0)\n    {\n        for(int i = 0; i < vl; i++)\n        {\n            printf(\"%d \",tv[i]);\n        }\n        printf(\"\\n\");\n        return;\n    }\n    for(int i = pos;i<n;i++)\n    {\n        tv[vl++] = nums[i];\n        getSum(nums,i+1,n,sum-nums[i]);\n        vl--;\n    }\n}\n\nint main(void)\n{\n    int nums[]={2,3,5,1,6},target=8;\n    getSum(nums,0,5,target);\n    return 0;\n}\n\n\n\n如有帮助，请点击我的回答下方的【采纳该答案】按钮帮忙采纳下，谢谢!\n", "Konwledge_Point": "算法与数字", "Question": "递归实现以下问题算法\n用递归实现如下问题：给定一个数组nums=[2，3，5]和一个固定的值target=8。找出数组nums中所有可以使数字和为target的组合（数字可重复）。", "Tag": "算法分析"}
{"Answer": "https://wenku.baidu.com/view/b3ba32a7afaad1f34693daef5ef7ba0d4a736de3.html", "Konwledge_Point": "算法与数字", "Question": "请问这里的数字组合算法怎么实现的呢，采用数据结构和C语言实现\nProblem Description\n\nLet d(x) be the sum of all divisors of x. x is called a good number if every number from 1 to d(x) can be expressed as a sum of distinct divisors of x.\n\n\n\nFor example, 6 is a good number, d(6)=1+2+3+6=12, 4=1+3,5=2+3,7=1+6 and so on.\n\n\n\nTeacher Mai wants to know whether a even number p can be expressed as a sum of two good numbers.\n\n\n\nInput\n\nThere are multiple test cases(about 40000).\n\n\n\nFor each test case, there is only one line contains one even number p(1≤p≤1018).\n\n\n\nMost test cases are generated randomly.\n\n\n\nOutput\n\nFor each test case, print \"YES\" or \"NO\" in the first line. That means if is possible to express p as a sum of two good numbers.\n\n\n\nIf your answer is \"YES\", print two number a,b in the second lines. Both a and b should be good numbers, and a+b=p.\n\n\n\nIn the third and the fourth line, print the factorization of number a and b. If a=∏ki=1peii, where p1<p2<⋯<pk, pi are all prime numbers and ei≥1, you should print k first, then 2k space-seperated numbers p1,e1,p2,e2,⋯,pk,ek.\n\n\n\nSample Input\n\n18\n\n\n\nSample Output\n\nYES\n\n6 12\n\n2 2 1 3 1\n\n2 2 2 3 1", "Tag": "算法分析"}
{"Answer": "你的 count_time函数返回的result是一个拷贝数组,不是运行时间,将其改为即可返回时间\n    return round(end_time - start_time,6)\n\n屏蔽\n# plt.legend(Sort = 'best')\n", "Konwledge_Point": "算法与数字", "Question": "变化数字列表长度，统计不同排序算法所消耗的时间，并以折线图形式进行可视化展示，要如何统计不同算法所消耗的时间，并可视化?(语言-python)\n为什么def的yi函数统计出的sort的耗时和之前运行的结果不一样，要怎么把之前的运行结果，def一个函数来进行统计，以及绘制折线图的报错要怎样修改\n\n", "Tag": "算法分析"}
{"Answer": "可以用 快速排序 或者 归并排序，或者 希尔排序 都是比冒泡快的。\n❤️五万字《十大排序算法》动图讲解❤️(建议收藏)_英雄哪里出来-CSDN博客\n打开算法大门，从排序开始\n\n\n\nhttps://blog.csdn.net/WhereIsHeroFrom/article/details/119976287\n\n", "Konwledge_Point": "算法与数字", "Question": "有没有更好的排序算法\n题目：\n\n\n\n\n我的代码：\n\n\nvoid sort\n_maoPao(\nint\n*\n \npeople\n,\nint\n \npeopleSize\n)\n\n{\n    \nint\n i,j;\n    \nint\n temp = \n0\n;\n    \nfor\n(i=\n0\n;i=min;i--){\n        \nfor\n(j=\n0\n;jpeople\n[\ni\n]\n){\n            *min = people\n[\ni\n]\n;\n        }\n        \nif\n(*max<people\n[\ni\n]\n){\n            *max = people\n[\ni\n]\n;\n        }\n    }\n}\n\n\nint\n num\nRescueBoats(\nint\n*\n \npeople\n, \nint\n \npeopleSize\n, \nint\n \nlimit\n)\n{\n    \nint\n left = \n0\n;\n    \nint\n ret = peopleSize-\n1\n;\n    \nint\n num = \n0\n;\n    \nint\n min = people\n[\n0\n]\n;\n    \nint\n max = people\n[\n0\n]\n;\n\n    people\nMinAndMax(\npeople\n,\npeopleSize\n,&\nmin\n,&\nmax\n)\n;\n    \n//printf(\"min:%d\\nmax:%d\\n\",min,max);\n\n    \n//sort_maoPao(people,peopleSize);\n\n    sort\n_jiShu(\npeople\n,\npeopleSize\n,\nmin\n,\nmax\n)\n;\n\n/*\n    for(int i=0;i<peopleSize;i++){\n        printf(\"%d \",people[i]);\n    }\n*/\n\n    \nfor\n(left=\n0\n;left<=ret;left++){\n        \nif\n(people\n[\nleft\n]\n == \nlimit){\n            num++;\n            continue;\n        }\n        \nif\n( (people\n[\nleft\n]\n+people\n[\nret\n]\n) <= limit){\n            num++;\n            ret--;\n            continue;\n        }\nelse\n{\n            num++;\n            continue;\n        }\n        \nif\n(left\n == \nret){\n            num++;\n        }\n    }\n    return num;\n}\n\n\n\n问题：\n一开始我用的冒泡排序，但是有一组测试案例给的数据量特别大，5000多个，用冒泡排序会超时；\n后来我发现这组数据最小值到最大值跨度不是很大，我就用了计数排序；\n结果在这个案例后面还有一个案例：数据量大，最小值到最大值跨度也大0.0；\n然后冒泡和计数排序都会超时；\n请问有没有更好的排序算法，或者解决方法", "Tag": "算法分析"}
{"Answer": "可以参考我写的博文\r\nhttp://blog.csdn.net/AIRE_Talent/article/details/51020888", "Konwledge_Point": "算法与数字", "Question": "有趣的数 算法的题 求思路\n问题描述\n\n我们把一个数称为有趣的，当且仅当：\n\n1. 它的数字只包含0, 1, 2, 3，且这四个数字都出现过至少一次。\n\n2. 所有的0都出现在所有的1之前，而所有的2都出现在所有的3之前。\n\n3. 最高位数字不为0。\n\n因此，符合我们定义的最小的有趣的数是2013。除此以外，4位的有趣的数还有两个：2031和2301。\n\n请计算恰好有n位的有趣的数的个数。由于答案可能非常大，只需要输出答案除以1000000007的余数。\n\n输入格式\n\n输入只有一行，包括恰好一个正整数n (4 ≤ n ≤ 1000)。 \n\n输出格式\n\n输出只有一行，包括恰好n 位的整数中有趣的数的个数除以1000000007的余数。 \n\n样例输入\n\n4\n\n样例输出\n\n3\n\n答案：\n\nimport java.util.*;\n\npublic class Main { \n\npublic static void main(String[] args) { \n\nnew Main().run(); \n\n}\n\npublic void run() { \n\nScanner fin = new Scanner(System.in);\n\nint N = fin.nextInt(); \n\nlong[] count = new long[8]; \n\ncount[6] = 0; \n\ncount[7] = 1; \n\nlong mod = 1000000007; for (int i = 2; i <= N; ++i) { \n\nlong[] newCount = new long[8]; \n\nnewCount[0] = (count[0] * 2 + count[1] + count[3]) % mod; \n\nnewCount[1] = (count[1] * 2 + count[2] + count[5]) % mod; \n\nnewCount[2] = (count[2] + count[6]) % mod; \n\nnewCount[3] = (count[3] * 2 + count[4] + count[5]) % mod; \n\nnewCount[4] = (count[4] + count[7]) % mod; \n\nnewCount[5] = (count[5] * 2 + count[6] + count[7]) % mod; \n\nnewCount[6] = 0; \n\nnewCount[7] = 1;\n\ncount = newCount; \n\n}\n\nSystem.out.println(count[0]); \n\n} \n\n}\n\n看不懂 求救 到底是什么思路", "Tag": "算法分析"}
{"Answer": "你的d是不是每个数重新计算时没有初始化。。", "Konwledge_Point": "算法与数字", "Question": "小白求助 算法有错误 找不出来，可以运行但是无法达到效果\n计算水仙花数的算法\n\n#include\n\nint main()\n\n{\n\nint a=100,b,c,d=0;\n\nwhile(a<1000)\n\n{\n\n    b=a;\n\n    while(b!=0)\n\n    {\n\n\n\nc=b%10;\n\nd=d+c*c*c;\n\nb=b/10;\n\n    }\n\n\n\nif(a==d)\n\nprintf(\"%d\",d);\n\na++;\n\n\n\n}\n\n}\n\n可以运行但是运行后没出数字啊啊啊啊", "Tag": "算法分析"}
{"Answer": "小白大学没认真学java，这是一道算法考试题，需要用java编写，希望有大神帮忙解答一下，题目有点长，但仔细读一下，看下举例就能明白。java编写出来能运行出结果就直接采纳给分，真心拜托了", "Konwledge_Point": "算法与数字", "Question": "Java 小白求编写一道算法题 \n约翰和他的朋友索尼娅打一场战舰游戏。游戏在N行的正方形地图上进行，编号从1到N.每行包含N个单元格，每列标有连续的英文大写字母（A，B，C等）。每个单元通过由其行编号及其列编号组成的串来标识：例如，“9C” 表示第9行中的第三单元,“15D”表示第15行中的第四单元。\n\n\n\n如下图所示，船只由最大面积为4个单元格的矩形定义，X落在船上时表示船被击中，如果一个船每个部位被击中，则该船被沉没。\n\n\n\n目标是计算沉没的船只的数量和被击中但未沉没的船只的数量。\n\n\n\n例如，下图显示了一个大小为N = 4的地图，两个蓝色船只和五个用字母“x”标记的命中;\n\n在这个例子中，一艘船已经沉没，另一艘已经被击中但没有沉没。在下一张图片中，沉船被显示为灰色，被击中但尚未沉没的船舶显示为红色：\n\n\n\n船的位置被给出为字符串S，其包含分别描述每艘船的左上角和右下角单元的位置对。船舶的描述用逗号分隔。命中的位置为字符串T，包含描述被击中的地图单元的位置：对于上述示例中的地图，S =“1B 2C，2D 4D”和T =“2B 2D 3D 4D 4A”。 S中的船舶和T中的命中可以以任何顺序出现。\n\n\n\n写一个函数：\n\n\n\nclass Solution {public String solution（int N，String S，String T）; ）\n\n\n\n假定地图N的大小和分别描述船只命中位置的两个字符串S，T返回具有两个数字的字符串：沉没船舶的计数和已被击中但未沉没的船舶的数量，用逗号分隔。\n\n\n\n例如，假设N = 4，S =“1B 2C，2D 4D”和T =“2B 2D 3D 4D 4A”，您的函数应返回“1,1”，如上所述。", "Tag": "算法分析"}
{"Answer": "已解决", "Konwledge_Point": "算法与数字", "Question": "leetcode算法题：第一个唯一数字\nleetcode题目链接 \nhttps://leetcode-cn.com/problems/first-unique-number/\n\n\n\n代码：\n\n\n\n\n\nclass FirstUnique \n{\npublic:\n    unordered_map num_freq;\n    vector rec;\n\n    FirstUnique(vector& nums) \n    {\n        for (int x: nums)\n            num_freq[x] ++;\n        for (int x : nums)\n            if (num_freq[x] == 1)\n                rec.push_back(x);\n    }\n    \n    int showFirstUnique() \n    {\n        int n = rec.size();\n        int res = -1;\n        int i = 0;\n        while (i < n)\n        {\n            if (num_freq[rec[i]] == 1)\n            {\n                res = rec[i];\n                rec.erase(rec.begin(), rec.begin() + i);\n                break;\n            }\n            i ++;\n        }\n        return res;\n\n    }\n    \n    void add(int value) \n    {\n        num_freq[value] ++;\n        if (num_freq[value] == 1)\n        {\n            rec.push_back(value);\n        }\n    }\n};\n\n/**\n * Your FirstUnique object will be instantiated and called as such:\n * FirstUnique* obj = new FirstUnique(nums);\n * int param_1 = obj->showFirstUnique();\n * obj->add(value);\n */\n\n\n\n求解释中rec.erase(rec.begin(), rec.begin() + i);的作用，我个人理解map中本就保存不重复的元素，这一句的意思应该是指删除因为新添加元素而变成不是唯一整数的数据，因为这个程序中只差这一个功能了，但是我没有理解到，谢谢！\n\n\n\nwhile (i < n)\n\n        {\n\n            if (num_freq[rec[i]] == 1)\n\n            {\n\n                res = rec[i];\n\n                rec.erase(rec.begin(), rec.begin() + i);\n\n                break;\n\n            }\n\n            i ++;\n\n        }\n\n\n\n \n\n\n\n ", "Tag": "算法分析"}
{"Answer": "这个应该能过了！\n#include <iostream>\n#include <cstdio>\nusing namespace std;\nint main()\n{\n    int n=0,a=0,b=0;\n    scanf(\"%d\",&n);\n    if(n==1)\n        a=1,b=9;\n    if(n==2)\n        a=10,b=98;\n    if(n==3)\n        a=102,b=987;\n    if(n==4)\n        a=1023,b=9876;\n    if(n==5)\n        a=10234,b=98765;\n    if(n==6)\n        a=102345,b=987654;\n    if(n==7)\n        a=1023456,b=9876543;\n    if(n==8)\n        a=10234567,b=98765432;\n    for(int i=a; i<=b; i++) //遍历所有n位数\n    {\n        int arr[10]= {0};\n        int index=0,num=i,flag=1;\n        while (num>0)\n        {\n            index = num % 10;\n            if (arr[index])\n            {\n                flag=0;\n                break;\n            }\n            arr[index] = 1;\n            num /= 10;\n        }\n        if(flag)\n            printf(\"%d\\n\",i);\n    }\n    return 0;\n}\n", "Konwledge_Point": "算法与数字", "Question": "51nod题目   n位不重复的数字\n今天的数学课让你感到很无聊。于是你打算在纸上写下所有n位不含重复数字的数，来打发时间。\n\n\n例如：你打算写6位数，那么你会写下127643；而123347含重复的3，你不会写下它。\n\n\n你决定由小到大写出每个数，并且你不会考虑含前导0的n位数。\n\n\n输入\n输入一个数n，表示你打算写n位数。\n输出\n每行输出一个数，表示你所写下的n位数。\n数据范围\n对于100%的数据，1≤n≤8；\n输入样例\n1\n输出样例\n1\n2\n3\n4\n5\n6\n7\n8\n9", "Tag": "算法分析"}
{"Answer": "g = sorted(eval(input()))\ns = sorted(eval(input()))\n\nfor i in range(len(s)):\n    if s[i] >= g[0]:\n        s = s[i:]\n        break\ncount=0\nfor i, j in zip(g,s):\n    if j>=i:\n        count += 1\n    else:\n        break\n\nprint(count)\n", "Konwledge_Point": "算法与数字", "Question": "分配问题@贪心算法-！%\n\n\n假设你是一位很棒的家长，想要给你的children一些小饼干。\n但是，每个最多只能给一块饼干。对每个child i，都有一个胃口值 g[i]，这是能让children满足胃口的\n饼干的最小尺寸；\n并且每块饼干j，都有一个尺寸 s[i]。如果 s[i]>= g[i]\n我们可以将这个饼干j分配给child i，这个child会得到满足。\n你的目标是尽可能满足越多数量的children，并输出这个最大数值。\n输入格式\n第一行是由多个数字组成的列表 g。\n第二行是由多个数字组成的列表 s。", "Tag": "算法分析"}
{"Answer": "String str=\"111,1a11b222c3dd128182\";\r\n\t\tint n=0;char c;boolean s=true;\r\n\t\tfor(int i=0,l=str.length();i'9'){\r\n\t\t\t\ts=true;continue;\r\n\t\t\t}\r\n\t\t\tif(!s)continue;\r\n\t\t\tn++;s=false;\r\n\t\t}\r\n\t\tSystem.out.println(n);\r\n\t\t//下面用正则\r\n\t\tPattern p=Pattern.compile(\"[0-9]+\");\r\n\t\tMatcher m=p.matcher(str);\r\n\t\tn=0;while(m.find())n++;\r\n\t\tSystem.out.println(n);\r\n这个嘛 面试官嘛 当面顶肯定你吃亏的嘛 心里有数才行", "Konwledge_Point": "算法与数字", "Question": "请问一道小算法题，今天面试没有写出来，被鄙视了\n\"abc334de55\"字符串中有多少组数字,比如这个是2\n\n\"abc334de5533aa44\"这个是3，\n\n\"abcd3343d444ed4ddd5\"这个是4\n\n\n\n就是连续的数字算是一组，一共多少组\n\n\n\n那个面试官很不给面子，说你连这个都写不出来还怎么混啊，我ding了句，说我以前的同事连冒泡排序也写不出，照样7000k", "Tag": "算法分析"}
{"Answer": "你如果要模拟列竖式，那你的所有中间结果也都应该用char[]来存啊，不要依赖long long int类型来保存中间结果，否则输入大到一定程度，中间结果溢出了", "Konwledge_Point": "算法与数字", "Question": "我的高精度乘法运算算法 为什么位数不能超过105位？\n进行高精度乘法运算时当数字输入位数超过大概105位时结果是错误的，此后随着输入位数的增加错误的位数也就越多，请问到底是怎么回事呢？\n又该如何解决这个问题呢？\n我的算法是模仿人类列竖式计算\n\n\n下面是代码 乘法函数为BIgMultiply函数\n\n\n#define _CRT_SECURE_NO_DEPRECATE\n\n\n#pragma warning(disable:4996)    //使scanf()函数可用\n\n\n\n#include\n\n\n#include\n\n\n#include\n\n\n#define N 205     //精度（数字位数） +2\n\n\n\n//\n将字符串变为倒序\nvoid reverse(char a[]) {\n    static char a2[N];\n    memset(a2, \n0\n, sizeof(a2));\n    int xa = strlen(a) - \n1\n;\n    int j = \n0\n;\n\n    \nfor\n (int i = xa; i >= \n0\n; i--) {\n        a2[j] = a[i];\n        j++;\n    }\n    memset(a, \n0\n, sizeof(a));\n    strcpy(a, a2);\n}\n\n\n//\n将字符串换算为真实数字\nvoid str2numArry(char a[]) {\n    \nfor\n (int i = \n0\n; a[i] != \n'\\0'\n; i++) {\n        a[i] -= \n'0'\n;\n    }\n}\n\nint strGetLongest(char a[], char b[]) {\n    int xa = strlen(a);\n    int xb = strlen(b);\n    int longest = xb;\n    \nif\n (xa >= xb) {\n        longest = xa;\n    }\n    return longest;\n}\n\n\n//\n运算得出的out[]是逆序的\n\nvoid BigPlus(char ia[], char ib[], char ResultGet[]) {\n    static char out[N], a[N], b[N];\n    int JW;\n//\n进位\n    \n//\n初始化\n    memset(out, \n0\n, sizeof(out));\n    memset(a, \n0\n, sizeof(a));\n    memset(b, \n0\n, sizeof(b));\n    memset(ResultGet, \n0\n, sizeof(ResultGet));\n    strcpy(a, ia);\n    strcpy(b, ib);\n    \n//\n先将数字倒序(因为列竖式时需要右对齐且从需要从右往左算)\n    reverse(a);\n    reverse(b);\n\n    \n//\n取a,b之中最长的 长度？\n    int longest = strGetLongest(a, b);\n    \n//\n换算为真实数字\n    str2numArry(a);\n    str2numArry(b);\n    \n//\n因为转换为真实数字之后末尾的‘\n0\n’会变成‘\\\n0\n’，又因为数组经过倒序处理，所以先导零将变成字符串结尾 \n'\\0'\n 将被忽略。\n    \n//\n运算\n    JW = \n0\n;\n    \nfor\n (int i = \n0\n; i <= longest; i++) {\n        out[i] = a[i] + b[i] + JW;\n        JW = \n0\n;\n        \nif\n (out[i] >= \n10\n) {\n            JW = out[i] / \n10\n;\n            out[i] %= \n10\n;\n        }\n    }\n\n    int j = \n0\n;\n    \nwhile\n (out[longest] == \n0\n && longest > \n0\n) {\n        longest--;\n    }\n    \nfor\n (int i = longest; i >= \n0\n; i--) {\n        ResultGet[j] = out[i] + \n'0'\n;\n\n        j++;\n    }\n    ResultGet[j] = \n'\\0'\n;\n}\n\nvoid BigMinus(char ia[], char ib[], char ResultGet[]) {\n    static char out[N], a[N], b[N];\n    int JW;\n//\n借位\n\n    \n//\n初始化\n    memset(out, \n0\n, sizeof(out));\n    memset(a, \n0\n, sizeof(a));\n    memset(b, \n0\n, sizeof(b));\n    memset(ResultGet, \n0\n, sizeof(ResultGet));\n    strcpy(a, ia);\n    strcpy(b, ib);\n    \n//\n先将数字倒序(因为列竖式时需要右对齐且从需要从右往左算)\n    reverse(a);\n    reverse(b);\n\n    \n//\n取a,b之中最长的 长度？\n    int longest = strGetLongest(a, b);\n    \n//\n换算为真实数字\n    str2numArry(a);\n    str2numArry(b);\n    \n//\n因为转换为真实数字之后末尾的‘\n0\n’会变成‘\\\n0\n’，又因为数组经过倒序处理，所以先导零将变成字符串结尾 \n'\\0'\n 将被忽略。\n\n    \n//\n运算\n    JW = \n0\n;\n    \nfor\n (int i = \n0\n; i < longest; i++) {\n        out[i] = a[i] - b[i] - JW;\n        JW = \n0\n;\n        \nif\n (out[i] < \n0\n) {\n            JW = \n1\n;\n            out[i] += \n10\n;\n        }\n    }\n\n    \n//\n逆序输出ASCII\n    int j = \n0\n;\n\n    \nwhile\n (out[longest] == \n0\n && longest > \n0\n) {\n        longest--;\n    }\n    \nfor\n (int i = longest; i >= \n0\n; i--) {\n        ResultGet[j] = out[i] + \n'0'\n;\n\n        j++;\n    }\n    ResultGet[j] = \n'\\0'\n;\n}\n\nvoid BigMultiply(char ia[], char ib[], char ResultGet[]) {\n    static char  out1[N][\n2\n * N], a[N+\n84\n], b[N];\n    static long long int out[\n2\n * N];\n    long long int JW;\n//\n进位\n    \n//\n初始化\n    memset(out, \n0\n, sizeof(out));\n    memset(out1, \n0\n, sizeof(out1));\n    memset(a, \n0\n, sizeof(a));\n    memset(b, \n0\n, sizeof(b));\n    memset(ResultGet, \n0\n, sizeof(ResultGet));\n    strcpy(a, ia);\n    strcpy(b, ib);\n\n    \n//\n先将数字倒序(因为列竖式时需要右对齐且从需要从右往左算)\n    reverse(a);\n    reverse(b);\n\n    int la = strlen(a);\n    int lb = strlen(b);\n    int longest = strGetLongest(a, b) + \n1\n;\n//\n中间过程结果长度可能的最大值\n    int longest_out = la + lb;\n//\n结果可能的最长长度\n    \n//\n换算为真实数字\n    str2numArry(a);\n    str2numArry(b);\n    \n//\n因为转换为真实数字之后末尾的‘\n0\n’会变成‘\\\n0\n’，又因为数组经过倒序处理，所以先导零将变成字符串结尾 \n'\\0'\n 将被忽略。\n    \n//\n运算\n    JW = \n0\n;\n\n    \nfor\n (int i = \n0\n; i < lb; i++) {\n        \nfor\n (int k = \n0\n, m = i; k < longest + i; k++, m++) {\n//\n数组序列是从零开始的，用<\n            out1[i][m] = b[i] * a[k] + JW;\n            JW = \n0\n;\n            \nif\n (out1[i][m] >= \n10\n) {\n                JW = out1[i][m] / \n10\n;\n                out1[i][m] %= \n10\n;\n            }\n            \n            printf(\n\"%d \"\n, out1[i][k]);\n        }\n        putchar(\n'\\n'\n);\n    }\n    putchar(\n'\\n'\n);\n    putchar(\n'\\n'\n);\n\n    \n    \n//\nchar test[\n50\n][\n50\n] = { {\n1\n,\n2\n,\n3\n},{\n1\n,\n1\n,\n1\n},{\n1\n,\n1\n,\n1\n} };\n    \n//\nlb是实际列数\n    \nfor\n (int i = \n0\n; i < longest_out; i++) {\n        out[i] = out1[\n0\n][i];\n    }\n    \n    \nfor\n (int i = \n1\n; i < lb; i++) {\n        JW = \n0\n;\n        \nfor\n (int j = \n0\n; j <= longest_out; j++) {\n            out[j] += out1[i][j] + JW;\n            \n//i\nf(out[j] < \n0\n || out[j] > \n9223372036854775000\n) \nexit\n(\n0\n);\n//\ntest\n            JW = \n0\n;\n            \nif\n (out[j] >= \n10\n) {\n                JW = out[j] / \n10\n;\n                out[j] %= \n10\n;\n            }\n            \n//i\nf (out[j] > \n10\n) \nexit\n(\n0\n);\n//\ntest\n            \n//i\nf (JW > \n10\n) \nexit\n(\n0\n);\n//\ntest\n        }\n\n        \n    }\n\n\n\n    \n//\nworking\n    int j = \n0\n;\n    \nwhile\n (out[longest_out] == \n0\n && longest_out > \n0\n) {\n        longest_out--;\n    }\n    \nfor\n (int i = longest_out; i >= \n0\n; i--) {\n        ResultGet[j] = out[i] + \n'0'\n;\n        \n//\nprintf(\n\"%d\"\n,out[i]);\n        j++;\n    }\n    ResultGet[j] = \n'\\0'\n;\n}\nint main() {\n    \n//i\nnt T;\n    static char a[N], b[N], out[\n2\n * N];\n    /*\n    scanf(\n\"%d\"\n, &T);\n    \nfor\n (int i = \n1\n; i <= T; i++) {\n        scanf(\n\"%s%s\"\n, a, b);\n        BigPlus(a, b, out);\n        printf(\n\"Case %d:\\n%s + %s = %s\\n\\n\"\n, i, a, b, out);\n    }\n    */\n    \nwhile\n (\n1\n) {\n        scanf(\n\"%s%s\"\n, a, b);\n        BigMultiply(a, b, out);\n        printf(\n\"%s\"\n, out);\n        putchar(\n'\\n'\n);\n    }\n\n    return \n0\n;\n}\n\n", "Tag": "算法分析"}
{"Answer": "递归条件改一下\nif (s/10!= 0)\n        constest(s / 10);\n", "Konwledge_Point": "算法与数字", "Question": "c++递归算法 整形数字 转换 字符串\n题目：用递归法将一个整数 n 转换成字符串，例如：输入483,应输出字符串\"483\"。n的位数是不确定的。\n问题：输出后开头多出来一个 0 ，why?\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\n\nvoid\n \nconstest\n(\nint\n s)\n\n\n{\n    \nint\n t;\n    \nchar\n a;\n    \nif\n (s != \n0\n)\n        \nconstest\n(s / \n10\n);\n    t = s % \n10\n;\n    a = t + \n'0'\n;\n    cout << a;\n}\n\n\nint\n \nmain\n()\n\n\n{\n    \nint\n s;\n    cout << \n\"输入整数: \"\n;\n    cin >> s;\n    \nconstest\n(s);\n}\n\n\n", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/u010551600/article/details/80507271", "Konwledge_Point": "算法与数字", "Question": "关于边缘检测中canny算法中极大值抑制的问题\nCanny算法通过对梯度大小取极大值来达到边缘‘’瘦身‘’的目的，有个疑问希望高手能解答，这是从百度百科粘过来的图，\n\n\n\n数字表示梯度幅值，方向表示梯度方向，百度上搜到的边缘“瘦身”方法举例为，比如第二排第3列。它的梯度方向是向上，因此比较它与上下的两个梯度幅值大小（5，4），7为极大值，因此被保留。\n\n\n\n问题来了，比如说第3排第4列中大小为3，方向向上的元素，它与与之相邻的上下两个元素做比较，向上的3与45°的1怎么去比较呢？\n\n\n\n希望高手指点下。。。", "Tag": "算法分析"}
{"Answer": "这题目用动态规划都不行, 只能从结果上找规律,直接推算了,时间复杂度O(n)规律是前面30个值为1,2,3,5,8,12,19,30,47,74,116,182,286,449,705,1107,1738,2729,4285,6728,10564,16587,26044,40893,64208,100816,158296,248548,390257,612761前面2个值为1,2,第3到5个值为前面两个值之和,第6到7个值为前面两个值之和减1.第7个之后的值为前面两个值之和减前面第7个值\nn = int(input(\"请输入一个整数n：\"))\ndef pf(n):\n    if n<=0:\n        return 0\n    res = [1,2]\n    for i in range(2,n):\n        if i < 5:\n            t = 0\n        elif i < 7:\n            t = 1\n        else:\n            t = res[i-7]\n        res.append(res[i-1]+res[i-2]-t)\n    return res[n-1]\n\ncount = pf(n)\nprint(n,\"点伤害的方案总数:\",count)\n\n\n如有帮助，请点击我的回答下方的【采纳该答案】按钮帮忙采纳下，谢谢!\n", "Konwledge_Point": "算法与数字", "Question": "Python爬楼梯算法\n投篮得1分，远距离投篮得2分，但他由于他技术有限，不能连续3次远距离投篮，问小明成功得n分的方案数。\n\n\n输入格式:\n一行，一个数字，表示n。\n\n\n输出格式:\n输出造成n点伤害的方案总数。", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/zhaihao1996/article/details/52004906", "Konwledge_Point": "算法与数字", "Question": "这个素数数字的算法，和一般的不太一样，它是基于不同的进制的，怎么算？\nProblem Description\n\nFermat's theorem states that for any prime number p and for any integer a > 1, a^p == a (mod p). That is, if we raise a to the pth power and divide by p, the remainder is a. Some (but not very many) non-prime values of p, known as base-a pseudoprimes, have this property for some a. (And some, known as Carmichael Numbers, are base-a pseudoprimes for all a.) \n\nGiven 2 < p ≤ 1,000,000,000 and 1 < a < p, determine whether or not p is a base-a pseudoprime. \n\n\n\nInput\n\nInput contains several test cases followed by a line containing \"0 0\". Each test case consists of a line containing p and a.\n\n\n\nOutput\n\nFor each test case, output \"yes\" if p is a base-a pseudoprime; otherwise output \"no\". \n\n\n\nSample Input\n\n3 2\n\n10 3\n\n341 2\n\n341 3\n\n1105 2\n\n1105 3\n\n0 0\n\n\n\nSample Output\n\nno\n\nno\n\nyes\n\nno\n\nyes\n\nyes", "Tag": "算法分析"}
{"Answer": "\nI have no actual experience that might help you with this, though since you're asking for some insight, I'll share my thoughts on how to do this.\nAs I typed my answer, I realised that this is in fact a knapsack problem, which means you can solve it to optimality using any algorithm that solves the knapsack problem. I recommend using dynamic programming to make your program run faster.\nWhat you need to do is construct all numbers you can generate by combining two numbers with an operator, so that after this you have a list containing the numbers you started with, and the numbers you generated.\nThen you solve the knapsack problem using the numbers as items with their value as their weight, and the number as the weight you can store at most.\nThe only thing that is slightly different is that you have an extra constraint that says that you may only use a number once. So you need to add into your implementation that if you add a combination of numbers, that you must remove the option of storing another combination that is constructed with the same number.\n", "Konwledge_Point": "算法与数字", "Question": "从6个随机数中计算出随机的三位数？\n\n\n\nI have 4 years PHP and C# experience, but Math is not my better side.\nI thnik that i need in this project use some math algorithms.\n\n\n\nWhen page load I need randomly create 7 numbers, 6 are numbers that I can use to calculate given three digit number:\n\n\n\n\n\nrand 1-9 \n\n\nrand 1-9 \n\n\nrand 1-9 \n\n\nrand 1-9 \n\n\nrand 10-100 //5 steps \n\n\nrand 10-100 //5 steps\n\n\n\n\nand given number to calculate is 100-999,\n\n\n\nI can use this operations: \n+, -, /, *, (, )\n\n\n\nWhat is best algorithm for this? \nI probably need to try all possible combinations with this 6 numbers to calculate given number or closest number of calculations.\n\n\n\nexample:\nlet say that given three digit number is \n350, and I need to calculate this number from this numbers:\n3,6,9,5 10, 100\nso formula for this is:\n(100*3)+(5*10) = 350\n\n\n\nif is not possible to calculate exact number, than calculate closest.\n\n\n\nYou don't need to solve this problem completely, you can introduce me to solve this problem by paste some pseudo, or describing how to do that.\n\n    ", "Tag": "算法分析"}
{"Answer": "你说随机算法为啥叫随机呢？除非你知道他用的随机算法是什么，不然你就只能模拟，或者又大批数据量来找看下是否为假随机。\n另外，网页游戏的话，看随机程序是跑在你网页代码里面的还是服务器端，服务器端基本上没辙，网页端直接F12改源码。", "Konwledge_Point": "算法与数字", "Question": "关于#哈希算法#的问题：网页游戏中怪物为八个 我们把怪物用1-8数字来表达 现在可以看到1-8的怪物是随机出现的 该游戏引用随机算法  随机算法有公式吗 随机算法可以破解吗 如果可以应该使用什么工具\n网页游戏中怪物为八个 我们把怪物用1-8数字来表达 现在可以看到1-8的怪物是随机出现的 该游戏引用随机算法  随机算法有公式吗 随机算法可以破解吗 如果可以应该使用什么工具", "Tag": "算法分析"}
{"Answer": "class Solution {\r\n\t/*\r\n\t *N 表示地图大小\r\n\t *S 表示船只的大小\r\n\t *T 表示被命中的位置\r\n\t * N = 4，S =“1B 2C，2D 4D”和T =“2B 2D 3D 4D 4A”\r\n\t * */\r\n\tpublic static String solution(int N,String S,String T) throws Exception{\r\n\t\tint hitShipLostCount = 0;\r\n\t\tint hitShipRunCount = 0;\r\n\t\t//获取没亮船只\r\n\t\tif(S != null && S != \"\"){\r\n\t\t\tString[] ships = S.split(\",\");\r\n\t\t\t//遍历船只，获取船只的每个位置\r\n\t\t\tfor (String ship : ships) {\r\n\t\t\t\t//获取船只最小位置\r\n\t\t\t\tString shipMin = ship.substring(0,ship.indexOf(\" \"));\r\n\t\t\t\tint xMin = Integer.valueOf(shipMin.charAt(0) + \"\");\r\n\t\t\t\tchar yMin = shipMin.charAt(1);\r\n\t\t\t\t\r\n\t\t\t\t//获取船只最大位置\r\n\t\t\t\tString shipMax = ship.substring(ship.indexOf(\" \") + 1);\r\n\t\t\t\tint xMax = Integer.valueOf(shipMax.charAt(0) + \"\");\r\n\t\t\t\tchar yMax = shipMax.charAt(1);\r\n\t\t\t\tif(xMax <= N){\r\n\t\t\t\t\t//定义集合保存船只的位置\r\n\t\t\t\t\tList shipPieces = new ArrayList();\r\n\t\t\t\t\tfor (int i = xMin; i <= xMax; i++) {\r\n\t\t\t\t\t\tfor (int j = yMin; j <= yMax; j++) {\r\n\t\t\t\t\t\t\tString s = (char)j + \"\";\r\n\t\t\t\t\t\t\tshipPieces.add(i + s);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t//获取被炮弹命中的位置,并去掉重复的\r\n\t\t\t\t\tSet shells = new HashSet();\r\n\t\t\t\t\tString[] shellsArr = T.split(\" \");\r\n\t\t\t\t\tfor (String shell : shellsArr) {\r\n\t\t\t\t\t\tshells.add(shell);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t//用于记录船只被击中的碎片数\r\n\t\t\t\t\tint count = 0;\r\n\t\t\t\t\tfor (String shipPiece : shipPieces) {\r\n\t\t\t\t\t\tfor (String shell : shells) {\r\n\t\t\t\t\t\t\tif(shipPiece.equals(shell)){\r\n\t\t\t\t\t\t\t\tcount ++ ;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t//被击中沉没船只的数量\r\n\t\t\t\t\tif(count == shipPieces.size()){\r\n\t\t\t\t\t\thitShipLostCount ++ ;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t//击中未沉没船只的数量\r\n\t\t\t\t\tif(count > 0 && count < shipPieces.size()){\r\n\t\t\t\t\t\thitShipRunCount ++ ;\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthrow new Exception(\"船只还没有完全进入地图\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\treturn hitShipLostCount + \",\" + hitShipRunCount;\r\n\t}; \r\n\t\r\n\tpublic static void main(String[] args) {\r\n\t\ttry {\r\n\t\t\tString answer = solution(4,\"1B 2C,2D 4D\",\"2B 2D 3D 4D 4A\");\r\n\t\t\tSystem.out.println(answer);\r\n\t\t} catch (Exception e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\t\r\n\t}\r\n}\r\n\r\n```\r\n \r\n```", "Konwledge_Point": "算法与数字", "Question": "Java 小白求编写一道算法题 能运行出结果立即采纳\n这是一道Java算法测试题，只是题目有点长，但看着图片和例子，耐心多读一下就能很容易明白，同学都说题目不难，但本人实在是小白，特此求助，能编写运行出结果立即采纳给分，拜托了。\n\n\n\n现有大小为N行的正方形地图，编号从1到N，每行包含N个单元格，每列标有连续的英文大写字母（A，B，C等）。每个单元格通过行编号及列编号组成的串来标识：例如，“9C” 表示第9行中的第三单元,“15D”表示第15行中的第四单元。\n\n\n\n如下图所示，现有几个最大面积不超过4个单元格组成的矩形，X表示被标记的单元格。\n\n\n\n目标是计算 被X标记且标记满的矩形的数量 和 被X标记但未被标记满的矩形数量。（请看例子）\n\n\n\n例如，下图显示了一个大小为N = 4的地图，两个蓝色矩形（一个正方形，一个长方形）和五个用字母“x”标记的单元格;\n\n\n\n\n\n\n在这个例子中，长方形的三个单元格已经被标记满，正方形只有一个单元格被标记，但未被标记满。在下一张图片中，标记满的矩形被显示为灰色，未标记满的矩形显示为红色：\n\n\n\n\n\n\n用字符串S表示矩形的位置，其分别包含描述矩形的左上角和右下角单元格的位置对。矩形之间用逗号分隔。如上图，S =“1B 2C，2D 4D”。字符串T表示被标记的单元格的位置，包含描述被击中的地图单元的位置：如图，T =“2B 2D 3D 4D 4A”。 S中的矩形和T中的被标记单元格可以以任何顺序出现。\n\n\n\n写一个函数：\n\n\n\nclass Solution {public String solution（int N，String S，String T）; ｝\n\n\n\n设地图的大小为N,字符串S描述矩形位置,T描述被标记的单元格，要求返回具有两个数字的字符串：被标记满的矩形的数量和被标记但未被标记满的矩形数量，用逗号分隔。\n\n\n\n例如，假设N = 4，S =“1B 2C，2D 4D”和T =“2B 2D 3D 4D 4A”，您的函数应返回“1,1”，如上所述。", "Tag": "算法分析"}
{"Answer": "没必要动态数组，你改用全局变量，int a[200000]这样，快点，最多空间应该用到0.76MB，没有超；每次动态数组申请浪费时间", "Konwledge_Point": "算法与数字", "Question": "请教用c++的vector如何实现（如图有时间限制哦）\n题目截图如下：\n\n\n本人第一次写数据结构代码，不知道如何用vector解决问题。目前（超时代码）如下：\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\nusing\n \nnamespace\n std;\n\n\nint\n \nmain\n()\n\n\n{\n    \nint\n n, m;\n    cin >> n >> m;\n    \nint\n* a = \nnew\n \nint\n[n];\n    \nint\n* b = \nnew\n \nint\n[n];\n    \nint\n* x = \nnew\n \nint\n[m];\n    \nint\n* y = \nnew\n \nint\n[m];\n    \nfor\n (\nint\n i = \n0\n;i < n;i++)\n    {\n        cin >> a[i] >> b[i];\n    }\n    \nfor\n (\nint\n i = \n0\n;i < m;i++)\n    {\n        cin >> x[i] >> y[i];\n    }\n    \nfor\n (\nint\n i = \n0\n;i < m;i++)\n    {\n        \nint\n lo=\n0\n, hi=n;\n        \nwhile\n (\n1\n < hi-lo)\n        {\n            \nint\n mi = (hi + lo) >> \n2\n;\n            \nlong\n \nlong\n \nint\n t;\n            t = (\nlong\n \nlong\n)b[mi] * (\nlong\n \nlong\n)x[i] + (\nlong\n \nlong\n)a[mi] * (\nlong\n \nlong\n)y[i] - (\nlong\n \nlong\n)a[mi] * (\nlong\n \nlong\n)b[mi];\n            \nif\n (t >= \n0\n)\n                lo = mi + \n1\n;\n            \nelse\n\n                hi = mi;\n        }\n        \nlong\n \nlong\n \nint\n t;\n        t = (\nlong\n \nlong\n)b[lo] * (\nlong\n \nlong\n)x[i] + (\nlong\n \nlong\n)a[lo] * (\nlong\n \nlong\n)y[i] - (\nlong\n \nlong\n)a[lo] * (\nlong\n \nlong\n)b[lo];\n        \nif\n (t >= \n0\n)\n            cout << lo + \n1\n << endl;\n        \nelse\n\n            cout << lo << endl;\n    }\n    \ndelete\n []a, b, x, y;\n    \nreturn\n \n0\n;\n}\n\n", "Tag": "算法分析"}
{"Answer": "其实这个题不难，可以考虑用2进制的方式来做。\r\ng()\r\n{\r\nreturn 4*f()+2*f()+f();\r\n}\r\n\r\n希望能帮到你。", "Konwledge_Point": "算法与数字", "Question": "求一个面试算法题答案。\n已知函数f()以相同的概率返回0或者1，求一个函数g()以相同的概率返回0-7之间的任意一个数字。", "Tag": "算法分析"}
{"Answer": "#include<iostream>\nusing namespace std;\nint main () {\n    int n, a;\n    while(1) {\n        cin >> n;\n        if(n == 0) return 0;\n        int f = 1, s = 0;\n        for(int i = 0; i < n; i++) {\n            cin >> a;\n            if(a >= 60 && a <= 100) {\n                s += a;\n            } else if(a < 0 || a > 100) {\n                f = 0;\n            }\n        }\n        if(f == 1) {\n            cout << s << endl;\n        } else {\n            cout << \"N\" << endl;\n        }\n    }\n    return 0;\n}\n", "Konwledge_Point": "算法与数字", "Question": "C++基础题 帮帮忙看一下 .在.线.等.待.\n\n\n                                                   武提交：\n277\n 则试通过：\n70\n\n描述\n  读入\nn\n（\n0\n<\nn\n<=\n20\n）门课程的成绩ai（\n0\n<=ai<=\n100\n）。输出所有大于或等于\n60\n分的成绩之和。如果其中有一门及以上成\n  绩中有小于\n0\n分或者大于\n100\n分的情况，则直接输出\nN\n”\n输入\n 读入有多组，以\nn\n==\n0\n为结束\n 每组数据占\n2\n行，第\n1\n行为\nn\n，第\n2\n行为\nn\n个整数\n输出\n 输出及格的总分或\nN\n”\n样例输入\n  \n4\n\n \n60\n \n50\n \n70\n \n40\n\n \n90\n \n60\n \n80\n \n110\n\n \n0\n\n样例输出\n \n130\n\n  \nN\n\n", "Tag": "算法分析"}
{"Answer": "有2种方法第一种就是再开辟一个与datas相同长度的数组(datax)。这个数组里面都是二进制。假设datas的长度，datax长度为3\r\n将datax从 000 001 010 011 100 101 110 111 只要末尾不断加1再不超过2\r\n然后将datas的相应位置与datax的相应位置的数据相乘\r\n若datas数据为 1 2 3 min -- 2 max --4 count -- 2\r\ndatax 000 001\t 010\t\t  011     \t100       101 \t\t      110 \t       \t111\r\nsum    0   1*3   1*2\t\t 1*2+1*3\t1*1\t\t1*1+1*3\t\t1*1+1*2\t\t1*1+1*2+1*3\r\n只要sum>=min&∑<=max至于count只要在符合sum的前提下datax的1的个数<=count就行\r\n\r\n另外一种是回溯法原理和上面类似\r\n\r\n\r\n\r\n\r\n```\r\n\r\n\r\n\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\npublic class A {\r\n\tpublic static Integer[] datas = new Integer[]{1,2,3,4,5,6,7,8,9,10,11};\r\n\tpublic static Integer[] datasx = new Integer[datas.length];\r\n\tpublic static Integer y = 100;\r\n\tpublic static void main(String[] args) {\r\n\r\n        Integer min = 6;\r\n        Integer max = 12;\r\n        Integer count = 3;\r\n        List> test = three(datas, min, max, count);\r\n        \r\n        \r\n        for(List list : test){\r\n        \tfor(Integer t:list){\r\n        \t\tSystem.out.print(\"[\"+t+\"]\");\r\n        \t}\r\n        \tSystem.out.println();\r\n        }\r\n\r\n\t\t\r\n       // dox(32,min,max,3);\r\n\r\n    }\r\n\r\n    \r\n    \r\n    public static List> three(Integer datas[], Integer min, Integer max,Integer count){\r\n        List result = new ArrayList();\r\n        List> list  = new ArrayList>();\r\n        double b = (double)datas.length;\r\n        Integer u = (int)Math.pow(2.0, b)-1;\r\n        System.out.println(\"wjc\"+u);\r\n        int y = 0;\r\n        while(y < u){\r\n        \ty+=1;\r\n        \tresult = dox(y,min,max,count);\r\n        \tif(result != null){\r\n        \t\tlist.add(result);\r\n        \t}\r\n        \t\r\n        }\r\n        return list;\r\n    }\r\n\tprivate static List dox(int parseInt,Integer min, Integer max,Integer count) {\r\n\t\t// TODO Auto-generated method stub\r\n\t\t\r\n\t\t List result1 = new ArrayList<>();\r\n\t\t int sum = 0;\r\n\t\t int j = 0;\r\n\t\t int y = 0;\r\n\t\t int p;\r\n\t\t for(int i = 0;icount){\r\n\t\t\t return null;\r\n\t\t }\r\n\t\t \r\n\t\t while(parseInt>0){\r\n\t\t\t p = parseInt%2;\r\n\t\t\t parseInt = parseInt/2;\r\n\t\t\t if(p == 1){\r\n\t\t\t\t y++;\r\n\t\t\t\t result1.add(datas.length-1-j);\r\n\t\t\t }\r\n\t\t\t datasx[j++] = p; \r\n\t\t } \r\n\t\t \r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t for(int i = datasx.length-1;i>=0;i--){\r\n\t\t//\tSystem.out.print(datasx[i]);\r\n\t\t\t sum += datas[datas.length-1-i]*datasx[i];\r\n\t\t }\r\n\t\t//System.out.println();\r\n\t\t//System.out.println(sum);\r\n\t\t if(sum >= min && sum <=max){\r\n\t\t\t return result1;\r\n\t\t }\r\n\t\t return null;\r\n\t}\r\n\r\n}\r\n\r\n\r\n```\r\n上面的代码是我说的第一种方法", "Konwledge_Point": "算法与数字", "Question": "java 从数组取出指定数量的值，相加大于等于或小于等于指定的值，取出对应的组合下标，下标不能重复\nInteger[] datas = new Integer[]{1,2,3,4,5,6,7,8,9,10,11}；//目标数组\n\nInteger min = 6;//大于等于的值\n\nInteger max = 12;//小于等于的值\n\nInteger count = 3;//指定数量\n\n\n\n根据count如：3,3个数相加大于等于min小于等于max，2个数相加大于等于min小于等于max，1个数相加大于等于min小于等于max。\n\n如果count=2,2个........,1ge.........。\n\n返回List。\n\n\n\n下面代码是我写死，我想知道怎样写活【count】\n\n\n\npublic static void main(String[] args) {\n        Integer[] datas = new Integer[]{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19};\n        Integer min = 6;\n        Integer max = 12;\n        Integer count = 3;\n        List test = test(datas, min, max, count);\n        for(Integer[] integers : test){\n            for(Integer t : integers){\n                System.out.print(\"[\"+t+\"]\");\n            }\n            System.out.println(\"\");\n        }\n\n    }\n    public static List test(Integer[] datas, Integer min, Integer max, Integer count){\n        List result = new ArrayList<>();\n        switch (count){\n            case 1:\n                result.addAll(one(datas, min, max));\n                break;\n            case 2:\n                result.addAll(one(datas, min, max));\n                result.addAll(two(datas, min, max));\n                break;\n            case 3:\n                result.addAll(one(datas, min, max));\n                result.addAll(two(datas, min, max));\n                result.addAll(three(datas, min, max));\n                break;\n        }\n        return result;\n    }\n\n    public static List one(Integer[] datas, Integer min, Integer max){\n        List result = new ArrayList<>();\n        for(int i = 0,len = datas.length; i < len; i++){\n            if(datas[i] >= min && datas[i] <= max){\n                result.add(new Integer[]{i});\n            }\n        }\n        return result;\n    }\n\n    public static List two(Integer[] datas, Integer min, Integer max){\n        List result = new ArrayList<>();\n        for(int i = 0,len = datas.length; i < len; i++){\n            for(int j = 1 + i; j < len; j++){\n                Integer num = datas[i] + datas[j];\n                if(num >= min && num <= max){\n                    result.add(new Integer[]{i,j});\n                }\n            }\n        }\n        return result;\n    }\n\n    public static List three(Integer datas[], Integer min, Integer max){\n        List result = new ArrayList<>();\n        for(int i = 0,len = datas.length; i < len; i++){\n            for(int j = 1 + i; j < len; j++){\n                for(int k = 1 + j; k < len; k++){\n                    Integer num = datas[i] + datas[j] + datas[k];\n                    if(num >= min && num <= max){\n                        result.add(new Integer[]{i,j,k});\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n\n\n\n输出的【下标】组合\n\n\n\n[5]\n[6]\n[7]\n[8]\n[9]\n[10]\n[11]\n[0][4]\n[0][5]\n[0][6]\n[0][7]\n[0][8]\n[0][9]\n[0][10]\n[1][3]\n[1][4]\n[1][5]\n[1][6]\n[1][7]\n[1][8]\n[1][9]\n[2][3]\n[2][4]\n[2][5]\n[2][6]\n[2][7]\n[2][8]\n[3][4]\n[3][5]\n[3][6]\n[3][7]\n[4][5]\n[4][6]\n[0][1][2]\n[0][1][3]\n[0][1][4]\n[0][1][5]\n[0][1][6]\n[0][1][7]\n[0][1][8]\n[0][2][3]\n[0][2][4]\n[0][2][5]\n[0][2][6]\n[0][2][7]\n[0][3][4]\n[0][3][5]\n[0][3][6]\n[0][4][5]\n[1][2][3]\n[1][2][4]\n[1][2][5]\n[1][2][6]\n[1][3][4]\n[1][3][5]\n[2][3][4]\n\n", "Tag": "算法分析"}
{"Answer": "我看是对的！\r\n```\r\nstruct Results solution(int T[],int M)\r\n{\r\n\tint cap = 0;\r\n\tint* res = (int*)malloc((M-1)*sizeof(int));\r\n\tfor(int i=0;iA = res;\r\n\trs->N = M-1;\r\n\r\n\treturn *rs;\r\n}\r\n```", "Konwledge_Point": "算法与数字", "Question": "c语言小白求解一道算法题，能编写运行出结果立即采纳给分\n这是一道C语言算法测试题，题目有点长，但看着图片和例子，耐心多读一下就能很容易理解，同学都说题目不难，但本人实在是小白，特此求助，能编写运行出正确结果则采纳给分，拜托了。同学说这道题要用 动态数组malloc创建。 \n\n\n\n一个网络由M个城市和M-1条连接它们的道路组成的。城市在 [0 …（M-1) ]范围内用不同的整数标记。\n\n\n\n如下图，道路以这样的方式连接城市，每对不同的城市通过道路组成的路径连接。只有一种方法可以从任何城市到达任何其它城市。必须经过的“直接道路”的数量被称为这两个城市之间的距离。\n\n\n\n例如，考虑以下由十个城市和九条道路组成的网络：\n\n\n\n\n\n\n城市2和4直接相连，因此它们之间的距离是1.城市4和7通过由“直接道路” 4-0, 0-9和 9-7组成的路径连接; 因此它们之间的距离为3。\n\n\n\n其中一个城市是首都，此题目标是计算在距离首都 1,2,3，...，M-1的每个距离处的城市的数量。\n\n\n\n如图，如果数字1是首都，那么离首都不同距离的城市将如下：\n\n\n\n9处于距离1;\n\n0,3,7处于距离2;\n\n8,4在距离3;\n\n2，5，6距离为4。\n\n\n\n假设给出以下声明：\n\n\n\nstruct Results  {\n\n\n\nint ＊ A;\n\nint N.\n\n};\n\n（A代表需要返回的数组，N代表数组的大小）\n\n要求写一个函数\n\n\n\nstruct Results solution（int T [ ]，int M），\n\n\n\n给定由M个整数组成的非空的零索引数组T（描述M个城市和M-1条道路组成的网络），返回由M-1个整数组成的数组（表示距离首都1,2，…，M-1的每个距离处的城市数目）。\n\n\n\n数组T描述了一个城市网络，如下所示：\n\n\n\n如果T [P] = Q且P = Q，则P是首都;\n\n如果T [P] = Q且 P不等于Q，则P和Q之间存在“直接道路”\n\n\n\n例如，给定以下由十个元素组成的数组T; （请详细看此例）\n\n\n\nT [0] = 9  T [1] = 1  T [2] = 4\n\nT [3] = 9  T [4] = 0  T [5] = 4\n\nT [6] = 8  T [7] = 9  T [8] = 0\n\nT [9] = 1\n\n\n\n因为 T [1] = 1且1=1，则此时1为首都，\n\n则该函数应返回[1，3，2，3，0，0，0，0，0]，如上所述。\n\n\n\n假设：\n\nM是在范围[1 ... 100,000]内的整数;\n\n数组T的每个元素是在范围[0 ... M-1]内的整数;\n\n在任何两个不同的城市之间只有一个（可能是间接的）连接。\n\n\n\n复杂度：\n\n\n\n预期最坏情况时间复杂度为O（M）;\n\n预期的最坏情况空间复杂度为O（M），超出输入存储（不计算输入参数所需的存储）。\n\n\n\n输入数组的元素可以修改。", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/wmn_wmn/article/details/7371607", "Konwledge_Point": "算法与数字", "Question": "2^x mod n = 1              \nGive a number n, find the minimum x that satisfies 2^x mod n = 1.\n\n\n\nInput\n\n\n\nOne positive integer on each line, the value of n.\n\n\n\nOutput\n\n\n\nIf the minimum x exists, print a line with 2^x mod n = 1.\n\n\n\nPrint 2^? mod n = 1 otherwise.\n\n\n\nYou should replace x and n with specific numbers.\n\n\n\nSample Input\n\n\n\n2\n\n5\n\n\n\nSample Output\n\n\n\n2^? mod 2 = 1\n\n2^4 mod 5 = 1", "Tag": "算法分析"}
{"Answer": "```\r\n public bool sortVector(ref list sourceData)\r\n{\r\n  bool isSuccess = false;\r\n\tif(null != sourceData)\r\n\t{\r\n\ttry\r\n\t{\r\n  list tem;\r\n\tdictionary dicBlob = new dictionary;\r\n\tforeach(var item in sourceData)\r\n\t{\r\n\tif(dicBlob.Contains(item))\r\n\t{\r\n\t dicBlob[item.ToString()].value += 1;\r\n\t}else\r\n\t{\r\n\t\tdicBlob.Add(item.ToString(),1);\r\n\t}\r\n\t}\r\n\tdicBlob.OrderDesc(r => r.value);\r\n\tforeach(var item in dicBlob.KeyArray)\r\n\t{\r\n\t\ttem.Add(item);\r\n\t}\r\n\tsourceData = tem;\r\n\t\r\n\t}catch(exception ex)\r\n\t{\r\n\t return false;\r\n\t}\r\n\t}\r\n\treturn isSuccess;\r\n}\r\n\r\n```", "Konwledge_Point": "算法与数字", "Question": "排序问题，给出详细算法过程\n给出算法详细过程，编写一个程序，出现次数越多，数字越大的排在前面。", "Tag": "算法分析"}
{"Answer": "int sum;要初始化，改为 int sum = 0;", "Konwledge_Point": "算法与数字", "Question": "求解怎么写，数字排序，我的代码错哪了\n题目6：数字排序\n问题描述\n　　给定n个整数，请计算每个整数各位数字和，按各位数字和从大到小的顺序输出。\n输入格式\n　　输入的第一行包含一个整数n，表示给定数字的个数。\n　　第二行包含n个整数，相邻的整数之间用一个空格分隔，表示所给定的整数。\n输出格式\n　　输出多行，每行包含两个整数，分别表示一个给定的整数和它的各位数字和。按各位数字和递减的顺序输出。如果两个整数各位数字和相同，则先输出值较小的，然后输出值较大的。\n样例输入\n5\n101 100 999 1234 110\n样例输出\n999 27\n1234 10\n101 2\n110 2\n100 1\n评测用例规模与约定\n　　1 ≤ n ≤ 1000，给出的数都是不超过10000的非负整数。", "Tag": "算法分析"}
{"Answer": "\n#include <string.h>\n#include <stdio.h>\n\ntypedef struct _node\n{\n    char *data;\n    int length;\n} Node;\n\nint main()\n{\n    Node head = {0};\n    head.data = (char *)malloc(100 * sizeof(char));\n    int i = 0;\n    char ch;\n    while (i < 100 && (ch = getchar()) != '\\n')\n    {\n        if (ch == ' ')\n            continue;\n        head.data[i++] = ch;\n    }\n    head.length = i;\n\n    for (i = 0; i < head.length - 1; i++)\n    {\n        for (int j = i + 1; j < head.length; j++)\n        {\n            if (head.data[i] == head.data[j])\n            {\n                memcpy(&head.data[j], &head.data[j + 1], head.length - j);\n                head.length--;\n                i--;\n            }\n        }\n    }\n    char *p = (char *)malloc(head.length * sizeof(char));\n    memcpy(p, head.data, head.length);\n    free(head.data);\n    head.data = p;\n\n    for (i = 0; i < head.length; i++)\n    {\n        printf(\"%c \", head.data[i]);\n    }\n\n    return 0;\n}\n", "Konwledge_Point": "算法与数字", "Question": "数据结构中线性表在不知道长度的时候怎么输入数据(语言-c语言)\n\n\n我用循环输入没有输出，刚刚开始学，希望可以解答一下，求指教😊😊非常感谢", "Tag": "算法分析"}
{"Answer": "（1）n较大时，fun函数中的t仍然是int类型，计算结果超出int数据类型范围了，把t也改成double类型。（2）你的fun函数代码逻辑应该是有问题，需要在第二层for循环之前，把t重置为1；也就是把t=1放在第二层for循环之前。（3）fun函数中sn 没有初始化就用了，需要先初始化为0代码修改如下（修改部分有注释）：\ndouble fun(int n)\n{\n    double sn=0,t; //(1)t改成double类型,sn初始化为0\n    int i;\n    \n    for(i=1;i<=n;i++){\n        t=1; //（2） t=1放在这里，这样才能保证每次计算的都是i的阶乘\n        int j;\n        for(j=1;j<=i;j++){\n            t*=j;\n        }\n        sn+=1.0/t;\n    }\n    return sn;\n}\n\n", "Konwledge_Point": "算法与数字", "Question": "为什么n输入较大的时候就会输出错误\n#include\n#include\ndouble fun(int );\nint main()\n{\n int n;\n double s;\n printf(\"输入一个正整数\");//大于1但小于100\n scanf(\"%d\",&n);\n s=fun(n);\n printf(\"%.6f\",s);\n return 0;\n}\ndouble fun(int n)\n{\n double sn;\n int i,t;\n t=1;\n for(i=1;i<=n;i++){\n  int j;\n  for(j=1;j<=i;j++){\n   t*=j;\n  }\n  sn+=1.0/t;\n }\n return sn;\n}", "Tag": "算法分析"}
{"Answer": "\nYou could use array_multisort in two passes:\n\nFirst sort by \"Answer Match\" and \"Responses\"\nAdd a new column to the data: the sequence number within a group of same \"Answer Match\" values\nSort again, but now by that new column, and then \"Answer Match\"\n\nHere is the code:\n// Example data\n$data = [\n    [\"Answer Match\" => \"rank 3\", \"Responses\" => \"CB\"],\n    [\"Answer Match\" => \"rank 1\", \"Responses\" => \"CO\"],\n    [\"Answer Match\" => \"rank 1\", \"Responses\" => \"BR\"],\n    [\"Answer Match\" => \"rank 2\", \"Responses\" => \"IR\"],\n    [\"Answer Match\" => \"rank 2\", \"Responses\" => \"AB\"],\n    [\"Answer Match\" => \"rank 3\", \"Responses\" => \"CA\"],\n];\n\n// First sort by \"Answer Match\" and then \"Responses\":\narray_multisort(array_column($data, \"Answer Match\"), \n                array_column($data, \"Responses\"), SORT_DESC, $data);\n\n// Then add a new column to the data, which gives the sequence number \n// within the same group of \"Answer Match\":\nforeach($data as $i => $a) {\n    $data[$i][\"i\"] = (!$i or $a[\"Answer Match\"] != $data[$i-1][\"Answer Match\"]) \n                         ? 1 : $data[$i-1][\"i\"]+1;\n}\n\n// Now sort using that extra column to get the final sort order\narray_multisort(array_column($data, \"i\"), array_column($data, \"Answer Match\"), $data);\n\n// If it bothers you, the extra column can be removed again.\n\n", "Konwledge_Point": "算法与数字", "Question": "按相同的字符串名称和索引位置排序\n\n\n\nI'm trying to sort an array where I have a column with equals strings, and a previous column with the information that should be print according to occurrence. I want to print only the alphabetical order of column 9  and do not take in consideration the alphabetical order from column 8.\n\n\n\nFor example:\n\n\n\ncolumn 9=[rank 1, rank1, rank 2, rank2, rank 3, rank3, ...]\n\ncolumn 8=[CO,      BR,    IR,     AB,    CB,      CA....]\n\n\n\n\nIt should give me this  output below, because I want to print by rank 1, rank 2, rank 3, rank 1, rank 2, rank 3:\n\n\n\nCO IR CB  BR AB CA\n\n\n\n\nHowever, my code take the alphabetic order of column 9 when it find equals strings in column 9. How could I solve. Is there a way to check the index to display the data in that order?\n\n\n\nhere is my code:\n\n\n\nfunction readCsv($fileName){\n\n    $handle = fopen($fileName, \"r\");\n\n\n    $data=array();\n\n    while ($col = fgetcsv($handle, 1000, \",\")) { \n\n        $data[] = [\n\n            'Section' => $col[0],   \n            'Q #' => $col [1],\n            'Q Type' => $col[2],\n            'Q Title' => $col[3],\n            'Q Text' => $col[4],\n            'Bonus' => $col [5],\n            'Difficulty' => $col[6],\n            'Answer' => $col[7],\n            'Answer Match' => $col[8],\n            'Responses'=> $col[9], \n\n        ];      \n\n    }\n\n    unset($data[0]); //skip line 1, header\n    usort($data, 'cmp');\n\n    fclose($handle);\n    return $data;\n}\nob_end_flush();\n\n\n\nfunction cmp($a, $b) {\n\n    return $a['Answer Match'] > $b['Answer Match'] (array_search($a['Answer Match'], $a) < array_search($b['Answer Match'], $b)+1);\n}\n\n\n    ", "Tag": "算法分析"}
{"Answer": "仅供参考：\n//假设有n个人团团围做，从第1个人开始数数，数到第m个人时候，第m个人出列，\n//然后继续从1开始数数，数到第m个人退出\n#include <stdio.h>\n#include <conio.h>\nint i,k,t;\nint n,m;\nstatic char f[1001];//0该座位未出圈,1该座位已出圈\nvoid main() {\n    while (1) {\n        printf(\"Input n m(1000>=n>=m>=1):\");\n        fflush(stdout);\n        rewind(stdin);\n        if (2==scanf(\"%d%d\",&n,&m)) {\n            if (1000>=n && n>=m && m>=1) break;\n        }\n    }\n    t=0;//已出圈总人数\n    i=1;//座位编号\n    k=1;//当前要数的数\n    while (1) {\n        if (0==f[i]) {\n            if (m==k) {\n                t++;\n                f[i]=1;\n                printf(\"%3d \",i);\n                if (0==t%10) printf(\"\\n\");\n                if (t>=n) break;\n            }\n            k++;if (k>m) k=1;\n        }\n        i++;if (i>n) i=1;\n    }\n    cprintf(\"Press any key ...\");\n    getch();\n}\n\n\n", "Konwledge_Point": "算法与数字", "Question": "约瑟夫问题的进阶：加入了一些幸运数字，当同学报到给出的幸运数字的时候，不仅不用出局，而且可以拉一个同学进来，排在他后面,并且从这个同学开始计数。拉进来的同学编号就是刚才出局的同学中编号最小的同学。\n问题详情：\n\n\nn个小朋友坐成一圈，编号从1到n，玩报数游戏，从第一个开始从1报数。报到特定数值（由题目给出）的同学离开，然后从下个同学开始从1报数。问最后剩的小朋友编号是多少？\n这是约瑟夫1的题目，II中加入了一些幸运数字，当同学报到给出的幸运数字的时候，不仅不用出局，而且可以拉一个同学进来，排在他后面,并且从这个同学开始计数。拉进来的同学编号就是刚才出局的同学中编号最小的同学。\n那什么是幸运数字呢？幸运数字就是给定数字中的奇数。\n\n\n输入要求：\n\n\nn（小盆友数目）\nn-1个数字，如果是偶数表示报道这个数字的同学离开。如果是幸运数字则加入一个同学。\n\n\n输出要求：\n\n\n当圈里面只有一个小朋友的时候，输出最后留下同学的编号\n\n\n输入样例：\n\n\n5\n2 3 4 4 2 5 6 8\n\n\n本人只会约瑟夫问题1的解答，就是简单的：\n\n\n约瑟夫问题：有n个人围成一圈，从第一个人开始沿顺时针方向报数（从1到m报数），凡报到m的人退出圈子，问最后留下的是原来第几号的那个人。要求是输入n,m，最后输出第几个人。感觉此问题和上述问题有相似也有进阶，但是思路上存在问题，希望得到帮助！\n\n\n希望有牛人能够帮助解答一下！本人初学C语言，期待着不断进步", "Tag": "算法分析"}
{"Answer": "http://xueshu.baidu.com/s?wd=paperuri:(338d8466d57169d1a3f5c5c14007590c)&filter=sc_long_sign≻_ks_para=q%3D%E5%9F%BA%E4%BA%8E%E7%AE%80%E5%8D%95Petri%E7%BD%91%E5%92%8CgSpan%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E9%A2%91%E7%B9%81%E7%BB%93%E6%9E%84%E6%8C%96%E6%8E%98&tn=SE_baiduxueshu_c1gjeupa&ie=utf-8≻_us=8400883579086322051", "Konwledge_Point": "算法与数字", "Question": "jni结构算法 计算一次的业务流程\n计算一次的业务流程：\n\n    第一步：随机取出1到10的数字n1\n\n        3n1 = n1*2 +n1\n\n        7n1 = 3n1*2+n1\n\n        15n1 = 7n1*2+n1\n\n        ...\n\n        ...共进行15次计算\n\n\n\n第二步：随机取出1到10的数字n2\n    3n2 = n2*2 +n2\n    7n2 = 3n2*2+n2\n    15n2 = 7n2*2+n2\n    ...\n    ...共进行15次计算\n\n第三步：做差并输出：\n    3n1 － 3n2 ＝ x1    输出\n    7n1 － 7n2 ＝ x2    输出\n    ....\n    ....      ＝ x15   输出\n", "Tag": "算法分析"}
{"Answer": "一般是用来获取频谱，频谱有什么用看你实际环境了", "Konwledge_Point": "算法与数字", "Question": "数字信号处理方面问题，数字信号做DFT或者FFT后到底是有什么作用？\n求问数字信号处理方面问题，数字信号做DFT或者FFT后到底是有什么作用？是为了滤波？还是为了还原连续信号？如果通过DFT还原连续信号该用什么算法或者公式？是用傅里叶逆变换吗？但逆变换后不也还是数字信号", "Tag": "算法分析"}
{"Answer": "给你提供一种思路：获取n个随机数n1,n2,n3...，分别对某个数取余并加1作为最后的值，把所有取余得到的值加起来得到sum，\r\n每个人获得的红包=n1/sum*红包\r\n\r\n比如红包总数为100，发给5个人，这5个人对应获得的随机数分别为11，13，5，20，99，对10取余加1\r\n那么第1个人对应的n值为11%10+1=2\r\n其余的人为4，6，1，10\r\nsum=2+4+6+1+10=23\r\n第1个人的红包=2/23*100=8.69\r\n不知道你看懂了没", "Konwledge_Point": "算法与数字", "Question": "php 循环10次随机数，加起来的和要为100，这个怎么写？\n循环10次，每次得到一个随机数，相加要等于100，随机数不能为0，且随机数需有大有小\n\n\n\nfunction randStr($num,$max){\n        $sum = 0;\n        $count = 0;\n        while($sum<$max){\n            $surNum = $num-$count;\n            $rand = mt_rand(1,($max-$sum-$surNum)+1);\n            $sum += $rand;\n            $count++;\n            echo $rand.\"\";\n        }\n        echo $sum;\n    }\n\n    randStr(10,100);\n\n\n\n\n我写的这个，一开始值会特别大，后面就全是2，1，1这种数，我希望得到的结果是7，9，15，3，5这种有大有小的，要怎么做呢？望各位大佬指教", "Tag": "算法分析"}
{"Answer": "https://github.com/guanzhi/GmSSL/ \r\ngmssl开源是基于openssl国密后的开源代码，其中有sm2生成国密证书的代码", "Konwledge_Point": "算法与数字", "Question": "sm2算法生成国密证书的代码\nsm2算法生成国密证书的代码，网上找了好多核心代码都不开源，好气。", "Tag": "算法分析"}
{"Answer": "看着像是，直接把String对象打印出来了。 ", "Konwledge_Point": "算法与数字", "Question": "关于#android-studio#的问题：Android Studio创建简易计算器，运行有输入第一个数字有点击任意算法后输入第二个数字后突然出现（class  java.lang.String).\nAndroid Studio创建简易计算器，运行有输入第一个数字有点击任意算法后输入第二个数字后突然出现（class  java.lang.String).\n\n", "Tag": "算法分析"}
{"Answer": "下面是我的代码，在没有打印的情况下在我机器上是1948ms\r\n[code]\r\n\t\tlong start = System.currentTimeMillis();\r\n\t\tint[] cubeArray = new int[1000];\r\n\t\tfor (int i = 0; i < 1000; i++) {\r\n\t\t\tcubeArray[i] = i * i * i;\r\n\t\t}\r\n\t\tfor (int a = 1; a <= 999; a++) {\r\n\t\t\tfor (int b = a; b <= 999; b++) {\r\n\t\t\t\tfor (int c = b; c <= 999; c++) {\r\n\t\t\t\t\tfor(int d=c+1;d<=999;d++)\r\n\t\t\t\t\t\tif(cubeArray[a]+cubeArray[b]+cubeArray[c]==cubeArray[d]);\r\n//\t\t\t\t\t\t\tSystem.out.printf(\"a=%d,b=%d,c=%d,d=%d\\n\",a,b,c,d);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tSystem.out.println(System.currentTimeMillis()-start);\r\n\t}", "Konwledge_Point": "算法与数字", "Question": "求一道java面试算法题 如下\n求A³+B³+C³=D³   ABCD∈(0-999) 求ABCD\n\n :( 当时想到的最笨的方法就是for循环的嵌套，从效率方面考虑，请教其它算法", "Tag": "算法分析"}
{"Answer": "比较三次是最简单的办法\r\n首先判断ab，然后是bc，再比较ac即可", "Konwledge_Point": "算法与数字", "Question": "Java语言怎么用最简单的算法给3个数字排序呢？需要至少交换3次么？可不可以简化\nJava语言怎么用最简单的算法给3个数字排序呢？需要至少交换3次么？可不可以简化", "Tag": "算法分析"}
{"Answer": "做一个简单的队列，只保留用户最新输入的7个数字\r\n\r\n```\r\nvar array = new Array();\r\n\r\nfunction addItem(item){\r\n\t if(array.length>=7)array.shift()//删除头\r\n\t\tarray.push(item);\r\n}\r\n```\r\n我觉得你可能表达的是这个意思", "Konwledge_Point": "算法与数字", "Question": "js或者java的算法，把未知的个数区分\njs或者java中根据用户输入的数的个数来做横坐标，假如输入的个数是等于7，那么就是7个x点,假如输入的个数大于7，假设为7-1000之间，而横坐标最多显示7个x点，或者小于7个的x点，该如何操作用户输入的大于7个数的数据啊，再重述下，如果输入的小于7个数，那么直接就是可以使用的横坐标，如果输入的是70个数，那么整除10，就是7个点，类似这样的一个整除算法方法，求助...", "Tag": "算法分析"}
{"Answer": "\nchar* bin2hex(int*a){\n    char*numChar=(char*)malloc(sizeof(char)*9);\n    int cnt = 0, tmp=0;\n    while(cnt<32){\n        for(int i=0;i<4;i++){\n            tmp = tmp*2 + a[cnt+i]; \n        }\n        if(tmp<10){\n            numChar[cnt/4] = (char)((int)'0'+tmp);\n        }else{\n             numChar[cnt/4] = (char)((int)'A'+(tmp)-10);\n        }\n        cnt+=4;\n        tmp=0;\n    }\n    numChar[8]='\\0';\n    return numChar;\n}\nint main(){\n    int num[32],cnt=0,time=0;//1个整数32位\n    int a = 136;\n    char*numChar;\n    unsigned tmp = a;\n    while(tmp){\n        num[31-cnt]=tmp&1;\n        tmp>>=1;\n        cnt++;\n    }\n    while(cnt<32){\n        num[31-cnt]=0;\n        cnt++;\n    }\n    for(int i=0;i<32;i++){\n        if(time>0&&time%4==0)\n            printf(\" \");\n        time++;        \n        printf(\"%d\",num[i]);\n    }\n    printf(\"\\n\");\n    numChar=bin2hex(num);\n    printf(\"%s\\n\",numChar);\n    system(\"pause\");\n}\n", "Konwledge_Point": "算法与数字", "Question": "C语言问题求解答（最好有代码）\n", "Tag": "算法分析"}
{"Answer": "可以存在数据库，不过同样的读取后存本地，为了安全可以使用后再删除，不过RSA客户端只要有公钥就行了，私钥只有服务端持有，不会被篡改的，公钥任何人都可以知道。", "Konwledge_Point": "算法与数字", "Question": "RSA算法中的公钥和私钥可以保存在数据库里面吗？\n毕设是网页防篡改系统。\n\n其中有两个模块，备份模块和恢复模块。\n\n\n\n备份模块用私钥对文件的摘要值进行签名，恢复模块用公钥解密摘要值。\n\n\n\n因为两个模块是分开的， 我如何保存公钥和私钥对？ \n\n\n\n可以保存在数据库里面吗？", "Tag": "算法分析"}
{"Answer": "https://wenku.baidu.com/view/3d17722cb4daa58da0114a32.html", "Konwledge_Point": "算法与数字", "Question": "求一个一维下料算法的Java实现\n条件：为多源线材，能够限定每根线材最多几种零件种类\n\n例如：木材料长度有10,12,13\n\n                        要切割成的零件有 3,    4,    5，  6\n\n                        每种零件需求为    15, 16,  18,    20\n\n                        每种母材上只能有2种零件（这个数字可变）\n\n\n\n求指导，求思路，求建议！", "Tag": "算法分析"}
{"Answer": "供参考：\n#include <stdio.h>/*标准输入输出头文件*/\nint main()\n{\n    int number,g,s,b,q,w;\n    printf(\"请输入一个5位整数：\\n\");\n    scanf(\"%d\",&number);/*从键盘接收一个5位整数*/\n    g=number%10;//这句得到     个位数字\n    s=number/10%10; //这句得到 十位数字\n    b=number/100%10;//这句得到 百位数字\n    q=number/1000%10;//这句得到 千位数字\n    w=number/10000%10;//这句得到 万位数字\n    printf(\"逆序输出为：%d\\n\",g*10000+s*1000+b*100+q*10+w);//逆序输出\n    return 0;\n}\n\n", "Konwledge_Point": "算法与数字", "Question": "C语言教材上的的数字倒排算法\n这个算法我实在是看不明白啊\n\n\n#include /*标准输入输出头文件*/\n\n\n\nint\n main()\n{            \n    \nint\n number,g,s,b,\nq\n,w; \n    \nprintf\n(\n\"请输入一个5位整数：\\n\"\n);\n    scanf(\n\"%d\"\n,&number);\n/*从键盘接收一个5位整数*/\n\n    g=number%10;\n/*将m模取10的结果赋值给g*/\n\n    s=number/\n10\n%10; \n/*将m整除10模取10的结果赋值给s*/\n\n    b=number/\n100\n%10;\n    \nq\n=number/\n1000\n%10;\n    w=number/\n10000\n%10;\n    \nprintf\n(\n\"逆序输出为：%d\\n\"\n,g*\n10000\n+s*\n1000\n+b*\n100\n+\nq\n*\n10\n+w);\n//\n逆序输出\n    \nreturn\n \n0\n;\n}\n", "Tag": "算法分析"}
{"Answer": "c语言没有默认参数吧，改为：\r\n\r\n```\r\n#include   \r\nint fun(char *p,int m)\r\n{\r\n\tint n=1;\r\n\tif(*p)\r\n\t{\r\n\t\tn=m*10+*p-'0';\r\n\t\treturn fun(p+1,n);\r\n\t}\r\n\treturn m;\t\r\n}\r\n\r\nvoid main()\r\n{\r\n\tchar str[]=\"1234\";\r\n\tprintf(\"%d\\n\",fun(str,0));\r\n} \r\n```", "Konwledge_Point": "算法与数字", "Question": "C语言递归的数字转换问题，习题求解\nC语言使用递归算法将一个正整数字符串为对应的数值。不得使用循环", "Tag": "算法分析"}
{"Answer": "\n#include <stdio.h>\n#include <conio.h>\n#include <malloc.h>\nint main()\n{\n    int *nums=NULL,*nSave=NULL,i,len=0,n=0,c=0,lc=0,*max,*min,sum=0;\n    double avg = 0.0, maxV = 0.0;\n    printf(\"输入任意数字空格分割(输入回车键结束输入，不支持退格删除):\\n\");\n    while(1)\n    {\n        lc=c;\n        c=getch();\n        if((c==' ' || c=='\\r') && (lc>='0' && lc<='9'))//当前输入字符是空格或者回车且前一个输入的字符是数字，创建内存空间并记录数字\n        {\n            printf(\"%c\",c);\n            if(!nums)\n            {\n                nums=(int *)malloc(sizeof(int));\n                if(!nums)\n                {\n                    printf(\"内存申请失败！\\n\");\n                    return 1;\n                }\n                max=min=&nums[len];\n            }\n            else\n            {\n                nSave=(int *)realloc(nums,sizeof(int)*(len+1));\n                if(!nSave)\n                {\n                    printf(\"内存申请失败！\\n\");\n                    return 1;\n                }\n                nums=nSave;\n                if(*max<n)\n                    max=&nums[len];\n                if(*min>n)\n                    min=&nums[len];\n            }\n            nums[len]=n;\n            n=0;\n            len++;\n        }\n        else if(c>='0' && c<='9')\n            printf(\"%c\",c),n=n*10+c-'0';\n        if(c=='\\r')\n        {\n            printf(\"\\n\");\n            break;\n        }\n\n    }\n    //------打印输入的数组\n    printf(\"输入的数组为：\\n\");\n    for(i=0;i<len;i++)\n        printf(\"%d \",nums[i]);\n    printf(\"\\n\");\n    //------求平均\n    for(i=0;i<len;i++)\n        if(&nums[i]!=max && &nums[i]!=min)\n            sum+=nums[i];\n\n    avg = sum*1.0/(len-2);\n    printf(\"去除最大值和最小值后的平均值为：%f\\n\",avg);\n\n    for(i=0;i<len;i++)\n        if(&nums[i]!=max && &nums[i]!=min)\n            if (abs(nums[i] - avg) > maxV)\n            {\n                maxV = nums[i];\n            }\n    printf(\"去除最大值和最小值后的剩余数与平均值差的绝对值的最大值：%f\\n\",maxV);\n    return 0;\n}\n", "Konwledge_Point": "算法与数字", "Question": "去掉最大，小值求平均值求出与剩余数与平均值差的绝对值的最大值\n算法存在问题，但自己没找出来", "Tag": "算法分析"}
{"Answer": "```\r\ndef deal(data,flag):\r\n    a=[]\r\n    for i in data:\r\n        if i>=flag:\r\n            return [i]\r\n        elif a==[]:\r\n            a.append([i])\r\n        else:\r\n            a=a+[k+[i] for k in a if sum(k)+i<=flag]\r\n            a.append([i])\r\n    #return sorted(a,key=sum)[-1]\r\n    target=sum(max(a,key=sum))\r\n    return list(filter(lambda x:sum(x)==target,a))\r\nif __name__=='__main__':\r\n    c=[2,1,3,1,5,2,3,4]\r\n    flag=sum(c)//2\r\n    res=deal(c,flag)\r\n    print(res)\r\n\r\n```\r\n\r\n算法复杂度最差是N的3次方", "Konwledge_Point": "算法与数字", "Question": "怎样用python实现将一组数尽可能均匀地分成两堆，使两个堆中的数的和尽可能相等？\n麦克叔叔去世了，他在遗嘱中给他的两个孙子阿贝和鲍勃留下了一堆珍贵的口袋妖怪卡片。遗嘱中唯一的方向是“尽可能均匀地分配纸牌的价值”。作为Mike遗嘱的执行人，你已经为每一张口袋妖怪卡片定价，以获得准确的货币价值。你要决定如何将口袋妖怪卡片分成两堆，以尽量减少每一堆卡片的价值总和的差异。\n\n例如，你有下列n=8 个口袋妖怪卡片：\n\n\n\n经过大量的工作，你发现你可以用下面的方法来划分卡片：\n\n\n\n这给了安倍10美元的牌给了鲍勃11美元的牌。这是最好的除法吗?\n\n你要做的是解决n张牌的问题其中每张牌ci都有一个正整数值vi.你的解决方法是计算牌应该如何被分割以及每摞牌的价值。\n\n输入输出示例如下:\n\n\n\n1.通过检查所有可能的桩以蛮力解决此问题。 对这种蛮力算法的时间复杂度进行分析，并通过实施和实验验证您的分析结果(既写出来算法的设计思路等)，并用python算法实现编程\n\n\n\n2.通过动态编程开发更有效的算法。 您应该首先通过动态编程的思想来分析此问题，并编写相应的递归属性。 对这种算法的时间复杂度进行分析，并通过实施和实验验证您的分析结果。并用python代码实现动态编程", "Tag": "算法分析"}
{"Answer": "穷举吧， 可能性也不多", "Konwledge_Point": "算法与数字", "Question": "从0至9选五个数字组成一个三位数与一个二位数相乘，求积最大。\n\n\n从0至9选五个数字组成一个三位数与一个二位数相乘，输入5个数，输出积的最大值，如何用c语言实现，算法是怎样的。", "Tag": "算法分析"}
{"Answer": "是选择排序算法", "Konwledge_Point": "算法与数字", "Question": "这个排序算法的交换位置次数为什么是0啊？\n\n\npublic class Xm1 {\n    public static void main(String[] args) {\n        int[] b = {45,32,43,12,87,56};\n//        冒泡排序算法从小到大\n        int p = 0;\n        int n = 0;\n        for (int q = b.length-1;q>0;q--){\n            for (int w =0;wb[w+1]){\n                    n++;//算出交换位置的次数。\n                    int e;\n                    e = b[w+1];\n                    b[w+1]= b[w];\n                    b[w]=e;\n                }\n            }\n        }\n        System.out.println(\"冒泡排序算法的次数：\"+p);\n        System.out.println(\"选择排序算法的交换位置次数：\"+n);\n        for(int r =0; rb[y]){\n                       min = y;//这个其实是下标,这个y的位置其实可能一直在改变。\n                   }\n            }\n            if(min!=t){\n                int u;\n                u = b[t];\n                b[t] = b[min];\n                b[min] = u;\n                h++;//算出交换位置的次数。\n            }\n        }\n        System.out.println(\"选择排序算法的比较次数：\"+v);\n        System.out.println(\"选择排序算法的交换位置次数：\"+h);\n        for(int r =0; r<b.length;r++){\n            System.out.println(b[r]);\n        }\n    }\n}", "Tag": "算法分析"}
{"Answer": "超过N次都没有猜到，则提示“Game Over”,之前判断太大或太小的应该是cs <= n\nelse if(a[cs]!=da && cs> n)//应该是cs > n才对\n            {\n                printf(\"Game Over\");\n                break;\n            }\n\n整体代码:\n#include<stdio.h>\n\nint main(void)\n{\n    int da,n;\n    int cs=1,num;\n    int a[100],i=1,j=1;\n    scanf(\"%d %d\",&da,&n);\n    scanf(\"%d\",&a[1]);\n     \n    while(a[i]>0)\n    {\n        i++; \n        scanf(\"%d\",&a[i]);\n    }\n     \n    while(1)\n    {\n        if(a[cs]<0)\n        {\n            printf(\"Game Over\");\n            break;\n        }\n        else\n        {\n            if(a[cs]==da)\n            {\n                if(cs==1)\n                {\n                    printf(\"Bingo!\");\n                    break;\n                }\n                else if(cs<=3)\n                {\n                    printf(\"Lucky You!\");\n                    printf(\"cs = %d\",cs);\n                    break;\n                }\n                else if(cs<=n)\n                {\n                    printf(\"Good Guess!\");\n                    break;\n                }\n            }\n            else if(a[cs]<da && cs<=n)\n            {\n                printf(\"Too small\\n\");\n            }\n            else if(a[cs]>da && cs<=n)\n            {\n                printf(\"Too big\\n\");\n            }\n            else if(a[cs]!=da && cs> n)\n            {\n                printf(\"Game Over\");\n                break;\n            }\n        }\n        cs++;\n    }\n \n    return 0;\n}\n", "Konwledge_Point": "算法与数字", "Question": "PTA 7-12猜数字游戏\n问题遇到的现象和发生背景\n\n\n7-12 猜数字游戏\n\n\n猜数字游戏是令游戏机随机产生一个100以内的正整数，用户输入一个数对其进行猜测，需要你编写程序自动对其与随机产生的被猜数进行比较，并提示大了（“Too big”），还是小了（“Too small”），相等表示猜到了。如果猜到，则结束程序。程序还要求统计猜的次数，如果1次猜出该数，提示“Bingo!”；如果3次以内猜到该数，则提示“Lucky You!”；如果超过3次但是在N（>3）次以内（包括第N次）猜到该数，则提示“Good Guess!”；如果超过N次都没有猜到，则提示“Game Over”，并结束程序。如果在到达N次之前，用户输入了一个负数，也输出“Game Over”，并结束程序。\n\n\n输入格式:\n输入第一行中给出两个不超过100的正整数，分别是游戏机产生的随机数、以及猜测的最大次数N。最后每行给出一个用户的输入，直到出现负数为止。\n\n\n输出格式:\n在一行中输出每次猜测相应的结果，直到输出猜对的结果或“Game Over”则结束。\n\n\n输入样例:\n58 4\n70\n50\n56\n58\n60\n-2\n输出样例:\nToo big\nToo small\nToo small\nGood Guess!\n\n\n用代码块功能插入代码，请勿粘贴截图\n\n\n#include\n\n\nint main(void)\n{\n    int da,n;\n    int cs=1,num;\n    int a[100],i=1,j=1;\n\n\nscanf(\n\"%d %d\"\n,&da,&n);\nscanf(\n\"%d\"\n,&a[\n1\n]);\n\n\nwhile\n(a[i]>\n0\n)\n{\n    i++; \n    scanf(\n\"%d\"\n,&a[i]);\n}\n\n\nwhile\n(\n1\n)\n{\n    \nif\n(a[cs]<\n0\n)\n    {\n        \nprintf\n(\n\"Game Over\"\n);\n        \nbreak\n;\n    }\n    \nelse\n\n    {\n        \nif\n(a[cs]==da)\n        {\n            \nif\n(cs==\n1\n)\n            {\n                \nprintf\n(\n\"Bingo!\"\n);\n                \nbreak\n;\n            }\n            \nelse\n \nif\n(cs<=\n3\n)\n            {\n                \nprintf\n(\n\"Lucky You!\"\n);\n                \nbreak\n;\n            }\n            \nelse\n \nif\n(cs<=n)\n            {\n                \nprintf\n(\n\"Good Guess!\"\n);\n                \nbreak\n;\n            }\n        }\n        \nelse\n \nif\n(a[cs]da && cs<n)\n        {\n            \nprintf\n(\n\"Too big\\n\"\n);\n        }\n        \nelse\n \nif\n(a[cs]!=da && cs==n)\n        {\n            \nprintf\n(\n\"Game Over\"\n);\n            \nbreak\n;\n        }\n    }\n    \n    cs++;\n}\n\n\nreturn\n \n0\n;\n\n\n\n}\n\n\n运行结果及报错内容\n\n\n\n\n我的解答思路和尝试过的方法\n\n\n运行起来好像符合要求，但是就是出错，实在找不到哪里有问题", "Tag": "算法分析"}
{"Answer": " if (s[i] >= '0' and s[i] <= '9')改为 if (s[i] >= '0' && s[i] <= '9')=========and是python中的用法", "Konwledge_Point": "算法与数字", "Question": "c++字符串中数字的个数\n字符串中的数字个数\n\n\n输入一行字符，长度不超过 100，请你统计一下其中的数字字符的个数。\n\n\n输入格式\n输入一行字符。注意其中可能包含空格。\n\n\n输出格式\n输出一个整数，表示字数字字符的个数。\n\n\n输入样例：\nI am 18 years old this year.\n输出样例：\n2\n这是我的代码：\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n\nusing\n \nnamespace\n std;\n\n\nint\n \nmain\n()\n\n\n{\n    \nint\n ans = \n0\n;\n    string s;\n    \ngetline\n (cin, s);\n    \nfor\n (\nint\n i = \n0\n; i < s.\nsize\n(); i ++ )\n        \nif\n (s[i] >= \n'0'\n \nand\n s[i] <= \n'9'\n)\n            ans ++ ;\n    cout << ans << endl;\n}\n\n\n\n\n我有个疑问，其他的我都懂，但是循环中的s[i]什么意思为什么要带上[i]直接s为什么不行，我试过了，编译错误，有谁能我讲讲其中的c++知识", "Tag": "算法分析"}
{"Answer": "使用全排列函数枚举0 ~ 9所有顺序数字，把特殊情况排除掉，如0开头，以及每个数字前面都不能为0。需要3 ~ 4秒钟出结果。\nimport itertools\n\n\nma = -1\nmi = float(\"inf\")\ndic = {}\nfor t in tuple(itertools.permutations([str(i) for i in range(9,-1,-1)])):\n    if t[0] == '0':\n        break\n\n    if t[4] == '0' or t[7] == '0' or t[9] == '0':\n        continue\n    \n    D = int(''.join(t[0:4]))\n\n    C = int(''.join(t[4:4+3]))\n\n    B = int(''.join(t[7:7+2]))\n\n    A = int(''.join(t[9:9+1]))\n\n    mul = D * C * B * A\n\n    if mul > ma:\n        ma = mul\n        dic[ma] = (D,C,B,A)\n\n    if mul < mi:\n        mi = mul\n        dic[mi] = (D,C,B,A)\n\nprint(ma,dic[ma])\nprint(mi,dic[mi])\n\n", "Konwledge_Point": "算法与数字", "Question": "数字0～9组成的四个数乘法算式，求乘积最大和最小的算法思路\n用 0123456789 这十个无重复的数字，组成一位数、两位数、三位数、四位数各一个，A、B、C、D；其中，A不能等于0。\n问题：ABC*D 的乘积最大和最小分别是多少？具体是哪四个数组成的算式？\n求：算法，思路。", "Tag": "算法分析"}
{"Answer": "gets（X）是干啥用的呢？", "Konwledge_Point": "算法与数字", "Question": "算法问题求解，程序优化\n三个整数分别为 A,B,CA,B,C。这三个数字不会按照这样的顺序给你，但它们始终满足条件：A < B \n#include\nint main()\n{\n    int x[\n3\n]={\n0\n};\n    char \nX\n[\n4\n]={\n0\n};\n    int i=\n0\n,t=\n0\n;\n    for(i=\n0\n;i<\n3\n;i++)\n    {\n        scanf(\n\"%d\"\n,&x[i]);\n    }\n        gets(\nX\n);\n    if(x[\n0\n]>x[\n1\n])\n    {\n        t=x[\n0\n];\n        x[\n0\n]=x[\n1\n];\n        x[\n1\n]=t;\n    }\n    if(x[\n0\n]>x[\n2\n])\n    {\n        t=x[\n0\n];\n        x[\n0\n]=x[\n2\n];\n        x[\n2\n]=t;\n    }\n    if(x[\n1\n]>x[\n2\n])\n    {\n        t=x[\n1\n];\n        x[\n1\n]=x[\n2\n];\n        x[\n2\n]=t;\n    }\n    if(strcmp(\nX\n,\n\"ABC\"\n)==\n0\n)\n    {\n        for(i=\n0\n;i<\n3\n;i++)\n        {\n            printf(\n\"%d \"\n,x[i]);\n        }\n    }\n    else if(strcmp(\nX\n,\n\"CBA\"\n)==\n0\n)\n    {\n        for(i=\n2\n;i>=\n0\n;i--)\n        {\n            printf(\n\"%d \"\n,x[i]);\n        }\n    }\n    if(strcmp(\nX\n,\n\"ACB\"\n)==\n0\n)\n    {\n        printf(\n\"%d %d %d\"\n,x[\n0\n],x[\n2\n],x[\n1\n]);\n    }\n    if(strcmp(\nX\n,\n\"BCA\"\n)==\n0\n)\n    {\n        printf(\n\"%d %d %d\"\n,x[\n1\n],x[\n2\n],x[\n0\n]);\n    }\n    if(strcmp(\nX\n,\n\"BAC\"\n)==\n0\n)\n    {\n        printf(\n\"%d %d %d\"\n,x[\n1\n],x[\n0\n],x[\n2\n]);\n    }\n    if(strcmp(\nX\n,\n\"CAB\"\n)==\n0\n)\n    {\n        printf(\n\"%d %d %d\"\n,x[\n2\n],x[\n0\n],x[\n1\n]);\n    }\n    return \n0\n;\n}\n\n", "Tag": "算法分析"}
{"Answer": "for(int i : a) {\r\n   if(a[i] != i) {\r\n       a[i] = -1;\r\n   }\r\n}\r\n\r\n这样所有a[i] !=-1的就是了  复杂度O(n)", "Konwledge_Point": "算法与数字", "Question": "阿里巴巴笔试题：A[i]是一个有序递增数组，其中所有的数字都不相等，请设计一种算法...\nA[i]是一个有序递增数组，其中所有的数字都不相等，请设计一种算法，求出其中所有的A[i]=i的数字并分析时间复杂度，不分析复杂度不得分。", "Tag": "算法分析"}
{"Answer": "你个问题 哪个大神都解答不出来", "Konwledge_Point": "算法与数字", "Question": "求大神解码一串加密的数字\nkAYsQ26__HhjJWKvqwkZHAqX-VMlUdYnR1fOKp54KWM\n\n\n\n解码成这串数字：1339189578535395383\n\n\n\n我是小白，求大神试一下，告知加密算法，万分感谢", "Tag": "算法分析"}
{"Answer": "思路就是：按照十进制的加法方法，满36向前进一位，这里有一篇比较详细的实现文章，可以参考：https://www.jianshu.com/p/a98caf83e67b\r\n说句实话，简书的文章排版比这个网站好呢。", "Konwledge_Point": "算法与数字", "Question": "Java语言高分悬赏：怎么实现36进制计数法的累加，要求能带进位算法的\nJava语言高分悬赏：怎么实现36进制计数法的累加，要求能带进位算法的", "Tag": "算法分析"}
{"Answer": "结构体变量 它终究是个变量，变量中只有对象的引用 而真正的对象是在内存中的\r\n\r\n\r\n结构体中可以声明一些属性，但是它里面不能有方法吧  结构体就是自己封装的一种数据结构  而类它是所有 对象的描述 ，包括属性 和行为 也就是方法吧", "Konwledge_Point": "算法与数字", "Question": "帮我解答一下这两道C语言的选择题，谢谢！\n", "Tag": "算法分析"}
{"Answer": "参考一下：\n\n#include<stdio.h>\n#include<time.h.>\n#include<stdlib.h>\nvoid menu()//菜单\n{\n    printf(\"*********************\\n\");\n    printf(\"****1.play 0.exit****\\n\");//选择“1”表示“玩游戏”\n    printf(\"*********************\\n\");//选择“0”表示“退出”\n}\nvoid play_game()//玩游戏\n{\n    int rand_num = rand() % 100;//随机产生0～99范围内的整数\n    int tmp = 0;\n    while (1)\n    {\n        printf(\"请输入你猜的数字：\");\n        scanf(\"%d\", &tmp);\n        if (tmp == rand_num)\n        {\n            printf(\"猜对了\\n\");\n            break;\n        }\n        else if (tmp > rand_num)\n        {\n            printf(\"猜大了\\n\");\n        }\n        else\n        {\n            printf(\"猜小了\\n\");\n        }\n    }\n}\nint main()\n{\n    int input = 0;\n    srand((unsigned int)time(NULL));//srand是随机数发生器的初始化函数\n    //为了防止每次玩游戏时随机产生的数字重复，常使用time函数获得系统时间以初始化\n    do\n    {\n        menu();\n        printf(\"请选择：\");\n        scanf(\"%d\", &input);\n        switch (input)\n        {\n        case 1:\n            play_game();\n            break;\n        case 0:\n            exit(EXIT_SUCCESS);\n            break;\n        default://当输入菜单中不存在选项时，提醒玩家“选择错误”\n            printf(\"选择错误.\\n\");\n            break;\n        }\n    } while (input);\n    system(\"pause\");\n    return 0;\n}\n ", "Konwledge_Point": "算法与数字", "Question": "c语言猜数字问题求解决\n一、问题描述：该游戏可以由程序随机产生或由用户输入四个0到9之间的数字，且不重复。玩游戏者通过游戏提示输入八次来匹配上面所输入的数字。A表示位置正确且数字正确，B表示数字正确而位置不正确。二、功能要求：本游戏显示这样的菜单：（1） 随机产生数据（2） 用户输入数据（3） 退出游戏游戏成功与否都能返回主菜单三、算法提示：数据结构：数组用简单的程序设计方法四、测试数据：测试数据： 3792第一次输入： 12340A2B第二次输入： 56780A1B第三次输入： 08670A1B第四次输入： 97861A1B第五次输入： 17942A0B第六次输入： 27932A2B第七次输入： 37924A0B游戏成功！！！五、其它：对该系统有兴趣的同学可以在实现系统基本功能后，完善系统的其它功能，如：破记录功能，若你所匹配的次数小于纪录保持者，则为破纪录。", "Tag": "算法分析"}
{"Answer": "用递归\n你题目的解答代码如下：\n#include<iostream>\nusing namespace std;\n\nint a[] = {1,2,3,4,5};\nint re[5],len=0;\n\nvoid fp(int t,int n)\n{\n    int i;\n    if (len==n)\n    {\n        cout << \" \";\n        for (i = 0; i < len; i++)\n        {\n            cout << re[i];\n        }\n        return;\n    }\n    for (i = t; i < 5-(n-len-1); i++)\n    {\n        re[len] = a[i];\n        len++;\n        fp(i+1,n);\n        len--;\n    }\n}\n\nint main()\n{\n    int i;\n    for (i = 1; i <= 5; i++)\n    {\n        cout << \"长度=\" << i << \":\";\n        len = 0;\n        fp(0,i);\n        cout << endl;\n    }\n    return 0;\n}\n\n\n如有帮助，请点击我的回答下方的【采纳该答案】按钮帮忙采纳下，谢谢!\n", "Konwledge_Point": "算法与数字", "Question": "五个数字所有不重复的组合方式逻辑思维及c++算法\n现有一个长度为5的数组arrar=[1,2,3,4,5]，求一下这个数组中，所有元素的组合：\n长度=1:1 2 3 4 5\n长度=2:12 13 14 15 23 24 25 34 35 45\n长度=3:123 124 125 234 235 345\n长度=4:1234 1235 1245 2345\n长度=5:12345\n麻烦详细提供一下逻辑和c++算法", "Tag": "算法分析"}
{"Answer": "图形型数字推理是数字推理的又一基本题型。其题干是一个或几个包含 数字的图形，应试者需要发现其中的规律来推测未知数。在解决此类问题时, 可以使用位置分析法。\n对于本题，可以发现如下规律：9.1/1.3 = 7 = 5+240.7/3.7= 11 =9+2即每行第二个数字除以第3个数字减去第一个数字的结果是2。因此， 可以计算出未知数是5。", "Konwledge_Point": "算法与数字", "Question": "正在研究一个算法是图形数字研究的，谁一起研究下这个要怎么实现优化\n问题遇到的现象和发生背景\n\n\n公司最近在搞图形算法，用来在图片上找规律，用于处理特定的图片\n\n\n问题相关代码，请勿粘贴截图\n\n\n第一步是对像素点的色调和分布用不同的数值表示，然后锁定3*3的像素点区域分析。\n比如出现了下面的9个像素点，并通过某种规则给这些像素不同的数值，然后来优化其中一个像素，达到优化图片的效果。\n\n\n表头\n表头\n表头\n5\n9.1\n1.3\n9\n40.7\n3.7\n？\n41.3\n5.9\n\n\n运行结果及报错内容\n\n\n从最初的像素点出来的原始数据是9，现在需要通过算法规律去找这个优化后的数据。\n\n\n我的解答思路和尝试过的方法\n\n\n暂时还在研究中，目前没有解答\n\n\n我想要达到的结果\n\n\n只要有一种规律，并找到优化后的值就可以了，当然如果有多种优化方法并用更好", "Tag": "算法分析"}
{"Answer": "\ndef get_nearest_lucky_ticket(n):\n    i = 0\n    while i<=n:\n        li = list(map(int,str(n+i)))\n        a = sum(li[0::2])\n        b = sum(li[1::2])\n        if a==b:\n            return n+i\n        li = list(map(int,str(n-i)))\n        a = sum(li[0::2])\n        b = sum(li[1::2])\n        if a==b:\n            return n-i\n        i += 1\nassert get_nearest_lucky_ticket ( 111111 ) == 111111\nassert get_nearest_lucky_ticket ( 123321 ) == 123321\nassert get_nearest_lucky_ticket ( 123320 ) == 123321\nassert get_nearest_lucky_ticket ( 333999 ) == 334004\n\n", "Konwledge_Point": "算法与数字", "Question": "用Python，用奇偶性判断幸运数字\n问题遇到的现象和发生背景\n\n\n如果它的奇数位置的数字的和等于偶数位置的数字的和，那么我们称票为幸运的。\n写下一个函数，它以一个票号作为参数，并返回最近的幸运票号（如果有两个的话）。\n最接近的票号意味着它与给定的票号之间的绝对差异被最小化。\n一个给定的票务号码应该是一个可接受的自然2𝑘位数（它有偶数位数），没有前导零。\n笔记将程序保存到文件ticket.py中，并为解决方案函数提供名称get_nearest_lucky_ticket。\n\n\n问题相关代码，请勿粘贴截图\n\n\nExample\nassert get_nearest_lucky_ticket ( \n111111\n ) \n=\n=\n \n111111\n\nassert get_nearest_lucky_ticket ( \n123321\n ) \n=\n=\n \n123321\n\nassert get_nearest_lucky_ticket ( \n123320\n ) \n=\n=\n \n123321\n\nassert get_nearest_lucky_ticket ( \n333999\n ) \n=\n=\n \n334004\n\n\n\n\n\n我想要达到的结果\n\n\n代码最后使用以上assert测试代码，代码写一下注释。", "Tag": "算法分析"}
{"Answer": "这个建议搭建神经网络来解决，目前TensorFlow，pytorch，paddle等框架入门项目便是手写字体的识别，你可以在他们的官方文档看到完整的代码", "Konwledge_Point": "算法与数字", "Question": "python机器学习中多个数字识别该怎么办啊\n问题遇到的现象和发生背景\n\n\n学校要求，用python一次性识别多个手写数字，但是我只会用k近邻算法识别单个数字，并且没有多个数字的数据集，只有0-9的 数据集\n\n\n问题相关代码，请勿粘贴截图\n\n\nfrom PIL import Image\nimg = Image.open('手写3.png')\nimg = img.resize((32,32))\nimg= img.convert('L')\n\n\nimport numpy as np\nimg_new = img.point(lambda x: 0 if x > 128 else 1)\narr = np.array(img_new)\n\n\narr_new = arr.reshape(1,-1)\n\n\nimport pandas as pd\ndf = pd.read_excel('手写字体识别.xlsx')\nX=df.drop(columns='对应数字')\ny=df['对应数字']\n\n\nfrom sklearn.model_selection import train_test_split\nX_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.2,random_state=1)\n\n\nfrom sklearn.neighbors import KNeighborsClassifier as  KNN\nknn = KNN(n_neighbors=5)\nknn.fit(X_train,y_train)\ny_pred = knn.predict(X_test)\na=pd.DataFrame()\na['预测值']=list(y_pred)\na['实际值']=list(y_test)\n\n\nanswer = knn.predict(arr_new)\nprint('手写数字识别为'+str(answer[0]))\n\n\n运行结果及报错内容\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果", "Tag": "算法分析"}
{"Answer": "每个数字做判断，小于5的加10，大于等于5的减5，就回来了", "Konwledge_Point": "算法与数字", "Question": "js数字密码加密，将密码中每个数字加5（超过10取个位数）\njs将密码中的每个数字加五,超过了十取个位数，然后反转（编写解密算法）", "Tag": "算法分析"}
{"Answer": "你是不是要实现矩阵乘的运算？\n算法没错，缺少了D[i][j]的初始化，所以是一堆很大或者很小的数字。\n\nfor (i = 0; i < M; i++)\n{\n    for (j = 0; j < M; j++)\n    {\n\tD[i][j] = 0;    //初始化\n\tfor (k = 0; k < M; k++)\n        {\n            C[j][k] = a[i][k] * b[k][j];\n            D[i][j] += C[j][k];\n        }\n    }\n}\n以上", "Konwledge_Point": "算法与数字", "Question": "想知道我的算法哪里出错了，输出来一堆奇怪的数字。\n\n标题\n\n\n\n\n\n#include\n#include\n\nint M=3;\nint MatMult(int a[3][3], int b[3][3]);\nint main(void)\n{\t\n\tint a[3][3]={{ 1, 2, 3 },{ 2, 3, 1 },{ 3, 1, 2 }};\n\tint b[3][3]={{ 1, 0, 0 },{ 0, 1, 0 }, { 0, 0, 1 }};\n\t\n\tMatMult(a,b);\t\n } \n \nint MatMult(int a[3][3], int b[3][3])\n{\n\tint C[3][3];\n\tint D[3][3];\n\tint i,j,k;\n\tfor(i=0;i<M;i++)\n   {\n\t  for(j=0;j<M;j++)\n\t  {\n\t    for(k=0;k<M;k++)\n\t\t{\n\t\t\tC[j][k]=a[i][k] * b[k][j];\n\t\t    D[i][j]+=C[j][k];\n\t\t\t}\t\n\t  }\n\t}\t\n\t\n\t\n\tfor(i=0;i<M;i++)\n   {\n\t  for(j=0;j<M;j++)\n\t  {\n\t  \t printf(\"%d\",D[i][j]);\n\t  \t printf(\"\\n\");\n      }\n    }\n\treturn 1;\n\t\n\t \n}", "Tag": "算法分析"}
{"Answer": "Full(number,begin+1,size-2);---你这里size每次减去2，然后判断的时候用size%2==1每次减去2，那么每次递归的size要么一直是奇数，要么一直是偶数，没有实现奇偶交叉啊", "Konwledge_Point": "算法与数字", "Question": "数字旋转方阵的有条件输入\n对于数字旋转方阵可以进行一圈输入为数字一圈输入为0交叉互换输入。以此为基础进行c++代码编写但是运行结果要么为纯数字要么全为0？？这是为什么呢？？\n#include\n#define N 10\nint data[N][N]={0};\n\n\nvoid Full(int number,int begin,int size)\n{\n  int i,j,k;\n  if(size==0) return;\n  if(size==1){\n    data[begin][begin]=number;\n    return;\n  }\n  i=begin;j=begin;\n  if((size%2)==1){\n    for(k=0;k<size-1;k++)\n    {\n      data[i][j]=number;\n      number++;\n      i++;\n    }\n    for(k=0;k<size-1;k++)\n    {\n      data[i][j]=number;\n      number++;\n      j++;\n    }\n    for(k=0;k<size-1;k++)\n    {\n      data[i][j]=number;\n      number++;\n      i--;\n    }\n    for(k=0;k<size-1;k++)\n    {\n      data[i][j]=number;\n      number++;\n      j--;\n    }\n   }\n  else{\n    number=0;\n    for(k=0;k<size-1;k++)\n    {\n      data[i][j]=number;\n      i++;\n    }\n    for(k=0;k<size-1;k++)\n    {\n      data[i][j]=number;\n      j++;\n    }\n    for(k=0;k<size-1;k++)\n    {\n      data[i][j]=number;\n      i--;\n    }\n    for(k=0;k<size-1;k++)\n    {\n      data[i][j]=number;\n      j--;\n    }\n   }\n  Full(number,begin+1,size-2);\n  return;\n}\n\n\nvoid OutPrint(int size)\n{\n  int i,j;\n  for(i=0;i<size;i++){\n    for(j=0;j<size;j++)\n    {\n      printf(\"%4d\",data[i][j]);\n    }\n    printf(\"\\n\");\n  }\n}\n\n\nint main()\n{\n  int n;\n  printf(\"输入方阵阶数(小于10):\\n\");\n  scanf(\"%d\",&n);\n  Full(1,0,n);\n  OutPrint(n);\n  return 0;\n}", "Tag": "算法分析"}
{"Answer": "https://www.cnblogs.com/caiyishuai/category/1151952.html", "Konwledge_Point": "算法与数字", "Question": "一个有关躲猫猫的算法问题，请教下各位的思路，用C语言\nProblem Description\n\nAs a cute girl, Kotori likes playing \nHide and Seek'' with cats particularly.\n\nUnder the influence of Kotori, many girls and cats are playing\nHide and Seek'' together.\n\nKoroti shots a photo. The size of this photo is n×m, each pixel of the photo is a character of the lowercase(from \na' to\nz').\n\nKotori wants to know how many girls and how many cats are there in the photo.\n\n\n\nWe define a girl as -- we choose a point as the start, passing by 4 different connected points continuously, and the four characters are exactly \ngirl'' in the order.\n\nWe define two girls are different if there is at least a point of the two girls are different.\n\nWe define a cat as -- we choose a point as the start, passing by 3 different connected points continuously, and the three characters are exactly\ncat'' in the order.\n\nWe define two cats are different if there is at least a point of the two cats are different.\n\n\n\nTwo points are regarded to be connected if and only if they share a common edge.\n\n\n\nInput\n\nThe first line is an integer T which represents the case number.\n\n\n\nAs for each case, the first line are two integers n and m, which are the height and the width of the photo.\n\nThen there are n lines followed, and there are m characters of each line, which are the the details of the photo.\n\n\n\nIt is guaranteed that:\n\nT is about 50.\n\n1≤n≤1000.\n\n1≤m≤1000.\n\n∑(n×m)≤2×106.\n\n\n\nOutput\n\nAs for each case, you need to output a single line.\n\nThere should be 2 integers in the line with a blank between them representing the number of girls and cats respectively.\n\n\n\nPlease make sure that there is no extra blank.\n\n\n\nSample Input\n\n3\n\n1 4\n\ngirl\n\n2 3\n\noto\n\ncat\n\n3 4\n\ngirl\n\nhrlt\n\nhlca\n\n\n\nSample Output\n\n1 0\n\n0 2\n\n4 1", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/red_red_red/article/details/89843256https://www.codenong.com/cs106863076/", "Konwledge_Point": "算法与数字", "Question": "（算法）蓝桥杯算法题数论\n小数第n位\n题目描述\n我们知道，整数做除法时，有时得到有限小数，有时得到无限循环小数。\n\n\n如果我们把有限小数的末尾加上无限多个 0，它们就有了统一的形式。\n\n\n本题的任务是：在上面的约定下，求整数除法小数点后的第\n�\nn 位开始的 3 位数。\n\n\n输入描述\n输入一行三个整数：\n�\n\n\n�\n\n\n�\na b n，用空格分开。\n�\na 是被除数，\n�\nb 是除数，\n�\nn 是所求的小数后位置（\n0\n<\n�\n,\n�\n,\n�\n<\n1\n0\n9\n0\n\n\nusing\n \nnamespace\n std;\n\nint\n \nmain\n()\n\n\n{\n    \ndouble\n a,b;\n    \nlong\n \nlong\n n,t;\n    \nint\n r1,r2,r3;\n    cin>>a>>b>>n; \n    a=a/b*\npow\n(\n10\n,n\n-1\n)*\n1000\n; \n    t=a;\n    r1=t%\n10\n;\n    r2=t/\n10\n%\n10\n;\n    r3=t/\n100\n%\n10\n;\n    cout<<r3<<r2<<r1;\n    \nreturn\n \n0\n;\n}\n\n\n\n错误问题：样例只有百分20的通过率\n\n\n\n", "Tag": "算法分析"}
{"Answer": "不好意思你要的是 false\r\n\r\npublic boolean check(String[] args){\r\nBoolean b=false;\r\nfor(String str:args){ \r\n  if(str!=null && !args[0].equals(str)){ \r\n    return true;    // 发现不一样的  \r\n  } \r\n}\r\nreturn b;\r\n}\r\n\r\n是这个意思？", "Konwledge_Point": "算法与数字", "Question": "求算法：判断未知长度数组内值是否全部相等\n从页面过来的一组数字（过来之前不知道会有多少个数字），存于String数组内了，现想判断其值是否全部相同，全部相同则返回false。小弟新手，想了一夜不知有何可用的算法，求教各位援手。", "Tag": "算法分析"}
{"Answer": "你的代码问题在于scanf没有判断输入的是否是数字，如果不是数字，就会进入死循环。加一个判断就好了。\r\n不过你也可以使用fgets之类的替代scanf，方便指定输入数据类型。\r\n```\r\n#include \r\n#include \r\nvoid main()\r\n{\r\n    int guess = 0, problem;\r\n    char ch = getchar();\r\n    int isNumber;\r\n    do\r\n    {\r\n        isNumber = scanf(\"%d\", &guess);\r\n        if(isNumber == 0)\r\n        {\r\n            printf(\"please input a number!\");\r\n            ch = getchar();\r\n            continue;\r\n        }\r\n        problem = (int)(rand() % 100) + 1;\r\n        for(; guess != problem;)\r\n        {\r\n            if(guess > problem)\r\n                printf(\"too high!\");\r\n            if(guess < problem)\r\n                printf(\"too low!\");\r\n            scanf(\"%d\", &guess);\r\n        }\r\n        printf(\"%d\", problem);\r\n        ch = getchar();\r\n    }while(ch != 'n');\r\n}\r\n```", "Konwledge_Point": "算法与数字", "Question": "c 语言的问题求大神的指导！\n#include\"stdio.h\"\n\n#include\"stdlib.h\"\n\nvoid main()\n\n{\n\n    int guess=0,problem,ch;\n\n    ch=getchar();\n\n    do\n\n    {scanf(\"%d\",&guess);\n\n    problem=(int)(rand()%100)+1;\n\n    for(;guess!=problem;)\n\n    {if(guess>problem)\n\n    printf(\"too high!\");\n\n    if(guess<problem)\n\n        printf(\"too low!\");\n\n    scanf(\"%d\",&guess);\n\n    }\n\n    printf(\"%d\",problem);\n\n    ch=getchar();\n\n    }while(ch!='n');\n\n}为什么猜完一次数字后，我按任意键程序都会进入死循环！！", "Tag": "算法分析"}
{"Answer": "https://www.zybang.com/question/49df45086e790e5f016e3b1d3016f25a.html", "Konwledge_Point": "算法与数字", "Question": "计算第k大的数字，在序列中，采用一次遍历的算法，C语言\nProblem Description\n\nNow is spring ! The sunshine is warm , the flowers is coming out . How lovely it is! So my classmates and I want to go out for a spring-outing.\n\n\n\nBut we all select courses ourselves. We don't have classes at the same time.Now our monitor has a big trouble in arranging the time of the spring-outing.\n\n\n\nCan you help him?\n\n\n\nI will give you our courses information and the time of the spring-outing.You just need to tell me that who can't go with us. \n\n\n\nInput\n\nThe first line contains an integer CA which indicates the number of test cases.\n\nThen CA cases follow.\n\nEach case contains two parts,the students' courses information and the query.\n\n\n\nIn the first part ,first there is an integer N（N<200） which means the number of the student,and then comes the N students’ courses information.\n\nA student's courses information is in this format:\n\n\n\nline1: name K\n\nline2: day1 b1 e1\n\n.....\n\nlineK+1: dayK bK eK\n\n\n\nThe first line of a student's courses infomation contains his name(less than 20 characters and in lowercase) and the number(K,K<1000) of his courses . Then next K lines describe his courses. Each Line contain three integers indicate the day of a week( 1 <= day <= 7 means Monday to Sunday ), the begin time and the end time of the course.\n\nTo make the problem easier,the begin time and the end time will be in the range from 1 to 11 .(Because in HDU,there is 11 classes one day).\n\n\n\nIn the query part , first there is an integer Q which means the query number,and then Q lines follow.\n\nA query contains three integers which means the day ,the begin time and the end time of the spring-outing.And the time is described as the courses.\n\nNotice,everyone may have more than one course at the same time for some special reasons.\n\n\n\nOutput\n\nFor each query , just print the names of the students who can't go out for a spring-outing in a line in lexicographic order.\n\nPlease separate two names with a blank.\n\nIf all of the students have time to go , just print \"None\" in a line.\n\n\n\nSample Input\n\n1\n\n3\n\nlinle 3\n\n1 1 2\n\n2 3 4\n\n3 8 10\n\nlaili 1\n\n4 1 4\n\nxhd 2\n\n1 2 4\n\n4 5 6\n\n3\n\n1 2 2\n\n4 4 5\n\n5 1 2\n\n\n\nSample Output\n\nlinle xhd\n\nlaili xhd\n\nNone", "Tag": "算法分析"}
{"Answer": "\nSince MD5 (and SHA-1, etc.) will give you 128 bits of data (in PHP, you'll get it in hexadecimal string notation, so you need to convert it to an integer first). That number modulo 10000 will give you your integer.\nNote however that many different hashes will convert to the same integer; this is unavoidable with any sort of conversion to your integer range, as the modulo operation essentially maps a larger set of numbers (in this case, 128 bits, that is numbers from 0 to 340,282,366,920,938,463,463,374,607,431,768,211,456) to a smaller set of numbers (less than 17 bits, numbers from 1 to 100,000).\n", "Konwledge_Point": "算法与数字", "Question": "算法将md5（或者可能是另一种散列方法？）转换为整数，可以设置可能的结果整数范围（例如：1-10000）？\n\n\n\nthe topic pretty much describes what we would like to accomplish.\n\n\n\na) start with a possible range of integers, for example, 1 to 10000.\n\n\n\nb) take any md5 hash, run it thru this algo.\n\n\n\nc) result that pops out will be an integer between 1 to 10000.\n\n\n\nwe are open to using another hashing method too.\n\n\n\nthe flow would ideally look like this:\n\n\n\nstring -> md5(string) -> algo(md5(string),range) -> resulting integer within range\n\n\n\n\nis something like this possible?\n\n\n\nfinal note: the range will always start with 1.\n\n\n\nif you have an answer, feel free to post just the general idea, or if you so desire, php snippet works too :)\n\n\n\nthanks!\n\n    ", "Tag": "算法分析"}
{"Answer": "时间复杂度O(n)绝对不可能，起码O(n^2)\r\n不用循环或者只用一个循环是可以的。\r\n\r\n\r\n\r\n```\r\n#include \"stdio.h\"\r\n\r\nvoid foo(int * arr, int n, int acc)\r\n{\r\n\tif (acc == n * n) return;\r\n\tif (acc / n > acc % n)\r\n\t\tprintf(\"%d \", arr[acc / n] + arr[acc % n]);\r\n\tfoo(arr, n, acc + 1);\r\n}\r\n\r\nint main()\r\n{\r\n\tint arr[] = { 7, 5, 3, 4 };\r\n\tfoo(arr, 4, 0);\r\n\treturn 0;\r\n}\r\n```\r\n\r\n![图片说明](https://img-ask.csdn.net/upload/201811/20/1542723086_958443.gif)", "Konwledge_Point": "算法与数字", "Question": "算法题 - 输出数组中数字两两相加的所有结果，要求时间复杂度o(n)\n比如数组{7,5,3,4}，输出12,10,11,8,9,7\n\n                    时间复杂度o(n)，所以不能用循环嵌套", "Tag": "算法分析"}
{"Answer": "好家伙，你这特征数量真心不少。KNN的核心是计算距离，你这个特征这么多，计算的复杂度就会很高，不知道你用的距离算法，也不知道你CPU能不能受的住。         减少特征的数量，比如颜色特征，看看能不能去掉关联特征或者在颜色特征的基础上二次提取，如提取所有颜色的均值，以减小特征维度，这也是可行的。        归一化，因为要计算距离，但是不同特征的单位不同，因此，一般对不同的特征进行归一化，去掉特征的单位，比较典型的归一化方法：最大最小归一化，min-max        把处理后的特征搞到一起组成一个串就行了，组成的串就是这个样本的特征，然后计算距离吧。        如果能帮到你，给个采纳哟！", "Konwledge_Point": "算法与数字", "Question": "关于机器学习中knn算法的一些问题\n我需要使用knn算法对包含以下三个特征的数据进行训练，但是这些数据都不是一个单一的数字，所以我不太明白应该如何使用这些数据进行训练\n这是一条数据的三个特征\n颜色用了颜色直方图，纹理是灰度共生矩阵，形状是hu矩", "Tag": "算法分析"}
{"Answer": "", "Konwledge_Point": "算法与数字", "Question": "算法验证，乘积最大值\n输入五个数字（0-9），把这五个数字组成一个三位数和一个二位数，要求计算组成的这两个数的乘积的最大值\n想问问该算法正确吗\n\n\n#\ninclude\n\n\n\n//乘积最大值\n\n\nvoid\n \nsort\n(\nint\n t[],\nint\n n)\n\n\n{\n    \nint\n j=\n0\n;\n    \nwhile\n(j<n)\n    {\n        \nif\n(t[j]<t[j\n-1\n]&&j!=\n0\n)\n        {\n            \nint\n tem=t[j];\n            t[j]=t[j\n-1\n];\n            t[j\n-1\n]=tem;\n            j--;\n        }\n        \nelse\n\n        {\n            j++;\n        }\n    }\n}\n\nint\n \nmain\n()\n\n\n{\n    \nint\n j,k,h;\n    \nint\n t[\n5\n];\n    \nfor\n(j=\n0\n;j<\n5\n;j++)\n    {\n        \nscanf\n(\n\"%d\"\n,&t[j]);\n    }\n    \nsort\n(t,\n5\n);\n    \n    \nint\n max1=t[\n4\n]*\n100\n+t[\n1\n]*\n10\n+t[\n0\n];\n    \nint\n max2=t[\n3\n]*\n10\n+t[\n2\n];\n    \n    \nprintf\n(\n\"%d  %d   \"\n,max1,max2);\n \n    \nprintf\n(\n\"乘积最大值：%d\\n\"\n,max1*max2);\n    \nreturn\n \n0\n;\n}\n", "Tag": "算法分析"}
{"Answer": "换一个角度，如果foo返回的是0-1的随机数，这时我们只需要建立一个二进制的随机数生成器就可以满足要求了。\n现在foo返回1-5，那么需要减1，建立5进制随机数生成器数，产生的随机数最大值必须大于等于n，如果生成的随机数超过n就重新生成一次，直到小于n。\n或者直接生成5进制下非常非常大的数，然后对n取余数也是可以的，不过需要注明可以忽略。", "Konwledge_Point": "算法与数字", "Question": "一道C语言的算法问题\n有一个函数 foo() 能够返回 1～5的随机数，那么请使用 foo（），设计一个程序实现 1～n的随机数。要求输出的随机数足够随机，有机会取值1~n的任意数字。前几天面试遇到的，没看懂什么意思啊", "Tag": "算法分析"}
{"Answer": "每行多一个字符\n#include <stdio.h>\nint main()\n{\n  char s;\n  int n,i,j;\n  scanf(\"%c%d\",&s,&n);\n  for(i=0;i<n;i++)\n  {\n      for(j=0;j<=i;j++)\n          printf(\"%c\",s);\n      printf(\"\\n\");\n  }\n  return 0;\n}\n\n", "Konwledge_Point": "算法与数字", "Question": "c语言输出直角三角形\n输入一个字符和一个正整数n，输出由该字符构成的n行左下角的直角三角形。\n\n\n输入格式:\n第一行输入一个字符\n\n\n第二行输入一个正整数n。\n\n\n输出格式:\n输出由该字符构成的n行左下角的直角三角形。\n\n\n输入样例:\n*\n5\n输出样例:\n*\n**\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "\n// 用递归就可以了\n#include <iostream>\n#include <string>\nusing namespace std;\n\nbool match(const char* pattern, const char *str)\n{\n    if (*pattern == '\\0' && *str == '\\0')\n        return true;\n    if (*pattern == '\\0' || *str == '\\0')\n        return false;\n\n    if (*pattern == '?')\n    {\n        return match(pattern + 1, str + 1);\n    }\n    else if (*pattern == '*')\n    {\n        // 匹配0个1个或多个\n        return match(pattern + 1, str) || match(pattern + 1, str + 1) || match(pattern, str + 1); \n    }\n    else if (*pattern == *str)\n    {\n        return match(pattern + 1, str + 1);\n    }\n\n    return false;\n}\nint main(void)\n{\n    string pattern, str;\n    while (cin >> pattern >> str)\n    {\n        bool ret = match(pattern.c_str(), str.c_str());\n        if (ret)\n            cout << \"true\" << endl;\n        else\n            cout << \"false\" << endl;\n    }\n    return 0;\n}\n", "Konwledge_Point": "算法与数字", "Question": "要求各位实现字符串通配符的算法\n问题描述：在计算机中，通配符一种特殊语法，广泛应用于文件搜索、数据库、正则表达式等领域。现要求各位实现字符串通配符的算法。\n要求：\n实现如下2个通配符：\n：匹配0个或以上的字符（注：能被\n和?匹配的字符仅由英文字母和数字0到9组成，下同）\n？：匹配1个字符\n\n\n注意：匹配时不区分大小写。\n\n", "Tag": "算法分析"}
{"Answer": "数字证书是什么格式的，是要生产签名还是验签？放到一个文件目录下就可以了。\r\n你可以看下java.security这个包下面的类", "Konwledge_Point": "算法与数字", "Question": "java 怎么使用数字证书\n做一个接口开发，对方想用RSA加密算法，他发给我了一个数字证书，这个数字证书在java开发中要怎么用呢，放在固定的目录下吗？\n", "Tag": "算法分析"}
{"Answer": "# 问题解决的话，请点下采纳\r\n```\r\n#include \r\n#define N 100\r\nint main()\r\n{\r\n\tint i,j,m,n,a[N];\r\n\tint max,r;\r\n\tscanf(\"%d %d\",&m,&n);\r\n\tfor(i=0;i<m;i++)\r\n\t{\r\n\t\tscanf(\"%d\",&a[i]);\r\n\t}\r\n\tfor(j=0;j<n;j++)\r\n\t{\r\n\t\tfor(i=0,max=i;i<m-j;i++)\r\n\t\t{\r\n\r\n\t\t\tif(a[max]<a[i])\r\n\t\t\t{\r\n\t\t\t\tmax=i;\r\n\t\t\t}\r\n\t\t}\r\n\t\tr=a[max];\r\n\t\ta[max]=a[m-1-j];\r\n\t\ta[m-1-j]=r;\r\n\t}\r\n\tfor(j=0;j<m;j++)\r\n\t{\r\n\t\tprintf(\"%d \",a[j]);\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\n```\r\n![图片说明](https://img-ask.csdn.net/upload/202005/23/1590205152_856813.png)", "Konwledge_Point": "算法与数字", "Question": "本人刚开始学习c语言，求大佬们看看我的这道题，一下是我的问题和代码，也请大佬顺便指出我的错误，修改一下我的代码，如果有更好的算法，就更好了？\n问题：\n\n7-11 简单选择排序显示第K趟 (16分)\n\n将N个整数按从小到大排序的选择排序法是这样工作的：选择所有数中最大（小）的，与最后一个（第一个）交换。通过一遍扫描，则最后一个元素必定是最大的元素（或第一个元素必定是最小的元素）。然后用同样的方法余下的N−1个元素进行第二遍扫描。依此类推，最后只需处理两个元素，即完成对N个数的排序。 本题要求对任意给定的K（<N）按找大的原则，输出扫描完第K遍后的中间结果数列。\n\n\n\n输入格式:\n\n输入在第1行中给出N和K（1≤K<N≤100），在第2行中给出N个待排序的整数，数字间以空格分隔。\n\n\n\n输出格式:\n\n在一行中输出选择排序法扫描完第K遍后的中间结果数列，数字间以空格分隔，但末尾不得有多余空格。\n\n\n\n输入样例:\n\n6 2\n\n2 3 5 1 6 4\n\n输出样例:\n\n2 3 4 1 5 6\n\n我的代码：\n\n#include\n\n#define N 100\n\nint main()\n\n{\n\n    int i,j,m,n,a[N];\n\n    int max,r;\n\n    scanf(\"%d %d\",&m,&n);\n\n    for(i=0;i<m;i++)\n\n    {\n\n        scanf(\"%d\",&a[i]);\n\n    }\n\n    for(j=0;j<n;j++)\n\n    {\n\n        for(i=0,max=a[0];i<m-j;i++)\n\n        {\n\n            if(max<a[i])\n\n            {\n\n                max=a[i];\n\n            }\n\n        }\n\n        r=max;\n\n        max=a[m-1-j];\n\n        a[m-1-j]=r;\n\n    }\n\n    for(j=0;j<m;j++)\n\n    {\n\n        printf(\"%d \",a[j]);\n\n    }\n\n    return 0;\n\n}", "Tag": "算法分析"}
{"Answer": "https://www.cnblogs.com/c1299401227/p/5592095.html", "Konwledge_Point": "算法与数字", "Question": "一个有关任务算法的问题，不太会做，请教各位了。\nProblem Description\n\nThere are two kinds of tasks, namely A and B. There are N workers and the i-th worker would like to finish one task A in ai minutes, one task B in bi minutes. Now you have X task A and Y task B, you want to assign each worker some tasks and finish all the tasks as soon as possible. You should note that the workers are working simultaneously.\n\n\n\nInput\n\nIn the first line there is an integer T(T<=50), indicates the number of test cases.\n\n\n\nIn each case, the first line contains three integers N(1<=N<=50), X,Y(1<=X,Y<=200). Then there are N lines, each line contain two integers ai, bi (1<=ai, bi <=1000).\n\n\n\nOutput\n\nFor each test case, output “Case d: “ at first line where d is the case number counted from one, then output the shortest time to finish all the tasks.\n\n\n\nSample Input\n\n3\n\n2 2 2\n\n1 10\n\n10 1\n\n2 2 2\n\n1 1\n\n10 10\n\n\n\n3 3 3\n\n2 7\n\n5 5\n\n7 2\n\n\n\nSample Output\n\nCase 1: 2\n\nCase 2: 4\n\nCase 3: 6", "Tag": "算法分析"}
{"Answer": "你题目的解答代码如下：\n#include<iostream>\nusing namespace std;\n\nint main()\n{\n    int n,l=0;\n    long long int m=0;\n    cin >> n;\n    if(n%2==0 || n%5==0)\n    {\n        cout << \"错误,n需要不能被2或5整除\" << endl;\n        return 0;\n    }\n    do {\n        m = m*10+1;\n        l++;\n    } while (m % n != 0);\n    cout << \"最小的数：\" << m << \"  是\" << n << \"的\" << m/n << \"倍, 包含\" << l << \"个1\" << endl;\n\n    return 0;\n}\n\n\n如有帮助，请点击我的回答下方的【采纳该答案】按钮帮忙采纳下，谢谢!\n", "Konwledge_Point": "算法与数字", "Question": "关于#c++#的问题：给出一个不能被2或5整除的整数0≤n≤10000，使得它的十进制表示仅由数字1组成\n给出一个不能被2或5整除的整数0≤n≤10000，一定存在一个n的倍数，使得它的\n十进制表示仅由数字1组成。其中最小的数包含多少个数字？", "Tag": "算法分析"}
{"Answer": "\npublic static void main(String[] args) {\n        boolean firstFlag = true;\n        for (int i = 1; i < 9; i++) {\n            if(i % 3 == 0){\n                if(firstFlag){\n                    System.out.print(i);\n                    firstFlag = false;\n                }else{\n                    System.out.print(\",\"+i);\n                }\n            }\n        }\n\n    }\n\n因为无法判断哪次输出是最后一次，所以将逗号放到前面，添加一个第一次打印的标识，第一次打印的时候不打印逗号", "Konwledge_Point": "算法与数字", "Question": "Java怎么把输出的最后一个逗号去掉\n怎么把最后一个逗号去掉啊，有人能教教我嘛。\n看了好多方法都不知道具体怎么用", "Tag": "算法分析"}
{"Answer": "http://www.cnblogs.com/zhousir1991/archive/2011/05/26/2058975.html", "Konwledge_Point": "算法与数字", "Question": "C语言小算法，求大神支招\n输入一串int类型的数组，要求出某一截数字串加起来最大，并打印数字串。", "Tag": "算法分析"}
{"Answer": "```\r\nimport java.util.Scanner;\r\n\r\npublic class Solution {\r\n\tpublic static void main(String[] args){\r\n\t\tScanner scan = new Scanner(System.in);\r\n\t\tint N = scan.nextInt();\r\n\t\tif(N > 0){\r\n\t\t\tint max = scan.nextInt();\t//假设第一个数是最大的\r\n\t\t\tint i = 1;\r\n\t\t\twhile(i < N){\r\n\t\t\t\tint next = scan.nextInt();\t//不断读取下一个数\r\n\t\t\t\ti++;\r\n\t\t\t\tif(max < next){\r\n\t\t\t\t\tmax = next;\t\t//将读到的数与当前最大值比较，维护最大值变量\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tSystem.out.println(max);\r\n\t\t}\r\n\t\tscan.close();\r\n\t}\r\n}\r\n```", "Konwledge_Point": "算法与数字", "Question": "有没有大佬帮忙看看，程序为什么能运行但报错不出结果。\npackage zh.codegym.task.task05.task0532;\n\n\n\nimport  java.util.Scanner;\n\n/* \n\n有关算法的任务\n\n*/\n\n\n\npublic class Solution {\n\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n\n        int N = sc.nextInt();\n\n        int i;\n\n\n\n    if (N > 0) {\n        int max = 0;\n\n        for (i = 1; i <= N; i++) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            max = a < b ? a : b;\n\n\n        }\n        System.out.println(max);\n    }\n    if(N<=0){\n        System.out.println();\n    }\n\n}\n\n\n\n\n}\n\n编写程序，使其：\n\n1. 从控制台读取数字 N（必须大于 0）\n\n2. 从控制台读取 N 个数字\n\n3.显示 N 个输入数字中的最大值。\n\n\n\n要求：\n\n1.程序应从键盘读取这些数字。\n\n2.程序必须在屏幕上显示一个数字。\n\n3.该类必须包含 public static void main 方法。\n\n4.不要向 Solution 类添加新方法。\n\n5.程序应显示 N 个输入数字中的最大值。\n\n6.如果 N 小于或等于 0，程序不应显示任何内容。\n\n绝望到家了，啥都满足了。就是没满足条件5，气死我鸟了。有大哥告诉我问题出在哪了么！！", "Tag": "算法分析"}
{"Answer": "看下面这个贴子吧，一模一样的题目：\r\n[url]http://topic.csdn.net/u/20090921/16/6a7b589a-18c2-48be-853f-a33be379818c.html[/url]", "Konwledge_Point": "算法与数字", "Question": "java 位操作分苹果问题\n前段时间看道笔试题，问题：\n\n    有600个苹果，分成10个箱子，要求不管顾客要买1-600的任意一个数字都可以给他（不能开箱子），要求用java的位操作，希望各位能帮忙做做\n\n    PS：本人碰到位操作的问题就郁闷", "Tag": "算法分析"}
{"Answer": "没人知道吗，有这么难吗？？？", "Konwledge_Point": "算法与数字", "Question": "java 两个算法题,帮忙给解答下\n1、有两百万个正整数 存储在int[] num数组中,而且这些正整数是排序好的,要求用最快的方式找出其中重复的一个数字.\n\n\n\n2、有一个数组中有1000个整数,输出重复次数最多的前三个数及出现次数", "Tag": "算法分析"}
{"Answer": "#include \"stdio.h\"\r\n#include \"stdlib.h\"\r\nint sort = 100;\r\nint main()\r\n{\r\n\tint in = 0;\r\n\tint r = 0;\r\n\tint sum，j;\r\n\twhile (1)\r\n\t{\r\n\t\ti=0;\r\n\t\tchar help;\r\n\t\tr = rand();\r\n\t\twhile (1000 <= r && r <= 9999 && sum<7)//sun<7 判断游戏机会是否超出7次\r\n\t\t{\r\n\t\t\tprintf(\"please enter data:\");\r\n\t\t\tscanf(\"%d\", ∈);\r\n\t\t\tprintf(\"Do you need help？Y/N\");//是否选择帮助，Y选择帮助，N不需要帮助\r\n\t\t\tscanf(\"%c\",&help);\r\n\t\t\tif(help=='Y')//Y选择帮助\r\n\t\t\t{\r\n\t\t\t\tint next,next1;\r\n\t\t\t\tint num1,num2;\r\n\t\t\t\tprintf(\"Select help mode ：position:1/Correct:2\");//选择帮助类型，1为查看对应位置正确性，2为查看正确数字\r\n\t\t\t\tscanf(\"%d\",&j);\r\n\t\t\t\tif(j==1)//1为查看对应位置正确性\r\n\t\t\t\t{\r\n\t\t\t\t\tnum1=in;num2=r;\r\n\t\t\t\t\tchar s[4];\r\n\t\t\t\t\tfor(next=0;next<4;next++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(num1%10==num2%10)//对应位置对比\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\ts[4-next-1]=\"R\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\ts[4-next-1]=\"E\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tnum1=num1/10;\r\n\t\t\t\t\t\tnum2=num2/10;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tputs(s);//输出对比结果\r\n\t\t\t\t}\r\n\t\t\t\telse if(j==2)//2为查看正确数字\r\n\t\t\t\t{\r\n\t\t\t\t\tint s[4];\r\n\t\t\t\t\tnum1=in;\r\n\t\t\t\t\tint g=0;\r\n\t\t\t\t\tfor(next=0;next<4;next++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tnum2=r;\r\n\t\t\t\t\t\tfor(next1=0;next1<4;next1++)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif(num1%10==num2%10)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\ts[g++]=num2%10;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tnum2/=10;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tnum1/=10;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tputs(s);//输出对比结果\r\n\t\t\t\t}\r\n\t\t\t\tsort-=sort/10;//扣除使用帮助分\r\n\t\t\t\tprintf(\"当前分数%d\\n\", sort);\r\n\t\t\t}\r\n\t\t\tif (in > r || in < r) //如果大或小，减去当前分数的1/10\r\n\t\t\tsort -= sort / 10;\r\n\t\t\tprintf(\"当前分数%d\\n\", sort);\r\n\t\t\tsum++;//\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}", "Konwledge_Point": "算法与数字", "Question": "求解一道C语言题目！！！！\n１. 电脑随机产生1000—9999之间的数字（包括1000、9999）；\n\n提示：用rand函数，该函数在stdlib.h库中，并保证多次运行产生不同的随机数\n\n２. 玩家每轮有七次猜数的机会，如果七次都没有猜到，则失败，判为0分；\n\n３. 玩家每轮可以请求帮助，提问关于产生数字的信息，扣分细则如下；\n\n4. 游戏以百分制形式，初始分为100，最后得分最多为赢家。\n\n 帮助内容及扣分细则：\n\n. 判断你所猜的数中各位数字对应位置正误情况，以R表正确，E表错误。若随机数是2537，而猜的数是1234，则输出EERE，代表猜的数第3位正确，第1,2，4位错误。\n\n——扣当前分数的1/10\n\n. 判断你所猜的数中正确数字是什么。若随机数是2537，而猜的数是1234，则输出有两个数字正确，它们是2，3。 ——扣当前分数的1/10\n\n#include\n\n#include\n\nint sort = 100;\n\nint main()\n\n{\n\nint in = 0;\n\nint r = 0;\n\nwhile (1)\n\n{\n\nr = rand();\n\nwhile (1000 <= r && r <= 9999)\n\n{\n\nprintf(\"please enter data:\");\n\nscanf(\"%d\", ∈);\n\nif (in > r || in < r) //如果大或小，减去当前分数的1/10\n\nsort -= sort / 10;\n\nprintf(\"当前分数%d\\n\", sort);\n\n}\n\n}\n\nreturn 0;\n\n}", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/weixin_39959298/article/details/110976824", "Konwledge_Point": "算法与数字", "Question": "扫雷游戏的布雷模块有没有是吗算法使雷区分布合理？\n问题描述\n\n\n我本人无聊的时候很喜欢玩扫雷，一般开始都是点击左上角第一个方块，只有出现的数字合理，才能继续玩下去，否则就会一直卡在第一步，游戏体验感大大降低，最近刚好碰到一个项目需要写扫雷游戏，关于布雷模块有没有什么算法使雷区分布合理？", "Tag": "算法分析"}
{"Answer": "https://www.cnblogs.com/wuyoucao/p/4562341.html", "Konwledge_Point": "算法与数字", "Question": "输入一个百分制的成绩t，将其转换成对应的等级，C语言实现\nProblem Description\n\n输入一个百分制的成绩t，将其转换成对应的等级，具体转换规则如下：\n\n90~100为A;\n\n80~89为B;\n\n70~79为C;\n\n60~69为D;\n\n0~59为E;\n\n\n\nInput\n\n输入数据有多组，每组占一行，由一个整数组成。\n\n\n\nOutput\n\n对于每组输入数据，输出一行。如果输入数据不在0~100范围内，请输出一行：“Score is error!”。\n\n\n\nSample Input\n\n56\n\n67\n\n100\n\n123\n\n\n\nSample Output\n\nE\n\nD\n\nA\n\nScore is error!", "Tag": "算法分析"}
{"Answer": "```\r\n //返回一个数从后往前第n位的值，比如 fn(1234, 2)得到3\r\nint fn(int x, int n) { ... } //这个函数你自己写\r\nint main()\r\n{\r\nfor (int i = 100; i < 000; i++)\r\n{\r\nfor (int j = 10; j < 99; j++)\r\n{\r\nint x = i * fn(j, 1);\r\nint y = i * fn(j, 2);\r\nif (i * j < 10000) continue; //结果不是5位数\r\nint z = i * j;\r\n//此时第一排是i，第二排是j，第三排是x，第四排是y，最后一排是z，通过fn可以得到每一位的值\r\n//下面写你的判断逻辑，什么叫数字互异的四个数字为2，3，5，7，我不是很清楚。如果满足逻辑，就是答案了。\r\n}\r\n}\r\n}\r\n```", "Konwledge_Point": "算法与数字", "Question": "竖式问题的变形，求大佬给一段c的编程算法提示\n下面的乘法竖式中，每个星号表示一个数字。已知竖式中出现的数字互异的四个数字为2，3，5，7，求还原竖式。\n\n      ***\n\n        x  **\n\n        ——\n\n         ****\n\n     ****\n\n     ——\n\n      *****", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/u011429058/article/details/50129919", "Konwledge_Point": "算法与数字", "Question": "i随机从一个数组中不放回不重复地选取n个数字\n随机从一个数组中不放回不重复地选取n个数字，使得产生的数组和等于m的编程选取的算法怎么做？", "Tag": "算法分析"}
{"Answer": "不超过5行？那只能这样：\n            string[] strs = new string[] {\"    1\",\"   121\",\"  12321\",\" 1234321\",\"123454321\", \" 1234321\", \"  12321\" , \"   121\" , \"    1\" };\n            foreach (var item in strs)\n                Console.WriteLine(item);\n\n\n\nlong item = 0, len = 9;//len只到5的话，定义为int就可以了\n            for (int i = 0; i < len * 2 - 1; i++)\n            {\n                item = i < len ? item * 10 + long.Parse(\"1\".PadLeft(i * 2 + 1, '1')) : (item - long.Parse(\"1\".PadLeft(((int)len * 2 - i - 1) * 2 + 1, '1'))) / 10;\n                Console.WriteLine(\" \".PadLeft((int)len - (item.ToString().Length) / 2, ' ') + item);\n            }\n\n", "Konwledge_Point": "算法与数字", "Question": "又一算法题，简单又复杂，导师有特殊要求，会的教下\n题目是在console输出如下图所示数字排列，我导师要求主体代码不能超过5行，又把我难倒了，各位码友专家看能不能教一下，java、c#、c、vb都行\n不会的也可以留言，我们一起学习共同进步\n\n", "Tag": "算法分析"}
{"Answer": "修改如下，供参考：\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nint n;\nstruct employee\n{\n    int  num;  //num[1000];\n    char name[20];\n    char sex;\n    char post[20];//职位\n    char department[30];//部门\n    char Addr[50];//住址\n    int  age;\n};struct employee peo[10];\nvoid addmessages(struct employee peo[])\n{\n    char c[2];\n    //int  n=0;\n    do\n    {\n        printf(\"员工编号.姓名.性别.年龄.职务.部门.住址\\n\");\n        //scanf(\"%d %s %s %d %s %s %s\",&peo[n].num,&peo[n].name,&peo[n].sex,&peo[n].age,&peo[n].post,&peo[n].department,&peo[n].Addr);\n        scanf(\"%d %s %c %d %s %s %s\",&peo[n].num,peo[n].name,&peo[n].sex,&peo[n].age,peo[n].post,peo[n].department,peo[n].Addr);\n        n++;\n        printf(\"\\n继续输入下一次请按Y或y：\");\n        scanf(\"%s\",c);\n    }while(!(strcmp(c,\"Y\"))||!(strcmp(c,\"y\")));\n}\nvoid show( struct employee peo[])\n{   int i;\n    for(i=0;i<n;i++)\n    {\n        //printf(\"%d %s %s %d %s %s %s\",peo[i].num,peo[i].name,peo[i].sex,peo[i].age,peo[i].post,peo[i].department,peo[i].Addr);\n        printf(\"%d %s %c %d %s %s %s\\n\",peo[i].num,peo[i].name,peo[i].sex,peo[i].age,peo[i].post,peo[i].department,peo[i].Addr);\n    }\n}\nvoid find(struct employee peo[])\n{\n    printf(\"输入部门,性别查找员工信息:\");\n    int i;    //n,\n    char bm[20];\n    char sex1;\n    //scanf(\"%s%s\",bm,&sex1);\n    scanf(\"%s %c\",bm,&sex1);\n    for(i=0;i<n;i++){\n       //if(!(strcmp(peo[i].department,bm))&&!(strcmp(peo[i].sex,sex1)))\n       if((strcmp(peo[i].department,bm)==0)&&(peo[i].sex == sex1))\n       {\n          //printf(\"%d %s %s %d %s %s %s\",peo[i].num,peo[i].name,peo[i].sex,peo[i].age,peo[i].post,peo[i].department,peo[i].Addr);\n          printf(\"%d %s %c %d %s %s %s\\n\",peo[i].num,peo[i].name,peo[i].sex,peo[i].age,peo[i].post,peo[i].department,peo[i].Addr);\n          break;\n       }\n    }\n    if(i >= n)\n       printf(\"not found!\\n\");\n}\nmain()\n{\n    int menu ;\n    while (1)\n    {\n        printf (\"1. 输入数据 \\n\");\n        printf (\"2. 显示所有员工信息 \\n\");\n        printf (\"3. 输入部门、性别，显示该部门的员工记录\\n\");\n        printf (\"4. 结束.\");\n        printf(\"请输入数字1—3:\");\n        scanf(\"%d\",&menu);\n        switch (menu)\n        {\n        case 1:\n               addmessages(peo);break ;\n        case 2:\n               show(peo);break;\n        case 3:\n               find(peo);break;\n        case 4:\n               exit(0);\n        }\n    }\n}\n\n", "Konwledge_Point": "算法与数字", "Question": "公司员工基本信息管理程序设计 设计结构体数组，结构中包含数据为：员工编号、姓名、性别、年龄、职务、部门、住址。 设计各个函数，通过选择菜单调用以上各函数\n这个问题没搞懂怎么改，后两个不能跑\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\nint\n n;\n\nstruct\n \nemployee\n\n{\n    \nint\n num[\n1000\n];\n    \nchar\n name[\n20\n];\n    \nchar\n sex;\n    \nchar\n post[\n20\n];\n//职位\n\n    \nchar\n department[\n30\n];\n//部门\n\n    \nchar\n Addr[\n50\n];\n//住址\n\n    \nint\n age;\n};\nstruct\n \nemployee\n peo[\n10\n];\n\nvoid\n \naddmessages\n(\nstruct\n employee peo[])\n\n\n{\n    \nchar\n c[\n2\n];\n    \nint\n n=\n0\n;\n    \ndo\n\n    {\n        \nprintf\n(\n\"员工编号.姓名.性别.年龄.职务.部门.住址\\n\"\n);\n        \nscanf\n(\n\"%d %s %s %d %s %s %s\"\n,&peo[n].num,&peo[n].name,&peo[n].sex,&peo[n].age,&peo[n].post,&peo[n].department,&peo[n].Addr);\n        n++;\n        \nprintf\n(\n\"\\n继续输入下一次请按Y或y：\"\n);\n        \nscanf\n(\n\"%s\"\n,c);\n\n    }\nwhile\n(!(\nstrcmp\n(c,\n\"Y\"\n))||!(\nstrcmp\n(c,\n\"y\"\n)));\n}\n\nvoid\n \nshow\n( \nstruct\n employee peo[])\n\n\n{   \nint\n i;\n    \nfor\n(i=\n0\n;i<n;i++)\n    {\n        \nprintf\n(\n\"%d %s %s %d %s %s %s\"\n,peo[i].num,peo[i].name,peo[i].sex,peo[i].age,peo[i].post,peo[i].department,peo[i].Addr);\n    }\n\n}\n\nvoid\n \nfind\n(\nstruct\n employee peo[])\n\n\n{\n    \nprintf\n(\n\"输入部门,性别查找员工信息:\"\n);\n    \nint\n n,i;\n    \nchar\n bm[\n20\n];\n    \nchar\n sex1;\n    \nscanf\n(\n\"%s%s\"\n,bm,&sex1);\n    \nfor\n(i=\n0\n;i<n;i++)\n    \nif\n(!(\nstrcmp\n(peo[i].department,bm))&&!(\nstrcmp\n(peo[i].sex,sex1)))\n    {\n        \nprintf\n(\n\"%d %s %s %d %s %s %s\"\n,peo[i].num,peo[i].name,peo[i].sex,peo[i].age,peo[i].post,peo[i].department,peo[i].Addr);\n    }\n}\n\nmain\n()\n{\n    \nint\n menu ;\n    \nwhile\n (\n1\n)\n    {\n        \nprintf\n (\n\"1. 输入数据 \\n\"\n);\n        \nprintf\n (\n\"2. 显示所有员工信息 \\n\"\n);\n        \nprintf\n (\n\"3. 输入部门、性别，显示该部门的员工记录\\n\"\n);\n        \nprintf\n (\n\"4. 结束.\"\n);\n        \nprintf\n(\n\"请输入数字1—3:\"\n);\n        \nscanf\n(\n\"%d\"\n,&menu);\n        \nswitch\n (menu)\n        {\ncase\n \n1\n:\n        \naddmessages\n(peo);\nbreak\n ;\n        \ncase\n \n2\n:\n        \nshow\n(peo);\nbreak\n;\n        \ncase\n \n3\n:\n        \nfind\n(peo);\nbreak\n;\n        \ncase\n \n4\n:\n        \nexit\n(\n0\n);\n        }\n    }\n}\n\n\n", "Tag": "算法分析"}
{"Answer": "if(a=1||3||5||7||8||10||12)错的太厉害了判断相等用==，多个值判断相等不能这么写if(a==1 || a==3 || a==5 || a== 7 || a== 8 || a== 10 || a==12)", "Konwledge_Point": "算法与数字", "Question": "怎么解答跨月日期的算法？\n我写了个程序，就是很简单的算日子相差几天（算上当天），虽然运行成功，但是有很大的问题。一个是我只把它局限在2022年（考虑2月的平年闰年），另一个是这个程序只能算相邻的月份数字。因为我想了很久怎么才能实现跨月份计算，（平年闰年我可以再套一个if，用4整除）却没有想到，不知道是不是受到所学知识的限制（目前学到c语言循环），还是说单纯没有想到办法呢？求帮忙解答！\n\n\n#include\nint main()\n{\n    int a;\n    int b;\n    int c;\n    int d;\n    int x;\n    int y;\n    printf(\"请分别输入初始与结束月份及日子！(2022)\");\n    scanf(\"%d %~ %~ %~\",&a,&b,&c,&d); //不让d重复！\n    if(a==1||3||5||7||8||10||12)\n    {x=32-b;\n    y=x+d;\n     }\n     else if(a==2)\n     {x=30-b;\n     y=x+b;\n     }\n     else if(a==4||6||9||11)\n     {x=31-b;\n     y=x+d;\n     }\n    printf(\"两个日子相差%d天！\",y);\n    return 0;\n}", "Tag": "算法分析"}
{"Answer": "这个不是必须的，你可以把任何一个不在你有效数值范围内的数作为结束标志。用-1是因为大部分练习题都是正整数计算，所以用-1表示无效数值作为结束", "Konwledge_Point": "算法与数字", "Question": "c语言为什么算平均数以输入-1为标志结束\nc语言算平均数为什么以输入-1为标志结束c语言算平均数为什么以输入-1为标志结束c语言算平均数为什么以输入-1为标志结束c语言算平均数为什么以输入-1为标志结束c语言算平均数为什么以输入-1为标志结束", "Tag": "算法分析"}
{"Answer": "#include \r\n#include \r\n\r\nint getmax(int first, int second)\r\n{\r\n        return first > second ? first : second;\r\n}\r\n\r\nint main()\r\n{\r\n        int start_index = 0, end_index = 0;\r\n        int sum_max = 0, result = 0;\r\n\r\n        int index = 0;\r\n\r\n        int data[] = {1, 3, -5, 0, 6, -4, 9, 12, -1};\r\n\r\n        int count = sizeof(data)/sizeof(int);\r\n\r\n        for(index = 0; index < count; index++)\r\n        {\r\n                sum_max = getmax(0, sum_max) + data[index];\r\n                if(data[index] >= sum_max)\r\n                {\r\n                        start_index = index;\r\n                }\r\n                result = getmax(result, sum_max);\r\n                if(result == sum_max)\r\n                {\r\n                        end_index = index;\r\n                }\r\n        }\r\n        printf(\"min section [%d, %d],sum : %d\\n\", start_index, end_index, result);\r\n        return 0;\r\n}\r\n\r\n```\r\n \r\n```", "Konwledge_Point": "算法与数字", "Question": "要求时间复杂度为O(n)的求两个位置之间最大值的算法\n把一串数（32位int型）放到Num中，求begin和end位置使得begin与end之间的是数字和最大，要求时间复杂度是O（n）。\n\n注：不可以先排序，这串数字的位置不能改变。\n\n最好有源码，思路也可以。", "Tag": "算法分析"}
{"Answer": "第一步将第一个数插入到链表中\n第二步接下来输入的这个数，从链表头部开始遍历链表，按照顺序插入到链表中。如果链表中存在此值，则说明找到了可以连接在一块的积木。即将原来链表中的此节点删除。\n第三步当遍历完所有的积木之后，计算链表长度，如果等于2，则表示可以将所有的积木串在一起，输入YES. 否则输入NO可以参考以下https://blog.csdn.net/u012324136/article/details/77483072", "Konwledge_Point": "算法与数字", "Question": "js算法题，搭积木是否能拼接成一个整体？需要提供一个解题思路，3q\n一天，小明买了许多积木回家，他想把这些积木拼接在一起。每块积木有两个接口，每个接口用一个数字标记，规定只有当两块积木有相同数字标记的接口时，这两块积木才可以通过该接口拼接在一起。举例，有两块积木，接口数字分别为[1,2]和[3,4]，那么这两块积木无法拼接；若两块积木接口数字分别为[1,2]和[2,3]，那么这两块积木可以通过由数字2标记的接口拼接在一起。现在小明知道所有积木的数量和每块积木接口的数字标记，你能告诉他他可以将所有积木拼接成一个整体么？\n\n\n输入\n:n个积木的两个接口的数字标记；1≤x，y≤100000；\n\n\n[\n[1,2]\n,\n[2,3]\n,\n[4,5]\n]\n\n\n[\n[1,2]\n,\n[2,3]\n,\n[3,5]\n,\n[4,5]\n,\n[4,6]\n,\n[5,1]\n]\n\n\n\n\n输出\n:对于每组测试数据，输出”YES”，表示该组数据中的\n所有积木\n可以拼接成一个整体，”NO”表示不行。\n\n\nNO\n\n\nYES\n\n", "Tag": "算法分析"}
{"Answer": "肯定是可以的，keras的话调整搭建模型的输出层就行（layers.Dense(2)），matlab里的没咋用过，等别人回答~", "Konwledge_Point": "算法与数字", "Question": "Lstm神经网络能否调整输出层的节点数使其对于预测点输出两个值?\n最近换方向到光伏区间预测了，对算法一头雾水……使用matlab自带的例子修改了numRespouce提示错误使用reshape，请问各位应该怎么改呢matlab或者python ", "Tag": "算法分析"}
{"Answer": "你题目的解答代码如下：（如有帮助，望采纳！谢谢! 点击我这个回答右上方的【采纳】按钮）\ndef fun(lst):\n    sl = sorted(enumerate(lst),key=lambda x: x[1])\n    for i in range(len(lst)):\n        lst[sl[i][0]] = i\n    return lst\nlst = [7,6,3,6,15,8]\nprint(fun(lst))\n\n‘\n", "Konwledge_Point": "算法与数字", "Question": "下面这个算法怎么用用python的函数实现？\npython 能不能设计一个函数，给list（里面是0-15的整数）里的数字最小的变成0，第二小的变成1，第三小的变成2，以此类推", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/chang_mu/article/details/27983989", "Konwledge_Point": "算法与数字", "Question": "关于如何计算机IP地址的判断判定算法C语言\nProblem Description\n\n在网络课程上，我学到了很多有关IP的知识。IP全称叫网际协议，有时我们又用IP来指代我们的IP网络地址，现在IPV4下用一个32位无符号整数来表示，一般用点分方式来显示，点将IP地址分成4个部分，每个部分为8位，表示成一个无符号整数（因此不需要用正号出现），如192.168.100.16，是我们非常熟悉的IP地址，一个IP地址串中没有空格出现（因为要表示成一个32数字）。\n\n但是粗心的我，常常将IP地址写错，现在需要你用程序来判断。\n\n\n\nInput\n\n输入有多个case，每个case有一行，不超过100个字符。\n\n\n\nOutput\n\n对于每个case，判断输入的IP是否正确，如果正确输入YES，否则NO。\n\n\n\nSample Input\n\n192.168.100.16\n\n\n\nSample Output\n\nYES", "Tag": "算法分析"}
{"Answer": "题主，在你的isSort方法里面，if判断里用break是错的，这里可以用一个实例说明，假如给你一个数组，元素为{3,1,2}；进入for循环，if判断语句，3和1比较通过，将sort赋值false，然后就   ** break __**break是退出整个循环哈，退出了for循环，后面的数组元素就没有办法判断了，如果非要这么写，可以用continue试一下，望题主采纳。", "Konwledge_Point": "算法与数字", "Question": "JAVA判断阵列数字是否由大到小的顺序排列\n输入：\n\n\n阵列大小N(整数)、各别数值(整数)\n\n\n输出：\n\n\n判断阵列数字是否由大到小的顺序排列\n\n\n提示：\n\n\n静态方法中的演算法：\n\n\n不必管什么排序法，只要用一个回圈，判断前面的数字有没有比后面的大，按顺序一一比对，若不成立就不是由大到小。\n\n\n特别要求:你必须写一个静态方法\n\n\npublic static boolean isSorted(int[] array) {}\n\n\n输出格式：\n\n\n当阵列\"前面的数字比后面的小\"时，输出文字：\n\n\nSystem.out.println(\"The list is not sorted\");\n\n\n当阵列\"前面的数字比后面的大\"时，输出文字：\n\n\nSystem.out.println(\"The list is already sorted\");\n\n\nExample:\n\n\nInput\n3\n3 2 1\n\n\nOutput\nThe list is already sorted\n\n\n\n\n以下是我的程式码:\n\n\n运行以后确实能达成example演示的结果，但是缴交系统表示答案是错误的，请问哪里出了问题?", "Tag": "算法分析"}
{"Answer": "http://wenku.baidu.com/link?url=sYNdbuO2AU_UQ0wHic4XgQYIv3NbiuNI_fh8sHXdJbTx_GhgJyTs2KvVTGRRSMtdU7aYNY2uv1sAd4TiznxUdsySI0v6kpWlzuHdcY2ocCq", "Konwledge_Point": "算法与数字", "Question": "VISC++ 6.0一个算法的问题，按照周期提取浮点数\nC++ 6.0提取浮点数，浮点数从小到大，再变小，其中有无效的数字剔除，然后得到每个周期，怎么实现呢？", "Tag": "算法分析"}
{"Answer": "\npublic static void main(String[] args){\n    String target = \"Jyouhou\";//目标串\n    Scanner scanner = new Scanner(System.in);\n    int t = scanner.nextInt();//组数\n    if(t<=0){\n        System.out.println(\"组数必须大于0\");\n        return;\n    }\n    int tLen = target.length();//目标串长度\n    String[] s = new String[t];//需要匹配的字符串数组\n    for(int i=0;i<t;i++){\n        int n = scanner.nextInt();\n        if(n<=0){\n            System.out.println(\"字符串SS的长度必须大于0\");\n            return;\n        }\n        scanner.nextLine();//消化掉回车,避免下面的nextLine读到\n        String s1 = scanner.nextLine();\n        s[i]= s1.substring(0,n);\n    }\n\n    for(int i=0;i<t;i++){\n        int count = 0;//匹配的次数\n        int k1 = 0;\n        int k2 = 0;\n        int sLen = s[i].length();//源字符串的长度\n        if(sLen<tLen){//长度不够，肯定不匹配\n            System.out.println(0);\n        }else{\n            while(true){\n                if(s[i].charAt(k1)==target.charAt(k2)){\n                    k2++;\n                }\n                k1++;\n                if(k2==tLen){//target被遍历完，res计数，k2重新开始\n                    count++;\n                    k2=0;\n                    if(sLen-k1<tLen){ //如果剩余长度不足，没必要往下判断\n                        System.out.println(count);\n                        break;\n                    }\n                }\n                if(k1==sLen){//源字符串已被扫描完，输出\n                    System.out.println(count);\n                    break;\n                }\n            }\n        }\n    }\n}", "Konwledge_Point": "算法与数字", "Question": "求大佬们帮忙看一道算法题目\n我好菜啊，做了半天还是做不出来，题目如下：\n\n\n\n提取子序列 subarr\n\n\n\nDescription\n\n\n\n \n\n\n\n「信息学（Informatics）」的另一个译名是「情报学」，这个名字在日本见得比较多。日文的「情報」读音为「Jyouhou」。\n\n\n\n现在有一个长为 nn 的字符串 SS ，SS中只包含大小写英文字母或数字。按从前往后的顺序读字符串SS，从SS中取出最靠前的一个子序列构成\nJyouhou\n串，取出一个串后，从最后一个字符的后一个位置继续尝试取出，直到剩余部分已无法取出一个\nJyouhou\n串。请求出对于给定的SS，取出的\nJyouhou\n串的数量是多少。\n\n\n\n子序列：从一个序列中取出若干元素（不要求相邻）组成的一个新序列，新序列元素的顺序按照原序列中元素的相对顺序确定。\n\n\n\n你可以参考样例解释来帮助理解上面的流程。\n\n\n\nInput\n\n\n\n \n\n\n\n测试点包含多组测试数据。\n\n\n\n第一行包含一个正整数T (1≤T≤20)，表示测试数据组数。\n\n\n\n每组数据中包含两行。第一行包含一个正整数n (1≤n≤10^4)，表示字符串SS的长度。第二行包含一个字符串SS，含义见「题目描述」。\n\n\n\nOutput\n\n\n\n \n\n\n\n对于每一组测试数据，输出一行一个正整数，表示该组数据的答案。\n\n\n\nSample Input 1 \n\n\n\n\n3\n20\nJJSy2ouhuouJ5yoxuhou\n10\naaaaaaaaaa\n14\nJyouhoJuyouhou\n\n\n\nSample Output 1\n\n\n\n\n2\n0\n1\n\n\n\n第一组数据中，找到的 2 个\nJyouhou\n串为\nJ\nJS\ny\n2\nouh\nu\nouJ\n5\nyo\nx\nuhou\n。\n\n\n\n第二组数据中，由于不存在 J、y、o、u、h 字符，故无法找到任何一个\nJyouhou\n串。\n\n\n\n第三组数据中，找到的\nJyouhou\n串为\nJyouho\nJ\nu\nyouhou。由于前一个\nJyouhou\n串的最后一个字符 u 在第二个字符 J 前面，字符 u 后面已经无法再找到一个\nJyouhou\n串了，因此只能找出 1 个。", "Tag": "算法分析"}
{"Answer": "http://blog.sina.com.cn/s/blog_6fb8700f0101iupl.html", "Konwledge_Point": "算法与数字", "Question": "求这个题代码的算法设计和流程图\n问题描述\n\nYOYO非常喜欢CICI，今天他终于向CICI表白了，但是CICI当然不会随随便便的接受，她想找个聪明的男朋友。于是她给YOYO出了个难题，她要求YOYO从商店里中找出一块巧克力。这听 起来不算什么，但是这块巧克力的要求可真是让YOYO犯难了，要求如下：\n\n1、这块巧克力一定要是商店里质量最大的；\n\n2、这块巧克力一定要是质量最大的巧克力中最薄的；\n\n3、这块巧克力一定要是符合前两条的巧克力中编码最大的（每块巧克力都有一个互不相同的编码，越大表示生产日期越近）。\n\n相关的资料到是有，可是，手工从几百块巧克力中选出符合要求的那块…… \n\n不过YOYO说，这个问题写个小的程序就能解决了。聪明的你一定知道他是怎么解决的吧。\n\n输入：\n\n\n\n有多组数据，第一行一个数字T，表示测试数据的组数。之后有T组数据。\n\n每组数据的第一行为一个整数 N（ N<1000000），表示商店里所有巧克力的数量。\n\n之后N行，每行三个整数，分别表示一块巧克力的质量L、厚度D和编码M（一个9位整数）,所有数字保证最高位非零。\n\n\n\n输出：\n\n\n\n共有T行，第i行只有一个9位整数，表示第i组数据中选出的那块巧克力的编码。\n\n\n\n样例输入：\n\n\n\n1\n\n4\n\n3000 50 872198442\n\n3000 45 752498124\n\n2000 60 765128742\n\n3000 45 652278122\n\n\n\n样例输出：\n\n\n\n752498124\n\n\n\n#include\n\nint main()\n\n{\n\nint n;\n\nscanf(\"%d\",&n);\n\nwhile(n--)\n\n{\n\nint m,a,b,c;\n\nint a1,b1,c1;\n\nscanf(\"%d\",&m);\n\nscanf(\"%d %d %d\",&a,&b,&c);\n\nfor(int i = 1;i < m;i++ )\n\n{\n\nscanf(\"%d %d %d\",&a1,&b1,&c1);\n\nif(a < a1 || (a == a1 && b > b1) || (a == a1 && b == b1 && c < c1))\n\n{\n\na = a1,b = b1,c = c1;\n\n}\n\n}\n\nprintf(\"%d\\n\",c);\n\n}\n\nreturn 0;\n\n}", "Tag": "算法分析"}
{"Answer": "应该是代码逻辑错误，如那里第二个for循环的终止条件要改为小于i，然后判断是否为素数的逻辑也要改一下，修改了一下如下：\n\n#include <stdio.h>\n\nint main(void){\n    \n    int a,b,c,i,j,t,prime=1;\n    int sum=0,count=0;\n    scanf(\"%d %d\",&a,&b);\n    \n    for(i=a;i<=b;i++){\n        for(j=2;j<i;j++){\n            t=i%j;\n            if(t==0){\n            //    printf(\"i=%d,j=%d,count=%d\\n\",i,j,count);\n                prime=0;\n                break;\n            }\n        }\n        if(prime==1){\n            count++;\n        }\n        \n        prime=1;\n                \n    }\n    \n    printf(\"%d\",count);\n    return 0;\n} \n", "Konwledge_Point": "算法与数字", "Question": "C语言，输入入2个正整数A和B，然后输出它们之间的素数个数（不包含A，B）\n输入格式:\n输入正整数A和B，空格分隔。\n\n\n输出格式:\n输出两数间素数的个数（不包括这两个数）。如果输入负数没有输出。\n\n\n输入样例:\n在这里给出一组输入。例如：\n\n\n10 20\n输出样例:\n在这里给出相应的输出。例如：\n\n\n4\n\n\n输出结果是0，不知道为什么", "Tag": "算法分析"}
{"Answer": "这个只要你自己想一个算法就可以了啊，增加位的校验，这样只要你公司里没人说，别人很难猜出是怎么加密的吧", "Konwledge_Point": "算法与数字", "Question": "公司要做卡系统，求卡号生成算法！\n公司要做卡系统，对卡号要求：第一：不能重复，要唯一；第二：长度可控制，要在12位到18位之间；第三：不能让别人猜出来（没有绝对，只要很难猜就行）。\n\n其实UUID很适合，但是太长了，而且我们做的是在电视遥控器上用，为了用户输入方便，要求全是数字的。上网查了太多的资料，但是没有一个有明确的答复的！我用的是java开发平台。最好有些示范性代码！谢谢！\n\n[b]问题补充：[/b]\n\n对于congjl2002的回答，我觉得是一个思路，但是能保证不重复吗？\n\n[b]问题补充：[/b]\n\n目前，我是这样做的，不知道可不可以。\n\n首选在卡是一批一批生成的，将卡的批次加入到卡号里面，其它卡号中随机生成，只要保证同一批次的没有重复号就可以了。最后根据congjl的建议，对生成的号码加密后，生成几位校验码再插入其中，这样就安全了　", "Tag": "算法分析"}
{"Answer": "```\r\npublic void calMaxLength() {\r\n\r\n\t\tString input = \"adc\";\r\n\t\tint max=0;\r\n\t\tint temp=1;\r\n\t\t\r\n\t\t/**\r\n\t\t * 对整个string进行遍历\r\n\t\t */\r\n\t\tfor(int i=1;itemp?max:temp);\r\n\t\t\t\ttemp=1;\r\n\t\t\t}\r\n\t\t}\r\n\t\t//因为上面的程序没有对最后一次连续长度进行比较，所以在这里额外比较一次\r\n\t\tmax=(max>temp?max:temp);\r\n\t\t\r\n\t\t//题目要求没有连续的输出0，即没有1这个说法，所以这里进行了判断\r\n\t\tSystem.out.println((max==1?0:max));\r\n\r\n\t}\r\n```\r\n\r\n\r\n上面的方法可以解决楼主的问题，而且时间复杂度是O(n)，应该是最优的解法了。\r\n手打代码&注释，思路已经在注释中说明了。\r\n\r\n望采纳，如果有不合适可以继续交流", "Konwledge_Point": "算法与数字", "Question": "java字符串中找出最大的“连续的” 子字符串”的长度。\n例如：abijkabcd 则结果返回 abcd  长度为4。注意是一个字符串，连续的“字符串”而不是  数字串。", "Tag": "算法分析"}
{"Answer": "供参考：\n#include <stdio.h>\nvoid fun(int a)\n{\n    int i, j, k, f, cnt = 0, n = a + 3;\n    for (i = a; i <= n; i++) {\n        for (j = a; j <= n; j++) {\n            for (k = a; k <= n; k++)  {\n                for (f = a; f <= n; f++) {\n                    if (i != j && i != k && i != f && j != k && j != f && k != f) {\n                        cnt++;\n                        printf(cnt % 6 == 0 ? \"%d\\n\" : \"%d \", i * 1000 + j * 100 + k * 10 + f);\n                    }\n                }\n            }\n        }\n    }\n    if (cnt % 6) printf(\"\\n\");\n}\nint main()\n{\n    int a;\n    do {\n        scanf(\"%d\", &a);\n    } while (a < 1 || a > 6);\n    fun(a);\n    return 0;\n}\n\n", "Konwledge_Point": "算法与数字", "Question": "由用户输入一个小于5的正整数a，编写一个函数fun，输出由a开始的连续4个数字组成的所有无重复数字的4位数，要求一行6个数，数字间用空格分开，要求在主函数中完成输入和函数调用。\n例如输入2，输出则为:\n2345 2354 2435 2453 2534 2543                                       3245 3254 3425 3452 3524 3542                                     4235 4253 4325 4352 4523 4532                                      5234 5243 5324 5342 5423 5432\n麻烦分析下过程和算法步骤和画下流程图或者N-S图", "Tag": "算法分析"}
{"Answer": "这里的移动，是指用一个指针或者代表下标的整数去扫描这个字符串。这个指针++，就相当于向右移动。", "Konwledge_Point": "算法与数字", "Question": "这是一个关于数据结构字符集问题\nkmp算法，就移动模式串就好。普通字符串数组匹配，主串和模式串都移动。\n\n我很懵，字符串数组数据内容存储好后，怎么能移动呢？\n\n如果指的是移动数组索引，那kmp算法也移动主串和模式串索引了吧", "Tag": "算法分析"}
{"Answer": "#include<stdio.h>#include<string.h>#include<stdlib.h>void search(char* a,int n) {    if (a == NULL)        return;    int i=0;    int index = 0, maxindex = 0;    int length = 0, maxlength = 0;    while (i<=n)    {        if (a[i] >= '0'&&a[i] <= '9'){            length++;        }        else {            if (length > maxlength)            {                maxindex = i - 1;maxlength = length;            }            length = 0;        }        i++;    }    for (int i = maxindex - maxlength + 1; i <= maxindex; i++)        printf(\"%c\", a[i]);}int main(){    char a[100];    gets(a);    int n = strlen(a);    search(a,n);}", "Konwledge_Point": "算法与数字", "Question": "求各位指导怎么才能缩短这个算法的测试时间\n编写函数输出s中的连续最长的数字串\n输入样例：\n12abcde2345efg789xyz\n输出样例：\n2345\n时间限制：1000ms内存限制：32000kb\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n \n\n\nvoid\n \nNumStr\n(\nchar\n s[])\n\n\n{\n    \nint\n j=\n0\n;\n    \nchar\n str1[\n100\n],str2[\n100\n];\n    \nint\n len,temp=\n0\n;\n    len=\nstrlen\n(s);\n    \nfor\n(\nint\n i=\n0\n; i=\n'0'\n&&s[i]<=\n'9'\n)\n        {\n\n            str1[j]=s[i];\n            j++;\n            \nif\n(s[i+\n1\n]>\n'9'\n||s[i+\n1\n]<\n'0'\n)\n            {\n                \nif\n(temp<j)\n                    \nfor\n(\nint\n x=\n0\n;x<j;x++)\n                        str2[x]=str1[x];\n                temp=j;\n                j=\n0\n;\n            }\n        }\n    }\n        \nprintf\n(\n\"%s\"\n,str2);\n}\n\n\nint\n \nmain\n()\n\n\n{\n    \nchar\n s[\n100\n];\n    \ngets\n(s);\n    \nNumStr\n(s);\n    \nreturn\n \n0\n;\n}\n", "Tag": "算法分析"}
{"Answer": "稍微总结一下:\r\nJVM一定是有优化 才造成冒泡的逆序反而快了 这一点毫无疑问 这个优化不是系统的 而是JVM的 因为在.net上结果是合理的\r\n\r\n交换的时候的位数对交换没有影响 都是32位int类型 你看到的位数多少是没有意义的 所以是等价的", "Konwledge_Point": "算法与数字", "Question": "问一个关于排序算法效率的问题。\n就这段代码，下面有3种简单的排序法：冒泡、选择、插入。\n\n我的问题是，为什么冒泡排序和选择排序在对数组进行逆序排序的时候花的时间比对随机数组进行排序所花的时间少呢？\n\n\n\n[code=\"java\"]import java.util.Random;\n\npublic class ArrayUtil {\n\n\n\npublic static void bubbleSort(int[] array){\n    for(int i=0; iarray[j + 1]){\n                swap(array, j, j + 1);\n            }\n        }\n    }\n}\n\npublic static void selectionSort(int[] array){\n    for(int i=0; i=0 && temp1)。\n\n\n\n第一种 当前空间效率最好。但ArrayList变化时要频繁申请内存。\n\n\n\n第二种 总体效率比第一种好，但没有第三种好。\n\n\n\n第三种 倍数是关键，倍数太大，当前内存浪费过多，倍数太小要频繁申请内存。以前这个倍数大概是2，但数大量数据证明1.5是最好的倍数，再加1应该有更好的效率(oldCapacity 比较小的时候)。[/quote]\n\n\n\n果然，在JDK1.1中，Vector的源代码是这样：\n\n[code=\"java\"]    private void ensureCapacityHelper(int minCapacity) {\n\n    int oldCapacity = elementData.length;\n\n    Object oldData[] = elementData;\n\n    int newCapacity = (capacityIncrement > 0) ?\n\n        (oldCapacity + capacityIncrement) : (oldCapacity * 2);\n\n    if (newCapacity < minCapacity) {\n\n        newCapacity = minCapacity;\n\n    }\n\n    elementData = new Object[newCapacity];\n\n    System.arraycopy(oldData, 0, elementData, 0, elementCount);\n\n    }[/code]\n\n谢谢[url=\"\nhttp://mymgrubby.iteye.com/\"]mymGrubby[/url\n]\n\n\n\n还有一个问题就是为什么冒泡排序和选择排序在对数组进行逆序排序的时候花的时间比对随机数组进行排序所花的时间少呢？\n\n[b]问题补充：[/b]\n\n[quote=\"xuyao\"]我来回答一地问题，因为是随即数位数太多了，比较要比较高位，所以开销很大，这样没有可比性。你的逆序最大才1000，所以逆序快，建议生成同等位数的再试试。我反正试过了。[/quote]\n\n首先谢谢你的回答。\n\n我刚把generateRandomArray()方法给改了，改成这样：\n\n    [code=\"java\"]private static void generateRandomArray(int[] array) {\n\n        Random random = new Random();\n\n        for(int i=0; i<array.length; ){\n\n            int item = random.nextInt(10000);\n\n            int j;\n\n            if(i==0) array[i]=item;\n\n            for(j=0; j<i; ){\n\n                if(array[j]==item) break;\n\n                j++;\n\n            }\n\n            if(j==i){\n\n                array[i] = item;\n\n                i++;\n\n            }\n\n        }\n\n    }[/code]\n\n这样保证了生成的随机数组不包含重复的数字，并且是0到10000内的数字。但结果似乎仍然是老样子。\n\n[quote=\"xuyao\"]你的逆序最大才1000[/quote]array.length是10000，第一次循环，i=0，array.length - i应该是10000吧。 :) \n\n[b]问题补充：[/b]\n\n[quote=\"mymGrubby\"]对冒泡排序和选择排序来说，逆序情况下比随机情况下swap操作要少很多。[/quote]\n\n这个应该是不对的，冒泡排序逆序情况下每一步都要swap操作，是49995000次，随机的时候要少得多，比如我刚运行了一下，只swap了25152355次。而选择排序的swap操作在逆序情况下和随机情况下是一样的，都是9999次。\n\n[b]问题补充：[/b]\n\n[quote=\"RednaxelaFX\"]主要还是因为冒泡排序中除了交换之外，寻找逆序对的额外消耗太大了，无法忽略。如果遍历整个数组只完成了一次交换，而这个数组的长度有很大，那么遍历的过程本身显然就有着无法忽略的开销。 [/quote]\n\n可是似乎逆序的时候同样也要遍历相同次数，我并没有在哪个条件下改变i、j的增量，也没有在哪个条件下跳出某次循环。\n\n寻找逆序对的操作同样存在于对逆序数组排序的整个过程中呀。是吧？ :) ", "Tag": "算法分析"}
{"Answer": "在这段代码中，使用了两个do-while循环来寻找分界点。这种写法比较灵活，可以处理一些特殊的情况，例如数组中有重复元素时。具体来说，第一个循环会从左向右逐个扫描数组元素，直到找到第一个大于或等于分界值x的元素；而第二个循环则会从右向左逐个扫描数组元素，找到第一个小于或等于分界值x的元素。然后交换这两个元素的位置，并继续执行下一轮循环。\n如果我们改用<=和>=来判断元素的大小关系，会出现以下问题：当数组中存在多个与分界值相等的元素时，就会出现死循环的情况。具体地说，如果一个元素恰好等于分界值，那么它将被分到左右两个部分中，但由于使用的是<=和>=，所以它又会被不断地交换位置，直到程序进入死循环。因此，在快速排序算法中，通常会采用严格的<和>操作符来避免这种情况的发生。\n需要注意的是，在C++中，do-while循环与while循环的区别在于，do-while循环至少会执行一次循环体，即使条件不成立；而while循环可能一次都不执行。在这里，使用do-while循环的主要目的是保证每个指针至少会移动一次，确保程序能够正确地运行。", "Konwledge_Point": "算法与数字", "Question": "C++快速排序算法，请各位看看怎么解决疑问\n\n#\ninclude\n \nusing namespace std;\n\nconst \nint\n N=\n1e6\n+\n10\n;\n\nint\n p\n[N]\n;\n\nint\n n=\n0\n;\n\nvoid quick\n_sort(\nint\n \np\n[],\nint\n \nl\n,\nint\n \nr\n)\n\n{\n    \nif\n(l>=r)\n    return;\n    \nint\n x=p\n[\nl\n]\n,i=l-\n1\n,j=r+\n1\n;\n    \nwhile\n(ix);    \n        \nif\n(i=和<=", "Tag": "算法分析"}
{"Answer": "```\r\n  if (c_plus > t){\r\n            cout << \"Oh，my god!\" << endl;\r\n            continue;\r\n        }\r\n```\r\n\r\n\r\n\r\n```\r\n  if(sum > t) {\r\n        printf(\"Oh,my god!\\n\");\r\n        return;\r\n    }\r\n```", "Konwledge_Point": "算法与数字", "Question": "一道算法水题，但是不知道问题在哪，求解\n原题：\n\n\n\n\n\n   JH苦练10年，终于成为了一个神箭手，在下山之前，大师兄YZ不放心，想考验他，只给他一定时间t，同时给他n支箭，最终根据他的表现，考虑他是否能下山。\n   对于每发一次箭，YZ给他4种成绩（优、良、中、差），JH有三种拉弓以及瞄准时间a ,b，c（a>=b>=c）分别能拿优，良，中等级，如果不拉弓不瞄（直接射），只能拿差（不能中靶）了。\n   现在JH想知道，在保证自己弹无虚发（不获得差）的情况下，最多能拿多少个优。\n   如果JH不能做到弹无虚发，输出Oh，my god! \n\n\n\n\nInput\n\n\n\n   输入数据包含T组:\n   对于每组数据，第一行为一个整数n，表示总共有n支箭。\n\n\n\n\n（0\n#include \n#include \n#include \n#include \n#include \n#include \n#include \n#include \n#include \n#include \n#include \nusing namespace std;\n//DEBUG MODE\n#define debug 0\n//循环\n#define REP(n) for(int o=0;o rhs.delta;\n    }\n};\nTime UseTime[maxn];\nvoid Do() {\n    int t,n,UT=0;\n    scanf(\"%d\",&n);\n    int sum = 0;\n    REP(n) {\n        int a,c;\n        scanf(\"%d%*d%d\",&a,&c);\n        sum += c;\n        UT += a;\n        UseTime[o] = Time(a,c);\n    }\n    scanf(\"%d\",&t);\n    if(sum > t) {\n        printf(\"Oh,my god!\\n\");\n        return;\n    }\n    sort(UseTime,UseTime + n);\n    int ans = n;\n    for(int i = 0;UT > t;i++) {\n        ans--;\n        UT -= UseTime[i].delta;\n    }\n    printf(\"%d\\n\",ans);\n}\nint main() {\n    int T;\n    scanf(\"%d\",&T);\n    while(T--)\n        Do();\n    return 0;\n}\n\n\n\n\n代码2：\n\n\n\n#include \n#include \nusing namespace std;\n\nstruct TimeNode {\n    int a, c, delta;\n    TimeNode(int A = 0, int C = 0){\n        a = A;\n        c = C;\n        delta = a-c;\n    }\n    bool operator < (const TimeNode &rhs) const {\n        return delta > rhs.delta;\n    }\n};\nint main(void){\n    TimeNode times[1005];\n    int T = 0;\n    cin >> T;\n    while (T--){\n        int n = 0, t = 0, a = 0, b = 0, c = 0, a_plus = 0, c_plus = 0;\n        cin >> n;\n        for (int count = 0; count < n; count++){\n            cin >> a >> b >> c;\n            times[count] = TimeNode(a,c);\n            a_plus += a;\n            c_plus += c;\n        }\n        cin >> t;\n        if (c_plus > t){\n            cout << \"Oh，my god!\" << endl;\n            continue;\n        }\n        sort(times, times+n);\n        for (int count = 0; a_plus > t; count++){\n            n--;\n            a_plus -= times[count].delta;\n        }\n        cout << n << endl;\n    }\n    return 0;\n}\n\n\n\n\n\n程序1正确但是程序2无法通过，但是我觉得两个程序的语义是一样的，求解。", "Tag": "算法分析"}
{"Answer": "直接split就好，楼上的substring用错了，substring(12)是从这个位置开始截取到最后，前面12位应该是substring(0,12)\r\n\r\n\r\n```\r\n public String getStr(){\r\nString[]strs = str.split(\"\\\\[Cc]\");//可能是\\\\C，没有实际测试\r\n\r\nfor(int i = 0; i < strs.length;i++){\r\n\tif(i == 0)//第一个一定不以\\c开头\r\n\t\tcontinue;\r\n\tif(strs[i].length>12)\r\n\t\treturn strs[i].substring(0,12);\r\n\telse if(strs[i].length == 12)\r\n\treturn strs[i];\r\n}\r\n}\r\n```\r\n\r\n大概这样就好了.", "Konwledge_Point": "算法与数字", "Question": "。。。java中一个小算法，来请教一下\n测试用字符串：\n\nItem0=800,11,0,\\fk3232\\C008028\\c255000000000 欢迎行驶\\n郑州金水路\\n\n\nItem1=800,11,0,\\fk3232\\C024023\\c255000000000注意安全\\n\\fk3232\\C024070\\c255000000000谨慎驾驶\\n\n\nItem2=800,11,0,\\fk3232\\C008032\\c000255000000 欢迎行驶\\n郑州金水路\\n\n\nItem0=300,11,0,\\fs3232\\C032000\\c255000000000谨慎驾驶 注意安全\\C000000\\BB04\n\nItem1=300,14,0,\\fs3232\\c255000000000 欢迎行驶 高速公路！\n\nItem2=300,13,0,\\fs3232\\c255255255000保持车距祝您一路平安\n\nItem0=300,12,0,\\fk2424\\c255000000000欢迎行驶\\n濮鹤高速\n\nItem1=300,14,0,\\fk2424\\c000255000000注意安全\\n谨慎驾驶\\fk2424\n\nItem2=300,76,0,\\fk2424\\c255255255000hello\\nworld\n\n1. 只有\\c中才会包含需要的信息，\n\n2.\\c后边有12个数字，这个12是固定的，\n\n需求是：\n\n给定任意固定格式的字符串，取出\\c 至结束，或者 \\c至下一个\\中间，除了\"\\c255255255255\"之外的信息\n\n比如：Item2=300,76,0,\\fk2424\\c255255255000hello\\nworld 中\n\n取出hello world\n\n\n\n。下边是我写的两种实现方式，虽然我的可以满足业务需求了。总觉得应该还有更便捷的方式，来这里问问大神\n\n这是我第一次写的。不用说，纯粹是跟着第一感觉走的，很啰嗦\n\n这是第二次写的，还是觉得啰嗦，", "Tag": "算法分析"}
{"Answer": "```\r\n #include\r\n#include\r\nusing namespace std;\r\nint x=0; //记录最大值 \r\nint flag[43]; //辅助数组由题可知10 10 10 9 10 10 8 10 10这样最大的数据所能走的最大距离为43所有下标43够了\r\nint N[]={0,1,2,3,4,5,6,7,8}; //辅助九个动作全排列数组\r\nstruct \r\n{\r\nint pos; //此人当前所在的位置\r\nint flag; //如果flag为0代表没被举 1代表被举了\r\nint juren;\r\nint mvflag;     //移动标志位如果没移动则为0 移动了则为1\r\nint mvmax;  //移动的最大步数\r\nint thrflag;  //丢标志位丢过为1没丢过则为0\r\nint thrmax;  //丢的最大距离 \r\n}People[3];   //三个人 \r\nvoid swap(int a,int b)\r\n{\r\nint temp=N[a];\r\nN[a]=N[b];\r\nN[b]=temp;\r\n}\r\nvoid judge(int a,int b,int pos)\r\n{\r\nswitch(People[0].thrflag+People[1].thrflag+People[2].thrflag) //0代表第一次丢人的人不用去判断走.1代表第二次丢 2代表第三次丢 \r\n{\r\ncase 1: if(People[a].mvflag==0)//如果背人的这个没走过且是第二次丢人\r\n x=x>pos+People[a].mvmax+1+People[b].thrmax?x:pos+People[a].mvmax+1+People[b].thrmax;  //这里有个比较巧的事情 \r\nbreak;\r\ncase 2: if(People[a].mvflag==0)//如果背人的这个没走过且是第三次丢人 \r\nif(People[a].mvmax>People[a].thrmax)\r\n x=x>pos+People[a].mvmax?x:pos+People[a].mvmax; \r\nif(People[b].mvflag==0)//如果被扔的人还能走则计算一下最远距离\r\nx=x>pos+People[a].thrmax+People[b].mvmax?x:pos+People[a].thrmax+People[b].mvmax;\r\nbreak;\r\n}\r\n}\r\nvoid Permutations(int n)\r\n{\r\nfor(int i=n;i<9;i++)\r\n{\r\nswap(i,n);\r\nint p=N[n]/3; \r\n//当前动作的人0-2为第一个人的动作一次类推\r\nint pos=People[p].pos;//此人当前所在位置 \r\nint j;\r\nswitch(N[n]%3)//根据动作的不同选择该人需要做的事 当前动作？0为移动1为举2为扔\r\n{\r\ncase 0: \r\nif(People[p].flag||People[p].juren)break; \r\n//如果被举或者举了人都不能移动直接退出\r\nx=x>pos+People[p].mvmax?x:pos+People[p].mvmax;//当前位置加上移动最大值如果大于原值则替换\r\nfor(j=1;j<=People[p].mvmax;j++)//逐步往后移动 \r\n{\r\nif(flag[pos+j]==0)//如果可以移动才移动 \r\n{\r\nflag[pos]=0;  //原位置清0\r\nflag[pos+j]=p+1;//下一位置为该人下标+1 \r\nPeople[p].pos=pos+j; \r\n//此人当前位置变为移动后的位置 \r\nPeople[p].mvflag=1; \r\n//1代表移动过了\r\nPermutations(n+1); \r\nPeople[p].mvflag=0;//所有状态回朔\r\nflag[pos+j]=0; \r\nflag[pos]=p+1; \r\nPeople[p].pos=pos; \r\n \r\n}\r\n} \r\nfor(j=1;j<=People[p].mvmax;j++)//逐步往前移动  \r\n{\r\nif(pos-j>0&&flag[pos-j]==0) //可以移动且大于0\r\n{\r\nflag[pos]=0;  //原位置清0\r\nflag[pos-j]=p+1;//下一位置为该人下标 \r\nPeople[p].pos=pos-j; \r\n//此人当前位置变为移动后的位置 \r\nPeople[p].mvflag=1; \r\n//1代表移动过了\r\nPermutations(n+1); \r\nPeople[p].mvflag=0; \r\nflag[pos-j]=0;//所有状态回朔 \r\nflag[pos]=p+1; \r\nPeople[p].pos=pos; \r\n \r\n} \r\n}\r\nbreak;\r\ncase 1:\r\nif(People[p].flag==1)break;   \r\n//如果此人被举则不能举别人直接退出因为是全排列计算不会出现此人举过再举\r\nif(flag[pos+1]!=0)//后面有人则先举后面的 \r\n{\r\nPeople[p].juren=flag[pos+1];  //举了这个人\r\nPeople[flag[pos+1]-1].flag=1 ;//被举人状态变为被举 \r\nflag[pos+1]=0;//后面的人被举了之后位置清0\r\nPermutations(n+1);\r\nflag[pos+1]=People[p].juren;//回朔\r\nPeople[p].juren=0;   \r\nPeople[flag[pos+1]-1].flag=0 ;\r\nPeople[flag[pos+1]-1].pos=pos+1; //位置复位 \r\n} \r\nif(flag[pos-1]!=0&&pos-1>0)//原理同上举后面的人 \r\n{\r\nPeople[p].juren=flag[pos-1];  //举了这个人\r\nPeople[flag[pos-1]-1].flag=1 ;//被举人状态变为被举 \r\nflag[pos-1]=0;//后面的人被举了之后位置清0\r\nPermutations(n+1);\r\nflag[pos-1]=People[p].juren;//回朔\r\nPeople[p].juren=0;   \r\nPeople[flag[pos-1]-1].flag=0 ;\r\nPeople[flag[pos-1]-1].pos=pos-1; //位置复位 \r\n}\r\nbreak;\r\ncase 2:\r\nif(People[p].juren==0||People[p].flag==1)break; //如果没举人或者被别人举了则不能扔直接退出 \r\nx=x>pos+People[p].thrmax?x:pos+People[p].thrmax;\r\nint juren=People[p].juren-1;//-1之后 才是此人操作的下标 \r\njudge(p,juren,pos);  //这个函数是整个裁剪的关键部分，处理之后可以让丢过人的人不用再走而得到最大距离\r\nfor(j=1;j<=People[p].thrmax;j++)\r\n{\r\nif(flag[pos+j]==0)//丢原理和移动类似 \r\n{\r\nPeople[juren].pos=pos+j;  //被丢人的位置变为丢到的位置 这里有一个地方没有清0就是背人标记位，从而减少了不必要的移动。\r\nPeople[juren].flag=0;     //被举状态复位\r\nflag[pos+j]=juren+1; //标记位置信息\r\nPeople[p].thrflag=1; //状态变为扔过人 \r\nPermutations(n+1); \r\nPeople[p].thrflag=0; //回朔 \r\nPeople[juren].flag=1;     //被举状态复位\r\nflag[pos+j]=0; //标记位置信息\r\n}\r\n}\r\nfor(j=1;j<=People[p].thrmax;j++)\r\n{\r\nif(flag[pos-j]==0&&pos-j>0)//丢原理和移动类似 \r\n{\r\nPeople[juren].pos=pos-j;  //被丢人的位置变为丢到的位置\r\nPeople[juren].flag=0;     //被举状态复位\r\nflag[pos-j]=juren+1; //标记位置信息\r\nPeople[p].thrflag=1; \r\nPermutations(n+1); \r\nPeople[p].thrflag=0; \r\n //回朔 \r\nPeople[juren].flag=1;     //被举状态复位\r\nflag[pos-j]=0; //标记位置信息\r\n}\r\n}\r\nbreak;\r\n} \r\nswap(i,n); //回朔 \r\n}\r\n}\r\nint main()\r\n{\r\nint i,j;\r\nx=0;\r\nmemset(flag,0,sizeof(flag));\r\nmemset(People,0,sizeof(People));\r\nfor(i=0;i<3;i++)\r\n{\r\ncin>>People[i].pos>>People[i].mvmax>>People[i].thrmax; //输入位置信息以及丢和扔的最大距离\r\nflag[People[i].pos]=i+1; \r\n//将位置绑定为当前人 因为0代表没人所以人下标加1 \r\n}\r\nPermutations(0);//9个动作递归全排列计算\r\ncout<<x<<endl;\r\nreturn 0;\r\n}\r\n```", "Konwledge_Point": "算法与数字", "Question": "蓝桥杯-算法训练 Lift and Throw 求教各位大牛，谢谢各位\n问题描述\n\n　　给定一条标有整点(1, 2, 3, ...)的射线. 定义两个点之间的距离为其下标之差的绝对值.\n\n　　Laharl, Etna, Flonne一开始在这条射线上不同的三个点, 他们希望其中某个人能够到达下标最大的点.\n\n　　每个角色只能进行下面的3种操作, 且每种操作每人不能进行超过一次.\n\n\n\n　　1.移动一定的距离\n\n　　2.把另一个角色高举过头\n\n　　3.将举在头上的角色扔出一段距离\n\n\n\n　　每个角色有一个movement range参数, 他们只能移动到没有人的位置, 并且起点和终点的距离不超过movement range.\n\n　　如果角色A和另一个角色B距离为1, 并且角色B没有被别的角色举起, 那么A就能举起B. 同时, B会移动到A的位置,B原来所占的位置变为没有人的位置\n\n\n\n. 被举起的角色不能进行任何操作, 举起别人的角色不能移动.同时, 每个角色还有一个throwing range参数, 即他能把举起的角色扔出的最远的距离. \n\n\n\n注意, 一个角色只能被扔到没有别的角色占据的位置. 我们认为一个角色举起另一个同样举起一个角色的角色是允许的. 这种情况下会出现3个人在同一\n\n\n\n个位置的情况. 根据前面的描述, 这种情况下上面的两个角色不能进行任何操作, 而最下面的角色可以同时扔出上面的两个角色. 你的任务是计算这些角\n\n\n\n色能够到达的位置的最大下标, 即最大的数字x, 使得存在一个角色能够到达x.\n\n输入格式\n\n　　输入共三行, 分别为Laharl, Etna, Floone的信息.\n\n　　每一行有且仅有3个整数, 描述对应角色的初始位置, movement range, throwing range.\n\n　　数据保证3个角色的初始位置两两不相同且所有的数字都在1到10之间.\n\n输出格式\n\n　　仅有1个整数, 即Laharl, Etna, Flonne之一能到达的最大距离.\n\n样例输入\n\n9 3 3\n\n4 3 1\n\n2 3 3\n\n样例输出\n\n15\n\n样例说明\n\n　　一开始Laharl在位置9, Etna在位置4, Flonne在位置2.\n\n　　首先, Laharl移动到6.\n\n　　然后Flonne移动到位置5并且举起Etna.\n\n　　Laharl举起Flonne将其扔到位置9.\n\n　　Flonne把Etna扔到位置12.\n\n　　Etna移动到位置15.\n\n    原题地址：\nhttp://lx.lanqiao.org/problem.page?gpid=T356\n\n    希望各位能解答一下，最好能提供一下思路和源代码，感激不尽", "Tag": "算法分析"}
{"Answer": "其实每步都可以知道还剩多少个数字，判断奇偶就可以每次从左到右执行的", "Konwledge_Point": "算法与数字", "Question": "报数游戏 用c语言写 输出最后剩下的数字\n给定一个从 1 到 n 排序的整数列表。\n首先，从左到右，从第一个数字开始，每隔一个数字进行删除，直到列表的末尾。\n第二步，在剩下的数字中，从右到左，从倒数第一个数字开始，每隔一个数字进行删除，直到列表开头。\n我们不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。\n返回长度为 n 的列表中，最后剩下的数字。\n输入n 的数 输出最后剩下的数字", "Tag": "算法分析"}
{"Answer": "对String进行操作，字符的分割、正则表达式都能解决这些问题", "Konwledge_Point": "算法与数字", "Question": "数据类型问题一枚\n[size=large][color=red]在别的语言中可以直接这样\n\n\n\n比如：int i =10;\n\n\n\nString one= \"abcd\" + i;\n\n\n\n//输出：这个数字是10\n\n\n\n在object_c中该怎么实现啊\n\n\n\nint i = 10;\n\n\n\nNSStirng *one = @\"abcd\" + i;\n\n\n\n//这里这样写肯定是错的，不知道正确的写法是什么，达到上面的那种效果，就是字符串和整形怎么衔接在一起啊\n\n\n\n还有比如java中两个字符串拼接可以直接用+号，在OC都难道只能用拼接函数实现吗？[color=red][/color][/color][/size]", "Tag": "算法分析"}
{"Answer": "题目是什么？你定义int i[7]，那么只能用i[0]到i[6]，你用i[7]就越界了而且每个for循环应该是0到6，不是1到7，也是越界了整个数组边界都是乱套的", "Konwledge_Point": "算法与数字", "Question": "特定数字组成的平方数\n我觉得我的算法思路没问题就是把原数组的下标进行排列组合然后组合成一个七位数，但是运行的时候运行不出结果，没有任何输出。请求指点谢谢。\n\n", "Tag": "算法分析"}
{"Answer": "\n \nnum = int(input(\"请输入数字\"))\na = 1\nwhile a < num:   //去掉等于号\n    if num % a == 0:\n        print(a)\n    a += 1\n \n", "Konwledge_Point": "算法与数字", "Question": "python找出一个整数的所有因子\n用循环写一个整数的所有因子数\n\n\n\n\nnum\n = int(input(\n\"请输入数字\"\n))\n\na\n = \n1\n\n\nwhile\n \na\n <= \nnum\n:\n    \nif\n \nnum\n % \na\n == \n0\n:\n        print(\na\n)\n    \na\n += \n1\n\n\n\n\n\n这个把本身也输出了，怎么去掉本身", "Tag": "算法分析"}
{"Answer": "如果不是有序的，那么比较绝对值，找到最小的。\r\n```\r\n#include \r\n\r\nint main()\r\n{\r\n\tint min = (1 << 31) - 1;\r\n\tint idx = 0;\r\n\tint arr[] = {915,941,960,976,992,1015,1034,1050,1073,1089,1115,1131,1150,1166,1182,1208,1227};\r\n\tint n = 1000;\r\n\tfor (int i = 0; i < sizeof(arr) / sizeof(int); i++)\r\n\t{\r\n\t\tint diff = arr[i] - n;\r\n\t\tif (diff < 0) diff = -diff;\r\n\t\tif (diff < min)\r\n\t\t{\r\n\t\t\tmin = diff;\r\n\t\t\tidx = i;\r\n\t\t}\r\n\t}\r\n\tprintf(\"最接近的是%d 下标是%d\", arr[idx], idx);\r\n   \treturn 0;\r\n}\r\n```\r\n最接近的是992 下标是4", "Konwledge_Point": "算法与数字", "Question": "C语言，目标值与数组所有元素去比对，找出最接近的元素，输出下标\n举例如下：一个数组{915,941,960,976,992,1015,1034,1050,1073,1089,1115,1131,1150,1166,1182,1208,1227};目标值假设是1000，我自己之前用插值算法公式mid = start + (end - start) * ( (key-a[start])/(a[end]-a[start]) )可以快速查找出中间位置，算出大概接近的元素，输出下标，但是我的实际需求数组不一定都是这么有序或者单调的，为保证更准确，我想将目标值一个一个去比对，然后找出数组中最接近的元素，输出数组下标，求老师们帮忙指导一下，求代码和注释", "Tag": "算法分析"}
{"Answer": "100+200+300+324+400+500+600+700=3124\n先确定个问题，以下两种情况不在目标组合里吧？100+100+400+324+400+500+600+700=3124。100+400+100+324+400+500+600+700=3124。\n能想到比较简单的思路是，分配8个100 到列表里，然后用目标数3124-800=2324 ， 做8层遍历， 依次加到列表中的8个数里，新数如果在结果集中出现，忽略。\n这样，问题就转换为 求8个不重复整数，和为2324的问题。递归算法，把 0-2324 数用完，取8个数，如果和为2324 ，输出。", "Konwledge_Point": "算法与数字", "Question": "8个互不相同三位正整数之和是1234四个数字组成的四位数，这样的组合有多少个？\n8个互不相同三位正整数之和是1234四个数字组成的四位数，这样的组合有多少个？\n\n\n例如：\n100+200+300+324+400+500+600+700=3124。\n\n\n八个数之和为1234，或1243，或1324……4321等24种情形的，都计算在内。\n\n\n求：算法；代码；运行结果；时耗。", "Tag": "算法分析"}
{"Answer": ";=================================================================\r\nCODE    SEGMENT PUBLIC USE16 'CODE'\r\n\tASSUME CS:CODE, DS:DATA,ES:DATA,SS:STACK\r\nSHOW_MSG MACRO msg\r\n\tpush ax\r\n\tpush dx\r\n\tmov dx,offset msg\r\n\tmov ah,9\r\n\tint 21h\r\n\tpop dx\r\n\tpop ax\r\n\tENDM\r\nSHOW_ASC MACRO\r\n\tpush ax\r\n\tmov ah,2\r\n\tint 21h\r\n\tpop ax\r\n\tENDM\r\n\r\nShowDat10 proc\r\n\tpush ax\r\n\tpush bx\r\n\tpush cx\r\n\tpush dx\r\n\tpush si\r\n\txor bx,bx\r\n\tmov si,offset DatAsc\r\n\taam\r\n\tmov bl,ah\r\n\tmov dl,[si+bx]\r\n\tSHOW_ASC\r\n\tmov bl,al\r\n\tmov dl,[si+bx]\r\n\tSHOW_ASC\r\n\tpop si\r\n\tpop dx\r\n\tpop cx\r\n\tpop bx\r\n\tpop ax\r\n\tretn\r\nShowDat10 Endp\r\nSTART:\r\n\tmov ax,STACK\r\n\tmov ss,ax\r\n\tmov sp,offset StackE\r\n\tmov ax,DATA\r\n\tmov ds,ax\r\n\tSHOW_MSG msg1\r\n\tmov si,offset dat\r\n\tmov cx,10\r\n\txor bx,bx\r\n\tcld\r\nLocLoop:\r\n\tlodsb\r\n\tcmp al,bl\r\n\tjb NotG\r\n\tmov bl,al\r\nNotG:\r\n\tloop LocLoop\r\n\tmov ax,bx\r\n\tcall ShowDat10\r\n\tSHOW_MSG msgCrLf\r\n\tmov ah,4ch\r\n\tint 21h\r\nCODE ENDS\r\n;============================================================================\r\nSTACK   SEGMENT USE16 'STACK'\r\n        DB 200h dup ('-STACK- ')\r\nStackE  equ $\r\nSTACK   ENDS\r\n;============================================================================\r\nDATA   SEGMENT DWORD PUBLIC USE16 'DATA'\r\nDatAsc  db '0123456789ABCDEF'\r\ndat     DB 6,3,11,66,34,67,31,33,89,45\r\nmsg1    db 'MAX IS $'\r\nmsgCrLf db 0dh,0ah,24h\r\nDATA    ENDS\r\n\tEND START", "Konwledge_Point": "算法与数字", "Question": "用8086汇编语言找出10个字节无符号数中的最大数，并进行显示输出。\n要求：\n\n数据段提前存好十个无符号数。\n\n得到的最大数也保存在数据段。\n\n利用系统功能调用进行结果的输出。\n\n使用分支和循环程序设计实现。\n\n尽量使用子程序或者宏的程序设计方法使程序整体简洁。\n\n最好写出算法", "Tag": "算法分析"}
{"Answer": "\n#include<stdio.h>\n#include<string.h>\nint main()\n{\n    //存储并接收组数\n    int a;\n    scanf(\"%d\",&a);\n    \n    //吃数字后面的回车\n    //但凡以后遇见数字回车，字符，一定要加上getchar，否则计算机会把数字后面的回车当做字符处理\n    getchar();\n    \n    //循环输入每组牌\n    for(int i=0;i<a;i++)\n    {\n        //存储每组牌\n        //小编觉得要将每组牌存储在一个大数组中\n        //因为题干有提示首尾有若干空格\n        //所以我觉得scanf(\"%s %d\",char*_,int_)这种格式可能接收不到末尾的空格\n        //哪怕后面加上getchar也只能接受一个空格，而空格的数量是不确定的\n        //导致空格或者回车可能会存储到下一组的字符数组里面，这样的程序肯定错误\n        char b[1001];\n        \n        //接收牌\n        gets(b);\n        \n        //存储牌的数量\n        int c=0;\n        \n        //存储牌的花色\n        char d[500][20];\n        \n        //存储牌的大小\n        int e[500]={0};\n        \n        //控制d数组每个花色字符串的结束\n        int k=0;\n        \n        //将大数组牌的花色和大小分别存储到两个数组中\n        for(int j=0;j<strlen(b);j++)\n        {\n            //判断是否是字母，如果是，存储到d数组中，以空格为标志结束\n            if(b[j]>='a'&&b[j]<='z')\n            {\n                //第一维控制每个花色\n                //第二位控制每个花色的字母\n                d[c][k++]=b[j];\n                \n                //如果该字母后面是空格，证明本花色字符串结束\n                if(b[j+1]==' ')\n                {\n                    //结束每个花色，字符串以'\\0'作为结束标志\n                    d[c][k]='\\0';\n                    \n                    //将k赋值0，准备接收下一个花色\n                    k=0;\n                    \n                    //小编这种字符串也有些不确定，打印出来看一下前面程序的正确性\n                    //printf(\"%s \",d[c]);\n                }\n            }\n            \n            //判断是否是数字\n            else if(b[j]>='0'&&b[j]<='9')\n            {\n                e[c]=e[c]*10+b[j]-'0';\n                \n                //如果改数字后面是'\\0'或者' '说明数字结束\n                //将控制第一维的变量c加一\n                //准备接收下一个牌的花色和大小\n                //d数组和e数组的角标相互对应\n                if(b[j+1]=='\\0'||b[j+1]==' ')\n                {\n                    //同样，打印一下，看一下效果，校验前面代码是否符合要求\n                    //printf(\"%d\\n\",e[c]);\n                    c++;\n                }\n            }\n        }\n        \n        //上面代码执行完毕，说明花色和大小已经分别存储在两个数组中\n        //进行下一步，排序\n        for(int j=0;j<c;j++)\n        {\n            for(int k=j+1;k<c;k++)\n            {\n                //作为交换时的中间变量\n                char tp[20];\n                \n                //先比较大小，如果前面的牌比后面的小，调换一下位置\n                if(e[j]<e[k])\n                {\n                    //先交换大小\n                    int temp=e[j];\n                    e[j]=e[k];\n                    e[k]=temp;\n                    \n                    //因为d数组存储的花色和e数组存储的大小的角标是相互对应的\n                    //d数组也要进行交换\n                    //因为d数组里面是字符串\n                    //所以要用字符串复制的函数strcpy\n                    //如果用赋值即“=”程序报错\n                    strcpy(tp,d[j]);\n                    strcpy(d[j],d[k]);\n                    strcpy(d[k],tp);\n                }\n                \n                //大小相同，比较花色\n                else if(e[j]==e[k])\n                    \n                    //因为每个花色的首字母不同，所以我们可以根据首字母判断花色\n                    //如果前一张牌的花色是‘d’，则一定小于后一张牌的花色，交换花色\n                    //如果后一张牌的花色是‘s’，则一定大于前一张牌的花色，交换花色\n                    //如果前一张牌的花色是‘c’，后一张牌的花色是‘h’\n                    //前一张牌的花色小于后一张牌的花色，交换花色\n                    //就这三种情况，如果花色不是‘d’和‘s’，那就只能是‘c’和‘h’\n                    //同理，如果有一个是‘c’，另一个不是‘h’，则一定是‘d’或‘s’\n                    //其他情况则无需交换花色\n                    if(d[j][0]=='d'||d[k][0]=='s'||(d[j][0]=='c'&&d[k][0]=='h'))\n                    {\n                        //同理，利用函数交换字符串\n                        strcpy(tp,d[j]);\n                        strcpy(d[j],d[k]);\n                        strcpy(d[k],tp);\n                    }\n            }\n        }\n        \n        //打印，因为结尾没有空格，所以只打印到倒数第二个\n        for(int j=0;j<c-1;j++)\n            printf(\"%s %d \",d[j],e[j]);\n        \n        //打印最后一个，并换行\n        printf(\"%s %d\\n\",d[c-1],e[c-1]);\n    }\n    \n    return 0;\n}\n", "Konwledge_Point": "算法与数字", "Question": "这个问题是需要改排序算法吗，显示运行超时其他的没错\n小诺诺喜欢玩纸牌比大小的游戏。现在有一副牌中的若干张纸牌，需要按牌面的数字从大到小的顺序排列，若数字大小相同则按花色从大到小（黑桃>红桃>梅花>方块）排列。牌面为A、J、Q、K分别用1、11、12、13表示；花色中的黑桃、红桃、梅花、方块分别用英文单词\"spade\"、\"heart\"、\"club\"、\"diamond\"表示。\n\n\n输入格式:\n测试数据有多组，首先输入测试的组数T （0\n#include\ntypedef struct {\n    char r[10];\n    int x;\n    int f;\n}Card;\nCard card[100];\nchar ap[100];\nint main(){\n    int l=0;\n    int T;\n\n\nscanf(\n\"%d\"\n,&\nT\n);\ngetchar();\nwhile(\nT\n--){\nchar e=\n'a'\n;\nl=\n0\n;\nwhile(e!=\n'\\n'\n){\n\nscanf(\n\"%s%d\"\n,&card[l].r,&card[l].x);\nl++;\ne=getchar();\n}\nfor(int n=\n0\n;n<l;n++){\n    \n        if(card[n].r[\n0\n]==\n'h'\n)\n        card[n].f =\n3\n;\n        if(card[n].r[\n0\n]==\n's'\n)\n        card[n].f =\n4\n;\n        if(card[n].r[\n2\n]==\n'u'\n)\n        card[n].f =\n2\n;\n        if(card[n].r[\n1\n]==\n'i'\n)\n        card[n].f =\n1\n;\n    \n}\n    \n\nCard\n t;\n for(int i=\n0\n;i<l;i++)\n        for(int j=\n0\n;j<l\n-1\n-i;j++)\n        {\n        \n            if(card[j].x<card[j+\n1\n].x){\n                t=card[j];\n                card[j]=card[j+\n1\n];\n                card[j+\n1\n]=t;\n            }\n            if(card[j].x==card[j+\n1\n].x)\n                if(card[j].f<card[j+\n1\n].f){\n                t=card[j];\n                card[j]=card[j+\n1\n];\n                card[j+\n1\n]=t;\n            }\n            }\nfor(int i=\n0\n;i<l;i++)\n        printf(\n\"%s %d  \"\n,card[i].r,card[i].x );\n        printf(\n\"\\n\"\n);\n        \n\n\n\n}\n\n\n}", "Tag": "算法分析"}
{"Answer": "你好，把solution改成x2就行拉\nsyms x2\nF=0.5;\nB=30;\nf1=(x2/(2+x2))*(1-x2)*(1-((-5+F+120*(x2/(x2+12)))*((F*(B-x2))/(F/0.2+20))/F/200))*(1-(2+F/0.02+50*(0.6/(F*x2))));\nx2=vpasolve(f1,x2,[0,3000]);\nx1=(F*(B-x2))./(123+F+50*x2);\nx3=(10+F+5*x2).*((F*(B-x2))./(F+5*x2)); \nx4=(-5+F*4+5*(x2./(5*x2+5))).*((4+F/0.1+20*(x2./(x2+10)))); \nx5=(-5+F+(x2./(x2+2))).*(10/F+12./(F*x2)).*((F*(B-x2))./(F+(x2./(x2+B))));\np1=[x1,x2,x3,x4,x5]\n\n结果：\np1 =\n \n[                              30/247,   0,                               315,                                -27,                               -Inf]\n[ 0.083573487031700288184438040345821, 1.0, 40.863636363636363636363636363636, -27.045454545454545454545454545455, -4994.4444444444444444444444444444]\n\n可见有5列呢", "Konwledge_Point": "算法与数字", "Question": "matlab结果显示为表达式，为何不能计算结果\n%想应用matlab求出x2的值，再通过x2与x1,x3,x4,x5的关系式，\n求出x1,x3,x4,x5的值，但是matlab输出结果只有x2的值，\nx1,x3,x4,x5都是表达式呈现的，没有数值结果。\n大致程序如下，请求大家指点\n\n\nsyms x1 x2 x3 x4 x5\nF=0.5;\nB=30;\nf1=(x2/(2+x2))*(1-x2)*(1-((\n-5\n+F\n+120\n*(x2/(x2\n+12\n)))*((F*(B-x2))/(F/0.2\n+20\n))/F/200))*(1-(2+F/0.02\n+50\n*(0.6/(F*x2))));\nsolution=vpasolve(f1,x2,[0,3000])\nx1=(F*(B-x2))/(123+F\n+50\n*x2);\nx3=(10+F\n+5\n*x2)*((F*(B-x2))/(F\n+5\n*x2)); \nx4=(\n-5\n+F*4\n+5\n*(x2/(5*x2\n+5\n)))*((4+F/0.1\n+20\n*(x2/(x2\n+10\n)))); \nx5=(\n-5\n+F+(x2/(x2\n+2\n)))*(10/F\n+12\n/(F*x2))*((F*(B-x2))/(F+(x2/(x2+B))));\np1=[x1,x2,x3,x4,x5]\n\n\n", "Tag": "算法分析"}
{"Answer": "#include \r\n#include \r\nint main()\r\n{  \r\n     int n, i, j;\r\n     char a[10];\r\n     for(n = 123; n < 330; n++)\r\n     {\r\n         sprintf(a, \"%d\", n * 1000000 + n * 2 * 1000 + n * 3);\r\n         for(j = 0, i = '1'; i <= '9'; memchr(a, i++, 9) && j++);\r\n         if (j == 9)\r\n             printf(\"%d %d %d \\n\", n, n * 2, n * 3);\r\n       }\r\n return 0;\r\n }\r\n\r\n ![图片说明](https://img-ask.csdn.net/upload/201809/22/1537579761_80792.jpg)", "Konwledge_Point": "算法与数字", "Question": "大神能教教下面这道题吗。。\n用1，2，3，…，9组成3个三位数abc，def和ghi，每个数字恰好使用一次，要 求abc：def：ghi＝1：2：3。按照“abc def ghi”的格式输出所有解，每行一个解。", "Tag": "算法分析"}
{"Answer": "![图片说明](https://img-ask.csdn.net/upload/202004/15/1586921582_36523.gif)\r\n\r\n下载地址：\r\nhttps://download.csdn.net/download/caozhy/12328131", "Konwledge_Point": "算法与数字", "Question": "c语言程序从1~16这16个数字中选出6个数字使其相加和为45，求个运行成功的代码\n要求\n\n1. 从1~16这16个数字中选出6个数字使其相加和为45。\n\n2.  可以动态设置数据中必须包括数和必须不能包括数，（如必须有1，2，3，不能有4，5）用MFC做成对话框形式。\n\n3. 输出满足条件的组数和每组的数据。\n\n\n\n（发个类似图片的代码就行", "Tag": "算法分析"}
{"Answer": "直接用Long的hashCode\r\n\r\nlong value;//手机号\r\nint hashCode=(int)(value ^ (value >>> 32));\r\nint index=hashCode%20;", "Konwledge_Point": "算法与数字", "Question": "通过取模方式，随机获得20个分区\n假如有100万个手机号码，要均匀分布到20个数据库分区，取模如何是好呢？当然其它好的算法也成\n\n我试验了下通过手机号码的最后两位数的asicc码取模，不太理想", "Tag": "算法分析"}
{"Answer": "你这是排序啊……", "Konwledge_Point": "算法与数字", "Question": "编写函数，求一个数组的倒序数组\n\n\n我的结果不是倒序 还是原来的数组里的数字\n哪位大佬帮我看看怎么改", "Tag": "算法分析"}
{"Answer": "参考GPT和自己的思路：我们看一下你的问题：\n**1<<get(i,j)是什么意思？**\n这个是位运算，<<是位左移运算符，比如1<<3，是将1的二进制位置左侧插入3个0，即$0_2=00_2,1_2=01_2,2_2=10_2,0_2=1000_2$ ，也就是将1的二进制位向左挪动了3个记号的位置，这个例子相当于计算2的立方。所以这句话中，1<<get(i,j)表示将1的二进制数向左移动get(i,j)位所得的数。另外get(i,j)函数表示，将4*4矩阵看作了一个一维的16个数的序列，并给每个数一个编号，编号规则为先列后行（列是第一位，从0开始），即(0,0)的编号为0，(0,1)的编号为1，直到(3,3)的编号为15。所以get(i,j)就取得了一个坐标对应的编号。\nk>>i&1是什么意思？\n这句话中，>>是右移位运算符,即将一个数向右移动几位，比如3>>1，则结果是1，即从个位往右第一个数变为了1，由于题目中，状态是用一个整型变量state存储的，即用整型表示了状态，所以这里可以用位运算进行计算。如k取二进制1111表示4*4矩阵都打开，当i=2时，则k>>i&1就表示k向右移动两位，即从k的号位开始（前面用了0补位），第一位向右移动到了二进制的个位上，这个时候，&1就表示和1取与运算，即相当于后一位取反，前面全部变成了零，这个时候就得到，3.", "Konwledge_Point": "算法与数字", "Question": "关于#算法#的问题，请各位专家解答！\n飞行员兄弟\n“飞行员兄弟”这个游戏，需要玩家顺利的打开一个拥有 16\n 个把手的冰箱。\n\n\n已知每个把手可以处于以下两种状态之一：打开或关闭。\n\n\n只有当所有把手都打开时，冰箱才会打开。\n\n\n把手可以表示为一个 4×4\n 的矩阵，您可以改变任何一个位置 [i,j]\n 上把手的状态。\n\n\n但是，这也会使得第 i\n 行和第 j\n 列上的所有把手的状态也随着改变。\n\n\n请你求出打开冰箱所需的切换把手的次数最小值是多少。\n\n\n输入格式\n\n\n输入一共包含四行，每行包含四个把手的初始状态。\n\n\n符号 + 表示把手处于闭合状态，而符号 - 表示把手处于打开状态。\n\n\n至少一个手柄的初始状态是关闭的。\n\n\n输出格式\n\n\n第一行输出一个整数 N\n，表示所需的最小切换把手次数。\n\n\n接下来 N\n 行描述切换顺序，每行输出两个整数，代表被切换状态的把手的行号和列号，数字之间用空格隔开。\n\n\n注意：如果存在多种打开冰箱的方式，则按照优先级整体从上到下，同行从左到右打开。\n\n\n数据范围\n\n\n1≤i,j≤4\n\n\n输入样例：\n\n\n-+--\n\n\n\n\n-+--\n输出样例：\n\n\n6\n1 1\n1 3\n1 4\n4 1\n4 3\n4 4\n难度： 简单\n时/空限制： 1s / 64MB\n\n\n\n```c++\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\nusing\n \nnamespace\n std;\n\ntypedef\n pair<\nint\n,\nint\n>  PII;\n\nint\n change[\n4\n][\n4\n];\n\nint\n \nget\n(\nint\n x,\nint\n y)\n\n\n{\n    \nreturn\n x*\n4\n+y;\n}\n\nint\n \nmain\n()\n\n\n{\n    \nint\n state=\n0\n;\n    \nfor\n(\nint\n i=\n0\n;i<\n4\n;i++)\n    {\n        string line;\n        cin>>line;\n        \nfor\n(\nint\n j=\n0\n;j<\n4\n;j++)\n            \nif\n(line[j]==\n'+'\n)\n                state+=\n1\n<<\nget\n(i,j);\n//**1<res;\n    \nfor\n(\nint\n k=\n0\n;k<\n1\n<<\n16\n;k++)\n    {\n        \nint\n now=state;\n        vectorpath;\n        \nfor\n(\nint\n i=\n0\n;i<\n16\n;i++)\n            \nif\n(k>>i&\n1\n)\n//k>>i&1是什么意思？\n\n            {\n                \nint\n x=i/\n4\n,y=i%\n4\n;\n                now^=change[x][y];\n                path.\npush_back\n({x,y});\n            }\n        \nif\n(!now&&(res.\nempty\n()||res.\nsize\n()>path.\nsize\n()))res=path;\n    }\n    cout<<res.\nsize\n()<<endl;\n    \nfor\n(\nauto\n p:res) cout<<p.first+\n1\n<<\n' '\n<<p.second+\n1\n<<endl;\n//p:res中：的作用是什么？\n\n    \nreturn\n \n0\n;\n}\n\n\n\n\n\n```", "Tag": "算法分析"}
{"Answer": "先按主键排序，相同则按次主键\ntypedef struct _PUKE\n{\n  int huase;\n  int p;\n}PUKE;\ntypedef void (*f)(PUKE *p,int n);\nvoid sort(PUKE *p,int n)\n{\n  int i,j;\n  PUKE t;\n  for(i=0;i<n;i++)\n    for(j=0;j<n-i-1;j++)\n    {\n      if(p[j].huase < p[j+1].huase)  || ((p[j].huase == p[j+1].huase) && (p[j].p < p[j+1].p)))\n      {\n        t = p[j];\n        p[j] = p[j+1];\n        p[j+1] = t;\n      }\n    }\n}\nint main()\n{\n  PUKE puke[100];\n  int n,i,j;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)\n    scanf(\"%d %d\",&puke[i].huase,&puke[i].p);//花色输入1,2,3,4表示黑、方、梅、杏即可\n  f fun = sort;\n  fun(puke,n);\n}\n", "Konwledge_Point": "算法与数字", "Question": "怎样设计一个先花色后数字的排序\n.设计算法并编写程序，将下列扑克牌按照先花色后点数的规则进行降序排列（要求使用\n函数指针）。\n花色桃方梅杏梅杏桃方桃\n点数K381024710J\n桃桃杏方梅桃杏梅方梅\n589426QKAQ", "Tag": "算法分析"}
{"Answer": "你输入数字10,就会打印10行语句,第一行语句打印了一个元素,第二行语句打印了两个元素,第三行语句打印了三个数字,因此可以发现每次需要打印当前行次数,而外层for循环中i变量代表当前行,因此只需要在内层for循环写个条件,使得循环i次,而内存for循环从0开始,因此j<i+1或者j<=i", "Konwledge_Point": "算法与数字", "Question": "c语言。打印数字金字塔。\nc语言。打印数字金字塔。\nfor循环中为什么是j < i+1 呢？以及如何判断这里的控制变量到底是与n有关还是与循环变量i有关呢？ 需要详细的解答\n\n\n\n\n#\ninclude\n\n\n\nvoid\n \npinrtTriangle\n(\nint\n n)\n\n\n{\n    \nint\n num = \n1\n;            \n//输入的内容\n\n    \nfor\n(\nint\n i = \n0\n;i < n;i++)\n    {\n        \nfor\n(\nint\n j = \n0\n;j < i+\n1\n;j++)      \n//为什么是j < i+1 呢？以及如何判断这里的控制变量到底是与n有关还是与循环变量i有关呢？ 需要详细的解答\n\n            \nprintf\n(\n\"%d\"\n,num++);\n        \nprintf\n(\n\"\\n\"\n);\n    }\n}\n\n\nint\n \nmain\n()\n\n\n{\n    \nint\n n;\n    \nscanf\n(\n\"%d\"\n,&n);\n    \npinrtTriangle\n(n);\n    \nreturn\n \n0\n;\n}\n", "Tag": "算法分析"}
{"Answer": "＃＃＃复制一段给你吧 \r\n1. 信息加密\r\n　　收信者是唯一能够解开加密信息的人，因此收信者手里的必须是私钥。发信者手里的是公钥，其它人知道公钥没有关系，因为其它人发来的信息对收信者没有意义。\r\n2. 登录认证\r\n客户端需要将认证标识传送给服务器，此认证标识（可能是一个随机数）其它客户端可以知道，因此需要用私钥加密，客户端保存的是私钥。服务器端保存的是公钥，其它服务器知道公钥没有关系，因为客户端不需要登录其它服务器。\r\n3. 数字签名\r\n　　数字签名是为了表明信息没有受到伪造，确实是信息拥有者发出来的，附在信息原文的后面。就像手写的签名一样，具有不可抵赖性和简洁性。\r\n　　简洁性：对信息原文做hash，得到digest。信息越短加密的耗时越少。\r\n　　不可抵赖性：信息拥有者要保证签名的唯一性，必须是唯一能够加密digest的人，因此必须用私钥加密(就像字迹他人无法学会一样)，得到签名。如果用公钥，那每个人都可以伪造签名了。\r\n4.数字证书\r\n　　问题起源：对1和3，发信者怎么知道从网上获取的公钥就是真的？没有遭受中间人攻击？\r\n　　这样就需要第三方机构来保证公钥的合法性，这个第三方机构就是CA（Certificate Authority），证书中心。\r\n　　CA用自己的私钥对信息原文所有者发布的公钥和相关信息进行加密，得出的内容就是数字证书。\r\n　　信息原文的所有者以后发布信息时，除了带上自己的签名，还带上数字证书，就可以保证信息不被篡改了。信息的接收者先用CA给的公钥解出信息所有者的公钥，这样可以保证信息所有者的公钥是真正的公钥，然后就能通过该公钥证明数字签名是否真实了。", "Konwledge_Point": "算法与数字", "Question": "RSA 公私匙 数字签名 \nRSA中通过KeyPair来生成公私匙\n\n\n\n KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(\"RSA\");\n       keyPairGen.initialize(1024);\n       KeyPair keyPair = keyPairGen.generateKeyPair();\n       RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();\n       RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();\n\n\n\n\n\n\n在做数字签名或者加解密时，为什么不直接使用上门的公私匙 而是要对公私匙做转化\n\n\n\n比如公匙\n\n  X509EncodedKeySpec keySpec = new X509EncodedKeySpec(publicKey.getEncoded());\n\n  KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);\n\n  PublicKey publicK = keyFactory.generatePublic(keySpec);\n\n\n\n比如私匙\nPKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(privateKey.getEncoded());\nKeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);\nPrivateKey privateK = keyFactory.generatePrivate(pkcs8KeySpec);\n\n目前网上的帖子基本都是用转化后的公私匙\n但自己在方法里试了下 在签名 验签方法里如果直接使用 不转化的 也是可以做数字签名的，那这几步转化的意义何在，求达人告知下 ，谢谢！\n", "Tag": "算法分析"}
{"Answer": "如下，全局变量是不行的，在函数里面是可以的，并且变长的数组不能初始化\nint len;\nint arr[len]; 全局变量好像是不行的\nint main()\n{\n    int i=0;\n    int arr_1[i]; //函数内部是可以，i可以读取\n    scanf(\"%d\", &i);\n", "Konwledge_Point": "算法与数字", "Question": "怎么可以让输入的数组个数是任意输入的\n这个代码输入的数组元素的个数是固定的，怎么可以让输入的数组个数是任意输入的，我在主函数中输入COUNT的值，但提醒我\n在“int”左侧忽略，当未声明变量时。 \n\n\n#include\n<\nstdio.h\n>\n\n#define \nCOUNT\n \n6\n\nint a[\nCOUNT\n], count \n=\n \nCOUNT\n, k, m, b[\nCOUNT\n],t,c[\nCOUNT\n];\n\nvoid oarray(){  \n//输出原数组\n\n    printf(\n\"原数组:\"\n);\n    \nfor\n (k \n=\n \n0\n; k \n<\n \nCOUNT\n; k\n++\n)\n        printf(\n\"%5d\"\n, b[k]);\n    printf(\n\"\n\\n\n\"\n);\n}\n\n\n//求最大值\n\nvoid \nmax\n(){\n    int i\n=\n0\n, max\n=\n0\n;\n    max\n=\na[\n0\n];\n    \nfor\n(i\n=\n1\n;i\n<\nCOUNT\n;i\n++\n){\n        \nif\n(max\n<\na[i]){\n            max\n=\na[i];\n        }\n    }\n    printf(\n\"最大值:%d\n\\n\n\"\n,max);\n}\n\n\n//求最小值\n\nvoid \nmin\n(){\n    int j\n=\n0\n, min\n=\n0\n;\n    min\n=\na[\n0\n];\n    \nfor\n(j\n=\n1\n;j\n<\nCOUNT\n;j\n++\n){\n        \nif\n(min\n>\na[j]){\n            min\n=\na[j];\n        }\n    }\n    printf(\n\"最小值:%d\n\\n\n\"\n,min);\n\n}\nvoid sort(){  \n//排序算法\n\n    \nfor\n(k\n=\n0\n;k\n<\nCOUNT\n-\n1\n;k\n++\n)  \n//排序数组\n\n            \nfor\n(m\n=\nk\n+\n1\n;m\n<\nCOUNT\n;m\n++\n)\n                \nif\n (c[k] \n>\n c[m]) {\n                    t \n=\n c[k];\n                    c[k] \n=\n c[m];\n                    c[m] \n=\n t;\n                }\n        \nfor\n (k \n=\n \n0\n; k \n<\n \nCOUNT\n; k\n++\n)\n            a[k] \n=\n c[k];\n        printf(\n\"排序后数组为:\"\n);\n        \nfor\n (k \n=\n \n0\n; k \n<\n \nCOUNT\n; k\n++\n)\n        printf(\n\"%5d\"\n, c[k]);\n    printf(\n\"\n\\n\n\"\n);\n}\n\nvoid darray(){  \n//删除重复数组\n\n       \n/* int  count = COUNT;*/\n\n\n        \nfor\n(k\n=\n0\n;k\n<\nCOUNT\n-\n1\n;k\n++\n)  \n//排序数组\n\n            \nfor\n(m\n=\nk\n+\n1\n;m\n<\nCOUNT\n;m\n++\n)\n                \nif\n (c[k] \n>\n c[m]) {\n                    t \n=\n c[k];\n                    c[k] \n=\n c[m];\n                    c[m] \n=\n t;\n                }\n        \nfor\n (k \n=\n \n0\n; k \n<\n \nCOUNT\n; k\n++\n)\n            a[k] \n=\n c[k];\n    \n    \nfor\n (k \n=\n count \n-\n \n1\n; k \n>\n \n0\n; k\n--\n) \n//删除重复数组\n\n        \nif\n (a[k] \n==\n a[k \n-\n \n1\n]) {\n            \nfor\n (m \n=\n k \n-\n \n1\n; m \n<\n \nCOUNT\n \n-\n \n1\n; m\n++\n)\n                a[m] \n=\n a[m \n+\n \n1\n];\n            count\n--\n;\n        }\n            printf(\n\"删除重复后的数组:\"\n);\n    \nfor\n (k \n=\n \n0\n; k \n<\n count; k\n++\n)\n        printf(\n\"%5d\"\n, a[k]);\n    printf(\n\"\n\\n\n\"\n);\n\n\n}\n \nvoid choose(){  \n//选项\n\n    printf(\n\"\n\\n\n\"\n);\n    printf(\n\"选择选项:\n\\n\n\\n\n\"\n);\n    printf(\n\"1.输出原数组\n\\n\n\\n\n\"\n);\n    printf(\n\"2.输出排序后数组\n\\n\n\\n\n\"\n);\n    printf(\n\"3.输出删除重复后的数组\n\\n\n\\n\n\"\n);\n    printf(\n\"4.输出最大值\n\\n\n\\n\n\"\n);\n    printf(\n\"5.输出最小值\n\\n\n\\n\n\"\n);\n    printf(\n\"6.输出所有\n\\n\n\\n\n\"\n);\n    printf(\n\"7.退出\n\\n\n\\n\n\"\n);\n    printf(\n\"请输入选项   1  2  3  4  5  6  7\n\\n\n\"\n);\n    int x;\n    printf(\n\"\n\\n\n\\n\n\"\n);\n    \ndo\n{\n        scanf(\n\"%d\"\n,\n&\nx);\n        printf(\n\"\n\\n\n\"\n);\n        \nswitch\n(x){\n        \ncase\n \n1\n: oarray(); printf(\n\"\n\\n\n退出按7\n\\n\n\\n\n\"\n);    \nbreak\n;  \n        \ncase\n \n2\n: sort(); printf(\n\"\n\\n\n退出按7\n\\n\n\\n\n\"\n);      \nbreak\n; \n        \ncase\n \n3\n: darray(); printf(\n\"\n\\n\n退出按7\n\\n\n\\n\n\"\n);    \nbreak\n; \n        \ncase\n \n4\n: \nmax\n();    printf(\n\"\n\\n\n退出按7\n\\n\n\\n\n\"\n);      \nbreak\n; \n        \ncase\n \n5\n: \nmin\n();  printf(\n\"\n\\n\n退出按7\n\\n\n\\n\n\"\n);      \nbreak\n; \n        \ncase\n \n6\n: oarray();printf(\n\"\n\\n\n\"\n);sort();printf(\n\"\n\\n\n\"\n);darray();printf(\n\"\n\\n\n\"\n);\nmax\n();printf(\n\"\n\\n\n\"\n);\nmin\n();   printf(\n\"\n\\n\n退出按7\n\\n\n\\n\n\"\n);\nbreak\n; \n        \ncase\n \n7\n: printf(\n\"结束\n\\n\n\\n\n\"\n);    \nbreak\n;\n        \ndefault\n:\nbreak\n;\n        }\n    }\nwhile\n(x\n!=\n7\n);\n}\n\n\nvoid main(){\n    printf(\n\"Input %d data in order:\n\\n\n\"\n, \nCOUNT\n);\n    \nfor\n (k \n=\n \n0\n; k \n<\n \nCOUNT\n; k\n++\n) {  \n            printf(\n\"a[%d]=\"\n, k);\n            scanf(\n\"%d\"\n, \n&\na[k]);\n            b[k] \n=\n a[k], c[k] \n=\n a[k];\n    }\n    oarray();\n    choose();\n\n\n    \n//system(\"pause\");\n\n\n\n}\n\n", "Tag": "算法分析"}
{"Answer": "实体\r\n/**\r\n * Created by admin on 2018/6/20.\r\n */\r\npublic class NumEntity {\r\n    private Integer x;\r\n    private Integer y;\r\n    public Integer getX() {\r\n        return x;\r\n    }\r\n\r\n    public void setX(Integer x) {\r\n        this.x = x;\r\n    }\r\n\r\n    public Integer getY() {\r\n        return y;\r\n    }\r\n\r\n    public void setY(Integer y) {\r\n        this.y = y;\r\n    }\r\n\r\n    public NumEntity(Integer x, Integer y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n}\r\n\r\n```\r\n \r\n```\r\n\r\n主类\r\n\r\n/**\r\n * Created by admin on 2018/6/20.\r\n */\r\npublic class CsdnMain {\r\n\r\n    /**\r\n     * 主方法\r\n     * @param args\r\n     */\r\n    public static void main(String[] args) {\r\n        //传入数据为list的对象，为点结构\r\n        List list = new ArrayList<>();\r\n        list.add(new NumEntity(3,5));\r\n        list.add(new NumEntity(8,20));\r\n        list.add(new NumEntity(7,10));\r\n        //输出结果\r\n        System.out.println(checkCross(list));\r\n    }\r\n\r\n    /**\r\n     * 将传入的数据，小的在前，大的在后, 如果传入规则随机，则需要在list加入参数时做处理，如\r\n     * list.add(beforeDo(new NumEntity(5,3)));\r\n     * @param numEntity\r\n     * @return\r\n     */\r\n    static NumEntity beforeDo(NumEntity numEntity){\r\n        numEntity.setX(Math.min(numEntity.getX(),numEntity.getY()));\r\n        numEntity.setY(Math.max(numEntity.getX(),numEntity.getY()));\r\n        return numEntity;\r\n    }\r\n\r\n    /**\r\n     * 将传入的数据循环比较，设置temp为哨兵，如果最小值大于哨兵则将最大值赋于哨兵，再做下一次判断，如果最小值小于或者等于哨兵，则有交集\r\n     * @param list\r\n     * @return\r\n     */\r\n    static boolean checkCross(List list){\r\n        int temp = 0;\r\n        for(int i = 0;itemp){\r\n                temp = list.get(i).getY();\r\n            }else{\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n}", "Konwledge_Point": "算法与数字", "Question": "有几组数字，如果有交集返回false\n今天项目需要 有交集返回false 场景如下\n\n前端传几组数字 比如：\n\n3 5\n\n8  20\n\n7  10\n\n\n\n3 5 和8 20 不存在交集 \n\n但 8 20  和 7 10存在交集\n\n\n\n这三组数字返回false \n\n\n\n如果是这两组：\n\n3 5\n\n8  20\n\n\n\n就返回true了 \n\n\n\n请问java代码怎么实现呢", "Tag": "算法分析"}
{"Answer": "\n    // 把数组替换成List集合就可以\n    public int fiveSum(int[] nums) {\n        int n = nums.length;\n        int ans = 0, len = n <= 5 ? n : 5;\n        for (int i = 0; i < len; i++) {\n            ans += nums[i];\n        }\n        if(n <= 5) return ans;\n        int tmp = ans;\n        for(int i = 1; i < n; i++) {\n            if(i + 4 < n) {\n                tmp = tmp - nums[i - 1] + nums[i + 4];\n                ans = Math.max(ans, tmp);\n            }\n        }\n        return ans;\n    }\n", "Konwledge_Point": "算法与数字", "Question": "list的数字集合中有什么好的求和办法么？\n工具类或者是算法都可以。\n我想要求某个list中连续的五个数的最大值。\n我想要用求子串然后求和的方式，list有什么好的求和方法吗？\n不要流处理。", "Tag": "算法分析"}
{"Answer": "\n大二的话，这个电路可以理解吧，用这个就可以了", "Konwledge_Point": "算法与数字", "Question": "#数字电路#的设计问题\n本人大二，刚学完数字电路，想解决下面的问题，发现自己的知识面不够，想问问大家这种要怎么设计，或者建议用什么芯片。", "Tag": "算法分析"}
{"Answer": "不是输入x,输入的是a,b,c,d\nscanf(\"%d %d %d %d\",&a,&b,&c,&d);\n\nh函数没有返回值\nint h(int a,int b,int c,int d){\nx = a + b * 10 + c * 100 + d * 1000;\nreturn x;\n}\n", "Konwledge_Point": "算法与数字", "Question": "目标是输入四位数，然后单独输出个十百千上的每个数字\n刚开始学习c语言，但是感觉十分混乱，想写一个函数，于是模仿书上的函数，但是一直是错误的，想请大家帮我检查一下错误，或者改进一下算法。", "Tag": "算法分析"}
{"Answer": "#include <stdio.h>\n#include <stdlib.h>\ntypedef int ElemType;\ntypedef struct node \n{\n    ElemType data;\n    struct node* next;\n}SlinkNode;\n\n//1初始化链表\nSlinkNode* InitLink(SlinkNode* h)\n{\n    h = (SlinkNode*) malloc(sizeof(SlinkNode));\n    h->next = NULL;\n    return h;\n}\n\n//头插法\nSlinkNode* InsertHead(SlinkNode* h,ElemType e)\n{\n    SlinkNode *t;\n    t = (SlinkNode*)malloc(sizeof(SlinkNode));\n    t->data = e;\n    t->next = h->next;\n    h->next = t;\n    return h;\n}\n\n//显示链表\nvoid showList(SlinkNode* h)\n{\n    SlinkNode* p = h->next;\n    while (p)\n    {\n        printf(\"%d \",p->data);\n        p = p->next;\n    }\n    printf(\"\\n\");\n}\n\n\n//链表的长度\nint Length(SlinkNode* h)\n{\n    SlinkNode* p = h->next;\n    int len=0;\n    while(p)\n    {\n        len++;\n        p = p->next;\n    }\n    return len;\n}\n\n\n//在pos位置插入元素\nSlinkNode* InsertAt(SlinkNode* h,int pos,ElemType e)\n{\n    SlinkNode* p,*t;\n    if (pos <1 || pos > Length(h))\n    {\n        return 0;\n    }\n    t = (SlinkNode*)malloc(sizeof(SlinkNode));\n    t->data = e;\n    p = h;\n    while(--pos && p)\n    {\n        p = p->next;\n    }\n    if(p) \n    {\n        t->next = p->next;\n        p->next = t;    \n    }\n    return h;\n}\n\n//释放内存\nvoid FreeList(SlinkNode* h)\n{\n    SlinkNode* p;\n    while(h)\n    {\n        p = h->next;\n        free(h);h=0;\n        h = p;\n    }\n}\n\nint main()\n{\n    SlinkNode* h = 0;\n    int i;\n    int a[7]={32,28,45,67,14,18,29};\n    \n    //初始化单链表h\n    h = InitLink(h);\n    //头插法建表\n    for(i=6;i>=0;i--)\n    {\n        h = InsertHead(h,a[i]);\n    }\n    printf(\"插入前链表数据:\");\n    showList(h);\n\n    \n    //在67与14之间插入100(14的位置是5)\n    h = InsertAt(h,5,100);\n\n    //显示链表\n    printf(\"插入100后链表数据：\");\n    showList(h);\n\n    \n    //释放链表\n    FreeList(h);\n    return 0;\n\n}\n", "Konwledge_Point": "算法与数字", "Question": "数据结构，C语言，请求各位回答\n创建一个单链表，除头结点之外有7个有效结点，存放数字分别为：32、28、45、67、14、18、29，建表过程要求使用头插入法。要求：在67与14之间插入结点，插入结点存放数字为100，将插入前和插入后的各结点数字输出。\n   可能使用到的函数：①初始化单链表；②头插入法建表；③单链表插入算法；④单链表输出算法；⑤主函数。", "Tag": "算法分析"}
{"Answer": "\n#define _CRT_SECURE_NO_WARNINGS\n#include<stdio.h> \n#include<string.h> \n\n\nvoid swap(char* i, char* index)\n{\n    char temp[80];\n    strcpy(temp, i);\n    strcpy(i, index);\n    strcpy(index, temp);\n}\nvoid sort(char str[][80])\n{\n    //简单选择排序 \n    int i, j, index;\n\n    for (i = 0;i < 3;i++)\n    {\n        int index = i;\n        for (j = i + 1;j < 3;j++)\n        {\n            if (strcmp(str[i], str[j]) > 0)\n                index = j;\n        }\n        if (i != index)\n            swap(str[i], str[index]);\n    }\n\n}\nint main()\n{\n    char str[3][80];\n    int i, j;\n    for (i = 0;i < 2;i++)\n    {\n        printf(\"输入字符串:\");\n        scanf(\"%s\", str[i]);\n    }\n    sort(str);\n    for (i = 0;i < 3;i++)\n        printf(\"%s\", str[i]);\n    return 0;\n}\n\n", "Konwledge_Point": "算法与数字", "Question": "c语言字符串排序问题\n键盘输入三个字符串，编写嵌套函数，对三个字符串进行由小到大排序，并输出排序结果。请问有没有人能帮忙解答一下呢，下面是具体要求\n1）在主函数中获取键盘输入三个字符串到 str[3][80]中.\n2）将数组名作为参数传递给函数 1，函数 1 的功能是实现排序。\n3）在函数 1 中，进行串的两两比较时，将两个串名作为参数传递给函数 2，函数 2 的功能是比较大小，并将小串前置，如 str[0]与 str[1]比较后，str[0]为较小的串。\n 4）在主函数中按照顺序输出排序结果", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/iluckyning/article/details/8482692", "Konwledge_Point": "算法与数字", "Question": "双向链表排序，大神看看为啥数据老是丢失\n上代码\n\n\n\n #include \n#include\n#include\nusing namespace std;\n\ntypedef struct node\n{\n    int date;\n    struct node *next;\n    struct node *prior;\n}node;\n\nclass Link\n{\nprivate:\n    node *first;\n    node *last;\n    node *temp;\n    int len;\npublic:\n    void addLink();\n    void showLink();\n    void Swap(node *,node *);\n    void sort();\n    int getLen() const {\n        return len;\n    }\n\n    void setLen(int len) {\n        this->len = len;\n    }\n\n};\n\nvoid Link::addLink()\n{\n    srand((unsigned)time(NULL));\n    for(int i=1;i<=len;i++)\n    {\n        if(i==1)\n        {\n            node *newnode=new node;\n            newnode->date=rand()%101;\n            first=newnode;\n            temp=newnode;\n            first->prior=NULL;\n\n        }else if(i==len){\n            node *newnode=new node;\n            newnode->date=rand()%101;\n            last=newnode;\n            temp->next=last;\n            last->prior=temp;\n            temp=newnode;\n            temp->next=NULL;\n\n        }else\n        {\n            node *newnode=new node;\n            newnode->date=rand()%101;\n            temp->next=newnode;\n            newnode->prior=temp;\n            temp=newnode;\n        }\n    }\n\n\n}\n\nvoid Link::showLink()\n{\n    node *temp=new node;\n    temp=first;\n    while(temp!=NULL)\n    {\n        cout<date<<\"  \";\n        temp=temp->next;\n    }\n    cout<date<<\"  \";\n        temp=temp->prior;\n    }*/\n\n}\n\n\n\n\n\n上面的是双向链表的建立和打印，代码没错\n\n\n\n下面的是选择排序算法，应该也没错\n\n\n\n void Link::sort()\n{\n    node *i,*j,*k;\n    //if(!first->next)\n    //return;\n\n    for(i=first;i->next!=NULL;i=k->next)\n    {\n        for(j=i->next,k=i;j!=NULL;j=j->next)\n            if(k->date>j->date)\n                k=j;\n        if(k!=i)\n            Swap(i,k);\n    }\n\n\n\n\n\n下面的是交换链表位置的代码，复制的某位大神（原谅我忘记了他的名字）的代码，由于他的代码中没有对头结点的换位方法，我就自己写了加上去，结果每次运行都会丢失比头结点小的数据\n\n\n\n void Link::Swap(node *p,node *t)\n{\n    node *temp;\n    if(t->next==NULL&&p->prior!=NULL) //t结点是否为尾结点\n    {\n        if(p->next==t) //p,t结点是否相邻\n        {\n            //与尾结点相邻的交换代\n            t->next=p;\n            t->prior=p->prior;\n            p->next=NULL;\n            p->prior->next=t;\n           p->prior=t;\n        }\n       else\n        {\n            //与尾结点不相邻的交换代\n            t->next=p->next;\n            t->prior->next=p;\n            temp=t->prior;\n            t->prior=p->prior;\n            p->next->prior=t;\n            p->next=NULL;\n            p->prior->next=t;\n            p->prior=temp;\n        }\n    }\n    else if(p->prior==NULL&&t->next!=NULL)\n    {\n        if(p->next==t)\n        {\n            p->next=t->next;\n            p->next->prior=p;\n            p->prior=t;\n            t->next=p;\n            t->prior=NULL;\n        }\n        else\n        {\n            temp=p->next;\n            p->next=t->next;\n            t->next->prior=p;\n            p->prior=t->prior;\n            t->prior->next=p;\n            t->next=temp;\n            temp->prior=t;\n            t->prior=NULL;\n        }\n    }\n    else if(p->prior==NULL&&t->next==NULL)\n    {\n        p->next->prior=t;\n        t->next=p->next;\n        p->next=NULL;\n        t->prior->next=p;\n        p->prior=t->prior;\n        t->prior=NULL;\n    }\n    else{\n        if(p->next==t) //p,t结点是否相邻\n        {\n            //相邻的交换代\n            t->next->prior=p;\n            temp=t->next;\n            t->next=p;\n            t->prior=p->prior;\n            p->next=temp;\n            p->prior->next=t;\n            p->prior=t;\n        }\n        else\n        {\n            //不相邻的交换代\n            t->next->prior=p;\n            temp=t->next;\n            t->next=p->next;\n            p->next->prior=t;\n            p->next=temp;\n            t->prior->next=p;\n            temp=t->prior;\n            t->prior=p->prior;\n            p->prior->next=t;\n            p->prior=temp;\n       }\n    }\n\n\n}\n\n\n\n\n\n大神们来帮个忙吧，找错误找的眼睛都出血丝了。。。", "Tag": "算法分析"}
{"Answer": "", "Konwledge_Point": "算法与数字", "Question": "要拿出来的数组不是数字，而是类似于一段字符串，想知道怎么转换为数字\n问题遇到的现象和发生背景\n\n\n验证二分法是真的正确，所以用暴力遍历和二分法同时处理数组，查看二分法是否编写正确\n\n\n问题相关代码，请勿粘贴截图\n\n\npackage cn.Text;\n\n\nimport java.util.Arrays;\n\n\n/**\n\n\n二分法\n\n\n一次找一半，比较找位置/数字（num）   保证有序\n\n\n注：我们中点位置一般去上中点\n\n\n135679      上中点为5\n\n\n/\npublic class Dichotomy {\n  //TODO 二分法查找\n  public static boolean find(int[] arr,int num){\n\n\n  \n//边界条件\n\n  \nif\n((arr==\nnull\n)||(arr.length==\n0\n)){\n      \nreturn\n \nfalse\n;\n  }\n  \n//左边界\n\n  \nint\n L=\n0\n;\n  \n//有边界\n\n  \nint\n R=arr.length\n-1\n;\n  \n/\n**\n   \n* arr的[L...........R]之间查找一个数num\n   *\n/\n\n  \nwhile\n(L<=R){\n      \nint\n media=(L+R)/\n2\n;\n      \nif\n(arr[media]==\nnum\n){\n          \nreturn\n \ntrue\n;\n      }\n      \nelse\n \nif\n(arr[media]<\nnum\n){\n          L=media+\n1\n;\n      }\n      \nelse\n{\n          R=media\n-1\n;\n      }\n  }\n  \nreturn\n \nfalse\n;\n\n\n\n  }\n\n\n  //TODO 遍历，暴力方法解决\n  public static boolean test(int[] sortedArr, int num) {\n\n\n  \nfor\n (\nint\n cur : sortedArr) {\n      \nif\n (cur == \nnum\n) {\n          \nreturn\n \ntrue\n;\n      }\n  }\n  \nreturn\n \nfalse\n;\n\n\n\n  }\n\n\n  public static int[] generateRandomArray(int maxSize, int maxValue) {\n\n\n  \nint\n[] arr = \nnew\n \nint\n[(\nint\n) ((maxSize + \n1\n) * Math.random())];\n  \nfor\n (\nint\n i = \n0\n; i < arr.length; i++) {\n      arr[i] = (\nint\n) ((\nmaxValue\n + \n1\n) * Math.random()) - (\nint\n) (\nmaxValue\n * Math.random());\n  }\n  return arr;\n\n\n\n  }\n\n\n  public static void main(String[] args) {\n\n\n  \nint\n testTime = \n500000\n;\n  \nint\n maxSize = \n10\n;\n  \nint\n maxValue = \n100\n;\n  boolean succeed = \ntrue\n;\n  \nfor\n (\nint\n i = \n0\n; i < testTime; i++) {\n      \nint\n[]\n arr = generate\nRandomArray(\nmaxSize\n, \nmaxValue\n)\n;\n      \nSystem\n.\nout.println(arr);\n      \nArrays\n.\nsort(arr);\n      \nint\n value = (\nint\n) ((maxValue + \n1\n)\n * \nMath\n.\nrandom\n()\n) - (\nint\n) (maxValue\n * \nMath\n.\nrandom\n()\n);\n      \nif\n (test(arr, value) != find(arr, value)) {\n          \nSystem\n.\nout.println(\n\"出错了！\"\n);\n          succeed = \nfalse\n;\n          break;\n      }\n  }\n  \nSystem\n.\nout.println(succeed ? \n\"Nice!\"\n : \n\"Fucking fucked!\"\n);\n\n\n\n  }\n}\n\n\n\n\n运行结果及报错内容\n\n\n运行正确，就是不知道怎么转换为数字\n\n\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果\n\n\n两个一样的，说明二分法正确，我想知道数组怎么打印出", "Tag": "算法分析"}
{"Answer": "好像也没说每个字母代表的数字不同?", "Konwledge_Point": "算法与数字", "Question": "不知道怎么用c语言实现每个数字不一样\n就是不知道怎么设置那个每个数字不一样\n#include\nint main()\n{\n    int d,o,n,a,l,b,e,r,t,g,y=0;\n    int z;\n    int p[10];\n    for(z=0;z<10;z++)\n    p[z]=z;\n    d=5;\nfor(z=0;z<10;z++)\n    for(o=p[z];o<=p[9];)\n        for(n=p[z];n<=p[9];)\n            for(a=p[z];a<=p[9];)\n                for(l=0;l<10;l++)\n                    for(b=0;b<10;b++)\n                        for(e=0;e<10;e++)\n                            for(r=0;r<10;r++)\n                                for(t=0;t<10;t++)\n                                    for(g=0;g<10;g++)\n                                    {\n\n\n                                \nif\n((d\n*100000\n+o\n*10000\n+n\n*1000\n+a\n*100\n+l\n*10\n+d+g\n*100000\n+e\n*10000\n+r\n*1000\n+a\n*100\n+l\n*10\n+d)==(r\n*100000\n+o\n*10000\n+b\n*1000\n+e\n*100\n+r\n*10\n+t))\n                                {\n                                    \n                                    printf(\n\"d=%d\\to=%d\\tn=%d\\ta=%d\\tl=%d\\tg=%d\\te=%d\\tr=%d\\tt=%d\\tb=%d\\n\"\n,d,o,n,a,l,g,e,r,t,b);\n                                    y++;\n                                }\n                                }\nprintf(\n\"总共有多少种正确的算法:%d\"\n,y);\nreturn 0; \n\n\n\n }\n修改一下谢谢了                               ", "Tag": "算法分析"}
{"Answer": "    public static void main(String[] args) {\n        int n = 6;\n        Scanner sc = new Scanner(System.in);\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = sc.nextInt();\n        }\n        Arrays.sort(arr);\n        System.out.println(Arrays.toString(arr));\n    }\n", "Konwledge_Point": "算法与数字", "Question": "键盘输入6个整数，将这6个整数按从小到大的顺序排序。\njava 在键盘输入6个整数，将这6个整数按从小到大的顺序排序。", "Tag": "算法分析"}
{"Answer": "def main(numbers):\n    new = sorted(i for i in numbers if i > 0)\n    result = []\n    n = len(new)\n    start = new[0]\n    for i in range(n):\n        if i == n-1 or new[i+1]-new[i] > 1:\n            if new[i] == start:\n                result.append(str(start))\n            else:\n                result.append(str(start)+'-'+str(new[i]))\n            if i < n-1: start = new[i+1]\n    return \",\".join(result)\n\nnums = [5,6,7,8,9,14,13,12,11,23,29,30,39]\nprint(main(nums))\n", "Konwledge_Point": "算法与数字", "Question": "Python排序数字返回紧凑形式的字符串\nPython#389\n函数main（）接收一个包含若干自然数的列表，要求对其中的自然数升序排序，然后返回紧凑形式的字符串。\n例如，main（[5，6,7,8,9,14,13,12,11,23,29,30,39]）返回'5-9,11-14,23,29-30,39'，\n也就是把连续的自然数组合到一起使用减号连接，单个不连续的自然数独立显示，每组之间使用半角逗号分隔。\n考点：选择结构与循环结构，排序\n我咋感觉要用到排序算法啊……\n排序的话有一个sorted()函数排序，但是这个是对字典用的.\n\n\ndef main(numbers):\n\n    #return numbers\n\n\n    ans=[]\n\n\n    list.sort(numbers)\n\n\n    for i in numbers:\n\n\n        if numbers[i+1]-numbers[i]==1:\n\n\n            ans.append(i)\n\n\n            return min(ans)+'-'+max(ans)\n\n\n        else:\n\n\n            return i\n\n'''\n答题错误！您的代码执行结果为：\nTraceback (most recent call last):\n\n  File xxx.py, line 13, in \n\n\n    print(main([5, 6, 7, 8, 9, 14, 13, 12, 11, 23, 29, 30, 39]))\n\n\n  File xxx.py, line 8, in main\n\n\n    return min(ans)+'-'+max(ans)\n\nTypeError: unsupported operand type(s) for +: \n'int'\n and \n'str'\n\n'''\n", "Tag": "算法分析"}
{"Answer": "一共1528个\nhttps://www.aliyundrive.com/s/m1giuANCszH", "Konwledge_Point": "算法与数字", "Question": "用1234这四个数字组合成8位数\n用1234这四个数字组合成8位数，里面只有1到2个数的组合有多少组，比如11111111这是1个数的组合，11111112，11111113，11111114这是2个数的组合，需要把只有1到2个数的组合统计然后列出来。", "Tag": "算法分析"}
{"Answer": "long long换成double类型试试", "Konwledge_Point": "算法与数字", "Question": "c语言long long类型数据溢出\n#纯新手，在解决计算任意输入的在10的九次方的范围内的数通过冰雹猜想的操作方式（冰雹猜想 是指：一个自然数x，如果是奇数就乘以3再加1，如果是偶数就析出偶数因数2ⁿ，这样经过若干个次数，最终回到1。）变成1所需的操作次数这一问题时，用long long类型进行运算。\n虽然对987654321得到了和书中答案一样的操作数量180，但在检查运算过程中间值时，发现其中有一些数值为负。这个问题整体计算过程中不应该出现负值，所以我推测是数据溢出。但不太能理解原理是什么，毕竟理论上来讲long long类型的范围在10的18次方左右，而我手算负数出现的时候所在的步数的计算结果实际不超过100亿，不应该溢出。而且我是通过类似于冒泡算法的方式输出了计算中间值的最大值，但这个最大值又输出成一个负值，负数又是怎么在比较大小中比过正数的？\n\n\n其次我使用的是devc++ 5.1.1，据说它应该不支持C99的内容，但我又可以顺利使用long long类型。这是为什么？在之后我又按照网上的方法尝试了一下在编译选项中添加“-std＝c99”，以上问题也没有得到解决。\n\n\n相关代码如下：\n#include \n/\nint main ()\n{\n    long long i=1,o,p,d;\n    int a,b=1;\n    for(;i!=987654321;i++)\n    {\n        o=i;\n        for(a=0;o!=1;a++)\n        {\n            if(o>d)\n            {\n                d=o;\n            }\n            if(o%2==0)\n            {\n                o=o/2;\n            }\n            else\n            {\n                o=3\no+1;\n            }\n        }\n        if(a>b)\n        {\n            b=a;\n            p=i;\n        }\n    }\n    printf(\"  %d %d %d  \",p,b,d);\n}\n/\nint main()\n{\n    int n2,count=0;\n    scanf(\"%d\",&n2);\n    long long n=n2,k=1;\n    while(n>1)\n    {\n        if(n%2==1)n=n\n3+1;\n        else n/=2;\n        count++;\n        if(n>k)\n        {\n            k=n;\n            printf(\"%d %d   \",k,count);\n        }\n    }\n    printf(\"%d\\n\",count);\n    return 0;\n}", "Tag": "算法分析"}
{"Answer": "c++不允许cin >>n, int a[n]的方式定义数组", "Konwledge_Point": "算法与数字", "Question": "为什么这段编译运行之后，输入大一点的数就一直没有输出\n要实现从N个数中抽出第k个最大的数\n用了二分查找的思想\n输入形式是N，k，a[]分别输入，输出是一个数（第k大的数）\n在输入\n5\n3\n5 4 3 2 1\n这种小一点的数就能运行\n输入\n5\n3\n12345\n5433\n5678\n4352\n345\n这种大一点的数就一直卡在输入结束的页面也不输出的了\n为什么啊求解答！\n\n\n#include \nusing namespace std;\n\n\nint\n topk(\nint\n a[], \nint\n \nN\n, \nint\n k) {\n    \nint\n \nmin\n = a[\n1\n], \nmax\n = a[\n1\n];\n    \nint\n \nmid\n = \n0\n, \ncount\n = \n0\n;\n    for (\nint\n i = \n2\n; i <= \nN\n; i++) {\n        \nif\n (a[i] < \nmin\n)\n            \nmin\n = a[i];\n        \nif\n (a[i] > \nmax\n)\n            \nmax\n = a[i];\n    }\n    while (\nmax\n > \nmin\n) {\n        \nmid\n = (\nmin\n + \nmax\n) / \n2\n;\n        for (\nint\n i = \n1\n; i <= \nN\n; i++) {\n            \nif\n (a[i] >= \nmid\n)\n                \ncount\n++;\n        }\n        \nif\n (\ncount\n < k) {\n            \nmax\n = \nmid\n - \n1\n;\n            \ncount\n = \n0\n;\n        } else {\n            \nmin\n = \nmid\n;\n            \ncount\n = \n0\n;\n        }\n    }\n    cout << \nmin\n;\n}\n\n\nint\n main() {\n    \nint\n \nN\n, k;\n    cin >> \nN\n >> k;\n    \nif\n (k < \n1\n || k > \nN\n)\n        return \n0\n;\n    \nint\n a[\nN\n + \n10\n];\n    for (\nint\n i = \n1\n; i <= \nN\n; i++)\n        cin >> a[i];\n    topk(a, \nN\n, k);\n    return \n0\n;\n}\n", "Tag": "算法分析"}
{"Answer": "BigInteger又不是基本类型，怎么直接乘", "Konwledge_Point": "算法与数字", "Question": "BigInteger类型的变量为什么只能用multiply来乘 不能直接乘数字吗\n BigInteger类型的变量为什么只能用multiply来乘 不能直接乘数字吗", "Tag": "算法分析"}
{"Answer": "这个可以吗，如果可以记得给个采纳呐\n#include<stdio.h>\n#define N 100\n \nint rmatrix[N][N]={0};\nint number1;//number的初始值 \nvoid RMATRIX(int n,int start, int number,int rmatrix[N][N]){//n为矩阵层数，start为矩阵开始层数，number为起始数字\n    int i;\n    if(n<1)return;\n//    printf(\"此时的n=%d,start = %d,number = %d\\n\",n,start,number);\n\n    if(n==1)\n    {\n        if(number1==number)\n        {\n            rmatrix[start][start]  = number;\n            return ;\n        }\n//        rmatrix[start][start] = number;\n        int t= start/2;\n//        printf(\"t = %d\\n\",t);\n        if(rmatrix[t][t] == 0)\n        {\n            rmatrix[t][t]  = number;\n        }\n        return;\n    }\n    else{\n        for(i=start;i<(n-1);i++){//A区(矩阵的第一列)\n            rmatrix[i][start]=number;\n            number++;\n        }\n        for(i=start;i<(n-1);i++){//B区(矩阵的最后一行)\n            rmatrix[n-1][i]=number;\n            number++;\n        }\n        for(i=(n-1);i>start;i--){//C区(矩阵最后一列)\n            rmatrix[i][n-1]=number;\n            number++;\n        }\n        for(i=(n-1);i>start;i--){\n            rmatrix[start][i]=number;\n            number++;\n        }\n        start++;\n        RMATRIX(n-1,start,number,rmatrix);\n    }\n}\n \nint main(){\n    int a,b;\n    int n,number;\n    int rmatrix[N][N];\n    printf(\"请输入矩阵阶数:\");\n    scanf(\"%d\",&n);\n    printf(\"请输入开始时的number:\");\n    scanf(\"%d\",&number);\n    number1 = number;\n    RMATRIX(n,0,number,rmatrix);\n    for(a=0;a<n;a++){\n        for(b=0;b<n;b++){\n            printf(\"%3d \",rmatrix[a][b]);\n        }\n        printf(\"\\n\");\n    }\n}\n \n\n\n", "Konwledge_Point": "算法与数字", "Question": "运行结果不显示任何数字\n想运行一个螺旋矩阵的程序，没有报错但是运行没有结果输出，感觉是传参的时候出了问题，有人能帮我看看吗？\n\n\n#\ninclude\n\n#define N \n100\n\n\n\nint\n rmatrix\n[N]\n[N]\n={\n0\n};\nvoid \nRMATRIX(\nint\n \nn\n,\nint\n \nstart\n, \nint\n \nnumber\n,\nint\n \nrmatrix\n[N][N])\n{\n//n为矩阵层数，start为矩阵开始层数，number为起始数字\n\n    \nint\n i;\n    \nif\n(n==\n1\n)\n        rmatrix\n[\nstart\n]\n[\nstart\n]\n=number;\n    \nelse\n{\n        \nfor\n(i=start;i<(n-\n1\n);i++){\n//A区(矩阵的第一列)\n\n            rmatrix\n[\ni\n]\n[\nstart\n]\n=number;\n            number++;\n        }\n        \nfor\n(i=start;i<(n-\n1\n);i++){\n//B区(矩阵的最后一行)\n\n            rmatrix\n[\nn\n-\n1\n]\n[\ni\n]\n=number;\n            number++;\n        }\n        \nfor\n(i=(n-\n1\n);i>start;i--){\n//C区(矩阵最后一列)\n\n            rmatrix\n[\ni\n]\n[\nn\n-\n1\n]\n=number;\n            number++;\n        }\n        \nfor\n(i=(n-\n1\n);i>start;i--){\n            rmatrix\n[\nstart\n]\n[\ni\n]\n=number;\n            number++;\n        }\n        start++;\n        \nRMATRIX(\nn\n-2,\nstart\n,\nnumber\n,\nrmatrix\n)\n;\n    }\n}\n\nvoid main\n()\n{\n    \nint\n a,b;\n    \nint\n n,number;\n    \nint\n rmatrix\n[N]\n[N]\n;\n    printf(\n\"请输入矩阵阶数:\"\n);\n    scanf(\n\"%d\"\n,&n);\n    printf(\n\"请输入开始时的number:\"\n);\n    scanf(\n\"%d\"\n,&number);\n    \nRMATRIX(\nn\n,0,\nnumber\n,\nrmatrix\n)\n;\n    \nfor\n(a=\n0\n;a<\n4\n;a++){\n        \nfor\n(b=\n0\n;b<\n4\n;b++){\n            printf(\n\"%d \"\n,rmatrix\n[\na\n]\n[\nb\n]\n);\n        }\n        printf(\n\"\\n\"\n);\n    }\n}\n\n", "Tag": "算法分析"}
{"Answer": "个人认为：首先要构成回文，是不是应该是一对称数组才行？如果是一个对称数组？就像例子一样。1234564321，length=10,如果是123454321，length=9,这个已经是回文了，所以\r\n长度是双数，我们可以将1234 56 4321中间的两个数（5,6）任意删去其一，就构成回文了。希望能够帮助你。", "Konwledge_Point": "算法与数字", "Question": "通过删改构成最长回文数问题\n给定一串数字，通过删除某些数字构成一个回文数，算法如何实现，最好使用java试实现。例 1234564321，删除5或者6，就构成了最长回文数。", "Tag": "算法分析"}
{"Answer": "\n#include <stdio.h>\n\n \n\nint main()\n\n{int a,n;\n\nint s=0;\n\nint t;\n\nscanf(\"%d%d\",&a,&n);\n\nt=a;\n\nif (n==1)\n\n{printf(\"%d\",t);\n\n}\n\nelse\n\nfor (int i=1;i<n;i++)\n\n{if (i==1)\n\n{printf(\" %d +\",a);\n\n}\n\na=a*10+t;\n\ns=s+a;\n\n if (i<n-1)\n\n{\nprintf(\" %d +\",a);}\n\nelse\n\n{printf(\" %d\",a);\n\n}\n\n}\n\ns=s+t;\n\nprintf(\" = %d\",s);\n\nreturn 0;\n\n}\n\n", "Konwledge_Point": "算法与数字", "Question": "原谅我老是不知道什么状况\n为什么我输入的数字只能得到0的结果，不知道我的算法还是哪里出了问题", "Tag": "算法分析"}
{"Answer": "兄弟你对这个题的理解有点偏你需要理解什么叫“1到N”的排列比如1到3的排列，就是1、2、3这三个数进行排列而你的结果是1、1、1、15，显然不是1到4的排列（需要由1、2、3、4进行排列）", "Konwledge_Point": "算法与数字", "Question": "字典序最小是什么意思？\n想问下字典序最小是啥意思？\n我求出的结果是，[1,1,1,15] 但它给出的结果却是 [1, 2, 4, 3]。[1,1,1,15] 与  [1, 2, 4, 3] 哪个字典序大些？\n会不会是答案有问题？\n附上我的代码\n\n\ndef dfs(nums,\nres\n):\n    \nif\n \nlen\n(\nres\n) == n:\n        result.\nappend\n(\nres\n)\n        \nreturn\n\n    \nfor\n i in \nrange\n(\n1\n,nums[\n0\n]//\n2\n+\n1\n):\n        temp = []\n        temp.\nappend\n(i)\n        flag = True \n        \nfor\n \nj\n in nums:\n            nextval = \nj\n - temp[-\n1\n]\n            \nif\n nextval <= \n0\n:\n                flag = False\n                \ncontinue\n\n            temp.\nappend\n(nextval)\n        \nif\n flag:\n            \nres\n = temp[:]\n            dfs(temp,\nres\n)\n        \nelse\n:\n            \nreturn\n False\n        \n\nn, s = \nmap\n(\nint\n,\ninput\n().\nsplit\n())\nresult = []\ndfs([s],[])\n\nfor\n i in sorted(result):\n    \nprint\n(i)\n", "Tag": "算法分析"}
{"Answer": "你错在把数组分成了两半去自找最值，然后再比较这两个值，如：5 9 1 3 4 | 2 6 10 12，分别找到9|12，明显最大不是这两个呢。", "Konwledge_Point": "算法与数字", "Question": "请问各位C语言求一组数据中最大的两个数和最小的两个数，我的代码错在哪，该怎么修改\n#\ninclude\n \n#\ninclude\n \n\nint\n get\n_max(\nint\n \nb\n[],\nint\n \np\n,\nint\n \nq\n)\n;\n\nint\n get\n_min(\nint\n \nb\n[],\nint\n \np\n,\nint\n \nq\n)\n;\n\nint\n main\n()\n\n{\n    \nint\n num,i,max1,max2,big_max,small_max,min1,min2,big_min,small_min;\n    scanf(\n\"%d\"\n,#);\n    \nint\n a\n[\nnum\n]\n;\n    \nfor\n(i=\n0\n;imax2)\n    {\n        big_max=max1;\n        small_max=max2;\n    }\n    \nelse\n\n    {\n        big_max=max2;\n        small_max=max1;\n    }\n    min1=get\n_min(\na\n[],0,\nnum\n/\n2-1)\n;\n    min2=get\n_min(\na\n[],\nnum\n/\n2,\nnum\n-1)\n;\n    \nif\n(min1max)\n            {\n                max=b\n[\nk\n]\n;\n            }\n        }\n    }\n    return max;\n}\n\nint\n get\n_min(\nint\n \nb\n[],\nint\n \np\n,\nint\n \nq\n)\n\n{\n    \nint\n k,min;\n    \nif\n(p<q)\n    {\n        min=b\n[\np\n]\n;\n        \nfor\n(k=p+\n1\n;k<=q;k++)\n        {\n            \nif\n(b\n[\nk\n]\n<min)\n            {\n                min=b\n[\nk\n]\n;\n            }\n        }\n    }\n    return min;\n}\n\n\n\n    \n/**********  End  **********/\n\n\n\n", "Tag": "算法分析"}
{"Answer": "\n#include <stdio.h>\nint  main()\n\n{\n    int i=0;\n\n    int n,j,a[16]; //n表示输入的十进制数\n\n    printf(\"请输入十进制数：\");\n\n    scanf(\"%d\",&n);\n\n    while(n>=10)\n\n    {\n        a[i]=n%10;\n\n        i++;\n\n        n=n/10;\n\n    }\n\n    a[i]=n;\n\n    for(j=i;j>=0;j--)\n        printf(\"%d \",a[j]);\n    printf(\"\\n\");\n}\n\n", "Konwledge_Point": "算法与数字", "Question": "99我，xdm!囚囚你们了\n1、设计一个递归算法，输出一个大于零的十进制数n的各数字位，如n=123，输出各数字位为123。\n2、递归设计简单选择排序和冒泡排序。", "Tag": "算法分析"}
{"Answer": "\n \n#include <stdio.h>\nint main()\n{\n    int x, count;\n    count = 1;\n    scanf(\"%d\", &x);\n    int n = x;\n    int i = 0;\n    int number[10] = {0};\n    while (x / 10 > 0)\n    {\n        number[i++] = x % 10;\n        x = x / 10;\n        if (x >= 0)\n        {\n            count++;\n        }\n    }\n    number[i++] = x % 10;\n    printf(\"%d\\n\", count);\n \n    for (i = count - 1; i >= 0; i--)\n    {\n        printf(\"%d\", number[i]);\n        if(i != 0)\n        {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n    for (i = 0; i < count; i++)\n    {\n        printf(\"%d\", number[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n", "Konwledge_Point": "算法与数字", "Question": "c语言对数字判断问题\n打了好久都没有思路，各位帮忙看看这个\nzjsjhshsudjsnwbe", "Tag": "算法分析"}
{"Answer": "```\r\n#include \r\n\r\nint isLeapYear(int year)\r\n{\r\n\tif (year % 100 == 0 && year % 400 != 0) return 0;\r\n\tif (year % 4 != 0) return 0;\r\n\treturn 1;\r\n}\r\nint main()\r\n{\r\n\tint y;\r\n\tscanf(\"%d\", &y);\r\n\tif (isLeapYear(y))\r\n\t\tprintf(\"%dÊÇÈòÄê!\", y);\r\n\telse\r\n\t\tprintf(\"%d²»ÊÇÈòÄê!\", y);\r\n}\r\n```\r\n\r\n![图片说明](https://img-ask.csdn.net/upload/201904/08/1554700431_328246.gif)", "Konwledge_Point": "算法与数字", "Question": "用C制作一个闰年判别程序\n使用C语言编写一个程序，在主函数中从用户处读取年份（整数）。在主函数中，有一个对函数的调用，该函数以参数形式接收年份。该函数确定给定年份是否为闰年。如果给定年份是闰年，则函数返回1（数字1）。否则，函数返回0（零）。\n\n\n\n确定闰年的算法如下：\n\n\n\n如果年份可以被数字400整除\n\n\n\n那一年就是闰年\n\n\n\n否则，如果年份可以被数字100整除\n\n\n\n那么年份不是闰年\n\n\n\n否则，如果年份可以被数字4整除\n\n\n\n那一年就是闰年\n\n\n\n否则，年份不是闰年。", "Tag": "算法分析"}
{"Answer": "", "Konwledge_Point": "算法与数字", "Question": "c语言表达猜数字问题\nshzjsjuxudjwhjsxuwjxiekhd看了没有什么思路，求解呀！", "Tag": "算法分析"}
{"Answer": "http://www.cnblogs.com/F-itachi/p/9974336.html", "Konwledge_Point": "算法与数字", "Question": "C语言输出格雷码的问题\n格雷码是以n位的二进制来表示数。\n\n与普通的二进制表示不同的是，它要求相邻两个数字只能有1个数位不同。\n\n首尾两个数字也要求只有1位之差。\n\n\n\n有很多算法来生成格雷码。以下是较常见的一种：\n\n从编码全0开始生成。\n\n当产生第奇数个数时，只把当前数字最末位改变（0变1，1变0）\n\n当产生第偶数个数时，先找到最右边的一个1，把它左边的数字改变。\n\n用这个规则产生的4位格雷码序列如下：\n\n0000\n\n0001\n\n0011\n\n0010\n\n0110\n\n0111\n\n0101\n\n0100\n\n1100\n\n1101\n\n1111\n\n1110\n\n1010\n\n1011\n\n1001\n\n1000", "Tag": "算法分析"}
{"Answer": "", "Konwledge_Point": "算法与数字", "Question": "螺旋矩阵最中间的数字无法输出\n运行一个关于螺旋矩阵的程序，但是当输入的矩阵阶数为奇数时，最中间的数字为0？这是为什么？\n\n\nimport\n java.util.Scanner;\n\n\npublic\n \nclass\n Main {\n    \npublic\n static \nvoid\n main(String[] args) {\n        \nint\n i,j;\n        \nint\n n,number;\n        \nSystem\n.\nout\n.print(\"请输入矩阵的阶数n:\");\n        Scanner s = \nnew\n Scanner(\nSystem\n.\nin\n);\n        n=s.nextInt();\n        \nint\n[][] matrix = \nnew\n \nint\n[n][n];\n        \nSystem\n.\nout\n.print(\"请输入矩阵初始的值number:\");\n        number=s.nextInt();\n        Rmatrix(n,\n0\n,number,matrix);\n        \nfor\n (i=\n0\n;i\nstart\n;i\n--){\n\n              m[i][n\n-1\n]=number;\n              number++;\n          }\n          \nfor\n(i=(n\n-1\n);i>\nstart\n;i\n--){\n\n              m[\nstart\n][i]=number;\n              number++;\n          }\n          \nstart\n++;\n          Rmatrix((n\n-1\n),\nstart\n,number,m);\n       }\n    }\n}\n![img](https://img-mid.csdnimg.cn/\nrelease\n/static/image/mid/ask/\n26193955456617.\npng \"#left\")\n\n\n", "Tag": "算法分析"}
{"Answer": "char A[] = \"\"; char B[] = \"\";char C[] = \"\";char D[] = \"\";char E[] = \"\";char F[] = \"\"; 字符串定义问题，改为：char A[4],B[4],C[4],D[4],E[4],F[4];修改如下，供参考：\n#include <stdio.h>\n#include <stdlib.h>\n//Ax+By=C\n//Dx+Ey=F\n//x=(CE-BF)/(AE-bD)\n//y=(CD-AF)/(BD-aE)\nint main(){\n    char A[4] = \"\"; //修改\n    char B[4] = \"\"; //修改\n    char C[4] = \"\"; //修改\n    char D[4] = \"\"; //修改\n    char E[4] = \"\"; //修改\n    char F[4] = \"\"; //修改\n    printf(\"请按照以下格式输入方程组 Ax+By=C;Dx+Ey=F\\n\");\n    char str[32] = \"\";\n    scanf(\"%s\",str);\n    printf(\"方程组为 %s\\n\", str);\n    sscanf(str,\"%[^x]\",A);\n    printf(\"%s\\n\", A);\n    sscanf(str,\"%*[^+]+%[^y]\",B);\n    printf(\"%s\\n\", B);\n    sscanf(str,\"%*[^=]=%[^;]\",C);\n    printf(\"%s\\n\", C);\n    sscanf(str,\"%*[^;];%[^x]\",D);\n    printf(\"%s\\n\", D);\n    sscanf(str,\"%*[^;]%*[^+]+%[^y]\",E);\n    printf(\"%s\\n\", E);\n    sscanf(str,\"%*[^;]%*[^=]=%s\",F);\n    printf(\"%s\\n\", F);\n    int num1, num2, num3, num4, num5, num6, x, y;\n    num1 = atoi(A);\n    num2 = atoi(B);\n    num3 = atoi(C);\n    num4 = atoi(D);\n    num5 = atoi(E);\n    num6 = atoi(F);\n    printf(\"%d\\n\",num1);\n    printf(\"%d\\n\",num2);\n    printf(\"%d\\n\",num3);\n    printf(\"%d\\n\",num4);\n    printf(\"%d\\n\",num5);\n    printf(\"%d\\n\",num6);\n    //x = (num1 * num5 -num2 * num6) / (num1 * num5 - num2 * num4);\n    //printf(\"%d,\",x);\n    //x=(CE-BF)/(AE-bD)\n    //y=(CD-AF)/(BD-aE)\n    return 0;\n}\n\n", "Konwledge_Point": "算法与数字", "Question": "C语言char类型字符串里的数字转换到int就变成0了，六个变了五个，看不出问题\nchar字符串里都是数字，想转换成int类型进行计算，结果转换出来就是一堆0。\n没有报错\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n//Ax+By=C\n\n\n//Dx+Ey=F\n\n\n//x=(CE-BF)/(AE-bD)\n\n\n//y=(CD-AF)/(BD-aE)\n\n\nint\n \nmain\n()\n{\n    \nchar\n A[] = \n\"\"\n;\n    \nchar\n B[] = \n\"\"\n;\n    \nchar\n C[] = \n\"\"\n;\n    \nchar\n D[] = \n\"\"\n;\n    \nchar\n E[] = \n\"\"\n;\n    \nchar\n F[] = \n\"\"\n;\n    \nprintf\n(\n\"请按照以下格式输入方程组 Ax+By=C;Dx+Ey=F\\n\"\n);\n    \nchar\n str[\n32\n] = \n\"\"\n;\n    \nscanf\n(\n\"%s\"\n,str);\n    \nprintf\n(\n\"方程组为 %s\\n\"\n, str);\n    \nsscanf\n(str,\n\"%[^x]\"\n,A);\n    \nprintf\n(\n\"%s\\n\"\n, A);\n    \nsscanf\n(str,\n\"%*[^+]+%[^y]\"\n,B);\n    \nprintf\n(\n\"%s\\n\"\n, B);\n    \nsscanf\n(str,\n\"%*[^=]=%[^;]\"\n,C);\n    \nprintf\n(\n\"%s\\n\"\n, C);\n    \nsscanf\n(str,\n\"%*[^;];%[^x]\"\n,D);\n    \nprintf\n(\n\"%s\\n\"\n, D);\n    \nsscanf\n(str,\n\"%*[^;]%*[^+]+%[^y]\"\n,E);\n    \nprintf\n(\n\"%s\\n\"\n, E);\n    \nsscanf\n(str,\n\"%*[^;]%*[^=]=%s\"\n,F);\n    \nprintf\n(\n\"%s\\n\"\n, F);\n    \nint\n num1, num2, num3, num4, num5, num6, x, y;\n    num1 = \natoi\n(A);\n    num2 = \natoi\n(B);\n    num3 = \natoi\n(C);\n    num4 = \natoi\n(D);\n    num5 = \natoi\n(E);\n    num6 = \natoi\n(F);\n    \nprintf\n(\n\"%d\\n\"\n,num1);\n    \nprintf\n(\n\"%d\\n\"\n,num2);\n    \nprintf\n(\n\"%d\\n\"\n,num3);\n    \nprintf\n(\n\"%d\\n\"\n,num4);\n    \nprintf\n(\n\"%d\\n\"\n,num5);\n    \nprintf\n(\n\"%d\\n\"\n,num6);\n    \n//x = (num1 * num5 -num2 * num6) / (num1 * num5 - num2 * num4);\n\n    \n//printf(\"%d,\",x);\n\n    \n//x=(CE-BF)/(AE-bD)\n\n    \n//y=(CD-AF)/(BD-aE)\n\n    \nreturn\n \n0\n;\n}\n\n\n\n\n\n\n尝试了这样写，结果成功了，但原算法出了什么问题呢\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\nint\n \nmain\n()\n\n\n{\n     \nchar\n b[\n18\n];\n     \nint\n num;\n     \nscanf\n(\n\"%s\"\n,b);\n//对char型数组进行赋值 如：123456789\n\n     num = \natoi\n(b);\n     \nprintf\n(\n\"%d\"\n,num);\n     \nint\n C = num + \n10\n;\n     \nprintf\n(\n\"%d\"\n,C);\n     \n     \n    \nreturn\n \n0\n;\n } \n\n\n\n\n其实就是提取数字计算，但系数为1的情况也没啥思路，是不是要用if，但怎么检测呢，刚学实在没啥见识", "Tag": "算法分析"}
{"Answer": "m函数的break有问题，返回的值会出现错误，建议这里的break变成return -1在主函数里面判断一下，如果返回值是-1，就continue\n望采纳！谢谢", "Konwledge_Point": "算法与数字", "Question": "在求200到300的素数的时候，为什么输出了除了素数以外的数字，函数到底除了什么问题？\n在求200到300的素数的时候，为什么输出了除了素数以外的数字，函数到底除了什么问题？", "Tag": "算法分析"}
{"Answer": "雷是随机布的。为了避免用户踩开来第一个就是雷，雷可以在用户翻开来之后再随机产生。事实上布雷的算法和洗牌算法是一样的。\r\n在一个m*n的雷区中，每个单元格可以给它一个编号，比如第x行第y列就是m*x+y。因此所有单元格被编号为0~m*n-1。你只需要打乱他们的顺序，然后取这个序列的前几个（比如10个），根据序号可以反推出坐标，将这些单元格视作雷就可以了。\r\n旁边的数字表示在其周围8个格子中有几个雷（需要对边缘判断下，这里省略不表），比如用户点的是a,b，那么就是判断a-1,b-1;a,b-1;a+1,b-1;...a+1,b+1这几个单元格是否有雷，将雷数显示出来。\r\n\r\n扫雷的程序有很多，你可以找个现成的学习下，google里面输入 site:download.csdn.net 扫雷 源代码，就可以找到。", "Konwledge_Point": "算法与数字", "Question": "扫雷布的问题，求大神解决\n扫雷里面的布雷以及雷旁边的数字怎么布呢？？？？具体思想，算法，或者代码都可以，求大神方法", "Tag": "算法分析"}
{"Answer": "cin>>s[i]改成getline(cin, s[i], '\\32')", "Konwledge_Point": "算法与数字", "Question": "怎样才能使矩阵每个数字间有一个空格\n请问这段代码如果想实现输入矩阵时每个数字间都有间隔该怎么改\n\n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n\n#\ndefine\n maxn 105\n\n\nusing\n \nnamespace\n std;\n\nstring s[maxn];\n\nlong\n \nlong\n a[maxn][maxn];\n\nlong\n \nlong\n p[maxn][maxn];\n\n\nint\n \nmain\n()\n\n\n{\n    \nlong\n \nlong\n n,m;\n    \nwhile\n(cin>>n>>m)\n    {\n    \nfor\n(\nint\n i=\n1\n;i<=n;i++)\n    {\n        cin>>s[i];\n        \nfor\n(\nint\n j=\n1\n;j<=m;j++)\n            a[i][j]=s[i][j\n-1\n]-\n'0'\n;    \n    }\n    \nfor\n(\nint\n i=\n1\n;i<=n;i++)\n        \nfor\n(\nint\n j=\n1\n;j<=m;j++)\n            p[i][j]=\nmax\n(p[i\n-1\n][j],p[i][j\n-1\n])+a[i][j];\n    cout<<p[n][m]<<endl;\n}\n}\n\n", "Tag": "算法分析"}
{"Answer": "索引错了望采纳，谢谢！\n    for (int i = 0; i < n - 1; i++)\n    {\n        for (int j = 0; j < n - i -1; j++)\n\n", "Konwledge_Point": "算法与数字", "Question": "c语言的起泡排序问题，出现了莫名的数字\n一个起泡排序的代码，问题是在排序的数列出现大于46的数字时，会变成46.\n\n\n#include\n\n\n/*\ntime:2022.04.25\nauthor:FZY\n*/\n \n\nvoid\n SelectSort(\nint\n r[],\nint\n n)\n{\n    \nint\n \nindex\n;\n    \nfor\n(\nint\n i=\n0\n;ir[j+\n1\n])\n            {\n                \nint\n \ntemp\n;\n                \ntemp\n=r[j];\n                r[j]=r[j+\n1\n];\n                r[j+\n1\n]=\ntemp\n;\n            }\n        }\n    }\n}\n\nint\n main()\n{\n    \nint\n r[] = {\n3\n,\n5\n,\n47\n,\n23\n,\n41\n,\n14\n,\n7\n,\n9\n,\n4\n};\n    \nint\n s[] = {\n2\n,\n5\n,\n3\n,\n9\n,\n24\n,\n47\n,\n43\n,\n21\n,\n4\n};\n    printf(\"选择排序：\\n\");\n    SelectSort(r,\n9\n);\n    \nfor\n(\nint\n i=\n0\n;i<\n9\n;i++)\n    {\n        printf(\"%d  \",r[i]);\n    }\n    printf(\"\\n起泡排序：\\n\");\n    BubbleSort(s,\n9\n);\n    \nfor\n(\nint\n i=\n0\n;i<\n9\n;i++)\n    {\n        printf(\"%d  \",s[i]);\n    } \n    \nreturn\n \n0\n;\n}\n\n\n\n排序数列里边莫名出现了46", "Tag": "算法分析"}
{"Answer": "int n;\nint a=1;\nint sum=0;\ncin>>n;\nfor(int i=1;i<=n;i++)\n{\na*=i;\nsum+=a;\n}\ncout<<sum;\n", "Konwledge_Point": "算法与数字", "Question": "给定输入n，求1!+2!+3!+.+n!。\n给定输入n，求1!+2!+3!+。+n!。在使用双重循环解决问题的前提下，可以尝试优化算法，使用单重循环解决该问题。\n【输入形式】\n\n\n一个数字n，不超过20\n【输出形式】【输出形式】\n\n\n一个数字，1!+2!+3!+.+n!的结果\n\n\n【样例输入】\n\n\n3\n【样例输出】\n\n\n9\n【样例说明】\n\n\n输入为3，即求1!+2!+3!=1+2+6=9", "Tag": "算法分析"}
{"Answer": "#include <stdio.h>\n#include <stdlib.h>\n#define N 10\nvoid main()\n{\n   while(1)\n  {\n   system(\"cls\");\n    int i, j, k, n=0, a[N][N];  /*定义二维数组a[10][10]*/\n    printf(\"请输入要打印的行数(输入<=0时结束）：\");\n    scanf(\"%d\",&n);\n    if(n<=0)\n      return;\n    if(n>10)\n    {\n      printf(\"行数不能大于10\\n\"):\n      continue;\n    }\n    printf(\"%d行杨辉三角如下：\\n\",n);\n    for(i=1;i<=n;i++)\n        a[i][1] = a[i][i] = 1;  /*两边的数令它为1，因为现在循环从1开始，就认为a[i][1]为第一个数*/\n    for(i=3;i<=n;i++)\n        for(j=2;j<=i-1;j++)\n            a[i][j]=a[i-1][j-1]+a[i-1][j];  /*除两边的数外都等于上两顶数之和*/ \n    for(i=1;i<=n;i++){\n        for(k=1;k<=n-i;k++)\n            printf(\"   \");  /*这一行主要是在输出数之前打上空格占位，让输出的数更美观*/\n        for(j=1;j<=i;j++)  /*j<=i的原因是不输出其它的数，只输出我们想要的数*/\n            printf(\"%5d\",a[i][j]);\n        \n        printf(\"\\n\");  /*当一行输出完以后换行继续下一行的输出*/\n    }\n    system(\"pause\");\n  }\n    printf(\"\\n\");\n}\n\n", "Konwledge_Point": "算法与数字", "Question": "杨辉三角问题C语言，今天\n杨辉，字谦光，汉族，钱塘（今浙江省杭州）人，南宋杰出的数学家。 他曾担任过南宋地方行政官员，为政清廉，足迹遍及苏杭一带。他在总结民间乘除捷算法、“垛积术”、纵横图（幻方）以及数学教育方面，均做出了重大的贡献。他是世界上第一个排出丰富的纵横图和讨论其构成规律的数学家。还曾论证过弧矢公式，时人称为“辉术”。与秦九韶、李冶、朱世杰并称“宋元数学四大家”。主要著有数学著作5种21卷，即《详解九章算法》12卷（1261），《日用算法》2卷（1262），《乘除通变本末》3卷（1274），《田亩比类乘除捷法》2卷（1275）和《续古摘奇算法》2卷（1275）（其中《详解》和《日用算法》已非完书）。后三种合称为《杨辉算法》。朝鲜、日本等国均有译本出版，流传世界。（来源于百度百科）\n\n\n杨辉在《详解九章算法》一书中还画了一张表示二项式展开后的系数构成的三角图形，称做“开方做法本源”，简称为“杨辉三角”。杨辉三角是一个由数字排列成的三角形数表。（来源于百度百科）\n\n\n输入一个整数n，输出n行的杨辉三角形。例如，n=5，则杨辉三角如输出样例所示。\n\n\n输入格式:\n输入数据有多组，每组1个整数n(1≤n≤10)，一直处理到文件结束。\n\n\n输出格式:\n对于每个n，输出n行杨辉三角形。每个数据的输出为5个字符宽度，具体见输出样例。", "Tag": "算法分析"}
{"Answer": "\n#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int a;\n    int res = 0;\n    int cnt = 1;\n    cin>>a;\n    int pre = a;\n    while(cin>>a,a)\n    {\n        if(a==pre) cnt++;\n        else cnt = 1;\n        res = max(res,cnt);\n        pre = a;\n    }\n    cout<<res<<'\\n';\n    return 0;\n}\n\n答案应该就是这，cnt代表连续的数字的个数，res随时更新答案，pre代表前一个数字，当当前数a等于前一个数pre时候，cnt加一（连续相同子序列长度加一），否则cnt为1（重新开始了一个子序列，初始长度为1）", "Konwledge_Point": "算法与数字", "Question": "相同数字的最大连续子序列\n要在规定时间里面完成，内存不能超。\n\n", "Tag": "算法分析"}
{"Answer": "问题已解决，原因是ios微信上调用此js接口，传入的timestamp必须是字符串类型，我之前传的是数字类型。安卓上无此问题。\r\n见知乎：\r\nhttps://www.zhihu.com/question/53490788/answer/136897593?group_id=794851608767893504", "Konwledge_Point": "算法与数字", "Question": "微信企业号页面打开企业通讯录选人报错：fail_invalid signature，请问如何解决？\n企业号页面中，想打开企业通讯录选人。\n\naccess_token获取成功；\n\njsapi_ticket获取成功；\n\ngroup_ticket也获取成功；\n\nwx.config调用成功（由于debug模式，弹出ok，说明jsapi_ticket的签名算法是正确的）；\n\n\n\n但是的就是调用WeixinJSBridge.invoke(\"openEnterpriseContact\", {......}, function(){......})的时候，总是报fail_invalid signature的错误。\n\n签名算法与wx.config中用的签名算法一样，签名用的字符串也是按照官网开发文档拼接的。\n\n\n\n以下是我的代码片段：\n\n\n\n而且，我已经按照官方文档附录6的方式检查了：\n\n1、企业管理组权限验证签名算法无法验证，因为这个工具只能验证jsapi的签名算法。企业管理组权限验证签名算法与jsapi_ticket签名算法相同，并通过了\nhttp://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign\n 此页面工具的验证。\n\n2、wx.config中的nonceStr是大写S，并且timestamp和noncestr与签名中的一样。\n\n3、url是完整的，以http://开头，与location.href.split('#')[0]相同，我的这个url没有get参数。\n\n4、检查过，一样。\n\n5、access_token和group_ticket都是缓存的。\n\n6、检查了，是一样的。\n\n\n\n页面获取group_ticket签名的controller：\n\n\n\n签名的方法：\n\n\n\n请问是哪里出了问题？\n\n\n\n恳请有能之士帮下忙，帮我解决下这个问题，非常感谢。\n\n\n\n\n\n\n2016年12月22日修改\n\n\n\n问题已解决，原因是ios微信上调用此js接口，传入的timestamp必须是字符串类型，我之前传的是数字类型。安卓上无此问题。\n\n见知乎：\nhttps://www.zhihu.com/question/53490788/answer/136897593?group_id=794851608767893504", "Tag": "算法分析"}
{"Answer": "SHA算法名中的数字，通常表示输出的散列值的位数，也就是二进制数的个数。例如：\n【1】SHA-1：输出160位的散列值，也就是160个0或1组成的字符串。【2】SHA-224：输出224位的散列值，也就是224个0或1组成的字符串。【3】SHA-256：输出256位的散列值，也就是256个0或1组成的字符串。输出的散列值的位数越多，表示其能够表示的不同值的数量越多，也就意味着其抗碰撞性越强，也就是难以找到两个不同的消息具有相同的散列值。因此，一般来说，数字越大的SHA算法，安全性越高，但同时计算效率也越低。\n您可以参考以下链接来了解更多关于SHA算法的原理和应用：\nhttps://en.wikipedia.org/wiki/Secure_hash_algorithmshttps://www.simplilearn.com/tutorials/cyber-security-tutorial/sha-256-algorithmhttps://brilliant.org/wiki/secure-hashing-algorithms/希望这能帮到您。可以的话采纳", "Konwledge_Point": "算法与数字", "Question": "sha算法名中数字代表什么\nsha算法名中数字代表什么\n例如sha1，sha224，sha256", "Tag": "算法分析"}
{"Answer": "参考如下：\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint prime(int x)\n{\n    int i;\n    int flag = 1;\n    if (x == 1) flag = 0; \n    for (i = 2; i <= sqrt(x); i++)\n    {\n        if (x % i == 0)\n        {\n            flag = 0;\n            break;\n        }\n    }\n    return flag;\n}\n\n// 从前往后冒泡\nvoid sort(int a[],int n)\n{\n    int i,j,t,noswap;\n    for(i=0;i< n-1; i++)\n    {\n        noswap=1; // 是否交换表示 1：未交换【表示已排序好】 0：交换了\n        for(j=0;j<n-1-i;j++)\n            if(a[j+1]<a[j])\n            {\n                t=a[j+1];\n                a[j+1]=a[j];\n                a[j]=t;\n                noswap=0;\n            }\n        if(noswap)  // 已经排序好，直接退出就行\n            break;\n    }\n}\n\nint main()\n{\n    int n, m = 0, i, temp;\n    cin>>n;\n\n    int a[n];\n    for(i = 0; i < n; i++)\n    {\n        cin>>temp;\n        if(prime(temp))\n            a[m++] = temp;\n    }\n\n    sort(a, m);\n\n    for (i = 0; i < m; i++)\n    {\n        printf(\"%d \", a[i]);\n    }\n}\n", "Konwledge_Point": "算法与数字", "Question": "用C++代码做输入数字n表示输入个数，讲输入的n个数字中找到里面的所有素数（包括重复的素数），并从小到大输出出来。\n用C++代码做输入数字n表示输入个数，讲输入的n个数字中找到里面的所有素数（包括重复的素数），并从小到大输出出来。\n例如：\n输入\n4\n3 7 2 1\n输出\n2 3 7\n我的思路：\n先判断素数，在判断正确，在排序，在输出，但是自己实现不了\n\n\n#\ninclude\n \n\n\n\nusing\n \nnamespace\n std;\n\n\nbool\n \nIsPrime\n(\nint\n n)\n\n\n{\n    \nif\n(n <= \n1\n){\n        cout<<n<<\n\"不是素数\"\n<<endl; \n        \nreturn\n \nfalse\n;\n    }\n    \nfor\n (\nint\n i = \n2\n; i < n; i++)\n    {\n        \nif\n ((n % i) == \n0\n){\n            cout<<n<<\n\"不是素数\"\n<<endl;\n            \nreturn\n \nfalse\n;\n        }\n    }\n    cout<<n<<\n\"是素数\"\n<<endl;\n    \nreturn\n \ntrue\n;\n}\n\n\nint\n \nmain\n()\n \n{\n    \nint\n a = \n2\n, b = \n17\n, c = \n18\n;\n    \nIsPrime\n(a);\n    \nIsPrime\n(b);\n    \nIsPrime\n(c);\n    \nreturn\n \n0\n;\n}\n\n", "Tag": "算法分析"}
{"Answer": "4行x=a改成x,  ，然后6行下面才补上x=a;你printf打印二进制的顺序反了，从小到大打印了。", "Konwledge_Point": "算法与数字", "Question": "编译无错。运行问题。请指正\n对数字求特征值是常用的编码算法，奇偶特征是一种简单的特征值。对于一个整数，从个位开始对每一位数字编号，个位是1号，十位是2号，以此类推。这个整数在第n位上的数字记作x，如果x和n的奇偶性相同，则记下一个1，否则记下一个0。按照整数的顺序把对应位的表示奇偶性的0和1都记录下来，就形成了一个二进制数字。比如，对于342315，这个二进制数字就是001101。\n\n\n你的程序要读入一个非负整数，整数的范围是[0,1000000]，然后按照上述算法计算出表示奇偶性的那个二进制数字，输出它对应的十进制值。\n\n\n\n\n#include \n\n\nint\n main()\n{\nint\n a,\nx\n=a,im,sum=\n0\n,b=\n1\n,i=\n1\n;\n\nprintf\n(\n\"请输入小于等于1000000的正整数\\n\"\n); \nscanf(\n\"%d\"\n,&a);\n\nwhile\n(\nx\n>\n0\n)\n{\n\nx\n=a%10;\n\nif\n(i%2!=\nx\n%2){\n    im=\n0\n;\n    \nprintf\n(\n\"%d\"\n,im);\n}\n\nelse\n{\nim=\n1\n;\nsum=sum+b; \n\nprintf\n(\n\"%d\"\n,im);\n}\nb=b*\n2\n;\ni++;\na/=\n10\n;\n}\n\nprintf\n(\n\"    %d\"\n,sum);\n\nreturn\n \n0\n;\n}\n", "Tag": "算法分析"}
{"Answer": "如果输入的不是数字,input.next().charAt(0) 接收的是你输入的那个不是数字的字符,你需要再加一个input.next() 来接y/n", "Konwledge_Point": "算法与数字", "Question": "急，这个判断不是数字后跳到else，下面的键盘输入为什么不起作用？\n为什么我后面的jiXu = input.next().charAt(0);这一句不起作用？\n输入数字就没问题，输入字母或者中文，因为用了数字判断，所有会调到后面的else，可是下面有个键盘输入，为什么不起作用，都不需要你输入\n\n\n\npackage choJiang;\nimport java.util.Scanner;\npublic class Jineng {\n    public static void mai\nn\n(String[] args){\n        Scanner \ninput\n = new Scanner(System.\nin\n);\n        String name;\n        int max = 9999;\n        int min = 1000;\n        int huiYuan = (int) (Math.random()\n*(max-min)) +min;\n\n        char jiXu;\n        \ndo\n{\n            System.\nout\n.printl\nn\n(\n\"************欢迎进入奖客富翁系统************\"\n);\n            System.\nout\n.printl\nn\n(\n\"1.注册\\t2.登录\\t3.抽奖\"\n);\n            System.\nout\n.printl\nn\n(\n\"*************************************\"\n);\n            System.\nout\n.pr\nint\n(\n\"请选择菜单:\"\n);\n            \nif\n(\ninput\n.hasNext\nInt\n()){\n                int \nindex\n = \ninput\n.next\nInt\n();\n                switch(\nindex\n){\n                    case 1:\n                        System.\nout\n.printl\nn\n(\n\"[奖客富翁系统  > 注册]\"\n);\n                        System.\nout\n.printl\nn\n(\n\"请填写个人注册信息:\"\n);\n                        System.\nout\n.pr\nint\n(\n\"用户名:\"\n);\n                        name = \ninput\n.next();\n                        System.\nout\n.pr\nint\n(\n\"密码(整数):\"\n);\n                        \nif\n(\ninput\n.hasNext\nInt\n()){\n                            int miMa = \ninput\n.next\nInt\n();\n                            System.\nout\n.printl\nn\n(\n\"注册成功,请记好您的会员卡号\"\n);\n                            System.\nout\n.printl\nn\n(\n\"用户名\\t密码\\t会员卡号\"\n);\n                            System.\nout\n.printl\nn\n(name+\n\"\\t\"\n+miMa+\n\"\\t\"\n+huiYuan);\n                        }\nelse\n{\n                            System.\nout\n.printl\nn\n(\n\"请输入正确的密码格式\"\n);\n                        }\n                        break;\n                    case 2:\n                        System.\nout\n.printl\nn\n(\n\"[奖客富翁系统  > 登录]\"\n);\n                        System.\nout\n.pr\nint\n(\n\"请输入用户名:\"\n);\n                        String name2 = \ninput\n.next();\n                        \nif\n(\n\"name\"\n.equals(name2)){\n                            System.\nout\n.printl\nn\n(\n\"去\"\n);\n                        }\n                        break;\n                    case 3:\n                        System.\nout\n.printl\nn\n(\n\"抽奖\"\n);\n                        break;\n                    default:\n                        System.\nout\n.printl\nn\n(\n\"输入错误\"\n);\n                        break;\n                }\n            }\nelse\n{\n                System.\nout\n.printl\nn\n(\n\"请输入正确数字\"\n);\n            }\n            System.\nout\n.printl\nn\n(\n\"继续吗？(y/n)\"\n);\n            jiXu = \ninput\n.next().charAt(0);\n            \nif\n(\n'n'\n==(jiXu)){\n                System.\nout\n.printl\nn\n(\n\"系统已退出，谢谢使用!\"\n);\n            }\n        }\nwhile\n(\n'y'\n==(jiXu));\n    }\n}\n", "Tag": "算法分析"}
{"Answer": "越界就查看for循环访问，冒泡每次是相邻两个元素比较", "Konwledge_Point": "算法与数字", "Question": "c语言实现冒泡排序时出现数组溢出\nvoid po_sort(int* arr, int sz)\n{\n    int i = 0;\n    for (i = 0; i < sz - 1; i++)\n    {\n        int flag = 1;\n        int j = 0;\n        for (j = 0; j < sz - 1 - i; j++);\n        {\n            if (arr[j] > arr[j + 1])\n            {\n                int tmp;\n                tmp    = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = tmp;\n                flag = 0;\n            }\n        }\n        if (flag == 1)\n        {\n            break;\n        }\n    }\n}\n    int main()\n    {\n        int i;\n        int arr[10] = {10,9,8,7,6,5,4,3,2,1 };\n        int sz=sizeof(arr)/sizeof(arr[0]);\n        po_sort(arr,sz);\n\n\nfor\n (i = \n0\n; i < sz; i++)\n{\n    \nprintf\n(\n\"%d \"\n, arr[i]);\n}\n\n\n", "Tag": "算法分析"}
{"Answer": "是你创建链表的时候多创建了一个节点你先创建了 head 首元节点之后 for (i = 1; i <= pMng->nNodeCnt; ++i) 循环NodeCnt次 (比如NodeCnt=10)一共创建了 NodeCnt 加 1  (10+1=11)个节点但是你  Print(pMng)函数只输出 10个节点,最后一个没有输出而排序时是遍历全部11个节点,最后一个没有输出的节点也参与排序再次  Print(pMng)输出还是只输出前 10个节点,之前没有输出的值排到了前面所以输出了, 排到最后的最大值又没有输出\n你把for (i = 1; i <= pMng->nNodeCnt; ++i)  中i=1 改成 i=2 即可\n\n如有帮助，请点击我的回答下方的【采纳该答案】按钮帮忙采纳下，谢谢!\n", "Konwledge_Point": "算法与数字", "Question": "双向链表的排序问题，结果为什么总有一个奇奇怪怪的数\n写了一个随机双向链表，排序操作有问题，导致我在进行排序的时候，总是会出现一个不知道哪来的数，请大家帮我看看是函数写的有问题还是在创建链表的时候我多创了空间导致他自己写了个数在里面。\n\n\n这个是我写的结构体：\ntypedef struct ltbl\n{\n    struct ltbl* pPre;      //前一个\n    struct ltbl* pNxt;      //后一个\n    int nKey;                 //结点里的值\n    unsigned char ucDummy[32];    //备用\n}LTBL;\n\n\ntypedef struct mng\n{\n    int nNodeCnt;         //链表长度\n    LTBL* pHead;         //指向头指针\n}MNG;\n\n\n这里是我的创建和排序：\nint TBLCreate (MNG* pMng, int nCnt)\n{\n    int i;\n    LTBL* head = NULL;\n    LTBL* p = NULL;\n    LTBL* q = NULL;\n    head = (LTBL*)malloc(sizeof(LTBL));\n    pMng->pHead = head;\n    srand((unsigned int)time(0));\n    pMng->nNodeCnt = nCnt;\n\n\nif(NULL \n=\n=\n head)\n{\n    printf(\n\"WRONG!\"\n)\n;\n\n    return NG\n;\n\n}\nhead->pPre \n=\n NULL\n;\n\nhead->nKey \n=\n rand() % \n200\n;\n\nhead->pNxt \n=\n NULL\n;\n\n\np\n \n=\n head\n;\n\nfor(i\n=\n1\n; i<=pMng->nNodeCnt; ++i)\n\n{\n    q \n=\n (LTBL*)malloc(sizeof(LTBL))\n;\n\n    if(NULL \n=\n=\n q)\n    {\n        printf(\n\"WRONG!\"\n)\n;\n\n        return NG\n;\n\n    }\n    q->nKey \n=\n rand() % \n200\n;\n\n    p->pNxt \n=\n q\n;\n\n    q->pPre \n=\n p\n;\n\n    q->pNxt \n=\n NULL\n;\n\n    p \n=\n q\n;\n\n}\nq->pNxt \n=\n NULL\n;\n\nreturn OK\n;\n\n\n\n\n}\n\n\nvoid TBLSort(MNG* pMng, int nFlg)\n{\n    int t = 0;\n    LTBL* head;\n    LTBL* p = NULL;\n    LTBL* q = NULL;\n    head = pMng->pHead;\n    if(0 == nFlg)\n    {\n        for(p=head; p!=NULL; p=p->pNxt)\n        {\n            for(q=p->pNxt; q!=NULL; q=q->pNxt)\n            {\n                if(p->nKey > q->nKey)\n                {\n                    t = q->nKey;\n                    q->nKey = p->nKey;\n                    p->nKey = t;\n                }\n            }\n        }\n    }\n    if(1 == nFlg)\n    {\n        for(p=head; p!=NULL; p=p->pNxt)\n        {\n            for(q=p->pNxt; q!=NULL; q=q->pNxt)\n            {\n                if(p->nKey < q->nKey)\n                {\n                    t = q->nKey;\n                    q->nKey = p->nKey;\n                    p->nKey = t;\n                }\n            }\n        }\n    }\n    Print(pMng);\n}\n\n\n运行结果及报错内容\n\n\n\n\n我的解答思路和尝试过的方法 ：我换的是结点里面的值 如果有人能告诉我怎么换结点就更好了 我试了很多办法都运行不了", "Tag": "算法分析"}
{"Answer": "如果我的回答对你有帮助，请点击旁边的采纳按钮，谢谢\n\n你这可能是思路没问题，写代码的时候糊涂了\n因为这个代码写到后面意思就不对了\n\n思路应该是这样的：\n1.将所有数字排序\nfor(i=1;i<n;i++){\n        for(j=i;j>0&&array[j]<array[j-1];j--){\n            temp=array[j];\n            array[j]=array[j-1];\n            array[j-1]=temp;\n        }\n    }\n\n\n\n2.统计次数\nresult[0][0]=array[0];\n    result[0][1]=1;\n    count=0; \n    for(i=1;i<n;i++){\n        if(array[i]==result[count][0]){\n            result[count][1]++;\n        }else{\n            count++;\n            result[count][0]=array[i];\n            result[count][1]=1;\n        }\n    }\n\n\n\n3.对次数进行排序\n    for(i=1;i<=count;i++){\n        for(j=i;j>0&&result[j][1]>result[j-1][1];j--){\n            temp=result[j][0];\n            result[j][0]=result[j-1][0];\n            result[j-1][0]=temp;\n            \n            temp=result[j][1];\n            result[j][1]=result[j-1][1];\n            result[j-1][1]=temp;\n        }\n    }\n\n\n\n具体代码如下：\n/*\n问题描述 \n 给定 n 个整数，请统计出每个整数出现的次数，按出现次数从多到少\n的顺序输出。\n输入格式 \n 输入的第一行包含一个整数 n，表示给定数字的个数。\n 第二行包含 n 个整数，相邻的整数之间用一个空格分隔，表示所给定\n的整数。\n输出格式 \n 输出多行，每行包含两个整数，分别表示一个给定的整数和它出现的\n次数。按出现次数递减的顺序输出。如果两个整数出现的次数一样多，则\n先输出值较小的，然后输出值较大的。(1 ≤ n ≤ 1000，)\n样例输入 \n12\n5 2 3 3 1 3 4 2 5 2 3 5\n样例输出 \n3 4\n2 3\n5 3\n1 1\n4 1\n*/\n#include<stdio.h>\nint main(void){\n    int n;\n    int i,j,temp,count;\n    printf(\"请输入数字个数：\");\n    scanf(\"%d\",&n);\n    int array[n];\n    int result[n][2];\n    //输入数据 \n    printf(\"请输入数据：\");\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&array[i]);\n    }\n    //对数字排序\n    for(i=1;i<n;i++){\n        for(j=i;j>0&&array[j]<array[j-1];j--){\n            temp=array[j];\n            array[j]=array[j-1];\n            array[j-1]=temp;\n        }\n    }\n    //统计次数\n    result[0][0]=array[0];\n    result[0][1]=1;\n    count=0; \n    for(i=1;i<n;i++){\n        if(array[i]==result[count][0]){\n            result[count][1]++;\n        }else{\n            count++;\n            result[count][0]=array[i];\n            result[count][1]=1;\n        }\n    }\n    //对次数进行排序\n    for(i=1;i<=count;i++){\n        for(j=i;j>0&&result[j][1]>result[j-1][1];j--){\n            temp=result[j][0];\n            result[j][0]=result[j-1][0];\n            result[j-1][0]=temp;\n            \n            temp=result[j][1];\n            result[j][1]=result[j-1][1];\n            result[j-1][1]=temp;\n        }\n    } \n    //输出\n    for(i=0;i<=count;i++){\n        printf(\"%d\\t%d\\n\",result[i][0],result[i][1]);\n    } \n    return 0;\n}\n\n\n", "Konwledge_Point": "算法与数字", "Question": "关于#c++#数字排序的问题\n为什么这个题我这样的解法就不对呀？\n\n\n\n\n#include \n\n\n#define endl '\\n'\n\nusing namespace std;\nint \nn\n=0;\nint a[1000]={0};\nint sign[1001]={0};\n\nint findmax()\n{\n    int \nmax\n=0;\n    int \nmaxnum\n=0;\n    \nfor\n(int \ni\n=0;i<1000;i++)\n    {\n        \nif\n(sign[i]==0)\n        {\n            continue;\n        }\n         \nelse\n\n         {\n             \nif\n(sign[i]>maxnum)\n             {\n                 \nmax\n=i;\n                 \nmaxnum\n=sign[i];\n            }\n        }\n    } \n    return max;\n}\n\nint main()\n{\n    int \nt\n=0,num=0;\n    cin>>n;\n    \nfor\n(int \ni\n=0;i>a[i];\n        sign[a[i]]++;\n    }\n    \nfor\n(int \ni\n=0;i<1000;i++)\n    {\n        \nif\n(sign[i]==0)\n        {\n            continue;\n        }\n         \nelse\n\n         {\n             num++;\n         }\n    }\n    \nfor\n(int \ni\n=0;i<num;i++)\n    {\n        \nt\n=findmax();\n        cout<<t<<\n\" \"\n<<sign[t]<<endl;\n        sign[t]=0;\n    }\n} \n", "Tag": "算法分析"}
{"Answer": "#include<stdio.h>\n\n#define MAX_N 1000 \n\nint main()\n{\n    int n, i, j, k;\n    int a[MAX_N], b[MAX_N]; \n    \n    while (scanf(\"%d\", &n) != EOF) {\n        \n        for (i = 0; i < n; i++) {\n            scanf(\"%d\", &a[i]);\n        }\n\n        k = 0;\n        for (i = 0; i < n; i++) { \n            for (j = 0; j < k; j++) {\n                if (a[i] == b[j]) { \n                    break;\n                }\n            }\n            if (j == k) {\n                b[k] = a[i];\n                k++;\n            }\n        }\n        for (i = 0; i < k; i++) { \n            for (j = i + 1; j < k; j++) {\n                if (b[i] > b[j]) {\n                    int temp = b[i];\n                    b[i] = b[j];\n                    b[j] = temp;\n                }\n            }\n        }\n        printf(\"%d\\n\", k);\n        for (i = 0; i < k; i++) {\n            printf(\"%d \", b[i]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n", "Konwledge_Point": "算法与数字", "Question": "输入n个随机数，将相同的去掉并按从小到大排序。\n输入数据有多组，每组测试数据有 2 行，第 1 行为 1 个正整数，表示所生成的随机数的个数：N\n\n\n第 2 行有 N 个用空格隔开的正整数，为所产生的随机数。\n\n\n对于每组测试实例，输出 2 行，第 1 行为 1 个正整数 M，表示不相同的随机数的个数。第 2 行为 M 个用空格隔开的正整数，为从小到大排好序的不相同的随机数。", "Tag": "算法分析"}
{"Answer": "l = [[1], [1, 1]]\nn = int(input(\">>>\"))\n\nfor i in range(2, n):\n    li = [0] * (i + 1)\n    for j in range(i + 1):\n        if j == 0 or j == i:\n            li[j] = 1\n        else:\n            li[j] = l[i - 1][j] + l[i - 1][j - 1]\n    l.append(li)\nfor i in range(n):\n    strC = ' '.join(map(str, l[i]))\n    print(strC.center(4 * n))\n\n'''--result\n>>>10\n                   1                    \n                  1 1                   \n                 1 2 1                  \n                1 3 3 1                 \n               1 4 6 4 1                \n             1 5 10 10 5 1              \n            1 6 15 20 15 6 1            \n          1 7 21 35 35 21 7 1           \n         1 8 28 56 70 56 28 8 1         \n      1 9 36 84 126 126 84 36 9 1       \n'''\n\n", "Konwledge_Point": "算法与数字", "Question": "sdut-array2-5 打印“杨辉三角“ 品中国数学史 增民族自豪感\n北宋人贾宪约1050年首先使用“贾宪三角”进行高次开方运算。 南宋数学家杨辉在《详解九章算法》（1261年）记载并保存了“贾宪三角”，故称杨辉三角。杨辉三角是中国数学史上的一个伟大成就。 杨辉三角，是中国古代数学的杰出研究成果之一，它把二项式系数图形化，把组合数内在的一些代数性质直观地从图形中体现出来，是一种离散型的数与形的结合。\n\n\n中国南宋数学家杨辉1261年所著的《详解九章算法》一书中出现。在欧洲，帕斯卡（1623-1662）在1654年发现这一规律，所以这个表又叫做帕斯卡三角形。帕斯卡的发现比杨辉要迟393年，比贾宪迟600年。\n\n\n杨辉三角数字的特点为：\n\n\n（1）在三角形的首列和对角线上，数值均为1；\n\n\n（2）其余数据为：每个数字等于上一行的左右两个数字之和，第n+1行的第i个数等于第n行的第i-1个数和第i个数之和，用公式表示为： C(n+1,i)=C(n,i)+C(n,i-1)。\n\n\n图示为：\n\n\n1.jpg\n\n\n杨辉三角的应用：(a+b)的n次方，展开式中的各项系数依次对应杨辉三角的第(n+1)行中的每一项。\n\n\n输入格式:\n欲打印杨辉三角的行数n（1<=n<=13)。\n\n\n输出格式:\n（1）输出的数据为等腰三角形样式；\n\n\n（2）每个数字占据4个字符的位置，数字左对齐，数字不足4位的右边留出空格；\n\n\n（3）最后一行的数值“1”顶格，前面无空格。\n\n\n提示：以n=5，分析行首空格数为：\n\n\n输入样例1:\n5\n结尾无空行\n输出样例:\n        1\n      1   1\n    1   2   1\n  1   3   3   1\n1   4   6   4   1\n结尾无空行\n输入样例2:\n6\n结尾无空行\n输出样例:\n          1\n        1   1\n      1   2   1\n    1   3   3   1\n  1   4   6   4   1\n1   5   10  10  5   1\n结尾无空行", "Tag": "算法分析"}
{"Answer": "package test;\r\n\r\nimport java.util.Arrays;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\npublic class Test {\r\n\r\n\t/**\r\n\t * @param args\r\n\t */\r\n\tprivate static Map map = new HashMap();\r\n\tprivate static Map maps = new HashMap();\r\n\r\n\tstatic {\r\n\t\tfor (int i = 0; i < 10; i++) {\r\n\t\t\tbyte[] bytes = { (byte) (97 + i) };\r\n\t\t\tmap.put(new String(bytes).toUpperCase(), i);\r\n\t\t\tmaps.put(i+\"\", new String(bytes).toUpperCase());\r\n\t\t}\r\n\t\tmaps.put(\" \", \" \");\r\n\t\tmaps.put(\"+\", \"+\");\r\n\t}\r\n\r\n\tpublic static Long[] strToLong(String[] ag) {\r\n\t\tLong[] lo = new Long[ag.length + 1];\r\n\t\tLong res = 0L;\r\n\t\tfor (int i = 0; i < ag.length; i++) {\r\n\t\t\tchar[] ch = ag[i].toCharArray();\r\n\t\t\tString str = \"\";\r\n\t\t\tfor (int j = 0; j < ch.length; j++) {\r\n\t\t\t\tstr = str + map.get(String.valueOf(ch[j])) + \"\";\r\n\t\t\t}\r\n\r\n\t\t\tlo[i] = Long.valueOf(str);\r\n\t\t\tres += lo[i];\r\n\t\t}\r\n\t\tlo[lo.length - 1] = res;\r\n\t\tArrays.sort(lo);\r\n\r\n\t\treturn lo;\r\n\t}\r\n\r\n\tpublic static String[] maxLong(Long[] str) {\r\n\t\tString[] rest = new String[str.length];\r\n\t\tlong maxLen = str[str.length - 1].toString().length();\r\n\r\n\t\tfor (int i = 0; i < str.length; i++) {\r\n\t\t\tlong Len = str[i].toString().length();\r\n\t\t\tlong sub = maxLen - Len;\r\n\t\t\tString s = \"\";\r\n\t\t\tfor (int j = 0; j < sub; j++) {\r\n\t\t\t\ts = \" \" + s;\r\n\t\t\t}\r\n\r\n\t\t\ts = s + str[i];\r\n\t\t\t\trest[i] = s;\r\n\t\t\t\r\n\t\t}\r\n\r\n\t\treturn rest;\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tString[] ag = { \"BAAAA\", \"BAAA\", \"BAABB\", \"BAABB\" };\r\n\t\tLong[] lo = strToLong(ag);\r\n\t\tString[] str = maxLong(lo);\r\n\t\tfor (int i = 0; i < str.length; i++) {\r\n\t\t\t\r\n\t\t\tif (i == 0 || i == str.length - 1 ){\r\n\t\t\t\tSystem.out.print(\"   \");\r\n\t\t\t} else {\r\n\t\t\t\tSystem.out.print(\"+  \");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tchar[] byt = str[i].toCharArray();\r\n\t\t\tfor (int j = 0 ; j < byt.length; j++){\r\n\t\t\t\tSystem.out.print(maps.get(byt[j]+\"\"));\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tSystem.out.println();\r\n\t\t\t\r\n\t\t\tif (str.length - 2 == i){\r\n\t\t\t\tSystem.out.println(\"-------------\");\r\n\t\t\t} \r\n\t\t\t\r\n\t\t\t\r\n\t\t\t//System.out.println(str[i]);\r\n\t\t}\r\n\t}\r\n\r\n}", "Konwledge_Point": "算法与数字", "Question": "Java高要求逻辑训练题\n给定等式其中每个字母代表一个数字，且不同数字对应不同字母。编程求出这些数字并且打出这个数字的算术计算竖式。\n\n\n\n   A B C D E\n  +    D F G\n  +    D F G\n——————————\n   X Y Z D E\n\n\n\n\nABCDEFGXYZ十个字母各不相等并且分别代表0~9\n\n试过用for循环遍历，但是判断条件想得头都大了。同时经常漏掉判断条件得出很多个错误答案\n\n试过用数组代表0~9先求出算数式再代入字母，依然不知从何下手\n\n也试过先找出隐性条件例G==0 F==5 X==A+1 B>=8   但是想得还是头大。\n\n求：\n\n解这个题目是否需要用到算法？\n\n尽量简短的实现代码\n\n\n\n万分感谢~~~", "Tag": "算法分析"}
{"Answer": "看起来一样，都是O(n)。\r\nlist在指定位置插值是用的System.arraycopy，直接基于内存复制，在数据量大的时候有优势（具体大到什么程度，未经测试）。\r\n当然你本地用数组插值也换成System.arraycopy，那肯定是下面的效率更高点。毕竟上面多了一个往List的转换函数。\r\n总体来说，双方类似。", "Konwledge_Point": "算法与数字", "Question": "以下在数组指定位置插入元素的两种方法哪个时间复杂度更低，效率更高？\n废话不多说，直接上图。\n\n以上两种算法都是在数组指定位置插入一个数字，哪一种算法时间复杂度更低，换句话说效率更高，我指的是当数组中数据很多的时候，最坏时间复杂度。", "Tag": "算法分析"}
{"Answer": "你举的例子，为什么b[1]=[0,0,10]，0不是l的元素啊", "Konwledge_Point": "算法与数字", "Question": "Python设计一个有关余数的列表\n\nn,\nk\n=\nmap\n(\nint\n,\ninput\n().\nsplit\n())\n\n\nl\n=\nlist\n(\nmap\n(\nint\n,\ninput\n().\nsplit\n()))\n\n\n\nn代表列表l有n个数字,k是一个正整数\n想问一下 如何创建这么一个数组 b[i]:代表l中的数字对k取余后，余数为i的前三个最大数字\n比如n=4\nk=3\nl=[2,5,8,10]\n那么b[2]=[2,5,8]\nb[1]=[0,0,10]\n\n\n要求b[i]里面降序 ，实在不知道用什么排序算法了，请求帮助", "Tag": "算法分析"}
{"Answer": "n-n * p改为 n * (1-p)", "Konwledge_Point": "算法与数字", "Question": "问题 B: 概率论，答案错误\n题目描述\n小L正在期末考试概率论的考场，但是她遗忘了一个公式的符号是>还是<，于是便开始选择听天由命（ZYZ自研的Z队算法，运行结果只有两个 < 或 >），假设每次命中>的概率为 p，因为小L考试就比较无聊，所以她做了 n 次（因为Z队算法运行的太快了！），她想问你最后命中 < 的期望命中次数是多少。\n输入\n第一行一个整数 n，代表Z队算法执行的次数，n的数据范围是 [1,1018]。\n第二行一个浮点数 p，表示每次执行Z队算法时命中>的概率，范围是 [0,1]。\n输出\n仅一个数字表示最后命中<的期望命中次数，只输出整数部分。\n样例输入 Copy\n19990930\n0.104\n样例输出 Copy\n17911873\n\n\n\n\n#\ninclude\n\n\n\nint\n \nmain\n()\n \n{\n    \nunsigned\n \nlong\n \nlong\n n;\n    \ndouble\n p;\n    \nscanf\n(\n\"%llu\"\n,&n);\n    \nscanf\n(\n\"%lf\"\n,&p);\n    \nprintf\n(\n\"%llu\"\n,(\nunsigned\n \nlong\n \nlong\n)(n-n*p));\n    \nreturn\n \n0\n;\n}\n", "Tag": "算法分析"}
{"Answer": "溢出问题在此不讨论，只要函数传进来的str有值就行。函数里面直接写这句试试:return str.substring(str.lastIndexOf(',')+1);只有一条纪录也可以正常使用，当然ip地址对不对那就自己验证了。还有函数外面的事情就自己解决了，比如溢出之类的。", "Konwledge_Point": "算法与数字", "Question": "对一个Java字符串进行分割并倒叙遍历获取最后一个IP地址\n问题遇到的现象和发生背景\n\n\n给你一个无穷字符串类型的 IP ，IP 之间以 ， 分割，类似这样 String ipStr = \"192.168.10.222,192.168.10.43,192.168.10.243\",现在需要你写一个方法，入参为 ipStr，出参为 ipStr 的最后一个 Ip。\n\n\n问题相关代码，请勿粘贴截图\n\n\npublic\n \nclass\n \nIpStr2\n {\n\n    \n/**\n     * 计时器\n     */\n\n    \nprivate\n \nstatic\n StopWatch stopWatch = \nnew \nStopWatch\n();\n\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[] args) {\n        StringBuilder \nstr\n = \nnew \nStringBuilder\n();\n        \n// N\n\n        \nfor\n (\nint\n i = \n1\n; i <= \n10000000\n; i++) {\n            \nstr\n.\nappend\n(i)\n                    .\nappend\n(\n\".\"\n + i)\n                    .\nappend\n(\n\".\"\n + i)\n                    .\nappend\n(\n\".\"\n + i)\n                    .\nappend\n(\n\",\"\n);\n        }\n        stopWatch.\nstart\n();\n        \nString\n s = \nipStr\n(\nString\n.\nvalueOf\n(\nstr\n));\n        stopWatch.\nstop\n();\n        System.\nout\n.\nprintln\n(\n\"运算耗时为：\"\n + stopWatch.\nprettyPrint\n());\n        System.\nout\n.\nprintln\n(\n\"计算值为： = \"\n + s);\n    }\n\n    \npublic\n \nstatic\n \nString\n \nipStr\n(\nString\n \nstr\n) {\n        \nArrayList\n<\nString\n> list = \nnew \nArrayList\n<>();\n        \nString\n[] \nsplit\n = \nstr\n.\nsplit\n(\n\",\"\n);\n        \nfor\n (\nString\n s : \nsplit\n) {\n            list.\nadd\n(s);\n        }\n        \n// 反转list\n\n        Collections.\nreverse\n(list);\n        \nreturn\n list.\nget\n(\n0\n);\n    }\n}\n\n\n\n运行结果及报错内容\n\n\n数据量超过一亿条会堆溢出\n\n\n我的解答思路和尝试过的方法\n\n\n我已经尝试过根据索引获取，反转实现，流实现等，效果皆不理想。目前最优方案是通过倒序遍历获取效率最高，但是不会倒序实现，希望解决思路附代码实现，感谢，其他方案只要没有性能问题都可以。\n\n\n我想要达到的结果\n\n\n现在需要你写一个方法，入参为 ipStr，出参为 ipStr 的最后一个 Ip。", "Tag": "算法分析"}
{"Answer": "```\r\n 153\r\n153, 1 5 3.\r\nyes\r\nx1=-0.697224 x2=-4.302776\r\n3 5 1 1 3 5 7 2 4 6\r\n1 1 2 3 3 4 5 5 6 7\r\n3 5 1 1 3 5 7 2 4 6\r\n1 1 2 3 3 4 5 5 6 7\r\nPress any key to continue\r\n```\r\n\r\n\r\n\r\n```\r\n 179\r\n179, 1 7 9.\r\nno\r\nx1=-1.697224 x2=-5.302776\r\n9 7 1 1 3 5 7 2 4 6\r\n1 1 2 3 4 5 6 7 7 9\r\n9 7 1 1 3 5 7 2 4 6\r\n1 1 2 3 4 5 6 7 7 9\r\nPress any key to continue\r\n```", "Konwledge_Point": "算法与数字", "Question": "C语言     求大神拯救\n根据下列要求，完成程序\n\n1从键盘输入一个三位数整数，并输出该整数，同时输出该三位整数的每一位数字\n\n2写一个函数，判断该三位整数是否为水仙花数\n\n3以该整数的三位数字作为一元二次方程的系数，求该一元二次方程的根\n\n4定义该整形数组，包含十个数据，把该整数的三位数字。依次放入该数组的最前三位，并把数组内容补充完整。并对该数组进行排序，分别输出该数组排序前和排序后的顺序\n\n5对4中做好的数组进行排序（算法不和4相同）输出。（限用指针实现）", "Tag": "算法分析"}
{"Answer": "\nx=int(input(\"请输入一个正整数\"))\ny=int(input(\"请输入另一个正整数\"))\nsum=0\nfor i in range(x,y+1):\n    sum+=i\nprint(sum)\n\n", "Konwledge_Point": "算法与数字", "Question": "输入两个正整数求他们的累加和\n问题遇到的现象和发生背景\n\n\n任意输入两个正整数而不是从1开始\n\n\n问题相关代码，请勿粘贴截图\n\n\nx=int(input(\"请输入一个正整数\"))\ny=int(input(\"请输入另一个正整数\"))\nwhile   y>x:\n    print(\"第一个正整数要小于第二个正整数\")\n    if  x<=y:\n        sum=0\n        sum=sum+x\n        x+=1\nelse:\n    print(sum)\n\n\n运行结果及报错内容\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果\n\n\n例如输入4,7则计算过程为4+5+6+7，怎样用python实现", "Tag": "算法分析"}
{"Answer": "看你的用途啦。说实在的，可以是数字累加型，也可以是定义位数，然后每个位26个字母和10个数字轮流转。\r\n如果是为了转成静态页面链接的，长点更好，不容易重复。\r\n如果有路由功能（比如说群集的负载均衡），则分段，前几个字母表示哪个具体的服务器的key。\r\n如果是为了作为临时页面的（比如说向导型的页面流，第一页，第二页，。。。最后一页，下次用户在过期失效之前，再进入的时候，直接就到处理的第N页）还是有点规律的比较好，便于下次再接着处理.", "Konwledge_Point": "算法与数字", "Question": "Tinyurl 中url的生成策略\ntinyurl可以将一长串的url转换为相当短的url，比如 \nhttp://preview.tinyurl.com/2wqbcs。\n\n\n\n我对 2wqbcs 这种形式的串比较感兴趣，感觉类似UUID或MD5这样的哈希算法所产生的，youtube的视频网址也有类似这样的串 \nhttp://www.youtube.com/watch?v=9SBB14vu8jM\n\n\n\n个人猜测是这几种可能之一：\n\n1.产生一个大的随机数，将这个数字转换为以数字和字母所表示的字符串。感觉这个可能性比较大，类似UUID这样，只要整数值足够大，重复几率很小。\n\n2.一种哈希函数，输入产生特定输出。对于tinyurl，它的长度和源url长度没有关联，感觉不像。\n\n3.一种加密算法，数据是可逆的。\n\n\n\n有对这个了解的朋友，能介绍一下么？", "Tag": "算法分析"}
{"Answer": "就是把数值用% 和 /除以10，取余 和取商，递归的进行。直到是0为止", "Konwledge_Point": "算法与数字", "Question": "这道数字逆序的题的代码如何思考呢？\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\nvoid\n \nreverse\n(\nint\n t)\n;\n\nint\n \nmain\n()\n \n{\n    \nint\n a = \n0\n;\n    cin >> a;\n    \nreverse\n(a);\n    \nreturn\n \n0\n;\n}\n\n\nvoid\n \nreverse\n(\nint\n t)\n \n{\n    \nif\n (t / \n10\n == \n0\n)\n    {\n        cout << t;\n    }\n    \nelse\n\n    {\n        \nreverse\n(t % \n10\n);\n        \nreverse\n(t / \n10\n);\n    }\n}\n\n\n\n\n\n不是很理解这些代码，希望大家帮我详细注释一下代码", "Tag": "算法分析"}
{"Answer": "结束前加个System(\"PAUSE\");", "Konwledge_Point": "算法与数字", "Question": "这个我输入完数字 后面的东西会一闪而过想知道怎么改\n编译环境 dev c++\n\n\n\n\n#\ndefine\n _CRT_SECURE_NO_WARNINGS 1\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\nclass\n \nRational\n {\n\npublic\n:\n    \nRational\n(\nint\n numerator = \n0\n, \nint\n denomintor = \n0\n);\n//分别表示分子和分母 \n\n    \nfriend\n Rational \noperator\n+(Rational r1, Rational r2);\n//+\n\n    \nfriend\n Rational \noperator\n-(Rational r1, Rational r2);\n//-\n\n    \nfriend\n Rational \noperator\n*(Rational r1, Rational r2);\n//*\n\n    \nfriend\n Rational \noperator\n/(Rational r1, Rational r2);\n// /\n\n    \nfriend\n istream& \noperator\n>>(istream& is, Rational& r);\n//重载流输入 \n\n    \nfriend\n ostream& \noperator\n<<(ostream& os, Rational& r);\n//重载流输出 \n\n    \nfriend\n \nvoid\n \nprintReal\n(Rational& r)\n;\n    \nfriend\n Rational \nnormalize\n(Rational s)\n;\n//化简函数\n\n\nprivate\n:\n    \nint\n numerator;\n    \nint\n denomintor;\n};\n\nstruct\n \nUser\n \n//用户结构体类型定义\n\n{\n    \nchar\n szName[\n20\n]; \n//用户名\n\n    \nint\n nTime; \n//使用次数\n\n    \nint\n nTest; \n//测试次数\n\n    \ndouble\n alAve; \n//平均成绩\n\n    \nint\n nAdd; \n//加法次数\n\n    \nint\n nSub; \n//减法次数\n\n    \nint\n nMul; \n//乘法次数\n\n    \ndouble\n dlScore[\n3\n]; \n//3次测试得分\n\n}user;\nRational::\nRational\n(\nint\n numerator, \nint\n denomintor)\n{\n    \nthis\n->numerator = numerator;\n    \nthis\n->denomintor = denomintor;\n}\n\nvoid\n \nprintReal\n(Rational& r)\n\n\n{\n    cout << r.numerator << \n\"/\"\n << r.denomintor;\n}\n\nRational \nnormalize\n(Rational s)\n\n\n{                                                                \n//求出分子和分母的最大公约数，用欧几里得算法\n\n    \nint\n a = \nabs\n(s.numerator);\n    \nint\n b = \nabs\n(s.denomintor);\n    \nwhile\n (b > \n0\n)\n    {\n        \nint\n t = a % b;\n        a = b;\n        b = t;\n    }\n    \nRational \nR\n(s.numerator / a, s.denomintor / a)\n;\n    \nreturn\n R;\n}\nRational \noperator\n+(Rational r1, Rational r2) {\n    \nint\n a = r1.numerator;\n    \nint\n b = r1.denomintor;\n// a/b\n\n    \nint\n c = r2.numerator;\n    \nint\n d = r2.denomintor;\n// c/d\n\n    \nint\n e = a * d + b * c;\n    \nint\n f = b * d;\n    \nRational \nR\n(e, f)\n;\n    \nreturn\n R;\n}\nRational \noperator\n-(Rational r1, Rational r2) {\n    \nint\n a = r1.numerator;\n    \nint\n b = r1.denomintor;\n// a/b\n\n    \nint\n c = r2.numerator;\n    \nint\n d = r2.denomintor;\n// c/d\n\n    \nint\n e = a * d - b * c;\n    \nint\n f = b * d;\n    \nRational \nR\n(e, f)\n;\n    \nreturn\n R;\n}\nRational \noperator\n*(Rational r1, Rational r2) {\n    \nint\n a = r1.numerator;\n    \nint\n b = r1.denomintor;\n// a/b\n\n    \nint\n c = r2.numerator;\n    \nint\n d = r2.denomintor;\n// c/d\n\n    \nint\n e = a * c;\n    \nint\n f = b * d;\n    \nRational \nR\n(e, f)\n;\n    \nreturn\n R;\n}\nRational \noperator\n/(Rational r1, Rational r2) {\n    \nint\n a = r1.numerator;\n    \nint\n b = r1.denomintor;\n// a/b\n\n    \nint\n c = r2.numerator;\n    \nint\n d = r2.denomintor;\n// c/d\n\n    \nint\n e = a * d + b * c;\n    \nint\n f = b * d;\n    \nRational \nR\n(e, f)\n;\n    \nreturn\n R;\n}\n \nistream& \noperator\n>>(istream& is, Rational& r) {\n    is >> r.numerator >> r.denomintor;\n    \nif\n (r.denomintor != \n0\n) {\n        \nreturn\n is;\n    }\n    \nelse\n {\n        cout << \n\"The denominator is 0, which is illegal. Please try again!\"\n << endl;\n        \nexit\n(\n0\n);\n    }\n}\nostream& \noperator\n<<(ostream& os, Rational& r) {\n    \nif\n (r.numerator % r.denomintor == \n0\n) {\n        os << r.numerator / r.denomintor << endl;\n        \nreturn\n os;\n    }\n    \nelse\n\n        os << r.numerator << \n\"\\\\\"\n << r.denomintor;\n    \nreturn\n os;\n}\n\nvoid\n \nuserprint\n()\n \n{}\n\nvoid\n \nLogin\n()\n \n//当前用户信息函数\n\n\n{\n    \nchar\n szName[\n20\n];\n    cout << \n\"请输入您的姓名:\"\n;\n    cin.\ngetline\n(szName, \n20\n);\n    ifstream infile;\n    User user1;\n    infile.\nopen\n(\n\"user.dat\"\n, ios::binary | ios::in);\n    \nif\n (!infile)\n    {\n        cout << \n\"没有原始记录文件，您是第一个用户!\\n\"\n;\n        \nstrcpy\n(user.szName, szName);\n        user.nTest++;\n        \nreturn\n;\n    }\n    infile.\nread\n((\nchar\n*)&user1, \nsizeof\n(User));\n    \nwhile\n (!infile.\neof\n())\n    {\n        \nif\n (\nstrcmp\n(user1.szName, szName) == \n0\n)\n        {\n            user = user1;\n            user.nTime++;\n            cout << \n\"欢迎您再次使用计算器!\"\n;\n            \nuserprint\n();\n            cin.\nget\n();\n            infile.\nclose\n();\n            \nreturn\n;\n        }\n        infile.\nread\n((\nchar\n*)&user1, \nsizeof\n(User));\n    }\n    cout << \n\"欢迎您再次使用计算器!\"\n;\n    \nstrcpy\n(user.szName, szName);\n    user.nTime++;\n    infile.\nclose\n();\n    \nreturn\n;\n}\n\nvoid\n \nSaveFile\n()\n \n//用户资料保存函数\n\n\n{\n    \nuserprint\n();\n    fstream file;\n    User user1;\n    file.\nopen\n(\n\"user.dat\"\n, ios::binary | ios::in | ios::out);\n    \nif\n (!file)\n    {\n        cout << \n\"文件打开错误，不能进行更新!\\n\"\n;\n        \nreturn\n;\n    }\n    file.\nseekp\n(\n0\n, ios::beg);\n    \nwhile\n (!file.\neof\n())\n    {\n        file.\nread\n((\nchar\n*)&user1, \nsizeof\n(User));\n        \nif\n (\nstrcmp\n(user1.szName, user.szName) == \n0\n)\n        {\n            file.\nseekp\n(\n-1\n * (\nsizeof\n(User)), ios::cur);\n            file.\nwrite\n((\nchar\n*)&user, \nsizeof\n(User));\n            file.\nclose\n();\n            \nreturn\n;\n        }\n    }\n    file.\nclose\n();\n    fstream outfile;\n    outfile.\nopen\n(\n\"user.dat\"\n, ios::binary | ios::app);\n    outfile.\nwrite\n((\nchar\n*)&user, \nsizeof\n(User));\n    outfile.\nclose\n();\n    \nreturn\n;\n}\n\nint\n \nmain\n(\nvoid\n)\n\n\n{\n    \nsrand\n(\ntime\n(\nNULL\n)); \n//初始化随机数种子语句 随机数在哪产生怎么写捏\n\n    \nLogin\n(); \n//当前用户信息函数\n\n    \nint\n choise; \n//定义字符串名\n\n \n    \ndo\n\n    {\n        \nsystem\n(\n\"cls\"\n);\n        cout << \n\"\\t这是一个简单的计算器程序，可以实现以下功能，请按对应的按键(1-5)\\n\\n\\n\"\n;\n        cout << \n\"\\t=========================MENU===========================\\n\"\n;\n        cout << \n\"\\t1:有理数加法，以0结束\\n\"\n;\n        cout << \n\"\\t2:有理数减法，以0结束\\n\"\n;\n        cout << \n\"\\t3:测试分数加减乘法运算，1次测试10道题\\n\"\n;\n        cout << \n\"\\t4:有理数乘法，以0结束\\n\"\n;\n        cout << \n\"\\t5:有理数除法，以0结束\\n\"\n;\n        cout << \n\"\\t0:退出程序\\n\\n:\"\n;\n        cout << \n\"\\t请您选择:\"\n;\n        cin >> choise;\n \n        \nint\n m1 = \nrand\n() % \n100\n + \n1\n; \n//生成1-100的随机数\n\n        \nint\n n1 = \nrand\n() % \n100\n + \n1\n;\n        \nint\n m2 = \nrand\n() % \n100\n + \n1\n;\n        \nint\n n2 = \nrand\n() % \n100\n + \n1\n;\n        \nRational \na\n(m1, n1)\n;\n        \nRational \nb\n(m2, n2)\n;\n \n        \nif\n (choise == \n1\n)\n        {\n            Rational c = a + b;\n            \nprintReal\n(c);\n        }\n        \nelse\n \nif\n (choise == \n2\n)\n        {\n            Rational c = a - b;\n            \nprintReal\n(c);\n        }\n        \nelse\n \nif\n (choise == \n3\n)\n        {\n             \n        }\n        \nelse\n \nif\n (choise == \n4\n)\n        {\n            Rational c = a * b;\n            \nprintReal\n(c);\n        }\n        \nelse\n \nif\n (choise == \n5\n)\n        {\n            Rational c = a / b;\n            \nprintReal\n(c);\n        }\n        \nelse\n \nif\n (choise == \n0\n) \n//用户选0则结束调用函数\n\n        {\n            cout << \n\"\\n\\n\\t欢迎下次继续使用计算器!\\n\"\n;\n            \nbreak\n;\n        }\n        \nelse\n\n        {\n            cout << \n\"\\n\\t输入错误，请按任意键继续!\\n\"\n;\n        }\n    } \nwhile\n (\n1\n);\n    \nSaveFile\n(); \n//调用用户资料保存函数\n\n    \nreturn\n \n0\n;\n}\n \n \n \n\n\n\n太奇怪了 调试好像也没啥错误 到底哪里错了呢", "Tag": "算法分析"}
{"Answer": "第一题：\ndef move(cube:list)->bool:\n    if (cube[0],cube[1])==(cube[2],cube[3]):return False # 同一个格子\n    if cube[0] == cube[2] or cube[1] == cube[3]:return True # 同行或同列\n    return False\ncube = list(map(int,input().split()))\nprint('是') if move(cube) else print('否')\n\n第二题：\ndef fun(n):\n    if n<=5:return 2*n\n    if n>5:\n        return fun(n-2)+3*fun(n/2)+n if n%2==0 else fun(n-1)+fun(n-2)+fun(n-3)\nprint(fun(99)+fun(100))\n\n第三题：\nn, m = eval(input())\nres = []\nfor i in range(n):\n    res += list(map(int,input().split()))\nloc = res.index(max(res))\nprint(1+loc//m, 1+loc%m)\n\n运行结果：\n(5,5)\n1 2 3 4 5\n2 3 4 5 6\n5 6 7 8 9\n7 8 9 1 2\n9 8 7 6 5\n3 5\n\n第四题：\ndef fun(n):\n    return 1 if n==1 else n*fun(n-1)\nn = int(input())\nsumtotal = 0\nfor i in range(n):\n    sumtotal += fun(i+1)\nprint(sumtotal)\n\n第五题：\ns = ['张三 男 30','李四 女 40','王五 男 50']\nwith open(r'员工信息.txt','w') as f:\n    f.write('\\n'.join(s))\nwith open(r'员工信息.txt','r') as f:\n    p = f.readlines()\nuserinfo = [i.strip().split() for i in p]\nprint(len([i for i in userinfo if int(i[2])>40]))\n\n第六题：\nres=[]\nfor x in range(185//15+1):\n    for y in range(185//17+1):\n        for z in range(185//21+1):\n            if 15*x + 17*y + 21*z == 185:\n                res.append([x,y,z])\n                break\nprint(f'有{len(res)}种方法可以做到：')\nfor i in res:\n    print(f'{i[0]}箱15公斤、{i[1]}箱17公斤、{i[2]}箱21公斤')\n\n运行结果：\n有5种方法可以做到：\n0箱15公斤、1箱17公斤、8箱21公斤\n1箱15公斤、10箱17公斤、0箱21公斤\n3箱15公斤、7箱17公斤、1箱21公斤\n5箱15公斤、4箱17公斤、2箱21公斤\n\n第七题：\nnums = list(map(int,input().split()))\nres = []\nfor i in range(len(nums)-2):\n    m = [nums[i],nums[i+1],nums[i+2]]\n    l = sorted(m)\n    if l[0]**2+l[1]**2==l[2]**2:\n        res.append(m)\nprint(len(res))\n\n运行结果：\n5 4 3 5 4 3\n[5, 4, 3] [4, 3, 5] [3, 5, 4] [5, 4, 3]\n", "Konwledge_Point": "算法与数字", "Question": "业务分析编程基础知识\n1)国际象棋的车在水平或垂直方向上移动。给出棋盘上两个不同的格子，判断车是否能在一次移动中从第一个格子移动到第二个格子。程序收到四个数字，每个数字从1到8，首先给出第一个方格的列号和行号，然后是第二个方格的列号和行号。如果车可以从第一个位置移动到第二个位置，程序应该输出 \"是\"，否则输出 \"否\"。\n\n\n2）如图，计算函数F（n）的算法由以下关系给出。\n函数F（99）+F（100）的值是多少？\n3）找到最大元素的第一次出现的索引。输出两个数字：包含二维数组中最大元素的行和列的数字。如果有多个这样的元素，就打印行号较小的那个，如果行号相等，就打印列号较小的那个。\n\n\n该程序接收到大小为n和m的数组作为输入，然后是n行，每行m个数字。\n\n\n4）如图\n5）创建一个文件，并将公司员工的信息写入其中。阅读该文件，了解有多少员工超过40岁。\n6) 该商店出售的油漆有15公斤、17公斤和21公斤的盒子。\n你必须在不开箱的情况下准确买到185公斤的油漆。有多少种方法可以做到这一点？\n7) 给出一个20个数字的清单。把一个三连号称为三个连续的数字。确定有多少个这样的三角形可以成为一个直角三角形的边。如果没有这样的三元组，打印0。", "Tag": "算法分析"}
{"Answer": "题目一参考代码：\n\nfrom collections import Counter\ns='abcdddcf'\na=Counter(s)\nl=sorted(a.items(),key=lambda x:x[1])[-1]\nprint(l)\n", "Konwledge_Point": "算法与数字", "Question": "Python基础问题求解\n1.输入一个字符串，求该字符串出现频率最高的那个字符以及其出现次数，将结果显示输出。\n2.给定一个任意字符串，其中，该字符串包含有大写和小写，现编写一函数将小写字母放在前面，大\n写字母放在最后。尽量降低算法的时间复杂度和空间复杂度（参见数据结构课程）\n3.编写一个函数，将用户输入的阿拉伯数字表示的金额表示为中文数字形式和英语形式。例如：\n￥12,539,576.00表示为“人民币壹仟贰佰伍拾叁万玖仟伍佰柒拾陆圆整”以及“RMBtwelve-millionfive\nhundredandthirty-ninethousandfivehundredandseventy-six”。\n（提示：汉语数字每四位一个单位，英语每三\n位一个单位。\n）", "Tag": "算法分析"}
{"Answer": "没看到max函数的代码呢，前面的代码是给数组赋值的", "Konwledge_Point": "算法与数字", "Question": "请问这道“数字三角形”的代码如何理解呢？\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\nusing\n \nnamespace\n std;\n\nint\n val[\n101\n][\n101\n];\n\nint\n f[\n101\n][\n101\n]; \n\nint\n n;\n\nint\n \nmain\n()\n\n\n{\n    \nmemset\n(f,\n0\n,\nsizeof\n(f));\n    cin>>n;\n    \nfor\n(\nint\n i=\n1\n;i<=n;i++)\n    {\n        \nfor\n(\nint\n j=\n1\n;j<=i;j++)\n        {\n            cin>>val[i][j];\n        }\n    } \n    \nfor\n(\nint\n i=n;i>=\n1\n;i--)\n    {\n        \nfor\n(\nint\n j=\n1\n;j<=i;j++)\n        {\n            f[i][j]=\nmax\n(f[i+\n1\n][j+\n1\n],f[i+\n1\n][j])+val[i][j];\n        }\n    }\n    cout<<f[\n1\n][\n1\n];\n    \nreturn\n \n0\n;\n}\n\n\n\n\n\n我不是很理解这些代码，希望大家帮我注释一下和给出思路分析，谢谢!", "Tag": "算法分析"}
{"Answer": "你的逻辑和代码都有错。\r\n交换这个思路不行，因为第二次交换，因为8正好是第一个，已经被交换走了，换成了1，所以和最小值交换交换的不是原始值了。\r\n\r\n# 问题解决的话，请点采纳\r\n\r\n```\r\n#include\r\n\r\nint main()\r\n{\r\n    int n;\r\n    scanf(\"%d\",&n);\r\n    int a[10],i,min,max;\r\n    for(i=0;ia[i])\r\n            min=i;\r\n        if(a[max]<a[i])\r\n            max=i;\r\n    }\r\n\tint b = a[0];\r\n\tint c = a[n - 1];\r\n\tint ma = a[max];\r\n\tint mi = a[min];\r\n\ta[max] = c;\r\n\ta[min] = b;\r\n\ta[0] = mi;\r\n\ta[n - 1] = ma;\r\n    for(i=0;i<n;i++)\r\n    {\r\n        printf(\"%d \",a[i]);\r\n    }\r\n}\r\n```", "Konwledge_Point": "算法与数字", "Question": "pta上敲题时出现关于指针与数组运用的问题~\n7-24 交换最小值和最大值\n\n\n\n本题要求编写程序，先将输入的一系列整数中的最小值与第一个数交换，然后将最大值与最后一个数交换，最后输出交换后的序列。   \n\n\n\n注意：题目保证最大和最小值都是唯一的。\n\n\n\n输入格式：\n\n\n\n输入在第一行中给出一个正整数N（≤10），第二行给出N个整数，数字间以空格分隔。\n\n\n\n输出格式：\n\n\n\n在一行中顺序输出交换后的序列，每个整数后跟一个空格。\n\n\n\n输入样例：\n\n\n\n\n\n5\n\n\n\n8 2 5 1 4\n\n\n\n\n\n输出样例：\n\n\n\n\n\n1 2 5 4 8\n\n\n\n\n\n程序清单:\n\n\n\n#include\nswap(int *p1,int *p2)       //交换两个变量的值 \n{\n    int temp;\n    temp=*p1;*p1=*p2;*p2=temp;\n}\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    int a[n],k=0,i,min,max,b;\n    for(i=0;ia[i+1])\n        {\n            k=i+1;min=a[i+1];\n        }\n        if(max<a[i+1])\n        {\n            b=i+1;max=a[i+1];\n        }\n    }\n    swap(&a[0],&a[k]);\n    swap(&a[b],&a[n]);\n    for(i=0;i<n-1;i++)\n    {\n        printf(\"%d \",a[i]);\n    }\n    printf(\"%d\",a[n]);\n}\n\n\n\n\n结果：\n\n\n\n我想请教各位咕噜我想法那里不对，遇到这种题怎么解决？寻找一个数组中最大与最小的是不是要这么麻烦？算法有更简便的请务必告知，谢了~", "Tag": "算法分析"}
{"Answer": "来个java版：\npublic class Test {\n\n    public static int N = 10;\n\n    public static int value(int px, int py, int di, int dj, int s, int n) {\n        for (int i = 0; i < n; i++) {\n            if (px == i + di && py == i + dj) {\n                return s + i + 1;\n            }\n            if (i != 0) {\n                if (px == i + di && py == 0 + dj) {\n                    return s + 3 * n - 2 - i;\n                }\n                if (px == n - 1 + di && py == i + dj) {\n                    return s + 2 * n - 1 - i;\n                }\n            }\n        }\n\n        if (n > 3) {\n            return value(px, py, 2 + di, 1 + dj, s + 3 * n - 3, n - 3);\n        }\n\n        throw new RuntimeException(\"something goes wrong.\");\n    }\n\n    public static void main(String[] args) throws Exception {\n        int width = Integer.toString((int) ((N * N - N) / 2 + N)).length();\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (i >= j) {\n                    System.out.print(String.format(\"%\" + width + \"s\", value(i, j, 0, 0, 0, N)) + \"\\t\");\n                }\n            }\n            System.out.println();\n        }\n    }\n}\n", "Konwledge_Point": "算法与数字", "Question": "脚趾踢到钢板，撞到硬题了，要求有点古怪，期待你进来\n本以为很简单的算法题，幻想几分钟几行代码搞定，没想到几年都没搞定，踢到钢板了\n各位神人果断出手，救题于千军万马中，招数任出\n当然，能够不用条件句那就最好，能不借助数组就不借助数组，当然，不是说不可以\n\n\n输入输出行数，得出下图数字阵列\n\n", "Tag": "算法分析"}
{"Answer": "number = input('请输入信用卡卡号(按回车键确定)：')\na = 0   # 奇数位总和\nfor i in range(1, len(number)+1, 2):\n    a += int(number[-i])\n\nb = 0   # 偶数位总和\nfor i in range(2, len(number)+1, 2):\n    num = int(number[-i])*2\n    if num >= 10:\n        num -= 9\n    b += num\n\nif (a+b) % 10 == 0:\n    print('校验通过')\nelse:\n    print('校验不通过')\n", "Konwledge_Point": "算法与数字", "Question": "Python上机练习，字符类型及其操作\n本关任务：编写一个能判断信用卡号是否合法的小程序。\n\n\n信用卡号必须通过lun算法进行校验，其过程：\n1、从卡号最后一位数字开始，逆向将奇数位(1、3、5等等)相加。\n2、从卡号倒数第二位数字开始，逆向将偶数位数字，先乘以2（如果乘积为两位数，则将其减去9），再求和。\n3、将奇数位总和加上偶数位总和，结果应该可以被10整除。\n例如，卡号是：5432123456788881\n逆向奇数位为 4 2 2 4 6 8 8 1 和 = 35\n逆向偶数位乘以2（有些要减去9）的结果：1 6 2 6 1 5 7 7，求和 = 35。\n最后 35 + 35 = 70 可以被10整除，认定校验通过。\n注意：信用卡的卡号长度是根据输入来确定的。", "Tag": "算法分析"}
{"Answer": "你这是让别人给你写作业来了吗？", "Konwledge_Point": "算法与数字", "Question": "初级程序设计编程练习题\n编写并测试一个函数innerProd(x，y) 它计算两个（相同长度）列表的内积。x 和y的内积计算如下：\n编写并测试一个函数removeDuplicates(somelist)，从列表中删除重复值。提示：新建一个空列表mlist，如果somelist中的元素没有出现在mlist中，将此元素追加到mlist中。\n编写并测试一个函数shuffle(myList)，该函数返回一个新的列表，此列表的内容为：随机打乱myList列表中各个元素的顺序。注意：不可使用Python自带的random模考中shuffle()函数。提示：可以使用random模块中的randrange函数产生指定范围的随机数，randrange函数的介绍见教材P179或\n\n  \n    \nPython randrange() 函数 | 菜鸟教程\n\n    \n  \nPython  randrange() 函数  Python 数字  描述  randrange() 方法返回指定递增基数集合中的一个随机数，基数默认值为1。 语法 以下是 randrange() 方法的语法:  import random  random.randrange ([start,] stop [,step])  注意：randrange()是不能直接访问的，需要导入 random  模块，然后通过 random 静态对象调..\n\n  \n\n  \n\n    \n\n      \nhttps://www.runoob.com/python/func-number-randrange.html\n\n    \n\n  \n埃拉托斯特尼筛法是一种优雅的算法，用于确定不超过n 的所有素数。基本思想是首先创建从2 到n 的数字列表。第一个数字从列表中删除，并作为素数公布，而且将该数字的所有倍数从列表中删除。此过程一直持续到列表为空。例如，如果我们希望找到不超过10 的所有素数，该列表最初将包含2、3、4、5、6、7、8、9、10。2 被删除并宣布为素数。然后4、6、8 和10 被删除，因为它们是2 的倍数。这会留下3、5、7、9。重复该过程，3 被宣布为素数并删除，并且9 被删除，因为它3 的倍数。这会留下5 和7。算法继续宣布5 是素数，并将它从列表中删除。最后，7 被宣布和删除。编写一个程序提示用户输入n，然后用筛选算法找出小于或等于n 的所有素数。", "Tag": "算法分析"}
{"Answer": "上面的数字和旋转没有关系", "Konwledge_Point": "算法与数字", "Question": "这是数据结构 平衡树旋转 上面的数字都是怎么来的啊\n", "Tag": "算法分析"}
{"Answer": "在Java中使用print的话是支持转义字符的，或者可以直接拼接一个空格进行打印即可，这里的print和C语言的print是类似的。\nSystem.out.print(num + \" \");\n", "Konwledge_Point": "算法与数字", "Question": "怎么把我这个数组横向输出，且每个数空格隔开\n刚上大一，所以想请教一下各位\n试过去掉ln但是只会输出一团数字 想要隔开数字\npackage 冒泡排序算法;\nimport java.util.Scanner;\npublic class Text {\n    public static void main(String[] args) {\n        int[] nums = {33,5,16,18,29,77,99,88};//待排序的数列\n\n\n    //外循环控制轮数\n    for(int i=0;inums\n[j+1]\n) {\n                nums\n[j]\n=nums\n[j]\n+nums\n[j+1]\n;\n                nums\n[j+1]\n=nums\n[j]\n-nums\n[j+1]\n;\n                nums\n[j]\n=nums\n[j]\n-nums\n[j+1]\n;\n            \n            }\n        }\n    }\n//输出结果\n    for(int s:nums) {\n        System.out.println(s);\n    }\n}\n\n\n\n}", "Tag": "算法分析"}
{"Answer": "能否倒推出来取决于随机算法如果是伪随时，存在一定可能倒推出来如果随机算法做到很随机了，那么几乎不可能倒推出来无论哪种情况，都需要知道随机算法的实现细节，才有倒推的可能如果从已知的数据倒推，那么需要大量的数据样本，才有可能形成一种模型，才可能预测\n如有帮助，请采纳，十分感谢！", "Konwledge_Point": "算法与数字", "Question": "我想请教一下：由一组电脑产生的随机数，能反推出它的计算公式吗？\n一个抽奖系统，现在知道其他中奖的编码，现在还剩一个奖，想知道编号\n电脑随机出来的数字能倒推回去，算出剩下的数字吗？\n电脑随机数字，一共是20万个数字，抽取十二个数字\n已知十一个个数字是181008\n156507\n155620\n109651\n193533\n070831\n032088\n174400\n055195\n082671\n007121\n那么剩下一个数字能算出来吗？\n抽出不放回的情况下", "Tag": "算法分析"}
{"Answer": "搞定了，genAppPayId…POST中paysign算法（已知）收货地址中addressDetail、Where、Mobile算法（已知）sign（已知）感谢大佬们！", "Konwledge_Point": "算法与数字", "Question": "3des ecb加密结果不一致的\n分别使用C++、CryptJs和JAVA，对一串数字加密，使用的DESede ECB PKCS5Padding加密方式，但是和另一个软件加密的结果不一致的。\n\n\n\n加密的数据： 13844445555\n\n\n\noNCpGto94/KBqX3FB3TKIg==  A工具\n\noNCpGto94/Kf2zS15DiL7w==  在线加密\n\noNCpGto94/Kf2zS15DiL7w==  CryptJS\n\noNCpGto94/Kf2zS15DiL7w==  C++\n\noNCpGto94/Kf2zS15DiL7w==  java\n\n\n\n如何和”A工具“保持一致呢？是不是和”A工具“算法或者模式不一样？那为什么前面几位又相同，后部分又不一样呢? 求解惑？", "Tag": "算法分析"}
{"Answer": "http://hi.baidu.com/youshizhihu/blog/item/de40658d95dfae10b31bba8a.html\r\n这个很详细", "Konwledge_Point": "算法与数字", "Question": "关于RSA 密钥文件结构的问题\n最近在做一个小项目，其中的数字签名部分采用RSA算法，但有一个要求是要使用指定的密钥对，从网上找了些代码，都是自己用KeyPairGenerator生成密钥对，然手再使用，代码如下：\n\n\n\nKeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(\"RSA\");\n\nkeyPairGen.initialize(512);\n\nKeyPair keyPair = keyPairGen.generateKeyPair();\n\nRSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();\n\nRSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();\n\n\n\n请问各位大侠，如何使用指定的密钥对来生成RSAPrivateKey 和 RSAPublicKey呢？，或者不采用以上该类，有其他的解决办法没？", "Tag": "算法分析"}
{"Answer": "我觉得问题在于：当收到的数据为0的时候，则中断接收。\n同一太机器上传输速度不是问题。不同机器，数据量大的时候，传输速度慢。服务端很又可能刚接受一帧数据马上再接受时还没有数据过来，返回0了。应该以别的方式结束接受。", "Konwledge_Point": "算法与数字", "Question": "求助 python json服务端与客户端之间传送出错\n我在一台电脑上运行服务端和客户端，成功。但把客户端放到另外一台电脑上的安卓模拟器里，就出错。我传送的只是一些文字和数字而已，没有特殊字符。\n\n\n\n我把服务端根据算法生成的文件变成JSON文件，切成1024大小，分多次发送。\n\n\n\n当8次发送的时候（一个小点的数据流），完全正常。当13次发送的时候（另外一个大一点的数据流），就出现故障了。\n\n\n\nadb现在乱码，看不到接收到的JSON是怎样的，但根据没乱码之前的经验，应该是不完整的。\n\n\n\n我在接收recv这块，做的是while循环，当收到的数据为0的时候，则中断接收。我设定的是recv（20480），正常的那个是接收了2次（服务端发送了8次 1024），有故障的那个是接收了3次（服务端发送了13次1024）。我在客户端设置了 RECV_BUF_SIZE = 204800。\n\n\n\n没有做切片发送的时候，做了尾标识方法的接收方法，但也不好使。\n\n\n\n请问这是什么问题，该如何解决？", "Tag": "算法分析"}
{"Answer": "#include<bits/stdc++.h>\nusing namespace std;\nstring gjd(string a,string b){ \n    string ans;\n    int la[1000]={0},lb[1000]={0};\n    int lena=a.length(),lenb=b.length();\n    for(int i=0;i<lena;i++)la[lena-1-i]=a[i]-'0'; \n    for(int i=0;i<lenb;i++)lb[lenb-1-i]=b[i]-'0';\n    int max1=max(lena,lenb);\n    for(int i=0;i<max1;i++)la[i]+=lb[i],la[i+1]+=la[i]/10,la[i]%=10; \n    if(la[max1])max1++; //判断高位是否还有;\n    for(int i=max1-1;i>=0;i--)ans+=la[i]+'0';\n    return ans;\n}\nstring a[1001]={\"0\",\"1\",\"1\"}; //预处理前两位\nint n,m;\nint main(){\n    cin>>n>>m;\n    int ans=m-n+1;\n    for(int i=3;i<=ans;i++){\n        a[i]=gjd(a[i-1],a[i-2]); //进行高精加\n    }\n    cout<<a[ans];\n    return 0;\n}\n", "Konwledge_Point": "算法与数字", "Question": "一只蜜蜂在下图所示的数字蜂房上爬动,已知它只能从标号小的蜂房爬到标号大的相邻蜂房,现在问你：蜜蜂从蜂房M开始爬到蜂房N，M=\n10\n) {\n            ++c[i+\n1\n]\n;\n\n            c[i]-=\n10\n;\n\n        }\n        if(c[\ncl\n])\n            ++\ncl\n;\n\n    }\n}\n\n\n\n\n求下面的代码", "Tag": "算法分析"}
{"Answer": "一个%d，怎么有两个变量，那你输出的就是年份了呀，改成 printf(\"There are %d cows. \\n\",   MyGetCowR(year));\n", "Konwledge_Point": "算法与数字", "Question": "一头小母牛，从出生起第四个年头开始每年生一头母牛，按此规律，第n年有头母牛？（C语言 递归函数）\n题目\n一头小母牛，从出生起第四个年头开始每年生一头母牛，按此规律，第n年有头母牛？\n我使用的是DevC++ 6.3\n代码可以正常运行 有return 0 但是算出来的结果不符合题目的正确算法\n后面递归函数如果year<4 那么输出结果都应该1才对\n可是我的结果是我输入数字是多少 输出就是多少 哪怕超过4 输出结果也是和输入一样\n不太清楚问题出在哪里 麻烦各位帮忙看看！！\n代码\n#include \nint MyGetCowR(int);\nint main()\n{\nint year;\nprintf(\"A heifer gives birth to a cow every year from the fourth year of life. \\n According to this rule, how many cows are there in the n year? \\n\");\nprintf(\"Input n = \");\nscanf(\"%d\",&year);\nprintf(\"There are %d cows. \\n\", year, MyGetCowR(year));\nreturn 0;\n}\nint MyGetCowR(int year)\n{\nif (year < 4)\nreturn 1;\nelse\nreturn MyGetCowR(year-1) + MyGetCowR(year-3);\n}\n\n\n下面是我运行出来的结果", "Tag": "算法分析"}
{"Answer": "首先差别不大，读取大量数据将占用主要的时间，比较三个字母占用时间比例很小；就3种方式来说，A会比较第4个，B仅仅比较前3个，C还需要取出子串，所以，B最快", "Konwledge_Point": "算法与数字", "Question": "SQL 查询方式中   大批量数据查询字段效率 \n![图片只有三个，如果可能的话请尽量列举更多，或者扩展其他方面的查询性能和优化 方面的知识图片说明\n\n问题内容：\n\n电话号码表t_phonebook中有一千万条数据，其中号码字段phone上创建唯一索引，\n\n且电话号码全都有数字组成，要求统计号码为321的电话号码数量，\n\n下面算法执行速度最快的是——————，最慢的是——————\n\nA：SELECT count(*) FROM t_phone WHERE phoneno>='321',AND phoneno< '321A'\n\nB：SELECT count(*) FROM t_phone WHERE phoneno LIKE '321%'\n\nC: SELECT count(*) FROM t_phone WHERE phoneno substr(phoneno,1,3)='321'\n\nD：都一样快**_", "Tag": "算法分析"}
{"Answer": "for (int i = 1; i <=100; i++) {\r\n    int num3 = i % 3;\r\n    int num5 = i %5;\r\n    if (num3 + num5 == 0) {\r\n    } else if (num5 == 0) {\r\n    } else if (num3 == 0) {\r\n    }\r\n}", "Konwledge_Point": "算法与数字", "Question": "实现打印1至100。\n实现打印1到100，遇到数字为3的倍数时打印“three”,5的倍数打印“five\",既是3的倍数又是5的倍数打印”three_five“;\n\n[code=\"java\"]\n\n    public static void main(String[] args) {\n\n        for(int i=1; i< 101;i++){\n\n\n\n        if(i % 3 == 0 ){\n            if( i % 5 == 0 ){\n                System.out.println(\"three&five's mulriple\");\n                continue;\n            }\n            System.out.println(\"three's mulriple\");\n            continue;\n\n        }\n        if(i% 5 == 0){\n            System.out.println(\"five's mulriple\");\n            continue;\n        }\n        System.out.println(i);\n    }\n}\n\n\n\n\n[/code]\n\n有没有更好的算法或思路。", "Tag": "算法分析"}
{"Answer": "算法问题\r\n1.第一个return最后才会调用 由于if条件限制调用完后也不会进入递归 详细请看算法\r\n2.第二个return是函数最后 且函数为void 加不加都一样", "Konwledge_Point": "算法与数字", "Question": "c语言递归调用中要不要return结果都一样\n以下来自啊哈算法这本书，用于输出数字全排列，发现注释掉的return属于多余。这是怎么回事啊？？？\n\n#include \n\nint a[10],book[10],n;\n\nvoid dfs(int step)\n\n{\n\n    int i,j;\n\n    if (step == n+1)\n\n    {\n\n        for ( i = 1; i<=n; i++ )\n\n            printf(\"%d\",a[i]);\n\n     //return;\n\n    }\n\n   for (i = 1; i<=n; i++) \n\n   { \n\n        if (book[i]==0)\n\n        {\n\n                a[step]=i;\n\n            book[i]=1;\n\n            dfs(step+1);\n\n\n\n        book[i]=0;\n    }\n\n\n\n\n}\n\n     //return;\n\n}\n\n\n\nint main()\n\n{\n\n    scanf(\"%d\",&n);\n\n    dfs(1);\n\n    getchar();\n\n    getchar();\n\n    return 0;\n\n}", "Tag": "算法分析"}
{"Answer": "ssss", "Konwledge_Point": "算法与数字", "Question": "快速排序zhe dao ti该怎么做（C++）？\n\ntimu描述\n给出一个数据序列，使用快速排序算法进行从小到大的排序\n\n输入\n第一行输入t，表示有t个测试示例\n第二行输入n，表示第一个示例有n个数据\n第三行输入n个数据，都是正整数，数据之间用空格隔开\n以此类推\n\n输出\n每组测试数据，输出每趟快排的结果，即每次排好一个数字结果（长度为1的子序列，不用排，不用输出）。不同测试数据间用空行分隔。\n\n样例输入\n2\n\n6\n\n111\n 22 \n6\n 444 \n333 55\n\n8\n\n77\n 555 \n33\n 1 \n444\n 77 \n666 2222\n\n样例输出\n55\n 22 \n6\n 111 \n333 444\n\n6\n 22 \n55\n 111 \n333 444\n\n6\n 22 \n55\n 111 \n333 444\n\n6\n 22 \n55\n 111 \n333 444\n\n \n\n1\n 33 \n77\n 555 \n444\n 77 \n666 2222\n\n1\n 33 \n77\n 555 \n444\n 77 \n666 2222\n\n1\n 33 \n77\n 77 \n444\n 555 \n666 2222\n\n1\n 33 \n77\n 77 \n444\n 555 \n666 2222\n\n1\n 33 \n77\n 77 \n444\n 555 \n666 2222\n\n\n\n\n\n\n希望有人能kanyixia。", "Tag": "算法分析"}
{"Answer": "sort,reverse前要有一个对象，应该是vecDouble,即vecDouble.sort和vecDouble.reverse", "Konwledge_Point": "算法与数字", "Question": "编译器报错，求解决办法，\n\n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n//算法\n\n\nusing\n \nnamespace\n std;\n\nint\n \nmain\n()\n\n\n{\n    vector<\ndouble\n>vecDouble = { \n98.5\n,\n67.9\n,\n43.6\n,\n32.9\n };\n    \n//向数组中插入数组\n\n    vecDouble.\npush_back\n(\n100.8\n);\n//在数组的尾部插入一个数字\n\n    \n//遍历\n\n    \nfor\n (\nint\n i = \n0\n; i < vecDouble.\nsize\n(); i++) {\n        cout << vecDouble[i] << endl;\n    }\n    \n//集合的通用遍历方法：使用迭代器 iterator\n\n    \n//以下是迭代器的基本用法\n\n    vector<\ndouble\n>::iterator it;\n//得到迭代器对象:实际上是一个指针对象\n\n    \n//从第一个元素开始迭代\n\n    \n//排序\n\n    \nsort\n(vecDouble.begin, vecDouble.\nend\n());\n    \nreverse\n(vecDouble.begin, vecDouble.\nend\n());\n\n    \nfor\n (it = vecDouble.\nbegin\n(); it != vecDouble.\nend\n(); ++it)\n    {\n        cout << *it << endl;\n    }\n    \n\n\n\n}\n\n\n", "Tag": "算法分析"}
{"Answer": "\npackage com.example.demo1;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.NoSuchPaddingException;\nimport java.io.ByteArrayOutputStream;\nimport java.security.*;\nimport java.security.interfaces.RSAPrivateKey;\nimport java.security.interfaces.RSAPublicKey;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class TestRSA\n{\n    /**\n     * 测试方法\n     */\n    public static void main(String[] args) throws NoSuchPaddingException, NoSuchAlgorithmException {\n        String publicKey = \"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCXGI8/U6r8m8bxrF+nb3ONgEUgcykJyo7ZyrAfzX8pbU/t58p89B5O2+zM2ArKBfX5krnUfdMM4DNhPh6HaR+TIFB6qbNCoaQY2IUP9RfsC/vo0Yyz7hZjrThwy+fLfQxZz5jCnrND4lUfKYk8Zh+SzFIsO4HOnsFiGOTIepyOtQIDAQAB\";\n        String privateKey = \"MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbAgEAAoGBAJcYjz9TqvybxvGsX6dvc42ARSBzKQnKjtnKsB/NfyltT+3nynz0Hk7b7MzYCsoF9fmSudR90wzgM2E+HodpH5MgUHqps0KhpBjYhQ/1F+wL++jRjLPuFmOtOHDL58t9DFnPmMKes0PiVR8piTxmH5LMUiw7gc6ewWIY5Mh6nI61AgMBAAECgYBvjnd89wZAebc6Cd2Z3qS/LZxcKAp9qysrTAYbhPrFGGsyKLgM56RU7vV4DG5y2FHS0W0YoUmosQPeYSHjMk9XizWc4RC5h3KX1FThEJgA/bGmv1kY7zURkCukq4RZRJDTc2LkQM7+ihFDyBt9fruROC48mzzV92V639iSO1tDxQJBANHZZUl5bsXBozRSjMBWc/WghLUvvdmJcsm4fQfYdXNsDYylGRAxi5wludHtzrIL1rpIuYtGh0SxW54Ak7Y71B8CQQC4U1QhW960MtbeWp56HbxDvK3SDRTDvEXIF8+1hAdFPFipaMShci8+y4uz9FiDWYDI0nU0SjEqsVuYQJjITmKrAkBo0TzNcXFKKAl8Fgul+sjbFL2Uvu8GXKhQZ+1T4OPxrjQqX0DgnM7ORO3HFRCcUFuGGtNK5QSl5C0OA93ENagjAkBAllJAbiSXF8lamH43Y/v38EEn/RVtkKcS+eT6QY0aoY6frepYd94+LqyBHfl17QLHW5dd/zFDOGpT6y6d4XmJAkAM1DD/QlzsD23zj+HeCiFY5EqEMvB3evi+yqdZ5J5th1VK4ywfeWwUueWDd3yyJy8sK+4vNmvuQci/zBbKU0+n\";\n\n        String str = \"{\\\"address\\\":\\\"安徽宿州\\\",\\\"authType\\\":\\\"1\\\",\\\"backPhoto\\\":\\\"https://uniubi-aiot.oss-cn-hangzhou.aliyuncs.com/device/84E0F424B99851FA/20210217083909_243_rgb.jpg\\\",\\\"educationCode\\\":\\\"6\\\",\\\"frontPhoto\\\":\\\"https://uniubi-aiot.oss-cn-hangzhou.aliyuncs.com/device/84E0F424B99851FA/20210217083909_243_rgb.jpg\\\",\\\"headImageUrl\\\":\\\"https://uniubi-aiot.oss-cn-hangzhou.aliyuncs.com/device/84E0F424B99851FA/20210217083909_243_rgb.jpg\\\",\\\"idCard\\\":\\\"340881199705260330\\\",\\\"majorHistoryB\\\":false,\\\"nation\\\":\\\"汉族\\\",\\\"personType\\\":\\\"03\\\",\\\"phone\\\":\\\"15988776666\\\",\\\"signOrg\\\":\\\"杭州市上城区公安局\\\",\\\"trueName\\\":\\\"严佳勇\\\",\\\"validityPeriod\\\":\\\"2012010120200101\\\"}\";\n        // 公钥加密，私钥解密\n        String enStr1 = TestRSA.encryptByPublicKey(str, publicKey);\n        System.out.println(\"公钥加密后：\" + enStr1);\n        String deStr1 = TestRSA.decryptByPrivateKey(enStr1, privateKey);\n        System.out.println(\"私钥解密后：\" + deStr1);\n\n        // 产生签名\n        String sign = sign(enStr1, privateKey);\n        System.out.println(\"签名:\" + sign);\n        // 验证签名\n        boolean status = verify(enStr1, publicKey, sign);\n        System.out.println(\"状态:\" + status);\n\n    }\n\n    //定义加密方式\n    public static final String KEY_RSA = \"RSA\";\n    //定义公钥关键词\n    public static final String KEY_RSA_PUBLICKEY = \"RSAPublicKey\";\n    //定义私钥关键词\n    public static final String KEY_RSA_PRIVATEKEY = \"RSAPrivateKey\";\n    //定义签名算法\n    private final static String KEY_RSA_SIGNATURE = \"SHA256WithRSA\";\n    /**\n     * **\n     * RSA最大加密大小\n     */\n    private final static int MAX_ENCRYPT_BLOCK = 117;\n\n    /**\n     * **\n     * RSA最大解密大小\n     */\n    private final static int MAX_DECRYPT_BLOCK = 128;\n\n    /**\n     * 生成公私密钥对\n     */\n    public static Map<String, Object> init()\n    {\n        Map<String, Object> map = null;\n        try\n        {\n            KeyPairGenerator generator = KeyPairGenerator.getInstance(KEY_RSA);\n            //设置密钥对的bit数，越大越安全，但速度减慢，一般使用512或1024\n            generator.initialize(1024);\n            KeyPair keyPair = generator.generateKeyPair();\n            // 获取公钥\n            RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();\n            // 获取私钥\n            RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();\n            // 将密钥对封装为Map\n            map = new HashMap<String, Object>();\n            map.put(KEY_RSA_PUBLICKEY, publicKey);\n            map.put(KEY_RSA_PRIVATEKEY, privateKey);\n        } catch (NoSuchAlgorithmException e)\n        {\n            e.printStackTrace();\n        }\n\n        return map;\n    }\n\n    /**\n     * 获取Base64编码的公钥字符串\n     */\n    public static String getPublicKey(Map<String, Object> map)\n    {\n        String str = \"\";\n        Key key = (Key) map.get(KEY_RSA_PUBLICKEY);\n        str = encryptBase64(key.getEncoded());\n        return str;\n    }\n\n    /**\n     * 获取Base64编码的私钥字符串\n     */\n    public static String getPrivateKey(Map<String, Object> map)\n    {\n        String str = \"\";\n        Key key = (Key) map.get(KEY_RSA_PRIVATEKEY);\n        str = encryptBase64(key.getEncoded());\n        return str;\n    }\n\n    /**\n     * BASE64 解码\n     *\n     * @param key 需要Base64解码的字符串\n     * @return 字节数组\n     */\n    public static byte[] decryptBase64(String key)\n    {\n        return Base64.getDecoder().decode(key);\n    }\n\n    /**\n     * BASE64 编码\n     *\n     * @param key 需要Base64编码的字节数组\n     * @return 字符串\n     */\n    public static String encryptBase64(byte[] key)\n    {\n        return new String(Base64.getEncoder().encode(key));\n    }\n\n    /**\n     * 公钥加密\n     *\n     * @param encryptingStr\n     * @param publicKeyStr\n     * @return\n     */\n    public static String encryptByPublicKey(String encryptingStr, String publicKeyStr)\n    {\n        try\n        {\n            // 将公钥由字符串转为UTF-8格式的字节数组\n            byte[] publicKeyBytes = decryptBase64(publicKeyStr);\n            // 获得公钥\n            X509EncodedKeySpec keySpec = new X509EncodedKeySpec(publicKeyBytes);\n            // 取得待加密数据\n            byte[] data = encryptingStr.getBytes(\"UTF-8\");\n            KeyFactory factory;\n            factory = KeyFactory.getInstance(KEY_RSA);\n            PublicKey publicKey = factory.generatePublic(keySpec);\n            // 对数据加密\n            Cipher cipher = Cipher.getInstance(factory.getAlgorithm());\n            cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n            // 返回加密后由Base64编码的加密信息\n            int inputLen = data.length;\n            ByteArrayOutputStream out = new ByteArrayOutputStream();\n            int offSet = 0;\n            byte[] cache;\n            int i = 0;\n            // 对数据分段解密\n            while (inputLen - offSet > 0)\n            {\n                if (inputLen - offSet > MAX_ENCRYPT_BLOCK)\n                {\n                    cache = cipher.doFinal(data, offSet, MAX_ENCRYPT_BLOCK);\n                } else\n                {\n                    cache = cipher.doFinal(data, offSet, inputLen - offSet);\n                }\n                out.write(cache, 0, cache.length);\n                i++;\n                offSet = i * MAX_ENCRYPT_BLOCK;\n            }\n            byte[] decryptedData = out.toByteArray();\n            out.close();\n            return encryptBase64(decryptedData);\n        } catch (Exception e)\n        {\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n\n    /**\n     * 私钥解密\n     *\n     * @param encryptedStr\n     * @param privateKeyStr\n     * @return\n     */\n    public static String decryptByPrivateKey(String encryptedStr, String privateKeyStr)\n    {\n        try\n        {\n            // 对私钥解密\n            byte[] privateKeyBytes = decryptBase64(privateKeyStr);\n            // 获得私钥\n            PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKeyBytes);\n            // 获得待解密数据\n            byte[] data = decryptBase64(encryptedStr);\n            KeyFactory factory = KeyFactory.getInstance(KEY_RSA);\n            PrivateKey privateKey = factory.generatePrivate(keySpec);\n            // 对数据解密\n            Cipher cipher = Cipher.getInstance(factory.getAlgorithm());\n            cipher.init(Cipher.DECRYPT_MODE, privateKey);\n            // 返回UTF-8编码的解密信息\n            int inputLen = data.length;\n            ByteArrayOutputStream out = new ByteArrayOutputStream();\n            int offSet = 0;\n            byte[] cache;\n            int i = 0;\n            // 对数据分段解密\n            while (inputLen - offSet > 0)\n            {\n                if (inputLen - offSet > MAX_DECRYPT_BLOCK)\n                {\n                    cache = cipher.doFinal(data, offSet, MAX_DECRYPT_BLOCK);\n                } else\n                {\n                    cache = cipher.doFinal(data, offSet, inputLen - offSet);\n                }\n                out.write(cache, 0, cache.length);\n                i++;\n                offSet = i * MAX_DECRYPT_BLOCK;\n            }\n            byte[] decryptedData = out.toByteArray();\n            out.close();\n            return new String(decryptedData, \"UTF-8\");\n        } catch (Exception e)\n        {\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n\n    /**\n     * 私钥加密\n     *\n     * @param encryptingStr\n     * @param privateKeyStr\n     * @return\n     */\n    public static String encryptByPrivateKey(String encryptingStr, String privateKeyStr)\n    {\n        try\n        {\n            byte[] privateKeyBytes = decryptBase64(privateKeyStr);\n            // 获得私钥\n            PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKeyBytes);\n            // 取得待加密数据\n            byte[] data = encryptingStr.getBytes(\"UTF-8\");\n            KeyFactory factory = KeyFactory.getInstance(KEY_RSA);\n            PrivateKey privateKey = factory.generatePrivate(keySpec);\n            // 对数据加密\n            Cipher cipher = Cipher.getInstance(factory.getAlgorithm());\n            cipher.init(Cipher.ENCRYPT_MODE, privateKey);\n            // 返回加密后由Base64编码的加密信息\n            int inputLen = data.length;\n            ByteArrayOutputStream out = new ByteArrayOutputStream();\n            int offSet = 0;\n            byte[] cache;\n            int i = 0;\n            // 对数据分段解密\n            while (inputLen - offSet > 0)\n            {\n                if (inputLen - offSet > MAX_ENCRYPT_BLOCK)\n                {\n                    cache = cipher.doFinal(data, offSet, MAX_ENCRYPT_BLOCK);\n                } else\n                {\n                    cache = cipher.doFinal(data, offSet, inputLen - offSet);\n                }\n                out.write(cache, 0, cache.length);\n                i++;\n                offSet = i * MAX_ENCRYPT_BLOCK;\n            }\n            byte[] decryptedData = out.toByteArray();\n            out.close();\n            return encryptBase64(decryptedData);\n        } catch (Exception e)\n        {\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n\n    /**\n     * 公钥解密\n     *\n     * @param encryptedStr\n     * @param publicKeyStr\n     * @return\n     */\n    public static String decryptByPublicKey(String encryptedStr, String publicKeyStr)\n    {\n        try\n        {\n            // 对公钥解密\n            byte[] publicKeyBytes = decryptBase64(publicKeyStr);\n            // 取得公钥\n            X509EncodedKeySpec keySpec = new X509EncodedKeySpec(publicKeyBytes);\n            // 取得待加密数据\n            byte[] data = decryptBase64(encryptedStr);\n            KeyFactory factory = KeyFactory.getInstance(KEY_RSA);\n            PublicKey publicKey = factory.generatePublic(keySpec);\n            // 对数据解密\n            Cipher cipher = Cipher.getInstance(factory.getAlgorithm());\n            cipher.init(Cipher.DECRYPT_MODE, publicKey);\n            // 返回UTF-8编码的解密信息\n            int inputLen = data.length;\n            ByteArrayOutputStream out = new ByteArrayOutputStream();\n            int offSet = 0;\n            byte[] cache;\n            int i = 0;\n            // 对数据分段解密\n            while (inputLen - offSet > 0)\n            {\n                if (inputLen - offSet > MAX_DECRYPT_BLOCK)\n                {\n                    cache = cipher.doFinal(data, offSet, MAX_DECRYPT_BLOCK);\n                } else\n                {\n                    cache = cipher.doFinal(data, offSet, inputLen - offSet);\n                }\n                out.write(cache, 0, cache.length);\n                i++;\n                offSet = i * MAX_DECRYPT_BLOCK;\n            }\n            byte[] decryptedData = out.toByteArray();\n            out.close();\n            return new String(decryptedData, \"UTF-8\");\n        } catch (Exception e)\n        {\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n\n    /**\n     * 用私钥对加密数据进行签名\n     *\n     * @param encryptedStr\n     * @param privateKey\n     * @return\n     */\n    public static String sign(String encryptedStr, String privateKey)\n    {\n        String str = \"\";\n        try\n        {\n            //将私钥加密数据字符串转换为字节数组\n            byte[] data = encryptedStr.getBytes();\n            // 解密由base64编码的私钥\n            byte[] bytes = decryptBase64(privateKey);\n            // 构造PKCS8EncodedKeySpec对象\n            PKCS8EncodedKeySpec pkcs = new PKCS8EncodedKeySpec(bytes);\n            // 指定的加密算法\n            KeyFactory factory = KeyFactory.getInstance(KEY_RSA);\n            // 取私钥对象\n            PrivateKey key = factory.generatePrivate(pkcs);\n            // 用私钥对信息生成数字签名\n            Signature signature = Signature.getInstance(KEY_RSA_SIGNATURE);\n            signature.initSign(key);\n            signature.update(data);\n            str = encryptBase64(signature.sign());\n        } catch (Exception e)\n        {\n            e.printStackTrace();\n        }\n        return str;\n    }\n\n    /**\n     * 校验数字签名\n     *\n     * @param encryptedStr\n     * @param publicKey\n     * @param sign\n     * @return 校验成功返回true，失败返回false\n     */\n    public static boolean verify(String encryptedStr, String publicKey, String sign)\n    {\n        boolean flag = false;\n        try\n        {\n            //将私钥加密数据字符串转换为字节数组\n            byte[] data = encryptedStr.getBytes();\n            // 解密由base64编码的公钥\n            byte[] bytes = decryptBase64(publicKey);\n            // 构造X509EncodedKeySpec对象\n            X509EncodedKeySpec keySpec = new X509EncodedKeySpec(bytes);\n            // 指定的加密算法\n            KeyFactory factory = KeyFactory.getInstance(KEY_RSA);\n            // 取公钥对象\n            PublicKey key = factory.generatePublic(keySpec);\n            // 用公钥验证数字签名\n            Signature signature = Signature.getInstance(KEY_RSA_SIGNATURE);\n            signature.initVerify(key);\n            signature.update(data);\n            flag = signature.verify(decryptBase64(sign));\n        } catch (Exception e)\n        {\n            e.printStackTrace();\n        }\n        return flag;\n    }\n}\n\n\n加密代码\n\n ", "Konwledge_Point": "算法与数字", "Question": "求助：RSA加密发送http请求失败\n菜鸟求助，这个接口怎样加密，才能发送请求成功，自己搞了半天也没解决。最好把加密代码提供下，感觉不尽！\n\n\n\n接口信息：\n\n\n\n测试接口地址 URL: \nhttp://221.13.13.133:21974\n\n\n\n请求方式：POST\n\n\n\nContent-Type：application/x-www-form-urlencoded\n\n\n\n请求参数：\n\n\n\n  unitCode:软件服务商统一社会信用代码\n\n  projectId:项目ID\n\n  data: 加密后的数据\n\n\n\n数据加密说明：\n\n\n\n接口平台为每个接入平台颁发一个数字证书（一对公私钥），接入平台必须通过数字证书的公钥对上行数据进行RSA加密 后再进行Base64编码后提交。 签名加密规则：\n\n\n\n加密算法RSA密钥位数1024；\n签名算法SHA256WithRSA；\n加解密Cipher算法：RAS/ECB/PKCS1Padding；\n加密原始数据为JSON字符串；\n加密最终为Base64编码数据；字符串统一采用UTF-8编码格式。\n\n\n\n \n\n\n\n测试数据：\n\n\n\nprojectId:1270995441467150337\n\n\n\nunitCode：9133011009519461XC\n\n\n\ndata: {\"address\":\"安徽宿州\",\"authType\":\"1\",\"backPhoto\":\"https://uniubi-aiot.oss-cn-hangzhou.aliyuncs.com/device/84E0F424B99851FA/20210217083909_243_rgb.jpg\",\"educationCode\":\"6\",\"frontPhoto\":\"https://uniubi-aiot.oss-cn-hangzhou.aliyuncs.com/device/84E0F424B99851FA/20210217083909_243_rgb.jpg\",\"headImageUrl\":\"https://uniubi-aiot.oss-cn-hangzhou.aliyuncs.com/device/84E0F424B99851FA/20210217083909_243_rgb.jpg\",\"idCard\":\"340881199705260330\",\"majorHistoryB\":false,\"nation\":\"汉族\",\"personType\":\"03\",\"phone\":\"15988776666\",\"signOrg\":\"杭州市上城区公安局\",\"trueName\":\"严佳勇\",\"validityPeriod\":\"2012010120200101\"}\n\n\n\n公钥：MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCXGI8/U6r8m8bxrF+nb3ONgEUgcykJyo7ZyrAfzX8pbU/t58p89B5O2+zM2ArKBfX5krnUfdMM4DNhPh6HaR+TIFB6qbNCoaQY2IUP9RfsC/vo0Yyz7hZjrThwy+fLfQxZz5jCnrND4lUfKYk8Zh+SzFIsO4HOnsFiGOTIepyOtQIDAQAB\n\n\n\n私钥：MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbAgEAAoGBAJcYjz9TqvybxvGsX6dvc42ARSBzKQnKjtnKsB/NfyltT+3nynz0Hk7b7MzYCsoF9fmSudR90wzgM2E+HodpH5MgUHqps0KhpBjYhQ/1F+wL++jRjLPuFmOtOHDL58t9DFnPmMKes0PiVR8piTxmH5LMUiw7gc6ewWIY5Mh6nI61AgMBAAECgYBvjnd89wZAebc6Cd2Z3qS/LZxcKAp9qysrTAYbhPrFGGsyKLgM56RU7vV4DG5y2FHS0W0YoUmosQPeYSHjMk9XizWc4RC5h3KX1FThEJgA/bGmv1kY7zURkCukq4RZRJDTc2LkQM7+ihFDyBt9fruROC48mzzV92V639iSO1tDxQJBANHZZUl5bsXBozRSjMBWc/WghLUvvdmJcsm4fQfYdXNsDYylGRAxi5wludHtzrIL1rpIuYtGh0SxW54Ak7Y71B8CQQC4U1QhW960MtbeWp56HbxDvK3SDRTDvEXIF8+1hAdFPFipaMShci8+y4uz9FiDWYDI0nU0SjEqsVuYQJjITmKrAkBo0TzNcXFKKAl8Fgul+sjbFL2Uvu8GXKhQZ+1T4OPxrjQqX0DgnM7ORO3HFRCcUFuGGtNK5QSl5C0OA93ENagjAkBAllJAbiSXF8lamH43Y/v38EEn/RVtkKcS+eT6QY0aoY6frepYd94+LqyBHfl17QLHW5dd/zFDOGpT6y6d4XmJAkAM1DD/QlzsD23zj+HeCiFY5EqEMvB3evi+yqdZ5J5th1VK4ywfeWwUueWDd3yyJy8sK+4vNmvuQci/zBbKU0+n\n\n\n\n \n\n\n\n\n\n\n ", "Tag": "算法分析"}
{"Answer": "mvc模式，是吧m和v层写在一起，通过c来处理逻辑关系，简单的页面还好，越大，逻辑越复杂，就会越乱，你可能经常会写出一个上千行的activity，过段时间再去自己都看不懂，mvp是吧m和v分离出来，不直接交互，通过p层实现数据传递显示，大量的m只管模型内容，v只负责显示，p层负责数据传递", "Konwledge_Point": "算法与数字", "Question": "Android 当中的 MVC 和 MVP 究竟是如何区分的？\n最近在看架构方面的资料，对于 MVC 和 MVP 有些搞不明白。\n\n\n\nMVC：\n\nM 层就是用户自己编写的类，页面的逻辑都在这里实现（譬如访问数据库、访问网络、以及各种逻辑操作算法等等），可以总结归纳为 M 层的作用就是“这个页面的功能”\n\nV 层就是各种控件，用来接受用户信息（譬如各种按钮、各种编辑框）和展示信息给用户（类如TextView ImageView 等）\n\nC 层的概念我有些模糊，看一些博客上讲，它是沟通 M 和 V 的桥梁。我有些搞不懂。\n\n\n\n我是这么理解的，我们需要在C 层当中创建 M 层的对象然后调用其相关方法：譬如访问网络方法、存储数据方法，而这些方法所用到的参数就通过V层来获取，同时如果M层有数据返回，那么V层可以直接操作这个返回的数据。\n\n\n\n总感觉哪里不太对，请问大家，我这个理解有问题吗？\n\n\n\nMVP:\n\n在这个模式里，是将Activity或者Fragment作为V层，而将原本 MVC 当中 C 层的沟通逻辑放到了新定义的 P 层当中。\n\n\n\n是这样吗？\n\n\n\n----------大年二十八update--------------\n\n我举个例子，譬如实现一个功能，用户输入一个id（数字），然后匹配数据库当中是否有这个id，如果有，就在页面上显示这个id对象的message，如果没有，就显示没有\n\n\n\n在 MVC 当中\n\nM 层自然有一个 String search(int id)方法，方法体就是通过id去执行查询\n\nV 层就是获取用户输入的id，以及获取用户的点击查询输入，还有显示查询结果\n\nC 层就是 Activity或者Fragment，我们在 Activity当中创建model对象并调用search方法，并且将V层输入的id作为参数传入。\n\n\n\n所谓的M层和V层耦合，就是search方法返回的数据，可以直接调用 V 层的 text.settext(message )来将内容显示出来\n\n\n\n我这么理解有问题吗？", "Tag": "算法分析"}
{"Answer": "（容斥原理）  最好画一个圈圈图更加直观。对于抽象能力差的人比较好！", "Konwledge_Point": "算法与数字", "Question": "又来数学题了。。。请教简单做法\n对某单位的100名员工进行调查，结果发现他们喜欢看球赛和电影、戏剧。\n其中58人喜欢看球赛，38人喜欢看戏剧，52人喜欢看电影，\n既喜欢看球赛又喜欢看戏剧的有18人，既喜欢看电影又喜欢看戏剧的有16人，\n三种都喜欢看的有12人，\n则只喜欢看电影的有（）\nA。22人 B。28人 C。30人 D。36人\n答案是：A。22人\n我想知道这种题的简单算法。\n因贱内对数字方面很弱，所以在这向大家请教了，谢谢各位高手啦。\nps：求 救 怎么不能用呢？", "Tag": "算法分析"}
{"Answer": "先排序，然后深度优先。\nnums = [20375,34665,26925,25060,\n22185,24375,22680,19195,\n19675,9800,10280,20090,\n22070,18765,18810,19180,\n15070,23000,18650,17320,\n21135,22440,18175]\n\ntar = 250430\n\ndef dfs(tar,nums,res):\n    if sum(res)==tar:\n        return res\n    elif len(nums)<1 or sum(res)>tar:\n        return False\n    else:\n        for i in range(len(nums)):\n            temp = dfs(tar,nums[i+1:],res+[nums[i]])\n            if temp: return temp\n            elif temp==False: break\n\nnums = sorted(nums)\nprint(dfs(tar,nums,list()))\n\n结果\n[9800, 10280, 15070, 17320, 18175, 18650, 18765, 19180, 20090, 20375, 21135, 26925, 34665]\n\n要找出所有的解，只要稍微改一下：\ndef dfs(tar,nums,res):\n    if sum(res)==tar:\n        all_res.append(res)\n    elif len(nums)<1 or sum(res)>tar:\n        return False\n    else:\n        for i in range(len(nums)):\n            temp = dfs(tar,nums[i+1:],res+[nums[i]])\n            if temp==False: break\n\nnums = sorted(nums)\nall_res=[]\ndfs(tar,nums,list())\nprint(len(all_res))\nprint(sorted(all_res,key=len)[0])\n\n可以看到总共有323种解，n最少的解是\n323\n[15070, 18175, 18765, 20090, 22185, 22440, 22680, 24375, 25060, 26925, 34665]\n", "Konwledge_Point": "算法与数字", "Question": "从23个已知数中取n个数，n个数之和是250430，求是哪几个数之和\n一共有23个已知数字，然后里面n个数之和是250430，n未知，现在需要知道是由哪几个数字组成了250430这个总数，只需要这个结果就行了，最好把代码也能给我，编程语言不限。证明不存在这个可能的话也可以。\n23个已知数字：\n20375\n34665\n26925\n25060\n22185\n24375\n22680\n19195\n19675\n9800\n10280\n20090\n22070\n18765\n18810\n19180\n15070\n23000\n18650\n17320\n21135\n22440\n18175", "Tag": "算法分析"}
{"Answer": "while后面多了一个分号，需要把它删了\n\n存到字符串数组时，要加上'0'\n\n临时变量应该是char类型，而不是char*类型\n\n完整代码：\n\n/*（3）数字字符与整数转换算法：将字符串“#b78c15fk23d*”中整型数据提取出来，合成一个整型数781523并输出来。再将781523整数的各个数位数字拆开存放到一维数组int b[10]中，将一维数组中的元素转换为字符数组s[100]中，输出该数字字符串“325187”。*/\n#include <iostream>\n#include <string>\nusing namespace std;\nvoid show_string(char t[200])//输出字符串\n{\n    cout << t << endl;\n}\nint tiqu(char t[200], int len)\n{\n    int j = 0;\n    for (int i = 0; i < len; i++)\n    {\n        if (t[i] >= '0' && t[i] < '9')\n        {\n            j = j * 10 + t[i] - '0';\n        }\n    }\n    return j;\n}\nint store_int(int z, int o[10])\n{\n    int m = z;//防止z数据丢失\n    int n = 0;//记录m的位数\n    while (m) { m /= 10; n++; }\n    for (int i = n - 1; i >= 0; i--)\n    {\n\n        o[i] = z % 10;\n        z = z / 10;\n    }\n    return n;\n}\nvoid show_int(int q[], int len)\n{\n    for (int i = 0; i < len; i++)\n    {\n        cout << q[i];\n    }\n    cout << endl;\n}\nvoid store_string(int t[10], int len, char s[100])\n{\n    for (int i = 0; i < len; i++)\n    {\n        s[i] = (char)t[i] + '0';//将t中元素储存到s中\n    }\n    char* p1 = &s[0];//z指向s[0]的位置\n    char* p2 = &s[len - 1];//z指向s[len-1]的位置\n    while (p1 < p2)\n    {\n        char t = 0;\n        t = *p1;\n        *p1 = *p2;\n        *p2 = t;\n        p1++;\n        p2--;\n    }\n    cout << s << endl;\n}\n\nint main()\n{\n    char d[200] = { \"#78c15fk23d\" };\n    show_string(d);\n    int j = strlen(d);//计算字符串长度\n    int k = tiqu(d, j);//提取出781523\n    cout << k << endl;\n    int b[10];\n    int c = store_int(k, b);//返回k的位数\n    show_int(b, c);\n    char s[100] = { 0 };\n    store_string(b, c, s);\n    show_string(s);\n    return 0;\n}\n", "Konwledge_Point": "算法与数字", "Question": "达不到第三个效果，问题在哪，325187没有输出\n\n\n\n\n/*（3）数字字符与整数转换算法：将字符串“#b78c15fk23d*”中整型数据提取出来，合成一个整型数781523并输出来。再将781523整数的各个数位数字拆开存放到一维数组int b[10]中，将一维数组中的元素转换为字符数组s[100]中，输出该数字字符串“325187”。*/\n\n#\ninclude\n \n#\ninclude\n <\nstring\n>\nusing namespace std;\nvoid show\n_string(\nchar\n \nt\n[200])\n//输出字符串\n\n{\n    cout << t << endl;\n}\n\nint\n tiqu(\nchar\n t\n[\n200\n]\n, \nint\n len)\n{\n    \nint\n j = \n0\n;\n    \nfor\n (\nint\n i = \n0\n; i < len; i++)\n    {\n        \nif\n (t\n[\ni\n]\n >= \n'0'\n && \nt\n[\ni\n]\n < \n'9'\n)\n        {\n            j = j\n * \n10\n + t\n[\ni\n]\n - \n'0'\n;\n        }\n    }\n    return j;\n}\n\nint\n store\n_int(\nint\n \nz\n,\nint\n \no\n[10])\n\n{\n    \nint\n m = z;\n//防止z数据丢失\n\n    \nint\n n = \n0\n;\n//记录m的位数\n\n    \nwhile\n (m) { m /= \n10\n; n++; }\n    \nfor\n (\nint\n i = n-\n1\n; i >=\n0\n; i--)\n    {\n        \n        o\n[\ni\n]\n = z%\n10\n;\n        z = z\n / \n10\n;\n    }\n    return n;\n}\nvoid show\n_int(\nint\n \nq\n[],\nint\n \nlen\n)\n\n{\n    \nfor\n (\nint\n i = \n0\n; i < len; i++)\n    {\n        cout << q\n[\ni\n]\n;\n    }\n}\nvoid store\n_string(\nint\n \nt\n[10],\nint\n \nlen\n, \nchar\n \ns\n[100])\n\n{\n    \nfor\n (\nint\n i = \n0\n; i < len; i++)\n    {\n        s\n[\ni\n]\n = (\nchar\n)t\n[\ni\n]\n;\n//将t中元素储存到s中\n\n    }\n    \nchar\n* p1 = &s\n[\n0\n]\n;\n//z指向s[0]的位置\n\n    \nchar\n* p2 = &s\n[\nlen\n-\n1\n]\n;\n//z指向s[len-1]的位置\n\n    \nwhile\n (p1 < p2);\n    {\n        \nchar\n *t = \n0\n;\n        *t = *p1;\n        *p1 = *p2;\n        *p2 = *t;\n        p1++;\n        p2--;\n    }\n    cout << s;\n}\n\n\nint\n main\n()\n\n{\n    \nchar\n d\n[\n200\n]\n = { \n\"#78c15fk23d\"\n };\n    show\n_string(\nd\n)\n;\n    \nint\n j = strlen(d);\n//计算字符串长度\n\n    \nint\n k = tiqu(d, j);\n//提取出781523\n\n    cout << k << endl;\n    \nint\n b\n[\n10\n]\n;\n    \nint\n c=store\n_int(\nk\n, \nb\n)\n;\n//返回k的位数\n\n    show\n_int(\nb\n,\nc\n)\n;\n    \nchar\n s\n[\n100\n]\n;\n    store\n_string(\nb\n, \nc\n, \ns\n)\n;\n    show\n_string(\ns\n)\n;\n    return \n0\n;\n", "Tag": "算法分析"}
{"Answer": "#include<cstdlib>\n#include <cstdio>\n#include <iostream>\nusing namespace std;\nint* array(int numsSize);\nint singleNumber(int* nums, int numsSize);\n int main()\n {\n     int numsSize;\n    scanf(\"%d\",&numsSize); \n    int* nums; \n    nums = array(numsSize);\n    int single  = 0;\n    single = singleNumber(nums,numsSize);\n    printf(\"只出现一次的是：%d\",single);\n    free(nums);\n    return 0;\n  } \n  int singleNumber(int* nums, int numsSize){\n    int ans = 0;\n    for(int i = 0; i < numsSize; i++){\n        ans ^= nums[i];//debug运行到这一步出错Segmentation Fault**\n    }\n    return ans;\n}\nint* array(int numsSize)//返回一个动态数组 \n {\n     int* p = (int*)malloc(sizeof(int)*numsSize);\n    if (p == NULL)\n    {\n        printf(\"未申请到内存\");\n        return 0;\n    }\n     for(int i = 0;i <numsSize;i++)\n     {\n         scanf(\"%d\",&p[i]);\n    }\n    return p;\n}\n\n", "Konwledge_Point": "算法与数字", "Question": "代码异或运算部分运行出错，编译没有问题\n题设是寻找数组中只出现一次的数，其他数字均出现两次（力扣初级算法的题）\n\n\n代码如下\n\n\n#include\n\n\nint\n* \narray\n(\nint\n numsSize);\n\nint\n singleNumber(\nint\n* nums, \nint\n numsSize);\n \nint\n main()\n {\n     \nint\n numsSize;\n    scanf(\"%d\",&numsSize); \n    \nint\n* nums; \n    nums = \narray\n(numsSize);\n    \nint\n single  = \n0\n;\n    single = singleNumber(nums,numsSize);\n    printf(\"只出现一次的是：%d\",single);\n    free(nums);\n    \nreturn\n \n0\n;\n  } \n  \nint\n singleNumber(\nint\n* nums, \nint\n numsSize){\n    \nint\n ans = \n0\n;\n    \nfor\n(\nint\n i = \n0\n; i < numsSize; i++){\n        ans ^= nums[i];**//\ndebug\n运行到这一步出错Segmentation Fault**\n    }\n    \nreturn\n ans;\n}\n\nint\n* \narray\n(\nint\n numsSize)//返回一个动态数组 \n {\n     \nint\n* p = (\nint\n*)malloc(sizeof(\nint\n)*numsSize);\n    \nif\n (p == \nNULL\n)\n    {\n        printf(\"未申请到内存\");\n        \nreturn\n \n0\n;\n    }\n     \nfor\n(\nint\n i = \n0\n;i <numsSize;i++)\n     {\n         scanf(\"%d\",&p[i]);\n    }\n}\n\n", "Tag": "算法分析"}
{"Answer": "以后还是多多自己动手做做吧，这训练的就是基础，我也是半个新手，写一个给你：\n\n# 问题1\ndef question_1(num_float):\n    return round(num_float)  # python自带化整函数\n\n\n# 问题2\ndef question_2(year_num):  # 问题二求的是第二年水獭的数量\n    if year_num < 100000:\n        return question_1(year_num * 1.784)\n    elif year_num >= 100000:\n        return question_1(year_num * 1.24)\n\n\n# 问题3（a） 求的是n年后水獭的数量\ndef predictV1(time, number):\n    final_num = number\n    if time > 0:\n        for i in range(time):\n            final_num = question_2(final_num)\n    return final_num\n\n\n# 问题3（b）根据参数显示水獭数量变化情况，并返回水獭最终的数量\ndef previsionV2(time, number, display, intyear):\n    final_num = number\n    if display:\n        print(intyear, ':', final_num)\n    if time > 0:\n        for i in range(time):\n            final_num = question_2(final_num)\n            if display:\n                print(intyear + i + 1, ':', final_num)\n    return final_num\n\n\n# 问题4 计算水獭数量到达阈值的年份\ndef question_4(threshold, nbInit, yearInit):\n    time_spent = 0\n    num = nbInit\n    while True:\n        if num >= threshold:\n            return yearInit + time_spent\n        num = question_2(num)\n        time_spent += 1\n\n\nif __name__ == '__main__':\n    final_num_1 = predictV1(3, 40000)\n    print('predictV1 final number is:', final_num_1)\n\n    print()\n    final_num_2 = previsionV2(3, 40000, True, 2020)\n    print('predictV2 final number is:', final_num_2)\n\n    print()\n    year = question_4(157859,40000,2020)\n    print('Ending year is', year)\n\n ", "Konwledge_Point": "算法与数字", "Question": "新人，求大佬帮忙解答\n本练习的目的是为预测水獭数量提供算法。爱丽丝和鲍勃（Alice and Bob）估计，当水獭的数量不太多时，水獭的数量每年将增长78.4％。然而，一旦水獭数量达到100,000人，各种因素就会导致繁殖减慢和更高的死亡率。因此，当水獭种群中至少有100,000人时，一年内仅增加24％。\n\n\n\n注意：除非另有明确说明，否则对于每个问题，您都可以调用先前问题中要求的功能（即使您自己不知道如何编写它们）。\n\n\n\n问题1：\n编写一个舍入函数，将浮点数x（假定为正数或零）作为参数，并返回最接近x的整数。如果X恰恰是在两个整数之间的中间，我们会总结（例如： 倒圆（16.5）是等于到17）。我们假定有一个地板函数它接受一个浮子作为参数并返回其下部的整数部分（例如： 地板（16.9）是等于以16）。（因此，您可以在不重写的情况下呼叫发言权）。\n\n\n\n问题2：\n编写以下函数，将某个种群中的水獭数量作为参数，并返回第二年该种群中的水獭数量。该数字必须是整数（因为我们不能有水獭的非整数分数），因此我们将四舍五入到最接近的整数。\n\n\n\n问题3：\n\n\n\na）编写一个函数predictV1，该函数将数年以及水獭初始种群中包含的水獭数量作为参数。然后，您的函数将返回所需年限后水獭的数量。请注意，如果所需的年数等于0，则您的函数应该起作用，并且在这种情况下，将返回初始种群中水獭的数量。\n\n例如：  previsionV1（3，40,000 ）将返回157,859，即3年后从40,000只水獭开始的水獭数量。\n\nprevisionV1（0，45000）将返回45000。\n\n\n\nb）编写一个函数previsionV2，该函数将年份，初始水獭种群中包含的水獭数量，显示的布尔值和整数yearInit作为参数。如果display为false，则该功能将与previsionV1完全相同。但是，如果显示为True，则除了intyear是学习的第一年之外，除了在要求的年限之后返回水獭的数量外，它还将显示每年的相应水獭数量。\n\n我们添加了一个附加约束：您的函数previsionV2不得调用previsionV1，这只是一个教育性的中间步骤，可帮助您编写previsionV2。\n\n注意，请注意使最优雅/分解的算法成为可能。\n\n\n\n示例：  previsionV2（3，40000，True，2020）将显示：\n\n\n\n\n2020：40,000 \n2021：71360 \n2022：127306 \n2023：157859\n\n\n\n并将返回157859。\n\n\n\n问题4：\n写一个函数会达到其把参数作为一个门槛整数，整数nbInit对应于初始种群水獭的数量，和一个整数yearInit对应研究的第一年，其将返回一年水獭的数量将达到或超过指定的阈值。\n\n请注意：乍一看，使用上一个问题中编写的预测功能似乎与您有关。但是，如果您采用这种策略，则由于重复该算法，很有可能导致过多的不必要的计算。我们将在三月至四月的有关复杂性的章节中更详细地介绍这一点。\n\n\n\n示例：将\n\n达到（40,000，45,000，2020）的价值是2020年，因为我们要通过在2020年从45,000獭开始达到40,000水獭的阈值。将\n\n达到（120,000，40,000，2020）的价值是2022年，因为我们要达到120,000只水獭，2020年为40,000只水獭。将\n\n达到（157859，40,000，2020）是2023年将达到（100,000，40,000，2010", "Tag": "算法分析"}
{"Answer": "一、步骤\n1、实现一个链表翻转；\n2、实现两个链表相对位置的相加操作；\n3、考虑进位；\n二、源码\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\n/*\nl1 -> l2 -> l3 -> l4 -> l5\n\n       |    |\n      pre  now\n*/\n\nstruct ListNode* reverseList(struct ListNode *l) {\n    struct ListNode *pre = l, *now = l->next;\n    struct ListNode *head = l;\n    while(now) {\n        pre->next = now->next;       // (1) 将 now 从链表中剥离出来；\n        now->next = head;            // (2) 将 now 插入到之前的链表头之前；\n        head = now;                  // (3) 让 now 成为新的链表头；\n        \n        now = pre->next;             // (4) now 也前进一格；\n    }\n    return head;\n}\n\nstruct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){\n    struct ListNode *l3 = NULL, *head, *tmp;\n    int a, b, c, cap = 0;\n\n    // l1 -> l2 上去\n    while(l1 || l2 || cap) {\n        a = l1 ? l1->val : 0;\n        b = l2 ? l2->val : 0;\n        c = a + b + cap;\n        tmp = (struct ListNode *)malloc(sizeof(struct ListNode));\n        tmp->val = c % 10;\n        tmp->next = l3;\n        cap = c / 10;\n\n        l3 = tmp;\n        head = l3;\n        \n        if(l1) {\n            l1 = l1->next;\n        }\n        if(l2) {\n            l2 = l2->next;\n        }\n    }\n\n\n\n    return reverseList(head);\n}\n", "Konwledge_Point": "算法与数字", "Question": "请你将两个数相加，并以相同形式返回一个表示和的链表。\n给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\n\n\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n\n\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n\n\n      \n        \n力扣\n\n        \n      \n\n      \n\n      \n\n        \n\n          \nhttps://leetcode-cn.com/problems/add-two-numbers/\n\n        \n\n      ", "Tag": "算法分析"}
{"Answer": "_int64 n=0;bool p=1;\ncin>>n;\nwhile(n)if(n%10==7||n%10==4)n/=10;else n=p=0;\ncout<<p<<endl;\n", "Konwledge_Point": "算法与数字", "Question": "jzoj9248: 幸运数\n题目描述\n4 和 7 是味味的幸运数字。幸运数是那些只由幸运数字组成的正整数。如 47，477 是幸运数，\n而 5，17，417 就不是幸运数。", "Tag": "算法分析"}
{"Answer": "使用一个while循环把scanf()读取后遗留在缓冲区的其他字符读走即可，修改如下:参考链接：\n\n\n\n\n\n         https://blog.csdn.net/haoshaokang_/article/details/121593252\n        \n\n \n#include \"stdio.h\"\n#include \"stdlib.h\"\n \nenum color {red,yellow,green,};\nvoid f(enum color c){\n    printf(\"%d\\n\", c);\n}\n \nint main(){\n    enum color t = red;\n    int i;\n    \n    /* recont: */\n    while( !(scanf(\"%d\", &t)) || (t < 0 || t>2 ) ){\n        printf(\"输入错误，必须输入数字0 <= x <= 2\\n\\n\");\n        // https://blog.csdn.net/haoshaokang_/article/details/121593252\n        while(getchar()!='\\n') // 把scanf()读取后遗留在缓冲区的其他字符读走即可\n            continue;\n         \n    }\n    f(t);\n    /*     //是否继续\n    printf(\"输入1继续:\");\n    scanf(\"%d\", &i);\n    if (i == 1){\n        goto recont;\n    } */\n \n    system(\"pause\");\n    return 0;\n}\n\n\n", "Konwledge_Point": "算法与数字", "Question": "有关于scanf防止错误输入的值。\n一个我不太能理解的地方：我的程序以下：\n\n\n\n\n#\ninclude\n \n\"stdio.h\"\n\n\n#\ninclude\n \n\"stdlib.h\"\n\n\n\nenum\n \ncolor\n {red,yellow,green,};\n\nvoid\n \nf\n(\nenum\n color c)\n{\n    \nprintf\n(\n\"%d\\n\"\n, c);\n}\n\n\nint\n \nmain\n()\n{\n    \nenum\n \ncolor\n t = red;\n    \nint\n i;\n    \n    \n/* recont: */\n\n    \nwhile\n( !(\nscanf\n(\n\"%d\"\n, &t)) || (t < \n0\n || t>\n2\n ) ){\n        \nprintf\n(\n\"输入错误，必须输入数字0 <= x <= 2\\n\\n\"\n);\n        \nif\n ( !(\nscanf\n(\n\"%d\"\n, &t))){\n            \nscanf\n(\n\"%*s\"\n);\n        }\n    }\n    \nf\n(t);\n    \n/*     //是否继续\n    printf(\"输入1继续:\");\n    scanf(\"%d\", &i);\n    if (i == 1){\n        goto recont;\n    } */\n\n\n    \nsystem\n(\n\"pause\"\n);\n    \nreturn\n \n0\n;\n}\n\n\n\n为了防止输入超出预期的数字，我用\n\n\n  while( !(\nscanf\n(\n\"%d\"\n, \n&t\n)) || (\nt\n < \n0\n || \nt\n>2 ) )\n\n\n\n\n来做这件事情，\n理论上来说无论输入什么，只要输入的不是0~2之间的某个整数，都会输出“输入错误，必须输入数字0 <= x <= 2\\n\\n”\n但是，很奇怪\n\n\n1111\n//\n输入\n输入错误，必须输入数字\n0\n <= x <= \n2\n\n\n\n7979\n//\n输入\n\n32\n//\n输入\n输入错误，必须输入数字\n0\n <= x <= \n2\n\n\nred\n//\n输入\n\n\nred\n//\n输入\n输入错误，必须输入数字\n0\n <= x <= \n2\n\n\n\n1\n//\n输入\n\n1\n\n请按任意键继续. . .\n\n\n\n\n这就是问题，只要我上一个输入是数字，我就需要随便输入一个值才能输入下一个值，\n只有输入的是一个字符串的时候（“例如‘red‘’”），才能直接开始输入下一个值。\n如何解决这一问题呢，我想达到输入错误的值之后打印“输入错误，必须输入数字0 <= x <= 2\\n\\n”之后立马开始下一次输出而不是输入一个值给不知道什么地方才能开始下一次输出。", "Tag": "算法分析"}
{"Answer": "我想到可以用导数的方法把差值拉大，然后可以划分2种方法如下，一阶和二阶导数（这也就要求至少有2个以上的数）想法：\n\"\"\"\n# 一、示例：原始数据\nnum_list = [393, 393, 394, 394, 394, 423, 424, 424, 425, 425, 454, 454, 454, 454, 456]\n\n# 二、示例：分组结果\npart_1 = [393, 393, 394, 394, 394]\npart_2 = [423, 424, 424, 425, 425]\npart_3 = [454, 454, 454, 454, 456]\n\n依次顺序：原来式子：，一阶导数，二阶导数，正则化二阶导数再提取变化最大特征的二阶导数，还原一阶导数\n[393, 393, 394, 394, 394, 423, 424, 424, 425, 425, 454, 454, 454, 454, 456]\n    [0, -1,   0,   0,   -29,  -1,  0,  -1,  0,  -29,   0,  0,    0,  -2]    \n      [1,  -1,  0,  29,   -28,  -1,  1,  -1,  29,  -29, 0, 0, 2]\n      [0,  0,   0,   1,    1,    0,   0,   0,   1,  1,  0,  0, 0]\n    [0,  0,   0,   0,   1,     0,    0,    0,  0,   1,  0,  0, 0,  0]  \n [0， 0,   0,   0,   0,    1,     0,    0,   0,  0,   1,  0,  0, 0, 0]  这个可以代表分界线  \n\"\"\"\n\n\n一阶导数\n\nnum_list = [0, 394, 454, 456]  # 3个起步\n# 前向递推法\nfirstD = [num_list[i] - num_list[i + 1] for i in range(len(num_list) - 1)]  # 一阶导数\ntmpFirstD = [abs(item) for item in firstD]\n\nminValue = np.min(tmpFirstD)\nmaxValue = np.max(tmpFirstD)\nnewFirstD = [0] + [int(round((item - minValue) / (maxValue - minValue))) for item in tmpFirstD] \nnewFirstDLen = len(newFirstD)\n# 一阶 =》 原式\nres = []\nfor i in range(newFirstDLen):\n    if i == 0:\n        res.append([num_list[i]])\n    elif newFirstD[i] == 0:\n        res[len(res) - 1].append(num_list[i])\n    elif newFirstD[i] == 1:\n        res.append([num_list[i]])\nprint(res)\n\n二阶求导\nnum_list = [393, 393, 394, 394, 394, 423, 424, 424, 425, 425, 454, 454, 454, 454, 456]  # 4个起步\nfirstD = [num_list[i] - num_list[i + 1] for i in range(len(num_list) - 1)]  # 一阶导数\ntmpFirstD = [abs(item) for item in firstD]\n\nsecondD = [firstD[i] - firstD[i + 1] for i in range(len(firstD) - 1)]  # 二阶导数\ntmpSecondD = [abs(item) for item in secondD]\n\n\nminValue = np.min(tmpSecondD)\nmaxValue = np.max(tmpSecondD)\ntmpSecondD = [int(round((item - minValue) / (maxValue - minValue))) for item in tmpSecondD]\ntmpSecondDLen = len(tmpSecondD)\n\n# 二阶 =》 一阶\ni = 0\nwhile i < tmpSecondDLen:\n    if tmpSecondD[i] == 1 and i < tmpSecondDLen - 1 and tmpSecondD[i + 1] == 1:\n        tmpSecondD[i] = 0\n        i += 2\n    else:\n        i += 1\n\nnewFirstD = [0] + tmpSecondD + [0]  \nnewFirstDLen = len(newFirstD)\n\n# 一阶 =》 原式\nres = []\nfor i in range(newFirstDLen):\n    if i == 0:\n        res.append([num_list[i]])\n    elif newFirstD[i] == 0:\n        res[len(res) - 1].append(num_list[i])\n    elif newFirstD[i] == 1:\n        res.append([num_list[i]])\nprint(res)\n\n\n其他案例：如果个数不多就用1阶\n\n\n", "Konwledge_Point": "算法与数字", "Question": "【python】给定数组，按相邻元素差额分组\n\n\n# 一、示例：原始数据\n\n\nnum_list\n = [\n393\n, \n393\n, \n394\n, \n394\n, \n394\n, \n423\n, \n424\n, \n424\n, \n425\n, \n425\n, \n454\n, \n454\n, \n454\n, \n454\n, \n456\n]\n\n\n\n# 二、示例：分组结果\n\n\npart_1\n = [\n393\n, \n393\n, \n394\n, \n394\n, \n394\n]\n\npart_2\n = [\n423\n, \n424\n, \n424\n, \n425\n, \n425\n]\n\npart_3\n = [\n454\n, \n454\n, \n454\n, \n454\n, \n456\n]\n\n\n\n# 三、数组说明\n\n\n# 1、确定的事项\n\n\n#   1-1 给定的列表，已按由小到大排列好；\n\n\n#   1-2【同组相邻数字的差额】一定明显大于【两组间相领数字的差额】。以上述案例为例：【同组相邻数字的差额】小于3，【两组间相领数字的差额】远大于3;\n\n\n# 2、不确定事项\n\n\n#   2-1 列表元素总个数不确定；\n\n\n#   2-2 可拆分成几组不确定；可能拆分成4-5组\n\n\n#   2-3 每组元素的个数不确定；可能是案例中的5个，也可能是8-10个\n\n\n#   2-4 【同组相邻数字的差额】不一定小于3，比如可能出现[1,5,7,21,25,29]这种场景\n\n\n\n\n# 请问如何使用python实现，或提供拆分思路也可以，谢谢\n\n", "Tag": "算法分析"}
{"Answer": "package com;\r\n\r\nimport java.util.Random;\r\n  \r\npublic class ShuDu {  \r\n    /** 存储数字的数组 */  \r\n    private static int[][] n = new int[9][9];  \r\n    /** 生成随机数字的源数组，随机数字从该数组中产生 */  \r\n    private static int[] num = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };  \r\n  \r\n    public static int[][] generateShuDu(){  \r\n        // 生成数字  \r\n        for (int i = 0; i < 9; i++) {  \r\n            // 尝试填充的数字次数  \r\n            int time = 0;  \r\n            // 填充数字  \r\n            for (int j = 0; j < 9; j++) {  \r\n                // 产生数字  \r\n                n[i][j] = generateNum(time);  \r\n                // 如果返回值为0，则代表卡住，退回处理  \r\n                // 退回处理的原则是：如果不是第一列，则先倒退到前一列，否则倒退到前一行的最后一列  \r\n                if (n[i][j] == 0) {  \r\n                    // 不是第一列，则倒退一列  \r\n                    if (j > 0) {  \r\n                        j -= 2;  \r\n                        continue;  \r\n                    } else {// 是第一列，则倒退到上一行的最后一列  \r\n                        i--;  \r\n                        j = 8;  \r\n                        continue;  \r\n                    }  \r\n                }  \r\n                // 填充成功  \r\n                if (isCorret(i, j)) {  \r\n                    // 初始化time，为下一次填充做准备  \r\n                    time = 0;  \r\n                } else { // 继续填充  \r\n                    // 次数增加1  \r\n                    time++;  \r\n                    // 继续填充当前格  \r\n                    j--;  \r\n                }  \r\n            }  \r\n        }  \r\n        return n;  \r\n    }  \r\n  \r\n    /** \r\n     * 是否满足行、列和3X3区域不重复的要求 \r\n     *  \r\n     * @param row \r\n     *            行号 \r\n     * @param col \r\n     *            列号 \r\n     * @return true代表符合要求 \r\n     */  \r\n    private static boolean isCorret(int row, int col) {  \r\n        return (checkRow(row) & checkLine(col) & checkNine(row, col));  \r\n    }  \r\n  \r\n    /** \r\n     * 检查行是否符合要求 \r\n     *  \r\n     * @param row \r\n     *            检查的行号 \r\n     * @return true代表符合要求 \r\n     */  \r\n    private static boolean checkRow(int row) {  \r\n        for (int j = 0; j < 8; j++) {  \r\n            if (n[row][j] == 0) {  \r\n                continue;  \r\n            }  \r\n            for (int k = j + 1; k < 9; k++) {  \r\n                if (n[row][j] == n[row][k]) {  \r\n                    return false;  \r\n                }  \r\n            }  \r\n        }  \r\n        return true;  \r\n    }  \r\n  \r\n    /** \r\n     * 检查列是否符合要求 \r\n     *  \r\n     * @param col \r\n     *            检查的列号 \r\n     * @return true代表符合要求 \r\n     */  \r\n    private static boolean checkLine(int col) {  \r\n        for (int j = 0; j < 8; j++) {  \r\n            if (n[j][col] == 0) {  \r\n                continue;  \r\n            }  \r\n            for (int k = j + 1; k < 9; k++) {  \r\n                if (n[j][col] == n[k][col]) {  \r\n                    return false;  \r\n                }  \r\n            }  \r\n        }  \r\n        return true;  \r\n    }  \r\n  \r\n    /** \r\n     * 检查3X3区域是否符合要求 \r\n     *  \r\n     * @param row \r\n     *            检查的行号 \r\n     * @param col \r\n     *            检查的列号 \r\n     * @return true代表符合要求 \r\n     */  \r\n    private static boolean checkNine(int row, int col) {  \r\n        // 获得左上角的坐标  \r\n        int j = row / 3 * 3;  \r\n        int k = col / 3 * 3;  \r\n        // 循环比较  \r\n        for (int i = 0; i < 8; i++) {  \r\n            if (n[j + i / 3][k + i % 3] == 0) {  \r\n                continue;  \r\n            }  \r\n            for (int m = i + 1; m < 9; m++) {  \r\n                if (n[j + i / 3][k + i % 3] == n[j + m / 3][k + m % 3]) {  \r\n                    return false;  \r\n                }  \r\n            }  \r\n        }  \r\n        return true;  \r\n    }  \r\n  \r\n    /** \r\n     * 产生1-9之间的随机数字 规则：生成的随机数字放置在数组8-time下标的位置，随着time的增加，已经尝试过的数字将不会在取到 \r\n     * 说明：即第一次次是从所有数字中随机，第二次时从前八个数字中随机，依次类推， 这样既保证随机，也不会再重复取已经不符合要求的数字，提高程序的效率 \r\n     * 这个规则是本算法的核心 \r\n     *  \r\n     * @param time \r\n     *            填充的次数，0代表第一次填充 \r\n     * @return \r\n     */  \r\n    private static Random r=new Random();  \r\n    private static int generateNum(int time) {  \r\n        // 第一次尝试时，初始化随机数字源数组  \r\n        if (time == 0) {  \r\n            for (int i = 0; i < 9; i++) {  \r\n                num[i] = i + 1;  \r\n            }  \r\n        }  \r\n        // 第10次填充，表明该位置已经卡住，则返回0，由主程序处理退回  \r\n        if (time == 9) {  \r\n            return 0;  \r\n        }  \r\n        // 不是第一次填充  \r\n        // 生成随机数字，该数字是数组的下标，取数组num中该下标对应的数字为随机数字  \r\n//      int ranNum = (int) (Math.random() * (9 - time));//j2se  \r\n        int ranNum=r.nextInt(9 - time);//j2me  \r\n        // 把数字放置在数组倒数第time个位置，  \r\n        int temp = num[8 - time];  \r\n        num[8 - time] = num[ranNum];  \r\n        num[ranNum] = temp;  \r\n        // 返回数字  \r\n        return num[8 - time];  \r\n    }  \r\n      \r\n    public static void main(String[] args) {  \r\n        int[][] shuDu=generateShuDu();  \r\n        // 输出结果  \r\n        for (int i = 0; i < 9; i++) {  \r\n            for (int j = 0; j < 9; j++) {  \r\n                System.out.print(shuDu[i][j] + \" \");  \r\n            }  \r\n            System.out.println();  \r\n        }  \r\n    }  \r\n}", "Konwledge_Point": "算法与数字", "Question": "java 菜鸟求助 求各路大神指教 九宫格如何填数？ 需求如下\n/**\n\n\n\n\n\n打印一个 9*9 的九宫格\n\n\n必须满足一下两个条件\n\n\n条件1： 任意一行或者一列都满足9个不同的数字\n\n\n条件2： 任意一个小9格正方形都满足9个不同的数字\n\n\n思想： 通过设定满足条件 无限次循环生成任意数字的矩阵 直到满足后跳出循环\n\n\n结果失败\n\n\n\n\n*/\n\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "1. 7次\r\n2. 45 64 4 35 25 55 82 89 29 10 15", "Konwledge_Point": "算法与数字", "Question": "数据结构问题求大神回答呀！！！小弟感激不尽！（可以分开了回答不用一次回答完）\n1.对于键值序列{38,73,52,15,64,40,48,55,26,12}，用筛选法建最小值堆，共交换元素多少次？ \n\n\n\n2.从空二叉树开始，严格按照二叉搜索树的插入算法（不进行旋转平衡），逐个插入关键码{15, 82, 10, 4, 55, 89, 29, 45, 54, 35, 25}构造出一颗二叉搜索树，对该二叉搜索树按照后序遍历得到的序列为（元素与元素之间用一个空格隔开）\n\n\n\n3.对于以下等价类，采用“加权合并规则”（也 称“重量权衡合并规则”），进行并查运算，给出最后父结点索引序列。\n\n\n\n1-2 5-1 1-6 0-3 7-4 6-9 5-3 0-8 4–8\n\n\n\n注意：当合并大小相同的两棵树的时候，将第二棵树的根指向第一棵树的根；根结点的索引是它本身；数字之间用一个空格隔开\n\n\n\n\n\n\n\n根据伪满二叉树的前序序列，求ltag-rlink的二叉树前序遍历\n\n\n\n比如：给出伪满二叉树的前序序列如下：\n\n\n\nA' B' D G' / H C' E' F I /\n\n\n\n则可以求出ltag-rlink的二叉树前序遍历为\n\n\n\n0A5 0B3 1D-1 1G4 1H-1 0C-1 0E8 1F-1 1I-1\n\n\n\n(注：各个结点按照“ltag结点名rlink”的方式给出，结点之间用一个空格分隔）\n\n\n\n现给出伪满二叉树的前序序列如下：\n\n\n\nA' B' C' / I H D' E' G / F\n\n\n\n则所求出ltag-rlink的二叉树前序遍历为：", "Tag": "算法分析"}
{"Answer": "ahash图片相似度匹配算法，可以更快判断出差别过大的，在粗分类方面非常好用 ！", "Konwledge_Point": "算法与数字", "Question": "用灰度值进行图像匹配，阈值要怎么设置\n\n目的是匹配接近的图像，用的灰度差，现在想提高效率，有更准确的办法能提前判断图像差别过大吗？希望找个设置阈值的算法", "Tag": "算法分析"}
{"Answer": "浮点", "Konwledge_Point": "算法与数字", "Question": "项目描述Python解（必采纳）\n项目描述Python解: （必采纳）\n给定一个数字n（2 ≤ n ≤ 9），将由这个数字组成的1 ~ n位数相加，要求打印出相加后的结果。例如：n = 3，需要计算3+33+333的值，结果为369，打印出369。", "Tag": "算法分析"}
{"Answer": "这个问题我觉的可以转换成，求解n皇后问题，不知道对不对，楼主可以试试", "Konwledge_Point": "算法与数字", "Question": "有一个M*N的0-1矩阵，对其操作以后要使每一行、每一列都只有1个1，求这个矩阵中1的最大个数？\nmatlab编写，就像数字填图的游戏一样，其中的数字1-9在每一行和每一列都有唯一的一个。在一个M*N的0-1矩阵中，我想得到的是在原矩阵上操作，使其每一行和每一列都只有唯一的一个1，怎样才能使得变换后1的个数最多。", "Tag": "算法分析"}
{"Answer": "我用矩阵乱算算出来了，结题了", "Konwledge_Point": "算法与数字", "Question": "python通过矩阵操作得到想要的结果\n[5 4 3 2 1\n 5 4 3 1 2\n 5 4 2 3 1\n 5 4 1 3 2\n 5 4 2 1 3\n 5 4 1 2 3\n 5 3 4 2 1\n 5 3 4 1 2\n 5 2 4 3 1\n 5 1 4 3 2\n 5 2 4 1 3\n 5 1 4 2 3]\n上述矩阵是否存在一个矩阵操作算法得到以下结果\n每一行出现相邻的目标数字，即在该数组中记为0，反之记为1，首尾也算相邻，例如\nS1_2=[0,0,1,1,0,0,0,0,1,1,1,1]\nS1_3=[1,0,0,0,0,1,1,1,0,1,0,1]\nS1_4=[1,1,1,0,1,0,1,0,1,0,0,0]\nS1_5=[0,1,0,1,1,1,0,1,0,0,1,0]\nS2_3=[0,1,0,0,1,0,1,1,1,0,1,0]\nS2_4=[1,1,0,1,0,1,0,1,0,1,0,0]\nS2_5=[1,0,1,0,1,1,1,0,0,0,0,1]\nS3_4=[0,0,1,1,1,1,0,0,0,0,1,1]\nS3_5=[1,1,1,1,0,0,0,0,1,1,0,0]\nS4_5=[0,0,0,0,0,0,1,1,1,1,1,1]\n共10个数组", "Tag": "算法分析"}
{"Answer": "\n代码\n\n int n,i_count;\n    scanf(\"%d%d\",&n,&i_count);\n    int a[n+1];\n    for(int i=0;i<n;++i)\n    {\n        scanf(\"%d\",&a[i]);\n    }\n    for(int i=0;i<i_count;++i)\n    {\n        int k;\n        scanf(\"%d\",&k);\n        int left=0,right=n-1;\n        bool isFind=false;\n        while(left<right)\n        {\n            int mid=left+(right-left)/2;\n            if(a[mid]==k)\n            {\n                while(a[mid]==k)\n                {\n                    --mid;\n                }\n                isFind=true;\n                printf(\"%d \",mid+2);\n                break;\n            }\n            else if(a[mid]<k)\n            {\n                left=mid+1;\n            }\n            else\n            {\n                right=mid-1;\n            }\n        }\n        if(!isFind)\n            printf(\"%d \",-1);\n    }\n\n", "Konwledge_Point": "算法与数字", "Question": "二分查找求解实在是看不出来了\n【深基13.例1】查找\n\n\n题目描述\n\n\n输入 $n$ 个不超过 $10^9$ 的单调不减的（就是后面的数字不小于前面的数字）非负整数 $a_1,a_2,\\dots,a_{n}$，然后进行 $m$ 次询问。对于每次询问，给出一个整数 $q$，要求输出这个数字在序列中第一次出现的编号，如果没有找到的话输出 $-1$ 。\n\n\n输入格式\n\n\n第一行 $2$ 个整数 $n$ 和 $m$，表示数字个数和询问次数。\n\n\n第二行 $n$ 个整数，表示这些待查询的数字。\n\n\n第三行 $m$ 个整数，表示询问这些数字的编号，从 $1$ 开始编号。\n\n\n输出格式\n\n\n输出一行，$m$ 个整数，以空格隔开，表示答案。\n\n\n样例 #1\n\n\n样例输入 #1\n\n\n11 \n3\n\n\n1 \n3\n \n3\n \n3\n \n5\n \n7\n \n9\n \n11\n \n13\n \n15\n \n15\n\n\n1 \n3\n \n6\n\n\n\n\n样例输出 #1\n\n\n1 \n2\n -\n1\n\n\n\n\n提示\n\n\n数据保证，$1 \\leq n \\leq 10^6$，$0 \\leq a_i,q \\leq 10^9$，$1 \\leq m \\leq 10^5$\n\n\n本题输入输出量较大，请使用较快的 IO 方式。\n\n\n#include \nusing namespace std;\nconst \nint\n \nN\n = \n10000005\n;\n\nint\n arr[\nN\n];\n\nint\n main(){\n    \nint\n \nn\n,m;\n    scanf(\n\"%d%d\\n\"\n,&\nn\n,&m);\n    for(\nint\n i = \n1\n; i <= \nn\n; i++){\n        scanf(\n\"%d\"\n,&arr[i]);\n    }\n    for(\nint\n j = \n1\n; j <= m; j++){\n        \nint\n \nleft\n = \n1\n;\n        \nint\n \nright\n = \nn\n;\n        \nint\n \nmid\n = (\nleft\n + \nright\n) / \n2\n;\n        \nint\n x;\n        scanf(\n\"%d\"\n,&x);\n        while(\ntrue\n){\n            \nif\n(arr[\nmid\n] > x){\n                \nright\n = \nmid\n - \n1\n;\n                \nmid\n = (\nleft\n + \nright\n) / \n2\n;\n            }\n            \nif\n(arr[\nmid\n] < x){\n                \nleft\n = \nmid\n + \n1\n;\n                \nmid\n = (\nleft\n + \nright\n) / \n2\n;\n            }\n            \nif\n(arr[\nmid\n] == x) {\n            break;\n            }\n            \nif\n(\nleft\n > \nright\n) {\n                printf(\n\"%d\"\n,-\n1\n);\n                return \n0\n;\n            }\n    }\n        \nint\n b = \n0\n;\n        for(\nint\n i = \n1\n; i < \nmid\n; i++){\n            \nif\n(arr[\nmid\n-i]==arr[\nmid\n]) {\n                b++;\n            }\n            else break;\n        }\n        printf(\n\"%d \"\n,\nmid\n-b);\n    }\n    return \n0\n;\n}\n\n", "Tag": "算法分析"}
{"Answer": "25行应该是  arr[j + 1 ] = temp;你写成  arr[j + i ] = temp;啦\n可以的话采纳一下", "Konwledge_Point": "算法与数字", "Question": "为什么我的C++冒泡排序不正确\n在b站学习C++,按照教程的代码敲了一冒泡排序。\n结果却跟教程的不一样，我发现最后一位数字无法交换\n使用的软件是VS2019\n该图为运行结果图\n代码如下：\n\n\n \n#\ninclude\n \n\n\n\nusing\n \nnamespace\n std;\n\nint\n \nmain\n()\n \n{\n    \nint\n arr[\n9\n] = {\n4\n,\n2\n,\n9\n,\n0\n,\n5\n,\n7\n,\n1\n,\n3\n,\n8\n};\n    cout << \n\"冒泡排序前\"\n << endl;\n    \nfor\n (\nint\n i = \n0\n; i < \n9\n; i++)\n    {\n        cout << arr[i] << \n\" \"\n;\n    }\n    cout << endl;\n    \nint\n len = \nsizeof\n(arr) / \nsizeof\n(arr[\n0\n]);\n    \n//开始冒泡排序\n\n    \n//总共排序的排序轮数为 元素个数-1\n\n    \nfor\n (\nint\n i = \n0\n; i < len \n-1\n  ; i++)\n    {\n        \n//内存循环对比\n\n        \n//次数=    元素个数-当前轮数- 1\n\n        \nfor\n (\nint\n j = \n0\n; j < len  - i \n-1\n ; j++)\n        {\n            \n//如果第一个数字比第二个数字大，就交换两个数字\n\n            \nif\n (arr[j]>arr[j + \n1\n])\n            {\n                \nint\n temp = arr[j];\n                arr[j] = arr[j + \n1\n];\n                arr[j + i ] = temp;\n            }\n        }\n    }\n    \n//排序后结果\n\n\n    cout << \n\"冒泡排序后\"\n << endl;\n    \nfor\n (\nint\n i = \n0\n; i < len; i++)\n    {\n        cout << arr[i] << \n\" \"\n;\n    }\n    cout << endl;\n    \nsystem\n(\n\"pause\"\n);\n    \nreturn\n \n0\n;\n}\n\n", "Tag": "算法分析"}
{"Answer": "如果我的回答对你有帮助，请点击采纳按钮，谢谢\n思路：​首先我们输入 n 和 k 并且运用二分找到合适的尺寸，而l 必须要足够小，r 必须要足够的大。题中写道数组中的数最大不会超过 100000000 ，所以我们设 100000001 就可以了。\n现在就走到了判断的环节，我们如何判断 mid 是太小还是太大呢？我们需要编写一个新函数 -- f。\n在函数 f 中，我们依次要判断 a 中的每一个数并计算出能切出多少个 mid ，还要用一个变量 ans 储存他们，如果 ans 分的分数比 k 多或者正好等于，返回真。如果是小于 k ，返回假。\n当 f 返回的是真的时候，我们就要试试还能不能把 mid 调大一点，就要\nl = mid;如果返回的是假，我们就加的太大了，就要把 midmid 调小一点，就要\nr = mid;一直到结束，输出 l 就可以了。\n完整代码区：​    \n #include <bits/stdc++.h>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <string>\n#include <cstdio>\n#include <iomanip>\n#include <cstring>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nlong long n, k;\nlong long a[1000005];\n\nbool f(long long x) {\n    long long ans = 0;\n    for (int i = 1; i <= n; i++) {\n        ans += a[i] / x;\n    }\n    return ans >= k;\n}\n\nint main() {\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    \n    long long l = 0, r = 100000001;\n    long long mid;\n    \n    while (l + 1 < r) {\n        mid = (l + r) / 2;\n        if (f(mid)) l = mid;\n        else r = mid;\n    }\n    cout << l << endl;\n    return 0;\n} \n\n", "Konwledge_Point": "算法与数字", "Question": "C++二分查找的判断\n二分查找\n判断是否合法\n设置的bool函数，请问定义int类型的数字有什么用啊？谢谢!", "Tag": "算法分析"}
{"Answer": "本人双非本科电信专业，单片机，通信原理，数字信号处理，数电模电也都是专业课。不同于题主，大学没有学习，每年必挂科，最后毕业混过。大学期间也就对编程感兴趣些（4年最高分C++ 95），学了学java，目前在郑州一家网络公司做初级java开发。\n \n从题主的学习经历以及各种奖项来看，真的很优秀了。个人推荐题主首先明确一个具体的方向\n1、硬件，单片机，嵌入式编程\n2、软件--具体语言\n3、信号处理\n \n大学学的东西都比较基础，对于实际生产来说其实比较落后，但并不是无用。特别题主这种，各方面都有涉及的，对之后的整体项目了解会很有帮助。\n比如51单片机，就真的只适合学习。电赛使用的也是STM32，18年用的日产的哪个我忘了。\n \n我是20级毕业的直接出来工作的，也有几个考上研究生的同学。考上研之后研究方向的选择，其实就是为以后确定具体方向。\n ", "Konwledge_Point": "算法与数字", "Question": "考研问答——通信专业相关方向\n本人双非本科通信工程专业，22届考研，现目标是南邮，但目前遇到一些问题，很是迷茫，恳求答主解惑相助；\n\n\n\n本科绩点一般，现大三第一学期刚结束，总绩点3.55（满绩点5），专业课有几门70多分，通信原理79，数字信号处理96...但实际情况复杂，真心感觉后者也没前者学得好；\n\n\n\n竞赛奖项方面：\n\n\n\n一等奖学金（大一）、2020高教社杯数学建模省二等奖（负责编程和写作）、2020ICAN省三等奖（负责作品主体设计）等省奖；\n\n\n\n个人兴趣和能力方面：\n\n\n\n四六级裸考542(口语B+)，480（还准备继续刷分）；\n\n\n\n对软件编程非常感兴趣，学过C，擅长MATLAB（经常帮实验室老师写一些小程序）、Python（计划参加2021蓝桥杯Python）、51单片机、DOS汇编；\n\n\n\n硬件方面只学过51单片机（课程设计满分）、8086/88微处理器（汇编用的比较熟练，下学期还会学EDA设计、FPGA）；\n\n\n\n数学基础比较薄弱，原本看到南邮20年初试专业课还可以选微机原理，而且其实只要是编程实践类的科目我都很感兴趣，后来发现21年开始专业课就只有通原和数字信号处理了，虽有些失落但也不大要紧，毕竟还有比较充裕的时间准备，但还是对理论类科目比较排斥..\n\n\n\n目前最大的困惑是：在本科的学习过程中经常会有一种虚无感，总觉得学的很多理论课用不上实践，导致大三一段时间上课经常走神不认真听讲，本身也不擅长考试突击，应试能力不强，最后其实连主要靠考试周突击的同学都不如，越发觉得自己很没用，获得的奖项、写过的博客、甚至编程能力也派不上什么用场，毕竟不是计算机专业，而且我们学院没有开设数据结构与算法和JAVA（我这一届没有），机器学习也很少接触，因此也并没有打算跨考；\n\n\n\n在2021 年南邮专业方向介绍中看到信号与信息处理中《多媒体技术与图形处理》还更偏向于软硬件，但不清楚这类专业方向实际学起来是什么情况，总而言之，我个人不太想往科研方向发展，将来也想从事一些技术类而非偏学术类的方向，是否有必要考虑专硕？\n\n\n\n在通信类专业方向的选择上，答主您有没有对我一些更好的建议呢？\n\n\n\n看到这里，也许你会觉得我有些思想上的错误，有点不求上进，也恳请您指点吧，谢谢！", "Tag": "算法分析"}
{"Answer": "我跟你说的这句话第一个字为什么是“我”呢你看代码不要只看一句啊，要结合上下文整体的去看你要看这两个变量后面干什么用了你不管它后面干什么用就纠结为什么给它赋值，那可不是看不懂吗-=-=-=这就好比你去看淘宝商家发货，你不看订单，只看商家把商品放到箱子里，然后就去问为什么这个箱子要放这个商品呢，你说呢-=-=-=-=如果你看不懂代码，那我简单给你讲讲二分查找到底前前后后的是在干什么首先定义两个指针，或者用做索引的变量，left和right，left指向0，right指向最后一个元素还需要一个middle来指向中间，middle=(left+right)/2然后循环，判断middle需要往更大的方向移动还是更小的方向移动如果大，让left=middle+1，重新计算middle如果小，让right=middle-1，重新计算middle如此循环那如果一开始你不给left和right赋值，那middle怎么算呢，你是从什么范围搜寻呢", "Konwledge_Point": "算法与数字", "Question": "关于二分查找的第一步\n到底为什么二分查找的第一步是先赋值两端的数字lef和rig啊 求解答 想不明白", "Tag": "算法分析"}
{"Answer": "递归遍历是比较简单的方法，数字长度有限制吗，长度大的话递归的效率比较低。\n\n参考如下：\n#define _CRT_SECURE_NO_WARNINGS 1\n#include <stdio.h>\n#include <string.h>\nconst char g_ys[][5] = { \"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\" };\nchar g_out[1000][20] = { 0 };\nint g_i = 0, g_j = 0;\nvoid fun(char* p)\n{\n    int i, len;\n    int x = p[0] - '0';\n    if (p[0] == '\\0')\n    {\n        g_out[g_i][g_j++] = '\\0';\n        g_i++;\n        g_j--;\n        return;\n    }\n    len = strlen(g_ys[x]);\n    for (i = 0; i < len; i++)\n    {\n        g_out[g_i][g_j++] = g_ys[x][i];\n        fun(p + 1);\n        g_j--;\n    }\n}\n\nint main()\n{\n    char str[20] = { 0 };\n    int i, j, len;\n    printf(\"digits = \");\n    gets_s(str);\n    len = strlen(str);\n    if (len == 0)\n    {\n        printf(\"\");\n        return 0;\n    }\n    fun(str);\n    //填充矩阵\n    for (i = 0; i < g_i; i++)\n    {\n        for (j = 0; j < len; j++)\n        {\n            if (g_out[i][j] == '\\0')\n            {\n                g_out[i][j] = g_out[i - 1][j];\n            }\n            printf(\"%c\", g_out[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n", "Konwledge_Point": "算法与数字", "Question": "来求电话号码的字母组合\n看道一到比较有意思的一题，主要是通过输入的数字返回特定的字符串，大家看一下怎么做更好", "Tag": "算法分析"}
{"Answer": "#include<iostream>\n#include<cstring>\nusing namespace std;\nchar a[82];\nint main() {\n    cin>>a;\n    int lena=strlen(a);\n    for (int i = 0; i < lena; i++) {\n        if (a[i] >= 'A' && a[i] <='Z'){\n            a[i] += 33;\n            if(a[i]>'z')\n                a[i]='a';\n        }else if (a[i] == 'a' || a[i] == 'b' || a[i] == 'c')\n            a[i] = '2';\n        else if (a[i] == 'd' || a[i] == 'e' || a[i] == 'f')\n            a[i] = '3';\n        else if (a[i] == 'g' || a[i] == 'h' || a[i] == 'i')\n            a[i] = '4';\n        else if (a[i] == 'j' || a[i] == 'k' || a[i] == 'l')\n            a[i] = '5';\n        else if (a[i] == 'm' || a[i] == 'n' || a[i] == 'o')\n            a[i] = '6';\n        else if (a[i] == 'p' || a[i] == 'q' || a[i] == 'r' || a[i] == 's')\n            a[i] = '7';\n        else if (a[i] == 't' || a[i] == 'u' || a[i] == 'v')\n            a[i] = '8';\n        else if (a[i] == 'w' || a[i] == 'x' || a[i] == 'y' || a[i] == 'z')\n            a[i] = '9';    \n    }\n    for (int i = 0; i < lena; i++) {\n        cout << a[i];\n    }\n    return 0;\n}\n\n\n觉得有用的话采纳一下哈", "Konwledge_Point": "算法与数字", "Question": "输入格式 输入包括多个测试数据，输入是一个明文，密码长度不超过80个字符。  输出格式 输出老王真正的密文。下面的这个代码只能输出老王的密码其他的的就不可以了，不知道咋办了\n假设老王原来一个BBS上的密码为zvbo941987,为了方便记忆，他通过一种算法把这个密码变换成YUANzi1987，这个密码是他的名字和出生年份，怎么忘都忘不了，而且可以明目张胆地放在显眼的地方而不被别人知道真正的密码。 他是这么变换的，大家都知道手机上的字母： 1--1， abc--2, def--3, ghi--4, jkl--5, mno--6, pqrs--7, tuv--8 wxyz--9, 0--0,就这么简单，老王把密码中出现的小写字母都变成对应的数字，数字和其他的符号都不做变换，声明：密码中没有空格，而密码中出现的大写字母则边成小写之后往后移一位，如：X，先边成小写，再往后移一位，不就是y了嘛，简单吧。记住，z往后移是a哦。\n\n\n\n#include\nusing namespace std;\n\nint main(){\n    char a[\n10\n];\n    for (int i = \n0\n; i < \n10\n; i++)\n    {\n        cin >> a[i];\n    }\n    for (int i = \n0\n; i < \n4\n; i++) {\n        if (a[i] >= \n65\n && a[i] < \n96\n)\n            a[i] += \n33\n;\n        else if(a[i]=\n96\n)\n            a[i]=\n97\n;\n    }\n    for(int i=\n4\n;i<\n6\n;i++){\n        if (a[i] == \n'a'\n || a[i] == \n'b'\n || a[i] == \n'c'\n)\n            a[i] = \n'2'\n;\n        else if (a[i] == \n'd'\n || a[i] == \n'e'\n || a[i] == \n'f'\n)\n            a[i] = \n'3'\n;\n        else if (a[i] == \n'g'\n || a[i] == \n'h'\n || a[i] == \n'i'\n)\n            a[i] = \n'4'\n;\n        else if (a[i] == \n'j'\n || a[i] == \n'k'\n || a[i] == \n'l'\n)\n            a[i] = \n'5'\n;\n        else if (a[i] == \n'm'\n || a[i] == \n'n'\n || a[i] == \n'o'\n)\n            a[i] = \n'6'\n;\n        else if (a[i] == \n'p'\n || a[i] == \n'q'\n || a[i] == \n'r'\n || a[i] == \n's'\n)\n            a[i] = \n'7'\n;\n        else if (a[i] == \n't'\n || a[i] == \n'u'\n || a[i] == \n'v'\n)\n            a[i] = \n'8'\n;\n        else if (a[i] == \n'w'\n || a[i] == \n'x'\n || a[i] == \n'y'\n || a[i] == \n'z'\n)\n            a[i] = \n'9'\n;\n        }\n    for (int i = \n0\n; i < \n10\n; i++){\n        cout << a[i]; }\n    return \n0\n;\n}\n", "Tag": "算法分析"}
{"Answer": "\nlinux的shell计算1乘2乘3,shell脚本基础（三）_梧桐叶的梦的博客-CSDN博客\n一、for循环for循环结构是日常运维工作中用的很频繁的循环结构。1、for循环具体格式：for 变量名 in 循环条件； docommanddone这里的“循环条件”可以是一组字符串挥着数字(用空格隔开)，也可以是一条命令的执行结果。2、for循环实例实例1：计算1到5之和[root@zlinux-01 shell]# vim for01.sh#! /bin/bashsum=0for i in ...\n\n\n\nhttps://blog.csdn.net/weixin_32797725/article/details/116923420\n\n参考一下", "Konwledge_Point": "算法与数字", "Question": "Linux 如何显示1+2×3的结果\n有没有人知道如何用expr显示1+2×3的结果\n这个需要凑数字，还要不带重复的字，", "Tag": "算法分析"}
{"Answer": "你内层循环没有结束条件啊，这不死循环了吗n*n如果大于num就应该结束了", "Konwledge_Point": "算法与数字", "Question": "没有错误但无法成功运行\n#include \n\n\nusing namespace std;\n\n\nint main()\n{\n// 输出所有形如 aabb（即前两位数字相等，后两位数字相等）的 4 位完全平方数。完全平方数是指那些可以表示为某一正整数的平方的数。\n\n\nint a,b;\n\nfor\n(\na\n=1; a<10; a++)\n    \nfor\n(\nb\n=1; b<10; b++)\n    {\n        int \nnum\n=a*1100+b*11;\n        \nfor\n(int \nn\n=0;; n++)\n        {\n            \nif\n(\nnum\n==n*n)\n                cout<<num<<endl;\n        }\n    }\n\n\n\nreturn 0;\n}\n\n\n本新手练习时常常出现这种问题，求大神解答，谢谢🙏", "Tag": "算法分析"}
{"Answer": "如果从你的编译提示信息来看，应该是floor()函数和sqrt()函数的头文件没有导入（我百度了一下，发现好像gcc不会自动自动链接math库，需要在gcc上加上编译参数：-lm）；如果从代码的逻辑来看，可能在判断完全平方数哪里可能错了。下面是我的一个实现，不知道对不对，供参考：参考链接：undefined reference to 'floor'/undefined reference to `&_ssdsafsdsd的博客-CSDN博客\n#include<stdio.h>\n#include<math.h>\nint main()\n{\n   for( int a = 1;  a <= 9; a++)\n    for( int b = 0; b <= 9; b++)\n    {\n      int n = a * 1100 + b * 11;\n//      int m =floor(sqrt(n) + 0.5);\n//      if(m*n ==n) printf(\"%d\\n\", n);\n        //判断当前aabb形式的四位数，是否是为完全平方数，简单的从31(1000的开平方约为整数)遍历到n的开平方 \n        int s = (int)sqrt(n);\n        if(s*s==n){\n            printf(\"%d \",n);\n        } \n    \n//        for(int c=31;c<=(int)sqrt(n);c++){\n//            if(c*c==n){\n//                printf(\"%d \",n);\n//                break;\n//            }\n//        }    \n    }\n  return 0;\n}\n\n", "Konwledge_Point": "算法与数字", "Question": "刘汝佳的紫书P20的代码运行不了？\n题目描述：\n输出所有形如aabb的4位完全平方数（即前两位数字相等，后两位数字也相等）。\n代码我使用g++编译后没有输出，是我编译有问题还是代码本身有问题，代码如下：\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\nint\n \nmain\n()\n\n\n{\n   \nfor\n( \nint\n a = \n1\n;  a <= \n9\n; a++)\n    \nfor\n( \nint\n b = \n0\n; b <= \n9\n; b++)\n    {\n      \nint\n n = a * \n1100\n + b * \n11\n;\n      \nint\n m =\nfloor\n(\nsqrt\n(n) + \n0.5\n);\n      \nif\n(m*n ==n) \nprintf\n(\n\"%d\\n\"\n, n);\n    }\n  \nreturn\n \n0\n;\n}\n\n\n\ngcc编译则是这样\n\n", "Tag": "算法分析"}
{"Answer": "\nint main()\n{\n    int m, n, max = 1, sum = 0, deletion;\n    scanf(\"%d\", &m);\n\n    for (int i = 0; i < m; i++)\n    {\n        max = 0;\n        sum = 0;\n        int sumall = 0;\n        do\n        {\n            scanf(\"%d\", &n);\n            if (n > max)\n                max = n;\n            sum += n;\n        } while (n != 0);\n\n        for (int j = 1; j <= max; j++)\n        {\n            sumall += j;\n        }\n\n        deletion = sumall - sum;\n        printf(\"%d\\n\", deletion);\n    }\n    return 0;\n}\n", "Konwledge_Point": "算法与数字", "Question": "关于循环嵌套的问题SOS\n现有一堆由1,2,3, ..., n (n>=1)组成的共 n-1 个数字，其中丢失了一个数字k，请找出这个数字。\n\n\n输入 \n\n\n第一行:m 表示测试数据的组数。\n\n\n接下来m行，每行即为一组测试样例。每组样例有n(n <= 1000)个正整数，其中最后一个整数为0，表示结束，不参与计算。\n\n\n输出\n\n\n对每组数据，输出1至n中缺失的那个整数。\n\n\n #include \nint main()\n{\n    int m,n,max=1,sum=0,deletion;\n    scanf(\"%d\",&m);\n\n\nfor(\nint\n i=\n0\n;i\nmax\n){\n            \nmax\n=\nn\n;\n        }\n        }\n        for(\nint\n j=\n1\n;j<\nmax\n;j++){\n            \nsum\n+=j;\n        }\n        for(\nint\n k=\n0\n;k<\nmax\n-\n1\n;k++){\n            \nsum\n-=\nn\n;\n        }\n            deletion=\nsum\n;    \n    printf(\n\"%d\\n\"\n,deletion);\n}\nreturn \n0\n;\n\n\n\n}\n\n\n佬们，为什么这个程序是错的呢？（c语言）比如我要输入两组数，但第二组就输不进去了，我也不知道就算输进去能不能运行", "Tag": "算法分析"}
{"Answer": "题目1：\nvoid fun(char *s)\n{\n    int i, j;\n    for (i=0, j=0; s[i]!='\\0'; i++)\n        if (s[i]>='0' && s[i]<='9')//错误1，修改为  !(s[i]>='0' && s[i]<='9')原来的条件是判断字符是数字字符，加上取反后才是去掉数字字符\n            s[j] = s[i];  //错误2：修改为s[j++]=s[i],赋值后，下标需要后移一位\n    s[j] = \"\\0\";\n}\n\n题目2：\n#include <stdio.h>\nint main()\n{ \n    int a[10]={21,43,55,12,65,87,25,93,30,62};\n    int i,k,*pa;\n    int temp;  //在这里添加temp的声明（错误1的修改方法）\n    for (k=0;k<10;k++)\n        printf(\"%3d\",a[k]);\n    printf(\"\\n\\n\");\n    for (k=0;k<9;k++)\n    { \n        pa=a;\n        for (i=0;i<10-k-1;i++)\n        { \n            if ( *pa>*(pa+1) )\n            { \n                temp=*pa; *pa=*(pa+1); *(pa+1)=temp;//错误1，没有对temp的声明，需要在开头添加int temp;\n            }\n            pa++;\n        }\n    }\n    pa = a; //错误2：需要把pa重新指向数组的首地址，需要添加这一句\n    for (k=0;k<10;k++)\n        printf(\"%3d\",*pa++);\n    printf(\"\\n\\n\");\n    return 0;\n}\n", "Konwledge_Point": "算法与数字", "Question": "c程序设计错误代码判断\n1.字符串在文档处理、基因序列等方面应用广泛。下列给定程序中，函数fun的功能是：依次取出字符串中所有数字字符，形成新的字符串，并取代原字符串。程序有二个错误，写出错行号、原因、和正确代码。\n1  #include \n2  void fun(char  *s)\n3   {\n4  int  i, j;\n5  for (i=0, j=0; s[i]!='\\0'; i++)\n6    if (s[i]>='0' && s[i]<='9')\n7       s[j] = s[i];\n8  s[j] = \"\\0\";\n9  }\n10  int main()\n11  {\n12  char  item[80];\n13  printf(\"\\nEnter a string :\");\n14  gets(item);\n15  printf(\"\\n\\nThe string is : %s\\n\", item);\n16  fun(item);\n17  printf(\"\\n\\nThe string of changing is : %s\\n\", item);\n18  return 0;\n19  }\n2.排序算法在很多领域得到相当的重视，尤其是在大量数据的处理方面。下列给定程序是使用指针完成冒泡法排序的程序，其中有二个错误，找出其中的错误行和出错原因，写出正确代码。\n1  #include \n2  int main()\n3  {  int  a[10]={21,43,55,12,65,87,25,93,30,62};\n4     int  i,k,\npa;\n5     for (k=0;k<10;k++)\n6       printf(\"%3d\",a[k]);\n7     printf(\"\\n\\n\");\n8     for (k=0;k<9;k++)\n9     {  pa=a;\n10       for (i=0;i<10-k-1;i++)\n11        {  if ( *pa>\n(pa+1) )\n12          {  temp=*pa; \npa=\n(pa+1); *(pa+1)=temp;\n13           }\n14           pa++;\n15        }\n16      }\n17      for (k=0;k<10;k++)\n18        printf(\"%3d\",*pa++);\n19      printf(\"\\n\\n\");\n20      return 0;\n21   }", "Tag": "算法分析"}
{"Answer": "问题1：\nif(th.IsAlive)\n        {\n            DateTime dt2 = DateTime.Now;\n            ts = dt2 - dt1;\n            this.textBoxTime.Text = Convert.ToString(ts);\n        }\n\n\n\n无效，因为t2,t3在线程里，你其实不知道他们的完成时间，所以这里是“假的执行时间”，修改方法。用异步信号量堵上，直到t2，t3完成当然如果你愿意使用task也行，await Task.WhenAll(Task1,task2)就好\n问题2：t2，t3升序，降序同时对nums操作。一个要升，一个要降，当然乱。所以你需要传参（线程传参），各个线程只用传参过来的而且最好是副本，而不是直接在原始数组上操作", "Konwledge_Point": "算法与数字", "Question": "求指导，c#数据排列使用多线程后输出结果异常\n求指导，问题如下。如下，我设计了一个冒泡排序法的数字排序功能，原本我将算法放在主线程内，代码运行良好。而我在修改后，将算法分别单独装入子线程中，输出结果出现了异常。\n我个人认为可能是因为子线程在同时调用主线程的局部变量时出现了冲突，当然也有可能不是这个问题。希望有人能为我指点一下问题所在，在不改变多线程，不改变使用冒泡排序法的前提下指导下该如何解决。\n\n\n功能：按下“排序”，主线程生成数据，两个子线程分别执行正反排序，并将结果输出在窗体上。\n问题：使用子线程排序，输出结果异常。\n\n\n源码放上：\n\n\nnamespace 数据统计_窗体\n{\n\n\npublic\n partial \nclass\n \nFrom1\n : Form\n{\n    \npublic\n \nFrom1\n()\n\n    {\n        CheckForIllegalCrossThreadCalls = \nfalse\n;\n        InitializeComponent();\n    }\n\n    \n//TimeSpan ts = new TimeSpan();\n\n\n\n\n    \n//int[] a = new int[n];\n\n\n    \nThread\n \nth\n \n=\n \nnull\n;\n\n    \nprivate\n \nvoid\n \nFrom1_Load\n(object sender, EventArgs e)\n\n    {\n\n    }\n\n    \nprivate\n \nvoid\n \nbuttonList_Click\n(object sender, EventArgs e)\n\n    {\n        \nif\n (th == \nnull\n)\n        {\n            th = \nnew\n \nThread\n(PaiXu);\n            th.IsBackground = \ntrue\n;\n//设置为后台线程\n\n            th.Start();   \n//子线程开始执行方法\n\n        }\n        \n    }\n\n    \nprivate\n \nvoid\n \nbuttonExit_Click\n(object sender, EventArgs e)\n\n    {\n        Close();\n    }\n\n    \nprivate\n \nvoid\n \ntextBoxWrite_KeyPress\n(object sender, KeyPressEventArgs e)\n\n    {\n        \nif\n(((\nint\n)e.KeyChar <\n48\n||(\nint\n)e.KeyChar >\n57\n&&(\nint\n)e.KeyChar !=\n8\n))\n        {\n            MessageBox.Show(\n\"只能输入整数\"\n, \n\"提示\"\n, MessageBoxButtons.OK, MessageBoxIcon.Warning);\n            e.Handled = \ntrue\n;\n        }\n    }\n\n    \nprivate\n \nvoid\n \nPaiXu\n()\n\n    {\n        \nTimeSpan\n \nts\n \n=\n \nnew\n \nTimeSpan\n();\n\n\n        \n\n        \nint\n \nn\n \n=\n \n0\n;\n        \n\n        \n//int[] arrayWaitSort = new int[n];\n\n        n = \nint\n.Parse(\n\"0\"\n + \nthis\n.textBoxWrite.Text);\n\n        \nint\n[] nums = \nnew\n \nint\n[n];     \n//数组arr    nums用于储存生成的数据\n\n        \n        \n        \n\n\n        \nRandom\n \nrnd\n \n=\n \nnew\n \nRandom\n();    \n//random随机数\n\n\n        \n            \nfor\n (\nint\n \ni\n \n=\n \n0\n; i < n; i++)       \n//i赋予初值0，只要i小于定义的总容量n，就会一直生成新的随机数\n\n                nums[i] = rnd.Next();\n\n        \n       \n\n        foreach (\nint\n everynum in nums)\n        {\n            \nthis\n.textBoxNum.Text += everynum + \n\"\\r\\n\"\n;\n        }\n\n\n\n        \nDateTime\n \ndt1\n \n=\n DateTime.Now;\n\n\n        \nThread\n \nt2\n \n=\n \nnew\n \nThread\n(() =>\n        {\n            \nint\n \non\n \n=\n nums.Length;\n            \nfor\n (\nint\n \ni\n \n=\n \n0\n; i < on-\n1\n ; i++)\n            {\n                \nfor\n (\nint\n \nj\n \n=\n \n0\n; j < on -\n1\n- i; j++)\n                {\n                    \nif\n (nums[j] > nums[j + \n1\n])\n                    {\n                        \nint\n \ntemp\n \n=\n nums[j];\n                        nums[j] = nums[j + \n1\n];\n                        nums[j+\n1\n] = temp;\n\n                    }\n                }\n            }\n\n            \nfor\n (\nint\n \ni\n \n=\n \n0\n; i < nums.Length; i++)\n\n                \nthis\n.textBoxListON.Text += nums[i] + \n\"\\r\\n\"\n;\n        });\n        \n\n\n\n        \n        \nThread\n \nt3\n \n=\n \nnew\n \nThread\n(() =>\n        {\n            \nint\n \notto\n \n=\n nums.Length - \n1\n;\n            \nfor\n (\nint\n \nh\n \n=\n \n0\n; h < otto; h++)\n            {\n                \nfor\n (\nint\n \nk\n \n=\n \n0\n; k < otto - h; k++)\n                {\n                    \nif\n (nums[k + \n1\n] > nums[k])\n                    {\n                        \nint\n \nmax\n \n=\n nums[k];\n                        nums[k] = nums[k + \n1\n];\n                        nums[k + \n1\n] = max;\n                    }\n                }\n            }\n\n            \n\n            \nfor\n (\nint\n \nh\n \n=\n \n0\n; h < n; h++)\n\n                \nthis\n.textBoxListOut.Text += nums[h] + \n\"\\r\\n\"\n;\n        });\n\n\n        t2.Start();\n        t3.Start();\n\n        \nif\n(th.IsAlive)\n        {\n            \nDateTime\n \ndt2\n \n=\n DateTime.Now;\n            ts = dt2 - dt1;\n            \nthis\n.textBoxTime.Text = Convert.ToString(ts);\n        }\n\n        \n\n\n        \n        \n    }\n\n\n\n}\n\n\n\n}\n\n\n界面如下：\n\n\n\n\n接下来是调试效果：（排序结果输出异常）\n\n", "Tag": "算法分析"}
{"Answer": "https://www.cnblogs.com/fendou-999/p/3534930.html", "Konwledge_Point": "算法与数字", "Question": "python3使用ctypes有些c类型没有怎么办？\n被实习作业折磨到摸不着头脑\n\n菜狗一只，平常总是靠度娘解决问题，但这次真的搜不到了(╥╯^╰╥)\n\n实在不想用C++......而且已经丢了很久了......\n\n学校实习任务开发指纹仪的相关软件，调用dll函数。\n\n问题1：\n\ndll函数：HANDLE_stdcall sensorOpen(int index)\n\n\n\n这个类型是句柄HANDLE，其返回值需要用到，但是Python没有直接HANDLE，我用int接收暂没出现问题，怕之后会遇到先问一个。\n\n\n\n问题2：\n\ndll函数：int_stdcall sensorCapture(HANDLE handle,unsigned char* imageBuffer, int imageBufferSize)//获取图像\n\n\n\nhandle就是上面那个，unsigned char* 文档解释是接收的图像即是输入的参数也会输出，后续指纹算法需要，ctypes也没有，怎么实现？\n\n我目前使用imageBuffer = create_string_buffer(所需空间大小)，但是没有采集到图像（我检验了该函数返回值，为0，即无图像）\n\n我也试过了create_unicode_buffer,结果也一样。到底是使用方法问题还是其他导致我真的没采集到图像\n\n\n\n问题3：（虽然前面的还没解决但先问下）（准确的说目前卡在这里）\n\ndll函数：HANDLE stdcall BIOKEY_INIT(int License, WORD *isize, BYTE*Params, BYTE *Buffer, intImageFlag)\n\n问题出在isize：文档描述：[in] 传入一个无符号双字节长度为22 的数组，且 isize[0]和isize[20]为传入图像宽度，isize[1]和 isize[21]为传入图像高度\n\n这isize怎么提前定义？\n\n\n\n我尝试使用isize = bytearray()处理，但是毕竟是双字节，光是宽度就有300多，但byte要在0-255之间，而且还不确定都是数字（我试过定义为整型数组，报错don't konw how to convert parameter 2）。作为指纹图像，虽然有函数可以修改采集图像的大小，但是太小了的话数据的完整性和可使用性就大打折扣。所以这个双字节咋整啊\n\n\n\n问题4：\n\n有些函数传入参数为int*，咋整......我先去看看ctypes的文档，但是我记得上次看的时候好像没有针对这种指针的...直接使用c_char_p吗？（目前没法验证这个方法是否可行，因为前面就走不通。。。）\n\n\n\n总之目前就这些了，实习作业周三开始检查希望会的大佬帮帮我！谢谢啦！\n\n我先滚去看文档了。。。", "Tag": "算法分析"}
{"Answer": "这种一般是函数参数不能作为返回值造成的你这Push调用不对吧， 参数要求是Linkstack类型，你却传递了Linkstack *类型，Push(s,e)就行了", "Konwledge_Point": "算法与数字", "Question": "关于数据结构的栈，入栈函数\n\n\n\n\n\n\n数据入栈后，在入栈函数内输出值是正确的，但是一在函数外面就输出-842150451，还有获取栈顶元素和出栈都是输出一长串数字。这到底是为什么。", "Tag": "算法分析"}
{"Answer": "scanf是以空格或回车结束的，所以你的字符串 s 中只有 a123x456 。你可以用 gets(s) 是以回车结束，得到字符串", "Konwledge_Point": "算法与数字", "Question": "我这代码到底出什么问题了？\n输入一个字符串，内有数字和非数字字符，例如：a123x456 7689?89njnk32lnk123，\n\n将其中连续的数字作为一个整数，依次存放到一维数组a中，例如123放在b[0]，456放\n\n在b[1]......统计共有多少个整数，并输出这些数。弟1行输出个数，第2行输出多个整数\n\n，用空格分隔。\n\n\n\n #include\n#include\nvoid main()\n{\n    int i,j=0,k=0,x=0,n,m,b[100];\n    char s[100],a[100];\n    scanf(\"%s\",s);\n    for(i=0;s[i]!='\\0';i++)\n    {\n        if(s[i]>='0'&&s[i]<='9')\n            a[j++]=s[i];\n        else\n        {\n            j--;\n            for(n=0;j>=0;j--,n++)\n                x+=(a[j]-'0')*(int)pow(10,n);\n            b[k++]=x;\n            x=0;  j=0;\n        }\n    }\n    printf(\"%d\\n\",k);\n    for(m=0;m<k;m++)\n        printf(\"%d \",b[m]);\n    printf(\"\\n\");\n}\n\n\n\n", "Tag": "算法分析"}
{"Answer": "原先定义的球队数组可以使用二维数组，第一维是球队好，第二维是球队名。就可以了。\r\n也可以将球队数组定义成Map，也可以。结合前面提供的方法，就可以输出球队号和球队名。\r\n这个由你自由选择", "Konwledge_Point": "算法与数字", "Question": "C++数组排序输出的问题\n数组中的每个量表示一支球队，对数组进行随机数分配，然后根据随机数进行选择排序，排序完了以后，如何输出这些数字原先对应的球队的排序（要求输出的是球队的中文名）？数组是int类型。", "Tag": "算法分析"}
{"Answer": "判断先后顺序肯定有关系。&&的意思是满足条件一才执行条件二，如果条件1不满足则不会执行条件2。拿你的问题来说，只有索引位置满足条件的时候，才会去进一步比较索引位置对应的值。否则，先取值的话，可能你的索引位置不满足要求，被用来取值了，导致数组越界异常。", "Konwledge_Point": "算法与数字", "Question": "Java关于if语句中有多个条件需要判断，各个条件间的先后顺序有要求吗\n今天学习回形数，在网上看了别人的代码后试着按自己的理解敲了一遍\n\n\npackage\n exercise;\n\nimport\n java.util.Scanner;\n\n\n/**\n * \n@author\n lzy\n * 数组算法\n * 回形数，也称回形矩阵\n */\n\n\npublic\n \nclass\n \nRoundMatrix\n {\n    \n/**\n     * 定义常量代表含义\n     * 初始向右，设置RIGHT = 1\n     */\n\n    \nprivate\n \nstatic\n \nfinal\n \nint\n \nRIGHT\n \n=\n \n1\n;\n    \nprivate\n \nstatic\n \nfinal\n \nint\n \nDOWN\n \n=\n \n2\n;\n    \nprivate\n \nstatic\n \nfinal\n \nint\n \nLEFT\n \n=\n \n3\n;\n    \nprivate\n \nstatic\n \nfinal\n \nint\n \nUP\n \n=\n \n4\n;\n\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(String[] args)\n {\n        \n//1.创建数组\n\n        \n//根据键盘输入num值决定回型矩阵的行数列数\n\n        \nScanner\n \nscanner\n \n=\n \nnew\n \nScanner\n(System.in);\n        System.out.println(\n\"请输入一个数字：\"\n);\n        \nint\n \nnum\n \n=\n scanner.nextInt();\n        \nint\n[][] roundMatrix = \nnew\n \nint\n[num][num];\n        \n//表示该矩阵元素的总数目\n\n        \nint\n \ncount\n \n=\n num * num;\n\n        \n//2.赋值\n\n        \n//定义横纵坐标，方向，循环次数计数器\n\n        \nint\n \nxAis\n \n=\n \n0\n;\n        \nint\n \nyAis\n \n=\n \n0\n;\n        \nint\n \ndirection\n \n=\n RIGHT;\n        \nint\n recycleNumber;\n\n        \nfor\n (recycleNumber = \n1\n; recycleNumber <= count; recycleNumber ++){\n            \n//方向向右时的处理\n\n            \nswitch\n (direction) {\n                \ncase\n RIGHT:\n                    \nif\n (roundMatrix[xAis][yAis] == \n0\n && yAis < num) {\n                        roundMatrix[xAis][yAis] = recycleNumber;\n                        yAis ++;\n                    } \nelse\n {\n                        direction = DOWN;\n                        xAis++;\n                        yAis--;\n                        \n//进入else的recycleNumber需减1，保证下次循环时的值正确\n\n                        recycleNumber--;\n                    }\n                    \nbreak\n;\n                \n//方向向下时的处理\n\n                \ncase\n DOWN:\n                    \nif\n (roundMatrix[xAis][yAis] == \n0\n && xAis < num) {\n                        roundMatrix[xAis][yAis] = recycleNumber;\n                        xAis ++;\n                    } \nelse\n {\n                        direction = LEFT;\n                        xAis--;\n                        yAis--;\n                        recycleNumber--;\n                    }\n                    \nbreak\n;\n                \n//方向向左时的处理\n\n                \ncase\n LEFT:\n                    \nif\n (roundMatrix[xAis][yAis] == \n0\n && yAis >= \n0\n) {\n                        roundMatrix[xAis][yAis] = recycleNumber;\n                        yAis --;\n                    } \nelse\n {\n                        direction = UP;\n                        xAis--;\n                        yAis++;\n                        recycleNumber--;\n                    }\n                    \nbreak\n;\n                \n//向上\n\n                \ncase\n UP:\n                    \nif\n (roundMatrix[xAis][yAis] == \n0\n && xAis >= \n0\n) {\n                        roundMatrix[xAis][yAis] = recycleNumber;\n                        xAis --;\n                    } \nelse\n {\n                        direction = RIGHT;\n                        xAis++;\n                        yAis++;\n                        recycleNumber--;\n                    }\n                    \nbreak\n;\n                \ndefault\n:\n            }\n\n        }\n        \n//3.遍历\n\n        \nfor\n (\nint\n[] matrix : roundMatrix) {\n            \nfor\n (\nint\n i : matrix) {\n                System.out.print(i + \n\" \"\n);\n            }\n            System.out.println();\n        }\n    }\n}\n\n\n\n写完后运行，但是却一直报错，显示数组越界异常，不明白为什么\n\n\nException \nin\n thread \n\"main\"\n java\n.lang\n.ArrayIndexOutOfBoundsException\n: \n3\n\n    at exercise\n.RoundMatrix\n.main\n(RoundMatrix\n.java\n:\n40\n)\n\n\n\n最后把每条case语句中第一个if语句中 && 前后两个条件的顺序替换了才运行成功，虽然没再报错了，但一直不明白为什么颠倒了顺序后就会数组越界\n\n\ncase\n RIGHT:\n                    \nif\n (yAis < \nnum\n && roundMatrix[xAis][yAis] == \n0\n)\n", "Tag": "算法分析"}
{"Answer": "第九行，赋值后longest变成一个字符串类型了pop函数返回的是被删除的元素，而不是删除元素后的列表\n\njuzi=input().split()\njuzi.pop(-1)  # 删除末尾句号\nlongest = ''\nfor i in range(len(juzi)):\n    if(len(juzi[i])>len(longest)):\n        longest = juzi[i]\n\nprint(longest)\n", "Konwledge_Point": "算法与数字", "Question": "请问为什么会报错呢？\n系统显示第八行数据类型不同不能比大小，但是len函数和变量longest不都是数字类型吗？我该怎么改呢？Python     我们学到列表元组了，这是列表元组的题。但还是想通过我自己的这种方法解出来。\n\n", "Tag": "算法分析"}
{"Answer": "String fileName = \"gzip.file.gz\";\r\nBufferedReader gzipReader = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(fileName))));\r\n            String tmp = null;\r\n            while((tmp=gzipReader.readLine())!=null){\r\n                System.out.println(\"文件行:\"+tmp);\r\n            }\r\n我这样试了试,是可以的;\r\n你是怎么读取的?\r\n\r\n难道跟服务器的编码有关?", "Konwledge_Point": "算法与数字", "Question": "关于java的GZip解压问题\n视频系统，关系各终端的播放日志，采用的是定期向服务器上传tar.gz包，然后在服务器上解开，逐条读取放到数据库中。\n\n问题：以前服务器用的是linux系统，解压文件是调用的系统命令tar来解压的，现在因为部分系统要部署到window或苹果上,所以改为用java自己的包来解压。这下出问题了，本来只有三行的记录，解出来之后有四行，第一行的前面是文件名和系统中的很多信息，然后是文件内容，中间隔的是乱码，下载到windows上用文本编辑器打到，，好像中间隔的是空格，用客户端软件ssh到linux上，用vi看，是一个个类似^@样的乱码，然而用正则表达式匹配却不行。\n\n实际数据：\n\n一个tar包，里面是一个log文件，内容是：\n\n\\factory\\film\\真实的谎言\\huangyan.vob,2000-01-01 20:43:32,2000-01-01 20:43:39\n\n\\factory\\film\\指环王\\zhihuanwang.vob,2000-01-01 22:50:24,2000-01-01 22:50:29\n\n用系统命令的方法，一切正常，但是用GZip的包来解，内容就是这样的：\n\n00e04c0000ba_2001-03-06.log     0100755 0000000 0000000 00000003036 07251305477 013102\\factory\\film\\真实的谎言\\huangyan.vob,2000-01-01 20:43:32,2000-01-01 20:43:39\n\n\\factory\\film\\指环王\\zhihuanwang.vob,2000-01-01 22:50:24,2000-01-01 22:50:29\n\n真实文件的前面，是文件名以及后面很多不知道是什么信息的信息，最后还有一行，我想用拷贝粘贴的方法，但是粘不出来，不知道为什么。\n\n请问是不是GZIPInputStream或GZIPOutputStream有什么参数？为什么他们解压后有这么多冗余的数据？如何去掉？\n\n谢谢!不好意思，就这点分了\n\n[b]问题补充：[/b]\n\n这是文件，如果能用Gzip解压后的文件与用winzip 或winrar解压后的文件一致，就说明正确了\n\n[b]问题补充：[/b]\n\n文件后缀名为tgz，请修改修改成tgz，当然压缩算法是一样的，我上传文件不行，只能改为gz才能上传成功\n\n[b]问题补充：[/b]\n\n有的朋友说格式不对，但是为什么用winrar或linux的系统命令解压之后的文件内容正常，但是用java的gzip包却多出了很多内容？这是为什么？至少应该结果相同吧？\n\n[b]问题补充：[/b]\n\n用客户端工具压缩之后，再用gzip的包解压，网上的大多程序都能做到正确解压，我得到的是数字电视的机顶盒所上传的日志文件，因为是不同公司之后开发的，所以很难联调，也不清楚具体是用什么压缩的，应该是用linux的命令压缩的\n\n[b]问题补充：[/b]\n\n[color=red]因为我上传的文件格式不支持，所以我是修改了后缀名才上传成功的，下载后请修改成为*.tgz，而不是gz[/color]\n\n[b]问题补充：[/b]\n\n[color=red]根据后缀名来判断，并不是bz2压缩，也许是在包中含了别的信息，但是有一点很奇怪：为什么用系统命令解压或用工具解压，都没有这些信息呢？为什么用GZip还解压，就会有呢？这是为什么？[/color]", "Tag": "算法分析"}
{"Answer": "应该是视频错了\r\n\r\n这里不会无限递归\r\nif(cur==n&&isP(r[0]+r[n-1]))\r\n这是递归终止条件", "Konwledge_Point": "算法与数字", "Question": "看不懂这个回溯，要什么条件才能执行这个回溯呢？\n题目描述：\n\n素数环:从1到n这n个数摆成一个环，要求相邻的两个数的和是一个素数。\n\n\n\n大佬们应该都接触过这个题，我就不详细说别的了。\n\n\n\n本人刚接触递归回溯这个算法，无法理解\n\n我怎么总觉得到了dfs(n,r,cur+1)这一行之后会一直递归下去呢？\n\n如果递归到满足if(cur==n&&isP(r[0]+r[n-1]))的时候就结束，那如果不满足这个条件难道一直递归下去吗？我怎么感觉没出口呢？？\n\n在什么条件下才会执行r[cur]=0这条回溯语句呢？\n\n求大佬们解答，救救孩子吧\n\n\n\n代码选自蓝桥杯郑未老师的视频，视频里老师说这个回溯语句加不加都行，但是我运行之后发现不加回溯语句的话结果是不对的。\n\n\n\nimport java.util.Scanner;\n\npublic class 素数环 {\n\n    public static void main(String[] args) {\n\n        Scanner sss=new Scanner(System.in);\n        int n=sss.nextInt();\n        int r[]=new int[n];\n        r[0]=1;\n        dfs(n,r,1);\n    }\n\n    public static void dfs(int n,int r[],int cur) {\n\n        if(cur==n&&isP(r[0]+r[n-1])) {    //填到末尾了，并且首尾相加为素数才算成功\n            print(r);\n            return;\n        }\n        for(int i=2;i<=n;i++) {        //尝试用每个数字填到cur这个位置\n            if(check(r,i,cur)) {       //数组中没有i这个数，且i和上一个数之和为素数\n                r[cur]=i;              //将i放在cur的位置，并向前走一步\n                dfs(n,r,cur+1);\n                r[cur]=0;              //回溯\n            }\n        }\n    }\n\n    public static void print(int a[]) {\n\n        for(int i=0;i<a.length;i++) {\n            System.out.print(a[i]+(i==a.length-1?\"\":\" \"));\n        }\n        System.out.println();\n    }\n\n\n\n    public static boolean check(int a[],int i,int cur){    //检测i这个数能否放到cur这个位置。\n        for(int e:a) {\n            if(e==i||!isP(a[cur-1]+i))  return false;   \n        }\n\n        return true;\n    }\n\n\n    public static boolean isP(int x) {     //判定是否为素数\n\n        for(int i=2;i*i<=x;i++) {\n\n            if(x%i==0)   return false;\n        }\n        return true;\n    }\n}\n\n", "Tag": "算法分析"}
{"Answer": "可以把每个数看做字符串，输入后排序，然后找到相同的字符串最多有多少个", "Konwledge_Point": "算法与数字", "Question": "关于如何使用剪枝优化问题\n问题遇到的现象和发生背景\n\n\n如果两个整数是由完全相同的数字组成，且同一种数字的个数也相等，那么这两个整数称为相似数。\n例如，12300和20310都是由2个0，1个1，1个2，1个3组成，所以它们是相似数。\n而124和120不是相似数，因为组成的数字不同。\n120和1200也不是相似数，因为组成的数字虽然相同，但0的个数不相等，120中有1个0，而1200中有2个0\n多个整数也可以相似。\n给出N个不同的正整数，求最多有多少个数相似。例如，如果最多有3个数相似，则输出3，最多有2个数相似，输出2.如果所有数均不相似，则输出1。\n\n\n这个问题如何在大量数据下进行剪枝优化\n\n\n问题相关代码，请勿粘贴截图\n\n\n#include \n\n\nusing\n namespace std;\n\nint\n a[\n1000005\n][\n15\n], m[\n1000005\n], s[\n1000005\n];\n\nint\n k = \n0\n;\n\nint\n num(\nint\n x) {\n    \nif\n (s[x] != \n0\n)\n        \nreturn\n s[x];\n    \nint\n cnt = \n0\n;\n    \nwhile\n (x != \n0\n) {\n        cnt++;\n        x /= \n10\n;\n    }\n    \nreturn\n s[x] = cnt;\n}\n\nvoid\n fun(\nint\n x) {\n    \nint\n i = x;\n    \nwhile\n (x != \n0\n) {\n        k = x % \n10\n;\n        a[i][k]++;\n        x /= \n10\n;\n    }\n}\n\nbool\n \ncheck\n(\nint\n x, \nint\n y) {\n    \nfor\n (\nint\n i = \n0\n; i <= \n9\n; i++) {\n        \nif\n ((a[x][i]) != (a[y][i]))\n            \nreturn\n \n0\n;\n    }\n    \nreturn\n \n1\n;\n}\n\nint\n main() {\n    \nint\n c, d, s = \n0\n, maxn = \n0\n;\n    cin >> c;\n    \nfor\n (\nint\n i = \n1\n; i <= c; i++) {\n        cin >> m[i];\n        fun(m[i]);\n    }\n    sort(m + \n1\n, m + \n1\n + c);\n    \nfor\n (\nint\n i = \n1\n; i <= c; i++) {\n        s = \n1\n;\n        \nfor\n (\nint\n j = i + \n1\n; j <= c; j++) {\n            \nif\n (num(m[j]) > num(m[i]))\n                break;\n            \nif\n (\ncheck\n(m[i], m[j]) == \n1\n) {\n                s++;\n                \nif\n (s >= maxn)\n                    maxn = s;\n            }\n        }\n    }\n    \nif\n (maxn == \n0\n)\n        cout << \n-1\n;\n    \nelse\n\n        cout << maxn;\n    \nreturn\n \n0\n;\n}\n\n\n\n\n运行结果及报错内容\n\n\n对于小数据而言比较容易处理，但是数据大了之后就会用时很长\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果", "Tag": "算法分析"}
{"Answer": "public static List longest_increasing_subsequence(List sequence) {\r\n\t\t// Write your solution here\r\n\t\tif (sequence.isEmpty()) return new ArrayList();\r\n\t\tint max_size[] = new int[sequence.size()];\r\n\t\tint prev_index[] = new int[sequence.size()];\r\n\t\tmax_size[0] = 1;\r\n\t\tprev_index[0] = -1;\r\n\t\tfor (int i = 1; i < sequence.size(); i++) {\r\n\t\t\tint cur_max = 1;\r\n\t\t\tint cur_prev = -1;\r\n\t\t\tint iVal = sequence.get(i);\r\n\t\t\tfor (int j = i - 1; j >= 0; j--) {\r\n\t\t\t\tif (cur_max < max_size[j] + 1 && sequence.get(j) < iVal) {\r\n\t\t\t\t\tcur_max = max_size[j] + 1;\r\n\t\t\t\t\tcur_prev = j;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tprev_index[i] = cur_prev;\r\n\t\t\tmax_size[i] = cur_max;\r\n\t\t}\r\n\t\tint max_idx = sequence.size() - 1;\r\n\t\tint max_val = max_size[max_idx];\r\n\t\tfor (int i = max_idx - 1; i >= 0; i--) {\r\n\t\t\tif (max_val < max_size[i]) {\r\n\t\t\t\tmax_idx = i;\r\n\t\t\t\tmax_val = max_size[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\tList aList = new ArrayList();\r\n\t\tint idx = max_idx;\r\n\t\taList.add(sequence.get(idx));\r\n\t\twhile (prev_index[idx] >= 0) {\r\n\t\t\tidx = prev_index[idx];\r\n\t\t\taList.add(sequence.get(idx));\r\n\t\t}\r\n\t\tList retList = new ArrayList(aList.size());\r\n\t\tfor (int i = aList.size() - 1; i >= 0; i--) {\r\n\t\t\tretList.add(aList.get(i));\r\n\t\t}\r\n\t\treturn retList;\r\n\t}", "Konwledge_Point": "算法与数字", "Question": "如果求最大非连续子序列？？\n假设有一个序列是L = [1, 0, 5, 3, 2, 7, 9, 15, 6, 4, 13]\n\n他的最大非连续子序列就是 S = [1, 5, 7, 15, 13] 俩俩数字任意不相邻\n\n现在要求给L求S", "Tag": "算法分析"}
{"Answer": "\n[int(input()) for i in range(int(input()))]\n", "Konwledge_Point": "算法与数字", "Question": "py有关列表的简洁写法\n给出一个n\n下面n行 每行一个数字 将其读入数组\n我的做法：\n\n\nn\n=\nint\n(\ninput\n())\n\n\na\n=[]\n\nfor\n \ni\n \nin\n \nrange\n(\nn\n):\n    \na.append\n(\nint\n(\ninput\n()))\n\n\n\n\n\n\n想问下有没有更加简洁的写法", "Tag": "算法分析"}
{"Answer": "该回答引用GPTᴼᴾᴱᴺᴬᴵ这段代码看起来是Smarty模板引擎的语法，其中包含了一个条件判断和一个输出语句。\n如果要在输出语句中直接减去固定数字3，可以在输出语句中使用数学计算符号“-”，例如：\n{#if $refrundstate ==1 && $refrundamount ==\"0.00\"#}0{#else#}{#$staticmoney['business']-3|string_format:\"%.2f\"#}{#/if#}\n\n在这个修改后的代码中，我们将原始的输出语句 {#$staticmoney['business']|string_format:\"%.2f\"#} 修改为了 {#$staticmoney['business']-3|string_format:\"%.2f\"#}，在这个新的输出语句中，我们直接从 $staticmoney['business'] 中减去了数字3，并使用 string_format 进行了格式化处理，保留了两位小数。", "Konwledge_Point": "算法与数字", "Question": "关于#else#的问题，如何解决？\n求帮忙看下这段代码怎么直接减去固定数字3\n￥{#if $refrundstate ==1 && $refrundamount ==\"0.00\"#}0{#else#}{#$staticmoney['business']|string_format:\"%.2f\"#}{#/if#}", "Tag": "算法分析"}
{"Answer": "这可能是由于文件内容不是有效的字符串，stoi函数无法将其转换为可用的整数而导致的。为了避免出现这种情况，应该使用有效的字符串来读取文件内容，以确保stoi函数可以正常工作。", "Konwledge_Point": "算法与数字", "Question": "为什么用stoi后显示abort已被调用错误\n用string读文件内容时，为了把读取到的string类型内容转换为整型数字，我用了stoi，但是在运行时却显示abort已被调用，这是为什么呢？\n代码：\n\n\n//利用Fleury算法求欧拉回路\n\n#\ninclude\n\n#\ninclude\n<\nstring\n>\n#\ninclude\n\n#\ninclude\n\nusing namespace std;\n#define INFINITY INT_MAX \n// 定义最大值\n\n#define MAX_V \n30\n \n// 最大顶点数目\n\n\nint\n i, j, k;\n\ntypedef \nstruct\n\n{\n    \nstring\n code; \n// 顶点编号\n\n}VertexType; \n// 顶点类型定义\n\ntypedef \nstruct\n\n{\n    \nint\n arcs\n[MAX\n_V\n + \n1\n]\n[MAX\n_V\n + \n1\n]\n; \n// 邻接矩阵\n\n    \nint\n vexnum, arcnum; \n// 图包含的顶点数与边的个数\n\n    VertexType vexs\n[MAX\n_V\n + \n1\n]\n; \n// 存放顶点信息\n\n} MGraph;\n\nstruct\n\n{\n    \nint\n vexcode;\n    \nint\n lowcost;\n    \nbool\n tag;\n} closest\n[MAX\n_V\n + \n1\n]\n; \n// 定义辅助数组 closest 的结构\n\n\n\n//利用邻接矩阵打印无向图\n\nvoid \nPrintGraph(MGraph G)\n\n{\n    cout << \n\"----------矩阵输出----------\"\n << endl;\n    \nfor\n (i = \n1\n; i <= \nG\n.\nvexnum; i++)\n        cout << \n\"\\t\"\n << \nG\n.\nvexs\n[\ni\n]\n.code;\n    cout << endl;\n    \nfor\n (i = \n1\n; i <= \nG\n.\nvexnum; i++) {\n        cout << \nG\n.\nvexs\n[\ni\n]\n.code << \n\"\\t\"\n;\n        \nfor\n (j = \n1\n; j <= \nG\n.\nvexnum; j++) {\n            \nif\n (\nG\n.\narcs\n[\ni\n]\n[\nj\n]\n == \nINFINITY)\n                cout << \n\"∞\"\n << \n\"\\t\"\n;\n            \nelse\n cout << \nG\n.\narcs\n[\ni\n]\n[\nj\n]\n << \n\"\\t\"\n;\n        }\n        cout << endl;\n    }\n}\n\n\n//创建图\n\nvoid \nCreateGraph(MGraph& G)\n\n{\n    ifstream ifs;\n    ifs.\nopen\n(\n\"D:\\\\欧拉回路.txt\"\n, ios::\nin\n);\n    \nif\n (!ifs.is\n_open()\n) {\n        cout << \n\"读取文件失败!\"\n << endl;\n        exit\n(-1)\n;\n    }\n\n    \nstring\n tmp;\n    \nint\n count = \n0\n;\n    \nwhile\n (getline(ifs, tmp, \n'\\n'\n)) {\n        \n//读取顶点数、边数、顶点编号\n\n        \nif\n (count\n == \n0\n)\n            \nG\n.\nvexnum = stoi(tmp);\n        \nelse\n \nif\n (count\n == \n1\n) {\n            \nG\n.\narcnum = stoi(tmp);\n            \nfor\n (i = \n1\n; i <= \nG\n.\nvexnum; i++)\n                \nfor\n (j = \n1\n; j <= \nG\n.\nvexnum; j++)\n                    \nG\n.\narcs\n[\ni\n]\n[\nj\n]\n = INFINITY; \n// 邻接矩阵初始化，所有元素初始值为 ∞\n\n        }\n        \nelse\n \nif\n (count\n == \n2\n) {\n            istringstream \nstring\n_to_string(\ntmp\n)\n;\n            \nfor\n (i = \n1\n; i <= \nG\n.\nvexnum; i++) {\n                \nstring\n str_tmp;\n                string_to_string >> str_tmp;\n                \nG\n.\nvexs\n[\ni\n]\n.code = str_tmp;\n            }\n        }\n        \n//读取带权边\n\n        \nelse\n {\n            istringstream \nstring\n_to_num(\ntmp\n)\n;\n            \nint\n arr_tmp\n[\n2\n]\n;\n            \nfor\n (\nint\n i = \n0\n; i < \n2\n; i++) {\n                \nstring\n str_tmp;\n                string_to_num >> str_tmp;\n                arr_tmp\n[\ni\n]\n = stoi(str_tmp);\n            }\n            \nG\n.\narcs\n[\narr_tmp\n[\n0\n]\n]\n[\narr_tmp\n[\n1\n]\n] = \n1\n;\n            \nG\n.\narcs\n[\narr_tmp\n[\n1\n]\n]\n[\narr_tmp\n[\n0\n]\n] = \n1\n;\n        }\n        count++;\n    }\n    \nPrintGraph(G)\n;\n\n    ifs.close\n()\n;\n}\n\n\n\n\nint\n main\n()\n\n{\n    MGraph G;\n    \nCreateGraph(G)\n;\n    return \n0\n;\n}\n\n\n\n\n错误：\n\n\n\n\n\n\n恳请解惑！万分感激！", "Tag": "算法分析"}
{"Answer": "假设两个格子的坐标为(x1,y1), (x2,y2).\r\n那么判断相邻: ((x1==x2) && (abs(y1-y2)==1)) || ((y1==y2) && (abs(x1-x2)== 1))\r\n\r\n\r\n用伪代码说明一下,怎么把二维数组分组\r\n\r\n```\r\n// 0 表示未分组, >=1 表示分在哪个组\r\ngroup[16] = {0}\r\ncolor[16]\r\ngroup_num = 0;\r\n\r\n// 递归深度优先遍历, 在当前点的上下左右4个方向探索, 如果未分组, 且颜色一样,则加入当前分组\r\ndfs(x, group_id)\r\n{\r\n  cur_color = color[x];\r\n  check(x-4, cur_color,group_id);\r\n  check(x-1, cur_color,group_id);\r\n  check(x+1, cur_color,group_id);\r\n  check(x+4, cur_color,group_id);\r\n}\r\n\r\ncheck(x, cur_color, group_id) {\r\n  if (x >=0 && x <16 && 0 == group[x]) {\r\n    if (color[x] == cur_color) {\r\n      group[x] = group_id;\r\n      dfs(x,group_id);\r\n    }\r\n  }\r\n}\r\n\r\n// 对每个点, 看是否已经分组, 如果未分组, 则新建分组并做深度优先遍历\r\nfor (i = 0; i < 16; i++) {\r\n  if (0 == group[i]) {\r\n    group_num += 1;\r\n    group[i] = group_num;\r\n    dfs(i, color[i], group[i]);\r\n  }\r\n}\r\n\r\n```", "Konwledge_Point": "算法与数字", "Question": "最难图形遍历，求大神解决！！！\n\n\n\n像这种图片怎么查找颜色相同的组件，找到相同的了，怎么才能知道颜色相同的方块是否相邻，像这种\n\n我现在的方案是：先创建5个不同颜色的color对象（这张图片只有4中颜色，没次运行方块的颜色不一样。设置的概率的。），然后坐标查询每个方块的颜色，返回的颜色和出创建的颜色对象作比较，和color对象相同的颜色分别用0--4（0红色，1黄色，2绿色，3蓝色，4紫色）表示，之后就用一个长度为16的二维数组装起，这样就得到了每个坐标的颜色。数组里面的值为：1312003010320012。这个一维数组代表的是4x4的格子中颜色。我的难题就是怎么判断相同的数字相邻。\n\n如果有这个问题解决办法或者有更好的算法请帮忙解答一下。\n\n这个是图形代码，负责创建容器和创建排列组件：\n\n\n\npackage zhuJie_MB;\n\nimport java.awt.Color;\nimport java.util.Random;\n\nimport javax.swing.JButton;\nimport javax.swing.JFrame;\n\nimport suanFa.XiaoChu_SF;\n\npublic  class Zhumianban_JM{\n    public static JFrame jFrame;\n    public static JButton[] jb=new JButton[16];\n\n    public static void main(String[] args) {\n        Zhumianban_JM zh=new Zhumianban_JM();\n        zh.zhuJianMian();\n        XiaoChu_SF jj=new XiaoChu_SF();\n        jj.suan();\n    }\n    public void zhuJianMian() {\n        Random r=new Random();\n        jFrame=new JFrame(\"糖果Party\");\n        jFrame.setBounds(100,50,1000,600);\n        jFrame.setLayout(null);\n\n        final Color red=new Color(255,0,0);//设置5种颜色。\n        final Color yellow=new Color(255,255,0);\n        final Color green=new Color(0,255,0);\n        final Color blue=new Color(0,0,255);\n        final Color purple=new Color(128,0,128);\n        int x=0;\n        int y=0;\n        for (int i = 0; i <16; i++) {//使用for循环16次。将16个组件初始化并添加到容器中。\n            jb[i]=new JButton();\n            int u=r.nextInt(15);//设置15的随机数。0-4红色，概率最高。以此类推。\n            if (u>=0 && u<=4) {\n                jb[i].setBackground(red);\n            }else if (u>4 && u<=8) {\n                jb[i].setBackground(yellow);\n            }else if (u>8 && u<=11) {\n                jb[i].setBackground(green);\n            }else if (u>11 && u<=13) {\n                jb[i].setBackground(blue);\n            }else {\n                jb[i].setBackground(purple);\n            }\n            jb[i].setBounds(x,y,80,80);//设置布局，使用变量想x，y当中介。使其排列为一个4x4的格子。\n            if (x==240) {\n                y+=80;\n                x=0;\n            }else {\n                x+=80;\n            }\n            jFrame.add(jb[i]);\n        }\n        jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        jFrame.setVisible(true);\n    }\n\n}\n\n\n\n\n\n这个是相关的算法：\n\n\n\npackage suanFa;\n\nimport java.awt.AWTException;\nimport java.awt.Color;\nimport java.awt.Robot;\n\nimport zhuJie_MB.Zhumianban_JM;\n\npublic class XiaoChu_SF {\n    static Robot robot=null;\n    static int xxx=145;//获取屏幕x坐标\n    static int yyy=120;//获取屏幕y坐标\n    static int col;//定义一个变量，用来储存颜色所对应的数字。\n    static int[] color=new int[16];//定义一个整型数组，用来装16个组件所对应的颜色代码。\n    static Zhumianban_JM zh=new Zhumianban_JM();\n    public static void suan() {\n        final Color red=new Color(255,0,0);\n        final Color yellow=new Color(255,255,0);\n        final Color green=new Color(0,255,0);\n        final Color blue=new Color(0,0,255);\n        final Color purple=new Color(128,0,128);\n\n\n        new Thread() {//此处需要加一个线程，让线程停止1秒，不然进程未加载出来就开始查询坐标颜色。\n            public void run() {\n                try {\n                    Thread.sleep(1000);\n                    for (int i = 0; i <16; i++) {\n                        try {\n                            robot=new Robot();\n                        } catch (AWTException e) {\n                            e.printStackTrace();\n                        }\n                        robot.getPixelColor(xxx, yyy);\n                        if (robot.getPixelColor(xxx, yyy).equals(red)) {\n                            col=0;\n                        }else if (robot.getPixelColor(xxx, yyy).equals(yellow)) {\n                            col=1;\n                        }\n                        else if (robot.getPixelColor(xxx, yyy).equals(green)) {\n                            col=2;\n                        }\n                        else if (robot.getPixelColor(xxx, yyy).equals(blue)) {\n                            col=3;\n                        }else if (robot.getPixelColor(xxx, yyy).equals(purple)) {\n                            col=4;\n                        }else {\n                            col=50;\n                        }\n                        color[i]=col;//把每个颜色放到color数组中。\n                        System.out.print(color[i]);\n                        if (xxx==385) {//将每次查询是的坐标变换。使其查询坐标颜色时排列为4X4的格子。\n                            yyy+=80;\n                            xxx=145;\n                        }else {\n                            xxx+=80;\n                        }\n                        if (i==15) {//当颜色查询完毕后，进入no1方法。\n                            no1();\n                        }\n                    }\n\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n\n            }\n        }.start();\n    }\n    public static void no1() {\n        int x0 = 0,x1 = 0,x2 = 0,x3 = 0,x4 = 0;//定义5个变量用来储存相同颜色的个数。\n        for (int i = 0; i <16; i++) {//需要查询16次\n            if (color[i]==0) {//查询数组中的数字是否与0，1，2，3，4,相等。\n                x0++;\n            }else if (color[i]==1) {\n                x1++;\n            }else if (color[i]==2) {\n                x2++;\n            }else if (color[i]==3) {\n                x3++;\n            }else if (color[i]==4) {\n                x4++;\n            }\n        }\n\n        int[] xx0 =new int[x0];//定义5个数组用来储存相同颜色的位置。\n        int[] xx1 =new int[x1];\n        int[] xx2 =new int[x2];\n        int[] xx3 =new int[x3];\n        int[] xx4 =new int[x4];\n\n\n        int xxx0=0;//用来当做xx0...的索引。\n        if (x0>=4) {//如果相同的颜色的个数大于或者等于4就把他们所对应的位置保存到上面的数组中\n            for (int i = 0; i <16; i++) {\n                if (color[i]==0) {\n                    xx0[xxx0]=i;\n                    xxx0+=1;//每次索引加一。\n                }\n            }\n        }\n        int xxx1=0;\n        if (x1>=4) {\n            for (int i = 0; i <16; i++) {\n                if (color[i]==1) {\n                    xx1[xxx1]=i;\n                    xxx1+=1;\n                }\n            }\n        }\n        int xxx2=0;\n        if (x2>=4) {\n            for (int i = 0; i <16; i++) {\n                if (color[i]==2) {\n                    xx2[xxx2]=i;\n                    xxx2+=1;\n                }\n            }\n        }\n        int xxx3=0;\n        if (x3>=4) {\n            for (int i = 0; i <16; i++) {\n                if (color[i]==3) {\n                    xx3[xxx3]=i;\n                    xxx3+=1;\n                }\n            }\n        }\n        int xxx4=0;\n        if (x4>=4) {//判断组件是否有4个或者以上，如果有输出组件的位置。\n            for (int i = 0; i <16; i++) {\n                if (color[i]==4) {\n                    xx4[xxx4]=i;\n                    xxx4+=1;\n                }\n            }\n        }\n\n\n\n\n位置和数量都有了，就差怎么知道相邻了。4个或4个以上都算。有点像消消乐，但是消消乐只有横排和枞排。\n\n注：每次运行的图形界面不一样", "Tag": "算法分析"}
{"Answer": "因为输入字符后，最后面还有个回车被scanf()读取了，可以使用一个循环读取每行输入后的剩余字符（包括回车符），修改如下：\n\n#include <stdio.h>\n#include <stdlib.h>\nint main()\n{\n    char a;\n    while (1){\n        scanf(\"%c\",&a);\n        \n        while(getchar()!='\\n'){ // 读走每行输入剩余字符 \n            continue;\n        } \n        \n        printf(\"%d\\n\",a);\n    }\n \n \n    \n    system(\"pause\");    // 防止运行后自动退出，需头文件stdlib.h\n    return 0;\n}\n\n", "Konwledge_Point": "算法与数字", "Question": "为什么会输出没有设想的值\n问题遇到的现象和发生背景\n\n\n我在尝试做pat的时候，有的程序的输出预期不在我的意料范围之内。\n\n\n遇到的现象和发生背景，请写出第一个错误信息\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\nint\n \nmain\n()\n\n\n{\n    \nchar\n a;\n    \nwhile\n (\n1\n){\n        \nscanf\n(\n\"%c\"\n,&a);\n        \nprintf\n(\n\"%d\\n\"\n,a);\n    }\n\n\n    \n    \nsystem\n(\n\"pause\"\n);    \n// 防止运行后自动退出，需头文件stdlib.h\n\n    \nreturn\n \n0\n;\n}\n\n\n\n这是我的程序，原本预想着输入一个字母或者数字，输出这个程序的ascII编码，但是实际上输出了令我史料不急的东西\n\n\n1\n\n\n49\n\n\n10\n\n\n2\n\n\n50\n\n\n10\n\n\n3\n\n\n51\n\n\n10\n\n\n4\n\n\n52\n\n\n10\n\n\n5\n\n\n53\n\n\n10\n\n\n6\n\n\n54\n\n\n10\n\n\n7\n\n\n55\n\n\n10\n\n\n8\n\n\n56\n\n\n10\n\n\n9\n\n\n57\n\n\n10\n\n\n0\n\n\n48\n\n\n10\n\n\na\n\n\n97\n\n\n10\n\ns\n\n115\n\n\n10\n\ndf\n\n100\n\n\n102\n\n\n10\n\nf\n\n102\n\n\n10\n\ng\n\n103\n\n\n10\n\nh\n\n104\n\n\n10\n\nj\n\n106\n\n\n10\n\n\nq\n\n\n113\n\n\n10\n\nw\n\n119\n\n\n10\n\ne\n\n101\n\n\n10\n\nr\n\n114\n\n\n10\n\nt\n\n116\n\n\n10\n\ny\n\n121\n\n\n10\n\nu\n\n117\n\n\n10\n\n\ni\n\n\n105\n\n\n10\n\no\n\n111\n\n\n10\n\n\n\n\n这些是我的一些测试，我输入的所有的数字和字母后面输出的除了对应的ascII码之外，还额外有一个10，这是咋回事呢？", "Tag": "算法分析"}
{"Answer": "第10行的for循环结束条件不对，可以改为ch[i]!='\\0'或者i<n，即只判断到输入的字符串最后一个字符，如果是ch[i]!='\\n'，则会数组越界，因为输入的换行使用gets获取字符串不会存储在数组中，所以会访问到超过数组最大下标，直到遇到一个换行符才停止循环。修改如下：参考链接：\n\n\n\n\n\n         https://baike.baidu.com/item/gets/787649\n        \n\n\n\n\n\n\n         http://ascii.wjccx.com/\n        \n\n\n#include<stdio.h>\n#include<string.h>\nint main()\n{\n    char ch[80];\n    int lc,sc,dc,n;\n    lc=sc=dc=0;\n    // https://baike.baidu.com/item/gets/787649?fr=aladdin\n    gets(ch);     //  oaidncpaoIHIOUGLKf093284900fjs \n    n = strlen(ch);\n    // for循环的结束条件改为ch[i]!='\\0'或者i<n，即只判断到输入的字符串最后一个字符 \n    int i;\n    for(i = 0;ch[i]!='\\n';i++)\n    {\n        // http://ascii.wjccx.com/\n    //    printf(\"ch[%d]=%d,ch[%d]=%c\\n\",i,ch[i],i,ch[i]);\n        if(ch[i]>='A'&&ch[i]<='Z')\n            lc++;\n        if(ch[i]>='a'&&ch[i]<='z')\n            sc++;\n        if(ch[i]>='0'&&ch[i]<='9')\n            dc++;\n    }\n   // printf(\"ch[%d]=%d,ch[%d]=%c\\n\",i,ch[i],i,ch[i]);\n        \n    printf(\"共%d个字符\\n其中%d个大写字母\\n %d个小写字母\\n %d个数字\\n\",n,lc,sc,dc);\n    printf(\"其中，大写字母占%.2f，小写字母占%.2f，数字占%.2f。\",(float)lc/n,(float)sc/n,(float)dc/n);\n    return 0;\n \n}\n \n\n", "Konwledge_Point": "算法与数字", "Question": "C语言。统计字符串字数并计算各类字符占总字符数的比例。\nC语言。统计字符串字数并计算各类字符占总字符数的比例。\n如图，显然不对，请问是什么地方出了问题？\n\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\nint\n \nmain\n()\n\n\n{\n    \nchar\n ch[\n80\n];\n    \nint\n lc,sc,dc,n;\n    lc=sc=dc=\n0\n;\n    \ngets\n(ch);\n    n = \nstrlen\n(ch);\n    \nfor\n(\nint\n i = \n0\n;ch[i]!=\n'\\n'\n;i++)\n    {\n        \nif\n(ch[i]>=\n'A'\n&&ch[i]<=\n'Z'\n)\n            lc++;\n        \nif\n(ch[i]>=\n'a'\n&&ch[i]<=\n'z'\n)\n            sc++;\n        \nif\n(ch[i]>=\n'0'\n&&ch[i]<=\n'9'\n)\n            dc++;\n    }\n    \nprintf\n(\n\"共%d个字符\\n其中%d个大写字母\\n %d个小写字母\\n %d个数字\\n\"\n,n,lc,sc,dc);\n    \nprintf\n(\n\"其中，大写字母占%.2f，小写字母占%.2f，数字占%.2f。\"\n,(\nfloat\n)lc/n,(\nfloat\n)sc/n,(\nfloat\n)dc/n);\n    \nreturn\n \n0\n;\n}\n\n", "Tag": "算法分析"}
{"Answer": "看我这篇文章：https://blog.csdn.net/weixin_64811333/article/details/125194636", "Konwledge_Point": "算法与数字", "Question": "数据结构|希望各位帮助一下啊\n一共有n个人，围成一圈，从1开始报数，数到m的人出局，然后重新开始报数。算出出局的人的顺序。要求：用顺序和链式存储两种方法完成\n程序清单\n#include \n#include \n#define N      //游戏参与人数\n#define M     //出局数字\nvoid main()\n{\n\n\n}", "Tag": "算法分析"}
{"Answer": "就是所有的连通的点，以及被周围的0包裹，形成一个岛屿，这个就是一个分块。", "Konwledge_Point": "算法与数字", "Question": "蓝桥杯模拟赛 最大连通 DFS\n求分析一下题目意思，不需要告诉我怎么做，\n只需要举个例子告诉我这个连通分块是什么就行，\n感谢感谢！\n\n\n\n\n问题描述\n小蓝有一个 30 行 60 列的数字矩阵，矩阵中的每个数都是 0 或 1 。\n\n\n\n\n\n\n110010000011111110101001001001101010111011011011101001111110\n\n\n\n010000000001010001101100000010010110001111100010101100011110 \n\n\n\n001011101000100011111111111010000010010101010111001000010100 \n\n\n\n101100001101011101101011011001000110111111010000000110110000 \n\n\n\n010101100100010000111000100111100110001110111101010011001011 \n\n\n\n010011011010011110111101111001001001010111110001101000100011 \n\n\n\n101001011000110100001101011000000110110110100100110111101011 \n\n\n\n101111000000101000111001100010110000100110001001000101011001 \n\n\n\n001110111010001011110000001111100001010101001110011010101110 \n\n\n\n001010101000110001011111001010111111100110000011011111101010 \n\n\n\n011111100011001110100101001011110011000101011000100111001011 \n\n\n\n011010001101011110011011111010111110010100101000110111010110 \n\n\n\n001110000111100100101110001011101010001100010111110111011011 \n\n\n\n111100001000001100010110101100111001001111100100110000001101 \n\n\n\n001110010000000111011110000011000010101000111000000110101101 \n\n\n\n100100011101011111001101001010011111110010111101000010000111 \n\n\n\n110010100110101100001101111101010011000110101100000110001010 \n\n\n\n110101101100001110000100010001001010100010110100100001000011 \n\n\n\n100100000100001101010101001101000101101000000101111110001010 \n\n\n\n101101011010101000111110110000110100000010011111111100110010 \n\n\n\n101111000100000100011000010001011111001010010001010110001010 \n\n\n\n001010001110101010000100010011101001010101101101010111100101 \n\n\n\n001111110000101100010111111100000100101010000001011101100001 \n\n\n\n101011110010000010010110000100001010011111100011011000110010 \n\n\n\n011110010100011101100101111101000001011100001011010001110011 \n\n\n\n000101000101000010010010110111000010101111001101100110011100 \n\n\n\n100011100110011111000110011001111100001110110111001001000111 \n\n\n\n111011000110001000110111011001011110010010010110101000011111 \n\n\n\n011110011110110110011011001011010000100100101010110000010011 \n\n\n\n010011110011100101010101111010001001001111101111101110011101\n\n\n\n\n\n\n\n如果从一个标为 1 的位置可以通过上下左右走到另一个标为 1 的位置，则称两个位置连通。与某一个标为 1 的位置连通的所有位置（包括自己）组成一个连通分块。\n\n\n\n\n\n\n请问矩阵中最大的连通分块有多大？\n\n", "Tag": "算法分析"}
{"Answer": "B=1应该挪到DO 20循环前面", "Konwledge_Point": "算法与数字", "Question": "大家帮我看看，我这个fortran程序错哪儿了？\n我是一名fortran语言初学者，目前跟着书本在学习。有一道例题   求1！+2！+......+N！。我编写的程序如下:\n\n\n\n\n这个程序编译，链接都没问题。算N=1和N=2都没问题，但是算大于等于3的数字就不行了，咋回事儿呢？", "Tag": "算法分析"}
{"Answer": "空指针了么不是，54行这里this后的值都是没有的，有参构造方法里边传值进来没有赋值，这样改一下试试\n public Object_4(String name, int age){\n        this.name=name;\n        this.age=age;\n    }\n\n\n\n", "Konwledge_Point": "算法与数字", "Question": "java中遇到的问题，难以解决\nObject_4.java\n\n\npackage \nJAVA\n;\n\n\npublic\n \nclass\n \nObject_4\n {\n    \nprivate\n \nString\n name;\n    \nprivate\n int age;\n    \n//设置内部类为外部类传递参数参数\n\n    \npublic\n \nObject\n_4(){\n        \n//TODO Auto-generated constructor stub\n\n        \n//添加TODO方法\n\n    }\n    \npublic\n \nObject\n_4(\nString\n name, int age){\n\n    }\n\n    \n//添加Getter和Setter方法。\n\n    \npublic\n \nString\n \ngetName\n(\n) {\n        \nreturn\n name;\n    }\n\n    \npublic\n \nvoid\n \nsetName\n(\nString\n name\n) {\n        \nthis\n.\nname\n = name;\n    }\n\n    \npublic\n int \ngetAge\n(\n) {\n        \nreturn\n age;\n    }\n\n    \npublic\n \nvoid\n \nsetAge\n(\nint age\n) {\n        \nthis\n.\nage\n = age;\n    }\n\n    \n//重构toString方法\n\n\n    \n@Override\n\n    \npublic\n \nString\n \ntoString\n(\n) {\n        \nreturn\n  \n\"姓名：\"\n+\nthis\n.\nname\n+\n\"，年龄:\"\n+\nthis\n.\nage\n;\n    }\n\n    \n//重写equals方法\n\n    \n@Override\n\n    \npublic\n \nboolean\n \nequals\n(\nObject\n obj\n) {\n        \n//判断内存地址\n\n        \nif\n (obj == \nthis\n) {\n            \nreturn\n \ntrue\n;\n        }\n        \nif\n (obj == \nnull\n) {\n            \nreturn\n \nfalse\n;\n        }\n        \n//判断是否是同一类型的对象\n\n        \nif\n (obj \ninstanceof\n \nObject\n_4) {\n            \n//强制转换成Person类型\n\n            \nObject\n_4 s = (\nObject\n_4) obj;\n            \n//判断他们的属性值    注：这里的age为什么要用==？可以在评论区回答\n\n            \nif\n (\nthis\n.\nname\n.\nequals\n(s.\nname\n) && \nthis\n.\nage\n == (s.\nage\n)) {\n                \nreturn\n \ntrue\n;\n            }\n        }\n        \nreturn\n \nfalse\n;\n    }\n}\n\n\n\n\nTest.java\n\n\npackage JAVA;\n\npublic \nclass\n Test04 {\n    public static void main(String\n[]\n args) {\n        Object_4 s1=\nnew\n \nObject_4(\n\"ZYH\"\n,20)\n;\n        Object_4 s2=\nnew\n \nObject_4(\n\"SG\"\n,20)\n;\n        \n//getClass()方法是获得调用该方法的类\n\n        Class class1=s1.get\nClass()\n;\n        Class class2=s2.get\nClass()\n;\n        \nif\n(class1==class2){  \n//class方法的返回值是一个类型\n\n            \nSystem\n.\nout.println(\n\"s1和s2是同一个类型\"\n);\n        }\nelse\n{\n            \nSystem\n.\nout.println(\n\"s1和s2不是同一个类型\"\n);\n        }\n        \nSystem\n.\nout.println(\n\"=======================\"\n);\n        \n//hashCode()方法： 对象的地址字符串或数字使用hash算法计算出来的int类型的数值\n\n        \nSystem\n.\nout.println(s1.hash\nCode()\n);\n        \nSystem\n.\nout.println(s2.hash\nCode()\n);\n        \nSystem\n.\nout.println(\n\"=======================\"\n);\n        \n//toString方法: 返回类名和他的引用地址\n\n        \nSystem\n.\nout.println(s1.\nto\nString()\n);\n        \nSystem\n.\nout.println(s2.\nto\nString()\n);\n        \nSystem\n.\nout.println(\n\"=======================\"\n);\n        \n//equals方法判断两个对象是否相等true/false\n\n        \nSystem\n.\nout.println(s1.equals(s2));\n\n        Object_4 s3=\nnew\n \nObject_4(\n\"小敏\"\n,20)\n;\n        Object_4 s4=\nnew\n \nObject_4(\n\"小敏\"\n,20)\n;\n        \nSystem\n.\nout.println(s3.equals(s4));\n    }\n}\n\n\n\n\n运行Tes.java的时候出现如下报错：\n\n\n\n\n跟着教程来写的，一模一样，但是我的始终不行。\n望帮忙解决，谢谢！！", "Tag": "算法分析"}
{"Answer": "是不一样的。那里应该是一直循环找到列表的最小值。以i=0为例，从第一项开始，找到了比它小的数，就更新min，所以才写作arr[j] < min，以找到最小的值；如果写作arr[j]<arr[i]，那么只要存在比第一项小的数，就会更新min——比如，如果第一项为3，而第二项为1（更新了min），但是第三项为2，2<3，又更新了min，并不是最小的数，就会产生错误。", "Konwledge_Point": "算法与数字", "Question": "各位，帮我看看这个问题，问题在代码里面\n问题遇到的现象和发生背景\n\n\n用代码块功能插入代码，请勿粘贴截图\n\n\n\n\n我想要达到的结果\n\n\n#\ninclude\n \n\n\n\nvoid\n \nmain\n()\n\n\n{\n    \nint\n i, j;\n    \nint\n min;\n    \nint\n pos;\n    \nint\n arr[\n10\n];\n    \nfor\n (i = \n0\n; i < \n10\n; i++)\n    {\n        \nprintf\n(\n\"arr[%d]=\"\n, i);\n        \nscanf\n(\n\"%d\"\n, &arr[i]);\n    }\n    \nfor\n (i = \n0\n; i < \n9\n; i++)\n    {\n        min = arr[i];\n        pos = i;\n        \nfor\n (j = i+\n1\n; j < \n10\n; j++)\n        {\n            \nif\n (arr[j] <min)\n//为什么这个判断不能改成arr[j]<arr[i]，不应该都行吗？\n\n            {\n                min = arr[j];\n                pos = j;\n            }\n        }\n        arr[pos] = arr[i];\n        arr[i] =min;\n    }\n    \nprintf\n(\n\"经过选择排列后的数字为:\\n\"\n);\n    \nfor\n (i = \n0\n; i < \n10\n; i++)\n    {\n        \nprintf\n(\n\"%d\\t\"\n, arr[i]);\n        \nif\n (i == \n4\n)\n            \nprintf\n(\n\"\\n\"\n);\n    }\n     \n}\n为什么这个数字排列，一旦改我上面的判断就不行，为什么不能直接arr[i]，非要一个中间变量min来代替\n\n", "Tag": "算法分析"}
{"Answer": "最高位表示符号位，1表示负数，1010是10，-10的6-bit源码就是：101010", "Konwledge_Point": "算法与数字", "Question": "二进制的原码和补数。\n对于这些问题，输入的答案为二进制值(不带空格)，例如00110。问题中的数字是小数。\n-10作为一个6-bit的原码是多少()\n-64作为8-bit 1的补数是多少()\n-31作为8-bit 2的补数是多少()\n-1作为12-bit 2的补数是多少()", "Tag": "算法分析"}
{"Answer": "#include <stdio.h>\n\nint main()\n{\n    int i, n, zimu = 0, shuzi = 0, fuhao = 0, sum=0;\n    char s[100];\n    scanf(\"%d\", &n);\n    getchar();\n    gets(s);\n    for (i = 0; i < n; i++)\n    {\n        if (s[i] >= 'a' && s[i] <= 'z')\n            zimu = 1;\n        else if (s[i] >= '0' && s[i] <= '9')\n            shuzi = 1;\n        else\n            fuhao = 1;\n    }\n    sum = zimu + shuzi + fuhao;\n    if (sum == 1)\n        printf(\"1\");\n    if (sum == 2)\n        printf(\"2\");\n    if (sum==3)\n        printf(\"3\");\n    return 0;\n}\n", "Konwledge_Point": "算法与数字", "Question": "关于密码强度的题，涉及字符串和ASCII码，本人想知道代码那个地方没有注意到\n这是一道要求用户输入密码，长度为n，判定密码强度等级的题，数字越高代表强度越高。已知密码可以由数字，字母和字符组成，每使用一个强度等级提升一。我的问题是这串代码可以编译运行，但是强度等级却输出不正确。\n\n\n#\ninclude\n \n\n\n\nchar\n s[\n100\n];\n\nint\n \nmain\n()\n\n\n{\n    \nint\n i, n,zimu, shuzi, fuhao, sum=\n0\n;\n    \nscanf\n(\n\"%d\"\n, &n);\n    \ngetchar\n();\n    \ngets\n(s);\n    \nfor\n (i = \n0\n; i < n; i++)\n    {\n        \nif\n (s[i] >= \n'a'\n && s[i] <= \n'z'\n)\n            zimu = \n1\n;\n        \nif\n (s[i] >= \n'0'\n && s[i] <= \n'9'\n)\n            shuzi = \n1\n;\n        \nelse\n\n            fuhao = \n1\n;\n    }\n    sum = zimu + shuzi + fuhao;\n    \nif\n (sum == \n1\n)\n        \nprintf\n(\n\"1\"\n);\n    \nif\n (sum == \n2\n)\n        \nprintf\n(\n\"2\"\n);\n    \nif\n (sum==\n3\n)\n        \nprintf\n(\n\"3\"\n);\n    \nreturn\n \n0\n;\n}\n![img](https:\n//img-mid.csdnimg.cn/release/static/image/mid/ask/205112253666165.jpg \"#left\")\n\n比如这里的应该输出\n1\n，但他输出\n2\n\n\n\n\n\n比如这里的应该输出2，但他输出3\n\n\n但最后这个却能正确输出3", "Tag": "算法分析"}
{"Answer": "宏展开大概是这样子吧。标准C必须要有返回类型，我加上int为返回类型。但是貌似逻辑有问题，运行出错！\n#include<stdio.h>\n\nint r, a;\nint P(y, x)\n{\n    return y - ~y << x;\n}\n\nint Z(x)\n{\n    return r = x % 2 ? 0 : 1 + Z(x / 2);\n}\n\nint L(x)\n{\n    return x / 2 >> Z(x);\n}\n\n\nint S(v, y, c, t)\n{\n    int\n        f = L(t),\n        x = r;\n    {\n        return f - 2 ? f > 2 ? f - v ? t - (f > v) * c : y : P(f, P(S(v, y, c, L(x)), S(v + 2, t = S(4,13,-4, y), c, Z(x))))\n            : A(S(v, y, c, L(x)),\n                S(v, y, c, Z(x)));\n    }\n}\n\nint A(y, x)\n{\n    return L(y) - 1\n               ? 5 << P(y, x)\n               : S(4, x, 4, Z(r));\n}\n\nint D(x)\n{\n    int\n        f,\n        d,\n        c = 0,\n        t = 7,\n        u = 14;\n    while (x && D(x - 1), (x /= 2) % 2 && ( 1))\n      d = L ( L ( D (x) ) ),\n         f = L ( r ),\n         x = L ( r ),\n         c - r || (\n            L ( u) || L ( r) - f ||\n            (x /= 2) % 2 && ( u = S (4, d, 4, r ), \n                   t = A (t, d) ),\n            f / 2 & (x /= 2) % 2 && (  c = P ( d, c ), \n                              t  = S(4,13,-4, t ), \n                              u  = S(4,13,-4, u) )\n             ),\n         c && (x /= 2) % 2 && (\n            t = P (\n               ~u & 2 | (x /= 2) % 2 && (\n                  u = 1 << P ( L ( c ),  u) ), \n               P ( L ( c ),  t) ),\n            c = r  ),\n         u / 2 & (x /= 2) % 2 && ( \n            c = P ( t, c ), \n            u  = S(4,13,-4, t ), \n            t = 9 );\n    {\n        return a = P(P(t, P(u, P(x, c))),\n                     a);\n    }\n}\nint main()\n{\n    return D(D(D(D(D(99)))));\n}\n\n\n\n", "Konwledge_Point": "算法与数字", "Question": "有什么办法比较方便的直接替换宏吗？或者看一下这个程序替换宏后的样子？\n有没有什么工具或是编译器、方法之类的能自动替换宏定义？\n是有一个程序为了尽可能节省字符数量用了大量宏定义，我想看懂它，但全是宏实在看不明白\n\n\n#define\n \nR\n \n{\n \nreturn\n\n\n#define\n \nP\n \nP\n \n(\n\n\n#define\n \nL\n \nL\n \n(\n\n\n#define\n \nT\n \nS\n \n(\nv\n,\n \ny\n,\n \nc\n,\n\n\n#define\n \nC\n \n)\n,\n\n\n#define\n \nX\n \nx\n)\n\n\n#define\n \nF\n \n)\n;\n}\n\n\n\nint\n \nr\n,\n \na\n;\n\n\nP\n \ny\n,\n \nX\n\n   \nR\n \ny\n \n-\n \n~\ny\n \n<<\n \nx\n;\n\n\n}\n\n\nZ\n \n(\nX\n\n   \nR\n \nr\n \n=\n \nx\n \n%\n \n2\n \n?\n \n0\n \n:\n \n1\n \n+\n \nZ\n \n(\nx\n \n/\n \n2\n \nF\n\n\nL\n \nX\n\n   \nR\n \nx\n \n/\n \n2\n \n>>\n \nZ\n \n(\nx\n \nF\n\n\n#define\n \nU\n \n=\n \nS\n(\n4\n,\n13\n,-\n4\n,\n\n\nT\n  \nt\n)\n\n\n{\n\n   \nint\n\n      \nf\n \n=\n \nL\n \nt\n \nC\n         \n      \nx\n \n=\n \nr\n;\n\n   \nR\n\n         \nf\n \n-\n \n2\n \n?\n\n         \nf\n \n>\n \n2\n \n?\n\n         \nf\n \n-\n \nv\n \n?\n \nt\n \n-\n \n(\nf\n \n>\n \nv\n)\n \n*\n \nc\n \n:\n \ny\n \n:\n\n         \nP\n \nf\n,\n \nP\n \nT\n  \nL\n \nX\n  \nC\n \n                          \nS\n \n(\nv\n+\n2\n,\n \nt\n  \nU\n \ny\n \nC\n  \nc\n,\n \nZ\n \n(\nX\n \n)\n)\n)\n\n         \n:\n\n         \nA\n \n(\nT\n  \nL\n \nX\n  \nC\n \n                \nT\n  \nZ\n \n(\nX\n \n)\n \nF\n\n\n}\n\n\nA\n \n(\ny\n,\n \nX\n\n   \nR\n \nL\n \ny\n)\n \n-\n \n1\n\n      \n?\n \n5\n \n<<\n \nP\n \ny\n,\n \nX\n \n      \n:\n \nS\n \n(\n4\n,\n \nx\n,\n \n4\n,\n \nZ\n \n(\nr\n)\n \nF\n\n\n#define\n \nB\n \n(\nx\n \n/=\n \n2\n)\n \n%\n \n2\n \n&&\n \n(\n\n\nD\n \n(\nX\n \n\n{\n\n   \nint\n\n      \nf\n,\n\n      \nd\n,\n\n      \nc\n \n=\n \n0\n,\n\n      \nt\n \n=\n \n7\n,\n\n      \nu\n \n=\n \n14\n;\n\n   \nwhile\n \n(\nx\n \n&&\n \nD\n \n(\nx\n \n-\n \n1\n \nC\n  \nB\n \n1\n)\n)\n\n      \nd\n \n=\n \nL\n \nL\n \nD\n \n(\nX\n \n)\n \nC\n\n         \nf\n \n=\n \nL\n \nr\n \nC\n\n         \nx\n \n=\n \nL\n \nr\n \nC\n\n         \nc\n \n-\n \nr\n \n||\n \n(\n\n            \nL\n \nu\n)\n \n||\n \nL\n \nr\n)\n \n-\n \nf\n \n||\n\n            \nB\n \nu\n \n=\n \nS\n \n(\n4\n,\n \nd\n,\n \n4\n,\n \nr\n \nC\n \n                   \nt\n \n=\n \nA\n \n(\nt\n,\n \nd\n)\n \nC\n\n            \nf\n \n/\n \n2\n \n&\n \nB\n  \nc\n \n=\n \nP\n \nd\n,\n \nc\n \nC\n \n                              \nt\n  \nU\n \nt\n \nC\n \n                              \nu\n  \nU\n \nu\n)\n \n)\n\n             \nC\n\n         \nc\n \n&&\n \nB\n\n            \nt\n \n=\n \nP\n\n               \n~\nu\n \n&\n \n2\n \n|\n \nB\n\n                  \nu\n \n=\n \n1\n \n<<\n \nP\n \nL\n \nc\n \nC\n  \nu\n)\n \nC\n \n               \nP\n \nL\n \nc\n \nC\n  \nt\n)\n \nC\n\n            \nc\n \n=\n \nr\n  \nC\n\n         \nu\n \n/\n \n2\n \n&\n \nB\n \n            \nc\n \n=\n \nP\n \nt\n,\n \nc\n \nC\n \n            \nu\n  \nU\n \nt\n \nC\n \n            \nt\n \n=\n \n9\n \n)\n;\n\n   \nR\n \na\n \n=\n \nP\n \nP\n \nt\n,\n \nP\n \nu\n,\n \nP\n \nx\n,\n \nc\n)\n)\n \nC\n \n                                \na\n \nF\n\n\n}\n\n\nmain\n \n(\n)\n\n   \nR\n \nD\n \n(\nD\n \n(\nD\n \n(\nD\n \n(\nD\n \n(\n99\n)\n)\n)\n)\n \nF\n\n\n\n\n\nPS：这是一个在假设无限大内存没有整形上限的情况下，输出一个巨大的数字的程序，这个数字非常大，远远超越想象。所以我想知道生成这个数字的D函数的工作原理", "Tag": "算法分析"}
{"Answer": "用哈希表", "Konwledge_Point": "算法与数字", "Question": "vJudge 提交 一直超时\n题目：\n给出包含n个元素的数组a，求a中距离最近的一对 i,j，满足i < j 且 a[i] == a[j]。如果同时存在多对，输出最小的 i 对应的a[i]。\n\n\n例如：10个数\n19,13,11,19,11,5,6,3,4,3\n满足存在a[i]=a[j]的数字包括：19,11,3。其中11,3这两对的距离更近，在距离相同的情况下，11的下标更靠前。如果不存在相同的数字，输出 \"No\"\n\n\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\nint\n \nmain\n()\n \n{\n    \nint\n size;\n    cin >> size;\n    \nint\n* arr = \nnew\n \nint\n[size];\n    \nfor\n (\nint\n i = \n0\n; i < size; i++) {\n        \nscanf\n(\n\"%d\"\n, arr + i);\n    }\n    \nint\n min = INT_MAX;\n    \nint\n minnum = INT_MAX;\n    \nfor\n (\nint\n i = \n0\n; i < size; i++) {\n        \nfor\n (\nint\n k = i + \n1\n; k < size; k++) {\n            \nif\n ((arr[i] == arr[k]) && (k - i) < min) {\n                min = k - i;\n                minnum = arr[i];\n                \nbreak\n;\n            }\n        }\n    }\n    \nif\n (minnum == INT_MAX) {\n        cout << \n\"No\\n\"\n;\n    }\nelse\n cout << minnum;\n}\n\n\n\n学院让在vjudge 上交题\n我寻思 这个都超时了 ，还有更快的吗？", "Tag": "算法分析"}
{"Answer": "\n#include <bits/stdc++.h>\n\nusing namespace std ;\n\nconst int N = 1010 ;\nint n , m , res ;\nint g[N][N] , f[N][N] ;\nint dx[4] = {-1 , 0 , 1 , 0} , dy[4] = {0 , 1 , 0 , -1} ;\n\nint dp (int x , int y)\n{\n    int & v = f[x][y] ;\n    if (v != -1) return v ;\n    else v = 1 ;\n    for (int i = 0; i < 4; i++)\n    {\n        int xx = x + dx[i] , yy = y + dy[i] ;\n        if (xx >= 1 && xx <= n && yy >= 1 && yy <= m && g[x][y] > g[xx][yy])\n        {\n            v = max (v , dp (xx , yy) + 1) ;\n        }\n    }\n    return v ;\n}\n\nint main ()\n{\n\n\n    cin >> n >> m ;\n    memset (f , -1 , sizeof (f)) ;\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= m; j++)  cin >> g[i][j] ;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= m; j++) res = max (res , dp (i , j)) ;\n    }\n    cout << res << endl ;\n\n\n    return 0 ;\n}\n\n\n", "Konwledge_Point": "算法与数字", "Question": "C爱滑雪 不会啊 希望思路+解析\n问题遇到的现象和发生背景\n\n\n今天在做题的时候，遇到一道搜索题.\n\n\n问题相关代码，请勿粘贴截图\n\n\n描述\nC teacher喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而\n且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。C想知道在一个区域中最长的滑\n坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子：\n1 2 3 4 5\n16 17 18 19 6\n15 24 25 20 7\n14 23 22 21 8\n13 12 11 10 9\n一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可行的\n滑坡为24 17 16 1（从24开始，在1结束）。当然25 24 23  3 2 1更长。事实上，这是\n最长的一条。\n输入\n输入的第一行为表示区域的二维数组的行数R和列数C（1≤R，C≤100）。下面是R行，每行有C个数，代\n表高度(两个数字之间用1个空格间隔)。\n输出\n输出区域中最长滑坡的长度。\n输入样例 1\n输出样例 1\n5 5\n1 2 3 4 5\n16 17 18 19 6\n15 24 25 20 7\n14 23 22 21 8\n13 12 11 10 9\n25\n\n\n运行结果及报错内容\n\n\n运行后我超时了\n\n\n我想要达到的结果\n\n\n希望有人作详细的注释解析，我在网上看了没懂！", "Tag": "算法分析"}
{"Answer": "#include#includeusing namespace std;int main(){    int i;    string n;    cin>>n;    printf(\"%c%c%c%c\\n\",n[0],n[1],n[6],n[7]);//因为只需要输出新同学的年级和班级，而年级是你输入的学号的第一和第二位字符，班级是第七和第八位字符，所以直接输出即可}", "Konwledge_Point": "算法与数字", "Question": "c++同学入学同学班级年纪\n9月5日早晨，四中正式进入迎新模式，众多新生和家长就早早来到迎新现场开始报道流程，该校各学院结合自身特色开展了创意十足的迎新活动：元素墙上每个“元素”后学长学姐留下的期待，迎新现场舞动的机器人，照片墙上新生与父母的合影……让新生和家长在了解了学校的情况下，更感受到了浓浓暖意和初中生活的精彩。\n“同学，你好！请问你是哪个班的？”\n仅一行。一个10位的正整数No（2000≤学生入学年份≤2050），表示新同学的学号，学号中从左向右数，第1-2位表示其所在的年级，第7-8位表示其所在的班级。\n仅一行。四位数字，表示新同学所在的年级及班级（其中年级和班级各占2位）。\n1602031104\n1611\n这个需要用string吗？不懂怎么用代码实现", "Tag": "算法分析"}
{"Answer": "44（10）=101100", "Konwledge_Point": "算法与数字", "Question": "十进制转二进制和浮点数\n首先，把44（10）转换成二进制，然后在这里输入答案     {}。\n在纸上标准化的答案，使它从0.1开始，并计算2的幂，这将是浮点数答案的指数值。在这里输入规范化的值   ()(必须从0.1开始，只输入您需要的数字)．\n在这里输入2的指数    ()(必须是一个小数)．\n输入44(10)浮点表示的完整16位二进制版本  ()(它必须是二进制且必须有16位)", "Tag": "算法分析"}
{"Answer": "第二个for循环是不是应该用 i < j", "Konwledge_Point": "算法与数字", "Question": "素数筛法求素数求解答\nc++任务描述\n本关任务：素数筛法求素数。\n\n\n编程要求\n用素数筛法求出2~N以内的所有素数并输出。每5个数字输出一行，每个数字之间用空格分隔开。\n\n\n测试说明\n我会对你编写的代码进行测试：\n\n\n样例输入：\n100\n样例输出：\n请输入N的值：\n2 3 5 7 11\n13 17 19 23 29\n31 37 41 43 47\n53 59 61 67 71\n73 79 83 89 97\n\n\n开始你的任务吧，祝你成功！\n\n\n#include\nint fac(int x )\n{\nint i,t=0,y;\n for(i=1;i<=x;i++){\n     if(x%i==0){\nt++;\n\n\n }else{\ncontinue;\n }          }\n\n\nif(t==2){\ny=x;\n}else{\ny=0;\n}\nreturn y;\n}\n\n\nint main()\n{int fac(int x );\n    int i,j,n,k;\n    scanf(\"%d\",&n);\n    int a[999];\n    for(i=2,j=0;i<=n;i++){\n    if(fac(i)!=i) continue;\n    a[j]=i;    j++;\n    }\n    for(i=0,k=1;i<=j;i++,k++){\n    printf(\"%ld\",a[i]);\nif(k%5==0){\nprintf(\"\\n\");\n}else{\nprintf(\" \");\n}\n}\n    return 0;\n}\n\n\n为什么我的代码运行后总是多出一个奇怪的数据", "Tag": "算法分析"}
{"Answer": "你的 count 变量在每次调用 darray() 函数的时候都对原来的数组进行排序删除重复，然后 count-- 改变了原来的值，随着调用次数增加，你这个 count 变量一直在减，逻辑出问题了。要么你在 darray() 函数开始的地方加上 count = COUNT; 重新赋值，应该就可以了。", "Konwledge_Point": "算法与数字", "Question": "程序有错误，在删除数组那里\n写这个程序  在删除重复数组的时候 ，当他自己执行模块的时候是正确的，但当把所有都输出的时候，删除数组哪里就有一个数字没有了\n\n\n#include\n<\nstdio.h\n>\n\n#define \nCOUNT\n \n6\n\nint a[\nCOUNT\n], count \n=\n \nCOUNT\n, k, m, b[\nCOUNT\n],t,c[\nCOUNT\n];\nvoid oarray(){  \n//输出原数组\n\n    printf(\n\"原数组:\"\n);\n    \nfor\n (k \n=\n \n0\n; k \n<\n \nCOUNT\n; k\n++\n)\n        printf(\n\"%5d\"\n, b[k]);\n    printf(\n\"\n\\n\n\"\n);\n}\n\nvoid sort(){  \n//排序算法\n\n    \nfor\n(k\n=\n0\n;k\n<\nCOUNT\n-\n1\n;k\n++\n)  \n//排序数组\n\n            \nfor\n(m\n=\nk\n+\n1\n;m\n<\nCOUNT\n;m\n++\n)\n                \nif\n (c[k] \n>\n c[m]) {\n                    t \n=\n c[k];\n                    c[k] \n=\n c[m];\n                    c[m] \n=\n t;\n                }\n        \nfor\n (k \n=\n \n0\n; k \n<\n \nCOUNT\n; k\n++\n)\n            a[k] \n=\n c[k];\n        printf(\n\"排序后数组为:\"\n);\n        \nfor\n (k \n=\n \n0\n; k \n<\n \nCOUNT\n; k\n++\n)\n        printf(\n\"%5d\"\n, c[k]);\n    printf(\n\"\n\\n\n\"\n);\n}\n\nvoid darray(){  \n//删除重复数组\n\n\n        \nfor\n(k\n=\n0\n;k\n<\nCOUNT\n-\n1\n;k\n++\n)  \n//排序数组\n\n            \nfor\n(m\n=\nk\n+\n1\n;m\n<\nCOUNT\n;m\n++\n)\n                \nif\n (c[k] \n>\n c[m]) {\n                    t \n=\n c[k];\n                    c[k] \n=\n c[m];\n                    c[m] \n=\n t;\n                }\n        \nfor\n (k \n=\n \n0\n; k \n<\n \nCOUNT\n; k\n++\n)\n            a[k] \n=\n c[k];\n    \n    \nfor\n (k \n=\n \nCOUNT\n \n-\n \n1\n; k \n>\n \n0\n; k\n--\n) \n//删除重复数组\n\n        \nif\n (a[k] \n==\n a[k \n-\n \n1\n]) {\n            \nfor\n (m \n=\n k \n-\n \n1\n; m \n<\n \nCOUNT\n \n-\n \n1\n; m\n++\n)\n                a[m] \n=\n a[m \n+\n \n1\n];\n            count\n--\n;\n        }\n            printf(\n\"删除重复后的数组:\"\n);\n    \nfor\n (k \n=\n \n0\n; k \n<\n count; k\n++\n)\n        printf(\n\"%5d\"\n, a[k]);\n    printf(\n\"\n\\n\n\"\n);\n\n\n}\n \nvoid choose(){  \n//选项\n\n    printf(\n\"选择选项:\n\\n\n\\n\n\"\n);\n    printf(\n\"1.输出原数组\n\\n\n\\n\n\"\n);\n    printf(\n\"2.输出排序后数组\n\\n\n\\n\n\"\n);\n    printf(\n\"3.输出删除重复后的数组\n\\n\n\\n\n\"\n);\n    printf(\n\"4.输出所有\n\\n\n\\n\n\"\n);\n    printf(\n\"5.退出\n\\n\n\\n\n\"\n);\n    printf(\n\"请输入数据1,2,3,4,5\n\\n\n\\n\n\"\n);\n    int x;\n    printf(\n\"\n\\n\n\\n\n\"\n);\n    \ndo\n{\n  \n        scanf(\n\"%d\"\n,\n&\nx);\n        \nswitch\n(x){\n        \ncase\n \n1\n: oarray(); printf(\n\"退出按5\n\\n\n\\n\n\"\n);    \nbreak\n;  \n        \ncase\n \n2\n: sort(); printf(\n\"退出按5\n\\n\n\\n\n\"\n);    \nbreak\n; \n        \ncase\n \n3\n: darray(); printf(\n\"退出按5\n\\n\n\\n\n\"\n);    \nbreak\n; \n        \ncase\n \n4\n: oarray();sort();darray();     printf(\n\"退出按5\n\\n\n\\n\n\"\n);    \nbreak\n; \n        \ncase\n \n5\n: \nbreak\n;\n        \ndefault\n:\nbreak\n;\n        }\n    }\nwhile\n(x\n!=\n5\n);\n}\n\n\nvoid main(){\n    \n\n    printf(\n\"Input %d data in order:\n\\n\n\"\n, \nCOUNT\n);\n\nfor\n (k \n=\n \n0\n; k \n<\n \nCOUNT\n; k\n++\n) {  \n        printf(\n\"a[%d]=\"\n, k);\n        scanf(\n\"%d\"\n, \n&\na[k]);\n        b[k] \n=\n a[k], c[k] \n=\n a[k];\n    }\n    \n    oarray();\n    choose();\n\n\n    \n//system(\"pause\");\n\n\n\n}\n\n\n\n", "Tag": "算法分析"}
{"Answer": "\na='((A+B-7*(6-5)'\nstack=[]\nerror=[]\nfor i,j in enumerate(a):\n    if j=='(':\n        stack.append([i,j])\n    if j==')':\n        if stack:\n            if stack[-1][-1]=='(':\n                stack.pop()\n            else:\n                error.append((i,1))\n        else:\n            error.append((i,1))\nwhile stack:\n    temp=stack.pop()\n    if temp[-1]=='(':\n        error.append((temp[0],2))\n    else:\n        error.append((temp[0],1))\nL=[' ' for _ in range(len(a))]\nfor i in error:\n    if i[-1]==1:\n        L[i[0]]='?'\n    else:\n        L[i[0]]='$'\nprint(a)\nprint(''.join(L))\n", "Konwledge_Point": "算法与数字", "Question": "python判断括号是否匹配\n输入一个表达式(长度小于100)，该表达式可以包括开括号、闭括号、数字、符号和字母，例如:\nY = 4 * 5 + (x 7) * 10\n请编写一个程序来查找不平衡的括号。在一行中输出表达式，并在表达式下面标记不平衡的括号。不平衡的左括号被标记为“$”，不平衡的右括号被标记为“?”。\n输出的例子:\n((A+B-7*(6-5)\n$$\n)(r+5-(e-6))/9-8)(\n？              ?$", "Tag": "算法分析"}
{"Answer": "这是我写的测试类，写的不怎么好，但是基本能够进行测试，在网上几乎没有搜出相应的解决方法，可能是测试servlet功能不流行吧，不过话说，开发中都不用纯servler的。\r\n\r\n\r\n```\r\n import static org.junit.Assert.*;\r\n\r\nimport java.io.IOException;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport javax.servlet.http.HttpSession;\r\n\r\nimport org.apache.log4j.Logger;\r\nimport org.easymock.EasyMock;\r\nimport org.junit.Test;\r\nimport org.springframework.mock.web.MockHttpSession;\r\n\r\npublic class ValidateCodeServletTest {\r\n\tprivate static Logger logger = Logger.getLogger(ValidateCodeServletTest.class);\r\n\r\n\t@Test\r\n\tpublic void testServiceHttpServletRequestHttpServletResponse() {\r\n\t\tHttpServletRequest reqMock = EasyMock.createMock(HttpServletRequest.class);\r\n\t\tHttpServletResponse respMock = EasyMock.createMock(HttpServletResponse.class);\r\n\t\t\r\n\t\tHttpSession session = new MockHttpSession();\r\n\t\t\r\n\t\tEasyMock.expect(reqMock.getSession()).andReturn(session);\r\n\t\tEasyMock.replay(reqMock);\r\n\t\t\r\n\t\tValidateCodeServlet test = new ValidateCodeServlet();\r\n\t\ttest.init();\r\n\t\ttry {\r\n\t\t\ttest.service(reqMock, respMock);\r\n\t\t} catch (ServletException e) {\r\n\t\t\tlogger.error(\"调用验证码出异常\", e);\r\n\t\t} catch (IOException e) {\r\n\t\t\tlogger.error(\"输入输出流抛出异常\", e);\r\n\t\t}\r\n\t\t\r\n\t\tEasyMock.verify(reqMock);\r\n\t}\r\n}\r\n```", "Konwledge_Point": "算法与数字", "Question": "悬赏如何junit测试返回值void的输出验证码图片功能的servlet！\n刚接触到验证码生成算法，由于楼主刚入职职场，刚接触junit测试，知道junit是白盒子测试，也只会用代用返回值的测试。现在我要写一个生成验证码的serlvet,此serlvet可以向客户端返回一个验证码的jpg图片。请问如果用junit来测试这个类的生成验证码功能是否生效？我知道难度可能有点大，所以希望大神耐心解答，50分献上！\n\n\n\n\n public class ValidateCodeServlet extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    // 设置验证图片的宽度, 高度, 验证码的个数\n    private int width = 152;\n    private int height = 40;\n    private int codeCount = 4;\n\n    // 验证码字体的高度\n    private int fontHeight = 4;\n\n    // 验证码中的单个字符基线. 即：验证码中的单个字符位于验证码图形左上角的 (codeX, codeY) 位置处\n    private int codeX = 0;\n    private int codeY = 0;\n\n    // 验证码由哪些字符组成\n    char[] codeSequence = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz23456789\"\n            .toCharArray();\n\n    // 初始化验证码图形属性\n    @Override\n    public void init() {\n        fontHeight = height - 2;\n        codeX = width / (codeCount + 2);\n        codeY = height - 4;\n    }\n\n    @Override\n    public void service(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        // 定义一个类型为 BufferedImage.TYPE_INT_BGR 类型的图像缓存\n        BufferedImage buffImg = null;\n        buffImg = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);\n\n        // 在 buffImg 中创建一个 Graphics2D 图像\n        Graphics2D graphics = null;\n        graphics = buffImg.createGraphics();\n\n        // 设置一个颜色, 使 Graphics2D 对象的后续图形使用这个颜色\n        graphics.setColor(Color.WHITE);\n\n        // 填充一个指定的矩形: x - 要填充矩形的 x 坐标; y - 要填充矩形的 y 坐标; width - 要填充矩形的宽度; height\n        // - 要填充矩形的高度\n        graphics.fillRect(0, 0, width, height);\n\n        // 创建一个 Font 对象: name - 字体名称; style - Font 的样式常量; size - Font 的点大小\n        Font font = null;\n        font = new Font(\"\", Font.BOLD, fontHeight);\n        // 使 Graphics2D 对象的后续图形使用此字体\n        graphics.setFont(font);\n\n        graphics.setColor(Color.BLACK);\n\n        // 绘制指定矩形的边框, 绘制出的矩形将比构件宽一个也高一个像素\n        graphics.drawRect(0, 0, width - 1, height - 1);\n\n        // 随机产生 15 条干扰线, 使图像中的认证码不易被其它程序探测到\n        Random random = null;\n        random = new Random();\n        graphics.setColor(Color.GREEN);\n        for (int i = 0; i < 10; i++) {\n            int x = random.nextInt(width);\n            int y = random.nextInt(height);\n            int x1 = random.nextInt(20);\n            int y1 = random.nextInt(20);\n            graphics.drawLine(x, y, x + x1, y + y1);\n        }\n\n        // 创建 randomCode 对象, 用于保存随机产生的验证码, 以便用户登录后进行验证\n        StringBuffer randomCode;\n        randomCode = new StringBuffer();\n\n        for (int i = 0; i < codeCount; i++) {\n            // 得到随机产生的验证码数字\n            String strRand = null;\n            strRand = String.valueOf(codeSequence[random.nextInt(36)]);\n\n            // 用随机产生的颜色将验证码绘制到图像中\n            graphics.setColor(Color.BLUE);\n            graphics.drawString(strRand, (i + 1) * codeX, codeY);\n\n            // System.out.println(\"^^\" + strRand);\n            randomCode.append(strRand);\n        }\n\n        //向session中写入验证码信息\n        request.getSession().setAttribute(\"checkCode\", randomCode.toString());\n\n        // 禁止图像缓存\n        response.setHeader(\"Pragma\", \"no-cache\");\n        response.setHeader(\"Cache-Control\", \"no-cache\");\n        response.setDateHeader(\"Expires\", 0);\n\n        // 将图像输出到输出流中\n        ServletOutputStream sos = null;\n        sos = response.getOutputStream();\n        ImageIO.write(buffImg, \"jpeg\", sos);\n        sos.close();\n    }\n}\n", "Tag": "算法分析"}
{"Answer": "在解析文本的时候，是根据Huffman树来解析压缩文本的.因为所有的字符都在叶子节点上，所以解析查找字符的时候直接找到叶子节点就可以取出对应的字符了；", "Konwledge_Point": "算法与数字", "Question": "关于同一二叉树的最佳前缀码的疑问\n\n\n如图，黑色方框内的是重点，其余的圈画请自行忽略。\n可以看到有三个权值为10的八进制数，分别是3.4.5，最优二叉树没问题，问题在于三个权值都是10的八进制数的最佳前缀码，怎么知道哪个最佳前缀码对应哪个八进制数呢？图一说100亻专3，101传4，0001亻专5，既然权值相同，而且画最优二叉树的时候只看权值，也不看权值对应的八进制数字，那么能不能让101传3，0001传4，100传5呢？", "Tag": "算法分析"}
{"Answer": "三重for为什么会有重复的", "Konwledge_Point": "算法与数字", "Question": "java：10 是一个非常特殊的数，它可以表示成两个非负整数的平方和 9 = 3 * 3 + 0 * 0。 　\n10 是一个非常特殊的数，它可以表示成两个非负整数的平方和，10 = 3 * 3 + 1 * 1。\n9 也是同样特殊的数，它可以表示成 9 = 3 * 3 + 0 * 0。\n　　请问，在 1 到 2021 中有多少个这样的数？\n　　请注意，有的数有多种表示方法，例如 25 = 5 * 5 + 0 * 0 = 3 * 3 + 4 * 4，在算答案时只算一次。\njava可以用3重for循环暴力出所有这样的数，但是会有重复的数字，用java解决，有更好的办法吗", "Tag": "算法分析"}
{"Answer": "该回答引用GPTᴼᴾᴱᴺᴬᴵ要实现一个基数排序的UI界面程序，需要以下几个步骤：\n设计UI界面：可以使用Python的GUI库（如Tkinter、PyQt、wxPython等）进行设计，添加输入框、按钮、文本框等组件，用于用户输入数据、选择排序方式等操作，并显示排序结果、时间复杂度、空间复杂度等信息。编写基数排序算法：可以使用Python编写基数排序算法函数，函数输入为待排序的整数列表和排序方式（如升序、降序、按照个位、十位、百位等排序），输出为排序后的整数列表。在函数内部实现基数排序的各个步骤，如桶的初始化、按照位数排序、桶合并等。实现UI与算法的交互：将UI界面中用户输入的数据传递给基数排序算法函数进行排序，然后将排序结果显示在UI界面上。同时，在排序完成后，计算时间复杂度和空间复杂度，并将其显示在UI界面上。实现异常处理：在程序中加入异常处理机制，对用户输入的数据进行判断，如果不符合要求（如长度不为m），则弹出提示框提醒用户重新输入。\n在完成以上步骤后，即可实现一个基数排序的UI界面程序，用户可以输入数据，选择排序方式，查看排序结果和相关信息。\n以下是一个 Python 的基数排序的示例程序，同时满足基本要求中的要求：\nimport tkinter as tk\nimport time\nimport random\n\n# 排序函数\ndef radix_sort(nums):\n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n\n    while placement < max_digit:\n        buckets = [list() for _ in range(RADIX)]\n        for i in nums:\n            tmp = int((i / placement) % RADIX)\n            buckets[tmp].append(i)\n\n        a = 0\n        for b in range(RADIX):\n            buck = buckets[b]\n            for i in buck:\n                nums[a] = i\n                a += 1\n\n        placement *= RADIX\n    return nums\n\n# 生成随机整数\ndef gen_random_int(n, m):\n    return [random.randint(10 ** (m-1), 10 ** m - 1) for _ in range(n)]\n\n# 排序并显示结果\ndef sort_and_display():\n    n = int(n_entry.get())\n    m = int(m_entry.get())\n\n    if len(n_entry.get()) == 0 or len(m_entry.get()) == 0:\n        result_label.config(text='请输入n和m')\n        return\n\n    if n <= 0 or m <= 0:\n        result_label.config(text='n和m必须为正整数')\n        return\n\n    nums = gen_random_int(n, m)\n\n    start_time = time.time()\n\n    # 排序方式1：基数排序\n    result1 = radix_sort(nums.copy())\n    time1 = time.time() - start_time\n    space1 = len(result1)\n\n    start_time = time.time()\n\n    # 排序方式2：快速排序\n    result2 = sorted(nums.copy())\n    time2 = time.time() - start_time\n    space2 = len(result2)\n\n    start_time = time.time()\n\n    # 排序方式3：冒泡排序\n    result3 = nums.copy()\n    for i in range(len(result3)):\n        for j in range(len(result3) - 1):\n            if result3[j] > result3[j+1]:\n                result3[j], result3[j+1] = result3[j+1], result3[j]\n    time3 = time.time() - start_time\n    space3 = len(result3)\n\n    start_time = time.time()\n\n    # 排序方式4：插入排序\n    result4 = nums.copy()\n    for i in range(1, len(result4)):\n        key_item = result4[i]\n        j = i - 1\n        while j >= 0 and result4[j] > key_item:\n            result4[j + 1] = result4[j]\n            j -= 1\n        result4[j + 1] = key_item\n    time4 = time.time() - start_time\n    space4 = len(result4)\n\n    # 显示结果\n    result_label.config(text='排序方式1（基数排序）：' + ','.join(map(str, result1)) + '\\n时间：{:.6f}s，空间复杂度：{}个\\n\\n'.format(time1, space1) +\n                             '排序方式2（快速排序）：' + ','.join(map(str, result2)) + '\\n时间：{:.6f}s，空间复杂度：{}个\\n\\n'.format(time2, space2) +\n                             '排序方式3（冒泡排序）：' + ','.\n\n\n", "Konwledge_Point": "算法与数字", "Question": "Python数据结构，基数排序\nPython数据结构\n要用UI界面，不能在控制台输出，怎么做UI界面呀，在网上看的都是教做学生信息管理系统之类的，不知道怎么做这种\n下面是题目：\n基数排序：从键盘上输入n个长度为m的整数，要求输出这些整数的升序\n和降序排列。\n基本要求：(1)不少于4种排序方式；\n(2)界面显示每种排序结果；\n(3)同时显示排序的时间和空间复杂度；\n(4)程序对所输入的数字进行判断，如果不是所要求的长度，弹出提醒消息\n框；\n(5)输出结果以逗号隔开。", "Tag": "算法分析"}
{"Answer": "var Reg = /^[+-\\d].*?/;//以+，-或者数字开头的字符串\nif(!Reg.test(usernamevalue)){//不是以+，-或者数字开头的字符串就执行\n\n}\n\n", "Konwledge_Point": "算法与数字", "Question": "javascript编写计算器的小问题\n问题遇到的现象和发生背景\n用javascript写一个计算器，现在想让输入的第一个值不能为乘号，除号，取余号，但是可以为加号和减号。\n\n\n问题相关代码，请勿粘贴截图\n在这个函数中\n\n\n\n\n\n\n    \n<\nstyle\n>\n\n        \n.top\n{\n            \nwidth\n: \n465px\n;\n            \nheight\n: \n60px\n;\n            \nmargin\n: auto;\n            \nbackground-color\n: gray;\n            \nmargin-top\n: \n100px\n;\n            \nborder-top-right-radius\n: \n10px\n;\n            \nborder-top-left-radius\n: \n10px\n;\n        }\n\n        \n.point-red\n{\n            \nwidth\n: \n20px\n;\n            \nheight\n: \n20px\n;\n            \nbackground-color\n: red;\n            \nfloat\n: left; \n/*浮动，可以让其不独占一行*/\n\n            \nmargin-left\n: \n20px\n;\n            \nmargin-top\n: \n20px\n;\n            \nborder-radius\n: \n50%\n;\n/* 通过这个指令将正方形改为一个圆 */\n\n            \n        }\n\n        \n.point-blue\n{\n            \nwidth\n: \n20px\n;\n            \nheight\n: \n20px\n;\n            \nbackground-color\n: blue;\n            \nfloat\n: left; \n/*浮动，可以让其不独占一行*/\n\n            \nmargin-left\n: \n20px\n;\n            \nmargin-top\n: \n20px\n;\n            \nborder-radius\n: \n50%\n;\n/* 通过这个指令将正方形改为一个圆 */\n\n        }\n\n        \n.point-green\n{\n            \nwidth\n: \n20px\n;\n            \nheight\n: \n20px\n;\n            \nbackground-color\n: green;\n            \nfloat\n: left; \n/*浮动，可以让其不独占一行*/\n\n            \nmargin-left\n: \n20px\n;\n            \nmargin-top\n: \n20px\n;\n            \nborder-radius\n: \n50%\n;\n/* 通过这个指令将正方形改为一个圆 */\n\n        }\n\n\n        \n#counter\n{\n            \nfont-size\n: \n25px\n;\n            \ncolor\n: white;\n            \nfloat\n: right;\n            \nline-height\n: \n60px\n;\n            \nmargin-right\n: \n35px\n;\n        }\n\n\n        \n/* 设置显示结果和计算过程的部分 */\n\n        \n#result\n{\n            \nwidth\n: \n451px\n;\n            \nheight\n: \n55px\n;\n            \nborder\n: \n2px\n solid brown;\n            \nmargin\n: auto;\n            \ntext-align\n: right;\n            \nfont-size\n: \n30px\n;\n            \npadding-right\n: \n10px\n;\n            \npadding-top\n: \n5px\n;\n        }\n\n        \n/* 设置按钮区域的样式 */\n\n        \n.button\n{\n            \nwidth\n: \n465px\n;\n            \nheight\n: \n413px\n;\n            \nbackground-color\n:gray;\n            \nmargin\n: auto;\n            \nborder-bottom-left-radius\n: \n10px\n;\n            \nborder-bottom-right-radius\n: \n10px\n;\n            \n        }\n\n        \n.button\n \ndiv\n{\n            \nwidth\n: \n110px\n;\n            \nheight\n: \n80px\n;\n            \nfloat\n: left;\n            \nbackground-color\n:aquamarine;\n            \nborder\n: \n1px\n gray solid;\n            \nmargin-left\n: \n3.3px\n;\n            \ntext-align\n: center;\n            \nfont-size\n: \n25px\n;\n            \nline-height\n: \n80px\n;\n            \nfont-weight\n: bold;\n        }\n\n        \n/* 使用伪类，可以产生一个鼠标悬停的效果 */\n\n        \n.button\n \ndiv\n:hover\n{\n            \nbackground-color\n: bisque;\n            \n/* 鼠标放在上面有放大的效果 */\n\n            \nfont-size\n: \n28px\n;\n            \n        }\n\n        \n    \n\n\n\n    \n<\nscript\n \ntype\n=\n\"text/javascript\"\n>\n\n\n        \n//解释：在你点击了7那个按钮，就会调用这个函数，定义一个result变量，将整个文件中的class名字为\n\n        \n//result的值赋给result这个变量，然后再把7赋给result。\n\n        \n//innerHTML获取HTML当前标签的起始和结束里面的内容\n\n        \n//给函数传递参数（number），用于输入哪一个数字\n\n    \nfunction\n \nclicknumber\n(\nnumber\n){\n        \nvar\n result = \ndocument\n.\ngetElementById\n(\n\"result\"\n);\n        \n//前面那个数加上后面你输入的数（不是相加成和，而是相加为一前一后，就是输入7和8，变成78\n\n        \n//innerHTML提取出来的是字符串，所以会变成输入的数字变成连接而不是相加\n\n        result.\ninnerHTML\n += number; \n//这里的result是前面那个变量名，给变量名赋值为7\n\n        \n    }\n\n    \n// 输入运算符\n\n    \nfunction\n \nclickoperator\n(\noperator\n){\n        \nvar\n result = \ndocument\n.\ngetElementById\n(\n\"result\"\n);\n        \nvar\n string = result.\ninnerHTML\n;\n        \nvar\n len = string.\nlength\n; \n//用len变量获取string长度\n\n        \nvar\n last = string[len-\n1\n]; \n//last变量是字符串的最后一个字符\n\n\n\n        \nif\n(last == \n\"+\"\n || last ==\n\"-\"\n || last == \n\"*\"\n || last == \n\"/\"\n || last == \n\"%\"\n){\n            \n//下面的代码是从string的数组下标为0开始往后获取len-1个长度，然后最后一位用新输入的那个运算符代替\n\n            \nvar\n temp = string.\nsubstr\n(\n0\n,len-\n1\n) + operator; \n//substr(x,y)，x是数组开始的下标，y是往后获取y个\n\n            result.\ninnerHTML\n = temp;\n        }\n        \nelse\n{\n            result.\ninnerHTML\n += operator; \n//如果不是字符那就正常执行\n\n        }\n\n        \n        \n        }\n\n\n    \n// 计算结果\n\n    \n//思路，先找到ID名为result的元素赋给result这个变量，然后用innerhtml将元素获取给到中间变量expression\n\n    \n//最后将结果赋给变量result，我认为最后的innerHTML是替换的作用。\n\n    \nfunction\n \ndocalc\n(\n){\n        \nvar\n result = \ndocument\n.\ngetElementById\n(\n\"result\"\n);\n        \nvar\n expression = result.\ninnerHTML\n;\n        result.\ninnerHTML\n = \neval\n(expression);\n       \n    }\n\n    \n// 清空\n\n    \nfunction\n \ndoclear\n(\n){\n        \nvar\n result = \ndocument\n.\ngetElementById\n(\n\"result\"\n);\n        result.\ninnerHTML\n = \n\" \"\n;  \n//给这个结果赋空值\n\n        \n        \n//或者可以这么写\n\n        \n//document.getElementById(\"result\").innerHTML = \" \";\n\n        \n//最简单的理解，就是将原来里面的东西替换成了空。因为innerhtml有获取的作用也有替换的作用\n\n        \n//可能有疑问为什么有时候innerhtml放在document那一句的后面，有时候是放在下一行的\n\n        \n//innerhtml放在哪一行就是获取这一行的标签的里面的元素的\n\n        \n    }\n\n    \n// 删除，退格,回退删除最后一个字符\n\n    \n// 要利用数组，在计算器中12345分别的是第01234位\n\n    \nfunction\n \ndoback\n(\n){\n        \nvar\n result = \ndocument\n.\ngetElementById\n(\n\"result\"\n);\n        \nvar\n len = result.\ninnerHTML\n.\nlength\n;\n//取长度，这个字符串有多少位的长度\n\n        \n// substr(x,y)里面有两个参数，x是从数组的第几位开始，y是往后取多少位。（0,5）意思就是从第一个开始取，一直取五个数字\n\n        result.\ninnerHTML\n = result.\ninnerHTML\n.\nsubstr\n(\n0\n,len-\n1\n);\n    }\n\n    \n//获取字符串最后一个字符，如果是一个运算符，你还想输入一个运算法，那就把这个运算符替换了\n\n    \nfunction\n \ngetlastchar\n(\n){\n        \nvar\n result = \ndocument\n.\ngetElementById\n(\n\"result\"\n);\n        \nvar\n string = result.\ninnerHTML\n;\n        \nvar\n len = string.\nlength\n;\n        \nvar\n last = string[len-\n1\n];\n        \nif\n(last == \n\"+\"\n || last ==\n\"-\"\n || last == \n\"*\"\n || last == \n\"/\"\n || last == \n\"%\"\n){\n        }\n    }\n\n\n    \n// 这个函数是模仿了运算符来写的\n\n    \nfunction\n \nclickpoint\n(\npoint\n){\n        \nvar\n result = \ndocument\n.\ngetElementById\n(\n\"result\"\n);\n        \nvar\n string = result.\ninnerHTML\n;\n        \nvar\n len = string.\nlength\n;\n        \nvar\n last = string[len-\n1\n];\n        \nif\n(last == \n\".\"\n){\n            last = string.\nsubstr\n(\n0\n,len-\n1\n) + point;\n            result.\ninnerHTML\n = last;\n        }\n        \nelse\n{\n            result.\ninnerHTML\n += point;\n        }\n    }\n\n    \n\n\n\n\n<\nbody\n \nonload\n=\n\"countertitle()\"\n>\n\n   \n    \n<\ndiv\n \nclass\n=\n\"top\"\n>\n   \n\n\n        \n<\ndiv\n \nclass\n=\n\"point-red\"\n>\n\n\n        \n<\ndiv\n \nclass\n=\n\"point-blue\"\n>\n\n\n        \n<\ndiv\n \nclass\n=\n\"point-green\"\n>\n\n\n        \n<\ndiv\n \nid\n=\n\"counter\"\n>\n计算器\n\n\n\n\n    \n<\ndiv\n \nid\n=\n\"result\"\n>\n\n\n\n\n    \n<\ndiv\n \nclass\n=\n\"button\"\n>\n\n        \n\n\n        \n<\ndiv\n \nonclick\n=\n\"doclear()\"\n>\nAC\n\n\n\n\n        \n<\ndiv\n >\n+/-\n\n \n        \n<\ndiv\n \nonclick\n=\n\"clickoperator('%')\"\n>\n%\n\n\n        \n<\ndiv\n \nonclick\n=\n\"clickoperator('/')\"\n>\n÷\n\n\n        \n<\ndiv\n \nonclick\n=\n\"clicknumber(1)\"\n>\n1\n\n\n        \n<\ndiv\n \nonclick\n=\n\"clicknumber(2)\"\n>\n2\n\n\n        \n<\ndiv\n \nonclick\n=\n\"clicknumber(3)\"\n>\n3\n\n\n        \n<\ndiv\n \nonclick\n=\n\"clickoperator('*')\"\n>\n*\n\n\n        \n<\ndiv\n \nonclick\n=\n\"clicknumber(4)\"\n>\n4\n\n\n        \n<\ndiv\n \nonclick\n=\n\"clicknumber(5)\"\n>\n5\n\n\n        \n<\ndiv\n \nonclick\n=\n\"clicknumber(6)\"\n>\n6\n\n\n        \n<\ndiv\n \nonclick\n=\n\"clickoperator('-')\"\n>\n-\n\n\n        \n<\ndiv\n \nonclick\n=\n\"clicknumber(7)\"\n>\n7\n\n\n        \n<\ndiv\n \nonclick\n=\n\"clicknumber(8)\"\n>\n8\n\n\n        \n<\ndiv\n \nonclick\n=\n\"clicknumber(9)\"\n>\n9\n\n\n        \n<\ndiv\n \nonclick\n=\n\"clickoperator('+')\"\n>\n+\n\n\n        \n<\ndiv\n \nonclick\n=\n\"clicknumber(0)\"\n>\n0\n\n\n\n        \n<\ndiv\n \nonclick\n=\n\"doback()\"\n>\n删除\n\n\n        \n<\ndiv\n \nonclick\n=\n\"clickpoint('.')\"\n>\n.\n\n\n        \n<\ndiv\n \nonclick\n=\n\"docalc()\"\n>\n=\n\n\n\n\n\n\n\n\n\n运行结果及报错内容\n没有报错，但是想尽量完善这个计算器\n\n\n我的解答思路和尝试过的方法\n刚开始想在输入数值的函数中进行一个过滤，只要第一个输入不为数值那就不能输出，但是如果这样那加和减也会被过滤掉，于是我选择在运算符的函数中过滤，只要第一个输入为乘除取余就取空值，但是不知道怎么取到第一个值。因为我的代码是将显示的结果里的值全部提出。\n\n\n 我想要达到的结果\n让输入的第一个值不能为乘号，除号，取余号，但是可以为加号和减号。", "Tag": "算法分析"}
{"Answer": "不能用递归求，否则递归次数太多会导致栈溢出\n#include <iostream>\n\nusing namespace std;\n\nint fibonacci(int a)\n{\n    if (a == 1 || a == 2)\n        return 1;\n    int f1 = 1, f2 = 1;\n    for (int i = 3; i <= a; i++)\n    {\n        int f = (f1 + f2) % 1000;\n        f1 = f2;\n        f2 = f;\n    }\n    return f2;\n}\n\nint main()\n{\n    int n, a;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a;\n        cout << fibonacci(a) << '\\n';\n    }\n    return 0;\n}\n", "Konwledge_Point": "算法与数字", "Question": "c++递归问题求解：2790: 菲波那契数列\n题目描述\n菲波那契数列是指这样的数列：数列的第一个和第二个数都为1，接下来的每个数都等于前面2个数字之和。\n给出一个正整数a，要求菲波那契数列中第a个数对1000取模的结果是多少。\n输入\n第1行是数据的组数n(n<=100000)，后面跟着n行输入。每组测试数据占1行，包括一个正整数a(1<=a<=1000000)。\n输出\nn行，每行输出对应一个输入。输出应是一个正整数，为菲波那契数列中第a个数对1000取模得到的结果。\n样例\n输入\n4\n5\n2\n19\n1\n输出\n5\n1\n181\n1", "Tag": "算法分析"}
{"Answer": "else if (a == 2) {        for (i = 0; i <10; i++)        {            cin >> y;            num2[i] = y;        }        Sort(num1); 这里有个错误，应该num2而且j应该要判断小于10-1", "Konwledge_Point": "算法与数字", "Question": "函数重载排序问题无法输出结果是为什么呢？\n\n#\ninclude\n\nusing namespace std;\n    \nint\n \nSort(\nint\n \nnum\n[10])\n;\n    \nfloat\n \nSort(\nfloat\n \nnum\n[10])\n;\n\n\nint\n main\n()\n\n{\n    \nint\n num1\n[\n11\n]\n,x;\n    \nfloat\n num2\n[\n11\n]\n,y;\n    \nint\n i;\n    cout << \n\"请选择需要输入数字的类型\"\n << endl;    \n    cout << \n\"整数输入1 实数输入2\"\n << endl;\n    \nint\n a;\n    cin >> a;\n    cout << \n\"请输入需要排序的数字\"\n << endl;\n    \nif\n (a\n == \n1\n) {        \n        \nfor\n (i = \n0\n; i <\n10\n; i++)\n        {\n            cin >> x;\n            num1\n[\ni\n]\n = x;\n        }\n        \nSort(\nnum1\n)\n;\n\n    }\n    \nelse\n \nif\n (a\n == \n2\n) {\n        \nfor\n (i = \n0\n; i <\n10\n; i++)\n        {\n            cin >> y;\n            num2\n[\ni\n]\n = y;\n        }\n        \nSort(\nnum1\n)\n;\n\n    }\n    return \n0\n;\n\n}\n\nint\n \nSort(\nint\n \nnum\n[10])\n\n{\n    \nint\n i, j, temp;\n    \nfor\n (i = \n0\n; i < \n10\n; i++) {\n        \nfor\n (j = i;j < \n10\n; j++)\n        {\n            \nif\n (num\n[\nj\n]\n > num\n[\nj\n + \n1\n]\n)\n            {\n                temp = num\n[\nj\n]\n;\n                num\n[\nj\n]\n = num\n[\nj\n + \n1\n]\n;\n                num\n[\nj\n + \n1\n]\n = temp;\n            }\n        }\n    }\n    \nfor\n (i = \n0\n, i < \n10\n; i++;)\n        cout << num\n[\ni\n]\n<<\n\" \"\n;\n    return \n0\n;\n    }\n\n\nfloat\n \nSort(\nfloat\n \nnum\n[10])\n\n{\n    \nint\n i, j;\n     \nfloat\n temp;\n    \nfor\n (i = \n0\n; i < \n10\n; i++) {\n        \nfor\n (j = i; j < \n10\n; j++)\n        {\n            \nif\n (num\n[\nj\n]\n > num\n[\nj\n + \n1\n]\n)\n            {\n                temp = num\n[\nj\n]\n;\n                num\n[\nj\n]\n = num\n[\nj\n + \n1\n]\n;\n                num\n[\nj\n + \n1\n]\n = temp;\n            }\n        }\n    }\n    \nfor\n (i = \n0\n, i < \n10\n; i++;)\n        cout << num\n[\ni\n]\n << \n\" \"\n;\n    return \n0\n;\n}\n", "Tag": "算法分析"}
{"Answer": "\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nconst int N = 260;\nstring s;\n\nint main() {\n    cin >> s;\n    int res = 0, num = 0, n = s.size();\n    for(int i = 0 ; i < n; i ++) {\n        int j = i;\n        while(j < n && s[j] <= '9' && s[j] >= '0') j ++;\n        int t = 0;\n        for(int k = i; k < j; k ++)\n            t = t * 10 + s[k] - '0';\n        if(t > num) num = t, res = i;\n        i = j;\n    }\n    \n    cout << res + 1 << endl;\n    \n    return 0;\n}\n\n", "Konwledge_Point": "算法与数字", "Question": "隐藏的最大整数WA 45分\n题目描述\n今天是个好日子，整数小伙伴们又一起出来聚会了。大家商议决定：今天玩捉迷藏！ 玩法很简单，就是把藏在一个长长的字符串中（任何两个人都不会并排藏在一起）数字伙伴找出来。而且，因为伙伴们太多，只找到此次藏起来的最大的那个伙伴就可以了。并且，大家一致同意，让“1”做第一个找人的人——当然，事先，他并不知道到底有哪些伙伴藏起来了……\n\n\n游戏开始了。“1”是一个很聪明的人，很快，他就把最大的那个伙伴找出来了……\n\n\n如果你是“1”，你能写个程序来解决这件事情么？\n\n\n输入格式\n只有一个字符串，这里面藏有很多的整数小伙伴。字符串最多包含255个字符\n\n\n输出格式\n只有一个整数，表示藏在其中的最大的那个整数小伙伴的位置（整数第一个数字在原串中的位置）。\n\n\n样例输入\n\n\n*((*-a32AB342+\n//\n32143\nabAA\n\n\n\n样例输出\n\n\n17\n\n\n\n我的WA代码：\n\n\n#include\n\n\nusing\n \nnamespace\n std;\n\n\nint\n main()\n{\n    string s;\n    cin >> s;\n    \nlong\n \nlong\n n = s.size(), \nindex\n = \n0\n, max = \n-2147483647\n, \nsum\n = \n0\n, wz[\n100005\n] = {\n0\n}, num[\n100005\n];\n    memset(num, \n-2147483647\n, sizeof(num));\n    bool flag = \nfalse\n;\n    \nfor\n(\nint\n i = \n0\n; i < n; i++)\n    {\n        \nif\n(s[i] >= \n'0'\n && s[i] <= \n'9'\n)\n        {\n            \nif\n(!flag) flag = \ntrue\n, \nsum\n += s[i] - \n'0'\n, wz[\nindex\n] = i + \n1\n;\n            \nelse\n \nsum\n *= \n10\n, \nsum\n += s[i] - \n'0'\n;\n        }\n        \nelse\n\n        {\n            \nif\n(\nsum\n != \n0\n) num[\nindex\n++] = \nsum\n;\n            \nsum\n = \n0\n, flag = \nfalse\n;\n        }\n    }\n    \nlong\n \nlong\n k = \n0\n;\n    \nfor\n(\nint\n i = \n0\n; i < \nindex\n; i++)\n        \nif\n(num[i] > max) max = num[i], k = wz[i];\n    printf(\n\"%lld\"\n, k);\n    \nreturn\n \n0\n;\n}\n", "Tag": "算法分析"}
{"Answer": "直接split就行了   [].concat(arr);换成  arr.split(',');\nfunction bubble(){\n    var arr = prompt(\"请输入一系列数字（用英文逗号隔开）\");\n    var arr1= arr.split(',');\n    for (var i = 0; i < arr1.length - 1; i++) {\n        for (var j = 0; j < arr1.length - 1 - i; j++) {\n            if (arr1[j] > arr1[j + 1]) {\n                var temp = arr1[j];\n                arr1[j] = arr1[j + 1];\n                arr1[j + 1] = temp;\n            }\n        }\n    }\n    alert(\"原始排序为:\"+arr+\",冒泡排序后的结果为：\"+arr1);\n}\n\n\n", "Konwledge_Point": "算法与数字", "Question": "JS冒泡排序法程序无效果\nJS实现冒泡排序法没有效果该怎么解决呢？\n代码如下：\n\n\nfunction \nbubble(){\n\n    var arr = prompt(\n\"请输入一系列数字（用英文逗号隔开）\"\n);\n    var arr1= [].concat(arr);\n    for (var i = \n0\n; i < arr1.length - 1; i++) {\n\n        for (var \nj \n= \n0\n; j < arr1.length - 1 - i; j++) {\n\n            if (arr1[\nj] \n> arr1[\nj \n+ \n1\n]) {\n                var temp = arr1[\nj];\n\n                arr1[\nj] \n= arr1[\nj \n+ \n1\n];\n                arr1[\nj \n+ \n1\n] = temp;\n            }\n        }\n    }\n    alert(\n\"原始排序为:\"\n+arr+\n\",冒泡排序后的结果为：\"\n+arr1);\n}\n\n", "Tag": "算法分析"}
{"Answer": "该回答引用自ChatGPT先贴本人本地执行结果\n\n这个是我根据chatGPT代码修改的。\n\n最近感觉chatGPT给的代码经常有问题\n\nimport java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        double min = Integer.MAX_VALUE;\n        //先将点存储在Point数组里面\n        ArrayList<Point> list = new ArrayList<>();\n        String line = \"\";\n        while (!(\"\").equals(line=sc.nextLine())) {\n            String[] s = line.split(\",\");\n            list.add(new Point(Integer.parseInt(s[0]), Integer.parseInt(s[1])));\n        }\n        //穷举所有四个点的组合\n        for (int i = 0; i < list.size(); i++) {\n            for (int j = i + 1; j < list.size(); j++) {\n                for (int k = j + 1; k < list.size(); k++) {\n                    for (int l = k + 1; l < list.size(); l++) {\n                        double sum = 0;\n                        //计算平均距离\n                        sum += getDistance(list.get(i), list.get(j));\n                        sum += getDistance(list.get(i), list.get(k));\n                        sum += getDistance(list.get(i), list.get(l));\n                        sum += getDistance(list.get(j), list.get(k));\n                        sum += getDistance(list.get(j), list.get(l));\n                        sum += getDistance(list.get(k), list.get(l));\n                        sum /= 6;\n                        if (sum < min) {\n                            min = sum;\n                        }\n                    }\n                }\n            }\n        }\n        System.out.printf(\"%.02f\", min);\n    }\n    //计算两点之间距离\n    public static double getDistance(Point a, Point b) {\n        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n    }\n}\nclass Point {\n    int x;\n    int y;\n    public Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\n", "Konwledge_Point": "算法与数字", "Question": "蓝桥杯 平面点集中4点最小平均距离\n题目描述\n已知平面上若干个点的坐标。\n\n\n需要求出在所有的组合中，4 个点间平均距离的最小值（四舍五入，保留 2 位小数）。\n比如有 4 个点：a,b,c,d, 则平均距离是指：ab, ac, ad, bc, bd, cd 这 6 个距离的平均值。\n\n\n输入描述\n输入多行（可能包含上万行），每行两个数字 x，y\\ （1 \\leq x,y \\leq 1000）x，y （1≤x,y≤1000），表示每个点的坐标。\n\n\n输出描述\n输出一行，在所有的组合中，4 个点间平均距离的最小值（四舍五入，保留 2 位小数）。\n\n\n输入输出样例\n示例\n输入\n\n\n10\n,\n10\n\n\n20\n,\n20\n\n\n80\n,\n50\n\n\n10\n,\n20\n\n\n20\n,\n10\n\n\n\n\n\n输出\n\n\n11\n.\n38\n\n\n", "Tag": "算法分析"}
{"Answer": "", "Konwledge_Point": "算法与数字", "Question": "识别象棋python运行的疑问\n这段代码在运行不正常\n（注：功能为，任意给定一张带有棋子的象棋棋盘图像,请识别棋盘中的棋子是什么颜色、是什么棋子及相应的坐标是多少）\n代码如下，怎么修改呀\n\n\n# 图片二值化\n\n\nimport\n numpy \nas\n np\n\nimport\n cv2 \nas\n cv\n\nfrom\n matplotlib \nimport\n pyplot \nas\n plt\n\nfrom\n PIL \nimport\n Image\nimg = Image.\nopen\n(\n'C:/Users/ZengFH/Desktop/2.png'\n)\n \n\n# 模式L”为灰色图像，它的每个像素用8个bit表示，0表示黑，255表示白，其他数字表示不同的灰度。\n\nImg = img.convert(\n'L'\n)\nplt.subplot(\n1\n,\n2\n,\n1\n),plt.imshow(Img)\n\n#Img.save(\"test1.jpg\")\n\n \n\n# 自定义灰度界限，大于这个值为黑色，小于这个值为白色\n\nthreshold = \n200\n\n \ntable = []\n\nfor\n i \nin\n \nrange\n(\n256\n):\n    \nif\n i < threshold:\n        table.append(\n0\n)\n    \nelse\n:\n        table.append(\n1\n)\n \n\n# 图片二值化\n\nphoto = Img.point(table, \n'1'\n)\nplt.subplot(\n1\n,\n2\n,\n2\n),plt.imshow(photo)\n\n#photo.save(\"test2.jpg\")\n\nplt.show()\n\n\n#竖线以x坐标进行排序\n\nsx = \nsorted\n(sx, key=\nlambda\n x: x[\n0\n])\n\n#直线以Y坐标进行排序\n\nzx = \nsorted\n(zx, key=\nlambda\n x: x[\n2\n])\n\n\n\n#对于竖线进行过滤\n\nsxFilter=[]\n\nif\n \nlen\n(sx)>\n0\n:\n    sxFilter.append(sx[\n0\n])\n    tempsx = sx[\n0\n]\n    \n# 从第二个开始提取\n\n    \nfor\n i \nin\n \nrange\n(\nlen\n(sx))[\n1\n:]:\n        \n# 这是竖线的x坐标值间距要大于10\n\n        \nif\n (sx[i][\n0\n] - tempsx[\n0\n]) > \n10\n:\n            tempsx = sx[i]\n            sxFilter.append(sx[i])\n\n\n#棋子识别\n\n\n#根据轮廓获取最小矩形边框\n\n            x, y, w, h = cv.boundingRect(cnts[i])\n\n\n\n#轮廓获取得到的是上面图，下面的会有一些干扰项\n\n\n#通过拿到边框的坐标，然后根据宽高的比例进行过滤，我这里根据宽高的差\n\n            x, y, w, h = cv.boundingRect(cnts[i])\n            \nprint\n(x,y,w,h)\n            \nif\n(\nabs\n(w-h)>\n20\n):\n                    \ncontinue\n\n\n\n\n#识别之前要做的是边框排序，根据上面拿到的轮廓数据\n\n\n#这里按照Y，X递增的方式进行\n\nquestionCnts2 = \nsorted\n(questionCnts.copy(), key=\nlambda\n x: (x[\n1\n],x[\n0\n]))\n\n#排序我这里遇到了问题，因为每行棋子识别的时候，坐标有些高低差导致排序结果可能跟棋盘显示有些出入\n\n\n#其实识别之后可以根据上一篇文章得到的棋盘表格一步一步的得到棋子，我这里没做\n\n\n#我用了个笨办法处理的 就是每行的Y轴根据个大致范围固定了\n\n\nif\n \nabs\n(y - \n19\n) < \n20\n:\n             y = \n19\n\n\n\nif\n \nabs\n(y - \n88\n) < \n20\n:\n             y = \n88\n\n \n \n#拿到了边框后我们可以根据边框截取抠图了\n\nx, y, w, h = questionCnts2[i]\n    \n# print(x, y, w, h)\n\nim = img[y:y + h, x:x + w]\n  \n  \n#抠图后然后根据模板匹配算法得到最匹配的模板\n\nresult = cv.matchTemplate(cv.resize(old_img,\nNone\n,fx=\n0.8\n, fy=\n0.8\n, interpolation = cv.INTER_CUBIC),tempImg,cv.TM_CCOEFF)\n(_, score, _, _) = cv.minMaxLoc(result)\n\nif\n check_score == \n0\n \nor\n score > check_score:\n      \n#最大得分项\n\n      check_score = score\n      \n#最大得分项的文件名，然后根据字典获取棋子名称\n\n      \n#字典\n\n      check_img = fileName\n\n\n#棋谱保存\n\n \n#第一排的棋子高度大概就在19左右\n\n\nif\n \nabs\n(y - \n19\n) < \n20\n:\n             y = \n19\n\n\n\nchess_array=[[] \nfor\n i \nin\n \nrange\n(\n10\n)]\n\nif\n(\nlen\n(sxFilter)==\n9\n \nand\n \nlen\n(zxFilter)==\n10\n):\n  \n#竖线 直线\n\n  \nprint\n(\n\"---------------------\"\n)\n  \nfor\n i \nin\n \nrange\n(\nlen\n(zxFilter)):\n        \nfor\n j \nin\n \nrange\n(\nlen\n(sxFilter)):\n            \n#直线的坐标\n\n            x1,x2,y1,y2=zxFilter[i]\n            \n#竖线坐标\n\n            x3,x4,y3,y4=sxFilter[j]\n            check = \nFalse\n\n            \nprint\n(zxFilter[i],\n\"-\"\n,sxFilter[j],i,j)\n            \nfor\n k \nin\n \nrange\n(\nlen\n(questionCnts)):\n                  x, y, w, h=questionCnts[k]\n                  \n#获取中心坐标\n\n                  centre_x=x+w/\n2\n\n                  centre_y=y+h/\n2\n\n                  \n#范围之内匹配成功\n\n                  \nprint\n(centre_x,\n\"-\"\n,centre_y)\n                  \n#这里写的匹配误差在25之内\n\n                  \nif\n(\nabs\n(centre_x-x3)<\n25\n \nand\n \nabs\n(centre_y-y1)<\n25\n):\n                    \nprint\n(\n\"命中!\"\n)\n                    check=\nTrue\n\n                    \n#抠图\n\n                    im = img[y:y + h, x:x + w]\n                    \n#识别\n\n                    orc = get_match(im)\n                    \nif\n orc \nis\n \nnot\n \nNone\n:\n                          chess_array[i].append(orc)\n                    \nelse\n:\n                        \nprint\n(\n\"未识别...\"\n)\n            \nif\n \nnot\n check:\n                  chess_array[i].append(\n\"空空空\"\n)\n\nelse\n:\n  \nprint\n(\n\"识别出错了!\"\n)\n\n\n", "Tag": "算法分析"}
{"Answer": "Python中str.index如果找不到就会报错，可以用异常处理，或者换成str.count麻烦采纳一下哟，谢谢๑•́₃•̀๑", "Konwledge_Point": "算法与数字", "Question": "Python index() ValueError: 402.11 is not in list\n问题遇到的现象和发生背景\n\n\n我循环遍历了两个数组，用以对其中一组数据进行数据扩充。数据如下：第一张图是需要扩充的，第二张是扩充范围，以第一列为基准，最邻近填充第二列\n\n\n\n\n\n\n用代码块功能插入代码，请勿粘贴截图\n\n\ntxt\n = pd.read_csv('F:\\\\Practice\\\\RamanSpectrum\\\\Savitzky-Golay\\\\actinolite\\\\R040063.txt', header=None)  # 第一张图的数据读入\n\narray\n = np.array(txt, dtype='float32')  # 转换为数组\n\n\ncenter_array\n = get_unique('F:\\\\Practice\\\\RamanSpectrum\\\\Savitzky-Golay')  # 第二张图的数据读入\n\n\nlist_arr\n = list(center_array[:, \n0\n])  # 设置一个列表用以索引指引\n\n\n# 遍历第一张图，把第二张图对应的位置前后填充起来\n\n\nfor\n x in range(len(array)):\n    \nprint\n(x)\n    \nif\n x == len(array) - \n1\n:\n        \nbreak\n\n    \nnum\n = int(round(array[x + \n1\n, \n0\n] - array[x, \n0\n], \n4\n) * \n100\n) - \n1\n\n    \na\n = int(array[x, \n0\n] * \n100\n)/\n100\n\n    \nb\n = int(array[x + \n1\n, \n0\n] * \n100\n)/\n100\n\n    \nloc1\n = list_arr.index(a)\n    \nloc2\n = list_arr.index(b)\n    \ncenter_array\n[loc1:loc1 + num // \n2\n + \n1\n, \n1\n] = array[x, \n1\n]\n    \ncenter_array\n[loc1 + num // \n2\n + \n1\n:loc2 + \n1\n, \n1\n] = array[x + \n1\n, \n1\n]\n\n\n\n运行结果及报错内容\n\n\n因为出现了错误，所以我尝试输出x，查看哪个数字出现错误，\n\n\n结果显示，是第一张图第488这个位置的数出现了问题，查看数据：\n\n\n但该数字int后不应该是402.11，甚至第二张图里面都没有出现过，所以才导致index找不到，但问题是int(401.637900*100)/100后得到的数值是401.63：\n\n\n\n\n我的解答思路和尝试过的方法\n\n\n我之前使用的是round保留两位数，但我只需要强制进行后两位的选取，并不需要四舍五入。\n所以我换成了int，但还是出现了问题", "Tag": "算法分析"}
{"Answer": "你的第二个for循环中的j的限制条件应该是 j<arr.length-1-i,而不是 j<arr.length-1-j\n\nfor(int j=0;j<arr.length-1-j;j++)\n改为\nfor(int j=0; j<arr.length-1-i; j++)\n", "Konwledge_Point": "算法与数字", "Question": "冒泡排序法遇到的问题\n我的冒泡排序法如果数组是奇数就最后一个数字不是最大的，但是没有排到前面来，如果是偶数的话就是倒数第二个\n\n\n\n\npublic\n \nclass\n lx12{\n    \npublic\n static \nvoid\n main(String[] args) {\n        \nint\n arr[] = {\n1\n,\n0\n,\n4\n,\n7\n,\n-1\n};\n      \nint\n \ntemp\n = \n0\n;\n      \nfor\n(\nint\n i =\n0\n;iarr[j+\n1\n]){\n               \ntemp\n = arr[j];\n               arr[j] = arr[j+\n1\n];\n               arr[j+\n1\n] = \ntemp\n;\n            }\n         }\n         \nSystem\n.\nout\n.println(\"这是\"+(i+\n1\n)+\"次循环\");\n         \nfor\n(\nint\n j=\n0\n;j<arr.length;j++){\n            \nSystem\n.\nout\n.print(arr[j]+\"\\t\");\n         }\n      }\n     \n    }\n}\n", "Tag": "算法分析"}
{"Answer": "“给定一个小点的输入，完整单步跟踪(同时按Alt+7键查看Call Stack里面从上到下列出的对应从里层到外层的函数调用历史)一遍。”是理解递归函数工作原理的不二法门！递归函数关注以下几个因素·退出条件·参数有哪些·返回值是什么·局部变量有哪些·全局变量有哪些·何时输出·会不会导致堆栈溢出", "Konwledge_Point": "算法与数字", "Question": "城堡问题 dfs 函数return以后不继续递归\n问题遇到的现象和发生背景\n\n\n做了一道 dfs的经典城堡问题 \n\n\n 1 \n \n 2 \n \n 3 \n \n 4 \n \n 5 \n \n 6 \n \n 7 \n \n\n\n\n   #############################\n 1 #   |   #   |   #   |   |   #\n   #####---#####---#---#####---#\n 2 #   #   |   #   #   #   #   #\n   #---#####---#####---#####---#\n 3 #   |   |   #   #   #   #   #\n   #---#########---#####---#---#\n 4 #   #   |   |   |   |   #   #\n   #############################\n           (图 1)\n\n\n= Wall\n\n\n   |  = No wall\n\n\n = No wall\n\n\n图1是一个城堡的地形图。请你编写一个程序，计算城堡一共有多少房间，最大的房间有多大。城堡被分割成mn(m≤50，n≤50)个方块，每个方块可以有0~4面墙。\n输入\n程序从标准输入设备读入数据。第一行是两个整数，分别是南北向、东西向的方块数。在接下来的输入行里，每个方块用一个数字(0≤p≤50)描述。用一个数字表示方块周围的墙，1表示西墙，2表示北墙，4表示东墙，8表示南墙。每个方块用代表其周围墙的数字之和表示。城堡的内墙被计算两次，方块(1,1)的南墙同时也是方块(2,1)的北墙。输入的数据保证城堡至少有两个房间。\n输出\n城堡的房间数、城堡中最大房间所包括的方块数。结果显示在标准输出设备上。\n样例输入\n4\n7\n11 6 11 6 3 10 6\n7 9 6 13 5 15 5\n1 10 12 7 13 7 5\n13 11 10 8 10 12 13\n样例输出\n5\n9\n\n\n问题相关代码，请勿粘贴截图\n\n\n#\ninclude\n\n#\ninclude\n\nusing namespace std;\n\nint\n N,R;\n\nint\n roomNum=\n0\n,roomArea=\n0\n;\n\nint\n maxroomArea=\n0\n;\n\nint\n color\n[\n60\n]\n[\n60\n]\n;\n\nint\n room\n[\n60\n]\n[\n60\n]\n;\nvoid \nDfs(\nint\n \ni\n,\nint\n \nk\n)\n{\n    \nif\n(color\n[\ni\n]\n[\nk\n]\n)\n        return;\n    \n    ++roomArea;\n    color\n[\ni\n]\n[\nk\n]\n=roomNum;\n    \nif\n((room\n[\ni\n]\n[\nk\n]\n&\n8\n)==\n0\n)return \nDfs(\ni\n+1,\nk\n)\n;\n     \nif\n((room\n[\ni\n]\n[\nk\n]\n&\n1\n)==\n0\n)return \nDfs(\ni\n,\nk\n-1)\n;\n     \nif\n((room\n[\ni\n]\n[\nk\n]\n&\n2\n)==\n0\n)return \nDfs(\ni\n-1,\nk\n)\n;\n     \nif\n((room\n[\ni\n]\n[\nk\n]\n&\n4\n)==\n0\n)return \nDfs(\ni\n,\nk\n+1)\n;\n    \n\n}\n\nint\n main\n()\n{\n    cin>>N>>R;\n    memset(color,\n0\n,sizeof(color));\n\n    \nfor\n(\nint\n i=\n1\n;i<=N;i++){\n        \nfor\n(\nint\n j=\n1\n;j<=R;j++){\n            cin>>room\n[\ni\n]\n[\nj\n]\n;\n        }\n    }\n    \n    \nfor\n(\nint\n i=\n1\n;i<=N;i++){\n        \nfor\n(\nint\n j=\n1\n;j<=R;j++){\n            \nif\n(!color\n[\ni\n]\n[\nj\n]\n){\n                ++roomNum;\n                roomArea=\n0\n;\n                \nDfs(\ni\n,\nj\n)\n;\n                \nfor\n(\nint\n i=\n1\n;i<=N;i++){\n                    \nfor\n(\nint\n j=\n1\n;j<=R;j++){\n                        cout<<color\n[\ni\n]\n[\nj\n]\n<<\n' '\n;\n                    }\n                    cout<<endl;\n                }\n                maxroomArea=max(roomArea,maxroomArea);\n            }\n        }\n    }\n    cout<<roomNum<<endl;\n    cout<<maxroomArea;\n    return \n0\n;\n} \n\n\n\n\n运行结果及报错内容\n\n\n我每次结束调用Dfs都打印了一下color\n发现这个函数每次 遇到return以后 就不继续递归了\n答案也不正确\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果", "Tag": "算法分析"}
{"Answer": "修改了你的代码，试试对不对\n\n#include<stdio.h>\nint main()\n{\n    int n,a,x,b,i,e,S=0,c;\n    printf(\"please input a suitable integer:\");\n    scanf(\"%d\",&n);\n    switch(n){\n        case 3:a=100,b=999;break;\n        case 4:a=1000,b=9999;break;\n        case 5:a=10000,b=99999;break;\n        case 6:a=100000,b=999999;break;\n        case 7:a=1000000,b=9999999;break;\n        default:printf(\"error\\n\");break;\n    }\n    for(x=a;x<=b;x++)\n    {\n        for(i=1;i<n;i++)\n        { e=x/10%10;\n            S=S+eee;\n        }\n        c=x%10;\n        S=S+ccc;\n        if(S==x)//这里本来是错的，前括号你用的是中文符号\n            printf(\"%d\\n\",x);\n    }\n    return 0;\n}\n", "Konwledge_Point": "算法与数字", "Question": "输出N位水仙花数pta\n为什么不是scanf 的返回值declared with attribute 就是printf 就是if\n\n\n水仙花数是指一个N位正整数（N≥3），它的每个位上的数字的N次幂之和等于它本身。例如：153=1\n 本题要求编写程序,计算所有N位水仙花数。\n\n\n输入格式:\n输入在一行中给出一个正整数N（3≤N≤7）。\n\n\n输出格式:\n按递增顺序输出所有N位水仙花数，每个数字占一行。\n\n\n输入样例:\n3\n输出样例:\n153\n370\n371\n407\n#include\nint main()\n{\n    int n,a,x,b,i,e,S=0,c;\n    printf(\"please input a suitable integer:\");\n    scanf(\"%d\",&n);\n    switch(n){\n      case 3:a=100,b=999;break;\n      case 4:a=1000,b=9999;break;\n      case 5:a=10000,b=99999;break;\n      case 6:a=100000,b=999999;break;\n      case 7:a=1000000,b=9999999;break;\n      default:printf(\"error\\n\");break;\n       }\nfor(x=a;x<=b;x++)\n{\n      for(i=1;i<n;i++)\n      {  e=x/10%10;\n         S=S+e\ne\ne;\n           }\n       c=x%10;\n       S=S+c\nc\nc;\n      if （S==x)\n        printf(\"%d\\n\",x);\n    }\n    return 0;\n}\n\n\npta说的编译错误:a.c: In function ‘main’:\na.c:23:10: error: stray ‘\\357’ in program\n       if （S==x)\n          ^\na.c:23:11: error: stray ‘\\274’ in program\n       if （S==x)\n           ^\na.c:23:12: error: stray ‘\\210’ in program\n       if （S==x)\n            ^\na.c:23:13: error: expected ‘(’ before ‘S’\n       if （S==x)\n             ^\na.c:23:13: warning: statement with no effect [-Wunused-value]\na.c:23:7: warning: this ‘if’ clause does not guard... [-Wmisleading-indentation]\n       if （S==x)\n       ^~\na.c:23:17: note: ...this statement, but the latter is misleadingly indented as if it is guarded by the ‘if’\n       if （S==x)\n                 ^\na.c:23:17: error: expected statement before ‘)’ token\na.c:6:5: warning: ignoring return value of ‘scanf’, declared with attribute warn_unused_result [-Wunused-result]\n     scanf(\"%d\",&n);", "Tag": "算法分析"}
{"Answer": "你要注意一个问题，当第一个元素是最小元素的话，你的交换是有问题的你的代码是将第一个元素和最大元素交换，如果第一个元素就是最小元素，那么最大元素交换后，最小元素不再是第一个元素，而是原先的最大元素位置。所以你交换最小元素时，还是和第一个元素交换就错了。要对这个情况进行特殊判断，如果第一个元素就是最大元素，那么需要将n值改为m才行。", "Konwledge_Point": "算法与数字", "Question": "数组元素交换，一道简单的C语言代码题，遇到点困难求解答\n我的代码过不了第二个测试点，由此我写了两种情况的代码，都过不了，感觉我的代码和同学的差不多，请纠正我的代码错误\n原题如下\nL2 数组元素交换 (5 分)\n数组元素交换，要求：（1）最大的元素与第一个元素交换（2）最小的元素与最后一个元素交换。\n\n\n输入格式:\n输入一行字符串（由不同的整数组成，以空格分开）\n\n\n输出格式:\n首先以数组形式输出初始字符串（一行一个数字），然后以数组形式输出完成交换后的字符串（一行一个数字）。\n\n\n输入样例:\n2 9 0 10\n输出样例:\n2\n9\n0\n10\n10\n9\n2\n0\n我的第一次代码\n\n\n#include\n\n\n#include\n\nlong long a[10005],\ni\n=0,j,m=0,n=0,b;\nint main ()\n{    \n    \nwhile\n(~scanf(\n\"%d\"\n,&b))\n    {\n         a[i++] = b;\n        \nif\n (\n'\\n'\n == getchar())\n         {\n             a[i] = \n'\\0'\n;\n             break;\n         }\n     }\n    \nfor\n(\nj\n=0;jmax)\n        {\n            \nmax\n=a[j];\n            \nm\n=j ;\n        }\n        \nif\n(a[j]\n\n\n#include\n\nlong long a[10005],\ni\n=0,j,m=0,n=0,b;\nint main ()\n{    \n    \nwhile\n(~scanf(\n\"%d\"\n,&b))\n    {\n         a[i++] = b;\n        \nif\n (\n'\\n'\n == getchar())\n         {\n             a[i] = \n'\\0'\n;\n             break;\n         }\n    }\n    \nfor\n(\nj\n=0;jmax)\n        {\n            \nmax\n=a[j];\n            \nm\n=j;\n        }\n    }\n    \n\n        int \nt\n=a[0];\n        a[0]=a[m];\n        a[m]=t;\n        \n        \n    int \nmin\n=a[0];\n    \nfor\n(\nj\n=0;j\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\nusing\n \nnamespace\n std;\n\n\n\nint\n \nmain\n()\n{\n \n \nint\n n,x=\n0\n,maxx=\n-9999\n,minn=\n9999\n,t,t1;\n \nint\n a[\n100010\n];\n \nwhile\n(cin >> n)\n {\n  a[++x] = n;\n  cout << a[x] << endl;\n  \nif\n(a[x] > maxx)\n  {\n   maxx = a[x];\n   t = x;\n  }\n  \nif\n(a[x] < minn)\n  {\n   minn = a[x];\n   t1 = x;\n  }\n }\n \nint\n w;\n w = a[\n1\n];\n a[\n1\n] = a[t];\n a[t] = w;\n \n w = a[x];\n a[x] = a[t1];\n a[t1] = w;\n  \n \nfor\n(\nint\n i = \n1\n;i <= x;i++)\n {\n  cout << a[i] <<endl; \n }\n\n    \nreturn\n \n0\n;\n}\n\n\n\n感谢帮助", "Tag": "算法分析"}
{"Answer": "int a[] = { 0 };不能这么写，你可以给一个比较大的值，比如int a[10000] = { 0 };\n  ", "Konwledge_Point": "算法与数字", "Question": "vs提示堆栈被损坏，但是能够运行出来结果？\n各位帮忙看下！！\n代码如下：\n\n\n#\ndefine\n _CRT_SECURE_NO_WARNINGS 1 \n\n\n#\ninclude\n \n\n\n\n\nint\n \nmain\n()\n \n{\n    \n//冒泡排序\n\n    \nint\n a[] = { \n0\n };\n    \nint\n b=\n0\n;    \n//这里的 b 是用来储存数组的大小\n\n    \nprintf\n(\n\"输入数字：\\n\"\n);\n    \nprintf\n(\n\"输入  00  停止\\n\"\n);\n    \nfor\n (\nint\n i = \n0\n;; i++)\n    {\n        \nscanf\n(\n\"%d\"\n, &a[i]);\n        \nif\n (a[i] == \n00\n)\n        {\n            b = i;\n            \nbreak\n;\n        }\n    }\n    \nprintf\n(\n\"  %d  个数的排序结果：\\n\"\n,b);\n    \nfor\n (\nint\n i = \n0\n; i < b; i++)        \n//因为输入了 b 个数，此处的  <b 刚好可以把最后输入的  控制 00  去掉\n\n    {\n        \nfor\n (\nint\n j = i; j < b; j++)\n        {\n            \nif\n (a[i] < a[j])                  \n            {\n                \nint\n te = a[i];\n                a[i] = a[j];\n                a[j] = te;\n                \n            }\n        }\n    }\n    \nfor\n (\nint\n i = \n0\n; i < b; i++)    \n//遍历\n\n    {\n        \nprintf\n(\n\"%d  \"\n, a[i]);\n    }\n}\n\n\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "第6行for循环后面的分号删除掉17行也是，然后大括号也是乱的printf输出的变量也是错的，修改如下：\n#include <stdio.h>\n\nint main()\n{\n    int  a[2][3] = { {1,2,3},{4,5,6} };\n    int  b[3][2], i, j;\n    printf(\"array a:\\n\");\n    for (i = 0; i <= 1; i++)\n    {\n        for (j = 0; j <= 2; j++)\n\n        {\n            printf(\"%5d\", a[i][j]);\n            b[j][i] = a[i][j];\n        }\n        printf(\"\\n\");\n    }\n    printf(\"array b:\\n\");\n    for (i = 0; i <= 2; i++)\n    {\n        for (j = 0; j <= 1; j++)\n            printf(\"%5d\", b[i][j]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n", "Konwledge_Point": "算法与数字", "Question": "二维数组元素互换出现问题\n问题遇到的现象和发生背景\n\n\n代码写完后，运行结果出现了一串数字，非数列形式\n\n\n问题相关代码，请勿粘贴截图\n\n\n#include \n\n\nint main()\n{\n\n\nint  a[\n2\n][\n3\n] = { {\n1\n,\n2\n,\n3\n},{\n4\n,\n5\n,\n6\n} };\nint  b[\n3\n][\n2\n], i, j;\nprintf(\n\"array a:\\n\"\n);\nfor (i = \n0\n; i <= \n1\n; i++)\n{\n    for (j = \n0\n; j <= \n2\n; j++);\n\n    {\n        printf(\n\"%5d\\n\"\n, a[\n2\n][\n3\n]);\n        b[j][i] = a[i][j];\n    }\n}\n    printf(\n\"\\n\"\n);\nprintf(\n\"array b:\\n\"\n);\nfor (i = \n0\n; i <= \n2\n; i++)\n{\n    for (j = \n0\n; j <= \n1\n; j++);\n}\nprintf(\n\"%5d\\n\"\n, b[i][j]);\nprintf(\n\"\\n\"\n);\nreturn \n0\n;\n\n\n\n}\n\n\n运行结果及报错内容\n\n\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果", "Tag": "算法分析"}
{"Answer": "pop(T &x)", "Konwledge_Point": "算法与数字", "Question": "想用栈实现进制转换，但不知道那里错了\n问题遇到的现象和发生背景\n\n\n问题相关代码，请勿粘贴截图\n\n\n \n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n.h\n#ifndef STACK_H\n#define STACK_H\ntemplate \nclass Stack\n{\nprivate:\n    T* element;\n    int maxSize;\n    int top;\npublic:\n    Stack(int w);  \n    bool isempty();     \n    bool isfull();\n    bool push(const T& x);\n    bool pop(T x);\n    ~Stack(){delete[] element;}\n};\n\ntemplate\nStack::Stack(int w)\n{\n    top = -1;\n    maxSize = w;\n    element = new T(w);\n}\n\ntemplate \nbool Stack::isempty()\n{\n    return top == -1;\n}\n\ntemplate \nbool Stack::isfull()\n{\n    return top+1 == maxSize;\n}\n\ntemplate \nbool Stack::push(const T& x)\n{\n    if(isfull())\n        return false;\n\n    else\n    {\n        element[top + 1] = x;\n        top++;\n        return true;\n    }\n}\n\ntemplate \nbool Stack::pop(T x)\n{\n    if(isempty())\n        return false;\n    else\n    {\n        x = element[top];\n        top--;\n        return true;\n    }\n}\n#endif\n\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\\\\n\\.cpp\n#include \n#include \"stack.h\"\n\nusing namespace std;\n\nvoid conversion(int n,int base);\n\nint main()\n{\n    int n,base;\n    cout << \"请输入想转换的数字和进制：\" << endl;\n    cin >> n >> base;\n    conversion(n,base);\n    cout << endl;\n    return 0;\n}\nvoid conversion(int n,int base)\n{\n    Stack s(100);\n    int y;\n    y = n;\n    int x;\n    while(y)\n    {\n        s.push(y%base);\n        y = y / base;\n    }\n\n    while(!s.isempty())\n    {\n\n        s.pop(x);\n        cout << x;\n    }\n}\n\n\n\n运行结果及报错内容\n\n\n请输入想转换的数字和进制：\n100 2\n32766327663276632766327663276632766\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果", "Tag": "算法分析"}
{"Answer": "这有个类似的问题, 你可以参考下: https://ask.csdn.net/questions/7679883我还给你找了一篇非常好的博客，你可以看看是否有帮助，链接：c语言删除数组中的元素", "Konwledge_Point": "算法与数字", "Question": "c语言如何进行数组中元素个数的计数\n这是我在做一个名叫 组成最大数 的程序时候想提的问题：如何对输入的数组中的数字个数进行计数\n\n\n以下是我同学教我的方法，但我不怎么懂\n\n\n\n\n#include      \n\nint main()      \n{      \n    int i,\nj\n=0,a[100000],m,n,s,b;      \n    \nfor\n(\ni\n=0;i<=100000;i++)      \n    {      \n        \nm\n=getchar();      \n        \nif\n(\nm\n=='\\n')      \n            break;      \n        a[i]=m-\n'0'\n;      \n        j++;      \n    }      \n    \nfor\n(\ni\n=0;i<j-1;i++)      \n    {      \n        \ns\n=i;      \n        \nfor\n(\nn\n=i+1;n<j;n++)      \n        {      \n            \nif\n(a[s]<a[n])      \n                \ns\n=n;      \n        }      \n        \nb\n=a[i];      \n        a[i]=a[s];      \n        a[s]=b;      \n    }      \n    \nfor\n(\ni\n=0;i<j;i++)      \n    {      \n        printf(\n\"%d\"\n,a[i]);      \n        \nif\n(\ni\n==j-1)      \n            printf(\n\"\\n\"\n);      \n    }      \n}  \n\n\n\n\n\n输入42351之后 就会输出54321，用了冒泡排序，但是那个j（数组中元素个数）有其他方法来计算吗？这个我真的不懂\n\n\n大家有没有什么更简单易懂的方法，让我可以替换掉那个求 j 的部分？", "Tag": "算法分析"}
{"Answer": "scanf(\"%s\",&b[i]);读取字符串不用加&hile (k == n - 1 && x[i] == 0)这个 while应该改成if应该是k == n \n           if (k == n && x[i] == 0)\n\n你题目的解答代码如下：\n#include <stdio.h>\n#include <string.h>\nint main()\n{\n    char a[101], b[101][101];\n    int i = 0, j = 0, k = 0, x[101] = {0};\n    int flag = 0, m = 0, n = 0;\n    gets(a);\n    scanf(\"%d\\n%d\", &flag, &m);\n    for (i = 0; i < m; i++)\n        scanf(\"%s\", b[i]);\n    n = strlen(a);\n    if (flag == 1)\n    {\n        for (i = 0; i < m; i++)\n        {\n            k = 0;\n            int t = 0;\n            for (j = 0; b[i][j] != '\\0'; j++)\n            {\n                if (a[k] == b[i][j])\n                {\n                    k++;\n                }\n                else\n                {\n                    j = t;\n                    t++;\n                    k = 0;\n                }\n                if (k == n && x[i] == 0)//  while应该改成if,应该是k == n\n                {\n                    puts(b[i]);\n                    x[i] = 1;\n                    break;\n                }\n            }\n        }\n    }\n    else\n    {\n        for (i = 0; i < m; i++)\n        {\n            k = 0;\n            int t = 0;\n            for (j = 0; b[i][j] != '\\0'; j++)\n            {\n                if (a[k] == b[i][j] || a[k] == b[i][j] + 32 || a[k] == b[i][j] - 32)\n                {\n                    k++;\n                }\n                else\n                {\n                    j = t;\n                    t++;\n                    k = 0;\n                }\n                if (k == n && x[i] == 0)//  while应该改成if,应该是k == n\n                {\n                    puts(b[i]);\n                    x[i] = 1;\n                    break;\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n\n\n\n如有帮助，请点击我的回答下方的【采纳该答案】按钮帮忙采纳下，谢谢!\n", "Konwledge_Point": "算法与数字", "Question": "请问xdoj 字符串查找 81题，运行结果正确，提交只有20分是为什么，怎样修改\n问题\n\n\n标题\n字符串查找\n\n\n类别\n字符串处理\n\n\n时间限制\n2S\n\n\n内存限制\n256Kb\n\n\n问题描述\n给出一个字符串和多行文字，输出在这些文字中出现了指定字符串的行。\n程序还需要支持大小写敏感选项：\n    当选项打开时，表示同一个字母的大写和小写看作不同的字符；\n    当选项关闭时，表示同一个字母的大写和小写看作相同的字符。\n\n\n输入说明\n输入数据第一行包含一个字符串s，由大小写英文字母组成，长度不超过100。\n第二行包含一个数字，表示大小写敏感选项。当数字为0时表示大小写不敏感，当数字为1时表示大小写敏感。\n第三行包含一个整数n，表示给出的文字行数。\n接下来n行，每行包含一个字符串，字符串由大小写英文字母组成，不含空格和其他字符。每个字符串长度不超过100。\n\n\n输出说明\n输出多行，每行包含一个字符串，按出现的顺序依次给出那些包含了字符串s的行。\n\n\n输入样例\nHello\n1\n5\nHelloWorld\nHiHiHelloHiHi\nGrepIsAGreatTool\nHELLO\nHELLOisNOTHello\n\n\n输出样例\nHelloWorld\nHiHiHelloHiHi\nHELLOisNOTHello\n\n\n问题相关代码\n\n\n我的代码\n\n\n#include\n\n\n#include\n\nint main(){\n    char a[101],b[101][101];\n    int \ni\n=0,j=0,k=0,x[101]={0};\n    int \nflag\n=0,m=0,n=0;\n    gets(a);\n    scanf(\n\"%d\\n%d\"\n,&flag,&m);\n    \nfor\n(\ni\n=0;i\n\n\n#\ninclude\n\n\n\n\nchar\n \ntran\n(\nchar\n a)\n{\n    \nif\n(a<=\n'z'\n&&a>=\n'a'\n) \nreturn\n a\n-32\n;\n    \nelse\n \nif\n(a<=\n'Z'\n&&a>=\n'A'\n) \nreturn\n a+\n32\n;\n}\n\n\nint\n \nmain\n()\n{\n    \nint\n sen,n,i,j,k,l;\n    \nchar\n s[\n101\n],ch[\n1000\n][\n101\n];\n    \nscanf\n(\n\"%s%d%d\"\n,s,&sen,&n);\n    \nfor\n(i=\n0\n;i<n;i++) \nscanf\n(\n\"%s\"\n,ch[i]);\n    \nif\n(sen==\n1\n){\n        \nfor\n(j=\n0\n;j<n;j++){\n//二重循环，在每一行中搜索s\n\n            \nfor\n(k=\n0\n;k<\nstrlen\n(ch[j])-\nstrlen\n(s)+\n1\n;k++){\n//防溢出\n\n                l=\n0\n;\n//初始化在这里进行！\n\n                \nif\n(ch[j][k]==s[\n0\n]){\n                    \nfor\n(;l<\nstrlen\n(s);l++){\n                        \nif\n(ch[j][k+l]!=s[l]) \nbreak\n;\n                    }\n                }\n                \nif\n(l==\nstrlen\n(s)){\n                    \nprintf\n(\n\"%s\\n\"\n,ch[j]);\n                    \nbreak\n;\n                }\n            }\n        }\n    }    \n    \nelse\n \nif\n(sen==\n0\n){\n        \nfor\n(j=\n0\n;j<n;j++){\n            \nfor\n(k=\n0\n;k<\nstrlen\n(ch[j])-\nstrlen\n(s)+\n1\n;k++){\n                l=\n0\n;\n                \nif\n(ch[j][k]==s[\n0\n]||\ntran\n(ch[j][k])==s[\n0\n]){\n                    \nfor\n(;l<\nstrlen\n(s);l++){\n                        \nif\n(ch[j][k+l]!=s[l]&&\ntran\n(ch[j][k+l])!=s[l]) \nbreak\n;\n                    }\n                }\n                \nif\n(l==\nstrlen\n(s)){\n                    \nprintf\n(\n\"%s\\n\"\n,ch[j]);\n                    \nbreak\n;\n                }\n            }\n        }\n    }\n    \nreturn\n \n0\n;\n}\n\n\n\n\n\n运行结果\n\n\n输入样例\nHello\n1\n5\nHelloWorld\nHiHiHelloHiHi\nGrepIsAGreatTool\nHELLO\nHELLOisNOTHello\n\n\n输出样例\nHelloWorld\nHiHiHelloHiHi\nHELLOisNOTHello\n\n\nHello\n0\n5\nHelloWorld\nHiHiHelloHiHi\nGrepIsAGreatTool\nHELLO\nHELLOisNOTHello\n\n\nHelloWorld\nHiHiHelloHiHi\nHELLO\nHELLOisNOTHello", "Tag": "算法分析"}
{"Answer": "递归快排：\n\nint PartQulickSort1(int*a, int left, int right)\n{\n \n    int mid = GetMid(a, left, right);//取中\n    Swap(&a[mid], &a[left]);//将中间的数与最左右的数交换下//swap写的交换函数\n    int keyi = left;//得到基数的位置\n    while (left < right)\n    {\n        while (left<right&&a[right] >= a[keyi])//先从右边找到较小的值\n        {\n            right--;\n        }\n        while (left<right&&a[left] <= a[keyi])//再从左边找最大的值\n        {\n            left++;\n        }\n        Swap(&a[right], &a[left]);//进行交换\n    }\n    Swap(&a[right], &a[keyi]);//最后将right或者left位置的值与基数交换\n    return right;\n\n", "Konwledge_Point": "算法与数字", "Question": "用C语言补充代码，能够输出所需结果\n实现递归快速排序。快速排序使用配分函数和交换函数。这些已经为您实现了。你的任务是实现函数r ecursive_quicksort().TODO在第48行上，该功能从第49行开始。实现是直接的，您先 已经实现了它，你可以转到find_mode_quicksort（）函数，注释出第一个快速排序调用和取消注释recursive_quicksort（）函数。接下来，实现计数排序。你可以在第96行找到TODO，这个函数从第98行开始。在这里，您将一步一步地找到如何实现该函数。注意，在这里也不需要实现查找模式的逻辑，而只需要实现计数排序部分。一旦你实现了计数s 排序后，您可以进入主函数，取消注释启动第二个时钟的块，调用计数排序函数，停止时钟，并打印结果。计数排序不会改变初始数组，因此首先调用它，然后调用快速排序是安全的。快速排序排序到位，所以它改变了顺序 初始数组本身中的元素的r。一旦实现了计数排序，请再次编译并运行代码。比较执行时间 用两种不同的方法来排序，然后找到模式。最后，实现迭代快速排序。你将在第30行找到TODO，算法从第32行开始。可以“硬编码”一个更小的数字输入数组，并包括适当的打印文件来调试您自己的解决方案。若要打印数组的内容，请不要使用大型数组。\n\n\n\n\n\n\n\n\n\n#include \n\n\n#include \n\n\n#include \n\n\n//    Swap function to swap two elements of an\n array\n\n//    Used by pratition\nvoid swap(int* a, int* b) {\n   \n int \ntemp = *a;\n    *a = *b;\n    *b = temp;\n}\n\n//    Partition used by both iterative\n and \nrecursive quicksort\n\nint \npartition(int arr[],\n int \nlow,\n int \nhigh) {\n   \n int \npivot = arr[high];\n   \n int \ni = low - 1;\n    for (int j = low; j <= high - 1; j++) {\n       \n if \n(arr[j] < pivot) {\n            i++;\n            swap(&arr[i], &arr[high]);\n        }\n    }\n    swap(&arr[i+1], &arr[high]);\n   \n return \ni + 1;\n}\n\n//    Iterative quicksort\n//    TODO!!    Implement this function\n//            Follow instructions in the comments below\nvoid iterative_quicksort(int arr[],\n int \nlow,\n int \nhigh) {\n    //    Initialize the \n\"stack data structure\"\n to simulate recursive calls\n    //    Note the size of the array.\n    \n    //    Set \n\"top\"\n as -1\n    \n    //    \n\"Push\"\n low\n and \nhigh to \n\"stack\"\n\n    \n    //    In a while loop, \n\"Pop\"\n two top values from s\n\"tack\"\n and \nsimulate\n    //    call of quicksort. If there are still subarrays to sort, their\n    //    low\n and \nhigh values are \n\"pushed to stack\"\n.\n    //    Ends when \n\"stack is empty\"\n\n    \n}\n\n//    Recursive quicksort\n//    TODO!! Implement this function\nvoid recursive_quicksort(int arr[],\n int \nlow,\n int \nhigh) {\n    \n}\n\n//    For library quicksort\n\nint \ncompare(const void *a,const void *b) {\n   \n int \nx = *(int *)(a);\n   \n int \ny = *(int *)(b);\n   \n return \nx-y;\n}\n\n/*    Finds mode by first sorting the\n array \nwith quicksort \n    NOTE!!!    Quicksort changes the original array,\n            so only one quicksort function can be used at a time.\n            The other function calls can be commented out.\n            qsort() is the library quicksort\n*/\n\nint \nfind_mode_quicksort(int *A,\n int \nlen) {\n    qsort(A,len,sizeof(int),compare);\n    //iterative_quicksort(A, 0, len - 1);\n    //recursive_quicksort(A, 0, len - 1);\n\n    //    Find mode from the sorted array.\n    //    You do\n not \nneed to change this\n   \n int \nmode = A[0];\n   \n int \nfreq = 1;\n   \n int \ntemp = 1;\n   \n int \ni=1;\n\n    while (i < len) {\n       \n if \n(A[i] != A[i-1]) {\n            temp = 1;\n        }\n        else {\n            temp++;\n           \n if \n(temp > freq) {\n                freq = temp;\n                mode = A[i];\n            }\n        }\n        i++;\n    }\n    printf(\n\"\\nQuicksort: Mode = %d, frequence = %d\\n\"\n,mode,freq);\n   \n return \nmode;\n}\n\n//    Finds mode by first sorting\n array \nwith counting sort.\n//    TODO!!    Implement the counting sort algorithm in this function\n//            Follow the instructions in the comments\n\nint \nfind_mode_counting_sort(int *A,\n int \nlen) {\n    //    Initialize output\n array \nB equal in size of\n array \nA\n\n    //    Initialize the temporary auxiliary\n array \nC. Note it's size\n\n    //    Fill the temporary\n array \nC with zeros\n\n    //    Store the count of each element into the temporary\n array \nC\n\n    // Store the cumulative counts into\n array \nC\n\n    //    Find the indexes of the elements of the original\n array\n\n    //   \n and \nplace the elements in the ouput\n array \nB\n\n    //    Find mode from\n array \nB\n    //    You do\n not \nneed to change anything here\n   \n int \nmode = arr_B[0];\n   \n int \nfreq = 1;\n   \n int \ntemp = 1;\n   \n int \ni=1;\n\n    while (i < len) {\n       \n if \n(arr_B[i] != arr_B[i-1]) {\n            temp = 1;\n        }\n        else {\n            temp++;\n           \n if \n(temp > freq) {\n                freq = temp;\n                mode = arr_B[i];\n            }\n        }\n        i++;\n    }\n    printf(\n\"\\nCounting sort: Mode = %d, frequence = %d\\n\"\n,mode,freq);\n    //    Free memory allocated to\n array \nB\n    free(arr_B);\n   \n return \nmode;\n}\n\n//    Initialize\n array \nwith random numbers\n//    from 0 to 999\nvoid initialize(int *A,\n int \nlen) {\n   \n int \ni;\n    for (i=0; i < len; i++) {\n        A[i] = rand()%1000;\n    }\n}\n\n\nint \nmain(){\n    clock_t start,end;\n   \n int \nmode = 0;\n\n    //    Reserve a large\n array\n\n   \n int \n*array = (int *)malloc(100000000*sizeof(int));\n\n    //    Seed random number generator\n    //    Otherwise it produces the same sequence every time\n    //    Although, same sequence could be used\n if \nyou want\n    //    to compare efficiency of different quicksort implementations\n   \n int \nseed = time(NU\nLL);\n\n    srand(seed);\n\n   \n double \ntotaltime;\n   \n int \nsize, threshold;\n\n    printf(\n\"Input array size > \"\n);\n    scanf(\n\"%d\"\n,&size);\n\n    printf(\n\"\\nSearching for mode... \\n\"\n);\n    initialize(array,size);\n\n    /*    Uncomment this block of code when you have implemented\n        the counting sort function\n        \n    start = clock();\n    mode = find_mode_counting_sort(array,size);\n    end = clock();\n    totaltime = (double)(end-start)/C\nLOCKS_PER_SEC;\n\n    printf(\n\"Mode:%d, Consumed time: %f seconds \\n\"\n,mode,totaltime);\n    */\n\n    start = clock();\n    mode = find_mode_quicksort(array,size);\n    end = clock();\n    totaltime = (double)(end-start)/C\nLOCKS_PER_SEC;\n\n    printf(\n\"Mode:%d, Consumed time: %f seconds \\n\"\n,mode,totaltime);\n\n    // Free memory allocated to the\n array\n\n    free(array);\n\n   \n return \n0;\n}\n\n", "Tag": "算法分析"}
{"Answer": "主要的问题是你已经用递归了，那么for(int i=start;i<9;i++)这个循环就不需要了，递归本身就相当于这个循环把这层循环去掉，同时把i都改为start\n#include <iostream>\n#include <cstring>\nusing namespace std;\nint queen( int col[9],int start){    //数组的下标代表列,col[i]的值代表在该列放的皇后所在的行数.\n    if(start == 9){\n            for(int j = 1; j <9; j++)cout << col[j] ;\n            cout << endl;\n            return 0;//假如正常进行到第八列, 就输出数组;\n        }\n //   for(int i =start; i <9; i ++){\n        for(int k = 1; k <9; k++){\n            bool flag = true;\n            col[start] = k;//给第i列的第k行放上皇后;\n            for(int j = 1; j < 9;j++){\n                if (start == j || col[j] == 0) continue;//不与同一个格子、没有放皇后的格子;进行比较\n                if(col[j] == col[start]|| start+col[start] == j + col[j] || start- col[start] == j-col[j]) {//检测是否有同行、同对角线的皇后\n                        flag = false;col[start] = 0;break;/*如果有问题,flag输出false,跳出循环\n                                                        如果没有,flag为true;尝试在下一列放置皇后*/\n                    }\n                }\n            if(flag){\n                if(!col[start]) return 0;//如果flag为true,而且在该列放置了皇后,就继续对下一列进行放置操作;如果未放置,说明此时无解,跳出本层递归;\n                queen(col,start+1);\n            }\n //       }\n    }\n}\n \nint main(){\n int queens[9] = {0};\n queen(queens,1);\nreturn 0;\n}\n\n\n", "Konwledge_Point": "算法与数字", "Question": "写了一个求解八皇后问题的问题代码\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n\nusing\n \nnamespace\n std;\n\n\nint\n \nqueen\n( \nint\n col[\n9\n],\nint\n start)\n{    \n//数组的下标代表列,col[i]的值代表在该列放的皇后所在的行数.\n\n    \nif\n(start == \n9\n){\n            \nfor\n(\nint\n j = \n1\n; j <\n9\n; j++)cout << col[j] ;\n            cout << endl;\n            \nreturn\n \n0\n;\n//假如正常进行到第八列, 就输出数组;\n\n        }\n    \nfor\n(\nint\n i =start; i <\n9\n; i ++){\n        \nfor\n(\nint\n k = \n1\n; k <\n9\n; k++){\n            \nbool\n flag = \ntrue\n;\n            col[i] = k;\n//给第i列的第k行放上皇后;\n\n            \nfor\n(\nint\n j = \n1\n; j < \n9\n;j++){\n                \nif\n (i == j || col[j] == \n0\n) \ncontinue\n;\n//不与同一个格子、没有放皇后的格子;进行比较\n\n                \nif\n(col[j] == col[i]|| i+col[i] == j + col[j] || i- col[i] == j-col[j]) {\n//检测是否有同行、同对角线的皇后\n\n                        flag = \nfalse\n;col[i] = \n0\n;\nbreak\n;\n/*如果有问题,flag输出false,跳出循环\n                                                        如果没有,flag为true;尝试在下一列放置皇后*/\n\n                    }\n                }\n            \nif\n(flag){\n                \nif\n(!col[i]) \nreturn\n \n0\n;\n//如果flag为true,而且在该列放置了皇后,就继续对下一列进行放置操作;如果未放置,说明此时无解,跳出本层递归;\n\n                \nqueen\n(col,start+\n1\n);\n            }\n        }\n    }\n}\n\n\n\nint\n \nmain\n()\n{\n \nint\n queens[\n9\n] = {\n0\n};\n\n \nqueen\n(queens,\n1\n);\n}\n\n\n\n\n以上,输出了很多很多个数字..", "Tag": "算法分析"}
{"Answer": "你的算法慢是因为：\n你用的排序算法是O(n^2), 可以直接用Arrays.sort()优化。你最后获取序号的算法也是O(n^2), 可以用哈希表优化成O(n)\n\nclass Solution {\n    public int[] arrayRankTransform(int[] arr) {\n        int[] arr_copy = Arrays.copyOf(arr, arr.length);\n        Arrays.sort(arr_copy);\n        Map<Integer, Integer> record = new HashMap<>();\n        int index = 1;\n        for (int num : arr_copy) {\n            if (!record.containsKey(num)) {\n                record.put(num, index++);\n            }\n        }\n        for (int i=0; i<arr.length; ++i) {\n            arr[i] = record.get(arr[i]);\n        }\n        return arr;\n    }\n}\n", "Konwledge_Point": "算法与数字", "Question": "优化一段代码，主要是for循环。希望减少运行时间。\n下面这段代码是将输入的数字进行排序后，将排好的序号替换掉原来数组中元素位置上的值。\n\n\n例如\n\n\n\n\n求优化下列代码。运行时间长，效率不高。\n\n\nclass\n \nSolution\n {\n    \npublic\n \nint\n[] \narrayRankTransform\n(\nint\n[] arr\n)\n {\n        \nint\n i, j, k;\n       \n        \nint\n arr_a[] = arr;\n        HashSet \nset\n = \nnew\n HashSet<>();\n\n\n//        for (int i1 : arr_a) {\n\n\n//            System.out.println(i1);\n\n\n//\n\n\n//        }\n\n\n        \nfor\n (\nint\n x = \n0\n; x < arr.length; x++) {\n            \nset\n.\nadd\n(arr_a[x]);\n        }\n        Integer arr_b[] = \nset\n.toArray(\nset\n.toArray(\nnew\n Integer[]{}));\n\n        \nfor\n (i = \n0\n; i < arr_b.length - \n1\n; i++) {\n            \nfor\n (j = \n0\n; j < arr_b.length - i - \n1\n; j++) {\n                \nif\n (arr_b[j] > arr_b[j + \n1\n]) {\n                    k = arr_b[j];\n                    arr_b[j] = arr_b[j + \n1\n];\n                    arr_b[j + \n1\n] = k;\n                }\n            }\n\n        }\n       \n        \nfor\n (\nint\n i1 = \n0\n; i1 < arr.length; i1++) {\n            \nfor\n (\nint\n i2 = \n0\n; i2 < arr_b.length; i2++) {\n                \nif\n (arr[i1] == arr_b[i2]) {\n                    arr[i1] = i2 + \n1\n;\n                    \nbreak\n;\n\n                }\n\n            }\n\n\n        }\n        \nreturn\n arr;\n\n    }\n}\n\n", "Tag": "算法分析"}
{"Answer": "代码如下：\n\n#include <stdio.h>\n#define LEN 10\nstruct queue {\n    int Data[LEN];\n    int Rear;\n    int Front;\n};\n\nvoid InitQueue(struct queue* q)\n{\n    for(int i=0;i<LEN;i++)\n        q->Data[i] = -1;\n}\n\n//输出\nvoid show(struct queue* q,int head)\n{\n    int i,j;\n    for(i=head,j=0;j<LEN;i++,j++)\n    {\n        if(q->Data[i%LEN] != -1)\n            printf(\"%d\",q->Data[i%LEN]);\n    }\n    printf(\"\\n\");\n}\n\n\n\nint main()\n{\n    char str[12] = { 0 };\n    int qhead; //对头位置\n    int sn, snindex; //蛇头元素和蛇头下标\n    int i, v, size = 0;\n    struct queue Qa;\n    InitQueue(&Qa); //初始化队列\n    scanf(\"%s %d\", str, &qhead);\n    scanf(\"%d %d\", &sn, &snindex);\n    Qa.Front = qhead; //队头\n\n    //将数字串放入队列\n    for (i = 0; str[i] != '\\0'; i++)\n        Qa.Data[(qhead+i)%LEN] = str[i]-'0'; //循环排放\n    \n    \n    //如果队头下标==蛇头下标，直接输出即可\n    if (qhead == snindex)\n    {\n        show(&Qa,qhead);\n        printf(\"%d %d\\n\", sn, snindex);\n        return 0;\n    }\n    else\n    {\n        //如果队头==0\n        if (qhead == 0)\n        {\n            //队尾肯定在最后，所以蛇头直接向前移动即可\n            while (snindex > qhead)\n            {\n                //队列数据前移\n                v = Qa.Data[snindex - 1];\n                for (i = snindex; i < LEN; i++)\n                    Qa.Data[i - 1] = Qa.Data[i];\n                Qa.Data[LEN - 1] = v;\n                snindex--;\n                //输出蛇元素\n                show(&Qa,qhead);\n                printf(\"%d %d\\n\", sn, snindex);\n            }\n        }\n        else\n        {\n            // 对头下标不为0，队尾肯定在头的左侧\n            Qa.Rear = Qa.Front - 1;\n            //如果蛇头初始位置在队尾的左侧\n            if (snindex <= Qa.Rear)\n            {\n                //先向左侧\n                while (snindex > 0)\n                {\n                    v = Qa.Data[snindex - 1];\n                    for (i = snindex; i <= Qa.Rear; i++)\n                        Qa.Data[i - 1] = Qa.Data[i];\n                    Qa.Data[Qa.Rear] = v;\n                    snindex--;\n                    //打印\n                    show(&Qa,qhead);\n                    printf(\"%d %d\\n\", sn, snindex);\n                }\n                //snindex == 0\n                v = Qa.Data[LEN-1]; //\n                Qa.Data[LEN-1]= Qa.Data[0];\n                for(i=0;i<Qa.Rear;i++)\n                    Qa.Data[i] = Qa.Data[i+1];\n                Qa.Data[Qa.Rear] = v;\n                snindex = LEN - 1;\n                show(&Qa,qhead);\n                printf(\"%d %d\\n\",sn,snindex);\n\n                //左侧吃完后，绕到数组末尾开始\n                \n                while (snindex > qhead)\n                {\n                    v = Qa.Data[snindex - 1];\n                    //蛇头后半部分移动\n                    for (i = snindex; i < LEN; i++)\n                        Qa.Data[i - 1] = Qa.Data[i];\n                    Qa.Data[LEN - 1] = Qa.Data[0];\n                    for (i = 0; i < Qa.Rear; i++)\n                        Qa.Data[i] = Qa.Data[i + 1];\n                    Qa.Data[Qa.Rear] = v;\n                    snindex--;\n                    if (v == -1)\n                        continue;\n                    show(&Qa,qhead);\n                    printf(\"%d %d\\n\", sn, snindex);\n                }\n            }\n            else\n            {\n                //蛇头在队尾的右侧\n                //size = LEN - (snindex - qhead); //初始蛇身长度（含-1）\n                while (snindex > qhead)\n                {\n                    v = Qa.Data[snindex - 1];\n                    //蛇头后半部分移动\n                    for (i = snindex; i < LEN; i++)\n                        Qa.Data[i - 1] = Qa.Data[i];\n                    Qa.Data[LEN - 1] = Qa.Data[0];\n                    for (i = 0; i < Qa.Rear; i++)\n                        Qa.Data[i] = Qa.Data[i + 1];\n                    Qa.Data[Qa.Rear] = v;\n                    snindex--;\n                    show(&Qa,qhead);\n                    printf(\"%d %d\\n\", sn, snindex);\n                }\n            }\n        }\n    }\n    return 0;\n}\n\n", "Konwledge_Point": "算法与数字", "Question": "关于使用数据结构队列创建贪吃蛇的问题\n需要设计一个顺序循环队列，长度len为10，队列中有n个元素（1≤n<10）。选择任意一个元素为蛇的头部，队尾元素为蛇的尾部。贪吃蛇开始移动吃他前面的元素，并追加至蛇的尾部，使蛇变长。\n\n\n第1行，第1个数为一串整形数字，第2个元素表示队头元素的下标值。\n第2行，第1个数表示蛇头部的元素，第2个数表示蛇头部元素的下标值。\n\n\n输入样例\n123456789 0\n3 2\n输出样例\n134567892\n3 1\n345678921\n3 0\n\n\n本人学艺不精，只会队列的入队出队，请问如何在该代码的基础上将其修改为符合题目的需求\n\n\n#\ninclude\n\n#\ninclude\n\n\n\nstruct\n queue{\n    \nint\n Data\n[\n100\n]\n;\n    \nint\n Rear;\n    \nint\n Front;\n};\nvoid \nCreatequeue(\nstruct\n \nqueue\n \n*\nq\n)\n\n{\n    q->Rear = -\n1\n;\n    q->Front = -\n1\n;\n}\nvoid \nAddqueue(\nstruct\n \nqueue\n \n*\nq\n, \nint\n \nx\n)\n\n{\n    q->Rear++;\n    q->Data\n[\nq\n->R\near\n]\n = x;\n}\n\nint\n \nOutqueue(\nstruct\n \nqueue\n \n*\nq\n)\n\n{\n    q->Front++;\n    return q->Data\n[\nq\n->F\nront\n]\n;    \n}\n\nint\n \nIsqueue(\nstruct\n \nqueue\n \n*\nq\n)\n \n{\n    \nint\n i;\n    \nif\n(q->Rear\n == \nq->Front) {\n        i = \n0\n;\n    }\n    \nelse\n {\n        i = \n1\n;\n    }\n\n    return i;\n} \n\nint\n main\n()\n\n{\n    \nstruct\n queue Qa;\n    \nCreatequeue(&Qa)\n;\n    \nint\n i; \n    \nfor\n(i = \n0\n;i<\n9\n;i++)\n    {\n        \nAddqueue(&Qa,\ni\n)\n;\n    }\n    \nwhile\n(\nIsqueue(&Qa)\n)\n    {\n    \nint\n    k = \nOutqueue(&Qa)\n;\n        printf(\n\"%d\"\n,k);\n    }\n    \n    \n}\n", "Tag": "算法分析"}
{"Answer": "第一个代码第8行多了个；", "Konwledge_Point": "算法与数字", "Question": "两段同样的冒泡排序代码产生不同的结果\n在学习了冒泡法后尝试用冒泡法把数字由小到大排序，但是第一次输出的结果顺序未变，又敲了一遍结果又正确了，很奇怪。\n\n\n产生错误结果的代码：\n\n\n#include\n\nint main()\n{\n    int a[10];\n    int j,i,m;\n    \nfor\n(\ni\n=0;i<10;i++)\n    scanf(\n\"%d\"\n,&a[i]);\n    \nfor\n(\nj\n=0;j<9;j++);\n        {\n            \nfor\n(\ni\n=0;i<9-j;i++)\n            {\n                \nif\n(a[i]>a[i+1])\n                {\n                    \nm\n=a[i];a[i]=a[i+1];a[i+1]=m;\n                }\n            }\n        } \n    \nfor\n(\ni\n=0;i<10;i++)\n    printf(\n\"%-3d\"\n,a[i]);\n    return 0;\n}\n\n\n\n\n产生正确结果的代码：\n\n\n#include\n\nint main()\n{\n    int a[10];\n    int i,j,t;\n    \nfor\n(\ni\n=0;i<10;i++)\n    scanf(\n\"%d\"\n,&a[i]);\n    \nfor\n(\nj\n=0;j<9;j++)\n    {\n        \nfor\n(\ni\n=0;i<9-j;i++)\n        {\n            \nif\n(a[i]>a[i+1])\n            {\n                \nt\n=a[i];a[i]=a[i+1];a[i+1]=t;\n            }\n        }\n    }\n    \nfor\n(\ni\n=0;i<10;i++)\n    printf(\n\"%-3d\"\n,a[i]);\n    return 0;\n}\n\n\n\n\n代码1输出的为原始顺序，代码2输出才是由小到大的正确顺序 ，不知道到底哪里不一样导致了错误。", "Tag": "算法分析"}
{"Answer": "main函数中：int l = left, r = right;//这里left和right都没有初始化，需要先给left和right赋值，看你main函数中也没用，这一句注释掉就可以了for (i = 0; i < n; i++)        printf(\"%d\", a[i]);//这里不需要&", "Konwledge_Point": "算法与数字", "Question": "请问我这个程序错在哪里？\n#include \n\nint\n myswap(\nint\n* \narray\n, \nint\n left, \nint\n right)\n{\n    \nint\n tmp = \narray\n[left];\n    \narray\n[left] = \narray\n[right];\n    \narray\n[right] = tmp;\n    \nreturn\n \n0\n;\n}\n\nint\n quicksort(\nint\n* a, \nint\n left, \nint\n right)\n{\n    \nif\n (left >= right)\n        \nreturn\n \n0\n;\n    \nint\n l = left, r = right;\n//最左边的数为左标记，最右边的数为右标记\n\n    \nint\n pivot = a[left];\n//选择最左边的数字为排序基准(pivot)\n\n    \nfor\n (;;)\n    {\n        \nwhile\n (*(a + \n1\n) <= *(a + pivot) && l < right)\n            l++;\n        \nwhile\n (*(a + r) >= *(a + pivot) && r > l)\n            r--;\n        \nif\n (l < r)\n            myswap(a, l, r);\n        \nelse\n\n            \nbreak\n;\n    }\n    \nif\n (*(a + pivot) < *(a + r))\n//如果此时（右标记）尾指针指向的元素刚好大于枢纽元素\n\n        myswap(a, pivot, r);\n//枢纽和尾指针进行交换使得枢纽元右侧的元素全部大于枢纽元素\n\n    quicksort(a, left, r - \n1\n);\n    quicksort(a, r + \n1\n, right);\n//递归\n\n}\n\nint\n main()\n{\n    \nint\n a[\n100\n], left, right,n,i;\n//一开始设的数组里不能是未知数\n\n    \nint\n l = left, r = right;\n    scanf(\n\"%d\"\n, &n);\n    \nfor\n (i = \n0\n; i < n; i++)\n        scanf(\n\"%d\"\n, &a[i]);\n    quicksort(a, \n0\n, n\n-1\n);\n    \nfor\n (i = \n0\n; i < n; i++)\n        printf(\n\"%d\"\n, &a[i]);\n}\n\n\n\n\n前几天误以为自己会了，今天复习，改了好几遍程序后发现还是有错误", "Tag": "算法分析"}
{"Answer": "参考https://blog.csdn.net/libaoshan55/article/details/76652228", "Konwledge_Point": "算法与数字", "Question": "Python用栈模拟递归解决找零钱问题\n问题遇到的现象和发生背景\n\n\n我想要写一些代码，用栈模拟递归解决找零钱问题\n然后我想了很久的代码，可总是会有问题，数字小没有问题，可一旦数字大起来，不但不好Debug，而且答案也不对\n我下面的代码该怎么修改才能正确，或者写怎样的代码能解决这道问题(Python或者伪代码， 所写代码为Python)\n原题目是一个客户来到商店，买了37元的东西，他给了服务员100元，服务员现在手头有1元, 3元， 5元,10元，21元和25元的纸币，请问服务员最少要给客户几张纸币(元不能重复输入，并不是我不想每个后面都加上元)\n\n\n问题相关代码，请勿粘贴截图\n\n\nfrom DoStack import Stack\n\n\ndef recDC(coinValueList, change, knownResults):\n    \n\"\"\n\"\n\n    :param coinValueList: list -> hava denominations of money\n    :param change: int -> amount of money to change\n    :param knownResults: list -> number of steps per known solution\n    :return: int -> optimal solution\n    \"\n\"\"\n\n    stack = Stack()\n    stack.push(\n[\n[coinValueList, change, knownResults]\n, \n[]\n]\n)\n    # stack\n[0]\n \nis\n list \nof\n parameter stack\n[0]\n[0]\n \nis\n coins stack\n[0]\n[1]\n \nis\n amount stack\n[0]\n[2]\n \nis\n list \nof\n money\n    # stack\n[1]\n \nis\n list \nof\n return value\n    \n\"\"\n\"\n    minCoins = change\n    if change in coinValueList:  # 递归结束基本条件\n        knownResults\n[change]\n = 1  # 记录最优解\n        return 1\n    elif knownResults\n[change]\n > 0:\n        return knownResults\n[change]\n  # 查表成功,直接使用最优解\n    else:\n        for i in \n[c for c in coinValueList if c <= change]\n:\n            numCoins = 1 + recDC(coinValueList, change - i, knownResults)\n            if numCoins < minCoins:\n                minCoins = numCoins\n                # 找到最优解,记录到表中\n                knownResults\n[change]\n = minCoins\n    return minCoins\n    \"\n\"\"\n\n    while not stack.isEmpty():\n        f = stack.pop()\n        flag = False\n        minCoins = f\n[0]\n[1]\n\n        if f\n[0]\n[1]\n in f\n[0]\n[0]\n:\n            f\n[0]\n[2]\n[f\n[0]\n[1]\n]\n = 1\n            if stack.isEmpty():\n                return 1\n            minCoins = 1\n        elif f\n[0]\n[2]\n[f\n[0]\n[1]\n]\n > 0:\n            if stack.isEmpty():\n                return f\n[0]\n[2]\n[f\n[0]\n[1]\n]\n\n            minCoins = f\n[0]\n[2]\n[f\n[0]\n[1]\n]\n\n        else:\n            l = \n[]\n\n            for c in f\n[0]\n[0]\n:\n                if c <= f\n[0]\n[1]\n:\n                    l.append(c)\n            for i in l:\n                if len(f\n[1]\n) < l.index(i) + 1:\n                    stack.push(f)\n                    stack.push(\n[\n[f\n[0]\n[0]\n, f\n[0]\n[1]\n - i, f\n[0]\n[2]\n]\n, \n[]\n]\n)\n                    flag = True\n                    break\n                else:\n                    if f\n[1]\n[l.index(i)]\n + 1 < minCoins:\n                        minCoins = f\n[1]\n[l.index(i)]\n + 1\n                        f\n[0]\n[2]\n[f\n[0]\n[1]\n]\n = minCoins\n        if flag:\n            continue\n        elif flag:\n            continue\n        else:\n            f = stack.pop()\n            stack.push(\n[\n[f\n[0]\n[0]\n, f\n[0]\n[1]\n, f\n[0]\n[2]\n]\n, \n[minCoins]\n]\n)\n\n\nprint(recDC(\n[1, 3, 5, 10, 21, 25]\n, 63, \n[0]\n * (63 + 1)))\n\n\n\n\nStack代码\n\n\nclass\n \nStack\n(\nobject\n):\n    \ndef\n \n__init__\n(\nself\n):\n        self.Stack = \nlist\n()\n\n    \ndef\n \npush\n(\nself, item\n):\n        self.Stack.append(item)\n\n    \ndef\n \npeek\n(\nself\n):\n        \nreturn\n self.Stack[-\n1\n]\n\n    \ndef\n \npop\n(\nself\n):\n        _\nreturn\n = self.Stack[-\n1\n]\n        self.Stack.pop()\n        \nreturn\n _\nreturn\n\n\n    \ndef\n \nisEmpty\n(\nself\n):\n        \nif\n \nlen\n(self.Stack) != \n0\n:\n            \nreturn\n \nFalse\n\n        \nreturn\n \nTrue\n\n\n    \ndef\n \nsize\n(\nself\n):\n        \nreturn\n \nlen\n(self.Stack)\n\n    \ndef\n \nnumber\n(\nself\n):\n        \nreturn\n self.Stack\n\n\n\n\n\n运行结果及报错内容\n\n\n理想的结果应该是3， 可运行出的答案却是39，\n\n\n我的解答思路和尝试过的方法\n\n\n我开始是想将问题分解成一个个子问题压入栈，可是代码实现起来却难如登天，最后我选择用二叉树的画法的思路(先将一条进行到底，然后一步步往回退)，但还是没有达到效果，Debug了半天也没找到问题所在，括号多出天际， 看起来贼费劲，最后搞不下去了，还有没有其他的办法可以解决这个问题啊\n\n\n我想要达到的结果\n\n\n运行出来答案是3，而不是39", "Tag": "算法分析"}
{"Answer": "可能是你没有对a进行范围校验，a的输入范围是1~9", "Konwledge_Point": "算法与数字", "Question": "[Java]连续数求和：a+2个a+..+ n个a。代码自测无问题，但平台用例通过50%。\n这是一道机试题，要求Java实现\n本地测试用例都通过了，但平台的测试用例只通过了50%，无法得知平台使用什么测试用例。\n\n\n------原题描述-------------------------------------------------------------------------------------------------------------------\n题目名称：连续数求和\n有这样一类数列，例如：\n数列1：2, 22, 222, 2222, 22222, 222222\n数列2：3, 33, 333, 3333, 33333, 333333, 333333等\n其中每个数的各位数上的值相同，范围1-9。\n输入：a,n，其中a是第一个数字，n是位数。输出：以上形式的数列和(即：a+2个a+..+ n个a)。\n如输入：2,5\n则输出最终求和：24690\n（即：2+22+222+2222+22222（5个2）=24690）\n输入：3,8\n则输出最终求和：37037034\n（即：3+33+333+3333+33333+333333+3333333+33333333（8个3）=37037034）\n注意：请不要修改框架代码，完成getSum函数代码，不要修改函数名，入参，及返回值。\n\n\n\n\n个人说明：\n代码结构平台已预处理好，无需处理输入输出等。只需完成getSum函数，getSum函数结构如下：\n\n\npublic\n \nstatic\n \nlong\n \ngetSum\n(\nint\n a, \nint\n n)\n \n{\n}\n\n\n\n\n个人完整实现如下：\n\n\npublic\n \nstatic\n \nlong\n getSum(\nint\n a, \nint\n n) {\n        \nlong\n \nsum\n = \n0\n;\n        \nlong\n x = a;\n        \nfor\n (\nint\n i = \n0\n; i < n; i++) {\n            \nsum\n = \nsum\n + x;\n            x = x * \n10\n + a;\n        }\n        \nreturn\n \nsum\n;\n}\n\n", "Tag": "算法分析"}
{"Answer": "**row 创建了一级指针地址内存，2级指针地址不知道里面多少个一级指针，定义为*row[10]，可以这么用", "Konwledge_Point": "算法与数字", "Question": "一道编程题，自己做的结果对，但是就是通不过牛客网上的编译器，不知为什么？\n洗牌在生活中十分常见，现在需要写一个程序模拟洗牌的过程。 现在需要洗2n张牌，从上到下依次是第1张，第2张，第3张一直到第2n张。\n\n首先，我们把这2n张牌分成两堆，左手拿着第1张到第n张（上半堆），右手拿着第n+1张到第2n张（下半堆）。接着就开始洗牌的过程，\n\n先放下右手的最后一张牌，再放下左手的最后一张牌，接着放下右手的倒数第二张牌，再放下左手的倒数第二张牌，\n\n直到最后放下左手的第一张牌。接着把牌合并起来就可以了。 例如有6张牌，最开始牌的序列是1,2,3,4,5,6。首先分成两组，\n\n左手拿着1,2,3；右手拿着4,5,6。在洗牌过程中按顺序放下了6,3,5,2,4,1。把这六张牌再次合成一组牌之后，\n\n我们按照从上往下的顺序看这组牌，就变成了序列1,4,2,5,3,6。 现在给出一个原始牌组，请输出这副牌洗牌k次之后从上往下的序列。\n\n输入描述:\n\n第一行一个数T(T ≤ 100)，表示数据组数。对于每组数据，第一行两个数n,k(1 ≤ n,k ≤ 100)，\n\n接下来一行有2n个数a1,a2,...,a2n(1 ≤ ai ≤ 1000000000)。表示原始牌组从上到下的序列。\n\n\n\n输出描述:\n\n对于每组数据，输出一行，最终的序列。数字之间用空格隔开，不要在行末输出多余的空格。\n\n\n\n输入例子:\n\n3\n\n3 1\n\n1 2 3 4 5 6\n\n3 2\n\n1 2 3 4 5 6\n\n2 2\n\n1 1 1 1\n\n\n\n输出例子:\n\n1 4 2 5 3 6\n\n1 5 4 3 2 6\n\n1 1 1 1\n\n\n\n#include \n\n#include \n\n\n\nvoid Shuffle()\n\n{\n\n    //输入要进行洗牌的组数\n\n    int groups;\n\n    scanf(\"%d\", &groups);\n\n\n\nint i, j, k;                        //循环变量\nint g;                              //定义了循环变量g，遍历每组数据\nint n;                              //定义了一堆牌数量变量n，共2n张牌\nint times;                          //定义了要进行洗牌的次数\n\n//动态分配结果输出数组的行\nint **row = (int**)malloc(sizeof(int*)*groups);\nfor (g = 0; g < groups; g++)\n{\n    scanf(\"%d\", &n);        //输入要进行洗牌的n张牌，共2n张牌\n    scanf(\"%d\", ×);    //输入要进行洗牌的次数\n\n    //动态分配结果输出数组的列\n    row[g] = (int *)malloc(sizeof(int) * 2 * n);\n\n    //为要洗的牌初始化\n    int value;\n    int *cards = (int *)malloc(sizeof(int) * 2 * n);\n    for (i = 0; i < 2 * n; i++)\n    {\n        scanf(\"%d\", &value);\n        cards[i] = value;\n    }\n\n    int *tmp_array = (int *)malloc(sizeof(int) * 2 * n);    //临时存储结果数组\n\n    //按照输入的洗牌次数进行洗牌\n    for (j = 0; j < times; j++)\n    {\n        int LPos = 0, RPos = n;                             //两堆牌的起始点\n        int LeftEnd = n - 1, RightEnd = 2 * n - 1;          //两堆牌的终点\n\n        k = 0;\n        while (LPos <=LeftEnd && RPos<= RightEnd)\n        {\n            tmp_array[k++] = cards[LPos++];\n            tmp_array[k++] = cards[RPos++];\n        }\n\n        //cards临时结果\n        for (i = 0; i < 2 * n; i++)\n            cards[i] = tmp_array[i];\n    }\n\n    //保存结果\n    for (i = 0; i < 2 * n; i++)\n        row[g][i] = tmp_array[i]; \n\n    //释放空间\n    free(cards);\n    free(tmp_array);\n}\n\n//输出结果\nfor (i = 0; i < groups; i++)\n{\n    j = 0;\n    while (row[i][j]>0)             //这里是我处理内存溢出bug的方法，比较简陋\n    {\n        printf(\"%d \", row[i][j]);\n        j++;\n    }\n    printf(\"\\n\");\n}\n\n\n\n\n}\n\n\n\nint main()\n\n{\n\n      Shuffle();\n\n    return 0;\n\n}", "Tag": "算法分析"}
{"Answer": "这个init是不对的， 如果返回一个形参 begin和end的值会乱掉的，只是值拷贝。 要malloc返回一个地址queue army = init(); 这句话运行后会产生一个先的变量，地址是改了的。先把这个改了试试\nqueue init(void) {\n    queue temp;\n    temp.current = 0;//现在的元素个数是0\n    temp.begin = temp.store;//两个指针都指向 数组\n    temp.end = temp.store;\n \n    return temp;\n\nmain函数这样改了一下输出好像对了\nint main(void) {\n    //queue army = init();//初始化一个链表\n    queue army;\n    army.current = 0;//现在的元素个数是0\n    army.begin = army.store;//两个指针都指向 数组\n    army.end = army.store;\n\n    push(&army);//此后几行是调试 ，结构发现错误了\n    push(&army);\n    push(&army);\n    pop(&army);\n    show(army);\n\n    return 0;\n}\n\n", "Konwledge_Point": "算法与数字", "Question": "环形队列使用指针导致错误了\n//环形队列\n\n\n// 不知道 哪里不对 了\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ndefine\n max 10\n\n\ntypedef\n \nstruct\n \nQueue\n {\n    \nint\n current;\n    \nint\n store[max];\n    \nint\n* begin, * end;\n}queue;\n\nqueue \ninit\n(\nvoid\n)\n;\n//初始化\n\n\nvoid\n \npush\n(queue*)\n;\n//入队列\n\n\nvoid\n \npop\n(queue*)\n;\n//出队列\n\n\nvoid\n \nshow\n(queue)\n;\n//遍历队列元素\n\n\nint\n \nmain\n(\nvoid\n)\n \n{\n    queue army = \ninit\n();\n//初始化一个链表\n\n    \npush\n(&army);\n//此后几行是调试 ，结构发现错误了\n\n    \npush\n(&army);\n    \npush\n(&army);\n    \npop\n(&army);\n    \nshow\n(army);\n \n    \nreturn\n \n0\n;\n}\n\nqueue \ninit\n(\nvoid\n)\n \n{\n    queue temp;\n    temp.current = \n0\n;\n//现在的元素个数是0\n\n    temp.begin = temp.store;\n//两个指针都指向 数组\n\n    temp.end = temp.store;\n \n    \nreturn\n temp;\n}\n\nvoid\n \npush\n(queue* temp)\n \n{\n    \nif\n (temp->current == max) {\n//数据存放满\n\n        \nputs\n(\n\"队列已满，无法入队列\"\n);\n        \nexit\n(\n-1\n);\n    }\n    \nputs\n(\n\"请输入要入队列的数据\"\n);\n    \nint\n income;\n    \nscanf_s\n(\n\"%d\"\n, &income);\n    *(temp->end)++ = income;\n// 在 end 位置写入 数据，然后end指针后移一位 \n\n    \nprintf\n(\n\"%d已入队列\\n\"\n, *(temp->end - \n1\n));\n    temp->current++; \n//队列数据 +1\n\n    \nif\n (temp->end == &(temp->store[max])) {\n//如果越界\n\n        temp->end = &(temp->store[\n0\n]);\n//指向开头位置\n\n    }\n}\n\nvoid\n \npop\n(queue* temp)\n \n{\n    \nif\n (temp->current == \n0\n) {\n        \nputs\n(\n\"队列为空，无法出队列\"\n);\n        \nexit\n(\n-1\n);\n    }\n    \nprintf\n(\n\"%d已出队列\"\n, *(temp->begin)++);\n//begin指针读取数字， 然后 后移一位 \n\n    temp->current--;\n    \nif\n (temp->begin == &(temp->store[max])) {\n//如果越界\n\n        temp->begin = &(temp->store[\n0\n]);\n//指向开头位置\n\n    }\n}\n\nvoid\n \nshow\n(queue temp)\n \n{\n    \nprintf\n(\n\"temp.current is %d\\n\"\n, temp.current);\n    \nwhile\n(temp.current != \n0\n) {\n        \nif\n (temp.begin != temp.store) {\n            \nprintf\n(\n\"--%d--\"\n, *(temp.begin));\n            temp.begin++;\n        }\n        temp.current--;\n    }\n}\n\n", "Tag": "算法分析"}
{"Answer": "谢谢大家，已经解决了", "Konwledge_Point": "算法与数字", "Question": "用tensorflow做机器翻译时训练代码有问题\n# -*- coding:UTF-8 -*-\nimport tensorflow as tf\n\n\nsrc_path = 'D:/Python37/untitled1/train.tags.en-zh.en.deletehtml'\ntrg_path = 'D:/Python37/untitled1/train.tags.en-zh.zh.deletehtml'\n\nSRC_TRAIN_DATA = 'D:/Python37/untitled1/train.tags.en-zh.en.deletehtml.segment'  # 源语言输入文件\nTRG_TRAIN_DATA = 'D:/Python37/untitled1/train.tags.en-zh.zh.deletehtml.segment'  # 目标语言输入文件\nCHECKPOINT_PATH = './model/seq2seq_ckpt'  # checkpoint保存路径\nHIDDEN_SIZE = 1024                  # LSTM的隐藏层规模\nNUM_LAYERS = 2                      # 深层循环神经网络中LSTM结构的层数\nSRC_VOCAB_SIZE = 10000              # 源语言词汇表大小\nTRG_VOCAB_SIZE = 4000               # 目标语言词汇表大小\nBATCH_SIZE = 100                    # 训练数据batch的大小\nNUM_EPOCH = 5                       # 使用训练数据的轮数\nKEEP_PROB = 0.8                     # 节点不被dropout的概率\nMAX_GRAD_NORM = 5                   # 用于控制梯度膨胀的梯度大小上限\nSHARE_EMB_AND_SOFTMAX = True        # 在softmax层和词向量层之间共享参数\nMAX_LEN = 50                        # 限定句子的最大单词数量\nSOS_ID = 1                          # 目标语言词汇表中的ID\n\n\n\"\"\"\nfunction: 数据batching,产生最后输入数据格式\nParameters:\n    file_path-数据路径\nReturns:\n    dataset-　每个句子－对应的长度组成的TextLineDataset类的数据集对应的张量\n\"\"\"\ndef MakeDataset(file_path):\n    dataset = tf.data.TextLineDataset(file_path)\n\n    # map(function, sequence[, sequence, ...]) -> list\n    # 通过定义可以看到，这个函数的第一个参数是一个函数，剩下的参数是一个或多个序列，返回值是一个集合。\n    # function可以理解为是一个一对一或多对一函数，map的作用是以参数序列中的每一个元素调用function函数，返回包含每次function函数返回值的list。\n    # lambda argument_list: expression\n    # 其中lambda是Python预留的关键字,argument_list和expression由用户自定义\n    # argument_list参数列表, expression 为函数表达式\n    # 根据空格将单词编号切分开并放入一个一维向量\n    dataset = dataset.map(lambda string: tf.string_split([string]).values)\n    # 将字符串形式的单词编号转化为整数\n    dataset = dataset.map(lambda string: tf.string_to_number(string, tf.int32))\n    # 统计每个句子的单词数量，并与句子内容一起放入Dataset\n    dataset = dataset.map(lambda x: (x, tf.size(x)))\n    return dataset\n\n\"\"\"\nfunction: 从源语言文件src_path和目标语言文件trg_path中分别读取数据，并进行填充和batching操作\nParameters:\n    src_path-源语言，即被翻译的语言,英语.\n    trg_path-目标语言，翻译之后的语言,汉语.\n    batch_size-batch的大小\nReturns:\n    dataset-　每个句子－对应的长度　组成的TextLineDataset类的数据集\n\"\"\"\ndef MakeSrcTrgDataset(src_path, trg_path, batch_size):\n    # 首先分别读取源语言数据和目标语言数据\n    src_data = MakeDataset(src_path)\n    trg_data = MakeDataset(trg_path)\n    # 通过zip操作将两个Dataset合并为一个Dataset，现在每个Dataset中每一项数据ds由4个张量组成\n    # ds[0][0]是源句子\n    # ds[0][1]是源句子长度\n    # ds[1][0]是目标句子\n    # ds[1][1]是目标句子长度\n    #https://blog.csdn.net/qq_32458499/article/details/78856530这篇博客看一下可以细致了解一下Dataset这个库，以及.map和.zip的用法\n    dataset = tf.data.Dataset.zip((src_data, trg_data))\n\n    # 删除内容为空(只包含)的句子和长度过长的句子\n    def FilterLength(src_tuple, trg_tuple):\n        ((src_input, src_len), (trg_label, trg_len)) = (src_tuple, trg_tuple)\n        # tf.logical_and 相当于集合中的and做法，后面两个都为true最终结果才会为true，否则为false\n        # tf.greater Returns the truth value of (x > y),所以以下所说的是句子长度必须得大于一也就是不能为空的句子\n        # tf.less_equal Returns the truth value of (x <= y),所以所说的是长度要小于最长长度\n        src_len_ok = tf.logical_and(tf.greater(src_len, 1), tf.less_equal(src_len, MAX_LEN))\n        trg_len_ok = tf.logical_and(tf.greater(trg_len, 1), tf.less_equal(trg_len, MAX_LEN))\n        return tf.logical_and(src_len_ok, trg_len_ok) #两个都满足才返回true\n\n    # filter接收一个函数Func并将该函数作用于dataset的每个元素，根据返回值True或False保留或丢弃该元素，True保留该元素，False丢弃该元素\n    # 最后得到的就是去掉空句子和过长的句子的数据集\n    dataset = dataset.filter(FilterLength)\n\n    # 解码器需要两种格式的目标句子：\n    # 1.解码器的输入(trg_input), 形式如同' X Y Z'\n    # 2.解码器的目标输出(trg_label), 形式如同'X Y Z '\n    # 上面从文件中读到的目标句子是'X Y Z '的形式，我们需要从中生成' X Y Z'形式并加入到Dataset\n    # 编码器只有输入,没有输出,而解码器有输入也有输出，输入为＋(除去最后一位eos的label列表)\n    # 例如train.en最后都为2,ｉｄ为２就是eos\n    def MakeTrgInput(src_tuple, trg_tuple):\n        ((src_input, src_len), (trg_label, trg_len)) = (src_tuple, trg_tuple)\n        # tf.concat用法 https://blog.csdn.net/qq_33431368/article/details/79429295\n        trg_input = tf.concat([[SOS_ID], trg_label[:-1]], axis=0)\n        return ((src_input, src_len), (trg_input, trg_label, trg_len))\n    dataset = dataset.map(MakeTrgInput)\n\n    # 随机打乱训练数据\n    dataset = dataset.shuffle(10000)\n\n    # 规定填充后的输出的数据维度\n    padded_shapes = (\n        (tf.TensorShape([None]),    # 源句子是长度未知的向量\n         tf.TensorShape([])),       # 源句子长度是单个数字\n        (tf.TensorShape([None]),    # 目标句子(解码器输入)是长度未知的向量\n         tf.TensorShape([None]),    # 目标句子(解码器目标输出)是长度未知的向量\n         tf.TensorShape([]))        # 目标句子长度(输出)是单个数字\n    )\n    # 调用padded_batch方法进行padding 和　batching操作\n    batched_dataset = dataset.padded_batch(batch_size, padded_shapes)\n\n    return batched_dataset\n\n\"\"\"\nfunction: seq2seq模型\nParameters:\nReturns:\n\"\"\"\nclass NMTModel(object):\n    \"\"\"\n    function: 模型初始化\n    Parameters:\n    Returns:\n\n    \"\"\"\n    def __init__(self):\n\n        # 定义编码器和解码器所使用的LSTM结构\n        self.enc_cell = tf.nn.rnn_cell.MultiRNNCell(\n            [tf.nn.rnn_cell.LSTMCell(HIDDEN_SIZE) for _ in range(NUM_LAYERS)])\n        self.dec_cell = tf.nn.rnn_cell.MultiRNNCell(\n            [tf.nn.rnn_cell.LSTMCell(HIDDEN_SIZE) for _ in range(NUM_LAYERS)])\n        # 为源语言和目标语言分别定义词向量\n        self.src_embedding = tf.get_variable('src_emb', [SRC_VOCAB_SIZE, HIDDEN_SIZE])\n        self.trg_embedding = tf.get_variable('trg_emb', [TRG_VOCAB_SIZE, HIDDEN_SIZE])\n        # 定义softmax层的变量\n        if SHARE_EMB_AND_SOFTMAX:\n            self.softmax_weight = tf.transpose(self.trg_embedding)\n        else:\n            self.softmax_weight = tf.get_variable('weight', [HIDDEN_SIZE, TRG_VOCAB_SIZE])\n        self.softmax_bias = tf.get_variable('softmax_loss', [TRG_VOCAB_SIZE])\n\n    \"\"\"\n    function: 在forward函数中定义模型的前向计算图\n    Parameters:\n    　　MakeSrcTrgDataset函数产生的五种张量如下（全部为张量）\n        src_input: 编码器输入（源数据）\n        src_size : 输入大小\n        trg_input：解码器输入（目标数据）\n        trg_label：解码器输出（目标数据）\n        trg_size：　输出大小\n    Returns:\n    \"\"\"\n    def forward(self, src_input, src_size, trg_input, trg_label, trg_size):\n        batch_size = tf.shape(src_input)[0]\n        # 将输入和输出单词转为词向量（rnn中输入数据都要转换成词向量）\n        # 相当于input中的每个id对应的embedding中的向量转换\n        src_emb = tf.nn.embedding_lookup(self.src_embedding, src_input)\n        trg_emb = tf.nn.embedding_lookup(self.trg_embedding, trg_input)\n        # 在词向量上进行dropout\n        src_emb = tf.nn.dropout(src_emb, KEEP_PROB)\n        trg_emb = tf.nn.dropout(trg_emb, KEEP_PROB)\n        # 使用dynamic_rnn构造编码器\n        # 编码器读取源句子每个位置的词向量，输出最后一步的隐藏状态enc_state\n        # 因为编码器是一个双层LSTM，因此enc_state是一个包含两个LSTMStateTuple类的tuple，\n        # 每个LSTMStateTuple对应编码器中一层的状态\n        # enc_outputs是顶层LSTM在每一步的输出，它的维度是[batch_size, max_time, HIDDEN_SIZE]\n        # seq2seq模型中不需要用到enc_outputs,而attention模型会用到它\n        with tf.variable_scope('encoder'):\n            enc_outputs, enc_state = tf.nn.dynamic_rnn(self.enc_cell, src_emb, src_size, dtype=tf.float32)\n        # 使用dynamic_rnn构造解码器\n        # 解码器读取目标句子每个位置的词向量，输出的dec_outputs为每一步顶层LSTM的输出\n        # dec_outputs的维度是[batch_size, max_time, HIDDEN_SIZE]\n        # initial_state=enc_state表示用编码器的输出来初始化第一步的隐藏状态\n        # 编码器最后编码结束最后的状态为解码器初始化的状态\n        with tf.variable_scope('decoder'):\n            dec_outputs, _ = tf.nn.dynamic_rnn(self.dec_cell, trg_emb, trg_size, initial_state=enc_state)\n        # 计算解码器每一步的log perplexity\n        #　输出重新转换成shape为[,HIDDEN_SIZE]\n        output = tf.reshape(dec_outputs, [-1, HIDDEN_SIZE])\n        #  计算解码器每一步的softmax概率值\n        logits = tf.matmul(output, self.softmax_weight) + self.softmax_bias\n        #  交叉熵损失函数，算loss\n        loss = tf.nn.sparse_softmax_cross_entropy_with_logits(labels=tf.reshape(trg_label, [-1]), logits=logits)\n        # 在计算平均损失时，需要将填充位置的权重设置为0，以避免无效位置的预测干扰模型的训练\n        label_weights = tf.sequence_mask(trg_size, maxlen=tf.shape(trg_label)[1], dtype=tf.float32)\n        label_weights = tf.reshape(label_weights, [-1])\n        cost = tf.reduce_sum(loss * label_weights)\n        cost_per_token = cost / tf.reduce_sum(label_weights)\n        # 定义反向传播操作\n        trainable_variables = tf.trainable_variables()\n        # 控制梯度大小，定义优化方法和训练步骤\n        # 算出每个需要更新的值的梯度，并对其进行控制\n        grads = tf.gradients(cost / tf.to_float(batch_size), trainable_variables)\n        grads, _ = tf.clip_by_global_norm(grads, MAX_GRAD_NORM)\n        # 利用梯度下降优化算法进行优化.学习率为1.0\n        optimizer = tf.train.GradientDescentOptimizer(learning_rate=1.0)\n        # 相当于minimize的第二步，正常来讲所得到的list[grads,vars]由compute_gradients得到，返回的是执行对应变量的更新梯度操作的op\n        train_op = optimizer.apply_gradients(zip(grads, trainable_variables))\n        return cost_per_token, train_op\n\n\"\"\"\nfunction: 使用给定的模型model上训练一个epoch，并返回全局步数，每训练200步便保存一个checkpoint\nParameters:\n    session :  会议\n    cost_op :  计算loss的操作op\n    train_op：　训练的操作op\n    saver：　　保存model的类\n    step：　　　训练步数\nReturns:\n\"\"\"\ndef run_epoch(session, cost_op, train_op, saver, step):\n    # 训练一个epoch\n    # 重复训练步骤直至遍历完Dataset中所有数据\n    while True:\n        try:\n            # 运行train_op并计算cost_op的结果也就是损失值，训练数据在main()函数中以Dataset方式提供\n            cost, _ = session.run([cost_op, train_op])\n            # 步数为１０的倍数进行打印\n            if step % 10 == 0:\n                print('After %d steps, per token cost is %.3f' % (step, cost))\n            # 每200步保存一个checkpoint\n            if step % 200 == 0:\n                saver.save(session, CHECKPOINT_PATH, global_step=step)\n            step += 1\n        except tf.errors.OutOfRangeError:\n            break\n    return step\n\n\"\"\"\nfunction: 主函数\nParameters:\nReturns:\n\"\"\"\ndef main():\n    # 定义初始化函数\n    initializer = tf.random_uniform_initializer(-0.05, 0.05)\n    # 定义训练用的循环神经网络模型\n    with tf.variable_scope('nmt_model', reuse=None, initializer=initializer):\n        train_model = NMTModel()\n    # 定义输入数据\n    data = MakeSrcTrgDataset(SRC_TRAIN_DATA, TRG_TRAIN_DATA, BATCH_SIZE)\n    iterator = data.make_initializable_iterator()\n    (src, src_size), (trg_input, trg_label, trg_size) = iterator.get_next()\n    # 定义前向计算图，输入数据以张量形式提供给forward函数\n    cost_op, train_op = train_model.forward(src, src_size, trg_input, trg_label, trg_size)\n    # 训练模型\n    # 保存模型\n    saver = tf.train.Saver()\n    step = 0\n    with tf.Session() as sess:\n        # 初始化全部变量\n        tf.global_variables_initializer().run()\n        # 进行NUM_EPOCH轮数\n        for i in range(NUM_EPOCH):\n            print('In iteration: %d' % (i + 1))\n            sess.run(iterator.initializer)\n            step = run_epoch(sess, cost_op, train_op, saver, step)\n\n\nif __name__ == '__main__':\n    main()\n\n\n\n\n\n问题如下，不知道怎么解决，谢谢！\n\nTraceback (most recent call last):\n\n  File \"D:\\Anaconda\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\client\\session.py\", line 1334, in _do_call\n\n    return fn(*args)\n\n  File \"D:\\Anaconda\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\client\\session.py\", line 1319, in _run_fn\n\n    options, feed_dict, fetch_list, target_list, run_metadata)\n\n  File \"D:\\Anaconda\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\client\\session.py\", line 1407, in _call_tf_sessionrun\n\n    run_metadata)\n\ntensorflow.python.framework.errors_impl.InvalidArgumentError: StringToNumberOp could not correctly convert string: This\n\n     [[{{node StringToNumber}}]]\n\n     [[{{node IteratorGetNext}}]]\n\n\n\nDuring handling of the above exception, another exception occurred:\n\n\n\nTraceback (most recent call last):\n\n  File \"D:/Python37/untitled1/train_model.py\", line 277, in \n\n    main()\n\n  File \"D:/Python37/untitled1/train_model.py\", line 273, in main\n\n    step = run_epoch(sess, cost_op, train_op, saver, step)\n\n  File \"D:/Python37/untitled1/train_model.py\", line 231, in run_epoch\n\n    cost, _ = session.run([cost_op, train_op])\n\n  File \"D:\\Anaconda\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\client\\session.py\", line 929, in run\n\n    run_metadata_ptr)\n\n  File \"D:\\Anaconda\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\client\\session.py\", line 1152, in _run\n\n    feed_dict_tensor, options, run_metadata)\n\n  File \"D:\\Anaconda\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\client\\session.py\", line 1328, in _do_run\n\n    run_metadata)\n\n  File \"D:\\Anaconda\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\client\\session.py\", line 1348, in _do_call\n\n    raise type(e)(node_def, op, message)\n\ntensorflow.python.framework.errors_impl.InvalidArgumentError: StringToNumberOp could not correctly convert string: This\n\n     [[{{node StringToNumber}}]]\n\n     [[node IteratorGetNext (defined at D:/Python37/untitled1/train_model.py:259) ]]", "Tag": "算法分析"}
{"Answer": "稍微修改了下你的代码，accepted了\r\n\r\n```\r\n #include \r\n#include \r\n#include \r\n#include \r\n#define LL long long\r\nusing namespace std;\r\nLL a[111],b[111111];\r\nint main()\r\n{\r\n    int T;\r\n    cin>>T;\r\n    int i,n;\r\n    while(T--)\r\n    {\r\n        cin>>n;\r\n        int signum=0;\r\n        for(i=1;i<=n;i++)\r\n        {\r\n            scanf(\"%ld\",&a[i]);\r\n            LL tempa=a[i];//保存a[i]被除后的剩余\r\n            int countf=0;//只保留a[i]最小的两个素因子\r\n           for(int j=2;j<=sqrt(a[i]);j++)\r\n            {\r\n                if(tempa%j==0){//第一个或第二个素因子\r\n                \ttempa=tempa/j;//剩余\r\n                    b[++signum]=j;//保存\r\n                    b[++signum]=tempa;//保存和这个因子配对的大于sqrt(a[i])的素因子（例子：26 37，结果应该是26，但是13是不会循环到的）\r\n\r\n                    countf++;\r\n                    if(countf==2){//判断是否是第二个素因子\r\n                    \tbreak;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n                    if(tempa%j==0){//如果上面是第一个素因子，试下剩余是否仍然包含这个素因子，比如 3 8，2是8的第一个，但是剩余4仍然有2\r\n                    \tb[++signum]=j;\r\n                    \t b[++signum]=tempa;\r\n\r\n                    \tbreak;\r\n\t\t\t\t\t}\r\n                } \r\n            }\r\n            if(a[i]!=1&&countf==0){//如果不是1而且没有素因子，就是素数，直接加入\r\n            \tb[++signum]=a[i];\r\n\t\t\t}\r\n\r\n        }\r\n        if(signum<2)\r\n            cout<<-1<<endl;\r\n        else{\r\n            sort(b+1,b+signum+1);\r\n            long long desnum=b[1]*b[2];\r\n            cout << desnum <<endl;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n```", "Konwledge_Point": "算法与数字", "Question": "刷ACM的小伙伴快进HDU 5428The Factor(*)\n链接在这\n\nProblem Description\n\n\n\nThere is a sequence of n positive integers. Fancycoder is addicted to learn their product, but this product may be extremely huge! However, it is lucky that FancyCoder only needs to find out one factor of this huge product: the smallest factor that contains more than 2 factors（including itself; i.e. 4 has 3 factors so that it is a qualified factor）. You need to find it out and print it. As we know, there may be none of such factors; in this occasion, please print -1 instead. \n\n\n\nInput\n\n\n\nThe first line contains one integer T (1≤T≤15), which represents the number of testcases. \n\n\n\nFor each testcase, there are two lines:\n\n\n\n\n\nThe first line contains one integer denoting the value of n (1≤n≤100).\n\n\nThe second line contains n integers a1,…,an (1≤a1,…,an≤2×109), which denote these n positive integers. \n\n\nOutput\n\n\n\nPrint T answers in T lines.\n\n\n\nSample Input\n\n\n\n2\n\n3\n\n1 2 3\n\n5\n\n6 6 6 6 6\n\n\n\nSample Output\n\n\n\n6\n\n4\n\n\n\nSource\n\n\n\nBestCoder Round #54 (div.2)  \n\n\n\n 有一个数列，FancyCoder沉迷于研究这个数列的乘积相关问题，但是它们的乘积往往非常大。幸运的是，FancyCoder只需要找到这个巨大乘积的最小的满足如下规则的因子：这个因子包含大于两个因子（包括它本身；比如，4有3个因子，因此它是满足这个要求的一个数）。你需要找到这个数字并输出它。但是我们知道，对于某些数可能没有这样的因子；在这样的情况下，请输出-1.\n\n\n\n\n我的代码如下：\n\n\n\n#include \n#include \n#include \n#include \n#define LL long long\nusing namespace std;\nLL a[111],b[111];\nint main()\n{\n    int T;\n    cin>>T;\n    int i,n;\n    while(T--)\n    {\n        cin>>n;\n        int signum=0;\n        for(i=1;i<=n;i++)\n        {\n            scanf(\"%ld\",&a[i]);\n           for(int j=2;j<=sqrt(a[i]);j++)\n            {\n                if(a[i]%j==0){\n                    b[++signum]=j;\n                }break;\n            }\n            if(a[i]!=1&&a[i]%2!=0||a[i]==2){\n                b[++signum]=a[i];\n            }\n\n        }\n        if(signum<2)\n            cout<<-1<<endl;\n        else{\n            sort(b+1,b+signum+1);\n            long long desnum=b[1]*b[2];\n            cout << desnum <<endl;\n        }\n    }\n    return 0;\n}\n\n\n\n\n\n结果一直显示Wrong Answer，研究了一天了，求大神解答", "Tag": "算法分析"}
{"Answer": "\n\n```c++\n#include<iostream>\nusing namespace std;\nbool flag=1;\nint n,m,s,a[105][105],book[105][105],fx[10]={0,-1,-1,-1,0,0,1,1,1},fy[10]={-1,0,1,-1,1,-1,0,1};\nvoid dfs(int x,int y)\n{\n    for(int i=1;i<=8;i++)\n    {\n        int nx=x+fx[i],ny=y+fy[i];\n        if(nx>=1&&nx<=n&&ny>=1&&ny<=m)\n        {\n            if(a[nx][ny]<=a[x][y]&&book[nx][ny]==0)\n            {\n                book[nx][ny]=1;\n                dfs(nx,ny);\n            }\n        }\n \n    }\n}\nint main()\n{\n    cin>>n>>m;\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=m;j++)\n        {\n            cin>>a[i][j];\n        }\n    }\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=m;j++)\n        {\n            if(book[i][j]==0)\n            {\n                book[i][j]=1;\n                flag=1;\n                dfs(i,j);\n                if(flag==1)\n                {\n                    s++;\n                }\n            }\n        }\n    }\n    cout<<s;\n}\n \n\n\n```", "Konwledge_Point": "算法与数字", "Question": "请帮我看看下面代码哪里错误，详细指明！\n题目描述\n农夫John的农场里有很多小山丘，他想要在那里布置一些保镖去保卫他的那些相当值钱的奶牛们。\n他想知道如果在一座小山丘上布置一名保镖的话，他总共需要招聘多少名保镖。他现在有一个用数字矩阵来表示地形的地图。这个矩阵有N行（1 < N < = 100)和M列( 1 < M < = 70) 。矩阵中的每个元素都有一个值H_ij(0 < = H_ij < =10,000)来表示该地区的海拔高度。\n小山丘的定义是：若地图中一个元素所邻接的所有元素都比这个元素高度要小或等于（或它邻接的是地图的边界），则该元素和其周围所有按照这样顺序排列的元素的集合称为一个小山丘（本题某个非边界点跟它相邻的有8个点：上、下、左、右、左上、右上、左下、右下）。\n\n\n输入\n第1行：两个由空格隔开的整数N和M；\n第2行到第N+1行：\n第I+l行描述了地图上的第I行，有M个由空格隔开的整数：H_ij。\n\n\n输出\n一个整数，表示小山丘的个数。\n\n\n样例输入\n8 7\n4 3 2 2 1 0 1\n3 3 3 2 1 0 1\n2 2 2 2 1 0 0\n2 1 1 1 1 0 0\n1 1 0 0 0 1 0\n0 0 0 1 1 1 0\n0 1 2 2 1 1 0\n0 1 1 1 2 1 0\n\n\n样例输出\n3\n\n\n我的代码如下：\n\n\n#include\nusing namespace std;\nbool flag=1;\nint n,m,s,a\n[105]\n[105]\n,book\n[105]\n[105]\n,fx\n[10]\n={0,-1,-1,-1,0,0,1,1,1},fy\n[10]\n={-1,0,1,-1,1,-1,0,1};\nvoid dfs(int x,int y)\n{\n    for(int i=1;i<=8;i++)\n    {\n        int nx=x+fx\n[i]\n,ny=y+fy\n[i]\n;\n        if(nx>=1&&nx<=n&&ny>=1&&ny<=m)\n        {\n            if(a\n[nx]\n[ny]\n<=a\n[x]\n[y]\n&&book\n[nx]\n[ny]\n==0)\n            {\n                book\n[nx]\n[ny]\n=1;\n                dfs(nx,ny);\n            }\n        }\n\n    }\n}\nint main()\n{\n    cin>>n>>m;\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=m;j++)\n        {\n            cin>>a\n[i]\n[j]\n;\n        }\n    }\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=m;j++)\n        {\n            if(book\n[i]\n[j]\n==0)\n            {\n                book\n[i]\n[j]\n=1;\n                flag=1;\n                dfs(i,j);\n                if(flag==1)\n                {\n                    s++;\n                }\n            }\n        }\n    }\n    cout<<s;\n}\n\n\n\n\n盼详细解释，谢谢！", "Tag": "算法分析"}
{"Answer": "题目要求“如果解不唯一，则输出按字母序最小的解”，所以最后输出判断时，C那行应该在J那行前面", "Konwledge_Point": "算法与数字", "Question": "pat乙1018 锤子剪刀布的问题，一个测试点怎么也过不了\n现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。\n\n\n输入格式：\n输入第 1 行给出正整数 N（≤10\n5\n ），即双方交锋的次数。随后 N 行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C 代表“锤子”、J 代表“剪刀”、B 代表“布”，第 1 个字母代表甲方，第 2 个代表乙方，中间有 1 个空格。\n\n\n输出格式：\n输出第 1、2 行分别给出甲、乙的胜、平、负次数，数字间以 1 个空格分隔。第 3 行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有 1 个空格。如果解不唯一，则输出按字母序最小的解。\n\n\n输入样例：\n10\nC J\nJ B\nC B\nB B\nB C\nC C\nC B\nJ B\nB C\nJ J\n输出样例：\n5 3 2\n2 3 5\nB B\n\n\n\n\n#include\n\nusing namespace std;\n\nint maxNum(int a, int b, int c){\n    int \nmaxnum\n = \n0\n;\n    \nif\n (a > maxnum)\n        \nmaxnum\n = a;\n      \nif\n (b > maxnum)\n        \nmaxnum\n = b;\n      \nif\n(c > maxnum)\n        \nmaxnum\n = c;\n     return maxnum;\n}\n \nint main(){\n    int N;\n    cin >> N;\n    char jia, yi;\n    int \njwin\n = \n0\n;\n    int \nywin\n = \n0\n;\n    int \nnowin\n = \n0\n;\n    int jiac, jiaj, jiab, yic, yib, yij;\n    \njiaj\n = \njiac\n = \njiab\n = \nyij\n = \nyib\n = \nyic\n = \n0\n;\n    \n    while(N--){\n        cin >> jia >> yi;\n        \nif\n(\njia\n == 'J'){\n            \nif\n(\nyi\n == 'J') ++nowin;\n            \nif\n(\nyi\n == 'C') ++ywin, ++yic;\n            \nif\n(\nyi\n == 'B') ++jwin, ++jiaj;\n        }\n        \nelse\n \nif\n(\njia\n == 'C'){\n            \nif\n(\nyi\n == 'C') ++nowin;\n            \nif\n(\nyi\n == 'B') ++ywin, ++yib;\n            \nif\n(\nyi\n == 'J') ++jwin, ++jiac;\n        }\n        \nelse\n \nif\n(\njia\n == 'B'){\n            \nif\n(\nyi\n == 'B') ++nowin;\n            \nif\n(\nyi\n == 'J') ++ywin, ++yij;\n            \nif\n(\nyi\n == 'C') ++jwin, ++jiab;\n        }\n    }\n        \n    cout << jwin << \n\" \"\n << nowin << \n\" \"\n << ywin << endl;\n    cout << ywin << \n\" \"\n << nowin << \n\" \"\n << jwin << endl;\n    \n    int \nans1\n = maxNum(jiab, jiaj, jiac);\n    int \nans2\n = maxNum(yib, yij, yic);\n    \nif\n(\nans1\n == jiab) cout << \n\"B\"\n;\n    \nelse\n \nif\n(\nans1\n == jiaj) cout << \n\"J\"\n;\n    \nelse\n \nif\n(\nans1\n == jiac) cout << \n\"C\"\n;\n        \n    cout << \n\" \"\n;\n    \n    \nif\n(\nans2\n == yib) cout << \n\"B\"\n;\n    \nelse\n \nif\n(\nans2\n == yij) cout << \n\"J\"\n;\n    \nelse\n \nif\n(\nans2\n == yic) cout << \n\"C\"\n;\n    \n    return \n0\n;\n}\n\n\n\n\n\n  代码差两分满分，但是实在不知道怎么改，希望大家帮助下，谢谢！", "Tag": "算法分析"}
{"Answer": "\n#include <stdio.h>\n#include <string.h>\nchar chNumber[10][10] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\nint fnStrToNum(char chNum[])\n{\nint i = 0;\nfor (i=0; i<10; i++)\n{\nif (0 == strcmp(chNum, chNumber[i]))\n{\nreturn i;\n}\n}\nreturn 0;\n}\nint fnStrToInt(char chNum[][10], int n)\n{\nint i = 0;\nint c = 0;\nwhile (n--)\n{\nc *= 10;\nc += fnStrToNum(chNum[i++]);\n}\nreturn c;\n}\nint fnIntToStr(char chNum[][10], int nNum)\n{\nint r = 0;\nchar chT[10];\nif (nNum<10)\n{\nstrcpy(chNum[0], chNumber[nNum]);\n}\nelse\n{\nr = fnIntToStr(&chT, nNum/10);\nstrcpy(chNum[r], chT);\n}\nreturn r+1;\n}\nint main()\n{\nint i = 0;\nint j = 0;\nint k = 0;\nchar chA[2][10] = {0}, chB[2][10] = {0};\nint iCount = 0; \nint iOut[1000]; \nwhile (1)\n{\nscanf(\"%s%s\", chA[0], chA[1]);\nif (chA[1][0] == '+')\n{\nscanf(\"%s%s\", chB[0], chB[1]);\nif (chB[1][0] == '=')\n{\niOut[iCount] = fnStrToNum(chA[0]) + fnStrToNum(chB[0]);\n}\nelse\n{\niOut[iCount] = fnStrToNum(chA[0]) + fnStrToInt(chB, 2);\n}\n}\nelse\n{\nscanf(\"%s%s\", chB[0], chB[1]);\nif (chB[1][0] == '=')\n{\niOut[iCount] = fnStrToInt(chA, 2) + fnStrToNum(chB[0]);\n}\nelse\n{\niOut[iCount] = fnStrToInt(chA, 2) + fnStrToInt(chB, 2);\n}\n}\nif (!iOut[iCount])\n{\nbreak;\n}\niCount++;\n}\nchar chC[3][10];\nfor (i=0; i<iCount; i++)\n{\nk = fnIntToStr(chC, iOut[i]);\nfor (j=0; j<k; j++)\n{\nprintf(\"%s \", chC[j]);\n}\nprintf(\"\\n\");\n}\nreturn 0;\n}\n\n经过测试，感谢采纳！", "Konwledge_Point": "算法与数字", "Question": "初学者不太看得懂程序\n 用英文单词模拟数学计算\n\n\n\n读入两个小于100的正整数A和B，计算A+B。需要注意的是：A和B的每一位数字由对应的英文单词给出。\n具体的输入输出格式规定如下：\n输入格式：测试输入包含若干测试用例，每个测试用例占一行，格式为“A+B=\"，相邻两字符串有一个空格间隔。当A和B同时为zero时输入结束，相应的结果不要输出。\n输出格式：对每个测试用例输出1行，即A+B的值。\n输入样例：\none+ two =\nthree four +five six=\nzero seven +eight nine =\nzero + zero =\n输出样例：\nthree\nnine zero\nnine six\n\n\n\n\n#include \n#include \n#include \n\n\n#define MAXSIZE (200)\n\n\nchar *array[] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\",\n    \"six\", \"seven\", \"eight\", \"nine\"};\n\n\nvoid procstr(char *string, int *left, int *right)\n{\n    char words[50][MAXSIZE];\n    char c;\n      int i, num = 0, word = 0, j;\n\n\n/*\n *这部分的功能就是将字符串分解\n * 输入为 one + two =       \n * 分解为:        \n * \nwords\n[\n0\n] = \n\"one\"\n\n * \nwords\n[\n1\n] = \n\"+\"\n\n * \nwords\n[\n2\n] = \n\"two\"\n\n * \nwords\n[\n3\n] = \n\"=\"\n\n */\n\nfor\n(i = \n0\n; (c = \nstring\n[i]) != '\\\n0\n'; i++) {\n    \nif\n (c == ' ') {\n        \nif\n (\nword\n) {\n            strncpy(\nwords\n[num\n-1\n], &\nstring\n[i-\nword\n], \nword\n);\n            \nwords\n[num\n-1\n][\nword\n] = '\\\n0\n';\n        }\n        \nword\n = \n0\n;\n    } \nelse\n \nif\n (\nword\n == \n0\n) {\n        \nword\n++;\n        num++;\n    } \nelse\n {\n        \nword\n++;\n    }\n}    \n\n\nif\n (\nword\n) {\n    strncpy(\nwords\n[num\n-1\n], &\nstring\n[i-\nword\n], \nword\n);\n    \nwords\n[num\n-1\n][\nword\n] = '\\\n0\n';\n}\n/*****************************************/    \n\n/*\n * 这里的功能就是把\n * + 左边的转换为整数放入 left 里面\n * + 右边的转换为整数放入 right 里面\n */\n\n*left = \n0\n , *right = \n0\n;\nint leftok = \n0\n;\n\nfor\n(i = \n0\n; i=\n0\n; i--) {\n    \nif\n (i != \n0\n) {\n        \nprintf\n(\n\"%s \"\n, array[stack[i]]);\n    } \nelse\n {\n        \nprintf\n(\n\"%s\\n\"\n, array[stack[i]]);\n    }\n}\n\n\n\n}\n\n\nint main()\n{\n    char str[MAXSIZE] = {'\\0'};\n    int left = 0, right = 0;int sum;\n    while(1) {\n        fgets(str, MAXSIZE - 1, stdin);\n        procstr(str, &left, &right);    \n\n\n    \nif\n (\nleft\n == \n0\n && \nright\n == \n0\n) {\n        break;\n    } \nelse\n {\n    \n        showRes(\nleft\n + \nright\n);\n    } \n}\nsystem(\n\"pause\"\n);\n\nreturn\n \n0\n;\n\n\n\n}", "Tag": "算法分析"}
{"Answer": " \n#include<stdio.h>\n#include <string.h>\nint main(void)\n{\n    /*********Begin*********/\n    int n,number,i,k,j,p;\n    number=0,p=0;\n    \n    \n    scanf(\"%d\",&n);/*输入代表测试实例个数的n*/\n    char z[100][200]={0};/*定义100个字符数为200的字符串数组，防止输入字符串过长溢出*/\n    \n    for(j=0;j<n;j++)/*这几行代码的作用是输入测试的字符，当输完一串之后，输出换行符换行，继续输入下一串，直到n行字符串全部输入完成*/    \n    {\n        scanf(\"%s\",z[j]);        \n    }\n    \n    /*for(j=0;j<n;j++)//这几行代码的作用是输入测试的字符，当输完一串之后，输出换行符换行，继续输入下一串，直到n行字符串全部输入完成    \n    {\n        //scanf(\"%s\",z[i]);\n        printf(\"%s\\n\",z[j]);        \n    }*/\n    \n    for(i=0;i<n;i++) //这个for语句的作用是把n行字符串全部执行完\n    {\n        number=0,k=0;\n        //p=i;//这个语句的作用是当执行完某一行字符串时，可以在数组中接着上一行的数组地址往下执行，而不是重新从数组z[0]开始执行\n        while(z[i][k])//如果为换行符，则跳出此循环\n        {\n            if((z[i][k]>='0'&&z[i][k]<='9'))\n                number=number+1;    \n            k++;\n        }\n        printf(\"%d\\n\",number);\n   }\n    /*********End**********/\n    return 0;\n}\n \n\n", "Konwledge_Point": "算法与数字", "Question": "能不能帮我看看我的代码的问题，不要新代码，我只想我这个能运行。\n这个题目我之前已经问过一次了，还是没有搞懂，之前有个回复说我的程序里是定义了一个字符串，而不是一个字符数组，字符串和字符数组有啥区别吗？按照昨天回复我的回答，我今天把我的代码中定义的z数组全部初始化为了0，把输入给数组中的scanf中的z前面的取地址符也去掉了，在我下面if的比较中在数字字符的两边也加上了''，昨天还是啥也没输出出来，今天已经变成了报错了。\n\n\n我的思路其实很简单，就是向电脑中输入n行字符串，我想把这n行字符串存到数组中，然后这n行字符串肯定是在数组中按照一个字符一位存储的，所以第二串字符串肯定就是在第一串字符串的基础上加上一个'\\0'，然后接着往数组的下一位存储啊，所以我就遍历这个数组，但是不知道为啥啥也输出不出来。还有我最后一张图片里的回复，他说只用遍历一遍字符串，他写的代码的意思是，输入一行字符串后就输出结果，然后再输出一行字符串吗？\n\n\n烦死我了，帮帮我吧😭一个字符串数组快两天了才做了三个。\n\n\n\n \n\n#include\n\nint main(void)\n{\n    \n/*********Begin*********/\n\n    int n,number,i,k,j,p;\n     number=\n0\n,p=\n0\n;\n    char z[\n1000\n]=｛\n0\n｝;     \n/* 定义一个字符数为1000的数组，防止输入字符串过长溢出*/\n\n \n    scanf(\n\"%d\"\n,&n);   \n/*输入代表测试实例个数的n*/\n\n    \n    \nfor\n(j=\n0\n;j=\n'0 '\n&& z[i]<=\n'9'\n))\n        {\n            number=number+\n1\n;\n        }\n    }\n    \nelse\n \n     p=p+\n1\n; \ncontinue\n;\n    }\n    printf(\n\"%d\\n\"\n,number);\n    }\n \n    \n/*********End**********/\n\n    return \n0\n;\n}\n\n\n\n\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "如果你的布局是这样子你的读取存在问题，回车会读进去，还有加和时，会溢出，比如 a[-1][1]就明显溢出了。\n\n#include<stdio.h>\n//#include<stdlib.h>\nint a[105][105] = {0}; //一张地图，有雷为一，无雷为零\nint main() {\n    //memset(a, 0, sizeof(a));//地图最开始清空\n    //int b[105][105];//一张地图，有雷为一，无雷为零\n    int n, m;\n    char tmp[105][105] = {0};\n    scanf(\"%d%d\", &m, &n);\n    setbuf(stdin, NULL);\n    for (int i = 0; i < m; i++) { //读入地图\n        for (int j = 0; j < n; j++) {\n            do {\n                //TODO\n                scanf(\"%c\", &tmp[i][j]);\n            } while ( tmp[i][j] != '*' && tmp[i][j] != '?'  );\n\n            if (tmp[i][j] == '*') {\n                a[i][j] = 1;//如果是地雷就将这个点设为一\n            }\n        }\n    }\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (a[i][j] == 1) printf(\"*\"); //如果是地雷不用输出数字\n            else {\n                int up = i - 1 >= 0 ? i - 1 : -1;\n                int down = i + 1 < n ? i + 1 : -1;\n                int lift = j - 1 >= 0 ? j - 1 : -1;\n                int right = j + 1 < n ? j + 1 : -1;\n                int num  = 0;\n                if ( up != -1 ) {\n                    if ( lift != -1 ) {\n                        num += a[up][lift];\n                    }\n                    num += a[up][j];\n                    if ( right != -1 ) {\n                        num += a[up][right];\n                    }\n                }\n                if (down != -1) {\n                    if ( lift != -1 ) {\n                        num += a[down][lift];\n                    }\n                    num += a[down][j];\n                    if ( right != -1 ) {\n                        num += a[down][right];\n                    }\n                }\n                if( lift != -1 ){\n                    num+=a[i][lift];\n                }\n                if( right != -1 ){\n                    num+=a[i][right];\n                }\n                printf(\"%d\", num);\n                //将旁边的雷加起来输出 (旁边的雷直接变成1）\n            }\n        }\n        printf(\"\\n\");\n    }\n    return 0;//愉快的结束了主程序\n}\n\n", "Konwledge_Point": "算法与数字", "Question": "（扫雷）我用测试样例做对了，为什么评测过不了\n问题遇到的现象和发生背景\n\n\n\n\n用代码块功能插入代码，请勿粘贴截图\n\n\n#include\nint main()\n{\n    int m, n;\n    char a\n[100]\n[100]\n;\n    int count\n[100]\n[100]\n;\n    scanf(\n\"%d%d\"\n, &m, &n);\n    setbuf(stdin, NULL);\n    /*fflush(stdin);*/\n    for (int i =1; i <=m; i++)\n    {\n        for (int j = 1; j <= n; j++)\n        {\n            scanf(\n\"%c\"\n, &a\n[i]\n[j]\n);\n        }\n        setbuf(stdin, NULL);\n        /*fflush(stdin);*/\n    }\n    for (int i =1; i <= m; i++)\n    {\n        for (int j =1; j <= n; j++)\n        {\n            if (i > 0) {\n                if (a\n[i - 1]\n[j]\n == '*')\n                    count\n[i]\n[j]\n++;\n                if (a\n[i - 1]\n[j - 1]\n == '*')\n                    count\n[i]\n[j]\n++;\n                if (a\n[i - 1]\n[j + 1]\n == '*')\n                    count\n[i]\n[j]\n++;\n                if (a\n[i]\n[j - 1]\n == '*')\n                    count\n[i]\n[j]\n++;\n                if (a\n[i]\n[j + 1]\n == '*')\n                    count\n[i]\n[j]\n++;\n                if (a\n[i + 1]\n[j]\n == '*')\n                    count\n[i]\n[j]\n++;\n                if (a\n[i + 1]\n[j - 1]\n == '*')\n                    count\n[i]\n[j]\n++;\n                if (a\n[i + 1]\n[j + 1]\n == '*')\n                    count\n[i]\n[j]\n++;\n            }\n        }\n    }\n    for (int i = 1; i <= m; i++)\n    {\n        for (int j = 1; j <= n; j++)\n        {\n            if (a\n[i]\n[j]\n == '?')\n                a\n[i]\n[j]\n = '0' + count\n[i]\n[j]\n;\n        }\n    }\n    for (int i = 1; i <= m; i++)\n    {\n        for (int j = 1; j <= n; j++)\n        {\n            printf(\n\"%c\"\n, a\n[i]\n[j]\n);\n        }\n        printf(\n\"\\n\"\n);\n    }\n    return 0;\n}\n\n\n```#include\n//#include\nint a\n[105]\n[105]\n={0};//一张地图，有雷为一，无雷为零 \nint main()\n{\n    //memset(a, 0, sizeof(a));//地图最开始清空 \n    //int b\n[105]\n[105]\n;//一张地图，有雷为一，无雷为零 \n    int n, m;\n    char tmp\n[105]\n[105]\n;\n    scanf(\n\"%d%d\"\n, &m, &n);\n    /*setbuf(stdin, NULL);*/\n    for (int i = 1; i <=m; i++)//读入地图\n    {\n        for (int j = 1; j <=n; j++)\n        {\n            scanf(\n\"%c\"\n,&tmp\n[i]\n[j]\n);\n            if (tmp\n[i]\n[j]\n == '*') \n                a\n[i]\n[j]\n = 1;//如果是地雷就将这个点设为一 \n        }\n    }\n    for (int i = 1; i <= m; i++)\n    {\n        for (int j = 1; j <= n; j++)\n        {\n            if (a\n[i]\n[j]\n == 1) printf(\n\"*\"\n); //如果是地雷不用输出数字 \n            else\n            {\n                printf(\n\"%d\"\n, a\n[i + 1]\n[j + 1]\n + a\n[i + 1]\n[j - 1]\n + a\n[i + 1]\n[j]\n + a\n[i]\n[j + 1]\n + a\n[i]\n[j - 1]\n + a\n[i - 1]\n[j + 1]\n + a\n[i - 1]\n[j]\n + a\n[i - 1]\n[j - 1]\n);\n                //将旁边的雷加起来输出 (旁边的雷直接变成1）\n            }\n        }\n        printf(\n\"\\n\"\n);\n    }\n    return 0;//愉快的结束了主程序 \n}\n我换了一种解法还是过不了\n\n```c\n\n\n\n\n\n\n\n运行结果及报错内容\n\n\n但是我自己输入时都对啊\n\n", "Tag": "算法分析"}
{"Answer": "修改字符集设置，使用多字节就可以了", "Konwledge_Point": "算法与数字", "Question": "哈希表的拉链法创建及操作\n用拉链法创建了一个哈希表。从文件中读取内容到哈希表中，duruhash(H)函数报错，应该是H参数错了，但我在inserthash(H)函数中，是成功运行了的，那H应该是没错的\n有没有兄弟能帮帮我\n\n\n显示错误： [Error] cannot convert 'Hashnode**' to 'hashbit {aka Hashnode*}' for argument '1' to 'void duruhash(hashbit)'\n\n\n#include\n\n\n#include\n\nusing \nnamespace\n \nstd\n;\n\n#define MAXSIZE 20 \n\n\n#define n 19\n\ntypedef struct aa\n//将哈希表节点的数据域变为复合型，以便储存密码和金额 \n\n{\n    \nint\n zhanghao;\n    \nint\n mima;\n    \nint\n money;\n}bb; \ntypedef struct Hashnode\n//哈希表的储存结构 \n\n{\n    bb data;\n    struct Hashnode *prior;\n    struct Hashnode *next;\n}hashnode,*hashbit;\n\nvoid\n inithash(hashbit H[])\n//初始化哈希表 \n\n{\n    \nint\n i;\n    \nfor\n(i=\n0\n;idata.zhanghao=\n0\n;\n        H[i]->data.mima=\n0\n;\n        H[i]->data.money=\n0\n;\n        H[i]->prior=\nNULL\n; \n        H[i]->next=\nNULL\n;\n    }\n}\n\nvoid\n readtext(\nint\n ab[]) \n//从文件中分别读取读取储户的账号，密码，储存金额信息，存入数组ab中\n\n{\n    \nint\n i=\n0\n;\n    fstream in(\n\"haxi.txt\"\n); \n    cin.rdbuf(in.rdbuf()); \n//将输入信息从控制台转向txt文件\n\n    \nfor\n(i=\n0\n;i<\n100\n;i++){\n           cin>>ab[i]; \n//输入到数组中的数据是从txt文件中读取到的，不用再在控制台输入\n\n     }\n    \n//文件信息读入完成，成功存入ab[]数组中 \n\n    \n//将ab[]数组中的信息存入哈希表中 \n\n}\n\nvoid\n duruhash(hashbit H)\n{\n    \nint\n x,i;\n    \nint\n ab[\n100\n]={\n1\n,\n2\n,\n3\n,\n4\n,\n5\n,\n6\n,\n7\n,\n8\n,\n9\n,\n10\n,\n11\n,\n12\n,\n13\n,\n14\n,\n15\n,\n16\n,\n17\n,\n18\n,\n19\n,\n20\n,\n21\n,\n22\n,\n23\n,\n24\n,\n25\n,\n26\n,\n27\n,\n28\n,\n29\n,\n30\n};\n    \nwhile\n(ab[i]!=\n'\\0'\n)\n    {\n        hashbit p=\nnew\n hashnode;\n        hashbit q=\nnew\n hashnode;\n        x=ab[i]%n;\n//散列函数\n\n        p->next=\nNULL\n;\n        p->data.zhanghao=ab[i];\n        p->data.mima=ab[i+\n1\n];\n        p->data.money=ab[i+\n2\n];\n        q=&H[x];\n        \nwhile\n(q->next!=\nNULL\n)\n        {\n            q=q->next;\n        }\n        q->next=p;\n// \n\n        p->prior=q;\n//指向前驱节点 \n\n        i=i+\n3\n; \n    }\n}\n\nvoid\n inputhash(hashbit H)\n{\n    \nint\n ab[\n100\n]={\n1\n,\n2\n,\n3\n,\n4\n,\n5\n,\n6\n,\n7\n,\n8\n,\n9\n,\n10\n,\n11\n,\n12\n,\n13\n,\n14\n,\n15\n,\n16\n,\n17\n,\n18\n,\n19\n,\n20\n,\n21\n,\n22\n,\n23\n,\n24\n,\n25\n,\n26\n,\n27\n,\n28\n,\n29\n,\n30\n};\n    hashbit p=\nnew\n hashnode;\n    hashbit q=\nnew\n hashnode;\n    \nint\n i=\n30\n;\n    \nint\n x;\n    x=ab[i]%n;\n//散列函数\n\n    \nfor\n(i=\n0\n;i<\n30\n;i++)\n    {\n        p->next=\nNULL\n;\n        p->data.zhanghao=ab[i];\n        p->data.mima=ab[i+\n1\n];\n        p->data.money=ab[i+\n2\n];\n        q=&H[x];\n        \nwhile\n(q!=\nNULL\n)\n        {\n            q=q->next;\n        }\n        q->next=p;\n// \n\n        p->prior=q;\n//指向前驱节点 \n\n        i=i+\n3\n; \n    }\n}\n\nvoid\n inserthash(hashbit H[])\n//开户 \n\n{\n    \nint\n a,b,c;\n    cout<<\n\"请设置您的账户（两位数字）：\"\n;\n    cin>>a;\n    cout<<\n\"请设置您的账户密码（不超过四位数字）：\"\n;\n    cin>>b;\n    cout<<\n\"请输入您的存款金额：\"\n;\n    cin>>c;\n    \nint\n i=a%n;\n    hashbit p=\nnew\n hashnode;\n    hashbit q=\nnew\n hashnode;\n    p->next=\nNULL\n;\n    p->data.zhanghao=a;\n    p->data.mima=b;\n    p->data.money=c;\n    q=H[i];\n    \nwhile\n(q->next!=\nNULL\n)\n    {\n        q=q->next;\n    }\n    q->next=p;\n    p->prior=q;\n    cout<<\n\"开户成功！\"\n<>a>>b;\n    \nint\n i=a%n;\n    \nint\n j=\n0\n;\n    hashbit p=\nnew\n hashnode;\n    p=H[i];\n    \nwhile\n(p->next!=\nNULL\n)\n    {\n        p=p->next;\n        \nif\n(p->data.zhanghao==a)\n//存在此账户 \n\n        {\n            \nif\n(p->data.mima==b)\n//此账户密码错正确 \n\n            {\n                j=j+\n1\n;\n                \nbreak\n; \n            }\n            \nelse\n//此账户密码错误 \n\n            {\n                j=\n3\n;\n                \nbreak\n; \n            } \n        }    \n    }\n    \nif\n(j==\n0\n)\n    {\n        cout<<\n\"不存在此账户！\"\n<data.money<>a>>b;\n    hashbit p=\nnew\n hashnode;\n    p=searchhash(H);\n    \nif\n(p!=\nNULL\n)\n    {\n        hashbit q=\nnew\n hashnode;\n        hashbit s=\nnew\n hashnode;\n        q=p->prior;\n        s=p->next;\n        q->next=s;\n        s->prior=q;\n    }\n    cout<<\n\"您的账户已成功注销！\"\n<>a>>b>>c;\n    \nint\n i=a%n;\n    \nint\n j=\n0\n;\n    p=H[i];\n    \nwhile\n(p->next!=\nNULL\n)\n    {\n        p=p->next;\n        \nif\n(p->data.zhanghao==a)\n//存在此账户 \n\n        {\n            \nif\n(p->data.mima==b)\n//此账户密码错正确 \n\n            {\n                j=j+\n1\n;\n                \nbreak\n; \n            }\n            \nelse\n//此账户密码错误 \n\n            {\n                j=\n3\n;\n                \nbreak\n; \n            } \n        }    \n    }\n    \nif\n(j==\n0\n)\n    {\n        cout<<\n\"不存在此账户！\"\n<data.money+=c;\n        cout<<\n\"存款成功！\"\n;\n        cout<<\n\"您的账户余额：\"\n<data.money<>a>>b>>c;\n    \nint\n i=a%n;\n    \nint\n j=\n0\n;\n    p=H[i];\n    \nwhile\n(p->next!=\nNULL\n)\n    {\n        p=p->next;\n        \nif\n(p->data.zhanghao==a)\n//存在此账户 \n\n        {\n            \nif\n(p->data.mima==b)\n//此账户密码错正确 \n\n            {\n                j=j+\n1\n;\n                \nbreak\n; \n            }\n            \nelse\n//此账户密码错误 \n\n            {\n                j=\n3\n;\n                \nbreak\n; \n            } \n        }    \n    }\n    \nif\n(j==\n0\n)\n    {\n        cout<<\n\"不存在此账户！\"\n<data.money>=c)\n        {\n            cout<<\n\"取款成功！\"\n;\n            cout<<\n\"您的账户余额：\"\n<data.money<data.money<data.zhanghao <<\n\"余额：\"\n<data.money<next;\n        }\n    }\n}\n\nvoid\n jiluhash(hashbit H[])\n//查询交易记录\n\n{\n    \nint\n a,b;\n    cout<<\n\"请输入您的账户和密码(用空格隔开):\"\n;\n    cin>>a>>b; \n    \n}\n\nint\n main() \n{\n    \nint\n a,b,c;\n    \nint\n m;\n    hashbit H[n];\n    inithash(H);\n\n//    readtext(ab);\n\n    duruhash(H);\n    cout<<\n\"本系统服务有：\"\n<>m;\n    \nwhile\n(m!=\n'\\0'\n)\n    {\n        hashbit p=\nnew\n hashnode;\n        \nswitch\n(m) \n        {\n            \ncase\n \n1\n:{\n                inserthash(H);\n                \nbreak\n;\n            }\n            \ncase\n \n2\n:{\n                addhash(H);\n                \nbreak\n;\n            }\n            \ncase\n \n3\n:{\n                minushash(H);\n                \nbreak\n;\n            }\n            \ncase\n \n4\n:{\n                p=searchhash(H);\n                \nbreak\n;\n            }\n            \ncase\n \n5\n:{\n                detehash(H);\n                \nbreak\n;\n            }    \n            \ncase\n \n6\n:{\n                shuchuhash(H);\n                \nbreak\n;\n            }    \n            \ncase\n \n7\n:{\n                cout<<\n\"请输入您的账户和密码(用空格隔开):\"\n;\n                cin>>a>>b; \n                jiluhash(H);\n                \nbreak\n;\n            }\n            \ndefault\n:{\n                cout<<\n\"错误！请重新输入！\"\n<>m;\n    }\n    \nreturn\n \n0\n;\n}\n\n\n\n​\n用拉链法创建了一个哈希表。从文件中读取内容到哈希表中，出现了问提，有没有兄弟能知道\n显示错误： [Error] cannot convert 'Hashnode**' to 'hashbit {aka Hashnode*}' for argument '1' to 'void duruhash(hashbit)'", "Tag": "算法分析"}
{"Answer": "这是因为两个链表都带有头节点的原因。\r\n在inter\\_link 方法中，p1=头节点，p2=头节点，while(p2!=NULL) 过程中，post->next=p2，表示post->next=头节点。\r\n你是不是打算把头节点去掉？\r\n这个方法中修改如下：\r\n\r\n\r\n```\r\n struct Node*head, *p1, *p2, *pos;\r\n\tif (a >= b) {\r\n\t\thead = p1 = chain1;\r\n\t\tp2 = chain2->next; // attention!!!!!!!!!!!!!!!!\r\n\t}\r\n\telse {\r\n\t\thead = p1 = chain2;\r\n\t\tp2 = chain1->next; // attention!!!!!!!!!!!!!!!!\r\n\t\ttemp = a;\r\n\t\ta = b;\r\n\t\tb = temp;\r\n\t}\r\n```\r\n结果如下：\r\n![图片说明](https://img-ask.csdn.net/upload/201708/19/1503132476_922095.png)", "Konwledge_Point": "算法与数字", "Question": " 关于链表合并问题 不知道哪里出了问题 \n你好\n\n这是我的代码\n\n\n\n #include \n#include \n#include \ntypedef struct Node\n{\n    int data;\n    struct Node *next;\n}NODE,*PNODE;\nvoid Delete(PNODE Head,int pos)\n{\n    int i=0;\n    PNODE p=Head;\n    while(p&&(inext;\n        i++;\n    }\n    if(p==NULL||i>pos-1)\n    {\n        printf(\"错误\\n\");\n        exit(-1);\n    }\n    PNODE q=p->next;\n    p->next=q->next;\n    free(q);\n    q=NULL;\n}\nvoid insert(PNODE Head,int pos,int val)\n{\n    int i=0;\n    PNODE p=Head;\n    while((NULL!=p)&&(inext;\n        i++;\n    }\n    if(p==NULL||i>pos-1)\n        {\n        exit(-1);\n        }\n    PNODE q=(PNODE)malloc(sizeof(NODE));\n    q->data=val;\n    q->next=p->next;\n    p->next=q;\n}\nPNODE create(int a)\n{\n    int len;\n    int i;\n    int val;\n    PNODE list;\n    PNODE Head=(PNODE)malloc(sizeof(NODE));\n    if(Head==NULL)\n    {\n        printf(\"Memory allocation failure\");\n        exit(-1);\n    }\n    else\n    {\n      PNODE tail=Head;\n      Head->next=NULL;\n      printf(\"please input the length of list: \");\n\n      for(i=0;idata=val;\n              tail->next=p;\n              p->next=NULL;\n              tail=p;\n\n          }\n      }\n\n    }\n  return Head;\n}\nvoid print(PNODE Head)\n{\n    PNODE p;\n    if(!Head->next)\n    {\n        printf(\"the list is empty\");\n        exit(-1);\n    }\n    p=Head->next;\n    while(p)\n    {\n        printf(\"%d\\t\",p->data);\n        p=p->next;\n\n    }\n    printf(\"\\n\");\n}\nstruct Node* inter_link(struct Node* chain1,int\n\na,struct Node* chain2,int b)\n{\n    int temp;\n    struct Node*head,*p1,*p2,*pos;\n    if(a>=b){\n        head=p1=chain1;\n        p2=chain2;\n    }else{\n        head=p1=chain2;\n        p2=chain1;\n        temp=a;\n        a=b;\n        b=temp;\n    }\n    pos=head;\n    while(p2!=NULL)\n    {\n        p1=p1->next;\n        pos->next=p2;\n        pos=p2;\n        p2=p2->next;\n        pos->next=p1;\n        pos=p1;\n    }\n    return head;\n}\nvoid inversion(PNODE Head)\n{\n    PNODE p,q,pr;\n    p=Head->next;\n    q=NULL;\n    Head->next=NULL;\n    while(p)\n    {\n        pr=p->next;\n        p->next=q;\n        q=p;\n        p=pr;\n    }\n    Head->next=q;\n}\nvoid sort(struct Node *p,int m)\n{\n    int i,j,t;\n    struct Node *k;\n    k=p;\n    for(i=0;idata>(p->next)->data)\n            {\n                t=p->data;\n                p->data=(p->next)->data;\n                (p->next)->data=t;\n            }\n            p=p->next;\n        }\n       p=k;\n    }\n}\nint main()\n{\n    PNODE Head,tab,boy;\n    int a,b,h;\n    scanf(\"%d\",&a);\n    Head=create(a);\n\n    printf(\"this is the list:\\n\");\n    print(Head);\n    scanf(\"%d\",&b);\n    tab=create(b);\n    print(tab);\n    inversion(Head);\n    printf(\"inverted list:\\n\");\n    print(Head);\n    printf(\"insert3:\\n\");\n\n\n    Head=inter_link(Head,a,tab,b);\n    print(Head);\n    insert(Head,3,999);\n    print(Head);\n    h=a+b;\n    Delete(Head,3);\n    print(Head);\n   //sort(boy,h);\n    //print(boy);\n\n\n\n    return 0;\n}\n\n\n\n\n\n为什么出现145368这个东西\n\n我的问题是 为什么会出现这串数字", "Tag": "算法分析"}
{"Answer": "step4输出的是 UserId\\tItemId,Score，也就是Step5的Map的step4数据KEY是UserId，map的step2的数据KEY是itemID，肯定没办法走到同一个循环。", "Konwledge_Point": "算法与数字", "Question": "Hadoop mapreduce传值问题\n最近mapreduce编写遇到了问题。在step4中，reduce可以同时收到从map中传来的A和B两组数据。但是在step5中的reudce却无法同时收到A、B两组数据，出现了有A没B，有B没A的现象，即A和B无法在同一次循环中出现。\n\n\n\nstep5，我几乎是从step4复制过来的，很奇怪他们的执行步骤为什么不一样。\n\n\n\nstep4\n\n\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.net.telnet.EchoOptionHandler;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.FileSystem;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.io.LongWritable;\nimport org.apache.hadoop.io.Text;\nimport org.apache.hadoop.mapreduce.Job;\nimport org.apache.hadoop.mapreduce.Mapper;\nimport org.apache.hadoop.mapreduce.Reducer;\nimport org.apache.hadoop.mapreduce.lib.input.FileInputFormat;\nimport org.apache.hadoop.mapreduce.lib.input.FileSplit;\nimport org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;\nimport org.apache.hadoop.yarn.logaggregation.AggregatedLogFormat.LogWriter;\n\n//同现矩阵和用户偏好矩阵相乘\npublic class Step4 {\n    public static boolean run(Configuration con, Mapmap) {\n        try {\n            FileSystem fs = FileSystem.get(con);\n            Job job = Job.getInstance();\n            job.setJobName(\"step4\");\n            job.setJarByClass(App.class);\n            job.setMapperClass(Step4_Mapper.class);\n            job.setReducerClass(Step4_Reducer.class);\n            job.setMapOutputKeyClass(Text.class);\n            job.setMapOutputValueClass(Text.class);\n            FileInputFormat.setInputPaths(job, \n                    new Path[] { \n                            new Path(map.get(\"Step4Input1\")),\n                            new Path(map.get(\"Step4Input2\"))\n                            });\n            Path outpath = new Path(map.get(\"Step4Output\"));\n            if(fs.exists(outpath)){\n                fs.delete(outpath,true);\n            }\n            FileOutputFormat.setOutputPath(job, outpath);\n            boolean f = job.waitForCompletion(true);\n            return f;\n        }catch(Exception e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n\n    static class Step4_Mapper extends Mapper{\n        private String flag;\n\n        //每次map时都会先判断一次\n        @Override\n        protected void setup(Context context )throws IOException,InterruptedException{\n            FileSplit split = (FileSplit) context.getInputSplit();\n            flag = split.getPath().getParent().getName();\n\n            System.out.print(flag+ \"*************************\");\n        }\n\n        @Override\n        protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException{\n            String[] tokens = Pattern.compile(\"[\\t,]\").split(value.toString());\n\n            //物品共现矩阵\n            if(flag.equals(\"step3\")) {\n                //  i2:i3 1\n                // i2:i2 2\n\n                String[] v1 = tokens[0].split(\":\");\n                String itemID1 = v1[0];\n                String itemID2 = v1[1];\n                String num = tokens[1];\n\n                Text k = new Text(itemID1);\n                Text v = new Text(\"A:\"+itemID2+\",\"+num); //A:i2,1\n\n                context.write(k,v);\n\n            }else if(flag.equals(\"step2\")) {//用户评价矩阵\n                // u2 i1:2,i3:4\n                String userID = tokens[0];\n                for(int i=1;i{\n        @Override\n        protected void reduce(Text key, Iterablevalues, Context context) throws IOException,InterruptedException{\n            //A为同现矩阵，B为用户偏好矩阵  \n            //某一个物品k，针对它和其他所有物品的同现次数v，都在mapA集合中\n        //  Text k = new Text(itemID1);\n        //Text v = new Text(\"A:\"+itemID2+\",\"+num); //A:i2,1\n        //  context.write(k,v);\n\n            //和该物品（key中的itemID）同现的其他物品的同现集合\n            //其他物品ID为map的key，同现数字为值\n            Map mapA = new HashMap();\n\n            //该物品（key中的itemID），所有用户的推荐权重分数\n            MapmapB = new HashMap();\n\n            for(Text line:values) {\n                String val = line.toString();\n                if(val.startsWith(\"A:\")) {\n                    String[] kv = Pattern.compile(\"[\\t,]\").split(val.substring(2));\n                    try {\n                        mapA.put(kv[0], Integer.parseInt(kv[1]));\n                    }catch(Exception e) {\n                        e.printStackTrace();\n                    }\n                }else if(val.startsWith(\"B:\")) {\n                    String[] kv = Pattern.compile(\"[\\t,]\").split(val.substring(2));\n                    try {\n                        mapB.put(kv[0], Integer.parseInt(kv[1]));\n                    }catch(Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n\n            double result = 0;\n            Iteratoriter = mapA.keySet().iterator();\n            while(iter.hasNext()) {\n                String mapk = iter.next(); //itemID\n\n                int num =mapA.get(mapk).intValue();  // 获取同现值\n                Iteratoriterb = mapB.keySet().iterator();\n                while(iterb.hasNext()) {\n                    String mapkb = iterb.next();\n                    int pref = mapB.get(mapkb).intValue();\n                    result = num*pref;\n\n                    Text k = new Text(mapkb);\n                    Text v = new Text(mapk+ \",\" + result);\n                    context.write(k, v);\n                }\n            }\n        }\n    }\n}\n\n\n\n\n\nstep5\n\n\n\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.net.telnet.EchoOptionHandler;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.FileSystem;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.io.LongWritable;\nimport org.apache.hadoop.io.Text;\nimport org.apache.hadoop.mapreduce.Job;\nimport org.apache.hadoop.mapreduce.Mapper;\nimport org.apache.hadoop.mapreduce.Reducer;\nimport org.apache.hadoop.mapreduce.Mapper.Context;\nimport org.apache.hadoop.mapreduce.lib.input.FileInputFormat;\nimport org.apache.hadoop.mapreduce.lib.input.FileSplit;\nimport org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;\nimport org.apache.hadoop.yarn.logaggregation.AggregatedLogFormat.LogWriter;\n\n\n\n\n//获得结果矩阵\npublic class Step5 {\n    public static boolean run(Configuration con, Mapmap) {\n        try {\n            FileSystem fs = FileSystem.get(con);\n            Job job = Job.getInstance();\n            job.setJobName(\"step5\");\n            job.setJarByClass(App.class);\n            job.setMapperClass(Step5_Mapper.class);\n            job.setReducerClass(Step5_Reducer.class);\n            job.setMapOutputKeyClass(Text.class);\n            job.setMapOutputValueClass(Text.class);\n            FileInputFormat.setInputPaths(job, \n                    new Path[] { \n                            new Path(map.get(\"Step5Input1\")),\n                            new Path(map.get(\"Step5Input2\"))\n                            });\n            Path outpath = new Path(map.get(\"Step5Output\"));\n            if(fs.exists(outpath)){\n                fs.delete(outpath,true);\n            }\n            FileOutputFormat.setOutputPath(job, outpath);\n            boolean f = job.waitForCompletion(true);\n            return f;\n        }catch(Exception e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n\n    static class Step5_Mapper extends Mapper{\n        private String flag;\n        //每次map时都会先判断一次\n        @Override\n        protected void setup(Context context )throws IOException,InterruptedException{\n            FileSplit split = (FileSplit) context.getInputSplit();\n            flag = split.getPath().getParent().getName();\n            System.out.print(flag+ \"*************************\");\n        }\n        @Override\n        protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException{\n            String[] tokens = Pattern.compile(\"[\\t,]\").split(value.toString());\n\n            if(flag.equals(\"step4\")) {\n                    //  i2:i3 1\n                    // i2:i2 2\n                Text k = new Text(tokens[0]);\n                Text v = new Text(\"A:\"+tokens[1]+\",\"+tokens[2]);\n                context.write(k, v);\n            }else if(flag.equals(\"step2\")) {//用户评价矩阵\n                    // u2 i1:2,i3:4\n                    String userID = tokens[0];\n                    for(int i=1;i{\n            protected void reduce(Text key, Iterablevalues, Context context) throws IOException,InterruptedException{\n                //其他物品ID为map的key，同现数字为值\n                Map mapA = new HashMap();\n\n                //该物品（key中的itemID），所有用户的推荐权重分数\n                MapmapB = new HashMap();\n\n                for(Text line : values) {\n                    String val = line.toString();\n                    if(val.startsWith(\"A:\")) {\n                        String[] kv = Pattern.compile(\"[\\t,]\").split(val.substring(2));\n                        String tokens = kv[1];\n                        String itemID = kv[0];//物品id\n                        Double score = Double.parseDouble(tokens); //相乘结果\n\n                        //相加计算\n                        if(mapA.containsKey(itemID)) {\n                            mapA.put(itemID, mapA.get(itemID)+score);\n                        }else {\n                            mapA.put(itemID, score);\n                        }\n\n                    }else if(val.startsWith(\"B:\")) {\n                        String[] kv = Pattern.compile(\"[\\t,]\").split(val.substring(2));\n                        try {\n                            mapB.put(kv[0], Integer.parseInt(kv[1]));\n                        }catch(Exception e) {\n                            e.printStackTrace();\n                        }\n                    }\n                }\n\n\n                Iterator iter = mapA.keySet().iterator();\n                while(iter.hasNext()) {\n                    String itemID = iter.next();\n                    double score = mapA.get(itemID);\n                    Text v = new Text(itemID+\",\"+score);\n                    Iteratoriterb = mapB.keySet().iterator();\n                    while(iterb.hasNext()) {\n                        String mapkb = iterb.next();\n                        Text k = new Text(mapkb);\n\n                        if(k.equals(key)) {\n                            continue;\n                        }else {\n                            context.write(key, v);\n                        }\n                    }\n                }\n            }\n        }\n\n}\n\n\n\n\n\n\nstep4和step5配置\n\n\n\nstep4，在for循环中同时出现A和B\n\n\n\nstep5中，A和B无法出现在同一次循环\n\n直接跳出了for循环进入下面的while循环，此时没有mapB，while无法正常进行\n\n\n\n进行了多次step5后，输出完所有mapA之后，在下一次step5才进入mapB，此时轮到mapA是空的，而只有mapB", "Tag": "算法分析"}
{"Answer": "这个参数本来就不是固定值啊。", "Konwledge_Point": "算法与数字", "Question": "小白求抓包数据transId的固定值\n一个网站的抓包数据 transId 没办法获取固定值 点一下抓包就变了 点一下就变了\n\n\n网站\n\n  \n    \n全球领先的数字藏品电商平台\n\n    \n  \niBox Description\n\n  \n\n  \n\n    \n\n      \nhttps://www.ibox.art/zh-cn/item/?id=100000121&gid=100065846\n\n    \n\n  \n\n\n需要配置微信环境点击才可以获取全部的数据 \n\n\n(window.webpackJsonp=window.webpackJsonp||[]).push([[10,3],{144:function(t,e,s){},145:function(t,e,s){},148:function(t,e,s){},150:function(t,e,s){\"use strict\";s(144)},151:function(t,e,s){\"use strict\";s(145)},152:function(t,e,s){\"use strict\";var a=s(19),i={name:\"NoData\",props:{tip:{type:String,default:\"暂无数据\"}}},n=(s(150),s(7)),o=Object(n.a)(i,(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s(\"div\",{staticClass:\"no-data\"},[s(\"div\",{staticClass:\"icon\"}),t._v(\" \"),s(\"div\",{staticClass:\"tip\"},[t._v(\"\\n        \"+t._s(t.tip)+\"\\n    \")])])}),[],!1,null,\"59258c4f\",null).exports,l={name:\"ScrollLoader\",props:{loading:{type:Boolean,default:!1},end:{type:Boolean,default:!1},noData:{type:Boolean,default:!1},noDataTip:{type:String,default:\"暂无数据\"},endTip:{type:String,default:\"没有更多数据了～\"}},components:{NoData:o},computed:{...Object(a.b)([\"isMobile\"])},mounted(){window.addEventListener(\"scroll\",this.load)},destroyed(){window.removeEventListener(\"scroll\",this.load,!1)},methods:{load(){if(this.loading||this.end)return;const t=this.isMobile?100:0;var e,s;(function(){let t=0,e=0,s=0;return document.body&&(e=document.body.scrollTop),document.documentElement&&(s=document.documentElement.scrollTop),t=e-s>0?e:s,t})()+document.body.clientHeight+t>=(e=0,s=0,document.body&&(e=document.body.scrollHeight),document.documentElement&&(s=document.documentElement.scrollHeight),e-s>0?e:s)&&this.$emit(\"load\")}}},c=(s(151),Object(n.a)(l,(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s(\"div\",{staticClass:\"scroll-loader\"},[t._t(\"default\"),t._v(\" \"),t.noData?s(\"no-data\",{staticClass:\"no-data\",attrs:{tip:t.noDataTip}}):t._e(),t._v(\" \"),t.end&&!t.noData?s(\"div\",{staticClass:\"no-more\"},[t._v(\"\\n        \"+t._s(t.endTip)+\"\\n    \")]):t._e()],2)}),[],!1,null,\"1bbeb5f3\",null));e.a=c.exports},155:function(t,e,s){},156:function(t,e,s){},159:function(t,e,s){\"use strict\";const a={0:\"UR\",1:\"SSR\",2:\"SR\",3:\"R\",4:\"N\"};var i={name:\"MBoxRarity\",props:{rarity:{type:[Number,String],default:\"\"},suffix:{type:String,default:\"\"}},computed:{label(){const{rarity:t}=this;if(0!==t&&!t&&!this.suffix)return\"盲盒开出\";const e=a[String(t)];return e||\"\"}}},n=(s(161),s(7)),o=Object(n.a)(i,(function(){var t=this,e=t.$createElement;return(t._self._c||e)(\"div\",{class:\"box-rarity rarity-\"+(t.rarity||0)},[t._v(\"\\n    \"+t._s(t.label)+\" \"+t._s(t.suffix)+\"\\n\")])}),[],!1,null,\"e675cdde\",null);e.a=o.exports},161:function(t,e,s){\"use strict\";s(148)},165:function(t,e,s){\"use strict\";var a={name:\"UIMobileCheckbox\",model:{prop:\"value\",event:\"change\"},props:{value:{type:[Object,Boolean],default:!1}},data(){return{checked:this.value}},methods:{toggle(){this.checked=!this.checked}},watch:{checked(t){this.$emit(\"change\",t)}}},i=(s(170),s(7)),n=Object(i.a)(a,(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s(\"div\",{staticClass:\"checkbox\",class:{checked:t.checked},on:{click:t.toggle}},[s(\"div\",{staticClass:\"icon\"}),t._v(\" \"),s(\"div\",{staticClass:\"label\"},[t._t(\"default\")],2)])}),[],!1,null,\"2225e34d\",null);e.a=n.exports},168:function(t,e,s){},170:function(t,e,s){\"use strict\";s(155)},171:function(t,e,s){\"use strict\";s(156)},179:function(t,e,s){\"use strict\";var a=s(153),i=s(159);const n={1:\"首发售罄\",2:\"热卖中\",3:\"即将开售\",4:\"尚未开售\"},o={1:\"首发售罄\",2:\"立即购买\",3:\"查看详情\",4:\"查看详情\"};var l={name:\"ProductList\",components:{MediaWrapper:a.a,BoxRarity:i.a},props:{products:{type:Array,default:()=>[]},showIndex:{type:Boolean,default:!1},mustShowAuthor:{type:Boolean,default:!1},showAction:{type:Boolean,default:!0},showGName:{type:Boolean,default:!1},showRarity:{type:Boolean,default:!1}},data:()=>({listData:[]}),methods:{isVideo(t){const{thumbPic:e}=t;return e.includes(\".mp4\")},saleLabel:t=>n[t],btnLabel:t=>o[t],detail(t){const{gType:e}=t;null===e||0===e?this.$router.push(\n/zh-cn/item/?id=${t.albumId||\"\"}${t.gId?\"&gid=\"+t.gId:\"\"}\n):this.$router.push(\n/zh-cn/mbox/item/?id=${t.albumId||\"\"}${t.gId?\"&gid=\"+t.gId:\"\"}\n)}}},c=(s(187),s(7)),r=Object(c.a)(l,(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s(\"div\",{staticClass:\"product-list\"},t._l(t.products,(function(e,a){return s(\"div\",{key:\"\"+e.albumId+(e.gId?e.gId:a)+e.gNum,staticClass:\"product-container\"},[s(\"div\",{class:\"product status-\"+e.onSale+\" \"+(t.isVideo(e)?\"is-video\":\"\"),on:{click:function(s){return t.detail(e)}}},[s(\"div\",{staticClass:\"cover-wrapper\"},[s(\"div\",{staticClass:\"cover\"},[s(\"media-wrapper\",{attrs:{type:t.isVideo(e)?2:1,src:e.thumbPic}})],1),t._v(\" \"),t.isVideo(e)?[s(\"div\",{staticClass:\"btn-play\",on:{click:function(s){return t.detail(e)}}})]:t.showAction?[s(\"div\",{staticClass:\"btn-status\"},[s(\"nuxt-link\",{attrs:{to:\"/zh-cn/item/?id=\"+(e.albumId||\"\")+(e.gId?\"&gid=\"+e.gId:\"\")}},[s(\"button\",[s(\"span\",{staticClass:\"text\"},[t._v(\"\\n                                    \"+t._s(t.btnLabel(e.onSale))+\"\\n                                \")]),t._v(\" \"),s(\"span\",{staticClass:\"icon\"})])])],1)]:t._e()],2),t._v(\" \"),s(\"div\",{staticClass:\"detail\"},[s(\"div\",{staticClass:\"name\"},[s(\"span\",{staticClass:\"album-name\"},[t._v(\"\\n                        \"+t._s(t.showGName&&e.gName||e.albumName)+\"\\n                    \")]),t._v(\" \"),e.vFlag?s(\"span\",{staticClass:\"v-flag\"}):t._e()]),t._v(\" \"),s(\"div\",{staticClass:\"item-detail\"},[s(\"div\",{staticClass:\"detail-content\",class:{\"show-index\":t.showIndex}},[null===e.gType||0===e.gType?s(\"div\",{staticClass:\"author-info\"},[s(\"img\",{staticClass:\"author-head\",attrs:{src:e.authorHeadImage?e.authorHeadImage:\"/image/default/head.png\",alt:\"headImg\"}}),t._v(\"\\n                            \"+t._s(e.authorName)+\"\\n                        \")]):t.mustShowAuthor?s(\"div\",{staticClass:\"author-info\"},[t._v(\"\\n                            盲盒商品\\n                        \")]):t._e(),t._v(\" \"),t.showIndex?[0===e.gType?s(\"div\",{staticClass:\"sell-limit\"},[s(\"b\",[t._v(\"\\n                                    #\"+t._s(e.gNum)+\"\\n                                \")]),t._v(\"\\n                                / \"+t._s(e.sellLimit)+\"\\n                            \")]):s(\"div\",{staticClass:\"sell-limit\",style:{opacity:.6}},[t._v(\"\\n                                \"+t._s(1===e.label?\"多开不重\":\"单开\")+\"\\n                            \")])]:t._e()],2),t._v(\" \"),4!==e.onSale?s(\"div\",{staticClass:\"price\"},[t._v(\"\\n                        \"+t._s(\"\"!==e.priceCny?\"￥\":\"\")+t._s(t._f(\"defaultValue\")(e.priceCny))+\"\\n                    \")]):s(\"div\",{staticClass:\"price\"},[t._v(\"\\n                        尚未开售\\n                    \")]),t._v(\" \"),s(\"div\",{staticClass:\"price-mobile\"},[4!==e.onSale?s(\"div\",{staticClass:\"price-value\"},[t._v(\"\\n                            \"+t._s(\"\"!==e.priceCny?\"￥\":\"\")+t._s(t._f(\"defaultValue\")(e.priceCny))+\"\\n                        \")]):s(\"div\",{staticClass:\"price-value\"},[t._v(\"\\n                            尚未开售\\n                        \")]),t._v(\" \"),s(\"div\",{staticClass:\"go\"})])])]),t._v(\" \"),[1,2,3].includes(e.onSale)&&t.showAction?s(\"div\",{staticClass:\"status-tag\"},[s(\"span\",{staticClass:\"icon\"}),t._v(\"\\n                \"+t._s(t.saleLabel(e.onSale))+\"\\n            \")]):t._e(),t._v(\" \"),t.showRarity&&0===e.gType&&null!==e.label?s(\"div\",{staticClass:\"rarity\"},[s(\"box-rarity\",{attrs:{suffix:\"盲盒开出\",rarity:e.rarity}})],1):t._e()])])})),0)}),[],!1,null,\"39761c76\",null);e.a=r.exports},180:function(t,e,s){\"use strict\";var a={name:\"UIMobileTabs\",model:{prop:\"value\",event:\"change\"},props:{value:{type:Number,default:null},list:{type:Array,default:()=>[]}},data(){return{active:this.value}},methods:{change(t){this.active=t}},watch:{active(t){this.$emit(\"change\",t)}}},i=(s(171),s(7)),n=Object(i.a)(a,(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s(\"div\",{staticClass:\"tab-change\"},t._l(t.list,(function(e){return s(\"div\",{key:e.value,staticClass:\"tab\",class:{active:e.value===t.active},on:{click:function(s){return t.change(e.value)}}},[t._v(\"\\n        \"+t._s(e.label)+\"\\n    \")])})),0)}),[],!1,null,\"3c467362\",null);e.a=n.exports},187:function(t,e,s){\"use strict\";s(168)},225:function(t,e,s){},226:function(t,e,s){},227:function(t,e,s){},228:function(t,e,s){},229:function(t,e,s){},230:function(t,e,s){},317:function(t,e,s){\"use strict\";s(225)},318:function(t,e,s){\"use strict\";s(226)},327:function(t,e,s){\"use strict\";s(227)},328:function(t,e,s){\"use strict\";s(228)},329:function(t,e,s){\"use strict\";s(229)},330:function(t,e,s){\"use strict\";s(230)},428:function(t,e,s){\"use strict\";s.r(e);var a=s(15),i=s(179),n=s(178),o=s(19),l=(s(312),s(147)),c=s(53),r=s(14),u=s(33),d=s(6),h=s(28),v=(s(313),s(222),{name:\"ProfileEditorModal\",components:{CommonModal:h.a,ElButton:s(314).default,ElInput:s(223).default},props:{user:{type:Object,default:()=>{}}},data(){const{user:t}=this;return{name:t.userName,bio:t.introduction,site:t.socialPlatform,loading:!1,autosize:{minHeight:168}}},methods:{async submit(){const{name:t,bio:e,site:s,user:i}=this;if(!this.checkSiteFormat())return void this.toast(\"社交地址格式不正确\",\"error\");this.loading=!0;const{success:n,message:o}=await a.b.updatePersonalInfo({headImage:i.headImage,userName:t,introduction:e,socialPlatform:s});this.loading=!1,n?(this.$emit(\"close\"),this.$parent.$emit(\"success\")):this.toast(o,\"error\")},startWith:t=>t.includes(\"https://\")||t.includes(\"http://\"),checkSiteFormat(){const{site:t}=this;let e=!1;if(t)if(t.includes(\";\")){const s=t.split(\";\");for(let t=0;t[]}},methods:{}},f=(s(318),Object(m.a)(b,(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s(\"common-modal\",[s(\"h3\",{staticClass:\"modal-title\",attrs:{slot:\"title\"},slot:\"title\"},[t._v(\"\\n        我的\\n    \")]),t._v(\" \"),s(\"div\",{staticClass:\"modal-content\",attrs:{slot:\"content\"},slot:\"content\"},t._l(t.links,(function(e,a){return s(\"a\",{key:a,attrs:{href:e,target:\"_blank\",rel:\"noopener noreferrer\"}},[t.\nv(\"\\n            \"+t.\ns(e)),s(\"i\")])})),0)])}),[],!1,null,\"6a273684\",null).exports),\n={name:\"CreativeAccountInfo\",components:{ElUpload:s(319).default,Clipboard:c.a},async created(){await this.loadUserInfo()},mounted(){this.headers[r.i]=this.$cookies.get(r.i)},data:()=>({headers:{},action:\"/file/upload\",data:{transId:Object(u.b)(),platform:\"web\",project:\"nft-mall\",upType:\"portrait\"},uploading:!1,user:{},copyable:!1,debugCount:0}),computed:{...Object(o.b)([\"uid\",\"isLogin\"]),isAccount(){const{uid:t,userId:e}=this;return+t==+e},links(){const{socialPlatform:t}=this.user;let e=t.split(\";\");return e[e.length-1]||e.splice(e.length-1,1),e},id(){const{id:t}=this.$route.query;return t||\"\"},userId(){const{id:t,uid:e}=this;return t||e}},methods:{checkDebug(){if(20==++this.debugCount){const t=s(95);Object(d.f)()&&new t}},beforeHeadUpload(t){const e=t.size/1024/1024<1;return this.uploading=!0,e||(this.toast(\"上传头像图片大小不能超过 1MB!\",\"error\"),this.uploading=!1),this.data.transId=Object(u.b)(),this.headers[r.i]=this.$cookies.get(r.i),e},onHeadSuccess({code:t,data:e,msg:s}){this.uploading=!1,1===t?(this.user.headImage=e[0],this.saveProfile()):this.toast(s,\"error\")},async saveProfile(){const{headImage:t,userName:e,introduction:s,socialPlatform:i}=this.user,{success:n,message:o}=await a.b.updatePersonalInfo({headImage:t,userName:e,introduction:s,socialPlatform:i});n||this.toast(o,\"error\")},async loadUserInfo(){this.user={};const{success:t,data:e,code:s}=await a.b.getPersonalInfo(this.userId);t?(this.user=e||{},this.user.walletAddress&&(this.copyable=!0)):121===s&&this.isAccount&&await this.login()},edit(){this.$modal.show(p,{user:this.user},{width:\"480px\",height:\"auto\"},{success:()=>{this.$store.dispatch(\"checkToken\"),this.loadUserInfo()}})},goOrder(){this.$router.push(\"/zh-cn/order/list\")},webShow(){this.$modal.show(f,{links:this.links},{height:\"auto\"})},onSuccess(){this.toast(\"复制成功\",\"success\")},onError(){this.toast(\"复制失败\",\"error\")}},watch:{uid(){this.loadUserInfo()},\"user.uid\"(){this.$emit(\"change\",this.user)},userId(t){this.loadUserInfo()}}},g=(s(327),Object(m.a)(\n,(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s(\"div\",{staticClass:\"account-info\"},[s(\"div\",{staticClass:\"inner\"},[s(\"div\",{staticClass:\"user-info\"},[s(\"el-upload\",{staticClass:\"avatar-uploader\",attrs:{action:t.action,\"show-file-list\":!1,headers:t.headers,data:t.data,disabled:t.uploading||!t.isAccount,accept:\"image/png, image/jpg, image/jpeg\",\"on-success\":t.onHeadSuccess,\"before-upload\":t.beforeHeadUpload}},[s(\"div\",{staticClass:\"head-container\"},[s(\"div\",{staticClass:\"head\"},[t.user.headImage?s(\"img\",{attrs:{src:t.user.headImage}}):t._e()]),t._v(\" \"),t.isAccount?s(\"div\",{staticClass:\"head-edit\"}):t._e()])]),t._v(\" \"),s(\"div\",{staticClass:\"user-detail\"},[s(\"div\",{staticClass:\"name\"},[s(\"div\",{staticClass:\"name-text\"},[t._v(\"\\n                        \"+t._s(t._f(\"defaultValue\")(t.user.userName))+\"\\n                    \")]),t._v(\" \"),s(\"div\",{staticClass:\"name-text-mobile\"},[t._v(\"\\n                        \"+t._s(t._f(\"defaultValue\")(t.user.userName))+\"\\n                    \")]),t._v(\" \"),t.isAccount?s(\"button\",{on:{click:t.edit}},[s(\"span\",{staticClass:\"icon\"}),t._v(\" \"),s(\"span\",{staticClass:\"text\"},[t._v(\"\\n                            编辑资料\\n                        \")])]):t._e()]),t._v(\" \"),s(\"div\",{staticClass:\"address\"},[s(\"span\",{staticClass:\"walletAddress\"},[t._v(t._s(t.user.walletAddress))]),t._v(\" \"),s(\"span\",{staticClass:\"mobile-walletAddress\"},[t._v(t._s(t._f(\"address\")(t.user.walletAddress||\"--\")))]),t._v(\" \"),t.copyable?s(\"clipboard\",{staticClass:\"copy\",attrs:{text:t.user.walletAddress,success:t.onSuccess,error:t.onError}}):t._e()],1)])],1),t._v(\" \"),s(\"div\",{staticClass:\"user-about\",on:{click:t.checkDebug}},[t._v(\"\\n            \"+t._s(t._f(\"defaultValue\")(t.user.introduction))+\"\\n        \")]),t._v(\" \"),t.user.socialPlatform?s(\"div\",{staticClass:\"user-website\"},[s(\"span\",{staticClass:\"icon\"}),t._v(\" \"),t._l(t.links,(function(e,a){return s(\"a\",{key:a,staticClass:\"pc-link\",attrs:{href:e,target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"\\n                \"+t._s(e)+\"\\n            \")])})),t._v(\" \"),t.links.length>0?s(\"a\",{staticClass:\"mobile-link\",attrs:{target:\"_blank\",href:t.links[0],rel:\"noopener noreferrer\"}},[t._v(t._s(t.links[0]))]):t._e(),t._v(\" \"),t.links.length>1?s(\"b\",{on:{click:t.webShow}},[t._v(\"更多\")]):t._e()],2):t._e(),t._v(\" \"),s(\"div\",{directives:[{name:\"show\",rawName:\"v-show\",value:t.isAccount,expression:\"isAccount\"}],staticClass:\"order-info\",on:{click:t.goOrder}},[t._v(\"\\n            全部订单\\n        \")])])])}),[],!1,null,\"5aa7f656\",null).exports),C=s(165),y=s(152),w={name:\"UIMobileRadioGroup\",model:{prop:\"value\",event:\"change\"},props:{value:{type:Number,default:null},list:{type:Array,default:()=>[]}},data(){return{active:this.value}},methods:{change(t){this.active=t}},watch:{active(t){this.$emit(\"change\",t)}}},x=(s(328),Object(m.a)(w,(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s(\"div\",{staticClass:\"radio-group\"},t._l(t.list,(function(e){return s(\"div\",{key:e.value,staticClass:\"item\",class:{checked:e.value===t.active},on:{click:function(s){return t.change(e.value)}}},[s(\"div\",{staticClass:\"icon\"}),t._v(\" \"),s(\"div\",{staticClass:\"label\"},[t._v(\"\\n            \"+t._s(e.label)+\"\\n        \")])])})),0)}),[],!1,null,\"1954425e\",null).exports),k=s(180),I={name:\"MBoxAccountList\",components:{ImageObject:s(181).a},props:{list:{type:Array,default:()=>[]},showPrice:{type:Boolean,default:!0}}},$=(s(329),Object(m.a)(I,(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s(\"div\",{staticClass:\"account-mbox-list\"},t._l(t.list,(function(e,a){return s(\"div\",{key:\"\"+e.albumId+e.num+a,staticClass:\"item-wrapper\"},[s(\"div\",{staticClass:\"item\",on:{click:function(s){return t.$emit(\"item-click\",e)}}},[s(\"div\",{staticClass:\"cover\"},[s(\"image-object\",{attrs:{src:e.thumbPic}})],1),t._v(\" \"),s(\"div\",{staticClass:\"detail\"},[s(\"div\",{staticClass:\"name\"},[t._v(\"\\n                    \"+t._s(t._f(\"defaultValue\")(e.gName))+\"\\n                \")]),t._v(\" \"),e.num>1?s(\"div\",{staticClass:\"num\"},[t._v(\"\\n                    \"+t._s(1===e.label?\"多开不重\":\"单开\")+\" x \"+t._s(t._f(\"defaultValue\")(e.num))+\"\\n                \")]):s(\"div\",{staticClass:\"num\"},[t._v(\"\\n                    \"+t._s(1===e.label?\"多开不重\":\"单开\")+\"\\n                \")]),t._v(\" \"),s(\"div\",{staticClass:\"price\",class:{\"hide-price\":!t.showPrice}},[s(\"div\",{staticClass:\"text\"},[t._v(\"\\n                        ￥\"+t._s(t._f(\"defaultValue\")(e.priceCny))+\"\\n                    \")]),t._v(\" \"),s(\"button\")])])])])})),0)}),[],!1,null,\"abe8b508\",null).exports),A={name:\"CreativePage\",data(){const{type:t,box:e,sale:s,sub:a}=this.$route.query;return{loading:!0,active:isNaN(Number(t))?2:Number(t),page:1,totalPage:0,list:[],noMore:!1,loadId:(new Date).getTime(),subActive:isNaN(Number(a))?0:Number(a),onlyOnSale:\"true\"===s,user:{},subTabs:[{label:\"藏品\",value:0},{label:\"盲盒\",value:1}],mBoxStatus:isNaN(Number(e))?0:Number(e),radios:[{label:\"在售\",value:1},{label:\"不在售\",value:0}]}},async created(){this.page=1,this.list=[],await this.load()},mounted(){this.syncQuery()},components:{List:i.a,ListSkeleton:n.a,ResponsiveLayout:l.a,AccountInfo:g,ScrollLoader:y.a,RadioGroup:x,Tabs:k.a,Checkbox:C.a,AccountList:$},computed:{isAccount(){const{uid:t,userId:e}=this;return+t==+e},id(){const{id:t}=this.$route.query;return t||\"\"},userId(){const{id:t,uid:e}=this;return t||e},pageSize(){const{isMobile:t}=this;return t?50:60},tabs(){const{isAccount:t}=this,e=t?[\"我拥有的\",\"我卖出的\",\"我创作的\"]:[\"TA拥有的\",\"TA卖出的\",\"TA创作的\"];return[2,1,0].map(((t,s)=>({id:t,title:e[s]})))},...Object(o.b)([\"uid\",\"isLogin\",\"isMobile\"]),...Object(o.b)(\"ethereum\",[\"account\"]),onSale(){const{subActive:t,mBoxStatus:e,onlyOnSale:s}=this;return 0===t?s?1:0:e}},methods:{initShare(){const{headImage:t,userName:e}=this.user;t&&this.initWxShare({title:\n${e}的数字藏品，邀你参观\n,desc:\n${e}的数字收藏品主⻚，戳戳看有哪些新鲜的NFT。\n,link:\n${location.origin}/zh-cn/account/?id=${this.userId}\n,timeLinetitle:\n${e}的数字藏品，邀你参观\n,imgUrl:t.includes(\"http\")?\n${t}\n:\n${location.origin}${t}\n})},async load(){this.loading=!0;const t=this.loadId,{success:e,data:s}=await a.b.getCollectionListByUid({uid:this.userId,type:this.active,pageSize:this.pageSize,page:this.page,subType:this.subActive,onSale:this.onSale});t===this.loadId&&(e?(this.page=s.currPage+1,this.noMore=0===s.hashNext,s&&s.list.length&&this.list.push(...s.list)):this.noMore=!0,this.loading=!1)},change(t){this.active=t},changeSub(t){this.subActive=t},reset(){this.page=1,this.list=[],this.noMore=!1,this.loadId=(new Date).getTime()},onItemClick(t){6!==t.onSale?6===t.onSale||this.isAccount?6!==t.onSale&&this.isAccount&&this.$router.push(\n/zh-cn/mbox/open/?id=${t.albumId}#=${t.num}&type=${t.label}&from=account${t.gId?\n&gid=${t.gId}\n:\"\"}\n):this.$router.push(\n/zh-cn/mbox/item/?id=${t.albumId}\n):this.$router.push(\n/zh-cn/mbox/item/?id=${t.albumId}&gid=${t.gId}\n)},onUserChange(t){this.user=t},syncQuery(){const{active:t,mBoxStatus:e,onlyOnSale:s,subActive:a,userId:i}=this;history.replaceState(null,document.title,\n?type=${t}&box=${e}&sale=${s}⊂=${a}${i?\n&id=${i}\n:\"\"}\n)}},watch:{active(){this.reset(),this.load(),this.syncQuery()},mBoxStatus(){this.reset(),this.load(),this.syncQuery()},onlyOnSale(){this.reset(),this.load(),this.syncQuery()},subActive(){this.reset(),this.load(),this.syncQuery()},async account(t){t?(await this.loadUserInfo(),this.reset(),await this.load()):this.goHome()},\"user.uid\"(){this.initShare()},userId(){this.page=1,this.list=[],this.noMore=!1,this.load()}}},S=(s(330),Object(m.a)(A,(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s(\"responsive-layout\",[s(\"section\",{staticClass:\"page\"},[s(\"account-info\",{on:{change:t.onUserChange}}),t._v(\" \"),s(\"div\",{staticClass:\"list-container\"},[s(\"ul\",{staticClass:\"tabs\"},t._l(t.tabs,(function(e){return s(\"li\",{key:e.id,staticClass:\"tab\",class:{active:e.id===t.active},on:{click:function(s){return t.change(e.id)}}},[t._v(\"\\n                    \"+t._s(e.title)),s(\"i\")])})),0),t._v(\" \"),2===t.active?s(\"div\",{staticClass:\"extend-bar\"},[s(\"div\",{staticClass:\"sub-tabs\"},[s(\"tabs\",{staticClass:\"tabs-custom\",attrs:{list:t.subTabs},model:{value:t.subActive,callback:function(e){t.subActive=e},expression:\"subActive\"}})],1),t._v(\" \"),s(\"div\",{staticClass:\"filter\"},[s(\"radio-group\",{directives:[{name:\"show\",rawName:\"v-show\",value:1===t.subActive,expression:\"subActive === 1\"}],attrs:{list:t.radios},model:{value:t.mBoxStatus,callback:function(e){t.mBoxStatus=e},expression:\"mBoxStatus\"}}),t._v(\" \"),s(\"checkbox\",{directives:[{name:\"show\",rawName:\"v-show\",value:1!==t.subActive,expression:\"subActive !== 1\"}],model:{value:t.onlyOnSale,callback:function(e){t.onlyOnSale=e},expression:\"onlyOnSale\"}},[t._v(\"\\n                        仅看在售\\n                    \")])],1)]):t._e(),t._v(\" \"),s(\"div\",{staticClass:\"list\"},[s(\"scroll-loader\",{attrs:{loading:t.loading,end:t.noMore,\"no-data\":!t.list.length&&!t.loading,\"no-data-tip\":\"暂无收藏\"},on:{load:t.load}},[2===t.active?[0===t.subActive?s(\"list\",{attrs:{products:t.list,\"show-action\":0===t.active,\"show-index\":0!==t.active,\"show-g-name\":!0,\"show-rarity\":!0,\"must-show-author\":!0}}):t._e(),t._v(\" \"),1===t.subActive?s(\"account-list\",{attrs:{list:t.list,\"show-price\":1===t.mBoxStatus},on:{\"item-click\":t.onItemClick}}):t._e()]:[s(\"list\",{attrs:{products:t.list,\"show-action\":0===t.active,\"show-index\":0!==t.active,\"show-g-name\":!0,\"show-rarity\":!0,\"must-show-author\":!0}})]],2),t._v(\" \"),s(\"list-skeleton\",{directives:[{name:\"show\",rawName:\"v-show\",value:t.loading,expression:\"loading\"}],attrs:{size:t.isMobile?4:8}})],1)])],1)])}),[],!1,null,\"32cb8751\",null));e.default=S.exports}}]);", "Tag": "算法分析"}
{"Answer": "写成jd* cz_bh()，这是函数申明，当然啥也不会执行写成ch_bh()，这是函数调用，在这里调用ch_bh函数，当然会执行啊=======86行你只是调用了ch_bh()函数，但你没有接收这个函数的返回值啊，改成p = ch_bh();这样p才是函数查找到的节点指针", "Konwledge_Point": "算法与数字", "Question": "C语言实训的两个问题\n我一共有两个问题关于我C语言的结课代码\n1、函数无法调用的问题（\n已解决\n）但是不知道原理，希望帮忙解释一下，就是我写的函数声明是 *\njd\n cz_bh()\n;，当我要调用的时候(\ncase '3'的时候调用了\n)把这段代码原封不动写上去函数无法运行，直接跳过了这个函数，但是当我把\njd*删除\n，只保留cz_bh()后函数又可以正常调用了，我不知道是为什么希望有人帮我解释一下\n\n\n2、查找功能传回去的值不是我需要的值，我定义了一个cz_bh()函数来以此通过编号查找到我存储的零部件信息，当我往cz_bh()中存储信息，如图是我已经输入的数据\n\n\n我要查找，往cz_bh()输入1，结果是编号2的信息，不知道是为什么\n\n\n\n\n于是我开始调试，如图是第二次循环找到了编号为2零部件\n\n\n\n\n然后程序返回了p，截至到这里都没有问题，如图，但是返回后的值有问题，p本应该返回编号为1的值，但是此时返回了编号为2的值\n\n\n\n\n接下来输入什么返回的都是2的值，不知道为什么，我把我的源代码发在底下了，希望有巨佬能忙里抽闲帮我看一下，我必感激不尽\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n\n//定义采购信息 \n\n\ntypedef\n \nstruct\n \n_car\n\n{\n    \nchar\n bh[\n20\n]; \n//编号\n\n    \nchar\n mc[\n10\n]; \n//名称\n\n    \nchar\n rq[\n20\n]; \n//日期\n\n    \nchar\n cgy[\n20\n];\n//采购员\n\n    \nint\n num;     \n//数量\n\n    \ndouble\n dj;    \n//单价\n\n    \nchar\n dw[\n5\n];  \n//单位 \n\n}car;\n\n\n\n//结点 \n\n\ntypedef\n \nstruct\n \n_jd\n\n{\n    car lj;      \n//零件\n\n     \n    \nstruct\n \n_jd\n* pnext;\n//指向下一个结点的指针 \n\n}jd;\n\n\n//头结点\n\njd *g_pHead = \nNULL\n; \n\n\n//函数：菜单 \n\n\nvoid\n \nmenu\n()\n;\n\n\n//函数：录入信息\n\n\nvoid\n \nlr\n()\n; \n\n\n//函数：打印信息\n\n\nvoid\n \ndy\n()\n; \n\n\n//函数：通过编号查找零部件\n\n\njd* \ncz_bh\n()\n;\n\n\n//函数：通过名称查找零部件\n\n\njd* \ncz_mc\n()\n; \n\n\n//函数：修改零部件信息\n\n\nvoid\n \nxg\n()\n;\n\n\n//函数：删除零部件是头结点的信息\n\n\nvoid\n \nt_sc\n()\n; \n\n\n//函数：删除零部件不是头结点的信息\n\n\nvoid\n \nft_sc\n()\n; \n\n\n\nint\n \nmain\n()\n\n\n{\n        \nwhile\n(\n1\n)\n    {\n        jd* p;\n        p = g_pHead;\n        \n        \nsystem\n(\n\"cls\"\n); \n//清屏 \n\n    \n        \n//打开菜单 \n\n        \nmenu\n();\n    \n        \n//输入选择 \n\n        \nprintf\n(\n\"请输入你的选择(直接点击数字，不用进行回车)\\n\"\n);\n    \n        \n//从键盘中接收一个字符来直接操作 \n\n        \nchar\n ch = \ngetch\n();\n        \nswitch\n(ch)\n       {\n        \ncase\n \n'1'\n:\n            \nprintf\n(\n\"接下来是采购信息的录入\\n\"\n);\n            \nlr\n();\n        \nbreak\n;\n        \n        \ncase\n \n'2'\n:\n            \nprintf\n(\n\"接下来是打印所有零部件采购信息\\n\"\n);\n            \ndy\n();\n        \nbreak\n;\n        \n        \ncase\n \n'3'\n:\n        {\n            \nprintf\n(\n\"接下来是通过编号查找零部件\\n\"\n);\n            \ncz_bh\n();\n            \nif\n(p != \nNULL\n) \n            {\n                \nprintf\n(\n\"*编号:%s\\t*名称:%s\\t*日期:%s\\t*采购员:%s\\t*数量%d\\t*单价:%.2lf\\t*单位:%s*\\n\"\n,p->lj.bh,p->lj.mc,p->lj.rq,p->lj.cgy,p->lj.num,p->lj.dj,p->lj.dw);\n            }\n            \n            \nelse\n\n            {\n                \nprintf\n(\n\"查找失败，未检查到所输入的编号，请您重新检查输入\\n\"\n); \n            }\n            \nsystem\n(\n\"pause\"\n);\n        \nbreak\n;\n       }\n        \n        \ncase\n \n'4'\n:\n        {\n            \nprintf\n(\n\"接下来是通过名称查找零部件\\n\"\n);\n            \ncz_mc\n(); \n            \nif\n(p != \nNULL\n) \n            {\n                \nprintf\n(\n\"*编号:%s\\t*名称:%s\\t*日期:%s\\t*采购员:%s\\t*数量%d\\t*单价:%.2lf\\t*单位:%s*\\n\"\n,p->lj.bh,p->lj.mc,p->lj.rq,p->lj.cgy,p->lj.num,p->lj.dj,p->lj.dw);\n            }\n            \n            \nelse\n \nif\n(p == \nNULL\n)\n            {\n                \nprintf\n(\n\"查找失败，未检查到所输入的名称，请您重新检查输入\"\n); \n            }\n            \nsystem\n(\n\"pause\"\n);\n        \nbreak\n;\n        }\n        \n        \ncase\n \n'5'\n:\n            \nprintf\n(\n\"接下来是给定采购编号，修改采购信息\\n\"\n); \n            \nxg\n();\n        \nbreak\n;\n        \n        \ncase\n \n'6'\n:\n        {\n            \nint\n i;\n            \nprintf\n(\n\"接下来是给定采购编号，删除采购信息\\n\"\n);\n            \nprintf\n(\n\"请输入需要删除的零部件的编号是否是您最后输入的零部件(是或只有一个零部件按1，不是按0):\\n\"\n);\n            \nscanf\n(\n\"%d\"\n,&i);\n            \nif\n(i==\n1\n)\n            {\n                \nt_sc\n();\n            }\n            \nelse\n \nif\n(i==\n0\n)\n            {\n                \nft_sc\n();\n            }\n            \nelse\n\n            {\n                \nprintf\n(\n\"对不起，您的输入有误，请重新检查输入\\n\"\n);\n                \nsystem\n(\n\"pause\"\n);\n            }\n        \nbreak\n;\n        }\n        \n        \ncase\n'7'\n:\n            \nprintf\n(\n\"感谢您的下次使用，再见\"\n);\n            \nreturn\n \n0\n; \n        \nbreak\n;\n        \n        \ndefault\n:\n        \nprintf\n(\n\"您当前输入有误，请您确认您的操作再重试\\n\"\n);\n        \nsystem\n(\n\"pause\"\n);\n        \nbreak\n;\n        } \n    }\n    \n    \nreturn\n \n0\n;\n}\n\n\nvoid\n \nmenu\n()\n\n\n{\n    \nprintf\n(\n\"******汽车零部件采购程序******\\n\"\n);\n    \nprintf\n(\n\"\\t(1)能从键盘输入采购信息。\"\n);\n    \nprintf\n(\n\"\\n\\t(2)打印所有零部件信息。\"\n);\n    \nprintf\n(\n\"\\n\\t(3)指定采购编号，显示采购的零部件信息。\"\n);\n    \nprintf\n(\n\"\\n\\t(4)指定零部件名称，显示该零部件的所有采购信息。\"\n);\n    \nprintf\n(\n\"\\n\\t(5)给定采购编号，修改采购信息。\"\n);\n    \nprintf\n(\n\"\\n\\t(6)给定采购编号，删除采购信息。\"\n);\n    \nprintf\n(\n\"\\n\\t(7)退出程序\\n\"\n);\n}\n\n\nvoid\n \nlr\n()\n\n\n{\n    \n//创建一个新结点\n\n    jd* pjd=(jd*)\nmalloc\n(\nsizeof\n(jd)); \n    pjd->pnext=\nNULL\n;\n    \n    \n//头插法\n\n    \nif\n(g_pHead == \nNULL\n) \n//没有结点，赋予结点 \n\n    {\n        g_pHead = pjd;\n    }\n    \nelse\n                \n//有结点\n\n    {\n        pjd->pnext = g_pHead;\n//新结点的下一个为头结点\n\n        g_pHead = pjd;      \n//则头结点为新设的结点 \n\n    }\n    \n    \nprintf\n(\n\"请输入编号(例如:1 2 3):\\n\\t\"\n);\n    \nscanf\n(\n\"%s\"\n,pjd->lj.bh); \n//编号\n\n    \n    \nprintf\n(\n\"请输入零部件名称(例如:xxx):\\n\\t\"\n);\n    \nscanf\n(\n\"%s\"\n,pjd->lj.mc); \n//名称\n\n    \n    \nprintf\n(\n\"请输入日期(例如:xx):\\n\\t\"\n);\n    \nscanf\n(\n\"%s\"\n,pjd->lj.rq); \n//日期\n\n    \n    \nprintf\n(\n\"请输入采购员名称(例如:张三):\\n\\t\"\n);\n    \nscanf\n(\n\"%s\"\n,pjd->lj.cgy);\n//采购员 \n\n    \n    \nprintf\n(\n\"请输入采购数量(例如:2):\\n\\t\"\n);\n    \nscanf\n(\n\"%d\"\n,&pjd->lj.num);\n//数量 \n\n    \n    \nprintf\n(\n\"请输入零部件单价(例如:2.00):\\n\\t\"\n);\n    \nscanf\n(\n\"%lf\"\n,&pjd->lj.dj);\n//单价 \n\n    \n    \nprintf\n(\n\"请输入零部件价格单位(例如:SF):\\n\\t\"\n); \n    \nscanf\n(\n\"%s\"\n,pjd->lj.dw); \n//单位 \n\n    \n    \nprintf\n(\n\"零部件信息录入成功!\\n\"\n);\n    \nprintf\n(\n\"如果您想继续输入，请在看到请按任意键继续后回到菜单继续按1录入信息\\n\"\n);\n    \n    \nsystem\n(\n\"pause\"\n); \n//停顿 \n\n      \nreturn\n;\n}\n\n//*********************\n\n\n//********\n\n\n//*************\n\n\n\nvoid\n \ndy\n()\n\n\n{\n    \nprintf\n(\n\"******************************************************\\n\"\n);\n    \nprintf\n(\n\"*\\t       欢迎使用汽车零部件管理系统            *\\n\"\n);\n    \nprintf\n(\n\"******************************************************\\n\"\n); \n    \n    \nprintf\n(\n\"*编号\\t*名称\\t*日期\\t*采购员\\t*数量\\t*单价\\t*单位*\\n\"\n);\n    \nprintf\n(\n\"******************************************************\\n\"\n) ;\n    \n    \n//遍历链表\n\n    jd* p =g_pHead; \n//让p指向头指针\n\n    \nwhile\n(p != \nNULL\n)\n//只要结点不为空就让循环往下走 \n\n    {\n    \nprintf\n(\n\"*%s\\t*%s\\t*%s\\t*%s\\t*%d\\t*%.2lf\\t*%s*\\n\"\n,\n        p->lj.bh,\n        p->lj.mc,\n        p->lj.rq,\n        p->lj.cgy,\n        p->lj.num,\n        p->lj.dj,\n        p->lj.dw);\n        \n        p=p->pnext; \n//指向下一个 \n\n    } \n     \n    \nsystem\n(\n\"pause\"\n);\n}\n\n\njd* \ncz_bh\n()\n\n\n{\n    \nchar\n cz_bh[\n20\n];\n    \n    \nprintf\n(\n\"请输入你想查找的零件的编号:\\n\"\n);\n    \nscanf\n(\n\"%s\"\n,cz_bh);\n    \n    jd* p=g_pHead;\n    \nwhile\n(p!=\nNULL\n)\n    {\n        \nif\n(\nstrcmp\n(p->lj.bh,cz_bh)==\n0\n) \n//会报警告 \n\n        {\n            \nreturn\n p;\n        }\n        \n        p = p->pnext;\n    }\n    \nreturn\n \nNULL\n; \n}\n\n\njd* \ncz_mc\n()\n\n\n{\n    \nchar\n cz_mc[\n20\n];\n    \n    \nprintf\n(\n\"请输入你想查找的零件的名称:\\n\"\n);\n    \nscanf\n(\n\"%s\"\n,cz_mc);\n    \n    jd* p =g_pHead;\n    \nwhile\n(p!=\nNULL\n)\n    {\n        \nif\n(\nstrcmp\n(p->lj.mc,cz_mc)==\n0\n)\n        {\n            \nreturn\n p;\n        }\n        \n        p=p->pnext; \n    }\n    \nreturn\n \nNULL\n; \n}\n\n\nvoid\n \nxg\n()\n\n\n{\n    \nchar\n xg_bh[\n20\n];\n    \nprintf\n(\n\"请输入需要修改的零部件的采购编号\\n\"\n);\n    \nscanf\n(\n\"%s\"\n,xg_bh);\n    \n    jd* p=g_pHead;\n    \nwhile\n(p!=\nNULL\n)\n    {\n        \nif\n(\nstrcmp\n(p->lj.bh,xg_bh)==\n0\n) \n//p->li.bh与xg_bh不能用等号比较 \n\n        {\n            \nprintf\n(\n\"请输入修改后的零部件名称:\\n\"\n);\n            \nscanf\n(\n\"%s\"\n,p->lj.mc);\n            \nprintf\n(\n\"修改成功\\n\"\n);\n            \nsystem\n(\n\"pause\"\n);\n            \nbreak\n;\n        }\n        p = p->pnext;\n    }\n    \n    \nif\n(p == \nNULL\n)\n    {\n        \nprintf\n(\n\"未能找到此采购编号对应零部件，请检查编号\\n\"\n); \n        \nsystem\n(\n\"pause\"\n);\n    }\n}\n\n\nvoid\n \nt_sc\n()\n\n\n{\n    jd* p1;\n    \nchar\n sc_bh[\n20\n];\n    \nprintf\n(\n\"请输入你所想要删除的零部件的编号:\"\n);\n    \nscanf\n(\n\"%s\"\n,sc_bh);\n    \n    \n//如果是头结点 \n\n    \nif\n(\nstrcmp\n(g_pHead->lj.bh,sc_bh)==\n0\n)  \n    {\n        p1 = g_pHead;            \n//备份头结点 \n\n        g_pHead = g_pHead->pnext;\n// 将头结点指向下一个结点 \n\n        \nfree\n(p1); \n//删除就是释放这段内存 ,p1被赋予了头结点，但是头结点已经指向下一个结点 \n\n        \nprintf\n(\n\"恭喜，删除成功\\n\"\n);\n        \nsystem\n(\n\"pause\"\n);\n        \nreturn\n;\n    }\n    \n    \nelse\n\n    {\n        \nprintf\n(\n\"对不起，删除失败，请检查你输入的编号\\n\"\n);\n        \nsystem\n(\n\"pause\"\n);\n        \nreturn\n;\n    }\n}\n\n\nvoid\n \nft_sc\n()\n\n\n{\n    \n//如果不是头结点\n\n    \nchar\n sc1_bh[\n20\n];\n    \nprintf\n(\n\"请输入你所想要删除的零部件的编号:\"\n);\n    \nscanf\n(\n\"%s\"\n,sc1_bh);\n    jd* p = g_pHead;\n    jd* p2;                  \n//p2是备份的 \n\n    \nwhile\n(p2->pnext != \nNULL\n)\n    {\n        \nif\n(\nstrcmp\n(p->pnext->lj.bh,sc1_bh)==\n0\n)\n        {\n            p2 = p->pnext;             \n//备份头结点 \n\n            p->pnext = p->pnext->pnext;\n//中间结点(要删除的结点)的上一个结点是头结点，头结点的下一个结点是中间节点的后一个结点 ，把中间结点指向第三个结点 \n\n            \nfree\n(p2);\n        }\n        \n        \nif\n(p->pnext == \nNULL\n) \n//中间结点已删除.  NULL会警告，'0'不会 ，char变量和指针变量不能比较 \n\n        {\n            \nprintf\n(\n\"恭喜，成功删除\\n\"\n);\n            \nsystem\n(\n\"pause\"\n);\n            \nreturn\n;\n        } \n        \n        p = p->pnext;\n        \n        \nif\n(p->pnext == \nNULL\n)\n//跳出循环，表示零件不存在\n\n        {\n            \nprintf\n(\n\"对不起，删除失败，请检查你输入的编号\\n\"\n);\n            \nsystem\n(\n\"pause\"\n);\n            \nreturn\n;\n        }         \n    }\n\n}\n\n\n", "Tag": "算法分析"}
{"Answer": "#include <cstdio>\n\nint main() {\n    for (int a = 1; a <= 9; a++) {\n        for (int b = 1; b <= 9; b++) {\n            if (b == a) continue;\n            for (int c = 1; c <= 9; c++) {\n                if (c == a || c == b) continue;\n                int abc = a * 100 + b * 10 + c;\n                int def = abc * 2;\n                int ghi = abc * 3;\n                if (ghi > 987) break;  // ghi 最大只能是 987\n                int d = def / 100, e = def / 10 % 10, f = def % 10;\n                int g = ghi / 100, h = ghi / 10 % 10, i = ghi % 10;\n                if (d != e && d != f && d != g && d != h && d != i &&\n                    e != f && e != g && e != h && e != i &&\n                    f != g && f != h && f != i &&\n                    g != h && g != i && h != i) {\n                        printf(\"%d %d %d\\n\", abc, def, ghi);\n                }\n            }\n        }\n    }\n    return 0;\n}\n\n", "Konwledge_Point": "算法与数字", "Question": "c++排列组合刘汝佳紫书\n题目：用1,2，3，…，9组成3个数abc,def和ghi，每个数字恰好用一次，要求abc：def:ghi=1:2:3。按照\"abc def ghi\"的格式输出所有解，每行一个解\n下面是我的解答代码，但是遗漏了一个输出 267 534 801\n\n\n#\ndefine\n _CRT_SECURE_NO_WARNINGS \n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\nint\n \nmain\n()\n \n{\n    \nauto\n i = \n0\n, j = i, k = j;\n    \nfor\n(i=\n1\n;i<=\n9\n;i++)\n        \nfor\n (j = \n1\n; j <= \n9\n; j++) {\n            \nfor\n (k = \n1\n; k <= \n9\n; k++) {\n                \nauto\n abc = i * \n100\n + j * \n10\n + k, def = \n2\n * abc, ghi = \n3\n * abc;\n                \nif\n (ghi >= \n1000\n)\ncontinue\n;\n                \nbool\n g[\n10\n]{ \nfalse\n };\n                g[i] = \ntrue\n; g[j] = \ntrue\n; g[k] = \ntrue\n;\n                g[def % \n10\n] = \ntrue\n; g[def % \n100\n / \n10\n] = \ntrue\n; g[def / \n100\n] = \ntrue\n;\n                g[ghi % \n10\n] = \ntrue\n; g[ghi % \n100\n / \n10\n] = \ntrue\n; g[ghi / \n100\n] = \ntrue\n;\n                \nauto\n flag = \ntrue\n;\n                \nfor\n (\nint\n q = \n1\n; q <= \n9\n; q++) {\n                    \nif\n (!g[q]) { flag = \nfalse\n;\n                    \nbreak\n;\n                    }\n                    \n                }\n                \nif\n (flag)\nprintf\n(\n\"%d %d %d\\n\"\n, abc, def, ghi);\n            }\n        }\n}\n\n", "Tag": "算法分析"}
{"Answer": "UPDATE ks_Card SET Card_ID = REPLACE(Emp_ID, 'A', '1') WHERE Emp_ID LIKE 'A%'; \nSELECT Employee_ID, Name FROM hr_EmployeeBase WHERE GetInDate BETWEEN '2010-04-01' AND '2010-04-30';\n\n", "Konwledge_Point": "算法与数字", "Question": "数据库服务器的问题。\n员工资料表 表名：hr_EmployeeBase 包含字段：(Employee_ID(员工编号), Name(姓名), GetInDate(录入日期))\n员工ID卡表 表名：ks_Card 包含字段：(Card_ID(卡号), Emp_ID(员工编号))\n说明：两个表用Emp_ID和Employee_ID关联\n1.写SQL查询，把所有员工编号是“A”开头的员工卡号更新为将字母“A”替换为数字“1”的员工编号（如员工编号为“A0001”的员工卡号要更新为“10001”）\n2.写SQL查询录用日期为2010年4月录用的员工", "Tag": "算法分析"}
{"Answer": "O(n)的：\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    int ans = 0;\n    for (int i = 0; i < (n - m + 1) / 2; ++i) {\n        for (int j = 0; j < m / 2; ++j) {\n            int x = a[i * m + j];\n            int y = a[(i + 1) * m - 1 - j];\n            ans += abs(x - y);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n\n", "Konwledge_Point": "算法与数字", "Question": "求一个C++ Problem 的解法\n小H觉得回文数字是非常美的，但是现实中遇到的数字串并非全部都是回文，因此小H要将连续若干个数变成回文，例如[2 4 6 4 3]，最少改变数字数量1个，即2改成3或3改成2。但是仅仅这么算作为第四题太简单了，因此要加大难度。出题人除了给你n个数ai外，还给了你一个奇数m。由经验可知n个数可以划分出n-m+1个子串（每个子串个数为m），现在需要你计算出每个子串都转换为回文的变化总次数。当然为了加深小H对题目的理解，出题者对样例进行如下解释，\n例如样例中可以生成4个子串，其中第一个子串[2 3 9 3 6]需要变化1次，第二个子串[3 9 3 6 3]需要变化次数为1，第三个子串[9 3 6 3 9]需要变化次数为0，[3 6 3 9 7]需要变化次数为2。所以答案就是1+1+0+2=4。\n输入\n第一行输入n和m。\n第二行输入n个整数ai。\n输出\n输出所有子串变成回文的变化次数之和\n样例输入\n8 5\n2 3 9 3 6 3 9 7\n样例输出\n4\n数据规模：\n70%数据 n<=300\n100%数据 1<=m<=n<=10^6 (m保证为奇数) 1<=ai<=10^6\n\n\nO(nm) 的会超时", "Tag": "算法分析"}
{"Answer": "算法思路：\n首先判断字符串s是否为回文串，如果是，则s本身就是特殊的回文子串，直接返回s的长度；如果s不是回文串，则遍历s中的每个字符，以该字符为中心向两侧扩展，寻找最长的回文子串，记为s1；对于s1的每个字符，将其和其它字符交换后再次判断是否为回文串，如果是，则更新最长的特殊回文子串的长度。\nC语言实现：\n#include <stdio.h>\n#include <string.h>\n\nint is_palindrome(char *s, int start, int end) {\n    while (start < end) {\n        if (s[start] != s[end]) {\n            return 0;\n        }\n        start++;\n        end--;\n    }\n    return 1;\n}\n\nint longest_special_palindrome(char *s) {\n    int n = strlen(s);\n    int max_len = 0;\n\n    /* 判断s本身是否为回文串 */\n    if (is_palindrome(s, 0, n - 1)) {\n        return n;\n    }\n\n    /* 以每个字符为中心向两侧扩展 */\n    for (int i = 0; i < n; i++) {\n        int len = 1;\n        while (i - len >= 0 && i + len < n && s[i - len] == s[i + len]) {\n            len++;\n        }\n        if (len > 1) {\n            /* 对于每个回文子串，交换其中的字符判断是否为特殊回文子串 */\n            for (int j = i - len + 1; j <= i + len - 1; j++) {\n                for (int k = j + 1; k <= i + len - 1; k++) {\n                    char tmp = s[j];\n                    s[j] = s[k];\n                    s[k] = tmp;\n                    if (is_palindrome(s, i - len + 1, i + len - 1)) {\n                        max_len = len;\n                    }\n                    /* 恢复原来的字符串 */\n                    tmp = s[j];\n                    s[j] = s[k];\n                    s[k] = tmp;\n                }\n            }\n        }\n    }\n\n    return max_len;\n}\n\nint main() {\n    char s[100];\n    scanf(\"%s\", s);\n    int len = longest_special_palindrome(s);\n    printf(\"%d\\n\", len);\n    return 0;\n}\n\n时间复杂度：$O(n^3)$，其中$n$为字符串s的长度。", "Konwledge_Point": "算法与数字", "Question": "特殊的回文子串C语言\n给定一个字符串s,s中只包含数字,请返回s中最长的特殊的回文子串的长度\n特殊的回文子串t满足\nt进行任何次交换后可以变成一个回文字符申\n输入格式：\n输入第一行包含一个字符串s\n输出格式：\n特殊的回文子串的最长长度\n\n\n有无给个正确算法", "Tag": "算法分析"}
{"Answer": "chatgpt:下面是完整的C语言代码实现：\n#include <stdio.h>\n\nint main() {\n    int para[4][2] = {{5, 7}, {7, 9}, {4, 10}, {12, 17}};\n    int threshold = 10;\n    int min_sum = 2 * threshold;\n    int min_idx = -1;\n    for (int i = 0; i < 4; i++) {\n        for (int j = i + 1; j < 4; j++) {\n            int sum = para[i][0] + para[j][0];\n            if (sum > threshold && sum < min_sum) {\n                min_sum = sum;\n                min_idx = i * 10 + j;\n            }\n        }\n    }\n    if (min_idx == -1) {\n        printf(\"No suitable combination found.\\n\");\n    } else {\n        int idx1 = min_idx / 10;\n        int idx2 = min_idx % 10;\n        printf(\"Combination: %c+%c\\n\", 'A' + idx1, 'A' + idx2);\n        printf(\"Result: %d,%d\\n\", min_sum, para[idx1][1] + para[idx2][1]);\n    }\n    return 0;\n}\n\n\n\n代码中的para数组表示参数的属性值，threshold表示门槛值，min_sum表示第一个参数之和最小的组合的第一个参数之和，min_idx表示第一个参数之和最小的组合在para数组中的下标，-1表示没有找到符合条件的组合。在代码中，使用了两个循环来遍历所有可能的组合，对于每个组合，计算第一个参数之和sum，并检查sum是否满足要求。如果满足，就更新min_sum和min_idx。最后，判断min_idx是否为-1，如果是，则输出提示信息；否则，计算出组合中每个参数的下标，输出组合和结果。注意：本代码中假设参数个数为4，如果参数个数增加，需要相应地修改代码", "Konwledge_Point": "算法与数字", "Question": "求一个排列组合优选程序的编程思路\n问题如下：\n假设每个参数有两个属性值，例如：\n参数A（5，7）\n参数B（7，9）\n参数C（4，10）\n参数D（12，17）\n现在有一个门槛值E，求第一个参数之和大于门槛值，且小于门槛值2倍的情况下，同时第二个参数之和最小的组合。\n比如门槛值E为10。\n那么门槛区间为10~20。\n那么满足门槛区间值要求的组合有：\nA+B+C（16），A+B（12），A+D（17），B+C（11）,B+D（19）, C+D（16），D（12） ，共有7个组合。\n对应的第二个参数值之和为：\n26（A+B+C）,16（A+B），24(A+D)，19（B+C），26(B+D)，27（C+D）, 17（D），这里面第二个组合A+B的第二个参数和最小（16）。\n所以应该筛选输出A+B这对组合结果（即12,16）以及组合组成（即A+B）。\n\n\n之前尝试用数组操作的方式解决，但是发现在数组中如果出现重复数字，例如A+B组合为12，D也为12，即无法识别该数字的组合来源。\n\n\n所以现在没有解决思路了，想看下各位有没有什么思路。谢谢！", "Tag": "算法分析"}
{"Answer": "参考GPT和自己的思路：\n原因是注释标注里的if语句没有返回值。求解代码如下：", "Konwledge_Point": "算法与数字", "Question": "关于#c++#的问题，买不到的数目\n买不到的数目\n小明开了一家糖果店。\n他别出心裁：把水果糖包成4颗一包和7颗一包的两种。\n糖果不能拆包卖。\n小朋友来买糖的时候，他就用这两种包装来组合。\n当然有些糖果数目是无法组合出来的，比如要买 10 颗糖。\n你可以用计算机测试一下，在这种包装情况下，最大不能买到的数量是17。\n大于17的任何数字都可以用4和7组合出来。\n本题的要求就是在已知两个包装的数量时，求最大不能组合出的数字。\n\n\n输入格式：\n两个正整数 n,m，表示每种包装中糖的颗数。\n输出格式：\n一个正整数，表示最大不能买到的糖数。\n\n\n数据范围\n2≤n,m≤1000 保证数据一定有解。\n\n\n输入样例：\n4 7\n输出样例：\n17\n\n\n\n```c++\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\nbool\n \ndfs\n(\nint\n i, \nint\n n, \nint\n m)\n \n{\n    \nif\n (i == \n0\n) \nreturn\n \ntrue\n;\n    \n/*if (i >= n) dfs(i - n, n, m);//注释里的为什么错了?\n    if (i >= m) dfs(i - m, n, m);*/\n\n    \nif\n (i >= n && \ndfs\n(i - n, n, m))  \nreturn\n \ntrue\n;\n    \nif\n (i >= m && \ndfs\n(i - m, n, m))  \nreturn\n \ntrue\n;\n    \nreturn\n \nfalse\n;\n}\n\nint\n \nmain\n()\n \n{\n    \nint\n n, m,res=\n0\n;\n    \nscanf\n(\n\"%d %d\"\n, &n, &m);\n    \nfor\n (\nint\n i = \n1\n; i < \n1000\n; i++) {\n        \nif\n (\ndfs\n(i, n, m) == \nfalse\n) res = i;\n    }\n    \nprintf\n(\n\"%d\"\n, res);\n    \nreturn\n \n0\n;\n}\n\n\n\n\n求解答注释里的为什么错了?", "Tag": "算法分析"}
{"Answer": "因为 参数需要两个String类型的      System.currentTimeMills()是Long类型 +“”可以转成String类型", "Konwledge_Point": "算法与数字", "Question": "读程序时候不理解一个地方。。。求解答\nCookie cookie=new Cookie（\"lastTime\",System.currentTimeMillis()+\"\"）;\n\n后面为什么要加\"\"啊  有什么特殊的含义或者用法吗", "Tag": "算法分析"}
{"Answer": "你排序传参列表时应该用 array.copy()复制下列表不然.上一个排序算法把列表排序了之后,下一个排序算法再排序时这个列表已经是排序好的了，这样计算时间就不准确了\nresult = sort(array)  #加上.copy()\n\n改成\nresult = sort(array.copy())\n\n对于已经排序好的数组再用快速排序时, 因为快速排序中是用数组第一个值作为中心数,这样中心数都是最小值，造成了递归层级非常多,列表长度4000,就要递归4000层,你就是设置了sys.setrecursionlimit(100000)递归栈的最大也只能到3000多层, 到达递归最大层数时就会因为递归栈溢出而出错,停止程序.\n\n如有帮助，请点击我的回答下方的【采纳该答案】按钮帮忙采纳下，谢谢!\n", "Konwledge_Point": "算法与数字", "Question": "python中变化数字列表长度，统计不同排序算法时间中，def计算时间的函数后，为什么当列表大于4000时就不运行了\n\n\npython中变化数字列表长度，统计不同排序算法时间中，def计算时间的函数后，为什么当列表大于4000时就不运行了，而且为什么使用count-time时，insertionsort的运行时间为0", "Tag": "算法分析"}
{"Answer": "小心0+0", "Konwledge_Point": "算法与数字", "Question": "编写两百位以内数字的加法的算法时出现了奇怪的问题\n我在编写一个有关两百位以内数字的加法的算法。编完之后，我发现我的算法出现了很奇怪的问题。比如这种，66+99=651.\n我发现我应该出现在的百分位的数出现在了个位。如果运算的过程中不出现进位的话，最后一位就会变成0 。就比如22+33=550 。我检查了三个小时，实在没有找到为什么会这样，不知是否有老哥有空愿意解答一下，真的万分感谢！(；へ：)\n\n\n\n\n#include\n\n\n#include\n\n\n#include\n\n\n#include\n\n\nusing\n namespace std;\n\n\n\n\nint\n main()\n{\n    \nint\n a_length = \n0\n, b_length = \n0\n;\n    \nint\n temp0=\n0\n;\n\n    \nint\n t1=\n0\n, t2=\n0\n, t3=\n0\n, t4=\n0\n,t5=\n0\n,t6=\n0\n;//这相当于一些临时变量，用于传递值\n\n    string \ntemp\n;\n    string a , b;\n    cin >> a >> b;\n    a_length = a.length();\n    b_length = b.length();\n    \n    \nif\n (a_length < b_length)\n    {\n        \ntemp\n = a;\n        a = b;\n        b = \ntemp\n;\n        temp0 = a_length;\n        a_length = b_length;\n        b_length = temp0;\n    }\n\n\n    reverse(a.\nbegin\n(), a.\nend\n());\n    reverse(b.\nbegin\n(), b.\nend\n());\n    a[a_length] = \n'0'\n;\n    b[b_length] = \n'0'\n;\n\n    \nfor\n (\nint\n i=\n0\n;i<=b_length;i++)\n    {\n        t1 = (\nint\n)a[i]\n-48\n;\n        t2 = (\nint\n)b[i]\n-48\n;\n\n        \nfor\n (;;)\n        {\n            \nif\n (t1 + t2+t3 > \n9\n)\n            {\n                t5 = (t1 + t2+t3) % \n10\n;\n                t6 = (t1 + t2+t3) / \n10\n;\n                a[i] = (\nchar\n)(t5 + \n48\n);\n                ++i;\n                t1 = (\nint\n)a[i] - \n48\n;\n                t2 = (\nint\n)b[i] - \n48\n;\n                t3 = t6;\n\n            }\n            \nelse\n\n            {\n                a[i] = (\nchar\n)(t1 + t2+t3 + \n48\n);\n                t3 = \n0\n;\n                break;\n            }\n        }\n    }\n\n    reverse(a.\nbegin\n(), a.\nend\n());\n    a_length = a.length();\n\n\n    \nfor\n (\nint\n i = \n0\n,w=\n0\n; i <= a_length; i++)\n    {\n        \nif\n (a[i] == \n'0'\n&&w==\n0\n)\n            \ncontinue\n;\n        \nelse\n\n        {\n            w = \n1\n;\n            cout << a[i];\n        }\n    }\n\n    a[\n0\n] = \n'a'\n;\n    b[\n0\n] = \n'b'\n;\n\n}\n\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "刚才复制没完全...\r\n\r\n```\r\n import java.util.*;\r\n\r\npublic class Test {\r\n\tpublic static void main(String[] args) {\r\n\t\tScanner in = new Scanner(System.in);\r\n\t\twhile (true) {\r\n\t\t\tSystem.out.println(\"=======猜拳游戏=====\");\r\n\t\t\tSystem.out.println(\"请出拳：(1.剪刀 2.石头 3.布)\");\r\n\t\t\tint number = in.nextInt();\r\n\t\t\tif (number > 3 || number < 1) {\r\n\t\t\t\tSystem.out.println(\"你出拳作弊，请重新合法出拳\");\r\n\t\t\t} else {\r\n\t\t\t\tint number1 = (int) ((Math.random() * 3) + 1);\r\n\t\t\t\tif (number == number1) {\r\n\t\t\t\t\tSystem.out.println(\"你出的是\" + getName(number) + \"\\t电脑出的是\" + getName(number1)\r\n\t\t\t\t\t\t\t+ \"\\t本局平局\");\r\n\t\t\t\t} else if (number < number1 || number==3&&number1==1) {\r\n\t\t\t\t\tSystem.out.println(\"你出的是\" + getName(number) + \"\\t电脑出的是\" + getName(number1)\r\n\t\t\t\t\t\t\t+ \"\\t本局你输\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tSystem.out.println(\"你出的是\" + getName(number) + \"\\t电脑出的是\" + getName(number1)\r\n\t\t\t\t\t\t\t+ \"\\t本局你赢\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static String getName(int n){\r\n\t\tString s = null;\r\n\t\tswitch(n){\r\n\t\tcase 1: s = \"剪刀\"; break;\r\n\t\tcase 2: s = \"石头\"; break;\r\n\t\tcase 3: s = \"布\"; break;\r\n\t\t}\r\n\t\treturn s;\r\n\t}\r\n}\r\n```", "Konwledge_Point": "算法与数字", "Question": "小白求助，猜拳游戏优化。\n该如何实现输出的是：你出的是剪刀 ，电脑出的布、这样的形式呢。我目前只能以数字 代替。\n\n代码如下：求大神指点、\n\nimport java.util.*;\n\npublic class A3_10{\n\n    public static void main(String[] args){\n\n        Scanner in=new Scanner(System.in);\n\n        while(true){\n\n            System.out.println(\"=======猜拳游戏=====\");\n\n            System.out.println(\"请出拳：(1.剪刀    2.石头     3.布)\");\n\n            int number=in.nextInt();\n\n            if(number>3||number<1){\n\n                System.out.println(\"你出拳作弊，请重新合法出拳\");\n\n            }else{\n\n                int number1=(int)((Math.random()*3)+1);\n\n                if(number==number1){\n\n                    System.out.println(\"你出的是\"+number+\"\\t电脑出的是\"+number1+\"\\t本局平局\");\n\n                }else if(number<number1){\n\n                    System.out.println(\"你出的是\"+number+\"\\t电脑出的是\"+number1+\"\\t本局你输\");\n\n                }else{\n\n                    System.out.println(\"你出的是\"+number+\"\\t电脑出的是\"+number1+\"\\t本局你赢\");\n\n                }\n\n            }\n\n        }\n\n    }\n\n}", "Tag": "算法分析"}
{"Answer": "你的click写错了\n", "Konwledge_Point": "算法与数字", "Question": "点击减号的按钮数字不进行减的算法\n\n\n可以点击+进行增加，减号不可以减一", "Tag": "算法分析"}
{"Answer": "可以考虑以下几种方法：（1）续期数字证书：在数字证书即将过期时，及时进行续期操作，以延长数字证书的有效期。这样可以保证数字证书的有效期与电子档案的保存期限相对应。需要注意的是，续期数字证书时应当确保其合法性和安全性，防止数字证书被冒用或篡改。（2）签署时间戳：在电子签名时，可以同时签署时间戳，以证明签名是在特定时间完成的。时间戳中包含了时间戳机构颁发的数字证书，因此即使原签名证书过期，时间戳依然可以验证签名的合法性，从而保证电子档案的长期可靠保存。需要注意的是，时间戳机构的可信度和稳定性也是需要考虑的因素。（3）保留数字证书私钥：在数字证书过期后，仍然保留数字证书的私钥，以便在需要时可以对电子文档进行验证。这种方法可以延长数字证书的有效期，但需要确保私钥的安全性，以免私钥被泄露或攻击。（4）使用长效数字证书：长效数字证书（Long-term Validity Certificate）是一种可以长期使用的数字证书，其有效期可以达到几十年或更长时间。这种数字证书的使用需要符合特定的安全标准和法律法规，同时需要确保证书的可信度和可靠性。", "Konwledge_Point": "算法与数字", "Question": "如何解决电子签名应用中数字证书有限服务期与电子档案长期保存的矛盾\n如何解决电子签名应用中数字证书有限服务期与电子档案长期保存的矛盾", "Tag": "算法分析"}
{"Answer": "```\r\nimport java.io.UnsupportedEncodingException;\r\n\r\npublic class HelloWorld {\r\n    public static String toOct(String s)\r\n    {\r\n        String result = \"\";\r\n\t\tbyte[] bytes = s.getBytes();\r\n\t\tfor (byte b : bytes)\r\n\t\t{\r\n\t\t\tint b1 = b;\r\n\t\t\tif (b1 < 0) b1 = 256 + b1;\r\n\t\t\tresult += \"\\\\\" + (b1 / 64) % 8 +  \"\" + (b1 / 8) % 8 + \"\" + b1 % 8;\r\n\t\t}\r\n        return result;\r\n    }\r\n\r\n    public static String getOct(String s) throws UnsupportedEncodingException\r\n    {\r\n\t\tString[] as = s.split(\"\\\\\\\\\");\r\n\t\tbyte[] arr = new byte[as.length - 1];\r\n\t\tfor (int i = 1; i < as.length; i++)\r\n\t\t{\r\n\t\t\tint sum = 0;\r\n            int base = 64;\r\n            for (char c : as[i].toCharArray())\r\n            {\r\n                sum += base * ((int)c - '0');\r\n                base /= 8;\r\n            }\r\n\t\t\tif (sum >= 128) sum = sum - 256;\r\n\t\t\tarr[i - 1] = (byte)sum;\r\n\t\t}\r\n        return new String(arr,\"UTF-8\"); //如果还有乱码，这里编码方式你可以修改下，比如试试看unicode gbk等等\r\n    }\r\n\r\n    public static void main(String[] args) throws java.io.UnsupportedEncodingException {\r\n        String s = \"123中文\";\r\n        String o = toOct(s);\r\n        System.out.println(o);\r\n        s = getOct(o);\r\n        System.out.println(s);\r\n    }\r\n}\r\n```\r\n\\061\\062\\063\\344\\270\\255\\346\\226\\207\r\n123中文", "Konwledge_Point": "算法与数字", "Question": "把8进制的字符串转化成汉字\n数据是这样的\"\\314\\251\\270\",得到就是这样的了，要把这个转换成汉字字符串", "Tag": "算法分析"}
{"Answer": "定义一个大小为n的数组，先将前n个数放到这个数组，求这个数组中的最小数，然后将最小数和后面的数比，如果后面的数比最小数大，那么将这个数替换数组中的最小数后，继续获取数组的最小数，循环上述步骤直至比完全部整数", "Konwledge_Point": "算法与数字", "Question": "关于#算法#的问题：则输出99.请设计并实现一算法，传入数字n即可输出第n个大的数(语言-c语言)\n有10个互不相同的整数： 99,200, 95、 87, 98、-12, 30, -87, 75,-25,不用排序，每当输入一个1-10之间的数n,即可输出第n个大的数", "Tag": "算法分析"}
{"Answer": "http://wenku.baidu.com/link?url=ZYix8_obOT37JUQyFv-t9Y0Sv7SPCIfmc5QwjW-aifxA8WJ4iWajKpfQS7o4aFykxKdIATLIwUY2WZKEnrezolAs3WcE-wczvNsF8qISD0u", "Konwledge_Point": "算法与数字", "Question": "如何在二分查找的程序中实现对某个具体的浮点型进行精确地查找的算法？\n如何在二分查找的程序中实现对某个具体的浮点型进行精确地查找的算法？是基于dat文件的存储的搜索，用什么方式进行？", "Tag": "算法分析"}
{"Answer": "import java.util.HashSet;\r\nimport java.util.Iterator;\r\nimport java.util.Set;\r\n\r\n\r\npublic class Test {\r\n\r\n\t\r\n\tpublic static void main(String[] args) {\r\n\t\tint i,j,k,m,n,t1,t2,t3;\r\n\t\tSet total=new HashSet();\r\n\t\tfor(int t=1;t<10;t++) {\r\n\t\t\ttotal.add(t);\r\n\t\t}\r\n\t\tSet set=new HashSet();\r\n\t\tSet lastThree=new HashSet();\r\n\t\tfor(i=1;i<4;i++) {\r\n\t\t\tset.add(i);\r\n\t\t\tfor(j=1;j<10;j++) {\r\n\t\t\t\tif(j==i){ continue;}\r\n\t\t\t\tset.add(j);\r\n\t\t\t\tfor(k=1;k<10;k++) {\r\n\t\t\t\t\tif(k==i||k==j) { continue;}\r\n\t\t\t\t\tset.add(k);\r\n\t\t\t\t\tm=3*(i*100+j*10+k);\r\n\t\t\t\t\tif(m>987){set.remove(k);continue;}//如果已超出范围，没必要再往下判断\r\n\t\t\t\t\tt1=m%10; if(t1==0) {set.remove(k);continue;} //个位数\r\n\t\t\t\t\tt2=(m%100)/10; if(t2==0) {set.remove(k);continue;} //十位数\r\n\t\t\t\t\tt3=m/100;  if(t3==0) {set.remove(k);continue;}//百位数\r\n\t\t\t\t\tif(set.contains(t1)){set.remove(k);continue;}\r\n\t\t\t\t\tset.add(t1);\r\n\t\t\t\t\tif(set.contains(t2)) {set.remove(k);set.remove(t1);continue;}\r\n\t\t\t\t\tset.add(t2);\r\n\t\t\t\t\tif(set.contains(t3)) {set.remove(k);set.remove(t1);set.remove(t2);continue;}\r\n\t\t\t\t\tset.add(t3);\r\n\t\t\t\t\t//System.out.println(\"  \"+i+j+k+\"   \"+m);\r\n\t\t\t\t\ttotal.removeAll(total);\r\n\t\t\t\t\tfor(int q=1;q<10;q++) {\r\n\t\t\t\t\t\ttotal.add(q);\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttotal.removeAll(set);\r\n                    int[] s=new int[3];\r\n                    Iterator iterator=total.iterator();\r\n                    int p=0;\r\n                    while(iterator.hasNext()) {\r\n                    \ts[p]=Integer.parseInt(iterator.next()+\"\");\r\n                    \tp++;\r\n                    }\r\n                    n=s[0]*100+s[1]*10+s[2];   \r\n                    if(n==2*(i*100+j*10+k)) { System.out.println(i+\"\"+j+\"\"+k+\"    \"+n+\"    \"+m);}\r\n                    n=s[0]*100+s[2]*10+s[1];    \r\n                    if(n==2*(i*100+j*10+k)) { System.out.println(i+\"\"+j+\"\"+k+\"    \"+n+\"    \"+m);}\r\n                    n=s[1]*100+s[0]*10+s[2];   \r\n                    if(n==2*(i*100+j*10+k)) { System.out.println(i+\"\"+j+\"\"+k+\"    \"+n+\"    \"+m);}\r\n                    n=s[1]*100+s[2]*10+s[0]; \r\n                    if(n==2*(i*100+j*10+k)) { System.out.println(i+\"\"+j+\"\"+k+\"    \"+n+\"    \"+m);}\r\n                    n=s[2]*100+s[0]*10+s[1]; \r\n                    if(n==2*(i*100+j*10+k)) { System.out.println(i+\"\"+j+\"\"+k+\"    \"+n+\"    \"+m);}\r\n                    n=s[2]*100+s[1]*10+s[0]; \r\n                    if(n==2*(i*100+j*10+k)) { System.out.println(i+\"\"+j+\"\"+k+\"    \"+n+\"    \"+m);}\r\n                    set.remove(t1);\r\n                    set.remove(t2);\r\n                    set.remove(t3);\r\n                    set.remove(k);\r\n\t\t\t\t} \r\n\t\t\t\t   set.remove(j);\r\n\t\t\t}\r\n\t\t\tset.remove(i);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n运行结果：\r\n192    384    576\r\n219    438    657\r\n273    546    819\r\n327    654    981\r\n\r\n我的思想是，第一个数百位数最大为3，可谓一层循环，十位和各位则组成两层循环。\r\n用一个Set容器来存储第一个三位数，利用第一个数求出第三个数（3倍第一个数），把第三个数的每一位求出，看是否符合，符合则加入set容器，而这时只剩下三个数，对这三个数的六种情况求解，等于第一个数的两倍即成立。很麻烦，思想很简单", "Konwledge_Point": "算法与数字", "Question": "一道java面试题目\n给出下题的算法(Java语言实现)\n\n将1、2、3、4、5、6、7、8、9 这九个数字分成三个百位数，每个数字用且只用一次，\n\n并且第三个数字是第一个的3倍，第二个数字是第一个的2倍。\n\n求三个数。[说明，结果可能多于一组，例如327  654  981]\n\n这个是看到一家公司的面试题目，想了一下还没有找到什么好的方法来解决。\n\n请各位帮下忙。", "Tag": "算法分析"}
{"Answer": "（1）你的pp函数逻辑不对，只能判断末尾还有0/1/2/9的数，其他位置的不能判断（2）printlen中输出的不应该是bb，应该是bb.pp()运行结果：\n\n代码修改如下：\npackage test;\n\npublic class LanQiaoBei {\n\n    int p;\n\n    public void setP(int p) {\n        this.p = p;\n    }\n     \n    int pp() {\n        int i,j=0,t,sum=0,k=0;\n        int s[]=new int[40];\n        for(i=1;i<=p;i++) {\n            t = i;\n            while(t!=0){ //这里判断i中是否包含 0 1 2 9这几个数字中的任意一个\n                int mm = t%10; //逐个取数字的末尾数\n                t/=10; //数字除以10，跟上一句配合使用，假如 t = i = 12; mm=t%10=2，t=t/10=1，下一次循环的时候 mm=t%10=1，这样能得到数字i各个位上的所有数字\n                if(mm==0 || mm==1 || mm==2 || mm==9){\n                    s[k++] = i;\n                    break;\n                }\n            }\n        }\n       for(t=0;t<k;t++) {\n             sum=sum+s[t];\n       }\n         return sum;\n    }\n    public static void main(String[] args){\n    LanQiaoBei bb=new LanQiaoBei();\n    bb.setP(40);\n    //bb.pp();\n    System.out.println(bb.pp());\n    }\n\n}\n\n\n", "Konwledge_Point": "算法与数字", "Question": "java算法求和，我的运行结果不对，求解答\n我的问题：\n\n\n我写的代码：\npublic class LanQiaoBei {\n   int i,p,t,sum=0;\n   int s[]=new int[40];\n\n\npublic void setP(\nint\n p) {\n    this.p = p;\n}\n\n\nint\n pp() {\n   for(i=\n1\n;i<=p;i++) {    \n        \nif\n(i%\n10\n==\n0\n||i%\n10\n==\n1\n||i%\n10\n==\n2\n||i%\n10\n==\n9\n) {                    \n            for(\nt\n=\n0\n;\nt\n<p;\nt\n++) {\n                s[\nt\n]=i;\n            }                \n     \n     }\n        }\n   for(\nt\n=\n0\n;\nt\n<s.length;\nt\n++) {\n         \nsum\n=\nsum\n+s[\nt\n];\n   }\n     return \nsum\n;\n\n\n\n   }\n   public static void main(String[] args){\n       LanQiaoBei bb=new LanQiaoBei();\n       bb.setP(40);\n       bb.pp();\n       System.out.println(bb);\n}\n}\n我的运行结果：LanQiaoBei\n@2f92e0f4\n我想要的结果是问题的和，应该是一个整数。", "Tag": "算法分析"}
{"Answer": "#include <iostream>\n#include <stack>\n#include <string>\n\nusing namespace std;\n\n// 运算符优先级，数值越大，优先级越高\nint priority(char c)\n{\n    if (c == '+' || c == '-')\n        return 1;\n    else if (c == '*' || c == '/')\n        return 2;\n    else\n        return 0;\n}\n\nint main()\n{\n    // 运算数栈\n    stack<int> opnd;\n    // 运算符栈\n    stack<char> optr;\n    char c;\n    cin >> c;\n    while (c != '$')\n    {\n        // 如果是数字，直接输出\n        if (isdigit(c))\n            cout << c << ' ';\n        else if (c == '(')\n            optr.push(c);\n        else if (c == ')')\n        {\n            while (optr.top() != '(')\n            {\n                cout << optr.top() << ' ';\n                optr.pop();\n            }\n            optr.pop(); // 将'('弹出但不输出\n        }\n        else\n        {\n            // 如果当前运算符的优先级小于等于栈顶运算符的优先级，则将栈顶运算符弹出并输出\n            while (!optr.empty() && priority(c) <= priority(optr.top()))\n            {\n                cout << optr.top() << ' ';\n                optr.pop();\n            }\n            optr.push(c);\n        }\n\n        cin >> c;\n    }\n\n    // 将剩余的运算符依次弹出并输出\n    while (!optr.empty())\n    {\n        cout << optr.top() << ' ';\n        optr.pop();\n    }\n\n    return 0;\n}\n", "Konwledge_Point": "算法与数字", "Question": "输入算数表达式，计算出该表达式的逆波兰表达式\n从键盘上输入一个算数表达式，试编写算法，计算出该表达式的逆波兰表达式。规定：逆波兰表达式的长度不超过一行，以$符作为输入结束，操作数之间用空格分隔,操作符只可能有+、-、\n、/四种运算。(注释要详细)\n例1：输入为：2+3$，输出逆波兰表达式为：2 3 +。\n例2：输入为：2\n3$，输出逆波兰表达式为：2 3 \n。\n例3：输入为：1+2\n3$，输出逆波兰表达式为：1 2 3 * +。\n例4：输入为：（1+2)\n3$，输出逆波兰表达式为：1 2 + 3 \n。\n例5：输入为：（1+2\n3）\n4$，输出逆波兰表达式为：1 2 3 * + 4 \n。\n例6：输入为：6\n((5+(2+3)*8)+3)$，输出逆波兰表达式为：6 5 2 3 + 8 * + 3 + *。\n提示1：括号成对，输出运算符；否则，输出数字。\n提示2：求逆波兰表达式规则如下：设立运算数栈OPND，对表达式从左到右扫描(读入)，当表达式中扫描到数时，压入OPND栈。当扫描到运算符时，从OPND退出两个数，进行相应运算，结果再压入OPND栈。这个过程一直不断运行直至表达式结束符$。", "Tag": "算法分析"}
{"Answer": "因为 参数需要两个String类型的      System.currentTimeMills()是Long类型 +“”可以转成String类型", "Konwledge_Point": "算法与数字", "Question": "读程序时候不理解一个地方。。。求解答\nCookie cookie=new Cookie（\"lastTime\",System.currentTimeMillis()+\"\"）;\n\n后面为什么要加\"\"啊  有什么特殊的含义或者用法吗", "Tag": "算法分析"}
{"Answer": "你排序传参列表时应该用 array.copy()复制下列表不然.上一个排序算法把列表排序了之后,下一个排序算法再排序时这个列表已经是排序好的了，这样计算时间就不准确了\nresult = sort(array)  #加上.copy()\n\n改成\nresult = sort(array.copy())\n\n对于已经排序好的数组再用快速排序时, 因为快速排序中是用数组第一个值作为中心数,这样中心数都是最小值，造成了递归层级非常多,列表长度4000,就要递归4000层,你就是设置了sys.setrecursionlimit(100000)递归栈的最大也只能到3000多层, 到达递归最大层数时就会因为递归栈溢出而出错,停止程序.\n\n如有帮助，请点击我的回答下方的【采纳该答案】按钮帮忙采纳下，谢谢!\n", "Konwledge_Point": "算法与数字", "Question": "python中变化数字列表长度，统计不同排序算法时间中，def计算时间的函数后，为什么当列表大于4000时就不运行了\n\n\npython中变化数字列表长度，统计不同排序算法时间中，def计算时间的函数后，为什么当列表大于4000时就不运行了，而且为什么使用count-time时，insertionsort的运行时间为0", "Tag": "算法分析"}
{"Answer": "小心0+0", "Konwledge_Point": "算法与数字", "Question": "编写两百位以内数字的加法的算法时出现了奇怪的问题\n我在编写一个有关两百位以内数字的加法的算法。编完之后，我发现我的算法出现了很奇怪的问题。比如这种，66+99=651.\n我发现我应该出现在的百分位的数出现在了个位。如果运算的过程中不出现进位的话，最后一位就会变成0 。就比如22+33=550 。我检查了三个小时，实在没有找到为什么会这样，不知是否有老哥有空愿意解答一下，真的万分感谢！(；へ：)\n\n\n\n\n#include\n\n\n#include\n\n\n#include\n\n\n#include\n\n\nusing\n namespace std;\n\n\n\n\nint\n main()\n{\n    \nint\n a_length = \n0\n, b_length = \n0\n;\n    \nint\n temp0=\n0\n;\n\n    \nint\n t1=\n0\n, t2=\n0\n, t3=\n0\n, t4=\n0\n,t5=\n0\n,t6=\n0\n;//这相当于一些临时变量，用于传递值\n\n    string \ntemp\n;\n    string a , b;\n    cin >> a >> b;\n    a_length = a.length();\n    b_length = b.length();\n    \n    \nif\n (a_length < b_length)\n    {\n        \ntemp\n = a;\n        a = b;\n        b = \ntemp\n;\n        temp0 = a_length;\n        a_length = b_length;\n        b_length = temp0;\n    }\n\n\n    reverse(a.\nbegin\n(), a.\nend\n());\n    reverse(b.\nbegin\n(), b.\nend\n());\n    a[a_length] = \n'0'\n;\n    b[b_length] = \n'0'\n;\n\n    \nfor\n (\nint\n i=\n0\n;i<=b_length;i++)\n    {\n        t1 = (\nint\n)a[i]\n-48\n;\n        t2 = (\nint\n)b[i]\n-48\n;\n\n        \nfor\n (;;)\n        {\n            \nif\n (t1 + t2+t3 > \n9\n)\n            {\n                t5 = (t1 + t2+t3) % \n10\n;\n                t6 = (t1 + t2+t3) / \n10\n;\n                a[i] = (\nchar\n)(t5 + \n48\n);\n                ++i;\n                t1 = (\nint\n)a[i] - \n48\n;\n                t2 = (\nint\n)b[i] - \n48\n;\n                t3 = t6;\n\n            }\n            \nelse\n\n            {\n                a[i] = (\nchar\n)(t1 + t2+t3 + \n48\n);\n                t3 = \n0\n;\n                break;\n            }\n        }\n    }\n\n    reverse(a.\nbegin\n(), a.\nend\n());\n    a_length = a.length();\n\n\n    \nfor\n (\nint\n i = \n0\n,w=\n0\n; i <= a_length; i++)\n    {\n        \nif\n (a[i] == \n'0'\n&&w==\n0\n)\n            \ncontinue\n;\n        \nelse\n\n        {\n            w = \n1\n;\n            cout << a[i];\n        }\n    }\n\n    a[\n0\n] = \n'a'\n;\n    b[\n0\n] = \n'b'\n;\n\n}\n\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "刚才复制没完全...\r\n\r\n```\r\n import java.util.*;\r\n\r\npublic class Test {\r\n\tpublic static void main(String[] args) {\r\n\t\tScanner in = new Scanner(System.in);\r\n\t\twhile (true) {\r\n\t\t\tSystem.out.println(\"=======猜拳游戏=====\");\r\n\t\t\tSystem.out.println(\"请出拳：(1.剪刀 2.石头 3.布)\");\r\n\t\t\tint number = in.nextInt();\r\n\t\t\tif (number > 3 || number < 1) {\r\n\t\t\t\tSystem.out.println(\"你出拳作弊，请重新合法出拳\");\r\n\t\t\t} else {\r\n\t\t\t\tint number1 = (int) ((Math.random() * 3) + 1);\r\n\t\t\t\tif (number == number1) {\r\n\t\t\t\t\tSystem.out.println(\"你出的是\" + getName(number) + \"\\t电脑出的是\" + getName(number1)\r\n\t\t\t\t\t\t\t+ \"\\t本局平局\");\r\n\t\t\t\t} else if (number < number1 || number==3&&number1==1) {\r\n\t\t\t\t\tSystem.out.println(\"你出的是\" + getName(number) + \"\\t电脑出的是\" + getName(number1)\r\n\t\t\t\t\t\t\t+ \"\\t本局你输\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tSystem.out.println(\"你出的是\" + getName(number) + \"\\t电脑出的是\" + getName(number1)\r\n\t\t\t\t\t\t\t+ \"\\t本局你赢\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static String getName(int n){\r\n\t\tString s = null;\r\n\t\tswitch(n){\r\n\t\tcase 1: s = \"剪刀\"; break;\r\n\t\tcase 2: s = \"石头\"; break;\r\n\t\tcase 3: s = \"布\"; break;\r\n\t\t}\r\n\t\treturn s;\r\n\t}\r\n}\r\n```", "Konwledge_Point": "算法与数字", "Question": "小白求助，猜拳游戏优化。\n该如何实现输出的是：你出的是剪刀 ，电脑出的布、这样的形式呢。我目前只能以数字 代替。\n\n代码如下：求大神指点、\n\nimport java.util.*;\n\npublic class A3_10{\n\n    public static void main(String[] args){\n\n        Scanner in=new Scanner(System.in);\n\n        while(true){\n\n            System.out.println(\"=======猜拳游戏=====\");\n\n            System.out.println(\"请出拳：(1.剪刀    2.石头     3.布)\");\n\n            int number=in.nextInt();\n\n            if(number>3||number<1){\n\n                System.out.println(\"你出拳作弊，请重新合法出拳\");\n\n            }else{\n\n                int number1=(int)((Math.random()*3)+1);\n\n                if(number==number1){\n\n                    System.out.println(\"你出的是\"+number+\"\\t电脑出的是\"+number1+\"\\t本局平局\");\n\n                }else if(number<number1){\n\n                    System.out.println(\"你出的是\"+number+\"\\t电脑出的是\"+number1+\"\\t本局你输\");\n\n                }else{\n\n                    System.out.println(\"你出的是\"+number+\"\\t电脑出的是\"+number1+\"\\t本局你赢\");\n\n                }\n\n            }\n\n        }\n\n    }\n\n}", "Tag": "算法分析"}
{"Answer": "你的click写错了\n", "Konwledge_Point": "算法与数字", "Question": "点击减号的按钮数字不进行减的算法\n\n\n可以点击+进行增加，减号不可以减一", "Tag": "算法分析"}
{"Answer": "可以考虑以下几种方法：（1）续期数字证书：在数字证书即将过期时，及时进行续期操作，以延长数字证书的有效期。这样可以保证数字证书的有效期与电子档案的保存期限相对应。需要注意的是，续期数字证书时应当确保其合法性和安全性，防止数字证书被冒用或篡改。（2）签署时间戳：在电子签名时，可以同时签署时间戳，以证明签名是在特定时间完成的。时间戳中包含了时间戳机构颁发的数字证书，因此即使原签名证书过期，时间戳依然可以验证签名的合法性，从而保证电子档案的长期可靠保存。需要注意的是，时间戳机构的可信度和稳定性也是需要考虑的因素。（3）保留数字证书私钥：在数字证书过期后，仍然保留数字证书的私钥，以便在需要时可以对电子文档进行验证。这种方法可以延长数字证书的有效期，但需要确保私钥的安全性，以免私钥被泄露或攻击。（4）使用长效数字证书：长效数字证书（Long-term Validity Certificate）是一种可以长期使用的数字证书，其有效期可以达到几十年或更长时间。这种数字证书的使用需要符合特定的安全标准和法律法规，同时需要确保证书的可信度和可靠性。", "Konwledge_Point": "算法与数字", "Question": "如何解决电子签名应用中数字证书有限服务期与电子档案长期保存的矛盾\n如何解决电子签名应用中数字证书有限服务期与电子档案长期保存的矛盾", "Tag": "算法分析"}
{"Answer": "```\r\nimport java.io.UnsupportedEncodingException;\r\n\r\npublic class HelloWorld {\r\n    public static String toOct(String s)\r\n    {\r\n        String result = \"\";\r\n\t\tbyte[] bytes = s.getBytes();\r\n\t\tfor (byte b : bytes)\r\n\t\t{\r\n\t\t\tint b1 = b;\r\n\t\t\tif (b1 < 0) b1 = 256 + b1;\r\n\t\t\tresult += \"\\\\\" + (b1 / 64) % 8 +  \"\" + (b1 / 8) % 8 + \"\" + b1 % 8;\r\n\t\t}\r\n        return result;\r\n    }\r\n\r\n    public static String getOct(String s) throws UnsupportedEncodingException\r\n    {\r\n\t\tString[] as = s.split(\"\\\\\\\\\");\r\n\t\tbyte[] arr = new byte[as.length - 1];\r\n\t\tfor (int i = 1; i < as.length; i++)\r\n\t\t{\r\n\t\t\tint sum = 0;\r\n            int base = 64;\r\n            for (char c : as[i].toCharArray())\r\n            {\r\n                sum += base * ((int)c - '0');\r\n                base /= 8;\r\n            }\r\n\t\t\tif (sum >= 128) sum = sum - 256;\r\n\t\t\tarr[i - 1] = (byte)sum;\r\n\t\t}\r\n        return new String(arr,\"UTF-8\"); //如果还有乱码，这里编码方式你可以修改下，比如试试看unicode gbk等等\r\n    }\r\n\r\n    public static void main(String[] args) throws java.io.UnsupportedEncodingException {\r\n        String s = \"123中文\";\r\n        String o = toOct(s);\r\n        System.out.println(o);\r\n        s = getOct(o);\r\n        System.out.println(s);\r\n    }\r\n}\r\n```\r\n\\061\\062\\063\\344\\270\\255\\346\\226\\207\r\n123中文", "Konwledge_Point": "算法与数字", "Question": "把8进制的字符串转化成汉字\n数据是这样的\"\\314\\251\\270\",得到就是这样的了，要把这个转换成汉字字符串", "Tag": "算法分析"}
{"Answer": "定义一个大小为n的数组，先将前n个数放到这个数组，求这个数组中的最小数，然后将最小数和后面的数比，如果后面的数比最小数大，那么将这个数替换数组中的最小数后，继续获取数组的最小数，循环上述步骤直至比完全部整数", "Konwledge_Point": "算法与数字", "Question": "关于#算法#的问题：则输出99.请设计并实现一算法，传入数字n即可输出第n个大的数(语言-c语言)\n有10个互不相同的整数： 99,200, 95、 87, 98、-12, 30, -87, 75,-25,不用排序，每当输入一个1-10之间的数n,即可输出第n个大的数", "Tag": "算法分析"}
{"Answer": "http://wenku.baidu.com/link?url=ZYix8_obOT37JUQyFv-t9Y0Sv7SPCIfmc5QwjW-aifxA8WJ4iWajKpfQS7o4aFykxKdIATLIwUY2WZKEnrezolAs3WcE-wczvNsF8qISD0u", "Konwledge_Point": "算法与数字", "Question": "如何在二分查找的程序中实现对某个具体的浮点型进行精确地查找的算法？\n如何在二分查找的程序中实现对某个具体的浮点型进行精确地查找的算法？是基于dat文件的存储的搜索，用什么方式进行？", "Tag": "算法分析"}
{"Answer": "import java.util.HashSet;\r\nimport java.util.Iterator;\r\nimport java.util.Set;\r\n\r\n\r\npublic class Test {\r\n\r\n\t\r\n\tpublic static void main(String[] args) {\r\n\t\tint i,j,k,m,n,t1,t2,t3;\r\n\t\tSet total=new HashSet();\r\n\t\tfor(int t=1;t<10;t++) {\r\n\t\t\ttotal.add(t);\r\n\t\t}\r\n\t\tSet set=new HashSet();\r\n\t\tSet lastThree=new HashSet();\r\n\t\tfor(i=1;i<4;i++) {\r\n\t\t\tset.add(i);\r\n\t\t\tfor(j=1;j<10;j++) {\r\n\t\t\t\tif(j==i){ continue;}\r\n\t\t\t\tset.add(j);\r\n\t\t\t\tfor(k=1;k<10;k++) {\r\n\t\t\t\t\tif(k==i||k==j) { continue;}\r\n\t\t\t\t\tset.add(k);\r\n\t\t\t\t\tm=3*(i*100+j*10+k);\r\n\t\t\t\t\tif(m>987){set.remove(k);continue;}//如果已超出范围，没必要再往下判断\r\n\t\t\t\t\tt1=m%10; if(t1==0) {set.remove(k);continue;} //个位数\r\n\t\t\t\t\tt2=(m%100)/10; if(t2==0) {set.remove(k);continue;} //十位数\r\n\t\t\t\t\tt3=m/100;  if(t3==0) {set.remove(k);continue;}//百位数\r\n\t\t\t\t\tif(set.contains(t1)){set.remove(k);continue;}\r\n\t\t\t\t\tset.add(t1);\r\n\t\t\t\t\tif(set.contains(t2)) {set.remove(k);set.remove(t1);continue;}\r\n\t\t\t\t\tset.add(t2);\r\n\t\t\t\t\tif(set.contains(t3)) {set.remove(k);set.remove(t1);set.remove(t2);continue;}\r\n\t\t\t\t\tset.add(t3);\r\n\t\t\t\t\t//System.out.println(\"  \"+i+j+k+\"   \"+m);\r\n\t\t\t\t\ttotal.removeAll(total);\r\n\t\t\t\t\tfor(int q=1;q<10;q++) {\r\n\t\t\t\t\t\ttotal.add(q);\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttotal.removeAll(set);\r\n                    int[] s=new int[3];\r\n                    Iterator iterator=total.iterator();\r\n                    int p=0;\r\n                    while(iterator.hasNext()) {\r\n                    \ts[p]=Integer.parseInt(iterator.next()+\"\");\r\n                    \tp++;\r\n                    }\r\n                    n=s[0]*100+s[1]*10+s[2];   \r\n                    if(n==2*(i*100+j*10+k)) { System.out.println(i+\"\"+j+\"\"+k+\"    \"+n+\"    \"+m);}\r\n                    n=s[0]*100+s[2]*10+s[1];    \r\n                    if(n==2*(i*100+j*10+k)) { System.out.println(i+\"\"+j+\"\"+k+\"    \"+n+\"    \"+m);}\r\n                    n=s[1]*100+s[0]*10+s[2];   \r\n                    if(n==2*(i*100+j*10+k)) { System.out.println(i+\"\"+j+\"\"+k+\"    \"+n+\"    \"+m);}\r\n                    n=s[1]*100+s[2]*10+s[0]; \r\n                    if(n==2*(i*100+j*10+k)) { System.out.println(i+\"\"+j+\"\"+k+\"    \"+n+\"    \"+m);}\r\n                    n=s[2]*100+s[0]*10+s[1]; \r\n                    if(n==2*(i*100+j*10+k)) { System.out.println(i+\"\"+j+\"\"+k+\"    \"+n+\"    \"+m);}\r\n                    n=s[2]*100+s[1]*10+s[0]; \r\n                    if(n==2*(i*100+j*10+k)) { System.out.println(i+\"\"+j+\"\"+k+\"    \"+n+\"    \"+m);}\r\n                    set.remove(t1);\r\n                    set.remove(t2);\r\n                    set.remove(t3);\r\n                    set.remove(k);\r\n\t\t\t\t} \r\n\t\t\t\t   set.remove(j);\r\n\t\t\t}\r\n\t\t\tset.remove(i);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n运行结果：\r\n192    384    576\r\n219    438    657\r\n273    546    819\r\n327    654    981\r\n\r\n我的思想是，第一个数百位数最大为3，可谓一层循环，十位和各位则组成两层循环。\r\n用一个Set容器来存储第一个三位数，利用第一个数求出第三个数（3倍第一个数），把第三个数的每一位求出，看是否符合，符合则加入set容器，而这时只剩下三个数，对这三个数的六种情况求解，等于第一个数的两倍即成立。很麻烦，思想很简单", "Konwledge_Point": "算法与数字", "Question": "一道java面试题目\n给出下题的算法(Java语言实现)\n\n将1、2、3、4、5、6、7、8、9 这九个数字分成三个百位数，每个数字用且只用一次，\n\n并且第三个数字是第一个的3倍，第二个数字是第一个的2倍。\n\n求三个数。[说明，结果可能多于一组，例如327  654  981]\n\n这个是看到一家公司的面试题目，想了一下还没有找到什么好的方法来解决。\n\n请各位帮下忙。", "Tag": "算法分析"}
{"Answer": "（1）你的pp函数逻辑不对，只能判断末尾还有0/1/2/9的数，其他位置的不能判断（2）printlen中输出的不应该是bb，应该是bb.pp()运行结果：\n\n代码修改如下：\npackage test;\n\npublic class LanQiaoBei {\n\n    int p;\n\n    public void setP(int p) {\n        this.p = p;\n    }\n     \n    int pp() {\n        int i,j=0,t,sum=0,k=0;\n        int s[]=new int[40];\n        for(i=1;i<=p;i++) {\n            t = i;\n            while(t!=0){ //这里判断i中是否包含 0 1 2 9这几个数字中的任意一个\n                int mm = t%10; //逐个取数字的末尾数\n                t/=10; //数字除以10，跟上一句配合使用，假如 t = i = 12; mm=t%10=2，t=t/10=1，下一次循环的时候 mm=t%10=1，这样能得到数字i各个位上的所有数字\n                if(mm==0 || mm==1 || mm==2 || mm==9){\n                    s[k++] = i;\n                    break;\n                }\n            }\n        }\n       for(t=0;t<k;t++) {\n             sum=sum+s[t];\n       }\n         return sum;\n    }\n    public static void main(String[] args){\n    LanQiaoBei bb=new LanQiaoBei();\n    bb.setP(40);\n    //bb.pp();\n    System.out.println(bb.pp());\n    }\n\n}\n\n\n", "Konwledge_Point": "算法与数字", "Question": "java算法求和，我的运行结果不对，求解答\n我的问题：\n\n\n我写的代码：\npublic class LanQiaoBei {\n   int i,p,t,sum=0;\n   int s[]=new int[40];\n\n\npublic void setP(\nint\n p) {\n    this.p = p;\n}\n\n\nint\n pp() {\n   for(i=\n1\n;i<=p;i++) {    \n        \nif\n(i%\n10\n==\n0\n||i%\n10\n==\n1\n||i%\n10\n==\n2\n||i%\n10\n==\n9\n) {                    \n            for(\nt\n=\n0\n;\nt\n<p;\nt\n++) {\n                s[\nt\n]=i;\n            }                \n     \n     }\n        }\n   for(\nt\n=\n0\n;\nt\n<s.length;\nt\n++) {\n         \nsum\n=\nsum\n+s[\nt\n];\n   }\n     return \nsum\n;\n\n\n\n   }\n   public static void main(String[] args){\n       LanQiaoBei bb=new LanQiaoBei();\n       bb.setP(40);\n       bb.pp();\n       System.out.println(bb);\n}\n}\n我的运行结果：LanQiaoBei\n@2f92e0f4\n我想要的结果是问题的和，应该是一个整数。", "Tag": "算法分析"}
{"Answer": "#include <iostream>\n#include <stack>\n#include <string>\n\nusing namespace std;\n\n// 运算符优先级，数值越大，优先级越高\nint priority(char c)\n{\n    if (c == '+' || c == '-')\n        return 1;\n    else if (c == '*' || c == '/')\n        return 2;\n    else\n        return 0;\n}\n\nint main()\n{\n    // 运算数栈\n    stack<int> opnd;\n    // 运算符栈\n    stack<char> optr;\n    char c;\n    cin >> c;\n    while (c != '$')\n    {\n        // 如果是数字，直接输出\n        if (isdigit(c))\n            cout << c << ' ';\n        else if (c == '(')\n            optr.push(c);\n        else if (c == ')')\n        {\n            while (optr.top() != '(')\n            {\n                cout << optr.top() << ' ';\n                optr.pop();\n            }\n            optr.pop(); // 将'('弹出但不输出\n        }\n        else\n        {\n            // 如果当前运算符的优先级小于等于栈顶运算符的优先级，则将栈顶运算符弹出并输出\n            while (!optr.empty() && priority(c) <= priority(optr.top()))\n            {\n                cout << optr.top() << ' ';\n                optr.pop();\n            }\n            optr.push(c);\n        }\n\n        cin >> c;\n    }\n\n    // 将剩余的运算符依次弹出并输出\n    while (!optr.empty())\n    {\n        cout << optr.top() << ' ';\n        optr.pop();\n    }\n\n    return 0;\n}\n", "Konwledge_Point": "算法与数字", "Question": "输入算数表达式，计算出该表达式的逆波兰表达式\n从键盘上输入一个算数表达式，试编写算法，计算出该表达式的逆波兰表达式。规定：逆波兰表达式的长度不超过一行，以$符作为输入结束，操作数之间用空格分隔,操作符只可能有+、-、\n、/四种运算。(注释要详细)\n例1：输入为：2+3$，输出逆波兰表达式为：2 3 +。\n例2：输入为：2\n3$，输出逆波兰表达式为：2 3 \n。\n例3：输入为：1+2\n3$，输出逆波兰表达式为：1 2 3 * +。\n例4：输入为：（1+2)\n3$，输出逆波兰表达式为：1 2 + 3 \n。\n例5：输入为：（1+2\n3）\n4$，输出逆波兰表达式为：1 2 3 * + 4 \n。\n例6：输入为：6\n((5+(2+3)*8)+3)$，输出逆波兰表达式为：6 5 2 3 + 8 * + 3 + *。\n提示1：括号成对，输出运算符；否则，输出数字。\n提示2：求逆波兰表达式规则如下：设立运算数栈OPND，对表达式从左到右扫描(读入)，当表达式中扫描到数时，压入OPND栈。当扫描到运算符时，从OPND退出两个数，进行相应运算，结果再压入OPND栈。这个过程一直不断运行直至表达式结束符$。", "Tag": "算法分析"}
{"Answer": "1、x=x * i，第一次 是2019 * 1=2019，第二次是 2019 * 2=4038 第三次是 4038 * 3=12114，中间不全是相差2019，会丢失值2、x += 2019;   第一次 是2019+2019=4038，第二次是 4038+2019=6057 第三次是 6057+2019=8076 中间相差2019所以第一种不行，第二种可以；", "Konwledge_Point": "算法与数字", "Question": "关于java的算法问题(求最小整数X，2019年蓝桥杯国赛题)\npublic\n \nclass\n \nMain\n {\n  \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[] args)\n \n{\n    \nint\n x = \n2019\n;\nint\n i = \n1\n;\n    \nwhile\n ( \nloseCondition\n(x) ){\n      i++;\n      x = x * i;\n    }\n    System.out.\nprintln\n(x);\n  }\n  \npublic\n \nstatic\n \nboolean\n \nloseCondition\n(\nint\n x)\n{\n    \nboolean\n order = \nfalse\n;\n    \nwhile\n ( x > \n0\n ){\n      \nint\n k = x % \n10\n;\n//依次取最后一位\n\n      \nif\n ( k % \n2\n == \n0\n ){\n        order = \ntrue\n;\n        \nbreak\n;\n      }\n      x /= \n10\n;\n//依次去掉最后一位\n\n    }\n    \nreturn\n order;\n  }\n}\n\n\n\npublic\n \nclass\n \nMain\n {\n  \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[] args)\n \n{\n    \nint\n x = \n2019\n;\n    \nwhile\n ( \nloseCondition\n(x) ){\n      x += \n2019\n;\n    }\n    System.out.\nprintln\n(x);\n  }\n  \npublic\n \nstatic\n \nboolean\n \nloseCondition\n(\nint\n x)\n{\n    \nboolean\n order = \nfalse\n;\n    \nwhile\n ( x > \n0\n ){\n      \nint\n k = x % \n10\n;\n//依次取最后一位\n\n      \nif\n ( k % \n2\n == \n0\n ){\n        order = \ntrue\n;\n        \nbreak\n;\n      }\n      x /= \n10\n;\n//依次去掉最后一位\n\n    }\n    \nreturn\n order;\n  }\n}\n\n\n\n代码求解的问题是：\n            算出最小的整数X，且同时满足：（1）X 是 2019 的整倍数；（2）X 的每一位数字都是奇数。\n\n\n为什么第一个解法不行？", "Tag": "算法分析"}
{"Answer": "这种我觉得用C++  以及opencv的库比较好。本身opencv的库比较成熟了，学起来也快。并且会的人也多，资源好找一些", "Konwledge_Point": "算法与数字", "Question": "刚刚学习VB，想知道Moravec算子特征如何提取。我们刚学习数字摄影测量，要求编写这个程序。\n想请大神告知一二。这个程序是用哪种语言来编写比较的方便。。。。。。。。。。。。。", "Tag": "算法分析"}
{"Answer": "题目要求是：使用do-while语句作为外循环，实现按行数循环，用while循环作为内循环，循环输出每行的5个数，但每个数据应通过计算得到，每个数据之间至少有1个空格。\n\n#include<stdio.h>\nint main()\n{\n    int i = 1;\n    do\n    {\n        int j = i;\n        while(j - i < 5)\n        {\n            printf(\"%d%s\", j, \" \");\n            j += 1;\n        }\n        i += 1;\n        printf(\"\\n\");\n    }while(i <= 5);\n    return 0 ;\n}\n\n\n输出结果：\n", "Konwledge_Point": "算法与数字", "Question": "do while循环嵌套实现数字方阵\n12345\n23456\n34567\n45678\n56789，输出这个方阵。使用do-while语句作为外循环，实现按行数循环，用while循环作为内循环，循环输出每行的5个数，但每个数据应通过计算得到，每个数据之间至少有1个空格，且要求数据左对齐。\n\n\n不能使用数组\n\n\n我在算法阶段就不知道该怎么设计，这个用循环该怎么做啊\n\n\n以下是我的原码\n\n\n#include\nint main()\n{\n    int num = 0;int i=0 ;\n    while(1)\n    {\n        if (num == 9)\n            break;\n        if (i >= 0 && i < 4)\n            num++; i++;\n        printf(\"%d \", num);\n        if (i >= 1 && i < 5)\n            num++; i++;\n        printf(\"%d \", num);\n        if (i >= 2 && i < 6)\n            num++; i++;\n        printf(\"%d \", num);\n        if (i >= 3 && i < 7)\n            num++; i++;\n        printf(\"%d \", num);\n        switch (num)\n        {\n        case 4:\n            num = 5;\n            printf(\"%d\\n\", num);\n            num = num - 3; i = 1;\n            printf(\"%d \", num);\n            continue;\n        case 5:\n            num = 6;\n            printf(\"%d\\n\", num);\n            num = num - 3; i = 2;\n            printf(\"%d \", num);\n            continue;\n        case 6:\n            num = 7;\n            printf(\"%d\\n\", num);\n            num = num - 3; i = 3;\n            printf(\"%d \", num);\n            continue;\n        case 7:\n            num = 8;\n            printf(\"%d\\n\", num);\n            num = num - 3; i = 4;\n            printf(\"%d \", num);\n        case 8:\n                num = 9;\n                printf(\"%d\\n\", num);\n                continue;\n        }\n        /\nif (num >= 4 && num < 9)\n        {\n            num = num + 1;\n            printf(\"%d\\n  \", num);\n            num = num - 4; i = 0;\n            continue;\n        }\n            if (num == 9)\n                break;\n/\n    }\n    return 0;\n}", "Tag": "算法分析"}
{"Answer": "![图片说明](https://img-ask.csdn.net/upload/201705/10/1494413813_110818.png)", "Konwledge_Point": "算法与数字", "Question": "大神   看这里  这个算法题    首先输入一个数字T(1 <= T <= 100)\n首先输入一个数字T(1 <= T <= 100)，表示有T个样例，每个样例输入一个仅包含大写英文字母的符串str，字符串长度用|str|来表示，1 <= |str| <= 100。\n\n输出描述\n\n\n\n输出对应的小写字符串。 \n\n样例输入\n\n\n\n3\n\nACMERGOGOGO\n\nYOUBADBAD\n\nHAPPYBOY\n\n\n\n样例输出\n\n\n\nacmergogogo\n\nyoubadbad\n\nhappyboy\n\n\n\n提示\n\n\n\n输入一个不包含空格的连续字符串，可以使用scanf()函数或gets()函数", "Tag": "算法分析"}
{"Answer": "https://www.nowcoder.com/questionTerminal/6bcd2d10a11e47c9b707f1d81d4bc1dc", "Konwledge_Point": "算法与数字", "Question": "float小数怎么精确到6个数字，这个问题的算法？\nProblem Description\n\nYou have been selected to write the navigation module for PropBot. Unfortunately, the mechanical engineers have not provided a lot of flexibility in movement; indeed, the PropBot can only make two distinct movements. It can either move 10 cm forward, or turn towards the right by 45 degrees. Each of these individual movements takes one second of time.\n\n\n\nInput\n\nYour module has two inputs: the Cartesian coordinates of a point on the plane that the PropBot wants to get as close to as possible, and the maximum number of seconds that can be used to do this. At the beginning of the navigation, the robot is located at the origin, pointed in the +x direction.\n\n\n\nThe number of seconds will be an integer between 0 and 24, inclusive. Both the x and y coordinates of the desired destination point will be a real number between -100 and 100, inclusive.\n\n\n\nThe first entry in the input file will be the number of test cases, t (0 < t <= 100). Following this line will be t lines, with each line containing three entries separated by spaces. The first entry will be the number of seconds PropBot has to get close to the point. The second entry is the x-coordinate of the point, and the third entry is the y-coordinate of the point.\n\n\n\nOutput\n\nYour program must return the distance between the goal point and the closest point the robot can get to within the given time.\n\n\n\nYour result should include at least one digit to the left of the decimal point, and exactly six digits to the right of the decimal point. To eliminate the chance of round off error affecting the results, we have constructed the test data so the seventh digit to the right of the decimal point of the true result is never a 4 or a 5.\n\n\n\nSample Input\n\n2\n\n24 5.0 5.0\n\n9 7.0 17.0\n\n\n\nSample Output\n\n0.502525\n\n0.100505", "Tag": "算法分析"}
{"Answer": "Console.WriteLine(\"{0}的阶乘结果为:{0}\", a, jc);改为 Console.WriteLine(\"{0}的阶乘结果为:{1}\", a, jc);", "Konwledge_Point": "算法与数字", "Question": "c#初学者关于for语句进行阶乘计算的问题\n    请问各位前辈大神为何这段代码计算后的结果和输入的结果是一样的,比较输入6,结果还是6,而不是阶乘的结果.\n                    //求输入数字的阶乘\n        Console.WriteLine(\"请输入一个数字:\");\n        int a = int.Parse(Console.ReadLine());\n        int jc = 1;\n        for(int i=1;i<=a;i++)\n        {\n            jc *= i;\n        }\n        Console.WriteLine(\"{0}的阶乘结果为:{0}\", a, jc);\n        Console.ReadKey();\n", "Tag": "算法分析"}
{"Answer": "\nAn alternative approach would be to extract features (keypoints) using the scale-invariant feature transform (SIFT) or Speeded Up Robust Features (SURF).\nIt is implemented in OpenCV 2.3.1.\nYou can find a nice code example using features in Features2D + Homography to find a known object\nBoth algorithms are invariant to scaling and rotation. Since they work with features, you can also handle occlusion (as long as enough keypoints are visible).\n\nImage source: tutorial example\nThe processing takes a few hundred ms for SIFT, SURF is bit faster, but it not suitable for real-time applications. ORB uses FAST which is weaker regarding rotation invariance.\nThe original papers\n\nSURF: Speeded Up Robust Features\nDistinctive Image Features\nfrom Scale-Invariant Keypoints\nORB: an efficient alternative to SIFT or SURF\n\n", "Konwledge_Point": "算法与数字", "Question": "图像处理: 可口可乐罐识别算法的改进\n\n\n\nOne of the most interesting projects I've worked on in the past couple of years was a project about \nimage processing\n. The goal was to develop a system to be able to recognize Coca-Cola \n'cans'\n (note that I'm stressing the word 'cans', you'll see why in a minute). You can see a sample below, with the can recognized in the \ngreen rectangle\n with scale and rotation.\n\n\n\n\n\n\nSome constraints on the project:\n\n\n\n\n\nThe background could be very noisy.\n\n\nThe \ncan\n could have any \nscale\n or \nrotation\n or even orientation (within reasonable limits).\n\n\nThe image could have some degree of fuzziness (contours might not be entirely straight).\n\n\nThere could be Coca-Cola bottles in the image, and the algorithm should only detect the \ncan\n!\n\n\nThe brightness of the image could vary a lot (so you can't rely \"too much\" on color detection).\n\n\nThe \ncan\n could be partly hidden on the sides or the middle and possibly partly hidden behind a bottle.\n\n\nThere could be no \ncan\n at all in the image, in which case you had to find nothing and write a message saying so.\n\n\n\n\nSo you could end up with tricky things like this (which in this case had my algorithm totally fail):\n\n\n\n\n\n\nI did this project a while ago, and had a lot of fun doing it, and I had a decent implementation. Here are some details about my implementation:\n\n\n\nLanguage\n: Done in C++ using \nOpenCV\n library.\n\n\n\nPre-processing\n: For the image pre-processing, i.e. transforming the image into a more raw form to give to the algorithm, I used 2 methods:\n\n\n\n\n\nChanging color domain from RGB to \nHSV\n and filtering based on \"red\" hue, saturation above a certain threshold to avoid orange-like colors, and filtering of low value to avoid dark tones. The end result was a binary black and white image, where all white pixels would represent the pixels that match this threshold. Obviously there is still a lot of crap in the image, but this reduces the number of dimensions you have to work with.\n\n\n\n\n\nNoise filtering using median filtering (taking the median pixel value of all neighbors and replace the pixel by this value) to reduce noise.\n\n\nUsing \nCanny Edge Detection Filter\n to get the contours of all items after 2 precedent steps.\n\n\n\n\n\n\n\nAlgorithm\n: The algorithm itself I chose for this task was taken from \nthis\n awesome book on feature extraction and called \nGeneralized Hough Transform\n (pretty different from the regular Hough Transform). It basically says a few things:\n\n\n\n\n\nYou can describe an object in space without knowing its analytical equation (which is the case here).\n\n\nIt is resistant to image deformations such as scaling and rotation, as it will basically test your image for every combination of scale factor and rotation factor.\n\n\nIt uses a base model (a template) that the algorithm will \"learn\".\n\n\nEach pixel remaining in the contour image will vote for another pixel which will supposedly be the center (in terms of gravity) of your object, based on what it learned from the model.\n\n\n\n\nIn the end, you end up with a heat map of the votes, for example here all the pixels of the contour of the can will vote for its gravitational center, so you'll have a lot of votes in the same pixel corresponding to the center, and will see a peak in the heat map as below:\n\n\n\n\n\n\nOnce you have that, a simple threshold-based heuristic can give you the location of the center pixel, from which you can derive the scale and rotation and then plot your little rectangle around it (final scale and rotation factor will obviously be relative to your original template). In theory at least...\n\n\n\nResults\n: Now, while this approach worked in the basic cases, it was severely lacking in some areas:\n\n\n\n\n\nIt is \nextremely slow\n! I'm not stressing this enough. Almost a full day was needed to process the 30 test images, obviously because I had a very high scaling factor for rotation and translation, since some of the cans were very small.\n\n\nIt was completely lost when bottles were in the image, and for some reason almost always found the bottle instead of the can (perhaps because bottles were bigger, thus had more pixels, thus more votes)\n\n\nFuzzy images were also no good, since the votes ended up in pixel at random locations around the center, thus ending with a very noisy heat map.\n\n\nIn-variance in translation and rotation was achieved, but not in orientation, meaning that a can that was not directly facing the camera objective wasn't recognized.\n\n\n\n\nCan you help me improve my \nspecific\n algorithm, using \nexclusively OpenCV\n features, to resolve the \nfour specific\n issues mentioned?\n\n\n\nI hope some people will also learn something out of it as well, after all I think not only people who ask questions should learn. :)\n\n    \n\n\n\n转载于:https://stackoverflow.com/questions/10168686/image-processing-algorithm-improvement-for-coca-cola-can-recognition", "Tag": "算法分析"}
{"Answer": "[http://blog.csdn.net/Dacc123/article/details/50911318?locationNum=2&fps=1](http://blog.csdn.net/Dacc123/article/details/50911318?locationNum=2&fps=1 \"\")\r\n[http://blog.csdn.net/mmc2015/article/details/47321713?locationNum=4&fps=1](http://blog.csdn.net/mmc2015/article/details/47321713?locationNum=4&fps=1 \"\")", "Konwledge_Point": "算法与数字", "Question": "Multiplication Puzzle               \nDescription\n\n\n\nThe multiplication puzzle is played with a row of cards, each containing a single positive integer. During the move player takes one card out of the row and scores the number of points equal to the product of the number on the card taken and the numbers on the cards on the left and on the right of it. It is not allowed to take out the first and the last card in the row. After the final move, only two cards are left in the row. \n\n\n\nThe goal is to take cards in such order as to minimize the total number of scored points. \n\n\n\nFor example, if cards in the row contain numbers 10 1 50 20 5, player might take a card with 1, then 20 and 50, scoring \n\n10*1*50 + 50*20*5 + 10*50*5 = 500+5000+2500 = 8000\n\n\n\nIf he would take the cards in the opposite order, i.e. 50, then 20, then 1, the score would be \n\n1*50*20 + 1*20*5 + 10*1*5 = 1000+100+50 = 1150.\n\nInput\n\n\n\nThe first line of the input contains the number of cards N (3 <= N <= 100). The second line contains N integers in the range from 1 to 100, separated by spaces.\n\nOutput\n\n\n\nOutput must contain a single integer - the minimal score.\n\nSample Input\n\n\n\n6\n\n10 1 50 50 20 5\n\nSample Output\n\n\n\n3650", "Tag": "算法分析"}
{"Answer": "肯定不是代码问题，你的路径有问题，你直接把这个java文件放在 任意盘符的跟路径下如：D:\\factorial10.java   试试！", "Konwledge_Point": "算法与数字", "Question": "求助解决：算法问题-10以内的自然数的阶乘之和。\n我用UltraEdit编写了factorial10.java文件，代码如下：\n\npublic class factorial10 {\n\n  public static void main(String args[]){\n\n    long a=1;\n\n    long result=0;\n\n    for(int i=1;i<=10;i++)\n\n     {a=a*i;\n\n      result+=a;\n\n     }\n\n     System.out.println(\"result=\" + result);\n\n  }\n\n}\n\n但是在命令提示符中运行factorial10.java文件老是报如下错误：\n\nE:\\baidudownyunload>javac factorial10.java\n\nerror:cannot read:javac factorial10.java\n\n1 error", "Tag": "算法分析"}
{"Answer": "这个问题其实跟之前大家问的组成3位数有点类似\n不同点是：\n1.现在是用7个数字去组成2.里面有0，这也就是说，0不能在百位上出现3.要求是偶数，这里就要来判断能不能%2为0\nfor i in [2,3,5,6,7,9,0]:\n    if(i > 0):\n        for j in [2,3,5,6,7,9,0]:\n            for k in [2,3,5,6,7,9,0]:\n                if( i != k ) and (i != j) and (j != k) and ((i*100+j*10+k)%2 == 0):\n                    print (i,j,k)\n\n\n输出结果：\n2 3 6\n2 3 0\n2 5 6\n2 5 0\n2 6 0\n2 7 6\n2 7 0\n2 9 6\n2 9 0\n2 0 6\n3 2 6\n3 2 0\n3 5 2\n3 5 6\n3 5 0\n3 6 2\n3 6 0\n3 7 2\n3 7 6\n3 7 0\n3 9 2\n3 9 6\n3 9 0\n3 0 2\n3 0 6\n5 2 6\n5 2 0\n5 3 2\n5 3 6\n5 3 0\n5 6 2\n5 6 0\n5 7 2\n5 7 6\n5 7 0\n5 9 2\n5 9 6\n5 9 0\n5 0 2\n5 0 6\n6 2 0\n6 3 2\n6 3 0\n6 5 2\n6 5 0\n6 7 2\n6 7 0\n6 9 2\n6 9 0\n6 0 2\n7 2 6\n7 2 0\n7 3 2\n7 3 6\n7 3 0\n7 5 2\n7 5 6\n7 5 0\n7 6 2\n7 6 0\n7 9 2\n7 9 6\n7 9 0\n7 0 2\n7 0 6\n9 2 6\n9 2 0\n9 3 2\n9 3 6\n9 3 0\n9 5 2\n9 5 6\n9 5 0\n9 6 2\n9 6 0\n9 7 2\n9 7 6\n9 7 0\n9 0 2\n9 0 6\n", "Konwledge_Point": "算法与数字", "Question": "如何将2、3、5、6、7、9、0组成不相同、不重复、且是偶数的三位数\n我想要达到的结果\n\n\n将2，3，5，6，7，9，0组成三位数，要求这三位数各不相关，不重复，且是偶数。\n请帮忙设计下算法，用python怎么写代码。", "Tag": "算法分析"}
{"Answer": "你学号和手机号是要int类型还是字符串char []类型\n输入,判断和输出都应该统一,不要一会用int类型一会用字符串char []类型\nint的范围是:-2147483648 to 2147483647你手机号有11位数超出int能承载的最大范围需要把学号与手机号改成long long int 类型    struct student {        long long int nume_student;        long long int phone_number;\n与之相关的a,d,op也改成long long int 类型    long long int a;    long long int d;    long long int op;\n学号与手机号输入和输出用%lld,不需要转成字符串了, 也就不需要nty了\n你题目的解答代码如下：\n#define _CRT_NONSTDC_NO_DEPRECATE\n#define _CRT_SECURE_NO_DEPRECATE\n#include<stdio.h>\n#include<string.h>\nusing namespace std;\n#define size 50\nint main() {\n    struct student {\n        long long int nume_student;\n        char name_student[20];\n        char sex_student;\n        long long int phone_number;\n        float score_yuwen;\n        float score_math;\n        float score_english;\n        float score_pinde;\n        float total_score;\n        int rank;\n        char attach[50];\n    }stu[size];\n    char uio[100];\n    long long int a;\n    char b;\n    char c;\n    long long int d;\n    float e;\n    float f;\n    float g;\n    float h;\n    float j;\n    int k;\n    char* l;\n    int i;\n    int lo;\n    long long int op;\n    printf(\"请问您要输入多少个信息？\");\n    scanf(\"%d\", &lo);\n    printf(\"确认输入%d个信息\\n开始输入您的信息:\\n\", lo);\n    for (i = 0;i<lo;i++)\n    {\n        scanf(\"%lld %s %c %lld %f %f %f %f %s\",&a, stu[i].name_student, &c,&d, &e, &f, &g, &h,stu[i].attach);\n        stu[i].nume_student = a;\n        stu[i].sex_student = c;\n        stu[i].phone_number = d;\n        stu[i].score_yuwen = e;\n        stu[i].score_math = f;\n        stu[i].score_english = g;\n        stu[i].score_pinde = h;\n        stu[i].total_score = e + f + g + h;\n    }\n    printf(\"请问您要查询哪个学号？\\n\");     //在这之前没什么大问题_\n    scanf(\"%lld\", &op);\n    for (i = 0; i < lo; i++)\n        if (op==stu[i].nume_student)\n            break;\n    if (i<lo)\n        printf(\"学号为%lld 姓名为%s 性别为%c 手机号为%lld 语文成绩为%f 数学成绩为%f 英语成绩为%f 品德分为%f 综合评测分为%f 排名为 备注为%s\", stu[i].nume_student ,stu[i].name_student,stu[i].sex_student, stu[i].phone_number , stu[i].score_yuwen, stu[i].score_math, stu[i].score_english, stu[i].score_pinde, stu[i].total_score, stu[i].attach);\n    else\n        printf(\"没有找到学号%d\",op);\n}\n\n\n如有帮助，请点击我的回答下方的【采纳该答案】按钮帮忙采纳下，谢谢!\n", "Konwledge_Point": "算法与数字", "Question": "数字转字符串永远乱码怎么回事？\n\n\n#\ndefine\n _CRT_NONSTDC_NO_DEPRECATE\n\n\n#\ndefine\n _CRT_SECURE_NO_DEPRECATE\n\n\n#\ninclude\n\n\n\n#\ninclude\n \n\n\n\nusing\n \nnamespace\n std;\n\n#\ndefine\n size 50\n\n\nint\n \nmain\n()\n \n{\n    \nstruct\n \nstudent\n {\n        \nint\n nume_student;\n        \nchar\n name_student[\n20\n];\n        \nchar\n sex_student;\n        \nint\n phone_number;\n        \nfloat\n score_yuwen;\n        \nfloat\n score_math;\n        \nfloat\n score_english;\n        \nfloat\n score_pinde;\n        \nfloat\n total_score;\n        \nint\n rank;\n        \nchar\n attach[\n50\n];\n    }stu[size];\n    \nstruct\n \nnum\n {\n        \nchar\n iuy[\n100\n];\n        \nchar\n tyu[\n100\n];\n    }nty[size];\n    \nchar\n uio[\n100\n];\n    \nint\n a;\n    \nchar\n b;\n    \nchar\n c;\n    \nint\n d;\n    \nfloat\n e;\n    \nfloat\n f;\n    \nfloat\n g;\n    \nfloat\n h;\n    \nfloat\n j;\n    \nint\n k;\n    \nchar\n* l;\n    \nint\n i;\n    \nint\n lo;\n    \nint\n op;\n    \nprintf\n(\n\"请问您要输入多少个信息？\"\n);\n    \nscanf\n(\n\"%d\"\n, &lo);\n    \nprintf\n(\n\"确认输入%d个信息\\n开始输入您的信息\"\n, lo);\n    \nfor\n (i = \n0\n;i<lo;i++)\n    {\n        \nscanf\n(\n\"%d %s %c %d %f %f %f %f %s\"\n,&a, stu[i].name_student, &c,&d, &e, &f, &g, &h,stu[i].attach);\n        stu[i].sex_student = c;\n        stu[i].score_yuwen = e;\n        stu[i].score_math = f;\n        stu[i].score_english = g;\n        stu[i].score_pinde = h;\n        stu[i].total_score = e + f + g + h;\n        \nitoa\n(a, nty[i].iuy, \n10\n);     _ \n//这句是我为了数字转化字符串后加的_\n\n        \nitoa\n(d, nty[i].tyu, \n10\n);    ** \n//这句是我为了数字转化字符串后加的**\n\n\n\n    }\n    \nprintf\n(\n\"请问您要查询哪个学号？\\n\"\n);     _\n//在这之前没什么大问题_\n\n    \nscanf\n(\n\"%d\"\n, &op);\n    \nsprintf\n(uio, \n\"%ld\"\n,op)\n    \nprintf\n(\n\"%s\"\n, uio);   **_\n//这一步输出uio的字符串，永远都不是我12位的学号永远都是8位数左右的随机数字_**\n\n    \nint\n r = \nstrcmp\n(uio, nty[i].iuy);\n    i = \n0\n;\n    \nwhile\n (r!=\n0\n)\n    {\n        i++;\n        r = \nstrcmp\n(uio, nty[i].iuy);\n    }\n    \nprintf\n(\n\"学号为%s 姓名为%s 性别为%c 手机号为%s 语文成绩为%f 数学成绩为%f 英语成绩为%f 品德分为%f 综合评测分为%f 排名为 备注为%s\"\n, nty[i].iuy,stu[i].name_student,stu[i].sex_student, nty[i].tyu, stu[i].score_yuwen, stu[i].score_math, stu[i].score_english, stu[i].score_pinde, stu[i].total_score, stu[i].attach);\n\n\n\n我的目的只有一个，最后我输入我的学号通过while判断找到结构体数组里面我自己信息的那一组然后自己的学号和手机号完美输出不是随机数字也不是乱码，其他的名称成绩统统已经没问题了就是学号和手机号永远不能完好输出。然后我尝试数字改字符串，然后通过strcmp字符串while比较来找到自己的那一组信息，但没等断点测试到while那一行前面数字就不对劲了，5个小时，真顶不住了，希望有可以告诉我怎么在student那块设立结构体数组的时候在学号和手机号也就是nume_student;和phone_number;前面依旧定义int而不是char我知道char最容易但我们课题就是int说最好别改，所以在int前提下成功最后输出我的学号和手机号，悬赏问题，感谢你们了。", "Tag": "算法分析"}
{"Answer": "供参考：\n#include <stdio.h>\nint main()\n{\n    int m = 4, n = 6, i, j;\n    scanf(\"%d%d\", &m, &n);\n    for (i = 0; i < m; i++) {\n        for (j = 0; j < n; j++) \n            i % (m - 1) == 0 || j % (n - 1) == 0 ? printf(\"*\") : printf(\" \");\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n", "Konwledge_Point": "算法与数字", "Question": "输出一个m行n列的图形\n实验四 13．输出一个m行n列的由*组成边框的长方形。例如若m为4、n为6时，则输出：\n\n\n要求：m和n从键盘输入，且m≥2 、n≥2，下述两种算法都可以实现，也可以用其他方法。\n\n\n算法1：第1行和第m行输出n个\n。其他行先输出一个\n，再输出n-2个空格，最后输出一个*。每行结尾输出一个换行符。\n\n\n算法2：将上述图形看成由\n和空格构成的长方形点阵。做一个双重循环，外循环m行，内循环n列，当行号为1或行号为m或列号为1或列号n时输出\n，其他情况输出空格。每行结尾输出一个换行符。", "Tag": "算法分析"}
{"Answer": "花了点时间，用递归和减而治之的思想。\n#include <iostream>\n#include <deque>\n\nusing namespace std;\n\nvoid Generate(const deque<int64_t> &operands, int64_t D, deque<char> &operators, int64_t &result)\n{\n    if (operands.size() == 1u) {\n        if ((operands[0] >= D) && (result == -1) || (result > operands[0])) {\n            result = operands[0];    \n        }\n        return;\n    }\n\n    // 加法运算\n    auto tmpOperands(operands);\n    tmpOperands[1] += tmpOperands[0];\n    tmpOperands.pop_front();\n    operators.push_back('+');\n    Generate(tmpOperands, D, operators, result);\n    if (result == D) {\n        return;\n    }\n    operators.pop_back();\n\n    // 乘法运算\n    tmpOperands[0] = operands[0] * operands[1];\n    operators.push_back('*');\n    Generate(tmpOperands, D, operators, result);\n    if (result != D) {\n        operators.pop_back();\n    }\n}\n\nint main(int, char **)\n{\n    int64_t N, D, i;\n    cin >> N >> D;\n\n    deque<int64_t> operands;\n    for (i = 0; i < N; ++i) {\n        int t;\n        cin >> t;\n        operands.push_back(t);\n    }\n\n    deque<char> operators;\n    int64_t result = -1;\n    Generate(operands, D, operators, result);\n    if (result == D) {\n        for (i = 0; i < N - 1; ++i) {\n            cout << operands[i] << operators[i];\n        }\n        cout << operands[i] << endl;\n    } else {\n        cout << \"NO\" << endl;\n        cout << result << endl;\n    }\n}\n\n", "Konwledge_Point": "算法与数字", "Question": "一道c++算法题，不知道该怎么设计，求指导\n一道c++算法题，不知道该怎么设计，求指导\n用户可以输入n个数和目标D。\n可使用的运算符限定于加号和乘号两种，且它们之间既没有优先级次序也不得使用括号（故计算总是按输入n个数的顺序及添加的运算符自左向右进行）。\n一旦得不到目标D，希望知道一个能够通过这n个数得出的大于D的最小值。\n【输入】\n第一行两个正整数 N 和 D，分别表示数的个数和目标结果。第二行为 N 个数字，以空格分隔。\n【输出】\n若能得到D，则输出一个对应算式；否则输出No，以及大于D的最小值（最小值不存在则输出-1）。\n【限制】1 ≤ N ≤ 24，1 ≤ D < 2^60\n【输入样例1】\n4 235\n34 12 5 5\n【输出样例1】\n34+12*5+5\n【输入样例2】\n3 600\n9 9 9\n【输出样例2】\nNo\n729", "Tag": "算法分析"}
{"Answer": "这个怎么可能可以反推得到呢？因为有无数种可能性。", "Konwledge_Point": "算法与数字", "Question": "已经知道一个数字作为数组的和，反过来推这个数组\n已经知道一个数字作为数组的和，反过来推这个数组是另一个数组中的哪些数字组成的用什么算法？", "Tag": "算法分析"}
{"Answer": "精简后的代码：\nimport java.util.*;\n\npublic class jiuwushu {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        System.out.print(\"请输入一个四位的整数：\");\n        int M = sc.nextInt();\n        int F = F(M);\n        if (F != 0) {\n            System.out.println(F);\n        }\n\n        System.out.println(\"----------------------------\");\n        List<Integer> list = TotalM();\n        System.out.println(\"九五数中F(M)能被8整除的所有M为: \" + list);\n    }\n\n    public static int F(int M) {\n        if (M < 1000 || M > 9999) {\n            System.out.println(\"你输入的数字有误\");\n            return 0;\n        }\n        Map<String, Integer> wei = wei(M);\n        int geWei = wei.get(\"geWei\");\n        int shiWei = wei.get(\"shiWei\");\n        int baiWei = wei.get(\"baiWei\");\n        int qianWei = wei.get(\"qianWei\");\n        if (qianWei + baiWei == 9 && shiWei + geWei == 5) {\n            int newM = qianWei * 10 + shiWei * 1000 + baiWei + geWei * 100;\n            return (M - newM) / 99;\n        }\n        return 0;\n    }\n\n    public static Map<String, Integer> wei(int M) {\n        Map<String, Integer> map = new HashMap<>();\n        map.put(\"geWei\", M % 10);\n        map.put(\"shiWei\", M / 10 % 10);\n        map.put(\"baiWei\", M / 100 % 10);\n        map.put(\"qianWei\", M / 1000);\n        return map;\n    }\n\n    public static List<Integer> TotalM() {\n        List<Integer> Ms = new ArrayList<>();\n        for (int i = 1000; i <= 9999; i++) {\n            int F = F(i);\n            if (F != 0 && F % 8 == 0) {\n                Ms.add(i);\n            }\n        }\n        return Ms;\n    }\n}\n\n\n", "Konwledge_Point": "算法与数字", "Question": "九五数算法求简单代码\n求精简的代码\n\n\n\n\nimport\n java.util.*;\n\n\npublic\n \nclass\n jiuwushu {\n    \npublic\n static \nvoid\n main(String[] args) {\n        Scanner sc = \nnew\n Scanner(\nSystem\n.\nin\n);\n        \nSystem\n.\nout\n.println(\"请输入一个四位的整数：\");\n        \nint\n M = sc.nextInt();\n        \nint\n F = F(M);\n        \nif\n (F != \n0\n) {\n            \nSystem\n.\nout\n.println(F);\n        }\n\n        \nSystem\n.\nout\n.println(\"----------------------------\");\n        List<\nInteger\n> list = TotalM();\n        \nSystem\n.\nout\n.println(\"九五数中F(M)能被8整除的所有M为\");\n        \nfor\n (\nInteger\n \ninteger\n : list) {\n            \nSystem\n.\nout\n.print(\ninteger\n);\n            \nSystem\n.\nout\n.print(\"    \");\n        }\n\n\n    }\n\n    \n/**\n     * 判断该数是否为九五数，\n     * 九五数：返回 F（M）\n     * 非九五数和输入错误：返回 0\n     * 详细版\n     *\n     * @param M\n     * @return\n     */\n\n    \npublic\n static \nint\n F(\nint\n M) {\n        \nif\n (M >= \n10000\n || M <= \n999\n) {\n            \nSystem\n.\nout\n.println(\"你输入的数字有误\");\n            \nreturn\n \n0\n;\n        } \nelse\n {\n            Map wei = wei(M);\n            \nint\n geWei = wei.\nget\n(\"geWei\");\n            \nint\n shiWei = wei.\nget\n(\"shiWei\");\n            \nint\n baiWei = wei.\nget\n(\"baiWei\");\n            \nint\n qianWei = wei.\nget\n(\"qianWei\");\n            \nif\n (qianWei + baiWei == \n9\n && shiWei + geWei == \n5\n) {\n                \nSystem\n.\nout\n.println(\"该数字为九五数\");\n                \nint\n newM = qianWei * \n10\n + shiWei * \n1000\n + baiWei + geWei * \n100\n;\n\n                \nint\n F = (M - newM) / \n99\n;\n                \nreturn\n F;\n\n            } \nelse\n {\n                \nif\n (qianWei + baiWei == \n9\n) {\n                    \nSystem\n.\nout\n.println(\"该数字不是九五数，原因是个位加十位不等于5\");\n                } \nelse\n \nif\n (shiWei + geWei == \n5\n) {\n                    \nSystem\n.\nout\n.println(\"该数字不是九五数，原因是百位加千位不等于9\");\n\n                } \nelse\n {\n                    \nSystem\n.\nout\n.println(\"该数字不是九五数，原因是个位加十位不等于5，并且百位加千位不等于9\");\n                }\n                \nreturn\n \n0\n;\n\n            }\n        }\n\n    }\n\n    \n/**\n     * 判断该数是否为九五数，\n     * 九五数：返回 F（M）\n     * 非九五数和输入错误：返回 0\n     * 简略版，针对第二题\n     *\n     * @param M\n     * @return\n     */\n\n    \npublic\n static \nint\n jiuWu(\nint\n M) {\n        Map wei = wei(M);\n        \nint\n geWei = wei.\nget\n(\"geWei\");\n        \nint\n shiWei = wei.\nget\n(\"shiWei\");\n        \nint\n baiWei = wei.\nget\n(\"baiWei\");\n        \nint\n qianWei = wei.\nget\n(\"qianWei\");\n        \nif\n (qianWei + baiWei == \n9\n && shiWei + geWei == \n5\n) {\n            \nint\n newM = qianWei * \n10\n + shiWei * \n1000\n + baiWei + geWei * \n100\n;\n            \nint\n F = (M - newM) / \n99\n;\n            \nreturn\n F;\n        }\n        \nreturn\n \n0\n;\n    }\n\n    \npublic\n static Map wei(\nint\n M) {\n        Map map = \nnew\n HashMap();\n        \nint\n geWei = M % \n10\n;\n        \nint\n shiWei = M / \n10\n % \n10\n;\n        \nint\n baiWei = M / \n100\n % \n10\n;\n        \nint\n qianWei = M / \n1000\n;\n\n        map.put(\"geWei\", geWei);\n        map.put(\"shiWei\", shiWei);\n        map.put(\"baiWei\", baiWei);\n        map.put(\"qianWei\", qianWei);\n        \nreturn\n map;\n    }\n\n    \n/**\n     * 判断1000-9999中所有满足九五数的，并满足F(M)能被8整出\n     * 返回List集合\n     *\n     * @return\n     */\n\n    \npublic\n static List<\nInteger\n> TotalM() {\n        List<\nInteger\n> Ms = \nnew\n ArrayList<\nInteger\n>();\n        \nfor\n (\nint\n i = \n1000\n; i <= \n9999\n; i++) {\n            \nint\n F = jiuWu(i);\n            \nif\n (F != \n0\n) {\n                \nif\n (F % \n8\n == \n0\n) {\n                    Ms.\nadd\n(i);\n                }\n            }\n        }\n        \nreturn\n Ms;\n    }\n}\n\n\n", "Tag": "算法分析"}
{"Answer": "双层循环：\n for (int i = 0; i < numlist.Length-1; i++)\n            {\n                for (int j = 0; j < numlist.Length-1-i; j++)\n\n前一个和后一个比 所以最后一次比较为倒数第二个和倒一比", "Konwledge_Point": "算法与数字", "Question": "冒泡排序算法报错 c#\n报错\n\n\n问题相关代码，请勿粘贴截图\n\n\n        Console.\nWriteLine(\n\"请输入一组数字：\"\n)\n;\n            \nstring\n str = Console.\nReadLine()\n;\n            \nstring\n[]\n num = str.\nSplit(',')\n; \n// 获取到每个数\n\n            \nint\n[]\n numlist=\nnew\n \nint\n[\nnum\n.L\nength\n]\n;\n            \nfor\n (\nint\n i = \n0\n; i < num.Length; i++)\n            {\n                numlist\n[\ni\n]\n = \nint\n.\nParse(\nnum\n[\ni\n])\n; \n// 将每个数存储到numlist数组中\n\n            }\n            \nfor\n (\nint\n i = \n0\n; i < numlist.Length; i++)\n            {\n                \nfor\n (\nint\n j = \n0\n; j < numlist.Length-i; j++)\n                {\n                    \nif\n (numlist\n[\nj\n]\n<numlist\n[\nj\n+\n1\n]\n)  \n//此数小于后一个数，两个数交换，从大到小排列\n\n                    {\n                        \nint\n temp = numlist\n[\nj\n]\n;\n                        numlist\n[\nj\n]\n = numlist\n[\nj\n + \n1\n]\n;\n                        numlist\n[\nj\n + \n1\n]\n = temp;\n                    }\n                }\n            }\n            Console.\nWriteLine(\n\"排序结果为:\"\n)\n;\n            \nfor\n (\nint\n i = \n0\n; i < numlist.Length; i++)\n            {\n                Console.\nWrite(\nnumlist\n[\ni\n]+\n\",\"\n)\n;\n            }\n        Console.\nReadLine()\n;\n\n\n\n", "Tag": "算法分析"}
{"Answer": "你的意思我看懂了，但是你举的例子最后一行数字按照你的规律说，答案是错的。（六个对号四个错号），按照你的规律来说，应该是两个错，八个对。\r\n3：234789 交集 null = null 叉\r\n9：15610 交集 3 = null 叉\r\n5：234789 交集 39 = 39 勾\r\n2：234789 交集 395 = 39 勾\r\n4：234789 交集 3952 = 239 勾\r\n8：234789 交集 39524 = 2349 勾\r\n1：15610 交集 395248 = 5 勾\r\n7：15610 交集 3952481 = 15 勾\r\n10：234789 交集 39524817 = 234789 勾\r\n6：15610 交集 3952481710 = 1510 勾\r\n你先确定一下这个规律是不是对的，如果确定了规律，出JAVA的算法很容易\r\n\r\n\r\n\r\n\r\n```\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Scanner;\r\n\r\npublic class Myclass01 {\r\n\r\n\tprivate HashMap> map = new HashMap>();\r\n\t\r\n\tpublic static void main(String[] args) {\r\n\t\tnew Myclass01();\r\n\t}\r\n\t\r\n\tpublic Myclass01() {\r\n\t\tSystem.out.print(\"请自行输入一串数字（0代表10）：\");\r\n\t\tScanner scan = new Scanner(System.in);\r\n\t\tString read = scan.nextLine();\r\n\t\tif(!read.matches(\"\\\\d+\")){\r\n\t\t\tSystem.out.println(\"输入的必须都是数字！\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tchar[] ch = read.toCharArray();\r\n\t\tint [] nums_input = new int[ch.length];\r\n\t\tfor (int i = 0; i < ch.length; i++) {\r\n\t\t\tnums_input[i] = Integer.parseInt(String.valueOf(ch[i]));\r\n\t\t}\r\n\t\tinitialization();\r\n\t\tList nums_input_list = new ArrayList();\r\n\t\tfor (int i = 0; i < nums_input.length; i++) {\r\n\t\t\tint num = nums_input[i];\r\n\t\t\tnums_input_list.add(num);\r\n\t\t}\r\n\t\tfor (int i = 0; i < nums_input_list.size(); i++) {\r\n\t\t\tint num = nums_input_list.get(i);\r\n\t\t\tif(num==0){\r\n\t\t\t\tnum = 10;\r\n\t\t\t}\r\n\t\t\tList nums_list = map.get(num);\r\n\t\t\tif(i==0){\r\n\t\t\t\tSystem.out.println(num+\":×\");\r\n\t\t\t}else{\r\n\t\t\t\tint before = nums_input_list.get(i-1);\r\n\t\t\t\tif(nums_list.contains(before)){\r\n\t\t\t\t\tSystem.out.println(num+\":√\");\r\n\t\t\t\t}else{\r\n\t\t\t\t\tSystem.out.println(num+\":×\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate int[] getRandomNum(int count) {\r\n\t\t// TODO 自动生成的方法存根\r\n\t\tint[] nums = new int[count];\r\n\t\tfor (int i = 0; i < count; i++) {\r\n\t\t\tnums[i] = (int)(1+Math.random()*(10-1+1));\r\n\t\t}\r\n\t\t\r\n\t\treturn nums;\r\n\t}\r\n\t\r\n\tprivate void initialization() {\r\n\t\tList nums_1 = new ArrayList();\r\n\t\tnums_1.add(1);\r\n\t\tnums_1.add(5);\r\n\t\tnums_1.add(6);\r\n\t\tnums_1.add(10);\r\n\t\tList nums_2 = new ArrayList();\r\n\t\tnums_2.add(2);\r\n\t\tnums_2.add(3);\r\n\t\tnums_2.add(4);\r\n\t\tnums_2.add(7);\r\n\t\tnums_2.add(8);\r\n\t\tnums_2.add(9);\r\n\t\t\r\n\t\tmap.put(1,nums_1);\r\n\t\tmap.put(2, nums_2);\r\n\t\tmap.put(3, nums_2);\r\n\t\tmap.put(4, nums_2);\r\n\t\tmap.put(5, nums_2);\r\n\t\tmap.put(6, nums_1);\r\n\t\tmap.put(7, nums_1);\r\n\t\tmap.put(8, nums_2);\r\n\t\tmap.put(9, nums_1);\r\n\t\tmap.put(10, nums_2);\r\n\t}\r\n\r\n}\r\n\r\n```\r\n运行结果是：\r\n3:×\r\n9:×\r\n5:√\r\n2:×\r\n4:√\r\n8:√\r\n1:×\r\n7:√\r\n10:√\r\n6:√", "Konwledge_Point": "算法与数字", "Question": "没有大神可以用java实现这个算法\n\n输入一次数据  然后 统计按规律的打对号   不按规律的打错号  每五分钟输入一次   统计12个小时内的对号和错号的个数。\n\n第一个规律，如果1这个数字左边的数字有 1、5、6、10，其中的一个，那么就打个对号      这十个规律是分开的   每输入一组数据要统计十次。这里的左边是紧挨着的左边。比如这个图片最下面一行的数字，对于上面十个规律来说，他只满足六个，也就是如果我输入图片最后一行的数字  输出的是六个对号四个错号。", "Tag": "算法分析"}
{"Answer": "时间复杂度为O(n4),一般超过O(n3)算法上就存在问题。参考：\nclass UnionFind:\n    def __init__(self, n: int):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, x: int) -> int:\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def merge(self, x: int, y: int) -> None:\n        x, y = self.find(x), self.find(y)\n        if x == y:\n            return\n        if self.rank[x] > self.rank[y]:\n            self.parent[y] = x\n        elif self.rank[x] < self.rank[y]:\n            self.parent[x] = y\n        else:\n            self.parent[y] = x\n            self.rank[x] += 1\n\nclass Solution:\n    def largestComponentSize(self, nums: List[int]) -> int:\n        uf = UnionFind(max(nums) + 1)\n        for num in nums:\n            i = 2\n            while i * i <= num:\n                if num % i == 0:\n                    uf.merge(num, i)\n                    uf.merge(num, num // i)\n                i += 1\n        return max(Counter(uf.find(num) for num in nums).values())\n", "Konwledge_Point": "算法与数字", "Question": "关于#优化算法#的问题，如何解决？\n问题遇到的现象和发生背景\n\n\nleetcode每日一题，给定一个由不同正整数的组成的非空数组 nums ，考虑下面的图：\n有 nums.length 个节点，按从 nums[0] 到 nums[nums.length - 1] 标记；\n只有当 nums[i] 和 nums[j] 共用一个大于 1 的公因数时，nums[i] 和 nums[j]之间才有一条边。\n返回 图中最大连通组件的大小 。\n示例 1：\n输入：nums = [4,6,15,35]\n输出：4\n示例 2：\n输入：nums = [20,50,9,63]\n输出：2\n\n\n问题相关代码，请勿粘贴截图\n\n\ndef\n \nfind\n(list,nums):\n        \nfor\n m in list:\n            \nfor\n k in nums:\n                \nif\n k not in list and math.gcd(k, m) > \n1\n:\n                    list.\nappend\n(k)\n\nclass\n Solution:\n    \n    \ndef\n largestComponentSize(self, nums: List[\nint\n]) -> \nint\n:\n        list1=[]\n        \nfor\n i in nums:\n            list=[i]\n            \nfor\n j in nums:\n                \nif\n i!=j and math.gcd(i,j)>\n1\n:\n                    list.\nappend\n(j)\n            \nwhile\n \nTrue\n:\n                a=len(list)\n                \nfind\n(list,nums)\n                b=len(list)\n                \nif\n a==b:\n                    \nbreak\n\n            list1.\nappend\n(len(list))\n        \nreturn\n max(list1)\n\n\n\n运行结果及报错内容\n\n\n循环语句太多导致遇到非常长的数字就超出时间限制了。\n\n\n\n我想要达到的结果\n\n\n算法本身能算出正确得数。\n请评价一下我的算法，有没有优化空间。", "Tag": "算法分析"}
{"Answer": "你可以一行输入7个数字，按照空格分隔或者分7行输入，每行一个数字\n最后你需要将要查询的数输入进去，再按回车", "Konwledge_Point": "算法与数字", "Question": "这个出现调试台之后怎么输入？\nN个有序整数已放在一维数组中。采用函数利用折半查找算法查找整数m在数组中的位置。若找到返回其下标值；反之，返回-1。编写主函数实现函数调用。\n\n\n\n#include\n\nint\n fun(\nint\n a[], \nint\n h)\n{\n    \nint\n \nleft\n = \n0\n, \nright\n = \n6\n, \nmid\n = (\nleft\n + \nright\n) / \n2\n;\n    while (\nleft\n <= \nright\n)\n    {\n        \nif\n (a[\nmid\n] == h)\n        {\n            return \nmid\n;\n        }\n        else \nif\n (a[\nmid\n] < h)\n        {\n            \nleft\n = \nmid\n + \n1\n;\n            \nmid\n = (\nleft\n + \nright\n) / \n2\n;\n        }\n        else \nif\n (a[\nmid\n] > h)\n        {\n            \nright\n = \nmid\n - \n1\n;\n            \nmid\n = (\nleft\n + \nright\n) / \n2\n;\n        }\n    }\n    \nif\n (\nleft\n > \nright\n) return -\n1\n;\n}\n\nint\n main()\n{\n    \nint\n a[\n100\n], i = \n0\n, s, h;\n    printf(\n\"请按顺序输入一串数字：\"\n);\n    for (i = \n0\n; i < \n7\n; i++)\n    {\n        scanf_s(\n\"%d\"\n, &a[i]);\n    }\n    printf(\n\"请输入目标数字：\"\n);\n    scanf_s(\n\"%d\"\n, &h);\n    s = fun(a, h);\n    printf(\n\"%d\"\n, s);\n    return \n0\n;\n}\n", "Tag": "算法分析"}
{"Answer": "试写一个：\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\n\r\nimport org.junit.Test;\r\n\r\npublic class CombinArray {\r\n\tpublic static ArrayList combine(ArrObject theArr,\r\n\t\t\tArrObject otherArr) {\r\n\t\tList one = theArr.getArr();\r\n\t\tList other = otherArr.getArr();\r\n\t\tArrayList combined = new ArrayList();\r\n\t\tint noEqualCount = 0;\r\n\t\tint equalCount = 0;\r\n\t\tif (one.size() == other.size()) {\r\n\t\t\tfor (int i = 0; i < one.size(); i++) {\r\n\t\t\t\tif (one.get(i) - other.get(i) != 0) {\r\n\t\t\t\t\tnoEqualCount++;\r\n\t\t\t\t\tcombined.add(one.get(i) + other.get(i));\r\n\t\t\t\t} else {\r\n\t\t\t\t\tequalCount++;\r\n\t\t\t\t\tcombined.add(one.get(i));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Equal and have only one difference can combine to one.\r\n\t\tif (noEqualCount == 1 || equalCount == one.size()) {\r\n\t\t\tSystem.out.println(\"middle:\" + combined);\r\n\t\t\treturn combined;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testCombine() {\r\n\t\tArrObject arr1 = new ArrObject(Arrays.asList(1, 2, 3));\r\n\t\tArrObject arr2 = new ArrObject(Arrays.asList(1, 2, 3));\r\n\t\tArrObject arr3 = new ArrObject(Arrays.asList(1, 2, 8));\r\n\t\tArrObject arr4 = new ArrObject(Arrays.asList(1, 3, 8));\r\n\t\tArrObject arr5 = new ArrObject(Arrays.asList(1, 3, 8));\r\n\t\tArrObject arr6 = new ArrObject(Arrays.asList(3, 8, 1));\r\n\t\tArrayList arrayList = new ArrayList(\r\n\t\t\t\tArrays.asList(arr1, arr2, arr3, arr4, arr5, arr6));\r\n\t\tArrayList resultList = new ArrayList();\r\n\t\tfor (int i = 0; i < arrayList.size(); i++) {\r\n\t\t\tArrObject one = arrayList.get(i);\r\n\t\t\tArrObject other = arrayList.get((i + 1) / arrayList.size());\r\n\t\t\tArrayList result = combine(one, other);\r\n\t\t\tif (result != null && !resultList.contains(result)) {\r\n\t\t\t\tarrayList.add(new ArrObject(result));\r\n\t\t\t\tarrayList.remove(one);\r\n\t\t\t\tarrayList.remove(other);\r\n\t\t\t\tresultList.add(new ArrObject(result));\r\n\t\t\t}\r\n\t\t\tprint(arrayList);\r\n\t\t}\r\n\t\tSystem.out.println(\"==========result==========\");\r\n\t\tprint(resultList);\r\n\t}\r\n\r\n\tprivate void print(ArrayList copyofList) {\r\n\t\tSystem.out.println(\"finished:\");\r\n\t\tfor (ArrObject arrObject : copyofList) {\r\n\t\t\tSystem.out.println(arrObject.getArr());\r\n\t\t}\r\n\t}\r\n}\r\n\r\nclass ArrObject {\r\n\tprivate List arr;\r\n\tprivate boolean combine;\r\n\r\n\tpublic ArrObject(List arr) {\r\n\t\tsuper();\r\n\t\tCollections.sort(arr);\r\n\t\tthis.arr = arr;\r\n\t}\r\n\r\n\tpublic boolean isCombine() {\r\n\t\treturn combine;\r\n\t}\r\n\r\n\tpublic void setCombine(boolean combine) {\r\n\t\tthis.combine = combine;\r\n\t}\r\n\r\n\tpublic List getArr() {\r\n\t\treturn arr;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic int hashCode() {\r\n\t\tfinal int prime = 31;\r\n\t\tint result = 1;\r\n\t\tresult = prime * result + ((arr == null) ? 0 : arr.hashCode());\r\n\t\treturn result;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic boolean equals(Object obj) {\r\n\t\tif (this == obj)\r\n\t\t\treturn true;\r\n\t\tif (obj == null)\r\n\t\t\treturn false;\r\n\t\tif (getClass() != obj.getClass())\r\n\t\t\treturn false;\r\n\t\tArrObject other = (ArrObject) obj;\r\n\t\tif (arr == null) {\r\n\t\t\tif (other.arr != null)\r\n\t\t\t\treturn false;\r\n\t\t} else if (!arr.equals(other.arr))\r\n\t\t\treturn false;\r\n\t\treturn true;\r\n\t}\r\n}", "Konwledge_Point": "算法与数字", "Question": "高分求解基本的java算法题\n例如：\n\nint[][] a=\n\n{\n\n{1,2,3,4,5},\n\n{1,2,3,4,6},\n\n{1,2,3,4,7}\n\n};\n\n\n\n行合并的规则为：两行中只相差一个数字，就把相差的数字进行合并，例如将a进行行合并处理后，变为：\n\nint[][] b=\n\n{\n\n{1,2,3,4,11},\n\n{1,2,3,4,7}\n\n};\n\n\n\n再对 b进行行合并后，变为：\n\nint[][] c=\n\n{\n\n{1,2,3,4,18}\n\n};\n\n\n\n请用java写出能实现合并规则，行数最多可能为5万。", "Tag": "算法分析"}
{"Answer": "max=b>max?b:max\r\n的意思是\r\nif (b > max)\r\nmax = b;\r\nelse\r\nmax = max;\r\n也就是如果b比max还大，那么用b作为新的max", "Konwledge_Point": "算法与数字", "Question": "一道C语言题目 看一下这个编程有些疑惑\n大概意思就是输入一组成绩 求最大 最小 平均值 \n\n看下这道提\n\n有个地方不明白\n  看一下有 问号的那两个地方\n\n\n\n就拿一个问号那句来说\n\n\n\n我不理解这程序是怎么一个运算顺序\n\n\n\n比如 b大于max不成立\n\n那么输出max", "Tag": "算法分析"}
{"Answer": "\n#include <string>\nint main() \n{ \n\tchar c;\n\tc=getchar();\n\tchar ch[80] = { 0 };\n\tgets(ch);\n\t\n\tint n = strlen(ch);\n\tint num = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (ch[i] == c)\n\t\t\tnum++;\n\t}\n\tprintf(\"字符%c出现的次数：%d\", c, num);\n\tprintf(\"%s\", ch);\n\treturn 0; \n} \n ", "Konwledge_Point": "算法与数字", "Question": "编写程序，输入一个以回车符结束的字符串（少于80字符），再输入一个字符，统计并输出该字符在字符串中出\n编写程序，输入一个以回车符结束的字符串（少于80字符），再输入一个字符，统计并输出该字符在字符串中出现的次数，然后再输出该字符串。", "Tag": "算法分析"}
{"Answer": "题主有一个重大的问题是，求字符串长度哪里，是没有\\0 的，导致你计算的长度有可能不准\n29行for循环用来判断小数前面是否有0，q记录第一个非0的位置，43行k不应该大于等于q吗修改前：\n修改后：\n改动如下：\n用你给的其他测试输入时没问题", "Konwledge_Point": "算法与数字", "Question": "为什么我有几个测试点过不了。给定一个数，请将该数各个位上数字反转得到一个新数。\n问题遇到的现象和发生背景\n\n\n给定一个数，请将该数各个位上数字反转得到一个新数。\n\n\n\n\n这次与 NOIp2011 普及组第一题不同的是：这个数可以是小数，分数，百分数，整数。整数反转是将所有数位对调；小数反转是把整数部分的数反转，再将小数部分的数反转，不交换整数部分与小数部分；分数反转是把分母的数反转，再把分子的数反转，不交换分子与分母；百分数的分子一定是整数，百分数只改变数字部分。整数新数也应满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数的最高位数字不应为零；小数新数的末尾不为 00（除非小数部分除了 00 没有别的数，那么只保留1个 00）；分数不约分，分子和分母都不是小数（约分滴童鞋抱歉了，不能过哦。输入数据保证分母不为 00），本次没有负数。\n\n\n题目描述\n给定一个数，请将该数各个位上数字反转得到一个新数。\n\n\n这次与 NOIp2011 普及组第一题不同的是：这个数可以是小数，分数，百分数，整数。\n\n\n整数反转是将所有数位对调。\n\n\n小数反转是把整数部分的数反转，再将小数部分的数反转，不交换整数部分与小数部分。\n\n\n分数反转是把分母的数反转，再把分子的数反转，不交换分子与分母。\n\n\n百分数的分子一定是整数，百分数只改变数字部分。\n\n\n输入格式\n一个实数 ss\n\n\n输出格式\n一个实数，即 ss 的反转数\n\n\n\n\n用代码块功能插入代码，请勿粘贴截图\n\n\n#include\n\n\n#include\n\n\nint\n main()\n{\n    \nchar\n a[\n10000\n];\n    gets(a);\n    \nint\n len = strlen(a);\n    \nint\n flag = \n0\n,count=\n0\n,count2=\n0\n;\n    \nfor\n (\nint\n i = \n0\n; i < len; i++)\n    {\n        \nif\n (a[i] == \n'.'\n) { flag = \n1\n; count = i; break; }\n        \nelse\n \nif\n (a[i] == \n'%'\n) { flag = \n2\n; count = i; break; }\n        \nelse\n \nif\n (a[i] == \n'/'\n) { flag = \n3\n; count = i; break; }\n        \nelse\n { flag = \n0\n; }\n    }\n    \nint\n count1 = count + \n1\n;\n        \nif\n (flag==\n1\n)\n        {\n            \nint\n j =count\n-1\n;\n            \nwhile\n (a[j]==\n'0'\n)\n            {\n                    j\n--;\n\n            }\n            \nfor\n (\nint\n k =j; k >=\n0\n; k\n--)\n\n            {\n                putchar(a[k]);\n            }\n            printf(\".\");\n            \nfor\n(\nint\n q=count+\n1\n;q= count1; k\n--)\n\n                {\n                    putchar(a[k]);\n                }\n            }\n            \nif\n (count2 == \n0\n)\n                putchar(\n'0'\n);\n        }\n        \nelse\n \nif\n (flag==\n3\n)\n        {\n            \nint\n j = count\n-1\n;\n            \nwhile\n (a[j] == \n'0'\n)\n            {\n                j\n--;\n\n            }\n            \nfor\n (\nint\n k = j; k >= \n0\n; k\n--)\n\n            {\n                \n/*printf(\"%c\", a[k]);*/\n\n                putchar(a[k]);\n            }\n            printf(\"/\");\n            j = len - \n1\n;\n            \nwhile\n (a[j] == \n'0'\n)\n            {\n                j\n--;\n\n            }\n            \nfor\n (\nint\n k = j; k > count; k\n--)\n\n            {\n                \n/*printf(\"%c\", a[k]);*/\n\n                putchar(a[k]);\n            }\n        \n/*    return 0;*/\n\n        }\n        \nelse\n \nif\n (flag==\n2\n)\n        {\n            \nint\n j = len - \n2\n;\n            \nwhile\n (a[j] == \n'0'\n)\n            {\n                j\n--;\n\n            }\n            \nfor\n (\nint\n k = j; k >= \n0\n; k\n--)\n\n            {\n                \n/*printf(\"%c\", a[k]);*/\n\n                putchar(a[k]);\n            }\n            \n/*printf(\"%\");*/\n\n            putchar(a[len - \n1\n]);\n            \n/*return 0;*/\n\n        }\n        \nelse\n \nif\n (flag == \n0\n)\n        {\n            \nint\n i = len - \n1\n;\n            \nwhile\n (a[i] == \n'0'\n)\n            {\n                i\n--;\n\n            }\n            \nfor\n (\nint\n j = i; j >= \n0\n; j\n--)\n\n            {\n                \n/*printf(\"%c\", a[j]);*/\n\n                putchar(a[j]);\n            }\n        }\n            \nreturn\n \n0\n;\n}\n\n\n\n\n运行结果及报错内容\n\n", "Tag": "算法分析"}
{"Answer": "首先 ，这是一个数学题；其次这肯定还要对y和x的差值分类（即下一层在此楼上还是下），可以使用分支语句，分支后根据给定的条件找出y的范围（y-x<x-B)）,y确定后就好办了；使用两重循环找出所有的组合，然后累加，当然期间还要去除相同排列的情况。\r\n另一种情况也相同。", "Konwledge_Point": "算法与数字", "Question": " c++算法题 坐电梯 数据结构\n小G 来到了著名的CIGOM 大厦。大厦一共有n 层，初始的时候小G 在第A\n\n层。小G 特别想去B 层小M 的办公室看一看，然而因为安保原因，B 层已经被\n\n封锁无法进入。\n\n但是小G 既然来了，就想在大厦里面逛一逛。大厦里面有一部电梯，小G 决\n\n定坐k 次电梯。因为小G 比较无聊，他给自己设定了这样一个规矩：假如当前他\n\n在x 层，则他要去的下一个楼层y 和x 的楼层差必须要小于x 和B 的楼层差。每到达一个楼层，小G 都要记录下来其楼层号。\n\n当小G 转完一圈后，他也记录下了k +1 个楼层号（可能有重复）。小G 现在想知道，按照他定下的规矩，一共有多少种可能的楼层号序列？\n\n\n\n输入格式\n\n\n\n输入文件一行，4 个数字n; A;B; k，含义如题目所述。\n\n\n\n输出格式\n\n\n\n输出一个数字，表示可能的楼层号序列的数量。答案对109 + 7 取模。\n\n\n\n样例输入\n\n5 2 4 1\n\n样例输出\n\n2", "Tag": "算法分析"}
{"Answer": "函数里 j 没有++的，始终是0位吗？", "Konwledge_Point": "算法与数字", "Question": "vs2019里的未定义标识符如何解决以及算法过程是否合理\n函数fun功能为依次取出字符串中所有数字字符，形成新的字符串，并取代原字符串\n\n\n\nclrscr（）显示未定义标识符如何处理（vs2019）\n\n\n\n这个程序是否还有其他的问题\n\n\n\n\n\n\n ", "Tag": "算法分析"}
{"Answer": "\n#include<iostream>\nusing namespace std;\nint house[10000] = { 0 };\nint nameToInt(string name) {\n    int res = 0;\n    for (char c : name) {\n        res += (c - 'a') + 1;\n    }\n    return res;\n}\nint nextValue(int v, int tryTime) {\n  /*  int n = tryTime / 2;\n    int sign = tryTime % 2 == 0 ? 1 : -1;\n    int add = n + 1;\n    return v + sign * add * add;*/\n    int add = tryTime + 1;\n    return v + add * add;\n}\nstring residents[10000];\nint main() {\n    int n, m, i, pathLength, tryTime = 0;\n    int value, oldvalue, newValue;\n    string name;\n    // n: 人数，m:房间\n    while (cin >> n >> m) {\n        i = value = 0;\n        pathLength = 0;\n        while (i++ < n) {\n            cin >> name;\n            value = nameToInt(name) % m;\n            pathLength += 1;\n            if (house[value]) {\n                tryTime = 0; oldvalue = value;\n                while (house[value]) {\n                    // 增量:+1 -1 +2^2 - 2^2 ...\n                    newValue = nextValue(oldvalue, tryTime);\n                    while (newValue < 0) {\n                        newValue += m;\n                    }\n                    value = (newValue) % m;\n                    //value = (value + 1) % m;\n                    pathLength += 1;\n                    tryTime += 1;\n                    if (tryTime > m) exit(-1);//全满\n                }\n            }\n            residents[value] = name;\n            house[value] = 1;\n        }\n        memset(house, 0, sizeof(int) * m);\n        for (i = 0; i < m; i++) {\n            cout << i << \":\" << (residents[i] != \"\" ? residents[i] : \"NULL\") << endl;\n            residents[i] = \"\";\n        }\n        printf(\"%.3lf\\n\", (1.0 * pathLength / (1.0 * n)));\n    }\n}\n", "Konwledge_Point": "算法与数字", "Question": "数据结构与算法“爸爸去哪儿”房子分配问题2\n题目描述\n\n\n最近“爸爸去哪儿”节目很火，据说新一期节目分房的策略有所改变:共有m间房，序号从0到m-1，村长根据每个小朋友的英 文名来分配房子。\n\n\n具体规则如下:\n\n\n每个小朋友的英文名都能得到一个对应的数值:‘a’数值为1，‘b’数值为2，…，‘z’数值为26，小朋友的英文名的数值为各个字母的数值和，比如kimi的英文名的数值为11+9+13+9=42。注:规定输入的英文名均为小写字母\n\n\n假设小朋友的英文名的数值为numName的话，那这个小朋友和他爸爸本期节目要住的房子就是(numName mod m)号房。\n如果某小朋友的numName mod m得到的值和之前的小朋友的一样，则用哈希中的平方探测法。\n\n\n分配完房子之后，村长想知道这个分房策略的平均查找长度是多少，也就是说村长根据这个策略来查找每个人的房子时，平均\n需要查找多少房子(结果保留三位小数)。\n\n\n比如有以下5个小朋友，并且有6间房:\n\n\n\n\n平均查找长度为:(1+1+1+2+2) / 5 = 1.400\n输入描述\n\n\n输入有多个测试用例，以EOF结束。\n\n\n对于每个测试用例，输入分两部分:\n\n\n第一部分是1行，有两个整数n和m(1<= n, m<=10,000)，中间用空格隔开，n代表有多少对明星父子参加节目，m代表一共 有多少间房\n\n\n第二部分是n行，每行都是一个小朋友的英文名，小朋友的英文名彼此都不同，且中间没有空格。每个小朋友的英文名不超过 10个字母，且均为小写字母\n输出描述\n\n\n对于每个测试用例，输出m+1行 前m行，每行为房子序号+“:”+要入住的小朋友的英文名，没有人入住则输出房子序号+“:NULL”\n\n\n第m+1行输出一个数字，表示平均查找长度，保留三位小数\n输入样例\n\n\n5 6\nkimi\ntiantian\nstone\nangela\ncindy\n\n\n输出样例\n\n\n0:kimi\n1:stone\n2:cindy\n3:NULL\n4:tiantian\n5:angela\n1.400\n\n\n给出代码，谢谢", "Tag": "算法分析"}
{"Answer": "staticint  intA=5float  f1 =  10.2ffloat  f2double  d  =  21.0char  c1=‘1’char  c2=‘’char  c3=‘’’", "Konwledge_Point": "算法与数字", "Question": "怎么用算法求大师指点\n将下列程序中的5个空按照注解的要求填写完整，然后阅读该程序，写出程序的运行结果，并与实际的运行结果进行比较。最后将填写完整的程序复制到用户代码框中提交。\npublic class Main {\n\n\npublic\n （填空\n1\n） \nvoid\n \nmain\n(\nString[] args\n)\n {\n//主方法main\n\n    （填空\n2\n）;\n// 声明一个初值为5的int类型变量intA\n\n    （填空\n3\n）\n// 声明两个float类型的变量f1和f2，f1的初值为实数10.2，f2没初值\n\n    （填空\n4\n）;\n// 声明一个初值为21.0的double类型变量d\n\n    （填空\n5\n）\n// 声明三个char类型的变量c1、c2、c3，初值分别为数字字符1、小写字母a、单引号'\n\n    \n    System.\nout\n.println(\n\"intA=\"\n+intA);\n    f2=\n2\n*f1;\n    System.\nout\n.println(\n\"f1=\"\n+f1+\n\",f2=\"\n+f2);\n    System.\nout\n.println(\n\"c1=\"\n+c1+\n\",c2=\"\n+c2+\n\",c3=\"\n+c3);\n}\n\n\n\n}", "Tag": "算法分析"}
{"Answer": "这个代码和前面的分析是意义对应的,\n\n \n#include <cstdio>\nint main()\n{\n    int nCases, nFeets;\n    while (scanf(\"%d\", &nCases) != EOF)//判定共有多少组输入\n    {\n        for (int i = 0; i < nCases; i++)\n        {\n            scanf(\"%d\", &nFeets);//扫描每一组输入中脚的数量\n            if (nFeets % 4 == 0)//如果能被4整除,则认为全是兔子\n                printf(\"%d%d\\n\", nFeets / 4, nFeets / 2);\n            else if (nFeets % 2 == 0)//否则,认为有1只鸡,剩余的全是兔子\n                printf(\"%d%d\\n\", nFeets / 4 + 1, nFeets / 2);\n            else\n                printf(\"0 0\\n\");//否则为奇数或0,认为没有合理情况,输出0 0\n        }\n    }\n    return 0;\n}\n \n", "Konwledge_Point": "算法与数字", "Question": "请问这个鸡兔同笼的算法如何理解呢？\n这个鸡兔同笼的算法我不是很理解，希望大家帮我解析一下代码，并举个实际数字的例子给我看一下，非常感谢！\n\n\n\n\n\n\n\n\n\n\n#\ninclude\n \n\n\n\n\nint\n \nmain\n()\n\n\n{\n    \nint\n nCases, nFeets;\n    \nwhile\n (\nscanf\n(\n\"%d\"\n, &nCases) != EOF)\n    {\n        \nfor\n (\nint\n i = \n0\n; i < nCases; i++)\n        {\n            \nscanf\n(\n\"%d\"\n, &nFeets);\n            \nif\n (nFeets % \n4\n == \n0\n)\n                \nprintf\n(\n\"%d%d\\n\"\n, nFeets / \n4\n, nFeets / \n2\n);\n            \nelse\n \nif\n (nFeets % \n2\n == \n0\n)\n                \nprintf\n(\n\"%d%d\\n\"\n, nFeets / \n4\n + \n1\n, nFeets / \n2\n);\n            \nelse\n\n                \nprintf\n(\n\"0 0\\n\"\n);\n        }\n    }\n    \nreturn\n \n0\n;\n}\n      \n\n", "Tag": "算法分析"}
{"Answer": "https://wenku.baidu.com/view/a9e63b7f7e21af45b307a8bd.html", "Konwledge_Point": "算法与数字", "Question": "比赛难度                         \nProblem Description\n\n　　最近，小明出了一些ACM编程题，决定在HDOJ举行一场公开赛。\n\n　　假设题目的数量一共是n道，这些题目的难度被评级为一个不超过1000的非负整数，并且一场比赛至少需要一个题，而这场比赛的难度，就是所有题目的难度之和，同时，我们认为一场比赛与本场题目的顺序无关，而且题目也不会重复。\n\n　　显而易见，很容易得到如下信息：\n\n　　假设比赛只用1个题目，有n种方案；\n\n　　假设比赛使用2个题目，有(n-1)*n/2种方案；\n\n　　假设比赛使用3个题目，有(n-2)*(n-1)*n/6种方案；\n\n　　............\n\n　　假设比赛使用全部的n个题目，此时方案只有1种。\n\n　　\n\n　　经过简单估算，小明发现总方案数几乎是一个天文数字！\n\n　　为了简化问题，现在小明只想知道在所有的方案里面第m小的方案，它的比赛难度是多少呢？\n\n\n\nInput\n\n输入数据的第一行为一个整数T（1 <= T <= 20），表示有T组测试数据。\n\n每组测试数据第一行为两个整数n, m（0 < n, m <= 10000），表示现在有n个题目，现在要求第m小的方案的比赛难度。接下来第二行有n个数字，分别表示这n个题目的难度值。\n\n\n\nOutput\n\n对于每组测试数据，输出一行\"Case #c: ans\"（不包含引号），ans 表示要求的第m小的比赛难度，输入数据保证存在第m小的方案，具体参见样例。\n\n\n\nSample Input\n\n2\n\n5 6\n\n1 1 1 1 1\n\n5 25\n\n1 2 3 4 5\n\n\n\nSample Output\n\nCase #1: 2\n\nCase #2: 11", "Tag": "算法分析"}
{"Answer": "2的（n-1）*(n-1)次方，到oj上试试", "Konwledge_Point": "算法与数字", "Question": "能给我看看这个算法题吗\n你有一个大小为n×n的矩阵, 你可以在矩阵中自由地填写数字\n\n\n假如将这个矩阵每个位置都填上0或1这两种数字, 不难计算: 共有2的(n×n)次方这么多种填写方案\n\n\n但是小度不喜欢偶数, 它希望矩阵的任意某行或任意某列的数字之和均为奇数\n\n\n那么按上述规则将n×n矩阵用0或1填满, 将有多少种方案去填写呢? 你能帮小度计算出来吗?\n\n\n答案可能很大, 请输出答案对1000000007 (10⁹+7)取模后的结果\n\n\n格式\n输入格式\n输入仅包含一个正整数n (1≤n≤109), 含义如题面所述\n输出格式\n输出一个非负整数, 含义如题面所述", "Tag": "算法分析"}
{"Answer": "遍历字符串，删除多余空格、数字和特殊字符，将大写字母转为小写，即可。运行结果：\n\n代码：\n#include <iostream>\n#include <string>\nusing namespace std;\n\n//判断字符是否是小写字母\nint islower(char c)\n{\n    if (c >= 'a' && c <= 'z')\n        return 1;\n    else\n        return 0;\n}\n//判断是否是大写字母\nint isupper(char c)\n{\n    if (c >= 'A' && c <= 'Z')\n        return 1;\n    else\n        return 0;\n}\n\n//判断是否是字母\nint isCharacter(char c)\n{\n    if (islower(c) || isupper(c))\n        return 1;\n    else\n        return 0;\n}\n\nint main()\n{\n    char a[100005] = { 0 };\n    int shift = 0;\n    while (cin.getline(a + shift, 100005 - shift) )\n    {\n        shift = strlen(a);\n        a[shift] = ' ';//每行后面加一个空格\n        shift++; \n    }\n    //删除最后添加的空格\n    while (shift>=0 && a[shift - 1] == ' ')\n    {\n        a[shift - 1] = 0;\n        shift--;\n    }\n    //遍历数组\n    int i = 0, j = 0;\n    while (isCharacter(a[i]) == 0) //过滤非字母\n        i++;\n    while (a[i] != '\\0')\n    {\n        if (islower(a[i]))\n            a[j++] = a[i];\n        else if (isupper(a[i])) //大写转小写\n            a[j++] = a[i] + 32;\n        else if (a[i] == ' ') //如果是空格\n        {\n            if (j > 0 && a[j-1] != ' ')//前一个字符不是空格\n                a[j++] = ' ';\n        }\n        else if (a[i] == '\\r' || a[i] == '\\n')//回车符\n        {\n            if (j > 0 && islower(a[j - 1]))\n                a[j++] = ' ';\n        }\n        i++;\n    }\n    a[j] = 0;\n    cout << a;\n    return 0;\n}\n\n\n", "Konwledge_Point": "算法与数字", "Question": "C++算法题求解（字符串）\n题目描述\n芭芭拉是西风教会的祈礼牧师，同时也是蒙德城的闪耀偶像。\n\n\n只要看到芭芭拉，心情就能变好。——蒙德城里流传着这样的说法。\n\n\n人们接受芭芭拉的歌声，逐渐被她的活力感染。\n\n\n和往常一样，芭芭拉即将登台表演，可她却突然发现自己的歌谱出现了问题，为了正常完成演出，请你能帮她复原歌谱。\n\n\n具体的，芭芭拉的歌谱被表示成一个字符串，这个字符串在标准的情况下仅由小写字 母和空格组成，并且连续的空格最多只能有一个。当前的歌谱由于某些原因，还含有 一些数字和大写字母，并且可能有多个连续空格和换行，所以当前的歌谱不标准。\n\n\n你需要将其还原成标准歌谱，形式化的，标准歌谱仅有小写字母和空格组成，开头不 包含空格，单词和单词之间由一个空格分开。\n\n\n注意换行符在 Windows 下为 \\r\\n 而不是\\n。\n\n\n输入格式\n若干行字符串\n\n\n输出格式\n一行字符串，表示标准歌谱\n\n\n样例\n【样例 1 输入】\nCor5ru2pt1 2 3 BinAry\ncodEs inFecting My\nmInd\n【样例 1 输出】\ncorrupt binary codes infecting my mind\n数据范围与提示\n特殊性质 A:不存在大写字母\n特殊性质 B:不存在数字\n特殊性质 C:不存在连续空格\n最大长度为10^5.\n\n\n希望给出代码！", "Tag": "算法分析"}
{"Answer": "下面是采用广度优先遍历的代码，我已经测试过了\r\n\r\n/*有一2维数组,比如:String[][] a={{1,2},{3},{4},{5,6}}; \r\n求这些数字一共可以组合多少种排列,并打印所有可能情况 \r\n比如上面的数字可以有这些情况:1345,1346,2345,2346 \r\n最好不要递归,速度要快! */\r\n\r\nimport java.util.LinkedList;\r\n//采用广度优先遍历\r\npublic class BroadFirst {\r\n\r\n\t//用于存储遍历情况的列表\r\n\tprivate LinkedList list=new LinkedList();\r\n\t//传入的参数\r\n\tprivate String[][] para=null;\r\n\t\r\n\tpublic BroadFirst(String[][] para){\r\n\t\tthis.para=para;\r\n\t\t//将第一个列表添加到遍历列表的前端\r\n\t\tfor(String str:this.para[0]){\r\n\t\t\tthis.list.addLast(str);\r\n\t\t}\r\n\t\t//产生序列\r\n\t\tthis.createSequence();\r\n\t}\r\n\t\r\n\tprivate void createSequence() {\r\n\t\tint innerLength = 1;\r\n\t\twhile (true) {\r\n\t\t\tString temp = this.list.pollFirst();\r\n\t\t\tinnerLength = temp.length();\r\n\t\t\t// 深度够了则执行完成\r\n\t\t\tif (innerLength == para.length) {\r\n\t\t\t\tthis.list.addFirst(temp);\r\n\t\t\t\treturn;\r\n\t\t\t} else {\r\n\t\t\t\tfor (String innerStr : this.para[innerLength]) {\r\n\t\t\t\t\t// 依次入队列的末端\r\n\t\t\t\t\tthis.list.addLast(temp + innerStr);\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic void printString(){\r\n\t\t\r\n\t\tfor(String str:this.list){\r\n\t\t\tSystem.out.println(str);\r\n\t\t}\r\n\t}\r\n\t//测试\r\n\tpublic static void main(String[] args) {\r\n\t\tString[][] temp={{\"1\",\"2\"},{\"3\"},{\"4\"},{\"5\",\"6\"},{\"7\",\"8\"}};\r\n\t\tBroadFirst bf=new BroadFirst(temp);\r\n\t\tbf.printString();\r\n\t}\r\n\r\n}", "Konwledge_Point": "算法与数字", "Question": "求2维数组有多少种排列的算法\n有一2维数组,比如:String[][] a={{1,2},{3},{4},{5,6}};\n\n求这些数字一共可以组合多少种排列,并打印所有可能情况\n\n\n\n比如上面的数字可以有这些情况:1345,1346,2345,2346\n\n\n\n最好不要递归,速度要快!", "Tag": "算法分析"}
{"Answer": "%利用扩展欧几里得算法求取e关于r的模反元素d\nif(mod(r,e)~=0)\n   [g,d,y]=gcd(e,r);\n   if d<0\n       d = d+r;\n   end\nend\n\nmatlab中gcd函数的第二个返回值才是要求的d，算出来的d有可能是负数，需要修正一下。RSA的详细过程参看：\n\n\n\n\n\nhttps://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html\n\n", "Konwledge_Point": "算法与数字", "Question": "matlb关于RSA算法加解密问题\nset(\n0\n,\n'RecursionLimit'\n,\n10000\n);\nclear all;\nclc;\n\n%-----------------------------------------------------\n\n\n%初始化生成1000以内的质数\n\nindex=\n1\n;\nzs(\n1\n)=\n2\n;\n\nfor\n \ni\n=\n3\n:\n1000\n\n  \nfor\n \nj\n=\n2\n:\ni\n-1\n\n      p=\nmod\n(\ni\n,\nj\n); \n%===i%j\n\n      \nif\n p==\n0\n\n         \nbreak\n;\n      \nelseif\n \nj\n==\ni\n-1\n\n         index=index+\n1\n;\n          zs(index)=\ni\n;  \n      \nend\n\n  \nend\n\n\nend\n\n\n%---------------------------------------------------\n\n\n%随机找出一个大的质数p\n\n\nwhile\n(\n1\n)\n \ni\n=\nrand\n()*(index\n-1\n);\n  \nif\n \ni\n>\n10\n\n     \nbreak\n;\n \nend\n\n\nend\n\n\n%---------------------------------------------------\n\n\n%随机找出一个大的质数q,且p！=q\n\n\nwhile\n(\n1\n)\n   \nj\n=\nrand\n()*(index\n-1\n);\n   \nif\n \nj\n>\n10\n && \nround\n(\nj\n+\n1\n)~=\nround\n(\ni\n+\n1\n)\n      \nbreak\n;\n   \nend\n\n\nend\n  \np=zs(\nround\n(\ni\n+\n1\n));\n%查表获得质数\n\nq=zs(\nround\n(\nj\n+\n1\n));\n%查表获得质数\n\n\n%-----------------------------------------------------\n\n\n%计算n\n\nn=p*q;\n\n%计算（p-1）*（q-1）----------------------------------\n\nr=(p\n-1\n)*(q\n-1\n);\n\n%----------------------------------------------------\n\n\n%随机取一个e，满足1\n\n\n%这里取的是质数，只要r不是e的倍数就满足条件。\n\n\nwhile\n(\n1\n)\n  \n  e=zs(\nround\n(\nrand\n()*(index\n-1\n))+\n1\n);\n%这里找出的e是质数\n\n   \nif\n(\nmod\n(r,e)~=\n0\n)   \n%只要r不是e的倍数就满足条件\n\n      \nbreak\n;\n   \nend\n\n\nend\n\n\n%---------------------------------------\n\n\n%利用扩张欧几里得算法求取e关于r的模反元素d\n\n\n\nif\n(\nmod\n(r,e)~=\n0\n)\n   d=\ngcd\n(e,r);\n\nend\n\n\n%--------------------------------------\n\n\n%得到公钥\n\nfprintf(\n'public key={n,e}={%d,%d} for encryption \\n'\n,n,e);\n\n%------------------------------------------------\n\n\n%得到私钥\n\nfprintf(\n'private key={n,d}={%d,%d} for decryption\\n'\n,n,d);\n\ndisp\n(\n'before encrypt,the info is:'\n);\n\n%-----------------------------------------\n\n\n%待加密的信息\n\ninfo=\n'Hello,I am a student'\n;\n\ndisp\n(info);\n\n%----------------------------------------\n\n\n%获得字符串长度\n\n[~,col]=\nsize\n(info);\n\n\nfor\n k=\n1\n:col\n  en_info(k)=sym(uint8(info(k)));\n\nend\n\n\ndisp\n(en_info);\n\n\n%数据采用公钥进行加密--------------------\n\ntic;\n%加密计时器开始\n\n\nfor\n k=\n1\n:col\n  tmp(k)=sym(\nmod\n(en_info(k)^e,n));\n\nend\n\n\ndisp\n(\n'after encrypted,the info is:'\n);\n\ndisp\n(tmp);  \ntoc;\n%加密计时器结束\n\n\n%数据采用私钥解密------------------------\n\ntic;\n%解密计时器开始\n\n\nfor\n k=\n1\n:col \n   den_info(k)=\nmod\n(tmp(k)^d,n);\n\nend\n\n\n%有符号数字转换成字符--------------------\n\n\nfor\n k=\n1\n:col \n  den_info_c(k)=uint8(den_info(k));\n\nend\n\n\ndisp\n(\n'after decrypted,the info is:'\n);\nfprintf(\n'%s\\n'\n,den_info_c);\n\ndisp\n(den_info);\ntoc;\n%解密计时器结束\n\n\n%--------------------------------------\n\nclear var;\nclear \nj\n;\nclear k;\nclear index;\nclear row;\nclear tmp;\nclear zs;\nclear info;\nclear col;\nclear \ni\n;\nclear den_info;\nclear den_info_c;\nclear en_info;\n\n\n\n\n\n编译结果\n\n\n\n\n解密的过程有些问题，解密之后显示的是一堆乱码，请问应该怎么解决呢，而且，不知道为什么解密的数字\n和加密时相同了，哪里出错了呢？该怎么改好，谢谢大家", "Tag": "算法分析"}
{"Answer": "建议如下图对象的初始化如果在循环体里面，每次重新进入循环是没有保存数据的，建议写在while 上面\n", "Konwledge_Point": "算法与数字", "Question": "创建的数组没有被查找算法找到\n问题遇到的现象和发生背景\n\n\n\n\n问题相关代码，请勿粘贴截图\n\n\npackage sheji;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport sheji.RecordNode;\nimport sheji.BSTree;\nimport sheji.KeyType;\nimport sheji.ElementType;\npublic \nclass\n action {\n    public static  void main(String\n[]\n args) {\n        boolean flag = \ntrue\n;\n        \nwhile\n (flag) {\n            \nSystem\n.\nout.println(\n\"=================================================\"\n);\n            \nSystem\n.\nout.println(\n\"请输入下列数字选择相应的操作：\"\n);\n            \nSystem\n.\nout.println(\n\"1.建立家谱成员信息\"\n);\n            \nSystem\n.\nout.println(\n\"2.查找家谱成员信息\"\n);\n            \nSystem\n.\nout.println(\n\"3.删除家谱成员信息\"\n);\n            \nSystem\n.\nout.println(\n\"4.退出\"\n);\n            \nSystem\n.\nout.println(\n\"=================================================\"\n);\n            \nSystem\n.\nout.print(\n\"输入的数字为：\"\n);\n            Scanner sc = \nnew\n \nScanner(System.\nin\n)\n;\n            \nint\n num = sc.next\nInt()\n;\n            BSTree bstree=\nnew\n \nBSTree()\n;\n            switch (num) {\n            case \n1\n:\n                String\n[]\nitem= {\n\"小明\"\n,\n                                \n\"小张\"\n,\n                                \n\"小李\"\n};\n                \nint\n[]\nk= {\n1002\n, \n1001\n,\n1003\n};   \n//关键字数组\n\n                KeyType\n[]\n key = \nnew\n KeyType\n[\nk\n. \nlength\n]\n; \n//关键字数组\n\n                ElementType\n[]\nelem=\nnew\n ElementType\n[\nk\n.\nlength\n]\n;  \n//记录数据数组\n\n                \nSystem\n.\nout.println(\n\"原序列:\"\n);\n                \nfor\n (\nint\n i = \n0\n; i<k. length; i++){\n                    key\n[\ni\n]\n = \nnew\n \nKeyType(\nk\n[\ni\n])\n;          \n//创建关键字对象\n\n                    elem\n[\ni\n]\n= \nnew\n \nElementType(\nitem\n[\ni\n])\n;  \n//创建记录数据对象\n\n                    \nif\n(bstree.insert\nBST(\nkey\n[\ni\n],\nelem\n[\ni\n])\n) {    \n//若插入对象成功\n\n                    \nSystem\n.\nout.println(\n\"[\"\n+key\n[\ni\n]\n+\n\",\"\n+elem\n[\ni\n]\n+\n\"]\"\n);\n                }\n                }\n            break;\n            case \n2\n:\n                \nSystem\n.\nout.println(\n\"\\n 中序遍历二叉排序树\"\n);\n                bstree.\nin\nOrderTraverse(\nbstree\n.\nroot\n)\n;\n                \nSystem\n.\nout.println\n()\n;\n                KeyType keyvalue =\nnew\n \nKeyType()\n;\n                keyvalue.key=\n1002\n;\n                RecordNode found =(RecordNode)bstree.search\nBST(\nkeyvalue\n)\n;\n                \nif\n(found!=null) {\n                    \nSystem\n.\nout.println(\n\"按编号查找:\"\n+keyvalue+\n\",成功！对应家族成员为:\"\n+found.element);\n                }\nelse\n {\n                    \nSystem\n.\nout.println(\n\"按编号查找:\"\n+keyvalue+\n\",失败！\"\n);\n                }\n                keyvalue.key=\n1003\n;\n                found=(RecordNode)bstree.search\nBST(\nkeyvalue\n)\n;\n                \nif\n(found!=null) {\n                    \nSystem\n.\nout.println(\n\"按编号查找:\"\n+keyvalue+\n\",成功！对应家族成员为:\"\n+found.element);\n                }\nelse\n {\n                    \nSystem\n.\nout.println(\n\"按编号查找:\"\n+keyvalue+\n\",失败！\"\n);\n                }\n            \n                break;\n            \n            case \n3\n:\n                bstree.\nin\nOrderTraverse(\nbstree\n.\nroot\n)\n;\n                \nSystem\n.\nout.println\n()\n;\n                KeyType keyvalue1 =\nnew\n \nKeyType()\n;\n                keyvalue1.key=\n1002\n;\n                found=(RecordNode)bstree.remove\nBST(\nkeyvalue1\n)\n;\n                \nif\n(found!=null) {\n                    \nSystem\n.\nout.println(\n\"删除编号：\"\n+keyvalue1+\n\"，成功删除：\"\n+found.element+\n\"!\"\n);\n                }\nelse\n {\nSystem\n.\nout.println(\n\"删除编号：\"\n+keyvalue1+\n\"，失败！\"\n);\n                \n                }\n                break;\n\n            default:\n                flag = \nfalse\n;\n                \nSystem\n.\nout.println(\n\"退出成功\"\n);\n                break;\n                }\n        }\n}\n\n}\n        \n\n        \n\n    \n            \n\n\n\n    \n\n    \n\n\n\n\n\n运行结果及报错内容\n\n\n\n\n我的解答思路和尝试过的方法\n\n\n是不是算法弄错了\n\n\n我想要达到的结果\n\n\n能够查找到并且删除对应对象", "Tag": "算法分析"}
{"Answer": "已完成，需要在代码的文件夹下新建一个graph.txt，内容如下\n\n\n# Python program for Kruskal's algorithm to find\n# Minimum Spanning Tree of a given connected,\n# undirected and weighted graph\n\n\n# Class to represent a graph\n\n\nclass Graph:\n\n    def __init__(self, vertices):\n        self.V = vertices  # No. of vertices\n        self.graph = []  # default dictionary\n        # to store graph\n\n    # function to add an edge to graph\n    def addEdge(self, u, v, w):\n        self.graph.append([u, v, w])\n\n    # A utility function to find set of an element i\n    # (uses path compression technique)\n    def find(self, parent, i):\n        if parent[i] == i:\n            return i\n        return self.find(parent, parent[i])\n\n    # A function that does union of two sets of x and y\n    # (uses union by rank)\n    def union(self, parent, rank, x, y):\n        xroot = self.find(parent, x)\n        yroot = self.find(parent, y)\n\n        # Attach smaller rank tree under root of\n        # high rank tree (Union by Rank)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n\n        # If ranks are same, then make one as root\n        # and increment its rank by one\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n\n    # The main function to construct MST using Kruskal's\n        # algorithm\n    def KruskalMST(self):\n\n        result = []  # This will store the resultant MST\n\n        # An index variable, used for sorted edges\n        i = 0\n\n        # An index variable, used for result[]\n        e = 0\n\n        # Step 1: Sort all the edges in\n        # non-decreasing order of their\n        # weight. If we are not allowed to change the\n        # given graph, we can create a copy of graph\n        self.graph = sorted(self.graph,\n                            key=lambda item: item[2])\n\n        parent = []\n        rank = []\n\n        # Create V subsets with single elements\n        for node in range(self.V):\n            parent.append(node)\n            rank.append(0)\n\n        # Number of edges to be taken is equal to V-1\n        while e < self.V - 1:\n\n            # Step 2: Pick the smallest edge and increment\n            # the index for next iteration\n            u, v, w = self.graph[i]\n            i = i + 1\n            x = self.find(parent, u)\n            y = self.find(parent, v)\n\n            # If including this edge does't\n            # cause cycle, include it in result\n            # and increment the indexof result\n            # for next edge\n            if x != y:\n                e = e + 1\n                result.append([u, v, w])\n                self.union(parent, rank, x, y)\n            # Else discard the edge\n\n        minimumCost = 0\n        print(\"Edges in the constructed MST\")\n        for u, v, weight in result:\n            minimumCost += weight\n            print(\"%d -- %d == %d\" % (u+1, v+1, weight))\n        print(\"Minimum Spanning Tree\", minimumCost)\n\n\n# Driver code\ndata = []\nwith open('graph.txt', mode='r', encoding='utf-8') as fp:\n    data = fp.readlines()\n    for i, item in enumerate(data):\n        data[i] = item.split(',')\n\nn = len(data)\ng = Graph(n)\nfor i in range(n):\n    for j in range(n):\n        g.addEdge(i, j, int(data[i][j]))\n\n# Function call\ng.KruskalMST()\n\n# This code is contributed by Neelam Yadav\n", "Konwledge_Point": "算法与数字", "Question": "如何插入txt， txt文件里面有matrix, 如何在python用minimum spanning tree 的算法来运行matrix， 并得出结果\n如何插入任意一个txt文件，txt文件里面有一个matrix，matrix可以是任意的， 例如， 5\n5， 6\n6.\n如何用minimum spanning tree 的kruskal算法来算出结果\n\n\n我的想法 要用到adj\n= numpy.loadtxt(\"graph.txt\", delimiter=',')\n这个公式来插入txt\n\n\n要用kruskal的方法计算minimum spanning tree， 但是那个matrix（或者说edge, wight)不是直接输在python code里面， 而是通过插入一个txt格式的文件，txt文件里面有matrix，例如：\n0,30,26,50,40\n30,0,24,40,50\n26,24,0,24,26\n50,40,24,0,30\n40,50,26,30,0\n这是55格式的\n也有可能是66格式， 不同数字。\n要求无论插入的txt文本里面有什么样的matrix，python code都可以运行\n\n\n我希望最后的output像这样\nFollowing are the edges in the constructed MST\n2 -- 3 == 4\n0 -- 3 == 5\n0 -- 1 == 10\nMinimum Cost Spanning Tree: 19\n可以参考 这个链接 \nhttps://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/\n\n\n并且希望output的顶点不是从0开始计， 而是从1开始\n像‘（0，2）’ 变成 “（1，3）”\n\n\n求解完整的算法", "Tag": "算法分析"}
{"Answer": "将所有员工编号是“A”开头的员工卡号更新为将字母“A”替换为数字“1”的员工编号：\nUPDATE ks_Card\nSET Card_ID = REPLACE(Card_ID, 'A', '1')\nWHERE Emp_ID IN (\n  SELECT Employee_ID FROM hr_EmployeeBase WHERE Employee_ID LIKE 'A%'\n);\n\n查询录用日期为2010年4月录用的员工：\n\nSELECT e.Employee_ID, e.Name, e.GetInDate\nFROM hr_EmployeeBase e\nWHERE YEAR(e.GetInDate) = 2010 AND MONTH(e.GetInDate) = 4;\n\n", "Konwledge_Point": "算法与数字", "Question": "数据库算法的设计问题\n员工资料表 表名：hr_EmployeeBase 包含字段：(Employee_ID(员工编号), Name(姓名), GetInDate(录入日期))\n员工ID卡表 表名：ks_Card 包含字段：(Card_ID(卡号), Emp_ID(员工编号))\n说明：两个表用Emp_ID和Employee_ID关联\n1.写SQL查询，把所有员工编号是“A”开头的员工卡号更新为将字母“A”替换为数字“1”的员工编号（如员工编号为“A0001”的员工卡号要更新为“10001”）\n2.写SQL查询录用日期为2010年4月录用的员工", "Tag": "算法分析"}
{"Answer": "```\r\n #include \r\nint main()\r\n{\r\n\tchar c;\r\n\tint letters=0,space=0,digit=0,other=0;\r\n\tprintf(\"请输入一行字符：\");\r\n\twhile ((c=getchar())!='\\n')\r\n\t{\r\n\t\tif (c >= 'a'&&c <= 'z' || c >= 'A'&&c <= 'Z')\r\n\t\t{\r\n\t\t\tletters++;\r\n\t\t}\r\n\t\telse if (c == ' ')\r\n\t\t{\r\n\t\t\tspace++;\r\n\t\t}\r\n\t\telse if (c >= '0'&&c <= '9')\r\n\t\t{\r\n\t\t\tdigit++;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tother++;\r\n\t\t}\r\n\t}\r\n\tprintf(\"字母数:%d\\n空格数:%d\\n数字数:%d\\n其他字符:%d\\n\",letters,space,digit,other);\r\n\treturn 0;\r\n}\r\n结果：\r\n请输入一行字符：I am a student 666.\r\n字母数:11\r\n空格数:4\r\n数字数:3\r\n其他字符:1\r\n请按任意键继续. . .\r\n```", "Konwledge_Point": "算法与数字", "Question": "一个让c语言新手无法理解的题\n输入一行字符，分别统计出其中英文字母、空格、数字和其他字符的个数。", "Tag": "算法分析"}
{"Answer": "string str1 = \"21314324234324324123123123\";\r\nstring str2 = \"21314312132132131232132131\";\r\n\r\n   21314324234324324123123123\r\n-  21314312132132131232132131//各位字符相互减法得到下面\r\n    0 0 0 0 0 0 1 2 1 0 2 2 -1 2 2 -1 3 -1 -1 1 0 -1 1 0 -1 2\r\n\t\t\r\n自己探索规律吧。", "Konwledge_Point": "算法与数字", "Question": "如何进行字符串数值比较（基础篇）\n例如C++\n\nstring str1 = \"21314324234324324123123123\";\n\nstring str2 = \"21314312132132131232132131\";\n\n\n\n这2条相同字符串长度的数值比较。\n\n看出str1比str2大。算法怎么实现、", "Tag": "算法分析"}
{"Answer": "commodity = []\nwhile True:\n    _ = input(\"输入的商品名称、价格、销量、成本[使用逗号或空格隔开],输入q或Q退出\")\n    if _.upper() == \"Q\":\n        break\n    _ = _.replace(' ',',').split(',')\n    \n    if len(_) != 4:\n        print(\"输入错误\")\n    else:\n        commodity.append({\n            \"商品名称\":_[0],\"价格\":float(_[1]),\"销量\":float(_[2]),\"成本\":float(_[3]),\n            \"利润\":(float(_[1]) - float(_[3])) * float(_[2]),\"销售额\":float(_[1]) * float(_[2])\n            })\nprint(\"利润排序\")\ncommodity.sort(key = lambda x:x[\"利润\"],reverse = True)\nfor i in commodity:\n    print(i)\nprint(\"销售额排序\")\ncommodity.sort(key = lambda x:x[\"销售额\"],reverse = True)\nfor i in commodity:\n    print(i)\n\n\n", "Konwledge_Point": "算法与数字", "Question": "设计小型商品销售统计系统\n针对现实场景,基于 python 设计小型商品销售统计系统,包括以下功能: 1.基于字典、列表,字符串、数字类型、 input 函数,记录用户输入的商品名称、价格、销量、成本数据 2.基于循环、字典、排序算法,根据商品的成本和销售额,计算商品的利润,然后按商品销售额和利润进行排序(从大到小)输出展示", "Tag": "算法分析"}
{"Answer": "字符串你要输入啥内容呀", "Konwledge_Point": "算法与数字", "Question": "求一下c语言的程序题\n问一下这个怎么改成输入字符串和数字 但是只用数字做后面平均值算法的程序呀\n\n\n#include \n#define N 5\nmain()\n{\nint a[N],i,n;\nfloat ave,sum=0;\nputs(\"个数n:\");\nscanf(\"%d\",&n);\nfor(i=0;i<n;i++)\n{\nscanf(\"%d\",&a[i]);\nsum=sum+a[i];\n}\nave=sum/n;\nprintf(\"\\n%d个数的平均值为:%.2f\\n\",n,ave);\nputs(\"\\n比平均值大的数为:\");\nfor(i=0;i<n;i++)\nif(ave<a[i])\nprintf(\"%d\\n\",a[i]);\n}", "Tag": "算法分析"}
{"Answer": "\nisHappy;\nfunction ans=isHappy\nn=input('输入数字:');\ntemp=[];\nwhile (n~=1)&&~in(n,temp)\n    temp(end+1)=n;\n    n=get_next(n);\nend\nif n==1\n    ans=true;\nelse\n    ans=false;\nend\nend\nfunction ans=get_next(n)\ns=0;\nwhile n>0\n    d=mod(n,10);\n    n=floor(n/10);\n    s=s+d^2;\nend\nans=s;\nend\nfunction ans=in(n,temp)\nfor i=1:length(temp)\n    if n==temp(i)\n        ans=true;\n        return;\n    end\nend\nans=false;\nend\n\n", "Konwledge_Point": "算法与数字", "Question": "关于#MATLAB#的问题，如何解决？\n用MATLAB编写一个算法来判断一个数n是不是快乐数\n「快乐数」定义为:对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为1, 也可能是无限循环但始终变不到1。如果可以变为1， 那么这个数就是快乐数。如果n是快乐数就返回True ;不是，则返回False 。", "Tag": "算法分析"}
{"Answer": "提供一种思路，不一定很好。先思考单一数列中按顺序取若干元素的最大值问题。这个问题的一种固定解法就是：在可以选择的范围内，选择最大的元素；如果有多个最大元素，选择最靠左的那个。举例，在2868734952中选择5个数字构成最大值。首先，第一个元素只能在最左边的\"286873\"中选出（因为再向右选的话剩余元素就凑不出4个数字了，也就是最后的结果凑不出5位数）。在\"286873\"中最大元素是8，我们选择尽可能靠左的“8”输出，然后剩下的序列变成\"68734952\"下一个元素只能在\"68734\"中选出，选8，剩下序列\"734952\"第3个元素只能在\"7349\"中选出，选9，剩下序列\"52\"依次类推。最后结果是88952。\n双数列要复杂的多，但是可以用类似的思路来处理它们。\n假设有数列A(1,n)={a1, a2, ... an}和B(1,m)={b1,b2,...,bm}，从中要选取K个元素。怎么做呢？显然，第1个元素要么从A(1,n)中给出，要么从B(1,m)中给出。所以，我们可以构造数列(A(1,n),B(1,m))={a1,a2,...,an,b1,b2,...bm}，从允许的范围内挑出最靠左边的最大元素f1（这个时候挑出的元素是A中的可能性大）。我们再构造一个数列(B(1,m),A(1,n))={b1,b2,...,bm,a1,a2,...an}，从允许的范围内挑出最靠左边的最大元素f2（这个时候挑出的元素是B中的可能性大）。如果f1<>f2，选择大的值输出，然后把A或B中该值以及左边的内容切除；如果f1=f2，且f1、f2都是A或都是B中的元素，则f1和f2必是同一个元素，把该元素输出，并在对应的数列中切除f1以及左边的所有元素;如果f1=f2，但是f1是ai, f2是bj，则当前步骤无法判断哪个值更合适，需要依次递归进行后续的切割后方能判断。\n大致的核心伪代码如下（偷懒起见，用char数组代表数列，用String代表输出的子序列）：\nchar[] A=....;char[[ B=....;int getMaxIndexInA(int ai, int bj, int L) {    //在{ai, ai+1,... an, bj, bj+1, ... bm}中，排除最右边的L-1个元素后，找最左边最大的元素，如果该元素属于A，返回其序号，否则返回-1。}int getMaxIndexInB(int ai, int bj, int L) {    //在{bj, bj+1, ... bm,ai, ai+1,... an}中，排除最右边的L-1个元素后，找最左边最大的元素，如果该元素属于B，返回其序号，否则返回-1。}\n//获取由序列{ai,...an}以及{bj,...,bm}之中的顺序最大子序列，返回其值。String getSubList(int ai, int bi, int L) throws Exception{  if (L<=0) {    return \"\";  }  int next_A_index = getMaxIndexInA(ai, bj, L);  int next_B_index = getMaxIndexInB(ai, bj, L);  if ((next_A_index<0) && (next_B_index<0)) {    throw new Exception(\"找不到解\");  }  if (next_A_index<0) {    String result = b[next_B_index];    result += getSubList(ai, next_B_index+1, L-1);  } else if (next_B_index<0) {    String result = a[next_A_index];    result += getSubList(next_A_index+1, bj, L-1);  } else {    String resultA = a[next_A_index];    resultA += getSubList(next_A_index+1, bj, L-1);    String resultB = b[next_B_index];    resultB += getSubList(ai, next_B_index+1, bj, L-1);    if (resutA<resultB) {        return resultB;    } else {        return resultA;    }  }\n}\nmain () {...getSubList(0, 0, L);...}", "Konwledge_Point": "算法与数字", "Question": "用java解决拼接最大数问题\n拼接最大数\n给定长度分别为 m 和 n 的两个数组，其元素由 0-9 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 k (k <= m + n) 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。\n\n\n求满足该条件的最大数。结果返回一个表示该最大数的长度为 k 的数组。\n\n\n说明: 请尽可能地优化你算法的时间和空间复杂度。\n\n\n示例 1:\n\n\n输入:\nnums1 =\n[3, 4, 6, 5]\n\n\nnums2 =\n[9, 1, 2, 5, 8, 3]\n\n\nk =\n5\n\n\n输出:\n[9, 8, 6, 5, 3]\n示例 2:\n\n\n输入:\nnums1 =\n[6, 7]\n\n\nnums2 =\n[6, 0, 4]\n\n\nk =\n5\n\n\n输出:\n[6, 7, 6, 0, 4]\n示例 3:\n\n\n输入:\nnums1 =\n[3, 9]\n\n\nnums2 =\n[8, 9]\n\n\nk =\n3\n\n\n输出:\n[9, 8, 9]", "Tag": "算法分析"}
{"Answer": "printf(\"%d %d %d\", i, j, shzi(i, j));这里，需要加一个\\n\nprintf(\"%d %d %d\\n\", i, j, shzi(i, j));//加上\\n回车，否则，所有输出都在一行了\n\n", "Konwledge_Point": "算法与数字", "Question": "c语言 The 3n + 1 problem ，可以通过样例，但依然错误。\n问题遇到的现象和发生背景\n\n\n问题相关代码，请勿粘贴截图\n\n\n请考虑以下算法以生成数字序列。以整数 n 开头。如果 n 为偶数，则除以 2。如果 n 为奇数，则乘以 3 并加 1。使用新值 n 重复此过程，并在 n = 1 时终止。例如，将为 n = 22 生成以下数字序列： 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1 推测（但尚未证明）对于每个整数 n，此算法将终止于 n = 1。尽管如此，这个猜想仍然适用于至少1， 000， 000的所有整数。对于输入 n，n 的循环长度是生成的数量，最多包括 1。在上面的示例中，循环长度 22 为 16。给定任意两个数字 i 和 j，您将确定 i 和 j 之间所有数字（包括两个端点）的最大循环长度。\n输入将由一系列整数对 i 和 j 组成，每行一对整数。所有整数将小于 1，000，000 且大于 0。\n对于每对输入整数 i 和 j，输出 i、j 的顺序与它们在输入中出现的顺序相同，然后是 i 和 j 之间整数的最大循环长度。这三个数字应用一个空格分隔，所有三个数字都在一行上，每行输入都有一行输出。\n样例输入\n1 10\n100 200\n201 210\n900 1000\n样例输出\n1 10 20\n100 200 125\n201 210 89\n900 1000 174\n\n\n运行结果及报错内容\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果\n\n\n#\ndefine\n _CRT_SECURE_NO_WARNINGS\n\n\n#\ninclude\n\n\n\nint\n \nshzi\n(\nint\n x, \nint\n y)\n;\n\nint\n \nmain\n()\n\n\n{\n    \nint\n i, j = \n0\n;\n    \nwhile\n (~\nscanf\n(\n\"%d %d\"\n, &i, &j))\n//while (scanf(\"%d%d\",&n,&m)!=EOF)也是为了没有输入时跳出循环。\n\n    {\n        \nshzi\n(i, j);\n        \nprintf\n(\n\"%d %d %d\"\n, i, j, \nshzi\n(i, j));\n    }\n    \nreturn\n \n0\n;\n}\n\nint\n \nshzi\n(\nint\n x, \nint\n y)\n\n\n{\n    \nint\n i = \n0\n;\n    \nint\n count = \n0\n;\n    \nint\n maxcount = \n0\n;\n    \nif\n (y < x)\n    {\n        \nint\n temp = \n0\n;\n        temp = x;\n        x = y;\n        y = temp;\n    }\n    \nfor\n (i = x; i <= y; i++)\n    {\n        \nint\n p = i;\n//保存i变量，不然后面i值变化了就没办法正常for循环了\n\n        \nif\n (i == \n1\n)\n//当i=1时不进入循环所以没办法算一次\n\n        {\n            count++;\n        }\n        \nelse\n\n        {\n            \nwhile\n (i != \n1\n)\n            {\n                \nif\n (i % \n2\n == \n0\n)\n                {\n                    i = i / \n2\n;\n                }\n                \nelse\n\n                {\n                    i = i * \n3\n + \n1\n;\n                }\n                count++;\n            }\n            count++;\n//i也算一次，但是while循环会忽略i\n\n        }\n        \nif\n (maxcount < count)\n        {\n            maxcount = count;\n        }\n        i = p;\n//赋值给i，继续正常循环\n\n        count = \n0\n;\n//清零，避免count一直加。才可以准确计算每个i的count\n\n    }\n    \nreturn\n maxcount;\n}\n\n", "Tag": "算法分析"}
{"Answer": "第二个代码只有两处地方有问题\n修改结果：\n\n#include<stdio.h>\nint main()\n{\n    int    a, z;\n    while (~scanf_s(\"%d%d\", &a, &z)) {\n        int    a1, z1, max = 1, q = 1;\n        //确保a1<z1\n        if (a > z) {\n            a1 = z;\n            z1 = a;\n        }\n        else {\n            a1 = a;\n            z1 = z;\n        }\n        for (int i = a1; i <= z1; i++) {\n\n            int j = i;\n            if (j == 1) { q == 1; }\n            while (j != 1)\n            {\n                if (j % 2 == 0) { j = j / 2; }\n                else { j = j * 3 + 1; }\n                q++;\n            }\n            if (max < q) {\n                max = q;\n            }\n            q = 1;\n        }\n        printf(\"%d %d %d\\n\", a, z, max);\n    }\n    return 0;\n}\n\n第一处是j是偶数的时候应该是j=j/2不是j=i/2，第二处是每次循环结束q要清空，不然会一直累加", "Konwledge_Point": "算法与数字", "Question": "The 3n + 1 problem两个代码的区别及对第二个进行修改\n问题\n        请考虑以下算法以生成数字序列。以整数 n 开头。如果 n 为偶数，则除以 2。如果 n 为奇数，则乘以 3 并加 1。使用新值 n 重复此过程，并在 n = 1 时终止。例如，将为 n = 22 生成以下数字序列： 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1 推测（但尚未证明）对于每个整数 n，此算法将终止于 n = 1。尽管如此，这个猜想仍然适用于至少1， 000， 000的所有整数。对于输入 n，n 的循环长度是生成的数量，最多包括 1。在上面的示例中，循环长度 22 为 16。给定任意两个数字 i 和 j，您将确定 i 和 j 之间所有数字（包括两个端点）的最大循环长度。\n输入：输入将由一系列整数对 i 和 j 组成，每行一对整数。所有整数将小于 1，000，000 且大于 0。\n输出：对于每对输入整数 i 和 j，输出 i、j 的顺序与它们在输入中出现的顺序相同，然后是 i 和 j 之间整数的最大循环长度。这三个数字应用一个空格分隔，所有三个数字都在一行上，每行输入都有一行输出。\n\n\n\n\n问题相关代码，请勿粘贴截图\n\n\n//可行代码\n\n\n#\ninclude\n\n\n\n#\ndefine\n max(a,b) ((a>b) ? a : b)\n\n\n#\ndefine\n min(a,b) ((a \n1\n) {\n        \nif\n (i % \n2\n==\n1\n)\n            i = i * \n3\n + \n1\n;\n        \nelse\n\n            i = i / \n2\n;\n        ans++;\n    }\n    \nreturn\n ans;\n}\n\nint\n \nmain\n()\n\n\n{\n    \nint\n    a, z,m;\n    \nwhile\n (~\nscanf_s\n(\n\"%d%d\"\n, &a, &z)) {\n        m = \n1\n;\n        \nfor\n (\nint\n i = \nmin\n(a, z); i <= \nmax\n(a, z); i++) {\n            m = \nmax\n(m, \nnum\n(i));\n        }\n        \nprintf\n(\n\"%d %d %d\\n\"\n, a, z, m);\n    }\n    \n    \nreturn\n \n0\n;\n}\n\n\n\n\n//不可行代码\n\n\n#\ninclude\n\n\n\nint\n \nmain\n()\n\n\n{\n    \nint\n    a, z;\n    \nwhile\n (~\nscanf_s\n(\n\"%d%d\"\n, &a, &z)){\n    \nint\n    a1, z1,max = \n1\n,q=\n1\n;\n    \n//确保a1 z) {\n        a1 = z;\n        z1 = a;\n    }\n    \nelse\n {\n        a1 = a;\n        z1 = z;\n    }\n    \nfor\n (\nint\n i = a1; i <= z1; i++) {\n        \n        \nint\n j = i;\n        \nif\n (j == \n1\n) { q == \n1\n; }\n        \nwhile\n (j!=\n1\n)\n        {\n            \nif\n (j % \n2\n == \n0\n) { j = i / \n2\n; }\n            \nelse\n { j = j * \n3\n + \n1\n;  }\n            q++;\n        }\n        \nif\n (max < q) {\n            max = q;\n        }\n    }\n    \nprintf\n(\n\"%d %d %d\\n\"\n, a, z, max);\n    }\n    \nreturn\n \n0\n;\n}\n\n\n\n\n\n运行结果及报错内容\n\n\n\n\n我想要达到的结果\n\n\n这两个代码有什么不同？为什么第二个代码不行？如何更改？", "Tag": "算法分析"}
{"Answer": "1.continue之前不要执行++操作，这里不仅是第3层有问题，第2层也是错的2.如果不是要求你输出所有组合，而只是问组合数，直接套用排列组合公式就行了", "Konwledge_Point": "算法与数字", "Question": "无重复组合（Java）\n题目：使用for循环，在控制台输出由4.5.6.7能组成多少个互不相同且无重复数字的三位数？都是多少？\n\n\n以下仅主方法代码\n\n\npublic\n \nstatic\n \nvoid\n main(String[] args) {\n        \n// TODO 自动生成的方法存根\n\n        \nint\n value;\n//计算互不相同且无重复数字的三位数的数量\n\n        value=\n4\n*\n3\n*\n2\n;\n        \nint\n \nsum\n=\n0\n;\n        System.out.println(\n\"能组成\"\n+value+\n\"个互不相同且无重复数字的三位数\"\n);\n        \nfor\n(\nint\n i=\n4\n;i<=\n7\n;i++)\n        {\n            \nsum\n=i*\n100\n;\n            \nfor\n(\nint\n j=\n4\n;j<=\n7\n;j++)\n            {\n                \nif\n(i==j)\n                {\n                    j++;\n                    \ncontinue\n ;\n                }\n                \nsum\n=\nsum\n+j*\n10\n;\n                \nfor\n(\nint\n k=\n4\n;k<=\n7\n;k++)\n                {\n                    \nif\n(i==k||j==k)\n                    {\n                        k++;\n                        \ncontinue\n ;\n                    }\n                    \nsum\n=\nsum\n+k;\n                    System.out.println(\nsum\n);\n                }\n            }\n        }\n    }\n\n\n\n\n经过断点调试发现第三个for循环有问题，哪位能指出我的算法错误？", "Tag": "算法分析"}
{"Answer": "（1）int bubble(int *p,int j; 这里，你最后漏了一个）应该是：\nint bubble(int *p,int j); \n\n\n（2）C语言不支持变量定义数组长度，题目说明n不大于10 了，数组直接用int ch[10];就可以了。（3）冒泡排序内循环错误，for(y=0;y<=j-x-1;y++)应该是：\nfor(y=0;y<j-x-1;y++) //不是<=是<\n\n\n冒泡排序的外循环：for(x=0;x<j;x++)最好改成for(x=0;x<j-1;x++)\n代码修改如下：\n#include <stdio.h>\nint bubble(int *p,int j);               //\"bubble\" means using bubble sort \nint main()\n{\n    int number,i;\n    int z;        //\"number\" is the number you want\n    int ch[10];  \n\n    scanf(\"%d\",&number);\n    \n    for(i=0;i<number;i++)       //i is used to put the number into array \n    {\n        scanf(\"%d\",&ch[i]);\n    }\n    bubble(ch,number);     // make the array to the function \"ch\"\n    for(z=0;z<number;z++)\n    {\n        printf(\"%d\",ch[z]);\n        if(z!=(number-1))\n        {\n            printf(\" \");      //do the \" \" thing\n        }\n    }\n    return 0;\n} \nint bubble(int *p,int j)\n{    \n    int x,y;                   //these variable are used to do the bubble sort\n    int t;                         //t is used to exchange variables\n    for(x=0;x<j-1;x++) //这里最好用x<j-1，虽然用x<j也可以，但是在有些平台提交的时候会报错\n    {\n        for(y=0;y<j-x-1;y++)\n        {\n            if(p[y]<=p[y+1])\n            {\n                t=p[y+1];\n                p[y+1]=p[y];\n                p[y]=t;\n            }\n        }\n    }\n    return 0;\n}\n\n\n", "Konwledge_Point": "算法与数字", "Question": "c语言冒泡排序：我在做选择排序但是我不知道为什么他前面会给我一个奇怪的数字？\n这是题目：\n\n\n#include \n\n\nint\n bubble(\nint\n *p,\nint\n j;               //\"bubble\" means \nusing\n bubble sort \n\nint\n main()\n{\n    \nint\n number,i;\nint\n z;        //\"number\" \nis\n the number you want\n    scanf(\"%d\",&number);\n    \nint\n ch[number];           //q \nis\n quantity \nof\n the \narray\n\"ch\"\n    \nfor\n(i=\n0\n;i<number;i++)       //i \nis\n used \nto\n put the number \ninto\n \narray\n \n    {\n        scanf(\"%d\",&ch[i]);\n    }\n    bubble(ch,number);     // make the \narray\n \nto\n the \nfunction\n \"ch\"\n    \nfor\n(z=\n0\n;z<number;z++)\n    {\n        printf(\"%d\",ch[z]);\n        \nif\n(z!=(number\n-1\n))\n        {\n            printf(\" \");      //\ndo\n the \" \" thing\n        }\n    }\n    \n    \nreturn\n \n0\n;\n } \n \nint\n bubble(\nint\n *p,\nint\n j)\n {    \n \nint\n x,y;                   //these variable are used \nto\n \ndo\n the bubble sort\n \nint\n t;                         //t \nis\n used \nto\n exchange variables\n     \nfor\n(x=\n0\n;x<j;x++)\n     {\n         \nfor\n(y=\n0\n;y<=j-x\n-1\n;y++)\n         {\n             \nif\n(p[y]<=p[y+\n1\n])\n             {\n                 t=p[y+\n1\n];\n                 p[y+\n1\n]=p[y];\n                 p[y]=t;\n             }\n         }\n     }\n }\n\n\n\n\n两个例子，为什么会有差别？\n对的：\n\n\n错的：", "Tag": "算法分析"}
{"Answer": "是对线条样式更精确的控制，元组的元素分别表示：3pt 线、5pt 空间、1pt 线、5pt 空间...，0表示没有偏移量。参考：https://matplotlib.org/stable/gallery/lines_bars_and_markers/linestyles.html", "Konwledge_Point": "算法与数字", "Question": "lstype = ['-','--',(0, (3, 5, 1, 5, 1, 5)),':','-.']请问这句代码什么意思？\n用聚类算法分析数据后，生成聚类中心雷达图\n lstype = ['-','--',(0, (3, 5, 1, 5, 1, 5)),':','-.']  #这句代码什么意思？\n        for p in range(len(kinds)):\n        ax.plot(angle, centers[p], linestyle=lstype[i]，label=kinds[p])\n 这句代码设计线条样式，中间的数字什么意思，是什么格式？", "Tag": "算法分析"}
{"Answer": "http://www.lxway.com/4084220604.htm", "Konwledge_Point": "算法与数字", "Question": "统计若干个大型英文txt文件中所有单词出现的次数，并输出出现次数最多的前10个单词及其出现次数\n统计若干个大型英文txt文件（如英文小说）中所有单词出现的次数，并输出出现次数最多的前10个单词及其出现次数。\n\n\n\n单词字符定义为大小写字母、数字和下划线，\n\n其他字符均看作单词分隔符；\n\n自行设计合适的数据结构及相关算法；\n\n程序运行结束时将txt文件名以及统计结果写入磁盘； \n\n每次程序启动时（除了首次运行）将上次的结果读入内存、显示；\n\n能根据用户选择实现重新初始化、查找某单词出现次数、追加统计、退出等功能。", "Tag": "算法分析"}
{"Answer": "感觉你的描述就是计算交叉熵(Cross Entropy)\r\n\r\nhttps://blog.csdn.net/tsyccnh/article/details/79163834", "Konwledge_Point": "算法与数字", "Question": "机器学习中分类器验证AUC值不理想，能否比较验证集实际频率和预测概率均值来说明模型准确性。\n大家好，我目前在用一批土壤数据做二分类模型，尝试了随机森林、SVM、逻辑斯蒂回归、朴素贝叶斯等常用分类算法，但是结果不太理想。不理想指的是采用常规的ROC曲线法进行模型精度验证时，曲线基本就在0.5随机线附近，AUC也就0.53左右的样子。\n\n之前看到过一篇关于贝叶斯概率预测模型的文章（Wu Bo, 2018），他在检验模型准确性时没有采取ROC曲线法或类似基于混淆矩阵的方法，而是把验证数据集当作一个整体，计算了两个分类各自的频率，然后将验证数据集参数的平均值带入训练好的贝叶斯模型，求出一个后验概率，通过比较后验概率与实际频率，来说明模型的好坏。\n\n于是尝试用这种思路，去把我的验证数据集每个样本带入模型计算得到的那个数字（例如贝叶斯和逻辑斯蒂回归都可以给出后验概率）求平均，发现这个平均数确实和实际两个类别的频率很接近。我又通过改变数据的分类阈值（比如说原来是170cm以上算高个，现在调整成160就是高个儿），发现不同阈值下求得的这个平均数和相应的实际频率都很一致。\n\n本人数学底子挺差的，不知道这种验证方法是否可行？如果可行的话，后面是什么原理？能否指点个参考文献？如果不行的话，又是为什么呢？", "Tag": "算法分析"}
{"Answer": "char A[] = \"\";你没有给数组指定大小啊既然输入表达式格式都是固定的，那这么写就可以了int A,B,C,D,E,F;scanf(\"%dx+%dy=%d,%dx+%dy=%c\",&A,&B,&C,&D,&E,&F);", "Konwledge_Point": "算法与数字", "Question": "C语言char字符串里的数字转换成int就变成0了，有的不变0，同样的数据，不知道哪里有问题\nchar转换为int，数据变成0，不知道哪里出错了\n六个数据，同样的方法，成功了一个\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n//Ax+By=C\n\n\n//Dx+Ey=F\n\n\n//x=(CE-BF)/(AE-bD)\n\n\n//y=(CD-AF)/(BD-aE)\n\n\nint\n \nmain\n()\n{\n    \nchar\n A[] = \n\"\"\n;\n    \nchar\n B[] = \n\"\"\n;\n    \nchar\n C[] = \n\"\"\n;\n    \nchar\n D[] = \n\"\"\n;\n    \nchar\n E[] = \n\"\"\n;\n    \nchar\n F[] = \n\"\"\n;\n    \nprintf\n(\n\"请按照以下格式输入方程组 Ax+By=C;Dx+Ey=F\\n\"\n);\n    \nchar\n str[\n32\n] = \n\"\"\n;\n    \nscanf\n(\n\"%s\"\n,str);\n    \nprintf\n(\n\"方程组为 %s\\n\"\n, str);\n    \nsscanf\n(str,\n\"%[^x]\"\n,A);\n    \nprintf\n(\n\"%s\\n\"\n, A);\n    \nsscanf\n(str,\n\"%*[^+]+%[^y]\"\n,B);\n    \nprintf\n(\n\"%s\\n\"\n, B);\n    \nsscanf\n(str,\n\"%*[^=]=%[^;]\"\n,C);\n    \nprintf\n(\n\"%s\\n\"\n, C);\n    \nsscanf\n(str,\n\"%*[^;];%[^x]\"\n,D);\n    \nprintf\n(\n\"%s\\n\"\n, D);\n    \nsscanf\n(str,\n\"%*[^;]%*[^+]+%[^y]\"\n,E);\n    \nprintf\n(\n\"%s\\n\"\n, E);\n    \nsscanf\n(str,\n\"%*[^;]%*[^=]=%s\"\n,F);\n    \nprintf\n(\n\"%s\\n\"\n, F);\n    \nint\n num1, num2, num3, num4, num5, num6, x, y;\n    num1 = \natoi\n(A);\n    num2 = \natoi\n(B);\n    num3 = \natoi\n(C);\n    num4 = \natoi\n(D);\n    num5 = \natoi\n(E);\n    num6 = \natoi\n(F);\n    \nprintf\n(\n\"%d\\n\"\n,num1);\n    \nprintf\n(\n\"%d\\n\"\n,num2);\n    \nprintf\n(\n\"%d\\n\"\n,num3);\n    \nprintf\n(\n\"%d\\n\"\n,num4);\n    \nprintf\n(\n\"%d\\n\"\n,num5);\n    \nprintf\n(\n\"%d\\n\"\n,num6);\n    \n//x = (num1 * num5 -num2 * num6) / (num1 * num5 - num2 * num4);\n\n    \n//printf(\"%d,\",x);\n\n    \n//x=(CE-BF)/(AE-bD)\n\n    \n//y=(CD-AF)/(BD-aE)\n\n    \nreturn\n \n0\n;\n}\n\n\n\n\n我尝试了重新写一个简单的，结果成功了，但这个不知道哪里错\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\nint\n \nmain\n()\n\n\n{\n     \nchar\n b[\n18\n];\n     \nint\n num;\n     \nscanf\n(\n\"%s\"\n,b);\n//对char型数组进行赋值 如：123456789\n\n     num = \natoi\n(b);\n     \nprintf\n(\n\"%d\"\n,num);\n     \nint\n C = num + \n10\n;\n     \nprintf\n(\n\"%d\"\n,C);\n     \n     \n    \nreturn\n \n0\n;\n } \n\n\n\n\n\n\n请教大家了，还有这个系数为1又怎么检测，做了好长时间了", "Tag": "算法分析"}
{"Answer": "1.\ns=1\nfor i in range(0,9436):\n    if i%2==1:\n        s*=i\nprint(s)\n\n2.\nx1=int(input())\nx2=int(input())\nx3=int(input())\nif x1+x2==x3 or  x1+x3==x2 or x3+x2==x1 :\n    print('yes')\n\n\n3.\nfor i in range(2,3804578900232):\n    if 3804578900232%i==0:\n        print(i,end='')\n\n4.\ns=input()\nt=[]\nfor i in range(len(s)):\n    if s[i]=='f':\n        t.append(i)\nif len(t)==1:\n    print(t[0])\nelse:\n    print(t[0])\n    print(t[len(t)-1])\n    \n\n5.\ndef extra_same_elem(list1, list2):\n    set1 = set(list1)\n    set2 = set(list2)\n    iset = set1.intersection(set2)\n    return list(iset)\n \nlst1 = [1,2,3]\nlst2 = [2,3,4]\nlst = extra_same_elem(lst1, lst2)\nlst.sort() #对结果排一下序，方便查看\nprint(lst)\n\n6.\n\ndef l(n):\n    if n==1:\n        return 1\n    else:\n        return n*l(n-1)\nprint(l(100))\n\n", "Konwledge_Point": "算法与数字", "Question": "业务分析编程的基础知识 IDLE\n1）将所有0到9435之间的奇数值相乘。\n2）给出三个数字。如果可以取其中任何两个加起来变成第三个，则输出«yes«。\n3）列出数字3804578900232的所有正因数。\n4) 给出一个字符串。如果在这一行中f只出现一次，则输出其索引。如果它出现两次或更多次，则打印其第一次和最后一次出现的索引。如果字母f没有出现在给定的行中，则不打印。\n5）有两份列表。找出第一和第二份列表中都出现的单词。\n6）计算函数F(n)值的算法，其中n是自然数，由以下比率给出：\n     F（1）=1\nF(n) = F(n–1) * n，在 n >1\n函数F（100）的值是多少？\n使用子程序", "Tag": "算法分析"}
{"Answer": "\n#include <bits/stdc++.h>\nusing namespace std;\nclass Solution\n{\npublic:\n    void nextPermutation(vector<int> &nums)\n    {\n        if (nums.size() < 2)\n        {\n            return;\n        }\n        int i = nums.size() - 2;\n        while (i >= 0 && nums[i] >= nums[i + 1])\n        {\n            i--;\n        }\n        if (i >= 0)\n        {\n            int j = nums.size() - 1;\n            while (nums[j] < nums[i])\n            {\n                j--;\n            }\n            swap(nums.begin() + i, nums.begin() + j);\n        }\n        reverse(nums.begin() + i + 1, nums.end());\n    }\n};\n", "Konwledge_Point": "算法与数字", "Question": "用C++解决下一个排列问题\n下一个排列\n实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。\n\n\n如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。\n\n\n必须 原地 (\nhttps://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)修改，只允许使用额外常数空间。\n\n\n示例 1：\n\n\n输入：nums = [1,2,3]\n输出：[1,3,2]\n示例 2：\n\n\n输入：nums = [3,2,1]\n输出：[1,2,3]\n示例 3：\n\n\n输入：nums = [1,1,5]\n输出：[1,5,1]\n示例 4：\n\n\n输入：nums = [1]\n输出：[1]\n\n\n提示：\n\n\n1 <= nums.length <= 100\n0 <= nums[i] <= 100", "Tag": "算法分析"}
{"Answer": "这种东西最好看产品手册，这玩意儿又不是人手一台，要找个用过的人恐怕不容易吧。", "Konwledge_Point": "算法与数字", "Question": "低功耗多通道WFAS1431无线数据采集采发仪的功耗是多少？\n 工程监测为野外恶劣自然环境和条件下开发的一种集太阳能充电、低功耗、防雷、接口齐备的一体化智能无线采控设备。\n整个设备由供电模块、任务管理模块、功耗管理模块、无线模块、数字接口模块、模拟接口模块、防雷模块、系统控制模块、状态扫描模块及报警模块构成，固件程序采用UCOSGUI多任务实时操作系统及程序算法，整个设备运行可靠，可以实现长时间野外工作。\n常年野外工作，就需要低功耗的设备，可以常年稳定数据采集传输。\n\n", "Tag": "算法分析"}
{"Answer": "[http://blog.csdn.net/wyxeainn/article/details/52451155?locationNum=2&fps=1](http://blog.csdn.net/wyxeainn/article/details/52451155?locationNum=2&fps=1 \"\")", "Konwledge_Point": "算法与数字", "Question": "数塔                              \nProblem Description\n\n在讲述DP算法的时候，一个经典的例子就是数塔问题，它是这样描述的：\n\n\n\n有如下所示的数塔，要求从顶层走到底层，若每一步只能走到相邻的结点，则经过的结点的数字之和最大是多少？\n\n已经告诉你了，这是个DP的题目，你能AC吗?\n\n\n\nInput\n\n输入数据首先包括一个整数C,表示测试实例的个数，每个测试实例的第一行是一个整数N(1 <= N <= 100)，表示数塔的高度，接下来用N行数字表示数塔，其中第i行有个i个整数，且所有的整数均在区间[0,99]内。\n\n\n\nOutput\n\n对于每个测试实例，输出可能得到的最大和，每个实例的输出占一行。\n\n\n\nSample Input\n\n1\n\n5\n\n7\n\n3 8\n\n8 1 0 \n\n2 7 4 4\n\n4 5 2 6 5\n\n\n\nSample Output\n\n30", "Tag": "算法分析"}
{"Answer": "1.你如果能保证1_X在3_X前面，就声明一个变量，保存截取的第一个字符，如果当前截取的和之前的不一样就说明已经循环到了下一个时间段。这样就能获得你要的结果。\r\n2.如果不能保证，就把截取的第一个字符放到Map中，key就是你的第一个字符，value就是拼接的字符，每次先拿截取的第一个字符串查询Map中的值，有就拼接，没有就添加一个。", "Konwledge_Point": "算法与数字", "Question": "java如何从一个指定的字符串截取相同格式的子字符串\nHi,\n\n\n\n我在做一个Web请假（图表操作形式）\n\n   老师通过点击表格列选中，表示这个时间请假。\n\n   当老师在一周的表格上点了很多下的时候，Jquery通过样式查找得到\n\n 老师选中的时间片ID,形如 (1_1,1_2,1_3,3_3,3_4,3_5)这样一个字符串。\n\n这个形式表示老师星期一，1,2,3节课请假，星期三，3,4,5节课请假。\n\n   因为我在数据里要插入2条记录。\n\n   所以要把(1_1,1_2,1_3,3_3,3_4,3_5)分割成(1_1,1_2)(3_3,3_4,3_5)这2个字符串。\n\n   请问有什么好的算法没有?\n\n   我的想法：1.分割成数组all[]遍历，把_前的数字找出来。去掉重复，\n\n               放到一个临时数组 pre[].\n\n           2.创建数组temp[pre.length]。\n\n                再双重遍历all[]与pre[]，\n\n               遍历的时候\n\n               if(all[i].startWith(pre[j]))\n\n                   temp[j]+=all[i]+\",\"\n\n           3.最后得到的temp[]就是要的结果？\n\n\n\n总感觉有点麻烦。求更好的算法.\n", "Tag": "算法分析"}
{"Answer": "欢迎采纳，这段代码的功能是将给定的数字 n 翻转过来，比如 n 是 1234，那么最终的输出 s 就会是 4321。为什么要使用这行代码 s = s * 10 + n % 10 ？因为%运算得到的是余数，当n的值不断除以10，余数就是每一位上的数字，乘以10则可以实现数字翻转。举个1234例子如果给定的数字是1234，最初 s 等于 0（ s=0），所以 n % 10 结果是 4，然后将 n%10 的结果加到 s 上，即 s = 0 + 4，此时 s 的值为4。接着，n 除以10，就变成了 123，此时，n % 10 结果是 3，将 n % 10 的结果再加到s上，即 s = 4 * 10 + 3，此时 s 的值为43。在继续循环直到 n 变为 0，即可得到最终的结果 s = 4321，也就是翻转后的结果。", "Konwledge_Point": "算法与数字", "Question": "c语言。输出该整数对应的反向数。\n从键盘上输入一整数（int范围内），输出该整数对应的反向数。\n\n\n比如输入3486，则输 出6843。\n请注意，输出的6843是一个数，不能只是将每个位上的数字打印出。\n\n\n如果输入数字以0结 束，则反向数不需要输出前导0。\n输入格式：\"%d\" 输出格式：\"%d\"\n程序运行结果示例1：\n输入：20220115\n输出：51102202\n程序运行结果示例2：\n输入：150\n输出：51\n\n\nwhile(n)<-这里n是在干嘛？\n    {\n        s = s * 10 + n % 10;          <-这里的算法又是在干嘛？？？\n        n/=10;\n    }\n\n\n可以详细解答一下代码的意思吗？\n\n\n\n\n#\ninclude\n\n\n\nint\n \nmain\n()\n\n\n{\n    \nint\n n;\n    \nint\n s = \n0\n;\n    \nscanf\n(\n\"%d\"\n,&n);\n    \nwhile\n(n)                          \n//(n)?\n\n    {\n        s = s * \n10\n + n % \n10\n;          \n//为什么？？这是在干嘛？\n\n        n/=\n10\n;\n    }\n    \nprintf\n(\n\"%d\"\n,s);\n    \nreturn\n \n0\n;\n}\n\n", "Tag": "算法分析"}
{"Answer": "Members={'Hugo':['Brijht','M'],'Mary':['Pretty','F'],'John':['CowBoy','M'],'Jerry':['Smart','M'],'Anna':['Lucky','F']}\nm=0\nf=0\nfor i,j in Members.items():\n    if Members[i][1]=='M':\n        m+=1\n    else :\n        f+=1\n    t=Members[i][0].lower()\n    s=''\n    for k in t:\n        s+=str(ord(k)%10)\n    Members[i][0]=s\nprint('共'+str(m)+'男性，'+str(f)+'个女性')\nprint('密码更新后：')\nfor i,j in Members.items():\n    print(i,j)\n", "Konwledge_Point": "算法与数字", "Question": "会员信息加密保存重新输出\n某公司后台管理系统存储着会员的用户信息（格式为{'姓名'：['密码'，'性别']}）。\n用户字典：Members={'Hugo'：['Brijht'，'M']，'Mary':['Pretty'，'F']，'John'：['CowBoy','M'],'Jerry':['Smart','M'],'Anna':['Lucky','F']}\n1.将所有会员的密码根据加密算法加密后，再更新字典里的密码，并输出所有人的信息。\n加密算法：<1>先将英文单词中的每个字母都转换为对应的小写字母。<2>再将该小写字母的ascii码对10整除后取其余数。<3>按以上方法加密每个字符，从而得到一个六位整数密码。\n2.统计男（M）、女（F）会员人数并输出结果。\n3.加密结束后，显示：加密完成。\n4.加密方法：通过表达式“ord(i.lower())%10”获取每个字符的密文，再连接成一串数字密文。", "Tag": "算法分析"}
{"Answer": "是pow函数的使用问题，这个函数返回值是double类型两个参数类型不能都是int类型", "Konwledge_Point": "算法与数字", "Question": "完美综合式，在sum++加断点之后，查看各个变量的值发现所有的变量都找不到，这是为什么？\n把数字1,2...9这9个数字分别填入以下含加﹑减﹑乘﹑除与乘方的综合运算式中的9个中,口使得该式成立\n口^口+口口÷口口-口×口=0\n要求数字1,2...这9个数字在式中出现一次且只出现一次，且约定数字“1\"不出现在乘﹑乘方的一位数中（即排除式中的各个1位数为1这一平凡情形)。\n\n\n我的代码整体想法是先枚举出每个数字的所有情况，然后进行条件筛选，调试的时候发现，在判断是否有重复出现的数字的时候，永远都判断不成功，这是不可能出现的，在sum++加断点之后，查看各个变量的值发现所有的变量都找不到，这是为什么？\n\n\n\n", "Tag": "算法分析"}
{"Answer": "val.end()超出了vector的范围", "Konwledge_Point": "算法与数字", "Question": "c++排大小，容器中传入数据\n我的目的是输入任意多的数字，然后通过排序算法，最后输出最大的值\n目前搞不懂要怎么才可以向一个容器中无限的放入数据，这个程序运行会崩溃\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\nvoid\n \ntest\n()\n\n\n{\n    vector<\nint\n>val;\n    val.\nresize\n(\n1000\n);\n    \nint\n put;\n    \nwhile\n (cin >> put)\n    {\n        val.\npush_back\n(put);\n    }\n    \nsort\n(val.\nbegin\n(), val.\nend\n());\n    cout << *val.\nend\n() << endl;\n}\n\nint\n \nmain\n()\n\n\n{\n    \ntest\n();\n    \nsystem\n(\n\"pause\"\n);\n    \nreturn\n \n0\n;\n}\n\n", "Tag": "算法分析"}
{"Answer": "1、2G\r\n2、一种最土的办法\r\n\r\n        int index = 0;\r\n        Map map = new HashMap();\r\n        for (int i = 1; i <= 11; i++)\r\n        {\r\n            for (int j = i + 1; j <= 12; j++)\r\n            {\r\n                for (int k = j + 1; k <= 13; k++)\r\n                {\r\n                    for (int l = k + 1; l <= 14; l++)\r\n                    {\r\n                        for (int m = l + 1; m <= 15; m++)\r\n                        {\r\n                            map.put(\"\" + i + j + k + l + m, ++index);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }", "Konwledge_Point": "算法与数字", "Question": "高级人员问卷　求解答\n１，32位WIN平台,JDK１.６，在上述环境下一个JVM实际最多可利多少内存\n２，１５选５是一种数字彩票游戏，即从１５个数字中随便选择不重复的５个数字组成一注彩票号码进行投注。一共３００３注号码，从最小的一注号码到最大的一注号码依次是：\n序号　　彩票号码\n1          01 02 03 04 05\n2          01 02 03 04 06\n           ······\n10        01 02 03 04 14\n11        01 02 03 04 15\n12        01 02 03 05 06\n           ······\n3003    11 12 13 14 15\n求算法:给出任意一注号码,求出序号.例输入\"01 02 03 05 06\"号码,输出数字１２\n问题补充\n高手      求解答！！！！！！！！！！！", "Tag": "算法分析"}
{"Answer": "\n这里的a[i+1]会访问到a[25] 但是数组开辟空间只开到a[24]，没a[25]，造成了越界访问\n\n简单来说就是：数组所创建的范围已经超过使用的范围了——越界了\n\n希望对题主有所帮助！可以的话，帮忙点个采纳！\n", "Konwledge_Point": "算法与数字", "Question": "题很简单，生成25个1到100之间的随机数，打印它们，并在相邻的两个数字之间打印 > 、 < 、 =。 比如 11 > 2 < 5 < 90 > 89 > 17 ...\n现在遇到的问题是报错，这个错误该怎修改？\n\n\n//我写的代码如下\n\n\nimport\n java.util.*;\n\npublic\n \nclass\n \nA\n{\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[] args)\n{ \n        Random rand=\nnew\n \nRandom\n();\n        \nint\n []a=\nnew\n \nint\n[\n25\n];\n        \nfor\n (\nint\n i=\n0\n;ia[i+\n1\n]) {\n                s=s+\n\">\"\n+a[i+\n1\n];\n            }\n            \nif\n (a[i]<a[i+\n1\n]) {\n                s=s+\n\"<\"\n+a[i+\n1\n];\n            }\n            \nif\n (a[i]==a[i+\n1\n]) {\n                s=s+\n\"=\"\n+a[i+\n1\n];\n            }\n            x=s;\n            System.out.\nprintln\n(a[\n0\n]+x);\n        }\n    }\n}\n\n\n\n\n问题遇到的现象和发生背景\n\n\n问题相关代码，请勿粘贴截图\n\n\n运行结果及报错内容\n\n\n8<50\n8<50>40\n8<50>40<70\n8<50>40<70>42\n8<50>40<70>42<81\n8<50>40<70>42<81>61\n8<50>40<70>42<81>61>24\n8<50>40<70>42<81>61>24<76\n8<50>40<70>42<81>61>24<76>3\n8<50>40<70>42<81>61>24<76>3<100\n8<50>40<70>42<81>61>24<76>3<100>5\n8<50>40<70>42<81>61>24<76>3<100>5<27\n8<50>40<70>42<81>61>24<76>3<100>5<27<81\n8<50>40<70>42<81>61>24<76>3<100>5<27<81>36\n8<50>40<70>42<81>61>24<76>3<100>5<27<81>36<92\n8<50>40<70>42<81>61>24<76>3<100>5<27<81>36<92>64\n8<50>40<70>42<81>61>24<76>3<100>5<27<81>36<92>64>56\n8<50>40<70>42<81>61>24<76>3<100>5<27<81>36<92>64>56=56\n8<50>40<70>42<81>61>24<76>3<100>5<27<81>36<92>64>56=56<57\n8<50>40<70>42<81>61>24<76>3<100>5<27<81>36<92>64>56=56<57<70\n8<50>40<70>42<81>61>24<76>3<100>5<27<81>36<92>64>56=56<57<70>54\n8<50>40<70>42<81>61>24<76>3<100>5<27<81>36<92>64>56=56<57<70>54<83\n8<50>40<70>42<81>61>24<76>3<100>5<27<81>36<92>64>56=56<57<70>54<83>40\n8<50>40<70>42<81>61>24<76>3<100>5<27<81>36<92>64>56=56<57<70>54<83>40>14\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 25\n    at A.main(A.java:14)\n\n\n输出完成 (耗时 0 秒) - 正常终止\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果", "Tag": "算法分析"}
{"Answer": "使用fprintf和fscanf读取文件的时候就能防止读取进去空格了，不行的话就fread然后清空格", "Konwledge_Point": "算法与数字", "Question": "怎样解决C语言TXT文本输入数据时的空格问题？\n题目如下：\n 1到40，一共四十个数，输入时一行不超过12个数，不超过10行，筛选出现一次的数字，出现两次的数字，三次及三次以上的数字，出现零次的数字，要求用TXT文本输入，输出。\n遇到的问题：\n输入数据后，发现结果错误。仔细查找发现，每行数据后会发现几个空格，\n，导致了只有第一行数据能够读入。笔者试过多次，发现貌似只有这一种空格形式会对结果造成影响，其他的情况，添加很多空格也不会有事。笔者咨询前辈，说可能由于中文或者英文状态下的原因，笔者试过两种状态下输入原数据的空格，发现均输出错误结果。现在比较迷惑，不知如何改进（其实用基本能用了），还请各位大神帮帮忙，也希望大家能对我的算法提出改进意见！\n代码如下：\n\n#include\n\n#include\n\n#define S 120\n\n#define T 40\n\n#define I 1\n\nint main()\n\n{\n\n    FILE*fp1;\n\n    FILE*fp2=fopen(\"output.txt\",\"w\");\n\n    int num1[S],num2[T],num3[T],num4[T],num5[T],num6[T],i,j=0,k=0,a=0,b=0,c=0,d=0,m,n;\n\n    if((fp1=fopen(\"input.txt\",\"r\"))==NULL)\n\n    {\n\n    printf(\"无法打开文件\\n\");\n\n    exit(0);\n\n    }\n\n    for(i=I;i<=T;i++)\n\n        num2[j++]=i;//将1至40赋给num2数组各元素\n\n    for(i=0;i\n    fscanf(fp1,\"%d\",&num1[i]);//从文件中读出120个的数据，并存入num1数组\n\n    fclose(fp1);\n\n    for(i=0;i\n    {\n\n            for(j=0;j\n            if(num1[j]==num2[i])k++;//比较\n\n            if(k==0) num3[a++]=num2[i];\n\n            else if(k==1) num4[b++]=num2[i];\n\n            else if(k==2) num5[c++]=num2[i];\n\n            else if(k>3||k==3) num6[d++]=num2[i];\n\n            k=0;\n\n    }\n\n    fprintf(fp2,\"出现过零次的数字是:\");\n\n    for(m=0;m<a;m++)\n\n        fprintf(fp2,\"%3d\",num3[m]);\n\n    fprintf(fp2,\"\\n\");\n\n    fprintf(fp2,\"出现过一次的数字是:\");\n\n    for(m=0;m<b;m++)\n\n        fprintf(fp2,\"%3d\",num4[m]);\n\n    fprintf(fp2,\"\\n\");\n\n    fprintf(fp2,\"出现过两次的数字是:\");\n\n    for(m=0;m<c;m++)\n\n        fprintf(fp2,\"%3d\",num5[m]);\n\n    fprintf(fp2,\"\\n\");\n\n    fprintf(fp2,\"出现过三次或三次以上的数字是:\");\n\n    for(m=0;m<d;m++)\n\n        fprintf(fp2,\"%3d\",num6[m]);\n\n    fprintf(fp2,\"\\n\");\n\n    fclose(fp2);\n\n    return 0;\n\n}", "Tag": "算法分析"}
