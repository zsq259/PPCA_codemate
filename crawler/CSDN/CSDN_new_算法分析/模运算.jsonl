{"Answer": "unsigned sum = a * ((b >> 30) & 1);改为unsigned long long sum = a * ((b >> 30) & 1);\n否则表达式中的  sum << 1 会溢出的", "Konwledge_Point": "模运算", "Question": "C语言通过位运算实现取模运算\n这是一道课后习题，原题如下：\n\n\n\n\n定义函数unsigned mod(unsigned a, unsigned b, unsigned c); 功能是计算并返回a\nb%c的结果。要求考试a, b, c的范围是大于0且小于 2^31，程序不能使用64位整型(如：long long类型或__int64)求解。\n问题：a\nb可能溢出（超出32位unsigned int型的表示范围）。为解决此问题，可用如下算法。\n设unsigned型变量b的每个二进制位为xi (i=0,1, …, 31)，i=0为最低位，i=31为最高位，则\n上式中，a\nxi的结果或者为a或者为0；\n2运算可用左移1位操作实现（小于2^31的整数\n2结果一定小于2^32, 不会发生溢出）；\n%c的结果是小于c的，而c小于2^31，它与a求和也不会发生溢出。\n编写完整程序，用迭代法实现上述算法。\n要求测试b的每个二进制xi位为1或0的操作必须采用位运算实现。\n输入提示：\"Input unsigned integer numbers a, b, c:\\n\"\n输入格式：\"%u %u %u\"\n输出格式：\"%u\n%u%%%u=%u\\n\"\n\n\n\n\n我的代码如下：\n\n\n#\npragma\n \nwarning\n(disable:4996)\n\n\n#\ninclude\n \n\n\n\n\nunsigned\n \nmod\n(\nunsigned\n a, \nunsigned\n b, \nunsigned\n c)\n \n{\n    \nunsigned\n sum = a * ((b >> \n30\n) & \n1\n);\n    \nfor\n (\nint\n i = \n29\n; i >= \n0\n; i--) {\n        sum = (sum << \n1\n) % c + a * ((b >> i) & \n1\n);\n    }\n    \nreturn\n sum % c;\n}\n\n\nint\n \nmain\n()\n \n{\n        \n//此部分用于实现题目要求\n\n    \nunsigned\n a, b, c;\n    \nprintf\n(\n\"Input unsigned integer numbers a, b, c:\\n\"\n);\n    \nscanf\n(\n\"%u %u %u\"\n, &a, &b, &c);\n    \nprintf\n(\n\"%u*%u%%%u=%u\\n\"\n, a, b, c, \nmod\n(a, b, c));\n    \n        \n//此部分用于检验答案是否正确\n\n    \nunsigned\n \nlong\n \nlong\n ab, bb, cb;\n    ab = a;\n    bb = b;\n    cb = c;\n    \nprintf\n(\n\"%llu*%llu%%%llu=%llu\"\n, ab, bb, cb, ab * bb % cb);\n}\n\n\n\n遇到的问题\n\n\n在处理较小的数据时，一切正常。但当处理较大数据时，如2147483647*2147483647/3，就会得到错误的答案。\n\n\n另外我是根据题目的公式写的代码，不是很清楚具体原理。", "Tag": "算法分析"}
{"Answer": "他的指针是不是真正的指针变量，而是int型的，用来记录数组下标，起到了指针的作用。因为只有这样才能实现取模循环。\n\n注意：循环队列的尾指针始终指Rear向下一个空间，即为指针的上一个才是存放数据的空间。           循环队列的头指针Front始终指向最后一个有数据的空间。\n\n循环队列是把顺序队列首尾相连，把存储队列元素的表从逻辑上看成一个环，成为循环队列。\n出队时：Q->Front++入队时：Q->Rear++这样每次不管是入队还是出队，下标都会++，如果不取模，就容易造成溢出。\n就比如此时循环队列有8个空间，当rear=9的时候其实在我们实际是循环了一圈了，到了rear=1的位置，因为我们size是8，所以用9%8=1.就获取到了我们的元素下标", "Konwledge_Point": "模运算", "Question": "插入队指针后移取模运算\n为什么入队之后指针后移拿一步有一个取模的操作啊，指针（Q.rear+1）可以取模吗", "Tag": "算法分析"}
{"Answer": "自答，用for循环写了个解决方案，不过速度比原来的要慢\nfor (int k = 0; k < 3; k++)\n{\n    for (int i = 0; i < img1.Height; ++i)\n    {\n        for (int j = 0; j < img1.Width; ++j)\n        {\n            diff.At<Vec3b>(i, j)[k] = (byte)((img2.At<Vec3b>(i, j)[k] - img1.At<Vec3b>(i, j)[k]) % 256);\n        }\n    }\n}\n\nfor (int k = 0; k < 3; k++)\n{\n    for (int i = 0; i < img1.Height; ++i)\n    {\n        for (int j = 0; j < img1.Width; ++j)\n        {\n            add.At<Vec3b>(i, j)[k] = (byte)((diff.At<Vec3b>(i, j)[k] + img1.At<Vec3b>(i, j)[k]) % 256);\n        }\n    }\n}\n", "Konwledge_Point": "模运算", "Question": "C# OpenCvSharp：图像加减超出0-255需要模运算\n比如\n\n\nMat\n img = Cv2.ImRead(@\n\"01.png\"\n);\n\nimg\n = img - new Scalar(\n255\n, \n255\n, \n255\n);\n\n\n\n运算结果得到全黑，但我希望它的颜色翻转\n\n\nMat im\ng1\n = Cv\n2.\nImRead\n(@\"01.png\")\n;\nMat im\ng2\n = Cv\n2.\nImRead\n(@\"02.png\")\n;\nMat test = im\ng2\n - im\ng1\n + im\ng1\n;\n\n\n\n结果和img2不一样\n\n\n怎么能让它进行模运算？", "Tag": "算法分析"}
{"Answer": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    double b,k,p,t;\n    cin >>b >> p>>k;\n    t=pow(b,p);\n    cout<<int(t)%int(k);\n\n    return 0;\n}\n\n", "Konwledge_Point": "模运算", "Question": "定义“取模”运算：对于正整数 a 和 p，a % p 表示 a 除以 p 的余数，又称“模”运算。现在，输入三个正整数 b、p、k，请编程计算 b^p % k 的值。\n定义“取模”运算：对于正整数 a 和 p，a % p 表示 a 除以 p 的余数，又称“模”运算。现在，输入三个正整数 b、p、k，请编程计算 b^p % k 的值。", "Tag": "算法分析"}
{"Answer": "\nAkama Razor tells me, that you don't need to use GO code here. \nit's much better to use JS in such situation. \nGood luck! \n\n\ns = document.getElementsByTagName('td');\r\n\r\nfor (i = 0; i < s.length; i++) {\r\n  if (parseInt(s[i].innerText) > 123) {\r\n    s[i].style = 'color:red';\r\n  }\r\n}\n<head lang=\"en\">\r\n  <title>123</title>\r\n</head>\r\n\r\n<body>\r\n  <table>\r\n    <tbody>\r\n      <tr>\r\n        <td>123</td>\r\n        <td>1234</td>\r\n      </tr>\r\n    </tbody>\r\n  </table>\r\n  <script>\r\n    s = document.getElementsByTagName('td');\r\n    for (i = 0; i < s.length; i++) {\r\n      if (parseInt(s[i].innerText) > 123) {\r\n        s[i].color = '#fff';\r\n      }\r\n    }\r\n  </script>\r\n</body>\n\n\n", "Konwledge_Point": "模运算", "Question": "如何在Golang HTML模板中使用算术运算符\n\n\n\nI want to compare field 'FileSize' in my html go temple with variable 'minsize' in my code (.FileSize < *minsize). I have no idea how to do it. See below\n\n\n\n{{ if lt .FileSize *minsize }}\n{{.FileSize}}\n{{else}}\n{{.FileSize}}\n{{end}}\n\n\n    ", "Tag": "算法分析"}
{"Answer": "\nThe package text/template (and subsequently html/template) can provide the functionality by defining division as a function using Template.Funcs:\nfunc (t *Template) Funcs(funcMap FuncMap) *Template\n\nIn your case, a FuncMap with a divide function could look something like this:\nfm := template.FuncMap{\"divide\": func(a, b int) int {\n    return a / b\n}}\n\nFull example (but without me trying to understand what you mean with if a/2):\npackage main\n\nimport (\n    \"os\"\n    \"text/template\"\n)\n\nfunc main() {\n    fm := template.FuncMap{\"divide\": func(a, b int) int {\n        return a / b\n    }}\n\n    tmplTxt := `{{divide . 2}}`\n\n    // Create a template, add the function map, and parse the text.\n    tmpl, err := template.New(\"foo\").Funcs(fm).Parse(tmplTxt)\n    if err != nil {\n        panic(err)\n    }\n\n    // Run the template to verify the output.\n    err = tmpl.Execute(os.Stdout, 10)\n    if err != nil {\n        panic(err)\n    }\n}\n\nOutput:\n\n5\n\nPlayground: http://play.golang.org/p/VOhTYbdj6P\n", "Konwledge_Point": "模运算", "Question": "如何在golang模板中使用除法？\n\n\n\nHow can I use division in a golang template. I need to divide \nId\n by 2.\n\n\n\nFor example\n\n\n\n{{if .Id/2}}\nHEY, I CAN DO IT!\n{{else}}\nWHY???\n{{end}}\n\n\n    ", "Tag": "算法分析"}
{"Answer": "```\r\n#include \r\n#include \r\n\r\nusing namespace std;\r\n\r\nclass Complex\r\n{\r\nprivate:\r\n\tdouble real;\r\n\tdouble img;\r\npublic:\r\n\tComplex() { real = img = 0.0; }\r\n\tComplex(double r, double i) { real = r; img = i; }\r\n\tComplex(const Complex &c) { real = c.real; img = c.img; }\r\n\t~Complex() { cout << \"dector has been called!\" << endl; }\r\n\tvoid Output() { cout << real << \"+\" << img << \"i\" << endl; }\r\n\tComplex operator +(const Complex &c) { return Complex(real + c.real, img + c.img); }\r\n\tdouble GetModulus() { return sqrt(img * img + real * real); }\r\n};\r\nint main()\r\n{\r\n\tComplex c1, c2(1.0, 2.0), c3(1.5, 2.5);\r\n\tc1 = c2 + c3;\r\n\tc1.Output();\r\n\tComplex c4 = c1;\r\n\tc4.Output();\r\n\tcout << c4.GetModulus() << endl;\r\n\treturn 0;\r\n}\r\n```\r\n\r\n![图片说明](https://img-ask.csdn.net/upload/201811/15/1542222666_909137.gif)\r\n\r\n>参考资料：https://en.wikipedia.org/wiki/Complex_number\r\n\r\n`如果问题得到解决，请点我回答左上角的采纳和向上的箭头`", "Konwledge_Point": "模运算", "Question": "C++类与对象 怎样利用复数类算复数的模等运算？\n定义复数类，并在主函数定义类的对象进行调用测试。\n\n                要求：① 数据成员为双精度类型的实部和虚部。\n\n                          ② 具有无参和有参的构造函数。\n\n                                    ③ 具有深拷贝构造函数。\n\n                                    ④ 具有析构函数。\n\n                                    ⑤ 具有输出函数、求模函数、加法函数等。", "Tag": "算法分析"}
{"Answer": "\ntemplate.Execute() returns an error, you should always check that. Would you have done so:\n\ntemplate: item.gtpl:3:33: executing \"item.gtpl\" at <.Number>: Number is not a field of struct type main.Item\n\nThe \"problem\" is that {{range}} changes the pipeline (the dot, .) to the current item, so inside the {{range}}:\n{{add $i (mul .ID .Number)}}\n\n.Number will refer to a field or method of your Item type since you are looping over a []Item. But your Item type has no such method or field.\nUse $.Number which will refer to the \"top-level\" Number and not a field of the current Item value:\n{{add $i (mul .ID $.Number)}}\n\nTry your modified, working code on the Go Playground.\n$ is documented at text/template:\n\nWhen execution begins, $ is set to the data argument passed to Execute, that is, to the starting value of dot.\n\n", "Konwledge_Point": "模运算", "Question": "html模板中的golang乘法算法\n\n\n\nI am new for golang. I met a problem when I use multiplication in html/template.\nSome code like below.\n\n\n\ntemplate code:   \n\n\n\n {{range $i,$e:=.Items}}\n      \n{{add $i (mul .ID .Number)}}\n{{.Name}}\n\n  {{end}}\n\n\n\n\n.go code\n\n\n\ntype Item struct{\n        ID int\n        Name string\n    }\nfunc init() {\n    itemtpl,_:=template.New(\"item.gtpl\").\n        Funcs(template.FuncMap{\"mul\": Mul, \"add\": Add}).\n        ParseFiles(\"./templates/item.gtpl\")\n}\n\nfunc itemHandle(w http.ResponseWriter, req *http.Request) {\n\n    items:=[]Item{Item{1,\"name1\"},Item{2,\"name2\"}}\n    data := struct {\n            Items []Item\n            Number int\n            Number2 int\n        }{\n            Items:    items,\n            Number:   5,\n            Number2:  2,\n        }\n        itemtpl.Execute(w, data)\n}\nfunc Mul(param1 int, param2 int) int {\n    return param1 * param2\n}\nfunc Add(param1 int, param2 int) int {\n    return param1 + param2\n}\n\n\n\n\nIt will output nothing when I use the code above. But It will output 10 when I use the code outside of array below.\n\n\n\n\n\n    {{mul .Number .Number2}}\n\n\n\n\n\n\nI google a lot. I cannot find the usable like mine. I want to use multiplication in array inside of html/template. Can someone tell me what is wrong with my code?\n\n    ", "Tag": "算法分析"}
{"Answer": "```\r\n模板：\r\nint Compare(T a, U b)\r\n{\r\n\tif (a>b)\r\n\t{\r\n\t\treturn 1;\r\n\t}\r\n   if (a == b)\r\n\t{\r\n\t\treturn 0;\r\n\t}\r\n   if (a < b) \r\n\t\treturn -1;\r\n}\r\n \r\n```\r\n\r\n测试代码：\r\n\r\n\r\n```\r\n#include\r\n#include\r\n#include\r\n#include\r\nusing namespace std;\r\n\r\n\r\n\r\ntemplate\r\nint Compare(T a, U b)\r\n{\r\n\tif (a>b)\r\n\t{\r\n\t\treturn 1;\r\n\t}\r\n   if (a == b)\r\n\t{\r\n\t\treturn 0;\r\n\t}\r\n   if (a < b) \r\n\t\treturn -1;\r\n}\r\n\r\nvoid MInt()\r\n{\r\n\tint a = 3;\r\n\tint b = 5;\r\n\tif (Compare(a, b) ==0)\r\n\t\tcout << \"a == b\" << endl;\r\n\telse if (Compare(a, b) > 0)\r\n\t{\r\n\t\tcout << \"a > b\" << endl;\r\n\t}\r\n\telse if (Compare(a, b) < 0) \r\n\t\tcout << \"a < b\" << endl;\r\n}\r\n\r\nvoid MDouble()\r\n{\r\n\tdouble a = 4.0;\r\n\tdouble b = 5.0;\r\n\tif (Compare(a, b) == 0)\r\n\t\tcout << \"a == b\" << endl;\r\n\telse if (Compare(a, b) > 0)\r\n\t{\r\n\t\tcout << \"a > b\" << endl;\r\n\t}\r\n\telse if (Compare(a, b) < 0)\r\n\t\tcout << \"a < b\" << endl;\r\n}\r\n\r\nvoid _MInt()\r\n{\r\n\tint * a = new int;\r\n\t*a = 3;\r\n\tint *b = new int;\r\n\t*b = 5;\r\n\tif (Compare(a, b) == 0)\r\n\t\tcout << \"a == b\" << endl;\r\n\telse if (Compare(a, b) > 0)\r\n\t{\r\n\t\tcout << \"a > b\" << endl;\r\n\t}\r\n\telse if (Compare(a, b) < 0)\r\n\t\tcout << \"a < b\" << endl;\r\n}\r\n\r\nvoid _MDouble()\r\n{\r\n\tdouble *a = new double;\r\n\t*a = 3.0;\r\n\tdouble *b = new double;\r\n\t*b = 5.0;\r\n\t*b = 5;\r\n\tif (Compare(a, b) == 0)\r\n\t\tcout << \"a == b\" << endl;\r\n\telse if (Compare(a, b) > 0)\r\n\t{\r\n\t\tcout << \"a > b\" << endl;\r\n\t}\r\n\telse if (Compare(a, b) < 0)\r\n\t\tcout << \"a < b\" << endl;\r\n\r\n}\r\nint main()\r\n{\r\n\tMInt();\r\n\tMDouble();\r\n\t_MInt();\r\n\t_MDouble();\r\n\tsystem(\"pause\");\r\n\treturn 0;\r\n}\r\n \r\n```", "Konwledge_Point": "模运算", "Question": "c++写一个模板 Compare函数\n对int,char*,int *,double类型的两个数据进行比较", "Tag": "算法分析"}
{"Answer": "你要安装cuda和cudnn，参考一下https://zhuanlan.zhihu.com/p/106133822", "Konwledge_Point": "模运算", "Question": "pytorch 模型在GPU上但训练时仍使用CPU\n我在练习pytorch，使用这个页面的代码。\nhttps://www.pytorch123.com/SecondSection/training_a_classifier/\n\n\n\n其中提到:如果使用GPU训练，代码需要更改\n\n\n\n\n\ndevice = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\nnet.to(device)\n...\n...\ninputs, labels = inputs.to(device), labels.to(device)\n\n\n\n其余部分没有改动，但是运行时资源管理器显示GPU占用0%，并且CPU保持一个恒定的高占用率。是否说明我没有成功在GPU上训练？\n\n\n\n请问怎么才能使用CPU进行训练？", "Tag": "算法分析"}
{"Answer": "可以用啊，判断GPU是否可用 ，否则使用cpu\ndevice = torch.device(\"cuda:0\"  if torch.cuda.is_available() else \"cpu\")\n", "Konwledge_Point": "模运算", "Question": "python 大量文本数据预处理（NLP），跑的很慢，是否可以用上GPU加速\n我现在有一批数据要进行文本预处理，主要是NER（但是调某个服务的接口，所以也不是本地用模型跑的），但现在问题是数据量很大，跑的很慢，能不能用gpu让数据并行运算（但数据都是文本），因为我本人之前对gpu并行运算完全不懂，所以现在有点儿摸不着头脑，希望专业人士能给点儿建议，谢谢。\n\n\n代码就是调用某服务接口，以及自己写的词典匹配和否定检测，都不涉及深度学习模型", "Tag": "算法分析"}
{"Answer": "你好，给你推荐篇文章，如有帮助，请采纳\nhttps://blog.csdn.net/SZU_Kwong/article/details/110359744", "Konwledge_Point": "模运算", "Question": "分数类异常处理c++\n设计一个分数类，考虑异常情况，并实现对运算符+的重载设计。\n\n\n设计主程序进行测试。\n大家解决一下吧😭", "Tag": "算法分析"}
{"Answer": "也就是说会把int类型转成unsigned int来计算。10的二级制是：  0000 0000  0000 0000  0000 0000  0000 1010-10的二进制是在10的二进制码基础上取反+1，也就是 1111 1111 1111 1111 1111 1111 1111 0110-10的十六进制是 FF FF FF F6，转成unsigned int后值是 4294967286， 4294967286除以500取余数就是286", "Konwledge_Point": "模运算", "Question": "c++中求模取余运算%的问题（int % unsigned）\n本人在调试他人代买的过程中，无意间注意到了这样一个问题：int类型的负数，与unsigned类型的正数，进行求模（取余）%运算，但是结果并不是我想要的，我猜测是是unsigned类型闯祸，但是查找资料没有头绪。\n\n\n#\ninclude\n \n\n\n\nusing\n \nnamespace\n std;\n\n\nint\n \nmain\n()\n \n{\n    \nint\n a = \n-100\n;\n    \nunsigned\n b = \n500\n;\n    a %= b;\n    cout << a << endl;\n    \nsystem\n(\n\"pause\"\n);\n    \nreturn\n \n0\n;\n\n}\n\n\n\n\n运行结果是：196\n\n\n我一开始以为运行结果会是-100，结果却是196。如果将代码中的a赋值为-10，那么结果就是286。似乎都跟296这个数有关系？为啥会这样？", "Tag": "算法分析"}
{"Answer": "不知道你怎么算的\r\n我们知道\r\na^m可以视作a^p*a^q（p+q=m）\r\n而如果p=m，显然，我们只要算了a^p，就可以再平方下就是最后的结果了。\r\n因此最简单的做法就是，将指数转化成2的幂相加的结果，这相当于二进制计算，比如100000000\r\n就是101111101011110000100000000（2）\r\n那么就是256+8192+16384+32768+65536+262144+1048576+...\r\n然后我们分别计算N的这些次方的幂，别忘了，我们可以通过平方翻倍很快算出来。\r\n最后再把结果相乘。", "Konwledge_Point": "模运算", "Question": "一道关于大数幂运算的题目，c语言实现\n题目描述\n\n幂运算是常见的数学运算之一，其原理是用同一个数相乘多次，但是有的时候当幂指数特别大的时候，这样的运算就太浪费时间。请大家学会在幂中加特技，让幂运算的效率提高到可以接受的程度。\n输入：\n\n第一个行一个整数T，表示有T组数据\n\n每组数据，输入x，y 求x的y次幂 （2≤ x ,y≤10^9）\n输出：\n\n每组数据输出一个整数，表示幂运算对1000000007取模后的结果\n样例输入：\n\n2\n\n2 4\n\n2 100000000\n样例输出：\n\n16\n\n494499948\n\n我的代码总是超时，求好方法！！谢谢！！", "Tag": "算法分析"}
{"Answer": "模运算是判断i是周几0和6分别表示是工作日进步，还是休息日退步切片肯定不行，因为[1 ,6]是列表，你切片要切一个变量才行，所以不能直接写切片", "Konwledge_Point": "模运算", "Question": "天天向上的力量代码询问\n在天天向上的力量例子中，一年365天，一周5个工作日，每天进步1%，一周2个休息日，每天休息时退步1% ，那工作日的力量是多少？\n       if i % 7 in [0,6]:\n看不懂这行代码，第一，为什么会用模运算？\n                             第二，为什么会是0和6而不是1和6？\n                             如果用切片表示是否可以，表示为 [0：7]？", "Tag": "算法分析"}
{"Answer": "你这个需要将点云生成一个闭合的图形，然后转换为vtkImageData。点云直接转vtkImageData可能就不会生成正确的vtkImageData；", "Konwledge_Point": "模运算", "Question": "如何使用vtk进行三维形态学腐蚀膨胀\n想将.txt格式的点云数据读入，然后作三维形态学开闭操作，目标去掉图中植物根系外周的小土屑\n原来的数据查资料后读成了vtkPolyData,但OpenClose3D先前报错说需要vtkImageData类型\n用vtkPolyData绘制出来的原数据如下（3D）：\n\n\n查阅各种资料写出的数据类型转换加形态学操作代码如下：\n\n\n\n```c++\n#\ninclude\n \n\nVTK_MODULE_INIT(\nvtkRenderingOpenGL2\n)\n;\n\nVTK_MODULE_INIT(\nvtkInteractionStyle\n)\n;\n#\ninclude\n \n#\ninclude\n \n#\ninclude\n \n#\ninclude\n \n#\ninclude\n \n#\ninclude\n \n#\ninclude\n \n#\ninclude\n \n#\ninclude\n \n#\ninclude\n \n#\ninclude\n \n#\ninclude\n \n#\ninclude\n \n#\ninclude\n \n#\ninclude\n \n#\ninclude\n \n#\ninclude\n \n#\ninclude\n \n#\ninclude\n \n#\ninclude\n \n#\ninclude\n \n\n#\ninclude\n \n\n\n\n\n#\ninclude\n \n\n\nint\n main(\nint\n argc, \nchar\n* argv\n[]\n)\n{\n    vtkNew colors;\n\n    \n// Verify input arguments\n\n    \nif\n (argc != \n2\n)\n    {\n        std::cout << \n\"Usage: \"\n << argv\n[\n0\n]\n << \n\" Filename(.txt) e.g. TeapotPoints.txt\"\n\n            << std::endl;\n        return EXIT_FAILURE;\n    }\n    \n// Get all data from the file\n\n    std::\nstring\n filename = argv\n[\n1\n]\n;\n    std::ifstream filestream(filename.c\n_str()\n);\n\n    std::\nstring\n line;\n    vtkNew points;\n    \nchar\n* p;\n    \nwhile\n (std::getline(filestream, line))\n    {\n        double x, y, z;\n        std::stringstream linestream;\n        linestream << line;\n        p = strtok((\nchar\n*)line.data\n()\n, \n\",\"\n);\n        x = atof(p);\n        p = strtok(NULL, \n\",\"\n);\n        y = atof(p);\n        p = strtok(NULL, \n\",\"\n);\n        z = atof(p);\n\n        points->\nInsertNextPoint(\nx\n, \ny\n, \nz\n)\n;\n    }\n\n    filestream.close\n()\n;\n\n    vtkNew polyData;\n\n    polyData->\nSetPoints(\npoints\n)\n;\n\n    \n// 将vtkPolyData转换成vtkImageData，先前OpenClose3D报错说需要vtkImageData类型\n\n    vtkSmartPointer whiteImage =\n        vtkSmartPointer::\nNew()\n;\n    double bounds\n[\n6\n]\n;\n    polyData->\nGetBounds(\nbounds\n)\n;\n    double spacing\n[\n3\n]\n; \n// desired volume spacing\n\n    spacing\n[\n0\n]\n = \n0.5\n;\n    spacing\n[\n1\n]\n = \n0.5\n;\n    spacing\n[\n2\n]\n = \n0.5\n;\n    whiteImage->\nSetSpacing(\nspacing\n)\n;\n\n    \n// compute dimensions\n\n    \nint\n dim\n[\n3\n]\n;\n    \nfor\n (\nint\n i = \n0\n; i < \n3\n; i++)\n    {\n        dim\n[\ni\n]\n = static_cast<\nint\n>(ceil((bounds\n[\ni\n \n*\n \n2\n + \n1\n]\n - bounds\n[\ni\n \n*\n \n2\n]\n)\n / \nspacing\n[\ni\n]\n));\n    }\n    whiteImage->\nSetDimensions(\ndim\n)\n;\n    whiteImage->\nSetExtent(0, \ndim\n[0] - 1, 0, \ndim\n[1] - 1, 0, \ndim\n[2] - 1)\n;\n\n    double origin\n[\n3\n]\n;\n    origin\n[\n0\n]\n = bounds\n[\n0\n]\n + spacing\n[\n0\n]\n / \n2\n;\n    origin\n[\n1\n]\n = bounds\n[\n2\n]\n + spacing\n[\n1\n]\n / \n2\n;\n    origin\n[\n2\n]\n = bounds\n[\n4\n]\n + spacing\n[\n2\n]\n / \n2\n;\n    whiteImage->\nSetOrigin(\norigin\n)\n;\n    whiteImage->\nAllocateScalars(VTK_UNSIGNED_CHAR, 1)\n;\n\n    \n// fill the image with foreground voxels:\n\n    unsigned \nchar\n inval = \n255\n;\n    unsigned \nchar\n outval = \n0\n;\n    vtkIdType count = whiteImage->\nGetNumberOfPoints()\n;\n    \nfor\n (vtkIdType i = \n0\n; i < count; ++i)\n    {\n        whiteImage->\nGetPointData()\n->\nGetScalars()\n->\nSetTuple1(\ni\n, \ninval\n)\n;\n    }\n\n    \n// polygonal data --> image stencil:\n\n    vtkSmartPointer pol2stenc =\n        vtkSmartPointer::\nNew()\n;\n    pol2stenc->\nSetInputData(\npolyData\n)\n;\n    pol2stenc->\nSetOutputOrigin(\norigin\n)\n;\n    pol2stenc->\nSetOutputSpacing(\nspacing\n)\n;\n    pol2stenc->\nSetOutputWholeExtent(\nwhiteImage\n->GetExtent()\n);\n    pol2stenc->\nUpdate()\n;\n\n    \n// cut the corresponding white image and set the background:\n\n    vtkSmartPointer imgstenc =\n        vtkSmartPointer::\nNew()\n;\n    imgstenc->\nSetInputData(\nwhiteImage\n)\n;\n    imgstenc->\nSetStencilConnection(\npol2stenc\n->GetOutputPort()\n);\n    imgstenc->\nReverseStencilOff()\n;\n    imgstenc->\nSetBackgroundValue(\noutval\n)\n;\n    imgstenc->\nUpdate()\n;\n\n\n\n    vtkNew openClose;\n    openClose->\nSetInputData(\nwhiteImage\n)\n;\n\n    openClose->\nSetOpenValue(0)\n;\n    openClose->\nSetCloseValue(255)\n;\n    openClose->\nSetKernelSize(5, 5, 3)\n;\n    openClose->\nReleaseDataFlagOff()\n;\n    openClose->\nGetOutput()\n;\n    openClose->\nGetCloseValue()\n;\n    openClose->\nGetOpenValue()\n;\n\n \n\n    vtkNew openCloseActor;\n    openCloseActor->\nGetMapper()\n->\nSetInputConnection(\nopenClose\n->GetOutputPort()\n);\n\n    \n// Define viewport ranges\n\n    \n// (xmin, ymin, xmax, ymax)\n\n    double originalViewport\n[\n4\n]\n = { \n0.0\n, \n0.0\n, \n0.5\n, \n1.0\n };\n    double openCloseViewport\n[\n4\n]\n = { \n0.5\n, \n0.0\n, \n1.0\n, \n1.0\n };\n\n    \n// Setup renderers\n\n  \n\n    vtkNew openCloseRenderer;\n    openCloseRenderer->\nSetViewport(\nopenCloseViewport\n)\n;\n    openCloseRenderer->\nAddActor(\nopenCloseActor\n)\n;\n    openCloseRenderer->\nResetCamera()\n;\n    openCloseRenderer->\nSetBackground(.4, .5, .7)\n;\n    openCloseRenderer->\nSetBackground(\ncolors\n->GetColor3d(\n\"RoyalBlue\"\n)\n.\nGetData()\n);\n\n    vtkNew renderWindow;\n    renderWindow->\nSetSize(600, 300)\n;\n    renderWindow->\nAddRenderer(\nopenCloseRenderer\n)\n;\n    renderWindow->\nSetWindowName(\n\"ImageOpenClose3D\"\n)\n;\n\n    vtkNew renderWindowInteractor;\n    vtkNew style;\n\n    renderWindowInteractor->\nSetInteractorStyle(\nstyle\n)\n;\n\n    renderWindowInteractor->\nSetRenderWindow(\nrenderWindow\n)\n;\n    renderWindow->\nRender()\n;\n    renderWindowInteractor->\nInitialize()\n;\n\n    renderWindowInteractor->\nStart()\n;\n\n    return EXIT_SUCCESS;\n}\n\n\n\n\n运行结果：\n\n\n\n\n好多代码似懂非懂不知问题在哪里，求解答", "Tag": "算法分析"}
{"Answer": "extends 表示继承这个模板，你下面给的是一堆html代码，似乎你把它理解成了两个html叠加，即便叠加，也不应该出现两个头吧\r\n\r\nhttps://docs.djangoproject.com/zh-hans/2.1/ref/templates/language/#template-inheritance", "Konwledge_Point": "模运算", "Question": "Django中静态文件的加载及模板中{% static %}标签的使用问题\n本人用Django1.11，在模板中用{% static %}标签加载静态文件时遇到问题：\n\n\n\n如果把{% extends %}标签那行去掉，浏览器中访问这个主页时可以正常显示图片，js文件也能正常加载，不过一旦有{% extends %}标签继承模板，图片就不显示，js文件不加载，但是服务器也没报404。\n\n\n\n项目设置如下：\n\n\n\n\n\n\n有关于在开发环境中静态文件的设置都做了，静态文件放在了app名文件夹/static文件夹/app名文件夹下\n\n\n\n\n\n\n请问大神是哪里出了问题导致静态文件没有加载，谢谢！", "Tag": "算法分析"}
{"Answer": "\nvoid jia(char *str, char *key, int len)\n{\n    int i = 0;\n    char ch;\n    while (*str)\n    {\n        if (i == len)\n            i = 0;\n        ch = *str;\n        ch += key[i];\n        if (ch < ' ' || ch > 'z')\n            ch %= 'z';\n        *str = ch;\n        str++;\n        i++;\n    }\n}\nvoid jie(char *str, char *key, int len)\n{\n    int i = 0;\n    char ch;\n    while (*str)\n    {\n        if (i == len)\n            i = 0;\n        ch = *str;\n        ch -= key[i];\n        if (ch < ' ' || ch > 'z')\n            ch %= 'z';\n        *str = ch;\n        str++;\n        i++;\n    }\n}\n\nint main()\n{\n    // 函数声明\n    // int jia(char *str, int len, char *key);\n    char str[100];\n    char key[7] = {4, 9, 6, 2, 8, 7, 3}; // 密钥\n    // char ch = 0;\n    // int i = 0;\n    cout << \"请输入一行字符来进行加密\" << endl;\n    cin.getline(str, 100);\n    // while ((ch = getchar()) != '\\n')\n    // {\n    //     str[i] = ch;\n    //     i++;\n    // }\n    // int len = i;\n    // jia(&str[i], len, &key[7]);\n    jia(str, key, 7);\n    cout << str << endl;\n    jie(str, key, 7);\n    cout << str;\n\n    return 0;\n}\n\n", "Konwledge_Point": "模运算", "Question": "C++字符串指针的加密\nC++字符串指针的加密\n\n\n运行结果为什么是乱码，还有超出范围的模运算，我不太肯定是不是这样子简单地ascii码加减90\n\n\n\n\n/*编制程序，将输入的一行字符（明文）加密和解密。加密时，明文的每个字符依次反复加上“4962873”中的数字，\n如果范围超过ASCII码的032(空格)--122(’z’)，则进行模运算。解密与加密的顺序相反。\n编制加密和解密函数，打印各个过程的结果。\n例如，加密：the result of 3 and 2 is not 8\n(t)116+4，(h)104+9，(e)101+6，()32+2，(r)114+8，(e)1Ol+7，(s)115+3,\n(u)117+4，(l)108+9，(t)116+6，( )32+2,(o)111+8，(f)102+7，( )32+3，(3)51+4,\n()32+9，(a)97+6，(n)110+2，(d)100+8，( )32+7，(2)50+3，( )32+4，(i)105+9，(s)115+6，()32+2，(n)110+8，(o)111+7，(t)L16+3，( )32+4，(8)56+9\n得到密文为：\nxqk”zlvyuz”wm#7>gpl’s$ry”vvw$A\n*/\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\nint\n \nmain\n()\n \n{\n    \n//函数声明\n\n    \nint\n \njia\n(\nchar\n* str, \nint\n len, \nchar\n* key)\n;\n    \nchar\n str[\n100\n];\n    \nchar\n key[\n7\n] = { \n4\n,\n9\n,\n6\n,\n2\n,\n8\n,\n7\n,\n3\n };\n//密钥\n\n    \nchar\n ch = \n0\n;\n    \nint\n i = \n0\n;\n    cout << \n\"请输入一行字符来进行加密\"\n << endl;\n    \nwhile\n ((ch=\ngetchar\n()) != \n'\\n'\n) {\n        str[i] = ch;\n        i++;\n    }\n    \nint\n len = i;\n    \njia\n(&str[i],len,&key[\n7\n]);\n    \nreturn\n \n0\n;\n}\n\nint\n \njia\n(\nchar\n* str, \nint\n len,\nchar\n* key)\n \n{\n    \nchar\n *m = &str[\n0\n];\n//m为明文\n\n    \nchar\n *n = &key[\n0\n];\n//n为密钥\n\n    \nchar\n *res = \nnew\n \nchar\n[len];\n    \nfor\n (\nint\n j = \n0\n; j < len; j++) {\n        \nif\n (*(m + j) < \n' '\n) {\n            *(res + j) = *(m + j) + \n90\n + *(n + j % \n7\n);\n        }\n        \nif\n (*(m + j) > \n'z'\n) {\n            *(res + j) = *(m + j) - \n90\n + *(n + j % \n7\n);\n        }\n        \n        *(res + j) = *(m + j) + *(n + j % \n7\n);\n    }\n    \nfor\n (\nint\n j = \n0\n; j < len; j++) {\n        cout << *(res + j);\n    }\n\n    \nreturn\n \n0\n;\n}\n\n\n\n\n\n\n反反复复看，是指针的哪里出问题了啊\n\n", "Tag": "算法分析"}
{"Answer": "#include\"stdio.h\"  \r\n#include\"stdlib.h\"   \r\n#include\"string.h\"   \r\n#include\"math.h\"  \r\n\r\n#define true 1   \r\n#define false 0   \r\n#define OPSETSIZE 8   \r\ntypedef int Status;   \r\n\r\nunsigned char Prior[8][8] =  \r\n{ // 运算符优先级表   \r\n\t// '+' '-' '*' '/' '(' ')' '#' '^'   \r\n\t/*'+'*/'>','>','<','<','<','>','>','<',   \r\n\t/*'-'*/'>','>','<','<','<','>','>','<',   \r\n\t/*'*'*/'>','>','>','>','<','>','>','<',   \r\n\t/*'/'*/'>','>','>','>','<','>','>','<',   \r\n\t/*'('*/'<','<','<','<','<','=',' ','<',   \r\n\t/*')'*/'>','>','>','>',' ','>','>','>',   \r\n\t/*'#'*/'<','<','<','<','<',' ','=','<',   \r\n\t/*'^'*/'>','>','>','>','<','>','>','>'   \r\n};   \r\n\r\ntypedef struct StackChar  \r\n{  \r\n\tchar c;   \r\n\tstruct StackChar *next;   \r\n}SC;       //StackChar类型的结点SC  \r\n\r\ntypedef struct StackFloat  \r\n{  \r\n\tfloat f;   \r\n\tstruct StackFloat *next;   \r\n}SF;       //StackFloat类型的结点SF  \r\n\r\nSC *SC_Push(SC *s,char c)          //SC类型的指针Push，返回p  \r\n{  \r\n\tSC *p=(SC*)malloc(sizeof(SC));   \r\n\tp->c=c;   \r\n\tp->next=s;   \r\n\treturn p;   \r\n}   \r\n\r\nSF *SF_Push(SF *s,float f)        //SF类型的指针Push，返回p  \r\n{  \r\n\tSF *p=(SF*)malloc(sizeof(SF));   \r\n\tp->f=f;   \r\n\tp->next=s;   \r\n\treturn p;   \r\n}   \r\n\r\nSC *SC_Pop(SC *s)    //SC类型的指针Pop  \r\n{  \r\n\tSC *q=s;   \r\n\ts=s->next;   \r\n\tfree(q);   \r\n\treturn s;   \r\n}   \r\n\r\nSF *SF_Pop(SF *s)      //SF类型的指针Pop  \r\n{  \r\n\tSF *q=s;   \r\n\ts=s->next;   \r\n\tfree(q);   \r\n\treturn s;   \r\n}   \r\n\r\nfloat Operate(float a,unsigned char theta, float b)      //计算函数Operate  \r\n{  \r\n\tswitch(theta)  \r\n\t{  \r\n\t\tcase '+': return a+b;   \r\n\t\tcase '-': return a-b;   \r\n\t\tcase '*': return a*b;   \r\n\t\tcase '/': return a/b;   \r\n\t\tcase '^': return powf(a,b);   \r\n\t\tdefault : return 0;   \r\n\t}   \r\n}   \r\n\r\nchar OPSET[OPSETSIZE]={'+','-','*','/','(',')','#','^'};   \r\n\r\nStatus In(char Test,char *TestOp)  \r\n{  \r\n\tint Find=false;   \r\n\tfor (int i=0; i< OPSETSIZE; i++)  \r\n\t{  \r\n\t\tif(Test == TestOp[i])  \r\n\t\t\tFind= true;   \r\n\t}   \r\n\treturn Find;   \r\n}   \r\n\r\nStatus ReturnOpOrd(char op,char *TestOp)  \r\n{   \r\n\tfor(int i=0; i< OPSETSIZE; i++)  \r\n\t{  \r\n\t\tif (op == TestOp[i])  \r\n\t\t\treturn i;  \r\n\t}  \r\n}  \r\n\r\nchar precede(char Aop, char Bop)  \r\n{   \r\n\treturn Prior[ReturnOpOrd(Aop,OPSET)][ReturnOpOrd(Bop,OPSET)];   \r\n}   \r\n\r\nfloat EvaluateExpression(char* MyExpression)  \r\n{   \r\n\t// 算术表达式求值的算符优先算法  \r\n\t// 设OPTR和OPND分别为运算符栈和运算数栈，OP为运算符集合   \r\n\tSC *OPTR=NULL;       // 运算符栈，字符元素   \r\n\tSF *OPND=NULL;       // 运算数栈，实数元素   \r\n\tchar TempData[20];   \r\n\tfloat Data,a,b;   \r\n\tchar theta,*c,Dr[]={'#','\\0'};   \r\n\tOPTR=SC_Push(OPTR,'#');   \r\n\tc=strcat(MyExpression,Dr);   \r\n\tstrcpy(TempData,\"\\0\");//字符串拷贝函数   \r\n\twhile (*c!= '#' || OPTR->c!='#')  \r\n\t{   \r\n\t\tif (!In(*c, OPSET))  \r\n\t\t{   \r\n\t\t\tDr[0]=*c;   \r\n\t\t\tstrcat(TempData,Dr);           //字符串连接函数   \r\n\t\t\tc++;   \r\n\t\t\tif (In(*c, OPSET))  \r\n\t\t\t{   \r\n\t\t\t\tData=atof(TempData);       //字符串转换函数(double)   \r\n\t\t\t\tOPND=SF_Push(OPND, Data);   \r\n\t\t\t\tstrcpy(TempData,\"\\0\");   \r\n\t\t\t}   \r\n\t\t}   \r\n\t\telse    // 不是运算符则进栈   \r\n\t\t{  \r\n\t\t\tswitch (precede(OPTR->c, *c))  \r\n\t\t\t{  \r\n\t\t\t\tcase '<': // 栈顶元素优先级低   \r\n\t\t\t\t\tOPTR=SC_Push(OPTR, *c);   \r\n\t\t\t\t\tc++;   \r\n\t\t\t\t\tbreak;   \r\n\t\t\t\tcase '=': // 脱括号并接收下一字符   \r\n\t\t\t\t\tOPTR=SC_Pop(OPTR);   \r\n\t\t\t\t\tc++;   \r\n\t\t\t\t\tbreak;   \r\n\t\t\t\tcase '>': // 退栈并将运算结果入栈   \r\n\t\t\t\t\ttheta=OPTR->c;OPTR=SC_Pop(OPTR);   \r\n\t\t\t\t\tb=OPND->f;OPND=SF_Pop(OPND);   \r\n\t\t\t\t\ta=OPND->f;OPND=SF_Pop(OPND);   \r\n\t\t\t\t\tOPND=SF_Push(OPND, Operate(a, theta, b));   \r\n\t\t\t\t\tbreak;   \r\n\t\t\t} //switch  \r\n\t\t}   \r\n\t} //while   \r\n\treturn OPND->f;   \r\n} //EvaluateExpression   \r\n\r\nint main(void)  \r\n{   \r\n\tchar s[128];  \r\n\tputs(\"请输入表达式:\");   \r\n\tgets(s);  \r\n\tputs(\"该表达式的值为:\");   \r\n\tprintf(\"%s\\b=%g\\n\",s,EvaluateExpression(s));  \r\n\treturn 0;  \r\n}  \r\n\r\n```\r\n \r\n```", "Konwledge_Point": "模运算", "Question": "怎样用c实现链栈的算术表达式运算，不得使用stl模板\n按照严蔚敏版的书上的算法，用c语言链栈实现，不让使用stl模板，有没有原代码", "Tag": "算法分析"}
{"Answer": "if (flag = 1) C = fgetc(source);\n改为if (flag == 1) C = fgetc(source);", "Konwledge_Point": "模运算", "Question": "为什么这个函数调用时老是闪退？求大佬解惑（加密文件里面的内容）\n\n\nvoid encode2() /*加密文件*/\n{ \n\tint m,n=strlen(password.ps),d;\n\tint i,flag = 1; //m存储加密字符长度 ,n存储加密字符串长度 ,i 为临时变量\n\tchar N,w; \n\tchar c,C;//临时字符存储变量\n\tchar ch='a';\n\tFILE *result = fopen(\"result.txt\",\"wt\"); \n\tif(result == NULL ) \n\t{\n\t\tprintf(\"无法打开 result.txt \\n\");\n\t\texit(0);\n\t} \n\tFILE *source = fopen(\"source.txt\",\"wt\");\n\tif(source == NULL ) \n\t{\n\t\tprintf(\"无法打开 source.txt \\n\");\n\t\tflag = 0;\n\t}\n    char filename[100];  //文件名 \n    printf(\"请输入要加密的文件名及地址：\\n\"); \n\tgetchar();\n    gets(filename);  //这句要用户输入文件名\n\tFILE *fp=fopen(filename,\"r\");\n    if (fp==NULL)   //打开文件，并判断是否有打开错误\n\t{\n\t\tprintf(\"无法打开文件\\n\"); \n\t\tsystem(\"pause\");\n        exit(0);\n\t }  \n\t while((ch=fgetc(fp))!=EOF)\n\t {\n\t\t fputc(ch,source);\n\t }\n\tif (flag = 1) C = fgetc(source);\n\tfor( i=0;(c=fgetc(source)) != EOF;i++) \n\t{ \n\t\tstatic int a=1; \n\t\tif((a122) \n\t\t\t{ \n\t\t\t\tN=N%122; /*模运算*/\n\t\t\t} \n\t\t\tfputc(N,result); \n\t\t\ta++; \n\t\t} \n\t\telse fputc(N,result); \n\t} \n\tprintf(\"\\n加密成功!\\n\"); \n\tfclose(result); \n\tfclose(source);\n\tfclose(fp);\n\tsystem(\"pause\");\n}", "Tag": "算法分析"}
{"Answer": "#include<cstdio>\n\nint a,b;\n\nchar c; \n\nint main()\n{\n    c = getchar();\n    \n    if(c != '+' and c != '-' and c != '*' and c != '/' and c != '%')\n\n        return !printf(\"input error!\");\n        \n    scanf(\"%d%d\",&a,&b);\n    \n    if((c == '/' or c == '%')and b == 0) \n    \n        return !printf(\"input error!\");\n        \n    if(c == '+') printf(\"%d\",a + b );\n    \n    if(c == '-') printf(\"%d\",a - b );\n    \n    if(c == '*') printf(\"%d\",a * b );\n    \n    if(c == '/') printf(\"%d\",a / b );\n    \n    if(c == '%') printf(\"%d\",a % b );\n}\n", "Konwledge_Point": "模运算", "Question": "程序，输入字符是算式运作字符就输入2个数计算，如果不是就输出输入错误\n", "Tag": "算法分析"}
{"Answer": "那就只能异步操作。计算时多线程，让它不阻塞页面渲染。只有这一个方案", "Konwledge_Point": "模运算", "Question": "【Vue】如何在Vue项目中实现运行一个大运算量模型的同时让页面的图表进行实时更新？\n目前找到的解决方案是使用多线程，但页面上的图表数据是依赖于大运算量模型的，目前只能实现主线程不卡，但做不到\n主线程的图表\n随着\n子线程模型的数据\n实时更新。（假设模型至少运行10s）\n\n\n\n跪求各位大佬提供合适的解决思路，跪谢！\n\n\n\n有简单的例子解说是最最好的，跪跪谢！", "Tag": "算法分析"}
{"Answer": "你好，你这个卷积核没有归一化，所以显示不了图像：\nd = imread('test.jpg');\nd = rgb2gray(d);\na1=conv2(a/sum(a(:)),d);\nimshow(a1) \n", "Konwledge_Point": "模运算", "Question": "急！zy！要截止了！请问模板和图像进行二维卷积运算后，为什么新图像是空白的\na1=conv2(a,d) a为模板，d为图像，\n得到的a1是空白图像，这是为啥", "Tag": "算法分析"}
{"Answer": "http://www.icourses.cn/jpk/viewCharacterDetail.action?courseId=4246&sectionId=35341", "Konwledge_Point": "模运算", "Question": "如何采用静态链表表示一元多项式\n1， 基于静态链表的模板，给出一元多项式 SPolymormial 的数据结构定义；\n\n2） 实现成员函数 Cal（double x），计算多项式在 x 处的值。\n\n注：假设指数为非负数，且多项式生成时按指数由低到高排列 ", "Tag": "算法分析"}
{"Answer": "具体要看你的程序，如果你不使用batch，那么通常的做法是把当前的权重在所有数据之上跑一次（正向传播），然后算出梯度，根据梯度修正每个隐层的权重（反向传播），这个整个的过程算一个迭代。\r\n你说的每年的数据做一个迭代，实际上算迁移学习了，一些情况下，比如又要不断学习，又要部署，那么其实就是用你的类似的思路去计算。", "Konwledge_Point": "模运算", "Question": "BP神经网络模型，如果要预测数据，是每一个数据都迭代N次吗？\n比如，以下例子：\n\n                某地区20年公路运量数据\n\n 年份         人口数量     机动车数量       公路面积         公路客运量      公路货运量\n\n1990         20.55             0.6                   0.09                5126                  1237\n\n1991           22.44             0.75                 0.11                6217                  1379\n\n1992           25.37             0.85                 0.11                7730                  1385\n\n1993           27.13             0.90                 0.14                9145                  1399\n\n1994           29.45             1.05                 0.20                10460                1663\n\n1995           30.1               1.35                 0.23                11387                1714\n\n1996           30.96             1.45                 0.23                12353                1834 \n\n1997           34.06             1.60                 0.32                15750                 4322\n\n1998           36.42             1.70                 0.32                 18304                8132\n\n1999           38.09             1.85                 0.34                 19836                8936\n\n2000           39.13              2.15                0.36                  21024               11099\n\n2001           39.99              2.20                0.36                 19490                11203\n\n2002           41.93              2.25                0.38                  20433               10524\n\n2003           44.59               2.35                0.49                  22598               11115\n\n2004           47.30              2.50                0.56                     ？                      ？\n\n2005          52.89              2.60                0.59                      ？                      ？\n\n题目的要求要我们预测2004和2005两年的公路客运量与公路货运量。\n\n\n\n首先，我现在已经清楚了BP神经网络的原理，包括正向传播反向传播激励函数等等，我自己也编写了一套BP神经网络的运算程序。现在我只想搞清楚一个简单的问题，对于这个实例，具体的运算步骤，是否是将人口数量、机动车数量以及公路面积作为3个输入层节点，隐藏层节点数就自己定了，输出层节点是公路客运量和公路货运量2个节点。那么我如果设置学习迭代次数为1000次。步骤是否是：对1990年的数据进行迭代1000次的学习，然后再对1991年的数据进行迭代1000次学习，对1991年初始权重值和偏值为1990年迭代1000次后最终更新的各节点的权重值和偏值，然后依次往下，即每年都会迭代1000次学习。\n\n各位一定看懂我的问题，不要答非所问", "Tag": "算法分析"}
{"Answer": "在空三计算中，模型重建的切块模式和瓦片大小对空三计算具有重要影响。切块模式可以影响地表特征的提取以及建模精度，而瓦片大小可以影响计算效率。\n切块模式：\n对于单一大场景的重建，采用全局切块模式可以保证地物特征的连续性和一致性，提高重建精度。\n对于多个小场景的重建，采用局部切块模式可以减少地物特征的遮挡和影响，提高重建精度。\n\n瓦片大小：\n对于大型场景，采用较大的瓦片大小可以提高计算效率，但可能会降低重建精度，因为在瓦片边缘处可能会存在地物特征的丢失。\n对于小型场景，采用较小的瓦片大小可以提高重建精度，但计算效率较低。\n\n因此，根据不同场景的特点和需求，可以采用不同的切块模式和瓦片大小。通常建议采用50-100米左右的瓦片大小，并根据场景特点分别采用全局或局部切块模式。", "Konwledge_Point": "模运算", "Question": "smart3D空三运算\n空三计算中，模型重建这一步骤中，切块模式和瓦片大小的变化对空三计算有什么影响？怎么设置比较合理？", "Tag": "算法分析"}
{"Answer": "keras.preprocessing.image.load_image(path) 其中 path 是文件路径而不是 image 本身的内容\n最简单的办法：django把图片保存成文件后给 load_image(path) 传入文件路径\n或者用其他API读图像", "Konwledge_Point": "模运算", "Question": "把训练好的cifar10数据集的模型并预测好的代码部署在django上，部署之后程序运行出错\n我的设想是想要把训练好的cifar10数据集的模型并预测好的代码部署在django上，想通过前端上传图片然后传到后端进行预测，然后再返回前端\n\n\n问题相关代码，请勿粘贴截图\n\n\n前端代码\n\n\n\n\n            \n<\ndiv\n \nclass\n=\n\"row\"\n>\n\n                \n<\nbr\n>\n\n                \n\n\n                \n<\ndiv\n \nclass\n=\n\"col-md-6\"\n>\n\n                    \n<\nimg\n \nid\n=\n\"photoIn\"\n \nsrc\n=\n\"\n{% \nstatic\n 'img/sample.jpg' %}\n\"\n \nclass\n=\n\"img-responsive\"\n>\n\n                    \n<\ninput\n \ntype\n=\n\"file\"\n \nid\n=\n\"photo\"\n \nname\n=\n\"photo\"\n />\n\n                \n\n\n\n                \n<\ndiv\n \nclass\n=\n\"col-md-6\"\n>\n\n                    \n<\ndiv\n \nclass\n=\n\"col-md-12\"\n>\n\n                        \n<\ntextarea\n \nid\n=\n\"output\"\n \ndisabled\n \nclass\n=\n\"form-control\"\n \nrows\n=\n\"5\"\n\n                            \nstyle\n=\n\"text-align: left;font: 150px 宋体;border: 0\"\n>\n\n                        \n\n\n\n                    \n<\nbr\n>\n\n                    \n<\ndiv\n \nclass\n=\n\"col-md-12\"\n>\n\n                        \n<\np\n \nclass\n=\n\"text-center h4\"\n>\n识别结果\n\n\n\n\n\n            \n<\nbr\n>\n\n            \n<\ndiv\n \nclass\n=\n\"row\"\n>\n\n                \n<\ndiv\n \nclass\n=\n\"text-center\"\n>\n\n                    \n<\nbutton\n \ntype\n=\n\"button\"\n \nid\n=\n\"recognition\"\n \nclass\n=\n\"btn btn-primary\"\n>\n识别\n\n\n\n\n\n\n\n\n<\nscript\n>\n\n    $(\nfunction\n (\n) {\n        $(\n'#photo'\n).\non\n(\n'change'\n, \nfunction\n (\n) {\n            \nvar\n r = \nnew\n \nFileReader\n();\n            f = \ndocument\n.\ngetElementById\n(\n'photo'\n).\nfiles\n[\n0\n];\n            r.\nreadAsDataURL\n(f);\n            r.\nonload\n = \nfunction\n (\ne\n) {\n                \ndocument\n.\ngetElementById\n(\n'photoIn'\n).\nsrc\n = \nthis\n.\nresult\n;\n            };\n        });\n    });\n\n\n\n\n\n<\nscript\n>\n\n    $(\n'#recognition'\n).\nclick\n(\nfunction\n (\n) {\n        formdata = \nnew\n \nFormData\n();\n        \nvar\n file = $(\n\"#photo\"\n)[\n0\n].\nfiles\n[\n0\n];\n        formdata.\nappend\n(\n\"image\"\n, file);\n        $.\najax\n({\n            \nurl\n: \n'/productapp/imgdetect/'\n, \n// 调用Django服务器计算函数\n\n            \ntype\n: \n'POST'\n, \n// 请求类型\n\n            \ndata\n: formdata,\n            \ndataType\n: \n'json'\n, \n// 期望获得的响应类型为json\n\n            \nprocessData\n: \nfalse\n,\n            \ncontentType\n: \nfalse\n,\n            \nsuccess\n: \nShowResult\n \n// 在请求成功之后调用该回调函数输出结果\n\n        })\n    })\n\n\n\n\n\n<\nscript\n>\n\n    \nfunction\n \nShowResult\n(\ndata\n) {\n        output.\nvalue\n = data[\n'output'\n];\n    }\n\n\n\n\n<\nscript\n>\n\n    \ndocument\n.\ngetElementById\n(\n\"output\"\n).\nstyle\n.\nwidth\n=\n\"400px\"\n;\n    \ndocument\n.\ngetElementById\n(\n\"output\"\n).\nstyle\n.\nheight\n=\n\"350px\"\n;\n\n\n\n\n\n\n后端代码\n\n\nfrom\n django.shortcuts \nimport\n render\n\n\n\n# Create your views here.\n\n\ndef\n \nproduct\n(\nrequest\n):\n    \nreturn\n render(request, \n'product.html'\n,{\n'active_menu'\n: \n'about'\n,\n'sub_menu'\n: \n'product1'\n,})\n\n\ndef\n \nsystem\n(\nrequest\n):\n    \nreturn\n render(request, \n'system.html'\n,{\n'active_menu'\n: \n'about'\n,\n'sub_menu'\n: \n'product2'\n,})    \n\n\n\n# 人脸识别\n\n\nimport\n numpy \nas\n np  \n# 矩阵运算\n\n\nimport\n urllib  \n# url解析\n\n\nimport\n json  \n# json字符串使用\n\n\nimport\n cv2  \n# opencv包\n\n\nimport\n os  \n# 执行操作系统命令\n\n\nfrom\n django.views.decorators.csrf \nimport\n csrf_exempt  \n# 跨站点验证\n\n\nfrom\n django.http \nimport\n JsonResponse  \n# json字符串响应\n\n\nfrom\n PIL \nimport\n Image\n\nimport\n keras.models\n\nimport\n numpy \nas\n np\n\nimport\n tensorflow \nas\n tf\n\nfrom\n keras.preprocessing \nimport\n image\n\n\ndef\n \nread_image\n(\nstream=\nNone\n):\n    \nif\n stream \nis\n \nnot\n \nNone\n:\n        data_temp = stream.read()\n    img = np.asarray(\nbytearray\n(data_temp), dtype=\n\"uint8\"\n)\n    img = cv2.imdecode(img, cv2.IMREAD_COLOR)\n    \nreturn\n img\n\n\nface_detector_path = \n\"productapp\\\\haarcascade_frontalface_default.xml\"\n\nface_detector = cv2.CascadeClassifier(face_detector_path)  \n# 生成人脸检测器\n\n\n\n@csrf_exempt  \n# 用于规避跨站点请求攻击\n\n\ndef\n \nfacedetect\n(\nrequest\n):\n    result = {}\n\n    \nif\n request.method == \n\"POST\"\n:  \n# 规定客户端使用POST上传图片\n\n        \nif\n request.FILES.get(\n\"image\"\n, \nNone\n) \nis\n \nnot\n \nNone\n:  \n# 读取图像\n\n            img = read_image(stream=request.FILES[\n\"image\"\n])\n        \nelse\n:\n            result.update({\n                \n\"#faceNum\"\n: -\n1\n,\n            })\n            \nreturn\n JsonResponse(result)\n\n        \nif\n img.shape[\n2\n] == \n3\n:\n            img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)  \n# 彩色图像转灰度图像\n\n\n        \n#进行人脸检测\n\n        values = face_detector.detectMultiScale(img,\n                                                scaleFactor=\n1.1\n,\n                                                minNeighbors=\n5\n,\n                                                minSize=(\n30\n, \n30\n),\n                                                flags=cv2.CASCADE_SCALE_IMAGE)\n\n        \n# 将检测得到的人脸检测关键点坐标封装\n\n        values = [(\nint\n(a), \nint\n(b), \nint\n(a + c), \nint\n(b + d))\n                  \nfor\n (a, b, c, d) \nin\n values]\n        result.update({\n            \n\"#faceNum\"\n: \nlen\n(values),\n            \n\"faces\"\n: values,\n        })\n    \nreturn\n JsonResponse(result)\n\n\n\nimport\n base64\n\n\n\n@csrf_exempt\n\n\ndef\n \nfacedetectDemo\n(\nrequest\n):\n    result = {}\n\n    \nif\n request.method == \n\"POST\"\n:\n        \nif\n request.FILES.get(\n'image'\n) \nis\n \nnot\n \nNone\n:  \n#\n\n            img = read_image(stream=request.FILES[\n\"image\"\n])\n        \nelse\n:\n            result.update({ \n\"#faceNum\"\n : -\n1\n,})\n            \nreturn\n JsonResponse(result)\n\n        \nif\n img.shape[\n2\n] == \n3\n:\n            imgGray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)  \n# 彩色图像转灰度图像\n\n        \nelse\n:\n            imgGray = img\n\n        \n#进行人脸检测\n\n        values = face_detector.detectMultiScale(img,\n                                           scaleFactor=\n1.1\n,\n                                           minNeighbors=\n5\n,\n                                           minSize=(\n30\n, \n30\n),\n                                           flags=cv2.CASCADE_SCALE_IMAGE)\n\n        \n#将检测得到的人脸检测关键点坐标封装\n\n        values = [(\nint\n(a), \nint\n(b), \nint\n(a + c), \nint\n(b + d))\n                  \nfor\n (a, b, c, d) \nin\n values]\n\n        \n# 将检测框显示在原图上\n\n        \nfor\n (w, x, y, z) \nin\n values:\n            cv2.rectangle(img, (w, x), (y, z), (\n0\n, \n255\n, \n0\n), \n2\n)\n\n        retval, buffer_img = cv2.imencode(\n'.jpg'\n, img)  \n# 在内存中编码为jpg格式\n\n        img64 = base64.b64encode(buffer_img)  \n# base64编码用于网络传输\n\n        img64 = \nstr\n(img64, encoding=\n'utf-8'\n)  \n# bytes转换为str类型\n\n        result[\n\"img64\"\n] = img64  \n# json封装\n\n    \nreturn\n JsonResponse(result)\n    \n\n@csrf_exempt \n# 用于规避跨站点请求攻击\n\n\ndef\n \nimgdetect\n(\nrequest\n):\n    result = {\n\"code\"\n:\nNone\n}\n    \nif\n request.method == \n\"POST\"\n:  \n# 规定客户端使用POST上传图片\n\n        \nif\n request.FILES.get(\n\"image\"\n, \nNone\n) \nis\n \nnot\n \nNone\n:  \n# 读取图像\n\n            img = read_image(stream=request.FILES[\n\"image\"\n])\n        model = keras.models.load_model(\n\"E:\\demo1\\productapp\\model.h5\"\n)\n        classes = (\n'plane'\n, \n'car'\n, \n'bird'\n, \n'cat'\n,\n'deer'\n, \n'dog'\n, \n'frog'\n, \n'horse'\n, \n'ship'\n, \n'truck'\n)\n        \n# img=Image.fromarray(cv2.cvtColor(img,cv2.COLOR_BGR2RGB))\n\n        img=image.load_img(img,target_size=(\n224\n,\n224\n,))\n        img_data = image.img_to_array(img)\n        img_data = np.expand_dims(img_data, axis=\n0\n)\n        test_img = img_data / \n255\n  \n# 此处还需要将0-255转化为0-1\n\n        \n# test_img = np.expand_dims(test_img, 0)  # 将三维输入图像拓展成四维张量\n\n        pred = model.predict(test_img)  \n# 预测\n\n        \nprint\n(\n'预测结果：'\n, end=\n''\n)\n        code=classes[pred.argmax()]\n        result.update({\n\"output\"\n:code})   \n    \nreturn\n JsonResponse(result)\n\n\n\n运行结果及报错内容\n\n\n当我点识别的时候\n出现了这个错误\n\n\n\n\n请问这个要怎么解决呀害", "Tag": "算法分析"}
{"Answer": "timestamp时间戳向左位移32位，然后整体就变为了：时间戳 + 32 位（32位全为0），这里记为 tBits\n\n或运算：同0为0，否则为1\n\n然后tBits | count，count为32位，所以count只会与tBits的后32位做或运算，由于tBits后32位全为零，000……000 | count = count", "Konwledge_Point": "模运算", "Question": "学习Redis全局ID自增的时候，为什么return的时候使用了或运算就可以了完成这个操作\n我在学习ID全局生成器的时候，想生成下图这样的id模板，但是最后return出现了一个或运算我不太理解，\n而且 long count = stringRedisTemplate.opsForValue().increment(\"icr:\"+keyPrefix+\":\"+date);这条语句的执行结果只有1或者0，为什么     return timestamp<< COUNT_BITS | count; 就可以实现下面这个模板呢？\n\n\n\n\n\n//\n基于Redis的id生成器\n@Component\npublic class RedisWorker {\n\n//\n   开始的一个时间戳\n\n//\n    时间戳 指的就是Unix时间戳(Unix timestamp)。\n\n//\n    它也被称为Unix时间(Unix time)、POSIX时间(POSIX time)，是一种时间表示方式，\n\n//\n    定义为从格林威治时间\n1970\n年\n01\n月\n01\n日\n00\n时\n00\n分\n00\n秒起至现在的总秒数。\n     private  static  final long BEGIN_TIMESTAPMP=\n1640995200\nL;\n\n//\n   序列号的位数\n     private  static  final int COUNT_BITS = \n32\n;\n     @Resource\n     private StringRedisTemplate stringRedisTemplate;\n    /**\n     *\n     * @param keyPrefix  前缀\n     * @return\n     */\n    public long nextId(String keyPrefix){\n\n//\n        \n1\n.生成时间戳     当前时间\n        LocalDateTime now = LocalDateTime.now();\n\n//\n           当前时间的秒数\n        long nowSecond = now.toEpochSecond(ZoneOffset.UTC);\n\n//\n           计算一下时间戳\n        long timestamp = nowSecond-BEGIN_TIMESTAPMP;\n\n\n//\n        \n2\n.生成序列号   我们用的Redis中的String数据结构  increment是自增，括号可以填一个参数key\n\n//\n             \n2.1\n获取当前日期，精确到Tina\n        String date = now.format(DateTimeFormatter.ofPattern(\n\"yyyy:MM:dd\"\n));\n\n//\n             \n2.2\n 自增长   我们在后面添加一个日期还是有好处的，每一天都是不同的key，当我们获取某一天的订单的时候也好查询，\n\n//\n                         另外如果都是用同一个key的话，可能会超过\n2\n的\n32\n次方\n        long count = stringRedisTemplate.opsForValue().increment(\n\"icr:\"\n+keyPrefix+\n\":\"\n+date);\n\n//\n        \n3\n.拼接并返回\n\n//\n           借助位运算进行拼接，如果直接拼接的话就成字符串了\n\n//\n           时间戳移动\n32\n位(因为我们定义的就是\n32\n位，定义为了一个常量) 后面空出来的\n32\n位（序列号）就补零\n\n//\n           序列号采用或运算填充 后面\n32\n为刚开始为\n0\n，count可能为\n0\n也可能为\n1\n，不管是\n0\n还是\n1\n 都填入进去\n        return timestamp<< COUNT_BITS | count;\n    }\n\n\n//\n   用下面这个方法可以获取当前的时间戳\n\n//\n    public static void main(String[] args) {\n\n//\n//\n       得到\n2022\n年一月一号\n0\n时\n0\n分\n0\n秒这个时间\n\n//\n        LocalDateTime time = LocalDateTime.of(\n2022\n, \n1\n, \n1\n, \n0\n, \n0\n, \n0\n);\n\n//\n//\n       得到一个秒数  ZoneOffset.UTC是一个时间戳\n\n//\n         long second =time.toEpochSecond(ZoneOffset.UTC);\n\n//\n        System.out.println(second);\n\n//\n    }\n\n\n}\n", "Tag": "算法分析"}
{"Answer": "更正项少+项多时的错误：\r\n\r\n```\r\n#include\r\nusing namespace std;\r\n\r\n//约定稀疏多项式输入升幂排列\r\ntemplateclass Polynomial;\r\ntemplateostream& operator<<(ostream& out, Polynomial&a);\r\n\r\ntemplate\r\nclass Polynomial\r\n{\r\nprivate:\r\n\tclass Term\r\n\t{\r\n\tpublic:\r\n\t\tT xishu;\r\n\t\tint mi;\r\n\t};\r\n\tclass Node\r\n\t{\r\n\tpublic:\r\n\t\tTerm data;\r\n\t\tNode* next;\r\n\t\tNode(T x = 0, unsigned y = 0, Node* p = 0)\r\n\t\t{\r\n\t\t\tdata.xishu = x;\r\n\t\t\tdata.mi = y;\r\n\t\t\tnext = p;//修改\r\n\t\t}\r\n\t};\r\npublic:\r\n\tPolynomial();\r\n\tvoid myfree();//释放链表所有各节点\r\n\tPolynomial& operator=(const Polynomial&);\r\n\tPolynomial operator+(const Polynomial&);\r\n\tPolynomial operator*(const Polynomial&);\r\n\tvoid initial();\r\n\tfriend ostream& operator<<  (ostream& out, Polynomial& a);\r\n\r\nprivate:\r\n\tint highestdigit;\r\n\tNode* first;\r\n\tint num;//用来判断多项式有几项,即链表节点数,在乘法运算里也要用到\r\n};\r\ntemplate\r\nPolynomial::Polynomial()\r\n{\r\n\tfirst = new Node;\r\n\tnum = 0;\r\n\thighestdigit = 0;\r\n}\r\n\r\ntemplate\r\nvoid Polynomial::myfree()    //释放链表所有节点\r\n{\r\n\tNode* p = first, *q;\r\n\twhile (p)\r\n\t{\r\n\t\tq = p->next;\r\n\t\tdelete p;\r\n\t\tp = q;\r\n\t}\r\n\tfirst=NULL;//修改\r\n\tnum = 0; highestdigit = 0;//修改\r\n}\r\n\r\ntemplate\r\nPolynomial& Polynomial::operator=(const Polynomial& second)\r\n{\r\n\tmyfree();\r\n\thighestdigit = second.highestdigit;\r\n\tnum = second.num;\r\n\tfirst = second.first;\r\n\r\n\treturn *this;\r\n}\r\n\r\ntemplate\r\nPolynomial Polynomial::operator+(const Polynomial& second)\r\n{\r\n\tPolynomial sum;\r\n\tNode* pa = first->next, *pb = second.first->next, *pc = sum.first;\r\n\twhile (pa&&pb)\r\n\t{\r\n\t\tif (pa->data.mi == pb->data.mi)  // 指数相等时  \r\n\t\t{\r\n\t\t\tT x = pa->data.xishu + pb->data.xishu;\r\n\t\t\tif (x)     // 相加完的系数不为0时  \r\n\t\t\t{\r\n\t\t\t\tpc->next = new Node(x, pa->data.mi);\r\n\t\t\t\tpc = pc->next;\r\n\t\t\t\t++sum.num;\r\n\t\t\t\tif(sum.highestdigitdata.mi) sum.highestdigit = pa->data.mi;\r\n\t\t\t}\r\n\t\t\tpa = pa->next;\r\n\t\t\tpb = pb->next;\r\n\t\t}\r\n\t\telse if (pa->data.mi > pb->data.mi){\r\n\t\t\tpc->next = new Node(pa->data.xishu, pa->data.mi);\r\n\t\t\tif(sum.highestdigitdata.mi) sum.highestdigit = pa->data.mi;\r\n\t\t\t++sum.num;\r\n\t\t\tpc = pc->next;\r\n\t\t\tpa = pa->next;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tpc->next = new Node(pb->data.xishu, pb->data.mi);\r\n\t\t\t++sum.num;\r\n\t\t\tif(sum.highestdigitdata.mi) sum.highestdigit = pb->data.mi;\r\n\t\t\tpc = pc->next;\r\n\t\t\tpb = pb->next;\r\n\t\t}\r\n\t}\r\n\twhile (pa){\r\n\t\tpc->next = new Node(pa->data.xishu, pa->data.mi);\r\n\t\t++sum.num;\r\n\t\tif(sum.highestdigitdata.mi) sum.highestdigit = pa->data.mi;\r\n\t\tpc = pc->next;\r\n\t\tpa = pa->next;\r\n\t}\r\n\twhile (pb){\r\n\t\tpc->next = new Node(pb->data.xishu, pb->data.mi);\r\n\t\t++sum.num;\r\n\t\tif(sum.highestdigitdata.mi) sum.highestdigit = pb->data.mi;\r\n\t\tpc = pc->next;\r\n\t\tpb = pb->next;\r\n\t}\r\n\treturn sum;\r\n}\r\ntemplate\r\nPolynomial Polynomial::operator*(const Polynomial& second){\r\n\tPolynomial multi, temp;\r\n\tNode* pa = first->next, *pb = second.first->next, * pt;\r\n\r\n\tif (num >= second.num){ //拿项数多的那个链表乘以项数少的那个\r\n\t\twhile(pb){          //pb是项数少的那个，\r\n\t\t\tpt = temp.first;\r\n\t\t\twhile (pa){     //项数多的开始遍历  \r\n\t\t\t\tpt->next = new Node(pa->data.xishu*pb->data.xishu, pa->data.mi+pb->data.mi);//修改\r\n\t\t\t\ttemp.num++;//修改\r\n\t\t\t\tif( temp.highestdigitnext->data.mi ) temp.highestdigit=pt->next->data.mi;//修改\r\n\t\t\t\tpt = pt->next;\r\n\t\t\t\tpa = pa->next;\r\n\t\t\t}\r\n\t\t\tmulti= temp+multi;\r\n\t\t\ttemp.myfree();\r\n\t\t\ttemp.first = new Node();\r\n\t\t\tpa = first->next;\r\n\t\t\tpb = pb->next;\r\n\t\t}\r\n\t}\r\n\telse{\r\n\t\twhile(pa){\r\n\t\t\tpt = temp.first;\r\n\t\t\twhile (pb){\r\n\t\t\t\tpt->next = new Node(pa->data.xishu*pb->data.xishu, pa->data.mi+pb->data.mi);//修改\r\n\t\t\t\ttemp.num++;//修改\r\n\t\t\t\tif( temp.highestdigitnext->data.mi ) temp.highestdigit=pt->next->data.mi;//修改\r\n\t\t\t\tpt = pt->next;\r\n\t\t\t\tpb = pb->next;\r\n\t\t\t}\r\n\t\t\tmulti = temp+multi;\r\n\t\t\ttemp.myfree();\r\n\t\t\ttemp.first = new Node();\r\n\t\t\tpb = second.first->next;//修改\r\n\t\t\tpa = pa->next;\r\n\t\t}\r\n\t}\r\n\treturn multi;\r\n}\r\ntemplate\r\nvoid Polynomial::initial()\r\n{\r\n\t//释放链表，保留头节点\r\n\tNode* p = first->next, *q;\r\n\twhile (p)\r\n\t{\r\n\t\tq = p->next;\r\n\t\tdelete p;\r\n\t\tp = q;\r\n\t}\r\n\tfirst->next=NULL;//修改\r\n\tp = first;\r\n\r\n\tT a;\r\n\tint b;\r\n\tnum = 0; highestdigit = 0;//修改\r\n\twhile (cin >> a&&a != 0 && cin >> b){   //输入a=0时结束输入\r\n\t\tif (b >= highestdigit) highestdigit = b;\r\n\t\t++num;\r\n\t\tp->next = new Node(a, b);\r\n\t\tp = p->next;\r\n\t}\r\n\tfflush(stdin);//修改\r\n}\r\n\r\ntemplate\r\nostream& operator<<(ostream& out, Polynomial& a)\r\n{\r\n\tPolynomial::Node *p = a.first->next;\r\n\r\n\tif (p == NULL) return out;//修改\r\n\r\n\tif (p->data.xishu == 0)cout << endl;//修改\r\n\telse{\r\n\t\tif (p->data.xishu != 1)\r\n\t\t\tout << p->data.xishu << \"x^\" << p->data.mi;\r\n\t\telse    out << \"x^\" << p->data.mi;\r\n\t}\r\n\tp = p->next;\r\n\twhile (p)\r\n\t{\r\n\t\tout << '+';\r\n\t\tif (p->data.xishu != 1)\r\n\t\t\tout << p->data.xishu << \"x^\" << p->data.mi;\r\n\t\telse    out << \"x^\" << p->data.mi;\r\n\t\tp = p->next;\r\n\t}\r\n\treturn out;\r\n}\r\n\r\nint main(){\r\n\tPolynomial a, b, c,d;\r\n\ta.initial();\r\n\tcout << \"a= \" << a << endl;\r\n\tb.initial();\r\n\tcout << \"b=\" << b << endl;\r\n\tc = a + b;\r\n\tcout << \"c=\" << c << endl;\r\n\td=a*b;\r\n\tcout<<\"d=\"<<d<<endl;\r\n\ta.myfree();\r\n\tb.myfree();\r\n\tc.myfree();\r\n\td.myfree();\r\n\treturn 0;\r\n} \r\n```\r\n运行结果：\r\n![图片说明](https://img-ask.csdn.net/upload/201512/05/1449253669_208689.jpg)", "Konwledge_Point": "模运算", "Question": "稀疏多项式C++链表的问题\n #include\nusing namespace std;\n\n//约定稀疏多项式输入升幂排列\ntemplateclass Polynomial;\ntemplateostream& operator<<(ostream& out, Polynomial&a);\n\ntemplate\nclass Polynomial\n{\nprivate:\n    class Term\n    {\n    public:\n        T xishu;\n        unsigned mi;\n    };\n    class Node\n    {\n    public:\n        Term data;\n        Node* next;\n        Node(T x = 0, unsigned y = 0, Node* p = 0)\n        {\n            data.xishu = x;\n            data.mi = y;\n            next = p;//修改\n        }\n    };\npublic:\n    Polynomial();\n    void myfree();//释放链表各节点,由于要重载+，所以设置这个函数\n    Polynomial& operator=(const Polynomial&);\n    Polynomial operator+(const Polynomial&);\n    Polynomial operator*(const Polynomial&);\n    void initial();\n    friend ostream& operator<<  (ostream& out, Polynomial& a);\n\nprivate:\n    int highestdigit;\n    Node* first;\n    int num;//用来判断多项式有几项,即链表节点数,在乘法运算里也要用到\n};\ntemplate\nPolynomial::Polynomial()\n{\n    first = new Node;\n    num = 0;\n    highestdigit = 0;\n}\n\ntemplate\nvoid Polynomial::myfree()    //释放链表各节点\n{\n    Node* p = first, *q;\n    while (p)\n    {\n        q = p->next;\n        delete p;\n        p = q;\n    }\n}\n\ntemplate\nPolynomial& Polynomial::operator=(const Polynomial& second)\n{\n    highestdigit = second.highestdigit;\n    num = second.num;\n    Node* p1 = first, *p2 = second.first;\n\n    while (p2->next)\n    {\n        p1->next = new Node();\n        p1 = p1->next;\n        p2 = p2->next;\n        *p1 = *p2;\n    }\n    return *this;\n}\n\ntemplate\nPolynomial Polynomial::operator+(const Polynomial& second)\n{\n    Polynomial sum;\n    Node* pa = first->next, *pb = second.first->next, *pc = sum.first;\n    while (pa&&pb)\n    {\n        if (pa->data.mi == pb->data.mi)  // 指数相等时  \n        {\n            T x = pa->data.xishu + pb->data.xishu;\n            if (x)     // 相加完的系数不为0时  \n            {\n                pc->next = new Node(x, pa->data.mi);\n                pc = pc->next;\n                ++sum.num;\n                sum.highestdigit = pa->data.mi;\n            }\n            pa = pa->next;\n            pb = pb->next;\n        }\n        else if (pa->data.mi > pb->data.mi){\n            pc->next = new Node(pa->data.xishu, pa->data.mi);\n            pc = pc->next;\n            pa = pa->next;\n            ++sum.num;\n            sum.highestdigit = pa->data.mi;\n        }\n        else{\n            pc->next = new Node(pb->data.xishu, pb->data.mi);\n            pc = pc->next;\n            pb = pb->next;\n            ++sum.num;\n            sum.highestdigit = pb->data.mi;\n        }\n    }\n    while (pa){\n        pc->next = new Node(pa->data.xishu, pa->data.mi);\n        pc = pc->next;\n        pa = pa->next;\n        ++sum.num;\n        sum.highestdigit = pa->data.mi;\n    }\n    while (pb){\n        pc->next = new Node(pb->data.xishu, pb->data.mi);\n        pc = pc->next;\n        pb = pb->next;\n        ++sum.num;\n        sum.highestdigit = pb->data.mi;\n    }\n    return sum;\n}\ntemplate\nPolynomial Polynomial::operator*(const Polynomial& second){\n    Polynomial multi;\n    Node* pa = first->next, *pb = second.first->next;\n    if (num >= second.num){ //拿项数多的那个链表乘以项数少的那个\n        Polynomial temp; \n        Node* pt;\n        while(pb){          //pb是项数少的那个，\n        pt = temp.first;\n            while (pa){     //项数多的开始遍历  \n                pt->next = new Node(pa->data.xishu*pb->data.xishu, pa->data.mi*pb->data.mi);\n                pt = pt->next;\n                pa = pa->next;\n            }\n            multi= temp+multi;\n            temp.myfree();\n            temp.first = new Node();\n            pb = pb->next;\n        }\n        return multi;\n    }\n    else{\n        Polynomial temp;\n        Node* pt;\n        while(pa){\n            pt = temp.first;\n            while (pb){\n                pt->next = new Node(pa->data.xishu*pb->data.xishu, pa->data.mi*pb->data.mi);\n                pt = pt->next;\n                pb = pb->next;\n            }\n            multi = temp+multi;\n            temp.myfree();\n            temp.first = new Node();\n            pa = pa->next;\n        }\n        return multi;\n    }\n}\ntemplate\nvoid Polynomial::initial()\n{\n    //释放链表，保留头节点\n    Node* p = first->next, *q;\n    while (p)\n    {\n        q = p->next;\n        delete p;\n        p = q;\n    }\n    p = first;\n\n    T a;\n    int b;\n    num = 0; highestdigit = 0;//修改\n    while (cin >> a&&a != 0 && cin >> b){   //输入a=0时结束输入\n        if (b >= highestdigit) highestdigit = b;\n        ++num;\n        p->next = new Node(a, b);\n        p = p->next;\n    }\n    fflush(stdin);//修改\n}\n\ntemplate\nostream& operator<<(ostream& out, Polynomial& a)\n{\n    Polynomial::Node *p = a.first->next;\n\n    if (p == NULL) return out;//修改\n\n    if (p->data.xishu == 0)cout << endl;//修改\n    else{\n        if (p->data.xishu != 1)\n            out << p->data.xishu << \"x^\" << p->data.mi;\n        else    out << \"x^\" << p->data.mi;\n    }\n    p = p->next;\n    while (p)\n    {\n        out << '+';\n        if (p->data.xishu != 1)\n            out << p->data.xishu << \"x^\" << p->data.mi;\n        else    out << \"x^\" << p->data.mi;\n        p = p->next;\n    }\n    return out;\n}\n\n\n\n\n\n\n\n测试代码：\n\n\n\n#include \"Polynomial.h\"\n\n#include\n\nusing namespace std;\n\nint main(){\n\n    Polynomial a, b, c,d;\n\n    a.initial();\n\n    cout << \"a= \" << a << endl;\n\n    b.initial();\n\n    cout << \"b=\" << b << endl;\n\n    c = a + b;\n\n    cout << \"c=\" << c << endl;\n\n    d=a*b;\n\n    cout<<\"d=\"<<d<<end;\n\n    a.myfree();\n\n    b.myfree();\n\n    c.myfree();\n\n    d.myfree();\n\n    return 0;\n\n}", "Tag": "算法分析"}
{"Answer": "给你一个以前写好的，仅供参考\r\nimport java.awt.BorderLayout;\r\nimport java.awt.GridLayout;\r\nimport java.awt.event.MouseEvent;\r\nimport java.awt.event.MouseListener;\r\nimport java.text.DecimalFormat;\r\n\r\nimport javax.swing.JButton;\r\nimport javax.swing.JFrame;\r\nimport javax.swing.JPanel;\r\nimport javax.swing.JTextField;\r\n\r\npublic class Calculator {\r\n    //计算器面板\r\n\tprivate JFrame f = new JFrame(\"Calculator\");\r\n\t//输入面扳\r\n\tprivate JPanel inputPanel = new JPanel();\r\n\t//加减乘除面板\r\n\tprivate JPanel operationPanel = new JPanel();\r\n\t//数字面板\r\n\tprivate JPanel buttonsPanel = new JPanel();\r\n\t\r\n\t//输入数据文本框\r\n\tprivate JTextField input = new JTextField(20);\r\n\t\r\n\t//退格键\r\n\tprivate JButton backspace = new JButton(\"BackSpace\");\r\n\t//清空\r\n\tprivate JButton CE = new JButton(\"CE  \");\r\n\t//删除\r\n\tprivate JButton C = new JButton(\"C  \");\r\n\t\r\n\t//四则运算符号键\r\n\tprivate JButton add = new JButton(\"+\");\r\n\tprivate JButton sub = new JButton(\"-\");\r\n\tprivate JButton mul = new JButton(\"*\");\r\n\tprivate JButton div = new JButton(\"/\");\r\n\t\r\n\t//小数点\r\n\tprivate JButton decimal = new JButton(\".\");\r\n\t//等号\r\n\tprivate JButton equal = new JButton(\"=\");\r\n\t\r\n\t//数字键\r\n\tprivate JButton zero = new JButton(\"0\");\r\n\tprivate JButton one = new JButton(\"1\");\r\n\tprivate JButton two = new JButton(\"2\");\r\n\tprivate JButton three = new JButton(\"3\");\r\n\tprivate JButton four = new JButton(\"4\");\r\n\tprivate JButton five = new JButton(\"5\");\r\n\tprivate JButton six = new JButton(\"6\");\r\n\tprivate JButton seven = new JButton(\"7\");\r\n\tprivate JButton eight = new JButton(\"8\");\r\n\tprivate JButton nine = new JButton(\"9\");\r\n\t\r\n\tprivate String num1 = \"\";//保存第一个运算数字\r\n\tprivate String operator = \"\";//保存运算符号\r\n\t\r\n\tpublic static void main(String[] args) {\r\n\t\tnew Calculator();//new计算器实例\r\n\t}\r\n\t\r\n\tpublic Calculator(){\r\n\t     //添加组件，布局\r\n\t\tinputPanel.add(input);\r\n\t\tf.add(inputPanel, BorderLayout.NORTH);\r\n\t\t\r\n\t\toperationPanel.add(backspace);\r\n\t\toperationPanel.add(CE);\r\n\t\toperationPanel.add(C);\r\n\t\tf.add(operationPanel, BorderLayout.CENTER);\r\n\t\t\r\n\t\tbuttonsPanel.add(add);\r\n\t\tbuttonsPanel.add(sub);\r\n\t\tbuttonsPanel.add(mul);\r\n\t\tbuttonsPanel.add(div);\r\n\t\tbuttonsPanel.add(one);\r\n\t\tbuttonsPanel.add(two);\r\n\t\tbuttonsPanel.add(three);\r\n\t\tbuttonsPanel.add(zero);\r\n\t\tbuttonsPanel.add(four);\r\n\t\tbuttonsPanel.add(five);\r\n\t\tbuttonsPanel.add(six);\r\n\t\tbuttonsPanel.add(decimal);\r\n\t\tbuttonsPanel.add(seven);\r\n\t\tbuttonsPanel.add(eight);\r\n\t\tbuttonsPanel.add(nine);\r\n\t\tbuttonsPanel.add(equal);\r\n\t\tbuttonsPanel.setLayout(new GridLayout(4, 4));\r\n\t\tf.add(buttonsPanel, BorderLayout.SOUTH);\r\n\t\t\r\n\t\t//注册各个组件监听事件\r\n\t\tbackspace.addMouseListener(new OperationMouseListener());\r\n\t\tCE.addMouseListener(new OperationMouseListener());\r\n\t\tC.addMouseListener(new OperationMouseListener());\r\n\t\tdecimal.addMouseListener(new OperationMouseListener());\r\n\t\tequal.addMouseListener(new OperationMouseListener());\r\n\t\t\r\n\t\t//注册四则运算监听\r\n\t\tadd.addMouseListener(new CalcMouseListener());\r\n\t\tsub.addMouseListener(new CalcMouseListener());\r\n\t\tmul.addMouseListener(new CalcMouseListener());\r\n\t\tdiv.addMouseListener(new CalcMouseListener());\r\n\t\t\r\n\t\t//注册数字监听事件\r\n\t\tzero.addMouseListener(new NumberMouseListener());\r\n\t\tone.addMouseListener(new NumberMouseListener());\r\n\t\ttwo.addMouseListener(new NumberMouseListener());\r\n\t\tthree.addMouseListener(new NumberMouseListener());\r\n\t\tfour.addMouseListener(new NumberMouseListener());\r\n\t\tfive.addMouseListener(new NumberMouseListener());\r\n\t\tsix.addMouseListener(new NumberMouseListener());\r\n\t\tseven.addMouseListener(new NumberMouseListener());\r\n\t\teight.addMouseListener(new NumberMouseListener());\r\n\t\tnine.addMouseListener(new NumberMouseListener());\r\n\t\t\r\n\t\tf.setVisible(true);\r\n\t\tf.pack();\r\n\t\tf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\r\n\t}\r\n\t\r\n\tprivate class NumberMouseListener implements MouseListener{\r\n\r\n\t\tpublic void mouseClicked(MouseEvent e) {\r\n\t\t\tif(input.getText().trim().equals(\"0\")){//如果文本框已经是0，结果还是0\r\n\t\t\t\tinput.setText(((JButton)e.getSource()).getText().trim());\r\n\t\t\t}else{//否则的话，把0添加到后面，譬如文本框是1，结果就为10\r\n\t\t\t\tinput.setText(input.getText().concat(((JButton)e.getSource()).getText().trim()));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpublic void mouseEntered(MouseEvent e) {}\r\n\t\tpublic void mouseExited(MouseEvent e) {}\r\n\t\tpublic void mousePressed(MouseEvent e) {}\r\n\t\tpublic void mouseReleased(MouseEvent e) {}\t\r\n\t}\r\n\t\r\n\tprivate class CalcMouseListener implements MouseListener{\r\n\t\t//如果输入的是运算符号，保存第一个结果和运算符号\r\n\t\tpublic void mouseClicked(MouseEvent e) {\r\n\t\t\tnum1 = input.getText().trim();input.setText(\"\");\r\n\t\t\toperator = ((JButton)e.getSource()).getText().trim();\r\n\t\t}\r\n\r\n\t\tpublic void mouseEntered(MouseEvent e) {}\r\n\t\tpublic void mouseExited(MouseEvent e) {}\r\n\t\tpublic void mousePressed(MouseEvent e) {}\r\n\t\tpublic void mouseReleased(MouseEvent e) {}\t\r\n\t}\r\n\t\r\n\tprivate class OperationMouseListener implements MouseListener{\r\n\r\n\t\tpublic void mouseClicked(MouseEvent e) {\r\n\t\t\tif(e.getSource() == backspace){//退格键，删除一个直到没有字符删除\r\n\t\t\t\tString inputText = input.getText();\r\n\t\t\t\tif(inputText.length() > 0){\r\n\t\t\t\t\tinput.setText(inputText.substring(0, inputText.length() - 1));\r\n\t\t\t\t}\r\n\t\t\t}else if(e.getSource() == C){\r\n\t\t\t\tinput.setText(\"0\");//C，清空所有运算数字和符号\r\n\t\t\t\tnum1 = \"\";\r\n\t\t\t}else if(e.getSource() == CE){\r\n\t\t\t\tinput.setText(\"0\");//CE-->将文本框置为0\r\n\t\t\t}else if(e.getSource() == decimal){\r\n\t\t\t\tString text = input.getText().trim();\r\n\t\t\t\t//如果按了小数点，如果文本框已经有小数点，不做任何操作，否则在结果后面加上小数点\r\n\t\t\t\tif(text.indexOf(\".\") == -1){\r\n\t\t\t\t\tinput.setText(text.concat(\".\"));\r\n\t\t\t\t}\r\n\t\t\t}else if(e.getSource() == equal){\r\n\t\t\t\t//如果是等号\r\n\t\t\t\tif(!operator.trim().equals(\"\")){\r\n\t\t\t\t\tif(!input.getText().trim().equals(\"\")){\r\n\t\t\t\t\t\tdouble result = 0D;\r\n\t\t\t\t\t\tif(operator.equals(\"+\")){//执行加法运算\r\n\t\t\t\t\t\t\tresult = Double.parseDouble(num1) + Double.parseDouble(input.getText().trim());\r\n\t\t\t\t\t\t}else if(operator.equals(\"-\")){//减法运算\r\n\t\t\t\t\t\t\tresult = Double.parseDouble(num1) - Double.parseDouble(input.getText().trim());\r\n\t\t\t\t\t\t}else if(operator.equals(\"*\")){//乘法运算\r\n\t\t\t\t\t\t\tresult = Double.parseDouble(num1) * Double.parseDouble(input.getText().trim());\r\n\t\t\t\t\t\t}else if(operator.equals(\"/\")){//除法运算\r\n\t\t\t\t\t\t\tresult = Double.parseDouble(num1) / Double.parseDouble(input.getText().trim());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t \r\n\t\t\t\t\t\t //格式化最终结果，保留两位小数点\r\n\t\t\t\t\t\tinput.setText(new DecimalFormat(\"0.00\").format(result));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\r\n\t\tpublic void mouseEntered(MouseEvent e) {}\r\n\t\tpublic void mouseExited(MouseEvent e) {}\r\n\t\tpublic void mousePressed(MouseEvent e) {}\r\n\t\tpublic void mouseReleased(MouseEvent e) {}\t\r\n\t}\r\n\t\r\n}", "Konwledge_Point": "模运算", "Question": "安卓开发 eclipse 计算器模型\n怎么做在eclipse安卓 里制作一个计算器APP，在虚拟机里出现能实现加减乘除等简单的运算", "Tag": "算法分析"}
{"Answer": "这个不需要讨论了，机器语言是图灵完备的，因此任何图灵完备的计算方法，比如说通用高级编程语言，它们和机器语言都是等价的。\r\n你说的“函数”不知道是什么意思，如果可以用计算机语言的程序表达的，具有确定的输入输出的，可以停机的，那么就是可以用编程语言解决的。\r\n\r\n存在死循环或者无限递归的“函数”，无法计算。\r\n比如说定义这么一个函数：\r\nbool Runforever(string code)\r\n{\r\n这个函数的作用是，判断作为参数的任意code（假设是C语言写的程序构成的字符串），是否是一个死循环，如果是返回true，否则返回false\r\n}\r\n这个函数就是不可计算的。\r\n\r\n扩展了解：\r\nhttps://www.bilibili.com/video/av9684428/\r\nhttps://www.cnblogs.com/lexus/archive/2012/08/21/2648810.html\r\nhttps://blog.csdn.net/u014073556/article/details/86382019\r\nhttps://www.cnblogs.com/zhangzefei/p/9743546.html", "Konwledge_Point": "模运算", "Question": "算法，当解决各种模型以后的感触\n能用函数解决的一定能用机器语言解决（机器运算能力无限）\n\n能用机器语言解决的一定能用函数解决（机器运算能力无限）\n\n两句话有没有道理，给出你的意见。\n\n能举出反例的给分。", "Tag": "算法分析"}
{"Answer": "没听说过，但是c#可以引用c++写的dll，如果你实在想用，自己封装一下", "Konwledge_Point": "模运算", "Question": "请问C#有无C++__builtin_系列的高效位运算函数?\nC++__builtin_系列函数\n•int __builtin_ffs (unsigned int x)\n返回x的最后一位1的是从后向前第几位，比如7368（1110011001000）返回4。\n•int __builtin_clz (unsigned int x)\n返回前导的0的个数。\n•int __builtin_ctz (unsigned int x)\n返回后面的0个个数，和__builtin_clz相对。\n•int __builtin_popcount (unsigned int x)\n返回二进制表示中1的个数。\n•int __builtin_parity (unsigned int x)\n返回x的奇偶校验位，也就是x的1的个数模2的结果\n\n\nC#中,如果需要计算二进制数的前导0,最高效的做法是什么?", "Tag": "算法分析"}
{"Answer": "内侧循环开始的地方加上 $dd = 0\r\n你调试下  $dd +=$c", "Konwledge_Point": "模运算", "Question": "请问：php运算时为什么只算两条数据相加呢？如何才能算出所有数的和？\n这是finecms 的模板，有这样的一个循环，展示的是会员发内布的交易信息，每个信息里面又有其他会员的回复，这个回复里有金额，用PHP写了个运算（只是显示，没写入数据库），可是它只算两条以内的和，如何能让每个信息里的所有回执金额相加成总数呢？\n\n\n\n{list modelid=27 order=updatetime num=10 more=1}\n{php $id = $t['id'];}\n\n\n{strcut(strip_tags($t['shangjia']),12,\"\")}{strcut(strip_tags($t['title']),12,\"\")}{strcut(strip_tags($t['jiaoyixiangmu']),12,\"\")}￥{$t['jiaoyijine']}元\n{list form=jiaoyi cid=$id order=id return=d}\n\n最近领取：{date(\"Y年m月d日\",$d['updatetime'])}来{$d['huizhishangjia']}领取{$d['huizhijine']} 元 {$d['huizhichanpin']}--计{$c}\n{/list}\n总{$dd}\n\n\n{/list}\n\n\n\n", "Tag": "算法分析"}
{"Answer": "文章：深度学习中，embedding如何理解？ 中也许有你想要的答案，请看下吧", "Konwledge_Point": "模运算", "Question": "文本数据为阿拉伯数字和运算符号怎么做embedding呢\n如果对一系列数学运算进行学习的话，怎么对数据进行处理呀？了解的朋友们可以解答一下吗，谢谢大家了🙏", "Tag": "算法分析"}
{"Answer": "问题已解决\n如果保存的模型是多GPU训练的，则load_state_dict()之前必须使用torch.nn.DataParallel()来源https://www.cnblogs.com/tofengz/p/13546902.html#_label5“踩坑记”", "Konwledge_Point": "模运算", "Question": "SINet语义分割，所有像素预测结果是同一个值\n问题遇到的现象和发生背景\n\n\n使用SINet进行二分类语义分割训练(\nhttps://openaccess.thecvf.com/content_CVPR_2020/papers/Fan_Camouflaged_Object_Detection_CVPR_2020_paper.pdf\n),\n\n\n训练时：输入图片RGB，输入target像素值只有0和255的单通道黑白图，loss为nn.BCEWithLogitsLoss()，训练时loss有在下降，打印求loss之前的网络输出结果看到，每个像素预测结果-5到5之间。这样的话sigmoid之后的值在0-1之间，target像素值只有0和1，所有训练时没有问题。\n\n\n但测试时：网络的预测值全都接近0，都为10的-1，-2次方，导致sigmoid之后的值全在0.5左右，transforms.ToPILImage()之后像素值全为213左右。不明白为什么。对训练集进行测试也是这种情况。\n\n\n问题相关代码，请勿粘贴截图\n\n\nhttps://github.com/DengPingFan/SINet\n\n\n运行结果及报错内容\n\n\n这是测试时打印的结果，cam1是网络预测的结果，cam2时sigmoid之后的结果，cam3是通过transforms.ToPILImage()将像素值调至0-255之后的结果\n\n\n我的解答思路和尝试过的方法\n\n\n怀疑是测试时对图片的预处理方式导致的，因此将测试时预处理方式调到和训练时相同，image=Image.open().convert('RGB')读取后，image = image.resize((512, 512), Image.BILINEAR),然后 transforms.ToTensor(), transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])])，都没有任何问题。\n怀疑训练时多GPU并行运算导致？（瞎猜）但尝试单GPU后结果仍然不佳。\n如果是图片前景面积过小导致类别不平衡，但训练时预测值也没问题。并且就算不平衡也不至于预测结果sigmoid之前全是0吧\n\n\n我想要达到的结果\n\n\n希望得到解答，找出可能错误的地方，不胜感谢", "Tag": "算法分析"}
{"Answer": "按照要求写模板函数就可以了啊，有什么困难参考：\n#include <iostream>\nusing namespace std;\ntemplate<typename T>\nT sum(T* array,int size=0)\n{\n    T sums = 0;\n    for(int i=0;i<size;i++)\n        sums += array[i];\n    return sums;\n}\nint main()\n{\n    int a[5] = {1,2,3,4,5};\n    double b[5] = {9.1,8.34,4.13,-3.913,0.923};\n\n    int s1 = sum(a,5);\n    double s2 = sum(b,5);\n    cout<<\"整型数组和:\"<<s1<<endl;\n    cout<<\"浮点型数组和:\"<<s2<<endl;\n    return 0;\n}\n\n", "Konwledge_Point": "模运算", "Question": "#C++模板和异常处理代码问题\n根据提示代码设计一个函数模板，能求一维数组中的所有元素的和，并写出调用此函数模板的完整程序，使得函数调用时，可以处理int、double类型的数组。\n运行结果如下：（运算结果因输入值差异，不是唯一）\n\n\n提示代码：\n\n\nT sum(T* \narray\n,\nint\n size=\n0\n)\n......\n\nint\n  array1[]=\n{......}\n;\ndouble array2[]=\n{......}\n;\n\n\n", "Tag": "算法分析"}
{"Answer": "建议断点调试，看有没有执行", "Konwledge_Point": "模运算", "Question": "MFC编程遇到问题求助大神\n求助各路大神。。\n\n   我在VC 6.0上编写MFC程序，我在一个dlg对话框里面加两个按钮控件，设置点击它们会弹出不同的模态对话框(用的dlg.DoModal())。新的对话框有自己的编辑框和按钮，我在编辑框输入数据后点击按钮后会在结果编辑框中输出数据，但是我发现一个问题。\n\n   我这里想要做的是，点击两个按钮分别弹出一个模逆运算和模幂运算的对话框，我先写模逆的，编译运行，点击按钮，弹出对话框，在编辑框输入数据(运算数和模数)，点击按钮，输出数据，结果没问题。接着我写模幂的，但是发现死活就不行了，也不报错，编译能运行，点击按钮，弹出模幂对话框，不管输入什么数据，输出始终都是0，我直接把用于输出结果的那个编辑框嗦绑定的变量人为赋值为一个非0的数，它输出居然还是0。开始我以为是第二个对话框编写函数的时候出了问题，但是又始终检查不出来就全部重新做，这次然后先写模幂的，发现模幂的可以运行了，然后写模逆，但是这次模逆的却出现刚才那个问题了，始终输出为0，感觉它就好像根本没有调用我给按钮写的响应函数一样。\n\n   小弟实在很困惑，MFC学得比较肤浅，实在不知道怎么回事了，求助各路大神。", "Tag": "算法分析"}
{"Answer": "1、0000 0001 + 1111 1111  最后一位1+1=0，这还要向前进1位呢，所以前7位也都是0了。  1111 1111 + 1000 0001 类似的道理", "Konwledge_Point": "模运算", "Question": "请教专业人士补码和原码的二进制算法！\n学习基础过程中遇到很多问题理不清！请教各位专业人士，下面是我在各网站上截图下来，看不太明白运算结果（运算规则）的图片（用红色方框标示出来了！），请问为什么2个8位数二进制补码相加不是遵循模二加法（即：0+0=0,1+0=1，0+1=1,1+1=0）呢！\n\n\n下图是：2个补码相加我看不明白的运算结果和规则！\n\n\n\n\n下图是：我看不明白的计算机将2原码相加的运算结果和规则！\n\n\n\n\n下图是：我不太确定将负数原码取反码再加1得到其补码的正确性！\n\n\n\n\n下图是：依然是看不明白2个补码相加得到的结果！\n\n", "Tag": "算法分析"}
{"Answer": "代码如下\nimport java.util.Scanner;\n\npublic class Demo {\n    public static void main(String[] args) {\n        System.out.println(\"请输入第一个值：\");\n        Scanner sc=new Scanner(System.in);\n        int a=sc.nextInt();\n        System.out.println(\"请输入第二个值：\");\n        Scanner sc1=new Scanner(System.in);\n        int b=sc.nextInt();\n\n//        请进行选项\n        System.out.println(\"1:加 2:减 3:乘 4:除 5:模\");\n        Scanner s=new Scanner(System.in);\n        int c=sc.nextInt();\n        do{\n            switch (c){\n                case 1:\n                    System.out.println(a+\"+\"+b+\"=\"+(a+b));break;\n                case 2:\n                    System.out.println(a+\"-\"+b+\"=\"+(a-b));break;\n                case 3:\n                    System.out.println(a+\"*\"+b+\"=\"+(a*b));break;\n                case 4:\n                    System.out.println(a+\"/\"+b+\"=\"+(a/b));break;\n                case 5:\n                    System.out.println(a+\"%\"+b+\"=\"+(a%b));break;\n                default:\n                    c=0;\n                    System.out.println(\"输入的不对，从请新输入\");\n                    c=sc.nextInt();\n            }\n        }while(c<1 || c>5);\n\n    }\n}\n\n测试如下\n\n如有帮助，请采纳一下，谢谢", "Konwledge_Point": "模运算", "Question": "运用JAVAV语言写程序\n运用JVAV语言 ：do while switch\n输入两个数 根据选项的不同 做不同运算\n1加 2减 3乘 4除 5模\n输出结果内容格式如下：\n3\n4\n3\n 3*4=12", "Tag": "算法分析"}
{"Answer": "楼下的素质真差 。。。没人回答，算了，关闭问题", "Konwledge_Point": "模运算", "Question": "-1对256求模的值是多少\nRT\n\n这个的结果是不是跟机器相关？\n\n或者根据不同的标准有不同的答案？\n\n新手问题，请知道的大神能不吝赐教，谢谢", "Tag": "算法分析"}
{"Answer": "该回答引用ChatGPT \n\n一、模2的剩余类环Z12中的乘法可逆元为：1、5、7、11。\n\n在模2的剩余类环Z12中，任意一个整数a如果和12互质，则a在Z12中存在乘法逆元，即存在b使得ab≡1(mod 12)。根据欧拉定理，当a和12互质时，有a^φ(12) ≡ 1(mod 12)，其中φ(12)=4是12的欧拉函数。\n因此，在Z12中，与1、5、7、11互质的整数都是乘法可逆元，它们分别是1、5、7、11。\n\n二、集合2Z关于加法运算构成的群不是循环群。\n\n循环群是指存在一个元素a，使得该群中的每个元素都可以表示为a的幂，即该群是由a生成的。对于2Z，它的元素形如2n，其中n∈Z。假设2Z是循环群，那么存在一个元素a，使得2n=a^n对于所有的n都成立。但是，我们可以发现，当n为奇数时，左边是偶数，右边是奇数，不相等，因此2Z不是循环群。\n\n三、集合｛(0 0) (0 a) | a∈R｝关于矩阵的加法和乘法不是整环。\n\n整环是指一个集合同时满足加法和乘法封闭性、结合律、交换律、分配律、存在加法和乘法单位元、存在乘法逆元（对于非零元素）。这里我们分别考虑集合｛(0 0) (0 a) | a∈R｝关于矩阵的加法和乘法是否满足这些性质。\n对于加法，任意两个矩阵的和仍然在集合中，满足封闭性。加法结合律、交换律、存在加法单位元都是成立的。但是，该集合中不存在加法逆元，因为对于任意一个矩阵(0 a)，不存在另一个矩阵(0 b)使得它们的和为(0 0)。因此，该集合关于矩阵的加法不是一个群，也就不满足整环的定义。\n对于乘法，该集合中的任意两个矩阵的乘积也仍然在集合中，满足封闭性。但是，乘法不满足结合律。例如，对于矩阵(0 a)，(0 b)，(0 c)，有(0 a)((0 b)(0 c))=(0 a)(0 0)=(0 0)，而((0 a)(0 b(0 c))=(0 0)(0 c)=(0 0)，它们的乘积不相等，因此乘法不满足结合律。因此，该集合关于矩阵的乘法也不是整环。", "Konwledge_Point": "模运算", "Question": "求解高等代数相关问题解答\n一，列出模2的剩余类环Z12的所有乘法可逆元\n二，记所有偶数构成的集合为2Z，2Z关于数的加法运算构成的群是不是循环群\n三，集合｛(0 0)\n                (0 a) Ia∈R｝关于矩阵的加法和乘法是不是整环\n四，", "Tag": "算法分析"}
{"Answer": "参考GPT和自己的思路：一、选择\n1  C.分配律2  C.43  A.无穷远点只有一个4  D.若是模的一个原根,则当时,也是模的一个原根。5  D.实数环二、填空\n1  φ(258)=962  {0,1,2,3,4,5,6,7,8,9,10}3  若p为素数，则ap-1≡1(mod p)4  椭圆曲线5  单位环三、判断\n1  错误。非零整数的因数包括1和本身，但不一定是自身的倍数。2  正确。根据同余关系的传递性可知：如果a≡b(mod m)且b≡c(mod m)，则a≡c(mod m)。\n因此，对于a≡b(mod m)，我们可以写成a-b=km，其中k是整数。\n将a和b分别表示为a1d和b1d，则有a1d-b1d=km，即(a1-b1)d=km。因此，a1≡b1(mod m)。\n因此，如果a≡b(mod m)，则a1≡b1(mod m)是正确的。3  错误。P(B)关于集合的并运算构成环，不满足交运算的封闭性。4  错误。非奇异的二次曲线被称为椭圆曲线，非奇异的三次曲线被称为椭圆曲线。四、解答\n首先求出7x和11y分别在模11下的逆元，由于7和11互质，所以7在模11下的逆元为8，11在模7下的逆元为6。则有：7x≡100(mod 11)x≡8×100(mod 11)x≡2(mod 11)\n11y≡100(mod 7)y≡6×100(mod 7)y≡4(mod 7)\n因此，7x+11y=100的所有整数解为{(2,4),(13,8),(24,12),...}。\n15x≡21(mod 9)可化为3x≡3(mod 9)，因为15和21都是3的倍数。根据同余式的性质，可知3和9互质，所以3在模9下有逆元3^-1=6，两边同时乘以6，得到：x≡6×3(mod 9)x≡18(mod 9)x≡0(mod 9)\n因此，15x≡21(mod 9)的解为x=9k，其中k为任意整数。\n如果对您有帮助，请给与采纳，谢谢", "Konwledge_Point": "模运算", "Question": "信息安全数学基础解答\n一、选择\n1.公式(AUB)∩C=(A∩C)U(B∩C),说明集合中的交运算对并运算满足（    ）。\nA.交换律          B.结合律         C.分配律         D.消去一次2.同余式6x≡48(mod 96)的解数是（    ）。\nA. 6              B. 3             C. 4             D. 8\n3.下列说法中错误的是（    ）。\nA.无穷远点只有一个\n B.经过同一个无穷远点的所有直线相互平行,经过不同无穷远点的两直线不平行\nC.一条直线的无穷远点有且只有一个\n D.平面上全体无穷远点构成一条无穷远直线\n4.以下说法中错误的一项是（    ）。\nA.并不是所有数都有原根。\nB.如果一个数有原根,原根也不一定是唯一的。\n C.若模的存在原根,则原根有个\nD.若是模的一个原根,则当时,也是模的一个原根。\n5.对于数集上的普通加法和普通乘法，以下说法错误的是（    ）。\nA.自然数环         B.整数环           C.有理数环             D.实数环\n二、填空\n1.计算φ(258)的值为             。\n2.写出模11的简化剩余系               。\n3.费马小定理：设为素数，则              。\n4.一般的，将的三次曲线称为                     。\n5.若环中乘法∙存在单位元，则称R是                      。\n三、判断\n1.任何非零整数是其自身的倍数,也是其自身的因数。（    ）\n2.若a≡b(mod m),a=a1d,b=b1d,则a1≡b1(mod m)。（    ）\n3.集合的幂集P(B)关于集合的交运算和并运算构成环。（    ）\n4.只有非奇异的三次曲线被称为椭圆曲线。（    ）\n5.域K任意点坐标(x,y)称为仿射坐标,引入一个新参量z∈Z,则三维坐标(X,Y,Z)=(xz,yz,z)。（）\n四、解答\n求7x+11y=100的一切整数解。\n\n\n求一次同余式15x≡21(mod 9)的解。\n\n", "Tag": "算法分析"}
{"Answer": "参考GPT和自己的思路：一、选择\n1  C.分配律2  C.43  A.无穷远点只有一个4  D.若是模的一个原根,则当时,也是模的一个原根。5  D.实数环二、填空\n1  φ(258)=962  {0,1,2,3,4,5,6,7,8,9,10}3  若p为素数，则ap-1≡1(mod p)4  椭圆曲线5  单位环三、判断\n1  错误。非零整数的因数包括1和本身，但不一定是自身的倍数。2  正确。根据同余关系的传递性可知：如果a≡b(mod m)且b≡c(mod m)，则a≡c(mod m)。\n因此，对于a≡b(mod m)，我们可以写成a-b=km，其中k是整数。\n将a和b分别表示为a1d和b1d，则有a1d-b1d=km，即(a1-b1)d=km。因此，a1≡b1(mod m)。\n因此，如果a≡b(mod m)，则a1≡b1(mod m)是正确的。3  错误。P(B)关于集合的并运算构成环，不满足交运算的封闭性。4  错误。非奇异的二次曲线被称为椭圆曲线，非奇异的三次曲线被称为椭圆曲线。四、解答第1题  首先我们需要找到一组特解，可以使用辗转相除法求解7x+11y=1的一组解，例如：11 = 1 * 7 + 47 = 1 * 4 + 34 = 1 * 3 + 11 = 4 - 1 * 3 = 4 - 1 * (7 - 1 * 4) = 2 * 4 - 1 * 7 = 2 * (11 - 1 * 7) - 1 * 7 = 2 * 11 - 3 * 7因此，一组特解为x=2，y=-3。然后，我们可以通过变换k=100/7，得到通解为x=2+11k，y=-3-7k。其中k为整数，将k分别取0,1,-1,2,-2,...即可得到所有整数解。\n第2题  对15x≡21(mod 9)两边同时除以最大公约数3，得到5x≡7(mod 9)。使用扩展欧几里得算法求解5x+9y=1的一组解，例如：9 = 1 * 5 + 45 = 1 * 4 + 11 = 5 - 1 * 4 = 5 - 1 * (9 - 1 * 5) = 2 * 5 - 1 * 9因此，一组特解为x=2，y=-1。然后，我们可以通过变换k=7/5，得到通解为x=2+9k，y=-1-5k。其中k为整数，将k分别取0,1,-1,2,-2,...即可得到所有同余式的解。\n第3题  由于x≡2(mod3)和x≡2(mod5)是两个线性同余方程，我们可以使用中国剩余定理求解。首先，我们可以使用扩展欧几里得算法求解3y+5z=1的一组解，例如：5 = 1 * 3 + 23 = 1 * 2 + 11 = 3 - 1 * 2 = 3 - 1 * (5 - 1 * 3) = 2 * 3 - 1 * 5因此，一组特解为y=2，z=-1。然后，我们可以通过变换k=2(mod3)和k=1(mod5)，得到通解为x=2+15k。其中k为整数，将k分别取0,1,-1,2,-2,...即可得到所有同余式组的解。第4题  根据 RSA 算法，加密公式为: C ≡ M^e (mod n)，其中 C 表示密文，M 表示明文，e 表示公钥，n 表示模数。解密公式为: M ≡ C^d (mod n)，其中 d 表示私钥。\n首先，计算 n = p * q = 11 * 17 = 187。根据欧拉函数，有 phi(n) = (p - 1) * (q - 1) = 160。找到一个与 phi(n) 互质的整数 e，且 e 满足 1 < e < phi(n)，选择 e = 3。求解得到私钥 d，满足 d ≡ e^-1 (mod phi(n))，即 d ≡ 107 (mod 160)。因此，公钥为 (e, n) = (3, 187)，私钥为 (d, n) = (107, 187)。\n加密字母 A，对应 ASCII 码为 65，将 65 作为明文 M 进行加密。计算 C ≡ M^e (mod n)，即 C ≡ 65^3 (mod 187)，得到 C = 147。\n解密密文 C，计算 M ≡ C^d (mod n)，即 M ≡ 147^107 (mod 187)。可以使用快速幂算法来计算 M，具体过程如下：\n将指数 d 转化为二进制数，例如：107 = 1101011。从右往左遍历二进制数，将计算过程依次平方并取模。初始时，取 base = C = 147，因为第一位是 1。遇到二进制数中的 1，即第 1、3、4、6 位，进行平方并取模。第 1 位：base = base^2 % n = 147^2 % 187 = 174。第 3 位：base = base^2 % n = 174^2 % 187 = 85。第 4 位：base = base^2 % n = 85^2 % 187 = 96。第 6 位：base = base^2 % n = 96^2 % 187 = 65。最终得到 M = 65，表示明文为字母 A。因此，加密后的密文为 147，解密后的明文为 65，表示字母 A。\n第5题  在<Z4,⊕>群中：\n3的逆元素是什么？首先计算3的所有幂次：3^0 = 13^1 = 33^2 = 13^3 = 3...\n我们可以发现，3的幂次交替为1和3，所以3没有逆元素。\n(-3+5)的逆元素是什么？(-3+5)可以化简为2。因此，我们需要找到2的逆元素，即满足2⊕a=0的a。由于在<Z4,⊕>群中只有4个元素，可以列出所有可能的组合：0⊕0=00⊕1=10⊕2=20⊕3=31⊕0=11⊕1=01⊕2=31⊕3=22⊕0=22⊕1=32⊕2=02⊕3=13⊕0=33⊕1=23⊕2=13⊕3=0\n可以看出，2没有逆元素。\n(-2)^3+(-2)^-4的值是多少？首先计算(-2)^3：(-2)^3 = (-2)⊕(-2)⊕(-2) = 0\n然后计算(-2)^-4。在<Z4,⊕>群中，每个元素的逆元素都是其本身，所以(-2)^-4就是(-2)^4=2：\n(-2)^-4 = (-2)^4 = 2\n因此，(-2)^3+(-2)^-4=0+2=2。\n对于Z5的剩余类环中的多项式：\nf(x) = 3x^5 -5x^3 +7x^2-13g(x) = 2x^2-5x-4\n计算f(x)+g(x)：\nf(x)+g(x) = (3x^5 -5x^3 +7x^2-13) + (2x^2-5x-4)= 3x^5 -5x^3 +9x^2 -5x -17\n计算f(x)*g(x)：\nf(x)*g(x) = (3x^5 -5x^3 +7x^2-13) * (2x^2-5x-4)= 6x^7 -15x^6 -4x^5 +10x^4 +23x^3 -31x^2 -1x +52\n注意，这里的乘法是在模5的意义下进行的，因此需要对系数进行取模运算。", "Konwledge_Point": "模运算", "Question": "信息安全数学基础解题，如果能用本子写下来最好了。\n一、选择\n1.公式(AUB)∩C=(A∩C)U(B∩C),说明集合中的交运算对并运算满足（    ）。\nA.交换律          B.结合律         C.分配律         D.消去一次2.同余式6x≡48(mod 96)的解数是（    ）。\nA. 6              B. 3             C. 4             D. 8\n3.下列说法中错误的是（    ）。\nA.无穷远点只有一个\n B.经过同一个无穷远点的所有直线相互平行,经过不同无穷远点的两直线不平行\nC.一条直线的无穷远点有且只有一个\n D.平面上全体无穷远点构成一条无穷远直线\n4.以下说法中错误的一项是（    ）。\nA.并不是所有数都有原根。\nB.如果一个数有原根,原根也不一定是唯一的。\n C.若模的存在原根,则原根有个\nD.若是模的一个原根,则当时,也是模的一个原根。\n5.对于数集上的普通加法和普通乘法，以下说法错误的是（    ）。\nA.自然数环         B.整数环           C.有理数环             D.实数环\n二、填空\n1.计算φ(258)的值为             。\n2.写出模11的简化剩余系               。\n3.费马小定理：设为素数，则              。\n4.一般的，将的三次曲线称为                     。\n5.若环中乘法∙存在单位元，则称R是                      。\n三、判断\n1.任何非零整数是其自身的倍数,也是其自身的因数。（    ）\n2.若a≡b(mod m),a=a1d,b=b1d,则a1≡b1(mod m)。（    ）\n3.集合的幂集P(B)关于集合的交运算和并运算构成环。（    ）\n4.只有非奇异的三次曲线被称为椭圆曲线。（    ）\n5.域K任意点坐标(x,y)称为仿射坐标,引入一个新参量z∈Z,则三维坐标(X,Y,Z)=(xz,yz,z)。（）\n四、解答\n求7x+11y=100的一切整数解。\n\n\n求一次同余式15x≡21(mod 9)的解。\n\n", "Tag": "算法分析"}
{"Answer": "思路是没问题，但是你没有初始化sum，结果就会错。\r\n简单地说就是 int sum=0;\r\n改一下就好", "Konwledge_Point": "模运算", "Question": "Digital Roots 题目大意将输入的正整数的各个数相加\n题目如下\n\nThe digital root of a positive integer is found by summing the digits of the integer. If the resulting value is a single digit then that digit is the digital root. If the resulting value contains two or more digits, those digits are summed and the process is repeated. This is continued as long as necessary to obtain a single digit. \n\nFor example, consider the positive integer 24. Adding the 2 and the 4 yields a value of 6. Since 6 is a single digit, 6 is the digital root of 24. Now consider the positive integer 39. Adding the 3 and the 9 yields 12. Since 12 is not a single digit, the process must be repeated. Adding the 1 and the 2 yeilds 3, a single digit and also the digital root of 39. \n\n\n\n输入 \n\n\n\nThe input file will contain a list of positive integers, one per line. The end of the input will be indicated by an integer value of zero. \n\n\n\n输出 \n\n\n\nFor each integer in the input, output its digital root on a separate line of the output. \n\n\n\n样例输入 \n\n\n\n24 \n\n39 \n\n0 \n\n\n\n样例输出 \n\n\n\n6 \n\n3 \n\n\n\n我的思路是 \n\n1.将sum各位数字加起来，赋值sum\n\n2.判断sum是否是个位数，如果不是，转1\n\n3是个位数，输出结果，运算结束\n\nsum%9的结果和整个数模9的结果相同，用来运算各个书之和。以下是我的代码。思路看起来没问题，但是运行结果和想象的不一样。\n\n\n\n #include \nint main()\n{\n    char ch;\n    while(1){  //计算各位数字的和\n    int sum;\n    while(scanf(\"%c\",&ch) && ch!='\\n'){\n        sum+=ch-'0';\n        }\n    if (sum==0) break;\n    //模9运算求根\n    if(sum%9==0) sum=9;\n    else sum=sum%9;\n    printf(\"%d\\n\",sum);\n    }\n    return 0;\n}\n\n", "Tag": "算法分析"}
{"Answer": "基础类型数据用偏特化Base版本\ntemplate<typename T, bool = std::is_class<T>::value>\nclass Base : public T {\n    T* t;\npublic:\n  using T::T;\n  Base() {}\n};\n\ntemplate<typename T>\nclass Base<T, false>{\n    T t;\npublic:\n  Base() {}\n};\n\nBase<int> b;\n", "Konwledge_Point": "模运算", "Question": "使用自定义的类型代替内置类型可行吗\n问题遇到的现象和发生背景\n\n\n最近想做一个类模板，希望兼容自己项目里的其他类和C++的内置类型。\n同时希望这个类型支持直接调用模板类的初始化。这个昨天发过问答，只有一位teacher给回答说用CRTP。但是没有用上，自己查别的资料发现只要写\nusing T::T;\n就可以了，所以问答就撤掉了，对那位回答的teacher说句不好意思。\n\n\ntemplate\n<\ntypename\n T>\n\nclass\n \nBase\n : \npublic\n T\n{\n\npublic\n:\n  \nusing\n T::T;\n  \nBase\n() {}\n  \n//一些功能...\n\n};\n\n\n\n现在又遇到了新的问题，上面的这个类型\nBase\n里面实际上没有申请储存空间，所有的数值都在继承到的模板类型\ntypename T\n里面。这样一来又出现了新的问题，就是没办法支持C++的内置类型了。\n\n\n我的解答思路和尝试过的方法\n\n\n我自己的思路是，对\nBase\n类的模板进行筛选，首先确定是否是C++内置类型，然后根据结果选择不同的模板来创建：\n\n\ntemplate\n <\ntypename\n T, \n        \ntypename\n = std::conditional<\nbool\n(is_class::result), T, CoverType> \n// is_class是网上抄的判断是否为类型的方法\n\n\nclass\n Base : T\n{\n  ...\n};\n\n\n//! CoverType定义\n\n\ntemplate\n <\ntypename\n T>\n\nclass\n \nCoverType\n\n{\n\nprivate\n:\n  T content;\n\npublic\n:\n  \n//! 模仿内置类型创建基础的运算规则\n\n};\n\n\n\n我想知道：\n\n\n因为使用CoverType代替了内置类型，使用这种方式会不会导致运行速度降低很多，或者有什么隐患", "Tag": "算法分析"}
{"Answer": "提个建议， 问题太多， 建议分开问。就第一个问题谈个人看法python 的知识网络（体系），有些广，常见的应用方向：数据分析、爬虫、自动化、桌面应用。不同方向，掌握东西不同， 比如说数据分析，那应该要了解数据结构、数据库、算法及初步的程序设计知识。而数据库又包含mysql，oracle ，hadoop 的知识， 数据分析常用的库 pandas , numpy , sklearn , matplotlib , pyecharts , seaborn解决问题过程中，如果你想对一个问题的细节进行深入了解的话。有可能要涉及到 计算机原理，计算数学，计算机网络原理， 数据库原理方面的知识。 \n说了这么多， 大概回答你所提问题的 1%。个人看法，供参考。", "Konwledge_Point": "模运算", "Question": "Python在学完基础知识之后，怎么能往APP和网页的平台开发、游戏开发方向走？另外还有其他问题~\n首问体验既然说要认真写那我就\n不客气啦\n。\npython！感觉很好用，但是我学完基础知识之后就像_没有肌肉的草履虫_一样，咋整？\n背python代码是可以背的，但是不乱背，怕背了不会用；有没有什么代码书推荐？可以买或者利用哪些书或课程来加上学习进程？（穷哦，前提）\n\n\n作为“\n拿来主义\n代表人物”，我（caiguai，的具体问题如下\n\n\n我不清楚python一整个知识网络，故问题如下：\n1.Python知识网络，有哪些大方面和大方面下方的哪些小方面\n2.简单易懂阐明知识网络下每一个专业名词的含义和用处，标注关键点\n3.最好有个实例来说明平台开发具体步骤和需要哪些知识\n4.Python游戏怎么搞，最高端的游戏长啥样？有没有模板或者说是一个常见的模型之类的（我背背）\n\n\n另外，\n夹带私货\n（顺带问问，恳请回答！）\n1.每天怎么安排学习代码\n2.我的世界mod的代码（java）想了解一下\n3.c语言是怎么通过二进制影响机器运作的，芯片的运算原理（就几个晶体管咋就能显示出我看到的那么多游戏，那么多强大的功能）。高低位电压？咋就能做到这么多运行和处理呢？电脑里边的各个硬件怎么个用处和它为何能够处理那个方面的东西（硬件和电的方面解释一下~）。\n4.编程的字母＋机器是如何能够做成机器人运作的，字母咋就影响它的行为了？", "Tag": "算法分析"}
{"Answer": "内侧循环开始的地方加上  $dd = 0", "Konwledge_Point": "模运算", "Question": "小白问个php累加问题？\n这是finecms的模板，按网上方法加了个php运算，是页面直接运算的，没写入数据库\n\n\n\n{list modelid=27 order=updatetime num=10 more=1 return=t}\n\n\n\n{$t['shangjia'])}{$t['title']}{st'jiaoyixiangmu']}￥{$t['jiaoyijine']}元\n\n{list form=jiaoyi cid=$id order=inputtime return=d}\n\n{$key_d+1} id:{$d['id']} {$d['huizhishangjia']}回{$a}--比{$g}%--算{$c}--总{$dd} \n{/list}\n\n{/list}\n\n\n\n\n\n外面循环是发布的信息\n\n里面的循环是对各自信息的回复\n\n\n\n请问里面循环的  ** $dd +=$c  **       显示出来的是页面所有 \n$c\n 相加的结果，如何改成计算每一条信息的结果呢\n\n\n\n\n\n\n图中第一条数据结果正确，从第二条开始，计算时会把第一条的也加上，就是说它依次计算了页面中所有** $c **的数据，请问如何调整才能让它只计算当条数据的结果呢\n\n\n\n谢谢\n\n\n\n又出了个问题\n\n\n\n\n$dd 只能累加最后两条的，超过两条就不加了 ，  这。。。。。不知是哪里出了问题？？", "Tag": "算法分析"}
{"Answer": "C++最全复数运算符重载,参考下\nC++最全复数运算符重载_PingBryant的博客-CSDN博客_c++运算符重载复数\nC++语言程序设计中，有关运算符重载的相关规则与方法请参考：https://blog.csdn.net/PingBryant/article/details/123089725?spm=1001.2014.3001.5501史上最全C++复数运算符重载代码如下：#include<iostream>using namespace std;class Complex{public:Complex(double x=0.0, double y=0.0);  //构造函数\n\n\n\nhttps://blog.csdn.net/PingBryant/article/details/123111393\n\n", "Konwledge_Point": "模运算", "Question": "c++：复数的运算符重载\n本题考虑对运算符进行重载。分别重载复数运算的+，-，*，/，=（赋值）运算符，以及比较大小的<=（复数1的模是否小于等于复数2的模）运算符，其中，比较运算符按复数的模进行比较。测试程序根据输入的mode值分别测试各个函数是否编写正确。\n函数接口定义：\n在这里描述函数接口：\n\n\n#\ninclude\n \n\n\n\nusing\n \nnamespace\n std;\n\n\nclass\n \nComplex\n {\n    \ndouble\n real;\n    \ndouble\n imag;\n\npublic\n:\n    \n//构造函数\n\n    \nComplex\n(\ndouble\n real=\n0\n, \ndouble\n imag=\n0\n);\n\n    \n//operator+-*/=操作符函数\n\n    Complex \noperator\n+(\nconst\n Complex& c) \nconst\n;\n    Complex \noperator\n-(\nconst\n Complex& c) \nconst\n;\n    Complex \noperator\n*(\nconst\n Complex& c) \nconst\n;\n    Complex \noperator\n/(\nconst\n Complex& c) \nconst\n;\n    Complex \noperator\n=(\nconst\n Complex& c);\n\n    \n//operator <=操作符函数\n\n    \nbool\n \noperator\n<=(\nconst\n Complex& c) \nconst\n;\n\n    \n//友元函数声明以帮助operator<<()函数访问Complex类的私有成员\n\n    \nfriend\n ostream& \noperator\n<<(ostream& out, \nconst\n Complex& c);\n};\n\n\n//n个复数，按模从小到达排序\n\n\nvoid\n \nbubble_sort\n(Complex[],\nint\n n)\n;\n\n\n\n\nbubble_sort函数按冒泡排序的算法对n个复数按模从小到大的顺序排序。\n\n\n裁判测试程序样例：\n在这里给出函数被调用进行测试的例子：\n\n\nint\n \nmain\n(\n)\n {\n    \ndouble\n dReal1, dImag1, dReal2, dImag2;\n\n    \nint\n mode;\n    cin>>mode;\n    cin>>dReal1>>dImag1>>dReal2>>dImag2;\n    \nComplex \nc1\n(\ndReal1, dImag1\n)\n;\n    \nComplex \nc2\n(\ndReal2, dImag2\n)\n;\n    Complex c[\n6\n] = {c1,c2,c1+c2,c1-c2,c1*c2,c1/c2};\n    \nswitch\n(mode)\n    {\n        \ncase\n \n1\n: cout << c[\n0\n]<<\n\" \"\n<\n\nComplex::Complex(\ndouble\n r,\ndouble\n i)\n{\n    \nreal\n=r;\n    imag=i;\n } \nComplex Complex::\noperator\n+(const Complex &c) const\n{\n    Complex c1;\n    c1.real=\nreal\n+c.real;\n    c1.imag=imag+c.imag;\n    \nreturn\n c1;\n }\nComplex Complex::\noperator\n-(const Complex &c) const\n{\n    Complex c1;\n    c1.real=\nreal\n-c.real;\n    c1.imag=imag-c.imag;\n    \nreturn\n c1;\n  } \nComplex Complex::\noperator\n=(const Complex &c)\n{\n    Complex c1;\n    c1.real=\nreal\n*c.real;\n    c1.imag=imag*c.imag;\n    \nreturn\n c1;\n  }\nComplex Complex::\noperator\n/(const Complex &c) const\n{\n    Complex c1;\n    c1.real=(\nreal\n*c.real+imag*c.imag)/(c.imag*c.imag+c.real*c.real);\n    c1.imag=(imag*c.real-\nreal\n*c.imag)/(c.imag*c.imag+c.real*c.real);\n    \nreturn\n c1;\n  } \nComplex Complex::\noperator\n*(const Complex &c) const\n{\n    Complex c1;\n    c1.real=\nreal\n*c.real-imag*c.imag;\n    c1.imag=\nreal\n*c.imag+imag*c.real;\n    \nreturn\n c1;\n  }\nostream& \noperator\n<<(ostream& \nout\n, const Complex& c)\n{\n    \nif\n(c.imag>\n0\n)\n        \nout\n<<c.real<<\"+\"<<c.imag<<\"i\";\n    \nelse\n\n        \nout\n<<c.real<<\"+\"<<c.imag;\n    \nreturn\n \nout\n;        \n}\n\n\ndouble\n distance(\ndouble\n r,\ndouble\n i)\n{\n    \nreturn\n sqrt(pow(r,\n2\n)+pow(i,\n2\n));\n}\n\nbool\n Complex::\noperator\n<=(const Complex &c) const\n{\n    \ndouble\n a,b;\n    a=distance(\nreal\n,imag);\n    b=distance(c.real,c.imag);\n    \nif\n(a<=b) \nreturn\n \ntrue\n;\n    \nelse\n \nreturn\n \nfalse\n;\n } \n//n个复数，按模从小到达排序\n\nvoid\n bubble_sort(Complex D[],\nint\n n)\n{\n    \nint\n i,j;\n    \nfor\n(i=\n1\n;i<n;i++)\n    {\n        \nfor\n(j=\n0\n;j<n-i;j++)\n        {\n            \nif\n(!(D[j]<=D[j+\n1\n]))\n            {\n                Complex \ntemp\n=D[j];\n                D[j]=D[j+\n1\n];\n                D[j+\n1\n]=\ntemp\n;\n            }\n        }\n      } \n}\n\n\n\n在输入\n\n\n6\n\n\n1 \n2\n \n3\n \n4\n\n\n\n\n这个例子的时候答案始终不对，输出是错的\n\n\n\n\n请问为什么啊？", "Tag": "算法分析"}
{"Answer": "你把最后一句话的输入全部转成小写再试试呢", "Konwledge_Point": "模运算", "Question": "python  不知道哪里出错了\n问题遇到的现象和发生背景\n\n\n题目描述\n在自然语言处理 NLP 的模型之中，通常会将每一个单词唯一对应到一个词\n向量，从而通过计算机对矩阵、向量的快速运算，达到对自然语言处理分析的目\n的。现在我们简化模型如下：\n假设给定 m 个单词ai(1 ≤ i ≤ m)，每个单词对应一个 n 维向量wi(1 ≤ i ≤ m)。\n再给定一个 n 维向量 v。定义每个单词ai的“分数”为其对应的词向量wi与给定\n向量 v 的内积。现在给定一串由单词ai(1 ≤ i ≤ m)组成的文本。请以此输出文本\n中每个单词所对应的“分数”。这里保证，对于文本中的每个单词，一定已经给\n出过它的词向量，并且文本中的单词不含标点符号，仅由空格分隔。\n说明：两个 n 维向量的内积指各分量相乘后再相加的值。\n输入格式\n输入 m+3 行，第一行为两个由空格分隔的正整数 m，n，表示共有 m 个单\n词，每个词向量的维数为 n。\n第二行为 n 个空格分隔的整数，代表给定的向量 v 的各个分量。\n从第三行开始，每一行为一个单词和 n 个空格分隔的整数，代表这个单词和\n它对应的词向量。\n最后一行是由一串单词组成的文本，每个单词以空格分隔。\n输出格式\n输出一行若干个整数，为文本中每个单词对应的“分数”，并以空格分隔。\n\n\n\n```\npython\n\n\nm\n,n=\nmap\n(\nint\n,\ninput\n().\nsplit\n())\nv=\nlist\n(\nmap\n(\nint\n,\ninput\n().\nsplit\n()))\nlis=[]\n\nfor\n i in \nrange\n(\nm\n):\n    \nl\n=\ninput\n().\nsplit\n()\n    lis.\nappend\n(\nl\n)\narti=\ninput\n().\nsplit\n()\ndic={}\n\nfor\n \nb\n in \nrange\n(\nm\n):\n    score=\n0\n\n    \nfor\n \nj\n in \nrange\n(\n1\n,n+\n1\n):\n        score+=\nint\n(lis[\nb\n][\nj\n])*v[\nj\n-\n1\n]\n    dic[lis[\nb\n][\n0\n]]=score\n\nfor\n \nk\n in arti:\n    \nprint\n(\nint\n(dic[\nk\n]),end=\n' '\n)\n\n\n\n\n自己在本地测试的时候好好的，按照题目的样例输入也都能得到一样的输出结果\n但是提交到课程的测试平台上就显示错误，不知道是哪里出了问题>-<，希望可以得到解答\n", "Tag": "算法分析"}
{"Answer": "数据库每个地方都可以考选择填空，看你们老师有没有給你们提纲，这样子的话就可以快速的将题目写出来。\n大题出后面的几率会比较大，难度会比较高嘛", "Konwledge_Point": "模运算", "Question": "求大佬分析一下数据库原理提纲，并参照提纲给点学习建议。谢谢\n一、考试基本要求\n\n\n\n本课程是一门数据库系统的基本概念和基本理论的课程。该课程考试的基本要求：\n\n\n\n掌握与数据库有关的基本概念，了解数据库的设计，应用开发和运行维护过程。\n了解关系模型的数学基础和关系数据库的规范化理论，掌握并学会使用关系数据库系统的标准语言SQL。\n\n\n\n二、考核知识范围及考核要求\n\n\n\n1\n、绪论\n\n\n\n数据库系统概述：\n数据、数据库、数据库管理系统、数据库系统、数据库系统的特点等基本概念的定义与理解。\n\n\n\n数据模型：\n层次、网状、关系、E-R模型等的构造形式及特点。重点是关系及E-R模型，要求熟练掌握其概念、技术及建模方法。\n\n\n\n数据库系统结构：\n数据库系统的三级模式与二级映象。\n\n\n\n2\n、关系数据库\n\n\n\n掌握关系模型的数学定义，关系模型、关系模式、关系数据库等基本概念；掌握关系代数的九种运算，即专门关系运算能熟练运用。\n\n\n\n3\n、关系数据库标准语言\nSQL\n\n\n\n掌握各类SQL语句的语法构成、语义与功能，特别是Select语句的不同应用方法。包括基本的定义及修改，索引的建立和删除；掌握SQL的数据操纵，连接查询，嵌套查询，库函数的应用；了解视图的定义，视图的查询，视图的更新及视图的优点。\n\n\n\n4\n、数据库安全性\n\n\n\n掌握计算机系统的三类安全性问题以及数据库安全性控制的基本技术。\n\n\n\n5\n、数据库完整性\n\n\n\n掌握完整性约束条件及完整性控制。\n\n\n\n6\n、关系数据理论\n\n\n\n掌握关系数据库理论提出的背景，对给定的数据如何改造数据模型；掌握函数依赖的定义：函数依赖中的部分函数依赖、完全函数依赖、传递函数依赖；对给定的实际问题可以确定函数依赖；掌握码的定义，对实际问题可以确定码；掌握1NF，2NF，3NF，BCNF的定义，对给定的关系模式可以确定属于什么级范式。\n\n\n\n7\n、数据库设计\n\n\n\n掌握数据库设计步骤；实际问题的需求分析；概念模型E-R图； E-R图向数据模型的转换；数据库的物理设计以及应用实例等。\n\n\n\n8\n、数据库恢复技术\n\n\n\n掌握事务的概念及特征，数据库恢复的基本原则；恢复的具体实现方法。\n\n\n\n9\n、并发控制\n\n\n\n掌握并发控制的基本概念，并发控制与实现技术，尤其是封锁技术的实施等。\n\n\n\n三、考试形式与试卷结构\n\n\n\n1\n、试卷分数及考试时间\n\n\n\n满分为100分，考试时间为120分钟。\n\n\n\n2\n、答题方式\n\n\n\n答题方式为闭卷、笔试。\n\n\n\n3\n、试卷题型结构\n\n\n\n题型\n\n\n\n题量\n\n\n\n分值\n\n\n\n单项选择题\n\n\n\n15\n\n\n\n30\n\n\n\n填空题\n\n\n\n10\n\n\n\n10\n\n\n\n判断题\n\n\n\n10\n\n\n\n10\n\n\n\n简答题\n\n\n\n4\n\n\n\n20\n\n\n\n综合应用题\n\n\n\n2\n\n\n\n30\n\n\n\n总计\n\n\n\n41\n\n\n\n100\n\n\n\n \n\n\n\n \n\n\n\n \n\n\n\n \n\n\n\n \n\n\n\n \n\n\n\n四、主要参考书目\n\n\n\n1、《数据库系统概论》王珊，萨师煊著， 2014年（第五版），高等教育出版社。", "Tag": "算法分析"}
{"Answer": "public static  double caculate(T a, T b) {\r\n\t\tdouble d = a.doubleValue() + b.doubleValue() + a.doubleValue() * b.doubleValue()\r\n\t\t\t\t+ a.doubleValue() / b.doubleValue();\r\n\t\treturn d;\r\n\t}", "Konwledge_Point": "模运算", "Question": "关于java泛型\n鉴于描述原来的问题有点麻烦，我举个简单的例子\n\n假如我现在要计算两个数字A+B+A*B+A/B（这两个数字类型相同，但其类型可以是int,float,long,double等，或者要求它们是Integer,Float,Long,Double也可以）\n\n可以将计算方法封装到一个独立的类\n\n为了便于维护，我想只写一个运算逻辑，也就是A+B+A*B+A/B\n\n\n\n有阵子没碰java了，不知道这问题是我把原来的知识忘了，还是java那鸡肋的泛型本身的局限", "Tag": "算法分析"}
{"Answer": "我把你的代码拿到本地跑了，首先你的代码的API是TF1.x版本的，我本地用的是tf1.15，所以第一步是把TF切换到1.15(我测试通过了，看你用Anaconda，那么安装就很简单了conda install tensorflow==1.15)，然后注意数据集的读取路劲要写对，你的代码train后面少了个 /\n\ntrain_dir = 'C:/Users/My104/Downloads/train/train/'\n我上传一张我跑起来的截图\n\n ", "Konwledge_Point": "模运算", "Question": "使用tensorflow时在 '__init__.py' 中找不到引用\n我使用的是Anaconde+cuda10.1+Cudnn+TensorFlow2.1.0+Pytorch1.7.1+Pycharm（python3.6）\n\n\n\n本人是机器学习初学者，想跑一个猫狗大战练练手，遇到了下列问题：\n\n\n\n个人感觉是我的一些配置出现了问题\n\n\n\n\n\n\n老是显示是 '__init__.py' 中找不到引用\n\n\n\n运行train.py会出现报错如下图:\n\n\n\n在网上也没有找到合适的解决方法，希望哥哥姐姐们可以帮我看一下，万分感谢！！!\n\n\n\n代码附在下面（数据集就是猫狗大战的数据集）：\n\n\n\ninput_data.py\n\n\n\n\n\nimport tensorflow as tf\nimport numpy as np\nimport os\n'''生成图片路径和标签的List'''\ndef get_files(file_dir):\n    '''\n           输入： 存放训练照片的文件地址\n           返回:  图像列表， 标签列表\n    '''\n    cats = []\n\n    label_cats = []\n    dogs = []\n    label_dogs = []\n    for file in os.listdir(file_dir):  # 用os.listdir函数来返回file_dir路径下所有的图片，file就是要读取的照片\n        name = file.split(sep='.')  # 用file.split 将文件的名字分隔开，分隔的符号是‘.’\n        if name[0] == 'cat':  # 所以只用读取 . 前面这个字符串\n            cats.append(file_dir + file)\n            label_cats.append(0)  # 把图像和标签加入列表\n        else:\n            dogs.append(file_dir + file)\n            label_dogs.append(1)  # 名字是cat就赋值0，名字是dog就赋值1\n    print('There are %d cats\\nThere are %d dogs' % (len(cats), len(dogs)))#打印有多少猫，多少狗\n    '''对生成的图片路径和标签List做打乱处理'''\n    image_list = np.hstack((cats, dogs))  #使用np.hstack()将cat和dog的图片和标签整合为列表image_list和label_list\n    label_list = np.hstack((label_cats, label_dogs))\n\n    temp = np.array([image_list, label_list])  # 将image_list和label_list合并，存放在temp\n    temp = temp.transpose()  # 对temp进行转置\n    np.random.shuffle(temp)  # 用shuffle来打乱图片和标签\n\n    image_list = list(temp[:, 0])  #从temp中取出乱序后的image_list和label_list列向量\n    label_list = list(temp[:, 1])\n    label_list = [int(float(i)) for i in label_list]  # 把标签列表转化为int类型\n\n    return image_list, label_list\n\n    ''' 由于数据集较大，需要分批次通过网络，故生成batch'''\n    '''step1：将上面生成的List传入get_batch() ，转换类型，产生一个输入队列queue，因为img和lab是分开的，\n             所以使用tf.train.slice_input_producer()，然后用tf.read_file()从队列中读取图像'''\ndef get_batch(image, label, image_W, image_H, batch_size, capacity):\n    \"\"\"\n    输入：\n    image,label ：要生成batch的图像和标签\n    image_W，image_H: 图像的宽度和高度\n    batch_size: 每个batch要放多少张图片\n    capacity: 一个队列最大多少\n    image_batch: 4D tensor [batch_size, width, height, 3], dtype=tf.float32\n    label_batch: 1D tensor [batch_size], dtype=tf.int32\n    \"\"\"\n    image = tf.cast(image, tf.string) #将列表转换成tf能够识别的格式\n    label = tf.cast(label, tf.int32)\n    \"\"\"\n    队列的理解：每次训练时，从队列中取一个batch送到网络进行训练，\n               然后又有新的图片从训练库中注入队列，这样循环往复。\n               队列相当于起到了训练库到网络模型间数据管道的作用，\n               训练数据通过队列送入网络。\n    \"\"\"\n    input_queue = tf.train.slice_input_producer([image, label])#将image和label合并生成一个队列\n\n    # 图像的读取需要tf.read_file()，标签则可以直接赋值\n    label = input_queue[1]\n    image_contents = tf.read_file(input_queue[0])#然后从队列中分别取出image和label\n    '''step2：将图像解码，不同类型的图像不能混在一起，要么只用jpeg，要么只用png等'''\n    image = tf.image.decode_jpeg(image_contents, channels=3)  # 解码彩色的.jpg图像\n    '''step3：数据预处理，对图像进行旋转、缩放、裁剪、归一化等操作，让计算出的模型更健壮'''\n    image = tf.image.resize_image_with_crop_or_pad(image, image_W, image_H)\n    image = tf.image.per_image_standardization(image)\n    '''step4：生成batch'''\n    image_batch, label_batch = tf.train.batch([image, label],\n                                              batch_size=batch_size,\n                                              num_threads=64,  # 涉及到线程，配合队列\n                                          capacity=capacity)\n    image_batch = tf.cast(image_batch, tf.float32)\n    label_batch = tf.cast(label_batch, tf.int32)  #重新排列label，行数为[batch_size]\n    return image_batch, label_batch\n\n\n# %% TEST\n# To test the generated batches of images\n# When training the model, DO comment the following codes\n\n\nimport matplotlib.pyplot as plt\n\nBATCH_SIZE = 2\nCAPACITY = 256\nIMG_W = 208\nIMG_H = 208\n\ntrain_dir = 'D:/Python/Pycharm_workstation/cats-vs-dogs-master/data/train'\nimage_list, label_list = get_files(train_dir)\nimage_batch, label_batch = get_batch(image_list, label_list, IMG_W, IMG_H, BATCH_SIZE, CAPACITY)\n\nwith tf.Session() as sess:\n    i = 0\n    coord = tf.train.Coordinator()\n    threads = tf.train.start_queue_runners(coord=coord)\n\n    try:\n        while not coord.should_stop() and i < 1:\n\n            img, label = sess.run([image_batch, label_batch])\n\n            # just test one batch\n            for j in np.arange(BATCH_SIZE):\n                print('label: %d' % label[j])  # j-index of quene of Batch_size\n                plt.imshow(img[j, :, :, :])\n                plt.show()\n            i += 1\n\n    except tf.errors.OutOfRangeError:\n        print('done!')\n    finally:\n        coord.request_stop()\n    coord.join(threads)\n\n\n\n\n\n\nmodel.py\n\n\n\n\n\nimport tensorflow as tf\n'''网络结构定义：一个简单的卷积神经网络，卷积+池化层x2，全连接层x2，最后一个softmax层做分类'''\ndef cnn_inference(images, batch_size, n_classes):\n    \"\"\"\n    输入\n    images      输入的图像\n    batch_size  每个批次的大小\n    n_classes   n分类\n    返回\n    softmax_linear 还差一个softmax\n\n输入参数：\nimages，image batch、4D tensor、tf.float32、[batch_size, width, height, channels]\n返回参数：\nlogits, float、 [batch_size, n_classes]\n    \"\"\"\n    '''第一层的卷积层conv1：16个3x3的卷积核（3通道），padding=’SAME’，表示padding后卷积的图与原图尺寸一致，激活函数relu()'''\n    with tf.variable_scope('conv1') as scope:\n        # 建立weights和biases的共享变量\n        # conv1, shape = [kernel size, kernel size, channels, kernel numbers]\n        weights = tf.get_variable('weights',\n                                  shape=[3, 3, 3, 16],\n                                  dtype=tf.float32,\n                                  initializer=tf.truncated_normal_initializer(stddev=0.1,\n                                                                              dtype=tf.float32))  # stddev标准差\n        biases = tf.get_variable('biases',\n                                 shape=[16],\n                                 dtype=tf.float32,\n                                 initializer=tf.constant_initializer(0.1))\n        conv = tf.nn.conv2d(images, weights, strides=[1, 1, 1, 1], padding='SAME')#padding填充周围有valid（丢弃）和same（补零）可选择\n        #strides:卷积时在图像每一维的步长（这是一个一维的向量，长度4)，第一维和第四维默认为1，第二维和第三维分别是平行和竖直滑行的步进长度\n        pre_activation = tf.nn.bias_add(conv, biases)  # 加入偏差\n        conv1 = tf.nn.relu(pre_activation, name=scope.name)  # 加上激活函数非线性化处理，且是在conv1的命名空间\n\n    '''池化层1:2*2最大池化，步长strides为2，池化后执行lrn()操作，局部响应归一化，对训练有利\n       第一层的池化层pool1和规范化norm1(特征缩放）'''\n    with tf.variable_scope('pooling1_lrn') as scope:\n        pool1 = tf.nn.max_pool(conv1, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1],\n                               padding='SAME', name='pooling1')\n        norm1 = tf.nn.lrn(pool1, depth_radius=4, bias=1.0, alpha=0.001 / 9.0,\n                          beta=0.75, name='norm1')\n        # ksize是池化窗口的大小=[1,height,width,1]，一般height=width=池化窗口的步长\n        # 池化窗口的步长一般是比卷积核多移动一位\n        # tf.nn.lrn是Local Response Normalization，（局部响应归一化）将输入小于0的值幅值为0，输入大于0的值不变\n\n    # 第二层的卷积层cov2，这里的命名空间和第一层不一样，所以可以和第一层取同名\n    with tf.variable_scope('conv2') as scope:\n        weights = tf.get_variable('weights',\n                                  shape=[3, 3, 16, 16],  # 这里只有第三位数字16需要等于上一层的tensor维度\n                                  dtype=tf.float32,\n                                  initializer=tf.truncated_normal_initializer(stddev=0.1, dtype=tf.float32))\n        biases = tf.get_variable('biases',\n                                 shape=[16],\n                                 dtype=tf.float32,\n                                 initializer=tf.constant_initializer(0.1))\n        conv = tf.nn.conv2d(norm1, weights, strides=[1, 1, 1, 1], padding='SAME')\n        pre_activation = tf.nn.bias_add(conv, biases)\n        conv2 = tf.nn.relu(pre_activation, name='conv2')\n\n    # 第二层的池化层pool2和规范化norm2\n    with tf.variable_scope('pooling2_lrn') as scope:\n        norm2 = tf.nn.lrn(conv2, depth_radius=4, bias=1.0, alpha=0.001 / 9.0,\n                          beta=0.75, name='norm2')\n        pool2 = tf.nn.max_pool(norm2, ksize=[1, 2, 2, 1], strides=[1, 1, 1, 1],\n                               padding='SAME', name='pooling2')\n        # 这里选择了先规范化再池化\n\n    # 第三层为全连接层local3,128个神经元，将之前pool层的输出reshape成一行，激活函数relu()\n    with tf.variable_scope('local3') as scope:\n        # flatten-把卷积过的多维tensor拉平成二维张量（矩阵）\n        reshape = tf.reshape(pool2, shape=[batch_size, -1])  # batch_size表明了有多少个样本\n\n        dim = reshape.get_shape()[1].value  # 知道-1(代表任意)这里具体是多少个\n        weights = tf.get_variable('weights',\n                                  shape=[dim, 128],  # 连接128个神经元\n                                  dtype=tf.float32,\n                                  initializer=tf.truncated_normal_initializer(stddev=0.005, dtype=tf.float32))\n        biases = tf.get_variable('biases',\n                                 shape=[128],\n                                 dtype=tf.float32,\n                                 initializer=tf.constant_initializer(0.1))\n        local3 = tf.nn.relu(tf.matmul(reshape, weights) + biases, name=scope.name)  # 矩阵相乘加上bias\n\n    # 第四层为全连接层local4\n    with tf.variable_scope('local4') as scope:\n        weights = tf.get_variable('weights',\n                                  shape=[128, 128],  # 再连接128个神经元\n                                  dtype=tf.float32,\n                                  initializer=tf.truncated_normal_initializer(stddev=0.005, dtype=tf.float32))\n        biases = tf.get_variable('biases',\n                                 shape=[128],\n                                 dtype=tf.float32,\n                                 initializer=tf.constant_initializer(0.1))\n        local4 = tf.nn.relu(tf.matmul(local3, weights) + biases, name='local4')\n\n    # 第五层为输出层softmax_linear,Softmax回归层 将前面的FC层输出，做一个线性回归，计算出每一类的得分，在这里是2类，所以这个层输出的是两个得分\n    with tf.variable_scope('softmax_linear') as scope:\n        weights = tf.get_variable('weights',\n                                  shape=[128, n_classes],\n                                  dtype=tf.float32,\n                                  initializer=tf.truncated_normal_initializer(stddev=0.005, dtype=tf.float32))\n        biases = tf.get_variable('biases',\n                                 shape=[n_classes],\n                                 dtype=tf.float32,\n                                 initializer=tf.constant_initializer(0.1))\n        softmax_linear = tf.add(tf.matmul(local4, weights), biases, name='softmax_linear')\n        # 这里只是命名为softmax_linear，真正的softmax函数放在下面的losses函数里面和交叉熵结合在一起了，这样可以提高运算速度。\n        # softmax_linear的行数=local4的行数，列数=weights的列数=bias的行数=需要分类的个数\n        # 经过softmax函数用于分类过程中，它将多个神经元的输出，映射到（0,1）区间内，可以看成概率来理解\n\n    return softmax_linear\n\n'''loss计算 \n   将网络计算得出的每类得分与真实值进行比较，得出一个loss损失值，这个值代表了计算值与期望值的差距。这里使用的loss函数是交叉熵。\n   一批loss取平均数。最后调用了summary.scalar()记录下这个标量数据，在TensorBoard中进行可视化\n'''\ndef losses(logits, labels):\n    \"\"\"\n    输入\n    logits: 经过cnn_inference处理过的tensor\n    labels: 对应的标签\n    返回\n    loss： 损失函数（交叉熵）\n    \"\"\"\n    with tf.variable_scope('loss') as scope:\n        cross_entropy = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=labels, name='loss_per_eg')\n        '''tf.nn.sparse_softmax_cross_entropy_with_logits()放在图片上，就是对一个像素深度方向的向量，与对应的标签做交叉熵，\n           再求一个像素深度方向交叉熵的和。loss值是对所有像素点的交叉熵和取平均。'''\n        loss = tf.reduce_mean(cross_entropy, name='loss')  # 求所有样本的平均loss\n        tf.summary.scalar(scope.name + '/loss', loss)\n    return loss\n'''loss损失值优化 :目的就是让loss越小越好，使用的是AdamOptimizer优化器 \n   函数：def trainning(loss, learning_rate)'''\ndef training(loss, learning_rate):\n    \"\"\"\n    输入\n    loss: 损失函数（交叉熵）\n    learning_rate： 学习率\n    返回\n    train_op: 训练的最优值\n    \"\"\"\n    with tf.name_scope('optimizer'):\n        optimizer = tf.train.AdamOptimizer(learning_rate=learning_rate)\n        # global_step不是共享变量，初始值为0，设定trainable=False 可以防止该变量被数据流图的 GraphKeys.TRAINABLE_VARIABLES 收集,\n        # 这样我们就不会在训练的时候尝试更新它的值。\n        global_step = tf.Variable(0, name='global_step', trainable=False)\n        train_op = optimizer.minimize(loss, global_step=global_step)\n    return train_op\n'''评价/准确率计算:计算出平均准确率来评价这个模型，在训练过程中按批次计算（每隔N步计算一次），可以看到准确率的变换情况。 \n   函数：def evaluation(logits, labels):'''\ndef evaluation(logits, labels):\n    \"\"\"\n     输入\n    logits: 经过cnn_inference处理过的tensor\n    labels:\n    返回\n    accuracy：正确率\n    \"\"\"\n    with tf.variable_scope('accuracy') as scope:\n        prediction = tf.nn.softmax(logits)\n        # Softmax简单的说就是把一个N*1的向量归一化为（0，1）之间的值，由于其中采用指数运算，使得向量中数值较大的量特征更加明显\n        # prediction每行的最大元素（1）的索引和label的值相同则为1 否则为0。\n        correct = tf.nn.in_top_k(prediction, labels, 1)\n        #tf.nn.in_top_k组要是用于计算预测的结果和实际结果的是否相等\n        # correct = tf.nn.in_top_k(logits, labels, 1)   也可以不需要prediction过渡，因为最大值的索引没变，这里这样写是为了更好理解\n        correct = tf.cast(correct, tf.float16)  # tf.cast() 函数的作用是执行 tensorflow 中张量数据类型转换\n        accuracy = tf.reduce_mean(correct)\n        tf.summary.scalar(scope.name + '/accuracy', accuracy)#通过函数tf.summary.scalar()记录的数据的变化趋势\n    return accuracy\n\n\n\n\ntrain.py\n\n\n\n\n\nimport os\nimport numpy as np\nimport tensorflow as tf\nimport input_data\nimport model\n\nN_CLASSES = 2  # 猫和狗\nIMG_W = 208  # resize图像，太大的话训练时间久\nIMG_H = 208\nBATCH_SIZE = 16#一次迭代的图片数量（50）\nCAPACITY = 2000\nMAX_STEP = 10000  # 一般5K~10k\nlearning_rate = 0.0001  # 一般小于0.0001\n\ntrain_dir = 'D:/Python/Pycharm_workstation/cats-vs-dogs-master/data/train'\nlogs_train_dir = 'D:/Python/Pycharm_workstation/catsvsdogs/log/'  # 记录训练过程与保存模型\n'''获取批次batch'''\ntrain, train_label = input_data.get_files(train_dir)\ntrain_batch,train_label_batch=input_data.get_batch(train,\n                                                   train_label,\n                                                   IMG_W,\n                                                   IMG_H,\n                                                   BATCH_SIZE,\n                                                   CAPACITY)\n'''操作定义'''\ntrain_logits = model.cnn_inference(train_batch, BATCH_SIZE, N_CLASSES)\ntrain_loss = model.losses(train_logits, train_label_batch)\ntrain_op = model.training(train_loss, learning_rate)\ntrain__acc = model.evaluation(train_logits, train_label_batch)\nsummary_op = tf.summary.merge_all() #自动管理模式\n\n#产生一个会话\nsess = tf.Session()\n#产生一个writer来写log文件\ntrain_writer = tf.summary.FileWriter(logs_train_dir, sess.graph)\n #产生一个saver来存储训练好的模型\nsaver = tf.train.Saver()\n#所有节点初始化\nsess.run(tf.global_variables_initializer())\n\n'''TensorFlow提供了两个类来实现对Session中多线程的管理：tf.Coordinator和 tf.QueueRunner，这两个类往往一起使用。'''\ncoord = tf.train.Coordinator()\n'''Coordinator类用来管理在Session中的多个线程，可以用来同时停止多个工作线程并且向那个在等待所有工作线程终止的程序报告异常，\n   该线程捕获到这个异常之后就会终止所有线程。使用 tf.train.Coordinator()来创建一个线程管理器（协调器）对象\n   QueueRunner类用来启动tensor的入队线程，可以用来启动多个工作线程同时将多个tensor（训练数据）推送入文件名称队列中，具体执行函数是\n    tf.train.start_queue_runners ， 只有调用 tf.train.start_queue_runners 之后，才会真正把tensor推入内存序列中，供计算单元调用，否则\n    会由于内存序列为空，数据流图会处于一直等待状态。\n'''\nthreads = tf.train.start_queue_runners(sess=sess, coord=coord)\n'''进行batch的训练'''\ntry:\n    #执行MAX_STEP步的训练，一步一个batch\n    for step in np.arange(MAX_STEP):\n        if coord.should_stop():\n                break\n        _, tra_loss, tra_acc = sess.run([train_op, train_loss, train__acc])\n        #每隔50步打印一次当前的loss以及acc，同时记录log，写入writer\n        if step % 50 == 0:\n            print('Step %d, train loss = %.2f, train accuracy = %.2f%%' %(step, tra_loss, tra_acc*100.0))\n            summary_str = sess.run(summary_op)\n            train_writer.add_summary(summary_str, step)\n        #每隔2000步，保存一次训练好的模型\n        if step % 2000 == 0 or (step + 1) == MAX_STEP:\n            checkpoint_path = os.path.join(logs_train_dir, 'model.ckpt')\n            saver.save(sess, checkpoint_path, global_step=step)\n\nexcept tf.errors.OutOfRangeError: #如果读取到文件队列末尾会抛出此异常\n    print('Done training -- epoch limit reached')\nfinally:\n    coord.request_stop()# 协调器coord发出所有线程终止信号\ncoord.join(threads)\nsess.close()\n", "Tag": "算法分析"}
{"Answer": "波特率115200，数据每秒11KB左右，4KB用300多毫秒，差不多啊。要是嫌慢，可以换c8051f340系列，用USB", "Konwledge_Point": "模运算", "Question": "C8051F020串口连续发送出现30延迟\n问题遇到的现象和发生背景\n\n\n使用C8051F020实现ADC读取采样计算后使用串口连续发送，串口发送间隔在20ms左右，但是每发送4K数据就有300ms的延迟。\n\n\n问题相关代码，请勿粘贴截图\n\n\n#include \n#include \n#include \n#include <\nstring\n.h>\n#include \n\n\n//宏声明\n\n#define uchar              unsigned char             \n//定义uchar类型\n\n#define \nuint\n               unsigned \nint\n              \n//定义uint类型\n\n#define BAUDRATE           \n115200\n                    \n//定义串口波特率\n\n#define SAR_CLK            \n2500000\n                   \n//定义SAR时钟熟读\n\n#define SAMPLE_RATE        \n50000\n                     \n//定义12位数模芯片采样率\n\n#define SYSTEMCLOCK        (\n22118400\nL)               \n//定义外部晶振速率\n\n#define UART_SIZE          \n128\n                       \n//定义串口1读取数据位数\n\n#define SAMP_NUM           \n22\n                        \n//定义ADC数组采样数量\n\n#define OPERATING          -((SYSTEMCLOCK / SAMPLE_RATE) * SAMP_NUM) \n//定义ADC运算转换频率\n\n\n\n//16位寄存器声明\n\nsfr16 ADC0                 = \n0xbe\n;                   \n//12位数模芯片数据定义\n\nsfr16 TMR2                 = \n0xcc\n;                   \n//定时器/计数器2初值\n\nsfr16 RCAP2                = \n0xca\n;                   \n//定时器/计数器2重载初值\n\nsfr16 TMR3                 = \n0x94\n;                   \n//定时器/计数器3初值\n\nsfr16 RCAP3                = \n0x92\n;                   \n//定时器/计数器3重载初值\n\nsfr16 TMR4                 = \n0xF4\n;                   \n//定时器/计数器4初值\n\nsfr16 RCAP4                = \n0xE4\n;                   \n//定时器/计数器4重载初值\n\n\n\n//引脚位声明\n\nsbit Auto_LED_RED          = P2^\n0\n;                   \n//Auto红灯控制位\n\nsbit Auto_LED_GREEN        = P2^\n1\n;                   \n//Auto绿灯控制位\n\nsbit ACK_LED_GREEN         = P3^\n1\n;                   \n//ACK绿灯控制位\n\nsbit ACK_LED_RED           = P3^\n2\n;                   \n//ACK红灯控制位\n\nsbit Watchdog              = P3^\n3\n;                   \n//3.3V电源看门狗控制位\n\nsbit Manual_LED_RED        = P3^\n6\n;                   \n//Manual红灯控制位\n\nsbit Manual_LED_GREEN      = P3^\n7\n;                   \n//Manual绿灯控制位\n\n\n\n//函数声明\n\n\nvoid\n OSCILLATOR_Init (\nvoid\n);                         \n//晶振初始化，切换为外部晶振\n\n\nvoid\n PORT_Init (\nvoid\n);                               \n//单片机端口初始化\n\n\nvoid\n Ext_Interrupt_Init (\nvoid\n);                      \n//外部中断初始化\n\n\nvoid\n Flash_WRITE(\nvoid\n);                              \n//非易失128Bety Flash写入\n\n\nvoid\n Flash_READ(\nvoid\n);                               \n//读取非易失Flash数据\n\n\nvoid\n ReadData(\nvoid\n);                                 \n//读取非易失区数据\n\n\nvoid\n ReadData1(\nvoid\n);                                \n//非中断读取非易失区数据\n\n\nvoid\n UART1_Init (\nvoid\n);                              \n//初始化串口1\n\n\nvoid\n delay(\nuint\n num);                                \n//延迟函数\n\n\nvoid\n TIMER2_Init();                                  \n//初始化定时计数器2，设置功率轮询输出\n\n\nvoid\n TIMER3_Init (\nint\n counts);                       \n//初始化定时计数器3，设置数模芯片转换速率\n\n\nvoid\n TIMER4_Init ();                                 \n//初始化定时计数器4，监控串口接受数据间隔\n\n\nvoid\n ADC0_Init (\nvoid\n);                               \n//初始化12位数模转换器\n\n\nvoid\n UART1_Deal(\nvoid\n);                               \n//串口数据处理\n\n\nvoid\n AcceptReset(uchar output, uchar outarr[]);      \n//串口数据清零\n\n\nvoid\n AcceptReset1(uchar output, uchar outarr[]);      \n//串口数据清零\n\n\n\n//全局变量声明\n\n\nuint\n idata AckBlink = \n0\n;                             \n//显示频率\n\n\nuint\n idata SampNum = \n0\n;                              \n//采样循环次数\n\n\nuint\n idata Samp = \n0\n;                                 \n//采样数据\n\nlong idata SampArr = \n0\n;                              \n//存放累积采样数据\n\nlong idata SampArrAll= \n0\n;                            \n//保存组采样值\n\n\nfloat\n xdata Kvaule = \n0\n;                              \n//ADC斜率\n\n\nfloat\n xdata Bvalue = \n0\n;                              \n//ADC最小值\n\n\nfloat\n xdata Power = \n0\n;                               \n//光功率\n\nuchar idata Byte = \n0\n;                                \n//串口1读一位数据\n\nuchar idata InputCheck = \n0\n;                          \n//串口1输入累加校验和\n\nuchar idata OutputCheck = \n0\n;                         \n//串口1输出累加校验和\n\nuchar idata UART_Input_Size= \n0\n;                      \n//串口1输入数据计数\n\nuchar idata UART_Input_First= \n0\n;                     \n//串口1输入字符位数\n\nuchar xdata UART_Input[UART_SIZE];                   \n//串口1读取数据大小    \n\nuchar idata UART_output_Size = \n0\n;                    \n//串口1输出数据计数\n\nuchar idata UART_output_First= \n0\n;                    \n//串口1输出字符位数\n\nuchar xdata UART_output[UART_SIZE];                  \n//串口1读出数据大小\n\nuchar xdata Permanent_data[\n128\n];                     \n//不丢失数据\n\nuchar code outok[] = {\n0xEF\n, \n0x00\n, \n0x4F\n, \n0x3E\n};       \n//正确返回值\n\nuchar code outon[] = {\n0xEF\n, \n0x00\n, \n0x58\n, \n0x47\n};       \n//错误返回值\n\nuchar xdata outarr[\n128\n] = {\n0xEF\n};                    \n//返回值\n\nuchar tempchar[\n4\n];                                   \n//char转float数组\n\n\nfloat\n * tempfloat;                                   \n//char转float指针\n\nuchar pollflag = \n0\n;                                  \n//轮询功率开关\n\n\n\n//主函数\n\n\nvoid\n main(\nvoid\n)\n{\n     WDTCN = \n0xde\n;                                     \n//关闭单片机内部看门狗\n\n   WDTCN = \n0xad\n;                                     \n//关闭单片机内部看门狗\n\n    \n     OSCILLATOR_Init();                                \n//初始化晶振\n\n     ReadData1();                                      \n//非中断读取非易失区数据\n\n     PORT_Init();                                      \n//初始端口\n\n     Ext_Interrupt_Init();                             \n//初始化外部中断\n\n     UART1_Init();                                     \n//初始化串口1\n\n     TIMER2_Init();                                    \n//初始化定时计数器2，设置功率轮询输出\n\n     TIMER3_Init(SYSTEMCLOCK/SAMPLE_RATE);             \n//初始化定时器3,设置数模芯片转换速率\n\n     TIMER4_Init ();                                   \n//初始化定时计数器4，监控串口接受数据间隔\n\n     ADC0_Init();                                      \n//初始化12位数模转换器\n\n     AD0EN = \n1\n;                                        \n//打开12位数模转换器    \n\n     EA    = \n1\n;                                        \n//打开所有中断  \n\n\n     Manual_LED_GREEN = \n0\n;                             \n//关闭Manual灯\n\n     Manual_LED_RED   = \n0\n;                             \n//关闭Manual灯\n\n     Auto_LED_GREEN   = \n0\n;                             \n//关闭Auto灯\n\n     Auto_LED_RED     = \n0\n;                             \n//关闭Auto灯\n\n     ACK_LED_GREEN    = \n0\n;                             \n//关闭ACK灯\n\n     ACK_LED_RED      = \n0\n;                             \n//关闭ACK灯\n\n     P4               = \n0xFF\n;                          \n//将LED1~4号为灯亮红\n\n    \n    \nwhile\n(\n1\n)\n    {\n        Watchdog = \n0\n;                                       \n//更新3.3V电源看门狗\n\n        Watchdog = \n1\n;                                    \n//更新3.3V电源看门狗\n\n        Auto_LED_RED = Manual_LED_GREEN = \n0\n;             \n//熄灭串口信号灯        \n\n\n        \nif\n(AckBlink > \n0xDFFF\n)                            \n//显示间隔\n\n        {\n            ACK_LED_GREEN = ~ACK_LED_GREEN;                \n//闪烁ACK灯\n\n            AckBlink = \n0\n;\n        }\n        \n        \n//delay(1);\n\n        \n        AckBlink++;                                         \n//显示次数累加\n\n    }\n\n}\n\n\n//延迟函数\n\n\nvoid\n delay(\nuint\n num)\n{\n    \nuint\n i, j;\n    \nfor\n(i = \n0\n; i < num; i++)\n        \nfor\n(j = \n0\n; j < \n200\n; j++);\n}\n\n\n//晶振初始化\n\n\nvoid\n OSCILLATOR_Init (\nvoid\n)\n{\n   \nuint\n i;                                           \n//定义累加值\n\n   OSCXCN = \n0x67\n;                                    \n//设置外部晶振22.1184MHz\n\n                                                       \n//晶体振荡器方式，晶体振荡器未用或未稳定\n\n   \nfor\n (i=\n0\n; i < \n256\n; i++) ;                         \n//等待晶振运行\n\n   \nwhile\n (!(OSCXCN & \n0x80\n));                         \n//等待晶振运行稳定\n\n   OSCICN = \n0x88\n;                                    \n//选择外部振荡器作为系统时钟\n\n                                                     \n//允许时钟丢失检测器 检测到时钟丢失时间大于 100 微秒时将触发复位\n\n\n}\n\n\n//端口初始化\n\n\nvoid\n PORT_Init (\nvoid\n)\n{\n   XBR0      = \n0x07\n;                                 \n//设置P1.0为TX1，P1.1为RX1\n\n   XBR1      = \n0x14\n;                                 \n//设置P1.2为INT0，P1.3为INT1\n\n   XBR2      = \n0x44\n;                                 \n//设置P0.6为SDA，P0.7为SCL\n\n   \n   P0MDOUT   = \n0xFF\n;                                 \n//设置P0为推挽方式\n\n   P1MDOUT   = \n0xFF\n;                                 \n//设置P1为推挽方式\n\n   P2MDOUT   = \n0xFF\n;                                 \n//设置P2为推挽方式\n\n     P3MDOUT   = \n0xFF\n;                                 \n//设置P3为推挽方式\n\n     P74OUT    = \n0xBF\n;                                 \n//设置P4-P7为推挽方式\n\n}\n\n\n//外部中断初始化\n\n\nvoid\n Ext_Interrupt_Init (\nvoid\n)\n{\n   TCON = \n0x05\n;                        \n// /INT 0 和INT 1 边沿触发\n\n\n   EX0 = \n1\n;                            \n// 使能 /INT0 中断\n\n   EX1 = \n1\n;                            \n// 使能 /INT1 中断\n\n}\n\n\n//初始化串口1\n\n\nvoid\n UART1_Init (\nvoid\n)\n{\n   SCON1     = \n0x50\n;                                 \n//UART1 接收允许\n\n                                                       \n//方式 1 8 位 UART 可变波特率\n\n   TMOD     &= ~\n0xF0\n;                                \n//清除定时器 0设置\n\n   TMOD     |= \n0x20\n;                                 \n//自动重装载的 8 位计数器/定时器\n\n     PCON     |= \n0x10\n;                                 \n//禁止 UART1 的波特率/2 功能\n\n     CKCON    |= \n0x10\n;                                 \n//定时器 1 使用系统时钟\n\n     TH1       = -((SYSTEMCLOCK/BAUDRATE)/\n16\n);         \n//设置定时器1 TH1初值\n\n   TL1       = TH1;                                  \n//设置定时器1 TL1初值\n\n   TR1       = \n1\n;                                    \n//启动定时器1\n\n   EIE2      = \n0x40\n;                                 \n//允许 UART1 中断\n\n   EIP2      = \n0x40\n;                                 \n//外部中断 6 设置为高优先级\n\n}\n\n\n//初始化定时器3\n\n\nvoid\n TIMER3_Init (\nint\n counts)\n{\n   TMR3CN    = \n0x02\n;                                 \n//定时器3禁止;定时器3的时钟源由 T3M TMR3CN.1 位定义;计数器/定时器3使用系统时钟\n\n   RCAP3     = -counts;                              \n//设置定时器重载初值\n\n   TMR3      = RCAP3;                                \n//设置定时器初值\n\n   EIE2     &= ~\n0x01\n;                                \n//禁止定时器3中断\n\n   TMR3CN   |= \n0x04\n;                                 \n//开始定时器3\n\n}\n\n\n//初始化12位数模转换器\n\n\nvoid\n ADC0_Init (\nvoid\n)\n{\n   ADC0CN    = \n0x04\n;                                 \n//ADC0禁止，当ADC被允许时除了转换期间之外一直处于跟踪方式\n\n                                                     \n//定时器3溢出启动ADC0转换，数据右对齐\n\n   REF0CN    = \n0x07\n;                                 \n//内部电压基准缓冲器工作，内部电压基准提供从 VREF 引脚输出\n\n                                                     \n//内部偏压发生器工作，内部温度传感器工作\n\n   AMX0CF    = \n0x00\n;                                 \n//ADC0独立的单端输入\n\n     AMX0SL    = \n0x01\n;                                 \n//选择AIN0.1引脚作为ADC0信号输入\n\n   ADC0CF    = (SYSTEMCLOCK/SAR_CLK) << \n3\n;           \n//ADC0转换时钟= 2.5MHz\n\n   ADC0CF   |= \n0x00\n;                                 \n//PGA增益= 1(默认)\n\n   EIE2     |= \n0x02\n;                                 \n//使ADC中断\n\n\n//     EIP2      = 0x03;                               //ADC 转换结束中断为高优先级\n\n                                                                                                         \n//定时器 3 中断为高优先级\n\n}\n\n\n//初始化定时器4\n\n\nvoid\n TIMER4_Init ()\n{\n     CKCON &= ~\n0x40\n;                                   \n//定时器 4 使用系统时钟12分频\n\n     RCAP4 = -(SYSTEMCLOCK/\n1000\n/\n12\n*\n5\n);                 \n//定时器4在1 kHz溢出1ms\n\n   TMR4 = RCAP4;                                     \n//设置定时器初值\n\n     T4CON &= ~\n0x80\n;                                   \n//清除初始化标志\n\n     EIE2 |= \n0x04\n;                                     \n//启动定时器4中断\n\n     T4CON |= \n0x04\n;                                    \n//启动定时器4\n\n     \n//T4CON &= ~0x04;                                    //关闭定时器4    \n\n}\n\n\n//初始化定时器2\n\n\nvoid\n TIMER2_Init()\n{\n   CKCON |= \n0x20\n;                                    \n//定时器 2 使用系统时钟\n\n   RCAP2 = OPERATING;                                \n//定时器2设置初值\n\n   TMR2 = RCAP2;                                     \n//设置定时器初值\n\n     T2CON = \n0x04\n;                                     \n//使能定时器2自动填装\n\n     TF2 = \n0\n;                                          \n//清除初始化标志\n\n   ET2 = \n1\n;                                          \n//启动定时器2中断\n\n     TR2 = \n1\n;                                          \n//启动定时器2  \n\n     \n//PT2 = 1;                                          //定时器2优先级最高\n\n}\n\n\n//外部中断1\n\n\nvoid\n INT0_ISR (\nvoid\n) \nint\nerrupt \n0\n\n{\n   pollflag = \n1\n;\n//打开轮询\n\n}\n\n\n//外部中断2\n\n\nvoid\n INT1_ISR (\nvoid\n) \nint\nerrupt \n2\n\n{\n   pollflag = \n0\n;\n//关闭轮询\n\n}\n\n\n\n//功率轮询\n\n\nvoid\n Power_Poll (\nvoid\n) \nint\nerrupt \n5\n\n{\n    \n    Power = ((\nfloat\n)SampArrAll * Kvaule + Bvalue * (\nfloat\n)SAMP_NUM ) / (\nfloat\n)SAMP_NUM;\n//计算光功率值dBm\n\n    \n    \nif\n(Power <= \n-65\n)                          \n//测试最小值\n\n    {\n         Power = \n-65\n; \n    }\n    \nelse\n \nif\n(Power >= \n10\n)                      \n//测试最大值              \n\n    {\n         Power = \n10\n;\n    }\n    \n    \nif\n(pollflag == \n1\n)     \n    {  \n        \nfloat\n temp = Power;                          \n//将功率值读入缓冲区\n\n        char * temp1;                                \n//零时指针 \n\n        TMR2 = RCAP2;                                \n//设置定时器初值\n\n        UART_output_Size = \n6\n;\n        \n        temp1=(char*)(&temp);\n        outarr[\n0\n] = \n0xEF\n; \n        outarr[\n1\n] = temp1[\n3\n];                        \n//将缓冲器数据写入待发区\n\n        outarr[\n2\n] = temp1[\n2\n];        \n        outarr[\n3\n] = temp1[\n1\n];                              \n        outarr[\n4\n] = temp1[\n0\n];     \n        AcceptReset1(UART_output_Size, &outarr);         \n//中断发送函数    \n\n    }\n\n  TF2 = \n0\n;                                         \n//清除初始化标志\n\n}\n\n\n//12位数模转换器中断\n\n\nvoid\n ADC0_ISR (\nvoid\n) \nint\nerrupt \n15\n\n{\n\n    \nif\n(SampNum == SAMP_NUM)                                  \n//判断采样次数\n\n    {\n        SampArrAll = SampArr;\n        SampArr = \n0\n;\n        SampNum = \n0\n;\n    }\n    \n    Samp = ADC0;                                       \n//写入采样值\n\n    SampNum++;                                         \n//累加\n\n    SampArr += ADC0;                                   \n//读取采样放入数组\n\n\n  AD0INT = \n0\n;                                        \n//采样中断标志位清零\n\n}\n\n\n//串口接受间隔\n\n\nvoid\n UART1_time (\nvoid\n) \nint\nerrupt \n16\n\n{\n   uchar i;\n     TMR4 = RCAP4;                                     \n//设置定时器初值\n\n    \n     \nfor\n(i = \n0\n; i < UART_Input_Size; i++)\n      UART_Input[i] = \n0\n;                               \n//清除发送缓冲器\n\n   InputCheck = \n0\n;                                   \n//输入校验和清零\n\n     UART_Input_Size = \n0\n;                              \n//发送数据计数清零\n\n      \n     T4CON &= ~\n0x80\n;                                   \n//清除初始化标志\n\n}\n\n\n//串口1中断响应函数\n\n\nvoid\n UART1_Interrupt (\nvoid\n) \nint\nerrupt \n20\n\n{\n   \nif\n ((SCON1 & \n0x01\n) == \n0x01\n)                       \n//判断RI1接收中断标志\n\n   {\n            TMR4 = RCAP4;                                  \n//设置定时器初值     \n\n          T4CON &= ~\n0x80\n;                                \n//清除初始化标志\n\n      \nif\n( UART_Input_Size == \n0\n)                      \n//检查是否输入了新单词\n\n            {\n                    UART_Input_First = \n0\n;                      \n//初始化数组序号\n\n            } \n      Byte  = SBUF1;                                 \n//从超级终端读取字符    \n\n      \nif\n (UART_Input_Size < UART_SIZE)               \n//判断读取数据是否超出\n\n      {\n         UART_Input[UART_Input_First] = Byte;        \n//将Byte写入数组\n\n         UART_Input_Size++;                          \n//更新数组大小\n\n         UART_Input_First++;                         \n//更新数组位数\n\n                 Auto_LED_RED = ~Auto_LED_RED;               \n//Auto灯闪烁\n\n      }\n            \n            \nif\n(UART_Input_Size > \n3\n)\n                 UART1_Deal();                               \n//串口接受处理函数\n\n            SCON1 = (SCON1 & \n0xFE\n);                        \n//清零RI1接收中断标志位\n\n   }\n\n   \nif\n ((SCON1 & \n0x02\n) == \n0x02\n)                       \n//判断TI1发送中断标志\n\n   {\n      \nif\n (UART_output_Size != \n0\n)                     \n//如果缓冲区不为空\n\n      {        \n         Byte = UART_output[UART_output_First];      \n//在变量字节中存储一个字符\n\n         SBUF1 = Byte;                               \n//将一位数据写入缓冲器\n\n         UART_output_First++;                        \n//数组位累加\n\n         UART_output_Size--;                         \n//数组总数减一\n\n                 Manual_LED_GREEN = ~Manual_LED_GREEN;       \n//Manual灯闪烁\n\n      }\n      \nelse\n\n      {\n                 UART_output_First = \n0\n;                      \n//发送位清零\n\n                 \n//UART_output_Size = 0;                       //发送数量清零\n\n      }\n            SCON1 = (SCON1 & \n0xFD\n);                      \n//清零TI1接收中断标志位\n\n   }\n }\n\n\n//非易失128Bety Flash写入\n\n\nvoid\n Flash_WRITE(\nvoid\n)\n{\n    uchar i;                                           \n//初始化累加值\n\n    uchar xdata * pwrite;                              \n//非易失区指针\n\n    uchar * pgen;                                      \n//常规指针\n\n    EA = \n0\n;                                            \n//关闭所有中断\n\n  FLSCL = \n0x01\n;                                      \n//允许对Flash进行写入\n\n    PSCTL = \n0x07\n;                                      \n//允许对Flash进行擦除\n\n    pwrite = \n0x1000\n;                                   \n//指向Flash的首地址\n\n    *pwrite = \n0\n;                                       \n//擦除该Flash扇区\n\n    PSCTL = \n0x05\n;                                      \n//禁止对Flash进行擦除\n\n    pgen = &Permanent_data[\n0\n];                         \n//将数组128位    数据写入Flash\n\n    \nfor\n(i = \n0\n; i < \n128\n; i++)\n        *pwrite++ = *pgen++;\n    FLSCL = \n0x00\n;                                      \n//禁止对Flash进行写入\n\n    PSCTL = \n0x00\n;                                      \n//禁止对Flash进行擦除\n\n    EA = \n1\n;                                            \n//打开所有中断\n\n}\n \n\n//读取非易失Flash数据\n\n\nvoid\n Flash_READ(\nvoid\n)\n{\n    uchar i;                                           \n//初始化累加值\n\n    uchar code *pread;                                 \n//程序存储空间指针\n\n    PSCTL = \n0x04\n;                                      \n//允许访问128K数据\n\n  EA = \n0\n;                                            \n//关闭所有中断\n\n    pread = \n0x1000\n;                                    \n//指向Flash的首地址\n\n    \nfor\n(i = \n0\n; i < \n128\n; i++)                           \n//读取非易失Flash数据start到stop数据\n\n    {\n        Permanent_data[i] = *pread++;    \n    }  \n    PSCTL = \n0x00\n;                                      \n//禁止对Flash进行擦除\n\n    EA = \n1\n;                                            \n//打开所有中断\n\n}\n \n\n//串口数据处理\n\n\nvoid\n UART1_Deal(\nvoid\n)\n{\n    uchar i;                                          \n//累加数\n\n    \nif\n((UART_Input[\n0\n] == \n0xEF\n))     \n//验证引导码确定发送数据完成\n\n    {\n        InputCheck = \n0\n;                              \n//校验和清零\n\n        \nfor\n(i = \n0\n; i < UART_Input_Size - \n1\n; i++)       \n//计算校验和\n\n            InputCheck += UART_Input[i];\n        \nif\n(UART_Input[\n1\n] == \n0x01\n)                        \n//客户写入\n\n        {\n            \nif\n((UART_Input[\n2\n] == \n0x15\n) && (UART_Input_Size == \n0x04\n) && (InputCheck == Byte))\n//停止功率轮询\n\n            {    \n                 pollflag = \n0\n;                                      \n//关闭定时器2  \n\n            }            \n            \nelse\n \nif\n((UART_Input[\n2\n] == \n0x16\n) && (UART_Input_Size == \n0x04\n) && (InputCheck == Byte))\n//开始功率轮询\n\n            {    \n                 pollflag = \n1\n;                                      \n//开启定时器2  \n\n            }                    \n        }\n        \nelse\n \nif\n(UART_Input[\n1\n] == \n0x02\n)                     \n//客户读取\n\n        {\n            \nif\n((UART_Input[\n2\n] == \n0x07\n) && (UART_Input_Size == \n0x04\n) && (InputCheck == Byte))\n//读取T1光功率\n\n            {\n                \nfloat\n temp = Power;                         \n//将功率值读入缓冲区\n\n                char * temp1;                                  \n//零时指针 \n\n                UART_output_Size = \n6\n;\n                temp1=(char*)(&temp);\n                outarr[\n0\n] = \n0xEF\n; \n                outarr[\n1\n] = temp1[\n3\n];                          \n//将缓冲器数据写入待发区\n\n                outarr[\n2\n] = temp1[\n2\n];        \n                outarr[\n3\n] = temp1[\n1\n];                              \n                outarr[\n4\n] = temp1[\n0\n];    \n                AcceptReset(UART_output_Size, &outarr);    \n            }    \n        }\n        \nelse\n \nif\n(UART_Input[\n1\n] == \n0x11\n)                   \n//后台写入\n\n        {\n            \nif\n((UART_Input[\n2\n] == \n0x00\n) && (UART_Input_Size == \n0x0A\n) && (InputCheck == Byte))\n//写入SN号\n\n            {  \n                \nfor\n(i = \n0\n; i < UART_Input_Size; i++)         \n//将SN号写入到非易失FLASH\n\n                {\n                    \nif\n((i > \n2\n) && (i < UART_Input_Size \n-1\n))\n                        Permanent_data[i\n-3\n] = UART_Input[i];   \n                }\n                Flash_WRITE();                               \n//写入非易失Flash\n\n                ReadData();                                  \n//读取非易失区数据\n\n                AcceptReset(\n4\n, &outok);    \n            }\n            \nelse\n \nif\n((UART_Input[\n2\n] == \n0x01\n) && (UART_Input_Size == \n0x08\n) && (InputCheck == Byte))\n//写入T1K值(1550)\n\n            {\n                \nfor\n(i = \n0\n; i < UART_Input_Size; i++)         \n//T1K值写入到非易失FLASH\n\n                {\n                    \nif\n((i > \n2\n) && (i < \n7\n))\n                        Permanent_data[i\n-3\n+\n6\n] = UART_Input[i];   \n                }\n                Flash_WRITE();                               \n//写入非易失Flash\n\n                ReadData();                                  \n//读取非易失区数据\n\n                AcceptReset(\n4\n, &outok);    \n            }\n            \nelse\n \nif\n((UART_Input[\n2\n] == \n0x05\n) && (UART_Input_Size == \n0x08\n) && (InputCheck == Byte))\n//写入T1B值(1550)\n\n            {\n                \nfor\n(i = \n0\n; i < UART_Input_Size; i++)         \n//T1B值写入到非易失FLASH\n\n                {\n                    \nif\n((i > \n2\n) && (i < \n7\n))\n                        Permanent_data[i\n-3\n+\n6\n+\n4\n*\n4\n] = UART_Input[i];   \n                }\n                Flash_WRITE();                               \n//写入非易失Flash\n\n                ReadData();                                  \n//读取非易失区数据\n\n                AcceptReset(\n4\n, &outok);                            \n            }\n        }\n        \nelse\n \nif\n(UART_Input[\n1\n] == \n0x12\n)\n//后台读取\n\n        {\n            \nif\n((UART_Input[\n2\n] == \n0x00\n) && (UART_Input_Size == \n0x04\n) && (InputCheck == Byte))\n//读取SN号\n\n            { \n                UART_output_Size = \n8\n;\n                Flash_READ();                                  \n//重新读取非易失区数据\n\n                \nfor\n(i = \n1\n; i < UART_output_Size\n-1\n; i++)        \n//将缓冲器数据写入待发区\n\n                {\n                    outarr[i] = Permanent_data[i\n-1\n];  \n                }    \n                AcceptReset(UART_output_Size, &outarr);\n            }\n            \nelse\n \nif\n((UART_Input[\n2\n] == \n0x01\n) && (UART_Input_Size == \n0x04\n) && (InputCheck == Byte))\n//读取T1K值(1550)\n\n            {\n                UART_output_Size = \n6\n;\n                Flash_READ();                                  \n//重新读取非易失区数据\n\n                \nfor\n(i = \n1\n; i < UART_output_Size\n-1\n; i++)        \n//将缓冲器数据写入待发区\n\n                {\n                    outarr[i] = Permanent_data[i\n-1\n+\n6\n];  \n                }    \n                AcceptReset(UART_output_Size, &outarr);        \n            }\n            \nelse\n \nif\n((UART_Input[\n2\n] == \n0x05\n) && (UART_Input_Size == \n0x04\n) && (InputCheck == Byte))\n//读取T1B值(1550)\n\n            {\n                UART_output_Size = \n6\n;\n                Flash_READ();                                  \n//重新读取非易失区数据\n\n                \nfor\n(i = \n1\n; i < UART_output_Size\n-1\n; i++)        \n//将缓冲器数据写入待发区\n\n                {\n                    outarr[i] = Permanent_data[i\n-1\n+\n6\n+\n4\n*\n4\n];  \n                }    \n                AcceptReset(UART_output_Size, &outarr);                            \n            }\n            \nelse\n \nif\n((UART_Input[\n2\n] == \n0x19\n) && (UART_Input_Size == \n0x04\n) && (InputCheck == Byte))\n//读取T1采样值\n\n            {\n                \nuint\n temp = Samp;                           \n//将采样值读入缓冲区\n\n                UART_output_Size = \n4\n;\n                outarr[\n0\n] = \n0xEF\n;                     \n                outarr[\n2\n] = temp;                              \n//将缓冲器数据写入待发区\n\n                temp = temp >> \n8\n;\n                outarr[\n1\n] = temp;    \n                AcceptReset(UART_output_Size, &outarr);    \n            }\n        }\n    }\n}\n \n\n//发送接收缓冲器初始化\n\n\nvoid\n AcceptReset(uchar output, uchar outarr[])  \n{\n  uchar i;\n    InputCheck = \n0\n;                                    \n//输入校验和清零\n\n    OutputCheck = \n0\n;                                   \n//输出校验和清零\n\n    UART_output_First = \n0\n;                             \n//发送位清零  \n\n    \n    UART_output_Size = output;                       \n//初始化输出数组数量    \n\n    \n    \nfor\n(i = \n0\n; i < UART_output_Size - \n1\n; i++)\n    {\n        UART_output[i] = outarr[i];                    \n//写入返回数据\n\n        OutputCheck += outarr[i];                      \n//计算输出校验和\n\n    }\n    UART_output[UART_output_Size\n-1\n] = OutputCheck;   \n//写入返回最后数据\n\n    \n    SCON1 = (SCON1 | \n0x02\n);                          \n//激活串口RX标记位\n\n}\n\n\n//中断发送接收缓冲器初始化\n\n\nvoid\n AcceptReset1(uchar output, uchar outarr[])  \n{\n    uchar i;\n    InputCheck = \n0\n;                                    \n//输入校验和清零\n\n    OutputCheck = \n0\n;                                   \n//输出校验和清零\n\n    UART_output_First = \n0\n;                             \n//发送位清零  \n\n    \n    UART_output_Size = output;                       \n//初始化输出数组数量    \n\n    \n    \nfor\n(i = \n0\n; i < UART_output_Size - \n1\n; i++)\n    {\n        UART_output[i] = outarr[i];                    \n//写入返回数据\n\n        OutputCheck += outarr[i];                      \n//计算输出校验和\n\n    }\n    UART_output[UART_output_Size\n-1\n] = OutputCheck;   \n//写入返回最后数据\n\n    \n    SCON1 = (SCON1 | \n0x02\n);                          \n//激活串口RX标记位    \n\n}\n\n\n//读取非易失区数据\n\n\nvoid\n ReadData(\nvoid\n)                                  \n{\n     Flash_READ();                                      \n//将非易失Flash数据全部读入Permanent_data数组\n\n\n        tempchar[\n0\n] = Permanent_data[\n9\n];         \n//读取非易失数据中K值(1550)\n\n        tempchar[\n1\n] = Permanent_data[\n8\n];\n        tempchar[\n2\n] = Permanent_data[\n7\n];\n        tempchar[\n3\n] = Permanent_data[\n6\n];\n        tempfloat=(\nfloat\n*)(&tempchar);\n        Kvaule = *tempfloat;\n         \n        tempchar[\n0\n] = Permanent_data[\n25\n];        \n//读取非易失数据中B值(1550)\n\n        tempchar[\n1\n] = Permanent_data[\n24\n];\n        tempchar[\n2\n] = Permanent_data[\n23\n];\n        tempchar[\n3\n] = Permanent_data[\n22\n];\n        tempfloat=(\nfloat\n*)(&tempchar);\n        Bvalue = *tempfloat;\n         \n     \n}\n\n\n//非中断读取非易失区数据\n\n\nvoid\n ReadData1(\nvoid\n)                                  \n{\n     Flash_READ();                                      \n//将非易失Flash数据全部读入Permanent_data数组\n\n    \n        tempchar[\n0\n] = Permanent_data[\n9\n];         \n//读取非易失数据中K值(1550)\n\n        tempchar[\n1\n] = Permanent_data[\n8\n];\n        tempchar[\n2\n] = Permanent_data[\n7\n];\n        tempchar[\n3\n] = Permanent_data[\n6\n];\n        tempfloat=(\nfloat\n*)(&tempchar);\n        Kvaule = *tempfloat;\n         \n        tempchar[\n0\n] = Permanent_data[\n25\n];        \n//读取非易失数据中B值(1550)\n\n        tempchar[\n1\n] = Permanent_data[\n24\n];\n        tempchar[\n2\n] = Permanent_data[\n23\n];\n        tempchar[\n3\n] = Permanent_data[\n22\n];\n        tempfloat=(\nfloat\n*)(&tempchar);\n        Bvalue = *tempfloat; \n\n     \n}\n\n\n\n\n运行结果及报错内容\n\n\n前面数据间隔还在20ms，后面就出现300ms延迟。\n\n\n我的解答思路和尝试过的方法\n\n\n关闭其他所有中断，尝试只用串口中断连续发送数据，也会周期性出现300ms延迟。\n\n\n我想要达到的结果\n\n\n在不使用DMA情况下，实现C8051F020连续发送数据，要求数据间隔保存在20~30ms。", "Tag": "算法分析"}
{"Answer": "", "Konwledge_Point": "模运算", "Question": "ptthon词云图最简单的结果\n文件如下\n\n\nPython学习总结\n   通过学习计算思维这门学科，我得以进入一个完全不同的世界，数码的世界，编程的世界。计算思维这么学科带我认识了Python，从中我又知道电脑是如何运作，对于电脑运行以及数码世界有了浅薄的认知。\n　　同时在python学习中，我知道了列表、字典、函数、类、对象等等，每一个看起来简单的词语的背后都是一套独有的思维方式，而也这些这一个个特有的“元素”汇聚成了Python语言这门课程，学习时间虽然很短，但是获得的知识是无穷的。每一节课堂内容的背后，我相信都是无数人知识、思维甚至是语言的集合，真的很感谢这门语言带给我的乐趣。下面是我的一些学习总结。\n　　学习中的第一个难点，就是循环逻辑的建构。Python的循环结构分为两种。分别是while和for循环。For 循环一般用于有限次数，while循环而用于未知次数的循环。在学习循环语句时，最大的感受就是逻辑的严密，什么地方要缩进，什么地方要结束，什么语句要置于循环的下方，一步也不能出错，大到逻辑的合理性，小到一个冒号是否添加。哪怕一个地方出现问题，电脑运行都会出现错误或者得出错误结论。在循环中对于列表，字典，元组……都有不同的循环遍历方式，不可以弄混淆。在我看来，循环语句是最考验逻辑严密性的一环了。\n　　接下来学习了函数和列表，元组，字典，集合这些不同键不同的区别以及如何对他们进行操作。下面我简单介绍一些基本操作方法。\n　　列表：列表是Python中使用最频繁的数据类型，集合中可以放任何数据类型，可对集合进行创建、查找、切片、增加、修改、删除、循环和排序操作。与字符串的索引一样，List索引从0开始，list 的数据项可以不同类型，list 的各个元素可以改变，list 是使用 [ ] 方括号包含各个数据项。+ 多个列表进行合并成一个列表 * 列表重复输出多次 in 某个项是否在列表中\n　　  Python中对序列提供了一些统计函数，其中len()函数就是可以获取序列长度的一个统计操作，可以结合range()哈数可以生成一个访问的索引范围，就可以实现循环索引访问列表的操作了。如果需要对列表进行排序或者反转等操作，那么通过索引这种访问就比较方便了。\n　　元组：Python 的元组与列表类似，不同之处在于元组的元素一旦初始化就不能修改。元组使用小括号 ( )，列表使用方括号 [ ]。元组与字符串类似，下标索引从0开始，可以进行截取，组合等。元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用。\n　　元组可以进行访问，修改，删除，索引和截取操作。\n　　字典：字典是一种键值对的集合，列表是有序的对象集合，字典是无序的对象集合。字典是可变容器模型，且可存储任意类型对象字典可以通过键来引用，键必须是唯一的且键名必须是不可改变的（即键名必须为Number、String、元组三种类型的某一种），但值则不必。字典是使用 { } 大括号包含键值对，创建空字典使用 { }\n　　字典可以进行访问，添加，删除和修改功能。dict.keys( ) 以列表返回一个字典所有的键，dict.values( ) 以列表返回字典中的所有值，dict.items( ) 以列表返回可遍历元组数组，以上是字典的几种常见用法。\n　　集合：集合（set）是一个无序的不重复元素序列，它的主要作用有两个，分别是去重和关系测试。\n　　集合的基本用法是集合的去重，增删，判断集合是否存在以及集合的四种基础运算方法。\n　　这学期的计算思维课程让我接触到了一个全新的领域，哲理有着严格的条例，但同时又创造出无限的可能。手指飞快打出几行代码，输出的结果却可以是瑰丽的图形或是精确的数据。以上仅是我的一小段学习总结，但是计算思维这门课对我思维的锻炼，逻辑推理能力的增进，以及使我渐渐养成严谨认真的态度，使我终身受益。", "Tag": "算法分析"}
{"Answer": "有个简单的办法，提前打开任务管理器翻到GPU那一栏，在训练或者预测数据的时候观察各项指标特别是复制有没有起伏", "Konwledge_Point": "模运算", "Question": "jupyter 中tf 搭建神经网络 如何确定自己的GPU参与了计算？\n采用mnist的数据集练习 神经网络分类问题，搭建完模型后的fit过程如下：\n\n\n%%time\nmodel.fit\n(x_train_reshaped,y_train,\nepochs\n = 10,\nbatch_size\n = 64,\n          \nvalidation_data\n = (x_valid_reshaped,y_valid)\n)\n\n# 这里面一定要用reshaped的数据才行\n\n\n\n\n运算结果如下：\n\n\nEpoch \n1\n/\n10\n\n\n938\n/938 [==============================] - 4s 4ms/\nstep\n - loss: \n3.0898\n - sparse_categorical_accuracy: \n0.6319\n - val_loss: \n0.7920\n - val_sparse_categorical_accuracy: \n0.7922\n\nEpoch \n2\n/\n10\n\n\n938\n/938 [==============================] - 3s 4ms/\nstep\n - loss: \n0.6585\n - sparse_categorical_accuracy: \n0.8172\n - val_loss: \n0.5834\n - val_sparse_categorical_accuracy: \n0.8415\n\nEpoch \n3\n/\n10\n\n\n938\n/938 [==============================] - 3s 4ms/\nstep\n - loss: \n0.5044\n - sparse_categorical_accuracy: \n0.8641\n - val_loss: \n0.4774\n - val_sparse_categorical_accuracy: \n0.8803\n\nEpoch \n4\n/\n10\n\n\n938\n/938 [==============================] - 3s 4ms/\nstep\n - loss: \n0.4253\n - sparse_categorical_accuracy: \n0.8852\n - val_loss: \n0.3929\n - val_sparse_categorical_accuracy: \n0.8931\n\nEpoch \n5\n/\n10\n\n\n938\n/938 [==============================] - 4s 4ms/\nstep\n - loss: \n0.3789\n - sparse_categorical_accuracy: \n0.8986\n - val_loss: \n0.3681\n - val_sparse_categorical_accuracy: \n0.9028\n\nEpoch \n6\n/\n10\n\n\n938\n/938 [==============================] - 4s 4ms/\nstep\n - loss: \n0.3455\n - sparse_categorical_accuracy: \n0.9064\n - val_loss: \n0.3584\n - val_sparse_categorical_accuracy: \n0.9103\n\nEpoch \n7\n/\n10\n\n\n938\n/938 [==============================] - 3s 4ms/\nstep\n - loss: \n0.3146\n - sparse_categorical_accuracy: \n0.9131\n - val_loss: \n0.3123\n - val_sparse_categorical_accuracy: \n0.9160\n\nEpoch \n8\n/\n10\n\n\n938\n/938 [==============================] - 3s 4ms/\nstep\n - loss: \n0.2925\n - sparse_categorical_accuracy: \n0.9198\n - val_loss: \n0.3075\n - val_sparse_categorical_accuracy: \n0.9169\n\nEpoch \n9\n/\n10\n\n\n938\n/938 [==============================] - 4s 4ms/\nstep\n - loss: \n0.2782\n - sparse_categorical_accuracy: \n0.9214\n - val_loss: \n0.3440\n - val_sparse_categorical_accuracy: \n0.9157\n\nEpoch \n10\n/\n10\n\n\n938\n/938 [==============================] - 4s 4ms/\nstep\n - loss: \n0.2652\n - sparse_categorical_accuracy: \n0.9247\n - val_loss: \n0.3154\n - val_sparse_categorical_accuracy: \n0.9147\n\nWall time: \n35.9\n s\n\n\n\n我想问在这个过程中GPU 有没有参与计算？ 如果没有，怎样设置才可以GPU 参与计算，在这之前我也将CUDA 显卡驱动什么的都装好了。\n数据量测试集是 60000\n784 验证集是10000\n784.", "Tag": "算法分析"}
{"Answer": "找一个查看dll依赖的程序看看依赖性，把需要的外dll都放在一起。如果想隐蔽一点，就把它加进自己的dll里面，在网上找个动态加载内存中的dll的代码，这样就不用加载实体dll了，用户也看不见你调用了什么。", "Konwledge_Point": "模运算", "Question": "c++ 类打包dll  含第三方依赖\n写了一个基于opencv的算法，会用到opencv的Net、Mat等类型和函数，大概是几个个接口用来接受参数路径，把读取net放在了循环之外因此private中含有Net类型，参考了dllexport但是头文件类的声明有mat、net存在仍然需要拷贝opencv的所有东西和环境\n现需要使用ocr::rec函数以及读取模型的readmodel函数，输入图像返回运算图像\n将它打包成一个dll交付给他人使用应该如何做到，纯虚函数是否可行，请教具体方法？\n目前头文件如下\n\n\n#\npragma\n once\n\n\n\n#\nifdef\n _DLL_EXPORTS\n\n\n#\ndefine\n DLL_API _declspec(dllexport)\n\n\n#\nelse\n\n\n#\ndefine\n DLL_API _declspec(dllimport)\n\n\n#\nendif\n\n\n#\ninclude\n \n\n  \n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n\n#\nifndef\n INTERFACE_DEFINE_AND_REALIZE\n\n\n#\ndefine\n INTERFACE_DEFINE_AND_REALIZE\n\n\n#\ninclude\n \n\n\n\nusing\n std::string;\n\n//define interface\n\n\n\nusing\n \nnamespace\n std;\n\nusing\n \nnamespace\n cv;\n\nusing\n \nnamespace\n dnn;\n\n\nclass\n \n_declspec\n(dllexport) ocr\n{\n\nprivate\n:\n    \nint\n crop_mode = \n1\n;\n    \nint\n thresh_mode=\n1\n;\n    \nint\n bitwise_mode2 = \n0\n;\n    \ndouble\n blur1 = \n3\n;\n    \ndouble\n blur2 = \n11\n;\n    \n//int rect_morph_x;\n\n    \n//int rect_morph_y;\n\n    \nint\n morph_x = \n1\n;\n    \nint\n morph_y = \n9\n;\n    \nint\n iteration = \n1\n;\n    \nint\n canny_max = \n300\n;\n    \nint\n min_width = \n8\n;\n    \nint\n i;\n//高斯模糊\n\n    \nint\n flag;\n    \nint\n flag2;\n    string model_path = \n\"./1.onnx\"\n;\n    Net net;                            \n//此处为opencv的net类型\n\n    \nint\n rect_thresh = \n0\n;\n    \nint\n blocksize = \n31\n;\n    \nint\n C = \n10\n;\n    \nint\n left = \n0\n;\n    \nint\n right = \n0\n;\n    \nint\n up = \n0\n;\n    \nint\n down = \n0\n;\n\n    \nint\n softmax_thresh;\n\n    \n//block,C,threshold\n\n\n    \n//unsigned char * img\n\n\n\n\npublic\n:\n    \n//void ~ocr(){}\n\n\n    \n//inline\n\n    \nvoid\n \nset_morph\n(\nint\n x, \nint\n y, \nint\n iter)\n\n    \n{\n        morph_x = x;\n        morph_y = y;\n        iteration = iter;\n    }\n    \n    \nvoid\n \nset_blocksize\n(\nint\n x)\n\n    \n{\n        blocksize = x;\n    }\n    \n//inline\n\n    \nvoid\n \nset_net\n(string model_path)\n                       \n    \n{\n        net = cv::dnn::\nreadNetFromONNX\n(model_path);\n    }\n\n    \nvoid\n \nset_rect_thresh\n(\nint\n x)\n\n    \n{\n        rect_thresh = x;\n    }\n\n\n\n    \nvoid\n \nset_C\n(\nint\n x)\n\n    \n{\n        C = x;\n    }\n\n    \nvoid\n \nset_canny_max\n(\nint\n x)\n\n    \n{\n        canny_max = x;\n    }\n\n    \nvoid\n \nset_abcd\n(\nint\n x, \nint\n y, \nint\n z, \nint\n f)\n\n    \n{\n        up = x;\n        down = y;\n        left = z;\n        right = f;\n    }\n\n    \nvoid\n \nset_min_width\n(\nint\n x)\n\n    \n{\n        min_width = x;\n    }\n\n    \nvoid\n \nset_softmax_thresh\n(\nint\n x)\n\n    \n{\n        softmax_thresh = x;\n    }\n\n    \nvoid\n \nload_model\n(\nconst\n string model_path, Net &net)\n;\n//Net net\n\n\n    \nvoid\n \nchar2mat\n(\nunsigned\n \nchar\n* cimg, Mat &mat, \nint\n h, \nint\n w, \nint\n channel)\n;\n\n    \nvoid\n \nrotate\n(Mat &frame)\n;\n\n    \nvoid\n \nundistort\n(Mat &frame)\n;\n\n    \nvoid\n \nfind_rect\n(cv::Mat& frame, Mat &dst, Point &startpoint, \nint\n rect_thresh, \nint\n rect_morph_x = \n1\n, \nint\n rect_morph_y = \n1\n, \nint\n operation = \n0\n, \nint\n erosion_elem = \n0\n, \nint\n iteration = \n1\n)\n;\n\n    \nvoid\n \ngetthresh\n(Mat &frame, \nint\n thresh1, \nint\n thresh3, \nint\n bitwise_mode = \n0\n, \nint\n thresh_mode = \n0\n, \nint\n blocksize = \n35\n, \nint\n C = \n29\n, \nint\n i = \n7\n)\n;\n\n    \nvoid\n \ncanny_crop\n(Mat &frame, Mat &output, vector<\nint\n>&result, vector<\ndouble\n>&softmax, \nint\n &flag2, Net net, vector &digit_rect, \nint\n bitwise_mode2, \nint\n morph_x = \n1\n, \nint\n morph_y = \n9\n, \n//9\n\n        \nint\n iteration = \n1\n, \nint\n padding = \n0\n, \nint\n canny_max = \n300\n)\n;\n\n    \nvoid\n \nvertical_crop\n(Mat &frame)\n;\n\n    \n//blobfromimages\n\n\n    \nvoid\n \nrec_single\n(Mat &img, \nint\n #, \nfloat\n &prob, \nint\n &flag2, Net net, \nfloat\n scale = \n1.0\n / \n255\n)\n;\n\n    \nvoid\n \nfindSquares\n(Mat &frame, Mat &out)\n;\n\n    \nvoid\n \nSortRotatedRectPoints\n(Point2f vetPoints[], RotatedRect ▭, \nint\n flag)\n;\n\n    \n//void thinimage(Mat &srcimage);\n\n    \nvoid\n \nthinimage\n(Mat &input_src, Mat & output_dst, \nint\n number = \n1\n)\n;\n    \nMat \nImgSkeletonization_H\n(Mat &input_src, \nint\n *search_arr)\n;\n    \nMat \nImgSkeletonization_V\n(Mat &input_src, \nint\n *search_arr)\n;\n\n    \n//int morph_x, int morph_y, a, b, c, d;\n\n    \nvoid\n \nrec\n(Mat &frame, Mat &output, Mat &canny_crop, Mat ▭_crop)\n;\n\n    \nvoid\n \ncrec\n(\nunsigned\n \nchar\n *input, \nunsigned\n \nchar\n *output, \nunsigned\n \nchar\n *rect, \nunsigned\n \nchar\n *threshold, \nunsigned\n \nchar\n *canny)\n;\n//gauss置于morph后\n\n};\n\n#\nendif\n\n\n", "Tag": "算法分析"}
{"Answer": "分页、序号、表单验证这些无论什么管理系统也是不能省的。这不叫什么细节需求。如果这些都没有，恐怕系统连粗制滥造都算不上，只能是个用来学习的例子程序。\r\n我去网络上搜索了一下，一些进销存软件甚至卖到了50多元（Joyo价格）。就算买10家的来试用，结果发现都不合适也比你的便宜。再考虑到因为项目拖延搁浅引发的经济损失，真是不如花几万买现成的。\r\n我不清楚你做了多久应用软件开发了。不过从你现在开发出来的东西看，你现在还不是一个合格的应用程序员，顶多算编程爱好者。建议你好好学习一下，最好作为普通程序员参加几个实际软件开发，再来说是不是有能力去接这类项目。特别是“尝试新技术”这点要不得，拿别人当试验品呢。如果没有足够把握，千万不要胡乱使用自己不熟悉的技术。\r\n你还是尽量帮他们试用一些国内知名的管理软件开发企业的成熟产品（很多都有试用版下载或者可以联系获得试用版），看哪些符合其需求。谈判买下一个合适的现成产品。", "Konwledge_Point": "模运算", "Question": "印刷行业进销存项目，用什么样的框架能开发效率更高学习成本维护成本更低\n之前我也用java+servlet+jsp写过一个鞋材的进销存系统。写得也是很慢，同样一遇到客户的业务逻辑一变，为修改代码而疲于奔命。这时我除了php框架thinkphp，还想到了Spring+Struts+Hibernate等企业级的框架应用。\n\n\n\n然后试图找来php，希望能发挥其敏捷的特性，为我加快开发速度和降低维护成本，做一个服饰连锁店销售管理软件──进货，配送到分店，分店销售，销售报表，管理员权限配置等模块，是从10月份开始的，用的是php原生态写法写的，发觉效率很低。\n\n\n\n另外我去网上搜索了，java做进销存的应用，比php要多很多，那么是不是说明对于数学运算一些的应用，java强类型语言更有优势一些呢？而php流行的应用，多是互联网应用，以内容为主的，而不是数据为主的？\n\n\n\n所以我现在很疑惑，我对java与php的熟练度都差不多，现在这个印刷进销存，包括以后还可能遇到的进销存，同样采用框架的前提下，是用java还是php的框架？另外弱弱的问一话，类似于进销存的应用──我明白离电信级别的应用差很远，那它能称得上企业级应用吗？\n\n\n\n[b]问题补充：[/b]\n\nTO:魔力猫咪\n\n\n\n由于业务流程不熟，经常要改动数据库与业务逻辑。借此问一下，Java没有太多的互联网应用CMS,BBS,SNS,BLOG，这些基于内容的，而php遍地开花，但如果是基于数据运算的，进销存、财务做帐，就php的开源项目不太多了？\n\n[b]问题补充：[/b]\n\nTO:魔力猫咪 II\n\n\"要判断一个应用是哪种程序开发的有时候不是那么好判断的。\"\n\n可能刚才没有表达清楚，不是说从后缀名判断网站是用什么语言去写成的，而是说从网上的开源项目看，互联网应用php居多，discuz,thinksns,dedecms等众cms。而其它“高级”的项目java居多，lucene,OFBiz等。\n\n\n\n应该说业务逻辑不熟，这是双方的原因造成的。\n\n在温州-瑞安这个县级市里，软件开发者与客户对于软件都没有经验。瑞安的it公司以做企业网站为主，技术人员的分工也不明确，因为只有1-3人。客户方面是：在过去，温州的企业主们都是靠手工来记录台帐，企业内部沟通与协同办公则是在家里吃晚饭时一家人在沟通。\n\n\n\n我接到客户说，要做一个管理软件，不用太复杂，最简单的够用就可以，所以这个订单的金额也都很小，1W以内的。一分钱一分货，那么我们就会做得简单些，赶工期；\n\n虽然客户先前说好只要某某功能，只是做的过程中，需求还要不断增加。所谓麻雀虽小，五脏俱全，管理权限，表单验证，敏感字符过滤，日志等等，统统得要。\n\n\n\n依照你的分析，我要做的是，把客户的需求挖掘出来──因为客户自己往往说不清楚，自己的业务流程是怎么样的，软件需要做成什么样，毕竟他们只了解自己的业务。这样要做出一个个性化人性化的管理软件就对双方都提出了要求，因为双方的水平都有限。\n\n[b]问题补充：[/b]\n\n正如你所料,这类小项目已经失败过两回.一个鞋材的软件,开发了一个月时,出现了一些细节上的需求,一些原先我明知需要的但被我阉割的功能.如分页.序号.表单验证.于是这个项目搁浅至今.目前这个印刷的软件也是二次开发了,上次的完全不合他的需求,上次我也向这位老板建议说购买现成系统,他是说用不到那么的功能,不如花同样的钱订制一个小型的系统.我本着尝试下新技术的想法就做了,结果导致了两边都 不讨好.       在温州这个传统制造业发达而信息产业不发达的地区.组建一支技术队伍困难重重,上个月与一位网络公司老板讨论\n\n\n\n[b]问题补充：[/b]\n\nTO 魔力猫咪 IV\n\n讨论瑞安企业的信息化解决方案.瑞安有几千家的小企业.以往他们只做一个宣传型的网站,做一个丢一个,每次一个新单只是换换美工,来年顶多就是收个几百元的域名空间费,这样的做法只够维持公司存活.现在考虑是不是可以再挖掘这些企业的其他需求.从网站建设入手,可以免费试用,按月付费,抢占市场(域名在手上了).然后推销购买来的系统  oa 进销存 做帐   数据全部同步共享 包括前台网站产品数据,     公司从技术向服务转型.他的这种想法是不是就是你说的信息咨询服务?\n\n[b]问题补充：[/b]\n\nTO:魔 V\n\n我是一名非科班出身始于爱好由vb开始的程序员..在零四年起,在校做学生信息,社团网站,参加大学生数模,算起来五年时间,虽然知道语言只是外在的.思想才是一通百通的.然而由于自卑与好奇,希望找到一门适合的万能语言,到处看语言c cpp asp delphi java php .net ,到现在都没有一门自己精通的语言,还是一个新门,很惭愧.\n\n\n\n我知道自己的技术实力远不够,可一直没放弃过自己开发产品去营销的念头,所以经常会向身边搞it的boss讨教.\n\n\n\n我猜想魔目前是prj leader类的职位吧,组织与编写文档多过写代码\n\n[b]问题补充：[/b]\n\nTO:魔 VI\n\n如果选择B/S管理软件，对于我，多少有点基础，从大学业余爱好做的事情到现在的工作，都在做网站。更重要的理由是，我身边市场大环境下，有这个需求。\n\n\n\n其实我是很反感做对数据库CRUD的，更反感在ie,ff,chrome各种浏览间之间调试css,js，好像没有创作的成就感，很崇拜做桌面应用程序，图像处理如PS，播放软件如KMplayer，下载软件如Flashget，装机必备一流的软件如winrar，极品五笔，有那么多用户在用，该是一件多么了不起的事情。\n\n\n\n去年开始盯上了java，这似乎有点万能的味道，嵌入式，b/s,c/s,都能看到它的身影，因为开源氛围比.net强，应用广多了。那个失败的鞋材进销存正是用它写的。只是它对我来说，有点难了。官方的core java几次拿起放下，thinking in java看了两次都停在了泛型那章。上个月买了只G4，换下了我用了2年多的nokia 3250，信誓旦旦地说要在android下写程序，很快又冷却掉了。一是上面说的java对我来说有点难，oo的思想进不了脑，java就是运用不了。二是，没有需求，不知道要做出一个什么软件，才是人们需要用的，再说android market上的太多好的软件都免费了。\n\n[url]\nhttp://it577net.iteye.com/blog/554179[/url]正像我这篇博文里写的，我一直在找方向。首先要养活自己吧，工作与身边的私单，要用到内容管理的东西CMS,B/S数据库管理软件\n 所以CRUD还是要继续，Java 或 Android放在兴趣爱好的位置吧。\n\n[b]问题补充：[/b]\n\nTO:魔 VII\n\n感谢魔力猫咪一天来的热心而无私的回复。很多句话都一针见血地说到了我身上的问题，“我感觉你这几年没找到适合自己的技术发展路线，到处乱撞”；也分享了你的开发经验，“业务变更的修改考验的是你的项目组织能力和面向对象设计能力”，“开发不是做几个数据库表，然后直接CRUD就够了的”；提出建议：“与其累死累活做这种谁都不高兴的软件，不如尝试一下信息化咨询实施方面”。\n\n\n\n你提到的两本书《走出软件作坊》、《软件随想录》，已经从CSDN下过来，正在看。这张问答网页我存到了我的硬盘了。虽然你自称不是leader，但程序员不单是技术而有了自己思考认识，足以让我小小的崇拜一下，期待以后我技术长进了再与你讨教切磋。再次感谢魔的启示，最后奉最我全部可用分20分。", "Tag": "算法分析"}
{"Answer": "看darknet的git，解决方案是将cuda升级到11.1，cudnn也升级，才能解决这个卡住的问题，和显卡有点关系", "Konwledge_Point": "模运算", "Question": "在yolov3下训练自己的数据集卡住\n在yolov3下训练自己的数据集卡住\n\n\n我在进行voc数据集的训练，使用yolov3\n并根据这个流程\nhttps://blog.csdn.net/weixin_43818251/article/details/89548583\n\n\ndarknet训练卡住\n我使用命令\n./darknet detector train cfg/voc.data cfg/yolov3-voc.cfg darknet53.conv.74  >>  /home/heying/darknet/scripts/VOCdevkit/VOC2020/traffic_light.log\n\n\n\n\n就是这个终端一直是这样的，这正常吗\n\n\n问题相关代码\n\n\n显卡\n\n\n\n\n使用的cfg/voc.data文件\n\n\nclasses= \n3\n\ntrain  = \n/home/\nheying\n/darknet/\nscripts/\n2020\n_train.txt\nvalid  = \n/home/\nheying\n/darknet/\nscripts/\n2020\n_test.txt\nnames = data/voc2020.names\nbackup = \n/home/\npjreddie\n/backup/\n\n\n\n\n使用的cfg/yolov3-voc.cfg文件\n\n\n[net]\n\n# Testing\n\n \nbatch\n=1\n \nsubdivisions\n=1\n\n# Training        #训练模式 每次前向图片的数目=batch/subdivisions\n\n\n\n\n#关于batch与subdivision：在训练输出中，训练迭代包括8组，\n\n\n#这些batch样本又被平均分成subdivision=8次送入网络参与训练，\n\n\n#以减轻内存占用的压力；batch越大，训练效果越好，subdivision越大，占用内存压力越小\n\n\n# batch=64\n\n\n# subdivisions=16\n\n\n\n\n#网络输入的宽、高、通道数这三个参数中，要求width==height, 并且为32的倍数\n\n\n#大分辨率可以检测到更加细小的物体，从而影响precision\n\n\nwidth\n=416        #只能是32的倍数\n\nheight\n=416\n\nchannels\n=3\n\nmomentum\n=0.9        #动量，影响梯度下降到最优的速度，一般默认0.9\n\ndecay\n=0.0005        #权重衰减正则系数，防止过拟合\n\nangle\n=0            #旋转角度，从而生成更多训练样本\nsaturation = 1.5    #调整饱和度，从而生成更多训练样本\nexposure = 1.5        #调整曝光度，从而生成更多训练样本\n\nhue\n=.1            #调整色调，从而生成更多训练样本\n\n\n\n#学习率决定了权值更新的速度，学习率大，更新的就快，但太快容易越过最优值，\n\n\n#而学习率太小又更新的慢，效率低，一般学习率随着训练的进行不断更改，\n\n\n#先高一点，然后慢慢降低，一般在0.01--0.001\n\n\nlearning_rate\n=0.001\n\n\n\n#学习率控制的参数，在迭代次数小于burn_in时，其学习率的更新有一种方式，大于burn_in时，才采用policy的更新方式\n\n\nburn_in\n=1000\n\n\n\n#迭代次数，1000次以内，每训练100次保存一次权重，1000次以上，每训练10000次保存一次权重\n\nmax_batches = 50200\n\npolicy\n=steps        # 学习率策略，学习率下降的方式\n\nsteps\n=40000,45000    #学习率变动步长\n\n\n#学习率变动因子：如迭代到40000次时，学习率衰减十倍，45000次迭代时，学习率又会在前一个学习率的基础上衰减十倍\n\n\nscales\n=.1,.1\n\n\n\n[convolutional]\n\nbatch_normalize\n=1    #BN\n\nfilters\n=32        #卷积核数目\n\nsize\n=3            #卷积核尺寸\n\nstride\n=1        #做卷积运算的步长\n\n\n\n#如果pad为0,padding由 padding参数指定；\n\n\n#如果pad为1，padding大小为size/2，\n\n\n#padding应该是对输入图像左边缘拓展的像素数量\n\n\npad\n=1\n\nactivation\n=leaky    #激活函数类型\n\n\n# Downsample\n\n【后面的没有修改】\n\n\n\n在卡住的过程中的log文件\n\n\n \nCUDNN_HALF\n=\n1\n\n\n0\n,\n1\n\n\nyolov3\n-voc\n\nnet\n.optimized_memory = \n0\n\n\nmini_batch\n = \n1\n, batch = \n1\n, time_steps = \n1\n, train = \n1\n\n\nCreate\n CUDA-stream - \n0\n\n \nCreate\n cudnn-handle \n0\n\n \nCUDNN_HALF\n=\n1\n\n\n0\n,\n1\n\n\nyolov3\n-voc\n\nnet\n.optimized_memory = \n0\n\n\nmini_batch\n = \n1\n, batch = \n1\n, time_steps = \n1\n, train = \n1\n\n\nCreate\n CUDA-stream - \n0\n\n \nCreate\n cudnn-handle \n0\n\n\n \nseen\n \n64\n, trained: \n0\n K-images (\n0\n Kilo-batches_64)\n\nCUDA\n status Error: file: ./src/dark_cuda.c : () : line: \n38\n : build time: Mar  \n7\n \n2022\n - \n16\n:\n11\n:\n01\n\n\n \nCUDA\n Error: invalid device ordinal\n \nCUDNN_HALF\n=\n1\n\n\n0\n\n\nyolov3\n-voc\n\nnet\n.optimized_memory = \n0\n\n\nmini_batch\n = \n1\n, batch = \n1\n, time_steps = \n1\n, train = \n1\n\n\nCreate\n CUDA-stream - \n0\n\n \nCreate\n cudnn-handle \n0\n\n \nCUDNN_HALF\n=\n1\n\n\n0\n\n\nyolov3\n-voc\n\nnet\n.optimized_memory = \n0\n\n\nmini_batch\n = \n1\n, batch = \n1\n, time_steps = \n1\n, train = \n1\n\n\nCreate\n CUDA-stream - \n0\n\n \nCreate\n cudnn-handle \n0\n\n \nCUDNN_HALF\n=\n1\n\n\nyolov3\n-voc\n\nnet\n.optimized_memory = \n0\n\n\nmini_batch\n = \n1\n, batch = \n1\n, time_steps = \n1\n, train = \n1\n\n\nCreate\n CUDA-stream - \n0\n\n \nCreate\n cudnn-handle \n0\n\n \nCUDNN_HALF\n=\n1\n\n\nyolov3\n-voc\n\nnet\n.optimized_memory = \n0\n\n\nmini_batch\n = \n1\n, batch = \n1\n, time_steps = \n1\n, train = \n1\n\n\nCreate\n CUDA-stream - \n0\n\n \nCreate\n cudnn-handle \n0\n\n \nCUDNN_HALF\n=\n1\n\n\nyolov3\n-voc\n\nnet\n.optimized_memory = \n0\n\n\nmini_batch\n = \n1\n, batch = \n1\n, time_steps = \n1\n, train = \n1\n\n\nCreate\n CUDA-stream - \n0\n\n \nCreate\n cudnn-handle \n0\n\n\n\n\n我的解答思路和尝试过的方法\n\n\n权重文件换成了yolov3.weights也还是卡住\n\n\n\n\n说明\n\n\n使用的voc数据集在我的另一台nvidia AGX 中jetson-inference里训练是正常的，出来的模型识别效果良好\n\n\n使用的主机是英特尔（Intel）NUC11PHKi7CAA幻影峡谷11代酷睿i7RTX2060独显迷你电脑主机\nhttps://item.jd.com/10028216825202.html\n\n\n现在临时想到能够提供的暂时这些，如有解决方案我将不胜感激", "Tag": "算法分析"}
{"Answer": "\n#include <stdio.h>\n//定义结构体类型Range\ntypedef struct _Range {\n    int start, end;\n} Range;\n//获得结构体变量的函数：它表示一个数组中的区间，由起始点和结束点构成\nRange new_Range(int s, int e) {\n    Range r;\n    r.start = s;\n    r.end = e;\n    return r;\n}\n//将x指向的元素和y指向的元素交换顺序：如果基准点左侧某个元素大于基准点且右侧有一个元素小于基准点，交换这两个元素\nvoid swap(int *x, int *y) {\n    int t = *x;\n    *x = *y;\n    *y = t;\n}\n//快速排序的方法\nvoid quick_sort(int arr[], const int len) {\n    if (len <= 0)\n        return; // 避免len等於負值時引發段錯誤（Segment Fault），排除要排序的数组的元素个数为0或负值\n    //技巧： r[]模擬列表,p為數量,r[p++]為push（它先使用,r[--p]為定位到前一个元素并取出该元素\n    Range r[len];//声明待排序数组的元素区间组成的数组，区间个数等于要排序的数组\n    int p = 0;//区间数组的初始索引为0\n    r[p++] = new_Range(0, len - 1);//表示要排序数组从第一个元素到最后一个元素的索引区间，并存入区间数组\n    while (p) {//如果有一个及以上的区间就进入循环直到没有区间循环终止\n        Range range = r[--p];//取出刚存入的待排数组地元素区间\n        if (range.start >= range.end)\n            continue;//但元素区间起始索引大于终了索引，这个区间无效，继续使用下一个元素区间；\n        int mid = arr[(range.start + range.end) / 2]; /* 取出该有效元素区间地中间值对应地元素的值作为基准，\n        该基准将元素区间划分成左右两部分*/\n        int left = range.start, right = range.end;/*有效元素区间的起始值作为左部序列的开始元素索引\n        有效元素区间的终了值作为右部序列的结束元素的索引*/\n\n        do\n        {\n            while (arr[left] < mid) ++left;   /*对基准点左部的元素向右扫描直到左部序列的某个元素大于基准点，\n            这样就将小于基准的元素集中在元素区间的左部，left是向右移动的指针*/\n            while (arr[right] >= mid) --right; /*对基准点右部的元素向左扫描直到右部序列的某个元素小于基准点，\n            将大于或等于基准的元素集中在元素区间的右部，right是向左移动的指针*/\n \n            if (left <= right)/*当左部序列扫描结束之时的元素依然在右部序列扫描结束之时的元素之前*/\n            {\n                swap(&arr[left],&arr[right]);//将左部序列扫描结束之时的元素和右部序列扫描结束之时的元素进行交换\n                left++;right--;               /*接着向右扫描左部序列，向左扫描右部序列，重复上面的步骤*/ \n            }\n        } while (left <= right);/*向右扫描左部序列和向左扫描右部序列直到相遇：相同索引的元素交换彼此的值；之后向\n        右扫描到了右部序列，向左扫描到了左部序列，基准点左部的各元素都小于它，右部的的各元素都大于等于它，循环结束*/\n        if (range.start < right) r[p++] = new_Range(range.start, right);/*上面的工作完成之后，right指针\n        遇到left或者right再left左边紧邻；只是现在将原来元素区间的起始点和right指针现在的位置构成新的元素区间，\n        然后通过一个基准点划分该区间为左部和右部，使得左部序列的元素小于右部序列的元素\n        */\n        if (range.end > left) r[p++] = new_Range(left, range.end);/*上面的工作完成之后，left指针\n        遇到right或者再righ后面与之紧邻；只是现在将left指针现在的元素位置和原来元素区间的终了点构成新的元素区间，\n        然后通过一个基准点划分该区间为左部和右部，使得左部序列的元素小于右部序列的元素*/\n        /*左部序列向右扫描，右部序列向左扫描，肯定会在某个索引处相遇或者错开b，原来的基准在其中的一个区间中，之后从该根据right和left两个索引\n        划分两个区间，存到区间数组中；\n        先完成右部序列的快速排序，再完成左部序列的快速排序，最终能得到数组的排序*/\n    }\n\n}\nint main()\n{\n    int arr[6] ={10,5,9,7,24,18};\n    quick_sort(arr,6);\n    int i;\n    for ( i = 0; i < 6; i++)\n    {\n        printf(\"%d\\n\",arr[i]);\n    }\n    return 0;\n    \n}\n", "Konwledge_Point": "模运算", "Question": "下面迭代法快速排序算法的方法体中有一个地方不明白，该怎样解释呢？\n\n\n//定义结构体类型Range\n\ntypedef \nstruct\n _Range {\n    \nint\n start, \nend\n;\n} Range;\n\n//获得结构体变量的函数：它表示一个数组中的区间，由起始点和结束点构成\n\nRange \nnew\n_Range(\nint\n \ns\n, \nint\n \ne\n)\n {\n    Range r;\n    r.start = s;\n    r.\nend\n = e;\n    return r;\n}\n\n//将x指向的元素和y指向的元素交换顺序：如果基准点左侧某个元素大于基准点且右侧有一个元素小于基准点，交换这两个元素\n\nvoid swap(\nint\n *x, \nint\n *y) {\n    \nint\n t = *x;\n    *x = *y;\n    *y = t;\n}\n\n//快速排序的方法\n\nvoid quick\n_sort(\nint\n \narr\n[], \nconst\n \nint\n \nlen\n)\n {\n    \nif\n (len <= \n0\n)\n        return; \n// 避免len等於負值時引發段錯誤（Segment Fault）\n\n    \n//技巧： r[]模擬列表,p為數量,r[p++]為push（它先使用,r[--p]為定位到前一个元素并取出该元素\n\n    Range r\n[\nlen\n]\n;\n//结构体变量组成的结构体数组：变量个数等于数组元素个数？\n\n    \nint\n p = \n0\n;\n    r\n[\np\n++\n]\n = \nnew\n_Range(0, \nlen\n - 1)\n;\n//存入一个结构体变量：它的成员分别表示区间开始值和结束值\n\n    \nwhile\n (p) {\n//存入一个结构体变量之后p的值变成1，此时条件成立\n\n        Range range = r\n[--\np\n]\n;\n//取出结构体数组种存入的结构体变量（它表示一个区间)；注意--p是先运算再使用\n\n        \nif\n (range.start >= range.\nend\n)\n            continue;\n//如果取出的开始值大于结束值，则进行下一次循环\n\n        \nint\n mid = arr\n[(\nrange\n.\nstart\n + \nrange\n.\nend\n) \n/\n \n2\n]\n; \n// 满足条件，選取区间中間點对应的元素為基準點\n\n        \nint\n left = range.start, right = range.\nend\n;\n//区间的起始值赋值作为最左端元素的索引，结束值作为最右端元素的索引\n\n\n        \ndo\n\n        {\n            \nwhile\n (arr\n[\nleft\n]\n < mid) ++left;   \n/* 檢測基準點左側是否符合要求，什么要求？检查基准点左侧的第一个元素值是否小于它，满足就把索引加上1继续判断左侧的下一个元素是否小于基准点，直到左侧的某个元素索引值加上1之后对应的元素大于基准点，则循环结束*/\n\n            \nwhile\n (arr\n[\nright\n]\n > mid) --right; \n/*檢測基準點右側是否符合要求，要求：检查基准点右侧的最后一个元素值是否大于它，满足就把索引减去1继续判断右侧的上一个元素是否大于基准点，直到右侧的某个元素索引值减去1之后对应的元素小于基准点，则循环结束*/\n\n \n            \nif\n (left <= right)\n/*只有这样前面给left和right的赋值才有意义；上面两个循环都得进入，只要有不满足的\n            元素，就将它们的值交换，但交换后的元素有可能小于他前面已经判断的元素（左侧），但交换后的元素有可能大于他后面已经判断的元素（右侧），这是确定的，因为上面并未判断基准点左侧和右侧的元素的顺序*/\n\n            {\n                swap(&arr\n[\nleft\n]\n,&arr\n[\nright\n]\n);\n                left++;right--;               \n/*移動指針以繼續。继续什么：判断左侧的下一个元素和右侧的上一个元素是否是否在小于基准点或大于基准点*/\n \n            }\n        } \nwhile\n (left <= right);\n/*当数组有奇数个元素时可能出现相等（等于中间元素的索引）的情况:此时直接执行到if语句块，交换后left > right，如果是偶数个元素则最终出现的是left>right;do-while循环结束；do-while循环保证了当前基准点左侧（部）的元素小于基准点，右侧（部）的元素大于基准点\n        */\n\n        \nif\n (range.start < right) r\n[\np\n++\n]\n = \nnew\n_Range(\nrange\n.\nstart\n, \nright\n)\n;\n/*right经过do...while循环后已经是小于基准点的索引了，如果此时区间的起始值还小于它，那就在原来基准的左侧再建立一个区间（Range对象），存入结构体数组，*/\n\n        \nif\n (range.\nend\n > left) r\n[\np\n++\n]\n = \nnew\n_Range(\nleft\n, \nrange\n.\nend\n)\n;\n/*left经过do...while循环后已经是大于基准点的索引了，如果此时区间的结束值还大于它，那就在原来基准的右侧再建立一个新的区间（Range对象），也存入结构体数组*/\n\n        \n/*如果两个条件都满足那么结构体数组岂不是右两个Range变量：r[0],r[1];且进入while循环中的p就等于2，用r[--p]取出来的是r[1]对应原基准点右侧（右部）的一个区间，下面将使用while循环来使得该索引区间中通新的基准点左侧都是小于它的元素，右侧都是大于它的元素；那么r[0]怎么办？原来基准点左侧的新的区间中的元素并没有被基准点分到小的在新的基准点左侧大的在新基准点基准点右侧，如果条件还满足的化这个工作还没有做就将新的基准点左侧和右侧又分别建立一个区间，这样一来第一次划分基准点之后左侧的元素继续划分区间就省略了，怎么最终得到正确的排序呢？*/\n\n    }\n}\n\n\n\n最后两个if语句如果同时满足条件该怎样继续进行下面的while循环才能达到快速排序的算法要求？", "Tag": "算法分析"}
{"Answer": "一般HTTP接口传输字符串都是utf8编码，转换成unicode再显示\nWCHAR wbuf[512];\nMultiByteToWideChar(CP_UTF8, 0, 源字符串, -1, wbuf, 512);\nMessageBox(wbuf, L\"标题\", MB_OK);\n", "Konwledge_Point": "模运算", "Question": "从服务器获取数据，输出显示中文乱码&winsock的使用\n本人刚接触网络编程不久，想用mfc做一个查询手机号归属地的小工具，已经找到了api接口，http-get请求也已经实现了，代码中的buffer变量就是返回的字符串，我试着把buffer打印到文件中，发现一切正常，汉字也能正常显示，但是当我把字符串用messagebox输出就会显示乱码，从网上找了各种各样的解决办法，包括转换编码，字符串格式等等，但都不起作用，求一个解决方案\n\n\n下面是对话框cpp的代码（尝试处理字符串的部分已经注释掉）\n\n\n\n\n#\ninclude\n \n\"pch.h\"\n\n\n#\ninclude\n \n\"framework.h\"\n\n\n#\ninclude\n \n\"ToolKits.h\"\n\n\n#\ninclude\n \n\"ToolKitsDlg.h\"\n\n\n#\ninclude\n \n\"afxdialogex.h\"\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\npragma\n comment (lib, \n\"ws2_32.lib\"\n)\n\n\nusing\n \nnamespace\n std;\n\n\n#\nifdef\n _DEBUG\n\n\n#\ndefine\n new DEBUG_NEW\n\n\n#\nendif\n\n\n\n\n// 用于应用程序“关于”菜单项的 CAboutDlg 对话框\n\n\n\nclass\n \nCAboutDlg\n : \npublic\n CDialogEx\n{\n\npublic\n:\n    \nCAboutDlg\n();\n\n\n// 对话框数据\n\n\n#\nifdef\n AFX_DESIGN_TIME\n\n    \nenum\n { IDD = IDD_ABOUTBOX };\n\n#\nendif\n\n\n    \nprotected\n:\n    \nvirtual\n \nvoid\n \nDoDataExchange\n(CDataExchange* pDX)\n;    \n// DDX/DDV 支持\n\n\n\n// 实现\n\n\nprotected\n:\n    \nDECLARE_MESSAGE_MAP\n()\n};\n\nCAboutDlg::\nCAboutDlg\n() : \nCDialogEx\n(IDD_ABOUTBOX)\n{\n}\n\n\nvoid\n \nCAboutDlg::DoDataExchange\n(CDataExchange* pDX)\n\n\n{\n    CDialogEx::\nDoDataExchange\n(pDX);\n}\n\n\nBEGIN_MESSAGE_MAP\n(CAboutDlg, CDialogEx)\n\nEND_MESSAGE_MAP\n()\n\n\n\n// CToolKitsDlg 对话框\n\n\n\n\nCToolKitsDlg::\nCToolKitsDlg\n(CWnd* pParent \n/*=nullptr*/\n)\n    : \nCDialogEx\n(IDD_TOOLKITS_DIALOG, pParent)\n{\n    m_hIcon = \nAfxGetApp\n()->\nLoadIcon\n(IDR_MAINFRAME);\n}\n\n\nvoid\n \nCToolKitsDlg::DoDataExchange\n(CDataExchange* pDX)\n\n\n{\n    CDialogEx::\nDoDataExchange\n(pDX);\n}\n\n\nBEGIN_MESSAGE_MAP\n(CToolKitsDlg, CDialogEx)\n    \nON_WM_SYSCOMMAND\n()\n    \nON_WM_PAINT\n()\n    \nON_WM_QUERYDRAGICON\n()\n    \nON_EN_CHANGE\n(IDC_EDIT1, &CToolKitsDlg::OnEnChangeEdit1)\n    \nON_BN_CLICKED\n(IDC_BUTTON1, &CToolKitsDlg::OnBnClickedButton1)\n\nEND_MESSAGE_MAP\n()\n\n\n\n// CToolKitsDlg 消息处理程序\n\n\n\nBOOL \nCToolKitsDlg::OnInitDialog\n()\n\n\n{\n    CDialogEx::\nOnInitDialog\n();\n\n    \n// 将“关于...”菜单项添加到系统菜单中。\n\n\n    \n// IDM_ABOUTBOX 必须在系统命令范围内。\n\n    \nASSERT\n((IDM_ABOUTBOX & \n0xFFF0\n) == IDM_ABOUTBOX);\n    \nASSERT\n(IDM_ABOUTBOX < \n0xF000\n);\n\n    CMenu* pSysMenu = \nGetSystemMenu\n(FALSE);\n    \nif\n (pSysMenu != \nnullptr\n)\n    {\n        BOOL bNameValid;\n        CString strAboutMenu;\n        bNameValid = strAboutMenu.\nLoadString\n(IDS_ABOUTBOX);\n        \nASSERT\n(bNameValid);\n        \nif\n (!strAboutMenu.\nIsEmpty\n())\n        {\n            pSysMenu->\nAppendMenu\n(MF_SEPARATOR);\n            pSysMenu->\nAppendMenu\n(MF_STRING, IDM_ABOUTBOX, strAboutMenu);\n        }\n    }\n\n    \n// 设置此对话框的图标。  当应用程序主窗口不是对话框时，框架将自动\n\n    \n//  执行此操作\n\n    \nSetIcon\n(m_hIcon, TRUE);            \n// 设置大图标\n\n    \nSetIcon\n(m_hIcon, FALSE);        \n// 设置小图标\n\n\n    \n// \nTODO:\n 在此添加额外的初始化代码\n\n    \nsetlocale\n(LC_ALL, \n\"chs\"\n);\n\n\n    \nreturn\n TRUE;  \n// 除非将焦点设置到控件，否则返回 TRUE\n\n}\n\n\nvoid\n \nCToolKitsDlg::OnSysCommand\n(UINT nID, LPARAM lParam)\n\n\n{\n    \nif\n ((nID & \n0xFFF0\n) == IDM_ABOUTBOX)\n    {\n        CAboutDlg dlgAbout;\n        dlgAbout.\nDoModal\n();\n    }\n    \nelse\n\n    {\n        CDialogEx::\nOnSysCommand\n(nID, lParam);\n    }\n}\n\n\n// 如果向对话框添加最小化按钮，则需要下面的代码\n\n\n//  来绘制该图标。  对于使用文档/视图模型的 MFC 应用程序，\n\n\n//  这将由框架自动完成。\n\n\n\nvoid\n \nCToolKitsDlg::OnPaint\n()\n\n\n{\n    \nif\n (\nIsIconic\n())\n    {\n        \nCPaintDC \ndc\n(\nthis\n)\n; \n// 用于绘制的设备上下文\n\n\n        \nSendMessage\n(WM_ICONERASEBKGND, \nreinterpret_cast\n(dc.\nGetSafeHdc\n()), \n0\n);\n\n        \n// 使图标在工作区矩形中居中\n\n        \nint\n cxIcon = \nGetSystemMetrics\n(SM_CXICON);\n        \nint\n cyIcon = \nGetSystemMetrics\n(SM_CYICON);\n        CRect rect;\n        \nGetClientRect\n(▭);\n        \nint\n x = (rect.\nWidth\n() - cxIcon + \n1\n) / \n2\n;\n        \nint\n y = (rect.\nHeight\n() - cyIcon + \n1\n) / \n2\n;\n\n        \n// 绘制图标\n\n        dc.\nDrawIcon\n(x, y, m_hIcon);\n    }\n    \nelse\n\n    {\n        CDialogEx::\nOnPaint\n();\n    }\n}\n\n\n//当用户拖动最小化窗口时系统调用此函数取得光标\n\n\n//显示。\n\n\nHCURSOR \nCToolKitsDlg::OnQueryDragIcon\n()\n\n\n{\n    \nreturn\n \nstatic_cast\n(m_hIcon);\n}\n\n\n\n\nvoid\n \nCToolKitsDlg::OnEnChangeEdit1\n()\n\n\n{\n    \n// \nTODO:\n  如果该控件是 RICHEDIT 控件，它将不\n\n    \n// 发送此通知，除非重写 CDialogEx::OnInitDialog()\n\n    \n// 函数并调用 CRichEditCtrl().SetEventMask()，\n\n    \n// 同时将 ENM_CHANGE 标志“或”运算到掩码中。\n\n\n    \n// \nTODO:\n  在此添加控件通知处理程序代码\n\n}\n\n\n\nvoid\n \nCToolKitsDlg::OnBnClickedButton1\n()\n\n\n{\n    \n// \nTODO:\n 在此添加控件通知处理程序代码\n\n    CString mobile;\n    \nGetDlgItem\n(IDC_EDIT1)->\nGetWindowTextW\n(mobile);\n    \nMessageBox\n(mobile, \n0\n, \n0\n);\n    \nchar\n* get_ret = \nhttp_get_mobile\n(mobile);\n    \nchar\n* errp = \n\"ERROR\"\n;\n    \nif\n (\nstrcmp\n(errp, get_ret) == \n0\n)\nreturn\n;\n//判断是否返回ERROR，是则退出不解析\n\n    \n\n}\n\n\nchar\n* \nCToolKitsDlg::http_get_mobile\n(CString moblie)\n\n\n{\n\n    \ntry\n\n    {\n        \n// 创建Internet连接\n\n        CInternetSession session;\n        \n// 发送GET请求\n\n        CHttpFile* file = (CHttpFile*)session.\nOpenURL\n(\n            _T(\n\"https://www.mxnzp.com/api/mobile_location/aim_mobile?mobile=1867800xxxx&app_id=lhkplhpxmxxxxx&app_secret=TE4zSWx0UG5MZXxxxxxxxxVDM1IrQT09\"\n),\n            \n1\n, INTERNET_FLAG_SECURE);\n        \n// 读取服务器的响应\n\n        \nchar\n buffer[\n512\n];\n                \n//    /*int nLen = MultiByteToWideChar(CP_ACP, 0, buffer, -1, NULL, 0);\n\n        \n//    wchar_t* szWide = new wchar_t[nLen];\n\n        \n//    MultiByteToWideChar(CP_ACP, 0, buffer, -1, szWide, nLen);\n\n        \n//    CString str(szWide);\n\n        \n//    delete[] szWide;\n\n        \n//    ofstream ofile;\n\n        \n//    ofile.open(L\"out.txt\");\n\n        \n//    ofile << buffer << endl;\n\n        \n//    ofile.close();\n\n        \n//    MessageBox(str, L\"str\", 0);*/\n\n        \n//    char* output;\n\n        \n//    int len;\n\n        \n//    wchar_t* out = (wchar_t*)malloc(len * sizeof(wchar_t));\n\n        \n//    len = MultiByteToWideChar(CP_ACP, 0, buffer, -1, out, strlen(buffer));\n\n        \n//    WideCharToMultiByte(CP_UTF8, 0, out, wcslen(out), output, len, NULL, NULL);\n\n        \n//    int len1 = strlen(output);\n\n        \n//    int wlen = MultiByteToWideChar(CP_UTF8, 0, output, len1, NULL, 0);\n\n        \n//    wchar_t* wstr = new wchar_t[wlen + 1];\n\n        \n//    MultiByteToWideChar(CP_UTF8, 0, output, len1, wstr, wlen);\n\n        \n//    wstr[wlen] = 0;\n\n        \n//    CString str(wstr);\n\n        \n//    delete[] wstr;\n\n                \n//      MessageBox(str);\n\n\n        }\n        \n// 关闭文件并结束Internet连接\n\n        file->\nClose\n();\n        session.\nClose\n();\n    }\n    \ncatch\n (CInternetException* e)\n    {\n        CString err;\n        err.\nFormat\n(\nL\"Internet exception:%d\"\n, e->m_dwError);\n        \nMessageBox\n(err);\n        e->\nDelete\n();\n    }\n\n    \nreturn\n \nnullptr\n;\n}\n\n\n\n\n还有一个问题就是：我在这个项目中使用winsock库发送get请求总是不成功，当我连接到目标服务器的80接口时，返回信息提示301 moved permanently；当我连接到443端口，又会提示400 The plain HTTP request was sent to HTTPS port，而用CInternetSession类发送GET请求就能成功，这是啥原因？", "Tag": "算法分析"}
{"Answer": "这样写：\n \n#include <stdio.h>\nint main(void)\n{\n    int Fixed_value, Random_value;//固定值， 随机值//\n    int value;\n    \n    printf(\" This program computes moduli.\\n\");\n    printf(\"Enter an integer to serve as the second operand:\" );\n    scanf_s(\"%d\", &Fixed_value);\n    printf(\"Now enter the first operand:\");\n    scanf_s(\"%d\", &Random_value);\n    printf(\"%d %% %d is %d\\n\", Random_value, Fixed_value,\n        value, value = Random_value % Fixed_value);\n \n    while (1)\n    {        \n        printf(\"Enter next number for first operand(<=0 to quit):\");\n        scanf_s(\"%d\", &Random_value);\n        if (Random_value <= 0) break;\n        printf(\"%d %% %d is %d\\n\", Random_value, Fixed_value, value,\n            value = Random_value % Fixed_value); \n    }\n    printf(\"Done\\n\");\n    return 0;\n}\n\n", "Konwledge_Point": "模运算", "Question": "输入0，不输出0 % 256 is 0\n题目：\n编写一个程序，显示求模运算的结果。把用户输入的1个整数作为求模运算符的第2个运算对象，该数在运算过程中保持不变。\n用户后面输入的数是第1个运算对象。当用户输入一个非正值时，程序结束。\n\n\n\n\n#include \n\n\nint\n main(void)\n{\n    \nint\n Fixed_value, Random_value;\n//\n固定值， 随机值//\n    \nint\n value;\n    \n    \nprintf\n(\n\" This program computes moduli.\\n\"\n);\n    \nprintf\n(\n\"Enter an integer to serve as the second operand:\"\n );\n    scanf_s(\n\"%d\"\n, &Fixed_value);\n    \nprintf\n(\n\"Now enter the first operand:\"\n);\n    scanf_s(\n\"%d\"\n, &Random_value);\n    \nprintf\n(\n\"%d %% %d is %d\\n\"\n, Random_value, Fixed_value,\n        value, value = Random_value % Fixed_value);\n\n    \nwhile\n (Random_value > \n0\n)\n    {\n        \n        \nprintf\n(\n\"Enter next number for first operand(<=0 to quit):\"\n);\n        scanf_s(\n\"%d\"\n, &Random_value);\n        \nprintf\n(\n\"%d %% %d is %d\\n\"\n, Random_value, Fixed_value, value,\n            value = Random_value % Fixed_value);\n\n    }\n    \nprintf\n(\n\"Done\\n\"\n);\n    \nreturn\n \n0\n;\n}\n\n\n\n我的代码输入结果：\n\n\n This program computes moduli.\nEnter \nan\n integer \nto\n serve \nas\n the second operand:\n256\n\nNow enter the \nfirst\n operand:\n438\n\n\n438\n % \n256\n \nis\n \n182\n\nEnter \nnext\n \nnumber\n \nfor\n \nfirst\n operand(<=\n0\n \nto\n \nquit\n):\n1234567\n\n\n1234567\n % \n256\n \nis\n \n135\n\nEnter \nnext\n \nnumber\n \nfor\n \nfirst\n operand(<=\n0\n \nto\n \nquit\n):\n0\n\n\n0\n % \n256\n \nis\n \n0\n\nDone\n\n\n\n\n正确答案是：\n\n\n This program computes moduli.\nEnter \nan\n integer \nto\n serve \nas\n the second operand:\n256\n\nNow enter the \nfirst\n operand:\n438\n\n\n438\n % \n256\n \nis\n \n182\n\nEnter \nnext\n \nnumber\n \nfor\n \nfirst\n operand(<=\n0\n \nto\n \nquit\n):\n1234567\n\n\n1234567\n % \n256\n \nis\n \n135\n\nEnter \nnext\n \nnumber\n \nfor\n \nfirst\n operand(<=\n0\n \nto\n \nquit\n):\n0\n\nDone\n\n\n\n\n输入：0\n是没有  0 % 256 is 0", "Tag": "算法分析"}
{"Answer": "EIGEN是不是需要初始化，在dllmain里面初始化下还有dll连同EIGEN的那些文件都要拷贝给调用者还有32bit 64bit不能混合", "Konwledge_Point": "模运算", "Question": "DLL动态链接库调用外部库报错\n#问题现状：\n使用Visual studio编辑C++代码，并生成DLL动态链接库发送到模型软件中做外部控制器，此时可以正常使用；\n在C++代码中增加关于EIGEN库的内容，生成DLL送进模型中运算就报错了。\n\n\n#\ninclude\n \n\n \n\n\n#\ninclude\n \n\n \n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\nusing\n \nnamespace\n std;\n\n#\ndefine\n NINT(a) ((a) >= 0.0 ? (int)((a)+0.5) : (int)((a)-0.5))\n\n\nextern\n \n\"C\"\n \n//avoid mangled names \n\n{ \nvoid\n __declspec(dllexport) \n__cdecl \nDISCON\n(\nfloat\n* avrSwap, \nint\n* aviFail,\n    \nchar\n* accInfile, \nchar\n* avcOutname, \nchar\n* avcMsg)\n;\n}\n\n//Main DLL routine \n\n\nvoid\n __declspec(dllexport) \n__cdecl \nDISCON\n(\nfloat\n* avrSwap, \nint\n* aviFail, \nchar\n* accInfile, \nchar\n* avcOutname, \nchar\n* avcMsg)\n\n\n{\n    Eigen::MatrixXd M;\n    M << \n0\n, \n0\n,\n         \n0\n, \n0\n;\n    std::cout << M << std::endl;\n    \nreturn\n;\n}\n", "Tag": "算法分析"}
