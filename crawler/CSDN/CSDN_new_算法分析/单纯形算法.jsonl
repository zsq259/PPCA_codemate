{"Answer": "单纯形法？这里有vb的，稍微修改应该就可以用了。\r\nhttps://download.csdn.net/download/a875566272/3116694?web=web\r\nhttps://download.csdn.net/download/jiangjason1988/2342205?web=web", "Konwledge_Point": "单纯形算法", "Question": "重赏！使用EXCEL的VB代码，如何把线性规划的单纯行法带出来\n使用EXCEL界面可以求解线性规划最优解相关的问题，我现在就是想问问如何在VB编辑页面直接调用这个单纯形法求解线性规划的函数？", "Tag": "算法分析"}
{"Answer": "我没有看你的代码，但我知道你问题出在哪你小球的函数只应该规定小球出现在哪，而不应该有任何绘制的代码绘制应该是根据人物的位置、视野、视野里能看到的东西，统一进行绘制，而不是每个函数绘制自己的东西", "Konwledge_Point": "单纯形算法", "Question": "一个程序被新加入的函数图层覆盖了怎么办\n呃，鄙人想做一个迷宫小程序，但觉得单纯的迷宫没有什么意思，想在程序中加入一个弹射的小球ghost，使游戏角色碰到产生一定的效果，问题就是我写好ghost函数之后整个游戏画面会被覆盖掉，而不是共存，所以想来请教一下各位。\n\n\n这是本来的程序：\n\n\n这是加了ghost后：\n\n\n\n\n源码：\n\n\n//1.程序与处理包括加载头文件，定义常量和函数，进行初始化工作\n\n\n#\nundef\n UNICODE\n\n\n#\nundef\n _UNICODE\n\n\n#\ndefine\n _CRT_SECURE_NO_WARNINGS\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n\n//*music\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\npragma\n comment(lib,\n\"Winmm.lib\"\n)\n\n\nusing\n std::stack;            \n// 使用STL的栈的声明\n\n\nusing\n std::vector;            \n// 使用STL的数组容器封装动态大小数组的序列容器；\n\n\n\n\n// 游戏信息（每一行每一列宽度为32像素）\n\n\n#\ndefine\n WIN_WIDTH    900    \n// 窗口的宽度(单位：像素)\n\n\n#\ndefine\n WIN_HEIGHT    500        \n// 窗口的高度(单位：像素)\n\n\n// !!注：由于随机生成算法的原因，地图宽高只能为奇数https://zhuanlan.zhihu.com/p/30724817\n\n\n\n#\ndefine\n GAME_WIDTH    41        \n// 地图的宽度(单位：块)\n\n\n#\ndefine\n GAME_HEIGHT    31    \n// 地图的高度(单位：块)\n\n\n\n#\ndefine\n WALL        1            \n// 墙壁的数字标记，用于判断\n\n\n#\ndefine\n GROUND        0            \n// 地面的数字标记，用于判断\n\n\n#\ndefine\n FILLSTATE    2            \n// 加油站的数字标记，用于判断\n\n\n#\ndefine\n ENDPOS        3            \n// 终点的数字标记，用于判断\n\n\n\n#\ndefine\n MAXVIEW        8.0            \n// 最大的视野\n\n\n#\ndefine\n MINVIEW        1            \n// 最小的视野\n\n\n#\ndefine\n FILLNUM        10            \n// 加油站的数量\n\n\n#\ndefine\n DARKTIME    12            \n// 视野下降1图块所需的时间\n\n\n\n// 全局变量列表\n\n\nint\n        g_BlockSize;            \n// 块大小\n\n\nint\n        g_GameMap[GAME_HEIGHT][GAME_WIDTH];    \n// 地图(宽高单位为块)\n\nPOINT    g_EndPos;                \n// 终点位置\n\nPOINT   g_PlayerPos;            \n// 玩家在地图上的位置\n\nPOINT    g_CameraPos;            \n// 摄像机(屏幕左上角)在地图上的位置\n\nIMAGE    g_MapImage;                \n// 地图的图片(由于地图是固定的，在不改变缩放的情况下只需要绘制一次)\n\n\ndouble\n    g_ViewArray;            \n// 视野\n\nUINT    g_BeginTime;            \n// 游戏开始时的时间\n\nUINT    g_LastFillTime;            \n// 上次为油灯加油的时间\n\n\n\n\n// 函数列表\n\n\nvoid\n \ninitGame\n()\n;                \n// 初始化游戏\n\n\nvoid\n \nendGame\n()\n;                    \n// 结束游戏\n\n\nvoid\n \ndraw\n()\n;                    \n// 绘制函数\n\n\nbool\n \nupDate\n()\n;                    \n// 数据更新函数\n\n\nvoid\n \nabsDelay\n(\nint\n delay)\n;        \n// 绝对延迟\n\n\n\nbool\n \ncanMove\n(POINT pos)\n;        \n// 判断某个位置是否可以移动\n\n\nvoid\n \ncomputeCameraPos\n()\n;        \n// 计算摄像机在地图上的位置\n\n\nvoid\n \nrePaintMap\n()\n;                \n// 重绘地图\n\n\n\nvoid\n \ndrawWall\n(POINT pos)\n;        \n// 绘制墙壁图块的函数\n\n\nvoid\n \ndrawGround\n(POINT pos)\n;        \n// 绘制地面图块的函数\n\n\nvoid\n \ndrawFillState\n(POINT pos)\n;    \n// 绘制油灯图块的函数\n\n\nvoid\n \ndrawEndPos\n(POINT pos)\n;        \n// 绘制终点\n\n\nvoid\n \ndrawPlayer\n()\n;                \n// 绘制人物的函数\n\n\nvoid\n \ndrawView\n()\n;                \n// 绘制视野\n\n\nvoid\n \nbgm\n()\n;                     \n//背景音乐\n\n\nvoid\n \njiaobu\n()\n;                  \n//脚步声\n\n\n\nvoid\n \nwelcome\n()\n;\n\nvoid\n \nghost\n()\n;\n\n\n//滚轮控制放大缩小\n\n\n//2.主函数，main执行\n\n\nint\n \nmain\n()\n//主函数\n\n\n{\n    \nwelcome\n();\n    \ninitGame\n();\n        \n    \nbgm\n();\n    \n    \nwhile\n (\n1\n)\n    {\n        \n        \nif\n (!\nupDate\n()) \nbreak\n;    \n// 更新\n\n        \n        \ndraw\n();                    \n// 绘制\n\n        \n        \nabsDelay\n(\n16\n);            \n// 绝对延迟 16 毫秒，控制每秒 60 帧\n\n        \n    }\n    \n    \nendGame\n();\n    \nreturn\n \n0\n;\n}\n\n//3.初始化游戏，定义开局视野，随机生成地图，这个算法是先生成了一个点 ，根据这个点去找别的点的位置该模块还引用了其他函数进行初始化游戏：标记终点，确定终点位置，计算摄像机的位置，初始化人的位置，初始化画布等，在main中被引用\n\n\nvoid\n \ninitGame\n()\n// 初始化游戏\n\n\n{\n    g_BlockSize = \n32\n;            \n// 初始图块大小为 32 个像素,这个数越大，人物越小，需要走的路程更多\n\n    \nsrand\n(\nGetTickCount\n());        \n// 标准库中初始化随机数生成的函数\n\n\n    \n// 初始化间隔室\n\n    \nfor\n (\nint\n i = \n0\n; i < GAME_HEIGHT; i++)\n    {\n        \nfor\n (\nint\n j = \n0\n; j < GAME_WIDTH; j++)\n        {\n            \nif\n (i % \n2\n == \n0\n || j % \n2\n == \n0\n)\n//奇数行奇数列设为墙壁    \n\n                g_GameMap[i][j] = WALL;\n            \nelse\n\n                g_GameMap[i][j] = GROUND;\n//偶数行偶数列为地面\n\n        }\n    }\n\n    \n// 随机生成地图(使用深度优先遍历:先输出当前结点，在根据一定的次序去递归查找孩子)\n\n    stack stepStack;        \n// 步骤栈\n\n    vector  stepPoint;    \n// 四周的点\n\n    POINT nowPoint;                \n// 当前步的所在点\n\n    stepStack.\npush\n({ \n1\n,\n1\n });    \n// 写入初始点 (1,1) 作为起点\n\n    nowPoint = { \n1\n,\n1\n };\n    g_GameMap[\n1\n][\n1\n] = \n0xFFFF\n;    \n// 标记这个点\n\n    \nwhile\n (!stepStack.\nempty\n())    \n// 只要步骤栈不空就继续循环\n\n    {\n        \n// 得到四周的点\n\n        POINT tempPoint;\n        \nfor\n (\nint\n i = \n-1\n; i <= \n1\n; i += \n2\n)\n        {\n            tempPoint = { nowPoint.x,nowPoint.y + i * \n2\n };    \n// 计算点\n\n            \n// 判断坐标是否合法\n\n            \nif\n (tempPoint.x >= \n0\n && tempPoint.x <= GAME_WIDTH - \n1\n &&\n                tempPoint.y >= \n0\n && tempPoint.y <= GAME_HEIGHT - \n1\n &&\n                g_GameMap[tempPoint.y][tempPoint.x] != \n0xFFFF\n)\n//0xffff=-1\n\n            {\n                stepPoint.\npush_back\n(tempPoint);\n            }\n            tempPoint = { nowPoint.x + i * \n2\n ,nowPoint.y };    \n// 计算点\n\n            \n// 判断坐标是否合法\n\n            \nif\n (tempPoint.x >= \n0\n && tempPoint.x <= GAME_WIDTH - \n1\n &&\n                tempPoint.y >= \n0\n && tempPoint.y <= GAME_HEIGHT - \n1\n &&\n                g_GameMap[tempPoint.y][tempPoint.x] != \n0xFFFF\n)\n            {\n                stepPoint.\npush_back\n(tempPoint);\n            }\n        }\n\n        \n// 根据周围点的量选择操作\n\n        \nif\n (stepPoint.\nempty\n())                \n// 如果周围点都被遍历过了\n\n        {\n            stepStack.\npop\n();                \n// 出栈当前点\n\n            \nif\n (!stepStack.\nempty\n())\n                nowPoint = stepStack.\ntop\n();    \n// 更新当前点\n\n        }\n        \nelse\n\n        {\n            stepStack.\npush\n(stepPoint[\nrand\n() % stepPoint.\nsize\n()]);    \n// 入栈当前点,rand()生成随机数\n\n            g_GameMap[(nowPoint.y + stepStack.\ntop\n().y) / \n2\n][(nowPoint.x + stepStack.\ntop\n().x) / \n2\n] = \n0\n;    \n// 打通墙壁\n\n            nowPoint = stepStack.\ntop\n();        \n// 更新当前点\n\n            g_GameMap[nowPoint.y][nowPoint.x] = \n0xFFFF\n;                \n// 标记当前点\n\n        }\n        stepPoint.\nclear\n();                    \n// 清空周围点以便下一次循环\n\n    }\n    \n    \n// 清洗标记点\n\n    \nfor\n (\nint\n i = \n0\n; i < GAME_HEIGHT; i++)\n    {\n        \nfor\n (\nint\n j = \n0\n; j < GAME_WIDTH; j++)\n        {\n            \nif\n (g_GameMap[i][j] == \n0xFFFF\n)\n                g_GameMap[i][j] = \n0\n;\n        }\n    }\n\n    \n// 随机生成加油站的位置\n\n    \nfor\n (\nint\n i = \n0\n; i < FILLNUM; i++)\n    {\n        POINT fillPoint = { \nrand\n() % GAME_WIDTH,\nrand\n() % GAME_HEIGHT };\n        \n// 保证在空地生成加油站\n\n        \nwhile\n (g_GameMap[fillPoint.y][fillPoint.x] != GROUND)\n            fillPoint = { \nrand\n() % GAME_WIDTH,\nrand\n() % GAME_HEIGHT };\n        \n// 标记油灯\n\n        g_GameMap[fillPoint.y][fillPoint.x] = FILLSTATE;\n    }\n    \n    g_GameMap[GAME_HEIGHT - \n2\n][GAME_WIDTH - \n2\n] = ENDPOS;        \n// 标记终点\n\n    g_EndPos = { GAME_WIDTH - \n2\n,GAME_HEIGHT - \n2\n };                \n// 确定终点位置\n\n    g_ViewArray = MAXVIEW;                \n// 初始视野是最大的\n\n    g_BeginTime = \nGetTickCount\n();        \n// 开始计时\n\n    g_LastFillTime = \nGetTickCount\n();    \n// 油灯加油的时间\n\n    \nrePaintMap\n();                        \n// 绘制地图\n\n    g_PlayerPos = { g_BlockSize * \n3\n / \n2\n,g_BlockSize * \n3\n / \n2\n };    \n// 初始化人的位置\n\n    \ncomputeCameraPos\n();                    \n// 计算摄像机的位置\n\n    \ninitgraph\n(WIN_WIDTH, WIN_HEIGHT);    \n// 初始化画布\n\n    \nsetbkmode\n(TRANSPARENT);                \n// 设置背景为透明\n\n    \nBeginBatchDraw\n();                    \n// 开始缓冲绘制\n\n    \n}\n\n\n\n//4. 该模块把绘制视野，人物，时间融合到一个draw里面，在main函数中被引用\n\n\n\nvoid\n \ndraw\n()\n//绘图\n\n\n{\n    \n    \n// 清空设备\n\n    \ncleardevice\n();\n    \n// 绘制视野\n\n    \ndrawView\n();\n    \n// 绘制人\n\n    \ndrawPlayer\n();\n    \n// 绘制时间\n\n    \n    TCHAR timeStr[\n256\n];\n    \nint\n loseTime = \nGetTickCount\n() - g_BeginTime;    \n// 计算流失的时间\n\n    _stprintf_s(timeStr, _T(\n\"游戏时间:%02d:%02d\"\n), loseTime / \n1000\n / \n60\n, loseTime / \n1000\n % \n60\n);\n    \nsettextcolor\n(\nRGB\n(\n140\n, \n140\n, \n140\n));\n    \nouttextxy\n((WIN_WIDTH - \ntextwidth\n(timeStr)) / \n2\n, \n3\n, timeStr);\n    \n\n    \nFlushBatchDraw\n();    \n// 刷新屏幕\n\n}\n\n//5.update意为更新，这里的函数用来计算人物移动合法性和路过油灯视野更新，以及鼠标滚轮放大缩小的重新定位\n\n\nbool\n \nupDate\n()\n//计算，更新位置\n\n\n{\n    POINT nextPos = g_PlayerPos;        \n// 下一个位置\n\n\n    \n// 计算下一个位置\n\n    \nif\n         (\nGetKeyState\n(VK_UP) & \n0x8000\n)    nextPos.y -= \n2\n;\n//GetKeyState(VK_UP) & 0x8000)判断是否有按↑键\n\n    \n    \n    \nif\n (\nGetKeyState\n(VK_DOWN) & \n0x8000\n)    nextPos.y += \n2\n;\n//GetKeyState(VK_UP) & 0x8000)判断是否有按↓键\n\n    \n    \nif\n (\nGetKeyState\n(VK_LEFT) & \n0x8000\n)    nextPos.x -= \n2\n;\n//GetKeyState(VK_UP) & 0x8000)判断是否有按←键\n\n    \n    \nif\n (\nGetKeyState\n(VK_RIGHT) & \n0x8000\n)    nextPos.x += \n2\n;\n//GetKeyState(VK_UP) & 0x8000)判断是否有按→键\n\n    \n\n    \n// 如果下一个位置不合法\n\n    \nif\n (!\ncanMove\n(nextPos))\n    {\n        \nif\n (\ncanMove\n({ g_PlayerPos.x, nextPos.y }))        \n// y 轴移动合法\n\n            nextPos = { g_PlayerPos.x, nextPos.y };\n        \nelse\n \nif\n (\ncanMove\n({ nextPos.x, g_PlayerPos.y }))    \n// x 轴移动合法\n\n            nextPos = { nextPos.x, g_PlayerPos.y };\n        \nelse\n                                            \n// 都不合法\n\n            nextPos = g_PlayerPos;\n    }\n\n    \n// 如果是油灯则更新时间\n\n    \nif\n (g_GameMap[nextPos.y / g_BlockSize][nextPos.x / g_BlockSize] == FILLSTATE)\n        g_LastFillTime = \nGetTickCount\n();\n    \n// 如果是终点则通关\n\n    \nelse\n \nif\n (g_GameMap[nextPos.y / g_BlockSize][nextPos.x / g_BlockSize] == ENDPOS)\n    {\n        \nouttextxy\n(WIN_WIDTH / \n2\n - \n40\n, WIN_HEIGHT / \n2\n - \n12\n, _T(\n\"恭喜过关！\"\n));\n//字体大小\n\n        \nFlushBatchDraw\n();\n        \nSleep\n(\n5000\n);\n        \nreturn\n \nfalse\n;\n    }\n    g_PlayerPos = nextPos;                        \n// 更新位置\n\n    \ncomputeCameraPos\n();                            \n// 计算摄像机的位置\n\n\n    \n// 根据时间缩减视野\n\n    \nstatic\n \nunsigned\n \nint\n lastTime = \nGetTickCount\n();\n    \nint\n loseTime = \nGetTickCount\n() - g_LastFillTime;            \n// 计算流失的时间\n\n    g_ViewArray = MAXVIEW - loseTime / \n1000.0\n / DARKTIME;    \n// 每一段时间油灯的照明力会下降一个图块\n\n    \nif\n (g_ViewArray < MINVIEW) g_ViewArray = MINVIEW;\n\n    \n// 处理鼠标消息\n\n    MOUSEMSG mouseMsg;                            \n// 鼠标信息\n\n    \nint\n lastBlockSize = g_BlockSize;            \n// 保存原本的大小\n\n    \nwhile\n (\nMouseHit\n())\n    {\n        mouseMsg = \nGetMouseMsg\n();\n        \nif\n (mouseMsg.uMsg = WM_MOUSEWHEEL)        \n// 滚轮消息\n\n        {\n            g_BlockSize += mouseMsg.wheel / \n120\n;\n        }\n    }\n\n    \n// 如果没有滚轮消息就退出\n\n    \nif\n (lastBlockSize == g_BlockSize) \nreturn\n \ntrue\n;\n    \n// 处理滚轮消息\n\n    \nif\n (g_BlockSize >= \n10\n && g_BlockSize <= \n50\n)    \n// 块大小没有达到极限值\n\n    {\n        \n// 保证缩放后的地图不会比窗口小\n\n        \nif\n (GAME_WIDTH * g_BlockSize < WIN_WIDTH ||\n            GAME_HEIGHT * g_BlockSize < WIN_HEIGHT)\n            g_BlockSize = lastBlockSize;\n        \nrePaintMap\n();                            \n// 重绘地图\n\n        \n// 重新计算玩家在地图上的位置\n\n        POINT mapPos = { g_PlayerPos.x / lastBlockSize,g_PlayerPos.y / lastBlockSize };    \n// 计算在地图上的位置\n\n        g_PlayerPos.x = mapPos.x * g_BlockSize + g_BlockSize / \n2\n;    \n// 计算映射后的位置\n\n        g_PlayerPos.y = mapPos.y * g_BlockSize + g_BlockSize / \n2\n;    \n// 计算映射后的位置\n\n        \ncomputeCameraPos\n();                        \n// 重新计算摄像机位置\n\n    }\n    \n// 保证图块不会过大和过小\n\n    \nif\n (g_BlockSize < \n10\n) g_BlockSize = \n10\n;\n    \nif\n (g_BlockSize > \n50\n) g_BlockSize = \n50\n;\n\n    \nreturn\n \ntrue\n;\n}\n\n//6.absdelay和帧率有关，人物移速也有关\n\n\nvoid\n \nabsDelay\n(\nint\n delay)\n// 绝对延迟指每隔指定的时间（参数：滴答值），执行一次调用vTaskDelayUntil()函数的任务。//和帧率有关\n\n\n{\n    \nstatic\n \nint\n curtime = \nGetTickCount\n();\n//GetTickCount是一种函数。GetTickCount返回（retrieve）从操作系统启动所经过（elapsed）的毫秒数，它的返回值是DWORD。\n\n    \nstatic\n \nint\n pretime = \nGetTickCount\n();\n    \nwhile\n (curtime - pretime < delay)\n    {\n        curtime = \nGetTickCount\n();\n        \nSleep\n(\n1\n);\n    }\n    pretime = curtime;\n}\n\n//7. //判断地图合法模块//在上面update模块中引用\n\n\n\nbool\n \ncanMove\n(POINT pos)\n//判断合法模块//在上面update模块中引用\n\n\n{\n    \n// 只要外接矩形的四个顶点不在墙壁内就必定合法\n\n    \nreturn\n    g_GameMap[(pos.y - \n3\n) / g_BlockSize][(pos.x - \n3\n) / g_BlockSize] != WALL &&\n        g_GameMap[(pos.y + \n3\n) / g_BlockSize][(pos.x + \n3\n) / g_BlockSize] != WALL &&\n        g_GameMap[(pos.y - \n3\n) / g_BlockSize][(pos.x + \n3\n) / g_BlockSize] != WALL &&\n        g_GameMap[(pos.y + \n3\n) / g_BlockSize][(pos.x - \n3\n) / g_BlockSize] != WALL;\n}\n\n//8.计算摄像机位置和防止摄像机越界在上面的bool upDate()被引用\n\n\nvoid\n \ncomputeCameraPos\n()\n//判断合法模块//在上面的bool upDate()被引用\n\n\n{\n    \n// 以人物位置为中心计算摄像机的理论位置\n\n    g_CameraPos.x = g_PlayerPos.x - WIN_WIDTH / \n2\n;\n    g_CameraPos.y = g_PlayerPos.y - WIN_HEIGHT / \n2\n;\n    \n    \n// 防止摄像机越界\n\n    \nif\n (g_CameraPos.x < \n0\n)                                        g_CameraPos.x = \n0\n;\n//摄像机位置的最左端\n\n    \nif\n (g_CameraPos.y < \n0\n)                                        g_CameraPos.y = \n0\n;\n//摄像机位置的最上端\n\n    \nif\n (g_CameraPos.x > GAME_WIDTH * g_BlockSize - WIN_WIDTH)    g_CameraPos.x = GAME_WIDTH * g_BlockSize - WIN_WIDTH;\n//摄像机位置的最右端\n\n    \nif\n (g_CameraPos.y > GAME_HEIGHT * g_BlockSize - WIN_HEIGHT)    g_CameraPos.y = GAME_HEIGHT * g_BlockSize - WIN_HEIGHT;\n//摄像机位置的最下端\n\n}\n\n//9. 地图元素绘制如墙壁，加油站，终点，地面\n\n\nvoid\n \nrePaintMap\n()\n//地图元素绘制模块\n\n\n{\n    g_MapImage.\nResize\n(GAME_WIDTH * g_BlockSize, GAME_HEIGHT * g_BlockSize);    \n// 重置地图图片大小\n\n    \nSetWorkingImage\n(&g_MapImage);                                \n// 设置地图图片为当前工作图片\n\n    \nfor\n (\nint\n i = \n0\n; i < GAME_HEIGHT; i++)\n    {\n        \nfor\n (\nint\n j = \n0\n; j < GAME_WIDTH; j++)\n        {\n            \nswitch\n (g_GameMap[i][j])\n            {\n            \ncase\n WALL:\n                \ndrawWall\n({ j * g_BlockSize,i * g_BlockSize });        \n// 绘制墙壁\n\n                \nbreak\n;\n            \ncase\n FILLSTATE:\n                \ndrawFillState\n({ j * g_BlockSize,i * g_BlockSize });    \n// 绘制加油站\n\n                \nbreak\n;\n            \ncase\n GROUND:\n                \ndrawGround\n({ j * g_BlockSize,i * g_BlockSize });    \n// 绘制地面\n\n                \nbreak\n;\n            \ncase\n ENDPOS:\n                \ndrawEndPos\n({ j * g_BlockSize,i * g_BlockSize });   \n//终点\n\n                \nbreak\n;\n            }\n        }\n    }\n    \nSetWorkingImage\n();    \n// 复位工作图片\n\n}\n\n//10.如下在上面的rePaintMap()被引用\n\n\n\n\nvoid\n \ndrawWall\n(POINT pos)\n//地图绘制模块//墙壁初始化// 绘制墙壁图块的函数//在上面的rePaintMap()被引用\n\n\n{\n    \nsetfillcolor\n(\nRGB\n(\n166\n, \n210\n, \n19\n));\n//填充颜色\n\n    \nsolidrectangle\n(pos.x, pos.y, pos.x + g_BlockSize, pos.y + g_BlockSize);\n//solidrectangle用于画无边框的填充矩形\n\n}\n\n//11.如下，在上面的rePaintMap()被引用\n\n\n\nvoid\n \ndrawGround\n(POINT pos)\n//地图绘制模块// 绘制地面图块的函数//在上面的rePaintMap()被引用\n\n\n{\n    \nsetfillcolor\n(\nRGB\n(\n255\n, \n255\n, \n255\n));\n    \nsolidrectangle\n(pos.x, pos.y, pos.x + g_BlockSize, pos.y + g_BlockSize);\n}\n\n//12. 在上面的rePaintMap()被引用\n\n\nvoid\n \ndrawFillState\n(POINT pos)\n//在上面的rePaintMap()被引用\n\n\n{\n    \ndrawGround\n(pos);\n\n    \n// 绘制圆角矩形\n\n    pos.x += g_BlockSize / \n5\n;\n    pos.y += g_BlockSize / \n5\n;\n    \nsetfillcolor\n(\nRGB\n(\n252\n, \n213\n, \n11\n));\n    \nsolidroundrect\n(pos.x, pos.y, pos.x + g_BlockSize / \n5\n * \n3\n, pos.y + g_BlockSize / \n5\n * \n3\n, g_BlockSize / \n8\n, g_BlockSize / \n8\n);\n}\n\n\nvoid\n \ndrawEndPos\n(POINT pos)\n//终点//在上面的rePaintMap()被引用\n\n\n{\n    \ndrawGround\n(pos);\n\n    \n// 绘制圆角矩形\n\n    pos.x += g_BlockSize / \n5\n;\n    pos.y += g_BlockSize / \n5\n;\n    \nsetfillcolor\n(\nRGB\n(\n87\n, \n116\n, \n48\n));\n    \nsolidroundrect\n(pos.x, pos.y, pos.x + g_BlockSize / \n5\n * \n3\n, pos.y + g_BlockSize / \n5\n * \n3\n, g_BlockSize / \n8\n, g_BlockSize / \n8\n);\n}\n\n\nvoid\n \ndrawPlayer\n()\n//在上面的draw中引用\n\n\n{\n    \nsetfillcolor\n(\nRGB\n(\n252\n, \n213\n, \n11\n));\n    \nsolidcircle\n(g_PlayerPos.x - g_CameraPos.x, g_PlayerPos.y - g_CameraPos.y, \n3\n);\n    \n}\n\n\nvoid\n \ndrawView\n()\n//在上面的draw中引用\n\n\n{\n    \n// 锁定视野\n\n    HRGN viewArr;\n    \nint\n r = \nint\n(g_BlockSize * g_ViewArray + \n0.5\n);    \n// 计算视野半径\n\n    POINT orgin = g_PlayerPos;\n    orgin.x -= g_CameraPos.x;                        \n// 计算在屏幕上的位置\n\n    orgin.y -= g_CameraPos.y;                        \n// 计算在屏幕上的位置\n\n    viewArr = \nCreateEllipticRgn\n(orgin.x - r, orgin.y - r, orgin.x + r, orgin.y + r);    \n// 创建一个圆形的区域\n\n    \nsetcliprgn\n(viewArr);                            \n// 锁定区域\n\n\n    \n// 绘制地图\n\n    \nputimage\n(\n0\n, \n0\n, WIN_WIDTH, WIN_HEIGHT, &g_MapImage, g_CameraPos.x, g_CameraPos.y);\n\n    \n// 删除区域\n\n    \nDeleteObject\n(viewArr);\n    \n// 消除区域\n\n    \nsetcliprgn\n(\nNULL\n);\n}\n\n\nvoid\n \nendGame\n()\n// 结束游戏\n\n\n{\n    \nEndBatchDraw\n();                        \n// 这个函数用于结束批量绘制，并执行未完成的绘制任务，即结束缓冲绘制\n\n    \nclosegraph\n();                        \n// 关闭画布\n\n}\n\nvoid\n \nbgm\n()\n\n\n{\n    \nPlaySound\n(\nTEXT\n(\n\"bgm.wav\"\n), \nNULL\n, SND_FILENAME | SND_ASYNC | SND_LOOP);\n}\n\nvoid\n \njiaobu\n()\n\n\n{\n    \nPlaySound\n(\nTEXT\n(\n\"jiaobu.wav\"\n), SND_SYNC, SND_FILENAME | SND_ASYNC | \nNULL\n);\n}\n\nvoid\n \ngotoxy\n(\nint\n x, \nint\n y)\n \n{\n    COORD pos = { x,y };\n    HANDLE hOut = \nGetStdHandle\n(STD_OUTPUT_HANDLE);\n// 获取标准输出设备句柄\n\n    \nSetConsoleCursorPosition\n(hOut, pos);\n//两个参数分别是指定哪个窗体，具体位置\n\n}\n\n\nvoid\n \nwelcome\n()\n \n{\n    \ngotoxy\n(\n15\n, \n6\n);  \nprintf\n(\n\"欢迎来到  熄灯迷宫小游戏 ! \\n\"\n);\n    \ngotoxy\n(\n15\n, \n8\n);  \nprintf\n(\n\"  玩法介绍：                                         \\n\"\n);\n    \ngotoxy\n(\n15\n, \n10\n); \nprintf\n(\n\"    本游戏使用方向键操控，和传统迷宫一样需要迅速找到出口，但人物视野会逐渐降低              \\n\"\n);\n    \ngotoxy\n(\n15\n, \n12\n); \nprintf\n(\n\"                            路上黄色方块即为“加油站”踩到可以获得最大视野，绿色方块即为终点                                     \\n\"\n);\n    \ngotoxy\n(\n15\n, \n20\n); \nprintf\n(\n\"                                                                                        祝你玩得开心\\n\\n\\n\\n\\n\\n\"\n);\n    \nsystem\n(\n\"pause\"\n); \nsystem\n(\n\"cls\"\n);\n//清除屏幕\n\n    \n}\n\nvoid\n \nghost\n()\n\n\n{\n    \nint\n ball_x, ball_y;        \n//小球位置坐标\n\n    \nint\n ball_vx = \n1\n;            \n//小球X轴与Y轴的速度\n\n    \nint\n ball_vy = \n1\n;\n    \n//随机生成小球初始位置\n\n    \nsrand\n((\nunsigned\n)\ntime\n(\nNULL\n));\n    ball_x = \nrand\n() % \n860\n + \n20\n;\n    ball_y = \nrand\n() % \n460\n + \n20\n;\n    \ninitgraph\n(\n900\n, \n500\n);\n//900+500\n\n    \n    \nwhile\n (\n1\n)\n    {\n        \nsetcolor\n(YELLOW);\n        \nsetfillcolor\n(GREEN);\n        \nfillcircle\n(ball_x, ball_y, \n20\n);\n        \nSleep\n(\n2\n);\n        \nFlushBatchDraw\n();        \n//将之前的绘图输出，这个函数用于执行未完成的绘图人物。\n\n        \n        \nsetcolor\n(WHITE);\n        \nsetfillcolor\n(WHITE);\n        \n        \nfillcircle\n(ball_x, ball_y, \n20\n);\n        ball_x = ball_x + ball_vx;\n        ball_y = ball_y + ball_vy;\n        \n//当小球表面接触墙壁时发生碰撞反弹\n\n        \nif\n (ball_x <= \n20\n || ball_x >= \n900\n)\n            ball_vx = -ball_vx;\n        \nif\n (ball_y <= \n20\n || ball_y >= \n500\n)\n            ball_vy = -ball_vy;\n        \n    }\n    \nEndBatchDraw\n();        \n//结束批量绘制，并执行未完成的绘图任务\n\n    \nclosegraph\n();\n    \n}\n\n\n\n\n\n\n", "Tag": "算法分析"}
