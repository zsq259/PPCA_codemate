{"Answer": "望采纳：我没有写，我是用gpt帮你写了一个,希望能帮到你。\nprocedure hanoi(n, src, dst, tmp1, tmp2)\n    if n == 1 then\n        move(src, dst)\n    else if n == 2 then\n        move(src, tmp1)\n        move(src, dst)\n        move(tmp1, dst)\n    else\n        hanoi(n-2, src, tmp2, tmp1, dst)\n        move(src, tmp1)\n        move(src, dst)\n        move(tmp1, dst)\n        hanoi(n-2, tmp2, dst, tmp1, src)\n    end if\nend procedure\n\n其中 n 表示盘子数，src 表示源柱，dst 表示目标柱，tmp1 和 tmp2 分别表示两个临时柱，move 函数表示移动操作。具体来说，当只有一个盘子时，直接从源柱移动到目标柱；当有两个盘子时，先将一个盘子从源柱移动到一个临时柱，然后将剩下的两个盘子从源柱直接移动到目标柱，最后将之前移动到临时柱上的盘子移动到目标柱；当有三个或更多盘子时，先将除最上面两个盘子以外的其他盘子从源柱移动到一个临时柱，然后将最上面的两个盘子从源柱直接移动到目标柱，最后将之前移动到临时柱上的其他盘子移动到目标柱，具体的移动过程需要递归调用 hanoi 函数完成。", "Konwledge_Point": "分治算法", "Question": "写出分治算法解决四柱汉诺塔问题的伪代码\n写出分治算法解决四柱汉诺塔问题的伪代码。\n写出分治算法解决四柱汉诺塔问题的伪代码。", "Tag": "算法分析"}
{"Answer": "```\r\n package com.test;  \r\n  \r\nimport java.util.ArrayList;  \r\nimport java.util.List;  \r\n  \r\npublic class MyTest02 {  \r\n    public static void main(String[] args) {  \r\n        int[] a = { 13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7 };  \r\n        int[] s = getMaxSummary(a, 0, 15);  \r\n        for (int i = 0; i < s.length; i++) {  \r\n            System.out.println(s[i]);  \r\n        }  \r\n    }  \r\n  \r\n    /** \r\n     * 程序主入口 \r\n     * @param A \r\n     * @param low \r\n     * @param high \r\n     * @return \r\n     */  \r\n    public static int[] getMaxSummary(int[] A, int low, int high) {  \r\n        if (low == high) { // 如果長度就一個，那麼就把這個取出來  \r\n            int[] result = { low, high, A[low] };  \r\n            return result;  \r\n        } else {  \r\n            int middle = (int) Math.floor((low + high) / 2); // 获取中间值  \r\n            int[] left = new int[3]; // 保存左边部分返回结果  \r\n            int[] right = new int[3]; // 保存右边部分返回结果  \r\n            int[] cross = new int[3]; // 返回交叉部分返回结果  \r\n            left = getMaxSummary(A, low, middle);  \r\n            right = getMaxSummary(A, middle + 1, high);  \r\n            cross = getMaxCrossMid(A, low, high, middle);  \r\n            if (left[2] >= right[2] && left[2] >= cross[2]) {   // 那部分大就用了那部分  \r\n                return left;  \r\n            } else if (right[2] >= left[2] && right[2] >= cross[2]) {  \r\n                return right;  \r\n            } else {  \r\n                return cross;  \r\n            }  \r\n        }  \r\n    }  \r\n  \r\n    /** \r\n     * 獲取最大子數組（一部分在左邊，一部分在右邊） \r\n     *  \r\n     * @param A \r\n     * @param low \r\n     * @param high \r\n     * @param middle \r\n     * @return \r\n     */  \r\n    public static int[] getMaxCrossMid(int[] A, int low, int high, int middle) {  \r\n        int leftSum = Integer.MIN_VALUE;  \r\n        int sum = 0; // 保存和的  \r\n        int left = 0; // 记录左边位置  \r\n        for (int i = middle; i >= low; i--) {  \r\n            sum = sum + A[i];  \r\n            if (sum > leftSum) { // 证明所加数字为正数，那么符合条件（因为最大子数组内正数越多指定越大）  \r\n                leftSum = sum;  \r\n                left = i;  \r\n            }  \r\n        }  \r\n  \r\n        int rightSum = Integer.MIN_VALUE;  \r\n        int sum2 = 0;  \r\n        int right = 0; // 记录右边位置  \r\n        for (int i = middle + 1; i <= high; i++) {  \r\n            sum2 = sum2 + A[i];  \r\n            if (sum2 > rightSum) {  \r\n                rightSum = sum2;  \r\n                right = i;  \r\n            }  \r\n        }  \r\n  \r\n        int[] result = new int[3];  \r\n        result[0] = left;  \r\n        result[1] = right;  \r\n        result[2] = leftSum + rightSum;  \r\n        return result;  \r\n    }  \r\n  \r\n      \r\n      \r\n      \r\n}\r\n```", "Konwledge_Point": "分治算法", "Question": "一个关于分治算法的问题\n比如有一个List L = [(0,1), (1, 0), (0, 1), (1, 1), (1, 2), (3, 1), (3, 1), (2, 2), (2, 3), (3, 2), (2, 3), (4, 3), (3, 4), (4, 4), (4, 5), (5, 5)]\n\n\n\n包含N对两两一起的Integer\n\n现在有 (ai,bi)∈L  和 (aj,bj)∈L \n\n\n\n我们假设如果任意两对满足以下**三种情况其一**，就称这两组数是一对\n\nai=aj  并且 bi=bj\n\nai<aj\n\nbi<bj\n\n比如 (1,2) (1,1)就不是一对，因为任意一个条件都不满足\n\n\n\n那么假设我们有一组中间的（ai，bi），在满足什么情况下我们可以直接停止搜索他的对子呢？\n\n\n\n另外用**分治法**的话，给出一组数字，如何寻找他的一对数组呢？", "Tag": "算法分析"}
{"Answer": "\n望采纳，谢谢！\n\ndef getmid(a, b):\n    k = int(len(a) / 2)\n    #print(k, a, b)\n    if len(a) == 1:\n        return (a[0] + b[0]) / 2\n    if a[k] == b[k]:\n        return a[k]\n    elif a[k] < b[k]:\n        return getmid(a[k+1:], b[:k])\n    else:\n        return getmid(a[:k], b[k:])\n\n\n\nlsta = [0,1,2,4,8]\nlstb = [3,5,7,8,9]\n\nprint(getmid(lsta,lstb))\n\n\n\n", "Konwledge_Point": "分治算法", "Question": "用python完成分治策略\n设A 和B都是从小到大已经排好序的几个不等的整数构成的数组，如果把 A 与B合并后的数组记作C,设计一个算法找出C的中位数python实现而且是分治策略", "Tag": "算法分析"}
{"Answer": "该回答引用chatgpt:区间覆盖问题问题描述：给定一些区间，求最少需要多少个点才能覆盖所有的区间。\n分治算法伪代码：\ncover(intervals):\n    if intervals is empty:\n        return 0\n    find the interval with the smallest end point, called it \"min_interval\"\n    remove \"min_interval\" from \"intervals\"\n    remove all intervals that overlap with \"min_interval\" from \"intervals\"\n    return 1 + cover(intervals)\n\n\n\n该算法的思路是选择一个区间，找到所有与之重叠的区间，然后递归地处理这些重叠的区间。由于每个点只会被算一次，因此可以保证最后的点的数量是最小的。\n2比赛日程安排问题问题描述：有n个队伍要进行比赛，每个队伍需要和其他队伍比赛一次，求如何安排比赛，使得n天内可以全部比完。\n分治算法伪代码：\n\nschedule(n):\n    if n == 1:\n        return [[1]]\n    else:\n        first_half = schedule(n/2)\n        second_half = schedule(n - n/2)\n        add n/2 to all entries in the second half\n        reverse the rows of the second half\n        return first_half + second_half\n\n\n该算法的思路是将所有队伍分为两部分，分别让这两部分内的队伍进行比赛，然后将第二部分内的所有队伍编号加上n/2，再将其倒序排列，最后将这两部分的比赛安排合并即可。由于每个队伍只需要比一次，因此可以保证最后的比赛日程安排是正确的。", "Konwledge_Point": "分治算法", "Question": "写出分治算法解决区间覆盖问题或比赛日程安排问题的伪代码\n写出分治算法解决区间覆盖问题或比赛日程安排问题的伪代码。\n请尽量详细一点。", "Tag": "算法分析"}
{"Answer": "代码出错了\r\n应该是\r\nwhile(i <= mid)\r\ntemp[k++] = a[i++];", "Konwledge_Point": "分治算法", "Question": "分治算法：二分归并排序的合并中一段代码有疑问\n\n上图是数据\n\n下图是合并代码\n\n求大神帮帮忙！！！", "Tag": "算法分析"}
{"Answer": "分治算法不算基础算法吗？", "Konwledge_Point": "分治算法", "Question": "关于#python#的问题：Python中分治算法的思想在很多基础算法上都有所体现吗\nPython编程中分治算法的思想在很多基础算法上都有所体现吗？", "Tag": "算法分析"}
{"Answer": "你这个 left  right 不相等不就死循环了么第一次循环进去left 0 right 1 ,然后  (left+right)/2-1)   =（0+1）/2-1 结果-1 ，第二次进去 left 0 right -1  直接死循环", "Konwledge_Point": "分治算法", "Question": "java 算法 合并数组\npublic \nclass\n PartitionTest {\n//分治算法 合并排序代码\n\n\n    \nprivate\n void merge\nSort(\nint\n \na\n[], \nint\n \nleft\n,\nint\n \nright\n)\n{\n        \nif\n(left\n == \nright)\n        {\n            return;\n        }\n        merge\nSort(\na\n,\nleft\n,(\nleft\n+\nright\n)\n/\n2\n-\n1\n);\n        merge\nSort(\na\n,(\nleft\n+\nright\n)\n/\n2\n+\n1\n,right-\n1\n );\n        merge(a,left,right);\n    }\n    \nprivate\n void merge(\nint\n a\n[]\n, \nint\n left, \nint\n right) {\n        \nint\n l = left, mid = (left + right)\n / \n2\n, i = \n0\n;\n        \nint\n k = mid + \n1\n;\n        \nint\n[]\n arr = \nnew\n \nint\n[\nleft\n - \nright\n + \n1\n]\n;\n//存放排好序的数组\n\n        \nwhile\n (l <= mid\n && \nk <= right) {\n            \nif\n (a\n[\nl\n]\n > a\n[\nk\n]\n) {\n                arr\n[\ni\n]\n = a\n[\nk\n]\n;\n                i++;\n                k++;\n            } \nelse\n {\n                arr\n[\ni\n]\n = a\n[\nl\n]\n;\n                i++;\n                l++;\n            }\n        }\n        \nif\n (l > mid) {\n            \nfor\n (; k <= right; i++, k++) {\n                arr\n[\ni\n]\n = a\n[\nk\n]\n;\n            }\n        } \nelse\n {\n            \nfor\n (; l <= mid; i++, l++) {\n                arr\n[\ni\n]\n = a\n[\nl\n]\n;\n            }\n        }\n        \nfor\n (\nint\n j = \n0\n; j < left - right + \n1\n ; j++) {\n            a\n[\nleft\n++\n]\n = arr\n[\nj\n]\n;\n        }\n    }\n\n    public static void main(String\n[]\n args) {\n        \nint\n[]\n a = {\n2\n,\n0\n};\n        \nnew\n \nPartitionTest()\n.merge\nSort(\na\n,0,\na\n.\nlength\n-1)\n;\n        \nfor\n (\nint\n i = \n0\n; i < a.length; i++) {\n            \nSystem\n.\nout.println(a\n[\ni\n]\n);\n        }\n    }\n}\n\n\n\n\n为什么爆栈了,同样类似的算法在c++ 我没有爆 不明白啊 这里的算法可能有点问题", "Tag": "算法分析"}
{"Answer": "你好，是closest()函数point *SR 指针越界导致程序崩溃的。做如下修改可以解决程序崩溃问题\r\npoint *SR = new point[(high - low) / 2]; 改为point *SR = new point[(high - low)+1]; OK", "Konwledge_Point": "分治算法", "Question": "C++：基于分治思想实现二维平面最近点对算法，n>3时程序崩溃\n感觉问题出在快速排序的两个函数上，麻烦各位大佬看一下哪里出了问题。\n\n\n\n#include \"stdafx.h\"\n#include \n#include \n#include \n#include\n#include \nusing namespace std;\n\nstruct point//存储点坐标的结构体\n{\n    int index;\n    float x,y;\n};\n\nvoid Same(int n,int k,point X[])//查找相同的坐标\n{\n    for(int i=0;i=a.x) // 从右向左找第一个小于x的数\n                j--; \n            if(i=a.y) // 从右向左找第一个小于x的数\n                j--; \n            if(i3时进行分治\n        {                  \n            point *SL = new point[(high-low)/2+1];             \n            point *SR = new point[(high-low)/2];      \n            m = (high-low)/2 + low;    //       把x数组以m为界划分为两半             \n            j = k = 0;            \n            for(i=0; i<=high-low; i++)\n            {                       \n                if(Y[i].index<=m)\n                {                                \n                    SL[j++] = Y[i];   //       收集左边子集中的最近点对                             \n                }\n                else\n                {                      \n                    SR[k++] = Y[i];   //       收集右边子集中的最近点对                           \n                }                    \n            }\n                        closest(X,SL,low, m, al, bl, dl);       //     计算左边子集的最近点对\n                        closest(X,SR,m+1, high, ar, br, dr);//  计算右边子集的最近点对\n                        if(dl>n;\n    point *X=new point[n];\n     srand((int)time(0));\n     for(int i=0;i=2)\n     {\n          printf(\"最近点对为：(%.0f,%.0f),(%.0f,%.0f) \\n两点距离为：%.4f\\n\", a.x, a.y, b.x, b.y, min);\n      }\n     else{\n                printf(\"不存在最近点对！\\n\");\n        }\n\n}\n\n\n", "Tag": "算法分析"}
{"Answer": "程序质量的高低一般看程序的运行速度、占用存储的大小，程序是否清晰，容易阅读理解。", "Konwledge_Point": "分治算法", "Question": "高分悬赏：Java语言中哪些排序算法体现了分治的思想，哪些体现了递归的思想？具体说明\n高分悬赏：Java语言中哪些排序算法体现了分治的思想，哪些体现了递归的思想？具体说明", "Tag": "算法分析"}
{"Answer": "```\r\n #include \r\n#include \r\n#include \r\n#define MAX_N 20\r\n\r\nint max3(int, int, int);\r\nint maxSubArrayAns(int []);\r\nint maxSubArray(int [], int, int);\r\n\r\nint main(){\r\n    int nums[MAX_N];\r\n    int i;\r\n    srand(time(0));\r\n    printf(\"array: \\n\");\r\n    for(int i = 0; i < MAX_N; i++){\r\n        nums[i] = (int)(rand() % (MAX_N * 2) - MAX_N);\r\n        printf(\"%d\\t\", nums[i]);\r\n    }\r\n    printf(\"\\n\");\r\n    printf(\"The max subsequen sum is %d.\\n\", maxSubArrayAns(nums));\r\n\r\n\r\n    return 0;\r\n}\r\n\r\nint max3(int a, int b, int c){\r\n    if(a > b)\r\n        return a > c ? a : c;\r\n    else\r\n        return b > c ? b : c;\r\n}\r\n\r\nint maxSubArray(int nums[], int left, int right){\r\n    int maxLeftSum, maxRightSum;\r\n    int maxLeftBorderSum, maxRightBorderSum;\r\n    int leftBorderSum, rightBorderSum;\r\n\r\n    if(left == right)\r\n        if(nums[left] > 0)\r\n            return nums[left];\r\n        else\r\n            return 0;\r\n\r\n    int mid = (left + right) / 2, i;\r\n    maxLeftSum = maxSubArray(nums, left, mid);\r\n    maxRightSum = maxSubArray(nums, mid + 1, right);\r\n\r\n    maxLeftBorderSum = 0, leftBorderSum = 0;\r\n    for(i = mid; i >= left; i--){\r\n        leftBorderSum += nums[i];\r\n        if(leftBorderSum > maxLeftBorderSum)\r\n            maxLeftBorderSum = leftBorderSum;\r\n    }\r\n\r\n    maxRightBorderSum = 0, rightBorderSum = 0;\r\n    for(i = mid + 1; i <= right; i++){\r\n        rightBorderSum += nums[i];\r\n        if(rightBorderSum > maxRightBorderSum)\r\n            maxRightBorderSum = rightBorderSum;\r\n    }\r\n\r\n    return max3(maxLeftSum, maxRightSum, maxLeftBorderSum + maxRightBorderSum);\r\n}\r\n\r\nint maxSubArrayAns(int nums[]){\r\n    return maxSubArray(nums, 0, MAX_N - 1);\r\n}\r\n```\r\n\r\n使用分治法的话，平均时间复杂度为Θ(n lg n)。实际上解决最大子序列问题还有一种更加快速的方法，这种方法的时间复杂度是Θ(n)，是一种线性的算法\r\n\r\n\r\n\r\n```\r\n int maxSubArrayAns(int nums[]){\r\n    int i, thisSum = 0, maxSum = 0;\r\n    for(i = 0; i < MAX_N - 1; i++){\r\n        thisSum += nums[i];\r\n        if(thisSum > maxSum)\r\n            maxSum = thisSum;\r\n        else if(thisSum < 0)\r\n            thisSum = 0;\r\n    }\r\n\r\n    return maxSum;\r\n}\r\n```", "Konwledge_Point": "分治算法", "Question": "分治法求最大非连续子序列\n求非连续子序列的问题用DP很好解决，但是**分治法**就比较难了\n\n假设有一个序列是L = [1, 0, 5, 3, 2, 7, 9, 15, 6, 4, 13]\n\n他的最大非连续子序列就是 S = [1, 5, 7, 15, 13] 俩俩数字任意不相邻\n\n现在要求给L求S", "Tag": "算法分析"}
{"Answer": "必要性谈不上，但有些信息可以提供给你参考。算法分为数据结构算法和数学算法，其中，使用数据结构的算法多用于数据的存储和其它的编程问题，而数学算法则多用于人工智能。至于算法题，不清楚你说的是哪一类，如果是大学生的ACM竞赛题、中学生的NOI或NOIP竞赛题的话，大多指的是数学算法类的，数据结构等程序上的算法用的较少，而且，大学数学不是不刷这类算法题的理由，毕竟中学都有集训和比赛的。总而言之，必要性谈不上，至于需不需要练，则看你自己。", "Konwledge_Point": "分治算法", "Question": "大一有必要学算法刷算法题吗\n  大一计科专业，学校大二都会讲数据结构算法啥的，现在学了c，平时不知道要干点啥，如果说刷题的话，都是算法题，什么二叉树分治递归的需要用到这些知识，现在没有学去写阻力会很大，每写一题都需要去看相关知识，但这样即使写出来题相关知识也没法掌握住，也只能知道的很浅显也不系统，而且我记得还需要用到其他数学课的知识，现在我们只学了高数线代。可能写一个月也学不了多少，大二会专门去深入讲数据结构什么的，比自己学会好很多。我看我身边有人也在刷洛谷，但是感觉也都是写的磕磕绊绊，为了写出来而写。\n  所以想知道大一有必要学算法写算法题，或者是我上面说的有不对的地方？", "Tag": "算法分析"}
{"Answer": "你的目的是找最大点，所以第3步应该是找右边Y值最大的和X值最大的。", "Konwledge_Point": "分治算法", "Question": "类似于最近点对问题，但是有点不一样，麻烦看下我的思路有没有问题 \n问题：（最近点对问题）设平面上有两个不同的点p1=（x1，y1）和p2（x2，y2），若x1>x2,y1>y2,则称p1支配p2,。\n\n给定平面上n个点的集合P={p1，p2，...,pn},若点pi属于P，不被平面上任意点支配，则称pi为P的最大点。\n\n试使用分治法设计一个O（nlogn）的算法计算P中的所有最大点。\n\n\n\n分治法解决最近点对问题思路：\n\n用分治法解决最近点对问题，就是将一个问题分解两个子问题，然后递归处理子问题，然后合并。可能两个点在每个子问题中，也可能两个点分别在两个子问题中，就这两种情况。则基本过程为：找一条中垂线m(坐位S集合x坐标的中位数)把n个元素分成左右两部分元素，然后分别求得两边的最短距离1d,2d，然后取两者中的最小者记为d，在中线两边分别取d的距离，记录该距离范围内点的个数，中线左边有L个元素，右边有R个元素，分别将两边的点按y坐标升序排列，在左边集合中每一个点，找右边集合的点，找到与之距离小于d的点，更新最短距离，直到循环结束，即可求出最短距离。\n\n\n\n以上是解决找距离最近的点的问题\n\n\n\n解决最开始那个问题，我的思路是：\n\n1.找一条中垂线m(坐位S集合x坐标的中位数)把n个元素分成左右两部分元素。\n\n2.既然已经有了坐标，那么这时中垂线右边的点的x坐标肯定要比左边的大，这时就只需要在中垂线的右边找就可以了\n\n3.取得右边最大距离为d\n\n\n\n想到这里不知道接下来该怎么办了\n\n我是初学者，可能有些啰嗦，问题又不是很难，麻烦大家帮我解决一下，谢谢", "Tag": "算法分析"}
{"Answer": "\n\n#include<iostream>\nusing namespace std;\nvoid quickSort(int a[], int, int);//原型声明\nint main()\n{\n    int array[100] = {0}, k, i = 0, len = 0;\n    char c;\n    do {\n        scanf(\"%d\", &array[i]);\n        i++, len++;\n        c = getchar();\n    } while (c  != '\\n');\n\n    cout << \"The orginal arrayare:\" << endl;\n    for ( k = 0; k<len; k++)\n        cout << array[k] << \" \";\n    cout << endl;\n\n    quickSort(array, 0, len - 1);\n    cout << \"The sorted arrayare:\" << endl;\n    for (k = 0; k<len; k++)\n        cout << array[k] << \" \";//打印数组\n    cout << endl;\n    system(\"pause\");\n    return 0;\n}\n\nvoid quickSort(int s[], int l, int r)\n{\n    if (l< r)\n    {\n        int i = l, j = r, x = s[l];\n        while (i < j)\n        {\n            while (i < j && s[j] >= x) // 从右向左找第一个小于x的数\n                j--;\n            if (i < j)\n                s[i++] = s[j];\n            while (i < j && s[i]< x) // 从左向右找第一个大于等于x的数\n                i++;\n            if (i < j)\n                s[j--] = s[i];\n        }\n        s[i] = x;\n        quickSort(s, l, i - 1); // 递归调用\n        quickSort(s, i + 1, r);\n    }\n}\n\n\n有帮助点个采纳", "Konwledge_Point": "分治算法", "Question": "关于#算法#的问题：递归与分治法实现快速排序算法，输入一串以英文字符逗号隔开的数字，按升序排列法实现快速排序算法，提交实验报告(语言-c++)\n递归与分治法实现快速排序算法，输入一串以英文字符逗号隔开的数字，按升序排列法实现快速排序算法，提交实验报告。\n要求：\n1、以word形式提交实验报告，其中运行结果包含3个测试用例。\n2、源码project名称，或类名，或代码注释等形式，体现个人信息，如姓名和学号。\n3、word命名：班级+学号+姓名+算法分析第2章实验报告", "Tag": "算法分析"}
{"Answer": "```\r\n #include \r\n\r\nvoid swap(int a[], int i, int j)\r\n{\r\n    // 交换数组a中元素i与元素j的值\r\n    int tmp;\r\n    tmp = a[i];\r\n    a[i] = a[j];\r\n    a[j] = tmp;\r\n}\r\n\r\nint partition(int a[], int lo, int hi)\r\n{\r\n    int i = lo-1, pivot = a[lo];\r\n    swap(a, lo, hi);\r\n    while(lo<hi)\r\n    {\r\n        // 循环开始的时候i指向的是小于pivot的最后的一个位置\r\n        if(a[lo] < pivot)\r\n        {\r\n            i ++;\r\n            swap(a, i, lo);\r\n        }\r\n        lo ++;\r\n    }\r\n    i ++;\r\n    swap(a, i, hi);\r\n    return i;\r\n}\r\n\r\nint find(int a[], int left, int right, int k)\r\n{\r\n    int index;\r\n    index = partition(a, left, right);\r\n    if(index == k)\r\n        return a[index];\r\n    else if(index < k)\r\n        return find(a, index+1, right, k);\r\n    else\r\n        return find(a, left, right-1, k);\r\n}\r\n\r\nint main()\r\n{\r\n    int a[10000];\r\n    int n, k, i;\r\n    scanf(\"%d\", &n);\r\n    scanf(\"%d\", &k);\r\n    for(i=0; i<n; i++)\r\n        scanf(\"%d\", &a[i]);\r\n    printf(\"%d\\n\", find(a, 0, n-1, k-1));\r\n}\r\n```", "Konwledge_Point": "分治算法", "Question": "C++语言编程 急急！！！ 用分治策略\n设计一个平均时间为O(n)的算法，在n(1<=n<=1000)个无序的整数中找出第k小的数。\n\n\n\n提示：函数int partition(int a[],int left,int right)的功能是根据a[left]~a[right]中的某个元素x（如a[left])对a[left]~a[right]进行划分，划分后的x所在位置的左段全小于等于x,右段全大于等于x,同时利用x所在的位置还可以计算出x是这批数据按升非降序排列的第几个数。因此可以编制int find(int a[],int left,int right,int k)函数，通过调用partition函数获得划分点，判断划分点是否第k小，若不是，递归调用find函数继续在左段或右段查找。\n\n\n\n输入格式:\n\n输入有两行：\n\n\n\n第一行是n和k，0<k<=n<=10000\n\n\n\n第二行是n个整数\n\n\n\n输出格式:\n\n输出第k小的数\n\n\n\n输入样例:\n\n在这里给出一组输入。例如：\n\n\n\n10 4\n\n2 8 9 0 1 3 6 7 8 2\n\n输出样例:\n\n在这里给出相应的输出。例如：\n\n\n\n2", "Tag": "算法分析"}
{"Answer": "在分治求和过程中，遇到更大的和值时，更新一下当前子数组下标就可以了\r\n\r\n\r\n```\r\n \r\npublic class MaxSumSubarray {\r\n\r\n\tprivate static int binarySearch(int a[], int left, int right, MaxSumSubarray result) {\r\n\t\tint leftSum, rightSum, crossSum;\r\n\t\tif (left == right) {\r\n\t\t\tif (a[left] > result.sum) {\r\n\t\t\t\tresult.sum = a[left];\r\n\t\t\t\tresult.begin = left;\r\n\t\t\t\tresult.end = right;\r\n\t\t\t}\r\n\t\t\treturn a[left];\r\n\t\t} else {\r\n\t\t\tint mid = (left + right) / 2;\r\n\t\t\tleftSum = binarySearch(a, left, mid, result);\r\n\t\t\trightSum = binarySearch(a, mid + 1, right, result);\r\n\t\t\tcrossSum = crossBinarySearch(a, left, mid, right, result);\r\n\t\t\tif (leftSum >= rightSum && leftSum >= crossSum) {\r\n\t\t\t\tif (leftSum > result.sum) {\r\n\t\t\t\t\tresult.sum = leftSum;\r\n\t\t\t\t\tresult.begin = left;\r\n\t\t\t\t\tresult.end = mid;\r\n\t\t\t\t}\r\n\t\t\t\treturn leftSum;\r\n\t\t\t} else if (rightSum >= leftSum && rightSum >= crossSum) {\r\n\t\t\t\tif (rightSum > result.sum) {\r\n\t\t\t\t\tresult.sum = rightSum;\r\n\t\t\t\t\tresult.begin = mid;\r\n\t\t\t\t\tresult.end = right;\r\n\t\t\t\t}\r\n\t\t\t\treturn rightSum;\r\n\t\t\t} else {\r\n\t\t\t\treturn crossSum;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static MaxSumSubarray binarySearch(int[] a) {\r\n\t\tif (a == null || a.length == 0) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tMaxSumSubarray result = new MaxSumSubarray();\r\n\t\tresult.sum = binarySearch(a, 0, a.length - 1, result);\r\n\t\treturn result;\r\n\t}\r\n\r\n\tprivate static int crossBinarySearch(int a[], int left, int mid, int right, MaxSumSubarray result) {\r\n\t\tint leftSum = 0;\r\n\t\tint max_left_sum = 0;\r\n\t\tint begin = mid, end = mid + 1;\r\n\t\tfor (int i = mid; i >= left; i--) {\r\n\t\t\tleftSum += a[i];\r\n\t\t\tif (leftSum > max_left_sum) {\r\n\t\t\t\tbegin = i;\r\n\t\t\t\tmax_left_sum = leftSum;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tint rightSum = 0;\r\n\t\tint max_right_sum = 0;\r\n\t\tfor (int i = mid + 1; i <= right; i++) {\r\n\t\t\trightSum += a[i];\r\n\t\t\tif (rightSum > max_right_sum) {\r\n\t\t\t\tend = i;\r\n\t\t\t\tmax_right_sum = rightSum;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tint sum = max_left_sum + max_right_sum;\r\n\t\tif (sum > result.sum) {\r\n\t\t\tresult.sum = sum;\r\n\t\t\tresult.begin = begin;\r\n\t\t\tresult.end = end;\r\n\t\t}\r\n\t\treturn sum;\r\n\t}\r\n\r\n\tprivate int begin;\r\n\r\n\tprivate int end;\r\n\r\n\tprivate int sum;\r\n\r\n\tpublic MaxSumSubarray() {\r\n\t\tsuper();\r\n\t\tsum = Integer.MIN_VALUE;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the begin\r\n\t */\r\n\tpublic int getBegin() {\r\n\t\treturn begin;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the end\r\n\t */\r\n\tpublic int getEnd() {\r\n\t\treturn end;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the sum\r\n\t */\r\n\tpublic int getSum() {\r\n\t\treturn sum;\r\n\t}\r\n}\r\n```\r\n\r\n我这里用java语言实现，如果用其他语言，可以将MaxSumSubarray用一个整形数组替换，\r\n\r\n\tprivate int begin;\r\n\r\n\tprivate int end;\r\n\r\n\tprivate int sum;\r\n\t\r\n\t这三个字段就用一个int[3]替换", "Konwledge_Point": "分治算法", "Question": "算法设计 最大子数组（序列）\n采用分治法，有没有简单的方法标记最大子序列的开始和结尾点。\n\n即为可以输出子序列各个元素", "Tag": "算法分析"}
{"Answer": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint n;\nint a[10][10],b[10][10];\nint main(){\n    cin>>n;\n    a[1][1]=1;\n    for(int i=1;i<=n;i++){\n        int len=1<<i;\n        for(int j=1;j<=len;j++){\n            for(int k=1;k<=len;k++){\n                b[j][k]=a[(j+1)/2][(k+1)/2];\n                if(j%2==0) b[j][k]+=2;\n                if(k%2==0) b[j][k]+=1;\n            }\n        }\n        for(int j=1;j<=len;j++)\n            for(int k=1;k<=len;k++)\n                a[j][k]=b[j][k];\n    }\n    for(int i=1;i<=1<<n;i++){\n        for(int j=1;j<=1<<n;j++)\n            cout<<a[i][j]<<\" \";\n        cout<<endl;\n    }\n    return 0;\n}\n", "Konwledge_Point": "分治算法", "Question": "c++分治xjoi9437矩阵变幻\n【题目描述】\n\n\n有一个奇幻的矩阵，在不停的变幻，其变幻方式为：\n数字 1 变成矩阵：\n\n\n1 1\n1 2\n数字 2 变成矩阵：\n\n\n2 2\n2 1\n最初该矩阵只有一个元素 1，变幻 n 次后，矩阵会变成什么样？\n例如，矩阵最初为：[1]；\n\n\n矩阵变幻 1 次后：\n\n\n1 1\n1 2\n矩阵变幻 2 次后：\n\n\n1 1 1 1\n1 2 1 2\n1 1 2 2\n1 2 2 1\n【输入】\n\n\n一行一个整数 n（1<=n<=10），表示矩阵变幻的次数\n\n\n【输出】\n\n\n输出若干行，每行若干个整数，整数间以空格分开，表示变幻 n 次后的矩阵\n\n\n【样例输入】\n\n\n3\n\n\n【样例输出】\n\n\n1 1 1 1 1 1 1 1\n1 2 1 2 1 2 1 2\n1 1 2 2 1 1 2 2\n1 2 2 1 1 2 2 1\n1 1 1 1 2 2 2 2\n1 2 1 2 2 1 2 1\n1 1 2 2 2 2 1 1\n1 2 2 1 2 1 1 2\n想自己尝试，但做不出来", "Tag": "算法分析"}
{"Answer": "```\r\n 参考下面的程序，输入输出就你自己修改了，不然等于帮你做作业了。\r\n\r\n#include  \r\n#include  \r\nusing namespace std;  \r\n  \r\nint Partition (int *L, int low, int high)  \r\n{  \r\n    int temp = L[low];  \r\n    int pt   = L[low]; //哨兵  \r\n    while (low != high)  \r\n    {  \r\n        while (low < high && L[high] >= pt)  \r\n            high--;  \r\n        L[low] = L[high];         \r\n          \r\n        while (low < high && L[low] <= pt)  \r\n            low++;  \r\n        L[high] = L[low];  \r\n    }     \r\n    L[low] = temp;  \r\n    return low;  \r\n}  \r\n  \r\nvoid QSort (int *L, int low, int high)  //快速排序  \r\n{  \r\n    int pl;  \r\n    if (low < high)  \r\n    {  \r\n        pl = Partition (L,low,high);  \r\n        QSort (L, low,  pl-1);  \r\n        QSort (L, pl+1, high);  \r\n    }  \r\n}  \r\n  \r\nvoid findk(int k,int *L,int low,int high)  \r\n{  \r\n    int temp;  \r\n    temp=Partition(L,low,high);  \r\n    if(temp==k-1)  \r\n    {  \r\n        cout<<\"第\"<k-1)  \r\n        findk(k,L,low,temp-1);  \r\n    else  \r\n        findk(k,L,temp+1,high);  \r\n}  \r\n  \r\nint main()  \r\n{  \r\n    int a[10]={15,25,9,48,36,100,58,99,126,5},i,j,k;  \r\n    cout<<\"排序前：\"<>k;  \r\n    findk(k,a,0,9); //查找第k大的数不需要全部排序  \r\n  \r\n    QSort(a,0,9);     \r\n    cout<<\"排序后：\"<<endl;  \r\n    for(i=0;i<10;i++){  \r\n        cout<<a[i]<<\" \";  \r\n    }  \r\n    cout<<endl;  \r\n    system(\"Pause\");  \r\n    return 0;  \r\n}\r\n```", "Konwledge_Point": "分治算法", "Question": "C++语言编程 急急！！！用分治策略\n设计一个平均时间为O(n)的算法，在n(1<=n<=1000)个无序的整数中找出第k小的数。\n\n\n\n提示：函数int partition(int a[],int left,int right)的功能是根据a[left]~a[right]中的某个元素x（如a[left])对a[left]~a[right]进行划分，划分后的x所在位置的左段全小于等于x,右段全大于等于x,同时利用x所在的位置还可以计算出x是这批数据按升非降序排列的第几个数。因此可以编制int find(int a[],int left,int right,int k)函数，通过调用partition函数获得划分点，判断划分点是否第k小，若不是，递归调用find函数继续在左段或右段查找。\n\n\n\n输入格式:\n\n输入有两行：\n\n\n\n第一行是n和k，0<k<=n<=10000\n\n\n\n第二行是n个整数\n\n\n\n输出格式:\n\n输出第k小的数\n\n\n\n输入样例:\n\n在这里给出一组输入。例如：\n\n\n\n10 4\n\n2 8 9 0 1 3 6 7 8 2\n\n输出样例:\n\n在这里给出相应的输出。例如：\n\n\n\n2", "Tag": "算法分析"}
{"Answer": "http://wenku.baidu.com/link?url=P10nirc7m3tpWtwvsF-Q_Su0RAaLVgd-pYbL29UAqm3IUVwf_6d-ARR9XLyuxaSkafTM06HHFjbC3xwflpztSUfQnzNq1wdPxJ_QWEkAOS_", "Konwledge_Point": "分治算法", "Question": "解高次方程，除二分法\n求解一个高次方程除了二分法，还有什么好的方法。求解一个高次方程除了二分法，还有什么好的方法。求解一个高次方程除了二分法，还有什么好的方法。", "Tag": "算法分析"}
{"Answer": "return (maxSubSum(nums, 0, numsSize-1)试试", "Konwledge_Point": "分治算法", "Question": "力扣53:最大子序和（最大子段和C语言分治）\n小白求指点，为什么会报错\n\n\n执行结果： 执行出错 ================================================================= ==42==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x604000000034 at pc 0x5643b9ff8e04 bp 0x7ffd2cd0ab60 sp 0x7ffd2cd0ab50 READ of size 4 at 0x604000000034 thread T0 #5 0x7f15c13530b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2) 0x604000000034 is located 0 bytes to the right of 36-byte region [0x604000000010,0x604000000034) allocated by thread T0 here: #0 0x7f15c1f98bc8 in malloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10dbc8) #3 0x7f15c13530b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2) Shadow bytes around the buggy address: 0x0c087fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0c087fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0c087fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0c087fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0c087fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 =>0x0c087fff8000: fa fa 00 00 00 00[04]fa fa fa fa fa fa fa fa fa 0x0c087fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c087fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c087fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c087fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c087fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa Shadow byte legend (one shadow byte represents 8 application bytes): Addressable: 00 Partially addressable: 01 02 03 04 05 06 07 Heap left redzone: fa Freed heap region: fd Stack left redzone: f1 Stack mid redzone: f2 Stack right redzone: f3 Stack after return: f5 Stack use after scope: f8 Global redzone: f9 Global init order: f6 Poisoned by user: f7 Container overflow: fc Array cookie: ac Intra object redzone: bb ASan internal: fe Left alloca redzone: ca Right alloca redzone: cb Shadow gap: cc ==42==ABORTING\n\n\n代码\n\n\n\n\nint\n maxSubArray(\nint\n nums[], \nint\n numsSize){\n    return (maxSubSum(nums, \n0\n, numsSize));\n}\n\n\nint\n maxSubSum(\nint\n *nums, \nint\n \nleft\n, \nint\n \nright\n){\n    \nint\n  \nsum\n = \n0\n, left_sum = \n0\n, right_sum = \n0\n, allmax = \n0\n;\n    \nif\n (\nleft\n == \nright\n){\n        \nif\n (nums[\nleft\n] > \n0\n){\n            return nums[\nleft\n];\n        }\n        else{\n            return \n0\n;\n        }\n    }\n\n    \nint\n \nmid\n = (\nleft\n + \nright\n) / \n2\n;\n    left_sum = maxSubSum(nums, \nleft\n, \nmid\n);\n    right_sum = maxSubSum(nums, \nmid\n + \n1\n, \nright\n);\n    for (\nint\n i = \nmid\n; i >= \nleft\n; i--){\n        \nsum\n += nums[i];\n        \nif\n (allmax < \nsum\n){\n            allmax = \nsum\n;\n        }\n    }\n    \nsum\n = allmax;\n    for (\nint\n i = \nmid\n + \n1\n; i <= \nright\n; i++){\n        \nsum\n += nums[i];\n        \nif\n (allmax < \nsum\n){\n            allmax = \nsum\n;\n        }\n    }\n    \nif\n (allmax < left_sum && right_sum < left_sum){\n        return left_sum;\n    }\n    \nif\n (allmax < right_sum){\n        return right_sum;\n    }\n    return allmax;\n}\n\n\n\n", "Tag": "算法分析"}
{"Answer": "\n#include<iostream>\nusing namespace std;\n#define N 100000000\nint a[N]; \nint quickselect(int a[],int s,int t,int k)\n{\n    int i=s,j=t;\n    int tmp;\n    if(s<t)\n    {\n        tmp=a[s];\n        while(i!=j)\n        {\n            while(j>i&&a[j]<=tmp)\n            {\n                j--;\n            }\n            a[i]=a[j];\n            while(i<j&&a[i]>=tmp)\n            {\n                i++;\n            }\n            a[j]=a[i];\n        }\n        a[i]=tmp;\n        if(k-1==i) return a[i];\n        else if(k-1<i) return quickselect(a,s,i-1,k);\n        else return quickselect(a,i+1,t,k);\n    }\n    else if(s==t&&s==k-1)\n    return a[k-1];\n}\nint main()\n{\n    int n;\n    int k;\n    cin>>n>>k;\n    for(int i=0;i<n;i++)\n    cin>>a[i];\n    cout<<quickselect(a,0,n-1,k);\n}\n\n", "Konwledge_Point": "分治算法", "Question": "分治法求第K大的数有一个数据过不了？\n问题遇到的现象和发生背景\n\n\n 第 k 大的整数**\n分数 25\n作者 李祥\n单位 湖北经济学院\n求 n 个整数中第 k(1≤k≤n) 大的整数。\n\n\n输入格式\nn 和 k\nn 个整数\n\n\n输出格式\n第 k 大的整数\n\n\n输入样例\n10 3\n2 5 -1 9 25 0 12 4 -7 12\n输出样例\n12\n\n\n用代码块功能插入代码，请勿粘贴截图\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\nint\n \nquickselect\n(\nint\n a[],\nint\n s,\nint\n t,\nint\n k)\n\n\n{\n    \nint\n i=s,j=t;\n    \nint\n tmp;\n    \nif\n(si&&a[j]>=tmp) j--;\n            a[i]=a[j];\n            \nwhile\n(i>n>>k;\n    \nint\n a[\n1000001\n];\n    \nfor\n(\nint\n i=\n0\n;i>a[i];\n    }  \n    e=\nquickselect\n(a,\n0\n,n\n-1\n,n-k+\n1\n);\n    cout<<e<<endl;\n    \nreturn\n \n0\n;\n} \n\n\n\n\n运行结果及报错内容\n\n", "Tag": "算法分析"}
{"Answer": "合并排序比较适合多核加速，jdk8的新Arrays.parallelSort API就是这么实现的，quick sort从理论上来说也可以利用多核加速，不过由于其对于不同数据的split有可能出现线性的特点，理论上不是能保证得到加速。\r\n另外，对于多核加速，期望值不要太高，基于我们对Arrays.parallelSort的测试，4核cpu最多能达到3.2倍的速度，而16核只能达到11.8倍。主要是由于现阶段的split之后还有merge。", "Konwledge_Point": "分治算法", "Question": "快速排序和合并排序是否可以利用多核进一步加速\n我在研究快速排序和合并排序的时候突然想到这两个算法是否可以利用多核来进一步加快运行效率~\n\n因为它们是采用了分治法的思想，分解成多个互相独立的子排序，与其他需要顺序执行的排序算法不同~\n\n没经过系统学习~正在看算法导论~勿喷~", "Tag": "算法分析"}
{"Answer": "你这不是分治法吧，而且逻辑也有问题。。。", "Konwledge_Point": "分治算法", "Question": "请问各位C语言，分治法找出数组中第 k 个小的元素，我错在哪儿，该怎么改呢。能够输出，但是输出结果错误\n\n#\ninclude\n \nvoid mp\n_sort(\nint\n \n*\nc\n,\nint\n \nn\n,\nint\n \np\n,\nint\n \nq\n)\n;\n\n/**********  Begin  **********/\n\n\nint\n main\n()\n\n{\n    \nint\n zd_num,i,num;\n    scanf(\n\"%d %d\"\n,#,&zd_num);\n    \nint\n a\n[\nnum\n]\n;\n    \nfor\n(i=\n0\n;ic\n[\nm\n]\n)\n            {\n                item=c\n[\nk\n]\n;\n                c\n[\nk\n]\n=c\n[\nm\n]\n;\n                c\n[\nm\n]\n=item;\n            }\n        }\n    }\n}\n\n/**********  End  **********/\n\n", "Tag": "算法分析"}
{"Answer": "\n\n\n\n'''\n先搞搞思路， 写几行伪代码\n\n1、输入n，真币重量a，假币重量b，假币位置m , 约束 b<a\n\n2、初始化 列表 list_n\nlist_n = [a for n in range(n)]    \nlist_n[m-1] = b\n\n3、根据列表长度切列表，比较，如未找到，继续遍历重量小的列表，直到切完。\n'''\ndef show_result(l):\n    print('Find! position is: {}, weight is: {}.'.format(l[0],l[1]))\n\nwork_cmd = input(\"请输入硬币n，真币重量a，假币重量b，假币位置m , 约束 b<a：\\nn a b m\\t\")\nwork_num = [int(x) for x in work_cmd.split(\" \")]\nif (work_num[2] < work_num[1]) and (work_num[0]>1) and (work_num[3] <= work_num[0]):\n    list_n = [[i+1,work_num[1]] for i in range(work_num[0])]\n    list_n[work_num[3]-1][1] = work_num[2]\n    print(\"硬币列表\", list_n)\n\n\n    while len(list_n) > 1:\n        listlen = len(list_n)\n        offset1 = listlen // 2\n        offset2 = offset1\n        if listlen % 2 == 1:\n            offset2 = offset2 + 1\n        list1 = list_n[:offset1]\n        list2 = list_n[offset2:]\n        sum1 = sum([n[1] for n in list1])\n        sum2 = sum([n[1] for n in list2])\n        if  sum1 == sum2  :\n            if offset1 != offset2:\n                show_result(list_n[offset1])\n                break\n            else:\n                print('Not Find!')\n        else:\n            if sum1 < sum2:\n                if len(list1)==1:\n                    show_result(list1[0])\n                    break\n                list_n = list1\n            else:\n                if len(list2)==1:\n                    show_result(list2[0])\n                    break\n                list_n = list2\nelse:\n    print(\"约束条件\", '未符合，结束程序。')\n\n", "Konwledge_Point": "分治算法", "Question": "想要请教一下这个python问题该怎么解决\n相关知识\n找假币问题是一个比较简单且典型能够体现计算思维的问题。假设现在有n（n>=2）枚硬币，已知其中一枚为假币，且知道假币的重量是比真币轻的，请思考如何用分治思想解决该问题。\n\n\n算法原理\n本次实验中我们采用二分法解决假币问题。二分法是一个非常典型的分治思想的应用。\n\n\n如果n是偶数，将n个硬币平均分成两份，直接比较这两份硬币的重量，假币在重量较轻的那份硬币中，继续对重量较轻的那一份硬币使用二分法，直到找出假币；\n如果n是奇数，则随意取出一种的一枚硬币，将剩下的n-1枚硬币等分成两份。如果这两份硬币重量相同，则随机取出的那枚硬币即为假币；否则，按照硬币数为偶数是的处理办法继续执行算法。\n\n\n测试输入：\n3（此处省略七个3），2\n预期输出 :\nposition is: 7, weight is: 2.", "Tag": "算法分析"}
{"Answer": "=换成==\n", "Konwledge_Point": "分治算法", "Question": "时间复杂度，求解答，求解答\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n\nint\n \nmaxIntervalSum_1\n(\nint\n array[],\nint\n len)\n//穷举法，三层循环\n\n\n{\n    \nint\n max=\n0\n;\n    \nfor\n(\nint\n i=\n0\n;imax) max=sum;\n        }\n    }\n    \nreturn\n max;\n}\n\nint\n \nmaxIntervalSum_2\n(\nint\n array[],\nint\n len)\n//改进穷举法，两层循环\n\n\n{\n    \nint\n max=\n0\n;\n    \nfor\n(\nint\n i=\n0\n;imax) max=sum;\n    }\n    \nreturn\n max;\n}\n\nint\n \nmaxIntervalSum_3\n(\nint\n array[],\nint\n begin,\nint\n end)\n//分治法\n\n\n{\n    \nint\n mmax=\n0\n;\n    \nif\n(begin=end) \nreturn\n array[begin]>\n0\n?array[begin]:\n0\n;\n    \nint\n mid=begin+(end-begin)/\n2\n;\n    \nint\n lmax=\nmaxIntervalSum_3\n(array,begin,mid);\n//左半区间最大值\n\n    \nint\n rmax=\nmaxIntervalSum_3\n(array,mid+\n1\n,end);\n//右半区间最大值\n\n    \n//中间区间最大值\n\n    \nint\n sum=\n0\n;\n    \nint\n left_max=\n0\n;\n    \nfor\n(\nint\n i=mid;i>=begin;i--)\n    {\n        sum+=array[i];\n        \nif\n(sum>left_max) left_max=sum;\n    }\n    sum=\n0\n;\n    \nint\n right_max=\n0\n;\n    \nfor\n(\nint\n i=mid+\n1\n;i<=end;i++)\n    {\n        sum+=array[i];\n        \nif\n(sum>right_max) right_max=sum;\n    }\n    mmax=left_max+right_max;\n    \nint\n max=(lmax>rmax)?(lmax>mmax?lmax:mmax):(rmax>mmax?rmax:mmax);\n    \nreturn\n max;\n}\n\nint\n \nmaxIntervalSum_4\n(\nint\n array[],\nint\n len)\n//动态规则\n\n\n{\n    \nint\n max=\n0\n;\n    \nint\n sum=\n0\n;\n    \nfor\n(\nint\n i=\n0\n;imax) max=sum;\n    }\n    \nreturn\n max;\n}\n\n\nint\n \nmain\n(\nint\n argc,\nchar\n* argv[])\n\n\n{\n    \nchar\n* f_name=argv[\n1\n];\n//文件名\n\n    \nint\n n=\natoi\n(argv[\n2\n]);\n//字符串转整数\n\n    \nint\n repeat_time=\natoi\n(argv[\n3\n]);\n//重复次数\n\n    \n//读取数据到数组\n\n    FILE *pf;\n    \nint\n* data=(\nint\n*)\nmalloc\n(n*\nsizeof\n(\nint\n));\n    \nif\n((pf=\nfopen\n(\n\"C:\\\\text_datum.txt\"\n,\n\"r\"\n))==\nNULL\n)\n    {\n        \nprintf\n(\n\"Error\\n\"\n);\n        \nsystem\n(\n\"PAUSE\"\n);\n        \nexit\n(\n1\n);\n    }\n    \n//读取文件内容到数列\n\n    \nfor\n(\nlong\n \nlong\n \nint\n i=\n0\n;i<n;i++)\n    {\n        \nfscanf\n(pf,\n\"%d\\n\"\n,&data[i]);\n    }\n    \nfclose\n(pf);\n\n\n    \nclock_t\n c_start,c_end;\n    \nint\n maxValue=\n0\n;\n    c_start=\nclock\n();\n    \nfor\n(\nint\n i=\n0\n;i<repeat_time;i++)\n    {\n        maxValue=\nmaxIntervalSum_1\n(data,n);\n    }\n    c_end=\nclock\n();\n    \ndouble\n \ndiff_t\n=\ndifftime\n(c_end,c_start);\n    \nprintf\n(\n\"算法1,时间复杂度0(n^3),最大值=%d,执行时间=%f 毫秒.\\n\"\n,maxValue,\ndiff_t\n/repeat_time);\n\n\n\n    c_start=\nclock\n();\n    \nfor\n(\nint\n i=\n0\n;i<repeat_time;i++)\n    {\n        maxValue=\nmaxIntervalSum_2\n(data,n);\n    }\n    c_end=\nclock\n();\n    \ndiff_t\n=\ndifftime\n(c_end,c_start);\n    \nprintf\n(\n\"算法2,时间复杂度0(n^2),最大值=%d,执行时间=%f 毫秒.\\n\"\n,maxValue,\ndiff_t\n/repeat_time);\n\n\n\n     c_start=\nclock\n();\n    \nfor\n(\nint\n i=\n0\n;i<repeat_time;i++){\n        maxValue=\nmaxIntervalSum_3\n(data,\n0\n,n\n-1\n);\n    }\n    c_end=\nclock\n();\n    \ndiff_t\n=\ndifftime\n(c_end,c_start);\n    \nprintf\n(\n\"算法3，时间复杂度0(nlogn),最大值=%d,执行时间=%f 毫秒.\\n\"\n,maxValue,\ndiff_t\n/repeat_time);\n\n     c_start=\nclock\n();\n    \nfor\n(\nint\n i=\n0\n;i<repeat_time;i++){\n        maxValue=\nmaxIntervalSum_4\n(data,n);\n    }\n    c_end=\nclock\n();\n    \ndiff_t\n=\ndifftime\n(c_end,c_start);\n    \nprintf\n(\n\"算法4，时间复杂度0(n),最大值=%d,执行时间=%f 毫秒.\\n\"\n,maxValue,\ndiff_t\n/repeat_time);\n    \nreturn\n \n0\n;\n}\n\n\n\n\n求告知该怎么办？\n这是文件链接\nhttps://share.weiyun.com/FF6MWRaQ\n\n", "Tag": "算法分析"}
{"Answer": "先把你代码贴好\n", "Konwledge_Point": "分治算法", "Question": "时间复杂度，今天就要交了\n#include \n#include \n#include \n\n\nint maxIntervalSum_1(int array[],int len)//穷举法，三层循环\n{\n    int max=0;\n    for(int i=0;imax) max=sum;\n        }\n    }\n    return max;\n}\nint maxIntervalSum_2(int array[],int len)//改进穷举法，两层循环\n{\n    int max=0;\n    for(int i=0;imax) max=sum;\n    }\n    return max;\n}\nint maxIntervalSum_3(int array[],int begin,int end)//分治法\n{\n    int mmax=0;\n    if(begin=end) return array[begin]>0?array[begin]:0;\n    int mid=begin+(end-begin)/2;\n    int lmax=maxIntervalSum_3(array,begin,mid);//左半区间最大值\n    int rmax=maxIntervalSum_3(array,mid+1,end);//右半区间最大值\n    //中间区间最大值\n    int sum=0;\n    int left_max=0;\n    for(int i=mid;i>=begin;i--)\n    {\n        sum+=array[i];\n        if(sum>left_max) left_max=sum;\n    }\n    sum=0;\n    int right_max=0;\n    for(int i=mid+1;i<=end;i++)\n    {\n        sum+=array[i];\n        if(sum>right_max) right_max=sum;\n    }\n    mmax=left_max+right_max;\n    int max=(lmax>rmax)?(lmax>mmax?lmax:mmax):(rmax>mmax?rmax:mmax);\n    return max;\n}\nint maxIntervalSum_4(int array[],int len)//动态规则\n{\n    int max=0;\n    int sum=0;\n    for(int i=0;imax) max=sum;\n    }\n    return max;\n}\n\n\nint main(int argc,char* argv[])\n{\n    char* f_name=argv[1];//文件名\n    int n=atoi(argv[2]);//字符串转整数\n    int repeat_time=atoi(argv[3]);//重复次数\n    //读取数据到数组\n    FILE \npf;\n    int\n data=(int*)malloc(n*sizeof(int));\n    if((pf=fopen(\"C:\n\\text_datum.txt\",\"r\"))==NULL)\n    {\n        printf(\"Error\\n\");\n        system(\"PAUSE\");\n        exit(1);\n    }\n    //读取文件内容到数列\n    for(long long int i=0;i<n;i++)\n    {\n        fscanf(pf,\"%d\\n\",&data[i]);\n    }\n    fclose(pf);\n\n\nclock_t c_start,c_end;\nint \nmaxValue\n=0;\n\nc_start\n=clock();\n\nfor\n(int \ni\n=0;i<repeat_time;i++)\n{\n    \nmaxValue\n=maxIntervalSum_1(data,n);\n}\n\nc_end\n=clock();\ndouble \ndiff_t\n=difftime(c_end,c_start);\nprintf(\n\"算法1,时间复杂度0(n^3),最大值=%d,执行时间=%f 毫秒.\\n\"\n,maxValue,diff_t/repeat_time);\n\n\n\n\nc_start\n=clock();\n\nfor\n(int \ni\n=0;i<repeat_time;i++)\n{\n    \nmaxValue\n=maxIntervalSum_2(data,n);\n}\n\nc_end\n=clock();\n\ndiff_t\n=difftime(c_end,c_start);\nprintf(\n\"算法2,时间复杂度0(n^2),最大值=%d,执行时间=%f 毫秒.\\n\"\n,maxValue,diff_t/repeat_time);\n\n\n\n \nc_start\n=clock();\n\nfor\n(int \ni\n=0;i<repeat_time;i++){\n    \nmaxValue\n=maxIntervalSum_3(data,0,n-1);\n}\n\nc_end\n=clock();\n\ndiff_t\n=difftime(c_end,c_start);\nprintf(\n\"算法3，时间复杂度0(nlogn),最大值=%d,执行时间=%f 毫秒.\\n\"\n,maxValue,diff_t/repeat_time);\n\n \nc_start\n=clock();\n\nfor\n(int \ni\n=0;i<repeat_time;i++){\n    \nmaxValue\n=maxIntervalSum_4(data,n);\n}\n\nc_end\n=clock();\n\ndiff_t\n=difftime(c_end,c_start);\nprintf(\n\"算法4，时间复杂度0(n),最大值=%d,执行时间=%f 毫秒.\\n\"\n,maxValue,diff_t/repeat_time);\nreturn 0;\n\n\n\n}\n\n", "Tag": "算法分析"}
{"Answer": "你想要看啥断点点在哪里，debug就可以了", "Konwledge_Point": "分治算法", "Question": "c＋＋中斐波那契数列项数\n#include \n\n\ndouble fib1(int n);    //非递归生成下标为n的斐波那契数列元素\ndouble fib2(int n);    //递归生成下标为n的斐波那契数列元素\n\n\nint main()\n{\n    int n;\n    printf(\"请输入斐波那契数列项数:\");\n    scanf(\"%d\", &n);\n    /\nprintf(\"动态规划方法求解：第 %d 项斐波那契数列数值是 %.0f \\n\", n, fib1(n));\n/\n    printf(\"分治法求解：第 %d 项斐波那契数列数值是 %.0f \\n\", n, fib2(n));\n    return 0;\n}\n\n\n//动态规划方法求解\n\n\ndouble fib1(int n)\n{\n    int i = 0;\n    double a = 1;\n    double b = 1;\n    double result = 0;\n    if (n <= 0)\n    {\n        return 0;\n    }\n    else if (n <= 2)\n    {\n        return 1;\n    }\n    else\n    {\n        for (i = 3; i <= n; i++)\n        {\n            result = a + b;\n            a = b;\n            b = result;\n        }\n        return result;\n    }\n}\n\n\n//分治方法求解\n\n\ndouble fib2(int n)\n{\n    if (n <= 0)\n    {\n        return 0;\n    }\n    else if (n <= 2)\n    {\n        return 1;    //递归终止条件\n    }\n    else\n    {\n        return fib2(n - 1) + fib2(n - 2);    //递归\n    }\n}\n\n\n斐波那契数列（分治策略）\n这个代码如何加断点，求解斐波那契数列的第 40 项", "Tag": "算法分析"}
{"Answer": "先说你的错误原因把： 第17行和第18行代码中， 你需要传递数组a， 不需要添加[],  数组的传递只用传递数组名\n其次：    printf(\"分治法求出数组元素的和为:%d\",&sum);输出这里不能加&， 这表示取地址， 加了就是输出sum在电脑中的地址而非输出sum所对应的值\n", "Konwledge_Point": "分治算法", "Question": "请问各位C语言求一组数据的和，我的代码编译不出来，该怎么修改呢\n\n\n#\ninclude\n \n\"stdio.h\"\n\n\n#\ninclude\n \n\"stdlib.h\"\n\n\n/**********  Begin  **********/\n\n\nint\n \nget_sum\n(\nint\n b[],\nint\n i,\nint\n j)\n;\n\nint\n \nmain\n()\n\n\n{\n    \nint\n sum1,sum2,sum,i,num;\n    \nscanf\n(\n\"%d\"\n,#);\n    \nprintf\n(\n\"\\n\"\n);\n    \nint\n a[num];\n    \nfor\n(i=\n0\n;i<num;i++)\n    {\n        \nscanf\n(\n\"%d\"\n,&a[i]);\n        \nprintf\n(\n\"\\n\"\n);\n    }\n    sum1=\nget_sum\n(a[],\n0\n,num/\n2\n-1\n);\n    sum2=\nget_sum\n(a[],num/\n2\n,num\n-1\n);\n    sum=sum1+sum2;\n    \nprintf\n(\n\"分治法求出数组元素的和为:%d\"\n,&sum);\n       \nreturn\n \n0\n;\n}\n\nint\n \nget_sum\n(\nint\n b[],\nint\n i,\nint\n j)\n\n\n{\n    \nint\n sum=\n0\n,k;\n    \nfor\n(k=i;k<=j;k++)\n    {\n        sum+=b[k];\n    }\n    \nreturn\n sum;\n}\n\n\n/**********  End  **********/\n\n\n", "Tag": "算法分析"}
