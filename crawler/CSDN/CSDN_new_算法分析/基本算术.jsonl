{"Answer": "#include<stdio.h>\n \n#include<stdlib.h>\n \n \n \n#define STACK_SIZE 10              //存储空间初始分配量\n \n#define STACK_INCREASE 5    //存储空间分配增量\n \n \n \ntypedef struct {                //寄存运算符\n \n      char* base;           //栈底指针\n \n      char* top;                  //栈顶指针\n \n      int stacksize;        //当前可使用最大容量\n \n}OPTR;\n \ntypedef struct {                //寄存操作数\n \n      double* base;\n \n      double* top;\n \n      int stacksize;\n \n}OPND;\n \n \n \nint InitStack(OPTR* s);\n \nint InitStack(OPND* s);\n \nint Push(OPTR* s, char e);\n \nint Push(OPND* s, double e);\n \nint Pop(OPTR* s, char* e);\n \nint Pop(OPND* s, double* e);\n \nchar Gettop(OPTR* s);\n \ndouble Gettop(OPND* s);\n \nint In(char e);\n \nchar Precede(char a, char b);\n \ndouble Operate(double a, double b, char t);\n \n \n \n//主函数\n \nint main()\n \n{\n \n      OPTR optr;\n \n      OPND opnd;\n \n      OPND temp;    //临时存储数字，构造多位数\n \n      char c;            //接收表达式\n \n      char y;            //接收脱掉的括号和井号\n \n      char theta;       //接收脱出进行运算的运算符\n \n      double a, b;  //接收脱出进行运算的操作数\n \n      int g = 1;\n \n \n \n      while(g)\n \n      {\n \n             system(\"cls\");\n \n                    double x = 0, z = 0;    //多位数转换\n \n                    int n = 1;                   //幂\n \n                    int error = 0;               //输入格式错误则报错\n \n                    InitStack(&optr);\n \n                    InitStack(&opnd);\n \n                    InitStack(&temp);\n \n            \n \n                    printf(\"请输入整数表达式（以#结束）：\\n\");\n \n                    Push(&optr, '#');\n \n                    c = getchar();\n \n     \n \n                    while (c != '#' || Gettop(&optr) != '#')\n \n                    {\n \n                           if (c == '0') {\n \n                                  Push(&opnd, (double)z);\n \n                                  c = getchar();\n \n                           }\n \n                           else\n \n                           {\n \n                                  while (!In(c))\n \n                                  {                                               //将多位数存入临时栈\n \n                                         Push(&temp, c - '0');       //字符转数字\n \n                                         c = getchar();\n \n                                  }\n \n                                  while (temp.base != temp.top)\n \n                            {                                 //将临时栈中的数重组为多位数\n \n                                         Pop(&temp, &x);\n \n                                         z = z + x * n;\n \n                                         n *= 10;\n \n                                  }\n \n                                  n = 1;\n \n                                  if (z)Push(&opnd, (double)z);//重组后的多位数入栈\n \n                                  z = 0;\n \n                           }\n \n            \n \n                           if (In(c))\n \n                           {\n \n                                  switch (Precede(Gettop(&optr), c))\n \n                                  {\n \n                                         case '<':\n \n                                                Push(&optr, c);\n \n                                                c = getchar();\n \n                                                break;\n \n                   \n \n                                         case '=':\n \n                                                Pop(&optr, &y);\n \n                                                c = getchar();\n \n                                                break;\n \n                   \n \n                                         case '>':\n \n                                                Pop(&optr, &theta);\n \n                                                Pop(&opnd, &b);\n \n                                                Pop(&opnd, &a);\n \n                                                Push(&opnd, Operate(a, b, theta));\n \n                                                break;\n \n                   \n \n                                         case '!':\n \n                                                printf(\"输入错误！\");\n \n                                                error = 1;\n \n                                                break;\n \n                                  }\n \n                           }\n \n                           if (error)break;\n \n                    }\n \n                    if (!error)\n \n                           printf(\"结果为：%.2f\\n\", Gettop(&opnd));\n \n                    system(\"pause\");\n \n \n      }\n \n            \n \n      return 0;\n \n}\n \n//构造空栈s\n \nint InitStack(OPTR* s) {\n \n      s->base = (char*)malloc(STACK_SIZE * sizeof(char));\n \n      if (!s->base)\n \n             exit(0);//存储分配失败\n \n      s->top = s->base;\n \n      s->stacksize = STACK_SIZE;\n \n      return 1;\n \n}\n \nint InitStack(OPND* s) {\n \n      s->base = (double*)malloc(STACK_SIZE * sizeof(double));\n \n      if (!s->base)\n \n             exit(0);\n \n      s->top = s->base;\n \n      s->stacksize = STACK_SIZE;\n \n      return 1;\n \n}\n \n//插入元素e为新的栈顶\n \nint Push(OPTR* s, char e) {\n \n      if (s->top - s->base >= s->stacksize) {//栈满，追加存储空间\n \n             s->base = (char*)realloc(s->base,\n \n                    (s->stacksize + STACK_INCREASE) * sizeof(char));\n \n             if (!s->base)\n \n                    exit(0);\n \n             s->top = s->base + s->stacksize;\n \n             s->stacksize += STACK_INCREASE;\n \n      }\n \n      *(s->top) = e;\n \n      s->top++;\n \n}\n \nint Push(OPND* s, double e) {\n \n      if (s->top - s->base >= s->stacksize) {\n \n             s->base = (double*)realloc(s->base,\n \n                    (s->stacksize + STACK_INCREASE) * sizeof(double));\n \n             if (!s->base)\n \n                    exit(0);\n \n             s->top = s->base + s->stacksize;\n \n             s->stacksize += STACK_INCREASE;\n \n      }\n \n      *(s->top) = e;\n \n      s->top++;\n \n}\n \n//删除栈顶元素,返回其值\n \nint Pop(OPTR* s, char* e) {\n \n      if (s->top == s->base)return 0;\n \n      s->top--;\n \n      *e = *(s->top);\n \n      return 1;\n \n}\n \nint Pop(OPND* s, double* e) {\n \n      if (s->top == s->base)return 0;\n \n      s->top--;\n \n      *e = *(s->top);\n \n      return 1;\n \n}\n \n//判断栈是否为空，不为空则返回栈顶元素e\n \nchar Gettop(OPTR* s) {\n \n      if (s->top == s->base)\n \n             return 0;\n \n      char* e = s->top;\n \n      e--;\n \n      return *e;\n \n}\n \ndouble Gettop(OPND* s) {\n \n      if (s->top == s->base)\n \n             return 0;\n \n      double* e = s->top;\n \n      e--;\n \n      return *e;\n \n}\n \n//判断是否为运算符\n \nint In(char e) {\n \n      if (e == '+' || e == '-' || e == '*' || e == '/' || e == '(' || e == ')' || e == '#')\n \n             return 1;\n \n      else return 0;\n \n}\n \n//判断优先级\n \nchar Precede(char a, char b) {\n \n      if (a == '+')\n \n      {\n \n             if (b == '*' || b == '/' || b == '(') return '<';\n \n             else return '>';\n \n      }\n \n      else if (a == '-')\n \n      {\n \n             if (b == '*' || b == '/' || b == '(') return '<';\n \n             else return '>';\n \n      }\n \n      else if (a == '*')\n \n      {\n \n             if (b == '(')return '<';\n \n             else return '>';\n \n      }\n \n      else if (a == '/')\n \n      {\n \n             if (b == '(')return '<';\n \n             else return '>';\n \n      }\n \n      else if (a == '(')\n \n      {\n \n             if (b == ')')return '=';\n \n             else if (b == '#') return '!';\n \n             else return '<';\n \n      }\n \n      else if (a == ')')\n \n      {\n \n             if (b == '(')return '!';\n \n             else return '>';\n \n \n \n      }\n \n      else if (a == '#')\n \n      {\n \n             if (b == ')')return '!';\n             if (b == '#')return '=';\n             else return '<';\n      }\n}\n//计算\ndouble Operate(double a, double b, char theta) {\n      switch (theta)\n      {\n      case '+':\n             return a + b;\n      case '-':\n             return 1.0 * a - b;\n      case '*':\n             return a * b;\n      case '/':if (b != 0)\n             return 1.0 * a / b;\n                    else\n             printf(\"输入错误！\");\n             exit(0);\n \n      }\n \n}\n\n", "Konwledge_Point": "基本算术", "Question": "数据结构-算术表达式的求解\n问题描述：给定一个算术表达式，通过程序求出最后的结果。\n基本要求：\n1． 从键盘输入要求解的算术表达式；\n2． 采用栈结构进行算术表达式的求解过程；\n3． 能够判断算术表达式正确与否；\n4． 对于错误表达式给出提示；\n5． 对于正确的表达式给出最后的结果；\n附程序和图加主要思想", "Tag": "算法分析"}
{"Answer": "提示一下，用简单类工厂的模式去做这种计算器的实现，能够体现面向对象的思想。", "Konwledge_Point": "基本算术", "Question": "求c++大神解答，最好是面向对象程序设计c++高级语言的\n\n\n模拟计算器程序\n问题描述\n设计一个程序来模拟一个简单的手持计算器。程序支持算术运算+、-、*、/、=、以及Ｃ（清除）、A（全清除）操作。\n基本要求\n程序运行时，显示一个窗口，等待用户输入，用户可以从键盘输入要计算的表达式，输入的表达式显示在窗口中，用户键入’=’ 符号后，窗口显示出结果。\n测试数据\n程序输入不少于5种不同的表达式进行测试。\n实现提示\n可定义一个计算器类，该类包括两个组件对象，一个计算引擎和一个用户接口，用户接口对象处理接受的键盘输入信息，并显示答案，计算引擎对象对给出的数据执行相应操作，并存储操作的结果。\n选作内容\n如果用户输入的表达式不合法，可以判别出来并给出相应的错误提示。\n\n", "Tag": "算法分析"}
{"Answer": "先括号，再其他", "Konwledge_Point": "基本算术", "Question": "逻辑表达式的基本算法\n像这样有括号的是不是就先算括号里的，就不能根据！的优先级大于算术运算符来算了？", "Tag": "算法分析"}
{"Answer": "简单写了下，希望有用，祝你顺利\n\n#include <stdio.h>\n//简单方法一 \nint main(){\n    int a,b,c;\n    char op;\n    printf(\"请输入表达式,按enter执行，例如 1+2 ：\"); \n    scanf(\"%d%c%d\",&a,&op,&b);\n    switch(op){\n        case '+':\n            c=a+b;\n            break;\n        case '-':\n            c=a-b;\n            break;\n        case '*':\n            c=a*b;\n            break;\n        case '/':\n            c=a/b;\n            break;\n        case '%':\n            c=a%b;\n            break;\n        default:\n            printf(\"不支持该操作%c\",op);     \n    }     \n     printf(\"%d%c%d=%d\\n\",a,op,b,c); \n    return 0;\n}\n\n\n#include <stdio.h>\n//简单方法二\nint add(int a,int b){\n    return a+b;\n} \nint sub(int a,int b){\n    return a-b;\n}\nint muti(int a,int b){\n    return a*b;\n}\nint div(int a,int b){\n    return a/b;\n}\nint mod(int a,int b){\n    return a%b;\n}\nint main(){\n    int a,b,c;\n    char op;\n    printf(\"请输入表达式,按enter执行，例如 1+2 ：\"); \n    scanf(\"%d%c%d\",&a,&op,&b);\n    switch(op){\n        case '+':\n            c=add(a,b);\n            break;\n        case '-':\n            c=sub(a,b);\n            break;\n        case '*':\n            c=muti(a,b);\n            break;\n        case '/':\n            c=div(a,b);\n            break;\n        case '%':\n            c=mod(a,b);\n            break;\n        default:\n            printf(\"不支持该操作%c\",op);     \n    }     \n     printf(\"%d%c%d=%d\\n\",a,op,b,c); \n    return 0;\n}\n\n\n\n", "Konwledge_Point": "基本算术", "Question": "这个c语言该怎么解答呢\n一、使用两种方法编写一个简单的计算器程序，该计算器程序能实现两个数的加法、减法、乘法、除法和取余等基本的算术运算。1.方法1：根据输入的两个整型操作数和运算符可以完成 + 、—、* 、/ 、% 运算，输出结果必须是一个完整的算术运算式的格式。例如 ：输入3+5，输出结果是 3+5=8。（要求使用switch语句）\n2.方法2：根据输入两个整型操作数和运算符可以完成 + 、—、* 、/ 、% 运算。具体运算过程要求是通过调用对应的子函数来实现。", "Tag": "算法分析"}
{"Answer": "下面是一个例子，它使用C语言实现了二叉树来表示表达式并求值的功能：\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\n// 定义表达式二叉树的结点结构\ntypedef struct node {\n  char data;  // 结点的数据域，用来存储运算符或者操作数\n  struct node *left;  // 左子树指针\n  struct node *right;  // 右子树指针\n} Node;\n\n// 创建表达式二叉树的函数\nNode *create_expression_tree(const char *expression) {\n  // 定义栈，用来存储结点\n  Node *stack[100];\n  int top = -1;  // 栈顶指针\n\n  // 遍历表达式的每一个字符\n  for (int i = 0; expression[i] != '\\0'; i++) {\n    // 如果是数字，创建一个结点并将其压入栈中\n    if (isdigit(expression[i])) {\n      Node *node = (Node *) malloc(sizeof(Node));\n      node->data = expression[i];\n      node->left = node->right = NULL;\n      stack[++top] = node;\n    } else {\n      // 如果是运算符，从栈中弹出两个结点作为运算符的两个操作数\n      Node *node = (Node *) malloc(sizeof(Node));\n      node->data = expression[i];\n      node->right = stack[top--];\n      node->left = stack[top--];\n      // 将新创建的结点压入栈中\n      stack[++top] = node;\n    }\n  }\n\n  // 返回表达式二叉树的根结点\n  return stack[0];\n}\n\n// 使用后缀表达式的方式遍历二叉树并求值的函数\nint evaluate(Node *root) {\n  // 如果是叶子结点，直接返回数据域中存储的数字\nif (root->left == NULL && root->right == NULL) {\nreturn root->data - '0';\n}\n\n// 如果是二元运算符，则递归计算左右子树的值并进行计算\nint left = evaluate(root->left);\nint right = evaluate(root->right);\nswitch (root->data) {\ncase '+': return left + right;\ncase '-': return left - right;\ncase '*': return left * right;\ncase '/': return left / right;\n}\n\n// 其他情况返回0\nreturn 0;\n}\n\nint main() {\n// 创建表达式二叉树\nNode root = create_expression_tree(\"9+52-4/2\");\n\n// 计算并打印结果\nint result = evaluate(root);\nprintf(\"Result: %d\\n\", result);\n\nreturn 0;\n}\n\n\n希望Al有所帮助", "Konwledge_Point": "基本算术", "Question": "求一段代码，用c语言写\n利用二叉树求解表达式【基本功能】二叉树表示表达式的递归定义为：（1）若表达式为数或简单变量，则相应二叉树中仅有一个根结点，其数据域存放该表达式信息；（2）若表达式为“第一操作数 运算符 第二操作数”的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根结点的数据域存放运算符（若为一元运算符，则左子树为空），其中，操作数本身又为表达式对于任意一个算术表达式，都可以用二叉树来表示。表达式对应的二叉树创建后，利用二叉树的遍历操作，可实现表达式的求值运算。【基本要求】（1）设计表达式二叉树的创建与求值函数。（2）编写一个测试主函数。【提示】由于创建的表达式树需要准确的表达运算次序，因此在扫描表达式创建表达式树的过程中，当遇到运算符时不能直接创建结点，而应将其与前面的运算符进行优先级比较，根据比较的结果再进行处理。", "Tag": "算法分析"}
{"Answer": "供参考：\n#include <stdio.h>\n#include <string.h>\n\nvoid plus(double a, double b)\n{\n    printf(\"%g + %g = %g\\n\", a, b, a + b);\n}\nvoid minus(double a, double b)\n{\n    printf(\"%g - %g = %g\\n\", a, b, a - b);\n}\nvoid multiply(double a, double b)\n{\n    printf(\"%g * %g = %g\\n\", a, b, a * b);\n}\nvoid divide(double a, double b)\n{        \n    printf(\"%g / %g = %.2f\\n\", a, b, a / b);\n}\nint main(void)\n{\n    int  ret;\n    char in[64] = { 0 }, x[16], y[16], op[10];\n    double a, b;//参加运算的两个数\n    while (1)\n    {\n        gets(in);//输入算式\n        if (strcmp(in, \"exit\") == 0) break; //输入“exit”时，退出计算器\n        ret = sscanf(in, \"%[0-9.] %[^0-9. ] %[0-9.]\", x, op, y);\n        if (ret == 3) {\n            sscanf(x, \"%lf\", &a);\n            sscanf(y, \"%lf\", &b);\n            if (strcmp(op, \"+\") == 0)\n                plus(a, b);\n            else if (strcmp(op, \"-\") == 0)\n                minus(a, b);\n            else if (strcmp(op, \"*\") == 0)\n                multiply(a, b);\n            else if (strcmp(op, \"/\") == 0 && b != 0)\n                divide(a, b);\n            else\n                printf(\"error!Please input again.\\n\");\n        }\n        else\n            printf(\"error!Please input again.\\n\");\n    }\n    return 0;\n}\n\n", "Konwledge_Point": "基本算术", "Question": "（简单题）程序设计基础：简易计算器的设计（急，6.5号16：00截止哦）\n课题2.简易计算器的设计\n\n\n问题描述:能够实现两个数的算术运算功能(加、减、乘、除)\n\n\n1.基本要求\n\n\n(1)依次输入第一个操作数、运算符、第二个操作数，然后输出运算结果，例如\n\n\n输入: 13*8\n\n\n输出: 13*8=104\n\n\n(2)对错误的表达式有识别功能，例如输入: 12/0\n\n\n输出: error! Please input again.\n\n\n(3)除法运算的结果要保留小数位数2位;(4)当输入“exit”时，退出计算器;\n\n\n(5)利用函数调用的方法实现计算器的计算功\n\n\n能。\n\n\n附上整个系统数据结构的定义及系统源代码，各自定义函数的声明部分中，要求对主要变量的作用进行注释，语句部分中要求对关键语句进行注释，以方便阅读和理解程序。", "Tag": "算法分析"}
{"Answer": "软考有官方教材啊...考软考不能连这个都不知道.....把那本教材搞定就差不多了..\r\n\r\n主要的难点是数据结构跟UML,重点搞定这2个.\r\n\r\n重点，数据结构，算法，C语言，UML，面向对象设计。\r\n其他都不怎么难的..\r\n\r\n还有要学一下什么数据流程图,不过看官方教材就可以了.\r\n\r\n这种事情,问你们老师更好,多跟你们的老师交流一下,发个mail沟通下,他肯定可以给你们更多的信息,包括如何复习跟准备.", "Konwledge_Point": "基本算术", "Question": "请问大家一下，软件设计师考试怎么过啊！\n考试时间爱：5月23日。\n\n考试要求：\n\n(1) 掌握数据表示、算术和逻辑运算；\n\n(2) 掌握相关的应用数学、离散数学的基础知识；\n\n(3) 掌握计算机体系结构以及各主要部件的性能和基本工作原理；\n\n(4) 掌握操作系统、程序设计语言的基础知识，了解编译程序的基本知识；\n\n(5) 熟练掌握常用数据结构和常用算法；\n\n(6) 熟悉数据库、网络和多媒体的基础知识；\n\n(7) 掌握C程序设计语言，以及C++、Java、Visual Basic、Visual C++中的一种程序设计语言；\n\n(8) 熟悉软件工程、软件过程改进和软件开发项目管理的基础知识；\n\n(9) 熟悉掌握软件设计的方法和技术；\n\n(10) 掌握常用信息技术标准、安全性，以及有关法律、法规的基本知识；\n\n(11) 了解信息化、计算机应用的基础知识；\n\n(12) 正确阅读和理解计算机领域的英文资料。\n\n通过本考试的合格人员能根据软件开发项目管理和软件工程的要求，按照系统总体设计规格说明书进行软件设计，编写程序设计规格说明书等相应的文档，组织和指导程序员编写、调试程序，并对软件进行优化和集成测试，开发出符合系统总体设计要求的高质量软件；具有工程师的实际工作能力和业务水平。\n\n本考试设置的科目包括：\n\n(1) 计算机与软件工程知识，考试时间为150分钟，笔试；\n\n(2) 软件设计，考试时间为150分钟，笔试。\n\n\n\n截至作者发表，作者已经学过数据结构与算法，c，java，计算机组成原理的1/3（这学期学的课），数据库（自学）好了，离散\n\n\n\n有经验的过来人请指点一二，我想早点过\n\n[b]问题补充：[/b]\n\n看好几编？ 要多久啊！ 大伙能具体点说吗？有哪些重点的", "Tag": "算法分析"}
{"Answer": "发送英文测试一下", "Konwledge_Point": "基本算术", "Question": "单片机与sim900a实现发送中文短信不成功的问题\n\n\n#include\n#define uchar unsigned char\n#define uint unsigned int\ncode char str1[]=\"AT+CSQ\\r\\n\";\ncode char str2[]=\"AT+CSCS=\\\"UCS2\\\"\\r\\n\";\ncode char str3[]=\"AT+CMGF=1\\r\\n\";\ncode char str4[]=\"AT+CSMP=17,167,2,25\";\ncode char str5[]=\"AT+CMGS=\\\"00310037003800330032003100370032003000380033\\\"\\r\\n\";\ncode char str6[]=\"8B66544AFF0179EF6C348D859650\";\ncode char str7[]=\"AT+CMGD=1\";\nvoid DelaySec(int sec)\n{\n\tuint i,j=0;\n\n\tfor(i=0;i\ntypedef unsigned char uchar;\ntypedef unsigned int uint;\n//注意，无论接收到信号还是发送完信号，都会进中断服务程序的\n/*初始化程序（必须使用，否则无法收发），次程序将会使用定时器1*/\nvoid SerialInti(void)//初始化程序（必须使用，否则无法收发）\n{\n\tTMOD=0x21;//定时器1操作模式2:8位自动重载定时器\n\tTH1=0xfd;//装入初值，波特率9600\n\tTL1=0xfd;\n\tTR1=1;//打开定时器\n\tSM0=0;//设置串行通讯工作模式，（10为一部发送，波特率可变，由定时器1的溢出率控制）\n\tSM1=1;//(同上)在此模式下，定时器溢出一次就发送一个位的数据\n\tREN=1;//串行接收允许位（要先设置sm0sm1再开串行允许）\n\tEA=1;//开总中断\n\tES=1;//开串行口中断\t\n}\nvoid Uart1BYTE(uchar temp)\n{\n\t\tSBUF=temp;\n\t\twhile(!TI);//等待发送完成信号（TI=1）出现\n\t\tTI=0;\n\n}\n//串行口连续发送char型数组，遇到终止号/0将停止\nvoid Uart1Sends(uchar *str)\n{\n\twhile(*str!='\\0')\n\t{\n\t\twhile(!TI);//等待发送完成信号（TI=1）出现\n\t\tTI=0;\n\t\tstr++;\n\t}\n}\n\n//延时函数大概是1s钟\nvoid DelaySec(int sec)\n{\n\tuint i,j=0;\n\n\tfor(i=0;i\n#include\"main.h\"\n#include\"SIM900A.h\"\n\ntypedef unsigned char uchar;\ntypedef unsigned int uint;\n\nuint temp1[3];\nuchar count = 0;\n\n\nuint a1=0,Threshold1=15,Threshold2=20;\n//已用端口p0.0，p0.1，p0.2，p0.3，p0.4，p0.5，p0.6，p0.7，p2.7，p2.6\n//p0.0，p0.1（超声波）p0.2~p0.5（LCD）p2.0-2.3（按键）p0.6（DS18b20）\n\nvoid main(void)\n{\t\n\t\tinitc();//超声波初始化\n\t\tinit(); //lcd初始化\n\t\tSerialInti();\n\t\t\n\t\t\n\twhile(1)\n\t{\n\t\tswitch(P2)\n\t\t{\n\t\tcase 0xfe:{Threshold1=Threshold1+1;display1();break;}\n\t\tcase 0xfd:{Threshold1=Threshold1-1;display1();break;}\n\t\tcase 0xfb:{Threshold2=Threshold2+1;display2();break;}\n\t\tcase 0xf7:{Threshold2=Threshold2-1;display2();break;}\n\t\tdefault:break;\n\t\t}\n\t\twhile(count < 3)\n\t\t{\n\t\t\ttemp1[count]=loop();\n\t\t\tcount++;\t\t\n\t\t}\t\t\t\n\t\ta1 = (uint)(temp1[0] + temp1[1] + temp1[2]) / 3;\n\t\ta1=400-a1;\n\t\tcount = 0;\n\t\tif(a1>Threshold2)\n\t\t{\n\t\t\tSIM900A();\n\t\t\tdisplay();\n\t\t}\n\t\telse if(a1>Threshold1)\n\t\t{\n\t\t\tdisplay();//lcd显示程序\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdisplay();\n\t\t}\n\t\tdelay(3000);\n\t}\n}\t\t\t //0:加，1：减\nvoid Serial_interrupt() interrupt 4//串口中断 \n{\n\tif(RI)\n\tRI=0;//接收中断信号清零，表示将继续接收\n\tif(TI)\n\tTI=0;\n}\n\n\n\n\n就会导致超声波传感器运行异常，lcd也什么都不显示了，只因为调用了SIM900A()这个函数，是不是频繁进入中断影响了超声波传感器的运行？？？\n\n\n\n总之，求大佬给一个SIM900A发送中文短信的正确程序（用的是52单片机），并考虑加到我那个涵洞积水系统也可以正常发中文短信的。\n\n\n\n以下是其他部分的.c和.h程序（怕大佬分析时有需求，特意附上，别因为感觉多就。。。），没加sim900a.c前其他程序已经在单片机跑过了的。\n\n\n\n\n\n#include\n#include\n#include\"ds18b20.h\"\n#include\"csb.h\"\n#include\"lcd.h\"\ntypedef unsigned char uchar;\ntypedef unsigned int uint;\n/*定时器0初始化*/\nvoid initc(void)\n{\n\tTMOD=0x21;//，定时器0工作在模式一。00000001\n\tTH0=0;\n\tTL0=0;\n\tET0=1;\t\n\tEA=1;\n\tTR0 = 0;\n}\nvoid trigger(void)    //单片机输入切换电平启动\n{\n\tTRIGGER=0;\n\tTRIGGER=1;\n\t_nop_();_nop_();_nop_();_nop_();\n\t_nop_();_nop_();_nop_();_nop_();\n\t_nop_();_nop_();_nop_();_nop_();\n\t_nop_();_nop_();_nop_();_nop_();\n\tTRIGGER=0;\n\n} \n\nuint get_distance()\n{\n\tuint time = TH0*256+TL0;\n\tfloat distance;\n\tif(read_temperature() <= 10)\n\t{\n\t\tdistance = time * (330.45 * 100) / 2000000; \n\t}\n\telse if(read_temperature() <= 30)\n\t{\n\t\tdistance = time * (342.62 * 100) / 2000000;\n\t}\n\telse\n\t{\n\t\tdistance = time * (354.85 * 100) / 2000000;\n\t}\n\tTH0 = TL0 = 0;\n\treturn (uint)distance;\n}\n\t\nuint loop(void)\n{\n\ttrigger();\n\twhile(!ECH0);\n\tTR0=1;\n\twhile(ECH0);  \n\tTR0=0;\n \tdelay(200);//延时（大于200ms)\n\treturn get_distance();\n}\n\n\n\n\n\n/*超声波*/\n\n\n\n\n\n#include \n#include \"ds18b20.h\"\n\nvoid delay_18B20(unsigned int i)\n{\n\tfor(;i>0;i--);\n}\n\n\n//DS18B20芯片初始化\nvoid Init_DS18B20(void) \t\n{\n  unsigned char x=0;\n  DQ = 1;          //DQ拉高\n  delay_18B20(8);  //稍作延时\n  DQ = 0;          //DQ拉低\n  delay_18B20(80); //延时大于480us\n  DQ = 1;          //拉高总线\n  delay_18B20(14);\n  x=DQ;            //若x=0初始化成功，若x=1初始化失败\n  delay_18B20(20);\n}\n\n\n//通过单总线向DS18B20写一个字节\nvoid WriteOneChar(unsigned char dat)\n{\n  unsigned char i=0;\n  for (i=8;i>0;i--)\n  {\n   DQ=0;\n   DQ=dat&0x01;\n   if(DQ)\n\t{\n\t\tdelay_18B20(1);\n\t\tDQ=1;\n\t}\n\telse\n\t{\n\t\tdelay_18B20(5);\n\t\tDQ=1;\n\t}\n   dat>>=1;\t //算术右移\n   }\n}\n\n//从DS18B20读取一个字节\nunsigned char ReadOneChar(void) //给DQ 0，1切换信号后便会得到1位的数据反馈到DQ上\n  {\n    unsigned char i=0;\n    unsigned char dat=0;\n    for (i=8;i>0;i--)\n    {\n\t\tDQ=0; //拉低总线\n\t\tdat>>=1;//每读取移位向右移移位\n\t\tDQ=1; //拉高总线\n\t\tif(DQ)\n\t\tdat|=0x80;\t\t  //当DQ为1信号，软件将1赋给那一位\n\t\tdelay_18B20(4);\n    }\n     return(dat);\n  }\n\n\nunsigned char read_temperature(void)\n{\t\t\t\t\t\t\t \n unsigned char a = 0,b = 0,temp = 0;\n Init_DS18B20();\n WriteOneChar(0xCC);  // 跳过读序列号操作\n WriteOneChar(0x44);  // 启动温度转换\n delay_18B20(100);    // \n Init_DS18B20();\n WriteOneChar(0xCC);  //跳过读序列号操作\n WriteOneChar(0xBE);  //读取温度寄存器\n delay_18B20(100);\n a = ReadOneChar();     //读温度低位\n b = ReadOneChar();     //读温度高位\n temp = b;              // 以下部分和你的是一样的\n temp <<= 8;\n temp |= a;\n if(temp < 0x8000)      \n {\n\ttemp = ((b * 256 + a) >> 4);  // 完成的是十六进制转为10进制\t，右移4位去掉小数部分，精度12位\n }\t \n else\n {\n\ttemp = -((b * 256 + a) >> 4);\n }\n return(temp);\n}\n\n\n/*温度传感器*/\n\n\n\n\n\n#include\n#include\n#include\"lcd.h\"\n#include\"main.h\"\n#include\"ds18b20.h\"\ntypedef unsigned char uchar;\ntypedef unsigned int uint;                                    \nuchar code hanzi1[]={\"当前积\\xfd水深度为:\"};\nuchar code hanzi2[]={\"谨慎通行!\"};\nuchar code Temp[]={\"温度:\"};\nuchar code Threshold_A[]={\"阈值A:\"};\nuchar code Threshold_B[]={\"阈值B:\"};\nvoid delay(uint y)                                //单位：1ms\n{\tuint z;\n\tuchar x;\n\tfor(z=0;zThreshold1)\n\t{\n\t\twrite_command(0x88);\n\t\tfor(j=0;j<9;j++)\n\t\t{\n\t\t\twrite_data(hanzi2[j]);\n\t\t}\n\t}\n\twrite_command(0x98);\n\tfor(i=0;i<6;i++)\n\t{\n\t\twrite_data(Temp[i]);   // 显示温度提示\n\t}\n\ttemp[0]=temperature/10+0x30;\n\ttemp[1]=temperature%10+0x30;\n\twrite_command(0x98+5);       // 显示温度值\n\tfor(i=0;i<2;i++)\n\t{\n\t\twrite_data(temp[i]);\n\t}\n}\nvoid display1(void)\n{\n\tuchar i;\n\tinit();\n\twrite_command(0x98);\n\tfor(i=0;i<6;i++)\n\t{\n\t\twrite_data(Threshold_A[i]);\n\t}\n\twrite_data(Threshold1/10+0x30);\n\twrite_data(Threshold1%10+0x30);\n\n}\nvoid display2(void)\n{\n\tuchar i;\n\tinit();\n\twrite_command(0x98);\n\tfor(i=0;i<6;i++)\n\t{\n\t\twrite_data(Threshold_B[i]);\n\t}\t\t\t     \n\twrite_data(Threshold2/10+0x30);\n\twrite_data(Threshold2%10+0x30);\n}\n\n\t/*lcd12864*/\n\n\n\n\n ", "Tag": "算法分析"}
