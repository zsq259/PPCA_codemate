{"Answer": "整数划分的递归关系是通过分析整数划分的性质和规律得出的。\n整数划分是将一个正整数拆分成若干个正整数，使得它们的和等于原数的过程。例如，对于整数4，它的不同划分方式有：\n43 + 12 + 22 + 1 + 11 + 1 + 1 + 1\n通过观察这些划分，我们可以发现：\n对于划分中的每个数，它必须小于等于原数。划分中可以有重复的数，如上例中的2 + 2。划分中的数是无序的，如上例中的3 + 1和1 + 3是相同的划分。\n基于这些性质，我们可以得出整数划分的递归关系：\n设p(n)表示将整数n拆分成若干个正整数的划分总数，则：\n如果划分中最大的数是1，则问题转化为将n拆分成n个数的和，即p(n) = 1 + p(n-1)。如果划分中最大的数大于1，则问题转化为将n拆分成最大数为k的数的和，其中k可以从1到n-1取值。因此，p(n) = p(n-1) + p(n-2) + ... + p(n-k)。\n这样，我们就可以使用递归的方式求解整数划分问题。", "Konwledge_Point": "递归关系", "Question": "整数划分的递归关系是怎么讨论出来的\n整数划分的递归关系是怎么讨论出来的？有人给我说说吗，看不懂书上说啥？\n\n", "Tag": "算法分析"}
{"Answer": "\nI have solved it like this, but I am not sure that it is a correct way:\ntype Organization struct {\n\n    gorm.Model\n\n    Parent *Organization\n    ParentId int `gorm:\"TYPE:integer REFERENCES organizations\"`\n    Name string `gorm:\"size:30\"`\n    Description string `gorm:\"size:100\"`\n}\n\n", "Konwledge_Point": "递归关系", "Question": "GORM中的一对多递归关系\n\n\n\nI need to have an \nOrganization\n which have relation to parent one. Something like this:\n\n\n\ntype Organization struct {\n\n    gorm.Model\n\n    Parent *Organization `gorm:\"ForeignKey:ParentId\"`\n    Name string `gorm:\"size:30\"`\n    Description string `gorm:\"size:100\"`\n}\n\n\n\n\nI want to have \nParentId\n field which will be referenced to \nid\n field in the same table. But as I see there is no field and relation.\n\n\n\nHow can I fix it ?\n\n    ", "Tag": "算法分析"}
{"Answer": "\nI got my answer in:  \nlaracasts.com/discuss\nThis is relationship that I must be added:\npublic function embed()\n{\n    return $this->belongsTo(Reply::class, 'embed_reply');\n}\n\nand this for fetching that :\n$reply = Reply::find($reply_id);\n$embed = $reply->embed;\n\n", "Konwledge_Point": "递归关系", "Question": "在laravel 5中以递归关系包含回复\n\n\n\nI have a table named \nreplies\n contains all replies of a topic in a Forum laravel application. \n\n\n\n**replies Table**\n---------------\n    reply_id\n    content\n    topic_id\n    reply_by\n    embed_reply\n    created_at\n    updated_at\n\n\n\n\nreplies can have another reply Herself.for that there is \nembed_reply\n column that hold \nreply_id\n of included reply.\n\n\n\nNow I want details of included reply would have existed on the parent Reply on fetching.\n\n\n\nfor that i add this Method to reply Model :\n\n\n\npublic function included_reply ()\n        {\n            return $this->with('replies', function ($query) {\n                $query->where('reply_id',$this->embed_reply);\n            });\n        }\n\n\n\n\nAnd for fetching replies of a specific Topic, I wrote this :\n\n\n\n$topic = Topic::whereTopicId($id)\n                ->with([\n                    'replies' => function ($query) {\n                        $query->orderBy('created_at', 'desc');\n                    }\n                    , 'replies.included_reply'\n                ])\n                ->first();\n\n\n\n\nall of this return bellow Error:\n\n\n\nBadMethodCallException in Builder.php line 2071:\nCall to undefined method Illuminate\\Database\\Query\\Builder::replies()\n\n\n\n\nand I do not know how to do that.\nwhat is solution?\n\n    ", "Tag": "算法分析"}
{"Answer": "如果不考虑兄弟姐妹的话如下：找到A的父母2人，祖父母4人(父母的父母)，曾祖父母8人(父母的父母的父母)同理找到B的父母、祖父母、曾祖父母\n判断他们每一代是否有重复即可，流程上能够从父母辈开始判断有重复即结束，是否向上继续追溯祖父母，同理无重复再追溯曾祖父母", "Konwledge_Point": "递归关系", "Question": "如何使用递归解决血缘关系判断？\n我最近在做一个养猪场项目，有一个需求是当公猪与母猪配种时，要查询两头猪在四代以内是否有血缘关系，如果有则提示。我现在可以通过猪的特定标识在数据库表中找到它的父母，后面应该要如何去实现这个四代比对过程呢？这个需求我大概思路是用递归来做，请教高人们这个需要怎么做？递归是在sql里做判断还是在java代码端做判断？具体怎么做？最好有个代码示例", "Tag": "算法分析"}
{"Answer": "不需要使用递归，城市编号是有规律的，按城市编号模糊查询即可。", "Konwledge_Point": "递归关系", "Question": "sql的关联递归查询问题\n有俩张数据表。\n其中地区表 dq_tab，数据类似如下：\n地区           地区代码         上级地区代码\ndq                dq_dm             sjdq_dm\n北京市          010000            000000\n海淀区          010100            010000\n江苏省          020000            000000\n南京市          020100            020000\n鼓楼区          020101            020100\n江宁区          020103            020100\n也就是说，全国各省或直辖市，对应的sjdq_dm（上级地区代码），为000000。表中数据有递归关系。\n\n\n另外有一张员工表  yg_tab：\n姓名                    地区代码\nxm                      dq_dm\n张三                    010000\n李四                    020103\n王五                    020100\n赵六                    020100\n也就是说，该员工表，和上面的地区表，有关联关系，通过dq_dm(地区代码)字段相关联。一个员工必定属于一个地区。\n\n\n那么，我想查询各省或直辖市，分别有多少员工，怎么查询？\n虽然可以通过start with语句，一个省一个省的查，但全国那么多省，分N次查询太累人。\n请问，有没有一条语句，就可以查询出全部结果的？", "Tag": "算法分析"}
{"Answer": "提问者是按递归的思路来实现阶乘的，所以每有一次阶乘，都需要调用很多次f，随着你输入的n越来越大，极大量的函数调用入栈会占用特别多的资源，导致最终一直在入栈没有出栈，因为只有最底层的f运行完，才会一个接着一个出栈，所有最终内存提供资源崩溃时就无法执行了，由保集成环境的护机制强制退出", "Konwledge_Point": "递归关系", "Question": "用递归关系求1！+2！+……+n!  从4开始，运行时就停止工作，为什么啊？\n实现 输入n,求1！+2！+……+n!=?\n\n\n\n小白一只，请教各位，下面这个程序，输入1，2，3都没问题，输入>4的数运行后就停止工作，这是为什么啊？代码有什么问题吗？\n\n\n\n#include \"stdafx.h\"\n#include \n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    int add(int x);\n    int f(int m);\n    int a,b;\n    printf(\"input an integer:\");\n    scanf(\"%d\",&a);\n    b=add(a);\n    printf(\"output:%d\",b);\n    return 0;\n}\nint add(int x)\n{\n    int f(int m);\n    int y;\n    if(x==1)\n        y=1;\n    else y=f(x)+add(f(x-1));\n    return(y);\n}\nint f(int m)\n{\n    int n;\n    if(m==1)\n        n=1;\n    else n=f(m-1)*m;\n    return(n);\n}\n\n\n\n", "Tag": "算法分析"}
{"Answer": "CREATE FUNCTION func(M INT,N INT) RETURNS varchar(50)\nBEGIN\n  DECLARE str varchar(50) DEFAULT '';\n  DECLARE p int DEFAULT 0;\n    DECLARE u int DEFAULT 0;\n  DECLARE count int DEFAULT 0;\n    set p = N;\n  set u = M;\n  set count = 0;\n    if p = 0 Then\n     set str = concat(u,'');\n  end if;\n  while p != 0 do\n\n    select uid into u from a where pid = p and uid = u;\n  select pid into p from a where pid = p and uid = u;\n      if p = 0 THEN\n      set p = 0;\n    else \n      if count = 0 THEN\n                    set str = concat(p,\"->\",u,str);\n      else\n          set str = concat(p,\"->\",str);\n      end if;\n        end if;\n    set u = p;\n    set count= count+1;\n        select pid into p from a where uid = u;\n   end while;\n \n  RETURN (\n      # Write your MySQL query statement below.\n        str\n      );\nEND;\n\n\n", "Konwledge_Point": "递归关系", "Question": "MYSQL 5.8 如何递归查询路径 举例如下\n一个表ABC  ，两列UID 和PID ，  现在需要得到UID 与PID 的路径关系如下：\n这个是用SQLSERVER的 with as 递归查询语句得出的结果。 请问 用MYSQL 语句如何得出这个结果。请给出MYSQL 的查询语句。", "Tag": "算法分析"}
{"Answer": "楼主那样实现的话逻辑会有点问题，刚才写了一段代码，可以实现楼主所说的功能，供楼主作一个参考吧：\r\n/**标签元素类.\r\n_atts是由{attName:'name',attValue:'value'}形式的对象组成的数组.*/\r\nfunction Element(_tagName,_atts){\r\n\tthis.tagName=_tagName;//标签名.\r\n\tthis.atts=_atts||[];//属性.\r\n\tthis.childNodes=[];//子标签.\r\n}\r\n\r\n/**添加子节点.\r\n_element:子节点,Element类的对象.*/\r\nElement.prototype.appendChild=function(_element){\r\n\tthis.childNodes.push(_element);\r\n}\r\n\r\n/**给元素添加属性.\r\n_attName:属性名,_attValue:属性值.*/\r\nElement.prototype.addAttribute=function(_attName,_attValue){\r\n\tthis.atts.push({attName:_attName,attValue:_attValue});\r\n}\r\n\r\n/**将Element对象转换为XML形式的字符串.*/\r\nElement.prototype.parseToXML=function(){\r\n\tvar xml=[];\r\n\txml.push(\"\");\r\n\tfor(var i=0;i\"+this.atts[i].attValue+\"\");\r\n\t}\r\n\tfor(var i=0;i\");\r\n\treturn xml.join(\"\\n\");//组成字符串并返回.\r\n}\r\n调用方法如下：\r\nvar body=new Element(\"BODY\");\r\nvar table=new Element(\"TABLE\",[{\r\n\t\t\tattName:\"border\",\r\n\t\t\tattValue:\"0\"\r\n\t\t},{\r\n\t\t\tattName:\"width\",\r\n\t\t\tattValue:\"100%\"\r\n\t\t}]);\r\nvar tr = new Element(\"TR\");\r\nvar td = new Element(\"TD\");\r\ntd.addAttribute(\"border\",\"1px\");\r\ntd.addAttribute(\"gbColor\",\"red\");\r\ntr.appendChild(td);\r\ntable.appendChild(tr);\r\nbody.appendChild(table);\r\nalert(body.parseToXML());//输出xml字符串", "Konwledge_Point": "递归关系", "Question": "javascript递归时出现死循环，该如何解决\nfunction Condition(tagName,attrName,attrValue)\n{\n    \n    this.tagName=tagName;\n    this.middleStart=\"\";\n    this.middleEnd=\"\"\n    this.child=null;\n    this.childResult=\"\";\n    \n}\n\nCondition.prototype.addChild=function(childCondition)\n{\n    this.child=childCondition;\n    this.childResult=this.child.showXml();\n}\n\nCondition.prototype.getChild=function()\n{\n    if(this.child==null)\n    {\n        return this;\n    }\n    else\n    {\n        return this.getChild();//这里是递归\n    }\n}\n\nCondition.prototype.showXml=function()\n{\n    return this.middleStart+this.childResult+this.middleEnd;\n}\n\nfunction test1()\n{   \n    var con=new Condition(\"table\",null,null);\n    var con1=new Condition(\"tr\",null,null);\n    var con2=new Condition(\"td\",null,null);\n    var child1=con.getChild();\n    child1.addChild(con1);\n    var child2=con.getChild();\n    child2.addChild(con2);\n    var child3=con.getChild();\n    alert(con.showXml());\n}\n\n\n\n \n问题补充：\n这个程序的功能主要是向服务器端的xml文件写入数据，这个xml文件里面描述了html页面的元素结构，比如html文件是这样:\n,则对应的此xml文件则是:\n\n1\n\n\n\n\n该xml文件是在服务器端读取后封装成HtmlParser框架过滤网页内容时用的条件，以上的javascript代码就是用来生成这个XML文件的，因为HTML页面的层次有很多层，需要描述任意层次的HTML节点关系", "Tag": "算法分析"}
{"Answer": "这个堆栈溢出看异常信息应该是页面有关,请从页面相关内容进行排查.应该是和thymeleaf标签使用有问题.如有帮助,欢迎采纳!", "Konwledge_Point": "递归关系", "Question": "java.lang.StackOverflowError null（栈溢出异常）\n问题：java.lang.StackOverflowError null（栈溢出异常）\n遇到这个问题，首先想了下，可能是忘记在service 层忘加 \n@service \n注解或者 \n@Autowired \n注解了\n在检查后，发现还是不得行\n\n\n后来去博客了解了：就是当多个实体类之间有多对一、多对多 关系时，重写 toString 方法的时候一定要注意，不要两个有对应关系的实体类都重写相关联属性字段的 toString 方法，这样会导致一直递归重写下去，内存当然会被耗尽，导致栈溢出\n\n\n我遇到的栈溢出截图如下：\n\n\n但是一直没找到出错原因在哪，希望能帮忙解答一下，十分感谢～🙏", "Tag": "算法分析"}
{"Answer": "\nYou should try to group the childs of the items, so you can identify which items has \"fathers\" and which not. I made a sample with your code, but you can also some array_filter to improve it:\n<?php\n    $tasks[] = array(\"id\" => 1, \"parent_id\" => 0, \"title\" => 'task 1');\n    $tasks[] = array(\"id\" => 2, \"parent_id\" => 1, \"title\" => 'sub task 1');\n    $tasks[] = array(\"id\" => 3, \"parent_id\" => 1, \"title\" => 'sub task 2');\n    $tasks[] = array(\"id\" => 5, \"parent_id\" => 2, \"title\" => 'task 2');\n    $tasks[] = array(\"id\" => 4, \"parent_id\" => 2, \"title\" => 'sub sub task 1');\n    $tasks[] = array(\"id\" => 6, \"parent_id\" => 2, \"title\" => 'sub task 3');\n    $tasks[] = array(\"id\" => 7, \"parent_id\" => 6, \"title\" => 'sub task of 6');\n    $branch = array();\n\n    function buildTree(array $elements, array $branch, $parentId=0) {\n        // group elements by parents if it does not comes on the parameters\n        if (empty($branch)) {\n            $branch = array();\n\n            foreach ($elements as $element) {\n                $branch[$element[\"parent_id\"]][$element[\"id\"]] = $element;\n            }\n        }\n\n        // echo the childs referenced by the parentId parameter\n        if (isset($branch[$parentId])) {\n            echo'<ul>';\n\n            foreach ($branch[$parentId] as $keyBranch => $itemBranch) {\n                echo '<li>'.$itemBranch['title'];\n                buildTree($elements, $branch, $itemBranch[\"id\"]); // iterate with the actual Id to check if this record have childs\n                echo '</li>';\n            }\n\n            echo '</ul>';\n        }\n    }\n\n    buildTree($tasks, array());\n?>\n\n", "Konwledge_Point": "递归关系", "Question": "PHP递归数组：正确显示父和子\n\n\n\nI want to make parent to be new \"ul\" and child \"li\" item,but obviously parent will have to be \"li\" and \"ul\" too at the same time,bcz i want to build \"parent child relationship list\" with tree principle, child will be a parent of another element too and that will create another subcategory and etc... so how would you have done it correctly? if you couldn't understand something... ask.  In image i just display how it should look like,simple tree\n\n\n\n 1, \"parent_id\" => 0, \"title\" => 'task 1');\n$tasks[] = array(\"id\" => 2, \"parent_id\" => 1, \"title\" => 'sub task 1');\n$tasks[] = array(\"id\" => 3, \"parent_id\" => 1, \"title\" => 'sub task 2');\n$tasks[] = array(\"id\" => 4, \"parent_id\" => 2, \"title\" => 'sub sub task 1');\n$tasks[] = array(\"id\" => 5, \"parent_id\" => 2, \"title\" => 'task 2');\n$tasks[] = array(\"id\" => 6, \"parent_id\" => 2, \"title\" => 'sub task 3');\n$branch = array();\nfunction buildTree(array &$elements, $parentId = 0) {\n    $branch = array();\n    foreach ($elements as &$element) {\n        if ($element['parent_id'] == $parentId) {\n            $children = buildTree($elements, $element['id']);\n            if ($children) {\n                $element['children'] = $children;\n                // $element['parent']=$element['title'];\n                print_r($element['id']);\n                foreach($element['children'] as $child){\n                    if($element['id']==$child['parent_id']){\n                    echo '';\n                    echo ''.$child['title'].'';\n                    echo '';\n                    }\n                }\n            }\n            $branch[$element['id']] = $element;\n        }\n    }\n    return $branch;\n}\nprint_r(buildTree($tasks));\n?>\n\n\n    ", "Tag": "算法分析"}
{"Answer": "这是除号性质的问题，即使这个函数中的返回值是double类型的，但是你在return的时候是进行一个计算，也就是1除以2, 1/2得到的结果是0，即使在计算完1/2之后返回调用点的时候，返回的也是0而不是你想要的0.5", "Konwledge_Point": "递归关系", "Question": "递归问题。。。。。。。\n\n请问下为什么第6行写1/2得到的是n-1应该得到的答案，而写了0.5得到的就是正确的呢", "Tag": "算法分析"}
{"Answer": "有个隐藏的条件，就是鱼的数量在任何时候都必须是整数，而且最后剩下的鱼的数量最少是4条（最后一个渔夫拿走1/5，也就是1条）。所以从F(0)=4开始累加计算，F(n+1)=F(n)*5/4+1，如果有任何一个F(n)是小数，则回溯到F(0)自加4（因为必须能被4整除），再重复递推。用Python实现如下，C++的实现交给其他同学了\ndef fish(n):\n    last=t=4\n    while True:\n        for _ in range(n):\n            if int(t)<t:break\n            t=t*5/4+1\n        if int(t)==t:\n            break\n        else:\n            last += 4\n            t = last\n    return int(t)\n\nprint(fish(5))\n", "Konwledge_Point": "递归关系", "Question": "捕鱼问题（递归找规律）\n题目名称：捕鱼问题\n题目描述：A，B，C，D，E五个渔夫夜间合伙捕鱼，,第二天清A先醒来，他把鱼均分五份，把多余的一条扔回湖中，\n便拿了自己的一份回家了，B醒来后，也把鱼均分五份，把多余的一条扔回湖中，便拿了自己的一份回家了，\nC,D,E也按同样方法分鱼。问5人至少捕到多少条鱼？\n（ 这也是一个递推问题，递推关系式为   F(n+1) = F(n)*5/4+1  (i = 1,2,3,4)  F(5)即捕鱼的总数）\n输入描述：无\n输出描述：F(5)即捕鱼的总数。\n\n\n样例输入：\n无\n样例输出：\n3121\n\n\n说明：无输入", "Tag": "算法分析"}
{"Answer": "这样的话，\r\n检索出数据放到list中list_bak中，\r\n遍历list,检索出一条，然后根据wbs_code到list_bak查找父id(遍历list_bak)", "Konwledge_Point": "递归关系", "Question": "POI导入含父子结构的EXCEL数据\njava中，如何导入具有父子关系的Excel数据到数据库中，父子关系在Excel有体现，导入后父子关系自动生成到数据库中，向各位大侠请教？\n\n\n\n示例EXCEL数据如下：\n\n\n\nWBS分类码    WBS名称             父WBS分类码\n\n\n\nSW                物资设备采购       NRG00870 （NRG00870为根父类码，存入时为根父类码的Id）\n\nPS                 基础施工              NRG00870\n\n69KV             结构施工              NRG00870.PS  (PS的子数据，存入时为PS的Id)\n\nHD                机电安装              NRG00870.PS\n\nPSU              门窗安装              NRG00870.PS.HD   （HD的子数据，存入时为HD的Id）\n\nCVC              内部装修              NRG00870.PS.HD", "Tag": "算法分析"}
{"Answer": "   public static void main(String[] args) throws Exception {\n        String str =\"{\\\"result\\\":[{\\\"MINX\\\":\\\"118.02250279\\\",\\\"UPDATETIME\\\":\\\"20180703\\\",\\\"MINY\\\":\\\"27.04543333\\\",\\\"SHORTNAME\\\":\\\"\\\",\\\"LABELY\\\":\\\"29.11397432\\\",\\\"LABELX\\\":\\\"120.58933477\\\",\\\"OID\\\":\\\"330000-000-2120-浙江省\\\",\\\"NAME\\\":\\\"浙江省\\\",\\\"OBJECTID\\\":\\\"330000-000-2120-浙江省\\\",\\\"CENTERX\\\":\\\"120.58933477\\\",\\\"CODE\\\":\\\"330000000\\\",\\\"CITY\\\":\\\"\\\",\\\"TOWN\\\":\\\"\\\",\\\"children\\\":[{\\\"MINX\\\":\\\"118.33967503\\\",\\\"UPDATETIME\\\":\\\"20180629\\\",\\\"MINY\\\":\\\"29.1885947\\\",\\\"SHORTNAME\\\":\\\"\\\",\\\"LABELY\\\":\\\"29.87685909\\\",\\\"LABELX\\\":\\\"119.52685481\\\",\\\"OID\\\":\\\"330100-000-2130-杭州市\\\",\\\"NAME\\\":\\\"杭州市\\\",\\\"OBJECTID\\\":\\\"330100-000-2130-杭州市\\\",\\\"CENTERX\\\":\\\"119.52685481\\\",\\\"CODE\\\":\\\"330100000\\\",\\\"CITY\\\":\\\"\\\",\\\"TOWN\\\":\\\"\\\",\\\"children\\\":[{\\\"MINX\\\":\\\"120.13241596\\\",\\\"UPDATETIME\\\":\\\"201612\\\",\\\"MINY\\\":\\\"30.19538921\\\",\\\"SHORTNAME\\\":\\\"\\\",\\\"LABELY\\\":\\\"30.22807413\\\",\\\"LABELX\\\":\\\"120.17105609\\\",\\\"OID\\\":\\\"330102-000-2140-上城区\\\",\\\"NAME\\\":\\\"上城区\\\",\\\"OBJECTID\\\":\\\"330102-000-2140-上城区\\\",\\\"CENTERX\\\":\\\"120.17105609\\\",\\\"CODE\\\":\\\"330102000\\\",\\\"CITY\\\":\\\"杭州市\\\",\\\"TOWN\\\":\\\"\\\",\\\"children\\\":[{\\\"MINX\\\":\\\"120.14936765\\\",\\\"UPDATETIME\\\":\\\"201612\\\",\\\"MINY\\\":\\\"30.23018409\\\",\\\"SHORTNAME\\\":\\\"\\\",\\\"LABELY\\\":\\\"30.23930124\\\",\\\"LABELX\\\":\\\"120.15866596\\\",\\\"OID\\\":\\\"330102-000-2150-清波街道\\\",\\\"NAME\\\":\\\"清波街道\\\",\\\"OBJECTID\\\":\\\"330102-000-2150-清波街道\\\",\\\"CENTERX\\\":\\\"120.15866596\\\",\\\"CODE\\\":\\\"330102001\\\",\\\"CITY\\\":\\\"杭州市\\\",\\\"TOWN\\\":\\\"\\\",\\\"children\\\":[{\\\"MINX\\\":\\\"120.16431845\\\",\\\"UPDATETIME\\\":\\\"201612\\\",\\\"MINY\\\":\\\"30.24266719\\\",\\\"SHORTNAME\\\":\\\"\\\",\\\"LABELY\\\":\\\"30.24266719\\\",\\\"LABELX\\\":\\\"120.16431845\\\",\\\"OID\\\":\\\"330102-000-2216-清河坊社区\\\",\\\"NAME\\\":\\\"清河坊社区\\\",\\\"OBJECTID\\\":\\\"330102-000-2216-清河坊社区\\\",\\\"CENTERX\\\":\\\"120.16431845\\\",\\\"CODE\\\":\\\"\\\",\\\"CITY\\\":\\\"杭州市\\\",\\\"TOWN\\\":\\\"清波街道\\\",\\\"MAXY\\\":\\\"30.24266719\\\",\\\"CENTERY\\\":\\\"30.24266719\\\",\\\"MAXX\\\":\\\"120.16431845\\\",\\\"ADDRESS\\\":\\\"浙江省杭州市上城区清波街道\\\",\\\"SECTIONTYPE\\\":\\\"五级行政区域（行政村）\\\",\\\"PROVINCE\\\":\\\"浙江省\\\",\\\"FULLNAME\\\":\\\"浙江省杭州市上城区清波街道清河坊社区\\\",\\\"COUNTY\\\":\\\"上城区\\\"}]}]}]}]}]}\";\n        parse(JSON.parseObject(str).getJSONArray(\"result\"),\"children\");\n\n    }\n\n    private static void parse(JSONArray jsonArray, String childFiledName){\n        if(jsonArray == null || jsonArray.size() == 0){\n            return;\n        }\n        JSONArray arr = null;\n        for (int i=0;i<jsonArray.size();i++){\n            JSONObject jsonObject = jsonArray.getJSONObject(i);\n            arr = null;\n            for (Map.Entry<String, Object> entry : jsonObject.entrySet()) {\n                if(Objects.equals(entry.getKey(),childFiledName)){\n                    arr = jsonObject.getJSONArray(childFiledName);\n                    continue;\n                }\n                System.out.print(entry.getKey()+\":\"+entry.getValue()+\"\\t\");\n            }\n            if(arr == null){\n                continue;\n            }\n            System.out.println(\"\\n下一层\");\n            parse(arr,childFiledName);\n        }\n    }\n", "Konwledge_Point": "递归关系", "Question": "java如何给具有层级关系的json字符串做递归\nJSON字符串如下：\n\n\n{\n\n\"result\"\n:[\n{\n  \n\"MINX\"\n: \n\"118.02250279\"\n,\n  \n\"UPDATETIME\"\n: \n\"20180703\"\n,\n  \n\"MINY\"\n: \n\"27.04543333\"\n,\n  \n\"SHORTNAME\"\n: \n\"\"\n,\n  \n\"LABELY\"\n: \n\"29.11397432\"\n,\n  \n\"LABELX\"\n: \n\"120.58933477\"\n,\n  \n\"OID\"\n: \n\"330000-000-2120-浙江省\"\n,\n  \n\"NAME\"\n: \n\"浙江省\"\n,\n  \n\"OBJECTID\"\n: \n\"330000-000-2120-浙江省\"\n,\n  \n\"CENTERX\"\n: \n\"120.58933477\"\n,\n  \n\"CODE\"\n: \n\"330000000\"\n,\n  \n\"CITY\"\n: \n\"\"\n,\n  \n\"TOWN\"\n: \n\"\"\n,\n  \n\"children\"\n: [\n    {\n      \n\"MINX\"\n: \n\"118.33967503\"\n,\n      \n\"UPDATETIME\"\n: \n\"20180629\"\n,\n      \n\"MINY\"\n: \n\"29.1885947\"\n,\n      \n\"SHORTNAME\"\n: \n\"\"\n,\n      \n\"LABELY\"\n: \n\"29.87685909\"\n,\n      \n\"LABELX\"\n: \n\"119.52685481\"\n,\n      \n\"OID\"\n: \n\"330100-000-2130-杭州市\"\n,\n      \n\"NAME\"\n: \n\"杭州市\"\n,\n      \n\"OBJECTID\"\n: \n\"330100-000-2130-杭州市\"\n,\n      \n\"CENTERX\"\n: \n\"119.52685481\"\n,\n      \n\"CODE\"\n: \n\"330100000\"\n,\n      \n\"CITY\"\n: \n\"\"\n,\n      \n\"TOWN\"\n: \n\"\"\n,\n      \n\"children\"\n: [\n        {\n          \n\"MINX\"\n: \n\"120.13241596\"\n,\n          \n\"UPDATETIME\"\n: \n\"201612\"\n,\n          \n\"MINY\"\n: \n\"30.19538921\"\n,\n          \n\"SHORTNAME\"\n: \n\"\"\n,\n          \n\"LABELY\"\n: \n\"30.22807413\"\n,\n          \n\"LABELX\"\n: \n\"120.17105609\"\n,\n          \n\"OID\"\n: \n\"330102-000-2140-上城区\"\n,\n          \n\"NAME\"\n: \n\"上城区\"\n,\n          \n\"OBJECTID\"\n: \n\"330102-000-2140-上城区\"\n,\n          \n\"CENTERX\"\n: \n\"120.17105609\"\n,\n          \n\"CODE\"\n: \n\"330102000\"\n,\n          \n\"CITY\"\n: \n\"杭州市\"\n,\n          \n\"TOWN\"\n: \n\"\"\n,\n          \n\"children\"\n: [\n            {\n              \n\"MINX\"\n: \n\"120.14936765\"\n,\n              \n\"UPDATETIME\"\n: \n\"201612\"\n,\n              \n\"MINY\"\n: \n\"30.23018409\"\n,\n              \n\"SHORTNAME\"\n: \n\"\"\n,\n              \n\"LABELY\"\n: \n\"30.23930124\"\n,\n              \n\"LABELX\"\n: \n\"120.15866596\"\n,\n              \n\"OID\"\n: \n\"330102-000-2150-清波街道\"\n,\n              \n\"NAME\"\n: \n\"清波街道\"\n,\n              \n\"OBJECTID\"\n: \n\"330102-000-2150-清波街道\"\n,\n              \n\"CENTERX\"\n: \n\"120.15866596\"\n,\n              \n\"CODE\"\n: \n\"330102001\"\n,\n              \n\"CITY\"\n: \n\"杭州市\"\n,\n              \n\"TOWN\"\n: \n\"\"\n,\n              \n\"children\"\n: [\n                {\n                  \n\"MINX\"\n: \n\"120.16431845\"\n,\n                  \n\"UPDATETIME\"\n: \n\"201612\"\n,\n                  \n\"MINY\"\n: \n\"30.24266719\"\n,\n                  \n\"SHORTNAME\"\n: \n\"\"\n,\n                  \n\"LABELY\"\n: \n\"30.24266719\"\n,\n                  \n\"LABELX\"\n: \n\"120.16431845\"\n,\n                  \n\"OID\"\n: \n\"330102-000-2216-清河坊社区\"\n,\n                  \n\"NAME\"\n: \n\"清河坊社区\"\n,\n                  \n\"OBJECTID\"\n: \n\"330102-000-2216-清河坊社区\"\n,\n                  \n\"CENTERX\"\n: \n\"120.16431845\"\n,\n                  \n\"CODE\"\n: \n\"\"\n,\n                  \n\"CITY\"\n: \n\"杭州市\"\n,\n                  \n\"TOWN\"\n: \n\"清波街道\"\n,\n                  \n\"MAXY\"\n: \n\"30.24266719\"\n,\n                  \n\"CENTERY\"\n: \n\"30.24266719\"\n,\n                  \n\"MAXX\"\n: \n\"120.16431845\"\n,\n                  \n\"ADDRESS\"\n: \n\"浙江省杭州市上城区清波街道\"\n,\n                  \n\"SECTIONTYPE\"\n: \n\"五级行政区域（行政村）\"\n,\n                  \n\"PROVINCE\"\n: \n\"浙江省\"\n,\n                  \n\"FULLNAME\"\n: \n\"浙江省杭州市上城区清波街道清河坊社区\"\n,\n                  \n\"COUNTY\"\n: \n\"上城区\"\n\n                }]\n            }]\n        }]\n    }]   \n}]\n\n\n\n\n上述代码的children有层层嵌套的关系，请问如何用java递归处理成一个对象数组？ ", "Tag": "算法分析"}
{"Answer": "\nWhy are you trying to build a full ORM? That way will lead to madness. \nSo, your user has multiple roles and each role has multiple permissions and you want to load it all. So why don't you do it this way:\n$roles = new Entity\\RoleCollection;\n$roles->forUser(new Entity\\User($id));\n// note: you really do not need to fetch user :)\n\n$roleMapper = new Mapper\\RoleCollection($pdo);\n$roleMmapper->fetch($roles);\n// populates the roles; if user is set, populates by user \n\n$permissionMapper = Mapper\\RoleCollectionPermissions($pdo);\n$permissionMapper->fetch($roles);\n// populates the permission collections inside each of role collection entry \n\nBasically, if you are good at SQL, this will require only two queries. And this way there isn't really any magic as long as you stick to (at least partially) clear naming scheme for your mappers. You only fetch the parts that you need. \nAnd, if you actually needed the permissions and the roles are just an intermediary for that goals, just make it simpler: \n$permissions = new PermissionCollection;\n$permissions->forUser(new Entity\\User($id))\n\n$permissionMapper = Mapper\\PermissionCollection($pdo);\n$permissionMapper->fetch($permissions);\n\nHave a two-deep join in the mapper, if the permission collection has a user class assigned as a condition. \nIf you started out with ORMs, then it seems like the natural to make recursive loaders, that populate everything. But that not how you write data mappers. It's how you make universal ORMs.\nStick to YAGNI principle.\nTL;DR\nWrite mapper that handle you existing scenarios instead of some generic \"load everything\" tasks.\n", "Konwledge_Point": "递归关系", "Question": "PHP Data Mapper，具有域之间的递归MTM关系\n\n\n\nI'm reading a lot around the Model layer in PHP MVC and developing a Data Mapper (yes, I'm reinventing the wheel, it's learning).\n\n\n\nI can claim I understand the relationship between Data Mappers and Domain Objects.\n\n\n\nWhat I'm struggling to implement in a coherent fashion is how to retrieve nested relations in the Data Mapper, without making the Mapper dependent on other Mappers.\n\n\n\nHere's an example of some related domains:\n\n\n\n\n\nUser\n\n\nRole\n\n\nPermissions\n\n\n\n\nSo a Role has many Permissions, and a User has many Roles:\n\n\n\nUser -> Role(s) -> Permission(s)\n\n\n\nWhen calling \nUserMapper -> fetch($id)\n, I should get a User domain. For the sake of (absurd) simplicity, the User domain has one property, \nroles\n, a collection of Role domains.\n\n\n\nSo far, so good. In the UserMapper, I can join the \nroles\n table to \nusers\n, match for the primary key, get all the roles associated with each user, and create a Role domain for each one. The Role collection is added to the user.\n\n\n\nThe problem\n\n\n\nThis Role collection isn't complete. Again for the sake of absurd simplicity, each Role has one property, \npermissions\n, a collection of Permission domains.\n\n\n\nAll we've done so far is populate the User domain with a Role collection, but we haven't got the permissions associated with each Role in the collection. The Role collection is incomplete.\n\n\n\nMy question is: how to populate the Permission collection for each role, in each user?\n\n\n\nIdea 1\n\n\n\nThis is the trivially simple idea (in terms of PHP implementation). UserMapper starts to look like this:\n\n\n\nclass UserMapper implements Mapper {\n    public function __construct(RoleMapper $mapper)\n}\n\n\n\n\nAnd in the RoleMapper:\n\n\n\nclass RoleMapper implements Mapper {\n    public function __construct(PermissionMapper $mapper)\n}\n\n\n\n\nIn the UserMapper, we'd fetch the matching Users. Then, we'd iterate the User collection, and call \nRoleMapper -> fetch_by_user($user -> id)\n. The Role Mapper gets the matching roles, iterates the resulting Role collection, and calls \nPermissionMapper -> fetch_by_role($role -> id)\n.\n\n\n\nThis is easy to implement. It's blindingly obvious what's going on. But it feels wrong, and would probably be horribly inefficient in use (at least, for anything with more complicated relations than this example).\n\n\n\nI don't like that data mappers are dependent on other data mappers - each data mapper is no longer self-contained, and it's not always doing its own mapping. The UserMapper does not know what will exactly be in the collection it returns - we assume we can trust the RoleMapper, but conceptually, we've broken encapsulation.\n\n\n\nIdea 2\n\n\n\nWhere I started. The UserMapper uses a join to get the roles associated with each user.\n\n\n\nInitially, this seems fine. It's efficient - we're just executing one SQL statement. Data Mappers don't need to be constrained to one table - I'm comfortable with that.\n\n\n\nBut... what happens when we need to get relations recursively?\n\n\n\nWhat I'm \nless\n comfortable with, is the idea that the UserMapper not only needs to know that Users have Roles (that's fine), but that \nRoles have Permissions\n. This detail seems to lie beyond the UserMapper's concern.\n\n\n\nWhat if later on, Roles also have many \"Chocolate Foobars?\" I don't want to be updating the UserMapper to retrieve all these Chocolate Foobars properly too.\n\n\n\nIt's possible that we also add a new \"Pet\" domain, and Pets can have Roles too. So now I have to update my UserMapper and my PetMapper to support these crazy \"Chocolate Foobars\" that are associated with Roles. This issue is entirely removed by Idea 1... but that has its own problems as outlined above.\n\n\n\nConclusion\n\n\n\nI started writing this post in the hope that putting things down simply would present me with a solution (can't tell you how many times I've typed into Stack Overflow and ended up not hitting enter). So far I haven't found one.\n\n\n\nNeither of these approaches seems \"right.\" On the one hand, Idea 1 maintains individual data mapper consistency and appears to have higher maintainability. But it will also result in a very high query count (even if they are highly optimised queries based on indexes) and requires data mappers to have other data mappers as dependencies, which feels wrong.\n\n\n\nBut Idea 2 is little better. A join at the top-level data mapper works fine... unless the Domain you're joining itself requires joins.\n\n\n\nI'd be interested to hear approaches to solving this problem. How do you manage nested relations between Domains in a Data Mapper scenario?\n\n\n\nThe eventual aim is by calling \nUserMapper -> fetch()\n, we get User domains populated with Role collections, that are themselves populated with Permission collections. Users are MTM with Roles, Roles are MTM with Permissions.\n\n\n\nThis is just an example scenario. Others include \nBlog post -> Image(s) -> Category(ies)\n, or \nWorkstation -> Phone(s) -> Camera(s) -> Component(s)\n.\n\n\n\nTaking the latter example, \nWorkstationMapper-> fetch()\n should return a \nWorkstationCollection\n where we can do: \nWorkstation -> get_phone(\"TA-1033\") -> get_camera(\"front\") -> has_component(\"1080p video capture component\")\n.\n  \n\n    ", "Tag": "算法分析"}
{"Answer": "可以查看手册：c语言-函数 中的内容", "Konwledge_Point": "递归关系", "Question": "不懂就问  c语言函数递归\n递归可不可以看成两类，一种可以用类似于数列的递推关系，一种不可以，还是都可以，求解答，刚学", "Tag": "算法分析"}
{"Answer": "\nfunction removeNode(ids, arr){\n    ids = Array.isArray(ids) ? ids : [ids]\n    let childrenids = []\n    let res = ids.reduce((res, id) => {\n        return arr.filter(item => {\n            if(item.id === id){\n                return false\n            }else if(item.parentId === id){\n                childrenids.push(item.id)\n                return false\n            }\n            return true\n        })\n    }, arr)\n    \n    return childrenids.length ? removeNode(childrenids, res) : res\n}\n\nlet list = removeNode(2, data)\nlet list = removeNode(3, data)\nlet list = removeNode(4, data)\n", "Konwledge_Point": "递归关系", "Question": "递归删除父级id相同的数组\n递归删除父级id相同的数组\n数组中的有level 层级，点击删除高层级时，同一个父级id相同的低层级也相应被删除；\n关联关系是：1级没有parent_id，2级的parent_id是1级的id，3级的parent_id是2级的parent_id，4级的parent_id是3级的id;相同的层级可以有多个；\n\n\n   \nlet\n \ndata\n \n=\n [\n        {\n          \nid:\n \n1\n,\n          \nlevel:\n \n1\n,\n          \nparentId:\n \nnull\n\n        },\n        {\n          \nid:\n \n2\n,\n          \nlevel:\n \n2\n,\n          \nparentId:\n \n1\n\n        },\n        {\n          \nid:\n \n4\n,\n          \nlevel:\n \n3\n,\n          \nparentId:\n \n2\n\n        },\n        {\n          \nid:\n \n5\n,\n          \nlevel:\n \n4\n,\n          \nparentId:\n \n4\n\n        },\n        {\n          \nid:\n \n3\n,\n          \nlevel:\n \n2\n,\n          \nparentId:\n \n1\n\n        }\n      ]\n\n\n\n不知道该怎么使用递归写删除", "Tag": "算法分析"}
{"Answer": "\nThat can be done this same way as with any entity. See official docs on @ManyToMany\nFor example:\n/**\n * @ManyToMany(targetEntity=\"Pointscomptage\")\n * @JoinTable(name=\"pointscomptage_link_table\",\n *      joinColumns={@JoinColumn(name=\"id_pointscomptage1\", referencedColumnName=\"id\")},\n *      inverseJoinColumns={@JoinColumn(name=\"id_pointscomptage2\", referencedColumnName=\"id\")}\n *      )\n **/\nprivate $pointscomptages;\n\nThis example assumes the following:\n\nThe relation is unidirectional. Bidirectional is just as easy achieved and is described as well in the docs link above.\nConnecting table is named pointscomptage_link_table\nConnecting table pointscomptage_link_table contains two column keys:\n\nid_pointscomptage1\nid_pointscomptage2\n\n\nHope this helps a bit...\n", "Konwledge_Point": "递归关系", "Question": "使用doctrine ORM（Symfony）正确创建ManyToMany递归/反身关系\n\n\n\nI have this entity named \nPointscomptage.php\n:\n\n\n\nclass Pointscomptage\n\n    {\n        /**\n         * @var integer\n         *\n         * @ORM\\Column(name=\"id\", type=\"integer\", nullable=false)\n         * @ORM\\Id\n         * @ORM\\GeneratedValue(strategy=\"IDENTITY\")\n         */\n        private $id;\n\n        /**\n         * @var string\n         *\n         * @ORM\\Column(name=\"invariant\", type=\"string\", length=150, nullable=false)\n         */\n        private $invariant;\n\n        /**\n         * @var string\n         *\n         * @ORM\\Column(name=\"nom\", type=\"string\", length=150, nullable=false)\n         */\n        private $nom;\n\n        /**\n         * @var string\n         *\n         * @ORM\\Column(name=\"consoProduction\", type=\"string\", length=150, nullable=false)\n         */\n        private $consoProduction;\n\n        /**\n         * @var Typesenergie\n         *\n         * @ORM\\ManyToOne(targetEntity=\"Typesenergie\", inversedBy=\"pointscomptage\")\n         * @ORM\\JoinColumn(name=\"typesenergie_id\", referencedColumnName=\"id\")\n         */\n        private $typesenergie;\n\n        /** ... getters and setters */\n\n\n\n\nI need to understand how to create a \nManyToMany\n \nrecursive\n or \nreflexive\n relation on this entity.\n\n\n\nThat is to say, a \nPointscomptage could have no (0) or many (n) Pointscomptage\n.\n\n\n\nHow to make this relation on this same entity?\n\n\n\n\n\nEDIT\n\n\n\nThanks to \nJovan Perovic\n answer and suggestion this the solution I found, we need to respect doctrine annotation:\n\n\n\n/**\n     * @ORM\\ManyToMany(targetEntity=\"Pointscomptage\")\n     * @ORM\\JoinTable(name=\"pointscomptage_link_table\",\n     * joinColumns={\n     *     @ORM\\JoinColumn(name=\"pointscomptage_id\", referencedColumnName=\"id\")\n     *   },\n     *   inverseJoinColumns={\n     *     @ORM\\JoinColumn(name=\"id_pointscomptage2\", referencedColumnName=\"id\")\n     *   }\n     * )\n     **/\n    private $pointscomptages;\n\n\n\n\nThank you a lot.\n\n    ", "Tag": "算法分析"}
{"Answer": "下列程序从标准输入读取字符串，直到遇到空行为止。每行的格式为 \"当前表 上游表\"，用一个空格隔开。例如，\"table1 table2\" 表示 \"table1\" 表依赖于 \"table2\" 表。\n接下来，程序遍历字典的每个键，并计算出那些表是这个表的下游表（即依赖于这个表的表）。为了计算下游表，程序从当前表开始，递归地搜索上游表，直到所有的上游表都被搜索完为止。最后，将计算出的下游表集合更新到字典中。\n最后，程序打印出构建的字典。结果应该是每个表及其所有下游表的列表。\n\n# 建立空字典，用于存储每个表格的来源\nupstream_tables = {}\n\n# 逐行读入字符串\nfor index, row in df.iterrows():\n    # 拆分为两个单词\n    cur_table, source_table = row[0], row[1]\n    # 为当前表格建立来源集合，或将来源表格加入来源集合\n    upstream_tables.setdefault(cur_table, set()).add(source_table)\n\n# 遍历所有表格\nfor key in upstream_tables.keys():\n    # 取出当前表格的来源表格集合\n    downstream_table = upstream_tables[key]\n    # 建立临时集合，用于存储间接来源表格\n    temp = set()\n    # 当来源表格集合不为空时\n    while downstream_table:\n        # 取出来源表格集合中的一个表格\n        a = downstream_table.pop()\n        # 将其加入临时集合\n        temp.add(a)\n        # 如果这个表格还有来源表格\n        if a in upstream_tables:\n            # 将这些来源表格加入来源表格集合\n            downstream_table.update(upstream_tables[a])\n    # 将临时集合存回字典\n    upstream_tables[key] = temp\n\n# 输出上游表\nprint(upstream_tables)\n# 输出结果df\nres_df = pd.DataFrame({'cur_table': upstream_tables.keys(), 'source_table': upstream_tables.values()})\n", "Konwledge_Point": "递归关系", "Question": "Python 递归找上游\n#背景\ncur_table  source_table\nA            C\nA            B\nB            D\nD            E\n…            …\n现在有一张表，里面存着两个字段，cur_table代表现有的表，source_table代表现在的表对应的上游表；如图，表A对应的上游表有C和B，B对应的上游表为D，D对应的上游表为E；\n\n\n#问题\n通过Ptyhon 或者 SQL，实现找到现有表的所有上游相关表；\n如\nA：C,B,D,E\nB：D,E\nD：E\n\n\n背景列的只是举例，实际表中，现有表相关的血缘关系可能有上百层；本人目前会使用SQL，重复left join的笨办法，不能解决血缘关系数量多的情景；", "Tag": "算法分析"}
{"Answer": "整理下你的意思：五个整型数值（1-15），后边的数值依次比前面的大，存在并且只有一组相邻的数值差相等；\r\n简化修正你的代码（for循环，减去不必要的循环；c_b=c-b，你写成了c-a；\r\n因为四个数值差你都定义了变量，的确不符合使用循环，使用循环的话可以定义成数组；这里用相等的个数==1进行判断）\r\nint main()\r\n{\r\n\t\tint a, b, c, d, e, i = 0;\r\n\t\tint b_a, c_b, d_c, e_d=0;\r\n\t\tint equalNum=0;\r\n\t\tfor (a = 1; a <= 11; a++)\r\n\t\tfor (b = a+1; b <= 12; b++)\r\n\t\tfor (c = b+1; c <= 13; c++)\r\n\t\tfor (d = c+1; d <= 14; d++)\r\n\t\tfor (e = d+1; e <= 15; e++)\r\n\t\t{\r\n\t\tb_a=b-a;\r\n\t\tc_b=c-b;\r\n\t\td_c=d-c;\r\n\t\te_d=e-d;\r\n\t\t/*在这里帮我加上一段逻辑控制，用递归算一算下面的6种关系，把6种情况里面的符合条件 的 a，b，c ，d，e的值全部打印出来。比如：b-a=c-b,等等*/\r\n\t\tequalNum=0;\r\n\t\tif(b_a==c_b) equalNum++;\r\n\t\tif(b_a==d_c) equalNum++;\r\n\t\tif(b_a==e_d) equalNum++;\r\n\t\tif(c_b==d_c) equalNum++;\r\n\t\tif(d_c==e_d) equalNum++;\r\n\t\tif(equalNum==1){\r\n\t\t\tprintf(\"A:%2d B:%2d C:%2d D:%2d E:%2d \", a, b, c, d, e);\r\n\t\t\tprintf(\"\\n\");\r\n\t\t\ti++;\r\n\t\t}\r\n\t\t}\r\n\t\tprintf(\"一共%d种\\n\", i);\r\n\t}\r\n\t运行结果如下：\r\n\t![图片说明](https://img-ask.csdn.net/upload/201805/16/1526437228_783681.png)", "Konwledge_Point": "递归关系", "Question": "用c语言算一个简单的循环判断，或者递归\n老铁帮我加一段代码。谢谢。\n\n\n\n#include \"stdafx.h\"\n\n#include\n\nint main()\n\n{\n\n    int a, b, c, d, e, i = 0;\n\n    int b_a, c_b, d_c, e_d=0;\n\n    for (a = 1; a <= 15; a++)\n\n        for (b = 1; b <= 15; b++)\n\n            for (c = 1; c <= 15; c++)\n\n                for (d = 1; d <= 15; d++)\n\n                    for (e = 1; e <= 15; e++)\n\nif (b - a > 0 && c - b > 0 && d - c > 0 && e - d > 0)\n\n       {\n\n       b_a=b-a;\n\n             c_b=c-a;\n\n             d_c=d-c;\n\n             e_d=e-d;\n\n       /*在这里帮我加上一段逻辑控制，用递归算一算下面的6种关系，把6种情况里面的符合条件      的  a，b，c   ，d，e的值全部打印出来。比如：b-a=c-b,等等*/\n\n        printf(\"A:%2d B:%2d C:%2d D:%2d E:%2d \", a, b, c, d, e);\n\n        i++;\n\n        if (i % 1 == 0)\n\n        printf(\"\\n\");\n\n                                }\n\n                            }\n\n                        }\n\n}\n\n    printf(\"一共%d种\\n\", i);\n\n    return 0;\n\n}\n\n需要循环控制的6种小逻辑。\n\n1 。b-a=c-b并且d-c≠e-d并且b-a≠d-c并且b-a≠e-d\n\n2。 b-a=e-d并且c-b≠d-c并且b-a≠c-b并且b-a≠d-c\n\n3。 b-a=d-c并且c-b≠e-d并且b-a≠c-b并且b-a≠e-d\n\n4。 c-b=d-c并且b-a≠e-d并且c-b≠b-a并且c-b≠e-d\n\n5。 d-c=e-d并且b-a≠c-b并且d-c≠b-a并且d-c≠c-b\n\n6。 c-b=e-d并且b-a≠d-c并且c-b≠b-a并且c-b≠d-c\n\n\n\n打个比方，有4个球A，B，C，D。从这4个球里面选择2个球，其中A等于B的时候，其他的球B不等于C，B不等于D，C不等于D.\n\n\n\n希望懂的老铁能帮我加一段逻辑控制。把代码添加到这里。\n\n\n\n/*在这里帮我加上一段逻辑控制，用递归算一算下面的6种关系，把6种情况里面的符合条件      的  a，b，c  ，d，e的值全部打印出来。比如：b-a=c-b,等等*/", "Tag": "算法分析"}
{"Answer": "汉诺塔问题是研究递归算法的一个经典案例，递归是指程序调用自身的编程方法，而分治算法的设计中很多时候都用到了递归的技巧，指将原问题拆分成几个规模较小但相识于原问题的子问题，然后通过递归的方式解决这些子问题，最后再合并这些子问题的解来建立原问题的解！", "Konwledge_Point": "递归关系", "Question": "汉诺塔问题哪里体现了分治思想\n汉诺塔问题不是用递归解决的吗？哪里体现了分治法，递归和分治法的关系", "Tag": "算法分析"}
{"Answer": "[quote]当我客户端插入一个新的菜单的时候，由Action返回，菜单树上面新的菜单没有被加载，html代码中也看不到，我在Action中调试，发现查询出来的数据是对的，包含了新插入的菜单，我就怀疑是否是freemarker的问题，不知是否能够给出解答. [/quote]\r\n因为我没有你的开发环境，也不知道你菜单生成的机制，也不知道调用结构。但你可以通过debug看看数据在哪里出错：\r\n1.action\r\n2.freemarker渲染数据\r\n3.界面某些js出错\r\n可以用一些js调试技巧发现问题，很多问题会是界面的问题，比如一些空格、标点、参数不对、id重复等都有可能照成界面出不来。", "Konwledge_Point": "递归关系", "Question": "[freemarker]使用freemarker生成父子关系树抛异常\n需要生成一个菜单树，使用了freemarker，由于采用了tiles2,在和freemarker整合的时候出现了问题，所以直接使用freemarker 2.3.15将模板通过template.process方法产生html code显示到前端,主要代码如下:\n\n[code=\"java\"]\n\n//产生freemarker config\n\npackage project.util.freemarker;\n\n\n\nimport freemarker.cache.ClassTemplateLoader;\n\nimport freemarker.template.Configuration;\n\nimport freemarker.template.DefaultObjectWrapper;\n\nimport freemarker.template.TemplateExceptionHandler;\n\n\n\npublic class FreeMarkerService {\n\n    private static Configuration cfg = new Configuration();\n\n\n\nstatic {\n    //设置模版加载的路径，相对于FreemarkerService类路径下的templates路径\n    cfg.setTemplateLoader(new ClassTemplateLoader(FreeMarkerService.class,\n            \"ftl\"));\n    //设置对象包装器\n    cfg.setObjectWrapper(new DefaultObjectWrapper());\n    //设置默认编码\n    cfg.setDefaultEncoding(\"UTF-8\");\n    //设置异常处理器\n    cfg.setTemplateExceptionHandler(TemplateExceptionHandler.IGNORE_HANDLER);\n}\n\npublic static Configuration getConfiguration() {\n    return cfg;\n}\n\n\n\n\n}\n\n[/code]\n\n\n\n[code=\"java\"]\n\n//freemarker工具类，将数据和模板合成html\n\npackage project.util.freemarker\n\n\n\nimport java.io.IOException;\n\nimport java.io.StringWriter;\n\nimport java.io.Writer;\n\nimport java.util.Map;\n\nimport freemarker.template.Configuration;\n\nimport freemarker.template.Template;\n\nimport freemarker.template.TemplateException;\n\n\n\npublic class FreeMarkerUtil {\n\n    @SuppressWarnings(\"rawtypes\")\n\n    public static String dataToString(Map data,String templatePath) throws IOException,TemplateException{\n\n        if(data == null){\n\n            return null;\n\n        }\n\n\n\n    Writer out = null;\n\n    Configuration cfg = FreeMarkerService.getConfiguration();\n    Template template = cfg.getTemplate(templatePath);\n    out = new StringWriter();\n    template.process(data,out);\n    return out.toString();\n}\n\n\n\n\n}\n\n[/code]\n\n\n\nfreemarker 模板\n\n[code=\"html\"]\n\n<#-- 定义宏buildNode -->\n\n<#macro buildNode child parent>\n\n            \n\n                style=\"text-decoration:line-through\"\n\n            \n\n        >\n\n        ${parent.menuName}\n\n        <#if child?? && child?size gt 0> \n\n\n\n                <#list child as t> \n\n                    <#-- 递归调用宏buildNode -->\n\n                    <@buildNode child=t.children parent=t/>\n\n                \n\n\n\n        <@buildNode child=rootMenu.children parent=rootMenu/>\n    \n\n\n\n\n[/code]\n\n\n\n[code=\"java\"]\n\n//实体类\n\npackage project.bean;\n\n\n\nimport java.util.ArrayList;\n\nimport java.util.List;\n\n\n\nimport javax.persistence.CascadeType;\n\nimport javax.persistence.Column;\n\nimport javax.persistence.Entity;\n\nimport javax.persistence.GeneratedValue;\n\nimport javax.persistence.Id;\n\nimport javax.persistence.JoinColumn;\n\nimport javax.persistence.ManyToOne;\n\nimport javax.persistence.OneToMany;\n\nimport javax.persistence.Table;\n\n\n\nimport org.hibernate.annotations.GenericGenerator;\n\nimport org.hibernate.annotations.Parameter;\n\n\n\n@Entity\n\n@Table(name=\"RBAC_MENUS\")\n\npublic class Menu {\n\n    private int menuId;\n\n    private String menuName;\n\n    private String description;\n\n    private Menu parent;\n\n    private List\n children;\n\n    private List functions;\n\n    private String isDel;\n\n\npublic Menu(){}\n\n@Id\n@GeneratedValue(generator = \"paymentableGenerator\")     \n@GenericGenerator(name = \"paymentableGenerator\", strategy = \"sequence\", parameters= {@Parameter(name=\"sequence\",value=\"RBAC_MENU_SEQ\")})\n@Column(name=\"MENU_ID\")\npublic int getMenuId() {\n    return menuId;\n}\n\npublic void setMenuId(int menuId) {\n    this.menuId = menuId;\n}\n\n@Column(name=\"MENU_NAME\")\npublic String getMenuName() {\n    return menuName;\n}\n\npublic void setMenuName(String menuName) {\n    this.menuName = menuName;\n}\n\n@ManyToOne(cascade = {CascadeType.MERGE,CascadeType.REFRESH }, optional = true)  \n@JoinColumn(name=\"PARENT_MENU_ID\")\npublic Menu getParent() {\n    return parent;\n}\n\npublic void setParent(Menu parent) {\n    this.parent = parent;\n}\n\n@OneToMany(cascade = { CascadeType.REFRESH, CascadeType.PERSIST,\n        CascadeType.MERGE, CascadeType.REMOVE },mappedBy =\"parent\")\npublic List getChildren() {\n    return children;\n}\n\npublic void setChildren(List children) {\n    this.children = children;\n}\n\npublic void addChildren(Menu menu){\n    if(this.children == null){\n        this.children = new ArrayList();\n    }\n    this.children.add(menu);\n}\n\n@OneToMany(cascade = { CascadeType.REFRESH, CascadeType.PERSIST,CascadeType.MERGE, CascadeType.REMOVE },mappedBy =\"menu\")\npublic List getFunctions() {\n    return functions;\n}\n\npublic void setFunctions(List functions) {\n    this.functions = functions;\n}\n\n@Column(name=\"IS_DEL\")\npublic String getIsDel() {\n    return isDel;\n}\n\npublic void setIsDel(String isDel) {\n    this.isDel = isDel;\n}\n\n@Column(name=\"description\")\npublic String getDescription() {\n    return description;\n}\n\npublic void setDescription(String description) {\n    this.description = description;\n}\n\n\n\n\n}\n\n[/code]\n\n\n\n[code=\"java\"]\n\n//Struts action\n\npackage project.web;\n\n\n\nimport java.util.HashMap;\n\nimport java.util.List;\n\nimport java.util.Map;\n\n\n\nimport javax.annotation.Resource;\n\n\n\nimport project.bean.Menu;\n\nimport project.service.MenuService;\n\nimport project.util.freemarker.FreeMarkerUtil;\n\nimport com.opensymphony.xwork2.ActionSupport;\n\nimport org.apache.struts2.ServletActionContext;\n\n\n\npublic class MenuAction extends ActionSupport {\n\n        ...\n\n        @Resource private MenuService menuService;\n\n\n\n    private String menuTree;\n\n    public String getMenuTree(){\n    return menuTree;\n}\n   ...\n@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\npublic String initMenu(){\n\n    Menu rootMenu = menuService.getRootMenu();\n\n    try{\n        Map freemarkerData = new HashMap();\n        freemarkerData.put(\"rootMenu\", rootMenu);\n        freemarkerData.put(\"webRoot\", ServletActionContext.getServletContext().getContextPath());\n        menuTree = FreeMarkerUtil.dataToString(freemarkerData, \"menumgmt.ftl\");\n    }\n    catch(Exception e){\n        e.printStackTrace();\n    }\n\n    return ActionSupport.SUCCESS;\n}\n    ...\n\n\n\n\n[/code]\n\n\n\n[code=\"java\"]\n\n//Menu Service实现类\n\npublic class MenuServiceImpl implements MenuService {\n\n    @Resource private SessionFactory sessionFactory;\n\n        ...\n\n\n\n//得到根菜单\n@SuppressWarnings(\"unchecked\")\n@Override\npublic Menu getRootMenu() {\n    List menus = sessionFactory.getCurrentSession().createQuery(\"from Menu m where m.parent is null\").list();\n\n    if(menus != null && menus.size()>0)\n        return menus.get(0);\n\n    return null;\n}\n\n//插入菜单\n@Override\npublic void insertMenu(Menu menu) {\n    sessionFactory.getCurrentSession().persist(menu);\n}\n    ...\n\n\n\n\n}\n\n[/code]\n\n\n\njsp代码\n\n[code=\"html\"]\n\n        ...\n\n    \n\n\n菜单列表\n\n\n\n\n\n                    ${menuTree}\n\n\n\n\n\n\n\n        ...\n\n               $(document).ready(function(){\n           $(\"#treeContainer ul\").Treeview();\n           $(\"#treeContainer\").show(500);\n           });\n\n\n[/code]\n\n\n异常信息\n\n...\n\nHibernate: \n\n    select\n\n        menu0_.MENU_ID as MENU1_2_,\n\n        menu0_.description as descript2_2_,\n\n        menu0_.IS_DEL as IS3_2_,\n\n        menu0_.MENU_NAME as MENU4_2_,\n\n        menu0_.PARENT_MENU_ID as PARENT5_2_ \n\n    from\n\n        RBAC_MENUS menu0_ \n\n    where\n\n        menu0_.PARENT_MENU_ID is null\n\nHibernate: \n\n    select\n\n        children0_.PARENT_MENU_ID as PARENT5_1_,\n\n        children0_.MENU_ID as MENU1_1_,\n\n        children0_.MENU_ID as MENU1_2_0_,\n\n        children0_.description as descript2_2_0_,\n\n        children0_.IS_DEL as IS3_2_0_,\n\n        children0_.MENU_NAME as MENU4_2_0_,\n\n        children0_.PARENT_MENU_ID as PARENT5_2_0_ \n\n    from\n\n        RBAC_MENUS children0_ \n\n    where\n\n        children0_.PARENT_MENU_ID=?\n\n[ERROR] [freemarker.log.Log4JLoggerFactory$Log4JLogger.error(Log4JLoggerFactory.java:96)] er.runtime - \n\n\n\nExpression parent.parent is undefined on line 3, column 43 in menumgmt.ftl.\n\n\n\nThe problematic instruction:\n\n\n\n==> ${parent.parent.menuId} [on line 3, column 41 in menumgmt.ftl]\n\n\n\n in user-directive buildNode [on line 27, column 21 in menumgmt.ftl]\n\n\n\nJava backtrace for programmers:\n\n\n\nfreemarker.core.InvalidReferenceException: Expression parent.parent is undefined on line 3, column 43 in menumgmt.ftl.\n\n    at freemarker.core.TemplateObject.assertNonNull(TemplateObject.java:124)\n\n    at freemarker.core.TemplateObject.invalidTypeException(TemplateObject.java:134)\n\n    at freemarker.core.Dot._getAsTemplateModel(Dot.java:78)\n\n    at freemarker.core.Expression.getAsTemplateModel(Expression.java:89)\n\n    at freemarker.core.Expression.getStringValue(Expression.java:93)\n\n    at freemarker.core.DollarVariable.accept(DollarVariable.java:76)\n\n    at freemarker.core.Environment.visit(Environment.java:209)\n\n    at freemarker.core.MixedContent.accept(MixedContent.java:92)\n\n    at freemarker.core.Environment.visit(Environment.java:209)\n\n    at freemarker.core.Macro$Context.runMacro(Macro.java:168)\n\n    at freemarker.core.Environment.visit(Environment.java:602)\n\n    at freemarker.core.UnifiedCall.accept(UnifiedCall.java:106)\n\n    at freemarker.core.Environment.visit(Environment.java:209)\n\n    at freemarker.core.MixedContent.accept(MixedContent.java:92)\n\n    at freemarker.core.Environment.visit(Environment.java:209)\n\n    at freemarker.core.Environment.process(Environment.java:189)\n\n    at freemarker.template.Template.process(Template.java:237)\n\n    at project.rbac.util.freemarker.FreeMarkerUtil.dataToString(FreeMarkerUtil.java:24)\n\n    at project.rbac.web.MenuAction.initMenu(MenuAction.java:91)\n\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\n    at java.lang.reflect.Method.invoke(Method.java:597)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation.invokeAction(DefaultActionInvocation.java:404)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation.invokeActionOnly(DefaultActionInvocation.java:267)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:229)\n\n    at com.opensymphony.xwork2.interceptor.DefaultWorkflowInterceptor.doIntercept(DefaultWorkflowInterceptor.java:221)\n\n    at com.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:86)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:224)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:223)\n\n    at com.opensymphony.xwork2.util.profiling.UtilTimerStack.profile(UtilTimerStack.java:455)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:221)\n\n    at com.opensymphony.xwork2.validator.ValidationInterceptor.doIntercept(ValidationInterceptor.java:150)\n\n    at org.apache.struts2.interceptor.validation.AnnotationValidationInterceptor.doIntercept(AnnotationValidationInterceptor.java:48)\n\n    at com.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:86)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:224)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:223)\n\n    at com.opensymphony.xwork2.util.profiling.UtilTimerStack.profile(UtilTimerStack.java:455)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:221)\n\n    at com.opensymphony.xwork2.interceptor.ConversionErrorInterceptor.intercept(ConversionErrorInterceptor.java:123)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:224)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:223)\n\n    at com.opensymphony.xwork2.util.profiling.UtilTimerStack.profile(UtilTimerStack.java:455)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:221)\n\n    at com.opensymphony.xwork2.interceptor.ParametersInterceptor.doIntercept(ParametersInterceptor.java:184)\n\n    at com.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:86)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:224)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:223)\n\n    at com.opensymphony.xwork2.util.profiling.UtilTimerStack.profile(UtilTimerStack.java:455)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:221)\n\n    at com.opensymphony.xwork2.interceptor.StaticParametersInterceptor.intercept(StaticParametersInterceptor.java:105)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:224)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:223)\n\n    at com.opensymphony.xwork2.util.profiling.UtilTimerStack.profile(UtilTimerStack.java:455)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:221)\n\n    at org.apache.struts2.interceptor.CheckboxInterceptor.intercept(CheckboxInterceptor.java:83)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:224)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:223)\n\n    at com.opensymphony.xwork2.util.profiling.UtilTimerStack.profile(UtilTimerStack.java:455)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:221)\n\n    at org.apache.struts2.interceptor.FileUploadInterceptor.intercept(FileUploadInterceptor.java:207)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:224)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:223)\n\n    at com.opensymphony.xwork2.util.profiling.UtilTimerStack.profile(UtilTimerStack.java:455)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:221)\n\n    at com.opensymphony.xwork2.interceptor.ModelDrivenInterceptor.intercept(ModelDrivenInterceptor.java:74)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:224)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:223)\n\n    at com.opensymphony.xwork2.util.profiling.UtilTimerStack.profile(UtilTimerStack.java:455)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:221)\n\n    at com.opensymphony.xwork2.interceptor.ScopedModelDrivenInterceptor.intercept(ScopedModelDrivenInterceptor.java:127)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:224)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:223)\n\n    at com.opensymphony.xwork2.util.profiling.UtilTimerStack.profile(UtilTimerStack.java:455)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:221)\n\n    at org.apache.struts2.interceptor.ProfilingActivationInterceptor.intercept(ProfilingActivationInterceptor.java:107)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:224)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:223)\n\n    at com.opensymphony.xwork2.util.profiling.UtilTimerStack.profile(UtilTimerStack.java:455)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:221)\n\n    at org.apache.struts2.interceptor.debugging.DebuggingInterceptor.intercept(DebuggingInterceptor.java:206)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:224)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:223)\n\n    at com.opensymphony.xwork2.util.profiling.UtilTimerStack.profile(UtilTimerStack.java:455)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:221)\n\n    at com.opensymphony.xwork2.interceptor.ChainingInterceptor.intercept(ChainingInterceptor.java:115)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:224)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:223)\n\n    at com.opensymphony.xwork2.util.profiling.UtilTimerStack.profile(UtilTimerStack.java:455)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:221)\n\n    at com.opensymphony.xwork2.interceptor.I18nInterceptor.intercept(I18nInterceptor.java:143)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:224)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:223)\n\n    at com.opensymphony.xwork2.util.profiling.UtilTimerStack.profile(UtilTimerStack.java:455)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:221)\n\n    at com.opensymphony.xwork2.interceptor.PrepareInterceptor.doIntercept(PrepareInterceptor.java:121)\n\n    at com.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:86)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:224)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:223)\n\n    at com.opensymphony.xwork2.util.profiling.UtilTimerStack.profile(UtilTimerStack.java:455)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:221)\n\n    at org.apache.struts2.interceptor.ServletConfigInterceptor.intercept(ServletConfigInterceptor.java:170)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:224)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:223)\n\n    at com.opensymphony.xwork2.util.profiling.UtilTimerStack.profile(UtilTimerStack.java:455)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:221)\n\n    at com.opensymphony.xwork2.interceptor.AliasInterceptor.intercept(AliasInterceptor.java:123)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:224)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:223)\n\n    at com.opensymphony.xwork2.util.profiling.UtilTimerStack.profile(UtilTimerStack.java:455)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:221)\n\n    at com.opensymphony.xwork2.interceptor.ExceptionMappingInterceptor.intercept(ExceptionMappingInterceptor.java:176)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:224)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation$2.doProfiling(DefaultActionInvocation.java:223)\n\n    at com.opensymphony.xwork2.util.profiling.UtilTimerStack.profile(UtilTimerStack.java:455)\n\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:221)\n\n    at org.apache.struts2.impl.StrutsActionProxy.execute(StrutsActionProxy.java:50)\n\n    at org.apache.struts2.dispatcher.Dispatcher.serviceAction(Dispatcher.java:504)\n\n    at org.apache.struts2.dispatcher.FilterDispatcher.doFilter(FilterDispatcher.java:422)\n\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235)\n\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)\n\n    at org.springframework.orm.hibernate3.support.OpenSessionInViewFilter.doFilterInternal(OpenSessionInViewFilter.java:198)\n\n    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:76)\n\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235)\n\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)\n\n    at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:96)\n\n    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:76)\n\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235)\n\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)\n\n    at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:233)\n\n    at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:191)\n\n    at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:127)\n\n    at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:102)\n\n    at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:109)\n\n    at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:298)\n\n    at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:857)\n\n    at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:588)\n\n    at org.apache.tomcat.util.net.JIoEndpoint$Worker.run(JIoEndpoint.java:489)\n\n    at java.lang.Thread.run(Thread.java:662)\n\nHibernate: \n\n    select\n\n        children0_.PARENT_MENU_ID as PARENT5_1_,\n\n        children0_.MENU_ID as MENU1_1_,\n\n        children0_.MENU_ID as MENU1_2_0_,\n\n        children0_.description as descript2_2_0_,\n\n        children0_.IS_DEL as IS3_2_0_,\n\n        children0_.MENU_NAME as MENU4_2_0_,\n\n        children0_.PARENT_MENU_ID as PARENT5_2_0_ \n\n    from\n\n        RBAC_MENUS children0_ \n\n    where\n\n        children0_.PARENT_MENU_ID=?\n\nHibernate: \n\n    select\n\n        children0_.PARENT_MENU_ID as PARENT5_1_,\n\n        children0_.MENU_ID as MENU1_1_,\n\n        children0_.MENU_ID as MENU1_2_0_,\n\n        children0_.description as descript2_2_0_,\n\n        children0_.IS_DEL as IS3_2_0_,\n\n        children0_.MENU_NAME as MENU4_2_0_,\n\n        children0_.PARENT_MENU_ID as PARENT5_2_0_ \n\n    from\n\n        RBAC_MENUS children0_ \n\n    where\n\n        children0_.PARENT_MENU_ID=?\n\n...\n\n\n\n菜单能够正常展现，但是这个异常为什么发生呢，我还碰到一个问题就是当我选择一个菜单项，并且插入一个子菜单的时候，发生一个异常，并且页面也无法展现最新插入的那个菜单，需要刷新一下才能看到新插入的菜单\n\n\n\n程序界面如下:\n\n\n\n[img]\nhttp://hiphotos.baidu.com/lucky_sonic/pic/item/c81382cf5b0ce869f9dc612a.jpg[/img]", "Tag": "算法分析"}
{"Answer": "不知道你这个问题是否已经解决, 如果还没有解决的话: 建议你看下这篇博客👉 ：分治法解决全排列问题及时间复杂度分析如果你已经解决了该问题, 非常希望你能够分享一下解决方案, 写成博客, 将相关链接放在评论区, 以帮助更多的人 ^-^", "Konwledge_Point": "递归关系", "Question": "汉诺塔问题哪里体现了分治法思想\n汉诺塔问题拿里体现了分治思想，不是递归的运用吗，递归和分治法又有什么关系", "Tag": "算法分析"}
{"Answer": "难道代码死循环了？", "Konwledge_Point": "递归关系", "Question": "洛谷提交答案后结果一直出不来\n兄弟们 我今天刚接触到洛谷 提交了两道题 但都是一直在转转转转转  转了一个多小时 就是出不来结果 这个咋整?谢谢好兄弟们\n代码放在自己的编译器里都能运行 没有超时 而且把样例代入进入结果也是正确的 但是提交之后就一直不出结果\n(两道题都是递归题 会和这个有关系吗?)", "Tag": "算法分析"}
{"Answer": "java从根对象出发，遍历引用，所有找到的被标记出来，不可到达的，无论是堆栈还是堆，都会直接被回收。\r\n线程的堆栈会单独被遍历，除非线程销毁，上面的引用不会被错误回收。但是线程如果使用了匿名函数，指向堆栈的变量引用，那么生命周期会延长到线程结束而不是原来的函数的结束。", "Konwledge_Point": "递归关系", "Question": "垃圾回收器如何回收局部线程对象和判断函数栈里引用对象的\n1、垃圾回收器工作背景简单描述\n\n  垃圾回收器工作时由查找对象引用链和回收不再引用链中的对象内存两步骤组成。\n\n    其中，查找和定位对象引用链时，是从静态存储区、类常量、函数栈中标记存活的对象，以及继续递归标识这些对象里有关其他对象的引用，从而形成存活对象关系引用链。\n\n\n\n2、问题1\n\n\n\n一个局部线程对象的引用所处的方法已经调用结束，但引用所指向的局部线程对象还在运行中，并没有退出 run() 方法。\n\n    请问垃圾回收器是何时才对这个局部线程对象进行回收呢？\n\n\n\n3、问题2\n\n  垃圾回收器在检索和建立存活对象关系引用链时，是如何对多个存活和运行中的线程 run() 方法里所引用的对象进行判定的？", "Tag": "算法分析"}
{"Answer": "不需要用堆栈，因为完全二叉树除了最后一层，上面都是满的，而下面从左边看，也是满的。\r\n因此其中序遍历的顺序（数组下标）是一定的。", "Konwledge_Point": "递归关系", "Question": "关于C++二叉树遍历的问题\n这是我的数据结构课的其中一道作业，题目是：一棵具有n个结点的完全二叉树存放在二叉树的顺序存储结构中，试编写非递归算法对该树进行中序遍历。\n\n\n\n如果是二叉链表就很容易，但这是顺序存储，我想了很久都没有清晰的思路，唯一想到的是要用栈来实现，只是纠结于数组元素下标之间的关系与操作，所以想请教各位大神。只需要写一个逻辑清晰的C++函数就可以，必要时可加上注释。\n\n谢谢！", "Tag": "算法分析"}
{"Answer": "treeListDE.KeyFieldName = \"Oid\";\r\ntreeListDE.ParentFieldName = \"ParentOid\";\r\n\r\ntreeListDE.DataSource = CMMConstants.quotaClassifyList.where(p.ParentOid=\"选择的id\").toList();", "Konwledge_Point": "递归关系", "Question": "C# Treelist绑定数据源，筛选数据问题\n首先我treelist是直接绑定数据源的，用的是List<实体类>，然后得到如下图所示的数据，是有5个父子节点关系的，现在有个下拉框，我要根据下拉框的值去匹配父节点。也就是一对一形式，不是这样直接全部显示出来的，下拉框也是5个值。所以请问下怎么刷选数据，用Linq或者递归都行，求指点下。\n代码如下：\n\n\n\ntreeListDE.KeyFieldName = \"Oid\";\n\ntreeListDE.ParentFieldName = \"ParentOid\";\n\ntreeListDE.DataSource = CMMConstants.quotaClassifyList;\n\nCMMConstants.quotaClassifyList------>是指CMMConstants类下 public static List quotaClassifyList = new List();\n如图：", "Tag": "算法分析"}
{"Answer": "主要区别就在于this是判断当前节点，this.left或者this.right是判断当前节点的下一左或右节点你用this判断是否为空，，那么对于当前节点来说，能走到这的代码，this也就是当前节点肯定不为空。所以他又继续遍历下一个左或者右节点，但当前节点不为空，他的下一节点肯能是为空的，所以就会报空指针只有判断当前节点的下一左或者右节点是否为空，才能决定是否要继续遍历当前节点的下一节点", "Konwledge_Point": "递归关系", "Question": "java求二叉树总结点数 空指针问题\n今天再做求二叉树总结点时，出现了空指针问题，十分差异\n期初我是用this来判断这个结点是否为空，之后就报了空指针，但离谱的是我改为用this.left、this.right来判断该姐点是否为空，程序就正常了，但但这两种判断方法都一样怎么就报错了，感到很奇观，this和this.left同样指的是空节点，一个居然会报错\n\n\n    \npublic\n int getDepth(){\n        \nif\n(\nthis\n==\nnull\n) \nreturn\n \n0\n;\n        int L=\nthis\n.left.getDepth();\n        int R=\nthis\n.right.getDepth();\n        \nreturn\n L+R+\n1\n;\n    }\n\n\n\n\n全部代码：\n\n\npublic\n \nclass\n \nBinaryTreeDemo\n \n{\n    \npublic\n static void main(String args[]) {\n        \n//先创建一个二叉树对象\n\n        BinaryTree binaryTree = new BinaryTree();\n\n\n//        创建结点\n\n        HeroNode root = new HeroNode(\n\"宋江\"\n);\n        HeroNode node1 = new HeroNode(\n\"张三\"\n);\n        HeroNode node2 = new HeroNode(\n\"李四\"\n);\n        HeroNode node3 = new HeroNode(\n\"王五\"\n);\n        HeroNode node4 = new HeroNode(\n\"麻六\"\n);\n\n//        建立结点关系\n\n        root.setLeft(node1);\n        root.setRight(node2);\n        node1.setLeft(node3);\n        node1.setRight(node4);\n\n//        确认根结点\n\n        binaryTree.setRoot(root);\n        \n//输出\n\n        System.\nout\n.println(\n\"前序查找：\"\n);\n        binaryTree.preOrder();\n        System.\nout\n.println(\n\"\\n中序查找：\"\n);\n        binaryTree.infixOrder();\n        System.\nout\n.println(\n\"\\n后序查找：\"\n);\n        binaryTree.postOrder();\n        binaryTree.getDepth();\n    }\n}\n\n\n//定义BinaryTree 二叉树\n\n\nclass\n \nBinaryTree\n \n{\n    HeroNode root;\n//定义根结点\n\n\n    \npublic\n void setRoot(HeroNode root) {\n        \nthis\n.root = root;\n    }\n\n    \n//前序遍历\n\n    \npublic\n void preOrder() {\n\n        \nif\n (\nthis\n.root == \nnull\n) {\n            System.\nout\n.println(\n\"当前二叉树为空，无法遍历\"\n);\n        } \nelse\n {\n            \nthis\n.root.preOrder();\n        }\n    }\n\n    \n//中序遍历\n\n    \npublic\n void infixOrder() {\n\n        \nif\n (\nthis\n.root == \nnull\n) {\n            System.\nout\n.println(\n\"当前二叉树为空，无法遍历\"\n);\n        } \nelse\n {\n            \nthis\n.root.infixOrder();\n        }\n    }\n\n    \n//后序遍历\n\n    \npublic\n void postOrder() {\n\n        \nif\n (\nthis\n.root == \nnull\n) {\n            System.\nout\n.println(\n\"当前二叉树为空，无法遍历\"\n);\n        } \nelse\n {\n            \nthis\n.root.postOrder();\n        }\n    }\n\n//获取总结点数\n\n    \npublic\n void getDepth(){\n        \nif\n(\nthis\n.root==\nnull\n){\n            System.\nout\n.println(\n\"总结点数为0\"\n);\n        }\n        \nelse\n{\n          int deepth=\nthis\n.root.getDepth();\n            System.\nout\n.println(\n\"总结点数为：\"\n+deepth);\n        }\n    }\n}\n\n\n\n//先创建HeroNode结点\n\n\n\nclass\n \nHeroNode\n \n{\n    String \ndata\n;\n    HeroNode left;\n    HeroNode right;\n\n    \npublic\n HeroNode getLeft() {\n        \nreturn\n left;\n    }\n\n    \npublic\n HeroNode getRight() {\n        \nreturn\n right;\n    }\n\n    \npublic\n void setRight(HeroNode right) {\n        \nthis\n.right = right;\n    }\n\n    \npublic\n void setLeft(HeroNode left) {\n        \nthis\n.left = left;\n    }\n\n\n    \npublic\n String getData() {\n        \nreturn\n \ndata\n;\n    }\n\n    \npublic\n void setData(String \ndata\n) {\n        \nthis\n.\ndata\n = \ndata\n;\n    }\n\n    \npublic\n HeroNode(String \ndata\n) {\n        \nthis\n.\ndata\n = \ndata\n;\n    }\n\n    \n//前序查找方法\n\n    \npublic\n void preOrder() {\n        \n//先输出父节点\n\n        System.\nout\n.print(\nthis\n.\ndata\n + \n' '\n);\n        \n//递归向左遍历\n\n        \nif\n (\nthis\n.left != \nnull\n) {\n            \nthis\n.left.preOrder();\n        }\n        \n//递归向右遍历\n\n        \nif\n (\nthis\n.right != \nnull\n) {\n            \nthis\n.right.preOrder();\n        }\n    }\n\n    \n//    中序遍历\n\n    \npublic\n void infixOrder() {\n        \n//递归向左遍历(先左)\n\n        \nif\n (\nthis\n.left != \nnull\n) {\n            \nthis\n.left.infixOrder();\n        }\n        \n//输出节点(后根)\n\n        System.\nout\n.print(\nthis\n.\ndata\n + \n' '\n);\n\n        \n//递归向右遍历(再右)\n\n        \nif\n (\nthis\n.right != \nnull\n) {\n            \nthis\n.right.infixOrder();\n        }\n    }\n\n    \n//    后序遍历\n\n    \npublic\n void postOrder() {\n        \n//递归向左遍历(先左)\n\n        \nif\n (\nthis\n.left != \nnull\n) {\n            \nthis\n.left.postOrder();\n        }\n\n        \n//递归向右遍历(后右)\n\n        \nif\n (\nthis\n.right != \nnull\n) {\n            \nthis\n.right.postOrder();\n        }\n        \n//输出节点(再根)\n\n        System.\nout\n.print(\nthis\n.\ndata\n + \n' '\n);\n    }\n\n    \npublic\n int getDepth(){\n        \nif\n(\nthis\n==\nnull\n) \nreturn\n \n0\n;\n        int L=\nthis\n.left.getDepth();\n        int R=\nthis\n.right.getDepth();\n        \nreturn\n L+R+\n1\n;\n    }\n}\n\n", "Tag": "算法分析"}
{"Answer": "你这个相当于是获取树的根元素\r\n我写个伪代码吧\r\n\r\n//定义rootSet\r\n//遍历这个集合 \r\n//Iterator i =  keySet.iterator()\r\n//while(i.hasNext()){\r\n//rootSet.add(leaf.charAt(0));\r\n//}\r\n最后的那个类似json的格式的东西，你自己组装吧。。。", "Konwledge_Point": "递归关系", "Question": "请教算法达人，这样算法怎么写\n比如 我有个map 集合 集合中的key 存在层级关系 \n\n\n\nMap outMap = new HashMap();\n\n以下空间已经分配好\n\nTypedFML32 fml1\n\nTypedFML32 fml2\n\nTypedFML32 fml3\n\nTypedFML32 fml4\n\nTypedFML32 fml5\n\nTypedFML32 fml6\n\n\n\noutMap.put(\"a.b.c.d\",fml1)\n\noutMap.put(\"e\",fml2)\n\noutMap.put(\"a.b.\",fml3)\n\noutMap.put(\"a.b.c\",fml4)\n\noutMap.put(\"a.b.d\",fml5)\n\n\n\noutMap.put(\"a\",fml6)\n\n\n\ne 不被map内除了自身之外的任何其他元素包含\n\n\n\na.b.c.d 不包含其他元素 但是被 a.b.c包含  所以把fml1加到 fml4\n\na.b.c 和a.b.d 上一层 节点是a,b 所以把fml4 fml5 加到fml3中\n\n\n\na.b上一层节点是a 所以把fml3加到fml6中\n\n\n\n最终的需要结果输出的结果是  {(\"a\",fml6)，(\"e\",fml2)}\n\n\n\n这样的递归方法应该怎么写呢", "Tag": "算法分析"}
{"Answer": "标题是分布式环境，电脑总数量固定，并且电脑售出时，需要修改各经销商最大销售量。\r\n本人提供方案如下：\r\n1.把电脑数量以及经销商最大销售量统一到一个server中。如a\r\n2.各分布式应用在获取数量时统一访问a，由a集中处理并返回当前最大数量值\r\n3.a统一处理数量锁机制控制并发\r\n\r\n如果不是分布式应用，直接通过多线程就可以处理了。", "Konwledge_Point": "递归关系", "Question": "分布式环境下并发加锁问题\n多线程问题：\n\n\n\n例如某公司共生产了100台电脑，找了三个一级代理商（A1、A2、A3）帮其销售，而A1、A2、A3又分别找其自己的二级代理商帮其销售（B1、B2、B3、B4、B5），\n\nB1、B2、B3、B4、B5又找其三级代理商帮其销售（C1、C2、C3、C4），D1、D2……代表消费者，ABCD之间的关系由图中箭头所示。\n\n\n\n[img]\nhttp://dl.iteye.com/upload/picture/pic/117657/38c9c231-1b86-3269-914b-6b3be5208424.png[/img]\n\n\n\n每个代理商可以销售的最大值分别是图例中所标示的值，但每个代理商销售的总和不能超过其上级所表示的值（即：A1的实际销售量+A2的实际销售量+A3的实际销售量<=100，B1的实际销售量+B2的实际销售量<=A1(80)）\n\n，其余级别同理，但每个代理商的最大销售量可以修改（增加或减小）\n\n\n\n场景一：\n\nD1购买20台电脑，则C1剩余20，B1剩余40,A1剩余60，厂家剩余80，此时A2直接向厂家订购90台，则会提醒货源不足，同理此时如果D2购买30台，因为C1最多还会卖20台，所以也会提示D3货源不足。\n\n\n\n场景二：\n\n\n\nB2直接从A1购买60台，则A1最多在再卖20台，经销商剩余40台，此时若D1购买30台，则会提示货源不足（因为A1最多只能在卖20台），同理B3购买50台也会提示货源不足（因为经销商还剩下40台）\n\n\n\n场景三：\n\n\n\nD1，D2，D3购买电脑的同时，减少A1的最大销售量，降为70，此时程序该如何控制，如何保证同步\n\n\n\n现在伪码如下\n\n[code=\"java\"]\n\n//购买电脑\n\npublic void buyComputer(User buyer){\n\n    int  buyCount = buyer.getBuyCount();\n\n\n\nboolean flag = 递归判断上级剩余量是否还够可以购买\n\nif(flag){//表示可以购买\n\n         lock.lock();\n    购买电脑，递归修改其上级的最大购买量\n    更新数据到数据库\n   lock.unlock();\n\n}else{\n    提示货源不足\n}   \n\n\n\n\n}\n\n//修改最大值\n\n\n\npublic void updateMax(User user , int max){\n\n    user.setMax(max);\n\n    更新数据库\n\n\n\n}\n\n\n\n[/code]\n\n\n\n问题一：如上述三个场景：在分布式环境下如何处理？\n\n\n\n问题二：多人同时购买时候是不是必须要顺序执行？有没有其它更优方法？\n\n\n\n欢迎探讨 谢谢！", "Tag": "算法分析"}
{"Answer": "我知道怎么解决你的问题，docker这一块我很熟", "Konwledge_Point": "递归关系", "Question": "docker部署jar，但是需要matlab runtime环境，都需要docker形式部署\n因为我的jar包用到了matlab runtime的环境，  jar包docker部署也需要这个环境，找到个matlab的镜像\nhttps://hub.docker.com/r/demartis/matlab-runtime/tags%EF%BC%8C%E4%BD%86%E6%98%AFdockerfile%E9%87%8C%E9%9D%A2%E5%8A%A0%E4%BA%86%E4%B8%AA%E8%B7%9Fjdk%E4%B8%80%E6%A0%B7%E7%9A%84from%EF%BC%8C%E6%83%B3%E7%9A%84%E6%98%AF%E8%B7%9Fjdk%E4%B8%80%E6%A0%B7%E6%98%AFjar%E9%9C%80%E8%A6%81%E7%9A%84%E7%8E%AF%E5%A2%83%E3%80%82%E7%BB%93%E6%9E%9C%E5%A4%B1%E8%B4%A5%E3%80%82%E5%AF%BB%E6%B1%82%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95\n ，有偿\n如果是宿主机安装matlab runtime 需要配置一个环境变量LD_LIBRARY_PATH,在宿主机启动jar包会有加载这个library_path输出。但是采用docker后就不行、\n不知道是不是dockerFile里面需要配这样一个环境变量还是咋的？\n这里必须用docker也是应该客户需求，不能再宿主机安装东西。，只能docker容器形式。所以就寻求docker的方式来处理方法\n 一个项目多个docker怎么又打包成一个docker。\n如果都能提供有效解决方案的话补偿金可以增加\n附客户的环境：CentOS 7    LINUX VERSION4.17.12-1.1\n\n\nqq:1158042016\n\n\n附一个dockerFile规范：\nDockerfile规范\n（1）基于dockerfile构建docker镜像时，默认情况下，当前的工作目录被称为构建上下文，我们也可以使用(-f)指定Dockerfile在不同的位置。无论dockerfile实际存在于哪里，当前目录中包含的文件和目录及其递归内容都将作为构建的上下文发送到dockerd daemon进程中。\n（2）使用.dockerignore. 为了避免在编译镜像时一些无关紧要的文件，我们可以采用.dockerignore文件来排除文件和目录，类似.gitignore作用一样。使用多阶段编译。\n（3）避免安装不必要的包，构建镜像应该尽可能减少复杂性、依赖关系、构建时间及镜像大小。\n（4）减少layer数量。排序多行参数，通过版本管理时我们可以清楚看到我们修改的变化。例如需要安装很多依赖，docker 17.05以及更高版本添加了对多阶段构建的支持，这允许我们只将需要的构件复制到最终图像中即可。极大简化了最终镜像的大小。\n（5）构建缓存。 Docker 构建镜像的过程是顺序执行 Dockerfile 每个指令的过程。执行过程中Docker 将在缓存中查找可重用的镜像，如果不想使用缓存，你也可以使用 docker build –no-cache=true … 命令", "Tag": "算法分析"}
{"Answer": "新插入的记录，其他表也要有数据，不然关联查不到数据，所以触发器无法触发\n", "Konwledge_Point": "递归关系", "Question": "sqlserver触发器问题\n问题遇到的现象和发生背景\n\n\n创建“入库单”表的插入触发器。（有递归插入，需要自行建表，较难）。要求：假设图书馆购买图书后需要填写入库单，通过触发器的作用，能判断在“图书”表是否存在该图书的库存记录，如果是已经存在的图书（此次只是补充图书数量），则自动更新该图书的现有库存数量（增加），并将入库单中此条入库记录中的其余信息填写完整。若图书表中不存在该图书（新出版的书），则在“图书”表中自动插入该图书的记录（提示：图书表和入库单本来应该是一对多，但此种先插入子表的记录的操作是违反参照完整性的，所以不能先有外键关系，通过触发器维持主表和子表的图书自编号的一致性，即不会出现入库单的图书在图书表中不存在的情况）。\n\n\n问题相关代码，请勿粘贴截图\n\n\n\n```\nsql\n\n\ncreate\n \ntrigger\n 插入触发器 \non\n 入库单\n\nfor\n \ninsert\n\n\nas\n\n\nbegin\n\n\ndeclare\n @入库编号 \nint\n,@图书自编号 \nchar\n(\n10\n),@ISBN \nchar\n(\n15\n),@书名 \nchar\n(\n255\n),@类别编号 \nchar\n(\n10\n)\n\ndeclare\n @作者 \nchar\n(\n100\n),@出版社 \nchar\n(\n50\n),@出版日期 \ndate\n,@简介 \nvarchar\n(\n200\n),@图书总量 \nint\n\n\ndeclare\n @价格 \nmoney\n,@入库数量 \nint\n,@入库时间 datetime,@单价 \nmoney\n,@现有库存量 \nint\n,@最低库存量 \nsmallint\n,@存放位置 \nchar\n(\n50\n)\n\nselect\n @入库编号=入库单.入库编号,@图书自编号=inserted.图书自编号,@ISBN=inserted.ISBN,\n       @入库数量=inserted.入库数量,@单价=inserted.单价,@书名=inserted.书名,\n       @价格=入库单.价格,@入库数量=入库单.入库数量,@入库时间=入库单.入库时间\n       \nfrom\n 图书 \njoin\n inserted \non\n inserted.图书自编号=图书.图书自编号\n       \njoin\n 入库单 \non\n 入库单.图书自编号=inserted.图书自编号\n\nselect\n @现有库存量=现有库存量,\n       @类别编号=类别编号,@作者=作者,@出版日期=出版日期,\n       @简介=简介,@图书总量=图书总量,@最低库存量=最低库存量,\n       @存放位置=存放位置,@图书自编号=图书自编号\n       \nfrom\n 图书\n\nif\n \nexists\n(\nselect\n * \nfrom\n 图书 \nwhere\n @图书自编号=图书自编号)\n\nbegin\n\n    \nupdate\n 入库单\n    \nset\n 价格=@入库数量*单价,入库时间=getdate()\n    \nwhere\n 入库编号=@入库编号\n    \nupdate\n 图书\n    \nset\n 现有库存量=现有库存量+@入库数量\n    \nwhere\n 图书自编号=@图书自编号\n\nend\n\n\nif\n \nnot\n \nexists\n(\nselect\n * \nfrom\n 图书)\n\nbegin\n\n    print\n'该图书是新入库图书！'\n\n    \nupdate\n 入库单\n    \nset\n 价格=@入库数量*单价,入库时间=getdate()\n    \nwhere\n 入库编号=@入库编号\n    \nupdate\n 图书\n    \nset\n 图书自编号=@图书自编号,ISBN=@ISBN,书名=@书名,简介=\nNULL\n,图书总量=@入库数量,最低库存量=\n5\n,存放位置=\n'四楼阅览室'\n\n    \nwhere\n 图书自编号=图书自编号\n\nend\n\n\nend\n\n\n\n\n\n###### 运行结果及报错内容 \n修改了很多次，插入原图书表中存在的图书入库单记录是正确的，但是插入新入库的图书，触发器就不生效了\n", "Tag": "算法分析"}
{"Answer": "你说的是可以的", "Konwledge_Point": "递归关系", "Question": "结构体指针与结构体？\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n\n#\ninclude\n\n\n\n\n#\ndefine\n MAX 100\n\n\n#\ndefine\n LENGTH(a) (sizeof(a)/sizeof(a[0]))\n\n\n\n//邻接表中标对应的链表的结点\n\n\ntypedef\n \nstruct\n \n_ENode\n\n{\n    \nint\n ivex;                   \n// 该边所指向的顶点的位置,是数组的下标\n\n    \nstruct\n \n_ENode\n* next_edge;   \n// 指向下一条弧的指针\n\n}ENode,*PENode;\n\n\n//邻接表中的表的顶点\n\n\ntypedef\n \nstruct\n \n_VNode\n\n{\n    \nchar\n data;              \n// 顶点信息\n\n    ENode* first_edge;      \n// 指向第一条依附该顶点的弧\n\n}VNode;\n\n\n//邻接表\n\n\ntypedef\n \nstruct\n \n_LGraph\n\n{\n    \nint\n vexnum;            \n// 图的顶点的数目\n\n    \nint\n edgnum;            \n// 图的边的数目\n\n    VNode vexs[MAX];\n}LGraph;\n\n\n//返回ch在matrix矩阵中的位置\n\n\nstatic\n \nint\n \nget_position\n(LGraph g, \nchar\n ch)\n    \n//为什么用static？\n\n\n{\n    \nint\n i;\n    \nfor\n (i = \n0\n; i < g.vexnum; i++)\n        \nif\n (g.vexs[i].data == ch)\n            \nreturn\n i;\n    \nreturn\n \n-1\n;\n}\n\n//将node链接到list的末尾\n\n\nstatic\n \nvoid\n \nlink_last\n(ENode* list, PENode node)\n\n\n{\n    PENode p = list;\n    \nwhile\n (p->next_edge)\n        p = p->next_edge;\n    p->next_edge = node;\n}\n\n//打印邻接表图\n\n\nvoid\n \nprint_lgraph\n(LGraph G)\n\n\n{\n    \nint\n i;\n    PENode node;\n\n    \nprintf\n(\n\"List Graph:\\n\"\n);\n    \nfor\n (i = \n0\n; i < G.vexnum; i++)  \n//遍历所有的顶点\n\n    {\n        \nprintf\n(\n\"%d(%c): \"\n, i, G.vexs[i].data);\n        node = G.vexs[i].first_edge;\n        \nwhile\n (node != \nNULL\n)  \n//把每个顶点周围的结点都输出一下\n\n        {\n            \nprintf\n(\n\"%d(%c) \"\n, node->ivex, G.vexs[node->ivex].data);\n            node = node->next_edge;\n        }\n        \nprintf\n(\n\"\\n\"\n);\n    }\n}\n\n\n//创建邻接表对应的图(用已提供的数据)，无向图\n\n\nLGraph* \ncreate_example_lgraph\n()\n\n\n{\n    \nchar\n c1, c2;\n    \nchar\n vexs[] = { \n'A'\n, \n'B'\n, \n'C'\n, \n'D'\n, \n'E'\n, \n'F'\n, \n'G'\n };\n    \nchar\n edges[][\n2\n] = {\n        {\n'A'\n, \n'C'\n},\n        {\n'A'\n, \n'D'\n},\n        {\n'A'\n, \n'F'\n},\n        {\n'B'\n, \n'C'\n},\n        {\n'C'\n, \n'D'\n},\n        {\n'E'\n, \n'G'\n},\n        {\n'F'\n, \n'G'\n} };\n    \nint\n vlen = \nLENGTH\n(vexs);\n    \nint\n elen = \nLENGTH\n(edges);\n    \n//上面类似一个邻接矩阵存储\n\n    \nint\n pos1, pos2;\n    ENode* node1, * node2;      \n//无向图，一条边两个对应关系\n\n    LGraph* pG;                 \n//pG表示图\n\n\n    \nif\n ((pG = (LGraph*)\nmalloc\n(\nsizeof\n(_LGraph))) == \nNULL\n)   \n///////\n\n        \n//若硬件没有内存申请失败\n\n        \nreturn\n \nNULL\n;\n    \nmemset\n(pG, \n0\n, \nsizeof\n(LGraph));\n//就是把申请的空间内初始化为0\n\n\n    \n// 初始化\"顶点数\"和\"边数\"\n\n    pG->vexnum = vlen;\n    pG->edgnum = elen;\n    \n// 初始化\"邻接表\"的顶点\n\n    \nfor\n (\nint\n i = \n0\n; i < pG->edgnum; i++)\n    {\n        pG->vexs[i].data = vexs[i];\n        pG->vexs[i].first_edge = \nNULL\n;\n    }\n\n    \n// 初始化\"邻接表\"的边\n\n    \nfor\n (\nint\n i = \n0\n; i < pG->edgnum; i++)\n    {\n        \n// 读取边的起始顶点和结束顶点\n\n        c1 = edges[i][\n0\n];\n        c2 = edges[i][\n1\n];\n\n        pos1 = \nget_position\n(*pG, c1);        \n//pos1对应起始顶点下标位置\n\n        pos2 = \nget_position\n(*pG, c2);        \n//pos2对应结束顶点下标位置\n\n                                             \n//这里传入用结构体而不是结构体指针，因为没有对其本身改变后续更改的时候因为成员是数组可以\n\n        \n// 初始化node1\n\n        node1 = (ENode*)\ncalloc\n(\n1\n, \nsizeof\n(ENode));\n        node1->ivex = pos2;\n        \n// 将node1链接到\"p1所在链表的末尾\"\n\n        \nif\n (pG->vexs[pos1].first_edge == \nNULL\n)\n            pG->vexs[pos1].first_edge = node1;\n        \nelse\n\n            \nlink_last\n(pG->vexs[pos1].first_edge, node1);\n       \n        \n// 初始化node2\n\n        node2 = (ENode*)\ncalloc\n(\n1\n, \nsizeof\n(ENode));\n        node2->ivex = pos1;\n        \n// 将node2链接到\"p2所在链表的末尾\"\n\n        \nif\n (pG->vexs[pos2].first_edge == \nNULL\n)\n            pG->vexs[pos2].first_edge = node2;\n        \nelse\n\n            \nlink_last\n(pG->vexs[pos2].first_edge, node2);\n    }\n}\n\n\n//创建邻接表对应的图(用已提供的数据)，有向图\n\n\nLGraph* \ncreate_example_lgraph_directed\n()\n\n\n{\n    \nchar\n c1, c2;\n    \nchar\n vexs[] = { \n'A'\n, \n'B'\n, \n'C'\n, \n'D'\n, \n'E'\n, \n'F'\n, \n'G'\n };\n    \nchar\n edges[][\n2\n] = {\n        {\n'A'\n, \n'C'\n},\n        {\n'A'\n, \n'D'\n},\n        {\n'A'\n, \n'F'\n},\n        {\n'B'\n, \n'C'\n},\n        {\n'C'\n, \n'D'\n},\n        {\n'E'\n, \n'G'\n},\n        {\n'F'\n, \n'G'\n} };\n    \nint\n vlen = \nLENGTH\n(vexs);\n    \nint\n elen = \nLENGTH\n(edges);\n    \n//上面类似一个邻接矩阵存储\n\n    \nint\n pos1, pos2;\n    ENode* node1, * node2;      \n//无向图，一条边两个对应关系\n\n    LGraph* pG;                 \n//pG表示图\n\n\n    \nif\n ((pG = (LGraph*)\nmalloc\n(\nsizeof\n(_LGraph))) == \nNULL\n)   \n///////\n\n        \n//若硬件没有内存申请失败\n\n        \nreturn\n \nNULL\n;\n    \nmemset\n(pG, \n0\n, \nsizeof\n(LGraph));\n//就是把申请的空间内初始化为0\n\n\n    \n// 初始化\"顶点数\"和\"边数\"\n\n    pG->vexnum = vlen;\n    pG->edgnum = elen;\n    \n// 初始化\"邻接表\"的顶点\n\n    \nfor\n (\nint\n i = \n0\n; i < pG->edgnum; i++)\n    {\n        pG->vexs[i].data = vexs[i];\n        pG->vexs[i].first_edge = \nNULL\n;\n    }\n\n    \n// 初始化\"邻接表\"的边\n\n    \nfor\n (\nint\n i = \n0\n; i < pG->edgnum; i++)\n    {\n        \n// 读取边的起始顶点和结束顶点\n\n        c1 = edges[i][\n0\n];\n        c2 = edges[i][\n1\n];\n\n        pos1 = \nget_position\n(*pG, c1);        \n//pos1对应起始顶点下标位置\n\n        pos2 = \nget_position\n(*pG, c2);        \n//pos2对应结束顶点下标位置\n\n                                             \n//这里传入用结构体而不是结构体指针，因为没有对其本身改变后续更改的时候因为成员是数组可以\n\n        \n// 初始化node1\n\n        node1 = (ENode*)\ncalloc\n(\n1\n, \nsizeof\n(ENode));\n        node1->ivex = pos2;\n        \n// 将node1链接到\"p1所在链表的末尾\"\n\n        \nif\n (pG->vexs[pos1].first_edge == \nNULL\n)\n            pG->vexs[pos1].first_edge = node1;\n        \nelse\n\n            \nlink_last\n(pG->vexs[pos1].first_edge, node1);\n    }\n}\n\n\n//深度优先搜索遍历图的递归实现\n\n\nstatic\n \nvoid\n \nDFS\n(LGraph G, \nint\n i, \nint\n visited[])\n\n\n{\n    \nprintf\n(\n\"%c \"\n, G.vexs[i].data);\n    visited[i] = \n1\n;\n    ENode* node;\n    node = G.vexs[i].first_edge;\n    \nwhile\n (node !=\nNULL\n)\n    {\n        \nif\n (!visited[node->ivex])\n//只要对应顶点没有访问过，深入到下一个顶点访问\n\n            \nDFS\n(G, node->ivex, visited);\n        node = node->next_edge;\n//某个顶点的下一条边，例如B结点的下一条边\n\n    }\n}\n\n\n//深度优先搜索遍历图\n\n\nvoid\n \nDFSTraverse\n(LGraph G)\n\n\n{\n    \nint\n visited[MAX];       \n// 顶点访问标记\n\n    \n//初始化所有顶点都没有被访问\n\n    \nmemset\n(visited, \n0\n, \nsizeof\n(visited));\n   \n/* for (int i = 0; i < G.vexnum; i++)\n        visited[i] = 0;*/\n\n    \nprintf\n(\n\"DFS:\"\n);\n    \nfor\n (\nint\n i = \n0\n; i < G.vexnum; i++)\n    {\n        \nif\n (!visited[i])\n            \nDFS\n(G, i, visited);\n    }\n    \nprintf\n(\n\"\\n\"\n);\n}\n\n\nint\n \nmain\n()\n\n\n{\n    LGraph* pG;\n    pG = \ncreate_example_lgraph_directed\n();\n    \nprint_lgraph\n(*pG);\n    \nDFSTraverse\n(*pG);\n}\n\n\n\n请问定义函数时 比如static void DFS(LGraph G, int i, int visited[])\n为什么用LGraph呢 是不是把结构体指针当做参数传入也可以呀 就是后面的访问要变成-> 了", "Tag": "算法分析"}
{"Answer": "1.初始化ftp 加 ftpClient.changeWorkingDirectory(pathname); ---确认存储文件目录\r\n\r\n2.上传文件  ftpClient.changeWorkingDirectory(pathname); pathname这个传本地上传的文件路径 非服务器路径\r\n\r\n3.下载文件 先判断 filename 是否存在 不存在把服务器路径生成为本地路径 作为作为本地地址进行下载", "Konwledge_Point": "递归关系", "Question": "java ftp上传下载本地无效\n在网上找的ftp的上传下载代码\n\n在本地测试是可以的\n\n不过把项目部署到服务器上后\n\n上传，是把服务器上的资源上传到ftp服务器去了。\n\n下载，是把ftp服务器上的文件下载到服务器上。\n\n这些都和客户端没关系啊，想实现，上传是上传客户端文件到ftp服务器，下载也是下载ftp服务器文件到客户端，请问大佬怎么解决啊\n\n下面是ftp的代码\n\n\n\npackage com.neo.util;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.MalformedURLException;\n\nimport org.apache.commons.net.ftp.FTPClient;\nimport org.apache.commons.net.ftp.FTPFile;\nimport org.apache.commons.net.ftp.FTPReply;\n\npublic class FtpUtils {\n        //ftp服务器地址\n        public String hostname = \"192.168.31.5\";\n        //ftp服务器端口号默认为21\n        public Integer port = 21 ;\n        //ftp登录账号\n        public String username = \"ftp\";\n        //ftp登录密码\n        public String password = \"ftp\";\n\n        public FTPClient ftpClient = null;\n\n        /**\n         * 初始化ftp服务器\n         */\n        public void initFtpClient() {\n            ftpClient = new FTPClient();\n            ftpClient.setControlEncoding(\"utf-8\");\n            try {\n                System.out.println(\"connecting...ftp服务器:\"+this.hostname+\":\"+this.port); \n                ftpClient.connect(hostname, port); //连接ftp服务器\n                ftpClient.login(username, password); //登录ftp服务器\n                int replyCode = ftpClient.getReplyCode(); //是否成功登录服务器\n                if(!FTPReply.isPositiveCompletion(replyCode)){\n                    System.out.println(\"connect failed...ftp服务器:\"+this.hostname+\":\"+this.port); \n                }\n                System.out.println(\"connect successfu...ftp服务器:\"+this.hostname+\":\"+this.port); \n            }catch (MalformedURLException e) { \n               e.printStackTrace(); \n            }catch (IOException e) { \n               e.printStackTrace(); \n            } \n        }\n\n        /**\n        * 上传文件\n        * @param pathname ftp服务保存地址\n        * @param fileName 上传到ftp的文件名\n        *  @param originfilename 待上传文件的名称（绝对地址） * \n        * @return\n        */\n        public boolean uploadFile( String pathname, String fileName,String originfilename){\n            boolean flag = false;\n            InputStream inputStream = null;\n            try{\n                System.out.println(\"开始上传文件\");\n                inputStream = new FileInputStream(new File(originfilename));\n                initFtpClient();\n                ftpClient.setFileType(ftpClient.BINARY_FILE_TYPE);\n                CreateDirecroty(pathname);\n                ftpClient.makeDirectory(pathname);\n                ftpClient.changeWorkingDirectory(pathname);\n                ftpClient.storeFile(fileName, inputStream);\n                inputStream.close();\n                ftpClient.logout();\n                flag = true;\n                System.out.println(\"上传文件成功\");\n            }catch (Exception e) {\n                System.out.println(\"上传文件失败\");\n                e.printStackTrace();\n            }finally{\n                if(ftpClient.isConnected()){ \n                    try{\n                        ftpClient.disconnect();\n                    }catch(IOException e){\n                        e.printStackTrace();\n                    }\n                } \n                if(null != inputStream){\n                    try {\n                        inputStream.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    } \n                } \n            }\n            return true;\n        }\n        /**\n         * 上传文件\n         * @param pathname ftp服务保存地址\n         * @param fileName 上传到ftp的文件名\n         * @param inputStream 输入文件流 \n         * @return\n         */\n        public boolean uploadFile( String pathname, String fileName,InputStream inputStream){\n            boolean flag = false;\n            try{\n                System.out.println(\"开始上传文件\");\n                initFtpClient();\n                ftpClient.setFileType(ftpClient.BINARY_FILE_TYPE);\n                CreateDirecroty(pathname);\n                ftpClient.makeDirectory(pathname);\n                ftpClient.changeWorkingDirectory(pathname);\n                ftpClient.storeFile(fileName, inputStream);\n                inputStream.close();\n                ftpClient.logout();\n                flag = true;\n                System.out.println(\"上传文件成功\");\n            }catch (Exception e) {\n                System.out.println(\"上传文件失败\");\n                e.printStackTrace();\n            }finally{\n                if(ftpClient.isConnected()){ \n                    try{\n                        ftpClient.disconnect();\n                    }catch(IOException e){\n                        e.printStackTrace();\n                    }\n                } \n                if(null != inputStream){\n                    try {\n                        inputStream.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    } \n                } \n            }\n            return true;\n        }\n        //改变目录路径\n         public boolean changeWorkingDirectory(String directory) {\n                boolean flag = true;\n                try {\n                    flag = ftpClient.changeWorkingDirectory(directory);\n                    if (flag) {\n                      System.out.println(\"进入文件夹\" + directory + \" 成功！\");\n\n                    } else {\n                        System.out.println(\"进入文件夹\" + directory + \" 失败！开始创建文件夹\");\n                    }\n                } catch (IOException ioe) {\n                    ioe.printStackTrace();\n                }\n                return flag;\n            }\n\n        //创建多层目录文件，如果有ftp服务器已存在该文件，则不创建，如果无，则创建\n        public boolean CreateDirecroty(String remote) throws IOException {\n            boolean success = true;\n            String directory = remote + \"/\";\n            // 如果远程目录不存在，则递归创建远程服务器目录\n            if (!directory.equalsIgnoreCase(\"/\") && !changeWorkingDirectory(new String(directory))) {\n                int start = 0;\n                int end = 0;\n                if (directory.startsWith(\"/\")) {\n                    start = 1;\n                } else {\n                    start = 0;\n                }\n                end = directory.indexOf(\"/\", start);\n                String path = \"\";\n                String paths = \"\";\n                while (true) {\n                    String subDirectory = new String(remote.substring(start, end).getBytes(\"GBK\"), \"iso-8859-1\");\n                    path = path + \"/\" + subDirectory;\n                    if (!existFile(path)) {\n                        if (makeDirectory(subDirectory)) {\n                            changeWorkingDirectory(subDirectory);\n                        } else {\n                            System.out.println(\"创建目录[\" + subDirectory + \"]失败\");\n                            changeWorkingDirectory(subDirectory);\n                        }\n                    } else {\n                        changeWorkingDirectory(subDirectory);\n                    }\n\n                    paths = paths + \"/\" + subDirectory;\n                    start = end + 1;\n                    end = directory.indexOf(\"/\", start);\n                    // 检查所有目录是否创建完毕\n                    if (end <= start) {\n                        break;\n                    }\n                }\n            }\n            return success;\n        }\n\n      //判断ftp服务器文件是否存在    \n        public boolean existFile(String path) throws IOException {\n                boolean flag = false;\n                FTPFile[] ftpFileArr = ftpClient.listFiles(path);\n                if (ftpFileArr.length > 0) {\n                    flag = true;\n                }\n                return flag;\n            }\n        //创建目录\n        public boolean makeDirectory(String dir) {\n            boolean flag = true;\n            try {\n                flag = ftpClient.makeDirectory(dir);\n                if (flag) {\n                    System.out.println(\"创建文件夹\" + dir + \" 成功！\");\n\n                } else {\n                    System.out.println(\"创建文件夹\" + dir + \" 失败！\");\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return flag;\n        }\n\n        /** * 下载文件 * \n        * @param pathname FTP服务器文件目录 * \n        * @param filename 文件名称 * \n        * @param localpath 下载后的文件路径 * \n        * @return */\n        public  boolean downloadFile(String pathname, String filename, String localpath){ \n            boolean flag = false; \n            OutputStream os=null;\n            try { \n                System.out.println(\"开始下载文件\");\n                initFtpClient();\n                //切换FTP目录 \n                ftpClient.changeWorkingDirectory(pathname); \n                FTPFile[] ftpFiles = ftpClient.listFiles(); \n                for(FTPFile file : ftpFiles){ \n                    if(filename.equalsIgnoreCase(file.getName())){ \n                        File localFile = new File(localpath + \"/\" + file.getName()); \n                        os = new FileOutputStream(localFile); \n                        ftpClient.retrieveFile(file.getName(), os); \n                        os.close(); \n                    } \n                } \n                ftpClient.logout(); \n                flag = true; \n                System.out.println(\"下载文件成功\");\n            } catch (Exception e) { \n                System.out.println(\"下载文件失败\");\n                e.printStackTrace(); \n            } finally{ \n                if(ftpClient.isConnected()){ \n                    try{\n                        ftpClient.disconnect();\n                    }catch(IOException e){\n                        e.printStackTrace();\n                    }\n                } \n                if(null != os){\n                    try {\n                        os.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    } \n                } \n            } \n            return flag; \n        }\n\n        /** * 删除文件 * \n        * @param pathname FTP服务器保存目录 * \n        * @param filename 要删除的文件名称 * \n        * @return */ \n        public boolean deleteFile(String pathname, String filename){ \n            boolean flag = false; \n            try { \n                System.out.println(\"开始删除文件\");\n                initFtpClient();\n                //切换FTP目录 \n                ftpClient.changeWorkingDirectory(pathname); \n                ftpClient.dele(filename); \n                ftpClient.logout();\n                flag = true; \n                System.out.println(\"删除文件成功\");\n            } catch (Exception e) { \n                System.out.println(\"删除文件失败\");\n                e.printStackTrace(); \n            } finally {\n                if(ftpClient.isConnected()){ \n                    try{\n                        ftpClient.disconnect();\n                    }catch(IOException e){\n                        e.printStackTrace();\n                    }\n                } \n            }\n            return flag; \n        }\n\n        public static void main(String[] args) {\n            FtpUtils ftp =new FtpUtils(); \n            //ftp.uploadFile(\"ftpFile/data\", \"123.docx\", \"E://123.docx\");\n            ftp.downloadFile(\"/ftp\", \"35.zip\", \"d://www//\");\n           // ftp.deleteFile(\"ftpFile/data\", \"123.docx\");\n            System.out.println(\"ok\");\n        }\n}\n", "Tag": "算法分析"}
