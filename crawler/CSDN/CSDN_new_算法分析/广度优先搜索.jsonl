{"Answer": "//你用邻接矩阵存储，我的使用邻接表...\r\n\r\n#include   \r\n#include   \r\n#define VERTEXNUM 5  \r\n  \r\n//存放顶点的邻接表元素  \r\ntypedef struct edge{  \r\n        int vertex;  \r\n        struct edge* next;  \r\n}st_edge;  \r\n  \r\n//队列的元素  \r\ntypedef struct qElement{  \r\n        int value;  \r\n        struct qElement* pre;  \r\n        struct qElement* next;  \r\n}st_qElement;  \r\n  \r\n//队列的前端和后端，最后一个入队列的元素为rear，第一个出队列的元素为front  \r\nst_qElement* front = NULL;  \r\nst_qElement* rear = NULL;  \r\n  \r\nvoid createGraph(st_edge** edge, int start, int end);  \r\nvoid displayGraph(st_edge** edge);  \r\nvoid delGraph(st_edge** edge);  \r\nvoid BFT(st_edge** edge,int* vertexStatusArr);  \r\nvoid BFTcore(st_edge** edge,int i,int* vertexStatusArr);  \r\nvoid putQueue(int vertex);  \r\nint* getQueue();  \r\nvoid putRelatedInQueue(st_edge** edge, int vertex);  \r\n  \r\nint main(void){  \r\n        //动态创建存放边的指针数组   \r\n        st_edge** edge = (st_edge**)malloc(sizeof(st_edge*)*VERTEXNUM);  \r\n        int i;  \r\n        for(i=0;ivertex = end;  \r\n        newedge->next = NULL;  \r\n        edge = edge + start;  \r\n        while(*edge != NULL){  \r\n                edge = &((*edge)->next);  \r\n        }  \r\n        *edge = newedge;  \r\n}  \r\n  \r\n//打印存储的图  \r\nvoid displayGraph(st_edge** edge){  \r\n        int i;  \r\n        st_edge* p;  \r\n        for(i=0;ivertex);  \r\n                        p = p->next;  \r\n                }  \r\n                printf(\"\\n\");  \r\n        }  \r\n}  \r\n  \r\n//释放邻接表占用的内存  \r\nvoid delGraph(st_edge** edge){  \r\n        int i;  \r\n        st_edge* p;  \r\n        st_edge* del;  \r\n        for(i=0;inext;  \r\n                        free(del);  \r\n                }  \r\n                edge[i] = NULL;  \r\n        }  \r\n        free(edge);  \r\n}  \r\n  \r\n//广度优先遍历  \r\nvoid BFT(st_edge** edge,int* vertexStatusArr){  \r\n        printf(\"start BFT graph:\\n\");  \r\n        int i;  \r\n        for(i=0;ivalue = vertex;  \r\n        qe->next = NULL;  \r\n        qe->pre = NULL;  \r\n        if(front == NULL || rear == NULL){  \r\n                front = rear = qe;  \r\n        }else{  \r\n                rear->next = qe;  \r\n                qe->pre = rear;  \r\n                rear = qe;  \r\n        }  \r\n}  \r\n  \r\n//从队列中获取一个元素  \r\nint* getQueue(){  \r\n        if(front == NULL || rear == NULL){  \r\n                return NULL;  \r\n        }else{  \r\n                int* res = (int*)malloc(sizeof(int));  \r\n                *res = front->value;  \r\n  \r\n                st_qElement* p = front;  \r\n                front = front->next;  \r\n                if(front == NULL){  \r\n                        rear = front;  \r\n                }else{  \r\n                        front->pre = NULL;  \r\n                }  \r\n                free(p);  \r\n                p = NULL;  \r\n                return res;  \r\n        }  \r\n}  \r\n  \r\n//将顶点关联的元素放到队列中  \r\nvoid putRelatedInQueue(st_edge** edge, int vertex){  \r\n        st_edge* p = *(edge+vertex);  \r\n        while(p != NULL){  \r\n                putQueue(p->vertex);  \r\n                p = p->next;  \r\n        }  \r\n}", "Konwledge_Point": "广度优先搜索", "Question": "图的广度优先搜索问题，我的代码超出时间限制求修改或给出新的答案，谢谢！\nDescription\n\n读入图的邻接矩阵以及一个顶点的编号（图中顶点的编号为从1开始的连续正整数。顶点在邻接矩阵的行和列上按编号递增的顺序排列。邻接矩阵中元素值为1，表示对应顶点间有一条边，元素值为0，表示对应顶点间没有边），输出从该顶点开始进行广度优先搜索（Breadth-First Search, BFS）的顶点访问序列。假设顶点数目<=100，并且，对于同一顶点的多个邻接顶点，按照顶点编号从小到大的顺序进行搜索。\n\nInput\n\n第一行为两个整数n和s (0\n#include\n#include\n#include\n#include\n#include\n#include\n#include\n#include\n#include\n#include\n#include\n#include           \nusing namespace std;   \ntypedef int ElemType ;  \ntypedef int VrType  ;  \ntypedef char VertexType ;  \ntypedef struct ArcCell{  \n    VrType adj;                                    \n}ArcCell, AdjMatrix[111][111];  \n\ntypedef struct{  \n    int vexs[111];  \n    AdjMatrix arcs;                   \n    int vexnum,arcnum;                 \n}MGraph;  \n\nbool visited[111]; \nint FirstAdjVex(MGraph G,int v){  \n    int i ;  \n    for(i = 0; i>G.arcs[i][j].adj;\n        }  \n    for(int i=0; i=0; w = NextAdjVex(G,v,w)){  \n        if(!visited[w]) DFS(G,w); \n    }  \n} \n\nvoid DFSTraverse(MGraph G,int n){\n    int v;  \n    for(v = n-1; v>m>>n; \n    MGraph G;  \n    CreatUDG(G,m,n);   \n    DFSTraverse(G,n);  \n} \n", "Tag": "算法分析"}
{"Answer": "广搜一般求最短路，算法时间复杂度比较固定深搜是穷举所有情况", "Konwledge_Point": "广度优先搜索", "Question": "广度优先搜索和深度优先搜索的区别\n广度优先搜索和深度优先搜索的区别在哪里啊？分不清楚什么时候用广度什么时候用宽度", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/qq_38665638/article/details/79942822", "Konwledge_Point": "广度优先搜索", "Question": "一个节点数的计算和遍历的问题，广度优先搜索，采用C语言的实现方式\nProblem Description\n\nFar away from our world, there is a banana forest. And many lovely monkeys live there. One day, SDH(Song Da Hou), who is the king of banana forest, decides to hold a big party to celebrate Crazy Bananas Day. But the little monkeys don't know each other, so as the king, SDH must do something. \n\nNow there are n monkeys sitting in a circle, and each monkey has a making friends time. Also, each monkey has two neighbor. SDH wants to introduce them to each other, and the rules are: \n\n1.every time, he can only introduce one monkey and one of this monkey's neighbor. \n\n2.if he introduce A and B, then every monkey A already knows will know every monkey B already knows, and the total time for this introducing is the sum of the making friends time of all the monkeys A and B already knows; \n\n3.each little monkey knows himself; \n\nIn order to begin the party and eat bananas as soon as possible, SDH want to know the mininal time he needs on introducing. \n\n\n\nInput\n\nThere is several test cases. In each case, the first line is n(1 ≤ n ≤ 1000), which is the number of monkeys. The next line contains n positive integers(less than 1000), means the making friends time(in order, the first one and the last one are neighbors). The input is end of file.\n\n\n\nOutput\n\nFor each case, you should print a line giving the mininal time SDH needs on introducing.\n\n\n\nSample Input\n\n8\n\n5 2 4 7 6 1 3 9\n\n\n\nSample Output\n\n105", "Tag": "算法分析"}
{"Answer": "class Solution {\n    public static int numIsPools(int[][] grid) {\n        if (grid == null || grid.length == 0) {\n            return 0;\n        }\n\n        int nr = grid.length;\n        int nc = grid[0].length;\n        int num_ispools = 0;\n\n        for (int r = 0; r < nr; ++r) {\n            for (int c = 0; c < nc; ++c) {\n                if (grid[r][c] == 0) {\n                    ++num_ispools;\n                    grid[r][c] = 1;\n                    Queue<Integer> neighbors = new LinkedList<>();\n                    neighbors.add(r * nc + c);\n                    while (!neighbors.isEmpty()) {\n                        int id = neighbors.remove();\n                        int row = id / nc;\n                        int col = id % nc;\n                        if (row - 1 >= 0 && grid[row-1][col] == 0) {\n                            neighbors.add((row-1) * nc + col);\n                            grid[row-1][col] = 1;\n                        }\n                        if (row + 1 < nr && grid[row+1][col] == 0) {\n                            neighbors.add((row+1) * nc + col);\n                            grid[row+1][col] = 1;\n                        }\n                        if (col - 1 >= 0 && grid[row][col-1] == 0) {\n                            neighbors.add(row * nc + col-1);\n                            grid[row][col-1] = 1;\n                        }\n                        if (col + 1 < nc && grid[row][col+1] == 0) {\n                            neighbors.add(row * nc + col+1);\n                            grid[row][col+1] = 1;\n                        }\n                    }\n                }\n            }\n        }\n\n        return num_ispools;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int col = scanner.nextInt();\n        int line = scanner.nextInt();\n        int[][] arr= new int[col][line];\n        for(int i =0;i<col;i++){\n            for (int j =0;j<line;++j){\n                arr[i][j] = scanner.nextInt();\n            }\n        }\n        System.out.println(numIsPools(arr));\n    }\n}\n\n已自测，给个采纳吧", "Konwledge_Point": "广度优先搜索", "Question": "Java运用BFS（广度优先搜索）解决水塘问题（全英文）\nOverview: Your program will be given a \"map\" of wet and dry locations and you will determine how many\nseperate puddles (contiguous wet areas) are depicted.\nDetails: The input will come from a le called input.txt which will be placed in the same directory as your\njava le. The rst line of the le will have two integer values R and C which will be the number of rows and\ncolumns in the map (simple rectangular region that can be represented by a 2-D array). Each of the next R\nlines will consist of C zeroes or ones. A zero will indicate water and a one will indicate NOT water (grass?).\nTwo zeroes will be considered to be in the same puddle if they are either directly left/right of each other (ie\n(i,j) and (i, j+1)) or directly above/below each other (ie (i,j) and (i+1, j)) or can be connected via repeated\napplications of these rules.\nAnother (more technical) way to picture the situation is that you begin with a graph having R  C vertices\neach having label (i,j) where 0  i < R and 0  j < C and are divided into two sets ”Water\" and “Not\nWater\". Vertex (i,j) shares an edge with the vertices above, below, left, and right, but not diagonal). In\nother words, (i,j) is adjacent to vertices (i-1,j), (i,j-1), (i,j+1), and (i+1, j). You then remove all ”Not Water\"\nvertices and their incident edges.\nYour program will output the number of puddles (or in the more technical description the number of com-\nponents in the graph).\n\n\nSample execution: If input.txt contains\n5 10\n1 1 1 1 1 1 0 1 1 1\n1 1 1 1 1 1 0 1 1 1\n1 1 0 1 1 1 0 1 1 1\n1 1 0 0 0 0 0 1 1 1\n1 1 1 0 0 0 0 1 1 1\nthen the output should be\n1\nIf input.txt contains\n10 15\n0 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n1 0 1 1 1 1 1 1 1 1 1 1 1 1 1\n1 1 0 1 1 1 1 1 1 1 1 1 1 1 1\n1 1 1 0 1 1 1 1 1 1 1 1 1 1 1\n1 1 1 1 0 1 1 1 1 1 1 0 1 0 1\n1 1 1 1 1 0 1 1 1 1 1 0 1 0 1\n1 1 1 1 1 1 0 1 1 1 1 0 1 0 1\n1 1 1 1 1 1 1 0 1 1 1 0 1 0 1\n1 1 1 1 1 1 1 1 0 1 1 0 1 0 1\n1 1 1 1 1 1 1 1 1 0 1 0 1 0 1\nthe the output should be\n12", "Tag": "算法分析"}
{"Answer": "试下这个，flag和module和你上面的一样，然后dfs（0）\r\n\r\n```\r\n def dfs(current):\r\n\tfor i in range(5):\r\n\t\tif mapmodel[current][i]==1 and flag[i]==0:\r\n\t\t\tflag[i]=1\r\n\t\t\tprint i,flag\r\n\t\t\tdfs(i)\r\n```", "Konwledge_Point": "广度优先搜索", "Question": "python 广度优先搜索 遍历图中的点\nmapmodel=[\n\n      [0,1,1,-1,1],\n\n      [1,0,-1,1,-1],\n\n      [1,-1,0,-1,1],\n\n      [-1,1,-1,0,-1],\n\n      [1,-1,1,-1,0]\n\n         ]\n\n\n\nflag=[1,0,0,0,0]\n\n\n\ndef dfs(current,sumpoint):\n\n    if sumpoint==5:\n\n        print sumpoint,flag\n\n    for i in range(5):\n\n        if mapmodel[current][i]==1 and flag[i]==0:\n\n            sumpoint=sumpoint+1\n\n            flag[i]=i\n\n            dfs(i,sumpoint)\n\n    return\n\n\n\ndfs(0,1)\n\n\n\n我想要遍历图里面的点，但总是得不到正确结果，不知道哪里出问题了，请大家指教", "Tag": "算法分析"}
{"Answer": "1.下面是深度优先搜索的程序，用于将图中所有结点的值变为0：\nvoid dfs(int u, int G[][MAXN], int n)\n{\n    // 将当前结点的值变为0\n    G[u][u] = 0;\n    // 遍历所有与当前结点相连的结点\n    for (int v = 0; v < n; v++)\n    {\n        // 如果v是u的相邻结点，则递归调用dfs\n        if (G[u][v] != 0)\n        {\n            dfs(v, G, n);\n        }\n    }\n}\n\n// 在主函数中调用dfs，遍历图中所有结点\nvoid setAllValuesToZero(int G[][MAXN], int n)\n{\n    for (int u = 0; u < n; u++)\n    {\n        dfs(u, G, n);\n    }\n}\n\n2.下面是广度优先搜索的程序，用于打印图中所有结点的值：\n\nvoid bfs(int u, int G[][MAXN], int n)\n{\n    // 创建一个队列来保存当前遍历到的结点\n    queue<int> q;\n    // 将当前结点加入队列\n    q.push(u);\n    // 循环遍历队列中的结点\n    while (!q.empty())\n    {\n        // 从队列中取出第一个结点\n        int u = q.front();\n        q.pop();\n        // 打印当前结点的值\n        printf(\"%d \", G[u][u]);\n        // 遍历所有与当前结点相连的结点\n        for (int v = 0; v < n; v++)\n        {\n            // 如果v是u的相邻结点，则将其加入队列\n            if (G[u][v] != 0)\n            {\n                q.push(v);\n            }\n        }\n    }\n}\n\n// 在主函数中调用bfs，遍历图中所有结点\nvoid printAllValues(int G[][MAXN], int n)\n{\n    for (int u = 0; u < n; u++)\n    {\n        bfs(u, G, n);\n    }\n}\n\n3.下面是使用邻接表存储图的程序，用于求解每个顶点的入度：\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAXN 100\n\n// 定义链表结点\nstruct ListNode\n{\n    int val; // 结点的值\n    ListNode* next; // 指向下一个结点的指针\n};\n\n// 定义邻接表\nstruct AdjacencyList\n{\n    ListNode* head; // 指向第一个结点的指针\n    int size; // 链表的长度\n};\n\n// 创建一个新的链表结点\nListNode* createListNode(int val)\n{\n    ListNode* node = (ListNode*)malloc(sizeof(ListNode));\n    node->val = val;\n    node->next = NULL;\n    return node;\n}\n\n// 初始化邻接表\nvoid initAdjacencyList(AdjacencyList* list)\n{\n    list->head = NULL;\n    list->size = 0;\n}\n\n// 向邻接表中加入新的结点\nvoid addToAdjacencyList(AdjacencyList* list, int val)\n{\n    // 创建新的结点\n    ListNode* node = createListNode(val);\n    // 将新结点插入到链表的头部\n    node->next = list->head;\n    list->head = node;\n    list->size++;\n}\n\n// 求解每个顶点的入度\nvoid FindInDegree(AdjacencyList* G, int indegree[], int n)\n{\n    // 初始化所有结点的入度为0\n    for (int u = 0; u < n; u++)\n    {\n        indegree[u] = 0;\n    }\n    // 遍历所有结点\n    for (int u = 0; u < n; u++)\n    {\n        // 遍历当前结点的所有相邻结点\n        ListNode* curr = G[u].head;\n        while (curr != NULL)\n        {\n              // 将当前结点的相邻结点的入度加1\n              indegree[curr->val]++;\n              curr = curr->next;\n        }\n    }\n}\n\nint main()\n{\n        // 创建邻接表\n        AdjacencyList G[MAXN];\n        for (int i = 0; i < MAXN; i++)\n        {\n              initAdjacencyList(&G[i]);\n          }\n         // 加入边\n         addToAdjacencyList(&G[0], 1);\n         addToAdjacencyList(&G[0], 2);\n         addToAdjacencyList(&G[1], 2);\n         addToAdjacencyList(&G[2], 0);\n         addToAdjacencyList(&G[2], 3);\n         addToAdjacencyList(&G[3], 3);\n         // 求解每个结点的入度\n         int indegree[MAXN];\n         FindInDegree(G, indegree, MAXN);\n\n         // 打印每个结点的入度\n         for (int u = 0; u < MAXN; u++)\n         {\n             printf(\"%d: %d\\n\", u, indegree[u]);\n         }\n\n         return 0;\n}\n\n在这段程序中，我们使用了链表来存储邻接表，并在FindInDegree函数中遍历所有结点的所有相邻结点，将这些结点的入度加1。最后，我们在主函数中调用了FindInDegree函数，并打印了每个结点的入度。", "Konwledge_Point": "广度优先搜索", "Question": "写出完整的编程代码！！（C语言）\n1.已知一个连通图G采用数组存储法，其结点值为数值型，采用深度优先搜索方法，编程序将所有结点的值变为0。\n\n\n2.已知一个连通图G采用数组存储法，其结点值为数值型，采用广度优先搜索方法，编程序将所有结点的值打印出来。\n\n\n3.假设图G采用邻接表存储方式，，编程序求解每个一个顶点的入度: FindInDegree(G, indegree);", "Tag": "算法分析"}
{"Answer": "是的，广度优先搜索（BFS）的一个基本特点是，它可以遍历所有能够到达的节点，且每个节点仅会被遍历一次。这也是 BFS 算法的一大优点，能够高效地遍历图中的所有节点。\n在您提到的情况中，如果A和B在同一层，且它们都指向同一个节点C，那么如果A先被遍历，C节点会被标记为已访问，此时B再遍历到C时，由于C节点已经被标记为已访问，因此B不会再对C进行遍历。这是 BFS 算法保证每个节点仅会被遍历一次的原因之一。\n需要注意的是，BFS 算法的正确性和效率都依赖于如何管理和维护已经遍历过的节点信息，一般来说可以使用队列等数据结构来实现节点的遍历和管理。\n望采纳。", "Konwledge_Point": "广度优先搜索", "Question": "广度优先搜索遍历是指所有的节点都只能遍历一次吗\n广度优先搜索，假设A和B同层，A可以指向C，B也可以指向C，如果A先遍历了，B就不能遍历了嘛", "Tag": "算法分析"}
{"Answer": "最短路可以用广搜实现。\n详情的话请看：\n一、最短路\n\n夜深人静写算法（二十三）- 最短路_英雄哪里出来-CSDN博客\n五个常用最短路算法\n\n\n\nhttps://blog.csdn.net/WhereIsHeroFrom/article/details/114456899\n\n\n二、单向广搜\n\n夜深人静写算法（十）- 单向广搜_英雄哪里出来-CSDN博客\n寻路算法的鼻祖 --- 广度优先搜索\n\n\n\nhttps://blog.csdn.net/WhereIsHeroFrom/article/details/112727824\n\n", "Konwledge_Point": "广度优先搜索", "Question": "请问算法中说到最短路 和 广度优先搜索是什么关系呢？\n请问算法中说到 最短路 和 广度优先搜索 是什么关系呢？\n有很多地方看到 最短路，但是不是很明白。", "Tag": "算法分析"}
{"Answer": "首先推荐你看一篇文章：\n图的广度优先搜索（BFS）和深度优先搜索（DFS）算法解析_Chida15的博客-CSDN博客_bfs算法\nBFS/DFS算法解析【算法入门]2018/6/21.前言和树的遍历类似，图的遍历也是从图中某点出发，然后按照某种方法对图中所有顶点进行访问，且仅访问一次。但是图的遍历相对树而言要更为复杂。因为图中的任意顶点都可能与其他顶点相邻，所以在图的遍历中必须记录已被访问的顶点，避免重复访问。根据搜索路径的不同，我们可以将遍历图的方法分为两种：广度优先搜索和深度优先搜索。2.图的基本概念2.1.无向图和无向...\n\n\n\nhttps://blog.csdn.net/weixin_40953222/article/details/80544928?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-3.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-3.no_search_link\n\n广度优先：     第一层-第二层：1)A-D 2)A-E 3)A-B     第二层-第三层：4)D-G  5)B-C     第三层-第四层：6)G-H 7)C-F     第四层-第五层：8）H-I深度优先：    1）A-D   2）D-B   3）B-C   4）C-F    5）(回溯)F-C 6）(回溯)C-B    7）B-D   8）D-G  9）G-E    10）(回溯)E-G    11）G-H  12）H-I    13）(回溯)I-H  14）(回溯)H-G  15）(回溯)G-D 16）(回溯)D-A", "Konwledge_Point": "广度优先搜索", "Question": "分别按照（1）广度优先搜索（2）深度优先搜索两种算法，遍历下图，写出遍历节点顺序。\n", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/zhousenshan/article/details/53140979", "Konwledge_Point": "广度优先搜索", "Question": "数据结构采用邻接表算法实现KAMI问题，怎么实现的，采用的C语言\nProblem Description\n\nLittle Bob found an interesting mobile game called KAMI in Google Play recently. In this game, you are given a 16*10 grid, and each cell is one of the 4 different colors.\n\n\n\nThe only thing you can do in this game is to choose a cell and a color, and then the entire 4-connected component, which contains the cell and has the same color as the cell, will be painted with the chosen color.\n\n\n\nYour goal is to make all cells painted with the same color with the least painting steps. Also note that the optimal painting steps will be given, just the same as the original game.\n\n\n\nFor your convenience, we label the colors with integers 1..4. In the grid, we index the rows with integers 1..16 from top to bottom, and index the columns with integers 1..10 from left to right. Thus the cell in the i-th row and j-th column will be denoted by (i, j).\n\n\n\nOnce you choose to paint cell (7, 1) with orange color in the above picture, we will obtain:\n\n\n\nInput\n\nThe first line contains an integer T (T<=5), which means there are T test cases in the input.\n\n\n\nFor each test case, the first line contains a positive integer n (n<=8), which denotes the optimal painting steps of this case. We ensure this is the least painting times to achieve the goal.\n\n\n\nThe next 16 lines in each test case describe the initial colors of each cell in the grid. Each line contains a string of length 10, which consists of digits '1'~'4'. For each test case, we ensure that the 4 colors all appear in the initial state.\n\n\n\nOutput\n\nFor each test case, output \"Case #x:\" (x means the case ID) in a separate line first. Then you should output exactly n lines. Each line contains three integers c, x, y (1<=c<=4, 1<=x<=16, 1<=y<=10), which means you choose to paint cell (x, y) with color c in this step.\n\n\n\nIf there exists more than one optimal solutions, you can output an arbitrary one.\n\n\n\nSample Input\n\n2\n\n3\n\n4444444444\n\n3332222333\n\n3111111113\n\n3332222313\n\n3111111113\n\n3132222333\n\n3111111113\n\n3332222313\n\n3111111113\n\n3132222333\n\n3111111113\n\n3332222313\n\n3111111113\n\n3132222333\n\n3332222333\n\n4444444444\n\n5\n\n1111213131\n\n1111213131\n\n4444243444\n\n1111213131\n\n4444444434\n\n1111213131\n\n2222222232\n\n1111213131\n\n1111213131\n\n1111213131\n\n1111213131\n\n1111213131\n\n1111213131\n\n1111213131\n\n1111213131\n\n1111213131\n\n\n\nSample Output\n\nCase #1:\n\n2 14 2\n\n3 15 7\n\n4 12 8\n\nCase #2:\n\n4 4 5\n\n4 16 9\n\n2 5 10\n\n1 7 10\n\n3 16 10", "Tag": "算法分析"}
{"Answer": "参考http://t.zoukankan.com/yuxiaoba-p-8335758.html", "Konwledge_Point": "广度优先搜索", "Question": "C语言，无向图的深度优先遍历和广度优先遍历\n给定一个有N个顶点和E条边的无向图，请用深度优先遍历（DFS）和广度优先遍历（BFS）分别列出其所有的连通集。假设顶点从0到N-1编号。进行搜索时，假设总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。\n\n\n输入：输入第1行给出2个整数N(0<N≤10)和E，分别是图的顶点数和边数。随后E行，每行给出一条边的两个端点。每行中的数字之间用一个空格分隔。\n输出：按照“{v1v2…vk}”的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。", "Tag": "算法分析"}
{"Answer": "深度优先:GABCDEF。广度优先:G-AB,A-F,B-C,C-D,F-E", "Konwledge_Point": "广度优先搜索", "Question": "深度优先搜索生成树和广度优先搜索生成树问题\n请问这个问题的两个图怎么画出来，输出格式不用管，只按照问的要求要出图即可，初学者不太明白，谢谢", "Tag": "算法分析"}
{"Answer": "import java.util.*;\n\npublic class MazeBFS {\n    // 迷宫地图\n    private char[][] maze;\n    // 迷宫大小\n    private int M, N;\n    // 上下左右四个方向\n    private int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    // 记录已访问的位置\n    private boolean[][] visited;\n\n    public MazeBFS(char[][] maze) {\n        this.maze = maze;\n        this.M = maze.length;\n        this.N = maze[0].length;\n        this.visited = new boolean[M][N];\n    }\n\n    // 广度优先搜索\n    public List<int[]> bfs(int start_x, int start_y, int end_x, int end_y) {\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{start_x, start_y});\n        visited[start_x][start_y] = true;\n        while (!queue.isEmpty()) {\n            int[] pos = queue.poll();\n            int x = pos[0], y = pos[1];\n            for (int[] dir : directions) {\n                int nx = x + dir[0], ny = y + dir[1];\n                if (nx >= 0 && nx < M && ny >= 0 && ny < N && maze[nx][ny] == 'O' && !visited[nx][ny]) {\n                    visited[nx][ny] = true;\n                    if (nx == end_x && ny == end_y) {\n                        List<int[]> path = new ArrayList<>();\n                        path.add(new int[]{nx, ny});\n                        int cur_x = x, cur_y = y;\n                        while (cur_x != start_x || cur_y != start_y) {\n                            path.add(new int[]{cur_x, cur_y});\n                            for (int[] dir2 : directions) {\n                                int prev_x = cur_x - dir2[0], prev_y = cur_y - dir2[1];\n                                if (prev_x >= 0 && prev_x < M && prev_y >= 0 && prev_y < N && visited[prev_x][prev_y]) {\n                                    cur_x = prev_x;\n                                    cur_y = prev_y;\n                                    break;\n                                }\n                            }\n                        }\n                        path.add(new int[]{start_x, start_y});\n                        Collections.reverse(path);\n                        return path;\n                    }\n                    queue.offer(new int[]{nx, ny});\n                }\n            }\n        }\n        return null;\n    }\n\n    public static void main(String[] args) {\n        // 迷宫地图\n        char[][] maze = {\n                {'O', 'O', 'O', 'O', 'O', 'X', 'O', 'O'},\n                {'X', 'O', 'X', 'X', 'O', 'X', 'O', 'X'},\n                {'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'},\n                {'O', 'X', 'X', 'O', 'X', 'X', 'O', 'X'},\n                {'O', 'O', 'O', 'O', 'X', 'O', 'O', 'O'},\n                {'X', 'O', 'X', 'O', 'O', 'O', 'X', 'O'},\n                {'X', 'X', 'O', 'O', 'X', 'O', 'O', 'O'},\n        };\n\n        MazeBFS solution = new MazeBFS(maze);\n        List<int[]> shortestPath= solution.bfs(0, 0, maze.length - 1, maze[0].length - 1);\n        if (shortestPath == null) {\n            System.out.println(\"无法到达终点！\");\n        } else {\n            System.out.println(\"最短路径为：\");\n            for (int[] pos : shortestPath) {\n                System.out.println(pos[0] + \" \" + pos[1]);\n            }\n        }\n    }\n}\n\n测试地图自己换一下", "Konwledge_Point": "广度优先搜索", "Question": "bfs广度优先搜索走迷宫\n走迷宫(广度优先搜索)\n\n\n已知一个MxN的迷宫\n\n\n求从(0,0)到(M-1,N-1)的最短路径\n\n\n例如迷宫如下：O代表可通行，X代表不可通行\n\n\n输出最短路径\n\n\n7,7\n\n\n6,7\n\n\n6,6\n\n\n5,6\n\n\n5,5\n\n\n5,4\n\n\n4,4\n\n\n3,4\n\n\n2,4\n\n\n1,4\n\n\n1,3\n\n\n1,2\n\n\n1,1\n\n\n1,0\n\n\n0,0", "Tag": "算法分析"}
{"Answer": "广度，先遍历子节点，再遍历子节点的子节点\r\n12345678\r\n深度，先访问一个节点，往下直到找不到，返回上一个，继续\r\n12485367", "Konwledge_Point": "广度优先搜索", "Question": "数据结构 图的生成树画法\n\n\n\n原图如上，怎么画他的广度优先，深度优先生成树呢？ 具体画法是什么？", "Tag": "算法分析"}
{"Answer": "图的深度优先遍历类似于二叉树的先序遍历，图的广度优先遍历类似于二叉树的层次遍历。\n\n以上仅供参考，如有任何疑问，可以评论回复，看到即回。希望对题主有所帮助！可以的话，点个采纳！\n", "Konwledge_Point": "广度优先搜索", "Question": "深度优先搜索和树与图的深度优先遍历有什么区别吗？\n深度优先搜索和树与图的深度优先遍历有什么区别吗？    同理，宽度呢？", "Tag": "算法分析"}
{"Answer": "#include \r\n#include \r\n#include \r\n#include \r\nusing namespace std;\r\nconst int MAX_V=100;//顶点个数\r\n\r\nvectorG[MAX_V+1];\r\nint V,E;//顶点数，边数\r\nbool used[MAX_V+1];\r\n\r\nvoid dfs(int s)\r\n{\r\n    used[s]=true;\r\n    printf(\"%d\",s);\r\n    for(int i=0;i\");\r\n            dfs(G[s][i]);//从这个为被遍历的点开始往下找\r\n        }\r\n    }\r\n}\r\nvoid bfs(int s)\r\n{\r\n    queueque;\r\n    memset(used,false,sizeof(used));\r\n    que.push(s);\r\n    used[s]=true;\r\n    while(!que.empty())\r\n    {\r\n        int v=que.front();//取出队首元素开始遍历与它相连的点\r\n        que.pop();\r\n        printf(\"%d\",v);\r\n        for(int i=0;i\");\r\n        }\r\n    }\r\n    printf(\"\\n\");\r\n}\r\nint main()\r\n{\r\n    while(~scanf(\"%d %d\",&V,&E))\r\n    {\r\n        for(int i=1;i<=V;i++)//邻接表初始化\r\n        {\r\n            G[i].clear();\r\n        }\r\n        int from,to;\r\n\r\n        for(int i=0;i<E;i++)\r\n        {\r\n            scanf(\"%d %d\",&from,&to);\r\n            //无向图双向边\r\n            G[from].push_back(to);\r\n            G[to].push_back(from);\r\n        }\r\n\r\n        memset(used,false,sizeof(used));//dfs就是从一个点出发若能往前遍历就往前遍历\r\n        dfs(1);                         //不能遍历再往回退一个点，从这个点的另一方向往前遍历\r\n        printf(\"\\n\");                   //持续上述过程直到所有的点都被遍历\r\n        \r\n        bfs(1);                         //bfs就是从一个点出发，先遍历它周围的点\r\n                                        //再按遍历过的点顺序，遍历下一个点的周围的点\r\n                                        //比如从1出发先遍历了2，3，4下一次就从2开始遍历周围的点\r\n                                        //持续这样直到所有的点都被遍历\r\n    }\r\n    return 0;\r\n}", "Konwledge_Point": "广度优先搜索", "Question": "各位大神，请问怎么求图的遍历？\n采用邻接表实现图的DFS和BFS，创图、   广度优先搜索，  深度优先搜索", "Tag": "算法分析"}
{"Answer": "网的遍历问题\n从vi出发进行DFS或者BFS如果能访问到vj则存在vi到vj的路径\n路径的记录可以用栈", "Konwledge_Point": "广度优先搜索", "Question": "c++数据结构有向网相关问题\n基于图的深度优先和广度优先搜索算法，分别设计算法判别以邻接表方式存储的有向图中是否存在有点Vi到Vj的路径", "Tag": "算法分析"}
{"Answer": "你有很多变量未定义就使用了：\n或者你把代码按照代码格式提交，不然少了很多符号：\n", "Konwledge_Point": "广度优先搜索", "Question": "来个人帮看看，能运行，但广度搜索和深度搜索出不来\n\n\n\n#include\n\ntypedef \nint\n VertexType;    \ntypedef \nint\n EdgeType;    \n\n#define MaxVex 100 \n\n\n#define TRUE  1\n\n\n#define INFINITY 0\n\n\n#define FALSE 0\n\ntypedef \nint\n  \nBool\n;\n\nBool\n    visited[MaxVex];\ntypedef struct\n{\n    VertexType Vexs[MaxVex];\n    EdgeType   Edge[MaxVex][MaxVex];\n    \nint\n numV;\n    \nint\n numE;\n}MGraph;\n \n\n//创建无向图的邻接矩阵\n\n\nvoid\n CreateMGraph(MGraph *G)\n{\n    \nint\n vi, vj, e;\n    printf(\n\"请输入图的顶点数和边数(顶点数 边数)：\"\n);\n    scanf(\n\"%d%d\"\n, &G->numV, &G->numE);\n    \nfor\n(\nint\n i = \n0\n; i < G->numV; i++)\n    {\n        \nfor\n (\nint\n j = \n0\n; j < G->numV; j++)\n        {\n            \nif\n (i == j)\n            {\n                G->Edge[i][j] = \n0\n;\n//将顶点与自身的权值初始化为0\n\n            }\n            \nelse\n\n            {\n                G->Edge[i][j] = INFINITY;\n//将顶点与其他顶点的权值初始化为Infinity\n\n            }\n        }\n    }\n    \nfor\n ( i = \n0\n; i < G->numV; i++)\n    {\n        printf(\n\"请输入第%d个顶点的值：\"\n, i + \n1\n);\n        scanf(\n\"%d\"\n, &G->Vexs[i]);\n    }\n    printf(\n\"\\n\"\n);\n \n    \nfor\n (\nint\n k = \n0\n; k < G->numE; ++k)\n    {\n        \nint\n i, j;\n        printf(\n\"请输入边的信息（顶点 顶点 权值）:\"\n);\n        scanf(\n\"%d%d%d\"\n, &vi, &vj, &e);\n        \nfor\n (i = \n0\n; i < G->numV; i++)\n        {\n            \nif\n (G->Vexs[i] == vi)\n            {\n                \nbreak\n;\n//找出顶点的在数组中的位置\n\n            }\n        }\n        \nfor\n (j = \n0\n; j < G->numV; j++)\n        {\n            \nif\n (G->Vexs[j] == vj)\n            {\n                \nbreak\n;\n            }\n        }\n        G->Edge[i][j] = e;\n        G->Edge[j][i] = e;\n    }\n}\n \n\n//输出无向图的邻接矩阵\n\n\nvoid\n ShowpGraph(MGraph G)\n{\n    printf(\n\"\\n邻接矩阵为：\\n\"\n);\n    printf(\n\"\\t\"\n);\n    \nfor\n (\nint\n i = \n0\n; i < G.numV; ++i)\n    {\n        printf(\n\"%6d\"\n, G.Vexs[i]);\n\n    }\n    printf(\n\"\\n\"\n);\n    \nfor\n ( i = \n0\n; i < G.numV; ++i)\n    {\n        printf(\n\"\\n%8d\"\n, G.Vexs[i]);\n        \nfor\n (\nint\n j = \n0\n; j < G.numV; ++j)\n        {\n            \nif\n (G.Edge[i][j] == INFINITY)\n            {\n                printf(\n\"%6s\"\n, \n\"∞\"\n);\n            }\n            \nelse\n\n            {\n                printf(\n\"%6d\"\n, G.Edge[i][j]);\n            }\n        }\n        printf(\n\"\\n\"\n);\n    }\n}\n \n//图的深度优先遍历\n\n\nvoid\n DFS(MGraph G, \nint\n i)\n{\n    \nint\n j;\n    visited[i] = \nTRUE\n;\n    printf(\n\"%c \"\n, G.Vexs[i]);\n\n    \nfor\n (j=\n0\n; j < G.numE; j++)\n    {\n        \nif\n (G.Edge[i][j]!=INFINITY  &&  !visited[j])\n            DFS(G, j);\n    }\n}\n\n\nvoid\n DFSTraverse(MGraph G)\n{\n    \nint\n i;\n    \nfor\n(i=\n0\n;inumE; ++i)\n        visited[i] = \nFALSE\n;\n    \nfor\n (i=\n0\n; inumE; ++i)\n    {\n        \nif\n (!visited[i])\n        {\n            visited[i] = \nTRUE\n;\n            printf(\n\"%c \"\n, G->Vexs[i]);\n            \nwhile\n (!G)\n            {\n                \nfor\n (j=\n0\n; jnumE; ++j)\n                {\n                    \nif\n (!visited[j] && G->Edge[i][j]!=INFINITY)\n                    {\n                        visited[j] = \nTRUE\n;\n                        printf(\n\"%c \"\n, G->Vexs[j]);\n                    }\n                }\n            }\n        }\n    }\n}\n\nint\n main()\n{\n    MGraph G;\n    CreateMGraph(&G);\n    ShowpGraph(G);\n    printf(\n\"\\n图的深度优先遍历为: \"\n);\n    DFSTraverse(G);\n     printf(\n\"\\n图的广度优先遍历为: \"\n);\n    BFSTraverse(&G);\n}\n\n\n", "Tag": "算法分析"}
{"Answer": "\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n    int s = n * m;\n    int i = 1;\n    deque<pair<int,int>> dq;\n    dq.push_back(make_pair(0,0));\n    vector<vector<int>> matrix(n, vector<int>(m));\n    matrix[0][0] = i;\n    i++;\n    while (!dq.empty()&&i<=s) {\n        auto pos = dq.front();\n        dq.pop_front();\n        int r = pos.first;\n        int c = pos.second;\n        //右\n        int rr = r;\n        int cr = c + 1;\n        if (cr < m  && matrix[rr][cr] == 0) {\n            matrix[rr][cr] = i;\n            i++;\n            dq.push_back(make_pair(rr, cr));\n        }\n        //下\n        int rd = r + 1;\n        int cd = c;\n        if (rd < n  && matrix[rd][cd] == 0) {\n            matrix[rd][cd] = i;\n            i++;\n            dq.push_back(make_pair(rd, cd));\n        }\n        //左\n        int rl = r;\n        int cl = c - 1;\n        if (cl >= 0 && matrix[rl][cl] == 0) {\n            matrix[rl][cl] = i;\n            i++;\n            dq.push_back(make_pair(rl, cl));\n        }              \n        //上\n        int ru = r - 1;\n        int cu = c;\n        if (ru >= 0 && matrix[ru][cu] == 0) {\n            matrix[ru][cu] = i;\n            i++;\n            dq.push_back(make_pair(ru, cu));\n        }\n    }           \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cout << matrix[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}\n ", "Konwledge_Point": "广度优先搜索", "Question": "【入门】快乐的马里奥 c++\n说明\n马里奥是一个快乐的油漆工人，这天他接到了一个油漆任务，要求马里奥把一个n行m列的矩阵每一格都用油漆标记一个数字，标记的顺序按照广度优先搜索的方式进行，也就是他会按照如下方式标记：\n\n\n1、首先标记第1行第1列的单元格，标记数字为1；\n\n\n2、然后标记当前单元格上下左右四个方向所有能标记的单元格，且：\n\n\n① 标记顺序按照：右、下、左、上的优先级；\n\n\n② 不能标记到矩阵外，且标记过的数字不能重复标记；\n\n\n3、当本单元格标记结束，寻找比本单元格中数字大1的单元格，标记那个单元格的上下左右四个方向，也是按照步骤2所示的要求进行标记。\n\n\n依次类推，直到所有单元格都被标记。\n\n\n比如：如果有一个3 * 3的矩阵如下，那么首先标记1,1单元格，并按照上面步骤2的要求标记其四周能够标记的单元格，标记结果如下：\n\n\n接下来，标记比1,1格大1的数字的四周的单元格，也就是标记值为2的单元格四周的单元格，标记结果如下：\n\n\n接下来标记值为3的单元格四周的单元格，标记结果如下：\n\n\n接下来标记值为4的单元格四周的单元格，标记结果如下：\n\n\n接下来标记值为5的单元格四周的单元格，标记结果如下：\n\n\n接下来标记值为6的单元格四周的单元格，但这个数字四周的单元格已经被标记，因此继续标记值为7四周的单元格，标记结果如下：\n\n\n此时，发现标记结束，得到如上图所示的标记结果。\n\n\n输入格式\n两个整数n和m，n和m都是3~100之间的整数。\n\n\n输出格式\n输出n行m列的标记后的矩阵，输出每个数后空一格。\n\n\n样例\n输入数据 1\n3 3\n输出数据 1\n1 2 4\n3 5 7\n6 8 9", "Tag": "算法分析"}
{"Answer": "int  q[g.numVertexes+1] ; //此处出现问题提示q没有大小。求帮助\r\n这种定义数组，大小是变量的代码，有的编译器不支持，有的编译器支持。\r\ngcc是支持的，你用devc++这个软件，带gcc编译器，可以编译。\r\n\r\n对于不支持的编译器，只能用malloc或者new动态分配了。\r\n\r\n你的代码，不考虑运行是否对，我已经测试过了，是可以编译的。", "Konwledge_Point": "广度优先搜索", "Question": "编译时提示变量无大小？\n#include \n\n                    #include \n\n                    #define MAXVEX  100                      //最大顶点数\n\n                    #define INFINITY    65535               //用65535来代表无穷大 \n\n                    int visited[MAXVEX]={0};\n\n                    typedef struct\n\n                    {    char vexs[MAXVEX];            //顶点表\n\n                    int  arc[MAXVEX][MAXVEX];         //邻接矩阵，可看作边\n\n                    int  numVertexes, numEdges;      //图中当前的顶点数和边数\n\n                    }Graph;  \n\n\n\n                void CreateGraph(Graph *g)\n                {    int i,j,k,w,t;  \n                printf(\"输入顶点数，边数和t（中间用空格）:\");  \n                scanf(\"%d %d %d\", &(g->numVertexes), &(g->numEdges),&t);  \n                printf(\"\\n\");\n                for(i=1;i<=g->numVertexes;i++) \n                {     \n                getchar();    \n                printf(\"输入第%d顶点信息vexs[%d]=\",i,i);    \n                scanf(\"%c\",&(g->vexs[i])); \n                }  \n                printf(\"\\n\"); \n                for(i=1;i<=g->numVertexes;i++)    \n                for(j=1;j<=g->numVertexes;j++)    \n                if (t>2)  \n                g->arc[i][j] = INFINITY;        \n                else       \n                g->arc[i][j]=0;   \n                for(k=1;k<=g->numEdges;k++)       \n                {            \n                printf(\"输入i j（中间用空格）:\");\n                scanf(\"%d %d\",&i,&j);    \n                if(i>g->numVertexes ||j>g->numVertexes)  exit(0);   \n                if(t>2)          \n                {              \n                printf(\"输入w:\");         \n                scanf(\"%d\",&w);       \n                g->arc[i][j]=w;       \n                if(t==3)  \n                g->arc[j][i]=w;  \n                }       \n                else     \n                {  \n                g->arc[i][j]=1;      \n                if (t==1)  \n                g->arc[j][i]=1;     \n                }    \n                }   \n                printf(\"\\n\"); \n                printf(\"输出邻接矩阵:\\n\"); \n                for(i=1;i<=g->numVertexes ;i++)   \n                {      \n                for(j=1;j<=g->numVertexes ;j++) \n                {       \n                printf(\"%8d\",g->arc[i][j]);     \n                if(t>2&&g->arc[i][j]==65535)         \n                g->arc[i][j]=0; \n                else if(t>2&&g->arc[i][j]!=65535)       \n                g->arc[i][j]=1; \n                }   \n                printf(\"\\n\");\n                }  \n                }  \n\n\n\n\n                void dfs (Graph g,int i)         //广度优先搜索，从顶点i开始遍历\n                {       int j;   \n                printf(\"%d->\",i);    \n                //输出访问顶点    \n                visited[i]=1;            //全局数组访问标记置1表示已经访问    \n                for(j=1; j<=g.numVertexes; j++)      \n                if ((g.arc[i][j]==1)&&(!visited[j]))                     \n                dfs (g,j);\n                }\n\n                void bfs (Graph g,int i)\n                {    \n                int visited[MAXVEX]={0}; \n                int  q[g.numVertexes+1] ; //此处出现问题提示q没有大小。求帮助 \n                int  f,r,j ;   \n                f=r=0 ;   \n                printf(\"%d->\",i);\n                visited[i]=1 ;\n                r++;    \n                q[r]=i ;   \n                while (f\",j);    ;     visited[j]=1 ;     r++; q[r]=j ;  \n                }    \n                }\n                }  \n\n\n                int main()\n                {  \n                Graph g;   \n                int i; \n                printf(\"t为1~4,分别表示无向图、有向图、带权无向图、带权有向图\\n\"); \n                CreateGraph(&g); \n                printf(\"\\n输入i:\"); \n                scanf(\"%d\",&i); \n                printf(\"\\n深度优先搜索遍历：\");  \n                dfs (g,i); \n                printf(\"NULL\\n\");\n                printf(\"广度优先搜索遍历：\"); \n                bfs (g,i);    \n                printf(\"NULL\\n\");\n                return 0;\n                }\n", "Tag": "算法分析"}
{"Answer": "因为nowx*2后可能会超过MAX_N,所以VIS数组大小要定义成2*MAX_N", "Konwledge_Point": "广度优先搜索", "Question": "Catch the cow(POJ3278) 编译器上没问题, OJ上一直runtime error?\n原题网址\n\n\n\n下面是我已经在编译器上通过的代码,但是OJ上始终会RE\n\n(使用的是广度优先搜索的方法)\n\n\n\n#include \n#include \n\n#define MAX_N 100000\n\nint n, k, ans;\nint que[MAX_N+10][2];\nint vis[MAX_N+10];\n\nint head, tail;\n\nvoid bfs( int x);\nvoid enqueue ( int x, int time);\n\n\nint main(void)\n{   \n    scanf(\"%d %d\", &n, &k);\n    if( n>k)\n    {\n        ans = n-k;\n    }\n    else\n    {\n        bfs(n);\n    }\n\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n\nvoid bfs( int x)\n{\n    enqueue(x, 0);\n    vis[x] = 1;\n\n    while(head=0 && nowx-1 <= MAX_N)\n            {\n                enqueue( nowx-1, nowtime+1);\n                vis[nowx-1] = 1;\n\n            }\n            if( i==2 && vis[nowx+1]!=1 && nowx+1>=0 && nowx+1 <= MAX_N)\n            {\n                enqueue( nowx+1, nowtime+1);\n                vis[nowx+1] = 1;\n            }\n            if( i==3 && vis[nowx*2]!=1 && nowx*2>=0 && nowx*2 <= MAX_N)\n            {\n                enqueue( nowx*2, nowtime+1);\n                vis[nowx*2] = 1;\n            }\n        }\n    }\n}\n\nvoid enqueue( int x, int time)\n{\n    que[tail][0] = x;\n    que[tail][1] = time;\n    tail ++;\n}\n\n\n\n\n一开始查了之后说可能是什么栈空间不够,就尝试了一下动态分配空间\n\n(萌新还没学指针,就在网上照猫画虎贴了进去), 但是数字只要大一点程序就无法输出结果\n\n更改后的代码如下:\n\n\n\n#include \n#include \n\n#define MAX_N 100001\n\nint n, k, ans;\n//int que[MAX_N+10][2];     /*之前的方案,但同样RE了,可能是空间不足(?),所以尝试如下动态分配的方法*/ \n//int vis[MAX_N+10];\n\nint head, tail;\n\nvoid bfs( int x, int **que, int *vis);\nvoid enqueue ( int x, int time, int **que);\n\n\nint main(void)\n{   \n    int **que;\n    int i, j;\n    int *vis;\n\n    que = (int**)malloc(sizeof(int*)*MAX_N);        //为两个数组分配空间 \n    for( i=0; ik)\n    {\n        ans = n-k;\n    }\n    else\n    {\n        bfs(n, que, vis);           //进入深搜 \n    }\n\n\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n\nvoid bfs( int x, int **que, int *vis)\n{\n    enqueue(x, 0, que);\n    vis[x] = 1;\n\n    while(head=0 && nowx-1 <= MAX_N)\n            {\n                enqueue( nowx-1, nowtime+1, que);\n                vis[nowx-1] = 1;\n\n            }\n            if( i==2 && vis[nowx+1]!=1 && nowx+1>=0 && nowx+1 <= MAX_N)\n            {\n                enqueue( nowx+1, nowtime+1, que);\n                vis[nowx+1] = 1;\n            }\n            if( i==3 && vis[nowx*2]!=1 && nowx*2>=0 && nowx*2 <= MAX_N)\n            {\n                enqueue( nowx*2, nowtime+1, que);\n                vis[nowx*2] = 1;\n            }\n        }\n    }\n}\n\nvoid enqueue( int x, int time, int **que)   //队列数据的写入 \n{\n    que[tail][0] = x;\n    que[tail][1] = time;\n    tail ++;\n}\n\n\n\n\n请教一下大佬们上面RE的原因到底是什么, 还有下面的动态分配有什么问题,感激不尽", "Tag": "算法分析"}
{"Answer": "自己的id 1,朋友的id 2\r\nA-B\r\nselect aid=1&fid=2 \r\n\r\nA-B-C A-D-C A-X-C  2表链接\r\nselect a1.aid=1&a1.fid=a2.aid&a2.fid=2\r\n\r\nA-B-C-D A-C-B-D    3表链接\r\n\r\nselect a1.aid=1&a1.fid=a2.aid&a2.fid=a3.aid&a3.fid=2 \r\n\r\n自己实现广度或者深度优先搜索都要取出非常多的结果来计算,直接把这个计算的任务交给数据库去处理,数据库肯定会给出更好的处理方法.\r\n\r\n如果你只要取出1条结果的话,可以加个limit语句,这样数据库在处理的时候它就只要找到1条就会返回,速度会快,所以不要取出所有结果,然后程序里面去取一条出来.", "Konwledge_Point": "广度优先搜索", "Question": "人脉系统中的人际距离关系的解决方案?\n昨天提问过的一问题,\nhttp://www.iteye.com/problems/13431\n\n\n\n好友分为三种： \n\n一度好友：用户的好友 \n\n二度好友：用户好友的好友 \n\n三度好友：用户好友的好友的好友 \n\n\n\n要将这三类好友的数量统计出来，如： \n\n\n\n一度好友：10 \n\n二度好友：300 \n\n三度好友：3500 \n\n\n\n并在地图上标识每一个好友的地理分布， \n\n然后还有将所有好友进行地区排行 ,\n\n\n\n又有了新的问题:\n\n做一用户搜索功能,搜索得出列表如下:\n\n\n\n用户照片   用户名称     用户的一度好友数量      用户与你的人际距离\n\nA照片        A              90                  A->B->C->您\n\n\n\n这里的\"人际距离关系\"是个很头疼的问题!\n\n\n\n数据库设计涉及两张表:\n\n用户表:\n\nusers\n\n\n\nuserid username .....\n\n   1     A\n\n   2     B\n\n   3     C\n\n\n\n好友表\n\n\n\nfriends\n\n\n\nuserid friendid\n\n  1      2\n\n  1      3\n\n  2      1\n\n  2      3\n\n  3      1\n\n  3      2\n\n\n\n这里搜索的话,该如何将\"人际关系\"表现出来呢?\n\n我的想法是把相关的用户分布关系当成一个 \"图\",\n\n进行广度优先查找:先遍历所有一度好友,二度好友,三度好友;为什么不是深度优先查找呢?打个比方说,我加了好友A\\B,A也加了好友B,如果是深度优先的话,有可能搜索到B的关系是:我->A->B,就不是最优路径了..\n\n\n\n但是单纯地靠搜索来实现好友关系的展现,搜索一度好友\\二度好友还可以满足,三度好友的搜索就不是一个数量级的了...\n\n\n\n各位大虾,可有好的解决方案?\n\n如何能更好地实现人际关系距离的搜索?\n\n[b]问题补充：[/b]\n\n是三度以内的,只要查找到3度就可以了..\n\n[b]问题补充：[/b]\n\n  A->B->C->您 \n\n\n\n就是查找到这个长度..", "Tag": "算法分析"}
