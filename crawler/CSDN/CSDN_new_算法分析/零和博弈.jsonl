{"Answer": "在-10、10那个分支的时候，先更新max层的α=-10，再更新其α=10，因为Max节点要将下限最大化，但是此时左侧分支α=7，故最终顶层min节点为了使上限最小，β仍是7", "Konwledge_Point": "零和博弈", "Question": "关于博弈树α-β剪枝的一个问题\n如果有这样一个博弈树：\n不剪枝的话，很容易求出第一层的β值是7。但是，如果使用剪枝，搜索到-10的时候：\n自动更新它上层的值（红色字体），求出来第一层的β值为-10。搜索到下一个节点10的时候，虽然正确地更新了第二层节点的α值，但是因为10大于-10，所以第一层的β值还是没有改变，这样就得到了一个错误的值。\n问题是：怎么预防这种bug的出现？还是我对剪枝的理解有误？", "Tag": "算法分析"}
{"Answer": "nash博弈的一个简单例题，先来看一下，你的所有情况：\n你正你反alice正+3-2alice反-2+1\n你需要做的就是，当alice出正和反的时候，你的期望收益都相等，否则alice可以通过改变正反的概率让你的期望收益降低。下来就很简单了，设你出正的概率为x，反1-x，列出方程3 * x + (-2) * (1 - x) = (-2) * x + 1 * (1 - x)，解得x = 3/8，也就是说当你采用正面为3/8概率得时候，期望达到最大，代入计算一下期望收益 = -1/8，答案就显而易见了。", "Konwledge_Point": "零和博弈", "Question": "硬币博弈怎么解释，（po已经绕晕了）\n如果你处于以下情况，你会和Alice一起玩游戏吗？Alice让你玩一个硬币配对游戏，游戏是：你和alice各自选择硬币向上的面（正或反）（你们之间互相不知道对方选的是什么），一起公开结果，若都是正面，她给你3元，都是反面，她给你1元，其他情况你给她2元，你会同意玩这个游戏吗，若会，你的策略是什么？", "Tag": "算法分析"}
{"Answer": "你好，帮你更正如下，主要是改了ode45调用czc函数的方式，我修改之后的格式是最经典，最能反应matlab求ode本质的了\na=0.88; b=0.88; o=0.69; v=1.1; c2=5; c3=15;\nt2=10; e1=10; e2=10; e3=10; j=1; d=1; w=5; \nq1=0.5; q2=0.8; f=5; h=5; r1=4;\nfor i=0.1:0.2:1\n    for j=0.1:0.2:1\n        for k=0.1:0.2:1\n            [t,y]=ode45(@(t,y)czc(y,t,c2,c3,t2,e1,e2,e3,d,j,w,f,h,r1,a,b,v,o,q1,q2),[0 50],[i j k]); % 这里修改了一下，一般是先t后y，然后其它参数放后面\n            figure(1)\n            grid on\n            plot3(y(:,1),y(:,2),y(:,3),'linewidth',1);\n            set(gca,'XTick',[0:0.2:1],'YTick',[0:0.2:1],'ZTick',[0:0.2:1])\n            hold on\n            axis([0 1 0 1 0 1])\n            view([45 10])\n        end\n    end\nend\nxlabel('x','Rotation',0);\nylabel('y','Rotation',0);\nzlabel('z','Rotation',360,'position',[0 0 1.05]);\n\nfunction dydt=czc(y,t,c2,c3,t2,e1,e2,e3,d,j,w,f,h,r1,a,b,v,o,q1,q2)\ndydt=zeros(3,1);\ndydt(1)=y(1)*(1-y(1))*(y(2)*(-q1^(o)*v*f^(b)/(q1^(o)+(1-q1)^o)^(1/o)-q1^(o)*v*h^(b)/(q1^(o)+(1-q1)^o)^(1/o)+v*h^(b))+y(3)*(-q2^(o)*v*f^(b)/(q2^(o)+(1-q2)^o)^(1/o)-q2^(o)*v*h^(b)/(q2^(o)+(1-q2)^o)^(1/o)+v*h^(b))+y(2)*y(3)*(-v*f^(b)+q1^(o)*v*f^(b)/(q1^(o)+(1-q1)^o)^(1/o)+q2^(o)*v*f^(b)/(q2^(o)+(1-q2)^o)^(1/o)+q1^(o)*v*h^(b)/(q1^(o)+(1-q1)^o)^(1/o)+q2^(o)*v*h^(b)/(q2^(o)+(1-q2)^o)^(1/o)+v*h^(b))+r1-v*h^(b));\ndydt(2)=y(2)*(1-y(2))*(y(1)*q1^(o)*w^(a)/(q1^(o)+(1-q1)^o)^(1/o)-y(1)*y(3)*q1^(o)*w^(a)/(q1^(o)+(1-q1)^o)^(1/o)-c2+t2-e1+e2+j);\ndydt(3)=y(3)*(1-y(3))*(y(1)*q2^(o)*f^(a)/(q2^(o)+(1-q2)^o)^(1/o)+y(2)*e3+y(1)*y(2)*(f^(a)-q1^(o)*f^(a)/(q1^(o)+(1-q1)^o)^(1/o)-q2^(o)*f^(a)/(q2^(o)+(1-q2)^o)^(1/o)+q1^(o)*v*w^(b)/(q1^(o)+(1-q1)^o)^(1/o))-c3-e3+d);\nend\n\n\n\n效果：\n", "Konwledge_Point": "零和博弈", "Question": "matlab ode45函数演化博弈仿真，报错 索引超出组元素的数目，请帮我看下\nmatlab ode45函数演化博弈仿真，报错 索引超出组元素的数目\n\n\n以下是定义函数\n\n\nfunction\n \ndydt\n=\nczc\n(\ny,t,c2,c3,t2,e1,e2,e3,d,j,w,f,h,r1,a,b,v,o,q1,q2\n)\n\ndydt\n=\nzeros\n(\n3,1\n);\n\ndydt\n(\n1\n)=\ny\n(\n1\n)*(\n1-y(1\n))*(\ny(2\n)*(\n-q1^(o\n)*\nv\n*\nf\n^(\nb\n)/(\nq1^(o\n)+(\n1-q1\n)^\no\n)^(\n1/o\n)-\nq1\n^(\no\n)*\nv\n*\nh\n^(\nb\n)/(\nq1^(o\n)+(\n1-q1\n)^\no\n)^(\n1/o\n)+\nv\n*\nh\n^(\nb\n))+\ny\n(\n3\n)*(\n-q2^(o\n)*\nv\n*\nf\n^(\nb\n)/(\nq2^(o\n)+(\n1-q2\n)^\no\n)^(\n1/o\n)-\nq2\n^(\no\n)*\nv\n*\nh\n^(\nb\n)/(\nq2^(o\n)+(\n1-q2\n)^\no\n)^(\n1/o\n)+\nv\n*\nh\n^(\nb\n))+\ny\n(\n2\n)*\ny\n(\n3\n)*(\n-v*f^(b\n)+\nq1\n^(\no\n)*\nv\n*\nf\n^(\nb\n)/(\nq1^(o\n)+(\n1-q1\n)^\no\n)^(\n1/o\n)+\nq2\n^(\no\n)*\nv\n*\nf\n^(\nb\n)/(\nq2^(o\n)+(\n1-q2\n)^\no\n)^(\n1/o\n)+\nq1\n^(\no\n)*\nv\n*\nh\n^(\nb\n)/(\nq1^(o\n)+(\n1-q1\n)^\no\n)^(\n1/o\n)+\nq2\n^(\no\n)*\nv\n*\nh\n^(\nb\n)/(\nq2^(o\n)+(\n1-q2\n)^\no\n)^(\n1/o\n)+\nv\n*\nh\n^(\nb\n))+\nr1\n-\nv\n*\nh\n^(\nb\n));\n\ndydt\n(\n2\n)=\ny\n(\n2\n)*(\n1-y(2\n))*(\ny(1\n)*\nq1\n^(\no\n)*\nw\n^(\na\n)/(\nq1^(o\n)+(\n1-q1\n)^\no\n)^(\n1/o\n)-\ny\n(\n1\n)*\ny\n(\n3\n)*\nq1\n^(\no\n)*\nw\n^(\na\n)/(\nq1^(o\n)+(\n1-q1\n)^\no\n)^(\n1/o\n)-\nc2\n+\nt2\n-\ne1\n+\ne2\n+\nj\n);\n\ndydt\n(\n3\n)=\ny\n(\n3\n)*(\n1-y(3\n))*(\ny(1\n)*\nq2\n^(\no\n)*\nf\n^(\na\n)/(\nq2^(o\n)+(\n1-q2\n)^\no\n)^(\n1/o\n)+\ny\n(\n2\n)*\ne3\n+\ny\n(\n1\n)*\ny\n(\n2\n)*(\nf^(a\n)-\nq1\n^(\no\n)*\nf\n^(\na\n)/(\nq1^(o\n)+(\n1-q1\n)^\no\n)^(\n1/o\n)-\nq2\n^(\no\n)*\nf\n^(\na\n)/(\nq2^(o\n)+(\n1-q2\n)^\no\n)^(\n1/o\n)+\nq1\n^(\no\n)*\nv\n*\nw\n^(\nb\n)/(\nq1^(o\n)+(\n1-q1\n)^\no\n)^(\n1/o\n))-\nc3\n-\ne3\n+\nd\n);\n\nend\n\n\n\n\n以下是绘图过程\n\n\na\n=0.88,b=0.88,o=0.69,v=1.1,c2=5,c3=15,t2=10,e1=10,e2=10,e3=10,j=1,d=1,w=5,q1=0.5,q2=0.8,f=5,h=5,r1=4;\n\nfor\n \ni\n=0.1:0.2:1\n    \nfor\n \nj\n=0.1:0.2:1\n        \nfor\n \nk\n=0.1:0.2:1\n            [t,y]=ode45(\n'czc'\n,[0 50],[i j k]);\n            figure(1)\n            grid on\n            plot3(y(:,1),y(:,2),y(:,3),\n'linewidth'\n,1);\n            \nset\n(gca,\n'XTick'\n,[0:0.2:1],\n'YTick'\n,[0:0.2:1],\n'ZTick'\n,[0:0.2:1])\n            hold on\n            axis([0 1 0 1 0 1])\n            view([45 10])\n        end\n    end\nend\nxlabel(\n'x'\n,\n'Rotation'\n,0);\nylabel(\n'y'\n,\n'Rotation'\n,0);\nzlabel(\n'z'\n,\n'Rotation'\n,360,\n'position'\n,[0 0 1.05]);\n\n\n\n以下是报错内容\n\n\n索引超出数组元素的数目(\n1\n)。\n\n出错 czc (第 \n3\n 行)\ndydt(\n1\n)=y(\n1\n)*(\n1\n-y(\n1\n))*(y(\n2\n)*(-q1^(o)*v*f^(b)\n/(q1^(o)+(1-q1)^o)^(1/\no)-q1^(o)*v*h^(b)\n/(q1^(o)+(1-q1)^o)^(1/\no)+v*h^(b))+y(\n3\n)*(-q2^(o)*v*f^(b)\n/(q2^(o)+(1-q2)^o)^(1/\no)-q2^(o)*v*h^(b)\n/(q2^(o)+(1-q2)^o)^(1/\no)+v*h^(b))+y(\n2\n)*y(\n3\n)*(-v*f^(b)+q1^(o)*v*f^(b)\n/(q1^(o)+(1-q1)^o)^(1/\no)+q2^(o)*v*f^(b)\n/(q2^(o)+(1-q2)^o)^(1/\no)+q1^(o)*v*h^(b)\n/(q1^(o)+(1-q1)^o)^(1/\no)+q2^(o)*v*h^(b)\n/(q2^(o)+(1-q2)^o)^(1/\no)+v*h^(b))+r1-v*h^(b));\n\n出错 odearguments (第 \n90\n 行)\nf0 = feval(ode,t0,y0,args{:});   % ODE15I sets args{\n1\n} to yp0.\n\n出错 ode45 (第 \n115\n 行)\n  odearguments(FcnHandlesUsed, solver_name, ode, tspan, y0, \noptions\n, varargin);\n\n出错 czctu (第 \n8\n 行)\n            [t,y]=ode45(\n'czc'\n,[\n0\n \n50\n],[i j k]);\n\n\n\n对于定义函数中的符号，实际上是想完成以下运算\n\n\n\n\n辛苦了，请帮我解答一下", "Tag": "算法分析"}
{"Answer": "这种方法在理论上是可行的，也有类似的应用，例如在混合整数规划（Mixed Integer Programming, MIP）中使用Benders分解法（Benders Decomposition）解决大规模优化问题时，也可以采用类似的方法进行求解。不过在实际应用中，这种方法的效率和稳定性需要根据具体情况进行评估和测试。\n具体来说，将主从博弈问题进行分解，使用一个层层递进的决策过程求解，在理论上可以确保最终求得的解是全局最优解。但在实际应用中，需要考虑问题的规模、复杂度、求解时间等多方面因素，以及具体问题的特点，才能判断这种方法是否适用，并对其进行优化和改进。\n此外，需要注意的是，使用该方法进行求解时，需要确保主从博弈问题是可分解的，即可以通过分解成不同的层次，使得每个层次之间的决策是独立的，且可以相互协作，从而逐层逼近全局最优解。因此，需要对问题进行适当的转化和模型设计，以确保问题的可分解性和有效性。", "Konwledge_Point": "零和博弈", "Question": "matlab中主从博弈怎样求解？\nmatlab主从博弈的解决方法能否这样做？\n领导者先做出决策，带入下层，下层用yamilp+gurobi进行求解。下层求得最优解后，将最优解带入上层，此时上层仍是一个混合整数线性函数，再用yamilp+gurobi求解，得出上层最优解。然后继续带入下层，如此反复迭代。\n因为并没有在主从博弈的相关论文上看到用这种方法求解，所以不知道这种方法是否可行。", "Tag": "算法分析"}
{"Answer": "主从博弈是一种博弈理论模型，用来描述上层领导者和下层跟随者之间的博弈关系。在一般情况下，主从博弈中的领导者和跟随者是独立的，没有耦合关系。\n然而，在某些情况下，如果下层跟随者和上层领导者之间存在耦合关系，那么主从博弈可能就不能够很好地解决问题了。这种情况下，可能需要使用其他的数学方法来解决耦合问题，如果下层模型中存在逻辑变量，那么可能需要使用其他的数学模型，如混合整数规划（mixed-integer programming）或者复杂网络博弈（complicated network game）等来解决。\n使用主从博弈和算法解决耦合问题，可能也有可能性，但这取决于问题的具体情况。例如，如果耦合关系是线性的，那么可能可以使用高斯-线性解法来解决问题。而如果耦合关系是非线性的，那么可能需要使用其他的算法来解决", "Konwledge_Point": "零和博弈", "Question": "主从博弈能求解耦合问题吗？\n一个双层模型中，如果下层跟随者与上层领导者之间存在耦合关系，那主从博弈能解决这样的问题吗？\n一般来说这类问题(EPEC)可以用数学方法转成单层优化的问题，就是MPEC。但要是下层模型中有逻辑变量，就转化不了了。\n要是用主从博弈，再用算法的话，这种存在耦合的问题还能求解吗？", "Tag": "算法分析"}
{"Answer": "我以前写的 http://blog.sina.com.cn/s/blog_51cea4040100h3l9.html", "Konwledge_Point": "零和博弈", "Question": "anti-SG博弈的问题，高手进。\nanti-SG博弈的胜利条件是(g(s)!=0&&Existg(t)>1)||(g(s)==0&&Anyg(t)<=1) \n\n为什么？？", "Tag": "算法分析"}
{"Answer": "你计算一下hessian矩阵就行了，然后只要Hessian矩阵最大和最小特征值乘积为负数就是鞍点", "Konwledge_Point": "零和博弈", "Question": "MATLAB中如何证明原点为马鞍面方程的鞍点，设计算法，是要把方程换成矩阵吗？含三个变量且有二次未知数的一个方程怎么换呢\n如题，请问MATLAB中如何证明原点为马鞍面方程的鞍点，设计算法，是要把方程换成矩阵吗？含三个变量且有二次未知数的一个方程怎么换呢", "Tag": "算法分析"}
{"Answer": "http://www.acmerblog.com/hdu-1836-another-convex-polygon-problem-2812.html", "Konwledge_Point": "零和博弈", "Question": "Another Convex Polygon Problem\nProblem Description\n\nYou are given a convex polygon with N vertices and M straight lines which divide the polygon into several regions. You must compute the number of regions into which the polygon is divided by the straight lines.\n\n\n\nInput\n\nThe first line of input contains the number T of test cases. The next lines describe the T test cases. The first line of each test case contains two integer numbers, separated by one blank: the number N of vertices of the convex polygon (3 <= N <= 10) and the number M of straight lines (0 <= M <= 10). The next N lines contain 2 integer numbers X and Y, denoting the coordinates of some vertex of the polygon. The vertices are given in clockwise or anti-clockwise order. Each of the next M lines contains 4 integer numbers: x1 y1 x2 y2. (x1,y1) and (x1,y1) are two different points on the straight line. All the X and Y coordinates in the input file are in the range -20…20.\n\n\n\nOutput\n\nFor each test case print a line having the following format: “Number of regions=XXX.”, where XXX is replaced by the number of regions into which the polygon is divided.\n\n\n\nSample Input\n\n2\n\n3 0\n\n0 0\n\n1 1\n\n1 0\n\n3 3\n\n0 0\n\n1 1\n\n1 0\n\n1 2 3 4\n\n1 2 3 4\n\n1 2 3 4\n\n\n\nSample Output\n\nNumber of regions=1.\n\nNumber of regions=1.", "Tag": "算法分析"}
{"Answer": "应该是方程的问题，我改了一下\nfunction dxdt=green(t,x)\ndxdt=[x(1)*(1-x(1))*(500*x(2)-250);x(2)*(1-x(2))*(400*x(1)-200)];\nend\n\n这个结果是这样\n\n", "Konwledge_Point": "零和博弈", "Question": "Matlab演化博弈代码错误请教\n微分方程如下：\n\n\nfunction\n dxdt=green(t,x)\n\ndxdt\n=[x(\n1\n)*(\n1\n-x(\n1\n))*(\n500\n*x(\n2\n)-\n250\n);x(\n2\n)*(\n1\n-x(\n2\n))*(\n400\n*x(\n1\n)-\n300\n)];\n\n\nend\n\n\n\n\n主函数如下：\nfor i=0.2:0.2:0.8\n    for j=0.2\n        [T,Y]=ode45('green',[0 0.08],[i j]);\n        figure(2)\n        grid on\n        plot(T,Y(:,1));\n        xlabel('t')\n        ylabel('x')\n        hold on\n    end\nend\nfor i=0.2:0.2:0.8\n    for j=0.8\n        [T,Y]=ode45('green',[0 0.08],[i j]);\n        figure(3)\n        grid on\n        plot(T,Y(:,1));\n        xlabel('t')\n        ylabel('x')\n        hold on\n    end\n\n\n图2是符合预期的\n\n\n图3 i取0.2的时候应该是趋向于1，结果是趋向于0，请问各位是什么原因？", "Tag": "算法分析"}
{"Answer": "在博弈论中，纳什均衡是指在一个博弈中，参与者之间的策略是相互协调的，使得没有一方有动机去改变自己的策略，因为改变策略对其自身没有更优的影响。\n\n在你描述的这个堵车的例子中，每个人在确定自己是否加塞时都要考虑其他人的决策。如果大家都加塞，那么就会形成堵车的局面，所有人的收益都为0。如果大家都不加塞，那么就会保持目前的位置，所有人的收益都为0。如果有一些人加塞，而另一些人不加塞，那么加塞的人会提前，而不加塞的人则会落后。这种情况下，加塞的人的收益为1，不加塞的人的收益为-1。\n\n因此，在这个例子中，加塞并不是纳什均衡的一种策略，因为当其他人都加塞时，加塞的人的收益为0，而不加塞的人的收益也为0。这样，加塞的人就有动机去改变自己的策略，而不加塞的人也有动机去改变自己的策略。因此，在这个例子中，不加塞是一种纳什均衡的策略。", "Konwledge_Point": "零和博弈", "Question": "对于博弈论蒟蒻的一个不成熟的想法\n看一看 瞧一瞧\n本蒟蒻有一个关于博弈论的问题\n\n\n就是堵车是不是也是个纳什均衡点\n对于每个人来说如果他加塞他就有可能比别人快也可能堵在一起，但是他不加塞一种情况是目前位置不变，另一种是被别人加塞自己落到最后，所以对于每个人来说加塞是他的个人最优解\n\n\nA加塞：\n（1）别人也加塞，两人堵在一起，收益为0\n（2）别人不加塞，A成为第一，收益为1\nA不加塞：\n（1）别人加塞，A落到最后一名，收益为-1\n（2）别人也不加塞，和平相处，收益为0\n综上加塞是最优解", "Tag": "算法分析"}
{"Answer": "你题目的解答代码如下：（如有帮助，望采纳！谢谢! 点击我这个回答右上方的【采纳】按钮）\n#include <iostream>\nusing namespace std;\nvoid dl(int m,int a,int b);\nint main()\n{\n    int n, m, a, b;\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> m >> a >> b;\n        dl(m, a, b);\n    }\n    return 0;\n}\n\nvoid dl(int m,int a,int b)\n{\n    int t = -1; //1为HX，-1为YY；\n    for (int i = 1; i <= m;)\n    {\n        if (m == 1)\n        {\n            cout << \"No\" << endl;\n            return;\n        }\n        else\n        {\n            t *= -1;\n            //cout<<\"t=\"<<t<<endl;\n            if (t == 1)\n            {\n                for (int j = 1; j <= a; j++)\n                {\n                    if ((i + j) == m)\n                    {\n                        cout << \"Yes\" << endl;\n                        return;\n                    }\n                    if (j == a)\n                    {\n                        i += 1;\n                    }\n                }\n            }\n            if (t == -1)\n            {\n                for (int j = 1; j <= b; j++)\n                {\n                    if ((i + j) == m)\n                    {\n                        cout << \"No\" << endl;\n                        return;\n                    }\n                    if (j == b)\n                    {\n                        i += 1;\n                    }\n                }\n            }\n        }\n    }\n}\n\n", "Konwledge_Point": "零和博弈", "Question": "巴什博弈的类型题求解\n", "Tag": "算法分析"}
{"Answer": "你题目的解答代码如下：（如有帮助，望采纳！谢谢! 点击我这个回答右上方的【采纳】按钮）\nvar arr = [3,5,7];\nvar player = 1;\nwhile (true) {\n    var n = parseInt(prompt(\"请输入\"+player+\"号玩家拿牙签的数目（1-\"+arr[0]+\"）\",\"\"), 10);\n    if (n<1 || n>arr[0]) {\n        alert(\"牙签的数目错误，请重新输入！\");\n        continue;\n    }\n    arr[0] -= n;\n    if (arr[0]==0)\n        arr.shift();\n    alert(\"剩余牙签的数目：\"+arr);\n    if (arr.length>0) {\n        player = player==1?2:1;\n    } else {\n        break;\n    }\n}\nalert(player+\"号玩家输了！\");\n\n", "Konwledge_Point": "零和博弈", "Question": "三堆火柴-博弈-笔试题\n15个任意物品（可以是火柴牙签poker）\n以下按牙签为例\n\n\n将15根牙签\n分成三行\n每行自上而下（其实方向不限）分别是3、5、7根\n\n\n安排两个玩家，每人可以在一轮内，在任意行拿任意根牙签，但不能跨行\n\n\n拿最后一根牙签的人即为输家\n\n\n请用你最擅长的语言，以你觉得最优雅的方式写一个符合以上游戏规则的程序。完成后把写好的代码和简历同时发到以下邮箱（备注姓名+岗位），并加上一段简短的文字描述一下你的想法\n（请使用javascript，typescript或C#的其中一种语言完成测试题）", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/keshuai19940722/article/details/47115679", "Konwledge_Point": "零和博弈", "Question": "who is the best?              \nProblem Description\n\nThere are N people want to choose the best person. Each person select the best person ai, .John wants to know that who received the most number of votes.\n\n\n\nInput\n\nThe first line contains a single integer T(1≤T≤50),indicating the number of test cases.\n\nEach test case begins with an integer N(1≤N≤100),indicating the number of person.\n\nNext N lines contains an integer ai(1≤ai≤N).\n\n\n\nOutput\n\nFor each case, output an integer means who is the best person. If there are multiple answers, print the minimum index.\n\n\n\nSample Input\n\n2\n\n10\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n5\n\n3\n\n3\n\n3\n\n3\n\n3\n\n\n\nSample Output\n\n1\n\n3", "Tag": "算法分析"}
{"Answer": "代码中，你的t,x,y代表什么？你要为t,x,y设置数据类型啊", "Konwledge_Point": "零和博弈", "Question": "MATLAB 程序运行出现 ：未定义函数或变量 't'\n用M-\n文件函数形式\n\n\n\n以下是函数窗口\n\n\n\n\n\nfunction xdot = fun1(t,x,y)   \nxdot = [f(t,x(t),y(t));x(t)];\n\n\n\n然后到命令行窗口\n\n\n\n\n\n\n[t,x,y]= ode23('@fun1',[t,tf],[x,y])\n\n\n\n结果运行说未定义函数或变量 't'\n\n\n\n如下图所示\n\n\n\n\n\n\n路径和文件名应该没错   不知道什么原因\n\n\n\n \n\n\n\n下图是代码来源\n\n\n\n\n\n\n \n\n\n\n求大佬教教   最近刚学习MATLAB", "Tag": "算法分析"}
{"Answer": "使用 while True 循环来一直input获得输入，直到用户输入空字符串回车位置。然后把每次获得的输入存入列表里，最后再用换行符将列表里的元素连接起来即可。\ncontent = []\nwhile True:\n    line = input()\n    if line == \"\":break\n    content.append(line)\nres = \"\\n\".join(content)\n", "Konwledge_Point": "零和博弈", "Question": "python怎么用input输入大段落文字或列表？\ns\n = \n'''\n货物损坏，货物完整\n知情，不知情\n不完全信息博弈，完全信息博弈\na,b\n单向担心，互相担心\n了解流程，不了解流程\n想和平解决，不想和平解决\n高高在上，表情和气\n啥也不是，啥也是\n坚持，不坚持\n'''\n\n", "Tag": "算法分析"}
{"Answer": "这看个人喜好吧，我喜欢用推导式。具体要看你真实需要是什么，要求怎么使用这些数据\n>>> s = '''\n货物损坏，货物完整\n知情，不知情\n不完全信息博弈，完全信息博弈\na,b\n单向担心，互相担心\n了解流程，不了解流程\n想和平解决，不想和平解决\n高高在上，表情和气\n啥也不是，啥也是\n坚持，不坚持\n'''\n>>> [i.split('，') for i in s.split()]\n[['货物损坏', '货物完整'], ['知情', '不知情'], ['不完全信息博弈', '完全信息博弈'], ['a,b'], ['单向担心', '互相担心'], ['了解流程', '不了解流程'], ['想和平解决', '不想和平解决'], ['高高在上', '表情和气'], ['啥也不是', '啥也是'], ['坚持', '不坚持']]\n", "Konwledge_Point": "零和博弈", "Question": "Python3怎么拆包，然后求笛卡尔积？\n# py字符串\n\n'''\n货物损坏，货物完整\n知情，不知情\n不完全信息博弈，完全信息博弈\na,b\n单向担心，互相担心\n了解流程，不了解流程\n想和平解决，不想和平解决\n高高在上，表情和气\n啥也不是，啥也是\n坚持，不坚持\n'''\n\n\n\n我的疑问是，\"\\n\"拆包后，有的教程是迭代列表，有的是列表推导式，有的是笛卡尔求积，\n\n\n他们说的是一回事吗？\n", "Tag": "算法分析"}
{"Answer": "对于新科技，不同的立场会有不同的态度和对大众的引导。比如，有些人可能会支持新科技，认为它可以改善人们的生活，并且会努力推广新科技，向大众介绍新科技的优势；而另一些人可能会担心新科技会带来不利的影响，因此会努力提醒大众注意新科技的风险，并且提倡谨慎使用新科技。", "Konwledge_Point": "零和博弈", "Question": "立场不同，对新科技会有怎样不同的态度和对大众的引导？\n一位科学家曾说，“其实在科学家眼里，这些人工智能模型并没有那么创新，但可能对有限认知的消费者来说似乎很花哨。”\n一位科技巨头曾言，“ChatGPT的出现是一场前所未有的工业革命。”\n一方资本呐喊，“ChatGPT，这就是未来啊！”\n立场不同，对新科技会有怎样不同的态度和对大众的引导？\n我们究竟要如何理解ChatGPT？ChatGPT为何在今时今日大火？它的进化有何等意义？\nChatGPT来了，科技巨头如何博弈？对普通人而言哪些工作会失业？哪些工作无需担忧？如何为我们所用？", "Tag": "算法分析"}
{"Answer": "不是特别安全。有被爬到的风险", "Konwledge_Point": "零和博弈", "Question": "微信收藏夹真的安全吗\n我把助记词放进了微信收藏，有一天钱包收到80万u突然显示有人登录我的钱包，我和对方一直互相顶登录，经过40多分钟的博弈，我的手速比较快，没有资金损失，从那以后助记词就没放到过任何电子产品，现在仍旧心有余悸，\n想问的是，微信收藏夹在技术上真的不安全吗？黑客是怎么从技术做到的？\n第三方授权，可以不点确认就授权钱包嘛？", "Tag": "算法分析"}
{"Answer": "重力原则是指同一个柱子的棋子必须从下到上吗？如果选择的两个柱子都相同就不互换了是吧？", "Konwledge_Point": "零和博弈", "Question": "自己设计了一款棋 如何去验证其规则的平衡性\n换柱棋\n玩法：3x3x3的棋盘 双方轮流下，先手方总共落14子 后手方落13子 落子遵循重力原则 布局下满棋盘后\n记各自三子连珠次数分别为A,B（任意角度三子连珠都可以，横着竖着斜着都可以 只要这三个珠子在一条线上即可（对角线也可以）\n\n\n\n\n然后双方同时各自选择两个柱子进行交换（九根柱子，对应编号为1－9号，一个柱子有三颗棋，在做出选择前并不知道对方的选择）\n例如玩家一选择柱子1，2号交换\n 玩家二选 柱子3，4号交换\n则12柱子进行交换 34柱子进行交换位置 最后统计交换后的各自连珠次数 分别计为a，b 最终双方成绩分别为A+a与B+b\n若同分 则后下者为胜 若后手仅比先手少一分 则重复换柱环节 然后再加上再次换柱后各自连珠的数值\n若选择的柱子有重复的 例如玩家一选择了1号2号柱子 玩家二选择了2号三号柱子 则13柱子进行交换 重复柱子不变\n\n\n胜负判定:\n\n\n若后手仅比先手少一分 则重复换柱环节 \n若先手总分比后手高两分及以上则先手胜 \n若后手总分大于等于先手则后手胜\n\n\n前面的属于确定性完全信息博弈 后面的换柱环节属于不完全信息博弈 我想知道该怎么用算法去研究这款棋的规则是否平衡 是否合理 。", "Tag": "算法分析"}
{"Answer": "就是生成一个[0,8)的随机整数，然后如果这个数字>=N，就表示加入，否则弃权\r\nN分别是0 1 2 3 ... 7\r\n\r\n好像代码以前给你了？", "Konwledge_Point": "零和博弈", "Question": "哪位有带弃权概率的囚徒困境相关c语言的代码吗？\n自愿参与的囚徒困境，在此基础上加入弃权概率，（0,0.125,0.25,0.375，...1）是每个个体的弃权概率，个体可以根据这个概率选择加入或者不加入囚徒困境，哪位有相关的c语言的程序吗？\n\n\n\n在c语言中如何概率选择，给每个个体随机生成了一个弃权概率数，在博弈过程中如何把这个概率加进去，有没有哪位大神指点一下，万分感谢!!!", "Tag": "算法分析"}
{"Answer": "\nclass Solution:\n    def __init__(self) -> None:\n        self.choice = {\"Rock\", \"Scissors\", \"Paper\"}\n\n    def Game(self, N: int) -> None:\n        \"\"\"\n        :param N:\n        :return:\n        \"\"\"\n\n        def decision(way1: str, way2: str) -> str:\n            \"\"\"\n            :param way1:\n            :param way2:\n            :return:\n            \"\"\"\n            if way1 == \"Rock\":\n                if way2 == \"Rock\":\n                    return \"Tie\"\n                elif way2 == \"Scissors\":\n                    return \"Player1\"\n                else:\n                    return \"Player2\"\n            elif way1 == \"Scissors\":\n                if way2 == \"Scissors\":\n                    return \"Tie\"\n                elif way2 == \"Rock\":\n                    return \"Player2\"\n                else:\n                    return \"Player1\"\n            else:\n                if way2 == \"Paper\":\n                    return \"Tie\"\n                elif way2 == \"Scissors\":\n                    return \"Player2\"\n                else:\n                    return \"Player1\"\n\n        arr = []\n        for i in range(N):\n            choices = input()\n            choices1, choices2 = choices.split(' ')\n            if choices1 not in self.choice:\n                print(\"Input Error, Enter Again\")\n                i -= 1\n                continue\n            if choices2 not in self.choice:\n                print(\"Input Error, Enter Again\")\n                i -= 1\n                continue\n            arr.append(decision(way1=choices1, way2=choices2))\n        for i in arr:\n            print(i)\n\n\nif __name__ == '__main__':\n    U = Solution()\n    num = int(input())\n    U.Game(num)\n\n\n", "Konwledge_Point": "零和博弈", "Question": "1102：练7.4  石头剪子布\n问题遇到的现象和发生背景\n\n\n1102：练7.4  石头剪子布\n\n\n时间限制: 1000 ms         内存限制: 65536 KB\n提交数: 354     通过数: 204\n【题目描述】\n石头剪子布，是一种猜拳游戏。起源于中国，然后传到日本、朝鲜等地，随着亚欧贸易的不断发展它传到了欧洲，到了近现代逐渐风靡世界。简单明了的规则，使得石头剪子布没有任何规则漏洞可钻，单次玩法比拼运气，多回合玩法比拼心理博弈，使得石头剪子布这个古老的游戏同时用于“意外”与“技术”两种特性，深受世界人民喜爱。\n\n\n游戏规则：石头打剪刀，布包石头，剪刀剪布。\n\n\n现在，需要你写一个程序来判断石头剪子布游戏的结果。\n\n\n【输入】\n第一行是一个整数N，表示一共进行了N(1 ≤ N ≤ 100)次游戏。\n\n\n接下来N行的每一行包括两个字符串，表示游戏参与者Player1，Player2的选择（石头、剪子或者是布）：\n\n\nS1 S2\n\n\n字符串之间以空格隔开S1,S2只可能取值在{\"Rock\", \"Scissors\", \"Paper\"}(大小写敏感)中。\n\n\n【输出】\n输出包括N行，每一行对应一个胜利者（Player1或者Player2），或者游戏出现平局，则输出Tie。\n\n\n【输入样例】\n3\nRock Scissors\nPaper Paper\nRock Paper\n【输出样例】\nPlayer1\nTie\nPlayer2\n\n\n问题相关代码，请勿粘贴截图\n\n\n运行结果及报错内容\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/iaccepted/article/details/24737385?utm_source=tuicool", "Konwledge_Point": "零和博弈", "Question": "Brave Game           \nProblem Description\n\n十年前读大学的时候，中国每年都要从国外引进一些电影大片，其中有一部电影就叫《勇敢者的游戏》（英文名称：Zathura），一直到现在，我依然对于电影中的部分电脑特技印象深刻。\n\n今天，大家选择上机考试，就是一种勇敢（brave）的选择；这个短学期，我们讲的是博弈（game）专题；所以，大家现在玩的也是“勇敢者的游戏”，这也是我命名这个题目的原因。\n\n当然，除了“勇敢”，我还希望看到“诚信”，无论考试成绩如何，希望看到的都是一个真实的结果，我也相信大家一定能做到的~\n\n\n\n各位勇敢者要玩的第一个游戏是什么呢？很简单，它是这样定义的：\n\n1、  本游戏是一个二人游戏;\n\n2、  有一堆石子一共有n个；\n\n3、  两人轮流进行;\n\n4、  每走一步可以取走1…m个石子；\n\n5、  最先取光石子的一方为胜；\n\n\n\n如果游戏的双方使用的都是最优策略，请输出哪个人能赢。\n\n\n\nInput\n\n输入数据首先包含一个正整数C(C<=100)，表示有C组测试数据。\n\n每组测试数据占一行，包含两个整数n和m（1<=n,m<=1000），n和m的含义见题目描述。\n\n\n\nOutput\n\n如果先走的人能赢，请输出“first”，否则请输出“second”，每个实例的输出占一行。\n\n\n\nSample Input\n\n2\n\n23 2\n\n4 3\n\n\n\nSample Output\n\nfirst\n\nsecond", "Tag": "算法分析"}
{"Answer": "http://www.acmerblog.com/hdu-1822-Earn-more-money-2804.html", "Konwledge_Point": "零和博弈", "Question": "Earn more money ready                 \nProblem Description\n\n渴望占有愈多而愈脆弱。\n\n              —— 安妮宝贝\n\n\n\n古有Bill gates辍学创业，今有Wiskey创作卖书。但是如今网络写手太多，Wiskey愁着自己写的书没人买，所以特地到网络上搜集了许多信息，最后发现最大的竞争对手是来自距离地球有一亿亿光年的伽玛星球的U.F.O集团，据说都是吃泡面不眨眼的家伙。为了使自己的利益最大化，Wiskey开始思考着对策，但是U.F.O集团也不是专吃方便面的，她们也会往自己利益最大化的方向前进，两者轮流决策，不能改变对方的决策，并且两者的决策信息是公开的。请各位看官预测下Wiskey和U.F.O竞争的最后结果。\n\n\n\n假如U.F.O和Wiskey从（400，400）开始，U.F.O先开始。对于U.F.O来说，（600，400）能是她们最大利益为50，轮到Wiskey决策，他会选择（600，800）收益45，U.F.O继续选择（800，800），而Wiskey再选择（800，600），此时Wiskey收益50，而U.F.O收益45。但对于U.F.O来说（800，600）这也是她们在Wiskey选择600的前提下自己的最优决策。这样U.F.O和Wiskey的竞争会稳定下来，最终的利益分配为（45，50）。当两者的利益已经最大化了，决策就会停止，这个点在博弈中就是Nash均衡点。\n\n给你两人的收益表，请计算出Nash均衡点。\n\n\n\nInput\n\n第一个数字T，表示测试数据数目。每个测试数据包含X和Y，表示U.F.O有X种决策，Wiskey有Y种决策，接下来是X×Y的矩阵，表示U.F.O的收益表，最后是Y×X的矩阵，表示Wiskey的收益表。\n\n\n\nOutput\n\n如果只有一个点请输出最终利益分配，其余答案则输出“Have XX Nash Points.”，一个答案一行。\n\n\n\nSample Input\n\n2\n\n3 3\n\n10 15 10\n\n50 40 15\n\n40 45 35\n\n\n\n45 15 10\n\n50 40 50\n\n40 45 35\n\n\n\n3 3\n\n10 15 10\n\n50 40 50\n\n40 45 35\n\n\n\n45 15 10\n\n50 40 50\n\n40 45 35\n\n\n\nSample Output\n\n45 50\n\nHave 2 Nash Points.                         ", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/levoleurdombres/article/details/43203067", "Konwledge_Point": "零和博弈", "Question": "Earn more money                 \nProblem Description\n\n渴望占有愈多而愈脆弱。\n\n              —— 安妮宝贝\n\n\n\n古有Bill gates辍学创业，今有Wiskey创作卖书。但是如今网络写手太多，Wiskey愁着自己写的书没人买，所以特地到网络上搜集了许多信息，最后发现最大的竞争对手是来自距离地球有一亿亿光年的伽玛星球的U.F.O集团，据说都是吃泡面不眨眼的家伙。为了使自己的利益最大化，Wiskey开始思考着对策，但是U.F.O集团也不是专吃方便面的，她们也会往自己利益最大化的方向前进，两者轮流决策，不能改变对方的决策，并且两者的决策信息是公开的。请各位看官预测下Wiskey和U.F.O竞争的最后结果。\n\n\n\n假如U.F.O和Wiskey从（400，400）开始，U.F.O先开始。对于U.F.O来说，（600，400）能是她们最大利益为50，轮到Wiskey决策，他会选择（600，800）收益45，U.F.O继续选择（800，800），而Wiskey再选择（800，600），此时Wiskey收益50，而U.F.O收益45。但对于U.F.O来说（800，600）这也是她们在Wiskey选择600的前提下自己的最优决策。这样U.F.O和Wiskey的竞争会稳定下来，最终的利益分配为（45，50）。当两者的利益已经最大化了，决策就会停止，这个点在博弈中就是Nash均衡点。\n\n给你两人的收益表，请计算出Nash均衡点。\n\n\n\nInput\n\n第一个数字T，表示测试数据数目。每个测试数据包含X和Y，表示U.F.O有X种决策，Wiskey有Y种决策，接下来是X×Y的矩阵，表示U.F.O的收益表，最后是Y×X的矩阵，表示Wiskey的收益表。\n\n\n\nOutput\n\n如果只有一个点请输出最终利益分配，其余答案则输出“Have XX Nash Points.”，一个答案一行。\n\n\n\nSample Input\n\n2\n\n3 3\n\n10 15 10\n\n50 40 15\n\n40 45 35\n\n\n\n45 15 10\n\n50 40 50\n\n40 45 35\n\n\n\n3 3\n\n10 15 10\n\n50 40 50\n\n40 45 35\n\n\n\n45 15 10\n\n50 40 50\n\n40 45 35\n\n\n\nSample Output\n\n45 50\n\nHave 2 Nash Points.", "Tag": "算法分析"}
{"Answer": "代码如下：\n\n#include <stdio.h>\n#include <process.h>\n\n//设置石头数目\nvoid Set(int *total)\n{\n\tint n;\n\tchar ch;\n\tprintf(\"当前石子总数:%d\\n\",*total);\n\tprintf(\"是否重新设置(Y/N)?\");\n\tscanf(\"%c\",&ch);\n\tif (ch == 'Y' || ch == 'y')\n\t{\n\t\tprintf(\"请输入石子总数:\");\n\t\twhile(1)\n\t\t{\n\t\t\tscanf(\"%d\",&n);\n\t\t\tif(n <= 0)\n\t\t\t{\n\t\t\t\tprintf(\"石子数大于0，请重新输入：\");\n\t\t\t}else\n\t\t\t\tbreak;\n\t\t}\n\t\t*total = n;\n\t\tsystem(\"cls\");\n\t\tprintf(\"设置成功！\\n\");\n\t\tprintf(\"当前石子总数:%d\\n\",*total);\n\t\tprintf(\"按任意键返回上一层...\");\n\t\tgetchar();\n\t\tgetchar();\n\t}\n}\n//取石子，返回取石子的个数\nint GetStone(int x)\n{\n\tint n;\n\tprintf(\"请输入取石子的个数:\");\n\twhile(1)\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tif (n<1 || n> 3)\n\t\t{\n\t\t\tprintf(\"石子数量只能是1、2或3，请重新输入:\");\n\t\t}else if( n > x)\n\t\t\tprintf(\"取的石子数大于剩余石子数，请重新输入:\");\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn n;\n}\n\n\n//开始游戏\nvoid StartGame(int total)\n{\n\tint a,b;\n\tint left = total;\n\twhile(1)\n\t{\n\t\tsystem(\"cls\");\n\t\tprintf(\"当前剩余石子数:%d\\n\",left);\n\t\tprintf(\"A:\");\n\t\ta = GetStone(left);\n\t\tleft -= a;\n\t\tif(left == 0)\n\t\t{\n\t\t\tprintf(\"A取到最后1个石子，A输\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tprintf(\"B:\");\n\t\tb = GetStone(left);\n\t\tleft -= b;\n\t\tif(left == 0)\n\t\t{\n\t\t\tprintf(\"B取到最后1个石子，B输\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\n\nint main()\n{\n\tint opt;\n\tint total = 100; //石头总数\n\tint bgo = 1;\n\twhile(bgo)\n\t{\n\t\tsystem(\"cls\");//清屏\n\t\tprintf(\"---------------石子游戏-------------\\n\");\n\t\tprintf(\"|     1.设置                       |\\n\");\n\t\tprintf(\"|     2.开始游戏                   |\\n\");\n\t\tprintf(\"|     3.退出                       |\\n\");\n\t\tprintf(\"------------------------------------\\n\");\n\n\t\tscanf(\"%d\",&opt);\n\t\tgetchar();\n\t\tswitch(opt)\n\t\t{\n\t\tcase 1:\n\t\t\tSet(&total);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tStartGame(total);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tbgo = 0;\n\t\t\tbreak;\n\t\t}\n\n\n\t}\n\treturn 0;\n}\n\n ", "Konwledge_Point": "零和博弈", "Question": "模拟一个取石子游戏编程\n设计一个系统模拟取石子游戏，基本功能包系括:设置，开始游戏。取石子游戏是一个博弈类游戏。有一堆石子，两个人分别从其中取石子，每次只能取1个、2个或3个，谁取到最后一个便输。\n\n 一级菜单显示“1.设置、 2.开始游戏3.退出”。用户输入自己的选择后，进入相应的二级菜单。比如，选择“2”，则进入“游戏”模块:当用户选择“3”时，退出系统。\n\n 用户选择“1”时，二级菜单显示“石子总数”，要求用户输入石子综述，比如输入“57”，则游戏中的石子总数便为57个。\n\n 用户选择“2”时，游戏开始。两人分别输入要取的石子个数，系统显示每次取的石子个数，并显示剩余石子个数。石子取完后，系统提示获胜方", "Tag": "算法分析"}
{"Answer": "\n#include <stdio.h>\n#include<iostream>\nusing namespace std;\n\nstatic int totalpebble = 47;\n\nvoid reInput(int a, int userId)\n{\n\twhile (a < 1 || a>3 || totalpebble < a)\n\t{\n\t\tprintf(\"石子个数错误，请用户%d重新选择石子个数：\", userId);\n\t\tscanf_s(\"%d\", &a);\n\t}\n\ttotalpebble -= a;\n\n}\n\nvoid takePebble()\n{\n\twhile (totalpebble)\n\t{\n\t\tprintf(\"-----------------------------------------\\n\");\n\t\tprintf(\"当前剩余石子：%d\\n\", totalpebble);\n\t\tprintf(\"请用户1选择石子个数：\");\n\t\tint a;\n\t\tscanf_s(\"%d\", &a);\n\t\treInput(a, 1);\t\t//如果输入石子个数不为1 2 3 ，大于剩余总石子个数，提示重新输入\n\t\tif (totalpebble == 0)\n\t\t{\n\t\t\tprintf(\"用户1获胜！\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tprintf(\"请用户2选择石子个数：\");\n\t\tint b;\n\t\tscanf_s(\"%d\", &b);\n\t\treInput(b, 2);\n\t\tif (totalpebble == 0)\n\t\t{\n\t\t\tprintf(\"用户2获胜！\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid pebbleGame()\n{\n\tprintf(\"--------取石子游戏--------\\n\");\n\tprintf(\"1、设置\\n\");\n\tprintf(\"2、游戏开始\\n\");\n\tprintf(\"3、退出\\n\");\n\tprintf(\"--------------------------\\n\");\n\tprintf(\"请选择目录：\");\n\tint n;\n\tscanf_s(\"%d\", &n);\n\tswitch (n)\n\t{\n\tcase 1:\n\t\tprintf(\"游戏简介：取石子游戏是一个博弈类游戏。有一堆石子，两个人分别从其中取石子，每次只能取1个、2个或3个，谁取到最后一个便输。\\n\");\n\t\tprintf(\"请输入石子总个数：\");\n\t\tscanf_s(\"%d\", &totalpebble);\n\t\tprintf(\"石子总个数设置成功！\\n\");\n\t\tpebbleGame();\n\tcase 2:\n\t\ttakePebble();\n\t\tpebbleGame();\n\tcase 3:\n\t\texit(0);\n\tdefault:\n\t\tbreak;\n\t}\n\n}\n\nint main(){\n\tpebbleGame();\n\tsystem(\"pause\");\n\treturn 0;\n}\n", "Konwledge_Point": "零和博弈", "Question": "求大神帮忙编程一下！\n设计一个系统模拟取石子游戏，基本功能包系括:设置，开始游戏。取石子游戏是一个博弈类游戏。有一堆石子，两个人分别从其中取石子，每次只能取1个、2个或3个，谁取到最后一个便输。\n\n 一级菜单显示“1.设置、 2.开始游戏3.退出”。用户输入自己的选择后，进入相应的二级菜单。比如，选择“2”，则进入“游戏”模块:当用户选择“3”时，退出系统。\n\n 用户选择“1”时，二级菜单显示“石子总数”，要求用户输入石子综述，比如输入“57”，则游戏中的石子总数便为57个。\n\n 用户选择“2”时，游戏开始。两人分别输入要取的石子个数，系统显示每次取的石子个数，并显示剩余石子个数。石子取完后，系统提示获胜方。", "Tag": "算法分析"}
{"Answer": "您好，我是有问必答小助手，您的问题已经有小伙伴解答了，您看下是否解决，可以追评进行沟通哦~\n\n如果有您比较满意的答案 / 帮您提供解决思路的答案，可以点击【采纳】按钮，给回答的小伙伴一些鼓励哦～～\n\nps: 问答会员年卡【8折】购 ，限时加赠IT实体书，即可 享受50次 有问必答服务，了解详情>>>https://t.csdnimg.cn/RW5m", "Konwledge_Point": "零和博弈", "Question": "有没有大神会编程一下感谢\n设计一个系统模拟取石子游戏，基本功能包系括:设置，开始游戏。取石子游戏是一个博弈类游戏。有一堆石子，两个人分别从其中取石子，每次只能取1个、2个或3个，谁取到最后一个便输。\n\n\n\n 一级菜单显示“1.设置、 2.开始游戏3.退出”。用户输入自己的选择后，进入相应的二级菜单。比如，选择“2”，则进入“游戏”模块:当用户选择“3”时，退出系统。\n\n\n\n 用户选择“1”时，二级菜单显示“石子总数”，要求用户输入石子综述，比如输入“57”，则游戏中的石子总数便为57个。\n\n\n\n 用户选择“2”时，游戏开始。两人分别输入要取的石子个数，系统显示每次取的石子个数，并显示剩余石子个数。石子取完后，系统提示获胜方。", "Tag": "算法分析"}
{"Answer": "崩溃的时候在弹出的对话框按相应按钮进入调试，按Alt+7键查看Call Stack即“调用堆栈”里面从上到下列出的对应从里层到外层的函数调用历史。双击某一行可将光标定位到此次调用的源代码或汇编指令处，看不懂时双击下一行，直到能看懂为止。\r\n\r\n代码功能归根结底不是别人帮自己看或讲解或注释出来的；而是被自己静下心来花足够长的时间和精力亲自动手单步或设断点或对执行到某步获得的中间结果显示或写到日志文件中一步一步分析出来的。\r\n提醒：再牛×的老师也无法代替学生自己领悟和上厕所！\r\n单步调试和设断点调试（VS IDE中编译连接通过以后，按F10或F11键单步执行，按Shift+F11退出当前函数；在某行按F9设断点后按F5执行停在该断点处。）是程序员必须掌握的技能之一。", "Konwledge_Point": "零和博弈", "Question": "求助大神五子棋alphabeta的迭代加深算法（出现异常）\nint AI::AlphaBeta(int depth, int alpha, int beta) {\n\n  int val;\n\n  total++;\n\n  // 对方最后一子连五\n\n  if (CheckWin())\n\n    return -10000;\n\n  // 叶节点\n\n  if (depth == 0)\n\n    return evaluate();\n\n  int count = GetMove(depth);\n\n  // 遍历所有走法\n\n  for (int i = 1; i <= count; i++) {\n\n    MakeMove(s[depth][i].p);\n\n    val = -AlphaBeta(depth - 1, -beta, -alpha);\n\n    DelMove();\n\n    if (val >= beta) {\n\n      ABcut++;\n\n      return val;\n\n    }\n\n    if (val > alpha) {\n\n      alpha = val;\n\n    }\n\n    return alpha;\n\n  }\n\n}\n\n  struct xy AI::gobang() {\n\n    int i;\n\n    clock_t start, finish;\n\n    start = clock();\n\n    cout << \"电脑思考中......\\n\";\n\n    total = 0;\n\n    ABcut = 0;\n\n    srand(time(NULL));\n\n    // 第一步下中心点\n\n    if (step == 0) {\n\n      BestMove.x = size / 2;\n\n      BestMove.y = size / 2;\n\n      return BestMove;\n\n    }\n\n    // 第二，三步随机\n\n    if (step == 2 || step == 1) {\n\n      int rx, ry;\n\n      do {\n\n        rx = rand() % 5 + chessxy[1].x - 2;\n\n        ry = rand() % 5 + chessxy[1].y - 2;\n\n      } while (chessboard[rx][ry] != 0);\n\n      BestMove.x = rx;\n\n      BestMove.y = ry;\n\n      return BestMove;\n\n    }\n\n    // 迭代加深搜索\n\n    for (int i= 2; i <= SearchDepth; i += 2) {\n\n    int depth=i;\n\n      int val;\n\n      int alpha=-10001;\n\n      int beta=10000;\n\n      total++;\n\n      int count = GetMove(depth);\n\n      // 遍历所有走法\n\n      for (int j = 1; j<= count; j++) {\n\n        MakeMove(s[depth][j].p);\n\n        val = -AlphaBeta(depth - 1, -beta, -alpha);\n\n        DelMove();\n\n        if (val >= beta) {\n\n          BestVal = val;\n\n          BestMove = s[depth][j].p;\n\n          ABcut++;\n\n          break;\n\n        }\n\n        if (val > alpha) {\n\n          BestVal=alpha = val;\n\n          BestMove = s[depth][j].p;\n\n        }\n\n      }\n\n      if (BestVal == 10000)\n\n        break;\n\n    }\n\n    finish = clock();\n\n    ThinkTime = (double)(finish - start) / CLOCKS_PER_SEC;\n\n    return BestMove;\n\n  }", "Tag": "算法分析"}
{"Answer": "```\r\n #include  \r\nusing namespace std;\r\nint largestFib(int n){\r\n\tif(n==0||n==1){\r\n\t\treturn n;\r\n\t} \r\n\tint a=0;\r\n\tint b=1;\r\n\tint c=1;\r\n\twhile(c<=n){\r\n\t\ta=b;\r\n\t\tb=c;\r\n\t\tc=a+b;\r\n\t}\r\n\treturn b;\r\n}\r\nint main(){\r\n\tint n;\r\n\tcin>>n;\r\n\twhile(n>0){\r\n\t\tint tempn=largestFib(n);\r\n\t\tcout<<tempn<<\" \";\r\n\t\tn=n-tempn;\r\n\t}\r\n\t\r\n}\r\n```", "Konwledge_Point": "零和博弈", "Question": "齐肯多夫定理的如何贪心实现\n齐肯多夫是说  任何自然数都可以由不连续的斐波那契数加和得到    问如题", "Tag": "算法分析"}
{"Answer": "使用暴力搜索吧，不外乎横、竖、左右斜对角这四种情况，我在纯暴力O(n3)的基础上做了一步优化，给你一种O(n2)的解法，希望能帮到你\r\n\r\n```\r\n #include \"iostream\"\r\nusing namespace std;\r\n//假设棋盘宽为100\r\n#define WIDTH   100\r\n//高为100\r\n#define HEIGHT  100\r\n\r\n//棋盘，没有落子的地方是0，，黑子是1，白子是2\r\nint keyMap[HEIGHT][WIDTH] = {0};\r\n\r\n// 向右下角搜索\r\nint rightBottomDetect(int tempI, int tempJ);\r\n// 向左下角搜索\r\nint leftBottomDetect(int tempI, int tempJ);\r\n\r\nint main(){\r\n    \r\n    //测试数据\r\n    for (int i=0; i<5; i++) {\r\n        keyMap[8+i][23+i]=2;\r\n    }\r\n    \r\n    \r\n    int isWin = 0;\r\n    // 水平方向是否是五子\r\n    for(int i = 0; i < HEIGHT && !isWin; i++) {\r\n        int stap = 1;\r\n        for(int j = 1; j < WIDTH; j++) {\r\n            if(keyMap[i][j] && keyMap[i][j] == keyMap[i][j-1]) {\r\n                stap ++;\r\n                if(stap >= 5) {\r\n                    isWin = keyMap[i][j];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    // 竖直方向是否是五子\r\n    for(int j = 0; j < WIDTH && !isWin; j++) {\r\n        int stap = 1;\r\n        for(int i = 1; i < HEIGHT; i++) {\r\n            if(keyMap[i][j] && keyMap[i][j] == keyMap[i-1][j]) {\r\n                stap ++;\r\n                if(stap >= 5) {\r\n                    isWin = keyMap[i][j];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    // 右下斜对角 part1\r\n    for (int j = 0; j < WIDTH && !isWin; j++) {\r\n        isWin = rightBottomDetect(1, j+1);\r\n    \r\n    }\r\n    // 右下斜对角 part2\r\n    for (int i = 0; i < HEIGHT && !isWin; i++) {\r\n        isWin = rightBottomDetect(i+1, 1);\r\n    }\r\n    \r\n    // 左下斜对角 part1\r\n    for (int j = 0; j < WIDTH && !isWin; j++) {\r\n        isWin = leftBottomDetect(1, j-1);\r\n    }\r\n    // 左下斜对角 part2\r\n    for (int i = 0; i < HEIGHT && !isWin; i++) {\r\n        isWin = rightBottomDetect(i+1, WIDTH - 2);\r\n    }\r\n    \r\n    if (isWin) {\r\n        cout<<\"赢棋的是:\";\r\n        if (isWin == 1) {\r\n            cout<<\"黑子\"<= 5) {\r\n                isWin = keyMap[tempI][tempJ];\r\n                break;\r\n            }\r\n        }\r\n        tempI ++;\r\n        tempJ ++;\r\n    }\r\n    return isWin;\r\n}\r\n\r\n// 向左下角搜索\r\nint leftBottomDetect(int tempI, int tempJ) {\r\n    int isWin = 0;\r\n    int stap = 1;\r\n    while (tempJ >= 0 && tempI < HEIGHT) {\r\n        if (keyMap[tempI][tempJ] && keyMap[tempI][tempJ] == keyMap[tempI - 1][tempJ + 1]) {\r\n            stap ++;\r\n            if (stap >= 5) {\r\n                isWin = keyMap[tempI][tempJ];\r\n                break;\r\n            }\r\n        }\r\n        tempI ++;\r\n        tempJ --;\r\n    }\r\n    return isWin;\r\n}\r\n\r\n```", "Konwledge_Point": "零和博弈", "Question": "不从最后一个棋子出发，有什么可以判断五子棋棋局是否有赢棋的简单方法?\n不从最后一个棋子出发，有什么可以判断五子棋棋局是否有赢棋的简单方法?", "Tag": "算法分析"}
{"Answer": "PC游戏编程---人机博弈有讲象棋和五子棋的 比较基础", "Konwledge_Point": "零和博弈", "Question": "求一套中国象棋比较合理的局面评估函数\n最近做一个中国象棋人机对弈，局面评估函数不知道怎么写。不用很复杂考虑到动态位置对子力的改变，只要每个棋子在各个位置的子力就可以了，不然自己不知道怎么设置比较合理，感谢~", "Tag": "算法分析"}
