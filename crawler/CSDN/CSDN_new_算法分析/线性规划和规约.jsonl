{"Answer": "您可以使用非线性规划库，例如 Math.NET Numerics 中的 NLopt 或者 Accord.NET 中的 Nelder-Mead 和 Simplex 方法来实现非线性规划。\nusing Accord.Math;\nusing Accord.Optimization;\n\nnamespace NonlinearProgrammingExample\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            // Define the objective function\n            NonlinearObjectiveFunction function = new NonlinearObjectiveFunction(x =>\n                x[0] * x[1] * (x[0] + x[1]),\n                2 // number of variables\n            );\n\n            // Define the constraints\n            NonlinearConstraint constraint1 = new NonlinearConstraint(x =>\n                x[0] * x[0] + x[1] * x[1] - 1,\n                0,\n                LessThanOrEqualToZero\n            );\n            NonlinearConstraint constraint2 = new NonlinearConstraint(x =>\n                x[1] - x[0],\n                0,\n                GreaterThanOrEqualToZero\n            );\n\n            // Create the solver\n            NonlinearProgram solver = new NonlinearProgram(function, new[] { constraint1, constraint2 });\n\n            // Solve the problem\n            double[] result = solver.Solve();\n\n            // Print the results\n            Console.WriteLine(\"Result: x = [{0}], f(x) = {1}\", string.Join(\", \", result), function.Value(result));\n        }\n    }\n}\n\n\n\n```", "Konwledge_Point": "线性规划和规约", "Question": "c#如何解决非线性规划\n目前想要用c#做一个求解简单的非线性规划的程序\n之前试过用matlab，但是似乎不能转换文件格式", "Tag": "算法分析"}
{"Answer": "http://www.acmerblog.com/hdu-1931-Target-Practice-3006.html", "Konwledge_Point": "线性规划和规约", "Question": "一个有关于线性规划的问题，具体问题请看下面的问题描述\nProblem Description\n\nThere are many forms of contests where the contestants (shooters) try to hit targets, either moving or still. In this version there are a number of small balloons sitting on the tops of poles that are in turn stuck in the ground at various points in a large field. These poles are not all the same height. The shooter circles the field and fires at the balloons, the goal being to burst all the balloons with as few shots as possible. Since the balloons offer almost no resistance to a bullet, the bullet will pass right through and possibly hit one or more other balloons. So, by judiciously taking shots, the shooter might need only a very few shots to hit all the targets (provided the shooter is a good marksman, which we will assume is the case).\n\nFor example, the following field of 10 targets can be covered in only four shots, as shown. (The first two numbers at each position indicate the position of the balloon, and the third number the height.)\n\nYour job is to determine the fewest number of shots necessary to hit all the targets in a given field.\n\n\n\nInput\n\nThere will be multiple test cases. Each test case will consist of an integer n (<= 50) indicating the number of target positions to follow. A value of n = 0 indicates end of input. There will follow n integer triples, x y h, indicating a balloon at position (x, y) in the field at height h. (There will be at most one balloon at any position (x, y).) All integers are greater than 0 and no greater than 100. Furthermore assume that the shooter can take shots from anywhere on the field at any height. For simplification, assume here that the balloons are points and that the bullets can pass through the poles on which the balloons are perched.\n\n\n\nOutput\n\nEach test case should produce one line of output of the form:\n\nTarget set k can be cleared using only s shots.\n\nwhere k is the number of the test case, starting at 1, and the value of s is the minimum number of shots needed to hit all the targets in the set.\n\n\n\nSample Input\n\n10\n\n5 15 4 10 60 52 17 27 4 33 20 10 33 85 31 42 52 4 70 70 22\n\n78 88 4 85 40 58 100 75 7\n\n9\n\n5 15 4 10 60 52 17 27 4 33 20 10 33 85 31 42 52 4 70 70 22\n\n78 88 4 100 75 7\n\n0\n\n\n\nSample Output\n\nTarget set 1 can be cleared using only 4 shots.\n\nTarget set 2 can be cleared using only 3 shots.", "Tag": "算法分析"}
{"Answer": "目标函数不是线性函数，这个优化问题不是线性规划，可以使用有约束非线性优化方法来求求解，使用fmincon函数，代码如下：\n\nfun = @(x) 12*x(1) + 3*x(1)*ceil(x(2)-1) - 1.5*ceil(x(2)-1)*x(1);\nA = [1 0\n     0 1\n     -1 0\n     0 -1];\nb = [1\n     30\n     0\n     0];\nx0 = [0.5 15]';\nx = fmincon(fun,x0,A,b);\ng = fun(x)\n\nw = x(1)\nxx = x(2)\np = w/3\n结果\n\ng =\n\n   2.0001e-08\n\n\nw =\n\n   1.6667e-09\n\n\nxx =\n\n    0.0983\n\n\np =\n\n   5.5557e-10\n ", "Konwledge_Point": "线性规划和规约", "Question": "MATLAB线性规划问题\n如何使用MATLAB求下列方程最优解\nmin f(x)=12*ω+3*ω*ceil (x-1)-1.5*ceil (x-1)\nω=3*p\n0≤x≤30\n0＜ω＜1\n求最优 x 和 ω 以及 p\n", "Tag": "算法分析"}
{"Answer": "只有5个元素，分别是0,1,2,3,4，下标为5超出了上限，请检查一下代码。", "Konwledge_Point": "线性规划和规约", "Question": "python小白上路，用pso算法解决多元带约束的非线性规划，\n用pso算法解决多元带约束的非线性规划，一直错误，盼望各位大佬多多指点我一下.\n\n\n\n照猫画虎，还没有人解答，还不知道去看什么，也不知道怎么办，救救孩子吧\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "11\n%fun1.m文件\n function f=fun1(x)\nf=sum(x.^2)+8;\nend\n\n%fun2.m文件\nfunction [g,h]=fun2(x)\ng=[-x(1)^2+x(2)-x(3)^2,x(1)+x(2)^2+x(3)^2-20];\nh=[x(2)+2*x(3)^2-3,-x(1)-x(2)^2+2];\nend\n\n命令行输入\n\nclear\nx0=[0.5,0.5,0.5];    %初值\nlb=[0,0,0];\nub=[inf,inf,inf];\nA=[];b=[];Aeq=[];beq=[];\n[x,fval]=fmincon('fun1',x0,A,b,Aeq,beq,lb,ub,'fun2');\n\n22\n[x,y]=ode45(@cal,[0 1],[0;1;1]);\nplot(x,y(:,1));\n \nfunction res=cal(~,y)\n    res = zeros(3,1);\n    res(1)=y(2)*y(3);\n    res(2)=-y(1)*y(3);\n    res(3)=-0.5*y(1)*y(2);\nend\n", "Konwledge_Point": "线性规划和规约", "Question": "用matlab求非线性规划和常微分方程组\n11．求下列非线性规划，初值为（0.5，0.5,0.5）\n\n\n\n\n12.求常微分方程组的解。\n范围[0 10]", "Tag": "算法分析"}
{"Answer": "这句话是正确的，因为栈和队列都必须在两头进行操作而不能随机的存取内部任何一个结点，所以是顺序存取的线性表。栈只能在栈顶进行存取，而队列只能从队尾插入结点队头删除结点，所以存取位置限制不同。", "Konwledge_Point": "线性规划和规约", "Question": "栈和队列都是限制存取点的线性结构\n栈和队列都是限制存取点的线性结构这句话是什么意思？\n\n不太理解，求教", "Tag": "算法分析"}
{"Answer": "非线性系统不能用ss函数来建模了，ss只能描述线性状态方程，非线性系统需要用微分方程描述，使用ode45来求解响应。", "Konwledge_Point": "线性规划和规约", "Question": "如何使用matlab解决非线性状态空间的问题\n在状态空间系统中，如E\\dot x=Ax+Bu,y=Cx+Du中，A矩阵内含有x2，该如何修改matlab程序，使得程序可以运行。\n\n\n\n \n\n\n\nE=[1 1;0 0]\n\nA=[-2 0;1 x2];%x=[x1;x2]\n\nB=[-1;0];\n\nC=[-1 -1];\n\nD=0;\n\nt=0:0.01:5;\n\nw=exp(-t);\n\nsys1=dss(A,B,C,D,E);\n\n[y,t,x]=lsim(sys1,w,t);\n\nplot(t,x)\n\n ", "Tag": "算法分析"}
{"Answer": "MatrixEquation me = new MatrixEquation(x点的数组， y点的数组, n);\r\nme.XXX调用，具体看你上面注释", "Konwledge_Point": "线性规划和规约", "Question": "c#实现最小二乘法线性拟合\npublic class MatrixEquation\n\n    {\n\n        private double[,] gaussMatrix;\n\n        private int coe;\n\n\n\n    public MatrixEquation()\n    {\n    }\n\n    public MatrixEquation(double[] arrX, double[] arrY, int n)\n    {\n        coe = n;\n        gaussMatrix = GetGauss(GetXPowSum(arrX, n), GetXPowYSum(arrX, arrY, n), n);\n    }\n\n    public double[,] GetGaussMatrix()\n    {\n        return gaussMatrix;\n    }\n\n    public double[] GetResult()\n    {\n        return ComputeGauss(gaussMatrix, coe);\n    }\n\n    ///  计算获取x散点的幂次和数组  \n    /// x散点序列 \n    /// 函数拟合次数 \n    ///  \n    protected double[] GetXPowSum(double[] arrX, int n)\n    {\n        int m = arrX.Length;//X散点的个数\n\n        double[] xPow = new double[2 * n + 1]; //存储X散点的幂次值\n\n        for (int i = 0; i < xPow.Length; i++)\n        {\n            if (i == 0)\n            {\n                xPow[i] = m;\n            }\n            else\n            {\n                //计算x的i次方和\n\n                double max = 0;\n                for (int j = 0; j < m; j++)\n                {\n                    if (arrX[j] == 0)\n                        max = max + 1;\n                    else\n                        max = max + Math.Pow(arrX[j], i);\n                }\n                xPow[i] = Math.Round(max, 4);\n            }\n        }\n        return xPow;\n    }\n\n    /// 计算获取xy的幂次和序列  \n    /// x散点序列 \n    /// y散点序列 \n    /// 拟合曲线次数 \n    ///  \n    protected double[] GetXPowYSum(double[] arrX, double[] arrY, int n)\n    {\n        int m = arrX.Length;//X散点的个数\n\n        double[] xyPow = new double[n + 1]; //仓储X散点的幂次值\n\n        for (int i = 0; i < xyPow.Length; i++)\n        {\n            //计算xy的i次方和\n\n            double max = 0;\n            for (int j = 0; j < m; j++)\n            {\n                if (arrX[j] == 0)\n                    max = max + 1;\n                else\n                    max = max + Math.Pow(arrX[j], i) * arrY[j];\n            }\n            xyPow[i] = Math.Round(max, 4);\n        }\n        return xyPow;\n    }\n\n    ///  获取高斯矩阵(增广矩阵)             \n    /// X的幂次和 \n    /// XY的幂次和 \n    /// 拟合曲线次数 \n    ///  \n    protected double[,] GetGauss(double[] arrX, double[] arrXY, int n)\n    {\n        double[,] gauss = new double[n + 1, n + 2];\n        for (int i = 0; i < n + 1; i++)\n        {\n            int j;\n            int m = i;\n            for (j = 0; j < n + 1; j++)\n            {\n                gauss[i, j] = arrX[m];\n                m++;\n            }\n            gauss[i, j] = arrXY[i];\n        }\n\n        return gauss;\n    }\n\n    ///  求解拟合曲线的系数                   \n    /// 线性方程的增广矩阵 \n    /// 方程次数 \n    ///  \n    protected double[] ComputeGauss(double[,] gauss, int n)\n    {\n        double[] a = new double[n + 1];\n        double s;\n        int matrixLine = n + 1;\n        for (int i = 0; i < n + 1; i++)\n            a[i] = 0;\n        //循环每列\n\n        for (int j = 0; j < matrixLine; j++)\n        {\n            //每列J行以后的绝对值最大值\n\n            double max = 0;\n            int k = j;\n            for (int i = j; i < matrixLine; i++)\n            {\n                if (Math.Abs(gauss[i, j]) > max)\n                {\n                    max = gauss[i, j];\n                    k = i;\n                }\n            }\n            //判断j行否为最大值行 若不是将j行调换为最大值行\n\n            if (k != j)\n            {\n                double temp; for (int m = j; m < matrixLine + 1; m++)\n                {\n                    temp = gauss[j, m];\n                    gauss[j, m] = gauss[k, m];\n                    gauss[k, m] = temp;\n                }\n            }\n            if (max == 0)\n            {\n                //奇异矩阵无解\n\n                return a;\n            }\n            //进行初等行变换得到上三角矩阵\n\n            for (int i = j + 1; i < matrixLine; i++)\n            {\n                s = gauss[i, j];\n                for (int m = j; m < matrixLine + 1; m++)\n                {\n                    gauss[i, m] = Math.Round(gauss[i, m] - gauss[j, m] * s / gauss[j, j], 6);\n                }\n            }\n        }\n        //根据倒推方式一次计算现行方程的解\n\n        for (int i = matrixLine - 1; i >= 0; i--)\n        {\n            s = 0;\n            for (int j = i + 1; j < matrixLine; j++)\n            {\n                s += gauss[i, j] * a[j];\n            }\n            a[i] = Math.Round((gauss[i, matrixLine] - s) / gauss[i, i], 6);\n        }\n        //返回方程的解即拟合曲线的系数\n\n        return a;\n    }\n}\n    ------------------------\n    以上是本人在网上看到的一个例子，但是不理解该怎么样测试这个类，请各位大神赐教！或者可以提供相关参考链接也可以。\n", "Tag": "算法分析"}
{"Answer": "参考http://blog.sina.com.cn/s/blog_7671b3eb01013vma.html", "Konwledge_Point": "线性规划和规约", "Question": "怎样求2个变量的非线性相关性(nonlinear correlation)？\n线性的用correlation coefficient\n\n非线性的呢？\n\ninformation gain（信息增益）、CHI suqare（卡方分布）、mutual information（互信息）,期望交叉熵 好像只能用来检测feature和class的关联度，不能检测feature和feature之间的\n\nT-Test和F-test算出来的那个值不知道如何利用，我能根据T-Test的结果反映出2个变量的相关度高低吗", "Tag": "算法分析"}
{"Answer": "matlab\nx1 = [1 2 3 4 5 6]';\nx2 = [.2 .4 .8 .9 1.1 2.1]';\nX = [x1 x2]; \nf = [ 3.3079 6.6358 10.3143 13.6492 17.2755 23.6271]';\nobjfcn = @(A,X)A(1)*x1 + x2.^(A(2));\nx0=1; \nx0=(1)*[1;1];\n[vestimated,resnorm] = lsqcurvefit(objfcn,x0,X,f)", "Konwledge_Point": "线性规划和规约", "Question": "如何matlab或者python实现多元函数的非线性拟合。\n比如z=f（x，y），给出（x，y，z）的多个数据点，然后怎么拟合出f函数，给出源码就更好了", "Tag": "算法分析"}
{"Answer": "拟合的时候可以加一点惩罚因子，意思就是可以允许有一两个错误点，这样可以避免离群点，这也是正则化的思想，你可以搜搜拉格朗日优化。", "Konwledge_Point": "线性规划和规约", "Question": "线性回归/拟合直线如何去除离群点/噪声？\n对于图1中这种散点，需要拟合出图2中的两条直线，怎么处理噪声点？\n\n\n最小二乘法受离群点的影响较大，请问一下大家这种情况有没有什么好回归方法可以拟合？或者说在回归之前有没有什么方法能去除掉这种离群点？\n\n\n\n", "Tag": "算法分析"}
{"Answer": "function  linprog2_1\r\nf=[1000,1000,1000,1000];\r\nA=[13.9,13.0,13.6,15.7;\r\n    0.17,0.04,0.08,0.11;\r\n    0.41,0.39,0.48,0.92;\r\n    0.13,0.21,0.14,0.24;\r\n    0.15,0.10,0.15,0.18;\r\n    0.3,0.44,0.52,0.58;\r\n    0.49,0.39,0.49,0.39;\r\n    3390,3240,3210,2240;\r\n    -13.9,-13.0,-13.6,-15.7;\r\n    -0.17,-0.04,-0.08,-0.11;\r\n    -0.41,-6.39,-0.48,-0.92;\r\n    -0.13,-0.21,-0.14,-0.24;\r\n    -0.15,-0.10,-0.15,-0.18;\r\n    -0.3,-0.44,-0.52,-0.58;\r\n    -0.49,-0.39,-0.49,-0.39;\r\n    -3390,-3240,-3210,-2240;];%负号指把不等式两边同时乘以-1把大于等于号转化为小于等于号\r\nb=[16,0.9,0.8,100,0.5,1.2,0.6,3310,-14,-0.1,-0.4,0,-0.1,-0.4,-0.32,-3110];\r\nAeq=[1,1,1,1];\r\nbeq=1;%组成之和为1\r\nlb=[0,0,0,0];\r\nub=[];\r\n[x,fval]=linprog(f,A,b,Aeq,beq,lb,ub)\r\n\r\n\r\nend\r\n![图片说明](https://img-ask.csdn.net/upload/201708/15/1502793328_544601.jpg)", "Konwledge_Point": "线性规划和规约", "Question": "Matlab 不等式 线性方程式最优解\n单价都是1000，X1到X4是4中原料占比，总和为100%，求解成本最低的最优解\n\n答案(X1=26.26%，X2=0.00%，X3=58.15%，X4=15.25%)\n\nMin s = 1000 * X1 + 1000 * X2 + 1000 * X3 + 1000 * X4;\n\n\n\n14<= 13.9 * X1 + 13.0 * X2 + 13.6 * X3 + 15.7 * X4 <=16;\n\n0.1<= 0.17 * X1 + 0.04 * X2 + 0.08 * X3 + 0.11 * X4 <= 0.9\n\n0.4<= 0.41 * X1 + 0.39 * X2 + 0.48 * X3 + 0.92 * X4 <=0.8;\n\n0<=0.13 * X1 + 0.21 * X2 + 0.14 * X3 + 0.24 * X4 <= 100;\n\n0.1<=0.15 * X1 + 0.10 * X2 + 0.15 * X3 + 0.18 * X4 <= 0.5;\n\n0.4<=0.3 * X1 + 0.44 * X2 + 0.52 * X3 + 0.58 * X4 <= 1.2;\n\n0.32<=0.49 * X1 + 0.39 * X2 + 0.49 * X3 + 0.39 * X4 <=0.6;\n\n3110<=3390 * X1 + 3240 * X2 + 3210 * X3 + 2240 * X4 =3310;\n\n\n\n帮忙看看，我写的肯定有问题，这个方法（linprog）能这么用吗？还有更好的方法吗？", "Tag": "算法分析"}
{"Answer": "你好，可以这样！令x=[y1,y2,y3,epsilon]现在就是要目标函数是epsilon = 0*x(1)+0*x(2)+0*x(3)+1*x(4)最小不等式约束和等式约束分别为：\n化成代码\nA = [-1,0,0,-1; \n    0,-1,0,-1; \n    0,0,-1,-1; \n    -1,-1,0,-1;\n    -1,0,-1,-1; \n    0,-1,-1,-1];%不等式约束的A\nb = [0; 0; 0; 0.314272; -0.830297; -1.088269];%不等式约束的b【满足A*x≤b】\nAeq = [1,1,1,0];%等式约束的Aeq\nbeq = [3.942592];%等式约束的beq\nf = [0,0,0,1];%目标函数的线性组合，即epsilon = 0*x(1)+0*x(2)+0*x(3)+1*x(4)\nmin_epsilon = linprog(f,A,b,Aeq,beq)%求解\n\n计算结果：\nmin_epsilon =\n\n   1.314197333333333\n   1.314197333333333\n   1.314197333333333\n  -1.314197333333333\n\n", "Konwledge_Point": "线性规划和规约", "Question": "请问如图线性规划问题 如何用matlab求解呀\n\n\n想请问下这个线性规划问题 整么用matlab的linprog()函数求解呀， 着实谢谢", "Tag": "算法分析"}
{"Answer": "望采纳下面是一个示例，用矩阵求逆的方法来求解这个线性方程组：\n4x1 + 2x2 - x3 = 2\n3x1 - x2 + 2x3 = 10\n12x1 + 3x2 = 8\n\n首先，将系数矩阵和常数向量分别存储在 A 和 b 的变量中，如下所示：\nA = [4 2 -1; 3 -1 2; 12 3 0];\nb = [2; 10; 8];\n\n然后，可以通过计算 A 的逆来求解方程组：\nx = inv(A) * b;\n\n这样，就可以得到方程组的解，即 x = [1; 2; -1]。注意：求矩阵逆是一个计算量比较大的操作，在实际应用中应该尽量避免使用。此外，如果方程组不存在解或者有多个解，那么求逆法就不能用了。", "Konwledge_Point": "线性规划和规约", "Question": "用矩阵求逆法求线性方程组的解\n4x1+2x2−x3=2    3x1−x2+2x3=10  12x1+3x2=8", "Tag": "算法分析"}
{"Answer": "convhull是凸包计算函数，k是选择的点和连接顺序，v是面积，也可以自己写源码。有用麻烦采纳一下，谢谢，有问题可以私聊", "Konwledge_Point": "线性规划和规约", "Question": "MATLAB中的convhull函数的使用说明\n\n\nP\n = [\n0\n \n0\n; \n1\n \n1\n; \n1\n.5\n \n0\n.5\n; \n1\n.5\n \n-0.5\n; \n1\n.25\n \n0\n.3\n; \n1\n \n0\n; \n1\n.25\n \n-0.3\n; \n1\n \n-1\n];\n[k,v] = convhull(\nP\n); \nplot(\nP\n(:,\n1\n),\nP\n(:,\n2\n),\n'*'\n) \nhold on\n plot(\nP\n(k,\n1\n),\nP\n(k,\n2\n))\n\n\n\n这里面的k，v，都是分别是什么含义啊，为什么就可以把这外围的一圈点都围起来啊？", "Tag": "算法分析"}
{"Answer": "你好，我是有问必答小助手，非常抱歉，本次您提出的有问必答问题，技术专家团超时未为您做出解答 本次提问扣除的有问必答次数，已经为您补发到账户，我们后续会持续优化，扩大我们的服务范围，为您带来更好地服务。", "Konwledge_Point": "线性规划和规约", "Question": "非线性规划的专业课排课问题研究\n问题如下：\n\n\n\n\n\n\n这是提示：\n\n\n\n\n希望是用python或者matlab求解出来。目前我表达式都写不出来，想了好久没明白，希望得到帮助。\n\n\n我的思考：开始我查资料是希望通过遗传算法来求解的，我看这一篇文章挺像的：\nhttps://blog.csdn.net/weixin_42062229/article/details/94504604\n他的比我这个复杂很多 。但是我还是没看懂 。不知道怎么用遗传算法。\n\n\n于是我就想根据题目提示用非线性规划中的01规划求解，但我表达式一直列不出来，所以不知道代码咋写。\n\n\n以下是我二维转一维的部分\n\n\n\n", "Tag": "算法分析"}
{"Answer": "注意到第六行\nprob.Constraints.cons1 = 280*x(1) + 250*x(2) + 400*x(3) <= 60000;\n\n但对应的是第二个约束，应该改为\nprob.Constraints.cons2 = 280*x(1) + 250*x(2) + 400*x(3) <= 60000;\n\n运行后的结果为[64.5161290322581,167.741935483871,0]与lingo结果差异不大完整代码如下：\nprob = optimproblem('ObjectiveSense','max');\n\nx = optimvar('x',3,'LowerBound',0);\nprob.Objective = 2*x(1) + 3*x(2) + 4*x(3);\n\ncons1 = 1.5*x(1) + 3*x(2) + 5*x(3) <= 600;\ncons2 = 280*x(1) + 250*x(2) + 400*x(3) <= 60000;\nprob.Constraints.cons1 = cons1;\nprob.Constraints.cons2 = cons2;\n\n[sol,fval,flag,out] = solve(prob);\nsol.x\ntx=round(sol.x);\n", "Konwledge_Point": "线性规划和规约", "Question": "看下Matlab怎么求解线性规划方程，为啥跟lingo偏差这么大\n为什么我用matlab 和lingo求一个线性规划问题答案完全不一样，我知道lingo答案应该是对的，Matlab是错在哪里了，我后面加取整也不对，初学Matlab\n\n", "Tag": "算法分析"}
{"Answer": "自己已解决记录一下：\n1.思路如下图\n2.两个二维数组每一行的数据分别做线性回归 的 代码：\nimport numpy as np\nfrom scipy import stats, linalg\n\ng = np.array([[1,6,8],[3,2,1],[2,6,10],[8,9,11]])\nprint(\"g:\", g)\nprint(\"g第一行:\", g[0])\na = g.shape[0]\nprint(\"a(行数):\", a)\nm = np.array([[2,7,9],[6,5,2],[4,8,12],[10,12,15]])\nprint(\"m:\", m)\nprint(\"m(第一行):\", m[0])\nfor i in range(a):\n    res = stats.linregress(g[i], m[i])\n    print(\"res:\", res)\n", "Konwledge_Point": "线性规划和规约", "Question": "对二维数组，逐元素地线性拟合，调用 stats.linregress(x, y)\n问题遇到的现象和发生背景\n\n\n我需要对长时间序列的栅格数据逐象元地做线性拟合。即x轴为第1\nn年第一个传感器的栅格数据，轴为第1\nn年第二个传感器的栅格数据。\n简化下来相当于就是两个二维数组对应元素做线性拟合，但是出现了问题：\nValueError: too many values to unpack (expected 4)\n\n\n于是我尝试例举了二维数组进行线性拟合出现了同样的问题：\n\n\n是stats.linregress(x, y)函数无法实现对二维数组的线性拟合吗？有没有能直接对二维数组直接线性拟合的办法？\n转换成一维的话又怎么回到二维的状态呢？该如何解决呢？\n\n\n问题相关代码\n\n\nimport numpy as np\nfrom scipy import stats, linalg\n\ndef f(a):\n     b = np.array(\n[[5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]\n)\n     n = np.array(\n[[9, 10, 11, 12], [13, 14, 15, 16],[17, 18, 19, 20]]\n)\n     y = np.concatenate((b,n), axis=\n0\n)\n     \nprint\n(\n\"y:\"\n, y)\n     res = stats.linregress(a, y)\n     \nreturn\n res\n\nc = np.array(\n[[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n)\nd = np.array(\n[[5,6,7,8],[9,10,11,12],[13,14,15,16]]\n)\nm = np.concatenate((c, d), axis=\n0\n)\n\nprint\n(\n\"m:\"\n, m)\nres = f(m)\n\n\n\n谢谢！", "Tag": "算法分析"}
{"Answer": "看来很少有人做这个，自己给自己顶一下", "Konwledge_Point": "线性规划和规约", "Question": "有关非线性最优化手眼标定的求助帖\n最近在做标定手眼关系（eye in hand ）中用到非线性最优化来求解方程AX=XB，\n\n但对于非线性最优化了解不多，理解困难。\n\n参考文中中定义函数f，对函数f进行非线性最优化\n\n函数f定义可见附图\n\n始终q为四元数（用来表示旋转矩阵），t表示平移向量，R表示旋转矩阵\n\n要优化的元素为q，t（即旋转矩阵和平移向量）\n\n这里如何求解真是不懂，请各位赐教   help", "Tag": "算法分析"}
{"Answer": "设置一个 relative布局，然后在把所有的linear布局的代码添加在relative layout里。再添加textview，并且标明textview在top位置，同时给出外边距。\r\n \r\n\r\n    \r\n         <TextView android:layout_alignParentTop=\"true\"\r\n          android:layout_margin=\"20dip/>\r\n         \r\n                    // here is your linear layout\r\n         \n", "Konwledge_Point": "线性规划和规约", "Question": "在Android中为线性布局添加标题\n我创建了如下的GUI，使用了线性布局，并且给这个布局设置了边框。我想在这个边框上插入标题。如何实现啊？", "Tag": "算法分析"}
{"Answer": "fmincon默认是求最小值，你需要求解的是最大值，所以目标函数f中应该取个负号。", "Konwledge_Point": "线性规划和规约", "Question": "请问如图非线性规划问题 如何用matlab求解呀\n\n\n我原本想用fmincon函数求解，先建立目标函数：\n\n\n\n\n然后由于约束条件都是线性的，没有非线性条件，所以就直接将线性约束加进去求解\n\n\n\n\n但最终得到的结果不对，请问是哪里错了", "Tag": "算法分析"}
{"Answer": "用RecyclerView啊，然后加载两种子布局就OK了", "Konwledge_Point": "线性规划和规约", "Question": "安卓相对布局和线性布局规划问题\n\n\n如图所示布局该如何规划？是全部采用相对布局还是全部采用线性布局比较好？刚接触XML不久", "Tag": "算法分析"}
{"Answer": "参考一下：\n\n#include \"stdio.h\"\n\n#define N 2\nstruct student{\n    int id;\n    char name[20];\n    int kaoqun;\n    int biaoxian;\n    int zuoye;\n    int biji;\n    int sum;\n}stud[N],t;\n\nint main()\n{\n    int i,j;\n    for(i=0;i<N;i++){\n        printf(\"请输入第%d个学生信息\\n\",i+1);\n        scanf(\"%d %s\",&stud[i].id,&stud[i].name);\n        fflush(stdin);\n        scanf(\"%d %d %d %d\",&stud[i].kaoqun,&stud[i].biaoxian,&stud[i].zuoye,&stud[i].biji);\n        stud[i].sum = stud[i].kaoqun*0.3+stud[i].biaoxian*0.3+stud[i].zuoye*0.3+stud[i].biji*0.1;\n    }\n    \n    //排序\n    \n    for (i = 0; i < N - 1; i++){\n        for (j = 0; j < N - 1 - i; j++){ //按成绩对学生信息进行排序\n            if (stud[j].sum > stud[j + 1].sum){ //整型数字的比较\n                t = stud[j];\n                stud[j] = stud[j + 1];\n                stud[j + 1] = t;\n            }\n        }\n    }\n    //打印\n    printf(\"学号\\t姓名\\t考勤\\t表现\\t作业\\t笔记\\t总分\\t\\n\");\n    for (i = 0; i < N; i++){\n        printf(\"%d\\t\", stud[i].id);\n        printf(\"%s\\t\", stud[i].name);\n        printf(\"%d\\t\", stud[i].kaoqun);\n        printf(\"%d\\t\", stud[i].biaoxian);\n        printf(\"%d\\t\", stud[i].zuoye);\n        printf(\"%d\\t\", stud[i].biji);\n        printf(\"%d \\n\", stud[i].sum);\n    }\n    \n    return 1;\n}\n", "Konwledge_Point": "线性规划和规约", "Question": "文件操作＋线性链表＋直接插入排序\n1）文件操作+线性链表+直接插入排序操作实验室。\n现有结构体定义如下：\nstruct stuInfo\n{\n    char id[12];            //数据成员\n    char name[15];\n    float score;\n\n\nstruct stuInfo *\nnext\n;   \n//\n指针成员\n\n\n\n};\n任务及要求：\n（1）首先完成线性链表的定义和创建，确保链表的第一个节点为哨兵节点，不存放有效的数据；\n（2）利用文件的相关操作，动态开辟节点存储空间，将存放在磁盘某个路径中的文件“stuinfo.txt”信息逐条读入，并依次存入到线性链表的每个节点中，信息如下；\n00001 张三 100\n00002 李四 99\n00003 王五 100\n00004 王六 89\n00005 江涛 98\n00006 陈琪 88\n00007 祁廷 91\n（3）接下来，利用键盘输入，动态开辟节点存储空间，将00008 赵四 88信息存在一个节点中，并插入到学号是‘00005’和‘00006’之间；\n（4）再接下来，利用直接插入排序，对链表继续升序排序；\n（5）将完整的线性链表信息从头到尾依", "Tag": "算法分析"}
{"Answer": "该回答引用GPTᴼᴾᴱᴺᴬᴵ针对多目标非线性整数规划问题，目前常用的算法包括遗传算法、粒子群算法、差分进化算法等。另外，也可以尝试使用混合整数线性规划和近似多目标优化方法等。\n对于具体应用的选择，需要考虑问题的特点和实际情况。不同算法的适用范围和优缺点也不同，因此需要综合考虑选择合适的算法。\n关于学习方法，可以通过阅读相关论文、专业书籍、参加相关学术会议等方式学习。以下是一些相关学习资源的推荐：\n《多目标优化理论与方法》一书，作者为陈志华等。\n学术期刊，例如IEEE Transactions on Evolutionary Computation、European Journal of Operational Research等。\n相关学术会议，例如International Conference on Evolutionary Multi-Criterion Optimization、International Symposium on Combinatorial Optimization等。\nMATLAB官方文档提供了各种优化算法的实现和示例，可以在MATLAB官网进行查找和学习。\n开源优化软件，例如Gurobi、CPLEX等，可以通过学习其官方文档和实例来了解相关算法。\n", "Konwledge_Point": "线性规划和规约", "Question": "多目标非线性整数规划\n请问，针对（多目标非线性整数规划）问题，用什么算法比较好？哪里可以借鉴学习", "Tag": "算法分析"}
{"Answer": "字段计算器中可以算出所有点的坐标值，然后导出到Excel中。距离计算和线性回归都可以用Excel的公式计算。", "Konwledge_Point": "线性规划和规约", "Question": "arcgis计算距离，线性回归分析的问题\n想问下已经在ARCGIS上标注了点并连成线，想知道怎么计算每个点到起始点的距离，并能把距离、时间放在坐标里，进行线性回归分析", "Tag": "算法分析"}
{"Answer": "能不能请把代码附上，不要截图，这样真的看不出来呀", "Konwledge_Point": "线性规划和规约", "Question": "matlab的fmincon函数求解非线性规划问题，我实在搞不懂呀(哭)\n以下有问题的方法都是我自己琢磨的(菜)\n想写一个非线性规划的求解代码，但是那个非线性规划问题的目标函数比较复杂，带积分长这样\n\n\n\n\n然后我就把这个积分先一个个算出来再加上(不知道这样对不对），\n得到目标函数z = 79\nq(1) + (398\nq(2))/5 + (398\nq(3))/5 + (801\nq(4))/10 + (11\nq(0)^2)/20 + (13\nq(1)^(7/5))/28 + (13\nq(2)^(7/5))/28 + (13\nq(3)^(7/5))/28 + (13*q(4)^(7/5))/28\n\n\n后面我就建了fun1(当然是看的网上的一步步来的)\n\n\nfun2\n\n\n\n\n然后写了主代码(我不知道这么写对不对，但是我写出来报好多错，该怎么写呀，这个代码是我找的，我不会写)\n\n\n\n\n后面我又换了一个主代码\n\n\n\n\n当然又是一堆错\n我不理解，这个错误fmincon\n\n\n第一次提问，求指点，小的这厢谢过了！(非编程专业的很多都不懂望理解！)", "Tag": "算法分析"}
{"Answer": "这篇文章：MATLAB遗传算法工具箱的使用及实例(线性规划) 也许能够解决你的问题，你可以看下", "Konwledge_Point": "线性规划和规约", "Question": "matlab做线性规划中一个报错无法解决望各位解惑！\n用matlab做一个关于线性规划的问题，但是出现以下形况望各位解惑！\nmatlab版本为2022a\n代码：\nclc,clear\nx = optimvar('x',4,3,'LowerBound',0);\nwh = [18,15,23,12];\nwj = [10,16,8];\nvj = [6800,8700,5300];\nrou = [18/480,15/650,23/580,12/390];\nlirun = [3100,3800,3500,2850];\na = sum(x,2);\nb = sum(x);\nz = lirun*a;\nprob = optimproblem('Objective',z,'ObjectiveSense','max');\nprob.Constraints.c1 = a <= wh';\nprob.Constraints.c2 = b' <= wj';\nprob.Constraints.c3 = sum(x(1:4,1)./rou') <= 6800;\nprob.Constraints.c4 = sum(x(1:4,2)./rou') <= 8700;\nprob.Constraints.c5 = sum(x(1:4,3)./rou') <= 5300;\nprob.Constraints.c6 = vj(1)/b(1) == vj(2)/b(2);\nprob.Constraints.c7 = vj(1)/b(1) == vj(3)/b(3);\n[sol,fval] = solve(prob);\nsol.x\nfval\n报错：\n错误使用 optim.problemdef.OptimizationProblem/solve\nSOLVE requires a non-empty initial point structure to solve a nonlinear problem.", "Tag": "算法分析"}
{"Answer": "http://datakung.com/?p=50&replytocom=5", "Konwledge_Point": "线性规划和规约", "Question": "怎么判定线性回归的好坏\n分类器的好坏在于准确率。\n\n那线性回归呢？\n\n我现在有10个特征和1个回归值，我想比较一下，用前5个特征做回归好，还是用后5个特征做回归好，该比较什么值呢？", "Tag": "算法分析"}
{"Answer": "现在的处理器支持SMT（intel商标化的名称叫“超线程”），也就是说你看到的计算机上的逻辑处理器核心的数量比物理的要多（一般是2倍，在一些处理器上是4倍或者更多）\r\n但是逻辑处理器因为共享计算核心，所以并不能成倍提高性能。比如一个8逻辑处理器的计算机，实际上只有4个内核，那么它充其量只能比单个处理器内核提高大约5倍的性能。\r\n\r\n另一个问题是，虽然你的处理器可以并行，但是磁盘还是只有一个，如果两个进程需要同时访问磁盘完成查询，那么显然只能轮流访问而不是同时访问，这部分无法并行。别的资源也类似。\r\n因此，一个程序能加速到什么程度，取决于可以并行的代码的比例。\r\n假设一个程序中有50%的操作不能并行，那么即便你有无穷多个处理器，并发无穷多个进程，那么你的程序的运行速度相比较单进程也最多提高2倍。\r\n（50%无法并行的部分所用的时间假设是t/2，50%可以并行的操作用时是t/2，总时间是t/2+t/2=t，假设你有无穷多个进程，那么总时间就是t/2+0=t/2）", "Konwledge_Point": "线性规划和规约", "Question": "Node使用了多进程，但QPS（每秒查询率）没有线性增长\n阅读《深入浅出Node.js》10.2.3小节，里面测试了单进程和多进程下QPS的对比，性能确实提高了，但是却没有解释为什么性能并没有与CPU的数量成线性增长。\n\n我自己也试了，确实如此。", "Tag": "算法分析"}
{"Answer": "你看2787行的三个条件，一个一个在代码中测试，找到那个是假，然后去搜一下我这里没有opencv的包，所以没法试", "Konwledge_Point": "线性规划和规约", "Question": "Python在线性规划的问题\n\n\n想问一下为什么一些数后面加上点之后就能运行了呢？是因为最后的答案是浮点数吗？感谢大家的解答！", "Tag": "算法分析"}
{"Answer": "http://ask.csdn.net/questions/270851", "Konwledge_Point": "线性规划和规约", "Question": "合并两个单链表的算法\n设带头结点的线性单链表A＝（a1,a2,⋯⋯am）,B＝(b1,b2⋯⋯bm),试编写一个按下列规则合并A,B为线性单链表C的算法，使得C＝(a1,b1,⋯⋯,bm,bm+1,⋯⋯,bn),m小于等于或者C＝(b1,a1,⋯⋯bn,an,an+1,…,am),m大于n", "Tag": "算法分析"}
{"Answer": "\nyour code is doing a linear search , a binary search require that the data is sorted , in your case its a regular file , plus in a binary search you start the search from the middle and compare the value your searching with the value in the middle and decide whether to go left or right depending on how your data is sorted .\ni hope it helped a little.\n", "Konwledge_Point": "线性规划和规约", "Question": "线性或二进制搜索??  -PHP\n\n\n\nI have some code that I wrote and it works really well. Except I am not sure whether what i have written is linear or bineary searching?! I get really confused about the differences. Could someone please clarify the differences and what my code is so I can explain it to someone?\n\n\n\n-The code below searches a value inputted by the user. And goes through a csv file of data. I then saves all values into a new array which has the results. Hopefully that makes sense.\n\n\n\nI just want to know whether my code is linear or binary? I get so confused about them *\n\n\n\n$SearchThis = isset($_POST['Search']) ? $_POST['Search'] : '';\n//empty()\n$SearchThis = !empty($_POST['Search']) ? $_POST['Search'] : '';\n\n\n\n// Grabs the csv file (and its existing data)  and makes it into an array\n$csv = array();\n$lines = file('data/StaffData.csv', FILE_IGNORE_NEW_LINES);\nforeach ($lines as $key => $value)\n{\n    $csv[$key] = str_getcsv($value);\n}\n\n\n\n//A new array which will display the search results\n$new_csv = array(); \n\n//This displays which rows have matched the search (it is put in an array)\n\n//Looks through full names\n$keys = array_keys(array_column($csv, 0), $SearchThis);  //  original code\nforeach($keys as $index) {                               // Iterate over the keys\n    $new_csv[] = $csv[$index];                           // Copy the matching rows to our new array\n}\n//Looks through phone numbers\n$keys = array_keys(array_column($csv, 1), $SearchThis);  // original code\nforeach($keys as $index) {                               // Iterate over the keys\n    $new_csv[] = $csv[$index];                           // Copy the matching rows to our new array\n}\n//Looks through gender\n$keys = array_keys(array_column($csv, 2), $SearchThis);  // original code\nforeach($keys as $index) {                               // Iterate over the keys\n    $new_csv[] = $csv[$index];                           // Copy the matching rows to our new array\n}\n//Looks through Birthday\n$keys = array_keys(array_column($csv, 3), $SearchThis);  // original code\nforeach($keys as $index) {                               // Iterate over the keys\n    $new_csv[] = $csv[$index];                           // Copy the matching rows to our new array\n}\n\n//Looks through Type of work\n$keys = array_keys(array_column($csv, 4), $SearchThis);  // original code\nforeach($keys as $index) {                               // Iterate over the keys\n    $new_csv[] = $csv[$index];                           // Copy the matching rows to our new array\n}\n\n\n    ", "Tag": "算法分析"}
{"Answer": "肯定会变化，这是正常现象，是因为你没有指定随机种子，所以每次训练的参数初始化是不同的。导致分数不同", "Konwledge_Point": "线性规划和规约", "Question": "请问python建模-线性回归，每运行一次，r2值会变化吗\n请问python建模-线性回归，每运行一次，r2值会变化，是正常的吗？\n\n\nimport pandas as pd\nimport xlrd\n\nsurvey\n=pd.read_excel(\"D:\\data\\第26节数据源-survey.xlsx\")\nsurvey.head()\n\n\nsurvey_suv\n=survey[survey[\n'category'\n]==\n'SUV'\n]\nsurvey_suv\n\nsurvey_suv.corr()\n\nimport seaborn as sns\nsns.heatmap(\ndata\n=survey_suv.corr())\n\nsns.scatterplot(\ndata\n=survey_suv,x='price_ratio',y='price')\n\n\n#创建自变量和因变量\n\n\nx\n=survey_suv[\n'price_ratio'\n]\n\ny\n=survey_suv[\n'price'\n]\n\n\n#导入机器学习交叉验证包的分割模块\n\n\nfrom\n sklearn.model_selection import train_test_split\n\n\n#二八分，拆分过程\n\nx_train,x_test,y_train,\ny_test\n=train_test_split(x,y,train_size=0.8,test_size=0.2)\n\n\n#检查拆分结果\n\n\nprint\n(\n'原始数据集大小：'\n,x.shape,\n'训练数据集大小:'\n,x_train.shape,\n'测试训练集大小:'\n,x_test.shape)\n\n\n#导入线性模型包\n\n\nfrom\n sklearn.linear_model import LinearRegression\n\n\n#创建模型\n\n\nmodel\n=LinearRegression()\n\n\n#训练模型\n\nmodel.fit(x_train,y_train)\n\nx_train\n\n\nx_train\n=x_train.values.reshape(-1,1)\n\nx_test\n=x_test.values.reshape(-1,1)\nx_train\n\nmodel.fit(x_train,y_train)\n\n\na\n=model.intercept_\n\nb\n=model.coef_\n\na\n=round(float(a),2)\n\nb\n=round(float(b),2)\n\n#print('一元一次方程为：y={}{}x'.format(a,b))\n\n\n\nr2\n=model.score(x_test,y_test)\nr2\n\n", "Tag": "算法分析"}
{"Answer": "线性系统有两个属性：齐次性和叠加性，若系统为y（n）=T[f(n)]，齐次：T[af(n)]=aT[f(n)],叠加：T[f1(n)+f2(n)]=T[f1(n)]+T[f2(n)]，所以既齐次又叠加的系统为线性系统，亦可用此判断。  【望采纳】", "Konwledge_Point": "线性规划和规约", "Question": "如何判断是否为线性系统\n零状态线性如何判断，导数和积分部分应该怎么计算，是求导和求积分一定是零吗，是需要带公式吗\n![img](\nhttps://img-mid.csdnimg.c\n\n\nn/release/static/image/mid/ask/162075222366153.jpg \"#left\")", "Tag": "算法分析"}
{"Answer": "clc,clear,close all;\n%hamming窗\nM=23;alpha=(M-1)/2;n=0:M-1;\nhd=(cos(pi*(n-alpha)))./(n-alpha);hd(alpha+1)=0;\nw_ham=(hamming(M))'; h=hd.*w_ham; [Hr,w,P,L]=Hr_Type3(h);\n%plots\nsubplot(221);stem(n,hd);\ntitle('Ideal Impulse Response') \naxis([-1 M -1.2 1.2]);\nxlabel('n');ylabel('hd(n)') \nsubplot(222);stem(n,w_ham);\ntitle('Hamming Window') \naxis([-1 M 0 1.2]);xlabel('n');ylabel('w(n)') \nsubplot(223);stem(n,h);\ntitle('Actual Impulse Response') \naxis([-1 M -1.2 1.2]);xlabel('n');ylabel('h(n)')\nsubplot(224);plot(w/pi,Hr/pi);\ntitle('Amplitude Response');grid;\naxis([0 1 0 1]);xlabel('frenquency in pi units');ylabel('slope in pi units');\n\n\n%子函数：\nfunction [Hr,w,c,L] = Hr_Type3(h);\n% Computes Amplitude response of Type-3 LP FIR filter\n% -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  ---\n% [Hr,w,c,L] = Hr_Type3(h)\n\n% Hr = Amplitude Response\n%  w = frequencies between [0 pi] over which Hr is computed\n%  c = Type-3 LP filter coefficients\n%  L = Order of Hr\n%  h = Type-3 LP impulse response\n%\nM = length(h);\nL = (M-1)/2;\nc = [2*h(L+1:-1:1)];\nn=[0:1:L];\nw = [0:1:500]'*pi/500;\nHr = sin(w*n)*c';\nend\n\n", "Konwledge_Point": "线性规划和规约", "Question": "如何利用海明窗设计N=24（23阶）的FIR线性相位数字微分器（用matlab），并求出h（n）（传递函数），并求出h（n）（传递函数），并画出幅频特性和相频特性\n这个FIR线性相位数字微分器怎么用matlab设计？\n\n\n如何利用海明窗设计N=24（23阶）的FIR线性相位数字微分器（用matlab实现），并求出h（n）（传递函数），并画出幅频特性和相频特性。\n\n\n好难啊，怎么做教一下，请给出matlab代码和图，谢谢啦", "Tag": "算法分析"}
{"Answer": "是可以的，我发现我一直显示不出来是因为我没有给标题设置宽度比和高度比，所以显示不出来，因为不知道layout__below怎么引用布局就重新倒着重写了一遍布局\r\n```\n\n\n\n\n\n\n\n\n\n\r\n\r\n```\r\n最后得图![图片说明](https://img-ask.csdn.net/upload/201905/30/1559211604_22833.png)", "Konwledge_Point": "线性规划和规约", "Question": "请问百分比布局可以引用线性布局的标题栏吗？求大神解答！！！\n想在百分比布局里尝试引用线性布局的标题栏，怎么也不成功，我是按照第一行代码那本书的引用布局部分做的，怎么也弄不出来，好懵\n\n\n", "Tag": "算法分析"}
{"Answer": "你好，(1)这是非线性函数求最小值\nformat long%设置显示的小数位长一点\nf = @(x) (x^3+cos(x)+x*log10(x))/exp(x);\nx = fminsearch(f, 0.5)%初值给0.5\n\n结果：\nx =\n\n   0.663769531250000\n\n(2)因为目标函数不是未知数的线性组合，所以需要用到fmincon函数求解代码供参考，注释的都注释了\nfunction main()\nfunc = @(x) x(1)^2 + x(2)^2 - x(1)*x(2) -2*x(1)-5*x(2);%目标函数\nx0 = rand(2,1);%给初始值\nA=[-2, 3]; b = -6;%线性约束A和b\nx = fmincon(func, x0,A,b,[],[],[],[],@nonlinfun)\nend\nfunction [c, ceq] = nonlinfun(x) %定义非线性约束函数\nc = (x(1)-1)^2-x(2);%非线性约束条件\nceq = [];\nend\n\n\n结果是\nx =\n\n   1.333333116738571\n  -0.988889101134474\n\n\n即x1 =  1.333333116738571； x2= -0.988889101134474\n有帮助望题主给个采纳，先行谢谢啦", "Konwledge_Point": "线性规划和规约", "Question": "如何在matlab上实现线性规划问题\n无约束\n（1）min f(x)＝(x³＋cos x＋x lgx)/e× (0<x<1)\n（2）min x(1)²＋x(2)²－x(1) x(2)－2 x(1)－5(2)\n        { －(x（1）－1)²＋x(2)≥0\n           2 x(1)－3 x(2)＋6≥0\n如何在matlab中输入，求步骤。谢谢！", "Tag": "算法分析"}
{"Answer": "仿佛看到会计学", "Konwledge_Point": "线性规划和规约", "Question": "Excle 运筹学 线性规划 正常步骤。\n\n\t\n\n\t\n\n\n\n2、\n\n\n\n\n\n\n某企业生产甲、乙、丙三种产品，其每单位所消耗工时分别为1.6、 2.0、 2.5小时，每单位所需原料A分别为24、20、 12 kg,所需原料B分别为14、10、18kg。生产线每月正常工作时间为240小时，原料A、B的总供应量限制为2400kg 和1500kg。生产一个甲、乙、丙产品各可获利润525、678、 812元。\n\n\n\n已知因为每单位丙产品不完全反应会产生5kg副产品丁，每kg需要排污费200元。\n\n副产品丁的需求量为每月不超过150kg。应如何确定生产计划，可使总利润最大", "Tag": "算法分析"}
{"Answer": "一看就是正在学数据结构的同学，现在没有电脑得空给你敲敲", "Konwledge_Point": "线性规划和规约", "Question": "线性表链式存储结构。。\n要求：\n\n\n1\n.写出线性表链式存储结构；\n\n\n2\n.写出链式存储的常用操作（函数）；\n\n\n3\n.编写实现集合逆置函数；\n\n\n4\n.编写测试函数；\n\n\n5\n.编写\nmain\n函数运行程序。\n", "Tag": "算法分析"}
{"Answer": "选特征，打标签，调sklearn 包训练，预测，结束", "Konwledge_Point": "线性规划和规约", "Question": "机器学习如何利用线性回归预测鲍鱼数据的年龄和利用贝叶斯预测鲍鱼的性别啊\n数据描述性统计（包括数据来源，数据计量方法，每个变量的最大最小值、均值、方差、标准差等）、定量分析（包括所用方法的特点、选用标准或依据、模型计算步骤、代码展示、结果）、结论。", "Tag": "算法分析"}
{"Answer": "代码没什么大问题，改动处见注释，完善如下，供参考：\n#define _CRT_SECURE_NO_WARNINGS 1\n#include<stdio.h>\n#include<stdlib.h>\n#include<assert.h>\ntypedef int datatype;\ntypedef struct node {\n    datatype data;\n    struct node* link;\n}node;\n\nnode* BuySLTNode(datatype x)\n{\n    node* newnode = (node*)malloc(sizeof(node));\n    if (newnode == NULL)\n    {\n        perror(\"malloc fail\");\n        exit(-1);\n    }\n    newnode->data = x;\n    newnode->link = NULL;\n    return newnode;\n}\n\nnode* CreateSList()\n{\n    datatype data;\n    node* phead = NULL, * ptail = NULL;\n    while (1)\n    {\n        scanf(\"%d\", &data); //修改  \n        node* newnode = BuySLTNode(data);\n        if (phead == NULL)\n            phead = newnode;//修改 \n        else\n            ptail->link = newnode;\n        ptail = newnode;   //修改 \n        if ((getchar()) == '\\n')  break; //修改\n    } \n    return phead;\n}\n\nnode* Find_max(node* phead)   \n{\n    node* cur = phead;\n    node* Max = phead;\n    datatype max = cur->data;\n    while (cur)\n    {\n        if (cur->data > max)\n        {\n            max = cur->data;\n            Max = cur;\n        }\n        cur = cur->link;\n    }\n    return Max;\n}\n\nvoid SListErase(node** pphead, node* pos) \n{\n    assert(pos);\n    assert(*pphead);\n    if (pos == *pphead)\n    {\n        node* next = (*pphead)->link;\n        free(*pphead);\n        *pphead = next;\n    }\n    else\n    {\n        node* prev = *pphead;\n        while (prev->link != pos)\n        {\n            prev = prev->link;\n        }\n        prev->link = pos->link;\n        free(pos);\n    }\n}\nvoid SLTPushBack(node** pphead, datatype x) \n{\n    node* newnode = BuySLTNode(x);\n    if (*pphead == NULL)\n    {\n        *pphead = newnode;\n    }\n    else\n    {\n        node* tail = *pphead;\n        //找尾\n        while (tail->link)\n        {\n            tail = tail->link;\n        }\n        tail->link = newnode;\n    }\n}\n\nvoid SLTPrint(node* phead)\n{\n    node* cur = phead;\n    while (cur)\n    {\n        printf(\"%d \", cur->data); //修改\n        cur = cur->link;\n    }\n}\n\nint main()\n{\n    node* plist = NULL;   //(node*)malloc(sizeof(node)); 修改\n    plist = CreateSList();\n    node* max = Find_max(plist);   \n    SLTPushBack(&plist, max->data); //修改 SLTPushBack(plist, max->data);\n    SListErase(&plist, max);        //修改 SListErase(plist, max);\n    SLTPrint(plist);\n    return 0;\n}\n\n", "Konwledge_Point": "线性规划和规约", "Question": "C语言线性链表的结点移动\n【问题描述】\n已知非空线性链表第1个链结点指针为list，链结点构造为\n\n\nstruct \nnode\n{\n    datatype\n data;\n    \nnode\n \n*link\n;\n};\n\n\n\n\n请写一算法，将该链表中数据域值最大的那个点移到链表的最后面。（假设链表中数据域值最大的链结点惟一）（注意：要求先写出算法的解题思路，然后再写出算法）\n【输入形式】\n输入为一个整数序列，整数之间以空格隔开，序列以回车结尾。\n【输出形式】\n输出为移动后的整数序列，整数之间以空格隔开，序列以回车结尾。\n【样例输入】\n3 12 4 9 5 1\n【样例输出】\n3 4 9 5 1 12\n【样例说明】\n将序列中最大的数字12移动到序列最后。\n\n\n我的思路：\n1.先遍历链表找出那个最大值\n2.尾插最大值\n3.删最大值对应结点\n代码如下：\n\n\n#define _CRT_SECURE_NO_WARNINGS 1\n\n\n#include\n\n\n#include\n\n\n#include\n\ntypedef int datatype;\ntypedef struct \nnode\n \n{\n    datatype\n data;\n    struct \nnode\n* link\n;\n}\nnode\n;\n\nnode\n* BuySLTNode(datatype x)\n{\n    \nnode\n* newnode\n = (\nnode\n*)malloc\n(sizeof(\nnode\n));\n    if\n (newnode == NULL)\n    {\n        perror(\n\"malloc fail\"\n);\n        exit(-\n1\n);\n    }\n    newnode->data = x;\n    newnode->link = NULL;\n    return newnode;\n}\n\n\nnode\n* CreateSList\n()\n{\n    datatype data;\n    \nnode\n* phead\n = NULL, *ptail = NULL;\n    while(\n1\n)\n    {\n        scanf(\n\"%d\"\n, &data);\n        if (getchar() == '\\n')\n        {\n            break;\n        }\n        \nnode\n* newnode\n = BuySLTNode(data);\n        if (phead == NULL)\n        {\n            ptail = phead = newnode;\n        }\n        else\n        {\n            ptail->link = newnode;\n            ptail = newnode;\n        }\n    }\n\n    return phead;\n}\n\n\nnode\n* Find_max\n(\nnode\n* phead\n)\n{\n    \nnode\n* cur\n = phead;\n    \nnode\n* Max\n = phead;\n    datatype max = cur->data;\n    while (cur)\n    {\n        if (cur->data > max)\n        {\n            max = cur->data;\n            Max = cur;\n        }\n        cur = cur->link;\n    }\n    return Max;\n}\n\nvoid SListErase(\nnode\n** pphead\n, \nnode\n* pos\n)\n{\n    assert(pos);\n    assert(*pphead);\n    if (pos == *pphead)\n    {\n        \nnode\n* next\n = (*pphead)->link;\n        free(*pphead);\n        *pphead = next;\n    }\n    else\n    {\n        \nnode\n* prev\n = *pphead;\n        while (prev->link != pos)\n        {\n            prev = prev->link;\n        }\n        prev->link = pos->link;\n        free(pos);\n    }\n}\nvoid SLTPushBack(\nnode\n** pphead\n, datatype x)\n{\n    \nnode\n* newnode\n = BuySLTNode(x);\n    if (*pphead == NULL)\n    {\n        *pphead = newnode;\n    }\n    else\n    {\n        \nnode\n* tail\n = *pphead;\n        //找尾\n        while (tail->link)\n        {\n            tail = tail->link;\n        }\n        tail->link = newnode;\n    }\n}\n\nvoid SLTPrint(\nnode\n* phead\n)\n{\n    \nnode\n* cur\n = phead;\n    while (cur)\n    {\n        printf(\n\"%d\"\n, cur->data);\n        cur = cur->link;\n    }\n}\n\n\nint main()\n{\n    \nnode\n* plist\n = (\nnode\n*)malloc\n(sizeof(\nnode\n));\n    plist\n = CreateSList();\n    \nnode\n* max\n = Find_max(plist);\n    SLTPushBack(plist, max->data);\n    SListErase(plist, max);\n    SLTPrint(plist);\n    return \n0\n;\n}\n\n\n\n\n但是打印结果如下：\n\n\n试图调试的时候发现：\n\n\n\n\n不知道是哪里出错了 希望得到帮助 非常感谢", "Tag": "算法分析"}
{"Answer": "malloc需要头文件stdlib.hGenerateRandomMatrix 函数名少了个m。GenerateRandomMatrix 中 随机数初始化函数名写错了，这个初始化提出来，放到main中。srand(time(NULL));//strabd(time(NULL));", "Konwledge_Point": "线性规划和规约", "Question": "C语言编写矩阵运算函数\n问题遇到的现象和发生背景\n\n\n矩阵运算：线性代数中的矩阵可以用C语言中的二维数组来表示，编写下列函数实现5*5矩阵的运算。（提示：为了简化编程，不用考虑动态创建二维数组，以指针形式传入即可）。\n（1）函数MatrixGenerate（利用srand函数和Rand函数生成一个随机矩阵）；\n（2）MatrixShow（以二维数组的形式显示矩阵）；\n（3）MatrixAdd（矩阵的加法）；\n（4）MatrixSub（矩阵的减法）；\n（5）MatrixMultiple（矩阵的乘法）；\n（6）MatrixTran（矩阵的转置）；\n（7）MatrixMultiple2（矩阵的数乘）；\n\n\n编制生成随机矩阵及矩阵相加的函数，但是运行不出来，一直报错，检查后又没发现什么错误\n\n\n问题相关代码，请勿粘贴截图\n\n\n#include\n#include\n#define max 5\nint ShowMatrixEx(int ** a,int m,int n)//以二维数组形式显示矩阵 。\n{\n    int i,j;\n    for(i=0;i<m;i++)\n    {\n        for(j=0;j<n;j++)\n        {\n            printf(\"%4d\",a[i][j]);\n        }\n        printf(\"\\n\");\n    }\n }\n int ** GenerateRandoMatrix(int m,int n)//生成随机矩阵 。\n {\n     int ** result=(int**)malloc(m\nsizeof(int\n));\n     int i;\n     for(i=0;i<m;i++)\n     {\n         result[i]=(int*)malloc(sizeof(int)*n);\n    }\n    int j=0;\n    strabd(time(NULL));\n    for(i=0;i<m;i++)\n    {\n\n\n     for(j\n=\n0\n;j<n;j++)\n\n     {\n         result[i][j]\n=\nrand()%\n10\n;\n\n     }\n}\n return result\n;\n\n\n\n\n}\nint ** MatrixAdd(int ** a,int ** b,int m,int n)//矩阵相加\n{\n    int ** result=(int **)malloc(m*sizeof(int \n));\n    int i,j;\n    for(i=0;i<m;i++)\n    {\n        result[i]=(int\n)malloc(sizeof(int)*n);\n    }\n    for(i=0;i<m;i++)\n    {\n        for(j=0;j<n;j++)\n        {\n            result[i][j]=a[i][j]+b[i][j];\n        }\n    }\n    return result;\n}\nint main()\n{\n    int **a=GenerateRandomMatrix(max,max);\n    int **b=GenerateRandomMatrix(max,max);\n    ShowMatrixEx(a,max,max);\n    ShowMatrixEx(b,max,max);\n    int i,result;\n    for(i=0;i<max;i++)\n    {\n        free(a[i]);\n        free(b[i]);\n        free(result[i]);\n    }\n    free(a);\n    free(b);\n    free(result);\n    return 0;\n}\n\n\n运行结果及报错内容\n\n\n18    24    D:\\C语言实践\\矩阵运算.c    [Warning] incompatible implicit declaration of built-in function 'malloc' [enabled by default]\n38    24    D:\\C语言实践\\矩阵运算.c    [Warning] incompatible implicit declaration of built-in function 'malloc' [enabled by default]\n55    10    D:\\C语言实践\\矩阵运算.c    [Warning] initialization makes pointer from integer without a cast [enabled by default]\n56    10    D:\\C语言实践\\矩阵运算.c    [Warning] initialization makes pointer from integer without a cast [enabled by default]\n62    3    D:\\C语言实践\\矩阵运算.c    [Warning] incompatible implicit declaration of built-in function 'free' [enabled by default]\n66    2    D:\\C语言实践\\矩阵运算.c    [Warning] incompatible implicit declaration of built-in function 'free' [enabled by default]\n68    2    D:\\C语言实践\\矩阵运算.c    [Warning] passing argument 1 of 'free' makes pointer from integer without a cast [enabled by default]\n64    14    D:\\C语言实践\\矩阵运算.c    [Error] subscripted value is neither array nor pointer nor vector\n68    2    D:\\C语言实践\\矩阵运算.c    [Warning] passing argument 1 of 'free' makes pointer from integer without a cast [enabled by default]\n\n\n我的解答思路和尝试过的方法\n\n\n尝试过确定result数组的变量值\n\n\n我想要达到的结果\n\n\n函数成功编制可以运行。\n可以实现生成随机数组并实现矩阵相加。", "Tag": "算法分析"}
{"Answer": "就是四个不等约束加一个目标函数\nc=[10000;9000];\na=[6,5;10,20;1,0; 0, -1];\nb=[60;150;8;0];\n[x,fval]=linprog(-c,a,b);% 由于要获得最大值，所以c取负号\nx\nfval = -fval % 最大值\n\n\n\n结果\nOptimal solution found.\n\n\nx =\n\n   6.428571428571425\n   4.285714285714288\n\n\nfval =\n\n     1.028571428571428e+05\n\n", "Konwledge_Point": "线性规划和规约", "Question": "线性规划问题是这样解吗？总感觉方向不对\nclear\n\n\n\n\n\n\nc=[10000;9000];a=[6,5;10,20];b=[60;150];\nAeq=[6 5];beq=60;\n[x,fval]=linprog(c,a,b,Aeq,beq,zeros(2,1))\n\n\n\n", "Tag": "算法分析"}
{"Answer": "倒幂函数曲线y = a + b ⋅ 1 x y=a+b \\cdot \\dfrac{1}{x}y=a+b⋅x1​ 型令x ′ = 1 x {x}'=\\dfrac{1}{x}x′ =x1​ , 则得y = a + b ⋅ x ′ y=a+b \\cdot {x}'y=a+b⋅x′ .双曲线1 y = a + b ⋅ 1 x \\dfrac{1}{y}=a+b \\cdot \\dfrac{1}{x}y1​ =a+b⋅x1​ 型令x ′ = 1 x , y ′ = 1 y {x}'=\\dfrac{1}{x}, {y}'=\\dfrac{1}{y}x′ =x1​ ,y′ =y1​ , 则得y ′ = a + b ⋅ x ′ {y}'=a+b \\cdot {x}'y′ =a+b⋅x′ .幂函数曲线y = d ⋅ x b y=d \\cdot x^by=d⋅xb 型令y ′ = I n y , x ′ = I n x , a = I n d {y}'=Iny, {x}'=Inx, a=Indy′ =Iny,x′ =Inx,a=Ind, 则得y ′ = a + b x ′ {y}'=a+b{x}'y′ =a+bx′ .指数曲线y = d ⋅ e b x y=d \\cdot e^{bx}y=d⋅ebx 型令y ′ = I n y , a = I n d {y}'=Iny, a=Indy′ =Iny,a=Ind, 则得y ′ = a + b x {y}'=a+bxy′ =a+bx.倒指数曲线y = d ⋅ e b x y=d \\cdot e^{\\dfrac{b}{x}}y=d⋅exb​\n 型令y ′ = I n y , x ′ = 1 x , a = I n d {y}'=Iny, {x}'=\\dfrac{1}{x}, a=Indy′ =Iny,x′ =x1​ ,a=Ind, 则得y ′ = a + b x ′ {y}'=a+b{x}'y′ =a+bx′ .————————————————版权声明：本文为CSDN博主「Mestarxh」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/wumian0123/article/details/81677076", "Konwledge_Point": "线性规划和规约", "Question": "选择用哪一种非线性回归模型？\n选择用哪一种非线性回归模型？\n怎么进行选择的啊？\n根据图形还是？\n感谢！", "Tag": "算法分析"}
{"Answer": "最后一段，没环境，没有测试过。layout_weight注意一下，如果一个区域分2部分，其中一个要占4分之3，则那个区域要设1（越小占比越大)，另一个要设3\r\n\r\n```\r\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \r\n```", "Konwledge_Point": "线性规划和规约", "Question": "android线性布局（计算器ui）\n\n以上是效果图：\n\n下面是我的代码，求指教：\n\n\n\n    android:layout_width=\"match_parent\"\n\n    android:layout_height=\"match_parent\"\n\n    android:orientation=\"vertical\" >\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/i1020/article/details/53469317", "Konwledge_Point": "线性规划和规约", "Question": "最小花费计算的问题？这是线性规划实现么？\nProblem Description\n\nAs far as we known,there are so many people in this world,expecially in china.But many people like LJ always insist on that more people more power.And he often says he will burn as much babies as he could.Unfortunatly,the president XiaoHu already found LJ's extreme mind,so he have to publish a policy to control the population from keep on growing.According the fact that there are much more men than women,and some parents are rich and well educated,so the president XiaoHu made a family planning policy:\n\nAccording to every parents conditions to establish a number M which means that parents can born M children at most.But once borned a boy them can't born other babies any more.If anyone break the policy will punished for 10000RMB for the first time ,and twice for the next time.For example,if LJ only allowed to born 3 babies at most,but his first baby is a boy ,but he keep on borning another 3 babies, so he will be punished for 70000RMB(10000+20000+40000) totaly.\n\n\n\nInput\n\nThe first line of the input contains an integer T(1 <= T <= 100) which means the number of test cases.In every case first input two integers M(0<=M<=30) and N(0<=N<=30),N represent the number of babies a couple borned,then in the follow line are N binary numbers,0 represent girl,and 1 represent boy.\n\n\n\nOutput\n\nForeach test case you should output the total money a couple have to pay for their babies.\n\n\n\nSample Input\n\n2\n\n2 5\n\n0 0 1 1 1\n\n\n\n2 2\n\n0 0\n\n\n\nSample Output\n\n70000 RMB\n\n0 RMB", "Tag": "算法分析"}
{"Answer": "所谓自感电动势就类似于作用力和反作用力一样我用10N的力推你，你也反作用10N的力在我身上，但这并不影响我把你推跑了而不是反过来你把我推跑了如果没有自感电动势，也就不存在电感两端有电压了，它就短路了但随着时间的推移，电感里形成了电流之后，自感电动势就没了，所以对于直流电源来说电感就相当于短路，它只在接通的一瞬间有电压还是用力来类比我用10N的力推你，但随着你的移动，我胳膊不够长了，你对我的力变小了，我对你的力也变小了", "Konwledge_Point": "线性规划和规约", "Question": "为什么buck电路中电感电流是线性变化的\n在进行buck电路工作过程的实际参数计算时，运用电感的伏秒平衡规律有以下公式\n\n\n\n\n\n\n\n\n但是比较疑惑的一点是，这样计算的前提是默认了电感中的电流是线性变化的，也即在开关管导通和截止时，电感两端的电压分别是一个固定值。导通时（Us-Uo），截止时Uo。\n电感的电压电流关系如下\n\n\n\n\n\n\n第一个公式表明在外加电压的作用下，电感中产生电流，但是第二个公式作为第一个的逆形式，却也是电感的自感电动势公式，和外加电压等大反向?那自感电动势不会影响电感两端实际电压吗，如果影响电感两端电压值还能固定吗？感觉有点绕晕了，不知道有没有小伙伴考虑过同样的问题，求解答或一起探讨下", "Tag": "算法分析"}
{"Answer": "参考一下：https://blog.csdn.net/your_answer/article/details/79234275https://blog.csdn.net/linshen1213/article/details/99433348如果对你有帮助，可以点击我这个回答右上方的【采纳】按钮，给我个采纳吗，谢谢", "Konwledge_Point": "线性规划和规约", "Question": "求解一阶线性微分方程组，matlab或者python都可以。\n有如下微分方程组：\n\n\n\n\n矩阵D全是数值，存在一些边界条件,当0<=Z<=10时，有Zmn（0）= -10，Xmn（0）=Ymn（0）=Xmn（10）=Ymn（10）=Zmn（10）=0,如何用matlab求解Rmn（z），数值解和解析解都可以。\n\n\nD=[0,0,0,0.00166666666666667,0,-2.19911485751286;0,0,0,0,0.00200000000000000,-2.19911485751286;0,0,0,2.19911485751286,2.19911485751286,0;51566.8828791659,4118.29417355141,-0.691545552676999,0,0,0;4118.29417355141,7768.18561244484,-0.567067353195139,0,0,0;0.691545552676999,0.567067353195139,0.000927672955974843,0,0,0]\n\n\nThanks！", "Tag": "算法分析"}
{"Answer": "一般是看你需要哪个，应该是实际情况而定比方说你要第一个解：\nU1 = solU1(1);\nV1 = solV1(1);\n\n你要第二个解：\nU2 = solU1(2);\nV2 = solV1(2);\n", "Konwledge_Point": "线性规划和规约", "Question": "非线性方程组有多个解的问题\n问题遇到的现象和发生背景\n\n\n非线性方程组有两个解，怎么才能只保留一个\n\n\n问题相关代码，请勿粘贴截图\n\n\nclc,clear\nsyms u v; % 定义u v 是未知量\neqns=[(u+1.25)/(v+0.69) == 4533269482901803/4503599627370496,64/49 == (v + 0.69)^2 + (u+ 1.25)^2]; % 定义方程组\nvars=[u,v]; % 定义求解的未知量\n[solU,solV]=solve(eqns,vars) % 求解eqns中的vars未知量，分别存储\nsol=fzero(eqns,vars); % 求解eqns中的vars未知量，以结构体的形式存储到sol中\nsolU1=sol.u % 从sol结构体中取出变量u的解\nsolV1=sol.v % 从sol结构体中取出变量v的解\n\n\n想保留一个解，怎么操作啊，求", "Tag": "算法分析"}
{"Answer": " https://blog.csdn.net/weixin_43905191/article/details/104677945?utm_source=app&app_version=5.2.1&code=app_1562916241&uLinkId=usr1mkqgl919blen", "Konwledge_Point": "线性规划和规约", "Question": "想知道能不能用Python实现克莱姆公式求解线性方程组啊\n就自己瞎写了些，好像都不太行，想看看有没有什么方法实现用程序来计算克莱姆方程对线性方程组的求解", "Tag": "算法分析"}
{"Answer": "我明白了，后面的+/-0n的意思就是小数点往后/前移n位", "Konwledge_Point": "线性规划和规约", "Question": "请问matlab非线性规划模型拟合stats的p这个属于是什么\n如图，请问这个数应该怎么看？\n这个模型拟合的可以吗\n球秋有时间而且愿意解答的朋友答疑解惑指点迷津", "Tag": "算法分析"}
{"Answer": "model.predict(pp.fit_transform([[16]])) 这个是一个数还是一组数的预测？", "Konwledge_Point": "线性规划和规约", "Question": "非线性回归的模型的预测是负数，如何解决\nx轴是1到12\ny轴是20W到50W\n打算用非线性回归的相关库来预测数据\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures as pf\n\n\npp=pf(degree=3)\nlist_grade=np.array(list_grade).reshape(-1,1)\ntrainx=pp.fit_transform(list_grade)\nmodel=LinearRegression()\nmodel.fit(trainx,list_time)\na=model.score(trainx,list_time)\n\n\n然后用预测函数预测下后面的值，但是出现了问题\nmodel.predict(pp.fit_transform([[16]]))\n后面都是负数了", "Tag": "算法分析"}
{"Answer": "出现了新手常见的问题，可以参考参考这篇文章https://www.zhihu.com/question/309028363/answer/582638696", "Konwledge_Point": "线性规划和规约", "Question": "为什么spss数据分析正相关的回归线系数是负的呀？\n如图，分析是有显著的正向影响，但是回归系数B是负的，这有什么影响吗？我能改成正的吗？", "Tag": "算法分析"}
{"Answer": "学C语言是为了控制计算机做你想做的事情。学线性代数是为了分析解决实际应用问题。如果你想用计算机解决一个需要用线性代数的实际问题，那么你就需要用C语言将问题的线性代数描述告诉计算机让它来解决。不过基本线性代数用的比较少，不同太担心。", "Konwledge_Point": "线性规划和规约", "Question": "线性代数和C语言有关系吗\nC语言和线性代数有关系吗？学的电子信息工程，想走软件方向，但是大一的线性代数有点头疼(´;︵;`)", "Tag": "算法分析"}
{"Answer": "用运筹学，Lingo软件，具体咋用网上有运筹学的书，里面有很相似的问题", "Konwledge_Point": "线性规划和规约", "Question": "请问这个问题应该用什么方法解决？线性规划？运筹学？控制论？？求答\n本人不是数学相关专业，请大家尽量讲解的白话一点\n问题 一天24小时，周期7天，居民自由出行的时长为6点-11点   15点-21点之间，可以出行体育锻炼，共计11小时\n目标：居民需要在一周7天内进行不少于共计5次的锻炼\n其中:中年人有890422*8.38%（746174）人，30%偏好广场舞，23%偏好羽毛球，14%偏好游泳，2%偏好篮球，20%偏好跑步，11%偏好乒乓球\n为了保证居民使用场地进行锻炼时的尺度适宜，其中广场舞每人占地1平方米，一个羽毛球场地可同时容纳2或4人，一条50米泳道至多同时6人，篮球场10人，乒乓球2或4人，每100米跑道10人。\n假设居民进行每项活动在30-150分钟范围内，要保证满足居民活动时长，类型和只要想进行活动就基本上不用排队的需求，设施应该具有的数量大致是多少？\n\n\n以上问题目前是一个年龄段的问题，若需要计算满足3个年龄段锻炼需求的设施数量（活动偏好比例不同、可出行锻炼时长不同）需要用怎样的方法得出？\n请问用什么方法求解", "Tag": "算法分析"}
{"Answer": "我今天遇到了，网上找了一圈也没有对策。后面猜可能是y轴的数据类型有问题，就将数据转为float就行了", "Konwledge_Point": "线性规划和规约", "Question": "Python matplotlib画图总是一条直线\n如图\n\n\n\n\n\n\n不论怎么画都是一条直线，但明显这不是线性关系。不明白怎么控制这个y轴的刻度，去网上找了半天也没找到解决方案。求解答这是为什么，该怎么处理", "Tag": "算法分析"}
{"Answer": "两个数，比较一次。1024个不是比较1023次吗需要比较的最大次数是元素个数-1", "Konwledge_Point": "线性规划和规约", "Question": "关于Java语言程序设计中的线性查找疑问\njava语言程序设计中的一句话：对于一个有 1024 ( 2 ∧10 ) 个元素的数组，在最坏情况下 ， 二分査找法只需要比较 11 次 ， 而在最坏的情况下线性査找要比较 1023 次。为什么线性是1023次呀，不是1024次吗 ？", "Tag": "算法分析"}
{"Answer": "这个错误是由于在字符串中使用了无效的格式化占位符导致的。在这里，你使用了\"{:.2f}\"这个占位符，它的意思是将一个浮点数格式化为保留两位小数的字符串。\n但是，在这个语句中，你传递给占位符的是一个二维数组gdp_prediction的第一个元素，它应该是一个标量或一维数组，而不是一个二维数组。因此，你需要使用gdp_prediction[0]或gdp_prediction.flatten()[0]来获取第一个元素，然后将它格式化为字符串。同样的，对于ggdp_prediction也需要做相应的修改。\n下面是修改后的代码：\ngdp_prediction = np.array(model.predict(X)).reshape(-1,1)\nggdp_prediction = np.array(model.predict(X)).reshape(-1,1)\nprint('{:.2f}'.format(gdp_prediction[0][0]))\n\n或者使用flatten()方法：\ngdp_prediction = np.array(model.predict(X)).reshape(-1,1)\nggdp_prediction = np.array(model.predict(X)).reshape(-1,1)\nprint('{:.2f}'.format(gdp_prediction.flatten()[0]))\n\n注意，在这里我假设了X是用来进行预测的输入数据，你需要根据你的具体情况进行相应的修改。如果对您有帮助，请给与采纳，谢谢。", "Konwledge_Point": "线性规划和规约", "Question": "Python 线性回归\ngdp_prediction=np.array(model.predict).reshape(-1,1)\nggdp_prediction=np.array(model.predict).reshape(-1,1)\nprint('{:.2f}'.format(gdp_prediction[0][0]))\n报错是 unsupported format string passed to method.\nformat\n请问要怎么改", "Tag": "算法分析"}
{"Answer": "double类型读取用%lfscanf(\"%f%f%f%f%f%f\",&a,&b,&c,&d,&e,&f);这里的%f都改成%lfscanf这里改完就可以了，代码如下：\n#include <stdio.h>\n#include <math.h>\nint main()\n{\n    double a,b,c,d,e,f,x,y;\n    double det, det1, det2, ind1, ind2;\n    scanf(\"%lf%lf%lf%lf%lf%lf\",&a,&b,&c,&d,&e,&f);\n\n    det=a*e-b*d;\n    det1=a*f-c*d;\n    det2=c*e-b*f;\n    if(fabs(det)<1e-6)\n        if(fabs(det1)<1e-6)\n        {\n            ind1=-b/a;\n            ind2=c/a;\n            printf(\"Infinite solution:x=%f*k+%f,k varies within R\\n\",ind1,ind2);\n        }\n        else\n            printf(\"unsolvable\\n\");\n    else\n    {\n        x=det2/det;\n        y=det1/det;\n        printf(\"x=%f,y=%f\\n\",x,y);\n    }\n    return (0);\n}\n\n", "Konwledge_Point": "线性规划和规约", "Question": "请看一下哪里错了，ax+by=c   dx+ey=f\n#include \n#include\nint main()\n{\n    double a,b,c,d,e,f,x,y;\n    double det, det1, det2, ind1, ind2;\n    scanf(\"%f%f%f%f%f%f\",&a,&b,&c,&d,&e,&f);\n    det=a\ne-b\nd;\n    det1=a\nf-c\nd;\n    det2=c\ne-b\nf;\n    if(fabs(det)<1e-6)\n        if(fabs(det1)<1e-6)\n        {ind1=-b/a;\n            ind2=c/a;\n            printf(\"Infinite solution:x=%f*k+%f,k varies within R\\n\",ind1,ind2);}\n        else\n            printf(\"unsolvable\\n\");\n    else\n    {x=det2/det;\n        y=det1/det;\n        printf(\"x=%f,y=%f\\n\",x,y);}\nreturn (0);\n}", "Tag": "算法分析"}
{"Answer": "你的列表用的RecyclerView？还是直接在线性布局一个个添加的？", "Konwledge_Point": "线性规划和规约", "Question": "Android Studio线性布局下滑滚动无响应\n如图：\n\n\n\n\n问题：\n\n\n列表无法下拉到底部，有些内容显示不出来，布局是线性布局，请问有什么属性或控件能使列表下拉到底部，之前做了底部间距但是无效果", "Tag": "算法分析"}
{"Answer": "/**************************************************************\n要求：\n1、管理学生的信息，包括，学号，姓名，各科成绩\n2、将信息保存成文件，能反复使用\n3、对信息操作，包括，添加学生信息，修改，删除，\n   按学号、姓名查询学生信息\n4、能进行科目成绩排序，科目分数段查询\n附data文件实例：\n001  小黑  语文  60.00  英语  70.00  数学  90.00\n002  小天  语文  70.00  英语  90.00  数学  80.00\n003  小芳  语文  80.00  英语  80.00  数学  70.00\n004  小鱼  语文  90.00  英语  70.00  数学 100.00\n***************************************************************/\n \n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n \n//链表结点结构体声明\ntypedef struct subjects\n{\n    char name[20];\n    float score;\n}sub;\n \ntypedef struct student\n{\n    int num;\n    char name[20];\n    sub  subject[3];\n    struct student* next;\n}stu,*pstu;\n \n#define SIZE sizeof(stu)\n \n//函数申明\npstu LoadInfo();\nvoid PrintMenu();\npstu AddStu(pstu );\npstu DeleStu(pstu );\npstu RwrStu(pstu );\nvoid FindStu(pstu , char );\nvoid Count(pstu ,char * ,float ,float );\nvoid Rank(pstu ,char * );\nvoid SaveQuit(pstu );\n \n//主函数\nint main()\n{ \n    float score1,score2;\n    char n,j;\n    char subname[20];\n    pstu head,ptr;\n    \n    head = LoadInfo();\n    ptr = head->next;\n \n    //创建菜单，进入选择循环\n    while(1)\n    {\n        PrintMenu();\n        printf(\"请输入您的选择编号：\");\n        scanf(\"%d\",&n);\n        getchar();                       //接收上次输入选择后的回车输入,不致影响下一次输入\n        switch(n)\n        {\n        case 1: \n            {\n                //信息管理\n                system(\"cls\");                //清屏\n                j=0;\n                while(4!=j)               //循环进入子菜单选择\n                {\n                    printf(\"欢迎进入信息管理版块！\\n\\n\");\n                    printf(\"\\025 1、添加学生\\n\");\n                    printf(\"\\025 2、删除学生\\n\");\n                    printf(\"\\025 3、修改学生信息\\n\");\n                    printf(\"\\025 4、返回\\n\");\n                    printf(\"请输入您的选择编号：\\n\");\n                    scanf(\"%d\",&j);\n                    getchar();\n                    \n                    if     ( 1 == j) head = AddStu(head);        //添加学生\n                    else if( 2 == j) head = DeleStu(head);        //删除学生\n                    else if( 3 == j) head = RwrStu(head);        //修改重写学生信息\n                    else if( 4 == j) ;\n                    else printf(\"输入有误,请重新输入!\\n\");\n                    \n                }\n                printf(\"请输入回车键返回主菜单！\");     //此处本意按任意键返回，但是任意键的话，需要按键A，再按回车确定\n                getchar();            //则会连续收到两个按键，造成错误读入，可以改进scanf接收字符串，\n                system(\"cls\");            //以下所有getchar()、system(\"cls\")同理\n                break;\n            }\n        case 2:\n            {\n                //信息查询\n                system(\"cls\");\n                printf(\"欢迎进入信息查询版块!\\n\");\n                printf(\"请输入要查询的学生编号：\");\n                scanf(\"%d\",&j);\n                getchar();\n                //printf(\"%d\\n\",j);           //检测输入是否成功,调试程序用\n                FindStu(head,j);            //查询并输出\n                printf(\"\\n请输入回车键返回主菜单！\");\n                getchar();\n                system(\"cls\");\n                break;\n            }\n        case 3:\n            {\n                //成绩统计\n                system(\"cls\");\n                printf(\"欢迎进入成绩统计版块!\\n\");\n                printf(\"请输入科目：\");\n                scanf(\"%s\",&subname);\n                getchar();\n                printf(\"请输入分数范围(score1,score2)：\");\n                scanf(\"%f,%f\",&score1,&score2);\n                getchar();\n                /*printf(\"%s %5.2f %5.2f\\n\",subname,\n                         score1,score2);   */          //检测输入是否成功，调试程序用\n                Count(head,subname,score1,score2);          //统计并输出\n                printf(\"请输入回车键返回主菜单！\");\n                getchar();\n                system(\"cls\");\n                break;\n            }\n        case 4:\n            {\n                //成绩排序\n                system(\"cls\");\n                printf(\"欢迎进入成绩排序版块，请输入科目：\");\n                scanf(\"%s\",&subname);\n                getchar();\n                Rank(head,subname);              //排序并输出\n                printf(\"\\n请输入回车键返回主菜单！\\n\");\n                getchar();\n                system(\"cls\");\n                break;\n            }\n        case 5:\n            {\n                //保存退出\n                SaveQuit(head);                //文件操作，保存并退出\n                free(head);\n                return 0;\n            }\n        default: \n            {\n                printf(\"输入有误，按回车键重新选择！\\n\");    //主菜单错误输出检测\n                getchar();\n                system(\"cls\");\n            }\n        }\n    }\n    \n      \n}\n \n//加载data数据 ，文件操作\npstu LoadInfo()\n{\n    int   num;\n    char name[20];\n    char sub1[20];\n    char sub2[20];\n    char sub3[20];\n    float score1;\n    float score2;\n    float score3;\n    \n    char filename[] = \"D:\\\\编程学习\\\\编程实践\\\\c语言课程设计1 学生信息管理\\\\data.txt\";  //文件名,此处为简化编程，采用固定地址名称，未作输入\n       FILE *fp; \n    pstu head,ptr;\n    \n    //创建带表头结点的空单链表head，用来存放载入信息\n    head = (pstu)malloc(SIZE);\n    ptr = head;\n    ptr->next = NULL;\n    \n    \n    //加载data文件，存入head链表\n    if( NULL == (fp = fopen(filename,\"r\")) )             //判断文件是否存在及可读\n    { \n        printf(\"error!\"); \n        exit(0); \n    } \n    \n    while (!feof(fp)) \n    { \n        fscanf(fp,\"%d %s %s %f %s %f %s %f\\n\",&num,&name,\n              &sub1,&score1,&sub2,&score2,&sub3,&score3); //读取一行，采用格式化读取，避免了其他各种读取方法的数据处理问题\n                                                                //该方法缺点明显，对数据格式要求教研，故data文件规定数据格式\n        ptr->next = (pstu)malloc(SIZE);\n        ptr = ptr->next;\n        ptr->next = NULL;\n        \n        ptr->num = num;\n        strcpy(ptr->name,name);\n        strcpy(ptr->subject[0].name,sub1);\n        ptr->subject[0].score = score1;\n        strcpy(ptr->subject[1].name,sub2);\n        ptr->subject[1].score = score2;\n        strcpy(ptr->subject[2].name,sub3);\n        ptr->subject[2].score = score3;\n        \n    } \n    \n    fclose(fp);                                         //关闭文件,已得到保存data信息的链表head\n    \n    return head;\n}\n \n \n//打印主菜单\nvoid PrintMenu()    \n{\n    printf(\"***************************************\\n\");\n    printf(\"           枫枫学生信息管理系统        \\n\");\n    printf(\"***************************************\\n\");\n    putchar('\\n');\n    printf(\"菜单\\n\");\n    printf(\"\\025 1、信息管理\\n\");\n    printf(\"\\025 2、信息查询\\n\");\n    printf(\"\\025 3、成绩统计\\n\");\n    printf(\"\\025 4、成绩排序\\n\");    \n    printf(\"\\025 5、保存退出\\n\");\n}\n \n//添加学生\npstu AddStu(pstu x)  \n{\n    char namestu[20];\n    char *p;\n    char subname1[20],subname2[20],subname3[20];\n    pstu head,ptr;\n    \n    head = x;\n    ptr = head;\n    \n    while( NULL != ptr->next )                    //遍历链表，找到链尾结点\n    {\n        ptr = ptr->next;\n    }\n    \n    ptr->next = (pstu)malloc(SIZE);                //默认在链表末追加添加信息\n    ptr = ptr->next;\n    ptr->next = NULL;\n    \n    printf(\"请输入添加学生的信息：\\n\");\n \n    printf(\"请输入添加学生的学号：\");\n    scanf(\"%d\",&ptr->num);\n    getchar();\n \n    printf(\"请输入添加学生的姓名：\");\n    scanf(\"%s\",namestu);\n    getchar();\n    p = namestu;\n    strcpy(ptr->name,p);\n \n    printf(\"请输入添加学生的科目1名称：\");\n    scanf(\"%s\",&subname1);\n    getchar();\n    p = subname1;\n    strcpy(ptr->subject[0].name,p);\n \n    printf(\"请输入添加学生的科目1成绩：\");\n    scanf(\"%f\",&ptr->subject[0].score);\n    getchar();\n \n    printf(\"请输入添加学生的科目2名称：\");\n    scanf(\"%s\",&subname2);\n    getchar();\n    p = subname2;\n    strcpy(ptr->subject[1].name,p);\n \n    printf(\"请输入添加学生的科目2成绩：\");\n    scanf(\"%f\",&ptr->subject[1].score);\n    getchar();\n \n    printf(\"请输入添加学生的科目3名称：\");\n    scanf(\"%s\",&subname3);\n    getchar();\n    p = subname3;\n    strcpy(ptr->subject[2].name,p);\n \n    printf(\"请输入添加学生的科目3成绩：\");\n    scanf(\"%f\",&ptr->subject[2].score);\n    getchar();\n    \n    putchar('\\n');\n    return head;\n}\n \n//删除学生\npstu DeleStu(pstu x)   \n{\n    int num;\n    pstu head,ptr,qtr;\n    \n    head = x;\n    ptr = head->next;\n    qtr = head;\n \n    printf(\"请输入要删除的学生的学号：\");\n    scanf(\"%d\",&num);\n    getchar();\n \n    while(ptr!=NULL)\n    {\n        if( ptr->num != num)                //遍历查找链表结点，未找到跳过该结点\n        {\n            ptr = ptr->next;\n            qtr = qtr->next;\n        }\n        else                        //找到则删除结点\n        {\n            ptr = ptr->next;\n            qtr->next = ptr;\n            break;\n        }\n    }\n    \n    printf(\"该学生信息已删除！\\n\\n\");\n    return head;\n}\n \n//修改学生信息\npstu RwrStu(pstu x)   \n{\n    char namestu[20];\n    char *p;\n    char subname1[20],subname2[20],subname3[20];\n    int num;\n    pstu head,ptr;\n    \n    head = x;\n    ptr = head->next;\n \n    printf(\"请输入要修改的学生的学号：\");\n    scanf(\"%d\",&num);\n    getchar();\n \n    while(ptr!=NULL)\n    {\n        if( ptr->num == num )\n        {\n            printf(\"已找到该学生信息，请填入修改项目：\");\n \n            printf(\"请输入修改学生的姓名：\");\n            scanf(\"%s\",namestu);\n            getchar();\n            p = namestu;\n            strcpy(ptr->name,p);\n \n            printf(\"请输入修改学生的科目1名称：\");\n            scanf(\"%s\",subname1);\n            getchar();\n            p = subname1;\n            strcpy(ptr->subject[0].name,p);\n \n            printf(\"请输入修改学生的科目1成绩：\");\n            scanf(\"%f\",&ptr->subject[0].score);\n            getchar();\n \n            printf(\"请输入修改学生的科目2名称：\");\n            scanf(\"%s\",subname2);\n            getchar();\n            p = subname2;\n            strcpy(ptr->subject[1].name,p);\n \n            printf(\"请输入修改学生的科目2成绩：\");\n            scanf(\"%f\",&ptr->subject[1].score);\n            getchar();\n \n            printf(\"请输入修改学生的科目3名称：\");\n            scanf(\"%s\",subname3);\n            getchar();\n            p = subname3;\n            strcpy(ptr->subject[2].name,p);\n \n            printf(\"请输入修改学生的科目3成绩：\");\n            scanf(\"%f\",&ptr->subject[2].score);\n            getchar();\n \n            printf(\"该学生信息已修改！\\n\\n\");\n            break;\n        }\n        else\n        {\n            ptr = ptr->next;\n        }\n    }\n    \n    return head;\n}\n \n//查找学生，参数为链表指针，和学生学号\n//不好，应该将学号输入放进子函数，简化主函数结构，减少子函数参数\nvoid FindStu(pstu x,char y)    \n{\n    pstu head,ptr;\n    \n    head = x;\n    ptr = head->next;\n    \n    while( ptr != NULL)\n    {\n        if( ptr->num == (int)y)        //因主函数中为节省空间，学号输入采用char数据，故强行准换\n        {\n            printf(\"已找到该学生信息!\\n如下：\");\n            printf(\"%03d  %s  %s  %5.2f  %s  %5.2f  %s  %5.2f\\n\",\n                ptr->num,ptr->name,ptr->subject[0].name,ptr->subject[0].score,ptr->subject[1].name,ptr->subject[1].score,ptr->subject[2].name,ptr->subject[2].score);            break;            //注意此处找到并输出信息后要手动退出循环\n        }\n        else\n        {\n            ptr = ptr->next;\n        }\n    }\n    if( ptr == NULL )                //查询成功检测，while循环中若找到，则ptr停留在当前学生的结点上\n    {\n        printf(\"未能找到该学生信息！\\n\");\n    }\n}\n \n \n//统计科目分数区间段的学生,参数为链表指针，科目名称，分数区间上下限\n//同理，参数的录入应放入子函数，简化结构和编程\nvoid Count(pstu x,char *y,float q,float p)    \n{\n    pstu head,ptr;\n    char name[20];\n    char flag=0;                   //手动设置的查找结果flag\n    \n    head = x;\n    ptr = head->next;\n    strcpy(name,y);\n    \n    //printf(\"%s %5.2f %5.2f\\n\",name,q,p);     //检测输入参数的传递，调试程序用\n \n    while( ptr != NULL)            //开始查找统计，科目查找用strcmp函数比较科目字符串,返回值0为字符串相等\n    {                                                            //此处while循环体中，重复的查找步骤太多，应设置科目匹配flag，参照rank()函数\n        if( strcmp(name,ptr->subject[0].name) == 0 )     //通过flag将科目确认放在while之外，循环体内只做分数区间的扫描和输出\n        {\n            if( q <= ptr->subject[0].score && ptr->subject[0].score<= p )\n            {\n                printf(\"%03d  %s  %s  %5.2f\\n\",ptr->num,ptr->name,ptr->subject[0].name,ptr->subject[0].score);\n                flag++;\n            }\n        }\n        if( strcmp(name,ptr->subject[1].name) == 0 )\n        {\n            if( q <= ptr->subject[1].score && ptr->subject[1].score<= p )\n            {\n                printf(\"%03d  %s  %s  %5.2f\\n\",ptr->num,ptr->name,ptr->subject[1].name,ptr->subject[1].score);\n                flag++;\n            }\n        }\n        if( strcmp(name,ptr->subject[2].name) == 0 )\n        {\n            if( q <= ptr->subject[2].score && ptr->subject[2].score<= p )\n            {\n                printf(\"%03d  %s  %s  %5.2f\\n\",ptr->num,ptr->name,ptr->subject[2].name,ptr->subject[2].score);\n                flag++;\n            }\n        }\n        \n        ptr = ptr->next;\n    }\n \n    if(flag==0)\n    {\n        printf(\"未能找到该课程该区间分数段的学生！\\n\");\n    }\n}\n \n \n//学科成绩排名,采用交换数据的方法,参数为链表指针，科目名称\n//同理参数问题\n//链表排序问题，此处用交换结点数据方法，还有其他多种排序方法\n//如，交换结点，辅助指针数组排序(未实现，过程繁杂)，插入法排序等\nvoid Rank(pstu x,char *y)     \n{\n    pstu head,ptr,qtr;\n    char name[20];\n    char len=0;\n    char flag=0;                    //简化算法,设置科目查找结果判断值,flag=0表示科目输入为未知科目，不存在\n    int i=0;                                                    //i、j循环次数控制参数\n    int j=0;  \n    char temp_name[20];            //数据交换时的暂存信息变量\n    float temp0,temp1,temp2;\n    int temp_num;\n \n    strcpy(name,y);\n    head = x;\n \n    ptr = head->next;\n    while( ptr != NULL)               //测链表长度,不包括表头结点\n    {\n        ptr = ptr->next;\n        len++;\n    }\n    ptr = head->next;              //指针ptr用过之后记得回原位\n                \n \n    //开始查找科目\n    if( strcmp(name,ptr->subject[0].name) == 0)    flag=1; \n    if( strcmp(name,ptr->subject[1].name) == 0)    flag=2;\n    if( strcmp(name,ptr->subject[2].name) == 0)    flag=3;\n    if( flag == 0)\n    {\n        printf(\"未找到该科目!\");\n        return;\n    }\n    \n    //开始排序,冒泡法比较各结点数据\n    //此处3个并列的if用switch case更清晰结构\n    if( n == 1 )\n    {\n        for( i=0;i<len;i++)\n        {\n            ptr = head->next->next;    //每一次内循环之后，ptr、qtr必然在最后两个节点上\n            qtr = head->next;        //故在进行内循环之前，要重新复位ptr、qtr\n            for( j=0;j<len-i-1;j++)\n            {\n                if( qtr->subject[0].score < ptr->subject[0].score )\n                {\n                    temp_num = qtr->num;    //交换数据,因数据格式(科目顺序)明确规定，故不再做科目名称的替换\n                    strcpy(temp_name,qtr->name);\n                    temp0 = qtr->subject[0].score;\n                    temp1 = qtr->subject[1].score;\n                    temp2 = qtr->subject[2].score;\n                    \n                    qtr->num = ptr->num;\n                    strcpy(qtr->name,ptr->name);\n                    qtr->subject[0].score = ptr->subject[0].score;\n                    qtr->subject[1].score = ptr->subject[1].score;\n                    qtr->subject[2].score = ptr->subject[2].score;\n                    \n                    ptr->num = temp_num;\n                    strcpy(ptr->name,temp_name);\n                    ptr->subject[0].score = temp0;\n                    ptr->subject[1].score = temp1;\n                    ptr->subject[2].score = temp2;\n                }\n                qtr = qtr->next;\n                ptr = ptr->next;\n            }\n        }\n    }\n    \n    if( n == 2 )\n    {\n        for( i=0;i<len;i++)\n        {\n            ptr = head->next->next;\n            qtr = head->next;\n            for( j=0;j<len-i-1;j++)\n            {\n                if( qtr->subject[1].score < ptr->subject[1].score )\n                {\n                    temp_num = qtr->num;\n                    strcpy(temp_name,qtr->name);\n                    temp0 = qtr->subject[0].score;\n                    temp1 = qtr->subject[1].score;\n                    temp2 = qtr->subject[2].score;\n                    \n                    qtr->num = ptr->num;\n                    strcpy(qtr->name,ptr->name);\n                    qtr->subject[0].score = ptr->subject[0].score;\n                    qtr->subject[1].score = ptr->subject[1].score;\n                    qtr->subject[2].score = ptr->subject[2].score;\n                    \n                    ptr->num = temp_num;\n                    strcpy(ptr->name,temp_name);\n                    ptr->subject[0].score = temp0;\n                    ptr->subject[1].score = temp1;\n                    ptr->subject[2].score = temp2;\n                }\n                qtr = qtr->next;\n                ptr = ptr->next;\n            }\n        }\n    }\n    \n    if( n == 3 )\n    {\n        for( i=0;i<len;i++)\n        {\n            ptr = head->next->next;\n            qtr = head->next;\n            for( j=0;j<len-i-1;j++)\n            {\n                if( qtr->subject[2].score < ptr->subject[2].score )\n                {\n                    temp_num = qtr->num;\n                    strcpy(temp_name,qtr->name);\n                    temp0 = qtr->subject[0].score;\n                    temp1 = qtr->subject[1].score;\n                    temp2 = qtr->subject[2].score;\n                    \n                    qtr->num = ptr->num;\n                    strcpy(qtr->name,ptr->name);\n                    qtr->subject[0].score = ptr->subject[0].score;\n                    qtr->subject[1].score = ptr->subject[1].score;\n                    qtr->subject[2].score = ptr->subject[2].score;\n                    \n                    ptr->num = temp_num;\n                    strcpy(ptr->name,temp_name);\n                    ptr->subject[0].score = temp0;\n                    ptr->subject[1].score = temp1;\n                    ptr->subject[2].score = temp2;\n                }\n                qtr = qtr->next;\n                ptr = ptr->next;\n            }\n        }\n    }\n \n    //输出排序过后的链表\n    ptr = head->next;\n    while( ptr != NULL )\n    {\n        printf(\"%03d  %s  %s  %5.2f  %s  %5.2f  %s  %5.2f\\n\",\n              ptr->num,ptr->name,ptr->subject[0].name,ptr->subject[0].score,\n              ptr->subject[1].name,ptr->subject[1].score,\n              ptr->subject[2].name,ptr->subject[2].score);\n        ptr = ptr->next;\n    }\n}\n \n \n//保存文件并退出，文件操作\nvoid SaveQuit(pstu x)    \n{\n    pstu head,ptr;\n    FILE *fp;\n    char filename[] = \"D:\\\\编程学习\\\\编程实践\\\\c语言课程设计1 学生信息管理\\\\data.txt\";\n    head = x;\n    ptr = head->next;\n \n    if( NULL == (fp = fopen(filename,\"w\")) )             //判断文件是否存在及可读\n    { \n        printf(\"error!\"); \n        exit(0); \n    } \n    \n    while(ptr != NULL)                        //遍历链表结点，按data约定格式输出数据\n    {\n        fprintf(fp,\"%03d  %s  %s  %5.2f  %s  %5.2f  %s  %5.2f\\r\",\n            ptr->num,ptr->name,ptr->subject[0].name,ptr->subject[0].score,\n", "Konwledge_Point": "线性规划和规约", "Question": "文件操作+线性链表+直接插入排序操作实验室\n有结构体定义如下：\nstruct stuInfo\n{    char id[12];            //数据成员\n      char name[15];\n      float score;\n      struct stuInfo *next;   //指针成员\n};\n任务及要求：\n（1）首先完成线性链表的定义和创建，确保链表的第一个节点为哨兵节点，不存放有效的数据；（2）利用文件的相关操作，动态开辟节点存储空间，将存放在磁盘某个路径中的文件“stuinfo.txt”信息逐条读入，并依次存入到线性链表的每个节点中，\n信息如下；\n00001 张三100\n00002 李四 99\n00003 王五 100\n00004 王六 89\n00005 江涛 98\n00006 陈琪 88\n00007 祁廷 91\n（3）接下来，利用键盘输入，动态开辟节点存储空间，将00008 赵四 88信息存在一个节点中，并插入到学号是‘00005’和‘00006’之间；\n（4）再接下来，利用直接插入排序，对链表继续升序排序；\n（5）将完整的线性链表信息从头到尾依次存储到磁盘某个路径下的“score.txt”文件中，存储格式和“stuinfo.txt”文件相同。\n（6）最终将“score.txt”的内容复制粘贴到实验报告的实验结果中。", "Tag": "算法分析"}
{"Answer": "\n        Dim divIn() As Double = {0, 5, 10, 15, 20}\n        Dim divOut() As Double = {0, 0.1, 0.4, 0.7, 0.8}\n        Dim x As Double = 7\n        Dim y As Double = 0\n        For i As Integer = 0 To divIn.Length - 2\n            If x > divIn(i) And x <= divIn(i + 1) Then\n                y = (divOut(i + 1) - divOut(i)) / (divIn(i + 1) - divIn(i)) * (x - divIn(i)) + divOut(i)\n            End If\n        Next\n        MessageBox.Show(y)\n", "Konwledge_Point": "线性规划和规约", "Question": "VB.NET如何进行线性插值计算？\nVB.NET如何进行线性插值计算？\n比如说一组数据：X分别是0  5  10  15  20；相对应Y为0  0.1  0.4  0.7  0.8。计算X=7时，Y是多少？", "Tag": "算法分析"}
{"Answer": "#include <stdio.h>\n\ndouble x(int n)\n{\n    return n == 0 ? 1.0 : 0.0;\n}\n\ndouble y(int n)\n{\n    if (n < 0)\n        return 0.0;\n    return 2.0 * x(n - 1) + 3.0 / 4.0 * y(n - 1) - 1.0 / 8.0 * y(n - 2);\n}\n\nint main()\n{\n    printf(\"%.5lf\\n\", y(4));\n    return 0;\n}\n\n$ gcc -Wall main.c\n$ ./a.out\n0.46875\n", "Konwledge_Point": "线性规划和规约", "Question": "线性常系数差分方程相关解答。\n考虑线性常系数差分方程如图所示。\n\n\n\n\n求y [4]，当条件如下图时。\n请给出5个有效数字。", "Tag": "算法分析"}
{"Answer": "android:layout_alignParentLeft=\"true\"\r\n android:layout_alignParentRight=\"true\"\r\n\r\n在你的两个`TextView`标签里分别加上这两个属性就可以了", "Konwledge_Point": "线性规划和规约", "Question": "在一个按钮上方左右排放 textview\nrelative layout:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n我用了上面的代码没有达到下面的效果：\n\n\n\ntv1--------------tv2\n\n|------Button------|\n\n\n\n想让textview1 在按钮的左上角， textview2 在按钮的右上角，如何实现呢？", "Tag": "算法分析"}
{"Answer": "\nThe code in the question is unsafe because it reads a variable in one goroutine and modifies the variable in another goroutine without synchronization.\nHere's one way to make the code safe:\ntype Obj struct {\n   mu sync.Mutex // add mutex\n   ... // other fields as before\n}\n\nfunc (o *Obj) Reader() {\n    o.mu.Lock()\n    data := o.data\n    o.mu.Unlock()\n    for i, value := range data {\n      log.Printf(\"got data[%v] = %v\", i, value)\n    }\n}\n\nfunc (o *Obj) Writer() {\n     o.mu.Lock()\n     o.data = append(o.data, 1234)\n     o.mu.Unlock()\n}\n\nIt's safe for Reader to range over the local slice variable data because the Writer does not modify the local variable data or the backing array visible through the local variable data.\n", "Konwledge_Point": "线性规划和规约", "Question": "将append（）附加到另一个线程正在读取的切片上是否安全？\n\n\n\nLet's say I have many goroutines doing something like this:\n\n\n\nfunc (o *Obj) Reader() {\n  data := o.data;\n  for i, value := range data {\n    log.Printf(\"got data[%v] = %v\", i, value)\n  }\n}\n\n\n\n\nAnd one doing this:\n\n\n\nfunc (o *Obj) Writer() {\n    o.data = append(o.data, 1234)\n}\n\n\n\n\nIf \ndata := o.data\n means the internal structure of the slice is copied, this looks like it could be safe, because I'm never modifying anything in the accessible range of the copy. I'm either setting one element outside of the range and increasing the length, or allocating a completely new pointer, but the reader would be operating on the original one.\n\n\n\nAre my assumptions correct and this is safe to do?\n\n\n\nI'm aware that slices are not meant to be \"thread-safe\" in general, the question is more about how much does \nslice1 := slice2\n actually copy.\n\n    ", "Tag": "算法分析"}
{"Answer": "你好同学，直接写出系数矩阵、然后用反除：\nA = [4,0,2,3;  0,3,2,3; 2,0,0,1; 0,-2,1,3];%系数矩阵\nb = [9;8;10;7];\nx = A\\b\n\n结果：\n\nx =\n\n    1.7174\n    1.9565\n   -8.7826\n    6.5652\n\n\n如有帮助，还望给个采纳哟", "Konwledge_Point": "线性规划和规约", "Question": "如何用matlab编码下面的线性方程组\n求下列线性方程组的数值解     \n\n\n4x1 +2x3 +3x4 = 9        \n\n\n3x2 +2x3 + 3x4 = 8        \n\n\n2x1 + x4 = 10        \n\n\nx3 -2x2 + 3x4 =7", "Tag": "算法分析"}
{"Answer": "你好，同学，之前已经回答过了，都是类似的办法\n如何用matlab编码下面的线性方程组-编程语言-CSDN问答\nCSDN问答为您找到如何用matlab编码下面的线性方程组相关问题答案，如果想了解更多关于如何用matlab编码下面的线性方程组 matlab 技术问题等相关问答，请访问CSDN问答。\n\n\n\nhttps://ask.csdn.net/questions/7553073?spm=1005.2025.3001.5141\n\n", "Konwledge_Point": "线性规划和规约", "Question": "如何用matlab编码这个线性方程组\n求下列线性方程组的数值解         \n\n\n4x1 +2x3 +3x4 = 9        \n\n\n3x2 +2x3 + 3x4 = 8        \n\n\n2x1 + x4 = 10        \n\n\nx3 -2x2 + 3x4 =7", "Tag": "算法分析"}
{"Answer": "CA,B,D结束时，i值都为10；C结束时，i值为11或者说A，B，D都是循环结束后i才加1C是循环开始时i就加1了比如代码块是：for(int i=0;i++<10;){    printf(\"%d\",i);}A,B,D输出是0到9而C输出是1到10", "Konwledge_Point": "线性规划和规约", "Question": "以下哪个循环和其他三条循环不等价（假设循环体都是一样的）？\n以下哪个循环和其他三条循环不等价（假设循环体都是一样的）？(请问c怎么理解)\nA.for ( i=0; i<10; i++ ) {...}\nB.for ( i=0; i<10; ++i ) {...}\nC.for ( i=0; i++<10;  ) {...}\nD.for ( i=0; i<=9; i++ ) {...}\n请问c怎么理解", "Tag": "算法分析"}
{"Answer": "这篇文章讲的很详细，请看：多元线性回归解决机器学习问题的一般方法", "Konwledge_Point": "线性规划和规约", "Question": "机器学习一元线性回归错误\n当我再用一元线性回归画散点图的时候报了这个错\n\n\nimport\n pandas \nas\n pd\n\nimport\n matplotlib.pyplot \nas\n plt\ndf=pd.read_csv(\n'chage.csv'\n)\ndf[\n'Deaths'\n]=df[\n'Deaths'\n].\nstr\n.replace(\n','\n,\n''\n)\ndf[\n'Total'\n]=df[\n'Total'\n].\nstr\n.replace(\n','\n,\n''\n)\n\nfrom\n sklearn \nimport\n linear_model\ndf[\n'Deaths'\n].astype(\nfloat\n) \ndf[\n'Total'\n].astype(\nfloat\n) \n\n# 设定x和y的值\n\nx = df[[\n'Deaths'\n]] \ny = df[[\n'Total'\n]]\nregr=linear_model.LinearRegression()  \n\n# 拟合fit()\n\nregr.fit(x,y)\n\nprint\n(regr.coef_)    \n# 权重\n\n\nprint\n(regr.intercept_)\n\nimport\n matplotlib.pyplot \nas\n plt\nplt.rcParams[\n'font.sans-serif'\n] = [\n'SimHei'\n] \nplt.rcParams[\n'axes.unicode_minus'\n] = \nFalse\n\nplt.xlabel(\n'Deaths'\n)\nplt.ylabel(\n'Total'\n)\n\n# 画出原始点:散点图scatter\n\nplt.scatter(x, y, color=\n'black'\n)\n\n# 画出预测点，预测点的宽度为1，颜色为红色\n\nplt.scatter(x, regr.predict(x), color=\n'red'\n,linewidth=\n1\n)\nplt.legend([\n'原始值'\n,\n'预测值'\n], loc = \n2\n)\nplt.show()\n\n\n\n\n这是我的数据集", "Tag": "算法分析"}
{"Answer": "这也不一定。例如：（1）结果与每个因素的相关性都不大，但加权后相关性仍然很大，例如 y =0.1x1 + ...0.1x10（2）结果与每个因素独立的相关性都不大，但受气综合影响的相关性很大，例如 y=x1*...*x10以上两种情况，模型预测可以达到 100%，但 y 与每个 xi 的相关性都很小。", "Konwledge_Point": "线性规划和规约", "Question": "2个变量的相关程度很若，这样做出来的回归模型，预测程度也很弱吗\n最近做了一个用Python建立回归模型的练习。想通过各个变量与销售额的相关性，来做主要影响变量和销售额的相关模型。\n\n\n但是，在计算相关性后，发现每个变量与销售额的相关性都小于0.1，相关性很弱。\n\n\nQ：这种弱相关程度的情况下，去做这些变量与销售额的回归模型，是有意义的吗？模型的预测性应该很不准吧。", "Tag": "算法分析"}
{"Answer": "总结下两位大佬的答案：\n1. 要把表转为字符串，用.join 更方便，因为它在转换时会自动把表的 []去掉\n2.str也可以转换表，只不过会保留[]\n3.俩位大佬答的都很好，小弟十分感谢！！！不知道该采纳哪位了。。。", "Konwledge_Point": "线性规划和规约", "Question": "python新手问题，关于字符串\n\nb=['123','32','980']\nb=str(b)\nprint(type(b))\nb.rstrip('[')\nprint(b)\n\n\n\n我把表b转为了字符串，type（b）返回的也是str，可是用rstrip去除不了 符号‘[’\n\n\n\n求解释下。。。。", "Tag": "算法分析"}
{"Answer": "用日期group by就可以了，\nSelect date, count(*) group by date\n\n", "Konwledge_Point": "线性规划和规约", "Question": "关于mybatis查询线性图表数据的问题\n就是要显示一个线性图表，该表显示当前月份每一天递增的数据量，比如用户数量。比如一号是10人，二号是三十人，三号是四十人这样，请问我在mybatis要怎么查呢？应该不能在事务层里去把当前月份的每一天遍历出来然后再一个一个去查吧，感觉那样太慢了，有没有朋友有什么办法，多谢\n\n", "Tag": "算法分析"}
{"Answer": "w = model.coef_ \r\nb = model.intercept_ #得到bias值\r\nprint(len(w))  # 输出参数数目\r\nprint([round(i,5) for i in w])  #输出w列表，保留5位小数\r\nprint(b)                       #输出bias\r\n因此你只需要调用评价函数指针的的coef_和intercept_方法", "Konwledge_Point": "线性规划和规约", "Question": "python 利用sklearn库做了线性回归，怎么得出线性表达式的各个参数\nfrom skearn.linear_model import LinearRegression()\n\nx=[[6,2],[8,1],[10,0],[14,2],[18,0]]\n\ny=[[11],[8.5],[15],[18],[11]]\n\nmodel=LinearRegression()\n\nmodel.fit(x,y)\n\n#如何求y=a+bx1+cx2中的a,b,c的值", "Tag": "算法分析"}
{"Answer": "看看这个http://www.sparkit.cn/2018/04/11/python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0sklearn%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B%EF%BC%88%E4%B8%8A%EF%BC%89/", "Konwledge_Point": "线性规划和规约", "Question": "python sklearn 线性回归\nimport ztop_ai as zai;\n\n\n\nmx = zai.mx_line(x_train.values.y_train.values)\n\n\n\n谁知道这句话是什么意思，建模又是什么意思？具体点。。", "Tag": "算法分析"}
{"Answer": "http://blog.chinaunix.net/uid-22263887-id-1778908.html", "Konwledge_Point": "线性规划和规约", "Question": "Painter                          \nThe local toy store sells small fingerpainting kits with between three and twelve 50ml bottles of paint, each a different color. The paints are bright and fun to work with, and have the useful property that if you mix X ml each of any three different colors, you get X ml of gray. (The paints are thick and \"airy\", almost like cake frosting, and when you mix them together the volume doesn't increase, the paint just gets more dense.) None of the individual colors are gray; the only way to get gray is by mixing exactly three distinct colors, but it doesn't matter which three. Your friend Emily is an elementary school teacher and every Friday she does a fingerpainting project with her class. Given the number of different colors needed, the amount of each color, and the amount of gray, your job is to calculate the number of kits needed for her class.\n\nInput\n\n\n\nThe input consists of one or more test cases, followed by a line containing only zero that signals the end of the input. Each test case consists of a single line of five or more integers, which are separated by a space. The first integer N is the number of different colors (3 <= N <= 12). Following that are N different nonnegative integers, each at most 1,000, that specify the amount of each color needed. Last is a nonnegative integer G <= 1,000 that specifies the amount of gray needed. All quantities are in ml. \n\nOutput\n\n\n\nFor each test case, output the smallest number of fingerpainting kits sufficient to provide the required amounts of all the colors and gray. Note that all grays are considered equal, so in order to find the minimum number of kits for a test case you may need to make grays using different combinations of three distinct colors.\n\nSample Input\n\n\n\n3 40 95 21 0\n\n7 25 60 400 250 0 60 0 500\n\n4 90 95 75 95 10\n\n4 90 95 75 95 11\n\n5 0 0 0 0 0 333\n\n0\n\nSample Output\n\n\n\n2\n\n8\n\n2\n\n3\n\n4", "Tag": "算法分析"}
{"Answer": "![图片说明](https://img-ask.csdn.net/upload/201809/04/1536025650_882146.jpg)", "Konwledge_Point": "线性规划和规约", "Question": "最小二乘法 求导，公式不太理解\n这个公式推导过程不理解，求指导。\n\n\n", "Tag": "算法分析"}
{"Answer": "这是维度匹配问题，GPOPS的cost函数中返回值是向量，注意返回值的维度。建议你的程序在GPOPS提供的范例基础上去修改。", "Konwledge_Point": "线性规划和规约", "Question": "如何解决使用GPOPS出现的这一问题？\n根据列车的动力学模型使用GPOPS编写的列车运动速度优化，运行时出现这个问题，卡了我很久，甚是困扰\n\n\n\n\n\n\n ", "Tag": "算法分析"}
{"Answer": "线性混合效应模型是一种混合模型，通常用于分析不同级别上的观察值之间的关系。在你描述的情况中，两组数据都只有一个主效应显著，且为连续变量，这意味着这两组数据的反应时和错误率与这个主效应有关。\n做emmeans分析是可以的，这可以帮助我们看到这个主效应对不同级别的观察值的影响。结果中的emmean表示对于不同级别的观察值的平均效应，SE表示标准误差，df表示自由度，lower.CL和upper.CL分别表示置信区间的下限和上限。\n如果只有主效应显著，那么结果表明主效应是显著的，对于不同级别的观察值都有显著的影响。\n解释结果可以使用可视化手段，如绘制主效应的线性回归曲线或者使用Tukey的分组比较可视化不同级别观察值之间的差异。\n总之，在这种情况下，主效应是显著的，对于不同级别的观察值都有影响，使用emmeans分析和可视化工具可以帮助我们更好地理解结果。", "Konwledge_Point": "线性规划和规约", "Question": "R 线性混合效应模型，只有主效应显著，且为连续变量\n两组数据分别作了线性混合效应（反应时），广义线性混合效应（错误率），都是只有一个主效应显著，且为连续变量。\n做emmeans看事后比较，输出的结果是\n（主效应下） 2.02e-18， emmean, SE, df, lower.CL, upper.CL\n请问是这样做吗？如果是这样做这样的结果该如何解读呢？有没有可视化的手段？", "Tag": "算法分析"}
{"Answer": "\ndef student():\n    students = []\n    for i in range(12):\n        lis=[]\n        info = input(\"请输入学号,姓名,三门成绩，用逗号隔开：\")\n        data = info.split(',')\n        lis.append((float(data[2])+float(data[3])+float(data[4]))/3)\n        students.append(data+lis)\n    print(students[5])\nstudent()\n", "Konwledge_Point": "线性规划和规约", "Question": "有关python有12个学生，每个学生的数据包括学号，姓名，三门课程的成绩及平均分。输入这12个学生的数据，然后计算平均分，并输出第6号学生\ndef student():\n    students = []\n    for i in range(12):\n        info = input(\"请输入学号 姓名 三门成绩\")\n         data = info.strip().split()\n        score = round(eval('%s+%s+%s'%(2,3,4))/3, 2)\n       data .append(score)\n        students.append(data)\n    print(students[5])\n\n\n运行没有错误，但就是什么都不会有显", "Tag": "算法分析"}
{"Answer": "你这个 可以 是四个统计图 。点击时切换一下就行。\n也可以是一个统计图 ，点击 时 绑定不同 的options配置也行", "Konwledge_Point": "线性规划和规约", "Question": "有没有哪位做过前端线性图表\n就是在vue中做线性图表，可以像下图一样，点击不同的时间，就会改变不同的图表状态\n\n\n\n\n比如点击今天跟本周跟本月都能改变不同的状态，我在网上看到的用echarts做的,如下图\n\n\n只能在同一个状态下，然后挤一块，处理不了不同的时间状态，有哪位做过的帮一下，万分感谢", "Tag": "算法分析"}
{"Answer": "你好同学，python里面的numpy在生成2维矩阵的时候不能只写一个维度的大小值，另外一个维度也要写\nimport numpy\na = numpy.random.rand(50,50)\nb = numpy.linalg.det(a)\n\n这样就有结果了，比如我这里有个随机结果\n", "Konwledge_Point": "线性规划和规约", "Question": "Matlab ipython线性代数\n\n\n第32题怎么用ipython做？\n我写的是\na = numpy.random.rand(50)\nb = numpy.linalg.det(a)\n但是报错1-dimensional array given. Array must be at least two-dimensional", "Tag": "算法分析"}
{"Answer": "这个很简单，比如说语音识别，需要很低的采样率就可以了，高了增加了数据量，毫无用处。\r\n采样你可以拿图片的分辨率类比。\r\n比如说照相机拍出来的照片是4000x3000，12Mp的分辨率。\r\n你现在要上传到csdn，说图片太大了，怎么办？你得把图片转换成800x600的，这个降低（其实是改变，也可以是插值升高）分辨率的过程，就很类似重采样。", "Konwledge_Point": "线性规划和规约", "Question": "音频为什么要重采样？\n网上关于音频采样与重采样的文章很少，学习时遇到音频重采样，想知道为什么要重采样？搜了好久，只得到一句：改变采样率，适应不同的情景，有大佬可以帮忙一下吗？\n\n链接也行。", "Tag": "算法分析"}
{"Answer": "你这是想让改错还是补全还是重写？", "Konwledge_Point": "线性规划和规约", "Question": "数据结构，链表问题，如何将代码补充完整\n完成如下任务。程序一，用上述基本方法，实现如下要求，在 main 函数中，对线性表操 作时，只能使用 b）中定义的函数，不可以直接对线性表进行操作： 1）初始化线性表\n2）从键盘依次读入 10 个字符并保存到线性表中； 3）将线性表的第 6 个存储位置的数据元素删除； 4）将线性表的第 4 个存储位置之前插入一个数据元素，其值为字符 # ； 5）将线性表的所有所有数据元素打印输出； 6）将线性表销毁。\n 程序二，修改上述链式存储的线性表的数据元素类型定义和基本操作函 数实现，将线性表修改为一个学生信息表，每个数据元素至少需要包含：\n姓名、学号、年龄，实现如下要求：\n\n\n初始化线性表\n实现一个线性表的插入函数，从键盘输入至少 5 名同学的信息并加 入到线性表中，要求选择时间复杂度为 O(1)的算法来实现。（注：输 入学生信息时，可以先要求输入学生信息数量；再依次输入每个学 生信息。）\n实现一个打印输出函数，在全部同学的信息从键盘输入完毕后，将\n线性表中的同学信息按输入顺序在屏幕打印输出。\n使用 ListDelete 函数将存储了第二个输入的学生信息的结点删除\n实现一个结点删除函数，将线性表中年龄超过某个年龄值（从键盘\n输入一个年龄）的所有节点都删除；\n按输入顺序打印输出剩余结点。\n销毁这个线性表。\n一二为两个不同程序，代码如有错误请进行修改\n#include\n#include\n#define MAXSIZE 100\ntypedef int ElemType;\ntypedef struct LNode\n{\n ElemType data; \n\n\nstruct LNode *next;\n}LNode,*LinkList;\nbool InitList(LinkList& L);\nbool DestroyList(LinkList& L);\nint  ListLength(LinkList L);\nbool GetElem(LinkList L, int i, ElemType &e);\nbool ListInsert(LinkList &L, int i, ElemType e);\nbool ListDelete(LinkList &L, int i,ElemType e);\nvoid ListPrint(LinkList L);\nint main()\n{\n\n\n}\n\n\nbool InitList(LinkList &L)\n{\nL=new LNode;\nL->next=NULL;\nreturn true;\n}\nbool DestroyList(LinkList& L)\n{        if(!L) return 0;\n    LNode *p= L;\n    while (p) {\n        LNode * q= p->next;\n        free(p);\n        p=q;\n    }\n    L=NULL;\n}\nint  ListLength(LinkList L)\n{\n    if(!L) return 0;\n          int len=0;\n          LNode *p= L->next;\n          while (p)  {\n              ++len;\n              p= p->next;\n          }\n          return len;\n    }\nbool GetElem(LinkList L, int i, ElemType &e)\n{\n    if(!L) return 0;\n        LNode *p= L->next;\n        int j=1;\n          while ( p && jnext;  ++j;\n        }\n        if ( !p || j>i ) return 0;\n        e= p->data;\n        return true;\n    }\n    bool ListInsert(LinkList &L, int i, ElemType e)\n    {\n        if(!L) return 0;\n            LNode *p=L;   int  j=0;\n            while (p  &&  jnext;    j++;\n            }\n            if ( !p || j>i-1 )  return 0 ;\n            LNode * s = (LNode *)malloc(sizeof(LNode));\n            if(!s) return 0;\n            s->data= e ;\n\n\n        \ns\n->\nnext\n= p->\nnext\n;    p->\nnext= s;\n    \n        return \ntrue\n;\n    \n}\n\n\n\nbool ListDelete(LinkList &L, int i,ElemType e)\n{\n    if(!L) return 0;\n\n\n    LNode *p = L;\n    \nif\n(!p->\nnext) \n        return \n0\n;     \n    LN\node\n * q= p->\nnext;\n    \np\n->\nnext\n= q->\nnext;\n    \ne\n= q->\ndata\n;    \n    free(q);\n    return \ntrue\n;\n\n\n\n}\n    void ListPrint(LinkList L)\n    {\n    LNode *temp=L;\n    while(temp->next)\n        {temp=temp->next;\n        printf(\"%c\",temp->data);\n         }\n    }\n\n    ", "Tag": "算法分析"}
{"Answer": "你好同学：（1）inv(A)*B指的是先对矩阵A求了逆矩阵，然后这个逆矩阵乘以B，得到满足方程A*X=B的解X，矩阵 A 和 B 必须具有相同的行数，一般是：\nX = inv(A)*B; % 方程A*X=B，求X\n\n（2）B/A意思是对线性方程组 X*A = B 求解 X，矩阵 A 和 B 必须具有相同的列数，一般是\nX = B/A; % 方程X*A=B，求X \n\n有帮助还望题主给个采纳支持答主，有任何后续疑问都可以继续追问哦", "Konwledge_Point": "线性规划和规约", "Question": "MATLAB中inv(A)*B与B/A\n在使用inv(A)*B时，matlab提示使用B/A进行替换，请问二者有何具体差别，产生差别的原因又是什么？", "Tag": "算法分析"}
{"Answer": "简单来说施密特正交化和QR分解都是针对矩阵的正交变换（orthogonal transformation）方法。\n\n施密特正交化（Schmidt orthogonalization）是一种将非正交向量组转化为正交向量组的方法，可以使用Gram-Schmidt正交化算法实现。这种方法的优点是能够保证转换后的向量组正交，但缺点是算法较为复杂，而且在运算过程中有可能出现数值精度问题。\nQR分解（QR decomposition）是一种将矩阵分解为正交矩阵和上三角矩阵的方法。QR分解的优点是算法相对简单，而且可以利用Q矩阵的正交性质来解决线性方程组，或者使用R矩阵的上三角结构来做矩阵运算。\n举个例子，在统计学中，需要对数据进行降维处理来简化数据结构，其中一种方法就是主成分分析（PCA）。在PCA中，使用QR分解来求解协方差矩阵的特征值和特征向量，来找出数据主要的方向。", "Konwledge_Point": "线性规划和规约", "Question": "关于线性代数里施密特正交化和QR分解的疑问\n学习线代的时候，一直搞不明白矩阵施密特正交化和QR分解的动机是什么？\n这样做有什么好处呢？在百度上搜过，都说简便矩阵运算，但是没有具体的例子，我还是不明白为什么。\n希望解答能结合矩阵和现实中的一个例子，这样我好理解。", "Tag": "算法分析"}
{"Answer": "3 组权值，分别是 Y1与非Y1、Y2与非Y2、Y3与非Y3 的分割平面的系数", "Konwledge_Point": "线性规划和规约", "Question": "线性可分三分类支持向量机如何得到每个自变量的权重\n问题遇到的现象和发生背景\n\n\n线性可分三分类支持向量机会产生三个分类平面吗？如果有三个分类平面的话每个自变量都会有三个系数，那么该如何求每个自变量的权重？\n\n\n问题相关代码，请勿粘贴截图\n\n\n运行结果及报错内容\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果", "Tag": "算法分析"}
{"Answer": "不是所有，而是只遍历到index\r\n也就是取得LinkedList的第index元素。和数组不同，链表只能遍历获取，index如果比size的一半大，那么从后往前找，否则从前往后找。", "Konwledge_Point": "线性规划和规约", "Question": "LinkedList随机添加元素底层代码看不懂，大神指点下？\nNode node(int index) {\n\n        // assert isElementIndex(index);\n\n\n\n    if (index < (size >> 1)) {\n        Node x = first;\n        for (int i = 0; i < index; i++)\n            x = x.next;\n        return x;\n    } else {\n        Node x = last;\n        for (int i = size - 1; i > index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n\n    没看懂这里的for循环，为什么把所有的都循环赋值一遍，那最后不就返回最后一个的引用吗？\n", "Tag": "算法分析"}
{"Answer": "class Queue:\n    def __init__(self, cap=10):  # 初始化\n        self.data = []\n        self.front = 0\n        self.rare = 0\n\n    def empty(self):  # 判空\n        self.front = 0\n        self.rare = 0\n\n    def __len__(self):  # 求长度\n        return self.rare - self.front\n\n    def append(self, item):  # 入队\n        self.data.append(item)\n        self.rare += 1\n\n    def reserve(self):  # 出队\n        if self.empty():\n            return None\n        self.front += 1\n        return self.data[self.front - 1]\n\npython好象没有内置的定长数组这种数据结构, 用变长的列表很容易实现队列, 根本不需要front和rare这样的下标变量进行辅助.", "Konwledge_Point": "线性规划和规约", "Question": "用Python实现，采用线性数组实现队列，并利用front和rear下标分别指示队头和对尾位置，当rear下标到达数组尾部时，将队列中的所有元素平移到数组的最前端。\n用Python实现，采用线性数组实现队列，并利用front和rear下标分别指示队头和对尾位置，当rear下标到达数组尾部时，将队列中的所有元素平移到数组的最前端。设计此队列类，并实现主要算法。\n\n\nclass CircularQue:\n\n\ndef\n \n__init__\n(\nself\n,cap=\n10\n)\n: \n#初始化\n\n\n    （请完成）\n\n\ndef\n \nempty\n(\nself\n)\n: \n#判空\n\n\n    （请完成）\n\n\ndef\n \n__len__\n(\nself\n)\n: \n#求长度\n\n\n    （请完成）\n\n\ndef\n \nappend\n(\nself\n,item)\n \n#入队\n\n\n    （请完成）\n\n\ndef\n \nreserve\n(\nself\n)\n:\n#出队\n\n\n    （请完成）\n", "Tag": "算法分析"}
{"Answer": "题主的代码修改如下，供参考：\n#include<stdio.h> \nint main()\n{\n    int n, m, b[100000], a, i;\n    scanf(\"%d %d\", &n, &m);\n    i = n;\n    while (i--) {  //n 需要保持不变，后面还要用到\n        scanf(\"%d\", &b[i]);\n    }\n    while (m--) {\n        scanf(\"%d\", &a);  //scanf(\"%d\",a); a 前面缺了 ‘&’ 符\n        printf(m != 0 ? \"%d\\n\" : \"%d\", b[n - a]); //修改\n    }\n    return 0;\n}\n\n", "Konwledge_Point": "线性规划和规约", "Question": "线性结构询问学号问题\n问题遇到的现象和发生背景 题目描述\n\n\n有 n(n \\le 2 \\times 10^6)n(n≤2×10\n6\n ) 名同学陆陆续续进入教室。我们知道每名同学的学号（在 11 到 10^910\n9\n  之间），按进教室的顺序给出。上课了，Teacher想知道第 ii 个进入教室的同学的学号是什么（最先进入教室的同学 i=1i=1），询问次数不超过 10^510\n5\n  次。\n\n\n输入格式\n第一行 22 个整数 nn 和 mm，表示学生个数和询问次数。\n\n\n第二行 nn 个整数，表示按顺序进入教室的学号。\n\n\n第三行 mm 个整数，表示询问第几个进入教室的同学。\n\n\n输出格式\n输出 mm 个整数表示答案，用换行隔开。\n\n\n输入输出样例\n输入 #1复制\n10 3\n1 9 2 60 8 17 11 4 5 14\n1 5 9\n输出 #1复制\n1\n8\n5\n\n\n用代码块功能插入代码，请勿粘贴截图\n\n\n#\ninclude\n\n \n\n\nint\n \nmain\n()\n\n\n{\n    \nint\n n,m;\n    \nint\n a;\n    \nscanf\n(\n\"%d %d\"\n,&n,&m);\n    \ndouble\n b[n];\n    \nwhile\n(n--){\n        \nscanf\n(\n\"%lf\"\n,&b[n]);\n    }\n    \nwhile\n(m--){\nscanf\n(\n\"%d\"\n,a);\n    \nprintf\n(m!=\n0\n?\n\"%.0lf\\n\"\n:\n\"%.0lf\"\n,b[n-a+\n1\n]);\n    }\n    \nreturn\n \n0\n;\n}\n\n\n\n\n运行结果及报错内容 输入样例但是没有输出结果\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果 不知道哪里出错了 请求指导", "Tag": "算法分析"}
{"Answer": "```\r\n #include\r\n#include\r\n\r\ntypedef struct LNode {\r\n\tint data;\r\n\tstruct LNode *next;\r\n}*LinkList;\r\n\r\nLinkList Creat_List(int n) {\r\n\tLinkList head,p,q;\r\n    head = p = (LinkList)malloc(sizeof(LNode));\r\n    for(int i = 1; i <= n; i++) {\r\n\t\tq = (LinkList)malloc(sizeof(LNode));\r\n\t\tq->data = i;\r\n\t\tp->next = q;\r\n\t\tp = q;\r\n\t}\r\n\tp->next = NULL;\r\n\treturn head;\r\n}\r\n\r\nvoid Delete_evenLNode(LinkList head) { // 删除偶数位结点\r\n    LinkList q,p = head;\r\n\tint i;\r\n    for(i = 1; p->next; ++i) {\r\n\t\tif(i % 2 == 0) {\r\n\t\t\tq = p->next; \r\n\t\t\tp->next = q->next;\r\n\t\t\tfree(q);\r\n\t\t}\r\n\t\telse p = p->next;\r\n\t}\r\n}\r\n\r\nvoid Print_List(LinkList head) {\r\n\tLinkList p = head->next;\r\n\twhile(p != NULL) {\r\n\t\tprintf(\"%d \",p->data);\r\n\t\tp = p->next;\r\n\t}\r\n\tprintf(\"\\n\");\r\n}\r\n\r\nvoid main () {\r\n    LinkList head = Creat_List(16);\r\n\tPrint_List(head);\r\n\tDelete_evenLNode(head);\r\n\tprintf(\"删除偶数结点后 :\\n\");\r\n\tPrint_List(head);\r\n}\r\n```", "Konwledge_Point": "线性规划和规约", "Question": "单链表做线性表的存储\n以带头结点的单链表做线性表的存储表示，编写算法删除表中的偶数序号结点，使（a1，a2,a3,a4,a5...）变成（a1,a3,a5...）", "Tag": "算法分析"}
{"Answer": "该测试执行的回归，error是表明无法执行回归，因为回归矩阵是不可逆的。由于你的模型只有一个回归量，加上常数项，通过使用测试函数参数的默认None值skip=是不行的，所以，正如消息指示的那样，你需要指定足够大的skip=参数值（即，用于测试的初始模型的观测值数量）以确保回归矩阵有足够的秩（它需要至少为与矩阵中的列数一样大）。\nhttps://stackoverflow.com/questions/74084265/statsmodels-linear-harveu-collier-test-valueerror", "Konwledge_Point": "线性规划和规约", "Question": "linear_harvey_collier - 检验线性回归假设\nlinear_harvey_collier检验回归模型是否线性模型时报错\n\n\n\n\nQGDP\n = df[\n'QUARTERLY REAL GDP'\n]\n\nUNRATE\n = df[\n'UNRATE(%)'\n]\n\nols_1\n = smf.ols(formula=\n'QGDP ~ UNRATE'\n, data = df)\n\nols_fit\n = ols_1.fit()\n\ntest\n = sms.linear_harvey_collier(ols_fit)\n\n\n\n\nValueError: \"The initial regressor matrix, x[:skip], issingular. You must use a value of skip large enough to ensure that the first OLS estimator is well-defined.\n\n\n无法理解报错原因，网上也没找到相关资料", "Tag": "算法分析"}
{"Answer": "如果v0和[s]是标量，上面的公式可写为f(Km, Vmax)=0的形式。假定km在区间[a,b]内方程有解，可在该区间内均匀取n点，计算一元方程得到n个Vmax的解。下面的代码，演示了非线性方程的解法。\nfrom scipy import optimize\ndef f(x):\n    return 3/(x*5) + 1/x - 1/7\n\nresult = optimize.root_scalar(f, bracket=[-2,2])\nresult.root\n-1.2566741077549764e-12\n", "Konwledge_Point": "线性规划和规约", "Question": "python自定义非线性方程\n请问我想利用python拟合上述公式求解Vmax和Km,其中V0，[S]是一些已知的参数，请问应该怎么用python来实现呢，谢谢。", "Tag": "算法分析"}
{"Answer": "首先怀疑过拟合, 减少迭代次数, 像这种非常简单的数据拟合, 完全不需要200这么大的周期, 一般30-50个足够", "Konwledge_Point": "线性规划和规约", "Question": "用BP神经网络进行预测，loss比较小，但预测值跟实际值相差较大，怎么办\n这是数据，三个输入一个输出。\n\n\n这是用keras写的模型\n\n\n这是训练得到的loss图", "Tag": "算法分析"}
{"Answer": "（1）问题的matlab解决代码\ncoef_vec=[11,9,10,11,12,8].';  %设置目标函数的系数向量\nA=[0.4,1.1,1,0,0,0;...   %将线性不等式约束优化转换为A*x<=b的形式\n    0,0,0,0.5,1.1,1.3];\nb=[800,901].';\nAeq=[6,0,0,1,0,0;... %将线性等式优化转换为Aeq*x=beq的形式\n    0,5,0,0,3.5,0;...\n    0,0,4.2,0,0,5.1];\nbeq=[410,421,511].';\nLB=[0,0,0,-inf,-inf,-inf]';  %将部分非负约束转换为LB<=x<=UB的形式\nUB=inf*ones(6,1);\n[x,z]=linprog(coef_vec,A,b,Aeq,beq,LB,UB); %调用linprog函数求解线性规划问题\nformat long;  %打开长有效数字显示模式显示结果\nx=x.'   %将列向量转置为行向量便于显示\nz=z.'\nformat short; %关闭长有效数字显示模式\n\n（2）代码运行结果截图", "Konwledge_Point": "线性规划和规约", "Question": "各位能帮我看下这个问题吗\n还是初学者刚学MATLAB和Python，对线性规划问题也不是很熟，希望大家帮帮我", "Tag": "算法分析"}
{"Answer": "其中一个层（第 65 层）中只有一个 PSU（主要抽样单位），这导致调查设计出现问题。你参考一下这个：\n# Filter out Stratum 65\nd_rec_filtered <- d_rec[d_rec$sdmvstra != 65, ]\n\n# Create survey design object with filtered data\nnhc <- svydesign(data=d_rec_filtered, ids=~sdmvpsu, strata = ~sdmvstra, \n                 weights=~nhs_wt, nest = TRUE)\n\n# Fit the model with the filtered survey design\nfit1 <- svyglm(rec.n~sex+age+eth+edu+inc+hbp+dm+htc,\n               design = nhc,family = quasibinomial())\n\n\n\n从 svyglm 函数调用中删除了数据参数，因为数据已经在调查设计对象中指定。", "Konwledge_Point": "线性规划和规约", "Question": "【R语言】加权线性回归模型，PSU问题\n请教各位R语言好手，请问在做加权线性回归模型的时候出现以下错误要如何解决呢？\n\n\nd_rec$\nrec\n.n <- as.numeric(\nwith\n(d_rec, ifelse(\nrec\n == \n\"aaa\"\n, \n1\n, \n0\n)))\nnhc <- svydesign(\ndata=d_rec,\n \nids=~sdmvpsu,\n \nstrata\n = ~sdmvstra, \n                 \nweights=~nhs_wt,\n \nnest\n = TRUE)\nfit1 <- svyglm(\nrec\n.n~sex+age+eth+edu+inc+hbp+dm+htc,\n               \ndesign\n = nhc,\nfamily\n = quasibinomial(),\ndata\n = d_rec)\n\nError \nin\n onestrat(x[index, , \ndrop\n = FALSE], clusters[index], nPSU[index][\n1\n],  : \n  Stratum (\n65\n) has only one PSU at stage \n1\n\n\n\n\n昨晚同样代码就可以运行，今天跑就不行了[捂脸]", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/chenxun_2010/article/details/48201181", "Konwledge_Point": "线性规划和规约", "Question": "递归 算法 最大子数组\n虽然写的非常差但还是我这个小白自己亲手写出来的，一边翻书一边谷歌..... 花了好多小时，虽然很罗嗦而且希望大家能帮我找一下我的find_maximum_subarry的错误，其余两个函数我都试过了应该是对的\n\n\n\n#include \n\n\n\ntypedef struct all_of_sum\n\n    {\n\n        int aa;\n\n        int bb;\n\n        int cc;\n\n    }all_sum;\n\nall_sum all;\n\n\n\nint max(int one, int two, int three)\n\n{\n\n    int current_max = one;\n\n    if(current_max < two)\n\n            {\n\n                current_max = two;\n\n            if(current_max < three)\n\n                current_max = three;\n\n            }\n\n    else if(current_max >= three)\n\n        {\n\n        if(current_max < three)\n\n            current_max = three;\n\n        }\n\n\n\nreturn current_max;\n\n\n\n\n}\n\n\n\nall_sum find_crossing_sum(int *array,int a,int mid,int b)\n\n{\n\n    int maxleftsum = -999999,maxrightsum = -999999,currentleft = 0;\n\n    int currentright = 0,i = 0,j = 0;\n\n\n\nfor(i = a; i <=mid;i++)\n{\n    currentleft = currentleft + array[i];\n    if(currentleft > maxleftsum)\n        maxleftsum  = currentleft;\n    };\n\nfor(j = mid+1; j <= b;j++)\n{\n    currentright = currentright + array[j];\n    if(currentright > maxrightsum)\n        maxrightsum  = currentright;\n    };\nall.aa = i-1;\nall.bb = j-1;\nall.cc = maxleftsum + maxrightsum;\n\nreturn all;\n\n\n\n\n}\n\n\n\ntypedef struct find_maxium\n\n{\n\n    int low;\n\n    int high;\n\n    int ddd;\n\n} maxium;\n\nmaxium mm;\n\n\n\nmaxium find_maximum_subarry(int*array,int a,int b)\n\n{\n\n    int mid = 0,left_low = 0,left_high = 0,left_sum = 0;\n\n    int right_low = 0,right_high = 0,right_sum = 0;\n\n    int cross_low = 0,cross_high = 0,cross_sum = 0;\n\n    if(a == b)\n\n    {\n\n        mm.low = a;\n\n        mm.high = b;\n\n        mm.ddd = array[a];\n\n        return mm;\n\n    }\n\n    else\n\n    {\n\n        mid = (a + b)/2;\n\n         left_low = find_maximum_subarry(array,a,mid).low;\n\n         left_high = find_maximum_subarry(array,a,mid).high;\n\n         left_sum = find_maximum_subarry(array,a,mid).ddd;\n\n\n\n     right_low = find_maximum_subarry(array,mid+1,b).low;\n     right_high = find_maximum_subarry(array,mid+1,b).high;\n     right_sum = find_maximum_subarry(array,mid+1,b).ddd;\n\n    cross_low = find_crossing_sum(array,a,mid,b).aa;\n    cross_high = find_crossing_sum(array,a,mid,b).bb;\n    cross_low = find_crossing_sum(array,a,mid,b).cc;\n}\nif(max(left_sum,right_sum,cross_sum) == left_sum)\n    {\n        mm.low = left_low;\n        mm.high = left_high;\n        mm.ddd = left_sum;\n    }\nelse if(max(left_sum,right_sum,cross_sum) == right_sum)\n    {\n        mm.low = right_low;\n        mm.high = right_high;\n        mm.ddd = right_sum;\n    }\nelse if(max(left_sum,right_sum,cross_sum) == cross_sum)\n    {\n        mm.low = cross_low;\n        mm.high = cross_high;\n        mm.ddd = cross_sum;\n    }\nreturn mm;\n}\n", "Tag": "算法分析"}
{"Answer": "线性表包括链表和数组，数组就不说了，链表的话，相同的方法可以建立多个，但这是跟实际需求有关的，区分就用链表名呗，。。", "Konwledge_Point": "线性规划和规约", "Question": "线性表建立链表c++i的问题\n线性表定义的链表怎么建立多个，建立多个之后怎么区分啊，他们的头节点都是一样的，好复杂啊！", "Tag": "算法分析"}
{"Answer": "Keras默认会占满显存的。下列代码是动态使用，也就是按需分配的：\n\nimport keras.backend.tensorflow_backend as KTF\nimport tensorflow as tf\nimport os\n \n \nos.environ[\"CUDA_VISIBLE_DEVICES\"] = \"1\"\n \nconfig = tf.ConfigProto()\nconfig.gpu_options.allow_growth=True   #不全部占满显存, 按需分配\nsess = tf.Session(config=config)\n \nKTF.set_session(sess)\n\n\nos.environ 指的时占用的 GPU编号；allow_growth 为动态申请显存占用。\n\nphysical_devices = tf.config.list_physical_devices('GPU') \ntf.config.experimental.set_memory_growth(physical_devices[0], True) \n ", "Konwledge_Point": "线性规划和规约", "Question": "cnn只加载了神经神经网络，还没开始训练，12G显存就占了12G，怎么回事？\n\n\nseed = 7\nnp.random.seed(seed)\n#设置了seed后，会让后面每次产生的随机数相同。\n\ndef Conv2d_BN(x, nb_filter,kernel_size, strides=(1,1), padding='same',name=None):\n    if name is not None:\n        bn_name = name + '_bn'\n        conv_name = name + '_conv'\n    else:\n        bn_name = None\n        conv_name = None\n \n    x = Conv2D(nb_filter,kernel_size,padding=padding,strides=strides,activation='relu',name=conv_name)(x)\n    x = BatchNormalization(axis=3,name=bn_name)(x)\n    return x\n\ndef Conv_Block(inpt,nb_filter,kernel_size,strides=(1,1), with_conv_shortcut=False):\n    x = Conv2d_BN(inpt,nb_filter=nb_filter[0],kernel_size=(1,1),strides=strides,padding='same')\n    x = Conv2d_BN(x, nb_filter=nb_filter[1], kernel_size=(3,3), padding='same')\n    x = Conv2d_BN(x, nb_filter=nb_filter[2], kernel_size=(1,1), padding='same')\n    if with_conv_shortcut:\n        shortcut = Conv2d_BN(inpt,nb_filter=nb_filter[2],strides=strides,kernel_size=kernel_size)\n        x = add([x,shortcut])\n        return x\n    else:\n        x = add([x,inpt])\n        return x\n\ninpt = Input(shape=(224,224,3))\n#预期的输入将是一批224*224*3维度的向量\n\nx = ZeroPadding2D((3,3))(inpt)\nx = Conv2d_BN(x,nb_filter=64,kernel_size=(95,95),strides=(2,2),padding='valid')   #找64种特征，特征基本像素的大小为7*7\nx = MaxPooling2D(pool_size=(3,3),strides=(2,2),padding='same')(x)\n \nx = Conv_Block(x,nb_filter=[64,64,256],kernel_size=(3,3),strides=(1,1),with_conv_shortcut=True)\nx = Conv_Block(x,nb_filter=[64,64,256],kernel_size=(3,3))\nx = Conv_Block(x,nb_filter=[64,64,256],kernel_size=(3,3))\n \nx = Conv_Block(x,nb_filter=[128,128,512],kernel_size=(3,3),strides=(2,2),with_conv_shortcut=True)\nx = Conv_Block(x,nb_filter=[128,128,512],kernel_size=(3,3))\nx = Conv_Block(x,nb_filter=[128,128,512],kernel_size=(3,3))\nx = Conv_Block(x,nb_filter=[128,128,512],kernel_size=(3,3))\n \nx = Conv_Block(x,nb_filter=[256,256,1024],kernel_size=(3,3),strides=(2,2),with_conv_shortcut=True)\nx = Conv_Block(x,nb_filter=[256,256,1024],kernel_size=(3,3))\nx = Conv_Block(x,nb_filter=[256,256,1024],kernel_size=(3,3))\nx = Conv_Block(x,nb_filter=[256,256,1024],kernel_size=(3,3))\nx = Conv_Block(x,nb_filter=[256,256,1024],kernel_size=(3,3))\nx = Conv_Block(x,nb_filter=[256,256,1024],kernel_size=(3,3))\n \nx = Conv_Block(x,nb_filter=[512,512,2048],kernel_size=(3,3),strides=(2,2),with_conv_shortcut=True)\nx = Conv_Block(x,nb_filter=[512,512,2048],kernel_size=(3,3))\nx = Conv_Block(x,nb_filter=[512,512,2048],kernel_size=(3,3))\n\nx = AveragePooling2D(pool_size=(5,5))(x)\n# x = Dropout(0.9)(x)\nx = Flatten()(x)\nx = Dense(25,activation='softmax')(x)\n\nmodel = Model(inputs=inpt,outputs=x)\nsgd = SGD(decay=0.0001,momentum=0.9)\nmodel.compile(loss='categorical_crossentropy',optimizer=sgd,metrics=['accuracy'])\nmodel.summary()\n\n\n\n神经网络如上所示，只运行到上面的这个步骤，我的12G显存就占了11G多。\n\n\n\n\n\n\n然后下一步\n\n\n\n\n\nprint('Training ------------')\n\n# training the model,加上shuffle=True，要不然可能会overfit。只要validation随着acc上升，说明模型就没问题。\n# model_load('my_model_resnet.h5')\nmodel.fit(X_train, y_train, validation_split = 0.2,shuffle = True,epochs=50, batch_size=64)\n\n\nNotFoundError:  No algorithm worked!\n\t [[node model/conv2d/Relu (defined at :5) ]] [Op:__inference_train_function_12948]\n\nFunction call stack:\ntrain_function\n\n\n\n在ubuntu系统里面。我用的是3060显卡，已经安装了显卡驱动，CUDA驱动，cuDNN驱动等。\n\n\n\n为什么会出现这个情况，还没training显存就占满了。求助，麻烦各位大佬帮忙。", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/zhangxaochen/article/details/8020668", "Konwledge_Point": "线性规划和规约", "Question": "使用Gauss-Jordan 消元法的计算\n**学校的作业，让程序最后输出成如图这样，代码看了半天不知道怎么搞，自己的代码输出后是第三张图那样，一堆乱数，实在不明白，哪位高手来替小弟解下惑!\n\n**\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n代码~~~~~~~\n\n\n\n#include\n\n\n\n#define N 100\n\n\n\nvoid output(int n, int st, double a[100][N], double b[100])\n\n{\n\n    int i, j;\n\n\n\nprintf(\"\\n\\nStep  %3d\\n\", st);\nfor (i = 1;i <= n;i++) {\n    for (j = 1;j <= n;j++)\n        printf(\"   %8.2f\", a[i][j]);\n    printf(\"   %8.2f\\n\", b[i]);\n}\n\n\n\n\n}\n\nint main(void)\n\n{\n\n    int  i, j, k, n, q;\n\n    double p;\n\n    double a[N][N], b[N], x[N];\n\n\n\nprintf(\"namber of demension(n) =\");        \nscanf(\"%d\", &n);\nfor (i = 1;i <= n;i++) {\n    for (j = 1;j <= n;j++) {\n        printf(\"a[%d][%d] =\", i, j);\n        scanf(\"%lf\", &a[i][j]);\n    }\n    printf(\"b[%d] =\", i);\n    scanf(\"%lf\", &b[i]);\n}\nprintf(\"\\n\\nGauss eliminaition method\\n\\n\");\nprintf(\"input data\\n\");\nfor (j = 1;j <= n;j++)\n    printf(\"         x%d\", j);\nprintf(\"       rhs\\n\");\nfor (i = 1;i <= n;i++) {\n    for (j = 1;j <= n;j++)\n        printf(\"   %8.2f\", a[i][j]);\n    printf(\"   %8.2f\\n\", b[i]);\n}\n\nfor (i = 1;i <= n;i++) {\n    p = a[i][i];\n    for (j = i;j <= n;j++)\n        a[i][j] = a[i][j] / p;\n    b[i] = b[i] / p;\n    for (k = 1;k <= n;k++) {\n        if (k != i) {\n            q = a[k][j];\n            for (j = i;j <= n;j++)\n                a[k][j] = a[k][j] - q * a[i][j];\n            b[k] = b[k] - q * b[i];\n        }\n    }\n    output(n, i, a, b);\n}\n\nprintf(\"\\n\\n solution :\\n\\n\"); \nfor (i = 1; i <= n; i++)\n    printf(\" x[%d] =b[%d] %8.2f¥n\", i, x[i], b[i]);\nreturn 0;\n\n\n\n\n}", "Tag": "算法分析"}
{"Answer": "z=|a+0.5|-|a|+0.5", "Konwledge_Point": "线性规划和规约", "Question": "if a>=0  then z=1 if a<0    then z=0条件怎么转换成线性表达式\nif a>=0  then z=1\nif a<0    then z=0\n怎么转化成线性表达式？", "Tag": "算法分析"}
{"Answer": "建议将x减去2010后再做多项式拟合，设中间变量m = x -2010，然后拟合y与m的关系，得到y关于m的表达式后，再将x = m+2010带回，得到y关于x的表达式。", "Konwledge_Point": "线性规划和规约", "Question": "Matlab多项式数据拟合，因为x过大y过小导致多项式系数为0该怎么解决?\nMatlab多项式数据拟合，因为x过大y过小导致多项式系数为0该怎么解决?", "Tag": "算法分析"}
{"Answer": "线性搜索不需要什么算法， 直接迭代遍历就可以了。", "Konwledge_Point": "线性规划和规约", "Question": "link下大根堆小根堆排序后的线性搜索是怎么做的？如何才能做到高效率？\nlink下大根堆小根堆排序后的线性搜索是怎么做的？如何才能做到高效率？", "Tag": "算法分析"}
{"Answer": "http://bbs.ednchina.com/BLOG_ARTICLE_3001207.HTM", "Konwledge_Point": "线性规划和规约", "Question": "串口采集数据的差分采样，产生不联系采集序数怎么恢复成线性连续的序列？\n串口采集数据的差分采样，产生不联系采集序数怎么恢复成线性连续的序列？求教差分采样数据的解析方式", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/mr_jj_lian/article/details/6684399", "Konwledge_Point": "线性规划和规约", "Question": " Minimize The Difference              \nProblem Description\n\nRecently, Kiki are asked to arrange a competition. Before the competition, everyone have an expectation of the ranking. To make all the players happy , Kiki wants to minimize the sum of all the players’ difference. We define the difference of a player as |ai-bi|, ai stands for one’s expected ranking ,and bi stands for one’s final ranking.\n\n\n\nInput\n\nThere are several test cases.\n\nEach case begins with an integer n ,(n<= 100)stands for the number of players in this competition.\n\nThen follows n lines ,each line contains a string s and an integer m,(the string will contains no more than 20 characters and no space in it, 1<=m<=n) stands for the name of the player and his expected ranking.\n\n\n\nOutput\n\nThe output contains one line for each data set : the minimum sum of differences Kiki can get.\n\n\n\nSample Input\n\n7\n\na 1\n\nb 2\n\nc 2\n\nd 1\n\ne 5\n\ng 7\n\nf 7\n\n\n\nSample Output\n\n5", "Tag": "算法分析"}
{"Answer": "关于该问题，我找了一篇非常好的博客，你可以看看是否有帮助，链接：matlab 简单函数拟合（全）您还可以看一下 苏金明老师的MATLAB数据拟合课程中的 使用拟合工具进行数据拟合-曲线拟合小节, 巩固相关知识点", "Konwledge_Point": "线性规划和规约", "Question": "Matlab怎么做非线性拟合\n要做一个新冠累计确诊人数的拟合，从WHO上下了数据，然后基于2020年1月3日起至2020年6月3日的数据做预测，共154行4列的，4列依次是新增确诊、累计确诊、新增死亡、累计死亡\n\n\n\n\nfunction\n \ny\n = \nquanguo\n(b, t)\n\n    \nglobal\n y0 \n%b(1):固有增长率;b(2):最大值;b(3):初始值  \n\n    y = b(\n2\n) ./ (\n1\n + b(\n2\n) / b(\n3\n) - \n1\n) .* \nexp\n(-b(\n1\n) .* t); \n\nend\n\n以上为函数\n以下为命令\na = xlsread(\n\"quanguo\"\n);\n\nplot\n(a, \n\"*-\"\n);\ny = a(:, \n2\n);\nt = \n1\n:\n154\n;\nb = nlinfit(t, y, @quanguo, [\n0.3\n, \n100000\n, \n1\n]);\n错误使用 nlinfit (line \n219\n)\nMODELFUN 必须为函数，它返回大小与 Y (\n154\n-by\n-1\n)相同的拟合值向量。您提供的模型函数返回结果 \n1\n-by\n-154\n。\n\n大小不匹配的常见原因之一是在函数中使用矩阵运算符(*、/、^)，而不是对应的元素运算符(.*、./、.^)。\n\n\n\n\n可我提供的xls是个154行4列的矩阵啊，a读出来也是正确的\n\n\n不是很懂错在哪了，求指点一下", "Tag": "算法分析"}
{"Answer": "意思就是要计算方阵A与方阵B的乘积，现在问题是，当C(1,2)开始计算时，C(1,1)是不是已经计算完毕？答案是-没有计算完即False，因为C(1,1)是i等于1和k等于1的时候，j循环了n次。而k是最里面的循环当i=1,j=1,k=1时，只是计算了C(1,1)的一部分下一步循环时是i=1,j=1,k=2，这个时候开始计算C(1,2)的一部分，因此C(1,2)已经开始计算了，但是C(1,1)只是计算了j=1，还有j=2,...n没计算呢。", "Konwledge_Point": "线性规划和规约", "Question": "Linear algebra, MATLAB线性代数\n\n\n以下是答案：\n\n\n\n\n我不懂matlab。看不懂题目和答案是什么意思。能不能解释一下？", "Tag": "算法分析"}
{"Answer": "你说的滑动后。自动居中。需要逻辑调整偏移量。或者不用HorizontalScrollView 控件。改为viewpager 实现。", "Konwledge_Point": "线性规划和规约", "Question": "使用HorizontalScrollView嵌套线性布局中的控件无法适应屏幕\n问题遇到的现象和发生背景\n\n\nandroid开发的小组work，为了实现横向滑动浏览图片使用HorizontalScrollView嵌套了一个线性布局，线性布局里放了4个尺寸一致的相对布局放置图片及文字，只涉及了前端代码。\n\n\n问题相关代码，请勿粘贴截图\n\n\n<\nHorizontalScrollView\n\n            \nandroid:id\n=\n\"@+id/horizontalScrollView\"\n\n            \nandroid:layout_width\n=\n\"match_parent\"\n\n            \nandroid:layout_height\n=\n\"wrap_content\"\n\n            \nandroid:scrollbars\n=\n\"none\"\n\n            \nandroid:fillViewport\n=\n\"true\"\n\n            \nandroid:background\n=\n\"#ffffff\"\n>\n\n            \n<\nLinearLayout\n\n                \nandroid:id\n=\n\"@+id/horizontalScrollViewItemContainer\"\n\n                \nandroid:layout_width\n=\n\"match_parent\"\n\n                \nandroid:layout_height\n=\n\"wrap_content\"\n\n                \nandroid:orientation\n=\n\"horizontal\"\n>\n\n                \n<\nRelativeLayout\n\n                    \nandroid:id\n=\n\"@+id/frame_1\"\n\n                    \nandroid:layout_width\n=\n\"match_parent\"\n\n                    \nandroid:layout_height\n=\n\"match_parent\"\n\n                    \nandroid:layout_alignParentLeft\n=\n\"true\"\n\n                    \nandroid:layout_alignParentTop\n=\n\"true\"\n\n                    \nandroid:layout_marginLeft\n=\n\"15dp\"\n\n                    \nandroid:layout_marginTop\n=\n\"163dp\"\n\n                    \nandroid:layout_marginRight\n=\n\"15dp\"\n>\n\n                    \n<\nImageView\n\n                        \nandroid:id\n=\n\"@+id/rectangle_2\"\n\n                        \nandroid:layout_width\n=\n\"fill_parent\"\n\n                        \nandroid:layout_height\n=\n\"wrap_content\"\n\n                        \nandroid:background\n=\n\"@mipmap/rectangle_2_8\"\n />\n\n                    \n<\nRelativeLayout\n\n                        \nandroid:id\n=\n\"@+id/component_1\"\n\n                        \nandroid:layout_width\n=\n\"wrap_content\"\n\n                        \nandroid:layout_height\n=\n\"wrap_content\"\n\n                        \nandroid:layout_below\n=\n\"@id/rectangle_2\"\n\n                        \nandroid:layout_marginTop\n=\n\"16dp\"\n>\n\n                        \n<\nImageView\n\n                            \nandroid:id\n=\n\"@+id/ellipse_1\"\n\n                            \nandroid:layout_width\n=\n\"wrap_content\"\n\n                            \nandroid:layout_height\n=\n\"wrap_content\"\n\n                            \nandroid:background\n=\n\"@mipmap/ellipse_1\"\n />\n\n                        \n<\nTextView\n\n                            \nandroid:id\n=\n\"@+id/ridhwan_nor\"\n\n                            \nandroid:layout_width\n=\n\"wrap_content\"\n\n                            \nandroid:layout_height\n=\n\"wrap_content\"\n\n                            \nandroid:layout_alignParentLeft\n=\n\"true\"\n\n                            \nandroid:layout_marginLeft\n=\n\"36dp\"\n\n                            \nandroid:text\n=\n\"@string/ridhwan_nor\"\n\n                            \nandroid:textAppearance\n=\n\"@style/ridhwan_nor\"\n />\n\n                        \n<\nTextView\n\n                            \nandroid:id\n=\n\"@+id/ridzjcob\"\n\n                            \nandroid:layout_width\n=\n\"wrap_content\"\n\n                            \nandroid:layout_height\n=\n\"wrap_content\"\n\n                            \nandroid:layout_alignParentLeft\n=\n\"true\"\n\n                            \nandroid:layout_alignParentTop\n=\n\"true\"\n\n                            \nandroid:layout_marginLeft\n=\n\"36dp\"\n\n                            \nandroid:layout_marginTop\n=\n\"15dp\"\n\n                            \nandroid:text\n=\n\"@string/ridzjcob\"\n\n                            \nandroid:textAppearance\n=\n\"@style/ridzjcob\"\n />\n\n                    \n\n\n\n\n                \n<\nRelativeLayout\n\n                    \nandroid:id\n=\n\"@+id/frame_2\"\n\n                    \nandroid:layout_width\n=\n\"match_parent\"\n\n                    \nandroid:layout_height\n=\n\"match_parent\"\n\n                    \nandroid:layout_alignParentLeft\n=\n\"true\"\n\n                    \nandroid:layout_marginLeft\n=\n\"30dp\"\n\n                    \nandroid:layout_alignParentTop\n=\n\"true\"\n\n                    \nandroid:layout_marginTop\n=\n\"163dp\"\n>\n\n                    \n<\nImageView\n\n                        \nandroid:id\n=\n\"@+id/rectangle_2_2\"\n\n                        \nandroid:layout_width\n=\n\"wrap_content\"\n\n                        \nandroid:layout_height\n=\n\"wrap_content\"\n\n                        \nandroid:layout_centerHorizontal\n=\n\"true\"\n\n                        \nandroid:background\n=\n\"@mipmap/rectangle_2_9\"\n />\n\n                    \n<\nRelativeLayout\n\n                        \nandroid:id\n=\n\"@+id/component_2\"\n\n                        \nandroid:layout_width\n=\n\"wrap_content\"\n\n                        \nandroid:layout_height\n=\n\"wrap_content\"\n\n                        \nandroid:layout_alignParentTop\n=\n\"true\"\n\n                        \nandroid:layout_marginTop\n=\n\"359dp\"\n>\n\n                        \n<\nImageView\n\n                            \nandroid:id\n=\n\"@+id/ellipse_2\"\n\n                            \nandroid:layout_width\n=\n\"wrap_content\"\n\n                            \nandroid:layout_height\n=\n\"wrap_content\"\n\n                            \nandroid:background\n=\n\"@mipmap/ellipse_3\"\n />\n\n                        \n<\nTextView\n\n                            \nandroid:id\n=\n\"@+id/clem_onojeg\"\n\n                            \nandroid:layout_width\n=\n\"wrap_content\"\n\n                            \nandroid:layout_height\n=\n\"wrap_content\"\n\n                            \nandroid:layout_alignParentLeft\n=\n\"true\"\n\n                            \nandroid:layout_marginLeft\n=\n\"36dp\"\n\n                            \nandroid:text\n=\n\"@string/clem_onojeg\"\n\n                            \nandroid:textAppearance\n=\n\"@style/clem_onojeg\"\n />\n\n                        \n<\nTextView\n\n                            \nandroid:id\n=\n\"@+id/clemono2\"\n\n                            \nandroid:layout_width\n=\n\"wrap_content\"\n\n                            \nandroid:layout_height\n=\n\"wrap_content\"\n\n                            \nandroid:layout_alignParentLeft\n=\n\"true\"\n\n                            \nandroid:layout_marginLeft\n=\n\"36dp\"\n\n                            \nandroid:layout_alignParentTop\n=\n\"true\"\n\n                            \nandroid:layout_marginTop\n=\n\"15dp\"\n\n                            \nandroid:text\n=\n\"@string/clemono2\"\n\n                            \nandroid:textAppearance\n=\n\"@style/clemono2\"\n/>\n\n                    \n\n\n\n\n\n\n\n\n运行结果及报错内容\n\n\n模拟器上显示正常（图上并非我想达到的最终效果，只是在不停的调整边距，但这种方法也不太适用）但在平板和真机上还是会出现误差\n \n\n\n我的解答思路和尝试过的方法\n\n\n由于代码是小组成员写出来的，我只负责整合。\n尝试过设置HorizontalScrollView的Android:fillViewport=\"true\"。也就是设置是否将HorizontalScrollView的内容宽度拉伸以适应视口(viewport)，好像没什么效果。我现在想把线性布局下的relativelayout兼容到该屏幕的水平居中位置，滑动到下一张图片时也自动水平居中。\n\n\n我想要达到的结果\n\n", "Tag": "算法分析"}
{"Answer": "\nA recursive function might be of help. It could be placed in a helper file, and then you could call it from the view like printMenu($menu);\nUPDATE WITH EXAMPLE:\nIf you need to exclude the first element in your array, as it seems that you want to identify it as a parent, you could do something like this:\nHELPER: (for example menu_helper.php put in folder helper)\nfunction printMenu($a) {\n\n  if (!is_array($a)) {\n    return;\n  } \n\n  foreach($a as $m) {         \n      if($m['parent'] > 0){\n          echo '<li><a tabindex=\"-1\" href=\"#\">'. $m['name'] .'</a></li>';             \n      }\n\n      if(is_array($m['child'])){\n        printMenu($m['child']);\n      }\n  }\n}\n\nVIEW:\n<div class=\"dropdown\">\n<button class=\"btn btn-default dropdown-toggle\" type=\"button\" data-toggle=\"dropdown\">Menu<span class=\"caret\"></span></button>\n    <ul class=\"dropdown-menu\">\n        <?php if($has_children){ ?>\n            <li class=\"dropdown-submenu\">\n                <a class=\"test\" href=\"#\"><?php echo $menu[0]['name']?> <span class=\"caret\"></span></a>\n                <ul class=\"dropdown-menu\">                      \n                    <?php printMenu($menu); ?>\n                </ul>\n            </li>\n        <?php } else {?>\n            <li><a tabindex=\"-1\" href=\"#\"><?php echo $menu[0]['name']?></a></li>\n        <?php } ?>\n    </ul>\n</div>\n\nCONTROLLER:\npublic function index()\n{\n    $this->load->helper('menu'); // OUR NEW HELPER FILE\n    $this->load->model('Test_model');\n    $data['menu'] = $this->Test_model->getCategoriesByParentId(0);\n    $data['has_children'] = 1; //REPLACE WITH A QUERY OR FUNCTION TO CHECK IF CHILDREN EXISTS IN YOU MENU\n    $this->load->view('dropdown', $data);\n}\n\nThe example above only applies to arrays with one single parent. If you need multiple parents you have to call the function for each parent. THis is not optimal, an if you need more advanced handling of menus with multiple depths in Codeigniter you could check the library in this project: https://github.com/edomaru/codeigniter_multilevel_menu\nThe library is not updated for a while and I don't know if its compatible with CI 3, but maybe you could get some ideas of how to go along by checking the source code. They even have a Bootstrap 3 example there.\n", "Konwledge_Point": "线性规划和规约", "Question": "Parent  -  Child  -  Codeigniter视图中的Grand Child类别标记\n\n\n\nI have a test Database Table by the name of autos like following\n\n\n\n\n\n\nI am using a recursive function in my model to get the data in array and dumped it. It looks perfect like following\n\n\n\nArray\n(\n[menu] => Array\n    (\n        [0] => Array\n            (\n                [id] => 1\n                [name] => Automobiles\n                [parent] => 0\n                [child] => Array\n                    (\n                        [0] => Array\n                            (\n                                [id] => 2\n                                [name] => Honda\n                                [parent] => 1\n                                [child] => Array\n                                    (\n                                        [0] => Array\n                                            (\n                                                [id] => 3\n                                                [name] => Cars\n                                                [parent] => 2\n                                                [child] => Array\n                                                    (\n                                                        [0] => Array\n                                                            (\n                                                                [id] => 4\n                                                                [name] => Civic\n                                                                [parent] => 3\n                                                                [child] => Array\n                                                                    (\n                                                                        [0] => Array\n                                                                            (\n                                                                                [id] => 5\n                                                                                [name] => Prosmetic\n                                                                                [parent] => 4\n                                                                            )\n\n                                                                    )\n\n                                                            )\n\n                                                    )\n\n                                            )\n\n                                    )\n\n                            )\n\n\n\n\nIn my view I am creating a standard bootstrap \nmulti-level dropdown\n but I am not getting all the child menus\n\n\n\n\n\n\nProblem : I am not getting all the child\n\n\n\nI believe I have found the reason which is in my view code . Following is the code snippet which renders the drop-down\n\n\n\n\nMenu\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nI am only able to get First level child because I am only checking for the first level child. How can I do it repeatedly (recursively) in the view. I can't just keep checking for sub-child of a child and so on.. There has to be a way. Can anyone point me to the right direction please?\n\n\n\nEDIT: My Model\n\n\n\nfunction getCategoriesByParentId($category_id) {\n    $data = $this->db->select('*')->from('autos')->WHERE('parent',$category_id)->get()->result_array();\n    for($i=0;$igetCategoriesByParentId($data[$i]['id']))\n        {\n            $data[$i]['child']=$this->getCategoriesByParentId($data[$i]['id']);\n        }\n    }\n    return $data;\n}\n\n\n\n\nMy Controller\n \n\n\n\npublic function index()\n{\n    $this->load->model('Test_model');\n    $data['menu']=$this->Test_model->getCategoriesByParentId(0);\n    //echo '';print_r(($data));echo '';exit;\n\n    $data['title']='testing';\n    $this->load->view('head',$data);\n    $this->load->view('dropdown');\n}\n\n\n\n\nI inserted some more categories and subcategories. Now the Menu looks like this \n\n\n\n\n    ", "Tag": "算法分析"}
{"Answer": "你好，代码供参考四阶切比雪夫\n% 切比雪夫级数逼近\nT0 = @(x) 1*ones(size(x));%切比雪夫多项式\nT1 = @(x) x;\nT2 = @(x) 2*x.^2 - 1;\nT3 = @(x) 4*x.^3 - 3*x;\nT4 = @(x) 8*x.^4 - 8*x.^2 + 1;\nT = {T0, T1, T2, T3, T4};\nA = zeros(5,5);\nB1 = zeros(5,1);\nB2 = zeros(5,1);\nf1 = @(x)cos(x);\nf2 = @(x)cosh(x);\nfor i = 1:1:5\n    B1(i,1) = integral(@(x)T{i}(x).*f1(x), -1, 1);%积分获取右端项\n    B2(i,1) = integral(@(x)T{i}(x).*f2(x), -1, 1);%积分获取右端项\n    for j = 1:1:5\n        A(i,j) = integral(@(x)T{i}(x).*T{j}(x), -1, 1);%积分获取系数矩阵\n    end\nend\nc1 = A\\B1;\nc2 = A\\B2;\ny1 = @(x) c1(1)*T{1}(x) + c1(2)*T{2}(x) + c1(3)*T{3}(x) + c1(4)*T{4}(x) + c1(5)*T{5}(x);\ny2 = @(x) c2(1)*T{1}(x) + c2(2)*T{2}(x) + c2(3)*T{3}(x) + c2(4)*T{4}(x) + c2(5)*T{5}(x);\nx = linspace(-1,1,100);\nycos = cos(x);\nycosh = cosh(x);\nycos_fit = y1(x);\nycosh_fit = y2(x);\nplot(x,ycos,'r-', x, ycosh, 'b-'); hold on;\nplot(x,ycos_fit,'-.', x, ycosh_fit, 'g--');\nlegend('cos(x)','cosh(x)','cos(x)四阶切比雪夫逼近','cosh(x)四阶切比雪夫逼近')\n\n效果\n\n四次多项式逼近\n% 四次多项式\nT0 = @(x) 1*ones(size(x));%基函数\nT1 = @(x) x;\nT2 = @(x) x.^2;\nT3 = @(x) x.^3;\nT4 = @(x) x.^4;\nT = {T0, T1, T2, T3, T4};\nA = zeros(5,5);\nB1 = zeros(5,1);\nB2 = zeros(5,1);\nf1 = @(x)cos(x);\nf2 = @(x)cosh(x);\nfor i = 1:1:5\n    B1(i,1) = integral(@(x)T{i}(x).*f1(x), -1, 1);%积分获取右端项\n    B2(i,1) = integral(@(x)T{i}(x).*f2(x), -1, 1);%积分获取右端项\n    for j = 1:1:5\n        A(i,j) = integral(@(x)T{i}(x).*T{j}(x), -1, 1);%积分获取系数矩阵\n    end\nend\nc1 = A\\B1;\nc2 = A\\B2;\ny1 = @(x) c1(1)*T{1}(x) + c1(2)*T{2}(x) + c1(3)*T{3}(x) + c1(4)*T{4}(x) + c1(5)*T{5}(x);\ny2 = @(x) c2(1)*T{1}(x) + c2(2)*T{2}(x) + c2(3)*T{3}(x) + c2(4)*T{4}(x) + c2(5)*T{5}(x);\nx = linspace(-1,1,100);\nycos = cos(x);\nycosh = cosh(x);\nycos_fit = y1(x);\nycosh_fit = y2(x);\nplot(x,ycos,'r-', x, ycosh, 'b-'); hold on;\nplot(x,ycos_fit,'-.', x, ycosh_fit, 'g--');\nlegend('cos(x)','cosh(x)','cos(x)四次多项式逼近','cosh(x)四次多项式逼近')\n\n逼近效果：\n\n可见两者在四阶的时候，都和原函数十分贴合有帮助还望答主点个右上角采纳支持一下，答题不易，十分感谢", "Konwledge_Point": "线性规划和规约", "Question": "数据分析的编程问题，4阶chebyshev级数、最佳平方逼近\n求函数 y=cosx 及函数y=cosh x  在区间[-1,1] 的4阶chebyshev级数以及4次多项式最佳平方逼近, 其中积分近似计算可以使用matlab命令quad及相关命令", "Tag": "算法分析"}
{"Answer": "首先在清单文件加权限:``\r\n然后重写onConfigurationChanged()方法.\r\n\r\n    @Override\r\n\tpublic void onConfigurationChanged(Configuration newConfig) {\r\n\t\t// TODO Auto-generated method stub\r\n\t\tsuper.onConfigurationChanged(newConfig);\r\n\t    if(newConfig.orientation==Configuration.ORIENTATION_LANDSCAPE){  \r\n\t        //横向  \r\n\t        setContentView(R.layout.main_landscape);  \r\n            //重新实例化组件和设置监听\r\n\t    }else{  \r\n\t        //竖向  \r\n\t        setContentView(R.layout.main);  \r\n            //重新实例化组件和设置监听       \r\n\t    }  \r\n\t}\r\n最后别忘了在onCreate()时加上判断,\r\n\r\n    if(getResources().getConfiguration().orientation ==Configuration.ORIENTATION_LANDSCAPE){\r\n        setContentView(R.layout.main_landscape);\r\n    }else {\r\n        setContentView(R.layout.main);\r\n    }", "Konwledge_Point": "线性规划和规约", "Question": "如何修改 activity 中的布局\n当方向改变时，我想让activity 不被毁坏，因此我在manifest 文件中添加：\n\n\n\n\n\n\n\n\n\n现在的问题是每当方向转化成横向方式时，我如何才能使它转向一个新的布局？\n\n在 layout-land 或者 layout-port 里加入布局文件还是不能正常运行。", "Tag": "算法分析"}
{"Answer": "刚才那个写的有点错误，方程写错了，修改如下：\nfloat f(float x)                    // 求 y 函数\n{\n    return 2*pow(x,3) - 4*pow(x,2)+3*x-6;\n}\n\nfloat newx(float x1, float x2)    // 求 x 的下一迭代值\n{\n    return x1-f(x1)*(x1-x2)/(f(x1)-f(x2));\n}\n\nfloat root(float x1, float x2)         // 求根函数\n{\n    float x, y, y1;\n    y1 = f(x1);                        // 先固定(x1,y1)，并不断调整(x2,y2)\n    for(y = y1; fabs(y) >= 1e-6; ) // 循环求解，判断精度是否满足需求\n    {\n        x = newx(x1, x2);            // 下一迭代值 x\n        y = f(x);                    // x 对应的 y 值\n\n        if(y*y1 > 0)                // 如果新点(x,y)和(x1,y1)在 x 轴的同侧，则替换(x1,y1)\n        {\n            y1 = y;\n            x1 = x;\n        }\n        else\n        {\n            x2 = x;                    \n        }\n    }\n    return x;\n}\n\nint main()\n{\n    float x;\n\n    x = root(0,3);\n\n    printf(\"%.2f\",x);\n    \n    return 0;\n}\n\n", "Konwledge_Point": "线性规划和规约", "Question": "关于#c语言#的问题：用弦截法求非线性方程23-42+3x-6=0在区间[0,3]的一个实根\n用弦截法求非线性方程2\n3-4\n2+3x-6=0在区间[0,3]的一个实根，精度为10-6。", "Tag": "算法分析"}
{"Answer": "参考一下a和m互质，即它们的最大公约数为1；c与m无公因数，即它们的最大公约数为1；a-1能够被m的所有质因子整除；如果m是4的倍数，则a-1也必须是4的倍数。\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int m = 945; // 模数\n    int a = 2; // a值\n    int c = 1; // c值\n    int max_period = 0; // 最大周期\n\n    for (int i = 2; i < m; i++) { // 遍历a值\n        if (m % i == 0 && (i - 1) % 4 == 0) { // 判断是否满足条件3和4\n            a = i;\n            break;\n        }\n    }\n\n    for (int i = 1; i < m; i++) { // 遍历c值\n        if (m % i != 0) { // 判断是否满足条件2\n            c = i;\n            break;\n        }\n    }\n\n    int x = 1; // 初始值\n    int period = 0; // 周期\n\n    do { // 计算随机数序列的周期\n        x = (a * x + c) % m;\n        period++;\n    } while (x != 1);\n\n    max_period = m - 1; // 最大周期为m-1\n\n    printf(\"a=%d, c=%d, max period=%d\\n\", a, c, max_period);\n\n    return 0;\n}\n\n", "Konwledge_Point": "线性规划和规约", "Question": "已知线性同余的模数为945\n已知线性同余的模数为945，怎么取a值和增量c值大最大周期呢", "Tag": "算法分析"}
{"Answer": "\nChris,\nFirst you will want to create that new table in your database to capture this information.  Lets assume to you will have the following fields (very basic, you may want to add more): ReportId, LinkId, DateReported. ReportId is our primary key, LinkId is the ID you reference in your question and the DateReported is the server time we logged the transaction.\nWith this table created you are going to want to create a new php page, lets call it report-link.php.  You are going to want to make this page accept a querystring variable called linkid (accessible in the $_GET[] collection).  In the code of this page you will want to write a SQL query that inserts the value of the linkid parameter into the new link report table in the database (along with the date()).\nOn your search page you will be able to have users report an entry by clicking a link with the href of /path/to/report-link.php?linkid=<?php echo $link_id; ?>\nPlease note this example is very simplistic in nature, and offers no security for spamming, pleasant end user experience after they click the link, but this is the process you will want to follow in setting this feature up.  After you have it working you can spruce up the experience for your users.\n", "Konwledge_Point": "线性规划和规约", "Question": "php报告按钮\n\n\n\nI am working on a search script and on each search result I want a report link button. I am not sure how to make one. I have looked on google for answers but cannot come up with anything. Can anyone give me an idea of what to do? or does anyone know where there is an example of this? I plan on using the link id and making a new table on mysql to send reports to. I am just looking for a basic button to send reports to mysql I am just not sure what would be the best way to do it. I have the data for the link id's I just need to be able to report it to a new table I am assuming. Any suggestions or examples are very appreciated. Thanks.\n\n    ", "Tag": "算法分析"}
{"Answer": "\n理解支持向量，bargin的含义就行，支持向量机的分类超平面只和支持向量样本有关", "Konwledge_Point": "线性规划和规约", "Question": "人工智能导论模型与算法书的课后题实在不会好商量支持向量机机器学习svm 分类边界错误率分离边界发生变化实现，考虑一个在二维特征空间中的二类分析问题，训练集包含八个样本其在二维空间中的分布如图\n\n\n考虑一个在两维特征空间中的二分类问题。训练集包含8个样本，其在二维空间中的分布如图4.14所示。图4.14中不同类别的样本用不同的形状表示，根据图4.14回答如下问题。\n(1)使用实线画出使用SVM分类器可得到的分类边界，并用圆圈标出支持向量。\n(2)在该分类边界下所得训练错误率为多少？\n(3)移除哪些样本可以让分类边界发生变化？", "Tag": "算法分析"}
{"Answer": "", "Konwledge_Point": "线性规划和规约", "Question": "Linear algebra, Least Squares Approximations线性代数\n\n\n4.3A(1)怎么做的？能不能解释一下solution?", "Tag": "算法分析"}
{"Answer": "用expi函数，参见https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.expi.html#scipy.special.expi", "Konwledge_Point": "线性规划和规约", "Question": "如何对指数积分进行非线性拟合\n楼主想拟合一个含指数积分的表达式，得到函数中的两个参数值。\n\n\n\n但是第一个问题是不知道自己写的指数积分表达是不是正确，第二是自己调用了哈这个自定义函数，报运行时间的错误，不知道怎么回事。这是那函数表达式。\n\n\n\n\n\n\n \n\n\n\n\n\nfrom scipy.special import *\nimport math\n##自定义函数 指数积分\ndef func(x,a,b):\n    c=2.5#单位时间单位长度发热丝的发热量\n    d=0.006#校准后的探针间距\n    e = 12 #热脉冲加热时间\n    #a为热传导系数\n    #b为热容量\n    return c/(4*math.pi*a*b)*(expn(1,-d*d/(4*a*(x-e)))-expn(1,-d*d/(4*a*x)))\nfunc(17,1,4.8)\n\n报错代码：\nD:\\anaconda\\lib\\site-packages\\ipykernel_launcher.py:15: RuntimeWarning: invalid value encountered in double_scalars\n  from ipykernel import kernelapp as app", "Tag": "算法分析"}
{"Answer": "我线性代数不太行，想不出啥技巧，用笨方法给你接一下x吧，y就不算了，不好算。\n", "Konwledge_Point": "线性规划和规约", "Question": "Linear algebra, graphs and networks线性代数\n\n\n求A^T C A x = f =(1, 0, 0, -1)\n等式左边我算出来了，但是我用ipython算是singular matrix，算不出答案。\n\n\n\n\n他给的答案是x=（5/12， 1/6, 1/6, 0)y=(1/2, 1/2, 0, 1/2, 1/2)\n到底怎么算？", "Tag": "算法分析"}
{"Answer": "根据行列式的Leibniz公式，把行列式项中的元素按第一个下标排序，然后看第二个下标是否是序列{1, 2, ..., n}的一种置换，如果是，则符号是为正，否则为负。你这道题按第一个下标排序，得到a12 a24 a35 a41 a53第二个下标序列为{2, 4, 5, 1, 3}，而这个序列不能通过对{1, 2, 3, 4, 5}进行置换得到，所以符号改项的符号为负\n参考https://en.wikipedia.org/wiki/Determinant#Leibniz_formula", "Konwledge_Point": "线性规划和规约", "Question": "请问这个是为什么线性代数\n", "Tag": "算法分析"}
{"Answer": "A是由5单位矩阵-4全是1的矩阵组成，前面的矩阵特征值都是5（单位矩阵对角线全是1，特征值全是1，所以都*5），后面的矩阵秩为1，但它是4阶，所以它只有一个特征值不为0，又因为对角线元素之和等于矩阵特征值之和，所以后面的矩阵特征值有一个是4，然后A的特征值是可以由前个矩阵的特征值依次减去后面矩阵特征值得到的\n", "Konwledge_Point": "线性规划和规约", "Question": "Linear algebra, diagonalizing a matrix线性代数\n\n\n\"Subtract the eigenvalues 4,0,0,0 from 5,5,5,5. The eigenvalues of A are 1,5,5,5.\" 是什么原理？", "Tag": "算法分析"}
{"Answer": "spatial analyst tools -> surface -> contour", "Konwledge_Point": "线性规划和规约", "Question": "arcgis中怎样绘制poi核密度等值线分布图\n这是大连市区的POI核密度分布图，请各位点播一下如何绘制POI分布等值线\n\n", "Tag": "算法分析"}
{"Answer": "能求出来应该算对吧，方法千万种", "Konwledge_Point": "线性规划和规约", "Question": "线性代数的问题 行列式的问题\n在求行列式时 不化成上三角或下三角直接用展开式求算错吗？", "Tag": "算法分析"}
{"Answer": "基于Monster 组和GPT的调写：使用 Scikit-learn 的机器学习模型时，通常都是先实例化一个模型对象，然后再调用其 fit 方法来拟合模型。如果直接调用 LinearRegression().fit(x_train, y_train)，你会得到一个 \"This LinearRegression instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\" 的错误。这是因为，在调用 fit 方法前，模型实例没有被保存下来，因此不能在之后使用。\n而在这种情况下：\nhouselr = LinearRegression()\nhouselr.fit(x_train,y_train)\n\n\n\n\n首先，我们实例化了一个 LinearRegression 对象，并将其保存在变量 houselr 中。然后再调用 houselr.fit(x_train, y_train) 拟合模型，这样就不会报错。因此，通常情况下，在使用模型时都会先将其实例化，再拟合。", "Konwledge_Point": "线性规划和规约", "Question": "使用sklearn进行线性回归时遇到的问题\n代码苦手,在使用sklearn中LinearRegression时,若直接使用\nLinearRegression().fit(x_train,y_train)\n则会报错This LinearRegression instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.  \n\n\n若是先行将LinearRegression()定义为其他,如\nhouselr = LinearRegression()\nhouselr.fit(x_train,y_train)\n则不会出现该状况,这是为什么呢?", "Tag": "算法分析"}
{"Answer": "楼上的两个按钮填满水平布局，如果不想填满还用线性布局，只能在两个TextView中间再放一个view 占位置了。借楼主的代码改了下\r\n\r\n    \n\n\n\n\n\n", "Konwledge_Point": "线性规划和规约", "Question": "在线性布局视图中创建两个列\n我想创建一个布局，布局里包含两列，左边和右边各显示一个textview，但是我使用的下面代码，这两个textview都在左边。怎么能把textview分开两边显示呢？谢谢！\n\n\n\n\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "意思是，你在使用N2前，你没有声明它是多少呀，凭空出现的N2，计算机肯定识别不出来呀，你要定义一下N2的值或者表达式哟。\n觉得有帮助的话，可以点击一下 采纳 哟，谢谢~", "Konwledge_Point": "线性规划和规约", "Question": "Matlab求出，解多目标线性方程\n这个多目标函数怎么都解不出来，他总是高数我未知数不知道，可是我希望他解未知数啊", "Tag": "算法分析"}
{"Answer": "你给的值已经很准确了，也是线性输出你可以仔细测量正确的DA的环境，与你的环境做对比。DA的工作电压最好不变。仔细测量正确 DA 环境下的12位数值和电流的关系。要测量多组数据做对比。我们一般使用 DA 是需要做校准的，每个DA板子的电阻值可能是有偏差的。一般就用一个最简单的线性方程 Y=K * X + B 反复多测量几组参数后用求出 K 和 B 的平均值。", "Konwledge_Point": "线性规划和规约", "Question": "DA输出值不准确，输出不线性\n用mcp4822.  12位DA输出芯片转0-20mA输出电路     程序输出直接发送数字0  万用表测量mA为0.07mA左右，程序直接输出数字4095  测量结果是20.5mA左右，输出数字2047  测量结果为10.2mA左右\n12位Da输出应该之前可以精确到0.01mA吧， 为什么 我的输出差这么多呢，da输出电路板没有问题，直接用的别人正常使用的，是不是程序还需要怎么处理呢，不是直接给输出程序赋对应的0-4095的数就可以直接输出对应的mA么？", "Tag": "算法分析"}
{"Answer": "是线性规划，但是不建议你自己手写代码了。可以去了解一下gurobi，可以解决这类问题\n", "Konwledge_Point": "线性规划和规约", "Question": "想知道这种用matlab要怎么写\n这种还是属于线性规划问题吗，可是y前面不是已经乘了未知数k了吗？\n请问具体应该怎么写代码呢？", "Tag": "算法分析"}
{"Answer": "这有个类似的问题, 你可以参考下: https://ask.csdn.net/questions/7739025这篇博客你也可以参考下：吴恩达机器学习之多变量线性回归：多维特征、多变量梯度下降、梯度下降法实践之特征缩放和学习率、特征和多项式回归、正规方程及不可逆性（详细笔记，建议收藏，已有专栏）除此之外, 这篇博客: 深度学习框架——学习入门中的 深度学习的总的框架包括以下一些内容：就是对于我们所要的数据进行相关的预处理。包括数据格式的统一以及必要的数据转换，同时进行训练数据集和测试数据集的划分，选择我们所需要的模型，设定相应的损失函数以及优化函数和对应的超参数进行相应的设置，最后使用模型去拟合训练集数据，在验证集和测试集上计算模型表现。 部分也许能够解决你的问题, 你可以仔细阅读以下内容或跳转源博客中阅读: 提示：以下是本篇文章正文内容，下面案例可供参考\n您还可以看一下 李月喜老师的企业微信开发自建内部应用开发篇课程中的 开发文档如何阅读,如何寻求帮助,如何找到同行小节, 巩固相关知识点", "Konwledge_Point": "线性规划和规约", "Question": "训练集，线性回归，截距，斜率\n1、装载数据\n''' 数据集说明：x特征变量只有一个分量；样本个数为100个'''\n2、划分训练集与测试集\n3、用线性回归模型来实例化，在训练集上拟合数据，从而学习出参数w和b\n4、输出参数学习的结果\n5、计算并输出训练集和测试集上的精度\n6、绘制数据集的二维平面图（数据点用红色标识），并根据学习到的参数（即斜率与截距），画出回归直线（用蓝色画线）", "Tag": "算法分析"}
{"Answer": "行列式求解两种方法，一是通过行列变换得到对角行列式，二是通过行列式展开，也就是代数余子式的方法，就是标准答案的第一个方法。行列式经过行列变换后是等效的，所以为了计算方便，先经过行列变换再做展开也是可以的。", "Konwledge_Point": "线性规划和规约", "Question": "线性代数中关于k阶子式问题\n\n\n我想用k阶子式的方法来做，但是我算出来的结果和答案不一样，而且答案是先行列互换再计算的，我这样子计算是错误的吗？", "Tag": "算法分析"}
{"Answer": "先构建一个等号右侧为0的等式，然后按照这个步骤去做就可以了。\n\n有帮助请采纳，还有不懂的可以继续追问~", "Konwledge_Point": "线性规划和规约", "Question": "请教一下大家关于matlab求解非线性方程\n\n\n自己的程序出了错误不知如何解决，还有初始值该如何表示，请教一下大家", "Tag": "算法分析"}
{"Answer": "https://www.cnblogs.com/ooon/p/5721119.html", "Konwledge_Point": "线性规划和规约", "Question": "除了牛顿法，还可以如何求解kkt条件？\n在获得了一个线性规划问题的KKT条件之后，除了用牛顿法之外，还可以用什么方法来求解了？请优化大佬指点一下", "Tag": "算法分析"}
{"Answer": "\nimport cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.widgets import Slider #调用Slider滑块控件\n\ndef set_chinese(): #使得画图时的标题可以为中文\n    import matplotlib\n    print(\"[INFO] matplotlib版本为: %s\" % matplotlib.__version__)\n    matplotlib.rcParams['font.sans-serif'] = ['FangSong']\n    matplotlib.rcParams['axes.unicode_minus'] = False\n\ndef three_line_trans(x,x1,y1,x2,y2):\n    if x1==0 or x1==x2 or x2==255:\n        print(\"[INFO] x1={},x2{} ->调用此函数必须满足: x1≠x2且x2≠255以及x1≠0\")\n        return None\n\n    #【快速算法】\n    m1 = (x<x1)\n    m2 = (x>x1)&(x<x2)\n    m3 = (x>x2)\n    output = (y1*x/x1)*m1 + (((y2-y1)/(x2-x1))*(x-x1)+y1)*m2 + (((255-y2)/(255-x2))*(x-x2)+y2)*m3\n\n    # 3.获取分段线性函数的点集，用于绘制函数图像\n    x_point = np.arange(0, 256, 1)\n    cond2 = [True if (i >= x1 and i <= x2) else False for i in x_point] #!!!不能直接写x1<=x_point<=x2,否则报错。暂时不知道为什么不能双向\n    y_point = (y1 / x1 * x_point) * (x_point < x1) \\\n              + ((y2 - y1) / (x2 - x1) * (x_point - x1) + y1) * (cond2) \\\n              + ((255 - y2) / (255 - x2) * (x_point - x2) + y2) * (x_point > x2)\n\n    return output, x_point, y_point\n\ndef update_trans(val):\n    # 读入4个滑动条的值\n    x1, y1 = slider_x1.val, slider_y1.val\n    x2, y2 = slider_x2.val, slider_y2.val\n    if x1>=x2:\n        x1 = x2-1\n    if y1>=y2:\n        y1 = y2-1\n    output, x_point, y_point = three_line_trans(img_original1, x1=x1, y1=y1, x2=x2, y2=y2)\n    ax3.clear()\n    ax3.set_title('分段线性函数图像', fontsize=8)\n    ax3.grid(True, linestyle=':', linewidth=1)\n    ax3.plot([x1, x2], [y1, y2], 'ro')\n    ax3.plot(x_point, y_point, 'g')\n\n    ax4.clear()\n    ax4.set_title('变换后的图像', fontsize=8)\n    ax4.imshow(output, cmap='gray', vmin=0, vmax=255)\n\n    ax5.clear()\n    ax5.set_title('变换后图像直方图', fontsize=8)\n    ax5.hist(output.flatten(),bins=50, density=True, color='r', edgecolor='k')\n    ax5.set_xlim(0, 255)  # 设置x轴分布范围\n    ax5.set_ylim(0, 0.15)  # 设置y轴分布范围\n    ax5.grid(True, linestyle=':', linewidth=1)\n\n\nif __name__ == '__main__':\n    set_chinese()\n    img_original = cv2.imread(r'Fig0316(2)(2nd_from_top).tif')\n    img_original1 = cv2.cvtColor(img_original, cv2.COLOR_BGR2GRAY)\n\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(231)\n    ax2 = fig.add_subplot(232)\n    ax3 = fig.add_subplot(233)\n    ax4 = fig.add_subplot(234)\n    ax5 = fig.add_subplot(235)\n\n    ax1.set_title('原始输入图片',fontsize=8)\n    ax1.imshow(img_original1,cmap='gray',vmin=0,vmax=255) #官方文档：https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.imshow.html#matplotlib.axes.Axes.imshow\n    ax2.set_title('原始输入图片直方图',fontsize=8)\n    ax2.hist(img_original1.flatten(), bins=50, density=True, color='r', edgecolor='k') #bin属性控制直方图横条的数量, density为True则显示的是概率密度\n    ax2.set_xlim(0, 255)  # 设置x轴分布范围\n    ax2.set_ylim(0, 0.15)  # 设置y轴分布范围\n    ax2.grid(True, linestyle=':', linewidth=1)\n\n    plt.subplots_adjust(bottom=0.3)\n    x1 = plt.axes([0.25, 0.2, 0.45, 0.03], facecolor='lightgoldenrodyellow') #控制横轴的left,bottom,width,height位置和大小\n    slider_x1 = Slider(x1, '参数x1', 0.0, 255.,\n                       valfmt='%.f', valinit=91, valstep=1) #slider的输入x必须是一个Axes\n    slider_x1.on_changed(update_trans)\n\n    y1 = plt.axes([0.25, 0.16, 0.45, 0.03],\n                  facecolor='lightgoldenrodyellow')\n    slider_y1 = Slider(y1, '参数y1', 0.0, 255.,\n                       valfmt='%.f', valinit=0, valstep=1)\n    slider_y1.on_changed(update_trans)\n\n    x2 = plt.axes([0.25, 0.06, 0.45, 0.03],\n                  facecolor='white')\n    slider_x2 = Slider(x2, '参数x2', 0.0, 254.,\n                       valfmt='%.f', valinit=138, valstep=1) #valinit表示slider的点的初始位置（即滑块的初始值）\n    slider_x2.on_changed(update_trans)\n\n    y2 = plt.axes([0.25, 0.02, 0.45, 0.03],\n                  facecolor='white')\n    slider_y2 = Slider(y2, '参数y2', 0.0, 255.,\n                       valfmt='%.f', valinit=255, valstep=1)\n    slider_y2.on_changed(update_trans)\n\n    slider_x1.set_val(91)\n    slider_y1.set_val(91)\n    slider_x2.set_val(138)\n    slider_y2.set_val(138)\n    #plt.tight_layout()\n    plt.show()\n\n", "Konwledge_Point": "线性规划和规约", "Question": "实现分段线性变换，显示处理前后图像\n2.产生灰度变换函数T1，使得：\n          0.3r                            r < 0.35\ns =     0.105 + 2.6333(r-0.35)                  0.35 ≤ r ≤ 0.65\n          1 + 0.3(r-1)                r > 0.65\n    用T1对原图像rice.jpg进行处理，显示处理前、后的图像(r,s为归一化灰度)。\n\n\nrice.jpg\n\n\n实验仪器\n      Python+OpenCV", "Tag": "算法分析"}
{"Answer": "不知道你这个问题是否已经解决, 如果还没有解决的话: 关于该问题，我找了一篇非常好的博客，你可以看看是否有帮助，链接：关于R语言多水平线性回归分析你还可以看下r语言参考手册中的 r语言 线性模型如果你已经解决了该问题, 非常希望你能够分享一下解决方案, 以帮助更多的人 ^-^", "Konwledge_Point": "线性规划和规约", "Question": "在R语言中做多水平线性回归\n我的数据是：低水平层面为团队中的成员；高水平为团队，其中团队层面的数据是从成员层面聚合得到的。\n我的分析模型是：考虑团队特性对团队绩效的影响，检验团队层面变量的调节作用以及个人层面变量的调节作用。\n我主要有两个问题请教大家：一是做多水平回归的时候对两个层面的数据做分析，导入的数据选择哪个层面呢？我在网上搜到一些例子，大多研究的是低水平层面的自变量与因变量的关系，同时考察高水平层面的调节作用，用的也都是低水平的数据，所以像我这样的研究假设因变量是在高水平层面，是否就应该导入高水平层面的数据做分析？二是，导入高水平层面的数据后还想检验低水平层面变量的调节作用该如何实现呢", "Tag": "算法分析"}
{"Answer": "该回答通过自己思路及引用到GPTᴼᴾᴱᴺᴬᴵ搜索,得到内容具体如下：以下是用 Jacobi 迭代法解线性方程组的 MATLAB 函数代码，包括了你提到的步骤 2 到 7：\nfunction Xsolve = myJacobi(A, b, X0, mytol)\n% Jacobi 迭代法解线性方程组 Ax=b\n% 输入参数：\n% A：系数矩阵\n% b：右端常向量\n% X0：初始迭代值，默认为全零向量\n% mytol：允许误差，默认为 1e-6\n% 输出参数：\n% Xsolve：迭代收敛时满足精度的数值解\n\n% 检查输入参数\nif nargin < 4\n    mytol = 1e-6;\nend\nif nargin < 3\n    X0 = zeros(size(b));\nend\nif nargin < 2\n    error('输入参数不足');\nend\n\n% 构造 Jacobi 迭代矩阵\nD = diag(diag(A));\nU = triu(A, 1);\nL = tril(A, -1);\nM = D;\nN = L + U;\n\n% 判断系数矩阵是否可逆\nif abs(det(A)) < mytol\n    error('系数矩阵不可逆');\nend\n\n% 判断系数矩阵主对角元素是否为零\nif any(diag(A) == 0)\n    error('系数矩阵主对角元素有零元素');\nend\n\n% 判断 Jacobi 迭代法是否收敛\nrho = max(abs(eig(M \\ N)));\nif rho >= 1\n    disp('Jacobi 迭代法不收敛');\n    Xsolve = [];\n    return;\nelse\n    disp('Jacobi 迭代法收敛');\nend\n\n% Jacobi 迭代格式\nXn = X0;\nerr = inf;\nwhile err > mytol\n    Xn1 = M \\ (b - N * Xn);\n    err = norm(Xn1 - Xn, inf);\n    Xn = Xn1;\nend\n\nXsolve = Xn;\n\nend\n\n在命令窗口中可以按以下方式调用该函数：\n% 例子：解方程组 Ax=b，其中 A=[4 -1 0; -1 4 -1; 0 -1 4]，b=[15; 10; 10]\nA = [4, -1, 0; -1, 4, -1; 0, -1, 4];\nb = [15; 10; 10];\nXsolve = myJacobi(A, b);\n\n其中，Xsolve 是 Jacobi 迭代法求解得到的数值解。\n希望这个代码能够帮助你解决问题。\n\n如果以上回答对您有所帮助，点击一下采纳该答案～谢谢", "Konwledge_Point": "线性规划和规约", "Question": "用jacobi迭代法解线性方程组函数\n1、函数输入形参要求如下，也可以修改得更好、更适合你自己.\nfunction Xsolve=myJacobi(A.b.X0 mytol)\n%A为系数矩阵\n點为右端常向量\nX0为初始层，默认取0.\n%mytol表示允许误差.要求默认值为le-b.\n%Xsolve表示收敛情况下满足精度的数值解\nXnargin表示输入参数个数，下面这一段是简单的判断，你可以编写的更好if nargin<4 %如果参数<4.\nmytol=le-b:\nif nargin<3 %如果参数3\nX0=zeros(size(b))；\nif nargins2\nerror(‘输入参数不足‘)；\nend\nend\nend\n2.第一步描述出矩阵DL.U\n3、第二步要判断系数矩阵是否可逆，用“abs(det(A))<mytol”或者别的方式判断，不满足要提示：\n4. 第三步要判断系数矩阵主对角元素是否为零，\n5、第四步用迭代法基本定理(计算谱半径)判断迭代法是否收敛，要在命令窗口输出是否收敛的结论：\n6、第五步在收敛的基础上进行迭代格式的程序编写：\n7、迭代格", "Tag": "算法分析"}
{"Answer": "\nWhat you are after is applying a Convolution filter to an image, for that you can use PHP's built in  imageconvolution() php.net function.\nFor usage, see Magilvia's example on php.net modified for your purpose:\n<?php \n    $sharpenMatrix = array \n    ( \n        array(-0.5, -0.5, -0.5), \n        array(-0.5, 5, -0.5), \n        array(-0.5, -0.5, -0.5) \n    ); \n\n    // calculate the sharpen divisor \n    $divisor = array_sum(array_map('array_sum', $sharpenMatrix));            \n\n    $offset = 0; \n\n    // apply the matrix \n    imageconvolution($img, $sharpenMatrix, $divisor, $offset); \n?>\n\n$img is a PHP image the convolution matrix (sharpening filter) is applied on\n", "Konwledge_Point": "线性规划和规约", "Question": "使用PHP中的线性过滤器锐化图像\n\n\n\nI would like to read an image and sharpen it using a linear filter, which is this matrix:\n\n\n\nH =  [-0.5 -0.5 -0.5; -0.5 5 -0.5; -0.5 -0.5 -0.5]\n\n\n\n\nI know about ImageMagick, is there any possibility to do just that?\n\n    ", "Tag": "算法分析"}
{"Answer": "对于常系数非齐次线性微分方程：\ny'' + ay' + by = f(x)\n其中 a 和 b 都是常数，f(x) 是已知函数。\n有两种情况，一种是 f(x) 是指数函数，另一种是 f(x) 是多项式函数。\n对于第一种情况，解的形式为 y = R(x) e^(mx)，其中 m 为常数，R(x) 是一个与 x 相关的函数。\n将 y = R(x) e^(mx) 带入到原方程中，得到：\n R''(x) e^(mx) + (2mR'(x) + aR(x)) e^(mx) + bR(x) e^(mx) = f(x)\n将 e^(mx) 分离出来，得到：\n e^(mx) (R''(x) + 2mR'(x) + (a+bm)R(x)) = f(x)\n因为 e^(mx) 不等于零，所以可以将方程简化为：\nR''(x) + 2mR'(x) + (a+bm)R(x) = f(x) e^(-mx)\n令 Rm(x) 为特解，则有：\nRm''(x) + 2mRm'(x) + (a+bm)Rm(x) = f(x) e^(-mx)\n对于第二种情况，即 f(x) 是多项式函数，解的形式为：\ny = (Ax^k + Bx^(k-1) + ... + C) e^(mx)\n其中 k 是 f(x) 的最高次幂，A, B, ..., C 都是常数，R(x) 是一个与 x 相关的函数。\n将 y 带入到原方程中，得到：\n[A(m^2+kam+b) x^k + ... + C(m^2+am+b)] e^(mx) + f(x) = 0\n因为 e^(mx) 不等于零，所以可以将方程简化为：\n[A(m^2+kam+b) x^k + ... + C(m^2+am+b)] + f(x) e^(-mx) = 0\n注意到上式中的常数项是与 x 无关的，所以不能写成 R(x) = xRm(x) + c 的形式。\n关于为什么书上没有给出这个常数项 c，可能是因为这个常数项并不能代表所有可能的常数项，因为常数项可以是任何常数。同时，书上可能认为这个常数项并不重要，因为它不会影响到 R(x) 的定义和求解。", "Konwledge_Point": "线性规划和规约", "Question": "常系数非齐次线性微分方程的问题\n为什么第二种情况不是R（x）=xRm（x）+c？为什么书上没有这个常数项c。", "Tag": "算法分析"}
{"Answer": "引用new bing部分回答作答：非线性薛定谔方程（NLSE）是一个描述波动现象的方程，在物理学和工程学等领域有广泛应用。NLSE 的一般形式为：\n$i\\hbar\\frac{\\partial \\psi}{\\partial t}=-\\frac{\\hbar^2}{2m}\\frac{\\partial^2\\psi}{\\partial x^2}+V(x)\\psi+g(x)|\\psi|^2\\psi$\n其中，$\\psi$ 是波函数，$m$ 是粒子的质量，$V(x)$ 是势能，$g(x)$ 是非线性系数，$|\\psi|^2$ 表示波函数的模方。\n为了求解 NLSE，我们可以采用紧致差分方法（Compact Difference Method），将偏微分方程转化为差分方程进行求解。这里介绍一种四阶紧致差分格式的求解方法。\n假设我们在空间方向上使用均匀网格，网格大小为 $h$，时间步长为 $\\Delta t$，则可以将空间坐标 $x$ 和时间 $t$ 分别离散化为 $x_j=jh$ 和 $t_n=n\\Delta t$。同时，我们采用中心差分法近似计算偏微分方程中的导数项。\n将 NLSE 中的各项代入差分方程中，可以得到如下形式的紧致差分方程：\n$i\\hbar\\frac{\\psi_j^{n+1}-\\psi_j^n}{\\Delta t}=-\\frac{\\hbar^2}{2m}\\frac{\\psi_{j+1}^n-2\\psi_j^n+\\psi_{j-1}^n}{h^2}+V_j\\psi_j^n+g_j|\\psi_j^n|^2\\psi_j^n$\n其中，$\\psi_j^n$ 表示波函数在位置 $x_j$ 和时间 $t_n$ 的值。\n将上述方程进行整理，得到：\n$\\psi_j^{n+1}=\\frac{\\Delta t i\\hbar}{2m}\\frac{\\psi_{j+1}^n-2\\psi_j^n+\\psi_{j-1}^n}{h^2}+(\\frac{\\Delta t i\\hbar}{h^2}V_j+1)\\psi_j^n+\\frac{\\Delta t i\\hbar g_j}{h^2}|\\psi_j^n|^2\\psi_j^n$\n这个方程是一个离散的迭代公式，可以通过多次迭代计算得到 NLSE 的数值解。下面是用 MATLAB 实现这个算法的示例代码。\n% 定义参数\nh = 0.1; % 空间步长\ndt = 0.001; % 时间步长\nx = -10:h:10; % 空间网格\nt = 0:dt:1; % 时间网格\nm = 1; % 粒子质量\nV = 0.5*x.^2; % 势能\ng = 1; % 非线性系数\nhbar = 1; % 普朗克常数\n\n% 初始化波函数\npsi = exp(-x.^2);\npsi_next = zeros(size(x));\n\n% 迭代计算\nfor n = 1:length(t)-1\n    for j = 3:length(x)-2 % 注意边界点的处理\n        % 计算波函数的一阶和二阶导数\n        dpsi = (psi(j+1)-psi(j-1))/(2*h);\n        d2psi = (psi(j+1)-2*psi(j)+psi(j-1))/h^2;\n        % 计算新的波函数值\n        psi_next(j) = psi(j) + dt*1i*hbar/(2*m)*d2psi + ...\n            dt*1i*hbar/(h^2)*V(j)*psi(j) + ...\n            dt*1i*hbar*g/(h^2)*abs(psi(j))^2*psi(j);\n    end\n    % 更新波函数\n    psi = psi_next;\n    % 将边界点的值设置为零\n    psi(1:2) = 0;\n    psi(end-1:end) = 0;\nend\n\n% 绘制波函数的时空演化图像\n[X, T] = meshgrid(x, t);\nPsiReal = real(psi).*exp(-1i*hbar/(2*m)*((x-mean(x)).^2)/hbar*n); % 实部\nPsiReal = repmat(PsiReal, size(X,1), 1);  % 添加这行代码\nPsiImag = imag(psi).*exp(-1i*hbar/(2*m)*((x-mean(x)).^2)/hbar*n); % 虚部\nPsiImag = repmat(PsiImag, size(X,1), 1);  % 添加这行代码\n%Z = abs(psi).^2; % 概率密度\nZ = repmat(abs(psi).^2, length(t), 1);\nfigure;\nmesh(X, T, ones(size(X))*max(abs(psi(:))).*Z, 'facecolor','flat');\nxlabel('Position');\nylabel('Time');\nzlabel('Probability density');\nfigure;\nsurf(real(X), real(T), real(PsiReal), 'facecolor', 'flat');\nxlabel('Position');\nylabel('Time');\nzlabel('Real part');\nfigure;\nsurf(real(X), real(T), real(Z), 'facecolor', 'flat');\nxlabel('Position');\nylabel('Time');\nzlabel('Imaginary part');\n\n这段代码中，我们使用了两重循环来计算每个时间步长中波函数在所有空间点上的值。其中，内层循环遍历空间网格上的所有内部点，使用中心差分法计算波函数在这些点的一阶和二阶导数，并根据紧致差分格式的公式计算出新的波函数值。外层循环则遍历所有的时间步长，通过多次迭代得到波函数的时空演化图像。\n注意到在代码中，我们使用 mesh 函数将波函数的时空演化图像绘制出来，并且将横轴和纵轴分别设为空间坐标和时间。图像的高度表示波函数的概率密度，可以通过调整视角和颜色映射来观察波函数的演化特征。", "Konwledge_Point": "线性规划和规约", "Question": "非线性薛定谔方程的四阶紧致差分格式\n非线性薛定谔方程的四阶紧致差分格式求解过程\n要求论述有条理，理论叙述详尽\n题主原理已经写出来了，但是通过原理写不出代码，所以想要有一个对比，希望大家帮帮忙", "Tag": "算法分析"}
{"Answer": "\nGolint is newly released this week: https://github.com/golang/lint\n", "Konwledge_Point": "线性规划和规约", "Question": "Go语言的静态代码分析（线性）工具\n\n\n\nIs there a static analysis tool for Go language –like \nlint\n, \npylint\n etc? As far as I googled, I haven't found anything related.\n\n\n\nI may do this as an undergrad senior project in my department. I must be sure that it is not done before. Any help is appreciated.\n\n    ", "Tag": "算法分析"}
{"Answer": "对于相似矩阵，如果存在一个可逆矩阵P，使得 A=PBP^(-1) ，那么矩阵A和B就是相似的。\n对于给定的矩阵B，我们可以假设可逆矩阵P为：\nP = （2，-1，1）(1，1，2）(-2，1，1）\n那么A=PBP^(-1) 。\n因此，I2A + EI = 2I + E = 3I\n结论是I2A + EI = 3I，其中I是单位矩阵。如果答案有帮助 请帮我点个采纳 谢谢", "Konwledge_Point": "线性规划和规约", "Question": "关于#线性代数#的问题，如何解决？\n发不了图片，我来叙述一下\nA和B是相似矩阵给出了\nB=4，1，0\n    -1，-1，0\n    9，-3，4\n然后求I2A+EI", "Tag": "算法分析"}
{"Answer": "> stray'\\241'in program\r\n\r\n一般是 **中文空格中文引号等中文标点符号**  所致\r\n目测出错语句中hwnd和(HMENU)5之间间隔比起别的语句大一些？\r\n\r\n你可以尝试删除此句，重新输入。\r\n或者拷贝类似语句，修改一下。", "Konwledge_Point": "线性规划和规约", "Question": "求大神， C语言的问题\nLRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {\n\n    HDC hdc;\n\n    PAINTSTRUCT ps;\n\n\n\nstatic HFONT hFont;     // 逻辑字体 \nstatic HWND hLabExample;    // 静态文本框--用户名 \nstatic HWND hLabPassword;   // 静态文本框--密码 \nstatic HWND hEditUsername;  // 单行文本输入框\nstatic HWND hEditPassword;  // 密码输入框 \nstatic HWND hBtnLogin;      // 登录按钮\n\nswitch (message) {\ncase WM_CREATE:\n    hFont = CreateFont(\n        -15, -7.5, 0, 0, 400,   // 高， 宽， -----  \n        FALSE, FALSE, FALSE,\n        DEFAULT_CHARSET,\n        OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,\n        DEFAULT_QUALITY,\n        FF_DONTCARE,\n        TEXT(\"微软雅黑\")\n    );\n    hLabExample = CreateWindow(\n        TEXT(\"static\"),\n        TEXT(\"用户名：\"),\n        WS_CHILD | WS_VISIBLE | SS_CENTERIMAGE | SS_RIGHT,  // 子窗口 创建时可见 垂直居中 水平居右  \n        0, 20, 70, 26,  // x坐标 y坐标 宽度 高度 \n        hwnd, (HMENU)1, hInst, NULL //  父窗口句柄 空间id 当前程序实例句柄  --  \n    );\n\n    hLabPassword = CreateWindow(\n        TEXT(\"static\"),\n        TEXT(\"密码：\"),\n        WS_CHILD | WS_VISIBLE | SS_CENTERIMAGE | SS_RIGHT,\n        0, 56, 70, 26,\n        hwnd, (HMENU)2, hInst, NULL\n    ); \n\n    hEditUsername= CreateWindow(\n        TEXT(\"edit\"),\n        TEXT(\"\"),\n        WS_CHILD | WS_VISIBLE | WS_BORDER| ES_AUTOHSCROLL,\n        80, 20, 200, 26,\n        hwnd, (HMENU)3, hInst, NULL\n    );\n\n    hEditPassword = CreateWindow(\n        TEXT(\"edit\"),\n        TEXT(\"\"),\n        WS_CHILD | WS_VISIBLE | WS_BORDER | ES_AUTOHSCROLL,\n        80, 56, 200, 26,\n        hwnd, (HMENU)4, hInst, NULL\n    ); \n\n    hBtnLogin = CreateWindow(\n        TEXT(\"button\"),\n        TEXT(\"登录\"),\n        WS_CHILD | WS_VISIBLE | WS_BORDER |　BS_FLAT,\n        80, 92, 200, 30,\n        hwnd,  (HMENU)5, hInst, NULL\n    );\n\n    SendMessage(hLabExample,   WM_SETFONT, (WPARAM)hFont, NULL);\n    SendMessage(hLabPassword,  WM_SETFONT, (WPARAM)hFont, NULL);\n    SendMessage(hEditUsername,  WM_SETFONT, (WPARAM)hFont, NULL);\n    SendMessage(hEditPassword, WM_SETFONT, (WPARAM)hFont, NULL);\n    SendMessage(hBtnLogin,     WM_SETFONT, (WPARAM)hFont, NULL);\n\n    break;\ncase WM_COMMAND:\n    break;\ncase WM_PAINT:\n    hdc = BeginPaint(hwnd, &ps);\n\n    EndPaint(hwnd, &ps);\n    break;\ncase WM_DESTROY:\n    DeleteObject(hFont);\n    PostQuitMessage(0);\n    break;\ndefault:\n    return DefWindowProc(hwnd, message, wParam, lParam);\n}\nreturn 0;\n\n\n\n\n}\n\n出错 stray“\\241” in program 就给hBtnLogin赋值那几行", "Tag": "算法分析"}
{"Answer": "将nan替换为0，参考一下这里：\nstatsmodels.tools.sm_exceptions.MissingDataError: exog contains inf or nans - 三水一人山 - 博客园\n出现：statsmodels.tools.sm_exceptions.MissingDataError: exog contains inf or nans 只需要把数据中的inf或者nan变成0即可\n\n\n\nhttps://www.cnblogs.com/houfei/p/13546163.html\n\n", "Konwledge_Point": "线性规划和规约", "Question": "python如何做回归滞后项?\n为什么结果出现“exog contains inf or nans”？\n，怎样PYTHON依次做回归？\n原代码：\n\n\n\n\n为什么结果出现“exog contains inf or nans”？\n\n\n\n", "Tag": "算法分析"}
{"Answer": "文章：Scipy优化scipy.optimize.minimize 中也许有你想要的答案，请看下吧", "Konwledge_Point": "线性规划和规约", "Question": "scipy中的minimize报错\n\n\n\n\n这是我在写非线性规划时报错，f0不是以为，但是我翻了很多资料都找不到f0到底是什么东西，求大佬解答", "Tag": "算法分析"}
{"Answer": "model.coef_斜率model.intercept_截距", "Konwledge_Point": "线性规划和规约", "Question": "LinearRegression没有coef，我想要求线性回归的系数\njieguo=pd.DataFrame()\ndate=pd.DataFrame()\nfor g in CID:\n    res =data[data['ID']==g]\n    if res['time'].max==1:\n        k=0\n    else:\n        X = res['time'].values.reshape(-1, 1)\n        Y = res['count'].values.reshape(-1, 1)\n        model = LinearRegression().fit(X, Y)\n        \nk = model.coef\n        jieguo['K'] = k\n    jieguo['ID']=g\n    date = pd.concat([date, jieguo], ignore_index=True)\n\n\nTraceback (most recent call last):\n  File \"F:\\学习\\wer\\w\\F变化趋势.py\", line 27, in \n    KK = model.coef\nAttributeError: 'LinearRegression' object has no attribute 'coef'", "Tag": "算法分析"}
{"Answer": "我后来发现，是我大意了，在函数里面，np.exp()里面1/2与后面的部分相乘，我把*号省略了。python里面的数字与数字之间的*是不能省略的。", "Konwledge_Point": "线性规划和规约", "Question": "scipy解非线性方程组报错TypeError: 'int' object is not callable\nscipy解非线性方程组报错TypeError: 'int' object is not callable。网上说是参数和函数重名的缘故，但貌似我的并没有重名，代码如下：\n\n\n\nfrom scipy.integrate import odeint\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.optimize import root,fsolve\n\ndef fun(x):\n    for i in range(0,len(x)):\n        x[i] = float(x[i])\n    fy = np.array([(x[0]*2010**x[1])*np.exp(-1/2(39.9612**2/(x[2]*2010**x[3])+(-75.2303)**2/(x[4]*2010**x[5])-6259)),(x[0]*2011**x[1])*np.exp(-1/2(39.9612**2/(x[2]*2011**x[3])+(-75.2303)**2/(x[4]*2011**x[5])-5958)),(x[0]*2012**x[1])*np.exp(-1/2(41.3866**2/(x[2]*2012**x[3])+(-81.4421)**2/(x[4]*2012**x[5])-2624)),(x[0]*2014**x[1])*np.exp(-1/2(39.9612**2/(x[2]*2014**x[3])+(-75.2303)**2/(x[4]*2014**x[5])-4809)),(x[0]*2015**x[1])*np.exp(-1/2(39.701**2/(x[2]*2015**x[3])+(-84.2187)**2/(x[4]*2015**x[5])-3877)),(x[0]*2017**x[1])*np.exp(-1/2(41.3866**2/(x[2]*2017**x[3])+(-81.4421)**2/(x[4]*2017**x[5])-7381))])\n    return fy\nres_fsolve = fsolve(fun,[1,1,1,1,1,1])\nprint(res_fsolve)\n\n\n\n\n报错内容如下：\n\n\n\n\n\nTypeError                                 Traceback (most recent call last)\n in \n\n      9     fy = np.array([(x[0]*2010**x[1])*np.exp(-1/2(39.9612**2/(x[2]*2010**x[3])+(-75.2303)**2/(x[4]*2010**x[5])-6259)),(x[0]*2011**x[1])*np.exp(-1/2(39.9612**2/(x[2]*2011**x[3])+(-75.2303)**2/(x[4]*2011**x[5])-5958)),(x[0]*2012**x[1])*np.exp(-1/2(41.3866**2/(x[2]*2012**x[3])+(-81.4421)**2/(x[4]*2012**x[5])-2624)),(x[0]*2014**x[1])*np.exp(-1/2(39.9612**2/(x[2]*2014**x[3])+(-75.2303)**2/(x[4]*2014**x[5])-4809)),(x[0]*2015**x[1])*np.exp(-1/2(39.701**2/(x[2]*2015**x[3])+(-84.2187)**2/(x[4]*2015**x[5])-3877)),(x[0]*2017**x[1])*np.exp(-1/2(41.3866**2/(x[2]*2017**x[3])+(-81.4421)**2/(x[4]*2017**x[5])-7381))])\n\n     10     return fy\n\n---> 11 res_fsolve = fsolve(fun,[1,1,1,1,1,1])\n\n     12 print(res_fsolve)\n\n\n\nc:\\users\\anton\\appdata\\local\\programs\\python\\python36\\lib\\site-packages\\scipy\\optimize\\minpack.py in fsolve(func, x0, args, fprime, full_output, col_deriv, xtol, maxfev, band, epsfcn, factor, diag)\n\n    145                'diag': diag}\n\n    146 \n\n--> 147     res = _root_hybr(func, x0, args, jac=fprime, **options)\n\n    148     if full_output:\n\n    149         x = res['x']\n\n\n\nc:\\users\\anton\\appdata\\local\\programs\\python\\python36\\lib\\site-packages\\scipy\\optimize\\minpack.py in _root_hybr(func, x0, args, jac, col_deriv, xtol, maxfev, band, eps, factor, diag, **unknown_options)\n\n    211     if not isinstance(args, tuple):\n\n    212         args = (args,)\n\n--> 213     shape, dtype = _check_func('fsolve', 'func', func, x0, args, n, (n,))\n\n    214     if epsfcn is None:\n\n    215         epsfcn = finfo(dtype).eps\n\n\n\nc:\\users\\anton\\appdata\\local\\programs\\python\\python36\\lib\\site-packages\\scipy\\optimize\\minpack.py in _check_func(checker, argname, thefunc, x0, args, numinputs, output_shape)\n\n     24 def _check_func(checker, argname, thefunc, x0, args, numinputs,\n\n     25                 output_shape=None):\n\n---> 26     res = atleast_1d(thefunc(*((x0[:numinputs],) + args)))\n\n     27     if (output_shape is not None) and (shape(res) != output_shape):\n\n     28         if (output_shape[0] != 1):\n\n\n\n in fun(x)\n\n      7     for i in range(0,len(x)):\n\n      8         x[i] = float(x[i])\n\n----> 9     fy = np.array([(x[0]*2010**x[1])*np.exp(-1/2(39.9612**2/(x[2]*2010**x[3])+(-75.2303)**2/(x[4]*2010**x[5])-6259)),(x[0]*2011**x[1])*np.exp(-1/2(39.9612**2/(x[2]*2011**x[3])+(-75.2303)**2/(x[4]*2011**x[5])-5958)),(x[0]*2012**x[1])*np.exp(-1/2(41.3866**2/(x[2]*2012**x[3])+(-81.4421)**2/(x[4]*2012**x[5])-2624)),(x[0]*2014**x[1])*np.exp(-1/2(39.9612**2/(x[2]*2014**x[3])+(-75.2303)**2/(x[4]*2014**x[5])-4809)),(x[0]*2015**x[1])*np.exp(-1/2(39.701**2/(x[2]*2015**x[3])+(-84.2187)**2/(x[4]*2015**x[5])-3877)),(x[0]*2017**x[1])*np.exp(-1/2(41.3866**2/(x[2]*2017**x[3])+(-81.4421)**2/(x[4]*2017**x[5])-7381))])\n\n     10     return fy\n\n     11 res_fsolve = fsolve(fun,[1,1,1,1,1,1])\n\n\n\nTypeError: 'int' object is not callable\n\n", "Tag": "算法分析"}
{"Answer": "偏离直线的点，就是 abs(x/y-直线的斜率) > 某个数的点", "Konwledge_Point": "线性规划和规约", "Question": "关于剔除一组数据中明显偏离直线的数据的问题\n初学者，在做图片处理的东西，现在得到了如图所示的图像，想要请教一下大佬们，把那些距离直线很远的点去掉该怎么用C#实现，或者请大佬说一下好的思路或者方法也可以。", "Tag": "算法分析"}
{"Answer": "你这属于滑动空间嵌套滑动空间问题  需要重写listview  要不然就会出现显示不全的问题 还有滑动冲突问题 \r\n自定义一个listview 继承 listview 重写onmeasure 方法 重新测量高度 \r\n\r\n@Override\r\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\r\n        int measureSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE >> 2, MeasureSpec.AT_MOST);\r\n\r\n        super.onMeasure(widthMeasureSpec, measureSpec);\r\n\r\n    }\r\n\t\t\r\n很简单 重写这一个方法就可以 然后再xml 文件中引用就好了 你试一下", "Konwledge_Point": "线性规划和规约", "Question": "Android 线性布局ScrollView嵌套以及TextView设置background的小问题\nScrollView 部分布局\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    布局效果图：\n    ![图片说明](https://img-ask.csdn.net/upload/201804/24/1524541534_568444.png)\n\n    实际效果图：\n    ![图片说明](https://img-ask.csdn.net/upload/201804/24/1524541656_487597.png)\n\n    期望效果：\n      实现类似于饿了么的那种界面，把listview的界面填充出去，如图下：\n\n![图片说明](https://img-ask.csdn.net/upload/201804/24/1524542251_73813.png)\n\n        TextView的设置background的bug:\n\n        TextView代码：\n        \n                效果：\n                ![图片说明](https://img-ask.csdn.net/upload/201804/24/1524542466_880111.png)\n                background的效果并没有运用上去，附其他可用的TextView的效果，如图下：\n                ![图片说明](https://img-ask.csdn.net/upload/201804/24/1524542599_493676.png)\n", "Tag": "算法分析"}
{"Answer": "不是问过了么〉。。。。。。\n#include  <iostream>\nusing namespace std;\ntypedef struct _sqlist\n{\n    int data[1000];\n    int length;\n}sqlist;\n \nvoid create(sqlist *s,int m,int n)\n{\n    int i=0;\n    printf(\"请输入%d个递增数:\\n\",m);\n    for(i=0;i<m;i++)\n        scanf(\"%d\",&s->data[i]);\n    printf(\"请输入%d个递增数:\\n\",n);\n    for(i=0;i<n;i++)\n        scanf(\"%d\",&s->data[i+m]);\n    s->length = m+n;\n}\n \nvoid sorts(sqlist *s,int m,int n)\n{\n    int i,j,k,t;\n    for(i=m;i<s->length;i++)\n    {\n        t = s->data[i];\n        for(j=0;j<i;j++)\n        {\n            if(s->data[j] >= s->data[i])\n            {\n                for(k=i;k>j;k--)\n                    s->data[k] = s->data[k-1];\n                s->data[j] = t;\n                break;\n            }\n        }\n    }\n}\n \nvoid print(sqlist *s)\n{\n    int i=0;\n    for(i=0;i<s->length;i++)\n        printf(\"%d \",s->data[i]);\n}\n \nint main()\n{\n    sqlist s;\n    int m,n;\n    printf(\"请输入两个递增序列的数量:\\n\");\n    scanf(\"%d%d\",&m,&n);\n    create(&s,m,n);\n    sorts(&s,m,n);\n    print(&s);\n    return 0;\n}\n \n\n", "Konwledge_Point": "线性规划和规约", "Question": "关于#c语言#的问题：有一个存放整数的长度为m+n的线性表L，其前m个元素单调递增，后n个元素也单调递增\n有一个存放整数的长度为m+n的线性表L，其前m个元素单调递增，后n个元素也单调递增。设计一个算法，使得整个线性表的元素单调递增。要求：使用链式存储实现。", "Tag": "算法分析"}
{"Answer": "梯度优化的时候训练参数值没发计算，加个数据归一化处理。", "Konwledge_Point": "线性规划和规约", "Question": "线性回归，回答正确加酬金（我开设了几个问题）\n问题遇到的现象和发生背景\n\n\n输出空值，线性回归计算\n\n\n问题相关代码，请勿粘贴截图\n\n\nimport\n cv2\n\nimport\n numpy \nas\n np\n\nimport\n matplotlib.pyplot \nas\n plt\n\n\nimg = cv2.imread(\nr'C:\\Users\\Xpc\\Desktop\\weixin2222 change40.jpg'\n)\nhsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\nlow_hsv = np.array([\n0\n, \n0\n, \n221\n])\nhigh_hsv = np.array([\n180\n, \n30\n, \n255\n])\nmask = cv2.inRange(hsv, lowerb=low_hsv, upperb=high_hsv)\n\n\nlist_y = []\nlist_x = []\n\n\nfor\n i \nin\n \nrange\n(\nlen\n(mask)):\n    xmax = []\n    \nfor\n j \nin\n \nrange\n(\nlen\n(mask[i])):\n        \nif\n mask[i][j] == \n0\n:\n            list_x.append(j)\n            list_y.append(\nlen\n(mask)-i)\n\nplt.plot(list_x, list_y, \n'o'\n, color=\n'r'\n)\nplt.show()\n\nx_array=np.array(list_x)\nx_array=x_array/\n400\n\ny_array=np.array(list_y)\ny_array=y_array*\n0.2\n/\n400\n\n\nz40=np.stack((x_array,y_array),axis=\n0\n).T\nz0=[]\n\nfor\n i \nin\n \nrange\n(\n0\n,z40.shape[\n0\n],\n30\n):\n    z1=z40[i,:]\n    z0.append(z1)\nz0=np.array(z0)\n\nx_array=z0[:,\n0\n]\ny_array=z0[:,\n1\n]\n\nprint\n(x_array)\n\nprint\n(y_array)\n\nlist_x1=[]\n\nfor\n i \nin\n \nrange\n(\n0\n,\nlen\n(x_array)):\n    list_x1.append(\n40\n)\nx1_array=np.array(list_x1)\n\nlist_x0=[]\n\nfor\n i \nin\n \nrange\n(\n0\n,\nlen\n(x_array)):\n    list_x0.append(\n1\n)\nx0=np.array(list_x0)\nx1=x_array\nx2=x1_array\nx3=x1*x2\nx4=x1*x1\nx5=x2*x2\nlabel40=y_array\n\n\n\nz40=np.stack((x0,x1,x2,x3,x4,x5),axis=\n0\n).T\n\nrescombine = z40\nlabels= y_array\ndata=rescombine\n\nnp.seterr(divide=\n'ignore'\n,invalid=\n'ignore'\n)\n\nclass\n \nLinearRegression\n:\n    \ndef\n \n__init__\n(\nself,data,labels\n):\n        self.data = data\n        self.labels = labels\n        num_features = \nlen\n(data[\n0\n])\n        self.theta = np.zeros((num_features,\n1\n))\n        \n\n\n    \ndef\n \ntrain\n(\nself,alpha,num_iterations = \n500\n):\n       \n        cost_history = self.gradient_descent(alpha,num_iterations)\n        \nreturn\n self.theta,cost_history\n        \n    \ndef\n \ngradient_descent\n(\nself,alpha,num_iterations\n):\n        cost_history= []\n        \nfor\n _ \nin\n \nrange\n(num_iterations):\n            self.gradient_step(alpha)\n            cost_history.append(self.cost_function(self.data,self.labels))\n        \nreturn\n cost_history\n        \n        \n    \ndef\n \ngradient_step\n(\nself,alpha\n):    \n        num_examples = data.shape[\n0\n]\n        prediction = LinearRegression.hypothesis(self.data,self.theta)\n        delta = prediction - self.labels\n        theta = self.theta\n        theta = theta - alpha*(\n1\n/num_examples)*(np.dot(delta.T,self.data)).T\n        self.theta = theta\n        \n        \n    \ndef\n \ncost_function\n(\nself,data,labels\n):\n        self.m = \nlen\n(labels) \n        delta = LinearRegression.hypothesis(data,self.theta) - labels\n        cost = (\n1\n/\n2\n)*np.dot(delta.T,delta)/self.m\n        \nreturn\n cost[\n0\n][\n0\n]\n        \n    \n    \ndef\n \nhypothesis\n(\ndata,theta\n):   \n        predictions = np.dot(data,theta)\n        \nreturn\n predictions\n        \n\nx_train = rescombine\n\ny_train = labels\n\nnum_iterations = \n500\n\nlearning_rate = \n0.01\n  \n\n\nlinear_regression = LinearRegression(x_train, y_train)\n\n(theta, cost_history) = linear_regression.train(learning_rate, num_iterations)\n\n\n\n\nprint\n (theta, cost_history)\n\nprint\n(\nlen\n( cost_history))\n\n\n\n\n\n\n\n运行结果及报错内容\n\n\n[0.3025 0.315  0.3275 0.3425 0.36   0.365  0.3775 0.395  0.41   0.4325\n 0.4475 0.46   0.4825 0.4925 0.5075 0.52   0.5375 0.5625 0.995  0.5825\n 0.9825 0.6    0.945  0.95   0.955  0.9525 0.63   0.6475 0.6475 0.655\n 0.8975 0.86   0.8125 0.685  0.805  0.71   0.785  0.7475 0.8225]\n[0.1365 0.1305 0.125  0.121  0.1175 0.114  0.111  0.1065 0.103  0.0985\n 0.0945 0.092  0.0895 0.087  0.0845 0.082  0.0795 0.0775 0.0755 0.074\n 0.0735 0.0725 0.072  0.0715 0.071  0.0705 0.0695 0.069  0.0685 0.068\n 0.068  0.0675 0.067  0.0665 0.0665 0.066  0.066  0.0655 0.0655]\n[[nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n  nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n  nan nan nan]\n [nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n  nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n  nan nan nan]\n [nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n  nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n  nan nan nan]\n [nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n  nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n  nan nan nan]\n [nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n  nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n  nan nan nan]\n [nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n  nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n  nan nan nan]] [6115546.293053937, 4014534661896851.5, 2.635330971147491e+24, 1.729956249576308e+33, 1.1356253382264945e+42, 7.454783374654096e+50, 4.893673405509658e+59, 3.2124393421296037e+68, 2.1087975579333355e+77, 1.3843147423906104e+86, 9.087298582980243e+94, 5.965333822395535e+103, 3.915928071216269e+112, 2.5706009278759203e+121, 1.687464378870506e+130, 1.1077316588031153e+139, 7.27167603227295e+147, 4.7734730607470265e+156, 3.1335341344346484e+165, 2.0570004369377248e+174, 1.3503126553064964e+183, 8.864092755348704e+191, 5.818810929946509e+200, 3.819743494677929e+209, 2.5074608095693e+218, 1.6460162103256778e+227, 1.080523114983515e+236, 7.093066244971383e+244, 4.656225124468534e+253, 3.0565670277085482e+262, 2.006475577346884e+271, 1.3171457409549063e+280, 8.646369397676056e+288, 5.675886990825303e+297, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan]\n500\n\n\n我的解答思路和尝试过的方法\n\n\n很懵\n\n\n我想要达到的结果\n\n\n正常运算", "Tag": "算法分析"}
{"Answer": "这个需要用数据拟合，而且要找出数据边界，即x在升稳降中的范围，才好用np分段拟合，参考https://blog.csdn.net/qq_42272539/article/details/91196087", "Konwledge_Point": "线性规划和规约", "Question": "python如何实现三维图像的分段线性拟合，并给出分段函数\n如图，x轴是时间，y,z轴表示变量，随着时间是上升——平稳——下降的趋势，怎么求出y和z之间的分段函数", "Tag": "算法分析"}
{"Answer": "如果你的温度-时间曲线可以用分段函数来拟合，那么你可以将分段函数的参数作为优化变量，使用Levenberg–Marquardt算法对这些参数进行拟合，从而得到最优的参数解。\n具体来说，你需要首先定义一个分段函数的模型，比如：\ndef piecewise_func(t, params):\n    \"\"\"\n    分段函数模型，其中params是一个列表，包含每个段的参数\n    \"\"\"\n    num_segments = len(params) // 3\n    result = np.zeros_like(t)\n    for i in range(num_segments):\n        offset = i * 3\n        a, b, c = params[offset:offset+3]\n        result[t >= a] = b * (t[t >= a] - a) + c\n    return result\n\n在上面的代码中，我们假设分段函数有多个段，每个段的参数包括一个起始时间 $a$，一个斜率 $b$ 和一个截距 $c$，并且将这些参数存储在一个列表 params 中。然后，我们使用一个循环来逐个计算每个段的函数值，并将它们组合起来得到整个分段函数的函数值。\n接下来，你可以使用 scipy.optimize.curve_fit 函数来对分段函数进行拟合。具体来说，你需要将分段函数模型作为第一个参数传递给 curve_fit 函数，并将时间和温度数据作为第二个和第三个参数传递进去。然后，你需要给出每个分段的初始参数值，将它们组合成一个初始参数列表，并将它作为 p0 参数传递给 curve_fit 函数。最后，你可以使用 method='lm' 参数指定使用Levenberg–Marquardt算法进行拟合。\n下面是一个示例代码，其中分段函数有两个段：\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\n# 定义分段函数模型\ndef piecewise_func(t, params):\n    \"\"\"\n    分段函数模型，其中params是一个列表，包含每个段的参数\n    \"\"\"\n    num_segments = len(params) // 3\n    result = np.zeros_like(t)\n    for i in range(num_segments):\n        offset = i * 3\n        a, b, c = params[offset:offset+3]\n        result[t >= a] = b * (t[t >= a] - a) + c\n    return result\n\n# 生成一些数据\nt = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\ny = np.array([20, 21, 25, 28, 30, 30, 28, 25, 22, 20])\n\n# 定义初始参数值\np0 = [2, 2, 20, 6, -2, 30]\n\n# 对分段函数进行拟合\nparams, _ = curve_fit(piecewise_func, t, y, p0=p0, method='lm')\n\n# 输出拟合结果\n\n拟合结果 params 是一个包含每个分段的参数的列表。假设我们在上面的代码中使用了初始参数值 [2, 2, 20, 6, -2, 30]，表示分段函数有两个段，第一个段的起始时间为 2，斜率为 2，截距为 20，第二个段的起始时间为 6，斜率为 -2，截距为 30。对这些初始参数进行拟合后，可以得到最优的参数值：\n>>> print(params)\n[2.0, 2.33333333, 20.66666667, 6.0, -2.0, 30.0]\n\n可以看到，最优的参数值与初始参数值比较接近，这说明Levenberg–Marquardt算法能够在较短的时间内得到较好的拟合结果。", "Konwledge_Point": "线性规划和规约", "Question": "请教采用Levenberg–Marquardt算法求非线性分段函数的参数\n目前想用一个模型拟合一天的温度变化，模型如下，\n\n\n\n\n在保证已知六组以上温度-时间数值的情况下，如何采用Levenberg–Marquardt算法获得最优的参数解呢？\n已经搜索了网上的经验帖，但没有关于分段函数的讨论，还望解答\n\n\n（模型解释引自 孟翔晨, 刘昊, & 程洁. (2019). 基于FY-2F数据的中国区域地表温度日变化模型评价及特征研究. 遥感学报, 4, 570–581.）", "Tag": "算法分析"}
{"Answer": "推荐使用GridLayout，这样每个Button的大小和位置都固定了", "Konwledge_Point": "线性规划和规约", "Question": "Android线性布局问题，调整了一下button文本内容位置，button大小发生了变化，如下图\nandroid:paddingRight=\"10dp\"\n\n android:paddingBottom=\"10dp\"\n\n这是对于C按钮添加的代码，用的都是linearlayout布局，求大牛解答，新人积分少，见谅哈，在此谢谢各位了", "Tag": "算法分析"}
{"Answer": "你已经求得垂直的向量为(i,-j,0*k)，所以这个area=[1^2+(－1)^2+0^2]的开方=2的开方", "Konwledge_Point": "线性规划和规约", "Question": "Linear algebra, Cramer’s rule, inverses and volumes线性代数\n\n\nIn example 8, 为什么area = 根号2？", "Tag": "算法分析"}
{"Answer": "都可以，看你怎么去写，你可以将指针放在第一个元素上，这个是带头结点的，不带头节点放在第一个元素之前你可以看我这篇文章：https://blog.csdn.net/qq_51553982/article/details/115730247", "Konwledge_Point": "线性规划和规约", "Question": "线性链表的插入算法的找位序是怎么初始化的？\n为什么PPT上显示是j从0开始，书上位序是从1开始的 ，如果都是对的话，为什么会不一样呢？", "Tag": "算法分析"}
{"Answer": "先化简为最简阶梯型矩阵，没有全为0的行，即为满秩，非满秩不可等价变为满秩，你问错地儿了吧", "Konwledge_Point": "线性规划和规约", "Question": "线性代数，怎么把矩阵变为等价的行满秩矩阵？\n怎么把矩阵变为等价的行满秩矩阵？\n怎么把矩阵变为等价的行满秩矩阵？\n怎么把矩阵变为等价的行满秩矩阵？", "Tag": "算法分析"}
{"Answer": "阅读理解，说的是空间复杂度", "Konwledge_Point": "线性规划和规约", "Question": "为什么n/2是常数性的啊？n就是线性的\n", "Tag": "算法分析"}
{"Answer": "\nSee Looking for actively maintained matrix math library for php\n", "Konwledge_Point": "线性规划和规约", "Question": "使用多个变量服务器为webapp求解线性方程？ 有可能与PHP？\n\n\n\nI have a gerneral question on php. Hope its ok to ask here. \n\n\n\nHow would you solve a linear Equation with multiple variables in the web? maybe using Gaussian elimination or ... ? Is it possible with php and recommendable?\n\n\n\n1500 + 100 w                 = 10,000 s\n3000 + 1000 s                = 3000 w\n5000 + 2000 s + 100 w + 30 r = 150 r\n\n=>   s = 0,16 | w = 1,05 | r = 45,21\n\n\n    ", "Tag": "算法分析"}
{"Answer": "latent里的分类变量改写成  _Isex_1格式，参照表格里的变量名", "Konwledge_Point": "线性规划和规约", "Question": "stata多元线性回归时系数集束法如何使用，对变量有何要求？\nstata系数集束化到底要怎么使用？\n最重要的是我的操作为啥会错误？\n我真的想不明白呀😭😭\n\n", "Tag": "算法分析"}
{"Answer": "题目已经自己解答出来，只需要把\r\n\r\n```\r\nelse if(N % K == 0 && N / K != 1)\r\n```\r\n的N% K==0删除即可\r\n应该说是N%K有余数也需要按照反转多次的办法来", "Konwledge_Point": "线性规划和规约", "Question": "PTA线性结构3 Reversing Linked List【直接贴答案将不予采纳，谢谢合作】\n#include \nusing namespace std;\n\nstruct Node\n{\n    int adrs;\n    int data;\n    int next;\n    struct Node* link;\n};\n\n\nNode* reverselink(struct Node* node, int K)\n{\n    struct Node* initnode = node;\n    struct Node* newnode = node -> link;\n    struct Node* oldnode = newnode -> link;\n    struct Node* temp;\n\n    int count = 1;\n\n    while(count < K)\n    {\n        temp = oldnode -> link;\n        oldnode -> link = newnode;\n        newnode = oldnode;\n        oldnode = temp;\n        count++;\n    }\n\n    initnode -> link -> link = oldnode;\n\n    return newnode;\n}\n\nvoid print(struct Node* initNode)\n{\n    while(initNode != NULL)\n    {\n        if(initNode -> link != NULL)\n        {\n            printf(\"%05d %d %05d\\n\", initNode -> adrs, initNode -> data, initNode -> link -> adrs);\n\n        }\n        else\n        {\n            printf(\"%05d %d %d\\n\", initNode -> adrs, initNode -> data, -1);\n        }\n\n        initNode  = initNode -> link;\n    }\n}\n\nint main()\n{\n    int start = 0;\n    int N = 0;\n    int K = 0;\n    scanf(\"%d %d %d\",&start, &N, &K);\n    int adrs = -1;\n    int cnt = 0;\n\n    int data[100000] = {0};\n    int next[100000] = {0};\n    while(cnt < N)\n    {\n        scanf(\"%d\", &adrs);\n        scanf(\"%d\", &data[adrs]);\n        scanf(\"%d\", &next[adrs]);\n        cnt++;\n    }\n    //解决多余结点\n    int actualNum = 0;\n    struct Node* initNode = new Node;\n    struct Node* prevNode = initNode;\n    struct Node* curNode = NULL;\n\n    for(int i = start; i <= 100000 && i != -1; )\n    {\n        curNode = new Node;\n        curNode -> data = data[i];\n        curNode -> adrs = i;\n        curNode -> next = next[i];\n        curNode -> link = NULL;//////\n        prevNode -> link = curNode;\n        prevNode = curNode;\n        i = next[i];\n        actualNum++;\n    }\n    cnt = 0;\n    N = actualNum;\n\n    curNode -> link = NULL;\n\n    if(K == 1)//直接输出\n    {\n        initNode = initNode -> link;\n    }\n    else if(K == N || (N / K == 1 && N % K != 0))//全反转  有尾巴不反转\n    {\n        initNode = reverselink(initNode, K);\n    }\n    else if(N % K == 0 && N / K != 1)\n    {\n        int count = 1;\n        int flag = 0;\n        struct Node* markNode = initNode;\n        struct Node* firstNode = initNode;\n        while(cnt < N / K)\n        {\n            initNode = reverselink(initNode, K);\n            markNode -> link = initNode;\n            cnt++;\n            while(count < K && cnt < N / K)\n            {\n                initNode = initNode -> link;\n                count++;\n            }\n            markNode = initNode;\n            count = 1;\n        }\n        initNode = firstNode -> link;\n    }\n    print(initNode);\n}\n\n\n\n\n\n\n\n\n\n\n请勿贴他人的代码，贴他人的代码及网址回答将不会采纳。", "Tag": "算法分析"}
{"Answer": "请看一下你的TestActivity中的第83行代码，那一行出现了空指针异常，先把空指针异常处理了，应该就没事了。\r\n一般情况下，出现error的话，都需要先找到错误的地方，一般都是看Caused by:......的下一行，会指出你的那一行代码出了什么问题，然后就可以去解决相应的异常！", "Konwledge_Point": "线性规划和规约", "Question": "向线性布局中动态添加textview出现闪退，代码如下，这是什么原因？？\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n\n        // TODO Auto-generated method stub\n\n        switch (requestCode) {\n\n        case 1:\n\n            if(resultCode==RESULT_OK){\n\n                personalNumber=data.getStringExtra(\"personal\");\n\n                allow=1;\n\n                Log.d(\"TestActivity\", personalNumber);\n\n\n\n            linearToLogin = (LinearLayout) findViewById(R.id.ll_to_login);\n            TextView firstTextView=new TextView(this);\n            firstTextView.setText(\"尊敬的：  \"+personalNumber);\n            firstTextView.setTextSize(16);\n            firstTextView.setGravity(Gravity.CENTER_HORIZONTAL);\n            LinearLayout.LayoutParams view01Params = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,\n                      ViewGroup.LayoutParams.WRAP_CONTENT);\n            ((ViewGroup) firstTextView.getParent()).removeView(firstTextView);\n             linearToLogin.addView(firstTextView,view01Params);\n\n            TextView welcomeTextView=new TextView(this);\n            welcomeTextView.setText(\"欢迎使用畅心停车\");\n            welcomeTextView.setTextSize(16);\n            welcomeTextView.setGravity(Gravity.CENTER_HORIZONTAL);\n            LinearLayout.LayoutParams view02Params = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,\n                      ViewGroup.LayoutParams.WRAP_CONTENT);\n            ((ViewGroup) welcomeTextView.getParent()).removeView(welcomeTextView);\n             linearToLogin.addView(firstTextView,view02Params);\n             Log.d(\"TestActivity布局\", \"填加完成\");\n        }\n        break;\n\n    default:\n        break;\n    }\n\n    这是logcat\n\n\n\n\n_", "Tag": "算法分析"}
{"Answer": "给出你的例子，有可能行列式等于零了，即方程非满秩。", "Konwledge_Point": "线性规划和规约", "Question": "解3元线性方程组，为什么输出结果总是nan或者0（有什么其他问题可以随便提出来，xie）\n\n\n#include\n\n\n#include\n\n\nint\n main()\n{\n    \nint\n a,b,c,d,e,f,g,h,i,j,k,l;\n    scanf(\n\"%d %d %d %d\"\n,&a,&b,&c,&d);\n    scanf(\n\"%d %d %d %d\"\n,&e,&f,&g,&h);\n    scanf(\n\"%d %d %d %d\"\n,&i,&j,&k,&l);\n    \n    double D=\n0\n;\n    double E=\n0\n;\n    double F=\n0\n;\n    double G=\n0\n;\n                    \n    D=\nsqrt\n((a*f*k)+(b*g*i)+(c*e*j)-(c*f*i)-(b*e*k)-(g*j*a));\n    E=\nsqrt\n((d*f*k)+(b*j*l)+(h*j*c)-(c*f*l)-(g*j*d)-(k*b*h));\n    F=\nsqrt\n((a*h*k)+(d*g*i)+(c*e*l)-(c*h*i)-(g*l*a)-(d*e*k));\n    G=\nsqrt\n((a*f*l)+(b*h*i)+(e*j*d)-(d*f*i)-(e*b*l)-(a*h*j));\n    \n    \nprintf\n(\n\"x1=%lf\\n\"\n,E/D);\n    \nprintf\n(\n\"x2=%lf\\n\"\n,F/D);\n    \nprintf\n(\n\"x3=%lf\\n\"\n,G/D);\n    \n    \nreturn\n \n0\n;\n\n", "Tag": "算法分析"}
{"Answer": "提供下数据切分思路：\r\n```\r\n第一，pandas 导入数据，有 load API 方法可以直接用；\r\n第二，对 DataFrame 进行数据切割，就是按照索引规则取不同部分的数据。\r\n```\r\n参考资料：https://www.jb51.net/article/133653.htm", "Konwledge_Point": "线性规划和规约", "Question": "Python怎么利用sklearn将pandas读取的数据拆分成训练集和验证集\nPython用多元线性回归算法对Boston House Price Dataset数据集进行预测中，怎么利用sklearn将pandas读取的数据拆分成训练集和验证集", "Tag": "算法分析"}
{"Answer": "#include <iostream>\n\nusing namespace std;\n\nvoid swap(int *a, int *b) {\n  int t = *a;\n  *a = *b;\n  *b = t;\n}\n\nvoid selectionsort(int a[], int n) {\n  for (int i = 0; i < n - 1; i++) {\n    int min_idx = i;\n    for (int j = i + 1; j < n; j++)\n      if (a[j] < a[min_idx])\n        min_idx = j;\n    if (min_idx != i)\n      swap(&a[min_idx], &a[i]);\n  }\n}\n\nint binarysearch(int a[], int n, int value) {\n  int left = 0, right = n - 1;\n  while (left <= right) {\n    int m = (left + right) / 2;\n    if (a[m] < value)\n      left = m + 1;\n    else if (a[m] > value)\n      right = m - 1;\n    else\n      return m;\n  }\n  return -1;\n}\n\nint main() {\n  int test[] = {5658845, 4520125, 7895122, 8777541, 8451277, 1302850,\n                8080152, 4568555, 5552012, 5050552, 7825877, 1250255,\n                1005231, 6545231, 3852085, 7576651, 7881200, 4581002};\n  std::size_t size = sizeof(test) / sizeof(int);\n  selectionsort(test, size);\n  cout << \"请输入要查找的账号：\";\n  int account;\n  cin >> account;\n  int index = binarysearch(test, size, account);\n  if (index >= 0 && index < size)\n    cout << \"合法账号！\" << endl;\n  else\n    cout << \"非法账号！\" << endl;\n  return 0;\n}\n", "Konwledge_Point": "线性规划和规约", "Question": "编程，让用户输入一个一个账号，检验该账号是否出现在下面的列表中。如果属于下面列表中的账号，则输出合法信息，否则输出非法信息。采用线性查找方法实现该程序。\n\n\n5658845\n  \n4520125\n  \n7895122\n  \n8777541\n  \n8451277\n  \n1302850\n  \n80801524568555\n  \n5552012\n  \n5050552\n  \n7825877\n  \n1250255\n  \n1005231\n  \n65452313852085\n  \n7576651\n  \n7881200\n  \n4581002\n\n\n1\n、算法分析\n先用选择排序法装饰所给的账号排序，然后采用二分查找算法检验输入账号的合法性。\n\n2\n、参考代码\n#include\nusing namespace std\n;\n\nint binarysearch(int a[],int n=\n10\n,int value=\n0000000\n)\n;\n\nvoid selectionsort(int a[],int n=\n10\n)\n;\n\nint main()\n {    \nint test[]={\n5658845\n,\n4520125\n,\n7895122\n,\n8777541\n,\n8451277\n,\n1302850\n,\n8080152\n,\n4568555\n,\n5552012\n,\n5050552\n,\n7825877\n,\n1250255,1005231\n,\n6545231\n,\n3852085\n,\n7576651\n,\n7881200\n,\n4581002\n}\n;\n\nint accounts\n;selectionsort(test,18);\n\ncout<<”请输入要查找的账号：”\n;    \n\ncin>>accounts\n;    \n\nif(binarysearch(test,sizeof(test)/sizeof(test[\n0\n]),accounts))        \ncout<<”合法账号！”<<endl\n;    \n\nelse        \ncout<<”非法账号！”<<endl\n;    \n\nreturn \n0\n;\n\n}\n//选择排序函数void selectionsort(int a[],int n)\n//二分查找函数int binarysearch(int a[],int n,int value)\n", "Tag": "算法分析"}
{"Answer": "看看这个https://ww2.mathworks.cn/help/matlab/ref/lsqr.html", "Konwledge_Point": "线性规划和规约", "Question": "matalab和C++问题\n怎样用最小二乘法和matalab或C++解线性方程Ax=b。", "Tag": "算法分析"}
{"Answer": "你可以在这个layout的点击事件中，设置ImageView的setPressed(true),这样就可以在selector中因公pressed的设置了", "Konwledge_Point": "线性规划和规约", "Question": "Android中怎么让一个布局中所有控件都获得这个布局的点击状态\n我在一个线性布局中有一个ImageView和一个TextView，怎么设置点击这个线性布局的时候ImageView处于选取状态，还有selector怎么设置", "Tag": "算法分析"}
{"Answer": "\n设计一个Student 类，此类的对象有属性name、age、 score, 用来保存学生的姓名、年龄、成绩。-Python-CSDN问答\nCSDN问答为您找到设计一个Student 类，此类的对象有属性name、age、 score, 用来保存学生的姓名、年龄、成绩。相关问题答案，如果想了解更多关于设计一个Student 类，此类的对象有属性name、age、 score, 用来保存学生的姓名、年龄、成绩。 python、有问必答 技术问题等相关问答，请访问CSDN问答。\n\n\n\nhttps://ask.csdn.net/questions/7728159?answer=53803841\n\n参考这个问题，有帮助麻烦点个采纳，有其他问题可以继续交流~", "Konwledge_Point": "线性规划和规约", "Question": "设计一个Student 类，此类的对象有属性name、age、 score, 用来保存学生的姓名、年龄、成绩。\n设计一个Student类，此类的对象有属性name、age、sore, 用来保存学生的姓名、年龄、成绩。\n\n\n(1) 编写一个函数input _student( )读入n个学生的信息，用对象来存储这些信息(不用字典)，并返回对象的列表。\n\n\n(2)编写一个函数output. studen( )打印这些学生信息(格式不限)。\n这是我写的还有一点不会写了，请各位帮忙看看", "Tag": "算法分析"}
{"Answer": "基于GPT的解答以下是一个简单的 VB 代码示例，用于实现二维线性插值：\n' 定义二维数组和变量\nDim x(1 To 4) As Double\nDim y(1 To 4) As Double\nDim z(1 To 4, 1 To 4) As Double\nDim x1 As Double, y1 As Double, z1 As Double\nDim i As Integer, j As Integer\n\n' 输入已知的数据\nx(1) = 1: x(2) = 2: x(3) = 3: x(4) = 4\ny(1) = 1: y(2) = 2: y(3) = 3: y(4) = 4\nz(1, 1) = 1: z(1, 2) = 2: z(1, 3) = 3: z(1, 4) = 4\nz(2, 1) = 2: z(2, 2) = 4: z(2, 3) = 6: z(2, 4) = 8\nz(3, 1) = 3: z(3, 2) = 6: z(3, 3) = 9: z(3, 4) = 12\nz(4, 1) = 4: z(4, 2) = 8: z(4, 3) = 12: z(4, 4) = 16\n\n' 输入待插值的点\nx1 = 1.5\ny1 = 2.5\n\n' 计算插值\nFor i = 1 To 3\n    If x(i) <= x1 And x(i + 1) >= x1 Then\n        For j = 1 To 3\n            If y(j) <= y1 And y(j + 1) >= y1 Then\n                z1 = ((x(i + 1) - x1) * (y(j + 1) - y1) * z(i, j) + _\n                      (x1 - x(i)) * (y(j + 1) - y1) * z(i + 1, j) + _\n                      (x(i + 1) - x1) * (y1 - y(j)) * z(i, j + 1) + _\n                      (x1 - x(i)) * (y1 - y(j)) * z(i + 1, j + 1)) / _\n                      ((x(i + 1) - x(i)) * (y(j + 1) - y(j)))\n                MsgBox \"插值结果为：\" & z1\n                Exit Sub\n            End If\n        Next j\n    End If\nNext i\n\nMsgBox \"该点不在已知数据范围内\"\n\n\n代码中，我们先定义了三个一维数组和一个二维数组，分别存储 x、y 和 z 的值。然后输入已知的数据，包括 x、y 和 z 的值，以及待插值的点 x1 和 y1。最后，在两个循环中查找待插值点所在的数据区域，并根据公式计算出插值结果。如果待插值点不在已知数据范围内，则输出相应", "Konwledge_Point": "线性规划和规约", "Question": "vb编程,代码添加，二维插值\nvb代码添加。\n二维插值，as和长细比，会求出处于一定范围\n怎样线性插值求出\n解决办法附带代码\n我这一个是大表格，数据很多，要求代码简洁\n要提供验证代码\n用if 挨个判断我也会写，就是简单线性插值\n\n", "Tag": "算法分析"}
{"Answer": "循环线性表判断是哪类字符,分添加到不同的的线性表即可你题目的解答代码如下：\nli = [\"a\",\"3\",\"7\",\"*\",\"b\",\"c\",\"#\",\"5\",\"x\"]\nli1 = []\nli2 = []\nli3 = []\nfor v in li:\n    if v.isalpha():\n        li1.append(v)\n    elif v.isdigit():\n        li2.append(v)\n    else:\n        li3.append(v)\nprint(li1)\nprint(li2)\nprint(li3)\n\n\n如有帮助，请点击我的回答下方的【采纳该答案】按钮帮忙采纳下，谢谢!\n", "Konwledge_Point": "线性规划和规约", "Question": "Python数据结构链表问题\n已知由一个线性链表表示的线性表中含有3类字符的数据元素（如：字母、数字和其他字符），试编写算法将该线性链表分割为3个循环链表，其中每个循环链表表示的线性表中均只含有一类字符。", "Tag": "算法分析"}
{"Answer": "参考GPT和自己的思路：\n对于集中式卡尔曼滤波的信息物理系统，可以通过对系统的状态估计值和测量值的误差进行分析来检测是否受到了线性欺骗攻击。通常可以计算出系统状态估计误差的均值和方差，通过对比理论值和实际值，判断是否存在线性欺骗攻击。\n如果只有部分传感器受到了线性欺骗攻击，可以采用一些特定的检测算法来确定是哪几个传感器受到了影响。常用的算法包括neighbors method和covariance consistency method等等，其中neighbors method通过对相邻传感器的测量值进行比较来判断哪些传感器受到了欺骗攻击，而covariance consistency method则分析系统的协方差矩阵是否存在不一致性来判断哪些传感器受到了影响。", "Konwledge_Point": "线性规划和规约", "Question": "集中式信息物理系统安全检测\n对于一个使用集中式卡尔曼滤波的信息物理系统，怎么检测系统是否受到了线性欺骗攻击？如果只有部分传感器受到了线性欺骗攻击，怎么检测出是哪几个？", "Tag": "算法分析"}
{"Answer": "1.线性回归，神经网络这些都可以拟合预测，方法的话其实和你数据量有关，如果数据量小的话，可以看看一些增加样本数量的方法。2.以神经网络为例，梯度下降算法是最流行的优化算法之一并且目前为止是优化最常见的算法。具体你可以都尝试一下，找到模型性能最好的算法。", "Konwledge_Point": "线性规划和规约", "Question": "利用时间与温度预测湿度的数学模型用哪种好\n做一个发酵物的湿度预测模型，发酵物的湿度随着时间和温度变化，用采集的时间、温度、湿度的数据建立模型。\n想建立通过时间和温度预测湿度的模型。\n问题1：有哪些方法可以建立数学模型？想知道用哪种方法建立模型最好最好（本来拟采用多元线性回归）？\n问题2：用哪种算法优化可以模型？哪种最适合？", "Tag": "算法分析"}
{"Answer": "附录：回归结果详细说明 原文链接：https://blog.csdn.net/youcans/article/details/116448853\n\n    Dep.Variable: y 因变量\n    Model：OLS 最小二乘模型\n    Method: Least Squares 最小二乘\n    No. Observations: 样本数据的数量\n    Df Residuals：残差自由度(degree of freedom of residuals)\n    Df Model：模型自由度(degree of freedom of model)\n    Covariance Type：nonrobust 协方差阵的稳健性\n    R-squared：R 判定系数\n    Adj. R-squared: 修正的判定系数\n    F-statistic： 统计检验 F 统计量\n    Prob (F-statistic): F检验的 P值\n    Log likelihood: 对数似然\n\n    coef：自变量和常数项的系数，b1,b2,...bm,b0\n    std err：系数估计的标准误差\n    t：统计检验 t 统计量\n    P>|t|：t 检验的 P值\n    [0.025, 0.975]：估计参数的 95%置信区间的下限和上限\n    Omnibus：基于峰度和偏度进行数据正态性的检验\n    Prob(Omnibus)：基于峰度和偏度进行数据正态性的检验概率\n    Durbin-Watson：检验残差中是否存在自相关\n    Skewness：偏度，反映数据分布的非对称程度\n    Kurtosis：峰度，反映数据分布陡峭或平滑程度\n    Jarque-Bera(JB)：基于峰度和偏度对数据正态性的检验\n    Prob(JB)：Jarque-Bera(JB)检验的 P值。\n    Cond. No.：检验变量之间是否存在精确相关关系或高度相关关系。\n", "Konwledge_Point": "线性规划和规约", "Question": "Python,对回归模型做评估：具体是通过哪些值，如何评估？\n最近在学习Python对回归模型做评估，代码过程我记住了，但是出来的表格不知道怎么分析呢。是看那些值，对模型评估有什么作用？\n\n\n【用到的包】\n1.调包\nimport pandas as pd\n2.可视化分析\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline\n3.线性回归模型的建立与评估\n（调用sklearn中的线性回归工具包）\nfrom sklearn.linear_model import LinearRegression\n\n\nLinearRegression()设置模型为线性回归\nmodel=LinearRegression()\n\n\n【Q：最后出来这个表格，我不知道对评估模型有什么作用】\n\n", "Tag": "算法分析"}
{"Answer": "% 设置矩阵 A 和向量 b\nA = [10.9 1.2 2.1 0.9; 1.2 11.2 1.5 2.5; 2.1 1.5 9.8 1.3; 0.9 2.5 1.3 12.3];\nb = [-7; 5.3; 10.3; 24.6];\n\n% 设置误差限\nepsilon = 0.2 * 1e-10;\n\n% Jacobi 迭代法\n\n% 选取初始解\nx = zeros(size(b));\n\n% 初始化迭代步数\nk = 0;\n\n% 迭代求解\nwhile true\n    % 计算新的解\n    for i = 1:length(b)\n        x_new(i) = (b(i) - A(i, 1:i-1)*x(1:i-1) - A(i, i+1:end)*x(i+1:end)) / A(i,i);\n    end\n    \n    % 更新解\n    x = x_new;\n    \n    % 计算残差向量和残差模长\n    r = b - A*x;\n    res = norm(r);\n    \n    % 检查是否满足误差限\n    if res < epsilon\n        break;\n    end\n    \n    % 更新迭代步数\n    k = k + 1;\nend\n\n% 输出迭代步数\nfprintf('Jacobi 迭代法：迭代 %d 次\\n', k);\n\n\n% Gauss-Seidel 迭代法\n\n% 选取初始解\nx = zeros(size(b));\n\n% 初始化迭代步数\nk = 0;\n\n% 迭代求解\nwhile true\n    % 计算新的解\n    for i = 1:length(b)\n        x_new(i) = (b(i) - A(i, 1:i-1)*x_new(1:i-1) - A(i, i+1:end)*x(i+1:end)) / A(i,i);\n    end\n    \n    % 更新解\n    x = x_new;\n    \n    % 计算残差向量和残差模长\n    r = b - A*x;\n    res = norm(r);\n    \n    % 检查是否满足误差限\n    if res < epsilon\n        break;\n    end\n    \n    % 更新迭代步数\n    k = k + 1;\nend\n\n% 输出迭代步数\nfprintf('Gauss-Seidel 迭代法：迭代 %d 次\\n', k);\n\n松弛迭代法\n\n% 选取松弛因子\nomega = 1.5;\n\n% 选取初始解\nx = zeros(size(b));\n\n% 初始化迭代步数\nk = 0;\n\n% 迭代求解\nwhile true\n% 计算新的解\n    for i = 1:length(b)\n        x_new(i) = (1-omega)*x(i) + omega * (b(i) - A(i, 1:i-1)*x_new(1:i-1) - A(i, i+1:end)*x(i+1:end)) / A(i,i);\n    end\n    % 更新解\n    x = x_new;\n\n    % 计算残差向量和残差模长\n    r = b - A*x;\n    res = norm(r);\n\n    % 检查是否满足误差限\n    if res < epsilon\n        break;\n    end\n\n    % 更新迭代步数\n    k = k + 1;\nend\n\n% 输出迭代步数\nfprintf('松弛迭代法（omega = %f）：迭代 %d 次\\n', omega, k);\n", "Konwledge_Point": "线性规划和规约", "Question": "数值代数的问题，请友友们解答\n设有线性方程组Ax=b， 其中\nA=\n10.9 1.2  2.1  0.9\n1.2  11.2 1.5  2.5\n 2.1  1.5   9.8  1.3\n 0.9  2.5  1.3 12.3\nB=\n-7\n5.3\n10.3\n24.6\n(1) 选取适当的松弛因子和初始向量,分别用 Jacobi 迭代，Gauss-Seidel 迭代和松弛迭代法（SOR）求解方程组Ax=b 使误差小于\n0.2*10^(-10)（写出详细求解过程）；\n(2)说明如何确保每种方法的误差在控制范围内;\n(3)使用上述三种方法求解该线性方程组时，给出求得误差在控制范\n围内的迭代步数.", "Tag": "算法分析"}
{"Answer": "参考一下：https://ww2.mathworks.cn/help/signal/filter-design.html如果对你有帮助，可以点击我这个回答右上方的【采纳】按钮，给我个采纳吗，谢谢", "Konwledge_Point": "线性规划和规约", "Question": "数字微分器的设计和实现\n采用IV的FIR线性相位滤波器逼近数字微分器。\n阶数：60\n通带边界频率：0.2π rad\n阻带边界频率：0.3π rad", "Tag": "算法分析"}
{"Answer": "链表操作和文件读写。代码如下：\n#define _CRT_SECURE_NO_WARNINGS 1\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\nstruct stuInfo\n{\n    char id[12]; //数据成员\n    char name[15];\n    float score;\n    struct stuInfo* next; //指针成员\n};\n\n\n//1.创建链表\nstruct stuInfo* CreateList()\n{\n    struct stuInfo* head = (struct stuInfo*)malloc(sizeof(struct stuInfo));\n    head->next = 0;\n    return head;\n}\n\n//读文件\nvoid readFile(struct stuInfo* head)\n{\n    struct stuInfo* p, * t;\n    FILE* fp = fopen(\"stuinfo.txt\", \"r\");\n    if (fp == 0)\n    {\n        printf(\"文件打开失败！\\n\");\n        return;\n    }\n\n    //获取链表尾节点\n    p = head;\n    while (p->next)\n        p = p->next;\n\n    //开始读文件\n    while (!feof(fp))\n    {\n        t = (struct stuInfo*)malloc(sizeof(struct stuInfo));\n        t->next = 0;\n        t->id[0] = 0;\n        fscanf(fp, \"%s %s %f\", t->id,t->name,&t->score);\n        if (strlen(t->id) == 0)\n        {\n            free(t);\n        }\n        else\n        {\n            p->next = t;\n            p = t;\n        }\n    }\n    fclose(fp);\n    printf(\"文件读取成功！\\n\");\n}\n\n\n//3.插入\nvoid Insert(struct stuInfo* head)\n{\n    struct stuInfo* p, * t;\n    char pos[20] = { 0 };\n    t = (struct stuInfo*)malloc(sizeof(struct stuInfo));\n    t->next = 0;\n  \n    p = head->next;\n    printf(\"请输入需要插入的信息：ID  NAME  SCORE:\");\n    scanf(\"%s %s %f\", t->id, t->name, &t->score);\n    printf(\"请输入插入位置（比如学号00005)：\");\n    scanf(\"%s\", pos);\n    while (p)\n    {\n        if (strcmp(p->id, pos) == 0)\n        {\n            t->next = p->next;\n            p->next = t;\n            printf(\"插入成功！\\n\");\n            break;\n        }\n        else\n            p = p->next;\n    }\n    if (p == 0)\n        printf(\"未找到该位置，插入失败\\n\");\n}\n\n//根据成绩排序\nvoid sortByScore(struct stuInfo* L)\n{\n    struct stuInfo* p, * tail, * q;\n    tail = NULL;\n    while ((L->next->next) != tail)\n    {\n        p = L;\n        q = L->next;\n        while (q->next != tail)\n        {\n            if (q->score > q->next->score) //升序排列\n            {\n                p->next = q->next;\n                q->next = q->next->next;\n                p->next->next = q;\n                q = p->next;\n            }\n            q = q->next;\n            p = p->next;\n        }\n        tail = q;\n    }\n\n}\n\n//写文件\nvoid writefile(struct stuInfo* head)\n{\n    struct stuInfo* p = head->next;\n    FILE* fp = fopen(\"score.txt\", \"w\");\n    while (p)\n    {\n        fprintf(fp, \"%s %s %f\\n\", p->id, p->name, p->score);\n        p = p->next;\n    }\n    fclose(fp);\n}\n\n//显示链表\nvoid showLinst(struct stuInfo* head)\n{\n    struct stuInfo* p = head->next;\n    while (p)\n    {\n        printf(\"%s %s %f\\n\", p->id, p->name, p->score);\n        p = p->next;\n    }\n}\n\nint main()\n{\n    struct stuInfo* head = 0;\n    int opt = 0;\n    \n\n    //1.创建链表\n    head = CreateList();\n\n    //2.读文件\n    readFile(head);\n\n    //showLinst(head); //显示列表\n\n    //3.插入\n    Insert(head);\n\n    //4.排序\n    sortByScore(head);\n\n    //5.写文件\n    writefile(head); \n\n    showLinst(head); //显示列表\n    return 0;\n}\n\n\n\n", "Konwledge_Point": "线性规划和规约", "Question": "C语言：TXT文件读取到链表中进行操作，键盘插入节点后以新文件输出\n现有结构体定义如下：\nstruct stuInfo\n{\n    char id[12];            //数据成员\n    char name[15];\n    float score;\n    struct stuInfo *next;   //指针成员\n};\n任务及要求：\n（1）首先完成线性链表的定义和创建，确保链表的第一个节点为哨兵节点，不存放有效的数据；\n（2）利用文件的相关操作，动态开辟节点存储空间，将存放在磁盘某个路径中的文件“stuinfo.txt”信息逐条读入，并依次存入到线性链表的每个节点中，信息如下；\n00001 张三 100\n00002 李四 99\n00003 王五 100\n00004 王六 89\n00005 江涛 98\n00006 陈琪 88\n00007 祁廷 91\n（3）接下来，利用键盘输入，动态开辟节点存储空间，将00008 赵四 88信息存在一个节点中，并插入到学号是‘00005’和‘00006’之间；\n（4）再接下来，利用直接插入排序，对链表继续升序排序；\n（5）将完整的线性链表信息从头到尾依次存储到磁盘某个路径下的“score.txt”文件中，存储格式和“stuinfo.txt”文件相同。\n（6）最终将“score.txt”的内容复制粘贴到实验报告的实验结果中。\n大一新生想问一下这个问题用CodeBlocks如何解决，急。谢谢大家", "Tag": "算法分析"}
{"Answer": "参考GPT和自己的思路：\n对于你的问题，我的回答如下：\n要计算状态反馈阵K，可以采用极点配置法，其中包括以下步骤：a. 确定系统的传递函数和期望闭环极点；b. 计算系统的可控性矩阵和可观性矩阵；c. 根据期望闭环极点和系统可控性矩阵，求解状态反馈增益矩阵K。在MATLAB中，可以使用place函数求解状态反馈增益矩阵K，其代码格式如下：K = place(A, B, p)；其中，A和B分别为系统的状态空间矩阵，p为期望闭环极点的向量。要仿真闭环系统的阶跃响应曲线图，可以使用MATLAB中的step函数，其代码格式如下：step(sys)；其中，sys为闭环系统的传递函数或状态空间矩阵。该函数将自动绘制系统的阶跃响应曲线图。", "Konwledge_Point": "线性规划和规约", "Question": "先进控制与MATLAB\n已知连续时间线性时不变系统和期望闭环极点：1.如何计算状态反馈阵K？2.如何利用MATLAB求取反馈增益K？3.如何仿真闭环系统的阶跃响应曲线图？", "Tag": "算法分析"}
{"Answer": "提示啥错误？你的name 输入了啥名字， 应该是要带png 后缀的吧？", "Konwledge_Point": "线性规划和规约", "Question": "matplotlip 绘图后，相以变量作为名称保存图片\n问题遇到的现象和发生背景\n\n\n图片无法以变量的名称进行保存\n\n\n问题相关代码，请勿粘贴截图\n\n\ndef Linechart():\n    while True:\n        name = input('请输入最终的保存文件名称，例如：2022 3 1')\n        x = [-8, -7, -6, -5, -4, -3, -2, -1]\n        yg = input('纵坐标的数据列表：').split(',')  # 通过input函数来输入列表\n        y = [int(yg[i]) for i in range(len(yg))]\n        plt.scatter(x, y)\n        plt.show()\n        answer = input('是否进行线性拟合？y/n')\n        if answer == 'y':\n            xl = int(input('请输入线性范围横坐标左端点'))\n            xr = int(input('请输入线性范围横坐标右端点'))\n            x0 = x[xl:xr]\n            yl = int(input('请输入线性范围纵坐标左端点'))\n            yr = int(input('请输入线性范围纵坐标右端点'))\n            y0 = y[yl:yr]\n            plt.scatter(x[:], y[:], 3, 'red')\n            A1, B1 = optimize.curve_fit(f_1, x0, y0)[0]\n            x1 = np.arange(xl, xr, 0.01)\n            y1 = A1 * x1 + B1\n            plt.plot(x1, y1, 'blue')\n            print(A1)\n            print(B1)\n            plt.title(\" \")\n            plt.xlabel('log')\n            plt.ylabel('Mt/g')\n            figure_save_path = 'file_fig'\n            if not os.path.exists(figure_save_path):\n                os.makedirs(figure_save_path)\n                plt.savefig(os.path.join(figure_save_path, name))\n            plt.show()\n            answer1=input('是否继续进行折线图绘制？y/n')\n            if answer1=='y':\n                continue\n            else:\n                break\n\n\n    \nelse\n:\n        \nbreak\n\n\n\n\n运行结果及报错内容\n\n\n正常可以绘制图片，但是保存文件件的位置并没有保存的图片\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果", "Tag": "算法分析"}
{"Answer": "没错，只有13 27存在冲突，所以都是7/6", "Konwledge_Point": "线性规划和规约", "Question": "数据结构平均查找长度问题\n设散列表的长度为8，散列函数H(k)=k mod 7，初始记录关键字序列为(25，31，8，27，13，68)，要求分别计算出用线性探测法和链地址法作为解决冲突方法的平均查找长度。\n\n答案分别为7/6 和 4/3\n\n但是链地址法算出来觉得也是7/6，求解...", "Tag": "算法分析"}
{"Answer": "你好，我是有问必答小助手，非常抱歉，本次您提出的有问必答问题，超出我们目前的服务范围，暂时无法为您解答。\n问答VIP目前服务范围为 ：Python、Java、MySQL、Redis、MongoDB、HBase、Zookeeper、Kafka、Linux领域专业问题解答，为您提供解决问题的思路和指导。 不提供源码代写、项目文档代写、论文代写、作业代写、安装包资源发送或安装指导等服务。\n本次提问扣除的有问必答次数，已经为您补发到账户，我们后续会持续优化，扩大我们的服务范围，为您带来更好地服务。", "Konwledge_Point": "线性规划和规约", "Question": "python多元回归模型的预测及检验\n现在已经根据一段时间的数据构造出了线性回归模型，想将下一段时间的数据带入到这个模型中进行检验，并画出预测值和实际值对比的散点图，应该如何实现", "Tag": "算法分析"}
{"Answer": "第一步  将function yy=Lagrange(x,y,xi)m=length(x);n=length(y);if m ~= n , error('向量x与y的长度必须一致'); end; s=0;for i=1 : n    z=ones(1,length(xi));    for j=1 : n        if j ~= i            z=z.*(xi-x(j))./(x(i)-x(j));        end    end    s=s+z*y(i);endyy=s;保存为M文件。（文件→新建→M文件）第二步将x=[0.5610,0.56280,0.56401,0.56521];y=[0.82741,0.82659,0.82577,0.82495];xi=[0.5625,0.5635,0.5645];yi=Lagrange(x,y,xi)粘贴至（命令窗口）。", "Konwledge_Point": "线性规划和规约", "Question": "用matlab进行拉格朗日插值还原曲线，和分段插值，详细代码包括测试结果\n还原图1.4(绘制Lagrange 10次插值曲线和原函数曲线)，并加上图1.5中的分段线性差值曲线。（三条曲线绘制在同一张Figure里面，注意用不同的线形区分）", "Tag": "算法分析"}
{"Answer": ">>> import numpy as np\n>>> import matplotlib.pyplot as plt\n>>> x = np.linspace(-np.pi, np.pi, 1000)\n>>> plt.plot(x, np.sin(x))\n[<matplotlib.lines.Line2D object at 0x000002BFFC916E88>]\n>>> plt.plot(x, np.cos(x))\n[<matplotlib.lines.Line2D object at 0x000002BFF9BF1208>]\n>>> plt.show()\n\n", "Konwledge_Point": "线性规划和规约", "Question": "python 数据分析与可视化基础题\n xX是从-pi到pi线性拆分1000个点组成的 维数组， sinx是x数组的正弦值， Cosx是x数组的余弦值， 在同一幅图中分别绘制出x的正弦曲线和余弦曲线。", "Tag": "算法分析"}
{"Answer": "从报错原因上看是维度不一致，可以进行以下修改：\nxdata=[1 2 3 4 5];\nydata=[20 40 60 80 100];\nfun=@(a, x)x.^(a (1) .*x+a (2))./(a (3).*(a(4).^(a (1) .*x+a (2))) .*gamma (1+a (1) .*x+a(2))) ;\nx0=[0.3,1.2,400,200];\nA=lsqcurvefit(fun, x0, xdata, ydata)\nydata=fun(A, xdata) \nx=linspace(xdata(1),xdata(end)) ;\ny=fun (A, x) ;\nplot(xdata,ydata, 'o',xdata,ydata,'*',x,y)\n\n结果为：\nA =\n\n   -0.3489    0.9364  399.9999  199.9995\n\n\nydata =\n\n    0.0001    0.0009    0.0037    0.0092    0.0103\n\n\n可见能够正常运行如果问题得到解决请点 采纳~~", "Konwledge_Point": "线性规划和规约", "Question": "最小二乘法拟合未知参数\n想用matlab最小二乘法拟合非线性方程的4个未知参数，并画出原始数据和拟合曲线的图像。一直运行错误不知道怎么修改，错误使用  * 内部矩阵维度必须一致。\n\n\n请指点~谢谢！函数如图片，a,b,c,d未知。", "Tag": "算法分析"}
{"Answer": "怎么会呢，都支持啊，只是py3在字符串类上统一了，其他数据结构没什么变化呀", "Konwledge_Point": "线性规划和规约", "Question": "python3里边的解构支持什么数据类型\n如:\n\n    lst = range(5)\n\n        x,*y=lst\n\n        x的值为0\n\n        y的值为[1,2,3,4]\n\n\n\n请问python3里边的解构是不是只支持线性结构的数据类型(列表等)，不支持集合和字典", "Tag": "算法分析"}
{"Answer": "使用 Matplotlib 库时可以使用 plt.xlim() 和 plt.ylim() 函数指定x轴和y轴的范围\nplt.xlim(xmin, xmax)\nplt.ylim(ymin, ymax)\n", "Konwledge_Point": "线性规划和规约", "Question": "python制图时，如何固定坐标？\n就是说制图的时候坐标系老是变化，随着输出的不同，y坐标老是在’500，-200‘和’500，-300‘间反复横跳，能不能把坐标轴的范围固定，只让线性回归后的直线自己动。", "Tag": "算法分析"}
{"Answer": "struct Tool\r\n{\r\nint 编号;\r\nchar 名称[100];\r\n...\r\n};\r\nstruct 记录\r\n{\r\nTool value;\r\nTool * next;\r\n};\r\n前者代表某一项，后者是链表，把它们串起来。", "Konwledge_Point": "线性规划和规约", "Question": "C语言编程题目——创建结构体和链表\n希望得到讲解\n\n\n\n1）定义一个结构体(struct Tool)表示工具，包括：工具编号、名称、价格、重量、存放位置等信息；\n\n\n\n2）要求定义一个线性单链表(struct ToolList)存储工具档案记录。\n\n\n\n两者创建有什么区别吗？希望得到创建源码，谢谢", "Tag": "算法分析"}
{"Answer": "在MATLAB中，可以使用fsolve函数来求解方程。首先，需要定义一个函数来表示给定方程，然后传递给fsolve。 例如：\n\nfunction F = myeqn(alpha)\nL = 0.9*tan(alpha)*L - 0.3*((9.8)*L^1.83)/(2*cos(alpha)^2) - (1.96*L^3)/(3*cos(alpha)^3) + 10;\nF = [F];\nend\n\n\n接下来，可以使用fsolve函数来求解方程，并将初始猜测值作为参数传递给它。例如：\n\nalpha0 = 0;\nalpha = fsolve(@myeqn,alpha0);\n\n运行这段代码，fsolve将返回方程的解，并将其存储在alpha变量中。\n注意，在这个方程中， L 是未知量，需要求解。", "Konwledge_Point": "线性规划和规约", "Question": "如何用matlab求解复杂方程\n具体方程如下：\n虽然前几天通过问问题了解了可以使用 fsolve 函数和 fzero 函数求解非线性方程，但是我查的资料中方程都是标准的y=ax..这种形式，但是我要求的这个方程很复杂，希望有了解的朋友可以说一下思路或指导一下", "Tag": "算法分析"}
{"Answer": "loss = (1/2) * (a - y)**2", "Konwledge_Point": "线性规划和规约", "Question": "python-lossfunction\n在python线性题中，loss fucntion 不是采用 cross entropy 而是预测值 a和真值 y 的差的平方 (又L2 loss):(a-y)2/1²，请用 python 代码(运用符号 a,y,+,，*，/ 等)写出上式的算式", "Tag": "算法分析"}
{"Answer": "线性拉升直接乘上去就是了，为什么要访问元素？img1=img*2+5;这样就是相当于把每个像素点的值x2+5", "Konwledge_Point": "线性规划和规约", "Question": "Opencv处理CIELab空间图像通道的问题？\n将图片从RGB空间转到Lab空间之后，如何对a通道和b通道的直方图进行线性拉伸处理？由于a通道取值为-128到127，所以采用img.at(row,col)的方式访问像素点是不是不对呀？应该怎么访问与操作？", "Tag": "算法分析"}
{"Answer": "注意力机制在 RNN 中的应用是用来解决 RNN 在处理长序列时会遗忘早期信息的问题。在 SimpleRNN+attention 模型中，注意力机制通过计算每个时间步的输出和编码器的最终输出之间的相似度来分配权重。这样，在解码器阶段，可以在每一步选择一个最相似的编码器输出来进行处理。\n具体来说，对于每一个时间步 i，我们将解码器的隐藏状态 hi 与编码器的最终输出 hm 进行线性变换，再通过 softmax 函数得到每个时间步的注意力权重 ai，即 ai = softmax(hi * W * hm)。这样，早期时间步的 hi 也能够通过 ai 的高权重得到重视，从而解决了 RNN 处理长序列时遗忘早期信息的问题。\n关于解码器阶段，在解码器阶段，我们使用起始符后的第一个字来预测第一个输出，这个输出通常是在预训练语言模型中获取的，然后第一步的输出将被用来预测第二个输出，以此类推，直到预测出所有的目标序列。\n总的来说, Attention 机制将信息从编码器传递给解码器的过程中，通过计算每一步解码器的隐藏状态与编码器最终输出之间的相似度，来确定在当前时间步中对编码器输出的关注。这样，在解码器阶段，每一步都可以从编码器输出中选择最相关的信息来进行处理，这使得我们可以避免 RNN 网络在处理长序列时的遗忘问题。比如说，在翻译模型中，编码器接收输入的源语句 \"I have a cat\" 并产生一个隐藏状态序列，解码器接着使用这个隐藏状态序列来生成目标语句 \"Je ai un chat\"。在解码器生成目标语句的过程中，它可能会在生成 \"Je\" 的时候主要关注 \"I\" 和 \"have\"，而在生成 \"ai\" 的时候主要关注 \"cat\"。这样可以解决解码器在生成每一个目标词时，都能根据编码器的输出来关注那些重要的源语言词汇。\n当然，这仅仅是一个简单的例子，在实际应用中，注意力机制还可以用于语音识别，图像分类等其他领域。", "Konwledge_Point": "线性规划和规约", "Question": "SimpleRNN+attention中注意力α的原理？\n就是说，α是由s0和hi计算出来的，s0就是编码器的最后一个输出hm，那样的话简单rnn的最后的输出不是会遗忘早先时候的数据么？那这个遗忘了数据的hm去和早先时候的hi线性变换后相乘，乘出来的值有意义么？还有，s0就是hm的话，那和hm相乘的时候不就会获得最高的注意力么？是怎么在decoder中推测出起始符后的第一个字的？", "Tag": "算法分析"}
{"Answer": "解决方案如下图所示，IntelliJ IDEA 2019.2.2\r\n![图片说明](https://img-ask.csdn.net/upload/201911/15/1573804567_307159.jpg)", "Konwledge_Point": "线性规划和规约", "Question": "intellij idea怎么创建文件夹？\n\n\n\n\n简单地说，我想创建com.test01这个文件夹，然后在下面分别创建1和2这两个文件夹。但是它创建出来是上图这样的，无论怎么创建它都不会分级，而是线性地往下创建\n\n请问大神要怎么办呢？", "Tag": "算法分析"}
{"Answer": "你可以参考下这篇文章：用梯度下降算法解决线性回归问题", "Konwledge_Point": "线性规划和规约", "Question": "关于梯度下降法的问题\n有以下数据：\n\n\n\n\n如果我们使用\n梯度下降算法\n来最小化线性回归的代价函数，那么前三次迭代的\nθ值\n和\n代价(cost)值\n是多少?（可以的话写出解答的全流程）\n假设\n初始θ值为[1,0.5]T\n，\n学习率(learning rate)α为0.1\n。", "Tag": "算法分析"}
{"Answer": "你从文本里读取的是字符串，你没有把字符串转成数字，你画出来的当然是直线了", "Konwledge_Point": "线性规划和规约", "Question": "以下是我用matplotlib画的折线图，但是折线图纵坐标没个数据之间的间隔是相等的，显示不出折线图的效果，应该如何解决这个问题\n\n\n#以下是我画折线图图写的代码\nq=list(open(\"pH.txt\",'r'))#pH.txt是一个包含了21个数据的txt文件\nx=range(0,21)\ny=q\npl.plot(x,y)\npl.xlabel(\"Vb\")\npl.ylabel(\"pH\")\npl.title(\"pH-Vb\")\npl.show()\n\n\n以下是我的数据，不是线性的😭\n2.591064607026499\n2.6379342479565424\n2.6901960800285134\n2.74929451036117\n2.817344971441929\n2.8976270912904414\n2.995635194597551\n3.1216692520434512\n3.2988530764097077\n3.6009728956867417\n7.00\n10.396855627379825\n10.69680394257951\n10.871816208578554\n10.995678626217357\n11.09151498112135\n11.16962521680645\n11.235503630789037\n11.292429823902065\n11.342519201431983\n11.387216143280265", "Tag": "算法分析"}
{"Answer": "可以的。", "Konwledge_Point": "线性规划和规约", "Question": "关于遗传算法应用的问题求解\n原因集合A导致结果B。\n\n原因集合A1导致结果B1。\n\n原因集合A2导致结果B2。\n\n原因集合A3导致结果B3。\n\n。。。。。\n\n是否可以根据遗传算法，求出原因状态A、A1、A2、A3...之间的非线性函数关系？？？", "Tag": "算法分析"}
{"Answer": "供参考：\n#include<stdio.h>\nint main()\n{\n    int n=0;\n    double a,b,c,d,e;\n    scanf(\"%lf %lf %lf %lf %lf\",&a,&b,&c,&d,&e);\n    if(a<60)n++;\n    if(b<60)n++;\n    if(c<60)n++;\n    if(d<60)n++;\n    if(e<60)n++;\n    if(n == 2)\n        printf(\"Nooooooooooo\");\n    else\n        printf(\"lknb\");\n    return 0;\n}\n\n", "Konwledge_Point": "线性规划和规约", "Question": "nyoj 纽约-1578 lk考试挂科事件\n假期摆烂后开学迎来了期天考试危机！Ik没有复习只能一晚上速通各科目，如果他恰好挂\n了两科，蓝桥杯的奖学金就和他拜拜了;当考试分数严格小于60分时为挂科,请你判断Ik能不能拿到蓝桥杯的奖学金\n输入描述\n给出5个分数，分别是linux成绩 数据结构成绩 高等数学成绩 线性代数成绩 大学英语成\n绩，分数不一定是整数\n输出描述\n如果能拿到奖学金输出Iknb\n如果不能拿到奖学金输出No0000000000\n\n", "Tag": "算法分析"}
{"Answer": "5日的数据\nimport pprint\nimport re\nimport requests\nimport csv\n\nf = open('data.csv', mode='a', encoding='utf-8', newline='')\ncsv_writer = csv.DictWriter(f, fieldnames=[\n    '日期',\n    '时间',\n    '价格',\n    '均价',\n    '成交',\n])\ncsv_writer.writeheader()\nurl = 'https://stock2.finance.sina.com.cn/futures/api/jsonp.php/var%20t5nf_SP0=/InnerFuturesNewService.getFourDaysLine?symbol=SP0'\nheaders = {\n    'user-agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.54 Safari/537.36'\n}\nhtml_data = requests.get(url=url, headers=headers).text\ncontent = re.findall('var t5nf_SP0=\\((.*?)\\);', html_data)[0]\ncontent_1 = re.findall('\\[(.*?)\\],', content)\nfor index in content_1:\n    info_list = index.split(',')\n    date_time = info_list[0].replace('\"', '').replace('[', '')\n    price = info_list[1].replace('\"', '')\n    price_1 = info_list[2].replace('\"', '')\n    clinch = info_list[3].replace('\"', '')\n    if len(info_list) == 7:\n        date = info_list[-1].replace('\"', '')\n    dit = {\n        '日期': date,\n        '时间': date_time,\n        '价格': price,\n        '均价': price_1,\n        '成交': clinch,\n    }\n    csv_writer.writerow(dit)\n    print(dit)\n\n\n年线数据\nimport requests\nimport re\nimport json\nimport csv\n\nf = open('年线data.csv', mode='a', encoding='utf-8', newline='')\ncsv_writer = csv.DictWriter(f, fieldnames=[\n    '日期',\n    '开盘',\n    '最高',\n    '最低',\n    '收盘',\n    '成交量',\n    '均价',\n])\ncsv_writer.writeheader()\nurl = 'https://stock2.finance.sina.com.cn/futures/api/jsonp.php/var%20_SP02022_6_7=/InnerFuturesNewService.getDailyKLine?symbol=SP0&_=2022_6_7'\nheaders = {\n    'user-agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.54 Safari/537.36'\n}\nhtml_data = requests.get(url=url, headers=headers).text\nprint(html_data)\ncontent = re.findall('\\{(.*?)\\}', html_data)\nfor index in content:\n    index_dict = '{' + index + '}'\n    dit = json.loads(index_dict)\n    print(dit)\n    dit_content = {\n        '日期': dit['d'],\n        '开盘': dit['o'],\n        '最高': dit['h'],\n        '最低': dit['l'],\n        '收盘': dit['c'],\n        '成交量': dit['v'],\n        '均价': dit['s'],\n    }\n    csv_writer.writerow(dit_content)\n    print(dit)\n\n", "Konwledge_Point": "线性规划和规约", "Question": "PowerBI或python获取新浪财经期货线图或数据\n请教列位dd，想在PowerBI里直接显示这张图，但是目前看来好像不行，所以想请教是否有python的dd能帮忙获取这个接口帮忙取出每日结算价格呢，方式方法不限，或者由PBI的dd能直接帮我show出这样图标或者线性数据或者表格数据都可以。\n\n\n网址如下：\nhttps://finance.sina.com.cn/futures/quotes/SP0.shtml\n类别：纸浆（SP0）\n\n", "Tag": "算法分析"}
{"Answer": "线性方程组写成 A*x = b形式，A非奇异时，解为 x = A \\ b，代码：\n\nA = [3 6 4\n     1 5 0\n     0 7 7];\nb = [1;2;3];\nx = A\\b\nb2 = A*x\n结果：\n\nx =\n\n   -0.5824\n    0.5165\n   -0.0879\n\n\nb2 =\n\n    1.0000\n    2.0000\n    3.0000\n ", "Konwledge_Point": "线性规划和规约", "Question": "请问这个怎么做呀，需要哪方面的知识啊！\n用\\运算解以下线性方程组，计算并显示误差向量。\n3a+6b+4c=1\na+5b=2\n7b+7c=3", "Tag": "算法分析"}
{"Answer": "```\r\nfloat aver(float a[],int n) { //用for循环求出所有值的和，再除以个数n \r\n    int i;\r\n    float sum;\r\n//  float sum = 0; // 要赋初值\r\n\r\n    for(i=0;i \r\n\r\n#define N 96\r\n\r\nint main() { \r\n\tfloat Temp_X[N] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.46667, 11.4667, 31.6, 52.7333, 80.3333, 116.333, 156.6, 199.4, 242.2, 283.4, 329.2, 379.333, 431.333, 482.6, 541, 594.4, 643.533, 692.133, 736.267, 772.667, 810.133, 841.867, 868.2, 892.4, 917.667, 939.8, 954.667, 969, 976.8, 983.4, 987.467, 994.933, 1023.67, 875.2, 873.933, 758.8, 678.2, 515.867, 782.533, 908.8, 779.2, 831.4, 645.533, 734.067, 679.533, 610.267, 565.067, 512.467, 462, 405.2, 354.133, 302, 247.8, 191.533, 140, 94.2667, 57.5333, 25.9333, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };            //定义初始化数组X \r\n\tfloat Temp_Y[N] = {0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 1.785, 2.57833, 3.927, 5.79233, 7.379, 9.48133, 11.1473, 12.4167, 13.6627, 16.193701, 18.248699, 19.042, 19.042, 19.105301, 16.6383, 17.240999, 14.631, 11.8217, 11.663, 12.155, 15.488, 21.859301, 19.32, 19.042, 19.6133, 21.105, 22.9937, 20.827299, 23.858299, 23.0333, 19.2883, 15.6937, 21.5893, 23.802999, 20.518299, 21.5893, 17.907301, 17.971001, 17.574301, 16.781, 15.5513, 12.3773, 10.2747, 8.60867, 6.86333, 5.39567, 3.88767, 2.856, 2.142, 2.142, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952 }; //定义初始化数组Y \r\n\t\r\n    float xSum = 0,ySum = 0, \r\n    float xySum=0, x2Sum=0;//这里赋值了后面就忘了 \r\n    float a, b;\r\n\t\r\n\tfor( int i = 0; i < N; i++ ) {\r\n\t    xySum += (Temp_X[i] * Temp_Y[i]);\r\n\t    x2Sum += (Temp_X[i] * Temp_X[i]);\r\n\t    xSum += Temp_X[i];\r\n\t    ySum += Temp_Y[i];\r\n\t}\r\n//\ta = (xySum - 96 * xAver * yAver) / (x2Sum-96 * xAver * xAver);  \r\n\ta = (N * xySum - xSum * ySum)/(N * x2Sum - xSum*xSum);\r\n\tb = ySum / N - a * xSum / N;\r\n\tprintf( \"a = %f\\n b = %f\", a, b ); \r\n}\r\n```\r\n[最小二乘法](https://blog.csdn.net/qq_35082030/article/details/88709990 \"\")", "Konwledge_Point": "线性规划和规约", "Question": "为什么调用函数参与运算再给变量赋值，数就不对了\n求线性回归方程a和b值，结果明显不对\n\n代码如下\n\n\n\n#include \n\n                                                         //调用库函数 \n\nint main()                                                //主函数 \n\n{   float aver(float a[],int);                         //声明求均值函数 \n\n\n\nfloat Temp_X[96] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.46667, 11.4667, 31.6, 52.7333, 80.3333, 116.333, 156.6, 199.4, 242.2, 283.4, 329.2, 379.333, 431.333, 482.6, 541, 594.4, 643.533, 692.133, 736.267, 772.667, 810.133, 841.867, 868.2, 892.4, 917.667, 939.8, 954.667, 969, 976.8, 983.4, 987.467, 994.933, 1023.67, 875.2, 873.933, 758.8, 678.2, 515.867, 782.533, 908.8, 779.2, 831.4, 645.533, 734.067, 679.533, 610.267, 565.067, 512.467, 462, 405.2, 354.133, 302, 247.8, 191.533, 140, 94.2667, 57.5333, 25.9333, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };            //定义初始化数组X \nfloat Temp_Y[96] = {0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 1.785, 2.57833, 3.927, 5.79233, 7.379, 9.48133, 11.1473, 12.4167, 13.6627, 16.193701, 18.248699, 19.042, 19.042, 19.105301, 16.6383, 17.240999, 14.631, 11.8217, 11.663, 12.155, 15.488, 21.859301, 19.32, 19.042, 19.6133, 21.105, 22.9937, 20.827299, 23.858299, 23.0333, 19.2883, 15.6937, 21.5893, 23.802999, 20.518299, 21.5893, 17.907301, 17.971001, 17.574301, 16.781, 15.5513, 12.3773, 10.2747, 8.60867, 6.86333, 5.39567, 3.88767, 2.856, 2.142, 2.142, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952 }; //定义初始化数组Y \nfloat a,b,sum1=0,sum2=0;                         //定义变量，a，b为线性回归方程y=ax+b中a，b的值，sum1，sum2，为求a时分步求解用的变量 \nint i,j;                                              //i，j为循环时使用的变量 \nfor(i=0;i<96;i++)\n{\n    sum1+=(Temp_X[i]*Temp_Y[i]);\n    sum2+=(Temp_X[i]*Temp_X[i]);\n}\na=(sum1-96*aver(Temp_X,96)*aver(Temp_Y,96))/(sum2-96*aver(Temp_X,96)*aver(Temp_X,96));  //通过线性回归方程公式求出a值 \nb=aver(Temp_Y,96)-(a*aver(Temp_X,96));\nprintf(\"a=%f,b=%f\",a,b); \n\n\n\n\n}\n\nfloat aver(float a[],int n)   //求均值的函数 \n\n{                                //用for循环求出所有值的和，再除以个数n \n\n    int i;\n\n    float sum;\n\n    for(i=0;i<n;i++)\n\n    {\n\n        sum+=a[i];\n\n    }\n\n    return sum/n;                 //返回结果 \n\n}", "Tag": "算法分析"}
{"Answer": "主要在俩个问题：绘图的时候传参数值不对；刻度太大，值差别太小，所以看不出来。\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib import ticker\n\nS = [13, 7, 15, 18, 19]\nlabels = S\nx = np.arange(len(labels))  # the label locations\nwidth = 0.35  # the width of the bars\n\nfig_Correlation, ax = plt.subplots()\nzsx = [0.999, 0.999, 0.998, 0.998, 0.998]\nzsy = [0.998, 0.998, 0.997, 0.998, 0.998]\nax.bar(x - width / 2, zsx, width, label='X_Rsq')\nax.bar(x + width / 2, zsy, width, label='Y_Rsq')\nax.set_xticks(x)\nax.set_xticklabels(labels)\nax.set_ylim((0.8, 1.0))  # 定义y轴的取值范围\nax.yaxis.set_major_locator(ticker.MultipleLocator(0.01)) # y轴刻度\nax.yaxis.set_minor_locator(ticker.MultipleLocator(0.001))  # y最小刻度精度\nax.legend()\nplt.show()\n\n", "Konwledge_Point": "线性规划和规约", "Question": "显示和理想的差距。。For循环逻辑上哪里出错了吗？\nimport\n pandas \nas\n pd\n# noinspection PyUnresolvedReferences\n\nimport\n numpy \nas\n np\n\nimport\n os\n# noinspection PyUnresolvedReferences\n\nimport\n matplotlib.pyplot \nas\n plt\n# noinspection PyUnresolvedReferences\n\nfrom\n sklearn.linear_model \nimport\n LinearRegression\n\n#input the excel file address and the data to be plotted.\n#refer to the excel header for groupKey, LocXKey, LocYKey, valueXKey and valueKKey.\nfileAdd_x = r\n\"C:\\Users\\z\\PycharmProjects\\Test\\Excel\\Material\\X.Meas.csv\"\n\nfileAdd_y = r\n\"C:\\Users\\z\\PycharmProjects\\Test\\Excel\\Material\\Y.Meas.csv\"\n\ngroupKey = \n'WorkSet'\n\n\n#data \nimport\n\ndata_x = pd.read_csv(fileAdd_x).dropna( how = \n'all'\n )\ndata_y = pd.read_csv(fileAdd_y).dropna( how = \n'all'\n )\ngroups_x = data_x[ groupKey ].unique()\ngroups_y = data_y[ groupKey ].unique()\n\n\n##################################################################################################\nS=[\n13\n,\n7\n,\n15\n,\n18\n,\n19\n]\nlabels = S\nx = np.arange(len(labels))  # the label locations\nwidth = \n0.35\n  # the width \nof\n the bars\n\n#########  Correlation  #########\nfig_Correlation,ax = plt.subplots()\nfor group \nin\n groups_x:\n    groupIndex = data_x[ groupKey ] == group\n    groupData_x = data_x[ groupIndex ]\n    x1 = groupData_x[\n'X_Meas'\n]\n    y1 = groupData_x[\n'X'\n]\n    #print(x1)\n    # 将 x，y 分别增加一个轴，以满足 sklearn 中回归模型认可的数据\n    x1 = x1[:, np.newaxis]\n    y1 = y1[:, np.newaxis]\n\n\n    model = LinearRegression() # 构建线性模型\n    model.fit(x1, y1) # Overlayx自变量在前，因变量在后\n    R2_X = model.score(x1, y1) # 拟合程度 x R2\n    print(\n'R2_x = %.3f'\n % R2_X) # 输出 R2\n\n    rects5 = ax.bar(x - width/\n2\n, R2_X , width, label=\n'X_Rsq'\n)\n\n\nfor group \nin\n groups_y:\n    groupIndex = data_y[ groupKey ] == group\n    groupData_y = data_y[ groupIndex ]\n\n    x2 = groupData_y[\n'Y_Meas'\n]\n    y2 = groupData_y[\n'Y'\n]\n\n    # 将 x，y 分别增加一个轴，以满足 sklearn 中回归模型认可的数据\n    x2 = x2[:, np.newaxis]\n    y2 = y2[:, np.newaxis]\n\n\n    model = LinearRegression() # 构建线性模型\n    model.fit(x2, y2) # Overlayx自变量在前，因变量在后\n    R2_Y = model.score(x2, y2) # 拟合程度 y R2\n    print(\n'R2_y = %.3f'\n % R2_Y) # 输出 R2\n    rects6 = ax.bar(x + width/\n2\n, R2_Y , width, label=\n'Y_Rsq'\n)\n\n#########  Graph Correlation  #########\n\n\n\n\n# Add some text for labels, title and custom x-axis tick labels, etc.\nax.set_xticks(x)\nax.set_xticklabels(labels)\nax.set_ylim((\n0\n,\n1.3\n))                       #定义y轴的取值范围\nax.legend()\n\n\ndef autolabel(rects):\n\n        # attach some text labels\n\n    for rect \nin\n rects:\n\n        height = rect.get_height()\n\n        ax.text(rect.get_x()+rect.get_width()/\n2.0\n, \n1.0\n*height,\n\n                    \n'%.3f'\n%float(height), ha=\n'center'\n, va=\n'bottom'\n)\n\n            #‘%\n.2\nf’%float(height)这个设置是让显示的数值精度为小数点后两位小数\n\n\nautolabel(rects5)\nautolabel(rects6)\n\nfig_Correlation.tight_layout()\n#plt.savefig(\n'./RMSE.jpg'\n)   #把图片保存在当前路径下，必须放在plt.show()之前，否则将是空白\n\n\nplt.show()**实际\n![img](https:\n//img-mid.csdnimg.cn/release/static/image/mid/ask/474965811926134.png 'image.png')\n\n**\n想法\n\n![img](https:\n//img-mid.csdnimg.cn/release/static/image/mid/ask/144166811926148.png 'image.png')\n\n", "Tag": "算法分析"}
{"Answer": "\nresult_list = []\n\n\n# 调节子树为小根堆,从1开始为有效位，0是临时作用\ndef HeapAdjust(item_list: list, k: int, length: int):\n    item_list[0] = item_list[k]\n    i = k * 2\n    while i <= length:\n        if i < length and item_list[i] > item_list[i + 1]:  # 找儿子中小的\n            i += 1\n        if item_list[i] >= item_list[0]:\n            break\n        else:\n            result_list.append(str(k - 1)+' '+str(i - 1))\n            item_list[k] = item_list[i]\n            k = i\n        i *= 2\n    item_list[k] = item_list[0]\n    return item_list\n\n\ndef BuildMinHeap(item_list: list):\n    length = len(item_list) - 1\n    for i in range(int(length / 2), 0, -1):\n        item_list = HeapAdjust(item_list, i, length)\n    return item_list\n\n\ndef HeapSort(item_list: list):\n    item_list = BuildMinHeap(item_list)\n    \"\"\" # 如果要真的堆排序形成大根堆，下面的就不要注释\n    length = len(item_list) - 1\n    for i in range(length, 1, -1):\n        item_list[1], item_list[i] = item_list[i], item_list[1]\n        item_list = HeapAdjust(item_list, 1, i - 1)\n    \"\"\"\n    return item_list\n\n\ndef main():\n    item_list = [0]\n    _ = eval(input())\n    num_str = input()\n    num_str_list = num_str.strip().split()\n    num_str_list = [eval(item) for item in num_str_list]\n    item_list.extend(num_str_list)\n    HeapSort(item_list)\n    print(len(result_list))\n    for item in result_list:\n        print(item)\n\n\nmain()\n\n\"\"\"\n6\n0 1 2 3 4 5\n6\n7 6 5 4 3 2\n\"\"\"\n\n", "Konwledge_Point": "线性规划和规约", "Question": "用Python，计算输入特定数列之后，输出构建最小堆需要交换的两个数和交换的次数\n问题遇到的现象和发生背景\n\n\n构建堆是堆排序算法的关键步骤。该算法在最坏情况下的运行时间为 O(n log n)将数组转化为堆，需要对其元素进行多次交换。我们将交换称为交换元素 A[i] 和 A[j] 的基本操作。你在这个任务中的目标是将一个给定的数组转换成一个线性数量的交换的堆\n######数据输入输出例子解释\n输入第一行包含数字 n。下一行指定了一个数字数组 A[0], …… , A[n − 1] (1< n< 10^5; 0< A[i]< 10^9 for all 0< i< n - 1 ;所有A[i]都是成对不同的；i≠qj).输出输出的第一行必须包含交换次数m，必须满足不等式0 < m < 4 n。以下 m 行中的每一行都应指定数组 A 的两个元素的交换。每个交换由一对不同的索引 0< i≠qj< n - 1 定义，其中一个等式 j = 2i + 1, j = 2i + 2, i = 2j + 1 or i = 2j + 2 都满足了。按照指定的顺序应用所有的交换后，数组应该变成一个最小堆，即所有的都必须满足以下两个条件0< i< n -1\n如果 2i + 1< n − 1，则 A[i] < A[2i + 1]。\n如果 2i + 2< n − 1，则 A[i] < A[2i + 2]。\n\n\n问题相关例子\n\n\n1.输入\n6\n0 1 2 3 4 5\n输出\n0\n2.输入\n6\n7 6 5 4 3 2\n输出\n4\n2 5\n1 4\n0 2\n2 5\n\n\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果\n\n\n用Python，计算输入特定数列之后，输出构建最小堆需要交换的两个数和交换的次数", "Tag": "算法分析"}
{"Answer": "替换成其他激活函数理论上是可以的，不过也有可能无法收敛，最好是高次的非线性函数，这样才好拟合\npytorch实现的话，参考李沐老师的系列教程应该就差不多了：\n10 多层感知机 + 代码实现 - 动手学深度学习v2_哔哩哔哩_bilibili\n动手学深度学习 v2 - 从零开始介绍深度学习算法和代码实现课程主页：https://courses.d2l.ai/zh-v2/教材：https://zh-v2.d2l.ai/\n\n\n\nhttps://www.bilibili.com/video/BV1hh411U7gn\n\n\n课程主页：https://courses.d2l.ai/zh-v2/\n教材：https://zh-v2.d2l.ai/", "Konwledge_Point": "线性规划和规约", "Question": "关于Pytorch中神经网络自定义的问题\n现在想尝试在一个单个隐藏层的神经网络中。把传统的线性权重\"WX+b\"加上激活函数的复合函数, 替换成任意高次函数f(x)（例如\"Ax^3+Bx^2+Cx+d\"）,然后进行前向传播与反向传播请问是否可行。求相关的理论参考与pytorch实现的相关资料？", "Tag": "算法分析"}
{"Answer": "有难度Gerber 不包含原件的坐标，需要你自己用代码去识别和匹配原件对表贴的电阻电容，比如 0603 的电阻和电容没办法识别，需要人工干预。需要自己做一个原件库,库里定义原件的中心坐标，通过对比匹配的方式识别 Gerber 中对应的原件，才能确定原件的中心坐标及旋转角度。特别是一些非几何对称的原件没啥好办法确定中心。", "Konwledge_Point": "线性规划和规约", "Question": "一个完整的Gerber文件最少应该包含哪些信息？\n问题遇到的现象和发生背景\n\n\n一个完整的Gerber文件最少应该包含哪些信息？\n\n\n问题相关代码，请勿粘贴截图\n\n\n给一个Gerber文件，用C或C#，c++编写小程序，能将Gerber文件中的各个元件类型，元件位置坐标，元件放置角度等信息，生成一个文档\n应该如何展开编写？\n\n\n运行结果及报错内容\n\n\nGerber文件是指导光绘机雕刻的，里面的指令都是指导光绘机画图的起点终点如何划线等信息，如何转换成元件中心点的坐标？，如何确定元件类型及放置角度？下图是Gerber文件的代码\nG04 Generated by SunshineCAM 1.0.0.31*\n%FSLAX34Y34*%                        FS 格式描述  L 省略前导零，A 绝对坐标，三位整数，四位小数\n%MOMM*%                              MO Mode 单位          MM 毫米\n%ADD70C,0.000000*%               AD Aperture Definition 光圈描述    定义D70码为圆，直径 0MM\n%ADD71C,0.300000*%\n%LNConvertedAllPolygons*%                    LN 层名 ConvertedAllPolygons\n%LPD*%                                                    LP 层正负性  D 设置为正图\nG36*                                                         G36 打开多边形填充\nX635760Y1095810D02*                              D02 关光圈，移动到 X63 5760       Y109 5810\nX632760Y1095810D01*                              D01 划线，开光圈    X63 2760       Y109 5810\nG75*                                                          G75 启用 360°的画圆功能\nG03X631760Y1094720I-4J-999D01*            G03 逆时针圆周运动 I，J 格式描述弧形位置。\nG74*                                                          G74 关闭 360 度圆周运动\nG01*                                                          G01 1 倍线性运动\nX631760Y1091810D01*\nG75*\nG03X632760Y1090810I996J1D01*\nG74*", "Tag": "算法分析"}
{"Answer": "基于Monster 组和GPT的调写：(1) 要证明$T_a$是群$GL_n(R)$的自同构，需满足以下三个条件：\nT_a是一个映射：即对于任意A\\in GL_n(R)，$T_a(A)都是一个GL_n(R)中的矩阵。\nT_a是一个同态：即对于任意A,B\\in GL_n(R)，有T_a(AB)=T_a(A)T_a(B)。\nT_a是一个双射：即$T_a$是一个一一映射，并且它的逆映射T_a^{-1}也是一个映射。首先证明条件1：对于任意A\\in GL_n(R)，T_a(A)都是一个GL_n(R)中的矩阵。显然T_a(A)的行列式为\n\n|T_a(A)|=|BA(B^{-1})|=|B||A||B^{-1}|=|A|\n由于A\\in GL_n(R)，所以|A|\\neq 0，即T_a(A)\\in GL_n(R)。\n接着证明条件2：对于任意A,B\\in GL_n(R)，有T_a(AB)=T_a(A)T_a(B)。由于\nT_a(AB)=BAB^{-1}=BT_a(A)B^{-1}=T_a(A)T_a(B)\n因此T_a是一个同态。\n最后证明条件3：$T_a$是一个双射。首先证明T_a是一个单射，即对于任意A,B\\in GL_n(R)，如果T_a(A)=T_a(B)，则A=B。有\nT_a(A)=T_a(B)\\Rightarrow BAB^{-1}=A\\Rightarrow BA=AB\n因为B\\in GL_n(R)，所以B^{-1}存在，因此可以从左右两侧同时乘以B^{-1}得到A=B。因此T_a是一个单射。\n接着证明T_a是一个满射，即对于任意A\\in GL_n(R)，都存在一个B\\in GL_n(R)，使得T_a(B)=A。可以取B=a^{-1} A a，则有\nT_a(B)=BaB^{-1}=a^{-1}Aaa^{-1}A^{-1}a=a^{-1}AA^{-1}a=A\n因此T_a是一个满射。\n由上述三个条件可知，T_a是一个群GL_n(R)的自同构。\n二.\n对于任意的 B \\in GL_n(R)，定义 T_B : GL_n(R) \\to GL_n(R)，A \\mapsto B A B^{-1}，已经证明 T_B 是 GL_n(R) 的一个自同构。\n接下来，我们需要求解集合 \\cap { A \\in GL_n(R) \\mid T_B(A) = A}。\n注意到 T_B 是一个自同构，因此 T_B(A) = A 等价于 A = T_B^{-1}(A) = B^{-1} A B，即 A 和 B 共轭。因此，我们可以重写要求解的交集为：\n\\cap {A \\in GL_n(R) \\mid A = B C B^{-1} \\text{ for some } C \\in GL_n(R)}\n为了求解这个交集，我们可以考虑 $B$ 的不同特征值的情况。设 $B$ 的不同特征值为 $\\lambda_1, \\ldots, \\lambda_k$，它们各自的代数重数为 m_1, \\ldots, m_k。\n如果B 有重复的特征值，我们可以通过对 B 进行合同变换将其变成一个块对角矩阵，其中每个块都是一个 Jordan 块。因此，我们可以假设 B 已经是一个块对角矩阵，每个块都是一个 Jordan 块。\n在这个假设下，我们可以考虑每个 Jordan 块的情况。设 $B$ 的一个 Jordan 块为 $J(\\lambda, m)$，表示一个大小为 $m \\times m$ 的 Jordan 块，其对应的特征值为 $\\lambda$。设 $A$ 也可以写成块对角矩阵的形式，每个块的大小与 $J(\\lambda, m)$ 相同。\n如果 A 与 J(\\lambda, m) 不相似，那么它们一定不能共轭，因此我们可以限制每个块都是 J(\\lambda, m)。此时，我们只需要求解每个块的形式，即\n{ C \\in GL_m(R) \\mid C J(\\lambda, m) C^{-1} = J(\\lambda, m)}\n根据 Jordan 标准型的结论，上式等价于 $C$ 是一个 $m \\times m$ 的可逆矩阵，其第 i 列由 Jordan 矩阵的第 i列线性组合而成。因此，上式的解为GL_m(R)。\n综上所述，对于每个 Jordan 块，对应的解集为 GL_m(R)。因此，整个交集的解为 GL_{m_1}(R) \\times \\cdots \\times GL_{m_k}(R)，即一个分块对角矩阵，每个块的大小为 \\lambda_i 的代数重数。", "Konwledge_Point": "线性规划和规约", "Question": "求解高等代数相关问题解答\n设GLn(R)={Ae Mn(R) I IAI≠0｝为一般线性群.对任意B∈GLn（R)，定义\nTB:GLn(R)→GLn(R),\nA→BA(B-1)\n（1）证明Ta是群GLn(R）的一个自同构.\n(2)求  ∩     ｛A∈GLn(R）I TB(A)=A}.\n  B∈GLn(R)", "Tag": "算法分析"}
{"Answer": "已解答，望采纳！", "Konwledge_Point": "线性规划和规约", "Question": "求助，SAS语言编程题，在线等，急～！\n1.对数据集中的数据进行整理,删除那些年龄在0到100范围之外的观测。\n\n\n\n2.分别对男、女受试者的Oxy描述性统计,求其样本均值、方差、均值95%置信区间。\n\n\n\n3.以Runtime为因变量，Weight, Age OXy为变量作线性回归。", "Tag": "算法分析"}
{"Answer": "fit函数里面的while循环里的第一个if语句是想判断当前求得的self.w的精度，如果self.w和b的改变小于precision即认为精度达到要求，退出循环！\r\n\r\n而第一次while循环时明显没有可以拿来比较的，所以自己定义一个与self.w差距为1的w_last 来保证if判断 \r\n\r\n实际上你可以改成2，3，4，0.5都可以，随意。", "Konwledge_Point": "线性规划和规约", "Question": "关于机器学习梯度下降求 w 和 b 的问题\n# 类目的求解斜率和截距\nclass Linear_model(object):\n    def __init__(self):\n        self.w = np.random.randn(1)[0]\n\n        self.b = np.random.randn(1)[0]\n        print('----------------------起始随机生成的斜率和截距',self.w,self.b)\n\n#   model就是方程f(x) = wx + b\n    def model(self,x):\n        return self.w * x + self.b\n\n#   线性问题，原理都是最小二乘法\n    def loss(self,x,y):\n#         方程中几个未知数？？？\n        cost = (y - self.model(x))**2\n\n#         求偏导数 ，把其他的都当成已知数，求一个未知数的导数\n#         导数是偏导数的一种特殊形式\n        g_w = 2*(y - self.model(x))*(-x)\n        g_b = 2*(y - self.model(x))*(-1)\n        return g_w,g_b\n\n#     梯度下降\n    def gradient_descend(self,g_w,g_b,step = 0.01):\n#         更新新的斜率和截距\n        self.w = self.w - g_w*step\n        self.b = self.b - g_b*step\n        print('----------------------',self.w,self.b)\n\n    def fit(self,X,y):\n        w_last = self.w + 1\n        b_last = self.b + 1\n        precision = 0.00001\n        max_count = 3000\n        count = 0\n        while True:\n            if (np.abs(self.w - w_last) < precision) and (np.abs(self.b - b_last) < precision):\n                break\n\n            if count > max_count:\n                break\n\n#             更新斜率和截距\n            g_w = 0\n            g_b = 0\n            size = X.shape[0]\n            for xi,yi in zip(X,y):\n                g_w += self.loss(xi,yi)[0]/size\n                g_b += self.loss(xi,yi)[1]/size\n\n            self.gradient_descend(g_w,g_b)\n            count += 1\n\n    def coef_(self):\n            return self.w\n\n    def intercept_(self):\n            return self.b\n\n\n\n\n\n\n请问\n\n    def fit(self,X,y):\n\n        w_last = self.w + 1\n\n        b_last = self.b + 1\n\n这里为什么\n\n                w_last = self.w + 1\n\n        b_last = self.b + 1\n\n\n\n加一是什么意思", "Tag": "算法分析"}
{"Answer": "你可以使用以下代码在Python中生成一组随机数，并添加噪声：\nimport random\n\n# 生成随机数\nx1 = random.uniform(2, 22)\nx2 = random.uniform(40, 120)\ny = -2*x1 + 5*x2 + 46\n\n# 添加噪声\nnoise = random.uniform(-50, 50)\ny_noisy = y + noise\n\n\n\n接下来，你可以使用Keras库来实现一个双进单出的线性神经元网络，并用你产生的数据去训练它。以下是一个简单的示例代码：\nfrom keras.models import Sequential\nfrom keras.layers import Dense\nimport numpy as np\n\n# 生成训练数据\nX = np.random.uniform(low=[2, 40], high=[22, 120], size=(1000, 2))\ny = np.array([-2*x[0] + 5*x[1] + 46 for x in X])\ny_noisy = y + np.random.uniform(low=-50, high=50, size=(1000,))\n\n# 定义模型\nmodel = Sequential()\nmodel.add(Dense(1, input_dim=2))\n\n# 编译模型\nmodel.compile(loss='mean_squared_error', optimizer='adam')\n\n# 训练模型\nmodel.fit(X, y_noisy, epochs=100, batch_size=10)\n\n# 预测值\nx_test = np.array([[19, 120]])\ny_pred = model.predict(x_test)\nprint(y_pred)\n\n\n\n在上面的代码中，我们首先生成了1000个随机的(x1, x2, y)数据点，并添加了噪声。然后，我们定义了一个包含一个输入层和一个输出层的线性神经元网络，并使用均方误差作为损失函数进行编译。最后，我们使用训练好的模型来预测当(x1, x2) = (19, 120)时，y的值。", "Konwledge_Point": "线性规划和规约", "Question": "如何使用函数 y = -2x1+5x2+46 产生一组随机数，对每个y值添加一个 [-50, 50] 范围内的噪声？\n使用函数 y = -2\nx1+5\nx2+46 产生一组随机数，其中x1取值 [2, 22]，x2取值 [40, 120]，对每个y值添加一个 [-50, 50] 范围内的噪声。\n\n\n（1）请实现一个双进单出的线性神经元网络，并用你产生的这组数据去训练它。\n\n\n（2）使用你训练好的网络，预测一下，当 (x1, x2) = (19, 120) 时，y的值是多少？", "Tag": "算法分析"}
{"Answer": "哪一行报错，有截图吗", "Konwledge_Point": "线性规划和规约", "Question": "Python，在分析建模的过程中出现报错显示，找到样本数不一致的输入变量，有人能解释一下并解决这个问题吗？\n#建模预测\nx=data4.iloc[:,2].values.astype(float)\ny=data4.iloc[:,3:6].values.astype(float)\nfrom sklearn import model_selection\nx_train,x_test,y_train,y_test=model_selection.train_test_split(x,y,test_size=0.35,random_state=1)\nx_train=np.array(x).reshape(-1,1)\nx_test=np.array(x_train).reshape(-1,1)\ny_train=np.array(x).reshape(-1,1)\nfrom sklearn.linear_model import LinearRegression\nlinregTr=LinearRegression()\nlinregTr.fit(x_train,y_train)\nprint('线性回归模型的回归系数:',linregTr.coef_)\nprint('线性回归模型的截距:',linregTr.intercept_)\nfrom sklearn import metrics\ny_train_pred=linregTr.predict(x_train)\ny_test_pred=linregTr.predict(x_test)\ntrain_err=metrics.mean_squared_error(y_train,y_train_pred)\ntest_err=metrics.mean_squared_error(y_test,y_test_pred)\nprint('在训练集上的均方根误差是：',train_err)\nprint('在测试集上的均方根误差是：',test_err)\n到这里之后就开报错，说找到样本数不一致的输入变量", "Tag": "算法分析"}
{"Answer": "谢邀，私信沟通一手。", "Konwledge_Point": "线性规划和规约", "Question": "留学狗求大佬帮我看看这个C++哈希的问题怎么解答，需要在linux上跑\n这是英文原文，链接: https://pan.baidu.com/s/1obkghFd_C59xibGdI_-Mlw 提取码: r75f \n\n\n\n以下是翻译版本问题要求：\n\n\n\n描述（85分可交付成果/正确性/ 15分设计）\n\n\n\n我们首先提供您对该问题将要做什么的摘要。可交付成果 文件的末尾将提供输出格式。您将测试每个哈希 具有以下内容的实现：\n\n\n\nA）表中的元素总数（N），表的大小（T），负载系数 （Lambda = N / T），平均碰撞次数（M = C / N）和总碰撞次数 碰撞（C），\n\n\n\nB）您将检查另一个给定文件query_words.txt中的每个单词是否在哈希中 表格，并根据是否找到该单词打印相应的输出 找到了，找到该单词需要进行多少次探查（如果存在）。虽然你是 随文件一起提供，我们将使用看不见的测试文件以及另一个文件名，该文件名可能会 包含words.txt中所有单词的子集。\n\n\n\n为了实现上述目的，您将编写一个名为create_and_test_hash.cc的测试程序。 您的程序应像这样从终端运行（终端提示符为％）：\n\n\n\n% ./create_and_test_hash   \n\n\n\n对于二次探测应为“二次”，对于线性探测应为“ linear”，而“ double”应为“ double” 用于双重哈希。\n\n\n\n哈希和堆项目 例如，您可以在终端上写：\n\n\n\n% ./create_and_test_hash words.txt query_words.txt quadratic\n\n\n\n您可以使用提供的Makefile来编译和测试您的代码。\n\n\n\n对于双哈希，格式将略有不同，即如下：\n\n\n\n％./create_and_test_hash words.txt query_words.txt double R\n\n\n\n或者，也可以使用：\n\n\n\n％./create_and_test_hash words.txt query_words.txt double\n\n\n\n这里R是在实现double时应该使用的可选R值 在课堂上讨论并在教科书中描述的哈希技术：hash2（x）= R –（x mod R）。如果用户没有输入一个默认的R值，则应在代码中指定一个默认值 命令行。\n\n\n\n一，使用线性和二次探测进行散列（20分）\n\n\n\n修改提供的代码，以进行二次和线性探测，并测试create_and_test_hash。\n\n\n\n不要在其中的main（）函数内编写任何功能 create_and_test_hash.cc。在testHashingWrapper（）中编写所有功能 该文件中的功能。我们将使用我们自己的main函数，直接调用 testHashingWrapper（）。此包装函数将传递所有命令行参数 就像通常在主要功能中一样。\n\n\n\n您将打印上面提到的值，然后打印查询的单词，无论它们是 找到了，并确定了多少次探查。确切的交付物和输出格式 在文件末尾进行了描述。\n\n\n\n二。双重哈希（25分）\n\n\n\n编写代码以实现double_hashing.h，并使用create_and_test_hash进行测试。 这将是二次探测的变体。区别在于功能 FindPos（），现在必须使用其他策略来提供探测。作为第二个哈希 函数，请使用在课堂讲义中讨论并在教科书中找到的hash2（x）= R – （x mod R）。我们将使用我们自己的R值测试您的代码。此外，请指定哪个R README.HASH文件中用于测试程序的值。 切记不要在main（）函数中包含任何功能 create_and_test_hash.cc。\n\n\n\n您将打印当前的R值，上面A部分中提到的值，然后是 查询的单词，是否找到它们以及确定该单词需要进行多少次探查。精确的 文件的末尾描述了可交付成果和输出格式。\n\n\n\n三，拼写检查（40分）\n\n\n\n现在，您可以通过使用线性或二次或双精度来实现拼写检查器 哈希算法。给定一个文档，您的程序应正确输出所有 带有此类标签的拼写单词以及所有拼写错误的单词。对于每个拼写错误的单词 您应该提供字典中的候选更正列表，该列表可以由 将以下规则之一应用于拼写错误的单词：\n\n\n\na）在任何可能的位置添加一个字符\n\n\n\nb）从单词中删除一个字符\n\n\n\nc）交换单词中的相邻字符 您的程序应从命令行运行，如下所示：\n\n\n\n% ./spell_check  \n\n\n\n系统会为您提供一个名为document1_short.txt，document_1.txt的小文档， 还有一个字典文件，其中包含大约370k个单词，名为wordsEnglish.txt。 例如，您的拼写检查器应更正以下错误。\n\n\n\n决定性->决定性（情况A） 决策->决策（案例B） 乡镇->国家（案例C）\n\n\n\n纠正提供的词典文件中不存在的任何单词（即使它是正确的） 英文）。\n\n\n\n一些提示：1.请注意，我们提供的词典是实际英语词典的子集， 只要您的拼写检查是合乎逻辑的，您就可以取得成绩。 例如， 字母“ i”不在词典中，更正可能是“中”，“如果”甚至是 “你好”。 这是可接受的输出。\n\n\n\n2.另外，如果将“编辑者”更正为“编辑者”，则可以。 （案例B，删除 特点）\n\n\n\n3.我们建议删除开头和结尾的所有标点符号，对于所有标点符号 单词会将字母转换为小写字母（例如，“ Hello！”被替换为“ hello”， 在拼写检查之前）。\n\n\n\n不要在spell_check.cc的main（）函数内编写任何功能。 写 该文件中的testSpellingWrapper（）内部的所有功能。 我们将使用我们的 自己的主要功能，直接调用testSpellingWrapper（）。 该包装函数是 传递了所有命令行参数，就像通常在main函数中一样。 您将打印该单词，无论它是否已经正确拼写（又名找到），以及所有 如果在词典中找不到该单词，则可能进行拼写更正。 提防 解析时在文档中使用标点符号和格式！ 确切的可交付成果和输出格式如下所述。\n\n\n\n（以下某部分是我要递交的文件，我省略翻译）\n\n\n\n格式 对于线性和二次探测标志（第一部分），格式应如下：\n\n\n\nnumber_of_elements: \n\nsize_of_table: \n\nload_factor: \n\naverage_collisions: \n\ntotal_collisions: \n\n Found \n Not_Found \n Found \n\n\n\n请包括在表格属性部分和单词列表之间显示的单行（ASCII 10，列为“ <新行>”）。 请加下划线 在“没有”和“找到”之间。 这里显示的单词列表是一个示例，实际输出将取决于query_words.txt中的单词。average_collisions和total_collisions的值将根据所使用的计算机而有所不同。 切换机器或寻求帮助时请注意这一点。 您的提交将在同一台计算机上评分，因此，只要您的实现对其他所有内容都是正确的，这些值就将保持一致。 对于所有标记（线性，二次和双精度），都会发生这种情况。\n\n\n\n正确输出的示例（数字不代表实际表）：\n\n\n\nnumber_of_elements: 670\n\nsize_of_table: 1560\n\nload_factor: 0.429487\n\naverage_collisions: 0.005\n\ntotal_collisions: 3\n\nhill Found 1\n\nskiny Not_Found 3\n\nbaked Found 1\n\n\n\n \n\n\n\n对于双标记（第二部分），格式应如下：\n\n\n\nr_value: \n\n\n\n\n双散列的输出之间唯一的区别是增加了一行 r_value：。 紧接在该行下方的输出应与线性输出相同 和二次探查，如上所述。 请在“不”之间添加下划线 和“找到”。\n\n\n\n正确输出的示例（数字不代表实际表）：\n\n\n\nnumber_of_elements: 200\n\nsize_of_table: 750\n\nload_factor: 0.266666\n\naverage_collisions: 0.0135\n\ntotal_collisions: 3\n\nhill Found 1\n\nskiny Not_Found 3\n\nbaked Found 1\n\n\n\n对于拼写检查（第三部分），输出应如下所示。\n\n\n\n is CORRECT\n\n is CORRECT\n\n is INCORRECT\n\n***  ->  *** case \n\n***  ->  *** case \n is CORRECT\n\n\n\n请确保您的空格，大写字母和换行符正确无误。 请在输出中包括***和->。 这里显示的单词列表是一个 例如，实际输出将取决于文档文件中的单词。 可能有 每个案例类型有一个以上的结果。\n\n\n\n正确输出的示例：（显示的单词不代表实际值 输入）\n\n\n\ncountry is CORRECT\n\nlikely is CORRECT\n\nclimbing is CORRECT\n\nlwa is INCORRECT\n\n*** lwa -> wa *** case B\n\n*** lwa -> la *** case B\n\n*** lwa -> law *** case C\n\ncases is CORRECT\n\n\n\n \n\n\n\n ", "Tag": "算法分析"}
{"Answer": "采用正则表达是来过滤是一个很通用的做法，有的还有模版之类的。\r\n\r\n但是你现在的是爬新浪微薄的博客对吧，不知道你是通过什么知道http://blog.sina.com.cn/s/blog_xxxxxxxxxxxxxxxx.html 就是你要的target\r\n\r\n因为blog static id 都是加密过的 blogId， 所以你可以看到就算一个博主下面所有的blog static id 都是没有规律的\r\n\r\n所以我觉得你可以通过关系来爬，比如从博主，找到博友，在来找文章\r\n\r\n感觉有点博客搬家的感觉", "Konwledge_Point": "线性规划和规约", "Question": "有做爬虫经验的朋友，请教爬虫抓取url时的队列处理问题\n最近我在做一个爬虫毕业设计，爬虫分为2个队列，对应两张数据表seeds和targets，seeds是尽可能多的爬url，targets是分析seeds中的url是否为我所要的，是则插入，否则过掉。\n\n\n\n而我现在的问题是，由于网页上的url可以看成是多叉树（因为每个链接进去后，又会爬到更多的链接……），所以seeds队列的记录以指数级增长，而targets却几乎是线性增长的，很明显跟不上seeds速度，所以现在出现一种情况是程序执行10多秒后，seeds表中爬到了8000多个url，但targets表才100来个记录。。这样的话seeds显得过于臃肿，而targets却比较空闲。\n\n\n\n请教各位朋友是如何解决这两者的矛盾呢？", "Tag": "算法分析"}
{"Answer": "变量的名字写的很清楚了，prev是n-1项，prevPrev是n-2项。\r\n\r\n递归调用中传递prevPrev的引用，函数返回n-1项的值，同时在prevPrev里放上n-2项的值。", "Konwledge_Point": "线性规划和规约", "Question": "斐波那契 递归算法求解\n书上的一段线性递归看不懂。。求解释，多谢了！\n\n\n\n#include \n\nusing namespace std;\n\n\n\nint fib(int n,int &prev)\n\n{\n\n    if(n==0)\n\n    {\n\n        prev=1;\n\n        return 0;\n\n    }\n\n    else\n\n    {\n\n        int prevPrev;\n\n        prev = fib(n-1,prevPrev);\n\n        return prevPrev + prev;\n\n    }\n\n}\n\n\n\nint main()\n\n{\n\n    int p,n;\n\n    cin>>n;\n\n    cout<<fib(n,p);\n\n\n\nreturn 0;\n\n\n\n\n}", "Tag": "算法分析"}
{"Answer": "底层系统图形会自动刷新屏幕 。 ListView里面有可以调整滚动条的位置。\r\nListView.smoothScrollToPosition(0);//顶部\r\nListView.smoothScrollToPosition(listView.getCount() - 1);//底部", "Konwledge_Point": "线性规划和规约", "Question": "关于控件A设置了visibility控件B被挤压的问题\n我有一个垂直线性布局，上面的是控件A，下面的是控件B（控件B是listview）。\n\n起初控件A 是gone状态。控件B占据整个布局的高且控件B scroll到最底部。当触发了某事件，我设置控件A的状态变为visible。控件B被挤压了一部分。此时！问题来了，控件B会自动scroll到顶部。好像控件B 重绘了一样？我想知道设置完visible，控件B调用了哪个方法？", "Tag": "算法分析"}
{"Answer": "数据库事务的问题，第一批还没有入库完成，第二批的查询就开始了。建议处理数据库事务问题", "Konwledge_Point": "线性规划和规约", "Question": "jdbctemplate中save方法数据入库的问题。\n问题遇到的现象和发生背景\n\n\n做分段的线性插值时，分段的点上偶尔会出现重复插入的情况。\n举例：1，5，9 中 1-5，5-9分段插值，入库后偶尔会出现两条5的数据。\n实现方式：在保存前先查询数据库中是否已经有对应的点，没有则插入有则更新。\n使用组件：spring-JdbcTemplate\n状态：在mysql5.7中未发现问题，mysql5.6时偶尔出现5点重复入库（由于1-5,5-9顺序插值，推测1-5保存时不是立刻生效的状态）。\n\n\n问题:想请各位解惑：是jdbctemplate有异步机制（没有在源码中找到），还是mysql那有什么延迟入库的配置？ 需要如何排查？\n\n\n引用的class\ncom.nurkiewicz.jdbcrepository.JdbcRepository\norg.springframework.jdbc.core.JdbcTemplate", "Tag": "算法分析"}
{"Answer": "x取点太稀疏导致的。\n将\n\nx=0:pi:10*pi; \n改为\n\nx=0:0.01:10*pi; \n结果为：\n\n ", "Konwledge_Point": "线性规划和规约", "Question": "用matlab画图与函数不对应\n函数里面是包括正弦的，最后画出来成了三角线性的，不应该是曲线么\nx=0:pi:10*pi;\nR2=0.2;\ny=((1-R2).^2)./((1-R2).^2+4*R2.*(sin(x./2).^2));\nplot(x,y)\n", "Tag": "算法分析"}
{"Answer": "变量和内存不能这样理解。a=(double)a后a还是int类型，不会变成double类型，这点和python不一样，不能把python的思维带入C中来。在语言中，如果你进行类型强转，强转得到的值只是暂时的，这时它其实不在内存中，而是在CPU的寄存器里，更不会立即写入内存。不同的是，python可以自行保留右值的类型，但C/C++会隐式转换double值到整数再进行赋值。不存在跳过这种隐式转换的方法。\n以你的a=(double)a为例，CPU先从a所在的位置（当然，这一步常常要访存，也可能是直接从cache line读取）取出数据丢进一个能存放32位数值的寄存器里（寄存器本身是没有类型的概念的，它存储的可以是字符，可以是整数，可以是float甚至是没什么意义的脏数据。赋予类型意义的是CPU指令而不是存储器）。在我的编译器上，我看了下汇编码，如果是O2优化，CPU会直接把数据放进XMM寄存器，然后调用cvtsi2ss，cvttss2si指令进行转换。如果没有编译器优化，CPU还要多中转几次，但最终还是要调用这两条指令。（这是x86_64架构的结果，其他指令集和微架构上很可能有不同做法，但都会进行至少两条调用。）这两条调用的含义分别是有符号整数转浮点和浮点转有符号整数，显而易见，前者对应你写的显式强转，后者则是C/C++自动进行的隐式转换。\n这种转换通常没有什么实际意义，但是编译器似乎不会省略它们。", "Konwledge_Point": "线性规划和规约", "Question": "关于强转后内存地址的问题\n就是变量在内存里面是成线性排列的，但是现在我用强制类型转换，将相邻两个int型变量a，b中的a转换为double型，那a索取的内存要比原来int型多出4个字节的内存，它应该向哪里索取，毕竟旁边变量b已经占据了a 变量所需的四个字节", "Tag": "算法分析"}
{"Answer": "我现在写，望采纳！！点击该回答右侧的“采纳”按钮即可采纳！！这是一个比较全面的任务，需要用到 Python 中的不同机器学习库和模型来完成。\n\n对于第一类数据集，我们可以使用 NumPy 库来生成数据，并使用 scikit-learn 中的线性模型、决策树、感知机和双隐层全连接神经网络模型来进行分类。我们可以使用 scikit-learn 中的 train_test_split 函数将数据分成训练集和测试集，然后使用不同的模型训练数据并预测结果。最后，我们可以使用 scikit-learn 中的 classification_report 函数来计算各种指标，例如精度、召回率和 F1 分数，以及使用 matplotlib 库进行可视化。\n\n对于第二类数据集，我们可以使用 TensorFlow 库中的 MNIST 数据集加载器来载入数据。然后使用 TensorFlow 中的全连接神经网络模型对数据进行分类。我们可以使用 TensorFlow 中的数据划分器将数据划分为训练集和测试集，然后使用模型训练数据并预测结果。最后，我们可以使用 TensorFlow 中的 evaluate 函数来计算模型的准确率，并使用 matplotlib 库进行可视化。\n\n在尝试使用具有更多隐藏层的全连接神经网络时，我们可以通过更改模型的结构来增加隐藏层的数量。具体来说，我们可以使用 TensorFlow 中的 Keras API 来构建全连接神经网络模型，并使用 add 函数来增加更多的隐藏层。然后我们可以使用 TensorFlow 中的 compile 函数来配置模型的优化器和损失函数，并使用 fit 函数来训练模型。最后，我们可以使用 evaluate 函数来计算模型的准确率，并使用 matplotlib 库进行可视化。\n在比较不同模型的精度差异时，我们可以使用 classification_report 函数或 evaluate 函数计算出各种指标，并使用 matplotlib 库进行可视化。我们可以对比这些指标，来分析不同模型的优劣。此外，我们还可以考虑因素，例如模型的复杂度和训练数据的质量，来分析可能的原因。\n\n下面是一个示例代码，它使用 NumPy 和 scikit-learn 库来处理第一类数据集，并使用线性模型、决策树、感知机和双隐层全连接神经网络对数据进行分类：\n(1)\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.neural_network import MLPClassifier\nfrom sklearn.metrics import classification_report\nimport matplotlib.pyplot as plt\n\n# 生成数据\nX = np.random.randint(2, size=(1000, 4))\ny = np.logical_and(X[:, 0], X[:, 1])\n\n# 将数据划分为训练集和测试集\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\n\n# 定义模型\nmodels = [\n    LogisticRegression(),\n    DecisionTreeClassifier(),\n    MLPClassifier(hidden_layer_sizes=(2,))\n]\n\n# 分别训练模型并计算准确率\nfor model in models:\n    # 训练模型\n    model.fit(X_train, y_train)\n    # 计算准确率\n    accuracy = model.score(X_test, y_test)\n    print(f'{model.__class__.__name__}的准确率为：{accuracy:.2f}')\n你还可以使用 classification_report 函数计算更多的指标，例如精度、召回率和 F1 分数。\n\n\nfor model in models:\n    # 训练模型\n    model.fit(X_train, y_train)\n    # 预测测测试集结果\ny_pred = model.predict(X_test)\n# 计算指标\nreport = classification_report(y_test, y_pred)\nprint(f'{model.class.name}的指标：\\n{report}')\n\n如果你想要使用 matplotlib 库进行可视化，你可以使用 matplotlib 库中的 plot 函数绘制散点图或直方图来展示数据分布情况，或者使用 matplotlib 库中的 scatter 函数绘制散点图来展示模型的预测结果。\n例如，下面是使用 matplotlib 库绘制散点图的示例代码：\nplt.scatter(X[:, 0], X[:, 1], c=y)\nplt.title('数据分布情况')\nplt.xlabel('特征1')\nplt.ylabel('特征2')\nplt.show()\n\n\n\n最后，你可以对比各种模型的精度差异，分析可能的原因，并根据自己的目标来选择最优的模型。下面是一个使用 TensorFlow 和 Keras API 对现有的与、或、非、异或数据集进行分类并给出精度分析和可视化结果的示例代码：\nimport tensorflow as tf\nfrom tensorflow import keras\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n#生成数据\nX = np.random.randint(2, size=(1000, 4))\ny = np.logical_and(X[:, 0], X[:, 1])\n\n#将数据划分为训练集和测试集\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\n\n#使用 Keras API 构建双隐层全连接神经网络模型\nmodel = keras.Sequential([\nkeras.layers.Dense(128, activation='relu', input_shape=(4,)),\nkeras.layers.Dense(64, activation='relu'),\nkeras.layers.Dense(1, activation='sigmoid')\n])\n\n#配置模型的优化器和损失函数\nmodel.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])\n\n#训练模型\nhistory = model.fit(X_train, y_train, epochs=20, validation_data=(X_test, y_test))\n\n#计算模型的准确率\naccuracy = model.evaluate(X_test, y_test)[1]\nprint(f'模型的准确率为：{accuracy:.2f}')\n\n#使用 matplotlib 库绘制训练损失和验证损失\nplt.plot(history.history['loss'], label='train loss')\nplt.plot(history.history['val_loss'], label='validation loss')\n\nplt.legend()\nplt.show()\n\n#使用 matplotlib 库绘制训练精度和验证精度\nplt.plot(history.history['accuracy'], label='train accuracy')\nplt.plot(history.history['val_accuracy'], label='validation accuracy')\nplt.legend()\nplt.show()\n\n\n(2)下面是一个示例代码，它使用 TensorFlow 和 matplotlib 库来处理 MNIST 数据集，并使用线性模型、决策树、感知机和双隐层全连接神经网络对数据进行分类：\nimport tensorflow as tf\nfrom tensorflow import keras\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.neural_network import MLPClassifier\nimport matplotlib.pyplot as plt\n\n# 加载数据\n(X_train, y_train), (X_test, y_test) = keras.datasets.mnist.load_data()\n\n#将图像数据转换为一维向量\nX_train = X_train.reshape(X_train.shape[0], -1)\nX_test = X_test.reshape(X_test.shape[0], -1)\n\n#定义模型\nmodels = [\nLogisticRegression(),\nDecisionTreeClassifier(),\nMLPClassifier(hidden_layer_sizes=(50,))\n]\n\n#分别训练模型并计算准确率\nfor model in models:\n# 训练模型\nmodel.fit(X_train, y_train)\n# 计算准确率\naccuracy = model.score(X_test, y_test)\nprint(f'{model.class.name}的准确率为：{accuracy:.2f}')\n\n#使用 matplotlib 库进行可视化\nfor i, model in enumerate(models):\n# 预测测试数据\ny_pred = model.predict(X_test)\n# 绘制前 25 个测试图像和预测结果\nplt.figure(figsize=(10, 5))\nfor j in range(25):\nplt.subplot(5, 5, j+1)\nplt.imshow(X_test[j].reshape(28, 28), cmap='gray')\nplt.title(f'Predicted: {y_pred[j]}')\nplt.axis('off')\nplt.suptitle(f'{model.class.name}')\nplt.show()\n\n\n\n\n注意，在上述代码中，我们使用了 scikit-learn 中的线性模型、决策树和感知机模型来处理 MNIST 数据集。这些模型可能不适用于图像数据，因此可能不会得到很好的结果。此外，我们也可以使用 TensorFlow 中的 Keras API 来构建全连接神经网络模型，并使用 fit 函数来训练模型。最后，我们可以使用 evaluate 函数来计算模型的准确率，并使用 matplotlib 库进行可视化。\n下面是一个使用 TensorFlow 和 Keras API 构建双隐层全连接神经网络模型并训练 MNIST 数据集的示例代码：\nimport tensorflow as tf\nfrom tensorflow import keras\n\n#加载数据\n(X_train, y_train), (X_test, y_test) = keras.datasets.mnist.load_data()\n\n#将图像数据转换为一维向量\nX_train = X_train.reshape(X_train.shape[0], -1)\nX_test = X_test.reshape(X_test.shape[0], -1)\n\n#归一化数据\nX_train = X_train / 255.0\nX_test = X_test / 255.0\n\n#使用 Keras API 构建双隐层全连接神经网络模型\nmodel = keras.Sequential([\nkeras.layers.Dense(128, activation='relu', input_shape=(784,)),\nkeras.layers.Dense(64, activation='relu'),\nkeras.layers.Dense(10, activation='softmax')\n])\n\n#配置模型的优化器和损失函数\nmodel.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])训练模型\nmodel.fit(X_train, y_train, epochs=5)\n\n#评估模型\ntest_loss, test_acc = model.evaluate(X_test, y_test, verbose=2)\nprint(f'测试集的准确率：{test_acc:.2f}')\n\n#使用 matplotlib 库进行可视化\ny_pred = model.predict(X_test)\n\n#绘制前 25 个测试图像和预测结果\nplt.figure(figsize=(10, 5))\nfor i in range(25):\nplt.subplot(5, 5, i+1)\nplt.imshow(X_test[i].reshape(28, 28), cmap='gray')\nplt.title(f'Predicted: {np.argmax(y_pred[i])}')\nplt.axis('off')\nplt.show()\n\n\n\n\n注意，在上述代码中，我们使用了 TensorFlow 和 Keras API 来构建双隐层全连接神经网络模型，并使用 fit 函数来训练模型。然后使用 evaluate 函数来计算模型的准确率，并使用 matplotlib 库进行可视化。", "Konwledge_Point": "线性规划和规约", "Question": "关于#机器学习#的问题，如何解决？\n实验主要内容：\n现有两类数据集：第一类是与、或、非、异或四个数据集，第二类是MNIST手写体数字图片数据集。请分别用教材《机器学习》（周志华著）第3章中的线性模型（任务一，满分20分）、第4章中的决策树（任务二，满分20分）、以及第5章中的感知机（任务三，满分20分）和双隐层全连接神经网络（任务四，满分25分）分别对上述两类数据集进行分类并给出精度分析和可视化结果；以及尝试采用具有更多隐藏层的全连接神经网络对第二类数据集进行分类，并给出精度分析和可视化结果（任务五，满分10分）；最后需要对比上述五种任务中的不同模型得到的精度差别，并分析可能的原因，以及由此受到的启发（任务六，满分5分）。\n报告内容要求：\n（1）编程采用MATLAB或Python，代码的所有行均需要有注释。代码单独提交，多个代码需要组织合理，环境配置要清楚指明。\n（2）任务一到任务四的核心算法部分不可以调用库函数，否则最多得相应满分的60%。\n（3）任务一到任务五都可能在编程正确的情况下依然效果不理想，请提出相应的改进方案。在改进时，任务一到任务四的模型类型不能改变，任务五的模型类型可以改变。\n（4）任务一和任务二可以只采用一种算法进行实验，不要求采用所有相关算法。\n（5）报告中可以粘贴代码，但是尽量控制粘贴的代码篇幅，代码的分析和评价以实际提交的代码为主。", "Tag": "算法分析"}
{"Answer": "我现在写，望采纳！！点击该回答右侧的“采纳”按钮即可采纳！！这是一个比较全面的任务，需要用到 Python 中的不同机器学习库和模型来完成。\n\n对于第一类数据集，我们可以使用 NumPy 库来生成数据，并使用 scikit-learn 中的线性模型、决策树、感知机和双隐层全连接神经网络模型来进行分类。我们可以使用 scikit-learn 中的 train_test_split 函数将数据分成训练集和测试集，然后使用不同的模型训练数据并预测结果。最后，我们可以使用 scikit-learn 中的 classification_report 函数来计算各种指标，例如精度、召回率和 F1 分数，以及使用 matplotlib 库进行可视化。\n\n对于第二类数据集，我们可以使用 TensorFlow 库中的 MNIST 数据集加载器来载入数据。然后使用 TensorFlow 中的全连接神经网络模型对数据进行分类。我们可以使用 TensorFlow 中的数据划分器将数据划分为训练集和测试集，然后使用模型训练数据并预测结果。最后，我们可以使用 TensorFlow 中的 evaluate 函数来计算模型的准确率，并使用 matplotlib 库进行可视化。\n\n在尝试使用具有更多隐藏层的全连接神经网络时，我们可以通过更改模型的结构来增加隐藏层的数量。具体来说，我们可以使用 TensorFlow 中的 Keras API 来构建全连接神经网络模型，并使用 add 函数来增加更多的隐藏层。然后我们可以使用 TensorFlow 中的 compile 函数来配置模型的优化器和损失函数，并使用 fit 函数来训练模型。最后，我们可以使用 evaluate 函数来计算模型的准确率，并使用 matplotlib 库进行可视化。\n在比较不同模型的精度差异时，我们可以使用 classification_report 函数或 evaluate 函数计算出各种指标，并使用 matplotlib 库进行可视化。我们可以对比这些指标，来分析不同模型的优劣。此外，我们还可以考虑因素，例如模型的复杂度和训练数据的质量，来分析可能的原因。\n下面是一个示例代码，它使用 NumPy 和 scikit-learn 库来处理第一类数据集，并使用线性模型、决策树、感知机和双隐层全连接神经网络对数据进行分类：\n(1)\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.neural_network import MLPClassifier\nfrom sklearn.metrics import classification_report\nimport matplotlib.pyplot as plt\n \n# 生成数据\nX = np.random.randint(2, size=(1000, 4))\ny = np.logical_and(X[:, 0], X[:, 1])\n \n# 将数据划分为训练集和测试集\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\n \n# 定义模型\nmodels = [\n    LogisticRegression(),\n    DecisionTreeClassifier(),\n    MLPClassifier(hidden_layer_sizes=(2,))\n]\n \n# 分别训练模型并计算准确率\nfor model in models:\n    # 训练模型\n    model.fit(X_train, y_train)\n    # 计算准确率\n    accuracy = model.score(X_test, y_test)\n    print(f'{model.__class__.__name__}的准确率为：{accuracy:.2f}')\n你还可以使用 classification_report 函数计算更多的指标，例如精度、召回率和 F1 分数。\n \n \nfor model in models:\n    # 训练模型\n    model.fit(X_train, y_train)\n    # 预测测测试集结果\ny_pred = model.predict(X_test)\n# 计算指标\nreport = classification_report(y_test, y_pred)\nprint(f'{model.class.name}的指标：\\n{report}')\n\n\n如果你想要使用 matplotlib 库进行可视化，你可以使用 matplotlib 库中的 plot 函数绘制散点图或直方图来展示数据分布情况，或者使用 matplotlib 库中的 scatter 函数绘制散点图来展示模型的预测结果。\n例如，下面是使用 matplotlib 库绘制散点图的示例代码：\nplt.scatter(X[:, 0], X[:, 1], c=y)\nplt.title('数据分布情况')\nplt.xlabel('特征1')\nplt.ylabel('特征2')\nplt.show()\n\n\n最后，你可以对比各种模型的精度差异，分析可能的原因，并根据自己的目标来选择最优的模型。下面是一个使用 TensorFlow 和 Keras API 对现有的与、或、非、异或数据集进行分类并给出精度分析和可视化结果的示例代码：\nimport tensorflow as tf\nfrom tensorflow import keras\nimport numpy as np\nimport matplotlib.pyplot as plt\n \n#生成数据\nX = np.random.randint(2, size=(1000, 4))\ny = np.logical_and(X[:, 0], X[:, 1])\n \n#将数据划分为训练集和测试集\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\n \n#使用 Keras API 构建双隐层全连接神经网络模型\nmodel = keras.Sequential([\nkeras.layers.Dense(128, activation='relu', input_shape=(4,)),\nkeras.layers.Dense(64, activation='relu'),\nkeras.layers.Dense(1, activation='sigmoid')\n])\n \n#配置模型的优化器和损失函数\nmodel.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])\n \n#训练模型\nhistory = model.fit(X_train, y_train, epochs=20, validation_data=(X_test, y_test))\n \n#计算模型的准确率\naccuracy = model.evaluate(X_test, y_test)[1]\nprint(f'模型的准确率为：{accuracy:.2f}')\n \n#使用 matplotlib 库绘制训练损失和验证损失\nplt.plot(history.history['loss'], label='train loss')\nplt.plot(history.history['val_loss'], label='validation loss')\n \nplt.legend()\nplt.show()\n \n#使用 matplotlib 库绘制训练精度和验证精度\nplt.plot(history.history['accuracy'], label='train accuracy')\nplt.plot(history.history['val_accuracy'], label='validation accuracy')\nplt.legend()\nplt.show()\n\n\n(2)下面是一个示例代码，它使用 TensorFlow 和 matplotlib 库来处理 MNIST 数据集，并使用线性模型、决策树、感知机和双隐层全连接神经网络对数据进行分类：\nimport tensorflow as tf\nfrom tensorflow import keras\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.neural_network import MLPClassifier\nimport matplotlib.pyplot as plt\n \n# 加载数据\n(X_train, y_train), (X_test, y_test) = keras.datasets.mnist.load_data()\n \n#将图像数据转换为一维向量\nX_train = X_train.reshape(X_train.shape[0], -1)\nX_test = X_test.reshape(X_test.shape[0], -1)\n \n#定义模型\nmodels = [\nLogisticRegression(),\nDecisionTreeClassifier(),\nMLPClassifier(hidden_layer_sizes=(50,))\n]\n \n#分别训练模型并计算准确率\nfor model in models:\n# 训练模型\nmodel.fit(X_train, y_train)\n# 计算准确率\naccuracy = model.score(X_test, y_test)\nprint(f'{model.class.name}的准确率为：{accuracy:.2f}')\n \n#使用 matplotlib 库进行可视化\nfor i, model in enumerate(models):\n# 预测测试数据\ny_pred = model.predict(X_test)\n# 绘制前 25 个测试图像和预测结果\nplt.figure(figsize=(10, 5))\nfor j in range(25):\nplt.subplot(5, 5, j+1)\nplt.imshow(X_test[j].reshape(28, 28), cmap='gray')\nplt.title(f'Predicted: {y_pred[j]}')\nplt.axis('off')\nplt.suptitle(f'{model.class.name}')\nplt.show()\n \n\n\n注意，在上述代码中，我们使用了 scikit-learn 中的线性模型、决策树和感知机模型来处理 MNIST 数据集。这些模型可能不适用于图像数据，因此可能不会得到很好的结果。此外，我们也可以使用 TensorFlow 中的 Keras API 来构建全连接神经网络模型，并使用 fit 函数来训练模型。最后，我们可以使用 evaluate 函数来计算模型的准确率，并使用 matplotlib 库进行可视化。\n下面是一个使用 TensorFlow 和 Keras API 构建双隐层全连接神经网络模型并训练 MNIST 数据集的示例代码：\nimport tensorflow as tf\nfrom tensorflow import keras\n \n#加载数据\n(X_train, y_train), (X_test, y_test) = keras.datasets.mnist.load_data()\n \n#将图像数据转换为一维向量\nX_train = X_train.reshape(X_train.shape[0], -1)\nX_test = X_test.reshape(X_test.shape[0], -1)\n \n#归一化数据\nX_train = X_train / 255.0\nX_test = X_test / 255.0\n \n#使用 Keras API 构建双隐层全连接神经网络模型\nmodel = keras.Sequential([\nkeras.layers.Dense(128, activation='relu', input_shape=(784,)),\nkeras.layers.Dense(64, activation='relu'),\nkeras.layers.Dense(10, activation='softmax')\n])\n \n#配置模型的优化器和损失函数\nmodel.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])训练模型\nmodel.fit(X_train, y_train, epochs=5)\n \n#评估模型\ntest_loss, test_acc = model.evaluate(X_test, y_test, verbose=2)\nprint(f'测试集的准确率：{test_acc:.2f}')\n \n#使用 matplotlib 库进行可视化\ny_pred = model.predict(X_test)\n \n#绘制前 25 个测试图像和预测结果\nplt.figure(figsize=(10, 5))\nfor i in range(25):\nplt.subplot(5, 5, i+1)\nplt.imshow(X_test[i].reshape(28, 28), cmap='gray')\nplt.title(f'Predicted: {np.argmax(y_pred[i])}')\nplt.axis('off')\nplt.show()\n\n\n注意，在上述代码中，我们使用了 TensorFlow 和 Keras API 来构建双隐层全连接神经网络模型，并使用 fit 函数来训练模型。然后使用 evaluate 函数来计算模型的准确率，并使用 matplotlib 库进行可视化。", "Konwledge_Point": "线性规划和规约", "Question": "有关#机器学习#的问题，怎么解决？\n现有两类数据集：第一类是与、或、非、异或四个数据集，第二类是MNIST手写体数字图片数据集。请分别用教材《机器学习》（周志华著）第3章中的线性模型（任务一）、第4章中的决策树（任务二）、以及第5章中的感知机（任务三）和双隐层全连接神经网络（任务四）分别对上述两类数据集进行分类并给出精度分析和可视化结果；以及尝试采用具有更多隐藏层的全连接神经网络对第二类数据集进行分类，并给出精度分析和可视化结果（任务五）；最后需要对比上述五种任务中的不同模型得到的精度差别，并分析可能的原因，以及由此受到的启发（任务六）。\n要求：\n（1）编程采用MATLAB或Python，代码的所有行均需要有注释。代码单独提交，多个代码需要组织合理，环境配置要清楚指明。\n（2）任务一到任务四的核心算法部分不可以调用库函数，否则最多得相应满分的60%。\n（3）任务一到任务五都可能在编程正确的情况下依然效果不理想，请提出相应的改进方案。在改进时，任务一到任务四的模型类型不能改变，任务五的模型类型可以改变。\n（4）任务一和任务二可以只采用一种算法进行实验，不要求采用所有相关算法。", "Tag": "算法分析"}
{"Answer": "不知道你说的集合是什么\r\n因为中文翻译的缘故，好几个词都被翻译成集合。\r\n比如说\r\nCollection\r\nSet\r\n其中Collection是一个抽象的接口，它的下层实现可以是数组也可以是链表\r\n而Set一般用散列表实现。", "Konwledge_Point": "线性规划和规约", "Question": "求大神指点, 集合算是数据结构的一种么?\n在网上看到不少有关数据结构的文章,发现有些中数据结构中有集合,有些没有,所以想请教一下大佬,集合算不算数据结构的一种. 其它的几种类型为 \n\n\n\n\n\n线性结构 \n\n\n\n\n树形结构 \n\n\n\n\n图形结构 \n\n\n\n\n数组 \n\n\n\n\n栈 \n\n\n\n\n队列 \n\n\n\n\n链表 \n\n\n\n\n散列表 \n\n有些还有堆,不过堆算是树形结构的一种,可能我的描述有问题,欢迎指出\n\n", "Tag": "算法分析"}
{"Answer": "https://wenku.baidu.com/view/fb00c1c2c4da50e2524de518964bcf84b8d52d62.html", "Konwledge_Point": "线性规划和规约", "Question": "数据结构实验：单链表\n实现线性结构上的单链表的产生以及元素的查找、插入与删除。具体实现要求：\n\n（1）从键盘输入20个整数，用前插法或尾插法输入结点值。\n\n（2）从键盘输入1个整数，在单链表中查找该结点的位置。若找到，则显示“找到了”；否则，则显示“找不到”。\n\n（3）从键盘输入2个整数，一个表示欲插入的位置i，另一个表示欲插入的数值x，将x插入在对应位置上，输出单链表所有结点值，观察输出结果。\n\n（4）从键盘输入1个整数，表示欲删除结点的位置，输出单链表所有结点值，观察输出结果。\n\n（5）将单链表中值重复的结点删除，使所得的结果表中个结点值均不相同，输出单链表所有结点值，观察输出结果。\n\n（6）删除其中所有数据值为偶数的结点，输出单链表所有结点值，观察输出结果。\n\n（7）将单链表分解成两个单链表A和B，使A链表中含有原链表中序号为奇数的元素，而B链表中含有原链表中序号为偶数的元素，且保持原来的相对顺序，分别输出单链表A和单链表B的所有结点值，观察输出结果。", "Tag": "算法分析"}
{"Answer": "sigmoid和和tanh两个函数虽然都是[0, 1]，但是你会发现他们的导数是不一样的，tanh的导数范围是[-1, 1], 而sigmoid的导数范围是[0, 0.25]，在反向传播的时候，sigmoid会很容易导致梯度消失，而不收敛。有帮助，请采纳，谢谢！", "Konwledge_Point": "线性规划和规约", "Question": "关于MINIST的GAN网络中归一化参数修改的问题\n最近在学GAN，今天试着跑了一下网上的代码，但是看到网上没有一个选择用MINIST的0-1分布的归一化的，想着网络跑0-1分布的会快一点，就改了一下参数，改动如下：\n把归一化的参数改成了0.1307和0.3081，把生成器最后一层的Tanh改成了Sigmoid。照理说这两个激活函数的性质差不多，为啥最后会不收敛呢？\n改动后代码如下：\n\n\nimport\n torch.autograd\n\nimport\n torch.nn \nas\n nn\n\nfrom\n torch.autograd \nimport\n Variable\n\nfrom\n torchvision \nimport\n transforms\n\nfrom\n torchvision \nimport\n datasets\n\nfrom\n torchvision.utils \nimport\n save_image\n\nimport\n os\n \n# 创建文件夹\n\nif\n not os.path.exists(\n'D:\\pytorch_lx\\GAN image'\n):\n    os.mkdir(\n'D:\\pytorch_lx\\GAN image'\n)\n \n \ndef to_img(x):\n    out = \n0.3081\n*x+\n0.1307\n\n    out = out.clamp(\n0\n, \n1\n)  # Clamp函数可以将随机变化的数值限制在一个给定的区间[min, max]内：\n    out = out.view(\n-1\n, \n1\n, \n28\n, \n28\n)  # view()函数作用是将一个多行的Tensor,拼接成一行\n    return out\n \n \nbatch_size = \n128\n\nnum_epoch = \n100\n\nz_dimension = \n100\n\n# 图像预处理\nimg_transform = transforms.Compose([\n    transforms.ToTensor(),\n    transforms.Normalize((\n0.1307\n,), (\n0.3081\n,))  # (x-mean) / std\n])\n \n# mnist dataset mnist数据集下载\nmnist = datasets.MNIST(\n    root=\n'D:\\pytorch_lx\\diabetes trainner'\n, train=\nTrue\n, transform=img_transform, download=\nTrue\n\n)\n \n# data loader 数据载入\ndataloader = torch.utils.data.DataLoader(\n    dataset=mnist, batch_size=batch_size, shuffle=\nTrue\n\n)\n \n \n# 定义判别器  #####Discriminator######使用多层网络来作为判别器\n# 将图片\n28\nx28展开成\n784\n，然后通过多层感知器，中间经过斜率设置为\n0.2\n的LeakyReLU激活函数，\n# 最后接sigmoid激活函数得到一个\n0\n到\n1\n之间的概率进行二分类。\n\nclass\n discriminator(nn.Module):\n    def __init__(self):\n        super(discriminator, self).__init__()\n        self.dis = nn.Sequential(\n            nn.Linear(\n784\n, \n256\n),  # 输入特征数为\n784\n，输出为\n256\n\n            nn.LeakyReLU(\n0.2\n),  # 进行非线性映射\n            nn.Linear(\n256\n, \n256\n),  # 进行一个线性映射\n            nn.LeakyReLU(\n0.2\n),\n            nn.Linear(\n256\n, \n1\n),\n            nn.Sigmoid()  # 也是一个激活函数，二分类问题中，\n            # sigmoid可以班实数映射到【\n0\n,\n1\n】，作为概率值，\n            # 多分类用softmax函数\n        )\n \n    def forward(self, x):\n        x = self.dis(x)\n        return x\n \n \n# ###### 定义生成器 Generator #####\n# 输入一个\n100\n维的\n0\n～\n1\n之间的高斯分布，然后通过第一层线性变换将其映射到\n256\n维,\n# 然后通过LeakyReLU激活函数，接着进行一个线性变换，再经过一个LeakyReLU激活函数，\n# 然后经过线性变换将其变成\n784\n维，最后经过Tanh激活函数是希望生成的假的图片数据分布\n# 能够在\n-1\n～\n1\n之间。\n\nclass\n generator(nn.Module):\n    def __init__(self):\n        super(generator, self).__init__()\n        self.gen = nn.Sequential(\n            nn.Linear(\n100\n, \n256\n),  # 用线性变换将输入映射到\n256\n维\n            nn.ReLU(\nTrue\n),  # relu激活\n            nn.Linear(\n256\n, \n256\n),  # 线性变换\n            nn.ReLU(\nTrue\n),  # relu激活\n            nn.Linear(\n256\n, \n784\n),  # 线性变换\n            nn.Sigmoid()  # Tanh激活使得生成数据分布在【\n-1\n,\n1\n】之间，因为输入的真实数据的经过transforms之后也是这个分布\n        )\n \n    def forward(self, x):\n        x = self.gen(x)\n        return x\n \n \n# 创建对象\nD = discriminator()\nG = generator()\n\nif\n torch.cuda.is_available():\n    D = D.cuda()\n    G = G.cuda()\n \n \n# 首先需要定义loss的度量方式  （二分类的交叉熵）\n# 其次定义 优化函数,优化函数的学习率为\n0.0003\n\ncriterion = nn.BCELoss()  # 是单目标二分类交叉熵函数\nd_optimizer = torch.optim.Adam(D.parameters(), lr=\n0.0003\n)\ng_optimizer = torch.optim.Adam(G.parameters(), lr=\n0.0003\n)\n \n# ##########################进入训练##判别器的判断过程#####################\nfor epoch \nin\n range(num_epoch):  # 进行多个epoch的训练\n    for i, (img, _) \nin\n enumerate(dataloader):\n        num_img = img.size(\n0\n)\n        # view()函数作用是将一个多行的Tensor,拼接成一行\n        # 第一个参数是要拼接的tensor,第二个参数是\n-1\n\n        # =============================训练判别器==================\n        img = img.view(num_img, \n-1\n)  # 将图片展开为\n28\n*\n28\n=\n784\n\n        real_img = Variable(img).cuda()  # 将tensor变成Variable放入计算图中\n        real_label = Variable(torch.ones(num_img)).cuda()  # 定义真实的图片label为\n1\n\n        fake_label = Variable(torch.zeros(num_img)).cuda()  # 定义假的图片的label为\n0\n\n \n        # ########判别器训练train#####################\n        # 分为两部分：\n1\n、真的图像判别为真；\n2\n、假的图像判别为假\n        # 计算真实图片的损失\n        real_out = D(real_img)  # 将真实图片放入判别器中\n        d_loss_real = criterion(real_out.squeeze(\n-1\n), real_label)  # 得到真实图片的loss\n        real_scores = real_out  # 得到真实图片的判别值，输出的值越接近\n1\n越好\n        # 计算假的图片的损失\n        z = Variable(torch.randn(num_img, z_dimension)).cuda()  # 随机生成一些噪声\n        fake_img = G(z).detach()  # 随机噪声放入生成网络中，生成一张假的图片。 # 避免梯度传到G，因为G不用更新, detach分离\n        fake_out = D(fake_img)  # 判别器判断假的图片，\n        d_loss_fake = criterion(fake_out.squeeze(\n-1\n), fake_label)  # 得到假的图片的loss\n        fake_scores = fake_out  # 得到假图片的判别值，对于判别器来说，假图片的损失越接近\n0\n越好\n        # 损失函数和优化\n        d_loss = d_loss_real + d_loss_fake  # 损失包括判真损失和判假损失\n        d_optimizer.zero_grad()  # 在反向传播之前，先将梯度归\n0\n\n        d_loss.backward()  # 将误差反向传播\n        d_optimizer.step()  # 更新参数\n \n        # ==================训练生成器============================\n        # ###############################生成网络的训练###############################\n        # 原理：目的是希望生成的假的图片被判别器判断为真的图片，\n        # 在此过程中，将判别器固定，将假的图片传入判别器的结果与真实的label对应，\n        # 反向传播更新的参数是生成网络里面的参数，\n        # 这样可以通过更新生成网络里面的参数，来训练网络，使得生成的图片让判别器以为是真的\n        # 这样就达到了对抗的目的\n        # 计算假的图片的损失\n        z = Variable(torch.randn(num_img, z_dimension)).cuda()  # 得到随机噪声\n        fake_img = G(z)  # 随机噪声输入到生成器中，得到一副假的图片\n        output = D(fake_img)  # 经过判别器得到的结果\n        g_loss = criterion(output.squeeze(\n-1\n), real_label)  # 得到的假的图片与真实的图片的label的loss\n        # bp and optimize\n        g_optimizer.zero_grad()  # 梯度归\n0\n\n        g_loss.backward()  # 进行反向传播\n        g_optimizer.step()  # .step()一般用在反向传播后面,用于更新生成网络的参数\n \n        # 打印中间的损失\n        \nif\n (i + \n1\n) % \n100\n == \n0\n:\n            print(\n'Epoch[{}/{}],d_loss:{:.6f},g_loss:{:.6f} '\n\n                  \n'D real: {:.6f},D fake: {:.6f}'\n.format(\n                epoch, num_epoch, d_loss.data.item(), g_loss.data.item(),\n                real_scores.data.mean(), fake_scores.data.mean()  # 打印的是真实图片的损失均值\n            ))\n        \nif\n epoch == \n0\n:\n            real_images = to_img(real_img.cpu().data)\n            save_image(real_images, r\n'D:\\pytorch_lx\\GAN image\\real_images.png'\n)\n    fake_images = to_img(fake_img.cpu().data)\n    save_image(fake_images, r\n'D:\\pytorch_lx\\GAN image\\fake_images-{}.png'\n.format(epoch + \n1\n))\n \n# 保存模型\ntorch.save(G.state_dict(), \n'D:\\pytorch_lx\\GAN module\\generator.pth'\n)\ntorch.save(D.state_dict(), \n'D:\\pytorch_lx\\GAN module\\discriminator.pth'\n)\n\n", "Tag": "算法分析"}
{"Answer": "该回答引用ChatGPT \n根据 nn.MultiheadAttention 的文档，query, key, value 输入的形状应该是 (seq_len, batch_size, embed_dim)，即每个时间步的输入向量形状是 (batch_size, embed_dim)。这里的 query, key, value 应该是经过线性变换后的向量。\n在 nn.MultiheadAttention 的初始化中，有三个线性层，分别对应 query, key, value 的线性变换，可以使用 nn.Linear 模块来实现，其中 in_features 表示输入向量的维度，out_features 表示输出向量的维度。比如：\nquery_linear = nn.Linear(embed_dim, embed_dim)\nkey_linear = nn.Linear(embed_dim, embed_dim)\nvalue_linear = nn.Linear(embed_dim, embed_dim)\n\nquery = query_linear(y)\nkey = key_linear(x)\nvalue = value_linear(x)\n\n\n这样，query, key, value 就是经过线性变换后的向量。", "Konwledge_Point": "线性规划和规约", "Question": "关于#人工智能#的问题：这个地方应该是query = y，value = x还是 query =wy ，key =wx，  value = wx ，其中w为训练参数\nmultihead_attn = nn.MultiheadAttention(embed_dim, num_heads)\nattn_output = multihead_attn(query, key, value)[0]\n\n\noutput: torch.Size([12, 64, 300])\n\n\nbatch_size 为 64，有 12 个词，每个词的向量是 300 维\n\n\n我想知道这个query、key、value是经过线性变换前的还是已经变换后的。\n\n\n比如原来的基础embding是x、y。\n\n\n这个地方应该是query = y，key =x，value = x\n还是 query =wy ，key =wx，  value = wx ，其中w为训练参数。", "Tag": "算法分析"}
{"Answer": "% 定义网格\nN = 64;  % 单元数\nh = pi/2 / N;  % 单元长度\nx = 0:h:pi/2;  % 节点坐标\n\n% 定义系数矩阵和右端项\nA = zeros(N+1);\nb = zeros(N+1, 1);\nfor i = 2:N\n    A(i, i-1) = 1/h^2;\n    A(i, i) = -2/h^2;\n    A(i, i+1) = 1/h^2;\n    b(i) = -exp(x(i)) * (-cos(x(i)) + 2*sin(x(i)) + x(i)*cos(x(i)) + x(i)*sin(x(i)));\nend\n\n% 在边界处添加约束条件\nA(1,1) = 1;\nb(1) = 0;\nA(N+1,N+1) = 1;\nb(N+1) = 0;\n\n% 求解线性方程组\nu = A\\b;\n\n% 计算精确解\nuexact = x .* cos(x);\n\n% 计算最大误差\nerror = max(abs(u - uexact));\n\n% 输出最大误差\ndisp(error);\n\n望采纳。", "Konwledge_Point": "线性规划和规约", "Question": "微分方程数值解求uu解答\n用连续分片线性有限元方法求解下列方程\n\n\n-d(k(x)du/dx)/dx=f,,0 < 𝑥 <π/2\n𝑢(0) = 0, 𝑢 (π/2) = 0\n其中，k(x) = 𝑒^(𝑥)\n, 𝑓 = −𝑒^(𝑥)[cos(𝑥) − 2 sin(𝑥) − 𝑥𝑐𝑜𝑠(𝑥) − 𝑥𝑠𝑖𝑛(𝑥)]，精确解为\nu(x) = xcos(x)。给出有限元方法，并进行数值实验分别给出在 N=4,8,16,32,64 等\n分下的最大误差（附程序，体现局部单元的节点与整体节点的映射关系）\n需要程序，需要程序，需要程序", "Tag": "算法分析"}
{"Answer": "我想你应该试试[relative layout][1].\r\n如果你使用相对布局来填充整个屏幕，你应该可以使用[android:layout_alignParentBottom][2] 来移动按钮到屏幕的底部。\r\n如果你的屏幕底部的视图不是以相对布局来显示的，那么也许上边的布局将占据所有的空间。在这种情况下，在这个android布局：以上的布局中，在你的布局文件和剩下的布局位置，首先你应该把这个视图放在底部。这能够使按钮的视图占据尽可能多的像他需要的空间，剩下的布局可以填满剩下的所有屏幕。\r\n\r\n\r\n  [1]: http://developer.android.com/guide/topics/ui/layout/relative.html\r\n  [2]: http://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams.html", "Konwledge_Point": "线性规划和规约", "Question": "如何调整屏幕底部的视图？\n这是我的布局代码：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n它现在是左边这样，但是我想让他像右边这样的\n\n\n\n比较容易的做法就是设置TextView充满整个高度，但是这会引起按钮没有空间或者是输入框。基本上这个问题是我想要submit button和text entry在底部是一个合适的高度，text view填满剩下的控件，同样的在这个水平线性布局里边，我想要submit button包含它的内容，text entry来包含剩下的空间。\n\n如果在这个线性布局里的第一个项目是告知它就是用来填满这个布局的，没有给其他项目留空间，我在这个布局里如何得到一个首先是在这个线性布局里，填满除了最低要求的其他项目的项目？\n\n\n\n编辑1：\n\n\n\nRelative Layouts 确实是答案，谢谢。\n\n\n\n   \n\n\n\n\n\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "这个跟i++,++i的原理是一样的，你把visit (* p++);改成printf（“%d”，i++）;不就明白了", "Konwledge_Point": "线性规划和规约", "Question": "*p++相关使用问题，求大佬解答\nvoid ListTraverse(SqList L,void(* visit)(ElemType&))\n{\nElemType *p = L.elem; \n                 // L.elem为线性顺序表表的基址，p指向第一个元素\nint i ;\nfor(i = 1;i < L.length; i++)\nvisit (* p++);     // 对每个数据元素调用visit\nprintf(\"\\n\");\n}\n\n\n\n\n\n我理解的 *p++ ：p指向的顺序表L的第二个元素的值；\n\n那么visit(*p++) 是不是从第二个元素开始调用visit，而不是第一个啊？\n\n还是我哪里理解错了？", "Tag": "算法分析"}
{"Answer": "因为定义Table结构体的时候，name只是char指针而没有分配空间，所以在Datatable()中输入数据的时候写入了未申请的内存空间。创建ST的时候需要为name分配内存空间。\n一共修改了3处：1、第34行\n(*ST) = (Table*)malloc(length * sizeof(Table));//动态分配内存的起始地址,和表长大小一样\nfor (i = 0; i < n; i++) { (*ST)[i].name = (char*)malloc(n * sizeof(20)); } //为每一个元素的name字段动态分配内存\n\n2、第72行\nint i;\nlength = 45;//哈希表长度为45\n\n3、第119行\n//先释放HAXI，再释放name,最后释放ST\nfree(HAXI);//释放HAXI\nint i;\nfor (i = 0; i < n; i++) free(ST[i].name);//释放name\nfree(ST);//释放ST\n", "Konwledge_Point": "线性规划和规约", "Question": "求读取无效数据和读取发生冲突的解决方法\n问题遇到的现象和发生背景\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ndefine\n _CRT_SECURE_NO_WARNINGS\n\n\n//为保证平均查找长度不超过2，哈希表的长度为45\n\n\n#\ndefine\n NULL 0\n\n\ntypedef\n \nint\n KeyType;\n//起别名，方便辨别\n\n\ntypedef\n \nstruct\n {\n    KeyType key;\n//人名对应的编号\n\n    \nchar\n* name;\n//人名\n\n}Table;\n\n\nint\n \nHaxi\n(KeyType key)\n//利用除留余数法构造哈希函数\n\n\n{\n    \nint\n i, p, flag;\n    \nint\n length = \n45\n;\n    \nfor\n (p = length; p >= \n2\n; p--)\n//不超过表长的最大素数\n\n    {\n        \nfor\n (i = \n2\n, flag = \n1\n; i <= p / \n2\n && flag; i++)\n//通过不断的除来判断\n\n        {\n            \nif\n (p % i == \n0\n)\n                flag = \n0\n;\n//不是则终止此循环\n\n        }\n        \nif\n (flag == \n1\n)\n            \nbreak\n;\n//是的话终止循环\n\n    }\n    \nreturn\n key % p;\n//哈希地址\n\n}\n\n\nvoid\n \nDatatable\n(Table** ST, \nint\n n, \nint\n length)\n//储存已知的30个人名，按照输入的顺序给每个人名编号\n\n\n{\n    \nint\n i;\n    (*ST) = (Table*)\nmalloc\n(length * \nsizeof\n(Table));\n//动态分配内存的起始地址,和表长大小一样\n\n    \nif\n (*ST) {\n        \nprintf\n(\n\"\\n 请输入30个人名(编号随机): \"\n);\n        \nfor\n (i = \n0\n; i < n; i++)\n        {\n            \nprintf\n(\n\"\\n第%d个:  (编号 空格 人名)\"\n, i + \n1\n);\n            \nfflush\n(stdin);\n/*清除输入缓冲区*/\n\n            \nscanf_s\n(\n\"%d %s\"\n, &((*ST)[i].key), (*ST)[i].name, \n20\n);\n        }\n    }\n}\n\n\nvoid\n \nHaxitable\n(Table** HAXI, Table* ST, \nint\n n)\n//建立哈希表\n\n\n{\n    \nint\n length = \n45\n;\n    \nint\n i, j;\n    (*HAXI) = (Table*)\nmalloc\n(length * \nsizeof\n(Table));\n//分配地址\n\n    \nif\n (*HAXI) {\n        \nfor\n (i = \n0\n; i < length; i++)\n        {\n            (*HAXI)[i].key = \nNULL\n;\n//初始化\n\n            (*HAXI)[i].name = \n0\n;\n        }\n        \nfor\n (i = \n0\n; i < n; i++)\n        {\n            j = \nHaxi\n(ST[i].key);\n//获得哈希地址\n\n            \nwhile\n ((*HAXI)[j].key != \nNULL\n)\n//利用线性探测再散列解决冲突\n\n                j = (j + \n1\n) % length;\n            (*HAXI)[j].key = ST[i].key;\n//将数据放入哈希表\n\n            (*HAXI)[j].name = ST[i].name;\n        }\n        \n//    for(i=0;i<n;i++)\n\n        \n//        printf(\"数据库第%d个是%d\\n\",i,ST[i].key);//验证思路\n\n        \nprintf\n(\n\"\\n哈希表制作完成\\n\"\n);\n    }\n}\n\nvoid\n \nShow\n(Table* HAXI, \nint\n length)\n\n\n{\n    \nint\n i;\n    \nprintf\n(\n\"\\n          ****************哈希表**************\\n\"\n);\n    \nprintf\n(\n\"键:       *****\"\n);\n    \nfor\n (i = \n0\n; i < length; i++)\n        \nprintf\n(\n\"%6d\"\n, HAXI[i].key);\n    \nprintf\n(\n\"\\n\"\n);\n    \nprintf\n(\n\"值:       *****\"\n);\n    \n    \nfor\n (i = \n0\n; i < length; i++) {\n        \nif\n(HAXI[i].name!=\nNULL\n)\n            \nprintf\n(\n\"%s\"\n, HAXI[i].name);\n    }\n        \nprintf\n(\n\"\\n\"\n);\n    \nprintf\n(\n\"地址:     *****\"\n);\n    \nfor\n (i = \n0\n; i < length; i++)\n        \nprintf\n(\n\"%6d\"\n, i);\n    \nprintf\n(\n\"\\n\"\n);\n}\n\nint\n \nSearch\n(Table* HAXI, KeyType key, \nint\n length)\n//查找方法\n\n\n{\n    \nint\n i;\n    i = \nHaxi\n(key);\n//哈希函数获得位置\n\n    \nwhile\n (HAXI[i].key != \n0\n && HAXI[i].key != key)\n    {\n        i = (i + \n1\n) % length;\n//利用构造时解决冲突的方法解决冲突\n\n    }\n    \nif\n (HAXI[i].key == \n0\n)\n        \nreturn\n \n-1\n;\n    \nelse\n\n        \nreturn\n i;\n}\n\nint\n \nmain\n()\n \n{\n    Table* ST, * HAXI;\n    KeyType key;\n    \nint\n n=\n3\n, length=\n4\n;\n\n        \nprintf\n(\n\"建立哈希表：\\n\"\n);    \n            \nDatatable\n(&ST, n, length);\n            \nHaxitable\n(&HAXI, ST, n);\n            \nprintf\n(\n\"显示哈希表\\n\"\n);\n            \nShow\n(HAXI, length);\n            \nprintf\n(\n\"请输入想要查找的编号：\"\n);\n            \nscanf_s\n(\n\"%d\"\n, &key);\n            \nif\n (\nSearch\n(HAXI, key, length) == \n-1\n)\n                \nprintf\n(\n\"未查询到\"\n);\n            \nelse\n\n                \nprintf\n(\n\"查找成功！位置是%d值为%s\"\n, \nSearch\n(HAXI, key, length), HAXI[\nSearch\n(HAXI, key, length)].name);\n            \nfree\n(ST);\n    }\n\n\n\n\n输入如图内容之后出现两个问题\n\n\n一个是读取无效\n\n\n一个是0x00007FFCE75A6191 (ucrtbased.dll)处(位于 haxibiao.exe 中)引发的异常: 0xC0000005: 读取位置 0xFFFFFFFFFFFFFFFF 时发生访问冲突。\n\n\n\n\n想要输入几个编号和对应的名字，利用线性探测再散列放入哈希表中，然后再输出存好之后的表的内容", "Tag": "算法分析"}
{"Answer": "\n% 定义函数maxtU\nmaxtU = @(t, h, alpha, beta, p) (alpha * t^p + beta * h^p)^(1/p);\n\n% 定义函数h\nh = @(c, cs, delta, delta1, h0, m, n) h0 - m * c + n * cs;\n\n% 定义函数cs\ncs = @(c, c0, delta, delta1) delta * c + delta1 * c1 + (1 - delta - delta1) * c0;\n\n% 定义函数M\nM = @(h, h_i, p2) h_i >= h ? 0 : p2 * (h - h_i) * h_i;\n\n% 定义目标函数\nobj = @(x) maxtU(x(1), x(2), alpha, beta, p);\n\n% 定义约束条件\nA = [];\nb = [];\nAeq = [];\nbeq = [];\nlb = [0, 0];\nub = [Inf, Inf];\nnonlcon = @(x) x(1) + p1 * cs(x(2), c0, delta, delta1) + M(h(x(2), cs(x(2), delta, delta1), delta, delta1, h0, m, n), h_i, p2) - I;\n\n% 求解最优化问题\nx0 = [1, 1]; % 初始值\noptions = optimoptions(@fmincon,'Algorithm','interior-point');\nx = fmincon(obj,x0,A,b,Aeq,beq,lb,ub,nonlcon,options);\n\n% 数值模拟\nnum_iterations = 100; % 迭代次数\nfor i = 1:num_iterations\n% 在每次迭代中调用上述函数并计算结果\nx = fmincon(obj,x,A,b,Aeq,beq,lb,ub,nonlcon,options);\n", "Konwledge_Point": "线性规划和规约", "Question": "使用matlab进行含参数的最优化求解及数值模拟\n问题背景\n\n\n效用最大化理论模型，非线性有约束规划，函数中有多个参数（如图），初步的想法是\n\n\n第一步：得出最优消费量关于某一变量的偏导；\n第二步：将偏导在某一参数的不同水平下进行数值模拟\n\n\n\n\n碰到的问题\n\n\n手动计算最优消费量易出错（不确定是否求出了正确的解），下面的数值模拟自然不好推进，所以想用matlab的最优化工具箱计算得出最优消费量，但是遇到了报错，无法实现\n\n\n目前尝试的代码\n\n\n参考matlab帮助文档中跟我这个相似的最优化问题，目前是这个代码（没有matlab格式的代码可插入，用了python的代码格式，见谅哈），目的是将f这一g的隐函数作图，这里4个变量t, c, c1, c0，其他的都是参数\n\n\n%%%%\n\nclc\n; clear all; close all;\n\nf = @(t, c, c1, c0) (a.*t.^p + b.*(h0-m.*c+n.*(\nk1\n.*c+\nk2\n.*c1+(\n1\n-\nk1\n-\nk2\n).*c0)).^p)^(\n1\n/p)\n;\n\ng = @(t,c, c1, c0) t+p1.*n.*(\nk1\n.*c+\nk2\n.*c1+(\n1\n-\nk1\n-\nk2\n))+ \n0\n*(h0-m.*c+n.*(\nk1\n.*c+\nk2\n.*c1+(\n1\n-\nk1\n-\nk2\n).*c0)>=h1)+p2.*(h0-m.*c+n.*(\nk1\n.*c+\nk2\n.*c1+(\n1\n-\nk1\n-\nk2\n).*c0)<h1)-i\n;\n\nfimplicit(g)\n\n\n\n\n报错情况\n\n\n“错误使用 fimplicit (line 54) 函数输入可以最多包含两个变量。”\n\n\n我目前的疑问\n\n\n当然上面这个报错是预想中的啦，关键的问题是不知道这样一个全是参数的最优化问题是否可以用matlab求出一个解的表达式再数值模拟还是说直接用这一系列关系式直接进行数值模拟\n\n\n可否指教一二？", "Tag": "算法分析"}
{"Answer": "你可以参考一下希望可以采纳支持一下博主呀\n#include <stdio.h>\n\nint main()\n{\n    double grade[4],sum=0;\n    int i;\n    printf(\"请依次输入高等数学、线性代数、大学物理、大学英语四门课程的成绩（成绩之间用空格分隔）：\\n\");\n    for (i = 0; i < 4; i++) {\n        scanf_s(\"%lf\", &grade[i]);\n        sum += grade[i];\n    }\n\n    double aver = sum / 4;\n    printf(\"平均成绩为：%.1f \", aver);\n\n    if (aver >= 0 && aver <= 100)\n    {\n        if (aver >= 90) {\n            printf(\"A档\\n\");\n        }\n        else if (aver >= 80) {\n            printf(\"B档\\n\");\n        }\n        else if (aver >= 70) {\n            printf(\"C档\\n\");\n        }\n        else if (aver >= 60) {\n            printf(\"D档\\n\");\n        }\n        else {\n            printf(\"E档\\n\");\n        }\n    }\n\n    int cnt = 0;\n    for (i = 0; i < 4; i++) {\n        if (aver > grade[i]) {\n            cnt++;\n        }\n    }\n\n    printf(\"比平均成绩低的课程有%d门\\n\", cnt);\n\n    return 0;\n}\n\n\n", "Konwledge_Point": "线性规划和规约", "Question": "网课不会做，求答案，，\n用C语言编写实现如下功能的程序：\n\n\n运行程序后实现\n\n\n1.提示用户通过键盘依次输入高等数学、线性代数、大学物理、大学英语四门课程的成绩\n\n\n2.输入完成后自动输出如下两部分内容：\n\n\n  I. 输出平均成绩（保留1位小数）以及平均成绩所属的档次（用A、B、C、D、E表示，90-100 A, 80-89 B, 70-79 C, 60-69 D,60分以下 E）（例如输出：平均成绩 85.8  B档）\n\n\n II. 输出比平均成绩低的课程有几门；(例如输出：比平均成绩低的课程有2门）注：只需输出比平均成绩低的课程的门数，不用给出具体是哪几门课\n使用visual ", "Tag": "算法分析"}
{"Answer": "Y里面一共只有27个元素，t=30，肯定超范围了", "Konwledge_Point": "线性规划和规约", "Question": "MATLAB索引越界问题(真一小白，哭晕)\n clear all;\nclc;\n% 读入人口数据(1971 - 2000年)\nY = [33815 33981 34004 34212 34327 34344 34458 34498 34476 \n     34483 34488 34513 34497 34511 34507 34509 34521 34513\n     34515 34517 34519 34521 34521 34523 34525 34525 34527];\n% 读入年份，很明显可以自己生成\n T = (1:1:30);\n%  做线性处理\nfor t = 1:30,\n    x(t)= exp(-t);\n    y(t) = 1/Y(t,1);\nend \n\n\n\n\n按照我买的一本书打的，没有打完，我就想看下有没有问题。结果，发现显示\n\n\n\n“\n\n索引超出矩阵维度\n\n出错 test1(line12)\n\ny(t) = 1/Y(t,1);\n\n”\n\n大佬们，怎么搞哇！", "Tag": "算法分析"}
{"Answer": "我发现你的问题可能是因为你的输入参数 x,y,u_new,v_new 等都是三维矩阵，而 contourf 函数只能接受二维矩阵作为输入。你需要将三维矩阵切片成二维矩阵，然后再用 contourf 函数绘制等高线图。\n例如，如果你想在 x-y 平面上绘制 u_new 和 v_new 的等高线图，你可以用以下代码：\n% 假设 z 是一个 1001 的向量，表示 z 轴上的坐标% 选择一个 z 坐标作为切片平面，比如 z(50)% 找到对应的 u_new 和 v_new 的切片矩阵u_slice = squeeze(u_new(:,:,50)); % 100100 的二维矩阵v_slice = squeeze(v_new(:,:,50)); % 100*100 的二维矩阵% 绘制等高线图figure;contourf(x,y,u_slice,v_slice);类似地，如果你想在 y-z 平面或 x-z 平面上绘制等高线图，你也可以用相同的方法切片。\n希望这些信息能帮助你解决问题，祝你编程愉快！", "Konwledge_Point": "线性规划和规约", "Question": "matlab重构三维流场\nmatlab重构流场，前面没问题 到了figure的时候出问题  显示\n\n\n\n\n%这一节程序的目的：重构某一个原始的瞬态流场，_**并且将速度场数据拟合到规整的网格中。然后做平面云图**_。\n\nn_recon = input(\n'重构的流场是第几个:'\n);\n%程序运行至此，需要人为在命令行窗口输入重构的流场是第几个\n\nat=\nzeros\n(r,\n1\n);\n% 时间系数矩阵, r * 1\n\n\nfor\n \nj\n = \n1\n:r\n   at(\nj\n,\n1\n)=\ndot\n(X_fluc(:,n_recon),POD_vector(:,n_snapshots-\nj\n+\n1\n));\n%计算时间系数,r*1的矩阵\n\n\nend\n\nX_reconstruct=\nzeros\n(\n6028500\n,\n1\n);\n\nfor\n \nj\n=\n1\n:\n3\n \n%用前50个能量贡献较大的POD模态重构瞬态速度场，这里的50可以改成100，200，500等任意数\n\n  X_reconstruct = X_reconstruct+at(\nj\n,\n1\n)*POD_vector(:,n_snapshots-\nj\n+\n1\n);\n%308400*1\n\n\nend\n\nrecon_u = X_reconstruct(\n1\n:\n2009500\n,\n1\n);\n%重构以后的速度U\n\nrecon_v = X_reconstruct((\n2009500\n+\n1\n):(\n2\n*\n2009500\n),\n1\n);\n%重构以后的速度V\n\nrecon_w = X_reconstruct((\n2009500\n*\n2\n+\n1\n):(\n3\n*\n2009500\n),\n1\n);\n%重构以后的速度W\n\n\nxx = \nlinspace\n( \n-0.0787\n , \n0.0787\n , \n100\n );\n%对X坐标进行线性插值，形成1*100的行向量\n\nyy = \nlinspace\n( \n-0.0787\n , \n0.0787\n , \n100\n );\n%对Y坐标进行线性插值，形成1*100的行向量\n\nzz = \nlinspace\n( \n-0.001\n , \n0.818\n , \n100\n );\n%对Z坐标进行线性插值，形成1*100的行向量\n\nnx = \nlength\n(xx);\nny = \nlength\n(yy);\nnz = \nlength\n(zz);\n[x,y,z] = \nmeshgrid\n(xx,yy,zz);\n% 100*100*100\n\nu_new=griddata(fluent_data(:,\n1\n),fluent_data(:,\n2\n),fluent_data(:,\n3\n),recon_u,x,y,z);\n%将重构的速度U拟合到新的坐标系，100*100*100\n\nv_new=griddata(fluent_data(:,\n1\n),fluent_data(:,\n2\n),fluent_data(:,\n3\n),recon_v,x,y,z);\n%将重构的速度V拟合到新的坐标系，100*100*100\n\nw_new=griddata(fluent_data(:,\n1\n),fluent_data(:,\n2\n),fluent_data(:,\n3\n),recon_w,x,y,z);\n%将重构的速度W拟合到新的坐标系，100*100*100\n\nu_new(\nisinf\n(u_new)) = \n0\n;\n%如果值为无穷大，则赋值为0\n\nu_new(\nisnan\n(u_new)) = \n0\n;\n%如果非数值，则赋值为0\n\nv_new(\nisinf\n(v_new)) = \n0\n;\nv_new(\nisnan\n(v_new)) = \n0\n;\nw_new(\nisinf\n(w_new)) = \n0\n;\nw_new(\nisnan\n(w_new)) = \n0\n;\n\nfigure\n;\ncontourf(x,y,u_new,v_new);\n\n\nfigure\n;\ncontourf(y,z,v_new,w_new);\n\n\nfigure\n;\ncontourf(x,z,u_new,w_new);\n\n\n\n但是总会报错 不知道怎么办了 目的是 将速度场数据拟合到规整的网格中。然后做平面云图", "Tag": "算法分析"}
{"Answer": "你好，这里面直接构造最小二乘法然后用比例系数比较方便，建议n不要取太大，容易造成过拟合，使得拟合误差过大：\n%% 为了得到分布，假设了一个协方差矩阵\nmu=[20,180];%数学期望\nsigma=[20/3 0;0,60].^2;%协方差矩阵\nr=mvnrnd(mu,sigma,100000);%生成100000个样本\nx = r(:,1);\ny = r(:,2);\nnx = 40;\nny = 40;\nxmax = 40;\nymax = 360;\ndx = xmax/nx;\ndy = ymax/ny;\n[X, Y, C, xmid, ymid] = ef2(x,y,nx+1,ny+1,[0,xmax],[0,ymax]);\nC = C/(dx*dy);%单位面积上的概率即概率密度\nfigure(1);clf;\nbar3(C)\ntitle('原先数据')\nxtick = 1:size(C,2); xticklabel = xmid; % xtick和xticklabel一定要对应，长度相等\nytick = 1:size(C,1); yticklabel = ymid; % ytick和yticklabel一定要对应，长度相等\nset(gca, 'xtick', xtick(1:4:end), 'xticklabel',xticklabel(1:4:end),...\n    'ytick', ytick(1:4:end), 'yticklabel',yticklabel(1:4:end))\nxlabel('X')\nylabel('Y')\nx = X(:);\ny = Y(:);\nz = C(:);%根据x和y算出的频率，x，y，z为输入数据\nn = 4; % n为多项式的阶数，参数一共为(n+1)²个, 注意n不要取太大，容易产生过拟合\n[i1, i2] = meshgrid(0:n);\nF = arrayfun(@(i)x.^i1(i).*y.^i2(i), 1:numel(i1), 'uniform', 0);\nF = cell2mat(F);\n%% 标注------------改动的地方-------------------\nz(z==0) = eps; %如果z等于零，赋值给一个很小的数字即可\nlogz=log(z);\nA = F'*F;\nb = F'*logz;\na = A\\b;%最小二乘法\nzfit = polyfunval(X,Y,a,n);\nzfun = @(x,y)exp(polyfunval(x,y,a,n)); % 构建z的函数获取整体积分值\nV = integral2(zfun, 0, 40, 0, 360);\na(1) = a(1) - log(V);\nzfun = @(x,y)exp(polyfunval(x,y,a,n)); % 构建z的函数获取整体积分值,修正了a，使得积分为1\nV_after_correct = integral2(zfun,0, 40, 0, 360) %这里可以显示积分值\nzfit1 = exp(zfit);\nfigure(2);clf\nsurf(X,Y,zfit1, 'facealpha', 0.8);%这之后的非线性方程组法和比例系数法如何仿造上面的程序继续\n\nfunction f = polyfunval(x,y,a,n)%指数多元多项式的公式\n[i1, i2] = meshgrid(0:n);\nCfit = arrayfun(@(i)a(i)*x.^i1(i).*y.^i2(i), 1:numel(i1), 'uniform', 0);\nf = Cfit{1};\nfor i = 2:numel(Cfit)\n    f = f + Cfit{i};\nend\nend\nfunction [X, Y, CDF, xmid, ymid] = ef2(x,y,nx,ny,xminmax,yminmax)%输入数据，只知道x和y，算出频率z\nnum = length(x);\nif(num~=length(y))\n   error('输入的x和y长度必须相等') \nend\nif(nargin>6) % 如果变量个数大于6个，太多了\n    error('太多输入变量')\nelseif(nargin<2) % 如果变量个数小于2个，太少了\n    error('输入变量数目不足!!')\nend\nif(nargin==6) % 如果变量个数等于6个，赋值给ymin和ymax\n    ymin = yminmax(1);\n    ymax = yminmax(2);\nend\nif(nargin>=5)% 如果变量个数大于等于5个，赋值给xmin和xmax\n    xmin = xminmax(1);\n    xmax = xminmax(2);\nend\nif(nargin<=4)% 如果变量个数小于等于4个，自定义xmin和xmax\n    xmin = min(x);\n    xmax = max(x)+eps;\n    ymin = min(y);\n    ymax = max(y)+eps;\nend\nif(nargin<=3)% 如果变量个数小于等于3个，自定义y方向划分段数ny\n    ny = 30;\nend\nif(nargin==2)% 如果变量个数等于2个，自定义x方向划分段数nx\n    nx = 30;\nend\nxg = linspace(xmin, xmax, nx);%x方向的点\nyg = linspace(ymin, ymax, ny);%y方向的点\nxmid = (xg(1:end-1)+xg(2:end))/2;\nymid = (yg(1:end-1)+yg(2:end))/2;\n[X,Y] = meshgrid(xmid, ymid);%形成网格\n[I,J] = meshgrid(2:nx, 2:ny);%下标网格\nCDF = arrayfun(@(i,j)sum(x>=xg(i-1)&x<xg(i)&y<yg(j)&y>=yg(j-1))/num,I,J);%形成经验分布\nend\n\n直接求解非线性方程组无法搜索到合理解，在这里给出，只作为参考\n%% 为了得到分布，假设了一个协方差矩阵\nmu=[20,180];%数学期望\nsigma=[20/3 0;0,60].^2;%协方差矩阵\nr=mvnrnd(mu,sigma,100000);%生成100000个样本\nx = r(:,1);\ny = r(:,2);\nnx = 40;\nny = 40;\nxmax = 40;\nymax = 360;\ndx = xmax/nx;\ndy = ymax/ny;\n[X, Y, C, xmid, ymid] = ef2(x,y,nx+1,ny+1,[0,xmax],[0,ymax]);\nC = C/(dx*dy);%单位面积上的概率即概率密度\nfigure(1);clf;\nbar3(C)\ntitle('原先数据')\nxtick = 1:size(C,2); xticklabel = xmid; % xtick和xticklabel一定要对应，长度相等\nytick = 1:size(C,1); yticklabel = ymid; % ytick和yticklabel一定要对应，长度相等\nset(gca, 'xtick', xtick(1:4:end), 'xticklabel',xticklabel(1:4:end),...\n    'ytick', ytick(1:4:end), 'yticklabel',yticklabel(1:4:end))\nxlabel('X')\nylabel('Y')\nx = X(:);\ny = Y(:);\nz = C(:);%根据x和y算出的频率，x，y，z为输入数据\nn = 4; % n为多项式的阶数，参数一共为(n+1)²个, 注意n不要取太大，容易产生过拟合\n[i1, i2] = meshgrid(0:n);\nF = arrayfun(@(i)x.^i1(i).*y.^i2(i), 1:numel(i1), 'uniform', 0);\nF = cell2mat(F);\n%% 标注------------改动的地方-------------------\nz(z==0) = eps; %如果z等于零，赋值给一个很小的数字即可\nlogz=log(z);\nA = F'*F;\nb = F'*logz;\na = A\\b;%最小二乘法\n\nff = @(x,y,a)exp(polyfunval(x,y,a,n)); % 构建z的函数获取整体积分值\neq = @(a)[A*a-b; integral2(@(x,y)ff(x,y,a),0,40,0,360)-1];%构建了方程组后面一项指的是积分为1\noptions = optimoptions('fsolve','Display','off','FunctionTolerance',1e-2,'algorithm','levenberg-marquardt');\n[aa, f, flag] = fsolve(eq, a, options);\ncount = 0;\nwhile (flag>=4 || flag<=0)\n    count = count + 1;\n    fprintf('第%d次寻根\\n',count);\n    [aa, f, flag] = fsolve(eq, a+a.*(0.0002*rand(size(a))-1), options);\n    if(count>100)\n        fprintf('寻根未成功\\n')\n        aa = a;\n        break;\n    end\nend\na = aa;\nzfit = polyfunval(X,Y,a,n);\nV_after_correct = integral2(zfun, min(x), max(x), min(y), max(y)) %这里可以显示积分值\nzfit1 = exp(zfit);\nfigure(2);clf\nsurf(X,Y,zfit1, 'facealpha', 0.8);%这之后的非线性方程组法和比例系数法如何仿造上面的程序继续\n\nfunction f = polyfunval(x,y,a,n)%指数多元多项式的公式\n[i1, i2] = meshgrid(0:n);\nCfit = arrayfun(@(i)a(i)*x.^i1(i).*y.^i2(i), 1:numel(i1), 'uniform', 0);\nf = Cfit{1};\nfor i = 2:numel(Cfit)\n    f = f + Cfit{i};\nend\nend\nfunction [X, Y, CDF, xmid, ymid] = ef2(x,y,nx,ny,xminmax,yminmax)%输入数据，只知道x和y，算出频率z\nnum = length(x);\nif(num~=length(y))\n   error('输入的x和y长度必须相等') \nend\nif(nargin>6) % 如果变量个数大于6个，太多了\n    error('太多输入变量')\nelseif(nargin<2) % 如果变量个数小于2个，太少了\n    error('输入变量数目不足!!')\nend\nif(nargin==6) % 如果变量个数等于6个，赋值给ymin和ymax\n    ymin = yminmax(1);\n    ymax = yminmax(2);\nend\nif(nargin>=5)% 如果变量个数大于等于5个，赋值给xmin和xmax\n    xmin = xminmax(1);\n    xmax = xminmax(2);\nend\nif(nargin<=4)% 如果变量个数小于等于4个，自定义xmin和xmax\n    xmin = min(x);\n    xmax = max(x)+eps;\n    ymin = min(y);\n    ymax = max(y)+eps;\nend\nif(nargin<=3)% 如果变量个数小于等于3个，自定义y方向划分段数ny\n    ny = 30;\nend\nif(nargin==2)% 如果变量个数等于2个，自定义x方向划分段数nx\n    nx = 30;\nend\nxg = linspace(xmin, xmax, nx);%x方向的点\nyg = linspace(ymin, ymax, ny);%y方向的点\nxmid = (xg(1:end-1)+xg(2:end))/2;\nymid = (yg(1:end-1)+yg(2:end))/2;\n[X,Y] = meshgrid(xmid, ymid);%形成网格\n[I,J] = meshgrid(2:nx, 2:ny);%下标网格\nCDF = arrayfun(@(i,j)sum(x>=xg(i-1)&x<xg(i)&y<yg(j)&y>=yg(j-1))/num,I,J);%形成经验分布\nend\n\n总体来讲，比例系数法会更加合理且简单易操作，但是要注意n的取值不要过大（建议5以内），根据自己的数据调整n的取值会好一些", "Konwledge_Point": "线性规划和规约", "Question": "用多元指数多项式去拟合一组数据，如何加上x在0到40，y在0到360积分为1这个约束\n下图为多元指数多项式，去拟合一组数据（x,y,f(x,y)），约束条件为x在0到40，y在0到360（xy的范围最好可变），f(x,y)的积分等于1。\n一维的指数多项式，拟合一组数据，积分为1的方法，可以用非线性方程组方法和比例系数法，为下面2个程序。然后二维数据的多元指数多项式不带积分为1的程序也在下面写了，如果把一维指数多项式的非线性方程组方法和比例系数法用在二维数据里，要如何编写，写了一半的程序和仿造的程序都在下面。\n\n\n\n\n一维指数多项式积分为1，非线性方程组法\n\n\nx = [\n0\n:\n1\n:\n40\n]; \n% x随意\n\nmu = \n20\n; sigma = \n10\n;\ny = \n1\n/\nsqrt\n(\n2\n*\npi\n)/sigma*\nexp\n(-(x-mu+\nrand\n(\nsize\n(x))*\n2\n).^\n2\n/\n2\n/sigma^\n2\n);\n% y随意设置，在正弦函数上加随机浮动\n\ny(y<=\n0\n) = \n10\n*\neps\n;\nn = \n5\n; \n% n随意\n\nx = x(:);\ny = y(:);\nS = \nzeros\n(\nlength\n(x), n+\n1\n);\nq = \nones\n(\nlength\n(x),\n1\n);\nS(:,n+\n1\n)=q;\n\nfor\n \ni\n = n:\n-1\n:\n1\n\n    q = q.*x;\n    S(:,\ni\n) = q;\n\nend\n\nlogy = \nlog\n(y);\nA = S'*S;\nb = S'*logy;\na = A\\b;\n%最小二乘\n\nff = @(x,a) \nexp\n(polyval(a,x));\neq = @(a)[A*a-b; integral(@(x)ff(x,a),\n0\n,\n40\n)\n-1\n];\n%构建了方程组后面一项指的是积分为1\n\noptions = optimoptions(\n'fsolve'\n,\n'Display'\n,\n'off'\n,\n'FunctionTolerance'\n,\n1e-2\n,\n'algorithm'\n,\n'levenberg-marquardt'\n);\n[a, f, flag] = fsolve(eq, a, options);\n\nwhile\n (flag>=\n4\n || flag<=\n0\n)\n    [aa, f, flag] = fsolve(eq, a+a.*(\n2\n*\nrand\n(\nsize\n(a))\n-1\n), options);\n\nend\n\na = aa;\nxfit = \nlinspace\n(\nmin\n(x),\nmax\n(x),\n1001\n);\n\nplot\n(x,y,\n'r-'\n,xfit,\nexp\n(polyval(a,xfit)),\n'b-'\n)\n\nlegend\n(\n'原值'\n,\n'拟合后'\n)\n\n\n\n一维指数多项式积分为1，比例系数法\n\n\nx = [\n0\n:\n1\n:\n40\n]; \n% x随意\n\nmu = \n20\n; sigma = \n10\n;\ny = \n1\n/\nsqrt\n(\n2\n*\npi\n)/sigma*\nexp\n(-(x-mu+\nrand\n(\nsize\n(x))*\n2\n).^\n2\n/\n2\n/sigma^\n2\n);\n% y随意设置，在正弦函数上加随机浮动\n\ny(y<=\n0\n) = \n10\n*\neps\n;\nn = \n5\n; \n% n随意\n\nx = x(:);\ny = y(:);\nS = \nzeros\n(\nlength\n(x), n+\n1\n);\nq = \nones\n(\nlength\n(x),\n1\n);\nS(:,n+\n1\n)=q;\n\nfor\n \ni\n = n:\n-1\n:\n1\n\n    q = q.*x;\n    S(:,\ni\n) = q;\n\nend\n\nlogy = \nlog\n(y);\nA = S'*S;\nb = S'*logy;\na = A\\b;\n%最小二乘\n\nff = @(x,a) \nexp\n(polyval(a,x));\nS = integral(@(x)ff(x,a),\n0\n,\n40\n);\na(\nend\n) = a(\nend\n) - \nlog\n(S);\n%整体除以S\n\nxfit = \nlinspace\n(\nmin\n(x),\nmax\n(x),\n1001\n);\n\nplot\n(x,y,\n'r-'\n,xfit,\nexp\n(polyval(a,xfit)),\n'b-'\n)\n\nlegend\n(\n'原值'\n,\n'拟合后'\n)\n\n\n\n\n多元指数多项式，不带积分为1的约束程序\n\n\n%% 为了得到分布，假设了一个协方差矩阵\n\nmu=[\n20\n,\n180\n];\n%数学期望\n\nsigma=[\n20\n/\n3\n \n0\n;\n0\n,\n60\n].^\n2\n;\n%协方差矩阵\n\nr=mvnrnd(mu,sigma,\n100000\n);\n%生成100000个样本\n\nx = r(:,\n1\n);\ny = r(:,\n2\n);\nnx = \n40\n;\nny = \n40\n;\nxmax = \n40\n;\nymax = \n360\n;\ndx = xmax/nx;\ndy = ymax/ny;\n[X, Y, C, xmid, ymid] = ef2(x,y,nx+\n1\n,ny+\n1\n,[\n0\n,xmax],[\n0\n,ymax]);\nC = C/(dx*dy);\n%单位面积上的概率即概率密度\n\n\nfigure\n(\n1\n);clf;\nbar3(C)\ntitle(\n'原先数据'\n)\nxtick = \n1\n:\nsize\n(C,\n2\n); xticklabel = xmid; \n% xtick和xticklabel一定要对应，长度相等\n\nytick = \n1\n:\nsize\n(C,\n1\n); yticklabel = ymid; \n% ytick和yticklabel一定要对应，长度相等\n\nset(gca, \n'xtick'\n, xtick, \n'xticklabel'\n,xticklabel,...\n    \n'ytick'\n, ytick, \n'yticklabel'\n,yticklabel)\nxlabel(\n'X'\n)\nylabel(\n'Y'\n)\nx = X(:);\ny = Y(:);\nz = C(:);\n%根据x和y算出的频率，x，y，z为输入数据\n\nn = \n7\n; \n% n为多项式的阶数，参数一共为(n+1)²个\n\n[i1, i2] = \nmeshgrid\n(\n0\n:n);\nF = arrayfun(@(\ni\n)x.^i1(\ni\n).*y.^i2(\ni\n), \n1\n:\nnumel\n(i1), \n'uniform'\n, \n0\n);\nF = cell2mat(F);\n\nF1=[z,F]\n%这里是因为z数据有时候频率为0，必须把含0的数据去掉\n\n[r,c]=\nsize\n(F1);\nindex=\n1\n:r; \n%一维矢量, F1的行指标\n\nall(F1') \n%将F1转置一下, 返回一个矢量,它的每个元素进行判断, F1所在行的元素全不为0则是1, 否则为0\n\nF1=F1(index(all(F1')),:) \n%取出F1不含0元素的行,构成新的矩阵\n\nF1(:,\n1\n)=[]\nz(z==\n0\n)=[]\nlogz=\nlog\n(z)\n\nA = F1'*F1;\nb = F1'*logz;\na = A\\b;\n%最小二乘法\n\nzfit = polyfunval(X,Y,a,n);\nzfit1 = \nexp\n(zfit);\nsurf(X,Y,zfit1);\n%这之后的非线性方程组法和比例系数法如何仿造上面的程序继续\n\n\n\nfunction\n \nf\n = \npolyfunval\n(x,y,a,n)\n%指数多元多项式的公式\n\n[i1, i2] = \nmeshgrid\n(\n0\n:n);\nCfit = arrayfun(@(\ni\n)a(\ni\n)*x.^i1(\ni\n).*y.^i2(\ni\n), \n1\n:\nnumel\n(i1), \n'uniform'\n, \n0\n);\nf = Cfit{\n1\n};\n\nfor\n \ni\n = \n2\n:\nnumel\n(Cfit)\n    f = f + Cfit{\ni\n};\n\nend\n\n\nend\n\n\n\nfunction\n \n[X, Y, CDF, xmid, ymid]\n = \nef2\n(x,y,nx,ny,xminmax,yminmax)\n%输入数据，只知道\nx\n和\ny\n，算出频率\nz\n\nnum = \nlength\n(x);\n\nif\n(num~=\nlength\n(y))\n   error(\n'输入的x和y长度必须相等'\n) \n\nend\n\n\nif\n(nargin>\n6\n) \n% 如果变量个数大于6个，太多了\n\n    error(\n'太多输入变量'\n)\n\nelseif\n(nargin<\n2\n) \n% 如果变量个数小于2个，太少了\n\n    error(\n'输入变量数目不足!!'\n)\n\nend\n\n\nif\n(nargin==\n6\n) \n% 如果变量个数等于6个，赋值给ymin和ymax\n\n    ymin = yminmax(\n1\n);\n    ymax = yminmax(\n2\n);\n\nend\n\n\nif\n(nargin>=\n5\n)\n% 如果变量个数大于等于5个，赋值给xmin和xmax\n\n    xmin = xminmax(\n1\n);\n    xmax = xminmax(\n2\n);\n\nend\n\n\nif\n(nargin<=\n4\n)\n% 如果变量个数小于等于4个，自定义xmin和xmax\n\n    xmin = \nmin\n(x);\n    xmax = \nmax\n(x)+\neps\n;\n    ymin = \nmin\n(y);\n    ymax = \nmax\n(y)+\neps\n;\n\nend\n\n\nif\n(nargin<=\n3\n)\n% 如果变量个数小于等于3个，自定义y方向划分段数ny\n\n    ny = \n30\n;\n\nend\n\n\nif\n(nargin==\n2\n)\n% 如果变量个数等于2个，自定义x方向划分段数nx\n\n    nx = \n30\n;\n\nend\n\nxg = \nlinspace\n(xmin, xmax, nx);\n%x方向的点\n\nyg = \nlinspace\n(ymin, ymax, ny);\n%y方向的点\n\nxmid = (xg(\n1\n:\nend\n-1\n)+xg(\n2\n:\nend\n))/\n2\n;\nymid = (yg(\n1\n:\nend\n-1\n)+yg(\n2\n:\nend\n))/\n2\n;\n[X,Y] = \nmeshgrid\n(xmid, ymid);\n%形成网格\n\n[I,J] = \nmeshgrid\n(\n2\n:nx, \n2\n:ny);\n%下标网格\n\nCDF = arrayfun(@(\ni\n,\nj\n)sum(x>=xg(\ni\n-1\n)&x=yg(\nj\n-1\n))/num,I,J);\n%形成经验分布\n\n\nend\n\n", "Tag": "算法分析"}
{"Answer": "GCS_WGS_1984与 GCS_North_American_1983属于不同椭球体，需要使用专业软件计算三七参数，得到三七参数就能使用arcgis进行转换，希望对你有帮助！", "Konwledge_Point": "线性规划和规约", "Question": "萌新求助，arcgis未知经纬度坐标系转换问题\nRT，本人在信息数据处理时候遇到的问题——两套数据的经纬度信息应该不是在一个坐标系中，\n\nA数据是曼哈顿城市网络结构，其节点坐标比如，\n583200.166333，4506032.483683（m）\n\n583432.793828，4506074.45177\n\n583193.776709，4506091.452575\n\n583452.09959，4506097.816545\n\n\n\n在arcgis中坐标信息如下\n\n\n\n\n\n投影坐标系:  WGS_1984_UTM_Zone_18N\n\n投影:   Transverse_Mercator\n\nFalse_Easting:    500000.00000000\n\nFalse_Northing:   0.00000000\n\nCentral_Meridian: -75.00000000\n\nScale_Factor: 0.99960000\n\nLatitude_Of_Origin:   0.00000000\n\n线性单位:     Meter\n\n\n\n地理坐标系:  GCS_WGS_1984\n\n基准面:    D_WGS_1984\n\n本初子午线:  Greenwich\n\n角度单位:     Degree\n\n\n\n\n\nB数据来自NYC网站的TLC出租车数据（附网站网址：\nhttp://www.nyc.gov/html/tlc/html/about/trip_record_data.shtml）\n\n其坐标数据举例为\n\n**-73.99389648，40.75011063\n\n-74.00164795，40.72424316\n\n-73.96334076，40.80278778\n\n-74.00908661，40.7138176\n\n**\n\n\n\n但是请注意，我所举例的信息均为数据集中随机数据，不存在一一对应关系，仅知道因为两个坐标都是在曼哈顿城区内部，差别应该不大，\n\n在这里我作为萌新向地理信息比较了解的，请问B数据的坐标系以及AB之间的换算方法\n\n\n\nPS.如果数据不足，我这里依旧可以提供，本人英语水平不足，没有在网站找到B数据的坐标信息，不过B数据的网站提供了出租车区域的SHP文件，这里坐标系的信息为\n\n\n\n\n\n投影坐标系:  NAD_1983_StatePlane_New_York_Long_Island_FIPS_3104_Feet\n\n投影:   Lambert_Conformal_Conic\n\nFalse_Easting:    984250.00000000\n\nFalse_Northing:   0.00000000\n\nCentral_Meridian: -74.00000000\n\nStandard_Parallel_1:  40.66666667\n\nStandard_Parallel_2:  41.03333333\n\nLatitude_Of_Origin:   40.16666667\n\n线性单位:     Foot_US\n\n\n\n地理坐标系:  GCS_North_American_1983\n\n基准面:    D_North_American_1983\n\n本初子午线:  Greenwich\n\n角度单位:     Degree\n\n\n\n\n\n我通过arcgis进行了地理坐标系转换，但是转换结果依旧不正确", "Tag": "算法分析"}
{"Answer": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    long long count = 0;\n    for (int i = 0; i < n - 1; i++)\n        for (int j = i + 1; j < n; j++)\n            if (a[i] > a[j])\n                count++;\n    std::cout << count;\n    return 0;\n}\n", "Konwledge_Point": "线性规划和规约", "Question": "程序设计 -- 计算逆序数\n这个学期 Amy 开始学习一门重要课程--线性代数。学到行列式的时候，每次遇到对给定的序列计算其逆序数，她都觉得是个很闹心的事。所以，她央求她的好朋友 Ray 为她写一段程序，用来解决这样的问题。作为回报，她答应在周末舞会上让 Ray 成为她的伦巴舞舞伴。所谓序列Ａ的逆序数，指的是序列中满足 iA[j] 的所有二元组  的个数。\n输入格式\n第一行输入一个整数 N(1≤N≤100000)，表示下一行给出的序列的个数。第二行为N个整数，每个整数之间空一格，表示序列中的N个元素。每个元素的值不超过1000000000\n输出格式\n输出只有一个表示给定序列的逆序数整数。\n输入样例1\n3\n1 2 3\n输出样例1\n0\n输入样例2\n2\n2 1\n输出样例2\n1", "Tag": "算法分析"}
{"Answer": " 开刀\r\n```\r\nconst int ARRAY_GROWUP = 10;\r\n//数组结构体定义\r\nstruct ArrayStruct\r\n{\r\nint iCurMaxElementCount; //当前数组最大能容纳元素个数\r\nint iCurElementCount; //当前元素数\r\nint * pHead; //指针头部\r\n};\r\n//功能：生成一个数组，参数为最初元素个数\r\n//参数：int iStartElementCount 数组初始化大小\r\n//返回：成功返回指针，否则返回 NULL\r\nArrayStruct * Array_Init(int iStartElementCount)\r\n{\r\n    if (iStartElementCount <= 0 )\r\n        return NULL;\r\n    ArrayStruct * pReturn;\r\n\r\n    pReturn = new ArrayStruct;\r\n    if (pReturn == NULL)\r\n        return NULL;\r\n\r\n    pReturn->pHead = new int[iStartElementCount];\r\n    if (pReturn->pHead == NULL)\r\n    {\r\n        delete pReturn;\r\n        return NULL;\r\n    }\r\n    pReturn->iCurMaxElementCount = iStartElementCount;\r\n    pReturn->iCurElementCount = 0;//表明当前没有元素\r\n    return pReturn;\r\n}\r\n\r\n// ========== 完成下面的函数\r\n//功能：向数组增加一个元素，如果元素超过上述 Array_Init\r\n// 函数的 iStartElementCount 参数时，请考虑如何适应\r\n// 可以假定一次增大ARRAY_GROWUP个元素容量，但要保证在内存中数据为线性存放\r\n//参数：ArrayStruct *pArray 要处理的数组结构体指针\r\n// const int iAppendElement 要增加的元素\r\n//返回：成功时返回 true ，失败时返加 false\r\nbool Array_AddElement(ArrayStruct *pArray,const int iAppendElement)\r\n{\r\n   if(pArray->iCurElementCount == pArray->iCurMaxElementCount)\r\n   {\r\n       //重新分配\r\n       int *pTempArray;\r\n       pTempArray = new int[pArray->iCurMaxElementCount+ARRAY_GROWUP];\r\n        if(!pTempArray)\r\n            return false;\r\n        //copy到新分配的\r\n       memcpy(pTempArray,pArray->pHead, sizeof(int)*pArray->iCurElementCount);\r\n        //删除以前的\r\n       delete pArray->pHead;\r\n        //重新设置参数\r\n       pArray->pHead= pTempArray;\r\n        pArray->iCurMaxElementCount+=ARRAY_GROWUP;\r\n       *(pArray->pHead+pArray->iCurElementCount)=iAppendElement;\r\n       pArray->iCurElementCount++;\r\n   }\r\n   else\r\n   {\r\n       *(pArray->pHead+pArray->iCurElementCount)=iAppendElement;\r\n       pArray->iCurElementCount++;\r\n   }\r\n    return true;\r\n}\r\n//功能：删除指定索引的元素，要保证元素在内存为线性不间隔存放\r\n//参数：ArrayStruct *pArray 要处理的数组结构体指针\r\n// const int iRemovedIndex 要删除的元素索引\r\n//返回：成功时返回 true ，失败时返加 false\r\nbool Array_RemoveElementAt(ArrayStruct *pArray,const int iRemovedIndex)\r\n{\r\n    if(pArray->iCurElementCount >iRemovedIndex && iRemovedIndex>=0)\r\n    {\r\n        int nRemain=pArray->iCurElementCount-iRemovedIndex-1;\r\n        memmove(pArray->pHead+iRemovedIndex,pArray->pHead+iRemovedIndex+1,sizeof(int)*nRemain);\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n//功能：返回指定索引的元素\r\n//参数：const ArrayStruct *pArray 要处理的数组结构体指针\r\n// const int iIndex 要取的索引值\r\n// int & iReturn 成功时的值\r\n//返回：成功为 true 失败为 false\r\nbool Array_GetElement(const ArrayStruct *pArray,const int iIndex,int & iReturn)\r\n{\r\n    if(pArray->iCurElementCount >iIndex && iIndex>=0)\r\n    {\r\n        iReturn= *(pArray->pHead+iIndex);\r\n        return true;\r\n    }\r\n\r\n    iReturn=-1;\r\n    return false;\r\n}\r\n//功能：删除一个数组\r\n//参数：自已定义\r\n//返回：无（12分）\r\nvoid Array_Release(ArrayStruct **pArray)\r\n{\r\n    delete (*pArray)->pHead;\r\n    delete (*pArray);\r\n    pArray=NULL;\r\n}\r\n```\r\n来操刀给你解决~这个主要是vector原理，认真回答题了，给个辛苦分吧~", "Konwledge_Point": "线性规划和规约", "Question": "新手小问题，就把三个简单的函数写出来就好\n求大神帮写个题...\n\n\n\n//==========下面是代码，完成相应函数==========\n\n\n\nconst int ARRAY_GROWUP = 10;\n\n\n\n//数组结构体定义\n\nstruct ArrayStruct\n\n{\n\n    int iCurMaxElementCount;    //当前数组最大能容纳元素个数\n\n    int iCurElementCount;       //当前元素数\n\n    int * pHead;                //指针头部\n\n};\n\n\n\n//功能：生成一个数组，参数为最初元素个数\n\n//参数：int iStartElementCount  数组初始化大小\n\n//返回：成功返回指针，否则返回 NULL\n\nArrayStruct * Array_Init(int iStartElementCount)\n\n{\n\n    if (iStartElementCount <= 0 )\n\n        return NULL;\n\n\n\nArrayStruct * pReturn;\n\npReturn = new ArrayStruct;\nif (pReturn == NULL)\n    return NULL;\n\npReturn->pHead = new int[iStartElementCount];\nif (pReturn->pHead == NULL)\n{\n    delete pReturn;\n    return NULL;\n}\npReturn->iCurMaxElementCount = iStartElementCount;\npReturn->iCurElementCount = 0;//表明当前没有元素\nreturn pReturn;\n\n\n\n\n}\n\n\n\n//  ========== 完成下面的函数\n\n\n\n//功能：向数组增加一个元素，如果元素超过上述 Array_Init \n\n//      函数的 iStartElementCount 参数时，请考虑如何适应\n\n//      可以假定一次增大ARRAY_GROWUP个元素容量，但要保证在内存中数据为线性存放\n\n//参数：ArrayStruct  *pArray   要处理的数组结构体指针\n\n//      const int iAppendElement     要增加的元素\n\n//返回：成功时返回 true ，失败时返加 false\n\nbool Array_AddElement(ArrayStruct  *pArray,const int iAppendElement)\n\n{\n\n\n\n}\n\n\n\n//功能：删除指定索引的元素，要保证元素在内存为线性不间隔存放\n\n//参数：ArrayStruct  *pArray   要处理的数组结构体指针\n\n//      const int iRemovedIndex    要删除的元素索引\n\n//返回：成功时返回 true ，失败时返加 false\n\nbool Array_RemoveElementAt(ArrayStruct  *pArray,const int iRemovedIndex)\n\n{\n\n}\n\n\n\n//功能：返回指定索引的元素\n\n//参数：const ArrayStruct  *pArray  要处理的数组结构体指针\n\n//      const int iIndex  要取的索引值\n\n//      int & iReturn 成功时的值\n\n//返回：成功为 true 失败为 false\n\nbool Array_GetElement(const ArrayStruct  *pArray,const int iIndex,int & iReturn)\n\n{\n\n}\n\n\n\n//功能：删除一个数组\n\n//参数：自已定义\n\n//返回：无（12分）\n\nvoid  Array_Release(/* 请在这里填上参数 */)\n\n{", "Tag": "算法分析"}
{"Answer": "这样的格式可否？\n\n会计 {'专业1': {'1班': 48, '2班': 48, '3班': 46}, '专业2': {'1班': 46, '2班': 45, '3班': 47}, '专业3': {'1班': 46, '2班': 48, '3班': 46}}\n金融 {'专业1': {'1班': 48, '2班': 49, '3班': 47}, '专业2': {'1班': 49, '2班': 50, '3班': 50}, '专业3': {'1班': 45, '2班': 47, '3班': 46}}\n马列 {'专业1': {'1班': 47, '2班': 49, '3班': 47}, '专业2': {'1班': 50, '2班': 45, '3班': 47}}\n外语 {'专业1': {'1班': 49, '2班': 45, '3班': 50}, '专业2': {'1班': 50, '2班': 49, '3班': 50}, '专业3': {'1班': 48, '2班': 49, '3班': 48}}\n人文 {'专业1': {'1班': 48, '2班': 47, '3班': 46}, '专业2': {'1班': 45, '2班': 50, '3班': 49}}\n旅游 {'专业1': {'1班': 45, '2班': 47, '3班': 50}, '专业2': {'1班': 50, '2班': 45, '3班': 46}, '专业3': {'1班': 49, '2班': 49, '3班': 45}}\n软件 {'专业1': {'1班': 45, '2班': 46, '3班': 45}, '专业2': {'1班': 49, '2班': 47, '3班': 47}, '专业3': {'1班': 46, '2班': 45, '3班': 49}}\n信息 {'专业1': {'1班': 45, '2班': 48, '3班': 50}, '专业2': {'1班': 49, '2班': 49, '3班': 46}}\n工商 {'专业1': {'1班': 48, '2班': 47, '3班': 47}, '专业2': {'1班': 47, '2班': 46, '3班': 48}, '专业3': {'1班': 50, '2班': 47, '3班': 49}}\n财税 {'专业1': {'1班': 48, '2班': 46, '3班': 50}, '专业2': {'1班': 49, '2班': 47, '3班': 47}, '专业3': {'1班': 49, '2班': 46, '3班': 45}}\n国贸 {'专业1': {'1班': 49, '2班': 46, '3班': 50}, '专业2': {'1班': 48, '2班': 47, '3班': 50}, '专业3': {'1班': 48, '2班': 45, '3班': 48}}\n经济 {'专业1': {'1班': 49, '2班': 45, '3班': 50}, '专业2': {'1班': 48, '2班': 47, '3班': 50}, '专业3': {'1班': 50, '2班': 45, '3班': 47}}\n统计 {'专业1': {'1班': 50, '2班': 50, '3班': 49}, '专业2': {'1班': 50, '2班': 48, '3班': 48}}\n数学 {'专业1': {'1班': 48, '2班': 48, '3班': 46}, '专业2': {'1班': 49, '2班': 48, '3班': 49}}\n体育 {'专业1': {'1班': 49, '2班': 48, '3班': 50}, '专业2': {'1班': 50, '2班': 50, '3班': 47}, '专业3': {'1班': 48, '2班': 49, '3班': 48}}\n测绘 {'专业1': {'1班': 48, '2班': 45, '3班': 45}, '专业2': {'1班': 49, '2班': 49, '3班': 46}, '专业3': {'1班': 46, '2班': 47, '3班': 46}}\n\n", "Konwledge_Point": "线性规划和规约", "Question": "python,excle,文件处理，\n已知某大学共有16个学院（会计、金融、马列、外语、人文、旅游、软件、信息、工商、财税、国贸、经济、统计、数学、体育、测绘），每个学院有2-3个专业（随机生成，在各个学院名称后面加专业1、专业2、专业3区分），每个专业招收3个班，每个班的人数为：45-50人，班级数量范围为：96到130个班级（Random）。100*50=5000个学生\n（1）    随机生成各个学院各个专业各个班级的学生，数据保存到excel文件中（文件处理，异常处理，基本语法）；\n（2）    每个专业随机生成课程数量为20门，其中必须包括：高数一、线性代数、英语一、马克思原理，其他课程为专业课16门。考虑到专业不同，课程名用学院、专业名，课程名代替：比如：“软件专业1课程1”表示一门专业课。", "Tag": "算法分析"}
{"Answer": "欸，小兄弟，我之前给你答了，你咋啥都没回复，直接删了，另一个也直接结题，现在又发，是代码有哪里出问题吗？\n数据结构与算法“爸爸去哪儿”房子分配问题2-数据结构与算法-CSDN问答\nCSDN问答为您找到数据结构与算法“爸爸去哪儿”房子分配问题2相关问题答案，如果想了解更多关于数据结构与算法“爸爸去哪儿”房子分配问题2 c++、数据结构、有问必答、 技术问题等相关问答，请访问CSDN问答。\n\n\n\nhttps://ask.csdn.net/questions/7558320?spm=1001.2014.3001.5505\n\n", "Konwledge_Point": "线性规划和规约", "Question": "数据结构与算法“爸爸去哪儿”分配问题1\n题目描述\n\n\n最近“爸爸去哪儿”节目很火，据说新一期节目分房的策略有所改变:共有m间房，序号从0到m-1，村长根据每个小朋友的英 文名来分配房子。\n\n\n具体规则如下:\n\n\n每个小朋友的英文名都能得到一个对应的数值:‘a’数值为1，‘b’数值为2，…，‘z’数值为26，小朋友的英文名的数值为各个字母的数值和，比如kimi的英文名的数值为11+9+13+9=42。注:规定输入的英文名均为小写字母\n\n\n假设小朋友的英文名的数值为numName的话，那这个小朋友和他爸爸本期节目要住的房子就是(numName mod m)号房。 如果某小朋友的numName mod m得到的值和之前的小朋友的一样，则用哈希中的线性探测法:找下一号房直到找到一间还没有父 子入住的，若已经找到第m-1间还有人，则回到第0间找。\n\n\n分配完房子之后，村长想知道这个分房策略的平均查找长度是多少，也就是说村长根据这个策略来查找每个人的房子时，平均需要查找多少房子(结果保留三位小数)。\n\n\n比如有以下5个小朋友，并且有6间房:\n\n\n\n\n平均查找长度为:(1+1+1+2+2) / 5 = 1.400\n输入描述\n\n\n输入有多个测试用例，以EOF结束。\n\n\n对于每个测试用例，输入分两部分:\n\n\n第一部分是1行，有两个整数n和m(1<= n, m<=10,000)，中间用空格隔开，n代表有多少对明星父子参加节目，m代表一共 有多少间房\n\n\n第二部分是n行，每行都是一个小朋友的英文名，小朋友的英文名彼此都不同，且中间没有空格。每个小朋友的英文名不超过 10个字母，且均为小写字母\n输出描述\n\n\n对于每个测试用例，输出m+1行 前m行，每行为房子序号+“:”+要入住的小朋友的英文名，没有人入住则输出房子序号+“:NULL”\n\n\n第m+1行输出一个数字，表示平均查找长度，保留三位小数\n输入样例\n\n\n5 6\nkimi\ntiantian\nstone\nangela\ncindy\n\n\n输出样例\n\n\n0:kimi\n1:stone\n2:cindy\n3:NULL\n4:tiantian\n5:angela\n1.400\n\n\n给出代码，谢谢", "Tag": "算法分析"}
{"Answer": "在保存和加载时使用的是二进制文件，这是因为在 Save 函数中使用了 fwrite，而在 Load 函数中使用了 fread。\n在这种情况下，应该将文件以二进制格式打开，而不是使用文本模式。在 Save 函数中，应使用 \"wb\" 模式打开文件，而在 Load 函数中，应使用 \"rb\" 模式打开文件。\n在 Load 函数中，需要将新节点的 next 指针设置为 NULL，否则将在读取新节点时可能遇到问题。\n如果希望保留原来的信息，并在文件的末尾添加新的信息，则应在 Save 函数中使用 \"a\" 模式打开文件。\n在使用二进制文件时，请确保结构体中没有任何动态分配的内存，因为这可能会导致问题。例如，如果结构体中有指针字段，则可能需要编写自己的读写函数来处理这些字段。", "Konwledge_Point": "线性规划和规约", "Question": "使用fwrite()函数和fread()函数发生乱码问题\n问题遇到的现象和发生背景\n\n\n我做了一个基于哈希表的身份证查询系统，运行程序想把输入的信息写入文件中\n\n\nvoid\n \nSave\n(IDLnode*& L)\n\n\n{\n    FILE* fp = \nfopen\n(\n\"D:\\\\IDcardSearchSystem.txt\"\n, \n\"w\"\n);\n//打开文件\n\n    \nif\n (fp == \nNULL\n)\n    {\n        \nperror\n(\n\"打开文件失败\\n\"\n);\n        \nsystem\n(\n\"pause\"\n);\n        \nsystem\n(\n\"cls\"\n);\n        \nreturn\n;\n    }\n    IDLnode* p = L;\n    \nwhile\n (p != \nNULL\n)\n    {\n        \nfwrite\n(&p, \nsizeof\n(IDLnode),\n1\n, fp);\n        p = p->next;\n    }\n    \nfclose\n(fp);    \n//关闭文件\n\n    \nprintf\n(\n\"保存成功！\\n\"\n);\n}\n\nvoid\n \nLoad\n(IDLnode*& L)\n\n\n{\n    FILE* fp = \nfopen\n(\n\"D:\\\\IDcardSearchSystem.txt\"\n, \n\"r\"\n);\n//打开文件\n\n\n    \nif\n (fp == \nNULL\n)\n    {\n        \nperror\n(\n\"\\n打开文件失败.\\n\"\n);\n        \nreturn\n;\n    }\n\n    IDLnode p;\n    \nwhile\n (\nfread\n(&p, \nsizeof\n(IDLnode),\n1\n, fp))\n    {\n        \n//创建新节点\n\n        IDLnode* pNewNode = (IDLnode*)\nmalloc\n(\nsizeof\n(IDLnode));\n\n        pNewNode->next = \nNULL\n;\n\n        \n//memcpy(pNewNode, &stu, sizeof(IDLnode));\n\n\n        \nif\n (pNewNode != \nNULL\n)\n        {\n            \nstrcpy\n(pNewNode->ID, p.ID);\n            \nstrcpy\n(pNewNode->Name, p.Name);\n            \nstrcpy\n(pNewNode->Address, p.Address);\n            pNewNode->next = L;\n            L = pNewNode;\n        }\n\n    }\n\n    \nfclose\n(fp);\n\n    \nprintf\n(\n\"\\n读取成功！\\n\"\n);\n\n    \nsystem\n(\n\"pause\"\n);\n    \nsystem\n(\n\"cls\"\n);\n}\n\n\n\n遇到的现象和发生背景，请写出第一个错误信息\n\n\n但是当我重新运行程序后，读取信息并将读取的信息打印在屏幕上发现是乱码，而非我之前填入的信息，这是为什么啊\n\n\n用代码块功能插入代码，请勿粘贴截图。 不用代码块回答率下降 50%\n\n\n以下是部分代码\n\n\n#\ndefine\n HashTableLength 50        \n//哈希表长度\n\n\n#\ndefine\n IdLength 20        \n//身份证号长度\n\n\n#\ndefine\n Prime 47    \n//质数\n\n\n#\ndefine\n NameLength 30\n\n\n#\ndefine\n AddressLength 50\n\n\n\n//身份证单链表\n\n\ntypedef\n \nstruct\n \nIDLnode\n\n{\n    \nchar\n ID[IdLength];        \n//身份证号\n\n    \nchar\n Name[NameLength];            \n//姓名\n\n    \nchar\n Address[AddressLength];        \n//地址\n\n    \nstruct\n \nIDLnode\n* next;\n}IDLnode;\n\n\n//身份证号哈希表\n\n\ntypedef\n \nstruct\n \nIDHashTable\n\n{\n    \nchar\n HI_ID[IdLength];\n    \nchar\n HI_Name[NameLength];\n    \nchar\n HI_Address[AddressLength];\n    \nint\n state;\n}IDHashTable;\n\n\n//姓名哈希表\n\n\ntypedef\n \nstruct\n \nNameHashTable\n\n{\n    \nchar\n HN_ID[IdLength];\n    \nchar\n HN_Name[NameLength];\n    \nchar\n HN_Address[AddressLength];\n    \nint\n state;\n}NameHashTable;\n\nbool\n \nInsert\n(IDLnode*& L, IDHashTable*& IH, NameHashTable*& NH, \nconst\n \nchar\n* id, \nconst\n \nchar\n* name, \nconst\n \nchar\n* address)\n\n\n{\n    \n//头插添加进链表\n\n    IDLnode* p = (IDLnode*)\nmalloc\n(\nsizeof\n(IDLnode));\n    \nif\n (p != \nNULL\n)\n    {\n        \nstrcpy\n(p->ID, id);\n        \nstrcpy\n(p->Name, name);\n        \nstrcpy\n(p->Address, address);\n        p->next = L;\n//->next;\n\n        L = p;\n    }\n    \nconst\n \nchar\n temp[\n1\n] = { \n'\\0'\n };\n    \n//用哈希函数抽象出关键字放入哈希表中\n\n    \nint\n namekey = \nHashName\n(name);        \n//获取关键字\n\n    \nint\n idkey = \nHashID\n(id);\n    \n//放入身份证号哈希表中\n\n    \nwhile\n (IH[idkey].state == \n1\n && \nstrcmp\n(IH[idkey].HI_ID, temp) != \n0\n)    \n//线性探测再散列法，用state判断是否冲突，当state=1为冲突，向后存放关键字\n\n        idkey++;\n    \nstrcpy\n(IH[idkey].HI_ID, id);\n    \nstrcpy\n(IH[idkey].HI_Name, name);\n    \nstrcpy\n(IH[idkey].HI_Address, address);\n    IH[idkey].state = \n1\n;\n        \n    \n//放入姓名哈希表中\n\n    \nwhile\n (NH[namekey].state == \n1\n && \nstrcmp\n(NH[namekey].HN_ID, temp) != \n0\n)\n        namekey++;\n    \nstrcpy\n(NH[namekey].HN_ID, id);\n    \nstrcpy\n(NH[namekey].HN_Name, name);\n    \nstrcpy\n(NH[namekey].HN_Address, address);\n    NH[namekey].state = \n1\n;\n\n    \nreturn\n \ntrue\n;\n}\n\n\n\n运行结果及详细报错内容\n\n\n\n\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "如果你要手动触发就把这个函数再拎出来一份，不然你这个只有加载页面触发，然后下边点击的时候没有这个del函数呀", "Konwledge_Point": "线性规划和规约", "Question": "用jsp写了个表格删除和添加，删除用了触发事件按，但是触发事件没有反应怎么会是。\n问题遇到的现象和发生背景\n\n\n用代码块功能插入代码，请勿粘贴截图\n\n\n\n```javascript\n\n<%@ page language=\n\"java\"\n contentType=\n\"text/html; charset=utf-8\"\n\n    pageEncoding=\n\"utf-8\"\n%>\n\n\n\n\n\n<\nhtml\n>\n\n\n<\nhead\n>\n\n\n<\nmeta\n \ncharset\n=\n\"utf-8\"\n>\n\n\n<\ntitle\n>\n表格的添加和删除\n\n\n\n\n<\nscript\n>\n\n    \nwindow\n.\nonload\n=\nfunction\n(\n){\n        \nfunction\n \ndel\n(\nobject\n){\n            \nvar\n table=object.\nparentNode\n.\nparentNode\n.\nparentNode\n;\n            \nvar\n tr=object.\nparentNode\n.\nparentNode\n;\n            table.\nremoveChild\n(tr);\n        }\n    }\n\n\n\n\n<\nbody\n>\n\n\n<%!\n\npublic\n \nclass\n Teacher{\n    int id;\n    String name;\n    String brithday;\n    String address;\n    double salary;\n    String operate;\n    \npublic\n Teacher(int id,String name,String brithday,String address,double salary,String operate){\n        this.id=id;\n        this.name=name;\n        this.brithday=brithday;\n        this.address=address;\n        this.salary=salary;\n        this.operate=operate;\n    }\n    int getId()\n    {\n        return id;\n    }\n    String getName()\n    {\n        return name;\n    }\n    String getBrith\nday\n()\n    {\n        return brithday;\n    }\n    String getAddress()\n    {\n        return address;\n    }\n    double getSalary()\n    {\n        return salary;\n    }\n    String getOperate()\n    {\n        return operate;\n    }\n}\n%>\n\n\n<%\nTeacher[] teacher=\nnew\n Teacher[\n10\n];\nteacher[\n0\n]=\nnew\n Teacher(\n11201\n,\n\"文华\"\n,\n\"1980-6-12\"\n,\n\"淮南\"\n,\n6600\n,\n\"英语\"\n);\nteacher[\n1\n]=\nnew\n Teacher(\n11202\n,\n\"余祥\"\n,\n\"1984-7-23\"\n,\n\"合肥\"\n,\n7000\n,\n\"数据结构\"\n);\nteacher[\n2\n]=\nnew\n Teacher(\n11203\n,\n\"于资\"\n,\n\"1985-2-1\"\n,\n\"南京\"\n,\n6700\n,\n\"离散\"\n);\nteacher[\n3\n]=\nnew\n Teacher(\n11204\n,\n\"卜悦\"\n,\n\"1991-5-16\"\n,\n\"合肥\"\n,\n6600\n,\n\"高等数学\"\n);\nteacher[\n4\n]=\nnew\n Teacher(\n11205\n,\n\"王毅\"\n,\n\"1987-7-16\"\n,\n\"芜湖\"\n,\n6600\n,\n\"线性代数\"\n);\nteacher[\n5\n]=\nnew\n Teacher(\n11206\n,\n\"赵鑫\"\n,\n\"1988-3-26\"\n,\n\"合肥\"\n,\n6600\n,\n\"java\"\n);\nteacher[\n6\n]=\nnew\n Teacher(\n11207\n,\n\"丁莹\"\n,\n\"1990-11-21\"\n,\n\"蚌埠\"\n,\n6600\n,\n\"c++\"\n);\nteacher[\n7\n]=\nnew\n Teacher(\n11208\n,\n\"程明\"\n,\n\"1984-12-17\"\n,\n\"合肥\"\n,\n6600\n,\n\"c语言\"\n);\nteacher[\n8\n]=\nnew\n Teacher(\n11209\n,\n\"张强\"\n,\n\"1986-9-16\"\n,\n\"阜阳\"\n,\n6600\n,\n\"毛概\"\n);\nteacher[\n9\n]=\nnew\n Teacher(\n11210\n,\n\"周霞\"\n,\n\"1991-5-26\"\n,\n\"合肥\"\n,\n6600\n,\n\"思修\"\n);\n%>\n\n\n<\ntable\n \nalign\n=\n\"center\"\n \nborder\n=\n\"2\"\n \nwidth\n=\n\"70%\"\n>\n\n\n<\ntr\n>\n\n\n<\nth\n>\n教工号\n\n<\nth\n>\n姓名\n\n<\nth\n>\n出生日期\n\n<\nth\n>\n籍贯\n\n<\nth\n>\n薪水\n\n<\nth\n>\n课程\n\n<\nth\n>\n操作\n\n\n\n\n<%\nint i;\n\nfor\n(i=\n0\n;i\n\n\n<\ntr\n>\n\n\n<\ntd\n \nalign\n=\n\"center\"\n>\n<%=teacher[i].getId() %>\n\n\n\n<\ntd\n \nalign\n=\n\"center\"\n>\n<%=teacher[i].getName() %>\n\n\n\n<\ntd\n \nalign\n=\n\"center\"\n>\n<%=teacher[i].getBrith\nday\n() %>\n\n\n\n<\ntd\n \nalign\n=\n\"center\"\n>\n<%=teacher[i].getAddress() %>\n\n\n\n<\ntd\n \nalign\n=\n\"center\"\n>\n<%=teacher[i].getSalary() %>\n\n\n\n<\ntd\n \nalign\n=\n\"center\"\n>\n<%=teacher[i].getOperate() %>\n\n\n\n<\ntd\n \nalign\n=\n\"center\"\n>\n<\na\n \nhref\n=\n\"javascript:void(0);\"\n \nonclick\n=\n\"del(this)\"\n>\n删除\n\n \n\n\n<\na\n \nhref\n=\n\"#\"\n>\n修改\n\n\n\n\n<%}%>\n\n\n\n\n\n\n\n\n\n\n\n\n运行结果及报错内容\n\n\n写个了删除的触发事件但是没有反应是怎么回事", "Tag": "算法分析"}
{"Answer": "int len = C.length;这行代码有异常。\n\nimport java.util.Scanner;\nclass Student {\n    String[] Name;\n    char[] Sex;\n    float[] Hmath;\n    float[] Lmath;\n    float[] C;\n    float[] Object;\n    int len =0;\n    public void Creat() {\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请输入录入学生信息的数量：\");\n        int m = sc.nextInt();\n         len=m;\n        Name = new String[m];\n        Sex = new char[m];\n        Hmath = new float[m];\n        Lmath = new float[m];\n        C = new float[m];\n        Object = new float[m];\n        for(int i=0;i<m;i++)\n        {\n             System.out.println(\"请输入第\"+i+\"组数据\");\n             Name[i] = sc.nextLine();\n             Sex[i] = sc.next().charAt(0);\n             Hmath[i] = sc.nextFloat();\n             Lmath[i] = sc.nextFloat();\n             C[i] = sc.nextFloat();\n             Object[i] = sc.nextFloat();\n         }\n    }\n    public void Print() {\n        for(int i=0;i<len;i++)\n        {\n             System.out.println(\"第\"+i+\"组\");\n             System.out.println(Name[i]+\",\");\n             System.out.println(Sex[i]+\",\");\n             System.out.println(Hmath[i]+\",\");\n             System.out.println(Lmath[i]+\",\");\n             System.out.println(C[i]+\",\");\n             System.out.println(Object[i]+\",\");\n         }\n    }\n    public void Put() {\n        float Sum1=0,Ave1=0;\n        float Sum2=0,Ave2=0;\n        float Sum3=0,Ave3=0;\n        float Sum4=0,Ave4=0;\n        for(int i=0;i<len;i++)\n             Sum1+=Hmath[i];\n        for(int i=0;i<len;i++)\n             Sum2+=Lmath[i];\n        for(int i=0;i<len;i++)\n             Sum3+=C[i];\n        for(int i=0;i<len;i++)\n             Sum4+=Object[i];\n        Ave1=Sum1/len;\n        Ave2=Sum2/len;\n        Ave3=Sum3/len;\n        Ave4=Sum4/len;\n        System.out.println(\"高等数学平均成绩为\"+Ave1);\n        System.out.println(\"线性代数平均成绩为\"+Ave2);\n        System.out.println(\"C语言平均成绩为\"+Ave3);\n        System.out.println(\"面对对象平均成绩为\"+Ave4);\n    }\n}\npublic class TestStudent {\n    public static void main(String[] args) {\n        Student Stu = new Student();\n        Stu.Creat();\n        Stu.Put();\n        Stu.Print();\n    }\n}\n", "Konwledge_Point": "线性规划和规约", "Question": "希望有人解答这个Java问题\n代码要求是线性表输入学生成绩信息\n\n\nimport java.util.Scanner;\n\nclass\n \nStudent\n {\n    String[] Name;\n    \nchar\n[] Sex;\n    \nfloat\n[] Hmath;\n    \nfloat\n[] Lmath;\n    \nfloat\n[] C;\n    \nfloat\n[] Object;\n    \nint\n len = C.length;\n    \npublic\n \nvoid\n \nCreat\n(\n)\n {\n        Scanner sc = \nnew\n Scanner(System.\nin\n);\n        System.\nout\n.println(\n\"请输入录入学生信息的数量：\"\n);\n        \nint\n m = sc.nextInt();\n        Name = \nnew\n String[m];\n        Sex = \nnew\n \nchar\n[m];\n        Hmath = \nnew\n \nfloat\n[m];\n        Lmath = \nnew\n \nfloat\n[m];\n        C = \nnew\n \nfloat\n[m];\n        Object = \nnew\n \nfloat\n[m];\n        \nfor\n(\nint\n i=\n0\n;i(Student.java:\n9\n)\n        at TestStudent.main(TestStudent.java:\n3\n)\n", "Tag": "算法分析"}
{"Answer": "<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n    <meta charset=\"UTF-8\">\n    <link rel=\"stylesheet\" href=\"/static/css/bootstrap.css\">\n    <link href=\"/static/css/base.css\" rel=\"stylesheet\">\n    <title>学生登录</title>\n</head>\n<body>\n<div>\n<!--引入使用-->\n<iframe src=\"./母版.html\" width=\"100%\" height=\"50\" frameborder=\"0\"></iframe>\n</div>\n<div class=\"container\" id=\"username\" >\n    <div class=\"row\">\n        <div class=\"col-md-6 col-md-offset-3\">\n            <form action=\"/studentlogin/\" method=\"post\" class=\"form-horizontal\" role=\"form\">\n                {% csrf_token %}\n            <div class=\"form-group\">\n            <label for=\"{{  form_object.username.id_for_label}}\" class=\"col-sm-2 control-label\">{{ form_object.username.label }}</label>\n            <div class=\"col-sm-10\">\n                {{ form_object.username }}\n                <span id=\"helpBlock2\" class=\"help-block\"></span>\n            </div>\n          </div>\n            </form>\n        </div>\n    </div>\n</div>\n \n<script src=\"/static/jquery-3.3.1.js\"></script>\n<script src=\"/static/js/bootstrap.js\"></script>\n</body>\n</html>\n \n\n\n", "Konwledge_Point": "线性规划和规约", "Question": "pycharm HTML编辑 母版页调用\n母版\n\n\n\n\n\n<\nhtml\n \nlang\n=\n\"zh-CN\"\n>\n\n\n<\nhead\n>\n\n    \n<\nmeta\n \ncharset\n=\n\"UTF-8\"\n>\n\n    \n<\ntitle\n>\nTitle\n\n\n    \n<\nlink\n \nhref\n=\n\"/static/css/bootstrap.css\"\n \nrel\n=\n\"stylesheet\"\n>\n\n    \n<\nscript\n \nsrc\n=\n\"/static/jquery-3.3.1.js\"\n>\n\n\n    \n<\nscript\n \nsrc\n=\n\"/static/js/bootstrap.js\"\n>\n\n\n    \n<\nlink\n \nrel\n=\n\"stylesheet\"\n  \nhref\n=\n\"/static/css/base.css\"\n>\n\n\n\n\n\n<\nbody\n>\n\n\n<\ndiv\n \nclass\n=\n\"base-div\"\n>\n\n\n    \n<\nul\n \nclass\n=\n\"list-inline\"\n>\n\n        \n<\nli\n>\n<\na\n \nclass\n=\n\"base-p\"\n>\n线性代数试卷生成系统\n\n\n\n        \n<\nli\n>\n\n            \n<\nbutton\n \ntype\n=\n\"button\"\n \nclass\n=\n\"btn btn-primary\"\n \nid\n=\n\"button-student\"\n>\n学生登录\n\n\n\n        \n<\nli\n>\n\n            \n<\nbutton\n \ntype\n=\n\"button\"\n \nclass\n=\n\"btn btn-primary\"\n \nid\n=\n\"button-teacher\"\n>\n教师登陆\n\n\n\n        \n<\nli\n>\n\n            \n<\nbutton\n \ntype\n=\n\"button\"\n \nclass\n=\n\"btn btn-primary\"\n \nid\n=\n\"button-admin\"\n>\n管理员登录\n\n\n\n        \n<\nli\n \nclass\n=\n\"message\"\n>\n\n            \n{{ \nstudent.name\n }}\n{{ \nmessage\n }}\n\n        \n\n\n        \n<\nli\n>\n\n            \n<\nbutton\n \ntype\n=\n\"button\"\n \nclass\n=\n\"btn btn-danger\"\n \nid\n=\n\"lagout\"\n >\n退出\n\n\n\n\n\n\n\n\n\n\n\n\n\nform表单：\n\n\n\n\n\n<\nhtml\n \nlang\n=\n\"zh-CN\"\n>\n\n\n<\nhead\n>\n\n    \n<\nmeta\n \ncharset\n=\n\"UTF-8\"\n>\n\n    \n<\nlink\n \nrel\n=\n\"stylesheet\"\n \nhref\n=\n\"/static/css/bootstrap.css\"\n>\n\n    \n<\nlink\n \nhref\n=\n\"/static/css/base.css\"\n \nrel\n=\n\"stylesheet\"\n>\n\n    \n<\ntitle\n>\n学生登录\n\n\n\n\n<\nbody\n>\n\n\n<\ndiv\n>\n\n\n\n\n\n\n<\ndiv\n \nclass\n=\n\"container\"\n \nid\n=\n\"username\"\n >\n\n    \n<\ndiv\n \nclass\n=\n\"row\"\n>\n\n        \n<\ndiv\n \nclass\n=\n\"col-md-6 col-md-offset-3\"\n>\n\n            \n<\nform\n \naction\n=\n\"/studentlogin/\"\n \nmethod\n=\n\"post\"\n \nclass\n=\n\"form-horizontal\"\n \nrole\n=\n\"form\"\n>\n\n                {% csrf_token %}\n            \n<\ndiv\n \nclass\n=\n\"form-group\"\n>\n\n            \n<\nlabel\n \nfor\n=\n\"\n{{  \nform_object.username.id_for_label\n}}\n\"\n \nclass\n=\n\"col-sm-2 control-label\"\n>\n{{ \nform_object.username.label\n }}\n\n\n            \n<\ndiv\n \nclass\n=\n\"col-sm-10\"\n>\n\n                \n{{ \nform_object.username\n }}\n\n                \n<\nspan\n \nid\n=\n\"helpBlock2\"\n \nclass\n=\n\"help-block\"\n>\n\n\n\n\n\n\n\n\n\n\n\n<\nscript\n \nsrc\n=\n\"/static/jquery-3.3.1.js\"\n>\n\n\n\n<\nscript\n \nsrc\n=\n\"/static/js/bootstrap.js\"\n>\n\n\n\n\n\n\n\n\n\n\n想请教一下，pycharm怎样调用自己弄好的模板HTML到新的HTML页面，我设计了一个在顶部的导航栏HTML，我想在设计其它HTML页面的时候保留顶部的导航栏", "Tag": "算法分析"}
{"Answer": "\n代码修改如下：\n#include <iostream>\nusing namespace std;\n\ntemplate<typename T>\nclass SingleLinkedList\n{\nprivate:\n    class SLNode\n    {\n    public:\n        T _data;\n        SLNode* next;\n\n        SLNode()\n        {\n            //this->_data = 0;\n            this->next = NULL;\n        }\n    };\n    SLNode* _head;\n    int _count;\n\npublic:\n\n    SingleLinkedList()\n    {\n        _head =  new SLNode();\n        _head->next = NULL;\n        //SLNode<T>* _head = NULL;\n        this->_count = 0;\n    }\n\n    void push_back( T data)\n    {\n        SLNode* new_node = new SLNode();\n        new_node->_data = data;\n        new_node->next = NULL;\n\n        SLNode* last_node = _head;\n        for (int i = 0; i < _count; i++)\n        {\n            last_node = last_node->next;\n        }\n        new_node->next = last_node->next;\n        last_node->next = new_node;\n    }\n    void insert(int pos, T data)\n    {\n        if (_head == NULL)\n        {\n            pos = 0;\n        }\n        SLNode* new_node = new SLNode();\n        new_node->_data = data;\n        new_node->next = NULL;\n\n        SLNode* pos_node = _head;\n        for (int i = 0; i < pos; i++)\n            pos_node = pos_node->next;\n        new_node->next = pos_node->next;\n        pos_node->next = new_node;\n        _count++;\n    }\n\n    void show()\n    {\n        if (_count == 0)\n            cout << \"该链表中没有数据\" << endl;\n        else {\n            SLNode* pcurrent = _head->next;\n            while (pcurrent != NULL)\n            {\n                cout << pcurrent->_data << endl;\n                pcurrent = pcurrent->next;\n            }\n            cout << endl;\n        }\n    }\n\n};\n\nclass Student\n{\npublic:\n    Student();\n    Student(int id, string name, float age, double score);\n    ~Student();\n    friend ostream& operator<<(ostream& os, const Student& s)\n    {\n        os << \"学号:\" << s._id << \"  姓名：\" << s._name << \"  年龄\" << s._age << \"  成绩：\" << s._score << endl;\n        return os;\n\n    }\n    string str()\n    {\n        cout << \"内部输出:\" << endl;\n        cout << \"学号:\" << _id << \"  姓名：\" << _name << \"  年龄\" << _age << \"  成绩：\" << _score << endl;\n        return \"\\n\";\n    };\n    Student& operator =(const Student& x)\n    {\n        this->_id = x._id;\n        this->_age = x._age;\n        this->_score = x._score;\n        this->_name = x._name;\n        return *this;\n\n    }\nprivate:\n    int _id;\n    string _name;\n    float _age;\n    double _score;\n\n};\nStudent::Student()\n{\n    _id = 0;\n    _name = \"\";\n    _age = 0;\n    _score = 0;\n}\nStudent::Student(int id, string name, float age, double score)\n{\n    _id = id;\n    _name = name;\n    _age = age;\n    _score = score;\n}\n\nStudent::~Student()\n{\n}\n\n\n\n\n\nint main()\n{\n\n    Student s1 = { 001,\"桑桑\",18.0f,88.0l };\n    Student s2 = { 002,\"稚稚\",8.0f,77.0l };\n    Student s3 = { 000,\"渊渊\",25.0f,99.0l };\n    SingleLinkedList<Student> L1;\n    cout << s1 << endl;\n    L1.push_back(s1);\n    L1.push_back(s2);\n    cout << s1 << endl;\n    L1.insert(0, s3);\n    L1.show();\n    return 0;\n}\n\n\n\n", "Konwledge_Point": "线性规划和规约", "Question": "关于自定义单链表实现Student类型数据存放的问题，主要是结点的构造不太明白！(语言-c++)\n实验要求： main 函数中利用单向链表类 SingleLinkedList， 定义和初始化一个 Student 类型的线性链表，在表中添加（push_back）和插入（insert）新的元素。\n\n\n结点的构造\n\n\ntemplate\n<\ntypename\n T>\n\nclass\n \nSLNode\n\n{\n\npublic\n:\n    T _data;\n    SLNode* next; \n    \n    \nSLNode\n()\n    {\n        \nthis\n->_data = \nNULL\n;\n        \nthis\n-> next = \nNULL\n;\n    }\n};\n\n\n\n链表的实现\n\n\ntemplate\n\nclass\n \nSingleLinkedList\n\n\n{\n\nprivate\n:\n    SLNode* _head;\n    \nint\n _count;\n\n\npublic\n:\n\n    SingleLinkedList()\n    {\n        SLNode* _head = \nNULL\n;\n        this->_count = \nNULL\n;\n    }\n\n    \nvoid\n push_back(SingleLinkedList* L, T data)\n    {\n        SLNode* new_node = \nnew\n SLNode();\n        new_node->_data = data;\n        new_node->next = \nNULL\n;\n\n        SLNode* last_node = L->_head;\n        \nfor\n (\nint\n i = \n0\n; i < _count; i++)\n        {\n            last_node = last_node->next;\n        }\n        new_node->next = last_node->next;\n        last_node->next = new_node;\n    }\n    \nvoid\n insert(SingleLinkedList* L, \nint\n pos, T data)\n    {\n        \nif\n (L == \nNULL\n)\n        {\n            pos = \n0\n;\n        }\n        SLNode* new_node = \nnew\n SLNode();\n        new_node->_data = data;\n        new_node->next = \nNULL\n;\n\n        SLNode* pos_node = L->_head;\n        \nfor\n (\nint\n i = \n0\n; i < pos; i++)\n            pos_node = pos_node->next;\n        new_node->next = pos_node->next;\n        pos_node->next = new_node;\n        L->_count++;\n    }\n\n    \nvoid\n show(SingleLinkedList* L)\n    {\n        \nif\n (L->_count == \n0\n)\n            cout << \n\"该链表中没有数据\"\n << endl;\n        \nelse\n {\n            SLNode* pcurrent = L->_head->next;\n            \nwhile\n (pcurrent != \nNULL\n)\n            {\n                cout << pcurrent->_data << endl;\n                pcurrent = pcurrent->next;\n            }\n            cout << endl;\n        }\n    }\n\n};\n\n\n\n\n测试函数\n\n\nint main()\n{\n    \n    Student \ns1\n = { \n001\n,\n\"桑桑\"\n,\n18\n.\n0\nf,\n88\n.\n0\nl };\n    Student \ns2\n = { \n002\n,\n\"稚稚\"\n,\n8\n.\n0\nf,\n77\n.\n0\nl };\n    Student \ns3\n = { \n000\n,\n\"渊渊\"\n,\n25\n.\n0\nf,\n99\n.\n0\nl };\n    SingleLinkedList L1;\n        cout << \ns1\n << endl;\n    L1.push_back(&L1,\ns1\n);\n    L1.push_back(&L1,\ns2\n);\n    cout << \ns1\n << endl;\n    L1.\ninsert(&L1, \n0\n, \ns3\n);\n    L1.\nshow(&L1);\n\n}\n\n\n\n\nStudent类\n\n\nclass Student\n{\npublic:\n    Student(int id, string \nname\n, float age, double \nscore\n);\n    ~Student();\n    friend ostream& operator<<(ostream&os, const Student&s)\n    {\n       os << \n\"学号:\"\n << s.\n_id\n << \n\"  姓名：\"\n << s.\n_name\n << \n\"  年龄\"\n << s.\n_age\n << \n\"  成绩：\"\n << s.\n_score\n << \nendl\n;\n            return os;\n        \n    }\n    string \nstr\n()\n    {\n        cout << \n\"内部输出:\"\n << \nendl\n;\n        cout << \n\"学号:\"\n << \n_id\n << \n\"  姓名：\"\n << \n_name\n << \n\"  年龄\"\n << \n_age\n << \n\"  成绩：\"\n << \n_score\n << \nendl\n;\n        return \n\"\\n\"\n;\n    };\n    Student& operator =(const Student&x)\n    {\n        this->\n_id\n = x.\n_id\n;\n        this->\n_age\n = x.\n_age\n;\n        this->\n_score\n = x.\n_score\n;\n        this->\n_name\n = x.\n_name\n;\n        \n    \n    }\n\nprivate\n:\n    int \n_id\n;\n    string \n_name\n;\n    float \n_age\n;\n    double \n_score\n;\n\n};\n\nStudent::Student(int id, string \nname\n, float age, double \nscore\n)\n{\n    \n_id\n = id;\n    \n_name\n = \nname\n;\n    \n_age\n = age;\n    \n_score\n = \nscore\n;\n}\n\nStudent::~Student()\n{\n}\n\n\n\n\n报错\n\n\n已启动生成…\n\n1\n>\n------ 已启动生成: 项目: ex4p4, 配置: Debug x64 ------\n\n\n1\n>p4.cpp\n\n1\n>\nC\n:\\Users\\\n86150\n\\source\\repos\\ex3\\dsa\\SingledLinkedList.h(\n83\n,\n1\n): \nerror\n \nC2514\n: “SLNode”: 无法构建类模板\n\n1\n>\nC\n:\\Users\\\n86150\n\\source\\repos\\ex3\\dsa\\SingledLinkedList.h(\n7\n): message : 参见“SLNode”的声明\n\n1\n>\nC\n:\\Users\\\n86150\n\\source\\repos\\ex3\\dsa\\SingledLinkedList.h(\n83\n): message : 查看对正在编译的 类 模板 实例化“SingleLinkedList”的引用\n\n1\n>已完成生成项目“ex4p4.vcxproj”的操作 - 失败。\n========== 生成: 成功 \n0\n 个，失败 \n1\n 个，最新 \n1\n 个，跳过 \n0\n 个 ==========\n\n错误    C2514    “SLNode”: 无法构建类模板    ex4p4    \nC\n:\\Users\\\n86150\n\\source\\repos\\ex3\\dsa\\SingledLinkedList.h    \n83\n    //\n83\n是最后一行，有点迷惑\n\n\n\n希望可以详细指出我的错误原因，以及如何改正", "Tag": "算法分析"}
{"Answer": "将数组定义在全局数据区，就OK", "Konwledge_Point": "线性规划和规约", "Question": "c++为什么在宏定义大于4万以后就会出错?\n1.问题：素数筛法，在数组大小为40w时报错，显示发生了未经处理的win32异常。\n\n 关闭vs2015的调试-实时里面的选项后就是.exe已停止工作。\n\n 2.代码\n\n\n\n#include\n#include\n#include\n#include\n#include\n#include\n#include\n#include\n#include\n#include\n#include\n#include\n#include\nusing namespace std;\n#define F(i,m,n) for(int i=m;i\nusing namespace std;\ntypedef long long ll;\n#define maxn 400007//最大遍历到40w 就能找到第1w多个发财数 \nint vis[maxn],p[maxn];\nll fa[maxn];\nvoid init(int n)//线性筛 \n{\n    int pos=0;\n    memset(vis,0,sizeof(vis));\n    int i,j;\n    for(i=2;i v;\n    for(k=2;k<400000;k++)//遍历到40w \n    {\n        if(!vis[k]) continue;//是素数则直接跳过\n        int kt=k;\n        int anssize=0;\n        int ansprime[30];\n        int ansnum[30];\n        for(i=0;i<1000;i++)//用前1000个素数来测试\n        {\n            //这个40w和1000，无脑试了很多次才确定这个范围，各位大佬有什么简便方法请指教 \n            if(kt%p[i]==0)//素数分解，可以参考王道第四章的分解素因数 \n            {\n                ansprime[anssize]=p[i];\n                ansnum[anssize]=0;\n                while(kt%p[i]==0)\n                {\n                    ansnum[anssize]++;\n                    kt/=p[i];\n                }\n                anssize++;\n                if(kt==1) break;\n            }\n        }\n        int su=0;\n        for(i=0;i=8)//是发财数就存起来 \n        {\n            v.push_back(k);\n        }\n    }\n    int vs=v.size();\n\n    cin>>t;\n    while(t--)\n    {\n        cin>>n;\n        cout<<v[n-1]<<endl;\n    }\n    return 0;\n}\n", "Tag": "算法分析"}
{"Answer": "假设有10个元素，你删除第3个，那么从第4个到第10个元素都要向前移动一个位置。因此总共需要移动的元素个数是10-3个，也就是n-i", "Konwledge_Point": "线性规划和规约", "Question": "删除值为x的元素时需要比较元素和移动元素的总次数为\n在一个长度为n的线性表中，删除值为x的元素时需要比较元素和移动元素的总次数为（   ）。\nA．（n+1）/2                             B．n/2\nC．n                                    D．n+1\n解析：假设长度为n的线性表中只有一个值为x的元素，则从第一个元素起到找到值为x(假设为第i个元素）比较i次，删除i后，第i+1个元素到第n个元素都要移动，移动n-(i+1)+1即n-i次，故比较元素和移动元素的总次数为n次。注：以上答案是针对线性表中只有一个值为x的元素\n问一下那个移动n-(i+1)+1怎么来的", "Tag": "算法分析"}
{"Answer": "", "Konwledge_Point": "线性规划和规约", "Question": "pycharm运行不出答案，安装插件了。以前可以运行，代码没有错误\n这是代码\n\n\n\n\n''\n'非线性回归'\n''\n\nimport matplotlib.pyplot as plt\n\nfrom\n scipy.optimize import curve_fit\nimport numpy as np\n\nfrom\n numpy import pi\n\nfrom\n sklearn.metrics import mean_squared_error, r2_score\n\ndef func(x,a,b,c):\n    return a*np.sin(2*pi*x/12+b)+c\n\n\nx\n=np.linspace(1,12,12)\ny_max=[17, 19, 21, 28, 33, 38, 37, 37, 31, 23, 19, 18]\ny_min=[-62, -59, -56, -46, -32, -18, -9, -13, -25, -46, -52, -58]\n\n\nprint\n(\n'时间与最高温度的相关系数矩阵：\\n'\n,np.corrcoef(x,y_max)) #计算相关系数\n\nprint\n(\n'时间与最低温度的相关系数矩阵：\\n'\n,np.corrcoef(x,y_min)) #计算相关系数\n\nplt.figure(1)\nplt.scatter(x,y_max,\ncolor\n=\n'red'\n,marker='.',label='Max')\nplt.scatter(x,y_min,\ncolor\n=\n'blue'\n,marker='*',label='Min')\nplt.legend(\nloc\n=2)\nplt.xlabel(\n'Month'\n)\nplt.ylabel(\n'Temperature'\n)\nplt.show()\n\npopt1,\npcov1\n=curve_fit(func,x,y_max)\n\nprint\n(\n'最高温度的拟合系数='\n,popt1)\npopt2,\npcov2\n=curve_fit(func,x,y_min)\n\nprint\n(\n'最高温度的拟合系数='\n,popt2)\n\n\nxt\n=np.linspace(1,12,120)\n\nyhat1\n=func(xt,*popt1)\n\nyhat2\n=func(xt,*popt2)\n\nyh1\n=func(x,*popt1)\n\nyh2\n=func(x,*popt2)\n\n\ner1\n=mean_squared_error(y_max,yh1) #计算均方差\n\ner2\n=mean_squared_error(y_min,yh2) #计算均方差\n\nprint\n(\n'最高温度的均方差='\n,er1)\n\nprint\n(\n'最高温度的均方差='\n,er2)\n\nrt1\n=r2_score(y_max,yh1) #计算R方\n\nrt2\n=r2_score(y_min,yh2) #计算R方\n\nprint\n(\n'最高温度的R2='\n,rt1)\n\nprint\n(\n'最低温度的R2='\n,rt2)\n\nplt.figure(2)\nplt.scatter(x,y_max,\ncolor\n=\n'red'\n,marker='.',label='Max')\nplt.scatter(x,y_min,\ncolor\n=\n'blue'\n,marker='*',label='Mix')\nplt.xlabel(\n'Month'\n)\nplt.ylabel(\n'Temperature'\n)\nplt.plot(xt,yhat1,\ncolor\n=\n'red'\n,linestyle='dashed',label='Max regression\n')\nplt.plot(xt,yhat2,color='\nblue\n',label='\nMin regression\n')\nplt.legend(loc=2)\nplt.show()\n\n\n", "Tag": "算法分析"}
{"Answer": "你好，我是有问必答小助手，非常抱歉，本次您提出的有问必答问题，技术专家团超时未为您做出解答\n本次提问扣除的有问必答次数，已经为您补发到账户，我们后续会持续优化，扩大我们的服务范围，为您带来更好地服务。", "Konwledge_Point": "线性规划和规约", "Question": "如何使用scipy.optimize.minimize来直接对方程组进行优化求解？\n最近在做基于tdoa的室内目标定位的研究，主要是做chan算法定位方面的东西，但是做了实验之后发现效果不太稳定。师哥发给我一份他改写的scipy.optimize.minimize的函数，说是用这个就可以定出位置，然后让我好好看一看，最好能看懂，如下（注释是我自己写的，不知道都对不对）\n\n\ndef\n \nopt_location\n(\nrange\n, anchors\n):               \n#range是真实测得的toa\n\n\n    \ndef\n \ncon\n():\n        \n# 约束条件 分为eq 和ineq\n\n        \n# eq表示 函数结果等于0 ； ineq 表示 表达式大于等于0\n\n        x1min, x1max, x2min, x2max = -\n5\n, \n15\n, -\n5\n, \n15\n\n        cons = ({\n'type'\n: \n'ineq'\n, \n'fun'\n: \nlambda\n x: x[\n0\n] - x1min},              \n#x[0]-x1min >= 0\n\n                {\n'type'\n: \n'ineq'\n, \n'fun'\n: \nlambda\n x: -x[\n0\n] + x1max},\n                {\n'type'\n: \n'ineq'\n, \n'fun'\n: \nlambda\n x: x[\n1\n] - x2min},\n                {\n'type'\n: \n'ineq'\n, \n'fun'\n: \nlambda\n x: -x[\n1\n] + x2max})\n        \nreturn\n cons                \n# **************我也不知道为什么约束条件要这么设置\n\n\n    \ndef\n \ncost\n(\npos\n):                 \n#***************\n\n        ref = np.sqrt(np.\nsum\n((anchors-pos.reshape(\n1\n,\n2\n))**\n2\n, axis=\n1\n))         \n#anchors为四个基站的位置，pos为要优化的位置\n\n        ref0 = ref[\n1\n:] - ref[\n0\n]\n        ref1 = ref[\n2\n:] - ref[\n1\n]\n        ref2 = ref[\n3\n:] - ref[\n2\n]                            \n#tdoa\n\n        Ri_0 = \nrange\n[\n1\n:] - \nrange\n[\n0\n]\n        Ri_1 = \nrange\n[\n2\n:] - \nrange\n[\n1\n]                \n        Ri_2 = \nrange\n[\n3\n:] - \nrange\n[\n2\n]                        \n#真实测得的tdoa\n\n        \nreturn\n np.\nsum\n((Ri_0 - ref0)**\n2\n) + np.\nsum\n((Ri_1 - ref1)**\n2\n) + np.\nsum\n((Ri_2 - ref2)**\n2\n)    \n#目标函数的目的是要求所估计位置和各基站的tdoa\n\n                                                                                                  \n#和真实测得的tdoa相差最小\n\n\n    x0 = np.array([\n5\n, \n5\n])\n    res = minimize(cost, x0, constraints=con()).x\n    \nreturn\n res\n\n\n\n之后，我的任务参照这个函数的优化方式，把chan算法的核心方程组（线性方程组）用这个优化算法求解出来，如图红框\n\n\n\n这篇关于chan算法的csdn博客的链接是：\nhttps://blog.csdn.net/qq_23947237/article/details/82715784\n\n由于之前没有接触过优化方面的东西，所以我没有思路，师哥说让我找出来目标函数和约束条件，然后依葫芦画瓢就行，但是我还是一头雾水，希望大佬可以帮忙解决！下面是我最后通过chan算法的第一次ls粗略位置估计得出Za0的代码，我的任务就是把这个Za0用优化的方式求出来\n\n\nfrom\n math import *\n\nfrom\n numpy import *\n\nimport\n numpy as np\n\nfrom\n numpy.linalg import inv, qr\n\nBSN\n = \n4\n #基站数目\n\nBS\n=np.array([[\n0\n,\n0\n,\n10\n,\n10\n,-sqrt(\n3\n),dot(- \n0\n.\n5\n,sqrt(\n3\n)),dot(\n0\n.\n5\n,sqrt(\n3\n))],[\n0\n,\n10\n,\n10\n,\n0\n,\n0\n,-\n1\n.\n5\n,-\n1\n.\n5\n]]) #锚点位置\n\nBS\n=BS[:,:BSN] #取前\n4\n列\n\n#BS=multiply(BS,50)   #数值×50 四个基站位置固定\n\n\nprint\n(\n\"-----------------------------BS--------------------------------\"\n)\n\nprint\n(BS)            #看看基站位置\n\nMS\n=np.array([\n10\n,\n4\n]) #设置移动台初始位置\n\nprint\n(\n\"-----------------------------MS--------------------------------\"\n)\n\nprint\n(MS)            #看看移动台位置\n\nR0\n=[]                #R0为四个锚点分别到移动台的距离\n\nR0\n.clear()           #清空R0\n\nfor\n i in range(\n0\n,BSN):\n    \nR0\n.append(sqrt((BS[(\n0\n,i)] - MS[\n0\n]) ** \n2\n + (BS[(\n1\n,i)] - MS[\n1\n])**\n2\n))#计算基站到移动台的距离\n\nR0\n = np.array(R0)    #转换为矩阵\n\nprint\n(\n\"-----------------------------R0--------------------------------\"\n)\n\nprint\n(R0)\n\nNoise\n = \n1\n            #噪声方差\n\nR\n =\n []\n\n\nR\n.clear()\n\na\n = random.random(\n3\n)\n\nr\n = np.zeros(\n3\n)\n\nfor\n i in range(\n0\n,\n3\n):\n    \nr\n[i]=\n2\n*a[i]-\n1\n  #随机生成一个-\n1\n到\n1\n的数\n\nfor\n i in range(\n1\n,BSN):  \n    \nR\n.append(R0[i]-R0[\n0\n]+Noise*r[i-\n1\n])#计算距离差 R2-R1 R3-R1 R4-R1 并加噪声\n\nR\n = np.array(R)     #转换为矩阵\n\nprint\n(\n\"-----------------------------R--------------------------------\"\n)\n\nprint\n(R)            #BSN BS R都有了，开始进行算法部分\n\n\nQ\n = eye(BSN-\n1\n)\n\nprint\n(\n\"-----------------------------Q--------------------------------\"\n)\n\nprint\n(Q)\n\nK1\n = \n0\n\n\nk\n = (BS**\n2\n).sum(\n0\n) #BS各基站的x平方+y平方\n\nprint\n(\n\"-----------------------------K--------------------------------\"\n)\n\nprint\n(k)\n\nGa\n = np.array([[\n1\n.\n0\n,\n1\n.\n0\n,\n1\n.\n0\n],[\n1\n.\n0\n,\n1\n.\n0\n,\n1\n.\n0\n],[\n1\n.\n0\n,\n1\n.\n0\n,\n1\n.\n0\n]])  #弄一个\n3\n*\n3\n的矩阵\n\nfor\n i in range(\n0\n,BSN-\n1\n):\n    \nGa\n[i][\n0\n] = -BS[\n0\n][i+\n1\n]\n    \nGa\n[i][\n1\n] = -BS[\n1\n][i+\n1\n]\n    \nGa\n[i][\n2\n] = -R[i]\n\nprint\n(\n\"-----------------------------Ga--------------------------------\"\n)\n\nprint\n(Ga)\n\nh\n =\n []\n\n\nfor\n i in range(\n0\n,BSN-\n1\n):\n    \nh\n.append(\n0\n.\n5\n*(R[i]**\n2\n-k[i+\n1\n]+K1))\n\nh\n = np.array(h)\n\nprint\n(\n\"-----------------------------h--------------------------------\"\n)\n\nprint\n(h)\n\nZa0\n = inv((Ga.T).dot(inv(Q)).dot(Ga)).dot((Ga.T).dot(inv(Q)).dot(h.T))  #第一次粗略估计的位置，使用这个值来估计B\n\nprint\n(\n\"-----------------------------Za0--------------------------------\"\n)\n\nprint\n(Za0)\n\n\n\n\n主要是不知道思路和怎么写代码，麻烦了，谢谢！", "Tag": "算法分析"}
{"Answer": "有二个地方要改一下，\n\nkernel_size[0],kernel_size[1]->kernel_size，要以元组形式参数传入.\n运行的片断，准确率在98%左右：\n\nEpoch 3/12\n60000/60000 [==============================] - 316s 5ms/step - loss: 0.0807 - accuracy: 0.9753 - val_loss: 0.0363 - val_accuracy: 0.9884\n \n>>> keras.__version__\n'2.3.1'\n>>> tensorflow.__version__\n'2.2.0'", "Konwledge_Point": "线性规划和规约", "Question": "深度学习准确率很低的原因\n\n\n代码如下：\n\n#使用keras训练一个深度神经网络\n#MNIST数据集预处理\n#\nimport numpy as np\nnp.random.seed(1337)\nfrom keras.datasets import mnist\n(X_train,y_train),(X_test,y_test)=mnist.load_data()\nimg_rows,img_cols=28,28\nX_train=X_train.reshape(X_train.shape[0],img_rows,img_cols,1)\nX_test=X_test.reshape(X_test.shape[0],img_rows,img_cols,1)\ninput_shape=(img_rows,img_cols,1)\n#确保矩阵中的数字是【0，1】之间的32位浮点型，而不是【0，255】之间的无符号整数\nX_train=X_train.astype('float32')/255.0\nX_test=X_test.astype('float32')/255.0\n#对训练标签进行独热编码\nfrom keras.utils import np_utils\nn_classes=10\ny_train=np_utils.to_categorical(y_train,n_classes)\ny_test=np_utils.to_categorical(y_test,n_classes)\n#创建一个卷积神经网络\nfrom keras.models import Sequential\nmodel=Sequential()\nfrom keras.layers import Convolution2D\nn_filters=32\nkernel_size=(3,3)\nmodel.add(Convolution2D(n_filters,kernel_size[0],kernel_size[1],padding='valid',input_shape=input_shape))\n#使用一个修正线性单元作为激活函数\nfrom keras.layers import Activation\nmodel.add(Activation('relu'))\n#\nmodel.add(Convolution2D(n_filters,kernel_size[0],kernel_size[1]))\nmodel.add(Activation('relu'))\n#对激活步骤进行池化并添加一个Dropout层\nfrom keras.layers import MaxPooling2D,Dropout\npool_size=(2,2)\nmodel.add(MaxPooling2D(pool_size=pool_size))\nmodel.add(Dropout(0.25))\n#\nfrom keras.layers import Flatten,Dense\nmodel.add(Flatten())\nmodel.add(Dense(128))\nmodel.add(Activation('relu'))\nmodel.add(Dropout(0.5))\nmodel.add(Dense(n_classes))\nmodel.add(Activation('softmax'))\n#\nmodel.compile(loss='categorical_crossentropy',optimizer='adadelta',metrics=['accuracy'])\n#拟合模型\nmodel.fit(X_train,y_train,batch_size=128,epochs=12,verbose=1,validation_data=(X_test,y_test))\nprint(model.evaluate(X_test,y_test,verbose=0))\n\n\n\n结果：\n\n\n", "Tag": "算法分析"}
{"Answer": "望采纳\nimport pandas as pd\nimport matplotlib.pyplot as plt\ndata = pd.read_excel('传感器.xlsx')\nprint(data)\nx=data['Time']\ny=data['Name']\nz=data['State']\nplt.scatter(x,y,s=10,marker='o',color='r',edgecolors='k')\nplt.gcf().autofmt_xdate()\nfor a,b,c in zip(x,y,z):\n    plt.text(x=a,y=b,s=c,fontdict={'family':'Kaiti','color':'k','size':'10'})\n\nplt.show()\n\n", "Konwledge_Point": "线性规划和规约", "Question": "关于python数据可视化的问题！\n\n\nTime,Name,State\n2011/6/14 22:45,M1,ON\n2011/6/15 8:06,M1,OFF\n2011/6/15 8:09,M4,ON\n2011/6/15 8:09,M4,OFF\n2011/6/15 8:14,M4,ON\n2011/6/15 8:14,M4,OFF\n2011/6/15 8:45,M3,ON\n2011/6/15 8:45,M3,OFF\n2011/6/15 10:23,M3,ON\n2011/6/15 10:23,M3,OFF\n2011/6/15 10:24,M2,ON\n2011/6/15 11:12,M2,OFF\n2011/6/15 13:15,M2,ON\n2011/6/15 14:03,M2,OFF\n2011/6/15 14:03,M1,ON\n2011/6/15 15:21,M1,OFF\n2011/6/15 15:23,M2,ON\n2011/6/15 15:46,M2,OFF\n2011/6/15 15:46,M4,ON\n2011/6/15 15:46,M4,OFF\n2011/6/15 16:01,M4,ON\n2011/6/15 16:01,M4,OFF\n2011/6/15 17:05,M2,ON\n2011/6/15 18:12,M2,OFF\n2011/6/15 19:12,M4,ON\n2011/6/15 19:12,M4,OFF\n2011/6/15 19:15,M2,ON\n2011/6/15 20:54,M2,OFF\n2011/6/15 22:35,M1,ON\n2011/6/16 8:07,M1,OFF\n2011/6/16 8:10,M4,ON\n2011/6/16 8:10,M4,OFF\n2011/6/16 8:15,M4,ON\n2011/6/16 8:16,M4,OFF\n2011/6/16 8:47,M3,ON\n2011/6/16 8:47,M3,OFF\n2011/6/16 10:32,M3,ON\n2011/6/16 10:32,M3,OFF\n2011/6/16 10:35,M2,ON\n2011/6/16 11:18,M2,OFF\n2011/6/16 13:17,M2,ON\n2011/6/16 14:05,M2,OFF\n2011/6/16 14:05,M1,ON\n2011/6/16 15:23,M1,OFF\n2011/6/16 15:25,M2,ON\n2011/6/16 15:49,M2,OFF\n2011/6/16 15:47,M4,ON\n2011/6/16 15:47,M4,OFF\n2011/6/16 16:07,M4,ON\n2011/6/16 16:07,M4,OFF\n2011/6/16 17:08,M2,ON\n2011/6/16 18:21,M2,OFF\n2011/6/16 19:18,M4,ON\n2011/6/16 19:18,M4,OFF\n2011/6/16 19:17,M2,ON\n2011/6/16 20:59,M2,OFF\n2011/6/16 22:57,M1,ON\n2011/6/17 8:15,M1,OFF\n\n\n数据集是这样的，根据线性时间序列排列的传感器开关，M1-M4为传感器名称，ON/OFF为开/关，现想用python数据可视化展示为如下图所示，无论ON/OFF都标注在上面\n\n\n\n\n请问该如何实现呢", "Tag": "算法分析"}
{"Answer": "（x,y），（x2， y2）分别表示线性渐变的起始点和结束点，globalCoord 为true 表示两个坐标点是绝对坐标", "Konwledge_Point": "线性规划和规约", "Question": "Echarts饼图x,y,x2,y2是什么含义？\n\n\ncolor: {\n\n        type: 'linear',\n\n        x: 0,\n\n        y: 0,\n\n        x2: .1,\n\n        y2: 1,\n\n        colorStops: [{\n\n            offset: 0, color: '#4dcdfc' // 0% 处的颜色，蓝绿色\n\n        },\n\n        {\n\n            offset: 1, color: '#3F77FE' // 100% 处的颜色，蓝色\n\n        }],\n\n        globalCoord: true // 缺省为 false\n\n    }, \n\n\n\n\n\n普通坐标是下图这种：\n\n\n\n\n\n\n饼图的X坐标的0起点是哪里，往哪个方向是增大的？Y坐标起点是哪里？往哪个方向是增大的？\n\n我尝试了一下，X好像是从左往右递增，Y是从往上下递增，取值范围不是0-1，而是可以更大，而且不能取负数。\n\n另外globalCoord是什么意思？\n\n\n\n完整代码如下：\n\n\n\n\n\n\n\nEChartsTest\n\n\n\n\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "看这篇文章的例子\r\n\r\nhttp://www.blogjava.net/killme2008/archive/2007/09/14/145195.html", "Konwledge_Point": "线性规划和规约", "Question": "线程测试--疑惑\n今天看了下线程中ReentrantLock类，便根据网上的资料写了个测试代码？ \n\n结果发现每次运行速度都不一样很纳闷。。。。。特来求教--哪出问题了？ \n\n另外第一次特别慢许多？\n\nps：网上说  Tim Peierls 用一个简单的线性全等伪随机数生成器（PRNG）构建了一个简单的评测 \n\n    哪位大虾有这评测,能否提供，感激不尽！ \n\n[code=\"java\"]public class ReentrantLockTest {\n\n        private CyclicBarrier barrier;\n\n        private Object objTest;\n\n        private int threadNum;  \n\n\n\n    public ReentrantLockTest(int threadNum) {  \n        barrier = new CyclicBarrier(threadNum + 1);  \n        this.threadNum = threadNum;  \n    }  \n\n    public static void main(String args[]) {  \n        int threadCount = 5000;  \n        ReentrantLockTest test4 = new ReentrantLockTest(threadCount);  \n        test4.objTest = test4.new ReentrantLockUnFair();  \n        test4.test();             \n        ReentrantLockTest test2 = new ReentrantLockTest(threadCount);  \n        test2.objTest = test2.new ReentrantLockUnFair();  \n        test2.test();             \n        ReentrantLockTest test1 = new ReentrantLockTest(threadCount);  \n        test1.objTest = test1.new ReentrantLockFair();  \n        test1.test();  \n        ReentrantLockTest test3 = new ReentrantLockTest(threadCount);  \n        test3.objTest = test3.new SynchronizedTest();  \n        test3.test();  \n    }  \n\n    public void test() {  \n        try {  \n            for (int i = 0; i < threadNum; i++) {  \n                new TestThread(objTest).start();  \n            }  \n            barrier.await(); // 等待所有任务线程创建  \n            long start = System.currentTimeMillis();  \n            barrier.await(); // 等待所有任务计算完成  \n            long end = System.currentTimeMillis();  \n\n           //另外一种写发  \n\n\n\n\n//              long start = System.currentTimeMillis();\n\n//              barrier.await(); // 等待所有任务线程创建\n\n//              barrier.await(); // 等待所有任务计算完成\n\n//              long end = System.currentTimeMillis();    \n\n\n\n            System.out.println(\"花费时间:\" + (end - start) + \"毫秒\");  \n        } catch (Exception e) {  \n            throw new RuntimeException(e);  \n        }  \n    }  \n\n    class TestThread extends Thread {  \n\n        private Object obj;  \n        public TestThread(Object obj) {  \n            this.obj = obj;  \n        }  \n\n        public void run() {  \n            try {  \n                barrier.await();  \n                obj.equals(\"\");  \n                barrier.await();  \n            } catch (Exception e) {  \n                throw new RuntimeException(e);  \n            }  \n        }  \n    }  \n    class ReentrantLockFair {  \n        public boolean equals(Object obj){  \n            final Lock lock = new ReentrantLock(true);  \n            lock.lock();  \n            try {  \n                for(int i=0 ; i<10 ; i++){  \n                }  \n            } finally {  \n                lock.unlock();  \n            }  \n            return true;  \n        }  \n    }  \n    class ReentrantLockUnFair {  \n        public boolean equals(Object obj){  \n            final Lock lock = new ReentrantLock(false);  \n            lock.lock();  \n            try {  \n                for(int i=0 ; i<10 ; i++){  \n                }  \n            } finally {  \n                lock.unlock();  \n            }  \n            return true;  \n        }  \n    }  \n    class SynchronizedTest {  \n        public boolean equals(Object obj){  \n            synchronized (obj) {  \n                for(int i=0 ; i<10 ; i++){  \n                }                     \n            }  \n            return true;  \n        }  \n    }  \n\n\n\n\n}  [/code]\n\n[b]问题补充：[/b]\n\n个人练习，无需求。。。\n\n弄不明白所以来求教，环境。。本机 :cry: \n\n[b]问题补充：[/b]\n\n把94行   synchronized (obj) {   改成了 synchronized (this)\n\n\n\n每次测试都不一样，我就是按那篇修改来的\n\n可测试结果每次不一样，请问我这样的测试类有问题吗？问题在哪呢？", "Tag": "算法分析"}
{"Answer": "第一行年份之类的不需要…", "Konwledge_Point": "线性规划和规约", "Question": "请问我这个是怎么了，plot使用错误，向量长度必须相同，刚开始提取excel数据\n\n\n请问我这个是怎么了，plot使用错误，向量长度必须相同，刚开始提取excel数据", "Tag": "算法分析"}
{"Answer": "是整个rv底部加两个按钮把，还是说是每个item里面加按钮\r\n\r\n—————————————————————————\r\n\r\n既然是在recyclerview的底部加的话，那就应该在该页fragment的底部加两个按钮\r\n\r\n所以我的话会在recyclerview.xml里面加两个按钮\r\n\r\n\r\n```\r\n\n\n\n\n\n\r\n```\r\n![图片说明](https://img-ask.csdn.net/upload/201903/14/1552552914_49259.jpg)", "Konwledge_Point": "线性规划和规约", "Question": "recycview中添加底部按钮问题。\n我就想在这个recycview中底部添加两个按钮\n\n项目地址链接: \nhttps://pan.baidu.com/s/13EzJZ8CrRL6xRiFjUxJXqw\n 提取码: qjet \n\n\n\npublic class CollectFragment extends Fragment {\n\n    public RecyclerView mCollectRecyclerView;//定义RecyclerView\n    //定义以goodsentity实体类为对象的数据集合\n    private ArrayList goodsEntityList = new ArrayList();\n    //自定义recyclerveiw的适配器\n    private CollectRecycleAdapter mCollectRecyclerAdapter;\n\n\n\n    private static ChangeFragment mChange;\n    public static CollectFragment newInstance(ChangeFragment changeFragment) {\n        mChange = changeFragment;\n        Bundle args = new Bundle();\n\n        CollectFragment fragment = new CollectFragment();\n        fragment.setArguments(args);\n        return fragment;\n    }\n    @Nullable\n    @Override\n    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\n        //获取fragment的layout\n       View  view = inflater.inflate(R.layout.recyclerview, container, false);\n        //对recycleview进行配置\n\n\n        return view;\n    }\n\n    @Override\n    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\n        super.onViewCreated(view, savedInstanceState);\n        initRecyclerView(view);\n        //模拟数据\n        initData();\n    }\n\n    /**\n     * TODO 模拟数据\n     */\n    private void initData() {\n        for (int i=0;i<10;i++){\n            GoodsEntity goodsEntity=new GoodsEntity();\n            goodsEntity.setGoodsName(\"模拟数据\"+i);\n            goodsEntity.setGoodsPrice(\"100\"+i);\n            goodsEntityList.add(goodsEntity);\n        }\n    }\n\n    /**\n     * TODO 对recycleview进行配置\n     */\n\n    private void initRecyclerView(View view) {\n        //获取RecyclerView\n        mCollectRecyclerView=view.findViewById(R.id.collect_recyclerView);\n        //创建adapter\n        mCollectRecyclerAdapter = new CollectRecycleAdapter(getActivity(), goodsEntityList);\n        //给RecyclerView设置adapter\n        mCollectRecyclerView.setAdapter(mCollectRecyclerAdapter);\n        //设置layoutManager,可以设置显示效果，是线性布局、grid布局，还是瀑布流布局\n        //参数是：上下文、列表方向（横向还是纵向）、是否倒叙\n        mCollectRecyclerView.setLayoutManager(new LinearLayoutManager(getActivity(), LinearLayoutManager.VERTICAL, false));\n        //设置item的分割线\n        mCollectRecyclerView.addItemDecoration(new DividerItemDecoration(getActivity(),DividerItemDecoration.VERTICAL));\n        //RecyclerView中没有item的监听事件，需要自己在适配器中写一个监听事件的接口。参数根据自定义\n        mCollectRecyclerAdapter.setOnItemClickListener(new CollectRecycleAdapter.OnItemClickListener() {\n            @Override\n            public void OnItemClick(View view, GoodsEntity data) {\n                //此处进行监听事件的业务处理\n                Toast.makeText(getActivity(),\"我是item\",Toast.LENGTH_SHORT).show();\n                mChange.changeAttractionsContent();\n            }\n        });\n    }\n\n}\n\n\n\n\n\n\npublic class CollectRecycleAdapter extends RecyclerView.Adapter {\n    private Context context;\n    private ArrayList goodsEntityList;\n\n    //创建构造函数\n    public CollectRecycleAdapter(Context context, ArrayList goodsEntityList) {\n        //将传递过来的数据，赋值给本地变量\n        this.context = context;//上下文\n        this.goodsEntityList = goodsEntityList;//实体类数据ArrayList\n    }\n\n    /**\n     * 创建viewhodler，相当于listview中getview中的创建view和viewhodler\n     *\n     * @param parent\n     * @param viewType\n     * @return\n     */\n    @Override\n    public myViewHodler onCreateViewHolder(ViewGroup parent, int viewType) {\n        //创建自定义布局\n\n        View itemView = View.inflate(context, R.layout.item_content, null);\n\n        return new myViewHodler(itemView);\n    }\n\n    /**\n     * 绑定数据，数据与view绑定\n     *\n     * @param holder\n     * @param position\n     */\n    @Override\n    public void onBindViewHolder(myViewHodler holder, int position) {\n        //根据点击位置绑定数据\n        GoodsEntity data = goodsEntityList.get(position);\n//        holder.mItemGoodsImg;\n        holder.mItemGoodsName.setText(data.goodsName);//获取实体类中的name字段并设置\n        holder.mItemGoodsPrice.setText(data.goodsPrice);//获取实体类中的price字段并设置\n\n    }\n\n    /**\n     * 得到总条数\n     *\n     * @return\n     */\n    @Override\n    public int getItemCount() {\n        return goodsEntityList.size();\n    }\n\n    //自定义viewhodler\n    class myViewHodler extends RecyclerView.ViewHolder {\n        private ImageView mItemGoodsImg;\n        private TextView mItemGoodsName;\n        private TextView mItemGoodsPrice;\n\n        public myViewHodler(View itemView) {\n            super(itemView);\n            mItemGoodsImg = itemView.findViewById(R.id.tx_news_simple_photos_01);\n            mItemGoodsName =  itemView.findViewById(R.id.tx_news_simple_photos_title);\n            mItemGoodsPrice =  itemView.findViewById(R.id.tx_news_simple_photos_time);\n\n            //点击事件放在adapter中使用，也可以写个接口在activity中调用\n            //方法一：在adapter中设置点击事件\n            itemView.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    //可以选择直接在本位置直接写业务处理\n                    //Toast.makeText(context,\"点击了xxx\",Toast.LENGTH_SHORT).show();\n                    //此处回传点击监听事件\n                    if(onItemClickListener!=null){\n                        onItemClickListener.OnItemClick(v, goodsEntityList.get(getLayoutPosition()));\n                    }\n                }\n            });\n\n        }\n    }\n\n    /**\n     * 设置item的监听事件的接口\n     */\n    public interface OnItemClickListener {\n        /**\n         * 接口中的点击每一项的实现方法，参数自己定义\n         *\n         * @param view 点击的item的视图\n         * @param data 点击的item的数据\n         */\n        public void OnItemClick(View view, GoodsEntity data);\n    }\n\n    //需要外部访问，所以需要设置set方法，方便调用\n    private OnItemClickListener onItemClickListener;\n\n    public void setOnItemClickListener(OnItemClickListener onItemClickListener) {\n        this.onItemClickListener = onItemClickListener;\n    }\n}\n\n\n", "Tag": "算法分析"}
{"Answer": "用python-docx模块读取word文档，\n再用正则表达式提取需要的内容保存为列表再存入CSV\n代码如下：{如果对你有帮助，可以给我个采纳吗，谢谢!! 点击我这个回答右上方的【采纳】按钮}。\n \n\nimport re\nimport csv\n# 我先用字符串代替了，你可以改为用python-docx模块读取word文档，\nwordtext = '''\nIL6,IL10无断点\n\nVersion:1.0 StartHTML:0000000107 EndHTML:0000004359 StartFragment:0000000127 EndFragment:0000004341\n] \"此时变量y 为：\"\n[1] \"IL1b\"\n[1] \"IL1b\"               \"-0.107648809523819\" \"0.339014229656206\"  \"22.7457597598328\"   \"0.103020721767575\"\n[6] \"0.361098065608572\"\n[1] \"breakpoint:\"\n[1] 22.74576\n[1] \"-----------------------(end)-----------------------\"\n[1] \"-----------------------(start)-----------------?------\"\n[1] \"此时变量y 为：\"\n[1] \"IL5\"\n[1] \"IL5\"                 \"0.0393546517271973\"  \"0.507875620155004\"   \"44.9984318923382\"    \"-0.0739995182265517\"\n[6] \"0.25727508099701\"\n[1] \"breakpoint:\"\n[1] 44.99843\n[1] \"-----------------------(end)-----------------------\"\n[1] \"-----------------------(start)-----------------?------\"\n[1] \"此时变量y 为：\"\n[1] \"IL13\"\n[1] \"IL13\"               \"0.376060723360758\"  \"0.0653383537180709\" \"49.9999861005274\"   \"-0.542856877790935\"\n[6] \"0.0169611166504877\"\n[1] \"breakpoint:\"\n[1] 49.99999\n[1] \"-----------------------(end)-----------------------\"\n[1] \"-----------------------(start)-----------------?------\"\n\n'''\n\nli = re.findall(r'\\[1\\]\\s*\"(.+?)\"\\s*\"(.+?)\"\\s*\"(.+?)\"\\s*\"(.+?)\"\\s*\"(.+?)\"\\s*\\[6\\]\\s*\"(.+?)\"',wordtext, re.M)\nprint(*li,sep=\"\\n\")\n\nwith open(\"data.csv\",\"w\",newline=\"\") as fileObj:\n    csv.writer(fileObj).writerows(li)\n\n", "Konwledge_Point": "线性规划和规约", "Question": "请教如何使用python从word中提取数字，存入CSV\n分组：2 打印结果依次为 i,b1,P1,breakpoint,b2,P2\n\n和生物燃料的线性关系\n\n\n\nIL6,IL10无断点\n\n\n\nVersion:1.0 StartHTML:0000000107 EndHTML:0000004359 StartFragment:0000000127 EndFragment:0000004341\n\n] \"此时变量y 为：\"\n\n[1] \"IL1b\"\n\n[1] \"IL1b\"               \"-0.107648809523819\" \"0.339014229656206\"  \"22.7457597598328\"   \"0.103020721767575\"\n\n[6] \"0.361098065608572\"\n\n[1] \"breakpoint:\"\n\n[1] 22.74576\n\n[1] \"-----------------------(end)-----------------------\"\n\n[1] \"-----------------------(start)-----------------?------\"\n\n[1] \"此时变量y 为：\"\n\n[1] \"IL5\"\n\n[1] \"IL5\"                 \"0.0393546517271973\"  \"0.507875620155004\"   \"44.9984318923382\"    \"-0.0739995182265517\"\n\n[6] \"0.25727508099701\"   \n\n[1] \"breakpoint:\"\n\n[1] 44.99843\n\n[1] \"-----------------------(end)-----------------------\"\n\n[1] \"-----------------------(start)-----------------?------\"\n\n[1] \"此时变量y 为：\"\n\n[1] \"IL13\"\n\n[1] \"IL13\"               \"0.376060723360758\"  \"0.0653383537180709\" \"49.9999861005274\"   \"-0.542856877790935\"\n\n[6] \"0.0169611166504877\"\n\n[1] \"breakpoint:\"\n\n[1] 49.99999\n\n[1] \"-----------------------(end)-----------------------\"\n\n[1] \"-----------------------(start)-----------------?------\"\n\n\n\n这个word文件，我想把  \"IL1b\"               \"-0.107648809523819\" \"0.339014229656206\"  \"22.7457597598328\"   \"0.103020721767575\"  这行中的字符串内容提取出来，还有下面那行[6]后面的 \"0.361098065608572\"提取出来，\n\n把这6项存入csv表格的一行中。\n\n然后再依次把\"IL5\" 、\"IL13\"后面的字符串也提出来，存入CSV中，请问，应该如何操作。", "Tag": "算法分析"}
{"Answer": "用代码插入功能啊，指出哪一个函数有问题", "Konwledge_Point": "线性规划和规约", "Question": "c语言数据结构词索引表出了点问题，谁能帮忙看看呀\n#include\n\n#include\n\n#include\n\n#include \n\n#include \n\n\n\n#define OK 1\n\n#define ERROR 0\n\n#define TRUE 1\n\n#define FALSE 0\n\n#define OVERFLOW -2\n\n\n\n#define MaxBookNum 1000 //假设只对1000本书建立索引表(1000)\n\n#define MaxKeyNum 2500 //索引表的最大容量(2500)\n\n#define MaxLineLen 500 //书目串的最大长度(500)\n\n#define MaxWordNum 10 //词表的最大容量\n\n#define MaxWordLength 30 //单词的最大长度\n\n\n\ntypedef int Status;\n\ntypedef int ElemType; //定义链表的数据元素类型为整型\n\ntypedef int Boolean;\n\ntypedef struct\n\n{\n\nchar item[MaxWordNum][MaxWordLength]; //字符串的数组\n\nint last; //词表的长度\n\n}WordListType; //词表的类型（顺序表）\n\ntypedef struct\n\n{\n\nchar \nch; //如果是非空串，则按串长分配存储区，否则ch为NULL\n\nint length; //串长度\n\n}HString;\n\ntypedef struct LNode\n\n{\n\nElemType data;\n\nstruct LNode *next;\n\n}LNode,*Link,*Position;\n\ntypedef struct\n\n{\n\nLink head,tail;\n\nint len;\n\n}LinkList;\n\ntypedef struct\n\n{\n\nHString key; //关键词\n\nLinkList bnolist; //存放书号索引的链表\n\n}IdxTermType; //索引项类型\n\ntypedef struct\n\n{\n\nIdxTermType item[MaxKeyNum+1];\n\nint last;\n\n}IdxListType; //索引表类型\n\n//----------------主要变量--------------\n\nchar buf[MaxLineLen]; //书目串缓冲区\n\nWordListType wdlist; //关键字词表\n\nIdxListType idxlist; //索引表\n\nchar oftenwords[6][10] = {\"an\",\"a\",\"of\",\"and\",\"to\",\"the\"};\n\n/\n******************************声明部分****************************************/\n\n//--------------基本操作---------\n\nvoid InitIdxList (IdxListType \nidxlist);\n\n//初始化操作，置索引表idxlist为空表，且在idxlist.item[0]设一空串\n\nvoid GetLine (FILE *f);\n\n//从文件F读入一个书目信息到书目串缓冲区buf\n\nvoid ExtractKeyWord (int *Num);\n\n//Status ExtractKeyWord(char\n Buffer,WordListType *w,int *Num);\n\n//从buf中提取书名关键词到词表wdlist，书号存入bno\n\nStatus InsIdxList (IdxListType *idxlist,ElemType bno);\n\n//将书号为bno的书名关键词按词典顺序插入索引表idxlist\n\nvoid PutText (FILE *g,IdxListType idxlist);\n\n//将生成的索引表idxlist输出到文件g\n\n//--------------为实现在索引表上进行插入，要先实现下列操作-----------\n\nvoid GetWord (int i,HString *wd);\n\n//用wd返回词表wdist中第i个关键词\n\nint Locate (IdxListType *idxlist,HString wd,Boolean *b);\n\n//在索引表idxlist中查询是否存在与wd相等的关键词。若存在，则返回其在索引表\n\n//中的位置，且b取值TRUE；否则返回插入位置，且b取值FALSE\n\nvoid InsertNewKey(int j,HString wd);\n\n//在索引表idxli的第i项上插入新关键词wd，并初始化书号索引的链表为空表\n\nStatus InsertBook (int i,int bno);\n\n//在索引表idxlist的第i项中插入书号为bno的索引\n\n//------------串的堆分配存储表示-----------\n\nStatus StrAssign(HString *T,char *chars);\n\n//生成一个其值等于串常量chars的串T\n\nint StrCompare(HString S,HString T);\n\n//若S>T，则返回值>0,若S=T，则返回值 = 0，若Snext = NULL;\n\n(*L).head = (*L).tail = p;\n\n(*L).len = 0;\n\nreturn OK;\n\n}\n\nStatus MakeNode(Link *p,ElemType e)\n\n{\n\n*p = (Link)malloc(sizeof(LNode));\n\nif(!(*p))\n\nexit(OVERFLOW);\n\n(*p)->data = e;\n\n(*p)->next = NULL;\n\nreturn OK;\n\n}\n\nStatus Append (LinkList *L,Link s)\n\n{\n\nint i = 1;\n\n(*L).tail->next = s;\n\nwhile(s->next){\n\ns = s->next;\n\ni++;\n\n}\n\n(*L).tail = s;\n\n(*L).len += i;\n\nreturn OK;\n\n}\n\nvoid GetWord(int i,HString *wd)\n\n{\n\nchar *p;\n\np = *(wdlist.item +i);\n\nStrAssign(wd,p); //生成关键字字符串\n\n}\n\nint Locate(IdxListType *idxlist,HString wd,Boolean *b)\n\n{\n\nint i,m;\n\nfor(i = (*idxlist).last-1; ( m=StrCompare((*idxlist).item[i].key,wd) ) >0; --i);\n\n\n\nif(m == 0){ //找到\nb = TRUE;\n\nreturn i;\n\n}\n\nelse{\n\n*b = FALSE;\n\nreturn i+1;\n\n}\n\n}\n\nvoid InsertNewKey(int j,HString wd)\n\n{\n\nint count;\n\nInitList(&idxlist.item[idxlist.last+1].bnolist);\n\nfor(count = idxlist.last-1; count>=j; --count){ //后移索引项\n\nidxlist.item[count+1] = idxlist.item[count];\n\n}\n\nInitString(&idxlist.item[j].key);\n\nStrCopy(&idxlist.item[j].key,wd); //插入新的索引项 //串赋值\n\nInitList(&idxlist.item[j].bnolist); //初始化书号索引表为空表\n\n++idxlist.last;\n\n}\n\nStatus InsertBook (int i,int bookno)\n\n{\n\nLink p;\n\nif(!MakeNode(&p,bookno))\n\nreturn ERROR;\n\nAppend(&idxlist.item[i].bnolist,p);\n\nreturn OK;\n\n}\n\nStatus InsertIdxList(IdxListType *idxlist,int bno)\n\n{\n\nint i,j;\n\nHString wd;\n\nBoolean b;\n\nInitString(&wd);\n\nfor(i= 0;i'A'&& *(buf+i) <= 'Z'){\n\n*(buf+i) -= 'A' - 'a'; //若为大写，则转为小写\n\n}\n\nTempChar[j] = *(buf+i); //把当前字符加入TempChar中//------------\n\nj++;\n\ni++;\n\n} //if\n\nelse{ //若为空字符，则检索当前TempChar中保存的字符串是否为常用词\n\nIgnore = FALSE; //若Ignore为TRUE，则为常用词；为FALSE则不是常用词\n\n\n\nfor(m = 0;m<6;m++){ //查找是否为常用词\n\nif(strcmp(TempChar,oftenwords[m]) == 0){\n\nIgnore = TRUE; //是常用词\n\nbreak;\n\n}//if\n\n}//for\n\nif(Ignore){\n\nfor(m = 0;m<=j;m++)\n\nTempChar[m] = '\\0'; //清空TempChat[]\n\ni++;\n\nj = 0;\n\n}//if\n\nelse{ //不是常用词\n\nfor(m = 0;m<=j;m++) //将该词插入wdlist中\n\nwdlist.item[wdlist.last][m] = TempChar[m];\n\nfor(m = 0;m<=j;m++)\n\nTempChar[m] = '\\0'; //清空TempChat[]\n\nk++;\n\nwdlist.last++;\n\ni++;\n\nj=0;\n\n}//else\n\n}//else\n\n\n\n}//while\n\n}\n\n\n\nvoid GetLine(FILE *f)\n\n{\n\nfgets(buf,MaxLineLen,f);\n\n}\n\n\n\nvoid PutText (FILE \ng,IdxListType idxlist)\n\n{\n\nint i,j,k;\n\nLink p;\n\nfor(i = 0;i<=idxlist.last;i++){\n\nfor(j = 0;jnext;\n\nfprintf(g,\"%03d\",p->data);\n\nputc(' ',g);\n\n}//for\n\nputc('\\n',g);\n\n}//for\n\n}\n\n\n\nvoid PrintFile(FILE *FileName)\n\n{\n\nchar ch;\n\nrewind(FileName);\n\nch = getc(FileName);\n\nwhile(ch != EOF){\n\nputchar(ch);\n\nch = getc(FileName);\n\n}\n\nprintf(\"\\n\");\n\nrewind(FileName);\n\n}\n\n\n\n/*******************************主函数部分**************************************/\n\n\n\nint main()\n\n{\n\nFILE *f,*g;\n\nint ct;\n\nint BookNo;\n\nif((f = fopen(\"BookName.txt\",\"r\")) == NULL){\n\nprintf(\"ERROR in open BookName.txt\\n\");\n\nexit(1);\n\n}\n\nif((g = fopen(\"KeyWordIndex_self.txt\",\"w\"))==NULL){\n\nprintf(\"ERROR in open KeyWordIndex_self.txt\\n\");\n\nexit(1);\n\n}\n\nprintf(\"书单文件：\\n\");\n\nPrintFile(f);\n\nInitIdxList(&idxlist);\n\nWordListType w;\n\nwhile(!feof(f)){\n\nGetLine(f); //读取书单文件中的一行到缓冲区\n\nExtractKeyWord(&BookNo);\n\nInsertIdxList(&idxlist,BookNo);\n\n}\n\nPutText(g,idxlist);\n\nfclose(f);\n\nfclose(g);\n\nprintf(\"\\n结果如下：\\n\");\n\nif((g = fopen(\"KeyWordIndex_self.txt\",\"r\"))==NULL){\n\nprintf(\"ERROR in open KeyWorkIndex_self.txt\\n\");\n\nexit(1);\n\n}\n\nPrintFile(g);\n\nfclose(g);\n\nreturn 0;\n\n}", "Tag": "算法分析"}
{"Answer": "不知道你这个问题是否已经解决, 如果还没有解决的话: 建议你看下这篇博客👉 ：用单链表实现学生信息管理系统如果你已经解决了该问题, 非常希望你能够分享一下解决方案, 以帮助更多的人 ^-^", "Konwledge_Point": "线性规划和规约", "Question": "用线性表实现学生信息表\n这是题目内容：\n\n\n\n用线性数组做一个班级学生档案记录的程序，要求：\n\n\n\n    1）用结构体表示学生记录，包括但不限于：学号、姓名、性别、班级、生日、宿舍、籍贯等信息；\n\n\n\n    2）学生记录用数组存储，按照学号递增顺序记录；\n\n\n\n    3）学生记录插入：插入包括自己在内的10名学生；\n\n\n\n    4）学生记录删除：删除指定位置学生；\n\n\n\n    5）查找学生：根据姓名查找学生在记录中的位序；\n\n\n\n \n\n\n\n\n\n#include  \n#include  \n#include  \n#include  \n#define OK 1  \n#define ERROR 0  \n#define OVERFLOW -2  \n#define MAXSIZE 1000 \n\ntypedef int Status; // 定义函数返回值类型  \n\ntypedef struct\n{\n    int num;\t\t//学号\n    char name[20];\t//姓名\n    char sex;\t\t//性别\n    int age;\t\t//年龄\n    char place[10];\t//籍贯\n    float weight;\t//体重\n    float height;\t//身高\n    int birthday;\t//生日\n    int dormitory;\t//宿舍\n}student;\n\ntypedef student ElemType;\n\ntypedef struct\n{\n    ElemType* elem; // 存储空间的基地址   \n    int length; // 当前长度   \n}SqList;\n\nStatus InitList(SqList* L) // 构造空的顺序表 L   \n{\n    L->elem = (ElemType*)malloc(sizeof(ElemType) * MAXSIZE);\n    if (!L->elem)  exit(OVERFLOW);  \t\t//分配失败退出 \n    L->length = 0;  \t\t//长度为0 \n    return OK;\n}\n\nElemType GetElem(SqList& L, int i) // 访问顺序表，找到 i位置，返回给 e  \n{\n    return L.elem[i];\n}\n\nint Search(SqList& L, char str[]) // 根据名字查找，返回该同学在顺序表中的编号   \n{\n    for (int i = 1;i <= L.length;i++)  \t//查找成功，返回序号 i+1\n    {\n        if (strcmp(L.elem[i].name, str) == 0)\n            return i;\n    }\n    return 0;\n}\n\nStatus ListInsert(SqList& L, int i, ElemType e) // 在 i位置插入某个学生的信息   \n{\n    if ((i < 1) || (i > L.length + 1)) return ERROR;\n    if (L.length == MAXSIZE)   return ERROR;\n    for (int j = L.length;j >= i;j--)\n    {\n        L.elem[j + 1] = L.elem[j];  \t//插入位置及之后的元素后移\n    }\n    L.elem[i] = e;  \t\t//将新元素e放入第i个位置\n    ++L.length;\n    return OK;\n}\n\nStatus ListDelete(SqList& L, int i) // 在顺序表中删除 i位置的学生信息   \n{\n    if ((i < 1) || (i > L.length))   return ERROR;\n    for (int j = i;j <= L.length;j++)\n    {\n        L.elem[j] = L.elem[j + 1];  \t//被删除元素之后的元素前移\n    }\n    --L.length;  \t//长度减一 \n    return OK;\n}\n\nvoid Input(ElemType* e)  \t\t//输入 \n{\n    printf(\" 学号:\");\n    scanf_s(\"%d\", &e->num);\n    printf(\" 姓名:\");\n    scanf_s(\"%s\", e->name, 4);\n    printf(\" 性别:\");\n    scanf_s(\"%s\", &e->sex, 3);\n    printf(\" 年龄:\");\n    scanf_s(\"%d\", &e->age);\n    printf(\" 籍贯:\");\n    scanf_s(\"%s\", e->place, 20);\n    printf(\" 体重:\");\n    scanf_s(\"%f\", &e->weight);\n    printf(\" 身高:\");\n    scanf_s(\"%f\", &e->height);\n    printf(\" 生日:\");\n    scanf_s(\"%d\", &e->birthday);\n    printf(\" 宿舍:\");\n    scanf_s(\"%d\", &e->dormitory);\n    printf(\"输入完成\\n\\n\");\n}\n\nvoid Output(ElemType& e)  \t\t//输出 \n{\n    printf_s(\"学号：%d 姓名：%s 性别：%s 年龄：%d 籍贯：%s 体重：%f 身高：%f 生日：%d 宿舍：%d\", e.num, &e.name, e.sex, e.age, &e.place, e.weight, e.height, e.birthday, e.dormitory);\n\n}\n\nint main()\n{\n    SqList L ;\n    ElemType a, b, c, d;\n    printf(\"1. 构造顺序表\\n\");\n    printf(\"2. 录入指定人数的学生信息\\n\");\n    printf(\"3. 显示学生表中的所有信息\\n\");\n    printf(\"4. 根据姓名查找该学生，并返回学号和成绩\\n\");\n    printf(\"5. 根据某指定位置显示该学生信息\\n\");\n    printf(\"6. 在指定位置插入学生信息\\n\");\n    printf(\"7. 在指定位置删除学生信息\\n\");\n    printf(\"8. 统计学生个数\\n\");\n    printf(\"0. 退出\\n\");\n    int x = 0, choose;\n    while (1)\n    {\n        printf(\"请输入你要选择的功能前的序号:\");\n        scanf_s(\"%d\", &choose);\n        if (choose == 0)   break;\n        switch (choose)\n        {\n        case 1:\n            if (InitList(&L))\n                printf(\"成功建立顺序表\\n\");\n            else\n                printf(\"顺序表建立失败\\n\");\n            break;\n        case 2:\n            printf(\"请输入要录入学生的人数:\");\n            scanf_s(\"%d\", &x);\n            for (int i = 1;i <= x;i++)\n            {\n                printf(\"第%d个学生:\\n\", i);\n                Input(&L.elem[i]);\n            }\n            L.length = x;\n            break;\n        case 3:\n            for (int i = 1;i <= x;i++)\n            {\n                a = GetElem(L, i);\n                Output(a);\n            }\n            break;\n        case 4:\n            char s[20];\n            printf(\"请输入要查找的学生姓名:\");\n            scanf_s(\"%s\", s, 4);\n            if (Search(L, s))\n                Output(L.elem[Search(L, s)]);\n            else\n                printf(\"对不起，查无此人\\n\");\n            printf_s(\"\");\n            break;\n        case 5:\n            printf_s(\"请输入要查询的位置:\");\n            int id1;\n            scanf_s(\"%d\", &id1);\n            b = GetElem(L, id1);\n            Output(b);\n            break;\n        case 6:\n            printf(\"请输入要插入的位置:\");\n            int id2;\n            scanf_s(\"%d\", &id2);\n            printf(\"请输入学生信息:\\n\");\n            Input(&c);\n            if (ListInsert(L, id2, c))\n            {\n                x++;\n                printf(\"插入成功\\n\");\n            }\n            else\n            {\n                printf(\"插入失败\\n\");\n            }\n            break;\n        case 7:\n            printf(\"请输入要删除的位置:\");\n            int id3;\n            scanf_s(\"%d\", &id3);\n            if (ListDelete(L, id3))\n            {\n                x--;\n                printf(\"删除成功\\n\");\n            }\n            else\n            {\n                printf(\"删除失败\\n\");\n            }\n            break;\n        case 8:\n            printf(\"已录入的学生个数为:%d\\n\\n\", L.length);\n            break;\n        }\n    }\n    printf(\"\\n\\n请按任意键退出\\n\\n\");\n    return 0;\n}\n\n\n\n    可以正常编译，选择1和选择2可以使用，但是其他选择在运行的时候会出问题，不知道怎么修改。\n\n\n\n    运行选择三的时候会出现（引发了异常: 读取访问权限冲突），不知道为什么", "Tag": "算法分析"}
{"Answer": "class equation\r\n{\r\npublic:\r\n    int n;\r\n    double ** A = new double *[n];          //系数阵\r\n    double *b = new double[n];              //常数项\r\n    double *x = new double[n];\r\n    void solve();\r\n    void DisplayEquation();\r\n    void DisplayResult();\r\n    void input();\r\n    void output();\r\n    equation()\r\n    {\r\n        n = 0;\r\n    }\r\n    equation(int a)\r\n    {\r\n        n = a;\r\n    }\r\n};\r\n\r\n两点问题：\r\n1）构造函数equation(){n=0;}会生成一个长度为0的数组，编译不会抛错，也会返回一个正常的数组指针，但是如果修改了指针会\r\n     导致内存被破坏，恰巧这块内存正在使用，就会抛出异常，也就会崩！\r\n2）建议申请的内存最好在析构函数内释放掉。。。", "Konwledge_Point": "线性规划和规约", "Question": "c++程序调试了好久总是出错，好像是指针的问题\n    初学，想实现n阶线性方程组求解。从txt文件中读入A矩阵和b，求解后将结果输出到另一个txt文件。\n    调试过程很奇怪，有时不会有问题，有时会报错。我单步执行时会在main函数return时出现断点，百度了一下，好像跟内存溢出什么的有关，没能看得很明白。请问是哪里出了问题。\n\n\n\n\n #include \n#include \n#include \n#include \nusing namespace std;\n\nclass equation\n{\npublic:\n    int n;\n    double ** A = new double *[n];          //系数阵\n    double *b = new double[n];              //常数项\n    double *x = new double[n];\n    void solve();\n    void DisplayEquation();\n    void DisplayResult();\n    void input();\n    void output();\n    equation()\n    {\n        n = 0;\n    }\n    equation(int a)\n    {\n        n = a;\n    }\n};\n\nint CountLines()                                                    //统计系数阵阶数\n{\n    int n = 0;\n    string temp;\n    fstream f;\n    f.open(\"equation.txt\", ios::in);\n    if (f.fail())\n    {\n        cout << \"打开文件失败\\n\";\n    }\n    else\n    {\n        while (getline(f, temp))\n        {\n            if (temp[0] == '#')\n                break;\n            n++;\n        }\n    }\n    f.close();\n    return n;\n}\n\nvoid equation::input()\n{\n    int t, i = 0, j = 0;\n    string temp;\n    fstream f;\n    f.open(\"equation.txt\", ios::in);\n    while (getline(f, temp, '   '))                     //从文件读入系数矩阵到A中\n    {\n        t = temp.find('\\n');\n        if (t > -1)\n            temp.erase(t, sizeof('\\n'));\n        if (temp[0] == '#')\n            break;\n        else\n        {\n            if (j == n - 1)\n            {\n                A[i][j] = atof(temp.c_str());\n                j = 0;\n                i++;\n            }\n            else\n            {\n                A[i][j] = atof(temp.c_str());\n                j++;\n            }\n        }\n    }\n    i = 0;\n    while (getline(f, temp, '   ') && !f.eof())         //从文件读入常数项到b中\n    {\n        t = temp.find('\\n');\n        if (t > -1)\n            temp.erase(t, sizeof('\\n'));\n        b[i] = atof(temp.c_str());\n        i++;\n    }\n//  f.close();  //这里加这东西居然会报错\n}\n\nvoid equation::DisplayEquation()                            //显示系数矩阵与常数向量\n{\n    cout << \"系数矩阵为:\\n\";\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n        {\n            if (j == n - 1)\n                cout << A[i][j] << \"\\t\\n\";\n            else\n                cout << A[i][j] << \"\\t\";\n        }\n    cout << \"\\n常数项为:\\n\";\n\n    for (int i = 0; i < n; i++)\n        cout << b[i] << \"\\n\";\n}\n\nvoid equation::solve()                                              //求解方程，将解存入x中\n{\n    double c;\n    //================================forward elimination==================================\n    for (int k = 0; k < n; k++)\n    {\n        for (int i = k + 1; i < n; i++)\n        {\n            c = A[i][k] / A[k][k];\n            for (int j = k; j < n; j++)\n                A[i][j] = A[i][j] - A[k][j] * c;\n            b[i] = b[i] - b[k] * c;\n        }\n    }\n    //==========================back substitution==========================================\n    double sum;\n    x[n - 1] = b[n - 1] / A[n - 1][n - 1];\n    for (int i = n - 2; i >= 0; i--)\n    {\n        sum = 0;\n        for (int j = n - 1; j >= i + 1; j--)\n            sum = sum + A[i][j] * x[j];\n        x[i] = (b[i] - sum) / A[i][i];\n    }\n}\n\nvoid equation::DisplayResult()\n{\n    cout << \"方程的解为：\\n\";\n    for (int i = 0; i < n; i++)\n        cout << x[i] << \"   \";\n    cout << endl;\n}\n\nvoid equation::output()\n{\n    fstream r;\n    r.open(\"result.txt\", ios::out);\n    if (r.fail())\n    {\n        cout << \"打开文件失败\\n\";\n        exit(1);\n    }\n    for (int i = 0; i < n; i++)\n    {\n        r << \"X\" << i << \"=\" << x[i] << \"\\n\";\n    }\n    r.close();\n}\n\nint main()\n{\n    int N, j = 0;\n    string temp, a;\n    N = CountLines();\n    equation e1(N);\n    for (int i = 0; i < N; i++)\n        e1.A[i] = new double[N];\n    e1.input();\n    //  e1.DisplayEquation();\n    e1.solve();\n//  e1.DisplayEquation();                               //上三角矩阵\n//  e1.DisplayResult();\n    e1.output();\n    return 0;\n}\n\n\n\n\n\n刚注册的账号，没有C币。。。", "Tag": "算法分析"}
{"Answer": "字符串输出格式不正确，字符串变量本身就是指针，不应该再取地址，单个字符的输出格式是“%c”\nprintf_s(\"学号：%d 姓名：%s 性别：%c 年龄：%d 籍贯：%s 体重：%f 身高：%f 生日：%d 宿舍：%d\", e.num, e.name, e.sex, e.age, e.place, e.weight, e.height, e.birthday, e.dormitory);", "Konwledge_Point": "线性规划和规约", "Question": "线性表实现学生信息表，运行时出现问题不知道怎么解决\n这是题目内容：\n\n\n\n用线性数组做一个班级学生档案记录的程序，要求：\n\n\n\n    1）用结构体表示学生记录，包括但不限于：学号、姓名、性别、班级、生日、宿舍、籍贯等信息；\n\n\n\n    2）学生记录用数组存储，按照学号递增顺序记录；\n\n\n\n    3）学生记录插入：插入包括自己在内的10名学生；\n\n\n\n    4）学生记录删除：删除指定位置学生；\n\n\n\n    5）查找学生：根据姓名查找学生在记录中的位序；\n\n\n\n\n\n\n#include  \n#include  \n#include  \n#include  \n#define OK 1  \n#define ERROR 0  \n#define OVERFLOW -2  \n#define MAXSIZE 1000 \ntypedef int Status; // 定义函数返回值类型  \ntypedef struct\n{\n    int num;\t\t//学号\n    char name[20];\t//姓名\n    char sex;\t\t//性别\n    int age;\t\t//年龄\n    char place[10];\t//籍贯\n    float weight;\t//体重\n    float height;\t//身高\n    int birthday;\t//生日\n    int dormitory;\t//宿舍\n}student;\ntypedef student ElemType;\ntypedef struct\n{\n    ElemType* elem; // 存储空间的基地址   \n    int length; // 当前长度   \n}SqList;\nStatus InitList(SqList* L) // 构造空的顺序表 L   \n{\n    L->elem = (ElemType*)malloc(sizeof(ElemType) * MAXSIZE);\n    if (!L->elem)  exit(OVERFLOW);  \t\t//分配失败退出 \n    L->length = 0;  \t\t//长度为0 \n    return OK;\n}\nElemType GetElem(SqList& L, int i) // 访问顺序表，找到 i位置，返回给 e  \n{\n    return L.elem[i];\n}\nint Search(SqList& L, char str[]) // 根据名字查找，返回该同学在顺序表中的编号   \n{\n    for (int i = 1;i <= L.length;i++)  \t//查找成功，返回序号 i+1\n    {\n        if (strcmp(L.elem[i].name, str) == 0)\n            return i;\n    }\n    return 0;\n}\nStatus ListInsert(SqList& L, int i, ElemType e) // 在 i位置插入某个学生的信息   \n{\n    if ((i < 1) || (i > L.length + 1)) return ERROR;\n    if (L.length == MAXSIZE)   return ERROR;\n    for (int j = L.length;j >= i;j--)\n    {\n        L.elem[j + 1] = L.elem[j];  \t//插入位置及之后的元素后移\n    }\n    L.elem[i] = e;  \t\t//将新元素e放入第i个位置\n    ++L.length;\n    return OK;\n}\nStatus ListDelete(SqList& L, int i) // 在顺序表中删除 i位置的学生信息   \n{\n    if ((i < 1) || (i > L.length))   return ERROR;\n    for (int j = i;j <= L.length;j++)\n    {\n        L.elem[j] = L.elem[j + 1];  \t//被删除元素之后的元素前移\n    }\n    --L.length;  \t//长度减一 \n    return OK;\n}\nvoid Input(ElemType* e)  \t\t//输入 \n{\n    printf(\" 学号:\");\n    scanf_s(\"%d\", &e->num);\n    printf(\" 姓名:\");\n    scanf_s(\"%s\", e->name, 4);\n    printf(\" 性别:\");\n    scanf_s(\"%s\", &e->sex, 3);\n    printf(\" 年龄:\");\n    scanf_s(\"%d\", &e->age);\n    printf(\" 籍贯:\");\n    scanf_s(\"%s\", e->place, 20);\n    printf(\" 体重:\");\n    scanf_s(\"%f\", &e->weight);\n    printf(\" 身高:\");\n    scanf_s(\"%f\", &e->height);\n    printf(\" 生日:\");\n    scanf_s(\"%d\", &e->birthday);\n    printf(\" 宿舍:\");\n    scanf_s(\"%d\", &e->dormitory);\n    printf(\"输入完成\\n\\n\");\n}\nvoid Output(ElemType& e)  \t\t//输出 \n{\n    printf_s(\"学号：%d 姓名：%s 性别：%s 年龄：%d 籍贯：%s 体重：%f 身高：%f 生日：%d 宿舍：%d\", e.num, &e.name, e.sex, e.age, &e.place, e.weight, e.height, e.birthday, e.dormitory);\n}\nint main()\n{\n    SqList L ;\n    ElemType a, b, c, d;\n    printf(\"1. 构造顺序表\\n\");\n    printf(\"2. 录入指定人数的学生信息\\n\");\n    printf(\"3. 显示学生表中的所有信息\\n\");\n    printf(\"4. 根据姓名查找该学生，并返回学号和成绩\\n\");\n    printf(\"5. 根据某指定位置显示该学生信息\\n\");\n    printf(\"6. 在指定位置插入学生信息\\n\");\n    printf(\"7. 在指定位置删除学生信息\\n\");\n    printf(\"8. 统计学生个数\\n\");\n    printf(\"0. 退出\\n\");\n    int x = 0, choose;\n    while (1)\n    {\n        printf(\"请输入你要选择的功能前的序号:\");\n        scanf_s(\"%d\", &choose);\n        if (choose == 0)   break;\n        switch (choose)\n        {\n        case 1:\n            if (InitList(&L))\n                printf(\"成功建立顺序表\\n\");\n            else\n                printf(\"顺序表建立失败\\n\");\n            break;\n        case 2:\n            printf(\"请输入要录入学生的人数:\");\n            scanf_s(\"%d\", &x);\n            for (int i = 1;i <= x;i++)\n            {\n                printf(\"第%d个学生:\\n\", i);\n                Input(&L.elem[i]);\n            }\n            L.length = x;\n            break;\n        case 3:\n            for (int i = 1;i <= x;i++)\n            {\n                a = GetElem(L, i);\n                Output(a);\n            }\n            break;\n        case 4:\n            char s[20];\n            printf(\"请输入要查找的学生姓名:\");\n            scanf_s(\"%s\", s, 4);\n            if (Search(L, s))\n                Output(L.elem[Search(L, s)]);\n            else\n                printf(\"对不起，查无此人\\n\");\n            printf_s(\"\");\n            break;\n        case 5:\n            printf_s(\"请输入要查询的位置:\");\n            int id1;\n            scanf_s(\"%d\", &id1);\n            b = GetElem(L, id1);\n            Output(b);\n            break;\n        case 6:\n            printf(\"请输入要插入的位置:\");\n            int id2;\n            scanf_s(\"%d\", &id2);\n            printf(\"请输入学生信息:\\n\");\n            Input(&c);\n            if (ListInsert(L, id2, c))\n            {\n                x++;\n                printf(\"插入成功\\n\");\n            }\n            else\n            {\n                printf(\"插入失败\\n\");\n            }\n            break;\n        case 7:\n            printf(\"请输入要删除的位置:\");\n            int id3;\n            scanf_s(\"%d\", &id3);\n            if (ListDelete(L, id3))\n            {\n                x--;\n                printf(\"删除成功\\n\");\n            }\n            else\n            {\n                printf(\"删除失败\\n\");\n            }\n            break;\n        case 8:\n            printf(\"已录入的学生个数为:%d\\n\\n\", L.length);\n            break;\n        }\n    }\n    printf(\"\\n\\n请按任意键退出\\n\\n\");\n    return 0;\n}\n\n\n\n\n可以正常编译，选择1和选择2可以使用，但是其他选择在运行的时候会出问题，不知道怎么修改。\n\n\n\n    运行选择三的时候会出现（引发了异常: 读取访问权限冲突），不知道为什么\n\n\n\n其他选择还没用，不知道怎么改", "Tag": "算法分析"}
{"Answer": "首先题主的epoch，matlab比pytorch多了600轮，一个1k，一个400，另外就是lr，对不上。然后可能还有其它值，没有细看了。那一个步长小，学习慢，轮数少，和一个相反的，没有可比性，可能一个欠拟合，一个过拟合", "Konwledge_Point": "线性规划和规约", "Question": "matlab与pytorch拟合效果对比\n为什么对于一个很简单的非线性拟合问题，就一个隐藏层+激活函数，pytorch与matlab对比效果差很多？\n\n\nimport torch\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimport scipy.io as scio\n\nfrom\n torch.utils.data import random_split\n\nfrom\n torch.optim import lr_scheduler\n\n\nfrom\n torch.optim import lr_scheduler\n\n\nfrom\n sklearn.metrics import r2_score\n\nimport os\nos.environ[\n'KMP_DUPLICATE_LIB_OK'\n]=\n'True'\n\n\n\ndef mse_cal(data_loader, net):\n    \n\"\"\n\"mse计算函数\n    \n    :param data_loader：加载好的数据\n    :param net: 模型\n    :return：根据输入的数据，输出其MSE计算结果\n    \"\n\"\"\n\n    data = data_loader.dataset                # 还原Dataset类\n    X = data[:][0]                            # 还原数据的特征\n    y = data[:][1]                            # 还原数据的标签\n    yhat = net(X)\n    return F.mse_loss(yhat, y)\n\n\n\n\n\n\nclass GenData(Dataset):\n    def __init__(self, features, labels):           \n        self.features = features                    \n        self.labels = labels                       \n        self.lens = len(features)                  \n\n    def __getitem__(self, index):\n        return self.features[index,:],self.labels[index]    \n\n    def __len__(self):\n        return self.lens\n    \n\n    \n    \n    \ndef split_loader(features, labels, \nbatch_size\n=10, \nrate\n=0.7):\n    data = GenData(features, labels) \n    num_train = int(data.lens * rate)\n    num_test = data.lens - num_train\n    data_train, data_test = random_split(data, [num_train, num_test])\n    train_loader = DataLoader(data_train, \nbatch_size\n=batch_size, \nshuffle\n=\nTrue\n)\n    test_loader = DataLoader(data_test, \nbatch_size\n=batch_size, \nshuffle\n=\nFalse\n)\n    return(train_loader, test_loader)\n\n\nclass Model(nn.Module):\n    def __init__(self,\nin_features\n=2,hidden1=6,out_features=1,BN_Model=None,act_fun=torch.relu):\n        super(Model,self).__init__()\n        self.\nlinear1\n=nn.Linear(in_features,hidden1)\n        self.\nnormalize1\n=nn.BatchNorm1d(hidden1)\n        self.\nlinear2\n=nn.Linear(hidden1,out_features)\n        self.\nBN_Model\n=BN_Model\n        self.\nact_fun\n=act_fun\n    def forward(self,x):\n        \nif\n self.\nBN_Model\n=='pre':\n            \nx\n=self.act_fun(self.normalize1(self.linear1(x)))\n            \noutput\n=self.linear2(x)\n        \nif\n self.\nBN_Model\n==None:\n            \nx\n=self.act_fun(self.linear1(x))\n            \noutput\n=self.linear2(x)\n        \n        return output\n\n\ntorch.manual_seed(420)\n\ninput_\n=torch.rand(size=(2000,2))\noutput_=(input_[:,0]*input_[:,1]).reshape(-1,1)\n\n\ntorch.manual_seed(420)\ntrain_loader,\ntest_loader\n=split_loader(input_,output_,batch_size=50,rate=0.75)\n\n\ntorch.manual_seed(24)\n\nnet1\n=Model(BN_Model='pre',hidden1=8,act_fun=torch.sigmoid)\n\n\ndef fit_rec_sc(net,\n              criterion,\n              optimizer,\n              train_data,\n              test_data,\n              scheduler,\n              \nepochs\n=3,\n              \ncla\n=\nFalse\n,\n              \neva\n=mse_cal):\n    train_l=[]\n    test_l=[]\n    \n    \nfor\n epoch \nin\n range(epochs):\n        net.train()\n        \nfor\n X,y \nin\n train_data:\n            \nif\n \ncla\n==True:\n                \ny\n=y.flatten().long()\n            \nyhat\n=net.forward(X)\n            \nloss\n=criterion(yhat,y)\n            optimizer.zero_grad()\n            loss.backward()\n            optimizer.\nstep\n()\n        scheduler.\nstep\n()\n        net.eval()\n        train_l.append(eva(train_data,net).detach())\n        test_l.append(eva(test_data,net).detach())\n    return train_l,test_l\n\n\n\nlr_lambda\n=lambda epoch:0.95*\n*e\npoch\n\n\noptimizer\n=torch.optim.Adam(net1.parameters(),lr=0.001)\n\n\nscheduler\n=lr_scheduler.LambdaLR(optimizer,lr_lambda)\n\n\ntrain_l,\ntest_l\n=fit_rec_sc(net=net1,\n                         \ncriterion\n=nn.MSELoss(),\n                         \noptimizer\n=optimizer,\n                         \ntrain_data\n=train_loader,\n                         \ntest_data\n=test_loader,\n                         \nscheduler\n=scheduler,\n                         \nepochs\n=400,\n                         \ncla\n=\nFalse\n,\n                         \neva\n=mse_cal)\n\n\nplt.plot(train_l,\nlabel\n=\n'train_mse'\n)\nplt.plot(test_l,\nlabel\n=\n'test_mse'\n)\nplt.xlabel(\n'epochs'\n)\nplt.ylabel(\n'MSE'\n)\nplt.legend(\nloc\n=1)\nplt.show()\n\n\nmse_cal(test_loader,net1)\n\n\n\nyhat\n=net1.forward(test_loader.dataset[:][0])\n\ny\n=test_loader.dataset[:][1]\n\nplt.plot(yhat.detach(),\n'bo-'\n,\nlabel\n=\n'pred'\n)\nplt.plot(y,\n'ro-'\n,\nlabel\n=\n'real'\n)\n\n\nr2_score(y.detach().numpy(),yhat.detach().numpy())\n\n\n\nmatlab代码\n\n\n\n\n\n%% 初始化\n\nclear\nclose all\nclc\n\n\n%% 读取数据\n\ninput=\nrand\n(\n2\n,\n2000\n);\noutput=input(\n1\n,:).*input(\n2\n,:);\n\n\n%% 训练集、测试集\n\ninput_train = input(:,\n1\n:\n1500\n);\noutput_train =output(\n1\n:\n1500\n);\ninput_test =input(:,\n1501\n:\nend\n);\noutput_test =output(\n1501\n:\nend\n);\n\n\n%% 数据归一化\n\n[inputn,inputps]=mapminmax(input_train,\n0\n,\n1\n);\n[outputn,outputps]=mapminmax(output_train);\ninputn_test=mapminmax(\n'apply'\n,input_test,inputps);\n\n\n%% 构建BP神经网络\n\nnet=newff(inputn,outputn,\n8\n);\n\n\n% 网络参数\n\nnet.trainParam.epochs=\n1000\n;         \n% 训练次数\n\nnet.trainParam.lr=\n0.01\n;                   \n% 学习速率\n\nnet.trainParam.goal=\n0.0000000001\n;        \n% 训练目标最小误差\n\n\n% net.dividefcn='';\n\n\n%% BP神经网络训练\n\nnet=train(net,inputn,outputn);\n\n\n%% BP神经网络测试\n\nan=sim(net,inputn_test); \n%用训练好的模型进行仿真 \n\ntest_simu=mapminmax(\n'reverse'\n,an,outputps); \n% 预测结果反归一化\n\n\nerror=test_simu-output_test;      \n%预测值和真实值的误差\n\n\n\n\n%y1为预测值 y为实际值\n\nR2=\n1\n - (sum((output_test- test_simu).^\n2\n) / sum((output_test - \nmean\n(output_test)).^\n2\n));\n\n\n\n%%真实值与预测值误差比较\n\n\n\ndisp\n([\n'r2误差为: '\n,num2str(R2)])\n\n\nfigure\n(\n1\n)\n\nplot\n(output_test,\n'bo-'\n)\n\nhold\n on\n\nplot\n(test_simu,\n'r*-'\n)\n\nhold\n on\n\nplot\n(error,\n'square'\n,\n'MarkerFaceColor'\n,\n'b'\n)\n\nlegend\n(\n'期望值'\n,\n'预测值'\n,\n'误差'\n)\nxlabel(\n'数据组数'\n),ylabel(\n'值'\n),title(\n'测试集预测值和期望值的误差对比'\n),set(gca,\n'fontsize'\n,\n12\n)\n\n%计算误差\n\n[~,len]=\nsize\n(output_test);\nMAE1=sum(\nabs\n(error./output_test))/len;\nMSE1=error*error'/len;\nRMSE1=MSE1^(\n1\n/\n2\n);\n\ndisp\n([\n'-----------------------误差计算--------------------------'\n])\n\ndisp\n([\n'平均绝对误差MAE为：'\n,num2str(MAE1)])\n\ndisp\n([\n'均方误差MSE为：       '\n,num2str(MSE1)])\n\ndisp\n([\n'均方根误差RMSE为：  '\n,num2str(RMSE1)])\n\n\n\n\n\n\n\n\n\n分别为pytorch/matlab效果图", "Tag": "算法分析"}
{"Answer": "你好，我是有问必答小助手，非常抱歉，本次您提出的有问必答问题，技术专家团超时未为您做出解答 本次提问扣除的有问必答次数，已经为您补发到账户，我们后续会持续优化，扩大我们的服务范围，为您带来更好地服务。", "Konwledge_Point": "线性规划和规约", "Question": "我只画出了绿色部分的图片，中间的参数曲线部分我没有画出来，不知道是哪里错误了\n天文学家要求你使用线性模型将数据放入太阳系外信号txt(参见黑板)中。该数据文件的第一列和第二列分别给出ti和vi，即观测时间(天)和相对速度(米/秒)。\n运用此模型 f0(t; β0, β1) = β0 sin(ωt) + β1 cos(ωt), β0和β1为参数，ω = 2π/(34.6天)，设X是N × 2矩阵，有一行[sin(ωti)， cos(ωti)]。构造X(作为数组)，并解常规方程 (X^TX)β = X^T y\n求出最佳拟合参数β = [β0， β1]^T\n绘制数据集和最佳拟合模型。它看起来应该有点像以下的图\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nxs,ys = np.loadtxt(\n'extrasolar_signal.txt'\n,unpack = True)\nplt.\nplot\n(xs,ys, \n'g+'\n)\nplt.xlabel(\n'$x$'\n)\nplt.ylabel(\n'$y$'\n)\nA = np.\ndot\n(X.transpose(), X)\nb = np.\ndot\n(X.transpose(), ys)\npar = np.linalg.solve(A, b)\nprint(\n\"Beta parameters: \"\n, par)\n\nn = \n100\n\nxline = np.\nlinspace\n(\n-4.1\n,\n4.1\n,n)\nyline = np.\nzeros\n(n)\n\nfor\n \ni\n in range(m):\n    yline += par[\ni\n]*xline**\ni\n\nplt.\nplot\n(xs, ys, \n'.'\n);\nplt.\nplot\n(xline, yline, \n'r-'\n, lw=\n3\n);\n\nfrom scipy.optimize import curve_fit\nw = \n2\n*np.\npi\n/\n34.6\n\ndef f0(t,b0,b1,w):\n    \nreturn\n b0*np.\nsin\n*w*t + b1*np.\ncos\n*w*t\nA = np.\ndot\n(X.transpose(), X)\nb = np.\ndot\n(X.transpose(), ys)\npar = np.linalg.solve(A, b)\nprint(\n\"Beta parameters: \"\n, par)\n\nn = \n100\n\nxline = np.\nlinspace\n(\n-4.1\n,\n4.1\n,n)\nyline = np.\nzeros\n(n)\n\nfor\n \ni\n in range(m):\n    yline += par[\ni\n]*xline**\ni\n\nplt.\nplot\n(xs, ys, \n'.'\n);\nplt.\nplot\n(xline, yline, \n'r-'\n, lw=\n3\n);\n\n\n\n以下为数据集\n0.    -0.5462822385491465\n0.4    -0.783702451361118\n0.8    -0.9089025224257823\n1.2000000000000002    -0.7889248051156628\n1.6    -0.949226943504489\n2.    -0.7611050401954805\n2.4000000000000004    -0.6650057450647151\n2.8000000000000003    -0.8759288670095501\n3.2    -0.8656123587289317\n3.6    -0.6649140457676437\n4.    -0.5583916152654299\n4.4    -0.6234103572245565\n4.800000000000001    -0.4384536670407637\n5.2    -0.45475540642816015\n5.6000000000000005    -0.2933535893528097\n6.    -0.41092618504230566\n6.4    -0.21640691364542158\n6.800000000000001    -0.3233191361448244\n7.2    -0.40033772666343287\n7.6000000000000005    -0.19619561408794248\n8.    -0.37232044338162273\n8.4    -0.32763639327372057\n8.8    -0.07584110402709568\n9.200000000000001    -0.07289662739894218\n9.600000000000001    -0.3861124072710949\n10.    0.0016509499268891892\n10.4    -0.18590426894048864\n10.8    0.10204635804590274\n11.200000000000001    0.09898944148210725\n11.600000000000001    -0.16365426432836233\n12.    0.022162186215955795\n12.4    -0.0873894131756795\n12.8    0.14331006792028625\n13.200000000000001    -0.07093466063257273\n13.600000000000001    -0.08726667971656135\n14.    0.10821188257124201\n14.4    0.15593856613111876\n14.8    0.14897975799398278\n15.200000000000001    -0.16871736440162438\n15.600000000000001    0.05054500120681124\n16.    0.06705897957468973\n16.400000000000002    0.1876763504970213\n16.8    0.06520926888847367\n17.2    0.10134588588772128\n17.6    0.26959040983807353\n18.    0.2539157102920223\n18.400000000000002    0.024874768094809763\n18.8    0.143008217569402\n19.200000000000003    0.3871661437031221\n19.6    0.2807141057341562\n20.    0.3884392340985038\n20.400000000000002    0.1355900401705764\n20.8    0.33355373782689146\n21.200000000000003    0.27999830448890783\n21.6    0.1672208672103661\n22.    0.28611323112030274\n22.400000000000002    0.18389979569025794\n22.8    0.424354295482916\n23.200000000000003    0.4482691277851301\n23.6    0.28911625650990647\n24.    0.3254114765687105\n24.400000000000002    0.3427910094969029\n24.8    0.30639615372248097\n25.200000000000003    0.3620792422007555\n25.6    0.5333743131783425\n26.    0.39409808537290963\n26.400000000000002    0.5728178137177391\n26.8    0.08537572482772388\n27.200000000000003    0.28523057343506414\n27.6    0.6426259088772276\n28.    0.46367151413404734\n28.400000000000002    0.45160954743898335\n28.8    0.4812533692364098\n29.200000000000003    0.6071255451174223\n29.6    0.3865498395360522\n30.    0.45964468718784435\n30.400000000000002    0.32571105852891497\n30.8    0.6846011283841505\n31.200000000000003    0.5133973059495182\n31.6    0.40248598712451333\n32.    0.2835389289400173\n32.4    0.30208717833464094\n32.800000000000004    0.2503493752453388\n33.2    0.2898018021224344\n33.6    0.09515099754339622\n34.    -0.20011718696526487\n34.4    -0.3750571976984114\n34.800000000000004    -0.43371508478312204\n35.2    -0.719799032621965\n35.6    -0.9004915376393323\n36.    -1.0075778689532933\n36.4    -1.0847746487179042\n36.800000000000004    -1.0347158404087944\n37.2    -0.7782406698370552\n37.6    -0.7013228694375362\n38.    -0.6999737071538361\n38.400000000000006    -0.5417534711626819\n38.800000000000004    -0.5032275263459386\n39.2    -0.6252927035832156\n39.6    -0.6023207461720973\n40.    -0.4427931407722867\n40.400000000000006    -0.5023196286259453\n40.800000000000004    -0.3047799962996736\n41.2    -0.3417332656517241\n41.6    -0.40688052553661025\n42.    -0.2792846817997484\n42.400000000000006    -0.3761858584786536\n42.800000000000004    -0.3322148718977771\n43.2    -0.1894292487503772\n43.6    -0.11481140334502393\n44.    -0.13884919114085115\n44.400000000000006    -0.14197647217998172\n44.800000000000004    -0.15668965339073987\n45.2    -0.30106547563085595\n45.6    -0.1601079715503942\n46.    -0.02856438946758659\n46.400000000000006    -0.012337329111426557\n46.800000000000004    0.12214231419108941\n47.2    -0.20972662011023396\n47.6    0.08299547427591929\n48.    0.14692819172321148\n48.400000000000006    0.030999940619061642\n48.800000000000004    0.01148690553567826\n49.2    0.12558896523923488\n49.6    0.21337993717333054\n50.    0.05261326571378101\n50.400000000000006    0.015171074820157837\n50.800000000000004    0.10030943947289518\n51.2    0.07566707857393415\n51.6    0.2878403012305583\n52.    0.06319472140542415\n52.400000000000006    0.0696430280349094\n52.800000000000004    0.12208331350240692\n53.2    0.06359652523747564\n53.6    0.31133682129861706\n54.    0.14345029247237168\n54.400000000000006    0.11571728996734064\n54.800000000000004    0.4458110824088779\n55.2    0.13603495323086506\n55.6    0.17090505396986216\n56.    0.4261058399859091\n56.400000000000006    0.37980187003159394\n56.800000000000004    0.1573904172013318\n57.2    0.20380280893732955\n57.6    0.17140189170010423\n58.    0.38440601207916764\n58.400000000000006    0.46088153933955767\n58.800000000000004    0.28645206883094193\n59.2    0.3817743213824975\n59.6    0.5880033160984758\n60.    0.26889226016305\n60.400000000000006    0.3197292048394207\n60.800000000000004    0.5058844619908931\n61.2    0.5328303396087486\n61.6    0.39809118839584495\n62.    0.4790661748830668\n62.400000000000006    0.4322866523197192\n62.800000000000004    0.5738971870057148\n63.2    0.4854131198652305\n63.6    0.48251305636966507\n64.    0.6405790592698798\n64.4    0.40246674211906774\n64.8    0.4985131223939545\n65.2    0.44244386447180284\n65.60000000000001    0.45841714901421676\n66.    0.34833181544778136\n66.4    0.3979748831459446\n66.8    0.458964810348448\n67.2    0.5170930019982345\n67.60000000000001    0.1759347943583993\n68.    -0.043156293122121464\n68.4    0.09696332441608412\n68.8    -0.2558260271758174\n69.2    -0.39923232592505825\n69.60000000000001    -0.8128179270209015\n70.    -0.8319290760909005\n70.4    -1.080004611307604\n70.8    -0.9880242281598463\n71.2    -1.0303479098135222\n71.60000000000001    -0.8397760052776759\n72.    -0.9044623385137911\n72.4    -0.8567212118283086\n72.8    -0.7534653458737495\n73.2    -0.6675507741975902\n73.60000000000001    -0.5666532372452661\n74.    -0.7712660454372295\n74.4    -0.3974742948276597\n74.8    -0.5946877604677512\n75.2    -0.4031915593671267\n75.60000000000001    -0.2821943186057766\n76.    -0.466492956801751\n76.4    -0.31706573379857794\n76.80000000000001    -0.5406061827445913\n77.2    -0.2710807545256565\n77.60000000000001    -0.34240653068601073\n78.    -0.32741259669469924\n78.4    -0.19460518725123405\n78.80000000000001    -0.29598538356708987\n79.2    -0.274449627037916\n79.60000000000001    -0.12600804723174605\n80.    -0.023851583103075544\n80.4    -0.19711257253457726\n80.80000000000001    -0.25355325905702014\n81.2    -0.14202573944496455\n81.60000000000001    -0.005505476692198655\n82.    -0.01007757352545851\n82.4    -0.27423396530714594\n82.80000000000001    0.05774683759947964\n83.2    -0.09628081995743432\n83.60000000000001    -0.06944835179982074\n84.    -0.0846046097999839\n84.4    0.1150230372096937\n84.80000000000001    0.00018716335145349539\n85.2    -0.022823370411284058\n85.60000000000001    -0.03137259399756902\n86.    0.011054934507681594\n86.4    -0.02655844915242281\n86.80000000000001    0.24895762795842316\n87.2    0.07913254678138325\n87.60000000000001    0.2300278285313324\n88.    0.21479961123956673\n88.4    0.20944251357249155\n88.80000000000001    0.18348117381816614\n89.2    0.2574212926057774\n89.60000000000001    0.41126513377888513\n90.    0.12305959029805205\n90.4    0.1638351308839136\n90.80000000000001    0.2328845800387314\n91.2    0.2398046782077135\n91.60000000000001    0.3631498591790082\n92.    0.1078738865005095\n92.4    0.3454088263034277\n92.80000000000001    0.5448086260614305\n93.2    0.3043549492065313\n93.60000000000001    0.3363562785095267\n94.    0.2612311629090467\n94.4    0.26030193696870574\n94.80000000000001    0.44800148917546334\n95.2    0.42499185674750584\n95.60000000000001    0.4429400564887961\n96.    0.5415513671999952\n96.4    0.3423197257336098\n96.80000000000001    0.33418612244379925\n97.2    0.4968735700779301\n97.60000000000001    0.5924748360892591\n98.    0.6147045551005446\n98.4    0.5659946440638943\n98.80000000000001    0.5462887976749852\n99.2    0.5608357659259421\n99.60000000000001    0.5062835898828245\n100.    0.5676729761918977\n100.4    0.47168711800682717\n100.80000000000001    0.3366713565408654\n101.2    0.5129243199308822\n101.60000000000001    0.4708176758882343\n102.    0.5427855549276028\n102.4    0.11936031480780501\n102.80000000000001    0.23424575082343574\n103.2    0.11553206914894676\n103.60000000000001    -0.1877509547165001\n104.    -0.4928384630473328\n104.4    -0.6662156662964173\n104.80000000000001    -0.7666916789694784\n105.2    -0.9735619511653839\n105.60000000000001    -0.9014467132649695\n106.    -0.8958602997771499\n106.4    -0.8224063839105851\n106.80000000000001    -0.6645903476112819\n107.2    -0.7819640958844551\n107.60000000000001    -0.6685374459319108\n108.    -0.6541210481036482\n108.4    -0.5214383138802767\n108.80000000000001    -0.6003153297645414\n109.2    -0.5787779769802132\n109.60000000000001    -0.3480504032971965\n110.    -0.5325703531094098\n110.4    -0.40142888927534914\n110.80000000000001    -0.4483810362656604\n111.2    -0.37808976333664585\n111.60000000000001    -0.416288255030488\n112.    -0.1360650372313087\n112.4    -0.4268937164048808\n112.80000000000001    -0.2529864665937869\n113.2    -0.34549384224190594\n113.60000000000001    0.06824335163778911\n114.    -0.2839666991565712\n114.4    -0.09729931130123909\n114.80000000000001    -0.13774252492489097\n115.2    -0.16607128925459416\n115.60000000000001    -0.1463761890901475\n116.    -0.07520463870990637\n116.4    -0.16481812940965937\n116.80000000000001    -0.21119489874471697\n117.2    0.0923790534885594\n117.60000000000001    -0.14099016050921043\n118.    -0.1070181087744724\n118.4    -0.06746400029990894\n118.80000000000001    -0.0633054410439185\n119.2    0.09436642103003781\n119.60000000000001    0.07731983501122021\n120.    0.26633338829557907\n120.4    0.08929344710613638\n120.80000000000001    0.2400066885272551\n121.2    0.10428838429148958\n121.60000000000001    0.24751164922878338\n122.    0.08978648653950992\n122.4    0.45471462692443454\n122.80000000000001    0.3089050100656188\n123.2    0.24584773382788544\n123.60000000000001    -0.019913654385687263\n124.    0.056672859665413716\n124.4    0.20168696119225715\n124.80000000000001    0.34972612465176006\n125.2    0.13038312006362557\n125.60000000000001    0.3167164216295364\n126.    0.2779266518534756\n126.4    0.26660536344437\n126.80000000000001    0.14444541651877255\n127.2    0.23498226712938536\n127.60000000000001    0.32457332737585987\n128.    0.340470740237679\n128.4    0.6211952921187511\n128.8    0.15342735804801438\n129.20000000000002    0.4099108917209856\n129.6    0.2712059665109151\n130.    0.3250849162328896\n130.4    0.3031154163474018\n130.8    0.3098377600846768\n131.20000000000002    0.48815960360908467\n131.6    0.20608568628338472\n132.    0.4099412370173662\n132.4    0.6001726844129311\n132.8    0.6820292577209212\n133.20000000000002    0.27117025310774967\n133.6    0.5841998652199251\n134.    0.43076261342893446\n134.4    0.5143873109835726\n134.8    0.46726110781143304\n135.20000000000002    0.37958390970371775\n135.6    0.7010985370187497\n136.    0.32249649601323116\n136.4    0.4702153335547108\n136.8    0.320217528422363\n137.20000000000002    0.02928600207078058\n137.6    0.318357039933507\n138.    0.03752982234827708\n138.4    -0.3351894811666113\n138.8    -0.5958162819094603\n139.20000000000002    -0.6425631067756862\n139.6    -0.8477400574266666\n140.    -0.8922853035015624\n140.4    -0.8232509765566146\n140.8    -0.912102023617521\n141.20000000000002    -0.974782777049334\n141.6    -0.7666870272358872\n142.    -0.9077531177373417\n142.4    -0.5599596188333437\n142.8    -0.45038021731924566\n143.20000000000002    -0.6681704000438224\n143.6    -0.6081038321024888\n144.    -0.6730182769281464\n144.4    -0.4271879548318579\n144.8    -0.4854454938268676\n145.20000000000002    -0.6038975411997995\n145.6    -0.5049302704130576\n146.    -0.6103257838150606\n146.4    -0.2672128156070648\n146.8    -0.2274655435022608\n147.20000000000002    -0.30474865248744654\n147.6    -0.15035696639627968\n148.    -0.0010436212727284733\n148.4    -0.047693642582197965\n148.8    -0.15645612245608825\n149.20000000000002    -0.049559089200126055\n149.6    -0.22467291208693557\n150.    -0.14521466027790936\n150.4    -0.165634289789594\n150.8    0.06520514400413163\n151.20000000000002    -0.10567659222139225\n151.6    0.01977278177354396\n152.    -0.13557893105081786\n152.4    0.00025117117596100955\n152.8    -0.08733521952212644\n153.20000000000002    0.2655048900618098\n153.60000000000002    0.17882263116728686\n154.    -0.13785362801835727\n154.4    0.09482886304696334\n154.8    -0.0632319596991523\n155.20000000000002    0.007020078422556406\n155.60000000000002    -0.009389357681450827\n156.    0.07785338401909957\n156.4    0.23198139546898455\n156.8    0.0174068383328633\n157.20000000000002    0.1842255013406493\n157.60000000000002    0.1393789762528451\n158.    0.33715425611588046\n158.4    0.19280862984606023\n158.8    0.33389954449909776\n159.20000000000002    0.13585670643011616\n159.60000000000002    0.36783110408378117\n160.    0.42010872369884095\n160.4    0.31286549632474864\n160.8    0.39069972699500555\n161.20000000000002    0.18116120329585575\n161.60000000000002    0.10371857479283189\n162.    0.4917274809103874\n162.4    0.3727810890779094\n162.8    0.3985424346035771\n163.20000000000002    0.33155500623764317\n163.60000000000002    0.49087193698786724\n164.    0.30985416697570645\n164.4    0.24544087613073115\n164.8    0.5400907066824197\n165.20000000000002    0.5929888938812942\n165.60000000000002    0.3809316027669257\n166.    0.4257183431048073\n166.4    0.30462687487763207\n166.8    0.43012532230731126\n167.20000000000002    0.4220534968683622\n167.60000000000002    0.36939625799188935\n168.    0.5392676132789046\n168.4    0.4865883072004645\n168.8    0.5144803652394002\n169.20000000000002    0.49512848660058156\n169.60000000000002    0.34859406478808885\n170.    0.3699097271324771\n170.4    0.38717674443255795\n170.8    0.4809681042881636\n171.20000000000002    0.5233041913949565\n171.60000000000002    0.3100388529630959\n172.    0.06853085920270038\n172.4    0.09384913809990186\n172.8    -0.17953490141744538\n173.20000000000002    -0.48489672802304673\n173.60000000000002    -0.6230705369803219\n174.    -0.634244556148584\n174.4    -1.0180361501668482\n174.8    -0.92720207954732\n175.20000000000002    -0.9966618637429566\n175.60000000000002    -0.7589352069652644\n176.    -0.8279820338807111\n176.4    -0.6836136294636722\n176.8    -0.6082406366530075\n177.20000000000002    -0.7550103655784546\n177.60000000000002    -0.5473463105118186\n178.    -0.6305311819755766\n178.4    -0.6459417408151074\n178.8    -0.5594554478813489\n179.20000000000002    -0.4733725236473101\n179.60000000000002    -0.32278661220846966\n180.    -0.4641220313427059\n180.4    -0.26133729607265666\n180.8    -0.23527649451051025\n181.20000000000002    -0.2925729105590527\n181.60000000000002    -0.09727766612286612\n182.    -0.46985687735805515\n182.4    -0.27825705499393755\n182.8    -0.2596775525305475\n183.20000000000002    -0.15767037791015198\n183.60000000000002    -0.29235665820657314\n184.    -0.09757582213465452\n184.4    -0.22298921221059234\n184.8    -0.04590939669421765\n185.20000000000002    -0.09238756474095157\n185.60000000000002    0.10664115041354308\n186.    -0.29151762318203905\n186.4    -0.10915832831973954\n186.8    -0.10678328495431663\n187.20000000000002    0.031772078997418296\n187.60000000000002    0.07474087836288307\n188.    0.13618278891413677\n188.4    -0.1133788116650889\n188.8    0.07455948896951106\n189.20000000000002    0.1483278806640675\n189.60000000000002    0.05080292450863628\n190.    -0.17226716059118025\n190.4    0.11971371193021275\n190.8    0.09662166246867193\n191.20000000000002    0.1805661490088666\n191.60000000000002    0.05993400992421301\n192.    0.07431224973783443\n192.4    0.20540432145542878\n192.8    0.08245871883766366\n193.20000000000002    0.12108291014577699\n193.60000000000002    0.15998539631512884\n194.    0.03250359040460707\n194.4    0.2718351017167708\n194.8    0.3042798009818843\n195.20000000000002    0.24731560455929016\n195.60000000000002    0.35284292515800403\n196.    0.2675357804985887\n196.4    0.21555440816274485\n196.8    0.005006448281731468\n197.20000000000002    0.5238287163387917\n197.60000000000002    0.41429219557707203\n198.    0.4173298692386332\n198.4    0.3727151012376218\n198.8    0.46631327699492664\n199.20000000000002    0.39089889533974337\n199.60000000000002    0.46922445398441637\n200.    0.19261170005827852", "Tag": "算法分析"}
{"Answer": "参考GPT和自己的思路：好的，关于你的问题，我来给你解答一下。\n线性电源和非线性电源是两种不同的电源类型，它们的区别主要在于工作原理和输出特性。线性电源是利用变压器和稳压器等电路组合实现对输入电压的变换和稳定，因此其输出具有较高的纹波系数和较低的效率，但是稳定性较好，适用于对电压稳定度要求较高的场合。而非线性电源则是通过开关管等元器件进行变换和调节，其输出特性相对不稳定但效率较高，适用于多种场合。\n稳定性方面，由于线性电源使用了稳压器等电路，其输出电压变化范围较小，因此稳定性更好。而非线性电源则需要通过电路调节来保持输出电压稳定，因此其稳定性可能稍差一些。可靠性方面，两种电源类型的可靠性大体相同，主要取决于电路设计的合理性和部件的使用寿命。\n总的来说，线性电源和非线性电源的选择应当根据具体的应用场合、功率需求和成本等因素综合考虑。", "Konwledge_Point": "线性规划和规约", "Question": "关于电源的类型有什么区别和不一样\n线性电源和非线性电源的区别在什么地方，有什么不一样的？稳定性和可靠性有什么区别？", "Tag": "算法分析"}
{"Answer": "使用listview就完美解决问题。", "Konwledge_Point": "线性规划和规约", "Question": "RecycleView代码不更新！\nRecycleView代码不更新！更新代码应该怎么写呢，有没有人教一下\n\n网络数据取到了，Recycleview 没显示出来数据\n\n\n\npublic class FoodFragment extends Fragment {\n    public RecyclerView mFoodRecyclerView;//定义RecyclerView\n    //定义以goodsentity实体类为对象的数据集合\n    private ArrayList goodsEntityList = new ArrayList();\n    //自定义recyclerveiw的适配器\n    private FoodRecycleAdapter mRecyclerAdapter;\n    private JSONArray array;\n\n\n\n    public  FoodFragment() {\n    }\n\n    private static ChangeFoodFragment changeFoodFragment;\n\n    public static FoodFragment newInstance(ChangeFoodFragment foodFragment){\n        changeFoodFragment = foodFragment;\n        Bundle args = new Bundle();\n\n        FoodFragment fragment = new FoodFragment();\n        fragment.setArguments(args);\n        return fragment;\n    }\n    @Nullable\n    @Override\n    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container,\n                             @Nullable Bundle savedInstanceState) {\n        View  view = inflater.inflate(R.layout.recyclerview_food, container, false);\n        //对recycleview进行配置\n\n        return view;\n    }\n    @Override\n    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\n        super.onViewCreated(view, savedInstanceState);\n        initData();\n        initRecyclerView(view);\n\n\n\n\n\n    }\n    private void initData() {\n        new Thread(){\n            public void run()\n            {\n                String url = DocUtil.food_list;\n                OkHttpClient okHttpClient = new OkHttpClient();\n\n                String token= CacheUtils.getString(getActivity(), \"token\", \"\");\n                RequestBody body = new FormBody.Builder()\n                        .add(\"token\",token)\n                        .build();\n\n                Request request = new Request.Builder()\n                        .url(url)\n                        .post(body)\n                        .build();\n\n                Call call = okHttpClient.newCall(request);\n                try {\n                    Response response = call.execute();\n                    //System.out.println(response.body().string());\n                    try {\n                        final String string=response.body().string();\n                        final JSONObject object=new JSONObject(string);\n\n                        array=object.getJSONArray(\"list\");\n                        System.out.println(array);\n                        if(array.length()>0) {\n\n                            try {\n                                FoodEntity foodEntity =new FoodEntity();\n                                for(int i=0;i{\n\n    private Context context;\n    private ArrayList goodsEntityList;\n    private ImageLoaderConfiguration configuration;\n    public DisplayImageOptions imageOptions;\n    private FoodRecycleAdapter adapter;\n\n\n    //创建构造函数\n    public FoodRecycleAdapter(Context context, ArrayList goodsEntityList) {\n        //将传递过来的数据，赋值给本地变量\n        this.context = context;//上下文\n        this.goodsEntityList = goodsEntityList;//实体类数据ArrayList\n    }\n\n    /**\n     * 创建viewhodler，相当于listview中getview中的创建view和viewhodler\n     *\n     * @param parent\n     * @param viewType\n     * @return\n     */\n    @Override\n    public myViewHodler onCreateViewHolder(ViewGroup parent, int viewType) {\n        //创建自定义布局\n\n        View itemView = View.inflate(context, R.layout.food_item, null);\n\n        return new myViewHodler(itemView);\n    }\n\n    /**\n     * 绑定数据，数据与view绑定\n     *\n     * @param holder\n     * @param position\n     */\n    @Override\n    public void onBindViewHolder(myViewHodler holder, int position) {\n             //根据点击位置绑定数据\n        FoodEntity data = goodsEntityList.get(position);\n//        holder.mItemGoodsImg;\n        configuration = ImageLoaderConfiguration.createDefault(context);\n        ImageLoader.getInstance().init(configuration);\n        imageOptions = DisplayImageOptions.createSimple();\n        holder.mItemGoodsName.setText(data.foodtitle);//获取实体类中的name字段并设置\n        holder.mItemContent.setText(data.foodcontent);//获取实体类中的price字段并设置\n        adapter=new FoodRecycleAdapter(context, goodsEntityList);\n\n        adapter.notifyItemRangeInserted(position,getItemCount());\n\n//        ImageLoader.getInstance().displayImage(DocUtil.base_url+\n//                        data.foodcontentimg, mItemGoodsImg,\n//                imageOptions);\n\n    }\n\n    /**\n     * 得到总条数\n     *\n     * @return\n     */\n    @Override\n    public int getItemCount() {\n        return goodsEntityList.size();\n    }\n\n    //自定义viewhodler\n    class myViewHodler extends RecyclerView.ViewHolder {\n        private ImageView mItemGoodsImg;\n        private TextView mItemGoodsName;\n        private TextView mItemContent;\n\n        public myViewHodler(View itemView) {\n            super(itemView);\n            mItemGoodsImg = itemView.findViewById(R.id.food_img);\n            mItemGoodsName =  itemView.findViewById(R.id.food_title);\n            mItemContent =  itemView.findViewById(R.id.tx_content);\n\n            //点击事件放在adapter中使用，也可以写个接口在activity中调用\n            //方法一：在adapter中设置点击事件\n            itemView.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    //可以选择直接在本位置直接写业务处理\n                    //Toast.makeText(context,\"点击了xxx\",Toast.LENGTH_SHORT).show();\n                    //此处回传点击监听事件\n\n                    if(onItemClickListener!=null){\n                        onItemClickListener.OnItemClick(v, goodsEntityList.get(getLayoutPosition()));\n                    }\n                }\n            });\n\n        }\n    }\n\n    /**\n     * 设置item的监听事件的接口\n     */\n    public interface OnItemClickListener {\n        /**\n         * 接口中的点击每一项的实现方法，参数自己定义\n         *\n         * @param view 点击的item的视图\n         * @param data 点击的item的数据\n         */\n        public void OnItemClick(View view, FoodEntity data);\n    }\n\n    //需要外部访问，所以需要设置set方法，方便调用\n    private FoodRecycleAdapter.OnItemClickListener onItemClickListener;\n\n    public void setOnItemClickListener(FoodRecycleAdapter.OnItemClickListener onItemClickListener) {\n        this.onItemClickListener = onItemClickListener;\n    }\n}\n\n", "Tag": "算法分析"}
{"Answer": "该回答通过自己思路及引用到GPTᴼᴾᴱᴺᴬᴵ搜索,得到内容具体如下：\n从您提供的代码中可以看出，您在将预测结果打印在控制台中时使用了以下代码：\nfor k, v in name_dict.items():\n    if result == v:\n        print(\"预测结果:\", k)\n\n但是，当您在将预测结果显示在 tkinter 窗口中时，使用了以下代码：\nresult = np.argmax(result[0])\nfor k, v in name_dict.items():\n    if result == v:\n        print(\"预测结果:\", k)\npred = \"预测结果：\" + k\ne1 = tk.Label(root, text=pred, font=('Arial', 16))\ne1.place(x=600, y=370)\n\n这两段代码中的变量 k 的值是不同的。在第一段代码中，k 的值是在循环中最后一次赋值的名称，而在第二段代码中，k 的值是在循环结束后最后一次赋值的名称。因此，这两个变量的值不同，导致在控制台中打印的结果和 tkinter 窗口中显示的结果不一致。\n要解决这个问题，您可以将第二段代码中的 k 的赋值移到循环内部，以确保每次循环结束时 k 的值都是正确的名称。以下是修改后的代码：\nresult = np.argmax(result[0])\nfor k, v in name_dict.items():\n    if result == v:\n        print(\"预测结果:\", k)\n        pred = \"预测结果：\" + k\n        e1 = tk.Label(root, text=pred, font=('Arial', 16))\n        e1.place(x=600, y=370)\n\n这样修改后，您的预测结果应该在控制台和 tkinter 窗口中都能正确地显示。\n\n如果以上回答对您有所帮助，点击一下采纳该答案～谢谢", "Konwledge_Point": "线性规划和规约", "Question": "我的print出的结果和tkinter上显示的结果不一致，怎么改啊？\n我的print出的结果，和tkinter上显示的结果不一样，怎么改啊？\n这是我tkinter上的显示：\n\n\n这是print出的结果：\n\n\n这是我将结果显示在tkinter上的代码：\n\n\n    for k, v \nin\n name_dict.items():  \n# 将类别由数字转换为名称\n\n        \nif\n \nresult\n == v:  \n# 如果预测结果等于v, 打印出名称\n\n            print(\n\"预测结果:\"\n, k)  \n# 打印出名称\n\n\n    \npred\n = \n\"预测结果：\"\n + k\n    \ne1\n = tk.Label(root, \ntext=pred,\n \nfont=('Arial',\n \n16\n))\n#显示预测结果\n\n    e1.place(\nx=600,\n \ny=370)\n\n\n\n\n\n下面是我的整体代码：\n\n\nimport\n tkinter \nas\n tk\n\nimport\n tensorflow \nas\n tf\n\nimport\n matplotlib.pyplot \nas\n plt\n\nfrom\n matplotlib.backends.backend_tkagg \nimport\n FigureCanvasTkAgg\n\nimport\n numpy \nas\n np\n\nfrom\n tkinter \nimport\n *\n\nimport\n tkinter.filedialog  \n# 注意次数要将文件对话框导入\n\n\nfrom\n PIL \nimport\n Image\n\nfrom\n tensorflow.python.keras \nimport\n models, layers\n\n\ndef\n \nCNN_yuce\n():\n    \nglobal\n e1, pred, root,predict_class, k\n    name_dict = {\n\"Uninfected\"\n:\n0\n, \n\"Parasitized\"\n:\n1\n}\n\n    fig = plt.figure(figsize=(\n2\n,\n2\n),dpi=\n100\n)\n    \n# 从本地选择一个文件，并返回文件的目录\n\n    \n# filenames = tkinter.filedialog.askopenfile()#形成一共io流 的文件名称\n\n    filename = tk.filedialog.askopenfilename(title=\nu'加载图片'\n,initialdir=(()))\n#只保留文件名和后缀\n\n    \nprint\n(filename)\n\n    \n# model_save_path = 'D:/ningyupeng/pythonProject/Graduation Project V1.0/my_model/variables/variables.ckpt'\n\n\n    model = tf.keras.models.Sequential([\n        tf.keras.layers.Flatten(),\n#Flatten-变成一维数组\n\n        tf.keras.layers.Dense(\n128\n, activation=\n'relu'\n),\n#relu函数可以解决 梯度消失问题 是线性的\n\n        tf.keras.layers.Dense(\n2\n, activation=\n'softmax'\n)])\n# 2个类所以2个神经元 softmax只用在最后一层 可以让最后输出的概率在0-1之间\n\n\n    \n# model.load_weights('checkpoint-05e-val_acc_0.58.hdf5')#读取文件\n\n    models.load_model(\n\"my_model\"\n)\n\n    \n# 加载测试图片\n\n    img = Image.\nopen\n(filename)\n    \n# 将图片resize到224x224大小\n\n    img = img.resize((\n128\n, \n128\n), Image.ANTIALIAS)\n    \n# 将灰度图转化为RGB模式\n\n    img = img.convert(\n\"RGB\"\n)\n\n    plt.axis(\n'off'\n)  \n# 去掉坐标轴\n\n    plt.imshow(img)\n    \n# 归一化\n\n    img1 = np.array(img) / \n255.\n\n    \n# 将图片增加一个维度，目的是匹配网络模型\n\n    img1 = (np.expand_dims(img1, \n0\n))\n    \n# 将预测结果转化为概率值\n\n    result = np.squeeze(model.predict(img1))\n    predict_class = np.argmax(result)\n    \n# pred = tf.argmax(result, axis=1)#求最大值得出最后识别出来的数\n\n    \n# print(inverse_dict[int(predict_class)],result[predict_class])\n\n    \n# 将预测的结果打印在图片上面\n\n    \n# plt.title([inverse_dict[int(predict_class)],result[predict_class]])\n\n    \nprint\n(result)\n\n    result = np.argmax(result[\n0\n])  \n# 取出预测结果中概率最大的元素索引值\n\n    \nfor\n k, v \nin\n name_dict.items():  \n# 将类别由数字转换为名称\n\n        \nif\n result == v:  \n# 如果预测结果等于v, 打印出名称\n\n            \nprint\n(\n\"预测结果:\"\n, k)  \n# 打印出名称\n\n\n    pred = \n\"预测结果：\"\n + k\n    e1 = tk.Label(root, text=pred, font=(\n'Arial'\n, \n16\n))\n#显示预测结果\n\n    e1.place(x=\n600\n, y=\n370\n)\n\n    canvas = FigureCanvasTkAgg(fig, master=root)\n#渲染器 在画布上放置图片\n\n    canvas.draw()\n    canvas.get_tk_widget().place(x=\n600\n,y=\n150\n)\n\ndef\n \npicture\n():\n    \nglobal\n root\n    root = Tk()\n    root.wm_title(\n\"细胞图像疟疾检测\"\n)\n    root.geometry(\n'1000x650'\n)\n\n    ask = tk.Button(root, text=\n\"CNN\"\n, width=\n10\n, command=CNN_yuce)\n    ask.place(x=\n600\n, y=\n90\n)\n\n    root.mainloop()\n\n\nif\n __name__ == \n'__main__'\n:\n    picture()\n\n", "Tag": "算法分析"}
{"Answer": "那应该是下面那行insert有问题，程序异常结束了insert函数的for语句，应该是i=length-1，你写成了length-i。后面的代码注意类似问题", "Konwledge_Point": "线性规划和规约", "Question": "线性表（c++），输出结果不全（只有length和IsEmpty），计算机新生求指出问题\n“llist.h\"\n\n\n\n\n\n\n输出结果只有cout<<\"Length=\"<<L.Length()<<endl;\n        cout<<\"IsEmpty=\"<<L.IsEmpty()<<endl; 这两行的输出", "Tag": "算法分析"}
{"Answer": "什么叫没错误，你释放那块就有问题：\r\nvoid Queue::clear(void)//清空链队\r\n自己到底调过没有，张嘴就说\r\n改成这样就不会崩了，你有其他转换问题就自行查询吧\r\n```\r\nvoid Queue::clear(void)//清空链队\r\n{\r\n\tif (count == 0) return;\r\n\tnode *searchp = front->next, *followp = front;//初始化两个指针\r\n\twhile (searchp != rear)\r\n\t{\r\n\t\tfollowp = searchp;\r\n\t\tsearchp = searchp->next;\r\n\t\tdelete followp;\r\n\t}\r\n\tfront->next = NULL;//保留了最后一个结点，就是头结点，并且链域置为空\r\n\trear = front;\r\n\tcount = 0;//计数器也清零\r\n}\r\n```", "Konwledge_Point": "线性规划和规约", "Question": "代码没有错误，为什么程序没运行完就直接结束了？\n\n\n\n//主要功能：实现带小数二进制和十进制之间数据的转换\n#include \n#include \n#include \n#include \n#include \n\nusing namespace std;\n\nconst int TAILMAXLENTH=10;//定义十进制转换成二进制小数部分最大位数\nconst int DABAMAXLENTH=40;//定义原始数据的最大长度\nconst double ADDMENBERNUM=111.11;//定义一个加数用于检测数据真实可用\n\n/*********************************************************************************************************\n*栈的部分\n*********************************************************************************************************/\nclass Stack;//类Stack的声明\n\n/*\n定义一个链栈结点类Stacknode\n*/\nclass Stacknode\n{\n    friend class Stack;//申请友元类\nprivate:\n    Stacknode(Stacknode *nextp=NULL);//构造函数\n    Stacknode(int &newdata,Stacknode *nextp=NULL);//构造函数\n    int data;//数据元素\n    Stacknode *next;//递归定义指向后继结点的指针\n};\n\n/*\nStacknode的实现部分\n*/\nStacknode::Stacknode(Stacknode *nextp)//构造函数\n{\n    next=nextp;\n}\n\nStacknode::Stacknode(int &newdata,Stacknode *nextp)//构造函数\n{\n    data=newdata;\n    next=nextp;\n}\n//结点类Stacknode的定义结束\n\n/*\n定义一个链栈类Stack\n*/\nclass Stack\n{\npublic:\n    Stack();//创建一个空栈\n    ~Stack();//回收一个栈\n    void clear();//销毁一个栈\n    bool empty() const;//确定栈是否已空\n    bool push(int &item);//把数据压进栈\n    bool pop();//出栈\n    bool top(int &item) const;//取出栈顶元素\nprivate:\n    Stacknode *newnode(Stacknode *nextp=NULL);\n    Stacknode *newnode(int &item,Stacknode *nextp=NULL);//创建新的结点\n    Stacknode *Stacktop;\n    int Stacklength;\n};\n\n/*\nStack的实现部分\n*/\nStacknode *Stack::newnode(Stacknode *nextp)//创建新的结点，不带数据\n{\n    return new Stacknode(nextp);\n}\n\nStacknode *Stack::newnode(int &item,Stacknode *nextp)//创建新的结点，数据域赋值\n{\n    return new Stacknode(item,nextp);\n}\n\n//以下为栈类Stack的函数定义\nStack::Stack()//创建一个空栈\n{\n    Stacktop=newnode();//创建一个栈顶指针初始化，相当于Stacktop=NULL；本链表没有用头结点\n    Stacklength=0;\n}\n\nStack::~Stack()//回收一个栈\n{\n    clear();\n    delete Stacktop;//释放栈底\n}\n\nvoid Stack::clear()//销毁一个栈\n{\n    //while(pop());//不停地出栈，而每次释放空间在出栈函数中完成\n    Stacknode *usednodep;//定义指针usednodep，准备指向出栈的结点\n    while(Stacktop->next!=NULL)\n    {\n        usednodep=Stacktop;//指向出栈的结点\n        Stacktop=Stacktop->next;//栈顶指针后移\n        delete usednodep;//释放空间\n    }\n}\n\nbool Stack::empty() const//确定栈是否已空\n{\n    return Stacklength<=0?true:false;\n}\n\nbool Stack::push(int &item)//数据进栈\n{\n    Stacknode *newnodep;//定义指针newnodep，准备指向申请的新结点\n    newnodep=newnode(item,Stacktop);//申请新结点，把数据存入，把指针域指向头指针\n    if(!newnodep)//如果没有申请到空间，返回失败\n        return false;\n    Stacktop=newnodep;//改链，完成进栈\n    Stacklength++;//栈的长度增加\n    return true;//本次操作成功\n}\n\nbool Stack::pop()//出栈,不要栈顶数据\n{\n    Stacknode *usednodep;//定义指针usednodep，准备指向出栈的结点\n    if(!empty())//判断是否栈空\n    {\n        usednodep=Stacktop;//指向出栈的结点\n        Stacktop=Stacktop->next;//栈顶指针后移\n    //  delete usednodep;//释放空间\n        Stacklength--;//栈的长度减少\n        return true;//本次操作成功\n    }\n    return false;//否则本次操作失败\n}\n\nbool Stack::top(int &item) const//取出栈顶数据返回去\n{\n    if(!empty())//如果栈不空，记录当前栈顶元素\n    {\n        item=Stacktop->data;//通过item返回去\n        return true;//本次操作成功\n    }\n    return false;//否则本次操作失败\n}\n\n/*********************************************************************************************************\n*队列的部分\n*********************************************************************************************************/\n/*\n定义一个结点类node\n*/\nclass node\n{\npublic:\n    int data;\n    node *next;\n};\n\n/*\n定义一个链队类Queue\n*/\nclass Queue\n{\nprivate:\n    node *rear;\n    node *front;\nprotected:\n    int count;//计数器，统计结点个数即线性队列的长度\npublic:\n    Queue();//构造函数\n    ~Queue();//析构函数\n    void clear(void);//清空链队\n    bool empty(void) const;//判断是否空队\n    bool retrieve(int &item) const;//读取队头\n    bool append(const int &item);//数据入队\n    bool serve();//数据出队\n};\n\n/*\n类Queue的实现部分\n*/\nQueue::Queue()//构造函数\n{\n    front=new node;//申请新结点，作为队头结点\n    front->next=NULL;\n    rear=front;//队尾指针指向队头\n    count=0;//计数器清零，队列开始时没有实际数据\n}\n\nQueue::~Queue()//析构函数\n{\n    clear();//删除所有数据，释放所有结点\n    delete front;//把头结点也释放掉\n    count=0;//计数器清零，队列开始时没有实际数据\n}\n\nvoid Queue::clear(void)//清空链队\n{\n    node *searchp=front->next,*followp=front;//初始化两个指针\n    while(searchp!=rear)\n    {\n        followp=searchp;\n        searchp=searchp->next;\n        delete followp;\n    }\n    front->next=NULL;//保留了最后一个结点，就是头结点，并且链域置为空\n    rear=front;\n    count=0;//计数器也清零\n}\n\nbool Queue::empty(void) const//判断是否空链\n{\n    return count==0?true:false;\n}\n\nbool Queue::retrieve(int &item) const//读取队头\n{\n    if(empty())//处理意外\n        return false;\n    item=front->next->data;//返回读取的数据\n    return true;//本次操作成功\n}\n\nbool Queue::append(const int &item)//进队\n{\n    node *newnodep=new node;\n    newnodep->data=item;//给数据赋值\n    rear->next=newnodep;//这一步可以看出有头结点\n    rear=rear->next;//改动队尾指针的位置\n    count++;//计数器加1\n    return true;\n}\n\nbool Queue::serve()//出队\n{\n    if(empty())//空队处理\n        return false;\n    node *tempp=front->next;\n//  item=tempp->data;//保存数据\n    front->next=tempp->next;//改变指针\n    delete tempp;//释放该结点\n    count--;//计数器减1\n    return true;\n}\n\n/*********************************************************************************************************\n*定义一个功能类NumSysConversion\n*********************************************************************************************************/\nclass NumSysConversion\n{\nprivate:\n    int inter;\n    float floater;\n    Stack *stack;\n    Queue *queue;\npublic:\n    NumSysConversion();//构造函数\n    ~NumSysConversion();//析构函数\n    bool check(char *array,int number);//检查输入数据是否符合要求\n    void change(char *array,int number);//将原始数据转化成数值\n    double change_to_aim(int tokind);//将原始数据转化成目标进制的数据\n};\n\nNumSysConversion::NumSysConversion()//构造函数\n{\n    stack=new Stack;\n    queue=new Queue;\n    inter=0;\n    floater=0;\n}\n\nNumSysConversion::~NumSysConversion()//析构函数\n{\n    delete stack;\n    delete queue;\n}\n\nbool NumSysConversion::check(char *array,int number)//检查输入数据是否符合要求\n{\n    bool flag=true;\n    for(int i=0;array[i]!='\\0';i++)\n    {\n        cout<=number)\n        {\n            flag=false;\n            break;\n        }\n    }\n    return flag;\n}\n\nvoid NumSysConversion::change(char *array,int number)//将原始数据转化成数值\n{\n    int flag=0,j=0;\n    for(int i=0;array[i]!='\\0';i++)\n    {\n        if(array[i]=='.')\n        {\n            flag=1;\n            continue;\n        }\n        if(flag==0)//取整数数据\n            inter=inter*number+array[i]-48;\n        if(flag==1)//取小数数据\n            floater+=(float)(((int)array[i]-48)*(float)pow(number,--j));\n    }\n}\n\ndouble NumSysConversion::change_to_aim(int tokind)//将原始数据转化成目标进制的数据\n{\n    int count=0,temp,flag=0,num;\n    double resnumb=0;\n    //第一步：先将整数部分转换进制后的数据依次入栈\n    while(inter)\n    {\n        num=inter%tokind;\n        stack->push(num);\n        inter/=tokind;\n    }\n    //第二步：再将小数部分转换进制后的数据依次入队\n    while(floater&&countappend(int(floater*tokind));\n        floater*=tokind;\n        if(floater>=1)\n            floater-=(int)floater;\n        count++;\n    }\n    //第三步：显示栈和队中的数据并将其转换成可用数据\n    cout<<\"数据转换后为：\";\n    while(!stack->empty())\n    {\n        stack->top(temp);\n        stack->pop();\n        cout<empty())\n    {\n        if(flag==0)\n            cout<<\"0\";\n        cout<<\".\";\n        count=-1;\n    }\n    while(!queue->empty())\n    {\n        queue->retrieve(temp);\n        queue->serve();\n        cout<clear();\n    queue->clear();\n    inter=0;\n    floater=0;\n    //第五步：将可用数据信息返回\n    return resnumb;\n}\n\n/*\n定义一个实现进制转换功能的菜单处理类interfacebase\n*/\nclass interfacebase\n{\nprivate:\n    NumSysConversion NumSysConversiononface;\npublic:\n    void clearscreen(void);//清屏\n    void showmenu(void);//显示菜单函数\n    int userchoice(void);//用户的选项\n    void processmenu(int menuchoice);//菜单函数\n};\n\n/*\n类interfacebase的实现部分\n*/\nvoid interfacebase::clearscreen(void)\n{\n    system(\"cls\");\n}\n\nvoid interfacebase::showmenu(void)\n{\n    cout<<\"进制转换功能菜单\"<>menuchoice;\n    return menuchoice;\n}\n\nvoid interfacebase::processmenu(int menuchoice)\n{\n    switch(menuchoice)//根据用户的选择进行相应的操作\n    {\n    case 1:\n        {\n            char array[10]={'0','.','1','2','5'};\n            int number=10;\n            if(NumSysConversiononface.check(array,number))\n                cout<<\"符合要求！\"<<endl;\n            else\n                cout<<\"不符合要求！\"<<endl;\n            NumSysConversiononface.change(array,number);\n            cout<<NumSysConversiononface.change_to_aim(2)<<endl;\n            cout<<\"进制转换成功！\"<<endl;\n        }\n        break;\n    case 2:\n        {\n            char array[10]={'1','1','1','1'};\n            int number=2;   \n            if(NumSysConversiononface.check(array,number))\n                cout<<\"符合要求！\"<<endl;\n            else\n                cout<<\"不符合要求！\"<<endl;\n            NumSysConversiononface.change(array,number);\n            cout<<NumSysConversiononface.change_to_aim(10)<<endl;\n            cout<<\"进制转换成功！\"<<endl;\n        }\n        break;\n    case 0:\n        exit(0);\n    default:\n        cout<<\"对不起，您输入的功能编号有错！请重新输入！！！\"<<endl;\n        break;\n    }\n}\n\n/*\n程序主入口\n*/\nvoid main(void)\n{\n    int menuchoice;//定义变量，菜单选单项的选择\n    interfacebase interfacenow;\n    system(\"color f0\");//修改屏幕的背景色和字的颜色\n    interfacenow.clearscreen();//清屏\n    while(1)//永真循环\n    {\n        interfacenow.showmenu();//显示菜单\n        menuchoice=interfacenow.userchoice();//获取用户的选择\n        interfacenow.processmenu(menuchoice);//处理用户的选择\n        system(\"pause\");//暂停\n        interfacenow.clearscreen();//清屏\n    }\n}//主函数结束\n\n", "Tag": "算法分析"}
{"Answer": "\nchar sex;\t//性别\n\nprintf(\" 性别:\");\n    scanf_s(\"%s\", &e->sex, 3);\n\n printf_s(\"学号：%d 姓名：%s 性别：%s 年龄：%d 籍贯：%s 体重：%f 身高：%f 生日：%d 宿舍：%d\", e.num, &e.name, e.sex, e.age, &e.place, e.weight, e.height, e.birthday, e.dormitory);\n好像是你的性别是char型，但是在输出时的性别是%s，你改成%c试一试。\n而且，你在输入性别的时候也不太对。\n看起来可能是这个问题，你可以修改试一试", "Konwledge_Point": "线性规划和规约", "Question": "线性表实现学生信息表，运行时出现问题不知道怎么解决\n这是题目内容：\n\n\n\n用线性数组做一个班级学生档案记录的程序，要求：\n\n\n\n    1）用结构体表示学生记录，包括但不限于：学号、姓名、性别、班级、生日、宿舍、籍贯等信息；\n\n\n\n    2）学生记录用数组存储，按照学号递增顺序记录；\n\n\n\n    3）学生记录插入：插入包括自己在内的10名学生；\n\n\n\n    4）学生记录删除：删除指定位置学生；\n\n\n\n    5）查找学生：根据姓名查找学生在记录中的位序；\n\n\n\n\n\n\n#include  \n#include  \n#include  \n#include  \n#define OK 1  \n#define ERROR 0  \n#define OVERFLOW -2  \n#define MAXSIZE 1000 \ntypedef int Status; // 定义函数返回值类型  \ntypedef struct\n{\n    int num;\t\t//学号\n    char name[20];\t//姓名\n    char sex;\t\t//性别\n    int age;\t\t//年龄\n    char place[10];\t//籍贯\n    float weight;\t//体重\n    float height;\t//身高\n    int birthday;\t//生日\n    int dormitory;\t//宿舍\n}student;\ntypedef student ElemType;\ntypedef struct\n{\n    ElemType* elem; // 存储空间的基地址   \n    int length; // 当前长度   \n}SqList;\nStatus InitList(SqList* L) // 构造空的顺序表 L   \n{\n    L->elem = (ElemType*)malloc(sizeof(ElemType) * MAXSIZE);\n    if (!L->elem)  exit(OVERFLOW);  \t\t//分配失败退出 \n    L->length = 0;  \t\t//长度为0 \n    return OK;\n}\nElemType GetElem(SqList& L, int i) // 访问顺序表，找到 i位置，返回给 e  \n{\n    return L.elem[i];\n}\nint Search(SqList& L, char str[]) // 根据名字查找，返回该同学在顺序表中的编号   \n{\n    for (int i = 1;i <= L.length;i++)  \t//查找成功，返回序号 i+1\n    {\n        if (strcmp(L.elem[i].name, str) == 0)\n            return i;\n    }\n    return 0;\n}\nStatus ListInsert(SqList& L, int i, ElemType e) // 在 i位置插入某个学生的信息   \n{\n    if ((i < 1) || (i > L.length + 1)) return ERROR;\n    if (L.length == MAXSIZE)   return ERROR;\n    for (int j = L.length;j >= i;j--)\n    {\n        L.elem[j + 1] = L.elem[j];  \t//插入位置及之后的元素后移\n    }\n    L.elem[i] = e;  \t\t//将新元素e放入第i个位置\n    ++L.length;\n    return OK;\n}\nStatus ListDelete(SqList& L, int i) // 在顺序表中删除 i位置的学生信息   \n{\n    if ((i < 1) || (i > L.length))   return ERROR;\n    for (int j = i;j <= L.length;j++)\n    {\n        L.elem[j] = L.elem[j + 1];  \t//被删除元素之后的元素前移\n    }\n    --L.length;  \t//长度减一 \n    return OK;\n}\nvoid Input(ElemType* e)  \t\t//输入 \n{\n    printf(\" 学号:\");\n    scanf_s(\"%d\", &e->num);\n    printf(\" 姓名:\");\n    scanf_s(\"%s\", e->name, 4);\n    printf(\" 性别:\");\n    scanf_s(\"%s\", &e->sex, 3);\n    printf(\" 年龄:\");\n    scanf_s(\"%d\", &e->age);\n    printf(\" 籍贯:\");\n    scanf_s(\"%s\", e->place, 20);\n    printf(\" 体重:\");\n    scanf_s(\"%f\", &e->weight);\n    printf(\" 身高:\");\n    scanf_s(\"%f\", &e->height);\n    printf(\" 生日:\");\n    scanf_s(\"%d\", &e->birthday);\n    printf(\" 宿舍:\");\n    scanf_s(\"%d\", &e->dormitory);\n    printf(\"输入完成\\n\\n\");\n}\nvoid Output(ElemType& e)  \t\t//输出 \n{\n    printf_s(\"学号：%d 姓名：%s 性别：%s 年龄：%d 籍贯：%s 体重：%f 身高：%f 生日：%d 宿舍：%d\", e.num, &e.name, e.sex, e.age, &e.place, e.weight, e.height, e.birthday, e.dormitory);\n}\nint main()\n{\n    SqList L ;\n    ElemType a, b, c, d;\n    printf(\"1. 构造顺序表\\n\");\n    printf(\"2. 录入指定人数的学生信息\\n\");\n    printf(\"3. 显示学生表中的所有信息\\n\");\n    printf(\"4. 根据姓名查找该学生，并返回学号和成绩\\n\");\n    printf(\"5. 根据某指定位置显示该学生信息\\n\");\n    printf(\"6. 在指定位置插入学生信息\\n\");\n    printf(\"7. 在指定位置删除学生信息\\n\");\n    printf(\"8. 统计学生个数\\n\");\n    printf(\"0. 退出\\n\");\n    int x = 0, choose;\n    while (1)\n    {\n        printf(\"请输入你要选择的功能前的序号:\");\n        scanf_s(\"%d\", &choose);\n        if (choose == 0)   break;\n        switch (choose)\n        {\n        case 1:\n            if (InitList(&L))\n                printf(\"成功建立顺序表\\n\");\n            else\n                printf(\"顺序表建立失败\\n\");\n            break;\n        case 2:\n            printf(\"请输入要录入学生的人数:\");\n            scanf_s(\"%d\", &x);\n            for (int i = 1;i <= x;i++)\n            {\n                printf(\"第%d个学生:\\n\", i);\n                Input(&L.elem[i]);\n            }\n            L.length = x;\n            break;\n        case 3:\n            for (int i = 1;i <= x;i++)\n            {\n                a = GetElem(L, i);\n                Output(a);\n            }\n            break;\n        case 4:\n            char s[20];\n            printf(\"请输入要查找的学生姓名:\");\n            scanf_s(\"%s\", s, 4);\n            if (Search(L, s))\n                Output(L.elem[Search(L, s)]);\n            else\n                printf(\"对不起，查无此人\\n\");\n            printf_s(\"\");\n            break;\n        case 5:\n            printf_s(\"请输入要查询的位置:\");\n            int id1;\n            scanf_s(\"%d\", &id1);\n            b = GetElem(L, id1);\n            Output(b);\n            break;\n        case 6:\n            printf(\"请输入要插入的位置:\");\n            int id2;\n            scanf_s(\"%d\", &id2);\n            printf(\"请输入学生信息:\\n\");\n            Input(&c);\n            if (ListInsert(L, id2, c))\n            {\n                x++;\n                printf(\"插入成功\\n\");\n            }\n            else\n            {\n                printf(\"插入失败\\n\");\n            }\n            break;\n        case 7:\n            printf(\"请输入要删除的位置:\");\n            int id3;\n            scanf_s(\"%d\", &id3);\n            if (ListDelete(L, id3))\n            {\n                x--;\n                printf(\"删除成功\\n\");\n            }\n            else\n            {\n                printf(\"删除失败\\n\");\n            }\n            break;\n        case 8:\n            printf(\"已录入的学生个数为:%d\\n\\n\", L.length);\n            break;\n        }\n    }\n    printf(\"\\n\\n请按任意键退出\\n\\n\");\n    return 0;\n}\n\n\n\n\n可以正常编译，选择1和选择2可以使用，但是其他选择在运行的时候会出问题，不知道怎么修改。\n\n\n\n    运行选择三的时候会出现（引发了异常: 读取访问权限冲突），不知道为什么", "Tag": "算法分析"}
{"Answer": "以下答案引用自GPT-3大模型,请合理使用：\n可以使用R中的glm函数来建立多元线性模型，在建立模型时添加类别和产地变量即可。比如：\n\nmodel<-glm(price~category+origin,data=your_data)\n\n#用上面的模型，我们可以同时考虑分类和产地因素影响价格的情况。\n\nsummary(model) #用这个函数可以对模型进行参数估计\n\nanova(model) #用这个函数可以检验因素对结果的显著性\n\n如果我的回答解决了您的问题，请采纳我的回答", "Konwledge_Point": "线性规划和规约", "Question": "多个固定效应用R语言怎么处理\n研究问题是研究商品定价和一系列变量间的关系，所有自变量和固定效应都是类别变量。现在想要同时固定“类别”和“产地”，想请教一下用R怎么实现哇🥺", "Tag": "算法分析"}
{"Answer": "就是把文件加载进来，将YUV数据转换成RGB颜色，然后用drawImage画出来", "Konwledge_Point": "线性规划和规约", "Question": "一段视频播放器文件代码，不明白\n代码如下：\nimport java.io.\n;\nimport java.util.TreeSet;\nimport java.awt.\n;\nimport java.awt.event.\n;\nimport java.awt.geom.AffineTransform;\nimport java.awt.image.\n;\nimport javax.imageio.\n;\nimport javax.swing.\n;\n\n\npublic class design1  extends Component {\n    DataInputStream data_in;\n    private byte[] yuv_array;\n    private int[] u_array, v_array;\n    private int[] rgb_array;\n    private BufferedImage img;\n    private int width, height;\n    private int frame_number;\n    private int frame_size, yuv_frame_size;\n\n\npublic\n \ndesign1\n(String filename, \nint\n width, \nint\n height, \nint\n frame_number)\n {\n    \nthis\n.width = width;\n    \nthis\n.height = height;\n    frame_size = width * height;\n    \nthis\n.frame_number = frame_number;\n    yuv_frame_size = (width * height * \n3\n)>>\n1\n;\n    \n//在Heap分配空间\n\n    img = \nnew\n \nBufferedImage\n(width, height, \n1\n);\n//1:TYPE_INT_RGB\n\n    yuv_array = \nnew\n \nbyte\n[yuv_frame_size];\n    u_array = \nnew\n \nint\n[frame_size];\n    v_array = \nnew\n \nint\n[frame_size];\n    rgb_array = \nnew\n \nint\n[frame_size];\n    \n    \ntry\n {\n        \nFileInputStream\n \nf_in\n \n=\n \nnew\n \nFileInputStream\n(\nnew\n \nFile\n(filename));\n        f_in.skip(frame_number * yuv_frame_size);\n        data_in = \nnew\n \nDataInputStream\n(f_in);\n        data_in.read(yuv_array, \n0\n, yuv_frame_size);\n        \nthis\n.frame_number++;\n    } \ncatch\n (IOException e) {  \n        \n// TODO Auto-generated catch block  \n\n        e.printStackTrace();  \n    }\n    yuv2rgb();\n    img.setRGB(\n0\n, \n0\n, width, height, rgb_array, \n0\n, width);\n}\n\n\nprivate\n \nvoid\n \nyuv2rgb\n()\n\n{\n    \nint\n h;\n    \nint\n h2;\n    \nint\n \nframe_size2\n \n=\n frame_size + (frame_size>>\n2\n);\n    \nint\n \nwidth2\n \n=\n width<<\n1\n;\n    \nint\n i2, j2;\n    \n    h = \n0\n;\n    h2 = \n0\n;\n    \nfor\n (\nint\n \nj\n \n=\n \n0\n; j < (height>>\n1\n); j++)\n    {\n        \nfor\n (\nint\n \ni\n \n=\n \n0\n; i < (width>>\n1\n); i++)\n        {\n            i2 = i<<\n1\n;\n            \nint\n a, b;\n            u_array[h2 + i2]   = yuv_array[frame_size + h + i]&\n0xff\n;\n            v_array[h2 + i2]   = yuv_array[frame_size2 + h + i]&\n0xff\n;\n        }\n        h += width>>\n1\n;\n        h2 += width2;\n    }\n    \n//执行双线性内插，把4:1:1的YUV扩大为4:4:4的YUV\n\n    h2 = \n0\n;\n    \nfor\n (j2 = \n0\n; j2 < height - \n2\n; j2 += \n2\n)\n    {\n        \nfor\n (i2 = \n0\n; i2 < width - \n2\n; i2 += \n2\n)\n        {\n            \nint\n a, b, ab;\n            \n            a = u_array[h2 + i2] + u_array[h2 + i2 + \n2\n];\n//水平\n\n            b = u_array[h2 + i2] + u_array[h2 + i2 + width2];\n//垂直\n\n            ab = u_array[h2 + i2] + u_array[h2 + i2 + \n2\n] + u_array[h2 + i2 + width2] + u_array[h2 + i2 + width2 + \n2\n];\n//对角线\n\n            u_array[h2 + i2 + \n1\n] = (a + \n1\n)>>\n1\n;\n            u_array[h2 + i2 + width] = (b + \n1\n)>>\n1\n;\n            u_array[h2 + i2 + width + \n1\n] = (ab + \n2\n)>>\n2\n;\n            \n            a = v_array[h2 + i2] + v_array[h2 + i2 + \n2\n];\n//水平\n\n            b = v_array[h2 + i2] + v_array[h2 + i2 + width2];\n//垂直\n\n            ab = v_array[h2 + i2] + v_array[h2 + i2 + \n2\n] + v_array[h2 + i2 + width2] + v_array[h2 + i2 + width2 + \n2\n];\n//对角线\n\n            v_array[h2 + i2 + \n1\n] = (a + \n1\n)>>\n1\n;\n            v_array[h2 + i2 + width] = (b + \n1\n)>>\n1\n;\n            v_array[h2 + i2 + width + \n1\n] = (ab + \n2\n)>>\n2\n;\n        }\n        u_array[h2 + i2 + \n1\n] = u_array[h2 + i2];\n        u_array[h2 + i2 + width] = \n        u_array[h2 + i2 + width + \n1\n] = (u_array[h2 + i2] + u_array[h2 + i2 + width2] + \n1\n)>>\n1\n;\n        \n        v_array[h2 + i2 + \n1\n] = v_array[h2 + i2];\n        v_array[h2 + i2 + width] = \n        v_array[h2 + i2 + width + \n1\n] = (v_array[h2 + i2] + v_array[h2 + i2 + width2] + \n1\n)>>\n1\n;\n        \n        h2 += width2;\n    }\n    \nfor\n (i2 = \n0\n; i2 < width - \n2\n; i2 += \n2\n)\n    {\n        \nint\n a, b, ab;\n        \n        u_array[h2 + i2 + \n1\n] = \n        u_array[h2 + i2 + width + \n1\n] = (u_array[h2 + i2] + u_array[h2 + i2 + \n2\n] + \n1\n)>>\n1\n;\n        u_array[h2 + i2 + width] = u_array[h2 + i2];\n        \n        v_array[h2 + i2 + \n1\n] = \n        v_array[h2 + i2 + width + \n1\n] = (v_array[h2 + i2] + v_array[h2 + i2 + \n2\n] + \n1\n)>>\n1\n;\n        v_array[h2 + i2 + width] = v_array[h2 + i2];\n    }\n    u_array[h2 + i2 + \n1\n] =\n    u_array[h2 + i2 + width] = \n    u_array[h2 + i2 + width + \n1\n] = u_array[h2 + i2];       \n    \n    v_array[h2 + i2 + \n1\n] =\n    v_array[h2 + i2 + width] = \n    v_array[h2 + i2 + width + \n1\n] = v_array[h2 + i2];\n    \n    \n//彩色空间变换,从YUV转换到RGB\n\n    \nfor\n (\nint\n \ni\n \n=\n \n0\n; i < frame_size; i++)\n    {\n        \nint\n pixel_r, pixel_g, pixel_b;\n        \nint\n \npixel_y\n \n=\n yuv_array[i]&\n0xff\n;\n        \nint\n \npixel_u\n \n=\n u_array[i] - \n128\n;\n        \nint\n \npixel_v\n \n=\n v_array[i] - \n128\n;\n        \n//YUV到RGB的矩阵变换运算\n\n        \ndouble\n \nR\n \n=\n pixel_y - \n0.001\n * pixel_u + \n1.402\n * pixel_v;\n        \ndouble\n \nG\n \n=\n pixel_y - \n0.344\n * pixel_u - \n0.714\n * pixel_v;\n        \ndouble\n \nB\n \n=\n pixel_y + \n1.772\n * pixel_u + \n0.001\n * pixel_v;\n        \n//限幅\n\n        \nif\n (R > \n255\n) pixel_r = \n255\n;\n        \nelse\n \nif\n (R < \n0\n) pixel_r = \n0\n;\n        \nelse\n \npixel_r\n \n=\n (\nint\n)R;\n        \nif\n (G > \n255\n) pixel_g = \n255\n;\n        \nelse\n \nif\n (G < \n0\n) pixel_g = \n0\n;\n        \nelse\n \npixel_g\n \n=\n (\nint\n)G;\n        \nif\n (B > \n255\n) pixel_b = \n255\n;\n        \nelse\n \nif\n (B < \n0\n) pixel_b = \n0\n;\n        \nelse\n \npixel_b\n \n=\n (\nint\n)B;\n        rgb_array[i] = (pixel_r<<\n16\n) | (pixel_g<<\n8\n) | pixel_b;\n    }\n}\n\n\npublic\n Dimension \ngetPreferredSize\n()\n {\n    \nif\n (img == \nnull\n) {\n         \nreturn\n \nnew\n \nDimension\n(width, height);\n    } \nelse\n {\n       \nreturn\n \nnew\n \nDimension\n(img.getWidth(\nnull\n), img.getHeight(\nnull\n));\n   }\n}\n\n\npublic\n \nvoid\n \nwriteFile\n(String formatName, String filename)\n {\n    \ntry\n {\n        ImageIO.write(img, formatName, \nnew\n \nFile\n(filename));\n    } \ncatch\n (IOException e) {\n        e.printStackTrace();  \n    }\n}\n\n\npublic\n \nvoid\n \npaint\n(Graphics g)\n {\n    g.drawImage(img, \n0\n, \n0\n, \nnull\n);\n}\n\n\npublic\n \nvoid\n \nplay\n(JFrame f)\n {\n    \nwhile\n(\ntrue\n){\n        \ntry\n {\n            data_in.read(yuv_array, \n0\n, yuv_frame_size);\n            f.setTitle(\n\"YUV Player of GDUT              #\"\n + frame_number + \n\" frames\"\n);\n            frame_number++;\n        } \ncatch\n (IOException e) {  \n            \n// TODO Auto-generated catch block  \n\n            e.printStackTrace();\n        }\n        yuv2rgb();\n        img.setRGB(\n0\n, \n0\n, width, height, rgb_array, \n0\n, width);\n        repaint(); \n    }\n}\n\n\npublic\n \nstatic\n \nvoid\n \nmain\n(String[] args)\n {\n    \n// TODO Auto-generated method stub\n\n    \nJFrame\n \nf\n \n=\n \nnew\n \nJFrame\n(\n\"YUV Player of GDUT\"\n);\n    f.addWindowListener(\nnew\n \nWindowAdapter\n() {\n        \npublic\n \nvoid\n \nwindowClosing\n(WindowEvent e)\n {System.exit(\n0\n);}\n    });\n\n    \n    \ndesign1\n \nme\n \n=\n \nnew\n \ndesign1\n(\n\"ShuttleStart_1280x720.yuv\"\n, \n1280\n, \n720\n, \n10\n);        \n    f.add(\n\"Center\"\n, me);\n    f.pack();\n    f.setVisible(\ntrue\n);\n\n    \n//me.writeFile(\"jpg\", \"out.jpg\");\n\n    \n//me.play(f);//连续读取并显示图像\n\n}\n\n\n\n}", "Tag": "算法分析"}
{"Answer": "看错误是g2o的依赖问题，检查下是否正确安装，在makelist中的依赖引入写法是否正确等。", "Konwledge_Point": "线性规划和规约", "Question": "视觉SLAM十四讲ch6\n视觉SLAM十四讲ch6程序g2oCurveFitting编译问题\n我的系统是Ubuntu22.04，g2o库是最新版\n\n\nCMakeLists如下：\n\n\ncmake_minimum_required\n(VERSION \n2.8\n)\n\nproject\n(ch6)\n\n\nset\n(CMAKE_BUILD_TYPE Debug)\n\nset\n(CMAKE_CXX_FLAGS \n\"-std=c++14 -O3\"\n)\n\n\nlist\n(APPEND CMAKE_MODULE_PATH \n${PROJECT_SOURCE_DIR}\n/cmake)\n\n\n# OpenCV\n\n\nfind_package\n(OpenCV REQUIRED)\n\ninclude_directories\n(\n${OpenCV_INCLUDE_DIRS}\n)\n\n\n# Ceres\n\n\nfind_package\n(Ceres REQUIRED)\n\ninclude_directories\n(\n${CERES_INCLUDE_DIRS}\n)\n\n\n# g2o\n\n\nfind_package\n(G2O REQUIRED)\n\ninclude_directories\n(\n${G2O_INCLUDE_DIRS}\n)\n\n\n# Eigen\n\n\ninclude_directories\n(\n\"/usr/include/eigen3\"\n)\n\n\nadd_executable\n(gaussNewton gaussNewton.cpp)\n\ntarget_link_libraries\n(gaussNewton \n${OpenCV_LIBS}\n)\n\n\nadd_executable\n(ceresCurveFitting ceresCurveFitting.cpp)\n\ntarget_link_libraries\n(ceresCurveFitting \n${OpenCV_LIBS}\n \n${CERES_LIBRARIES}\n)\n\n\nadd_executable\n(g2oCurveFitting g2oCurveFitting.cpp)\n\ntarget_link_libraries\n(g2oCurveFitting \n${OpenCV_LIBS}\n \n${G2O_CORE_LIBRARIES}\n \n${G2O_SOLVERS_LIBRARIES}\n)\n\n\n\ng2oCurveFitting.cpp如下：\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n\nusing\n \nnamespace\n std;\n\n\n// 曲线模型的顶点，模板参数：优化变量维度和数据类型\n\n\nclass\n \nCurveFittingVertex\n : \npublic\n g2o::BaseVertex<\n3\n, Eigen::Vector3d> {\n\npublic\n:\n  EIGEN_MAKE_ALIGNED_OPERATOR_NEW\n\n  \n// 重置\n\n  \nvirtual\n \nvoid\n \nsetToOriginImpl\n()\n \noverride\n \n{\n    _estimate << \n0\n, \n0\n, \n0\n;\n  }\n\n  \n// 更新\n\n  \nvirtual\n \nvoid\n \noplusImpl\n(\nconst\n \ndouble\n *update)\n \noverride\n \n{\n    _estimate += Eigen::\nVector3d\n(update);\n  }\n\n  \n// 存盘和读盘：留空\n\n  \nvirtual\n \nbool\n \nread\n(istream ∈)\n \n{}\n\n  \nvirtual\n \nbool\n \nwrite\n(ostream &out)\n \nconst\n \n{}\n};\n\n\n// 误差模型 模板参数：观测值维度，类型，连接顶点类型\n\n\nclass\n \nCurveFittingEdge\n : \npublic\n g2o::BaseUnaryEdge<\n1\n, \ndouble\n, CurveFittingVertex> {\n\npublic\n:\n  \nEIGEN_MAKE_ALIGNED_OPERATOR_NEW\n\n  \nCurveFittingEdge\n(\ndouble\n x)\n : BaseUnaryEdge(), _x(x) {\n}\n\n  \n// 计算曲线模型误差\n\n  \nvirtual\n \nvoid\n \ncomputeError\n()\n \noverride\n \n{\n    \nconst\n CurveFittingVertex *v = \nstatic_cast\n<\nconst\n CurveFittingVertex *> (_vertices[\n0\n]);\n    \nconst\n Eigen::Vector3d abc = v->\nestimate\n();\n    _error(\n0\n, \n0\n) = _measurement - std::\nexp\n(\nabc\n(\n0\n, \n0\n) * _x * _x + \nabc\n(\n1\n, \n0\n) * _x + \nabc\n(\n2\n, \n0\n));\n  }\n\n  \n// 计算雅可比矩阵\n\n  \nvirtual\n \nvoid\n \nlinearizeOplus\n()\n \noverride\n \n{\n    \nconst\n CurveFittingVertex *v = \nstatic_cast\n<\nconst\n CurveFittingVertex *> (_vertices[\n0\n]);\n    \nconst\n Eigen::Vector3d abc = v->\nestimate\n();\n    \ndouble\n y = \nexp\n(abc[\n0\n] * _x * _x + abc[\n1\n] * _x + abc[\n2\n]);\n    _jacobianOplusXi[\n0\n] = -_x * _x * y;\n    _jacobianOplusXi[\n1\n] = -_x * y;\n    _jacobianOplusXi[\n2\n] = -y;\n  }\n\n  \nvirtual\n \nbool\n \nread\n(istream ∈)\n \n{}\n\n  \nvirtual\n \nbool\n \nwrite\n(ostream &out)\n \nconst\n \n{}\n\n\npublic\n:\n  \ndouble\n _x;  \n// x 值， y 值为 _measurement\n\n};\n\n\nint\n \nmain\n(\nint\n argc, \nchar\n **argv)\n \n{\n  \ndouble\n ar = \n1.0\n, br = \n2.0\n, cr = \n1.0\n;         \n// 真实参数值\n\n  \ndouble\n ae = \n2.0\n, be = \n-1.0\n, ce = \n5.0\n;        \n// 估计参数值\n\n  \nint\n N = \n100\n;                                 \n// 数据点\n\n  \ndouble\n w_sigma = \n1.0\n;                        \n// 噪声Sigma值\n\n  \ndouble\n inv_sigma = \n1.0\n / w_sigma;\n  cv::RNG rng;                                 \n// OpenCV随机数产生器\n\n\n  vector<\ndouble\n> x_data, y_data;      \n// 数据\n\n  \nfor\n (\nint\n i = \n0\n; i < N; i++) {\n    \ndouble\n x = i / \n100.0\n;\n    x_data.\npush_back\n(x);\n    y_data.\npush_back\n(\nexp\n(ar * x * x + br * x + cr) + rng.\ngaussian\n(w_sigma * w_sigma));\n  }\n\n  \n// 构建图优化，先设定g2o\n\n  \ntypedef\n g2o::BlockSolver> BlockSolverType;  \n// 每个误差项优化变量维度为3，误差值维度为1\n\n  \ntypedef\n g2o::LinearSolverDense LinearSolverType; \n// 线性求解器类型\n\n\n  \n// 梯度下降方法，可以从GN, LM, DogLeg 中选\n\n  \nauto\n solver = \nnew\n g2o::\nOptimizationAlgorithmGaussNewton\n(\n    g2o::\nmake_unique\n(g2o::\nmake_unique\n()));\n  g2o::SparseOptimizer optimizer;     \n// 图模型\n\n  optimizer.\nsetAlgorithm\n(solver);   \n// 设置求解器\n\n  optimizer.\nsetVerbose\n(\ntrue\n);       \n// 打开调试输出\n\n\n  \n// 往图中增加顶点\n\n  CurveFittingVertex *v = \nnew\n \nCurveFittingVertex\n();\n  v->\nsetEstimate\n(Eigen::\nVector3d\n(ae, be, ce));\n  v->\nsetId\n(\n0\n);\n  optimizer.\naddVertex\n(v);\n\n  \n// 往图中增加边\n\n  \nfor\n (\nint\n i = \n0\n; i < N; i++) {\n    CurveFittingEdge *edge = \nnew\n \nCurveFittingEdge\n(x_data[i]);\n    edge->\nsetId\n(i);\n    edge->\nsetVertex\n(\n0\n, v);                \n// 设置连接的顶点\n\n    edge->\nsetMeasurement\n(y_data[i]);      \n// 观测数值\n\n    edge->\nsetInformation\n(Eigen::Matrix<\ndouble\n, \n1\n, \n1\n>::\nIdentity\n() * \n1\n / (w_sigma * w_sigma)); \n// 信息矩阵：协方差矩阵之逆\n\n    optimizer.\naddEdge\n(edge);\n  }\n\n  \n// 执行优化\n\n  cout << \n\"start optimization\"\n << endl;\n  chrono::steady_clock::time_point t1 = chrono::steady_clock::\nnow\n();\n  optimizer.\ninitializeOptimization\n();\n  optimizer.\noptimize\n(\n10\n);\n  chrono::steady_clock::time_point t2 = chrono::steady_clock::\nnow\n();\n  chrono::duration<\ndouble\n> time_used = chrono::duration_cast>(t2 - t1);\n  cout << \n\"solve time cost = \"\n << time_used.\ncount\n() << \n\" seconds. \"\n << endl;\n\n  \n// 输出优化值\n\n  Eigen::Vector3d abc_estimate = v->\nestimate\n();\n  cout << \n\"estimated model: \"\n << abc_estimate.\ntranspose\n() << endl;\n\n  \nreturn\n \n0\n;\n}\n\n\n\n\nmake编译出错：\n\n\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: warning: relocation against `_ZN3g2o18G2OBatchStatistics12_globalStatsE' \nin\n read-only section `.text._ZN3g2o11BlockSolverINS_17BlockSolverTraitsILi3ELi1EEEE5solveEv[_ZN3g2o11BlockSolverINS_17BlockSolverTraitsILi3ELi1EEEE5solveEv]'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: \nin\n function `g2o::BaseEdge<\n1\n, double>::~\nBaseEdge\n()':\n/usr/local/include/g2o/core/base_edge.h:\n96\n: undefined reference to `g2o::OptimizableGraph::Edge::~\nEdge\n()'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: \nin\n function `non-\nvirtual\n thunk to CurveFittingEdge::~\nCurveFittingEdge\n()':\n/usr/local/include/g2o/core/base_edge.h:\n96\n: undefined reference to `g2o::OptimizableGraph::Edge::~\nEdge\n()'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: \nin\n function `g2o::BaseEdge<\n1\n, double>::~\nBaseEdge\n()':\n/usr/local/include/g2o/core/base_edge.h:\n96\n: undefined reference to `g2o::OptimizableGraph::Edge::~\nEdge\n()'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: \nin\n function `non-\nvirtual\n thunk to CurveFittingEdge::~\nCurveFittingEdge\n()':\n/usr/include/eigen3/Eigen/src/Core/util/Memory.h:\n203\n: undefined reference to `g2o::OptimizableGraph::Edge::~\nEdge\n()'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: \nin\n function `g2o::BaseFixedSizedEdge<\n1\n, double, CurveFittingVertex>::\nresize\n(unsigned long)':\n/usr/local/include/g2o/core/base_fixed_sized_edge.hpp:\n31\n: undefined reference to `g2o::HyperGraph::Edge::\nresize\n(unsigned long)'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: \nin\n function `g2o::BlockSolver >::\ncomputeMarginals\n(g2o::SparseBlockMatrix >&, std::vector, std::allocator > > \nconst\n&)':\n/usr/local/include/g2o/core/block_solver.hpp:\n485\n: undefined reference to `g2o::\nget_monotonic_time\n()'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: \nin\n function `g2o::G2OBatchStatistics::\nglobalStats\n()':\n/usr/local/include/g2o/core/batch_stats.h:\n79\n: undefined reference to `g2o::G2OBatchStatistics::_globalStats'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: \nin\n function `g2o::BlockSolver >::\ncomputeMarginals\n(g2o::SparseBlockMatrix >&, std::vector, std::allocator > > \nconst\n&)':\n/usr/local/include/g2o/core/block_solver.hpp:\n489\n: undefined reference to `g2o::\nget_monotonic_time\n()'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: \nin\n function `g2o::BaseVertex<\n3\n, Eigen::Matrix >::~\nBaseVertex\n()':\n/usr/local/include/g2o/core/base_vertex.h:\n50\n: undefined reference to `g2o::OptimizableGraph::Vertex::~\nVertex\n()'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: \nin\n function `non-\nvirtual\n thunk to CurveFittingVertex::~\nCurveFittingVertex\n()':\n/usr/local/include/g2o/core/base_vertex.h:\n50\n: undefined reference to `g2o::OptimizableGraph::Vertex::~\nVertex\n()'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: \nin\n function `g2o::BaseVertex<\n3\n, Eigen::Matrix >::~\nBaseVertex\n()':\n/usr/local/include/g2o/core/base_vertex.h:\n50\n: undefined reference to `g2o::OptimizableGraph::Vertex::~\nVertex\n()'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: \nin\n function `non-\nvirtual\n thunk to CurveFittingVertex::~\nCurveFittingVertex\n()':\n/usr/include/eigen3/Eigen/src/Core/util/Memory.h:\n203\n: undefined reference to `g2o::OptimizableGraph::Vertex::~\nVertex\n()'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: \nin\n function `g2o::BlockSolverBase::\nBlockSolverBase\n()':\n/usr/local/include/g2o/core/block_solver.h:\n90\n: undefined reference to `g2o::Solver::\nSolver\n()'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: \nin\n function `g2o::BlockSolverBase::~\nBlockSolverBase\n()':\n/usr/local/include/g2o/core/block_solver.h:\n92\n: undefined reference to `g2o::Solver::~\nSolver\n()'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: \nin\n function `g2o::BlockSolver >::\nresize\n(int*, int, int*, int, int)':\n/usr/local/include/g2o/core/block_solver.hpp:\n56\n: undefined reference to `g2o::Solver::\nresizeVector\n(unsigned long)'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: \nin\n function `g2o::BaseEdge<\n1\n, double>::~\nBaseEdge\n()':\n/usr/local/include/g2o/core/base_edge.h:\n96\n: undefined reference to `g2o::OptimizableGraph::Edge::~\nEdge\n()'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: \nin\n function `main.cold':\n/home/zsh/VSLAM/Programs/Notmycode/slambook2/ch6/g2oCurveFitting.cpp:\n126\n: undefined reference to `g2o::SparseOptimizer::~\nSparseOptimizer\n()'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: \nin\n function `g2o::BlockSolver >::\nsolve\n()':\n/usr/local/include/g2o/core/block_solver.hpp:\n346\n: undefined reference to `g2o::\nget_monotonic_time\n()'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: \nin\n function `g2o::G2OBatchStatistics::\nglobalStats\n()':\n/usr/local/include/g2o/core/batch_stats.h:\n79\n: undefined reference to `g2o::G2OBatchStatistics::_globalStats'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: \nin\n function `g2o::BlockSolver >::\nsolve\n()':\n/usr/local/include/g2o/core/block_solver.hpp:\n436\n: undefined reference to `g2o::\nget_monotonic_time\n()'\n/usr/bin/ld: /usr/local/include/g2o/core/block_solver.hpp:\n439\n: undefined reference to `g2o::\nget_monotonic_time\n()'\n/usr/bin/ld: /usr/local/include/g2o/core/block_solver.hpp:\n442\n: undefined reference to `g2o::\nget_monotonic_time\n()'\n/usr/bin/ld: /usr/local/include/g2o/core/block_solver.hpp:\n332\n: undefined reference to `g2o::\nget_monotonic_time\n()'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: \nin\n function `g2o::G2OBatchStatistics::\nglobalStats\n()':\n/usr/local/include/g2o/core/batch_stats.h:\n79\n: undefined reference to `g2o::G2OBatchStatistics::_globalStats'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: \nin\n function `g2o::BlockSolver >::\nsolve\n()':\n/usr/local/include/g2o/core/block_solver.hpp:\n336\n: undefined reference to `g2o::\nget_monotonic_time\n()'\n/usr/bin/ld: /usr/local/include/g2o/core/block_solver.hpp:\n439\n: undefined reference to `g2o::\nget_monotonic_time\n()'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: \nin\n function `g2o::BlockSolver >::\nupdateStructure\n(std::vector > \nconst\n&, std::set, std::allocator > \nconst\n&)':\n/usr/local/include/g2o/core/block_solver.hpp:\n292\n: undefined reference to `g2o::Solver::\nresizeVector\n(unsigned long)'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: \nin\n function `std::__cxx11::basic_string<\nchar\n, std::char_traits<\nchar\n>, std::allocator<\nchar\n> >* google::MakeCheckOpString(unsigned long \nconst\n&, unsigned long \nconst\n&, \nchar\n \nconst\n*)':\n/usr/include/glog/logging.h:\n694\n: undefined reference to `google::base::CheckOpMessageBuilder::\nCheckOpMessageBuilder\n(\nchar\n \nconst\n*)'\n/usr/bin/ld: /usr/include/glog/logging.h:\n696\n: undefined reference to `google::base::CheckOpMessageBuilder::\nForVar2\n()'\n/usr/bin/ld: /usr/include/glog/logging.h:\n697\n: undefined reference to `google::base::CheckOpMessageBuilder::NewString[abi:cxx11]()'\n/usr/bin/ld: /usr/include/glog/logging.h:\n698\n: undefined reference to `google::base::CheckOpMessageBuilder::~\nCheckOpMessageBuilder\n()'\n/usr/bin/ld: /usr/include/glog/logging.h:\n698\n: undefined reference to `google::base::CheckOpMessageBuilder::~\nCheckOpMessageBuilder\n()'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: \nin\n function `ceres::internal::FixedArray >::operator[](unsigned long)':\n/usr/local/include/ceres/internal/fixed_array.h:\n215\n: undefined reference to `google::LogMessageFatal::\nLogMessageFatal\n(\nchar\n \nconst\n*, int, google::CheckOpString \nconst\n&)'\n/usr/bin/ld: /usr/local/include/ceres/internal/fixed_array.h:\n215\n: undefined reference to `google::LogMessage::\nstream\n()'\n/usr/bin/ld: /usr/local/include/ceres/internal/fixed_array.h:\n215\n: undefined reference to `google::LogMessageFatal::\nLogMessageFatal\n(\nchar\n \nconst\n*, int, google::CheckOpString \nconst\n&)'\n/usr/bin/ld: /usr/local/include/ceres/internal/fixed_array.h:\n215\n: undefined reference to `google::LogMessage::\nstream\n()'\n/usr/bin/ld: /usr/local/include/ceres/internal/fixed_array.h:\n215\n: undefined reference to `google::LogMessageFatal::\nLogMessageFatal\n(\nchar\n \nconst\n*, int, google::CheckOpString \nconst\n&)'\n/usr/bin/ld: /usr/local/include/ceres/internal/fixed_array.h:\n215\n: undefined reference to `google::LogMessage::\nstream\n()'\n/usr/bin/ld: /usr/local/include/ceres/internal/fixed_array.h:\n215\n: undefined reference to `google::LogMessageFatal::~\nLogMessageFatal\n()'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: \nin\n function `main':\n/home/zsh/VSLAM/Programs/Notmycode/slambook2/ch6/g2oCurveFitting.cpp:\n91\n: undefined reference to `g2o::OptimizationAlgorithmGaussNewton::\nOptimizationAlgorithmGaussNewton\n(std::unique_ptr >)'\n/usr/bin/ld: /home/zsh/VSLAM/Programs/Notmycode/slambook2/ch6/g2oCurveFitting.cpp:\n92\n: undefined reference to `g2o::SparseOptimizer::\nSparseOptimizer\n()'\n/usr/bin/ld: /home/zsh/VSLAM/Programs/Notmycode/slambook2/ch6/g2oCurveFitting.cpp:\n93\n: undefined reference to `g2o::SparseOptimizer::\nsetAlgorithm\n(g2o::OptimizationAlgorithm*)'\n/usr/bin/ld: /home/zsh/VSLAM/Programs/Notmycode/slambook2/ch6/g2oCurveFitting.cpp:\n94\n: undefined reference to `g2o::SparseOptimizer::\nsetVerbose\n(\nbool\n)'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: \nin\n function `g2o::BaseVertex<\n3\n, Eigen::Matrix >::\nBaseVertex\n()':\n/usr/local/include/g2o/core/base_vertex.hpp:\n29\n: undefined reference to `g2o::OptimizableGraph::Vertex::\nVertex\n()'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: \nin\n function `g2o::BaseVertex<\n3\n, Eigen::Matrix >::\nsetEstimate\n(Eigen::Matrix \nconst\n&)':\n/usr/local/include/g2o/core/base_vertex.h:\n133\n: undefined reference to `g2o::OptimizableGraph::Vertex::\nupdateCache\n()'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: \nin\n function `g2o::OptimizableGraph::\naddVertex\n(g2o::OptimizableGraph::Vertex*)':\n/usr/local/include/g2o/core/optimizable_graph.h:\n597\n: undefined reference to `g2o::OptimizableGraph::\naddVertex\n(g2o::OptimizableGraph::Vertex*, g2o::HyperGraph::Data*)'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: \nin\n function `g2o::BaseEdge<\n1\n, double>::\nBaseEdge\n()':\n/usr/local/include/g2o/core/base_edge.h:\n94\n: undefined reference to `g2o::OptimizableGraph::Edge::\nEdge\n()'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o: \nin\n function `main':\n/home/zsh/VSLAM/Programs/Notmycode/slambook2/ch6/g2oCurveFitting.cpp:\n105\n: undefined reference to `g2o::HyperGraph::Edge::\nsetId\n(int)'\n/usr/bin/ld: /home/zsh/VSLAM/Programs/Notmycode/slambook2/ch6/g2oCurveFitting.cpp:\n109\n: undefined reference to `g2o::OptimizableGraph::\naddEdge\n(g2o::OptimizableGraph::Edge*)'\n/usr/bin/ld: /home/zsh/VSLAM/Programs/Notmycode/slambook2/ch6/g2oCurveFitting.cpp:\n115\n: undefined reference to `g2o::SparseOptimizer::\ninitializeOptimization\n(int)'\n/usr/bin/ld: /home/zsh/VSLAM/Programs/Notmycode/slambook2/ch6/g2oCurveFitting.cpp:\n116\n: undefined reference to `g2o::SparseOptimizer::\noptimize\n(int, \nbool\n)'\n/usr/bin/ld: /home/zsh/VSLAM/Programs/Notmycode/slambook2/ch6/g2oCurveFitting.cpp:\n126\n: undefined reference to `g2o::SparseOptimizer::~\nSparseOptimizer\n()'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o:(.data.rel.ro._ZTIN3g2o15BlockSolverBaseE[_ZTIN3g2o15BlockSolverBaseE]+\n0x10\n): undefined reference to `typeinfo \nfor\n \ng2o\n::Solver'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o:(.data.rel.ro._ZTIN3g2o10BaseVertexILi3EN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEEEE[_ZTIN3g2o10BaseVertexILi3EN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEEEE]+\n0x10\n): undefined reference to `typeinfo \nfor\n \ng2o\n::OptimizableGraph::Vertex'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o:(.data.rel.ro._ZTIN3g2o8BaseEdgeILi1EdEE[_ZTIN3g2o8BaseEdgeILi1EdEE]+\n0x10\n): undefined reference to `typeinfo \nfor\n \ng2o\n::OptimizableGraph::Edge'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o:(.data.rel.ro._ZTVN3g2o10BaseVertexILi3EN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEEEE[_ZTVN3g2o10BaseVertexILi3EN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEEEE]+\n0x88\n): undefined reference to `g2o::OptimizableGraph::Vertex::\ngetEstimateData\n(double*) \nconst\n'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o:(.data.rel.ro._ZTVN3g2o10BaseVertexILi3EN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEEEE[_ZTVN3g2o10BaseVertexILi3EN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEEEE]+\n0x98\n): undefined reference to `g2o::OptimizableGraph::Vertex::\nestimateDimension\n() \nconst\n'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o:(.data.rel.ro._ZTVN3g2o10BaseVertexILi3EN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEEEE[_ZTVN3g2o10BaseVertexILi3EN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEEEE]+\n0xa0\n): undefined reference to `g2o::OptimizableGraph::Vertex::\ngetMinimalEstimateData\n(double*) \nconst\n'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o:(.data.rel.ro._ZTVN3g2o10BaseVertexILi3EN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEEEE[_ZTVN3g2o10BaseVertexILi3EN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEEEE]+\n0xb0\n): undefined reference to `g2o::OptimizableGraph::Vertex::\nminimalEstimateDimension\n() \nconst\n'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o:(.data.rel.ro._ZTVN3g2o10BaseVertexILi3EN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEEEE[_ZTVN3g2o10BaseVertexILi3EN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEEEE]+\n0xe8\n): undefined reference to `g2o::OptimizableGraph::Vertex::\nupdateCache\n()'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o:(.data.rel.ro._ZTV18CurveFittingVertex[_ZTV18CurveFittingVertex]+\n0x88\n): undefined reference to `g2o::OptimizableGraph::Vertex::\ngetEstimateData\n(double*) \nconst\n'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o:(.data.rel.ro._ZTV18CurveFittingVertex[_ZTV18CurveFittingVertex]+\n0x98\n): undefined reference to `g2o::OptimizableGraph::Vertex::\nestimateDimension\n() \nconst\n'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o:(.data.rel.ro._ZTV18CurveFittingVertex[_ZTV18CurveFittingVertex]+\n0xa0\n): undefined reference to `g2o::OptimizableGraph::Vertex::\ngetMinimalEstimateData\n(double*) \nconst\n'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o:(.data.rel.ro._ZTV18CurveFittingVertex[_ZTV18CurveFittingVertex]+\n0xb0\n): undefined reference to `g2o::OptimizableGraph::Vertex::\nminimalEstimateDimension\n() \nconst\n'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o:(.data.rel.ro._ZTV18CurveFittingVertex[_ZTV18CurveFittingVertex]+\n0xe8\n): undefined reference to `g2o::OptimizableGraph::Vertex::\nupdateCache\n()'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o:(.data.rel.ro._ZTVN3g2o8BaseEdgeILi1EdEE[_ZTVN3g2o8BaseEdgeILi1EdEE]+\n0x28\n): undefined reference to `g2o::HyperGraph::Edge::\nresize\n(unsigned long)'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o:(.data.rel.ro._ZTVN3g2o8BaseEdgeILi1EdEE[_ZTVN3g2o8BaseEdgeILi1EdEE]+\n0x40\n): undefined reference to `g2o::OptimizableGraph::Edge::\nsetMeasurementData\n(double \nconst\n*)'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o:(.data.rel.ro._ZTVN3g2o8BaseEdgeILi1EdEE[_ZTVN3g2o8BaseEdgeILi1EdEE]+\n0x48\n): undefined reference to `g2o::OptimizableGraph::Edge::\ngetMeasurementData\n(double*) \nconst\n'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o:(.data.rel.ro._ZTVN3g2o8BaseEdgeILi1EdEE[_ZTVN3g2o8BaseEdgeILi1EdEE]+\n0x50\n): undefined reference to `g2o::OptimizableGraph::Edge::\nmeasurementDimension\n() \nconst\n'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o:(.data.rel.ro._ZTVN3g2o8BaseEdgeILi1EdEE[_ZTVN3g2o8BaseEdgeILi1EdEE]+\n0x58\n): undefined reference to `g2o::OptimizableGraph::Edge::\nsetMeasurementFromState\n()'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o:(.data.rel.ro._ZTVN3g2o8BaseEdgeILi1EdEE[_ZTVN3g2o8BaseEdgeILi1EdEE]+\n0xd8\n): undefined reference to `g2o::OptimizableGraph::Edge::\nresolveCaches\n()'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o:(.data.rel.ro._ZTVN3g2o18BaseFixedSizedEdgeILi1EdJ18CurveFittingVertexEEE[_ZTVN3g2o18BaseFixedSizedEdgeILi1EdJ18CurveFittingVertexEEE]+\n0x40\n): undefined reference to `g2o::OptimizableGraph::Edge::\nsetMeasurementData\n(double \nconst\n*)'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o:(.data.rel.ro._ZTVN3g2o18BaseFixedSizedEdgeILi1EdJ18CurveFittingVertexEEE[_ZTVN3g2o18BaseFixedSizedEdgeILi1EdJ18CurveFittingVertexEEE]+\n0x48\n): undefined reference to `g2o::OptimizableGraph::Edge::\ngetMeasurementData\n(double*) \nconst\n'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o:(.data.rel.ro._ZTVN3g2o18BaseFixedSizedEdgeILi1EdJ18CurveFittingVertexEEE[_ZTVN3g2o18BaseFixedSizedEdgeILi1EdJ18CurveFittingVertexEEE]+\n0x50\n): undefined reference to `g2o::OptimizableGraph::Edge::\nmeasurementDimension\n() \nconst\n'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o:(.data.rel.ro._ZTVN3g2o18BaseFixedSizedEdgeILi1EdJ18CurveFittingVertexEEE[_ZTVN3g2o18BaseFixedSizedEdgeILi1EdJ18CurveFittingVertexEEE]+\n0x58\n): undefined reference to `g2o::OptimizableGraph::Edge::\nsetMeasurementFromState\n()'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o:(.data.rel.ro._ZTVN3g2o18BaseFixedSizedEdgeILi1EdJ18CurveFittingVertexEEE[_ZTVN3g2o18BaseFixedSizedEdgeILi1EdJ18CurveFittingVertexEEE]+\n0xd8\n): undefined reference to `g2o::OptimizableGraph::Edge::\nresolveCaches\n()'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o:(.data.rel.ro._ZTV16CurveFittingEdge[_ZTV16CurveFittingEdge]+\n0x40\n): undefined reference to `g2o::OptimizableGraph::Edge::\nsetMeasurementData\n(double \nconst\n*)'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o:(.data.rel.ro._ZTV16CurveFittingEdge[_ZTV16CurveFittingEdge]+\n0x48\n): undefined reference to `g2o::OptimizableGraph::Edge::\ngetMeasurementData\n(double*) \nconst\n'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o:(.data.rel.ro._ZTV16CurveFittingEdge[_ZTV16CurveFittingEdge]+\n0x50\n): undefined reference to `g2o::OptimizableGraph::Edge::\nmeasurementDimension\n() \nconst\n'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o:(.data.rel.ro._ZTV16CurveFittingEdge[_ZTV16CurveFittingEdge]+\n0x58\n): undefined reference to `g2o::OptimizableGraph::Edge::\nsetMeasurementFromState\n()'\n/usr/bin/ld: CMakeFiles/g2oCurveFitting.dir/g2oCurveFitting.cpp.o:(.data.rel.ro._ZTV16CurveFittingEdge[_ZTV16CurveFittingEdge]+\n0xd8\n): undefined reference to `g2o::OptimizableGraph::Edge::\nresolveCaches\n()'\n/usr/bin/ld: warning: creating DT_TEXTREL \nin\n a PIE\ncollect2: error: ld returned \n1\n exit status\nmake[\n2\n]: *** [CMakeFiles/g2oCurveFitting.dir/build.make:\n111\n：g2oCurveFitting] 错误 \n1\n\nmake[\n1\n]: *** [CMakeFiles/Makefile2:\n139\n：CMakeFiles/g2oCurveFitting.dir/all] 错误 \n2\n\nmake: *** [Makefile:\n91\n：all] 错误 \n2\n\n\n\n\n\n\n以及之前安装g2o依赖项时出现的一个小问题：\n\n\n正在读取软件包列表\n...\n 完成\n正在分析软件包的依赖关系树\n...\n 完成\n正在读取状态信息\n...\n 完成                 \n没有可用的软件包 qt5-default，但是它被其它的软件包引用了。\n这可能意味着这个缺失的软件包可能已被废弃，\n或者只能在其他发布源中找到\n\nE: 软件包 qt5-default 没有可安装候选\n\n\n", "Tag": "算法分析"}
{"Answer": "\n", "Konwledge_Point": "线性规划和规约", "Question": "#高数#高数过程求解，向量空间\n大学高数解答，2×2矩阵，求解答a和b过程，希望能得到详细的过程。", "Tag": "算法分析"}
{"Answer": "[quote]CONSTRAINT `dy_apply_ibfk_1` FOREIGN KEY (`UID`) REFERENCES `dy_use[/quote]\r\n这个是定义外健\r\n\r\n[quote]LOCK TABLES `dy_revert` WRITE[/quote]\r\n这个是锁表,他在插入前都锁了下,插完解锁[quote]UNLOCK TABLES; [/quote]", "Konwledge_Point": "线性规划和规约", "Question": "看别人的项目，就是数据库的表看不懂，帮忙解释下\n-- MySQL dump 10.11\n\n\n\n-- Host: localhost    Database: zxdy\n\n\n\n-- Server version   5.0.41-community-nt\n\n\n\n/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT \n/;\n\n/\n!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS \n/;\n\n/\n!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION \n/;\n\n/\n!40101 SET NAMES latin1 \n/;\n\n/\n!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE \n/;\n\n/\n!40103 SET TIME_ZONE='+00:00' \n/;\n\n/\n!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 \n/;\n\n/\n!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 \n/;\n\n/\n!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' \n/;\n\n/\n!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;\n\n\n\n\n\n\n-- Table structure for table \ndy_apply\n\n\n\n\n\nDROP TABLE IF EXISTS \ndy_apply\n;\n\nCREATE TABLE \ndy_apply\n (\nAID\n int(11) NOT NULL auto_increment,\nUID\n int(11) default NULL,\nTGID\n int(11) default NULL,\nAReason\n varchar(200) NOT NULL,\nAFlag\n int(11) default '0',\nAStatus\n char(10) default '申请中',\n\n  PRIMARY KEY  (\nAID\n),\n\n  KEY \nUID\n (\nUID\n),\n\n  KEY \nTGID\n (\nTGID\n),\n\n [color=red] CONSTRAINT \ndy_apply_ibfk_1\n FOREIGN KEY (\nUID\n) REFERENCES \ndy_user\n (\nUID\n) ON DELETE CASCADE,\n\n  CONSTRAINT \ndy_apply_ibfk_2\n FOREIGN KEY (\nTGID\n) REFERENCES \ndy_topic_group\n (\nTGID\n) ON DELETE CASCADE\n\n) ENGINE=InnoDB DEFAULT CHARSET=latin1;[/color]--\n\n\n\n-- Dumping data for table \ndy_apply\n\n\n\n\n\n[color=red]LOCK TABLES \ndy_apply\n WRITE;[/color]/*!40000 ALTER TABLE \ndy_apply\n DISABLE KEYS \n/;\n\nINSERT INTO \ndy_apply\n VALUES (2,1,10002,'范德萨发大萨菲',1,'拒绝申请'),(3,1,10004,'范德萨发大',0,'申请中'),(4,1,10000,'fsfaf',1,'拒绝申请'),(5,1,10002,'dsf',1,'拒绝申请'),(7,3,10002,'范德萨发大是',1,'同意申请'),(8,1,10002,'feafdsafdsafdas',1,'同意申请'),(9,1,10000,'fefewfewa',1,'同意申请'),(10,1,10003,'21',0,'申请中'),(11,1,10008,'fdsa',0,'申请中'),(12,1,10006,'想学习',0,'申请中');\n\n/\n!40000 ALTER TABLE \ndy_apply\n ENABLE KEYS */;\n\nUNLOCK TABLES;\n\n\n\n\n\n\n-- Table structure for table \ndy_revert\n\n\n\n\n\nDROP TABLE IF EXISTS \ndy_revert\n;\n\nCREATE TABLE \ndy_revert\n (\nRID\n int(11) NOT NULL auto_increment,\nTID\n int(11) default NULL,\nUID\n int(11) default NULL,\nRTitle\n varchar(200) default NULL,\nRContent\n text NOT NULL,\nRDate\n datetime NOT NULL,\n\n  PRIMARY KEY  (\nRID\n),\n\n  KEY \nTID\n (\nTID\n),\n\n  KEY \nUID\n (\nUID\n),\n\n [color=red] CONSTRAINT \ndy_revert_ibfk_1\n FOREIGN KEY (\nTID\n) REFERENCES \ndy_topic\n (\nTID\n) ON DELETE CASCADE,\n\n  CONSTRAINT \ndy_revert_ibfk_2\n FOREIGN KEY (\nUID\n) REFERENCES \ndy_user\n (\nUID\n) ON DELETE CASCADE\n\n\n\n) ENGINE=InnoDB DEFAULT CHARSET=latin1;[/color]\n\n\n\n-- Dumping data for table \ndy_revert\n\n\n\n\n\n[color=red]LOCK TABLES \ndy_revert\n WRITE;[/color]/*!40000 ALTER TABLE \ndy_revert\n DISABLE KEYS \n/;\n\nINSERT INTO \ndy_revert\n VALUES (1,2,3,'','看书，上网问问题','2008-12-08 11:08:31'),(2,1,3,'','传说新版本的JAVA 会自动缓存BYTE范围内的值.','2008-12-08 11:08:31'),(3,1,3,'','楼主懂了吗？可以参考Java里的源代码','2008-12-08 11:08:31'),(4,1,3,'','谢谢大家指教','2008-12-08 11:08:31'),(5,3,3,'','认真学习，专心研究的话就好学','2008-12-08 11:08:31'),(6,10,1,'','\\r\\n测试测试测试测试测试测试测试测试测试10\\r\\n测试测试测试测试测试测试测试测试测试10\\r\\n测试测试测试测试测试测试测试测试测试10','2008-12-08 20:13:07'),(7,10,1,'回答 xyz 的问题','\\r\\n测试测试测试测试测试测试测试测试测试10\\r\\n测试测试测试测试测试测试测试测试测试10\\r\\n测试测试测试测试测试测试测试测试测试10','2008-12-08 20:13:15'),(8,1,2,'','都是一个人????','2008-12-10 23:01:33'),(9,6,2,'','新版本会缓存的 呵呵','2008-12-11 23:24:32'),(10,8,1,'','再次测试啊啊啊 啊','2008-12-12 01:16:36'),(11,10,1,'','学生\\r\\n\\r\\n注册时间 2008-12-08\\r\\n\\r\\n最后登陆 2008-12-12\\r\\n 2楼  发表于 2008-12-08 20:13:15 回答 xyz 的问题\\r\\n测试测试测试测试测试测试测试测试测试10 测试测试测试测试测试测试测试测试测试10 测试测试测试测试测试测试测试测试测试10 ','2008-12-12 01:16:56'),(12,4,2,'','回答过的问题嘛算法','2008-12-12 10:58:57'),(13,10,2,'','回答过了，是不是没有了么','2008-12-12 13:08:35'),(14,3,2,'','回答了 谢谢 呵呵。。。','2008-12-12 13:27:24'),(15,15,1,'','bbbbbbbbbbbbbbbbb','2009-03-16 20:45:19'),(16,15,1,'','ccccccccccccccc','2009-03-16 20:59:07'),(17,17,1,'','ssssssssssssssssss','2009-03-16 21:00:10');\n\n/\n!40000 ALTER TABLE \ndy_revert\n ENABLE KEYS */;\n\nUNLOCK TABLES;\n\n\n\n\n\n\n-- Table structure for table \ndy_topic\n\n\n\n\n\nDROP TABLE IF EXISTS \ndy_topic\n;\n\nCREATE TABLE \ndy_topic\n (\nTID\n int(11) NOT NULL auto_increment,\nUID\n int(11) default NULL,\nTGID\n int(11) default NULL,\nTTitle\n varchar(200) NOT NULL,\nTContent\n text NOT NULL,\nTDate\n datetime NOT NULL,\nTReadCount\n int(11) default '0',\n\n  PRIMARY KEY  (\nTID\n),\n\n  KEY \nUID\n (\nUID\n),\n\n  KEY \nTGID\n (\nTGID\n),\n\n  CONSTRAINT \ndy_topic_ibfk_1\n FOREIGN KEY (\nUID\n) REFERENCES \ndy_user\n (\nUID\n) ON DELETE CASCADE,\n\n  CONSTRAINT \ndy_topic_ibfk_2\n FOREIGN KEY (\nTGID\n) REFERENCES \ndy_topic_group\n (\nTGID\n) ON DELETE CASCADE\n\n) ENGINE=InnoDB DEFAULT CHARSET=latin1;\n\n\n\n\n\n\n-- Dumping data for table \ndy_topic\n\n\n\n\n\nLOCK TABLES \ndy_topic\n WRITE;\n\n/*!40000 ALTER TABLE \ndy_topic\n DISABLE KEYS \n/;\n\nINSERT INTO \ndy_topic\n VALUES (1,1,10001,'怎样学习框架ssh','学习struts spring hibernate 的顺序是ssh吗  顺便根据我的情况推荐几本书','2008-12-08 11:07:16',31),(2,2,10003,'C++很难吗？应该怎么样学习呢','请给我推荐几本C++的书，给我讲些学习方法谢谢','2008-12-08 11:07:16',19),(3,2,10001,'测试','测试测试测试测试测试测试测试测试测试','2008-12-08 11:07:16',19),(4,1,10001,'JAVA很难吗？应该怎么样学习呢','请给我推荐几本JAVA的书，给我讲些学习方法谢谢','2008-12-08 11:07:16',14),(5,1,10002,'请教一句SQL这么写。。','这个SQL好难啊，应该怎么学呢','2008-12-08 11:07:16',12),(6,1,10001,'Integer类的一个小问题 ==比较','Integer内的值的大小在Byte范围内时，==比较返回true 在那范围之外返回false \\n这是为什么呢，为什么会这样》？ ','2008-12-08 11:07:34',32),(7,1,10002,'测试71','测试测试测试测试测试测试测试测试测试7','2008-12-08 11:08:09',13),(8,1,10001,'测试81','测试测试测试测试测试测试测试测试测试8','2008-12-08 11:08:09',21),(9,1,10002,'测试91','测试测试测试测试测试测试测试测试测试9','2008-12-08 11:08:09',16),(10,1,10001,'测试101','测试测试测试测试测试测试测试测试测试10','2008-12-08 11:08:09',29),(11,1,10002,'测试111','测试测试测试测试测试测试测试测试测试11','2008-12-08 11:08:09',12),(12,1,10001,'测试121','测试测试测试测试测试测试测试测试测试12','2008-12-08 11:08:09',13),(13,1,10005,'自动控制的课本是哪个？','自动控制的课本是哪个？自动控制的课本是哪个？自动控制的课本是哪个？','2008-12-12 01:18:07',2),(14,1,10000,'我是第一个来到这里的','第一个提问的哦 呵呵','2008-12-12 14:01:29',1),(15,1,10000,'aaaaaaaaaa','aabbbbbbbbbbbbbbbbbbbb','2009-03-16 20:44:05',6),(16,1,10000,'bbccccccccccccc','aaaaaaaaaaaaaa','2009-03-16 20:58:57',0),(17,1,10000,'11111111111111111','22222222222222222222','2009-03-16 21:00:00',2);\n\n/\n!40000 ALTER TABLE \ndy_topic\n ENABLE KEYS */;\n\nUNLOCK TABLES;\n\n\n\n\n\n\n-- Table structure for table \ndy_topic_group\n\n\n\n\n\nDROP TABLE IF EXISTS \ndy_topic_group\n;\n\nCREATE TABLE \ndy_topic_group\n (\nTGID\n int(11) NOT NULL auto_increment,\nTGName\n varchar(50) NOT NULL,\nTDetail\n varchar(200) NOT NULL,\n\n  PRIMARY KEY  (\nTGID\n)\n\n) ENGINE=InnoDB DEFAULT CHARSET=latin1;\n\n\n\n\n\n\n-- Dumping data for table \ndy_topic_group\n\n\n\n\n\nLOCK TABLES \ndy_topic_group\n WRITE;\n\n/*!40000 ALTER TABLE \ndy_topic_group\n DISABLE KEYS \n/;\n\nINSERT INTO \ndy_topic_group\n VALUES (10000,'Java网络编程','计算机与自动控制学院'),(10001,'数据库系统概论','计算机与自动控制学院'),(10002,'C语言程序设计','计算机与自动控制学院'),(10003,'高等数学','理学院'),(10004,'线性代数','理学院'),(10005,'自动控制原理','机械学院'),(10006,'大学英语1','外国语学院'),(10007,'运筹学','经济管理学院'),(10008,'运筹学','经济管理学院'),(10009,'大学物理','基础课程'),(10010,'高等数学','基础课程');\n\n/\n!40000 ALTER TABLE \ndy_topic_group\n ENABLE KEYS */;\n\nUNLOCK TABLES;\n\n\n\n\n\n\n-- Table structure for table \ndy_tu\n\n\n\n\n\nDROP TABLE IF EXISTS \ndy_tu\n;\n\nCREATE TABLE \ndy_tu\n (\nTUID\n int(11) NOT NULL auto_increment,\nUID\n int(11) default NULL,\nTGID\n int(11) default NULL,\n\n  PRIMARY KEY  (\nTUID\n),\n\n  KEY \nUID\n (\nUID\n),\n\n  KEY \nTGID\n (\nTGID\n),\n\n  CONSTRAINT \ndy_tu_ibfk_1\n FOREIGN KEY (\nUID\n) REFERENCES \ndy_user\n (\nUID\n) ON DELETE CASCADE,\n\n  CONSTRAINT \ndy_tu_ibfk_2\n FOREIGN KEY (\nTGID\n) REFERENCES \ndy_topic_group\n (\nTGID\n) ON DELETE CASCADE\n\n) ENGINE=InnoDB DEFAULT CHARSET=latin1;\n\n\n\n\n\n\n-- Dumping data for table \ndy_tu\n\n\n\n\n\nLOCK TABLES \ndy_tu\n WRITE;\n\n/*!40000 ALTER TABLE \ndy_tu\n DISABLE KEYS \n/;\n\nINSERT INTO \ndy_tu\n VALUES (1,2,10000),(2,2,10001),(3,2,10002),(4,1,10001),(6,1,10005),(10,3,10002),(12,1,10000),(13,1,10002),(14,3,10001),(15,4,10001),(17,7,10001);\n\n/\n!40000 ALTER TABLE \ndy_tu\n ENABLE KEYS */;\n\nUNLOCK TABLES;\n\n\n\n\n\n\n-- Table structure for table \ndy_user\n\n\n\n\n\nDROP TABLE IF EXISTS \ndy_user\n;\n\nCREATE TABLE \ndy_user\n (\nUID\n int(11) NOT NULL auto_increment,\nUName\n varchar(20) NOT NULL,\nUPwd\n varchar(20) NOT NULL,\nUGender\n char(2) default '男',\nUEmail\n varchar(40) default NULL,\nURole\n int(11) default '0',\nUHead\n varchar(50) default 'UserHead/no_head.jpg',\nURegDate\n date default NULL,\nULastLogin\n datetime default NULL,\nULastEmit\n datetime default NULL,\nUPermit\n int(11) default '1',\n\n  PRIMARY KEY  (\nUID\n),\n\n  UNIQUE KEY \nUName\n (\nUName\n)\n\n) ENGINE=InnoDB DEFAULT CHARSET=latin1;\n\n\n\n\n\n\n-- Dumping data for table \ndy_user\n\n\n\n\n\nLOCK TABLES \ndy_user\n WRITE;\n\n/*!40000 ALTER TABLE \ndy_user\n DISABLE KEYS \n/;\n\nINSERT INTO \ndy_user\n VALUES (1,'xyz','123456','男','\nfgdsa@163.com\n',0,'UserHead/1.jpg','2008-12-08','2009-03-16 22:16:20','2009-03-16 21:00:10',1),(2,'zrk','123456','男','\nsfdsaga@163.com\n',1,'UserHead/2.JPG','2008-12-08','2009-03-16 23:12:04','2008-12-12 13:27:24',1),(3,'胡再芬','123456','女','\nwereq@163.com\n',0,'UserHead/3.jpg','2008-12-08','2008-12-12 09:26:47',NULL,1),(4,'wyf','123456','男','\ngr4eg@163.com\n',3,'UserHead/1.jpg','2008-12-08','2009-03-17 15:11:32','2008-12-12 14:01:29',1),(5,'fdsa','123123','男','\nrfews@3421.com\n',0,'UserHead/no_head.jpg','2009-03-16','2009-03-16 17:41:24','2009-03-16 17:41:24',1),(7,'wfa','123123','男','\nfdsa@123.com\n',0,'UserHead/no_head.jpg','2009-03-16','2009-03-16 17:44:32','2009-03-16 17:44:32',1),(8,'few','123123','男','\nfdsa@123.com\n',0,'UserHead/no_head.jpg','2009-03-16','2009-03-16 17:45:11','2009-03-16 17:45:11',1);\n\n/\n!40000 ALTER TABLE \ndy_user\n ENABLE KEYS \n/;\n\nUNLOCK TABLES;\n\n/\n!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;\n\n\n\n/*!40101 SET SQL_MODE=@OLD_SQL_MODE \n/;\n\n/\n!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS \n/;\n\n/\n!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS \n/;\n\n/\n!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT \n/;\n\n/\n!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS \n/;\n\n/\n!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION \n/;\n\n/\n!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;\n\n\n\n-- Dump completed on 2009-03-17  7:23:17\n\n\n\n红色部分不知道什么意思，如果能解释下这几个表的关系，就更好了", "Tag": "算法分析"}
{"Answer": "在多标签文本分类的训练过程中，在多元文本分类的训练过程中，Loss一般在0.1-0.2之间的时候，模型基本上已经收敛。但是，看题主的这个，在多标签文本分类(这个框架下)的情况下，Loss往往要达到0.0001-0.001之间，模型才收敛。", "Konwledge_Point": "线性规划和规约", "Question": "问下使用albert 进行多标签的文本分类[12个类别],为啥 acc 才这么点,是哪里没写对么?\nimport\n tensorflow \nas\n tf\n \n\ntf\n.__version__\n\n\n\n'2.2.2\n'\n\n\n\nimport keras\n\nprint\n(keras.__version__)\n\n\n\n\n2\n.\n3\n.\n1\n\n\n\n\nUsing\n TensorFlow backend.\n\n\n\n\n\nfrom\n tensorflow \nimport\n keras\n\nprint\n(keras.__version__)\n\n\n\n2\n.\n3\n.\n0\n-tf\n\n\n\nfrom tensorflow.keras.utils import to_categorical\nfrom sklearn.model_selection import train_test_split\n\nMAX_LENGTH = \n1024\n\n#载入训练集和测试集数据\n# train = pd.read\n_csv(\nr\n'D:\\\ncode\n\\\npython\n\\\ncsdn_nlp\n\\\ndata\n\\文本分类数据\\Texts_Classification\\\ntrain2\n.\ncsv\n')\n\n# test = pd.read\n_csv(\nr\n'D:\\\ncode\n\\\npython\n\\\ncsdn_nlp\n\\\ndata\n\\文本分类数据\\Texts_Classification\\\ntest2\n.\ncsv\n')\n\n\ntrain = pd.read\n_csv(\nr\n'\n/\nmnt\n/\nd\n/\ncode\n/\npython\n/\ncsdn_nlp\n/\ndata\n/\n文本分类数据\n/\nTexts_Classification\n/\ntrain2\n.\ncsv\n')\n\ntest = pd.read\n_csv(\nr\n'\n/\nmnt\n/\nd\n/\ncode\n/\npython\n/\ncsdn_nlp\n/\ndata\n/\n文本分类数据\n/\nTexts_Classification\n/\ntest2\n.\ncsv\n')\n\n\n\n\ntrain\n.head(\n10\n)\n\n\n\n\n\n\n\nUnnamed: 0\n分类\n文章\n字数\n分词\nlabel\n0\n10000\n体育\n欧洲杯观察：足坛格局地震　东南欧已能占半边天 搜狐体育讯　土耳其与克罗地亚在本届欧洲杯１／４...\n1818\n['欧洲杯', '观察', '足坛', '格局', '地震', '东南欧', '已能', '...\n8\n1\n10001\n体育\n来源：搜狐体育　作者：雷欧 主队　比分　客队　进球视频青岛　１－１　武汉浙江　１－１　北京搜...\n2190\n['来源', '搜狐', '体育', '作者', '雷欧', '主队', '比分', '客队...\n8\n2\n10002\n体育\n欧洲杯－帕夫柳琴科范尼破门　荷兰１－１俄罗斯加时 搜狐体育讯　北京时间６月２２日，２００８欧...\n2078\n['欧洲杯', '帕夫', '柳琴', '科范尼', '破门', '荷兰', '俄罗斯', ...\n8\n3\n10003\n体育\n郅联璧合配合日臻完善　斯杯之前尤纳斯再谈裁员 ７年后重登上海滩，中国男篮来去匆匆。队长刘炜回...\n1810\n['郅', '联璧', '合', '配合', '日臻完善', '斯杯', '之前', '尤纳...\n8\n4\n10004\n体育\n盘踞世界第一逼近五百周　伍兹创造高尔夫里程碑 搜狐体育讯　下周一，老虎－伍兹将第４９９周稳坐...\n1893\n['盘踞', '世界', '第一', '逼近', '五百', '周伍', '兹', '创造'...\n8\n5\n10005\n体育\n第五日看点：郑洁挑战ＮＯ．１　费天王冲击男单１６强 搜狐体育讯　北京时间６月２７日晚，２００...\n2082\n['第五日', '看点', '郑洁', '挑战', '费', '天王', '冲击', '男单...\n8\n6\n10007\n体育\n王德显改变双姝命运　邢慧娜孙英杰成败均因一人 ２００７年年底，邢慧娜来到了北京。田管中心已经...\n1855\n['王德显', '改变', '双姝', '命运', '邢慧娜', '孙', '英杰', '成...\n8\n7\n10008\n体育\n半场实录：皮尔斯异军突起　湖人队领先凯尔特人 搜狐直播员：搜狐网友：赛式是２３２制的，还是主...\n8550\n['半场', '实录', '皮尔斯', '异军突起', '湖人队', '领先', '凯尔特人...\n8\n8\n10009\n体育\n温格：德国可成英格兰榜样　三狮军团差在意志力 晨报特派记者　甘慧（奥地利维也纳６月２９日电）...\n2162\n['温格', '德国', '可成', '英格兰', '榜样', '三狮', '军团', '差...\n8\n9\n10010\n体育\n欧洲杯－范尼斯内德建功　荷兰３－０狂屠意大利 搜狐体育讯　北京时间６月１０日凌晨２：４５，２...\n2643\n['欧洲杯', '范', '尼斯', '德', '建功', '荷兰', '狂屠', '意大利...\n8\n\n\n\n\n\n\n\n\ntemp_train_data_list = train\n[[\n\"文章\"\n,\n\"label\"\n]\n]\n.values\n.tolist\n()\ntrain_data_list = \n[tuple(x) for x in temp_train_data_list]\n\n\ntemp_test_data_list = test\n[[\n\"文章\"\n,\n\"label\"\n]\n]\n.values\n.tolist\n()\ntest_data_list = \n[tuple(x) for x in temp_test_data_list]\n\ntrain_data_list\n[0]\n\n\nprint\n(type(train_data_list)\n)\n\n\n\n<\nclass\n \n'list'\n>\n\n\n\n# \nfrom\n sklearn.model_selection import train_test_split\n# \n''\n'不采取分层抽样时的数据集分割'\n''\n\n# valid_data_list = train_test_split(train_data_list,test_size=0.3)\n# le\nn\n(valid_data_list)\n# valid_data_list[0]\nimport random\nbaifenbi = 80\n\nlength\n = le\nn\n(train_data_list)\npr\nint\n(\nlength\n)\nle\nn\n(train_data_list[\nint\n((\nlength\n/100)\n*baifenbi):])\n\n\n\n\n23549\n\n\n\n\n\n\n\n4710\n\n\n\n\n# 加载数据集 这么取 值 标签训练会有问题,所以要随机打乱,然后选取\n\nimport \nrandom\n\n\nrandom\n.shuffle(train_data_list)\ntrain_data = train_data_list[\n0\n:\nint\n((length/\n100\n)*baifenbi)]\nvalid_data = train_data_list[\nint\n((length/\n100\n)*baifenbi):]\n\n\n\n# random.seed(10)\n\n\n# valid_data = random.sample(train_data_list, 5) \n\n\ntest_data = test_data_list\n\n\n\nimport\n numpy \nas\n np\n\nfrom\n sklearn \nimport\n metrics\n\nfrom\n bert4keras.tokenizers \nimport\n Tokenizer\n\nfrom\n bert4keras.backend \nimport\n keras, set_gelu\n\nfrom\n bert4keras.models \nimport\n build_transformer_model\n\nfrom\n bert4keras.snippets \nimport\n DataGenerator, sequence_padding\n\nfrom\n bert4keras.optimizers \nimport\n Adam, extend_with_piecewise_linear_lr\n\nfrom\n keras.layers \nimport\n Lambda, Dense\n\nfrom\n contextlib \nimport\n redirect_stdout\n\n\n\nset_gelu(\n'tanh'\n)  \n# 切换gelu版本\n\n\n\n# 文本共计 12 个类别\n\nnum_classes = \n12\n\n\n# 长文本,长一些,好像bert 类,最长 512? 所以编码的文字 应该去掉停用词\n\nmaxlen = \n64\n\n\nbatch_size = \n8\n\n\n\n# config_path = r\"D:/code/python/csdn_nlp/model/albert_xlarge_zh/albert_xlarge/albert_config.json\"\n\n\n# checkpoint_path =tf.train.latest_checkpoint(r\"D:/code/python/csdn_nlp/model/albert_xlarge_zh/albert_xlarge/\")\n\n\n# #checkpoint_path = r\"D:/code/python/csdn_nlp/model/albert_xlarge_zh/albert_xlarge/model\"\n\n\n# dict_path = r\"D:/code/python/csdn_nlp/model/albert_xlarge_zh/albert_xlarge/vocab_chinese.txt\"\n\n\n\n# linux 路径\n\nconfig_path = \nr\"/mnt/d/code/python/csdn_nlp/model/albert_base/albert_config.json\"\n\n\n# albert-base-v2 的压缩包里面没有ckpt，windows 下面加载报错，所以应该在linux 下面使用\n\ncheckpoint_path =tf.train.latest_checkpoint(\nr\"/mnt/d/code/python/csdn_nlp/model/albert_base/model.ckpt-best.data-00000-of-00001\"\n)\n\n#checkpoint_path = r\"/mnt/d/code/python/csdn_nlp/model/albert_base/\"\n\ndict_path = \nr\"/mnt/d/code/python/csdn_nlp/model/albert_base/vocab_chinese.txt\"\n\n\n\n# 建立分词器\n\ntokenizer = Tokenizer(dict_path, do_lower_case=\nTrue\n)\n\n\n\nclass\n \ndata_generator\n(\nDataGenerator\n):\n    \n\"\"\"数据生成器\n    \"\"\"\n\n    \ndef\n \n__iter__\n(\nself, random=\nFalse\n):\n        batch_token_ids, batch_segment_ids, batch_labels = [], [], []\n        \nfor\n is_end, (text, label) \nin\n self.sample(random):\n            token_ids, segment_ids = tokenizer.encode(text, maxlen=maxlen)\n            batch_token_ids.append(token_ids)\n            batch_segment_ids.append(segment_ids)\n            batch_labels.append([label])\n            \nif\n \nlen\n(batch_token_ids) == self.batch_size \nor\n is_end:\n                batch_token_ids = sequence_padding(batch_token_ids)\n                batch_segment_ids = sequence_padding(batch_segment_ids)\n                batch_labels = sequence_padding(batch_labels)\n                \nyield\n [batch_token_ids, batch_segment_ids], batch_labels\n                batch_token_ids, batch_segment_ids, batch_labels = [], [], []\n\n\n\n# 加载预训练模型\n\nbert = build_transformer_model(\n    config_path=config_path,\n    checkpoint_path=checkpoint_path,\n    model=\n'albert'\n,\n    return_keras_model=\nFalse\n,\n)\n\noutput = Lambda(\nlambda\n x: x[:, \n0\n], name=\n'CLS-token'\n)(bert.model.output)\noutput = Dense(\n    units=num_classes,\n    activation=\n'softmax'\n,\n    kernel_initializer=bert.initializer\n)(output)\n\nmodel = keras.models.Model(bert.model.\ninput\n, output)\nmodel.summary()\n\n\n# 派生为带分段线性学习率的优化器。\n\n\n# 其中name参数可选，但最好填入，以区分不同的派生优化器。\n\nAdamLR = extend_with_piecewise_linear_lr(Adam, name=\n'AdamLR'\n)\n\nmodel.\ncompile\n(\n    loss=\n'sparse_categorical_crossentropy'\n,\n    \n# optimizer=Adam(1e-5),  # 用足够小的学习率\n\n    optimizer=AdamLR(learning_rate=\n1e-4\n, lr_schedule={\n        \n1000\n: \n1\n,\n        \n2000\n: \n0.1\n\n    }),\n    metrics=[\n'accuracy'\n],\n)\n\n\n# 转换数据集\n\ntrain_generator = data_generator(train_data, batch_size)\nvalid_generator = data_generator(valid_data, batch_size)\ntest_generator = data_generator(test_data, batch_size)\n\n\n\ndef\n \nevaluate\n(\ndata\n):\n    total, right = \n0.\n, \n0.\n\n    \nfor\n x_true, y_true \nin\n data:\n        y_pred = model.predict(x_true).argmax(axis=\n1\n)\n        y_true = y_true[:, \n0\n]\n        total += \nlen\n(y_true)\n        right += (y_true == y_pred).\nsum\n()\n    \nreturn\n right / total\n\n\n\nclass\n \nEvaluator\n(keras.callbacks.Callback):\n    \n\"\"\"评估与保存\n    \"\"\"\n\n    \ndef\n \n__init__\n(\nself\n):\n        self.best_val_acc = \n0.\n\n\n    \ndef\n \non_epoch_end\n(\nself, epoch, logs=\nNone\n):\n        val_acc = evaluate(valid_generator)\n        \nif\n val_acc > self.best_val_acc:\n            self.best_val_acc = val_acc\n            model.save_weights(\n'best_model.weights'\n)\n        test_acc = evaluate(test_generator)\n        \nprint\n(\n            \nu'val_acc: %.5f, best_val_acc: %.5f, test_acc: %.5f\\n'\n %\n            (val_acc, self.best_val_acc, test_acc)\n        )\n\n\n\nModel: \"model\n_6\"\n\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n__\nLayer (type)                    Output Shape         Param #     Connected to                     \n==================================================================================================\nInput-Token (InputLayer)        (None, None)         0                                            \n__\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n\nInput-Segment (InputLayer)      (None, None)         0                                            \n\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n__\nEmbedding-Token (Embedding)     (None, None, 128)    2704384     Input-Token[\n0\n][\n0\n]                \n__\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n\nEmbedding-Segment (Embedding)   (None, None, 128)    256         Input-Segment[\n0\n][\n0\n]              \n\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n__\nEmbedding-Token-Segment (Add)   (None, None, 128)    0           Embedding-Token[\n0\n][\n0\n]            \n                                                                 Embedding-Segment[\n0\n][\n0\n]          \n__\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n\nEmbedding-Position (PositionEmb (None, None, 128)    65536       Embedding-Token-Segment[\n0\n][\n0\n]    \n\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n__\nEmbedding-Norm (LayerNormalizat (None, None, 128)    256         Embedding-Position[\n0\n][\n0\n]         \n__\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n\nEmbedding-Mapping (Dense)       (None, None, 768)    99072       Embedding-Norm[\n0\n][\n0\n]             \n\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n__\nTransformer-MultiHeadSelfAttent (None, None, 768)    2362368     Embedding-Mapping[\n0\n][\n0\n]          \n                                                                 Embedding-Mapping[\n0\n][\n0\n]          \n                                                                 Embedding-Mapping[\n0\n][\n0\n]          \n                                                                 Transformer-FeedForward-Norm[0][0\n                                                                 Transformer-FeedForward-Norm[0][0\n                                                                 Transformer-FeedForward-Norm[0][0\n                                                                 Transformer-FeedForward-Norm[1][0\n                                                                 Transformer-FeedForward-Norm[1][0\n                                                                 Transformer-FeedForward-Norm[1][0\n                                                                 Transformer-FeedForward-Norm[2][0\n                                                                 Transformer-FeedForward-Norm[2][0\n                                                                 Transformer-FeedForward-Norm[2][0\n                                                                 Transformer-FeedForward-Norm[3][0\n                                                                 Transformer-FeedForward-Norm[3][0\n                                                                 Transformer-FeedForward-Norm[3][0\n                                                                 Transformer-FeedForward-Norm[4][0\n                                                                 Transformer-FeedForward-Norm[4][0\n                                                                 Transformer-FeedForward-Norm[4][0\n                                                                 Transformer-FeedForward-Norm[5][0\n                                                                 Transformer-FeedForward-Norm[5][0\n                                                                 Transformer-FeedForward-Norm[5][0\n                                                                 Transformer-FeedForward-Norm[6][0\n                                                                 Transformer-FeedForward-Norm[6][0\n                                                                 Transformer-FeedForward-Norm[6][0\n                                                                 Transformer-FeedForward-Norm[7][0\n                                                                 Transformer-FeedForward-Norm[7][0\n                                                                 Transformer-FeedForward-Norm[7][0\n                                                                 Transformer-FeedForward-Norm[8][0\n                                                                 Transformer-FeedForward-Norm[8][0\n                                                                 Transformer-FeedForward-Norm[8][0\n                                                                 Transformer-FeedForward-Norm[9][0\n                                                                 Transformer-FeedForward-Norm[9][0\n                                                                 Transformer-FeedForward-Norm[9][0\n                                                                 Transformer-FeedForward-Norm[10][\n                                                                 Transformer-FeedForward-Norm[10][\n                                                                 Transformer-FeedForward-Norm[10][\n__\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n\nTransformer-MultiHeadSelfAttent (None, None, 768)    0           Embedding-Mapping[\n0\n][\n0\n]          \n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-FeedForward-Norm[0][0\n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-FeedForward-Norm[1][0\n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-FeedForward-Norm[2][0\n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-FeedForward-Norm[3][0\n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-FeedForward-Norm[4][0\n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-FeedForward-Norm[5][0\n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-FeedForward-Norm[6][0\n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-FeedForward-Norm[7][0\n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-FeedForward-Norm[8][0\n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-FeedForward-Norm[9][0\n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-FeedForward-Norm[10][\n                                                                 Transformer-MultiHeadSelfAttentio\n\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n__\nTransformer-MultiHeadSelfAttent (None, None, 768)    1536        Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-MultiHeadSelfAttentio\n__\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n\nTransformer-FeedForward (FeedFo (None, None, 768)    4722432     Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-MultiHeadSelfAttentio\n\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n__\nTransformer-FeedForward-Add (Ad (None, None, 768)    0           Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-FeedForward[\n0\n][\n0\n]    \n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-FeedForward[\n1\n][\n0\n]    \n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-FeedForward[\n2\n][\n0\n]    \n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-FeedForward[\n3\n][\n0\n]    \n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-FeedForward[\n4\n][\n0\n]    \n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-FeedForward[\n5\n][\n0\n]    \n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-FeedForward[\n6\n][\n0\n]    \n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-FeedForward[\n7\n][\n0\n]    \n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-FeedForward[\n8\n][\n0\n]    \n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-FeedForward[\n9\n][\n0\n]    \n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-FeedForward[\n10\n][\n0\n]   \n                                                                 Transformer-MultiHeadSelfAttentio\n                                                                 Transformer-FeedForward[\n11\n][\n0\n]   \n__\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n\nTransformer-FeedForward-Norm (L (None, None, 768)    1536        Transformer-FeedForward-Add[\n0\n][\n0\n]\n                                                                 Transformer-FeedForward-Add[\n1\n][\n0\n]\n                                                                 Transformer-FeedForward-Add[\n2\n][\n0\n]\n                                                                 Transformer-FeedForward-Add[\n3\n][\n0\n]\n                                                                 Transformer-FeedForward-Add[\n4\n][\n0\n]\n                                                                 Transformer-FeedForward-Add[\n5\n][\n0\n]\n                                                                 Transformer-FeedForward-Add[\n6\n][\n0\n]\n                                                                 Transformer-FeedForward-Add[\n7\n][\n0\n]\n                                                                 Transformer-FeedForward-Add[\n8\n][\n0\n]\n                                                                 Transformer-FeedForward-Add[\n9\n][\n0\n]\n                                                                 Transformer-FeedForward-Add[10][0\n                                                                 Transformer-FeedForward-Add[11][0\n\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n__\nCLS-token (Lambda)              (None, 768)          0           Transformer-FeedForward-Norm[11][\n__\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n\ndense_\n21 (Dense)                (None, 12)           9228        CLS-token[\n0\n][\n0\n]                  \n==================================================================================================\nTotal params: 9,966,604\nTrainable params: 9,966,604\nNon-trainable params: 0\n\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n____\n__\n\n\n\n\nevaluator = Evaluator()\nmodel.fit(\n        train_generator.forfit(),\n        steps_per_epoch=\nlen\n(train_generator),\n        epochs=\n1\n,\n        callbacks=[evaluator]\n    )\n\nmodel.load_weights(\n'best_model.weights'\n)\n\nprint\n(\nu'final test acc: %05f\\n'\n % (evaluate(test_generator)))\n\n\n\nEpoch\n \n1\n/1\n\n\n2355\n/2355\n [\n==============================\n] \n-\n \n1663s 706ms/step - loss: 2.5211 - accuracy:\n \n0.0876\n\n\nval_acc:\n \n0.08493\n,\n \nbest_val_acc:\n \n0.08493\n,\n \ntest_acc:\n \n0.08333\n\n\n\nfinal test acc:\n \n0.083333\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "文件后缀没加", "Konwledge_Point": "线性规划和规约", "Question": "数据科学技术与应用回归分析\n我把advertising文件和我写的Python文件保存在同一个文件夹里（如图1）,但是数据报错显示打不开advertising文件\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "缺失值处理要根据具体情况，通常的方法：1）删除该样本，2）补0或预置值，3）补平均值，4）用上一个样本值或滑动平均值代替\n具体到你提出的问题，性别只有 男/女（忽略其它）相当于 0/1，估计相邻样本不存在明显的相关性，且高达 39% 数据缺失，这就不适合补充该数据了，建议直接删除该列，即忽略性别的影响。\n如果分析认为 性别 对于分析结果影响很大，不能忽略，建议只能想办法再收集该数据，而不是按某种规则填补了。", "Konwledge_Point": "线性规划和规约", "Question": "数据分析中，性别一列的缺失值怎么处理比较好\n在做某平台用户信息和销售额的分析\n\n\n性别一列有11729条缺失值，约39%的缺失\n\n\n性别这一列应该怎么做缺失值处理？\n性别这一列可以用到回归模型里吗？", "Tag": "算法分析"}
{"Answer": "你是不是不知道set的作用……，它就是用来去除重复值的呀，两次都加上1，重复了，只会剩下1个。set确实是可变对象，你这样改一下就知道了：\ndef func(value, A=set()):\n    A.add(value)\n    return A\n\nprint(func(1))  # {1}\nprint(func(2))  # {1, 2}\n", "Konwledge_Point": "线性规划和规约", "Question": "Python两次调用函数改变了形参默认值\n问题遇到的现象和发生背景\n\n\nPython 两次调用同一个函数会改变形参的默认值\n\n\n遇到的现象和发生背景，请写出第一个错误信息\n\n\n下面是一段简单的函数，我们将它调用两次：\n\n\ndef \nfunc\n(A=[])\n:\n\n    A.\nappend\n(\n1\n)\n    \nprint\n(id(A))\n    \nreturn\n A\n\n\nprint\n(\nfunc\n()\n)  # [1]\n\n\nprint\n(\nfunc\n()\n)  # [1,1]\n\n\n\n\nOutput:\n\n\n1449889792264\n\n\n[1]\n\n\n1449889792264\n\n\n[1, 1]\n\n\n\n\n第一次输出[1]，第二次输出[1,1]，id()函数反映两个A是同一个对象。不知道这是为什么，我把这个函数略作修改，List()改Set()，输出结果却正好相反：\n\n\ndef\n \nfunc\n(\nA=\nset\n(\n)\n):\n    A.add(\n1\n)\n    \nprint\n(\nid\n(A))\n    \nreturn\n A\n\n\nprint\n(func())  \n# {1}\n\n\nprint\n(func())  \n# {1,1}\n\n\n\n\nOutput:\n\n\n2032723709064\n\n{1}\n\n2032723709064\n\n{1}\n\n\n\n\n依旧是同一个对象id，但是两次调用却没有改变默认形参的值\n有没有精通Python的伙伴能解释一下。", "Tag": "算法分析"}
{"Answer": "应该是yz两个网络输出1，x网络第一层计算之后3个值变为0，唯一不为0的经过权重为0的乘积后也变成0 了", "Konwledge_Point": "线性规划和规约", "Question": "神经网络的简单问题。\n考虑下面的神经网络，哪两个网络输出1?\n\n\n一道神经网络问题，比较急，回答秒采纳", "Tag": "算法分析"}
{"Answer": "上面说得很清楚啊。你都不知道哪里，我们怎么知道。按照你发的错误图片，那就是图片的那里", "Konwledge_Point": "线性规划和规约", "Question": "不知道怎么去找错误在哪里\n", "Tag": "算法分析"}
{"Answer": "这两个单词大小写错了，跟你定义的不一致", "Konwledge_Point": "线性规划和规约", "Question": "数据结构线性表代码出现错误\n出现了错误不知道怎么改\nUse of undeclared identifier ‘MaxSize’\nUnknown type name‘S q li s t’", "Tag": "算法分析"}
{"Answer": "该回答通过自己思路及引用到GPTᴼᴾᴱᴺᴬᴵ搜索,得到内容具体如下：\n您好！根据您提供的代码，这个问题是因为您没有指定求解器，而默认情况下 MATLAB 会使用非线性最小二乘法（lsqnonlin）求解优化问题。但是，由于您的问题是一个非线性无约束优化问题，因此应该使用 fminunc 函数进行求解。\n\n您可以使用以下代码将 fminunc 作为求解器来解决这个问题：\nprob = optimproblem('ObjectiveSense','min');\na = optimvar('a',1,1,'LowerBound',0,'UpperBound',1);\nf = 1531.9396*(-0.0255493101686254*a*(9.58*a + 19.98) + a + 0.0255493101686254*a*(-a*(9.58*a + 19.98) + 29.56*a)/(1 - a) - 0.0250383239652529)^2 ;\nprob.Objective = f;\nshow(prob);\nopts = optimoptions('fminunc','Algorithm','quasi-newton');\n[sol,fval,flag,out] = solve(prob,'options',opts);\n\n在上面的代码中，我们使用了 optimoptions 函数为 fminunc 指定了一个选项，其中 Algorithm 参数设置为 'quasi-newton'，这是一种非常常用的无约束非线性优化算法。然后，我们将这个选项作为第二个参数传递给 solve 函数，以使用 fminunc 求解您的问题。\n希望这可以帮助您解决问题！\n\n如果以上回答对您有所帮助，点击一下采纳该答案～谢谢", "Konwledge_Point": "线性规划和规约", "Question": "关于#MATLAB#的问题，如何解决？\nMATLAB入门，对于求解非线性优化问题有一处报错不理解，望解答修改\n\n\nprob\n = optimproblem('ObjectiveSense','min');\n\na\n = optimvar('a',\n1\n,\n1\n,'LowerBound',\n0\n,'UpperBound',\n1\n);\n\nf\n = \n1531\n.\n9396\n*(-\n0\n.\n0255493101686254\n*a*(\n9\n.\n58\n*a + \n19\n.\n98\n) + a + \n0\n.\n0255493101686254\n*a*(-a*(\n9\n.\n58\n*a + \n19\n.\n98\n) + \n29\n.\n56\n*a)/(\n1\n - a) - \n0\n.\n0250383239652529\n)^\n2\n \n\nprob\n.Objective = f;\n\nshow\n(prob);\n\n[sol,fval,flag,out] = solve(prob);\n\n\n\n", "Tag": "算法分析"}
{"Answer": "在路径前面加一个 r'路径'，就可以了，问题是出在其中的“\\”符号上，会被当做转义字符的", "Konwledge_Point": "线性规划和规约", "Question": "如图   为什么指定路径总是提示错误？\n", "Tag": "算法分析"}
{"Answer": "第二生产总值的估计系数为负，可能表明第二产业和港口吞吐量之间存在负相关关系。但是，这并不能说明第二产业对港口吞吐量有负向影响。这只是一个单独的统计结论，需要进一步考虑其他因素和数据，并进行完整的统计分析和经济解释才能得出结论。另外，由于第二产业比重却是显著正向的，这可能表明在模型中缺少一些重要的影响因素或者数据有偏差，导致结果的不一致。建议进行进一步的数据清理。", "Konwledge_Point": "线性规划和规约", "Question": "第二生产总值的估计系数为负，但是第二生产总值比重却是正的，我这个固定效应回归模型是正常的吗？\n港口吞吐量作为因变量，stata，面板数据是从1999-2021的不平稳面板数据。回归后很多估计指标不显著。然后通过控制数据选取范围，把估计系数的p值降到只有两个不显著，但是有一个第二产业的符号是负的 它这个指标的p值是0.042，这是不是说明，第二产业对港口吞吐量的作用是负向的？是不是不合理？因为跟通常的说法不一样。然而第二产业比重却是显著正向的。我是哪里错了？", "Tag": "算法分析"}
{"Answer": "首先用数据构建一个堆，然后不断调整非叶子节点（也就是数据之间相互比较，用较大的数做为根节点并交换，交换后记得检查相关的节点），保证较大树做为根，然后弹出堆顶元素（与最后一个元素交换，然后忽略已排好的元素就可以了）：\n\n", "Konwledge_Point": "线性规划和规约", "Question": "这个怎么构建最大堆并描述升序过程、\n对关键字表为{16,5,9,17,2,8,33,10,6,90}的无序序列进行累堆排序(升序) ,请构建最大堆,并描述累堆排序过程", "Tag": "算法分析"}
{"Answer": "\n\n\n\n\n\n         https://blog.csdn.net/weixin_64565994/article/details/125253331\n        \n\n（一）快速排序的最好情况O（nlogn）（二）快速排序的最坏情况O（n^2）", "Konwledge_Point": "线性规划和规约", "Question": "快速排序的时间复杂性不受数据初始状态影响，恒为O(nlog2n)。\n快速排序的时间复杂性不受数据初始状态影响，恒为O(nlog2n)。（\n【答案】错\n不是对的吗，哪里错了", "Tag": "算法分析"}
{"Answer": "你得先说清楚你函数的意思啊。为啥要修改呢？？？而且代码也没给完整，你真有这需求？if (flag = false)  这个flag从天而降", "Konwledge_Point": "线性规划和规约", "Question": "可不可以修改一下 但不改变函数意思 写一下解释\npublic void insert(Node head, Node new node)\n{\nboolean inserted = false; if (head == null) head = newnode; if (head.next==null) head.next=newnode; while(head.next!=null)\n{\nif (head.next.value>newnode.value)\n{\nNode temp = head.next; head.next=newnode; newnode.next=temp; inserted =true; break;\n\n\nelse\nhead = head.next;}\nif (flag = false)\nhead.next=newnode", "Tag": "算法分析"}
{"Answer": "这个错误通常是由于在模型训练过程中发生了数据类型或形状不匹配的错误导致的。要解决这个问题，需要检查代码中的数据处理部分，以确保输入和输出的形状和数据类型与模型的期望相匹配。以下是一些可能导致此错误的常见原因和解决方法：（1）输入数据的形状或数据类型与模型期望的不匹配。检查输入数据的形状和数据类型，并确保它们与模型期望的相同。（2）数据预处理或增强的过程中发生错误，导致生成的数据形状或数据类型与模型期望的不匹配。检查数据预处理和增强代码，并确保生成的数据与模型期望的形状和数据类型相同。（3）使用了不支持的数据类型或操作。检查代码中使用的所有数据类型和操作，并确保它们都是支持的。", "Konwledge_Point": "线性规划和规约", "Question": "（python）如何解决 ValueError: in user code:这个问题，能解决一下吗？\n\nmodel = Sequential()\n\n#conv layer\n\nmodel.\nadd\n(Conv2D(6,(5,5),activation = \n'relu'\n))\n\n#Maxpooling layer\n\nmodel.\nadd\n(MaxPooling2D(pool_size=(2, 2), \nstrides\n=2, \npadding\n=\n'same'\n))\n\n#conv layer\n\nmodel.\nadd\n(Conv2D(16, (5, 5), \nactivation\n=\n'relu'\n))\n\n#Maxpooling layer\n\nmodel.\nadd\n(MaxPooling2D(pool_size=(2, 2), \nstrides\n=2, \npadding\n=\n'same'\n))\n\n#fully connected layer\n\nmodel.\nadd\n(Flatten())  # 进行全连接之前要将多维变量变成二维变量，因为全连接层的输入只能是二维变量即平化层\nmodel.\nadd\n(Dense(120, \nactivation\n=\n'relu'\n))  # 增加一个激活函数提高模型参数的非线性能力\nmodel.\nadd\n(Dropout(0.5))  # 表示随机去掉50%的神经元连接\n\n# Flatten()  因为上一层的输出就是一个二维变量，所以这里不需要进行拉直操作了\n\nmodel.\nadd\n(Dense(84, \nactivation\n=\n'relu'\n))  # 增加一个激活函数提高模型参数的非线性能力\nmodel.\nadd\n(Dropout(0.5))  # 表示随机去掉50%的神经元连接\n\n#output layer \n\nmodel.\nadd\n(Dense(7, \nactivation\n=\n'softmax'\n))  # 增加这个激活函数便于多分类\n\n\nfrom\n tensorflow.keras.optimizers import SGD\n\nsgd = SGD(\nlr\n=0.01, \nmomentum\n=0.9, \nnesterov\n=\nTrue\n)\nmodel.compile(\nloss\n=\n'categorical_crossentropy'\n,\n              \noptimizer\n=sgd,\n              metrics=[\n'accuracy'\n])\n\n# #compile\n\n\n# model.compile(optimizer = 'adam',\n\n\n#              loss='sparse_categorical_crossentropy',\n\n\n#              metrics=['accuracy'])\n\n\n#fit\n\nmodel.fit(x_train, y_train,\nbatch_size\n=20,epochs=20,validation_data=(x_test,y_test))\n", "Tag": "算法分析"}
{"Answer": "可以看下帮助，我不太懂‘x’这个参数设置的意义。https://ww2.mathworks.cn/help/matlab/ref/diff.html", "Konwledge_Point": "线性规划和规约", "Question": "MATLAB函数求导报错\n不太明白MATLAB中diff()函数有什么要求。\n或者有其他问题？\n\n\n%%%% 牛顿迭代法求非线性方程实根%%%%%\nclc;\n\nclear\n\n\nformat\n short\ns=\nin\n\nput(\n'请输入函数表达式：f = '\n,\n's'\n);\n\nglobal\n f;\nf=inline(s,\n'x'\n);\nX = input(\n'请输入初始点:x0='\n);\nfai(X)\nfunction f1=fai(x)\n\nglobal\n f;\ntempf=diff(f,\n'x'\n);\nf1=x-f/tempf;\nend\n\n\n\n还没写完，\n下面是命令与报错：\n\n\n请输入函数表达式：f = x*x\n请输入初始点:\nx0\n=1\n检查对函数 \n'diff'\n 的调用中是否存在不正确的参数数据类型或缺少参数。\n\n出错 Newtonian_iterative_method>fai (第 16 行)\n\ntempf\n=diff(f,'x');\n\n出错 Newtonian_iterative_method (第 9 行)\nfai(a)\n \n16  \ntempf\n=diff(f,'x');\nK>> \n\n\n\n", "Tag": "算法分析"}
{"Answer": "聚类分析例程，你将X换成你的数据就可以用：\n%Matlab程序如下：\nX=[244.42    412.04   459.63    512.21  160.45    43.51     89.93    48.55   48.63\n435.77    724.85   376.04    381.81  210.39    71.82   150.64     23.74  188.28\n321.75    665.80   157.94    172.19  147.16    52.44     78.16     10.90    93.50                                                                       \n152.29    258.60     83.42      85.10    75.74    26.75     63.47       5.89    47.02                                                                \n347.25    332.59   157.32    172.48  115.16    33.80     77.27       8.69    79.01                                                                    \n145.40    143.54     97.40    100.50    43.28    17.71     51.03       5.41    62.03                                                                  \n442.20    665.33    411.89   429.88   115.07   87.45   145.25     21.39  187.77 ]';\nY=pdist(X);\nSF=squareform(Y);\nZ=linkage(Y,'average');\ndendrogram(Z);\nT=cluster(Z,'maxclust',3)\n\n\n详细参考：https://blog.csdn.net/henu111/article/details/81512314", "Konwledge_Point": "线性规划和规约", "Question": "数学建模萌新小白求救\n有20个土壤样品，分别给出5个变量的观测数据如下表所示，利用系统聚类法对其进行样品聚类分析", "Tag": "算法分析"}
{"Answer": "这个错误是因为在运行bwselect时参数不正确导致的。建议检查以下几个方面：\n参数 y、v、c(0) 是否正确。其中 y 和 v 是必须参数，分别表示原始数据集和输出数据集。c(0) 是一个可选参数，表示颜色变量，如果原始数据集没有颜色变量，可以省略该参数。\nkernel(uni)bwselect(meserd) 中的参数是否正确。其中 kernel 表示使用的核函数，这里是指使用的是 univariate 核函数；bwselect 表示带宽选择方法，这里是指使用的是 meserd 带宽选择方法。\n检查是否已经安装了 bwselect 插件。可以使用命令 findit bwselect 来查找并安装 bwselect 插件。如果已经安装了插件，可以尝试更新插件并重新运行命令。\n如果以上都检查过了还是无法解决问题，建议提供更详细的错误信息和数据集以便进行更具体的排查。", "Konwledge_Point": "线性规划和规约", "Question": "stata bwselect报错\n求问！stata 做断点回归\n运行这个 rdbwselect y v, c(0) kernel(uni) bwselect(mserd)\n一直出现   bwselect() incorrectly specified  已安装外部命令", "Tag": "算法分析"}
{"Answer": "具体的没理解你最终需要的效果😂，只发表一下自己的见解：arcgis作图基本都是空间上展示（比如一个地域上的平面差异等），如果想要展现时间上的差异，我觉得要么就是多时序的图片显示，或者直接显示一段时间内的差异变化吧。", "Konwledge_Point": "线性规划和规约", "Question": "arcgis每年递增的数据如何统一图例？\n类似于gdp之类每年递增的数据，用arcgis作图如果按照自动分级的方法，感觉就不能体现出时间演变的趋势了，能否通过统一尺度的方法在地图中也展示出时间的演变趋势（色块的深浅）？", "Tag": "算法分析"}
{"Answer": "这题不是让你把f(x)的函数形式表达出来，而是让你根据曲线图把g(x), h(x), k(x)函数是怎样从f(x)变换得到的关系写出来。\ng(x) = f(x-2) -1\nh(x) = -f(x-2)-1\nk(x) = -0.4 * f(-x -2)\n", "Konwledge_Point": "线性规划和规约", "Question": "这种波浪函数的表达式怎么求\n初步构想是使用三角函数的模板，构造一个类似的函数，但是不清楚是否可行", "Tag": "算法分析"}
{"Answer": "第一题，可以用头插法进行原地逆置，按顺序遍历链表，每遍历一个就插入到头结点的后面。void reverseList(nodeList &L) {\n Node*p = L->next,*tmp;\n L->next = NULL;//这里是为了保证最后一个结点指向NULL\n while (p) {//遍历链表\n     if (p->next)\n         tmp = p->next;\n     else\n         tmp = NULL;\n     //插入到L头结点的后面\n     p->next = L->next;\n     L->next = p;\n     p = tmp;\n }\n}\n\n第二题1）元素最多不会超过L长度，我认为也可以插入到第0个数据之后：i<0 || i>L.length2）初始化申请的最大空间为MAXSIZE：L.length == MAXSIZE3）把第i个后面的元素往后挪，但数组下标从0开始所以是i-1：j > i - 14）数组下标从0开始所以第i+1个数位置是i下标：L.elem[i] = e;5）L.length++;", "Konwledge_Point": "线性规划和规约", "Question": "这些空怎么填啊，初学者 ，有几个不会，有没有人解，决一下，不知道怎么做 不知道 不知道怎么做\n\n\n不知道怎么做，有没有人解决一下 ，我还是初学者不会这些题目，有没有人解决一下", "Tag": "算法分析"}
{"Answer": "以下内容部分参考ChatGPT模型：\n\n要计算影像组学R_Score评分，可以按照以下步骤进行：\n确定特征对应的回归系数\n使用机器学习算法训练模型，得到特征与目标变量之间的关系，从而得到每个特征对应的回归系数。\n计算每个影像组学评分\n对于每个影像组学数据样本，将其特征值代入回归方程中，得到对目标变量的预测值，即影像组学评分。\n线性组合计算总评分\n将所有影像组学评分进行线性组合，得到总评分。\n以下是一个简单的例子，使用线性回归算法训练模型，计算影像组学R_Score评分：\nfrom sklearn.linear_model import LinearRegression\n\n# 训练模型\nX = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] # 特征矩阵\ny = [10, 20, 30] # 目标变量\nmodel = LinearRegression().fit(X, y)\n\n# 计算每个影像组学评分\nimage_features = [[2, 4, 6], [3, 5, 7], [1, 8, 9]]\nimage_scores = model.predict(image_features)\n\n# 线性组合计算总评分\ntotal_score = sum(image_scores)\n\n以上代码中，首先使用LinearRegression算法训练模型，得到每个特征对应的回归系数。然后，将影像组学数据样本的特征值代入回归方程中，得到对目标变量的预测值，即影像组学评分。最后，将所有影像组学评分进行线性组合，得到总评分。\n\n如果我的建议对您有帮助、请点击采纳、祝您生活愉快", "Konwledge_Point": "线性规划和规约", "Question": "影像组学评分R_Score\n用Python要怎么计算影像组学R_Score评分呀！\n（选定特征对应的回归系数，将所有影像组学评分经过线性组合计算出来）", "Tag": "算法分析"}
{"Answer": "你已经有t 值了，那计算r 的话这个公式r=[t^2/(t^2+df)]^0.5 应该能看懂吧。df=n1+n2-2  ,n1,n2 就是两组样本的数量。", "Konwledge_Point": "线性规划和规约", "Question": "Meta分析t值、f值如何转换为r值？\n很多文献只给了回归分析结果，有t值，但是不会转换为r值，比如这种：\n（n🟰561）\n\n\n还有这种\n\n\n\n\n再有的文献中写了怎么算，但是纯社科学渣一个，不会转换，那个自由度搞不清楚，比如：\n\n\n希望有有相关经验的朋友解释解释\n能算的话希望给个带入数值后的计算过程或者相关计算器\n万分感谢", "Tag": "算法分析"}
{"Answer": "如果您只有问卷调查的选项占比数据，而没有原始数据，那么无法直接使用 SPSS 进行回归分析。回归分析需要使用原始数据，即每个样本的具体数值。而选项占比只是一种统计数据，无法直接作为回归分析的输入数据。\n如果您想进行回归分析，您需要从其他渠道获取原始数据。例如，您可以重新进行一次问卷调查，收集每个样本的具体数值，然后使用 SPSS 进行回归分析。另外，您也可以尝试从其他数据来源中获取相关数据，比如已有的研究报告、公共数据集等等。\n需要注意的是，回归分析需要根据具体问题和研究目的进行设计和分析，并不是简单地将数据输入 SPSS 中就能得到结果。因此，在进行回归分析前，建议您充分了解回归分析的原理和方法，制定合理的分析方案，并选择适当的统计工具进行分析。", "Konwledge_Point": "线性规划和规约", "Question": "SPSS只知道问卷调查的数据百分比，能做回归分析嘛\n只知道问卷调查的数据百分比，比如第一个选项30％第二个选项15％第三个选项45％第四个选项10％，所有的问题都只知道选项占比，我想用这种选项占比做SPSS回归分析，能做嘛", "Tag": "算法分析"}
{"Answer": "豪斯曼检验是用来检验随机效应模型是否适用于数据的一种方法，它的基本原理是在随机效应和固定效应两种假设下，比较不同变量的F值，来确定哪种假设更适合数据。\n针对你的情况，有两个被解释变量，你可以将其分别作为因变量，进行两次豪斯曼检验。在每次检验中，自变量C和四个控制变量保持不变，分别计算出A和B的F值，并比较其显著性水平，以确定哪种假设更适用于对应的因变量。\n如果A适合固定效应而B适合随机效应，这意味着你需要使用混合效应模型来进行多元线性回归，其中A作为固定效应，B作为随机效应。\n需要注意的是，多元线性回归分析的结果需要在豪斯曼检验的基础上综合考虑，不能仅仅依据单个因变量的结果来确定模型的类型。另外，豪斯曼检验只是一种基于统计方法的判断，对于复杂数据情况下的模型选择，还需要结合实际问题进行综合分析。", "Konwledge_Point": "线性规划和规约", "Question": "有两个因变量应该怎么进行豪斯曼检验\n如果有两个因变量A和B，一个自变量C，四个控制变量，应该如何做豪斯曼检验？\n我现在阶段是将两个被解释变量拆开，解释变量和控制变量都不变，分别进行检验,但结果显示一个p小于0.05，适合用固定效应，另一个大于它，适合随机效应\n但是我需要进行多元线性回归，这个样子的话就不知道应该怎么进行了\n请问有人知道如何处理吗？", "Tag": "算法分析"}
{"Answer": "基于Monster 组和GPT的调写：下面是一个简单的例子，展示了如何在C++中使用Eigen库求解一个稀疏线性方程组：\n#include <Eigen/Sparse>\n#include <Eigen/Dense>\n\nint main()\n{\n    // 创建稀疏矩阵和向量\n    Eigen::SparseMatrix<double> A(10, 10);\n    Eigen::VectorXd b(10);\n\n    // 设置矩阵和向量的值\n\n    // ...\n\n    // 创建求解器并求解方程组\n    Eigen::SparseLU<Eigen::SparseMatrix<double>> solver;\n    solver.analyzePattern(A);\n    solver.factorize(A);\n    Eigen::VectorXd x = solver.solve(b);\n\n    return 0;\n}\n\n\n\n接下来，要把这个求解稀疏线性方程组的方法封装成dll，在C#程序中调用。先要创建一个C++的动态链接库，其中包含你的求解方法。具体的步骤包括：\n创建一个新的C++项目，选择“DLL”作为项目类型。在项目中添加您的求解方法的源代码。 在项目属性中设置“生成->配置类型”为“动态库(.dll)”，以及其他必要的设置，例如输出路径等。\n接下来要在C#程序中调用这个dll。具体的步骤包括：\n在C#程序中声明DllImport，以便能够使用外部的dll。创建一个C#类，其中包含您要调用的C++函数的签名。 在C#程序中调用这个C++函数。\n下面是一个简单的例子，展示了如何在C#程序中调用你的C++函数：\nusing System.Runtime.InteropServices;\n\npublic static class MyDll\n{\n    [DllImport(\"MyDll.dll\")]\n    public static extern void SolveSparseLinearEquation(\n        [In] int n,\n        [In] double[] A,\n        [In] int[] ia,\n        [In] int[] ja,\n        [In] double[] b,\n        [Out] double[] x\n    );\n}\n\npublic class Example\n{\n    public static void Main()\n    {\n        // 创建稀疏矩阵和向量\n        int n = 10;\n        double[] A = new double[10 * 10];\n        int[] ia = new int[10 + 1];\n        int[] ja = new int[10 * 5];\n        double[] b = new double[10];\n        double[] x = new double[10];\n\n        // 设置矩阵和向量的值\n\n        // ...\n\n        // 调用C++函数求解方程组\n        MyDll.SolveSparseLinearEquation(n, A, ia, ja, b, x);\n\n        // 处理求解结果\n\n        // ...\n    }\n}\n\n\n", "Konwledge_Point": "线性规划和规约", "Question": "找C++ C#的有缘人指导\n想找一个会C++和C#的厉害的有缘人在线指导一下，最好还了解过Eigen库😭\n我现在需要用C++调用Eigen库，写一个求解稀疏线性方程组的方法，然后封装成dll在C#程序中调用，求指导😭快崩溃了", "Tag": "算法分析"}
{"Answer": "回归分析需要满足一些基本原则，以便保证结果的有效性和准确性。\n如果你使用家庭数据作为一个自变量，但是这些数据是由同一家庭内的多个个人数据累加起来的，这样的数据可能会存在共线性问题，因为两个变量相关性过高，导致估计的系数不可靠。\n此外，在使用多元回归分析时，也需要考虑独立性原则，即自变量间应该相互独立，不存在多重共线性问题。\n因此，如果你想使用家庭数据作为自变量，建议检验家庭数据和个人数据之间的关系，以确保不存在共线性问题。", "Konwledge_Point": "线性规划和规约", "Question": "回归分析的自变量数据单位必须同一口径吗？\n在实证分析时运用到了charls数据库，数据库里面是家庭、个人以及社区三种标签，自变量一共有四组，其中三组是个人的数据，另外一组是家庭的数据，都是同一群人，家庭的数据是将同一家庭的个人数据累加起来了，回归分析也有结果，但是符合回归分析的原则吗？不知道有没有将问题讲清楚，希望大家可以帮个忙", "Tag": "算法分析"}
{"Answer": "要在COMSOL中显示线性传输比例图像，请按照以下步骤进行操作：\n点击“结果”选项卡，选择要显示图像的结果集。\n选择“表面绘图”或“体绘图”，具体取决于您想要绘制的图像类型。\n在“设置”窗口中，找到“可视化”选项卡并单击。\n在“颜色映射”下拉菜单中，选择“传输比例”。\n在“选择数据”下拉菜单中，选择“线性传输比例”。\n根据需要调整其他设置，例如最小值和最大值，颜色范围等。\n单击“确定”以应用更改并显示线性传输比例图像。如果您的结果显示为透射率或吸收率图像，您可以通过更改显示的结果类型来显示线性传输比例图像。在“结果”选项卡中，选择“切换结果类型”选项卡，然后选择“线性传输比例”作为结果类型。", "Konwledge_Point": "线性规划和规约", "Question": "comsol的结果问题\n在comsol里怎么显示线性传输比例图像？结果显示图像为透射率吸收率，怎么添加线性传输比例图像？", "Tag": "算法分析"}
{"Answer": "参考GPT和自己的思路：\n使用非线性混合效应模型来预测锂电池剩余寿命是可行的。建议使用MATLAB中的工具箱，例如Statistics and Machine Learning Toolbox来构建和训练模型。在建模之前，需要根据实验数据，尤其是寿命数据来选择合适的非线性模型，以及确定混合效应。另外，还需要对数据进行预处理和特征工程，以保证模型的准确性和可靠性。", "Konwledge_Point": "线性规划和规约", "Question": "关于#算法#的问题：利用非线性混合效应模型来预测锂电池剩余寿命预测可行吗(语言-matlab)\n利用非线性混合效应模型来预测锂电池剩余寿命预测可行吗？能不能提点建议？", "Tag": "算法分析"}
{"Answer": "笑死..稍等,我问问他有没有详细答案", "Konwledge_Point": "线性规划和规约", "Question": "Linear algebra, orthogonal线性代数\n\n\n能不能解释一下为什么4.1B(c)的答案是(1,-3,-4)?", "Tag": "算法分析"}
{"Answer": "答案代码如下：\nimport numpy as np\n\n# 定义矩阵A\nA = np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\n\n# 求逆矩阵\nA_inv = np.linalg.inv(A)\n\n# 验证AA_inv = A_invA = I\nprint(np.dot(A, A_inv))\nprint(np.dot(A_inv, A))\n\n输出结果为：\n[[1. 0. 0.]\n [0. 1. 0.]\n [0. 0. 1.]]\n[[1. 0. 0.]\n [0. 1. 0.]\n [0. 0. 1.]]\n\n并且 $AA^{-1}=A^{-1}A=I$ 成立，证明矩阵 $A$ 的逆矩阵计算正确。", "Konwledge_Point": "线性规划和规约", "Question": "Python求解线性代数的题\n假设有矩阵 $A=\\begin{bmatrix} 2 & 1 & 1 \\ 1 & 2 & 1 \\ 1 & 1 & 2 \\end{bmatrix}$，求矩阵 $A$ 的逆矩阵，并验证 $AA^{-1}=A^{-1}A=I$。", "Tag": "算法分析"}
{"Answer": "scipy库和matplotlib库，很快的", "Konwledge_Point": "线性规划和规约", "Question": "非线性微分方程画图像\n", "Tag": "算法分析"}
{"Answer": "这俩是一样的吗？ 原式是不是不一样啊，这里少一个换行就少一个负号", "Konwledge_Point": "线性规划和规约", "Question": "线性代数的一道小破题\n\n\n夸克里第三步到第四步是怎么来的，不应该是直接提出右下角的3*3矩阵吗\n\n\n\n\n以及我的这个解答有啥问题", "Tag": "算法分析"}
{"Answer": "", "Konwledge_Point": "线性规划和规约", "Question": "Linear algebra, determinant线性代数\n\n\n这道题怎么做？", "Tag": "算法分析"}
{"Answer": "", "Konwledge_Point": "线性规划和规约", "Question": "Linear algebra, projections线性代数\n\n\n4.2A 怎么算这个3 By 3 projection matrix P. 公式是划红线的这个\n\n\n\n\n但是在此题中，(At\nA)-1是2 by 2. A\nAt是3 by 3.怎么相乘？\n\n\n答案：\n\n", "Tag": "算法分析"}
{"Answer": "望采纳可以使用fsolve来解决这个问题，需要提供一个名为fun的函数，包含非线性方程组。函数的形式应该是这样的：\nfunction [f] = fun(x)\n    % x 是一个向量，包含未知变量 x, y 和 z 的值\n    % f 是包含方程的结果的向量，f(1) 对应第一个方程，f(2) 对应第二个方程，以此类推\n\n    % 您的方程组\n    f(1) = exp(x(1)) - (x(3) ./ x(2) - 1) / (x(3) / 18.3 - 1);\n    f(2) = exp(2 * x(1)) - (x(3) ./ x(2) - 1) / (x(3) / 29 - 1);\n    f(3) = exp(3 * x(1)) - (x(3) ./ x(2) - 1) / (x(3) / 47.2 - 1);\nend\n\n之后需要提供一个初始猜测值，然后调用fsolve。\nx0 = [1, 1, 1];  % 这是初始猜测值\nx = fsolve(@fun, x0);\n", "Konwledge_Point": "线性规划和规约", "Question": "MATLAB 非线性三元方程求解\n建立logistics模型时，用前三组数据解出初值，x-r，y-x0,z-xm\nexp(x)=(z./y-1)./(z/18.3-1)\nexp(2\nx)=(z./y-1)./(z/29-1)\nexp(3\nx)=(z./y-1)./(z/47.2-1)", "Tag": "算法分析"}
{"Answer": "首先，v = 0时，rank=0，这个不需要解释了吧。当v 不等于0即为实矩阵时，M = v vT矩阵乘矩阵的转置最后得到是对称矩阵；对称矩阵的rank就是1根据rank的定义，对称矩阵nXn的rank等价1Xn矩阵的秩而，m × n 矩阵的秩不大于m且不大于n的一个非负整数，表示为 rk(A) ≤ min(m, n)，所以rank=1。\n望采纳！", "Konwledge_Point": "线性规划和规约", "Question": "Linear algebra, transpose线性代数\n\n\n以下是答案：\n\n\n\n\n为什么rank不能是2？", "Tag": "算法分析"}
{"Answer": "是的，这段代码是在每个epoch结束后计算验证集的loss，上面的for循环中实际上每个step都更新了一次w和b", "Konwledge_Point": "线性规划和规约", "Question": "有关线性回归代码的问题\n所以这里是用上面优化出来的w,b，根据这些数据来计算损失函数的嘛？", "Tag": "算法分析"}
{"Answer": "你是问怎么把下面第一个转化为第二个吗？第一个：1 2 3  5   02 4 8 12  63 6 7 13 -6第二个：1 2 3 5 00 0 2 2 60 0 0 0 0第一行A1：不变第二行A2：A2-2A1=0 0 2 2 6第三行A3：3A1-A3=0 0 2 2 6第二行等于第三行，所以第三行可以去掉因此结果为：1 2 3 5 00 0 2 2 60 0 0 0 0也可以写成：1 2 3 5 0(A1)0 0 1 1 3(A2)0 0 0 0 0(A3)对第一行进行处理：A1-3*A2=1 2 0 2 -9最终的结果就是：1 2 0 2 -90 0 1 1 30 0 0 0 0 ", "Konwledge_Point": "线性规划和规约", "Question": "线性代数的问题，linear algebra\nAx = b is\nx1 + 2x2 + 3x2 + 5x4 = b1\n2x1 + 4x2 + 8x3 + 12x4 = b2\n3x1 + 6x2 + 7x3 + 13x4 = b3\nTurn [A b] to [R d]: special solutions from R, particular solution from d.\n\n\n正确答案的式子的右边是[-9 3 0] 就是b1 = -9, b2 = 3, b3 = 0。能解释一下为什么吗？\n\n\n这是问题，我想问的第五题：\n\n\n\n\n\n\n这是答案：\n\n", "Tag": "算法分析"}
{"Answer": "一种全同态加密的安全内积计算方案\r\nhttp://www.wanfangdata.com.cn.wust.dr2am.cn/details/detail.do?_type=perio&id=dzkjdxxb201605017", "Konwledge_Point": "线性规划和规约", "Question": "有关密文检索排序问题\n利用线性索引结构进行密文检索并排序时，请问除了安全的KNN算法还有什么方法能让加密后的内积与加密前计算的内积相等？\n\n       在研究密文检索时，索引和陷门都是二进制索引向量，希望在公有云服务器中的计算密文环境下索引向量和陷门向量的内积，除了使用可逆矩阵加密的那种knn算法，还有什么方法可以达到要求呢？\n\n        或许也不需要密文计算的内积与加密前计算的内积相等，只要能比较大小就行，在服务器端能够实现排序", "Tag": "算法分析"}
{"Answer": "https://www.cnblogs.com/johnnyzhao/p/15414850.html", "Konwledge_Point": "线性规划和规约", "Question": "Rust是如何实现内存安全的，与其他编程语言有何不同？比如C/C++/Java…\n当谈到内存管理，尤其是堆内存时，我们常希望编程语言：1.不需要内存时就尽快释放，且不增加资源消耗；2.对已释放数据的引用进行自动维护，否则极易发生程序崩溃和安全问题。\n\n\n编程语言往往通过这些方式确保内存安全，比如：显式内存释放（C/C++）；自动或隐式内存释放（Java/Python/C#）；基于区域的内存管理；线性或特殊类型系统。\n\n\n那么，Rust是如何实现内存安全的呢？和其他语言有何不同？", "Tag": "算法分析"}
{"Answer": "原始数据—>滑动窗口L=10截取原始数据得到N个子序列—>线性拟合—>标准化斜率—>子序列符号化处理—>Apriori算法我觉得这个说的挺清楚的啊，关联算法本身解决的是各个商品的关联度，其实就是分类变量的关联关系。所以这里不是转成布尔值，符号化处理是转成了分类量。所以这里的处理逻辑就是将原始数据按滑动窗口分成N个子序列（N个商品），线性拟合得出斜率（斜率是连续值通过符号化处理转成分类变量，相同的符号比如1a,1b ,就认为是同一个商品），然后就是典型的关联算法处理逻辑了", "Konwledge_Point": "线性规划和规约", "Question": "两列时间序列数据怎么用apriori算法做关联分析呢？(语言-python)\n问题遇到的现象和发生背景\n\n\n就是两列时间序列数据怎么用apriori算法做关联分析呢？比如水位一列数据 位移一列数据 那怎么得出水位和位移这两个效应量关联度吗？\n\n\n问题相关代码，请勿粘贴截图\n\n\nPython 编程实现\n\n\n运行结果及报错内容\n\n\n我的解答思路和尝试过的方法\n\n\n关联规则所使用的的Apriori算法要求输入的数据应为布尔类型吗？所以数值类型就要符号化？\n看到一篇文献是这样做的：原始数据—>滑动窗口L=10截取原始数据得到N个子序列—>线性拟合—>标准化斜率—>子序列符号化处理—>Apriori算法\n搞不明白文中说从由每段斜率组成的事务集中找出频繁项集是什么意思？\n\n\n\n\n我想要达到的结果\n\n\n输出水位与位移这两监测效应量的关联性", "Tag": "算法分析"}
{"Answer": "```\r\n 因为对于n，这个函数递归调用n次\r\n本质上，这个递归其实不是递归，就是循环（尾递归）\r\nlong f(int n)\r\n{\r\nint acc = 1;\r\nwhile (n > 1)\r\n{\r\nacc = n * acc;\r\nn = n - 1;\r\n}\r\nreturn acc;\r\n}\r\n```", "Konwledge_Point": "线性规划和规约", "Question": "数据结构与算法那：程序运行时间的问题\n\n\n\n本人刚接触数据结构和算法，有个地方不是很懂，这个程序书上说运行时间为O(n)， 我不明白为什么是O(n),  T(n) = n * (n-1), 怎么换算也不能是O（n）线性的啊，求大神帮我讲解，越详细越好，本人真的小白。", "Tag": "算法分析"}
