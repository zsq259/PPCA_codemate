{"Answer": "您可以使用非线性规划库，例如 Math.NET Numerics 中的 NLopt 或者 Accord.NET 中的 Nelder-Mead 和 Simplex 方法来实现非线性规划。\nusing Accord.Math;\nusing Accord.Optimization;\n\nnamespace NonlinearProgrammingExample\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            // Define the objective function\n            NonlinearObjectiveFunction function = new NonlinearObjectiveFunction(x =>\n                x[0] * x[1] * (x[0] + x[1]),\n                2 // number of variables\n            );\n\n            // Define the constraints\n            NonlinearConstraint constraint1 = new NonlinearConstraint(x =>\n                x[0] * x[0] + x[1] * x[1] - 1,\n                0,\n                LessThanOrEqualToZero\n            );\n            NonlinearConstraint constraint2 = new NonlinearConstraint(x =>\n                x[1] - x[0],\n                0,\n                GreaterThanOrEqualToZero\n            );\n\n            // Create the solver\n            NonlinearProgram solver = new NonlinearProgram(function, new[] { constraint1, constraint2 });\n\n            // Solve the problem\n            double[] result = solver.Solve();\n\n            // Print the results\n            Console.WriteLine(\"Result: x = [{0}], f(x) = {1}\", string.Join(\", \", result), function.Value(result));\n        }\n    }\n}\n\n\n\n```", "Konwledge_Point": "线性规划简介", "Question": "c#如何解决非线性规划\n目前想要用c#做一个求解简单的非线性规划的程序\n之前试过用matlab，但是似乎不能转换文件格式", "Tag": "算法分析"}
{"Answer": "http://www.acmerblog.com/hdu-1931-Target-Practice-3006.html", "Konwledge_Point": "线性规划简介", "Question": "一个有关于线性规划的问题，具体问题请看下面的问题描述\nProblem Description\n\nThere are many forms of contests where the contestants (shooters) try to hit targets, either moving or still. In this version there are a number of small balloons sitting on the tops of poles that are in turn stuck in the ground at various points in a large field. These poles are not all the same height. The shooter circles the field and fires at the balloons, the goal being to burst all the balloons with as few shots as possible. Since the balloons offer almost no resistance to a bullet, the bullet will pass right through and possibly hit one or more other balloons. So, by judiciously taking shots, the shooter might need only a very few shots to hit all the targets (provided the shooter is a good marksman, which we will assume is the case).\n\nFor example, the following field of 10 targets can be covered in only four shots, as shown. (The first two numbers at each position indicate the position of the balloon, and the third number the height.)\n\nYour job is to determine the fewest number of shots necessary to hit all the targets in a given field.\n\n\n\nInput\n\nThere will be multiple test cases. Each test case will consist of an integer n (<= 50) indicating the number of target positions to follow. A value of n = 0 indicates end of input. There will follow n integer triples, x y h, indicating a balloon at position (x, y) in the field at height h. (There will be at most one balloon at any position (x, y).) All integers are greater than 0 and no greater than 100. Furthermore assume that the shooter can take shots from anywhere on the field at any height. For simplification, assume here that the balloons are points and that the bullets can pass through the poles on which the balloons are perched.\n\n\n\nOutput\n\nEach test case should produce one line of output of the form:\n\nTarget set k can be cleared using only s shots.\n\nwhere k is the number of the test case, starting at 1, and the value of s is the minimum number of shots needed to hit all the targets in the set.\n\n\n\nSample Input\n\n10\n\n5 15 4 10 60 52 17 27 4 33 20 10 33 85 31 42 52 4 70 70 22\n\n78 88 4 85 40 58 100 75 7\n\n9\n\n5 15 4 10 60 52 17 27 4 33 20 10 33 85 31 42 52 4 70 70 22\n\n78 88 4 100 75 7\n\n0\n\n\n\nSample Output\n\nTarget set 1 can be cleared using only 4 shots.\n\nTarget set 2 can be cleared using only 3 shots.", "Tag": "算法分析"}
{"Answer": "目标函数不是线性函数，这个优化问题不是线性规划，可以使用有约束非线性优化方法来求求解，使用fmincon函数，代码如下：\n\nfun = @(x) 12*x(1) + 3*x(1)*ceil(x(2)-1) - 1.5*ceil(x(2)-1)*x(1);\nA = [1 0\n     0 1\n     -1 0\n     0 -1];\nb = [1\n     30\n     0\n     0];\nx0 = [0.5 15]';\nx = fmincon(fun,x0,A,b);\ng = fun(x)\n\nw = x(1)\nxx = x(2)\np = w/3\n结果\n\ng =\n\n   2.0001e-08\n\n\nw =\n\n   1.6667e-09\n\n\nxx =\n\n    0.0983\n\n\np =\n\n   5.5557e-10\n ", "Konwledge_Point": "线性规划简介", "Question": "MATLAB线性规划问题\n如何使用MATLAB求下列方程最优解\nmin f(x)=12*ω+3*ω*ceil (x-1)-1.5*ceil (x-1)\nω=3*p\n0≤x≤30\n0＜ω＜1\n求最优 x 和 ω 以及 p\n", "Tag": "算法分析"}
{"Answer": "http://muchong.com/t-4879914-1", "Konwledge_Point": "线性规划简介", "Question": "求助非线性环节线性化\n对于双容水箱液位控制系统，如何对描述水箱输出方程中的非线性环节进行线性化？两个水箱对应输出描述方程如图一，系统描述方式如图2.急求大佬解答！！！", "Tag": "算法分析"}
{"Answer": "非线性系统不能用ss函数来建模了，ss只能描述线性状态方程，非线性系统需要用微分方程描述，使用ode45来求解响应。", "Konwledge_Point": "线性规划简介", "Question": "如何使用matlab解决非线性状态空间的问题\n在状态空间系统中，如E\\dot x=Ax+Bu,y=Cx+Du中，A矩阵内含有x2，该如何修改matlab程序，使得程序可以运行。\n\n\n\n \n\n\n\nE=[1 1;0 0]\n\nA=[-2 0;1 x2];%x=[x1;x2]\n\nB=[-1;0];\n\nC=[-1 -1];\n\nD=0;\n\nt=0:0.01:5;\n\nw=exp(-t);\n\nsys1=dss(A,B,C,D,E);\n\n[y,t,x]=lsim(sys1,w,t);\n\nplot(t,x)\n\n ", "Tag": "算法分析"}
{"Answer": "我有  要么。。。。。。。。", "Konwledge_Point": "线性规划简介", "Question": "基于DSP技术的图像线性变换系统设计\n要求：1.在图形窗口显示原图，处理后的结果图。\n\n             2.图像使用源数据为JPG格式的彩色图像，处理图像为经过变换后的灰度图像。\n\n            3.对灰度图像进行线性变换\n\n            4.使用ccs3.3  编程，c语言", "Tag": "算法分析"}
{"Answer": "MatrixEquation me = new MatrixEquation(x点的数组， y点的数组, n);\r\nme.XXX调用，具体看你上面注释", "Konwledge_Point": "线性规划简介", "Question": "c#实现最小二乘法线性拟合\npublic class MatrixEquation\n\n    {\n\n        private double[,] gaussMatrix;\n\n        private int coe;\n\n\n\n    public MatrixEquation()\n    {\n    }\n\n    public MatrixEquation(double[] arrX, double[] arrY, int n)\n    {\n        coe = n;\n        gaussMatrix = GetGauss(GetXPowSum(arrX, n), GetXPowYSum(arrX, arrY, n), n);\n    }\n\n    public double[,] GetGaussMatrix()\n    {\n        return gaussMatrix;\n    }\n\n    public double[] GetResult()\n    {\n        return ComputeGauss(gaussMatrix, coe);\n    }\n\n    ///  计算获取x散点的幂次和数组  \n    /// x散点序列 \n    /// 函数拟合次数 \n    ///  \n    protected double[] GetXPowSum(double[] arrX, int n)\n    {\n        int m = arrX.Length;//X散点的个数\n\n        double[] xPow = new double[2 * n + 1]; //存储X散点的幂次值\n\n        for (int i = 0; i < xPow.Length; i++)\n        {\n            if (i == 0)\n            {\n                xPow[i] = m;\n            }\n            else\n            {\n                //计算x的i次方和\n\n                double max = 0;\n                for (int j = 0; j < m; j++)\n                {\n                    if (arrX[j] == 0)\n                        max = max + 1;\n                    else\n                        max = max + Math.Pow(arrX[j], i);\n                }\n                xPow[i] = Math.Round(max, 4);\n            }\n        }\n        return xPow;\n    }\n\n    /// 计算获取xy的幂次和序列  \n    /// x散点序列 \n    /// y散点序列 \n    /// 拟合曲线次数 \n    ///  \n    protected double[] GetXPowYSum(double[] arrX, double[] arrY, int n)\n    {\n        int m = arrX.Length;//X散点的个数\n\n        double[] xyPow = new double[n + 1]; //仓储X散点的幂次值\n\n        for (int i = 0; i < xyPow.Length; i++)\n        {\n            //计算xy的i次方和\n\n            double max = 0;\n            for (int j = 0; j < m; j++)\n            {\n                if (arrX[j] == 0)\n                    max = max + 1;\n                else\n                    max = max + Math.Pow(arrX[j], i) * arrY[j];\n            }\n            xyPow[i] = Math.Round(max, 4);\n        }\n        return xyPow;\n    }\n\n    ///  获取高斯矩阵(增广矩阵)             \n    /// X的幂次和 \n    /// XY的幂次和 \n    /// 拟合曲线次数 \n    ///  \n    protected double[,] GetGauss(double[] arrX, double[] arrXY, int n)\n    {\n        double[,] gauss = new double[n + 1, n + 2];\n        for (int i = 0; i < n + 1; i++)\n        {\n            int j;\n            int m = i;\n            for (j = 0; j < n + 1; j++)\n            {\n                gauss[i, j] = arrX[m];\n                m++;\n            }\n            gauss[i, j] = arrXY[i];\n        }\n\n        return gauss;\n    }\n\n    ///  求解拟合曲线的系数                   \n    /// 线性方程的增广矩阵 \n    /// 方程次数 \n    ///  \n    protected double[] ComputeGauss(double[,] gauss, int n)\n    {\n        double[] a = new double[n + 1];\n        double s;\n        int matrixLine = n + 1;\n        for (int i = 0; i < n + 1; i++)\n            a[i] = 0;\n        //循环每列\n\n        for (int j = 0; j < matrixLine; j++)\n        {\n            //每列J行以后的绝对值最大值\n\n            double max = 0;\n            int k = j;\n            for (int i = j; i < matrixLine; i++)\n            {\n                if (Math.Abs(gauss[i, j]) > max)\n                {\n                    max = gauss[i, j];\n                    k = i;\n                }\n            }\n            //判断j行否为最大值行 若不是将j行调换为最大值行\n\n            if (k != j)\n            {\n                double temp; for (int m = j; m < matrixLine + 1; m++)\n                {\n                    temp = gauss[j, m];\n                    gauss[j, m] = gauss[k, m];\n                    gauss[k, m] = temp;\n                }\n            }\n            if (max == 0)\n            {\n                //奇异矩阵无解\n\n                return a;\n            }\n            //进行初等行变换得到上三角矩阵\n\n            for (int i = j + 1; i < matrixLine; i++)\n            {\n                s = gauss[i, j];\n                for (int m = j; m < matrixLine + 1; m++)\n                {\n                    gauss[i, m] = Math.Round(gauss[i, m] - gauss[j, m] * s / gauss[j, j], 6);\n                }\n            }\n        }\n        //根据倒推方式一次计算现行方程的解\n\n        for (int i = matrixLine - 1; i >= 0; i--)\n        {\n            s = 0;\n            for (int j = i + 1; j < matrixLine; j++)\n            {\n                s += gauss[i, j] * a[j];\n            }\n            a[i] = Math.Round((gauss[i, matrixLine] - s) / gauss[i, i], 6);\n        }\n        //返回方程的解即拟合曲线的系数\n\n        return a;\n    }\n}\n    ------------------------\n    以上是本人在网上看到的一个例子，但是不理解该怎么样测试这个类，请各位大神赐教！或者可以提供相关参考链接也可以。\n", "Tag": "算法分析"}
{"Answer": "matlab\nx1 = [1 2 3 4 5 6]';\nx2 = [.2 .4 .8 .9 1.1 2.1]';\nX = [x1 x2]; \nf = [ 3.3079 6.6358 10.3143 13.6492 17.2755 23.6271]';\nobjfcn = @(A,X)A(1)*x1 + x2.^(A(2));\nx0=1; \nx0=(1)*[1;1];\n[vestimated,resnorm] = lsqcurvefit(objfcn,x0,X,f)", "Konwledge_Point": "线性规划简介", "Question": "如何matlab或者python实现多元函数的非线性拟合。\n比如z=f（x，y），给出（x，y，z）的多个数据点，然后怎么拟合出f函数，给出源码就更好了", "Tag": "算法分析"}
{"Answer": "df1是你的数据，df1.loc[:, 'd']在最后面的列添加列名‘d’的一列数据，然后将数组d赋值即可\r\n\r\n```\r\ndf1 = pd.DataFrame(np.random.randn(8, 3), columns=['a', 'b', 'c'])\r\n    print(df1)\r\n    d=range(8)\r\n    df1.loc[:, 'd'] = d\r\n    print(df1)\r\n \r\n```", "Konwledge_Point": "线性规划简介", "Question": "python dataframe如何线性插值缺省值\n编程小白一枚，想问下如何对缺省值线性插值，网上查到都是直接填充平均值，线性插值有什么简便的方法吗？\n\n\n\n示例：\n\n2017/11/7   1\n\n2017/11/8   2 \n\n2017/11/9   None\n\n2017/11/10  None\n\n2017/11/11  5\n\n2017/11/12  None\n\n2017/11/13  None\n\n2017/11/14  None\n\n2017/11/15  None\n\n2017/11/16  15\n\n2017/11/17  None\n\n2017/11/18  None\n\n2017/11/19  None\n\n2017/11/20  11\n\n\n\n我想让缺省值填充成\n\n2017/11/7   1\n\n2017/11/8   2 \n\n2017/11/9   3\n\n2017/11/10  4\n\n2017/11/11  5\n\n2017/11/12  7\n\n2017/11/13  9\n\n2017/11/14  11\n\n2017/11/15  13\n\n2017/11/16  15\n\n2017/11/17  14\n\n2017/11/18  13\n\n2017/11/19  12\n\n2017/11/20  11\n\n\n\nPS：类似如果想三次样条插值呢？", "Tag": "算法分析"}
{"Answer": "拟合的时候可以加一点惩罚因子，意思就是可以允许有一两个错误点，这样可以避免离群点，这也是正则化的思想，你可以搜搜拉格朗日优化。", "Konwledge_Point": "线性规划简介", "Question": "线性回归/拟合直线如何去除离群点/噪声？\n对于图1中这种散点，需要拟合出图2中的两条直线，怎么处理噪声点？\n\n\n最小二乘法受离群点的影响较大，请问一下大家这种情况有没有什么好回归方法可以拟合？或者说在回归之前有没有什么方法能去除掉这种离群点？\n\n\n\n", "Tag": "算法分析"}
{"Answer": "程序迭代输出问题，现已经解决了", "Konwledge_Point": "线性规划简介", "Question": "matlab非线性问题的解法---椎补线性化\n椎补线性化方法编程不报错，有解，但是所得解与给出的限定约束条件矛盾，也就是说约束条件失效，但是什么原因不报错，用椎补线性化方法中迭代有关系吗", "Tag": "算法分析"}
{"Answer": "C语言代码块是需要用{}括号括起来的，不是Python那样依靠缩进。\n", "Konwledge_Point": "线性规划简介", "Question": "线性插值方法完成求解\n根据压力传感器数据集，应用线性插值方法完成求解，我不知道错哪了，快帮帮我吧", "Tag": "算法分析"}
{"Answer": "望采纳下面是一个示例，用矩阵求逆的方法来求解这个线性方程组：\n4x1 + 2x2 - x3 = 2\n3x1 - x2 + 2x3 = 10\n12x1 + 3x2 = 8\n\n首先，将系数矩阵和常数向量分别存储在 A 和 b 的变量中，如下所示：\nA = [4 2 -1; 3 -1 2; 12 3 0];\nb = [2; 10; 8];\n\n然后，可以通过计算 A 的逆来求解方程组：\nx = inv(A) * b;\n\n这样，就可以得到方程组的解，即 x = [1; 2; -1]。注意：求矩阵逆是一个计算量比较大的操作，在实际应用中应该尽量避免使用。此外，如果方程组不存在解或者有多个解，那么求逆法就不能用了。", "Konwledge_Point": "线性规划简介", "Question": "用矩阵求逆法求线性方程组的解\n4x1+2x2−x3=2    3x1−x2+2x3=10  12x1+3x2=8", "Tag": "算法分析"}
{"Answer": "可以啊，建立一个元胞数组，每个回归循环都存在元胞数组里\nn = 10;\nc = cell(n,1);\nfor i = 1:n\nc{i} = polyfit(xi, yi, 4); % 比方说regress也行\nend\n\n\n然后取用也很方便\nfor i = 1:n\np = c{i};\nend\n\n", "Konwledge_Point": "线性规划简介", "Question": "如何使用matlab进行线性回归循环\n请问如何使用matlab进行线性回归循环，然后将每次回归方程的系数保存下来，再调用在别的程序中。", "Tag": "算法分析"}
{"Answer": "convhull是凸包计算函数，k是选择的点和连接顺序，v是面积，也可以自己写源码。有用麻烦采纳一下，谢谢，有问题可以私聊", "Konwledge_Point": "线性规划简介", "Question": "MATLAB中的convhull函数的使用说明\n\n\nP\n = [\n0\n \n0\n; \n1\n \n1\n; \n1\n.5\n \n0\n.5\n; \n1\n.5\n \n-0.5\n; \n1\n.25\n \n0\n.3\n; \n1\n \n0\n; \n1\n.25\n \n-0.3\n; \n1\n \n-1\n];\n[k,v] = convhull(\nP\n); \nplot(\nP\n(:,\n1\n),\nP\n(:,\n2\n),\n'*'\n) \nhold on\n plot(\nP\n(k,\n1\n),\nP\n(k,\n2\n))\n\n\n\n这里面的k，v，都是分别是什么含义啊，为什么就可以把这外围的一圈点都围起来啊？", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/yitian_z/article/details/103097363", "Konwledge_Point": "线性规划简介", "Question": "广义线性回归模型用r语言\n如何在r语言中求广义线性回归定义下的离差 似然比统计量 皮尔逊卡方统计量 以及怀尔德统计量 我用glm好像只能得到拟合", "Tag": "算法分析"}
{"Answer": "注释给你写好了，如有帮助，请点击我评论上方【采纳该答案】按钮支持一下,谢谢！\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nfrom linear_regression import LinearRegression#前几行都是导入包\n\ndata = pd.read_csv('../data/world-happiness-report-2017.csv')#读取csv文件到data\n\n# 得到训练和测试数据\ntrain_data = data.sample(frac = 0.8)#frac 抽取行的比例 例如frac=0.8，就是抽取其中80%\ntest_data = data.drop(train_data.index)#使用drop函数删除表中index\n\ninput_param_name = 'Economy..GDP.per.Capita.'# 输入特征名字\noutput_param_name = 'Happiness.Score'# 输出特征名字\n\nx_train = train_data[[input_param_name]].values\n# .values表示转换成ndarray格式 [input_param_name]表示列值\ny_train = train_data[[output_param_name]].values\n# .values表示转换成ndarray格式 [output_par  am_name]表示列值\n\nx_test = test_data[input_param_name].values#上面是训练集，这是测试集\ny_test = test_data[output_param_name].values\n\n# 散点图绘制\nplt.scatter(x_train,y_train,label='Train data')#\nplt.scatter(x_test,y_test,label='test data')\nplt.xlabel(input_param_name)\nplt.ylabel(output_param_name)\nplt.title('Happy')\nplt.legend()\nplt.show()\n\nnum_iterations = 500# 迭代次数\nlearning_rate = 0.01# 学习率\n\nlinear_regression = LinearRegression(x_train,y_train)\n(theta,cost_history) = linear_regression.train(learning_rate,num_iterations)\n# 调用train模块传入学习率和和迭代次数\n\nprint ('开始时的损失：',cost_history[0])\n# cost_history[0]表示开始的\nprint ('训练后的损失：',cost_history[-1])\n# cost_history[-1]表示最后的那次\nplt.plot(range(num_iterations),cost_history)\nplt.xlabel('Iter')\nplt.ylabel('cost')\nplt.title('GD')\nplt.show()\n\npredictions_num = 100\n\nx_predictions = np.linspace(x_train.min(),x_train.max(),predictions_num).reshape(predictions_num,1)\ny_predictions = linear_regression.predict(x_predictions)\n\nplt.scatter(x_train,y_train,label='Train data')\nplt.scatter(x_test,y_test,label='test data')\nplt.plot(x_predictions,y_predictions,'r',label = 'Prediction')\nplt.xlabel(input_param_name)\nplt.ylabel(output_param_name)\nplt.title('Happy')\nplt.legend()\nplt.show()\n\n", "Konwledge_Point": "线性规划简介", "Question": "机器学习pycharm线性回归代码讲解\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n\nfrom linear_regression import LinearRegression\n\n\ndata = pd.read_csv('../data/world-happiness-report-2017.csv')\n\n\ntrain_data = data.sample(frac = 0.8)\ntest_data = data.drop(train_data.index)\n\n\ninput_param_name = 'Economy..GDP.per.Capita.'\noutput_param_name = 'Happiness.Score'\n\n\nx_train = train_data[[input_param_name]].values\ny_train = train_data[[output_param_name]].values\n\n\nx_test = test_data[input_param_name].values\ny_test = test_data[output_param_name].values\n\n\nplt.scatter(x_train,y_train,label='Train data')\nplt.scatter(x_test,y_test,label='test data')\nplt.xlabel(input_param_name)\nplt.ylabel(output_param_name)\nplt.title('Happy')\nplt.legend()\nplt.show()\n\n\nnum_iterations = 500\nlearning_rate = 0.01\n\n\nlinear_regression = LinearRegression(x_train,y_train)\n(theta,cost_history) = linear_regression.train(learning_rate,num_iterations)\n\n\nprint ('开始时的损失：',cost_history[0])\nprint ('训练后的损失：',cost_history[-1])\n\n\nplt.plot(range(num_iterations),cost_history)\nplt.xlabel('Iter')\nplt.ylabel('cost')\nplt.title('GD')\nplt.show()\n\n\npredictions_num = 100\n\n\nx_predictions = np.linspace(x_train.min(),x_train.max(),predictions_num).reshape(predictions_num,1)\ny_predictions = linear_regression.predict(x_predictions)\n\n\nplt.scatter(x_train,y_train,label='Train data')\nplt.scatter(x_test,y_test,label='test data')\nplt.plot(x_predictions,y_predictions,'r',label = 'Prediction')\nplt.xlabel(input_param_name)\nplt.ylabel(output_param_name)\nplt.title('Happy')\nplt.legend()\nplt.show()\n有没有会的给我简单讲解一下每段代码都是干什么的 谢谢啦", "Tag": "算法分析"}
{"Answer": "除了线性调频脉冲，PD雷达的发射脉冲还可以是：\n频率跳变脉冲（FMCW脉冲）：它通过改变发射信号的频率，从而实现距离测量和速度测量。与LFM脉冲相比，FMCW脉冲的带宽较窄，但可以实现更高的距离测量精度。\n矩形脉冲：一种时间宽度和幅度相等的脉冲，可以用于雷达探测和测距。\n窄带脉冲：一种带宽很窄的脉冲，可以用于目标检测和跟踪。与LFM脉冲相比，窄带脉冲的距离分辨率较差，但可以实现更高的信噪比。", "Konwledge_Point": "线性规划简介", "Question": "PD雷达的发射脉冲是线性调频脉冲？\nPD雷达是脉冲多普勒雷达，PD雷达的发射脉冲除了是线性调频脉冲还可以是什么脉冲？", "Tag": "算法分析"}
{"Answer": "看来很少有人做这个，自己给自己顶一下", "Konwledge_Point": "线性规划简介", "Question": "有关非线性最优化手眼标定的求助帖\n最近在做标定手眼关系（eye in hand ）中用到非线性最优化来求解方程AX=XB，\n\n但对于非线性最优化了解不多，理解困难。\n\n参考文中中定义函数f，对函数f进行非线性最优化\n\n函数f定义可见附图\n\n始终q为四元数（用来表示旋转矩阵），t表示平移向量，R表示旋转矩阵\n\n要优化的元素为q，t（即旋转矩阵和平移向量）\n\n这里如何求解真是不懂，请各位赐教   help", "Tag": "算法分析"}
{"Answer": "一旦执行了return语句，函数立即结束执行并返回。因此返回n之后就不再返回-1，若是没有返回n则最后返回-1", "Konwledge_Point": "线性规划简介", "Question": "c，线性查找数组元素   问题求解决\nint linearsearch(const int array[],int key,int size)\n\n{\n\n    int n;\n\n    for(n=0;n<100;n++)\n\n    {\n\n        if(array[n]==key)\n\n        {\n\n            return n;\n\n        }\n\n    }\n\n    return -1;\n\n}\n\n\n\n这个函数返回给主函数的值是不是总是-1？？   还是返回n后就不在返回-1", "Tag": "算法分析"}
{"Answer": "双向链表属于多重链表，但它是线性结构。", "Konwledge_Point": "线性规划简介", "Question": "多重链表一定是非线性结构吗？\n多重链表一定是非线性结构。\n答案说这句话是错的，有什么例子呢？我不太明白。Thank you！", "Tag": "算法分析"}
{"Answer": "该回答引用GPTᴼᴾᴱᴺᴬᴵ针对多目标非线性整数规划问题，目前常用的算法包括遗传算法、粒子群算法、差分进化算法等。另外，也可以尝试使用混合整数线性规划和近似多目标优化方法等。\n对于具体应用的选择，需要考虑问题的特点和实际情况。不同算法的适用范围和优缺点也不同，因此需要综合考虑选择合适的算法。\n关于学习方法，可以通过阅读相关论文、专业书籍、参加相关学术会议等方式学习。以下是一些相关学习资源的推荐：\n《多目标优化理论与方法》一书，作者为陈志华等。\n学术期刊，例如IEEE Transactions on Evolutionary Computation、European Journal of Operational Research等。\n相关学术会议，例如International Conference on Evolutionary Multi-Criterion Optimization、International Symposium on Combinatorial Optimization等。\nMATLAB官方文档提供了各种优化算法的实现和示例，可以在MATLAB官网进行查找和学习。\n开源优化软件，例如Gurobi、CPLEX等，可以通过学习其官方文档和实例来了解相关算法。\n", "Konwledge_Point": "线性规划简介", "Question": "多目标非线性整数规划\n请问，针对（多目标非线性整数规划）问题，用什么算法比较好？哪里可以借鉴学习", "Tag": "算法分析"}
{"Answer": "字段计算器中可以算出所有点的坐标值，然后导出到Excel中。距离计算和线性回归都可以用Excel的公式计算。", "Konwledge_Point": "线性规划简介", "Question": "arcgis计算距离，线性回归分析的问题\n想问下已经在ARCGIS上标注了点并连成线，想知道怎么计算每个点到起始点的距离，并能把距离、时间放在坐标里，进行线性回归分析", "Tag": "算法分析"}
{"Answer": "你先用matlab把这两个方程写一下，写完了，我给你求解", "Konwledge_Point": "线性规划简介", "Question": "如何用matlab求解非线性方程组\n如何用matlab中牛顿迭代法或者二分法求解下面非线性方程组\n\n", "Tag": "算法分析"}
{"Answer": "仅限我个人的理解:首先你有一个优化函数和一组训练数据,优化函数中有一系列待确定的参数,你的目的就是让优化函数在训练数据中取得一个局部最优解也就是说计算出一组参数,将参数代入模型之后,模型可以尽可能的符合训练数据因为是局部最优解,所以可能存在训练效果不好的情况,用测试集套一下就可以一定程度反映出训练好的模型的准确程度", "Konwledge_Point": "线性规划简介", "Question": "关于线性回归的一些理解，希望可以下纠正错误\n刚开始学习的小白，什么也不懂，也不知道自己理解的对不对，想问一下可能很蠢的问题🥲\n利用数据进行训练得到的所谓的模型，\n就是会得到一个线性回归函数的意思吗？\n然后再把测试集套到这个函数对这个模型进行评价，得到这个模型的准确性..？是这样的吗？", "Tag": "算法分析"}
{"Answer": "clear\nclc\nclose all \n%%  仿真步长 h=0.01 时\nHfun = @(t,x) [ x(1)-x(2)-x(1)*x(3);x(1)+x(2)-x(2)*x(3); x(1)*x(1)+x(2)*x(2)-x(3)];   % 一阶微分方程导数表达式 \n% 参数\nt = [0 12];     % 时间范围\nh = 0.01;       % 时间步长\nx0 = [2 0 1];   % 初始状态 \n% 显式欧拉法求解\n[T1,X1] = ODE_ExplicitEuler( Hfun,t,h,x0 );\n% 隐式欧拉法求解\n[T2,X2] = ODE_ImplicitEuler( Hfun,t,h,x0 );\n% 两步欧拉法求解\n[T3,X3] = ODE_2OrderEuler( Hfun,t,h,x0 );\n% 改进欧拉法求解\n[T4,X4] = ODE_ImprovedEuler( Hfun,t,h,x0 );\n% Matlab自带ode45求解\n[T5,X5] = ode45( Hfun,t,x0 ); \n% 绘图对比\nfigure\nsubplot(311)\nplot(T1,X1(:,1),T2,X2(:,1),T3,X3(:,1),T4,X4(:,1),T5,X5(:,1))\nxlabel('Time(s)')\nylabel('x_1')\nlegend('显式欧拉法','隐式欧拉法','两步欧拉法','改进欧拉法','ode45')\nsubplot(312)\nplot(T1,X1(:,2),T2,X2(:,2),T3,X3(:,2),T4,X4(:,2),T5,X5(:,2))\nxlabel('Time(s)')\nylabel('x_2')\nlegend('显式欧拉法','隐式欧拉法','两步欧拉法','改进欧拉法','ode45')\nsubplot(313)\nplot(T1,X1(:,3),T2,X2(:,3),T3,X3(:,3),T4,X4(:,3),T5,X5(:,3))\nxlabel('Time(s)')\nylabel('x_3')\nlegend('显式欧拉法','隐式欧拉法','两步欧拉法','改进欧拉法','ode45')\n% 显示欧拉\nfunction [T,X,dX] = ODE_ExplicitEuler( Hfun,t,h,x0 )\n    % 确定时间节点\n    T = t(1):h:t(2);\n    % 计算\n    N = length(T);\n    x0 = x0(:);  x0 = x0';     % 初值变为行向量  \n    m = length(x0);            % 状态量维数\n    X = zeros(N,m);            % 初始化状态量\n    dX = zeros(N,m);           % 状态导数\n    X(1,:) = x0;\n    for k = 2:N\n        dX(k-1,:) = Hfun( T(k-1),X(k-1,:) );   \n        h = T(k) - T(k-1);\n        X(k,:) = X(k-1,:) + h*dX(k-1,:);                        \n    end\n    dX(N,:) = Hfun( T(N),X(N,:) );\nend\n% 隐式欧拉\nfunction [T,X,dX] = ODE_ImplicitEuler( Hfun,t,h,x0 )\n    T = t(1):h:t(2);\n    % 计算\n    N = length(T);\n    x0 = x0(:);  x0 = x0';     % 初值变为行向量  \n    m = length(x0);            % 状态量维数\n    X = zeros(N,m);            % 初始化状态量\n    dX = zeros(N,m);           % 状态导数\n    X(1,:) = x0;\n    for k = 2:N\n        h = T(k) - T(k-1);\n        for jj = 1:m\n           Ind =  zeros(1,m);         % 状态选择向量\n           Ind(jj) = 1;        % 选择的向量位置  \n           fh = @(x) h*Ind*Hfun(T(k),[X(k-1,1:jj-1)';x; X(k-1,jj+1:m)']) + X(k-1,jj)' - x;    \n           X(k,jj) = fzero( fh,X(k-1,jj) ) ;   \n        end                  \n    end\n    dX(N,:) = Hfun( T(N),X(N,:) );\nend\n\nfunction [T,X,dX] = ODE_2OrderEuler( Hfun,t,h,x0 )\n    T = t(1):h:t(2);\n    % 计算\n    N = length(T);\n    x0 = x0(:);  x0 = x0';     % 初值变为行向量  \n    m = length(x0);            % 状态量维数\n    X = zeros(N,m);            % 初始化状态量\n    dX = zeros(N,m);           % 状态导数\n    X(1,:) = x0;\n    for k = 2:N\n        dX(k-1,:) = Hfun( T(k-1),X(k-1,:) );   \n        h = T(k) - T(k-1);\n        if k == 2\n            X(k,:) = X(k-1,:) + h*dX(k-1,:);    \n        else\n            X(k,:) = X(k-2,:) + 2*h*dX(k-1,:);   \n        end\n    end\n    dX(N,:) = Hfun( T(N),X(N,:) );\nend\nfunction [T,X,dX] = ODE_ImprovedEuler( Hfun,t,h,x0 )\n    T = t(1):h:t(2);\n    % 计算\n    N = length(T);\n    x0 = x0(:);  x0 = x0';     % 初值变为行向量  \n    m = length(x0);            % 状态量维数\n    X = zeros(N,m);            % 初始化状态量\n    dX = zeros(N,m);           % 状态导数\n    X(1,:) = x0;\n    for k = 2:N\n        dX(k-1,:) = Hfun( T(k-1),X(k-1,:) );   \n        h = T(k) - T(k-1);\n        Xp = X(k-1,:) + h*dX(k-1,:);\n        dXp = Hfun( T(k),Xp );\n        X(k,:) = X(k-1,:) + (h/2)*(dX(k-1,:)+dXp');\n    end\n    dX(N,:) = Hfun( T(N),X(N,:) );\nend\n", "Konwledge_Point": "线性规划简介", "Question": "Matlab欧拉法求解非线性常微分方程\n请教一下\n这个怎么用Matlab编程求解这个非线性常微分方程\n包括显式欧拉法，隐式欧拉法，两步欧拉法，改进欧拉法\n包括图像", "Tag": "算法分析"}
{"Answer": "http://datakung.com/?p=50&replytocom=5", "Konwledge_Point": "线性规划简介", "Question": "怎么判定线性回归的好坏\n分类器的好坏在于准确率。\n\n那线性回归呢？\n\n我现在有10个特征和1个回归值，我想比较一下，用前5个特征做回归好，还是用后5个特征做回归好，该比较什么值呢？", "Tag": "算法分析"}
{"Answer": "swap函数有问题啊，int指针和int值怎么能直接相等呢。修改如下\nvoid swap(int *u,int *v)\n{\n   int temp;\n   temp=*u;\n   *u=*v;\n   *v=temp;\n}\n\n\n22行的 swap(a[i], a[j]); 改成 swap(&a[i], &a[j]);下面swap交换的地方，都需要加&修改后运行结果：\n\n完整代码修改如下：\n//线性时间选择\n#include <stdio.h>\nvoid bubbleSort(int* a, int p, int r);\nint Partition(int* a, int p, int r, int val);\nint Select(int* a, int p, int r, int k);\nvoid swap(int* u, int* v);\n\nvoid swap(int* u, int* v)\n{\n    int temp;\n    temp = *u;\n    *u = *v;\n    *v = temp;\n}\nvoid bubbleSort(int* a, int p, int r)\n{\n    int i, j;\n    for (i = p; i < r; i++)\n    {\n        for (j = i + 1; j <= r; j++)\n        {\n            if (a[j] < a[i]) swap(&a[i], &a[j]);\n        }\n    }\n}\n\nint Partition(int* a, int p, int r, int val)\n{\n    int pos;\n    int q, i, j, x;\n    for (q = p; q <= r; q++)\n    {\n        if (a[q] == val)\n        {\n            pos = q;\n            break;\n        }\n    }\n    swap(&a[p], &a[pos]);\n\n    i = p; j = r + 1; x = a[p];\n    while (1)\n    {\n        while (a[++i] < x && i < r);\n        while (a[--j] > x);\n        if (i >= j) break;\n        swap(&a[i], &a[j]);\n    }\n    a[p] = a[j]; a[j] = x;\n    return j;\n}\n\nint Select(int* a, int p, int r, int k)\n{\n    int s, t;\n    int i, j, n, x;\n    if (r - p < 75)\n    {\n        bubbleSort(a, p, r);\n        return a[p + k - 1];\n    }\n    //找中位数的中位数，r-p-4即上面所说的n-5\n    for (i = 0; i <= (r - p - 4) / 5; i++) //把每个组的中位数交换到区间[p,p+(r-p-4)/4]\n    {\n        s = p + 5 * i; t = s + 4;\n        for (j = 0; j < 3; j++) //冒泡排序，从后开始排，结果使得后三个数是排好顺序的（递增）\n        {\n            for (n = s; n < t - j; n++)\n            {\n                if (a[n] > a[n + 1]) swap(&a[n], &a[n + 1]);\n            }\n        }\n        swap(&a[p + i], &a[s + 2]);//交换每组中的中位数到前面\n    }\n    //(r-p-4)/5表示组数-1，则[p,p+(r-p-4)/5]的区间长度等于组数\n    x = Select(a, p, p + (r - p - 4) / 5, (r - p + 1) / 10);//求中位数的中位数\n    /*\n    (r-p+1)/10 = (p+(r+p-4)/5-p+1)/2\n    */\n    i = Partition(a, p, r, x); j = i - p + 1;\n    if (k <= j) return Select(a, p, i, k);\n    else return Select(a, i + 1, r, k - j);\n}\nint main(void)\n{\n    int x, i;\n    //数组a存了0-79\n    int a[80] = { 3,1,7,6,5,9,8,2,0,4,13,11,17,16,15,19,18,12,10,14,23,21,27,26,25,29,28,22,20,24,33,31,37,36,35,39,38,32,30,34,43,41,47,46,45,49,48,42,40,44,53,51,57,56,55,59,58,52,50,54,63,61,67,66,65,69,68,62,60,64,73,71,77,76,75,79,78,72,70,74,\n    };\n    scanf(\"%d\", &x);\n    printf(\"The %d smallest number is %d\\n\", x, Select(a, 0, 79, x));\n    return 0;\n}\n\n\n\n这里有个详细的解答：\n算法：线性时间选择_顾道长生'的博客-CSDN博客_线性时间选择算法\n定义：给定线性序集中n个元素和一个整数k，1≤k≤n，要求找出这n个元素中第k小的元素。（1）在某些特殊情况下，很容易设计出解选择问题的线性时间算法。如：当要选择最大元素或最小元素时，显然可以在O(n)时间完成。（一趟比较即可）（2）一般的选择问题，特别是中位数的选择问题似乎比最小（大）元素要难。但实际上，从渐近阶的意义上，它们是一样的。也可以在O(n)时间完成。步骤：（1）将n个输入元...\n\n\n\nhttps://blog.csdn.net/wl1780852311/article/details/101000722\n\n", "Konwledge_Point": "线性规划简介", "Question": "C语言学习，算法设计，线性时间选择\n我在学习线性时间选择算法，编写如下程序，算法要求是找到n个元素中第k小的元素：\n\n\n//线性时间选择\n\n#\ninclude\n \nvoid bubble\nSort(\nint\n \n*\na\n,\nint\n \np\n,\nint\n \nr\n)\n;\n\nint\n \nPartition(\nint\n \n*\na\n,\nint\n \np\n,\nint\n \nr\n,\nint\n \nval\n)\n;\n\nint\n \nSelect(\nint\n \n*\na\n,\nint\n \np\n,\nint\n \nr\n,\nint\n \nk\n)\n;\nvoid swap(\nint\n *u,\nint\n *v);\n\nvoid swap(\nint\n *u,\nint\n *v)\n{\n   \nint\n temp;\n   temp=u;\n   u=v;\n   v=temp;\n}\nvoid bubble\nSort(\nint\n \n*\na\n,\nint\n \np\n,\nint\n \nr\n)\n\n{ \n    \nint\n i,j;\n    \nfor\n(i=p; ix);\n        \nif\n(i>=j) break;\n        swap(a\n[\ni\n]\n,a\n[\nj\n]\n);\n    }\n    a\n[\np\n]\n=a\n[\nj\n]\n; a\n[\nj\n]\n=x;\n    return j;\n}\n\n\nint\n \nSelect(\nint\n \n*\na\n,\nint\n \np\n,\nint\n \nr\n,\nint\n \nk\n)\n\n{\n    \nint\n s,t;\n    \nint\n i,j,n,x;\n    \nif\n(r-p<\n75\n)\n    {\n        bubble\nSort(\na\n,\np\n,\nr\n)\n;\n        return a\n[\np\n+\nk\n-\n1\n]\n;\n    }\n    \n//找中位数的中位数，r-p-4即上面所说的n-5\n\n    \nfor\n( i=\n0\n; i<=(r-p-\n4\n)/\n5\n; i++) \n//把每个组的中位数交换到区间[p,p+(r-p-4)/4]\n\n    {\n        s=p+\n5\n*i; t=s+\n4\n;\n        \nfor\n( j=\n0\n; j<\n3\n; j++) \n//冒泡排序，从后开始排，结果使得后三个数是排好顺序的（递增）\n\n        {\n            \nfor\n( n=s; na\n[\nn\n+\n1\n]\n) swap(a\n[\nn\n]\n,a\n[\nn\n+\n1\n]\n);\n            }\n        }\n        swap(a\n[\np\n+\ni\n]\n,a\n[\ns\n+\n2\n]\n);\n//交换每组中的中位数到前面\n\n    }\n    \n//(r-p-4)/5表示组数-1，则[p,p+(r-p-4)/5]的区间长度等于组数\n\n    x=\nSelect(\na\n,\np\n,\np\n+(\nr\n-\np\n-4)\n/\n5\n,(r-p+\n1\n)/\n10\n);\n//求中位数的中位数\n\n    \n/*\n    (r-p+1)/10 = (p+(r+p-4)/5-p+1)/2\n    */\n\n    i=\nPartition(\na\n,\np\n,\nr\n,\nx\n)\n; j=i-p+\n1\n;\n    \nif\n(k<=j) return \nSelect(\na\n,\np\n,\ni\n,\nk\n)\n;\n    \nelse\n return \nSelect(\na\n,\ni\n+1,\nr\n,\nk\n-\nj\n)\n;\n}\n\nint\n main(void)\n{\n    \nint\n x,i;\n    \n//数组a存了0-79\n\n    \nint\n a\n[\n80\n]\n= {\n3\n,\n1\n,\n7\n,\n6\n,\n5\n,\n9\n,\n8\n,\n2\n,\n0\n,\n4\n,\n13\n,\n11\n,\n17\n,\n16\n,\n15\n,\n19\n,\n18\n,\n12\n,\n10\n,\n14\n,\n23\n,\n21\n,\n27\n,\n26\n,\n25\n,\n29\n,\n28\n,\n22\n,\n20\n,\n24\n,\n33\n,\n31\n,\n37\n,\n36\n,\n35\n,\n39\n,\n38\n,\n32\n,\n30\n,\n34\n,\n43\n,\n41\n,\n47\n,\n46\n,\n45\n,\n49\n,\n48\n,\n42\n,\n40\n,\n44\n,\n53\n,\n51\n,\n57\n,\n56\n,\n55\n,\n59\n,\n58\n,\n52\n,\n50\n,\n54\n,\n63\n,\n61\n,\n67\n,\n66\n,\n65\n,\n69\n,\n68\n,\n62\n,\n60\n,\n64\n,\n73\n,\n71\n,\n77\n,\n76\n,\n75\n,\n79\n,\n78\n,\n72\n,\n70\n,\n74\n,\n               };\n    scanf(\n\"%d\"\n,&x); \n    printf(\n\"The %d smallest number is %d\\n\"\n,x,\nSelect(\na\n,0,79,\nx\n)\n);\n    return \n0\n;\n}\n\n\n\n\n运行结果如下：\n\n\n\n\n请问是哪有问题，应该怎么修改。", "Tag": "算法分析"}
{"Answer": "你看2787行的三个条件，一个一个在代码中测试，找到那个是假，然后去搜一下我这里没有opencv的包，所以没法试", "Konwledge_Point": "线性规划简介", "Question": "Python在线性规划的问题\n\n\n想问一下为什么一些数后面加上点之后就能运行了呢？是因为最后的答案是浮点数吗？感谢大家的解答！", "Tag": "算法分析"}
{"Answer": "你的意思是决策树的结果是 不同的线性回归函数，例如简单地不同斜率的直线，那么以上回答的思路似乎有问题。首先这是一个分类问题，决策结果是“第k个回归函数“，然后再用 “第k个回归函数“ 计算得到具体的函数值。这个问题取决于，所述不同的线性回归函数是不是已知确定的，还是也要同时进行学习的。如果线性回归函数已知，则本质上仍然是分类问题，做一个预处理把”第k类“的函数值与实际值之差作为分类模型的误差，就可以完成分类。", "Konwledge_Point": "线性规划简介", "Question": "逻辑树与线性回归的结合使用什么算法？\n正在做一个预测产量的算法，能否有一种决策树它的叶子节点不是分类标签，而是一个个不同的线性回归函数。这样在输入投入物料时，根据投入物料的属性对应到逻辑树的节点上进行计算。 大家给我个搜索方向或者实现的路径想法就可以了。", "Tag": "算法分析"}
{"Answer": "同学，你把你的优化的目标函数和约束条件都说一下，目前来看你的这些代码比较凌乱，看不出具体在优化什么，以及约束什么，还有sym变量，非常忌讳的东西。全局找最小，不用优化：\n% 这个是全局找最小\n[X,Y] = meshgrid(6:12,8:16);\nF = X.*Y;\nC = true(size(X));\nfor i = 1:numel(X)\n    n = X(i);\n    y = Y(i);\n    c = 0;\n    for k = 1:1:n\n        c = c+ (184900+860*(k-1)*y^2+(k-1)^2*y^2)/...\n            (860*(k-1)*y+(k-1)^2*y^2+249600);\n    end\n    C(i) = 24-c<=0;\nend\nminf = min(F(C));\nI = find(minf==F&C);\nx = X(I)\ny = Y(I)\nfmin = x*y\n\n最后结果：\nx =\n\n    12\n\n\ny =\n\n    10\n\n\nfmin =\n\n   120\n\n优化的代码在评论区，只是fmincon只能找到局部最优", "Konwledge_Point": "线性规划简介", "Question": "matlab求多元非线性，求和里面的m也是变量吗\n目标函数：\nfunction y=myfun(k)\ny=x(1)*x(2)\n约束条件：\n\n\nfunction [\nc\n,\nceq]\n=\ncons(\nx\n)\n\neq\n=\nsymsum((\n400\n^\n2\n+\n800\n*(m\n-1\n)*y+(m\n-1\n)^\n2\n*y^\n2\n)/(\n800\n*(m\n-1\n)*y+(m\n-1\n)^\n2\n*y^\n2\n)\n,\nm\n,\n2\n,\nx\n)\n;\n\n\nc\n=\n-\ndouble\n(\neq\n)\n-6\n;\n\nceq\n=\n[]\n;\n\n\n\n\n\n\n主程序：\n\n\n>> syms x y m\nceq=[];\n\nA\n=[];\nb=[];\n\nAeq\n=[];\nbeq=[];\nx(\n1\n)=\n6\n,x(\n2\n)=\n8\n;\nk0=[x(\n1\n),x(\n2\n)];\nlb=[\n6\n,\n8\n];\nub=[\n12\n,\n16\n];\n[x,fval,exitflag,output]=fmincon(@fun,k0,\nA\n,b,[],[],[],[],@cons);\ndisp(\n'x(1)、x(2)、y值'\n)\n \nx =\n \n\n6\n\n \n错误使用 fmincon (line \n224\n)\n\nFMINCON\n requires the following inputs to be of data type double: \n'X0'\n.\n \n![img](https://img-mid.csdnimg.cn/release/static/image/mid/ask/\n19219581353612.\npng \n\"=600 #left\"\n)\n\n\n", "Tag": "算法分析"}
{"Answer": "调用这个方法\nfunction [T,X,dX] = ODE_RK4( Hfun,t,h,x0 )\n    T = t(1):h:t(2);\n    % 计算\n    N = length(T);\n    x0 = x0(:);  \n    x0 = x0';                  % 初值变为行向量  \n    m = length(x0);            % 状态量维数\n    X = zeros(N,m);            % 初始化状态量\n    dX = zeros(N,m);           % 状态导数\n    X(1,:) = x0;\n    for k = 2:N\n        h = T(k) - T(k-1);\n        K1 = Hfun( T(k-1)     , X(k-1,:)' );    \n        K2 = Hfun( T(k-1)+h/2 , X(k-1,:)'+h*K1/2 ); \n        K3 = Hfun( T(k-1)+h/2 , X(k-1,:)'+h*K2/2 ); \n        K4 = Hfun( T(k-1)+h   , X(k-1,:)'+h*K3 ); \n        X(k,:) = X(k-1,:)' + (h/6) * ( K1 + 2*K2 + 2*K3 + K4 );      \n        dX(k-1,:) = (1/6) * ( K1 + 2*K2 + 2*K3 + K4 );\n    end\n    dX(N,:) = Hfun( T(N),X(N,:) );\nend\n", "Konwledge_Point": "线性规划简介", "Question": "Matlab龙格库塔法求解非线性常微分方程\n请教一下\n这个怎么用Matlab编程求解这个非线性常微分方程\n用龙格库塔法", "Tag": "算法分析"}
{"Answer": "线性系统有两个属性：齐次性和叠加性，若系统为y（n）=T[f(n)]，齐次：T[af(n)]=aT[f(n)],叠加：T[f1(n)+f2(n)]=T[f1(n)]+T[f2(n)]，所以既齐次又叠加的系统为线性系统，亦可用此判断。  【望采纳】", "Konwledge_Point": "线性规划简介", "Question": "如何判断是否为线性系统\n零状态线性如何判断，导数和积分部分应该怎么计算，是求导和求积分一定是零吗，是需要带公式吗\n![img](\nhttps://img-mid.csdnimg.c\n\n\nn/release/static/image/mid/ask/162075222366153.jpg \"#left\")", "Tag": "算法分析"}
{"Answer": "是可以的，我发现我一直显示不出来是因为我没有给标题设置宽度比和高度比，所以显示不出来，因为不知道layout__below怎么引用布局就重新倒着重写了一遍布局\r\n```\n\n\n\n\n\n\n\n\n\n\r\n\r\n```\r\n最后得图![图片说明](https://img-ask.csdn.net/upload/201905/30/1559211604_22833.png)", "Konwledge_Point": "线性规划简介", "Question": "请问百分比布局可以引用线性布局的标题栏吗？求大神解答！！！\n想在百分比布局里尝试引用线性布局的标题栏，怎么也不成功，我是按照第一行代码那本书的引用布局部分做的，怎么也弄不出来，好懵\n\n\n", "Tag": "算法分析"}
{"Answer": "我没太看明白你取得那6个特征，x0、2、5不都是常量吗x1和x3是一次函数，x4是二次函数，这个是否用3个特征就可以了，你最后想要的效果是要一个二次函数去拟合你原本图片中的那条线吗？我用你其中一张图片研究了一下,目前的效果是这样的：\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport cv2\n\nclass LinearRegression:\n    def __init__(self,data,labels):\n        self.data = data\n        self.labels = labels\n        self.features = np.zeros((1,self.data.shape[1]))\n    \n    def train(self,learning_rate, num_iterations):\n        for i in range(num_iterations):\n            self.step_gradient(learning_rate)\n            # loss = self.loss_fuction()\n            # print(f'第{i}轮loss={loss}, features={self.features}')\n        return self.features\n    \n    def step_gradient(self, learning_rate):\n        N = float(len(self.labels))\n        err_current = np.sum(self.features*self.data,axis=1) - self.labels\n        features_gradient = np.array([sum([x**i*err for x,err in zip(self.data[:,i],err_current)])*(2/N) for i in range(self.features.shape[1])])\n        self.features = self.features - (learning_rate* features_gradient)\n    \n    def loss_fuction(self):\n        totalError = sum([(y-(np.sum(self.features*x,axis=1)))**2 for x,y in zip(self.data,self.labels)])\n        return totalError / float(len(self.labels))\n    \n    def draw(self,num_iterations):\n        plt.rcParams['font.sans-serif'] = ['SimHei']\n        plt.rcParams['axes.unicode_minus'] = False\n        x = self.data[:,1]\n        sl = [s[0] for s in sorted(enumerate(x), key=lambda a:a[1])]\n        y = [sum(x*self.features[0]) for x in self.data]\n        sort_y = [y[i] for i in sl]\n        sort_labels = [self.labels[i] for i in sl]\n        x.sort()\n        plt.scatter(x,sort_labels,label='source')\n        plt.plot(x, sort_y,color='r',label='predict')\n        plt.xlabel('X')\n        plt.ylabel('Y')\n        plt.title(str(num_iterations)+'轮')\n        plt.legend()\n        plt.show()\n \nif __name__ == '__main__':\n    img = cv2.imread('line.jpg')\n    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n    low_hsv = np.array([0, 0, 221])\n    high_hsv = np.array([180, 30, 255])\n    mask = cv2.inRange(hsv, lowerb=low_hsv, upperb=high_hsv)\n    list_y = []\n    list_x = []\n    \n    for i in range(0,len(mask),5):\n        xmax = []\n        for j in range(0,len(mask[i]),5):\n            if mask[i][j] == 0:\n                list_x.append(j)\n                list_y.append(i)\n    list_x = [x/100 for x in list_x]\n    list_y = [y/100 for y in list_y]\n    list_x = [[1,x,x**2] for x in list_x]\n    learning_rate = 0.001\n    num_iterations = 1000\n    lr = LinearRegression(np.array(list_x),np.array(list_y))\n    lr.train(learning_rate,num_iterations)\n    lr.draw(num_iterations)\n\n", "Konwledge_Point": "线性规划简介", "Question": "线性回归数组行数不对应\n问题遇到的现象\n\n\n线性回归中遇到数组行数不对应的情况\n\n\n问题相关代码，请勿粘贴截图\n\n\nimport cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimg = cv2.imread(r\n'C:\\Users\\Xpc\\Desktop\\weixin2222 change40.jpg'\n)\nhsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\nlow_hsv = np.array([0, 0, 221])\nhigh_hsv = np.array([180, 30, 255])\nmask = cv2.inRange(hsv, \nlowerb\n=low_hsv, \nupperb\n=high_hsv)\n\nlist_y = []\nlist_x = []\n\n\nfor\n i \nin\n range(len(mask)):\n    xmax = []\n    \nfor\n j \nin\n range(len(mask[i])):\n        \nif\n mask[i][j] == 0:\n            list_x.append(j)\n            list_y.append(len(mask)-i)\n\nplt.plot(list_x, list_y, \n'o'\n, \ncolor\n=\n'r'\n)\nplt.show()\n\n\nx_array\n=np.array(list_x)\n\nx_array\n=x_array/400\n\ny_array\n=np.array(list_y)\n\ny_array\n=y_array*0.2/400\n\n\nz40\n=np.stack((x_array,y_array),axis=0).T\nz0=[]\n\nfor\n i \nin\n range(0,z40.shape[0],30):\n    \nz1\n=z40[i,:]\n    z0.append(z1)\n\nz0\n=np.array(z0)\n\nx_array\n=z0[:,0]\n\ny_array\n=z0[:,1]\n\nprint\n(x_array)\n\nprint\n(y_array)\n\n\nlist_x1=[]\n\nfor\n i \nin\n range(0,len(x_array)):\n    list_x1.append(40)\n\nx1_array\n=np.array(list_x1)\n\nlist_x0=[]\n\nfor\n i \nin\n range(0,len(x_array)):\n    list_x0.append(1)\n\nx0\n=np.array(list_x0)\n\nx1\n=x_array\n\nx2\n=x1_array\n\nx3\n=x1*x2\n\nx4\n=x1*x1\n\nx5\n=x2*x2\n\nlabel40\n=y_array\n\nz40\n=np.vstack((x0,x1,x2,x3,x4,x5)).T\n\n\n\n\n\nimg = cv2.imread(r\n'C:\\Users\\Xpc\\Desktop\\weixin2222 - 50.jpg'\n)\nhsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\nlow_hsv = np.array([0, 0, 221])\nhigh_hsv = np.array([180, 30, 255])\nmask = cv2.inRange(hsv, \nlowerb\n=low_hsv, \nupperb\n=high_hsv)\n\n\nlist_y = []\nlist_x = []\n\n\nfor\n i \nin\n range(len(mask)):\n    xmax = []\n    \nfor\n j \nin\n range(len(mask[i])):\n        \nif\n mask[i][j] == 0:\n            list_x.append(j)\n            list_y.append(len(mask)-i)\n\nplt.plot(list_x, list_y, \n'o'\n, \ncolor\n=\n'r'\n)\nplt.show()\n\n\nx_array\n=np.array(list_x)\n\nx_array\n=x_array/400\n\ny_array\n=np.array(list_y)\n\ny_array\n=y_array*0.2/400\n\nz50\n=np.stack((x_array,y_array),axis=0).T\nz0=[]\n\nfor\n i \nin\n range(0,z50.shape[0],30):\n    \nz1\n=z50[i,:]\n    z0.append(z1)\n\nz0\n=np.array(z0)\n\n\nx_array\n=z0[:,0]\n\ny_array\n=z0[:,1]\n\nprint\n(x_array)\n\nprint\n(y_array)\n\nlist_x1=[]\n\nfor\n i \nin\n range(0,len(x_array)):\n    list_x1.append(40)\n\nx1_array\n=np.array(list_x1)\n\nlist_x0=[]\n\nfor\n i \nin\n range(0,len(x_array)):\n    list_x0.append(1)\n\nx0\n=np.array(list_x0)\n\nx1\n=x_array\n\nx2\n=x1_array\n\nx3\n=x1*x2\n\nx4\n=x1*x1\n\nx5\n=x2*x2\n\nlabel50\n=y_array\n\nz50\n=np.stack((x0,x1,x2,x3,x4,x5),axis=0).T\n\n\n\n\n \nimg = cv2.imread(r\n'C:\\Users\\Xpc\\Desktop\\weixin2222 - 55.jpg'\n)\nhsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\nlow_hsv = np.array([0, 0, 221])\nhigh_hsv = np.array([180, 30, 255])\nmask = cv2.inRange(hsv, \nlowerb\n=low_hsv, \nupperb\n=high_hsv)\n\nlist_y = []\nlist_x = []\n\n\nfor\n i \nin\n range(len(mask)):\n    xmax = []\n    \nfor\n j \nin\n range(len(mask[i])):\n        \nif\n mask[i][j] == 0:\n            list_x.append(j)\n            list_y.append(len(mask)-i)\n\nplt.plot(list_x, list_y, \n'o'\n, \ncolor\n=\n'r'\n)\nplt.show()\n\n\nx_array\n=np.array(list_x)\n\nx_array\n=x_array/400\n\ny_array\n=np.array(list_y)\n\ny_array\n=y_array*0.2/400\n\nz55\n=np.stack((x_array,y_array),axis=0).T\nz0=[]\n\nfor\n i \nin\n range(0,z55.shape[0],30):\n    \nz1\n=z55[i,:]\n    z0.append(z1)\n\nz0\n=np.array(z0)\n\n\nx_array\n=z0[:,0]\n\ny_array\n=z0[:,1]\n\nprint\n(x_array)\n\nprint\n(y_array)\n\nlist_x1=[]\n\nfor\n i \nin\n range(0,len(x_array)):\n    list_x1.append(40)\n\nx1_array\n=np.array(list_x1)\n\nlist_x0=[]\n\nfor\n i \nin\n range(0,len(x_array)):\n    list_x0.append(1)\n\nx0\n=np.array(list_x0)\n\nx1\n=x_array\n\nx2\n=x1_array\n\nx3\n=x1*x2\n\nx4\n=x1*x1\n\nx5\n=x2*x2\n\nlabel55\n=y_array\n\nz55\n=np.stack((x0,x1,x2,x3,x4,x5),axis=0).T\n\n\n\n\n\nimg = cv2.imread(r\n'C:\\Users\\Xpc\\Desktop\\weixin2222 -60.jpg'\n)\nhsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\nlow_hsv = np.array([0, 0, 221])\nhigh_hsv = np.array([180, 30, 255])\nmask = cv2.inRange(hsv, \nlowerb\n=low_hsv, \nupperb\n=high_hsv)\n\n\nlist_y = []\nlist_x = []\n\n\nfor\n i \nin\n range(len(mask)):\n    xmax = []\n    \nfor\n j \nin\n range(len(mask[i])):\n        \nif\n mask[i][j] == 0:\n            list_x.append(j)\n            list_y.append(len(mask)-i)\n\nplt.plot(list_x, list_y, \n'o'\n, \ncolor\n=\n'r'\n)\nplt.show()\n\n\nx_array\n=np.array(list_x)\n\nx_array\n=x_array/400\n\ny_array\n=np.array(list_y)\n\ny_array\n=y_array*0.2/400\n\nz60\n=np.stack((x_array,y_array),axis=0).T\nz0=[]\n\nfor\n i \nin\n range(0,z60.shape[0],30):\n    \nz1\n=z60[i,:]\n    z0.append(z1)\n\nz0\n=np.array(z0)\n\n\nx_array\n=z0[:,0]\n\ny_array\n=z0[:,1]\n\nprint\n(x_array)\n\nprint\n(y_array)\n\nlist_x1=[]\n\nfor\n i \nin\n range(0,len(x_array)):\n    list_x1.append(40)\n\nx1_array\n=np.array(list_x1)\n\nlist_x0=[]\n\nfor\n i \nin\n range(0,len(x_array)):\n    list_x0.append(1)\n\nx0\n=np.array(list_x0)\n\nx1\n=x_array\n\nx2\n=x1_array\n\nx3\n=x1*x2\n\nx4\n=x1*x1\n\nx5\n=x2*x2\n\nlabel60\n=y_array\n\nz60\n=np.stack((x0,x1,x2,x3,x4,x5),axis=0).T\n\n\n\n\n\nimg = cv2.imread(r\n'C:\\Users\\Xpc\\Desktop\\weixin2222 - 65.jpg'\n)\nhsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\nlow_hsv = np.array([0, 0, 221])\nhigh_hsv = np.array([180, 30, 255])\nmask = cv2.inRange(hsv, \nlowerb\n=low_hsv, \nupperb\n=high_hsv)\n\nlist_y = []\nlist_x = []\n\n\nfor\n i \nin\n range(len(mask)):\n    xmax = []\n    \nfor\n j \nin\n range(len(mask[i])):\n        \nif\n mask[i][j] == 0:\n            list_x.append(j)\n            list_y.append(len(mask)-i)\n\nplt.plot(list_x, list_y, \n'o'\n, \ncolor\n=\n'r'\n)\nplt.show()\n\n\nx_array\n=np.array(list_x)\n\nx_array\n=x_array/400\n\ny_array\n=np.array(list_y)\n\ny_array\n=y_array*0.2/400\n\nz65\n=np.stack((x_array,y_array),axis=0).T\nz0=[]\n\nfor\n i \nin\n range(0,z65.shape[0],30):\n    \nz1\n=z65[i,:]\n    z0.append(z1)\n\nz0\n=np.array(z0)\n\nx_array\n=z0[:,0]\n\ny_array\n=z0[:,1]\n\nprint\n(x_array)\n\nprint\n(y_array)\n\nlist_x1=[]\n\nfor\n i \nin\n range(0,len(x_array)):\n    list_x1.append(40)\n\nx1_array\n=np.array(list_x1)\n\nlist_x0=[]\n\nfor\n i \nin\n range(0,len(x_array)):\n    list_x0.append(1)\n\nx0\n=np.array(list_x0)\n\nx1\n=x_array\n\nx2\n=x1_array\n\nx3\n=x1*x2\n\nx4\n=x1*x1\n\nx5\n=x2*x2\n\nlabel65\n=y_array\n\nz65\n=np.stack((x0,x1,x2,x3,x4,x5),axis=0).T\n\n\n\nimg = cv2.imread(r\n'C:\\Users\\Xpc\\Desktop\\weixin2222 - 70.jpg'\n)\nhsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\nlow_hsv = np.array([0, 0, 221])\nhigh_hsv = np.array([180, 30, 255])\nmask = cv2.inRange(hsv, \nlowerb\n=low_hsv, \nupperb\n=high_hsv)\n\nlist_y = []\nlist_x = []\n\n\nfor\n i \nin\n range(len(mask)):\n    xmax = []\n    \nfor\n j \nin\n range(len(mask[i])):\n        \nif\n mask[i][j] == 0:\n            list_x.append(j)\n            list_y.append(len(mask)-i)\n\nplt.plot(list_x, list_y, \n'o'\n, \ncolor\n=\n'r'\n)\nplt.show()\n\n\nx_array\n=np.array(list_x)\n\nx_array\n=x_array/400\n\ny_array\n=np.array(list_y)\n\ny_array\n=y_array*0.2/400\n\nz70\n=np.stack((x_array,y_array),axis=0).T\nz0=[]\n\nfor\n i \nin\n range(0,z70.shape[0],30):\n    \nz1\n=z70[i,:]\n    z0.append(z1)\n\nz0\n=np.array(z0)\n\nx_array\n=z0[:,0]\n\ny_array\n=z0[:,1]\n\nprint\n(x_array)\n\nprint\n(y_array)\n\nlist_x1=[]\n\nfor\n i \nin\n range(0,len(x_array)):\n    list_x1.append(40)\n\nx1_array\n=np.array(list_x1)\n\nlist_x0=[]\n\nfor\n i \nin\n range(0,len(x_array)):\n    list_x0.append(1)\n\nx0\n=np.array(list_x0)\n\nx1\n=x_array\n\nx2\n=x1_array\n\nx3\n=x1*x2\n\nx4\n=x1*x1\n\nx5\n=x2*x2\n\nlabel70\n=y_array\n\nz70\n=np.stack((x0,x1,x2,x3,x4,x5),axis=0).T\n\n\nrescombine = np.vstack((z40,z50,z55,z60,z65,z70))\nlabels= np.hstack((label40,label50,label55,label60,label65,label70)).T\n\nlabels\n=labels.reshape(-1, 1)\n\n\nfrom\n sklearn.model_selection import train_test_split\nx_train,x_test,y_train,y_test = train_test_split(rescombine,labels,\ntest_size\n=0.25)\n\n\nfrom\n sklearn.preprocessing import MinMaxScaler\nmm = MinMaxScaler()\nx_train = mm.fit_transform(x_train)\ny_train = mm.fit_transform(y_train)\ny_max = y_train.max(\naxis\n=0)\ny_min = y_train.min(\naxis\n=0)\n\n\ndata\n=x_train\n\nlabels\n=y_train\n\nclass LinearRegression:\n    def __init__(self,data,labels):\n        \n        self.data = data\n        self.labels = labels\n        num_features = len(data[1])\n        self.theta = np.zeros((num_features,1))\n        \n\n\n    def train(self,alpha,num_iterations = 500):\n       \n        cost_history = self.gradient_descent(alpha,num_iterations)\n        return self.theta,cost_history\n        \n    def gradient_descent(self,alpha,num_iterations):\n        cost_history= []\n        \nfor\n _ \nin\n range(num_iterations):\n            self.gradient_step(alpha)\n            cost_history.append(self.cost_function(self.data,self.labels))\n        return cost_history\n        \n        \n    def gradient_step(self,alpha):    \n        num_examples = data.shape[0]\n        prediction = LinearRegression.hypothesis(self.data,self.theta)\n        delta = prediction - self.labels   ##有问题\n..\n.\n        theta = self.theta\n        theta = theta - alpha*(1/num_examples)*(np.dot(delta.T,self.data)).T\n        self.theta = theta\n        \n        \n    def cost_function(self,data,labels):\n        self.m = len(labels) \n        delta = LinearRegression.hypothesis(data,self.theta) - labels\n        cost = (1/2)*np.dot(delta.T,delta)/self.m\n        return cost[0][0]\n        \n    \n    def hypothesis(data,theta):   \n        predictions = np.dot(data,theta)\n        return predictions\n        \n\nx_train = rescombine\n\ny_train = labels\n\nnum_iterations = 500\nlearning_rate = 0.01  \n\n\nlinear_regression = LinearRegression(x_train, y_train)\n\n(theta, cost_history) = linear_regression.train(learning_rate, num_iterations)\n\n\n\n\nprint\n (theta, cost_history)\n\nprint\n(len( cost_history))\n\n\n\n\n运行结果及报错内容\n\n\n发生异常: ValueError\noperands could not be broadcast together with shapes (207,1) (155,1) \n  \nFile\n \n\"C:\\Users\\Xpc\\Desktop\\LinearRegression\\linear_regression.py\"\n, \nline\n 380, \nin\n gradient_step\n    delta = prediction - self.labels   ##有问题...\n  \nFile\n \n\"C:\\Users\\Xpc\\Desktop\\LinearRegression\\linear_regression.py\"\n, \nline\n 372, \nin\n gradient_descent\n    self.gradient_step(\nalpha\n)\n  \nFile\n \n\"C:\\Users\\Xpc\\Desktop\\LinearRegression\\linear_regression.py\"\n, \nline\n 366, \nin\n train\n    cost_history = self.gradient_descent(\nalpha\n,num_iterations)\n  \nFile\n \n\"C:\\Users\\Xpc\\Desktop\\LinearRegression\\linear_regression.py\"\n, \nline\n 408, \nin\n \n    (theta, cost_history) = linear_regression.train(learning_rate, num_iterations)\n\n\n\n\n我的解答思路和尝试过的方法\n\n\n我提取了一些数据\n\n\nimport numpy as np\n\nimport cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimg = cv2.imread(r\n'C:\\Users\\Xpc\\Desktop\\weixin2222 change40.jpg'\n)\nhsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\nlow_hsv = np.array([0, 0, 221])\nhigh_hsv = np.array([180, 30, 255])\nmask = cv2.inRange(hsv, \nlowerb\n=low_hsv, \nupperb\n=high_hsv)\n\nlist_y = []\nlist_x = []\n\n\nfor\n i \nin\n range(len(mask)):\n    xmax = []\n    \nfor\n j \nin\n range(len(mask[i])):\n        \nif\n mask[i][j] == 0:\n            list_x.append(j)\n            list_y.append(len(mask)-i)\n\nplt.plot(list_x, list_y, \n'o'\n, \ncolor\n=\n'r'\n)\nplt.show()\n\n\nx_array\n=np.array(list_x)\n\nx_array\n=x_array/400\n\ny_array\n=np.array(list_y)\n\ny_array\n=y_array*0.2/400\n\n\nz40\n=np.stack((x_array,y_array),axis=0).T\nz0=[]\n\nfor\n i \nin\n range(0,z40.shape[0],30):\n    \nz1\n=z40[i,:]\n    z0.append(z1)\n\nz0\n=np.array(z0)\n\nx_array\n=z0[:,0]\n\ny_array\n=z0[:,1]\n\nprint\n(x_array)\n\nprint\n(y_array)\n\n\nlist_x1=[]\n\nfor\n i \nin\n range(0,len(x_array)):\n    list_x1.append(40)\n\nx1_array\n=np.array(list_x1)\n\nlist_x0=[]\n\nfor\n i \nin\n range(0,len(x_array)):\n    list_x0.append(1)\n\nx0\n=np.array(list_x0)\n\nx1\n=x_array\n\nx2\n=x1_array\n\nx3\n=x1*x2\n\nx4\n=x1*x1\n\nx5\n=x2*x2\n\nlabel40\n=y_array\n\nz40\n=np.vstack((x0,x1,x2,x3,x4,x5)).T\n\n\n\n\n\nimg = cv2.imread(r\n'C:\\Users\\Xpc\\Desktop\\weixin2222 - 50.jpg'\n)\nhsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\nlow_hsv = np.array([0, 0, 221])\nhigh_hsv = np.array([180, 30, 255])\nmask = cv2.inRange(hsv, \nlowerb\n=low_hsv, \nupperb\n=high_hsv)\n\n\nlist_y = []\nlist_x = []\n\n\nfor\n i \nin\n range(len(mask)):\n    xmax = []\n    \nfor\n j \nin\n range(len(mask[i])):\n        \nif\n mask[i][j] == 0:\n            list_x.append(j)\n            list_y.append(len(mask)-i)\n\nplt.plot(list_x, list_y, \n'o'\n, \ncolor\n=\n'r'\n)\nplt.show()\n\n\nx_array\n=np.array(list_x)\n\nx_array\n=x_array/400\n\ny_array\n=np.array(list_y)\n\ny_array\n=y_array*0.2/400\n\nz50\n=np.stack((x_array,y_array),axis=0).T\nz0=[]\n\nfor\n i \nin\n range(0,z50.shape[0],30):\n    \nz1\n=z50[i,:]\n    z0.append(z1)\n\nz0\n=np.array(z0)\n\n\nx_array\n=z0[:,0]\n\ny_array\n=z0[:,1]\n\nprint\n(x_array)\n\nprint\n(y_array)\n\nlist_x1=[]\n\nfor\n i \nin\n range(0,len(x_array)):\n    list_x1.append(40)\n\nx1_array\n=np.array(list_x1)\n\nlist_x0=[]\n\nfor\n i \nin\n range(0,len(x_array)):\n    list_x0.append(1)\n\nx0\n=np.array(list_x0)\n\nx1\n=x_array\n\nx2\n=x1_array\n\nx3\n=x1*x2\n\nx4\n=x1*x1\n\nx5\n=x2*x2\n\nlabel50\n=y_array\n\nz50\n=np.stack((x0,x1,x2,x3,x4,x5),axis=0).T\n\n\n\n\n \nimg = cv2.imread(r\n'C:\\Users\\Xpc\\Desktop\\weixin2222 - 55.jpg'\n)\nhsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\nlow_hsv = np.array([0, 0, 221])\nhigh_hsv = np.array([180, 30, 255])\nmask = cv2.inRange(hsv, \nlowerb\n=low_hsv, \nupperb\n=high_hsv)\n\nlist_y = []\nlist_x = []\n\n\nfor\n i \nin\n range(len(mask)):\n    xmax = []\n    \nfor\n j \nin\n range(len(mask[i])):\n        \nif\n mask[i][j] == 0:\n            list_x.append(j)\n            list_y.append(len(mask)-i)\n\nplt.plot(list_x, list_y, \n'o'\n, \ncolor\n=\n'r'\n)\nplt.show()\n\n\nx_array\n=np.array(list_x)\n\nx_array\n=x_array/400\n\ny_array\n=np.array(list_y)\n\ny_array\n=y_array*0.2/400\n\nz55\n=np.stack((x_array,y_array),axis=0).T\nz0=[]\n\nfor\n i \nin\n range(0,z55.shape[0],30):\n    \nz1\n=z55[i,:]\n    z0.append(z1)\n\nz0\n=np.array(z0)\n\n\nx_array\n=z0[:,0]\n\ny_array\n=z0[:,1]\n\nprint\n(x_array)\n\nprint\n(y_array)\n\nlist_x1=[]\n\nfor\n i \nin\n range(0,len(x_array)):\n    list_x1.append(40)\n\nx1_array\n=np.array(list_x1)\n\nlist_x0=[]\n\nfor\n i \nin\n range(0,len(x_array)):\n    list_x0.append(1)\n\nx0\n=np.array(list_x0)\n\nx1\n=x_array\n\nx2\n=x1_array\n\nx3\n=x1*x2\n\nx4\n=x1*x1\n\nx5\n=x2*x2\n\nlabel55\n=y_array\n\nz55\n=np.stack((x0,x1,x2,x3,x4,x5),axis=0).T\n\n\n\n\n\nimg = cv2.imread(r\n'C:\\Users\\Xpc\\Desktop\\weixin2222 -60.jpg'\n)\nhsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\nlow_hsv = np.array([0, 0, 221])\nhigh_hsv = np.array([180, 30, 255])\nmask = cv2.inRange(hsv, \nlowerb\n=low_hsv, \nupperb\n=high_hsv)\n\n\nlist_y = []\nlist_x = []\n\n\nfor\n i \nin\n range(len(mask)):\n    xmax = []\n    \nfor\n j \nin\n range(len(mask[i])):\n        \nif\n mask[i][j] == 0:\n            list_x.append(j)\n            list_y.append(len(mask)-i)\n\nplt.plot(list_x, list_y, \n'o'\n, \ncolor\n=\n'r'\n)\nplt.show()\n\n\nx_array\n=np.array(list_x)\n\nx_array\n=x_array/400\n\ny_array\n=np.array(list_y)\n\ny_array\n=y_array*0.2/400\n\nz60\n=np.stack((x_array,y_array),axis=0).T\nz0=[]\n\nfor\n i \nin\n range(0,z60.shape[0],30):\n    \nz1\n=z60[i,:]\n    z0.append(z1)\n\nz0\n=np.array(z0)\n\n\nx_array\n=z0[:,0]\n\ny_array\n=z0[:,1]\n\nprint\n(x_array)\n\nprint\n(y_array)\n\nlist_x1=[]\n\nfor\n i \nin\n range(0,len(x_array)):\n    list_x1.append(40)\n\nx1_array\n=np.array(list_x1)\n\nlist_x0=[]\n\nfor\n i \nin\n range(0,len(x_array)):\n    list_x0.append(1)\n\nx0\n=np.array(list_x0)\n\nx1\n=x_array\n\nx2\n=x1_array\n\nx3\n=x1*x2\n\nx4\n=x1*x1\n\nx5\n=x2*x2\n\nlabel60\n=y_array\n\nz60\n=np.stack((x0,x1,x2,x3,x4,x5),axis=0).T\n\n\n\n\n\nimg = cv2.imread(r\n'C:\\Users\\Xpc\\Desktop\\weixin2222 - 65.jpg'\n)\nhsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\nlow_hsv = np.array([0, 0, 221])\nhigh_hsv = np.array([180, 30, 255])\nmask = cv2.inRange(hsv, \nlowerb\n=low_hsv, \nupperb\n=high_hsv)\n\nlist_y = []\nlist_x = []\n\n\nfor\n i \nin\n range(len(mask)):\n    xmax = []\n    \nfor\n j \nin\n range(len(mask[i])):\n        \nif\n mask[i][j] == 0:\n            list_x.append(j)\n            list_y.append(len(mask)-i)\n\nplt.plot(list_x, list_y, \n'o'\n, \ncolor\n=\n'r'\n)\nplt.show()\n\n\nx_array\n=np.array(list_x)\n\nx_array\n=x_array/400\n\ny_array\n=np.array(list_y)\n\ny_array\n=y_array*0.2/400\n\nz65\n=np.stack((x_array,y_array),axis=0).T\nz0=[]\n\nfor\n i \nin\n range(0,z65.shape[0],30):\n    \nz1\n=z65[i,:]\n    z0.append(z1)\n\nz0\n=np.array(z0)\n\nx_array\n=z0[:,0]\n\ny_array\n=z0[:,1]\n\nprint\n(x_array)\n\nprint\n(y_array)\n\nlist_x1=[]\n\nfor\n i \nin\n range(0,len(x_array)):\n    list_x1.append(40)\n\nx1_array\n=np.array(list_x1)\n\nlist_x0=[]\n\nfor\n i \nin\n range(0,len(x_array)):\n    list_x0.append(1)\n\nx0\n=np.array(list_x0)\n\nx1\n=x_array\n\nx2\n=x1_array\n\nx3\n=x1*x2\n\nx4\n=x1*x1\n\nx5\n=x2*x2\n\nlabel65\n=y_array\n\nz65\n=np.stack((x0,x1,x2,x3,x4,x5),axis=0).T\n\n\n\nimg = cv2.imread(r\n'C:\\Users\\Xpc\\Desktop\\weixin2222 - 70.jpg'\n)\nhsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\nlow_hsv = np.array([0, 0, 221])\nhigh_hsv = np.array([180, 30, 255])\nmask = cv2.inRange(hsv, \nlowerb\n=low_hsv, \nupperb\n=high_hsv)\n\nlist_y = []\nlist_x = []\n\n\nfor\n i \nin\n range(len(mask)):\n    xmax = []\n    \nfor\n j \nin\n range(len(mask[i])):\n        \nif\n mask[i][j] == 0:\n            list_x.append(j)\n            list_y.append(len(mask)-i)\n\nplt.plot(list_x, list_y, \n'o'\n, \ncolor\n=\n'r'\n)\nplt.show()\n\n\nx_array\n=np.array(list_x)\n\nx_array\n=x_array/400\n\ny_array\n=np.array(list_y)\n\ny_array\n=y_array*0.2/400\n\nz70\n=np.stack((x_array,y_array),axis=0).T\nz0=[]\n\nfor\n i \nin\n range(0,z70.shape[0],30):\n    \nz1\n=z70[i,:]\n    z0.append(z1)\n\nz0\n=np.array(z0)\n\nx_array\n=z0[:,0]\n\ny_array\n=z0[:,1]\n\nprint\n(x_array)\n\nprint\n(y_array)\n\nlist_x1=[]\n\nfor\n i \nin\n range(0,len(x_array)):\n    list_x1.append(40)\n\nx1_array\n=np.array(list_x1)\n\nlist_x0=[]\n\nfor\n i \nin\n range(0,len(x_array)):\n    list_x0.append(1)\n\nx0\n=np.array(list_x0)\n\nx1\n=x_array\n\nx2\n=x1_array\n\nx3\n=x1*x2\n\nx4\n=x1*x1\n\nx5\n=x2*x2\n\nlabel70\n=y_array\n\nz70\n=np.stack((x0,x1,x2,x3,x4,x5),axis=0).T\n\n\nrescombine = np.vstack((z40,z50,z55,z60,z65,z70))\nlabels= np.hstack((label40,label50,label55,label60,label65,label70)).T\n\nlabels\n=labels.reshape(-1, 1)\n\n\nfrom\n sklearn.model_selection import train_test_split\nx_train,x_test,y_train,y_test = train_test_split(rescombine,labels,\ntest_size\n=0.25)\n\n\nfrom\n sklearn.preprocessing import MinMaxScaler\nmm = MinMaxScaler()\nx_train = mm.fit_transform(x_train)\ny_train = mm.fit_transform(y_train)\ny_max = y_train.max(\naxis\n=0)\ny_min = y_train.min(\naxis\n=0)\n\n\ndata\n=x_train\n\nlabels\n=y_train\n\nnum_features = len(data[1])\ntheta = np.zeros((num_features,1))\npredictions = np.dot(data,theta)\n\nprint\n(len(data[1]))#列数\n\nprint\n(len(data))#行数\n\nprint\n(len(theta[1]))\n\nprint\n(len(theta))\n\nprint\n(len(predictions [1]))\n\nprint\n(len(predictions))\n\nprint\n(len(labels))\n\nprint\n(len(labels[1]))\n\n\n\n\n运行结果显示prediction并没有出错\n\n\n6\n155\n1\n6\n1\n155\n155\n1\n\n\n\n\n我想要达到的结果 找出原程序里的错误原因", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/v5zsq/article/details/47948397", "Konwledge_Point": "线性规划简介", "Question": "The Balance              一元线性同余方程\nDescription \n\n给出两种质量的砝码，和一件物品，问要多少砝码能称出物品，砝码的个数满足两种砝码的数量和尽量小，如果还有多解满足两种砝码的总质量最少 \n\nInput \n\n多组用例，每组用例包括三个整数a，b和d分别表示两种砝码的质量以及物品的质量，以0 0 0结束输入 \n\nOutput \n\n对于每组用例，输出能称出物品质量的砝码个数，砝码的个数满足两种砝码的数量和尽量小，如果还有多解满足两种砝码的总质量最少 \n\nSample Input \n\n700 300 200 \n\n500 200 300 \n\n500 200 500 \n\n275 110 330 \n\n275 110 385 \n\n648 375 4002 \n\n3 1 10000 \n\n0 0 0 \n\nSample Output \n\n1 3 \n\n1 1 \n\n1 0 \n\n0 3 \n\n1 1 \n\n49 74 \n\n3333 1 ", "Tag": "算法分析"}
{"Answer": "三个未知数四个代数式，容易无解。所以先用前三个求出解，带入验证。\n\nimport numpy as np\nA=np.array([[1,2,-3],\n           [2,3,1],\n           [3,-1,2]])\nb=np.array([13,4,-1])\nx=np.linalg.solve(A,b)\nprint(x)\n\n解得x=[2,1,-3]代入4式，成立。", "Konwledge_Point": "线性规划简介", "Question": "关于线性方程组的求解。，/*+\nX1+2X2-3X3=13\n2X1+3X2+X3=4\n3X1-X2+2X3=-1\nX1-X2+3X3=-8", "Tag": "算法分析"}
{"Answer": "你好，这类似于这种构架就行\nro1 = @(m,n,p,q) 这里写你的约束;\nro2 = @(m,n,p,q) 这里写你的约束;\nro3 = @(m,n,p,q) 这里写你的约束;\ng = @(x) myfun(g, x);\nfmincon(g, ……, @(x) nlinc(x,ro1,ro2,ro3))\n\nfunction [c, ceq] = nlinc(x, ro1, ro2, ro3)\nx = num2cell(x(:))';\nceq =[]; %我这里设若等式约束没有\nif(条件1)\nc = ro1(x{:})\nelseif(条件2) \nc = ro2(x{:})\nelse\nc = ro3(x{:})\nend\nend\n\n", "Konwledge_Point": "线性规划简介", "Question": "关于fmincon 函数非线性约束的符号转换。需要一个通用方案\n\n\n之前的公式计算了fmincon需要的 三个非线性约束，已经转换成了标准型。\n目标函数是求 minimum： m^2+n^2+p^2+q^2\n想要一个转化方式将约束中包含的m,n,p,q 自动转化成x(1),x(2),x(3),x(4)这种形式。\n因为这三约束根据给出的初始条件不同，约束也不一样，所以需要一个通用方案。", "Tag": "算法分析"}
{"Answer": "![图片说明](https://img-ask.csdn.net/upload/201504/09/1428565544_388835.png)这个地方错了，改一下！", "Konwledge_Point": "线性规划简介", "Question": "线性布局问题 计算器布局\n4/09/1428560451_585625.png)\n\n\n\n为什么没有出现第一张效果，求解\n\n代码如下：\n\n\n\n    android:layout_width=\"match_parent\"\n\n    android:layout_height=\"match_parent\"\n\n    android:orientation=\"vertical\" >\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "代码没什么大问题，改动处见注释，完善如下，供参考：\n#define _CRT_SECURE_NO_WARNINGS 1\n#include<stdio.h>\n#include<stdlib.h>\n#include<assert.h>\ntypedef int datatype;\ntypedef struct node {\n    datatype data;\n    struct node* link;\n}node;\n\nnode* BuySLTNode(datatype x)\n{\n    node* newnode = (node*)malloc(sizeof(node));\n    if (newnode == NULL)\n    {\n        perror(\"malloc fail\");\n        exit(-1);\n    }\n    newnode->data = x;\n    newnode->link = NULL;\n    return newnode;\n}\n\nnode* CreateSList()\n{\n    datatype data;\n    node* phead = NULL, * ptail = NULL;\n    while (1)\n    {\n        scanf(\"%d\", &data); //修改  \n        node* newnode = BuySLTNode(data);\n        if (phead == NULL)\n            phead = newnode;//修改 \n        else\n            ptail->link = newnode;\n        ptail = newnode;   //修改 \n        if ((getchar()) == '\\n')  break; //修改\n    } \n    return phead;\n}\n\nnode* Find_max(node* phead)   \n{\n    node* cur = phead;\n    node* Max = phead;\n    datatype max = cur->data;\n    while (cur)\n    {\n        if (cur->data > max)\n        {\n            max = cur->data;\n            Max = cur;\n        }\n        cur = cur->link;\n    }\n    return Max;\n}\n\nvoid SListErase(node** pphead, node* pos) \n{\n    assert(pos);\n    assert(*pphead);\n    if (pos == *pphead)\n    {\n        node* next = (*pphead)->link;\n        free(*pphead);\n        *pphead = next;\n    }\n    else\n    {\n        node* prev = *pphead;\n        while (prev->link != pos)\n        {\n            prev = prev->link;\n        }\n        prev->link = pos->link;\n        free(pos);\n    }\n}\nvoid SLTPushBack(node** pphead, datatype x) \n{\n    node* newnode = BuySLTNode(x);\n    if (*pphead == NULL)\n    {\n        *pphead = newnode;\n    }\n    else\n    {\n        node* tail = *pphead;\n        //找尾\n        while (tail->link)\n        {\n            tail = tail->link;\n        }\n        tail->link = newnode;\n    }\n}\n\nvoid SLTPrint(node* phead)\n{\n    node* cur = phead;\n    while (cur)\n    {\n        printf(\"%d \", cur->data); //修改\n        cur = cur->link;\n    }\n}\n\nint main()\n{\n    node* plist = NULL;   //(node*)malloc(sizeof(node)); 修改\n    plist = CreateSList();\n    node* max = Find_max(plist);   \n    SLTPushBack(&plist, max->data); //修改 SLTPushBack(plist, max->data);\n    SListErase(&plist, max);        //修改 SListErase(plist, max);\n    SLTPrint(plist);\n    return 0;\n}\n\n", "Konwledge_Point": "线性规划简介", "Question": "C语言线性链表的结点移动\n【问题描述】\n已知非空线性链表第1个链结点指针为list，链结点构造为\n\n\nstruct \nnode\n{\n    datatype\n data;\n    \nnode\n \n*link\n;\n};\n\n\n\n\n请写一算法，将该链表中数据域值最大的那个点移到链表的最后面。（假设链表中数据域值最大的链结点惟一）（注意：要求先写出算法的解题思路，然后再写出算法）\n【输入形式】\n输入为一个整数序列，整数之间以空格隔开，序列以回车结尾。\n【输出形式】\n输出为移动后的整数序列，整数之间以空格隔开，序列以回车结尾。\n【样例输入】\n3 12 4 9 5 1\n【样例输出】\n3 4 9 5 1 12\n【样例说明】\n将序列中最大的数字12移动到序列最后。\n\n\n我的思路：\n1.先遍历链表找出那个最大值\n2.尾插最大值\n3.删最大值对应结点\n代码如下：\n\n\n#define _CRT_SECURE_NO_WARNINGS 1\n\n\n#include\n\n\n#include\n\n\n#include\n\ntypedef int datatype;\ntypedef struct \nnode\n \n{\n    datatype\n data;\n    struct \nnode\n* link\n;\n}\nnode\n;\n\nnode\n* BuySLTNode(datatype x)\n{\n    \nnode\n* newnode\n = (\nnode\n*)malloc\n(sizeof(\nnode\n));\n    if\n (newnode == NULL)\n    {\n        perror(\n\"malloc fail\"\n);\n        exit(-\n1\n);\n    }\n    newnode->data = x;\n    newnode->link = NULL;\n    return newnode;\n}\n\n\nnode\n* CreateSList\n()\n{\n    datatype data;\n    \nnode\n* phead\n = NULL, *ptail = NULL;\n    while(\n1\n)\n    {\n        scanf(\n\"%d\"\n, &data);\n        if (getchar() == '\\n')\n        {\n            break;\n        }\n        \nnode\n* newnode\n = BuySLTNode(data);\n        if (phead == NULL)\n        {\n            ptail = phead = newnode;\n        }\n        else\n        {\n            ptail->link = newnode;\n            ptail = newnode;\n        }\n    }\n\n    return phead;\n}\n\n\nnode\n* Find_max\n(\nnode\n* phead\n)\n{\n    \nnode\n* cur\n = phead;\n    \nnode\n* Max\n = phead;\n    datatype max = cur->data;\n    while (cur)\n    {\n        if (cur->data > max)\n        {\n            max = cur->data;\n            Max = cur;\n        }\n        cur = cur->link;\n    }\n    return Max;\n}\n\nvoid SListErase(\nnode\n** pphead\n, \nnode\n* pos\n)\n{\n    assert(pos);\n    assert(*pphead);\n    if (pos == *pphead)\n    {\n        \nnode\n* next\n = (*pphead)->link;\n        free(*pphead);\n        *pphead = next;\n    }\n    else\n    {\n        \nnode\n* prev\n = *pphead;\n        while (prev->link != pos)\n        {\n            prev = prev->link;\n        }\n        prev->link = pos->link;\n        free(pos);\n    }\n}\nvoid SLTPushBack(\nnode\n** pphead\n, datatype x)\n{\n    \nnode\n* newnode\n = BuySLTNode(x);\n    if (*pphead == NULL)\n    {\n        *pphead = newnode;\n    }\n    else\n    {\n        \nnode\n* tail\n = *pphead;\n        //找尾\n        while (tail->link)\n        {\n            tail = tail->link;\n        }\n        tail->link = newnode;\n    }\n}\n\nvoid SLTPrint(\nnode\n* phead\n)\n{\n    \nnode\n* cur\n = phead;\n    while (cur)\n    {\n        printf(\n\"%d\"\n, cur->data);\n        cur = cur->link;\n    }\n}\n\n\nint main()\n{\n    \nnode\n* plist\n = (\nnode\n*)malloc\n(sizeof(\nnode\n));\n    plist\n = CreateSList();\n    \nnode\n* max\n = Find_max(plist);\n    SLTPushBack(plist, max->data);\n    SListErase(plist, max);\n    SLTPrint(plist);\n    return \n0\n;\n}\n\n\n\n\n但是打印结果如下：\n\n\n试图调试的时候发现：\n\n\n\n\n不知道是哪里出错了 希望得到帮助 非常感谢", "Tag": "算法分析"}
{"Answer": "你这里的无约束条件不是图片中了的吧，被你修改了的，运行程序没错，你可以看看是不是参数上设置错了", "Konwledge_Point": "线性规划简介", "Question": "fmincon函数非线性优化问题\nclear;\nclc;\n\nlb = [\n1\n;\n0.625\n;\n25\n;\n25\n];\nub = [\n1.375\n;\n1\n;\n150\n;\n240\n];\n\nA=[-\n1\n \n0\n \n0.0193\n \n0\n;\n    \n0\n -\n1\n \n0.00954\n \n0\n;\n    \n0\n \n0\n \n0\n \n1\n;\n    -\n1\n \n0\n \n0\n \n0\n;\n    \n0\n -\n1\n \n0\n \n0\n];\nb=[\n0\n;\n0\n;\n240\n;-\n1.1\n;-\n0.6\n];\n\n\nfunction\n [\nc\n,\nceq\n] = \nmycon\n(x)\n\n\nc\n=-\npi\n*\nx\n(3)\n*\nx\n(3)\n-4/3*\npi\n*\nx\n(3)\n*\nx\n(3)\n*\nx\n(3)\n+1296000;\n\nceq = [];\n\nend\n\n\n\nfunction\n [ \nf7\n ] = \nmypeaks\n( x )\n\n\nf7\n=0.6224*\nx\n(1)\n*\nx\n(3)\n*\nx\n(4)\n+1.7781*\nx\n(2)\n*\nx\n(3)\n^2+3.1661*\nx\n(1)\n^2*\nx\n(4)\n+19.84*\nx\n(1)\n^2*\nx\n(3)\n;\n\n\nend\n\n\n\nfor\n i=\n1\n:\n50\n\n    x0 = [\n1\n;\n0\n;\n0\n;\n0\n]+\n1\n.*rand(\n4\n,\n1\n);  % randomly determine the initial point\n%     x0 = [\n0.5\n -\n1.5\n];\n    % sqp\n    sqp_opts = optimset(\n'Algorithm'\n,\n'sqp'\n,\n'Display'\n,\n'iter-detailed'\n );\n    [x,fval,exitflag,output]=fmincon(@mypeaks,x0,A,b,[],[],lb,ub,@mycon,sqp_opts);\n%     %% ga\n%     ga_opts = gaoptimset(\n'Display'\n,\n'off'\n,\n'PopulationSize'\n,\n100\n);\n%     [x,fval,exitflag,output]=ga(@mypeaks,\n4\n,A,b,[],[],lb,ub,@mycon,ga_opts);\n%     %% \nRecord\n data\n    recordY(i) = fval;\n    recordNfe(i) = output.funcCount;\n\nend\n\n\n\n\n\n\n\n最优解答案应该在8960，但是我的sqp算法算出来50个都是8949，没有变化很不对啊，请问哪里出了问题呢？", "Tag": "算法分析"}
{"Answer": "这只是以防万一的写法，也不会有count > n的出现，只是防止一些没法预想到的情况或者有时候程序写得不那么好会导致不应该发生的结果", "Konwledge_Point": "线性规划简介", "Question": "线性表链式存储的查找元素\n如图 在线性表的链式存储中 查找第n个元素\n图中圈出来的地方 count > n 这个条件 是不是多余啊 通过上面的while循环后 count 最多 = n\n什么时候会出现 count > n 呢", "Tag": "算法分析"}
{"Answer": "最后一段，没环境，没有测试过。layout_weight注意一下，如果一个区域分2部分，其中一个要占4分之3，则那个区域要设1（越小占比越大)，另一个要设3\r\n\r\n```\r\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \r\n```", "Konwledge_Point": "线性规划简介", "Question": "android线性布局（计算器ui）\n\n以上是效果图：\n\n下面是我的代码，求指教：\n\n\n\n    android:layout_width=\"match_parent\"\n\n    android:layout_height=\"match_parent\"\n\n    android:orientation=\"vertical\" >\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "这个错误是使用了未定义的变量.", "Konwledge_Point": "线性规划简介", "Question": "初学者求助：用python解一阶线性微分方程组\n目标：由f3，f4求解i（t），e（t）的数值解（给定初值）\n\n\n\n想拜托大佬们帮我看看这个思路是否可行，以及为何报错：\n\n\n\nfrom sympy import *\n\n\n\nt=symbols('t')\n\n\n\nf3=Eq(i(t).diff(t),1/5.1*e(t)-11.45*t**-1.662*i(t))\n\n\n\nf4=Eq(e(t).diff(t),-1/5.1*e(t)+4*i(t))\n\n\n\neq=(f3,f4)\n\n\n\n# 第一步求解i(t),e(t)的结果：\n\n\n\n# i(t)=C1*x0(t) + C2*x0(t)*Integral(0.196078431372549*exp(m)*exp(n)/x0(t)**2, t)\n\n\n\n# e(t)=C1*y0(t) + C2*(y0(t)*Integral(0.196078431372549*exp(m)*exp(n)/x0(t)**2, t) + exp(m)*exp(n)/x0(t))\n\n\n\n# 其中：\n\n\n\n# m=Integral(-0.196078431372549, t)=-0.196078431372549*t\n\n\n\n# n=Integral(-11.45*t**(-1.662), t)=17.2960725075529*t**(-0.662)\n\n\n\n# 第二步赋初值：C1=4156,C2=25000,将原方程组转换为求解未知函数x0(t),y0(t)的方程组(在下面程序中用x,y分别代替x0,y0)：\n\n\n\nx,y=symbols('x,y',cls=Function)\n\n\n\nf3=Eq(4900.0*Derivative(x(t),t)*Integral(exp(17.296*t**(-0.662))*exp(-0.196*t)/x(t)**2,t) + 4156*Derivative(x(t),t) + 4900.0*exp(17.296*t**(-0.662))*exp(-0.196*t)/x(t),1/5.1*(4156*y(t) + 25000*(y(t)*0.196*integrate(exp(17.296*t**(-0.662))*exp(-0.196*t)/x(t)**2,t) + exp(-0.196*t)*exp(17.296*t**(-0.662))/x(t)))-11.45*t**-1.662*(4156*x(t) + 25000*x(t)*0.196*integrate(exp(17.296*t**(-0.662))*exp(-0.196*t)/x(t)**2,t)))\n\n\n\nf4=Eq(-286248.8*t**(-1.662)*exp(17.296*t**(-0.662))*exp(-0.196*t)/x(t) + 4900.0*Derivative(y(t), t)*Integral(exp(17.296*t**(-0.662))*exp(-0.196*t)/x(t)**2, t) + 4156*Derivative(y(t), t) - 4900.0*exp(17.296*t**(-0.662))*exp(-0.196*t)/x(t) + 4900.0*y(t)*exp(17.296*t**(-0.662))*exp(-0.196*t)/x(t)**2 - 25000*exp(17.296*t**(-0.662))*exp(-0.196*t)*Derivative(x(t), t)/x(t)**2,-1/5.1*(4156*y(t) + 25000*(y(t)*0.196*integrate(exp(17.296*t**(-0.662))*exp(-0.196*t)/x(t)**2,t) + exp(-0.196*t)*exp(17.296*t**(-0.662))/x(t)))+4*(4156*x(t) + 25000*x(t)*0.196*integrate(exp(17.296*t**(-0.662))*exp(-0.196*t)/x(t)**2,t)))\n\n\n\neq=(f3,f4)\n\n\n\nresults=dsolve(eq)\n\n\n\nfor result in results:\n\n\n\n    print(result)\n\n\n\n \n\n\n\n报错：\n\n\n\nTraceback (most recent call last):\n\n  File \"c:/Users/lenovo/Desktop/1.py\", line 96, in \n\n    results=dsolve(eq)\n\n  File \"C:\\Users\\lenovo\\AppData\\Local\\Programs\\Python\\Python36-32\\lib\\site-packages\\sympy\\solvers\\ode\\ode.py\", \n\nline 588, in dsolve\n\n    match = classify_sysode(eq, func)\n\n  File \"C:\\Users\\lenovo\\AppData\\Local\\Programs\\Python\\Python36-32\\lib\\site-packages\\sympy\\solvers\\ode\\ode.py\", \n\nline 1971, in classify_sysode\n\n    type_of_equation = check_nonlinear_2eq_order1(eq, funcs, func_coef)\n\n  File \"C:\\Users\\lenovo\\AppData\\Local\\Programs\\Python\\Python36-32\\lib\\site-packages\\sympy\\solvers\\ode\\ode.py\", \n\nline 2106, in check_nonlinear_2eq_order1\n\n    (r1[f].subs(x(t),u).subs(y(t),v))/\n\nTypeError: 'NoneType' object is not subscriptable", "Tag": "算法分析"}
{"Answer": "你好，既然你知道了y和x那么数值求到了dy/dt和dx/dt，自然就可以通过插值方法得到与x和y等长的dy/dt和dx/dt，然后直接进行拟合就好了啊，lsqcurvefit也好，最小二乘法加上fminsearch求解也罢，都可以做啊！", "Konwledge_Point": "线性规划简介", "Question": "Matlab 非线性最小二乘法 求解微分方程\n如下微分方程，求解微分方程系数（a1, a2, a3）\n\n\n\n\n\n\n1）没有dx/dt 的方程\n2）yexp是实验值\n3）先假定a1,a2,a3，应用ode45计算解析值y,然后用lsqcurvefit求系数\n\n\n代码如下：\n\n\nt = data(:,1);\nx = data(:,2);\ny_exp = data(:,3);\n\ndt = t(2) - t(1);\nlen = length(x);\ndx_dt(1) = x(1)/dt;\n\ndx_dt(2:len) = diff(x) / dt;\n\ndy_exp(1) = y_exp(1)/dt;\n\ndy_exp(2:len) = diff(y_exp) / dt;\n\n\na1 = 10.74;\na2 = 0.91;\na3 = 290;\n\nget_dx_dt = @(t_sim) interp1(t(1:end), dx_dt, t_sim);\ndy_dt = @(t,y)(get_dx_dt(t)-sign(y)*(abs(y)/a1)^(1/a2))*a3;\n[tout, y] = ode4(dy_dt, t(1), dt, t(end), y_exp(1));\n\nlen_y = length(y);\nx1 = dx_dt(1:len_y);\nx2 = y';\nY =dy_exp(1:len_y);\nX=[x1;x2]';\na0=rand(1,3);\nfunc=@(a,X)(x1-sign(x2).*(abs(x2)/a(1)).^(1/a(2)))*a(3);\na=lsqcurvefit(func,a0,X,Y);\n\n\n\n\n计算得到的a为复数。\n请问:\n1.思路是否正确；\n2.如果思路不正确，能否指明正确思路\n\n\n谢谢", "Tag": "算法分析"}
{"Answer": "参考一下：https://blog.csdn.net/your_answer/article/details/79234275https://blog.csdn.net/linshen1213/article/details/99433348如果对你有帮助，可以点击我这个回答右上方的【采纳】按钮，给我个采纳吗，谢谢", "Konwledge_Point": "线性规划简介", "Question": "求解一阶线性微分方程组，matlab或者python都可以。\n有如下微分方程组：\n\n\n\n\n矩阵D全是数值，存在一些边界条件,当0<=Z<=10时，有Zmn（0）= -10，Xmn（0）=Ymn（0）=Xmn（10）=Ymn（10）=Zmn（10）=0,如何用matlab求解Rmn（z），数值解和解析解都可以。\n\n\nD=[0,0,0,0.00166666666666667,0,-2.19911485751286;0,0,0,0,0.00200000000000000,-2.19911485751286;0,0,0,2.19911485751286,2.19911485751286,0;51566.8828791659,4118.29417355141,-0.691545552676999,0,0,0;4118.29417355141,7768.18561244484,-0.567067353195139,0,0,0;0.691545552676999,0.567067353195139,0.000927672955974843,0,0,0]\n\n\nThanks！", "Tag": "算法分析"}
{"Answer": "计算多元线性回归中每个回归系数的t检验结果对应的Cohen's d需要以下步骤：\n1.计算每个回归系数的t值：将回归系数除以它的标准误差。\n2.计算每个回归系数对应的Cohen's d：将每个回归系数的t值除以样本的标准差的根号。\n3.评估Cohen's d的大小：Cohen's d的大小表示因变量的变化对自变量的影响，通常认为0.2是小的、0.5是中等的，0.8是大的。\n4.计算Cohen's d：Cohen's d是回归系数的t值除以因变量的标准差的根号，即d = t / sqrt(n)，其中n为样本的大小。\n注意：上述步骤需要使用样本数据以及其他相关的统计信息，如样本的标准差、样本的数量等。", "Konwledge_Point": "线性规划简介", "Question": "多元线性回归系数回归系数显著性检验（t检验）怎么求每个t检验的cohen‘d\n多元线性回归系数回归系数显著性检验（t检验）怎么求每个t检验的cohen‘d", "Tag": "算法分析"}
{"Answer": " https://blog.csdn.net/weixin_43905191/article/details/104677945?utm_source=app&app_version=5.2.1&code=app_1562916241&uLinkId=usr1mkqgl919blen", "Konwledge_Point": "线性规划简介", "Question": "想知道能不能用Python实现克莱姆公式求解线性方程组啊\n就自己瞎写了些，好像都不太行，想看看有没有什么方法实现用程序来计算克莱姆方程对线性方程组的求解", "Tag": "算法分析"}
{"Answer": "\nConsidering you want last row to always be id 1000:\nfunction linear($step) {\n\n $query = \"SELECT * FROM TABLE WHERE id IN (1000, 1000 - $step, 1000 - $step * 2, 1000 - $step * 3)\"\n $result = mysql_query($query)\n}\n\nIn case you do not know what is the last ID:\nfunction linear($step) {\n $lastId = mysql_fetch_assoc(mysql_query(\"SELECT id FROM TABLE ORDER BY id DESC LIMIT 1\"))['id']\n $query = \"SELECT * FROM TABLE WHERE id IN ($lastId, $lastId - $step, $lastId - $step * 2, $lastId - $step * 3)\"\n $result = mysql_query($query)\n}\n\nFeel free to ask if you need more information.\nYou are welcome.\n", "Konwledge_Point": "线性规划简介", "Question": "如何在MySQL中获取线性函数行？\n\n\n\nI have a MySQL table with 1000 rows. And I want to get 4 specific rows based on linear function as step (get value of row, last position must be the last row, row number 1000). Example:\n\n\n\n---------------------\n id  | value\n---------------------\n  1  | 3\n  2  | 1\n  3  | 5\n  4  | 4\n ... | ...\n 997 | 2\n 998 | 0\n 999 | 7\n1000 | 4\n--------------------\n\n\n\n\nStep as linear function (1,2,3....,N)\n\n\n\n*) step=1  =>  i will get 4 rows of id : 997,998,999,1000   \n       first row to get is row number 997, last row is row number 1000\n       result = 2,0,7,4\n*) step=2  =>  i will get 4 rows of id : 994,996,998,1000\n*) step=3  =>  i will get 4 rows of id : 991,994,997,1000\n*) step=4  =>  i will get 4 rows of id : 988,992,996,1000\n*) step=5  =>  i will get 4 rows of id : 985,990,995,1000\n.....\n*) step=330 => i will get 4 rows of id : 10,340,670,1000\n*) step=331 => i will get 4 rows of id : 7,338,669,1000\n*) step=332 => i will get 4 rows of id : 4,336,668,1000\n*) step=333 => i will get 4 rows of id : 1,334,667,1000\n\n\n\n\nHow to do it in PHP?\n\n    ", "Tag": "算法分析"}
{"Answer": "warning信息问题不大，做测试看结果的话可以忽略", "Konwledge_Point": "线性规划简介", "Question": "线性回归，运行时出现一个问题\n刚接触，复制别人的代码熟悉，遇到这样的问题，有能帮我看看嘛，需要改什么或者还是有什么问题", "Tag": "算法分析"}
{"Answer": "datetools好像已经弃用了 要么用别的 要么降版本", "Konwledge_Point": "线性规划简介", "Question": "大数据一元线性回归代码提示错误\n整个代码其他部分运行没问题，只有图示部分提示错误信息，不明白是什么意思，但又不影响整个代码正常运行。\n\n\n\n", "Tag": "算法分析"}
{"Answer": "http://www.zybang.com/question/7743c5097ab383da2608b909488a4498.html", "Konwledge_Point": "线性规划简介", "Question": "VS2010 求一个线性方程组A.x=b的解，用了Eige n库，可是我更新A，b后解没有更新\n代码 这里tub就是x (\nhttps://img-ask.csdn.net/upload/201607/29/1469795830_353711.png\n)\n\nA是矩阵，b是向量。for循环后A,b的值都变了，但是调试发现方程解tub不变。求指点", "Tag": "算法分析"}
{"Answer": "不是，因为new的过程就是动态申请内存的过程，就像C中的malloc一样动态的申请内存的，应该是链式的结构吧，但是数组不一样的，数组是线性的结构，不正确的地方欢迎指正，交流啊", "Konwledge_Point": "线性规划简介", "Question": "对象在内存中分配的时候，其属性是线性分配的吗？\n比如说：\n\nclass A\n\n{\n\n    int i=1;\n\n    double j=2.0;\n\n    String s=\"xyz\";\n\n\n\npublic void function()\n{\n}\n\n\n\n\n}\n\n我的问题是：假如int是4字节，double是8字节，String是X个字节，请问4,8，X这些内存是连续分配的吗？像数组那样？", "Tag": "算法分析"}
{"Answer": "\nThe problem in your solution is that you are using \"linear probing\" for insert operation, but you are not using the same approach for retrieving it.\nFirst of all - I would change your underlining storage to keep whole struct instead of value:\nvar hasharray [15]Item\n\nSecond, I would change the retrieve method to check value of the item with calculated hash index, and after that iterate items one by one to find actual item if there was a collision:\nfunc retrieve(key string) {\n    index := hashmethod(key)\n    found := false\n    for !found {\n        item:= hasharray[index];\n        if key == item.key {\n         found = true;\n         fmt.Println(index, item)\n        } else if index != size-1 {\n            index++\n        } else {\n            index = 0\n        }\n    }   \n}\n\nSee here: https://play.golang.org/p/8JfTpbJcWx\n", "Konwledge_Point": "线性规划简介", "Question": "使用线性探测解决冲突后，如何从哈希表中检索值？\n\n\n\nI am trying to implement a hash program in go, I did insertion and resolved collisions using linear probing. When I'm trying to retrieve values back, i'm getting different values as I used linear probing to fix collisions.\n\n\n\nThis is my program : \nhttps://play.golang.org/p/7Pmqu6A313\n\n    ", "Tag": "算法分析"}
{"Answer": "本来清明节后工作挺忙的，结果意外的一切正常，上班摸鱼期间看到了你的提问，想尝试用心答一下。你想知道标题的原因？这个原因是想说，照你的理解F检验通过的话，那么4个自变量也应该是显著的对吧。\n首先我想解释下多元回归中F检验的意义，我觉得你可能要先明确这一点，F检验中，我们本身是想让其支持备择假设H1而拒绝H0，但犯第一类错误下拒绝了H0，意味着你只能认定肯定有解释变量X1X2X3X4与Y存在回归关系，因为F检验的H0假设是认为k-1个解释变量都不与y存在回归关系。一般的操作过程是F检验通过后，进一步对各变量做t检验以确定哪些X是重要的解释变量。显然你第一步是成功的，但第二步没有找到一个通过的t。读到此处，我开始质疑你的初始假设条件是否支持你做F检验，即F检验，它可靠吗？标题里是多元回归的内容，下方的各种建模尝试我看到都是在进行线性建模，那么我首先认为你需要做的是多元线性回归。我首先说结论吧，基于你给出的结果，因变量间存在着中度的相关性（0.5其实很高了），也就是犯了多重共线性的问题。\n那么我先尝试不借助任何统计论证去解释你的这个结果。从业务端看这种问题可以猜想是不是你的能力测试间并不相互独立（其实可以简单暴力的归结为聪明人做什么测试都得心应手，而蠢人干什么可能都差点意思），那么毫无疑问测试分数间是有相关性存在的。而且对应你的Y是某项绩效分数，也可以用这样的业务常识去佐证。毕竟优秀的人绩效也不会差，对吧。\n那么为什么会在线性组合之后关系反而弱化了？\n我曾经给同事们设计过一项变态的问卷，那份问卷分AB卷，简单弱化概念就是这份问卷可以真实反映做题人的IQ水平，但A卷是得分越高IQ越高，B卷是得分越低IQ越高（B卷是我小时候看武林外传李大嘴做测试题的灵机一动），虽然我们没有让每一个受试者把AB卷各答一遍，但我们还是拿到了每个人的得分。你可以看到，IQ与A高度正线性相关，IQ与B高度负线性相关，但IQ与A+B的多项式就显得不那么相关了（如果我们真的让每个人都做了A和B）。我想这个例子有助于你的进一步思考。\n接着聊聊统计论证吧。其实在统计学的世界里，回归问题有大量变量间相关，自相关问题多出现在时间序列的分析过程中。在应对这种问题时，因为你的基础假设条件不满足线性回归，也就意味着你的方法其实全部失效了。（很残忍对不对。。。）要想研究这种问题，就必须重新构筑变量，或者重新研判变量间关系，即使牺牲一部分的信息量，也要保证你的多元线性模型能够更好的拟合。（我猜想这部分可能会以EFA过程反驳我，别急，看下去，毕竟我也没看到你的KMO和barrlet不是吗。）写到此处我忽然想起一篇我多年前的学年论文博客，你可以参考下面对线性相关时，如何处理能够使得结果可行。https://blog.csdn.net/lixiaomie01/article/details/80395065针对其中的几个点我想我其实没有给你思路，只是告诉了你我不认可的论点，但是统计论证到此处，我无法站在你不可靠的假设条件下做论证，我更希望你尝试下新的方法吧，box-cox变化下，或者lasso试试。期待你的新结果反馈。", "Konwledge_Point": "线性规划简介", "Question": "R语言多元回归。4个自变量全部不显著。但整体F显著。只需要深度解释原因。不需要任何纠错\n本人初学R语言-海外研究生就读。教授的题目背景是4个不同的能力测试分数作为自变量，1个绩效分数作为因变量。（XY都是score的数字分数）探求哪个能力测试和绩效成绩最相关。100+样本数量\n\n\n多元回归后-出现如标题的问题。教授表示这就是想要同学们探索的问题。\n\n\n查阅资料后，\n怀疑是多重现性或者是残值问题\n-用VIF和一些残值程序-包括数据分布是否正态。数据测试完后-全部没有问题。\n数据分布的很好，无多重现性，也没有残值问题\n。\n\n\n又怀疑是否是这4个因变量之间是否高度相关-\n导致多元回归时候互相抵消了显著性。为此各自做了相关分析，\n4个变量互相之间最高的相关系数也就0.5\n。似乎这个原因站不住脚跟。\n\n\n我突发奇想自己\n组合了4个因变量可能存在的线性组合\n-如123、124、234；23；12、14之类的多元回归。发现每一种回归下-\n各个因变量都显示不同的显著性\n。另外，我还做了\n4个一元回归，全部各自高度显著。\n\n\n这个题目的背景是建立在EFA下的-EFA的结果跑出来建议是4个Factors-正好对应了题目数据里4个能力测试的类别。一共40道题目的分数-所以分成4个因子应该是没问题的（如果能指出倪端，欢迎）\n\n\n本人问题就是想要请求各位帮忙解释这个现象的原因。教授是刻意设置这个结果，\n所以不需要纠错，或者更改某种模型-只希望一个合理的解释-最好联系到背景\n，这4个能力测试的设置是否真的能够预测绩效分数，或者和绩效分数高度相关。所以请求指点一下，\n最好附上一些重要理论或是文献！\n我会深入学习！", "Tag": "算法分析"}
{"Answer": "SVM模型预测解决非线性数据的问题，是通过核函数将非线性数据全部转化成更高维的数据，在更高维度的空间中，使得这些更高维的数据是可以进行线性分类的，从而在实际分类中，其分类原理是首先需要对原始数据进行核函数的变换，根据变换后的数据进行分类判别，最终确定原始数据的所属类别", "Konwledge_Point": "线性规划简介", "Question": "SVM模型预测解决非线性数据的问题，是把数据转化成线性了吗\nSVM模型预测解决非线性数据的问题，是把数据转化成线性了吗？\n比如 我做空气质量指数的预测，我用ARIMA模型做出的空气质量指数的残差，想将非线性残差序列用SVM模型再做一次预测，最终是把非线性数据转成线性的了吗", "Tag": "算法分析"}
{"Answer": "你好，代码供参考：\n% 实验2 \nx = [81, 70, 65, 51, 76,66,90,87,61,77];\nn = length(x);\nx_mean = sum(x)/n%均值，也可以用x_mean = mean(x)\ns = sqrt((sum(x.^2-x_mean^2))/(n-1))%标准差\n\n% 实验4\nt = (1+sqrt(5))/2;\nFk = 1;\nFk_1 = 1;\nk = 2;\nwhile (abs(Fk/Fk_1 -t) > 1e-8 )\n Fk1 = Fk + Fk_1;\n temp = Fk; \n Fk_1 = Fk;\n Fk = Fk1;\nend\nformat long\nerrors = Fk/Fk_1 - t\n% 可以看出相差小于1e-8\n\n结果\nx_mean =\n\n  72.400000000000006\n\n\ns =\n\n  12.112436217008941\n\n\nerrors =\n\n     9.771908393574336e-09\n\n", "Konwledge_Point": "线性规划简介", "Question": "matlab的练习题，数组编程的\n这俩该咋编啊，各位帮忙看看，对于矩阵和数组运算一时半会儿还真转不过来弯，\n\n\n\n", "Tag": "算法分析"}
{"Answer": "a_eq内应该是一个1-3的array,不应该是三个单值,即应该多套一层中括号修改如下:有帮助望采纳\nimport numpy as np\nfrom scipy.optimize import linprog\n\nc = np.array([2, 3, -5])\na_ub = np.array([[-2, 5, -1], [1, 3, 1]])\nb_ub = np.array([-10, 12])\na_eq = np.array([[1, 1, 1]])#注意维度,要多加一个方括号\nb_eq = np.array([7])\nprint(c, a_ub, b_ub, a_eq, b_eq)\n\nret = linprog(-c, A_ub=a_ub, b_ub=b_ub, A_eq=a_eq,\n              b_eq=b_eq, bounds=((0, None), (0, None),(0, None)))#变量有三个,bound要写三个\n\nprint(ret)\nprint(ret.x)  # 表示最优解\nprint(ret.fun)  # 表示最值\n\n", "Konwledge_Point": "线性规划简介", "Question": "用python求线性规划问题，但是提示错误是A_eq必须正好有两个维度，A_eq中的列数必须等于c的大小\n代码是这样的：\n错误提示：A_eq必须正好有两个维度，A_eq中的列数必须等于c的大小\n求解！", "Tag": "算法分析"}
{"Answer": "\nimport numpy as np\nimport csv\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom sklearn.linear_model import LinearRegression\nimport matplotlib\nmatplotlib.rcParams['font.sans-serif'] = ['SimHei']\nmatplotlib.rcParams['font.family']=['sans-serif']\n\ndata = '''battery,KM\n   2,12\n   5,31\n   8,45\n   8,52\n   13,79\n   15,85\n   17,115\n   19,119\n   21,135\n   24,145'''.split('\\n')\nfor i,j in enumerate(data):\n    data[i] = j.replace(' ', '').split(',')\n\nwith  open('LR_data_exam.csv','w') as csvFile: #一行一行地写入到csv文件中\n    writer = csv.writer(csvFile)\n    #先写columns_name\n    writer.writerow(data[0])\n    #写入多行用writerows\n    writer.writerows(data[1:])\n LR_data_exam.csv：\n\n\ndataframe = pd.read_csv(\"LR_data_exam.csv\", sep=\",\")\nx = dataframe['battery'].tolist()\ny = dataframe['KM'].tolist()\n\n# 画出数据的散点图\nfig = plt.figure()\nfig.set_size_inches(10, 4)   # 整个绘图区域的宽度10和高度4\nax = fig.add_subplot(1, 2, 1)  # 整个绘图区分成一行两列，当前图是第一个。\n# 画出原始数据的散点图。\nax.set_title(\"散点图\")\nax.set_xlabel(\"battery\")\nax.set_ylabel(\"KM\")\nax.scatter(x, y)\nplt.show()\n\n\nregressor = LinearRegression()\nregressor = regressor.fit(np.reshape(x,(-1, 1)),np.reshape(y,(-1, 1)))\nprint(regressor.coef_, regressor.intercept_)  # 打印拟合结果(参数)\n\n[[6.28763667]] [-1.19680404]\n\n# 画出数据和拟合直线的图\nplt.scatter(x, y)\nplt.plot(np.reshape(x,(-1,1)), regressor.predict(np.reshape(x,(-1,1))))\nplt.xlabel(\"battery\") \nplt.ylabel(\"KM\") \nplt.title(\"拟合结果\")\nplt.show()\n\n\nprint(regressor.predict([[10], [20], [30]]))  # model.predict预测x为10,20,30时的结果\nfor i in [40,50,60]:\n    print(regressor.coef_*i + regressor.intercept_)   #用拟合参数预测x为40,50,60时的结果\n\n[[ 61.67956266]\n [124.55592935]\n [187.43229605]]\n[[250.30866274]]\n[[313.18502944]]\n[[376.06139613]]", "Konwledge_Point": "线性规划简介", "Question": "python编程 线性回归\n把以下数据制作成csv数据文件,并命名为LR_data_exam.csv。 \n\n对该文件内的数据进行线性回归\n\n画出数据的散点图\n\n建立线性回归模型并拟合\n\n打印拟合结果(参数) \n\n画出数据和拟合直线的图\n\n用model.predict预测x为10,20,30时的结果\n\n用拟合参数预测x为40,50,60时的结果\n\n   battery,KM\n\n   2,12\n\n   5,31\n\n   8,45\n\n   8,52\n\n   13,79\n\n   15,85\n\n   17,115\n\n   19,119\n\n   21,135\n\n   24,145", "Tag": "算法分析"}
{"Answer": "该回答引用GPTᴼᴾᴱᴺᴬᴵ根据你提供的代码和错误信息，很可能是你拼写了错误的变量名或模块名。可以检查以下几个方面：\n检查导入的模块名是否正确，正确的模块名应该是statsmodels.api而不是statzmodels.api。检查是否正确导入了OLS模型，正确的导入方式应该是from statsmodels.regression.linear_model import OLS。检查X_train2和E_train2是否定义正确，如果这些变量没有定义正确，可能会导致错误。\n以下是一个正确的多元线性回归模型构建的例子：\nimport numpy as np\nimport statsmodels.api as sm\n\n# 创建数据\nX = np.random.rand(100, 3)\ny = X.dot([1, 2, 3]) + np.random.randn(100) * 0.5\n\n# 添加常数列1\nX = sm.add_constant(X)\n\n# 将数据集分为训练集和测试集\nX_train, X_test = X[:80], X[80:]\ny_train, y_test = y[:80], y[80:]\n\n# 拟合模型\nmodel = sm.OLS(y_train, X_train).fit()\n\n# 查看模型系数\nprint(model.params)\n\n\n\n该例子创建了一个包含3个特征的数据集，使用add_constant函数添加了常数列1，将数据集分为训练集和测试集，然后使用OLS函数拟合了一个多元线性回归模型，并查看了模型的系数。", "Konwledge_Point": "线性规划简介", "Question": "构建多元线性回归模型\n构建多远线性回归模型的时候报错了 如图。\n\n\n怎么修改这个错误\n谢谢各位解答", "Tag": "算法分析"}
{"Answer": "Earth Engine 有几种使用减速器执行线性回归的方法：\nee.Reducer.linearFit()ee.Reducer.linearRegression()ee.Reducer.robustLinearRegression()ee.Reducer.ridgeRegression()最简单的线性回归缩减器是linearFit()计算一个具有常数项的变量的线性函数的最小二乘估计。要获得更灵活的线性建模方法，请使用允许可变数量的自变量和因变量的线性回归缩减器之一。linearRegression()实现普通最小二乘回归（OLS）。robustLinearRegression()使用基于回归残差的成本函数来迭代地减轻数据中的异常值 ( O'Leary, 1990 )。 ridgeRegression()使用 L2 正则化进行线性回归。非现象模型我之前也没做过，不知道如何进行。有一个时间序列拟合的函数：ee.Algorithms.TemporalSegmentation.LandTrendrFit(timeSeries, vertices, spikeThreshold, minObservationsNeeded)使用一组LandTrendr断点年份对时间序列进行插值。对于时间序列中的每个输入带，输出一个新的一维数组值带，其中包含由顶点图像识别的断点时间之间的输入值插值。更多细节见LandTrendr算法。Interpolates a time series using a set of LandTrendr breakpoint years. For each input band in the timeSeries, outputs a new 1D array-valued band containing the input values interpolated between the breakpoint times identified by the vertices image. See the LandTrendr Algorithm for more details.\nArguments:timeSeries (ImageCollection):Time series to interpolate.要内插的时间序列影像。vertices (Image):Vertices image. A 1D array of LandTrendr breakpoint years.顶点图像。LandTrendr断点年份的一维数组spikeThreshold (Float, default: 0.9):Threshold for dampening input spikes (1.0 means no dampening).阈值设置minObservationsNeeded (Integer, default: 6):Min observations needed.需要的最小观测值Returns: Image", "Konwledge_Point": "线性规划简介", "Question": "构建LST-NDVI非线性回归模型\n您好,看了下您的一些关于线性回归的文章, 请教一下非线性的模型要如何构建呀", "Tag": "算法分析"}
{"Answer": "int x会越界，循环到第三次x*16807会超出int范围", "Konwledge_Point": "线性规划简介", "Question": "正数乘正数后取余为什么结果有负数\n本人用线性同余法编写了一个产生0,1之间均匀分布的随机数程序，明明都是正数和正数相乘，但结果却含有负值，始终搞不明白为什么，求指点。谢谢\n\n\n#\ndefine\n _CRT_SECURE_NO_WARNINGS\n\n\n#\ninclude\n \n\n\n\nusing\n \nnamespace\n std;\n\nvoid\n \nmain\n()\n\n\n{   \n\n    FILE*fp;\n    fp = \nfopen\n(\n\"myrandom.txt\"\n, \n\"w\"\n);\n    \nif\n (fp != \nNULL\n)\n    { \n    \ndouble\n n;\n    \ndouble\n ex=\n0\n;\n    \ndouble\n x0;\n    cout << \n\"请输入要产生的随机数个数\"\n;\n    cin >> n;\n    cout << \n\"请输入初始种子\"\n;\n    cin >> x0;\n    \nint\n x = x0;\n    \ndouble\n k = \n0\n;\n    \nfor\n (\nint\n i = \n0\n; i < n; i++)\n    {\n        \n        x = (x * \n16807\n) % \n2147483647\n;\n//进行线性同余的计算\n\n        \ndouble\n m = x / \n2147483607.0\n;\n        k = k + m;\n        \nfprintf\n(fp, \n\"%10.8f \"\n, m);\n        cout << endl;\n    }\n    ex = k / n;\n}\n\n\n\n\n\n\n在某一次运算时x就变为负的了！\n\n", "Tag": "算法分析"}
{"Answer": "echarts 应该可以吧", "Konwledge_Point": "线性规划简介", "Question": "请问vue怎么写线性图标\n就是在vue项目中怎么写如下图的线性图表呢？百度了很久都没有相关的代码，哪位有写过相关的帮一下，万分感谢\n\n", "Tag": "算法分析"}
{"Answer": "参考GPT和自己的思路，ARIMA-GARCH和SVM是两种不同类型的模型，ARIMA-GARCH是时间序列模型，而SVM是非线性回归模型。通常情况下，这些模型不能直接组合在一起，因为它们所涉及的数据和方法有很大的差异。\n一种可能的方法是使用多个模型进行预测，并将它们的结果组合在一起。例如，您可以使用ARIMA-GARCH模型来预测时间序列数据中的波动性，并使用SVM模型来预测非线性趋势。然后，您可以将两种模型的预测结果结合在一起，以获得最终的预测结果。\n另一种方法是使用混合模型，即将ARIMA-GARCH模型和SVM模型的某些特性结合在一起，以获得更准确的预测。例如，您可以将ARIMA-GARCH模型的波动性预测结果作为SVM模型的输入特征，或者将SVM模型的非线性预测结果作为ARIMA-GARCH模型的输入特征。\n需要注意的是，这些方法需要对数据进行适当的预处理和参数调整，以确保模型的准确性和可靠性。因此，在使用这些组合模型之前，您需要深入了解这些模型以及如何适应您的数据和问题。将线性模型和非线性模型组合可以采用集成学习的思想，常见的方法包括Bagging、Boosting、Stacking等。对于arima-garch和svm组合模型，可以考虑使用Stacking方法。\n具体地，可以先将arima-garch和svm分别作为基模型进行训练，然后使用另一个模型作为元模型对基模型的预测结果进行组合。在这个例子中，我们使用svm作为基模型1，arima-garch作为基模型2，使用线性回归作为元模型进行组合。\n以下是R语言的示例代码：\nlibrary(forecast)\nlibrary(rugarch)\nlibrary(e1071)\n\n# 生成时间序列数据\nset.seed(123)\ny <- arima.sim(list(ar = 0.8), n = 100)\n\n# 划分训练集和测试集\ntrain <- y[1:80]\ntest <- y[81:100]\n\n# 训练arima-garch模型\nfit.arima <- auto.arima(train)\nfit.garch <- ugarchspec(mean.model = list(armaOrder = c(0,0)), variance.model = list(garchOrder = c(1,1)), data = train) \nfit.garch <- ugarchfit(fit.garch, data = train)\n\n# 训练svm模型\nfit.svm <- svm(train ~ seq_along(train), kernel = \"radial\")\n\n# 对测试集进行预测\npred.arima <- forecast(fit.arima, h = length(test))$mean\npred.garch <- predict(fit.garch, n.ahead = length(test))$forecast[,1]\npred.svm <- predict(fit.svm, data.frame(seq_along(test)))\n\n# 将预测结果组合起来\ndata.comb <- data.frame(pred.arima, pred.garch, pred.svm)\nfit.comb <- lm(test ~ ., data = data.comb)\npred.comb <- predict(fit.comb, data.comb)\n\n# 计算组合模型的预测误差\nmse.comb <- mean((pred.comb - test)^2)\nmse.arima <- mean((pred.arima - test)^2)\nmse.garch <- mean((pred.garch - test)^2)\nmse.svm <- mean((pred.svm - test)^2)\n\n# 输出结果\ncat(\"ARIMA MSE:\", mse.arima, \"\\n\")\ncat(\"GARCH MSE:\", mse.garch, \"\\n\")\ncat(\"SVM MSE:\", mse.svm, \"\\n\")\ncat(\"Combined MSE:\", mse.comb, \"\\n\")\n\n\n在这个例子中，我们首先生成一个AR(1)时间序列，并将前80个点作为训练集，后20个点作为测试集。我们分别训练了一个ARIMA模型、一个GARCH模型和一个SVM模型，并对测试集进行预测。然后，我们将三个模型的预测结果组合在一起，使用线性回归作为元模型进行组合。最后，我们计算了组合模型和单独的三个基模型的预测误差，并输出了结果。", "Konwledge_Point": "线性规划简介", "Question": "线性和非线性模型如何组合在一起\n做arima-garch和svm组合模型，不太理解这个怎么组合", "Tag": "算法分析"}
{"Answer": "这是常数变易法.", "Konwledge_Point": "线性规划简介", "Question": "非齐次线性微分方程组\n这个方程组怎么得出来的，非常迷惑\n关于解决非齐次线性微分方程组的问题", "Tag": "算法分析"}
{"Answer": "\nHere is one solution\n# GET EQUATION AND R-SQUARED AS STRING\n# SOURCE: http://goo.gl/K4yh\n\nlm_eqn <- function(df){\n    m <- lm(y ~ x, df);\n    eq <- substitute(italic(y) == a + b %.% italic(x)*\",\"~~italic(r)^2~\"=\"~r2, \n         list(a = format(coef(m)[1], digits = 2), \n              b = format(coef(m)[2], digits = 2), \n             r2 = format(summary(m)$r.squared, digits = 3)))\n    as.character(as.expression(eq));                 \n}\n\np1 <- p + geom_text(x = 25, y = 300, label = lm_eqn(df), parse = TRUE)\n\nEDIT. I figured out the source from where I picked this code. Here is the link to the original post in the ggplot2 google groups\n\n", "Konwledge_Point": "线性规划简介", "Question": "如何在图上增加回归直线方程和R^2？\n\n\n\n我想知道如何在 ggplot 上加上回归线方程和R^2。代码如下：\n\n\n\nlibrary(ggplot2)\ndf <- data.frame(x = c(1:100))\ndf$y <- 2 + 3 * df$x + rnorm(100, sd = 40)\np <- ggplot(data = df, aes(x = x, y = y)) +\n            geom_smooth(method = \"lm\", se=FALSE, color=\"black\", formula = y ~ x) +\n            geom_point()\np\n\n\n\n\n任何帮助我都感激不尽。\n\n    \n\n\n\n转载于:https://stackoverflow.com/questions/7549694/adding-regression-line-equation-and-r2-on-graph", "Tag": "算法分析"}
{"Answer": "因为两种写法并不是等价的。\n        if(H->Cells[ind].Info == Legitimate){ //就是这里\n            if(H->Cells[ind].Data == Key){//还有这里\n                return ind;\n            }\n        }\n\n这里实际包含了另一个条件，就是内层的if如果没满足，还有else，而这个else是直接返回ERROR。而下面的写法，实际是把条件限定更加严格。\n        if(H->Cells[ind].Info == Legitimate && H->Cells[ind].Data == Key){//就是这里\n            return ind;\n        }\n\n就是必须满足两个条件才返回ind，不满足则进入else，忽略了进入ERROR的条件。所以程序上面才是正确的。如有帮助，希望采纳一下", "Konwledge_Point": "线性规划简介", "Question": "PTA习题问题，离大谱了\n浙大版《数据结构（第2版）》题目集\n习题5.10 线性探测法的查找函数 (20 分)\n把两个if条件写开就答案正确\n\n\nPosition \nFind\n( HashTable H, ElementType Key )\n{\n    Position ind;\n    \nint\n \ncount\n = \n0\n;\n    \n//循环表长长度\n\n    \nwhile\n(\ncount\n < H->TableSize){\n        \n//获取Key第一次在的位置\n\n        ind = Hash(Key +\ncount\n,H->TableSize);\n        \nif\n(H->Cells[ind].Info == Legitimate){ \n//就是这里\n\n            \nif\n(H->Cells[ind].Data == Key){\n//还有这里\n\n                \nreturn\n ind;\n            }\n        }\nelse\n{\n            \nreturn\n ind;\n        }\n        \ncount\n++;\n    }\n    \nreturn\n ERROR;\n}\n\n\n\n把if的两个条件写在一起，结果就是部分正确\n\n\nPosition \nFind\n( HashTable H, ElementType Key )\n{\n    Position ind;\n    \nint\n \ncount\n = \n0\n;\n    \n//循环表长长度\n\n    \nwhile\n(\ncount\n < H->TableSize){\n        \n//获取Key第一次在的位置\n\n        ind = Hash(Key +\ncount\n,H->TableSize);\n        \nif\n(H->Cells[ind].Info == Legitimate && H->Cells[ind].Data == Key){\n//就是这里\n\n            \nreturn\n ind;\n        }\nelse\n{\n            \nreturn\n ind;\n        }\n        \ncount\n++;\n    }\n    \nreturn\n ERROR;\n}\n\n", "Tag": "算法分析"}
{"Answer": "用循环不断比较每个节点的值，如果找到最大值，则记录这个值及其节点，循环结束把尾结点的值和最大值节点的值互换即可，代码如下：\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef int datatype ;\n\nstruct node{\n    datatype data;\n    node * link;\n}; \n\nint main(void){\n    \n    node * list,* tmp,*pre=NULL;\n        \n    int i=0;\n//创建测试链表节点的测试数据\n    while(i<5){\n        \n        \n        printf(\"请输入链表第%d个节点的值：\",i+1);\n        \n    \n        tmp = (node*)malloc(sizeof(node));\n        if(pre!=NULL){\n            pre->link = tmp;\n        }\n        \n        if(i==0){\n            list = tmp;\n        }\n    \n        scanf(\"%d\",&tmp->data);    \n        tmp->link = NULL;        \n        pre = tmp;\n                \n        i++;\n    }\n    \n    //打印移动前，链表各节点的值 \n    printf(\"移动最大值前链表各节点的值为：\\n\");\n    tmp = list;\n    while(tmp!=NULL){\n        printf(\"%d \",tmp->data,tmp->link);\n        tmp = tmp->link;\n    }\n    printf(\"\\n\");\n    \n    \n    tmp = list;\n    int max=tmp->data;  //把链表节点最大值赋值为链表节点第一个值 \n    node* maxList=tmp,tmp2;   //最大值节点也赋值为链表第一个节点 \n//    printf(\"0\\n\");\n    //i=0;\n    while(tmp!=NULL){\n    \n        //printf(\"0,tmp->data=%d,tmp->link=%p\\n\",tmp->data,tmp->link);    \n  //如果链表节点当前最大值小于当前节点的值，则把最大值赋值为当前节点的值，最大值节点也赋值为当前节点         \n        if(max<tmp->data){ \n        //    printf(\"tmp->data=%d,max=%d\\n\",tmp->data,max);\n            max = tmp->data;\n            maxList = tmp;\n            \n        }\n    //    i++;\n    //    printf(\"i=%d\\n\",i);\n        pre = tmp;  //记录当前节点，以便循环结束记录到链表节点的尾结点 \n        tmp = tmp->link;\n    }\n    \n//    printf(\"1-1,maxList=%p,pre=%p\\n\",maxList,pre);\n    maxList->data = pre->data; //把最大值节点的值赋值为尾结点的值 \n    pre->data = max;  //把尾结点的值赋值为最大值节点的值，实现把最大值移到节点的最后面的目的 \n    \n    //打印移动后的结果 \n    printf(\"移动最大值后链表各节点的值为：\\n\");\n    tmp = list;\n    while(tmp!=NULL){\n        printf(\"%d \",tmp->data);\n        tmp = tmp->link;\n    }\n    printf(\"\\n\");\n    \n    \n    return 0; \n    \n}\n\n", "Konwledge_Point": "线性规划简介", "Question": "最大值移动到最后的线性链表的结点移动\n已知非空线性链表第1个链结点指针为list，链结点构造为\nstruct node{\ndatatype data;\nnode *link;\n};\n请写一算法，将该链表中数据域值最大的那个点移到链表的最后面。（假设链表中数据域值最大的链结点惟一）（注意：要求先写出算法的解题思路，然后再写出算法）", "Tag": "算法分析"}
{"Answer": "左右移项，然后缩小矩阵，继续linalg.solve()", "Konwledge_Point": "线性规划简介", "Question": "如何在已知部分解的情况下，求解线性方程组？\n在求解线性方程组时，将线性方程组组装成矩阵形式，可以通过numpy.linalg.solve()直接给出结果。\n但如果已知部分解的情况下，如何得到该情况下线性方程组的解？", "Tag": "算法分析"}
{"Answer": "是2x^3+4x^2+3x+6=0吧？\n#include<stdio.h>\n#include <math.h>\nfloat f(float x)                   \n{\n    return 2*pow(x,3) + 4*pow(x,2)+3*x+6;\n}\n\nfloat newx(float x1, float x2)    \n{\n    float x;\n    x = (x1*f(x2) - x2*f(x1)) / (f(x2) - f(x1));\n    return x;\n}\n\nfloat root(float x1, float x2)        \n{\n    float x, y, y1;\n    y1 = f(x1);                      \n    for(y = y1; fabs(y) >= 1e-6; )\n    {\n        x = newx(x1, x2);           \n        y = f(x);                 \n\n        if(y*y1 > 0)            \n        {\n            y1 = y;\n            x1 = x;\n        }\n        else\n        {\n            x2 = x;                    \n        }\n    }\n    return x;\n}\n\nint main()\n{\n    float x;\n    x = root(0,3);\n    printf(\"%.2f\",x);\n    return 0;\n}\n\n", "Konwledge_Point": "线性规划简介", "Question": "用弦解法求非线性方程\n用弦截法求非线性方程2\n3-4\n2+3x-6=0在区间[0,3]的一个实根，精度为10-6。", "Tag": "算法分析"}
{"Answer": "基于Monster 组和GPT的调写：在Matlab中进行周期函数简单线性拟合，可以使用Matlab中的polyfit函数。该函数可以对给定的一组数据点进行线性拟合，并返回拟合的系数。\n假设有一个周期函数的数据点，可以先通过找到峰值点确定一个周期。然后，将数据点按周期分段，对每个段进行拟合。可以使用Matlab中的mod函数将数据点按周期分段，然后分别对每个段使用polyfit函数进行拟合。最后，将所有段的拟合结果合并起来即可得到周期函数的简单线性拟合。\n以下是一个示例代码，假设数据点为x和y，周期为period，峰值点为peak：\n% 计算周期起始点\nstart = peak - floor(period/2);\n\n% 按周期分段\nnum_periods = floor(length(x)/period);\nsegments = cell(1,num_periods);\nfor i = 1:num_periods\n    indices = start + (1:period) + (i-1)*period;\n    segments{i} = [x(indices); y(indices)];\nend\n\n% 对每个段进行拟合\ncoeffs = cell(1,num_periods);\nfor i = 1:num_periods\n    segment = segments{i};\n    p = polyfit(segment(1,:), segment(2,:), 1);\n    coeffs{i} = p;\nend\n\n% 合并拟合结果\nall_coeffs = [coeffs{:}];\na = all_coeffs(1:2:end);\nb = all_coeffs(2:2:end);\nx_fit = linspace(min(x), max(x), 100);\ny_fit = zeros(size(x_fit));\nfor i = 1:num_periods\n    indices = (i-1)*period+1:i*period;\n    y_fit(indices) = a(i)*x(indices) + b(i);\nend\n\n% 绘制拟合结果\nplot(x, y, 'o', x_fit, y_fit);\n\n\n在上面的代码中，首先计算了每个周期的起始点，并将数据点按周期分段。然后，对每个段使用polyfit函数进行线性拟合，并将拟合结果保存在coeffs变量中。最后，将所有拟合结果合并起来，得到整个周期函数的拟合结果。最后，将数据点和拟合结果绘制在同一张图上，以便比较。", "Konwledge_Point": "线性规划简介", "Question": "matlab如何进行周期函数简单线性拟合\nmatlab如何进行周期函数简单线性拟合？\n已有如下图数据及周期峰值点，如何进行分段拟合？并按周期重复\n\n", "Tag": "算法分析"}
{"Answer": " 参考这个链接里的文章：\n一文教你全面掌握用Python实现线性回归 - 知乎\n全文共 4968字，预计学习时长15分钟或更长 本文旨在为读者理解和应用线性回归时提供参考。虽然线性回归算法很简单，但是只有少数人能真正理解其基本原则。 本文首先会深入挖掘线性回归理论，理解其内在的工作机制…\n\n\n\nhttps://zhuanlan.zhihu.com/p/75412836\n\n", "Konwledge_Point": "线性规划简介", "Question": "求..如何使用python 线性回归参数来预测保险费随年龄的变化\n包含显示线性回归参数（斜率和偏差）\n        可视化线性回归线如何拟合数据 ", "Tag": "算法分析"}
{"Answer": "B变量看起来不是每次都清空，建议\n...\nfor i=1:floor(a/20) %根据步进的循环数自行调整\nB=zeros(10,b);\nB(:,:)=A(20*(i-1)+1:20*(i-1)+10,:);%挑选出的加载段数据赋值给B\n...\n\n这样的话应该是每段拟合。我觉得这是每次都截取10行，拟合不好是因为带上了上次的数据，局部线性，好几个局部在一起就不线性了。", "Konwledge_Point": "线性规划简介", "Question": "数据线性拟合结果与实际情况不符，越来越偏。\n问题遇到的现象和发生背景\n\n\n问题背景：从txt中循环取出数据即每隔几行取几行，并将取出的数据线性拟合。\n问题现象：数据挑选没问题，但是循环程序输出的拟合优度越来越差，从0.99几到0.7几递减。如果将拟合度差的那段数据单独挑出来拟合，数据点又呈很好的线性分布，拟合优度也非常好能达到0.99多。\n\n\n问题相关代码，请勿粘贴截图\n\n\nclear all;\n\nA\n=importdata( \n'test.txt'\n);\n[a,b]=size(A);%识别A的行数；\nD1=[];%输出加载段斜率、截距、拟合优度\nD2=[];%输出卸载段斜率、截距、拟合优度\n\nfor\n \ni\n=1:floor(a/20) %根据步进的循环数自行调整\nB(10*(i-1)+1:10*(i-1)+10,:)=A(20*(i-1)+1:20*(i-1)+10,:);%挑选出的加载段数据赋值给B\n\nx1\n=B(:,2);%应变\n\ny1\n=B(:,7);%荷载 \n\np1\n=polyfit(x1,y1,1);\n\nc1\n=p1(:,1);\n\nd1\n=p1(:,2);%把拟合后一次函数的系数提取出来，以回归拟合后的y值\n\nR1\n=1 - (sum(((c1*x1+d1)- y1).^2) / sum((y1 - mean(  y1)).^2));\nC1=[p1,R1];\nD1=[D1;C1];\nE(10*(i-1)+1:10*(i-1)+10,:)=A(20*(i-1)+11:20*(i-1)+20,:);%挑选出的卸载段数据赋值给E\n\nx2\n=E(:,2);\n\ny2\n=E(:,7);\n\np2\n=polyfit(x2,y2,1);\n\nc2\n=p2(:,1);\n\nd2\n=p2(:,2);%把拟合后一次函数的系数提取出来，以回归拟合后的y值\n\nR2\n=1 - (sum(((c2*x2+d2)- y2).^2) / sum((y2 - mean(y2)).^2));\nC2=[p2,R2];\nD2=[D2;C2];\nend\n\nm\n=D1(:,1);\n\nn\n=D2(:,1);\n\no\n=m./n;\n\n\n\n\n\n我想要达到的结果\n\n\n期望拟合结果能跟实际对应上。", "Tag": "算法分析"}
{"Answer": "参考GPT和自己的思路：\n求解四阶非线性微分方程一般需要使用数值方法，例如有限差分法、有限元法等。由于你提到了反散射方法，可能可以考虑一些基于反演算法的数值求解方法。具体的方法选择需要根据具体的微分方程形式和边界条件来确定。\n另外，需要注意的是，非线性微分方程的求解一般比较困难，往往需要结合一些数值计算软件或者编程语言来实现。如果你对数学建模或者程序设计不是很熟悉，可能需要寻求专业人士的帮助。", "Konwledge_Point": "线性规划简介", "Question": "求解四阶非线性微分方程\n四阶的非线性微分方程怎么求解啊，有两个边界条件。今天看到反散射方法求Kdv孤立子方程，和我要求的偏微分方程很像，但还是求不出来", "Tag": "算法分析"}
{"Answer": "参考：\n\n#include \"stdio.h\"\n\n#define N 2\nstruct student{\n    int id;\n    char name[20];\n    int kaoqun;\n    int biaoxian;\n    int zuoye;\n    int biji;\n    int sum;\n}stud[N],t;\n\nint main()\n{\n    int i,j;\n    for(i=0;i<N;i++){\n        printf(\"请输入第%d个学生信息\\n\",i+1);\n        scanf(\"%d %s\",&stud[i].id,&stud[i].name);\n        fflush(stdin);\n        scanf(\"%d %d %d %d\",&stud[i].kaoqun,&stud[i].biaoxian,&stud[i].zuoye,&stud[i].biji);\n        stud[i].sum = stud[i].kaoqun*0.3+stud[i].biaoxian*0.3+stud[i].zuoye*0.3+stud[i].biji*0.1;\n    }\n    \n    //排序\n    \n    for (i = 0; i < N - 1; i++){\n        for (j = 0; j < N - 1 - i; j++){ //按成绩对学生信息进行排序\n            if (stud[j].sum > stud[j + 1].sum){ //整型数字的比较\n                t = stud[j];\n                stud[j] = stud[j + 1];\n                stud[j + 1] = t;\n            }\n        }\n    }\n    //打印\n    printf(\"学号\\t姓名\\t考勤\\t表现\\t作业\\t笔记\\t总分\\t\\n\");\n    for (i = 0; i < N; i++){\n        printf(\"%d\\t\", stud[i].id);\n        printf(\"%s\\t\", stud[i].name);\n        printf(\"%d\\t\", stud[i].kaoqun);\n        printf(\"%d\\t\", stud[i].biaoxian);\n        printf(\"%d\\t\", stud[i].zuoye);\n        printf(\"%d\\t\", stud[i].biji);\n        printf(\"%d \\n\", stud[i].sum);\n    }\n    \n    return 1;\n}\n", "Konwledge_Point": "线性规划简介", "Question": "文件操作+线性链表+冒泡排序实验室\n文件操作+线性链表+冒泡排序实验室。现有结构体定义如下：struct stuInfo{    char id[12];            //数据成员    char name[15];    float score;    struct stuInfo *next;   //指针成员};任务及要求：（1）首先完成线性链表的定义和创建，确保链表的第一个节点为哨兵节点，不存放有效的数据；（2）利用文件的相关操作，动态开辟节点存储空间，将存放在磁盘某个路径中的文件“stuinfo.txt”信息逐条读入，并依次存入到线性链表的每个节点中，信息如下；00001 张三 10000002 李四 9900003 王五 10000004 王六 8900005 江涛 9800006 陈琪 8800007 祁廷 91（3）接下来，将学号为‘00004’的节点删除；（4）再接下来，利用冒泡排序，对链表继续升序排序；（5）将完整的线性链表信息从头到尾依次存储到磁盘某个路径下的“score.txt”文件中，存储格式和“stuinfo.txt”文件相同。\n哪个大佬救救孩子吧 😭", "Tag": "算法分析"}
{"Answer": "很可能是matlab的版本问题，检查一下版本的兼容性。", "Konwledge_Point": "线性规划简介", "Question": "matlab App Designer报错“结构体内容引用自非结构体数组对象”\ngithub上fork的matlab代码，但是无法查看源代码\n\n\nGitHub项目地址\nhttps://github.com/NathanJustus/VideoVibrometry_MatlabApp\n\n\n报错\n\n\n\n\n运行报错\n\n\n\n\nmatlab刚接触，求各位指点\n\n\n万分感谢", "Tag": "算法分析"}
{"Answer": "这个是求最小值，所以程序结果没问题。你说的0.5-1 之间，应该是求最大值把。如果你要最大值，可以加个负号。\n\ndef demo_func(x):\n    # Sphere\n    x1=x\n    return -((10-4*x1)/(4*x1+3))*x1\nfrom sko.PSO import PSO\npso = PSO(func=demo_func, n_dim=1, pop=40, max_iter=150, lb=[0], ub=[10], w=0.8, c1=0.5, c2=0.5)\npso.run()\nprint('best_x is ', pso.gbest_x, 'best_y is', -pso.gbest_y)\nimport matplotlib.pyplot as plt\nplt.plot(pso.gbest_y_hist)\nplt.show()\n这是结果：\n", "Konwledge_Point": "线性规划简介", "Question": "如何使用sko PSO 包进行粒子群算法优化（python,PSO ）\n我想使用这个包进行单目标优化:\n\n\n\nhttps://github.com/guofei9987/scikit-opt\n\n\n\n目标函数为 y=((10-4x)/(4x+3))*x\n\n\n\n但是我用与例子类似的代码时却获得错误答案\n\n\n\n代码如下：\n\n\n\ndef demo_func(x):\n\n    # Sphere\n\n    x1= x\n\n    return ((10-4*x1)/(4*x1+3))*x1\n\nfrom sko.PSO import PSO\n\npso = PSO(func=demo_func, n_dim=1, pop=40, max_iter=150, lb=[0], ub=[10], w=0.8, c1=0.5, c2=0.5)\n\npso.run()\n\nprint('best_x is ', pso.gbest_x, 'best_y is', pso.gbest_y)\n\n\n\nimport matplotlib.pyplot as plt\n\n\n\nplt.plot(pso.gbest_y_hist)\n\nplt.show()\n\n\n\n输出是这样的：\n\n\n\nbest_x is  [10.] best_y is [-6.97674419]\n\n\n\n事实上这是个错误的答案， 因为通过函数图像我们可以看到正确的答案位于0.5和1之间。\n\n\n\n想求教各位大佬想要获得 正确的 答案y应该怎么写", "Tag": "算法分析"}
{"Answer": "你好同学，python里面的numpy在生成2维矩阵的时候不能只写一个维度的大小值，另外一个维度也要写\nimport numpy\na = numpy.random.rand(50,50)\nb = numpy.linalg.det(a)\n\n这样就有结果了，比如我这里有个随机结果\n", "Konwledge_Point": "线性规划简介", "Question": "Matlab ipython线性代数\n\n\n第32题怎么用ipython做？\n我写的是\na = numpy.random.rand(50)\nb = numpy.linalg.det(a)\n但是报错1-dimensional array given. Array must be at least two-dimensional", "Tag": "算法分析"}
{"Answer": "线性调频脉冲信号可以采用和差波束原理进行测角。\n和差波束原理是一种通过将多个天线的信号进行加权相加或相减来形成不同方向的波束的方法。当两个或更多的天线接收到同一个信号时，它们会产生相位差异，这可以通过改变天线之间的距离或方向来实现。通过调整相位差异，可以使得某个方向上的信号强度最大，从而实现测角。\n对于线性调频脉冲信号，可以使用和差波束原理来实现测角。首先，将接收到的信号分别输入到不同的天线中。然后，将这些信号进行加权相加或相减，以产生一个特定方向上的波束。通过改变权重系数，可以得到不同方向的波束。最后，通过检测不同方向上的波束强度，可以确定信号来自哪个方向。\n需要注意的是，线性调频脉冲信号的测角精度受到多个因素的影响，如信号频率、天线之间的距离和方向、以及接收到的噪声水平等。因此，在实际应用中，需要进行适当的调整和校准，以获得最佳的测角精度。", "Konwledge_Point": "线性规划简介", "Question": "请问线性调频脉冲信号可以采用和差波束原理进行测角吗\n请问线性调频脉冲信号可以采用和差波束原理进行测角吗？和差波束如何测角？", "Tag": "算法分析"}
{"Answer": "每行最后一个不为零其它全为零则假，否则真。\nimport numpy as np\n\ndef judge(A):    \n    res = np.nonzero(A)\n    a = map(tuple, np.transpose(res).tolist())\n    m,n=np.shape(A)\n    all_l = [(i,n -1) for i in range(m)]\n    for i in a:\n        if i not in all_l:\n            return True\n    return False\nif __name__ == '__main__':\n    res = judge([[0,0,0], [0, 1, 2], [0, 0, 0]])\n    print(res)\n", "Konwledge_Point": "线性规划简介", "Question": "python线性代数的办法\npython 通过numpy nonzero方法判断一个矩阵是否是不一致的,以下是我目前的想法,\n用nonzero可以判断是否是零,如果最后一行最后一列的那个数字为0,且之前的不为0那么就可以判断他是不一致的,但是不知道该如何写出代码.", "Tag": "算法分析"}
{"Answer": "```\r\n#include \r\n#include \r\n#define MAX_N 20\r\nint main()\r\n{\r\n    int arr[MAX_N][MAX_N],n;\r\n    memset(arr,0x0,sizeof(arr));\r\n    scanf(\"%d\",&n);\r\n    for(int i=0;i<n;i++)\r\n        for(int j=0;j<n;j++)\r\n            scanf(\"%d\",&arr[i][j]);\r\n    int sum = 0;\r\n    for(int i=0;i<n;i++)\r\n        for(int j=0;j<n;j++)\r\n        {\r\n            if(i == j)\r\n                sum += arr[i][j];\r\n            else if(i == ((n-1)-j))\r\n                sum += arr[i][j];\r\n        }\r\n    printf(\"%d\\n\",sum);\r\n    return 0;\r\n}\r\n```", "Konwledge_Point": "线性规划简介", "Question": "C语言关于数组循环的问题\n\n[题目描述]\n\n在线性代数中，矩阵的计算是一种常见运算。在程序设计中矩阵常用二维数组表示，现在，给你一个N x N的方阵，请编程计算矩阵中两条对角线上元素的和。\n\n[输入]\n\n有多行，第一行是一个正整数N (N<20)，表示矩阵的行数和列数，后面N行每行N个整数\n\n[输出]\n\n一个整数，表示矩阵对角线上元素的和\n\n[样例输入]\n\n4\n\n1 2 3 4\n\n5 6 7 8\n\n4 3 2 1\n\n3 4 5 6\n\n[样例输出]\n\n32", "Tag": "算法分析"}
{"Answer": "一般来说是不需要的。但有些情况下如果Y值比较大且是非负的，可以对其做对数运算，对logY做预测，最后再做逆运算即可", "Konwledge_Point": "线性规划简介", "Question": "是否需要对真实值Y标准化\n在回归模型训练中，我们需要对输入x做标准化。需要对真实值y也做标准化吗？", "Tag": "算法分析"}
{"Answer": "看图标可以知道，局部线性回归是用于三维数据的", "Konwledge_Point": "线性规划简介", "Question": "MATLAB曲线拟合器选择拟合类型选不了局部线性拟合\n这是导入的数据\n打开后其他的都能用，就局部线性回归模型用不了，我想问问是为什么😢\n用的版本是2022b", "Tag": "算法分析"}
{"Answer": "入门的话不用，想深入研究就要哦", "Konwledge_Point": "线性规划简介", "Question": "想学机器学习一定得先去学线性代数这本书吗？\n目前大一新生，有自学python基础，现在想学机器学习一定得先去学线性代数这本书吗？", "Tag": "算法分析"}
{"Answer": "参考GPT和自己的思路：\n对于您的问题，可以使用插值函数进行二维线性插值。以下是一份Python代码，可以根据您提供的原始数据进行线性插值并绘制图像：\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.interpolate import interp2d\n\n# 构造原始数据\nx = [0, 91, 182, 273, 364, 455, 546, 637]\ny = [0, 91, 182, 273, 364, 455, 546]\nz = [[15,    15, 14, 18, 24, 24, 20, 17],\n     [17,    16, 15, 18, 23, 23, 19, 17],\n     [17,    16, 15, 18, 21, 21, 18, 16],\n     [0,     0,  14, 0,  21, 0,  18, 0],\n     [0,     0,  14, 0,  23, 0,  18, 0],\n     [0,     0,  14, 0,  23, 0,  19, 0],\n     [0,     0,  15, 0,  23, 0,  19, 0]]\n\n# 构建二维线性插值函数\nf = interp2d(x, y, z, kind='linear')\n\n# 构建新的 x,y 范围\nx_new = np.arange(0, 638)\ny_new = np.arange(0, 547)\n\n# 进行插值\nz_new = f(x_new, y_new)\n\n# 绘制插值后的图像\nplt.imshow(z_new, cmap='hot', interpolation='nearest')\nplt.show()\n\n注：请确保安装有NumPy和Matplotlib包。", "Konwledge_Point": "线性规划简介", "Question": "二维矩阵线性插值问题 python\n我有一串气温资料，要用线性插值找出其他时间点的气温，要怎么做\n我想把这资料做完线性插值弄成图片\n以下是我网上找来找去的自己打出来的，还是有错\n\n\nimport\n numpy as np\n\nfrom\n scipy.interpolate import interp2d\n\nfrom\n scipy.interpolate import griddata\n\n# 創建一個547*638的矩陣\n\n\nmatrix\n = np.zeros((\n547\n, \n638\n))\n\n\n\n# 定義矩陣大小\n\n\nrows\n, cols = \n547\n, \n638\n\n\n# 創建一個新的空矩陣\n\n\nmatrix_new\n = np.zeros((rows, cols))\n\n\n# 填充矩陣 設定氣溫\n\n\n\nmatrix\n[\n0\n,\n0\n]=\n15\n\n\nmatrix\n[\n0\n,\n91\n]=\n15\n\n\nmatrix\n[\n0\n,\n182\n]=\n14\n\n\nmatrix\n[\n0\n,\n273\n]=\n18\n\n\nmatrix\n[\n0\n,\n364\n]=\n24\n\n\nmatrix\n[\n0\n,\n455\n]=\n24\n\n\nmatrix\n[\n0\n,\n546\n]=\n20\n\n\nmatrix\n[\n0\n,\n637\n]=\n17\n\n\n\nmatrix\n[\n91\n,\n0\n]=\n17\n\n\nmatrix\n[\n91\n,\n91\n]=\n16\n\n\nmatrix\n[\n91\n,\n182\n]=\n15\n\n\nmatrix\n[\n91\n,\n273\n]=\n18\n\n\nmatrix\n[\n91\n,\n364\n]=\n23\n\n\nmatrix\n[\n91\n,\n455\n]=\n23\n\n\nmatrix\n[\n91\n,\n546\n]=\n19\n\n\nmatrix\n[\n91\n,\n637\n]=\n17\n\n\n\nmatrix\n[\n182\n,\n0\n]=\n17\n\n\nmatrix\n[\n182\n,\n91\n]=\n16\n\n\nmatrix\n[\n182\n,\n182\n]=\n15\n\n\nmatrix\n[\n182\n,\n273\n]=\n18\n\n\nmatrix\n[\n182\n,\n364\n]=\n21\n\n\nmatrix\n[\n182\n,\n455\n]=\n21\n\n\nmatrix\n[\n182\n,\n546\n]=\n18\n\n\nmatrix\n[\n182\n,\n637\n]=\n16\n\n\n\nmatrix\n[\n273\n,\n0\n]=\n0\n\n\nmatrix\n[\n273\n,\n91\n]=\n0\n\n\nmatrix\n[\n273\n,\n182\n]=\n14\n\n\nmatrix\n[\n273\n,\n273\n]=\n0\n\n\nmatrix\n[\n273\n,\n364\n]=\n21\n\n\nmatrix\n[\n273\n,\n455\n]=\n0\n\n\nmatrix\n[\n273\n,\n546\n]=\n18\n\n\nmatrix\n[\n273\n,\n637\n]=\n0\n\n\n\nmatrix\n[\n364\n,\n0\n]=\n0\n\n\nmatrix\n[\n364\n,\n91\n]=\n0\n\n\nmatrix\n[\n364\n,\n182\n]=\n14\n\n\nmatrix\n[\n364\n,\n273\n]=\n0\n\n\nmatrix\n[\n364\n,\n364\n]=\n23\n\n\nmatrix\n[\n364\n,\n455\n]=\n0\n\n\nmatrix\n[\n364\n,\n546\n]=\n18\n\n\nmatrix\n[\n364\n,\n637\n]=\n0\n\n\n\nmatrix\n[\n455\n,\n0\n]=\n0\n\n\nmatrix\n[\n455\n,\n91\n]=\n0\n\n\nmatrix\n[\n455\n,\n182\n]=\n14\n\n\nmatrix\n[\n455\n,\n273\n]=\n0\n\n\nmatrix\n[\n455\n,\n364\n]=\n23\n\n\nmatrix\n[\n455\n,\n455\n]=\n0\n\n\nmatrix\n[\n455\n,\n546\n]=\n19\n\n\nmatrix\n[\n455\n,\n637\n]=\n0\n\n\n\nmatrix\n[\n546\n,\n0\n]=\n0\n\n\nmatrix\n[\n546\n,\n91\n]=\n0\n\n\nmatrix\n[\n546\n,\n182\n]=\n15\n\n\nmatrix\n[\n546\n,\n273\n]=\n0\n\n\nmatrix\n[\n546\n,\n364\n]=\n23\n\n\nmatrix\n[\n546\n,\n455\n]=\n0\n\n\nmatrix\n[\n546\n,\n546\n]=\n19\n\n\nmatrix\n[\n546\n,\n637\n]=\n0\n\n\n\n# 將原本有值的位置填入新矩陣\n\n\nmatrix_new\n[::\n91\n, ::\n91\n] = matrix[::\n91\n, ::\n91\n]\n\n# 定義 x 和 y 的範圍\n\n\nx_range\n = np.arange(\n0\n, cols)\n\ny_range\n = np.arange(\n0\n, rows)\n\n\n# 對每五格進行內插\n\n\nx_new\n=\n0\n\n\ny_new\n=\n0\n\n\ndef\n new_func(matrix_new, x_new, y_new, pts, vals):\n    \nmatrix_new\n[y_new, x_new] = griddata(pts, vals, (x_new, y_new), method='linear', fill_value=\n0\n)\n\n\nfor\n x in range(\n0\n, cols, \n5\n):\n    \nfor\n y in range(\n0\n, rows, \n5\n):\n        \n# 如果原本位置的值>0，就不做內插\n\n        \nif\n matrix_new[y, x] > \n0\n or y_new == \n545\n:\n            \ncontinue\n\n        \n# 要進行內插的新位置\n\n        \n####x_new, y_new = int(x+2.5), int(y+2.5)\n\n        \ny_new\n = y_new + \n5\n\n        \n# 取出內插需要用到的點\n\n        \npts\n =\n [(x0, y0) for x0 in x_range for y0 in y_range if matrix_new[y0, x0] > 0]\n\n        \n# 取出內插需要用到的值\n\n        \nvals\n =\n [matrix_new[y0, x0] for x0, y0 in pts]\n\n        \n# 進行內插\n\n        \nnew_func\n(matrix_new, x_new, y_new, pts, vals)\n    \ny_new\n = \n0\n\n    \nx_new\n = x_new + \n5\n\n    \nif\n x_new == \n640\n:\n        \ncontinue\n\n\n\n\n# 開啟檔案\n\n\nwith\n open(\n\"output.txt\"\n, \n\"w\"\n) as f:\n    \n# 將矩陣中的每個元素寫入檔案\n\n    \nfor\n row in matrix_new:\n        \nfor\n value in row:\n            \nf\n.write(str(value) + \n\" \"\n)\n        \nf\n.write(\n\"\\n\"\n)\n\n# 打印矩陣a\n\n\n#print(matrix_new)\n\n\n", "Tag": "算法分析"}
{"Answer": "基于Monster 组和GPT的调写：2\n% 定义系数矩阵和常数向量\nA = [0.001 2.000 3.000; -1.000 3.712 4.623; -2.000 1.072 5.643];\nb = [1.000; 2.000; 3.000];\n\n% 顺序消元法求解\nx1 = A\\b;\n\n% 列主元消元法求解\n[L,U,P] = lu(A);\ny = L\\(P*b);\nx2 = U\\y;\n\n% 输出结果并与真实解进行比较\nfprintf('顺序消元法求解结果：\\n');\ndisp(x1);\nfprintf('列主元消元法求解结果：\\n');\ndisp(x2);\nfprintf('真实解：\\n');\nx_true = [-0.4904; -0.05104; 0.3675];\ndisp(x_true);\n\nfprintf('顺序消元法误差：\\n');\ndisp(norm(x1 - x_true));\nfprintf('列主元消元法误差：\\n');\ndisp(norm(x2 - x_true));\n\n\n\n4\n% 定义系数矩阵\nA = [2 -1 0 0; -1 2 -1 0; 0 -1 2 -1; 0 0 -1 2];\n% 定义右侧常数向量\nb = [0; 0; 0; 5];\n\n% 使用追赶法求解线性方程组\nn = length(b);\nc = diag(A, -1);\nd = diag(A);\ne = diag(A, 1);\n% 前向消元\nfor i = 2:n\n    factor = c(i-1) / d(i-1);\n    d(i) = d(i) - factor * e(i-1);\n    b(i) = b(i) - factor * b(i-1);\nend\n% 回代求解\nx = zeros(n, 1);\nx(n) = b(n) / d(n);\nfor i = n-1:-1:1\n    x(i) = (b(i) - e(i) * x(i+1)) / d(i);\nend\n\n% 输出解向量\ndisp(x);\n\n\n\n\n\n\n4.顺序消元法\n% 定义系数矩阵和常数向量\nA = [1.1348, 3.8326, 1.1651, 3.4017;\n     0.5301, 1.7875, 2.5330, 1.5435;\n     3.4129, 4.9317, 8.7643, 1.3142;\n     1.2371, 4.9998, 10.6721, 0.0147];\nb = [9.5342; 6.3941; 18.4231; 16.9237];\n\n% 高斯消元求解方程组\nn = length(b);\nfor k = 1:n-1\n    for i = k+1:n\n        factor = A(i,k)/A(k,k);\n        A(i,k+1:n) = A(i,k+1:n) - factor*A(k,k+1:n);\n        b(i) = b(i) - factor*b(k);\n    end\nend\n\n% 回代求解方程组\nx = zeros(n,1);\nx(n) = b(n)/A(n,n);\nfor i = n-1:-1:1\n    x(i) = (b(i) - A(i,i+1:n)*x(i+1:n))/A(i,i);\nend\n\n% 输出结果\ndisp('顺序消元法结果：');\ndisp(x);\n\n\n\n列主元消元法\n\n% 定义系数矩阵和常数向量\nA = [1.1348, 3.8326, 1.1651, 3.4017;\n     0.5301, 1.7875, 2.5330, 1.5435;\n     3.4129, 4.9317, 8.7643, 1.3142;\n     1.2371, 4.9998, 10.6721, 0.0147];\nb = [9.5342; 6.3941; 18.4231; 16.9237];\n\n% 列主元消元求解方程组\nn = length(b);\nfor k = 1:n-1\n    [~,maxidx] = max(abs(A(k:n,k)));  % 找到当前列中绝对值最大的元素所在行\n    maxidx = maxidx + k - 1;\n    if A(maxidx,k) == 0   % 避免主元为0的情况\n        error('矩阵不可逆');\n    end\n    % 交换当前行和主元所在行\n    if maxidx ~= k\n        A([k,maxidx],k:n) = A([maxidx,k],k:n);\n        b([k,maxidx]) = b([maxidx,k]);\n    end\n    % 消元\n    for i = k+1:n\n        factor = A(i,k)/A(k,k);\n        A(i,k+1:n) = A(i,k+1:n) - factor*A(k,k+1:n);\n        b(i) = b(i) - factor*b(k);\n    end\nend\n\n% 回代求解方程组\nx = zeros(n,1);\nx(n) = b(n)/A(n,n);\nfor i = n-1:-1:1\n    x(i) = (b(i) - A(i,i+1:n)*x(i+1:n))/A(i,i);\nend\n\n% 输出结果\ndisp('列主元消元法结果：');\ndisp(x);\n\n\n", "Konwledge_Point": "线性规划简介", "Question": "MATLAB 解线性方程组\n\n\n按题目要求用顺序消元法，列主元消元法和追赶法求方程组的解，想求个思路和全过程代码。不知道为什么我写的代码MATLAB上算不出结果，想看看正确的代码。", "Tag": "算法分析"}
{"Answer": "判断离群点的方法不一定是只看3倍标准差，还可以通过画散点图、Cook距离、DFFITS等方法进行识别。在进行离群点处理时，建议先进行散点图观察，结合领域知识和实际情况进行判断，然后再采取相应的处理方式，比如删除、替换等。但是需要注意的是，过度地删除离群点可能会导致信息的丢失和模型的失真，因此需要在删除前进行谨慎的分析和判断。另外，删除离群点后重新进行回归分析，R方减小的情况是可能会出现的，因为离群点具有一定的影响力，但是如果删除离群点能够提高模型的预测精度和稳定性，那么可以考虑采取删除的方式。同时，需要注意的是，重新进行回归分析时，可能会出现新的离群点，因此需要进行迭代处理，直到模型达到一定的稳定性为止。", "Konwledge_Point": "线性规划简介", "Question": "SPSS线性回归离群值处理\n问题\n\n\nSPSS线性回归离群值处理——删除离群点后重新回归，R方减小了且又出现离群点\n\n\n过程\n\n\n为了研究因变量的不同影响因素，在运用SPSS开展多元线性回归的过程中，通过离群点（Outlier）、高杠杆点（High Leverage Point）和强影响点（Influential Point）三种方式识别异常点，其中杠杆值均低于0.2，库克距离均小于1因此并未出现高杠杆点和强影响点，但是出现了若干的离群点，即大于3倍标准差。\n\n\n请问\n\n\n想要请问在判断离群点是一定是看3倍标准差吗？\n出现离群点的情况下是需要不停地删除，直到回归结果没有离群点出现嘛？", "Tag": "算法分析"}
{"Answer": "都是 O（1）", "Konwledge_Point": "线性规划简介", "Question": "new和delete的时间复杂度怎么看啊，是常数阶还是线性阶？\nnew空间和delete删空间的时间复杂度怎么看啊，是常数阶还是线性阶？", "Tag": "算法分析"}
{"Answer": "题主的代码修改如下，供参考：\n#include<stdio.h> \nint main()\n{\n    int n, m, b[100000], a, i;\n    scanf(\"%d %d\", &n, &m);\n    i = n;\n    while (i--) {  //n 需要保持不变，后面还要用到\n        scanf(\"%d\", &b[i]);\n    }\n    while (m--) {\n        scanf(\"%d\", &a);  //scanf(\"%d\",a); a 前面缺了 ‘&’ 符\n        printf(m != 0 ? \"%d\\n\" : \"%d\", b[n - a]); //修改\n    }\n    return 0;\n}\n\n", "Konwledge_Point": "线性规划简介", "Question": "线性结构询问学号问题\n问题遇到的现象和发生背景 题目描述\n\n\n有 n(n \\le 2 \\times 10^6)n(n≤2×10\n6\n ) 名同学陆陆续续进入教室。我们知道每名同学的学号（在 11 到 10^910\n9\n  之间），按进教室的顺序给出。上课了，Teacher想知道第 ii 个进入教室的同学的学号是什么（最先进入教室的同学 i=1i=1），询问次数不超过 10^510\n5\n  次。\n\n\n输入格式\n第一行 22 个整数 nn 和 mm，表示学生个数和询问次数。\n\n\n第二行 nn 个整数，表示按顺序进入教室的学号。\n\n\n第三行 mm 个整数，表示询问第几个进入教室的同学。\n\n\n输出格式\n输出 mm 个整数表示答案，用换行隔开。\n\n\n输入输出样例\n输入 #1复制\n10 3\n1 9 2 60 8 17 11 4 5 14\n1 5 9\n输出 #1复制\n1\n8\n5\n\n\n用代码块功能插入代码，请勿粘贴截图\n\n\n#\ninclude\n\n \n\n\nint\n \nmain\n()\n\n\n{\n    \nint\n n,m;\n    \nint\n a;\n    \nscanf\n(\n\"%d %d\"\n,&n,&m);\n    \ndouble\n b[n];\n    \nwhile\n(n--){\n        \nscanf\n(\n\"%lf\"\n,&b[n]);\n    }\n    \nwhile\n(m--){\nscanf\n(\n\"%d\"\n,a);\n    \nprintf\n(m!=\n0\n?\n\"%.0lf\\n\"\n:\n\"%.0lf\"\n,b[n-a+\n1\n]);\n    }\n    \nreturn\n \n0\n;\n}\n\n\n\n\n运行结果及报错内容 输入样例但是没有输出结果\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果 不知道哪里出错了 请求指导", "Tag": "算法分析"}
{"Answer": "\n3.2 矩阵乘积的秩_jhshanvip的博客-CSDN博客_矩阵乘积的秩\n矩阵乘积的秩矩阵乘积 ABABAB 的秩和矩阵 A,BA,BA,B 的秩有什么关系呢？首先直观上说明。线性映射 Ax=yA\\mathbf{x}=\\mathbf{y}Ax=y ，当矩阵 AAA 是列满秩矩阵时，即无关组时，映射是单射，所以定义域内一个向量 x\\mathbf{x}x 对应值域内一个向量 y\\mathbf{y}y ，值域内一个向量 y\\mathbf{y}y 也对应定义域内一个向量 x...\n\n\n\nhttps://blog.csdn.net/jhshanvip/article/details/105077191\n\n最极端的情况,A=np.zeros(),也就是你乘了一个0过去,计算出的AB秩为0,小于rank(B)就是说矩阵相乘后矩阵的秩不会增加,视A的情况秩可能减少有帮助望采纳", "Konwledge_Point": "线性规划简介", "Question": "线性代数，linear algebra\nSuppose column j of B is a combination of previous columns of B. Show that column j of AB is the same combination of previous columns of AB. Then AB can't have new pivot columns, so rank(AB) <= rank(B).\n\n\n我能理解rank(AB) = rank(B),  什么时候rank(AB)会小于rank(B)啊？", "Tag": "算法分析"}
{"Answer": "如果v0和[s]是标量，上面的公式可写为f(Km, Vmax)=0的形式。假定km在区间[a,b]内方程有解，可在该区间内均匀取n点，计算一元方程得到n个Vmax的解。下面的代码，演示了非线性方程的解法。\nfrom scipy import optimize\ndef f(x):\n    return 3/(x*5) + 1/x - 1/7\n\nresult = optimize.root_scalar(f, bracket=[-2,2])\nresult.root\n-1.2566741077549764e-12\n", "Konwledge_Point": "线性规划简介", "Question": "python自定义非线性方程\n请问我想利用python拟合上述公式求解Vmax和Km,其中V0，[S]是一些已知的参数，请问应该怎么用python来实现呢，谢谢。", "Tag": "算法分析"}
{"Answer": "```\r\n#include \r\n#include \r\nusing namespace std;\r\n\r\n#define MAX 100\r\n\r\ntemplate \r\nclass Stack {\r\npublic:\r\nStack(); //构造函数\r\nbool empty() const ; //判断S是否为空栈\r\nbool full() const; //判断栈S是否为满，\r\n~Stack(); //将栈S清空\r\nint size() const; //求栈S的长度，即栈S中的元素的个数\r\nT & top() const; //返回栈S的栈顶元素\r\nvoid push( const T &e ); //入栈操作，将数据元素e插入栈S的当前栈顶\r\nT & pop(); //出栈操作，删除栈S的栈顶元素，并返回其值\r\nprivate:\r\n// 补充\r\nT data[MAX];\r\nint cur;\r\n};\r\n\r\nStack::Stack()\r\n{\r\n\tcur = 0;\r\n}\r\n\r\nbool Stack::empty() const\r\n{\r\n\tcur = 0;\r\n}\r\n\r\nbool Stack::full() const\r\n{\r\n\treturn cur >= MAX;\r\n}\r\n\r\nStack::~Stack() {}\r\n\r\nint size() const { return cur; }\r\n\r\nT & Stack::top()\r\n{\r\n\tif (cur == 0) throw \"stack is empty\";\r\n\treturn data[cur - 1];\r\n}\r\n\r\nvoid Stack::push( const T &e )\r\n{\r\n\tif (cur >= MAX) throw \"stack is full\";\r\n\tdata[cur++] = e;\r\n}\r\n\r\nT & Stack::pop()\r\n{\r\n\tif (cur == 0) throw \"stack is empty\";\r\n\treturn data[--cur];\r\n}\r\n\r\n//测试的main函数\r\nint main() {\r\nStack sc; //stack of char\r\nStack si; //Stack of int\r\nchar ch = ' ';\r\n// 不断输入字符到栈中，=结束\r\nwhile (ch != '=') {\r\ncin >> ch;\r\nif (ch == 'a')\r\nsc.push('A');\r\nsc.push(ch);\r\n}\r\ncout << \"top=\" << sc.top() << \"size=\" << sc.size() << endl;\r\ncout << \"pop \" << sc.pop() << endl;\r\nwhile (!sc.empty())\r\ncout << sc.pop()<< \" \";\r\ncout << endl;\r\n\r\n int x = 1;\r\n // 不断输入int到栈中，0结束\r\nwhile (x != 0) {\r\n     cin >> x;\r\n     if (x > 10)\r\n         si.push(10000);\r\n     si.push(x);\r\n }\r\n cout << \"top=\" << si.top() << \"size=\" << si.size() << endl;\r\n cout << \"pop \" << si.pop() << endl;\r\n while (!si.empty())\r\n     cout << si.pop()<< \"/\";\r\n cout << endl;\r\n\r\n return 0;\r\n}\r\n```\r\n\r\n# 如果问题解决，请采纳下毕小宝的回答。如果还有问题，请追问", "Konwledge_Point": "线性规划简介", "Question": "线性表及栈与队列的实现 -- 栈\n1.问题描述：\n\n 针对线性表或栈或队列（三者任选一种逻辑结构），按要求完成类（模板）的实现，并使用提供的main函数测试程序。\n\n\n\n2.完成时有几种选择：\n\na.栈的实现。 b. 队列的实现。 c. 线性表的实现。\n\n\n\n这里是栈的实现。务必按照提供的代码为基础进行补充。\n\n\n\ntemplate \n\n class Stack {\n\n public:\n\nStack();     //构造函数\n\n    bool empty() const ; //判断S是否为空栈\n\n    bool full() const; //判断栈S是否为满，\n\n    ~Stack(); //将栈S清空\n\n    int size() const; //求栈S的长度，即栈S中的元素的个数\n\n    T & top() const; //返回栈S的栈顶元素\n\n    void push( const T &e ); //入栈操作，将数据元素e插入栈S的当前栈顶\n\n    T & pop(); //出栈操作，删除栈S的栈顶元素，并返回其值\n\nprivate:\n\n     // 补充\n\n};\n\n\n\n//测试的main函数\n\nint main() {\n\n     Stack sc; //stack of char\n\n     Stack si; //Stack of int\n\n     char ch = ' ';\n\n     // 不断输入字符到栈中，=结束\n\n    while (ch != '=') {\n\n         cin >> ch;\n\n         if (ch == 'a')\n\n             sc.push('A');\n\n         sc.push(ch);\n\n     }\n\n     cout << \"top=\" << sc.top() << \"size=\" << sc.size() << endl;\n\n     cout << \"pop \" << sc.pop() << endl;\n\n     while (!sc.empty())\n\n         cout << sc.pop()<< \" \";\n\n     cout << endl;\n\n\n\n int x = 1;\n // 不断输入int到栈中，0结束\nwhile (x != 0) {\n     cin >> x;\n     if (x > 10)\n         si.push(10000);\n     si.push(x);\n }\n cout << \"top=\" << si.top() << \"size=\" << si.size() << endl;\n cout << \"pop \" << si.pop() << endl;\n while (!si.empty())\n     cout << si.pop()<< \"/\";\n cout << endl;\n\n return 0;\n\n\n\n\n}\n\n\n\n急求，用c++补充", "Tag": "算法分析"}
{"Answer": "loginFenzi", "Konwledge_Point": "线性规划简介", "Question": "用java怎么拟合形如y=ax^b的幂函数\n我现在用一组(x,y)的值,怎么根据这一组值求解a,b;\n\n                用excel拟合出来的结果是y = 118.5x^-0.713\n\n                但excel内部具体实现就不知道了,求大神给个思路或代码", "Tag": "算法分析"}
{"Answer": "看这样行不行\nfrom scipy.integrate import odeint\nimport numpy as np\nimport matplotlib.pyplot as plt \n\ndef dx_dt(x,t):\n    return -3*t*x**3+np.sin(t)+np.cos(2*t)\n\nx0 = input('请输入x0: ')\nt = np.arange(0, 10, 0.01)\nx = odeint(dx_dt,x0,t)\n\nplt.plot(t, x)\nplt.title(\"picture\")\nplt.show()\n", "Konwledge_Point": "线性规划简介", "Question": "如何使用python求微分方程的数值解，并绘图？\n使用python求微分方程的数值解，并绘图，有哪位可以帮帮忙🙏🙏", "Tag": "算法分析"}
{"Answer": "一个线性变换就是对应于一个变换矩阵，假设变换矩阵为A，从三维到二维，所以是一个2x3的矩阵，把已知的值带入，列出一个六元一次方程组求出矩阵A。", "Konwledge_Point": "线性规划简介", "Question": "关于#算法#的问题：高等数学求解，R的三次方变R的平方\n高等数学求解，R的三次方变R的平方，然后求a和b两个问题的解", "Tag": "算法分析"}
{"Answer": "可以尝试将 w[0] = bias 改为 weight[0] = bias。", "Konwledge_Point": "线性规划简介", "Question": "关于Python#线性回归#中遇到的syntax error问题，如何解决？\n本人在实践《用线性回归预测网店销售额》的‘初始化权重训练机器的环节’中中遇到问题：syntax error ：can' assign to function call，代码如下：\n<< iterations = 300 ;\n<< alpha = 0.15 ;\n<<  weight = np.array( [ 0.5,1,1,1] ) , w[0] = bias\n<<print ('当前损失:' ,loss_function(X_train, y_train ,weight) )\n结果输出：syntax error ：can' assign to function call,问题出在第三行代码。\n望高人指点江山，非常感谢！", "Tag": "算法分析"}
{"Answer": "你看错了吧，是不是说法有区别，你给个链接，开关灯操作只需要对应的位异或1就行.\r\n你是说获取某一位的get函数么，因为是从右往左数第i位，所以往右移i位肯定到了个位，这样再&1就是结果了。\r\n```\r\nint GetBit(char c, int i)\r\n{\r\n    return (c >> i) & 1;\r\n}\r\n```", "Konwledge_Point": "线性规划简介", "Question": "关于熄灯问题的一个疑问\n老师上课问的问题：熄灯问题常用的方法是位运算，位运算是从后向前数第 i 位，讨论解题思路时是从前向后第 i位，为什么可以计算正确？\n\n是网课，演示用的代码就是这个（好像连文案都是一样的）\n\n[(\nhttps://blog.csdn.net/qq_41480330/article/details/82561840\n \"\")]", "Tag": "算法分析"}
{"Answer": "最后一步按列展开，应该是 a11*A1，这里你只出现了 A11，所以还要乘上 a11，然后就能得到3 ", "Konwledge_Point": "线性规划简介", "Question": "线性代数关于按列展开问题\n为什么按列展开得到的答案是-3，和用对角线法则算出来的不一样？书上只写了按行展开，不是很明白如何按列展开，求解释", "Tag": "算法分析"}
{"Answer": "因为你最后一行有个break  只会运行一次  i就是0", "Konwledge_Point": "线性规划简介", "Question": "关于线性回归的数据集遍历\n\n\n\n自己设了个小数据集，\n\nfeatures为[1,2],[3,4],[5,6],[7,8],[9,10],[11,12]\n\nlables为[9,19,29,39,49,59]\n\n\n\nprint(i)还是永恒为0，但是 j 会一直变化 ( 甚至会出现 j 为[5,2]这种情况，不知道为什么min( i+batch_size,num_examples )会比 i 小\n\n\n\n \n\n\n\n而且i不是应该遍历嘛，应该从0到2到4，但是也一直是0\n\n\n\n初学者想这个问题已经好几天了，拜托大神，感激不尽", "Tag": "算法分析"}
{"Answer": "你好，结果的回归系数是两个，第一个你仔细看其实是乘以后面两个数据的意思，也就是说得到的回归系数是0.2902*10^(-4)和0.0182*10^(-4)，第一个数是要乘以后面两个数的有帮助望采纳", "Konwledge_Point": "线性规划简介", "Question": "matlab在线性回归中的疑问\n回归系数为什么是3个，第一个为什么会那么小，是可以忽略了吗？第一个为什么出来的，哪一位大佬有兴趣帮忙，求大神解惑", "Tag": "算法分析"}
{"Answer": "\nuse web workers, it like running your code in a seprate thread\nhttp://www.html5rocks.com/en/tutorials/workers/basics/\n", "Konwledge_Point": "线性规划简介", "Question": "javascript的线性代数[关闭]\n\n\n\nI am doing a couple of heavy linear algebra computations in my javascript code which results in blocking the browser. I was wondering what is the best way to handle heavy mathematical computations in a web application?\n\n\n\nI am using php on serverside. My question is should I use linear algebra libraries in php or is there a way I can use MATLAB in my web application? Any other suggestions to handle this?\n\n    ", "Tag": "算法分析"}
{"Answer": "使用:\r\n\r\n    new LinearLayout.LayoutParams(LayoutParams.FILL_PARENT,getWindowManager().getDefaultDisplay().getHeight()-100));", "Konwledge_Point": "线性规划简介", "Question": "如何动态的设置linear layout的高和宽\n在我的XML文件中有一个 Linearlayout，但是高度和宽度是布满整个屏幕的。现在我想动态的改变布局的高和宽。\n\n使用以下的代码:\n\n\n\n_llChooseType.setLayoutParams(new LayoutParams(LayoutParams.FILL_PARENT,getWindowManager().getDefaultDisplay().getHeight()-100));\n\n\n\n\n但是却得到错误：\n\n\n\njava.lang.ClassCastException: android.view.ViewGroup$LayoutParams exception.\n", "Tag": "算法分析"}
{"Answer": "A= rand(5)", "Konwledge_Point": "线性规划简介", "Question": "Matlab的高斯消元法\n生成随机5、10阶矩阵A，x=（1 1 1 1 1）ᵀ，计算Ax=b，然后使用A，b和高斯消去法求解x. 分析误差；", "Tag": "算法分析"}
{"Answer": "方程中的变量跟 Java 的变量是一样的，需要先对方程进行转换为 x 为 y 的一个表达式，然后就可以用变量直接得到计算结果了。", "Konwledge_Point": "线性规划简介", "Question": "高分悬赏：Java语言输入一个包含xy的方程，再输入一个y的值，怎么计算对应的x\n高分悬赏：Java语言输入一个包含xy的方程，再输入一个y的值，怎么计算对应的x", "Tag": "算法分析"}
{"Answer": "（1）问题分析出现复数解应该是因为你的“zw”函数中有1.5次方和0.5次方，而fsolve搜索解的时候对应幂的底数可能是负的，这样对应的1.5次方和0.5次方就会出现复数，进而导致目标函数值为复数，最终导致得到的解为复数。（2）问题的可能改进代码考虑在zw中将最后的函数值取模，这样可以得到实数解\nfunction F = zw_real(X)\nda= X(1);\ndr= X(2);\nct= X(3);\ndc=31;\nDw = 12.303;\nA = 0.627;\ndm = 58;\na=35/180*pi;\nKn=3.0363*10^5;\nri=6.405;\nRi=dm/2+(ri-Dw/2)*cos(a);\n\nFr=4500;Fa=3000;M=800000;\np1 = 0:2*pi/13:24*pi/13;\np2 = pi/13:2*pi/13:25*pi/13;\nF(1) = Fa-Kn*A^1.5*sum((sin(a) + da/A+Ri*(ct/A)*cos(p1)).*(((sin(a) + da/A+Ri*(ct/A)*cos(p1)).^2 + (cos(a) + dr* cos(p1)/A+0.5*dc*ct*cos(p1)/A).^2).^0.5 - 1).^1.5./((sin(a) + da/A+Ri*(ct/A)*cos(p1)).^2 + (cos(a) + dr* cos(p1)/A+0.5*dc*(ct/A)*cos(p1)).^2).^0.5)+Kn*A^1.5*sum((sin(a) - da/A-Ri*(ct/A)*cos(p2)).*(((sin(a) - da/A-Ri*(ct/A)*cos(p2)).^2 + (cos(a) + dr* cos(p2)/A-0.5*dc*ct*cos(p2)/A).^2).^0.5 - 1).^1.5./((sin(a) - da/A-Ri*(ct/A)*cos(p2)).^2 + (cos(a) + dr* cos(p2)/A-0.5*dc*(ct/A)*cos(p2)).^2).^0.5);\nF(2) = Fr-Kn*A^1.5*sum((cos(a) + (dr/A)*cos(p1)+0.5*dc*(ct/A)*cos(p1)).*cos(p1).*(((sin(a) + da/A+Ri*(ct/A)*cos(p1)).^2 + (cos(a) + dr* cos(p1)/A+0.5*dc*ct*cos(p1)/A).^2).^0.5 - 1).^1.5./((sin(a) + da/A+Ri*(ct/A)*cos(p1)).^2 + (cos(a) + dr* cos(p1)/A+0.5*dc*(ct/A)*cos(p1)).^2).^0.5)-Kn*A^1.5*sum((cos(a) + (dr/A)*cos(p2)-0.5*dc*(ct/A)*cos(p2)).*cos(p2).*(((sin(a) -da/A-Ri*(ct/A)*cos(p2)).^2 + (cos(a) + dr* cos(p2)/A-0.5*dc*ct*cos(p2)/A).^2).^0.5 - 1).^1.5./((sin(a) + da/A+Ri*(ct/A)*cos(p1)).^2 + (cos(a) + dr* cos(p1)/A+0.5*dc*(ct/A)*cos(p1)).^2).^0.5);\nF(3)=M-dm/2*Kn*A^1.5*sum((sin(a) + da/A+Ri*(ct/A)*cos(p1)).*cos(p1).*(((sin(a) + da/A+Ri*(ct/A)*cos(p1)).^2 + (cos(a) + dr* cos(p1)/A+0.5*dc*ct*cos(p1)/A).^2).^0.5 - 1).^1.5./((sin(a) + da/A+Ri*(ct/A)*cos(p1)).^2 + (cos(a) + dr* cos(p1)/A+0.5*dc*(ct/A)*cos(p1)).^2).^0.5)-dc/2*Kn*A^1.5*sum((cos(a) + (dr/A)*cos(p1)+0.5*dc*(ct/A)*cos(p1)).*cos(p1).*(((sin(a) + da/A+Ri*(ct/A)*cos(p1)).^2 + (cos(a) + dr* cos(p1)/A+0.5*dc*ct*cos(p1)/A).^2).^0.5 - 1).^1.5./((sin(a) + da/A+Ri*(ct/A)*cos(p1)).^2 + (cos(a) + dr* cos(p1)/A+0.5*dc*(ct/A)*cos(p1)).^2).^0.5)+dm/2*Kn*A^1.5*sum((sin(a) - da/A-Ri*(ct/A)*cos(p2)).*cos(p2).*(((sin(a) - da/A-Ri*(ct/A)*cos(p2)).^2 + (cos(a) + dr* cos(p2)/A-0.5*dc*ct*cos(p2)/A).^2).^0.5 - 1).^1.5./((sin(a) - da/A-Ri*(ct/A)*cos(p2)).^2 + (cos(a) + dr* cos(p2)/A-0.5*dc*(ct/A)*cos(p2)).^2).^0.5)+dc/2*Kn*A^1.5*sum((cos(a) + (dr/A)*cos(p2)-0.5*dc*(ct/A)*cos(p2)).*cos(p2).*(((sin(a) -da/A-Ri*(ct/A)*cos(p2)).^2 + (cos(a) + dr* cos(p2)/A-0.5*dc*ct*cos(p2)/A).^2).^0.5 - 1).^1.5./((sin(a) + da/A+Ri*(ct/A)*cos(p1)).^2 + (cos(a) + dr* cos(p1)/A+0.5*dc*(ct/A)*cos(p1)).^2).^0.5);\nF=abs(F);  %给函数返回值取模\nend\n\nclear;clc;\nh=optimset;\nh.Display='off';\nh.TolX=1e-6;\nformat long;\n[jg,fval,exitflag]=fsolve('zw_real',[0,0,0],h) %求解\nformat short;\n\n（3）代码运行结果截图这是将zw的返回值取模得到的结果，不知道能不能对上你的理论解，欢迎讨论", "Konwledge_Point": "线性规划简介", "Question": "matlab fsolve求解非线性方程组为什么得到复数解\n用matlab fsolve求解非线性方程组得到的是复数解，该方程组有实数解，而且发现求得的复数解的实部和答案基本吻合，这是为什么呢？下面是我建立的方程和fsolve求解的程序\n\n\nfunction\n F = zw(X)\n\nda\n= X(\n1\n);\n\ndr\n= X(\n2\n);\n\nct\n= X(\n3\n);\n\ndc\n=\n31\n;\n\nDw\n = \n12\n.\n303\n;\n\nA\n = \n0\n.\n627\n; \n\ndm\n = \n58\n;\n\na\n=\n35\n/\n180\n*pi;\n\nKn\n=\n3\n.\n0363\n*\n10\n^\n5\n;\n\nri\n=\n6\n.\n405\n;\n\nRi\n=dm/\n2\n+(ri-Dw/\n2\n)*cos(a);\n\n    \nFr\n=\n4500\n;Fa=\n3000\n;M=\n800000\n;\n    \np1\n = \n0\n:\n2\n*pi/\n13\n:\n24\n*pi/\n13\n;\n    \np2\n = pi/\n13\n:\n2\n*pi/\n13\n:\n25\n*pi/\n13\n;\n    \nF\n(\n1\n) = Fa-Kn*A^\n1\n.\n5\n*sum((sin(a) + da/A+Ri*(ct/A)*cos(p1)).*(((sin(a) + da/A+Ri*(ct/A)*cos(p1)).^\n2\n + (cos(a) + dr* cos(p1)/A+\n0\n.\n5\n*dc*ct*cos(p1)/A).^\n2\n).^\n0\n.\n5\n - \n1\n).^\n1\n.\n5\n./((sin(a) + da/A+Ri*(ct/A)*cos(p1)).^\n2\n + (cos(a) + dr* cos(p1)/A+\n0\n.\n5\n*dc*(ct/A)*cos(p1)).^\n2\n).^\n0\n.\n5\n)+Kn*A^\n1\n.\n5\n*sum((sin(a) - da/A-Ri*(ct/A)*cos(p2)).*(((sin(a) - da/A-Ri*(ct/A)*cos(p2)).^\n2\n + (cos(a) + dr* cos(p2)/A-\n0\n.\n5\n*dc*ct*cos(p2)/A).^\n2\n).^\n0\n.\n5\n - \n1\n).^\n1\n.\n5\n./((sin(a) - da/A-Ri*(ct/A)*cos(p2)).^\n2\n + (cos(a) + dr* cos(p2)/A-\n0\n.\n5\n*dc*(ct/A)*cos(p2)).^\n2\n).^\n0\n.\n5\n);\n    \nF\n(\n2\n) = Fr-Kn*A^\n1\n.\n5\n*sum((cos(a) + (dr/A)*cos(p1)+\n0\n.\n5\n*dc*(ct/A)*cos(p1)).*cos(p1).*(((sin(a) + da/A+Ri*(ct/A)*cos(p1)).^\n2\n + (cos(a) + dr* cos(p1)/A+\n0\n.\n5\n*dc*ct*cos(p1)/A).^\n2\n).^\n0\n.\n5\n - \n1\n).^\n1\n.\n5\n./((sin(a) + da/A+Ri*(ct/A)*cos(p1)).^\n2\n + (cos(a) + dr* cos(p1)/A+\n0\n.\n5\n*dc*(ct/A)*cos(p1)).^\n2\n).^\n0\n.\n5\n)-Kn*A^\n1\n.\n5\n*sum((cos(a) + (dr/A)*cos(p2)-\n0\n.\n5\n*dc*(ct/A)*cos(p2)).*cos(p2).*(((sin(a) -da/A-Ri*(ct/A)*cos(p2)).^\n2\n + (cos(a) + dr* cos(p2)/A-\n0\n.\n5\n*dc*ct*cos(p2)/A).^\n2\n).^\n0\n.\n5\n - \n1\n).^\n1\n.\n5\n./((sin(a) + da/A+Ri*(ct/A)*cos(p1)).^\n2\n + (cos(a) + dr* cos(p1)/A+\n0\n.\n5\n*dc*(ct/A)*cos(p1)).^\n2\n).^\n0\n.\n5\n);\n    \nF\n(\n3\n)=M-dm/\n2\n*Kn*A^\n1\n.\n5\n*sum((sin(a) + da/A+Ri*(ct/A)*cos(p1)).*cos(p1).*(((sin(a) + da/A+Ri*(ct/A)*cos(p1)).^\n2\n + (cos(a) + dr* cos(p1)/A+\n0\n.\n5\n*dc*ct*cos(p1)/A).^\n2\n).^\n0\n.\n5\n - \n1\n).^\n1\n.\n5\n./((sin(a) + da/A+Ri*(ct/A)*cos(p1)).^\n2\n + (cos(a) + dr* cos(p1)/A+\n0\n.\n5\n*dc*(ct/A)*cos(p1)).^\n2\n).^\n0\n.\n5\n)-dc/\n2\n*Kn*A^\n1\n.\n5\n*sum((cos(a) + (dr/A)*cos(p1)+\n0\n.\n5\n*dc*(ct/A)*cos(p1)).*cos(p1).*(((sin(a) + da/A+Ri*(ct/A)*cos(p1)).^\n2\n + (cos(a) + dr* cos(p1)/A+\n0\n.\n5\n*dc*ct*cos(p1)/A).^\n2\n).^\n0\n.\n5\n - \n1\n).^\n1\n.\n5\n./((sin(a) + da/A+Ri*(ct/A)*cos(p1)).^\n2\n + (cos(a) + dr* cos(p1)/A+\n0\n.\n5\n*dc*(ct/A)*cos(p1)).^\n2\n).^\n0\n.\n5\n)+dm/\n2\n*Kn*A^\n1\n.\n5\n*sum((sin(a) - da/A-Ri*(ct/A)*cos(p2)).*cos(p2).*(((sin(a) - da/A-Ri*(ct/A)*cos(p2)).^\n2\n + (cos(a) + dr* cos(p2)/A-\n0\n.\n5\n*dc*ct*cos(p2)/A).^\n2\n).^\n0\n.\n5\n - \n1\n).^\n1\n.\n5\n./((sin(a) - da/A-Ri*(ct/A)*cos(p2)).^\n2\n + (cos(a) + dr* cos(p2)/A-\n0\n.\n5\n*dc*(ct/A)*cos(p2)).^\n2\n).^\n0\n.\n5\n)+dc/\n2\n*Kn*A^\n1\n.\n5\n*sum((cos(a) + (dr/A)*cos(p2)-\n0\n.\n5\n*dc*(ct/A)*cos(p2)).*cos(p2).*(((sin(a) -da/A-Ri*(ct/A)*cos(p2)).^\n2\n + (cos(a) + dr* cos(p2)/A-\n0\n.\n5\n*dc*ct*cos(p2)/A).^\n2\n).^\n0\n.\n5\n - \n1\n).^\n1\n.\n5\n./((sin(a) + da/A+Ri*(ct/A)*cos(p1)).^\n2\n + (cos(a) + dr* cos(p1)/A+\n0\n.\n5\n*dc*(ct/A)*cos(p1)).^\n2\n).^\n0\n.\n5\n);\n  \n\nend\n\n\n\nh\n=optimset;\n\nh\n.Display='\noff\n';\n\nh\n.TolX=\n1\ne-\n6\n;\n\n[jg,fval,exitflag]=fsolve('zw',[0,0,0],h) %求解\n\n", "Tag": "算法分析"}
{"Answer": "展开成傅里叶级数，高数的内容", "Konwledge_Point": "线性规划简介", "Question": "分段函数的单一函数数学近似\n一个周期连续的分段函数，怎么用一个周期的单一函数逼近？有没有什么理论之类的~表示数学太渣啊", "Tag": "算法分析"}
{"Answer": "和你的item布局文件有关系。把item布局贴一下。\r\n前面数字列应该设置成固定宽度。身高和体重也设置成固定宽度，顶多也就3为数字。", "Konwledge_Point": "线性规划简介", "Question": "listview里的textviw文本错位\n\n如图所示:一开始布局没乱,但是输入数据后就会发生错误,我想实现的是,输入的新数据不会影响到其他数据的位置.该怎么解决?\n\n部分xml\n\n        android:id=\"@+id/list_view\"  \n\n        android:layout_width=\"fill_parent\"  \n\n        android:layout_height=\"fill_parent\"  \n\n        android:scrollingCache=\"true\"  \n\n        android:cacheColorHint=\"#00000000\"  \n\n        android:fastScrollEnabled=\"true\" \n\n        android:focusable=\"true\"  \n\n        android:dividerHeight=\"1dip\"   \n\n        />\n\n                item------\n\n                \n\n     xmlns:android=\"http://schemas.android.com/apk/res/android\"  \n\n     android:layout_width=\"fill_parent\"  \n\n     android:layout_height=\"wrap_content\">\n\n\n\n \n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "参考一下a和m互质，即它们的最大公约数为1；c与m无公因数，即它们的最大公约数为1；a-1能够被m的所有质因子整除；如果m是4的倍数，则a-1也必须是4的倍数。\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int m = 945; // 模数\n    int a = 2; // a值\n    int c = 1; // c值\n    int max_period = 0; // 最大周期\n\n    for (int i = 2; i < m; i++) { // 遍历a值\n        if (m % i == 0 && (i - 1) % 4 == 0) { // 判断是否满足条件3和4\n            a = i;\n            break;\n        }\n    }\n\n    for (int i = 1; i < m; i++) { // 遍历c值\n        if (m % i != 0) { // 判断是否满足条件2\n            c = i;\n            break;\n        }\n    }\n\n    int x = 1; // 初始值\n    int period = 0; // 周期\n\n    do { // 计算随机数序列的周期\n        x = (a * x + c) % m;\n        period++;\n    } while (x != 1);\n\n    max_period = m - 1; // 最大周期为m-1\n\n    printf(\"a=%d, c=%d, max period=%d\\n\", a, c, max_period);\n\n    return 0;\n}\n\n", "Konwledge_Point": "线性规划简介", "Question": "已知线性同余的模数为945\n已知线性同余的模数为945，怎么取a值和增量c值大最大周期呢", "Tag": "算法分析"}
{"Answer": "", "Konwledge_Point": "线性规划简介", "Question": "Linear algebra, Least Squares Approximations线性代数\n\n\n4.3A(1)怎么做的？能不能解释一下solution?", "Tag": "算法分析"}
{"Answer": "用expi函数，参见https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.expi.html#scipy.special.expi", "Konwledge_Point": "线性规划简介", "Question": "如何对指数积分进行非线性拟合\n楼主想拟合一个含指数积分的表达式，得到函数中的两个参数值。\n\n\n\n但是第一个问题是不知道自己写的指数积分表达是不是正确，第二是自己调用了哈这个自定义函数，报运行时间的错误，不知道怎么回事。这是那函数表达式。\n\n\n\n\n\n\n \n\n\n\n\n\nfrom scipy.special import *\nimport math\n##自定义函数 指数积分\ndef func(x,a,b):\n    c=2.5#单位时间单位长度发热丝的发热量\n    d=0.006#校准后的探针间距\n    e = 12 #热脉冲加热时间\n    #a为热传导系数\n    #b为热容量\n    return c/(4*math.pi*a*b)*(expn(1,-d*d/(4*a*(x-e)))-expn(1,-d*d/(4*a*x)))\nfunc(17,1,4.8)\n\n报错代码：\nD:\\anaconda\\lib\\site-packages\\ipykernel_launcher.py:15: RuntimeWarning: invalid value encountered in double_scalars\n  from ipykernel import kernelapp as app", "Tag": "算法分析"}
{"Answer": "我线性代数不太行，想不出啥技巧，用笨方法给你接一下x吧，y就不算了，不好算。\n", "Konwledge_Point": "线性规划简介", "Question": "Linear algebra, graphs and networks线性代数\n\n\n求A^T C A x = f =(1, 0, 0, -1)\n等式左边我算出来了，但是我用ipython算是singular matrix，算不出答案。\n\n\n\n\n他给的答案是x=（5/12， 1/6, 1/6, 0)y=(1/2, 1/2, 0, 1/2, 1/2)\n到底怎么算？", "Tag": "算法分析"}
{"Answer": "根据行列式的Leibniz公式，把行列式项中的元素按第一个下标排序，然后看第二个下标是否是序列{1, 2, ..., n}的一种置换，如果是，则符号是为正，否则为负。你这道题按第一个下标排序，得到a12 a24 a35 a41 a53第二个下标序列为{2, 4, 5, 1, 3}，而这个序列不能通过对{1, 2, 3, 4, 5}进行置换得到，所以符号改项的符号为负\n参考https://en.wikipedia.org/wiki/Determinant#Leibniz_formula", "Konwledge_Point": "线性规划简介", "Question": "请问这个是为什么线性代数\n", "Tag": "算法分析"}
{"Answer": "广义线性模型 (Generalized Linear Model, GLM) 是一类常用于分析二项分布数据的统计模型。当因变量是二元变量时，可以使用 glm() 函数来拟合一个 GLM 模型，并使用 family 参数来指定二项分布的家族。\n在你的情况中，因变量是0，1，自变量是分类变量，连续变量。你使用 family=binomial 来指定二项分布家族，这是正确的。\n但是，如果你在拟合模型时遇到了 \"model is nearly unidentifiable: very large eigenvalue\" 的警告，这通常表明线性模型存在多重共线性问题。这可能是因为自变量之间存在高度相关性，或者是因为自变量的线性组合导致的。\n解决方法:\n你可以考虑删除一些自变量，或者使用不同的转换来降低自变量之间的相关性你可以尝试使用正则化技术，比如 L1 或 L2 正则化，来解决多重共线性问题。你可以尝试使用其他类型的模型，比如决策树或随机森林等。需要注意的是，在确定自变量的时候，还需要考虑自变量的可解释性和业务场景。", "Konwledge_Point": "线性规划简介", "Question": "R 广义线性模型 — very large eigenvalue\n因变量为正确率（0，1），自变量为一个分类变量，两个连续变量，family=binomial\n显示model is nearly unidentifiable: very large eigenvalue\n\n\n请问family的使用是否正确，以及如何解决警告？", "Tag": "算法分析"}
{"Answer": "A是由5单位矩阵-4全是1的矩阵组成，前面的矩阵特征值都是5（单位矩阵对角线全是1，特征值全是1，所以都*5），后面的矩阵秩为1，但它是4阶，所以它只有一个特征值不为0，又因为对角线元素之和等于矩阵特征值之和，所以后面的矩阵特征值有一个是4，然后A的特征值是可以由前个矩阵的特征值依次减去后面矩阵特征值得到的\n", "Konwledge_Point": "线性规划简介", "Question": "Linear algebra, diagonalizing a matrix线性代数\n\n\n\"Subtract the eigenvalues 4,0,0,0 from 5,5,5,5. The eigenvalues of A are 1,5,5,5.\" 是什么原理？", "Tag": "算法分析"}
{"Answer": "x=data[\"Points\"].values", "Konwledge_Point": "线性规划简介", "Question": "如何知道线性方程y−y1 =m(x−x1)后，将表中的点值(50,60，…)保存到一个名为x的array中？\n从以上表格中任意选取两个等级，求线性评价量表y = ax + b的方程。\n用x标记point，用y标记grade。\ny−y1 =m(x−x1)\n知道线性方程后，将表中的点值(50,60，…)保存到一个名为x的array中。\n将方程应用到x的array中计算y。\n输出y和x的值。", "Tag": "算法分析"}
{"Answer": "能求出来应该算对吧，方法千万种", "Konwledge_Point": "线性规划简介", "Question": "线性代数的问题 行列式的问题\n在求行列式时 不化成上三角或下三角直接用展开式求算错吗？", "Tag": "算法分析"}
{"Answer": "基于Monster 组和GPT的调写：使用 Scikit-learn 的机器学习模型时，通常都是先实例化一个模型对象，然后再调用其 fit 方法来拟合模型。如果直接调用 LinearRegression().fit(x_train, y_train)，你会得到一个 \"This LinearRegression instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\" 的错误。这是因为，在调用 fit 方法前，模型实例没有被保存下来，因此不能在之后使用。\n而在这种情况下：\nhouselr = LinearRegression()\nhouselr.fit(x_train,y_train)\n\n\n\n\n首先，我们实例化了一个 LinearRegression 对象，并将其保存在变量 houselr 中。然后再调用 houselr.fit(x_train, y_train) 拟合模型，这样就不会报错。因此，通常情况下，在使用模型时都会先将其实例化，再拟合。", "Konwledge_Point": "线性规划简介", "Question": "使用sklearn进行线性回归时遇到的问题\n代码苦手,在使用sklearn中LinearRegression时,若直接使用\nLinearRegression().fit(x_train,y_train)\n则会报错This LinearRegression instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.  \n\n\n若是先行将LinearRegression()定义为其他,如\nhouselr = LinearRegression()\nhouselr.fit(x_train,y_train)\n则不会出现该状况,这是为什么呢?", "Tag": "算法分析"}
{"Answer": "b后面是逗号，你写成点了\nclc\nclear all\nclear global variables;\nf=[-2;-3;5];\na=[-2,5,-1;1,3,1];\nb=[-10;12];\naeq=[1,1,1];\nbeq=7;\n[x,y]=linprog(f,a,b,aeq,beq,zeros(3,1)); %此类型的变量不支持使用点进行索引。\nx,y=-y\n\n输出：\nx =\n\n    6.4286\n    0.5714\n    0.0000\n\n\ny =\n\n   14.5714\n", "Konwledge_Point": "线性规划简介", "Question": "matlab报错——此类型的变量不支持使用点进行索引。\nclc\nclear all\nclear global variables;\nf=[-2;-3;5];\na=[-2,5,-1;1,3,1];\nb=[-10;12];\naeq=[1,1,1];\nbeq=7;\n[x,y]=linprog(f,a,b.aeq,beq,zeros(3,1));                                此类型的变量不支持使用点进行索引。\nx,y=-y\n\n\nmatlab报错——此类型的变量不支持使用点进行索引。\n如何让这个线性规划问题得解", "Tag": "算法分析"}
{"Answer": "一、实验目的(1)加深对离散傅里叶变换(DFT)基本性质的理解。\n(2)了解有限长序列傅里叶变换(DFT)性质的研究方法。\n(3)掌握用MATLAB语言进行离散傅里叶变换性质分析时程序编写的方法。\n二、实验原理\n1.线性性质如果两个有限长序列分别为x1(n)和x2(n)，长度分别为N1和N2，且y(n)＝ax1(n)＋bx2(n) (a、b均为常数)\n则该y(n)的N点DFT为Y(k)＝DFT［y(n)］＝aX1(k)＋bX2(k) 0≤k≤N－1\n其中：N＝max［N1，N2］，X1(k)和X2(k)分别为x1(n)和x2(n)的N点DFT。\n例1：已知x1(n)＝［0，1，2，4］，x2(n)＝［1，0，1，0，1］，求：\n(1)y(n)＝2x1(n)＋3x2(n)，再由y(n)的N点DFT获得Y(k)；\n(2)由x1(n)、x2(n)求X1(k)、X2(k)，再求Y(k)＝2X1(k)＋3X2(k)。\n用图形分别表示以上结果，将两种方法求得的Y(k)进行比较，由此验证有限长序列傅里叶变换(DFT)的线性性质代码：\nxn1=[0,1,2,4]; %建立xn1序列\nxn2=[1,0,1,0,1];%建立xn2序列\nN1=length(xn1);\nN2=length(xn2);\nN=max(N1,N2);%确定N\nif N1>N2\n    xn2=[xn2,zeros(1,N1-N2)];%对长度短的序列补0\nelseif N2>N1 \n    xn1=[xn1,zeros(1,N2-N1)];\nend\nyn=2*xn1+3*xn2;%计算yn\nn=0:N-1;k=0:N-1;\nYk1=yn*(exp(-1j*2*pi/N)).^(n'*k);%求yn的N点DFT\nXk1=xn1*(exp(-1j*2*pi/N)).^(n'*k);%求xn1的N点DFT\nXk2=xn2*(exp(-1j*2*pi/N)).^(n'*k);%求xn2的N点DFT\nYk2=2*Xk1+3*Xk2;%由Xk1、Xk2求Yk\n\nfigure(1)\nsubplot(4,1,1);stem(xn1);\ntitle('x1(n)')\nsubplot(4,1,2);stem(xn2);\ntitle('x2(n)')\nsubplot(4,1,3);stem(yn);\ntitle('y(n)')\nsubplot(4,1,4);stem(k,Yk1);\naxis([0 4 -20 30])\ntitle('DFT(y(n))')\n\nfigure(2)\nsubplot(3,1,1);stem(k,Xk1);\ntitle('Xk1')\nsubplot(3,1,2);stem(k,Xk2);\ntitle('Xk2')\nsubplot(3,1,3);stem(k,Yk2);\naxis([0 4 -20 30])\ntitle('Yk')\n\n输出：\n详细内容可以查看：https://blog.csdn.net/linzch3/article/details/71107284", "Konwledge_Point": "线性规划简介", "Question": "matlab编程验证图像傅里叶变换的相关定理\nmatlab编程验证图像傅里叶变换性质中的相关定理，希望可以给出代码，是相关定理，不是其他性质，是性质中的相关定理，相！关！定！理！", "Tag": "算法分析"}
{"Answer": "这有个类似的问题, 你可以参考下: https://ask.csdn.net/questions/7739025这篇博客你也可以参考下：吴恩达机器学习之多变量线性回归：多维特征、多变量梯度下降、梯度下降法实践之特征缩放和学习率、特征和多项式回归、正规方程及不可逆性（详细笔记，建议收藏，已有专栏）除此之外, 这篇博客: 深度学习框架——学习入门中的 深度学习的总的框架包括以下一些内容：就是对于我们所要的数据进行相关的预处理。包括数据格式的统一以及必要的数据转换，同时进行训练数据集和测试数据集的划分，选择我们所需要的模型，设定相应的损失函数以及优化函数和对应的超参数进行相应的设置，最后使用模型去拟合训练集数据，在验证集和测试集上计算模型表现。 部分也许能够解决你的问题, 你可以仔细阅读以下内容或跳转源博客中阅读: 提示：以下是本篇文章正文内容，下面案例可供参考\n您还可以看一下 李月喜老师的企业微信开发自建内部应用开发篇课程中的 开发文档如何阅读,如何寻求帮助,如何找到同行小节, 巩固相关知识点", "Konwledge_Point": "线性规划简介", "Question": "训练集，线性回归，截距，斜率\n1、装载数据\n''' 数据集说明：x特征变量只有一个分量；样本个数为100个'''\n2、划分训练集与测试集\n3、用线性回归模型来实例化，在训练集上拟合数据，从而学习出参数w和b\n4、输出参数学习的结果\n5、计算并输出训练集和测试集上的精度\n6、绘制数据集的二维平面图（数据点用红色标识），并根据学习到的参数（即斜率与截距），画出回归直线（用蓝色画线）", "Tag": "算法分析"}
{"Answer": "行列式求解两种方法，一是通过行列变换得到对角行列式，二是通过行列式展开，也就是代数余子式的方法，就是标准答案的第一个方法。行列式经过行列变换后是等效的，所以为了计算方便，先经过行列变换再做展开也是可以的。", "Konwledge_Point": "线性规划简介", "Question": "线性代数中关于k阶子式问题\n\n\n我想用k阶子式的方法来做，但是我算出来的结果和答案不一样，而且答案是先行列互换再计算的，我这样子计算是错误的吗？", "Tag": "算法分析"}
{"Answer": "先构建一个等号右侧为0的等式，然后按照这个步骤去做就可以了。\n\n有帮助请采纳，还有不懂的可以继续追问~", "Konwledge_Point": "线性规划简介", "Question": "请教一下大家关于matlab求解非线性方程\n\n\n自己的程序出了错误不知如何解决，还有初始值该如何表示，请教一下大家", "Tag": "算法分析"}
{"Answer": "http://www.cnblogs.com/mr-wid/p/3380337.html", "Konwledge_Point": "线性规划简介", "Question": "线性结构模板，插入线性表时停止运行\n#include \n\n#include\n\n#include\n\n\n\n//模板结点\n\ntemplate\n\nstruct LNode{\n\n    ElemType data;\n\n    struct LNode* next;      //指针域\n\n};\n\n\n\ntemplate\n\nstruct List\n\n{\n\n    struct LNode *head;\n\n    struct LNode *tail;\n\n    int len;\n\n};\n\n\n\n//创建线性表\n\ntemplate\n\nvoid CreatList(struct List &L)\n\n{\n\n    L.head=L.tail=(struct LNode*)malloc(sizeof(struct LNode));\n\n    L.head->next=NULL;\n\n    L.len=0;\n\n}\n\n\n\ntemplate\n\nvoid Insert(struct List &L,ElemType e)\n\n{\n\n    struct LNode* s=(struct LNode*)malloc(sizeof(struct LNode));\n\n    s->data=e;\n\n    s->next=NULL;\n\n    L.tail->next=s;\n\n    L.tail=s;\n\n    L.len++;\n\n}\n\n\n\nstruct association;\n\ntypedef struct Student\n\n{\n\n    char no[15];\n\n    char name[20];\n\n    char sex;\n\n    char grade[5];\n\n    char major[24];\n\n    struct List ass_list;\n\n}*p_stu,stu;\n\n\n\nvoid addStu(struct List &s_L)\n\n{\n\n    stu s;\n\n    char no[15];\n\n    char name[20];\n\n    char grade[5];\n\n    char major[24];\n\n\n\nscanf(\"%s\",no);\nstrcpy(s.no,no);\n\nscanf(\"%s\",name);\nstrcpy(s.name,name);\nfflush(stdin);\n\nscanf(\"%c\",&s.sex);\n\nscanf(\"%s\",grade);\nstrcpy(s.grade,grade);\n\nscanf(\"%s\",major);\nstrcpy(s.major,major);\n\nCreatList(s.ass_list);\n\nInsert(s_L,s);\n\n\n\n\n}\n\n\n\nint main()\n\n{\n\n    struct List s_L;\n\n    s_L.head=NULL;\n\n    s_L.tail=NULL;\n\n\n\naddStu(s_L);\n\nreturn 0;\n\n\n\n\n}\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "\nimport cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.widgets import Slider #调用Slider滑块控件\n\ndef set_chinese(): #使得画图时的标题可以为中文\n    import matplotlib\n    print(\"[INFO] matplotlib版本为: %s\" % matplotlib.__version__)\n    matplotlib.rcParams['font.sans-serif'] = ['FangSong']\n    matplotlib.rcParams['axes.unicode_minus'] = False\n\ndef three_line_trans(x,x1,y1,x2,y2):\n    if x1==0 or x1==x2 or x2==255:\n        print(\"[INFO] x1={},x2{} ->调用此函数必须满足: x1≠x2且x2≠255以及x1≠0\")\n        return None\n\n    #【快速算法】\n    m1 = (x<x1)\n    m2 = (x>x1)&(x<x2)\n    m3 = (x>x2)\n    output = (y1*x/x1)*m1 + (((y2-y1)/(x2-x1))*(x-x1)+y1)*m2 + (((255-y2)/(255-x2))*(x-x2)+y2)*m3\n\n    # 3.获取分段线性函数的点集，用于绘制函数图像\n    x_point = np.arange(0, 256, 1)\n    cond2 = [True if (i >= x1 and i <= x2) else False for i in x_point] #!!!不能直接写x1<=x_point<=x2,否则报错。暂时不知道为什么不能双向\n    y_point = (y1 / x1 * x_point) * (x_point < x1) \\\n              + ((y2 - y1) / (x2 - x1) * (x_point - x1) + y1) * (cond2) \\\n              + ((255 - y2) / (255 - x2) * (x_point - x2) + y2) * (x_point > x2)\n\n    return output, x_point, y_point\n\ndef update_trans(val):\n    # 读入4个滑动条的值\n    x1, y1 = slider_x1.val, slider_y1.val\n    x2, y2 = slider_x2.val, slider_y2.val\n    if x1>=x2:\n        x1 = x2-1\n    if y1>=y2:\n        y1 = y2-1\n    output, x_point, y_point = three_line_trans(img_original1, x1=x1, y1=y1, x2=x2, y2=y2)\n    ax3.clear()\n    ax3.set_title('分段线性函数图像', fontsize=8)\n    ax3.grid(True, linestyle=':', linewidth=1)\n    ax3.plot([x1, x2], [y1, y2], 'ro')\n    ax3.plot(x_point, y_point, 'g')\n\n    ax4.clear()\n    ax4.set_title('变换后的图像', fontsize=8)\n    ax4.imshow(output, cmap='gray', vmin=0, vmax=255)\n\n    ax5.clear()\n    ax5.set_title('变换后图像直方图', fontsize=8)\n    ax5.hist(output.flatten(),bins=50, density=True, color='r', edgecolor='k')\n    ax5.set_xlim(0, 255)  # 设置x轴分布范围\n    ax5.set_ylim(0, 0.15)  # 设置y轴分布范围\n    ax5.grid(True, linestyle=':', linewidth=1)\n\n\nif __name__ == '__main__':\n    set_chinese()\n    img_original = cv2.imread(r'Fig0316(2)(2nd_from_top).tif')\n    img_original1 = cv2.cvtColor(img_original, cv2.COLOR_BGR2GRAY)\n\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(231)\n    ax2 = fig.add_subplot(232)\n    ax3 = fig.add_subplot(233)\n    ax4 = fig.add_subplot(234)\n    ax5 = fig.add_subplot(235)\n\n    ax1.set_title('原始输入图片',fontsize=8)\n    ax1.imshow(img_original1,cmap='gray',vmin=0,vmax=255) #官方文档：https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.imshow.html#matplotlib.axes.Axes.imshow\n    ax2.set_title('原始输入图片直方图',fontsize=8)\n    ax2.hist(img_original1.flatten(), bins=50, density=True, color='r', edgecolor='k') #bin属性控制直方图横条的数量, density为True则显示的是概率密度\n    ax2.set_xlim(0, 255)  # 设置x轴分布范围\n    ax2.set_ylim(0, 0.15)  # 设置y轴分布范围\n    ax2.grid(True, linestyle=':', linewidth=1)\n\n    plt.subplots_adjust(bottom=0.3)\n    x1 = plt.axes([0.25, 0.2, 0.45, 0.03], facecolor='lightgoldenrodyellow') #控制横轴的left,bottom,width,height位置和大小\n    slider_x1 = Slider(x1, '参数x1', 0.0, 255.,\n                       valfmt='%.f', valinit=91, valstep=1) #slider的输入x必须是一个Axes\n    slider_x1.on_changed(update_trans)\n\n    y1 = plt.axes([0.25, 0.16, 0.45, 0.03],\n                  facecolor='lightgoldenrodyellow')\n    slider_y1 = Slider(y1, '参数y1', 0.0, 255.,\n                       valfmt='%.f', valinit=0, valstep=1)\n    slider_y1.on_changed(update_trans)\n\n    x2 = plt.axes([0.25, 0.06, 0.45, 0.03],\n                  facecolor='white')\n    slider_x2 = Slider(x2, '参数x2', 0.0, 254.,\n                       valfmt='%.f', valinit=138, valstep=1) #valinit表示slider的点的初始位置（即滑块的初始值）\n    slider_x2.on_changed(update_trans)\n\n    y2 = plt.axes([0.25, 0.02, 0.45, 0.03],\n                  facecolor='white')\n    slider_y2 = Slider(y2, '参数y2', 0.0, 255.,\n                       valfmt='%.f', valinit=255, valstep=1)\n    slider_y2.on_changed(update_trans)\n\n    slider_x1.set_val(91)\n    slider_y1.set_val(91)\n    slider_x2.set_val(138)\n    slider_y2.set_val(138)\n    #plt.tight_layout()\n    plt.show()\n\n", "Konwledge_Point": "线性规划简介", "Question": "实现分段线性变换，显示处理前后图像\n2.产生灰度变换函数T1，使得：\n          0.3r                            r < 0.35\ns =     0.105 + 2.6333(r-0.35)                  0.35 ≤ r ≤ 0.65\n          1 + 0.3(r-1)                r > 0.65\n    用T1对原图像rice.jpg进行处理，显示处理前、后的图像(r,s为归一化灰度)。\n\n\nrice.jpg\n\n\n实验仪器\n      Python+OpenCV", "Tag": "算法分析"}
{"Answer": "不知道你这个问题是否已经解决, 如果还没有解决的话: 关于该问题，我找了一篇非常好的博客，你可以看看是否有帮助，链接：关于R语言多水平线性回归分析你还可以看下r语言参考手册中的 r语言 线性模型如果你已经解决了该问题, 非常希望你能够分享一下解决方案, 以帮助更多的人 ^-^", "Konwledge_Point": "线性规划简介", "Question": "在R语言中做多水平线性回归\n我的数据是：低水平层面为团队中的成员；高水平为团队，其中团队层面的数据是从成员层面聚合得到的。\n我的分析模型是：考虑团队特性对团队绩效的影响，检验团队层面变量的调节作用以及个人层面变量的调节作用。\n我主要有两个问题请教大家：一是做多水平回归的时候对两个层面的数据做分析，导入的数据选择哪个层面呢？我在网上搜到一些例子，大多研究的是低水平层面的自变量与因变量的关系，同时考察高水平层面的调节作用，用的也都是低水平的数据，所以像我这样的研究假设因变量是在高水平层面，是否就应该导入高水平层面的数据做分析？二是，导入高水平层面的数据后还想检验低水平层面变量的调节作用该如何实现呢", "Tag": "算法分析"}
{"Answer": "该回答通过自己思路及引用到GPTᴼᴾᴱᴺᴬᴵ搜索,得到内容具体如下：以下是用 Jacobi 迭代法解线性方程组的 MATLAB 函数代码，包括了你提到的步骤 2 到 7：\nfunction Xsolve = myJacobi(A, b, X0, mytol)\n% Jacobi 迭代法解线性方程组 Ax=b\n% 输入参数：\n% A：系数矩阵\n% b：右端常向量\n% X0：初始迭代值，默认为全零向量\n% mytol：允许误差，默认为 1e-6\n% 输出参数：\n% Xsolve：迭代收敛时满足精度的数值解\n\n% 检查输入参数\nif nargin < 4\n    mytol = 1e-6;\nend\nif nargin < 3\n    X0 = zeros(size(b));\nend\nif nargin < 2\n    error('输入参数不足');\nend\n\n% 构造 Jacobi 迭代矩阵\nD = diag(diag(A));\nU = triu(A, 1);\nL = tril(A, -1);\nM = D;\nN = L + U;\n\n% 判断系数矩阵是否可逆\nif abs(det(A)) < mytol\n    error('系数矩阵不可逆');\nend\n\n% 判断系数矩阵主对角元素是否为零\nif any(diag(A) == 0)\n    error('系数矩阵主对角元素有零元素');\nend\n\n% 判断 Jacobi 迭代法是否收敛\nrho = max(abs(eig(M \\ N)));\nif rho >= 1\n    disp('Jacobi 迭代法不收敛');\n    Xsolve = [];\n    return;\nelse\n    disp('Jacobi 迭代法收敛');\nend\n\n% Jacobi 迭代格式\nXn = X0;\nerr = inf;\nwhile err > mytol\n    Xn1 = M \\ (b - N * Xn);\n    err = norm(Xn1 - Xn, inf);\n    Xn = Xn1;\nend\n\nXsolve = Xn;\n\nend\n\n在命令窗口中可以按以下方式调用该函数：\n% 例子：解方程组 Ax=b，其中 A=[4 -1 0; -1 4 -1; 0 -1 4]，b=[15; 10; 10]\nA = [4, -1, 0; -1, 4, -1; 0, -1, 4];\nb = [15; 10; 10];\nXsolve = myJacobi(A, b);\n\n其中，Xsolve 是 Jacobi 迭代法求解得到的数值解。\n希望这个代码能够帮助你解决问题。\n\n如果以上回答对您有所帮助，点击一下采纳该答案～谢谢", "Konwledge_Point": "线性规划简介", "Question": "用jacobi迭代法解线性方程组函数\n1、函数输入形参要求如下，也可以修改得更好、更适合你自己.\nfunction Xsolve=myJacobi(A.b.X0 mytol)\n%A为系数矩阵\n點为右端常向量\nX0为初始层，默认取0.\n%mytol表示允许误差.要求默认值为le-b.\n%Xsolve表示收敛情况下满足精度的数值解\nXnargin表示输入参数个数，下面这一段是简单的判断，你可以编写的更好if nargin<4 %如果参数<4.\nmytol=le-b:\nif nargin<3 %如果参数3\nX0=zeros(size(b))；\nif nargins2\nerror(‘输入参数不足‘)；\nend\nend\nend\n2.第一步描述出矩阵DL.U\n3、第二步要判断系数矩阵是否可逆，用“abs(det(A))<mytol”或者别的方式判断，不满足要提示：\n4. 第三步要判断系数矩阵主对角元素是否为零，\n5、第四步用迭代法基本定理(计算谱半径)判断迭代法是否收敛，要在命令窗口输出是否收敛的结论：\n6、第五步在收敛的基础上进行迭代格式的程序编写：\n7、迭代格", "Tag": "算法分析"}
{"Answer": "\nWhat you are after is applying a Convolution filter to an image, for that you can use PHP's built in  imageconvolution() php.net function.\nFor usage, see Magilvia's example on php.net modified for your purpose:\n<?php \n    $sharpenMatrix = array \n    ( \n        array(-0.5, -0.5, -0.5), \n        array(-0.5, 5, -0.5), \n        array(-0.5, -0.5, -0.5) \n    ); \n\n    // calculate the sharpen divisor \n    $divisor = array_sum(array_map('array_sum', $sharpenMatrix));            \n\n    $offset = 0; \n\n    // apply the matrix \n    imageconvolution($img, $sharpenMatrix, $divisor, $offset); \n?>\n\n$img is a PHP image the convolution matrix (sharpening filter) is applied on\n", "Konwledge_Point": "线性规划简介", "Question": "使用PHP中的线性过滤器锐化图像\n\n\n\nI would like to read an image and sharpen it using a linear filter, which is this matrix:\n\n\n\nH =  [-0.5 -0.5 -0.5; -0.5 5 -0.5; -0.5 -0.5 -0.5]\n\n\n\n\nI know about ImageMagick, is there any possibility to do just that?\n\n    ", "Tag": "算法分析"}
{"Answer": "\nint Delete(LinkList L,int i,ElemType *e)\n/*在带头结点的单链表L中删除第i个元素，并将删除的元素保存到变量*e中*/\n{\nNode * pre,* r;\nint k;\npre=L;\nk=0;\nwhile(pre->next!=NULL&&k<i-1)\n{\n  pre=pre->next;\n  k=k+1;\n}\nif(pre->next==NULL)\n{\n  printf(\"删除结点的位置i不合理！\");\n  return ERROR;\n}\nr=pre->next;\npre->next=r->next;\n*e=r->data;\nfree(r);\nreturn 1;\n}\n\n ", "Konwledge_Point": "线性规划简介", "Question": "线性表链式结构能按序号删除吗\n如果能的话\n\n\n\n用函数List Delete(List L,int P);应该怎么编写程序\n\n\n\n想了好久了但是还是没改出来", "Tag": "算法分析"}
{"Answer": "\nPHP in general in synchronous.\n", "Konwledge_Point": "线性规划简介", "Question": "PHP文件编写操作是线性还是异步？\n\n\n\nI'm wondering because I have a script that writes to the same temp file in a loop. Would that be the best way to go about it?\n\n    ", "Tag": "算法分析"}
{"Answer": "对于常系数非齐次线性微分方程：\ny'' + ay' + by = f(x)\n其中 a 和 b 都是常数，f(x) 是已知函数。\n有两种情况，一种是 f(x) 是指数函数，另一种是 f(x) 是多项式函数。\n对于第一种情况，解的形式为 y = R(x) e^(mx)，其中 m 为常数，R(x) 是一个与 x 相关的函数。\n将 y = R(x) e^(mx) 带入到原方程中，得到：\n R''(x) e^(mx) + (2mR'(x) + aR(x)) e^(mx) + bR(x) e^(mx) = f(x)\n将 e^(mx) 分离出来，得到：\n e^(mx) (R''(x) + 2mR'(x) + (a+bm)R(x)) = f(x)\n因为 e^(mx) 不等于零，所以可以将方程简化为：\nR''(x) + 2mR'(x) + (a+bm)R(x) = f(x) e^(-mx)\n令 Rm(x) 为特解，则有：\nRm''(x) + 2mRm'(x) + (a+bm)Rm(x) = f(x) e^(-mx)\n对于第二种情况，即 f(x) 是多项式函数，解的形式为：\ny = (Ax^k + Bx^(k-1) + ... + C) e^(mx)\n其中 k 是 f(x) 的最高次幂，A, B, ..., C 都是常数，R(x) 是一个与 x 相关的函数。\n将 y 带入到原方程中，得到：\n[A(m^2+kam+b) x^k + ... + C(m^2+am+b)] e^(mx) + f(x) = 0\n因为 e^(mx) 不等于零，所以可以将方程简化为：\n[A(m^2+kam+b) x^k + ... + C(m^2+am+b)] + f(x) e^(-mx) = 0\n注意到上式中的常数项是与 x 无关的，所以不能写成 R(x) = xRm(x) + c 的形式。\n关于为什么书上没有给出这个常数项 c，可能是因为这个常数项并不能代表所有可能的常数项，因为常数项可以是任何常数。同时，书上可能认为这个常数项并不重要，因为它不会影响到 R(x) 的定义和求解。", "Konwledge_Point": "线性规划简介", "Question": "常系数非齐次线性微分方程的问题\n为什么第二种情况不是R（x）=xRm（x）+c？为什么书上没有这个常数项c。", "Tag": "算法分析"}
{"Answer": "引用new bing部分回答作答：非线性薛定谔方程（NLSE）是一个描述波动现象的方程，在物理学和工程学等领域有广泛应用。NLSE 的一般形式为：\n$i\\hbar\\frac{\\partial \\psi}{\\partial t}=-\\frac{\\hbar^2}{2m}\\frac{\\partial^2\\psi}{\\partial x^2}+V(x)\\psi+g(x)|\\psi|^2\\psi$\n其中，$\\psi$ 是波函数，$m$ 是粒子的质量，$V(x)$ 是势能，$g(x)$ 是非线性系数，$|\\psi|^2$ 表示波函数的模方。\n为了求解 NLSE，我们可以采用紧致差分方法（Compact Difference Method），将偏微分方程转化为差分方程进行求解。这里介绍一种四阶紧致差分格式的求解方法。\n假设我们在空间方向上使用均匀网格，网格大小为 $h$，时间步长为 $\\Delta t$，则可以将空间坐标 $x$ 和时间 $t$ 分别离散化为 $x_j=jh$ 和 $t_n=n\\Delta t$。同时，我们采用中心差分法近似计算偏微分方程中的导数项。\n将 NLSE 中的各项代入差分方程中，可以得到如下形式的紧致差分方程：\n$i\\hbar\\frac{\\psi_j^{n+1}-\\psi_j^n}{\\Delta t}=-\\frac{\\hbar^2}{2m}\\frac{\\psi_{j+1}^n-2\\psi_j^n+\\psi_{j-1}^n}{h^2}+V_j\\psi_j^n+g_j|\\psi_j^n|^2\\psi_j^n$\n其中，$\\psi_j^n$ 表示波函数在位置 $x_j$ 和时间 $t_n$ 的值。\n将上述方程进行整理，得到：\n$\\psi_j^{n+1}=\\frac{\\Delta t i\\hbar}{2m}\\frac{\\psi_{j+1}^n-2\\psi_j^n+\\psi_{j-1}^n}{h^2}+(\\frac{\\Delta t i\\hbar}{h^2}V_j+1)\\psi_j^n+\\frac{\\Delta t i\\hbar g_j}{h^2}|\\psi_j^n|^2\\psi_j^n$\n这个方程是一个离散的迭代公式，可以通过多次迭代计算得到 NLSE 的数值解。下面是用 MATLAB 实现这个算法的示例代码。\n% 定义参数\nh = 0.1; % 空间步长\ndt = 0.001; % 时间步长\nx = -10:h:10; % 空间网格\nt = 0:dt:1; % 时间网格\nm = 1; % 粒子质量\nV = 0.5*x.^2; % 势能\ng = 1; % 非线性系数\nhbar = 1; % 普朗克常数\n\n% 初始化波函数\npsi = exp(-x.^2);\npsi_next = zeros(size(x));\n\n% 迭代计算\nfor n = 1:length(t)-1\n    for j = 3:length(x)-2 % 注意边界点的处理\n        % 计算波函数的一阶和二阶导数\n        dpsi = (psi(j+1)-psi(j-1))/(2*h);\n        d2psi = (psi(j+1)-2*psi(j)+psi(j-1))/h^2;\n        % 计算新的波函数值\n        psi_next(j) = psi(j) + dt*1i*hbar/(2*m)*d2psi + ...\n            dt*1i*hbar/(h^2)*V(j)*psi(j) + ...\n            dt*1i*hbar*g/(h^2)*abs(psi(j))^2*psi(j);\n    end\n    % 更新波函数\n    psi = psi_next;\n    % 将边界点的值设置为零\n    psi(1:2) = 0;\n    psi(end-1:end) = 0;\nend\n\n% 绘制波函数的时空演化图像\n[X, T] = meshgrid(x, t);\nPsiReal = real(psi).*exp(-1i*hbar/(2*m)*((x-mean(x)).^2)/hbar*n); % 实部\nPsiReal = repmat(PsiReal, size(X,1), 1);  % 添加这行代码\nPsiImag = imag(psi).*exp(-1i*hbar/(2*m)*((x-mean(x)).^2)/hbar*n); % 虚部\nPsiImag = repmat(PsiImag, size(X,1), 1);  % 添加这行代码\n%Z = abs(psi).^2; % 概率密度\nZ = repmat(abs(psi).^2, length(t), 1);\nfigure;\nmesh(X, T, ones(size(X))*max(abs(psi(:))).*Z, 'facecolor','flat');\nxlabel('Position');\nylabel('Time');\nzlabel('Probability density');\nfigure;\nsurf(real(X), real(T), real(PsiReal), 'facecolor', 'flat');\nxlabel('Position');\nylabel('Time');\nzlabel('Real part');\nfigure;\nsurf(real(X), real(T), real(Z), 'facecolor', 'flat');\nxlabel('Position');\nylabel('Time');\nzlabel('Imaginary part');\n\n这段代码中，我们使用了两重循环来计算每个时间步长中波函数在所有空间点上的值。其中，内层循环遍历空间网格上的所有内部点，使用中心差分法计算波函数在这些点的一阶和二阶导数，并根据紧致差分格式的公式计算出新的波函数值。外层循环则遍历所有的时间步长，通过多次迭代得到波函数的时空演化图像。\n注意到在代码中，我们使用 mesh 函数将波函数的时空演化图像绘制出来，并且将横轴和纵轴分别设为空间坐标和时间。图像的高度表示波函数的概率密度，可以通过调整视角和颜色映射来观察波函数的演化特征。", "Konwledge_Point": "线性规划简介", "Question": "非线性薛定谔方程的四阶紧致差分格式\n非线性薛定谔方程的四阶紧致差分格式求解过程\n要求论述有条理，理论叙述详尽\n题主原理已经写出来了，但是通过原理写不出代码，所以想要有一个对比，希望大家帮帮忙", "Tag": "算法分析"}
{"Answer": "\nGolint is newly released this week: https://github.com/golang/lint\n", "Konwledge_Point": "线性规划简介", "Question": "Go语言的静态代码分析（线性）工具\n\n\n\nIs there a static analysis tool for Go language –like \nlint\n, \npylint\n etc? As far as I googled, I haven't found anything related.\n\n\n\nI may do this as an undergrad senior project in my department. I must be sure that it is not done before. Any help is appreciated.\n\n    ", "Tag": "算法分析"}
{"Answer": "model.coef_[0]是x1的系数，model.coef_[1]是x2 的系数", "Konwledge_Point": "线性规划简介", "Question": "二元线性回归模型怎么把元分别带进去\n有两个因变量，求出来两个系数，请问最后怎么能列出这个式子来？就是希望最后结果是 y=系数1\nX1+系数2\nX2+截距\n\n", "Tag": "算法分析"}
{"Answer": "该回答通过自己思路及引用到GPTᴼᴾᴱᴺᴬᴵ搜索,得到内容具体如下：非线性薛定谔方程（Nonlinear Schrödinger Equation, NLSE）是一个重要的数学模型，被广泛应用于光学、声学、等离子体和量子物理等领域。本文将介绍如何使用Richardson外推法求解非线性薛定谔方程，并推导其四阶精度的理论原理。\n一、非线性薛定谔方程\n非线性薛定谔方程是一个偏微分方程，通常用来描述自由粒子或束缚电子在势场中的运动，其标准形式为：\n$$i\\hbar\\frac{\\partial \\psi}{\\partial t}=-\\frac{\\hbar^2}{2m}\\frac{\\partial^2 \\psi}{\\partial x^2}+V\\psi+g|\\psi|^2\\psi$$\n其中，$\\psi(x,t)$是波函数，描述了粒子在时空中的分布情况；$m$是粒子的质量；$V(x)$是势能函数；$g$是非线性项的系数，描述了粒子之间相互作用的强度。\n二、Richardson外推法\nRichardson外推法是一种常用的数值微分方法，用于提高数值解的精度。其基本思想是，将一个数值解按照一定的步长逐渐逼近真实解，并通过外推法来消除截断误差。\n对于一个一阶微分方程$y'(x)=f(x,y)$，我们可以使用欧拉方法来求解：\n$$y_{n+1}=y_n+hf(x_n,y_n)$$\n其中，$y_n$表示$x_n$处的数值解，$h$表示步长。然而，欧拉方法的精度只有一阶，为了提高精度，我们可以使用Richardson外推法。\n具体来说，我们可以使用两个不同步长的欧拉方法来求解$y(x)$，并将它们的结果进行外推，得到更高精度的数值解。假设$y_{h}$和$y_{2h}$分别表示使用步长$h$和$2h$的欧拉方法得到的数值解，则可以使用以下公式进行外推：\n$$y_{extr}=y_h+\\frac{y_h-y_{2h}}{2^p-1}$$\n其中，$p$表示外推方法的阶数，$y_{extr}$表示外推后的数值解。通过不断缩小步长，我们可以逐渐逼近真实解，并得到更高精度的数值解。\n三、非线性薛定谔方程的四阶Richardson外推法\n对于非线性薛定谔方程，我们可以使用有限差分方法来求解。将空间和时间分别离散化，我们可以得到如下差分方程：\n$$i\\frac{\\psi_{j,k+1}-\\psi_{j,k}}{\\Delta t}=-\\frac{1}{2}\\frac{\\psi_{j+1,k}-2\\psi_{j,k}+\\psi_{j-1,k}}{(\\Delta x)^2}+V_j\\psi_{j,k}+g|\\psi_{j,k}|^2\\psi_{j,k}$$\n其中，$\\psi_{j,k}$表示在$x=j\\Delta x$，$t=k\\Delta t$处的数值解，$\\Delta x$和$\\Delta t$分别表示空间和时间的步长。\n为了提高数值解的精度，我们可以使用四阶中心差分法来求解$\\psi_{j+1,k}$和$\\psi_{j-1,k}$，即：\n$$\\psi_{j+1,k}=\\psi_{j,k}+\\frac{\\Delta x}{6}\\left(2\\psi_{j,k}-\\psi_{j-1,k}+\\psi_{j+2,k}\\right)+O(\\Delta x^4)$$\n$$\\psi_{j-1,k}=\\psi_{j,k}-\\frac{\\Delta x}{6}\\left(2\\psi_{j,k}-\\psi_{j+1,k}+\\psi_{j-2,k}\\right)+O(\\Delta x^4)$$\n将上式代入差分方程中，可以得到：\n$$i\\frac{\\psi_{j,k+1}-\\psi_{j,k}}{\\Delta t}=-\\frac{1}{2}\\frac{1}{(\\Delta x)^2}\\left(\\frac{2}{3}\\psi_{j+1,k}-\\frac{2}{3}\\psi_{j,k}-\\frac{2}{3}\\psi_{j-1,k}+\\frac{1}{6}\\psi_{j+2,k}+\\frac{1}{6}\\psi_{j-2,k}\\right)+V_j\\psi_{j,k}+g|\\psi_{j,k}|^2\\psi_{j,k}$$\n将上式改写为：\n$$i\\frac{\\psi_{j,k+1}-\\psi_{j,k}}{\\Delta t}=\\frac{1}{2}\\frac{1}{(\\Delta x)^2}\\left(-\\frac{1}{3}\\psi_{j+2,k}+2\\psi_{j+1,k}-\\frac{2}{3}\\psi_{j,k}-\\frac{2}{3}\\psi_{j-1,k}+\\frac{1}{6}\\psi_{j-2,k}\\right)+V_j\\psi_{j,k}+g|\\psi_{j,k}|^2\\psi_{j,k}$$\n接下来，我们可以使用四阶Richardson外推法来提高数值解的精度。假设$\\psi_{h,j,k}$和$\\psi_{2h,j,k}$分别表示使用步长$h$和$2h$的差分方法得到的数值解，则可以使用以下公式进行外推：\n$$\\psi_{extr,j,k}=\\psi_{h,j,k}+\\frac{\\psi_{h,j,k}-\\psi_{2h,j,k}}{2^4-1}$$\n其中，$2^4-1=15$表示外推方法的阶数，$\\psi_{extr,j,k}$表示外推后的数值解。通过不断缩小步长，我们可以逐渐逼近真实解，并得到更高精度的数值解。\n四、MATLAB代码实现\n下面给出使用MATLAB实现非线性薛定谔方程的四阶Richardson外推法的示例代码。其中，我们选择了谐振子势场$V_j=\\frac{1}{2}\\omega^2x_j^2$，并使用了Crank-Nicolson方法进行时间离散化。\n% Parameters\nL = 10; % Spatial domain [-L,L]\nN = 2^8; % Number of spatial grid points\nx = linspace(-L,L,N+1); x(end) = []; % Spatial grid\nh = x(2) - x(1); % Spatial step size\nT = 10; % Final time\ndt = h^2/4; % Time step size\nM = floor(T/dt); % Number of time steps\nomega = 1; % Frequency of harmonic oscillator\ng = 1; % Nonlinear coefficient\npsi0 = exp(-(x.^2)/2); % Initial condition\n\n% Construct the matrix for the Crank-Nicolson method\nA = diag(-1/2*ones(N-1,1),1) + diag(-1/2*ones(N-1,1),-1) + diag(ones(N,1));\nA(1,1) = -1; A(N,N) = -1; A = A/h^2;\n\n% Construct the matrix for the harmonic oscillator potential\nV = diag(1/2*omega^2*x.^2);\n\n% Initialize the solution\npsi = psi0;\n\n% Time integration using Richardson extrapolation\npsi_old = psi;\nfor k = 1:M\n    % Crank-Nicolson method\n    psi_new = (eye(N) - 1i*dt/2*A - 1i*dt*V)*psi_old;\n    psi_new = (eye(N) + 1i*dt/2*A + 1i*dt*V)*psi_new;\n    \n    % Richardson extrapolation\n    if k > 1\n        psi_extr = psi_h + (psi_h - psi_2h)/15;\n        err = norm(psi_extr - psi_new);\n        if err < 1e-10 % Exit if the error is small enough\n\n或者MATLAB实现非线性薛定谔方程的四阶Richardson外推法的示例代码如下：\n% 设置谐振子势场参数\nomega = 1;\n\n% 设置空间离散化参数\nL = 20; % 区间长度\nN = 256; % 离散化点数\ndx = L/N; % 离散化步长\nx = linspace(-L/2, L/2, N); % 离散化区间\n\n% 设置时间离散化参数\nT = 10; % 时间总长\ndt = 0.01; % 时间离散化步长\nM = T/dt; % 时间离散化点数\nt = linspace(0, T, M); % 时间离散化区间\n\n% 初始化波函数\npsi = exp(-x.^2/2)/sqrt(sqrt(pi));\n\n% 计算哈密顿矩阵\nA = zeros(N,N);\nfor j=2:N-1\n    A(j,j-1) = -1/2/dx^2;\n    A(j,j) = 1/dx^2+1/2*omega^2*x(j)^2;\n    A(j,j+1) = -1/2/dx^2;\nend\nA(1,1) = 1/dx^2+1/2*omega^2*x(1)^2;\nA(1,2) = -1/2/dx^2;\nA(N,N) = 1/dx^2+1/2*omega^2*x(N)^2;\nA(N,N-1) = -1/2/dx^2;\n\n% 计算演化算符\nB = eye(N)+1i*dt/2*A;\nC = eye(N)-1i*dt/2*A;\n\n% 时间演化\npsi_store = zeros(N,M);\npsi_store(:,1) = psi;\nfor n=2:M\n    psi1 = C\\B*psi;\n    psi2 = C\\B*psi1;\n    psi3 = C\\B*psi2;\n    psi4 = C\\B*psi3;\n    psi_new = (16/15*psi4-1/15*psi3)/dt;\n    psi = psi_new;\n    psi_store(:,n) = psi;\nend\n\n% 绘制波函数演化图像\nfigure;\nfor n=1:M\n    plot(x,abs(psi_store(:,n)).^2,'b');\n    xlim([-L/2 L/2]);\n    ylim([0 0.5]);\n    xlabel('x');\n    ylabel('|\\psi(x,t)|^2');\n    title(['t=' num2str(t(n))]);\n    drawnow;\nend\n\n以上代码实现了非线性薛定谔方程的四阶Richardson外推法，其中谐振子势场的参数为$ω=1$，空间离散化采用了256个离散化点，时间离散化采用了0.01的步长，总共演化了10个时间单位。通过绘制波函数演化图像，可以直观地观察到波函数的演化情况。\n\n如果以上回答对您有所帮助，点击一下采纳该答案～谢谢", "Konwledge_Point": "线性规划简介", "Question": "非线性薛定谔方程的四阶Richardson外推法\n用Richardson外推法来求解非线性薛定谔方程的理论推导过程\n要求精度是四阶，理论原理要详尽，过程要完善", "Tag": "算法分析"}
{"Answer": "你好，请问你解决这个问题了吗，能否教一下咋计算yolov5的map", "Konwledge_Point": "线性规划简介", "Question": "yolov5中mAP的计算和coco中mAP的计算有什么区别\nyolov5官方计算的是mAP0.5和mAP0.5:0.95,这两个跟大部分论文里面计算的方法都不太一样,比如coco里面的,会计算一个总的mAP,怎么处理这个问题", "Tag": "算法分析"}
{"Answer": "可以尝试使用多元线性回归模型，相关资料可以看看https://ww2.mathworks.cn/help/stats/multiple-linear-regression-1.html?s_tid=CRUX_lftnav", "Konwledge_Point": "线性规划简介", "Question": "多元线性回归是否可以用来整合拟合优度指标。\n我想整合拟合优度指标来优选概率分布,就是能否用多元线性回归来整合指标。导师电气方向的不懂线性回归，理学院问了2个老师也不知道，只好来论坛找大神们了\n\n\n\n底下是我列的表，Y是排行，X123是概率分布拟合风速的拟合优度指标。我列的表是特例，3个指标，指标越小排行越高。是否可以强行把Y弄成排名，X弄指标，形成多元线性回归。因为我看一般都多元线性回归例子里面x和y是有特定公式关系的，而我这种是强行把指标和排行弄成了多元线性回归，是否可以\n\n\n\n再就是请问一下大家，有没有什么方法能整合多个指标然后进行排行，比如熵权法，TOPSIS法这种的\n\n\n\n\n\n\n ", "Tag": "算法分析"}
{"Answer": "model.coef_斜率model.intercept_截距", "Konwledge_Point": "线性规划简介", "Question": "LinearRegression没有coef，我想要求线性回归的系数\njieguo=pd.DataFrame()\ndate=pd.DataFrame()\nfor g in CID:\n    res =data[data['ID']==g]\n    if res['time'].max==1:\n        k=0\n    else:\n        X = res['time'].values.reshape(-1, 1)\n        Y = res['count'].values.reshape(-1, 1)\n        model = LinearRegression().fit(X, Y)\n        \nk = model.coef\n        jieguo['K'] = k\n    jieguo['ID']=g\n    date = pd.concat([date, jieguo], ignore_index=True)\n\n\nTraceback (most recent call last):\n  File \"F:\\学习\\wer\\w\\F变化趋势.py\", line 27, in \n    KK = model.coef\nAttributeError: 'LinearRegression' object has no attribute 'coef'", "Tag": "算法分析"}
{"Answer": "\nI tested your code on PHP 5.3.9. To do so I had to translate [] to array(), and I also had to correct your line #12: from $a=new MyTest($size), to $mytest=new MyTest($size) (BTW, the constructor argument gets silently ignored, funny). I also added this code:\necho \"================\".PHP_EOL;\necho \"Testing Function\".PHP_EOL;\nfor($size = 1000; $size < 1000000; $size *= 2) {\n    $start = milliseconds();\n    for ($a=array(), $i=0;$i<$size;$i++) {\n        my_push($a);\n    }\n    $end = milliseconds();\n    echo \"Array Size $size\".PHP_EOL;\n    echo $end - $start . \" milliseconds to perform\".PHP_EOL;\n    echo \"memory usage: \".memory_get_usage().\" , real: \".memory_get_usage(true).PHP_EOL;\n}\n\nfunction my_push(&$a)\n{\n   $a[] = array(new stdClass());\n}\n\nI added the memory usage line to your loops at the same point, added an unset($mytest); after the object case (to get a more consistent memory log), and also replaced your 5000000's with 1000000's because I only have 2GB of RAM. This is what I got:\nTesting Objects\nArray Size 1000\n2 milliseconds to perform\nmemory usage: 1666376 , real: 1835008\nArray Size 2000\n5 milliseconds to perform\nmemory usage: 2063280 , real: 2097152\nArray Size 4000\n10 milliseconds to perform\nmemory usage: 2857008 , real: 2883584\nArray Size 8000\n19 milliseconds to perform\nmemory usage: 4444456 , real: 4718592\nArray Size 16000\n44 milliseconds to perform\nmemory usage: 7619392 , real: 8126464\nArray Size 32000\n103 milliseconds to perform\nmemory usage: 13969256 , real: 14417920\nArray Size 64000\n239 milliseconds to perform\nmemory usage: 26668936 , real: 27262976\nArray Size 128000\n588 milliseconds to perform\nmemory usage: 52068368 , real: 52690944\nArray Size 256000\n1714 milliseconds to perform\nmemory usage: 102867104 , real: 103546880\nArray Size 512000\n5452 milliseconds to perform\nmemory usage: 204464624 , real: 205258752\n================\nTesting Array\nArray Size 1000\n1 milliseconds to perform\nmemory usage: 18410640 , real: 20709376\nArray Size 2000\n4 milliseconds to perform\nmemory usage: 18774760 , real: 20709376\nArray Size 4000\n7 milliseconds to perform\nmemory usage: 19502976 , real: 20709376\nArray Size 8000\n13 milliseconds to perform\nmemory usage: 20959360 , real: 21233664\nArray Size 16000\n29 milliseconds to perform\nmemory usage: 23872176 , real: 24379392\nArray Size 32000\n61 milliseconds to perform\nmemory usage: 29697720 , real: 30146560\nArray Size 64000\n124 milliseconds to perform\nmemory usage: 41348856 , real: 41943040\nArray Size 128000\n280 milliseconds to perform\nmemory usage: 64651088 , real: 65273856\nArray Size 256000\n534 milliseconds to perform\nmemory usage: 111255536 , real: 111935488\nArray Size 512000\n1085 milliseconds to perform\nmemory usage: 204464464 , real: 205258752\n================\nTesting Function\nArray Size 1000\n357 milliseconds to perform\nmemory usage: 18410696 , real: 22544384\nArray Size 2000\n4 milliseconds to perform\nmemory usage: 18774768 , real: 22544384\nArray Size 4000\n9 milliseconds to perform\nmemory usage: 19503008 , real: 22544384\nArray Size 8000\n17 milliseconds to perform\nmemory usage: 20959392 , real: 22544384\nArray Size 16000\n36 milliseconds to perform\nmemory usage: 23872208 , real: 24379392\nArray Size 32000\n89 milliseconds to perform\nmemory usage: 29697720 , real: 30146560\nArray Size 64000\n224 milliseconds to perform\nmemory usage: 41348888 , real: 41943040\nArray Size 128000\n529 milliseconds to perform\nmemory usage: 64651088 , real: 65273856\nArray Size 256000\n1587 milliseconds to perform\nmemory usage: 111255616 , real: 111935488\nArray Size 512000\n5244 milliseconds to perform\nmemory usage: 204464512 , real: 205258752\n\nAs you can see, appending to the array inside a function call costs almost as much as (and has the same non-linear behavior as) doing it inside your original method call. One thing can be said for sure:\nIt's the function calls that eat up CPU time!\nRegarding the non-linear behavior, it becomes really evident only above a certain threshold. While all three cases have the same memory behavior (because of incomplete gargabe collection this is only evident among the \"plain array\" and the \"array inside function\" case, in this log), it is the \"array inside method\" and the \"array inside function\" cases that have the same execution time behavior. This means that it's the function calls themselves that cause a non-linear increase in time. It seems to me that this can be said:\nThe amount of data that is around during a function call influences its duration.\nTo verify this I replaced all $a[] with $a[0] and all 1000000 with 5000000 (to get similar total execution times) and obtained this output:\nTesting Objects\nArray Size 1000\n2 milliseconds to perform\nmemory usage: 1302672 , real: 1572864\nArray Size 2000\n4 milliseconds to perform\nmemory usage: 1302672 , real: 1572864\nArray Size 4000\n8 milliseconds to perform\nmemory usage: 1302672 , real: 1572864\nArray Size 8000\n15 milliseconds to perform\nmemory usage: 1302672 , real: 1572864\nArray Size 16000\n31 milliseconds to perform\nmemory usage: 1302672 , real: 1572864\nArray Size 32000\n62 milliseconds to perform\nmemory usage: 1302672 , real: 1572864\nArray Size 64000\n123 milliseconds to perform\nmemory usage: 1302672 , real: 1572864\nArray Size 128000\n246 milliseconds to perform\nmemory usage: 1302672 , real: 1572864\nArray Size 256000\n493 milliseconds to perform\nmemory usage: 1302672 , real: 1572864\nArray Size 512000\n985 milliseconds to perform\nmemory usage: 1302672 , real: 1572864\nArray Size 1024000\n1978 milliseconds to perform\nmemory usage: 1302672 , real: 1572864\nArray Size 2048000\n3965 milliseconds to perform\nmemory usage: 1302672 , real: 1572864\nArray Size 4096000\n7905 milliseconds to perform\nmemory usage: 1302672 , real: 1572864\n================\nTesting Array\nArray Size 1000\n1 milliseconds to perform\nmemory usage: 1302464 , real: 1572864\nArray Size 2000\n3 milliseconds to perform\nmemory usage: 1302464 , real: 1572864\nArray Size 4000\n5 milliseconds to perform\nmemory usage: 1302464 , real: 1572864\nArray Size 8000\n10 milliseconds to perform\nmemory usage: 1302464 , real: 1572864\nArray Size 16000\n20 milliseconds to perform\nmemory usage: 1302464 , real: 1572864\nArray Size 32000\n40 milliseconds to perform\nmemory usage: 1302464 , real: 1572864\nArray Size 64000\n80 milliseconds to perform\nmemory usage: 1302464 , real: 1572864\nArray Size 128000\n161 milliseconds to perform\nmemory usage: 1302464 , real: 1572864\nArray Size 256000\n322 milliseconds to perform\nmemory usage: 1302464 , real: 1572864\nArray Size 512000\n646 milliseconds to perform\nmemory usage: 1302464 , real: 1572864\nArray Size 1024000\n1285 milliseconds to perform\nmemory usage: 1302464 , real: 1572864\nArray Size 2048000\n2574 milliseconds to perform\nmemory usage: 1302464 , real: 1572864\nArray Size 4096000\n5142 milliseconds to perform\nmemory usage: 1302464 , real: 1572864\n================\nTesting Function\nArray Size 1000\n1 milliseconds to perform\nmemory usage: 1302464 , real: 1572864\nArray Size 2000\n4 milliseconds to perform\nmemory usage: 1302464 , real: 1572864\nArray Size 4000\n6 milliseconds to perform\nmemory usage: 1302464 , real: 1572864\nArray Size 8000\n14 milliseconds to perform\nmemory usage: 1302464 , real: 1572864\nArray Size 16000\n26 milliseconds to perform\nmemory usage: 1302464 , real: 1572864\nArray Size 32000\n53 milliseconds to perform\nmemory usage: 1302464 , real: 1572864\nArray Size 64000\n105 milliseconds to perform\nmemory usage: 1302464 , real: 1572864\nArray Size 128000\n212 milliseconds to perform\nmemory usage: 1302464 , real: 1572864\nArray Size 256000\n422 milliseconds to perform\nmemory usage: 1302464 , real: 1572864\nArray Size 512000\n844 milliseconds to perform\nmemory usage: 1302464 , real: 1572864\nArray Size 1024000\n1688 milliseconds to perform\nmemory usage: 1302464 , real: 1572864\nArray Size 2048000\n3377 milliseconds to perform\nmemory usage: 1302464 , real: 1572864\nArray Size 4096000\n6814 milliseconds to perform\nmemory usage: 1302464 , real: 1572864\n\nNote how the times are almost perfectly linear now. Of course, the array size is stuck to 1 now. Note also how the differences of the execution times of the three cases are less pronounced than before. Remember that the innermost operation is the same in all cases.\nI'm not going to try to fully explain all this (gargabe collection on function call? memory fragmentation? ...?), but I think that I have nonetheless collected some useful information, for everyone here and for myself too.\n", "Konwledge_Point": "线性规划简介", "Question": "全局数组的PHP对象数组不是线性扩展吗？\n\n\n\nThere is a major performance issue when using in-object array's as a property versus using a global php array variable, why?\n\n\n\nTo benchmark this problem I created the following benchmark that stores an increasingly larger array with an stdClass as a node, two tests were run one using an array property in a class the other a global array.\n\n\n\nThe test code\n\n\n\nini_set('memory_limit', '2250M');\nclass MyTest {\n    public $storage = [];\n    public function push(){\n        $this->storage[] = [new stdClass()];\n    }\n}\n\necho \"Testing Objects\".PHP_EOL;\nfor($size = 1000; $size < 5000000; $size *= 2) {\n    $start = milliseconds();\n    for ($a=new MyTest(), $i=0;$i<$size;$i++) {\n        $a->push();\n    }\n    $end = milliseconds();\n    echo \"Array Size $size\".PHP_EOL;\n    echo $end - $start . \" milliseconds to perform\".PHP_EOL;\n}\necho \"================\".PHP_EOL;\necho \"Testing Array\".PHP_EOL;\nfor($size = 1000; $size < 5000000; $size *= 2) {\n    $start = milliseconds();\n    for ($a=[], $i=0;$i<$size;$i++) {\n        $a[] = [new stdClass()];\n    }\n    $end = milliseconds();\n    echo \"Array Size $size\".PHP_EOL;\n    echo $end - $start . \" milliseconds to perform\".PHP_EOL;\n}\n\n\n\n\nAnd the shocking results:\n\n\n\nTesting Objects\nArray Size 1000\n2 milliseconds to perform\nArray Size 2000\n3 milliseconds to perform\nArray Size 4000\n6 milliseconds to perform\nArray Size 8000\n12 milliseconds to perform\nArray Size 16000\n35 milliseconds to perform\nArray Size 32000\n97 milliseconds to perform\nArray Size 64000\n246 milliseconds to perform\nArray Size 128000\n677 milliseconds to perform\nArray Size 256000\n2271 milliseconds to perform\nArray Size 512000\n9244 milliseconds to perform\nArray Size 1024000\n31186 milliseconds to perform\nArray Size 2048000\n116123 milliseconds to perform\nArray Size 4096000\n495588 milliseconds to perform\n================\nTesting Array\nArray Size 1000\n1 milliseconds to perform\nArray Size 2000\n2 milliseconds to perform\nArray Size 4000\n4 milliseconds to perform\nArray Size 8000\n8 milliseconds to perform\nArray Size 16000\n28 milliseconds to perform\nArray Size 32000\n61 milliseconds to perform\nArray Size 64000\n114 milliseconds to perform\nArray Size 128000\n245 milliseconds to perform\nArray Size 256000\n494 milliseconds to perform\nArray Size 512000\n970 milliseconds to perform\nArray Size 1024000\n2003 milliseconds to perform\nArray Size 2048000\n4241 milliseconds to perform\nArray Size 4096000\n14260 milliseconds to perform\n\n\n\n\nNow besides the obvious overhead of the object calls itself the object array property scales terribly sometimes taking 3 - 4 times longer when the array becomes larger but this is not the case with the standard global array variable.\n\n\n\nAny thoughts or answers regarding this problem and is this a possible bug with the PHP engine?\n\n    ", "Tag": "算法分析"}
{"Answer": "可以。但自变量、因变量都要转化为数值，例如 ABC 转化为 123，因变量也转化为 123.这样处理后，回归分析的结果，并不取决于表达形式，还是取决于自变量因变量的关系是否满足回归方程的假设。", "Konwledge_Point": "线性规划简介", "Question": "自变量是无序多分类变量，因本量是等级变量可以做回归分析吗\n自变量是无序多分类变量，因本量是等级变量可以做回归分析吗？比如自变量是不同地区（A,B,C），因变量是高血压分级（1级，2级，3级）", "Tag": "算法分析"}
{"Answer": "你这属于滑动空间嵌套滑动空间问题  需要重写listview  要不然就会出现显示不全的问题 还有滑动冲突问题 \r\n自定义一个listview 继承 listview 重写onmeasure 方法 重新测量高度 \r\n\r\n@Override\r\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\r\n        int measureSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE >> 2, MeasureSpec.AT_MOST);\r\n\r\n        super.onMeasure(widthMeasureSpec, measureSpec);\r\n\r\n    }\r\n\t\t\r\n很简单 重写这一个方法就可以 然后再xml 文件中引用就好了 你试一下", "Konwledge_Point": "线性规划简介", "Question": "Android 线性布局ScrollView嵌套以及TextView设置background的小问题\nScrollView 部分布局\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    布局效果图：\n    ![图片说明](https://img-ask.csdn.net/upload/201804/24/1524541534_568444.png)\n\n    实际效果图：\n    ![图片说明](https://img-ask.csdn.net/upload/201804/24/1524541656_487597.png)\n\n    期望效果：\n      实现类似于饿了么的那种界面，把listview的界面填充出去，如图下：\n\n![图片说明](https://img-ask.csdn.net/upload/201804/24/1524542251_73813.png)\n\n        TextView的设置background的bug:\n\n        TextView代码：\n        \n                效果：\n                ![图片说明](https://img-ask.csdn.net/upload/201804/24/1524542466_880111.png)\n                background的效果并没有运用上去，附其他可用的TextView的效果，如图下：\n                ![图片说明](https://img-ask.csdn.net/upload/201804/24/1524542599_493676.png)\n", "Tag": "算法分析"}
{"Answer": "\nThe control point arguments are helpfully organised into this layout:\nx1  , y1  ,\nx1' , y1' ,\n\nx2  , y2  ,\nx2' , y2' ,\n\nx3  , y3  ,\nx3' , y3' ,\n\nx4  , y4  ,\nx4' , y4'\n\nFor each set of coordinates, x_ and y_ are the source points, and x_' and y_' are the targets.\nSo it's taking the top-left corner and moving it up a bit, the bottom-left is being moved down, the top-right is being moved down and the bottom-right is being moved up, producing the perspective result.\n", "Konwledge_Point": "线性规划简介", "Question": "在Imagick中双线性失真中的参数是什么意思\n\n\n\nI was referring example of \nImagick::distortImage\n\n\n\nNow look at Example 1 which generates following image\n\n\n\n\n\n\nI got confused while looking at below part of code.\n\n\n\n/* Control points for the distortion */\n$controlPoints = array( 10, 10, \n                        10, 5,\n\n                        10, $im->getImageHeight() - 20,\n                        10, $im->getImageHeight() - 5,\n\n                        $im->getImageWidth() - 10, 10,\n                        $im->getImageWidth() - 10, 20,\n\n                        $im->getImageWidth() - 10, $im->getImageHeight() - 10,\n                        $im->getImageWidth() - 10, $im->getImageHeight() - 30);\n\n\n\n\nNow can anybody tell me what this 16 points exactly means ?\n\n    ", "Tag": "算法分析"}
{"Answer": "1. 设决策变量 x = [ x1'  x2'  … xn']， xi表示第i个人是否做m项工作，xi = [xi1 xi2 … xim]，xij取1表示第i个人做第j项工作，xij取0表示第i个人不做第j项工作；\n2. 目标函数 sum( Cij * xij ) 最小化\n3. 约束条件：第i个人最多做1项工作，sum( xi ) <= 1\n                      第j项工作有且仅有1人做，sum( xj ) = 1\nMatlab代码：\n \n\n% 目标函数\nC = [6 2 6 7 6\n    7 5 3 8 3\n    1 10 7 4 2\n    3 9 2 7 11\n    7 2 6 5 8\n    5 6 4 1 3];\nC2 = C';\nf = C2(:); \n\n% 约束条件\n[n,m] = size(C);\nA =  kron( eye(n),ones(1,m) );   \nb = ones(n,1);\nAeq =  repmat( eye(m),1,n );\nbeq = ones(m,1);\nlb = zeros(m*n,1);   % 下限\nub = ones(m*n,1);    % 上限\n\nintcon = 1:m*n;\nx = intlinprog(f,intcon,A,b,Aeq,beq,lb,ub);\ny = f'*x\n\n% 显示结果\nfor ii = 1:n\n   disp(['第' num2str(ii)  '人：'])\n   ind =  find( x( (ii-1)*m+(1:m) ) == 1);\n   if isempty(ind)\n       disp('无工作')\n   else\n       disp(['第' num2str(ind)  '项工作'])\n   end\nend\n结果：\n\n总时间消耗\ny =\n\n     9\n\n第1人：\n无工作\n第2人：\n第5项工作\n第3人：\n第1项工作\n第4人：\n第3项工作\n第5人：\n第2项工作\n第6人：\n第4项工作\n ", "Konwledge_Point": "线性规划简介", "Question": "matlab里用0-1整数线性规intlinprog求解 不会啊\n\n\n\n ", "Tag": "算法分析"}
{"Answer": "梯度优化的时候训练参数值没发计算，加个数据归一化处理。", "Konwledge_Point": "线性规划简介", "Question": "线性回归，回答正确加酬金（我开设了几个问题）\n问题遇到的现象和发生背景\n\n\n输出空值，线性回归计算\n\n\n问题相关代码，请勿粘贴截图\n\n\nimport\n cv2\n\nimport\n numpy \nas\n np\n\nimport\n matplotlib.pyplot \nas\n plt\n\n\nimg = cv2.imread(\nr'C:\\Users\\Xpc\\Desktop\\weixin2222 change40.jpg'\n)\nhsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\nlow_hsv = np.array([\n0\n, \n0\n, \n221\n])\nhigh_hsv = np.array([\n180\n, \n30\n, \n255\n])\nmask = cv2.inRange(hsv, lowerb=low_hsv, upperb=high_hsv)\n\n\nlist_y = []\nlist_x = []\n\n\nfor\n i \nin\n \nrange\n(\nlen\n(mask)):\n    xmax = []\n    \nfor\n j \nin\n \nrange\n(\nlen\n(mask[i])):\n        \nif\n mask[i][j] == \n0\n:\n            list_x.append(j)\n            list_y.append(\nlen\n(mask)-i)\n\nplt.plot(list_x, list_y, \n'o'\n, color=\n'r'\n)\nplt.show()\n\nx_array=np.array(list_x)\nx_array=x_array/\n400\n\ny_array=np.array(list_y)\ny_array=y_array*\n0.2\n/\n400\n\n\nz40=np.stack((x_array,y_array),axis=\n0\n).T\nz0=[]\n\nfor\n i \nin\n \nrange\n(\n0\n,z40.shape[\n0\n],\n30\n):\n    z1=z40[i,:]\n    z0.append(z1)\nz0=np.array(z0)\n\nx_array=z0[:,\n0\n]\ny_array=z0[:,\n1\n]\n\nprint\n(x_array)\n\nprint\n(y_array)\n\nlist_x1=[]\n\nfor\n i \nin\n \nrange\n(\n0\n,\nlen\n(x_array)):\n    list_x1.append(\n40\n)\nx1_array=np.array(list_x1)\n\nlist_x0=[]\n\nfor\n i \nin\n \nrange\n(\n0\n,\nlen\n(x_array)):\n    list_x0.append(\n1\n)\nx0=np.array(list_x0)\nx1=x_array\nx2=x1_array\nx3=x1*x2\nx4=x1*x1\nx5=x2*x2\nlabel40=y_array\n\n\n\nz40=np.stack((x0,x1,x2,x3,x4,x5),axis=\n0\n).T\n\nrescombine = z40\nlabels= y_array\ndata=rescombine\n\nnp.seterr(divide=\n'ignore'\n,invalid=\n'ignore'\n)\n\nclass\n \nLinearRegression\n:\n    \ndef\n \n__init__\n(\nself,data,labels\n):\n        self.data = data\n        self.labels = labels\n        num_features = \nlen\n(data[\n0\n])\n        self.theta = np.zeros((num_features,\n1\n))\n        \n\n\n    \ndef\n \ntrain\n(\nself,alpha,num_iterations = \n500\n):\n       \n        cost_history = self.gradient_descent(alpha,num_iterations)\n        \nreturn\n self.theta,cost_history\n        \n    \ndef\n \ngradient_descent\n(\nself,alpha,num_iterations\n):\n        cost_history= []\n        \nfor\n _ \nin\n \nrange\n(num_iterations):\n            self.gradient_step(alpha)\n            cost_history.append(self.cost_function(self.data,self.labels))\n        \nreturn\n cost_history\n        \n        \n    \ndef\n \ngradient_step\n(\nself,alpha\n):    \n        num_examples = data.shape[\n0\n]\n        prediction = LinearRegression.hypothesis(self.data,self.theta)\n        delta = prediction - self.labels\n        theta = self.theta\n        theta = theta - alpha*(\n1\n/num_examples)*(np.dot(delta.T,self.data)).T\n        self.theta = theta\n        \n        \n    \ndef\n \ncost_function\n(\nself,data,labels\n):\n        self.m = \nlen\n(labels) \n        delta = LinearRegression.hypothesis(data,self.theta) - labels\n        cost = (\n1\n/\n2\n)*np.dot(delta.T,delta)/self.m\n        \nreturn\n cost[\n0\n][\n0\n]\n        \n    \n    \ndef\n \nhypothesis\n(\ndata,theta\n):   \n        predictions = np.dot(data,theta)\n        \nreturn\n predictions\n        \n\nx_train = rescombine\n\ny_train = labels\n\nnum_iterations = \n500\n\nlearning_rate = \n0.01\n  \n\n\nlinear_regression = LinearRegression(x_train, y_train)\n\n(theta, cost_history) = linear_regression.train(learning_rate, num_iterations)\n\n\n\n\nprint\n (theta, cost_history)\n\nprint\n(\nlen\n( cost_history))\n\n\n\n\n\n\n\n运行结果及报错内容\n\n\n[0.3025 0.315  0.3275 0.3425 0.36   0.365  0.3775 0.395  0.41   0.4325\n 0.4475 0.46   0.4825 0.4925 0.5075 0.52   0.5375 0.5625 0.995  0.5825\n 0.9825 0.6    0.945  0.95   0.955  0.9525 0.63   0.6475 0.6475 0.655\n 0.8975 0.86   0.8125 0.685  0.805  0.71   0.785  0.7475 0.8225]\n[0.1365 0.1305 0.125  0.121  0.1175 0.114  0.111  0.1065 0.103  0.0985\n 0.0945 0.092  0.0895 0.087  0.0845 0.082  0.0795 0.0775 0.0755 0.074\n 0.0735 0.0725 0.072  0.0715 0.071  0.0705 0.0695 0.069  0.0685 0.068\n 0.068  0.0675 0.067  0.0665 0.0665 0.066  0.066  0.0655 0.0655]\n[[nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n  nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n  nan nan nan]\n [nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n  nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n  nan nan nan]\n [nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n  nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n  nan nan nan]\n [nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n  nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n  nan nan nan]\n [nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n  nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n  nan nan nan]\n [nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n  nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n  nan nan nan]] [6115546.293053937, 4014534661896851.5, 2.635330971147491e+24, 1.729956249576308e+33, 1.1356253382264945e+42, 7.454783374654096e+50, 4.893673405509658e+59, 3.2124393421296037e+68, 2.1087975579333355e+77, 1.3843147423906104e+86, 9.087298582980243e+94, 5.965333822395535e+103, 3.915928071216269e+112, 2.5706009278759203e+121, 1.687464378870506e+130, 1.1077316588031153e+139, 7.27167603227295e+147, 4.7734730607470265e+156, 3.1335341344346484e+165, 2.0570004369377248e+174, 1.3503126553064964e+183, 8.864092755348704e+191, 5.818810929946509e+200, 3.819743494677929e+209, 2.5074608095693e+218, 1.6460162103256778e+227, 1.080523114983515e+236, 7.093066244971383e+244, 4.656225124468534e+253, 3.0565670277085482e+262, 2.006475577346884e+271, 1.3171457409549063e+280, 8.646369397676056e+288, 5.675886990825303e+297, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan]\n500\n\n\n我的解答思路和尝试过的方法\n\n\n很懵\n\n\n我想要达到的结果\n\n\n正常运算", "Tag": "算法分析"}
{"Answer": "如果你的温度-时间曲线可以用分段函数来拟合，那么你可以将分段函数的参数作为优化变量，使用Levenberg–Marquardt算法对这些参数进行拟合，从而得到最优的参数解。\n具体来说，你需要首先定义一个分段函数的模型，比如：\ndef piecewise_func(t, params):\n    \"\"\"\n    分段函数模型，其中params是一个列表，包含每个段的参数\n    \"\"\"\n    num_segments = len(params) // 3\n    result = np.zeros_like(t)\n    for i in range(num_segments):\n        offset = i * 3\n        a, b, c = params[offset:offset+3]\n        result[t >= a] = b * (t[t >= a] - a) + c\n    return result\n\n在上面的代码中，我们假设分段函数有多个段，每个段的参数包括一个起始时间 $a$，一个斜率 $b$ 和一个截距 $c$，并且将这些参数存储在一个列表 params 中。然后，我们使用一个循环来逐个计算每个段的函数值，并将它们组合起来得到整个分段函数的函数值。\n接下来，你可以使用 scipy.optimize.curve_fit 函数来对分段函数进行拟合。具体来说，你需要将分段函数模型作为第一个参数传递给 curve_fit 函数，并将时间和温度数据作为第二个和第三个参数传递进去。然后，你需要给出每个分段的初始参数值，将它们组合成一个初始参数列表，并将它作为 p0 参数传递给 curve_fit 函数。最后，你可以使用 method='lm' 参数指定使用Levenberg–Marquardt算法进行拟合。\n下面是一个示例代码，其中分段函数有两个段：\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\n# 定义分段函数模型\ndef piecewise_func(t, params):\n    \"\"\"\n    分段函数模型，其中params是一个列表，包含每个段的参数\n    \"\"\"\n    num_segments = len(params) // 3\n    result = np.zeros_like(t)\n    for i in range(num_segments):\n        offset = i * 3\n        a, b, c = params[offset:offset+3]\n        result[t >= a] = b * (t[t >= a] - a) + c\n    return result\n\n# 生成一些数据\nt = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\ny = np.array([20, 21, 25, 28, 30, 30, 28, 25, 22, 20])\n\n# 定义初始参数值\np0 = [2, 2, 20, 6, -2, 30]\n\n# 对分段函数进行拟合\nparams, _ = curve_fit(piecewise_func, t, y, p0=p0, method='lm')\n\n# 输出拟合结果\n\n拟合结果 params 是一个包含每个分段的参数的列表。假设我们在上面的代码中使用了初始参数值 [2, 2, 20, 6, -2, 30]，表示分段函数有两个段，第一个段的起始时间为 2，斜率为 2，截距为 20，第二个段的起始时间为 6，斜率为 -2，截距为 30。对这些初始参数进行拟合后，可以得到最优的参数值：\n>>> print(params)\n[2.0, 2.33333333, 20.66666667, 6.0, -2.0, 30.0]\n\n可以看到，最优的参数值与初始参数值比较接近，这说明Levenberg–Marquardt算法能够在较短的时间内得到较好的拟合结果。", "Konwledge_Point": "线性规划简介", "Question": "请教采用Levenberg–Marquardt算法求非线性分段函数的参数\n目前想用一个模型拟合一天的温度变化，模型如下，\n\n\n\n\n在保证已知六组以上温度-时间数值的情况下，如何采用Levenberg–Marquardt算法获得最优的参数解呢？\n已经搜索了网上的经验帖，但没有关于分段函数的讨论，还望解答\n\n\n（模型解释引自 孟翔晨, 刘昊, & 程洁. (2019). 基于FY-2F数据的中国区域地表温度日变化模型评价及特征研究. 遥感学报, 4, 570–581.）", "Tag": "算法分析"}
{"Answer": "\nThe benchmark was wrongly implemented, a correct version:\nfunc BenchmarkRBTree_Put(b *testing.B) {\n    count := 0\n    grow := 1\n    for size := 0; size < 100000; size += 1 * grow {\n        if count%10 == 0 {\n            count = 1\n            grow *= 10\n        }\n        b.Run(fmt.Sprintf(\"size-%d\", size), func(b *testing.B) {\n            // prepare problem size\n            tree := NewRBTree(func(a, b interface{}) bool {\n                if a.(int) < b.(int) {\n                    return true\n                }\n                return false\n            })\n            for n := 0; n < size-1; n++ {\n                tree.Put(n, n)\n            }\n            b.ResetTimer()\n            for i := 0; i < b.N; i++ {\n                tree.Put(size, size) // only measure the last operation\n            }\n        })\n        count++\n    }\n}\n\n\n", "Konwledge_Point": "线性规划简介", "Question": "为什么我的红黑树实现基准显示线性时间复杂度？\n\n\n\nThe implementation basically follows \nwiki\n. \n\n\n\nHere is how I implemented the benchmark, in this case, it is benchmarking \nPut\n op:\n\n\n\nfunc BenchmarkRBTree(b *testing.B) {\n    for size := 0; size < 1000; size += 100 {\n        b.Run(fmt.Sprintf(\"size-%d\", size), func(b *testing.B) {\n            tree := NewRBTree(func(a, b interface{}) bool {\n                if a.(int) < b.(int) {\n                    return true\n                }\n                return false\n            })\n            for i := 0; i < b.N; i++ {\n                for n := 0; n < size; n++ {\n                    tree.Put(n, n)\n                }\n            }\n        })\n    }\n}\n\n\n\n\nThe benchmark results:\n\n\n\nBenchmarkRBTree/size-0-8              2000000000              0.49 ns/op               0 B/op          0 allocs/op\nBenchmarkRBTree/size-100-8                200000             11170 ns/op            7984 B/op        298 allocs/op\nBenchmarkRBTree/size-200-8                100000             26450 ns/op           15984 B/op        598 allocs/op\nBenchmarkRBTree/size-300-8                 50000             38838 ns/op           23984 B/op        898 allocs/op\nBenchmarkRBTree/size-400-8                 30000             55460 ns/op           31984 B/op       1198 allocs/op\nBenchmarkRBTree/size-500-8                 20000             62654 ns/op           39984 B/op       1498 allocs/op\nBenchmarkRBTree/size-600-8                 20000             80317 ns/op           47984 B/op       1798 allocs/op\nBenchmarkRBTree/size-700-8                 20000             91308 ns/op           55984 B/op       2098 allocs/op\nBenchmarkRBTree/size-800-8                 10000            106180 ns/op           63984 B/op       2398 allocs/op\nBenchmarkRBTree/size-900-8                 10000            121026 ns/op           71984 B/op       2698 allocs/op\n\n\n\n\nA visual line chart of \nns/op\n:\n\n\n\n\n\n\nEven I increase the problem size:\n\n\n\nBenchmarkRBTree/size-0-8              2000000000              0.50 ns/op               0 B/op          0 allocs/op\nBenchmarkRBTree/size-10000-8                1000           1622187 ns/op          799989 B/op      29998 allocs/op\nBenchmarkRBTree/size-20000-8                 500           3693875 ns/op         1599994 B/op      59998 allocs/op\nBenchmarkRBTree/size-30000-8                 300           5693788 ns/op         2399998 B/op      89998 allocs/op\nBenchmarkRBTree/size-40000-8                 200           7663705 ns/op         3199998 B/op     119998 allocs/op\nBenchmarkRBTree/size-50000-8                 200           9869095 ns/op         3999997 B/op     149998 allocs/op\nBenchmarkRBTree/size-60000-8                 100          12133795 ns/op         4799999 B/op     179998 allocs/op\nBenchmarkRBTree/size-70000-8                 100          15422763 ns/op         5599999 B/op     209998 allocs/op\nBenchmarkRBTree/size-80000-8                 100          16140037 ns/op         6399998 B/op     239998 allocs/op\nBenchmarkRBTree/size-90000-8                 100          18161217 ns/op         7199997 B/op     269998 allocs/op\n\n\n\n\nVisual chart:\n\n\n\n\n\n\nYou can check the code in \nPlayground\n, or a lengthy version:\n\n\n\ntype color uint32\n\nconst (\n    red color = iota\n    black\n)\n\ntype rbnode struct {\n    c      color\n    left   *rbnode\n    right  *rbnode\n    parent *rbnode\n    k, v   interface{}\n}\n\nfunc (n *rbnode) color() color {\n    if n == nil {\n        return black\n    }\n    return n.c\n}\n\nfunc (n *rbnode) grandparent() *rbnode {\n    return n.parent.parent\n}\n\nfunc (n *rbnode) uncle() *rbnode {\n    if n.parent == n.grandparent().left {\n        return n.grandparent().right\n    }\n    return n.grandparent().left\n}\n\nfunc (n *rbnode) sibling() *rbnode {\n    if n == n.parent.left {\n        return n.parent.right\n    }\n    return n.parent.left\n}\n\nfunc (n *rbnode) maximumNode() *rbnode {\n    for n.right != nil {\n        n = n.right\n    }\n    return n\n}\n\n// RBTree is a red-black tree\ntype RBTree struct {\n    root *rbnode\n    len  int\n    less Less\n}\n\n// Less returns true if a < b\ntype Less func(a, b interface{}) bool\n\n// NewRBTree creates a red-black tree\nfunc NewRBTree(less Less) *RBTree {\n    return &RBTree{less: less}\n}\n\n// Len returns the size of the tree\nfunc (t *RBTree) Len() int {\n    return t.len\n}\n\n// Put stores the value by given key\nfunc (t *RBTree) Put(key, value interface{}) {\n    var insertedNode *rbnode\n\n    new := &rbnode{k: key, v: value, c: red}\n    if t.root != nil {\n        node := t.root\n    LOOP:\n        for {\n            switch {\n            case t.less(key, node.k):\n                if node.left == nil {\n                    node.left = new\n                    insertedNode = node.left\n                    break LOOP\n                }\n                node = node.left\n            case t.less(node.k, key):\n                if node.right == nil {\n                    node.right = new\n                    insertedNode = node.right\n                    break LOOP\n                }\n                node = node.right\n            default: // =\n                node.k = key\n                node.v = value\n                return\n            }\n        }\n        insertedNode.parent = node\n    } else {\n        t.root = new\n        insertedNode = t.root\n    }\n    t.insertCase1(insertedNode)\n    t.len++\n}\n\nfunc (t *RBTree) insertCase1(n *rbnode) {\n    if n.parent == nil {\n        n.c = black\n        return\n    }\n    t.insertCase2(n)\n}\nfunc (t *RBTree) insertCase2(n *rbnode) {\n    if n.parent.color() == black {\n        return\n    }\n    t.insertCase3(n)\n}\nfunc (t *RBTree) insertCase3(n *rbnode) {\n    if n.uncle().color() == red {\n        n.parent.c = black\n        n.uncle().c = black\n        n.grandparent().c = red\n        t.insertCase1(n.grandparent())\n        return\n    }\n    t.insertCase4(n)\n\n}\nfunc (t *RBTree) insertCase4(n *rbnode) {\n    if n == n.parent.right && n.parent == n.grandparent().left {\n        t.rotateLeft(n.parent)\n        n = n.left\n    } else if n == n.parent.left && n.parent == n.grandparent().right {\n        t.rotateRight(n.parent)\n        n = n.right\n    }\n    t.insertCase5(n)\n}\nfunc (t *RBTree) insertCase5(n *rbnode) {\n    n.parent.c = black\n    n.grandparent().c = red\n    if n == n.parent.left && n.parent == n.grandparent().left {\n        t.rotateRight(n.grandparent())\n        return\n    } else if n == n.parent.right && n.parent == n.grandparent().right {\n        t.rotateLeft(n.grandparent())\n    }\n}\n\nfunc (t *RBTree) replace(old, new *rbnode) {\n    if old.parent == nil {\n        t.root = new\n    } else {\n        if old == old.parent.left {\n            old.parent.left = new\n        } else {\n            old.parent.right = new\n        }\n    }\n    if new != nil {\n        new.parent = old.parent\n    }\n}\n\nfunc (t *RBTree) rotateLeft(n *rbnode) {\n    right := n.right\n    t.replace(n, right)\n    n.right = right.left\n    if right.left != nil {\n        right.left.parent = n\n    }\n    right.left = n\n    n.parent = right\n}\nfunc (t *RBTree) rotateRight(n *rbnode) {\n    left := n.left\n    t.replace(n, left)\n    n.left = left.right\n    if left.right != nil {\n        left.right.parent = n\n    }\n    left.right = n\n    n.parent = left\n}\n\n// Get returns the stored value by given key\nfunc (t *RBTree) Get(key interface{}) interface{} {\n    n := t.find(key)\n    if n == nil {\n        return nil\n    }\n    return n.v\n}\n\nfunc (t *RBTree) find(key interface{}) *rbnode {\n    n := t.root\n    for n != nil {\n        switch {\n        case t.less(key, n.k):\n            n = n.left\n        case t.less(n.k, key):\n            n = n.right\n        default:\n            return n\n        }\n    }\n    return nil\n}\n\n// Del deletes the stored value by given key\nfunc (t *RBTree) Del(key interface{}) {\n    var child *rbnode\n\n    n := t.find(key)\n    if n == nil {\n        return\n    }\n\n    if n.left != nil && n.right != nil {\n        pred := n.left.maximumNode()\n        n.k = pred.k\n        n.v = pred.v\n        n = pred\n    }\n\n    if n.left == nil || n.right == nil {\n        if n.right == nil {\n            child = n.left\n        } else {\n            child = n.right\n        }\n        if n.c == black {\n            n.c = child.color()\n            t.delCase1(n)\n        }\n\n        t.replace(n, child)\n        if n.parent == nil && child != nil {\n            child.c = black\n        }\n    }\n    t.len--\n}\n\nfunc (t *RBTree) delCase1(n *rbnode) {\n    if n.parent == nil {\n        return\n    }\n\n    t.delCase2(n)\n}\nfunc (t *RBTree) delCase2(n *rbnode) {\n    sibling := n.sibling()\n    if sibling.color() == red {\n        n.parent.c = red\n        sibling.c = black\n        if n == n.parent.left {\n            t.rotateLeft(n.parent)\n        } else {\n            t.rotateRight(n.parent)\n        }\n    }\n    t.delCase3(n)\n}\nfunc (t *RBTree) delCase3(n *rbnode) {\n    sibling := n.sibling()\n    if n.parent.color() == black &&\n        sibling.color() == black &&\n        sibling.left.color() == black &&\n        sibling.right.color() == black {\n        sibling.c = red\n        t.delCase1(n.parent)\n        return\n    }\n    t.delCase4(n)\n}\nfunc (t *RBTree) delCase4(n *rbnode) {\n    sibling := n.sibling()\n    if n.parent.color() == red &&\n        sibling.color() == black &&\n        sibling.left.color() == black &&\n        sibling.right.color() == black {\n        sibling.c = red\n        n.parent.c = black\n        return\n    }\n    t.delCase5(n)\n}\nfunc (t *RBTree) delCase5(n *rbnode) {\n    sibling := n.sibling()\n    if n == n.parent.left &&\n        sibling.color() == black &&\n        sibling.left.color() == red &&\n        sibling.right.color() == black {\n        sibling.c = red\n        sibling.left.c = black\n        t.rotateRight(sibling)\n    } else if n == n.parent.right &&\n        sibling.color() == black &&\n        sibling.right.color() == red &&\n        sibling.left.color() == black {\n        sibling.c = red\n        sibling.right.c = black\n        t.rotateLeft(sibling)\n    }\n    t.delCase6(n)\n}\nfunc (t *RBTree) delCase6(n *rbnode) {\n    sibling := n.sibling()\n    sibling.c = n.parent.color()\n    n.parent.c = black\n    if n == n.parent.left && sibling.right.color() == red {\n        sibling.right.c = black\n        t.rotateLeft(n.parent)\n        return\n    }\n    sibling.left.c = black\n    t.rotateRight(n.parent)\n}\n\n\n    ", "Tag": "算法分析"}
{"Answer": "你已经求得垂直的向量为(i,-j,0*k)，所以这个area=[1^2+(－1)^2+0^2]的开方=2的开方", "Konwledge_Point": "线性规划简介", "Question": "Linear algebra, Cramer’s rule, inverses and volumes线性代数\n\n\nIn example 8, 为什么area = 根号2？", "Tag": "算法分析"}
{"Answer": "都可以，看你怎么去写，你可以将指针放在第一个元素上，这个是带头结点的，不带头节点放在第一个元素之前你可以看我这篇文章：https://blog.csdn.net/qq_51553982/article/details/115730247", "Konwledge_Point": "线性规划简介", "Question": "线性链表的插入算法的找位序是怎么初始化的？\n为什么PPT上显示是j从0开始，书上位序是从1开始的 ，如果都是对的话，为什么会不一样呢？", "Tag": "算法分析"}
{"Answer": "先化简为最简阶梯型矩阵，没有全为0的行，即为满秩，非满秩不可等价变为满秩，你问错地儿了吧", "Konwledge_Point": "线性规划简介", "Question": "线性代数，怎么把矩阵变为等价的行满秩矩阵？\n怎么把矩阵变为等价的行满秩矩阵？\n怎么把矩阵变为等价的行满秩矩阵？\n怎么把矩阵变为等价的行满秩矩阵？", "Tag": "算法分析"}
{"Answer": "可以像下面这样使用，areaStyle可以传递一个函数，通过函数判断不同的折线图，返回不同的渐变色\nconst area = new Area('container', {\n      data,\n      xField: 'date',\n      yField: 'value',\n      color: ['red', 'blue'],\n      seriesField: 'country',\n      areaStyle:(d)=>{\n        console.log(d)\n        if(d.country===\"北美\") return {'fill':'l(270) 0:#FFFFFF 1:#FF0000'}\n        if(d.country==='中南美') return {'fill':'l(270) 0:#FFFFFF 1:#00FF00'}\n      }\n    });\n    area.render();\n\n我这里的结果如下：\n\n\n觉得有用，还请点赞收藏！励志前端，CSDN唯一账号！关注我，带你了解更多前端知识！\n", "Konwledge_Point": "线性规划简介", "Question": "AntV G2Plot线性图若有多个填充色，怎么统一设置渐变\n需求如下：\n\n\n当前实现：\n\n\n查看了官方文档（属实写的不易懂，比ant design写的还烂），也百度了很久，基本都是单线条的渐变，没有找到多线条渐变的案例。\n\n\n填充色color是可以用[]来进行赋值的，所以每个线条都有自己的填充色。\n但是渐变fill只支持单色（若放开注释，则两个线条的填充色都变成一样了），尝试了[]、{}等写法都不支持，请教一下熟悉g2plot的大拿这个玩意怎么实现。", "Tag": "算法分析"}
{"Answer": "阅读理解，说的是空间复杂度", "Konwledge_Point": "线性规划简介", "Question": "为什么n/2是常数性的啊？n就是线性的\n", "Tag": "算法分析"}
{"Answer": "\nSee Looking for actively maintained matrix math library for php\n", "Konwledge_Point": "线性规划简介", "Question": "使用多个变量服务器为webapp求解线性方程？ 有可能与PHP？\n\n\n\nI have a gerneral question on php. Hope its ok to ask here. \n\n\n\nHow would you solve a linear Equation with multiple variables in the web? maybe using Gaussian elimination or ... ? Is it possible with php and recommendable?\n\n\n\n1500 + 100 w                 = 10,000 s\n3000 + 1000 s                = 3000 w\n5000 + 2000 s + 100 w + 30 r = 150 r\n\n=>   s = 0,16 | w = 1,05 | r = 45,21\n\n\n    ", "Tag": "算法分析"}
{"Answer": "latent里的分类变量改写成  _Isex_1格式，参照表格里的变量名", "Konwledge_Point": "线性规划简介", "Question": "stata多元线性回归时系数集束法如何使用，对变量有何要求？\nstata系数集束化到底要怎么使用？\n最重要的是我的操作为啥会错误？\n我真的想不明白呀😭😭\n\n", "Tag": "算法分析"}
{"Answer": "题目已经自己解答出来，只需要把\r\n\r\n```\r\nelse if(N % K == 0 && N / K != 1)\r\n```\r\n的N% K==0删除即可\r\n应该说是N%K有余数也需要按照反转多次的办法来", "Konwledge_Point": "线性规划简介", "Question": "PTA线性结构3 Reversing Linked List【直接贴答案将不予采纳，谢谢合作】\n#include \nusing namespace std;\n\nstruct Node\n{\n    int adrs;\n    int data;\n    int next;\n    struct Node* link;\n};\n\n\nNode* reverselink(struct Node* node, int K)\n{\n    struct Node* initnode = node;\n    struct Node* newnode = node -> link;\n    struct Node* oldnode = newnode -> link;\n    struct Node* temp;\n\n    int count = 1;\n\n    while(count < K)\n    {\n        temp = oldnode -> link;\n        oldnode -> link = newnode;\n        newnode = oldnode;\n        oldnode = temp;\n        count++;\n    }\n\n    initnode -> link -> link = oldnode;\n\n    return newnode;\n}\n\nvoid print(struct Node* initNode)\n{\n    while(initNode != NULL)\n    {\n        if(initNode -> link != NULL)\n        {\n            printf(\"%05d %d %05d\\n\", initNode -> adrs, initNode -> data, initNode -> link -> adrs);\n\n        }\n        else\n        {\n            printf(\"%05d %d %d\\n\", initNode -> adrs, initNode -> data, -1);\n        }\n\n        initNode  = initNode -> link;\n    }\n}\n\nint main()\n{\n    int start = 0;\n    int N = 0;\n    int K = 0;\n    scanf(\"%d %d %d\",&start, &N, &K);\n    int adrs = -1;\n    int cnt = 0;\n\n    int data[100000] = {0};\n    int next[100000] = {0};\n    while(cnt < N)\n    {\n        scanf(\"%d\", &adrs);\n        scanf(\"%d\", &data[adrs]);\n        scanf(\"%d\", &next[adrs]);\n        cnt++;\n    }\n    //解决多余结点\n    int actualNum = 0;\n    struct Node* initNode = new Node;\n    struct Node* prevNode = initNode;\n    struct Node* curNode = NULL;\n\n    for(int i = start; i <= 100000 && i != -1; )\n    {\n        curNode = new Node;\n        curNode -> data = data[i];\n        curNode -> adrs = i;\n        curNode -> next = next[i];\n        curNode -> link = NULL;//////\n        prevNode -> link = curNode;\n        prevNode = curNode;\n        i = next[i];\n        actualNum++;\n    }\n    cnt = 0;\n    N = actualNum;\n\n    curNode -> link = NULL;\n\n    if(K == 1)//直接输出\n    {\n        initNode = initNode -> link;\n    }\n    else if(K == N || (N / K == 1 && N % K != 0))//全反转  有尾巴不反转\n    {\n        initNode = reverselink(initNode, K);\n    }\n    else if(N % K == 0 && N / K != 1)\n    {\n        int count = 1;\n        int flag = 0;\n        struct Node* markNode = initNode;\n        struct Node* firstNode = initNode;\n        while(cnt < N / K)\n        {\n            initNode = reverselink(initNode, K);\n            markNode -> link = initNode;\n            cnt++;\n            while(count < K && cnt < N / K)\n            {\n                initNode = initNode -> link;\n                count++;\n            }\n            markNode = initNode;\n            count = 1;\n        }\n        initNode = firstNode -> link;\n    }\n    print(initNode);\n}\n\n\n\n\n\n\n\n\n\n\n请勿贴他人的代码，贴他人的代码及网址回答将不会采纳。", "Tag": "算法分析"}
{"Answer": "请看一下你的TestActivity中的第83行代码，那一行出现了空指针异常，先把空指针异常处理了，应该就没事了。\r\n一般情况下，出现error的话，都需要先找到错误的地方，一般都是看Caused by:......的下一行，会指出你的那一行代码出了什么问题，然后就可以去解决相应的异常！", "Konwledge_Point": "线性规划简介", "Question": "向线性布局中动态添加textview出现闪退，代码如下，这是什么原因？？\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n\n        // TODO Auto-generated method stub\n\n        switch (requestCode) {\n\n        case 1:\n\n            if(resultCode==RESULT_OK){\n\n                personalNumber=data.getStringExtra(\"personal\");\n\n                allow=1;\n\n                Log.d(\"TestActivity\", personalNumber);\n\n\n\n            linearToLogin = (LinearLayout) findViewById(R.id.ll_to_login);\n            TextView firstTextView=new TextView(this);\n            firstTextView.setText(\"尊敬的：  \"+personalNumber);\n            firstTextView.setTextSize(16);\n            firstTextView.setGravity(Gravity.CENTER_HORIZONTAL);\n            LinearLayout.LayoutParams view01Params = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,\n                      ViewGroup.LayoutParams.WRAP_CONTENT);\n            ((ViewGroup) firstTextView.getParent()).removeView(firstTextView);\n             linearToLogin.addView(firstTextView,view01Params);\n\n            TextView welcomeTextView=new TextView(this);\n            welcomeTextView.setText(\"欢迎使用畅心停车\");\n            welcomeTextView.setTextSize(16);\n            welcomeTextView.setGravity(Gravity.CENTER_HORIZONTAL);\n            LinearLayout.LayoutParams view02Params = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,\n                      ViewGroup.LayoutParams.WRAP_CONTENT);\n            ((ViewGroup) welcomeTextView.getParent()).removeView(welcomeTextView);\n             linearToLogin.addView(firstTextView,view02Params);\n             Log.d(\"TestActivity布局\", \"填加完成\");\n        }\n        break;\n\n    default:\n        break;\n    }\n\n    这是logcat\n\n\n\n\n_", "Tag": "算法分析"}
{"Answer": "线性表直接排序就可以了。\n\n代码如下：\n#include <stdio.h>\n#define MAXNMB 100\ntypedef struct _node \n{\n    int data[MAXNMB];\n    int len;\n}Linklist;\n\n//排序\nvoid sort(Linklist *L)\n{\n    int t,i,j;\n    for (i=0;i<L->len-1;i++)\n    {\n        for (j=0;j<L->len-i-1;j++)\n        {\n            if(L->data[j] > L->data[j+1])\n            {\n                t = L->data[j];\n                L->data[j] = L->data[j+1];\n                L->data[j+1] = t;\n            }\n        }\n    }\n}\n\n\nint main()\n{\n    Linklist L;\n    int m,n,i;\n    printf(\"请输入m和n：\");\n    scanf(\"%d %d\",&m,&n);\n    printf(\"请输入%d个递增的数：\",m);\n    for(i=0;i<m;i++)\n        scanf(\"%d\",&L.data[i]);\n    printf(\"请输入%d个递增的数：\",n);\n    for(i=0;i<n;i++)\n        scanf(\"%d\",&L.data[m+i]);\n    L.len = m+n;\n    //排序\n    sort(&L);\n    //输出\n    for (i=0;i<L.len;i++)\n    {\n        if(i<L.len-1)\n            printf(\"%d \",L.data[i]);\n        else\n            printf(\"%d\\n\",L.data[i]);\n    }\n    return 0;\n}\n\n\n", "Konwledge_Point": "线性规划简介", "Question": "关于#c语言#的问题：有一个存放整数的长度为m+n的线性表L，其前m个元素单调递增，后n个元素也单调递增\n有一个存放整数的长度为m+n的线性表L，其前m个元素单调递增，后n个元素也单调递增。设计一个算法，使得整个线性表的元素单调递增。要求：使用顺序存储实现。", "Tag": "算法分析"}
{"Answer": "#include <iostream>\n\nusing namespace std;\n\nvoid swap(int *a, int *b) {\n  int t = *a;\n  *a = *b;\n  *b = t;\n}\n\nvoid selectionsort(int a[], int n) {\n  for (int i = 0; i < n - 1; i++) {\n    int min_idx = i;\n    for (int j = i + 1; j < n; j++)\n      if (a[j] < a[min_idx])\n        min_idx = j;\n    if (min_idx != i)\n      swap(&a[min_idx], &a[i]);\n  }\n}\n\nint binarysearch(int a[], int n, int value) {\n  int left = 0, right = n - 1;\n  while (left <= right) {\n    int m = (left + right) / 2;\n    if (a[m] < value)\n      left = m + 1;\n    else if (a[m] > value)\n      right = m - 1;\n    else\n      return m;\n  }\n  return -1;\n}\n\nint main() {\n  int test[] = {5658845, 4520125, 7895122, 8777541, 8451277, 1302850,\n                8080152, 4568555, 5552012, 5050552, 7825877, 1250255,\n                1005231, 6545231, 3852085, 7576651, 7881200, 4581002};\n  std::size_t size = sizeof(test) / sizeof(int);\n  selectionsort(test, size);\n  cout << \"请输入要查找的账号：\";\n  int account;\n  cin >> account;\n  int index = binarysearch(test, size, account);\n  if (index >= 0 && index < size)\n    cout << \"合法账号！\" << endl;\n  else\n    cout << \"非法账号！\" << endl;\n  return 0;\n}\n", "Konwledge_Point": "线性规划简介", "Question": "编程，让用户输入一个一个账号，检验该账号是否出现在下面的列表中。如果属于下面列表中的账号，则输出合法信息，否则输出非法信息。采用线性查找方法实现该程序。\n\n\n5658845\n  \n4520125\n  \n7895122\n  \n8777541\n  \n8451277\n  \n1302850\n  \n80801524568555\n  \n5552012\n  \n5050552\n  \n7825877\n  \n1250255\n  \n1005231\n  \n65452313852085\n  \n7576651\n  \n7881200\n  \n4581002\n\n\n1\n、算法分析\n先用选择排序法装饰所给的账号排序，然后采用二分查找算法检验输入账号的合法性。\n\n2\n、参考代码\n#include\nusing namespace std\n;\n\nint binarysearch(int a[],int n=\n10\n,int value=\n0000000\n)\n;\n\nvoid selectionsort(int a[],int n=\n10\n)\n;\n\nint main()\n {    \nint test[]={\n5658845\n,\n4520125\n,\n7895122\n,\n8777541\n,\n8451277\n,\n1302850\n,\n8080152\n,\n4568555\n,\n5552012\n,\n5050552\n,\n7825877\n,\n1250255,1005231\n,\n6545231\n,\n3852085\n,\n7576651\n,\n7881200\n,\n4581002\n}\n;\n\nint accounts\n;selectionsort(test,18);\n\ncout<<”请输入要查找的账号：”\n;    \n\ncin>>accounts\n;    \n\nif(binarysearch(test,sizeof(test)/sizeof(test[\n0\n]),accounts))        \ncout<<”合法账号！”<<endl\n;    \n\nelse        \ncout<<”非法账号！”<<endl\n;    \n\nreturn \n0\n;\n\n}\n//选择排序函数void selectionsort(int a[],int n)\n//二分查找函数int binarysearch(int a[],int n,int value)\n", "Tag": "算法分析"}
{"Answer": "小魔女参考了bing和GPT部分内容调写:二维数组是一种特殊的线性结构，它是由一维数组组成的，每个一维数组又可以看作是一个元素，这些元素可以按照一定的顺序排列，所以它是一种线性结构。但是，二维数组也有一些特殊的特性，比如可以通过行和列的索引来访问元素，这种方式在一维数组中是不可能的，所以有些人认为二维数组是非线性结构。\n其实，这个问题的答案取决于你如何定义线性结构和非线性结构。如果你把线性结构定义为只能按照一种顺序排列的数据结构，那么二维数组就是线性结构；如果你把线性结构定义为只能按照一种顺序排列，但是可以通过行列索引访问元素的数据结构，那么二维数组就是非线性结构。回答不易，记得采纳呀。", "Konwledge_Point": "线性规划简介", "Question": "算法与数据结构问题。\n二维数组到底是线性结构还是非线性结构?\n为什么网上搜索结果会有不同的答案", "Tag": "算法分析"}
{"Answer": "在布局中设置一个居中图片然后平时隐藏，等到加载的实现显示出来，把Recyclerview隐藏，等数据加载完成后，把图片隐藏，Recyclerview显示就行了", "Konwledge_Point": "线性规划简介", "Question": "Recyclerview数据未加载前显示加载界面如何实现？\n一个界面的数据用的Recyclerview线性布局加载数据，在数据没有得到前界面是空白一片，怎么实现在数据没加载完成前先让界面显示一个居中的加载图片", "Tag": "算法分析"}
{"Answer": "单脉冲通常指的是一种具有极窄脉冲宽度的信号，通常用于雷达、通信和遥感等领域。单脉冲信号的特点是信号持续时间很短，但是带宽较宽，能够提供高分辨率的信息。\n线性调频信号是一种特殊的信号形式，其频率随时间线性变化。线性调频信号通常用于雷达、声纳、通信和遥感等领域，用于距离和速度测量，目标探测等应用。线性调频信号也称为chirp信号，这是因为其频率随时间变化的形状类似于鸟叫声的形状。\n因此，单脉冲信号和线性调频信号是不同的信号类型，但它们在雷达、通信和遥感等领域都有重要应用。", "Konwledge_Point": "线性规划简介", "Question": "请问单脉冲是什么意思?\n请问单脉冲是什么意思?单脉冲的概念是什么？包括线性调频信号吗？若不是，那请问线性调频信号叫什么呢？", "Tag": "算法分析"}
{"Answer": "一维数据有很多种，python的一维列表，一维元组，集合等等，c和Java的一维数组所以一维数据不一定是线性结构", "Konwledge_Point": "线性规划简介", "Question": "一维数据为什么可以用集合表示？\n一维数据不应该都是线性结构吗（百度也是这么说的）\n\n\n而集合是非线性结构，那为什么一维数据可以用集合表示", "Tag": "算法分析"}
{"Answer": "参考GPT和自己的思路：\n对于集中式卡尔曼滤波的信息物理系统，可以通过对系统的状态估计值和测量值的误差进行分析来检测是否受到了线性欺骗攻击。通常可以计算出系统状态估计误差的均值和方差，通过对比理论值和实际值，判断是否存在线性欺骗攻击。\n如果只有部分传感器受到了线性欺骗攻击，可以采用一些特定的检测算法来确定是哪几个传感器受到了影响。常用的算法包括neighbors method和covariance consistency method等等，其中neighbors method通过对相邻传感器的测量值进行比较来判断哪些传感器受到了欺骗攻击，而covariance consistency method则分析系统的协方差矩阵是否存在不一致性来判断哪些传感器受到了影响。", "Konwledge_Point": "线性规划简介", "Question": "集中式信息物理系统安全检测\n对于一个使用集中式卡尔曼滤波的信息物理系统，怎么检测系统是否受到了线性欺骗攻击？如果只有部分传感器受到了线性欺骗攻击，怎么检测出是哪几个？", "Tag": "算法分析"}
{"Answer": "建立一个类/结构体\r\nstudent s{\r\n\tstr Name;\r\n\tstr Number;\r\n\tstr Sex;\r\n\t....\r\n\tstudent * next;\r\n}\r\n删除、查找、追加、读入、排序这些操作都是一般线性链表的删除结点、查找结点、添加结点、调换链表顺序(推荐先遍历链表，将数值赋给其他数据结构(vector、数组)排序后建立新链表取代旧链表)操作\r\n\r\n需求分析：vs上可以画uml图", "Konwledge_Point": "线性规划简介", "Question": "求解数据结构课程设计问题\n学生成绩管理系统 \n\n设计目的：\n\n1 掌握线性链表的建立。\n\n2 掌握线性链表的基本操作。\n\n3 掌握查找的基本算法。\n\n设计内容：\n\n　　利用线性链表实现学生成绩管理系统，具体功能：输入、输出、插入、删除、查找、追加、读入、显示、保存、拷贝、排序、索引、分类合计、退出，并能在屏幕上输出操作前后的结果。\n\n设计要求：\n\n1 写出系统需求分析,并建模。\n\n2  编程实现,界面友好。\n\n3  输出操作前后的结果。", "Tag": "算法分析"}
{"Answer": "举个例子，比如一个长度为10的表结构（已经排序过的），首先和第5位的元素进行比较，若目标值小于第5位上的元素，那么认为目标在第1位到第5位这个区间内，接着比较目标值和第3位的元素，如果是数组，也就是这里说的随机访问的结构，可以直接通过下标来访问第3位的元素，而对于链表来说，它始终要从第一个元素一个一个地遍历过来才能找到第3位的元素，由于这样的过程就使得二分查找变成了顺序查找", "Konwledge_Point": "线性规划简介", "Question": "java集合二分查找算分\n只有采用随机访问，二分查找才有意义，如果提供的是一个链表，binarySearch()就         自动的变成线性查找。没太理解这句话的意思。链表是有序集合，为什么二分查找用在链表上就变成线性查找？\n\n\n\n多谢各位老师指教。", "Tag": "算法分析"}
{"Answer": "参考一下https://blog.csdn.net/weixin_39703468/article/details/116166887", "Konwledge_Point": "线性规划简介", "Question": "使用matlab对干扰信号进行检测\n使用连续均值消除法对线性扫频干扰进行检测，输出snr与检测概率关系曲线", "Tag": "算法分析"}
{"Answer": "附录：回归结果详细说明 原文链接：https://blog.csdn.net/youcans/article/details/116448853\n\n    Dep.Variable: y 因变量\n    Model：OLS 最小二乘模型\n    Method: Least Squares 最小二乘\n    No. Observations: 样本数据的数量\n    Df Residuals：残差自由度(degree of freedom of residuals)\n    Df Model：模型自由度(degree of freedom of model)\n    Covariance Type：nonrobust 协方差阵的稳健性\n    R-squared：R 判定系数\n    Adj. R-squared: 修正的判定系数\n    F-statistic： 统计检验 F 统计量\n    Prob (F-statistic): F检验的 P值\n    Log likelihood: 对数似然\n\n    coef：自变量和常数项的系数，b1,b2,...bm,b0\n    std err：系数估计的标准误差\n    t：统计检验 t 统计量\n    P>|t|：t 检验的 P值\n    [0.025, 0.975]：估计参数的 95%置信区间的下限和上限\n    Omnibus：基于峰度和偏度进行数据正态性的检验\n    Prob(Omnibus)：基于峰度和偏度进行数据正态性的检验概率\n    Durbin-Watson：检验残差中是否存在自相关\n    Skewness：偏度，反映数据分布的非对称程度\n    Kurtosis：峰度，反映数据分布陡峭或平滑程度\n    Jarque-Bera(JB)：基于峰度和偏度对数据正态性的检验\n    Prob(JB)：Jarque-Bera(JB)检验的 P值。\n    Cond. No.：检验变量之间是否存在精确相关关系或高度相关关系。\n", "Konwledge_Point": "线性规划简介", "Question": "Python,对回归模型做评估：具体是通过哪些值，如何评估？\n最近在学习Python对回归模型做评估，代码过程我记住了，但是出来的表格不知道怎么分析呢。是看那些值，对模型评估有什么作用？\n\n\n【用到的包】\n1.调包\nimport pandas as pd\n2.可视化分析\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline\n3.线性回归模型的建立与评估\n（调用sklearn中的线性回归工具包）\nfrom sklearn.linear_model import LinearRegression\n\n\nLinearRegression()设置模型为线性回归\nmodel=LinearRegression()\n\n\n【Q：最后出来这个表格，我不知道对评估模型有什么作用】\n\n", "Tag": "算法分析"}
{"Answer": "该回答引用ChatGPT \n由于没有给出具体的线性方程组，我无法给出实际的代码。但是，解决线性方程组的一般步骤如下：\n将方程组表示成矩阵形式对矩阵进行初等行变换，将其化为阶梯形式对阶梯形矩阵进行回代，求出方程组的解向量在 C 语言中，可以使用数组来表示矩阵和向量，并编写循环来实现初等行变换和回代的操作。以下是一个简单的例子，假设方程组如下：\n3x + 2y + z = 10x - y + 2z = -12x + 3y - z = 7\n可以将其表示成矩阵形式：\n[ 3 2 1 ][ x ] [ 10 ][ 1 -1 2 ][ y ] = [ -1 ][ 2 3 -1 ][ z ] [ 7 ]\n然后使用 C 语言编写程序求解该方程组：\n#include <stdio.h>\n\nvoid row_reduce(double A[][3], double b[], int n) {\n    int i, j, k;\n    for (i = 0; i < n; i++) {\n        double pivot = A[i][i];\n        for (j = i; j < n; j++) {\n            A[i][j] /= pivot;\n        }\n        b[i] /= pivot;\n        for (k = i+1; k < n; k++) {\n            double factor = A[k][i] / A[i][i];\n            for (j = i+1; j < n; j++) {\n                A[k][j] -= factor * A[i][j];\n            }\n            b[k] -= factor * b[i];\n        }\n    }\n}\n\nvoid back_substitute(double A[][3], double b[], double x[], int n) {\n    int i, j;\n    for (i = n-1; i >= 0; i--) {\n        double sum = 0.0;\n        for (j = i+1; j < n; j++) {\n            sum += A[i][j] * x[j];\n        }\n        x[i] = b[i] - sum;\n    }\n}\n\nint main() {\n    double A[3][3] = {{3, 2, 1}, {1, -1, 2}, {2, 3, -1}};\n    double b[3] = {10, -1, 7};\n    double x[3];\n    row_reduce(A, b, 3);\n    back_substitute(A, b, x, 3);\n    printf(\"Solution: (%f, %f, %f)\\n\", x[0], x[1], x[2]);\n    return 0;\n}\n\n\n\n运行该程序，输出为：\nSolution: (1.000000, -2.000000, 3.000000)即解向量为 (1, -2, 3)。您可以根据实际的线性方程组编写类似的程序，进行求解。", "Konwledge_Point": "线性规划简介", "Question": "这个方程组用c语言怎么实现\n这个种线性代数的方程用C语言怎么实现,具体参考的内容怎么实现", "Tag": "算法分析"}
{"Answer": "报错提示是没有找到该文件，你看下你的相对路径，有没有写对？", "Konwledge_Point": "线性规划简介", "Question": "python中pd.read_csv出现错误\npython 进行线性学习，使用read的时候读取不到是为什么呀？", "Tag": "算法分析"}
{"Answer": "“Devil组”引证GPT后的撰写：本代码演示了如何使用该方法求解经典的Korteweg-de Vries (KdV)方程。\n% Korteweg-de Vries (KdV)方程的时间劈裂傅里叶谱方法求解\n\n% 设置初始参数\nL = 30; % 区间长度\nN = 512; % 离散点数\nx = linspace(-L/2,L/2,N+1); x = x(1:N); % 离散空间点\nk = (2*pi/L)*[0:(N/2-1) (-N/2):-1]; % 离散波数\ntspan = 0:0.4:100; % 时间步长\n\n% 初始条件\nu = 2*sech(x);\nut = fft(u);\n\n% 声明时间劈裂傅里叶谱算法所需的线性算子和非线性算子\nA = 1i*k.^3;\nB = @(x) -0.5i*fft(real(ifft(x)).^2);\n\n% 声明存储解和时间向量的数组\nsol = zeros(length(tspan),length(u));\nsol(1,:) = u;\nt = 0;\n\n% 时间劈裂傅里叶谱算法\nfor j = 1:length(tspan)-1\n    % 隐式时间步长\n    t = tspan(j);\n    dt = tspan(j+1) - t;\n    % 线性部分的时间步长\n    utstar = exp(A*dt/2).*ut;\n    % 非线性部分的时间步长\n    ustar = real(ifft(utstar));\n    k1 = dt*B(utstar);\n    k2 = dt*B(utstar + 0.5*k1);\n    k3 = dt*B(utstar + 0.5*k2);\n    k4 = dt*B(utstar + k3);\n    ut = exp(A*dt/2).*(utstar + (1/6)*(k1+2*k2+2*k3+k4));\n    sol(j+1,:) = real(ifft(ut));\nend\n\n% 绘制解的图像\nwaterfall(x,tspan,sol'), colormap([0 0 0]), view(10,70)\nxlabel('x'), ylabel('t'), zlabel('u')\n\n\n", "Konwledge_Point": "线性规划简介", "Question": "matlab关于时间劈裂傅立叶谱方法的程序\n通过matlab软件，作用时间劈裂傅立叶谱方法求解非线性偏微分方程", "Tag": "算法分析"}
{"Answer": "望采纳：我可以提供一个 Matlab 程序来解决一维非线性偏微分方程组，该方程组是一个双组分 GP 方程，其中求解基态波函数。下面是程序的代码：\n\n% 求解双分量系统的一维非线性GP方程\n% 使用虚时间传播方法\n\n% 参数\ng = 1; % Interaction strength\nmu = 0.5; % Chemical potential\nL = 10; % Spatial domain\nNx = 2^10; % Number of grid points\ndx = L/Nx; % Spatial step size\nx = dx*(1:Nx)'; % Spatial grid\ndt = 0.01; % Time step size\n\n% 初始波函数\npsi1 = sqrt(2*mu)*sech(x); % Component 1\npsi2 = 0*x; % Component 2\npsi = [psi1, psi2]; % Total wave function\n\n% 时间演变\nfor n = 1:5000\n    % Kinetic energy operator\n    K1 = -0.5*(1/dx^2)*(diag(ones(Nx-1,1),-1)-2*diag(ones(Nx,1),0)+diag(ones(Nx-1,1),1));\n    K2 = K1;\n    K = kron(eye(2), K1) + kron(flipud(eye(2)), K2);\n    % Potential energy operator\n    V = diag(g*(abs(psi(:,1)).^2+abs(psi(:,2)).^2));\n    % Time-evolution operator\n    U = expm(-1i*dt*(K+V));\n    % Update wave function\n    psi = U*psi;\n    % Normalize wave function\n    psi = psi/norm(psi);\nend\n\n% 绘制每个分量的密度\nfigure;\nplot(x, abs(psi(:,1)).^2, 'r-', x, abs(psi(:,2)).^2, 'b-');\nxlabel('x');\nylabel('Density');\n\n\n这个程序使用了一种叫做 \"虚时间演化\" 的方法来求解 GP 方程。其中g为相互作用强度，mu为化学势，L为空间范围，Nx为网格点数，dx为空间步长，dt为时间步长。", "Konwledge_Point": "线性规划简介", "Question": "有偿求 matlab解GP方程程序\n一个双组分Gp方程（一维非线性偏微分方程组）求解基态波函数程序", "Tag": "算法分析"}
{"Answer": "这个你可以在csdn的下载里搜索相关的代码", "Konwledge_Point": "线性规划简介", "Question": "有局放定位的程序吗？\n有局放定位的程序吗？如线性阵列传感器，十字形阵列传感器，方形阵列传感器等", "Tag": "算法分析"}
{"Answer": "1、没有非线性激活函数的神经网络，不管多少层都无法解决非线性分类2、非线性激活函数越多，那么网络的非线性拟合能力越强。", "Konwledge_Point": "线性规划简介", "Question": "关于#神经网络#的问题，如何解决？\n想问一下两层神经网络和三层神经网络哪一个可以解决非线性分类，并且讲解一下原因～", "Tag": "算法分析"}
{"Answer": "神经网络的权重就是训练出来的", "Konwledge_Point": "线性规划简介", "Question": "是否可以利用神经网络来做权重分析？\n当前有一个模型，该模型具有四个特征（a,b,c,d），另外有一个算法，输入是把a,b,c,d四个特征以及知识图谱中的知识点集合，输出是知识点结合的线性排序。现想请假各位大拿，四个特征的权重目前暂不可知，我是否可以利用神经网络的方法来对四个特征的权重做分析，进而得到相对科学、理想的知识点线性排序呢？", "Tag": "算法分析"}
{"Answer": "这不是很明显么，D选项你列出来看看，不就是 d->e->a->b->c->f", "Konwledge_Point": "线性规划简介", "Question": "关于#数据结构#的问题，请各位专家解答！\n这是一道关于算法的题，我一直不明白如何判断哪些数据元素集合具有线性结构，谁能帮我解答一下", "Tag": "算法分析"}
{"Answer": "你好，我是有问必答小助手，非常抱歉，本次您提出的有问必答问题，技术专家团超时未为您做出解答本次提问扣除的有问必答次数，将会以问答VIP体验卡（1次有问必答机会、商城购买实体图书享受95折优惠）的形式为您补发到账户。因为有问必答VIP体验卡有效期仅有1天，您在需要使用的时候【私信】联系我，我会为您补发。", "Konwledge_Point": "线性规划简介", "Question": "Matlab中mosek求解器\n关于非线性方程组的求解问题，运行到最后提示是求解器不适用，请教一下，一般出现这种情况是什么原因", "Tag": "算法分析"}
{"Answer": "这个问题的回答你可以参考下: https://ask.csdn.net/questions/7731194这篇博客也不错, 你可以看下matlab微分方程求解并仿真您还可以看一下 苏金明老师的MATLAB偏微分方程数值解课程中的 计算小节, 巩固相关知识点", "Konwledge_Point": "线性规划简介", "Question": "MATLAB仿真微分方程组\n非线性，需要用MATLAB仿真出来，仿真不出来，不知道什么原因，请求各位的帮助，感谢各位的帮助！", "Tag": "算法分析"}
{"Answer": "\n代码：\n\nvector<int> res={1,2,3,4,5,6,7,7,6,5,4,3,2,1,0};\n   int i_count=0;\n   vector<vector<int>>ans;\n   vector<int> childans;\n   for(int i=0;i<res.size();i++)\n   {\n       if(i_count==7)\n       {\n           ans.push_back(childans);\n           childans.clear();\n           i_count=0;\n       }\n       childans.push_back(res[i]);\n       i_count++;\n   }\n   if(childans.size()!=0)\n   {\n       ans.push_back(childans);\n   }\n\n   for(int i=0;i<ans.size();++i)\n   {\n       for(int j=0;j<ans[i].size();++j)\n       {\n           cout<<ans[i][j];\n       }\n       cout<<endl;\n   }\n", "Konwledge_Point": "线性规划简介", "Question": "算法设计与分析  中的  选择问题\n选择问题中，如果分组为7个数一-组，能否在线性时间内完成?列出递推公式，并求解。", "Tag": "算法分析"}
{"Answer": "求采纳，求C币\r\n\r\n![图片说明](https://img-ask.csdn.net/upload/201908/02/1564724157_798890.png)", "Konwledge_Point": "线性规划简介", "Question": "矩阵内积运算方法？。\n请问红线部分是什么运算原理呢。。学过线性代数依然看不懂这个计算方法", "Tag": "算法分析"}
{"Answer": "http://bbs.csdn.net/topics/391979780", "Konwledge_Point": "线性规划简介", "Question": "fragment加了recycleView中就转换不了。\n报错是E/RecyclerView: No adapter attached; skipping layout\n\n这个是什么意思？？？？\n\n求大神指点。\n\n布局只是线性布局里加了个recycleview", "Tag": "算法分析"}
{"Answer": "你好同学，你的p1是空的啊。读入音频请用audioread函数\n此 MATLAB 函数 从名为 filename 的文件中读取数据，并返回样本数据 y 以及该数据的采样率 Fs。\n[y,Fs] = audioread(filename)\n[y,Fs] = audioread(filename,samples)\n[y,Fs] = audioread(___,dataType)\n", "Konwledge_Point": "线性规划简介", "Question": "MATLAB出现索引超过矩阵维度\n各位大神们，这个范围该取多少，取一帧320样点的语音信号，分析十二阶的线性预测系数，后面的参数有没有问题。\n\n", "Tag": "算法分析"}
{"Answer": "答案是 1.6", "Konwledge_Point": "线性规划简介", "Question": "已知线性表 22 15 36 40 63\n已知线性表 22 15 36 40 63，用Hash(x) = x mod 7作为散列函数，用线性探查法作为冲突处理，求平均查找长度。", "Tag": "算法分析"}
{"Answer": "看了一天的百度，我要是老板，我觉得你是故意的。\r\n\r\n![图片说明](https://img-ask.csdn.net/upload/201709/02/1504341379_376173.png)\r\n\r\n![图片说明](https://img-ask.csdn.net/upload/201709/02/1504341412_143392.png)", "Konwledge_Point": "线性规划简介", "Question": "求C#实现PCA算法的例子\n求C#实现PCA算法的例子，PCA为主成分分析，\n\n看了一天的百度，然而线性代数的知识完全不记得了。\n\n求各位大神指点迷津，万分感谢！", "Tag": "算法分析"}
{"Answer": "你用的LinearLayout把？而且你还设置了方向是Horizontal，它表示水平排列，超出屏幕视野范围了，移到屏幕外面了。\n你如果用的就是LinearLayout八你的xml的orientation的Horizontal改成vertical就行了。\n望采纳。懂了吗？", "Konwledge_Point": "线性规划简介", "Question": "Android studio编辑活动界面内容缺失\n我快捷拖选了图片，输入框，按钮进行编辑，但发现活动界面只有图片没有其他的内容，这怎么解决呢？\n难道是更改线性排列的错误吗？\n\n", "Tag": "算法分析"}
{"Answer": "你这个方程右端没有出现关于t的函数，所以可以称作三元一阶线性非齐次自治方程组，这里不存在静定和超静定问题【静定超静定是只的结构是否过约束】三元：y1 y2 y3一阶：最高阶为时间的一阶导数线性：最高阶的幂为1次非齐次：右端常数项不为0自治：所有导数项均不包含时间项t有帮助望采纳", "Konwledge_Point": "线性规划简介", "Question": "微分方程组的类型判断\n\n\n问题：\n这微分方程组是什么微分方程组呀？\n一元非线性非齐次微分方程组吗？还是超静定微分方程组？搞不懂这个名字叫什么", "Tag": "算法分析"}
{"Answer": "N年以前的autocad可以导出一种文本格式，另存为就可以。但是现在已经忘记是什么扩展名了。从这种文件中可以看出矢量图的格式。我们那个时候做GIS，将autocad文件生成我们自己的gis图形文件。你可以试试，这个功能应该还保留着，分析这个文本文件当然是很艰苦的事情，但是可以从文档中找到一些提示。那时候我们做成了，可惜这个项目因为架构的原因搁浅了。\r\n楼主的这个问题使我想起了当年编程的时候...", "Konwledge_Point": "线性规划简介", "Question": "AutoCAD怎样导出矢量图形数据\n具体说明如下：\n\n\n\n使用AutoCAD绘制的线性地图（类似googlemap的样子），将其中的图形数据读出，\n\n生成指定的矢量图形格式。\n\n\n\n然后导出的矢量图形用于二次开发，最后在web页面中显示图形输出。\n\n\n\n望详解！\n\n\n\n[b]问题补充：[/b]\n\n具体说明如下：\n\n\n\n使用AutoCAD绘制的线性地图（类似googlemap的样子），将其中的图形数据读出，\n\n生成指定的矢量图形格式。\n\n\n\n然后导出的矢量图形用于二次开发，最后在web页面中显示图形输出。\n\n\n\n望详解！\n\n\n\n主要是用于web的矢量图形格式，理想格式是svg。\n\n目前发现一国外转换工具，但注册费很贵，求开源方案", "Tag": "算法分析"}
{"Answer": "![图片说明](https://img-ask.csdn.net/upload/202004/27/1587918519_611968.png)\r\n看这个图，比如说先序遍历\r\n传统的，每个节点存储左右孩子（蓝色线）\r\n1->2->3没问题，3回不到2了。怎么办，需要在访问2的时候，把2放入堆栈。访问完3，左右都没有孩子了，此路走完，再到堆栈里面找2，才能到4。\r\n类似的，4到1也不能直接连上。6到5也不能连上。\r\n怎么办？\r\n增加一个\"线索\"，红色的箭头，在3的节点上指向2，4指向1，6指向5。\r\n这样，不需要堆栈就可以遍历了。\r\n![图片说明](https://img-ask.csdn.net/upload/202004/27/1587919159_128982.png)\r\n没有线索，遍历需要4个序列。\r\n现在用红色绳子把这4列串成一条线，这就是线索。\r\n什么地方需要添加“线索”？没有左右孩子的节点，所以为了节约存储，可以把线索和孩子的节点放在同样的存储单元，用一个flag区分，是孩子还是线索。", "Konwledge_Point": "线性规划简介", "Question": "这是一个关于数据结构二叉树的内容\n线索二叉树怎么充分利用了剩余结点呢？把剩余结点记录前驱后继，有什么效果呢？\n\n课本上说，把树形逻辑变为线性逻辑，这一点如何体现的呢？", "Tag": "算法分析"}
{"Answer": "以你目前的数学基础够了（不是说真的就够了，而是你继续做题，题目基本上都是理想情况，实际应用真需要推理的话难度比这个大多了。）你需要的是打代码了，实现推理过程你会发现更多的细节问题，一边实现一边学，闭门造车可不行。而实际应用过程基本上不会涉及到推理公式，一般都是用的现成第三方库，各种框架，像反向传播，根本不需要你自己去推理过程，但是需要你知道遇到什么问题该用哪种方法，调哪些库。", "Konwledge_Point": "线性规划简介", "Question": "问一下学习机器学习需要什么数学基础\n问一下学习机器学习需要什么数学基础，高等数学线性代数概率论最基本的三本书已经看完了，也能做出来考研的题，但是推算法相关的公式还是有点费劲", "Tag": "算法分析"}
{"Answer": "我觉得，X，Y是多少数据并没有关系，首先列两个方程a*e^bx1=y1,a*e^bx2=y2，根据这两个式子求出a和b，然后带入a*e^bx3看是否等于y3，如果相等就有指数关系，不相等就没有关系。", "Konwledge_Point": "线性规划简介", "Question": "求解MATLAB的编程，数据图像的处理\n请问用MATLAB处理数据，已知X,Y，分别有12个数，假设他们之间有线性关系，检测他们是否有指数关系y=ae^b*x,怎么编写代码？", "Tag": "算法分析"}
{"Answer": "你的邮箱", "Konwledge_Point": "线性规划简介", "Question": "IMSL for C 7.0 安装包\n您好，看到您有分享 IMSL CNL 7.0.0 for Visual C++ 2008 (x86-64) Crack 文件，\n想用IMSL for C 求解非线性方程组，请问您还留着 IMSL CNL 7.0.0 安装包吗？", "Tag": "算法分析"}
{"Answer": "http://download.csdn.net/download/lming_08/7035195\r\nhttp://download.csdn.net/download/u014443759/8296347\r\nhttp://download.csdn.net/download/erlongz/5815557\r\n`采纳本回答可以代下载以上程序`", "Konwledge_Point": "线性规划简介", "Question": "一直空间中圆柱的点云数据，如何估计圆柱的7个参数\n查询百度大致告诉我可以用LM算法，非线性最小二乘法，还有用RANSAC方法，\n\n从数学角度而言出入参数为3个，估计参数为7个，有若干样本数据，应该采用什么方法、\n\n搞笑准确。", "Tag": "算法分析"}
{"Answer": "线性回归吗？为什么你的线性回归出来的线是这样的？数据和代码要不做个网盘链接，我试试", "Konwledge_Point": "线性规划简介", "Question": "生物SPO2数据拟合问题\n红色的为原始数据，blue是我用一元线性回归 Y = w X + b 拟合出来的，但效果不理想，可能还需要kalman滤波来平滑曲线，或者采取分段拟合等\n快有30万个点。\n额 外 报 酬 可 以再细谈。谢谢\n\n", "Tag": "算法分析"}
{"Answer": "使用PIL库和opencv应该可以实现的", "Konwledge_Point": "线性规划简介", "Question": "怎样在YOLOv5输出视频帧中叠加线条？\n目前做到：\n运行detect.py生成txt文件，在txt文件中保存了检测框底边中点的坐标。\n想利用这些坐标进行线性拟合，如何将拟合出的线叠加到视频帧中，让他们同时输出出来？", "Tag": "算法分析"}
{"Answer": "基于Monster 组和GPT的调写：用MATLAB中的imresize和flipud函数。首先，使用你提供的代码生成马赫带图案。然后，我们可以使用imresize函数将图像调整为200x200像素。最后，我们可以使用flipud函数将图像上下翻转。现在，你可以将生成的图像保存为PNG或其他图像格式\n完整的MATLAB代码如下：\nimagesc(1:9)\ncolormap(gray)\nim = getframe(gca);\nim = imresize(im.cdata, [200 200]);\nim = flipud(im);\nimwrite(im, 'mach_band.png');\n\n\n", "Konwledge_Point": "线性规划简介", "Question": "用matlab绘制特定的马赫带\n要求：绘制视觉马赫带图案，大小为200x200，共有10条亮度带，从左向右亮度线性递减\nimagesc（1：9）\ncolormap（gray）\n完全初学 知道简单的如何生成 但不知道生成之后如何调整大小且如何反转图片", "Tag": "算法分析"}
{"Answer": "chomd 777 + 文件夹名字", "Konwledge_Point": "线性规划简介", "Question": "请问怎么解决vim编辑文件想存到指定文件夹的权限问题\n1、\n\n2、学习使用ubuntuC++编程看那本书好\n\n3、张量变换矩阵应该是看线性代数的哪个部分", "Tag": "算法分析"}
{"Answer": "应该是 bytes 数据错了。是不是读入为 3 通道彩色图片，而 bytes 只计算了 H*W?", "Konwledge_Point": "线性规划简介", "Question": "C#数字图像处理点运算图像不全\nC#数字图像处理中的直方图变换，进行变换后只有一部分图像完成了变换，但灰度直方图显示已经完成了变换。请问以下如何解决这个显示问题\n\n\n\n\n\n\n\n\n部分源码如下：\n\n\n\n\n用的时线性变换，y=-x+255", "Tag": "算法分析"}
{"Answer": "(int)-0.5=-1\r\n这个才是科学的，因为int永远是找比自身小的最大整数。\r\n\r\njava需要判断\r\ndouble d = -0.5;\r\nint r = d > 0? (int)d : (int)d - 1;", "Konwledge_Point": "线性规划简介", "Question": "C中，(int)-0.5=-1,java中,(int)-0.5=0;java有没有类似算法\nC的这种方法的浮点整数映射上是线性的，java的方法在0附近将发生重叠，这样的话，在实数域处理问题要分类讨论，不方便。\n\n方法好像有Math.floor()，不知道还有没有简单的表达式", "Tag": "算法分析"}
{"Answer": "这就是简单的求常微分方程https://blog.csdn.net/lynn15600693998/article/details/86597068", "Konwledge_Point": "线性规划简介", "Question": "关于#matlab#的问题：kf、kn、c、h已知且为常数，i为随时间变化的函数且与x无关但i的所有值都知道\n\n\n\n\nkf、kn、c、h已知且为常数，i为随时间变化的函数且与x无关但i的所有值都知道，这样的一个非线性方程可以求出来吗？我需要每个时刻的x的值（有偿解题）", "Tag": "算法分析"}
{"Answer": "参考：\n使用svm对手写体数字图片进行分类_Walt_像道光的博客-CSDN博客\nimport pandas as pdfrom sklearn import svmimport joblibprint(“1.载入训练数据，对训练数据进行标准化”)train_data = pd.read_csv (‘dataset/digits_training.csv’)print(data)分类属性yTrain = train_data.values[:,0]特征属性xTrain = train_data.values[:,1:]标准化函数def normalization(X\n\n\n\nhttps://blog.csdn.net/m0_45426399/article/details/110528737\n\n\n这是预训练好的模型", "Konwledge_Point": "线性规划简介", "Question": "使用SVM对手写体数字图片分类，python报错\n使用SVM对手写体数字图片分类\n\n\nimport\n pandas \nas\n pd\n\nfrom\n sklearn \nimport\n svm\n\nimport\n joblib\n\nprint\n(\n\"1.载入训练数据，对训练数据进行标准化\"\n)\ntrain_data = pd.read_csv (\n'digits_training.csv'\n)\n\n# print(data)\n\n\n# 分类属性\n\nyTrain = train_data.values[:,\n0\n]\n\n# 特征属性\n\nxTrain = train_data.values[:,\n1\n:]\n\n\n# 标准化函数\n\n\ndef\n \nnormalization\n(\nX\n):\n    \nreturn\n (X-X.mean())/X.\nmax\n()\n\n# print(\"xTrain:{0}\".format(xTrain.shape))\n\n\n# 对特征属性进行标准化处理\n\nxTrain = normalization(xTrain)\n\n# print(xTrain.shape[1])\n\n\n# print(xTrain.shape)\n\n\nprint\n(\n\"训练数据：\"\n,xTrain.shape[\n0\n],\n\"条\"\n)\n\n\n# 构建模型\n\n\n'''\n默认核函数是 ‘rbf’-->就是radial basis function keranl (径向基核函数)\n模型准确率约为0.89\n使用线性核函数（linear）构建模型，准确率在0.908左右\n线性核函数主要用于线性可分的情况\n在特征数量相对于样本数量非常多的时候，适合采用线性核函数\n'''\n\nmodel = svm.SVC(decision_function_shape=\n'ovo'\n,kernel=\n'linear'\n)\n\nprint\n(\n\"2.训练模型……\"\n)\nmodel.fit(xTrain,yTrain)\n\nprint\n(\n\"3.保存模型……\"\n)\njoblib.dump(model,\n\"model/svm_classifier_model1.m\"\n)\n\nprint\n(\n\"4.加载测试数据，对测试数据进行标准化……\"\n)\ntest_data = pd.read_csv(\n\"digits_testing.csv\"\n)\nyTest = test_data.values[:,\n0\n]\nxTest = test_data.values[:,\n1\n:]\n\nprint\n(\n\"测试数据：\"\n,xTest.shape[\n0\n],\n\"条\"\n)\nxTest = normalization(xTest)\n\nprint\n(\n\"5.加载测试好的模型，进行预测……\"\n)\nmodel = joblib.load(\n\"model/svm_classifier_model1.m\"\n)\nresult =model.predict(xTest)\n\nprint\n(\n\"预测错误数据：\"\n,(result!=yTest).\nsum\n())\n\nprint\n(\n\"测试数据正确率：\"\n,(result==yTest).\nsum\n()/\nlen\n(yTest))\n\nprint\n(\n\"模型内构建正确率估计：\"\n,model.score(xTest,yTest))\n\n\n\n报错如下：\n文件夹里的数据集：\n\n\n'model/svm_classifier_model1.m'这个文件是干嘛的呀？", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/Olaking/article/details/43199003?locationNum=15", "Konwledge_Point": "线性规划简介", "Question": "如何解决numpy.ndarray' object is not callable\n我用python进行非线性规划时报错numpy.ndarray' object is not callable，有大佬可以帮忙解释一下吗\n\n直到最后一句res=minimize。。。才报错，之前检查过都没有问题\n\n\n\nfrom scipy.optimize import minimize\nimport numpy as np\ndef fun():\n    v=lambda x:abs((x(1)+0*x(2)+0*x(3)+0*x(4)+0*x(5)+0*x(6)+0*x(7)+0*x(8)+0*x(9)+0*x(10)+0*x(11)+0*x(12)+0*x(13)+0*x(14)))\n    return v\ndef cons():\n\n    # d,e=args\n    con=({'type':'eq','fun':lambda x: x(1)-(2171.4/0.85*x(2))},\n         {'type': 'eq', 'fun': lambda x: (x(5)*x(6)*89.496/6.28)-x(7)-x(8)},\n         {'type': 'eq', 'fun': lambda x: x(9)*x(10)-x(10)*x(11)-x(8)*x(11)},\n         {'type': 'eq', 'fun': lambda x: x(12) - x(13)+x(11)},\n         {'type': 'eq', 'fun': lambda x: x(10) - 12500*3.1415},\n         {'type': 'ineq', 'fun': lambda x: x(6) - x(14)},\n         {'type': 'ineq', 'fun': lambda x: x(3) - x(4)-2.45},\n         {'type': 'eq', 'fun': lambda x: x(14) - 12.14*3.1415},\n         {'type': 'ineq', 'fun': lambda x: x(4) - 2.45},\n         {'type': 'ineq', 'fun': lambda x: 97.55 - x(4)},\n         {'type': 'ineq', 'fun': lambda x: x(3) },\n         {'type': 'ineq', 'fun': lambda x: 95.1 - x(3)},\n         {'type': 'ineq', 'fun': lambda x: x(5)-2.45-x(4)},\n         {'type': 'ineq', 'fun': lambda x: 100-x(5)}\n    )\n    return con\na=fun()\nb=cons()\n# print(b)\nx0=np.asarray([3,4,3,2,3,4,3,2,3,4,3,2,3,2])\nbounds=((0,None),(0,None),(0,None),(0,None),(0,None),(0,None),(0,None),(0,None),(0,None),(0,None),(0,None),(0,None),(0,None),(0,None))\nres=minimize(a,x0,method='SLSQP',constraints=b,bounds=bounds)\nprint(res)\nprint(b)\n\n", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/lwgkzl/article/details/80948548", "Konwledge_Point": "线性规划简介", "Question": "怎么用python填充缺失值？\n我建立了一个图中的pm10和pm25的线性方程y=kx+b,y是pm10，x是pm25，请问怎么用python去填充，求具体代码，我还没学过python（只填充空值，原有数据不改变）", "Tag": "算法分析"}
{"Answer": "是的，在拟合gamlss模型前，应当先对响应变量进行Box-Cox转换，以保证拟合模型的准确性。如果残差仍然不服从正态分布，那么可以考虑使用family=BCT/BCCG/BCPE，这些模型可以拟合非正态分布的响应变量。", "Konwledge_Point": "线性规划简介", "Question": "拟合gamlss模型\n#拟合gamlss时数据不满足正态分布，在选择family=BCT/BCCG/BCPE前，必须先对响应变量进行box-cox转换之后才可以吗？\n#响应变量y和解释变量x之间拟合线性回归，残差的直方图接近正态分布，偏度为0.036，box转换后残差偏度为0,025，逆转换后响应变量仍然不服从正态分布", "Tag": "算法分析"}
{"Answer": "是的。。。数据结构就那么几种", "Konwledge_Point": "线性规划简介", "Question": "Java编程算法和数据结构?\n算法：解决具体问题所需要的解决方法。执行效率最快的最优算法。时间复杂度。输入，输出，有穷性，确定性，可行性。冒泡排序，二叉树遍历，最长回文，二分查找，指针，链表等，堆栈，队列等。力扣，codewar，算法导论。\n数据结构：逻辑结构：集合、线性、树形、图形结构，物理结构：顺序、链式存储结构。", "Tag": "算法分析"}
{"Answer": "Python开发环境、数据挖掘与统计分析等问题可以在本模块提问", "Konwledge_Point": "线性规划简介", "Question": "Pandas高级数据分析快速入门之五——机器学习特征工程篇\nPandas高级数据分析快速入门，包括：Python开发环境篇、基础篇、数据挖掘与统计分析篇、数据可视化篇、机器学习特征工程篇、机器学习预测分析篇。本篇为第五篇，通过机器学习方法和技术增强特征，使用线性回归算斜率、聚类数据密度算正常状态，以及相关系数等。\n\n\n\nhttps://xiaoyw.blog.csdn.net/article/details/120094548", "Tag": "算法分析"}
{"Answer": "一、绘制该DataFrame折线图\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndata = {\n        'A': [0, 1, 2, 1, 0],\n        'B': [1, 2, 3, 2, 1],\n        'C': [2, 3, 4, 3, 2]\n        }\ndf = pd.DataFrame(data, index=['one', 'two', 'three', 'four', 'five'], columns=['A', 'B', 'C'])\n\ny1=df['A'] # 取所有行的第1列数据为y1\ny2=df['B'] # 去所有行的第2列数据为y2\nx=np.arange(1, 6) # x为[0,1,2,3,4,5]\nax=plt.subplot(111) # 1行1列的一张子图，即只有一张图。三个1分别表示1行、1列、第1个\nax.plot(x,y1,'bD-') # 对y1的数据作图，b表示蓝色，D表示菱形，-表示实直线\nax.plot(x,y2,'r^--') # 对y2的数据作图，r表示红色，^表示三角形，--表示破折线\nplt.show()\n\n\n二、绘制柱状图和堆积柱状图\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndata = {\n        'A': [0, 1, 2, 1, 0],\n        'B': [1, 2, 3, 2, 1],\n        'C': [2, 3, 4, 3, 2]\n        }\ndf = pd.DataFrame(data, index=['one', 'two', 'three', 'four', 'five'], columns=['A', 'B', 'C'])\n#\ny1=df['C'] # 取所有行的第1列数据为y1\nx=np.arange(1, 6) # x为[0,1,2,3,4,5]\n# 绘制条形图\nplt.bar(x, y1,  width=0.5)\nplt.show()\n\n\n\n三、绘制散点图\n\n\n", "Konwledge_Point": "线性规划简介", "Question": "绘制DataFrame折线图及其他\n一（1）建立DataFrame，要求行标签为one,two,three,four,five字符串，列标签为A,B,C字符串，值为标准正态分布\n（2）绘制该DataFrame折线图\n二1）建立DataFrame，要求行标签为one,two,three,four,five字符串，列标签为A,B,C字符串，值为均匀分布\n（2）绘制柱状图和堆积柱状图\n三（1）建立DataFrame，要求列标签为A,B,C字符串，值是形状为（50，3）的均匀分布\n（2）以第一列值为x，第三列值为y，绘制散点图并拟合出一条线性回归线\n想知道如何撰写", "Tag": "算法分析"}
{"Answer": "\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport csv\n\nbj=['北京','22300.00' ,'28489.00', '34117.00', '37420.19']#北京价格\nsh=['上海','21501.00' ,'25910.00', '24866.00', '28981.11']#上海价格\nnj=['南京','11260.00','17884.00','15259.00','19708.33']#南京价格\nhz=['杭州','14748.00','16211.00','21225.00','24360.20']#杭州价格\nqd=['青岛','8437.00','8997.00','10052.00','12373.44']#青岛价格\nheaders=['城市','2015年','2016年','2017年','2018年','2019年']#csv的第一行标签\n\ndef huigui(t):#回归函数 t是城市价格列表\n    t=[float(i) for i in t[1:]]#把城市列表中的城市名排除，只留价格\n    b=np.mat(t)#把价格列表转为矩阵\n    b=b.T#矩阵转置\n    a=[[1,1],[2,1],[3,1],[4,1]]#坐标列表\n    a=np.mat(a)#坐标列表转矩阵\n    re=(a.T*a).I*a.T*b#用矩阵计算来获得回归方程的斜率和偏移 \n    re=re[0][0]*5+re[1][0]#用得到的斜率和偏移计算2019年（第5年）的价格\n    return round(np.array(re)[0][0],2)#返回计算的价格值\n\nbj.append(huigui(bj))#调用函数计算北京价格，并把结果加到北京价格列表\nsh.append(huigui(sh))#调用函数计算上海价格，并把结果加到上海价格列表\nnj.append(huigui(nj))#调用函数计算南京价格，并把结果加到南京价格列表\nhz.append(huigui(hz))#调用函数计算杭州价格，并把结果加到杭州价格列表\nqd.append(huigui(qd))#调用函数计算青岛价格，并把结果加到青岛价格列表\n    \n\n\nwith open('price2019.csv','w')as f:#创建csv文件\n    f_csv = csv.writer(f)#创建csv对象以写入csv文件\n    f_csv.writerow(headers)#向csv写入第一行标签\n    f_csv.writerow(bj)#写入北京价格\n    f_csv.writerow(sh)#写入上海价格\n    f_csv.writerow(nj)#写入南京价格\n    f_csv.writerow(hz)#写入杭州价格\n    f_csv.writerow(qd)#写入青岛价格\n", "Konwledge_Point": "线性规划简介", "Question": "25一题，Python 类型的，不怎么会写\n现有“price2018.txt”文件，存储了2015年至2018年主要城市住宅商品房平均销售价格(元/平方米)数据。编写程序，将数据整理成二维表格形式，并采用线性回归模型估算2019年商品房平均销售价格，将读取二维数据和预测数据保存到”price2019.csv”文件中。（写点注释求求大佬）\nhttps://share.weiyun.com/AX0yMUUs", "Tag": "算法分析"}
{"Answer": "你说的这些牵涉到两个概念`数据清洗（去噪）`和`迁移学习`。\r\n两者的区别在于，前者，将你所谓的所有企业当成一个模型去学习，后者的意思是，你根据某个企业的数据去学习的权重在另一个企业中不能直接拿来做预测，而是需要通过迁移学习修改权重。", "Konwledge_Point": "线性规划简介", "Question": "关于缺失值和异常值等数值处理的疑问\n网上看了很多关于异常值处理，缺失值填充的文章，感觉有些简单化处理了。。不知道是否我自己钻牛角尖了。。\n\n我手头有一组数据，其中数据是不同企业各自的数据记录。其中不少记录是有异常值和缺失值的。\n\n1. 不同企业之间差别较大，异常值的判定，需要通过对企业分组进行判定。换句话说，一个数值在这个企业可能是正常值，而对另外一个企业可能就是异常值。\n\n2. 关于缺失值的填充，同样存在类似问题。。不同企业之间的数据差别可能较大，如果数据填充时，用简单的均值或是线性插值法填充，就会导致数据填充的可信度较低。我个人以为，也应该按照企业分组来进行分别填充处理。\n\n我不知道是否我的想法有些极端了，亦或是本身数据处理就不必思考过多。毕竟数据本身就很可能存在不少异常或缺失情况，而有些模型对异常或缺失值又并不敏感。。\n\n想请教下各位，具体数据处理过程中，是怎样做呢？", "Tag": "算法分析"}
{"Answer": "望采纳。。setPeekHeight是弹出的高度，它和你的layout_height没有直接联系，你弄混淆了", "Konwledge_Point": "线性规划简介", "Question": "安卓BottomSheetBehaviour的peekheight，setState等无作用\n  安卓BottomSheetBehavior设置状态和peek不能改变view的高度，view的高度一直保持为设置的height\n\n\n我想实现高度地图首页底部弹窗的效果.这个窗口我用线性布局器作为coordinator的子view，页面效果没问题，然而不能通过behaviour的peek，setState等设置窗口的高度。API31\n\n\n//behaviour\n设置\n bottomSheetBehavior=BottomSheetBehavior.from\n(fragmentBinding.bom)\n;\n bottomSheetBehavior.\nset\nState\n(STATE_COLLAPSED)\n;\n bottomSheetBehavior.\nset\nPeekHeight\n(10)\n;   \n//10px\n，如果设置成功view应该很小\n\n\n//\n底部窗口的XML\n\n\n...\n\n<\n/LinearLayout\n>\n\n\n\n依然是xml的height=100dp属性设置的高度，而不是peek设置的10px", "Tag": "算法分析"}
{"Answer": "这样看，还觉得初始化了吗，看代码当然知道for里面一定会走；但是编译器并不会这样觉得，for里面只有第一个定义会走，其他的不一定会走", "Konwledge_Point": "线性规划简介", "Question": "java中关于布尔型变量遇到的问题\n问题：对布尔型变量定义之后，明明后面对变量赋了值，但在使用时依然提醒没有初始化\n\n\n\n\npublic\n \nclass\n \nArrayFind\n {\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[] args)\n \n{\n\n        \n//线性查找\n\n        \nString\n[] arr = \nnew\n \nString\n[]{\n\"AA\"\n, \n\"BB\"\n, \n\"CC\"\n, \n\"DD\"\n, \n\"EE\"\n, \n\"FF\"\n};\n        \nString\n dest = \n\"BB\"\n;\n        \nboolean\n isFind;\n        \nfor\n (\nint\n i = \n0\n; i < arr.length;i++){\n            isFind = \ntrue\n;\n            \nif\n (dest.\nequals\n(arr[i])){\n                isFind = \nfalse\n;\n                System.out.\nprintln\n(i);\n                \nbreak\n;\n            }\n        }\n        \nif\n (isFind)\n        {\n            System.out.\nprintln\n(\n\"很遗憾没找到\"\n);\n        }\n\n\n    }\n}\n\n\n\n\n\n\n\nF:\\Java_workspace\\Day3\\src\\ArrayFind.java:16:13\njava: 可能尚未初始化变量isFind\n\n\n将boolean isFind那一句改成Boolean isFind = true;后面可以使用\n\n\n我想知道里面的内在原因是什么，后面对isFind变量赋了值，为什么提示没有初始化。", "Tag": "算法分析"}
{"Answer": "还有一种办法是在for循环中对变量设置值：在第14行与16行之间添加：checkvar[i].set(i)输出：PY_VAR0 ~ 0为0~6", "Konwledge_Point": "线性规划简介", "Question": "将checkbutton设置在类中时，不管选中与未选中的variable值都是0(语言-python)\n当我单独设置checkbutton时，能够正常运行\n\n\nimport\n tkinter \nas\n tk \n\nfrom\n tkinter \nimport\n *\n\nfrom\n tkinter \nimport\n ttk\n\nwindow\n = tk.Tk()\n\n\ncolumns\n = [\n'组序'\n,\n'热丝电流(A)'\n,\n'激光功率'\n,\n'送丝速度'\n,\n'焊接速度'\n,\n'对接间隙'\n,\n'得分'\n]\n\ndef \ncheck\n(num):\n    print(checkvar[num],\n'='\n,checkvar[num].\nget\n())\n\ncheckvar = [\nNone\n]*len(\ncolumns\n)#生成一个具有维度的空列表\n    \n\nfor\n i \nin\n range(len(\ncolumns\n)):\n    checkvar[i] = tk.IntVar()\n    checkbutton = tk.Checkbutton(\nwindow\n,\ntext\n=\ncolumns\n[i],variable=checkvar[i],command=lambda x=i: \ncheck\n(x))\n    checkbutton.deselect()\n    checkbutton.grid(\nrow\n=i,column=\n0\n,sticky=\n'w'\n)\n\n\nwindow\n.mainloop()\n\n\n\n结果如下\n\n\n但是当我将这段代码放到类中去就出现了如下问题，不管有没有选中，variable的返回值都为0，如下\n\n\nimport\n tkinter \nas\n tk \n\nfrom\n tkinter \nimport\n *\n\nfrom\n tkinter \nimport\n ttk\n\n\nclass\n \nnonlinear_fit_class\n:\n    \ndef\n \n__init__\n(\nself\n):\n        \n#根窗口\n\n        self.root = tk.Tk()\n        self.button_nonlinear = tk.Button(self.root,text=\n'非线性拟合'\n,command=self.nonlinear_fit)\n        self.button_nonlinear.pack()\n        self.root.mainloop()\n\n    \n#定义非线性拟合函数\n\n    \ndef\n \nnonlinear_fit\n(\nself\n):\n        window = tk.Tk()\n\n        columns = [\n'组序'\n,\n'热丝电流(A)'\n,\n'激光功率'\n,\n'送丝速度'\n,\n'焊接速度'\n,\n'对接间隙'\n,\n'得分'\n]\n\n        \ndef\n \ncheck\n(\nnum\n):\n            \nprint\n(checkvar[num],\n'='\n,checkvar[num].get())\n\n        checkvar = [\nNone\n]*\nlen\n(columns)\n#生成一个具有维度的空列表\n\n\n        \nfor\n i \nin\n \nrange\n(\nlen\n(columns)):\n            checkvar[i] = tk.IntVar()\n            checkbutton = tk.Checkbutton(window,text=columns[i],variable=checkvar[i],command=\nlambda\n x=i: check(x))\n            checkbutton.deselect()\n            checkbutton.grid(row=i,column=\n0\n,sticky=\n'w'\n)\n        \nprint\n(checkvar)\n\n        \n#button = tk.Button(window,text='应用',command=check).grid(row=1,column=0)\n\n\n        window.mainloop()\n        \nA = nonlinear_fit_class()\n\n\n\n\n\n我就是希望能够通过选中checkbutton来索引对应checkbutton的名称，所以想借助variable的值来高速机器我选中了这个button，再获取button名称\n\n\n能力有限，卡了两天都没解决这个问题，上网没找到类似问题，来这里寻求各位的帮助", "Tag": "算法分析"}
{"Answer": "Gerber 文件格式，主要有274D，274X和X2，三种格式。目前用得比较多的还是274X。\n相对于274D，274X将Aperture文件集成到轨迹文件里面了，即只有一个文件。\n这种文件的设计本来出发点是为光绘机绘制底片，所以只是通过轨迹的方式来描述图形。", "Konwledge_Point": "线性规划简介", "Question": "Gerber文件代码解析\n问题遇到的现象和发生背景\n\n\ngerber文件解析\n\n\n问题相关代码，请勿粘贴截图\n\n\nGerber文件中的X1，Y3是什么？下文是什么意思？\n\n\nG36\n*                                                                 \n//G36 　打开多边形填充   \n\nX\n1520073\nY\n395960\nD\n02\n*\n\nG01\nX\n1519989\nY\n395964\nD\n01\n*                                \n//G01 1 倍线性运动         D01 划线，开光圈\n\nX\n1520157\n*\nX\n1520073\nY\n395960\n*\n\nG37\n*          \n\n\n%\nADD\n210\nR,\n0.02201\nX\n0.03937\n*\n%\n\n\n%\nADD\n211\nR,\n0.04331\nX\n0.03937\n*\n%\n\n\n%\nADD\n212\nR,\n0.02201\nX\n0.03984\n*\n%\n\n\n%\nADD\n213\nR,\n0.04331\nX\n0.03984\n*\n%\n\n\n%\nADD\n214\nR,\n0.02709\nX\n0.03984\n*\n%\n\n\n%\nADD\n215\nR,\n0.02709\nX\n0.03937\n*\n%\n\n\n%\nADD\n216\nR,\n0.02283\nX\n0.01591\n*\n%\n\n\n%\nADD\n217\nR,\n0.01413\nX\n0.01591\n*\n%\n\n\n%\nADD\n218\nR,\n0.02709\nX\n0.01067\n*\n%\n\n\n%\nADD\n219\nR,\n0.02717\nX\n0.04311\n*\n%\n\n\n%\nADD\n220\nR,\n0.01988\nX\n0.01591\n*\n%\n\n\n%\nADD\n222\nR,\n0.03051\nX\n0.03189\n*\n%\n\n\n%\nADD\n223\nR,\n0.03189\nX\n0.03051\n*\n%\n\n", "Tag": "算法分析"}
{"Answer": "https://github.com/integralpro/libpger/blob/master/antlr/Gerber.g\n通常这类文法解析都采用通用文法解析器完成，常见的文法解析引擎是antlr，yacc，Babel当然上学的时候编译原理的老师一般会教BNF+yacc，不过现在实际应用的比较多是antlr，babelantlr4下比较常见的语言的文法解析规则在下面https://github.com/antlr/grammars-v4\n可惜你这个Gerber实在是个小众偏门DSL，所以anltr4没有收集，我只找到一个很多年前anltr3的定义https://github.com/integralpro/libpger/blob/master/antlr/Gerber.g\n我们可以参考这个写出Antlr4的解析文法（如果你有兴趣的学学anltr4的话）\n有关如何在C#里用antlr4，我到不用赘述了。这种文章到多，随便百度一下就行。\n随带说一句：如果知道这些，就可以摆脱那些语言之争和某某园子偶尔会折腾的啥中文编程，我实现了一门语言这类东西。单纯文法词法分析目前并不困难，难的是你用词法分析器是人家的，你最后的对语法树的编译是人家的。所以仅仅说自己实现一个DSL文法，对一个会玩antlr的人并不困难，一个星期就可以弄个稍微的“中文编程语言”出来了", "Konwledge_Point": "线性规划简介", "Question": "用C，C#，C++，编写程序，读取Gerber文件，导出其元件类型，元件中心坐标信息，放置角度信息，该如何下手？\n问题遇到的现象和发生背景\n\n\n用C，C#，C++，编写程序，读取Gerber文件，导出其元件类型，元件中心坐标信息，放置角度信息，该如何下手？\n\n\n问题相关代码，请勿粘贴截图\n\n\nGerber指令代码\n%FSLAX34Y34*%                        FS 格式描述  L 省略前导零，A 绝对坐标，三位整数，四位小数\n%MOMM*%                              MO Mode 单位          MM 毫米\n%ADD70C,0.000000*%               AD Aperture Definition 光圈描述    定义D70码为圆，直径 0MM\n%ADD71C,0.300000*%\n%LNConvertedAllPolygons*%                    LN 层名 ConvertedAllPolygons\n%LPD*%                                                    LP 层正负性  D 设置为正图\nG36*                                                         G36 打开多边形填充\nX635760Y1095810D02*                              D02 关光圈，移动到 X63 5760       Y109 5810\nX632760Y1095810D01*                              D01 划线，开光圈    X63 2760       Y109 5810\nG75*                                                          G75 启用 360°的画圆功能\nG03X631760Y1094720I-4J-999D01*            G03 逆时针圆周运动 I，J 格式描述弧形位置。\nG74*                                                          G74 关闭 360 度圆周运动\nG01*                                                          G01 1 倍线性运动\nX631760Y1091810D01*                              光圈说白了就是形状，不同的光圈就是不同的形状。pcb里面常见的形状有，圆形、方形、椭圆等等。\nG75*                                                          分别表示某个焊盘的形状\nG03X632760Y1090810I996J1D01*", "Tag": "算法分析"}
{"Answer": "https://wenku.baidu.com/view/fb00c1c2c4da50e2524de518964bcf84b8d52d62.html", "Konwledge_Point": "线性规划简介", "Question": "数据结构实验：单链表\n实现线性结构上的单链表的产生以及元素的查找、插入与删除。具体实现要求：\n\n（1）从键盘输入20个整数，用前插法或尾插法输入结点值。\n\n（2）从键盘输入1个整数，在单链表中查找该结点的位置。若找到，则显示“找到了”；否则，则显示“找不到”。\n\n（3）从键盘输入2个整数，一个表示欲插入的位置i，另一个表示欲插入的数值x，将x插入在对应位置上，输出单链表所有结点值，观察输出结果。\n\n（4）从键盘输入1个整数，表示欲删除结点的位置，输出单链表所有结点值，观察输出结果。\n\n（5）将单链表中值重复的结点删除，使所得的结果表中个结点值均不相同，输出单链表所有结点值，观察输出结果。\n\n（6）删除其中所有数据值为偶数的结点，输出单链表所有结点值，观察输出结果。\n\n（7）将单链表分解成两个单链表A和B，使A链表中含有原链表中序号为奇数的元素，而B链表中含有原链表中序号为偶数的元素，且保持原来的相对顺序，分别输出单链表A和单链表B的所有结点值，观察输出结果。", "Tag": "算法分析"}
{"Answer": "这道题答案不是很重要，思路比较重要，上面有的人说的答案也对，但是不精确（有时候不精确不会产生大的问题，有时候就会，下面会解释\r\n\r\n这个观点），所以LZ最好亲自试试下面的过程。另外，本题涉及几个知识点。我详细解释下。\r\n1.如果你是想在JAVA代码级别解释这个问题，那么你是在浪费时间。这个问题必须到JVM生成的代码级别讨论（很多问题都是这个样子，在\r\n\r\nJAVA代码级别讨论不仅浪费时间，而且没有意义，记得有人跟我说过一句话：在你所处理的层面，问题根本还没有浮现（非编程问题））。\r\n2.\r\n\r\npublic class TestJVM {\r\n    public static void main(String[] args)\r\n    {\r\n        TestJVM abc = new TestJVM();\r\n    }\r\n}\r\n\r\n代码用javap -c 命令反编译TestJVM.class文件后（我建议你自己试试），生成\r\n...\r\n\r\npublic TestJVM();\r\n  Code:\r\n   0:\taload_0\r\n   1:\tinvokespecial\t#8; //Method java/lang/Object.\"\":()V\r\n   4:\treturn\r\npublic static void main(java.lang.String[]);\r\n  Code:\r\n   0:\tnew\t#1; //class TestJVM\r\n   3:\tdup\r\n   4:\tinvokespecial\t#16; //Method \"\":()V\r\n   7:\tastore_1\r\n   8:\treturn\r\n...\r\n\r\n解释这段代码是这道问题的第一步,建议你大概查阅下JVM规范，因为我也刚查了。\r\n(1) new 的含义是创造一块内存，并且在堆栈上压入指向这块内存的引用。\r\n(2) dup的含义是将栈顶复制，并压入栈。(所以现在有了两个指向刚才分配内存的引用)\r\n(3) invokespecial意思是将分配的内存中初始化对象。\r\n(4) astore_1是将栈顶压入本地变量。\r\n(这段过程，我建议你自己多画几遍，体会下JVM\"面向堆栈\"的概念,JVM规范第一章最好看看)\r\n3.上面的四个步骤(绝对的物理过程)，其实就是三件事（体会一下原子语句的含义）:\r\n\ta.给实例分配内存。\r\n\tb.初始化构造器\r\n\tc.将引用指向分配的内存空间（注意到这步引用就非null了）。\r\n一般来说，我们期望执行的步骤是a->b->c，然而，由于JVM乱序执行的特性（自己查查这句话在哪，别轻易相信别人,虽然有时候文档也是会\r\n\r\n骗人的-!-）,可能执行的顺序是a->c->b。当a->c->b这样执行时候，假如刚执行完c，这样线程2访问这个引用，发现引用不为空，他就对相\r\n\r\n应的内存做操作，这样就会发生错误，这种错误想必不容易发现(那是不是不容易发生？取决于具体的应用环境。)。\r\n\r\n4.问题的关键用一句话来概括，就是这个意思：if(instance==null),如果instance !=null,那么instance就真的准备好了么？ \r\n所以，最原始的写法虽然慢，但是不会产生这种问题，因为原始写法把判断是否等于null的语句，也给锁起来了。只有得到锁，才有资格判断\r\n\r\n。\r\n5.上面的几条，你也许看了第四条，或者大概明白前几条，你的问题就能解答了。不精确的了解似乎也能回答，但是，有好多误解就产生了。\r\n比如，有人说，加了valatile类型修饰（JVM1.5以后）符可以将LZ的写法变对，如private volatile static Singleton instance = null;\r\n其实这是不对的，valatile（LZ想想为什么valatile影响效率？理解下寄存器和内存的效率差别）无非说的就是线程是不能保留共享对象的本地\r\n\r\n拷贝（正常情况线程是可以保留的）,那是不是每次去内存中取，就能保证单例对象的正常初始化呢？很明显，这完全是两个问题。\r\n\r\n6.很多细节问题（编程方面），你都得查查英文文档，得自己写试试，中文大家说的话都非常像（因为都是同一本书里面说的，再加上第一个\r\n\r\n人的翻译水平不咋样），很多误解就此产生。", "Konwledge_Point": "线性规划简介", "Question": "单例模式并发的问题！\n[code=\"java\"]\n\npublic static Singleton getInstance() {\n\n    if(instance == null) {\n\n        synchronized(Singleton.class) {\n\n            if(instance == null) {\n\n                instance = new Singleton();\n\n            }\n\n        }\n\n    }\n\n\n\nreturn instance;\n\n\n\n\n}\n\n[/code]\n\n\n\n在一本并发书上看见的，说这个单例会造成有一些问题，具体原因是因为java对读写共享对象的域时并不保证可线性化性，甚至不保证顺序一致性。原因在于，如果严格遵循顺序一致性，那么将会导致已被广泛采用的编译优化技术变得无效。\n\n\n\n大牛们，解释下？说实话，我是看的一头雾水。\n\n书中指出这段代码有误，但是紧跟的内容感觉和这段牛头不对马嘴，紧跟的内容大致讨论了同步块在线程中的作用，以及对线程cache拷贝和共享存储器之间的关系。\n\n\n\n书名：多处理编程的艺术 - P42\n\n\n\n顺便说两句闲话，发帖到论坛被弄成隐藏贴。我想知道为什么会被隐藏。我感觉这个问题超出了问题的本生，很有高度的一个问题。\n\n  当然也有可能很菜的我，不能理解各位大神的思想。", "Tag": "算法分析"}
{"Answer": "这里啊", "Konwledge_Point": "线性规划简介", "Question": "TypeError: 'numpy.float64' object is not callable\n我想用curve_fit拟合一条复杂曲线，并求出方程中的三个参数，但是运行后程序报错如下\n\n\nTypeError: 'numpy.float64' object is not callable\n\n\n\n\n代码如下，哪里出错了，我没有找到变量和函数名冲突\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom\n scipy.optimize import curve_fit\n\n\n# a,b,c是需要求出来的三个参数，D,z,ee全都是已知的。 \n\ndef dfin(x, a, b, c):\n    return ((a*z*\n*b\n-30.0)(1.0-np.exp(-np.log(2.0*(x/ee)*\n*c\n))))\n\n\nD = 30.0\nz = 1.31\n*10\n*\n*21\n\nee = 0.0016\n*D\n*\n*0\n.2709*z*\n*0\n.1147\n\n# 给出x、y对应坐标\n\nx = [1.29, 1.24, 1.11, 0.97, 0.82, 0.68, 1.07, 0.86, 0.64, 0.52]\nx = np.array(x)\nnum = [15.7, 15.0, 18.2, 18.7, 21.1, 24.5, 15.7, 21.2, 24.8, 31.7]\ny = np.array(num)\n\n\n# 非线性最小二乘法拟合\n\npopt, pcov = curve_fit(dfin, x, y)\n\n# 获取popt里面拟合系数\n\n\nprint\n(popt)\na = popt[0]\nb = popt[1]\nc = popt[2]\nyvals = dfin(x, a, b, c)\n\nprint\n(\n'系数a:'\n, a)\n\nprint\n(\n'系数b:'\n, b)\n\nprint\n(\n'系数c:'\n, c)\n\nprint\n(\n'系数yvals:'\n, yvals)\n\n\n# 绘图\n\nplot1 = plt.plot(x, y, \n's'\n, \nlabel\n=\n'original values'\n)\nplot2 = plt.plot(x, yvals, \n'r'\n, \nlabel\n=\n'polyfit values'\n)\nplt.xlabel(\n'x'\n)\nplt.ylabel(\n'y'\n)\nplt.legend(\nloc\n=4)\nplt.title(\n'curve_fit'\n)\nplt.show()\n\n", "Tag": "算法分析"}
{"Answer": "成员函数，参数末尾有个隐含的参数 A * this\r\n这使得它实际上多一个参数，而核函数指针的类型不匹配。", "Konwledge_Point": "线性规划简介", "Question": "levmar 库 dlevmar_dif函数第一个参数使用成员函数指针报错 \n使用levmar库通过LM算法求解非线性最小二乘。 c++版本的函数\n\nint dlevmar_dif(\n\nvoid (*func)(double \np, double *hx, int m, int n, void *adata), /\n functional relation describing measurements.\n\ndouble \np,         /\n I/O: initial parameter estimates. On output contains the estimated solution \n/\n\ndouble *x,         /\n I: measurement vector. NULL implies a zero vector \n/\n\nint m,             /\n I: parameter vector dimension (i.e. #unknowns) \n/\n\nint n,             /\n I: measurement vector dimension \n/\n\nint itmax,         /\n I: maximum number of iterations \n/\n\ndouble opts[5]）\n\n第一个参数是函数指针，直接用函数赋值可以运行。例如\n\nvoid a(double\n,double*,int,int,void*);\n\ndlevmar_dif(a............);\n\n\n\n但是使用类成员函数指针就会报错。例如\n\nclass A\n\n{\n\npublic:\n\nA{};\n\nvoid a(double*,double*,int,int,void*);\n\n};\n\nA test;\n\nvoid (A::*a_ptr)(double*,double*,int,int,void*)=&A::a;\n\n\n\ndlevmar_dif(test.*a_ptr      ………………        );\n\n就会报错 invalid use of non-static number function.\n\n\n\n请问这是因为普通函数指针和类成员函数指针有什么本质的区别吗？\n\n\n\n或者推荐我一个好用的LM算法库也可以。\n\n\n\n谢谢！", "Tag": "算法分析"}
{"Answer": "思路：x这个数是2的n次幂的和。分解x，如x转换成2机制数1010就表示2（10）+8（1000），下面是算法\r\npublic static void getRes(int x){\r\n\t\t//loop记录位数\r\n\t\tint loop = 0;\r\n\t\tint i;\r\n\t\twhile(true){\r\n\t\t\ti=x&1;\r\n\t\t\t//x的最后一位是否是1\r\n\t\t\tif(i == 1){\r\n\t\t\t\t//1左移位数就是结果\r\n\t\t\t\t//相当于2的loop次幂\r\n\t\t\t\tSystem.out.println(i<>1;\r\n\t\t\tif(x == 0)\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}", "Konwledge_Point": "线性规划简介", "Question": "一道面试题\n已知一个集合,{1,2,4,8,16.....}\na + b + c + n = x\na b c ...都是集合里的任意数,x已知,求a b c...值\n比如 \na(2) + b(8) + c(16) = 26 \na(1) + b(2) = 3\na(1) + b(4) + c(8) = 13\na(1) + b(2) + c(4) + d(8) = 15  \n问题补充\n抛出异常的爱 写道\n\n\nxiaozhen57520 写道\n\n\n已知一个集合,{1,2,4,8,16.....}\na + b + c + n = x\na b c ...都是集合里的任意数,x已知,求a b c...值\n比如 \na(2) + b(8) + c(16) = 26 \na(1) + b(2) = 3\na(1) + b(4) + c(8) = 13\na(1) + b(2) + c(4) + d(8) = 15  \n\n\n大学线性代数习题.\n怎么弄,我不会\n问题补充\n抛出异常的爱 写道\n\n\nxiaozhen57520 写道\n\n\n\n\n抛出异常的爱 写道\n\n\n\n\nxiaozhen57520 写道\n\n\n已知一个集合,{1,2,4,8,16.....}\na + b + c + n = x\na b c ...都是集合里的任意数,x已知,求a b c...值\n比如 \na(2) + b(8) + c(16) = 26 \na(1) + b(2) = 3\na(1) + b(4) + c(8) = 13\na(1) + b(2) + c(4) + d(8) = 15  \n\n\n大学线性代数习题.\n\n\n怎么弄,我不会\n\n\n看错题了....\n应该是二进制的问题.\n\n\n见过,看见别人用Xor 异或弄过.", "Tag": "算法分析"}
{"Answer": "供参考：\n#include <stdio.h>\n#include <stdlib.h>\ntypedef int DataType;\ntypedef struct node\n{\n    DataType data;\n    struct node* next;\n}LNode, * LinkList;\nLinkList CreatLinkList(); //创建带头结点单链表,并返回头指针。\nvoid PrintLinkList(LinkList H);//依次输出单链表H中各个元素结点，若为空表则输出NONE。\nLinkList CombineList(LinkList La, LinkList Lb);\nint main()\n{\n    LinkList la, lb;\n    la = CreatLinkList();\n    lb = CreatLinkList();\n    la = CombineList(la, lb);\n    PrintLinkList(la);\n    return 0;\n}\n\nLinkList CreatLinkList()\n{\n    int n, i;\n    LNode* nw, * rear = NULL, *head = NULL;\n    head = (LNode*)malloc(sizeof(LNode));\n    rear = head;\n    scanf(\"%d\", &n);//接收结点总数\n    for (i = 0; i < n; i++)\n    {\n        nw = (LNode*)malloc(sizeof(LNode));\n        scanf(\"%d\", &nw->data);\n        rear->next = nw;\n        rear = nw;\n    }\n    rear->next = NULL;\n    return head;\n}\n\nvoid PrintLinkList(LinkList H)\n{\n    LNode* p;\n    if (!(H->next))\n    {\n        printf(\"NONE\\n\");\n        return;\n    }\n    for (p = H->next; p; p = p->next)\n        printf(\"%d \", p->data);\n    printf(\"\\n\");\n}\n\n/* 请在这里填写答案 */\n\nLinkList CombineList(LinkList La, LinkList Lb)\n{\n    int m = 0, n = 0, i = 0;\n    LinkList p = La->next;\n    LinkList q = Lb->next;\n    LinkList p1 = La->next;\n                  //LinkList p2 = p1->next;\n    LinkList q1 = Lb->next;\n                  //LinkList q2 = q1->next;\n    LinkList h, head;\n    while (p) { p = p->next; m++; }\n    while (q) { q = q->next; n++; }\n    if (m <= n)\n    {\n        head = h = La;\n        while (p1 && q1)\n        {\n            i++;\n            if (i % 2) {\n                head->next = p1;\n                head = p1;\n                p1 = p1->next;\n            }\n            else {\n                head->next = q1;\n                head = q1;\n                q1 = q1->next;\n            }\n#if 0\n            q1->next = p1->next;\n            p1->next = q1;\n            q1 = q2;\n            p1 = p2;\n            p2 = p2->next;\n            q2 = q2->next;\n            m--;\n            n--;\n#endif\n        }\n        if (p1)\n        {\n            head->next = p1;//q1->next = p1;\n        }\n        if (q1)\n        {\n            head->next = q1;//p1->next = q1;\n        }\n        free(Lb);\n    }\n    else\n    {\n        head = h = Lb;    //修改\n        while (p1 && q1)\n        {\n            i++;\n            if (i % 2) {\n                head->next = q1;\n                head = q1;\n                q1 = q1->next;\n            }\n            else {\n                head->next = p1;\n                head = p1;\n                p1 = p1->next;\n            }\n        }\n#if 0\n            p1->next = q1->next;\n            q1->next = p1;\n            q1 = q2;\n            p1 = p2;\n            p2 = p2->next;\n            q2 = q2->next;\n            m--;\n            n--;\n    }\n#endif\n        if (q1)\n        {\n            head->next = q1;  //p1->next = q1;\n        }\n        if (p1)\n        {\n            head->next = p1; //q1->next = p1;\n        }\n        free(La);\n    }\n    return h;\n}\n\n", "Konwledge_Point": "线性规划简介", "Question": "两个单链表元素交叉合并\npta显示段错误，不知道哪里错了\n\n\n题目：\n\n\n设带头结点的线性单链表A={\na1\n,\na2\n,...,am}，\nB={b1,b2,...,bn} \n。试编写算法按下列规则合并A、\nB为线性单链表C，使得\n\n\n C={\na1\n,\nb1,a2,b2,...am,bm,...,bn} \n，  m<=n\n 或者\n C={\nb1,a1,b2,a2,...,bn,an,...,am} \n,   m>n\n\n\n\n其中 La 和 Lb 都是用户传入的参数，分别为待合并单链表的头指针。函数须返回合并后的单链表的头指针。\n\n\n函数接口定义：\n\n\nLinkList CombineList(LinkList La,LinkList Lb); \n\n\n裁判测试程序样例：\n\n\n#include \n#include \ntypedef int DataType;\ntypedef struct node\n{\n    DataType data;\n    struct node *next;\n}LNode,*LinkList;\n\n\nLinkList CreatLinkList();  //创建带头结点单链表,并返回头指针。\nvoid PrintLinkList(LinkList H);//依次输出单链表H中各个元素结点，若为空表则输出NONE。\nLinkList CombineList(LinkList La,LinkList Lb);\nmain()\n{\n    LinkList la,lb;\n    la = CreatLinkList();\n    lb = CreatLinkList();\n    la=CombineList(la,lb);\n    PrintLinkList(la);\n}\n\n\nLinkList CreatLinkList()\n{\n    int n,i;\n    LNode *nw,*rear=NULL,\nhead=NULL;\n    head=(LNode\n)malloc(sizeof(LNode));\n    rear=head;\n    scanf(\"%d\",&n);//接收结点总数\n    for(i=0;idata);\n        rear->next=nw;\n        rear=nw;\n    }\n    rear->next=NULL;\n    return head;\n}\n\n\nvoid PrintLinkList(LinkList H)\n{\n    LNode *p;\n    if(!(H->next))\n    {\n        printf(\"NONE\\n\");\n        return;\n    }\n    for(p=H->next;p;p=p->next)\n        printf(\"%d \",p->data);\n    printf(\"\\n\");\n}\n\n\n/* 请在这里填写答案 */\n\n\n我的答案：\n\n\nLinkList CombineList(LinkList La,LinkList Lb)\n{\n    int \nm\n=0,n=0;\n    LinkList \np\n=La;\n    LinkList \nq\n=Lb;\n    LinkList \np1\n=La;\n    LinkList \np2\n=p1->next;\n    LinkList \nq1\n=Lb;\n    LinkList \nq2\n=q1->next;\n    LinkList h;\n    \nwhile\n(p)\n    {\n        \np\n=p->next;\n        m++;\n    }\n    \nwhile\n(q)\n    {\n        \nq\n=q->next;\n        n++;\n    }\n    \nif\n(m<=n)\n    {\n        \nh\n=La;\n        \nwhile\n(p1&&q1)\n        {\n            q1->\nnext\n=p1->next;\n            p1->\nnext\n=q1;\n            \nq1\n=q2;\n            \np1\n=p2;\n            \np2\n=p2->next;\n            \nq2\n=q2->next;\n            m--;\n            n--;\n        }\n        \nif\n(p1)\n        {\n            q1->\nnext\n=p1;\n        }\n        \nif\n(p2)\n        {\n            p1->\nnext\n=q1;\n        }\n        free(Lb);\n    }\n    \nelse\n\n    {\n        \nh\n=Lb;\n        \nwhile\n(p1&&q1)\n        {\n            p1->\nnext\n=q1->next;\n            q1->\nnext\n=p1;\n            \nq1\n=q2;\n            \np1\n=p2;\n            \np2\n=p2->next;\n            \nq2\n=q2->next;\n            m--;\n            n--;\n        }\n        \nif\n(q1)\n        {\n            p1->\nnext\n=q1;\n        }\n        \nif\n(p1)\n        {\n            q1->\nnext\n=p1;\n        }\n        free(La);\n    }\n   return h;\n}\n\n", "Tag": "算法分析"}
{"Answer": "你可以去看看django的中文文档，关于django的模板语言，视图函数部分，或者运行一下runserver，看看运行结果，就知道了，pyecharts用于生成可视化图表，数据来源是django的模型也就数据库，再通过django的模板语言生成html，展示给用户", "Konwledge_Point": "线性规划简介", "Question": "pyecharts与django结合的原理是什么？\npyecharts与django结合的原理是什么？百度到的资料很少，现摘录一段，请帮分析一下，谢谢！\n原文链接：\nhttps://blog.csdn.net/u013421629/article/details/78192402\n这个是views.py：\n\n\ndef index(request):\n    template = loader.get\n_template('\nmyfirstvis\n/\npyecharts\n.\nhtml\n')\n\n    l3d = line3d\n()\n\n    context = dict(\n        myechart=l3d.render\n_embed()\n,\n        host=DEFAULT_HOST,\n        script_list=l3d.get\n_js_dependencies()\n\n    )\n    return \nHttpResponse(\ntemplate\n.\nrender\n(\ncontext\n, \nrequest\n)\n)\n\n\ndef line3d\n()\n:\n#一个定义线性\n3\nD图的函数，不再照抄\n    return line3d\n\n\n\n这个是html：\n\n\n\n\n\n\n<\nhtml\n>\n\n\n\n<\nhead\n>\n\n    \n<\nmeta\n \ncharset\n=\n\"utf-8\"\n>\n\n    \n<\ntitle\n>\nProudly presented by PycCharts\n\n\n    \n{% \nfor\n jsfile_name \nin\n script_list %}\n\n    \n<\nscript\n \nsrc\n=\n\"\n{{host}}\n/\n{{jsfile_name}}\n.js\"\n>\n\n\n    \n{% \nendfor\n %}\n\n\n\n\n\n\n<\nbody\n>\n\n\n  \n{{myechart|\nsafe\n}}\n\n\n\n\n\n\n\n\n主要的不解之处：\n1、render_embed()与render()的区别是什么？分别用在什么地方？\n2、 host=DEFAULT_HOST什么用处？\n3、script_list=l3d.get_js_dependencies()赋值的意义是什么？为什么在html里面要循环？\n4、能否推荐一些原理性的文章？", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/technologist_37/article/details/118500579一样的功能已经写好了，把main中注释掉的冒泡排序恢复出来，下面那个排序注释掉", "Konwledge_Point": "线性规划简介", "Question": "修正代码，实现需求，给我正确代码，晚上九点之前给回复\n任务及要求：\n（1）首先完成线性链表的定义和创建，确保链表的第一个节点为哨兵节点，不存放有效的数据；\n（2）利用文件的相关操作，动态开辟节点存储空间，将存放在磁盘某个路径中的文件“stuinfo.txt”信息逐条读入，并依次存入到线性链表的每个节点中，信息如下；\n00001 张三 100\n00002 李四 99\n00003 王五 100\n00004 王六 89\n00005 江涛 98\n00006 陈琪 88\n00007 祁廷 91\n（3）接下来，将学号为‘00004’的节点删除；\n（4）再接下来，利用冒泡排序，对链表继续升序排序；\n（5）将完整的线性链表信息从头到尾依次存储到磁盘某个路径下的“score.txt”文件中，存储格式和“stuinfo.txt”文件相同。\n问题:\n我写的代码运行时找不到节点信息，删除不了，后面的代码也没法运行，保存到文件全是乱码。\n代码:\n#include \n#include\n#include\n#define LEN sizeof(stuInfo)\ntypedef struct stuInfo\n{\nchar id[12];            //数据成员    char name[15];    float score;    struct stuInfo *next;}stuInfo, *stu;\nstu headStu;\nvoid save(stu headStu);\nstuInfo *create(stuInfo *headStu);void Lsort(stu headStu);stuInfo *create(stuInfo *headStu){    int N=7;    headStu=(stuInfo *)malloc(LEN);    stuInfo *p,*q;    p=headStu;    for(int i=0;inext=q;        p->next;        q->next=NULL;        p=q;    }    printf(\"创建结束！\\n\");    return headStu;}void ListStu(stu headStu){    int num;    stuInfo *p;    p=headStu->next;    while(p!=NULL)    {        printf(\"%d:%s %s %f\\n\",++num,p->id,p->name,p->score);        p=p->next;    }    printf(\"打印完毕\\n\");}stu Bubble_Sort(stu headStu){    stu p1,p2;    p1=headStu->next;    p2=headStu;    while(p1!=NULL)    {        while(p1->next!=NULL)        {            if(p1->scorescore)            {                float temp=p1->score;                p1->score=p1->next->score;                p1->next->score=temp;            }            p1=p1->next;        }        p1=p2->next;        p2=p1;    }}stu Delete_stuInfo(stu headStu,char delId[12]){    stu lp,p;    lp=headStu;    p=lp->next;    if(headStu==NULL)    {        printf(\"链表为空\\n\");        return;    }    while(strcmp(p->id,delId)!=0&&(p->next!=NULL))    {        lp=p;        p=p->next;    }    if((strcmp(p->id,delId)==0))    {        lp->next=p->next;        free(p);    }    else        printf(\"没有找到该学生的信息！\\n\");    return headStu;}void Lsort(stu headStu){    stu head;    int x=0;    float t;    stu end,p,next;    if(head==NULL)        return;    for(p=headStu;p->next!=NULL;p=p->next)    end=p;    while(end!=headStu)    {        for(p=headStu;p!=end;p=p->next)        {            if(p->next->score>p->next->score)            {                t=p->score;p->score=p->next->score;p->next->score=t;            }            next=p;        }        end=next;    }}void save(stu headStu){    int N=7;    FILE *fp;    stu p=headStu->next;    if((fp=fopen(\"score.txt\",\"w+\"))==NULL)    {        printf(\"文件打开失败！\\n\");        exit(-1);    }    else    {        printf(\"打开save成功\\n\");    }    for(int i=0;iid,p->name,p->score);        p=p->next;    }    printf(\"文件保存成功！\\n\");    fclose(fp);}void load(){    char id[12],name[15];    float score;    int N=7;    FILE *fp;    fp=fopen(\"stuinfo.txt\",\"rb+\");    if(fp==NULL)    {        printf(\"文件打开失败！\");        exit(-1);    }    else    {        printf(\"读取成功:\\n\");    }    stuInfo *h,*p,*q;    h=(stuInfo *)malloc(LEN);    p=h;    printf(\" 学号 姓名 分数\\n\");    while(N>0)    {        q=(stuInfo *)malloc(LEN);        fscanf(fp,\"%s %s %f\",&q->id,&q->name,&q->score);        printf(\"%s %s %f\\n\",q->id,q->name,q->score);        p->next=q;        if(q->next=NULL)        p=q;        N--;    }    printf(\"读取结束!\\n\");    fclose(fp);}int main(){    stu head;    char id[12];    head=create(head);    load();    printf(\"请输入要删除学生的学号：\\n\");    scanf(\"%s\",id);    head=Delete_stuInfo(head,id);    Lsort(head);    save(head);    ListStu(head);    return 0;}", "Tag": "算法分析"}
{"Answer": "你实际malloc的空间是给p的，pre只是指向这块空间。退出循环后，你只是让pre指向了NULL，与链表中的节点完全没关系啊。\r\n所以后面你while(po)的时候，很大概率不会因为NULL结束，printf的时候就会段错误了。如果没有那也是意外，因为刚好那块内存是NULL。\r\n你的逻辑有问题，应该是每次malloc完，判断下返回值，然后就填充该节点，然后加入链表中。\r\n现在你在一个循环中，是先给之前的节点赋值，再分配新的节点空间，就会导致最后一个分配的节点里面的数据是不确定的(因为你malloc后没有清零操作)仅供参考\r\n/*随意输入n个数字，作为线性链表，遍历该列表返回输入值最小节点的关键字*/\r\n\r\n#include \r\n\r\n\r\nstruct example \r\n{\r\nint input;\r\nint keyword;\r\nstruct example* next;\r\n};\r\n\r\ntypedef struct example EXAMPLE;\r\n\r\nint main (void)\r\n{\r\nEXAMPLE* head;\r\nEXAMPLE* p;\r\nEXAMPLE* pre;\r\nEXAMPLE* po;\r\nEXAMPLE* pMin;\r\nint n;\r\nint i = 1;\r\n\r\nprintf(\"n = ? \");\r\nscanf(\"%d\",&n);\r\n\r\nhead = (EXAMPLE*)malloc(sizeof(EXAMPLE));\r\nif(NULL == head)\r\n{\r\n\tprintf(\"no memory\\n\");\r\n\treturn 0;\r\n}\r\n\r\nprintf(\"input = ? \");\r\nscanf(\"%d\",&head->input);\r\nhead->keyword = i;\r\nhead->next = NULL;\r\ni++;\r\n\r\npre = head;\r\nfor(; i <= n; i++)\r\n{\r\n\tp = (EXAMPLE*)malloc(sizeof(EXAMPLE));\r\n    printf(\"input = ? \");\r\n    scanf(\"%d\",&p->input);\r\n    p->keyword = i;\t\r\n\tp->next = NULL;\r\n\r\n    pre->next = p;\t\r\n\tpre = p;   \r\n}\r\n\r\npo = head;\r\nwhile(po)\r\n{\r\n    printf(\"%d   %d\\n\",po->keyword, po->input);\r\n    po = po->next;\r\n}\r\n\r\np = head->next;\r\npMin = head;   //好像就是这里出了问题，但不知为什么\r\nwhile(p)\r\n{\r\nif(pMin->input > p->input)\r\npMin = p;\r\np = p->next;\r\n}\r\n\r\nprintf(\"min : %d   %d\\n\",pMin->keyword, pMin->input);\r\n\r\n\r\n\r\nreturn 0;\r\n}\r\n\r\n\r\n\r\n```\r\n \r\n```", "Konwledge_Point": "线性规划简介", "Question": "链表的一个错误，找了很久也没发现为什么错了。。。\n/*随意输入n个数字，作为线性链表，遍历该列表返回输入值最小节点的关键字*/\n\n\n\n#include \n\n#include \n\n#include \n\n#include \n\n\n\nstruct example \n\n{\n\n    int     input;\n\n    int     keyword;\n\n    struct example* next;\n\n};\n\n\n\ntypedef struct example EXAMPLE;\n\n\n\nint main (void)\n\n{\n\n    EXAMPLE* head;\n\n    EXAMPLE* p;\n\n    EXAMPLE* pre;\n\n    EXAMPLE* po;\n\n    EXAMPLE* pMin;\n\n    int  n;\n\n    int  i;\n\n\n\nprintf(\"n = ? \");\nscanf(\"%d\",&n);\n\nhead = (EXAMPLE*)malloc(sizeof(EXAMPLE));\npre = head;\n\nfor(i = 1; i <= n; i++)\n{\n    printf(\"input = ? \");\n    scanf(\"%d\",&pre->input);\n    pre->keyword = i;\n\n    p = (EXAMPLE*)malloc(sizeof(EXAMPLE));\n    pre->next = p;\n    pre = p;\n}\n\npre = NULL;\n\npo = head;\nwhile(po)\n{\n    printf(\"%d   %d\\n\",po->keyword, po->input);\n    po = po->next;\n}\n\np = head->next;\npMin = head;   //好像就是这里出了问题，但不知为什么\n\n\n\n\n/*  while(p)\n\n    {\n\n        if(pMin->input > p->input)\n\n            pMin = p;\n\n        p = p->next;\n\n    }*/\n\n\n\nprintf(\"min : %d   %d\\n\",pMin->keyword, pMin->input);\n\n\n\nreturn 0;\n\n\n\n\n}", "Tag": "算法分析"}
{"Answer": "因为你的属性都只创建了类似指针的对象,但是没有分配对应地址在input接受输入后对应分配空间即可\n     Scanner sc = new Scanner(System.in);\n        System.out.println(\"请输入录入学生数量:\");\n        n = sc.nextInt();\n        name = new String[n];\n        sex = new char[n];\n        math = new float[n];\n        daishu = new float[n];\n        C = new float[n];\n        object = new float[n];\n", "Konwledge_Point": "线性规划简介", "Question": "Exception in thread \"main\" java.lang.NullPointerException: 哪里出了问题(๑•́ ₃ •̀๑)\nimport java.util.Scanner;\n//定义主类\npublic class TestStudent {\n    public static void main (String[] args) {\n\n\nStudent Stu \n=\n new Student()\n;\n\nStu.Input()\n;\n\n\n\n}\n\n\n\n}\n\n\n//定义类\nclass Student {\n    String[] name;\n    char[] sex;\n    float[] math;\n    float[] daishu;\n    float[] C;\n    float[] object;\n    int n;\n    public void Input () {\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请输入录入学生数量:\");\n        n = sc.nextInt();\n        for(int i = 1;i<=n;i++) {\n        System.out.println(\"请输入第\"+i+\"组数据\");\n\n\n    \nSystem\n.\nout\n.println(\"请输入第\"+i+\"组姓名\");\n    \nname\n[i] = sc.nextLine();\n    \nSystem\n.\nout\n.println(\"请输入第\"+i+\"组性别\");\n    sex[i] = sc.next().charAt(\n0\n);\n    \nSystem\n.\nout\n.println(\"请输入第\"+i+\"组高数成绩\");\n    math[i] = sc.nextFloat();\n    \nSystem\n.\nout\n.println(\"请输入第\"+i+\"组线性代数成绩\");\n    daishu[i] = sc.nextFloat();\n    \nSystem\n.\nout\n.println(\"请输入第\"+i+\"组C语言成绩\");\n    C[i] = sc.nextFloat();\n    \nSystem\n.\nout\n.println(\"请输入第\"+i+\"组面向对象成绩\");\n    \nobject\n[i] = sc.nextFloat();\n    }\n}\n\n\n\n}", "Tag": "算法分析"}
{"Answer": "我只专注于回答怎么解决你的这个很紧急的问题，所以答案也你想要的。\r\n捕获在另外一个activity中的一个activity的动作需要三个步骤。\r\n加载第二个activity（你的‘camera activity’）作为一个子activity，用startActivityForResult而不是startActivity。\r\n\r\n    Intent i = new Intent(this,CameraActivity.class);    \r\n    startActivityForResult(i, STATIC_INTEGER_VALUE);\r\n\r\n\r\n在这个子activity（camera activity）中，当你返回到父app时用额外的bundle，你需要创建一个新的包含索引tab的intent来显示，而不仅仅是当一个用户点击不同的tab图片的时候关闭activity。在关闭camera activity结束之前传递它到父调用setResult。\r\n\r\n    resultIntent = new Intent(null);\r\n    resultIntent.putExtra(PUBLIC_STATIC_STRING_IDENTIFIER, tabIndexValue);\r\n    setResult(Activity.RESULT_OK, resultIntent);\r\n    finish();\r\n\r\n最后一步是在调用activity的时候，重写onActivityResult来监听camera activity的回调。从返回的Intent获得额外的来决定你想要显示的索引tab\r\n\r\n    @Override \r\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {     \r\n      super.onActivityResult(requestCode, resultCode, data); \r\n      switch(requestCode) { \r\n        case (STATIC_INTEGER_VALUE) : { \r\n          if (resultCode == Activity.RESULT_OK) { \r\n          int tabIndex = data.getIntExtra(PUBLIC_STATIC_STRING_IDENTIFIER);\r\n          // TODO Switch tabs using the index.\r\n          } \r\n          break; \r\n        } \r\n      } \r\n    }", "Konwledge_Point": "线性规划简介", "Question": "Android：捕获一个activity的返回\n关于启动一个新的activity我遇到了一个问题。主要的问题就是，在一个视图上我有三个tab\n\nA) 包含gMap activity\n\n B) camera activity\n\n C)一些随机的文本字段\n\n要求就是这个应用程序要在肖像模式下运行。\n\n除了Camera Preview Surface (B)，所有的三个tab都正常。它旋转了90度。唯一的方法是把应用程序设置成横屏显示模式，移除所有的标签。但是这样是非常不切实际的。\n\n我的解决方案就是：代替\n\n我的camera activity和一个空的常规activity，除了\n\n\n\nIntent i = new Intent(this,CameraActivity.class);\n    startActivity(i);\n\n\n\n\n这将启动我的CameraActivity。而且很正常。我必须做一个包含3个图片的线性布局使它看起来像真正的tab，所以我可以试着模拟操作系统的tab，旋转屏幕成横屏然后保持视觉效果作为图像。用户可以点击其中的一个图像（按钮）来显示下一个tab。这是我的想法。它应该在一个tab中退出我的‘camera activity’，返回到‘blank activity’，它应该解释为从我的image中单击desiered tab。\n\n\n\n最主要的就是，当它返回时，它在一个tab下返回一个空白（黑色）页面（因为它是空的）。我怎么能够捕获调用activity的返回这个页面的返回事件，然后看看做了什么动作？\n\n当点击退出camera activity时，我可以设置一个点击的监听事件以便可以对假tab（图像）被点击做出会用。一旦退出，tab应该更新以便你来返回。有什么建议么？\n\n谢谢。", "Tag": "算法分析"}
{"Answer": "#include\"linked_List.h\"这一句删了，或者把这一句上面的代码都保存到linked_List.h文件中\n\n看你的文件结构，#include\"linked_List.h\"应该是cpp文件的第一行。\n\n", "Konwledge_Point": "线性规划简介", "Question": "关于频繁出现linked_List.h:No such file or directory的问题却不知道问题出现在哪这件事\n做软基实验的时候出现的问题，题目大概是：建立一个空线性链表，依次进行扫描、插入、扫描、删除、扫描的操作。\n\n\n代码如下\n\n\n//linked_List.h\n\n    \n#\ninclude\n \n\n\n    \nusing\n \nnamespace\n std;\n    \n//定义结点类型\n\n    \ntemplate\n <\nclass\n \nT\n>  \n//T为虚拟类型\n\n    \nstruct\n \nnode\n\n    { T d;\n      node *next;\n    };\n    \n//定义线性链表类\n\n    \ntemplate\n <\nclass\n \nT\n>  \n//模板声明,数据元素虚拟类型为T\n\n    \nclass\n  \nlinked_List\n\n    { \nprivate\n:  \n//数据成员\n\n        node *head;     \n//链表头指针\n\n      \npublic\n:   \n//成员函数\n\n        \nlinked_List\n();    \n//构造函数,建立空链表\n\n        \nvoid\n \nprt_linked_List\n()\n;  \n//扫描输出链表中的元素\n\n        \nvoid\n \nins_linked_List\n(T, T)\n;  \n//在包含元素x的结点前插入新元素b\n\n        \nint\n \ndel_linked_List\n(T)\n;     \n//删除包含元素x的结点\n\n    };\n    \n//建立空链表\n\n    \ntemplate\n <\nclass\n \nT\n>\n    linked_List::\nlinked_List\n()  \n    { head=\nNULL\n;  \nreturn\n; }\n    \n//扫描输出链表中的元素\n\n    \ntemplate\n <\nclass\n \nT\n>\n    \nvoid\n linked_List::\nprt_linked_List\n()\n    { node *p;\n      p=head;\n      \nif\n (p==\nNULL\n) { cout <<\n\"空链表！\"\n <d <next;\n         } \nwhile\n (p!=\nNULL\n);\n      \nreturn\n;\n    }\n    \n//在包含元素x的结点前插入新元素b\n\n    \ntemplate\n <\nclass\n \nT\n>\n    \nvoid\n linked_List::\nins_linked_List\n(T x, T b)\n    { node *p, *q;\n      p=\nnew\n node;  \n//申请一个新结点\n\n      p->d=b;      \n//置新结点的数据域\n\n      \nif\n (head==\nNULL\n)  \n//原链表为空\n\n      { head=p; p->next=\nNULL\n; \nreturn\n;}\n      \nif\n (head->d==x)  \n//在第一个结点前插入\n\n      { p->next=head;  head=p;  \nreturn\n; }\n      q=head;\n      \nwhile\n ((q->next!=\nNULL\n)&&(((q->next)->d)!=x))\n          q=q->next;  \n//寻找包含元素x的前一个结点q\n\n      p->next=q->next;  q->next=p;  \n//新结点p插入到结点q之后\n\n      \nreturn\n;\n    }\n    \n//删除包含元素x的结点元素\n\n    \ntemplate\n <\nclass\n \nT\n>\n    \nint\n linked_List::\ndel_linked_List\n(T x) \n    { node *p, *q;\n      \nif\n (head==\nNULL\n) \nreturn\n(\n0\n); \n//链表为空，无删除的元素\n\n      \nif\n ((head->d)==x)  \n//删除第一个结点\n\n      { p=head->next; \ndelete\n head; head=p; \nreturn\n(\n1\n); }\n      q=head;\n      \nwhile\n ((q->next!=\nNULL\n)&&(((q->next)->d)!=x))\n          q=q->next;  \n//寻找包含元素x的前一个结点q\n\n      \nif\n (q->next==\nNULL\n) \nreturn\n(\n0\n); \n//链表中无删除的元素\n\n      p=q->next; q->next=p->next;  \n//删除q的下一个结点p\n\n      \ndelete\n p;  \n//释放结点p的存储空间\n\n      \nreturn\n(\n1\n);\n    }\n\n#\ninclude\n\"linked_List.h\"\n\n\nint\n \nmain\n()\n\n\n{linked_List<\nint\n> s;\ncout<<\n\"第一次扫描输出链表s中的元素：\"\n<<endl;\ns.\nprt_linked_List\n();\ns.\nins_linked_List\n(\n10\n,\n10\n);\ns.\nins_linked_List\n(\n10\n,\n20\n);\ns.\nins_linked_List\n(\n10\n,\n30\n);\ns.\nins_linked_List\n(\n40\n,\n40\n);\ncout<<\n\"第二次扫描输出链表s中的元素：\"\n<<endl;\ns.\nprt_linked_List\n();\n\nif\n(s.\ndel_linked_List\n(\n30\n))\ncout<<\n\"删除元素：30\"\n<<endl;\n\nelse\n\ncout<<\n\"链表中无元素：30\"\n<<endl;\n\nif\n(s.\ndel_linked_List\n(\n50\n))\ncout<<\n\"删除元素：50\"\n<<endl;\n\nelse\n\ncout<<\n\"链表中无元素：50\"\n<<endl;\ncout<<\n\"第三次扫描输出链表s中的元素：\"\n<<endl;\ns.\nprt_linked_List\n();\n\nreturn\n \n0\n;\n}\n\n\n\n\n运行结果\n\n\n\n\n很多程序都出现了这个 No such file or directory，不是很懂，求大佬讲的通俗一点应该怎么解决", "Tag": "算法分析"}
{"Answer": "引用django用户表示user而不是AbstractUser参考delmo\nfrom django.contrib.auth.models import User\nclass Userinfo(User):\n    supernumber = models.IntegerField(verbose_name = '权限',choices = ((0,'无权限'),(1,'销售权限'),(2,\"管理权限\")),\n                                      default = 0,\n                                      help_text = \"非必填:用户登录到前台后的权限\")\n    isenable = models.BooleanField(verbose_name = '是否启用',default = False,help_text = \"非必选:用户能否登录前台界面\")\n    \n    def __init__(self,*args,**kwargs):\n        super(Userinfo,self).__init__(*args,**kwargs)\n        self._meta.get_field('is_staff').verbose_name = '能否登录后台'\n        self._meta.get_field('groups').verbose_name = '用户组'\n        self._meta.get_field('user_permissions').verbose_name = '用户数据库权限'\n        self._meta.get_field(\"last_name\").help_text = \"非必填:姓氏\"\n        self._meta.get_field(\"first_name\").help_text = \"非必填:名字\"\n        self._meta.get_field(\"email\").help_text = \"非必填:邮箱\"\n        self._meta.get_field(\"date_joined\").help_text = \"非必填:加入时间\"\n    \n    class Meta:\n        db_table = 'userinfo'\n        verbose_name = '用户信息表'\n        verbose_name_plural = verbose_name\n    \n    def __str__(self):\n        return f\"用户名:{self.username},权限:{self.supernumber}\"\n\n创建用户\nfrom django.contrib.auth.hashers import make_password, check_password\n\n\n#从django请求中获取的参数,我这里使用装饰器将所有参数放在可kwargs中\nname = kwargs.get('name')\npwd = kwargs.get('pwd')\nmakpwd = make_password(password=pwd)\n#添加用户\nUserinfo.objects.create(username=name, password=makpwd)\n\n这样即可在admin中添加用户的同时自己添加用户\n\n\n有帮助请点一下右上角的采纳,谢谢", "Konwledge_Point": "线性规划简介", "Question": "Python Django\n这是model模块\n\n\n\n\nfrom\n django.db \nimport\n models\n\nfrom\n django.contrib.auth.models \nimport\n AbstractUser\n\n\n\n\nclass\n \nTeacher\n(\nAbstractUser\n):\n    phone = models.CharField(max_length=\n11\n,verbose_name=\n'手机号'\n)\n\n    \nclass\n \nMeta\n:\n        db_table=\n'teacher'\n\n        verbose_name=\n'教师'\n\n        verbose_name_plural=verbose_name\n    \ndef\n \n__str__\n(\nself\n):\n        \nreturn\n self.username;\n\n\n\n\n这是view模块\n\n\n\n\n#注册模块\n\n\ndef\n \nregister\n(request)\n:\n    \nif\n request.method ==\n\"POST\"\n:\n        forms_Reg = forms.registerForm(request.POST)\n        \n#帮我做校验\n\n        \nif\n forms_Reg.is_valid():\n            \n#校验通过，去数据库创建一个新用户\n\n            forms_Reg.cleaned_data.pop(\n\"re_password\"\n)\n            models.Teacher.objects.create_user(**forms_Reg.cleaned_data)\n            \n#创建成功之后就跳转到登录页面\n\n            \nreturn\n redirect(\n\"/login/\"\n)\n        \nelse:\n\n\n            \nreturn\n render(request,\n\"register.html\"\n,{\n\"form_Reg\"\n:forms_Reg\n})\n    form_Reg = forms.registerForm()\n    \nreturn\n render(request,\n\"register.html\"\n,{\n\"form_Reg\"\n:form_Reg\n})\n\n\n\n\n这是admin模块\n\n\n\n\nfrom\n django.contrib \nimport\n \nadmin\n\n\nfrom\n .models \nimport\n Teacher\n# Register your models here.\n\nadmin\n.site.site_header=\n'线性代数试卷生成系统后台'\n\n\nadmin\n.site.site_title=\"教师管理\"\n\n@\nadmin\n.register(Teacher)\n\nclass\n TeacherAdmin(\nadmin\n.ModelAdmin):\n    list_display = (\n'username'\n,\n'password'\n)   #要显示的字段\n\n\n\n\n\n\n我基于django的用户模块创建一个用户模块，然后资金弄html然后通过view中的注册函数注册的用户密码是加密，\n但是不知道为什么在Admin中添加的用户，用户密码就不是加密的还出现了以下报错，\n\n", "Tag": "算法分析"}
{"Answer": "n = int(input())\na = list(map(int,input().split()))\nexchs = []\npos = n // 2 - 1\n\nwhile pos >= 0:\n    i = pos\n    while 2 * i + 1 < n:\n        left = 2 * i + 1\n        right = left + 1\n        if a[i] < a[left] and (right >= n or a[i] < a[right]):\n            break\n        t = left\n        if right < n and a[right] < a[left]:\n            t = right\n        if a[i] > a[t]:\n            a[i],a[t] = a[t],a[i]\n            exchs.append([i, t])\n            i = t\n    pos -= 1\n\nprint (len(exchs))\nfor exch in exchs:\n    print (exch[0], exch[1])\n", "Konwledge_Point": "线性规划简介", "Question": "怎么用python实现这个问题\n问题 4.3。构建堆\n            时限：1秒\n            内存限制：256 MB\n       构建堆是堆排序算法的关键步骤。该算法在最坏情况下的运行时间为 O(n log n)，与快速排序算法不同，后者仅在平均情况下保证这样的估计。几种排序算法在实践中比较常用的是组合。将数组转化为堆，需要对其元素进行多次交换。我们将交换称为交换元素 A[i] 和 A[j] 的基本操作。你在这个任务中的目标是将一个给定的数组转换成一个线性数量的交换的堆。输入第一行包含数字 n。下一行指定了一个数字数组 A[0], …… , A[n − 1] (1< n< 10^5; 0< A[i]< 10^9 for all 0< i< n - 1 ;所有A[i]都是成对不同的；i≠qj).输出输出的第一行必须包含交换次数m，必须满足不等式0 < m < 4 n。以下 m 行中的每一行都应指定数组 A 的两个元素的交换。每个交换由一对不同的索引 0< i≠qj< n - 1 定义，其中一个等式 j = 2i + 1, j = 2i + 2, i = 2j + 1 or i = 2j + 2 都满足了。按照指定的顺序应用所有的交换后，数组应该变成一个最小堆，即所有的都必须满足以下两个条件0< i< n - 1：\n如果 2i + 1< n − 1，则 A[i] < A[2i + 1]。\n如果 2i + 2< n − 1，则 A[i] < A[2i + 2]。\n例如：\n1.输入\n6\n0 1 2 3 4 5\n输出\n0\n2.输入\n6\n7 6 5 4 3 2\n输出\n4\n2 5\n1 4\n0 2\n2 5", "Tag": "算法分析"}
{"Answer": "把transforms.Normalize((0.1307),(0.3081))改为transforms.Normalize((0.1307,),(0.3081,))", "Konwledge_Point": "线性规划简介", "Question": "请求大神帮帮我，加载MNIST数据集后，显示IndexError: too many indices for tensor of dimension 0\n我想用线性的模型训练一下MNIST数据集，在运行到\n\ndef train(epoch):\n\n    running_loss = 0.0\n\n    for batch_idx,data in enumerate(train_loader):\n\n语句后显示\n\nIndexError: too many indices for tensor of dimension 0\n\n这是为什么呢？？甚至都还没到将数据放到模型中训练，应该和模型没关系，我也看了其他人的代码，在加载数据这些代码中也没找到什么问题。所以在这请教一下大神，万分感谢Orz\n\n\n\n以下是我的代码：\n\n\n\nimport  torch\nfrom torch.utils.data import DataLoader\nfrom torchvision import transforms \nfrom torchvision import datasets\nimport  torch.nn.functional as F\nimport torch.optim as optim\n\nbatch_size = 64\ntransform = transforms.Compose([transforms.ToTensor(),transforms.Normalize((0.1307),(0.3081))])\n\ntrain_dataset = datasets.MNIST(root='./data',\n                               train=True,\n                               download=True,\n                               transform=transform)\ntrain_loader = DataLoader(dataset=train_dataset,\n                          shuffle=True,\n                          batch_size=batch_size)\ntest_dataset = datasets.MNIST(root='./data',\n                              train=False,\n                              download=True,\n                              transform=transform)\ntest_loader = DataLoader(dataset=test_dataset,\n                         shuffle=False,\n                         batch_size=batch_size)\n\nclass Net(torch.nn.Module):\n    def __init__(self):#构造函数\n        super(Net,self).__init__()\n        self.linear1 = torch.nn.Linear(784,512)\n        self.linear2 = torch.nn.Linear(512,256)\n        self.linear3 = torch.nn.Linear(256,128)\n        self.linear4 = torch.nn.Linear(128,64)\n        self.linear5 = torch.nn.Linear(64,10)\n\n    def forward(self, x):\n        x=x.view(-1,784)\n        x = F.relu(self.linear1(x))\n        x = F.relu(self.linear2(x))\n        x = F.relu(self.linear3(x))\n        x = F.relu(self.linear4(x))\n        return self.linear5(x)\n\nmodel = Net()#实例化模型\n\ncriterion = torch.nn.CrossEntropyLoss()\noptimizer = optim.SGD(model.parameters(),lr=0.1,momentum=0.5)#lr为学习率\n\ndef train(epoch):\n    running_loss = 0.0\n    for batch_idx,data in enumerate(train_loader):\n        inputs, target = data\n        optimizer.zero_grad()\n\n        outputs = model(inputs)\n        loss = criterion(outputs, target)\n        loss.backward()\n        optimizer.step()\n        running_loss +=loss.item()\n        if batch_idx%300 == 299:\n            print('[%d,%5d] loss: %.3f' %(epoch+1,batch_idx+1,running_loss/300))\n            running_loss = 0.0\n\nif __name__=='__main__':\n    for epoch in range(10):\n        train(epoch)\n\n", "Tag": "算法分析"}
{"Answer": "python堆排序算法参考\nPython 堆排序 | 菜鸟教程\nPython 堆排序   Python3 实例   堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。     实例    [mycode3 type='python'] def heapify(arr, n, i):      largest ..\n\n\n\nhttps://www.runoob.com/python3/python-heap-sort.html\n\n", "Konwledge_Point": "线性规划简介", "Question": "用Python构建堆\n问题遇到的现象和发生背景\n\n\n构建堆是堆排序算法的关键步骤。该算法在最坏情况下的运行时间为 O(n log n)，与快速排序算法不同，后者仅在平均情况下保证这样的估计。几种排序算法在实践中比较常用的是组合。将数组转化为堆，需要对其元素进行多次交换。我们将交换称为交换元素 A[i] 和 A[j] 的基本操作。你在这个任务中的目标是将一个给定的数组转换成一个线性数量的交换的堆。\n\n\n数据输入输出例子解释\n\n\n输入第一行包含数字 n。下一行指定了一个数字数组 A[0], …… , A[n − 1] (1< n< 10^5; 0< A[i]< 10^9 for all 0< i< n - 1 ;所有A[i]都是成对不同的；i≠qj).输出输出的第一行必须包含交换次数m，必须满足不等式0 < m < 4 n。以下 m 行中的每一行都应指定数组 A 的两个元素的交换。每个交换由一对不同的索引 0< i≠qj< n - 1 定义，其中一个等式 j = 2i + 1, j = 2i + 2, i = 2j + 1 or i = 2j + 2 都满足了。按照指定的顺序应用所有的交换后，数组应该变成一个最小堆，即所有的都必须满足以下两个条件0< i< n - 1：\n如果 2i + 1< n − 1，则 A[i] < A[2i + 1]。\n如果 2i + 2< n − 1，则 A[i] < A[2i + 2]。\n\n\n问题相关例子\n\n\n1.输入\n6\n0 1 2 3 4 5\n输出\n0\n2.输入\n6\n7 6 5 4 3 2\n输出\n4\n2 5\n1 4\n0 2\n2 5\n\n\n我想要达到的结果\n\n\n用Python构建堆，写一下注释", "Tag": "算法分析"}
{"Answer": "1、Points写成了points。2、还有变量不能以数字开头命名，你写成了1xxfloat 1xx = 0, 1yy = 0, 1xy = 0;3、Points[i].getX写错了，应该写成Points[i].getX()\n\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nclass Point {//Piont类的定义\npublic:\n    Point(float x = 0, float y = 0) : x(x), y(y) {}\n    float getX() const { return x; }\n    float getY() const { return y; }\nprivate:\n    float x, y;\n};\n\n//直线线性拟合，points为各点,nPiont为点数\nfloat lineFit(const Point Points[], int nPoint);\nfloat lineFit(const Point Points[], int nPoint) \n{\n    float avgX = 0, avgY = 0;\n    float xx = 0, yy = 0, xy = 0;\n    for (int i = 0; i < nPoint; i++)\n    {\n        avgX += Points[i].getX() / nPoint;\n        avgY += Points[i].getY() / nPoint;\n    }\n    for (int i = 0; i < nPoint; i++)\n    {\n        xx += (Points[i].getX() - avgX) * (Points[i].getX() - avgX);\n        yy += (Points[i].getY() - avgY) * (Points[i].getY() - avgY);\n        xy += (Points[i].getX() - avgX) * (Points[i].getY() - avgY);\n    }\n    cout << \"This line can be fitted by y=ax+b.\" << endl;\n    cout << \"a=\" << xy / xx << \" \";\n    cout << \"b=\" << avgY - xy * avgX / xx << endl;\n    return static_cast<float>(xy / sqrt(xx * yy));\n}\nint main()\n{\n    Point p[10] = { Point(6,10),Point(14,20), Point(26,30), Point(33,40), Point(46,50), Point(56,60), Point(67,70), Point(75,80), Point(84,90), Point(100,100), };\n    float r = lineFit(p, 10);\n    cout << \"Line coefficient r=\" << r << endl;\n    return 0;\n}\n", "Konwledge_Point": "线性规划简介", "Question": "应输入标识符，如下图报错,都是什么原因，应该怎么改？\n#\nifndef\n _POINT_H\n\n\n#\ndefine\n _POINT_H\n\n\nclass\n \nPoint\n {\n//Piont类的定义\n\n\npublic\n:\n    \nPoint\n(\nfloat\n x = \n0\n,\nfloat\n y = \n0\n) : \nx\n(x), \ny\n(y){}\n    \nfloat\n \ngetX\n()\n \nconst\n \n{ \nreturn\n x; }\n    \nfloat\n \ngetY\n()\n \nconst\n \n{ \nreturn\n y; }\n\nprivate\n:\n    \nfloat\n x, y;\n};\n\n#\nendif\n\n\n\n\n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\"Point.h\"\n\n\n#\ninclude\n \n\n\n\nusing\n \nnamespace\n std;\n    \n//直线线性拟合，points为各点,nPiont为点数\n\n\nfloat\n \nlineFit\n(\nconst\n Point Points[], \nint\n nPoint)\n;\n    \nfloat\n \nlineFit\n(\nconst\n Point Points[], \nint\n nPoint)\n \n{\n        \nfloat\n avgX = \n0\n, avgY = \n0\n;\n        \nfloat\n \n1\nxx = \n0\n, \n1\nyy = \n0\n, \n1\nxy = \n0\n;\n        \nfor\n (\nint\n i = \n0\n; i < nPoint; i++)\n        {\n            avgX += points[i].\ngetX\n() / nPoint;\n            avgY += points[i].\ngetY\n() / nPoint;\n        }\n        \nfor\n (\nint\n i = \n0\n; i < nPoint; i++)\n        {\n            \n1\nxx += (points[i].\ngetX\n() - avgX) * (points[i].getX - avgX);\n            \n1\nyy += (points[i].\ngetY\n() - avgY) * (points[i].getY - avgY);\n            \n1\nxy += (points[i].\ngetX\n() - avgX) * (points[i].getY - avgY);\n        }\n        cout << \n\"This line can be fitted by y=ax+b.\"\n << endl;\n        cout << \n\"a=\"\n << \n1\nxy / \n1\nxx << \n\" \"\n;\n        cout << \n\"b=\"\n << avgY - \n1\nxy * avgX / \n1\nxx << endl;\n        \nreturn\n \nstatic_cast\n<\nfloat\n>(\n1\nxy / \nsqrt\n(\n1\nxx * \n1\nyy));\n    }\n    \nint\n \nmain\n()\n\n    \n{\n        Point p[\n10\n] = { \nPoint\n(\n6\n,\n10\n),\nPoint\n(\n14\n,\n20\n), \nPoint\n(\n26\n,\n30\n), \nPoint\n(\n33\n,\n40\n), \nPoint\n(\n46\n,\n50\n), \nPoint\n(\n56\n,\n60\n), \nPoint\n(\n67\n,\n70\n), \nPoint\n(\n75\n,\n80\n), \nPoint\n(\n84\n,\n90\n), \nPoint\n(\n100\n,\n100\n), };\n        \nfloat\n r = \nlineFit\n(p, \n10\n);\n        cout << \n\"Line coefficient r=\"\n << r << endl;\n        \nreturn\n \n0\n;\n    }\n\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "你放循环体里万一超出范围还会赋值，最后只能报错。而放判断语句里它会先判断是否会超出范围，一旦超出它就退出，也就不会执行赋值", "Konwledge_Point": "线性规划简介", "Question": "关于力扣“计算质数”这一题的一些疑问\n是这样的，这题我试着用“线性筛”的方法进行求解，在解题的过程中发现了这样一个问题，令我很困惑，首先一个代码如下\n\n\n\n```java\n\nclass\n \nSolution\n {\n    \npublic\n \nint\n \ncountPrimes\n(\nint\n n)\n \n{\n        \n//存放质数的集合\n\n        \nint\n[] primes = \nnew\n \nint\n[n+\n1\n];\n\n        \nint\n num = \n0\n;\n\n        \n//标记是否为质数\n\n        \nboolean\n[] bp = \nnew\n \nboolean\n[n+\n1\n];\n\n        \nfor\n (\nint\n i = \n2\n; i < n; i++) {\n            \nif\n (!bp[i]){\n                primes[num++] = i;\n            }\n\n            \nfor\n(\nint\n j = \n0\n;j < num ;j++){\n                \nif\n( i * primes[j] < n){\n                    bp[i*primes[j]] = \ntrue\n;\n                }\n                \n                \n//  **关键点在这里**\n\n                \nif\n (i % primes[j] == \n0\n) {\n                    \nbreak\n;\n                }\n            }\n        }\n\n        \nreturn\n num;\n\n    }\n}\n\n\n\n\n\n\n\n\n可以看到，在这里int类型的运算超出表示范围了，所以报错了，但是，如果换一种写法，如下：\n\n\nclass\n \nSolution\n {\n    \npublic\n \nint\n \ncountPrimes\n(\nint\n n)\n \n{\n        \n//存放质数的集合\n\n        \nint\n[] primes = \nnew\n \nint\n[n+\n1\n];\n\n        \nint\n num = \n0\n;\n\n        \n//标记是否为质数\n\n        \nboolean\n[] bp = \nnew\n \nboolean\n[n+\n1\n];\n\n        \nfor\n (\nint\n i = \n2\n; i < n; i++) {\n            \nif\n (!bp[i]){\n                primes[num++] = i;\n            }\n\n            \nfor\n(\nint\n j = \n0\n;j < num && i * primes[j] < n;j++){\n                bp[i*primes[j]] = \ntrue\n;\n                \nif\n (i % primes[j] == \n0\n) {\n                    \nbreak\n;\n                }\n            }\n        }\n\n        \nreturn\n num;\n\n    }\n}\n\n\n\n\n也就是把判断放到for循环的判断语句里了，结果如下：\n\n\n\n\n所以说判断语句放在for循环的循环体里和放在for循环的判断语句里是有所不同的吗？\n到底有什么不同呢？希望有人能帮我答疑解惑", "Tag": "算法分析"}
{"Answer": " x数组没有排序，最小值索引7，最大值索引8，直线就是这两点的连线。建议将 yvals = dfin(x, a, b, c) 改为 yvals = dfin(x[np.argsort(x)], a, b, c)", "Konwledge_Point": "线性规划简介", "Question": "python拟合曲线为什么画的图中一条曲线一条直线\npython拟合曲线为什么画的图中一条曲线一条直线？给定了函数形式让程序拟合的。\n\n\nimport\n matplotlib.pyplot as plt\n\nimport\n numpy as np\n\nfrom\n scipy.optimize import curve_fit\n\n\n\n#去掉了最后一个水平\n\n\n\n\n# x就是等效应变\n\n\ndef\n dfin(x, a, b, c):\n    \nreturn\n (a*z**b-\n30\n.\n0\n)*(\n1\n.\n0\n-np.exp(-np.log(\n2\n.\n0\n*(x/ee)**c)))+\n30\n.\n0\n\n\n\n# D初始晶粒尺寸\n\n\nD\n = \n30\n.\n0\n\n\n# z不同温度需要重新输入\n\n\nz\n = \n1\n.\n92\n*\n10\n**\n20\n\n\nee\n = \n0\n.\n0016\n*D**\n0\n.\n2709\n*z**\n0\n.\n1147\n\n\n# 给出x、y对应坐标，即给出等效应变和对应的真实最终晶粒尺寸\n\n\nx\n =\n [0.74,0.69,0.56,0.41,0.3,0.21,0.15,0.12,\n    1.38,1.33,1.18,1.01,0.82,0.64,0.48,0.35]\n\n\nx\n = np.array(x)\n\nnum\n =\n [26,29,28,30,31,40,39,41,\n    21,22,23,24,23,27,28,30]\n\n\ny\n = np.array(num)\n\n\n# 非线性最小二乘法拟合\n\n\nparameter_bounds\n = ([\n15\n*\n10\n**\n5\n,-\n0\n.\n25\n,\n0\n],[np.inf,\n0\n,\n3\n])\n\npopt\n, pcov = curve_fit(dfin, x, y, bounds=parameter_bounds)\n\n# 获取popt里面拟合系数\n\n\nprint\n(popt)\n\na\n = popt[\n0\n]\n\nb\n = popt[\n1\n]\n\nc\n = popt[\n2\n]\n\nyvals\n = dfin(x, a, b, c)\n\nprint\n('系数a:', a)\n\nprint\n('系数b:', b)\n\nprint\n('系数c:', c)\n\nprint\n('系数yvals:', yvals)\n\n\n# 绘图\n\n\nplot1\n = plt.plot(x, y, 's')\n\nplot2\n = plt.plot(x, yvals, 'r')\n\nplt\n.xlabel('ε')\n\nplt\n.ylabel('d')\n\nplt\n.title('\n1120\n,v=\n14\n,zhui')\n\nplt\n.show()\n\n\n\n\n\n图片如下：\n\n", "Tag": "算法分析"}
{"Answer": "现已经找到了此问题的最终原因，因为setImageResource在运行时，会自动匹配相应质量的图片，而且之后也没有及时的资源回收机制，所以导致在加载第三张图片的时候，内存溢出报错（我建立的AVD所分配的内存比较小）。重新建立一个AVD4.0.3，并且把内存改为512M，就不会报错了。如果非要针对内存比较小的Android，或者说是为了节约资源，就尽量不要用setImageBitmap或setImageResource或BitmapFactory.decodeResource来设置一张大图，因为这些函数在完成decode后，最终都是通过java层的createBitmap来完成的，需要消耗更多内存。因此，改用先通过BitmapFactory.decodeStream方法，创建出一个bitmap，再将其设为ImageView的 source，decodeStream最大的秘密在于其直接调用JNI>>nativeDecodeAsset()来完成decode，无需再使用java层的createBitmap，从而节省了java层的空间。", "Konwledge_Point": "线性规划简介", "Question": "Android 项目中不能显示两张以上图片\npublic class MainActivity extends Activity {\n\n\n\nprivate ImageView[] img=new ImageView[4];//声明一个保存ImageView组件的数组\n\nprivate int[] imagePath= new int[]{R.drawable.img01,R.drawable.img02,R.drawable.img03,R.drawable.img04};//声明并初始化一个保存访问图片的数组\n\n\n\n@Override\n\nprotected void onCreate(Bundle savedInstanceState) {\n\nsuper.onCreate(savedInstanceState);\n\nsetContentView(R.layout.activity_main);\n\nLinearLayout layout=(LinearLayout) findViewById(R.id.layout); //获取XML文件中定义的线性布局管理器\n\nfor (int i=0;i\n{\n\nimg[i]=new ImageView(this);//新创建一个ImageView组件\n\nimg[i].setImageResource(imagePath[i]);//设置要显示的图片\n\nimg[i].setPadding(5, 5, 5, 5);//设置ImageView显示的内边距\n\nLayoutParams params=new LayoutParams(80,40);//设置图片的宽和高\n\nimg[i].setLayoutParams(params);//为ImageView组件设置布局参数\n\nlayout.addView(img[i]);//将ImageView组件添加到布局管理器中\n\n}\n\n}\n\n}\n\n我建立的安卓4.2.2上的项目，但是上边的程序运行一直出错。如果把img长度设置为2，然后imagePath初始化为四个图片中的任何两个，就会成功了。请大神们指点是为什么？\n\n下边是我的布局文件内容\n\n\n    xmlns:tools=\"http://schemas.android.com/tools\"\n\n    android:orientation=\"horizontal\"\n\n    android:layout_width=\"fill_parent\"\n\n    android:layout_height=\"fill_parent\"\n\n    android:background=\"@drawable/background\"\n\n    android:id=\"@+id/layout\"\n\n    tools:context=\"${relativePackage}.${activityClass}\" \n\n    >", "Tag": "算法分析"}
{"Answer": "选择排序法的的降序排列没有实现是因为内层循环有个地方写错了\r\nfor(j=n+1;j\r\n#include \r\n#define N 20\r\nint Readscore(int  score[],long id[]);\r\nint Linsearch(long id[],long m,int n);\r\nvoid Linsort(int score[],long id[],int n);\r\nvoid Selectsort(int score[],long id[],int n);\r\nint Binsearch(long id[],long m,int n);\r\nvoid Printf(int score[],long id[],int n);\r\n \r\nint main()\r\n{\r\n    int score[N];//记录学生成绩\r\n    long id[N];//记录学生学号\r\n    int num;//接收 READscore的返还值，即学生人数\r\n    long x,x1;\r\n    int a,a1;//接收返回学号的值\r\n \r\n    //记录学生成绩\r\n    num=Readscore(score,id);\r\n \r\n    //输出成绩和学号\r\n    Printf(score,id,num);\r\n \r\n \r\n    // 顺序查找法\r\n    printf(\"输入你要查找的学生的学号：\");\r\n    scanf(\"%ld\",&x);\r\n    a=Linsearch(id,x,num);\r\n    printf(\"%d %ld\\n\",score[a],id[a]);\r\n \r\n    //线性排序法\r\n    Linsort(score,id,num);\r\n \r\n    //输出成绩和学号\r\n    Printf(score,id,num);\r\n \r\n    //选择排序法\r\n    Selectsort(score,id,num);\r\n \r\n    //输出成绩和学号\r\n    Printf(score,id,num);\r\n \r\n    //折半查找法\r\n    printf(\"输入你要查找的学生的学号：\");\r\n    scanf(\"%ld\",&x1);\r\n    a1=Binsearch(id,x1,num);\r\n    if(a1 != -1)\r\n    {\r\n        printf(\"%d %ld\\n\",score[a1],id[a1]);\r\n    }\r\n    else\r\n    {\r\n        printf(\"大兄弟，没这个人啊!\");\r\n    }\r\n \r\n \r\n    //输出成绩和学号\r\n    Printf(score,id,num);\r\n \r\n \r\n    return 0;\r\n}\r\n \r\n//录入学生成绩 和学号\r\nint Readscore(int score[],long id[])\r\n{\r\n    int i=-1;\r\n    do\r\n    {\r\n        i++;\r\n        printf(\"input score and id:\");\r\n        scanf(\"%d %ld\",&score[i],&id[i]);\r\n    }while((score[i] >= 0)&&(id[i] >=0));\r\n    return i;\r\n}\r\n//顺序查找\r\nint Linsearch(long id[],long m,int n)\r\n{\r\n    int i;\r\n \r\n    for(i=0;iscore[j])\r\n            {\r\n                //交换成绩\r\n                temp1=score[j];\r\n                score[j]=score[i];\r\n                score[i]=temp1;\r\n                //交换学号\r\n                temp2=id[j];\r\n                id[j]=id[i];\r\n                id[i]=temp2;\r\n            }\r\n        }\r\n    }\r\n}\r\n//选择排序法,降序排\r\nvoid Selectsort(int score[],long id[],int n)\r\n{\r\n    int i,j,k;\r\n    int temp1;\r\n    long temp2;\r\n \r\n    for(i=0;i score[k])\r\n            {\r\n                k=j;\r\n            }\r\n        }\r\n        if(k != i)\r\n        {\r\n            //交换成绩\r\n            temp1 = score[k];\r\n            score[k] = score[i];\r\n            score[i] = temp1;\r\n \r\n            //交换学号\r\n            temp2 = id[k];\r\n            id [k] =id[i];\r\n            id[i] = temp2;\r\n        }\r\n    }\r\n}\r\n \r\n//折半查找法\r\nint Binsearch(long id[],long m,int n)\r\n{\r\n    int high = n-1;\r\n    int low = 0;\r\n    int mid;\r\n \r\n    while(low <= high)\r\n    {\r\n        mid = (high+low)/2;\r\n        if(m < id[mid])\r\n        {\r\n            high = mid-1;\r\n        }\r\n        else if(m > id[mid])\r\n        {\r\n            low = mid+1;\r\n        }\r\n        else\r\n        {\r\n            return mid;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\n//输出函数\r\nvoid Printf(int score[],long id[],int n)\r\n{\r\n    int i;\r\n    printf(\"=============================\\n\");\r\n    for(i=0;i < n;i++)\r\n    {\r\n \r\n        printf(\"%d %ld\\n\",score[i],id[i]);\r\n \r\n    }\r\n}\r\n```\r\n![图片说明](https://img-ask.csdn.net/upload/201604/22/1461303479_907686.png)", "Konwledge_Point": "线性规划简介", "Question": "新人问一个c语言问题，麻烦各位帮忙看一下\n一个小型成绩管理系统：\n\n#include \n\n#include \n\n#define N 40\n\nint Readscore(int  score[],long id[]);\n\nint Linsearch(long id[],long m,int n);\n\nvoid Linsort(int score[],long id[],int n);\n\nvoid Selectsort(int score[],long id[],int n);\n\nint Binsearch(long id[],long m,int n);\n\nvoid Printf(int score[],long id[],int n);\n\n\n\nint main()\n\n{\n\n    int score[N];//记录学生成绩\n\n    long id[N];//记录学生学号\n\n    int num;//接收 READscore的返还值，即学生人数\n\n    long x,x1;\n\n    int a,a1;//接收返回学号的值\n\n\n\n//记录学生成绩\nnum=Readscore(score,id);\n\n//输出成绩和学号\nPrintf(score,id,num);\n\n\n// 顺序查找法\nprintf(\"输入你要查找的学生的学号：\");\nscanf(\"%ld\",&x);\na=Linsearch(id,x,num);\nprintf(\"%d %ld\\n\",score[a],id[a]);\n\n//线性排序法\nLinsort(score,id,num);\n\n//输出成绩和学号\nPrintf(score,id,num);\n\n//选择排序法\nSelectsort(score,id,num);\n\n//输出成绩和学号\nPrintf(score,id,num);\n\n//折半查找法\nprintf(\"输入你要查找的学生的学号：\");\nscanf(\"%ld\\n\",&x1);\na1=Binsearch(id,x1,num);\nif(a1 != -1)\n{\n    printf(\"%d %ld\\n\",score[a1],id[a1]);\n}\nelse\n{\n    printf(\"大兄弟，没这个人啊!\");\n}\n\n\n//输出成绩和学号\nPrintf(score,id,num);\n\n\nreturn 0;\n\n\n\n\n}\n\n\n\n//录入学生成绩 和学号\n\nint Readscore(int score[],long id[])\n\n{\n\n    int i=-1;\n\n    do\n\n    {\n\n        i++;\n\n        printf(\"input score and id:\");\n\n        scanf(\"%d %ld\",&score[i],&id[i]);\n\n    }while((score[i] >= 0)&&(id[i] >=0));\n\n    return i;\n\n}\n\n//顺序查找\n\nint Linsearch(long id[],long m,int n)\n\n{\n\n    int i;\n\n\n\nfor(i=0;iscore[j])\n        {\n            //交换成绩\n            temp1=score[j];\n            score[j]=score[i];\n            score[i]=temp1;\n            //交换学号\n            temp2=id[j];\n            id[j]=id[i];\n            id[i]=temp2;\n        }\n    }\n}\n\n\n\n\n}\n\n//选择排序法,降序排\n\nvoid Selectsort(int score[],long id[],int n)\n\n{\n\n    int i,j,k;\n\n    int temp1;\n\n    long temp2;\n\n\n\nfor(i=0;i score[k])\n        {\n            k=j;\n        }\n    }\n    if(k != i)\n    {\n        //交换成绩\n        temp1 = score[k];\n        score[k] = score[i];\n        score[i] = temp1;\n\n        //交换学号\n        temp2 = id[k];\n        id [k] =id[i];\n        id[i] = temp2;\n    }\n}\n\n\n\n\n}\n\n\n\n//折半查找法\n\nint Binsearch(long id[],long m,int n)\n\n    {\n\n        int high = n-1;\n\n        int low = 0;\n\n        int mid;\n\n\n\n    while(low <= high)\n    {\n        mid = (high+low)/2;\n        if(m < id[mid])\n        {\n            high = mid-1;\n        }\n        else if(m > id[mid])\n        {\n            low = mid+1;\n        }\n        else\n        {\n            return mid;\n        }\n    }\n    return -1;\n}\n\n\n\n\n//输出函数\n\nvoid Printf(int score[],long id[],int n)\n\n{\n\n    int i;\n\n    printf(\"=============================\\n\");\n\n    for(i=0;i < n;i++)\n\n    {\n\n\n\n    printf(\"%d %ld\\n\",score[i],id[i]);\n\n}\n\n\n\n\n}\n\n为什么选择排序法升序没有实现？\n\n还有，为什么折半查找法用不了？就是输进去学号之后程序不继续往下执行。\n\n我实在找不出错在哪了。", "Tag": "算法分析"}
{"Answer": "你 self.gradient_descent(alpha,num_iterations) 中 self是float浮点数类型,不可能有gradient_descent方法吧你调用train()方法的方式不对要用LinearRegression类的实例对象 linear_regression 调用train()方法不是用LinearRegression类本身调用train()方法,\n(theta, cost_history) = LinearRegression.train(learning_rate, num_iterations)##此处有问题\n\n改成\n(theta, cost_history) = linear_regression.train(learning_rate, num_iterations)##此处有问题\n", "Konwledge_Point": "线性规划简介", "Question": "python数据类型报错\n问题遇到的现象和发生背景\n\n\npython 写线性回归代码时遇到变量类型报错的问题\n\n\n问题相关代码，请勿粘贴截图\n\n\ndef\n \ntrain\n(\nself,alpha,num_iterations = \n500\n):\n       \n        cost_history = self.gradient_descent(alpha,num_iterations)\n##此处有问题\n\n        \nreturn\n self.theta,cost_history\n        \n    \ndef\n \ngradient_descent\n(\nself,alpha,num_iterations\n):\n        cost_history = []\n        \nfor\n x \nin\n \nrange\n(num_iterations):\n            self.gradient_step(alpha)\n            cost_history.append(self.cost_function(self.data,self.labels))\n        \nreturn\n cost_history\n        \n        \n    \ndef\n \ngradient_step\n(\nself,alpha\n):    \n        num_examples = data.shape[\n0\n]\n        prediction = LinearRegression.hypothesis(self.data,self.theta)\n        delta = prediction - self.labels\n        theta = self.theta\n        theta = theta - alpha*(\n1\n/num_examples)*(np.dot(delta.T,self.data)).T\n        self.theta = theta\n        \n        \n    \ndef\n \ncost_function\n(\nself,data,labels\n):\n        self.m = \nlen\n(labels)\n        delta = LinearRegression.hypothesis(data,self.theta) - labels\n        cost = (\n1\n/\n2\n)*np.dot(delta.T,delta)/self.m\n        \nreturn\n cost[\n0\n][\n0\n]\n        \n    \n    \ndef\n \nhypothesis\n(\ndata,theta\n):   \n        predictions = np.dot(data,theta)\n        \nreturn\n predictions\n        \n\nx_train =rescombine\ny_train = labels\n\nnum_iterations = \n500\n  \nlearning_rate = \n0.01\n  \n\n\nlinear_regression = LinearRegression(x_train, y_train)\n\n(theta, cost_history) = LinearRegression.train(learning_rate, num_iterations)\n##此处有问题\n\n\n\nprint\n(theta, cost_history)\n\nprint\n(\n'开始损失'\n,cost_history[\n0\n])\n\nprint\n(\n'结束损失'\n,cost_history[-\n1\n])\n\n\n\n运行结果及报错内容\n\n\n发生异常: AttributeError\n'float' object has no attribute 'gradient_descent'\n  File \"C:\\Users\\Xpc\\Desktop\\LinearRegression\\linear_regression.py\", line 299, in train\n    cost_history = self.gradient_descent(alpha,num_iterations)\n  File \"C:\\Users\\Xpc\\Desktop\\LinearRegression\\linear_regression.py\", line 340, in \n    (theta, cost_history) = LinearRegression.train(learning_rate, num_iterations)\n\n\n我的解答思路和尝试过的方法\n\n\n我不知道是不是我写的程序有问题，还是数据的类型不对", "Tag": "算法分析"}
{"Answer": "基于Monster 组和GPT的调写：任务1\n# 导入所需的库\nimport pandas as pd\nimport numpy as np\nimport statsmodels.api as sm\nfrom statsmodels.stats.outliers_influence import variance_inflation_factor\n\n# 读取数据文件\ndata = pd.read_csv('regres.txt', header=None, delim_whitespace=True,\n                   names=['air_speed', 'temp', 'acid_conc', 'loss_ammonia'])\nX = data[['air_speed', 'temp', 'acid_conc']]\ny = data['loss_ammonia']\n\n# 确定哪些自变量是高度相关的\nvif = pd.DataFrame()\nvif[\"VIF Factor\"] = [variance_inflation_factor(X.values, i) for i in range(X.shape[1])]\nvif[\"features\"] = X.columns\nprint(vif)\n\n# 确定哪些自变量与因变量高度相关\nX = sm.add_constant(X)\nmodel = sm.OLS(y, X).fit()\nprint(model.summary())\n\n# 建立一个多元线性回归方程，确定哪些自变量是显著的\nsignificant_features = ['air_speed', 'temp']\nX_significant = X[significant_features]\nmodel_significant = sm.OLS(y, X_significant).fit()\nprint(model_significant.summary())\n\n\n# 使用逐步回归法，选择有信息的变量\ndef backward_elimination(X, y, sig_level=0.05):\n    num_features = X.shape[1]\n    for i in range(num_features):\n        model = sm.OLS(y, X).fit()\n        p_values = model.pvalues\n        max_p_value = max(p_values)\n        if max_p_value > sig_level:\n            max_p_value_idx = p_values.idxmax()\n            X = X.drop(max_p_value_idx, axis=1)\n        else:\n            break\n    return X\n\n\nX_backward_elim = backward_elimination(X, y)\nmodel_backward_elim = sm.OLS(y, X_backward_elim).fit()\nprint(model_backward_elim.summary())\n\n# 分析残留物\nresiduals = model_backward_elim.resid\nprint(residuals.describe())\n\n# 构建因变量的预测，将第4天的数值作为自变量的数值\nX_predict = [1, 62, 24, 93]\ny_predict = model_backward_elim.predict(X_predict)\nprint(y_predict)\n\n任务2\n岭回归模型Ridge回归模型是线性回归模型的改进版，它添加了L2范数正则化项。岭回归通过对系数进行缩减，降低了过拟合的风险。我们可以使用scikit-learn库的Ridge类来建立岭回归模型。\n\n导入所需的库\nimport pandas as pd\nimport numpy as np\nfrom sklearn.linear_model import Ridge\nfrom sklearn.metrics import mean_squared_error\n\n读取数据文件\ndata = pd.read_csv('regres.txt', header=None, delim_whitespace=True, names=['air_speed', 'temp', 'acid_conc', 'loss_ammonia'])\nX = data[['air_speed', 'temp', 'acid_conc']]\ny = data['loss_ammonia']\n\n将第四天的数据用作自变量\nx_pred = X.iloc[3]\n\n建立岭回归模型\nridge = Ridge(alpha=1.0)\nridge.fit(X, y)\n\n使用模型进行预测\ny_pred = ridge.predict([x_pred])\n\n输出预测结果\nprint(\"预测值：\", y_pred[0])\n\n拉索回归模型\nLasso回归模型也是线性回归模型的改进版，它添加了L1范数正则化项。与岭回归相比，Lasso回归可以将某些系数缩减到0，因此可以用于特征选择。我们可以使用scikit-learn库的Lasso类来建立Lasso回归模型。\n\n导入所需的库\nimport pandas as pd\nimport numpy as np\nfrom sklearn.linear_model import Lasso\nfrom sklearn.metrics import mean_squared_error\n\n读取数据文件\ndata = pd.read_csv('regres.txt', header=None, delim_whitespace=True, names=['air_speed', 'temp', 'acid_conc', 'loss_ammonia'])\nX = data[['air_speed', 'temp', 'acid_conc']]\ny = data['loss_ammonia']\n\n将第四天的数据用作自变量\nx_pred = X.iloc[3]\n\n建立Lasso回归模型\nlasso = Lasso(alpha=1.0)\nlasso.fit(X, y)\n\n使用模型进行预测\ny_pred = lasso.predict([x_pred])\n\n输出预测结果\nprint(\"预测值：\", y_pred[0])\n\n", "Konwledge_Point": "线性规划简介", "Question": "氨氧化法硝酸生产过程数据的回归分析任务\n问题遇到的现象和发生背景\n\n\n回归分析任务\n任务 1\n数据（文件regres.txt）(数据见下面代码块)代表了21天内对氨氧化法硝酸生产过程的四个参数的测量。\n氨氧化法的硝酸生产过程的四个参数。\nX(1) - （air speed）空气速度。\nX(2)-（ temperature of the cooled liquid）是冷却后的液体温度。\nX(3)-（acid concentration）酸浓度。\nX(4) - （loss of ammonia）氨的损失。\n变量X(4)是因变量，变量X(1)、X(2)X(3)是独立变量。\n1 确定哪些自变量是高度相关的。\n2. 确定哪些自变量与因变量高度相关。\n3. 建立一个多元线性回归方程，确定哪些自变量是显著的。\n4. 使用逐步回归法，选择有信息的变量。\n5.分析残留物。\n6.构建因变量的预测，将第4天的数值作为自变量的数值。\n任务2 \n\n\n1.建立岭回归模型（Ridge Regression Model）\n2. 建立拉索回归模型（ Lasso Regression Model）\n3. 构建每个模型的因变量预测，将第四天的数值作为自变量。\n将第四天的数值作为自变量的数值。\n\n\n数据（文件regres.txt）\n\n\n  \n80\n.\n00000\n   \n27\n.\n00000\n   \n89\n.\n00000\n   \n42\n.\n00000\n \n  \n80\n.\n00000\n   \n27\n.\n00000\n   \n88\n.\n00000\n   \n37\n.\n00000\n \n  \n75\n.\n00000\n   \n25\n.\n00000\n   \n90\n.\n00000\n   \n37\n.\n00000\n \n  \n62\n.\n00000\n   \n24\n.\n00000\n   \n87\n.\n00000\n   \n28\n.\n00000\n \n  \n62\n.\n00000\n   \n22\n.\n00000\n   \n87\n.\n00000\n   \n18\n.\n00000\n \n  \n62\n.\n00000\n   \n23\n.\n00000\n   \n87\n.\n00000\n   \n18\n.\n00000\n \n  \n62\n.\n00000\n   \n24\n.\n00000\n   \n93\n.\n00000\n   \n19\n.\n00000\n \n  \n62\n.\n00000\n   \n24\n.\n00000\n   \n93\n.\n00000\n   \n20\n.\n00000\n \n  \n58\n.\n00000\n   \n23\n.\n00000\n   \n87\n.\n00000\n   \n15\n.\n00000\n \n  \n58\n.\n00000\n   \n18\n.\n00000\n   \n80\n.\n00000\n   \n14\n.\n00000\n \n  \n58\n.\n00000\n   \n18\n.\n00000\n   \n89\n.\n00000\n   \n14\n.\n00000\n \n  \n58\n.\n00000\n   \n17\n.\n00000\n   \n88\n.\n00000\n   \n13\n.\n00000\n \n  \n58\n.\n00000\n   \n18\n.\n00000\n   \n82\n.\n00000\n   \n11\n.\n00000\n \n  \n58\n.\n00000\n   \n19\n.\n00000\n   \n93\n.\n00000\n   \n12\n.\n00000\n \n  \n50\n.\n00000\n   \n18\n.\n00000\n   \n89\n.\n00000\n    \n8\n.\n00000\n \n  \n50\n.\n00000\n   \n18\n.\n00000\n   \n86\n.\n00000\n    \n7\n.\n00000\n \n  \n50\n.\n00000\n   \n19\n.\n00000\n   \n72\n.\n00000\n    \n8\n.\n00000\n \n  \n50\n.\n00000\n   \n19\n.\n00000\n   \n79\n.\n00000\n    \n8\n.\n00000\n \n  \n50\n.\n00000\n   \n20\n.\n00000\n   \n80\n.\n00000\n    \n9\n.\n00000\n \n  \n56\n.\n00000\n   \n20\n.\n00000\n   \n82\n.\n00000\n   \n15\n.\n00000\n \n  \n70\n.\n00000\n   \n20\n.\n00000\n   \n91\n.\n00000\n   \n15\n.\n00000\n \n\n\n\n我想要达到的结果\n\n\n使用Python和Jupyter notebook编写，完成任务要求，写一下注释", "Tag": "算法分析"}
{"Answer": "把FrameLayout外面在添加一个线性或相对布局试试，这个布局和你之前`android:id=\"@+id/RelativeLayout1\"布局是平级的，要不然Framelayout总是默认在左边，", "Konwledge_Point": "线性规划简介", "Question": "把 button 放在框架布局 frame layout 左边的问题\n在一个垂直的线性布局中设置了两个textviews，还有一个button和一个frame layout框架布局。\n\n我要把按钮放在框架布局的左边，并把按钮放在 relative layout布局中。\n\n但是如何把框架布局 frame layout 放在右边呢？\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "画图你的XYZ都是3D的数组，所以建议用scatter3画图\n \n[X,Y,Z] = meshgrid(5:.01:10,8:.01:15,24:30);\nF = X.*Y+Z;\nC = true(size(X));\nfor i = 1:numel(X)\n    n = X(i);% x(1)\n    y = Y(i);% x(2)\n    z = Z(i);\n    c = 0;\n    for k = 1:0.01:n\n        c = c+(4970250*y + 14100*(k -1 )*y^2*z + 10*( k - 1 )^2 * y^3 + 20*(k-1)*y^2*z+10*y*z^2)/ ...\n            ((705+(k-1)*y)* (1410*(k-1)* y * z+(k-1)^2 *y^2+2*(k-1)*y*z+z^2));\n    end\n    x = n;\n    C(i) = 31.4+(31213170/(1410*x*y+1410*z+x^2*y^2+2*x*y*z+z^2))-(159*z/(x*y+z))-(161.5*x*y/(x*y+z))-0.1*2*c<=0;\nend\nminf = min(F(C));\nif(isempty(minf))\n    fprintf('无解\\n')\nelse\n    I = find((minf==F)&C);\n    x = X(I);\n    y = Y(I);\n    z = Z(I);\n    fmin = x*y+z;\n    fprintf('在x=%d,y=%d,z=%d处目标函数有最小值%d\\n',x,y,z,fmin)\nend\nF(~C)=NaN;\nscatter3(X(:),Y(:),Z(:),10,F(:))\n\n结果：\n在x=5.010000e+00,y=1.498000e+01,z=24处目标函数有最小值9.904980e+01\n\n", "Konwledge_Point": "线性规划简介", "Question": "请问这个程序为什么不能输出小数呢，改变约束条件，X一直输出为固定的整数\n三个变量，我知道Z变量求解不变是因为函数问题，不知为何改变约束 X 也一直输出为一个整数\n\n\n\n\n\n[X\n,\nY\n,\nZ] \n=\n meshgrid(\n5\n:.\n01\n:\n10\n,\n8\n:.\n01\n:\n15\n,\n24\n:\n30\n)\n;\n\nF \n=\n X.*Y+Z\n;\n\nC \n=\n \ntrue\n(size(X))\n;\n\nfor i \n=\n \n1\n:numel(X)\n    n \n=\n X(i)\n;% x(1)\n\n    y \n=\n Y(i)\n;% x(2)\n\n    z \n=\n Z(i)\n;\n\n    \nc\n \n=\n \n0\n;\n\n    for k \n=\n \n1\n:\n0.01\n:n\n        \nc\n \n=\n \nc\n+(\n4970250\n*y + \n14100\n*(k \n-1\n )*y^\n2\n*z + \n10\n*( k - \n1\n )^\n2\n * y^\n3\n + \n20\n*(k\n-1\n)*y^\n2\n*z+\n10\n*y*z^\n2\n)/ ...\n            ((\n705\n+(k\n-1\n)*y)* (\n1410\n*(k\n-1\n)* y * z+(k\n-1\n)^\n2\n *y^\n2\n+\n2\n*(k\n-1\n)*y*z+z^\n2\n))\n;\n\n    \nend\n\n    C(i) \n=\n \n31.4\n+(\n31213170\n/(\n1410\n*\nx\n*y+\n1410\n*z+\nx\n^\n2\n*y^\n2\n+\n2\n*\nx\n*y*z+z^\n2\n))-(\n159\n*z/(\nx\n*y+z))-(\n161.5\n*\nx\n*y/(\nx\n*y+z))\n-0.1\n*\n2\n*\nc\n<\n=\n0\n;\n\n\nend\n\nminf \n=\n \nmin\n(F(C))\n;\n\nif(isempty(minf))\n    fprintf('无解\\n')\nelse\n    I \n=\n find((minf\n=\n=\nF)&C)\n;\n\n    \nx\n \n=\n X(I)\n;\n\n    y \n=\n Y(I)\n;\n\n    z \n=\n Z(I)\n;\n\n    fmin \n=\n \nx\n*y+z\n;\n\n    fprintf('在\nx\n=\n%d\n,\ny\n=\n%d\n,\nz\n=\n%d\n处目标函数有最小值\n%d\n\\n'\n,\nx\n,\ny\n,\nz\n,\nfmin)\n\nend\n\nF(~C)\n=\nNaN\n;\n\nsurf(X\n,\nY\n,\nZ\n,\nF)\n\n\n\n\n得到的不是想要的结果，不知是不是函数的问题，还是程序的问题。\n\n\n我的解答思路和尝试过的方法 ：改变X,Y,X取值范围，以及区间步数没有效果\n\n\n我想要达到的结果：输出X,Y，Z都可以是小数，或者有没有其他的函数可以求解这种三元约束非线性方程，（一个三元约束方程，一个三元目标函数，三元范围给定）请求解答", "Tag": "算法分析"}
{"Answer": "y =sigmoid( Wx+b)这类感知机模型，能学到的特性有限，难以学习复杂特性。通常是和其他网络搭配使用的。\n\n学习到曲线规律性的变化，色谱图这种的，我比较推荐LSTM（RNN神经网络的一种）\n\n如果是一些医学图片，我推荐CNN神经网络（UNet结构常用于医学图片的处理）\n\n训练好神经网络，是需要有大量的数据的。\n\n关于自学这方面，Python的话，目前PyTorch框架还是值得考虑的，PyTorch官网也提供了很好的全套的中文教程。机器学习和神经网络相关的，比较推荐吴恩达老师的课（B站搜索就行）", "Konwledge_Point": "线性规划简介", "Question": "想通过神经网络分析化学实验图谱，求建议\n本小白非计算机专业，目前自学python和机器学习，想通过神经网络分析化学方面的实验分析图谱，比如色谱图（下图）。这个曲线有一些凸起（峰），一些自然过程会导致这些凸起的高度发生变化，因此可以通过这个图的形态分析这些自然过程。但是这些变化不是线性的，而且经常有多种过程、因素叠加在一起，总之就是比较复杂。\n\n\n\n \n\n\n\n打个比方：假如这个图分析自人体血液，而已知人的年龄、肥胖程度、健康状况会对某些凸起（峰）造成规律性改变，因此可以通过曲线的形态反推这些信息。\n\n\n\n \n\n\n\n我手上有许多图谱和已知的结果，想让神经网络学习这些信息，最后实现自动分析。目前我自己学会了单隐藏层的BP神经网络，并通过识别曲线像素点竖向坐标的方式可以把这个曲线转换成一个一维数组。但问题在于，在保证图片精度的情况下（分辨率不能太低），转换得到的一维数组经常多达一两千个数（就是输入层有一两千个节点，输出层是单个节点），在我目前的代码下学习效果非常差（可以说就没效果），运行时间也很长。\n\n\n\n \n\n\n\n求大佬们给些建议和方向，BP神经网络能否实现我这个需求？还是换用别的方法？\n\n\n\n \n\n\n\n \n\n\n\n \n\n\n", "Tag": "算法分析"}
{"Answer": "我想应该是len的问题，可以考虑在全局int len=0;然后在create()中给len赋值n", "Konwledge_Point": "线性规划简介", "Question": "各位看下哪里出了问题(〃'▽'〃)  学生信息录入\nimport java.util.Scanner;\npublic class abc {\n    public static void main(String[] args) {\n        Student Stu = new Student();\n        Stu.Creat();\n        Stu.Put();\n        Stu.Print();\n    }\n}\n\n\nclass Student {\n    String[] Name;\n    char[] Sex;\n    float[] Hmath;\n    float[] Lmath;\n    float[] C;\n    float[] Object;\n    int len = C.length;\n    public void Creat() {\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请输入录入学生信息的数量：\");\n        int n = sc.nextInt();\n        Name = new String[n];\n        Sex = new char[n];\n        Hmath = new float[n];\n        Lmath = new float[n];\n        C = new float[n];\n        Object = new float[n];\n\n\n    \nfor\n(\nint\n i=\n0\n;i<n;i++)\n    {\n         \nSystem\n.\nout\n.println(\"请输入第\"+i+\"组数据\");\n         \nName\n[i] = sc.nextLine();\n         Sex[i] = sc.next().charAt(\n0\n);\n         Hmath[i] = sc.nextFloat();\n         Lmath[i] = sc.nextFloat();\n         C[i] = sc.nextFloat();\n         \nObject\n[i] = sc.nextFloat();\n     }\n}\n\npublic\n \nvoid\n Print() {\n    \nfor\n(\nint\n i=\n0\n;i<len;i++)\n    {\n         \nSystem\n.\nout\n.println(\"第\"+i+\"组\");\n         \nSystem\n.\nout\n.println(\nName\n[i]+\",\");\n         \nSystem\n.\nout\n.println(Sex[i]+\",\");\n         \nSystem\n.\nout\n.println(Hmath[i]+\",\");\n         \nSystem\n.\nout\n.println(Lmath[i]+\",\");\n         \nSystem\n.\nout\n.println(C[i]+\",\");\n         \nSystem\n.\nout\n.println(\nObject\n[i]+\",\");\n     }\n}\n\npublic\n \nvoid\n Put() {\n    \nfloat\n Sum1=\n0\n,Ave1=\n0\n;\n    \nfloat\n Sum2=\n0\n,Ave2=\n0\n;\n    \nfloat\n Sum3=\n0\n,Ave3=\n0\n;\n    \nfloat\n Sum4=\n0\n,Ave4=\n0\n;\n    \nfor\n(\nint\n i=\n0\n;i<len;i++)\n         Sum1+=Hmath[i];\n    \nfor\n(\nint\n i=\n0\n;i<len;i++)\n         Sum2+=Lmath[i];\n    \nfor\n(\nint\n i=\n0\n;i<len;i++)\n         Sum3+=C[i];\n    \nfor\n(\nint\n i=\n0\n;i<len;i++)\n         Sum4+=\nObject\n[i];\n    Ave1=Sum1/len;\n    Ave2=Sum2/len;\n    Ave3=Sum3/len;\n    Ave4=Sum4/len;\n    \nSystem\n.\nout\n.println(\"高等数学平均成绩为\"+Ave1);\n    \nSystem\n.\nout\n.println(\"线性代数平均成绩为\"+Ave2);\n    \nSystem\n.\nout\n.println(\"C语言平均成绩为\"+Ave3);\n    \nSystem\n.\nout\n.println(\"面对对象平均成绩为\"+Ave4);\n}\n\n\n\n}", "Tag": "算法分析"}
{"Answer": "你好，你错误定义了inline的函数建议\nf=inline('x^3-3*x+1')\n\n改成\nf=@(x)x^3-3*x+1;\n", "Konwledge_Point": "线性规划简介", "Question": "MATLAB中二分法出现错误，请问怎样解决\n#程序\n\n\nfunction\n g=bisectfun(f,a,b,tol)\n% bisectfun.m函数为编写的利用二分法求解非线性方程组的函数\n% f为方程f(x)=\n0\n中的f(x)\n% a为区间的左端点\n% b为区间的右端点\n% tol为根的精度\n% g为求的根\n\nif\n (nargin==\n3\n)\n    tol=\n1.0e-6\n;\n\nend\n\ng=compute\n_bisect(\nf\n,\na\n,\nb\n,\ntol\n)\n;\n\n\nfunction\n r=compute\n_bisect(\nf\n,\na\n,\nb\n,\ntol\n)\n\n% 计算左端点函数值\nfa=subs(f,a);\n% 计算右端点函数值\n\n\nfb=subs(f,b);\n% 区间中点函数值\nfab=subs(f,(a+b)/\n2\n);\n\nif\n(fa*fab>\n0\n)\n    t=(a+b)/\n2\n;\n    %采用递归方法\n    r=compute\n_bisect(\nf\n,\nt\n,\nb\n,\ntol\n)\n;\n\nelse\n\n    \nif\n(fa*fab==\n0\n)\n        r=(a+b)/\n2\n;\n    \nelse\n\n        \nif\n(abs(b-a)<=tol)\n            r=(b+\n3\n*a)/\n4\n;\n        \nelse\n\n            s=(a+b)/\n2\n;\n            r=compute\n_bisect(\nf\n,\na\n,\ns\n,\ntol\n)\n;  \n        \nend\n\n    \nend\n\n\nend\n\n\n\n\n\n\n\n\n\nclear all;\ntol=1e-6;\nf=inline('x^3-3*x+1');a=-1;b=1;\ng=bisectfun(f,a,b,tol)\n错误使用 sym>tomupad (line 1229)\nUnable to convert 'inline' to 'sym'.\n\n\n\n\n\n\n出错 sym (line 211)\n                S.s = tomupad(x);\n\n\n出错 subs (line 68)\n    r_unique_name = subs(sym(f_unique_name),varargin{:});\n\n\n出错 bisectfun>compute_bisect (line 15)\nfa=subs(f,a);\n\n\n出错 bisectfun (line 11)\ng=compute_bisect(f,a,b,tol);\n\n\n\n\n\n\nclear all;\ng=bisectfun('x^3-3*x+1',-1,1,1e-6)\n错误使用 sym>convertChar (line 1448)\nCharacter vectors and strings in the first argument can only specify a variable or number. To evaluate character\nvectors and strings representing symbolic expressions, use 'str2sym'.\n\n\n\n\n\n\n出错 sym>tomupad (line 1214)\n        S = convertChar(x);\n\n\n出错 sym (line 211)\n                S.s = tomupad(x);\n\n\n出错 subs (line 68)\n    r_unique_name = subs(sym(f_unique_name),varargin{:});\n\n\n出错 bisectfun>compute_bisect (line 15)\nfa=subs(f,a);\n\n\n出错 bisectfun (line 11)\ng=compute_bisect(f,a,b,tol);\n\n\n\n\n\n\n\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "那就是程序崩溃了创建函数一开始就会崩溃void CreateList_Lsort(LinkList& L,int n) {    L->next = NULL;LinkList是个指针，还没有分配空间，你就开始操作它的成员，就会崩溃先L = new LinkList;然后才是L->next = NULL;", "Konwledge_Point": "线性规划简介", "Question": "程序异常终止 ，但是没有报错\n问题遇到的现象和发生背景\n\n\n不能正确运行，程序没执行完异常退出\n\n\n用代码块功能插入代码，请勿粘贴截图\n\n\n#include \n\nusing namespace std;\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n#define ERROR 0\n\n\n#define OK 1\n\ntypedef int Status; \n//\n单链表中的元素为整型 \ntypedef int ElemType;\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n//\n单链表的类型定义 \n\ntypedef struct  LNode {\n\n    ElemType data;  \n//\n 数据域\n\n    struct LNode* \nnext\n;  \n//\n 指针域\n\n}LNode, * LinkList;\n\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n//\n创建含n个元素的非递减有序单链表 ，注意插入排序 \n\nvoid CreateList_Lsort(LinkList& L,int n) {\n    L->\nnext\n = NULL;\n    LNode* p_new = L->\nnext\n;\n    \n//\n新建立一个数组存放输入的元素的值\n    int a[\n1024\n];\n    \n//\n利用冒泡发先对输入的数据进行排序\n    \nfor\n (int m = \n0\n; m < n; ++m) { cin >> a[m]; }\n    int u, v,temp=\n0\n;\n    \nfor\n(u=\n0\n;udata=a[j];\n        p_new->\nnext\n = L->\nnext\n;\n        L->\nnext\n = p_new;\n    }\n\n\n}\n//\nCreateList_Lsort\n\n\n\n\n//\n输出单链表\n\nStatus PrintList_L(LinkList L) {\n\n    LinkList p = L->\nnext\n;\n\n    \nwhile\n (p) {\n\n        cout << p->data << \n\" \"\n;\n\n        p = p->\nnext\n;\n\n    }\n\n    cout << endl;\n\n    return OK;\n\n}\n//\nPrintList_L\n\nint main() {\n\n    LinkList La；\n    int n;\n    cin >> n;\n//\n输入线性链表La的长度\n    CreateList_Lsort(La, n);\n    PrintList_L(La);\n    return \n0\n;\n\n}\n\n\n\n\n运行结果及报错内容\n\n\n0x00ED6A4B 处(位于 test.exe 中)引发的异常: 0xC0000005: 写入位置 0xCCCCCCD0 时发生访问冲突。", "Tag": "算法分析"}
{"Answer": "该回答引用GPTᴼᴾᴱᴺᴬᴵ这个代码实现了一个哈希表，但是哈希函数采用了一个简单的计数哈希。需要改进哈希函数，以减少冲突。改进后，还需要修改插入和查找函数，以便使用新的哈希函数。\n改进哈希函数的方法很多，以下是一些常见的方法：\n求余数哈希求余数哈希是计算哈希值的常见方法。这种方法需要选择一个素数作为哈希表大小，然后将键的字符值相加，然后将结果取模。例如，如果哈希表大小为N，键的字符值为c1, c2, c3等，则哈希值为：(c1 + c2 + c3 + ...) % N。这种方法可以产生比计数哈希更好的分布，但是如果哈希表大小不是素数，就可能会出现不均匀的哈希值分布。\n多项式哈希多项式哈希是一种计算哈希值的方法，它将键的字符值视为多项式的系数。例如，如果键是\"abcd\"，则其哈希值可以表示为：a * p^3 + b * p^2 + c * p + d，其中p是一个素数。这种方法可以产生非常好的哈希值分布，并且可以通过选择不同的p值来减少冲突。\n布谷鸟哈希布谷鸟哈希是一种更高级的哈希函数，它可以在O(1)的时间内完成插入和查找操作。它的基本思想是将哈希表分成多个小部分，每个小部分都可以包含多个键。当哈希函数计算出键的哈希值后，它会在所属的小部分中查找是否已经存在相同的键。如果存在，它会将该键移动到另一个小部分中，并在新的小部分中插入该键。这个过程会一直重复，直到没有更多的冲突发生为止。\n\n在这里，我们选择第一个方法，即求余数哈希。\n下面是改进后的哈希函数：\n// improved hash function using modulo hashing\nint modulo_hash(char* key, int table_size) {\n    int hash = 0;\n    while(*key) {\n        hash = (hash * 31 + *key) % table_size;\n        key++;\n    }\n    return hash;\n}\n\n\n\n我们还需要修改插入和查找函数，以便使用新的哈希函数。\n下面是修改后的插入函数：\n// improved insert function using modulo hashing\nint insertPerson(person_struct *name_store, char *fi_name, char *la_name, char *c_code, char *a_code, char *l_number, int *allPersons) {\n    int i;\n    int hash, firsthash;\n    char tempFullName[MAX_NAME_LENGTH*2+1];\n\n\n", "Konwledge_Point": "线性规划简介", "Question": "关于#哈希函数#的问题，如何解决？\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n\n#\ndefine\n MAX_PERSONS 100000    \n// hash table size - experiment with different values\n\n\n#\ndefine\n MAX_NAME_LENGTH 50\n\n\n#\ndefine\n COUNTRY_CODE_LENGTH 4\n\n\n#\ndefine\n AREA_CODE_LENGTH 4\n\n\n#\ndefine\n LOCAL_NUMBER_LENGTH 8\n\n\n\n// struct to store a persosn name and phone nummber details\n\n\ntypedef\n \nstruct\n \nperson\n {\n    \nchar\n *first_name;\n    \nchar\n *last_name;\n    \nchar\n *fullName;\n    \nchar\n *countryCode;\n    \nchar\n *areaCode;\n    \nchar\n *localNumber;\n    \n} person_struct;\n\n\n// global variables for printing status infomation\n\n\nint\n collision = \n0\n;\n\nint\n longest_probing_sequence = \n0\n;\n\n\n// The bad hash function! \nTODO:\n Implement a better hesh function!\n\n\nint\n \ncount_hash\n(\nint\n mod, \nchar\n* fullName, \nint\n fullNameLength)\n \n{\n    \nint\n i;\n    \nint\n hash = \n0\n;\n    \nfor\n(i=\n0\n; i < fullNameLength; i++){\n        hash = (hash + fullName[i])%mod;\n    }\n    \nreturn\n hash;\n}\n\n\n/**\n function to insert a person into the hash table\n (maybe not the best way to do it, but will have to do for now)\n the key used for a person is the first name and last name together\n \nTODO:\n    I this function you will find the probing method\n     You need to implement a better one.\n*/\n\n\nint\n \ninsertPerson\n(    person_struct *name_store,\n            \nchar\n *fi_name,\n            \nchar\n *la_name,\n            \nchar\n *c_code,\n            \nchar\n *a_code,\n            \nchar\n *l_number,\n            \nint\n *allPersons)\n \n{\n    \nint\n i;\n    \nint\n hash,firsthash;\n    \n    \n// Allocating memory for person information\n\n    \nint\n fiNameLength = \nstrlen\n(fi_name);\n    \nchar\n *tempFiName = \nmalloc\n(fiNameLength*\nsizeof\n(\nchar\n)+\n1\n);\n    \nint\n laNameLength = \nstrlen\n(la_name);\n    \nchar\n *tempLaName = \nmalloc\n(laNameLength*\nsizeof\n(\nchar\n)+\n1\n);\n    \nint\n coCodeLength = \nstrlen\n(c_code);\n    \nchar\n *tempCoCode = \nmalloc\n(coCodeLength*\nsizeof\n(\nchar\n)+\n1\n);\n    \nint\n arCodeLength = \nstrlen\n(a_code);\n    \nchar\n *tempArCode = \nmalloc\n(arCodeLength*\nsizeof\n(\nchar\n)+\n1\n);\n    \nint\n loNumberLength = \nstrlen\n(l_number);\n    \nchar\n *tempLoNumber = \nmalloc\n(loNumberLength*\nsizeof\n(\nchar\n)+\n1\n);\n    \nint\n fullNameLength = MAX_NAME_LENGTH*\n2\n;\n    \nchar\n *tempFullName = \nmalloc\n(fullNameLength*\nsizeof\n(\nchar\n)+\n1\n);\n\n    \nstrcpy\n(tempFiName, fi_name);\n    \nstrcpy\n(tempLaName, la_name);\n    \nstrcpy\n(tempCoCode, c_code);\n    \nstrcpy\n(tempArCode, a_code);\n    \nstrcpy\n(tempLoNumber, l_number);\n    \n    \n//concatenating first name and last name into a variable for the key\n\n    \nstrcpy\n(tempFullName, tempFiName);\n    \nstrcat\n(tempFullName, tempLaName);\n    \n    \n//changeing the key to capital letters\n\n    \nfor\n (i=\n0\n; i < fullNameLength; i++) {\n        tempFullName[i] = \ntoupper\n(tempFullName[i]);\n    }\n    tempFullName[i] = \n0\n;\n\n    \n// counter for number of persons stored in the hash table\n\n    *allPersons = *allPersons+\n1\n;\n\n    \n// compute hash for the key\n\n    hash = \ncount_hash\n(MAX_PERSONS, tempFullName, fullNameLength);\n    \n    \n// insert person into hash table\n\n    firsthash = hash;\n    \nint\n probing = \n0\n;\n    \nint\n stored = \n0\n;\n    \nwhile\n (stored == \n0\n) {\n        \nif\n (name_store[hash].fullName != \n0\n) {\n            \n// Linear probing used a probing method\n\n            \n// \nTODO:\n Implement better probing method\n\n            hash = (hash+\n1\n)%MAX_PERSONS;\n            collision++;\n            probing++;\n            \n            \n//Check if hashtable full\n\n            \nif\n (hash == firsthash) {\n                \nreturn\n \n0\n;\n            }\n        }\n        \nelse\n {\n            person_struct person;\n            person.first_name = tempFiName;\n            person.last_name = tempLaName;\n            person.fullName = tempFullName;\n            person.countryCode = tempCoCode;\n            person.areaCode = tempArCode;\n            person.localNumber = tempLoNumber;\n            name_store[hash] = person;\n            stored = \n1\n;\n        }\n    }\n    \nif\n (probing > longest_probing_sequence) {\n        longest_probing_sequence = probing;\n    }\n    \nreturn\n \n1\n;\n}\n\n\n/**\n \nTODO:\n Implement function to find person\n Note that a character array cannot be directly copied\n Note also that you must use the same probing mehtod as in insert in case of collisions\n @param name_storage - the the hash table where the persons have been stored\n @param personToFind - the full name of person to find\n @return 0 if person was not found\n*/\n\n\nint\n \nfindPerson\n(person_struct *name_storage, \nchar\n* personToFind)\n \n{\n    \nprintf\n(\n\"\\nSearching...\\n\"\n);\n    \nreturn\n \n0\n;\n}\n\n\n// main function\n\n\nint\n \nmain\n()\n \n{\n    FILE *personFile;\n    \n//person_struct persons[MAX_PERSONS+1];\n\n    \n// allocate memory for hash table and initialize needed variables\n\n    person_struct *persons = (person_struct *)\nmalloc\n(\nsizeof\n(person_struct)*(MAX_PERSONS+\n1\n));\n    \nchar\n firstName[MAX_NAME_LENGTH];\n    \nchar\n lastName[MAX_NAME_LENGTH];\n    \nchar\n countryCode[COUNTRY_CODE_LENGTH];\n    \nchar\n areaCode[AREA_CODE_LENGTH];\n    \nchar\n localNumber[LOCAL_NUMBER_LENGTH];\n    \nint\n personCount = \n0\n;\n    \ndouble\n totaltime;\n    \nclock_t\n start,end;\n    \nint\n i;\n    \nint\n full = \n0\n;\n\n    \n// get input file name from user\n\n    \nchar\n fileName[\n500\n];\n    \nprintf\n(\n\"Type filename:  > \"\n);\n    \nscanf\n(\n\"%s\"\n,fileName);\n\n    personFile = \nfopen\n(fileName,\n\"r\"\n);\n\n    \nif\n (personFile == \nNULL\n){\n        \nprintf\n(\n\"NO SUCH FILE!\\n\"\n);\n        \nreturn\n \n0\n;\n    }\n\n    \nchar\n garbage[\n1000\n];\n\n    \n// measure time for inserting all persons into the hash table\n\n    start = \nclock\n();\n    \n    \n// reade lines while not end of file\n\n    \nwhile\n (\nfscanf\n(personFile, \n\"%[^,], %[^,], %[^,], %[^,], %[^\\n]\"\n, firstName, lastName, countryCode, areaCode, localNumber) != EOF) {\n        \n// try to insert person into hash table\n\n        \nif\n (\ninsertPerson\n(persons, firstName, lastName, countryCode, areaCode, localNumber, &personCount) == \n0\n){\n            \nprintf\n(\n\"Hash table full. File not processed completely!\\n\"\n);\n            full = \n1\n;\n            \nbreak\n;\n        }\n\n        \nif\n (\nfscanf\n(personFile, \n\"%999[^a-zA-Z']\"\n, garbage) == EOF) {\n            \n// End of file garbage\n\n            \nbreak\n;\n        }\n    }\n\n    \nfclose\n(personFile);\n    \n    end = \nclock\n();\n\n    \n// printing status information\n\n    \nif\n (full == \n0\n) {\n        \nprintf\n(\n\"Total number persons inserted: %d\\n\"\n,personCount);\n        \nprintf\n(\n\"\\n\\nFillrate is: %f%%\\n\"\n, (personCount/(\ndouble\n)MAX_PERSONS)*\n100.00\n);\n        \nprintf\n(\n\"Total number of collisions: %d\\n\"\n, collision);\n        \nprintf\n(\n\"Longest probing sequece: %d\\n\"\n, longest_probing_sequence);\n    }\n\n    totaltime = (\ndouble\n)(end-start)/CLOCKS_PER_SEC;\n    \nprintf\n(\n\"\\n\\nTime for inserting %f seconds\\n\"\n, totaltime);\n    \n    \n// measure time to find a person\n\n    start = \nclock\n();\n    \n    \n// Searching for one person\n\n    \nchar\n searchPersonFullName[MAX_NAME_LENGTH*\n2\n] = \n\"Tian Alphonse JinchengAnguissola\"\n;\n    \n// use findPeso() function to get place of the hash table where the person should be\n\n    \nint\n place = \nfindPerson\n(persons, searchPersonFullName);\n    \n// print detials of person if found, else inform that the person was not found\n\n    \n    end = \nclock\n();\n    \n    \nif\n (place != \n0\n) {\n        \nprintf\n(\n\"Found\\n\"\n);\n        \nprintf\n(\n\"%s \"\n, persons[place].first_name);\n        \nprintf\n(\n\"%s \"\n, persons[place].last_name);\n        \nprintf\n(\n\"%s \"\n, persons[place].countryCode);\n        \nprintf\n(\n\"%s \"\n, persons[place].areaCode);\n        \nprintf\n(\n\"%s\\n\"\n, persons[place].localNumber);\n    }\n    \nelse\n {\n        \nprintf\n(\n\"Not found\\n\"\n);\n    }\n    \n    totaltime = (\ndouble\n)(end-start)/CLOCKS_PER_SEC;\n    \nprintf\n(\n\"\\n\\nTime searching %f seconds\\n\"\n, totaltime);\n    \n    \n// Free all person elements from memory\n\n    \nfor\n (i=\n0\n; i <= MAX_PERSONS; i++) {\n        \nif\n (persons[i].fullName != \n0\n) {\n            \nfree\n(persons[i].last_name);\n            \nfree\n(persons[i].first_name);\n            \nfree\n(persons[i].countryCode);\n            \nfree\n(persons[i].areaCode);\n            \nfree\n(persons[i].localNumber);\n        }\n    }\n    \n// Free the table\n\n    \nfree\n(persons);\n    \nreturn\n \n0\n;\n}\n\n\n\n\n注意!提交时:\n\n\n•必要时压缩所有文件\n\n\n•不要包含可执行文件\n\n\n文件扩展名为。c\n\n\n在文件名、注释和代码中使用英文\n\n\n在Moodle中，你可以找到源代码文件phonebook_for_students.c\n\n\n你将在这个练习中练习。此外，您将发现包含\n\n\n不同数量的名字和电话号码(这些不是真实的名字和\n\n\n数字，它们已经生成了)。您可以运行源代码文件。它要求\n\n\n您需要输入一个文本文件。使用给定的文件。然后程序尝试全部插入\n\n\n人员和他们的数字组成一个哈希表结构。一旦完成，它就会尝试\n\n\n从哈希表中找一个人。这不会起作用，因为它没有\n\n\n已经实现了。研究代码和注释以了解它是如何实现的\n\n\n的工作原理。查看关于哈希表的幻灯片和视频来帮助你\n\n\n理解。\n\n\n1点-找到计算哈希值的函数。这不是一件好事\n\n\n解决方案。你的任务是实现一个更好的哈希函数。观察\n\n\n运行时间!越快越好。也要观察总计的打印输出\n\n\n碰撞次数和最长探测序列。实验\n\n\n不同的哈希函数。还可以尝试哈希表的大小。不要尝试\n\n\n大文件与糟糕的哈希函数!这要花很长时间!\n\n\n1点-找到探测方法。它使用线性探测作为探测\n\n\n方法。您的任务是实现一种不同的探测方法。实验\n\n\n不同的探测方法。你也可以尝试不同的哈希函数\n\n\n不同的探测方法。观察这些如何影响碰撞的数量\n\n\n以及探测序列的长度。还可以尝试不同大小的散列\n\n\n表格观察运行时间。\n\n\n1点-找到应该从哈希中找到一个人的函数\n\n\n表格您的任务就是实现这个函数。重复使用已经有的东西\n\n\n送给你。如果你不知道如何处理字符串，请寻求帮助\n\n\n(char数组)。\n\n\n在下一页，你会发现一个表，指定输入文件，数量\n\n\n每个文件中的人，以及他们是否搜索人应该找到\n\n\n在文件中。", "Tag": "算法分析"}
{"Answer": "看这篇文章的例子\r\n\r\nhttp://www.blogjava.net/killme2008/archive/2007/09/14/145195.html", "Konwledge_Point": "线性规划简介", "Question": "线程测试--疑惑\n今天看了下线程中ReentrantLock类，便根据网上的资料写了个测试代码？ \n\n结果发现每次运行速度都不一样很纳闷。。。。。特来求教--哪出问题了？ \n\n另外第一次特别慢许多？\n\nps：网上说  Tim Peierls 用一个简单的线性全等伪随机数生成器（PRNG）构建了一个简单的评测 \n\n    哪位大虾有这评测,能否提供，感激不尽！ \n\n[code=\"java\"]public class ReentrantLockTest {\n\n        private CyclicBarrier barrier;\n\n        private Object objTest;\n\n        private int threadNum;  \n\n\n\n    public ReentrantLockTest(int threadNum) {  \n        barrier = new CyclicBarrier(threadNum + 1);  \n        this.threadNum = threadNum;  \n    }  \n\n    public static void main(String args[]) {  \n        int threadCount = 5000;  \n        ReentrantLockTest test4 = new ReentrantLockTest(threadCount);  \n        test4.objTest = test4.new ReentrantLockUnFair();  \n        test4.test();             \n        ReentrantLockTest test2 = new ReentrantLockTest(threadCount);  \n        test2.objTest = test2.new ReentrantLockUnFair();  \n        test2.test();             \n        ReentrantLockTest test1 = new ReentrantLockTest(threadCount);  \n        test1.objTest = test1.new ReentrantLockFair();  \n        test1.test();  \n        ReentrantLockTest test3 = new ReentrantLockTest(threadCount);  \n        test3.objTest = test3.new SynchronizedTest();  \n        test3.test();  \n    }  \n\n    public void test() {  \n        try {  \n            for (int i = 0; i < threadNum; i++) {  \n                new TestThread(objTest).start();  \n            }  \n            barrier.await(); // 等待所有任务线程创建  \n            long start = System.currentTimeMillis();  \n            barrier.await(); // 等待所有任务计算完成  \n            long end = System.currentTimeMillis();  \n\n           //另外一种写发  \n\n\n\n\n//              long start = System.currentTimeMillis();\n\n//              barrier.await(); // 等待所有任务线程创建\n\n//              barrier.await(); // 等待所有任务计算完成\n\n//              long end = System.currentTimeMillis();    \n\n\n\n            System.out.println(\"花费时间:\" + (end - start) + \"毫秒\");  \n        } catch (Exception e) {  \n            throw new RuntimeException(e);  \n        }  \n    }  \n\n    class TestThread extends Thread {  \n\n        private Object obj;  \n        public TestThread(Object obj) {  \n            this.obj = obj;  \n        }  \n\n        public void run() {  \n            try {  \n                barrier.await();  \n                obj.equals(\"\");  \n                barrier.await();  \n            } catch (Exception e) {  \n                throw new RuntimeException(e);  \n            }  \n        }  \n    }  \n    class ReentrantLockFair {  \n        public boolean equals(Object obj){  \n            final Lock lock = new ReentrantLock(true);  \n            lock.lock();  \n            try {  \n                for(int i=0 ; i<10 ; i++){  \n                }  \n            } finally {  \n                lock.unlock();  \n            }  \n            return true;  \n        }  \n    }  \n    class ReentrantLockUnFair {  \n        public boolean equals(Object obj){  \n            final Lock lock = new ReentrantLock(false);  \n            lock.lock();  \n            try {  \n                for(int i=0 ; i<10 ; i++){  \n                }  \n            } finally {  \n                lock.unlock();  \n            }  \n            return true;  \n        }  \n    }  \n    class SynchronizedTest {  \n        public boolean equals(Object obj){  \n            synchronized (obj) {  \n                for(int i=0 ; i<10 ; i++){  \n                }                     \n            }  \n            return true;  \n        }  \n    }  \n\n\n\n\n}  [/code]\n\n[b]问题补充：[/b]\n\n个人练习，无需求。。。\n\n弄不明白所以来求教，环境。。本机 :cry: \n\n[b]问题补充：[/b]\n\n把94行   synchronized (obj) {   改成了 synchronized (this)\n\n\n\n每次测试都不一样，我就是按那篇修改来的\n\n可测试结果每次不一样，请问我这样的测试类有问题吗？问题在哪呢？", "Tag": "算法分析"}
{"Answer": "你得算上前面的结果啊, 比如12+3, 遍历到2的时候sum是1, 应该是1*10+2", "Konwledge_Point": "线性规划简介", "Question": "栈的后缀表达式中不懂\n问题遇到的现象和发生背景\n\n\n#include \n#include \n#include\n#define ERROR 0\n#define TRUE 1\n#define FALSE 0\n#define OK 1\n#define max 100\n\n\ntypedef struct STACK\n{\n    int date[max];\n    int top;\n}stack;\n\n\nstack* initStack()//创建线性存储结构的栈结构\n{\n    stack* s;\n    s = (stack*)malloc(sizeof(stack));\n    s->top = -1;\n    return s;\n}\n\n\nvoid destroyStack(stack* s)//摧毁栈\n{\n    free(s);\n    printf(\"清空成功！\");\n}\n\n\nstack* clearStack(stack* s)//清空栈\n{\n    s->top = -1;\n    printf(\"清理成功！\");\n    return s;\n}\n\n\nint stackEmpty(stack* s)//判断链表是否为空\n{\n    if (s->top >= max)\n        return FALSE;\n    if (s->top == -1)\n        return TRUE;\n    else\n        return FALSE;\n}\n\n\nint getTop(stack* s, int* e)//获取栈顶元素\n{\n    if (s->top > -1 && s->top < max)\n    {\n        *e = s->date[s->top];\n        return OK;\n    }\n    else\n        return FALSE;\n}\n\n\nint push(stack* s, int e)//进栈操作\n{\n    if (s->top == max - 1)\n    {\n        return ERROR;\n    }\n    s->top++;\n    s->date[s->top] = e;\n    return OK;\n}\n\n\nint pop(stack* s, int* e)//出栈操作\n{\n    if (s->top == -1)\n        return ERROR;\n    *e = s->date[s->top];\n    s->top--;\n    return OK;\n}\n\n\nint stackLength(stack* s)//获取链表长度\n{\n    return s->top++;\n}\n\n\nint main()\n{\n    char str[100];\n    int i = 0, a, b, c, sum;\n    stack* s;\n    s = initStack();\n    gets_s(str);\n    while (str[i] != '\\0')\n    {\n        if (str[i] >= '0' && str[i] <= '9')//1. 将字符串型的数字转换为整型（或者浮点型）。\n        {\n            sum = 0;\n            sum = str[i] - '0';\n            i++;\n            while (str[i] >= '0' && str[i] <= '9')\n            {\n                sum = sum * 10 + str[i] - '0';\n                printf(\"%d\\n\",sum);\n                i++;\n            }\n            push(s, sum);\n        }\n        if (str[i] == '+' || str[i] == '-' || str[i] == '\n' || str[i] == '/')//3. 遇到运算符（#），则将栈中的前两个数字（a和b）出栈，并将b#a的值压入栈中。\n        {\n            pop(s, &a);\n            pop(s, &b);\n            if (str[i] == '+')\n                push(s, b + a);\n            else if (str[i] == '-')\n                push(s, b - a);\n            else if (str[i] == '\n')\n                push(s, b * a);\n            else if (str[i] == '/')\n                push(s, b / a);\n            else\n                printf(\"error\\n\");\n        }\n        i++;\n    }\n    pop(s, &c);//栈顶的数字出栈\n    printf(\"%s=%d\\n\", str, c);\n    return 0;\n}\n\n\n这是怎么变的  sum是整形  我不应该 用sum等于 str{i}-0 就行了吗         为什么sum*10还要加str     ", "Tag": "算法分析"}
{"Answer": "问题已解决，这只是一个思路，对照代码自己看一下，\r\n链接：https://pan.baidu.com/s/1mu_GOwwcvzVI1u1l1mK55Q \r\n提取码：ce12", "Konwledge_Point": "线性规划简介", "Question": "fragment跳转另一个fragment的问题！\n项目地址：\n\n链接: \nhttps://pan.baidu.com/s/1OHSva0M5PIQMWNP0iwzlLg\n 提取码: csf5 \n\n\n\n求大能帮我解决一下。我不知道怎么去写这个跳转。\n\n\n\n\n\n\n鼠标点击需要跳转（例如点击“苹果手机”）；\n\n\n\npublic class MsgFragment extends Fragment {\n\n    View view;\n    TextView textView;\n    private int i;\n    private String str;\n\n\n    private String[] mVals = new String[] { \"苹果手机\", \"笔记本电脑\", \"电饭煲\", \"腊肉\",\n            \"特产\", \"剃须刀\", \"宝宝\", \"康佳\" };\n    private LayoutInflater mInflater;\n    private FlowLayout mFlowLayout;\n\n    //自定义recyclerveiw的适配器\n\n\n\n    @Override\n    public void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        mInflater = LayoutInflater.from(getContext());\n\n\n    }\n\n    public MsgFragment() {\n    }\n\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n\n       view = inflater.inflate(R.layout.fragment_msg, container, false);\n\n        mFlowLayout = view.findViewById(R.id.id_flowlayout);\n\n\n        initData();\n\n\n        return view;\n    }\n    public void initData() {\n        /**\n         * 找到搜索标签的控件\n         */\n        for (  i = 0; i < mVals.length; i++) {\n            final TextView tv = (TextView) mInflater.inflate(\n                    R.layout.search_label_tv, mFlowLayout, false);\n            tv.setText(mVals[i]);\n            str = tv.getText().toString();\n            //点击事件\n            tv.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    try {\n\n                        switch (str) {\n                            case \"苹果手机\":\n\n\n                                break;\n                            case \"笔记本电脑\":\n\n                                break;\n                            case \"电饭煲\":\n\n                                break;\n                            case \"腊肉\":\n\n                                break;\n                            case \"特产\":\n\n                                break;\n                            case \"剃须刀\":\n\n                                break;\n                            case \"宝宝\":\n\n                                break;\n                            case \"康佳\":\n\n                                break;\n                            default:\n\n                                break;\n                        }\n\n\n\n\n\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n\n                }\n            });\n            mFlowLayout.addView(tv);//添加到父View\n        }\n\n\n    }\n\n\n}\n\n\n\n\n需要跳转到的fragment\n\n\n\npublic class CollectFragment extends Fragment {\n    private View view;//定义view用来设置fragment的layout\n    public RecyclerView mCollectRecyclerView;//定义RecyclerView\n    //定义以goodsentity实体类为对象的数据集合\n    private ArrayList goodsEntityList = new ArrayList();\n    //自定义recyclerveiw的适配器\n    private CollectRecycleAdapter mCollectRecyclerAdapter;\n\n    @Nullable\n    @Override\n    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\n        //获取fragment的layout\n        view = inflater.inflate(R.layout.item_content, container, false);\n        //对recycleview进行配置\n        initRecyclerView();\n        //模拟数据\n        initData();\n        return view;\n    }\n\n    /**\n     * TODO 模拟数据\n     */\n    private void initData() {\n        for (int i=0;i<10;i++){\n            GoodsEntity goodsEntity=new GoodsEntity();\n            goodsEntity.setGoodsName(\"模拟数据\"+i);\n            goodsEntity.setGoodsPrice(\"100\"+i);\n            goodsEntityList.add(goodsEntity);\n        }\n    }\n\n    /**\n     * TODO 对recycleview进行配置\n     */\n\n    private void initRecyclerView() {\n        //获取RecyclerView\n        mCollectRecyclerView=view.findViewById(R.id.collect_recyclerView);\n        //创建adapter\n        mCollectRecyclerAdapter = new CollectRecycleAdapter(getActivity(), goodsEntityList);\n        //给RecyclerView设置adapter\n        mCollectRecyclerView.setAdapter(mCollectRecyclerAdapter);\n        //设置layoutManager,可以设置显示效果，是线性布局、grid布局，还是瀑布流布局\n        //参数是：上下文、列表方向（横向还是纵向）、是否倒叙\n        mCollectRecyclerView.setLayoutManager(new LinearLayoutManager(getActivity(), LinearLayoutManager.VERTICAL, false));\n        //设置item的分割线\n        mCollectRecyclerView.addItemDecoration(new DividerItemDecoration(getActivity(),DividerItemDecoration.VERTICAL));\n        //RecyclerView中没有item的监听事件，需要自己在适配器中写一个监听事件的接口。参数根据自定义\n        mCollectRecyclerAdapter.setOnItemClickListener(new CollectRecycleAdapter.OnItemClickListener() {\n            @Override\n            public void OnItemClick(View view, GoodsEntity data) {\n                //此处进行监听事件的业务处理\n                Toast.makeText(getActivity(),\"我是item\",Toast.LENGTH_SHORT).show();\n            }\n        });\n    }\n\n}\n\n", "Tag": "算法分析"}
{"Answer": "用代码插入功能啊，指出哪一个函数有问题", "Konwledge_Point": "线性规划简介", "Question": "c语言数据结构词索引表出了点问题，谁能帮忙看看呀\n#include\n\n#include\n\n#include\n\n#include \n\n#include \n\n\n\n#define OK 1\n\n#define ERROR 0\n\n#define TRUE 1\n\n#define FALSE 0\n\n#define OVERFLOW -2\n\n\n\n#define MaxBookNum 1000 //假设只对1000本书建立索引表(1000)\n\n#define MaxKeyNum 2500 //索引表的最大容量(2500)\n\n#define MaxLineLen 500 //书目串的最大长度(500)\n\n#define MaxWordNum 10 //词表的最大容量\n\n#define MaxWordLength 30 //单词的最大长度\n\n\n\ntypedef int Status;\n\ntypedef int ElemType; //定义链表的数据元素类型为整型\n\ntypedef int Boolean;\n\ntypedef struct\n\n{\n\nchar item[MaxWordNum][MaxWordLength]; //字符串的数组\n\nint last; //词表的长度\n\n}WordListType; //词表的类型（顺序表）\n\ntypedef struct\n\n{\n\nchar \nch; //如果是非空串，则按串长分配存储区，否则ch为NULL\n\nint length; //串长度\n\n}HString;\n\ntypedef struct LNode\n\n{\n\nElemType data;\n\nstruct LNode *next;\n\n}LNode,*Link,*Position;\n\ntypedef struct\n\n{\n\nLink head,tail;\n\nint len;\n\n}LinkList;\n\ntypedef struct\n\n{\n\nHString key; //关键词\n\nLinkList bnolist; //存放书号索引的链表\n\n}IdxTermType; //索引项类型\n\ntypedef struct\n\n{\n\nIdxTermType item[MaxKeyNum+1];\n\nint last;\n\n}IdxListType; //索引表类型\n\n//----------------主要变量--------------\n\nchar buf[MaxLineLen]; //书目串缓冲区\n\nWordListType wdlist; //关键字词表\n\nIdxListType idxlist; //索引表\n\nchar oftenwords[6][10] = {\"an\",\"a\",\"of\",\"and\",\"to\",\"the\"};\n\n/\n******************************声明部分****************************************/\n\n//--------------基本操作---------\n\nvoid InitIdxList (IdxListType \nidxlist);\n\n//初始化操作，置索引表idxlist为空表，且在idxlist.item[0]设一空串\n\nvoid GetLine (FILE *f);\n\n//从文件F读入一个书目信息到书目串缓冲区buf\n\nvoid ExtractKeyWord (int *Num);\n\n//Status ExtractKeyWord(char\n Buffer,WordListType *w,int *Num);\n\n//从buf中提取书名关键词到词表wdlist，书号存入bno\n\nStatus InsIdxList (IdxListType *idxlist,ElemType bno);\n\n//将书号为bno的书名关键词按词典顺序插入索引表idxlist\n\nvoid PutText (FILE *g,IdxListType idxlist);\n\n//将生成的索引表idxlist输出到文件g\n\n//--------------为实现在索引表上进行插入，要先实现下列操作-----------\n\nvoid GetWord (int i,HString *wd);\n\n//用wd返回词表wdist中第i个关键词\n\nint Locate (IdxListType *idxlist,HString wd,Boolean *b);\n\n//在索引表idxlist中查询是否存在与wd相等的关键词。若存在，则返回其在索引表\n\n//中的位置，且b取值TRUE；否则返回插入位置，且b取值FALSE\n\nvoid InsertNewKey(int j,HString wd);\n\n//在索引表idxli的第i项上插入新关键词wd，并初始化书号索引的链表为空表\n\nStatus InsertBook (int i,int bno);\n\n//在索引表idxlist的第i项中插入书号为bno的索引\n\n//------------串的堆分配存储表示-----------\n\nStatus StrAssign(HString *T,char *chars);\n\n//生成一个其值等于串常量chars的串T\n\nint StrCompare(HString S,HString T);\n\n//若S>T，则返回值>0,若S=T，则返回值 = 0，若Snext = NULL;\n\n(*L).head = (*L).tail = p;\n\n(*L).len = 0;\n\nreturn OK;\n\n}\n\nStatus MakeNode(Link *p,ElemType e)\n\n{\n\n*p = (Link)malloc(sizeof(LNode));\n\nif(!(*p))\n\nexit(OVERFLOW);\n\n(*p)->data = e;\n\n(*p)->next = NULL;\n\nreturn OK;\n\n}\n\nStatus Append (LinkList *L,Link s)\n\n{\n\nint i = 1;\n\n(*L).tail->next = s;\n\nwhile(s->next){\n\ns = s->next;\n\ni++;\n\n}\n\n(*L).tail = s;\n\n(*L).len += i;\n\nreturn OK;\n\n}\n\nvoid GetWord(int i,HString *wd)\n\n{\n\nchar *p;\n\np = *(wdlist.item +i);\n\nStrAssign(wd,p); //生成关键字字符串\n\n}\n\nint Locate(IdxListType *idxlist,HString wd,Boolean *b)\n\n{\n\nint i,m;\n\nfor(i = (*idxlist).last-1; ( m=StrCompare((*idxlist).item[i].key,wd) ) >0; --i);\n\n\n\nif(m == 0){ //找到\nb = TRUE;\n\nreturn i;\n\n}\n\nelse{\n\n*b = FALSE;\n\nreturn i+1;\n\n}\n\n}\n\nvoid InsertNewKey(int j,HString wd)\n\n{\n\nint count;\n\nInitList(&idxlist.item[idxlist.last+1].bnolist);\n\nfor(count = idxlist.last-1; count>=j; --count){ //后移索引项\n\nidxlist.item[count+1] = idxlist.item[count];\n\n}\n\nInitString(&idxlist.item[j].key);\n\nStrCopy(&idxlist.item[j].key,wd); //插入新的索引项 //串赋值\n\nInitList(&idxlist.item[j].bnolist); //初始化书号索引表为空表\n\n++idxlist.last;\n\n}\n\nStatus InsertBook (int i,int bookno)\n\n{\n\nLink p;\n\nif(!MakeNode(&p,bookno))\n\nreturn ERROR;\n\nAppend(&idxlist.item[i].bnolist,p);\n\nreturn OK;\n\n}\n\nStatus InsertIdxList(IdxListType *idxlist,int bno)\n\n{\n\nint i,j;\n\nHString wd;\n\nBoolean b;\n\nInitString(&wd);\n\nfor(i= 0;i'A'&& *(buf+i) <= 'Z'){\n\n*(buf+i) -= 'A' - 'a'; //若为大写，则转为小写\n\n}\n\nTempChar[j] = *(buf+i); //把当前字符加入TempChar中//------------\n\nj++;\n\ni++;\n\n} //if\n\nelse{ //若为空字符，则检索当前TempChar中保存的字符串是否为常用词\n\nIgnore = FALSE; //若Ignore为TRUE，则为常用词；为FALSE则不是常用词\n\n\n\nfor(m = 0;m<6;m++){ //查找是否为常用词\n\nif(strcmp(TempChar,oftenwords[m]) == 0){\n\nIgnore = TRUE; //是常用词\n\nbreak;\n\n}//if\n\n}//for\n\nif(Ignore){\n\nfor(m = 0;m<=j;m++)\n\nTempChar[m] = '\\0'; //清空TempChat[]\n\ni++;\n\nj = 0;\n\n}//if\n\nelse{ //不是常用词\n\nfor(m = 0;m<=j;m++) //将该词插入wdlist中\n\nwdlist.item[wdlist.last][m] = TempChar[m];\n\nfor(m = 0;m<=j;m++)\n\nTempChar[m] = '\\0'; //清空TempChat[]\n\nk++;\n\nwdlist.last++;\n\ni++;\n\nj=0;\n\n}//else\n\n}//else\n\n\n\n}//while\n\n}\n\n\n\nvoid GetLine(FILE *f)\n\n{\n\nfgets(buf,MaxLineLen,f);\n\n}\n\n\n\nvoid PutText (FILE \ng,IdxListType idxlist)\n\n{\n\nint i,j,k;\n\nLink p;\n\nfor(i = 0;i<=idxlist.last;i++){\n\nfor(j = 0;jnext;\n\nfprintf(g,\"%03d\",p->data);\n\nputc(' ',g);\n\n}//for\n\nputc('\\n',g);\n\n}//for\n\n}\n\n\n\nvoid PrintFile(FILE *FileName)\n\n{\n\nchar ch;\n\nrewind(FileName);\n\nch = getc(FileName);\n\nwhile(ch != EOF){\n\nputchar(ch);\n\nch = getc(FileName);\n\n}\n\nprintf(\"\\n\");\n\nrewind(FileName);\n\n}\n\n\n\n/*******************************主函数部分**************************************/\n\n\n\nint main()\n\n{\n\nFILE *f,*g;\n\nint ct;\n\nint BookNo;\n\nif((f = fopen(\"BookName.txt\",\"r\")) == NULL){\n\nprintf(\"ERROR in open BookName.txt\\n\");\n\nexit(1);\n\n}\n\nif((g = fopen(\"KeyWordIndex_self.txt\",\"w\"))==NULL){\n\nprintf(\"ERROR in open KeyWordIndex_self.txt\\n\");\n\nexit(1);\n\n}\n\nprintf(\"书单文件：\\n\");\n\nPrintFile(f);\n\nInitIdxList(&idxlist);\n\nWordListType w;\n\nwhile(!feof(f)){\n\nGetLine(f); //读取书单文件中的一行到缓冲区\n\nExtractKeyWord(&BookNo);\n\nInsertIdxList(&idxlist,BookNo);\n\n}\n\nPutText(g,idxlist);\n\nfclose(f);\n\nfclose(g);\n\nprintf(\"\\n结果如下：\\n\");\n\nif((g = fopen(\"KeyWordIndex_self.txt\",\"r\"))==NULL){\n\nprintf(\"ERROR in open KeyWorkIndex_self.txt\\n\");\n\nexit(1);\n\n}\n\nPrintFile(g);\n\nfclose(g);\n\nreturn 0;\n\n}", "Tag": "算法分析"}
{"Answer": "如果是卡死在switch里面，你可以试试把searchHash注释掉运行一遍。", "Konwledge_Point": "线性规划简介", "Question": "哈希表始终无法成功实现查找关键字（开放定址法)，如何解决？\n在编写一个哈希应用的小程序中始终无法实现对关键字的查找，也导致插入和删除功能始终无法进行，代码完全没有报错\n\n\n整体也可以运行，但运行到查找功能模块，程序就跑不动了\n对于hash定义了一个结构体成员变量为整形elem指针，和整型元素个数count，在模块代码都是用的结构体指针变量来访问成员\n\n\n模块代码：\n\n\n// 哈希表查找关键字\n\n\nint\n \nsearchHash\n(HashTable *hash, \nint\n \nkey\n, \nint\n address)\n{\n    address = \nhashFun\n(\nkey\n); \n// 求哈希地址\n\n    \nwhile\n (hash->elem[address] != \nkey\n) \n// 否则，使用开放定址法继续查找\n\n    {\n        address = (address + \n1\n) % m; \n// 开放定址法的线性探测\n\n        \n        \n// 如果 查找到NULLKEY | 循环回到原点，则说明关键字不存在，返回FALSE      \n\n      \nif\n(hash->elem[address] == NULLKEY || address ==\nhashFun\n(\nkey\n)) \n            \nprintf\n(\n\"查找 %d 失败。\\n\"\n, \nkey\n);\n            \nreturn\n \n0\n; \n//查找失败\n\n    }\n     hash->elem[address] = \nkey\n;\n    \nprintf\n(\n\"查找%d的哈希地址为 %d \\n\"\n,\nkey\n,address);\n    \nreturn\n \n1\n;\n//查找成功\n\n}\n\n\n\n\n\n主函数里调用它：\n\n\nint\n \nmain\n()\n\n\n{\n  \n//  int arr[HASHSIZE] = {12, 67, 56, 16, 25, 37, 22, 29, 15, 47, 48, 34}; // 要插入关键字\n\n    \nint\n key; \n// 关键字\n\n    \nint\n address; \n// 哈希地址\n\n    \nint\n i;\n    HashTable hash;\n     \nwhile\n(\n1\n)\n    {\n             \nprintf\n(\n\"==================哈希表的应用==================\\n \"\n);\n            \nprintf\n(\n\"-------------------1.创建哈希表-----------------\\n\"\n) ;\n             \nprintf\n(\n\"-------------------2.显示哈希表-----------------\\n\"\n) ;\n             \nprintf\n(\n\"-------------------3.插入关键字-----------------\\n\"\n) ;\n             \nprintf\n(\n\"-------------------4.查找关键字-----------------\\n\"\n) ;\n             \nprintf\n(\n\"-------------------5.删除关键字-----------------\\n\"\n) ;\n             \nprintf\n(\n\"-------------------0.退出-----------------\\n\"\n) ;\n             \n             \nprintf\n(\n\"请输入你的选择：\"\n);\n            \nscanf\n(\n\"%d\"\n,&i);\n            \nswitch\n(i)\n            {\n                \ncase\n \n0\n: \nprintf\n(\n\"\\n提示：退出系统！\\n\"\n);\nbreak\n;\n                \ncase\n \n1\n: \ninitHashTable\n(&hash);\nbreak\n;\n                \ncase\n \n2\n:    \nprint_HashTable\n(&hash);\nbreak\n;\n                \ncase\n \n3\n:    \nprintf\n(\n\"请输入要插入的关键字：\"\n); \n                        \nscanf\n(\n\"%d \\n\"\n,&key); \n                        \ninsertHash\n(&hash,key,address);\n                        \nbreak\n;\n                \ncase\n \n4\n:    \nprintf\n(\n\"请输入要查找的关键字：\"\n); \n                        \nscanf\n(\n\"%d \\n\"\n,&key); \n                        \nsearchHash\n(&hash, key,address);\n                        \nbreak\n;\n                \ncase\n \n5\n:    \nprintf\n(\n\"请输入要删除的关键字：\"\n); \n                        \nscanf\n(\n\"%d \\n\"\n,&key); \n                        \nDEL_HashTable\n(&hash, key,address);\n                        \nbreak\n;    \n                \n            }     \n             \n    } \n   \n}\n\n\n\n\n跑的结果：卡住完全没反应\n\n\n\n\n我的解答思路和尝试过的方法\n\n\n尝试修改函数类型为void来改写部分代码，但实际还是int用返回值来判断比较方便，我觉得代码逻辑完全没有问题，编译也没有错，死磕不出问题在哪里", "Tag": "算法分析"}
{"Answer": "谢谢，你的这个是对的，结果是我想要的，不过跟我讲解下以后做这种嵌套查询的时候要注意什么问题么？还有思路应该怎么整理出来？ \r\n首先你要把表关系搞明白。\r\n其次要真正的明白你想要的结果\r\n不过在工作中用级联查询确实不太多", "Konwledge_Point": "线性规划简介", "Question": "sql：寻找错误\n环境： mysql 5.1.45 \n\n\n\n题目: \n\n\n\n  已知关系模式: S (SNO,SNAME) 学生关系。SNO 为学号，SNAME 为姓名 \n\n\n\n  C (CNO,CNAME,CTEACHER) 课程关系。CNO 为课程号，CNAME 为课程名，CTEACHER 为任课教师 \n\n\n\n  SC(SNO,CNO,SCGRADE) 选课关系。SCGRADE 为成绩\n\n\n\n问题： \n\n\n\n  找出没有选修过“李明”老师讲授课程的所有学生姓名\n\n\n\n  \n\n\n\n  \n\n\n\ncreate database school;\n\nuse school\n\ncreate table s(\n  sno int not null auto_increment,\n  sname varchar(20) not null,\n  primary key(sno)\n);\n\ncreate table c(\n  cno int not null auto_increment,\n  cname varchar(20) not null,\n  cteacher varchar(20) not null,\n  primary key(cno)\n);\n\ncreate table sc(\n  sno int not null,\n  cno int not null,\n  scgrade int not null,\n  primary key(sno, cno)\n);\n\nalter table sc add constraint fk_s\nforeign key(sno) references s(sno);\n\nalter table sc add constraint fk_c\nforeign key(cno) references c(cno);\n\n\n 再向三张表中插入相应的数据，如下：\n\n\n  \n\n\ninsert into s(sname) values('魏东');\ninsert into s(sname) values('陈标');\ninsert into s(sname) values('张健');\ninsert into s(sname) values('丁翔');\ninsert into s(sname) values('徐章健');\ninsert into s(sname) values('陈燕翔');\ninsert into s(sname) values('单洪奇');\n\ninsert into c(cname, cteacher) values('大学英语', '邱俊敏');\ninsert into c(cname, cteacher) values('高等数学', '孙天川');\ninsert into c(cname, cteacher) values('线性代数', '孙敏');\ninsert into c(cname, cteacher) values('SQL基础', '肖浩');\ninsert into c(cname, cteacher) values('算法设计', '李明');\n\ninsert into sc(sno, cno, scgrade) values(1, 1, 100);\ninsert into sc(sno, cno, scgrade) values(1, 5, 98);\ninsert into sc(sno, cno, scgrade) values(2, 2, 60);\ninsert into sc(sno, cno, scgrade) values(3, 3, 48);\ninsert into sc(sno, cno, scgrade) values(3, 5, 68);\ninsert into sc(sno, cno, scgrade) values(4, 1, 100);\ninsert into sc(sno, cno, scgrade) values(4, 4, 50);\ninsert into sc(sno, cno, scgrade) values(5, 3, 89);\ninsert into sc(sno, cno, scgrade) values(5, 5, 68);\ninsert into sc(sno, cno, scgrade) values(6, 5, 100);\ninsert into sc(sno, cno, scgrade) values(7, 5, 80);\n\n\n\n\n \n\n\n\n再做题目，进行查询：\n\n\n\n \n\n\n\n  \n\n\n\nselect sname\nfrom s\nwhere sno in(\n  select sno \n  from sc\n  where cno not in(\n    select cno\n    from c\n    where cteacher = '李明'\n  )\n);\n\n\n\n查询结果是这样的：\n\n\n\n  +--------+\n| sname  |\n+--------+\n| 魏东   |\n| 陈标   |\n| 张健   |\n| 丁翔   |\n| 徐章健 |\n+--------+\n\n\n\n我这样做，为什么还是不能筛选出来人啊？\n\n\n\n而且其中学生：魏东、张健、徐章健都是选了李明老师的课程了的啊？\n\n\n\n \n\n\n\n哪位能告诉我这个是为什么？\n\n\n\n正确的做法是怎么样的啊？\n\n\n\n \n\n\n\n还有，对不起了，我现在还没有javaeye的论坛积分\n\n\n\n \n\n\n\n问题补充：\n\n\n\n  我现在这里是想用嵌套查询，如果能有更加简单的方法，希望各位高手能贡献下。", "Tag": "算法分析"}
{"Answer": "你上面代码多了一个sort函数调用啊，排序可能是O(n^2)，比较耗时", "Konwledge_Point": "线性规划简介", "Question": "关于时间复杂度的问题\n这里用俩段代码，其执行的结果应该是一样的。\n但是代码执行的时间却不一样\n看看 为什么俩段代码时间花费差这么多。\n这段代码花了 1500ms左右\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\nconst\n \nint\n N = \n1e6\n + \n5\n;\n\n#\ndefine\n ll long long\n\n\nint\n cnt = \n0\n;\n\nbool\n isprime[N]{};\n\nint\n prime[N]{};\n\nint\n num[N]{};\n\nint\n sum[N];\n\nint\n dp[N]{};\n\nint\n size = \n0\n;\n\nint\n not_prime[N]{};\n\nvoid\n \nSolution\n(\nint\n n)\n \n{\n    \n//一开始假设全是素数，然后再筛掉\n\n    \nmemset\n(isprime, \ntrue\n, \nsizeof\n(isprime));\n    isprime[\n1\n] = \nfalse\n;\n    \nfor\n (\nint\n i = \n2\n; i <= n; ++i) {\n        \nif\n (isprime[i])prime[++cnt] = i;\n        \nfor\n (\nint\n j = \n1\n; j <= cnt && i * prime[j] <= n; ++j) {\n            \n// 任何一个合数 = 质数 * 某一个数\n\n            \n// i * prime[j]是一个合数\n\n            isprime[i * prime[j]] = \nfalse\n;\n            not_prime[size++] = i * prime[j];\n            \n//如果prime[j]是i的最小质因子，那么 不管 i*x(x:表示随便一个数）的最小质因子都是 prime[j]\n\n            \n// 又因为 每一个合数都要由最小质因子筛去，所以 就 不让 i乘其他数了,直接break\n\n            \nif\n (i % prime[j] == \n0\n)\nbreak\n;\n        }\n    }\n}\n\nint\n \nmain\n()\n{\n    \nint\n n;\n    cin >> n;\n    \nSolution\n(n);\n    \nsort\n(not_prime, not_prime + size);\n    size--;\n\n    \n// for (int i = 0; i <= size;++i)\n\n    \n//     cout << not_prime[i] << endl;\n\n\n    \nfor\n (\nint\n i = \n0\n; i <= size; i++)\n    {\n        dp[not_prime[i]] = dp[not_prime[i] - \n1\n] + \n1\n;\n        num[dp[not_prime[i]]]++;\n    }\n    \n// for (int i = 0; i <= size;++i){\n\n    \n//     cout << dp[not_prime[i]] << endl;\n\n    \n// }\n\n    \n// for (int i = 1; i <= 3;++i){\n\n    \n//     cout << num[i] << endl;\n\n    \n// }\n\n\n    \nfor\n (\nint\n i = \nsqrt\n(n); i >= \n1\n; i--)\n        sum[i] += sum[i + \n1\n] + num[i];\n\n    \nint\n m;\n    \nwhile\n(~\nscanf\n(\n\"%d\"\n,&m)){\n        cout << sum[m] << endl;\n    }\n    \n//system(\"pause\");\n\n    \nreturn\n \n0\n;\n}\n\n\n\n\n\n\n\n\n这个就花了263ms左右\n\n\n\n\n#\ninclude\n \n\n\n\n#\ndefine\n INF 0x3f3f3f3f\n\n\n#\ndefine\n ll long long\n\n\nusing\n \nnamespace\n std;\n\nint\n factor[\n1000005\n];\n//记录最小素因子\n\n\nint\n prime[\n1000005\n],vis[\n1000005\n];\n//记录素数\n\n\nint\n dp[\n1000005\n],cnt[\n1000005\n],sum[\n1000005\n];\n\nint\n p=\n0\n;\n\n// 线性筛\n\n\nvoid\n \ninit\n(\nint\n n)\n\n\n{\n    vis[\n1\n]=\n1\n;\n    \nint\n i,j;\n    \nfor\n(i=\n2\n;i<=n;i++){\n        \nif\n(factor[i]==\n0\n){\n            prime[p++]=i;\n            vis[i]=\n1\n;\n            factor[i]=i;\n        }\n        \nfor\n(j=\n0\n;j= \n1\n; i--)\n        sum[i] = sum[i + \n1\n] + cnt[i];\n    \nwhile\n(~\nscanf\n(\n\"%d\"\n,&m)){\n        \nprintf\n(\n\"%d\\n\"\n,sum[m]);\n    }\n    \nreturn\n \n0\n;\n\n}\n\n我觉得时间应该花的差不多呀，怎么提交结果的时候，上面的代码还时间超限了。\n", "Tag": "算法分析"}
{"Answer": "```\r\n \\#include \r\n#include \r\n#include \r\n\r\nstruct student{\r\n    char name[15];\r\n    char major[15];\r\n    int Eng_sco;\r\n    int cal_sco;\r\n    int c_sco;\r\n    int sum;\r\n};\r\nint tx_per=0,tx_ave,tx_sum=0;\r\nint wl_per=0,wl_ave,wl_sum=0;\r\nint wlw_per=0,wlw_ave,wlw_sum=0;\r\nint ReadStudentInfo(const char* filename, struct student** pStudents);\r\nvoid Count(struct student pStudents[], int num);\r\nint main()\r\n{\r\n\t\r\n    int count;\r\n    int m;\r\n    struct student *list;\r\n    count=ReadStudentInfo(\"stu.txt\", &list);\r\n    printf(\"学生信息： \\n\");\r\n    printf(\"----------------------------------------------------\\n\");\r\n    printf(\"序号  姓名  专业名称  英语成绩   线性代数成绩    c语言成绩   总成绩\\n\");\r\n    for(m=1;m<=count;m++)\r\n    {\r\n        printf(\"%4d %6s %6s %4d %4d %4d %4d\\n\",m,(list+m-1)->name,(list+m-1)->major,(list+m-1)->Eng_sco,(list+m-1)->cal_sco,(list+m-1)->c_sco,(list+m-1)->sum);\r\n    }\r\n    Count(list, count);\r\n    printf(\"\\n统计信息 ：\\n\");\r\n    printf(\"----------------------------------------------------\\n\");\r\n    printf(\"序号  专业名称 学生人数 平均成绩\\n\");\r\n    printf(\"   1    通信      %d       %d\\n\",tx_per,tx_ave);\r\n    printf(\"   2    网络      %d       %d\\n\",wl_per,wl_ave);\r\n    printf(\"   3   物联网     %d       %d\\n\",wlw_per,wlw_ave);\r\n\t\r\n    return 0;\r\n}\r\nvoid CutString(char* buf,char*temp,char sp);\r\nint ReadStudentInfo(const char* filename, struct student** pStudents)\r\n{\r\n    FILE *fp;\r\n    char ch;\r\n    int i=1,j;\r\n    fp=fopen(filename,\"r\");\r\n    if(fp==NULL)\r\n    {\r\n        printf(\"cann't open the file\");\r\n        exit(-1);\r\n    }\r\n    ch=fgetc(fp);\r\n    while(ch!=EOF)\r\n    {\r\n        if(ch=='\\n')\r\n        {\r\n            i++;\r\n        }\r\n        ch=fgetc(fp);\r\n    }\r\n    rewind(fp);\r\n\t*pStudents=(struct student*)malloc(sizeof(** pStudents)*i);\r\n\r\n\tchar buf[512]={0};\r\n    for(j=0;jname,' ');\r\n\t\tCutString(buf,(*pStudents+j)->major,' ');\r\n\t\tchar e_Score[8],cal_Score[8],c_Score[8];\r\n\r\n\t\tmemset(e_Score,0,8);\r\n\t\tmemset(cal_Score,0,8);\r\n\t\tmemset(c_Score,0,8);\r\n\t\tCutString(buf,e_Score,' ');\r\n\t\t(*pStudents+j)->Eng_sco = atoi(e_Score);\r\n\t\tCutString(buf,cal_Score,' ');\r\n\t\t(*pStudents+j)->cal_sco = atoi(cal_Score);\r\n\t\tCutString(buf,c_Score,' ');\r\n\t\t(*pStudents+j)->c_sco = atoi(c_Score);\r\n\t\t(*pStudents+j)->sum=((*pStudents+j)->Eng_sco+(*pStudents+j)->cal_sco+(*pStudents+j)->c_sco);\r\n    }\r\n    fclose(fp);\r\n    return i;\r\n}\r\n\r\nvoid CutString(char* buf,char*temp,char sp)\r\n{\r\n\tint len = strlen(buf);\r\n\tfor (int i=0;imajor,\"通信\"))\r\n        {\r\n            tx_per++;\r\n            tx_sum=tx_sum+(pStudents+n-1)->sum;\r\n\t\t\ttx_ave=tx_sum/tx_per;\r\n        }\r\n        if(!strcmp((pStudents+n-1)->major,\"网络\"))\r\n        {\r\n            wl_per++;\r\n            wl_sum=wl_sum+(pStudents+n-1)->sum;\r\n\t\t\twl_ave=wl_sum/wl_per;\r\n        }\r\n        if(!strcmp((pStudents+n-1)->major,\"物联网\"))\r\n        {\r\n            wlw_per++;\r\n            wlw_sum=wlw_sum+(pStudents+n-1)->sum;\r\n\t\t\twlw_ave=wlw_sum/wlw_per;\r\n        }    \r\n    }\r\n    free(pStudents);\r\n}\r\n\r\n\r\n```\r\n闲来无事，改了一把， 拿过去跑一把吧", "Konwledge_Point": "线性规划简介", "Question": "关于c语言从文件中读取学生信息，处理并打印\n\nb)  建议函数流程：\n\ni.  打开数据文件，失败返回-1；\n\nii. 从头到尾扫描数据文件（即预读一遍）获得学生人数；\n\niii.    根据学生人数，利用malloc和sizeof等函数或运算符为struct student** pStudents分配内存；\n\niv. 利用rewind函数，定位到文件头；\n\nv.  读取数据文件，并把每一条记录通过数组下标法或指针法保存到结构体数组pStudents中；\n\nvi. 关闭文件；\n\nvii.    返回学生人数。\n\n\n\nc)  数据文件格式说明：\n\n一行一条学生信息的记录，不同属性用空格隔开，输入数据中无总成绩记录，例如：\n\n张三 通信 89 93 95\n\n李四 网络 88 91 94\n\n王五 物联网 71 94 88\n\n\n\n\n\n编写统计函数：\n\na)  函数定义void Count(struct student pStudents[], int num)。输入参数分别为保存学生的结构体数组和学生人数。\n\nb)  功能为：统计所有学生的总成绩和每个专业（假定一共三个专业：通信，网络，物联网）的平均成绩；输入参数包括学生信息结构体数组，学生人数，返回的每个学生的总成绩直接填充到对应的输入结构体数组对应字段中。统计信息包括三个专业的总人数、平均成绩数组，用全局变量来表示。访问每个学生信息的时候，用指针来指向当前正在处理的学生。\n\nc)  设计一个或者三个带参数的宏，判断输入的字符串是否是指定的专业名称，并在函数Count中使用。\n\n\n编写main函数实现：\n\na)  定义变量，其中保存学生信息的数据文件直接在源代码中初始化；\n\nb)  读取学生信息，如果失败，打印失败信息并退出程序；\n\nc)  统计学生信息；\n\nd)  输出统计信息。\n\ne)  释放内存。\n\n\n#include \n#include \n#include \n\nstruct student{\n    char name[15];\n    char major[15];\n    int Eng_sco;\n    int cal_sco;\n    int c_sco;\n    int sum;\n};\nint tx_per=0,tx_ave,tx_sum=0;\nint wl_per=0,wl_ave,wl_sum=0;\nint wlw_per=0,wlw_ave,wlw_sum=0;\nint ReadStudentInfo(const char* filename, struct student** pStudents);\nvoid Count(struct student pStudents[], int num);\nint main()\n{\n\n    int count;\n    int m;\n    struct student *list;\n    count=ReadStudentInfo(\"readme.txt\", &list);\n    printf(\"学生信息： \\n\");\n    printf(\"----------------------------------------------------\\n\");\n    printf(\"序号  姓 名  专业名称 英语成绩 线性代数成绩 c语言成绩 总成绩\\n\");\n    for(m=1;m<=count;m++)\n    {\n        printf(\"%4d %s %s %4d %4d %4d %4d\\n\",m,(list+m-1)->name,(list+m-1)->major,(list+m-1)->Eng_sco,(list+m-1)->cal_sco,(list+m-1)->c_sco,(list+m-1)->sum);\n    }\n    Count(list, count);\n    printf(\"\\n统计信息 ：\\n\");\n    printf(\"----------------------------------------------------\\n\");\n    printf(\"序号  专业名称 学生人数 平均成绩\\n\");\n    printf(\"   1    通信      %d       %d\\n\",tx_per,tx_ave);\n    printf(\"   2    网络      %d       %d\\n\",wl_per,wl_ave);\n    printf(\"   3   物联网     %d       %d\\n\",wlw_per,wlw_ave);\n\n    return 0;\n}\nint ReadStudentInfo(const char* filename, struct student** pStudents)\n{\n    FILE *fp;\n    char ch;\n    int i=1,j;\n    fp=fopen(readme.txt,\"r\");\n    if(fp==NULL)\n    {\n        printf(\"cann't open the file\");\n        exit(-1);\n    }\n    ch=fgetc(fp);\n    while(ch!=EOF)\n    {\n        if(ch=='\\n')\n        {\n            i++;\n        }\n        ch=fgetc(fp);\n    }\n    rewind(fp);\n     *pStudents=(struct student*)malloc(sizeof(** pStudents)*i);\n    for(j=0;jsum=((*pStudents+j)->Eng_sco+(*pStudents+j)->cal_sco+(*pStudents+j)->c_sco);\n    }\n    fclose(fp);\n    return i;\n}\nvoid Count(struct student pStudents[], int num)\n{\n    int n=1;\n    for(n=1;n<=num;n++)\n    {\n        if(!strcmp((pStudents+n-1)->major,\"通信\"))\n        {\n            tx_per++;\n            tx_sum=tx_sum+(pStudents+n-1)->sum;\n        }\n        if(!strcmp((pStudents+n-1)->major,\"网络\"))\n        {\n            wl_per++;\n            wl_sum=wl_sum+(pStudents+n-1)->sum;\n        }\n        if(!strcmp((pStudents+n-1)->major,\"物联网\"))\n        {\n            wlw_per++;\n            wlw_sum=wlw_sum+(pStudents+n-1)->sum;\n        }\n        tx_ave=tx_sum/tx_per;\n        wl_ave=wl_sum/wl_per;\n        wlw_ave=wlw_sum/wlw_per;\n    }\n    free(pStudents);\n}\n\n\n\n\n\n运行不起来，是哪里出问题了？", "Tag": "算法分析"}
{"Answer": "下面函数定义和上面的声明对不上上面写的是creat_L,下面只剩creat了将下面函数声明时的函数名改为creat_L即可有帮助望采纳~", "Konwledge_Point": "线性规划简介", "Question": "C语言代码打完后出现两个错误，不知是哪出错，求解答！\n1.未命名1.cpp:(.text+0xaf): undefined reference to `creat_L()'\n2.ld returned 1 exit status\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\ntypedef\n \nint\n ElemType;\n\ntypedef\n \nstruct\n \nLNode\n \n {ElemType data;\n  \nstruct\n \nLNode\n * next;\n } LNode;\nLNode * L;\n\nLNode * \ncreat_L\n()\n;\n\nvoid\n \nout_L\n(LNode * L)\n;\n\nvoid\n \ninsert_L\n(LNode * L,\nint\n i,ElemType e)\n;\n\nElemType \ndelete_L\n(LNode * L,\nint\n i)\n;\n\nint\n \nlocat_L\n(LNode * L,ElemType e)\n;\n\nmain\n()\n{\n \nint\n i,k,loc; ElemType e,x; \nchar\n ch;\n    \ndo\n{\nprintf\n(\n\"\\n\\n\\n\"\n);\n        \nprintf\n(\n\"\\n\\n 1.建立线性链表\"\n);\n        \nprintf\n(\n\"\\n\\n 2.在i位置插入元素e\"\n);\n        \nprintf\n(\n\"\\n\\n 3.删除第i个元素，返回其值\"\n); \n        \nprintf\n(\n\"\\n\\n 4.查找值为e的元素\"\n);\n        \nprintf\n(\n\"\\n\\n 5.结束程序运行\"\n);\n        \nprintf\n(\n\"\\n============================\"\n);\n        \nprintf\n(\n\"\\n  请输入您的选择（1,2,3,4,5）\"\n); \nscanf\n(\n\"%d\"\n,&k);\n        \nswitch\n(k)\n        {\ncase\n \n1\n:{  L=\ncreat_L\n();  \nout_L\n(L);\n                }\nbreak\n;\n         \ncase\n \n2\n:{\nprintf\n(\n\"\\n i,e=?\"\n);\nscanf\n(\n\"%d,%d\"\n,&i,&e);\n                  \ninsert_L\n(L,i,e);    \nout_L\n(L);    \n                 }\nbreak\n;    \n         \ncase\n \n3\n:{\nprintf\n(\n\"\\n i=?\"\n); \nscanf\n(\n\"%d\"\n,&i);\n                 x=\ndelete_L\n(L,i);    \nout_L\n(L);\n                 \nif\n(x!=\n-1\n) \nprintf\n(\n\"\\n x=%d\\n\"\n,x);\n                 }\nbreak\n;\n         \ncase\n \n4\n:{ \nprintf\n(\n\"\\n e=?\"\n); \nscanf\n(\n\"%d\"\n,&e);\n                 loc=\nlocat_L\n(L,e);\n                 \nif\n (loc=\n-1\n) \nprintf\n(\n\"\\n未找到%d\"\n,loc);\n                 \nelse\n \nprintf\n(\n\"\\n已找到，元素位置是%d\"\n,loc);             \n                 }\nbreak\n;\n        } \n        \nprintf\n(\n\"\\n----------------------\"\n);\n    }\nwhile\n(k>=\n1\n && k<\n5\n);\n    \nprintf\n(\n\"\\n      再见\"\n);\n    \nprintf\n(\n\"\\n     按Enter键，返回.\"\n);ch=\ngetch\n();     \n}\n\nLNode * \ncreat\n()\n\n\n{LNode * h,* p,* s; ElemType x;\n h=(LNode * )\nmalloc\n(\nsizeof\n(LNode));\n h->next=\nNULL\n;\n p=h;\n \nprintf\n(\n\"\\n data=?\"\n); \nscanf\n(\n\"%d\"\n,&x);\n \nwhile\n(x!=\n-111\n)\n     {s=(LNode * )\nmalloc\n(\nsizeof\n(LNode));\n      s->data=x; s->next=\nNULL\n;\n      p->next=s; p=s;\n      \nprintf\n(\n\"data=?(-111 end)\"\n); \nscanf\n(\n\"%d\"\n,&x);\n     }\n     \nreturn\n(h);    \n}\n\n\nvoid\n \nout_L\n(LNode * L)\n\n\n{LNode * p;\nchar\n ch;\n p=L->next;  \nprintf\n(\n\"\\n\\n\"\n);\n \nwhile\n(p!=\nNULL\n) { \nprintf\n(\n\"%5d\"\n,p->data); p=p->next;\n                 };\n\nprintf\n(\n\"\\n\\n 按Enter键,继续.\"\n); ch=\ngetch\n(); \n} \n\nvoid\n \ninsert_L\n(LNode * L,\nint\n i,ElemType e)\n\n\n{LNode *s,*p,*q; \nint\n j;\n p=L;\n j=\n0\n;\n \nwhile\n(p!=\nNULL\n && jnext;j++;}\n \nif\n(p==\nNULL\n || j>i\n-1\n) \nprintf\n (\n\"\\n i ERROR !\"\n);\n \nelse\n{ s=(LNode * )\nmalloc\n(\nsizeof\n(LNode));\n         s->data=e;\n         s->next=p->next;\n         p->next=s;\n    }     \n}\n\nElemType \ndelete_L\n(LNode * L,\nint\n i)\n\n\n{LNode * p,* q;\nint\n j;ElemType x;\n    p=L;j=\n0\n;\n    \nwhile\n(p->next!=\nNULL\n && jnext;j++;}\n    \nif\n(p->next==\nNULL\n) {\nprintf\n(\n\"\\n i ERROR !\"\n);\nreturn\n(\n-1\n);}\n        \nelse\n{q=p->next;x=q->data;\n             p->next=q->next; \nfree\n(q);\n             \nreturn\n(x);\n        }\n}\n\nint\n \nlocat_L\n(LNode * L,ElemType e)\n\n\n{LNode * p;\nint\n j=\n1\n;\n  p=L->next;\n  \nwhile\n(p!=\nNULL\n && p->data!=e){p=p->next; j++; }\n  \nif\n(p!=\nNULL\n)\nreturn\n(j);\nelse\n \nreturn\n(\n-1\n); \n}\n\n", "Tag": "算法分析"}
{"Answer": "SELECT S.sn,MAX(g)\nFROM S,C\n\n还是用了关联查询，而且没加上on ", "Konwledge_Point": "线性规划简介", "Question": "怎样把不嵌套mysql语言改成嵌套的\n\n\n\n\nCREATE TABLE S (\n  sno   INT NOT NULL PRIMARY KEY,\n  sn    CHAR(20) NOT NULL,\n  sex    CHAR(8),\n  dep    INT\n);\n\n\nCREATE TABLE C (\n  cno   INT NOT NULL,\n  cn    CHAR(20),\n  tno   INT NOT NULL,\n  credit    INT,\n  PRIMARY KEY(cno,tno)\n);\n\n\nCREATE TABLE SC (\n  sno   INT NOT NULL,\n  cno   INT NOT NULL,\n  g     INT,\n  PRIMARY KEY(sno,cno)\n);\n\n\nCREATE TABLE Teacher (\n  tno   INT NOT NULL PRIMARY KEY,\n  tn    CHAR(8) NOT NULL,\n  dep    INT\n);\n\n\nCREATE TABLE Dept (\n  dep   INT NOT NULL PRIMARY KEY,\n  dn   CHAR(20) NOT NULL\n);\n\n\nALTER TABLE S ADD age SMALLINT;\nALTER TABLE S MODIFY age INT; \n\n\nINSERT INTO S VALUES\n(1001,'喵喵','m',10,20),\n(1002,'汪汪','f',10,21),\n(1003,'咩咩','m',10,21),\n(1004,'哞哞','f',20,21),\n(1005,'呱呱','m',20,22),\n(1006,'嘎嘎','f',20,22),\n(1007,'咕咕哒','f',30,20),\n(1008,'西西','m',30,20),\n(1009,'哈哈','f',40,21),\n(1010,'张三','m',50,19),\n(1011,'李四','f',30,20),\n(1012,'王五', 'm',50,20),\n(1013,'马六','f',40,18),\n(1014,'伏七','m',20,20),\n(1015,'邢八','f',10,20),\n(1016,'刘九','m',20,21),\n(1017,'邹十','f',30,22),\n(1018,'吕十一','m',40,19),\n(1019,'吴十二','f',50,18),\n(1020,'陈十三','m',50,19),\n(1021,'姚十四','m',30,19);\n\n\nINSERT INTO C VALUES\n(1,'数据结构',101,4),\n(2,'数据库',102,4),\n(3,'离散数学',103,4),\n(4,'C语言程序设计',104,2),\n(5,'高等量子力学',105,3),\n(6,'高等数学',106,6),\n(7,'线性代数',107,4),\n(8,'管理统计学',108,4),\n(9,'财务管理学',109,3),\n(10,'商务智能',100,4);\n\n\nINSERT INTO SC VALUES\n(1001,1,80),\n(1001,2,85),\n(1001,3,78),\n(1002,1,72),\n(1002,2,82),\n(1002,3,86),\n(1003,1,92),\n(1003,3,90),\n(1004,1,87),\n(1004,4,90),\n(1005,1,85),\n(1005,4,92),\n(1006,5,99),\n(1006,2,100),\n(1007,1,80),\n(1007,3,91),\n(1008,7,82),\n(1008,3,59),\n(1009,10,73),\n(1009,9,78),\n(1010,1,92),\n(1010,3,87),\n(1011,10,85),\n(1011,6,88),\n(1012,6,90),\n(1012,8,76),\n(1013,10,59),\n(1013,7,95),\n(1014,6,79),\n(1014,10,97),\n(1015,8,66),\n(1015,3,70),\n(1016,4,69),\n(1016,5,85),\n(1017,10,97),\n(1017,9,96),\n(1018,7,83),\n(1018,5,86),\n(1019,4,90),\n(1019,10,78),\n(1020,9,84),\n(1020,1,99),\n(1021,3,77),\n(1021,7,88);\nINSERT INTO Teacher VALUES\n(101,'张小天',10),\n(102,'胡小伟',10),\n(103,'黄程',10),\n(104,'郭冰',20),\n(105,'钱祺',30),\n(106,'邢文',20),\n(107,'王笑',50),\n(108,'周思',40),\n(109,'庞锦',50),\n(100,'李想',30);\n\n\nINSERT INTO Dept VALUES\n(10,'计算机'),\n(20,'经管'),\n(30,'物理'),\n(40,'广告'),\n(50,'音录');\n\n\nSELECT S.sn,MAX(g)\nFROM S,SC\nWHERE S.sno = SC.sno\nGROUP BY cno;\n\n\n\n\n如果用嵌套结构\n\nSELECT\n S.sn,MAX(g)\n\nFROM\n S,C\n\nWHERE\n S.sno \nIN\n(\n          \nSELECT\n SC.sno\n          \nFROM\n SC\n          \nWHERE\n SC.cno=C.cno)\n\nGROUP\n \nBY\n C.cno\n\n![img](https://img-mid.csdnimg.cn/\nrelease\n/static/image/mid/ask/\n122304252666135.\npng \"#left\")\n\n\n\n\n写出来的就是错的，该怎么改成正确的嵌套结构\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "RecyclerView可以完成你的需求\r\n```\r\n @Override\r\n\tprotected void onCreate(Bundle savedInstanceState) {\r\n\t\tsuper.onCreate(savedInstanceState);\r\n\r\n\t\tMyScrollView rootView = new MyScrollView(this);\r\n\t\trootView.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));\r\n\r\n\t\tHorizontalScrollView horizontalScrollView = new HorizontalScrollView(this);\r\n\t\thorizontalScrollView.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));\r\n\r\n\t\tRecyclerView recyclerView = new RecyclerView(this){\r\n\t\t\t@Override\r\n\t\t\tprotected void onMeasure(int widthSpec, int heightSpec) {\r\n\t\t\t\tint expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE >> 2,\r\n\t\t\t\t\t\tMeasureSpec.AT_MOST);\r\n\t\t\t\tsuper.onMeasure(widthSpec, expandSpec);\r\n\t\t\t}\r\n\t\t};\r\n\t\trecyclerView.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.VERTICAL,false));\r\n\r\n\r\n\t\trecyclerView.setAdapter(new MyAdapter());\r\n\r\n\r\n\t\thorizontalScrollView.addView(recyclerView);\r\n\t\trootView.addView(horizontalScrollView);\r\n\t\tsetContentView(rootView);\r\n\r\n\t}\r\n\r\n\tclass MyAdapter extends RecyclerView.Adapter {\r\n\t\tprivate int size=50;\r\n\t\t@Override\r\n\t\tpublic RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\r\n\t\t\tView view = LayoutInflater.from(TestActivity.this).inflate(R.layout.activity_test, parent, false);\r\n\t\t\tTextView name = (TextView) view.findViewById(R.id.ct2r_1);\r\n\t\t\tview.setTag(name);\r\n\t\t\treturn new RecyclerView.ViewHolder(view) {};\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {\r\n\t\t\tif (getItemViewType(position) ==1)\r\n\t\t\t((TextView)holder.itemView.getTag()).setText(\"这是第 \"+ position);\r\n\t\t\telse {\r\n\t\t\t\t((TextView) holder.itemView.getTag()).setText(\"这是第 \" + position / 10 + \"页\");\r\n\t\t\t\tholder.itemView.setBackgroundColor(Color.BLUE);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic int getItemViewType(int position) {\r\n\t\t\treturn (position == 0 || position % 10 !=0) ? 1:2;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic int getItemCount() {\r\n\t\t\tint num = size / 10;\r\n\t\t\treturn size+num;\r\n\t\t}\r\n\t}\r\n\t\r\n\tclass MyScrollView extends ScrollView {\r\n\r\n    private int downY;\r\n    private int mTouchSlop;\r\n\r\n    public MyScrollView(Context context) {\r\n        super(context);\r\n        mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();\r\n    }\r\n\r\n    public MyScrollView(Context context, AttributeSet attrs) {\r\n        super(context, attrs);\r\n        mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();\r\n    }\r\n\r\n    public MyScrollView(Context context, AttributeSet attrs, int defStyleAttr) {\r\n        super(context, attrs, defStyleAttr);\r\n        mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();\r\n    }\r\n\r\n    @Override\r\n    public boolean onInterceptTouchEvent(MotionEvent e) {\r\n        int action = e.getAction();\r\n        switch (action) {\r\n            case MotionEvent.ACTION_DOWN:\r\n                downY = (int) e.getRawY();\r\n                break;\r\n            case MotionEvent.ACTION_MOVE:\r\n                int moveY = (int) e.getRawY();\r\n                if (Math.abs(moveY - downY) > mTouchSlop) {\r\n                    return true;\r\n                }\r\n        }\r\n        return super.onInterceptTouchEvent(e);\r\n    }\r\n}\r\n```", "Konwledge_Point": "线性规划简介", "Question": "Android 客户端 TextView表格分页显示数据\n由于接口里面最多有100行数据（可能少于100），显示数据的xml布局文件是在线性布局下面定义了TextView\n\n,不是用的ListView，现在表格里面能显示100行数据出来，现在想在手机上面每个页面显示\n\n10行数据，下面要有页码显示最好，求大神给我指点，本人实在太菜，下面是表格的布局文件,只定义了一行,在代码里面动态添加的，本人QQ：1194660702，帮我解决这个\n\n问题，本人发大红包\n\n\n\n\n\n              android:id=\"@+id/ct2r_root\"\n\n              android:layout_width=\"fill_parent\"\n\n              android:layout_height=\"wrap_content\"\n\n              android:background=\"#FFEEEEEE\"\n\n              android:orientation=\"vertical\"\n\n              android:padding=\"1px\"\n\n    >\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "官方pretrain的模型数据集是imagenet，样本数是你这个数据集的很多倍，这样的vgg网络卷积层的参数基本收敛到比较好的一个情况，你直接用来finetune只要稍微微调一下最后的fc层就可以得到一个比较好的分类结果了。相比于你自己从0训练网络，你的网络见过的数据比较少，容易过拟合在见到过的数据上，因此你自己从0训练的效果远远不如加载pretrain然后finetune的效果。", "Konwledge_Point": "线性规划简介", "Question": "为什么在pytorch中使用VGG16不用预训练，自己从头训练猫狗分类，正确率只有74%就上不去了？\n这是我的代码。请大家过目。\n而且我在用训练好的pth模型进行单独测试时总会是第0类正确率很高（也就是猫的识别率很高 狗的识别率很低）\n测试集猫狗各500张，猫能识别出400多张而狗只能识别出十几张。\n不知道问题出在哪里？\n训练的loss会一直降，但是验真loss从0.7降到0.6，就趋于平滑，不再下降。\n我试了调整学习率，但是没用。\n\n\n\n\nimport\n math\nfrom torch \nimport\n nn\nfrom torchvision \nimport\n models,datasets,transforms\n\nimport\n torch\n\nimport\n os\nfrom torch.autograd \nimport\n Variable\n\nimport\n csv\n\n#import visdom\n\n\n\n\n#viz = visdom.Visdom()\n\ndata_dir = 'VGGTrain'\ndata_transform = {\n    '\ntrain'\n:transforms\n.Compose\n([transforms\n.Resize\n((224, 224)),\n                          transforms\n.ToTensor\n(),\n                          transforms\n.Normalize\n([0.485,0.456,0.406], [0.229,0.224,0.225]),\n                          transforms\n.RandomHorizontalFlip\n(p=0.5),#水平翻转\n                          transforms\n.RandomRotation\n(15),  # 随机旋转\n                          transforms\n.RandomCrop\n(224),  #随机剪裁\n                          transforms\n.Pad\n(padding=4, padding_mode='edge'),#边缘填充\n                          ]),\n        'valid':transforms\n.Compose\n([transforms\n.Resize\n((224, 224)),\n                          transforms\n.ToTensor\n(),\n                          transforms\n.Normalize\n([0.485,0.456,0.406], [0.229,0.224,0.225])\n                          ])\n}\n\nimage_datasets = {x:datasets\n.ImageFolder\n(root=os\n.path\n.join\n(data_dir, x), transform=data_transform[x])\n                    for x in ['train','valid']\n                    }\n\ndataloader = {x:torch\n.utils\n.data\n.DataLoader\n(dataset=image_datasets[x], batch_size=32, shuffle=True, num_workers=4)\n              for x in ['train','valid']\n}\n\nx_example, y_example = next(iter(dataloader['train']))\n\nexample_classes = image_datasets['train']\n.classes\n\n\nindex_classes = image_datasets['train']\n.class_to_idx\n\n\n\nmodel = models\n.vgg\n16(pretrained=False)\n\n\n# 遍历模型中的所有模块\nfor m in model\n.modules\n():\n    # 如果当前模块是卷积层或者线性层\n    if isinstance(m, nn\n.Conv\n2d):\n        #则进行xavier初始化\n        nn\n.init\n.kaiming_normal_\n(m\n.weight\n, mode='fan_out', nonlinearity='relu')\n        if m\n.bias\n is not None:\n            nn\n.init\n.constant_\n(m\n.bias\n, 0)\n    elif isinstance(m, nn\n.BatchNorm\n2d):\n        nn\n.init\n.constant_\n(m\n.weight\n, 1)\n        nn\n.init\n.constant_\n(m\n.bias\n, 0)\n    elif isinstance(m, nn\n.Linear\n):\n        nn\n.init\n.normal_\n(m\n.weight\n, 0, 0.01)\n        nn\n.init\n.constant_\n(m\n.bias\n, 0)\n\n\nmodel\n.classifier\n = torch\n.nn\n.Sequential\n(\n    torch\n.nn\n.Linear\n(25088,512),\n    torch\n.nn\n.ReLU\n(),\n    torch\n.nn\n.Dropout\n(p=0.6),\n    torch\n.nn\n.Linear\n(512,256),\n    torch\n.nn\n.ReLU\n(),\n    torch\n.nn\n.Dropout\n(p=0.6),\n    torch\n.nn\n.Linear\n(256,2)\n)\n\n\nuse_gpu = torch\n.cuda\n.is_available\n()\nif use_gpu :\n    model = model\n.cuda\n()\n\n\nloss_f = torch\n.nn\n.CrossEntropyLoss\n()\noptimizer = torch\n.optim\n.Adam\n(model\n.classifier\n.parameters\n(), lr=1e-4,weight_decay=0.01)\n\nepochs = 99999\n\n\n#viz\n.line\n([0], [-1], win='loss', opts=dict(title='loss'))\n#viz\n.line\n([0], [-1], win='val_acc', opts=dict(title='val_acc'))\nglobal_step = 0\nbest_acc = 0\nbest_epoch = 0\n\nwith open(\"loss2\n.txt\n\", \"w\") as f:\n    for epoch in range(epochs):\n\n        print('----' * 10)\n        print('Epoch {}/{}'\n.format\n(epoch + 1, epochs))\n\n        for phase in ['train', 'valid']:\n            if phase == 'train':\n                print('Training...')\n                model\n.train\n(True)\n\n            else:\n                print('Validing...')\n                model\n.train\n(False)\n\n            running_loss = 0.0\n            running_corrects = 0\n\n            for batch, data in enumerate(dataloader[phase]):\n\n                x, y = data\n                x, y = Variable(x\n.cuda\n()), Variable(y\n.cuda\n())\n\n                y_pred = model(x)\n\n                _, pred = torch\n.max\n(y_pred\n.data\n, 1)\n                optimizer\n.zero_grad\n()\n\n\n                loss = loss_f(y_pred, y)\n\n                running_loss += loss\n.data\n\n                if phase == 'train':\n                    global_step += 1\n                    loss\n.backward\n()\n                    optimizer\n.step\n()\n\n                running_corrects += torch\n.sum\n(pred == y\n.data\n)\n                    \n\n            epoch_loss = running_loss * 32 / len(image_datasets[phase])\n            epoch_acc = 100 * running_corrects / len(image_datasets[phase])\n\n            print('{} Loss:{} ACC:{}'\n.format\n(phase, epoch_loss, epoch_acc))\n            if(phase == 'train'):\n                f\n.writelines\n([str(epoch), ',', str(epoch_loss\n.item\n()),',',str(epoch_acc\n.item\n()), ','])\n                \n            if(phase == 'valid'):\n                f\n.writelines\n([str(epoch_acc\n.item\n()),',',str(epoch_loss\n.item\n()), ';'])\n                \nf.flush()\n                if epoch_acc.item() > best_acc\n:\n                    torch\n.save\n(model, 'best3\n.pth\n')\n                    best_acc = epoch_acc\n.item\n()\n                    best_epoch = epoch\n                    print('最好的正确率是epoch：', best_epoch+1, '    正确率为：', best_acc)\n\n\nprint('最好的模型在epoch：', best_epoch)\ntorch\n.save\n(model, 'vggmodel2\n.pth\n')\n\n\n", "Tag": "算法分析"}
{"Answer": "参考GPT和自己的思路，该异常java.util.ConcurrentModificationException表示在迭代列表时，另一个线程修改了该列表，导致迭代器失效。在你的代码中没有明显的多线程，所以可能是因为在迭代mFruitList时在另一个地方修改了mFruitList。可能的原因是你在使用mFruitList的同时，在另一个线程中对mFruitList进行了修改。可以尝试在对mFruitList进行迭代的时候对其进行同步，以防止其他线程同时对其进行修改，如下所示：\nList<MyFruit> mFruitList = new ArrayList<MyFruit>();\nMySQLiteOpenHelper mySQLiteOpenHelper=new MySQLiteOpenHelper(this,DB_NAME,null,1);\nSQLiteDatabase sqLiteDatabase=mySQLiteOpenHelper.getWritableDatabase();\nCursor cursor=sqLiteDatabase.query(DB_TABLE,null,null,null,null,null,\"_id DESC\");\n\nsynchronized (mFruitList) { // 同步块\n    while (cursor.moveToNext()){                   \n        String _id = cursor.getString(cursor.getColumnIndexOrThrow(\"_id\"));\n        String khmc = cursor.getString(cursor.getColumnIndexOrThrow(\"khmc\"));\n        String gcmc=cursor.getString(cursor.getColumnIndexOrThrow(\"gcmc\"));\n        String sgbw=cursor.getString(cursor.getColumnIndexOrThrow(\"sgbw\"));\n        String ysrq=cursor.getString(cursor.getColumnIndexOrThrow(\"ysrq\"));\n        String qddj=cursor.getString(cursor.getColumnIndexOrThrow(\"qddj\"));\n        String ksdj=cursor.getString(cursor.getColumnIndexOrThrow(\"ksdj\"));\n        String bcfl=cursor.getString(cursor.getColumnIndexOrThrow(\"bcfl\"));\n        String ljfl=cursor.getString(cursor.getColumnIndexOrThrow(\"ljfl\"));\n        String ysch=cursor.getString(cursor.getColumnIndexOrThrow(\"ysch\"));\n        String jsy=cursor.getString(cursor.getColumnIndexOrThrow(\"jsy\"));\n\n        MyFruit bookStore=new MyFruit(_id,khmc,gcmc,sgbw,ysrq,qddj,ksdj,bcfl,ljfl,ysch,jsy);\n\n        mFruitList.add(bookStore);\n    }\n}\ncursor.close();\n\n另外，也可以尝试使用CopyOnWriteArrayList类代替ArrayList类，CopyOnWriteArrayList类是一个线程安全的ArrayList，当有修改操作时，它会创建一个新的副本来进行修改，而不会影响到迭代操作，从而避免了ConcurrentModificationException异常。", "Konwledge_Point": "线性规划简介", "Question": "android studio sqlite异常\njava.util.ConcurrentModificationException异常\njava.util.ConcurrentModificationException异常\n刚刚转战Android，花了一个星期弄了个东西，\n\n\n一直正常编译运行，买包烟回来就不能运行了，买烟之前都还好好的，\n有备份，运行备份也是一样\n求帮忙。\n\n\n\n\n\n\n\npublic\n \nclass\n \nMainActivity2\n \nextends\n \nAppCompatActivity\n {\n    DBAdapter dbAdapter;\n    TextView text;\n    FloatingActionButton fab;\n\n\n\n\n    \n@SuppressLint(\"MissingInflatedId\")\n\n    \n@Override\n\n    \nprotected\n \nvoid\n \nonCreate\n(Bundle savedInstanceState)\n {\n        \nsuper\n.onCreate(savedInstanceState);\n        supportRequestWindowFeature(Window.FEATURE_NO_TITLE);\n        setContentView(R.layout.activity_main2);\n        dbAdapter=\nnew\n \nDBAdapter\n(\nthis\n);\n        text = findViewById(R.id.textView);\n        fab = findViewById(R.id.floatingActionButton);\n        fab.setOnClickListener(\nnew\n \nView\n.OnClickListener() {\n            \n@Override\n\n            \npublic\n \nvoid\n \nonClick\n(View v)\n {\n//点击悬浮按钮跳转到添加界面\n\n                \nIntent\n \nintent\n \n=\n \nnew\n \nIntent\n(MainActivity2.\nthis\n,MainActivity.class);\n                startActivity(intent);\n\n            }\n        });\n\n        List mFruitList = \nnew\n \nArrayList\n();\n        MySQLiteOpenHelper mySQLiteOpenHelper=\nnew\n \nMySQLiteOpenHelper\n(\nthis\n,DB_NAME,\nnull\n,\n1\n);\n        SQLiteDatabase sqLiteDatabase=mySQLiteOpenHelper.getWritableDatabase();\n        Cursor cursor=sqLiteDatabase.query(DB_TABLE,\nnull\n,\nnull\n,\nnull\n,\nnull\n,\nnull\n,\n\"_id DESC\"\n);\n        \nwhile\n (cursor.moveToNext()){\n//报错行\n\n            \nString\n \n_id\n \n=\n cursor.getString(cursor.getColumnIndexOrThrow(\n\"_id\"\n));\n            \nString\n \nkhmc\n \n=\n cursor.getString(cursor.getColumnIndexOrThrow(\n\"khmc\"\n));\n            String gcmc=cursor.getString(cursor.getColumnIndexOrThrow(\n\"gcmc\"\n));\n            String sgbw=cursor.getString(cursor.getColumnIndexOrThrow(\n\"sgbw\"\n));\n            String ysrq=cursor.getString(cursor.getColumnIndexOrThrow(\n\"ysrq\"\n));\n            String qddj=cursor.getString(cursor.getColumnIndexOrThrow(\n\"qddj\"\n));\n            String ksdj=cursor.getString(cursor.getColumnIndexOrThrow(\n\"ksdj\"\n));\n            String bcfl=cursor.getString(cursor.getColumnIndexOrThrow(\n\"bcfl\"\n));\n            String ljfl=cursor.getString(cursor.getColumnIndexOrThrow(\n\"ljfl\"\n));\n            String ysch=cursor.getString(cursor.getColumnIndexOrThrow(\n\"ysch\"\n));\n            String jsy=cursor.getString(cursor.getColumnIndexOrThrow(\n\"jsy\"\n));\n\n            MyFruit bookStore=\nnew\n \nMyFruit\n(_id,khmc,gcmc,sgbw,ysrq,qddj,ksdj,bcfl,ljfl,ysch,jsy);\n            mFruitList.add(bookStore);\n\n        }\n        text.setText(\n\"总车数：\"\n+allCaseNum()+\n\"        \"\n+\n\"累计方量:\"\n+(\nint\n) getsumdebt()+\n\"M³\"\n);\n        cursor.close();\n\n        \n// 获取到 RecyclerView 实例\n\n        \nRecyclerView\n \nmRecyclerView\n \n=\n findViewById(R.id.test_rv);\n        \n// 创建 LinearLayoutManager 对象 ，即线性布局\n\n        \nLinearLayoutManager\n \nmManager\n \n=\n \nnew\n \nLinearLayoutManager\n(\nthis\n);\n\n        mRecyclerView.setLayoutManager(mManager);\n        \n// 创建自定义的 Adapter 实例\n\n        \nMyFruitAdapter\n \nmAdapter\n \n=\n \nnew\n \nMyFruitAdapter\n(mFruitList);\n        \n//进场动画\n\n        \nLayoutAnimationController\n \ncontroller\n \n=\n \nnew\n \nLayoutAnimationController\n(AnimationUtils.loadAnimation(\nthis\n,R.anim.my_anim));\n        mRecyclerView.setLayoutAnimation(controller);\n        \n// 设置适配器\n\n        mRecyclerView.setAdapter(mAdapter);\n        \n//itme 点击事件\n\n        mAdapter.setOnItemClick(\nnew\n \nMyFruitAdapter\n.OnItemClick() {\n            \n@Override\n\n            \npublic\n \nvoid\n \nonItemClick\n(\nint\n position)\n {\n                AlertDialog.\nBuilder\n \ndialog\n \n=\n \nnew\n \nAlertDialog\n.Builder(MainActivity2.\nthis\n);\n                dialog.setTitle(\n\"请选择操作：\"\n);\n                dialog.setIcon(R.drawable.icon);\n                dialog.setPositiveButton(\n\"修改\"\n,\n                        \nnew\n \nDialogInterface\n.OnClickListener() {\n                            \n@Override\n\n                            \npublic\n \nvoid\n \nonClick\n(DialogInterface dialog, \nint\n which)\n {\n                                \nIntent\n \nintent\n \n=\n \nnew\n \nIntent\n(MainActivity2.\nthis\n,Update.class);\n                                \nMyFruit\n \nmyFruit\n  \n=\n mFruitList.get(position);\n                                intent.putExtra(\n\"_id\"\n,myFruit.get_id());\n                                intent.putExtra(\n\"khmc\"\n,myFruit.getKhmc());\n                                intent.putExtra(\n\"gcmc\"\n,myFruit.getGcmc());\n                                intent.putExtra(\n\"sgbw\"\n,myFruit.getSgbw());\n                                intent.putExtra(\n\"ysrq\"\n,myFruit.getYsrq());\n                                intent.putExtra(\n\"qddj\"\n,myFruit.getQddj());\n                                intent.putExtra(\n\"ksdj\"\n,myFruit.getKsdj());\n                                intent.putExtra(\n\"bcfl\"\n,myFruit.getBcfl());\n                                intent.putExtra(\n\"ljfl\"\n,myFruit.getLjfl());\n                                intent.putExtra(\n\"ysch\"\n,myFruit.getYsch());\n                                intent.putExtra(\n\"jsy\"\n,myFruit.getJsy());\n                                startActivity(intent);\n                                }\n                            });\n                dialog.setNeutralButton(\n\"删除\"\n,\n                        \nnew\n \nDialogInterface\n.OnClickListener() {\n                            \n@Override\n\n                            \npublic\n \nvoid\n \nonClick\n(DialogInterface dialog, \nint\n which)\n {\n                                \nMyFruit\n \nmyFruit\n  \n=\n mFruitList.get(position);\n                                \nString\n \nid1\n \n=\n myFruit.get_id();\n                                \nboolean\n \nshanchu\n \n=\n deleteUser(id1);\n                                \nif\n (shanchu == \ntrue\n){\n                                    mFruitList.remove(position);\n                                    mAdapter.notifyItemRemoved(position);\n                                    mAdapter.notifyItemRangeChanged(position, mFruitList.size());\n                                    Toast.makeText(MainActivity2.\nthis\n,\n\"删除成功！\"\n,Toast.LENGTH_SHORT).show();\n\n                                }\nelse\n {Toast.makeText(MainActivity2.\nthis\n,\n\"删除失败！！！\"\n,Toast.LENGTH_SHORT).show();}\n                                    }\n                                });\n                dialog.setNegativeButton(\n\"复制\"\n, \nnew\n \nDialogInterface\n.OnClickListener() {\n                    \n@Override\n\n                    \npublic\n \nvoid\n \nonClick\n(DialogInterface dialog, \nint\n which)\n {\n                        \nIntent\n \nintent\n \n=\n \nnew\n \nIntent\n(MainActivity2.\nthis\n,Copyone.class);\n                        \nMyFruit\n \nmyFruit\n  \n=\n mFruitList.get(position);\n                        intent.putExtra(\n\"_id\"\n,myFruit.get_id());\n                        intent.putExtra(\n\"khmc\"\n,myFruit.getKhmc());\n                        intent.putExtra(\n\"gcmc\"\n,myFruit.getGcmc());\n                        intent.putExtra(\n\"sgbw\"\n,myFruit.getSgbw());\n                        intent.putExtra(\n\"ysrq\"\n,myFruit.getYsrq());\n                        intent.putExtra(\n\"qddj\"\n,myFruit.getQddj());\n                        intent.putExtra(\n\"ksdj\"\n,myFruit.getKsdj());\n                        intent.putExtra(\n\"bcfl\"\n,myFruit.getBcfl());\n                        intent.putExtra(\n\"ljfl\"\n,myFruit.getLjfl());\n                        intent.putExtra(\n\"ysch\"\n,myFruit.getYsch());\n                        intent.putExtra(\n\"jsy\"\n,myFruit.getJsy());\n                        startActivity(intent);\n\n                    }\n                });\n                dialog.create();\n                dialog.show();\n            }\n        });\n    }\n\n\n\n\n    \npublic\n \ndouble\n \ngetsumdebt\n()\n {\n//统计总方量\n\n        \nint\n \ntotal\n \n=\n \n0\n;\n        MySQLiteOpenHelper mySQLiteOpenHelper=\nnew\n \nMySQLiteOpenHelper\n(\nthis\n,DB_NAME,\nnull\n,\n1\n);\n        SQLiteDatabase sqLiteDatabase=mySQLiteOpenHelper.getWritableDatabase();\n        \nCursor\n \nmCursor\n \n=\n sqLiteDatabase.rawQuery(\n\" SELECT SUM(bcfl) FROM peopleinfo\"\n, \nnull\n);\n        \nif\n (mCursor.moveToFirst())\n        {\n            total = mCursor.getInt(\n0\n);\n        }\n        \nwhile\n (mCursor.moveToNext());\n        \nreturn\n total;\n    }\n    \n/**\n     * 查询数据库中的总条数.\n     */\n\n    \npublic\n \nlong\n \nallCaseNum\n( )\n{\n        MySQLiteOpenHelper mySQLiteOpenHelper=\nnew\n \nMySQLiteOpenHelper\n(MainActivity2.\nthis\n,DB_NAME,\nnull\n,\n1\n);\n        SQLiteDatabase sqLiteDatabase=mySQLiteOpenHelper.getWritableDatabase();\n        \nCursor\n \ncursor\n \n=\n sqLiteDatabase.rawQuery(\n\"select count(*) from \"\n+DB_TABLE, \nnull\n);\n        cursor.moveToFirst();\n        \nlong\n \ncount\n \n=\n cursor.getLong(\n0\n);\n        \nreturn\n count;\n    }\n    \npublic\n \nboolean\n \ndeleteUser\n(String  ID)\n{\n//删除方法\n\n\n        MySQLiteOpenHelper mySQLiteOpenHelper=\nnew\n \nMySQLiteOpenHelper\n(\nthis\n,DB_NAME,\nnull\n,\n1\n);\n        SQLiteDatabase sqLiteDatabase=mySQLiteOpenHelper.getWritableDatabase();\n        \nlong\n \nid\n \n=\n sqLiteDatabase.delete(DB_TABLE,KEY_ID+\n\"=\"\n+ID,\nnull\n);\n        sqLiteDatabase.close();\n        \nreturn\n id>\n0\n?\ntrue\n:\nfalse\n;\n\n    }\n    \npublic\n \nlong\n \nupdate\n \n(String id ,ContentValues updateValues)\n{\n\n        MySQLiteOpenHelper mySQLiteOpenHelper=\nnew\n \nMySQLiteOpenHelper\n(\nthis\n,DB_NAME,\nnull\n,\n1\n);\n        SQLiteDatabase sqLiteDatabase=mySQLiteOpenHelper.getWritableDatabase();\n        sqLiteDatabase.update(DB_TABLE,updateValues,KEY_ID+\n\"=\"\n+id,\nnull\n);\n        \nreturn\n \n0\n;\n    }\n\n}\n\n", "Tag": "算法分析"}
{"Answer": "# 已解决，原因：没处理好屏幕适配。深坑，谨记教训！！\r\n![图片说明](https://img-ask.csdn.net/upload/201703/27/1490578658_132734.png)", "Konwledge_Point": "线性规划简介", "Question": "android 两个页面都用recyclerview,一个正常，另一个报错\n第一个页面(没问题)\n\n\n\n     @BindView(R.id.title_tv)\n    TextView titleTv;\n    @BindView(R.id.recycler)\n    RecyclerView recyclerView;\n    @BindView(R.id.refresh)\n    SwipeRefreshLayout refreshLayout;\n    @BindView(R.id.no_details)\n    LinearLayout noDetails;\n    List transactionList = new ArrayList();\n    private TransactionListAdapter adapter;\n    private String token;\n    private int page = 1;\n        ....\n        protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_wallet_details);\n        ButterKnife.bind(this);\n\n        Intent intent = getIntent();\n        if(intent != null){\n            token = intent.getStringExtra(\"token\") != null ? intent.getStringExtra(\"token\") : \" \";\n        }\n        initTitle();\n        initView();\n        initData(token);\n    }\n        ....\n        private void initView() {\n        refreshLayout.setOnRefreshListener(this);\n        refreshLayout.setColorSchemeResources(android.R.color.holo_blue_bright,\n                android.R.color.holo_green_light,\n                android.R.color.holo_orange_light,\n                android.R.color.holo_red_light);\n        refreshLayout.setProgressBackgroundColor(R.color.refresh_bg);\n        initListView();\n    }\n\n    private void initListView() {\n        layoutManager = new LinearLayoutManager(this);\n        layoutManager.setOrientation(LinearLayoutManager.VERTICAL);\n        recyclerView.setLayoutManager(layoutManager);\n        adapter = new TransactionListAdapter(this, transactionList);\n        recyclerView.setAdapter(adapter);\n        recyclerView.setBackgroundColor(Color.WHITE);\n        // 第一次进入页面的时候显示加载进度条\n        refreshLayout.setProgressViewOffset(true, 0,\n                (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 24,\n                        getResources().getDisplayMetrics()));\n        refreshLayout.setRefreshing(true);\n        //滚动监听\n        recyclerView.setOnScrollListener(new RecyclerView.OnScrollListener() {\n            @Override\n            public void onScrollStateChanged(RecyclerView recyclerView, int newState) {\n                super.onScrollStateChanged(recyclerView, newState);\n                if (newState == RecyclerView.SCROLL_STATE_IDLE && lastVisibleItem + 1 == adapter.getItemCount()) {\n                    refreshLayout.setRefreshing(true);\n                    page++;\n                    if (page <= totalPage) { //根据后台接口   判断当前页是否小于总页\n                        L.e(\"pageNo:\" + page + \",totalPage:\" + totalPage);\n                        queryTransactionDetails(MywalletDetailActivity.this,token,page);\n                        showToast(getResources().getString(R.string.loading));\n                    } else {\n                        refreshLayout.setRefreshing(false);\n                        showToast(getString(R.string.no_more_data));\n                    }\n                }\n            }\n            @Override\n            public void onScrolled(RecyclerView recyclerView, int dx, int dy) {\n                super.onScrolled(recyclerView, dx, dy);\n                lastVisibleItem = layoutManager.findLastVisibleItemPosition();\n            }\n        });\n    }\n\n\n\n\n两个页面的xml文件都差不多：\n\n\n\n \n    ...\n    \n\n\n\n\n\n\n\n第二个页面：\n\n\n\n  @BindView(R.id.title_tv)\n    TextView titleTv;\n    @BindView(R.id.no_schedule_ll)\n    LinearLayout noScheduleLl;\n    @BindView(R.id.recycler)\n    RecyclerView recyclerView;\n    @BindView(R.id.refresh_myschedule)\n    SwipeRefreshLayout refreshLayout;\n        ...\n         @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_my_schedule);\n        ButterKnife.bind(this);\n\n        withRefreshView = setRefreshView();\n        intent = getIntent();\n        userid = intent.getStringExtra(\"userid\");\n        token = intent.getStringExtra(\"token\");\n        initView();\n        loadFromNet(token,pageNo);\n    }\n\n    /**\n     * 初始化控件\n     */\n    private void initView() {\n        titleTv.setText(getResources().getString(R.string.my_schedule));\n        needHelp.setVisibility(View.VISIBLE);\n        needHelp.setText(getResources().getString(R.string.need_help));\n\n        refreshLayout.setOnRefreshListener(this);\n\n        refreshLayout.setColorSchemeResources(android.R.color.holo_blue_bright,\n                android.R.color.holo_green_light,\n                android.R.color.holo_orange_light,\n                android.R.color.holo_red_light);\n        refreshLayout.setProgressBackgroundColor(R.color.refresh_bg);\n        refreshLayout.setRefreshing(true);\n        /*\n         *  第一次进入页面的时候显示加载进度条\n         */\n        refreshLayout.setProgressViewOffset(true, 0,\n                (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 24,\n                        getResources().getDisplayMetrics()));\n        refreshLayout.setRefreshing(true);\n        initListView();\n    }\n\n    private void initListView() {\n        recyclerView.setItemAnimator(new DefaultItemAnimator());//设置item动画\n        recyclerView.setHasFixedSize(true); //如果可以确定每个item的高度是固定的，设置这个选项可以提高性能\n        //创建默认的线性LayoutManage\n        layoutManager = new LinearLayoutManager(this);\n        layoutManager.setOrientation(LinearLayoutManager.VERTICAL);\n        recyclerView.setLayoutManager(layoutManager);\n        recyclerView.setBackgroundColor(Color.WHITE);\n        recyclerView.addItemDecoration(new MyDecoration(this, MyDecoration.VERTICAL_LIST));//自定义的分隔线\n\n        adapter = new ScheduleAdapter(this, scheduleList);\n        adapter.setOnItemClickListener(new ScheduleAdapter.OnItemClickListener() {\n            @Override\n            public void onItemClick(View view, int position) {\n                startActivity(new Intent(MyScheduleActivity.this, ShowWebViewActivity.class)\n                        .putExtra(\"title\",getResources().getString(R.string.riding_details_title))\n                        .putExtra(\"share\",getResources().getString(R.string.riding_details_share))\n                        .putExtra(\"url\", Url.getMyScheduleDetailUrl(true) + \"?token=\" + token +\"&id=\" + rideId));\n            }\n        });\n        adapter.setOnItemLongClickListener(new ScheduleAdapter.OnItemLongClickListener() {\n            @Override\n            public void onItemLongClick(View view, int position) {\n\n            }\n        });\n        recyclerView.setAdapter(adapter);\n\n        recyclerView.setOnScrollListener(new RecyclerView.OnScrollListener() {\n            @Override\n            public void onScrollStateChanged(RecyclerView recyclerView, int newState) {\n                super.onScrollStateChanged(recyclerView, newState);\n                if (newState == RecyclerView.SCROLL_STATE_IDLE && lastVisibleItem + 1 == adapter.getItemCount()) {\n                    refreshLayout.setRefreshing(true);\n                    pageNo++;\n                    if (pageNo <= totalPage) { //根据后台接口   判断当前页是否小于总页\n                        L.e(\"pageNo:\" + pageNo + \"newsTotalPage:\" + totalPage);\n                        loadFromNet(token, pageNo);\n                        showToast(getResources().getString(R.string.loading));\n                    } else {\n                        refreshLayout.setRefreshing(false);\n                        showToast(getString(R.string.no_more_data));\n                    }\n                }\n            }\n            @Override\n            public void onScrolled(RecyclerView recyclerView, int dx, int dy) {\n                super.onScrolled(recyclerView, dx, dy);\n                lastVisibleItem = layoutManager.findLastVisibleItemPosition();\n            }\n        });\n    }\n\n\n\n\n跳转到第一个页面正常显示列表，跳转到第二个页面的时候报错\n\n\n\n请问是怎么回事，看了一天了还是看不出所以然来。\n\n谢谢~", "Tag": "算法分析"}
{"Answer": "把ImageAndTextListAdapter 这个类中的\r\nimageAndTexts 设置get/set方法\r\n\r\n\r\n\r\n将onPostExecute方法改成这样\r\ndataArray.addAll(this.getListResp.InfoList); \r\nadapter.setImageAndTexts(dataArray); \r\nadapter.notifyDataSetChanged();", "Konwledge_Point": "线性规划简介", "Question": "大家帮我看下listview 异步加载数据 分页的问题！！！\n网上有大量介绍listview分页的文章，但都是一些基础，下面我用的是 异步从服务端获取数据，然后绑定到listview里面，服务端程序也是一个大家常见的分页的程序，现在出现一些问题，滑动滚动条加载下一页内容时上一页的内容没有了，大家能不能帮着看看，先谢了!\n\n\n\npublic class SearchList extends CommonActivity implements OnScrollListener,\n\n        OnClickListener ,OnItemClickListener{\n\n\n\nprivate String wherestr=\"\",orderstr=\" autoid desc\";\nprivate int lastItem = 0;\nImageAndTextListAdapter adapter;\nLinearLayout loadingLayout;\n/**\n * 设置布局显示属性\n */\nprivate LayoutParams mLayoutParams = new LinearLayout.LayoutParams(\n        LinearLayout.LayoutParams.WRAP_CONTENT,\n        LinearLayout.LayoutParams.WRAP_CONTENT);\n/**\n * 设置布局显示目标最大化属性\n */\nprivate LayoutParams FFlayoutParams = new LinearLayout.LayoutParams(\n        LinearLayout.LayoutParams.FILL_PARENT,\n        LinearLayout.LayoutParams.FILL_PARENT);\nprivate ProgressBar progressBar;\nprivate ListView list;\n// 获得数据集合\nprivate List dataArray = new ArrayList();\nprivate int mCurrentPage = Constants.PAGE_FIRST;\nprivate int mTotalPage, mTotalCount;\n// 组件声明\nprivate EditText searchTxt = null;\nprivate TextView recent_view_topnotifybar = null;\nprivate ImageView locate_my=null;//搜索确定\nprivate ImageView record_cordition=null; //搜索详细\nprivate ImageView go_filter2=null;\nprivate String Flag=\"\";\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    // TODO Auto-generated method stub\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.searchlist);\n\n    searchTxt = (EditText) findViewById(R.id.search_edittext);\n    recent_view_topnotifybar = (TextView) findViewById(R.id.recent_view_topnotifybar);\n    locate_my=(ImageView)findViewById(R.id.locate_my);\n    record_cordition=(ImageView)findViewById(R.id.record_cordition);\n    go_filter2=(ImageView)findViewById(R.id.go_filter2);\n\n    searchTxt.setOnClickListener(this);\n    locate_my.setOnClickListener(this);\n    record_cordition.setOnClickListener(this);\n    go_filter2.setOnClickListener(this);\n\n    // 线性布局\n    LinearLayout layout = new LinearLayout(this);\n    // 设置布局 水平方向\n    layout.setOrientation(LinearLayout.HORIZONTAL);\n    // 进度条\n    progressBar = new ProgressBar(this);\n    // 进度条显示位置\n    progressBar.setPadding(0, 0, 15, 0);\n    // 把进度条加入到layout中\n    layout.addView(progressBar, mLayoutParams);\n    // 文本内容\n    TextView textView = new TextView(this);\n    textView.setText(\"加载中...\");\n    textView.setGravity(Gravity.CENTER_VERTICAL);\n    // 把文本加入到layout中\n    layout.addView(textView, FFlayoutParams);\n    // 设置layout的重力方向，即对齐方式是\n    layout.setGravity(Gravity.CENTER);\n\n    // 设置ListView的页脚layout\n    loadingLayout = new LinearLayout(this);\n    loadingLayout.addView(layout, mLayoutParams);\n    loadingLayout.setGravity(Gravity.CENTER);\n    // =============================================\n    list = (ListView) findViewById(R.id.list);\n    list.setOnItemClickListener(this);\n\n}\n//\n@Override\nprotected void onResume() {\n    // TODO Auto-generated method stub\n    super.onResume();\n\n\n    // load\n    new QueryTask().execute();\n\n}\n\n// 单击事件\npublic void onClick(View v) {\n    // TODO Auto-generated method stub\n    Intent intent=null;\n    switch (v.getId()) {\n    case R.id.search_edittext://点击搜索文本框内容清空文本框\n        searchTxt.setText(\"\");\n        break;\n    case R.id.locate_my:// 搜索确定\n        String str=searchTxt.getText().toString();\n        if(str.equals(\"\")||str.equals(\"车辆品牌\"))\n            Toast.makeText(this, \"请输入查询关键词！\", Toast.LENGTH_LONG).show();\n        else\n        {   \n            this.wherestr=str;//查询条件\n            dataArray.clear();\n            new QueryTask().execute();\n        }\n        break;\n    case R.id.record_cordition:// 进入搜索的详细页\n        intent = new Intent(SearchList.this,\n                ZoneMain.class);\n\n        startActivity(intent);\n        break;\n    case R.id.go_filter2:// 点击筛选进入筛选页，但要返回筛选条件\n        intent = new Intent(SearchList.this,\n                FilterSearch.class);\n\n        startActivity(intent);\n        break;\n\n    }\n}\n\n//\npublic void onScroll(AbsListView view, int firstVisibleItem,\n        int visibleItemCount, int totalItemCount) {\n    //Log.e(\"onscroll adapter.coun\", adapter.count + \"\");\n    // TODO Auto-generated method stub\n    lastItem = firstVisibleItem + visibleItemCount - 1;\n            //如果当前页小于总页数 就需要加载\n    if (mCurrentPage <= mTotalPage) {\n        if (firstVisibleItem + visibleItemCount == totalItemCount) {\n            //adapter.count += 5;\n            mCurrentPage++;\n            new QueryTask().execute();\n\n            adapter.notifyDataSetChanged();\n            list.setSelection(lastItem);\n\n            // mCurrentPage=2;\n\n\n\n\n//              mCurrentPage = adapter.count / 5;// 当前页？\n\n//              Toast.makeText(getApplicationContext(),\n\n//                      \"第\" + mCurrentPage + \"页\", Toast.LENGTH_LONG).show();\n\n            }\n\n        } else {\n\n            list.removeFooterView(loadingLayout);\n\n        }\n\n\n\n}\n\n//\npublic void onScrollStateChanged(AbsListView view, int scrollState) {\n    // TODO Auto-generated method stub\n\n}\n\n// 加载数据\nclass QueryTask extends CommonTask {\n\n    private CarSearchListReq getListReq = null;\n    // 实例化此方法后就已经开始加载服务端的数据了\n    private CarSearchListResp getListResp = new CarSearchListResp();\n\n    public QueryTask() {\n        super(SearchList.this, getString(R.string.get_data));\n        // TODO Auto-generated constructor stub\n    }\n\n    protected Void doInBackground(Void... params) {\n        // TODO Auto-generated method stub\n        this.getListReq = new CarSearchListReq();\n        this.getListReq.wherestr = SearchList.this.wherestr;\n        this.getListReq.orderstr = SearchList.this.orderstr;\n        // 这个必须存在 mCurrentPage赋值改变记录查询\n        this.getListReq.pageIndex = mCurrentPage;\n\n        InputStream is = null;\n        HttpConnectWrapper httpCon = new HttpConnectWrapper();\n        try {\n            is = httpCon.httpPost(getListReq.getData(), getListReq\n                    .getNeedRespHeaderProps());\n\n            getListResp.parse(is);\n        } catch (Exception e) {\n\n        }\n        return super.doInBackground(params);\n    }\n\n    protected void onPostExecute(Void result) {\n        // TODO Auto-generated method stub\n        super.onPostExecute(result);\n        int hRet = this.getListResp.getData();\n\n        if (hRet == 1 || hRet == 1004) {\n            dataArray = this.getListResp.InfoList;\n            // 总记录数\n            mTotalCount = this.getListResp.count;\n            // 总页数\n            mTotalPage = mTotalCount % PAGE_MAX_LINE == 0 ? mTotalCount\n                    / PAGE_MAX_LINE : mTotalCount / PAGE_MAX_LINE + 1;\n\n            setPage();\n\n            if (hRet == 1004) {\n\n            }\n\n        } else {\n\n        }\n\n    }\n}\n\n/**\n * 设置ListView\n */\nprivate void setPage() {\n    adapter = new ImageAndTextListAdapter(this, dataArray, list);\n    // 添加到脚页显示\n    list.addFooterView(loadingLayout);\n\n    list.setAdapter(adapter);\n    // 给ListView注册滚动监听\n    list.setOnScrollListener(this);\n}\n\n//单击列表促发事件\npublic void onItemClick(AdapterView arg0, View arg1, int arg2, long arg3) {\n    // TODO Auto-generated method stub\n\n    if (arg2 != -1) {\n        Intent intent=new Intent(SearchList.this,CarDetail.class);\n        intent.putExtra(\"AutoID\", dataArray.get(arg2).AutoId.toString());\n        startActivity(intent);\n    }\n}\n", "Tag": "算法分析"}
{"Answer": "修改完善如下，具体改动处见注释，供参考：\n//Linear Table On On Link List Structure\n#include<stdio.h>\n#include<conio.h>\n#include<stdlib.h>\n\n#define FAIL 1   //; 修改\n#define OK 0     //; 修改\n\n//程序中反复出现的H=H->next是因为H的首地址不存数据 \n\ntypedef int ElemType; //数据元素类型定义\ntypedef int DataType;\ntypedef struct Node //线性表链式存储结构的定义\n{\n    DataType data;\n    struct Node* next;\n\n}LNode, * LinkList; //修改\n\n      //Node LNode;  修改\n      //int* px;     修改\n      //int i = 0, x = 0;      修改\n     //LinkList H, T, OriginH; 修改\n     //LinkList p;             修改\n     \n//注意：下面的链表都采用带头节点的结构 \nLinkList CreateLinkList(int n); //带n个节点的链表,返回链表的头指针\nvoid PrintList(LinkList L);//以(a1,a2,...,an)格式输出链表  OK\nvoid EmptyList(LinkList L);  //把链表H清空（保留头结点）\nint ListLength(LinkList L);  //返回链表H的长度    OK\nNode* GetData(Node* L, int i, DataType* px);//查找第i(1≤i≤n)个元素，查找成功返回OK并把元素放入*px,查找失败返回FAIL  \nNode* Locate(LinkList H, DataType x); //查找元素x的位置，找到返回指向该结点指针,否则返回NULL\nint InsList(LinkList H, int i, DataType x);//在链表H的第i个位置上插入值为x的元素，成功返回TRUE,否则FALSE\nint DelList(LinkList L, int i, ElemType* px); //删除表中第i(1≤i≤n)个元素，删除元素值放入*px;删除成功返回OK,否则FAIL\n\nint main()\n{\n    LinkList H = NULL;//定义一个链表指针   修改\n    int i = 0, x = 0;    //修改\n    //生成菜单 \n    char sel = ' ';\n    while (sel != '0')\n    {\n        printf(\"------线性表(链式存储结构)演示系统-------\\n\");\n        printf(\"   版本:1.0   作者:XXXXXX 日期:yyyy-mm-dd\\n\");\n        printf(\"------------------------------------------\\n\");\n        printf(\"       1.创建线性表\\n\");   //已经实现 \n        printf(\"       2.查找元素位置\\n\");\n        printf(\"       3.按位置查找元素\\n\");\n        printf(\"       4.插入一个元素\\n\");\n        printf(\"       5.删除一个元素\\n\");\n        printf(\"       6.打印线性表\\n\");  //已经实现 OK\n        printf(\"       7.打印线表长度\\n\");  //OK\n        printf(\"       8.清空线性表\\n\");\n        printf(\"       9.清空屏幕\\n\"); //已经实现 \n        printf(\"       0.退出系统\\n\"); //已经实现 \n        printf(\"请输入选项[0-7]:\");\n        sel = getch();\n        switch (sel)\n        {\n        case '1':\n            int n;\n            printf(\"创建线性表操作.\\n\");\n            printf(\"请输入你要创建线性表的长度：\");\n            scanf(\"%d\", &n);\n            H = CreateLinkList(n);\n            system(\"pause\"); //按任意键继续 \n            break;\n        case '2':\n            printf(\"查找元素操作.\\n\");\n            //... \n            system(\"pause\"); //按任意键继续 \n            break;\n        case '3':\n            printf(\"按位置查找元素操作.\\n\");\n            //... \n            system(\"pause\"); //按任意键继续 \n            break;\n        case '4':\n            printf(\"插入一个元素操作.\\n\");\n            printf(\"请输入所插入的位置与数据的值：\");\n            scanf(\"%d %d\", &i, &x);\n            InsList(H, i, x);\n\n            system(\"pause\"); //按任意键继续 \n            break;\n        case '5':\n            printf(\"删除一个元素操作.\\n\");\n            //... \n            system(\"pause\"); //按任意键继续 \n            break;\n        case '6':\n            printf(\"显示线性表操作.\\n\");\n            PrintList(H);\n            system(\"pause\"); //按任意键继续 \n            break;\n        case '7':\n            printf(\"显示线性表长度.\\n\");\n            printf(\"长度为：%d\\n\", ListLength(H));\n            system(\"pause\"); //按任意键继续 \n            break;\n        case '8':\n            printf(\"清空线性表操作.\\n\");\n            //... \n            system(\"pause\"); //按任意键继续 \n            break;\n        case '9':\n            system(\"cls\");\n            break;\n        case '0':\n            printf(\"\\n谢谢使用，再见！\\n\");\n            break;\n        default:\n            printf(\"您输入的选项不合法，请重新选择！\\n\");\n        }\n    }\n    return 0;\n}\n\n//创建带n个节点的链表,返回链表的头指针\nLinkList CreateLinkList(int n)\n{\n    LinkList H = (LinkList)malloc(sizeof(LNode));       //修改\n    //申请一个LNode节点，把H指向这个新申请的节点 void*\n    H->next = NULL; //(*H).next = NULL;\n    //OriginH = H;//统计长度或显示链表会导致地址后移，OriginH存放原始H地址  修改\n    LinkList T = H;    //修改\n    int i;\n    printf(\"请输入%d个整数：\", n);\n    for (i = 0; i < n; i++)\n    {\n        int x;\n        scanf(\"%d\", &x);\n        //申请节点p，放入x \n        LNode *p = (LinkList)malloc(sizeof(LNode));  //修改\n        p->data = x;\n        p->next = NULL;\n\n        //把p点接入T后面\n        T->next = p;\n        T = p;\n    }\n    return H;\n}\n\nint ListLength(LinkList L)//统计长度 \n{\n    int cnt = 0;\n    if (!L || !L->next)           //修改 \n        return cnt;\n    LinkList H = L->next;  //H = H->next;  修改\n    while (H != NULL)\n    {\n        H = H->next;\n        cnt++;\n    }\n                        //H = OriginH;   修改\n    return cnt;\n}\n\nint InsList(LinkList H, int i, DataType x)//插入 \n{\n    int length = ListLength(H);\n    int j = 0; // j = 1;         修改\n    if (i > length || i < 1)\n    {\n        printf(\"超出范围，无法插入！\\n\");\n        return FAIL;\n    }\n    else\n    {\n        LinkList L = H, tmp = NULL;  //修改\n        while (L && j < i - 1) {\n            L = L->next;\n            j++;\n        }\n        tmp = (LinkList)malloc(sizeof(LNode));\n        tmp->next = NULL;\n        tmp->data = x;\n        tmp->next = L->next;\n        L->next = tmp;\n        //H = H->next;\n        //for (; j != i; j++)\n        //{\n        //    H = H->next;//后传直至找到第i个位置 \n        //}\n        //x = x + H->data;//交换 x与 x=x+Tmp1->data的值 可以少用一个变量 \n        //H->data = x - H->data;\n        //x = x - H->data;\n        //for (int k = i; k < length; k++)//交换x与H.data中的数据方便后移 \n        //{\n        //    H = H->next;//插入数据后将每一位数字后移 \n        //    x = x + H->data;\n        //    H->data = x - H->data;\n        //    x = x - H->data;\n        //}\n        printf(\"插入成功！\\n\");\n        //H = OriginH;\n        return OK;\n    }\n\n}\n\nvoid PrintList(LinkList L)//打印链表 \n{\n    int flag = 0;//默认为第一位 \n    if (!L || !L->next)           //修改 \n        return;\n    LinkList H = L->next;         //H = H->next; 修改\n    printf(\"（\");\n    while (H != NULL)\n    {\n        if (flag == 0)\n        {\n            printf(\"%d\", H->data);\n            flag = 1;\n        }\n        else \n            printf(\"，%d\", H->data);\n        H = H->next;\n    }\n    printf(\"）\");\n                    //H = OriginH;//返回初始位置  修改\n}\n\n", "Konwledge_Point": "线性规划简介", "Question": "C语言链表 插入一个值 导致链表最后一位消失怎么办？\nC语言链表 插入一个值 导致链表最后一位消失怎么办？\n比如链表中本身有（1,2,3） 插入99在第二位后 链表就变成了（1,99,3）\n\n\n\n\n//Linear Table On On Link List Structure\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n\n#\ndefine\n FAIL 1;\n\n\n#\ndefine\n OK 0;\n\n\n\n//程序中反复出现的H=H->next是因为H的首地址不存数据 \n\n\n\ntypedef\n \nint\n ElemType; \n//数据元素类型定义\n\n\ntypedef\n \nint\n DataType; \n\ntypedef\n \nstruct\n \nNode\n \n//线性表链式存储结构的定义\n\n{\n    DataType data;\n    \nstruct\n \nNode\n* next;\n    \n}Node,*LinkList;\nNode LNode;\n\nint\n *px;\n\nint\n i=\n0\n,x=\n0\n;\nLinkList H,T,OriginH;\nLinkList p;\n\n//注意：下面的链表都采用带头节点的结构 \n\n\nLinkList \nCreateLinkList\n(\nint\n n)\n; \n//带n个节点的链表,返回链表的头指针\n\n\nvoid\n \nPrintList\n(LinkList L)\n;\n//以(a1,a2,...,an)格式输出链表  OK\n\n\nvoid\n \nEmptyList\n(LinkList L)\n;  \n//把链表H清空（保留头结点）\n\n\nint\n \nListLength\n(LinkList L)\n;  \n//返回链表H的长度    OK\n\n\nNode* \nGetData\n(Node *L, \nint\n i, DataType*px)\n;\n//查找第i(1≤i≤n)个元素，查找成功返回OK并把元素放入*px,查找失败返回FAIL  \n\n\nNode* \nLocate\n(LinkList H, DataType x)\n; \n//查找元素x的位置，找到返回指向该结点指针,否则返回NULL\n\n\nint\n \nInsList\n(LinkList H, \nint\n i, DataType x)\n;\n//在链表H的第i个位置上插入值为x的元素，成功返回TRUE,否则FALSE\n\n\nint\n \nDelList\n(LinkList L,\nint\n i, ElemType*px)\n; \n//删除表中第i(1≤i≤n)个元素，删除元素值放入*px;删除成功返回OK,否则FAIL\n\n\n\nint\n \nmain\n()\n\n\n{\n    LinkList H;  \n//定义一个链表指针 \n\n    \n    \n//生成菜单 \n\n    \nchar\n sel=\n' '\n;\n    \nwhile\n(sel!=\n'0'\n)\n    {\n        \n        \nprintf\n(\n\"------线性表(链式存储结构)演示系统-------\\n\"\n);\n        \nprintf\n(\n\"   版本:1.0   作者:XXXXXX 日期:yyyy-mm-dd\\n\"\n); \n        \nprintf\n(\n\"------------------------------------------\\n\"\n);\n        \nprintf\n(\n\"       1.创建线性表\\n\"\n);   \n//已经实现 \n\n        \nprintf\n(\n\"       2.查找元素位置\\n\"\n);\n        \nprintf\n(\n\"       3.按位置查找元素\\n\"\n);\n        \nprintf\n(\n\"       4.插入一个元素\\n\"\n);\n        \nprintf\n(\n\"       5.删除一个元素\\n\"\n);\n        \nprintf\n(\n\"       6.打印线性表\\n\"\n);  \n//已经实现 OK\n\n        \nprintf\n(\n\"       7.打印线表长度\\n\"\n);  \n//OK\n\n        \nprintf\n(\n\"       8.清空线性表\\n\"\n);\n        \nprintf\n(\n\"       9.清空屏幕\\n\"\n); \n//已经实现 \n\n        \nprintf\n(\n\"       0.退出系统\\n\"\n); \n//已经实现 \n\n        \nprintf\n(\n\"请输入选项[0-7]:\"\n); \n        sel=\ngetch\n();\n        \nswitch\n(sel)\n        {\n            \ncase\n \n'1'\n:\n                \nint\n n;\n                \nprintf\n(\n\"创建线性表操作.\\n\"\n);\n                \nprintf\n(\n\"请输入你要创建线性表的长度：\"\n);\n                \nscanf\n(\n\"%d\"\n,&n);\n                H = \nCreateLinkList\n(n);\n                \nsystem\n(\n\"pause\"\n); \n//按任意键继续 \n\n                \nbreak\n;\n            \ncase\n \n'2'\n:\n                \nprintf\n(\n\"查找元素操作.\\n\"\n);   \n                \n//... \n\n                \nsystem\n(\n\"pause\"\n); \n//按任意键继续 \n\n                \nbreak\n;\n            \ncase\n \n'3'\n:\n                \nprintf\n(\n\"按位置查找元素操作.\\n\"\n);\n                \n//... \n\n                \nsystem\n(\n\"pause\"\n); \n//按任意键继续 \n\n                \nbreak\n;\n            \ncase\n \n'4'\n:\n                \nprintf\n(\n\"插入一个元素操作.\\n\"\n);\n                \nprintf\n(\n\"请输入所插入的位置与数据的值：\"\n);\n                \nscanf\n(\n\"%d %d\"\n,&i,&x);\n                \nInsList\n(H,i,x);\n                \n                \nsystem\n(\n\"pause\"\n); \n//按任意键继续 \n\n                \nbreak\n;\n            \ncase\n \n'5'\n:\n                \nprintf\n(\n\"删除一个元素操作.\\n\"\n);\n                \n//... \n\n                \nsystem\n(\n\"pause\"\n); \n//按任意键继续 \n\n                \nbreak\n;\n            \ncase\n \n'6'\n:\n                \nprintf\n(\n\"显示线性表操作.\\n\"\n);\n                \nPrintList\n(H);\n                \nsystem\n(\n\"pause\"\n); \n//按任意键继续 \n\n                \nbreak\n;\n            \ncase\n \n'7'\n:\n                \nprintf\n(\n\"显示线性表长度.\\n\"\n);\n                \nprintf\n(\n\"长度为：%d\\n\"\n,\nListLength\n(H));\n                \nsystem\n(\n\"pause\"\n); \n//按任意键继续 \n\n                \nbreak\n;\n            \ncase\n \n'8'\n:\n                \nprintf\n(\n\"清空线性表操作.\\n\"\n);\n                \n//... \n\n                \nsystem\n(\n\"pause\"\n); \n//按任意键继续 \n\n                \nbreak\n;\n            \ncase\n \n'9'\n:\n                \nsystem\n(\n\"cls\"\n);\n                \nbreak\n;\n            \ncase\n \n'0'\n:\n                \nprintf\n(\n\"\\n谢谢使用，再见！\\n\"\n);\n                \nbreak\n;\n            \ndefault\n:\n                \nprintf\n(\n\"您输入的选项不合法，请重新选择！\\n\"\n);\n        }\n    }\n\n    \nreturn\n \n0\n;\n} \n\n\n\n//创建带n个节点的链表,返回链表的头指针\n\n\nLinkList \nCreateLinkList\n(\nint\n n)\n\n\n{\n    \n    H = (LinkList) \nmalloc\n(\nsizeof\n(LNode));  \n//申请一个LNode节点，把H指向这个新申请的节点 void*\n\n    H->next = \nNULL\n; \n//(*H).next = NULL;\n\n    OriginH=H;\n//统计长度或显示链表会导致地址后移，OriginH存放原始H地址 \n\n    T=H;\n    \nint\n i;\n    \nprintf\n(\n\"请输入%d个整数：\"\n,n);\n    \nfor\n(i=\n0\n;idata = x;\n        p->next = \nNULL\n;\n        \n        \n//把p点接入T后面\n\n        T->next = p;\n        T=p;\n    } \n    \n    \nreturn\n H;\n}\n\n\n\n\nint\n \nListLength\n(LinkList L)\n//统计长度 \n\n\n{\nH=H->next;\n\nint\n cnt=\n0\n;\n\nwhile\n(H!=\nNULL\n)\n    {H=H->next;\n    cnt++;\n    }\nH=OriginH;\n\nreturn\n cnt;\n}\n\n\n\n\n\nint\n \nInsList\n(LinkList H, \nint\n i, DataType x)\n//插入 \n\n\n{\n\n\n\nint\n length=\nListLength\n(H);\n\nint\n j=\n1\n;\n\nif\n(i>length||i<\n1\n)\n    {\nprintf\n(\n\"超出范围，无法插入！\\n\"\n);\n    \nreturn\n FAIL;\n    }\n        \nelse\n\n        {H=H->next;\n        \nfor\n(;j!=i;j++)\n        {H=H->next;\n//后传直至找到第i个位置 \n\n        }\n                x=x+H->data;\n//交换 x与 x=x+Tmp1->data的值 可以少用一个变量 \n\n                H->data=x-H->data;\n                x=x-H->data;\n                    \nfor\n(\nint\n k=i;knext;\n//插入数据后将每一位数字后移 \n\n                        x=x+H->data;\n                        H->data=x-H->data;\n                        x=x-H->data;                    \n                    \n                    }\n                    \nprintf\n(\n\"插入成功！\\n\"\n);\n                    H=OriginH;\n                    \nreturn\n OK;\n        }\n    \n}\n\n\n\nvoid\n \nPrintList\n(LinkList L)\n//打印链表 \n\n\n{\nint\n flag=\n0\n;\n//默认为第一位 \n\nH=H->next;\n\nprintf\n(\n\"（\"\n);\n    \nwhile\n(H!=\nNULL\n)\n    {\nif\n(flag==\n0\n)\n        {\nprintf\n(\n\"%d\"\n,H->data);\n        flag=\n1\n;\n        }\n    \nelse\n \nprintf\n(\n\"，%d\"\n,H->data);\n    H=H->next;\n    }\n        \nprintf\n(\n\"）\"\n);\nH=OriginH;\n//返回初始位置 \n\n}\n\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "就是把文件加载进来，将YUV数据转换成RGB颜色，然后用drawImage画出来", "Konwledge_Point": "线性规划简介", "Question": "一段视频播放器文件代码，不明白\n代码如下：\nimport java.io.\n;\nimport java.util.TreeSet;\nimport java.awt.\n;\nimport java.awt.event.\n;\nimport java.awt.geom.AffineTransform;\nimport java.awt.image.\n;\nimport javax.imageio.\n;\nimport javax.swing.\n;\n\n\npublic class design1  extends Component {\n    DataInputStream data_in;\n    private byte[] yuv_array;\n    private int[] u_array, v_array;\n    private int[] rgb_array;\n    private BufferedImage img;\n    private int width, height;\n    private int frame_number;\n    private int frame_size, yuv_frame_size;\n\n\npublic\n \ndesign1\n(String filename, \nint\n width, \nint\n height, \nint\n frame_number)\n {\n    \nthis\n.width = width;\n    \nthis\n.height = height;\n    frame_size = width * height;\n    \nthis\n.frame_number = frame_number;\n    yuv_frame_size = (width * height * \n3\n)>>\n1\n;\n    \n//在Heap分配空间\n\n    img = \nnew\n \nBufferedImage\n(width, height, \n1\n);\n//1:TYPE_INT_RGB\n\n    yuv_array = \nnew\n \nbyte\n[yuv_frame_size];\n    u_array = \nnew\n \nint\n[frame_size];\n    v_array = \nnew\n \nint\n[frame_size];\n    rgb_array = \nnew\n \nint\n[frame_size];\n    \n    \ntry\n {\n        \nFileInputStream\n \nf_in\n \n=\n \nnew\n \nFileInputStream\n(\nnew\n \nFile\n(filename));\n        f_in.skip(frame_number * yuv_frame_size);\n        data_in = \nnew\n \nDataInputStream\n(f_in);\n        data_in.read(yuv_array, \n0\n, yuv_frame_size);\n        \nthis\n.frame_number++;\n    } \ncatch\n (IOException e) {  \n        \n// TODO Auto-generated catch block  \n\n        e.printStackTrace();  \n    }\n    yuv2rgb();\n    img.setRGB(\n0\n, \n0\n, width, height, rgb_array, \n0\n, width);\n}\n\n\nprivate\n \nvoid\n \nyuv2rgb\n()\n\n{\n    \nint\n h;\n    \nint\n h2;\n    \nint\n \nframe_size2\n \n=\n frame_size + (frame_size>>\n2\n);\n    \nint\n \nwidth2\n \n=\n width<<\n1\n;\n    \nint\n i2, j2;\n    \n    h = \n0\n;\n    h2 = \n0\n;\n    \nfor\n (\nint\n \nj\n \n=\n \n0\n; j < (height>>\n1\n); j++)\n    {\n        \nfor\n (\nint\n \ni\n \n=\n \n0\n; i < (width>>\n1\n); i++)\n        {\n            i2 = i<<\n1\n;\n            \nint\n a, b;\n            u_array[h2 + i2]   = yuv_array[frame_size + h + i]&\n0xff\n;\n            v_array[h2 + i2]   = yuv_array[frame_size2 + h + i]&\n0xff\n;\n        }\n        h += width>>\n1\n;\n        h2 += width2;\n    }\n    \n//执行双线性内插，把4:1:1的YUV扩大为4:4:4的YUV\n\n    h2 = \n0\n;\n    \nfor\n (j2 = \n0\n; j2 < height - \n2\n; j2 += \n2\n)\n    {\n        \nfor\n (i2 = \n0\n; i2 < width - \n2\n; i2 += \n2\n)\n        {\n            \nint\n a, b, ab;\n            \n            a = u_array[h2 + i2] + u_array[h2 + i2 + \n2\n];\n//水平\n\n            b = u_array[h2 + i2] + u_array[h2 + i2 + width2];\n//垂直\n\n            ab = u_array[h2 + i2] + u_array[h2 + i2 + \n2\n] + u_array[h2 + i2 + width2] + u_array[h2 + i2 + width2 + \n2\n];\n//对角线\n\n            u_array[h2 + i2 + \n1\n] = (a + \n1\n)>>\n1\n;\n            u_array[h2 + i2 + width] = (b + \n1\n)>>\n1\n;\n            u_array[h2 + i2 + width + \n1\n] = (ab + \n2\n)>>\n2\n;\n            \n            a = v_array[h2 + i2] + v_array[h2 + i2 + \n2\n];\n//水平\n\n            b = v_array[h2 + i2] + v_array[h2 + i2 + width2];\n//垂直\n\n            ab = v_array[h2 + i2] + v_array[h2 + i2 + \n2\n] + v_array[h2 + i2 + width2] + v_array[h2 + i2 + width2 + \n2\n];\n//对角线\n\n            v_array[h2 + i2 + \n1\n] = (a + \n1\n)>>\n1\n;\n            v_array[h2 + i2 + width] = (b + \n1\n)>>\n1\n;\n            v_array[h2 + i2 + width + \n1\n] = (ab + \n2\n)>>\n2\n;\n        }\n        u_array[h2 + i2 + \n1\n] = u_array[h2 + i2];\n        u_array[h2 + i2 + width] = \n        u_array[h2 + i2 + width + \n1\n] = (u_array[h2 + i2] + u_array[h2 + i2 + width2] + \n1\n)>>\n1\n;\n        \n        v_array[h2 + i2 + \n1\n] = v_array[h2 + i2];\n        v_array[h2 + i2 + width] = \n        v_array[h2 + i2 + width + \n1\n] = (v_array[h2 + i2] + v_array[h2 + i2 + width2] + \n1\n)>>\n1\n;\n        \n        h2 += width2;\n    }\n    \nfor\n (i2 = \n0\n; i2 < width - \n2\n; i2 += \n2\n)\n    {\n        \nint\n a, b, ab;\n        \n        u_array[h2 + i2 + \n1\n] = \n        u_array[h2 + i2 + width + \n1\n] = (u_array[h2 + i2] + u_array[h2 + i2 + \n2\n] + \n1\n)>>\n1\n;\n        u_array[h2 + i2 + width] = u_array[h2 + i2];\n        \n        v_array[h2 + i2 + \n1\n] = \n        v_array[h2 + i2 + width + \n1\n] = (v_array[h2 + i2] + v_array[h2 + i2 + \n2\n] + \n1\n)>>\n1\n;\n        v_array[h2 + i2 + width] = v_array[h2 + i2];\n    }\n    u_array[h2 + i2 + \n1\n] =\n    u_array[h2 + i2 + width] = \n    u_array[h2 + i2 + width + \n1\n] = u_array[h2 + i2];       \n    \n    v_array[h2 + i2 + \n1\n] =\n    v_array[h2 + i2 + width] = \n    v_array[h2 + i2 + width + \n1\n] = v_array[h2 + i2];\n    \n    \n//彩色空间变换,从YUV转换到RGB\n\n    \nfor\n (\nint\n \ni\n \n=\n \n0\n; i < frame_size; i++)\n    {\n        \nint\n pixel_r, pixel_g, pixel_b;\n        \nint\n \npixel_y\n \n=\n yuv_array[i]&\n0xff\n;\n        \nint\n \npixel_u\n \n=\n u_array[i] - \n128\n;\n        \nint\n \npixel_v\n \n=\n v_array[i] - \n128\n;\n        \n//YUV到RGB的矩阵变换运算\n\n        \ndouble\n \nR\n \n=\n pixel_y - \n0.001\n * pixel_u + \n1.402\n * pixel_v;\n        \ndouble\n \nG\n \n=\n pixel_y - \n0.344\n * pixel_u - \n0.714\n * pixel_v;\n        \ndouble\n \nB\n \n=\n pixel_y + \n1.772\n * pixel_u + \n0.001\n * pixel_v;\n        \n//限幅\n\n        \nif\n (R > \n255\n) pixel_r = \n255\n;\n        \nelse\n \nif\n (R < \n0\n) pixel_r = \n0\n;\n        \nelse\n \npixel_r\n \n=\n (\nint\n)R;\n        \nif\n (G > \n255\n) pixel_g = \n255\n;\n        \nelse\n \nif\n (G < \n0\n) pixel_g = \n0\n;\n        \nelse\n \npixel_g\n \n=\n (\nint\n)G;\n        \nif\n (B > \n255\n) pixel_b = \n255\n;\n        \nelse\n \nif\n (B < \n0\n) pixel_b = \n0\n;\n        \nelse\n \npixel_b\n \n=\n (\nint\n)B;\n        rgb_array[i] = (pixel_r<<\n16\n) | (pixel_g<<\n8\n) | pixel_b;\n    }\n}\n\n\npublic\n Dimension \ngetPreferredSize\n()\n {\n    \nif\n (img == \nnull\n) {\n         \nreturn\n \nnew\n \nDimension\n(width, height);\n    } \nelse\n {\n       \nreturn\n \nnew\n \nDimension\n(img.getWidth(\nnull\n), img.getHeight(\nnull\n));\n   }\n}\n\n\npublic\n \nvoid\n \nwriteFile\n(String formatName, String filename)\n {\n    \ntry\n {\n        ImageIO.write(img, formatName, \nnew\n \nFile\n(filename));\n    } \ncatch\n (IOException e) {\n        e.printStackTrace();  \n    }\n}\n\n\npublic\n \nvoid\n \npaint\n(Graphics g)\n {\n    g.drawImage(img, \n0\n, \n0\n, \nnull\n);\n}\n\n\npublic\n \nvoid\n \nplay\n(JFrame f)\n {\n    \nwhile\n(\ntrue\n){\n        \ntry\n {\n            data_in.read(yuv_array, \n0\n, yuv_frame_size);\n            f.setTitle(\n\"YUV Player of GDUT              #\"\n + frame_number + \n\" frames\"\n);\n            frame_number++;\n        } \ncatch\n (IOException e) {  \n            \n// TODO Auto-generated catch block  \n\n            e.printStackTrace();\n        }\n        yuv2rgb();\n        img.setRGB(\n0\n, \n0\n, width, height, rgb_array, \n0\n, width);\n        repaint(); \n    }\n}\n\n\npublic\n \nstatic\n \nvoid\n \nmain\n(String[] args)\n {\n    \n// TODO Auto-generated method stub\n\n    \nJFrame\n \nf\n \n=\n \nnew\n \nJFrame\n(\n\"YUV Player of GDUT\"\n);\n    f.addWindowListener(\nnew\n \nWindowAdapter\n() {\n        \npublic\n \nvoid\n \nwindowClosing\n(WindowEvent e)\n {System.exit(\n0\n);}\n    });\n\n    \n    \ndesign1\n \nme\n \n=\n \nnew\n \ndesign1\n(\n\"ShuttleStart_1280x720.yuv\"\n, \n1280\n, \n720\n, \n10\n);        \n    f.add(\n\"Center\"\n, me);\n    f.pack();\n    f.setVisible(\ntrue\n);\n\n    \n//me.writeFile(\"jpg\", \"out.jpg\");\n\n    \n//me.play(f);//连续读取并显示图像\n\n}\n\n\n\n}", "Tag": "算法分析"}
{"Answer": "\n回答不易，求求您采纳点赞哦\n\n一般来说，下游生物信息分析流程包括以下几步：\n鉴定该转录本的全长序列：确定该转录本的全长序列，并验证其准确性。分析转录本的功能：使用相关的生物信息学工具，如RNA-seq数据库、预测转录因子结合位点等，预测该转录本的功能。判断该转录本的调控效应：评估该转录本的表达与其他基因或蛋白质的相关性，以确定该转录本的调控效应。研究该转录本的作用机制：利用细胞生物学、分子生物学等方法研究该转录本在肿瘤发生发展过程中的作用机制。每一步分析的动机是为了更深入了解该转录本的功能和作用机制，以便确定该转录本在肿瘤发生发展中的作用。", "Konwledge_Point": "线性规划简介", "Question": "关于#算法#的问题：某团队通过转录组测序比较口腔颌面部肿瘤样本，鉴定出一个新的转录本序列，在肿瘤样本中显著高表达\n某团队通过转录组测序比较口腔颌面部肿瘤样本，鉴定出一个新的转录本序列，在肿瘤样本中显著高表达。推测该转录本可能对口腔颌面部的发生发展具有重要意义。为进一步解析该分子的功能和作用机制，请，设计下游生物信息分析流程，并解释每一步分析的动机。不需要给出具体的实现细节。", "Tag": "算法分析"}
{"Answer": "up_and_down方法的第一条语句打印顺序是1,2,3,4，最后一条语句打印是4,3,2,1", "Konwledge_Point": "线性规划简介", "Question": "有一个递归函数不知道该怎么理解？\n他最后这个输出结果到底是怎么从一变到四？然后从四再变到一的？", "Tag": "算法分析"}
{"Answer": "单看这一部分，只是在设置网络中的全连接层，为了后续构造生成器模型进行训练，详细说明为：\nPyTorch的nn.Linear（）详解_风雪夜归人o的博客-CSDN博客_nn.linear\n  PyTorch的nn.Linear（）是用于设置网络中的全连接层的，需要注意的是全连接层的输入与输出都是二维张量，一般形状为[batch_size, size]，不同于卷积层要求输入输出是四维张量。其用法与形参说明如下：  in_features指的是输入的二维张量的大小，即输入的[batch_size, size]中的size。  out_features指的是输出的二维张量的大小，即...\n\n\n\nhttps://blog.csdn.net/qq_42079689/article/details/102873766\n\n", "Konwledge_Point": "线性规划简介", "Question": "求解，if score_func == 1:\n\n\n一个代码初学者，感觉是在求加权数的，求帮忙解释这些代码是什么意思🙏", "Tag": "算法分析"}
{"Answer": "你没有设置，既然想显示年-月-日，那就要设置date()函数的第二个参数如date(date, \"YMD\")这里的YMD意思就是year month date即年月日 https://cloud.tencent.com/developer/news/574226", "Konwledge_Point": "线性规划简介", "Question": "stata回归导入日期处理\n为什么在excel里面是年、月、日，导入stata之后就变成了日、月、年\n？然后用date命令，结果显示的全是一个点", "Tag": "算法分析"}
{"Answer": "报错是关于优化设置的编译器警告信息1、首先检查代码中的错误\n2、编译器优化设置： \"Current optimization/debug settings\"，检查当前的编译器优化设置是否正确。调整编译器的优化级别，降低优化级别，或者禁用某些优化选项\n3、编译器的目标设置：\"#27010-D Not all available code size is b DCDCPlantF...\" 和 \"#27007-D Detecting compilation without DCDCPlantF...\"，这与编译器的目标设置有关。检查编译器的目标设置，如目标芯片型号、编译器选项等是否正确配置\n4、代码依赖关系： \"properties properties properties\"，是代码中存在的依赖关系问题导致的错误。检查代码中的依赖关系，包括头文件引用、库文件链接等是否正确配置", "Konwledge_Point": "线性规划简介", "Question": "ccs代码报错怎么办\n\n\n在ccs代码《buck变换器线性化模型》中出现2个解决不了的bug，求帮忙", "Tag": "算法分析"}
{"Answer": "把代码发给我看看", "Konwledge_Point": "线性规划简介", "Question": "R语言tb1.contineous.normal函数是哪个R包的？\n各位，苦找这函数的R包却不得\n希望得到各位解惑～\ntb1.contineous.normal\ntb1.categorial\ntb1.contineous.not.normal\n\n\n源代码如下：\n\n\nchtable <-  function (design, \ncv\n = NULL, cv.\nnn\n = NULL, \ngv\n = NULL, \nby\n = NULL, \n                     \nc_meanSQse\n = FALSE, \nc_meanPMse\n = FALSE, \nc_ci\n = FALSE, \ng_N\n = FALSE, \n                     \ng_percent\n = FALSE, \ng_perSQse\n = FALSE, \ng_NSQper\n = FALSE, \ng_nSQper\n = FALSE, \n                     \ng_ci\n = FALSE, \ng_direction\n = \n\"v\"\n, \ntotal\n = FALSE, \nround\n = \n2\n, \n                     \nview\n = T, \nxlsx\n = NULL) \n{\n  ck.by <- list(\ncv\n = cv, \ngv\n = gv, cv.\nnn\n = cv.nn, \nby\n = by)\n  (ck.by <- ck.by[!sapply(ck.by, is.\nnull\n)])\n  \nif\n (length(ck.by) > \n1\n) {\n    for (i \nin\n \n1\n:(length(ck.by) - \n1\n)) {\n      for (j \nin\n (i + \n1\n):length(ck.by)) {\n        \nif\n (names(ck.by)[i] == \n\"cv\"\n & names(ck.by)[j] == \n            \n\"cv.nn\"\n) \n          (next)(j)\n        ck.common <- set::\nand\n(ck.by[[i]], ck.by[[j]])\n        \nif\n (length(ck.common) > \n0\n) \n          stop(names(ck.by)[i], \n\" and \"\n, names(ck.by)[j], \n               \n\" have the same variable: \"\n, paste0(ck.common, \n                                                   \ncollapse\n = \n\", \"\n))\n      }\n    }\n  }\n  v <- c(cv, cv.nn, gv)\n  lv <- set::not(v, colnames(design$variables))\n  \nif\n (length(lv) > \n0\n) {\n    \nif\n (do::cnOS()) \n      stop(tmcn::toUTF8(\n\"变量 \"\n), paste0(lv, \ncollapse\n = \n\", \"\n), \n           tmcn::toUTF8(\n\" 输入错误\"\n))\n    \nif\n (!do::cnOS()) \n      stop(\n\"variable \"\n, paste0(lv, \ncollapse\n = \n\", \"\n), \n\" not exist\"\n)\n  }\n  r1 <- NULL\n  \nif\n (!is.\nnull\n(cv)) {\n    r1 <- tb1.contineous.normal(design, cv, by, \nmeanSQse\n = c_meanSQse, \n                                \nmeanPMse\n = c_meanPMse, \nci\n = c_ci, total, round)\n  }\n  r2 <- NULL\n  \nif\n (!is.\nnull\n(cv.nn)) {\n    r2 <- tbl.contineous.not.normal(design, cv.nn, by, total, \n                                    round)\n  }\n  r3 <- NULL\n  \nif\n (!is.\nnull\n(gv)) {\n    r3 <- tb1.categorial(design, \nx\n = gv, by, \nvalue\n = g_N, \n                         \nper\n = g_percent, \nperSQse\n = g_perSQse, \nNSQper\n = g_NSQper, \n                         \nnSQper\n = g_nSQper, \nci\n = g_ci, \ndirection\n = g_direction, \n                         \ntotal\n = total, round)\n  }\n  r <- plyr::rbind.fill(r1, r2)\n  r <- plyr::rbind.fill(r, r3)\n  row.names(r) <- NULL\n  \nif\n (view) \n    nhs_view.svytableone(r)\n  r$variable <- do::Replace(r$variable, \n\"~~~~\"\n, \n\"    \"\n)\n  \nif\n (!is.\nnull\n(xlsx)) {\n    header_bold <- openxlsx::createStyle(\ntextDecoration\n = \n\"Bold\"\n)\n    wb <- openxlsx::createWorkbook()\n    openxlsx::addWorksheet(wb, \n\"Sheet1\"\n)\n    for (i \nin\n \n1\n:ncol(r)) {\n      openxlsx::writeData(wb, \nsheet\n = \n1\n, \nx\n = colnames(r)[i], \n                          \nstartCol\n = i, \nstartRow\n = \n1\n, \nheaderStyle\n = header_bold)\n      \nif\n (\ni\n == \n1\n) {\n        for (j \nin\n \n1\n:nrow(r)) {\n          \nif\n (do::left(r[j, i], \n4\n) == \n\"    \"\n) {\n            openxlsx::writeData(wb, \nsheet\n = \n1\n, \nx\n = r[j, \n                                                     i], \nstartCol\n = i, \nstartRow\n = j + \n1\n)\n          }\n          \nelse\n {\n            openxlsx::writeData(wb, \nsheet\n = \n1\n, \nx\n = r[j, \n                                                     i], \nstartCol\n = i, \nstartRow\n = j + \n1\n, \nheaderStyle\n = header_bold)\n          }\n        }\n      }\n      \nelse\n \nif\n (grepl(\n\"p\"\n, colnames(r)[i], T)) {\n        for (j \nin\n \n1\n:nrow(r)) {\n          \nif\n (nchar(r[j, i]) > \n0\n) {\n            ii <- tryCatch(as.numeric(r[j, i]), \nwarning\n = function(w) \n\"w\"\n)\n            \nif\n ((\nii\n == \n\"w\"\n | ii <= \n0.05\n) & r[j, i] != \n                \n\"ref\"\n) {\n              openxlsx::writeData(wb, \nsheet\n = \n1\n, \nx\n = ii, \n                                  \nstartCol\n = i, \nstartRow\n = j + \n1\n, \nheaderStyle\n = header_bold)\n            }\n          }\n          \nelse\n {\n            openxlsx::writeData(wb, \nsheet\n = \n1\n, \nx\n = r[j, \n                                                     i], \nstartCol\n = i, \nstartRow\n = j + \n1\n)\n          }\n        }\n      }\n      \nelse\n {\n        openxlsx::writeData(wb, \nsheet\n = \n1\n, \nx\n = r[, i], \n                            \nstartCol\n = i, \nstartRow\n = \n2\n)\n      }\n    }\n    openxlsx::saveWorkbook(wb, xlsx, \noverwrite\n = TRUE)\n  }\n  invisible(r)\n}\n\n", "Tag": "算法分析"}
{"Answer": "\nn = int(input())\nfor i in range(n):\n    row = list(range(n * i + 1,(i + 1) * n + 1))\n    if i % 2 == 1:\n        row = row[::-1]\n    print(row)\n\n5\n[1, 2, 3, 4, 5]\n[10, 9, 8, 7, 6]\n[11, 12, 13, 14, 15]\n[20, 19, 18, 17, 16]\n[21, 22, 23, 24, 25]\n", "Konwledge_Point": "线性规划简介", "Question": "关于#python#的问题\n螺旋矩阵形式如下：必须按照同等形势\n5阶螺旋矩阵：\n【12345】\n【109876】\n[1112131415】\n【2019181716】\n【2122232425】\n求 n 阶螺旋矩阵的行列式。 n 由用户输入，程序输出螺旋矩阵及其行列式。\n要求：行列式的求法是线性代数的知识；螺旋矩阵的生成必须采用列表递推式；本程序不能使用除了 random 库之外的其它库", "Tag": "算法分析"}
{"Answer": "个数：从1000--500--250--125--63--37 -- 19--9--5--3--2，第一个比较的数是第1000个数据，所以是11个单元", "Konwledge_Point": "线性规划简介", "Question": "数据结构导论数列二分查找法\n\n\n为什么选C？", "Tag": "算法分析"}
{"Answer": "数据比较可以简单的画一个图.\n。但是根据查找的大小。有些节点是大可不必画的。", "Konwledge_Point": "线性规划简介", "Question": "数据结构二叉排序树查找元素比较次数\n这样的题该如何做，求详细步骤", "Tag": "算法分析"}
{"Answer": "这个用pandas处理，用pandas读取excel然后处理数据就行了，pandas教程可以网上搜索一下，具体的代码这个要结合数据才能写得出。", "Konwledge_Point": "线性规划简介", "Question": "stata数据排序分组求均值\n将公司的四个指标分年度排序分成十组并赋值1-10，然后加总除以4得到平均值，这个数据都要经过怎么处理？代码要怎么写啊？\n实在是看不懂这个数据具体是怎么操作的，希望有大神能给出具体的解答，谢谢各位了😭", "Tag": "算法分析"}
{"Answer": "机器人的回答笑死了，也不检查一下。。。哪里有什么乱七八糟的文字。第9题环形队列的话可以入队，不然怎么叫环形。环形队列只需要检查队列不为空时（head和rear都是0），head和rear是否相等，相等则说明队列已满，不能入队。rear指针在i,j,k,l,m入队后就指向了0，因为head和rear并不相同，所以可以入队。", "Konwledge_Point": "线性规划简介", "Question": "假设CQ[0..10]是一个环形队列,初始状态为front=rear=0\n假设CQ[0..10]是一个环形队列,初始状态为front=rear=0\n这两个第八题是不可以入队第二个可以入队吗", "Tag": "算法分析"}
{"Answer": "5", "Konwledge_Point": "线性规划简介", "Question": "数据结构导论二叉树度数\n怎么做求解答", "Tag": "算法分析"}
{"Answer": "这是因为B样条曲线是由多个B样条基函数组成的，每个B样条基函数只影响以该点为中心的邻近4段曲线，因此改动特征多边形上的一个顶点，也只会影响以该点为中心的邻近4段曲线。", "Konwledge_Point": "线性规划简介", "Question": "b样条问题b样条b样条\n根据B样条曲线表达式及B样条基函数的性质，分析对于三次B-样条曲线，改动特征多边形上的一个顶点，为何至多只影响以该点为中心的邻近4段曲线？", "Tag": "算法分析"}
{"Answer": "数据结构和算法课程是在给你灌输一些概念和培养解决问题的思维以及了解它们的优缺点等等，在以后实际工作中很大可能你是不会自己去实现各种数据结构和算法，而是使用别人已经写好了的经过测试和优化过的库，不过学过数据结构和算法等基础课，你应该大概知道各种数据结构和算法是怎样工作的。", "Konwledge_Point": "线性规划简介", "Question": "数据结构抽象数据类型的表示与实现和线性表的类型定义？\n最近在学数据结构，现在学到了第2.3章线性表的类型定义，然后课本上就突然给出了图一和图二的线性表的抽象数据类型定义，但是我有点懵，书上给的这些东西是干嘛的呢？是为了方便在本书的以后讲解中描述关于线性表的操作吗？还是以后在C语言等程序中就可以直接使用？这个用记吗？第三张和第四张图片里关于抽象数据类型的表示与实现是假如在c语言中定义了，以后就可以在c语言中使用了吗？我c语言还差指针还有结构体和共同体没有学，比如第四张图片里的C.Realpart=X，这是啥玩意？还有struct这是啥？结构体吗？能不能帮我讲一讲这几张图片啊\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "def line(a:tuple, b:tuple)->list[tuple]:\n    if a[0]==b[0]:return [(a[0],a[1]+i) for i in range(b[1]-a[1]+1)]\n    if a[1]==b[1]:return [(a[0]+i,a[1]) for i in range(b[0]-a[0]+1)]\n    if a[0]>b[0]:a,b=b,a\n    return [(a[0]+i, int(a[1]+i*(b[1]-a[1])/(b[0]-a[0]))) for i in range(b[0]-a[0]+1)]\n\na = (10,10)\nb = (40,10)\nc = (20,30)\n\nac=line(a,c)\nbc=line(b,c)\nab=line(a,b)\n\nfor x, y in zip(ac+bc[1:], ab):\n    for i in range(x[1]-y[1]+1):\n        print((y[0],y[1]+i))\n", "Konwledge_Point": "线性规划简介", "Question": "关于#python#的问题：要求通过python编程，遍历三角区域内所有的整数点坐标\npython遍历一个区域内的全部整数点并打印出来\n\n\n看图\n\n\n已知条件：在直角坐标系内有一个三角形，并直到三角形三个点的坐标位置。\n要求通过python编程，遍历三角区域内所有的整数点坐标，并打印出来。\n简洁快速，可以遍历方向都可以只要能遍历出来并打印即可", "Tag": "算法分析"}
{"Answer": "以下内容部分参考ChatGPT模型：\n\n将print输出的结果显示在tkinter界面上，可以使用tkinter的Label组件来实现。在CNN_yuce函数中，可以创建一个Label组件并将print输出的结果赋值给它的text属性，然后将该组件放置在界面上即可。例如：\ndef CNN_yuce():\n    global e1, pred, root,predict_class\n    name_dict = {\"Uninfected\":0, \"Parasitized\":1}\n\n    ...\n\n    # 将预测结果转化为概率值\n    result = np.squeeze(model.predict(img1))\n    predict_class = np.argmax(result)\n    print(result)\n\n    result = np.argmax(result[0])  # 取出预测结果中概率最大的元素索引值\n    for k, v in name_dict.items():  # 将类别由数字转换为名称\n        if result == v:  # 如果预测结果等于v, 打印出名称\n            print(\"预测结果:\", k)  # 打印出名称\n\n    # 创建Label组件并将预测结果赋值给它的text属性\n    pred = \"预测结果：\" + k\n    e1 = tk.Label(root, text=pred, font=('Arial', 16))\n    e1.place(x=500, y=370)\n\n    ...\n\n这样就可以在界面上显示print输出的结果了。\n\n如果我的建议对您有帮助、请点击采纳、祝您生活愉快", "Konwledge_Point": "线性规划简介", "Question": "怎么将print中的结果显示在tkinter界面上\n我想在我的tkinter界面上显示我print出的结果，但是我不知道怎么改。\n在网上查的，也没有查到说的清楚点的。\n下面是我的代码：\n\n\nimport\n tkinter \nas\n tk\n\nimport\n tensorflow \nas\n tf\n\nimport\n matplotlib.pyplot \nas\n plt\n\nfrom\n matplotlib.backends.backend_tkagg \nimport\n FigureCanvasTkAgg\n\nimport\n numpy \nas\n np\n\nfrom\n tkinter \nimport\n *\n\nimport\n tkinter.filedialog  \n# 注意次数要将文件对话框导入\n\n\nfrom\n PIL \nimport\n Image\n\nfrom\n tensorflow.python.keras \nimport\n models, layers\n\n\ndef\n \nCNN_yuce\n():\n    \nglobal\n e1, pred, root,predict_\nclass\n\n    \nname_dict\n = {\n\"Uninfected\"\n:\n0\n, \n\"Parasitized\"\n:\n1\n}\n\n    fig = plt.figure(figsize=(\n2\n,\n2\n),dpi=\n100\n)\n    \n# 从本地选择一个文件，并返回文件的目录\n\n    \n# filenames = tkinter.filedialog.askopenfile()#形成一共io流 的文件名称\n\n    filename = tk.filedialog.askopenfilename(title=\nu'加载图片'\n,initialdir=(()))\n#只保留文件名和后缀\n\n    \nprint\n(filename)\n\n    \n# model_save_path = 'D:/ningyupeng/pythonProject/Graduation Project V1.0/my_model/variables/variables.ckpt'\n\n\n    model = tf.keras.models.Sequential([\n        tf.keras.layers.Flatten(),\n#Flatten-变成一维数组\n\n        tf.keras.layers.Dense(\n128\n, activation=\n'relu'\n),\n#relu函数可以解决 梯度消失问题 是线性的\n\n        tf.keras.layers.Dense(\n2\n, activation=\n'softmax'\n)])\n# 2个类所以2个神经元 softmax只用在最后一层 可以让最后输出的概率在0-1之间\n\n\n    \n# model.load_weights('checkpoint-05e-val_acc_0.58.hdf5')#读取文件\n\n    models.load_model(\n\"my_model\"\n)\n\n    \n# 加载测试图片\n\n    img = Image.\nopen\n(filename)\n    \n# 将图片resize到224x224大小\n\n    img = img.resize((\n128\n, \n128\n), Image.ANTIALIAS)\n    \n# 将灰度图转化为RGB模式\n\n    img = img.convert(\n\"RGB\"\n)\n\n    plt.imshow(img)\n    \n# 归一化\n\n    img1 = np.array(img) / \n255.\n\n    \n# 将图片增加一个维度，目的是匹配网络模型\n\n    img1 = (np.expand_dims(img1, \n0\n))\n    \n# 将预测结果转化为概率值\n\n    result = np.squeeze(model.predict(img1))\n    predict_class = np.argmax(result)\n    \n# pred = tf.argmax(result, axis=1)#求最大值得出最后识别出来的数\n\n    \n# print(inverse_dict[int(predict_class)],result[predict_class])\n\n    \n# 将预测的结果打印在图片上面\n\n    \n# plt.title([inverse_dict[int(predict_class)],result[predict_class]])\n\n    \nprint\n(result)\n\n    result = np.argmax(result[\n0\n])  \n# 取出预测结果中概率最大的元素索引值\n\n    \nfor\n k, v \nin\n name_dict.items():  \n# 将类别由数字转换为名称\n\n        \nif\n result == v:  \n# 如果预测结果等于v, 打印出名称\n\n            \nprint\n(\n\"预测结果:\"\n, k)  \n# 打印出名称\n\n\n    e1 = tk.Label(root, text=pred, font=(\n'Arial'\n, \n16\n))\n#显示预测结果\n\n    e1.place(x=\n500\n, y=\n370\n)\n\n    canvas = FigureCanvasTkAgg(fig, master=root)\n#渲染器 在画布上放置图片\n\n    canvas.draw()\n    canvas.get_tk_widget().place(x=\n550\n,y=\n50\n)\n\ndef\n \npicture\n():\n    \nglobal\n root\n    root = Tk()\n    root.wm_title(\n\"细胞图像疟疾检测\"\n)\n    root.geometry(\n'1000x650'\n)\n\n    ask = tk.Button(root, text=\n\"预测\"\n, width=\n10\n, command=CNN_yuce)\n    ask.place(x=\n600\n, y=\n90\n)\n\n    root.mainloop()\n\n\nif\n __name__ == \n'__main__'\n:\n    picture()\n\n\n\n\n\n\n\n它运行后print的结果不在界面上，下面是print结果截图，和界面的截图。\n\n\n\n\n\n\n我应该怎么更改。", "Tag": "算法分析"}
{"Answer": "在 changecolor 方法中的 setStrokeColor 方法调用失败，可能是由于前端未正确获取到线性覆盖物对象或未正确设置线性覆盖物的属性。可以在方法调用之前使用 console.log 或者 Vue.js 的开发工具来打印相关对象，以确保正确获取到了对应的对象，可以在 changecolor 方法中添加一些调试信息或者直接在浏览器的开发者工具中调试代码，以确保 setStrokeColor 方法可以被正确调用", "Konwledge_Point": "线性规划简介", "Question": "vue根据后端数据动态修改界面组件属性的问题\n最近在用Vue-element-admin调用百度地图，创建了许多线性覆盖物：\n\n\n<\nscript\n>\n\n\nimport\n speedApi \nfrom\n \n'@/api/speedsearch'\n\n\nexport\n \ndefault\n \n{\n \n name\n: \n'BmapDemo'\n,\n  data() {\n    \nreturn\n {\n      options: [{\n        value: \n'15'\n,\n        label: \n'15分后'\n\n      }\n, \n{\n        value: \n'30'\n,\n        label: \n'30分后'\n\n      }\n, \n{\n        value: \n'45'\n,\n        label: \n'45分后'\n\n      }\n, \n{\n        value: \n'60'\n,\n        label: \n'60分后'\n\n      }\n],\n      \nvalue\n: \n''\n,\n      \nspeedlist\n: \n{\n       \n id\n: \n''\n,\n        fif: \n''\n,\n        thir: \n''\n,\n        fou: \n''\n,\n        six: \n''\n\n      }\n\n    }\n  },\n  mounted() \n{\n    // \n2\n. 创建地图示例\n    var \nmap\n = new \nwindow\n.BMapGL.Map(\n'container'\n)\n    // \n3\n. 设置中心点坐标\n    var point = new \nwindow\n.BMapGL.Point(\n116.400747\n, \n39.983412\n)\n    // \n4\n. 地图初始化，同时设置地图展示级别\n    \nmap\n.centerAndZoom(point, \n15\n)\n    // \n5\n. 开启鼠标滚轮缩放\n    \nmap\n.enableScrollWheelZoom\n(true\n)\n    var scaleCtrl = new \nwindow\n.BMapGL.ScaleControl() // 添加比例尺控件\n    \nmap\n.addControl(scaleCtrl)\n    var zoomCtrl = new \nwindow\n.BMapGL.ZoomControl() // 添加缩放控件\n    \nmap\n.addControl(zoomCtrl)\n    var cityCtrl = new \nwindow\n.BMapGL.CityListControl() // 添加城市列表控件\n    \nmap\n.addControl(cityCtrl)\n    \nmap\n.addEventListener(\n'click'\n, (data) => {\n      // point包含了经纬度\n      console.log(data.point)\n      // polyline17.setStrokeColor(\n'green'\n)\n    }\n)\n    \nvar\n polyline1 = \nnew\n \nwindow\n.\nBMapGL\n.\nPolyline\n([\n      \nnew\n \nwindow\n.\nBMapGL\n.\nPoint\n(\n116.360431\n, \n39.992534\n),\n      \nnew\n \nwindow\n.\nBMapGL\n.\nPoint\n(\n116.360899\n, \n39.987103\n)\n    ],\n    \n{ strokeColor: \n'blue'\n, strokeWeight: \n6\n, strokeOpacity: \n0\n.\n5\n }\n\n    )\n    map.\naddOverlay\n(polyline1)\n    \nvar\n polyline2 = \nnew\n \nwindow\n.\nBMapGL\n.\nPolyline\n([\n      \nnew\n \nwindow\n.\nBMapGL\n.\nPoint\n(\n116.360899\n, \n39.987103\n),\n      \nnew\n \nwindow\n.\nBMapGL\n.\nPoint\n(\n116.360827\n, \n39.982182\n)\n    ],\n    \n{ strokeColor: \n'blue'\n, strokeWeight: \n6\n, strokeOpacity: \n0\n.\n5\n }\n\n    )\n    map.\naddOverlay\n(polyline2)\n    \nvar\n polyline3 = \nnew\n \nwindow\n.\nBMapGL\n.\nPolyline\n([\n      \nnew\n \nwindow\n.\nBMapGL\n.\nPoint\n(\n116.360827\n, \n39.982182\n),\n      \nnew\n \nwindow\n.\nBMapGL\n.\nPoint\n(\n116.361438\n, \n39.973778\n)\n    ],\n    \n{ strokeColor: \n'blue'\n, strokeWeight: \n6\n, strokeOpacity: \n0\n.\n5\n }\n\n    )\n    map.\naddOverlay\n(polyline3)\n    \nvar\n polyline17 = \nnew\n \nwindow\n.\nBMapGL\n.\nPolyline\n([\n      \nnew\n \nwindow\n.\nBMapGL\n.\nPoint\n(\n116.387632\n, \n39.983316\n),\n      \nnew\n \nwindow\n.\nBMapGL\n.\nPoint\n(\n116.38677\n, \n39.974525\n)\n    ],\n    \n{ strokeColor: \n'blue'\n, strokeWeight: \n6\n, strokeOpacity: \n0\n.\n5\n }\n\n    )\n    map.\naddOverlay\n(polyline17)\n    \nvar\n polyline16 = \nnew\n \nwindow\n.\nBMapGL\n.\nPolyline\n([\n      \nnew\n \nwindow\n.\nBMapGL\n.\nPoint\n(\n116.386626\n, \n39.988457\n),\n      \nnew\n \nwindow\n.\nBMapGL\n.\nPoint\n(\n116.387632\n, \n39.983316\n)\n    ],\n    \n{ strokeColor: \n'blue'\n, strokeWeight: \n6\n, strokeOpacity: \n0\n.\n5\n }\n\n    )\n    map.addOverlay(polyline16)\n  },\n  methods: \n{\n    changecolor\n(id\n, speed) {\n      \nif\n (speed >= \n5\n) {\n        \nwindow\n[\n'polyline'\n +\n id\n].setStrokeColor(\n'green'\n)\n      }\n \nelse\n \nif\n (speed >= \n2\n && speed < \n5\n) \n{\n        \nwindow\n[\n'polyline'\n +\n id\n].setStrokeColor(\n'yellow'\n)\n      }\n \nelse\n \n{\n        \nwindow\n[\n'polyline'\n +\n id\n].setStrokeColor(\n'red'\n)\n      }\n\n    },\n    paintmap() \n{\n      speedApi.paintmap(this.\nvalue\n).\nthen\n(response => {\n        this.speedlist = response.data.row\n        console.log(this.speedlist)\n        \nfor\n (var i = \n0\n; i < this.speedlist.length; i++) {\n          \nif\n (this.speedlist[i].fif != null) {\n            \nwindow\n.console.log(this.speedlist[i]\n.id\n)\n            \nwindow\n.console.log(this.speedlist[i].fif)\n            this.changecolor(this.speedlist[i]\n.id\n, this.speedlist[i].fif)\n          }\n \nelse\n \nif\n (\nthis\n.\nspeedlist\n[i].\nthir\n != \nnull\n) \n{\n            \nwindow\n.console.log(this.speedlist[i]\n.id\n)\n            \nwindow\n.console.log(this.speedlist[i].thir)\n            this.changecolor(this.speedlist[i]\n.id\n, this.speedlist[i].thir)\n          }\n \nelse\n \nif\n (\nthis\n.\nspeedlist\n[i].\nfou\n != \nnull\n) \n{\n            \nwindow\n.console.log(this.speedlist[i]\n.id\n)\n            \nwindow\n.console.log(this.speedlist[i].fou)\n            this.changecolor(this.speedlist[i]\n.id\n, this.speedlist[i].fou)\n          }\n \nelse\n \n{\n            \nwindow\n.console.log(this.speedlist[i]\n.id\n)\n            \nwindow\n.console.log(this.speedlist[i].six)\n            this.changecolor(this.speedlist[i]\n.id\n, this.speedlist[i].six)\n          }\n\n        }\n      })\n    }\n  }\n}\n\n\n\n\n\n\n\n我的method里的changecolor是用来根据后端传回的ID和速度修改前端对应线性覆盖物的颜色的，但是运行一直报错，想请教下该怎么修改这个方法。\n这个是报错的内容", "Tag": "算法分析"}
{"Answer": "\n这是代码块\n\n\nimport matplotlib.pyplot as plt\n\nimport numpy as np\n\n# 生成示例数据\nnp.random.seed(0)\nx = np.random.rand(20)\ny = 2 * x + 1 + np.random.randn(20) * 0.1\n\n# 计算回归线\ncoef = np.polyfit(x, y, 1)\nline_x = np.linspace(0, 1, 2)\nline_y = np.polyval(coef, line_x)\n\n# 绘制回归图和数据点\nplt.figure()\nplt.scatter(x, y)\n\n# 绘制回归线\nplt.plot(line_x, line_y, c='g')\n\n# 绘制每个数据点到回归线的距离\nfor i in range(len(x)):\n    x_val = x[i]\n    y_val = y[i]\n    y_pred = np.polyval(coef, x_val)\n    plt.plot([x_val, x_val], [y_val, y_pred], c='r')\n\nplt.show()\n\n", "Konwledge_Point": "线性规划简介", "Question": "画出线性回归图每个点到直线的距离\n怎么画出每个点到直线的距离\n\n\nimport\n numpy as np\n\nimport\n matplotlib.pyplot as plt\nfrom scipy \nimport\n stats\n\n\n# 构造训练数据\n\n\nx\n = np.arange(\n0\n., \n10\n., \n0.2\n)\n\nm\n = len(x)\n\nx0\n = np.full(m, \n1.0\n)\n\ninput_data\n = np.vstack([x0, x]).T\n\ntarget_data\n = \n2\n * x + \n5\n + np.random.randn(m)\n\n\n# 终止条件\n\n\nloop_max\n = \n10000\n  \n# 最大迭代次数\n\n\nepsilon\n = \n1\ne-\n3\n    \n# 收敛条件最小值\n\n\n\n# 初始化权值\n\nnp.random.seed(\n0\n)\n\ntheta\n = np.random.randn(\n2\n)\n\nalpha\n = \n0.001\n  \n# 步长\n\n\ndiff\n = \n0\n.\n\nerror\n = np.zeros(\n2\n)\n\ncount\n = \n0\n  \n# 循环次数\n\n\nfinish\n = \n0\n  \n# 终止标志\n\n\n\n# 迭代\n\nwhile count < loop_max:\n    count += \n1\n\n    \n# 在标准梯度下降中，权值更新的每一步对多个样例求和，需要更多的计算\n\n    \nsum_m\n = np.zeros(\n2\n)\n    for i \nin\n range(m):\n        \ndif\n = (np.dot(theta, input_data[i]) - target_data[i]) * input_data[i]\n        \n# 当alpha取值过大时,sum_m会在迭代过程中会溢出\n\n        \nsum_m\n = sum_m + dif\n\n    \n# 注意步长alpha的取值,过大会导致振荡\n\n    \ntheta\n = theta - alpha * sum_m\n\n    \n# 判断是否已收敛\n\n    \nif\n np.linalg.norm(theta - error) < epsilon:\n        \nfinish\n = \n1\n\n        break\n    \nelse\n:\n        \nerror\n = theta\n\n    print('迭代次数 = %d' % count, '\\t w:', theta)\nprint('迭代次数 = %d' % count, '\\t w:', theta)\n\n\n# 用scipy线性回归进行检查\n\nslope, intercept, r_value, p_value, \nslope_std_error\n = stats.linregress(x, \n                                                                       target_data)\nprint('截距 = %s 斜率 = %s' % (intercept, slope))\n\n\n# 用plot进行展示\n\nplt.plot(x, target_data, 'b*')\nplt.plot(x, theta[\n1\n] * x + theta[\n0\n], 'r')\nplt.xlabel(\n\"x\"\n)\nplt.ylabel(\n\"y\"\n)\nplt.show()\n\n\n", "Tag": "算法分析"}
{"Answer": "运行界面截个图看看呢，除了这个press any key to continue，还有啥？", "Konwledge_Point": "线性规划简介", "Question": "这个程序是顺序表（c++），建立学生信息表，现在的问题是程序不报错但是会出现’press any key to continue”\n\n\n\n\n’press any key to continue” ’press any key to continue”\n\n", "Tag": "算法分析"}
{"Answer": "summarize * summarize salary age comten sales profits mktvalbysort grad : summarize ceotengraph hbox salary\ngen losalary = log(salary)graph hbox losalary5. scatter salary sales6. scatter sales profits salary, mstyle(p9 p8)7. scatter sales profits salary, msymbol(O X p) mcolor(green blue black) msize(medium medium medium)8.  scatter sales profits salary, c(l) legend(pos(5) ring(0) col(1) lab(1 “ sales  ”) lab(2 “ profits ”)\n\n)9. quietly regress salary sales\n\n. predict hat\n. predict stdf\n. generate lo=hat-1.96*stdf\n. generate hi=hat+1.96*stdf\n. scatter salary sales || line hat lo hi sales , pstyle(p2 p3 p3) sort\n scatter salary sales || lfit salary sales", "Konwledge_Point": "线性规划简介", "Question": "用stata进行统计图形\n用stata\n文件CEOSAL2.dta包含了177位首席执行官的数据，可以用来考查企业业绩对CEO薪水的影响。\n  要求：\n  1.描述整个数据文件，获得对变量的基本理解。\n2.对salary、age、comten、sales、profits、mktval等5个变量进行统计描述，要求必须包含最大值、最小值和平均数3个统计量。\n3.要求对研究生和非研究生（变量是grade）CEO进行对比描述。\n4.利用箱线图找出salary和log(salary)的可疑异常值。\n5.绘制salary和sales的散点图。\n6.绘制salary和sales以及salary与profits的散点图，要求前者使用整体样式p9，后者使用整体样式p8.\n7.绘制salary和sales以及salary与profits的散点图，要求散点图形状前者选择实心圆，后者选择大写字母X；散点颜色前者选择绿色，后者选择蓝色；散点大小均选择中等。\n8.绘制salary和sales以及salary与profits的散点图，要求将图例放置在五点钟方向，同时图例排成一列。\n9.通过散点图和曲线图的复合来绘制salary对sales一次线性回归的95%的预测置信区间。\n10绘制复合图，包括salary对sales的散点图以及salary对sales的一次拟合图。", "Tag": "算法分析"}
{"Answer": "你说的没错，直接选择排序的时间复杂度是O(n^2)，而不是O(n)。因此，如果题目中要求时间复杂度为O(n)的排序方法，直接选择排序并不符合要求。\n另外，在稳定性方面，直接选择排序是不稳定的，因为在选择最小元素的过程中，可能会破坏相同元素之间的顺序关系。例如，在排序序列[5, 8, 5, 2, 9]中，第一次选择最小元素2会把第一个5和2交换位置，因此两个5的相对顺序被破坏了。\n因此，题目中说时间复杂度为O(n)的排序方法不稳定，很可能是错别字或者表述不准确，应该是说某个特定的O(n)排序方法不稳定，而不是说所有O(n)排序方法都不稳定。", "Konwledge_Point": "线性规划简介", "Question": "在时间复杂度为O(n)的排序方法中\n在时间复杂度为O(n)的排序方法中，（）排序方法是不稳定的。\n这个怎么是直接选择排序，它的时间复杂度不是O(n平方)吗‘", "Tag": "算法分析"}
{"Answer": "用最小二乘法或梯度下降法来比较和判断。case {1,'l','linear'}    N = size(x,1);    bp = unique([1; double(bp(:)); N]);   % Include both endpoints    bp = bp(bp >= 1 & bp <=N);   % Should error in the future    lbp = length(bp);    % Build regressor with linear pieces + DC    a = zeros(N,lbp,class(x));    a(1:N,1) = (1:N)./N;    for k = 2:(lbp-1)        M = N - bp(k);        a((bp(k)+1):end,k) = (1:M)./M;    end    a(1:N,end) = 1;    y = x - a*(a\\x);   % Remove best fit", "Konwledge_Point": "线性规划简介", "Question": "min f=||ax+bv³||2，迭代求a,b参数，x,v是自变量\n如题，x,v是其它函数g(x,v)的值，g(x,v)已知且只能求出数值解，要用什么优化办法得到a,b参数，使得目标函数最小啊，就主要不知道x,v数值很多的情况下怎么优化。我看的优化方法都是a,b已知，求x,v的，比如f=3x+2v³这种，", "Tag": "算法分析"}
{"Answer": "以下内容部分参考ChatGPT模型：\n\n在使用Python中linregress函数做线性回归时，可以使用pandas库中的fillna()函数将缺失值填充为0或者均值、中位数等统计量。在进行线性回归时，需要将缺失值对应的数据点剔除掉，可以使用numpy库中的isnan()函数将缺失值对应的位置找出来，然后使用pandas库中的dropna()函数将对应的数据点剔除掉。下面是一个简单的例子：\nimport pandas as pd\nimport numpy as np\nfrom scipy.stats import linregress\n\n# 创建一个时间序列数据，包含缺失值\ndata = pd.Series([1, 2, np.nan, 4, 5, 6, np.nan, 8, 9, 10])\n\n# 将缺失值填充为0\ndata = data.fillna(0)\n\n# 找出缺失值对应的位置，剔除掉\nmask = np.isnan(data)\nx = np.arange(len(data))[~mask]\ny = data[~mask]\n\n# 进行线性回归\nslope, intercept, r_value, p_value, std_err = linregress(x, y)\n\n在上面的例子中，我们将缺失值填充为0，然后使用isnan()函数找出缺失值对应的位置，使用~mask可以将True和False进行反转，得到非缺失值对应的位置，然后从原始数据中取出对应的x和y，进行线性回归。\n\n如果我的建议对您有帮助、请点击采纳、祝您生活愉快", "Konwledge_Point": "线性规划简介", "Question": "Python用linregress时，我有缺失值，改怎么处理\n在使用Python中linregress函数做线性回归时，我的时间序列数据中有缺失值，而且不同点的缺失值不一样，该怎么处理", "Tag": "算法分析"}
{"Answer": "这类问题默认都来用顺序查询，需要要求折半回明确表示。200/4=50块（1+50）/2=25.5（1+4）/2=2.5这是查找成功的情况！查找失败是（1+51+1+5）/2=29", "Konwledge_Point": "线性规划简介", "Question": "一个文件包含了200个记录，若采用分块查找法，每块长度为4，则平均查找长度为\n一个文件包含了200个记录，若采用分块查找法，每块长度为4，则平均查找长度为（28）。\n计算这个题目，它又没说是顺序查找还是折半查找所在块，", "Tag": "算法分析"}
{"Answer": "基于Monster 组和GPT的调写：下面是一个简单的例子，展示了如何在C++中使用Eigen库求解一个稀疏线性方程组：\n#include <Eigen/Sparse>\n#include <Eigen/Dense>\n\nint main()\n{\n    // 创建稀疏矩阵和向量\n    Eigen::SparseMatrix<double> A(10, 10);\n    Eigen::VectorXd b(10);\n\n    // 设置矩阵和向量的值\n\n    // ...\n\n    // 创建求解器并求解方程组\n    Eigen::SparseLU<Eigen::SparseMatrix<double>> solver;\n    solver.analyzePattern(A);\n    solver.factorize(A);\n    Eigen::VectorXd x = solver.solve(b);\n\n    return 0;\n}\n\n\n\n接下来，要把这个求解稀疏线性方程组的方法封装成dll，在C#程序中调用。先要创建一个C++的动态链接库，其中包含你的求解方法。具体的步骤包括：\n创建一个新的C++项目，选择“DLL”作为项目类型。在项目中添加您的求解方法的源代码。 在项目属性中设置“生成->配置类型”为“动态库(.dll)”，以及其他必要的设置，例如输出路径等。\n接下来要在C#程序中调用这个dll。具体的步骤包括：\n在C#程序中声明DllImport，以便能够使用外部的dll。创建一个C#类，其中包含您要调用的C++函数的签名。 在C#程序中调用这个C++函数。\n下面是一个简单的例子，展示了如何在C#程序中调用你的C++函数：\nusing System.Runtime.InteropServices;\n\npublic static class MyDll\n{\n    [DllImport(\"MyDll.dll\")]\n    public static extern void SolveSparseLinearEquation(\n        [In] int n,\n        [In] double[] A,\n        [In] int[] ia,\n        [In] int[] ja,\n        [In] double[] b,\n        [Out] double[] x\n    );\n}\n\npublic class Example\n{\n    public static void Main()\n    {\n        // 创建稀疏矩阵和向量\n        int n = 10;\n        double[] A = new double[10 * 10];\n        int[] ia = new int[10 + 1];\n        int[] ja = new int[10 * 5];\n        double[] b = new double[10];\n        double[] x = new double[10];\n\n        // 设置矩阵和向量的值\n\n        // ...\n\n        // 调用C++函数求解方程组\n        MyDll.SolveSparseLinearEquation(n, A, ia, ja, b, x);\n\n        // 处理求解结果\n\n        // ...\n    }\n}\n\n\n", "Konwledge_Point": "线性规划简介", "Question": "找C++ C#的有缘人指导\n想找一个会C++和C#的厉害的有缘人在线指导一下，最好还了解过Eigen库😭\n我现在需要用C++调用Eigen库，写一个求解稀疏线性方程组的方法，然后封装成dll在C#程序中调用，求指导😭快崩溃了", "Tag": "算法分析"}
{"Answer": "回归分析需要满足一些基本原则，以便保证结果的有效性和准确性。\n如果你使用家庭数据作为一个自变量，但是这些数据是由同一家庭内的多个个人数据累加起来的，这样的数据可能会存在共线性问题，因为两个变量相关性过高，导致估计的系数不可靠。\n此外，在使用多元回归分析时，也需要考虑独立性原则，即自变量间应该相互独立，不存在多重共线性问题。\n因此，如果你想使用家庭数据作为自变量，建议检验家庭数据和个人数据之间的关系，以确保不存在共线性问题。", "Konwledge_Point": "线性规划简介", "Question": "回归分析的自变量数据单位必须同一口径吗？\n在实证分析时运用到了charls数据库，数据库里面是家庭、个人以及社区三种标签，自变量一共有四组，其中三组是个人的数据，另外一组是家庭的数据，都是同一群人，家庭的数据是将同一家庭的个人数据累加起来了，回归分析也有结果，但是符合回归分析的原则吗？不知道有没有将问题讲清楚，希望大家可以帮个忙", "Tag": "算法分析"}
{"Answer": "要在COMSOL中显示线性传输比例图像，请按照以下步骤进行操作：\n点击“结果”选项卡，选择要显示图像的结果集。\n选择“表面绘图”或“体绘图”，具体取决于您想要绘制的图像类型。\n在“设置”窗口中，找到“可视化”选项卡并单击。\n在“颜色映射”下拉菜单中，选择“传输比例”。\n在“选择数据”下拉菜单中，选择“线性传输比例”。\n根据需要调整其他设置，例如最小值和最大值，颜色范围等。\n单击“确定”以应用更改并显示线性传输比例图像。如果您的结果显示为透射率或吸收率图像，您可以通过更改显示的结果类型来显示线性传输比例图像。在“结果”选项卡中，选择“切换结果类型”选项卡，然后选择“线性传输比例”作为结果类型。", "Konwledge_Point": "线性规划简介", "Question": "comsol的结果问题\n在comsol里怎么显示线性传输比例图像？结果显示图像为透射率吸收率，怎么添加线性传输比例图像？", "Tag": "算法分析"}
{"Answer": "可以贴一下代码看看\n不能新写回答，补充：左、中、右对应的三个LinearLayout需要用一个父级LinearLayout包裹，并设置orientation属性为horitantal", "Konwledge_Point": "线性规划简介", "Question": "利用andriod studio编写线性布局\n\n\n图一是我需要写出来的样子，图二是我写出来的样子，我不能理解为什么这个不能全部显示出来😭", "Tag": "算法分析"}
{"Answer": "笑死..稍等,我问问他有没有详细答案", "Konwledge_Point": "线性规划简介", "Question": "Linear algebra, orthogonal线性代数\n\n\n能不能解释一下为什么4.1B(c)的答案是(1,-3,-4)?", "Tag": "算法分析"}
{"Answer": "答案代码如下：\nimport numpy as np\n\n# 定义矩阵A\nA = np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\n\n# 求逆矩阵\nA_inv = np.linalg.inv(A)\n\n# 验证AA_inv = A_invA = I\nprint(np.dot(A, A_inv))\nprint(np.dot(A_inv, A))\n\n输出结果为：\n[[1. 0. 0.]\n [0. 1. 0.]\n [0. 0. 1.]]\n[[1. 0. 0.]\n [0. 1. 0.]\n [0. 0. 1.]]\n\n并且 $AA^{-1}=A^{-1}A=I$ 成立，证明矩阵 $A$ 的逆矩阵计算正确。", "Konwledge_Point": "线性规划简介", "Question": "Python求解线性代数的题\n假设有矩阵 $A=\\begin{bmatrix} 2 & 1 & 1 \\ 1 & 2 & 1 \\ 1 & 1 & 2 \\end{bmatrix}$，求矩阵 $A$ 的逆矩阵，并验证 $AA^{-1}=A^{-1}A=I$。", "Tag": "算法分析"}
{"Answer": "scipy库和matplotlib库，很快的", "Konwledge_Point": "线性规划简介", "Question": "非线性微分方程画图像\n", "Tag": "算法分析"}
{"Answer": "这俩是一样的吗？ 原式是不是不一样啊，这里少一个换行就少一个负号", "Konwledge_Point": "线性规划简介", "Question": "线性代数的一道小破题\n\n\n夸克里第三步到第四步是怎么来的，不应该是直接提出右下角的3*3矩阵吗\n\n\n\n\n以及我的这个解答有啥问题", "Tag": "算法分析"}
{"Answer": "", "Konwledge_Point": "线性规划简介", "Question": "Linear algebra, determinant线性代数\n\n\n这道题怎么做？", "Tag": "算法分析"}
{"Answer": "", "Konwledge_Point": "线性规划简介", "Question": "Linear algebra, projections线性代数\n\n\n4.2A 怎么算这个3 By 3 projection matrix P. 公式是划红线的这个\n\n\n\n\n但是在此题中，(At\nA)-1是2 by 2. A\nAt是3 by 3.怎么相乘？\n\n\n答案：\n\n", "Tag": "算法分析"}
{"Answer": "望采纳可以使用fsolve来解决这个问题，需要提供一个名为fun的函数，包含非线性方程组。函数的形式应该是这样的：\nfunction [f] = fun(x)\n    % x 是一个向量，包含未知变量 x, y 和 z 的值\n    % f 是包含方程的结果的向量，f(1) 对应第一个方程，f(2) 对应第二个方程，以此类推\n\n    % 您的方程组\n    f(1) = exp(x(1)) - (x(3) ./ x(2) - 1) / (x(3) / 18.3 - 1);\n    f(2) = exp(2 * x(1)) - (x(3) ./ x(2) - 1) / (x(3) / 29 - 1);\n    f(3) = exp(3 * x(1)) - (x(3) ./ x(2) - 1) / (x(3) / 47.2 - 1);\nend\n\n之后需要提供一个初始猜测值，然后调用fsolve。\nx0 = [1, 1, 1];  % 这是初始猜测值\nx = fsolve(@fun, x0);\n", "Konwledge_Point": "线性规划简介", "Question": "MATLAB 非线性三元方程求解\n建立logistics模型时，用前三组数据解出初值，x-r，y-x0,z-xm\nexp(x)=(z./y-1)./(z/18.3-1)\nexp(2\nx)=(z./y-1)./(z/29-1)\nexp(3\nx)=(z./y-1)./(z/47.2-1)", "Tag": "算法分析"}
{"Answer": "首先，v = 0时，rank=0，这个不需要解释了吧。当v 不等于0即为实矩阵时，M = v vT矩阵乘矩阵的转置最后得到是对称矩阵；对称矩阵的rank就是1根据rank的定义，对称矩阵nXn的rank等价1Xn矩阵的秩而，m × n 矩阵的秩不大于m且不大于n的一个非负整数，表示为 rk(A) ≤ min(m, n)，所以rank=1。\n望采纳！", "Konwledge_Point": "线性规划简介", "Question": "Linear algebra, transpose线性代数\n\n\n以下是答案：\n\n\n\n\n为什么rank不能是2？", "Tag": "算法分析"}
{"Answer": "是的，这段代码是在每个epoch结束后计算验证集的loss，上面的for循环中实际上每个step都更新了一次w和b", "Konwledge_Point": "线性规划简介", "Question": "有关线性回归代码的问题\n所以这里是用上面优化出来的w,b，根据这些数据来计算损失函数的嘛？", "Tag": "算法分析"}
{"Answer": "你是问怎么把下面第一个转化为第二个吗？第一个：1 2 3  5   02 4 8 12  63 6 7 13 -6第二个：1 2 3 5 00 0 2 2 60 0 0 0 0第一行A1：不变第二行A2：A2-2A1=0 0 2 2 6第三行A3：3A1-A3=0 0 2 2 6第二行等于第三行，所以第三行可以去掉因此结果为：1 2 3 5 00 0 2 2 60 0 0 0 0也可以写成：1 2 3 5 0(A1)0 0 1 1 3(A2)0 0 0 0 0(A3)对第一行进行处理：A1-3*A2=1 2 0 2 -9最终的结果就是：1 2 0 2 -90 0 1 1 30 0 0 0 0 ", "Konwledge_Point": "线性规划简介", "Question": "线性代数的问题，linear algebra\nAx = b is\nx1 + 2x2 + 3x2 + 5x4 = b1\n2x1 + 4x2 + 8x3 + 12x4 = b2\n3x1 + 6x2 + 7x3 + 13x4 = b3\nTurn [A b] to [R d]: special solutions from R, particular solution from d.\n\n\n正确答案的式子的右边是[-9 3 0] 就是b1 = -9, b2 = 3, b3 = 0。能解释一下为什么吗？\n\n\n这是问题，我想问的第五题：\n\n\n\n\n\n\n这是答案：\n\n", "Tag": "算法分析"}
{"Answer": "可以贴一下代码看看\n不能新写回答，补充：左、中、右对应的三个LinearLayout需要用一个父级LinearLayout包裹，并设置orientation属性为horitantal", "Konwledge_Point": "线性规划简介", "Question": "利用andriod studio编写线性布局\n\n\n图一是我需要写出来的样子，图二是我写出来的样子，我不能理解为什么这个不能全部显示出来😭", "Tag": "算法分析"}
{"Answer": "笑死..稍等,我问问他有没有详细答案", "Konwledge_Point": "线性规划简介", "Question": "Linear algebra, orthogonal线性代数\n\n\n能不能解释一下为什么4.1B(c)的答案是(1,-3,-4)?", "Tag": "算法分析"}
{"Answer": "答案代码如下：\nimport numpy as np\n\n# 定义矩阵A\nA = np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\n\n# 求逆矩阵\nA_inv = np.linalg.inv(A)\n\n# 验证AA_inv = A_invA = I\nprint(np.dot(A, A_inv))\nprint(np.dot(A_inv, A))\n\n输出结果为：\n[[1. 0. 0.]\n [0. 1. 0.]\n [0. 0. 1.]]\n[[1. 0. 0.]\n [0. 1. 0.]\n [0. 0. 1.]]\n\n并且 $AA^{-1}=A^{-1}A=I$ 成立，证明矩阵 $A$ 的逆矩阵计算正确。", "Konwledge_Point": "线性规划简介", "Question": "Python求解线性代数的题\n假设有矩阵 $A=\\begin{bmatrix} 2 & 1 & 1 \\ 1 & 2 & 1 \\ 1 & 1 & 2 \\end{bmatrix}$，求矩阵 $A$ 的逆矩阵，并验证 $AA^{-1}=A^{-1}A=I$。", "Tag": "算法分析"}
{"Answer": "scipy库和matplotlib库，很快的", "Konwledge_Point": "线性规划简介", "Question": "非线性微分方程画图像\n", "Tag": "算法分析"}
{"Answer": "这俩是一样的吗？ 原式是不是不一样啊，这里少一个换行就少一个负号", "Konwledge_Point": "线性规划简介", "Question": "线性代数的一道小破题\n\n\n夸克里第三步到第四步是怎么来的，不应该是直接提出右下角的3*3矩阵吗\n\n\n\n\n以及我的这个解答有啥问题", "Tag": "算法分析"}
{"Answer": "", "Konwledge_Point": "线性规划简介", "Question": "Linear algebra, determinant线性代数\n\n\n这道题怎么做？", "Tag": "算法分析"}
{"Answer": "", "Konwledge_Point": "线性规划简介", "Question": "Linear algebra, projections线性代数\n\n\n4.2A 怎么算这个3 By 3 projection matrix P. 公式是划红线的这个\n\n\n\n\n但是在此题中，(At\nA)-1是2 by 2. A\nAt是3 by 3.怎么相乘？\n\n\n答案：\n\n", "Tag": "算法分析"}
{"Answer": "望采纳可以使用fsolve来解决这个问题，需要提供一个名为fun的函数，包含非线性方程组。函数的形式应该是这样的：\nfunction [f] = fun(x)\n    % x 是一个向量，包含未知变量 x, y 和 z 的值\n    % f 是包含方程的结果的向量，f(1) 对应第一个方程，f(2) 对应第二个方程，以此类推\n\n    % 您的方程组\n    f(1) = exp(x(1)) - (x(3) ./ x(2) - 1) / (x(3) / 18.3 - 1);\n    f(2) = exp(2 * x(1)) - (x(3) ./ x(2) - 1) / (x(3) / 29 - 1);\n    f(3) = exp(3 * x(1)) - (x(3) ./ x(2) - 1) / (x(3) / 47.2 - 1);\nend\n\n之后需要提供一个初始猜测值，然后调用fsolve。\nx0 = [1, 1, 1];  % 这是初始猜测值\nx = fsolve(@fun, x0);\n", "Konwledge_Point": "线性规划简介", "Question": "MATLAB 非线性三元方程求解\n建立logistics模型时，用前三组数据解出初值，x-r，y-x0,z-xm\nexp(x)=(z./y-1)./(z/18.3-1)\nexp(2\nx)=(z./y-1)./(z/29-1)\nexp(3\nx)=(z./y-1)./(z/47.2-1)", "Tag": "算法分析"}
{"Answer": "首先，v = 0时，rank=0，这个不需要解释了吧。当v 不等于0即为实矩阵时，M = v vT矩阵乘矩阵的转置最后得到是对称矩阵；对称矩阵的rank就是1根据rank的定义，对称矩阵nXn的rank等价1Xn矩阵的秩而，m × n 矩阵的秩不大于m且不大于n的一个非负整数，表示为 rk(A) ≤ min(m, n)，所以rank=1。\n望采纳！", "Konwledge_Point": "线性规划简介", "Question": "Linear algebra, transpose线性代数\n\n\n以下是答案：\n\n\n\n\n为什么rank不能是2？", "Tag": "算法分析"}
{"Answer": "是的，这段代码是在每个epoch结束后计算验证集的loss，上面的for循环中实际上每个step都更新了一次w和b", "Konwledge_Point": "线性规划简介", "Question": "有关线性回归代码的问题\n所以这里是用上面优化出来的w,b，根据这些数据来计算损失函数的嘛？", "Tag": "算法分析"}
{"Answer": "参考GPT和自己的思路：\n使用非线性混合效应模型来预测锂电池剩余寿命是可行的。建议使用MATLAB中的工具箱，例如Statistics and Machine Learning Toolbox来构建和训练模型。在建模之前，需要根据实验数据，尤其是寿命数据来选择合适的非线性模型，以及确定混合效应。另外，还需要对数据进行预处理和特征工程，以保证模型的准确性和可靠性。", "Konwledge_Point": "线性规划简介", "Question": "关于#算法#的问题：利用非线性混合效应模型来预测锂电池剩余寿命预测可行吗(语言-matlab)\n利用非线性混合效应模型来预测锂电池剩余寿命预测可行吗？能不能提点建议？", "Tag": "算法分析"}
{"Answer": "你是问怎么把下面第一个转化为第二个吗？第一个：1 2 3  5   02 4 8 12  63 6 7 13 -6第二个：1 2 3 5 00 0 2 2 60 0 0 0 0第一行A1：不变第二行A2：A2-2A1=0 0 2 2 6第三行A3：3A1-A3=0 0 2 2 6第二行等于第三行，所以第三行可以去掉因此结果为：1 2 3 5 00 0 2 2 60 0 0 0 0也可以写成：1 2 3 5 0(A1)0 0 1 1 3(A2)0 0 0 0 0(A3)对第一行进行处理：A1-3*A2=1 2 0 2 -9最终的结果就是：1 2 0 2 -90 0 1 1 30 0 0 0 0 ", "Konwledge_Point": "线性规划简介", "Question": "线性代数的问题，linear algebra\nAx = b is\nx1 + 2x2 + 3x2 + 5x4 = b1\n2x1 + 4x2 + 8x3 + 12x4 = b2\n3x1 + 6x2 + 7x3 + 13x4 = b3\nTurn [A b] to [R d]: special solutions from R, particular solution from d.\n\n\n正确答案的式子的右边是[-9 3 0] 就是b1 = -9, b2 = 3, b3 = 0。能解释一下为什么吗？\n\n\n这是问题，我想问的第五题：\n\n\n\n\n\n\n这是答案：\n\n", "Tag": "算法分析"}
