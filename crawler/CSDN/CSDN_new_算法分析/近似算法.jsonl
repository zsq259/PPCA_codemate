{"Answer": "\nwhile 1:\n    n = int(input(\"输入数值\"))\n    if n<1:\n        break\n    else:\n        print('n的平方根为:', n**0.5)\n\n直接用x的0.5平方就得到平方根的值，没必要这么复杂，如有帮助，望采纳，谢谢", "Konwledge_Point": "近似算法", "Question": "求大家帮我看一下这道pyython的while题，新手真的卡住了呜呜呜\n用while语句完成程序逻辑，求如下算法可以求根号x的近似值。（例如，x为3时，算法输出约为1.7320508）。\n\n算法如下：\n\n输入x，若x为负数，则输出“无实数解”，算法结束；\n\n令g=x/2；\n\n通过如下公式计算误差值，如果\n∣x−g∗g∣<10 \n−6\n ，输出g，算法结束；\n\n否则，将（g+x/g）/2作为新的猜测值，仍记为g。\n\n重复步骤3和4", "Tag": "算法分析"}
{"Answer": "#include <math.h>\n\nconst double PI = acos(-1.0);\n\n听懂掌声", "Konwledge_Point": "近似算法", "Question": "求圆周率的近似值的代码\n题目要求如下：\n\n\n\n\n我根据公式写的算法是这样的：\n\n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\nusing\n \nnamespace\n std;\n\n\ndouble\n \njiecheng\n(\nint\n k)\n\n\n{\n    \ndouble\n s = \n1\n;\n    \nfor\n(\nint\n i = \n1\n; i <= k; i++)\n    {\n        s *= i;\n    }\n    \nreturn\n s;\n}\n\ndouble\n \nfenmu\n(\nint\n k)\n\n\n{\n    \nint\n s = \n1\n;\n    \nfor\n(\nint\n i = \n1\n; k >= \n0\n; k--, i += \n2\n)\n    {\n        s *= i;\n    }\n    \nreturn\n s;\n}\n\nint\n \nmain\n()\n\n\n{\n    \ndouble\n temp1 = \n1\n, temp2 = \n1\n;\n    \nint\n k = \n0\n;\n    \ndouble\n s = \n0\n;\n    \ndouble\n u;\n    cin >> u;\n    \nwhile\n(temp1 / temp2 >= u)\n    {\n    \n        s += temp1 / temp2;\n        k++;\n        temp1 = \njiecheng\n(k);\n        temp2 = \nfenmu\n(k);\n        \n    \n    }\n    cout << \nsetprecision\n(\n6\n) << \n2.0\n * s;\n    \nreturn\n \n0\n;\n}\n\n\n\n得出的结果接近题目给出的输出要求，但是不一样，请问是我的算法不够准确吗\n\n", "Tag": "算法分析"}
{"Answer": "\ndef fac(x):\n    if x == 1 or x == 0:\n        return x\n    else:\n        return x * fac(x - 1)\n\n\ni = 1\ns = 1\na = eval(input()) #精度\nwhile 1 / fac(i) >= a:\n    s = s + 1 / fac(i)\n    i += 1\ns = s + 1 / fac(i)\nprint(s)\n\n", "Konwledge_Point": "近似算法", "Question": "写了个输入计算精度，求e近似值的算法，请问下为什么会在第八行报错，及如何修改\n写了个输入计算精度，求e近似值的算法，请问下为什么会在第八行报错，及如何修改\n\n\n原算法：\n\n\ndef\n \nfactorial\n(\na\n):\n    \nif\n \na\n == \n1\n:\n        \nreturn\n \na\n\n    \nelse\n:\n        \nreturn\n (\na\n * \nfactorial\n(\na\n - \n1\n))\n\n\nb\n = \n1\n\n\nc\n = \n1\n\n\nwhile\n \nb\n <= \nint\n(\ninput\n()):\n    \nc\n = \nc\n + \n1\n / \nfactorial\n(\nb\n)\n\n    \nb\n = \nb\n + \n1\n\n\nprint\n(\nc\n)\n\n\n\n\n\n报错结果：\n\n\nline\n \n8\n, \nin\n \n    \nwhile\n b <= \nint\n(\ninput\n()):\nValueError: invalid literal \nfor\n \nint\n() \nwith\n base \n10\n: \n''\n\n\n", "Tag": "算法分析"}
{"Answer": "\n\n代码如下，供参考\n#include <stdio.h>\n#include <math.h>\nvoid main()\n{\n    float x, s, a;\n    int i;\n    printf(\"请输入x\\n\");\n    scanf(\"%f\", &x);\n    a = x;\n    s = 0;\n    for (i = 1; fabs(a) >= pow(10, -8); i++)\n    {\n        s = s + a;\n        a = -a * pow(x, 2) / (2 * i * (2 * i + 1));\n    }\n    printf(\"sinx = %.1f\\n\", s);\n}\n", "Konwledge_Point": "近似算法", "Question": "常用数值计算算法及其程序设计\n1．采用递推法计算sinx幂级数展开式的近似值，当通项绝对值小于10-8时停止累加。\n【测试数据】\n\n\n当输入x=3.1415926时输出0.0,，当输入x=1.5707963时输出1.0", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/rosone/article/details/7796535", "Konwledge_Point": "近似算法", "Question": "求任意凸多边形的最大内接正交矩形\n正交矩形就是四个边平行于坐标轴的矩形。请问这个用什么算法实现呀？", "Tag": "算法分析"}
{"Answer": "我这里把函数f()里面sum的数据类型改为double，结果就和题目所给出的一致了，所以推测应该是求阶乘这里的原因。修改如下:参考链接：\n\n\n\n\n\n         https://blog.csdn.net/ZHangFFYY/article/details/53043885\n        \n\n\n\n\n\n\n         https://www.jianshu.com/p/67d55d7b1480\n        \n\n#include<stdio.h>\n#include<math.h>\ndouble f(int n)\n{\n    int i;\n    double sum=1; \n    for(i=1;i<=n;i++)\n    {\n        sum*=i;\n    }\n    return sum;\n}\nint main()\n{\n    // https://blog.csdn.net/ZHangFFYY/article/details/53043885\n    // https://www.jianshu.com/p/67d55d7b1480\n    double x,e,x2,x3,x4;\n    scanf(\"%lf %lf\",&x,&e);\n    x2=x;\n    x3=1;\n    x4=x;\n    int i,j,flag=-1,cnt=1;\n    for(i=2;x3>=e;i++)\n    {\n        x3=x2;\n        x4*=x*x;        \n        x2=x2+x4*flag/f((2*i-1));\n        flag=-flag;\n        x3=fabs(x2-x3);\n        cnt++;\n    \n    } \n    printf(\"%d %.9lf\",cnt,x2);\n    return 0;\n}\n\n", "Konwledge_Point": "近似算法", "Question": "用c求sin的近似值\n【问题描述】\n\n\n给定一个精度值e，用下列公式计算sin(x)的近似值，要求前后两次迭代之差的绝对值小于e，给出相应的最小迭代次数n和最后一次计算的sin(x)值。\n\n\n sin x = x - x3/3! + x5/5! - x7/7! + ... + (-1)n-1x2n-1/(2n-1)!\n\n\n 其中x为弧度，n为正整数。\n\n\n 【输入形式】\n\n\n从控制台输入x( （0e>0 )的值，以一个空格分隔。\n\n\n【输出形式】\n\n\n输出迭代次数n和最后一次计算的sin(x)的值（以一个空格分隔，并且输出sin(x)时要求小数点后保留9位有效数字）。\n\n\n【样例输入】\n\n\n1.23 0.0000001\n\n\n【样例输出】\n\n\n7 0.942488802\n\n\n【样例说明】\n\n\n输入的x为1.23，精度值e为0.0000001。当n为5时，利用上述公式计算sin(x)的值为0.942489044，n为6时计算的结果为0.942488800，两结果之差的绝对值约为0.000000244，大于要求的精度值0.0000001，故需要继续迭代计算。当n为7时计算的结果为0.942488802，与n为6的计算结果之差的绝对值约为0.000000002，小于要求的精度值，所以最小迭代次数应为7，最后一次计算的sin(x)的值为0.942488802（小数点后保留9位有效数字）。\n\n\n注意：\n(1) 为保证计算精度，请使用double数据类型保存计算数据。\n(2) 应至少迭代两次，即：n>=2。\n\n\nn=7时测试数据与我的结果数据差了一点点，思路和其他测试数据都一样，不知道为啥。\n\n\n#include\n\n\n#include\n\nint f(int n)\n{\n    int i,\nsum\n=1;\n    \nfor\n(\ni\n=1;i<=n;i++)\n    {\n        sum*=i;\n    }\n    return sum;\n}\nint main()\n{\n    double x,e,x2,x3,x4;\n    scanf(\n\"%lf %lf\"\n,&x,&e);\n    \nx2\n=x;\n    \nx3\n=1;\n    \nx4\n=x;\n    int i,j,\nflag\n=-1,cnt=1;\n    \nfor\n(\ni\n=2;x3>=e;i++)\n    {\n        \nx3\n=x2;\n        x4*=x*x;        \n        \nx2\n=x2+x4*flag/f((2*i-1));\n        \nflag\n=-flag;\n        \nx3\n=fabs(x2-x3);\n        cnt++;\n    \n    } \n    printf(\n\"%d %.9lf\"\n,cnt,x2);\n    return 0;\n}\n\n\n", "Tag": "算法分析"}
{"Answer": "先求平均数，平均数乘以4，得到一个基准数。然后把所有数从小到大排序，因为是均分，所以每组四个数，和近似相等，那么只能是最小数和最大数在一组，可以尝试前1后三，前2后2，前3后1这几种组合哪种跟基准数的偏差最小，取偏差最小的方案，其它分组同样的处理方式", "Konwledge_Point": "近似算法", "Question": "一道算法题，把28个数均分为7组，使每组和近似相等，要求使用c/c++\n把28个数均分为7组，使每组和近似相等。\n\n\n  如果可以适用于任意数更好。", "Tag": "算法分析"}
{"Answer": "安利wolfram\nplot 20+x1*cos(x2)+x2*sin(x1) x1 from 0 to 10,  x2 from -10 to 0 - Wolfram|Alpha\nCompute answers using Wolfram's breakthrough technology & knowledgebase, relied on by millions of students & professionals. For math, science, nutrition, history, geography, engineering, mathematics, linguistics, sports, finance, music…\n\n\n\nhttps://www.wolframalpha.com/input/?i=plot+20%2Bx1*cos%28x2%29%2Bx2*sin%28x1%29+x1+from+0+to+10%2C++x2+from+-10+to+0\n\n\n", "Konwledge_Point": "近似算法", "Question": "布置了一个题目，用一个算法计算以下函数的最大值\n有没有啥网站能画出这种函数的图像的，或者能计算出这个函数的最大值的近似值，我做一个参考\n\n", "Tag": "算法分析"}
{"Answer": "同学你好，代码供参考，如有帮助还麻烦题主给个宝贵的采纳支持一下答题呢\ns = 0;%初始s\ni = 1;%初始i\nds = 1;%初始ds\nflag = 1;%初始符号\nwhile (abs(ds)>1e-4)\n    s = s+ds;\n    i = i + 2;\n    flag = -flag; %符号每次换一下\n    ds = flag/i;\nend\nfprintf('pi的近似值%f \\n',4*s)\n\n结果：pi的近似值3.141393 ", "Konwledge_Point": "近似算法", "Question": "用matlab利用格里高利公式求pi的近似值，要求精确到最后一项的绝对值小于10^-4（用while语句来实现））\n网上查到的相关算法不能运行，希望大神可以帮忙指点一下！", "Tag": "算法分析"}
{"Answer": "#include<stdio.h>\n#include<math.h>\nint main()\n{\n    int i;\n    float prev1 = 1.0,n,error,prev;\n    scanf(\"%f %f\",&n,&error);\n    prev = 1.0 / 2.0 * (prev1 + n / prev1);\n\n    while (fabs(prev - prev1) > error){\n        prev1 = prev;\n        prev = 1.0 / 2.0 * (prev1 + n / prev1);\n    }\n\n    printf(\"%.2f\",prev);\n\n    return 0;\n}\n\n\n", "Konwledge_Point": "近似算法", "Question": "求计算n的平方根 的计算方法\nHeron方法是古希腊人用于计算一个数n的平方根的方法。该方法产生一系列值不断逼近√\n​n\n​\n​​ 。序列中的第一个值是一个任意的猜测值，其他值根据前一个值prev计算获得，计算公式如下：\n\n\n​2\n​\n​1\n​​ (prev+\n​prev\n​\n​n\n​​ )\n\n\n输入两个数：n和error，初始猜测值为1.0，重复计算其更好的近似值，直到两次相邻的近似值之差（绝对值）小于或等于error。输出n的平方根。\n\n\n输入格式:\n输入n和error\n\n\n输出格式:\n输出n的平方根\n\n\n输入样例1:\n在这里给出一组输入。例如：\n\n\n4.0\n0.5\n输出样例1:\n在这里给出相应的输出。例如：\n\n\n2.05", "Tag": "算法分析"}
{"Answer": "\n#include <stdio.h>\n#include <math.h>\nint main()\n{\nfloat x0,x1,x2,y0,y1,y2;\nprintf(\"please input x1,x2:\\n\");\nloop: scanf(\"%lf %lf\",&x1,&x2);\ny1=2*pow(x1,3)-4*pow(x1,2)+3*x1-6;\ny2=2*pow(x2,3)-4*pow(x2,2)+3*x2-6; if (y1+y2>=y1)\n{\nprintf(\"请重新输入\");\ngoto loop;\n}\nelse\n{\ndo\n{ x0=(x1*y2-x2*y1)/(y2-y1);\ny0=2*pow(x0,3)-4*pow(x0,2)+3*x0-6; if(y0*y1>0)\n{\nx1=x0;\ny1=y0;\n}\nelse\n{\nx2=x0;\ny2=y0;\n}\n}\nwhile(fabs(y0)>1e-4);\nprintf(\"%f\",x0) ;\n}\n}\n", "Konwledge_Point": "近似算法", "Question": "用弦截法求程2x3-4x2+3x-6=0在(0,3)内的近似根，直到|f(x)|<0.0001为止。\nC语言程序。用弦截法求程2x3-4x2+3x-6=0在(0,3)内的近似根，直到|f(x)|<0.0001为止。", "Tag": "算法分析"}
{"Answer": "相关文章的原理：\r\n\r\n每一篇文字发布时，从其中抽取几个关键词（tag），\r\n相关文章即是具有相同关键词的最近的几篇。\r\n每一篇文章的各个tag可以给一个权重，也可以按各个关键词的权重和来作为文章相似度的指标。\r\n\r\n（比如：本文的tag为 lunece 0.5,文章 0.2,查找 0.2...", "Konwledge_Point": "近似算法", "Question": "lunece查找 近似文章的问题\n我正在做一个网站的垂直搜索模块，现在碰到了以下问题。 \n请注意：根据字符串查询相关内容的方法我已经写好了，所以我不是问查找相关文章的算法。 \n我要问的是： \n我的查找相关文章的方法 要求我传一个代表文章内容的字符串作为对比参数。 \n难道我在显示每篇文章之前都要先把 该文章的所有内容传给 查找相关文章的方法，然后获得相关文章列表吗？ \n如果文章的内容很多，这种传输会不会造成性能问题呢？ \njavaeye生成相关文章列表的凭据数据是什么呢？也是拿整篇文章的内容去求得相关文章列表？还是有其他更改好的方法？ \n如果 javaeye也是把文章的所有内容作为查找相关文章的凭据，那么这些内容是如何传到后台的呢，通过url参数吗？ \n小弟不才，还请各位大大帮助。\n附上查询方法：\npackage com.jdtqn.module.tools.search;\n\n\nimport java.io.StringReader;\n\nimport java.util.ArrayList;\n\nimport java.util.List;\n\n\n\nimport jeasy.analysis.MMAnalyzer;\n\n\n\nimport org.apache.lucene.index.IndexReader;\n\nimport org.apache.lucene.search.Hits;\n\nimport org.apache.lucene.search.IndexSearcher;\n\nimport org.apache.lucene.search.Query;\n\nimport org.apache.lucene.search.similar.MoreLikeThis;\n\n\n\nimport com.jdtqn.module.tools.SearchResult;\n\nimport com.jdtqn.module.tools.SearchResults;\n\n\n\npublic class MoreLikeThisSearcher implements Seacher{\n\n\n\nprivate String index_path=\"D:\\\\work\\\\resin-pro-3.0.26\\\\deploy\\\\jdtqn_final\\\\anthemIndex\";\n\npublic void setIndex_path(String index_path){\n    this.index_path=index_path;\n}\npublic SearchResults search(String queryWord) throws Exception {\n\n    IndexReader r = IndexReader.open(index_path); \n    MoreLikeThis mlt = new MoreLikeThis(r); //传入IndexReader对象提供查询\n    mlt.setAnalyzer(new MMAnalyzer());//设置使用的分词器\n    mlt.setFieldNames(new String[]{\"htmlTitle\",\"htmlContent\"}); //设置需要比较的field字段\n    mlt.setMinWordLen(0);\n    mlt.setMinDocFreq(2);//出现词的频率小于二，则该词不作为关键词被纳入搜索\n    mlt.setMinTermFreq(3);\n    mlt.setBoost(true);\n    Query query = null;\n    query = mlt.like(new StringReader(queryWord)); //创建查询,传入查询内容可为任意的Reader子类\n    IndexSearcher searcher = new IndexSearcher(index_path);\n    Hits hits = searcher.search(query); //根据查询返回相似文档\n    int len = hits.length();\n    System.out.println(len);\n    SearchResult searchResult;\n    SearchResults searchResults = new SearchResults();\n    searchResults.setHitsCount(len);\n    List searchList = new ArrayList();\n    for (int i = 0; i < Math.min(7, len); i++) //如果比7大就只返回前7条\n    {\n        searchResult = new SearchResult();\n        System.out.println(hits.score(i));\n        searchResult.setHtmlName(hits.doc(i).get(\"htmlName\"));\n        System.out.println(hits.doc(i).get(\"htmlName\"));\n        searchResult.setHtmlTitle(hits.doc(i).get(\"htmlTitle\"));\n        searchList.add(searchResult);\n        System.out.println(\"*****************\");\n    }\n    r.close(); //关闭索引\n    return searchResults;\n}\n\n\n\n\n}\n\n\n\n问题补充\n难道就没人知道吗？没人做相似文章推荐这个功能吗？\n自己顶下", "Tag": "算法分析"}
{"Answer": "有没有人哪,给其他解决方案也行.如果可以直接采纳了.", "Konwledge_Point": "近似算法", "Question": "三维装箱(Java)求优化或给出更好的代码方案\n代码效率太低,货品一多会导致内存溢出.求优化或给出更好的解决方案\n\n\n\npackage com.example.demo.box;\n\n\nimport java.util.*;\n\npublic class GoodsInBox {\n    /*箱子的型号,盛放空间*/\n    private Map> boxTypeArr;\n    /*订单中的商品*/\n    private Map> orderItemArr;\n    /*计算结果*/\n    private Map result=new HashMap();\n    /*计算过程数据,有效的空间列表*/\n    private List inboxinfo=new ArrayList();\n\n    /**\n     * 根据箱型以及订单中的商品，返回每个箱型需要箱子多少只。如果没有任何的箱子能装下某一款超大商品的时候，抛出异常\n     *\n     * @param linkedHashMap\n     * @param orderItemArr\n     * @return\n     */\n    public GoodsInBox(LinkedHashMap> linkedHashMap, Map> orderItemArr){\n        this.boxTypeArr = linkedHashMap;\n        this.orderItemArr=orderItemArr;\n        //开始执行\n        run();\n    }\n\n\n    /**\n     * boxType.get(boxkey)  value{boxcode=1, l=100, w=100, h=120}\n     * boxType.get(boxkey) {boxcode=2, l=200, w=150, h=180}\n     * boxType.get(boxkey) {boxcode=3, l=500, w=600, h=700}\n     */\n    //执行装箱\n    private void run(){\n        Integer[] boxkeys=boxTypeArr.keySet().toArray(new Integer[]{});\n        aBoxType: for (Integer boxkey : boxkeys) {\n            tryInSpance(boxTypeArr.get(boxkey), orderItemArr);\n        }\n    }\n\n    /**\n     * 每次测试1块空间,和全部商品,将商品一次向空间转移,放进去后产生新的3块空间,同时商品的数量再减少,直到商品全部转移;\n     * @param boxMap\n     * @param products\n     */\n    private void tryInSpance(Map boxMap/* 某1个盒子或者是1个剩餘空間 */,\n                             Map> products/* 多件商品，装进去一件，删除一件，直到删没了为止 */){\n        if (null == boxMap || null == products) {\n            return;\n        }\n        java.util.Iterator gks = products.keySet().iterator();    //对存储商品的Map进行遍历\n        while (gks.hasNext()) {\n            Integer oid = gks.next();                      //oid就是products的Key\n            Map g = products.get(oid);    //g是具体的商品属性\n            // 商品数量\n            Integer num = g.get(\"n\");     //获取某种商品的数量\n            if (0 == num) {\n                return;\n            }\n            // 多少件商品就循环多少次，每次处理一件；\n            for (int i = num; i > 0; i--) {\n                String boxcode = boxMap.get(\"boxcode\").toString().concat(\":\").concat(oid.toString());   //箱的Kye:商品的Key    1:1\n                Integer bl = Integer.valueOf(boxMap.get(\"l\").toString());       //箱的长\n                Integer bw = Integer.valueOf(boxMap.get(\"w\").toString());       //箱的宽\n                Integer bh = Integer.valueOf(boxMap.get(\"h\").toString());       //箱的高\n                Integer gl = g.get(\"l\");                                        //商品的长\n                Integer gw = g.get(\"w\");                                        //商品的宽\n                Integer gh = g.get(\"h\");                                        //商品的高\n                // 正面放置商品\n                if ((bl - gl) >= 0 && (bw - gw) >= 0 && (bh - gh) >= 0) {\n                    // 可以放入的情况下先减少商品的数量；\n                    g.put(\"n\", i - 1);\n                    // 加入统计\n                    inboxinfo.add(boxcode);\n                    // 正放的3块剩余空间\n                    Map leftover;\n                    // 第一块空间\n                    leftover = new HashMap();\n                    leftover.put(\"boxcode\", boxcode.concat(\"-1:\").concat(oid.toString()));\n                    leftover.put(\"l\", gl);\n                    leftover.put(\"w\", gw);\n                    leftover.put(\"h\", bh - gh);\n                    tryInSpance(leftover, products);\n                    // 第二块空间\n                    leftover = new HashMap();\n                    leftover.put(\"boxcode\", boxcode.concat(\"-2:\").concat(oid.toString()));\n                    leftover.put(\"l\", gl);\n                    leftover.put(\"w\", bw - gw);\n                    leftover.put(\"h\", bh);\n                    tryInSpance(leftover, products);\n                    // 第三块空间\n                    leftover = new HashMap();\n                    leftover.put(\"boxcode\", boxcode.concat(\"-3:\").concat(oid.toString()));\n                    leftover.put(\"l\", bl - gl);\n                    leftover.put(\"w\", bw);\n                    leftover.put(\"h\", bh);\n                    tryInSpance(leftover, products);\n\n                    // 侧面放置商品\n                } else if ((bl - gw) >= 0 && (bw - gl) >= 0 && (bh - gh) >= 0) {\n                    // 可以放入的情况下先减少商品的数量；\n                    g.put(\"n\", i - 1);\n                    // 加入统计\n                    inboxinfo.add(boxcode);\n                    // 侧放的3块剩余空间\n                    Map leftover;\n                    // 第一块空间\n                    leftover = new HashMap();\n                    leftover.put(\"boxcode\", boxcode.concat(\"-1:\").concat(oid.toString()));\n                    leftover.put(\"l\", gl);\n                    leftover.put(\"w\", gw);\n                    leftover.put(\"h\", bh - gh);\n                    tryInSpance(leftover, products);\n                    // 第二块空间\n                    leftover = new HashMap();\n                    leftover.put(\"boxcode\", boxcode.concat(\"-2:\").concat(oid.toString()));\n                    leftover.put(\"l\", bw - gl);\n                    leftover.put(\"w\", gw);\n                    leftover.put(\"h\", bh);\n                    tryInSpance(leftover, products);\n\n                    // 第三块空间\n                    leftover = new HashMap();\n                    leftover.put(\"boxcode\", boxcode.concat(\"-3:\").concat(oid.toString()));\n                    leftover.put(\"l\", bl - gw);\n                    leftover.put(\"w\", bw);\n                    leftover.put(\"h\", bh);\n                    tryInSpance(leftover, products);\n\n                    // 卧倒放置商品\n                } else if (g.get(\"t\") == 1 && (bl - gh) >= 0 && (bw - gw) >= 0 && (bw - gl) >= 0) {\n                    // 可以放入的情况下先减少商品的数量；\n                    g.put(\"n\", i - 1);\n                    // 加入统计\n                    inboxinfo.add(boxcode);\n                    // 侧放的3块剩余空间\n                    Map leftover;\n                    // 第一块空间\n                    leftover = new HashMap();\n                    leftover.put(\"boxcode\", boxcode.concat(\"-1:\").concat(oid.toString()));\n                    leftover.put(\"l\", gh);\n                    leftover.put(\"w\", gw);\n                    leftover.put(\"h\", bh - gh);\n                    tryInSpance(leftover, products);\n\n                    // 第二块空间\n                    leftover = new HashMap();\n                    leftover.put(\"boxcode\", boxcode.concat(\"-2:\").concat(oid.toString()));\n                    leftover.put(\"l\", bw - gw);\n                    leftover.put(\"w\", gh);\n                    leftover.put(\"h\", bh);\n                    tryInSpance(leftover, products);\n\n                    // 第三块空间\n                    leftover = new HashMap();\n                    leftover.put(\"boxcode\", boxcode.concat(\"-3:\").concat(oid.toString()));\n                    leftover.put(\"l\", bl - gh);\n                    leftover.put(\"w\", bw);\n                    leftover.put(\"h\", bh);\n                    tryInSpance(leftover, products);\n\n                    // 侧卧放置商品\n                } else if (g.get(\"t\") == 1 && (bl - gw) >= 0 && (bh - gl) >= 0 && (bw - gh) >= 0) {\n                    // 可以放入的情况下先减少商品的数量；\n                    g.put(\"n\", i - 1);\n                    // 加入统计\n                    inboxinfo.add(boxcode);\n                    // 侧放的3块剩余空间\n                    Map leftover;\n                    // 第一块空间\n                    leftover = new HashMap();\n                    leftover.put(\"boxcode\", boxcode.concat(\"-1:\").concat(oid.toString()));\n                    leftover.put(\"l\", gw);\n                    leftover.put(\"w\", gh);\n                    leftover.put(\"h\", bh - gl);\n                    tryInSpance(leftover, products);\n                    // 第二块空间\n                    leftover = new HashMap();\n                    leftover.put(\"boxcode\", boxcode.concat(\"-2:\").concat(oid.toString()));\n                    leftover.put(\"l\", bw - gh);\n                    leftover.put(\"w\", gw);\n                    leftover.put(\"h\", bh);\n                    tryInSpance(leftover, products);\n                    // 第三块空间\n                    leftover = new HashMap();\n                    leftover.put(\"boxcode\", boxcode.concat(\"-3:\").concat(oid.toString()));\n                    leftover.put(\"l\", bl - gw);\n                    leftover.put(\"w\", bw);\n                    leftover.put(\"h\", bh);\n                    tryInSpance(leftover, products);\n\n                }\n            }\n        }\n    }\n\n    /**\n     * 返回计算后得到的结果\n     * @return\n     */\n    public Map getResult(){\n        result.clear();\n        // 这里开始数数了！\n        // 所有装入盒子的商品都放到列表中了，\n        // length为特定长度（3）的为商品第一次装入箱子，其它过长（>3）的都是小件商品塞到之前的箱子里的。\n        // 以上运行的结果应该是：最少需要1号箱两个，3号箱1个，\n        for (String code : inboxinfo) {\n            if (code.length() == 3) {\n                String boxno = String.valueOf(code.split(\":\")[0]);\n                Integer num = result.get(boxno);\n                if (null == num)\n                    num = 0;\n                num = num + 1;\n                result.put(boxno + \"\", num);\n            }\n        }\n        return this.result;\n    }\n\n    public static void main(String[] arproducts) {\n        GoodsInBox gb = new GoodsInBox(/* 箱子的规格 */new LinkedHashMap>() {\n            {\n                // 假设有大中小三种型号的箱子,如下描述：\n                /*-\n                 *  要求数据从数据库中取出来的时候是按照 箱子型号大小系数 (l长+w款+h高) 从小到大的顺序排好序的。這樣裝箱后可以得到近似合理的解\n                 */\n                // 1,小箱\n                this.put(1, new LinkedHashMap() {\n                    {\n                        // 小箱 长 100厘米，宽100厘米，高120厘米；\n                        this.put(\"boxcode\", 1);\n                        this.put(\"l\", 100);\n                        this.put(\"w\", 100);\n                        this.put(\"h\", 120);\n                    }\n                });\n                // 2,中箱\n                this.put(2, new LinkedHashMap() {\n                    {\n                        // 中箱 长200厘米，宽150厘米，高180厘米\n                        this.put(\"boxcode\", 2);\n                        this.put(\"l\", 200);\n                        this.put(\"w\", 150);\n                        this.put(\"h\", 180);\n                    }\n                });\n                // 3,大箱\n                this.put(3, new LinkedHashMap() {\n                    {\n                        // 大箱长500厘米宽600厘米高700厘米\n                        this.put(\"boxcode\", 3);\n                        this.put(\"l\", 500);\n                        this.put(\"w\", 600);\n                        this.put(\"h\", 700);\n                    }\n                });\n\n            }\n        }, /* 订单 */ new LinkedHashMap>() {\n            {\n                /*-\n                 *  要求数据从数据库中取出来的时候是按照 商品大小系数 (l长+w款+h高) 从大到小的顺序排好序的。這樣裝箱后可以得到近似合理的解\n                 */\n                // 1,卧室用的小冰箱1个\n                this.put(1, new LinkedHashMap() {\n                    {\n                        // 长 400厘米，宽500厘米，高600厘米；\n                        this.put(\"l\", 400);\n                        this.put(\"w\", 500);\n                        this.put(\"h\", 600);\n                        this.put(\"n\", 10);\n                        this.put(\"t\", 0);// 是否可以躺着放，0，否；1，是，这个不能躺着放，而且所有商品均不能倒置，而且倒置和正着放置所占用空间一样。\n                    }\n                });\n                // 1,电脑主机箱2台\n                this.put(2, new LinkedHashMap() {\n                    {\n                        // 长 57厘米，宽21厘米，高52厘米；\n                        this.put(\"l\", 1);\n                        this.put(\"w\", 1);\n                        this.put(\"h\", 1);\n                        this.put(\"n\", 5);\n                        this.put(\"t\", 1);// 是否可以躺着放，0，否；1，是\n                    }\n                });\n                // 2,苹果笔记本电脑10台\n                this.put(3, new LinkedHashMap() {\n                    {\n                        // 长 33厘米，宽24厘米，高6厘米；\n                        this.put(\"l\", 1);\n                        this.put(\"w\", 1);\n                        this.put(\"h\", 1);\n                        this.put(\"n\", 5);\n                        this.put(\"t\", 1);// 是否可以躺着放，0，否；1，是\n                    }\n                });\n\n            }\n        });\n\n        // 1号箱子 2只,分别装笔记本和小键盘； 3号箱子：1只用来装冰箱\n        System.out.println(gb.getResult().toString());\n    }\n}\n\n", "Tag": "算法分析"}
{"Answer": "数组前三个元素取中间的一个就行了", "Konwledge_Point": "近似算法", "Question": "关于#算法#的问题：第一题时间复杂度需要O（1）的话，可不可以直接用if判断来进行输出第二题真不懂求解惑(语言-c语言)\n求解惑\n1.令A[1...n]为整数数组，n>2,请设计一个O（1）时间的算法，它在A中找出一个既不是最大值也不是最小值得元素\n2.证明\n n\nΣ  j log j   = θ（n²logn）\nj=1\n①用代数方法\n②用积分近似求和的方法\n\n\n第一题时间复杂度需要O（1）的话，可不可以直接用if判断来进行输出\n第二题真不懂求解惑", "Tag": "算法分析"}
{"Answer": "这不很简单吗。\r\n理论上：先生成n个随机数，求总和得S，每个数都除以S，就保证和为1。\r\n实现上：\r\n1)除之前先判断一下S是否为0（随机算法太妖了吧），是0就重来。\r\n2)考虑到小数的精度问题，最后一个数修正为 1-(前n-1个数的和)。", "Konwledge_Point": "近似算法", "Question": "求给出一个生成n个和为1，且每个数都在[0,1]间的随机数的算法\n同题，有伪码就好了，或者其他什么代码都可以。要求生成的随机数分布不会有明显的集中，比如最后几个随机数总是近似为零", "Tag": "算法分析"}
{"Answer": "堆排序吧，或者二叉排序树，也就是你说的红黑树", "Konwledge_Point": "近似算法", "Question": "如何使用数据结构与算法优雅地实现边统计边排序？\n我感觉对于关键字的统计和排序很多情况都是基于已经知道所有关键字的情况下进行哈希表统计然后排序。\n但是假如我并不能事先知道有哪些关键字我只能一次一次得像开盲盒一样去获取关键字，并且每一次获取后我都要更新排序结果。\n我想过如果用数组，每次获取关键词后查找倒是可以用二分查找实现O(logn)，当然也可以添加一个哈希表实现近似O(1)实现查找。如果关键字存在还好，顶多就是交换关键字位置，要是不存在就要进行新增元素并且移动了。\n然后我就想用链表，每次获取一个关键字要么就是在链表头部增一个节点，要么就是把原来存在的关键字节点移动到出现次数加一的位置，至少新增或者移动复杂度是相较于数组是降低了。但是要找到存在的关键字节点的复杂度变成了O(n)。我觉得还是可以使用哈希表存储关键字和节点地址或者引用实现O(1)查找。\n我还想到了个方案，用红黑树，但是红黑树我没听说过有更新操作，但可以用删除和新增两个操作来代替，但是感觉十分不优雅。\n我想问到底最优雅的方法是啥？是不是本身就存在一个我还不了解的方案解决这个问题。", "Tag": "算法分析"}
{"Answer": "1、举例：1亿条数据分成6份sql：select t.*,ntile(6)over(order by null) num from tablea t;\n2、把1亿数据的表取1000万条分成5份select t.*,ntile(6)over(order by null) num   from(select * from tablea  wehre rownum<=10000000) t;", "Konwledge_Point": "近似算法", "Question": "oracle主键id分布不均匀的大表怎么均匀等分多份\n最近项目要做新老系统的数据割接，大表几千万数上亿的数据，不好一次性割接，想近似等分N份。开始我用id平均一下，结果发现主键id分布不均匀，相同间隔区间里，有的一两百万，有的五六百万数据，我还要等最多的那个区间割接完，做不到耗时差不多。并且表还挺多的，就有点伤脑筋，请教一下有啥妙招！", "Tag": "算法分析"}
{"Answer": "假设原始特征为ABCD，存在冗余后变成AaBbCcDd。那么ABCD,abcd,ABcd,abCD,Abcd........等等都是AaBbCcDd近似性能的特征子集。作者说影响的稳定性是指提升稳定性，在只有4个特征时(ABCD)，但凡缺一个就会导致判断失误；而存在冗余特征时(AaBbCcDd)，缺了部分特征对判断失误影响不大", "Konwledge_Point": "近似算法", "Question": "冗余特征的存在是提高了特征选择的稳定性还是降低了稳定性？\n能不能帮我解释一下这句话：\n“当特征集里含有大量的冗余特征时，由于冗余特征之间的关联性较强，具有相似的（分类）性能，也会产生多个具有近似性能的特征子集，从而影响算法的稳定性。”（出处：\nhttps://tech.hqew.com/fangan_1573971\n）\n这里说也会产生多个具有近似性能的特征子集是什么意思？影响稳定性在这里是说降低了稳定性吗，然而我在一篇名为《Comparison of Stability for Different Families of Filter-Based and Wrapper-Based Feature Selection》的文献里看到说冗余直接提高了稳定性，这应该怎么理解呢？", "Tag": "算法分析"}
{"Answer": "递归次数太多了，导致堆栈溢出。\r\nwhile(temp>=1e-3) 就可以输出正常结果\r\nwhile(temp>=1e-4)就不行了\r\n我测试了一下大概while (temp >= 0.000104375)在我电脑上就到达极限了，要递归4790次。\r\n建议求PI不要用递归", "Konwledge_Point": "近似算法", "Question": "递归问题，求各位大神解疑\n递归问题，求各位大神解答\n\n\n\n这个递归哪里出问题了，为什么程序没有结果？\n\n\n\n\n//根据 P/4=1-1/3+1/5-1/7.... 求P的近似值，要求精度为0.000001\n\n#include\"iostream\"\nusing namespace std;\n\nint Temp(int n){//求-1的n次方\n    if(n==0)return 1;\n    return -1*Temp(n-1);\n}\n\ndouble PI(){\n    double sum=0;\n    double temp=1.0;\n    int count=0;//计数变量\n    while(temp>=1e-6){\n        count++;\n        sum=sum+Temp(count-1)*temp;\n        temp=1.0/(2*count+1);\n    }\n    return 4*sum;\n}\n\nint main(){\n    cout<<\"------------求PI的值-------------\"<<endl<<endl<<endl<<endl;\n    cout<<\"根据 P/4=1-1/3+1/5-1/7.... 求P的近似值，要求精度为0.000001\"<<endl<<endl;\n    double Pi=PI();\n    cout<<\"PI=\"<<Pi;\n    return 0;\n}\n", "Tag": "算法分析"}
{"Answer": "如果大小不一致的话，看看sift算法，大小一致的话直接模板匹配", "Konwledge_Point": "近似算法", "Question": "如何用Python+NumPy实现比较两张图片重叠的部分？\n问题背景\n\n\n如果两张图片\n只存在上下的偏移\n，并且重叠的部分是\n近似相等\n，并且\n不能用缩图\n的方式进行“近似”比较，那么使用Python+Numpy库，有没有什么办法能比对出这两张图片的上下错位的偏移量？\n\n\n例如这两张图：\n\n\n\n\n相关代码\n\n\n我已经实现了一种找到偏移量的方法，是从偏移量-h/2到h/2进行逐行搜寻，依次计算每次的像素差异值的大小之后找到差异最小的那次，算作两张图片的偏移量。\n\n\n但是由于循环次数较多，所以运行速度较慢，能否有\n更快的速度\n可以计算出结果的算法？\n\n\nimport\n cv2\n\nimport\n numpy \nas\n np\n\n\ndef\n \noverlay\n(\nd1, d2, d\n):\n    \n'''计算重叠部分差异绝对值的平均值'''\n\n    L1 = d1.shape[\n0\n]\n    L2 = d2.shape[\n0\n]\n    dd1 = d1[\nmax\n(\n0\n,  d):\nmin\n(L1, L2+d)]\n    dd2 = d2[\nmax\n(-d, \n0\n):\nmin\n(L1-d, L2)]\n    \nreturn\n np.\nabs\n(- \n1\n * dd2 + dd1).mean()\n\n\ndef\n \noffset\n(\nimg1, img2\n):\n    \n'''计算两张图片的平移偏移量'''\n\n    height = img1.shape[\n0\n]\n    avg = np.inf\n    \nfor\n h \nin\n \nrange\n(- height // \n2\n, height // \n2\n): \n# 搜寻范围\n\n        avg1 = overlay(img1, img2, h)\n        \nif\n avg > avg1:\n            avg = avg1\n            dh = h\n    \nreturn\n dh, avg\n\nimg1 = cv2.imread(file1)\nimg2 = cv2.imread(file2)\n\nprint\n(offset(img1, img2))\n", "Tag": "算法分析"}
{"Answer": "\n\n#include<iostream>\nusing namespace std;\nfloat erfen1(float a, float b);\nfloat erfen2(float a, float b);\nfloat  f1(float x);\nfloat  f2(float x);\nint main()\n{\n    cout << erfen1(0, 10000) << endl;\n    cout << erfen2(3, 4);\n}\n\nfloat erfen1(float a, float b)\n{\n    float m;\n    //解位于(a,b)区间内，如果两者距离小于1.0*（1e-2）/2。那么a,b已经满足所需精度\n    for (; fabs(a - b) > 1e-2;)\n    {\n        m = (a + b) / 2;\n        //结果<1.0*（1e-2）/2,满足精度，直接输出\n        if (fabs(f1(m)) < 1e-2)return m;\n        //根据零点定理，若区间[a,b]内，有f1(a)*f1(b)<0，则解位于此区间\n        //解位于(a,m)\n        if (f1(a) * f1(m) < 0)b = m;\n        //解位于(m,b)\n        if (f1(m) * f1(b) < 0)a = m;\n    }\n    return a;\n}\n\nfloat erfen2(float a, float b)\n{\n    float m;\n    for (; fabs(a - b) > 1e-3;)\n    {\n        m = (a + b) / 2;\n        if (fabs(f2(m)) < 1e-6)return m;\n        if (f2(a) * f2(m) < 0)b = m;\n        if (f2(m) * f2(b) < 0)a = m;\n    }\n    return a;\n}\n\nfloat  f1(float x)\n{\n    return x * x * x * x * x + 3 * x - 1;\n}\n\nfloat  f2(float x)\n{\n    return x * x * x - 2 * x * x - 4 * x - 7;\n}\n", "Konwledge_Point": "近似算法", "Question": "使用C++求解区间二分法求根这一问题\n区间二分法求根\n\n\n用区间二分法求方程x^5+3x-1=0的最小正根，要求误差不超过1/2×10^(-2)，x^3-2x^2-4x-7=0在[3,4]的近似根，要求精度|x^*-x_k |<10^(-3)\n\n\n运行结果及报错内容\n\n\n使用C++语言解决\n\n\n完整可运行代码", "Tag": "算法分析"}
{"Answer": "以下内容部分参考ChatGPT模型：\n\n可以将分母赋值为double类型的1.0，然后在求阶乘时，在循环中将1.0乘上i，这样就可以避免出现运行错误而没有输出的问题。\n以下是修改后的代码：\ndouble cosx(double x, int n) {\n    double result = 1.0;\n    double numerator = 1.0;\n\n    for(int i = 1; i <= n; i++) {\n        numerator *= -x * x;\n        result += numerator / (double)(2 * i * (2 * i - 1));\n    }\n\n    return result;\n}\n\n\n如果我的建议对您有帮助、请点击采纳、祝您生活愉快", "Konwledge_Point": "近似算法", "Question": "我通过2种方式对分母赋值，一种是通过中间变量再赋值给分母，一种是直接对分母赋1对其求阶乘这是通过中间变量赋值（运行错误没有输出，如何解决？\n这是一个求cosx近似值的函数，分母的值为阶乘；我通过2种方式对分母赋值，一种是通过中间变量再赋值给分母，一种是直接对分母赋1对其求阶乘\n这是通过中间变量赋值（运行错误没有输出）\n\n\n这是主函数\n\n\n这个是最初的求分母的方式（运行错误）\n\n\n这个是更改过的方式（正确运行）\n\n\n\n\n为什么同样的逻辑第一种只是增加了个中间变量赋值就错误没有输出呢", "Tag": "算法分析"}
