{"Answer": "参考：http://blog.chinaunix.net/uid-20357359-id-1963209.html", "Konwledge_Point": "优先队列实现", "Question": "如何用大小根交替堆实现双端优先队列？\n双端优先队列是一个支持如下操作的数据结构：\n\n•Insert (S, x) – 将元素x插入集合S\n\n•Extract –Min (S) –删除S中的最小关键字\n\n•Extract –Max (S) –删除S中的最大关键字\n\n可用小大根交替堆来实现对上述三个操作的支持。小大根交替堆是一个满足如下小大根交替条件的完全二元树：如果该二元树不空，那么其上的每个元素都有一个称为关键字的域，且针对该关键字，二元树按层次形成了小大根交替的形式，即对于小大根交替堆中的任何一个结点x，如果x位于小根层次，那么x就是以x为根节点的二元树中键值最小的结点，并称该结点为一个小根结点。同样的道理，如果x位于大根层次，那么x就是以x为根节点的二元树中键值最大的结点，并称该结点为一个大根结点。在小大根交替堆中根结点位于小根层次。", "Tag": "算法分析"}
{"Answer": "#include<stdio.h>\nstruct job{\n    int job_number;\n    int priority;\n};\njob priority_queue[100];\nint length=0;   //队列中的作业个数 全局变量\nint allnumber=1;    //作业号，依次递增，赋给增加的作业\n\nint remove(){\n    if(length==0){\n        printf(\"There is no job!\\n\");\n        return 0;\n    }\n    int maxpriority=9999;\n    int number=9999;\n    int sign=0;\n    //遍历一次队列，找到最高优先级的作业\n    for(int i=0;i<length;i++){\n        if(priority_queue[i].priority<maxpriority){\n            maxpriority = priority_queue[i].priority;\n            number = priority_queue[i].job_number;\n            sign = i;\n        }\n        else if(priority_queue[i].priority==maxpriority)\n            if(priority_queue[i].job_number<number){\n                maxpriority = priority_queue[i].priority;\n                number = priority_queue[i].job_number;\n                sign = i;\n            }\n    }\n    printf(\"%d %d\\n\",priority_queue[sign].job_number,priority_queue[sign].priority);\n\n    //找到了作业，删除它\n    //从后往前依次覆盖\n    for(int i=sign;i<length-1;i++)\n        priority_queue[i] = priority_queue[i+1];\n    //作业个数减一\n    length--;\n    printf(\"Remove succeeds!\\n\");\n    return 1;\n}\nint add(){ //控制台输入一个优先级，系统自动赋予作业号\n    printf(\"Please input the priority: \");\n    int p;  scanf(\"%d\",&p);\n    //构成一个作业：作业号，优先级  并且加在队列最后\n    priority_queue[length] = {allnumber++,p};\n    //作业个数加一\n    length++;\n    printf(\"%d %d\\n\",priority_queue[length-1].job_number,priority_queue[length-1].priority);\n    printf(\"Add succeeds!\\n\");\n    return 1;\n}\nint list(){\n    printf(\"List:\\n\");\n    //一个for循环遍历整个数组\n    for(int i=0;i<length;i++)\n        printf(\"%d %d\\n\",priority_queue[i].job_number,priority_queue[i].priority);\n    printf(\"Over!\\n\");\n    return 1;\n}\n\nint menu(){\n    printf(\"Please input your operation:\");\n    char operation;\n    scanf(\"%s\",&operation);\n    switch (operation) {\n        case 'R':remove();break;\n        case 'A':add();break;\n        case 'L':list();break;\n        case '0':return 0;\n        default: printf(\"Illegal input.\\n\");\n    }\n    menu();\n}\nint main(){\n    menu();\n    return 1;\n}\n\n\n\n直接复制粘贴就能运行。\n使用数组存储作业。每次出队时，先找到优先级最高的作业，然后删除它。", "Konwledge_Point": "优先队列实现", "Question": "数据结构（用无序顺序表实现优先队列）\n需要用c语言编程，加点注释。\n\n\n假设进入计算机系统的作业（job）被赋予一个作业号（job number）和一个从0～9之中的优先级（priority），0表示最大优先级，9表示最小优先级。等待被作业执行的作业的作业号被保存在一个优先级队列（priority queue）中。\n编写一个程序，使用优先级队列来存放作业，并允许用户选择一下菜单操作：R（删除remove）、A（增加add）和L（列举list）。\n对于R，读出当前优先级最高的作业号并把它从优先级队列中删除，如果当前优先级最高的作业有多个，则把作业号小的作业从优先队列中删除；对于A，读入作业号和优先级，然后按上述规则把它加入到优先级队列中；对于L，则列出队列中的所有作业号及其优先级。\n作业号可用一个整数表示，可在作业进入系统时由系统赋予。\n设计适当的数据元素类型，用无序顺序表实现优先队列并写出验证代码验证各个操作，完成上述计算机系统的作业调度的演示方案。新来的作业插入到表尾。假定作业号可以反映作业被加入的先后次序，因此和作业优先级一起可以唯一识别一个作业。", "Tag": "算法分析"}
{"Answer": "构造方法用错了，你l放ambda的地方应该放functype而不是func本身：\n#include <queue>\n#include <vector>\n\nauto main() -> int\n{\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>,\n                        std::function<bool(std::pair<int, int> & map1,\n                                           std::pair<int, int> & map2)>>\n    pri_que([](std::pair<int, int> &map1, std::pair<int, int> &map2) -> bool {\n        return map1.second > map2.second;\n    });\n}\n\n", "Konwledge_Point": "优先队列实现", "Question": "关于c++用lambda表达式自定义优先级队列出错，如何解决？\n这样写,正确创建优先级队列\n\n\nclass\n \nmycomparison\n {\n    \npublic\n:\n        \nbool\n \noperator\n()\n(\nconst\n pair<\nint\n, \nint\n>& lhs, \nconst\n pair<\nint\n, \nint\n>& rhs)\n \n{\n            \nreturn\n lhs.second > rhs.second;\n        }\n    };\n\n    \nvector<\nint\n> \ntopKFrequent\n(vector<\nint\n>& nums, \nint\n k)\n \n{\n        priority_queue,vector>,mycomparison>pri_que;\n\n\n\n这样写 编译器报错,我的lambda表达式写错了吗?\n\n\n        priority_queue,vector>,[](pair<\nint\n,\nint\n>&map1,pair<\nint\n,\nint\n>&map2)\n        {\nreturn\n map1.second>map2.second;} >pri_que;\n\n\n\n错误信息:\n\n\n error: a lambda expression cannot appear in \nthis\n context\n priority_queue,vector>,[](pair<\nint\n,\nint\n>&map1,pair<\nint\n,\nint\n>&map2)\n", "Tag": "算法分析"}
{"Answer": "单调队列必须维护其内元素的有序性。\n优先队列在普通队列的基础上给每个元素增加了优先级，这样每次出队的元素不再是队首的元素，而是队列中优先级最高的元素，而具体的优先级可以自行定义，典型的就是按元素从大到小或从小到大的顺序定义优先级。\n堆通常是一个可以被看做一棵完全二叉树的数组对象，和队列这种线性结构有本质上的差别。\nSTL的实现一般是经过编译器优化的。\n不知道有没有帮到您。", "Konwledge_Point": "优先队列实现", "Question": "单调队列 优先队列 堆的区别和联系?\n单调队列 优先队列 堆的区别和联系是啥 感觉很像.\n以及优先队列和堆的STL实现方式又有什么联系？", "Tag": "算法分析"}
{"Answer": "```\r\n#include\r\n#include       //有用到malloc()\r\n#include       //键盘输入\r\n#include\r\n #define MAX 10\r\n\r\n \r\n#define getpch(type)  (type*)malloc(sizeof(type))\r\n#define NULL 0\r\n\r\nstruct task_struct\r\n{\r\n    char name[10];           /*进程名称*/\r\n    int number;              /*进程编号*/\r\n    float come_time;         /*到达时间*/\r\n    float run_begin_time;     /*开始运行时间*/\r\n    float run_time;          /*需要运行时间*/\r\n    float runed_time;\t\t/*运行时间*/\r\n    float run_end_time;      /*运行结束时间*/\r\n    int priority;           /*优先级*/\r\n    int run_flag;          /*调度标志*/\r\n    int start_flag;     //是否为第一次开始调度\r\n} tasks[MAX];\r\nint counter; /*实际进程个数*/\r\nint time_counter=0;\r\nint poutput(); /*调度结果输出*/\r\nint time();\r\nint charge();//判断是否所有的进程都被执行过\r\n \r\nstruct pcb                   //定义进程控制块\r\n{\r\n\tchar name[10];           //定义进程名\r\n\tchar state;              //进程状态\r\n\tint  super;             //进程优先级\r\n\tint  rtime;              //已经运行时间\r\n\tint  ntime;                //运行所需时间\r\n\tstruct pcb* link;           //定义一个队列指针，定义了一个指向pcb结构类型的指针link作为自己的成员函数\r\n}*ready=NULL,*p;                 //定义两个指向pcb结构指针类型的指针ready和p，ready的初值为空,并建立了一个空的就绪队列\r\n\r\n\r\ntypedef struct pcb PCB;           //定义将struct pcb称为PCB\r\n \r\n \r\n \r\n \r\n//***********************************************************************************************\r\nvoid sort()                       //建立对进程进行优先级排列的函数\r\n{\r\n\tPCB *f,*s;                   //定义两个用来排列的指针first和second\r\n\tint insert=0;                    //插入\r\n\tif((ready==NULL)||(p->super)>(ready->super))     //比较优先级，优先级最大者，直接插入队首\r\n\t{\r\n\t\tp->link=ready;                           //\r\n\t\tready=p;                                // 将新建进程放入队首\r\n\t}\r\n\telse                                      //比较进程的优先级，并将其插入适当的地方\r\n\t{\r\n\t\tf=ready;                          //                                                \r\n\t\ts=f->link;                              //插入新的进程\r\n\t\twhile(s!=NULL)                           //如果第二个进程不为空\r\n\t\t{\r\n\t\t\tif((p->super)>(s->super))            //将插入进程与当前进程比较\r\n\t\t\t{                                   //如果插入进程的优先级大于当前进程优先级，则插入当前优先级的前面\r\n\t\t\t\tp->link=s;\r\n\t\t\t\tf->link=p;\r\n\t\t\t\ts=NULL;\r\n\t\t\t\tinsert=1;\r\n\t\t\t}\r\n\t\t\telse                                 //否则，将新插入的进程插入到当前进程的后面，向后移指针\r\n\t\t\t{\r\n\t\t\t\tf=f->link;\r\n\t\t\t\ts=s->link;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(insert==0)\r\n\t\t\tf->link=p;                           //将p指针指向队尾\r\n\t}\r\n}\r\n \r\n \r\n \r\n \r\n//**********************************************************************************\r\nvoid input()                                          //建立进程控制块函数\r\n{\r\n\tint i,num;                               \r\n\tprintf(\"*********************最高优先级优先算法**********************\");\r\n\tprintf(\"\\n 请输入进程的数量：\");\r\n\tscanf(\"%d\",#);              //键盘上输入\r\n\tfor(i=1;i<=num;i++)\r\n\t{\r\n\t\tprintf(\"\\n 进程号No.%d:\",i);\r\n\t\tp=getpch(PCB);\r\n\t\tprintf(\"\\n 请输入进程名：\");\r\n\t\tscanf(\"%s\",p->name);\r\n\t\tprintf(\"\\n 请输入进程优先级：\");\r\n\t\tscanf(\"%d\",&p->super);\r\n\t\tprintf(\"\\n 请输入进程所需运行时间：\");\r\n\t\tscanf(\"%d\",&p->ntime);\r\n\t\tprintf(\"\\n\");\r\n\t\tp->rtime=0;\r\n\t\tp->state='w';\r\n\t\tp->link=NULL;\r\n\t\tsort();                               //调用sort函数进行排序\r\n\t}\r\n}\r\n \r\n \r\n \r\n \r\n \r\n \r\n//********************************************************************************\r\nint space()                 //计算进程控制块个数的函数\r\n{\r\n\tint k=0;\r\n\tPCB*pr=ready;          //pr指向队首进程\r\n\twhile(pr!=NULL)          //pr为空则说明计数完成，就绪队列没到头，就一直输出\r\n\t{\r\n\t\tk++;\r\n\t\tpr=pr->link;\r\n\t}\r\n\tprintf(\" 进程数量：%d\\n\",k);\r\n\tprintf(\"*********************************************\\n\");\r\n\treturn(k);\r\n}\r\n \r\n \r\n \r\n \r\n \r\n \r\n//************************************************************************************\r\nvoid disp(PCB*pr)   //建立进程显示函数，显示当前的进程\r\n{\r\n\tprintf(\"\\n name\\t state\\t super \\t ntime\\t rtime\\n\");\r\n\tprintf(\" %s  \\t\",pr->name);\r\n\tprintf(\" %c  \\t\",pr->state);\r\n\tprintf(\" %d  \\t\",pr->super);\r\n\tprintf(\" %d  \\t\",pr->ntime);\r\n\tprintf(\" %d  \\t\",pr->rtime);\r\n\tprintf(\"\\n\");\r\n}\r\n \r\n \r\n \r\n \r\n \r\n \r\n//****************************************************************************\r\nvoid check()            //建立进程查看函数，查看已经排列好的情况\r\n{\r\n\tPCB* pr;\r\n\tprintf(\"\\n 当前正在运行的进程：%s\",p->name);\r\n\tdisp(p);                //调用disp()显示已经筛选出来的正在运行的进程\r\n\tpr=ready;                \r\n\tprintf(\"\\n 当前就绪队列状态为：\\n\");\r\n\twhile(pr!=NULL)\r\n\t{\r\n\t\tdisp(pr);             //调用disp()显示已经排列好的就绪队列  \r\n\t\tpr=pr->link;\r\n\t}\r\n}\r\n \r\n \r\nvoid destroy()      //建立函数，撤销进程\r\n{\r\n\tprintf(\"\\n 进程[%s]已完成.\\n\",p->name);\r\n\tfree(p);                            //释放空间\r\n}\r\n \r\n \r\n \r\n \r\n \r\n \r\n//********************************************************************************\r\nvoid running()                 //建立进程就绪函数（进程运行时间到，置为就绪状态）\r\n{\r\n\t(p->rtime)++;                    //运行时间加一\r\n\tif(p->rtime==p->ntime)\r\n\t   destroy();                     //\r\n\t else\r\n\t {\r\n\t\t (p->super)--;             //运行时间减一\r\n\t\t p->state='w';\r\n\t\t sort();                   //调用一次之后，运行时间时间和运行状态改变后，重新去排序进程\r\n\t }\r\n} \r\n \r\n \r\n//***************************************************************************\r\nvoid HPF()                        //主函数\r\n{\r\n\tint len,h=0;                                //h是用于计算执行次数的\r\n\tchar ch;\r\n\tinput();                                    //调用input函数输入相关的进程信息\r\n\tlen=space();                              //input调用完之后，回到主函数调用space函数得到对列长度\r\n\twhile((len!=0)&&(ready!=NULL))\r\n\t{\r\n\t\tch=getchar();                  //从键盘输入一个字符型数据，把值赋给变量ch,这个是为了每一次被执行，自己手动回车呈现出来，如果没有，则会一次性出现全部被执行的情况\r\n\t\th++;\r\n\t\tprintf(\"\\n The execute number:%d \\n\",h);\r\n\t\tp=ready;\r\n\t\tready=p->link;\r\n\t\tp->link=NULL;\r\n\t\tp->state='R';\r\n\t\tcheck();                         //调用显示正在运行的函数和就绪的函数\r\n        running();        // 调用进程就绪函数,上一个正在运行的进程运行完之后，运行时间加1，将就绪队列里面优先级最高的进程置为运行状态，如果是同优先级，则看哪个先进来，这个不可以运行在check()前，会导致多计算，并出现错误\r\n\t\tprintf(\"\\n 请回车继续......\");\r\n\t\tch=getchar();\r\n\t}\r\n\tprintf(\"\\n\\n 进程已经完成.\\n\");\r\n\tch=getchar();\r\n}\r\n\r\n \r\nvoid RR()\r\n{\r\n\t\r\n    pinput();\r\n    printf(\"时间片轮转算法。\\n\\n\");\r\n    time();\r\n    poutput();\r\n}\r\n \r\nint time()\r\n{\r\n    float time_temp=0;\r\n    int i;\r\n    int j=0;\r\n    int k=0;\r\n\tchar ch;\r\n    struct task_struct  copy_task[MAX];//备份\r\n    for(i=0; itime_temp)\r\n            {\r\n                time_temp=tasks[i].come_time;\r\n                poutput();\r\n                printf(\"\\n 新进程进入输入...任意字符继续......\");\r\n\t\t\t\tch=getchar();\r\n            }\r\n            if(tasks[i].run_flag==0)//该进程还未结束\r\n            {\r\n                if(tasks[i].start_flag==0)  //该条件成立则说明，该进程是第一次执行，记录开始执行时间\r\n                {\r\n                    tasks[i].run_begin_time=time_temp;\r\n                    tasks[i].start_flag=1;\r\n                }\r\n                if(tasks[i].run_time/time_counter>1)//至少有两倍的时间片未执行\r\n                {\r\n                    tasks[i].run_time=tasks[i].run_time-time_counter;\r\n                    time_temp=time_temp+time_counter;\r\n                    tasks[i].runed_time = tasks[i].runed_time + (float)time_counter;//加上的不知道又没用 \r\n                    poutput();\r\n                    printf(\"\\n 执行一次时间片了..按任意字符继续........\");\r\n\t\t\t\t\tch=getchar();\r\n                }\r\n                else if(tasks[i].run_time-time_counter==0)\r\n                {\r\n                    time_temp=time_temp+time_counter;\r\n                    tasks[i].run_end_time=time_temp;\r\n                    tasks[i].run_flag=1;\r\n                    tasks[i].run_time=copy_task[i].run_time;\r\n                    tasks[i].runed_time = tasks[i].runed_time + (float)time_counter;//加上的不知道又没用 \r\n                    poutput();\r\n                    printf(\"\\n 任务完成..按任意字符继续........\");\r\n\t\t\t\t\tch=getchar();\r\n                }\r\n                else//仅剩下不足一倍的时间片\r\n                {\r\n                    time_temp=time_temp+tasks[i].run_time;\r\n                    tasks[i].runed_time = tasks[i].runed_time + tasks[i].run_time;//加上的不知道又没用 \r\n                    tasks[i].run_end_time=time_temp;\r\n                    tasks[i].run_flag=1;\r\n                    tasks[i].run_time=copy_task[i].run_time;\r\n                    \r\n                    poutput();\r\n                    printf(\"\\n 任务完成..按任意字符继续........\");\r\n\t\t\t\t\tch=getchar();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n \r\nint charge()//判断是否全部进程都执行完毕\r\n{\r\n    int k;\r\n    int super_flag=0;//判断是否全部的进程都执行完毕\r\n    for(k=0; k高优先级优先调度算法,1是RR->时间片轮转调度算法）：\\n\") ;\r\n\tscanf(\"%d\",&flag);\r\n\tif (flag == 0){\r\n\t\tHPF();\r\n\t} else if(flag = 1){\r\n\t\tRR();\r\n\t} else{\r\n\t\tprintf(\"没有其他了算法\"); \r\n\t}\r\n\t\r\n}\r\n\r\n```", "Konwledge_Point": "优先队列实现", "Question": "在Windows系统下用C/C++编程实现两种处理机调度算法。\n\n\nCPU Scheduling\n(1)题目描述\n编程实现两种处理机调度算法，可选择的以下组合方式其中之- -: 1) 高优先级优先调度算法和时间片轮转调度算法; 2) 短进程优先调度算法和时间片轮转调度算法; 3) 先入先出调度算法和时间片轮转让调度算法。\n选择-一个调度算法，实现处理机调度。(2)功能实现\no输入提示选择哪种算法，例如:输入“0”--HPF，输入“1”--RR; )\n输入提示创建进程的个数，初始化进程;\nPCB内容:进程名/PID\n运行时间\n优先权\n状态\nPCB指针\n●运行过程中须提示所创建进程的状态信息，包括:已运行的时间,还需运行的时间，阻塞的时间，要阻塞多长时间;\n●提示进程的状态:运行，就绪，阻塞三者之- -;\n●建立进程的PCB， 用队列实现进程就绪队列和阻塞队列的管理。\n可随机输入若干进程，并按所选算法的规则排序，从就绪队首选进程运行，进程在运行过程中定时(或发生调度时)更新各进程的状态信息，\n进程名状态运行时间 剩余运行时间 优先级进程阻塞属性(有阻塞/无阻塞)\n规定系统可接纳的进程的道数，设置后备队列和挂起状态。若内存中进程少于规定道数，可自动从后备队列调度- -作业进入。\n被挂起进程入挂起队列，设置解挂功能用于将指定挂起进程解挂入就绪队列。\n\n", "Tag": "算法分析"}
{"Answer": "#include <iostream>\n#include <list>\n#include <algorithm>\n\nenum class Priority\n{\n    Low,\n    Medium,\n    High\n};\n\ntemplate <typename T, typename List = std::list<std::pair<T, Priority>>>\nclass PriorityQueue\n{\npublic:\n    typedef List list_type;\n    typedef typename List::value_type value_type;\n    typedef typename List::size_type size_type;\n    typedef typename List::iterator iterator;\n    typedef typename List::const_iterator const_iterator;\n\n    PriorityQueue() : _high_end(_list.end()), _medium_end(_list.end()) {}\n    PriorityQueue(const PriorityQueue &other) : _list(other._list)\n    {\n        init();\n    }\n    PriorityQueue(PriorityQueue &&other)\n        : _list(std::move(other._list))\n    {\n        init();\n        other._high_end = other._list.end();\n        other._medium_end = other._list.end();\n    }\n    PriorityQueue(const std::initializer_list<value_type> &list) : _high_end(_list.end()), _medium_end(_list.end())\n    {\n        for (const auto &[value, priority] : list)\n            insert(value, priority);\n    }\n    ~PriorityQueue() {}\n\n    PriorityQueue &operator=(const PriorityQueue &other)\n    {\n        if (this != &other)\n        {\n            _list = other._list;\n            init();\n        }\n        return *this;\n    }\n\n    PriorityQueue &operator=(PriorityQueue &&other)\n    {\n        _list = std::move(other._list);\n        init();\n        other._high_end = other._list.end();\n        other._medium_end = other._list.end();\n        return *this;\n    }\n\n    iterator begin(Priority priority)\n    {\n        iterator it;\n        switch (priority)\n        {\n        case Priority::Low:\n            it = _medium_end;\n            break;\n        case Priority::Medium:\n            it = _high_end;\n            break;\n        case Priority::High:\n            it = _list.begin();\n            break;\n        }\n        return it;\n    }\n\n    iterator end(Priority priority)\n    {\n        iterator it;\n        switch (priority)\n        {\n        case Priority::Low:\n            it = _list.end();\n            break;\n        case Priority::Medium:\n            it = _medium_end;\n            break;\n        case Priority::High:\n            it = _high_end;\n            break;\n        }\n        return it;\n    }\n\n    const_iterator begin(Priority priority) const\n    {\n        const_iterator it;\n        switch (priority)\n        {\n        case Priority::Low:\n            it = _medium_end;\n            break;\n        case Priority::Medium:\n            it = _high_end;\n            break;\n        case Priority::High:\n            it = _list.begin();\n            break;\n        }\n        return it;\n    }\n\n    const_iterator end(Priority priority) const\n    {\n        const_iterator it;\n        switch (priority)\n        {\n        case Priority::Low:\n            it = _list.end();\n            break;\n        case Priority::Medium:\n            it = _medium_end;\n            break;\n        case Priority::High:\n            it = _high_end;\n            break;\n        }\n        return it;\n    }\n\n    bool empty() const { return _list.empty(); }\n\n    size_type size() const { return _list.size(); }\n\n    size_type size(Priority priority) const\n    {\n        size_type sz = 0;\n        switch (priority)\n        {\n        case Priority::Low:\n            sz = std::distance(const_iterator(_medium_end), _list.end());\n            break;\n        case Priority::Medium:\n            sz = std::distance(_high_end, _medium_end);\n            break;\n        case Priority::High:\n            sz = std::distance(_list.begin(), const_iterator(_high_end));\n            break;\n        }\n        return sz;\n    }\n\n    iterator insert(const T &value, Priority priority)\n    {\n        iterator it;\n        switch (priority)\n        {\n        case Priority::Low:\n        {\n            auto sz_medium = size(Priority::Medium);\n            auto sz_low = size(Priority::Low);\n            it = _list.insert(_list.end(), std::make_pair(value, priority));\n            if (sz_low == 0)\n            {\n                _medium_end = it;\n                if (sz_medium == 0)\n                    _high_end = it;\n            }\n            break;\n        }\n        case Priority::Medium:\n        {\n            auto sz_medium = size(Priority::Medium);\n            it = _list.insert(_medium_end, std::make_pair(value, priority));\n            if (sz_medium == 0)\n                _high_end = it;\n            break;\n        }\n        case Priority::High:\n            it = _list.insert(_high_end, std::make_pair(value, priority));\n            break;\n        }\n        return it;\n    }\n\n    iterator erase(iterator pos)\n    {\n        iterator it = _list.erase(pos);\n        if (pos == _high_end)\n            _high_end = it;\n        if (pos == _medium_end)\n            _medium_end = it;\n        return it;\n    }\n\n    void remove(const T &value)\n    {\n        auto it = _list.begin();\n        while (1)\n        {\n            it = find_if(it, _list.end(), [value](const auto &v)\n                         { return v.first == value; });\n            if (it == _list.end())\n                break;\n            it = erase(it);\n        }\n    }\n\n    value_type front() const\n    {\n        return _list.front();\n    }\n\nprivate:\n    void init()\n    {\n        _high_end = std::find_if(_list.begin(), _list.end(), [](const auto &v)\n                                 { return v.second != Priority::High; });\n        _medium_end = std::find_if(_high_end, _list.end(), [](const auto &v)\n                                   { return v.second != Priority::Medium; });\n    }\n\n    list_type _list;\n    iterator _high_end;\n    iterator _medium_end;\n};\n\nstd::ostream &operator<<(std::ostream &os, Priority priority)\n{\n    switch (priority)\n    {\n    case Priority::Low:\n        os << \"Low\";\n        break;\n    case Priority::Medium:\n        os << \"Medium\";\n        break;\n    case Priority::High:\n        os << \"High\";\n        break;\n    }\n    return os;\n}\n\ntemplate <typename T, typename List>\nstd::ostream &operator<<(std::ostream &os, const PriorityQueue<T, List> &q)\n{\n    os << \"{ \";\n    for (auto priority : {Priority::High, Priority::Medium, Priority::Low})\n    {\n        if (priority != Priority::High)\n            os << \", \";\n        os << priority << \": [\";\n        for (auto it = q.begin(priority); it != q.end(priority); ++it)\n        {\n            if (it != q.begin(priority))\n                os << \", \";\n            os << it->first;\n        }\n        os << \"]\";\n    }\n    os << \"}\";\n    return os;\n}\n\nint main()\n{\n    PriorityQueue<int> q = {{1, Priority::Low}, {2, Priority::Medium}, {3, Priority::High}, {4, Priority::High}, {5, Priority::Medium}, {6, Priority::Low}};\n    std::cout << \"q = \" << q << std::endl;\n\n    PriorityQueue<int> p1 = q;\n    std::cout << \"after p1 = q:\\n\";\n    std::cout << \"p1 = \" << p1 << std::endl;\n\n    PriorityQueue<int> p2 = std::move(p1);\n    std::cout << \"after p2 = std::move(p1):\\n\";\n    std::cout << \"p2 = \" << p2 << std::endl;\n    std::cout << \"p1 = \" << p1 << std::endl;\n\n    q.insert(5, Priority::High);\n    std::cout << \"after q.insert(5, Priority::Hight):\\n\";\n    std::cout << \"q = \" << q << std::endl;\n\n    q.remove(5);\n    std::cout << \"after q.remove(5):\\n\";\n    std::cout << \"q = \" << q << std::endl;\n\n    std::cout << \"q.front(): {\" << q.front().first << \", \" << q.front().second << \"}\" << std::endl;\n    return 0;\n}\n\n$ g++ -Wall -std=c++17 main.cpp\n$ ./a.out\nq = { High: [3, 4], Medium: [2, 5], Low: [1, 6]}\nafter p1 = q:\np1 = { High: [3, 4], Medium: [2, 5], Low: [1, 6]}\nafter p2 = std::move(p1):\np2 = { High: [3, 4], Medium: [2, 5], Low: [1, 6]}\np1 = { High: [], Medium: [], Low: []}\nafter q.insert(5, Priority::Hight):\nq = { High: [3, 4, 5], Medium: [2, 5], Low: [1, 6]}\nafter q.remove(5):\nq = { High: [3, 4], Medium: [2], Low: [1, 6]}\nfront: {3, High}\n", "Konwledge_Point": "优先队列实现", "Question": "创建一个基于单向线性列表的 \"具有整数优先级的队列\"。\n当一个元素被插入时，它的优先级被设置，有三个固定值：低、中、高。一旦被放入队列，元素的优先级就不能改变。\n如果没有具有任何优先级的元素，那么指向尾部的相应指针必须为空。\n无参数的构造函数，复制，移动。\n  复制和移动分配运算符。\n确定队列中具有特定优先级的元素的数量和元素的总数量。\n检查是否有空队列。\n插入一个具有价值和优先权的元素。\n从队列中删除一个元素。\n获得关于队列头部元素的优先级和价值的信息。\n  通过菜单实现的头部程序应检查上述所有方法的操作。", "Tag": "算法分析"}
{"Answer": "\n#include<stdio.h>\n#include<stdlib.h>\n#define MAX_VERTEX_NUM 100\ntypedef struct ArcNode{\n\tint adjvex;//该边的另一个顶点的位置 \n\tstruct ArcNode *nextarc; //指向下一条边 \n}ArcNode;\ntypedef struct VNode{\n\tint data;//顶点的值 \n\tArcNode *firstarc;//指向第一条依附该顶点的边的指针 \n}VNode,AdjList[MAX_VERTEX_NUM];\ntypedef struct{\n\tAdjList vertices;//顶点数组 \n\tint vexnum,arcnum;\n}ALGraph;\nint LocateVex(ALGraph G,int v){//定位函数 \n\tfor(int i=0;i<G.vexnum;i++){\n\t\tif(v==G.vertices[i].data)return i;\n\t} \n}\nvoid CreateUDG(ALGraph &G){\n\tArcNode *p,*q;\n\tint i,j,k,v1,v2;\n\tprintf(\"分别输入顶点个数和边的数目：\\n\");\n\tscanf(\"%d%d\",&G.vexnum,&G.arcnum);\n\tprintf(\"分别输入各个顶点值：\\n\");\n\tfor(i=0;i<G.vexnum;i++){\n\tscanf(\"%d\",&G.vertices[i].data);\n\tG.vertices[i].firstarc=NULL;//初始化 \n\t} \n\tprintf(\"分别输入各条边的两个顶点：\\n\");\n\tfor(k=0;k<G.arcnum;k++){\n\t\tscanf(\"%d%d\",&v1,&v2);\n\t\ti=LocateVex(G,v1);j=LocateVex(G,v2);//定位 \n\t\tp=(ArcNode*)malloc(sizeof(ArcNode));//申请一个结点 \n\t\tp->adjvex=j;p->nextarc=NULL;//赋值 \n\t\tp->nextarc=G.vertices[i].firstarc;//连接结点 \n\t\tG.vertices[i].firstarc=p;//连接结点 \n\t\tq=(ArcNode*)malloc(sizeof(ArcNode));\n\t\tq->adjvex=i;q->nextarc=NULL;\n\t\tq->nextarc=G.vertices[j].firstarc;\n\t\tG.vertices[j].firstarc=q;\n\t}\n}\nvoid PrintUDG(ALGraph G){//输出邻接表 \n    int i,j;\n\tfor(i=0;i<G.vexnum;i++){\n\t\tprintf(\"%d:\",i);\n\t\tArcNode *p;\n\t\tp=G.vertices[i].firstarc;\n\t\twhile(p!=NULL){\n\t\t\tprintf(\"->%d\",p->adjvex);\n\t\t\tp=p->nextarc;\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\nint main(){\n\tALGraph G;\n\tCreateUDG(G);\n\tPrintUDG(G);\n\treturn 0;\n}\n如果对你有帮助，可以点击我这个回答右上方的【采纳】按钮，给我个采纳吗，谢谢\n ", "Konwledge_Point": "优先队列实现", "Question": "怎样实现无向图的创建算法\n\n\n\n1、编写一个函数让用户输入这张图，用邻接表存储。\n\n2、编写函数实现此图的深度优先搜索遍历。\n\n3、编程实现循环队列，编写初始化、创建、入队、出队等算法。\n\n4、利用循环队列对图实现广度优先搜索遍历。", "Tag": "算法分析"}
{"Answer": "```\r\n#include\r\n#include\r\n#include\r\n#include\r\n#define MAXSIZE 100\r\ntypedef struct ElemType\r\n{\r\n\tint level;\r\n\tchar name[20];\r\n\tchar gender;\r\n\tchar ID[20];\r\n\r\n}QelemType;\r\ntypedef struct{\r\n\tQelemType *base;\r\n\tint front;\r\n\tint rear;\r\n}squene;\r\nvoid Initquene(squene *s){\r\n\ts->base=(QelemType *)malloc(MAXSIZE * sizeof(QelemType));\r\n\tif(!s->base)\r\n\t\texit(-1);\r\n\ts->front=0;\r\n\ts->rear=0;\r\n}\r\nvoid enquene(squene *s,QelemType e){\r\n\tif((s->rear+1)%MAXSIZE==s->front){\r\n\t\tprintf(\"duimanb\");\r\n\t\texit(0);\r\n\t}\r\n\ts->base[s->rear]=e;\r\n\ts->rear=(s->rear+1)%MAXSIZE;\r\n}\r\nvoid dequene(squene *s,QelemType *e){\r\n\tif(s->rear==s->front){\r\n\t\tprintf(\"栈空\");\r\n\t\texit(-1);\r\n\t}\r\n\t*e=s->base[s->front];\r\n\ts->front=(s->front+1)  % MAXSIZE;\r\n}\r\nint length(squene s){\r\n\treturn (s.rear-s.front+MAXSIZE) % MAXSIZE;\r\n}\r\n\r\nint main()\r\n{\r\n\tint i,j;\r\n\tint n;\r\n\tsquene Q1;\r\n\tQelemType *e,t;\r\n\tInitquene(&Q1);\r\n\tprintf(\"请输入前来就诊的病人数量：\");\r\n\tscanf(\"%d\",&n);\r\n\te = (QelemType *)malloc(n*sizeof(QelemType));\r\n\tfor(i=0;i<n;i++)\r\n\t{\r\n\t\tprintf(\"\\n请输入第%d个病人的优先级：\",i+1);\r\n\t\tscanf(\"%d\",&e[i].level);\r\n\t\tprintf(\"\\n请输入第%d个病人的姓名：\",i+1);\r\n\t\tscanf(\"%s\",e[i].name);\r\n\t\tfflush(stdin);\r\n\t\tprintf(\"\\n请输入第%d个病人的性别：\",i+1);\r\n\t\tscanf(\"%c\",&e[i].gender);\r\n\t\tprintf(\"\\n请输入第%d个病人的身份证：\",i+1);\r\n\t\tscanf(\"%s\",e[i].ID);\r\n\t}\r\n\r\n\tfor (i=0;i<n-1;i++)\r\n\t{\r\n\t\tfor (j=0;j<n-i-1;j++)\r\n\t\t{\r\n\t\t\tif (e[j].level<e[j+1].level)\r\n\t\t\t{\r\n\t\t\t\tt = e[j];\r\n\t\t\t\te[j] = e[j+1];\r\n\t\t\t\te[j+1] = t;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfor (i=0;i<n;i++)\r\n\t{\r\n\t\tenquene(&Q1,e[i]);\r\n\t}\r\n\r\n\tfor (i=0;i<n;i++)\r\n\t{\r\n\t\tdequene(&Q1,&t);\r\n\t\tprintf(\"办理业务 姓名：%s，身份证号：%s,性别：%c，优先级：%d\\n\", t.name,t.ID, t.gender,t.level);\r\n\t}\r\n\r\n\tfree(e);\r\n\te=NULL;\r\n\tsystem(\"pause\");\r\n\treturn 0;\r\n\r\n}\r\n\r\n```", "Konwledge_Point": "优先队列实现", "Question": "医院排队就诊问题（C语言实现）求大神帮忙查看一下如何修改这些错误 （续）\n问题描述：\n\n医院急诊科室，有医生1名\n\n现有病人7名，先后到达\n\n病人病情轻重各有不同（分3级，3级最重，1级最轻），重症的优先就诊；病症相同的，先来的先就诊。\n\n模型假设：\n\n1.病人挂完号后进入对应的科室，每位病人属性包括姓名，性别，和身份证号\n\n2.一开始的时候，医生空闲（等待病人）。\n\n3.有护士根据病人病情，给出病情优先级后，再排队。\n\n4.排队的病人按照先后次序排队，重症的优先就诊，病症相同的，先来的先就诊。。\n\n5.一位医生每次只能看一个病人。\n\n解决方案模型：\n\n1. 程序模拟医院排队就诊，程序开始输入病人资料（包括优先级，姓名，性别，和身份证号）。\n\n2. 设置一个病人的优先队列，按照优先级由高到低，分段排队，最开头的是优先级最高的病人；如果优先级相同，那么按照先来后到的顺序排队。\n\n3. 对病人队列有两种操作，pop与push，医生每次从病人队列里面pop一个病人，并打印病人信息（包括优先级，姓名，性别，和身份证号），直到队列空。\n\n\n\n\n\n请大佬继续补充回答\n\n", "Tag": "算法分析"}
{"Answer": "对给定图进行邻接表表示，并利用队列和栈实现广度优先遍历和深度优先遍历的Python代码实现。同时，程序还支持从键盘输入初始出发的顶点序号，并在遍历过程中输出访问过的结点序号\nfrom collections import defaultdict, deque\n\nclass Graph:\n    def __init__(self, vertices):\n        self.graph = defaultdict(list)\n        self.vertices = vertices\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n\n    def print_graph(self):\n        for vertex in self.graph:\n            print(vertex, \"->\", \" -> \".join(str(i) for i in self.graph[vertex]))\n\n    def bfs(self, start_vertex):\n        visited = [False] * self.vertices\n        queue = deque()\n\n        visited[start_vertex] = True\n        queue.append(start_vertex)\n\n        while queue:\n            start_vertex = queue.popleft()\n            print(start_vertex, end=\" \")\n\n            for vertex in self.graph[start_vertex]:\n                if not visited[vertex]:\n                    visited[vertex] = True\n                    queue.append(vertex)\n\n    def dfs(self, start_vertex):\n        visited = [False] * self.vertices\n        stack = []\n\n        visited[start_vertex] = True\n        stack.append(start_vertex)\n\n        while stack:\n            start_vertex = stack.pop()\n            print(start_vertex, end=\" \")\n\n            for vertex in self.graph[start_vertex]:\n                if not visited[vertex]:\n                    visited[vertex] = True\n                    stack.append(vertex)\n\n    def traverse(self):\n        start_vertex = int(input(\"Enter the starting vertex: \"))\n        print(\"BFS traversal: \")\n        self.bfs(start_vertex)\n        print(\"\\nDFS traversal: \")\n        self.dfs(start_vertex)\n\n\n# Create a sample graph\ng = Graph(5)\ng.add_edge(0, 1)\ng.add_edge(0, 4)\ng.add_edge(1, 2)\ng.add_edge(1, 3)\ng.add_edge(1, 4)\ng.add_edge(2, 3)\ng.add_edge(3, 4)\n\n# Print the graph\ng.print_graph()\n\n# Traverse the graph\ng.traverse()\n\n\n\n输出\n0 -> 1 -> 4\n1 -> 2 -> 3 -> 4\n2 -> 3\n3 -> 4\nEnter the starting vertex: 0\nBFS traversal: \n0 1 4 2 3 \nDFS traversal: \n0 4 1 3 2 \n\n\n", "Konwledge_Point": "优先队列实现", "Question": "数据结构算法求详细解\n5、对任意给定的图（顶点数和边数自定），建立它的邻接表并输出，利用队列的基本运算实现图的广度优先遍历；利用栈的基本运算实现图的深度优先遍历；从键盘输入初始出发的顶点的序号，要求在遍历过程中输出访问过的结点序号。", "Tag": "算法分析"}
{"Answer": "main函数文件中的int visited[MaxSize];这一句注释掉。然后把 int visited[MaxSize];放在.h文件中(const int MaxSize = 10;     这一句下面)，前面加extern就可以了\n\nextern  int visited[MaxSize];\n", "Konwledge_Point": "优先队列实现", "Question": "为什么在main文件中定义的全局变量在类的函数实现文件中访问不到？（使用的VS编程工具）\n问题遇到的现象和发生背景\n\n\n就是照着书上敲代码，然后发现和书上面即使是一样，却发生了bug\n\n\n问题相关代码，请勿粘贴截图\n\n\n//头文件\n\n\n#\nifndef\n MGraph_H        \n//避免重复包含MGraph.h文件\n\n\n#\ndefine\n MGraph_H\n\n\n\nconst\n \nint\n MaxSize = \n10\n;        \n//图中最多顶点个数\n\n\n\ntemplate\n<\nclass\n \nDataType\n>\n\nclass\n \nMGraph\n {\n\npublic\n:\n    \nMGraph\n(DataType a[], \nint\n n, \nint\n e);    \n//构造函数，建立有n个顶点e条边的图\n\n    ~\nMGraph\n() {};    \n//析构函数\n\n    \nvoid\n \nDFSTraverse\n(\nint\n v)\n;        \n//深度优先遍历\n\n    \nvoid\n \nBFSTraverse\n(\nint\n v)\n;        \n//广度优先遍历\n\n\nprivate\n:\n    DataType vertex[MaxSize];    \n//存放途中顶点的数组\n\n    \nint\n arc[MaxSize][MaxSize];    \n//存放途中边的数组\n\n    \nint\n vertexNum, arcNum;        \n//图的顶点数和边数\n\n};\n\n#\nendif\n\n\n\n//类函数实现类文件：\n\n\n#\ninclude\n\n        \n//引入输入输出流\n\n\nusing\n \nnamespace\n std;\n\n#\ninclude\n\"MGraph.h\"\n        \n//引入类MGraph的声明\n\n\n\n\n//以下是对类MGraph的成员函数定义\n\n\ntemplate\n <\nclass\n \nDataType\n>\nMGraph::\nMGraph\n(DataType a[], \nint\n n, \nint\n e) {\n    \nint\n i, j, k;\n    vertexNum = n; arcNum = e;\n    \nfor\n (i = \n0\n; i < vertexNum; i++) {    \n//存储图的顶点信息\n\n        vertex[i] = a[i];\n    }\n    \nfor\n(i=\n0\n;i> i >> j;\n        arc[i][j] = \n1\n; arc[j][i] = \n1\n;\n    }\n}\n\n\ntemplate\n<\nclass\n \nDataType\n>\n\nvoid\n MGraph::\nDFSTraverse\n(\nint\n v) {        \n//深度优先遍历图\n\n    cout << vertex[v]; visited[v] = \n1\n;\n    \nfor\n (\nint\n j = \n0\n; j < vertexNum; j++)\n        \nif\n (arc[v][j] == \n1\n && visited[j] == \n0\n)\n            \nDFSTraverse\n(j);\n}\n\n\ntemplate\n<\nclass\n \nDataType\n>\n\nvoid\n MGraph::\nBFSTraverse\n(\nint\n v)        \n//广度优先遍历图\n\n{\n    \nint\n Q[MaxSize];    \n//假设队列采用顺序存储且不会发生溢出\n\n    \nint\n front = \n-1\n, rear = \n-1\n;        \n//初始化队列\n\n    cout << vertex[v]; visited[v] = \n1\n; Q[++rear] = v;        \n//被访问点入队\n\n    \nwhile\n (front != rear) {\n        v = Q[++front];\n        \nfor\n (\nint\n j = \n0\n; j < vertexNum;j++) {\n            \nif\n (arc[v][j] == \n1\n && visited[j] == \n0\n) {\n                cout << vertex[j]; visited[j]=\n1\n; Q[++rear] = j;\n            }\n        }\n    }\n}\n\n//main函数文件\n\n\n#\ninclude\n\n        \n//引入输入输出流\n\n\nusing\n \nnamespace\n std;\n\n#\ninclude\n\"MGraph.cpp\"\n        \n//引入类MGraph的成员函数定义\n\n\n \nint\n visited[MaxSize];\n\n\n//以下是主函数\n\n\nint\n \nmain\n()\n \n{\n    \nchar\n ch[] = {\n'A'\n,\n'B'\n,\n'C'\n,\n'D'\n,\n'E'\n};    \n//定点信息\n\n    \nMGraph<\nchar\n> \nMG\n(ch, \n5\n, \n6\n)\n;    \n//图中顶点信息是char型\n\n    \nfor\n (\nint\n i = \n0\n; i < MaxSize;i++) {    \n//初始化图中所有顶点均未被访问\n\n        visited[i] = \n0\n;\n    }\n    cout << \n\"深度优先遍历序列是：\"\n;\n    MG.\nDFSTraverse\n(\n0\n);    \n//从顶点0出发进行深度优先遍历图\n\n    cout << endl;\n    \nfor\n (\nint\n i = \n0\n; i < MaxSize;i++) {        \n//初始化途中所有顶点均未被访问\n\n        visited[i] = \n0\n;\n    }\n    cout << \n\"广度优先遍历序列是：\"\n;\n    MG.\nBFSTraverse\n(\n0\n);    \n//从顶点0出发广度优先遍历图\n\n    cout << endl;\n    \nreturn\n \n0\n;\n}\n\n\n\n\n\n运行结果及报错内容\n\n\n\n\n我的解答思路和尝试过的方法\n\n\n使用过将沈明visited放到函数实现类文件的头部，但是出现了其他bug，说是以及有声明了\n\n\n我想要达到的结果\n\n\n解决这visited问题", "Tag": "算法分析"}
{"Answer": "错误太多了，只能简单修改下编译错误\r\n\r\n```\r\n// Q1062027.cpp : Defines the entry point for the console application.\r\n//\r\n\r\n#include \"stdafx.h\"\r\n\r\n\r\n#include\r\n#include\r\n#include\r\n#define OK 1\r\n#define ERROR 0\r\nint M=0;\r\nint N=0;\r\ntypedef int Status;\r\ntypedef struct ElemType\r\n{\r\n    int level;\r\n    char name[20];\r\n    char gender;\r\n    char ID[20];\r\n\r\n}ElemType;\r\ntypedef struct Node   //结点结构\r\n{\r\n    ElemType data;\r\n    struct Node *next;\r\n}Node,*QueuePtr;\r\n\r\ntypedef struct\r\n{\r\n    QueuePtr front,rear;\r\n} LinkQueue;\r\n\r\nStatus InitQueue(LinkQueue **Q)  // 队列初始化\r\n{\r\n   QueuePtr p;\r\n   p=(QueuePtr)malloc(sizeof(QueuePtr));\r\n   if(!p)\r\n   {\r\n       printf(\"内存分配失败\");\r\n       return ERROR;\r\n   }\r\n   *Q=(LinkQueue*)malloc(sizeof(LinkQueue));\r\n   if(!(*Q))\r\n   {\r\n       printf(\"内存分配失败\");\r\n       return ERROR;\r\n   }\r\n   p->next=NULL;\r\n   (*Q)->front=p;\r\n   (*Q)->front=(*Q)->rear;\r\n   return OK;\r\n}\r\n\r\nStatus EnQueue(LinkQueue *Q, ElemType e)  //入队\r\n{\r\n    QueuePtr s=(QueuePtr)malloc(sizeof(Node));\r\n    if(!s)\r\n    {\r\n       printf(\"内存分配失败\");\r\n       return ERROR;\r\n    }\r\n    s->data=e;\r\n    s->next=NULL;\r\n    Q->rear->next=s;      //把拥有元素e的新节点s赋值给队尾的后继节点\r\n    Q->rear=s;            //把当前s设置为队尾节点，rear指向s\r\n    return OK;\r\n}\r\n\r\nStatus DeQueue(LinkQueue *Q,ElemType *e)  //出队\r\n{\r\n    QueuePtr p;\r\n    if(Q->front==Q->rear)\r\n    {\r\n        printf(\"队列为空!\");\r\n        return ERROR;\r\n    }\r\n\r\n    p=Q->front->next;     //  将预删除的队头结点暂存给p\r\n    *e=p->data;             // 将删除的队头结点赋值给e 即出队\r\n    Q->front->next=p->next;  //  将原队头结点后继p->next 赋值给现投结点后继\r\n\r\n    if(Q->rear==p)\r\n    {\r\n        Q->rear=Q->front;      //若队头是队尾，则删除后将rear指向头结点\r\n\r\n    }\r\n     free(p);\r\n\r\n    return OK;\r\n}\r\n\r\nStatus PriorEnQueue(LinkQueue *Q1,LinkQueue *Q2,ElemType e)\r\n{\r\n    if(e.level==3)\r\n       {\r\n           EnQueue(Q1,e);\r\n       }\r\n    else\r\n       {\r\n          EnQueue(Q2,e);\r\n       }\r\n\r\n        return OK;\r\n\r\n}\r\n\r\n\r\nStatus PriorDeQueue(LinkQueue*Q1,LinkQueue*Q2)\r\n{\r\n    ElemType e;\r\n    if(!(Q2->front==Q2->rear))\r\n       DeQueue(Q2,&e);\r\n    else if(!(Q1->front==Q1->rear))\r\n       DeQueue(Q1,&e);\r\n    else\r\n    {\r\n        return ERROR;\r\n    }\r\n    return OK;\r\n\r\n}\r\n\r\nStatus GetIN(LinkQueue*Q1,LinkQueue*Q2,ElemType*e)\r\n{\r\n    int i;\r\n    int n;\r\n    printf(\"请输入前来就诊的病人数量：\");\r\n    scanf(\"%d\",&n);\r\n    for(i=M;i<M+n;i++)\r\n    {\r\n        printf(\"\\n请输入第%d个病人的优先级：\",i+1);\r\n        scanf(\"%d\",&e[i].level);\r\n        printf(\"\\n请输入第%d个病人的姓名：\",i+1);\r\n        scanf(\"%s\",e[i].name);\r\n        printf(\"\\n请输入第%d个病人的性别：\",i+1);\r\n        scanf(\"%s\",&e[i].gender);\r\n        printf(\"\\n请输入第%d个病人的身份证：\",i+1);\r\n        scanf(\"%s\",e[i].ID);\r\n        PriorEnQueue(Q1,Q2,e[i]);\r\n    }\r\n    M=M+n;\r\n    return OK;\r\n}\r\nStatus ShowInformation(ElemType *e)\r\n{\r\n    int i;\r\n    LinkQueue *Q1,*Q2;\r\n    InitQueue(&Q1);\r\n    InitQueue(&Q2);\r\n    PriorDeQueue(Q1,Q2);\r\n    printf(\"优先级----------姓名----------性别----------身份证\\n\");\r\n    for(i=N;i<N;i++)\r\n    {\r\n        printf(\"\\n\");\r\n        printf(\"%5d %5s %5s %10s\",e[i].level,e[i].name,&e[i].gender,e[i].ID);\r\n    }\r\n    return OK;\r\n}\r\nint main()\r\n{\r\n    LinkQueue Q1,Q2;\r\n\tQ1.front=Q1.rear=NULL;\r\n\tQ2.front=Q2.rear=NULL;\r\n    ElemType e;\r\n    GetIN(&Q1,&Q2,&e);\r\n    ShowInformation(&e);\r\n    return 0;\r\n\r\n}\r\n\r\n\r\n```\r\n# 问题采纳了可以继续帮你看运行的错误", "Konwledge_Point": "优先队列实现", "Question": "医院排队就诊问题（C语言实现）求大神帮忙查看一下如何修改这些错误\n问题描述：\n\n医院急诊科室，有医生1名\n\n现有病人7名，先后到达\n\n病人病情轻重各有不同（分3级，3级最重，1级最轻），重症的优先就诊；病症相同的，先来的先就诊。\n\n模型假设：\n\n1.病人挂完号后进入对应的科室，每位病人属性包括姓名，性别，和身份证号\n\n2.一开始的时候，医生空闲（等待病人）。\n\n3.有护士根据病人病情，给出病情优先级后，再排队。\n\n4.排队的病人按照先后次序排队，重症的优先就诊，病症相同的，先来的先就诊。。\n\n5.一位医生每次只能看一个病人。\n\n解决方案模型：\n\n1. 程序模拟医院排队就诊，程序开始输入病人资料（包括优先级，姓名，性别，和身份证号）。\n\n2. 设置一个病人的优先队列，按照优先级由高到低，分段排队，最开头的是优先级最高的病人；如果优先级相同，那么按照先来后到的顺序排队。\n\n3. 对病人队列有两种操作，pop与push，医生每次从病人队列里面pop一个病人，并打印病人信息（包括优先级，姓名，性别，和身份证号），直到队列空。\n\n————————————————\n\n运行输入：\n\n请按照优先级，姓名，性别，和身份证号顺序输入：\n\n1 吕雅畅 男 141130198509277099\n\n1 卞丹丹 女 532925197204181629\n\n2 潘德茂 男 500114197005227938\n\n1 邬碧玉 女 620721198202232320\n\n3 金慧雅 女 533123198508252640\n\n2 岑俊茂 男 152526198707214777\n\n3 毕采萱 女 420600198202107509\n\n\n\n输出：\n\n就诊顺序......\n\n3 金慧雅 女 533123198508252640\n\n3 毕采萱 女 420600198202107509\n\n2 潘德茂 男 500114197005227938\n\n2 岑俊茂 男 152526198707214777\n\n1 吕雅畅 男 141130198509277099\n\n1 卞丹丹 女 532925197204181629\n\n1 邬碧玉 女 620721198202232320\n\n\n\n#include\n#include\n#include\n#define OK 1\n#define ERROR 0\nint M=0;\nint N=0;\ntypedef int Status;\ntypedef struct ElemType\n{\n    int level;\n    char name[20];\n    char gender;\n    char ID[20];\n\n}ElemType;\ntypedef struct Node   //结点结构\n{\n    ElemType data;\n    struct Node *next;\n}Node,*QueuePtr;\n\ntypedef struct\n{\n    QueuePtr front,rear;\n} LinkQueue;\n\nStatus InitQueue(LinkQueue *Q)  // 队列初始化\n{\n   QueuePtr p;\n   p=(QueuePtr)malloc(sizeof(QueuePtr));\n   if(!p)\n   {\n       printf(\"内存分配失败\");\n       return ERROR;\n   }\n   Q=(LinkQueue*)malloc(sizeof(LinkQueue));\n   if(!Q)\n   {\n       printf(\"内存分配失败\");\n       return ERROR;\n   }\n   p->next=NULL;\n   Q->front=p;\n   Q->front=Q->rear;\n   return OK;\n}\n\nStatus EnQueue(LinkQueue *Q, ElemType e)  //入队\n{\n    QueuePtr s=(QueuePtr)malloc(sizeof(Node));\n    if(!s)\n    {\n       printf(\"内存分配失败\");\n       return ERROR;\n    }\n    s->data=e;\n    s->next=NULL;\n    Q->rear->next=s;      //把拥有元素e的新节点s赋值给队尾的后继节点\n    Q->rear=s;            //把当前s设置为队尾节点，rear指向s\n    return OK;\n}\n\nStatus DeQueue(LinkQueue *Q,ElemType *e)  //出队\n{\n    QueuePtr p;\n    if(Q->front==Q->rear)\n    {\n        printf(\"队列为空!\");\n        return ERROR;\n    }\n\n    p=Q->front->next;     //  将预删除的队头结点暂存给p\n    *e=p->data;             // 将删除的队头结点赋值给e 即出队\n    Q->front->next=p->next;  //  将原队头结点后继p->next 赋值给现投结点后继\n\n    if(Q->rear==p)\n    {\n        Q->rear=Q->front;      //若队头是队尾，则删除后将rear指向头结点\n\n    }\n     free(p);\n\n    return OK;\n}\n\nStatus PriorEnQueue(LinkQueue *Q1,LinkQueue *Q2,ElemType *e)\n{\n    if(e->level==3)\n       {\n           EnQueue(Q1,e);\n       }\n    else\n       {\n          EnQueue(Q2,e);\n       }\n\n        return OK;\n\n}\n\n\nStatus PriorDeQueue(LinkQueue*Q1,LinkQueue*Q2)\n{\n    ElemType *e;\n    if(!(Q2->front==Q2->rear))\n       e=DeQueue(Q2,e);\n    else if(!(Q1->front==Q1->rear))\n        e=DeQueue(Q1,e);\n    else\n    {\n        return ERROR;\n    }\n    return OK;\n\n}\n\nStatus GetIN(LinkQueue*Q1,LinkQueue*Q2,ElemType*e)\n{\n    int i;\n    int n;\n    printf(\"请输入前来就诊的病人数量：\");\n    scanf(\"%d\",&n);\n    for(i=M;i<M+N;i++)\n    {\n        printf(\"\\n请输入第%d个病人的优先级：\",i+1);\n        scanf(\"%d\",&e[i].level);\n        printf(\"\\n请输入第%d个病人的姓名：\",i+1);\n        scanf(\"%s\",e[i].name);\n        printf(\"\\n请输入第%d个病人的性别：\",i+1);\n        scanf(\"%s\",&e[i].gender);\n        printf(\"\\n请输入第%d个病人的身份证：\",i+1);\n        scanf(\"%s\",e[i].ID);\n        PriorEnQueue(Q1,Q2,e);\n    }\n    M=M+n;\n    return OK;\n}\nStatus ShowInformation(ElemType *e)\n{\n    int i;\n    LinkQueue *Q1,*Q2;\n    InitQueue(Q1);\n    InitQueue(Q2);\n    PriorDeQueue(Q1,Q2);\n    printf(\"优先级----------姓名----------性别----------身份证\\n\");\n    for(i=N;i<N;i++)\n    {\n        printf(\"\\n\");\n        printf(\"%5d %5s %5s %10s\",e[i].level,e[i].name,&e[i].gender,e[i].ID);\n    }\n    return OK;\n}\nint main()\n{\n    LinkQueue *Q1,*Q2;\n    ElemType *e;\n    GetIN(Q1,Q2,e);\n    ShowInformation(e);\n    return 0;\n\n}\n\n\n\n\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "操作符和f_dis函数加上const修饰，代码修改如下：\n\n#include<cstdio>\n#include<cmath>\n#include<queue>\n#include<vector>\nusing namespace std;\nconst int N=100,M=100;\nint n,m;\nbool map[N][M]; \nclass map\n{\nprivate:\n\tbool **p;\n\tint n,m;\n\tinline bool isin(const int x1,const int y1,const int x2,const int y2,const int i,const int j)\n\t{\n\t\treturn (((i>=((x1>x2)?x2:x1))&&(i<=((x1>x2)?x1:x2)))&&((j>=((y1>y2)?y2:y1))&&(j<=((y1>y2)?y1:y2))));\n\t}\n\tstruct point\n\t{\n\t\tstatic int tar_x,tar_y;\n\t\tint x,y,b_dis;\n\t\tint f_dis() const  //修改1\n\t\t{\n\t\t\treturn abs(x-tar_x)+abs(y-tar_y);\n\t\t}\n\t\tbool operator<(const point b)const   //修改2\n\t\t{\n\t\t\treturn (b_dis+f_dis())>(b.b_dis+b.f_dis());\n\t\t}\n\t};\npublic:\n\tmap(const int N,const int M)\n\t{\n\t\tn=N;\n\t\tm=M;\n\t\tp=new bool*[N+1];\n\t\tfor(int i=1;i<=N;i++)\n\t\t\tp[i]=new bool[M+1];\n\t}\n\t~map()\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tdelete[] p[i];\n\t\tdelete[] p;\n\t}\n\tvoid set_obstruction(const int x,const int y)\n\t{\n\t\tp[x][y]=true;\n\t\treturn;\n\t}\n\tvoid set_obstruction(const int x1,const int y1,const int x2,const int y2)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t\tif(isin(x1,y1,x2,y2,i,j))\n\t\t\t\t\tp[i][j]=true;\n\t\treturn;\n\t}\n\tint get_way(const int x1,const int y1,const int x2,const int y2)\n\t{\n\t\tpriority_queue<point> q;\n\t\tpoint::tar_x=x2;\n\t\tpoint::tar_y=y2;\n\t\tpoint start;\n\t\tstart.x=x1;\n\t\tstart.y=y1;\n\t\tq.push(start);\n\t}\n};\nint main()\n{\n\n\treturn 0;\n}\n//我想写一个A*寻路实现，但是这段BFS的优先队列似乎因为结构体的重载运算符跑不了了（555~~），求大佬告知怎么改啊？ ", "Konwledge_Point": "优先队列实现", "Question": "以下这段C++代码为啥跑不了？\n\n\n#include\n#include\n#include\n#include\nusing namespace std;\nconst int N=100,M=100;\nint n,m;\nbool map[N][M]; \nclass map\n{\n\tprivate:\n\t\tbool **p;\n\t\tint n,m;\n\t\tinline bool isin(const int x1,const int y1,const int x2,const int y2,const int i,const int j)\n\t\t{\n\t\t\treturn (((i>=((x1>x2)?x2:x1))&&(i<=((x1>x2)?x1:x2)))&&((j>=((y1>y2)?y2:y1))&&(j<=((y1>y2)?y1:y2))));\n\t\t}\n\t\tstruct point\n\t\t{\n\t\t\tstatic int tar_x,tar_y;\n\t\t\tint x,y,b_dis;\n\t\t\tint f_dis()\n\t\t\t{\n\t\t\t\treturn abs(x-tar_x)+abs(y-tar_y);\n\t\t\t}\n\t\t\tbool operator<(point b)\n\t\t\t{\n\t\t\t\treturn (b_dis+f_dis())>(b.b_dis+b.f_dis());\n\t\t\t}\n\t\t};\n\tpublic:\n\t\tmap(const int N,const int M)\n\t\t{\n\t\t\tn=N;\n\t\t\tm=M;\n\t\t\tp=new bool*[N+1];\n\t\t\tfor(int i=1;i<=N;i++)\n\t\t\t\tp[i]=new bool[M+1];\n\t\t}\n\t\t~map()\n\t\t{\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tdelete[] p[i];\n\t\t\tdelete[] p;\n\t\t}\n\t\tvoid set_obstruction(const int x,const int y)\n\t\t{\n\t\t\tp[x][y]=true;\n\t\t\treturn;\n\t\t}\n\t\tvoid set_obstruction(const int x1,const int y1,const int x2,const int y2)\n\t\t{\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t\t\tif(isin(x1,y1,x2,y2,i,j))\n\t\t\t\t\t\tp[i][j]=true;\n\t\t\treturn;\n\t\t}\n\t\tint get_way(const int x1,const int y1,const int x2,const int y2)\n\t\t{\n\t\t\tpriority_queue q;\n\t\t\tpoint::tar_x=x2;\n\t\t\tpoint::tar_y=y2;\n\t\t\tpoint start;\n\t\t\tstart.x=x1;\n\t\t\tstart.y=y1;\n\t\t\tq.push(start);\n\t\t}\n};\nint main()\n{\n\t\n\treturn 0;\n}\n//我想写一个A*寻路实现，但是这段BFS的优先队列似乎因为结构体的重载运算符跑不了了（555~~），求大佬告知怎么改啊？ ", "Tag": "算法分析"}
{"Answer": "具体的步骤如下:\n1.启动Netty服务，运行上面给出的启动代码2.启动WireShark，并选择本机网卡上的流量3.进行过滤，比如过滤出Netty服务端口为8085的流量4.开始抓包，并分析抓取到的包5.需要注意的是，WireShark需要管理员权限运行\n\n如果遇到问题，检查以下几点：\n1.依赖库是否正确引入2.网络是否正常3.端口是否被占用4.是否有其他程序正在使用相同的端口5.是否有权限启动服务6.配置文件是否正确仅供参考，望采纳，谢谢。", "Konwledge_Point": "优先队列实现", "Question": "Netty怎么用WireShark抓包呢\nNetty怎么用WireShark抓包呢？\n\n\n这是启动的代码\n\n\n@ServiceScan\n\n\npublic\n \nclass\n \nServer\n {\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[] args\n) {\n        \ntry\n {\n            \nNettyServer\n nettyServer = \nnew\n \nNettyServer\n(\n\"192.168.10.1\"\n, \n8085\n, \nSerializerCode\n.\nHESSIAN\n.\ngetCode\n());\n            nettyServer.\nstart\n();\n        } \ncatch\n (\nRpcException\n e) {\n            e.\nprintStackTrace\n();\n        }\n    }\n}\n\n\n\n@Slf4j\npublic \nclass\n NettyServer extends AbstractRpcServer {\n\n\n    \n/**\n     * 服务器启动时 优先做一些预加载\n     */\n\n    \n    \n/**\n     *\n     * @param hostName 启动服务所在机器的主机号，可以是私网或者公网\n     * @param port 启动服务所在机器的端口号\n     * @param serializerCode 序列化代码\n     * @throws RpcException\n     */\n\n    public \nNettyServer(String \nhostName\n, \nint\n \nport\n, Integer \nserializerCode\n)\n throws RpcException {\n        this.hostName = hostName.equals(\n\"localhost\"\n)\n || \nhostName.equals(\n\"127.0.0.1\"\n) ? \nIpUtils\n.\nget\nPubIpAddr()\n : hostName;\n        log.info(\n\"start with host: {}, port: {}\"\n, this.hostName, port);\n        this.port = port;\n        \n//serviceRegistry = new NacosServiceRegistry();\n\n        \n//serviceProvider = new DefaultServiceProvider();\n\n        \n/**\n         * 使用 SPI 机制，接口与实现类解耦到配置文件\n         */\n\n        serviceRegistry = \nServiceLoader\n.\nload(\nServiceRegistry\n.\nclass\n).iterator\n()\n.next\n()\n;\n        serviceProvider = \nServiceLoader\n.\nload(\nServiceProvider\n.\nclass\n).iterator\n()\n.next\n()\n;\n\n        serializer = \nCommonSerializer\n.\nget\nByCode(\nserializerCode\n)\n;\n        \n// 扫描 @ServiceScan 包下的 所有 @Service类，并 注册它们\n\n        scan\nServices()\n;\n    }\n\n    @Override\n    public void start\n()\n {\n        \n/**\n         *  封装了 之前 使用的 线程吃 和 任务队列\n         *  实现了 ExecutorService 接口\n         */\n\n        \nShutdownHook\n.\nget\nShutdownHook()\n.add\nClearAllHook()\n;\n        EventLoopGroup bossGroup = \nnew\n \nNioEventLoopGroup()\n;\n        EventLoopGroup workerGroup = \nnew\n \nNioEventLoopGroup()\n;\n\n        \ntry\n {   \n            \n/**\n             *  启动服务\n             */\n\n            ServerBootstrap serverBootstrap = \nnew\n \nServerBootstrap()\n;\n            serverBootstrap.group(bossGroup, workerGroup)\n                    .channel(\nNioServerSocketChannel\n.\nclass\n)\n                    .handler(\nnew\n \nLoggingHandler(LogLevel.INFO)\n)\n                    .option(ChannelOption.SO_BACKLOG, \n256\n)\n                    .option(ChannelOption.SO_KEEPALIVE, \ntrue\n)\n                    .child\nOption(ChannelOption.TCP_NODELAY, \ntrue\n)\n\n                    .child\nHandler(\nnew\n ChannelInitializer()\n {\n                        @Override\n                        protected void init\nChannel(SocketChannel \nch\n)\n throws Exception {\n                            ChannelPipeline pipeline = ch.pipeline\n()\n;\n                            \n/**\n                             * 读 超时 触发, WriteIdleTime 和 allIdleTime 为 0 表示不做处理\n                             */\n\n                            pipeline.add\nLast(\nnew\n IdleStateHandler(30, 0, 0, TimeUnit.SECONDS)\n);\n                            pipeline.add\nLast(\nnew\n CommonEncoder(\nserializer\n)\n);\n                            pipeline.add\nLast(\nnew\n CommonDecoder()\n);\n                            pipeline.add\nLast(\nnew\n NettyServerHandler()\n);\n                        }\n                    });\n            ChannelFuture future = serverBootstrap.bind(port).sync\n()\n;\n            future.channel\n()\n.close\nFuture()\n.sync\n()\n;\n\n        } catch (Exception e) {\n            log.error(\n\"Error occurred while starting server! {}\"\n,e);\n            e.print\nStackTrace()\n;\n        } finally {\n            bossGroup.shutdown\nGracefully()\n;\n            workerGroup.shutdown\nGracefully()\n;\n        }\n    }\n\n}\n\n\n\nWireshark怎么抓呀，我一直没抓到\n\n\n\n", "Tag": "算法分析"}
{"Answer": "兄弟新加的程序位置应该在输入函数，而不是打印函数啊", "Konwledge_Point": "优先队列实现", "Question": "想先删掉链表里的VIP客户再删掉Ordinary客户该怎么写delete函数？\n问题描述\n注意：用链表完成\n现在银行都有排队叫号系统，如果你到银行去办理业务，首先取得一个顺序号，并告诉你前面有多少人在等待。\n现在请你设计、并实现该系统。\n\n\n客户信息包括：取号的号码、客户银行卡号码、客户类型（包括普通客户和vip客户，分别用Ordinary和VIP表示）。\nVIP用户有优先权，即VIP入队时，可以插入到  所有Ordinary类型用户的前面，已经排队的最后一个VIP用户的后面。\n\n\n本题要求实现以下功能：\n（1）客户进入银行并取号，该功能对应的命令为IN number type，number表示客户银行卡号码，type表示客户类型。\n（2）在上一题基础上，按取号顺序列出当前未办理业务的客户信息，该功能对应的命令为LIST。\n（3）客户办理完业务并离开银行，该功能对应的命令为OUT。\n（4）退出系统，该功能对应的命令为QUIT。\n\n\n输入\n输入有多行，每行表示一种操作。\n\n\n本题实现的操作有：\nIN guestnumber guesttype\n其中IN 表示入队，guestnumber表示客户银行卡号码，guesttype有两种取值，分别为Ordinary和VIP，表示普通客户与VIP客户。\n\n\nLIST\n按取号的顺序输出队列中所有排队的客户信息。\n\n\nQUIT\n退出银行排队系统\n\n\n请注意：输入的数据中，只有最后一个命令是QUIT命令。\n输出\n输出有多行，对不同的命令给出不同的输出。\n\n\n以下是具体的输出说明：\nIN 客户银行卡号码　客户类型\n该命令首先在单独的一行中输出\"IN:\", 然后再输出客户信息。\n客户信息包括客户编号 客户银行卡号码　客户类型 该客户前面的客户数。客户编号由系统在客户取号的时候给定，从1开始顺序编号。\n客户类型分为Ordinary和VIP。数据之间用一个空格分开。\n\n\n请注意：\n第一个客户入队后，则该用户的顺序号为1，前面有0个客户等待；\n第二个客户入队后，则该用户的顺序号为2，前面有1个客户等待。\n以此类推。\n\n\nLIST\n该命令首先在单独的一行中输出\"LIST:\", 后面有若干行先按客户类型（VIP优先），再按客户取号的顺序输出，每一行输出一个客户的信息，每行的输出格式为\n客户编号 客户银行卡号码 客户类型\n\n\nOUT\n该命令首先在单独的一行中输出\"OUT:\"，接下来一行输出办理业务的客户信息，包括顺序号，客户银行卡号码和客户类型。\n如果没有办理业务的客户，则输出\"FAILED:\"。\n\n\nQUIT\n在单独的一行中显示\"GOOD BYE!\"后结束程序。\n输入样列\nIN 1000001 Ordinary\nIN 2000003 VIP\nIN 2000009 VIP\nOUT\nOUT\nOUT\nOUT\nIN 1000007 Ordinary\nIN 2000005 VIP\nLIST\nOUT\nQUIT\n\n\n输出样例\nIN:1 1000001 Ordinary 0\nIN:2 2000003 VIP 0\nIN:3 2000009 VIP 1\nOUT:2 2000003 VIP\nOUT:3 2000009 VIP\nOUT:1 1000001 Ordinary\nFAILED:\nIN:4 1000007 Ordinary 0\nIN:5 2000005 VIP 0\nLIST:\n5 2000005 VIP\n4 1000007 Ordinary\nOUT:5 2000005 VIP\nGOOD BYE!\n\n\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\ntypedef\n \nstruct\n \nClient\n{\n    \nint\n sernumber;\n    \nchar\n guestnumber[\n20\n];\n    \nchar\n guesttype[\n20\n];\n    \nstruct\n \nClient\n *next;\n}\nClient\n;\n\nint\n n=\n0\n;\n\nint\n wait1=\n0\n,wait2=\n0\n;\n\nint\n out1=\n0\n,out2=\n0\n;\n\nvoid\n \ninputSingle\n(\nClient\n *s)\n\n\n{\n    \nscanf\n(\n\"%s %s\"\n,s->guestnumber,s->guesttype);\n}\n\nvoid\n \noutputSingle\n(\nClient\n *s)\n\n\n{\n    n+=\n1\n;\n    s->sernumber=n;\n    \nif\n(\nstrcmp\n(s->guesttype,\n\"VIP\"\n)==\n0\n){\n        \nprintf\n(\n\"%d %s %s %d\\n\"\n,s->sernumber,s->guestnumber,s->guesttype,wait1-out1);\n        wait1++;\n    }\n    \nif\n(\nstrcmp\n(s->guesttype,\n\"Ordinary\"\n)==\n0\n){\n        \nprintf\n(\n\"%d %s %s %d\\n\"\n,s->sernumber,s->guestnumber,s->guesttype,wait2-out1-out2);\n        wait2++;\n    }\n}\n\nvoid\n \noutputList\n(\nClient\n *L)\n\n\n{\n    \nClient\n *p;\n    p=L->next;\n    \nwhile\n(p!=\nNULL\n){\n        \noutputSingle\n(p);\n        p=p->next;\n    }\n}\n\nvoid\n \ninsert\n(\nClient\n *L,\nClient\n *s)\n\n\n{\n    \nClient\n *pre,*p;\n    pre=L;\n    p=L->next;\n    \nwhile\n(p!=\nNULL\n){\n        pre=p;\n        p=p->next;\n    }\n    s->next=pre-next;\n    pre->next=s;\n}\n\nint\n \ndelete\n(\nClient\n *L,\nClient\n *s)\n\n\n{\n    \nClient\n *pre,*p;\n    pre=L;\n    p=L->next;\n    \nwhile\n(p!=\nNULL\n&&\nstrcmp\n(p->guesttype,\n\"VIP\"\n)==\n0\n){\n        pre->next=p->next;\n        \nfree\n(p);\n        out1++;\n    }\n    \nif\n(p==\nNULL\n){\n        \nreturn\n \n0\n;\n    }\n    \nelse\n{\n        pre=p;\n        p=p->next;\n    }\n}\n\nClient\n* \ncreateList\n()\n\n\n{\n    \nClient\n *L;\n    L=(\nClient\n *)\nmalloc\n(\nsizeof\n(\nClient\n));\n    L->next=\nNULL\n;\n    \nreturn\n L;\n}\n\n\nint\n \nmain\n()\n\n\n{\n    \nClient\n *s,*L;\n    string order;\n    \nwhile\n(\n1\n){\n        cin>>order;\n        \nif\n(order==\n\"IN\"\n){\n            \nprintf\n(\n\"IN:\"\n);\n            s=(\nClient\n *)\nmalloc\n(\nsizeof\n(\nClient\n));\n            \ninputSingle\n(s);\n            \noutputSingle\n(s);\n        }\n        \nif\n(order==\n\"LIST\"\n){\n            \nputs\n(\n\"LIST:\"\n);\n            \noutputList\n(L);\n        }\n        \nif\n(order==\n\"OUT\"\n){\n            \n        }\n    }\n    \nreturn\n \n0\n;\n}\n\n\n\n暂时只写了这些，我想能不能遍历链表两遍，先删掉VIP再删掉Ordinary呢？但是我不知道咋写", "Tag": "算法分析"}
{"Answer": "你看下这篇博客吧, 应该有用👉 ：java中的空指针异常", "Konwledge_Point": "优先队列实现", "Question": "空指针异常 java.lang，如何解决？\njava.lang.NullPointerException\n空指针异常 找了半天没找到\n有会的指导一下吗\njava.lang.NullPointerException\n\n\npackage Search;\n\n\nimport java.io.IOException;\nimport java.util.Scanner;\n\n\npublic class Chuanyueleichi1 {\n    /*\n     * 题目描述\n    X星的坦克战车很奇怪，它必须交替地穿越正能量辐射区和负能量辐射区才能保持正常运转，\n    否则将报废。\n    某坦克需要从A区到B区去（A，B区本身是安全区，没有正能量或负能量特征），\n    怎样走才能路径最短？\n\n\n已知的地图是一个方阵，上面用字母标出了A，B区，\n其它区都标了正号或负号分别表示正负能量辐射区。\n例如：\nA + - + -\n- + - - +\n- + + + -\n+ - + - +\nB + - + -\n\n坦克车只能水平或垂直方向上移动到相邻的区。\n\n输入格式\n输入第一行是一个整数n，表示方阵的大小， \n4\n<=n<\n100\n\n接下来是n行，每行有n个数据，可能是A，B，+，-中的某一个，中间用空格分开。\nA，B都只出现一次。\n输出格式\n要求输出一个整数，表示坦克从A区到B区的最少移动步数。\n如果没有方案，则输出\n-1\n\n\n样例输入\n\n5\n\nA + - + -\n- + - - +\n- + + + -\n+ - + - +\nB + - + -\n样例输出\n\n10\n\n\n思想\n\n1.\n图的广度优先算法 直接算出最短路径所用，数据结构 队列（在chuanyueleichi2中具体实现）\n\n2.\n图的深度优先算法 遍历所有路径，求出最小路径（具体在本类实现）\n\n\n步骤\n一.建立全局变量\n    \n1.\n坐标（x，y）\n    \n2.\n当前区域辐射值\n    \n3.\n达到该区所走步数\n二.输入，初始化节点\n    \n1.\n找到A区位置，并赋值给dfs入口\n三.dfs建立\n    \n1.\n注意回溯\n*/\n\npublic\n \nstatic\n \nString\n[][] arr  = \nnew\n \nString\n[\n101\n][\n101\n] ;\n\npublic\n \nstatic\n \nint\n n = \n0\n;\n//雷区大小\n\n\npublic\n \nstatic\n \nint\n x =\n0\n,y =\n0\n;\n\npublic\n \nstatic\n \nint\n min = \n0\n;\n//记录到达B区最小步数\n\n\npublic\n \nstatic\n \nint\n[][] visit =  \nnew\n \nint\n[\n101\n][\n101\n];\n//标记已走过的雷区 初始值为0 表示都没走过\n\n\npublic\n \nstatic\n \nint\n []fx = {\n1\n,\n0\n,\n-1\n,\n0\n};\n\npublic\n \nstatic\n \nint\n []fy = {\n0\n,\n-1\n,\n0\n,\n-1\n};\n//表示移动方向分别是 下 右 上 左\n\n\npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[] args)\n throws NumberFormatException, IOException \n{\n    \n// TODO Auto-generated method stub\n\n    \n    Scanner sc = \nnew\n \nScanner\n(System.in);\n     n = sc.\nnextInt\n();\n//雷区大小\n\n    \nint\n a = \n0\n,b=\n0\n;\n    \n//arr = new String[n+1][n+1];\n\n    \n//visit = new int[n+1][n+1];\n\n    \nfor\n(\nint\n i = \n1\n ; i <= n; i++) {\n        \nfor\n(\nint\n j = \n1\n ; j<= n ;j++) {\n            arr[i][j] = sc.\nnext\n();\n            \n            \nif\n(arr[i][j].\nequals\n(\n\"A\"\n)) {\n                a = i;\n                b = j;\n            }\n        }\n    }\n    \ndfs\n(a,b,\n\"o\"\n,\n0\n);\n    System.out.\nprintln\n(min);\n}\n\n\n//输入为坐标  当前的状态（+，-，A，B），当前的步数\n\n\nprivate\n \nstatic\n \nvoid\n \ndfs\n(\nint\n x, \nint\n y, \nString\n status, \nint\n step)\n \n{\n    \n// TODO Auto-generated method stub\n\n    \nif\n(arr[x][y].\nequals\n(\n\"B\"\n)) {\n        min = Math.\nmin\n(step, min);\n        \nreturn\n ;\n    }\n    \n    \nint\n x1 = \n0\n ,y1 = \n0\n;\n//表示移动的坐标\n\n    \nfor\n(\nint\n i = \n0\n ; i < \n4\n ;i++) {\n        x1 = x +fx[i];\n        y1 = y +fy[i];\n        \n//判断接下来的雷区是否符合要求 且没有重复\n\n        \nif\n( \nis\n(x1,y1,x,y)&&visit[x1][y1]!=\n1\n) {\n            \n//符合的话 标记 已访问\n\n            visit[x1][y1]=\n1\n;\n            \ndfs\n(x1,y1,arr[x1][y1],step+\n1\n);\n//进入递归\n\n            \n//当前递归结束 访问标记位取消 以免 访问不到B区（如果有B 区的话）\n\n            visit[x1][y1]=\n0\n;\n        }\n    }\n    \n    \n}\n\n\nprivate\n \nstatic\n \nboolean\n \nis\n(\nint\n x1, \nint\n y1,\nint\n x,\nint\n y)\n \n{\n    \n// TODO Auto-generated method stub\n\n    \nif\n(x1 >= \n0\n&& x1 <= n && y1 >= \n0\n&& y1 <=n&&arr[x1][y1]!=arr[x][y])\n        \nreturn\n \ntrue\n;\n    \nreturn\n \nfalse\n;\n}\n\n\n\n}\n\n\nException in thread \"main\" java.lang.NullPointerException\n    at BlueCup/Search.Chuanyueleichi1.dfs(Chuanyueleichi1.java:90)\n    at BlueCup/Search.Chuanyueleichi1.dfs(Chuanyueleichi1.java:103)\n    at BlueCup/Search.Chuanyueleichi1.dfs(Chuanyueleichi1.java:103)\n    at BlueCup/Search.Chuanyueleichi1.dfs(Chuanyueleichi1.java:103)\n    at BlueCup/Search.Chuanyueleichi1.dfs(Chuanyueleichi1.java:103)\n    at BlueCup/Search.Chuanyueleichi1.main(Chuanyueleichi1.java:83)", "Tag": "算法分析"}
{"Answer": "你这里面使用了递归没有 ？ \r\n\r\n看你这种情况，引起堆栈溢出的可能性，有两种。一种是递归，一种就是内存没有往堆上分配，即没有使用malloc等内存分配函数。\r\n\r\n我认为递归引起的可能性更大。", "Konwledge_Point": "优先队列实现", "Question": "AI八数码问题 Stack Overflow\nAI课本八数码问题，我是用广度优先搜索，用Ismatch来记录状态是否已经遍历，个人感觉算法基本没错吧！可是编译程序的时候只要步数长一点（5步可以输出）就没有输出，用Debug调试显示是：Stack Overflow。我看了很久的代码，也没有搞懂需要在哪里做优化。希望大家看下给点意见。谢谢\n\n[code=\"c\"]#include \n\n#include \n\n#define M 362881\n\n\n\nbool IsAnswer = false;\n\nbool Ismatch[M];//标记是否已经遍历过\n\nint tos,len;//队列指针tos,长度len\n\nint tt[9]={1,1,2,6,24,120,720,5040,40320};\n\nchar dest[10];//目标状态\n\nchar tmap[10];\n\nenum dir{up,down,left,right,none};\n\n\n\nstruct {\n\n    int dir;\n\n    int t;\n\n}path[M];//记录路径\n\n\n\nstruct eightnum{\n\n    char map[10];\n\n    int x,y;\n\n    int father;\n\n    dir myDir;//父节点移动的方向\n\n}num[M];\n\neightnum temp;\n\n\n\nvoid back_push(eightnum _num)//push\n\n{\n\n    strcpy(num[len].map, _num.map);\n\n    num[len].x = _num.x;\n\n    num[len].y = _num.y;\n\n    num[len].father = _num.father;\n\n    num[len].myDir = _num.myDir;\n\n    ++len;\n\n}\n\n\n\neightnum front_pop()//pop\n\n{\n\n    tos++;\n\n    if(tos=M){//flow\n\n        printf(\"Above Flow!\");\n\n        return ;\n\n    }\n\n    else{\n\n        //down\n\n        if( _tmp.x != 2){\n\n            strcpy(tmap,_tmp.map);\n\n            char m_tmp;\n\n            m_tmp = tmap[_tmp.x*3+_tmp.y];\n\n            tmap[_tmp.x*3+_tmp.y] = tmap[(_tmp.x+1)*3+_tmp.y];\n\n            tmap[(_tmp.x+1)*3+_tmp.y] = m_tmp;\n\n            int m_hash = getHash(tmap);\n\n            if(Ismatch[m_hash]==false){\n\n                Ismatch[m_hash] = true;\n\n                strcpy(temp.map,tmap);\n\n                temp.x = _tmp.x + 1;\n\n                temp.y = _tmp.y;\n\n                temp.father = tos;\n\n                temp.myDir = down;\n\n                back_push(temp);\n\n            }\n\n        }\n\n        //right\n\n        if( _tmp.y != 2 ){\n\n            strcpy(tmap,_tmp.map);\n\n            char m_tmp;\n\n            m_tmp = tmap[(_tmp.x)*3+_tmp.y];\n\n            tmap[(_tmp.x)*3+_tmp.y]= tmap[(_tmp.x)*3+_tmp.y+1];\n\n            tmap[(_tmp.x)*3+_tmp.y+1] = m_tmp;\n\n            int m_hash = getHash(tmap);\n\n            if(Ismatch[m_hash]==false){\n\n                Ismatch[m_hash] = true;\n\n                strcpy(temp.map,tmap);\n\n                temp.x = _tmp.x;\n\n                temp.y = _tmp.y+1;\n\n                temp.father = tos;\n\n                temp.myDir = right;\n\n                back_push(temp);\n\n            }\n\n        }\n\n        //up\n\n        if(_tmp.x != 0){\n\n            strcpy(tmap,_tmp.map);\n\n            char m_tmp;\n\n            m_tmp = tmap[_tmp.x*3+_tmp.y];\n\n            tmap[_tmp.x*3+_tmp.y] = tmap[(_tmp.x-1)*3+_tmp.y];\n\n            tmap[(_tmp.x-1)*3+_tmp.y] = m_tmp;\n\n            int m_hash = getHash(tmap);\n\n            if(Ismatch[m_hash]==false){\n\n                Ismatch[m_hash] = true;\n\n                strcpy(temp.map,tmap);\n\n                temp.x = _tmp.x - 1;\n\n                temp.y = _tmp.y;\n\n                temp.father = tos;\n\n                temp.myDir = up;\n\n                back_push(temp);\n\n            }\n\n        }\n\n        //left\n\n        if( _tmp.y != 0 ){\n\n            strcpy(tmap,_tmp.map);\n\n            char m_tmp;\n\n            m_tmp = tmap[_tmp.x*3+_tmp.y];\n\n            tmap[_tmp.x*3+_tmp.y]= tmap[(_tmp.x)*3+_tmp.y-1];\n\n            tmap[(_tmp.x)*3+_tmp.y-1] = m_tmp;\n\n            int m_hash = getHash(tmap);\n\n            if(Ismatch[m_hash]==false){\n\n                Ismatch[m_hash] = true;\n\n                strcpy(temp.map,tmap);\n\n                temp.x = _tmp.x;\n\n                temp.y = _tmp.y-1;\n\n                temp.father = tos;\n\n                temp.myDir = left;\n\n                back_push(temp);\n\n            }\n\n        }\n\n\n\n}\neightnum m_tmp = front_pop();\nDFS(m_tmp);\n\n\n\n\n}\n\n\n\nvoid myDisplay(char _map[]){//display\n\n    int ii;\n\n    for(ii=0;ii<9;++ii){\n\n        if(0==ii%3)\n\n            printf(\"\\n\");\n\n        if(_map[ii] == '0')\n\n            printf(\"    \");\n\n        else\n\n            printf(\"%c   \",_map[ii]);\n\n    }\n\n    printf(\"\\n-----------------------------\\n\");\n\n}\n\n\n\nint main()\n\n{\n\n    char input[10] ;//输入\n\n    strcpy(input,\"283164705\");\n\n    strcpy(dest,\"123804765\");\n\n    int i;\n\n    tos =  -1;\n\n    len  = 0;\n\n    strcpy(temp.map,input);\n\n    printf(\"原始状态:\\n\");\n\n    myDisplay(input);\n\n    for(i=0;i=0;--i)\n{\n    if(path[i].dir==0){\n        printf(\"down-->\");\n        myDisplay(num[path[i].t].map);\n    }\n    else if(path[i].dir==1){\n        printf(\"up-->\");\n        myDisplay(num[path[i].t].map);\n    }\n    else if(path[i].dir==2){\n        printf(\"right-->\");\n        myDisplay(num[path[i].t].map);\n    }\n    else if(path[i].dir==3){\n        printf(\"left-->\");\n        myDisplay(num[path[i].t].map);\n    }\n}\nreturn 0;\n\n\n\n\n}[/code]\n\n\n\nps:用“在link option中增加/stack”这种方法可以实现步长到27，我是想知道是否有更好的方法可以优化代码", "Tag": "算法分析"}
