{"Answer": "你可以参考下这个问题的回答, 看看是否对你有帮助, 链接: https://ask.csdn.net/questions/7517842这篇博客你也可以参考下：哈夫曼编码实验报告这篇博客也不错, 你可以看下哈夫曼编码实验报告", "Konwledge_Point": "哈夫曼编码", "Question": "哈夫曼树编码以及译码\n求一个哈夫曼树编码以及译码的小程序，26个字母以及权值已经给出，希望以此建立哈夫曼树。在由键盘输入字符串或者二进制数时可以根据此树进行编码或译码", "Tag": "算法分析"}
{"Answer": "步骤1.构造哈夫曼树，\n2.输入字符个数\n3.输入字符\n4.输入权值\n5.遍历打印输出树\n6.乱序输入字符，输出编码\n7.乱序输入编码，输出对应字符", "Konwledge_Point": "哈夫曼编码", "Question": "一个程序，哈夫曼树的构造遍历打印，编码解码，缺少遍历和打印\n#include \n\n#include     /* 数组头文件 \n/\n\n#include \n\n#define MAX 999    /\n 定义长度 \n/\n\ntypedef struct{     /\n 定义哈夫曼编码的结构数组 \n/\n\n    char data;\n\n    int weight;    /\n 定义权值 \n/\n\n    int parent;\n\n    int lchild;\n\n    int rchild;\n\n}huffmannode;\n\ntypedef struct{      /\n 定义保存哈夫曼结构体 \n/\n\n    char bits[50];\n\n    int start;\n\n}huffmancode ;\n\nvoid main()\n\n{\n\n    huffmannode ht[100];    /\n 定义储存权值的空间 \n/\n\n    huffmancode cd[100];\n\n    char string[100];      /\n 定义数组存储空间 \n/\n\n    char hcd[100];\n\n    int i,j,x,y,s1,s2,m1,m2,n,c,f,k;\n\n    printf(\"please input the n =\");     /\n 输入字符的个数 \n/\n\n    scanf(\"%d\",&n);\n\n    printf(\"\\n============================\\n\");\n\n    for(i=0;i<n;i++)\n\n    {\n\n        getchar();                 /\n 获得输入的字符 \n/\n\n        printf(\"please input the value :\");\n\n        scanf(\"%c\",&ht[i].data);            /\n 输入字符函数 \n/\n\n        printf(\"please input the weight:\\n\");\n\n        scanf(\"%d\",&ht[i].weight);\n\n    }\n\n    printf(\"\\n=============================\\n\");\n\n    for(i=0;i<2*n-1;i++)\n\n    {\n\n        ht[i].parent=ht[i].lchild=ht[i].rchild=-1;  /\n 初始化父结点，左右子结点 \n/\n\n    }\n\n    for (i=n;i<2*n-1;i++)\n\n    {\n\n        s1=s2=0;                        /\n 初始化变量 \n/\n\n        m1=m2=MAX;\n\n        for (j=0;j<i;j++)\n\n     {\n\n            if (ht[j].weight<m1 &&ht[j].parent==-1) /\n 寻找无父结点的最小值 \n/\n\n            {\n\n                m2=m1;\n\n                s2=s1;\n\n                m1=ht[j].weight;\n\n                s1=j;                           /\n 寻找当前最小值 \n/\n\n            }\n\n            else if(ht[j].weight<m2 &&ht[j].parent==-1) /\n 寻找无父结点的次小值 \n/\n\n            {\n\n                m2=ht[j].weight;\n\n                s2=j;\n\n            }                              /\n 寻找次小值 \n/\n\n        }\n\n        ht[s1].parent=i;                 /\n s1的父结点为i \n/\n\n        ht[s2].parent=i;\n\n        ht[i].weight=m1+m2;             /\n 最小值的权值相加为i的权值 \n/\n\n        ht[i].lchild=s1;                /\n i的左子为s1 \n/\n\n        ht[i].rchild=s2;                /\n i的右子为s2 \n/\n\n    }\n\n    for(i=0;i<n;i++)\n\n    {\n\n        cd[i].start=n;\n\n        x=i;\n\n        y=ht[x].parent;                /\n 记录父结点 \n/\n\n        while (y!=-1)\n\n        {\n\n            if (ht[y].lchild==x)\n\n                cd[i].bits[cd[i].start]='0';   /\n 给字符赋0值 \n/\n\n            else\n\n               cd[i].bits[cd[i].start]='1';    /\n 给字符赋1值 \n/\n\n            cd[i].start--;\n\n            x=y;\n\n            y=ht[y].parent;\n\n        }\n\n    }\n\n    printf(\"\\cout the huffmancode:\\n\");\n\n    for (i=0;i<n;i++)\n\n    {\n\n        printf(\"%c:\",ht[i].data);         /\n 输出字符 \n/\n\n        for(j=cd[i].start;j<=n;j++){\n\n            printf(\"%c\",cd[i].bits[j]);    /\n 输出字符的01代码 \n/\n\n        }\n\n         printf(\"\\n\");\n\n    }\n\n    printf(\"\\n=============================\\n\");\n\n    printf(\"\\n Please input the message:\\n\");\n\n    scanf(\"%s\",string);                    /\n 输入字符串 \n/\n\n    for(i=0;string[i]!='0';i++)\n\n    {\n\n        for(c=0;c<=n;c++)\n\n            if(string[i]==ht[c].data)  /\n 寻找与输入字符相匹配的字母 \n/\n\n            {\n\n                for(j=cd[c].start;j<=n;j++)\n\n                    printf(\"%c\",cd[c].bits[j]);   /\n 输出字母代码 \n/\n\n                break;\n\n            }\n\n    }\n\n    printf(\"\\n=============================\\n\");\n\n    printf(\"Please input the HuffmanCode:\\n\");\n\n    scanf(\"%s\",hcd);                  /\n 输入0、1代码 \n/\n\n    f=2*n-2;\n\n    for(i=0;hcd[i]!='\\0';i++)\n\n    {\n\n        if(hcd[i]=='0')               /\n 判断输入为0，寻找左子 \n/\n\n            f=ht[f].lchild;\n\n        else if(hcd[i]=='1')\n\n            f=ht[f].rchild;           /\n 判断输入为1，寻找右子 \n/\n\n        if(f<n)\n\n        { \n\n            printf(\"%c\",ht[f].data);  /\n 输出字符串 */\n\n            f=2*n-2;\n\n        }\n\n    }\n\n    printf(\"\\n\");\n\n    getch();\n\n\n\n}", "Tag": "算法分析"}
{"Answer": "", "Konwledge_Point": "哈夫曼编码", "Question": "哈夫曼树如何画出，以及对应的哈夫曼i编码如何求得\n哈夫曼树如何画出，以及对应的哈夫曼i编码如何求得，求解答，感谢", "Tag": "算法分析"}
{"Answer": "做过一个比较类似的，需要可以给你", "Konwledge_Point": "哈夫曼编码", "Question": "怎样把句号，逗号作为前缀进行编码\n利用哈夫曼编码进行压缩英文短文，还需要包括句号，逗号，利用单词重复进行编码，", "Tag": "算法分析"}
{"Answer": "32行for循环后面的分号删掉", "Konwledge_Point": "哈夫曼编码", "Question": "为什么无论输入什么数，打出来的哈夫曼数都是一样的，而且编码打不出来\n(为什么无论输入什么数，打出来的哈夫曼数都是一样的，而且编码打不出来)\n\n\n#\ninclude\n \n\n \n\n\n#\ninclude\n \n\n \n\n\n#\ninclude\n \n\n \n\n\n#\ndefine\n N 8\n\n\n//#define M 2*N-1\n\n\n//哈夫曼树类型定义 \n\n\ntypedef\n \nstruct\n    \n{ \n    \nunsigned\n \nint\n weight; \n    \nunsigned\n \nint\n parent, lchild, rchild; \n}HTNode,*HuffmanTree;\n\ntypedef\n \nchar\n **HuffmanCode;\nHuffmanTree HT;\nHuffmanCode HC;\n\nchar\n *cd;\n\n//字符、权值、对应编码组成的结构体类型 \n\n\nstruct\n \ns\n\n{  \n    \nchar\n data;  \n    \nint\n weight;  \n    \nchar\n code[N]; \n}; \ns S[N];\n\n//此处函数定义请自行编写 \n\n\nvoid\n \nInit\n(s S[N],\nint\n *w)\n\n\n{\n    \nint\n i;\n    \nprintf\n(\n\"输入%d个字符，及他们的权值:\\n\"\n,N);\n    \nfor\n(i=\n1\n;i<=N;i++)\n    {\n        \nprintf\n(\n\"请输入第%d个字符:\"\n,i);\n        \nscanf\n(\n\"%c\"\n,&S[i\n-1\n].data);\n        \ngetchar\n();\n        \nprintf\n(\n\"请输入该字符的权值：\"\n);\n        \nscanf\n(\n\"%d\"\n,&w[i\n-1\n]);\n        \ngetchar\n();\n    }\n}\n\nvoid\n \nSelect\n(HuffmanTree HT,\nint\n n,\nint\n &s1,\nint\n &s2)\n\n\n{\n    \nint\n minn=\n99999998\n,maxx=\n99999999\n,i=\n1\n; \n    \n    s1=s2=\n0\n; \n    \n    \nfor\n( i=\n1\n; i<=n;i++) \n        \n    { \n        \n        \nif\n(HT[i].parent==\n0\n) \n            \n        { \n            \n            \nif\n(HT[i].weightparent=\n0\n;\n        p->lchild=\n0\n;\n        p->rchild=\n0\n;\n        p->weight=w[i\n-1\n];\n    }  \n/**p={ * w, 0, 0, 0};*/\n   \n//用给定的n个\n\n    \n//权值 ，构造n棵只有一个根结点的二叉树\n\n    \n    \nfor\n (;i<=m;i++,++p){\n        p->weight=\n0\n;\n        p->parent=\n0\n;\n        p->lchild=\n0\n;\n        p->rchild=\n0\n;\n    }\n    \n    \nfor\n(i=n+\n1\n;i<=m;i++);\n    { \n        \n        \nSelect\n(HT,i\n-1\n,s1,s2);\n    \n        HT[s1].parent=i;\n    \n        HT[s2].parent=i;\n        \n        HT[i].lchild=s1;\n        \n        HT[i].rchild=s2;\n    \n        HT[i].weight=HT[s1].weight+HT[s2].weight;\n    }\n    HC=(HuffmanCode)\nmalloc\n((n+\n1\n)*\nsizeof\n(\nchar\n *));\n//分配n个字符编码的头指针向量\n\n    cd=(\nchar\n*)\nmalloc\n(n*\nsizeof\n(\nchar\n));\n//分配求编码的工作空间，用cd指向该空间\n\n    cd[n\n-1\n]=\n'\\0'\n;\n    \nfor\n (i=\n1\n;i<=n;i++)\n    {\n        start=n\n-1\n;\n        \nfor\n(c=i,f=HT[i].parent;f!=\n0\n;c=f,f=HT[f].parent)\n        {\n            \nif\n (HT[f].lchild==c) \n                cd[--start]=\n'0'\n;\n            \nelse\n \n                cd[--start]=\n'1'\n;\n        }\n        HC[i]=(\nchar\n *)\nmalloc\n((n-start)*\nsizeof\n(\nchar\n));\n        \nstrcpy\n(HC[i],&cd[start]);\n        \n// strcpy(S[i].code,&HC[i]);\n\n    }\n    \n/*    for( i=1;i<=N;i++)\n    {\n    S[i].weight=\n    S[i].data=\n    //        strcpy(S[i].code,HC[i]);\n    }\n    */\n\n    \nfree\n(cd);\n}\n\n\nint\n \nmain\n()\n \n\n{  \n//哈夫曼树的建立和编码的生成  \n\n    \n//打印输出哈夫曼树数据 \n\n    \n//用户输入任意一个由N个字符组成的字符串，输出该字符串对应的哈夫曼编码字符串 \n\n    \n//用户输入哈夫曼编码(由01组成)，将进行解码，输出对应的字符串 \n\n    \nint\n a[\n100\n];\n    \nint\n k,*w,n,m=\n2\n*N\n-1\n;\n    w=a;\n    \n//    HTNode HT[M-1];\n\n    \n//    HTCode HC[N+1];\n\n    \nInit\n(S,w);\n    \nHuffmancoding\n(HT,HC,\n8\n,w);\n    \nprintf\n(\n\"\\n哈夫曼树如下所示:\\n\"\n);\n    \nfor\n (\nint\n v=\n1\n;v<=m;v++){\n        \nprintf\n(\n\"%d\\t\"\n,HT[v].weight);\n        \nprintf\n(\n\"%d\\t\"\n,HT[v].parent);\n        \nprintf\n(\n\"%d\\t\"\n,HT[v].lchild);\n        \nprintf\n(\n\"%d\\t\\n\"\n,HT[v].rchild);\n    }\n    \nprintf\n(\n\"\\n%d个字符的字符、权值以及哈夫曼编码如下：\\n\"\n,N);\n    \nfor\n(k=\n1\n;k<=n;k++);\n    {\n        \nprintf\n(\n\"%-3c%-3d%s\\n\"\n,S[k].data,S[k].weight,HC[k]);\n        \n//puts(S[k].code);\n\n        \n//printf(\"%c\\t\",HC[k]);\n\n    }\n    \nreturn\n \n0\n; \n} \n\n", "Tag": "算法分析"}
{"Answer": "\n那么加权路径长度WPL=(9+7+8)×2+4×3+(2+3)×4=80\n（结点到树根之间的路径长度与该结点上权的乘积）\n构造哈夫曼树的办法是：在W中选出两个权小结点，并同时计算出它们的和，如果两个数的和正好是下一步的两个最小数的其中的一个，那么这个树直接往上生长就可以了，如果这两个数的和比较大，不是下一步的两个最小数的其中一个，那么就并列生长。", "Konwledge_Point": "哈夫曼编码", "Question": "哈夫曼树，求解析，数据结构\n35.(填空题， 2.5 分)\n有一份电文中共使用 6个字符:a,b,c,d,e,f,它们的出现频率依次为2,3,4,7,8,9,试构造一棵哈夫曼树,则其加权路径长度WPL为多少，求解析", "Tag": "算法分析"}
{"Answer": "![图片说明](https://img-ask.csdn.net/upload/201905/02/1556800260_830294.jpg)\r\n![图片说明](https://img-ask.csdn.net/upload/201905/02/1556800272_950431.jpg)", "Konwledge_Point": "哈夫曼编码", "Question": "二叉树，哈夫曼问题，求大神指点，多谢。\n1、已知一棵二叉树的前序遍历为：ABCDEFHIKLGJ，中序遍历序列为：CBAFEIHLKDGJ，画出次二叉树的逻辑结构图。\n\n2、已知一段电文仅含8个字符{C1,C2,……,C8}，且每个字符在电文中出现的频率构成权集{13,2,11,20,9,23,17,5}，求各个字符的哈夫曼编码", "Tag": "算法分析"}
{"Answer": "运行结果及代码如下：\n\n#include <iostream>\n#include <algorithm>\n\n#include <iomanip>\nusing namespace std;\n#define MAXLEN 30\n#define MAXLEAF 130\n#define MAXWEIGHT 1\n\n//结点\nstruct HuffmanNode\n{\n    char node;      //结点字符\n    double weight;  //结点权值\n    int parent;     //父结点\n    int lchild;     //左子节点\n    int rchild;     //右子节点\n    int no;         //节点编号\n};\n//每个结点的编码\nstruct HuffmanCode\n{\n    int bit[MAXLEN];  //存储哈夫曼编码\n    int length;        //每个结点编码的长度\n};\nbool cmp1(HuffmanNode a, HuffmanNode b)\n{\n    return a.weight < b.weight;\n}\nbool cmp2(HuffmanNode a, HuffmanNode b)\n{\n    return a.no < b.no;\n}\n\nHuffmanNode HNode[2 * MAXLEAF - 1];\nHuffmanCode HCode[MAXLEAF];\n\n\n\n\n//构造哈夫曼树\nvoid CreateHafman(char buf[], double w[], int n)\n{\n    //初始化结点\n    for (int i = 0; i < 2 * n - 1; i++)\n    {\n        HNode[i].weight = MAXWEIGHT;\n        HNode[i].parent = -1;\n        HNode[i].lchild = -1;\n        HNode[i].rchild = -1;\n        HNode[i].no = 2 * n;\n    }\n\n    for (int i = 0; i < n; i++)\n    {\n        HNode[i].node = buf[i];\n        HNode[i].weight = w[i];\n        HNode[i].no = i;\n    }\n\n\n    for (int i = 0; i < n - 1; i++)\n    {\n        int min1 = 0, min2 = 1;\n        sort(HNode, HNode + n + i, cmp1);\n        for (int j = 0; j < n + i; j++)\n        {\n            if (HNode[min1].parent != -1)\n            {\n                min1++;\n                min2 = min1 + 1;\n                continue;\n            }\n            if (HNode[min2].parent != -1)\n                min2++;\n        }\n        HNode[n + i].lchild = HNode[min1].no;\n        HNode[n + i].rchild = HNode[min2].no;\n        HNode[n + i].weight = HNode[min1].weight + HNode[min2].weight;\n        HNode[n + i].no = n + i;\n        HNode[min1].parent = HNode[n + i].no;\n        HNode[min2].parent = HNode[n + i].no;\n\n    }\n    //cout << \"哈夫曼树构建成功！\" << endl;\n}\n\n//获取每个字符的哈夫曼编码\nvoid Getcode(int n)\n{\n    int offset = 2 * n - 1, p, j;\n    HuffmanCode hc;\n\n    sort(HNode, HNode + offset, cmp2);\n    for (int i = 0; i < n; i++)\n    {\n        hc.length = 0;\n        j = i;\n        p = HNode[j].parent;\n        while (p != -1)\n        {\n            if (HNode[p].lchild == HNode[j].no)\n                hc.bit[hc.length] = 0;\n            else\n                hc.bit[hc.length] = 1;\n            hc.length++;\n            j = HNode[p].no;\n            p = HNode[j].parent;\n        }\n        for (int k = 0; k < hc.length; k++)\n            HCode[i].bit[k] = hc.bit[hc.length - k - 1];\n        HCode[i].length = hc.length;\n    }\n}\n//显示哈夫曼编码\nvoid showHafman(int n)\n{\n    //输出哈夫曼编码\n    for (int i = 0; i < n; i++)\n    {\n        if (HNode[i].node == '\\n')\n            cout << \"\\\\n\" << \": Huffman code is: \";\n        else if (HNode[i].node == '\\r')\n            cout << \"\\\\r\" << \": Huffman code is: \";\n        else if (HNode[i].node == '\\t')\n            cout << \"\\\\t\" << \": Huffman code is: \";\n        else\n            cout << HNode[i].node << \": Huffman code is: \";\n        for (int j = 0; j < HCode[i].length; j++)\n            cout << HCode[i].bit[j];\n        cout << endl;\n    }\n}\n\n\n\nint main()\n{\n    int n = 8;\n    char buf[MAXLEAF]={'a','b','c','d','e','f','g','h'};\n    double w[MAXLEAF]={0.07,0.19,0.02,0.06,0.32,0.03,0.21,0.13};\n\n    \n    CreateHafman(buf, w, n); //创建哈夫曼树\n    Getcode(n);//获取每个字符的编码\n    showHafman(n);\n    return 0;\n}\n\n\n", "Konwledge_Point": "哈夫曼编码", "Question": "利用哈弗曼树编码原理，对字符进行编码（C++,C语言都可）\n题目：输入任意字符串，str]=(\"a”，“b”，“c”，\"d”，\"e”，\"f”，”g”，“h”；每种字符出现频率fnum，=0.07,0.19,0.02,0.06,0.32,0.03,0.21,0.13，根据出现频率，利用哈夫曼编码原理，对每个字符进行(0.1)编码，并输出每种字符编码。", "Tag": "算法分析"}
{"Answer": "\n\n#include<stdio.h>\n#define Maxleaf 30\n#define Maxnode 1000\n#define Max 100000\n#define Maxsize 100\ntypedef struct      //定义结构体\n{\n  char ch;          //定义字符型的结点名\n  float weight;     //定义一个整型权值变量\n  int lchild,rchild,parent;   //定义左、右孩子及双亲指针\n}hufmtree;\ntypedef struct\n{\n  char bits[Maxsize];        //定义一个字符型的数组存储结点的编码\n  int start;                 //标志字符串起点\n  char ch;                   //存储结点的名称\n}codetype;\nvoid huffman(hufmtree tree[],int n)   //哈夫曼树的创建\n{\n  int i,j,p1,p2;\n  float small1,small2,f;\n  char c;\n  int m=2*n-1;           //总的结点数目\n  for(i=0;i<m;i++)        //结点信息的初始化\n  {\n    tree[i].parent=0;\n    tree[i].lchild=-1;\n    tree[i].rchild=-1;\n    tree[i].weight=0.0;\n  }\n  for(i=0;i<n;i++)              //输入叶子结点的结点名和权值\n  {\n    printf(\"第%d个元素的结点:\",i+1);  \n    scanf(\"%c\",&c);\n    getchar();\n    printf(\"输入该节点的权值：\");\n    scanf(\"%f\",&f);\n    getchar();\n    tree[i].ch=c;\n    tree[i].weight=f;\n  }\n  for(i=n;i<m;i++)         //找出剩余结点中的权值最小的两个结点组合\n  {\n    p1=0;p2=0;\n    small1=Max;small2=Max;\n    for(j=0;j<i;j++)             \n    if(tree[j].parent==0)         //如果该结点不存在双亲\n    if(tree[j].weight<small1)        //结点的权值小于small1时\n    {\n      small2=small1;                \n      small1=tree[j].weight;          \n      p2=p1;                       \n      p1=j;\n    }\n    else if(tree[j].weight<small2)         //结点的权值大于small1但是小于small2\n    {\n      small2=tree[j].weight;\n      p2=j;\n    }\n    tree[p1].parent=i;           \n    tree[p2].parent=i;\n    tree[i].lchild=p1;\n    tree[i].rchild=p2;\n    tree[i].weight=tree[p1].weight+tree[p2].weight;\n  }\n}\nvoid huffmancode(codetype code[],hufmtree tree[],int n)   //哈夫曼的编码函数\n{\n  int i,c,p;\n  codetype cd;            //定义一个临时变量\n  for(i=0;i<n;i++)         //从下往上遍历哈夫曼树，进行编码\n  {\n    cd.start=n;            //编码的结束位置\n    cd.ch=tree[i].ch;        //将哈夫曼结构体中的结点名赋给存储编码的结构体中的结构名\n    c=i;                       \n    p=tree[i].parent;         \n    while(p!=0)             //当p是根结点的双亲时跳出循环\n    { \n      cd.start--;           \n      if(tree[p].lchild==c)     //如果是它的左孩子\n         cd.bits[cd.start]='0';     //则输出0\n      else\n         cd.bits[cd.start]='1';     //否则就是右孩子输出1\n      c=p;\n      p=tree[p].parent;\n    }\n    code[i]=cd;                     //将临时变量中的值存入结构体数组\n  }\n}\nvoid decode(hufmtree tree[],int m)     //译码函数\n{\n  int i,j=0,k=0;\n  char b[Maxsize];             \n  char endflag='#';\n  i=m-1;\n  getchar();\n  gets(b);                                                  //读入编码\n  printf(\"输出哈夫曼译码：\\n\");\n  while(b[j]!='#')     \n  {\n    if(b[j]=='0')                                         //如果编码是0\n      i=tree[i].lchild;                                 //将该结点左孩子的序号赋给i\n    else\n    {\n    if(b[j]=='1')\n    \n        i=tree[i].rchild;   //如果编码是1，将该结点右孩子的序号赋给i\n    else\n        printf(\"ERROR\\n\");\n    }\n      if(tree[i].lchild==-1)         //如果该结点左孩子的序号等于-1，即根结点\n      {\n        printf(\"%c\",tree[i].ch);    //输出该结点名\n        i=m-1;                        //回到根结点\n      }\n   j++;\n  }\n  printf(\"\\n\");\n  if(tree[i].parent!=0)    \n    printf(\"\\nERROR\\n\");\n}\nvoid Menu()\n    {\n    printf(\"◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆\\n\");\n    printf(\"*    ********哈夫曼编码/译码器********         *\\n\");\n    printf(\"*             1.创建哈夫曼树;                  *\\n\");\n    printf(\"*             2.进行哈夫曼编码;                *\\n\");\n    printf(\"*             3.进行哈夫曼译码;                *\\n\");\n    printf(\"*             4.退出;                          *\\n\");\n    printf(\"◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆\\n\");\n    }\nint main()\n{\n  int i,j,n,m;\n  int choose;\n  hufmtree tree[Maxnode];       \n  codetype code[Maxleaf];   \n  Menu();    \n  while(1)\n  {\n        printf(\"\\n请输入要进行的功能：\");\n     scanf(\"%d\",&choose);\n     switch(choose)\n     {\n      case 1:\n          printf(\"请输入元素个数：\");\n          scanf(\"%d\",&n);\n          getchar();\n          huffman(tree,n);                                //调用哈夫曼创建函数\n          printf(\"成功建立哈夫曼树！\\n\");\n      break;\n      case 2:\n          printf(\"请输出哈夫曼编码：\\n\");\n          huffmancode(code,tree,n);           //调用哈夫曼编码函数\n          for(i=0;i<n;i++)                           //输出结点对应的哈夫曼编码\n          {\n            printf(\"%c:\",code[i].ch);\n            for(j=code[i].start;j<n;j++)\n              printf(\"%c\",code[i].bits[j]);\n            printf(\"\\n\");\n          }\n      break;\n      case 3:\n          m=2*n-1;\n          printf(\"请输入编码，以#为结束标志：\\n\");\n          decode(tree,m);                             //调用译码函数\n      break;\n      case 4:\n          return 0;\n     }\n  }\nreturn 0;\n}\n", "Konwledge_Point": "哈夫曼编码", "Question": "下面这个到底哪里不对，运行了是c++那c语言咋整呢\n给定权值(A:5，B:29，C:7,D: 8, E:14，F:23，G:3， H：11 建立哈夫曼树，输出哈夫曼编码；对上述给定的哈夫曼树及得到的哈夫曼编码，试输入一串二进制编码，输出它的哈夫曼译码。\n要求：将哈夫曼树的结构定义为一个一维数组，每个元素含有四顶：权值、双亲、左、右。权值由键盘输入；二进制编码时，往左走编码为0，往右走编码为1：译码就是将输入的编码还原成对应的字符。\n\n\n以上好多人用的用的是c++有人给改成c语言嘛，不会呀", "Tag": "算法分析"}
{"Answer": "因为有某次调用selectMin()函数时没有进54行那个分支，导致secminIndex没有初始化就赋值给了res[1]", "Konwledge_Point": "哈夫曼编码", "Question": "C语言哈夫曼树编码及其解码\n问题：\n读取文件并对其中的数据进行哈夫曼树编码和解码\n出现的问题：\n用数据创建哈夫曼树并对哈夫曼树进行先序遍历的时候，出现程序崩溃，崩溃的原因我觉得莫名其妙\n如图：\n\n\n\n\n需求：\n1.解决上述问题，将字符数据翻译为哈夫曼树编码\n2.完成对解码部分的代码\n代码：\n\n\n#define _CRT_SECURE_NO_WARNINGS\n#include \n\"stdio.h\"\n\n#include \n\"stdlib.h\"\n\ntypedef struct TreeNode  \n//定义树结点\n\n{\n    int weight;  \n//权值\n\n    int parent;\n    int lchild;\n    int rchild;\n    char ch;\n}treenode;\n\ntypedef struct HuffmanTree  \n//定义huffmantree，用数组表示树\n\n{\n    treenode* \ndata\n;\n    int length;\n}huffmantree;\n\nhuffmantree* huffmantree_create(int weight[], int length, char character[])\n//huffmantree初始化\n\n{\n    huffmantree* \ntree\n = (huffmantree*)malloc(sizeof(huffmantree));\n    \ntree\n->\ndata\n = (treenode*)malloc(sizeof(treenode) * (\n2\n * length - \n1\n));  \n//n个元素，树中有2n-1个结点\n\n    \ntree\n->\nlength = length;\n    \nfor\n (int i = \n0\n; i < length; i++)\n    {\n        \ntree\n->\ndata\n[i].weight = weight[i];\n        \ntree\n->\ndata\n[i].parent = \n0\n;\n        \ntree\n->\ndata\n[i].lchild = -\n1\n;\n        \ntree\n->\ndata\n[i].rchild = -\n1\n;\n        \ntree\n->\ndata\n[i].ch = character[i];\n    }\n    return \ntree\n;\n}\n\nint* selectMin(huffmantree* \ntree\n)\n//选择最小的两个结点\n\n{\n    int min=\n10000\n, secmin=\n10000\n;\n    int minIndex, secminIndex;\n    \nfor\n (int i = 0; i < \ntree\n->\nlength; i++)  \n//找到最小的结点的索引下标\n\n    {\n        \nif\n (\ntree\n->\ndata\n[i].parent == \n0\n)\n        {\n            \nif\n (\ntree\n->\ndata\n[i].weight < min)\n            {\n                \nmin\n = \ntree\n->\ndata\n[i].weight;\n                minIndex = i;\n            }\n        }\n    }\n    \nfor\n (int i = 0; i < \ntree\n->\nlength; i++)  \n//找到第二小的结点的索引下标\n\n    {\n        \nif\n (\ntree\n->\ndata\n[i].parent == \n0\n && i != minIndex)\n        {\n            \nif\n (\ntree\n->\ndata\n[i].weight < secmin)\n            {\n                \nsecmin\n = \ntree\n->\ndata\n[i].weight;\n                secminIndex = i;\n            }\n        }\n    }\n    int* res = (int*)malloc(sizeof(int) * \n2\n);  \n//返回两个数据，用int数组返回\n\n    res[\n0\n] = minIndex;\n    res[\n1\n] = secminIndex;\n    return res;\n}\n\nvoid createTree(huffmantree* \ntree\n)  \n//建树\n\n{\n    int min;\n    int secmin;\n    int* res;\n    \nfor\n (int i = \ntree\n->\nlength\n; i < \ntree\n->\nlength * \n2\n - \n1\n; i++)\n    {\n        res = selectMin(\ntree\n);\n        printf(\n\"%d %d\\t\"\n, res[\n0\n], res[\n1\n]);\n        min = res[\n0\n];\n        secmin = res[\n1\n];\n        \ntree\n->\ndata\n[i].weight = \ntree\n->\ndata\n[min].weight + \ntree\n->\ndata\n[secmin].weight;\n        \ntree\n->\ndata\n[min].parent = i;  \n//设置双亲结点\n\n        \ntree\n->\ndata\n[secmin].parent = i;\n        \ntree\n->\ndata\n[i].parent = \n0\n;\n        \ntree\n->\ndata\n[i].lchild = min;  \n//设置孩子结点\n\n        \ntree\n->\ndata\n[i].rchild = secmin;\n        \ntree\n->\nlength++;\n    }\n}\n\nvoid preorder(huffmantree* \ntree\n,int index)\n{\n    \nwhile\n (index != -\n1\n)\n    {\n        \nprintf\n(\"%c %d\\n\", \ntree\n->\ndata\n[index].ch, \ntree\n->\ndata\n[index].weight);\n        \npreorder\n(\ntree\n, \ntree\n->\ndata\n[index].lchild);\n        \npreorder\n(\ntree\n, \ntree\n->\ndata\n[index].rchild);\n    }\n}\n\nint main()\n{\n    FILE* fp;\n    char ch, str[\n100\n],character[\n100\n];\n    int length = \n0\n, option, lengthchar = \n0\n, weight[\n100\n];\n    fp = fopen(\n\"test3.txt\"\n, \n\"r+\"\n);\n    \nif\n (fp == NULL)\n    {\n        printf(\n\"打开文件失败\\n\"\n);\n        exit(\n0\n);\n    }\n    printf(\n\"打开文件成功\\n\"\n);\n    ch = fgetc(fp);\n    \nwhile\n (ch != EOF)\n    {\n        str[length] = ch;\n        length++;\n        ch = fgetc(fp);\n    }\n    str[length] = \n'\\0'\n;\n    printf(\n\"该文件的数据为:\"\n);\n    puts(str);\n    printf(\n\"请问你是要对文件进行加密还是进行解密？(输入1为加密，输入2为解密)\"\n);\n    printf(\n\"我选择：\"\n);\n    scanf(\n\"%d\"\n, &option);\n    \nwhile\n (option != \n1\n && option != \n2\n)\n    {\n        printf(\n\"你的输入有误，请重新输入！\\n我选择：\"\n);\n        scanf(\n\"%d\"\n, &option);\n    }\n    \nif\n (option == \n1\n)  \n//对数据进行huffmantree编码\n\n    {\n        int status;\n        huffmantree* hftree;\n        \nfor\n (int i = \n0\n; i < length; i++)  \n//先把str中的每一个字符都单列出来放进数组character\n\n        {\n            status = \n0\n;\n            \nfor\n (int t = \n0\n; t < lengthchar; t++)\n            {\n                \nif\n (str[i] == character[t])\n                {\n                    status = \n1\n;\n                    break;\n                }\n            }\n            \nif\n (status == \n1\n)\n                continue;\n            character[lengthchar] = str[i];\n            lengthchar++;\n        }\n        character[lengthchar] = \n'\\0'\n;\n        printf(\n\"字符数组为:\"\n);\n        puts(character);\n        \nfor\n (int i = \n0\n; i < lengthchar; i++)  \n//将权值数组归0\n\n        {\n            weight[i] = \n0\n;\n        }\n        \nfor\n (int i = \n0\n; i < lengthchar; i++)  \n//设置权值数组\n\n        {\n            \nfor\n (int t = \n0\n; t < length; t++)\n            {\n                \nif\n (str[t] == character[i])  \n//统计每个字符的出现次数\n\n                    weight[i]++;\n            }\n        }\n        printf(\n\"权值数组为:\"\n);\n        \nfor\n (int i = \n0\n; i < lengthchar; i++)\n            printf(\n\"%d \"\n, weight[i]);\n        printf(\n\"\\n\"\n);\n        hftree = huffmantree_create(weight, lengthchar, character);\n        createTree(hftree);\n        \npreorder\n(hftree,hftree->\nlength-\n1\n);\n    }\n    \nif\n (option == \n2\n)\n//对huffmantree编码进行解码\n\n    {\n        \n    }\n    fclose(fp);\n    return \n0\n;\n}\n谢谢！\n\n", "Tag": "算法分析"}
{"Answer": "定义hufmtree（哈夫曼）的结构体，创建一个新的数据类型，名称为hufmtree。", "Konwledge_Point": "哈夫曼编码", "Question": "C语言 哈夫曼编译码器\ntypedef struct\n\n{\n\n char ch;\n\n float weight;\n\n int lchild,rchild,parent;\n\n}hufmtree;\n\n\n\n这段代码是什么作用的？", "Tag": "算法分析"}
{"Answer": "哈夫曼树是一种用于编码和压缩数据的数据结构。它是根据给定的权值创建出的二叉树，其中每个节点的权值表示该节点对应的字符或数据块的出现频率。哈夫曼树的编码是指将每个数据块编码成一个二进制序列，该序列由该数据块在哈夫曼树中路径上的左右分支构成。\n对于哈夫曼树而言，左分支为0或者为1都是可以的。在构建哈夫曼树时，只需要保证编码过程中每个节点的左右分支不重复即可，因此左分支为0或者为1都是正确的。", "Konwledge_Point": "哈夫曼编码", "Question": "数据结构中哈夫值曼树的编码\n问题遇到的现象和发生背景\n\n\n为哈夫曼树设计哈夫曼编码，左分支为0或者为1，都是可以的吗\n\n\n遇到的现象和发生背景，请写出第一个错误信息\n\n\n用代码块功能插入代码，请勿粘贴截图。 不用代码块回答率下降 50%\n\n\n运行结果及详细报错内容\n\n\n我的解答思路和尝试过的方法，不写自己思路的，回答率下降 60%\n\n\n我想要达到的结果，如果你需要快速回答，请尝试 “付费悬赏”", "Tag": "算法分析"}
{"Answer": "\n#include <stdio.h>\n#include <string.h>\n#include <malloc.h>\n#define MaxSize 100\ntypedef char ElemType;\n#define N 50        //叶子结点数\n#define M 2*N-1     //树中结点总数\n\n//哈夫曼树的节点结构类型\ntypedef struct\n{\n    char data;  //结点值\n    double weight;  //权重\n    int parent;     //双亲结点\n    int lchild;     //左孩子结点\n    int rchild;     //右孩子结点\n} HTNode;\n\n//每个节点哈夫曼编码的结构类型\ntypedef struct\n{\n    char cd[N]; //存放哈夫曼码\n    int start;\n} HCode;\n\nvoid CreateHT(HTNode ht[],int n)\n{\n    int i,k,lnode,rnode;\n    double min1,min2;\n    for (i=0; i<2*n-1; i++)         //所有结点的相关域置初值-1\n        ht[i].parent=ht[i].lchild=ht[i].rchild=-1;\n    for (i=n; i<2*n-1; i++)         //构造哈夫曼树\n    {\n        min1=min2=32767;            //lnode和rnode为最小权重的两个结点位置\n        lnode=rnode=-1;\n        for (k=0; k<=i-1; k++)\n            if (ht[k].parent==-1)   //只在尚未构造二叉树的结点中查找\n            {\n                if (ht[k].weight<min1)\n                {\n                    min2=min1;\n                    rnode=lnode;\n                    min1=ht[k].weight;\n                    lnode=k;\n                }\n                else if (ht[k].weight<min2)\n                {\n                    min2=ht[k].weight;\n                    rnode=k;\n                }\n            }\n        ht[i].weight=ht[lnode].weight+ht[rnode].weight;\n        ht[i].lchild=lnode;\n        ht[i].rchild=rnode;\n        ht[lnode].parent=i;\n        ht[rnode].parent=i;\n    }\n}\n\n//实现哈夫曼编码\nvoid CreateHCode(HTNode ht[],HCode hcd[],int n)\n{\n    int i,f,c;\n    HCode hc;\n    for (i=0; i<n; i++) //根据哈夫曼树求哈夫曼编码\n    {\n        hc.start=n;\n        c=i;\n        f=ht[i].parent;\n        while (f!=-1)   //循序直到树根结点\n        {\n            if (ht[f].lchild==c)    //处理左孩子结点\n                hc.cd[hc.start--]='0';\n            else                    //处理右孩子结点\n                hc.cd[hc.start--]='1';\n            c=f;\n            f=ht[f].parent;\n        }\n        hc.start++;     //start指向哈夫曼编码最开始字符\n        hcd[i]=hc;\n    }\n}\n\n//输出哈夫曼编码\nvoid DispHCode(HTNode ht[],HCode hcd[],int n)\n{\n    int i,k;\n    double sum=0,m=0;\n    int j;\n    printf(\"  输出哈夫曼编码:\\n\"); //输出哈夫曼编码\n    for (i=0; i<n; i++)\n    {\n        j=0;\n        printf(\"      %c:\\t\",ht[i].data);\n        for (k=hcd[i].start; k<=n; k++)\n        {\n            printf(\"%c\",hcd[i].cd[k]);\n            j++;\n        }\n        m+=ht[i].weight;\n        sum+=ht[i].weight*j;\n        printf(\"\\n\");\n    }\n    printf(\"\\n  平均长度=%g\\n\",1.0*sum/m);\n}\n\nint main()\n{\n    int n=8,i;      //n表示初始字符串的个数\n    char str[]= {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'};\n    double fnum[]= {0.07,0.19,0.02,0.06,0.32,0.03,0.21,0.1};\n    HTNode ht[M];\n    HCode hcd[N];\n    for (i=0; i<n; i++)\n    {\n        ht[i].data=str[i];\n        ht[i].weight=fnum[i];\n    }\n    printf(\"\\n\");\n    CreateHT(ht,n);\n    CreateHCode(ht,hcd,n);\n    DispHCode(ht,hcd,n);\n    printf(\"\\n\");}\n\n\n", "Konwledge_Point": "哈夫曼编码", "Question": "输入任意字符串，str[]={\"a\",\"b\",\"c\",\"d\",\"e”,\"f\",\"g\",\"h\"}\n输入任意字符串，str[]={\"a\",\"b\",\"c\",\"d\",\"e”,\"f\",\"g\",\"h\"},每种字符出现频率fnum[]={0.070.19,0.02,0.06,0.32,0.03,0.21,0.1},根据出现频率，利用哈夫曼编码原理，对每个字符进行（0.1）编码，并输出每种字符编码。\n注意：写清具体步骤（文字描述）和程序流程图！", "Tag": "算法分析"}
{"Answer": "还有std::bitset", "Konwledge_Point": "哈夫曼编码", "Question": "用C++可以存储2bit的数据么?\n今天用哈夫曼编码做24位bmp图像的压缩，像素里的RGB已经按频率编好了前缀编码。问题是编好了的前缀码有的较短，不需要一个字节来装，只要几个比特就好了。但是最小的数据类型unsigned char也有一个字节，用它来装编码达不到压缩的效果", "Tag": "算法分析"}
{"Answer": "是你结构体数组S的最后一个元素下标越界了\nN = 8; 你这样 s S[N-1]; 是声明结构体数组S的长度只有7个元素，下标是从S[0]到S[6]，没有S[7]，最后一个S[7]的内存空间是不属于S数组的。虽然可以访问S[7]但不安全。因为这个内存空间可能会分配给其它变量，当这个变量的值改变时S[7]也就受到影响。\n改成 s S[N]; 就可以了\n如有帮助，望采纳！谢谢!", "Konwledge_Point": "哈夫曼编码", "Question": "创建动态数组后，另一个数组的最后一个元素值被改变\n在用c语言编写哈夫曼树时，为了存放权值，建立了一个有8个元素的结构体数组S，而后依次将8个结构体的权值成员赋值为1，2，3，4，5，6，7，8\n\n\ns  S[\n7\n];\n    \nprintf\n(\n\"请输入8个字符的权值:\\n\"\n);\n    \nfor\n(\nint\n i=\n1\n;i<=\n7\n;i++){\n        scanf(\n\"%u\"\n,&S[i].weight);\n        \nprintf\n(\n\"%d\\n\"\n,S[i].weight);\n    }\n\n\n\n\n\n\n然后创建一个动态数组HT，此时发现S最后一个结构体元素的权值成员变为了随机值，这是为什么？\n\n\n    HT=(HuffmanTree)\nmalloc\n((m+\n1\n)*\nsizeof\n(HTNode));\n    \nprintf\n(\n\"%u\\n\"\n,S[\n7\n].weight);\n    \nfor\n(\nunsigned\n \nint\n g=\n0\n;g<=\n7\n;g++){\n         \nprintf\n(\n\"%u\\t\"\n,S[g].weight);\n    }\n\n\n\n\n\n\n完整代码如下\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ndefine\n N 8\n\n\n//存储哈夫曼树的静态三叉链表定义\n\n\ntypedef\n \nstruct\n{\n\nunsigned\n \nint\n weight;\n\nunsigned\n \nint\n parent, lchild, rchild;\n}HTNode, *HuffmanTree;\n\ntypedef\n \nchar\n ** HuffmanCode;\n\n//字符、权值、对应编码组成的结构体类型\n\n\nstruct\n \ns\n \n{\n\nchar\n c;\n\nunsigned\n \nint\n weight;\n\nchar\n code[N];\n};\n\n//选择两个权值最小的结点\n\n\nvoid\n \nSelect\n(HuffmanTree &HT,\nunsigned\n \nint\n i,\nint\n *s1,\nint\n *s2)\n{\n    \nunsigned\n \nint\n min1,min2,j;\n    min1=min2=\n9999\n;\n    \nfor\n(j=\n1\n;j<=i;j++){\n        \nif\n(HT[j].parent==\n0\n){\n            \nif\n(HT[j].weightparent=\n0\n;\n        p->lchild=\n0\n;\n        p->rchild=\n0\n;\n        p->weight=S[i\n-1\n].weight;\n    }\n    \nfor\n(;i<=m;i++,++p){\n        p->parent=\n0\n;\n        p->lchild=\n0\n;\n        p->rchild=\n0\n;\n        p->weight=\n0\n;\n    }\n    \nfor\n(i=n+\n1\n;i<=m;++i){\n        \nSelect\n(HT,n,&s1,&s2);\n        HT[s1].parent=i;\n        HT[s2].parent=i;\n        HT[i].lchild=s1;\n        HT[i].rchild=s2;\n        HT[i].weight=HT[s1].weight+HT[s2].weight;\n    }\n    HC=(HuffmanCode)\nmalloc\n((n+\n1\n)*\nsizeof\n(\nchar\n*));\n    \nchar\n *cd=(\nchar\n*)\nmalloc\n(n*\nsizeof\n(\nchar\n));\n    cd[n\n-1\n]=\n'\\0'\n;\n    \nfor\n(i=\n1\n;i<=n;i++){\n        \nint\n start=n\n-1\n;\n        \nprintf\n(\n\"test1\"\n);\n        \nfor\n(c=i,f=HT[i].parent;f!=\n0\n;c=f,f=HT[f].parent){\n            \nif\n(HT[f].lchild==c)cd[--start]=\n'0'\n;\n            \nelse\n cd[--start]=\n'1'\n;}\n        HC[i]=(\nchar\n*)\nmalloc\n((n-start)*\nsizeof\n(\nchar\n));\n        \nstrcpy\n(HC[i],&cd[start]);\n        \nstrcpy\n(S[i].code,&cd[start]);\n    }\n}\n\n//输出哈夫曼树数据\n\n\nvoid\n \nPrintHuffman\n(HuffmanTree HT,\nint\n n,s S[N])\n{\n    \nprintf\n(\n\"哈夫曼树如下所示:\\n\"\n);\n    \nfor\n(\nint\n k=\n1\n;k<=\n2\n*n\n-1\n;k++){\n        \nprintf\n(\n\"%d\\t\"\n,HT[k].weight);\n        \nprintf\n(\n\"%d\\t\"\n,HT[k].parent);\n        \nprintf\n(\n\"%d\\t\"\n,HT[k].lchild);\n        \nprintf\n(\n\"%d\\t\\n\"\n,HT[k].rchild);\n    }\n    \nprintf\n(\n\"8个字符的字符、权值及哈夫曼编码如下:\\n\"\n);\n    \nfor\n(\nint\n l=\n0\n;l<=n;l++){\n         \nprintf\n(\n\"%s\\t%u\\t%s\\t\\n\"\n,S[l].c,S[l]. weight,S[l].code);\n    }\n}\n\nint\n \nmain\n()\n\n\n{\n \n//哈夫曼树的建立和编码的生成\n\n    HuffmanTree HT;\n    HuffmanCode HC;\n    s S[N\n-1\n];\n    \nprintf\n(\n\"请输入8个字符，及它们的权值:\\n\"\n);\n    \nfor\n(\nint\n i=\n1\n;i<=N;i++){\n        \nprintf\n(\n\"请输入第%d个字符:\"\n,i);\n        \nscanf\n(\n\"%s\"\n,&S[i\n-1\n].c);\n        \nprintf\n(\n\"请输入该字符的权值:\"\n);\n        \nscanf\n(\n\"%u\"\n,&S[i\n-1\n].weight);\n        \nprintf\n(\n\"%d\\n\"\n,S[i\n-1\n].weight);\n    }\n    \nHuffman\n(HT,HC,\n8\n,S);\n   \n \n//打印输出哈夫曼树数据\n\n  \n//  PrintHuffman(HT,8,S);\n\n \n//用户输入任意一个由 N 个字符组成的字符串，输出该字符串对应的哈夫曼编码字符串\n\n    \nprintf\n(\n\"请输入一个字符串,该字符串只能包含8个字符(ABCDEFGH):\"\n);\n    \n    \nprintf\n(\n\"\\n该字符串对应的哈夫曼编码为:\"\n);\n\n\n\n//用户输入哈夫曼编码(由 01 组成)，将进行解码，输出对应的字符串\n\n    \nprintf\n(\n\"请输入一个由0或1构成的哈夫曼编码:\"\n);\n    \nprintf\n(\n\"\\n该哈夫曼编码对应的字符串为\"\n);\n    \nsystem\n(\n\"PAUSE\"\n);\n \nreturn\n \n0\n;\n}\n\n", "Tag": "算法分析"}
{"Answer": "scanf(\"%s\",&S[i-1].c);改为scanf(\"%c\",&S[i-1].c);", "Konwledge_Point": "哈夫曼编码", "Question": "无法打印结构体数组里的数据\n在练习用c语言实现哈夫曼树时，建立了一个结构体数组原来存放字符及其相应的权值和编码\n\n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ndefine\n N 8\n\n\n//存储哈夫曼树的静态三叉链表定义\n\n\ntypedef\n \nstruct\n{\n\nunsigned\n \nint\n weight;\n\nunsigned\n \nint\n parent, lchild, rchild;\n}HTNode, *HuffmanTree;\n\ntypedef\n \nchar\n ** HuffmanCode;\n\n//字符、权值、对应编码组成的结构体类型\n\n\nstruct\n \ns\n \n{\n\nchar\n c;\n\nunsigned\n \nint\n weight;\n\nchar\n code[N];\n};\n\n//选择两个权值最小的结点\n\n\nvoid\n \nSelect\n(HuffmanTree &HT,\nunsigned\n \nint\n i,\nunsigned\n \nint\n *s1,\nunsigned\n \nint\n *s2)\n{\n    \nunsigned\n \nint\n min1,min2,j;\n    min1=min2=\n9999\n;\n    \nfor\n(j=\n1\n;j<=i;j++){\n        \nif\n(HT[j].weightparent=\n0\n;\n        p->lchild=\n0\n;\n        p->rchild=\n0\n;\n        p->weight=S[i\n-1\n].weight;\n    }\n\n/*    for(unsigned int v=1;v<=2*n-1;v++){\n        printf(\"%d\\t\",HT[v].weight);\n        printf(\"%d\\t\",HT[v].parent);\n        printf(\"%d\\t\",HT[v].lchild);\n        printf(\"%d\\t\\n\",HT[v].rchild);\n    }\n    printf(\"****************************************************\\n\");*/\n\n    \nfor\n(;i<=m;i++,++p){\n        p->parent=\n0\n;\n        p->lchild=\n0\n;\n        p->rchild=\n0\n;\n        p->weight=\n0\n;\n    }\n    \n/*for(unsigned int o=1;o<=2*n-1;o++){\n        printf(\"%d\\t\",HT[o].weight);\n        printf(\"%d\\t\",HT[o].parent);\n        printf(\"%d\\t\",HT[o].lchild);\n        printf(\"%d\\t\\n\",HT[o].rchild);\n    }\n    printf(\"*************************************************************************\\n\");*/\n\n        \nfor\n(i=n+\n1\n;i<=m;++i){\n        \nSelect\n(HT,i\n-1\n,&s1,&s2);\n        HT[s1].parent=i;\n        HT[s2].parent=i;\n        HT[i].lchild=s1;\n        HT[i].rchild=s2;\n        HT[i].weight=HT[s1].weight+HT[s2].weight;\n    }\n\n/*    for(unsigned int k=1;k<=2*n-1;k++){\n        printf(\"%d\\t\",HT[k].weight);\n        printf(\"%d\\t\",HT[k].parent);\n        printf(\"%d\\t\",HT[k].lchild);\n        printf(\"%d\\t\\n\",HT[k].rchild);\n    }*/\n\n    HC=(HuffmanCode)\nmalloc\n((n+\n1\n)*\nsizeof\n(\nchar\n*));\n    \nchar\n *cd=(\nchar\n*)\nmalloc\n(n*\nsizeof\n(\nchar\n));\n    cd[n\n-1\n]=\n'\\0'\n;\n    \nfor\n(i=\n1\n;i<=n;i++){\n        \nint\n start=n\n-1\n;\n        \nfor\n(c=i,f=HT[i].parent;f!=\n0\n;c=f,f=HT[f].parent){\n            \nif\n(HT[f].lchild==c)cd[--start]=\n'0'\n;\n            \nelse\n cd[--start]=\n'1'\n;}\n        HC[i]=(\nchar\n*)\nmalloc\n((n-start)*\nsizeof\n(\nchar\n));\n\n//        strcpy(HC[i],&cd[start]);\n\n        \nstrcpy\n(S[i].code,&cd[start]);\n    }\n    \nfree\n(cd);\n}\n\n//输出哈夫曼树数据\n\n\nvoid\n \nPrintHuffman\n(HuffmanTree HT,\nint\n n,s S[N])\n{\n    \nprintf\n(\n\"哈夫曼树如下所示:\\n\"\n);\n    \nfor\n(\nint\n k=\n1\n;k<=\n2\n*n\n-1\n;k++){\n        \nprintf\n(\n\"%d\\t\"\n,HT[k].weight);\n        \nprintf\n(\n\"%d\\t\"\n,HT[k].parent);\n        \nprintf\n(\n\"%d\\t\"\n,HT[k].lchild);\n        \nprintf\n(\n\"%d\\t\\n\"\n,HT[k].rchild);\n    }\n    \nprintf\n(\n\"8个字符的字符、权值及哈夫曼编码如下:\\n\"\n);\n    \nfor\n(\nint\n l=\n0\n;l<=n;l++){\n    \nprintf\n(\n\"%s\\t%u\\t%s\\t\\n\"\n,S[l].c,S[l].weight,S[l].code);\n    }\n}\n\nint\n \nmain\n()\n\n\n{\n \n//哈夫曼树的建立和编码的生成\n\n    HuffmanTree HT;\n    HuffmanCode HC;\n    s S[N];\n    \nprintf\n(\n\"请输入8个字符，及它们的权值:\\n\"\n);\n    \nfor\n(\nint\n i=\n1\n;i<=N;i++){\n        \nprintf\n(\n\"请输入第%d个字符:\"\n,i);\n        \nscanf\n(\n\"%s\"\n,&S[i\n-1\n].c);\n        \nprintf\n(\n\"请输入该字符的权值:\"\n);\n        \nscanf\n(\n\"%u\"\n,&S[i\n-1\n].weight);\n    \n//    printf(\"%d\\n\",S[i-1].weight);\n\n    }\n    \nHuffman\n(HT,HC,\n8\n,S);\n   \n \n//打印输出哈夫曼树数据\n\n    \nPrintHuffman\n(HT,\n8\n,S);\n \n//用户输入任意一个由 N 个字符组成的字符串，输出该字符串对应的哈夫曼编码字符串\n\n    \nprintf\n(\n\"请输入一个字符串,该字符串只能包含8个字符(ABCDEFGH):\"\n);\n    \n    \nprintf\n(\n\"\\n该字符串对应的哈夫曼编码为:\"\n);\n\n\n\n//用户输入哈夫曼编码(由 01 组成)，将进行解码，输出对应的字符串\n\n    \nprintf\n(\n\"请输入一个由0或1构成的哈夫曼编码:\"\n);\n    \nprintf\n(\n\"\\n该哈夫曼编码对应的字符串为\"\n);\n    \nsystem\n(\n\"PAUSE\"\n);\n \nreturn\n \n0\n;\n}\n\n\n\n但是打印输出的时候没有打印结构体数组里的数据，为什么？\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "http://www.cnblogs.com/yym2013/p/3554471.html", "Konwledge_Point": "哈夫曼编码", "Question": "Safe Or Unsafe                \nProblem Description\n\nJavac++ 一天在看计算机的书籍的时候，看到了一个有趣的东西！每一串字符都可以被编码成一些数字来储存信息，但是不同的编码方式得到的储存空间是不一样的！并且当储存空间大于一定的值的时候是不安全的！所以Javac++ 就想是否有一种方式是可以得到字符编码最小的空间值！显然这是可以的，因为书上有这一块内容--哈夫曼编码(Huffman Coding)；一个字母的权值等于该字母在字符串中出现的频率。所以Javac++ 想让你帮忙，给你安全数值和一串字符串，并让你判断这个字符串是否是安全的？\n\n\n\nInput\n\n输入有多组case，首先是一个数字n表示有n组数据，然后每一组数据是有一个数值m(integer)，和一串字符串没有空格只有包含小写字母组成！\n\n\n\nOutput\n\n如果字符串的编码值小于等于给定的值则输出yes，否则输出no。\n\n\n\nSample Input\n\n2\n\n12\n\nhelloworld\n\n66\n\nithinkyoucandoit\n\n\n\nSample Output\n\nno\n\nyes", "Tag": "算法分析"}
{"Answer": "在哈夫曼树中，给定任意一个叶子节点，它对应的编码是由根节点到该叶子节点的路径上的 0 和 1 组成的，所以说，在进行哈夫曼编码时，路径为零的叶子节点的编码可以被定义为比路径为 1 的叶子节点的编码小，也可以被定义为比路径为 1 的叶子节点的编码大，具体的定义可以看情况，只需要保证编码的唯一性和无歧义性就行了，", "Konwledge_Point": "哈夫曼编码", "Question": "请问哈夫曼树的零一编码是否需要路径为零的数比路径为1的叶子结点的值小或者大。\n请问哈夫曼树的零一编码是否需要路径为零的数比路径为1的叶子结点的值小或者大？还是任意的呀，自己编码的话，", "Tag": "算法分析"}
{"Answer": "简单记法，左0右1", "Konwledge_Point": "哈夫曼编码", "Question": "请问大家这个huffman树编码的0和1是怎么判断的呀\n", "Tag": "算法分析"}
{"Answer": "typedef struct BinNode{};这样是声明一个类，你的声明是一个没有类名的一个结构体对象BinNode", "Konwledge_Point": "哈夫曼编码", "Question": "请教一下，vs2017 为什么我的c++代码定义的没有问题，也没有错误提示，但是一编译就爆出很奇怪的错误\n\n\n\n\n\n\n\n\n\n\n\n\n以下是完整代码\n\n\n\n#include \"pch.h\"\n#include\nusing namespace std;\n\ntypedef struct {\n    int weight;\n    BTreeNode *left;\n    BTreeNode *right;\n}BTreeNode;\n\nBTreeNode* CreateHuffman(int a[], int n)\n{\n    // 根据数组a中n个权值建立一颗哈夫曼树，则返回树根指针\n    BTreeNode **b, *q;\n    // 动态地分配一个由b指向的指针数组\n    b = new BTreeNode*[n];\n    int i, j;\n\n    // 初始化b指针数组，使每个指针元素指向a数组中对应元素的结点\n    for (i = 0; i < n; i++) {\n        b[i] = new BTreeNode;\n        b[i]->weight = a[i]; b[i]->left = b[i]->right = NULL;\n    }\n\n    // 进行n-1此循环建立哈夫曼树\n    for (i = 1; i < n; i++) {\n        // 用k1表示森林中具有最小权值的树根节点下标\n        // 用k2表示森林中具有次小权值的树根节点下标\n        int k1=-1, k2;\n        for (j = 0; j < n; j++) {\n            if (b[j] != NULL && k1 == -1) {\n                k1 = j; continue;\n            }\n            if (b[j] != NULL) {\n                k2 = j; break;\n            }\n        }\n\n        // 从当前森林中求出最小权值树和次小权值树\n        for (j = k2; j < n; j++) {\n            if (b[j] != NULL) {\n                if (b[j]->weight < b[k1]->weight) {\n                    k2 = k1; k1 = j;\n                }\n                else if (b[j]->weight < b[k2]->weight)\n                    k2 = j;\n            }\n        }\n\n        // 由最小权值树和次小权值树建立一棵新树，q指向树跟结点\n        q = new BTreeNode;\n        q->weight = b[k1]->weight + b[k2]->weight;\n        q->left = b[k1]; q->right = b[k2];\n        // 将指向新树的指针赋给b指针数组k1位置，k2位置置为空\n        b[k1] = q; b[k2] = NULL;\n    }\n\n    // 删除动态建立的数组b\n    delete []b;\n    // 返回整个哈夫曼树的树根指针\n    return q;\n}\n\nvoid HuffManCoding(BTreeNode *FBT, int len)\n{\n    // 根据FBT指针所指向的哈夫曼树输出每个叶子的编码，len初值为0\n    static int code[10];    // 数组的长度要至少等于哈夫曼树的深度减1\n    if (FBT != NULL) {\n        // 访问到叶子结点时输出其保存在数组code中的0和1序列编码\n        if (FBT->left == NULL && FBT->right == NULL) {\n            cout << \"结点权值为\" << FBT->weight << \"的编码：\";\n            for (int i = 0; i < len; i++)\n                cout << code[i] << \" \";\n            cout << endl;\n        }\n\n        // 访问到非叶子节点时分别向左、右子树递归调用，并分别把分支上\n        // 的0、1编码保存到数组code，向下深入一层时len+1\n        else {\n            code[len] = 0; HuffManCoding(FBT->left, len + 1);\n            code[len] = 1; HuffManCoding(FBT->right, len + 1);\n        }\n    }\n}\n\nvoid CleanBTree(BTreeNode *BT)\n{\n    if (BT != NULL) {\n        CleanBTree(BT->left);\n        CleanBTree(BT->right);\n        delete BT;\n        BT = NULL;\n    }\n}\n\nint main()\n{\n    int n, i;\n    BTreeNode *fbt = NULL;\n    // 输入哈夫曼树中叶子结点数\n    cout << \"输入待构造的哈夫曼树中带权叶子结点的权值n：\";\n    cin >> n;\n    // 用数组a保存从键盘输入的n个叶子结点的权值\n    int *a = new int[n];\n    cout << \"输入\" << n << \"个整数作为权值：\";\n    for (i = 0; i < n; i++) cin >> a[i];\n    // 根据数组a建立哈夫曼树\n    fbt = CreateHuffman(a, n);\n    // 输出哈夫曼编码，即每个叶子节点所对应的0、1序列\n    cout << \"树种每个叶子的哈夫曼编码：\" << endl;\n    HuffManCoding(fbt, 0);\n    CleanBTree(fbt);\n}\n", "Tag": "算法分析"}
{"Answer": "可以看下数据结构参考手册中的 c语言-fscanf()", "Konwledge_Point": "哈夫曼编码", "Question": "通过fscanf扫描文本存到动态数组\n我想要通过fscanf扫描weightdata.txt中的字母和数字，分别存入到data和weight中，并打印，第一次运行成功，再尝试就开始报错，并且每次运行结果都不同。\n\n\n多次运行结果如下：\n\n\n代码如下：\n\n\n#\ndefine\n _CRT_SECURE_NO_WARNINGS\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\ntypedef\n \nstruct\n\n{\n    \nchar\n data;\n    \nint\n weight;\n    \nint\n parent, lchild, rchild;\n}HTNode, * HuffmanTree;\n//动态分配数组存储哈夫曼树\n\n\ntypedef\n \nchar\n** HuffmanCode;\n//动态分配数组存储哈夫曼编码表\n\n\nvoid\n \nload_weightdata_file\n(HTNode* hnode)\n\n\n{\n    FILE* fp;\n    \nint\n i = \n0\n;\n    fp = \nfopen\n(\n\"D://数据结构//课程实验//weightdata.txt\"\n, \n\"r\"\n);\n    \nif\n (fp == \nNULL\n)\n    {\n        cout << \n\"打开文件失败\"\n << endl;\n        \nexit\n(OVERFLOW);\n    }\n    \nwhile\n (!\nfeof\n(fp))\n    {\n        \nfscanf\n(fp, \n\"%c\"\n, &((hnode+i)->data));\n        \nfscanf\n(fp, \n\"%d\"\n, &((hnode+i)->weight));\n        \nfseek\n(fp,\n2\n, SEEK_CUR);\n        cout << (hnode+i)->data << \n\" \"\n;\n        cout << (hnode+i)->weight << endl;\n        i++;\n        \nif\n (i == \n26\n)\n            \nbreak\n;\n    }\n    \nfclose\n(fp);\n    fp = \nNULL\n;\n}\n\nint\n \nmain\n()\n\n\n{\n    HTNode* HT;\n    HT = (HTNode*)\nmalloc\n(\nsizeof\n(HTNode));\n    \nload_weightdata_file\n(HT);\n    \nreturn\n \n0\n;\n}\n\n\n\n\n调试报错如下：\n\n\n\n\n我查询资料也不知如何解决这种情况", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/qq_29503203/article/details/53034955", "Konwledge_Point": "哈夫曼编码", "Question": "关于HUFFMAN利用数组压缩的算法问题\n整体代码如下，具体关于问题在最下方，\n\nstruct head\n\n{\n\n unsigned char b;             /*the charactor*/\n\n long count;                  /*the frequency*/\n\n long parent,lch,rch;         /*make a tree*/\n\n char bits[256];              /*the haffuman code*/\n\n}\n\nheader[512],tmp;\n\n\n\nvoid compress()\n\n{\n\n\n\nclock_t start,end; \n\n char filename[255],outputfile[255],buf[512];\n\n int fn = 0, sz = 0, sz1 = 0;\n\n double x = 0;\n\n unsigned char c;\n\n long i,j,m,n,f;\n\n long min1,pt1,flength;\n\n FILE \nifp,*ofp;\n\n printf(\"源文件名:\");\n\n gets_s(filename);\n\n ifp=fopen(filename,\"rb\");\n\n if(ifp==NULL)\n\n {\n\n  printf(\"源文件打开失败!\\n\");\n\n  return;\n\n }\n\n fn = _fileno(ifp); /\n取得文件指针的底层流式文件号*/\n\n sz = _filelength(fn);/*根据文件号取得文件大小*/\n\n printf(\"文件大小为:%d B.\\n\", sz);\n\n sz1 = sz;\n\n printf(\"压缩后文件名:\");\n\n gets_s(outputfile);\n\n  start=clock(); /* 计时开始 */ \n\n ofp=fopen(outputfile,\"wb\");\n\n if(ofp==NULL)\n\n {\n\n  printf(\"压缩文件打开失败!\\n\");\n\n  return;\n\n }\n\n flength=0;\n\n\n\nwhile(!feof(ifp))\n\n {\n\n  fread(&c,1,1,ifp);//读数据\n\n  header[c].count++; //字符重复出现频率+1\n\n  flength++;  //字符出现原文件长度+1\n\n }\n\n flength--;\n\n header[c].count--;//减一平衡位数\n\n for(i=0;i\n {\n\n  if(header[i].count!=0) \n\n      header[i].b=(unsigned char)i;\n\n  /*将每个哈夫曼码值及其对应的ASCII码存放在一维数组header[i]中，\n\n  且编码表中的下标和ASCII码满足顺序存放关系*/\n\n  else header[i].b=0;\n\n  header[i].parent=-1; //对结点进行初始化\n\n  header[i].lch=header[i].rch=-1;\n\n }\n\n for(i=0;i\n {\n\n  for(j=i+1;j\n  {\n\n   if(header[i].count \n   {\n\n    tmp=header[i];\n\n    header[i]=header[j];\n\n    header[j]=tmp;\n\n   }\n\n  }\n\n }\n\n for(i=0;i\n n=i;\n\n m=2*n-1; //外部叶子结点数为n个时，内部结点数为n-1，整个哈夫曼树的需要的结点数为2*n-1.\n\n for(i=n;i\n {\n\n  min1=999999999;\n\n  for(j=0;j\n\n  {\n\n   if(header[j].parent!=-1) continue;//parent!=-1说明该结点已存在哈夫曼树中，跳出循环重新选择新结点*/\n\n   if(min1>header[j].count)\n\n   {\n\n    pt1=j;\n\n    min1=header[j].count;//找到最小值\n\n    continue;\n\n   }\n\n  }\n\n  header[i].count=header[pt1].count;\n\n  header[pt1].parent=i; //依据parent域值（结点层数）确定树中结点之间的关系\n\n  header[i].lch=pt1;//计算左分支权值大小\n\n  min1=999999999;\n\n  for(j=0;j\n\n  {\n\n   if(header[j].parent!=-1) continue;\n\n   if(min1>header[j].count)\n\n   {\n\n    pt1=j;\n\n    min1=header[j].count;\n\n    continue;\n\n   }\n\n  }\n\n  header[i].count+=header[pt1].count;\n\n  header[i].rch=pt1;//计算右分支权值大小\n\n  header[pt1].parent=i;\n\n }\n\n for(i=0;i\n {\n\n  f=i;\n\n  header[i].bits[0]=0;//根结点编码0   \n\n  while(header[f].parent!=-1)\n\n  {\n\n   j=f;\n\n   f=header[f].parent;\n\n   if(header[f].lch==j) //置左分支编码0\n\n   {\n\n    j=strlen(header[i].bits);//扫描长度\n\n    memmove(header[i].bits+1,header[i].bits,j+1);//由header复制j+ 1个到前者\n\n                                                 //依次存储连接“0”“1”编码\n\n    header[i].bits[0]='0';\n\n   }\n\n   else//置右分支编码1\n\n   {\n\n    j=strlen(header[i].bits);//计算字符长度？\n\n    memmove(header[i].bits+1,header[i].bits,j+1);\n\n    header[i].bits[0]='1';\n\n   }\n\n  }\n\n }\n\n fseek(ifp,0,SEEK_SET);//从文件开始位置向前移动0字节，即定位到文件开始位置\n\n fwrite(&flength,sizeof(int),1,ofp);/*用来将数据写入文件流中，参数flength指向欲写入的数据地址，\n\n总共写入的字符数以参数size*int来决定，返回实际写入的int数目1*/ \n\n fseek(ofp,8,SEEK_SET);\n\n buf[0]=0; //定义缓冲区,它的二进制表示00000000\n\n f=0;\n\n pt1=8;\n\n /*假设原文件第一个字符是\"A\"，8位2进制为01000001，编码后为0110识别编码第一个'0'，\n\n 那么我们就可以将其左移一位，看起来没什么变化。下一个是'1'，应该|1，结果00000001\n\n 同理4位都做完，应该是00000110，由于字节中的8位并没有全部用完，我们应该继续读下一个字符，\n\n 根据编码表继续拼完剩下的4位，如果字符的编码不足4位，还要继续读一个字符，\n\n 如果字符编码超过4位，那么我们将把剩下的位信息拼接到一个新的字节里*/\n\n while(!feof(ifp))\n\n {\n\n  c=fgetc(ifp);\n\n  f++;\n\n  for(i=0;i\n  {\n\n   if(c==header[i].b) break;\n\n  }\n\n  strcat(buf,header[i].bits);\n\n  j=strlen(buf);\n\n  c=0;\n\n  while(j>=8) //对哈夫曼编码位操作进行压缩存储\n\n  {\n\n   for(i=0;i\n   {\n\n    if(buf[i]=='1') c=(c\n    else c=c\n   }\n\n   fwrite(&c,1,1,ofp);\n\n   pt1++; //统计压缩后文件的长度\n\n   strcpy(buf,buf+8);//一个字节一个字节拼接\n\n   j=strlen(buf);\n\n  }\n\n  if(f==flength) break;\n\n }\n\n if(j>0) //对哈夫曼编码位操作进行压缩存储\n\n {\n\n  strcat(buf,\"00000000\");\n\n  for(i=0;i<8;i++)\n\n  {\n\n   if(buf[i]=='1') c=(c<<1)|1;\n\n   else c=c<<1;\n\n  }\n\n  fwrite(&c,1,1,ofp);\n\n  pt1++;\n\n }\n\n fseek(ofp,4,SEEK_SET);\n\n fwrite(&pt1,sizeof(long),1,ofp);\n\n fseek(ofp,pt1,SEEK_SET);\n\n fwrite(&n,sizeof(long),1,ofp);\n\n for(i=0;i<n;i++)\n\n {\n\n  fwrite(&(header[i].b),1,1,ofp);\n\n  c=strlen(header[i].bits);\n\n  fwrite(&c,1,1,ofp);\n\n  j=strlen(header[i].bits);\n\n  if(j%8!=0) //若存储的位数不是8的倍数，则补0\n\n  {\n\n   for(f=j%8;f<8;f++)\n\n   strcat(header[i].bits,\"0\");\n\n  }\n\n  while(header[i].bits[0]!=0)\n\n  {\n\n   c=0;\n\n   for(j=0;j<8;j++) //字符的有效存储不超过8位，则对有效位数左移实现两字符编码的连接\n\n   {\n\n    if(header[i].bits[j]=='1') c=(c<<1)|1; //|1不改变原位置上的“0”“1”值\n\n    else c=c<<1;\n\n   }\n\n   strcpy(header[i].bits,header[i].bits+8);// 把字符的编码按原先存储顺序连接\n\n   fwrite(&c,1,1,ofp);\n\n  }\n\n }\n\n fclose(ifp);\n \n\n\n\nprintf(\"压缩成功!\\n\");\n\n end=clock(); /* 计时结束 \n/\n\n fn = _fileno(ofp); /\n取得文件指针的底层流式文件号*/\n\n sz = _filelength(fn);/*根据文件号取得文件大小*/\n\n printf(\"压缩后文件大小为:%d B.\\n\", sz);\n\n x = (sz / sz1)*1.0;\n\n printf(\"压缩率为:%d B.\\n\", x);\n\n fclose(ofp); \n\nprintf(\"压缩用时%f秒\\n\",(double)(end - start) / CLOCKS_PER_SEC);\n\n return;\n\n}\n\n\n\n//\n\n整体代码如上，请问下  关于找到最小值以后\n\n\n\nheader[i].count=header[pt1].count;\n\n  header[pt1].parent=i; //依据parent域值（结点层数）确定树中结点之间的关系\n\n  header[i].lch=pt1;//计算左分支权值大小\n\n    哈夫曼生成的节点权重不应该两者之和么，这个对于双亲的赋值不是很懂，这种利用数组进行排序以后的这个操作不是很明白，这个i好像是顺序，但不是累加，怎么剔除以后去和剩下的节点比较啊。原来搞不明白这里怎么赋值的", "Tag": "算法分析"}
{"Answer": "1、第一步：将字符全部按照频率按升序排序；2、b和e是最小的两个节点，两者连接到同一个节点上，该节点权值为0.04+0.06=0.1;3、最小的两个节点权值为0.1和0.17，将两个节点合并到一个节点上，频率为：0.1+0.17=0.27；4、重复以上步骤，哈弗曼树构造完成。关于WPL：f、a、c在第二层，d在第三层，b和e在第四层，所以WPS=（0.18+0.23+0.32）2+0.173+（0.04+0.06）*4=2.37。", "Konwledge_Point": "哈夫曼编码", "Question": "数据结构c语言哈夫曼树\n有一份电文中共使用 6个字符:a,b,c,d,e,f,它们的出现频率依次为0.23  0.04  0.32  0.17  0.06  0.18  试构造一棵哈夫曼树，求其加权路径长度WPL及各字符的编码。", "Tag": "算法分析"}
{"Answer": "你的方法定义是不是不对？调用方法之后node里面的内容有带回到主函数吗？可以断点看下返回之后node的内容。", "Konwledge_Point": "哈夫曼编码", "Question": "当输入3个字母以上，执行到if (node[p].lchild == c) 无法读取内存\n#include\n\n#include\n\n#include\n\n\n\n#define MAXBIT      100\n\n#define MAXVALUE  10000\n\n#define MAXLEAF     30\n\n#define MAXNODE    MAXLEAF*2 -1\n\n\n\nusing namespace std;\n\n\n\ntypedef struct{\n\n    int bit[100];\n\n    int start;\n\n}Code;\n\ntypedef struct node{\n\n    char data;\n\n    int weight;\n\n    int parent;\n\n    int lchild;\n\n    int rchild;\n\n    bool tag;\n\n}Node;\n\n\n\nint HuffmanTree(Node node[MAXNODE], int a[128])\n\n{\n\n    int i, j, m1, m2, x1, x2;\n\n    int n = 0;\n\n    for (i = 0; i < 128; i++)\n\n    {\n\n        if (a[i])\n\n        {\n\n            node[n].weight = a[i];\n\n            node[n].parent = -1;\n\n            node[n].lchild = -1;\n\n            node[n].rchild = -1;\n\n            node[n].data = (char)i;\n\n            n++;\n\n        }\n\n    }\n\n    for (i = n ; i < 2*n; i++)\n\n    {\n\n        node[n].weight = 0;\n\n        node[n].parent = -1;\n\n        node[n].lchild = -1;\n\n        node[n].rchild = -1;\n\n    }\n\n    /*循环构建霍夫曼树*/\n\n    for (i = 0; i > s;\n\n    for (i = 0; s[i]; i++)\n\n        a[s[i]]++;\n\n    for (j = 0; j < 128; j++)\n\n    {\n\n        if (a[j])\n\n        {\n\n            cout << (char)j << \":\" << a[j] << endl;\n\n        }\n\n    }\n\n    n=HuffmanTree(node, a);\n\n    cout << n;\n\n    for (i = 0; i < n; i++)\n\n    {\n\n        cd.start = n-1;\n\n        c = i;\n\n        p = node[c].parent;\n\n        while (p != -1)\n\n        {\n\n\n\n        if (node[p].lchild == c)\n            cd.bit[cd.start] = 0;\n        else\n        {\n            cd.bit[cd.start] = 1;\n        }\n        cd.start--;\n        c = p;\n        p = node[c].parent;\n    }//end while\n    for (j = cd.start + 1; j < n; j++)\n    {\n        code[i].bit[j] = cd.bit[j];\n    }\n    code[i].start = cd.start;\n}//end for\n/* 输出已保存好的所有存在编码的哈夫曼编码 */\ncout << \"编码：\" << endl;\n        for (i = 0; i < n; i++)\n        {\n            cout << node[i].data<< \" :\";\n            for (j = code[i].start + 1; j < n; j++)\n            {\n                cout << code[i].bit[j];\n            }\n        cout << endl;\n        }\nsystem(\"pause\");\n\n\n\n\n}", "Tag": "算法分析"}
{"Answer": "这个题目你只需要知道哈夫曼树就可以了\r\n首先将字符与加权一一对应，并将他们按权值大小排序：\r\nd 0.12 c 0.14 b 0.17 e 0.18 f 0.19 a 0.2\r\n哈夫曼树构造方法：\r\n假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为：\r\n(1) 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)；\r\n(2) 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；\r\n(3)从森林中删除选取的两棵树，并将新树加入森林；\r\n(4)重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。\r\n----来源百度百科\r\n（1）先挑选最小的两个节点，此处为dc，作为一棵树的左右叶子，用他们的和作为根节点，就够造成了一棵树。\r\n（2）以新产生的树为左子树，在未加入树中的节点在选择一个最小权值的节点，作为右叶子，构造一棵树。\r\n（3）重复（2），直至结束。\r\n然后根据左零右一得规则进行编码，即任意一个根节点，指向左孩子的树枝（姑且叫树枝）标注零，同理指向右孩子的标注一。如图\r\n\r\n![图片说明](https://img-ask.csdn.net/upload/201911/10/1573383456_900144.jpg)\r\n\r\n确定编码：从根节点出发，到指定节点N所走过路径上的编码顺排，就构成了这个节点的编码，如a可以编码1指代。\r\n每个节点的编码图片中已经给出。\r\n求加权路径长度：题目中给出了每个节点的权值，可记为Wi（第i个节点的权重）你需要搞清楚普通路径长度是多少，根据够早的哈弗曼数，每一个节点到根节点的所要经过的边数称为路径长度，此处记为Li（第i个节点的...）\r\n加权路径长度即为全部节点LiWi的西格玛求和\r\n本题目构造的哈夫曼树WPL为\r\n0.2×1+0.19×2+0.18×3+0.17×4+0.14×5+0.12×5\r\n\r\n\r\n学过好久了，可能有纰漏，海涵。", "Konwledge_Point": "哈夫曼编码", "Question": "数据结构------树  能不能帮忙解答下\n有一份电文中共使用 6个字符：a，b，c，d，e，f，它们的出现频率依次为：  0.2，0.17，0.14，0.12，0.18，0.19，回答下面的问题： \n\n (1)   试构造一棵哈夫曼树（小值左子树，大值右子树） \n\n (2)   给出各个字符的编码（按照左0右1编码）\n\n (3)   求其加权路径长度WPL", "Tag": "算法分析"}
{"Answer": "而哈夫曼树（Huffman Tree）是在叶子结点和权重确定的情况下，带权路径长度最小的二叉树，也被称为最优二叉树。--链接转自\n最全哈夫曼树哈夫曼编码讲解，兄弟你值得拥有_记录博主学到的点滴-CSDN博客\n目录 1.哈夫曼树的概念                路径概念        路径长度概念         节点的带权路径长度        树的带权路径长度 2.构建哈夫曼树的步骤 3.构建哈夫曼树的完整代码 4.哈夫曼编码1.哈夫曼树的概念在正式\n\n\n\nhttps://blog.csdn.net/qq_45737068/article/details/106910349\n\n想要得到一颗哈夫曼树，就应该每次找到权值最小的两个点的权值和作为他们两个点的根节点，这样做的目的是用最大的深度乘以最小的权重。所以为了每次都取最小的两个值，就需要把数组排列一下。", "Konwledge_Point": "哈夫曼编码", "Question": "为什么这个地方要将哈夫曼树的权值由大到小排列。\nfor\n(\ni\n=0;i<256;i++)\n\n{                    \n//\n按出现权值从大到小排序\n    for\n(\nj\n=i+1;j<256;j++)\n{\n        \nif\n(header[i].countheader[j].count)\n \n//\n代表不在哈夫曼树中 \n        {    \n            pt1=j; \n//j\n是下标 \n            min1=header[j]\n.count\n; \n            continue;    \n        } \n    }\n    header[i]\n.count=header\n[pt1]\n.count\n; \n    header[pt1]\n.parent=i\n;      \n    header[i]\n.lch=pt1\n;   \n    min1=999999999;   \n    for\n(\nj\n=0;jheader[j].count)\n\n        {\n            pt1=j; \n            min1=header[j]\n.count\n; \n            continue; \n        } \n    }\n    header[i]\n.count\n+=header[pt1]\n.count\n; \n    header[i]\n.rch=pt1\n;   \n    header[pt1]\n.parent=i\n;            \n//\n哈夫曼无重复前缀编码 \n}\n", "Tag": "算法分析"}
{"Answer": "你用写的？\r\nchar cd[n];\r\n这句能通过编译？怎么可能？", "Konwledge_Point": "哈夫曼编码", "Question": "赫夫曼树出错 ，编译没错 不知道哪里错了运行不了\n编译没有错误，运行失败\n\n\n\n\n#include \n#include \n#include  \n#include  \n#define STACK_INIT_SIZE 100//存储空间初始分配量  没分号“;” \n#define STACKINCREMENT 10 //存储空间分配增量\n\n#define TRUE 1\n#define FALSE 0\n#define OK 1\n#define ERROR 0\n#define INFEASIBLE -1\n\ntypedef struct {\n    unsigned int weight;\n    unsigned int parent,lchild,rchild;  \n}HTNode,*HuffmanTree;\n\ntypedef char **HuffmanCode;\n\n//在HT[1..i-1]选择parent为0且weight最小的两个结点，\n//其序号为最小s1和次小s2(若parent≠0，则说明被选取过不能再选)\n//s1s2并不是指的weight权值，而是最（次）小的这个字符前面的编号（后面需要填进lchild、rchild）\n\nvoid Select(HuffmanTree p,int n,int *s1,int *s2)\n{\n    int i;\n    int min = 99999;\n    for(i=1;i<=n;i++){\n        if(p[i].parent == 0){\n            if(p[i].weight <= min){\n            min = p[i].weight;\n            *s1 = i;\n            }\n        }   \n    }\n    min = 99999;\n    for(i=1;i<=n;i++){\n        if(p[i].parent==0){\n            if(p[i].weight<=min && i!=*s1){\n            min = p[i].weight;\n            *s2 = i;\n            }\n        }   \n    }   \n}\n\n\nvoid HuffmanCoding(HuffmanTree *HT,HuffmanCode *HC,int *w,int n){\n    //n字符 m节点 HT空间\n    int m,i;\n    HuffmanTree p;\n    //int w[8] = {5,29,7,8,14,23,3,11};\n    m = 2*n-1;\n    if(n<=1){return;}   \n    //加上一个未用的0号单元\n    HT = (HuffmanTree *)malloc((m+1)*sizeof(HTNode)); \n\n    //一：初始化，得a图：\n    //(1)把已有字符（1-8） 权重赋值w，左右孩子及parent赋值为0,p指向第二个单元（非0第一个） \n    for(p=*HT+1,i=1 ; i<=n ; ++i,++p,++w){//[问题p=HT+1？]看和鸿昌的聊天记录 \n        //*p={*w,0,0,0};\n        //错误原因： 赋值数组不能分着写\n        //http://zhidao.baidu.com/link?url=jZOgI5PGVycg1v6c1pJ2AlDI3J6fiDLUQQ-1FkGjGzrXTE-hYQusYkoVQlM-EBhr3IjdF9d1wy-o_6elz6m2hald8u0LVM1EUzDaTZ6Rs7e\n        (*p).weight = *w;\n        (*p).parent = 0;\n        (*p).lchild = 0;\n        (*p).rchild = 0;\n    }\n    //(2)把未知字符（9-15） 权重、左右孩子及parent赋值为0， p指向上面跳出来的 未知字符的第一个 9\n    for(;i<=m;++i,++p){\n        (*p).weight = 0;\n        (*p).parent = 0;\n        (*p).lchild = 0;\n        (*p).rchild = 0;    \n    }\n\n    //二：建立赫夫曼树,得到b图 \n    //在HT[1..i-1]选择parent为0且weight最小的两个结点，其序号为最小s1和次小s2(若parent≠0，则说明被选取过不能再选)\n    for(i=n+1;i<=m;++i){    //n+1 即后面未知字符 （比如9开始到15） \n    int s1,s2;\n    //void Select(HuffmanTree HT,int q,int *s1,int *s2){\n    Select(*HT,i-1,&s1,&s2);\n\n    //select(*HT,i-1,&s1,&s2);\n\n    //给s1 s2的parent赋值为当前i 编号 \n    (*HT)[s1].parent = i;\n    (*HT)[s2].parent = i;\n    //给当前i 的lchild和rchild赋值为s1、s2编号 ，给当前i 的 weight赋值为二者权重之和\n    //设最小的作左子树，次小的作右子树 \n    (*HT)[i].lchild = s1;\n    (*HT)[i].rchild = s2;\n    (*HT)[i].weight = (*HT)[s1].weight + (*HT)[s2].weight;\n    }\n\n    //三：从叶子到根逆向求每个结点字符的赫夫曼编码 \n\n    //存放赫夫曼编码的cd \n    char cd[n];\n    int c,f;\n    //分配n个字符编码的头指针向量HC \n    //HuffmanTree HC;报错类型：declaration of'HTNode* HC'shadows a parameter 原因：函数参数里已有HC的定义导致重复 \n    HC = (HuffmanCode *)malloc((n+1)*sizeof(char *));\n    //编码结束符  如声明cd[8]，0-7中最后一个结束符则为cd[7] \n    cd[n-1] = '\\0';//书上写错了，应该是'\\0' \n    //1-8逐个求 \n    for(i=1;i<=n;++i){\n        //编码结束符位置 \n        int start = n-1;\n        //c=i，f指向当前字 符i的双亲 双亲不为0则循环 经过循环一次后，当前字符变成它的双亲,以此逆向递推 \n        //小细节：--start  如图 \n        for(c=i,f=(*HT)[i].parent;f!=0;c=f,f=(*HT)[f].parent){\n            if((*HT)[f].lchild ==c){\n            cd[--start]='0';//书上写错了，应该是单引号'0' \n            }else{\n            cd[--start]='1';\n            }\n            //for循环结束后，得到cd，为第i个字符分配存储空间HC\n            (*HC)[i] = (char *)malloc((n-start)*sizeof(char));\n            //start目前指到最前面了，所以将cd复制（strcpy）给HC \n            /*原型声明：char *strcpy(char* dest, const char *src);\n                头文件：#include  和 #include \n                功能：把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间*/\n            strcpy((*HC)[i],&cd[start]);\n        }\n    }\n    free(cd);\n}\n\n\n\n\nint main(void){\n   HuffmanTree HT;\n   HuffmanCode HC;\n   int n;\n   printf(\"请输入字符个数(空格间隔)：\");\n   scanf(\"%d\",&n);\n\n   int i; \n   int *w=NULL;\n   w=(int*)malloc(n*sizeof(int));\n   printf(\"请依次输入权值(空格间隔)：\");\n   for(i=0;i<n;i++){\n      scanf(\"%d\",w+i);\n   }\n\n   HuffmanCoding(&HT,&HC,w,n);\n   for(i=1;i<=n;i++){ \n   puts(HC[i]);//???\n   } \n}\n\n\n\n\n\n已解决。。。", "Tag": "算法分析"}
{"Answer": "\n ", "Konwledge_Point": "哈夫曼编码", "Question": "哈夫曼树压缩，报错不能将errno_t类型的值分配到+file*类型的实体，该怎么修改解决这个问题\n\n\n#include  \n#include  \n#include  \n#include  \n#define _CRT_SECURE_NO_WARNINGS\n\n/*哈夫曼树结构定义*/\nstruct head\n{\n    unsigned char b;            /*定义一个字符*/\n    long count;                 /*频率数据*/\n    long parent, lch, rch;        /*创建哈夫曼树*/\n    char bits[256];             /*哈夫曼结点*/\n}header[512], tmp;\n\n\n/*压缩文件*/\nvoid yasuo()\n{\n    char filename[255], outputfile[255], buf[512];\n    unsigned char c;\n    char wenjianming[255];\n    long i, j, m, n, f;\n    long min1, pt1, flength;\n    FILE* ifp, * ofp;\n    printf(\"请输入文件地址及文件名：\");\n    gets_s(filename);\n    ifp = fopen_s( &ifp,\"filename\", \"rb\");     /*打开源文件并读取*/\n    while (ifp == NULL)\n    {\n        printf(\"打开文件时出错！\\n\");\n        printf(\"请重新输入文件地址及文件名：\");\n        gets_s(filename);\n        ifp = fopen_s(&ifp,\"filename\", \"rb\");\n    }\n    printf(\"请输入压缩后的文件地址和文件名及后缀：\");\n    gets_s(wenjianming);\n    ofp = fopen_s(&ofp,\"wenjianming\", \"wb\");    /*创建并打开目的文件*/\n\n    while (ofp == NULL)\n    {\n        printf(\"请重新输入压缩后的文件地址和文件名及后缀：\");\n        ofp = fopen_s(&ofp,\"wenjianming\", \"wb\");\n    }\n    flength = 0;\n\n    /*读取ifp文件*/\n    while (!feof(ifp))\n    {\n        fread(&c, 1, 1, ifp);           /*按位读取文件*/\n        header[c].count++;           /*记录文件的字符总数*/\n        flength++;\n    }\n    flength = -1;\n    header[c].count = -1;             /*读取文件结束*/\n    /*构造哈弗曼树，初始结点的设置*/\n    for (i = 0; i < 512; i++)\n    {\n        if (header[i].count != 0)\n            header[i].b = (unsigned char)i;\n        else\n            header[i].b = 0;\n        header[i].parent = -1;\n        header[i].lch = header[i].rch = -1;\n    }\n    /*按结点出现的次数排序*/\n    for (i = 0; i < 256; i++)\n    {\n        for (j = i + 1; j < 256; j++)\n        {\n            if (header[i].count < header[j].count)\n            {\n                tmp = header[i];\n                header[i] = header[j];\n                header[j] = tmp;\n            }\n        }\n    }\n    /*统计不同字符的数量*/\n    for (i = 0; i < 256; i++)\n        if (header[i].count == 0)\n            break;\n    n = i;\n    m = 2 * n - 1;\n    for (i = n; i < m; i++)\n    {\n        min1 = 999999999;\n        for (j = 0; j < i; j++)\n        {\n            if (header[j].parent != -1)\n                continue;\n            if (min1 > header[j].count)\n            {\n                pt1 = j;\n                min1 = header[j].count;\n                continue;\n            }\n        }\n        header[i].count = header[pt1].count;\n        header[pt1].parent = i;\n        header[i].lch = pt1;\n        min1 = 999999999;\n        for (j = 0; j < i; j++)\n        {\n            if (header[j].parent != -1)\n                continue;\n            if (min1 > header[j].count)\n            {\n                pt1 = j;\n                min1 = header[j].count;\n                continue;\n            }\n        }\n        header[i].count += header[pt1].count;\n        header[i].rch = pt1;\n        header[pt1].parent = i;\n    }\n    /*构造哈夫曼树，设置字符编码*/\n    for (i = 0; i < n; i++)\n    {\n        f = i;\n        header[i].bits[0] = 0;\n        while (header[f].parent != -1)\n        {\n            j = f;\n            f = header[f].parent;\n            if (header[f].lch == j)\n            {\n                j = strlen(header[i].bits);\n                memmove(header[i].bits + 1, header[i].bits, j + 1);\n                header[i].bits[0] = '0';\n            }\n            else\n            {\n                j = strlen(header[i].bits);\n                memmove(header[i].bits + 1, header[i].bits, j + 1);\n                header[i].bits[0] = '1';\n            }\n        }\n    } /*哈弗曼构造结束*/\n\n    //读取源文件中的每一个字符，按照设置好的编码替换文件中的字符\n    fseek(ifp, 0, SEEK_SET);\t\t\t\t\t/*把文件指针指向文件的开头*/\n    fwrite(&flength, sizeof(int), 1, ofp);     /*把哈弗曼代码写入ofp文件*/\n    fseek(ofp, 8, SEEK_SET);                   /*以8位二进制数为单位读取*/\n    buf[0] = 0;\n    f = 0;\n    pt1 = 8;\n    while (!feof(ifp))\n    {\n        c = fgetc(ifp);        //从流中读取一个字符，并增加文件指针的位置\n        f++;\n        for (i = 0; i < n; i++)\n        {\n            if (c == header[i].b)\n                break;\n        }\n        strcat_s(buf, header[i].bits); //把header[i].bits所指字符串添加到buf结尾处\n        j = strlen(buf);            //计算字符串buf的长度\n        c = 0;\n        while (j >= 8)     /*按八位二进制数转化成十进制ASCII码写入文件一次进行压缩*/\n        {\n            for (i = 0; i < 8; i++)\n            {\n                if (buf[i] == '1') c = (c << 1) | 1;\n                else c = c << 1;\n            }\n            fwrite(&c, 1, 1, ofp);\n            pt1++;\n            strcpy_s(buf, buf + 8);\n            j = strlen(buf);\n        }\n        if (f == flength)\n            break;\n    }\n    if (j > 0) /*剩余字符数量少于8个*/\n    {\n        strcat_s(buf, \"00000000\");\n        for (i = 0; i < 8; i++)\n        {\n            if (buf[i] == '1') c = (c << 1) | 1;\n            else c = c << 1;     /*对不足的位数补0*/\n        }\n        fwrite(&c, 1, 1, ofp);\n        pt1++;\n    }\n    //将编码信息写入存储文件\n    fseek(ofp, 4, SEEK_SET);     /*fseek 用于二进制方式打开的文件,移动文件读写指针位置.第一个是文件流,第3个是指针零点位置,第2个是把指针移动到的地点. */\n    fwrite(&pt1, sizeof(long), 1, ofp); /*是要输出数据的地址,每次写入的位数,数据项的个数，目标文件地址*/\n    fseek(ofp, pt1, SEEK_SET);\n    fwrite(&n, sizeof(long), 1, ofp);\n    for (i = 0; i < n; i++)\n    {\n        fwrite(&(header[i].b), 1, 1, ofp);\n        c = strlen(header[i].bits);\n        fwrite(&c, 1, 1, ofp);\n        j = strlen(header[i].bits);\n        if (j % 8 != 0)             /*按八位读取，位数不满8位时，对该位补0*/\n        {\n            for (f = j % 8; f < 8; f++)\n                strcat_s(header[i].bits, \"0\");\n        }\n        while (header[i].bits[0] != 0)\n        {\n            c = 0;\n            for (j = 0; j < 8; j++)\n            {\n                if (header[i].bits[j] == '1') c = (c << 1) | 1;\n                else c = c << 1;\n            }\n            strcpy_s(header[i].bits, header[i].bits + 8);  /*把从header[i].bits+8地址开始且含有NULL结束符的字符串赋值到以header[i].bits开始的地址空间 */\n            fwrite(&c, 1, 1, ofp);\n        }\n    }\n    fclose(ifp);\n    fclose(ofp);\n    printf(\"压缩成功\\n\");\n\n}\n/*主函数*/\nvoid main()\n{\n    printf(\"输入a开始压缩\\n\");\n    printf(\"输入b结束压缩\\n\");\n    while (1)\n    {\n        char c;\n        c =_getch();\n        if (c == 'a')\n            yasuo();\n        else\n        {\n            if (c == 'b')\n                return;\n        }\n    }\n}\n", "Tag": "算法分析"}
{"Answer": "干了几年了，你说的这些我一个都不会", "Konwledge_Point": "哈夫曼编码", "Question": "写逻辑代码要很长的时间适合走后端吗？\n(刚学习新算法后敲代码)\n哈夫曼基本实现编码用了两天(译码没写)\n棋盘覆盖用了6个小时\ndijkstra用了6个小时\n背包回溯用了4个小时\n二叉树基本操作包括结点数，度为1结点数等实现用了8个钟(递归)\n\n\n就感觉自己敲逻辑代码好慢，适合干后端吗，现在有点想走前端的想法", "Tag": "算法分析"}
{"Answer": "自己顶下……求解答啊求解答", "Konwledge_Point": "哈夫曼编码", "Question": "求关于图片裁剪的底层算法解释\n根据鼠标点击位置得到裁剪范围，然后把指定范围裁剪出来。从底层来看，就是输出指定范围的数据。拿jpg为例，jpg是个压缩格式，经过了游程编码和哈夫曼树，算法是怎么找到鼠标\n\n点击位置是在图像数据的哪里？怎么确定的指定范围对应的图形数据？我看了一些裁剪的源码，但是没有看懂......求大神帮忙解答!!  ", "Tag": "算法分析"}
{"Answer": "ChatGPT :在C语言中，无法直接将map写入文件，因为map是一个动态的数据结构，其大小在编译时无法确定。因此，需要将map转换为一种可以写入文件的数据结构，比如数组或者结构体。在本文中，作者使用了一个名为ZipStruct的结构体来存储压缩文件的相关信息，其中包括编码表（encodeMap）和所占字节数（size）。在压缩文件时，先将编码表和字节流写入ZipStruct结构体中，然后再将整个结构体写入文件中。在解压文件时，先读取ZipStruct结构体，然后根据其中的编码表将二进制编码字符串转化为原始字符，最后将原始字符写入文件中。需要注意的是，在写入和读取文件时，需要使用二进制模式打开文件，否则可能会出现数据损坏的情况。同时，在写入和读取结构体时，需要使用fwrite和fread函数，而不是普通的文件写入和读取函数。", "Konwledge_Point": "哈夫曼编码", "Question": "关于C语言写入结构体时无法写入map的问题\n在写哈夫曼编码压缩与解压文件的问题时，Java是非常容器且没有问题的；但是在C语言里面，这个文件读写就变得很困难；当我尝试写入一个结构体时，发现没有问题，但是实际并没有将map的内容顺利写入；而且我发现不管是fread还是fwrite，都无法将无法提前确定大小的map集合写入；太痛苦了；感觉我已经在尝试学习Java序列化的解决思路了。\n\n\n代码如下：（原本以为已经写完的我，才发现只是开了个头；C语言的文件读写好折磨，太折磨了）\n文章地址：\n\n      \n        \n\n        \n      \n\n      \n\n      \n\n        \n\n         https://blog.csdn.net/bingbingyihao/article/details/129979463\n        \n\n      \n\n\n# \ninclude\n \n\n\n# \ninclude\n \n\n\n# \ninclude\n \n\n\n# \ninclude\n \n\n\n# \ninclude\n \n\n\n# \ninclude\n \n\n\n# \ninclude\n \n\n\n# \ninclude\n \n\n\nusing\n \nnamespace\n std;\n\n\n// 读取文件得到int数组转化成哈夫曼编码得到哈夫曼树，进行压缩与解压\n\n\n\ntypedef\n \nint\n elementType;\n\n\nstruct\n \nNode\n\n{\n    elementType data;\n    \nint\n value;\n    Node* left;\n    Node* right;\n};\n\n\nstruct\n \nZipStruct\n\n{\n    map\n encodeMap; \n// 由哈夫曼树生成的编码表\n\n    \nint\n size = \n0\n; \n// 所占字节数\n\n    \nint\n zipSize = \n0\n; \n// 所占比特数（用于处理末尾数字补全）\n\n};\n\n\nstruct\n \nZip\n\n{\n    string originFileName;\n    string destFileName; \n// 压缩生成的文件名\n\n    elementType* buff = \nNULL\n; \n// 读入的文件字符数据\n\n    map\nint> twoTuple; \n// 字符串转化为二元组形式，表示各个字符出现的频率\n\n    map\n encodeMap; \n// 由哈夫曼树生成的编码表\n\n    string res; \n// 生成的二进制编码字符串\n\n    \nint\n size = \n0\n; \n// 所占字节数\n\n    \nint\n zipSize = \n0\n; \n// 所占比特数（用于处理末尾数字补全）\n\n};\n\n\nstruct\n \nUnZip\n\n{\n    string originFileName; \n// 要解压的文件名\n\n    string destFileName; \n// 解压生成的文件名\n\n};\n\n\n// 将int数组转化为二元组形式，表示各个int数字出现的频率\n\n\nmap\nint\n> \ngetList\n(\nint\n* text, \nint\n length)\n;\n\n\n//自定义排序函数  \n\n\nbool\n \ncmp\n(\nconst\n Node* node1, \nconst\n Node* node2)\n;\n\n\n// 通过二元组创建哈夫曼树\n\n\nNode* \ncreateHafumanTree\n(vector\n list)\n;\n\n\n// 获取编码\n\n\nvoid\n \ngetCodes\n(Node* root, string path, map\n& encodeMap)\n;\n\n\n// 读取文件内容，得到int数组\n\n\nelementType* \nreadFile\n(string fileName, \nint\n& size)\n;\n\n\n// 根据编码表将int数组转化为新的编码\n\n\nstring \ntransform\n(elementType* buff, \nint\n length, map\n encodeMap)\n;\n\n\n// 获取文件生成的二进制编码字符串\n\n\nvoid\n \ngenerateCodes\n(Zip& zip)\n;\n\n\n//将传入的二进制字符串转换成十进制，并返回十进制数字\n\n\nint\n \nbinToTen\n(string binaryString)\n;\n\n\n// 将新编码字符串转化为int数组(转化采用末尾不够补0)，减少占用空间，并写入文件中，返回文件比特数，同时一并将编码表和字节与比特数写入\n\n\nvoid\n \nzipFile\n(string res, string fileName, \nint\n& zipSize, ZipStruct* zipStruct)\n;\n\n\n//将传入的int转换成二进制字符串\n\n\nstring \nintToBin\n(\nint\n ch)\n;\n\n\n// 根据编码表将文件还原\n\n\nvoid\n \nunZipFile\n(string originFileName, string destFileName, ZipStruct* zipStruct)\n;\n\n\nint\n \nmain\n()\n\n\n{\n    Zip zip;\n    UnZip unZip;\n    ZipStruct zipStruct;\n\n    zip.originFileName = \n\"D:/test.png\"\n;\n    zip.destFileName = \n\"D:/test.myZip\"\n;\n    \ngenerateCodes\n(zip);\n    zipStruct.encodeMap = zip.encodeMap;\n    zipStruct.size = zip.size;\n    \nzipFile\n(zip.res, zip.destFileName, zip.zipSize, &zipStruct);\n\n    unZip.originFileName = zip.destFileName;\n    unZip.destFileName = \n\"D:/test1.png\"\n;\n    \nunZipFile\n(unZip.originFileName, unZip.destFileName, &zipStruct);\n\n    \nsystem\n(\n\"pause\"\n);\n}\n\n\nmap\nint\n> \ngetList\n(\nint\n* text, \nint\n length)\n\n{\n    map\nint> map;\n    \nfor\n (\nint\n i = \n0\n; i < length; i++)\n    {\n        \nif\n (map.\ncount\n((\nint\n)text[i]) == \n1\n)\n        {\n            map[text[i]] = map[text[i]] + \n1\n;\n        }\n        \nelse\n\n        {\n            map[text[i]] = \n1\n;\n        }\n    }\n    \nreturn\n map;\n}\n\n\nbool\n \ncmp\n(\nconst\n Node* node1, \nconst\n Node* node2)\n\n\n{\n    \nreturn\n node1->value > node2->value;\n}\n\n\nNode* \ncreateHafumanTree\n(vector\n list)\n\n\n{\n    \nwhile\n (list.\nsize\n() > \n1\n)\n    {\n        \nsort\n(list.\nbegin\n(), list.\nend\n(), cmp);\n\n        Node* left = list.\nat\n(list.\nsize\n() - \n1\n);\n        Node* right = list.\nat\n(list.\nsize\n() - \n2\n);\n        Node* node = (Node*)\nmalloc\n(\nsizeof\n(Node));\n        \nif\n (node == \nNULL\n)\n        {\n            cout << \n\"内存不足\"\n << endl;\n            \nreturn\n \nNULL\n;\n        }\n        node->value = left->value + right->value;\n        node->left = left;\n        node->right = right;\n\n        list.\npop_back\n();\n        list.\npop_back\n();\n        list.\npush_back\n(node);\n    }\n\n    \nreturn\n list.\nat\n(\n0\n);\n}\n\n\nvoid\n \ngetCodes\n(Node* root, string path, map\n& encodeMap)\n\n\n{\n    \nif\n (root == \nNULL\n)\n    {\n        \nreturn\n;\n    }\n    \nif\n (root->left == \nNULL\n && root->right == \nNULL\n)\n    {\n        encodeMap.\ninsert\n(map\n::\nvalue_type\n(root->data, path));\n    }\n    \ngetCodes\n(root->left, path + \n\"0\"\n, encodeMap);\n    \ngetCodes\n(root->right, path + \n\"1\"\n, encodeMap);\n}\n\n\nelementType* \nreadFile\n(string fileName, \nint\n& size)\n\n\n{\n    \nstruct\n \nstat\n buf;\n    \nstat\n(fileName.\nc_str\n(), &buf);\n    size = buf.st_size;\n\n    FILE* fp = \nNULL\n;\n    \nint\n* buff = \nnew\n \nint\n[buf.st_size];\n\n    \nerrno_t\n err;\n    \nif\n ((err = \nfopen_s\n(&fp, fileName.\nc_str\n(), \n\"rb\"\n)) != \n0\n)\n    {\n        cout << \n\"文件打开失败\"\n << endl;\n        \nreturn\n \nNULL\n;\n    }\n\n    \nint\n index = \n0\n;\n    \nwhile\n (index < buf.st_size)\n    {\n        buff[index++] = \nfgetc\n(fp);\n    }\n    \nfclose\n(fp);\n    \nreturn\n buff;\n}\n\n\nstring \ntransform\n(elementType* buff, \nint\n length, map\n encodeMap)\n\n\n{\n    string res = \n\"\"\n;\n    \nfor\n (\nint\n i = \n0\n; i < length; i++)\n    {\n        res += encodeMap[buff[i]];\n    }\n    \nreturn\n res;\n}\n\n\nvoid\n \ngenerateCodes\n(Zip& zip)\n\n\n{\n    zip.buff = \nreadFile\n(zip.originFileName, zip.size);\n    zip.twoTuple = \ngetList\n(zip.buff, zip.size);\n    vector\n list;\n    \nfor\n (\nauto\n& it : zip.twoTuple)\n    {\n        Node* node = (Node*)\nmalloc\n(\nsizeof\n(Node));\n        \nif\n (node == \nNULL\n)\n        {\n            cout << \n\"内存不足\"\n << endl;\n            \nreturn\n;\n        }\n        node->data = it.first;\n        node->value = it.second;\n        node->left = \nNULL\n;\n        node->right = \nNULL\n;\n        list.\npush_back\n(node);\n    }\n\n    Node* root = \ncreateHafumanTree\n(list);\n    \ngetCodes\n(root, \n\"\"\n, zip.encodeMap);\n    zip.res = \ntransform\n(zip.buff, zip.size, zip.encodeMap);\n}\n\n\nint\n \nbinToTen\n(string binaryString)\n\n\n{\n    \nint\n parseBinary = \n0\n;\n    \nfor\n (\nint\n i = \n0\n; i < binaryString.\nlength\n(); ++i)\n    {\n        \nif\n (binaryString[i] == \n'1'\n)\n        {\n            parseBinary += \npow\n(\n2.0\n, binaryString.\nlength\n() - i - \n1\n);\n        }\n    }\n    \nreturn\n parseBinary;\n}\n\n\nvoid\n \nzipFile\n(string res, string fileName, \nint\n& zipSize, ZipStruct* zipStruct)\n\n\n{\n    zipSize = res.\nlength\n();\n    zipStruct->zipSize = zipSize;\n    \nif\n (res.\nlength\n() % \n8\n != \n0\n)\n    {\n        \nfor\n (\nint\n i = \n0\n; i < res.\nlength\n() % \n8\n; i++)\n        {\n            res += \n\"0\"\n;\n        }\n    }\n\n    \nchar\n* bytes = \nnew\n \nchar\n[res.\nlength\n() / \n8\n];\n    \nint\n index = \n0\n;\n    \nfor\n (\nint\n i = \n0\n; i < res.\nlength\n();)\n    {\n        string subStr = res.\nsubstr\n(i, \n8\n);\n        i += \n8\n;\n        bytes[index] = \nbinToTen\n(subStr);\n        index++;\n    }\n\n    FILE* fp = \nNULL\n;\n    \nerrno_t\n err;\n    \nif\n ((err = \nfopen_s\n(&fp, fileName.\nc_str\n(), \n\"wb\"\n)) != \n0\n)\n    {\n        cout << \n\"文件写入失败\"\n << endl;\n        \nreturn\n;\n    }\n    \nfwrite\n(zipStruct, \nsizeof\n(ZipStruct), \n1\n, fp);\n    \nfwrite\n(bytes, \nsizeof\n(\nunsigned\n __int8), res.\nlength\n() / \n8\n, fp);\n    \nfclose\n(fp);\n}\n\n\nstring \nintToBin\n(\nint\n ch)\n\n\n{\n    string res = \n\"\"\n;\n    \nfor\n (\nint\n i = \n7\n; i >= \n0\n; i--)\n    {\n        \nif\n (ch & (\n128\n >> \n7\n - i))\n        {\n            res += \n\"1\"\n;\n        }\n        \nelse\n\n        {\n            res += \n\"0\"\n;\n        }\n    }\n    \nreturn\n res;\n}\n\n\nvoid\n \nunZipFile\n(string originFileName, string destFileName, ZipStruct* zipStruct)\n\n\n{\n    FILE* fp = \nNULL\n;\n    \nerrno_t\n err;\n    \nif\n ((err = \nfopen_s\n(&fp, originFileName.\nc_str\n(), \n\"rb\"\n)) != \n0\n)\n    {\n        cout << \n\"文件打开失败\"\n << endl;\n        \nreturn\n;\n    }\n\n    \nfread\n(zipStruct, \nsizeof\n(ZipStruct), \n1\n, fp);\n    map\n decodeMap;\n    \nfor\n (\nauto\n& it : zipStruct->encodeMap)\n    {\n        decodeMap.\ninsert\n(map\nchar>::\nvalue_type\n(it.second, it.first));\n    }\n\n    \n// 为了凑整，省的用if语句了\n\n    \nint\n size = zipStruct->zipSize;\n    \nint\n length = (size + \n7\n) / \n8\n;\n    \nint\n* buff = \nnew\n \nint\n[length];\n    \nint\n index = \n0\n;\n    \nwhile\n (index < length)\n    {\n        buff[index++] = \nfgetc\n(fp);\n    }\n    \nfclose\n(fp);\n\n    string res = \n\"\"\n;\n    \nfor\n (\nint\n i = \n0\n; i < length; i++)\n    {\n        res += \nintToBin\n(buff[i]);\n    }\n\n    string text = \n\"\"\n;\n    \nfor\n (\nint\n i = \n0\n; i <= size;)\n    {\n        index = \n1\n;\n        \nwhile\n (i + index <= size)\n        {\n            string temp = res.\nsubstr\n(i, index);\n            \nif\n (decodeMap.\ncount\n(temp) == \n1\n)\n            {\n                text += decodeMap[temp];\n                \nbreak\n;\n            }\n            index++;\n        }\n        i += index;\n    }\n\n    \nif\n ((err = \nfopen_s\n(&fp, destFileName.\nc_str\n(), \n\"wb\"\n)) != \n0\n)\n    {\n        cout << \n\"文件写入失败\"\n << endl;\n        \nreturn\n;\n    }\n    \nfwrite\n(text.\nc_str\n(), \nsizeof\n(\nunsigned\n __int8), text.\nlength\n(), fp);\n    \nfclose\n(fp);\n}\n\n\n\n文章可能在审核，要过一小会才能看到", "Tag": "算法分析"}
{"Answer": "贪心的意思就是每次都选最好的，哈夫曼编码的贪心就是每次都选择权重最大的两个结点作为兄弟结点。", "Konwledge_Point": "哈夫曼编码", "Question": "求解哈夫曼编码时如何体现贪心思路\n请问求解哈夫曼编码时如何体现贪心思路，就是哈夫曼编码的贪心策略吗？", "Tag": "算法分析"}
{"Answer": "哈夫曼编码C语言问题参考：https://blog.csdn.net/qq_45746876/article/details/109938879", "Konwledge_Point": "哈夫曼编码", "Question": "关于#c语言#的问题：从控制台输入一个字符串，使用哈夫曼编码对该字符串进行编码，输出每个字符对应的编码以及字符串的编码\n从控制台输入一个字符串，使用哈夫曼编码对该字符串进行编码，输出每个字符对应的编码以及字符串的编码。", "Tag": "算法分析"}
{"Answer": "说实话，我也看不懂。\r\n1. 你要给出上下文，如果这是书上的例子，那么书上肯定会事先或事后说明这段代码是干什么。只有光代码，我根本没有耐心看完\r\n2. 你要尝试着自己去理解，如果真看不懂，至少要说出你的理解，然后我们来帮你分析。", "Konwledge_Point": "哈夫曼编码", "Question": "跪求大神 帮忙，这段关于哈夫曼编码 的程序着实看不懂啊。。。。。。。\nstruct Codetype{//哈弗曼编码数据类型\n\nchar \nbits;//编码流-数组，n为为哈夫曼树中叶子结点的数目，编码的长度不可能超过n\n\nint start;//编码实际在编码流数组里的开始位置\n\n};\n\nCodetype *HuffmanCode(hufmtree *tree){//哈弗曼编码的生成\n\n  int i,j,p,k;\n\n  Codetype *code; \n\n  if(tree==NULL)\n\n     return NULL;\n\n  code=(Codetype\n)malloc(tree->n*sizeof(Codetype));//把tree的n个叶子节点生成哈夫曼码\n\n  for(i=0;in;i++)\n\n  {\n\n      printf(\"%c\",tree->node[i].data);//打印字符信息\n\n      code[i].bits=(char*)malloc(tree->n*sizeof(char));\n\n      code[i].start=tree->n-1;\n\n      j=i;\n\n      p=tree->node[i].parent;\n\n      while(p!=-1){\n\n             if(tree->node[p].lchild==j)\n\n                  code[i].bits[code[i].start]='0';\n\n             else\n\n                 code[i].bits[code[i].start]='1';\n\n             code[i].start--;\n\n             j=p;\n\n             p=tree->node[p].parent;\n\n     }\n\n     for(k=code[i].start+1;kn;k++)//打印字符编码\n\n        printf(\"%c\",code[i].bits[k]);\n\n    printf(\"\\n\");\n\n  }\n\n    return code;\n\n}", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/fduan/article/details/7837444\r\nhttp://blog.sina.com.cn/s/blog_686d0fb001012qmh.html", "Konwledge_Point": "哈夫曼编码", "Question": "电工4课程作业2：哈夫曼编码实验\n1) 问题描述设某编码系统共有n个字符，使用频率分别为{w1, w2, …, wn}，设计一个不等长的编码方案，使得该编码系统的空间效率最好。2) 基本要求(1) 设计数据结构；(2) 设计编码算法；(3) 分析时间复杂度和空间复杂度。", "Tag": "算法分析"}
{"Answer": "要现成代码还是要算法", "Konwledge_Point": "哈夫曼编码", "Question": "如何用哈夫曼编码进行通信C语言？\n怎么用哈夫曼编码实现进行通信C语言的\n发送者的功能：\n输入待传送的字符信息；\n统计字符信息中出现的字符种类数和各字符出现的次数（频率）；\n根据字符的种类数和各自出现的次数建立哈夫曼树；\n利用以上哈夫曼树求出各字符的哈夫曼编码；\n将字符信息转换成对应的编码信息进行传送。\n接收者功能：\n接收发送者传送来的编码信息。\n利用上述哈夫曼树对编码信息进行翻译及将编码信息还原成发送前的字符信息。\n\n\n能在VC++6.0中用 .c 运行下图这结果\n\n", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/c_kite/article/details/53516670, 我们数据结构实验也是这个, 自己写的, 完美运行, 看完记得点赞给分啊", "Konwledge_Point": "哈夫曼编码", "Question": "数据结构哈弗曼编码，急急急急急急！\n在记事本软件中，放入不小于1000个英文字符的文本，命名为source.txt。\n\n编写过程，挑出文本中的不相同字符，输出文件列出每个字符的出现概率。\n\n根据字符列表文件建立字符列表的哈夫曼编码本1\n\n以哈夫曼编码本1为参照，将文本文件source.txt的内容转换为二进制码文件code.dat\n\n以哈夫曼编码本1为参照，将二进制码文件code1.dat的内容解码为target.txt明文\n\n编写函数，对比source.txt和 target.txt是否相同，不同则返回出现不同的位置点。\n\n大学生的数据结构作业，求大神帮忙啊！", "Tag": "算法分析"}
{"Answer": "哈夫曼编码是经典的数据压缩算法，有必要好好学习一下的哦。完整实现参考：\r\nhttps://blog.csdn.net/u013571044/article/details/103042941", "Konwledge_Point": "哈夫曼编码", "Question": "Java语言高分悬赏：怎么实现一个哈夫曼编码树？用到赏节课我们的带权树的构造，要有完整代码\nJava语言高分悬赏：怎么实现一个哈夫曼编码树？用到赏节课我们的带权树的构造，要有完整代码", "Tag": "算法分析"}
{"Answer": "把void main()改成int main()，最后return 0;", "Konwledge_Point": "哈夫曼编码", "Question": "哈夫曼编码问题，有错误不知怎么改\n\n\n\n ", "Tag": "算法分析"}
{"Answer": "#include\r\nusing namespace std;\r\nHuffmanTree::HuffmanTree()                             //初始化空树\r\n{\r\n Node=NULL;                                           //将树结点初始化为空 \r\n Info=NULL;                                           //将字符数组初始化为空\r\n LeafNum=0;                                           //将叶子数初始化为0\r\n}\r\nHuffmanTree::~HuffmanTree()            //析构函数\r\n{\r\n delete[] Node;                                         //释放结点空间\r\n delete[] Info;                                         //释放字符存储空间\r\n}\r\n/////////////////////////////////////////\r\n//初始化函数\r\nvoid HuffmanTree::Initialization(int WeightNum)         \r\n{\r\n int i,j,pos1,pos2,max1,max2;\r\nNode=new HuffmanNode[2*WeightNum-1];        //为哈夫曼树所需的结点申请空间         \r\nInfo=new char[2*WeightNum-1];\r\n for(i=0;i>Info[i];\r\n  cout<<\"请输入该字符的权值或频度\";\r\n  cin>>Node[i].weight;                                 //输入权值\r\n  Node[i].parent=-1;                                   //为根结点\r\n  Node[i].lchild=-1;                                   //无左孩子\r\n  Node[i].rchild=-1;                                   //无右孩子\r\n }\r\n//这里构造出weightnum个带权结点\r\n \r\n for(i=WeightNum;i<2*WeightNum-1;i++)                  \r\n {\r\n  pos1=-1;\r\n  pos2=-1;                                            //分别用来存放当前最小值和次小值的所在单元编号 \r\n  max1=32767;                                         //32767为整型数的最大值 \r\n  max2=32767;                                        \r\n  for(j=0;j>ch;\r\n if(ch=='y'||ch=='Y')\r\n {\r\n ofstream fop;                                       //以二进制方式打开hfmTree.dat文件，并当重新运行时覆盖原文件\r\n fop.open(\"hfmTree.dat\",ios::out|ios::binary|ios::trunc);\r\n if(fop.fail())                                      //文件打开失败\r\n  cout<<\"文件打开失败！\\n\";\r\n fop.write((char*)&WeightNum,sizeof(WeightNum));     //写入WeightNum\r\n for(i=0;i>Choose;\r\n if(Choose=='1')                                       //读取文件ToBeTran.txt\r\n {\r\n  ifstream fip1(\"ToBeTran.txt\");\r\n  if(fip1.fail())                                      //文件不存在\r\n  {\r\n   cout<<\"文件打开失败!\\n\";\r\n   return;                                              //结束本函数\r\n  }\r\n  char ch;\r\n  int k=0;\r\n  while(fip1.get(ch))            \r\n  {\r\n   k++;                                                 \r\n  } \r\n  fip1.close();   \r\n  Tree=new char[k+1];\r\n  ifstream fip2(\"ToBeTran.txt\");\r\n  k=0; \r\n  while(fip2.get(ch))\r\n  {\r\n   Tree[k]=ch;                                            //读取文件内容，并存到Tree中\r\n   k++;\r\n  }\r\n  fip2.close();\r\n  Tree[k]='\\0';                                           //结束标志\r\n  cout<<\"需编码内容为:\";\r\n  cout<LeafNum-1;i--)        \r\n {\r\n  cout<=0;i--)\r\n {\r\n  cout<<i<<\":\"<<Node[i].weight<<\"(\"<<Info[i]<<\")---^\\n\";\r\n  fop<<i<<\":\"<<Node[i].weight<<\"(\"<<Info[i]<<\")---^\\n\";\r\n }\r\n}", "Konwledge_Point": "哈夫曼编码", "Question": "数据结构（C++版）哈弗曼 编码\n问题描述：利用哈夫曼编码进行信息通讯可以大大提高信道的利用率，缩短信息传输时间，降低传输成本。但是，这要求在发送端通过一个编码系统对待传输数据预先编码；在接受端将传来的数据进行译码。对于双工信道（即可以双向传输信息的信道），每端都需要一个完整的编/译码系统。试为这样的信息收发站编写一个哈夫曼码编码/译码系统。\n\n基本要求：根据某字符文件统计字符出现频度，构造Huffman 树，编制Huffman编码，并将给定字符文件编码，生成编码文件；再将给定编码文件解码，生成字符文件（要求按二进制位表示编码）。\n\n提高要求：改进Huffman编码，产生两种以上的编码方案，对同一组测试数据，用不同的编码方案编码，并从文件长度、算法复杂度等方面进行比较分析。\n\n测试数据：找一个英文文档文件或中文文档文件。\n\n用C++来编写，能实现基本要求和提高要求的。", "Tag": "算法分析"}
{"Answer": "您好，楼主的问题已经有解决办法，源码在：http://download.csdn.net/detail/doctorczm/6768399\r\n如果您有积分的话直接去该网址下载即可，如果积分不够的话，我可以将源码粘贴出来，希望能帮助到您！", "Konwledge_Point": "哈夫曼编码", "Question": "哈夫曼树算法设计编码译码\n求大神帮忙用C++语言写一个算法设计\n\n1）从键盘上输入要进行哈夫曼编码的字符集和对应的权值。\n\n2）构造哈夫曼树的算法\n\n3）完成哈夫曼编码的算法\n\n4）完成哈夫曼译码算法。\n\n5)利用编译码算法，对给定的文本文件t1.txt的英语内容进行编码，保存到指定文件code1.txt中。然后再编写一个函数对code1.txt中的内容进行译码。\n\n要求输入哈夫曼编码时，能输出对应的字符。跪求了   真的没法写啊   想不到思路发到我哦空间或者是\n1511437725@qq.com\n都行啊", "Tag": "算法分析"}
{"Answer": "回答：可以自己设置的，哈夫曼树并不唯一，但最终的编码长度是一样的，即二进制位数一致", "Konwledge_Point": "哈夫曼编码", "Question": "哈夫曼编码时左边的一定要比右边的小吗，还是可以任意的呀\n图片最上面那个0.6和0.4就是1大0小，但是好像之前看到的很多都是默认1小0大，左小右大滴", "Tag": "算法分析"}
{"Answer": "def __init__(self,name=None,pro=None):__init__  应该是两边各有两个_下划线你写的是只有一个下划线_init_ \n如有帮助，望采纳！谢谢! 请点击下我回答下方的采纳该回答按钮。", "Konwledge_Point": "哈夫曼编码", "Question": "python,要求输入对应字符和概率，求哈夫曼编码。\n这个报错告诉对象没有属性root，但我在_init_不是写过了吗，刚学习类，不太清楚，疑惑。\n\n\n\n\n\n\n完整代码如下\n\n\nchar_get=\ninput\n().split( )\n#储存字母名称\n\npercent=\ninput\n().split()\n#储存概率\n\npercent=[\nint\n(percent[i])\nfor\n i \nin\n \nrange\n(\nlen\n(percent))]\nlength=\nlen\n(percent)\n#有多少个字符\n\n\n\nclass\n \nNodecreate\n(\nobject\n):\n    \ndef\n \n_init_\n(\nself,name=\nNone\n,pro=\nNone\n):\n        self.name=name\n        self.pro=pro\n        self.left=\nNone\n\n        self.right=\nNone\n\n\nclass\n \nHuffman\n(\nobject\n):\n    \ndef\n \n_init_\n(\nself\n):\n        self.\nlist\n=[Nodecreate(char_get(i),percent(i)) \nfor\n i \nin\n \nrange\n(length)]\n#建立列表，用来进行比较概率。\n\n\n        \nwhile\n(self.\nlist\n)!=\n1\n:\n#当只剩根节点时停止运行\n\n            self.\nlist\n.sort(key=\nlambda\n x:x.pro)\n#从小到大排序\n\n            self.new=Nodecreate(pro=(self.\nlist\n[\n0\n].pro+self.\nlist\n[\n1\n].\nlist\n))\n#新的节点pro之和\n\n\n            self.new.left=self.\nlist\n.pop(\n0\n)\n#左节点为列表第一个节点\n\n            self.new.right=self.\nlist\n.pop(\n0\n)\n#右节点为现在第一个\n\n            self.\nlist\n.append(self.\nlist\n)\n        self.root=self.\nlist\n[\n0\n]\n#储存根节点\n\n\n        self.myth=[\n0\n \nfor\n i \nin\n \nrange\n (\n10\n)]\n    \ndef\n \norder\n(\nself,now_tree,myth_length\n):\n#遍历得到huffman编码\n\n        now_node=now_tree\n        \nif\n now_node.name==\nNone\n:\n            \nreturn\n\n        \nelse\n:\n            \nprint\n(now_node.name,end=\n\"\"\n)\n            \nfor\n i \nin\n \nrange\n (myth_length):\n                \nprint\n(self.myth[i],end=\n\"\"\n)\n            \nreturn\n\n        self.myth[myth_length]=\n0\n\n        self.order(now_node.left,myth_length+\n1\n)\n        self.myth[myth_length] = \n1\n\n        self.order(now_node.right, myth_length + \n1\n)\n    \ndef\n \nfrom_print\n(\nself\n):\n        self.order(self.root,\n0\n)\n\ntree=Huffman()\ntree.from_print()\n\n", "Tag": "算法分析"}
{"Answer": "打眼一看，创建的树没传出来，要不先建个伪根节点进去建树，要不把建的树作为返回值返回出来。函数的参数只是形参，在函数里怎么修改也不会影响原来的变量的值。其他函数类似。还有参数类型，C不能传&引用，传指针就可以了", "Konwledge_Point": "哈夫曼编码", "Question": "用哈夫曼树编码并译码，为啥没有输出呢？\n#include\n#include\n#include\ntypedef struct\n{\n    char data;\n    int weight;\n    int parent,lchild,rchild;\n}HTNode,*HuffmanTree;\n\n\ntypedef char **HuffmanCode;\n\n\nvoid Select(HuffmanTree &HT,int m,int &s1,int &s2)//选择两个权值较小的结点,并返回序号\n{\n    int i,j,min1,min2;\n    min1=min2=1000;\n    for(i=1;i<=m;i++)\n        if(HT[i].parent==0&&HT[i].weight='A'&&str[i]<='Z') str[i]=str[i]+32;\n        if(str[i]>='a'&&str[i]<='z') printf(\"%s\",HC[str[i]-95]);\n        }\n    }\n} \n\n\nint main()\n{\n    HuffmanTree HT;\n    HuffmanCode HC;\n    CreateHuffmanTree(HT,27);\n    printf(\"请输入报文:\");\n    CreateHuffmanCode(HT,HC,27);\n    char s[100];\n    gets(s);\n    InterpretCode(HC,s);\n    return 0;\n}", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/qq_32445015/article/details/79972105", "Konwledge_Point": "哈夫曼编码", "Question": "求哈夫曼对一西文文本提供最优的编、解码方案，并给出编码与解码结果。 其中编码要求正向与逆向两种方式？\n其中编码要求正向与逆向两种方式？\n\n要求实现两个方案：从键盘输入进行解码译码和对已有的文件中的一串英文进行编译码", "Tag": "算法分析"}
{"Answer": "假设对n个数据huffman编码，你用一个n* n的矩阵保存即可", "Konwledge_Point": "哈夫曼编码", "Question": "如何在MATLAB中实现哈夫曼编码？\n我是想用二叉树实现，原本想使用MATLAB调用C语言程序，但是接口函数太难写。\n\n请问怎么在MATLAB中实现树结构，或者用别的方法实现哈夫曼编码。", "Tag": "算法分析"}
{"Answer": "你树不对。\n      100\n   45   55\n      25     30\n  12 13 14 16\n             5 9\n", "Konwledge_Point": "哈夫曼编码", "Question": "这个哈夫曼树是答案错了还是我算错了？\n各位大佬帮忙看看这题的第十七小问，虽然哈夫曼树不是唯一的， 但是这题我算不出选项中的答案，答案也没有写出这一问的具体步骤，是答案错了我还是我错了？\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "\nsourceData = [['a', 15], ['b', 3], ['c', 14], ['d', 2], ['e', 6], ['f', 9], ['g', 16], ['h', 17]]\nclass BinaryTree:\n    def __init__(self, data, weight):\n        self.data = data\n        self.weight = weight\n        self.left = None\n        self.right = None\n\ndef min2(li):\n    result = [BinaryTree(None, float('inf')), BinaryTree(None, float('inf'))]\n    li2 = []\n    for i in range(len(li)):\n        if li[i].weight < result[0].weight:\n            if result[1].weight != float('inf'):\n                li2.append(result[1])\n            result[0], result[1] = li[i], result[0]\n        elif li[i].weight < result[1].weight:\n            if result[1].weight != float('inf'):\n                li2.append(result[1])\n            result[1] = li[i]\n        else:\n            li2.append(li[i])\n    return result, li2\n\ndef makeHuffman(source):\n    m2, data = min2(source)\n    print(m2[0].data, m2[1].data)\n    left = m2[0]\n    right = m2[1]\n\n    sumLR = left.weight + right.weight\n    father = BinaryTree(None, sumLR)\n    father.left = left\n    father.right = right\n    if data == []:\n        return father\n    data.append(father)\n    return makeHuffman(data)\n\n# 中序\ndef intermediateTraversal(now, result=[]):\n    if now == None:\n        return result\n    intermediateTraversal(now.left, result)\n    result.append(now.data)\n    intermediateTraversal(now.right, result)\n    return result\n\n# 后序\ndef postorderTraversal(now, result=[]):\n    if now == None:\n        return\n    postorderTraversal(now.left, result)\n    postorderTraversal(now.right, result)\n    result.append(now.data)\n    return result\n\n# 创建哈夫曼树\nsourceData = [BinaryTree(x[0], x[1]) for x in sourceData]\nm = makeHuffman(sourceData)\n# 中序\nprint(intermediateTraversal(makeHuffman(sourceData)))\n# 后序\nprint(postorderTraversal(makeHuffman(sourceData)))\n\n如果对你有帮助，可以点击我这个回答右上方的【采纳】按钮，给我个采纳吗，谢谢", "Konwledge_Point": "哈夫曼编码", "Question": "求解用python遍历哈夫曼编码（中序遍历、后序遍历）\n已知若干个字符的权重值为=[['a',15]，['b',3]，['c',14]，['d',2]，['e',6]，['f',9]，['g',16]，['h',17]]\n\n\n设计python程序，实现构造哈夫曼树，并采用中根序或后根序遍历方法，获取每个叶子节点的哈夫曼编码。", "Tag": "算法分析"}
{"Answer": "https://zhuanlan.zhihu.com/p/144562146\n这篇文章讲的很好，可以参考理解一下，不懂问我哟", "Konwledge_Point": "哈夫曼编码", "Question": "数据压缩编码中的哈夫曼编码方法是什么？\n数据压缩编码中的哈夫曼编码方法是什么？\n怎样进行操作？希望有 大_佬解救。", "Tag": "算法分析"}
{"Answer": "5 8 6 7 1 3 1 2 7 怎么变成树？", "Konwledge_Point": "哈夫曼编码", "Question": "关于数据压缩编码中的哈夫曼编码方法的问题\n数据压缩编码中的哈夫曼编码方法是什么？\n怎样进行操作？希望有 大_佬解救。", "Tag": "算法分析"}
{"Answer": "两处小错误，见修改注释，供参考：\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/* run this program using the console pauser or add your own getch, system(\"pause\") or input loop */\ntypedef struct {\n    int weight;\n    int parent, lchild, rchild;\n    int flag;\n}HTNode, * HuffmanTree;\ntypedef char** HuffmanCode;\nvoid Select(HuffmanTree HT, int end, int* s1, int* s2) {\n    int min = 1, i;\n    for (i = 1; i <= end; i++) {\n        if (HT[i].flag != 0) {\n            continue;\n        }\n        while (HT[min].flag != 0) {\n            min++;\n        }\n        if (HT[i].parent == 0 && HT[min].weight > HT[i].weight) {\n            min = i;\n        }\n    }\n    *s1 = min;\n    HT[min].flag = 1;\n    min = 1;\n    for (i = 1; i <= end; i++) {\n        if (HT[i].flag != 0) {\n            continue;\n        }\n        while (HT[min].flag != 0) {\n            min++;\n        }\n        if (HT[i].parent == 0 && HT[min].weight > HT[i].weight) {\n            min = i;\n        }\n    }\n    *s2 = min;\n    HT[min].flag = 1;\n}\nvoid CreateHuffmanTree(HuffmanTree* HT, int n) {\n    if (n <= 1) return;\n    int i, m = 2 * n - 1;\n    *HT = (HuffmanTree)malloc((m + 1) * sizeof(HTNode));\n    HuffmanTree p = *HT;\n    for (i = 1; i <= m; i++) {\n        p[i].parent = 0;\n        p[i].lchild = 0;\n        p[i].rchild = 0;\n        p[i].flag = 0;\n    }\n    for (i = 1; i <= n; i++) {\n        puts(\"输入权值：\");\n        scanf(\"%d\", &(p[i].weight));\n    }\n    int s1, s2;\n    for (i = n + 1; i <= m; i++) {\n        Select(*HT, i - 1, &s1, &s2);\n        p[s1].parent = p[s2].parent = i;\n        p[i].lchild = s1;\n        p[i].rchild = s2;\n        p[i].weight = p[s1].weight + p[s2].weight;\n    }\n}\nvoid CreateHuffmanCode(HuffmanTree HT, HuffmanCode* HC, int n) {\n    int i;\n    (*HC) = (HuffmanCode)malloc((n + 1) * sizeof(char*));\n    if (!(*HC))   printf(\"kong\");\n    char* cd = (char*)malloc(n * sizeof(char));\n    if (!cd)   printf(\"kong\");\n    cd[n - 1] = '\\0';\n    for (i = 1; i <= n; i++) {\n        int start = n - 1;\n        int c = i;\n        int f = HT[i].parent;\n        while (f != 0) {\n            --start;\n            if (HT[f].lchild == c) {\n                cd[start] = '0';\n            }\n            else {\n                cd[start] = '1';\n            }\n            c = f;\n            f = HT[f].parent;\n        }\n        //printf(\"%s\",cd);\n        (*HC)[i] = (char*)malloc((n - start) * sizeof(char));\n        if (!(*HC)[i]) printf(\"kong\");\n        strcpy((*HC)[i], cd + start);\n        printf(\"%s\", (*HC)[i]);//printf(\"%s\",HC[i]); 修改\n    }\n    puts(\"--\");\n    free(cd);\n}\nvoid printHuffmanTree(HuffmanTree HT, int n) {\n    puts(\"节点\\tweight\\tparent\\tlchild\\trchild\");\n    int i;\n    for (i = 1; i <= n; i++) {\n        printf(\"%d  \\t%d  \\t%d  \\t%d  \\t%d\\n\", i, \n            HT[i].weight, HT[i].parent, HT[i].lchild, HT[i].rchild);\n    }\n}\nint main(int argc, char* argv[]) {\n    HuffmanTree HT;\n    HuffmanCode HC;\n    CreateHuffmanTree(&HT, 8);\n    printHuffmanTree(HT, 15);\n    puts(\"哈夫曼树\");\n    CreateHuffmanCode(HT, &HC, 8);\n    int i;\n    for (i = 1; i <= 8; i++) { // for(i=0;i<=8;i++) 修改\n        printf(\"%s\", HC[i]);\n    }\n    return 0;\n}\n\n\n", "Konwledge_Point": "哈夫曼编码", "Question": "哈夫曼编码有些问题，循环和输出编码有问题\n问题遇到的现象和发生背景\n\n\n哈夫曼编码函数有些问题，输出哈夫曼编码有些问题\n\n\n用代码块功能插入代码，请勿粘贴截图\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n/* run this program using the console pauser or add your own getch, system(\"pause\") or input loop */\n\n\ntypedef\n \nstruct\n{\n    \nint\n weight;\n    \nint\n parent,lchild,rchild;\n    \nint\n flag;\n}HTNode,*HuffmanTree;\n\ntypedef\n \nchar\n** HuffmanCode;\n\n\n\nvoid\n \nSelect\n(HuffmanTree HT,\nint\n end,\nint\n *s1,\nint\n *s2)\n{\n    \nint\n min=\n1\n,i;\n    \nfor\n(i=\n1\n;i<=end;i++){\n        \nif\n(HT[i].flag!=\n0\n){\n            \ncontinue\n;\n        }\n        \nwhile\n(HT[min].flag!=\n0\n){\n            min++;\n        }\n        \nif\n(HT[i].parent==\n0\n&&HT[min].weight>HT[i].weight){\n                min=i;\n        }    \n    }\n    *s1=min;\n    HT[min].flag=\n1\n;\n    min=\n1\n;\n    \nfor\n(i=\n1\n;i<=end;i++){\n        \nif\n(HT[i].flag!=\n0\n){\n            \ncontinue\n;\n        }\n        \nwhile\n(HT[min].flag!=\n0\n){\n            min++;\n        }\n        \nif\n(HT[i].parent==\n0\n&&HT[min].weight>HT[i].weight){\n                min=i;\n        }\n    }\n    *s2=min;\n    HT[min].flag=\n1\n;\n}\n\n\nvoid\n \nCreateHuffmanTree\n(HuffmanTree *HT,\nint\n n)\n{\n    \nif\n(n<=\n1\n) \nreturn\n;\n    \nint\n i,m=\n2\n*n\n-1\n;\n    *HT=(HuffmanTree)\nmalloc\n((m+\n1\n)*\nsizeof\n(HTNode));\n    HuffmanTree p=*HT;\n    \nfor\n(i=\n1\n;i<=m;i++){\n        p[i].parent=\n0\n;\n        p[i].lchild=\n0\n;\n        p[i].rchild=\n0\n;\n        p[i].flag=\n0\n;\n    }\n    \nfor\n(i=\n1\n;i<=n;i++){\n        \nputs\n(\n\"输入权值：\"\n);\n        \nscanf\n(\n\"%d\"\n,&(p[i].weight));\n    }\n    \nint\n s1,s2;\n    \nfor\n(i=n+\n1\n;i<=m;i++){\n        \nSelect\n(*HT,i\n-1\n,&s1,&s2);\n        p[s1].parent=p[s2].parent=i;\n        p[i].lchild=s1;\n        p[i].rchild=s2;\n        p[i].weight=p[s1].weight+p[s2].weight;\n    }    \n}\n\n\nvoid\n \nCreateHuffmanCode\n(HuffmanTree HT,HuffmanCode *HC,\nint\n n)\n{\n    \nint\n i;\n    (*HC)=(HuffmanCode)\nmalloc\n((n+\n1\n)*\nsizeof\n(\nchar\n *));\n     \n    \nif\n(!(*HC)) \nprintf\n(\n\"kong\"\n);\n    \nchar\n *cd=(\nchar\n *)\nmalloc\n(n*\nsizeof\n(\nchar\n));\n    \nif\n(!cd) \nprintf\n(\n\"kong\"\n);\n    cd[n\n-1\n]=\n'\\0'\n;\n    \n    \nfor\n(i=\n1\n;i<=n;i++){\n        \nint\n start=n\n-1\n;\n        \nint\n c=i;\n        \nint\n f=HT[i].parent;\n        \n        \nwhile\n(f!=\n0\n){\n            --start;\n            \nif\n(HT[f].lchild==c){\n                cd[start]=\n'0'\n;\n            }\nelse\n{\n                cd[start]=\n'1'\n;\n            }\n            c=f;\n            f=HT[f].parent;\n        }\n        \n//printf(\"%s\",cd);\n\n        (*HC)[i]=(\nchar\n *)\nmalloc\n((n-start)*\nsizeof\n(\nchar\n));\n        \nif\n(!(*HC)[i]) \nprintf\n(\n\"kong\"\n);\n        \nstrcpy\n((*HC)[i],cd+start);\n        \nprintf\n(\n\"%s\"\n,HC[i]);\n    }\n    \nputs\n(\n\"--\"\n);\n    \nfree\n(cd);\n}\n\n\n\n\n\n\nvoid\n \nprintHuffmanTree\n(HuffmanTree HT,\nint\n n)\n{\n    \nputs\n(\n\"节点\\tweight\\tparent\\tlchild\\trchild\"\n);\n    \nint\n i;\n    \nfor\n(i=\n1\n;i<=n;i++){\n        \nprintf\n(\n\"%d  \\t%d  \\t%d  \\t%d  \\t%d\\n\"\n,i,HT[i].weight,HT[i].parent,HT[i].lchild,HT[i].rchild);\n    }\n    \n    \n}\n\n\n\nint\n \nmain\n(\nint\n argc, \nchar\n *argv[])\n \n{\n    HuffmanTree HT;\n    HuffmanCode HC;\n    \nCreateHuffmanTree\n(&HT,\n8\n);\n    \nprintHuffmanTree\n(HT,\n15\n);\n    \nputs\n(\n\"哈夫曼树\"\n);\n    \n    \nCreateHuffmanCode\n(HT,&HC,\n8\n);\n    \n    \nint\n i;\n     \nfor\n(i=\n0\n;i<=\n8\n;i++){\n         \nprintf\n(\n\"%s\"\n,HC[i]);\n     }\n    \nreturn\n \n0\n;\n}\n\n\n\n\n运行结果及报错内容\n\n\n\n\n\n\n\n\n@qzjhjxj ", "Tag": "算法分析"}
{"Answer": "\ntips:\n1，二进制文件读写（无法使用string)\n2，ASCII码和字符转换\n3，哈夫曼算法\n4，哈希思想的妙用（计算字频；编码使用） \n\n数据结构\ntypedef struct\n{\n\tint ascii,weight,parent,lchild,rchild;//哈夫曼树，它们依次表示：字符的ASCII码，双亲，左孩子，右孩子 \n}HTNode,*HuffmanTree;\n\n算法\n假设有n个字符，申请2n个空间，0号不用 ,HTree数组首地址 \n1，初始化1，所有成员赋0；初始化2，读入字符及相应的权值\n2，令下个根节点j = n+1,在parent=0的点中挑选出最小值，次小值分别记录其下标index1，index2；\n3，最小值和次小值的parent=j;  \n*/\n#include<iostream>\nusing namespace std;\n#include<stdlib.h> \n#include<fstream>\n#include<string>\n#include<stack>\n\n#define MIN1 0x1fffffff\n#define MIN2 0x2fffffff\n\n\n//Attention：只可以识别英文输入法下的所有字符，中文打出来的‘？’都不行 \nchar code[20];//二进制读写准备 \n\ntypedef struct\n{\n\tint ascii,weight,parent,lchild,rchild;//哈夫曼树，它们一次表示：字符的ASCII码，双亲，左孩子，右孩子 \n}HTNode,*HuffmanTree;\n\n//统计每个字符出现次数：只有英文符号，否则报错 \nvoid Count_Character_Occur_Frequency()\n{\n\tint cof[256];//存储相应字符出现的次数，字符ASCII为下标。charater_occur_frequency \n\tfor(int i = 0; i < 256; i++)//初始化字符出现次数统计表 \n\t{\n\t\tcof[i] = 0;\n\t}\n\t//从源文件按行读取，并统计字符个数，由于字符个数有限，所以用字符的ASCII码作为数组下标，数组值作为次数，类似哈希映射 \n\tfstream inFile(\"source.txt\",ios::in); \n\tif(!inFile)cout<<\"source.txt 打开失败！\"<<endl;\n\t\n\tint sum = 0;//总行数，记录换行个数 \n\tstring s;//存放一行 \n\twhile(true)\n\t{\n\t\tgetline(inFile,s);\n\t\tif(!inFile)break;//避免重复读取最后一个字符 \n\t\tsum++;\n\t\tfor(int i = 0; i < s.size(); i++)\n\t\t{\n\t\t\tint a = s[i];//cout<<\"a:\"<<a<<endl;中文会溢出 \n\t\t\tcof[a]++; //计数 \n\t\t}\n\t}\n\tinFile.close();//好习惯 \n\tint a = '\\n';//换行符 \n\tcof[a] = sum; //换行符个数 \n\t//=======将所有出现的字符及其次数写入文件（类似全局数组）========= \n\tint n = 0;//计算出现字符总个数 \n\tfor(int i = 0; i < 256; i++)\n\t{\n\t\tif(cof[i] != 0)n++; \n\t}\n\tfstream outFile(\"data.txt\",ios::out);\n\tif(!outFile)cout<<\"data.txt 打开失败！\"<<endl;\n\toutFile<<n<<endl;//写入字符总个数 \n\t//打印调试 \n\tfor(int i = 0; i < 256; i++)\n\t{\n\t\tif(cof[i] != 0)\n\t\t{\n\t\t\tchar ch = i - '\\0';\n\t//\t\tcout<<\"i: \"<<i<<\"  字符：\"<<ch<<\" cof[i]: \"<<cof[i]<<endl;\n\t\t\toutFile<<i<<\" \"<<cof[i]<<endl;//写入文件 \n\t\t}\n\t}\n\toutFile.close();\n}\n//创建哈夫曼树 \nvoid CreateHT()\n{\n\tHuffmanTree HTree;\n\tfstream inFile(\"data.txt\",ios::in);\n\tif(!inFile)cout<<\"data.txt 打开失败！\"<<endl;\n\t\n\tint n;//节点个数\n\tinFile>>n;\n\tHTree = (HTNode*)malloc(2*n*sizeof(HTNode));//哈夫曼构造，共需2n-1个，0号单元不用\n\tfor(int i = 1; i < 2*n; i++)//初始化 1\n\t{\n\t\tHTree[i].ascii = HTree[i].lchild = HTree[i].parent = HTree[i].rchild = HTree[i].weight = 0;//0号单元无用 \n\t} \n\tfor(int i = 1; i <= n; i++)//初始化 2，从文件读取ASCII码及相应权值 \n\t{\n\t\tinFile>>HTree[i].ascii>>HTree[i].weight;\n\t} \n\tinFile.close();\n/*\tfor(int i = 1; i < 2*n; i++)//打印输出调试 \n\t{\n\t\tcout<<HTree[i].ascii <<\" \"<<HTree[i].weight<<endl;\n\t} \n*/\t\n\tfor(int i = n+1; i < 2*n; i++)//从n+1开始，进行n-1次计算 \n\t{\n\t\t//寻找最小，次小值，记录其下标 \n\t\tint min1 = MIN1,min2 = MIN2;\n\t\tint index1 = 0,index2 = 0;\n\t\t\n\t\tfor(int j = 1; j < i; j++)//i是即将要被填入的根节点 \n\t\t{\n\t\t\tif(HTree[j].parent == 0)//双亲为0表示尚待操作 \n\t\t\t{\n\t\t\t\tif(min1 > HTree[j].weight)\n\t\t\t\t{\n\t\t\t\t\tmin2 = min1;//先赋给次小值 \n\t\t\t\t\tindex2 = index1;\n\t\t\t\t\tmin1 = HTree[j].weight;\n\t\t\t\t\tindex1 = j;\n\t\t\t\t}\n\t\t\t\telse if(min2 > HTree[j].weight)\n\t\t\t\t{\n\t\t\t\t\tmin2 = HTree[j].weight;\n\t\t\t\t\tindex2 = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}//cout<<index1<<\" \"<<index2<<endl; \n\t\t\n\t\tHTree[i].weight = HTree[index1].weight + HTree[index2].weight;//双亲权值更新 \n\t\tHTree[index1].parent = HTree[index2].parent = i;//孩子的双亲节点更新\n\t\tif(HTree[index1].weight < HTree[index2].weight)//1，两个节点权值不同，左小右大 ；相同，下标小者在左 \n\t\t{\n\t\t\tHTree[i].lchild = index1;//下标赋值 \n\t\t\tHTree[i].rchild = index2;\n\t\t}\n\t\telse if(HTree[index1].weight > HTree[index2].weight)\n\t\t{\n\t\t\tHTree[i].lchild = index2;\n\t\t\tHTree[i].rchild = index1;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tif(index1 < index2)\n\t\t\t{\n\t\t\t\tHTree[i].lchild = index1;\n\t\t\t\tHTree[i].rchild = index2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tHTree[i].lchild = index2;\n\t\t\t\tHTree[i].rchild = index1;\n\t\t\t}\n\t\t}\n\t} \n\tfstream outFile(\"result.txt\",ios::out);\n\tif(!outFile)cout<<\"result.txt 无法打开！\"<<endl;\n\toutFile<<n<<endl;//节点个数 \n\tfor(int i = 1; i < 2*n; i++)//打印输出调试 \n\t{\n//\t\tcout<<\"i:\"<<i<<\" ascii:\"<<HTree[i].ascii <<\" weight:\"<<HTree[i].weight<<\" parent:\"<<HTree[i].parent<<\" lchild:\"<<HTree[i].lchild<<\" rchild:\"<<HTree[i].rchild<<endl;\n\t\toutFile<<\" \"<<HTree[i].ascii <<\" \"<<HTree[i].weight<<\" \"<<HTree[i].parent<<\" \"<<HTree[i].lchild<<\" \"<<HTree[i].rchild<<endl;\t\n\t} \n\toutFile.close();\n\t\n\t//==========建立编码表，写入字符，权值，编码==================\n\toutFile.open(\"result.txt\",ios::out);\n\tif(!outFile)cout<<\"result.txt 打开失败！\"<<endl;\n\t//利用栈从叶子出发读取每个字符的编码，在写入文件 \n\tstack<char> code;//存储编码 \n\tfor(int i = 1; i <= n; i++)//对n个字符分别求编码 \n\t{\n\t\tint j = i;\n\t\tdo{\n\t\t\tint p = HTree[j].parent;\n\t\t\tif(p != 0)\n\t\t\t{\n\t\t\t\tint l,r;\n\t\t\t\tl = HTree[p].lchild;\n\t\t\t\tr = HTree[p].rchild;\n\t\t\t\tif(j == l)code.push('0');\n\t\t\t\tif(j == r)code.push('1');\n\t\t\t\tj = p;\n\t\t\t}\n\t\t}while(HTree[j].parent != 0);\n\t\t\n\t\toutFile<<HTree[i].ascii<<\" \"<<HTree[i].weight<<\" \";//写入字符，权值 \n\t\twhile(!code.empty())\n\t\t{\n\t\t\toutFile<<code.top();//写入编码 \n\t\t\tcode.pop();\n\t\t}outFile<<endl;\n\t} \n\toutFile.close();\n} \nvoid Encode()\n{\n\tfstream inFile(\"result.txt\",ios::in);\n\tif(!inFile)cout<< \"result.txt\"<<endl;\n\tstring s,codeList[256];//将编码表从文件读入该数组中，ASCII码为下标，类似哈希映射 \n\tint ch,w;\n\twhile(true)\n\t{\n\t\tinFile>>ch>>w>>s;\n\t\tif(!inFile)break;\n\t\tcodeList[ch] = s; \n\t}\n\tinFile.close();\n\t\n\tinFile.open(\"source.txt\",ios::in);\n\tif(!inFile)cout<<\"source.txt 打开失败！\"<<endl;\n\tfstream outFile(\"code.dat\",ios::out|ios::binary);\n\tif(!outFile)cout<<\"code.dat打开失败！\"<<endl;\n\tstring s2;\n\twhile(true)\n\t{\n\t\tgetline(inFile,s);\n\t\tif(!inFile)break;\n\t\tint a;\n\t\tfor(int i = 0; i < s.size(); i++)\n\t\t{\n\t\t\ta = s[i];//转化为ASCII码 \n\t\t\tint j; \n\t\t\tfor(j = 0; j < codeList[a].size();j++)\n\t\t\t{\t\n\t\t\t\ts2 = codeList[a];\n\t\t\t\tcode[j] = s2[j];\n\t\t\t}code[j]='\\0';//!!!关键的一句 \n\t\t\toutFile.write((char*)code,20*sizeof(char));\n\t\t}\n\t\ta = '\\n';\n\t\tfor(int j = 0; j < codeList[a].size();j++)\n\t\t{\n\t\t\tcode[j]  = (codeList[a])[j];\n\t\t}\n\t\toutFile.write((char*)code,20*sizeof(char));\n\t}\n\tinFile.close();\n\toutFile.close(); \n}\n//解码 \nvoid Decode()\n{\n\tfstream inFile(\"data.txt\",ios::in);\n\tif(!inFile)cout<<\"data.txt 打开失败！\"<<endl; \n\tint n;\n\tinFile>>n;\n\tHuffmanTree HTree;\n\tHTree = (HTNode*)malloc(2*n*sizeof(HTNode));\n\tfor(int i = 1; i < 2*n; i++)\n\t{\n\t\tinFile>>HTree[i].ascii >>HTree[i].weight>>HTree[i].parent>>HTree[i].lchild>>HTree[i].rchild;\t\n\t}\n\tinFile.close();\n\tfor(int i = 1; i < 2*n; i++)//打印输出调试 \n\t{\n\t//\tcout<<\"i:\"<<i<<\" ascii:\"<<HTree[i].ascii <<\" weight:\"<<HTree[i].weight<<\" parent:\"<<HTree[i].parent<<\" lchild:\"<<HTree[i].lchild<<\" rchild:\"<<HTree[i].rchild<<endl;\n\t} \n/*\tinFile.open(\"code.txt\",ios::in);\n\tif(!inFile)cout<<\"code.txt 打开失败！\"<<endl;\n*/\n\tinFile.open(\"code.dat\",ios::in|ios::binary);\n\tif(!inFile)cout<<\"code.dat 打开失败！\"<<endl;\n\t\n\tfstream outFile(\"recode.txt\",ios::out);\n\tif(!outFile)cout<<\"recode.txt 打开失败！\"<<endl;\n\tchar ch;\n\tint root = 2*n - 1;//char code[100];\n//\tstring s;\n\twhile(true)\n\t{\n\t\tinFile.read((char*)code,20*sizeof(char));\n\t\tif(!inFile)break;\n\t//\tcout<<\"ch: \"<<ch<<\" root: \"<<root<<endl;\t\n\t\tfor(int i = 0; code[i] != '\\0'; i++)\n\t\t{//cout<<ch;\n\t\t\tch = code[i];\n\t\t\tif(ch == '0')root = HTree[root].lchild;\n\t\telse if(ch == '1')root = HTree[root].rchild;\n\t\t\n\t\tif(HTree[root].lchild == 0)\n\t\t{//cout<<endl;\n\t\t\tchar cht = HTree[root].ascii;\n\t\t\toutFile<<cht;\n\t\t\troot = 2*n - 1;\n\t\t} \n\t\t\n\t\t}//cout<<endl;\n\t}\n\toutFile.close();\n}\nint main()\n{\n\tCount_Character_Occur_Frequency();\n\tCreateHT();\n\tEncode();\n\tDecode();\n\treturn 0;\n} \n\n ", "Konwledge_Point": "哈夫曼编码", "Question": "哈夫曼树的编码与解码\n综合训练2\t利用哈夫曼树进行编码与解码\n一、主要目的:\n理解哈夫曼树的概念、掌握哈夫曼树的建立以及利用利用哈夫曼树进行哈夫曼编码的方法。\n二、主要内容:\n在基于哈夫易树进行哈夫易编码的基础理论之上，完成对英文文竟的编码和解码，要求如下:\n1、使用文件流方式。\n自行查阅关于文件流的相关资料。\n2、要求提供编码和解码两种方式\n3、能够打开原文文件(dataxt)，统计其中英文字母(假设均为小写)出现的频率，并以此进行哈夫曼编码(空格以及其他字符不加处理)，将每个字母的哈夫曼编码输出到屏幕，并将编码后的结果输出到码文文件(code.xt)中。\n4、能够根据3中得到的字符编码，将码文文件中的码文进行解码，得到解码后的原文(result.txt)\n5、本综合训练以个人方式完成。\n\n上交方法:各班班长统一收齐发送给我。(只要 CPP 文件，不用 data.txt 文件。)命名格式:数学X班 xxx.cpp\n\n提示:\n(1)建立的哈夫曼树结点应添加保存字母的域\n(2)教材中求哈夫曼编码的算法为递归算法，每次在递归中输出所求编码，而我们需要在对原文编码时使用每个字母的哈夫曼编码，所以应该将递归中求得的字母编码保存下来，以备后用。保存方式自行考虑。\n(3)对原文进行编码时，根据读取到的每个字符进行处理:如果是字母，则往code.txt中输出相应编码(根据2中所得编码);如果是其它字符，则不加处理，直接输出到code.txt。(4)解码应在所建立的哈夫曼树基础上进行。依次读取code.txt 文件中字符，若为0或1.则0进左子树1进右子树，直到叶子结点然后取出叶子节点中的字母输出到result.txt:如果是其它字符，则不加处理，直接输出到result.txt。", "Tag": "算法分析"}
{"Answer": "```\r\n new char *[n + 1]返回的是char **\r\n  HuffmanTree *HT是HTNode**类型的\r\n\t两边类型不匹配的\r\n```\r\n不知道楼主到底是要干嘛？\r\n\r\n代码功能归根结底不是别人帮自己看或讲解或注释出来的；而是被自己静下心来花足够长的时间和精力亲自动手单步或设断点或对执行到某步获得的中间结果显示或写到日志文件中一步一步分析出来的。\r\n提醒：再牛×的老师也无法代替学生自己领悟和上厕所！\r\n单步调试和设断点调试（VS IDE中编译连接通过以后，按F10或F11键单步执行，按Shift+F11退出当前函数；在某行按F9设断点后按F5执行停在该断点处。）是程序员必须掌握的技能之一。", "Konwledge_Point": "哈夫曼编码", "Question": "霍夫曼编码的指针快要搞死我了\n还是在学数据结构。要写霍夫曼编码了。以下我就直接po全套代码\n\n\n\n\n\n\n #include\n#include\n#include\nusing namespace std;\n\ntypedef char **HuffmanCode;\ntypedef struct\n{\n    int weight;\n    int parent, lchild, rchild;\n}HTNode, *HuffmanTree;\n\nvoid InsertSearch(HuffmanTree &HT, int n)\n{\n    int i, j;\n    for (i = 2; i <=n ; ++i)\n    {\n        if (HT[i].weight < HT[i -1].weight)\n        {\n            HT[0] = HT[i];\n            HT[i] = HT[i - 1];\n            for (j = i - 2; HT[0].weight < HT[j].weight; --j)\n                HT[j + 1] = HT[j];\n            HT[j + 1] = HT[0];\n        }\n    }\n}\n\nvoid Select(HuffmanTree &HT, int area, int &s1, int &s2)\n{\n    int i, flag = 1;\n    for (i = 1; (i <= area) || (flag == 1); i++)\n    {\n        if (HT[i].parent = 0)\n        {\n            s1 = i;\n            s2 = i + 1;\n            flag = 0;\n        }\n        else continue;\n    }\n}\n\nvoid CreateHuffmanTree(HuffmanTree &HT, int n)\n{\n    int m, i, s1, s2;\n    if (n <= 1)\n        return;\n    m = 2 * n - 1;\n    HT = new HTNode[m + 1];\n    for (i = 1; i <= m; ++i)\n    {\n        HT[i].parent = 0; \n        HT[i].lchild = 0; \n        HT[i].rchild = 0;\n    }\n    for (i = 1; i <= n; ++i)\n        cin >> HT[i].weight;\n\n    InsertSearch(HT, n);\n\n    for (i = n + 1; i <= m; ++i)\n    {\n        Select(HT, i - 1, s1, s2);\n        HT[s1].parent = i; HT[s2].parent = i;\n        HT[i].lchild = s1; HT[i].rchild = s2;\n        HT[i].weight = HT[s1].weight + HT[s2].weight;\n    }\n}\n\nvoid CreateHuffmanCode(HuffmanTree HT, HuffmanCode &HC, int n)\n{\n    int i, c, start, f;\n    char *cd;\n    cd = new char[n];\n    cd[n - 1] = '\\0';\n    for (i = 1; i <= n; ++i)\n    {\n        start = n - 1;\n        c = i; f = HT[i].parent;\n        while (f != 0)\n        {\n            --start;\n            if (HT[f].lchild == 0)\n                cd[start] = '0';\n            else\n                cd[start] = '1';\n            c = f;\n            f = HT[f].parent;\n        }\n        HC[i] = new char[n - start];\n        strcpy_s(HC[i], 20, &cd[start]);\n    }\n    delete cd;\n}\n\n\nint main()\n{\n    int n;\n    cout << \"请输入 即将输入的叶子节点个数\" << endl;\n    cin >> n;\n    HuffmanTree *HT = new char *[n + 1];\n    HuffmanCode *HC = new char *[n + 1];\n    CreateHuffmanTree(*HT, n);\n    CreateHuffmanCode(*HT, *HC, n);\n}\n\n\n\n\n\n\n\n问题出在main函数构建HT 和 HC上。po图\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n救救我吧，快被指针搞死啦", "Tag": "算法分析"}
{"Answer": "我之前的C++ 版本，支持压缩视频https://gitee.com/wubindong/HuffmanTreeCodeApplication/tree/master，可以的话通过下", "Konwledge_Point": "哈夫曼编码", "Question": "二 实践2:哈夫曼编码\n\n\n\n ", "Tag": "算法分析"}
{"Answer": "输入节点那里有问题，有很多\\n缓存，解决不掉，x没有被赋值修这个bug确实费劲\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#define Max 100\ntypedef struct\n{\n    char ch;\n    int weight;\n    int lchild,rchild,parent;\n} HTNode;\ntypedef HTNode HT[Max];\nint n=0;\nvoid InitHFMT (HT T)//哈夫曼树初始化子函数\n{\n    int i;\n    printf(\"请输入结点个数：\");\n    scanf(\"%d\",&n);\n    for(i=0; i<2*n-1; i++)\n    {\n        T[i].weight=0;\n        T[i].lchild=-1;\n        T[i].rchild=-1;\n        T[i].parent=-1;\n    }\n}\nvoid InputWeight(HT T)//输入权值子函数\n{\n    int w,i;\n    char x[Max];\n    getchar();\n    for(i=0; i<n; i++)\n    {\n    \n        printf(\"输入第%d个结点:\",i+1);\n        //scanf(\"%c\",&x);\n        //printf(\"x:%c\",x);\n        //x=getchar();\n        //getchar();\n        //T[i].ch=x;\n        gets(x);\n        //T[i].ch[0]=x[0];\n       // strcpy(T[i].ch,x);\n        //printf(\"x:%s\",x);\n        //puts(x);\n        char t=x[0];\n        T[i].ch=t;\n        //puts(T[i].ch[0]);\n        //putchar(t);\n        //putchar(T[i].ch);\n    }\n    for(i=0; i<n; i++)\n    {\n        printf(\"输入第%d个权值:\",i+1);\n        scanf(\"%d\",&w);\n        getchar();\n        T[i].weight=w;\n    }\n}\nvoid SelectMin (HT T,int i,int *p1,int *p2)//选择两个结点中小的结点\n{\n    long min1=888888,min2=88888;\n    int j;\n    for(j=0; j<=i; j++)\n    {\n        if(T[j].parent==-1)\n        {\n            if(min1>T[j].weight)\n            {\n                min1=T[j].weight;\n                *p1=j;\n            }\n        }\n    }\n    for(j=0; j<=i; j++)\n    {\n        if(T[j].parent==-1)\n        {\n            if(min2>T[j].weight&&j!=(*p1))\n            {\n                min2=T[j].weight;\n                *p2=j;\n            }\n        }\n    }\n}\nvoid CreatHFMT(HT T)//构造哈夫曼树\n{\n    int i,p1,p2;\n    InitHFMT (T);\n    InputWeight(T);\n    for(i=n; i<2*n-1; i++)\n    {\n        SelectMin(T,i-1,&p1,&p2);\n        T[p1].parent=T[p2].parent=i;\n        T[i].lchild=p1;\n        T[i].rchild=p2;\n        T[i].weight=T[p1].weight+T[p2].weight;\n    }\n}\nvoid hfnode(HT T,int i)//哈夫曼编码函数\n{\n    int j;\n    j=T[i].parent;\n    if(T[j].rchild==i)\n        printf(\"1\");\n    else\n        printf(\"0\");\n    if(T[j].parent!=-1)\n        i=j,hfnode(T,i);\n}\nvoid huffmannode(HT T)//求哈夫曼编码\n{\n    int i,j,a;\n    printf(\"\\n输入的权值对应的哈夫曼编码\");\n    for(i=0; i<n; i++)\n    {\n        j=0;\n        a=i;\n        printf(\"\\n权值为%i的编码是:\",T[i].weight);\n        hfnode(T,i);\n        i=a;\n    }\n}\nvoid DeCode(HT T,int n)//解码\n{\n    int i;\n    char str[50];\n    int a=2*n-2;\n    //printf(\"n:%d\\n\",n);\n    printf(\"请输入需要译码的二进制:\\n\");\n    getchar();//清除缓冲区\n    gets(str);\n    printf(\"%c\",T[a].ch);\n    //printf(\"strlen(str):%d\\n\",strlen(str));\n    printf(\"译码结果为：\\n\");\n    for(i=0; i<strlen(str); i++)\n    {\n        //a=2*n-2;\n        if(str[i]=='0')\n        {\n            a=T[a].lchild;\n        }\n        else if(str[i]=='1')\n        {\n            a=T[a].rchild;\n        }\n\n        if(T[a].lchild==-1 && T[a].rchild==-1)\n        {\n            printf(\"%c\",T[a].ch);\n            a=2*n-2;\n        }\n    }\n    printf(\"\\n\");\n}\nvoid Menu()\n{\n    printf(\"◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆\\n\");\n    printf(\"*    ********哈夫曼编码/译码器********         *\\n\");\n    printf(\"*             1.创建哈夫曼树;                  *\\n\");\n    printf(\"*             2.进行哈夫曼编码;                *\\n\");\n    printf(\"*             3.进行哈夫曼译码;                *\\n\");\n    printf(\"*             4.退出;                          *\\n\");\n    printf(\"◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆\\n\");\n}\nint main()//主函数\n{\n    //int n;\n    //char A[100];\n    HT HT;\n    Menu();\n    while(1)\n    {\n        int choice;\n        printf(\"\\n请输入要进行的功能：\");\n        scanf(\"%d\",&choice);\n        switch(choice)\n        {\n        case 1:\n            CreatHFMT(HT);\n            break;\n        case 2:\n            huffmannode(HT);\n            break;\n        case 3:\n            DeCode(HT,n);\n            break;\n        case 4:\n            printf(\"退出成功！\\n\");\n            system(\"PAUSE\");\n            break;\n        default:\n            printf(\"输入失败！\\n\");\n            break;\n        }\n    }\n    printf(\"\\n \");\n}\n\n", "Konwledge_Point": "哈夫曼编码", "Question": "求解 急 为什么哈夫曼的译码出不了\n哈夫曼的译码出不来\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ndefine\n Max 100\n\n\ntypedef\n \nstruct\n\n{\n    \nchar\n ch;\n    \nint\n weight;\n    \nint\n lchild,rchild,parent;\n} HTNode;\n\n\ntypedef\n HTNode HT[Max];\n\nint\n n;\n\nvoid\n \nInitHFMT\n \n(HT T)\n//哈夫曼树初始化子函数 \n\n\n{\n    \nint\n i;\n    \nprintf\n(\n\"请输入结点个数：\"\n);\n    \nscanf\n(\n\"%d\"\n,&n);\n    \nfor\n(i=\n0\n;i<\n2\n*n\n-1\n;i++) \n    {\n        T[i].weight=\n0\n;\n        T[i].lchild=\n-1\n;\n        T[i].rchild=\n-1\n;\n        T[i].parent=\n-1\n;\n    }\n}\n\nvoid\n \nInputWeight\n(HT T)\n//输入权值子函数 \n\n\n{\n    \nint\n w,i;\n    \nchar\n x;\n    \nfor\n(i=\n0\n;iT[j].weight)\n         {\n             min1=T[j].weight;\n             *p1=j;\n         }\n        }\n    }\n    \nfor\n(j=\n0\n;j<=i;j++)\n    {\n        \nif\n(T[j].parent==\n-1\n)\n        {\n            \nif\n(min2>T[j].weight&&j!=(*p1))\n            {\n                min2=T[j].weight;\n                *p2=j;\n            }\n        }\n    }\n}\n\nvoid\n \nCreatHFMT\n(HT T)\n//构造哈夫曼树 \n\n\n{\n    \nint\n i,p1,p2;\n    \nInitHFMT\n (T);\n    \nInputWeight\n(T);\n    \nfor\n(i=n;i<\n2\n*n\n-1\n;i++)\n    {\n        \nSelectMin\n(T,i\n-1\n,&p1,&p2);\n        T[p1].parent=T[p2].parent=i;\n        T[i].lchild=p1;\n        T[i].rchild=p2;\n        T[i].weight=T[p1].weight+T[p2].weight;\n    }\n} \n\nvoid\n \nhfnode\n(HT T,\nint\n i)\n//哈夫曼编码函数 \n\n\n{\n    \nint\n j;\n    j=T[i].parent;\n    \nif\n(T[j].rchild==i)\n       \nprintf\n(\n\"1\"\n);\n    \nelse\n\n       \nprintf\n(\n\"0\"\n);\n    \nif\n(T[j].parent!=\n-1\n)\n       i=j,\nhfnode\n(T,i);\n}\n\nvoid\n \nhuffmannode\n(HT T)\n//求哈夫曼编码 \n\n\n{\n    \nint\n i,j,a;\n    \nprintf\n(\n\"\\n输入的权值对应的哈夫曼编码\"\n);\n    \nfor\n(i=\n0\n;i<n;i++)\n    {\n        j=\n0\n;\n        a=i;\n        \nprintf\n(\n\"\\n权值为%i的编码是:\"\n,T[i].weight);\n        \nhfnode\n(T,i);\n        i=a;\n     } \n}\n\n\nvoid\n \nDeCode\n(HT T,\nint\n n)\n//解码\n\n\n{\n    \nint\n i;\n    \nchar\n str[\n50\n];\n    \nint\n a=\n2\n*n\n-2\n;\n    \nprintf\n(\n\"请输入需要译码的二进制:\\n\"\n);\n    \ngetchar\n();\n//清除缓冲区 \n\n    \ngets\n(str);\n    \nprintf\n(\n\"译码结果为：\\n\"\n);\n    \nfor\n(i=\n0\n; i<\nstrlen\n(str);i++)\n    {\n        \nif\n(str[i]==\n'0'\n)\n        {\n                a=T[a].lchild;\n        }\n        \nelse\n \nif\n(str[i]==\n'1'\n)\n        {\n                a=T[a].rchild;\n        }\n        \nif\n(T[a].lchild==\n-1\n && T[a].rchild==\n-1\n)\n        {\n            \nprintf\n(\n\"%c\"\n,T[a].ch);\n            a=\n2\n*n\n-2\n;\n        }\n    } \n    \nprintf\n(\n\"\\n\"\n);\n}\n\nvoid\n \nMenu\n()\n\n    \n{\n    \nprintf\n(\n\"◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆\\n\"\n);\n    \nprintf\n(\n\"*    ********哈夫曼编码/译码器********         *\\n\"\n);\n    \nprintf\n(\n\"*             1.创建哈夫曼树;                  *\\n\"\n);\n    \nprintf\n(\n\"*             2.进行哈夫曼编码;                *\\n\"\n);\n    \nprintf\n(\n\"*             3.进行哈夫曼译码;                *\\n\"\n);\n    \nprintf\n(\n\"*             4.退出;                          *\\n\"\n);\n    \nprintf\n(\n\"◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆\\n\"\n);\n    }\n\nint\n \nmain\n()\n//主函数 \n\n\n{\n    \nint\n n;\n    \nchar\n A[\n100\n];\n    HT HT;\n    \nMenu\n();\n    \nwhile\n(\n1\n)\n    {\n        \nint\n choice;\n        \nprintf\n(\n\"\\n请输入要进行的功能：\"\n);\n            \nscanf\n(\n\"%d\"\n,&choice);\n            \nswitch\n(choice)\n            {\n                \ncase\n \n1\n:\n                    \nCreatHFMT\n(HT);\n                \nbreak\n;\n                \ncase\n \n2\n:\n                    \nhuffmannode\n(HT);\n                    \nbreak\n;\n                \ncase\n \n3\n:\n                    \nDeCode\n(HT,n);\n                    \nbreak\n;\n                \ncase\n \n4\n:\n                    \nprintf\n(\n\"退出成功！\\n\"\n);\n                    \nsystem\n(\n\"PAUSE\"\n);\n                    \nbreak\n; \n                \ndefault\n:\n                    \nprintf\n(\n\"输入失败！\\n\"\n);\n                    \nbreak\n;\n                    \n            }\n    }\n    \nprintf\n(\n\"\\n \"\n);\n}\n\n", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/xiaoting451292510/article/details/12559421", "Konwledge_Point": "哈夫曼编码", "Question": "哈夫曼树的编码链式存储怎么画，译码链式存储怎么画？\n哈夫曼树的编码存储怎么画，译码存储怎么画？像二叉树那样画的话那它的0,1序列标在哪里", "Tag": "算法分析"}
{"Answer": "这个属于数据的序列化和反序列化问题。在这里是对树的序列化和反序列化。\r\n最简单的方式莫过于在内存里以完全二叉树的空间存储哈夫曼树，然后文件里直接写入这块内存就好了。", "Konwledge_Point": "哈夫曼编码", "Question": "求教，哈夫曼树问题，感觉好难\n大佬们，哈夫曼编码的问题，编码完毕后，下次不初始化，怎么从文件中读出哈夫曼树？怎么打印哈夫曼树？", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/hold_twenty/article/details/95602451", "Konwledge_Point": "哈夫曼编码", "Question": "哈夫曼算法应用(数据结构)\n求大神解答\n哈夫曼算法的应用\n1.问题描述\n假设某文本文档只包含26个英文字母，应用哈夫曼算法对该文档进行压缩和解压缩操作，使得该文档占用较少的存储空间。\n2.基本要求\n(1)假设文档内容从键盘输入；\n(2)设计哈夫曼算法的存储结构；\n(3)设计哈夫曼编码和解码算法；\n(4)分析时间复杂度和空间复杂度。\n3.设计思想\n对于给定的文档，首先通过扫描确定文档中出现了哪些英文字母以及出现的次数，以出现的次数作为叶子结点的权值构造哈夫曼树，获得各字符的哈夫曼编码；然后再扫描一遍文档将其进行哈夫曼压缩编码，将文本文档转换为二进制编码输出；最后将该二进制流进行解码，并与原文档进行对照，以验证算法的正确性。哈夫曼算法的存储结构以及哈夫曼算法请参见主教材5.7.1节。\n【思考题】如果对任意以文件形式存在的文本文档，如何实现应用哈夫曼算法进行压缩和解压缩？", "Tag": "算法分析"}
