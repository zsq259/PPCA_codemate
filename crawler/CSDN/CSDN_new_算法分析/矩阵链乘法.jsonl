{"Answer": "https://blog.csdn.net/qq_42334072/article/details/106769534可以看一下这个链接最后的代码修正，加上了LAST信号，应该可以重复发送", "Konwledge_Point": "矩阵链乘法", "Question": "PYNQ矩阵乘法IP核不能重复调用\n问题遇到的现象和发生背景\n\n\n矩阵乘法IP核不能重复调用\n\n\n问题相关代码，请勿粘贴截图\n\n\n问题采用的矩阵乘法IP核如下\n\n      \n        \n基于PYNQ-Z2开发板实现矩阵乘法加速详细流程_谦豫-CSDN博客_hwh文件\n\n        \n      \n基于PYNQ-Z2开发板实现矩阵乘法加速主要内容1、在Vivado HLS中生成矩阵乘法加速的IP核。2、在Vivado中完成Block Design。3、在Jupyter Notebook上完成IP的调用。完整项目工程文件下载链接见文末所需硬件PYNQ-Z2开发板、USB数据线、网线SD卡、读卡器开发板配置参考链接1、Vivado HLS生成矩阵乘法加速IPHLS硬件配置信息mul.h关键代码#define MAT_A_ROWS 32#define MAT_A_COLS \n\n      \n\n      \n\n        \n\n          \nhttps://blog.csdn.net/qq_42334072/article/details/106769534\n\n        \n\n      \n调用过程如下\n\n\n运行结果及报错内容\n\n\n如果只是重复最后三行transfer代码，会报错显示channel not open。如果全部重复，overlay那一行太过耗时。\n\n\n我想要达到的结果\n\n\n在不重复overlay那一行代码的同时，重复进行矩阵乘法运算", "Tag": "算法分析"}
{"Answer": "如有帮助，请采纳。点击我回答右上角【采纳】按钮。\n\n#include<iostream>\nusing namespace std;\ntypedef  int  ElemType ;\n#define M 4  //稀疏矩阵行数\n#define N 4  //稀疏矩阵列数\n#define MaxSize  6  //非零元素最多个数\n//三元组类型定义\ntypedef struct\n{\n\tint r;         //行号  \n\tint c;          //列号  \n\tElemType d;     //元素值  \n} TupNode;         //三元组定义  \ntypedef struct\n{\n\tint rows;      //行数  \n\tint cols;     //列数  \n\tint nums;       //非零元素个数  \n\tTupNode data[MaxSize];\n} TSMatrix;    //三元组顺序表定义  \n//十字链表类型定义\ntypedef struct mtxn\n{\n\tint row;   //行号\n\tint col;    //列号\n\tstruct mtxn *right, *down;  //向右和向下的指针\n\tunion\n\t{\n\t\tElemType value;   //非零元素值\n\t\tstruct mtxn *link;  //指向下一个头结点\n\t}tag;\n}MatNode;\n\n\n//三元组创建\nvoid Create_1(TSMatrix &t, ElemType A[M][N])\n{\n\tint i, j;\n\tt.rows = M;\n\tt.cols = N;\n\tt.nums = 0;\n\tfor (i = 0; i < M; i++)\n\t{\n\t\tfor (j = 0; j < N; j++)\n\t\t{\n\t\t\tif (A[i][j] != 0)    //元素值不为零，建立三元组\n\t\t\t{\n\t\t\t\tt.data[t.nums].r = i;\n\t\t\t\tt.data[t.nums].c = j;\n\t\t\t\tt.data[t.nums].d = A[i][j];\n\t\t\t\tt.nums++;\n\t\t\t}\n\t\t}\n\t}\n}\n//十字链表创建\nvoid Create_2(MatNode *&mh, ElemType a[M][N])\n{\n\tint i, j;\n\tMatNode *h[MaxSize], *p, *q, *r;\n\tmh = (MatNode *)malloc(sizeof(MatNode));   //创建十字链表的头节点\n\tmh->row = M;\n\tmh->col = N;\n\tr = mh;   //r指向尾节点\n\tfor (i = 0; i < MaxSize; i++)   //采用尾插法创建循环表\n\t{\n\t\th[i] = (MatNode *)malloc(sizeof(MatNode));\n\t\th[i]->down = h[i]->right = h[i];\t//将down和right方向量置为循环的\n\t\tr->tag.link = h[i];  //将h[i]加到链表中\n\t\tr = h[i];\n\t}\n\tr->tag.link = mh;   //置为循环链表\n\n\n\tfor (i = 0; i < M; i++)    //处理每一行\n\t{\n\t\tfor (j = 0; j < N; j++)    //处理每一列\n\t\t{\n\t\t\tif (a[i][j] != 0)   //处理非零元素\n\t\t\t{\n\t\t\t\tp = (MatNode *)malloc(sizeof(MatNode));\t  //创建一个新节点\n\t\t\t\tp->row = i;\n\t\t\t\tp->col = j;\n\t\t\t\tp->tag.value = a[i][j];\n\t\t\t\tq = h[i];   //查找在行表中插入位置\n\t\t\t\twhile (q->right != h[i] && q->right->col < j)\n\t\t\t\t{\n\t\t\t\t\tq = q->right;\n\t\t\t\t}\n\t\t\t\tp->right = q->right;\n\t\t\t\tq->right = p;\t\t\t//完成行表的操作\n\t\t\t\tq = h[j];      //查找在链表中插入的位置\n\n\t\t\t\twhile (q->down != h[j] && q->down->row < i)\n\t\t\t\t{\n\t\t\t\t\tq = q->down;\n\t\t\t\t}\n\t\t\t\tp->down = q->down;\n\t\t\t\tq->down = p;\t\t\t//完成列表的插入\n\t\t\t}\n\t\t}\n\n\t}\n}\n\n\n//输出三元组矩阵 \nvoid  DispMat_1(TSMatrix t)\n{\n\tint k;\n\tif (t.nums <= 0)\n\t{\n\t\treturn ;\n\t}\n\tcout << t.rows << \"\\t\" << t.cols << \"\\t\" << t.nums << endl;\n\tcout << \"=====================\" << endl;\n\tcout << \"行数\" << \" \" << \" 列数\" << \" \" << \"非零元素\" << endl;\n\tfor (k = 0; k < t.nums; k++)\n\t{\n\t\tcout << t.data[k].r << '\\t' << t.data[k].c << '\\t' << t.data[k].d << endl;\n\t}\n}\n//输出十字链表矩阵\nvoid DispMat_2(MatNode *mh)\n{\n\tMatNode *p, *q;\n\tcout << \"行=\" << mh->row << \"列=\" << mh->col << endl;\n\tp = mh->tag.link;\n\twhile (p != mh)\n\t{\n\t\tq = p->right;\n\t\twhile (p != q)\t\t\t\t//输出一行非零元素\n\t\t{\n\t\t\tcout << q->row << '\\t' << q->col << '\\t' << q->tag.value << endl;\n\t\t\tq = q->right;\n\t\t}\n\t\tp = p->tag.link;\n\t}\n\n}\n\n\n//三元组元素赋值  \nbool Value(TSMatrix &t, ElemType x, int i, int j)\n{\n\tint k = 0, k1;\n\tif (i >= t.rows || j >= t.cols)\n\t\treturn false;\n\twhile (k<t.nums && i>t.data[k].r)\n\t\tk++;      //查找行  \n\twhile (k<t.nums && i == t.data[k].r && j>t.data[k].c)\n\t\tk++;     //查找列  \n\tif (t.data[k].r == i && t.data[k].c == j)   //存在这样的元素  \n\t\tt.data[k].d = x;\n\telse               //不存在这样的元素时插入一个元素  \n\t{\n\t\tfor (k1 = t.nums - 1; k1 >= k; k1--)\n\t\t{\n\t\t\tt.data[k1 + 1].r = t.data[k1].r;\n\t\t\tt.data[k1 + 1].c = t.data[k1].c;\n\t\t\tt.data[k1 + 1].d = t.data[k1].d;\n\t\t}\n\t\tt.data[k].r = i;\n\t\tt.data[k].c = j;\n\t\tt.data[k].d = x;\n\t\tt.nums++;\n\t}\n\treturn true;\n}\n//将指定位置的元素值赋给变量 \nbool Assign(TSMatrix t, ElemType &x, int i, int j)\n{\n\tint k = 0;\n\tif (i >= t.rows || j >= t.cols)\n\t\treturn false;\n\twhile (k<t.nums && i>t.data[k].r)\n\t\tk++;    //查找行  \n\twhile (k<t.nums && i == t.data[k].r && j>t.data[k].c)\n\t\tk++;  //查找列  \n\tif (t.data[k].r == i && t.data[k].c == j)\n\t\tx = t.data[k].d;\n\telse\n\t\tx = 0;         //在三元组中没有找到表示是零元素  \n\treturn true;\n}\n\n\n//三元组下矩阵转置 \nvoid TranTat_1(TSMatrix t, TSMatrix &tb)\n{\n\tint k, k1 = 0, v;\t\t//k1记录tb中的元素个数\n\ttb.rows = t.rows;\n\ttb.cols = t.cols;\n\ttb.nums = t.nums;\n\tif (t.nums != 0)\t//当存在非零元素时执行转置\n\t{\n\t\tfor (v = 0; v < t.cols; v++)\n\t\t{\n\t\t\tfor (k = 0; k < t.nums; k++)\t\t//k用于扫描t.data的所有元素\n\t\t\t{\n\t\t\t\tif (t.data[k].c == v)\t\t//找到一个列号为v的元素\n\t\t\t\t{\n\t\t\t\t\ttb.data[k].r = t.data[k].c;\t\t//将行列交换后添加到tb中\n\t\t\t\t\ttb.data[k].c = t.data[k].r;\n\t\t\t\t\ttb.data[k].d = t.data[k].d;\n\t\t\t\t\tk1++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n//十字链表下矩阵转置 \nvoid TranTat_2(ElemType a[M][N], ElemType c[M][N])\n{\n\tint i,j;\n\tfor (i = 0; i < M; i++)\n\t{\n\t\tfor (j = 0; j < N; j++)\n\t\t\tc[j][i] = a[i][j];\n\t}\n\n}\n\n\n//三元组下矩阵相加 \nbool  AddMat_1(TSMatrix a, TSMatrix b, TSMatrix &c)\n{\n\tint i, j;\n\tElemType x, y, z;\n\tif (a.rows != b.rows || a.cols != b.cols)\n\t\treturn false;            //行数或列数不等时不能相加\n\tc.rows = a.rows;\n\tc.cols = a.cols;       //c的行列数与a的相同  \n\tc.nums = 0;\n\tfor (i = 0; i<M; i++)\n\t\tfor (j = 0; j<N; j++)\n\t\t{\n\t\t\tAssign(a, x, i, j);\n\t\t\tAssign(b, y, i, j);\n\t\t\tz = x + y;\n\t\t\tif (z!=0)\n\t\t\t\tValue(c, z, i, j);\n\t\t}\n\treturn true;\n}\n//十字链表下矩阵相加 \nvoid AddMat_2(ElemType a[M][N], ElemType b[M][N], ElemType c[M][N])\n{\n\tint i;\n\tint j;\n\tfor (i = 0; i < M; i++)\n\t{\n\t\tfor (j = 0; j < N; j++)\n\t\t{\n\t\t\tc[i][j] = a[i][j] + b[i][j];\n\t\t}\n\t}\n}\n\n\n//三元组下矩阵相乘 \nbool  MulMat_1(TSMatrix a, TSMatrix b, TSMatrix &c)\n{\n\tint i, j;\n\tElemType x, y, z;\n\tif (a.rows != b.rows || a.cols != b.cols)\n\t\treturn false;            //行数或列数不等时不能相乘\n\tc.rows = a.rows;\n\tc.cols = a.cols;       //c的行列数与a的相同  \n\tc.nums = 0;\n\tfor (i = 0; i<M; i++)\n\t\tfor (j = 0; j<N; j++)\n\t\t{\n\t\t\tAssign(a, x, i, j);\n\t\t\tAssign(b, y, i, j);\n\t\t\tz = x * y;\n\t\t\tif (z)\n\t\t\t\tValue(c, z, i, j);\n\t\t}\n\treturn true;\n}\n//十字链表下矩阵相乘 \nvoid  MulMat_2(ElemType a[M][N], ElemType b[M][N], ElemType c[M][N])\n{\n\tint i;\n\tint j;\n\tint k;\n\tint temp;\n\tfor (i = 0; i < M; i++)\n\t{\n\t\tfor (j = 0; j < N; j++)\n\t\t{\n\t\t\ttemp = 0;\n\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\ttemp = temp + a[i][k] * b[k][j];\n\t\t\t}\n\t\t\tc[i][j] = temp;\n\t\t}\n\n\t}\n}\n\n\n//主函数实现\nint main()\n{\n\tTSMatrix ta, tb, tc;\n\n\tMatNode *td,*tf;\n\n\tint x,y,z;\n\n\tElemType a[M][N] = { 1, 0, 3, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1 };\n\tElemType b[M][N] = { 3, 0, 0, 0, 0, 4, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2 };\n\tElemType c[M][N] = { 0 };\n\n\twhile (1)\n\t{\n\t\tcout << \"提示：输入1----是三元组下的矩阵运算\" << endl;\n\t\tcout << \"      输入2----是十字链表下的矩阵运算\" << endl;\n\t\tcout << \"      输入3----退出\" << endl;\n\t\tcout << \"请输入：\";\n\t\tcin >> x;\n\t\tswitch (x)\n\t\t{\n\t\tcase 1:\n\t\t\tcout << \"提示：输入1----三元组下矩阵的转置运算\" << endl;\n\t\t\tcout << \"      输入2----三元组下矩阵的相加运算\" << endl;\n\t\t\tcout << \"      输入3----三元组下矩阵的相乘运算\" << endl;\n\t\t\tcout << \"请输入：\";\n\t\t\tcin >> y;\n\t\t\tswitch (y)\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\tCreate_1(ta, a);\n\t\t\t\tcout << \"输出三元组下矩阵a：\" << endl;\n\t\t\t\tDispMat_1(ta);\n\t\t\t\tcout << \"三元组下矩阵a转置：\" << endl;\n\t\t\t\tTranTat_1(ta, tc);\n\t\t\t\tDispMat_1(tc);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tCreate_1(ta, a);\n\t\t\t\tCreate_1(tb, b);\n\t\t\t\tcout << \"三元组下矩阵a,b相加：\" << endl;\n\t\t\t\tAddMat_1(ta, tb, tc);\n\t\t\t\tDispMat_1(tc);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tCreate_1(ta, a);\n\t\t\t\tCreate_1(tb, b);\n\t\t\t\tcout << \"三元组下矩阵a,b相乘：\" << endl;\n\t\t\t\tMulMat_1(ta, tb, tc);\n\t\t\t\tDispMat_1(tc);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcout << \"提示：输入1----十字链表下矩阵的转置运算\" << endl;\n\t\t\tcout << \"      输入2----十字链表下矩阵的相加运算\" << endl;\n\t\t\tcout << \"      输入3----十字链表下矩阵的相乘运算\" << endl;\n\t\t\tcout << \"请输入：\";\n\t\t\tcin >> z;\n\t\t\tswitch (z)\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\tCreate_2(td,a);\n\t\t\t\tcout << \"输出十字链表下矩阵a：\" << endl;\n\t\t\t\tDispMat_2(td);\n\t\t\t\tcout << \"十字链表下矩阵a转置：\" << endl;\n\t\t\t\tTranTat_2(a, c);\n\t\t\t\tCreate_2(tf, c);\n\t\t\t\tDispMat_2(tf);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tcout << \"十字链表下矩阵a,b相加：\" << endl;\n\t\t\t\tAddMat_2(a, b, c);\n\t\t\t\tCreate_2(tf, c);\n\t\t\t\tDispMat_2(tf);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tcout << \"十字链表下矩阵a,b相乘：\" << endl;\n\t\t\t\tMulMat_2(a, b, c);\n\t\t\t\tCreate_2(tf, c);\n\t\t\t\tDispMat_2(tf);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 3: break; \n\t\t}\n\t}\n\tcout << endl;\n\tsystem(\"pause\");\n}\n\n\n ", "Konwledge_Point": "矩阵链乘法", "Question": "怎么用c语言实现一下稀疏矩阵操作?\n要求用C语言编写\n\n实现三元组，十字链表下的稀疏矩阵的加、转、乘的实现。\n\n（1）稀疏矩阵的存储\n\n（2）稀疏矩阵加法\n\n（3）矩阵乘法\n\n（4）矩阵转置\n\n\n\n求各位大神指点！！！求源代码，最好有注释\n\n\n\n ", "Tag": "算法分析"}
