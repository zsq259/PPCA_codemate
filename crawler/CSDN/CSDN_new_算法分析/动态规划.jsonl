{"Answer": "动态规划和递归毫无关系，事实上也没有“递归优化”这种说法。\r\n动态规划的思想是将要解决的问题转化为一系列逐步求解的问题并且逐步加以解决。动态规划避免了无意义的穷举，它强调逐步解决问题，让先前解决的结果可以作为后续解决问题的条件避免重复求解相同的问题。\r\n举一个例子，最长公共子序列问题（我曾经解答过，完整代码在这里：http://ask.csdn.net/questions/237208），传统的穷举是那第一个字符串的任意子序列去匹配第二个的任何子序列，比如说比较abc和bcd，abc的所有子串是\r\na\r\nb\r\nc\r\nab\r\nbc\r\nabc\r\n而bcd是\r\nb\r\nc\r\nd\r\nbc\r\ncd\r\nbcd\r\n然后再把它们两两比较，找到b c bc，最后找到最长的bc。这是无意义的穷举。\r\n用动态规划，我们将它们转化为后缀数组，然后排序\r\na\r\nab\r\nabc\r\nb\r\nb-2\r\nbc\r\nbc-2\r\nbcd-2\r\nc-2\r\ncd-2\r\nd-2\r\n注意，因为C语言可以用首地址+长度表示一个字符串，实际上我们并不需要穷举就能得到子串\r\n我们把子串排列起来，自然相邻的字符串才能匹配上。所以只要比较相邻的就可以了。\r\n为什么第二个方法要比第一个方法好，因为第一个方法做了很多重复的事情，如果a和b匹配不上，它和c更匹配不上，但是显然在没有序的集合里匹配，它就是在做重复工作。\r\n\r\n动态规划的过程中局部、整体等都可以采用递归，也可以不用。比如如上算法，其中排序的环节，你就可以用快速排序，它就是一个递归分治的过程。", "Konwledge_Point": "动态规划", "Question": "动态规划与递归联系。\n求教各位，以前一直觉得动态规划就是对递归的优化，最近发现并不是。我想请问各位动态规划和递归之间有什么联系吗？还是说动态规划和递归没关系。", "Tag": "算法分析"}
{"Answer": "点击链接加入群聊【python技术部落窝】：https://jq.qq.com/?_wv=1027&k=58leovM", "Konwledge_Point": "动态规划", "Question": "多维资源分配 动态规划  python的代码\n如题，在写论文，求一个多维资源分配 动态规划的python代码，跪求。", "Tag": "算法分析"}
{"Answer": "强化学习中的动态规划和最优控制中的动态规划基本上是相同的概念，两者都是指一类基于值函数、策略等概念的动态规划算法，用于求解最优策略或最优值函数等问题。两者的区别可能在于应用领域和侧重点略有不同，强化学习中的动态规划更多地关注智能体与环境的交互过程，如何通过智能体的决策和环境的反馈来优化策略或值函数等，而最优控制中的动态规划更多地关注系统控制领域，如何通过控制系统的决策和系统反馈来实现优化控制。 关于自适应动态规划的入门，建议首先了解动态规划中的基本概念、算法思路和应用场景等。在学习过程中可以通过参考相关教材、论文和网络课程等途径获取相关知识。以下是入门自适应动态规划时的一些建议： 了解基本概念和算法：包括状态空间、值函数、策略、贝尔曼等基本概念，以及动态规划算法中的策略迭代、值迭代等核心思想和数学工具。 学习自适应动态规划的基本原理和方法：包括自适应系统的基本概念和特点，自适应动态规划中的自适应控制参数、学习率、自适应规划等问题。 理解自适应动态规划在实际应用中的优势和局限：例如在控制系统优化、自主机器人、智能交通等领域中的应用案例和实验结果。 尝试实践和扩展自适应动态规划算法：可以从案例出发，学习基于自适应动态规划算法的控制系统或机器人等系统，通过对算法的本质及应用实例的深入理解，进而深入分析和尝试扩展自适应动态规划算法。同时建议积累相关的编程和数据分析技能，例如 Python 编程和数据可视化等。 值得一提的是，自适应动态规划是一类比较复杂和高级的动态规划算法，需要具备一定的数学建模和数据分析基础，同时也需要花费较多", "Konwledge_Point": "动态规划", "Question": "强化学习里的动态规划和最优控制里的动态规划有区别吗？\n强化学习里的动态规划和最优控制里的动态规划有区别吗？，\n\n\n\n学习自适应动态规划如何入门呢？", "Tag": "算法分析"}
{"Answer": "\n#include<stdio.h>\nvoid strcpy(int *a, int *b, int Y){\n    for(int i=0;i<=Y;i++) *(a+i) = *(b+i);\n}\nvoid solve(){\n        int n; scanf(\"%d\",&n);\n        int type[n], weight[n], Y, i, j, k;\n        for(i=0;i<n;i++) scanf(\"%d\",&type[i]);\n        for(i=0;i<n;i++) scanf(\"%d\",&weight[i]);\n        scanf(\"%d\",&Y);\n        int Min[Y+1], Min_Path[Y+1], path[n][Y+1];\n        for(i=0;i<=Y;i++) Min[i] = 9999;\n        Min[0] = 0;\n        printf(\"\\n\");\n        for(j=0;j<n;j++){\n            for(i=type[j]; i<=Y; i++)\n                if(Min[i] > Min[i-type[j]]+weight[j]){\n                    Min_Path[i] = type[j];\n                    Min[i] = Min[i-type[j]]+weight[j];\n                }\n            for(k=1;k<=Y;k++) printf(\"%-3d\",Min[k]);\n            printf(\"\\n\");\n            strcpy(path[j],Min_Path,Y);\n        }\n\n        printf(\"\\n\");\n        for(i=0;i<n;i++){\n            for(j=1;j<=Y;j++)\n                printf(\"%-3d\",path[i][j]);\n            printf(\"\\n\");\n        }\n\n        int y=Y;\n        printf(\"\\n支付方式:\");\n        while (y){\n            printf(\"%d \",Min_Path[y]);\n            y -= Min_Path[y];\n        }\n        printf(\"\\n总重量:%d\\n\",Min[Y]);\n}\nint main(){\n    solve();\n    return 1;\n}\n/*\n4\n1 4 6 8\n1 3 2 6\n12\n */\n\n ", "Konwledge_Point": "动态规划", "Question": "动态规划-硬币重量最轻问题\n    设有n种不同面值的硬币，第i种硬币的币值是Vi(其中V1=1),重量是Wi,i=1,2，...n且现在购买某种总币值为y的商品，需要用这些硬币付款，如果每种钱币使用的个数不限，那么如何选择付款的方法使得付出钱币的总重量最轻？使用动态规划设计策略设计一个求解该问题的算法。假设问题的输入实例是：\n\n\n\n     V1=1， V2=4， V3=6， V4=8\n\n\n\n     W1=1， W2=2，W3=4，W4=6\n\n\n\n     Y=12\n\n\n\n要求输出优化函数表和标记函数表、以及硬币支付方式。\n\n\n\n最好用C语言", "Tag": "算法分析"}
{"Answer": "理解图", "Konwledge_Point": "动态规划", "Question": "动态规划c++编程题：铺砖\n我好像见过类似的题，但只有一种砖，这有两种砖；\n求思路即可；（毕竟动归一般只需要一个状态转移方程吧？）\n\n", "Tag": "算法分析"}
{"Answer": "#include<bits/stdc++.h>using namespace std;const int MAX_N = 10010;int Num[MAX_N][2];\nint Sum[MAX_N][MAX_N];int N, X;int main(){    cin >> N >> X;    for (int i = 1; i <= N; i++)    {        cin >> Num[i][0] >> Num[i][1];    }    Sum[0][0] = 1;    for (int i = 1; i <= N; i++)    {        for (int j = 0; j <= X; j++)        {            if (Sum[i - 1][j])            {                Sum[i][j + Num[i][0]] = Sum[i][j + Num[i][1]] = 1;            }        }    }    if (Sum[N][X]==1)    {        cout << \"Yes\" << endl;    }    else    {        cout << \"No\" << endl;    }}", "Konwledge_Point": "动态规划", "Question": "动态规划跳跃问题c++\n（用动态规划，c++实现）\n小明在数轴上的坐标 0 处。现在小明将进行N次跳跃。第i次朝数轴正方向跳ai或bi个单位。请你判断跳N次以后他能否停留在坐标X\n\n\n输入描述\n\n\n第一行输入N和X，接下来N行输入ai和bi，其中\n1≤i≤N\n1≤ai,bi≤100\n1≤X≤10000\n\n\n输出描述\n\n\n如果能在 N 次跳跃后到达位置 X，则输出 Yes，否则输出 No。\n\n\n用例输入 \n\n\n2 10\n3 6\n4 5\n\n\n用例输出 \n\n\nYes", "Tag": "算法分析"}
{"Answer": "动态规划严格说不是算法，而是思路。就是求出一个中间的结果，再用它作为下次求解的条件，从而避免重复的运算（相比较穷举和遍历），提高性能。\r\n动态规划不一定是递归的，反之也不一定。", "Konwledge_Point": "动态规划", "Question": "一个大一小白，想问动态规划是干嘛的\nC语言老师给了好多个课题让我们自己去学然后上讲台讲给同听。我负责动态规划，但不知道动态规划是干嘛的，知道涉及到递归", "Tag": "算法分析"}
{"Answer": "报错\n原因在于你没开启C++11，如果是DEV这里可以开启：\n\n如果不是dev，那么就去百度一下你的IDE如何开启C++11\n开启后就没有error了，只有warning\n", "Konwledge_Point": "动态规划", "Question": "#动态规划#的问题，如何解决？\n动态规划\n\n\n\n#include\n#include\n\nusing namespace std;\nconst int \nN\n=\n11\n,\nM\n=\n28\n,inf=\n0x3f3f3f\n,\nDay\n=\n30\n;\nint dp[\n32\n][\nN\n+\n1\n][\n405\n][\n605\n],zd,qd,\nFZ\n;\nint cost_water,cost_food,walk,dig,buy;\nint xh_water[\n3\n]= {\n5\n,\n8\n,\n10\n},xh_food[\n3\n]= {\n7\n,\n6\n,\n10\n};//不同天气条件基础消耗\nbool cz[\nN\n+\n1\n],ks[\nN\n+\n1\n];\n\nstruct node\n{\n    short day; // 天数\n    short from; // 持续天数\n    int water,food;\n    int money;\n    bool operator!=(const node &x)\n    {\n        return x.day!=day || x.from!=from || x.water!=water || x.food!=food ;\n    };\n} path[\n31\n][\nN\n+\n1\n][\n405\n][\n605\n],lastpath;\nint  weather[\n31\n]=\n    {\n-1\n,\n1\n,\n1\n,\n0\n,\n2\n,\n0\n,\n1\n,\n2\n,\n0\n,\n1\n,\n1\n,\n        \n2\n,\n1\n,\n0\n,\n1\n,\n1\n,\n1\n,\n2\n,\n2\n,\n1\n,\n1\n,\n        \n0\n,\n0\n,\n1\n,\n0\n,\n2\n,\n1\n,\n0\n,\n0\n,\n1\n,\n1\n\n    };//\n30\n天的天气条件情况“\n1\n”代表高温，“\n0\n”代表晴朗，“\n2\n”代表沙暴\n\nvector  g[\nN\n];\nmap  mp;\nvoid push_back(int x,int y)\n{\n    g[x].push_back(y);\n    g[y].push_back(x);\n}\n\nvoid build_map()\n{\n    push_back(\n1\n,\n2\n);//从哪走到哪\n    push_back(\n2\n,\n3\n);\n    push_back(\n2\n,\n5\n);\n    push_back(\n5\n,\n6\n);\n    push_back(\n3\n,\n4\n);\n    push_back(\n4\n,\n7\n);\n    push_back(\n6\n,\n7\n);\n    push_back(\n7\n,\n8\n);\n    push_back(\n8\n,\n9\n);\n    push_back(\n9\n,\n10\n);\n    push_back(\n10\n,\n11\n);\n\n    mp[\n1\n]=\n1\n;//走哪\n    mp[\n2\n]=\n25\n;\n    mp[\n3\n]=\n26\n;\n    mp[\n4\n]=\n27\n;\n    mp[\n5\n]=\n24\n;\n    mp[\n6\n]=\n23\n;\n    mp[\n7\n]=\n21\n;\n    mp[\n8\n]=\n9\n;\n    mp[\n9\n]=\n15\n;\n    mp[\n10\n]=\n14\n;\n    mp[\n11\n]=\n12\n;\n    for(int i=\n1\n; i<=\nN\n; i++)\n    {\n        cz[i]=\n0\n;\n        ks[i]=\n0\n;\n    }\n    cz[\n9\n]=\n1\n;\n    ks[\n11\n]=\n1\n;\n    zd=\n4\n;\n    qd=\n1\n;\n\n    return ;\n}\nvoid init()\n{\n    memset(dp,-inf,sizeof(dp));\n    \nFZ\n=\n1200\n;\n    cost_water=\n5\n;\n    cost_food=\n10\n;\n\n    walk=\n2\n;\n    buy=\n2\n;\n    dig=\n3\n;\n\n\n    for(int k=\n0\n; k<=\n405\n; k++)\n    {\n        for(int l=\n0\n; l<=\n601\n; l++)\n        {\n            if(k*\n3\n+l*\n2\n<=\nFZ\n)\n            {\n                dp[\n0\n][qd][k][l]=\n10000\n-k*cost_water-l*cost_food;\n            }\n        }\n    }\n    printf(\n\"init %d\\n\"\n,dp[\n0\n][\n1\n][\n178\n][\n333\n]);\n    path[\n0\n][\n1\n][\n0\n][\n0\n]= {\n0\n,\n0\n,\n0\n,\n0\n};\n    return ;\n}\nint main()\n{\n\n\n    build_map();\n    init();\n    for(int i=\n0\n; i<\nDay\n; i++)\n    {\n        printf(\n\"第%d天\\n\"\n,i);\n        int tq=weather[i];\n        for(int j=\n1\n; j<=\nN\n; j++)\n        {\n            if(cz[j])// 村庄\n            {\n                for(int w=\n0\n; w<=\n405\n; w++)\n                {\n                    for(int f=\n0\n; w*\n3\n+f*\n2\n<=\n1200\n; f++)\n                    {\n                        //购买或不够买物资(ww=\n0\n,ff=\n0\n就是不购买)\n                        if(tq==\n2\n) //停留\n                        {\n                            int money=dp[i][j][w][f];\n                            for(int ww=\n0\n; ww<=money/cost_water; ww++)\n                            {\n                                for(int ff=\n0\n; ff<=(\nFZ\n-(w+ww)*\n3\n)/\n2\n-f; ff++)\n                                {\n\n                                    if(w+ww-xh_water[tq]>=\n0\n&&f+ff-xh_food[tq]>=\n0\n&&dp[i][j][w][f]\n-2\n*ww*cost_water\n-2\n*ff*cost_food>=\n0\n)\n                                    {\n                                        if(dp[i+\n1\n][j][w+ww-xh_water[tq]][f+ff-xh_food[tq]]=\n0\n&&f+ff-walk*xh_food[tq]>=\n0\n&&dp[i][j][w][f]-buy*ww*cost_water-buy*ff*cost_food>=\n0\n)\n                                        {\n                                            if(dp[i+\n1\n][jj][w+ww-walk*xh_water[tq]][f+ff-walk*xh_food[tq]]=\n0\n&&f-dig*xh_food[tq]>=\n0\n)\n                        {\n                            if(dp[i+\n1\n][j][w-dig*xh_water[tq]][f-dig*xh_food[tq]]=\n0\n)\n                            {\n                                dp[i+\n1\n][j][w-dig*xh_water[tq]][f-dig*xh_food[tq]]=dp[i][j][w][f]+\n1000\n;\n                                path[i+\n1\n][j][w-dig*xh_water[tq]][f-dig*xh_food[tq]]= {i,j,w,f,dp[i][j][w][f]+\n1000\n};\n                            }\n\n                        }\n                        // 在矿山不挖矿或 不允许挖矿\n                        if(tq==\n2\n) //停留但不挖矿\n                        {\n                            if(w-xh_water[tq]>=\n0\n&&f-xh_food[tq]>=\n0\n)\n                            {\n                                if(dp[i+\n1\n][j][w-xh_water[tq]][f-xh_food[tq]]=\n0\n)\n                                {\n\n                                    dp[i+\n1\n][j][w-xh_water[tq]][f-xh_food[tq]]=dp[i][j][w][f];\n                                    path[i+\n1\n][j][w-xh_water[tq]][f-xh_food[tq]]= {i,j,w,f,dp[i][j][w][f]};\n                                }\n\n                            }\n                        }\n                        else\n                        {\n                            if(w-walk*xh_water[tq]>=\n0\n&&f-walk*xh_food[tq]>=\n0\n)\n                            {\n                                for(auto jj:g[j])\n                                {\n                                    if(dp[i+\n1\n][jj][w-walk*xh_water[tq]][f-walk*xh_food[tq]]=\n0\n)\n                                    {\n                                        dp[i+\n1\n][jj][w-walk*xh_water[tq]][f-walk*xh_food[tq]]=dp[i][j][w][f];\n                                        path[i+\n1\n][jj][w-walk*xh_water[tq]][f-walk*xh_food[tq]]= {i,j,w,f,dp[i][j][w][f]};\n                                    }\n\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            else //普通区\n            {\n                for(int w=\n0\n; w<=\n405\n; w++)\n                {\n                    for(int f=\n0\n; w*\n3\n+f*\n2\n<=\n1200\n; f++)\n                    {\n                        if(tq==\n2\n) //在j点停留\n                        {\n                            if(w-xh_water[tq]>=\n0\n&&f-xh_food[tq]>=\n0\n&&dp[i][j][w][f]>=\n0\n)\n                            {\n                                if(dp[i+\n1\n][j][w-xh_water[tq]][f-xh_food[tq]]=\n0\n&&f-walk*xh_food[tq]>=\n0\n&&dp[i][j][w][f]>=\n0\n)\n                                {\n                                    if(dp[i+\n1\n][jj][w-walk*xh_water[tq]][f-walk*xh_food[tq]]ans)\n                {\n                    ans=dp[i][zd][w][f];\n                    lastpath=path[i][zd][w][f];\n                    last_water=w;\n                    last_food=f;\n                    last_day=i;\n                }\n            }\n    }\n    stack s;\n    stack my;\n    printf(\n\"天数:%d 天气:%d %d 水:%d 食物:%d 资金:%d\\n\"\n,last_day,weather[\nDay\n],zd,last_water,last_food,ans);\n    s.push((node)\n    {\n        last_day,zd,last_water,last_food,ans\n    });\n\n\n    while(lastpath!=path[\n0\n][\n1\n][\n0\n][\n0\n])\n    {\n        s.push(lastpath);\n        printf(\n\"天数:%d 天气:%d %d 天气:%d 食物:%d 资金:%d\\n\"\n,lastpath.day,weather[lastpath.day],mp[lastpath.from],lastpath.water,lastpath.food,lastpath.money);\n        my.push(lastpath.money);\n        lastpath=path[lastpath.day][lastpath.from][lastpath.water][lastpath.food];\n    }\n    freopen(\n\"output.txt\"\n,\n\"w\"\n,stdout);\n    my.push(my.top());\n    while (!s.empty())\n    {\n        node t=s.top();\n        int money=my.top();\n        printf(\n\"天数:%d 天气:%d 获得资金:%d 水:%d 食物:%d 资金:%d\\n\"\n,t.day,weather[t.day],mp[t.from],t.water,t.food,money);\n        s.pop();\n        my.pop();\n    }\n    printf(\n\"%d\\n\"\n,ans);\n    return \n0\n;\n}\n\n\n\n\n\n\n\n运行结果及报错内容\n\n\n\n\nD:\\Users\\86187\\Documents\\shuame\\Cache\\穿越沙漠\\main.cpp|140|error: 'jj' does not name a type|\nD:\\Users\\86187\\Documents\\shuame\\Cache\\穿越沙漠\\main.cpp|159|error: expected ';' before '}' token|\nD:\\Users\\86187\\Documents\\shuame\\Cache\\穿越沙漠\\main.cpp|159|error: expected primary-expression before '}' token|\nD:\\Users\\86187\\Documents\\shuame\\Cache\\穿越沙漠\\main.cpp|159|error: expected ';' before '}' token|\nD:\\Users\\86187\\Documents\\shuame\\Cache\\穿越沙漠\\main.cpp|159|error: expected primary-expression before '}' token|\nD:\\Users\\86187\\Documents\\shuame\\Cache\\穿越沙漠\\main.cpp|159|error: expected ')' before '}' token|\nD:\\Users\\86187\\Documents\\shuame\\Cache\\穿越沙漠\\main.cpp|159|error: expected primary-expression before '}' token|\nD:\\Users\\86187\\Documents\\shuame\\Cache\\穿越沙漠\\main.cpp|159|error: expected ';' before '}' token|\nD:\\Users\\86187\\Documents\\shuame\\Cache\\穿越沙漠\\main.cpp|175|warning: extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by default]|\n\n", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/weixin_39778570/article/details/87095270", "Konwledge_Point": "动态规划", "Question": "多维资源动态规划 Matlab求解\n", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/nan81962325/article/details/80202508", "Konwledge_Point": "动态规划", "Question": "算法【动态规划类型的问题】\n对一棵树进行着色，每个结点可着黑色或白色，相邻结点不能着相同黑色，但可着相同白色，令树的根为r，请设计一种算法对树中尽量多的节点着黑色\n\n\n\n不需要写代码啦，希望有大神给一个思路", "Tag": "算法分析"}
{"Answer": "[b]一个线性规划的问题[/b]\r\n\r\n设总吨数:K \r\n设22顿车辆数为：x\r\n设29顿车辆数为：y\r\n设32顿车辆数为：m\r\n设40顿车辆数为：n\r\n\r\n列方程：\r\n\r\nx+y+m+n <=21;\r\n22x+29y+32m+40n >= K；\r\nx , y,m ,n 为正整数\r\nx>0\r\ny>0\r\nm>0\r\nn>0\r\n\r\n\r\n求x+y+m+n的最优解（当x+y+m+n相等时，取22x+29y+32m+40n最小的x,y,m,n）\r\n==============================\r\n条件太小，只能从1开始，用穷举法。", "Konwledge_Point": "动态规划", "Question": "关于一个动态规划的问题\n问题描述：现有21辆车，其中载重22吨的有2台、29吨的有6台、32吨的有7台、40吨的有6台，求最佳车辆分配方案。\n\n输入:总吨数\n\n输出：车辆分配方案 需要的车辆最少（车辆载重量最低也是一个评价因素，当需要的车辆数目相同时，载重量低的车辆为最优解）为最优解\n\n\n\n示例：\n\n输入： 101\n\n输出： 29吨一台 32吨一台 40吨一台\n\n\n\n求算法描述....", "Tag": "算法分析"}
{"Answer": "对，不装入第i件物品和装入第i件物品（前提是能装下）进行比较价值哪个更大这个讲动态规划很全面\n动态规划之背包问题系列 - 知乎\n背包问题是一类经典的动态规划问题，它非常灵活，需要仔细琢磨体会，本文先对背包问题的几种常见类型作一个总结，然后再看看LeetCode上几个相关题目。 本文首发于我的博客，传送门根据 维基百科，背包问题（Knapsa…\n\n\n\nhttps://zhuanlan.zhihu.com/p/93857890\n\n", "Konwledge_Point": "动态规划", "Question": "动态规划问题的个人理解\n假设背包的容量无穷大,那么说到我加入(i+1)件物品肯定比i件物品的价值大,但是实际情况背包的容量是有限的。可不可以理解为当每多一件物品,新物品+前面剩余价值最大值组合 和 旧物品的最大排列组合相对比,留下最大值", "Tag": "算法分析"}
{"Answer": "O(n^2)很明显，两层循环第一层平方级别第二层常数级别所以是平方级别", "Konwledge_Point": "动态规划", "Question": "动态规划求一下这个时间复杂度\n for(int i=1; i<=n*m; i++)\n            for(int j=0; j<=14; j++)\n            {\n                if(j==0)//只有一种情况，由dp[i-1][j+5]+b[i]的情况也就是上一段有5的气然后用掉了\n                    dp[i][j]=dp[i-1][j+5]+b[i];\n                else if(j<10)//有两种情况，1，由上一段直接跑过来，2，由上一段消耗一张加速卡跑过来；\n                    dp[i][j]=min(dp[i-1][j-1]+a[i],dp[i-1][j+5]+b[i]);\n                else if(j==10)//有两种情况，1，由上一段直接跑过来，2，由上一段的14+1变成10跑过来；\n                    dp[i][j]=min(dp[i-1][j-1]+a[i],dp[i-1][14]+a[i]);\n                else if(j>10)//只有一种情况，由上一段路直接跑过来；\n                    dp[i][j]=dp[i-1][j-1]+a[i];\n            }", "Tag": "算法分析"}
{"Answer": "将单独赋值的m放到第一个后，req就不会报错了", "Konwledge_Point": "动态规划", "Question": "lingo动态规划求生产计划\nlingo求解出现问题，不知为何，代码如下\n\n\nsets:\npart/\n1.\n.7\n/:set,hold,a;\ntime/\n1.\n.6\n/:capacity;\nuses(part,part):req;\npxt(part,time):demand,x,y,inv;\nendsets\n\ndata:\ndemand = \n40\n \n0\n \n100\n \n0\n \n90\n \n10\n\n          \n0\n \n0\n \n0\n \n0\n \n0\n \n0\n\n          \n0\n \n0\n \n0\n \n0\n \n0\n \n0\n\n          \n0\n \n0\n \n0\n \n0\n \n0\n \n0\n\n          \n0\n \n0\n \n0\n \n0\n \n0\n \n0\n\n          \n0\n \n0\n \n0\n \n0\n \n0\n \n0\n\n          \n0\n \n0\n \n0\n \n0\n \n0\n \n0\n;\ncapacity = \n10000\n \n0\n \n5000\n \n5000\n \n1000\n \n1000\n;\nset = \n400\n \n500\n \n1000\n \n300\n \n200\n \n400\n \n100\n;\nhold = \n12\n \n0.6\n \n1.0\n \n0.04\n \n0.03\n \n0.04\n \n0.04\n;\na = \n0\n \n5\n \n8\n \n0\n \n0\n \n0\n \n0\n;\nreq = \n0\n \n0\n \n0\n \n0\n \n0\n \n0\n \n0\n\n      \n5\n \n0\n \n0\n \n0\n \n0\n \n0\n \n0\n\n      \n7\n \n0\n \n0\n \n0\n \n0\n \n0\n \n0\n\n      \n0\n \n9\n \n0\n \n0\n \n0\n \n0\n \n0\n\n      \n0\n \n11\n \n0\n \n0\n \n0\n \n0\n \n0\n\n      \n0\n \n13\n \n0\n \n0\n \n0\n \n0\n \n0\n\n      \n0\n \n0\n \n15\n \n0\n \n0\n \n0\n \n0\n;\nM = \n25000\n;\n\nenddata\n\n\n\nmin\n \n=\n \n@sum(pxt(i,j):set(i)*y(i,j)+hold(i)*inv(i,j))\n;\n\n\n@for(pxt(i,j): @if(j#eq#1,0,inv(i,j-1))+x(i,j)-inv(i,j)=\n                        demand(i,j)+@sum(part(k):req(i,k)*x(k,j)))\n;\n\n@for(time(j):@sum(part(i):a(i)*x(i,j))<capacity(j))\n;\n\n\n@for(pxt:X<=M*y;@bin(y))\n;\n\n\n\n\n出现以下问题\n\n\n[Error Code:   \n29\n]\n\n  Invalid \nnumber\n of initialization \nvalues\n in \na\n DATA/INIT/CALC\n  statement.  The required \nnumber\n of \nvalues\n \nis\n:          \n42\n.\n\n     \n14\n]            \n0\n \n0\n \n0\n \n0\n \n0\n \n0\n\n                            ^\n\n\n\n\n感谢大家指导！谢谢", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/qq_40379678/article/details/82955119", "Konwledge_Point": "动态规划", "Question": "这个动态规划的问题有点难，用C语言实现\nProblem Description\n\nMr Cheng is a collector of old Chinese porcelain, more specifically late 15th century Feng dynasty vases. The art of vase-making at this time followed very strict artistic rules. There was a limited number of accepted styles, each defined by its shape and decoration. More specifically, there were 36 vase shapes and 36 different patterns of decoration – in all 1296 different styles.\n\n\n\nFor a collector, the obvious goal is to own a sample of each of the 1296 styles. Mr Cheng however, like so many other collectors, could never afford a complete collection, and instead concentrates on some shapes and some decorations. As symmetry between shape and decoration was one of the\n\nmain aestheathical paradigms of the Feng dynasty, Mr Cheng wants to have a full collection of all combinations of k shapes and k decorations, for as large a k as possible. However, he has discovered that determining this k for a given collection is not always trivial. This means that his collection might actually be better than he thinks. Can you help him?\n\n\n\nInput\n\nOn the first line of the input, there is a single positive integer n, telling the number of test scenarios to follow. Each test scenario begins with a line containing a single positive integer m <=100 , the number of vases in the collection. Then follow m lines, one per vase, each with a pair of numbers, si and di, separated by a single space, where si ( 0 < i <= 36 ) indicates the shape of Mr Cheng's i:th vase, and di ( 0 < i <=36 ) indicates its decoration.\n\n\n\nOutput\n\nFor each test scenario, output one line containing the maximum k, such that there are k shapes and k decorations for which Mr Cheng's collection contains all k*k combined styles.\n\n\n\nSample Input\n\n2\n\n5\n\n11 13\n\n23 5\n\n17 36\n\n11 5\n\n23 13\n\n2\n\n23 15\n\n15 23\n\n\n\nSample Output\n\n2\n\n1", "Tag": "算法分析"}
{"Answer": "https://www.cnblogs.com/tonghao/p/4802967.html", "Konwledge_Point": "动态规划", "Question": "这个问题用动态规划的算法可以怎么实现的呢？\nProblem Description\n\nYou are given N baskets of gold coins. The baskets are numbered from 1 to N. In all except one of the baskets, each gold coin weighs w grams. In the one exceptional basket, each gold coin weighs w-d grams. A wizard appears on the scene and takes 1 coin from Basket 1, 2 coins from Basket 2, and so on, up to and including N-1 coins from Basket N-1. He does not take any coins from Basket N. He weighs the selected coins and concludes which of the N baskets contains the lighter coins. Your mission is to emulate the wizard's computation.\n\n\n\nInput\n\nThe input file will consist of one or more lines; each line will contain data for one instance of the problem. More specifically, each line will contain four positive integers, separated by one blank space. The first three integers are, respectively, the numbers N, w, and d, as described above. The fourth integer is the result of weighing the selected coins.\n\n\n\nN will be at least 2 and not more than 8000. The value of w will be at most 30. The value of d will be less than w.\n\n\n\nOutput\n\nFor each instance of the problem, your program will produce one line of output, consisting of one positive integer: the number of the basket that contains lighter coins than the other baskets.\n\n\n\nSample Input\n\n10 25 8 1109\n\n10 25 8 1045\n\n8000 30 12 959879400\n\n\n\nSample Output\n\n2\n\n10\n\n50", "Tag": "算法分析"}
{"Answer": "http://www.2cto.com/kf/201504/390807.html", "Konwledge_Point": "动态规划", "Question": "Balance 天平问题，用动态规划\nDescription\n\n\n\nGigel has a strange \"balance\" and he wants to poise it. Actually, the device is different from any other ordinary balance. \n\nIt orders two arms of negligible weight and each arm's length is 15. Some hooks are attached to these arms and Gigel wants to hang up some weights from his collection of G weights (1 <= G <= 20) knowing that these weights have distinct values in the range 1..25. Gigel may droop any weight of any hook but he is forced to use all the weights. \n\nFinally, Gigel managed to balance the device using the experience he gained at the National Olympiad in Informatics. Now he would like to know in how many ways the device can be balanced. \n\n\n\nKnowing the repartition of the hooks and the set of the weights write a program that calculates the number of possibilities to balance the device. \n\nIt is guaranteed that will exist at least one solution for each test case at the evaluation. \n\nInput\n\n\n\nThe input has the following structure: \n\n? the first line contains the number C (2 <= C <= 20) and the number G (2 <= G <= 20); \n\n? the next line contains C integer numbers (these numbers are also distinct and sorted in ascending order) in the range -15..15 representing the repartition of the hooks; each number represents the position relative to the center of the balance on the X axis (when no weights are attached the device is balanced and lined up to the X axis; the absolute value of the distances represents the distance between the hook and the balance center and the sign of the numbers determines the arm of the balance to which the hook is attached: '-' for the left arm and '+' for the right arm); \n\n? on the next line there are G natural, distinct and sorted in ascending order numbers in the range 1..25 representing the weights' values. \n\nOutput\n\n\n\nThe output contains the number M representing the number of possibilities to poise the balance.\n\nSample Input\n\n\n\n2 4 \n\n-2 3 \n\n3 4 5 8\n\nSample Output\n\n\n\n2", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/hnust_xiehonghao/article/details/7911575", "Konwledge_Point": "动态规划", "Question": "这个问题用线段数还是用动态规划？回溯算法怎么实现？\nProblem Description\n\n\n\nIn the year 8888, the Earth is ruled by the PPF Empire . As the population growing , PPF needs to find more land for the newborns . Finally , PPF decides to attack Kscinow who ruling the Mars . Here the problem comes! How can the soldiers reach the Mars ? PPF convokes his soldiers and asks for their suggestions . “Rush … ” one soldier answers. “Shut up ! Do I have to remind you that there isn’t any road to the Mars from here!” PPF replies. “Fly !” another answers. PPF smiles :“Clever guy ! Although we haven’t got wings , I can buy some magic broomsticks from HARRY POTTER to help you .” Now , it’s time to learn to fly on a broomstick ! we assume that one soldier has one level number indicating his degree. The soldier who has a higher level could teach the lower , that is to say the former’s level > the latter’s . But the lower can’t teach the higher. One soldier can have only one teacher at most , certainly , having no teacher is also legal. Similarly one soldier can have only one student at most while having no student is also possible. Teacher can teach his student on the same broomstick .Certainly , all the soldier must have practiced on the broomstick before they fly to the Mars! Magic broomstick is expensive !So , can you help PPF to calculate the minimum number of the broomstick needed .\n\nFor example : \n\nThere are 5 soldiers (A B C D E)with level numbers : 2 4 5 6 4;\n\nOne method :\n\nC could teach B; B could teach A; So , A B C are eligible to study on the same broomstick.\n\nD could teach E;So D E are eligible to study on the same broomstick;\n\nUsing this method , we need 2 broomsticks.\n\nAnother method:\n\nD could teach A; So A D are eligible to study on the same broomstick.\n\nC could teach B; So B C are eligible to study on the same broomstick.\n\nE with no teacher or student are eligible to study on one broomstick.\n\nUsing the method ,we need 3 broomsticks.\n\n……\n\n\n\nAfter checking up all possible method, we found that 2 is the minimum number of broomsticks needed. \n\n\n\nInput\n\nInput file contains multiple test cases. \n\nIn a test case,the first line contains a single positive number N indicating the number of soldiers.(0<=N<=3000)\n\nNext N lines :There is only one nonnegative integer on each line , indicating the level number for each soldier.( less than 30 digits);\n\n\n\nOutput\n\nFor each case, output the minimum number of broomsticks on a single line.\n\n\n\nSample Input\n\n4\n\n10\n\n20\n\n30\n\n04\n\n5\n\n2\n\n3\n\n4\n\n3\n\n4\n\n\n\nSample Output\n\n1\n\n2", "Tag": "算法分析"}
{"Answer": "http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2944", "Konwledge_Point": "动态规划", "Question": "字母猜谜问题，用动态规划算法怎么解决？\nProblem Description\n\nAnna Graham is a puzzle maker who prides herself in the quality and complexity of her work. She makes puzzles of all kinds - crosswords, logic problems, acrostics, and word search puzzles, to name but a few. For each puzzle, she has developed a set of rules which she constrains herself to follow. For word search puzzles, she insists not only that all the words be connected to one another (as in most word search puzzles), but also that removing any word from the word list will not cause one or more words to become disconnected from the rest. (Two words are connected if they contain a common letter in the grid.) The example word search puzzle on the left satisfies this condition, but the one on the right does not (removing the word Pascal from the word list disconnects Java from the other two words).\n\nYour job is to write a program that checks to see if Anna’s word search problems are up to snuff.\n\n\n\nInput\n\nInput will consist of multiple test cases. The first line of each test case contains 3 integers n m l, where n and m are the number of rows and columns in the puzzle and l is the number of words. Following this are n lines containing m uppercase characters each (the puzzle) followed by l lines containing one word each (the word list, in mixed case). Each word in the word list will appear in the puzzle exactly once. There will be no more than 100 rows and 100 columns in the puzzle and no more than 100 words to search for. There will be no spaces in the input words.\n\n\n\nOutput\n\nFor each problem instance, output the word Yes or No depending on whether the puzzle satisfies Anna’s constraints.\n\n\n\nSample Input\n\n5 6 3\n\nPBROGR\n\nPASCAL\n\nASMMIN\n\nGIICON\n\nTCELST\n\nBASIC\n\nLISP\n\nPascal\n\n5 6 4\n\nPBROJR\n\nPASCAL\n\nASMMVN\n\nGIICAN\n\nTCELST\n\nBASIC\n\nJava\n\nLISP\n\nPascal\n\n0 0 0\n\n\n\nSample Output\n\nYes\n\nNo", "Tag": "算法分析"}
{"Answer": "你可以参考如下链接：https://blog.csdn.net/the_ZED/article/details/104174375https://blog.csdn.net/qq_41785863/article/details/88769368\n解决思路和代码都在链接中，我就不重述了。\n如果对你有帮助，可以给我个采纳吗，谢谢!! 点击我这个回答右上方的【采纳】按钮", "Konwledge_Point": "动态规划", "Question": "求c语言代码做大臣的旅费的两种方法，分别是动态规划和分支界定，要让我能在电脑上运行\n【问题描述】  \n很久以前，T王国空前繁荣。为了更好地管理国家，王国修建了大量的快速路，用于连接首都和王国内的各大城市。 \n为节省经费，T国的大臣们经过思考，制定了一套优秀的修建方案，使得任何一个大城市都能从首都直接或者通过其他大城市间接到达。同时，如果不重复经过大城市，从首都到达每个大城市的方案都是唯一的。 \nJ是T国重要大臣，他巡查于各大城市之间，体察民情。所以，从一个城市马不停蹄地到另一个城市成了J最常做的事情。他有一个钱袋，用于存放往来城市间的路费。 \n聪明的J发现，如果不在某个城市停下来修整，在连续行进过程中，他所花的路费与他已走的距离有关，在走第x千米到第x+1千米这一千米中（x是整数），他花费的路费是x+10这么多。也就是说走1千米花费11，走2千米要花费23。 \nJ大臣想知道：他从某一个城市出发，中间不休息，到达另一个城市，所有可能花费的路费中最多是多少呢？  \n\n\n输入格式 \n输入的第一行包含一个整数n，表示包括首都在内的T王国的城市数 \n城市从1开始依次编号，1号城市为首都。 \n接下来n-1行，描述T国的高速路（T国的高速路一定是n-1条） \n每行三个整数Pi, Qi, Di，表示城市Pi和城市Qi之间有一条高速路，长度为Di千米。  \n\n\n输出格式 \n输出一个整数，表示大臣J最多花费的路费是多少。 \n样例输入\n1 \n5 \n1 2 2 \n1 3 1 \n2 4 5 \n2 5 4 \n样例输出\n1 \n135 \n输出格式\n大臣J从城市4到城市5要花费135的路费。 \n上面就是习题\n我自己在网上也有找代码，就是不知道这个是上面方法中的哪一个，我不介意你在网上找代码告诉我，只要能运行就行，但是最好把代码稍微修改，只要让老式不发现就行。时间在七月十四日之前\n。\n接受私信联系", "Tag": "算法分析"}
{"Answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* search(char*s,char*t)\n{    \n    int t_size=strlen(t),s_size=strlen(s),T,i,j;\n    char *p=NULL;\n    for(i=0;i<=(s_size-t_size);i++)\n    {\n        p=s+i;\n        T=1;\n        for(j=0;j<t_size;j++)\n        {\n            if(*p!=*(t+j))\n            {\n                T=0;\n                break;\n            }\n            p++;\n        }\n        if(T==1)\n            break;\n    }\n    if(T==0)\n        return NULL;\n    else\n        return s+i;\n}\n\n\nint main()\n{\n    char* S = \"qwertyuoiuywerqwrew\";\n    char* T = \"ty\";\n    char* R = search(S,T);\n    if(R == NULL) printf(\"Not Found\\n\");\n    else printf(\"%d\",strlen(S)-strlen(R));\n    \n    return 0;\n}\n", "Konwledge_Point": "动态规划", "Question": "定义两个字符串s和t，在s中查找t。如果能够找到，则输出t在s中首次出现的第一个字符的下标；否则，输出“Not Found”。\n定义两个字符串s和t，在s中查找t。如果能够找到，则输出t在s中首次出现的第一个字符的下标；否则，输出“Not Found”。", "Tag": "算法分析"}
{"Answer": "参考一下：https://juejin.cn/post/6979215311820029982\n如果对你有帮助，可以点击我这个回答右上方的【采纳】按钮，给我个采纳吗，谢谢", "Konwledge_Point": "动态规划", "Question": "MATLAB动态规划优化调度代码\n有没有大神会MATLAB动态规划优化调度代码，可以教我一下吗，有偿。实在是搞不懂了。", "Tag": "算法分析"}
{"Answer": "参考GPT和自己的思路：\n不是同一个意思。动态规划是一种解决复杂问题的算法，它通过将问题分解成子问题，并且通过解决子问题来求解原问题。而cplex中的动态搜索是指在求解MIP问题时，根据列子空间变化情况根据目标函数的优化值进行变量选择，并不是像动态规划将问题分解成子问题。两者的应用场景和解决问题的方法不同，需要根据具体的问题来选择正确的方法。", "Konwledge_Point": "动态规划", "Question": "动态规划和cplex中的MIP动态搜索是一回事吗\ncplex中对MIP问题的求解中写道MIP搜索方式：动态搜索。请问这里的动态搜索和常说的动态规划是一个意思吗，如果不是那有什么不同呢？", "Tag": "算法分析"}
{"Answer": "思路如下：\r\n题目的要求本质上是说有x个人，分成y组，要求每组至少有个一个人。问有多少种分法。\r\n动态数组为dp[x][y]。表示x个人分成y组有多少种分法。有题目要求所知，\r\n对所有x，dp[x][1] = 1，dp[x][y] = 1，如果x < y，则dp[x][y] = 0.否则，\r\ndp[x][y] = dp[x-1][y] * y + dp[x-1][y-1]，也就是说，状态[x,y]肯定可以从二种相邻状态得到，\r\n第一种，x-1个人已经组成了y组，则第x个人可以放入任意一组中，也就是有dp[x-1][y]_*y种可能；\r\n第二种，x-1个人已经组成了y-1组，则第x个人必须被放到第yzu中，也就是有dp[x-1][y-1]种可能。\r\n对于x-1个人组成了y-2甚至更少组的情况，不可能在多一个人情况下组成y组，可以不予考虑。c++程序如下：_\r\n\r\n\r\n```\r\n const int INF = 110; \r\nint dp[INF][INF]; \r\n\r\nvoid buildDP() {\r\n\tfor (int i = 1; i < INF; i++) {\r\n\t\tdp[i][1] = 1; \r\n\t\tdp[i][i] = 1; \r\n\t}\r\n\r\n\tfor (int i = 2; i < INF; i++) {\r\n\t\tfor (int j = 2; j < i; j++) {\r\n\t\t\tdp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] * j; \r\n\t\t}\r\n\t}\r\n}\r\n\r\nint main() {\r\n\tint x, y; cin >> x >> y; \r\n\r\n\tbuildDP(); \r\n\r\n\tcout << dp[x][y] << endl; \r\n\r\n\treturn 0; \r\n}\r\n```", "Konwledge_Point": "动态规划", "Question": "动态规划问题求解思路\n动态规划题目：请问这道问题的各阶段确定状态变量如何确定？请各位大神指教！\n\n假设工人人数为 x，有 y 项任务(其中：1 <= y,x <= 100)，假定每个任务的工作量都是一样的，要求每个工人至少完成一项任务，同时还要求每项任务至少要被完成一次，问有多少种安排方案？当然也有可能没有一种方案存在。\n\n（附测试数据：x=4 ,y=2时，结果为7\n\n\n\n                    x=15 ,y=12,结果为106470\n", "Tag": "算法分析"}
{"Answer": "可以当作一辆车，第一辆车先走，采集过的置为0，然后第2辆车再走。简单的动态规划问题：\nclass Solution{\n    public static void run(int[][] arr, String name){\n        List<int[]> res = new ArrayList<>();\n        int row = arr.length;\n        int column = arr[0].length;\n        int[][] temp = new int[row][column];\n        for(int i = 0;i<row; i++) {\n            for (int j = 0; j < column; j++) {\n                int top = i > 0 ? temp[i - 1][j] : 0;\n                int left = j > 0 ? temp[i][j - 1] : 0;\n                temp[i][j] = Math.max(top, left) + arr[i][j];\n            }\n        }\n        int car = temp[row-1][column-1];\n        System.out.println(name + \"最大值：\" + car);\n        //获取car1的路径\n        res.add(new int[]{row-1,column-1});\n        int i = row-1,j=column-1;\n        while (i >0 && j>0){\n            int top =temp[i-1][j];\n            int left = temp[i][j-1];\n            if(top >= left){\n                i--;\n            }else{\n                j--;\n            }\n            res.add(new int[]{i, j});\n            arr[i][j] = 0;\n        }\n        while (i-- > 0){\n            arr[i][0] = 0;\n            res.add(new int[]{i, 0});\n        }\n        while (j-- > 0){\n            arr[0][j] = 0;\n            res.add(new int[]{0, j});\n        }\n        System.out.println(name + \"路径：\");\n        for (int k = res.size()-1; k>=0;--k){\n            System.out.print(Arrays.toString(res.get(k)));\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        int[][] a = new int[][]{{0,2,2,2,2},{0,1,0,0,2},{0,0,0,0,2},{0,0,0,0,2},{0,0,0,0,0}};\n        run(a, \"car1\");\n        run(a, \"car2\");\n    }\n}\n\n\n给个采纳吧", "Konwledge_Point": "动态规划", "Question": "动态规划问题，请大家看一下\n两台月球矿车从A点向B点移动探测，每台矿车每次可以向右或向下移动一步，移动到的位置对应的数据为可采集的矿石数量 假设每台矿车矿石装载量无限，请求出两台矿车都到达B点后采集到的矿石数量总和最大值，并将他们经过的路径输出 动态规划问题\n算法思想  代码和伪代码  复杂度（空间和时间）\n\n", "Tag": "算法分析"}
{"Answer": "1、暴力解法\n所谓暴力解法，就是穷举所有情况。因为对于长度为 $n$ 的原序列，它的子序列总共有 $2^n$ 种情况，所以利用深度优先搜索枚举所有情况，然后取 \"满足相邻两元素递增并且长度最长\" 的子序列就是答案，当然这种方法肯定是不可取的，因为随着 $n$ 的不断变大，整个求解时间复杂度呈指数级增长。\n2、朴素解法\n朴素解法采用的是动态规划的思想。首先当然是设计状态。1）设计状态\n对于数组序列 $a_i(1 \\le i \\le n)$，令 $f[i]$ 表示以第 $i$ 个数 $a_i$ 结尾的最长递增子序列的长度。那么，我们考虑以第 $i$ 个数 $a_i$ 结尾的最长递增子序列，它在这个序列中的前一个数一定是 $a_j(1 \\le j < i)$ 中的一个，所以，如果我们已经知道了 $f[j]$，那么就有 $f[i] = f[j] + 1$。显然，我们还需要满足 $a_j < a_i$ 这个递增的限制条件。2）状态转移方程\n那么就可以得出状态转移方程：$$f[i] = \\max_{j=1}^{i-1} (f[j] \\ | \\  a_j < a_i) + 1$$这里 $f[j]$ 是 $f[i]$ 的子结构，而 $max(f[j])$ 是 $f[i]$ 的最优子结构，当然我们需要考虑一种情况，就是没有找到最优子结构的时候，例如：$i=1$ 或者 不存在 $a_j < a_i$ 的 $j$，此时 $f[i] = 1$，表示 $a_i$ 本身是一个长度为 $1$ 的最长递增子序列。$f[i]$ 数组可以通过两层循环来求解，如下图表所示：\n\n-|-|-|-|-|-|-|-\n$a[i]$|1|2|4|6|3|5|9\n$f[i]$|1|2|3|4|3|4|5\n\n3）时间复杂度分析\n状态数 $f[...]$ 总共 $O(n)$ 个，状态转移的消耗为 $O(n)$，所以总的时间复杂度为 $O(n^2)$，所以对于这类问题，一般能够接受的 $n$ 的范围在千级别，也就是 $1000, 2000, 3000 ...$。如果是 $n=10000, 100000$ 的情况，就需要考虑优化了。那么，下文将介绍最长单调子序列的优化算法，基于的是 贪心 的思想，为了方便理解，将 \"单调\" 一词替换为 \"递增\"。均以 最长递增子序列 为例进行讲解。", "Konwledge_Point": "动态规划", "Question": "请问动态规划里的最长递增子系列问题\n请问动态规划里的最长递增子系列问题\n为什么时间复杂度是 nlog2 的呀", "Tag": "算法分析"}
{"Answer": "http://zhidao.baidu.com/link?url=DusTYd_4dgXuIS_G88sIwfRCR7viclzAEjlx45dQIXVNvisa28lctiMmi90qEkjl1wJ7B66bDEgZpeGhXkQd8rZX8L5xW7e4n63K9bQUrB_", "Konwledge_Point": "动态规划", "Question": "概率问题,动态规划求解\n大神们,用动态规划怎么解这道题呀?\n\n问题描述\n\n　　生成n个∈[a,b]的随机整数，输出它们的和为x的概率。\n\n输入格式\n\n　　一行输入四个整数依次为n，a，b，x，用空格分隔。\n\n输出格式\n\n　　输出一行包含一个小数位和为x的概率，小数点后保留四位小数\n\n样例输入\n\n2 1 3 4\n\n样例输出\n\n0.3333\n\n数据规模和约定\n\n　　对于50%的数据，n≤5.\n\n　　对于100%的数据，n≤100,b≤100.", "Tag": "算法分析"}
{"Answer": "这是一道动态规划题目。\n我们可以使用自底向上的方法来求解这道题目。\n首先我们可以定义一个数组dp[i]表示到第i个时间结点的最大收获。\n具体来说，我们可以从小到大循环每个时间结点i，对于每个时间结点i，我们可以循环每个指向它的时间结点j，如果有多个指向它的时间结点j，则取收获最大的那个即可。\n最终结果就是dp[n]，即最后一个时间结点的最大收获值。\n具体代码如下：\nint n;\nint v[MAX_N];\nint f[MAX_N];\nint dp[MAX_N];\n\nint main()\n{\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> v[i];\n    for (int i = 1; i <= n; i++) cin >> f[i];\n\n    for (int i = n; i >= 1; i--)\n    {\n        if (f[i] == 0) dp[i] = v[i];\n        else\n        {\n            dp[i] = v[i];\n            for (int j = f[i]; j != 0; j = f[j]) dp[i]\n\n", "Konwledge_Point": "动态规划", "Question": "关于#C++动态规划#的问题,如何解决?\n希望能帮忙解决一下今天不会的题(应该是动态规划):\n\n\n\n\n\n\n\n\n最好是C++的代码加上思路!谢谢", "Tag": "算法分析"}
{"Answer": "动态规划，光讲概念肯定很难理解的，还是需要多加实践。建议多刷题，文章的话我可以提供一些：\n\n夜深人静写算法（二）- 动态规划入门_英雄哪里出来-CSDN博客\n全网独家《动态规划》从入门到精通\n\n\n\nhttps://blog.csdn.net/WhereIsHeroFrom/article/details/120107337?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163965567116780264065144%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=163965567116780264065144&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-120107337.pc_v2_rank_blog_default&utm_term=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92&spm=1018.2226.3001.4450\n\n", "Konwledge_Point": "动态规划", "Question": "动态规划的子问题到底是指什么呢？\n动态规划的子问题到底是指什么呢？这块有详细的教程吗？\n如果有一些能够参考的博文也可以", "Tag": "算法分析"}
{"Answer": "[[0]*(n+1) for _ in range(m+1)] 这整体不是列表推导式吗意思就是生成一个m行n列的数组每项值为0，print(dp) 就能看出来生成的是什么了。for _ in range(m+1) 你应该知道for in 语句吧， 这个 _ 你不喜欢可以换成其他的不影响，反正又不使用。\nw[j] 没定义是应为没把全部代码写出来，w[] v[] 这两个不都是要输入的吗？", "Konwledge_Point": "动态规划", "Question": "python 动态规划创建列表相关问题\n\n\n最近在学python，在刷题的时候遇到一道动态规划题——背包问题，有一些代码看不懂。\n\n\n\n\ndp = \n[\n[0]\n*(n+1) for _ in range(m+1)]\n\nfor i in range(1,m+1):\n    for j in range(1,n+1):\n        if j-w\n[i]\n>=0:\n            dp\n[i]\n[j]\n = max(dp\n[i-1]\n[j]\n, dp\n[i-1]\n[j-w\n[i]\n]\n+v\n[i]\n)\n        else:\n            dp\n[i]\n[j]\n = dp\n[i-1]\n[j]\n\nreturn dp\n[m]\n[n]\n\n\n\n\n\n附完整问题截图：\n\n\n\n\n想问问这些代码是什么意思？尤其是第一行，没见过这种写法，有两个地方看不懂——\"[0]*(n+1)\"和for后面的\"_\"。\n还有，第四行为什么可以直接把w[j]写进来，前面的代码里也没定义过。\n提前谢谢解答。", "Tag": "算法分析"}
{"Answer": "import java.util.*;\nimport static java.lang.Math.*;\npublic class  Shiyaner\n{\npublic static void main(String[] args)\n{\nfinal  int m = 5;\nfinal  int n = 5;\n//  定义向上，向右的代价，以及最优代价\nint[][] Cost = new int[m+1][n+1];\nint[][] Down = new int[m][n+1];\nint[][] Right = new int[m+1][n];\nint count = 0, i = 0, j = 0;\n//  随机的产生向上代价数组Above，并输出\nfor(i = 0; i < m; i++)\nfor(j = 0; j < n+1; j++)\n{\nRandom rand = new Random();\nDown[i][j] = (rand.nextInt(5)+5);\n}\nSystem.out.printf(\"Down:\\n\");\nfor(i = 0; i < m; i++)\n{\nfor(j = 0; j < n+1; j++)\n{\nSystem.out.printf(\"%5d\", Down[i][j]);\n}\nSystem.out.println(\"\\n\");\n}\n//  随机的产生向右代价数组Right，并输出\nfor(i = 0; i < m+1; i++)\nfor(j = 0; j < n; j++)\n{\nRandom rand = new Random();\nRight[i][j] = (rand.nextInt(5)+5);\n}\nSystem.out.printf(\"Right:\\n\");\nfor(i = 0; i < m+1; i++)\n{\nfor(j = 0; j < n; j++)\n{\nSystem.out.printf(\"%5d\", Right[i][j]);\n}\nSystem.out.println(\"\\n\");\n}\n//   求出最优代价数组Cost并输出\nCost[0][0] = 0;\nfor(i = 1; i < m+1; i++)\nCost[i][0] = Cost[i-1][0] + Down[i-1][0];\nfor(j = 1; j < n+1; j++)\nCost[0][j] = Cost[0][j-1] + Right[0][j-1];\nfor(i = 0; i < m; i++)\nfor(j = 0; j < n; j++)\nCost[i+1][j+1] = min((Cost[i+1][j] + Right[i+1][j]), (Cost[i][j+1] +\nDown[i][j+1]));\nSystem.out.printf(\"最优距离:\\n\");\nfor(i = 0; i < m+1; i++)\n{\nfor(j = 0; j < n+1; j++)\n{\nSystem.out.printf(\"%5d\",Cost[i][j]);\n}\nSystem.out.println(\"\\n\");\n}\n//  输出最优路径的具体走法\nSystem.out.println(\"请输入你想到达的坐标位置：\");\nScanner in1 = new Scanner(System.in);\nSystem.out.print(\"横坐标：\");\nint a = in1.nextInt();\nSystem.out.print(\"纵坐标：\");\nint b = in1.nextInt();\nint[] d = new int[a+b];\nint k = a+b-1;\ni = a - 1  ;\nj = b - 1  ;\nwhile ( i != 0 && j != 0 )\n{\nif (  Cost[i+1][j+1] == (Cost[i+1][j] + Right[i+1][j]))\n{\nd[k] = 0;\nj--;\nk--;\n}\nelse\n{\nd[k] = 1;\ni--;\nk--;\n}\n}\nif( i == 0 )\n{\nwhile ( j != 0 )\n{\nd[k] = 1;\nj--;\nk--;\n}\n}\nif( j == 0 )\n{\nwhile ( i != 0 )\n{\nd[k] = 0;\ni--;\nk--;\n}\n}\nfor (i = a+b-1 ; i >= 0 ; i-- )\n{\nif ( d[i] == 0 )\nSystem.out.println(\"Right\");\nelse\nSystem.out.println(\"Down\");\n}\n}\n}\n运行结果如下：\nDown:\n5    9    7    6    5    6\n8    9    8    5    7    6\n9    6    7    9    6    5\n9    9    7    5    6    6\n5    7    5    9    5    5\nRight:\n7    7    9    8    8\n6    6    5    6    6\n8    9    7    9    8\n9    7    7    5    8\n6    7    7    9    7\n6    7    8    5    6\n最优距离:\n0    7   14   23   31   39\n5   11   17   22   28   34\n13   20   25   27   35   40\n22   26   32   36   41   45\n31   35   39   41   47   51\n36   42   44   50   52   56\n请输入你想到达的坐标位置：\n横坐标：3\n纵坐标：3\nDown\nDown\nDown\nDown\nRight\nRight", "Konwledge_Point": "动态规划", "Question": "java实验-设计动态规划算法\n设平面上有一个m×n 的网格，将左下角的网格点标记为（0,0）而右上角的网格点标记为（m,n）。某人想从（0,0）出发沿网格线行进到达（m,n），但是在网格点（i,j）处他只能向上行进或者向右行进，向上行进的代价为aij（amj ＝＋∞），向右行进的代价是bij（bin ＝＋∞）。试设计一个动态规划算法，在这个网格中为该旅行者寻找一条代价最小的旅行路线。", "Tag": "算法分析"}
{"Answer": "代码如下：（1）递归 \n#include <stdio.h>\n\nlong long Cnk(int n,int k)\n{\n    if(k==0 ||k==n)\n        return 1;\n    else\n        return Cnk(n-1,k)+Cnk(n-1,k-1);\n}\n\n\nint main()\n{\n    int n,k;\n    long long res = 0;\n    scanf(\"%d %d\",&n,&k);\n    res = Cnk(n,k);\n    printf(\"%lld\",res);\n    return 0;\n}\n\n（2）\n#include <stdio.h>\nlong long Jiecheng(int n)\n{\n    long long s = 1;\n    for(int i=1;i<=n;i++)\n        s *= i;\n    return s;\n}\n\n\nlong long Cnk(int n,int k)\n{\n    return Jiecheng(n)/Jiecheng(k)/Jiecheng(n-k);\n}\n\n\nint main()\n{\n    int n,k;\n    long long res = 0;\n    scanf(\"%d %d\",&n,&k);\n    res = Cnk(n,k);\n    printf(\"%lld\",res);\n    return 0;\n}\n\n", "Konwledge_Point": "动态规划", "Question": "如何用偏基础的c语言递归和动态规划解决该问题\n如何用偏基础的C语言递归程序和动态规划程序分别解决这个问题，希望给出两种方法\n数据范围在一千左右", "Tag": "算法分析"}
{"Answer": "用数组price[0,1,2...n]表示每个城镇的货物价值题目：低买高卖，限制买卖次数k次。\n我们用 buy[i][j] 表示对于数组prices[0..i] 中的价格而言，进行恰好 j次交易，并且车上还有一个货物，这种情况下的最大利润。用sell[i][j]表示这种情况下，车上没有货物时候的最大利润；用cost表示此时车上货物的价值\n推导：对于buy[i][j] ,如果是第i站进行了交易，如果此时不持有货物那么最大利润就是sell[i-1][j-1] - price[i]如果此时持有货物，那么最大利润就是buy[i-1][j-1]-price[i]+cost那么buy[i][j] = Max{sell[i-1][j-1] - price[i]，buy[i-1][j-1]-price[i]+cost  }\n对于sell[i][j]，此时持有货物，那么最大利润就是持有的卖出 buy[i-1][j-1] + cost如果此时不持有货物，最大利润就是sell[i-1][j]那么sell[i][j] = Max{ buy[i-1][j-1] + cost, sell[i-1][j]  }\n在k次交易后，不持有货物利润最大，所以答案在sell[n-1][0...k]中的最大值。\nps：算法题中，算是困难类型的了。。。", "Konwledge_Point": "动态规划", "Question": "动态规划相关问题，卡车运货最大利润问题\nConsider a delivery truck that travels from a start town to a destination town\npassing by multiple towns en route. At each of the n towns along the route\nthere is the option for the truck to either pick up a new load at cost ci specific\nfor town i, or else drop off its existing load at a value vi ≤ ci specific for town\ni. The truck can only transport one load at a time and can only stop at most\n2k ≤ n times to pick up or drop off a load.\nThe purpose of this assignment is to develop algorithms that can indicate to\na truck driver at which towns it is best to pick up or drop off in order for the\ntruck to get the best overall profit.\n Exact Approach which is a program that demonstrates an approach that\ncorrectly and efficiently solves the delivery truck problem. Please include\ncomments in your program that clearly explain the approach you have\ntaken, particularly why it works, and include good test cases that illustrate\nits correctness.\n求一个详细点的思路，需要用动态规划，最好思路有详细思考过程", "Tag": "算法分析"}
{"Answer": "动态规划的基本思想是将原问题分解为若干个子问题，从而通过计算每个子问题的答案来解决原问题。在本题中，我们可以使用一个数组，记录以当前数字结尾的单调递增子数列的最大和。\n我们令dp[i]表示以第i个数字结尾的单调递增子数列的最大和，那么，dp[i]可以由以下状态转移方程得到：\ndp[i] = max(dp[j]) + a[i] (0 <= j < i and a[j] < a[i])\n代码如下：\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 2010; // 定义数列的最大长度\n\nint n; // 数列的长度\nint a[N]; // 定义数列\nint dp[N]; // 定义DP数组，dp[i]表示以第i个数字结尾的单调递增子数列的最大和\n\nint main()\n{\n    cin >> n; // 输入数列的长度\n    for (int i = 0; i < n; i ++) cin >> a[i]; // 输入数列中的数字\n    for (int i = 0; i < n; i ++)\n    {\n        dp[i] = a[i]; // 初始化dp[i]，设为数列中的第i个数字\n        for (int j = 0; j < i; j ++)\n        {\n            if (a[j] < a[i]) dp[i] = max(dp[i], dp[j] + a[i]); // 如果a[j] < a[i]，更新dp[i]的值\n        }\n    }\n    int ans = 0; // 定义答案\n    for (int i = 0; i < n; i ++) ans = max(ans, dp[i]); // 求出答案\n    cout << ans << endl; // 输出答案\n    return 0;\n}\n\n\n", "Konwledge_Point": "动态规划", "Question": "关于递增数列问题，如何使用动态规划思想解决。\n关于递增数列问题，如何使用动态规划思想解决。\n从数列中选出若干个数字（至少选择一个），这些数字相对顺序与他们对应在数列中的相对顺序一致， 同时要求其大小单调递增，求满足条件的这些数字的最大和。\n\n\n第一行输入 1 个整数N，表示数列大小。（1≤N≤2000）\n第二行输入 N 个整数 Ai，表示数列中的每个数字。（−10000≤Ai≤10000）。\n\n\n一个整数，表示满足条件的这些数字的最大和。\n样例输入：\n5\n1 3 1 5 -2\n样例输出：\n9", "Tag": "算法分析"}
{"Answer": "需要考虑的前提很多啊，如果你的对象数量级很大，那不推荐这样，如果你需要给删除配上撤销操作，这样是可行的\r\n数据库里的删除操作，很多时候就不是真的删除，只是状态的改变", "Konwledge_Point": "动态规划", "Question": "程序设计 方法合并问题\n对某个对象的删除方法可以合并到编辑方法里面吗？因为就算是删除也只是软删除改一下状态而已嘛  这样做是否合理呢？", "Tag": "算法分析"}
{"Answer": "全局有默认值", "Konwledge_Point": "动态规划", "Question": "c++中有关动态规划的简单算法\n这个问题的题目和正确题解如下，主要用到的是动态规划算法。我的疑问是为什么二维数组f【】【】没有进行初始化，但是运行结果却是正确的呢？\n\n\n[NOIP2002 普及组] 过河卒\n\n\n题目描述\n\n\n棋盘上 $A$ 点有一个过河卒，需要走到目标 $B$ 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 $C$ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。\n\n\n棋盘用坐标表示，$A$ 点 $(0, 0)$、$B$ 点 $(n, m)$，同样马的位置坐标是需要给出的。\n\n\n\n\n现在要求你计算出卒从 $A$ 点能够到达 $B$ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。\n\n\n输入格式\n\n\n一行四个正整数，分别表示 $B$ 点坐标和马的坐标。\n\n\n输出格式\n\n\n一个整数，表示所有的路径条数。\n\n\n样例 #1\n\n\n样例输入 #1\n\n\n6 \n6\n \n3\n \n3\n\n\n\n\n样例输出 #1\n\n\n6\n\n\n\n提示\n\n\n对于 $100 %$ 的数据，$1 \\le n, m \\le 20$，$0 \\le$ 马的坐标 $\\le 20$。\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ndefine\n ll long long\n\n\nusing\n \nnamespace\n std;\n\n\nconst\n \nint\n fx[] = {\n0\n, \n-2\n, \n-1\n, \n1\n, \n2\n, \n2\n, \n1\n, \n-1\n, \n-2\n};\n\nconst\n \nint\n fy[] = {\n0\n, \n1\n, \n2\n, \n2\n, \n1\n, \n-1\n, \n-2\n, \n-2\n, \n-1\n};\n\n//马可以走到的位置\n\n\n\nint\n bx, by, mx, my;\nll f[\n40\n][\n40\n];\n\nbool\n s[\n40\n][\n40\n]; \n//判断这个点有没有马拦住\n\n\nint\n \nmain\n()\n{\n    \nscanf\n(\n\"%d%d%d%d\"\n, &bx, &by, &mx, &my);\n    bx += \n2\n; by += \n2\n; mx += \n2\n; my += \n2\n;\n    \n//坐标+2以防越界\n\n    f[\n2\n][\n1\n] = \n1\n;\n//初始化\n\n    s[mx][my] = \n1\n;\n//标记马的位置\n\n    \nfor\n(\nint\n i = \n1\n; i <= \n8\n; i++) s[mx + fx[i]][my + fy[i]] = \n1\n;\n    \nfor\n(\nint\n i = \n2\n; i <= bx; i++){\n        \nfor\n(\nint\n j = \n2\n; j <= by; j++){\n            \nif\n(s[i][j]) \ncontinue\n; \n// 如果被马拦住就直接跳过\n\n            f[i][j] = f[i - \n1\n][j] + f[i][j - \n1\n];\n            \n//状态转移方程\n\n        }\n    }\n    \nprintf\n(\n\"%lld\\n\"\n, f[bx][by]);\n    \nreturn\n \n0\n;\n} \n\n", "Tag": "算法分析"}
{"Answer": "动态规划的背包问题。\n但是如果把这道题强行理解为01背包未免有些和01背包的概念不符，其实这道题是到达性的01背包。\n我们可以不把这道题想象的那么复杂，直接按照最基础的动态规划来，设置动态转移方程和初值。\n这回我们用标记数组来动归。\n设状态转移方程f[i][j]为第i首歌能否达到j的音量，能为1，不能为0。\n这样的话我们就可以开始动归，最后只需要枚举出最大的f[n][i]，就是需要找的答案了。\n这里还需要注意，初值f[0][begin]要设置为1，因为没开始之前就可以达到begin的音量。\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n,beginlevel,maxlevel;\nint c[60];\nint f[60][1010];\nint main()\n{\n    scanf(\"%d%d%d\",&n,&beginlevel,&maxlevel);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&c[i]);\n    f[0][beginlevel]=1;\n    for(int i=1;i<=n;i++)\n        for(int j=maxlevel;j>=0;j--)\n        {\n            if(f[i-1][j] && j+c[i]<=maxlevel)\n                f[i][j+c[i]]=1;\n            if(f[i-1][j] && j-c[i]>=0)\n                f[i][j-c[i]]=1;\n        }\n    for(int i=maxlevel;i>=0;i--)\n        if(f[n][i]==1)\n        {\n            printf(\"%d\",i);\n            return 0;\n        }\n    printf(\"-1\");\n    return 0;\n}\n\n\n\nDFS也行\n#include<bits/stdc++.h>\n#define ll long long\n#define reg register\nusing namespace std;\nint bl,ml,ans,c[55],n;\nbool f[51][1010];//定义t是否能达到k的音量\nvoid dfs(int t,int k){\n    if(k<0||k>ml)return;\n    //剪枝部分↓\n    if(f[t][k])return;\n    //如果改点已经有了\n    //就不要再搜了\n    else f[t][k]=1;//否则算他访问过了\n    //剪枝部分↑\n    if(t==n){\n        ans=max(ans,k);\n        return;\n    }\n    dfs(t+1,k+c[t+1]);\n    dfs(t+1,k-c[t+1]);\n}\nint main(){\n    ans=-1;\n    scanf(\"%d%d%d\",&n,&bl,&ml);\n    for(reg int i=1;i<=n;++i){\n        scanf(\"%d\",&c[i]);\n    }\n    dfs(0,bl);\n    cout<<ans;\n    return 0; \n}\n\n\n", "Konwledge_Point": "动态规划", "Question": "关于C++动态规划，请问代码bug在哪儿？\n这道问题起源洛谷\n\n\n\n\n\n\n我用动态规划来写，solve(i,j)表示第 i 次调音调到 j 可不可行，true代表可行，false代表不可行\n那么i>1时，solve(i,j)=true当且仅当 0<=j - a[j]<=maxlevel && solve(i - 1, j - a[j]) == true\n                                                     或 0<=j +a[j]<=maxlevel && solve(i - 1, j +a[j]) == true\n以下是我用这个思路写的代码\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\n\nint\n n, bl, ml;\n\nint\n a[\n51\n];\n\n\nbool\n \nin\n(\nint\n n)\n \n{\n    \nif\n (n >= \n0\n && n <= ml) {\n        \nreturn\n \ntrue\n;\n    }\n    \nelse\n {\n        \nreturn\n \nfalse\n;\n    }\n}\n\nbool\n \nsolve\n(\nint\n i, \nint\n j)\n \n{\n        \nif\n (i == \n0\n) {\n            \nif\n (j == bl) {                \n                \nreturn\n \ntrue\n;\n            }\n            \nelse\n {                \n                \nreturn\n \nfalse\n;\n            }\n        }\n        \nelse\n{\n            \nif\n (\nin\n(j - a[j]) == \ntrue\n && (\nsolve\n(i - \n1\n, j - a[j]) == \ntrue\n)) {                \n                \nreturn\n \ntrue\n;\n            }\n            \nelse\n \nif\n (\nin\n(j + a[j]) == \ntrue\n && (\nsolve\n(i - \n1\n, j + a[j]) == \ntrue\n)) {                \n                \nreturn\n \ntrue\n;\n            }\n            \nelse\n {                \n                \nreturn\n \nfalse\n;\n            }\n        }\n    \n}\n\n\nint\n \nmain\n()\n \n{\n    cin >> n >> bl >> ml;\n    \nfor\n (\nint\n i = \n1\n;i <= n;i++) {\n        cin >> a[i];\n    }    \n    \nfor\n (\nint\n j = ml;j >= \n-1\n;j--) {\n        \nbool\n ans2 = \nsolve\n(n, j);\n        \nif\n (ans2 == \ntrue\n) {\n            cout << j;\n            \nbreak\n;\n        }\n        \nif\n (j == \n-1\n) {\n            cout << \n-1\n;\n        }        \n    }\n}\n\n\n\n\n\n\n但是程序好像有bug，输入样例不对\n\n\n\n\n请问bug在哪儿？", "Tag": "算法分析"}
{"Answer": "这道题的n高达1e5，两次循环下来肯定会超时的两序列长度相同并且都是1-n的排列，因此可以进行优化将时间复杂度降为nlogn，数组降为1维。\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+10;\nint a[N],b[N],c[N],f[N];\nint len=1;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n    scanf(\"%d\",&a[i]);\n    c[a[i]]=i;\n    }\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&b[i]);\n        b[i]=c[b[i]];\n    }\n    f[1]=b[1];\n    for(int i=2;i<=n;i++)\n    {\n        if(f[len]<b[i])\n        f[++len]=b[i];\n        else\n        f[lower_bound(f+1,f+len+1,b[i])-f]=b[i];\n    }\n    printf(\"%d\",len);\n}\n\n", "Konwledge_Point": "动态规划", "Question": "关于#c语言#的问题：洛谷P1438最长公共子序列与动态规划有关错误信息如图找出错误并给出解决方案通过测试\n洛谷P1438最长公共子序列与动态规划有关\n错误信息如图\n找出错误并给出解决方案通过测试\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "代码功能归根结底不是别人帮自己看或讲解或注释出来的；而是被自己静下心来花足够长的时间和精力亲自动手单步或设断点或对执行到某步获得的中间结果显示或写到日志文件中一步一步分析出来的。\r\n提醒：再牛×的老师也无法代替学生自己领悟和上厕所！\r\n单步调试和设断点调试（VS IDE中编译连接通过以后，按F10或F11键单步执行，按Shift+F11退出当前函数；在某行按F9设断点后按F5执行停在该断点处。）是程序员必须掌握的技能之一。", "Konwledge_Point": "动态规划", "Question": "c语言 回转寿司（排列组合问题） 有雏形\n盘子从厨师右边流向左边\n\n\n\n厨师连续做n盘寿司，放入回转寿司的传送列中\n\n最初的分叉点：\n\n最初的b盘寿司会流向上面的传送列，后面的n-b盘寿司流向下面的传送列\n\n或者\n\n最初的b盘寿司会流向下面的传送列，后面的n-b盘寿司流向下面的传送列\n\n1<=b<=n-1\n\n\n\n上面的列和下面的列都坐着客人\n\n上面的客人：会吃掉送过来的所有寿司，全部吃掉以后，会以最初传送过来的顺序或者与之相反的顺序把盘子放回传送列\n\n下面的客人和上面的客人完全一样。\n\n\n\n店员会把传送过来的空盘子叠成一叠，有可能叠成上面客人的盘子在上，也有可能叠成下面的客人的盘子在上\n\n\n\n碟子一共有10种(0,1,2,3,4,5,6,7,8,9)\n\n\n\n问最后一共有多少被叠起来的可能\n\n\n\n比如，流过来的碟子是0,1,2的时候\n\n一共有012,021,102,120,201,210这6种顺序\n\n\n\n输入格式：\n\n数据的个数L\n\n数据1\n\n数据2\n\n…\n\n数据L\n\n\n\n各数据代表盘子的排列方式（2<=盘子数量<=100）\n\n\n\n输出\n\n\n\n输出可能的排列数量\n\n<例1>\n\n输入\n\n3\n\n001\n\n12345\n\n0000\n\n输出\n\n3\n\n18\n\n1\n\n<例2>\n\n输入\n\n2\n\n012\n\n1234\n\n输出\n\n6\n\n12\n\n（还有一组是50个的比较大的数据，这个时候我自己写的程序运行就会直接结束）\n\n\n\n以下是代码雏形\n\n只需要修改reverse swap和chk_isnew（这个函数我应该没写错）部分\n\n（自己写了要求的函数部分，但是结果不对）\n\n\n\n #include \n#include \n#include \n\ntypedef int item;\ntypedef struct node *link;\n\n#define MAX_LEN 100\n#define MAX_RESULTS 1000\n\nstruct node\n{\n    char *p;\n    link next;\n};\nlink NEW(char *inp, link next)\n{\n    link x = malloc(sizeof(*x));\n    x->p = inp;\n    x->next = next;\n    return x;\n}\nvoid reverse(int sp,int ep,char*in)\n{\n    int i;\n    char temp;\n    for(i=0;i<(ep-sp+1)/2;i++){\n        temp=in[sp+i];\n        in[sp+i]=in[ep-(i+1)];\n        in[ep-(i+1)]=temp;\n    }\n    //reverse in[sp]...in[ep-1]\n}\nvoid swap(int sp,int ep,char *in)\n{\n    int i,j,k;\n    char temp[101];\n    char box1[101];\n    char box2[101];\n    for(i=0;ip,in)==0) return 0;\n        else t=t->next;\n    }\n    char *store = (char *)malloc(sizeof(char)*MAX_LEN);\n    memcpy(store,in,sizeof(char)*MAX_LEN);\n    *p_head = NEW(store, *p_head);\n    return(1);\n}\nint main(void)\n{\n    link head;\n    int num, cnt, i;\n    scanf(\"%d\", #);\n    int *result = (int *)malloc(sizeof(int)*MAX_RESULTS);\n    char *dish;\n    char *tmp_dish;\n    for(cnt=0; cntnext!=NULL)\n        {\n            t = t->next;\n        }\n        link r;\n        t = head;\n        while(t->next!=NULL)\n        {\n            r = t;\n            t = t->next;\n            free(r->p);\n            free(r);\n        }\n        free(dish);\n        free(tmp_dish);\n    }\n    for(cnt=0; cnt<num; cnt++)\n    {\n        printf(\"%d\\n\",result[cnt]);\n    }\n    return 0;\n}\n\n\n\n\n\n要求改写reverse,swap和chk_isnew的函数部分（chk_isnew应该没有错）\n\n非常长的问题有劳了", "Tag": "算法分析"}
{"Answer": "http://www.acmerblog.com/hdu-2224-the-shortest-path-3454.html", "Konwledge_Point": "动态规划", "Question": "The shortest path                   \nProblem Description\n\nThere are n points on the plane, Pi(xi, yi)(1 <= i <= n), and xi < xj (i\nBefore you reach the rightmost point Pn, you can only visit the points those have the bigger x-coordinate value. For example, you are at Pi now, then you can only visit Pj(j > i). When you reach Pn, the rule is changed, from now on you can only visit the points those have the smaller x-coordinate value than the point you are in now, for example, you are at Pi now, then you can only visit Pj(j < i). And in the end you back to P1 and the tour is over.\n\nYou should visit all points in this tour and you can visit every point only once.\n\n\n\nInput\n\nThe input consists of multiple test cases. Each case begins with a line containing a positive integer n(2 <= n <= 200), means the number of points. Then following n lines each containing two positive integers Pi(xi, yi), indicating the coordinate of the i-th point in the plane.\n\n\n\nOutput\n\nFor each test case, output one line containing the shortest path to visit all the points with the rule mentioned above.The answer should accurate up to 2 decimal places.\n\n\n\nSample Input\n\n3\n\n1 1\n\n2 3\n\n3 1\n\n\n\nSample Output\n\n6.47\n\n\n\nHint: The way 1 - 3 - 2 - 1 makes the shortest path.", "Tag": "算法分析"}
{"Answer": "http://poj.org/problem?id=3033", "Konwledge_Point": "动态规划", "Question": "Traveling Salesman                      \nProblem Description\n\nLong before the days of international trade treaties, a salesman would need to pay taxes at every border crossed. So your task is to find the minimum number of borders that need to be crossed when traveling between two countries. We model the surface of Earth as a set of polygons in three dimensions forming a closed convex 3D shape, where each polygon corresponds to one country. You are not allowed to cross at points where more than two countries meet.\n\n\n\nInput\n\nEach test case consists of a line containing c, the number of countries (4 ≤ c ≤ 6000), followed by c lines containing the integers n x1 y1 z1 … xn yn zn, describing (in order) the n corners of a closed polygon (3 ≤ n ≤ 20). Then follows a line with one integer m (0 < m ≤ 50), and then m lines with queries ca cb, where ca and cb are country numbers (starting with 1). No point will be on the line between two connected points, and -106 ≤ x, y, z ≤ 106 for all points. No two non-adjacent edges of a country share a common point. The input is terminated by a case where c = 0, which should not be processed.\n\n\n\nOutput\n\nFor each query, output the number of borders you must cross to go from ca to cb.\n\n\n\nSample Input\n\n6\n\n4 0 0 0 0 0 1 0 1 1 0 1 0\n\n4 1 0 0 1 0 1 1 1 1 1 1 0\n\n4 0 0 0 1 0 0 1 0 1 0 0 1\n\n4 0 1 0 1 1 0 1 1 1 0 1 1\n\n4 0 0 0 0 1 0 1 1 0 1 0 0\n\n4 0 0 1 0 1 1 1 1 1 1 0 1\n\n2\n\n1 2\n\n1 3\n\n0\n\n\n\nSample Output\n\n2\n\n1", "Tag": "算法分析"}
{"Answer": "将 n 个点的坐标排序（x 为主键）\r\n\r\n任取一点将 n 个点分成 2 组 n1 和 n2，求出 2 个面积 m1 和 m2\r\n\r\n从 n1 中取出最后的一个点，放入 n2 中，再求出 2 个面积 m'1 和 m'2\r\n\r\n如果 m'1+m'2 < m1+m2，则继续\r\n\r\n分别对重组后的 n1 和 n2 做如上操作\r\n\r\n直至满足 k 的数量要求，反之亦然\r\n\r\n其实你很快就会发现最小面积就是前 k-1 个点的 (maxx - minx)*(maxy-miny) + (n-k-1)", "Konwledge_Point": "动态规划", "Question": "如何用动态规划解决平面上的n个点用k个矩形覆盖的最小面积？\n假设有n个点，我们要用k个矩形去覆盖所用的点，然后这k个矩形的面积要尽可能小\n\n1）矩形的底是在x轴上的（其实就是直方图）\n\n2）矩形的面积可以为0（就是一条与x轴垂直的线）\n\n3）矩形不能重叠（边线与顶点也都不能重合）\n\n\n\n有人可以帮我一下吗？想了半天都没想出来怎么用动态规划解决这个问题", "Tag": "算法分析"}
{"Answer": "http://www.acmerblog.com/hdu-1501-Zipper-2058.html", "Konwledge_Point": "动态规划", "Question": "Zipper                   \nProblem Description\n\nGiven three strings, you are to determine whether the third string can be formed by combining the characters in the first two strings. The first two strings can be mixed arbitrarily, but each must stay in its original order.\n\n\n\nFor example, consider forming \"tcraete\" from \"cat\" and \"tree\":\n\n\n\nString A: cat\n\nString B: tree\n\nString C: tcraete\n\n\n\nAs you can see, we can form the third string by alternating characters from the two strings. As a second example, consider forming \"catrtee\" from \"cat\" and \"tree\":\n\n\n\nString A: cat\n\nString B: tree\n\nString C: catrtee\n\n\n\nFinally, notice that it is impossible to form \"cttaree\" from \"cat\" and \"tree\".\n\n\n\nInput\n\nThe first line of input contains a single positive integer from 1 through 1000. It represents the number of data sets to follow. The processing for each data set is identical. The data sets appear on the following lines, one data set per line.\n\n\n\nFor each data set, the line of input consists of three strings, separated by a single space. All strings are composed of upper and lower case letters only. The length of the third string is always the sum of the lengths of the first two strings. The first two strings will have lengths between 1 and 200 characters, inclusive.\n\n\n\nOutput\n\nFor each data set, print:\n\n\n\nData set n: yes\n\n\n\nif the third string can be formed from the first two, or\n\n\n\nData set n: no\n\n\n\nif it cannot. Of course n should be replaced by the data set number. See the sample output below for an example.\n\n\n\nSample Input\n\n3\n\ncat tree tcraete\n\ncat tree catrtee\n\ncat tree cttaree\n\n\n\nSample Output\n\nData set 1: yes\n\nData set 2: yes\n\nData set 3: no", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/counterm/article/details/6308881", "Konwledge_Point": "动态规划", "Question": "Bean Counting               \nThe CSC has decided to hold a contest to guess the number of beans in a given jar. To make it a wee bit more interesting, they decided to have the contestants guess the number of a particular kind of bean, the jar having many types of beans in it. Each participant would par $2.00 per guess.\n\nIf the guess is one off (either one greater or less) than the actual count, they get a single share of the total pot. If the guess is right on, they get two shares of the total pot.\n\n\n\nYour task is to tally these guesses and print out how much each person wins.\n\n\n\nInput\n\n\n\nThe first line will contain hundreds of letters, from a - z, each representing one bean of that type of bean. There will only be 26 different types of beans. The next line contains an integer n, the number of guesses. Each of the n following line will be the guess from a contestant. A contestant can guess as many times as they like. The line will begin with a single letter, in the range A - Z, leaving only 26 possible contests. The first letter will be followed by a single space, and then up to five pairs of letter/number combinations, the letter representing the type of bean for this guess, and the number the number of that bean the contestant expects to find. The letter and the value of a guess will be separated by a ':' and each guess on lines with more than one guess will be separated by a ','.\n\n\n\nProcess to the end of file.\n\n\n\nTallying:\n\n\n\nThe amount a contestant will receive is based on shares of a pot. The pot will consist of the total of all the guesses, at $2.00 per guess. The fraction each person gets will be based on:\n\n\n\nTotNum: total number of guesses by all contestants\n\nTotShares: total number of shares from all contestants\n\nOffOne: number of off-by-one guesses by that contestant\n\nRightOn: number if right-on guesses by that contestant\n\n\n\n(TotNum * $2.00) / TotShares * (OffOne + (RightOn * 2))\n\n\n\nOutput\n\n\n\nPrint out all the winners, in alphabetical order, and their winnings, separated by a single space. Each winner should be on a line by itself.\n\n\n\nSeparate output for different cases by a single blank line.\n\n\n\nSample Input\n\n\n\naadddddddddddddddddddddddffffffffffffffffwwwwwwwwwwwwccccalalala\n\n4\n\nA a:6,c:6\n\nB w:12\n\nC d:25\n\nD d:22,c:4,l:3,f:15\n\n\n\nSample Output\n\n\n\nA 3.20\n\nB 3.20\n\nD 9.60", "Tag": "算法分析"}
{"Answer": "你好，我是有问必答小助手，非常抱歉，本次您提出的有问必答问题，目前超出我们的服务范围，暂时无法为您解答。\n\n首次提问人员可免费体验一次有问必答服务。目前首次提问的问题服务范围为：编程语言、Java开发、python、数据库、前端开发 领域专业技术问题，为您提供问题的解决思路和指导。不提供源码代写、项目文档代写、论文代写、安装包资源发送或安装、软件使用指导等服务。\n\n我们后续会持续优化，扩大我们的服务范围，为您带来更好地服务。", "Konwledge_Point": "动态规划", "Question": "动态规划 C++ 急求\n【问题描述】\n\n\n\n助教小明给期末测验出了\n道算法题目。他希望在即将到来的期末测验试卷中使用其中\n道题目。\n\n\n\n每道算法题目都有一个难度等级。如果一次测验中的所有k道题目都有不同的难度等级，那么这次期末测试就是有区分度的。\n\n\n\n计算小明可以设计多少种有区分度的期末试卷。\n\n\n\n注：\n\n\n\n两份测验试卷当且仅当一份试卷中存在某一题目\n，而另一份试卷中不存在这个题\n，这两份试卷才有区别。\n\n\n\n输出结果对998,244,353取余。\n\n\n\n【输入形式】\n\n\n\n输入第一行包括两个用空格分隔开的整数\n和\n,\n\n\n\n输入第二行\n个用空格分开隔的整数\n，表示不同题目的难度。\n\n\n\n【输出形式】\n\n\n\n 一个整数，表示可设计的有区分度的期末试卷数目。结果对998,244,353取余\n\n\n\n【样例输入】\n\n\n\n\n5 2\n1 2 3 4 5\n\n\n\n【样例输出】\n\n\n\n\n10", "Tag": "算法分析"}
{"Answer": "更改如下：\nclear all\nclc\n% clc;clear;\n% A=[ 0 1 2 3 4];\n% A1=[0 1 2 3 4 5];\n% A2=[0 1 2 3 4 5 6];\n% B=nchoosek(A,3);\n% B1=nchoosek(A1,3);\n% B2=nchoosek(A2,3);\n% C=fliplr(B);\n% C1=fliplr(B1);\n% C2=fliplr(B2);\n% sum=[B;C];\n% sum1=[B1;C1];\n% sum2=[B2;C2];\n% [m,n]=size(sum);\n% [m1,n1]=size(sum1);\n% [m2,n2]=size(sum2);\nblank=0;\nblank1=0;\n% blank2=zeros(m2,1);\n%%\nsum11=0;\nfor i=0:4\n    %a4=sum(i,1);\n    switch i\n        case 0\n            a1=0;\n        case 1\n            a1=3;\n        case 2\n            a1=5;\n        case 3\n            a1=6;\n        case 4\n            a1=7;\n    end\n    for j=1:4\n        %b4=sum(j,2);\n        switch j\n            case 0\n                b1=0;\n            case 1\n                b1=4;\n            case 2\n                b1=6;\n            case 3\n                b1=7;\n            case 4\n                b1=8;\n        end\n        \n        for k=0:4\n            %c4=sum(k,3);\n            switch k\n                case 0\n                    c1=0;\n                case 1\n                    c1=2;\n                case 2\n                    c1=5;\n                case 3\n                    c1=9;\n                case 4\n                    c1=8;\n            end\n            if i+j+k==4\n                sum11=a1+b1+c1;\n                if blank<sum11\n                    blank=sum11;\n                    list=[i,j,k];\n                end\n            end\n            \n        end\n    end\nend\nMAX=blank %最大获利\nlist %z最终结果\n%%\n\nsum12=0;\nfor i=0:5\n    switch i\n        case 0\n            a1=0;\n        case 1\n            a1=3;\n        case 2\n            a1=5;\n        case 3\n            a1=6;\n        case 4\n            a1=7;\n        case 5\n            a1=6;\n    end\n    for j=0:5\n        switch j\n            case 0\n                b1=0;\n            case 1\n                b1=4;\n            case 2\n                b1=6;\n            case 3\n                b1=7;\n            case 4\n                b1=8;\n            case 5\n                b1=9;\n        end\n        for k=0:5\n            switch k\n                case 0\n                    c1=0;\n                case 1\n                    c1=2;\n                case 2\n                    c1=5;\n                case 3\n                    c1=9;\n                case 4\n                    c1=8;\n                case 5\n                    c1=8;\n            end\n            if i+j+k==5\n                sum12=a1+b1+c1;\n                if blank1<sum12\n                    blank1=sum12;\n                    list1=[i,j,k];\n                end\n            end\n        end\n    end\nend\nMAX1=blank1 %最大获利\nlist1 %z最终结果\n\n\n", "Konwledge_Point": "动态规划", "Question": "matlab动态规划问题。\n这里我只列出了订购4套和5套的情况，一开始以为能弄出所有排列情况即可，但是结果是我写的排列中没有出现数字有重复的排列，类似于（1，1，2）（1，1, 3)这样的有重复数字的排列，导致计算订购5套时只得到答案时（0，2，3），未得到正确答案（1，1，3），如何在此代码上进行修改从而把有重复数字的排列加进去？\n\n\nclc;clear;\nA=[ 0 1 2 3 4];\nA1=[0 1 2 3 4 5];\nA2=[0 1 2 3 4 5 6];\n\nB\n=nchoosek(A,3);\n\nB1\n=nchoosek(A1,3);\n\nB2\n=nchoosek(A2,3);\n\nC\n=fliplr(B);\n\nC1\n=fliplr(B1);\n\nC2\n=fliplr(B2);\nsum=[B;C];\nsum1=[B1;C1];\nsum2=[B2;C2];\n[m,n]=size(sum);\n[m1,n1]=size(sum1);\n[m2,n2]=size(sum2);\n\nblank\n=zeros(m,1);\n\nblank1\n=zeros(m1,1);\n\nblank2\n=zeros(m2,1);\n%%\n\nfor\n \ni\n=1:m\n        \na4\n=sum(i,1);\n        switch a4\n            case 0\n                \na1\n=0;\n            case 1\n                \na1\n=3;\n            case 2\n                \na1\n=5;\n            case 3\n                \na1\n=6;\n            case 4\n                \na1\n=7;\n        end\n                \n            \n        \nb4\n=sum(i,2);\n        switch b4\n            case 0\n                \nb1\n=0;\n            case 1\n                \nb1\n=4;\n            case 2\n                \nb1\n=6;\n            case 3\n                \nb1\n=7;\n            case 4\n                \nb1\n=8;\n        end\n            \n        \nc4\n=sum(i,3);\n        switch c4\n            case 0\n                \nc1\n=0;\n            case 1\n                \nc1\n=2;\n            case 2\n                \nc1\n=5;\n            case 3\n                \nc1\n=9;\n            case 4\n                \nc1\n=8;\n        end\n        \nif\n a4+b4+\nc4\n==4\n        \nsum11\n=a1+b1+c1;\n        blank(i,1)=sum11;\n        end\n    \nend\n\nMAX\n=max(blank);\n[q,w]=\nfind\n(\nblank\n==MAX);\n\nfinal\n=sum(q,:)\n%%\n\nfor\n \ni\n=1:m1\n        \na5\n=sum1(i,1);\n        switch a5\n            case 0\n                \na1\n=0;\n            case 1\n                \na1\n=3;\n            case 2\n                \na1\n=5;\n            case 3\n                \na1\n=6;\n            case 4\n                \na1\n=7;\n            case 5\n                \na1\n=6;\n                \n                \n        end\n                \n            \n        \nb5\n=sum1(i,2);\n        switch b5\n            case 0\n                \nb1\n=0;\n            case 1\n                \nb1\n=4;\n            case 2\n                \nb1\n=6;\n            case 3\n                \nb1\n=7;\n            case 4\n                \nb1\n=8;\n            case 5\n                \nb1\n=9;\n        end\n            \n        \nc5\n=sum1(i,3);\n        switch c5\n            case 0\n                \nc1\n=0;\n            case 1\n                \nc1\n=2;\n            case 2\n                \nc1\n=5;\n            case 3\n                \nc1\n=9;\n            case 4\n                \nc1\n=8;\n            case 5\n                \nc1\n=8;\n        end\n        \nif\n a5+b5+\nc5\n==5\n        \nsum22\n=a1+b1+c1;\n        blank1(i,1)=sum22;\n        end\nend\n        \nMAX1\n=max(blank1);\n[q1,w1]=\nfind\n(\nblank1\n==MAX1);\n\nfinal1\n=sum1(q1,:)\n\n\n\n\n1）当可分配设备数为4时，最终得到最优决策为（0,1,3）即1分厂不分配设备，2分厂分配1个设备，3分厂分配3个设备，得到最优解为13万元\n2）当可分配设备数为5时，最终得到最优决策为（1,1,3）即1分厂分配1台设备，2分厂分配1台设备，3分厂分配3个设备，得到最优解为16万元", "Tag": "算法分析"}
{"Answer": "树上背包问题，给你个参考题目https://www.luogu.com.cn/problem/P2014和你这个一样，具体可以去看他们的题解，他们写的会更详细。", "Konwledge_Point": "动态规划", "Question": "求解一道动态规划问题\n问题遇到的现象和发生背景\n\n\n共N门功夫，没门功夫伤害值为ti，没一门功夫都有0或1个先修功夫，有先修功夫的需要先学个先修功夫之后才能练习。小西现在想学习M门功夫,她想知道M门功夫能够造成的伤害值最大为多大?\n输入示例：\n6\n2 ，-1\n3， 2\n4， 0\n3， -1\n4 ，1\n5 ，0\n4\n输入第一行为N,接下来N行第-个数字是第i门功夫的伤害值和第i门功夫的先修功夫(0-indexed).如果没有先修功夫，则标记其先修功夫为-1.最后一行输入为M \n\n", "Tag": "算法分析"}
{"Answer": "看了代码有以下几个问题：\n1.在记录是否为障碍物的数组中，应该将其定义为bool类型而不是int类型，因为它只有两个取值，0和1。\n2.在记录是否为障碍物的数组中，应该将x和y的计算分别赋值给x和y，而不是将y赋值给x，这是因为y是dy数组中的元素，而dx数组中的元素应该赋值给x。\n3.在dp的过程中，应该从0开始循环到Bx和By，而不是从1开始循环到Bx-1和By-1，因为dp[0][0]表示的是起点，而dp[Bx-1][By-1]表示的是终点。\n4.dp[i][j]应该只在map[i][j]等于0的情况下更新，因为map[i][j]等于1表示这个点是障碍物，无法通过。\n这个是修改过后的代码，你可以参考一下\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define INF 1e9\nusing namespace std;\n\nint dx[] = {-2, -1, 1, 2, -2, -1, 1, 2};\nint dy[] = {-1, -2, -2, -1, 1, 2, 2, 1};\nbool map[22][22];\nint dp[22][22];\n\nint Bx, By, Hx, Hy;\n\nint main() {\n    memset(map, 0, sizeof(map));\n    cin >> Bx >> By >> Hx >> Hy;\n    map[Hx][Hy] = true;\n    for(int i = 0; i < 8; i++) {\n        int x = Hx + dx[i];\n        int y = Hy + dy[i];\n        if(x < 0 || y < 0 || x > Bx || y > By) continue;\n        map[x][y] = true;\n    }\n    dp[0][0] = 1;\n    for(int i = 0; i <= Bx; i++) {\n        for(int j = 0; j <= By; j++) {\n            if(!map[i][j]) {\n                if(i == 0 && j == 0) continue;\n                if(i == 0) dp[i][j] = dp[i][j-1];\n                else if(j == 0) dp[i][j] = dp[i-1][j];\n                else dp[i][j] = dp[i-1][j] + dp[i][j-1];\n            }\n        }\n    }\n    cout << dp[Bx][By] << endl;\n    return 0;\n}\n\n", "Konwledge_Point": "动态规划", "Question": "C++动态规划DP题\nDP题，马前卒，代码求指正\n思路是用map记录障碍点（记为1），dp时若非1则dp[i][j]=dp[i-1][j]+dp[i][j-1]\n原题洛谷：\nhttps://www.luogu.com.cn/problem/P1002\n\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ndefine\n INF 1e9\n\n\nusing\n \nnamespace\n std;\n\n\nint\n dx[]={\n-2\n,\n-1\n,\n1\n,\n2\n,\n-2\n,\n-1\n,\n1\n,\n2\n};\n\nint\n dy[]={\n-1\n,\n-2\n,\n-2\n,\n-1\n,\n1\n,\n2\n,\n2\n,\n1\n};\n\nbool\n map[\n22\n][\n22\n];\n\nint\n dp[\n22\n][\n22\n];\n\n\nint\n Bx,By,Hx,Hy;\n\n//dp[i][j]=dp[i-1][j]+dp[i][j-1]\n\n\nint\n \nmain\n()\n{\n    \nmemset\n(map,\n0\n,\nsizeof\n(map));\n    cin>>Bx>>By>>Hx>>Hy;\n    map[Hx][Hy]=\n1\n;\n    \nfor\n(\nint\n i=\n0\n;i<\n8\n;i++){\n        \nint\n x=Hx+dx[i];\n        \nint\n y=Hx+dy[i];\n        \nif\n(x<\n0\n||y<\n0\n||x>Bx||y>By)\ncontinue\n;\n        map[x][y]=\n1\n;\n    }\n    dp[\n0\n][\n1\n]=\n1\n;\n    \nfor\n(\nint\n i=\n1\n;i<Bx;i++){\n        \nfor\n(\nint\n j=\n1\n;j<By;j++){\n            \nif\n(map[i][j]==\n0\n)dp[i][j]=dp[i\n-1\n][j]+dp[i][j\n-1\n];\n        }\n    }\n    cout<<dp[Bx\n-1\n][By\n-1\n];\n    \nreturn\n \n0\n;\n} \n", "Tag": "算法分析"}
{"Answer": "return x<1&&y<1?false:true;这意思要x和y都小于1才是false？应该是x<1 || y<1吧，有一个小于1就不对了吧", "Konwledge_Point": "动态规划", "Question": "动态规划DP过河卒C++\n洛谷原题：\nhttps://www.luogu.com.cn/problem/P1002\n用的DP，但是WA，求指导\n思路是把所有坐标+1（坐标原点映射到（1，1）），再用数组E[][]标记马可能在的地方（用in函数避免数组越界），最后dp\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\n\n//f[i][j]表示走到（i,j）的总路径条数\n\n\n//转移方程：f[i][j]=f[i][j-1]+f[i-1][j] \n\n\nint\n Bx,By,Hx,Hy;\n\nint\n f[\n22\n][\n22\n],E[\n22\n][\n22\n];\n\n//坐标原点映射为（1，1） \n\n\n\n//检查是否在边界内\n\n\nbool\n \nin\n(\nint\n x,\nint\n y)\n{\n    \nreturn\n x<\n1\n&&y<\n1\n?\nfalse\n:\ntrue\n;\n} \n\n\nint\n \ndp\n(\nint\n Bx,\nint\n By,\nint\n Hx,\nint\n Hy)\n{\n    \n//马 \n\n    \nmemset\n(E,\n0\n,\nsizeof\n(E));\n    E[Hx][Hy]=\n-1\n;\n    \nfor\n(\nint\n i=\n-2\n;i<=\n2\n;i+=\n4\n)\nfor\n(\nint\n j=\n-1\n;i<=\n1\n;i+=\n2\n)\nif\n(\nin\n(Hx+i,Hy+j))E[Hx+i][Hy+j]=\n-1\n;\n    \nfor\n(\nint\n i=\n-1\n;i<=\n1\n;i+=\n2\n)\nfor\n(\nint\n j=\n-2\n;j<=\n2\n;j+=\n4\n)\nif\n(\nin\n(Hx+i,Hy+j))E[Hx+i][Hy+j]=\n-1\n;\n    \n//for(int i=1;i<=Bx;i++)f[i][1]=1;\n\n    \n//for(int j=1;j<=By;j++)f[1][j]=1;\n\n    f[\n1\n][\n0\n]=\n1\n;\n    \nfor\n(\nint\n i=\n1\n;i<=Bx;i++){\n        \nfor\n(\nint\n j=\n1\n;j<=By;j++){\n            \nif\n(E[i][j]==\n-1\n)f[i][j]=\n0\n;\n            \nelse\n f[i][j]=f[i][j\n-1\n]+f[i\n-1\n][j];\n        }\n    }\n    \nreturn\n f[Bx][By];\n}\n\n\nint\n \nmain\n()\n{\n    cin>>Bx>>By>>Hx>>Hy;\n    cout<<\ndp\n(Bx+\n1\n,By+\n1\n,Hx+\n1\n,Hy+\n1\n);\n    \nreturn\n \n0\n;\n} \n\n", "Tag": "算法分析"}
{"Answer": "数组越界你的二维数组定义为 int arr[1001][1001]，但是只读入了5行数字，所以当n大于5时，数组会越界。正确的定义应该是 int arr[1001][1001] = {0}，这样数组中的所有元素都会初始化为0，可以避免数组越界问题。\n贪心算法错误你的dp转移方程为 dp[i][j]=max(dp[i-1][j],dp[i-1][j-1])+arr[i][j]，这是贪心算法的思想，但是这个思想在本题中不适用。因为你要求的是从顶部到底部的最大路径和，但是这个路径上的数并不一定是每一行中的最大值。例如，在样例中，第1行的5是最大值，但是最大路径和的路径是 7->6->9->3->2，其中第1行的5并没有被选中。\n变量重复定义你在dp_function函数中定义了一个变量 dp，但是这个变量和外面的变量名相同，会导致变量重复定义的错误。建议将内部变量的名称更改为 dpArr。", "Konwledge_Point": "动态规划", "Question": "C++动态规划引入数字三角形\n原题洛谷：\nhttps://www.luogu.com.cn/problem/P1216\n照葫芦画瓢第一次写的DP，但是只通过了2/9，不知道哪里有问题，请求指导\n\n\n#include\n#include\n#include\n#include\nusing namespace std;\n\nint dp_function(int n){\n    int arr[\n1001\n][\n1001\n];\n    int dp[\n1001\n][\n1001\n];   //dp[i][j]=max(dp[i\n-1\n][j],dp[i\n-1\n][j\n-1\n])+arr[i][j]//request=dp[n\n-1\n][n\n-1\n]\n    for(int i=\n0\n;i<\n5\n;i++){\n        for(int j=\n0\n;j<=i;j++){\n        scanf(\n\"%d\"\n,&arr[i][j]);\n        if(i==\n0\n)dp[i][j]=arr[i][j];\n        if(j==\n0\n)dp[i][j]=dp[i\n-1\n][j]+arr[i][j];\n        }\n    }\n    for(int i=\n1\n;i<n;i++){\n        for(int j=\n1\n;j<n;j++){\n            dp[i][j]=max(dp[i\n-1\n][j],dp[i\n-1\n][j\n-1\n])+arr[i][j];\n        }\n    }\n    return dp[n\n-1\n][n\n-1\n];\n}\n\nint main(){\n    int n;\n    //dp[i][j]=max(dp[i\n-1\n][j],dp[i\n-1\n][j\n-1\n])+dp[i][j]//request=dp[n\n-1\n][n\n-1\n]\n    scanf(\n\"%d\"\n,&n);\n    printf(\n\"%d\"\n,dp_function(n));\n    return \n0\n;\n} \n\n", "Tag": "算法分析"}
{"Answer": "下面这个是我的：\n#include<bits/stdc++.h>\nusing namespace std;\nint n,x,l[1005],w[1005],u[1005],dp[1005];\nint main(){\n    scanf(\"%d %d\",&n,&x);\n    for(int i=1;i<=n;i++){\n        scanf(\"%d %d %d\",&l[i],&w[i],&u[i]);\n    }\n    for(int i=1;i<=n;i++){\n        for(int j=x;j>=u[i];j--){\n            dp[j]=max(dp[j]+l[i],dp[j-u[i]]+w[i]);\n        }\n        for(int j=u[i]-1;j>=0;j--){\n            dp[j]+=l[i];\n        }\n    }\n    printf(\"%lld\\n\",5*dp[x]);\n}\n\n你的其实没啥问题，只不过你的dp药要从0开始。因为就算没有药也有失败经验*_*.(要注意细节啊，满意就给个采纳吧^_^)", "Konwledge_Point": "动态规划", "Question": "动态规划五倍经验C++\n洛谷原题：\nhttps://www.luogu.com.cn/problem/P1802\n初学DP，只拿了40分，但总感觉代码没问题\n转移方程：f[i][j]=max(f[i-1][j]+lose[i],f[i-1][j-use[i]]+win[i]) \n\n\n#include\n#include\n#include\nusing namespace std;\nint n,x,lose\n[1002]\n,win\n[1002]\n,use\n[1002]\n;\nlong long f\n[1002]\n[1002]\n;\n//f\n[i]\n[j]\n表示用j瓶药拿到前i人的exp\n//f\n[i]\n[j]\n=max(f\n[i-1]\n[j]\n+lose\n[i]\n,f\n[i-1]\n[j-use\n[i]\n]\n+win\n[i]\n) \nlong long dp(int n,int x){\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=x;j++){\n            if(j>n>>x;\n    for(int i=1;i<=n;i++)cin>>lose\n[i]\n>>win\n[i]\n>>use\n[i]\n;\n    long long exp=dp(n,x);\n    cout<<5*exp;\n    return 0;\n}\n\n", "Tag": "算法分析"}
{"Answer": "对于等差数列有三种情况 上升、下降、不变\n可参考\nLeetcode 1027：最长等差数列（超详细的解法！！！）_coordinate_blog的博客-CSDN博客_最长等差子序列\n给定一个整数数组 A，返回 A 中最长等差子序列的长度。回想一下，A 的子序列是列表 A[i_1], A[i_2], ..., A[i_k] 其中 0 <= i_1 < i_2 < ... < i_k <= A.length - 1。并且如果 B[i+1] - B[i]( 0 <= i < B.length - 1) 的值都相同，那么序列 B 是等差的。...\n\n\n\nhttps://blog.csdn.net/qq_17550379/article/details/96623816\n\n", "Konwledge_Point": "动态规划", "Question": "最长等差数列动态规划\n\n\n\n\n能不能具体讲解一下这个状态转移方程，尽量细致一点，想了半天愣是想不通", "Tag": "算法分析"}
{"Answer": "a[i]代表第i个要释放的囚犯的编号,为了方便处理边界问题，我们把牢房的左墙壁和右墙壁也当作要释放的囚犯。\ndp[i][j]表示释放a[i]和a[j]之间应该要释放的囚犯所需要的最少金币数。", "Konwledge_Point": "动态规划", "Question": "贿赂囚犯，区间动态规划\n区间dp的i和j连续释放之间的囚犯是什么意思啊", "Tag": "算法分析"}
{"Answer": "import java.util.*;\r\nimport java.util.stream.Collectors;\r\n\r\nimport static java.util.stream.Collectors.*;\r\n\r\npublic class GroupTest {\r\n    public static void main(String[] args) {\r\n        double[] nums = {100.0, 1.0, 20.0, 50.0, 90.0, 91.0, 92.0, 31.0, 32.0, 63.0,\r\n        33.0, 45.0, 56.0, 78.0, 88.0, 99.0, 8.0, 13.0, 23.0, 53.0, 67.0};\r\n\r\n        int k = 8;\r\n\r\n        group(nums, k);\r\n    }\r\n\r\n    public static void group(double[] values, int countPerGroup) {\r\n        // order first, get len%countPerGroup from middle\r\n        // the left split to several groups\r\n\r\n        // calculate the average, get len%countPerGroup numbers which totally to it\r\n        // cycle, if min, select the max\r\n\r\n        Arrays.sort(values);\r\n\r\n        List lstNums = new ArrayList<>();\r\n        for(double value: values) {\r\n            lstNums.add(value);\r\n        }\r\n\r\n        List middleList = new ArrayList<>();\r\n        int midLen = values.length%countPerGroup;\r\n\r\n        if(midLen != 0) {\r\n            middleList = middle(lstNums, midLen, Arrays.stream(values).average().getAsDouble());\r\n        }\r\n\r\n        List> lstGroups = new ArrayList<>();\r\n        int groups = values.length/countPerGroup;\r\n        for(int i = 0; i < groups; i++) {\r\n            lstGroups.add(new ArrayList<>());\r\n        }\r\n\r\n        for(int i = 0; i < countPerGroup; i++) {\r\n            lstGroups = lstGroups.stream().sorted((a, b) -> {\r\n                double total_a = a.stream().reduce(0.0, Double::sum);\r\n                double total_b = b.stream().reduce(0.0, Double::sum);\r\n                return Double.compare(total_a, total_b);\r\n            }).collect(Collectors.toList());\r\n\r\n            lstGroups.forEach(group -> {\r\n                group.add(max(lstNums));\r\n            });\r\n        }\r\n\r\n        if(midLen != 0) {\r\n            lstGroups.add(middleList);\r\n        }\r\n        lstGroups.forEach(group -> {\r\n            System.out.println(\"average:\" + group.stream().reduce(0.0, Double::sum)/group.size()\r\n                    + \", count:\" + group.size()\r\n            + \", elements:\" + group.toString());\r\n        });\r\n    }\r\n\r\n    public static List middle(List values, int count, double average) {\r\n        List middleList = new ArrayList<>();\r\n\r\n        if(count == 1) {\r\n            middleList.add(mostNear(values, average));\r\n        } else {\r\n            List tmp = middle(values, count - 1, average);\r\n            double total = 0.0;\r\n            for(double value : tmp) {\r\n                total = total + value;\r\n            }\r\n\r\n            middleList.addAll(tmp);\r\n            middleList.add(mostNear(values, average * count - total));\r\n        }\r\n\r\n\r\n        return middleList;\r\n    }\r\n    public static double mostNear(List values, double average) {\r\n        double nearestValue = 0.0;\r\n        double gap = values.stream().max(Double::compareTo).get();\r\n        for(double value: values) {\r\n            if(Math.abs(value - average) < gap) {\r\n                gap = Math.abs(value - average);\r\n                nearestValue = value;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        // remove from the list\r\n        values.remove(nearestValue);\r\n        return nearestValue;\r\n    }\r\n\r\n    public static double max(List values) {\r\n        double maxValue = values.stream().max(Double::compareTo).get();\r\n\r\n        values.remove(maxValue);\r\n        return maxValue;\r\n    }\r\n\r\n}", "Konwledge_Point": "动态规划", "Question": "java数据分组  动态规划 遗传算法\nn个小数待分组，每个数组k个，如果n%k==0,那么组数为n/k个，如果n%k!=0,则最后一组的数量为n%k,组数为n/K+1,要求每个组的均值相等或者相近！", "Tag": "算法分析"}
{"Answer": "\n#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    int n, k,cnt=0;\n    cin >> n >> k;\n    vector<long long> d(n);\n    for (int i = 0; i < n; i++) {\n        cin >> d[i];\n    }\n    vector<long long> dp(n + 1, 0);\n    for (int i = 1; i <= n; i++) {\n\n        if(i>1){\n                cnt+=1;\n            dp[i] = min(dp[i-1]+k+1,dp[i-1]+d[cnt]-d[cnt-1]);\n        }\n\n        else\n        dp[i] = dp[i-1]+k+1;\n    }\n    /*for (int i=1; i <= n; i++) {\n       cout<<dp[i]<<endl;\n    }*/\n    cout << dp[n] << endl;\n    return 0;\n}\n\n", "Konwledge_Point": "动态规划", "Question": "C++算法题（动态规划算法）\n贝西喜欢看Mooloo的节目。因为贝西是一头忙碌的奶牛，她已经计划了接下来N（1≤N≤10^5）天的时间表，她将观看Mooloo。因为Mooloo是一项付费订阅服务，她现在需要决定如何将需要支付的金额降至最低。\n\n\nMooloo有一个有趣的订阅系统：连续d天订阅Mooloo需要d+K（1≤K≤10^9）元钱。您可以随时启动订阅，如果当前订阅到期，您可以根据需要多次启动新订阅。考虑到这一点，计算出贝西为了完成她的计划需要支付的最低金额。\n\n\nINPUT FORMAT（输入来自终端/stdin）：\n\n\n第一行包含整数N和K。\n\n\n第二行包含N个整数，描述贝西观看Mooloo的天数：1≤d1<d2<……<dN≤10^14。\n\n\nOUTPUT FORMAT（输出格式）（将输出打印到终端/标准输出）：\n\n\n请注意，此问题中涉及的大整数大小可能需要使用64位整数数据类型（例如，C/C++中的“long-long”）。\n\n\n样本输入：\n\n\n2 4\n\n\n7 9\n\n\n样本输出：\n\n\n7.\n\n\n贝西在第7天购买了为期三天的订阅，花费d+K=3+4=7元。\n\n\n样本输入：\n\n\n2 3\n\n\n1 10\n\n\n样本输出：\n\n\n8.\n\n\n贝西第一天购买一天的订阅，花费d+K=1+3=4元。贝西还在第10天购买一天的订阅，花费d+K=1+3=4元。贝西总共花了8元。\n\n\n评分：\n\n\n输入3-5:N≤10\n\n\n输入6-12：无额外限制。\n\n\n这是今天学校布置的题目，我不会，希望各位帮忙解答一下（用C++的算法进行），最希望给出代码和思路！", "Tag": "算法分析"}
{"Answer": "这一道题很容易被误认为机器人路径问题，但你仔细看看这个题目，这个是4行5列，你用的是5行5列的，应该用4行4列的。", "Konwledge_Point": "动态规划", "Question": "简单动态规划问题（寻找路径条数）\n问题遇到的现象和发生背景\n\n\n蓝桥杯上的题\n视频链接：\nhttps://www.bilibili.com/video/BV1qE411E7UK?p=3\n\n\n问题相关代码，请勿粘贴截图\n\n\n#include \n\nint main()\n{\n    long f[\n5\n][\n5\n]={\n0\n};\n    int i,j;\n    for(i=\n0\n;i<\n5\n;i++)\n        for(j=\n0\n;j<\n5\n;j++)\n            {\n                if(i == \n0\n and j == \n0\n) //递推边界\n1\n f[\n0\n][\n0\n]=\n1\n\n                    f[\n0\n][\n0\n] = \n1\n;\n                else if(i == \n0\n and j > \n0\n)//递推边界\n2\n，x=\n0\n时；\n                    f[\n0\n][j] = f[\n0\n][j - \n1\n];\n                else if(i > \n0\n and j == \n0\n)//递推边界\n3\n，y=\n0\n时；\n                    f[i][\n0\n] = f[i - \n1\n][\n0\n];\n                else\n                    f[i][j] = f[i - \n1\n][j] + f[i][j - \n1\n];//递推核心\n            }\n        printf(\n\"%d\"\n,f[\n4\n][\n4\n]);\n        return \n0\n; \n}\n\n\n\n\n运行结果及报错内容\n\n\n运行结果打印出的是70 而官方给出的答案却是是35\n\n\n我的解答思路和尝试过的方法\n\n\n  在这个问题中，不管是上面还是左边的字都可以接上下一个字，所以问题就转化成了“从起点（0，0）开始，移动至终点（4，4）有可以有多少条路线”.所以根据动态转移方程f[i][j] = f[i - 1][j] + f[i][j - 1]写出了以上代码。", "Tag": "算法分析"}
{"Answer": "一个标准的多重背包问题，\n\n#include <bits/stdc++.h>\nusing namespace std;\nint n,m;//n种牌，出m张,根据n、m的大小开二维数组d[n+1][m+1] \n//这里假设n小于100，m小于1000 \nint a[100],d[100][1000],s;//d[i][j]表示前i种牌出m张，一共多少种 \nint main()\n{\n    cin>>n>>m;\n    for(int i=1;i<=n;i++) cin>>a[i]; \n    d[0][0]=1;\n    for(int i=1;i<=n;i++){\n        d[i][0]=1;\n        s+=a[i];//前i种牌一共s张 \n        for(int j=1;j<=min(m,s);j++){//凑j张牌  //降维的话，这需要倒着做，参考01背包\n            for(int k=0;k<=min(a[i],j);k++){//取k张i ，这是一个多重背包 \n                d[i][j]+=d[i-1][j-k];\n                d[i][j]%=1e6+7;\n            } \n        }\n    } \n    cout<<d[n][m]; //降维的话，倒着做。 \n    return 0;\n}\n", "Konwledge_Point": "动态规划", "Question": "求大家帮我解答一下这道动态规划题\n现在有n种牌，第i种有ai张牌。\n\n\n现在要出m张牌，可以从手牌里任意选择。出牌时同一种牌需要放在一起，且不同种类的牌需要按牌的种类编号从小到大摆放。\n\n\n想知道一共有多少种出牌方式。对答案膜10^6 + 7的结果\n\n\n想了很久还是不会", "Tag": "算法分析"}
{"Answer": "1.把输入的数据放到数组里面；2.循环遍历相加，步长为3；3.把相加的数比较大小，去最大的一个。", "Konwledge_Point": "动态规划", "Question": "站外题！动态规划 ！求解！！\n求大神解答！\n题目：\n设有N 个正整数（1<=N<=1000），其中每一个均是大于等子1 小于等于10000的数。从这N个数中任取出若干个数（不能连续取相邻3个数）要求得到一种取法，使得到的和为最大。\n如：当N=6时，有6个数分别为：15,18 28 14 5 11 2133\n此时，有许多种取法，如：\n15, 18,45,33\n18. 28 21 33\n15. 28 45 33\n和为121就是满足要求的一种取法，\n\n\n输入数据的第一行是一个整数N\n第二行有N个符合条件的整数，数与数之间的间隔是用一个空格分开。\n输出数据仅有一行包含一个整数，即为满足条件的最大和。\n输入：\n6\n15 18 28 45 21 33\n输出：\n121", "Tag": "算法分析"}
{"Answer": "代码有一些问题。函数 leftsing 采用了递归的方式，这会导致程序在处理较大的输入时运行很慢，导致超时。此外程序没有处理可能出现的边界条件，例如 i 等于 0 时的情况。\n提供一个思路：\n首先，定义一个数组 dp，dp[i] 表示在前 i 个同学中出列最少的同学数，使得剩下的同学能排成合唱队形。\n对于每个同学，有两种选择：\n1、将其出列，这样的话，需要使得剩下的同学能排成合唱队形，就有 dp[i] = dp[i-1]。2、将其保留，这样的话，需要使得它的左右两侧的同学身高都比它低，可以使用一个数组 left[i] 表示在第 i 个同学的左侧，最多能保留多少个比它高的同学，使得剩下的同学能排成合唱队形。同理，可以使用一个数组 right[i] 表示在第 i 个同学的右侧，最多能保留多少个比它低的同学，使得剩下的同学能排成合唱队形。就有 dp[i] =dp[i] = min(dp[i], dp[left[i]] + dp[right[i]] + 1)\n于是，就可以得到状态转移方程：\ndp[i] = min(dp[i-1], dp[left[i]] + dp[right[i]] + 1)\n接下来，考虑如何求出 left[i] 和 right[i]。可以使用单调栈来维护一个递增的子序列。对于第 i 个同学，弹出栈中所有比它大的同学，并将它压入栈中。如果栈中有 k 个同学，就 left[i] = k，也就是在第 i 个同学的左侧最多能保留 k 个比它高的同学，使得剩下的同学能排成合唱队形。对于 right[i]，可以从后往前扫描数组，使用同样的方法求出。\n程序输出 dp[n] 就可以了。\n这是一种可行的做法，但是它的时间复杂度是 O(n^2)，可能还是不够优秀。如果想进一步优化，可以考虑使用更高效的算法，例如二分或者树状数组。仅供参考，望采纳，谢谢。", "Konwledge_Point": "动态规划", "Question": "关于动态规划合唱队问题的疑问！(语言-c语言)\n您的程序未能在规定时间内运行结束，请检查是否循环有错或算法复杂度过大。\n\n\n通俗来说，能找到一个同学，他的两边的同学身高都依次严格降低的队形就是合唱队形。\n例子：\n123 124 125 123 121 是一个合唱队形\n123 123 124 122不是合唱队形，因为前两名同学身高相等，不符合要求\n123 122 121 122不是合唱队形，因为找不到一个同学，他的两侧同学身高递减。\n\n\n你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。\n\n\n注意：不允许改变队列元素的先后顺序 且 不要求最高同学左右人数必须相等\n\n\n数据范围： 1 \\le n \\le 3000 \\1≤n≤3000 \n\n\n未通过样例:\n124\n16 103 132 23 211 75 155 82 32 48 79 183 13 91 51 172 109 102 189 121 12 120 116 133 79 120 116 208 47 110 65 187 69 143 140 173 203 35 184 49 245 50 179 63 204 34 218 11 205 100 90 19 145 203 203 215 72 108 58 198 95 116 125 235 156 133 220 236 125 29 235 170 130 165 155 54 127 128 204 62 59 226 233 245 46 3 14 108 37 94 52 97 159 190 143 67 24 204 39 222 245 233 11 80 166 39 224 12 38 13 85 21 47 25 180 219 140 201 11 42 110 209 77 136\n\n\n预期输出：95\n\n\n#\ninclude\n \n\n\n\n\nint\n \nleftsing\n(\nint\n *height,\nint\n num,\nint\n i)\n{\n//以第i个同学为基准左边最长上升子序列\n\n\n//前面i-1组中满足：1.height[j]\n0\n){\n      \nint\n max1=\n0\n,max2=\n0\n;\n      \nfor\n(\nint\n j=\n0\n;jmax1&&height[j]max2){\n            max2=\nleftsing\n(height,num,j);\n         }\n      }\n      \nif\n(max1>=max2){\n        \nreturn\n max1+\n1\n;\n      }\n      \nelse\n\n        \nreturn\n max2;\n    }\n    \nelse\n\n    \nreturn\n \n1\n;\n}\n//该函数输出正常\n\n\n\nint\n \nmain\n()\n \n{\n    \nint\n num=\n0\n;\n    \nscanf\n(\n\"%d\"\n,#);\n    \nint\n height[num];\n    \nfor\n(\nint\n i=\n0\n;ibest)\n          best=temp;\n    }\n    \nint\n min=num-best;\n    \nprintf\n(\n\"%d\"\n,min);\n    \nreturn\n \n0\n;\n}\n\n\n\n\n牛客刷题时遇到的问题，自测样例都能过，但是提交时就是0/20，而且报超时，用本地IDE输入错误的样例也是没有输出，很奇怪。", "Tag": "算法分析"}
{"Answer": "代码下载：https://download.csdn.net/download/caozhy/11449907\r\n\r\n\r\n![图片说明](https://img-ask.csdn.net/upload/201907/29/1564412731_903934.gif)\r\n\r\n\r\n\r\n```\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.ComponentModel;\r\nusing System.Data;\r\nusing System.Drawing;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Windows.Forms;\r\n\r\nnamespace Q770812\r\n{\r\n    public partial class Form1 : Form\r\n    {\r\n        public Form1()\r\n        {\r\n            InitializeComponent();\r\n        }\r\n\r\n        private int[,] area;\r\n\r\n        private int step = 1;\r\n\r\n        private void button1_Click(object sender, EventArgs e)\r\n        {\r\n            //step++;\r\n            for (int k = 0; k < step; k++)\r\n            {\r\n                for (int i = 0; i < 30; i++)\r\n                {\r\n                    for (int j = 0; j < 15; j++)\r\n                    {\r\n                        if (area[i, j] == 4) area[i, j] = 1;\r\n                    }\r\n                }\r\n                for (int i = 0; i < 30; i++)\r\n                {\r\n                    for (int j = 0; j < 15; j++)\r\n                    {\r\n                        if (area[i, j] == 0)\r\n                        {\r\n                            bool pt = false;\r\n                            for (int ii = (i > 0 ? i - 1 : 0); ii <= (i < 29 ? i + 1 : 29); ii++)\r\n                                for (int jj = (j > 0 ? j - 1 : 0); jj <= (j < 14 ? j + 1 : 14); jj++)\r\n                                {\r\n                                    if ((ii == i && jj != j) || (ii != i && jj == j))\r\n                                        if (area[ii, jj] == 1) pt = true;\r\n                                }\r\n                            area[i, j] = pt ? 4 : area[i, j];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            pictureBox1.Refresh();\r\n        }\r\n\r\n        private void pictureBox1_Paint(object sender, PaintEventArgs e)\r\n        {\r\n            if (area == null) return;\r\n            var g = e.Graphics;\r\n            g.FillRectangle(Brushes.White, 0f, 0f, pictureBox1.Width, pictureBox1.Height);\r\n            for (int i = 0; i < 30; i++)\r\n            {\r\n                for (int j = 0; j < 15; j++)\r\n                {\r\n                    Brush br = new SolidBrush(Color.FromArgb(110, 136, 199));\r\n                    switch (area[i, j])\r\n                    {\r\n                        case 0:\r\n                            br = new SolidBrush(Color.FromArgb(219, 213, 213));\r\n                            break;\r\n                        case 1:\r\n                            br = new SolidBrush(Color.FromArgb(202, 190, 180));\r\n                            break;\r\n                        case 3:\r\n                            br = new SolidBrush(Color.FromArgb(134, 134, 122));\r\n                            break;\r\n                    }\r\n                    g.FillRectangle(br, 10.0f + i * 20.0f, 10.0f + j * 20.0f, 18.0f, 18.0f);\r\n                }\r\n            }\r\n        }\r\n\r\n        private void button2_Click(object sender, EventArgs e)\r\n        {\r\n            area = new int[30, 15];\r\n            for (int i = 0; i < 30; i++)\r\n            {\r\n                for (int j = 0; j < 15; j++)\r\n                    area[i, j] = 0;\r\n            }\r\n            for (int i = 3; i <= 11; i++)\r\n            {\r\n                area[3, i] = 3;\r\n                area[4, i] = 3;\r\n            }\r\n            for (int i = 4; i <= 14; i++)\r\n            {\r\n                area[13, i] = 3;\r\n                area[14, i] = 3;\r\n            }\r\n            for (int i = 0; i <= 6; i++)\r\n            {\r\n                area[22, i] = 3;\r\n                area[23, i] = 3;\r\n            }\r\n            for (int i = 0; i <= 6; i++)\r\n            {\r\n                area[22, i] = 3;\r\n                area[23, i] = 3;\r\n            }\r\n            for (int i = 5; i <= 6; i++)\r\n            {\r\n                area[24, i] = 3;\r\n                area[25, i] = 3;\r\n                area[26, i] = 3;\r\n            }\r\n            area[8, 7] = 1;\r\n            step = 1;\r\n            pictureBox1.Refresh();\r\n        }\r\n\r\n        private void Form1_Load(object sender, EventArgs e)\r\n        {\r\n            button2.PerformClick();\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n```\r\nnamespace Q770812\r\n{\r\n    partial class Form1\r\n    {\r\n        /// \r\n        /// Required designer variable.\r\n        /// \r\n        private System.ComponentModel.IContainer components = null;\r\n\r\n        /// \r\n        /// Clean up any resources being used.\r\n        /// \r\n        /// true if managed resources should be disposed; otherwise, false.\r\n        protected override void Dispose(bool disposing)\r\n        {\r\n            if (disposing && (components != null))\r\n            {\r\n                components.Dispose();\r\n            }\r\n            base.Dispose(disposing);\r\n        }\r\n\r\n        #region Windows Form Designer generated code\r\n\r\n        /// \r\n        /// Required method for Designer support - do not modify\r\n        /// the contents of this method with the code editor.\r\n        /// \r\n        private void InitializeComponent()\r\n        {\r\n            this.pictureBox1 = new System.Windows.Forms.PictureBox();\r\n            this.button1 = new System.Windows.Forms.Button();\r\n            this.button2 = new System.Windows.Forms.Button();\r\n            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();\r\n            this.SuspendLayout();\r\n            // \r\n            // pictureBox1\r\n            // \r\n            this.pictureBox1.BackColor = System.Drawing.Color.White;\r\n            this.pictureBox1.Location = new System.Drawing.Point(30, 12);\r\n            this.pictureBox1.Name = \"pictureBox1\";\r\n            this.pictureBox1.Size = new System.Drawing.Size(616, 319);\r\n            this.pictureBox1.TabIndex = 0;\r\n            this.pictureBox1.TabStop = false;\r\n            this.pictureBox1.Paint += new System.Windows.Forms.PaintEventHandler(this.pictureBox1_Paint);\r\n            // \r\n            // button1\r\n            // \r\n            this.button1.Location = new System.Drawing.Point(431, 354);\r\n            this.button1.Name = \"button1\";\r\n            this.button1.Size = new System.Drawing.Size(90, 25);\r\n            this.button1.TabIndex = 1;\r\n            this.button1.Text = \"next\";\r\n            this.button1.UseVisualStyleBackColor = true;\r\n            this.button1.Click += new System.EventHandler(this.button1_Click);\r\n            // \r\n            // button2\r\n            // \r\n            this.button2.Location = new System.Drawing.Point(556, 354);\r\n            this.button2.Name = \"button2\";\r\n            this.button2.Size = new System.Drawing.Size(90, 25);\r\n            this.button2.TabIndex = 2;\r\n            this.button2.Text = \"reset\";\r\n            this.button2.UseVisualStyleBackColor = true;\r\n            this.button2.Click += new System.EventHandler(this.button2_Click);\r\n            // \r\n            // Form1\r\n            // \r\n            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);\r\n            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;\r\n            this.ClientSize = new System.Drawing.Size(673, 391);\r\n            this.Controls.Add(this.button2);\r\n            this.Controls.Add(this.button1);\r\n            this.Controls.Add(this.pictureBox1);\r\n            this.Name = \"Form1\";\r\n            this.Text = \"Form1\";\r\n            this.Load += new System.EventHandler(this.Form1_Load);\r\n            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).EndInit();\r\n            this.ResumeLayout(false);\r\n\r\n        }\r\n\r\n        #endregion\r\n\r\n        private System.Windows.Forms.PictureBox pictureBox1;\r\n        private System.Windows.Forms.Button button1;\r\n        private System.Windows.Forms.Button button2;\r\n    }\r\n}\r\n\r\n```", "Konwledge_Point": "动态规划", "Question": "请问下面这样的路径规划动态图应该如何制作\n", "Tag": "算法分析"}
{"Answer": "看着应该没问题，递归的话，n 如果大一点话，可能会栈溢出， 不知道这种情况是不是也是解答错误", "Konwledge_Point": "动态规划", "Question": "想问问以下两种动态规划方法有什么不同？为什么会导致结果不一样？\n第一种做法的思路是先不断递归求出下格子与右格子拿到的金币数，然后根据两者的最大值来判断是走下方还是走右方。期间使用了标记数组剪枝\n\n\ndef dfs(x,y):\n    if x > n-\n1\n or y > n-\n1\n:\n        return \n0\n\n    if x == n-\n1\n and y == n-\n1\n:\n        return nums[x][y]\n    if not used[x][y]:\n        used[x][y] = \nmax\n(\ndfs\n(x+\n1\n,y),\ndfs\n(x,y+\n1\n)) + nums[x][y]\n    return used[x][y]\n    \n    \nn = \nint\n(\ninput\n())\nnums = []\nfor i in \nrange\n(n):\n    nums.\nappend\n(\nlist\n(\nmap\n(int,\ninput\n().\nsplit\n())))\n    \nused = [[\n0\n for i in \nrange\n(n)] for j in \nrange\n(n)]\n\nprint\n(\ndfs\n(\n0\n,\n0\n))\n\n\n\n第二种思路是要想走到这个位置，就要看这个位置的上方拿的金币多点还是左方拿的金币多点，哪边拿得多就从哪边走过来\n\n\nnums = \n[]\n\nn = int(\ninput\n())\n\nfor\n \ni\n \nin\n range(n):\n    nums\n.append\n(list(map(int, \ninput\n()\n.split\n())))\n \ndp = \n[[0 for i in range(n)]\n \nfor\n j \nin\n range(n)]\n\ndp\n[0]\n[0]\n = nums\n[0]\n[0]\n\n\nfor\n \ni\n \nin\n range(\n1\n, n):\n    dp\n[i]\n[0]\n = dp\n[i - 1]\n[0]\n + nums\n[i]\n[0]\n\n    dp\n[0]\n[i]\n = dp\n[0]\n[i - 1]\n + nums\n[0]\n[i]\n\n\n\nfor\n \ni\n \nin\n range(\n1\n, n):\n    \nfor\n j \nin\n range(\n1\n, n):\n        dp\n[i]\n[j]\n = max(dp\n[i - 1]\n[j]\n, dp\n[i]\n[j - 1]\n) + nums\n[i]\n[j]\n\n \n\nprint\n(dp[n - \n1\n][n - \n1\n])\n\n\n\n\n一种做法能拿满分，另一种做法只能拿30分，没有出现运行超时的情况，都是解答错误.", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/discreeter/article/details/52005835", "Konwledge_Point": "动态规划", "Question": "不用动态规划，亲和串能做到不超时么？具体的代码和思路？\nProblem Description\n\n人随着岁数的增长是越大越聪明还是越大越笨，这是一个值得全世界科学家思考的问题,同样的问题Eddy也一直在思考，因为他在很小的时候就知道亲和串如何判断了，但是发现，现在长大了却不知道怎么去判断亲和串了，于是他只好又再一次来请教聪明且乐于助人的你来解决这个问题。\n\n亲和串的定义是这样的：给定两个字符串s1和s2,如果能通过s1循环移位，使s2包含在s1中，那么我们就说s2 是s1的亲和串。\n\n\n\nInput\n\n本题有多组测试数据，每组数据的第一行包含输入字符串s1,第二行包含输入字符串s2，s1与s2的长度均小于100000。\n\n\n\nOutput\n\n如果s2是s1的亲和串，则输出\"yes\"，反之，输出\"no\"。每组测试的输出占一行。\n\n\n\nSample Input\n\nAABCD\n\nCDAA\n\nASD\n\nASDF\n\n\n\nSample Output\n\nyes\n\nno", "Tag": "算法分析"}
{"Answer": "我怀疑你是故意的吧，哪怕是复制黏贴也好啊，看得头都大了。两个代码不是一样的。", "Konwledge_Point": "动态规划", "Question": "一道OJ动态规划题（Print Words in Lines），同样的代码用C++能通过，改写为C就不行\nC++版本\n\n\n\n//poj \n3390\n\n//sep9\n#include \n#include\nusing namespace std;\nconst int maxM=\n102\n;\nconst int maxN=\n10004\n;\nint dp[maxN+\n1\n][maxM+\n1\n];\nint \nL\n[maxN];\n\nint main()\n{\n    int cases;\n    scanf(\n\"%d\"\n,&cases);\n    while(cases--){\n        int m,n,s;\n        scanf(\n\"%d%d\"\n,&m,&n);\n        for(int i=\n1\n;i<=n;i++)\n            scanf(\n\"%d\"\n,&\nL\n[i]);\n        memset(dp,\n0x7f\n,sizeof(dp));\n        dp[\n0\n][m]=\n0\n;\n        for(int i=\n1\n;i<=n;i++){\n            int x=dp[maxN][maxM];\n            for(s=m;s>=\n0\n;--s)\n                x=min(x,dp[i\n-1\n][s]);    \n            dp[i][\nL\n[i]]=x+(m-\nL\n[i])*(m-\nL\n[i]);\n            for(s=\nL\n[i]+\n2\n;s<=m;++s){\n                int x=s-\nL\n[i]\n-1\n;\n                if(dp[i\n-1\n][x]==dp[maxN][maxM])\n                    continue;\n                int y=dp[i\n-1\n][x]-(m-x)*(m-x)+(m-s)*(m-s);\n                dp[i][s]=y;\n            }\n        }\n        int ans=dp[\n0\n][maxM];\n        for(s=\n0\n;s<=m;++s)\n            ans=min(ans,dp[n][s]);\n        printf(\n\"%d\\n\"\n,ans);\n    }\n    return \n0\n;    \n} \n\n\n\nc语言版本\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ndefine\n maxM 108\n\n\n#\ndefine\n maxN 10004\n\n\nint\n f[maxM+\n10\n][maxN+\n10\n];\n\nint\n L[maxN+\n1\n];\n\nint\n \nmin\n(\nint\n a,\nint\n b)\n{\n    \nif\n(a>b)\n        \nreturn\n b;\n    \nelse\n\n        \nreturn\n a;\n}\n\n\nint\n \nmain\n()\n\n\n{\n    \nint\n c,i,x,y,fine;\n    \nscanf\n(\n\"%d\"\n,&c);\n    \nwhile\n(c--){\n        \nint\n m,n,s;\n        \nscanf\n(\n\"%d%d\"\n,&m,&n);\n        \nfor\n(i=\n1\n;i<=n;++i)\n            \nscanf\n(\n\"%d\"\n,&L[i]);\n        \nmemset\n(f,\n0x7f\n,\nsizeof\n(f));\n        f[\n0\n][m]=\n0\n;\n\n        \nfor\n(i=\n1\n;i<=n;i++){\n            x=f[maxM][maxN];\n            \nfor\n(s=m;s>=\n0\n;s--)\n                x=\nmin\n(x,f[i\n-1\n][s]);\n            f[i][L[i]]=x+(m-L[i])*(m-L[i]);\n\n            \nfor\n(s=L[i]+\n2\n;s<=m;s++){\n                x=s-L[i]\n-1\n;\n                \nif\n(f[i\n-1\n][x]==f[maxM][maxN])\n                    \ncontinue\n;\n                y=f[i\n-1\n][x]-(m-x)*(m-x)+(m-s)*(m-s);\n                f[i][s]=y;\n            }\n        }\n\n        fine=f[maxM][maxN];\n        \nfor\n(s=\n0\n;s<=m;s++){\n            fine=\nmin\n(fine,f[n][s]);\n        }\n        \nprintf\n(\n\"%d\\n\"\n,fine);\n    }\n    \nreturn\n \n0\n;\n}\n\n\n", "Tag": "算法分析"}
{"Answer": "按照你的代码改的，有什么看不懂的再问我\n\n#include<iostream>\n#include<vector>\nusing namespace std;\nvector<vector<int>> generate(int numRows) {\n\n    //int i = numRows;\n\n    //int j = numRows;\n\n    vector<vector<int>> dp(numRows+1,vector<int>(numRows+1));               //代表的是第i行第j列的元素是多少\n\n    vector<vector<int>> st;\n\n    \n\n    for (int i = 0; i<=numRows; i++)\n\n        dp[i][0] = 1;\n\n\n\n    for (int j = 0; j<numRows; j++)\n\n        dp[j][j + 1] = 0;\n\n    st.push_back({ 1 });\n\n    for (int i = 1; i <= numRows; i++) {\n        vector<int> s;\n        s.push_back(dp[i][0]);\n        for (int j = 1; j <= i; j++) {\n\n            dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n\n            //s.push_back(dp[i, j]);\n            s.push_back(dp[i][j]);\n\n        }\n\n        st.push_back(s);\n\n    }\n\n    return st;\n\n}\n\nint main()\n{\n    vector<vector<int>> ans = generate(5);\n    for (size_t i = 0; i < ans.size(); ++i) {\n        for (size_t j = 0; j < ans[i].size(); ++j) {\n            cout << ans[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    system(\"pause\");\n    return 0;\n}\n", "Konwledge_Point": "动态规划", "Question": "我觉得这道杨辉三角思路应该是这样的，就是用动态规划，但感觉里面错误不少，有没有朋友愿意看一下啊。\n问题遇到的现象和发生背景\n\n\nhttps://leetcode-cn.com/problems/pascals-triangle/solution/\n\n\n问题相关代码，请勿粘贴截图\n\n\nclass\n \nSolution\n {\n\npublic\n:\n    vector> \ngenerate\n(\nint\n numRows) {\n        \nint\n i = numRows;\n        \nint\n j = numRows;\n        \nint\n dp[i][j];               \n//代表的是第i行第j列的元素是多少\n\n        vector> st;\n        vector<\nint\n> s;\n        \nfor\n(\nint\n i = \n0\n;i<numRows;i++)\n            dp[i][\n0\n] = \n1\n;\n\n        \nfor\n(\nint\n j = \n0\n;j<numRows;j++)\n            dp[j][j+\n1\n] = \n0\n;\n\n        \nfor\n(\nint\n i = \n1\n;i<=numRows;i++){\n            \nfor\n(\nint\n j = \n1\n;j<=i+\n1\n;j++){\n                dp[i][j] = dp[i\n-1\n][j\n-1\n] + dp[i\n-1\n][j];\n                s.\npush_back\n(dp[i,j]);\n            }\n            st.\npush_back\n(s);\n        }\n        \nreturn\n st;\n    }\n};\n\n\n\n\n运行结果及报错内容\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果", "Tag": "算法分析"}
{"Answer": "if (result == 0) 条件不满足的情况下就会执行。", "Konwledge_Point": "动态规划", "Question": "书上说这段代码是用动态规划优化了递归算法，但是像下面这样数组里的元素好像永远不会改变，那跟原本的递归不就没有区别了吗\n我想问一下，下面这段代码最后的 output[n] = result 意义是什么，在这段代码里它好像并不会执行。书上说这段代码是用动态规划优化了递归算法，但是像下面这样数组里的元素好像永远不会改变，那跟原本的递归不就没有区别了吗。\n\n\n\npublic class test2 {\n    public \nstatic\n \nint\n output[] = new \nint\n[\n1000\n];\n    public \nstatic\n \nvoid\n main(\nString\n[] args) {\n        \nSystem\n.\nout\n.println(\nmethod\n(\n6\n));\n    }\n    public \nstatic\n \nint\n \nmethod\n(\nint\n n){\n        \nint\n \nresult\n;\n        \nresult\n = output[n];\n        \nif\n (\nresult\n == \n0\n){\n            \nif\n (n == \n0\n)\n                \nreturn\n \n0\n;\n            \nelse\n \nif\n (n == \n1\n)\n                \nreturn\n \n1\n;\n            \nelse\n {\n                \nreturn\n (\nmethod\n(n - \n1\n) + \nmethod\n(n - \n2\n));\n            }\n        }\n        output[n] = \nresult\n;\n        \nreturn\n \nresult\n;\n    }\n}\n", "Tag": "算法分析"}
{"Answer": "if( len <= 1);因为这个分号，使得你后面的代码全成了废话了。return s成了必然执行的，可不是输入什麽就输出什麽麽", "Konwledge_Point": "动态规划", "Question": "我用c语言写了一段动态规划的寻找最长回文字符，可是总是不成功，找了半天，输入babad，却输出babad，以下是代码\n\n\nchar\n * \nlongestPalindrome\n(\nchar\n * s)\n\n\n{\n    \n//读取长度\n\n    \nint\n len = \nstrlen\n(s);\n    \nif\n( len <= \n1\n);\n    {\n        \nreturn\n s;\n    }\n    \n//定义布尔型\n\n    \nbool\n dp[\n1001\n][\n1001\n];\n    \nmemset\n(dp,\n0\n,\nsizeof\n(dp));\n    dp[\n0\n][\n0\n]=\n1\n;\n     \n//给长度为2的赋值，因为上面的排出，最短的长度就是2了\n\n     \nfor\n(\nint\n i =\n1\n; i < len;i++)\n     {\n      dp[i][i]=\ntrue\n;\n      \n//因为下面判断时候会出[1][0]的时候，不然会出错\n\n      dp[i][i\n-1\n]=\ntrue\n; \n     }\n    \nint\n left = \n0\n;\n    \nint\n right = \n0\n;\n    \nint\n max = \n0\n;\n    \n//k表示回文字节的长度，先从2开始\n\n    \nfor\n(\nint\n k=\n2\n; k <= len;k++)\n    {\n      \n//i表示回文字符的开始位置\n\n      \nfor\n(\nint\n i =\n0\n; i < len - k +\n1\n ;i++ ) \n     {\n       \nif\n(s[i] == s[i+k\n-1\n] && dp[i+\n1\n][i+k\n-2\n])\n       {\n            dp[i][i+k\n-1\n] =\ntrue\n;\n           \nif\n(max < k\n-1\n)\n           {\n              max = k\n-1\n;\n              left = i;\n              right = i+k\n-1\n;\n           }   \n       }\n     }\n    }\n    \nchar\n* arr = (\nchar\n*)\nmalloc\n(\nsizeof\n(\nchar\n)*(max*\n2\n));\n//因为 ap[X][Y]代表了2个字符，所以max*2才是最终的字符\n\n    \nint\n i =\n0\n;\n    \nfor\n(;left<=right;i++)\n    {\n     arr[i]=s[left++];\n    }\n    arr[i]=\n'\\0'\n;\n    \nreturn\n  arr;\n}\n", "Tag": "算法分析"}
{"Answer": "![](http://img.my.csdn.net/uploads/201301/23/1358910778_5267.jpg)", "Konwledge_Point": "动态规划", "Question": "C++ LCS 算法的问题???\n求最长公共字串，用后缀数组和动态规划相比，哪个更有优势？\n\n\n\n谢谢", "Tag": "算法分析"}
{"Answer": "最优二叉查找树和哈夫曼树都是动态规划算法中的经典问题，但它们是不同的问题，它们解决的问题也不同。\n最优二叉查找树问题是一个经典的搜索问题，旨在找到一个给定有序关键字序列的最优二叉查找树，使得在查询这些关键字时所需的比较次数最小。最优二叉查找树通常被用于数据库管理系统中，用于快速查找关键字。\n而哈夫曼树问题是一个经典的编码问题，旨在找到一个给定字符集的最优前缀编码方式，使得编码后的比特流长度最小。哈夫曼树通常被用于数据压缩和通信中，用于减小数据传输的大小。\n虽然这两个问题看起来相似，但它们解决的问题不同，所以它们的算法也有所不同。在最优二叉查找树算法中，我们需要计算一个有序关键字序列的最优查找树，而在哈夫曼树算法中，我们需要计算一个字符集的最优前缀编码方式。在最优二叉查找树中，我们需要计算每个关键字的概率，而在哈夫曼树中，我们需要计算每个字符的出现概率。\n总之，最优二叉查找树和哈夫曼树都是动态规划算法中的经典问题，但它们解决的问题不同，所以它们的算法也有所不同。", "Konwledge_Point": "动态规划", "Question": "最优二叉查找树和哈夫曼树\n动态规划算法里的最优二叉查找树就是哈夫曼树嘛？如果不是的话它们有什么区别呢？", "Tag": "算法分析"}
{"Answer": "i从1到n遍历，求出每个r[i]。求r[i]的方法是j从1到i-1遍历，求出最大的r[i-j]+r[j]，再将最大的r[i-j]+r[j]与p[i]比较，较大的一个就是r[i]，若p[i]较大，则将s[i]赋值i，否则赋值j。输出最优解就是输出s[i]，再把i赋值为i-s[i]，两个过程循环，直到i与s[i]相等。\n外层循环次数为n，内层循环次数为1+2+3+……+n-1，总体时间复杂度为O(n*n)\nc代码：\n\n#include<stdio.h>\nint main() {\n    int p[11] = {0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30}, r[11], s[11], n = 10;\n    int i, j;\n\n    //求r[i]和s[i]\n    i = 1;\n    while (i <= n) {\n        r[i] = p[i];\n        j = 1;\n        s[i] = i;\n        while (j < i) {\n            if (r[j] + r[i - j] >r[i]) {\n                r[i] = r[j] + r[i - j];\n                s[i] = j;\n            }\n            j++;\n        }\n        i++;\n    }\n\n    //输出最优解\n    printf(\"请输入长度: \");\n    scanf(\"%d\", &i);\n    while (i != s[i]) {\n        printf(\"%d \", s[i]);\n        i = i-s[i];\n    }\n    printf(\"%d\",s[i]);\n    return 0;\n}\n\n执行结果（为了方便显示，我临时套了个死循环）：", "Konwledge_Point": "动态规划", "Question": "这个算法题的3、4、5有没有会做的啊\n就写345问就行，有没有会写的啊，关于动态规划的.（这个提问要求30字实在没什么好写的、冲字数）", "Tag": "算法分析"}
{"Answer": "建模有两种，基于场景的建模和基于代码实现的建模。前者将实际场景抽象为人可以分析的数学模型，后者则是将实际场景（或者是经过“提纯”后的数学模型）转换为可以编码实现的类定义。实际使用时，最常见的是直接将实际场景映射为类定义，而数学建模则完全隐匿在这个转换中不可见。譬如我现在有一个基于图论的最短行程算法，想用它来解决不同仓库间的运输问题。首先进行数学建模，得把仓库和图中的节点对应起来，把路程和节点间距对应起来，把单位耗费和节点间距的权重对应起来，然后可以开始用那个方法来解决这个问题。简单的讲，就是先手算一遍，了解那些信息是必须的，这些必须的信息是如何为算法所用的。然后是到计算机代码的建模。如果你所使用的语言中已经有提供合适的模型类（譬如带长度权重的节点图），则可以直接使用。如果没有（一般总是没有的），那么这些东西就需要自己来实现，这样你的模型就有很多东西可以写了，譬如定义一个带长度和权重的路径类，带仓储容量的仓库类，由若干仓库对象及关联的路径对象组成的运输网类等等，然后在自己的算法中，就使用这些类的对象属性进行处理，而不要直接用那种一般人看不懂的abcd作为变量就行了。开头有点难，慢慢的会习惯的", "Konwledge_Point": "动态规划", "Question": "是根据算法建模还是根据模型采用算法?\n大佬们，我在写论文，题目早都定了，不能修改，叫基于动态规划的冷链物流路径优化研究，我去看了下采用动态规划思想的算法有Floyd算法，但是好像一般用于最短路，而路径优化研究没看到过关于这个算法的，我不知道该怎么扯得上关系建模了，或许是本来就不能关联，真的现在很混乱，导师又水，问了不回，让我去看别人论文怎么写的，救救孩子吧🙏🏻", "Tag": "算法分析"}
{"Answer": "那个貌似是滚动数组，01背包优化用到了", "Konwledge_Point": "动态规划", "Question": "用一维数组去代替二维数组，从而优化空间复杂度的方法叫什么啊，\n我想问一下，例如动态规划中，因为之前的数据用不到，用1个一维数组去代替二维数组是状态压缩吗？\n\n就是那种后算出来的数据去覆盖之前的数据。使空间被优化了。它就叫什么呢？", "Tag": "算法分析"}
{"Answer": "在回答你问题的时候，想问下你，计划以后往哪个方向发展？如果Java 方向，这个大了去了，完全没必要c/c++，java 搞定一切。如果c/c++，例如Linux 驱动等，更没必要Java，没鸟用；建议走 c/c++职场十几年发展下来，得出一个结论，你要精、精、精。当你很精一门之后，你会发现，其他没必要学，因为你已经是专家了，或者走向管理的路线。专家只会越来越深，不会把面扩的很广，你要知道公司里面有一批Java 人员。你需要的是在架构、设计上精通，底层、硬件精通；最后，你是在是有空的话，深入shell 、python。。。一定对你以后有好处。。。", "Konwledge_Point": "动态规划", "Question": "目前只会c和c++,有必要再学java或者其他语言吗\n背景：我是个女生，是计科的人工智能方向的大学生，打算明年考研。\n我现在只会c和c++,目前只会用c和c++刷算法题，没试过开发，只会动态规划、深度搜索那些算法，但我看就业好像都是收会java或者python的，非常犹豫要不要学一下java。可以给一些建议吗？", "Tag": "算法分析"}
{"Answer": "基于你对代码有一定的基础，我建议你尝试到b站上去学习尚硅谷的java基础视频，毕竟现在的主流还是java，早点接触会比较好，那个视频讲的非常详细，适合初学者学习", "Konwledge_Point": "动态规划", "Question": "大一学习方向，希望有人能提点提点\n我是一名大一学生，（双非普通一本）现在还是大类，下学期分流，能顺便提点下我该分流去哪儿的方向吗？🐣，现在学了c语言，数据结构自学了寒假但有些东西算法没有搞太明白，但自学有些不太懂，teather现在讲课又太慢了比如什么动态规划，我就完全搞不懂🦁，hash也没完全搞懂，我又不想浪费时间，就像先学学新语言c++或者Java但我不知道学啥🙈", "Tag": "算法分析"}
{"Answer": "\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\n\nint main() {\n    int cost[10]; // 存储行驶1到10公里的费用\n    int n; // 总路程数\n    int dp[1005]; // dp数组，dp[i]表示行驶i公里的最小花费\n    memset(dp, INF, sizeof(dp)); // 初始化为最大值，表示不可达\n\n    for (int i = 0; i < 10; i++) {\n        cin >> cost[i];\n    }\n    cin >> n;\n\n    dp[0] = 0; // 起点为0公里，花费为0\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= 10 && j <= i; j++) { // 从1到10公里选择一个乘车距离\n            dp[i] = min(dp[i], dp[i-j] + cost[j-1]); // 转移方程\n        }\n    }\n\n    cout << dp[n] << endl; // 输出结果\n\n    return 0;\n}\n\n", "Konwledge_Point": "动态规划", "Question": "绿色出行（green）\n绿色出行(green):为了保护环境，倡导“绿色出行”，小L每天都乘公共汽车上、下学。\nWH城市的公共汽车很特别，没有一辆公共汽车行驶超过10公里(但都是行驶整数公\n里)，所有街道在每公里处都有一个公共汽车站。一位顾客打算乘坐公共汽车行驶x公\n里，他可以通过多次的换乘车来完成他的旅程，顾客每次换乘车都根据他所乘坐的公\n里数来付费。小L的家和学校都恰好在公共汽车站处，相距n公里。小L是学生，在保护环境的同时当然忠要节省，他在想怎样换乘公共汽车，使得行驶n公里乘坐公共汽车的总费用最少。\n第一行十个整数分别表示行走1到10公里的费用(费用≤500)。注意这些数并无实际的经济意义，即行驶10公里费用可能比行驶1公里的少。\n第二行一个整数n表示，表示小L要乘坐的总路程数。\nOutput\n仅一行包含一个整数，表示最少的费用。1sns100。\nSample Input\n12 21 31 40 49 58 69 79 90 101\n15\nSample Output\n147\nSample Exp lanation\n  动态规划", "Tag": "算法分析"}
{"Answer": "这是一个NP-hard问题，通常需要采用启发式算法来求解。这里介绍一种贪心算法的思路，可能并不能保证达到最优解，但是可以得到一个比较好的近似解。\n首先，将所有任务按照区域编号升序排列。然后，对于每个经理，统计该经理已经负责的区域中的任务数量之和。对于每个任务，按照区域编号升序依次将其分配给还未负责该区域的任务数量最小的经理。如果存在多个经理任务数量相同时，选择任务数量之和最小的那个经理。最后，检查各个经理手上的任务数量，如果有经理比其他经理任务数量多出了两个或以上的任务，那么就从该经理手中数量最多的任务中选择一个，分配给任务数量最少的经理。\n下面是一个C++实现的代码示例（假设区域编号从1开始）：\n\n```c++\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\n// 定义经理和区域的类型\ntypedef vector<int> Manager;\ntypedef vector<int> Region;\n\n// 打印经理和区域的任务情况\nvoid print(const Manager& mgr, const Region& region) {\n    for (int i = 0; i < mgr.size(); ++i) {\n        cout << \"Manager \" << char('A' + i) << \":\";\n        for (int j = 0; j < region.size(); ++j) {\n            if (mgr[i] == j) {\n                cout << \" \" << region[j];\n            }\n        }\n        cout << endl;\n    }\n}\n\n// 贪心分配任务\nvoid assign(const Manager& mgr, const Region& region, Manager& result) {\n    // 统计每个经理已经负责的区域中的任务数量之和\n    map<int, int> taskCount;\n    for (int i = 0; i < mgr.size(); ++i) {\n        taskCount[i] = 0;\n        for (int j = 0; j < region.size(); ++j) {\n            if (mgr[i] == j) {\n                taskCount[i] += region[j];\n            }\n        }\n    }\n\n    // 按照区域编号升序分配任务\n    for (int i = 0; i < region.size(); ++i) {\n        int minTaskCount = INT_MAX;\n        vector<int> candidate;\n        for (int j = 0; j < mgr.size(); ++j) {\n            if (mgr[j] == i) continue;\n            if (taskCount[j] < minTaskCount) {\n                candidate.clear();\n                candidate.push_back(j);\n                minTaskCount = taskCount[j];\n            } else if (taskCount[j] == minTaskCount) {\n                candidate.push_back(j);\n            }\n        }\n        if (candidate.size() == 1) {\n            result[i] = candidate[0];\n            taskCount[candidate[0]] += region[i];\n        } else {\n\nint minSum = INT_MAX;\nint selected = -1;\nfor (int j : candidate) {\n    int sum = 0;\n    for (int k = 0; k < m; k++) {\n        sum += abs(data[k][j]);\n    }\n    if (sum < minSum) {\n        minSum = sum;\n        selected = j;\n    }\n}\n\n\n\n\n这段代码中，首先初始化 minSum 为整型最大值，selected 为 -1，然后遍历候选的区域经理，计算每个区域经理当前任务量的绝对值之和，即上文代码中的 calculateSum() 函数返回值，将结果保存在 sum 变量中，如果 sum 小于当前最小值 minSum，则将 minSum 更新为 sum，同时将 selected 更新为当前区域经理 j。最后返回选中的区域经理的编号 selected。\n```", "Konwledge_Point": "动态规划", "Question": "一个任务平均分配算法问题\n有ABCDE等多个区域经理，现在有区域一二三四等若干个区域的任务向区域经理分配，每个经理负责的区域不同，（例如A负责一二三，B负责二四 C负责三五六），并且每个区域经理手上已经可能存在一定量的任务，求一种算法思路使得尽可能的使每个经理手上最后分配到的任务数量相同。\n\n\n示例：A=1 B=60 C=5 D=5 E=10 F=40（每个经理手中初始任务数量）\n\n\n           区域一=20   区域二=15  区域三=10  区域四=10  区域五=0 (目前需要被分配的任务数量）\n\n\n          A负责区域一二三四\n\n\n          B负责区域一二三四\n\n\n          C负责区域一三四\n\n\n          D负责区域二\n\n\n          E负责区域三\n\n\n          F负责区域一四五\n\n\n这个例子最后期望是A=19 B=60 C=19 D=19 E=19 F=40\n\n\n我试过自己写贪心\\动态规划 但都在个别极端情况下出现了分配不均或局部不均的情况，可不可以给个思路，有C++的或者其他的代码更好。", "Tag": "算法分析"}
{"Answer": "读题：\n相比于其他普通大一计算机专业的学生，你已经相对很优秀了，当然如果你身边全是优秀并且勤奋的同学，你可能感觉不到这一点以我的理解，除了计算机组成原理、编译原理、计算机网络这些相对偏底层的科目外，其他本应该大二大三计算机专业才需要学习的课程，你现在都已经掌握了，常规课程进度已经跟不上你的学习进度你和你的家人都很快乐和谐，那么你可能是一个热爱生活的人，算法竞赛对你来说一眼就能看到头，翻来覆去就是那些算法、思路，而且看不到这些算法能解决什么实际生活中的问题，这对你来说有些迷茫和困惑，我在大学的时候也有这种困惑，现在回想起来如果有人在那个时候给我一些指点和帮助，可能我会更“厉害”一点读研读博最终都是在某一个领域深耕，也就是是在深度上下功夫，如果读研读博是你真实的想法，那么最终你需要回归到“深度”上面来\n我的建议是：\n课程要重视，学校学院的实践、活动要参加，以你的基础、学习能力和对生活的热爱，绩点和实践分数加起来，保研没问题学好数学，包括但不限于微积分、线性代数、概率论等，计算机的尽头是算法，算法的尽头是数学计算一些竞赛可以参加，一是能保研加分，二是能结交朋友，这对你以后的学习和工作会有帮助，不必过分在意证书，有兴趣和时间就去考，没有就不考了解本校优秀研究生导师，如果你有他的课程那就更好，看看他和他的学生在研究什么，如果有兴趣，你可以和导师了解，甚至到实验室“打工”，一般来说，优秀的导师都很喜欢这种有潜力有兴趣的学生，这会扩大你的知识面，也会让你结交更多朋友多了解计算机研究如何跟实际问题挂钩，激发兴趣，让“深耕”不那么枯燥，兴趣是最好的老师，比如新闻、招聘网站、博客、开源社区等，比如前段时间的chatGPT，比如很久之前的比特币，比如招聘网站上紧缺的人才等等，对有兴趣的方向通过搜索、学习和请教，了解大概，有机会的话去参加一些线上或线下的讲座，甚至了解本校或其他学校有没有这方面的专家，自己考不考虑去相关学校读研读博等别忘了和自己的父母讨论，你的父母都是高级知识分子，能给你一些帮助到了大三大四，自己大概也有个方向了，这时候不会再迷茫，再从这个方向完成深度的追求\n总结：\n打好基础，学好数学，热爱生活，参加竞赛，广交朋友，力争保研广泛涉猎，激发兴趣，父母建议，确定方向追求深度，读研读博", "Konwledge_Point": "动态规划", "Question": "大一计算机专业学生应该追求深度学习还是广度学习？\n我是某大学大一计算机科学与技术专业的学生。\n\n\n除了老师上课讲C语言程序设计基础外，我利用半年的时间自学了C++，数据结构与算法，和数据库管理系统MySQL。\n\n\n我身边的同学大多都在卷算法，学校集训队也会定期举行一些训练赛。我也刷了一些LeetCode上的算法题，但是我只能说我只是对一些基本的东西有所了解，比如递归回溯贪心深搜广搜动态规划啥常用的，有时候LeetCode上面的一些题目，还有ACM的题目对我来说有些费劲。\n\n\n我很有把握地说，我不想在算法竞赛上花费太多时间，只是因为我想更全面地发展。我的学习能力不需要怀疑，如果我真的想认真学算法，精通它，这只是时间的问题，所以不用考虑我是否能学好。\n\n\n所以说我想从更广度的方面进行学习，我下学期开学后回校准备继续用半年时间打磨我计算机的基本功，就是在计算机组成原理、计算机网络等计算机基础学科方面，然后大二参加一些竞赛，雨露均沾。\n\n\n另外的话，我的个人想法是希望我能读研读博，这是由我的家庭环境决定的，因为我妈妈就是博士，虽然发财是从来没有的，但是很有文化、有思想，我们家也过得很快乐，我也希望我也能一样，这也算是我的一种信仰吧。\n\n\n所以我是应该从广度的方面进行学习？还是从深度的方面进行学习呢？我更倾向前者，如果可以，我应该制定并遵循什么样的学习计划？可以考什么样的证书、参加比赛呢？", "Tag": "算法分析"}
{"Answer": "\n        g = y[i + 1];\n\n这里有访问越界", "Konwledge_Point": "动态规划", "Question": "vc中因为数组定义顺序不同，执行结果也不同\n问题遇到的现象和发生背景\n\n\n问题相关代码，请勿粘贴截图\n\n\n\n\n#\ninclude\n \n\n\n\nusing\n \nnamespace\n std;\n\n\ndouble\n \nnewTon\n(\ndouble\n s, \ndouble\n x[], \ndouble\n y[], \nint\n n)\n\n\n{\n\n    \ndouble\n p = y[\n0\n], g, f;\n    \nfor\n (\nint\n i = \n0\n; i < n; i++)\n    {\n        \nfor\n (\nint\n j = n - \n1\n; j > i; j--)\n        {\n            y[j] = (y[j] - y[j - \n1\n]) / (x[j] - x[j - i - \n1\n]); \n//动态规划\n\n        }\n        g = y[i + \n1\n];\n        \nfor\n (\nint\n k = \n0\n; k <= i; k++)\n            g *= (s - x[k]);\n        p += g;\n    }\n    \nreturn\n p;\n}\n\nint\n \nmain\n()\n\n\n{\n\n    \ndouble\n y1[\n3\n] = {\n0.36789441\n, \n0.135335283\n, \n0.049787068\n};\n    \ndouble\n x1[\n3\n] = {\n1\n, \n2\n, \n3\n};\n    cout << \nnewTon\n(\n2.6\n, x1, y1, \n3\n) << endl;\n\n    \ndouble\n x2[\n3\n] = {\n1\n, \n2\n, \n3\n};\n    \ndouble\n y2[\n3\n] = {\n0.36789441\n, \n0.135335283\n, \n0.049787068\n};\n    cout << \nnewTon\n(\n2.6\n, x2, y2, \n3\n) << endl;\n\n    \nreturn\n \n0\n;\n}\n\n\n\n运行结果及报错内容\n\n\n0.066365\n-0.317635\n\n\n我的解答思路和尝试过的方法\n\n\n在devc和vs里出来的两个答案是一样的，但在vc里是不同的\n\n\n我想要达到的结果", "Tag": "算法分析"}
{"Answer": "returnSize是个输出型参数。因为你要返回一个数组，但是数组返回的时候会退化成指针，你无法知道该数组有几个元素，所以需要传入一个输出型参数来表示数组的元素个数。所以这个参数在函数里面修改，你在函数外部可以拿到。int returnSize = 0；然后将&returnSize传入函数twoSum。", "Konwledge_Point": "动态规划", "Question": "returnSize 什么用\n问题遇到的现象和发生背景\n\n\n问题相关代码，请勿粘贴截图\n\n\n运行结果及报错内容\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果\n\n\n题目描述\n给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n示例:\n\n给定 nums = \n[\n2\n, \n7\n, \n11\n, \n15\n]\n, target = \n9\n\n\n因为 nums\n[\n0\n]\n + nums\n[\n1\n]\n = \n2\n + \n7\n = \n9\n\n所以返回 \n[\n0\n, \n1\n]\n\n\n来源：力扣（LeetCode）\n链接：https:\n//leetcode-cn.com/problems/two-sum\n\n\n完整程序代码：\n\n#\ninclude\n \n#\ninclude\n \n\n\n/* DS:Review */\n\n\n\n\nint\n* two\nSum(\nint\n*\n \nnums\n, \nint\n \nnumsSize\n, \nint\n \ntarget\n, \nint\n*\n \nreturnSize\n)\n{\n    \nint\n *a = (\nint\n *)malloc(sizeof(\nint\n)\n * \n2\n);\n//用动态规划的方法创建一个大小为2的数组\n\n    \nint\n i, j;\n    \nfor\n (i = \n0\n; i < numsSize - \n1\n; i++) {\n        \nfor\n (j = i + \n1\n; j < numsSize; j++) {\n            \nif\n (nums\n[\ni\n]\n + nums\n[\nj\n]\n == \ntarget) {\n                a\n[\n0\n]\n = i;\n                a\n[\n1\n]\n = j;\n                printf(\n\"%d---%d\"\n,i,j);\n                *returnSize = \n2\n;\n                return a;\n            }\n        }\n    }               \n    *returnSize = \n0\n;\n    return a;\n}\n\n\nint\n main(\nint\n argc, \nchar\n *argv\n[]\n) {\n    \nint\n nums\n[\n10\n]\n = {\n1\n,\n3\n,\n7\n,\n9\n,\n4\n,\n2\n};\n    \nint\n *returnSize;\n    two\nSum(\nnums\n,6,7,\nreturnSize\n)\n;\n    return \n0\n;\n}\n\n\n\n", "Tag": "算法分析"}
{"Answer": "参考：https://blog.csdn.net/weixin_42127177/article/details/122076403\nint getGiftMaxValue2(const int *values, int rows, int cols)\n    {\n        if (!values || !rows || !cols)\n            return 0;\n        int *maxValues = new int[cols];//一维数组的内存不能申请为rows的大小，除非rows在内层循环        \n        for (int i = 0; i < rows; ++i) \n        {\n            for (int j = 0; j < cols; ++j)\n            {\n                int left = 0;\n                int up = 0;\n                if (i > 0)\n                    up = maxValues[j];\n                if (j > 0)\n                    left = maxValues[j - 1];\n                maxValues[j] = max(up, left) + values[i*cols + j];\n            }\n        }\n        int maxValue = maxValues[cols - 1];\n        delete maxValues;\n        return maxValue;\n    }\n", "Konwledge_Point": "动态规划", "Question": "函数参数调用的问题，\n关于函数调用的问题。\n题目是一道动态规划的题目。\n在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？\n\n\n#include\nusing namespace std;\n#define maxn 105\nint a\n[maxn]\n[maxn]\n;\nint n,m;\n\nint fun(vector>& grid){\n      int m = grid.size();   \n        int n = grid\n[0]\n.size(); \n  \n    for(int i=0;i>n>>m;\n    int i,j;\n    vector>grid;\n    int sum;\n\n    for(i=0;i>grid\n[i]\n[j]\n;\n        }\n    }\n\n   sum=fun(vector>& grid);// 这里一直报错，请问这里应该怎么写参数。\n\n    cout<<sum;\n    \n\n\n    return 0;\n}\n\n\n\n\n关于函数参数调用的问题！", "Tag": "算法分析"}
{"Answer": "你第9行赋值给minCoins为coinCount了 ", "Konwledge_Point": "动态规划", "Question": "各位大神，我这里哪里出错了呀，，\n#找零兑换的动态规划\n\n\n\n#不知道哪里出错了！！！！！！老是提示 第6行 'int' object is not subscriptable\n\n\n\ndef dpMakeChange(coinValueList,change,minCoins,coinsUsed):\n    for cents in range(1,change+1):\n        coinCount = cents\n        newCoin = 1\n        for j in [c for c in coinValueList if c <= cents]:\n            if minCoins[cents - j] + 1 < coinCount:\n                coinCount = minCoins[cents - j] + 1 \n                newCoin = j\n        minCoins = coinCount\n        coinsUsed[cents] = newCoin\n    return minCoins[change]\n \nprint(dpMakeChange([1,5,10,21,25],63,[0] * 63))\n ", "Tag": "算法分析"}
{"Answer": "你的代码问题很明显啊，参数returnSize你没有给赋值啊。这样外边调用函数就不知道你返回的指针有多少个元素了。如果默认为0的话，就啥也不会干", "Konwledge_Point": "动态规划", "Question": "关于函数中的指针参数的问题\n问题遇到的现象和发生背景\n\n\n        我在力扣上刷题的时候，被一个函数的指针参数给难住了？想问一问关于指针参数的问题\n        问题是：\n\n\n\n杨辉三角 II\n给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。\n\n\n在「杨辉三角」中，每个数是它左上方和右上方的数的和。\n\n\n示例 1:\n\n\n输入: rowIndex = 3\n输出: [1,3,3,1]\n示例 2:\n\n\n输入: rowIndex = 0\n输出: [1]\n示例 3:\n\n\n输入: rowIndex = 1\n输出: [1,1]\n\n\n提示:\n\n\n0 <= rowIndex <= 33\n\n\n用代码块功能插入代码，请勿粘贴截图\n\n\n首先是出题人给的函数格式：\n\n\n/**\n * Note: The returned\n array \nmust be malloced, assume caller calls free().\n */\nint* getRow(int rowIndex, int* returnSize){\n\n}\n\n\n\n\n这是我写的代码：\n\n\nint\n* getRow(\nint\n rowIndex, \nint\n* returnSize){\n    \nint\n i,j;\n    \nint\n *\nrow\n=(\nint\n*)malloc(sizeof(\nint\n)*(rowIndex+\n1\n));                 //注意这里的“rowIndex+\n1\n”\n    memset(\nrow\n,\n0\n,sizeof(\nint\n)*(rowIndex+\n1\n));                          //这句也是\n    \nrow\n[\n0\n]=\n1\n;\n    \nfor\n(i=\n1\n;i<=rowIndex;i++){\n        \nfor\n(j=i;j>\n0\n;j\n--){\n\n            \nrow\n[j]+=\nrow\n[j\n-1\n];\n        }\n    }\n    \nreturn\n \nrow\n;\n}\n\n\n\n\n提交结果显示解答错误。\n\n\n下面这个是正确的版本：\n\n\nint\n* getRow(\nint\n rowIndex, \nint\n* returnSize){\n    \nint\n i,j;\n     *returnSize=rowIndex+\n1\n;                                       \n//用了它给的指针参数\n\n    \nint\n *\nrow\n=(\nint\n*)malloc(sizeof(\nint\n)*( *returnSize));      \n//把rowIndex+1 改成   *returnSize了\n\n    memset(\nrow\n,\n0\n,sizeof(\nint\n)*( *returnSize));                \n//这句也是\n\n    \nrow\n[\n0\n]=\n1\n;\n    \nfor\n(i=\n1\n;i<=rowIndex;i++){\n        \nfor\n(j=i;j>\n0\n;j--){\n            \nrow\n[j]+=\nrow\n[j-\n1\n];\n        }\n    }\n    \nreturn\n \nrow\n;\n}\n\n\n\n运行结果及报错内容\n\n\n\n\n具体错在哪我也不知道\n\n\n我的解答思路和尝试过的方法\n\n\n就用了个动态规划\n\n\n我想要达到的结果\n\n\n我想知道为啥用rowIndex+1就是错的，而用*returnSize就对了，应该是我在函数的指针参数这一块有些迷糊，想向大家请教一下函数的指针参数的知识，特别像上面这样的问题。", "Tag": "算法分析"}
{"Answer": "首先你的card肯定是个数组\n\n数据的格式大概是这样的\nexport default {\n  data() {\n    return {\n      list: [\n        {name: '二级菜单1'},\n        {name: '二级菜单2'},\n      ]\n    }\n  }\n}\n\n\n添加菜单的时候只需要向这个数组push一个节点this.list.push({name: '二级菜单3'})", "Konwledge_Point": "动态规划", "Question": "vue个人页如何可以自定义添加card\n前端框架：Ant Design Vue\n需求：我想给登录用户设置一个可以自我规划的以card形式添加系统内页面的功能，应该如何实现？\n具体样式大致如下：\n\n", "Tag": "算法分析"}
{"Answer": "网关获取到了吗 网关可达吗 网关可达的话看网关所在设备到Zongbu路由器有没有问题，如果你是中继获取的话记得把向外的路由打通", "Konwledge_Point": "动态规划", "Question": "新华三H3C动态地址访问遇到问题\n如图是我的实验拓扑图。其中PC_1是需要采用DHCP获取动态地址的。现在的情况是PC_1成功获取了一个IP地址（192.168.1.2），但是这个动态地址无法访问到Zongbu路由器，我需要怎样修改命令？", "Tag": "算法分析"}
{"Answer": "用对应的sql_id替换到的这个SQL进行查询 ，会查到对应的结果。结果是call 存储过程的命令，执行这个存储过程即可删除指定sql。切记执行存储过程时，你想删除的sql没有在运行。\n\nselect \n'call sys.dbms_shared_pool.purge('''||t.ADDRESS||','||t.hash_value||''',''c'')'\nSQL_TEXT,sql_id, address, hash_value, executions, loads, parse_calls, invalidations  \nfrom v$sql t where t.SQL_ID = '71bmxtwqmdq43'\n", "Konwledge_Point": "动态规划", "Question": "oracle 如何删除动态v$sql视图中的记录？\noracle 如何删除动态v$sql视图中的记录，比如想删指定的一条或者多条？", "Tag": "算法分析"}
{"Answer": "谁定的主色调是红色？ 我觉得就不应该是红为主色调，一般企业政府的网站都是蓝白色调为主。红色很两眼，起到点睛之笔还可以，作主色调我觉得不合适。", "Konwledge_Point": "动态规划", "Question": "一个论坛网站怎样设计，首页和子页面\n大家好，最近公司要求我和一个美工一起做一个论坛网站，名为“中国IT服务管理论坛”（itsmf）。两周前客户给出了第一份需求：\n\n关于中国IT服务管理论坛的初步需求如下：\n1、  由于论坛工作刚刚展开，网站需求暂时没法表达非常详尽，目前近期的规划是使首页初步成型，论坛动态、加入论坛以及联系我们等基本功能正常使用。\n\n2、  菜单项有如下几个：首页、关于论坛、论坛服务、最佳实践、出版物、论坛会员、加入论坛、联系我们\n•首页包含：公告通知、论坛动态、业界动态、会员单位、会员登录、友情链接\n•关于论坛中包含：论坛的倡议书、论坛章程、论坛组织结构\n•论坛服务中包含：咨询认证结果公示平台、IT服务管理软件使用平台等\n\n3、  会员制：会员登陆后能使用论坛服务以及其他功能。\n\n4、我们会提供论坛Logo，希望网站主色调为红色。\n不知通过上述需求，贵公司能否先设计一个网站大致的界面？也希望贵公司能提出宝贵意见！有问题，请随时沟通！  \n\n本周一的时候我们给他做了一个初步的模型：(模型截图见附件1\n\n\n\n\n[img]/upload/attachment/136177/487baa3f-f642-3fe4-b573-4785d7c2a061.jpg[/img]\n\n)\n\n\n\n但是客户很不满意，主要说颜色不是很符合他们的要求。之后，客户又提出了进一步的需求：\n\n下面需要将菜单上每一个菜单项对应调用的页面框架设计出来，\n1.关于论坛：应当包含论坛介绍，建议在页面的上部放置图片，图片下方左边可以论坛介绍的一些标题，例如论坛的倡议书、论坛章程、论坛组织结构等内容；图片下方右边就是每一个标题对应的内容。\n\n2.论坛服务：采用类似框架，左边是链接标题，包括咨询认证结果公示平台、IT服务管理软件使用平台等，右边是对应的内容\n\n3.最佳实践：采用类似框架，左边是链接标题，包括服务台介绍、事件处理流程、问题处理流程、变更处理流程、配置处理流程等，右边就是对应内容，应该设计为点击左边标题，则右边内容变为对应信息。\n\n4.出版物和论坛会员都是类似方式表示。\n\n然后我们提交了第二次的效果图：\n\n\n\n\n[img]/upload/attachment/136179/0eded2d3-6808-3b2f-aa13-2782b9df6859.png[/img]\n\n\n\n客户提出的意见如下：\n1.颜色还是不够让人舒服，色泽还需要调整；\n2.菜单框显得偏大，菜单文字偏小；\n3.页面布局还需要修饰，显得还不够专业。\n\n由于自己以前没做过网页设计（只做过一点JSP后台开发），美工也是刚毕业，才来公司不久，做的东西很难满足客户的要求。希望大家能提出你们宝贵的意见，或者提供一些类似的参考网站。\n\n\n\n\n我也知道我们做的这个网站很不专业，连我自己都不太看的过去，确实很难拿出手，但是客户那边又催得急。大家有什么话请尽管说，谢谢你们的帮助！", "Tag": "算法分析"}
{"Answer": "$(\".AddSection\").parent().parent().siblings(\".FormItemListEdit2\")", "Konwledge_Point": "动态规划", "Question": "Jquery如何选择到父父元素下的某个子元素（越多种方法越好）\n点击AddSection，给FormItemListEdit2下嵌套某个div，div已经用onclick动态生成\n\n\n\n \n\n\n准备工作\n    \n\n\n\n\n添加章\n添加节\n删除\n\n\n0字\n\n\n安排行程规划\n\n\n\n\n添加节\n删除\n0字\n\n", "Tag": "算法分析"}
{"Answer": "```\r\n下面这个函数是有问题的\r\n function cleananimated(time,a) { \r\n    var $right_content=$(\"#right_content\");\r\n    var $box_ul=$right_content.find(a);\r\n    $box_ul.mouseover(function () {\r\n        clearInterval(time);\r\n    }).mouseout(function () {\r\n        time1=setInterval(\"lianimated1()\",50);\r\n        return time1;\r\n    });\r\n}\r\n前面\r\n time1=cleananimated(time1,\"ul.content_box_ul\");\r\ntime2=cleananimated(time2,\"ul.visit_box_ul\"); //这里有time2，但上面函数在Out的时候只会改变time1。也就是最后time1,time2都会执行lianimated1这个函数定时\r\n```", "Konwledge_Point": "动态规划", "Question": "jqueryclearInterval怎么无法清除setInterval\n\n\n\n\n\n主站\n\n\n\n\n\n\n\n\n\n\n\n\n首页\n个人简介\n个人相册\n日志\n职业规划\n作品展示\n\n\n\n\n\n\n首页\n相册列表\n旅游相册\n动漫卡通\n大学时光\n职业规划\n大学生活\n活动参与\n实习打算\n我的日志\n星湖游记\n重庆一览\n荷塘月色\n个人简历\n姓名\n姓别\n工作经验\n作品展示\nps作品\nHTML作品\n经典瞬间\n\n\n\n\n\n\n\n\n\n\n\n\n日志动态\n\n\n我很不幸的过了英语四级啊06-13\n一女生说：生命科学院院长演讲一场，彻...04-13\n【转】班任为王，导员为皇，讲师为妃，...03-11\n一，当你发现自己不再盲目的喜欢跟风似...02-19\n很多人都认为节省能让他们的生活更保险...02-10\n请不要随意的对一个人下定义告诉你这样...02-09\n【转】我现在终于明白，其实爱情没那么...02-01\n请不要随意的对一个人下定义告诉你这样...01-19\n我很不幸的过了英语四级啊06-13\n一女生说：生命科学院院长演讲一场，彻...04-13\n【转】班任为王，导员为皇，讲师为妃，...03-11\n一，当你发现自己不再盲目的喜欢跟风似...02-19\n很多人都认为节省能让他们的生活更保险...02-10\n请不要随意的对一个人下定义告诉你这样...02-09\n【转】我现在终于明白，其实爱情没那么...02-01\n请不要随意的对一个人下定义告诉你这样...01-19\n\n\n\n\n\n\n个人简介\n我叫，\n                        来自。\n\n\n\n\n职业\n现学习软件工程，\n                        想从事软件开发。\n\n\n\n\n个人爱好\n喜欢古典文学，\n                        喜欢乒乓球。\n\n\n\n\n最近发生\n\n\n爬高压线触电身亡 身体被烧焦浓烟滚滚恐怖06-20\n抗日雷剧再现神技：自行车飞拦火车似直升机06-19\n成龙动作电影周落幕《战狼》豪取四奖成最大赢家06-18\n爬高压线触电身亡 身体被烧焦浓烟滚滚恐怖06-20\n抗日雷剧再现神技：自行车飞拦火车似直升机06-19\n成龙动作电影周落幕《战狼》豪取四奖成最大赢家06-18\n爬高压线触电身亡 身体被烧焦浓烟滚滚恐怖06-20\n抗日雷剧再现神技：自行车飞拦火车似直升机06-19\n成龙动作电影周落幕《战狼》豪取四奖成最大赢家06-18\n\n\n\n\n\n\n\n\n\n\n\n var len1=0;\nfunction lianimated1() {\n    var $right_content=$(\"#right_content\");\n    var $box=$right_content.find(\"div.content_box\");\n    var $box_ul=$right_content.find(\"ul.content_box_ul\");\n    var height=$box.height();\n    var ul_height=$box_ul.height();\n    if(len1<(ul_height-height)){\n        $box_ul.animate({marginTop: '-=' +10},\"slow\");\n        len1+=10;\n    }else{\n        $box_ul.animate({marginTop: '+=' +len1},0);\n        len1=0;\n    }\n}\nvar len2=0;\nfunction lianimated2() {\n    var $right_content=$(\"#right_content\");\n    var $box=$right_content.find(\"div.visit_box\");\n    var $box_ul=$right_content.find(\"ul.visit_box_ul\");\n    var height=$box.height();\n    var ul_height=$box_ul.height();\n    if(len2<(ul_height-height-60)){\n        $box_ul.animate({marginTop: '-=' +10},\"slow\");\n        len2+=10;\n    }else{\n        $box_ul.animate({marginTop: '+=' +len2},0);\n        len2=0;\n    }\n}\nfunction cleananimated(time,a) {\n    var $right_content=$(\"#right_content\");\n    var $box_ul=$right_content.find(a);\n    $box_ul.mouseover(function () {\n        clearInterval(time);\n    }).mouseout(function () {\n        time1=setInterval(\"lianimated1()\",50);\n        return time1;\n    });\n}\n", "Tag": "算法分析"}
{"Answer": "最外面少了[]\n\"daan\": [{\"A\", \"B\", \"C\", \"D\"}]不对。去掉 {}改成\"daan\": [\"A\", \"B\", \"C\", \"D\"]\n正确json格式\n[\n    {\n        \"根据事项所涉的责任单位，将工单分派到相关成员单位办理。以上是工单分派原则的那一种（)\": \"C\",\n        \"工单延期申请第一次延期时限为()工作日?\": \"C\",\n        \"以下哪项不符合成员单位提交的办理结果的要求:\": \"B\",\n        \"负责知识库更新维护的是:\": \"C\",\n        \"为热线工作的业务主管部门负责12345 热线规划、建设和管理工作。\": \"D\",\n        \"根据热线管理办法第三十四条市民投诉和举报的内容应()，须提供具体的联系方式和必要的情况说明，并根据特定情形配合提供相关材料或证据。\": \"C\",\n        \"在办理环节，咨询、表扬类工单距办结期限剩余的呈预警状态：投诉、举报、求助、建议类工单距办结期限剩余的呈预警状态。\": \"C\",\n        \"热线工单实行限时办结制，成员单位应当按照以下规定办理工单：咨询、表扬类单，一般须在个工作日内办结：投诉、举报、求助、建议类工单，一般须在个工作日内办结。\": \"B\",\n        \"以下对东莞12345热线受理范围解释最全面的是\": \"E\",\n        \"群众前往东莞市中级法院立案庭办事，过安检时被要求脱鞋子站到2个木箱上，其认为此举侵犯人权。同时其发现法院适用的设备是三无产品，并且没有通过3c认证。现对于中级法院使用三无产品及所采取的安检方法表示不满。其希望相关部门处理中级法院使用不合法产品以及违规安检的问题。以上案例不可以受理，其依据是（)\": \"A\",\n        \"话务服务满意度评价结果纳入咨询员工作绩效考核;办理情况满意度评价结果首次评为事项办理效果不满意，且诉求人有说明合理理由的工单，经热线管理中心审核后，对符合重办要求的发回成员单位重办，重办次数为次，按原工单类型时限要求办理，且不能申请延期;对不符合重办要求的向诉求人说明理由。\": \"A\",\n        \"分管领导、专职人员和应急联系人的姓名、职务、办公电话、手机号码等信息要向备案并保持动态更新。\": \"B\",\n        \"市民可通过电话、网站、等多种渠道反映非紧急类诉求。\": \"C\",\n        \"成员单位须在收到工单内反馈是否受理意见，工单办结时限均从工单受理后开始计算。\": \"D\",\n        \"市民来电查询某地址上的住户信息，该诉求涉及个人隐私，故不在受理范围。\": \"A\",\n        \"诉求人要求出具书面办理结果的，在符合法律法规和国家、省、市相关规章制度的情况下，成员单位应予以配合。\": \"A\",\n        \"成员单位须配合“直通12345”栏目组做好工单的跟踪、督办、采访、报道工作;应邀做客“直通12345”节目的，对市民在 节目中反映的诉求进行有效处理。\": \"A\",\n        \"工单超过受理期限或办结期限未作处理的，工单呈红牌状态。\": \"A\",\n        \"对涉及两个或者以上成员单位职责的事项，按照职责规定分别分派至成员单位办理，即拆单分派。\": \"B\",\n        \"市民来电表示中东国家都是一夫多妻制为什么我国只能一夫一妻。希望能修改有关法律法规，该诉求涉及法律法规和规章明确规定的情形，根据管理办法不在受理范围。可以建议市民向人大反映该类诉求。\": \"A\",\n        \"当履责意见超出有效期时，该类事项仍不具备办理条件的，成员单位须重新签订传。\": \"A\",\n        \"成员单位要明确应急联系人，指定工作机构，落实有综合协调职能的专职人员，统筹协调办理12345热线分派的属于本单位或下属单位职责范围的事项及其他相关工作。\": \"A\",\n        \"工单类型是咨询，成员单位可以申请延期，第一次延期为10个工作日。\": \"B\",\n        \"履责意见须附上具体办理工单的单位盖章及证明本单位已按照法律、职责规定履行职责的书面意见，自签发之日起，有效期为一年。\": \"B\",\n        \"工单的监察状态分为预警和红牌。\": \"A\",\n        \"市民如对执法部门的执法结果不满可以建议市民去对应部门进行行政复议。\": \"A\",\n        \"经查证，诉求内容纯属骚扰、恶意攻击、陷害、悔辱、详诱、馒骂，热线管理中心有权采取挂机、号码屏蔽等手段或提请有关部门依法进行处理。\": \"A\",\n        \"市民反映南城区鸿福路11号的兰州拉面店拒绝食客在餐馆内饮酒，且店内也没有提供猪肉类的食品。市民认为该类清真餐应入乡随俗，迎合当地人生活习惯。希望相关部门协调该餐厅提供猪肉类食品并售卖酒类饮品，该诉求涉及社会公序良俗和宗教信仰问题，根据管理办法不在受理范围。\": \"A\",\n        \"市民来电反映家中自来水管老化需要更换，咨询员可以直接下单受理。\": \"B\"\n    },\n    {\n        \"name\": \"【多选题】如遇特殊情况，哪些类型工单无法在规定时限内办结可申请延期答复?\",\n        \"daan\": [\"A\", \"B\", \"C\", \"D\"]\n    }, {\n        \"name\": \"【多选题】如遇特殊情况，工单无法在规定时限内办结的，以下哪些类型工单，可申请1次延期答复有以下：\",\n        \"daan\": [\"A\", \"B\", \"C\", \"D\"]\n    }, {\n        \"name\": \"【多选题】根据目前热线的操作规范，下列哪些指引是正确的是:\",\n        \"daan\": [\"A\", \"B\", \"C\"]\n    }, {\n        \"name\": \"【多选题】申请1次延期后，如有法律法规、规章或有关规范性文件明确规定办结时限超过上述时限，且确实无法在上述时限内办结的，以下哪些类型工单，可再次提交1次延期申请：\",\n        \"daan\": [\"B\", \"C\"]\n    }, {\n        \"name\": \"【多选题】以下哪些事项，热线是不予受理的？\",\n        \"daan\": [\"A\", \"B\", \"D\"]\n    }, {\n        \"name\": \"【多选题】经查证，诉求内容纯属骚扰、恶意攻击、陷害、侮辱、诽谤、谩骂，热线管理中心有权采取（）等手段或提请有关部门依法进行处理。\",\n        \"daan\": [\"B\", \"C\"]\n    }, {\n        \"name\": \"【多选题】符合管理办法不受理事项中“依照法定职责不属于本级政府及其工作部处理的事项”规定有:\",\n        \"daan\": [\"B\", \"C\"]\n    }, {\n        \"name\": \"【多选题】根据热线管理办法，热线的服务内容包括:\",\n        \"daan\": [\"A\", \"B\", \"C\", \"D\", \"E\"]\n    }, {\n        \"name\": \"【多选题】热线管理中心对以下情形进行督办:\",\n        \"daan\": [\"A\", \"B\", \"C\", \"D\"]\n    }, {\n        \"name\": \"【多选题】依法应当通过或已进入以下哪些途径解决的事项热线不予受理？\",\n        \"daan\": [\"A\", \"B\", \"C\", \"D\"]\n    }, {\n        \"name\": \"【多选题】热线建立满意度评价机制，市民可对（）和（）进行满意度评价。\",\n        \"daan\": [\"A\", \"B\"]\n    }, {\n        \"name\": \"【多选题】市民反映楼上住户装修施工导致其家里天花板漏水，但是一直没有支付维修费，随即向万江区人民法院提出起诉，但是法院一直没有开庭审批，其对此不满。希望有关部门要求法院尽快开庭审理。以上案例符合管理办法中不受理范围中的那些条理？\",\n        \"daan\": [\"B\", \"C\"]\n    }, {\n        \"name\": \"【多选题】当涉及等突发事项时，热线管理中心及时向应急部门通报情况，由应急部门通知相关单位按照《中华人民共和国突发事件应对法》等有关要求立即启动应急处置预案，并及时向社会公布处置结果。\",\n        \"daan\": [\"A\", \"B\", \"C\", \"D\", \"E\"]\n    }, {\n        \"name\": \"【多选题】以下不属于热线受理范围的是：\",\n        \"daan\": [\"A\", \"B\", \"C\", \"D\", \"E\"]\n    }, {\n        \"name\": \"【多选题】东莞市12345政府服务热线管理中心（以下简称“热线管理中心”）负责热线事项的哪些日常管理工作？\",\n        \"daan\": [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"]\n    }\n]\n\n\n", "Konwledge_Point": "动态规划", "Question": "josn的题库格式，能看下对不对吗\n{\n    \"根据事项所涉的责任单位，将工单分派到相关成员单位办理。以上是工单分派原则的那一种（)\": \"C\",\n    \"工单延期申请第一次延期时限为()工作日?\": \"C\",\n    \"以下哪项不符合成员单位提交的办理结果的要求:\": \"B\",\n    \"负责知识库更新维护的是:\": \"C\",\n    \"为热线工作的业务主管部门负责12345 热线规划、建设和管理工作。\": \"D\",\n    \"根据热线管理办法第三十四条市民投诉和举报的内容应()，须提供具体的联系方式和必要的情况说明，并根据特定情形配合提供相关材料或证据。\": \"C\",\n    \"在办理环节，咨询、表扬类工单距办结期限剩余的呈预警状态：投诉、举报、求助、建议类工单距办结期限剩余的呈预警状态。\": \"C\",\n    \"热线工单实行限时办结制，成员单位应当按照以下规定办理工单：咨询、表扬类单，一般须在个工作日内办结：投诉、举报、求助、建议类工单，一般须在个工作日内办结。\": \"B\",\n    \"以下对东莞12345热线受理范围解释最全面的是\": \"E\",\n    \"群众前往东莞市中级法院立案庭办事，过安检时被要求脱鞋子站到2个木箱上，其认为此举侵犯人权。同时其发现法院适用的设备是三无产品，并且没有通过3c认证。现对于中级法院使用三无产品及所采取的安检方法表示不满。其希望相关部门处理中级法院使用不合法产品以及违规安检的问题。以上案例不可以受理，其依据是（)\": \"A\",\n    \"话务服务满意度评价结果纳入咨询员工作绩效考核;办理情况满意度评价结果首次评为事项办理效果不满意，且诉求人有说明合理理由的工单，经热线管理中心审核后，对符合重办要求的发回成员单位重办，重办次数为次，按原工单类型时限要求办理，且不能申请延期;对不符合重办要求的向诉求人说明理由。\": \"A\",\n    \"分管领导、专职人员和应急联系人的姓名、职务、办公电话、手机号码等信息要向备案并保持动态更新。\": \"B\",\n    \"市民可通过电话、网站、等多种渠道反映非紧急类诉求。\": \"C\",\n    \"成员单位须在收到工单内反馈是否受理意见，工单办结时限均从工单受理后开始计算。\": \"D\",\n    \"市民来电查询某地址上的住户信息，该诉求涉及个人隐私，故不在受理范围。\": \"A\",\n    \"诉求人要求出具书面办理结果的，在符合法律法规和国家、省、市相关规章制度的情况下，成员单位应予以配合。\": \"A\",\n    \"成员单位须配合“直通12345”栏目组做好工单的跟踪、督办、采访、报道工作;应邀做客“直通12345”节目的，对市民在 节目中反映的诉求进行有效处理。\": \"A\",\n    \"工单超过受理期限或办结期限未作处理的，工单呈红牌状态。\": \"A\",\n    \"对涉及两个或者以上成员单位职责的事项，按照职责规定分别分派至成员单位办理，即拆单分派。\": \"B\",\n    \"市民来电表示中东国家都是一夫多妻制为什么我国只能一夫一妻。希望能修改有关法律法规，该诉求涉及法律法规和规章明确规定的情形，根据管理办法不在受理范围。可以建议市民向人大反映该类诉求。\": \"A\",\n    \"当履责意见超出有效期时，该类事项仍不具备办理条件的，成员单位须重新签订传。\": \"A\",\n    \"成员单位要明确应急联系人，指定工作机构，落实有综合协调职能的专职人员，统筹协调办理12345热线分派的属于本单位或下属单位职责范围的事项及其他相关工作。\": \"A\",\n    \"工单类型是咨询，成员单位可以申请延期，第一次延期为10个工作日。\": \"B\",\n    \"履责意见须附上具体办理工单的单位盖章及证明本单位已按照法律、职责规定履行职责的书面意见，自签发之日起，有效期为一年。\": \"B\",\n    \"工单的监察状态分为预警和红牌。\": \"A\",\n    \"市民如对执法部门的执法结果不满可以建议市民去对应部门进行行政复议。\": \"A\",\n    \"经查证，诉求内容纯属骚扰、恶意攻击、陷害、悔辱、详诱、馒骂，热线管理中心有权采取挂机、号码屏蔽等手段或提请有关部门依法进行处理。\": \"A\",\n    \"市民反映南城区鸿福路11号的兰州拉面店拒绝食客在餐馆内饮酒，且店内也没有提供猪肉类的食品。市民认为该类清真餐应入乡随俗，迎合当地人生活习惯。希望相关部门协调该餐厅提供猪肉类食品并售卖酒类饮品，该诉求涉及社会公序良俗和宗教信仰问题，根据管理办法不在受理范围。\": \"A\",\n    \"市民来电反映家中自来水管老化需要更换，咨询员可以直接下单受理。\": \"B\"\n}, {\n    \"name\": \"【多选题】如遇特殊情况，哪些类型工单无法在规定时限内办结可申请延期答复?\",\n    \"daan\": [{\"A\", \"B\", \"C\", \"D\"}]\n}, {\n    \"name\": \"【多选题】如遇特殊情况，工单无法在规定时限内办结的，以下哪些类型工单，可申请1次延期答复有以下：\",\n    \"daan\": [{\"A\", \"B\", \"C\", \"D\"}]\n}, {\n    \"name\": \"【多选题】根据目前热线的操作规范，下列哪些指引是正确的是:\",\n    \"daan\": [{\"A\", \"B\", \"C\"}]\n}, {\n    \"name\": \"【多选题】申请1次延期后，如有法律法规、规章或有关规范性文件明确规定办结时限超过上述时限，且确实无法在上述时限内办结的，以下哪些类型工单，可再次提交1次延期申请：\",\n    \"daan\": [{\"B\", \"C\"}]\n}, {\n    \"name\": \"【多选题】以下哪些事项，热线是不予受理的？\",\n    \"daan\": [{\"A\", \"B\", \"D\"}]\n}, {\n    \"name\": \"【多选题】经查证，诉求内容纯属骚扰、恶意攻击、陷害、侮辱、诽谤、谩骂，热线管理中心有权采取（）等手段或提请有关部门依法进行处理。\",\n    \"daan\": [{\"B\", \"C\"}]\n}, {\n    \"name\": \"【多选题】符合管理办法不受理事项中“依照法定职责不属于本级政府及其工作部处理的事项”规定有:\",\n    \"daan\": [{\"B\", \"C\"}]\n}, {\n    \"name\": \"【多选题】根据热线管理办法，热线的服务内容包括:\",\n    \"daan\": [{\"A\", \"B\", \"C\", \"D\", \"E\"}]\n}, {\n    \"name\": \"【多选题】热线管理中心对以下情形进行督办:\",\n    \"daan\": [{\"A\", \"B\", \"C\", \"D\"}]\n}, {\n    \"name\": \"【多选题】依法应当通过或已进入以下哪些途径解决的事项热线不予受理？\",\n    \"daan\": [{\"A\", \"B\", \"C\", \"D\"}]\n}, {\n    \"name\": \"【多选题】热线建立满意度评价机制，市民可对（）和（）进行满意度评价。\",\n    \"daan\": [{\"A\", \"B\"}]\n}, {\n    \"name\": \"【多选题】市民反映楼上住户装修施工导致其家里天花板漏水，但是一直没有支付维修费，随即向万江区人民法院提出起诉，但是法院一直没有开庭审批，其对此不满。希望有关部门要求法院尽快开庭审理。以上案例符合管理办法中不受理范围中的那些条理？\",\n    \"daan\": [{\"B\", \"C\"}]\n}, {\n    \"name\": \"【多选题】当涉及等突发事项时，热线管理中心及时向应急部门通报情况，由应急部门通知相关单位按照《中华人民共和国突发事件应对法》等有关要求立即启动应急处置预案，并及时向社会公布处置结果。\",\n    \"daan\": [{\"A\", \"B\", \"C\", \"D\", \"E\"}]\n}, {\n    \"name\": \"【多选题】以下不属于热线受理范围的是：\",\n    \"daan\": [{\"A\", \"B\", \"C\", \"D\", \"E\"}]\n}, {\n    \"name\": \"【多选题】东莞市12345政府服务热线管理中心（以下简称“热线管理中心”）负责热线事项的哪些日常管理工作？\",\n    \"daan\": [{\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"}]\n}", "Tag": "算法分析"}
{"Answer": "你看上个提问里面我的回答了吗，又开一个一样的。。", "Konwledge_Point": "动态规划", "Question": "android 百度地图 搜索跳转\n一共有两个Activity ，第一个Activity显示地图，实现定位当前地址并输出在第一个页面的EditText里，第二个Activity是搜索页面，搜索框是EditText，ListView显示搜索结果，使用百度地图建议搜索功能。比如搜索一个万达广场，点击搜索结果后希望在第一个Activity的地图上显示当前定位地址和到万达广场的路线规划，就是起点和终点显示出来。\n\n（这里需要起点自动获取，因为地图已经实现自动定位当前地址了，不要那种既要输入起点，又要输入终点，最后还得要点击一下确定，才会显示结果的那种无语的操作体验，整个软件是没有一个Bundle按钮的，只需要item）\n\n现在的问题是点击第二个页面ListView里面的搜索结果万达广场，跳转到第一个页面之后没有任何反应。\n\n谢谢各位大神哥哥姐姐~请帮我实现Intent ，使用的是startactivityforresult，数据传送和接收，在接收后的onActivityResult里面进行处理\n\n第一个页面\n\npublic class MainActivity extends Activity {\n\n\n\nprivate MapView mMapView = null;\nprivate BaiduMap mBaidumap =null;\nprivate PoiSearch mPoiSearch = null;\nprivate EditText mTv = null;\n\nprivate \n\nLocationClient mLocClient;\nprivate MainActivity.MyLocationListener myListener = new MainActivity.MyLocationListener();\nprivate int mCurrentDirection = 0;\nprivate Double lastX = 0.0;\nprivate MyLocationData locData;\nprivate float mCurrentAccracy;\nprivate double mCurrentLat = 0.0;\nprivate double mCurrentLon = 0.0;\nprivate String mCityName;\nboolean isFirstLoc = true;\nBitmapDescriptor mCurrentMarker;\nprivate SensorManager mSensorManager;\nprivate MyLocationConfiguration.LocationMode mCurrentMode;\nprivate MainActivity.DirectionSensorListener DirectionListener = new MainActivity.DirectionSensorListener();\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    SDKInitializer.initialize(getApplicationContext());\n    setContentView(R.layout.content_main);\n    mSensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);//获取传感器管理服务\n    mCurrentMode = MyLocationConfiguration.LocationMode.NORMAL;\n    //初始化地图\n    mMapView = (MapView) findViewById(R.id.mapView);\n    mTv = (EditText) findViewById(R.id.tiaozhuan);\n    mTv.setOnClickListener(new View.OnClickListener() {\n        @Override\n        public void onClick(View view) {\n            Bundle bundle = new Bundle();\n            bundle.putString(\"userName\", \"zhangsan\");\n            bundle.putInt(\"userAge\", 100);\n            Intent intent = new Intent(MainActivity.this, Main2Activity.class);\n            intent.putExtras(bundle);\n            startActivityForResult(intent, 1);//\n        }\n    });\n\n/*protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n    // TODO Auto-generated method stub\n    switch (requestCode){\n        case RESULT_OK:\n            Bundle bundle=data.getExtras();\n            String str=bundle.getString(\"backData\");\n            Toast.makeText(MainActivity.this, str,Toast.LENGTH_LONG).show();\n            break;\n\n        default:\n            break;\n    }*/\n    mBaidumap = mMapView.getMap();\n    mMapView.showScaleControl(false);\n    mMapView.showZoomControls(false);\n    UiSettings settings = mBaidumap.getUiSettings();\n    settings.setOverlookingGesturesEnabled(false);//设置双指下拉时不启用3D地图\n    settings.setRotateGesturesEnabled(false);//设置地图不可旋转\n    //开启定位图层\n    mBaidumap.setMyLocationEnabled(true);\n    initLocation();\n    //initPoiSearch();\n\n    mPoiSearch = PoiSearch.newInstance();\n    mPoiSearch.setOnGetPoiSearchResultListener(new OnGetPoiSearchResultListener() {\n@Override\npublic void onGetPoiDetailResult(PoiDetailResult poiDetailResult) {\n    if (poiDetailResult == null\n        || poiDetailResult.error == SearchResult.ERRORNO.RESULT_NOT_FOUND) {\n        Toast.makeText(MainActivity.this, \"未找到结果\", Toast.LENGTH_LONG)\n        .show();\n        return;\n    }\n    if (poiDetailResult.error == SearchResult.ERRORNO.NO_ERROR) {\n    //搜索到POI\n    mBaidumap.clear();\n    mBaidumap.addOverlay(new MarkerOptions()\n        .position(poiDetailResult.location)\n        .icon(BitmapDescriptorFactory.fromResource(R.drawable.alf))\n        .title(poiDetailResult.getAddress()));\n    //讲该POI设置为地图中心\n    mBaidumap.setMapStatus(MapStatusUpdateFactory.newLatLng(poiDetailResult.location));\n    Toast.makeText(MainActivity.this, \"搜索中...\", Toast.LENGTH_LONG).show();\n        return;\n    }\n}\n@Override\npublic void onGetPoiIndoorResult(PoiIndoorResult poiIndoorResult) {\n\n}\n@Override\npublic void onGetPoiResult(PoiResult poiResult) {\n\n        }\n    });\n}\n\nprivate void initLocation() {\n    mLocClient = new LocationClient(this);\n    mLocClient.registerLocationListener(myListener);\n    LocationClientOption option = new LocationClientOption();\n    option.setOpenGps(true);//打开GPS\n    option.setCoorType(\"bd09ll\");//设置坐标类型\n    option.setIsNeedAddress(true);//是否需要地址信息\n    option.setScanSpan(1000);\n    LocationPermission();\n    mLocClient.setLocOption(option);\n}\n\nprivate void LocationPermission() {\n    int checkPermission = ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_COARSE_LOCATION);\n    if (checkPermission != PackageManager.PERMISSION_GRANTED) {\n        ActivityCompat.requestPermissions(MainActivity.this, new String[]{Manifest.permission.ACCESS_COARSE_LOCATION}, 1);\n        Log.d(\"未获得定位权限\", \"弹出提示\");\n        return;\n    }\n}\n\npublic class DirectionSensorListener implements SensorEventListener {\n\n    @Override\n    public void onSensorChanged(SensorEvent event) {\n        double x = event.values[SensorManager.DATA_X];\n        if (Math.abs(x - lastX) > 1.0) {\n            mCurrentDirection = (int) x;\n            //设置定位数据\n            locData = new MyLocationData.Builder()\n                    .accuracy(mCurrentAccracy)//精度\n                    .direction(mCurrentDirection) //此处设置开发者获取到的方向信息，顺时针0-360\n                    .latitude(mCurrentLat)//经度\n                    .longitude(mCurrentLon)//纬度\n                    .build();\n            mBaidumap.setMyLocationData(locData);\n        }\n        lastX = x;\n    }\n    @Override\n    public void onAccuracyChanged(Sensor sensor, int accuracy) {\n\n    }\n}\npublic class MyLocationListener implements BDLocationListener {\n\n    @Override\n    public void onReceiveLocation(BDLocation bdLocation) {\n        //map view销毁后不在处理新接受的位置\n        if (bdLocation == null || mMapView == null) {\n            return;\n        }\n        mCurrentLat = bdLocation.getLatitude();\n        mCurrentLon = bdLocation.getLongitude();\n        mCurrentAccracy = bdLocation.getRadius();\n        mCityName = bdLocation.getCity();\n        //设置定位数据\n        locData = new MyLocationData.Builder()\n                .accuracy(bdLocation.getRadius())//精度\n                .direction(mCurrentDirection) //此处设置开发者获取到的方向信息，顺时针0-360\n                .latitude(bdLocation.getLatitude())//经度\n                .longitude(bdLocation.getLongitude())//纬度\n                .build();\n        mBaidumap.setMyLocationData(locData);\n        //第一次定位时，将地图位置移动到当前位置\n        if (isFirstLoc) {\n            isFirstLoc = false;\n            LatLng ll = new LatLng(bdLocation.getLatitude(), bdLocation.getLongitude());\n            MapStatus.Builder builder = new MapStatus.Builder();\n            builder.target(ll).zoom(18.0f);\n            mBaidumap.animateMapStatus(MapStatusUpdateFactory.newMapStatus(builder.build()));\n            mCurrentMarker = null;\n            mBaidumap\n                    .setMyLocationConfiguration(new MyLocationConfiguration(\n                            mCurrentMode, true, null));\n        }\n    }\n}\n@Override\nprotected void onStart() {\n    //为系统的方向传感器注册监听器\n    mSensorManager.registerListener(DirectionListener, mSensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION)\n            , SensorManager.SENSOR_DELAY_UI);\n    //启动监听\n    mLocClient.start();\n    super.onStart();\n}\n\n@Override\nprotected void onPause() {\n    mMapView.onPause();\n    super.onPause();\n}\n\n@Override\nprotected void onResume() {\n    mMapView.onResume();\n    super.onResume();\n}\n\n@Override\nprotected void onStop() {\n    //取消传感器监听\n    mSensorManager.unregisterListener(DirectionListener);\n    super.onStop();\n}\n\n@Override\nprotected void onDestroy() {\n    //退出时销毁定位\n    mLocClient.stop();\n    //关闭定位图层\n    mBaidumap.setMyLocationEnabled(false);\n    mMapView.onDestroy();\n    //mMapView = null;\n   // mPoiSearch.destroy();\n    //mSuggestionSearch.destroy();\n    super.onDestroy();\n}\n\n\n\n\n}\n\n第二个页面\n\npublic class Main2Activity extends Activity implements OnGetSuggestionResultListener {\n\n\n\nprivate EditText et_address;\nprivate Adapter_list_Address adapter_list_Address;\nprivate ListView myListView;\nprivate List list = new ArrayList<>();\nprivate List lists = new ArrayList<>();\n\n\n//地图相关\n/**\n * 百度地图控件\n */\nMapView mMapView = null;\n/**\n * 百度地图实例\n */\nBaiduMap mBaidumap = null;\n\n\n//定位相关\n/**\n * 定位客户端\n */\nLocationClient mLocClient;\n/**\n * 定位模式\n */\nprivate LocationMode mCurrentMode;\n/**\n * 定位图标\n */\nBitmapDescriptor mCurrentMarker;\n/**\n * 传感器管理器\n */\nprivate SensorManager mSensorManager;\n/**\n * 当前方向\n */\nprivate int mCurrentDirection = 0;\n/**\n * 当前经度\n */\nprivate double mCurrentLat = 0.0;\n/**\n * 当前纬度\n */\nprivate double mCurrentLon = 0.0;\n/**\n * 当前经度\n */\nprivate float mCurrentAccracy;\n/**\n * 是否首次定位\n */\nboolean isFirstLoc = true;\n/**\n * 定位数据\n */\nprivate MyLocationData locData;\n/**\n * 定位监听\n */\nprivate MyLocationListener myListener = new MyLocationListener();\n/**\n * 方向监听\n */\nprivate DirectionSensorListener DirectionListener = new DirectionSensorListener();\n/**\n * 上一次的方向\n */\nprivate Double lastX = 0.0;\n/**\n * 定位所在城市\n */\nprivate String mCityName;\n//poi搜索相关\n/**\n * Poi检索实例\n */\nprivate PoiSearch mPoiSearch = null;\nprivate SuggestionSearch mSuggestionSearch = null;\n\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    SDKInitializer.initialize(getApplicationContext());\n    setContentView(R.layout.activity_main2);\n    mSensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);//获取传感器管理服务\n    mCurrentMode = LocationMode.NORMAL;\n    //初始化地图\n    mMapView = (MapView) findViewById(R.id.mapView2);\n    mBaidumap = mMapView.getMap();\n    mMapView.showScaleControl(false);\n    mMapView.showZoomControls(false);\n    UiSettings settings = mBaidumap.getUiSettings();\n    settings.setOverlookingGesturesEnabled(false);//设置双指下拉时不启用3D地图\n    settings.setRotateGesturesEnabled(false);//设置地图不可旋转\n    //开启定位图层\n    mBaidumap.setMyLocationEnabled(true);\n    initLocation();\n    initPoiSearch();\n    initData();\n\n    Timer timer = new Timer();\n    timer.schedule(new TimerTask() {\n        public void run() {\n            ShowKeyboard(et_address);\n        }\n    }, 500);\n}\n\nprivate void initData() {\n    et_address = (EditText) findViewById(R.id.et_address);\n    myListView = (ListView) findViewById(R.id.lv_address);\n    mPoiSearch = PoiSearch.newInstance();\n    mPoiSearch.setOnGetPoiSearchResultListener(new OnGetPoiSearchResultListener() {\n@Override\npublic void onGetPoiResult(PoiResult poiResult) {\n    if (poiResult == null || poiResult.error == SearchResult.ERRORNO.RESULT_NOT_FOUND) {\n    Toast.makeText(Main2Activity.this, \"未找到结果\", Toast.LENGTH_LONG).show();\n    return;\n}\n    if (poiResult.error == SearchResult.ERRORNO.NO_ERROR) {\n\n}\n    if (poiResult.error == SearchResult.ERRORNO.AMBIGUOUS_KEYWORD) {\n    //当输入关键字在本市没有找到，但是在其他城市找到时，返回包含该关键字信息的城市列表\n    String strInfo = \"在\";\n    for (CityInfo cityInfo : poiResult.getSuggestCityList()) {\n            strInfo += cityInfo.city;\n            strInfo += \",\";\n        }\n            strInfo += \"找到结果\";\n            Toast.makeText(Main2Activity.this, strInfo, Toast.LENGTH_LONG).show();\n        }\n    }\n\n@Override\npublic void onGetPoiDetailResult(PoiDetailResult poiDetailResult) {\n    if (poiDetailResult == null\n        || poiDetailResult.error == SearchResult.ERRORNO.RESULT_NOT_FOUND) {\n        Toast.makeText(Main2Activity.this, \"未找到结果\", Toast.LENGTH_LONG)\n            .show();\n            return;\n        }\n    if (poiDetailResult.error == SearchResult.ERRORNO.NO_ERROR) {\n    //搜索到POI\n    mBaidumap.clear();\n    mBaidumap.addOverlay(new MarkerOptions()\n            .position(poiDetailResult.location)\n            .icon(BitmapDescriptorFactory.fromResource(R.drawable.alf))\n            .title(poiDetailResult.getAddress()));\n        //讲该POI设置为地图中心\n        mBaidumap.setMapStatus(MapStatusUpdateFactory.newLatLng(poiDetailResult.location));\n        Toast.makeText(Main2Activity.this, \"搜索中...\", Toast.LENGTH_LONG).show();\n            return;\n        }\n    }\n@Override\npublic void onGetPoiIndoorResult(PoiIndoorResult poiIndoorResult) {\n\n    }\n});\n\n    //初始化建议搜索模块，注册建议搜索事件监听\n    mSuggestionSearch = SuggestionSearch.newInstance();\n    mSuggestionSearch.setOnGetSuggestionResultListener(this);\n    et_address.addTextChangedListener(new TextWatcher() {\n@Override\npublic void afterTextChanged(Editable arg0) {\n    if (adapter_list_Address != null) {\n        adapter_list_Address.notifyDataSetChanged();\n    }\n    mSuggestionSearch\n        .requestSuggestion((new SuggestionSearchOption())\n        .keyword(et_address.getText().toString()).city(\"北京\"));\n    }\n@Override\npublic void beforeTextChanged(CharSequence arg0, int arg1,\n                              int arg2, int arg3) {\n    if (adapter_list_Address != null) {\n        adapter_list_Address.notifyDataSetChanged();\n    }\n    mSuggestionSearch\n        .requestSuggestion((new SuggestionSearchOption())\n        .keyword(et_address.getText().toString()).city(\"北京\"));\n    }\n@Override\npublic void onTextChanged(CharSequence cs, int arg1, int arg2,\n                          int arg3) {\n    if (cs.length() < 0) {\n        return;\n    }\n/**\n* 使用建议搜索服务获取建议列表，结果在onSuggestionResult()中更新\n*/\nif (adapter_list_Address != null) {\n          adapter_list_Address.notifyDataSetChanged();\n}\n    mSuggestionSearch\n    .requestSuggestion((new SuggestionSearchOption())\n    .keyword(et_address.getText().toString()).city(\"北京\"));\n}\n});\n\n\n\n\n}\n\n\n\n@Override\npublic void onGetSuggestionResult(final SuggestionResult msg) {\n    // TODO Auto-generated method stub\n    if (msg == null || msg.getAllSuggestions() == null) {\n        Toast.makeText(Main2Activity.this, \"未检索到当前地址\", Toast.LENGTH_SHORT).show();\n        return;\n    }\n\n    if (list != null) {\n        list.clear();\n    }\n    if (lists != null) {\n        lists.clear();\n    }\n\n    for (SuggestionResult.SuggestionInfo info : msg.getAllSuggestions()) {\n        Log.e(\"info.ccity\", \"info.city\" + info.city + \"info.district\" + info.district + \"info.key\" + info.key);\n        list.add(info.key);\n        lists.add(info.city + info.district + info.key);\n        adapter_list_Address = new Adapter_list_Address(Main2Activity.this, list, lists);\n        myListView.setAdapter(adapter_list_Address);\n        myListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {\n            @Override\n            public void onItemClick(AdapterView adapterView, View view, int position, long id) {\n                SuggestionResult.SuggestionInfo info = msg.getAllSuggestions().get(position);\n                mPoiSearch.searchPoiDetail(new PoiDetailSearchOption().poiUid(info.uid));\n\n                Intent intentAddress = new Intent();\n                intentAddress.putExtra(\"backData\",et_address.getText().toString());\n                setResult(RESULT_OK,intentAddress);\n                finish();\n            }\n        });\n        adapter_list_Address.notifyDataSetChanged();\n    }\n}\n\npublic static void ShowKeyboard(View v) {\n    InputMethodManager imm = (InputMethodManager) v.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);\n    imm.showSoftInput(v, InputMethodManager.SHOW_FORCED);\n}\n\npublic static void HideKeyboard(View v) {\n    InputMethodManager imm = (InputMethodManager) v.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);\n    if (imm.isActive()) {\n        imm.hideSoftInputFromWindow(v.getApplicationWindowToken(), 0);\n    }\n}\n\n/**\n * 初始化定位相关\n */\nprivate void initLocation() {\n    mLocClient = new LocationClient(this);\n    mLocClient.registerLocationListener(myListener);\n    LocationClientOption option = new LocationClientOption();\n    option.setOpenGps(true);//打开GPS\n    option.setCoorType(\"bd09ll\");//设置坐标类型\n    option.setIsNeedAddress(true);//是否需要地址信息\n    option.setScanSpan(1000);\n    LocationPermission();\n    mLocClient.setLocOption(option);\n}\n\n/**\n * poi搜索相关\n */\nprivate void initPoiSearch() {\n    //初始化搜索模块，注册搜索事件监听\n    mPoiSearch = PoiSearch.newInstance();\n    //mPoiSearch.setOnGetPoiSearchResultListener(this);\n}\n\n/**\n * 获取GPS定位权限(Android6.0 以上需要动态获取权限)\n */\nprivate void LocationPermission() {\n    int checkPermission = ContextCompat.checkSelfPermission(Main2Activity.this, Manifest.permission.ACCESS_COARSE_LOCATION);\n    if (checkPermission != PackageManager.PERMISSION_GRANTED) {\n        ActivityCompat.requestPermissions(Main2Activity.this, new String[]{Manifest.permission.ACCESS_COARSE_LOCATION}, 1);\n        Log.d(\"未获得定位权限\", \"弹出提示\");\n        return;\n    }\n}\n\n/**\n * 方向监听\n */\npublic class DirectionSensorListener implements SensorEventListener {\n\n    @Override\n    public void onSensorChanged(SensorEvent event) {\n        double x = event.values[SensorManager.DATA_X];\n        if (Math.abs(x - lastX) > 1.0) {\n            mCurrentDirection = (int) x;\n            //设置定位数据\n            locData = new MyLocationData.Builder()\n                    .accuracy(mCurrentAccracy)//精度\n                    .direction(mCurrentDirection) //此处设置开发者获取到的方向信息，顺时针0-360\n                    .latitude(mCurrentLat)//经度\n                    .longitude(mCurrentLon)//纬度\n                    .build();\n            mBaidumap.setMyLocationData(locData);\n        }\n        lastX = x;\n    }\n\n    @Override\n    public void onAccuracyChanged(Sensor sensor, int accuracy) {\n\n    }\n}\n\n/**\n * 定位监听\n */\npublic class MyLocationListener implements BDLocationListener {\n\n    @Override\n    public void onReceiveLocation(BDLocation bdLocation) {\n        //map view销毁后不在处理新接受的位置\n        if (bdLocation == null || mMapView == null) {\n            return;\n        }\n        mCurrentLat = bdLocation.getLatitude();\n        mCurrentLon = bdLocation.getLongitude();\n        mCurrentAccracy = bdLocation.getRadius();\n        mCityName = bdLocation.getCity();\n        //设置定位数据\n        locData = new MyLocationData.Builder()\n                .accuracy(bdLocation.getRadius())//精度\n                .direction(mCurrentDirection) //此处设置开发者获取到的方向信息，顺时针0-360\n                .latitude(bdLocation.getLatitude())//经度\n                .longitude(bdLocation.getLongitude())//纬度\n                .build();\n        mBaidumap.setMyLocationData(locData);\n        //第一次定位时，将地图位置移动到当前位置\n        if (isFirstLoc) {\n            isFirstLoc = false;\n            LatLng ll = new LatLng(bdLocation.getLatitude(), bdLocation.getLongitude());\n            MapStatus.Builder builder = new MapStatus.Builder();\n            builder.target(ll).zoom(18.0f);\n            mBaidumap.animateMapStatus(MapStatusUpdateFactory.newMapStatus(builder.build()));\n            mCurrentMarker = null;\n            mBaidumap\n                    .setMyLocationConfiguration(new MyLocationConfiguration(\n                            mCurrentMode, true, null));\n        }\n    }\n}\n\n@Override\nprotected void onStart() {\n    //为系统的方向传感器注册监听器\n    mSensorManager.registerListener(DirectionListener, mSensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION)\n            , SensorManager.SENSOR_DELAY_UI);\n    //启动监听\n    mLocClient.start();\n    super.onStart();\n}\n\n@Override\nprotected void onPause() {\n    mMapView.onPause();\n    super.onPause();\n}\n\n@Override\nprotected void onResume() {\n    mMapView.onResume();\n    super.onResume();\n}\n\n@Override\nprotected void onStop() {\n    //取消传感器监听\n    mSensorManager.unregisterListener(DirectionListener);\n    super.onStop();\n}\n\n@Override\nprotected void onDestroy() {\n    //退出时销毁定位\n    mLocClient.stop();\n    //关闭定位图层\n    mBaidumap.setMyLocationEnabled(false);\n    mMapView.onDestroy();\n    mMapView = null;\n    mPoiSearch.destroy();\n    mSuggestionSearch.destroy();\n    super.onDestroy();\n}\n\n\n\n\n}", "Tag": "算法分析"}
{"Answer": " return s.substr(begin,maxlen);", "Konwledge_Point": "动态规划", "Question": "判断最长回文字符串的时候，用这段代码在面对cbbd时输出了bbd，其他都正常，这是为什么呢\n问题遇到的现象和发生背景\n\n\n问题相关代码，请勿粘贴截图\n\n\nclass\n \nSolution\n {\n\npublic\n:\n    \nstring \nlongestPalindrome\n(string s)\n \n{\n        \nint\n n = s.\nsize\n();\n        \nif\n(n<\n2\n)\n            \nreturn\n s;\n\n        \nint\n maxlen = \n1\n;\n        \nint\n begin = \n0\n;\n        \nint\n dp[n][n];\n        \nfor\n(\nint\n i = \n0\n;imaxlen){\n                maxlen = j-i+\n1\n;\n                begin = i;\n            }\n            }        \n        }\n        \nreturn\n s.\nsubstr\n(begin,maxlen+begin);\n    }\n};\n\n\n\n运行结果及报错内容\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果", "Tag": "算法分析"}
{"Answer": "35岁前我面试过很多项目经理和开发候选人，发现大多数40岁的甚至50岁的技术人，他们的技术并没有随着年龄的增长而提高，反而有点跟不上时代的发展。固守旧有的经验，故步自封。\n为此我成立了35岁大龄技术人社群，针对35岁以上技术人组织线下会议，一起分享和沟通技术，以及未来的发展。\n我发现35岁的人因为受到家庭的影响，精力明显不够用，而且也没有时间学习新技术，更多情况下是考虑用旧有的技术解决问题，或者甩手给新人，让他们解决。更多的人开始考虑副业，打造自己的睡后收入。\n后来这个社群讨论的话题就慢慢演变成了35岁如何通过副业打造自己的竞争力，确保可以不工作也有收入。\n于是大部分人开设了公众号，开通了csdn博客专栏，开始输出自己的价值，进而获得收益。\n从那之后，我也开始写公众号，做自己的个人网站，在csdn输出内容，提供面试资料，提供学习规划咨询，等等一系列的副业。很庆幸的是，花了一年时间，成功实现了副业收入高于了工资收入。当副业收入高于薪资4倍的时候，正好赶上中耳炎，果断辞职。\n之后结束北漂，在老家定居，过上了自己梦想中的居家办公的生活。\n所以35岁不可怕，可怕的是你一直在等待35岁的到来，而从未行动。", "Konwledge_Point": "动态规划", "Question": "如何打破IT界的35岁门槛？\nIT程序员在大家看来是一个'高薪'行业, 可是它真的是一个高薪行业吗? 现在国家认证程序员是'农民工'。\n\n\n那么问题来了, 农民工的工作年龄的限制是多少呢? 程序员的为什么又会有35大砍一说呢?\n希望大家们能够帮我解惑, 也帮一些即将进入IT圈的同学指出问题。", "Tag": "算法分析"}
{"Answer": "\n    public static int minTime(int[] time,int[] costs,int x){\n        int temp,times=0,tmp_x=x;\n        if(time.length==0 || costs.length==0){\n            return times;\n        }\n//        按时间排序\n        for(int i=1;i<time.length;i++){\n            for(int j=0;j<time.length-i;j++){\n                if(time[j]<time[j+1]){\n                    temp=time[j];\n                    time[j]=time[j+1];\n                    time[j+1]=temp;\n                    temp=costs[j];\n                    costs[j]=costs[j+1];\n                    costs[j+1]=temp;\n                }\n            }\n        }\n//        复制一个临时数组，用于删除使用过的元素\n        int[] tmp_time=(int[]) Arrays.copyOf(time,time.length);\n        int[] tmp_costs=(int[]) Arrays.copyOf(costs,costs.length);\n        int len=tmp_costs.length;\n        \n//        开始获取时间\n        for(int i=0;i<costs.length;i++){\n//            判断人数是否满足条件\n            if(tmp_x>=costs[i]){\n//                每一次统计只取同时进行所花最大时间\n                if(times<time[i]){\n                    times=time[i];\n                }\n                tmp_x-=costs[i];\n//                删除使用过的元素\n                for(int k=i;k<len-1;k++){\n                    tmp_costs[k]=tmp_costs[k+1];\n                    tmp_time[k]=tmp_time[k+1];\n                }\n                tmp_costs[len-1]='\\0';\n                tmp_time[len-1]='\\0';\n                len--;\n            }\n            if(tmp_x==0){ break; }\n\n        }\n        return times+minTime((int[]) Arrays.copyOf(tmp_time,len),(int[]) Arrays.copyOf(tmp_costs,len),x);\n    }\n", "Konwledge_Point": "动态规划", "Question": "蓄水池并发注水问题-算法题（java/c++）\n当前有n个水池（n无大小限制，此处0<n<10^5）可同时蓄水，蓄满第i个水池所需要的时间为time[i]，蓄第i个水池所需要的工人数为costs[i]，（水池一旦开始蓄水就不能停下，且对水池蓄水必须满足人数要求，time.length = costs.length），当前有x个员工在待命（单个水池需要的人数不会超过x），求在满足人数要求的情况下完成全部蓄水任务的最短时间。\n\n\n输入：\ntime = [2,4,10]\ncosts = [2,5,7]\nx=7\n输出：14\n\n", "Tag": "算法分析"}
{"Answer": "如果你要把s[i]替换成t，图2中循环条件中的s[i]也需要替换成t，即for (k=1; k<=t; k*=2)", "Konwledge_Point": "动态规划", "Question": "help！多重背包的二进制优化\n\n\n第13行到18行，把s[i]用t代换为啥错了呢？\n\n\np1对，p2错", "Tag": "算法分析"}
{"Answer": "参考GPT和自己的思路：\n下面是你的错误代码：\nint n, m;\n// 多组数据，数组开大点\nlong long a[10][200010];\n// a[初始数字][扩展次数] = 扩展后的位数\n// 数据可能比较大，取模\n\nint main() {    \n    // 预处理，初始化10之前的数，也就是0~9\n    for (int i = 0; i <= 9; i ++) {\n        a[i][0] = 1; // 对于0次扩展，自己不变\n    }\n    for (int i = 0; i <= 9; i ++) { // 初始数字\n        for (int j = 1; j <= 200000; j ++) { // 扩展次数\n            a[i][j] = a[i][j-1];\n            if (j >= 11)\n                // 对于当前位数j，统计的是自身i在j次扩展时的数字个数\n                a[i][j] = (a[i][j] + a[i][j-9] - a[i][j-10] + a[i][j-10] - a[i][j-11]) % mod;\n                /*\n                因为数字9可以由0和1增加得到，假设我们从x扩展到y，\n                那么y与x一定最多只多了一位，\n                因此我们可以用a[i][j-9]来表示是在1后面加上i扩展了j-10位的\n                数字前面在并上0或不变得到的，即a[i][j-9] - a[i][j-10]\n                如果不加0而是加1的话，就变成了i+1的后9位，即a[i][j-10] - a[i][j-11]\n                数字9会多算，所以减去前面的再加上后面的，就是实际得到的结果\n                */\n            else if (j == 10 - i)\n                a[i][j] = (a[i][j] + 1) % mod;\n                // 由于加1后每一位都变成了1，因为+1与之前不同，直接+1即可\n        }\n    }\n\n    int t = read();\n    while (t --) {\n        n = read(); m = read();\n        long long sum = 0;\n        while (n) {\n            // 从低位到高位记录总共的数字个数，取模\n            sum = (sum + a[n%10][m]) % mod;\n            n /= 10;\n        }\n        printf(\"%lld\\n\", sum);\n    }\n\n    return 0;\n}\n\n原因：\n代码中没有对结果取模，超过了最大范围可能引起错误，因此加上了这部分内容。\n代码预处理的步骤和函数的具体说明提供的解释并不一样。因此对预处理部分做了必要的调整。建议看一遍解释。\n以上是你的答案和错误代码的原因，请注意后续维护。", "Konwledge_Point": "动态规划", "Question": "线性DPCF1513C Add One的代码不知道为什么错了\n题目链接codeforces\n题目链接洛谷\n\n\nAdd One\n\n\n题面翻译\n\n\n称“将一个数上每一位的值$+1$”为一次操作，例如对于$93$进行一次操作后的结果为$104$。输入$n,m$，输出对$n$进行$m$次操作的结果。\n\n\n题目描述\n\n\nYou are given an integer $ n $ . You have to apply $ m $ operations to it.\n\n\nIn a single operation, you must replace every digit $ d $ of the number with the decimal representation of integer $ d + 1 $ . For example, $ 1912 $ becomes $ 21023 $ after applying the operation once.\n\n\nYou have to find the length of $ n $ after applying $ m $ operations. Since the answer can be very large, print it modulo $ 10^9+7 $ .\n\n\n输入格式\n\n\nThe first line contains a single integer $ t $ ( $ 1 \\le t \\le 2 \\cdot 10^5 $ ) — the number of test cases.\n\n\nThe only line of each test case contains two integers $ n $ ( $ 1 \\le n \\le 10^9 $ ) and $ m $ ( $ 1 \\le m \\le 2 \\cdot 10^5 $ ) — the initial number and the number of operations.\n\n\n输出格式\n\n\nFor each test case output the length of the resulting number modulo $ 10^9+7 $ .\n\n\n样例 #1\n\n\n样例输入 #1\n\n\n5\n\n\n1912 \n1\n\n\n5 \n6\n\n\n999 \n1\n\n\n88 \n2\n\n\n12 \n100\n\n\n\n\n样例输出 #1\n\n\n5\n\n\n2\n\n\n6\n\n\n4\n\n\n2115\n\n\n\n\n提示\n\n\nFor the first test, $ 1912 $ becomes $ 21023 $ after $ 1 $ operation which is of length $ 5 $ .\n\n\nFor the second test, $ 5 $ becomes $ 21 $ after $ 6 $ operations which is of length $ 2 $ .\n\n\nFor the third test, $ 999 $ becomes $ 101010 $ after $ 1 $ operation which is of length $ 6 $ .\n\n\nFor the fourth test, $ 88 $ becomes $ 1010 $ after $ 2 $ operations which is of length $ 4 $ .\n\n\n我的错误代码\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n\nusing\n \nnamespace\n std;\n\n\nconst\n \nint\n mod = \n1e9\n + \n7\n;\n\n\ninline\n \nint\n \nread\n()\n \n{\n    \nint\n s = \n0\n, w = \n1\n;\n    \nchar\n c = \ngetchar\n();\n    \nwhile\n (c < \n'0'\n || c > \n'9'\n) {\nif\n (c == \n'-'\n) w = \n-1\n; c = \ngetchar\n();}\n    \nwhile\n (c >= \n'0'\n && c <= \n'9'\n) s = s * \n10\n + c - \n'0'\n, c = \ngetchar\n();\n    \nreturn\n s * w;\n}\n\n\nint\n n, m;\n\nlong\n \nlong\n a[\n10\n][\n200010\n];\n\n// a[初始数字][扩展次数] = 扩展后的位数\n\n\n\nint\n \nmain\n()\n \n{    \n    \nfor\n (\nint\n i = \n0\n; i <= \n9\n; i ++) {\n        a[i][\n0\n] = \n1\n;\n    }\n    \n    \nfor\n (\nint\n i = \n0\n; i <= \n9\n; i ++) { \n// 初始数字\n\n        \nfor\n (\nint\n j = \n1\n; j <= \n200000\n; j ++) { \n// 扩展次数\n\n            a[i][j] = a[i][j\n-1\n];\n            \nif\n (j >= \n11\n)\n                a[i][j] = (a[i][j] + a[i][j\n-9\n] - a[i][j\n-10\n] + a[i][j\n-10\n] - a[i][j\n-11\n]) % mod;\n            \n/*\n              因为数字9可以由0和1增加得到\n              所以：a[i][j-9] - a[i][j-10] + a[i][j-10] - a[i][j-11]\n              表示数字i扩展j次后的数字中数字9的个数。\n              其中a[i][j-9] - a[i][j-10]是数字i在扩展第j-9次后\n              新出现的数字1的个数；\n              其中a[i][j-10] - a[i][j-11]是数字i在扩展第j-10次后\n              新出现的数字0的个数；\n             */\n\n            \nelse\n \nif\n (j == \n10\n - i || i == \n9\n && j == \n10\n)\n                a[i][j] = (a[i][j] + \n1\n) % mod;\n        }\n    }\n    \n    \nint\n t = \nread\n(); \n    \nwhile\n (t --) {\n        n = \nread\n(); m = \nread\n();\n        \nlong\n \nlong\n sum = \n0\n;\n        \nwhile\n (n) {\n            sum = (sum + a[n%\n10\n][m]) % mod;\n            n /= \n10\n;\n        }\n        \nprintf\n(\n\"%lld\\n\"\n, sum);\n    }\n    \n    \nreturn\n \n0\n;\n}\n", "Tag": "算法分析"}
{"Answer": "\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int size = nums.size();\n \n        //int dp[size][size];             //dp数组表明前面存储的元素的和\n \n        int sum = 0;\n \n        // for(int i = 0;i<size;i++)      //对元素进行初始化\n        //     dp[i][0] = sum+nums[i];\n \n        int max = nums[0];//dp[0][0];\n \n        for(int j = 0;j<size;j++)\n        {\n            sum=0;\n            for(int i =j;i<size;i++)\n            {\n                //dp[i][j] = dp[i][j-1] + nums[i];\n                sum+=nums[i];\n                if(max<sum)max=sum;\n            }\n        }\n        return max;\n    }\n};\n", "Konwledge_Point": "动态规划", "Question": "leetcode最大子数组之和，用我这种思路可以解吗？\n问题遇到的现象和发生背景\n\n\n\n      \n        \n力扣\n\n        \n      \n\n      \n\n      \n\n        \n\n          \nhttps://leetcode-cn.com/problems/maximum-subarray/\n\n        \n\n      \n\n\n问题相关代码，请勿粘贴截图\n\n\nclass\n \nSolution\n {\n\npublic\n:\n    \nint\n \nmaxSubArray\n(vector<\nint\n>& nums)\n \n{\n        \nint\n size = nums.\nsize\n();\n\n        \nint\n dp[size][size];             \n//dp数组表明前面存储的元素的和\n\n\n        \nint\n sum = \n0\n;\n\n        \nfor\n(\nint\n i = \n0\n;i max)\n                    max = dp[i][j];\n            }\n        }\n        \nreturn\n max;\n    }\n};\n\n\n\n\n运行结果及报错内容\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果", "Tag": "算法分析"}
{"Answer": "利用HttpClient或者HttpRequest等和网络相关的类拿到网页数据，此时应该是HTML的，然后利用正则提取出来就可以了", "Konwledge_Point": "动态规划", "Question": "c#如何提取提取淘宝或者京东的一些产品信息\n想请问下怎么提取淘宝或者京东的一些产品信息功能，比如成交记录之类的，因为淘宝或者京东等网站这些都是JS，不懂提取，求大神们指点一二", "Tag": "算法分析"}
{"Answer": "\n迪杰斯特拉算法（Dijkstra）证明_肥宅_Sean的博客-CSDN博客_迪杰斯特拉算法证明\n首先，这篇文章是在讲《图论》时候写文章（所以，还是以理论为主，以后有空的时候，会把代码发上来，不过我觉得大家看完理论，如果讲得好，代码也就比较容易了。如果讲得不好，网上的代码也是大把，不看这篇文章也罢了）下图为老师的课件内容部分，我觉得虽然详尽，但也有些枯燥。可能是为了凝练语言吧。如果有耐心看的话，倒真的是一篇非常好的文章。（反正这个应该是比百度百科要强的….） 我在后面会用自己的语言阐...\n\n\n\nhttps://blog.csdn.net/a19990412/article/details/80232810\n\n", "Konwledge_Point": "动态规划", "Question": "证明证明Dijkstra算法正确性，并分析时间复杂度\n证明Dijkstra算法正确性，并分析在未优化的情况下其平均情况下时间复杂度。假设图为G=(V,E)\n\n\n要求：c/c++，有证明过程", "Tag": "算法分析"}
{"Answer": "重新更新回答，简单的说说前面的执行步骤，其实一步一步按照程序执行流程演算下去就行了。文字实在难以解释，可以+V私聊说明", "Konwledge_Point": "动态规划", "Question": "python递归函数中通过for循环构建树 for循环运作逻辑\n最近工作忙到死 以前也一知半解的 现在彻底想不起来了 脊椎也痛，索性就直接问吧\n是这样子的 有哪位可以给我讲述一下通过递归构建树的时候内部for循环的运作逻辑 为啥图1的for循环长这个样子 for循环这些数字代表啥意思 图1成功构建了一个树\n\n\n大家可以看我之前打赏记录 我得到满意答案会给钱的放心\n\n\n\n\ndef\n recDCCC(weightlist,maxweight,num,lk,value,llp):\n    \nif\n num==\n4\n:\n        \nreturn\n llp ##递归结束条件 并开始新的一轮递归\n    \nif\n maxweight>\n20\n:\n        \nreturn\n llp\n    \n###op.append([val for val in ok if val not in weightlist])##将OK表中不属于valuelist的元素，重复元素剔除出来,除非重复是8，发生重复，立即结束\n\n    \nelse\n:\n        \nfor\n i in range(len(weightlist)): \n                    \nprint\n(i)\n                    \np\n=weightlist[i][\n0\n]\n                    \nl\n=weightlist[i][\n1\n]\n                    \nc\n=list(set(weightlist)-set([weightlist[i]]))## 被抽出的因子，剩余的进去迭代，剩余的部分便是C\n                    \nllp\n.append(c)\n                    \nnumcoins\n=recDCCC(c,maxweight+p,num+\n1\n,lk+l,value,llp)\n    \nreturn\n llp\n\n\n\nrecDCCC\n([(\n2\n,\n3\n),(\n3\n,\n4\n),(\n4\n,\n8\n),(\n5\n,\n8\n),(\n9\n,\n10\n)],\n0\n,\n0\n,\n0\n,\n0\n,[])\n", "Tag": "算法分析"}
{"Answer": "我想明白了", "Konwledge_Point": "动态规划", "Question": "请问我写的dp状态转移方程对不对\n能看看这个问题我写的状态转移方程对吗？答案是二维的但我的是一维的\n\n\n\n\n我写的是:\ndp[i]=max(dp[i-1],dp[i-2]+a[i]*a[i-1])\ndp[0]=0,dp[1]=1", "Tag": "算法分析"}
{"Answer": "虽然是三维数组，但其实问题不大，有一维是字符串，其实是二维的字符串数组\nint countMatches(char *** items, int itemsSize, int* itemsColSize, char * ruleKey, char * ruleValue){\n    int i;\n    int ans = 0, cmpIdx;\n    for(i = 0; i < itemsSize; ++i) {\n        if(strcmp(ruleKey, \"type\") == 0) {\n            cmpIdx = 0;\n        }else if(strcmp(ruleKey, \"color\") == 0) {\n            cmpIdx = 1;\n        }else if(strcmp(ruleKey, \"name\") == 0) {\n            cmpIdx = 2;\n        }else {\n            cmpIdx = 0;\n        }\n        if(strcmp(items[i][cmpIdx], ruleValue) == 0)\n            ++ ans;\n    }\n    return ans;\n}\n", "Konwledge_Point": "动态规划", "Question": "一个有关于三维数组的题\n给你一个数组 items ，其中 items[i] = [typei, colori, namei] ，描述第 i 件物品的类型、颜色以及名称。\n\n\n另给你一条由两个字符串 ruleKey 和 ruleValue 表示的检索规则。\n\n\n如果第 i 件物品能满足下述条件之一，则认为该物品与给定的检索规则 匹配 ：\n\n\nruleKey == \"type\" 且 ruleValue == typei 。\nruleKey == \"color\" 且 ruleValue == colori 。\nruleKey == \"name\" 且 ruleValue == namei 。\n统计并返回 匹配检索规则的物品数量 。\n\n\n\n      \n        \n力扣\n\n        \n      \n\n      \n\n      \n\n        \n\n          \nhttps://leetcode-cn.com/problems/count-items-matching-a-rule/\n\n        \n\n      ", "Tag": "算法分析"}
{"Answer": "不一定从最高处开始啊", "Konwledge_Point": "动态规划", "Question": "dp 滑雪 请帮我看看我的代码哪里错了 特别是search过程 谢谢！\n滑雪是一项非常刺激的运动，为了获得速度，滑雪的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。给出一个由二维数组表示的滑雪区域，数组的数字代表各点的高度。请你找出这个区域中最长的滑坡。\n\n下面是一个例子：\n\n1  2  3  4  5\n\n16 17 18 19 6\n\n15 24 25 20 7\n\n14 23 22 21 8\n\n13 12 11 10 9\n\n\n\n一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可滑行的滑坡为24-17-16-1。当然，25-24-23-...-3-2-1更长。事实上，这是最长的一条滑坡。\n\n\n\n输入文件ski.in的第一行为两个数R, C，表示滑雪区域的行数和列数（1≤R,C≤100）。下面是R行，每行有C个整数，表示高度H（0≤H≤10000）。 \n\n\n\n输出文件ski.out包括一行，只包含一个整数，表示滑雪区域中最长滑坡的长度\n\n\n\n这是我的代码 请问哪里错了 不能得满分啊\n\nprogram hx;\n\ntype info=array[1..3]of longint;\n\nconst movx:array[1..4]of shortint=(0,-1,1,0);\n\n      movy:array[1..4]of shortint=(1,0,0,-1);\n\nvar map:array [1..6000000]of info;\n\nn,m,s,i,tot,max:longint;\n\nprocedure readin;\n\nvar i,j:longint;\n\nbegin\n\n  readln(n,m);\n\n  for i:=1 to n do\n\n  begin\n\n    for j:=1 to m do\n\n    begin\n\n      inc(s);\n\n      read(map[s][3]);\n\n      map[s][1]:=i;\n\n      map[s][2]:=j;\n\n    end;\n\n  end;\n\nend;\n\nprocedure ordered(l,r:longint);\n\nvar i,j,m:longint;\n\n    jhq:info;\n\nbegin\n\n  m:=map[(l+r)div 2][3];\n\n  i:=l;\n\n  j:=r;\n\n  while i<=j do\n\n  begin\n\n    while map[i][3]\n    while map[j][3]>m do dec(j);\n\n    if i<=j then\n\n    begin\n\n      jhq:=map[i];\n\n      map[i]:=map[j];\n\n      map[j]:=jhq;\n\n      inc(i);\n\n      dec(j);\n\n    end;\n\n    if i\n    if j>l then ordered(l,j);\n\n  end;\n\nend;\n\nprocedure search(k:longint);\n\nvar i:longint;\n\n    f:boolean;\n\nbegin\n\n  f:=false;\n\n  for i:=1 to 4 do\n\n    begin\n\n      if (map[k-1][1]=map[k][1]+movx[i])and(map[k-1][2]=map[k][2]+movy[i])and(map[k][3]<>map[k-1][3]) then\n\n      f:=true;\n\n      if f=true then inc(tot);\n\n      if f=false then\n\n      begin\n\n        if max<=tot then max:=tot\n\n        else tot:=0;\n\n      end;\n\n      if k-1=1 then exit;\n\n      search(k-1);\n\n    end;\n\nend;\n\nbegin\n\n  s:=0;\n\n  readin;\n\n  ordered(1,s);\n\n  max:=0;\n\n  search(s);\n\n  write(max+1);\n\nend.", "Tag": "算法分析"}
{"Answer": "\n阅读、理解、注释、讲解四段代码的工作量非常大，很抱歉我无力完成。我仅分析一下第四段代码。另外，我不建议你直接贴代码让别人来分析，而是应该首先理解书上作者的描述、逻辑，在脑海中构建出解题的思路。有必要的话自己跑代码，并且学会使用代码调试器观察程序运行途中变量的值，这样有便于你自己理解，也有利于你的编程思维。我个人并不是很喜欢硬分析别人给出的代码，而是自己从头开始写，如果遇到什么困难再去看看别人在那个地方是怎么写的。\n\n概括一下这四段代码别写了啥：①代码一直接递归，时间开销O(2^N)为指数量级，耗时巨大；②代码二叫备忘录式的动态规划。他建立了一个表格，标记了哪些路径已经算过了，哪些没有算过。算过的值就可以直接拿来用。这个算法已经把时间复杂度降低为O(N²)的多项式，改进巨大；③代码三叫递推式的动态规划。他直接从子问题（更短的路径）开始解决，然后用子问题的答案直接求解更大的问题，逐步推进。递推式的动态规划比备忘录式的在时间复杂度上的常数更小，但是数量级依然是O(N²)的；④代码四用了滚动数组的技巧，用新算出来的值覆盖掉老的、不再使用的值。此方法把空间复杂度从O(N²)降到O(N)，时间复杂度不变（已无法改进）。\n\n动态规划中的状态转移方程非常重要，程序的核心就是在递推这个方程求值，顺带一点边角料的处理。本题的状态转移方程：\nmaxSum[r][j] =\n{\n    D[r][j], if r == N\n    max{maxSum[r+1][j], maxSum[r+1][j+1]} + D[r][j], if r < N\n}\n\n在状态转移方程中，maxSum[r][j]指的是从三角形的最下面一行走到第r行第j个数字时的最大的和，D[r][j]指的是三角形中第r行第j个数字。如果r == N，那么路径上仅有这个数字，故maxSum[r][j] = D[r][j]；如果r < N，那么从D[r][j]这一点的左侧最大路径maxSum[r+1][j]和右侧最大路径maxSum[r+1][j+1]中选一个更大的，再加上D[r][j]本身的值，得到maxSum[r][j]的结果。\n\n这是对第四段代码进行注释：\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n \n#define MAX 101\nint D[MAX][MAX]; // 二维数组D，用于存储这个数字三角形。\nint n; int* maxSum; // maxSum是一个int指针。\n \nint main() {\n    int i, j;\n    cin >> n; // 将N存入变量n.\n    for (i = 1, i <= n;i++）\n        for (j = 1;j <= i;j++)\n            cin >> D[i][j]; // 将数字三角形读入二维数组D.\n    maxSum = D[n]; // 将maxSum指向三角形的最后一行，实现了状态转移方程中r == N时的情况。此时maxSum是个一维数组，maxSum[j]保存了第N行第j个位置的最大路径（从三角形最下行开始走）。\n    for (int i = n - 1; i >= 1; --i) // 变量i是当前考虑的行数，从第n-1行递减到第1行。\n        for (int j = 1; j <= i; ++j) // 考虑第i行第j个位置，从1递增到i，因为第i行只有i个数。\n            maxSum[j] = max(maxSum[j], maxSum[j + 1]) + D[i][j]; // 实现状态转移方程r < N时的递推。这里算第i行的maxSum[j]时，使用了已经算好且存下来的第i+1行的maxSum[j]和maxSum[j+1]的值，并直接覆盖了maxSum[j]的值，这并不会干扰接下来对maxSum[j+1]的计算。这就是滚动数组的主要思想。\n    cout << maxSum[1] << endl; // 输出结果。变量i最终的值为1，即maxSum当前存的是第1行的情况。\n}\n", "Konwledge_Point": "动态规划", "Question": "请问这道数字三角形如何理解呢？\n请问这道数字三角形如何理解呢？有四段代码，我不是很懂，希望大家帮注释一下代码并讲一下思路。非常感谢！\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\nusning \nnamespace\n std;\n\n\n#\ndefine\n MAX_NUM 100\n\n\nint\n d[MAX_NUM + \n10\n][MAX_NUM + \n10\n];\n\nint\n N;\n\n\nint\n \nMaxSum\n(\nint\n r, \nint\n j)\n\n\n{\n    \nif\n (r == N）\n        \nreturn\n d[r][j]\n        \nint\n sum1 = \nMaxSun\n(r + \n1\n, j);\n        \nint\n sum2 = \nMaxSum\n(r + \n1\n, j + \n1\n);\n        \nif\n (sum1 > sum2)\n            \nreturn\n sum1 + d[r][j]\n            \nreturn\n sum2 + d[r][j];\n}\n\n\nint\n \nmain\n()\n{\n    \nint\n m;\n    \nscanf\n(\n\"%d\"\n, &N);\n    \nfor\n (\nint\n i = \n1\n;i <= N;i++)\n        \nfor\n (\nint\n j = \n1\n;j <= i;i++)\n            \nscanf\n(\n\"%d\"\n, &d[i][j]);\n    \nprintf\n(\n\"%d\"\n, \nMaxSum\n(\n1\n, \n1\n));\n    \nreturn\n \n0\n;\n}\n\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\n\n#\ndefine\n MAX_NUM 100\n\n\nint\n d[MAX_NUM + \n10\n][MAX_NUM + \n10\n];\n\nint\n N;\n\nint\n maxSum[MAX_NUM + \n10\n][MAX_NUM + \n10\n];\n\n\nint\n \nMaxSum\n(\nint\n r, \nint\n j)\n\n\n{\n    \nif\n (r == N)\n        \nreturn\n d[r][j];\n    \nif\n (maxSum[r + \n1\n][j] == \n-1\n)\n        maxSum[r + \n1\n][j] = \nMaxSum\n(r + \n1\n, j);\n    \nif\n (maxSum[r + \n1\n][j + \n1\n] == \n-1\n)\n        maxSum[r + \n1\n][j + \n1\n] = \nMaxSum\n(r + \n1\n, j + \n1\n);\n    \nif\n (maxSum[r + \n1\n][j] > maxSum[r + \n1\n][j + \n1\n])\n        \nreturn\n maxSum[r + \n1\n][j] + d[r][j];\n}\n\n\nint\n \nmain\n()\n\n\n{\n    \nint\n m;\n    \nscanf\n(\n\"%d\"\n, &N);\n\n    \nmemset\n(maxSum, \n-1\n, \nsizeof\n(maxSum));\n    \nfor\n (\nint\n i = \n1\n;i <= N;i++)\n        \nfor\n (\nint\n j = \n1\n;j <= i;j++)\n            \nscanf\n(\n\"%d\"\n, &d[i][j]);\n    \nprintf\n(\n\"%d\"\n, \nMaxSum\n(\n1\n, \n1\n))l\n        \nreturn\n \n0\n;\n}\n\n\n\n\n#include\n#include\n#include\nusing namespace std;\n\n#define \nMAX_NUM\n \n100\n\nint d[\nMAX_NUM\n + \n10\n][\nMAX_NUM\n + \n10\n];\nint \nN\n;\nint maxSum[\nMAX_NUM\n + \n10\n][\nMAX_NUM\n + \n10\n];\n\nint main()\n{\n    int i, j;\n    scanf(\n\"%d\"\n, &\nN\n);\n    for (i = \n1\n, i <= \nN\n;i++)\n        for (j = \n1\n;j <= i;j++)\n            scanf(\n\"%d\"\n, &d[i][j]);\n    for (j = \n1\n;j <= \nN\n;j++)\n        maxSum[\nN\n][j] = d[\nN\n][j];\n    for (i = \nN\n;i > \n1\n;i--)\n        for (j = \n1\n;j < i;j++) {\n            if (maxSum[i][j] > maxSum[i][j + \n1\n])\n                maxSum[i - \n1\n][j] = maxSum[i][j] + d[i - \n1\n][j];\n            else\n                maxSum[i - \n1\n][j] = maxSun[i][j + \n1\n] + d[i - \n1\n][j];\n        }\n    printf(\n\"%d\"\n, maxSum[\n1\n][\n1\n]);\n    return \n0\n;\n}\n\n\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\n\n#\ndefine\n MAX 101\n\n\nint\n D[MAX][MAX];\n\nint\n n;\nint\n* maxSum;\n\n\nint\n \nmain\n()\n \n{\n    \nint\n i, j;\n    cin >> n;\n    \nfor\n (i = \n1\n, i <= n;i++）\n        \nfor\n (j = \n1\n;j <= i;j++)\n            cin >> D[i][j];\n        maxSum = D[n];\n        \nfor\n (\nint\n i = n - \n1\n;i >= \n1\n, --i)\n            \nfor\n (\nint\n j = \n1\n;j <= i;++j)\n                maxSum[j] = \nmax\n(maxSum[j], maxSum[j + \n1\n]) + D[i][j];\n        cout << maxSum[\n1\n] << endl;\n}\n\n\n", "Tag": "算法分析"}
{"Answer": "\nvector<int>f[10];\nvector<int> add(vector<int> &A, vector<int> &B)\n{\n    if (A.size() < B.size()) return add(B, A);\n \n    vector<int> C;\n    int t = 0;\n    for (int i = 0; i < A.size(); i ++ )\n    {\n        t += A[i];\n        if (i < B.size()) t += B[i];\n        C.push_back(t % 10);\n        t /= 10;\n    }\n \n    if (t) C.push_back(t);\n    return C;\n}\n \nvoid solve(){\n         \n         string s;\n         cin >> s;\n         f[0].push_back(1);\n         for(int i = 0 ; i < s.size() ; i ++ ){\n             if(s[i] == 'c') f[1] = add(f[0],f[1]) ;\n             if(s[i] == 'h') f[2] = add(f[1],f[2]) ;\n             if(s[i] == 't') f[3] = add(f[2],f[3]) ;\n             if(s[i] == 'h') f[4] = add(f[3],f[4]) ;\n             if(s[i] == 'o') f[5] = add(f[4],f[5]) ;\n             if(s[i] == 'l') f[7] = add(f[7],f[6]) ;\n             if(s[i] == 'l') f[6] = add(f[6],f[5]) ;\n             if(s[i] == 'y') f[8] = add(f[8],f[7]);\n              \n         }\n         reverse(f[8].begin(),f[8].end());\n         for(auto i : f[8]) cout<<i;\n          \n}\n", "Konwledge_Point": "动态规划", "Question": "求字符串的子序列问题(语言-c++)\n题目描述\n\n\n众所周知，珂朵莉是世界上最幸福的女孩子；\n但这道题目与幸福没有任何关系；\n珂朵莉发现，对于任何一个字符串s都有一个珂学值，即其中含有子序列“chtholly”的个数\n由于珂学崇尚壮阔，珂学值的结果可能很大\n\n\n输入\n\n\n第1行一个字符串S。\n\n\n输出\n\n\n共1行，一个整数，表示珂学值\n\n\n提示\n\n\n对于10%的数据，|S|<=8\n对于30%的数据，|S|<=20\n对于60%的数据，|S|<=1000\n对于100%的数据，|S|<=100000\n答案保证在可输出的范围内\n\n\n我感觉应该是用dp 就写了一下\n但是代码卡在60分过不去了 显示答案错误 请指教一下哪里出了问题QAQ\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\nstring k={\n\"chtholly\"\n};\n\nlong\n \nlong\n  f[\n100005\n][\n13\n];\n\nchar\n ch[\n100005\n];\n\nint\n \nmain\n()\n\n\n{\n   \nscanf\n(\n\"%s\"\n,&ch);\n   \nint\n n=\nstrlen\n(ch);\n   \nfor\n(\nint\n i=\n0\n;i\n\n\nusing\n namespace std;\nstring k={\"chtholly\"};\nstring sum[\n8\n]={\"0\",\"0\",\"0\",\"0\",\"0\",\"0\",\"0\",\"0\"};\n\nchar\n ch[\n200005\n];\nstring \nadd\n(string  n,string  m)\n{\n   string x;\n   \nint\n a=n.size(),b=m.size();\n   \nint\n mins=min(a,b),\ntemp\n=\n0\n,i;\n   \nfor\n( i=\n0\n;i\n9\n)\ntemp\n=\n1\n;\n       \nelse\n \ntemp\n=\n0\n;\n       x+=(\nchar\n)(s%\n10\n+\n48\n);\n       //cout<\n9\n)\ntemp\n=\n1\n;\n       \nelse\n \ntemp\n=\n0\n;\n       x+=(\nchar\n)(s%\n10\n+\n48\n);\n       // cout<\n9\n)\ntemp\n=\n1\n;\n       \nelse\n \ntemp\n=\n0\n;\n       x+=(\nchar\n)(s%\n10\n+\n48\n);\n       // cout<=\n1\n;j\n--)\n\n       {\n           \nif\n(ch[i]==k[j])sum[j]=\nadd\n(sum[j\n-1\n],sum[j]);\n       }\n\n   }\n    \nfor\n(\nint\n i=sum[\n7\n].size()\n-1\n;i>=\n0\n;i\n--)cout<<sum[7][i];\n\n    \nreturn\n \n0\n;\n}\n", "Tag": "算法分析"}
{"Answer": "一、分析\n1、0是；2、负数不是；3、整数的话先拆解到栈中，然后比较头尾即可；\n二、题解\nbool isPalindrome(int x){\n    int stk[20], top = 0;\n    int i;\n    if(x == 0) {\n        return true;\n    }\n    if(x < 0) {\n        return false;\n    }\n\n    while(x) {\n        stk[top++] = x % 10;\n        x /= 10;\n    }\n    for(i = 0; i < top/2; ++i) {\n        if(stk[i] != stk[top-1-i]) {\n            return false;\n        }\n    }\n    return true;\n}\n", "Konwledge_Point": "动态规划", "Question": "有一道关于回文数的问题。\n给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。\n\n\n回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。\n\n\nhttps://leetcode-cn.com/problems/palindrome-number/", "Tag": "算法分析"}
{"Answer": "一、分析\n思路如下：\n1）如果在 1 到 maxn 之间的数字，映射到哈希数组中；\n2）然后从 1 开始遍历哈希数组，第一个没有被哈希的就是答案；\n3）所有数字都遍历完毕，仍然没有找到，则答案为 $n+1$。\n\n二、源码\n#define maxn 500001\nint hash[500001], cases = 0;\nint firstMissingPositive(int* nums, int numsSize){\n    int i;\n    ++cases;\n    for(i = 0; i < numsSize; ++i) {\n        if(nums[i] > 0 && nums[i] < maxn)\n            hash[ nums[i] ] = cases;        // (1) 如果在 1 到 maxn 之间的数字，映射到哈希数组中；\n    }\n    for(i = 1; i <= numsSize; ++i) {\n        if(hash[i] < cases) {\n            return i;                       // (2) 然后从 1 开始遍历哈希数组，第一个没有被哈希的就是答案；\n        }\n    }\n    return numsSize + 1;                    // (3) 所有数字都遍历完毕，仍然没有找到，则答案为 n+1；    \n}\n", "Konwledge_Point": "动态规划", "Question": "给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数\n给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。\n\n\n\n      \n        \n力扣\n\n        \n      \n\n      \n\n      \n\n        \n\n          \nhttps://leetcode-cn.com/problems/first-missing-positive/\n\n        \n\n      ", "Tag": "算法分析"}
{"Answer": "今天正好写了篇题解，可以赏脸看看dwd https://www.cnblogs.com/mosqu1to/p/15913766.html", "Konwledge_Point": "动态规划", "Question": "试题 算法训练 幸运的店家\n资源限制\n时间限制：1.0s   内存限制：256.0MB\n问题描述\n　　炫炫开了一家商店，卖的货只有一个，X，X卖N元钱。有趣的是，世界上只有面值为3的幂的纸币，即纸币只有1元的、3元的、9元的，有一天，桥神来买X，可他没办法正好给出N元钱，而炫炫没法找零，于是他只好用他的钱凑出了一个比N大，并且最小的价值，交给了炫炫。炫炫想知道，他这次最多可以得到多少张纸币。\n输入格式\n　　一个数，N\n输出格式\n　　一个数，为答案\n样例输入\n4\n样例输出\n2\n数据规模和约定\n　　n<=10^17\n\n\n究竟要怎么贪 ", "Tag": "算法分析"}
{"Answer": "#include <stdio.h>\nvoid swap(int* x, int *y) {            // (1)\n    int tmp = *x;\n    *x = *y;\n    *y = tmp;\n}\nint main() {   \n    int a, b, c;\n    while(scanf(\"%d %d %d\", &a, &b, &c) != EOF) {\n        if(a > b) swap(&a, &b);        // (2)\n        if(b > c) swap(&b, &c);        // (3)\n        if(a > b) swap(&a, &b);        // (4)\n        printf(\"%d %d %d\\n\", a, b, c);\n    }\n    return 0;\n}\n\n$(1)$ swap这个函数用来实现对两个整数的交换，int *x代表一个指针，指向的是某个变量的地址，函数体执行的就是交换两个变量的操作。其中，*x代表的是取地址中的值。$(2)$ $(3)$ $(4)$ 布对应的就是上文 解题思路 中提到的三步交换，由于swap函数的参数是指针，这里需要用&符号把变量转换成它的地址，即指针。", "Konwledge_Point": "动态规划", "Question": "【第13题】给定三个数 a，b，c，从小到大输出这三个数\n给定三个数 a，b，c，从小到大输出这三个数，这个怎么做呀\n数字范围是不定的", "Tag": "算法分析"}
{"Answer": "一、解析\n注意以下几个点：1）符号位；2）超int32；3）判断0的情况；\n二、源码\nint reverse(long long x) {\n    long long s = 0;  // (1) 存储结果；\n    int sign = +1;    // (2) 存储符号位；\n    if(x < 0) {       // (3) 判断x的符号位；\n        sign = -1;    // (4) 负数的情况；\n        x = -x;       // (5) 取反；\n    }\n    if(x == 0) {\n        return 0;     // (6) x 为 0 的情况直接返回；\n    }\n    while (x) {\n        s = s * 10 + (x % 10);\n        x /= 10;\n    }\n    s *= sign;        // (7) 别忘了\n\n    if(s < -((long long)1<<31) ) {\n        s = 0;\n    }else if(s > ((long long)1<<31) - 1 ) {\n        s = 0;\n    }\n\n    return s;\n}\n", "Konwledge_Point": "动态规划", "Question": "给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。\n给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。\n\n\n\n      \n        \n力扣\n\n        \n      \n\n      \n\n      \n\n        \n\n          \nhttps://leetcode-cn.com/problems/reverse-integer/\n\n        \n\n      ", "Tag": "算法分析"}
{"Answer": "par = [0.05,0.1,0.2,0.5,1.0,2.0] #存储每种硬币，从小到大排列\nsum = float(input(\"请输入需要找的零钱:\")) \n#从面值最大的开始遍历\ni = len(par) -1\nwhile i >= 0:\n    if sum >= par[i]:\n        n = int(sum // par[i])\n        change = n * par[i]\n        sum = float(\"%.6f\" %(sum - change))\n        print(\"用了%d个%1.2f元硬币\" % (n,par[i]))\n    i -= 1\n\npar是硬币种类,可以自行修改有帮助请点击采纳,谢谢", "Konwledge_Point": "动态规划", "Question": "python 贪心算法硬币找钱问题\n设有6 种不同面值的硬币，各硬币的面值分别为5 分，1 角，2 角，5 毛，1 元，2元。现要用这些面值的硬币来购物。在购物中希望使用最少个数硬币。例如，1 次购物需要付款0.55 元，如果没有5 角的硬币，只好用2∗2角+1∗1角+1∗5分 共4 枚硬币来付款。\n\n\n对于给定的各种面值的硬币个数和付款金额，计算使用硬币个数最少的交易方案。\n\n\n输入格式:\n输入数据有若干组，第一行给出一个整数n表示输入数据的组数。\n\n\n以下n行每一行有6 个整数和1个有2 位小数的实数。分别表示可以使用的各种面值的硬币个数和付款金额。\n\n\n输出格式:\n输出每组数据的最少硬币个数。如果不可能完成交易，则输出“impossible”。\n\n\n输入样例:\n2\n2 4 2 2 1 0 0.95\n2 4 2 0 1 0 0.55\n输出样例:\n4\n4", "Tag": "算法分析"}
{"Answer": "这是一道典型的背包问题。在这道题中，我们可以将每位骑士看作是一种物品，攻击力ai看作是价值，他自己的价格看作是他的攻击力。我们的目标是尽可能使用少的骑士来消灭恶龙，并且让国王支付的报酬最少。\n为了解决这道题，我们可以使用01背包算法来求解。首先，我们可以使用一个一维数组f[i]表示当恶龙的生命值为i时，国王支付的最低代价。然后，我们可以枚举每位骑士，分别计算出使用这位骑士可以让国王支付的最低代价。\n具体来说，我们可以使用以下代码来实现：\nfor (int i = 0; i < n; i++) {\n  for (int j = h; j >= a[i]; j--) {\n    f[j] = min(f[j], f[j - a[i]] + a[i]);\n  }\n}\n\n在上面的代码中，我们首先使用枚举骑士的循环来遍历每位骑士。然后，我们使用双重循环来枚举恶龙的生命值j。在循环中，我们可以使用 f[j] = min(f[j], f[j - a[i]] + a[i]) 语句来更新状态。在这个语句中，f[j] 表示当前的最低代价，f[j - a[i]] 表示使用第i位骑士的情况下的最低代价", "Konwledge_Point": "动态规划", "Question": "杀死恶龙II(dragon)DP\n杀死恶龙II(dragon)\n问题描述：\n王国里又来了一头恶龙，国王又到骑士工会征集n名骑士去杀死这条恶龙。假定这条恶龙的生命值为H，而每位骑士有攻击力ai，他可以砍伤恶龙ai点生命值，他所得的报酬就是他的攻击力。请你帮助国王计算，如果要杀死这个恶龙，也就是把恶龙的生命值全部消灭，他最少要支付多少报酬（注意：不一定要求这n名骑士都去攻击，只需要选择部分骑士即可完成任务，此时国王只需要支付参与攻击的那部分骑士即可）。\n输入格式：\n第一行为正整数n(≤100)和H(≤106)；第二行为n个正整数ai(≤105)，分别表示每位骑士的攻击力。\n输出格式：\n输出仅一个整数，表示国王必须支付的最低代价，如果不能杀死恶龙，输出-1。\n输入样例\n5 16\n3 1 3 5 6\n输出样例\n17", "Tag": "算法分析"}
{"Answer": "首先这是算法题.\r\n然后答案是:\r\n1 优惠力度最大的是2个花瓶加一朵花 原价12 现在10\r\n2 优惠力度次的是3朵花 优惠1元\r\n所以先计算能满足的2瓶1花数量\r\n再计算3花数量\r\n剩下的按原价\r\n将前面三个加起来就行\r\n实现:\r\nint p1 = 0;\r\nint p2 = 0;\r\nint n1 = n2 = 0;\r\nint price = 0;\r\np1 = (n1 % 2)\r\n\r\nif n2 >= p1&&p1!=0 n2=n2-p1;n1=n1-p1;\r\np2=n2%3\r\nif  p2>0 n2=n2-p2\r\n总价格为:p1*10+p2*5 + n1*2+n2*5", "Konwledge_Point": "动态规划", "Question": "有没有大神指导下，下面这道题用Java怎么做，能给出代码最好！\n商店中每种商品都有标价.例如,一朵花的价格是2元.一个花瓶的价格是5元.为了吸引顾客,商店提供了一组优惠商品价. 优惠商品是把一种或多种商品分成一组,并降价销售.例如,3朵花的价格不是6元而是5元.2个花瓶加1朵花的优惠价是10元.试设计一种算法,计算出某一顾客所购商品应付的最少费用. ", "Tag": "算法分析"}
{"Answer": "在 LIS 算法中，通常使用二分查找来查找第一个大于等于 a[i] 的元素的下标。\n这是因为，LIS 算法中所求的是最长上升子序列，也就是说，每一个元素都应该比它前面的元素要大。如果使用第一个大于 a[i] 的元素的下标，那么就可能会出现一个元素和它前面的元素相等的情况，这样就不能满足 LIS 的要求了。另一方面，如果要求最长不下降子序列，那么就可以使用第一个大于 a[i] 的元素的下标，因为最长不下降子序列中的元素是可以相等的。简单来说，在 LIS 算法中，用二分查找查找第一个大于等于 a[i] 的元素的下标，是为了保证 LIS 中的每一个元素都比它前面的元素要大。如果你想要求最长不下降子序列，就可以使用第一个大于 a[i] 的元素的下标。\n#include <stdio.h>\n#include <stdlib.h>\n\n#define max(a, b) ((a) > (b) ? (a) : (b))\n\nint n;\nint a[100005];\nint b[100005];\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d\", &a[i]);\n\n    int len = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        int left = 1, right = len;\n        while (left <= right)\n        {\n            int mid = (left + right) / 2;\n            if (b[mid] < a[i])\n                left = mid + 1;\n            else\n                right = mid - 1;\n        }\n        b[left] = a[i];\n        if (left > len)\n            len = left;\n    }\n\n    printf(\"%d\\n\", len);\n\n    return 0;\n}\n", "Konwledge_Point": "动态规划", "Question": "LIS的O(nlogn)算法中关于二分查找的问题\n用O(nlogn)算法 求最长上升子序列 和最长不下降子序列 中用到的二分搜索，是查找第一个 >= a[i] 的元素的下标还是第一个 > a[i] 的元素的下标？", "Tag": "算法分析"}
{"Answer": "vector创建二维数组，应该是这里错了。按着下面这个改一下//创建一个[99][99]的二维数组vector<vector > f(99,vector(99))", "Konwledge_Point": "动态规划", "Question": "vector实现背包dp，报错\n 背包dp，没报错，为什么运行不了啊。\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n\nusing\n \nnamespace\n std;\n\nvector <\nint\n> \nnum\n(\n0\n, \n0\n);\nvector <\nint\n> \nvalue\n(\n0\n, \n0\n);\n\nint\n m=\n0\n, n=\n0\n;\n\n\nint\n \nmain\n()\n\n\n{\n    \nsystem\n(\n\"color 2E\"\n);\n    cout << \n\"请输入商品数M ： \"\n;\n    cin >> m;\n    cout << \n\"请输入容器容量N ： \"\n;\n    cin >> n;\n    \nint\n temp=\n0\n;\n    cout << \n\"请输入每个商品的体积 ： \"\n<> temp;\n        num.\npush_back\n(temp);\n\n    }\n    cout << \n\"请输入每个商品的价值 ： \"\n << endl;\n    \nfor\n (\nint\n i = \n0\n; i < m; i++)\n    {\n        cin >> temp;\n        value.\npush_back\n(temp);\n    }\n    vector > \na\n(m + \n1\n, \nvector\n<\nint\n>(n + \n1\n));\n    \nfor\n (\nint\n i = \n0\n; i <= m; i++)\n    {\n        a[i][\n0\n] = \n0\n;\n    }\n    \nfor\n (\nint\n i = \n0\n; i <= n; i++)\n    {\n        a[\n0\n][i] = \n0\n;\n    }\n    \nfor\n (\nint\n i = \n1\n; i <= m; i++)\n    {\n        \nfor\n (\nint\n j = \n1\n; j <= n; j++)\n        {\n            \nif\n (num[i - \n1\n] < j)\n            {\n                a[i][j] = \n0\n;\n            }\n            \nelse\n\n            {\n                a[i][j] = \nmax\n(a[i\n-1\n][j],(value[i\n-1\n]+a[i\n-1\n][j-num[i\n-1\n]]));\n            }\n        }\n    }\n    cout << \n\"物品的最大价值为 ： \"\n;\n    cout << a[m + \n1\n][n + \n1\n] << endl;\n    \nreturn\n \n0\n;\n}\n\n\n\n\n\n\n 用一维数组就可以，但我想用vector\n在不改变变长数组的情况下正常输出", "Tag": "算法分析"}
{"Answer": "-2即4,294,967,294，4,294,967,294%1000就是294。可以这样试试（int）real", "Konwledge_Point": "动态规划", "Question": "关于#c##的问题：//计算rt_kprintf(\"dd=%d res=%f real=%d CIRCLE_CNT=%d\\n\",dd,res,real,CIRCLE_CNT)\n条件：real=-2 CIRCLE_CNT=1000 M_PI=3.1415\nint dd=(real) % CIRCLE_CNT;\ndouble res = (double)((real) % CIRCLE_CNT) * 2 * M_PI / CIRCLE_CNT;//计算\nrt_kprintf(\"dd=%d res=%f real=%d CIRCLE_CNT=%d\\n\",dd,res,real,CIRCLE_CNT);\n输出：dd=294 res=1.847256 real=-2\n感觉好奇怪，为什么dd是294？", "Tag": "算法分析"}
{"Answer": "用动态规划算法，结果是 1153760191515263502 种。\n", "Konwledge_Point": "动态规划", "Question": "从小于300的素数中，随机取出的组合，其和大于等于4567的有多少种？\n小于300的素数有62个，从中随机取出若干，可以是1个到62个，它们的和大于等于4567，这样的组合有多少个？", "Tag": "算法分析"}
