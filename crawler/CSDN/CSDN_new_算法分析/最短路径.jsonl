{"Answer": "Dijkstra算法伪代码 \n\nfor each node v    \n    dis(v) ← +∞    \n    previous (v) ← undefined    \n    dis(source) ← 0    \n    while num(S) < n    ▷ S为顶点集合\n        u ← node with smallest distance    \n        Remove u    \n        for each node v in S    \n            alt ← dis(u) + dis(u,v)    \n            if alt < dis(v) then    \n                dis(v) ← alt    ▷ 更新距离\n                previous(v) ← u    \n\n可以参考这篇博客（含MATLAB代码）：https://blog.csdn.net/lishan132/article/details/108527271这篇里面有讲解（有示例讲解）：https://blog.csdn.net/L_J_Kin/article/details/103061420", "Konwledge_Point": "最短路径", "Question": "Matlab 最短路径 起始点出发，回到起始点，经过所有点\n利用matlab图论知识求解，从起始点出发，经过其他所有点，然后返回起始点，求最短路径", "Tag": "算法分析"}
{"Answer": "TSP问题本质和城市间最短路径寻优问题一样，都是求两个点的最优路径，这种问题你要把这些实际数据想成是图的操作\r\nhttp://www.cnblogs.com/biaoyu/archive/2012/09/26/2704456.html", "Konwledge_Point": "最短路径", "Question": "蚁群算法 寻找最短路径的问题\n想搞个城市间最短路径寻优，网上全都是tsp问题，我只想要起点到终点的最优路径，不需要返回，该怎么写。。。能不能给点代码……", "Tag": "算法分析"}
{"Answer": "已找到，使用图网络模型可以实现。", "Konwledge_Point": "最短路径", "Question": "神经网络能否不失一般性地解图的最短路径问题？\n\n\n\n解最短路径问题，我看了一些网上的例子，多是训练DQN能够在某一特定图中找到最短路径（如图，在这个特定图中学习如何绕过黑点到达黄点）\n\n\n\n这种训练，相当于特定图的拓扑存储在了Q Matrix中，当图（环境）改变时则需要重新训练。\n\n问题：请问神经网络能否不失一般性地解图的最短路径问题？也就是不依赖某种特定的图拓扑，每次输入图拓扑和起点终点，输出最优路径", "Tag": "算法分析"}
{"Answer": "#define INF 1000000; 这里的分号去掉输入3 2，中间不能带逗号， 因为你是scanf(\"%d%d\",&n,&m);，两个%d之间没有逗号", "Konwledge_Point": "最短路径", "Question": "迪杰斯特拉求任意一点的最短路径问题遇到错误情况无法实现\n代码运行结果不对怎么直接就输出结果了，还有通过visit数组来判断是否经过那个点不知道正不正确\n\n\n#include\n#define SIZE 110\n#define INF 1000000;\nint map[SIZE][SIZE];  //邻接矩阵存储\nint len[SIZE];      //d[i]表示源点到i这个点的距离\nint visit[SIZE];  //节点是否被访问\nint n,m,j,pos,ans,temp;\n int temp = INF;\n\n\nint dijkstra(int from, int to){    //从源点到目标点\n    int i;\n    for(i = 1 ; i <= n ; i ++){    //初始化\n        visit[i] = 0;    //一开始每个点都没被访问\n        len[i] = map[from][i];    //先假设源点到其他点的距离\n    }  \n\n\nfor\n(i = \n1\n ; i < n ; ++i){    \n//对除源点的每一个点进行最短计算 \n\n    \nint\n min = INF;  \n//记录最小len[i] \n\n      \n//记录小len[i] 的点 \n\n    \nfor\n(j = \n1\n ; j <= n ; ++j){    \n        \nif\n(!visit[j] && min > \nlen\n[j]){  \n            pos = j;  \n            min = \nlen\n[j];  \n        }  \n    }  \n    visit[pos] = \n1\n;  \n    \nfor\n(j = \n1\n ; j <= n ; ++j){\n        \nif\n(!visit[j] && (\nlen\n[j] > (\nlen\n[pos] +\nmap\n[pos][j]))){ \n//如果j节点没有被访问过&&j节点到源节点的最短路径>pos节点到源节点的最短路径+pos节点到j节点的路径  \n\n            \nlen\n[j] = \nlen\n[pos] + \nmap\n[pos][j];    \n//更新j节点到源节点的最短路径    \n\n        }  \n    }  \n}  \n\nreturn\n \nlen\n[to];\n\n\n\n}\n\n\nint main ()\n{  \n\n\nint\n i,j;  \n\n\nint\n ans,u,v;\n\n\nprintf\n(\n\"输入顶点和边数\"\n);\n\nscanf\n(\n\"%d%d\"\n,&n,&m);    \n//输入数据\n\n\n\n\nfor\n(i = \n1\n ; i <= n ; ++i){    \n//设一开始每个点都不可达 \n\n    \nfor\n(j = \n1\n ; j <= n ; ++j){  \n        map[i][j] = INF;  \n    }  \n}  \n\n\nint\n a,b,c;    \n//输入数据 \n\n\nfor\n(i = \n1\n ; i <= m ; ++i){  \n    \nscanf\n(\n\"%d%d%d\"\n,&a,&b,&c);  \n    map[a][b] = map[b][a] = c;  \n}  \n\n\n\n   printf(\"输入起点和终点：\");\n   scanf(\"%d,%d\",&u,&v);\n\n\nans=dijkstra(u,v);\n\nfor\n(i=\n0\n;i<=n;i++)//输出途径点 \n{\n    \nif\n(visit[i]==\n1\n)\n    {\n        \nprintf\n(\n\"%d\"\n,i);\n    }\n}\n\nprintf\n(\n\"%d\"\n,ans);  \n\n\nreturn\n \n0\n;  \n\n\n\n} \n\n", "Tag": "算法分析"}
{"Answer": "上方图中共10个点，确定了起点，相当于9个点的全排列，可以非递归实现，也可以递归实现。共有9的阶乘：362880种走法，分别计算每一种路径的总距离，取最小的。运行截图如下：\n并结合了matplotlib和 pyecharts 可视化出了最短路径分别如下图\n\n\n源码见：\n\nPython访问街区所有节点最短路径问题，并结合matplotlib可视化_程序媛一枚~的博客-CSDN博客\n这篇博客将介绍如何全排列街区的点，即规定起点不重复的走完所有街区，并找出最短路径，并结合matplotlib、pyecharts对最短路径进行可视化。\n\n\n\nhttps://blog.csdn.net/qq_40985985/article/details/120199441\n\n\n回答不易，有帮助麻烦点下采纳哦", "Konwledge_Point": "最短路径", "Question": "访问所有节点的最短路径问题，节点只能访问一次，python实现。\n已知起点（310,385），访问所有节点，节点只能访问一次，不用返回起点。求最短路径，python实现，CVXPY 最好。思路和代码请详细说明，以便我学习。", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/alphapi/article/details/19770749", "Konwledge_Point": "最短路径", "Question": "求无向不带权图某点C到各点的最短路径dai'ma\n一个无向不带权图，有N个节点，M条路径\n\n求某一节点C到其他各路径的最短路径，并按顺序输出", "Tag": "算法分析"}
{"Answer": "你这个是最短路径计算，运费应该两个地点之间经过节点数计算，比如a到c，，经过5个节点，每个节点收费5元，运费就25元。你的要求包括了好几种最短路径算法，具体可以参考https://blog.csdn.net/printfxgd/article/details/80791847", "Konwledge_Point": "最短路径", "Question": "城市交通查询系统设计\n题目3: 城市交通查询系统设计内容：设计一个交通查询系统，能够查询：1)从一个城市到其它各城市之间的最短路径或运费最少的路径;2）多个城市中任意一对城市之间的最短路径或运费最少的路径。设计要求：（1）建立关于城市信息结点的结构体；（2）定义城市信息链表的结点结构；（3）建立交通网络图的存储结构；（4）写出采用Dijksta算法求每对顶点之间最短路径的算法函数；  （5）写出采用Floyed算法求任意一对顶点之间最短路径的算法函数；（6）输入交通网络图中的路径信息或费用信息；（7）根据Dijksta算法计算从太原到其它各大城市的最短路径或最小费用；（8）根据Floyed算法计算任意一对大城市之间的最短路径或最小费用；（9）对于不同的查询要求可以输入已知城市间的路程或所需费用信息。", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/ShiWaiGaoRen12345/article/details/69808597", "Konwledge_Point": "最短路径", "Question": "最短路径的数据结构的问题，C语言的问题，具体怎么解决的思路的问题\nProblem Description\n\nThere are n points on the plane, Pi(xi, yi)(1 <= i <= n), and xi < xj (i\nBefore you reach the rightmost point Pn, you can only visit the points those have the bigger x-coordinate value. For example, you are at Pi now, then you can only visit Pj(j > i). When you reach Pn, the rule is changed, from now on you can only visit the points those have the smaller x-coordinate value than the point you are in now, for example, you are at Pi now, then you can only visit Pj(j < i). And in the end you back to P1 and the tour is over.\n\nYou should visit all points in this tour and you can visit every point only once.\n\n\n\nInput\n\nThe input consists of multiple test cases. Each case begins with a line containing a positive integer n(2 <= n <= 200), means the number of points. Then following n lines each containing two positive integers Pi(xi, yi), indicating the coordinate of the i-th point in the plane.\n\n\n\nOutput\n\nFor each test case, output one line containing the shortest path to visit all the points with the rule mentioned above.The answer should accurate up to 2 decimal places.\n\n\n\nSample Input\n\n3\n\n1 1\n\n2 3\n\n3 1\n\n\n\nSample Output\n\n6.47", "Tag": "算法分析"}
{"Answer": "这个图有点特殊，每个节点都是关键节点，多条关键路径，因此每个节点的最早开始时间和最晚开始时间都是一样的。我认为是对的。", "Konwledge_Point": "最短路径", "Question": "最短路径中最早开始时间和最晚开始时间，写的对吗\n", "Tag": "算法分析"}
{"Answer": "#include \"stdio.h\"\nusing namespace std;\nstruct OP {\n    int next[10001], num = 0;  //  记入它接下来抵达的地方,num 为个数\n}op[10001];                    //  表示点个数,0为出发地,10000为目的地\n\nint f[10001],key[10001],k_len=50000;\nvoid find_MinRoad(int now,int num){  // 当前位置,当前走的步数\n    if(now==10000){\n        if(num<k_len) for(k_len=0;k_len<num;k_len++) key[k_len] = f[k_len];\n    }\n    if(now!=10000){\n        for(int z=0;z<op[now].num;z++) {\n            f[num] = op[now].next[z];\n            find_MinRoad(op[now].next[z],num+1);\n        }\n    }\n\n}\nint main()\n{\n    int road,a,b;                      //  road : 输入中间路的总个数，你的图为13,如果更多点把int 换成long op那的数组也再开大点\n    scanf(\"%d\",&road);\n\n    while (road--){\n        scanf(\"%d %d\",&a,&b); // a->b\n        op[a].next[op[a].num++] = b;\n    }\n\n    find_MinRoad(0,1);\n\n    printf(\"%d\\n\",k_len-1);\n    for(int z=0;z<k_len;z++) printf(\"%d \",key[z]);\n    return 0;\n}\n", "Konwledge_Point": "最短路径", "Question": "对于下图，利用最短路径算法，找到从家到学校最短路径长度（能够输出对应路径更好）\n对于下图，利用最短路径算法，找到从家到学校最短路径长度（能够输出对应路径更好）（C语言）", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/u014569598/article/details/25472851", "Konwledge_Point": "最短路径", "Question": "Risk(Floyd)               \nRisk is a board game in which several opposing players attempt to conquer the world. The gameboard consists of a world map broken up into hypothetical countries. During a player's turn, armies stationed in one country are only allowed to attack only countries with which they share a common border. Upon conquest of that country, the armies may move into the newly conquered country.\n\nDuring the course of play, a player often engages in a sequence of conquests with the goal of transferring a large mass of armies from some starting country to a destination country. Typically, one chooses the intervening countries so as to minimize the total number of countries that need to be conquered. Given a description of the gameboard with 20 countries each with between 1 and 19 connections to other countries, your task is to write a function that takes a starting country and a destination country and computes the minimum number of countries that must be conquered to reach the destination. You do not need to output the sequence of countries, just the number of countries to be conquered including the destination. For example, if starting and destination countries are neighbors, then your program should return one.\n\n\n\nThe following connection diagram illustrates the sample input.\n\n\n\nInput\n\n\n\nInput to your program will consist of a series of country configuration test sets. Each test set will consist of a board description on lines 1 through 19. The representation avoids listing every national boundary twice by only listing the fact that country I borders country J when I < J. Thus, the Ith line, where I is less than 20, contains an integer X indicating how many \"higher-numbered\" countries share borders with country I, then X distinct integers J greater than I and not exceeding 20, each describing a boundary between countries I and J. Line 20 of the test set contains a single integer (1 <= N <= 100) indicating the number of country pairs that follow. The next N lines each contain exactly two integers (1 <= A,B <= 20; A!=B) indicating the starting and ending countries for a possible conquest.\n\n\n\nThere can be multiple test sets in the input; your program should continue reading and processing until reaching the end of file. There will be at least one path between any two given countries in every country configuration.\n\n\n\nOutput\n\n\n\nFor each input set, your program should print the following message \"Test Set #T\" where T is the number of the test set starting with 1. The next NT lines each will contain the result for the corresponding test in the test set - that is, the minimum number of countries to conquer. The test result line should contain the start country code A the string \" to \" the destination country code B ; the string \": \" and a single integer indicating the minimum number of moves required to traverse from country A to country B in the test set. Following all result lines of each input set, your program should print a single blank line.\n\n\n\nSample Input\n\n\n\n1 3 \n\n2 3 4 \n\n3 4 5 6 \n\n1 6 \n\n1 7 \n\n2 12 13 \n\n1 8 \n\n2 9 10 \n\n1 11 \n\n1 11 \n\n2 12 17 \n\n1 14 \n\n2 14 15 \n\n2 15 16 \n\n1 16 \n\n1 19 \n\n2 18 19 \n\n1 20 \n\n1 20 \n\n5 \n\n1 20 \n\n2 9 \n\n19 5 \n\n18 19 \n\n16 20\n\n\n\nSample Output\n\n\n\nTest Set #1 \n\n1 to 20: 7 \n\n2 to 9: 5 \n\n19 to 5: 6 \n\n18 to 19: 2 \n\n16 to 20: 2 ", "Tag": "算法分析"}
{"Answer": "根据要求，大体的功能已实现，代码如下。如有帮助，望采纳！\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define THRESHOLD   32\n\n//用户基本信息\ntypedef struct _userInfo {\n    int id;         //学号\n    char name[20];  //姓名\n    char gender[4]; //性别\n    int age;        //年龄\n    int step;       //行走步数\n    struct _userInfo *next;\n} UsrInfo;\n//好友关系以及熟悉程度\ntypedef struct _relation {\n    int id1;        //用户1学号\n    int id2;        //用户2学号\n    int familiar;   //好友熟悉程度\n    struct _relation *next;\n} Relation;\n//接收信息缓冲区\ntypedef struct _buffer {\n    int id;                 //用户学号\n    char msg[THRESHOLD];    //接收信息缓冲区\n    int len;                //累积的信息长度\n    struct _buffer *next;\n} Buffer;\n//用户信息节点（如果改成这种结构可能更好一些，同一用户的信息全部在一个结构体，统一一个链表管理）\n//typedef struct _node {\n//    UsrInfo usrInfo;    //用户基本信息\n//    Relation relation;  //好友关系以及熟悉程度\n//    Buffer buffer;      //接收信息缓冲区\n//    struct _node *next;\n//} UsrNode;\n//UsrNode *head = NULL;   //用户信息链表头节点\nUsrInfo *lst = NULL; //用户基本信息链表头节点\nRelation *rel = NULL; //用户好友关系以及熟悉程度信息链表头节点\nBuffer *buf = NULL; //用户接收信息缓冲区链表头节点\n\n//添加用户\nint addUsr(UsrInfo *lst, int id, char *name, char *gender, int age, int step)\n{\n    if(lst == NULL) {\n        return -1;\n    }\n    UsrInfo *p = lst;\n    while(p) {\n        if(p->id == id) { //查找到有这个id的用户\n            printf(\"添加用户失败，id=%d的用户已存在！\", id);\n            return -2;\n        }\n        if(p->next == NULL) {\n            UsrInfo *node = (UsrInfo *)malloc(sizeof(UsrInfo));\n            node->id = id;\n            strcpy(node->name, name);\n            strcpy(node->gender, gender);\n            node->age = age;\n            node->step = step;\n            node->next = NULL;\n            p->next = node;\n            break;\n        }\n        p = p->next;\n    }\n    //同步生成接收信息缓冲区节点\n    Buffer *p2 = buf;\n    while(p2) {\n        if(p2->id == id) { //查找到有这个id的用户\n            p2->len = 0; //直接清空就可以\n            break;\n        }\n        if(p2->next == NULL) {\n            Buffer *node = (Buffer *)malloc(sizeof(Buffer));\n            node->id = id;\n            node->len = 0;\n            node->next = NULL;\n            p2->next = node;\n            break;\n        }\n        p2 = p2->next;\n    }\n    return 0;\n}\n\n//添加好友\nint addFriend(Relation *rel, int id1, int id2, int familiar)\n{\n    if(rel == NULL) {\n        return -1;\n    }\n    int flag1 = 0, flag2 = 0;\n    UsrInfo *p = lst;\n    while(p) { //查找用户是否存在\n        if(p->id == id1) {\n            flag1 = 1;\n        }\n        if(p->id == id2) {\n            flag2 = 1;\n        }\n        p = p->next;\n    }\n    if(flag1 == 0) {\n        return -2; //id1用户不存在\n    }\n    if(flag2 == 0) {\n        return -3; //id2用户不存在\n    }\n    Relation *q = rel;\n    while(q) { //查找好友关系是否存在\n        if((q->id1 == id1 && q->id2 == id2) || (q->id1 == id2 || q->id2 == id1)) {\n            return -4;\n        }\n        if(q->next == NULL) {\n            Relation *node = (Relation *)malloc(sizeof(Relation));\n            node->id1 = id1;\n            node->id2 = id2;\n            node->familiar = familiar;\n            node->next = NULL;\n            q->next = node;\n            break;\n        }\n        q = q->next;\n    }\n    return 0;\n}\n\n//从高到低打印用户行走步数的排行榜\nvoid printSteps(UsrInfo *lst)\n{\n    if(lst == NULL) {\n        return;\n    }\n    int n = 0;\n    printf(\"********************************\\n\\n\");\n    UsrInfo *p = lst->next;\n    while(p) { //遍历链表，统计用户个数\n        n++;\n        p = p->next;\n    }\n    if(n == 0) {\n        printf(\"行走步数排行榜为空，当前没有用户！\\n\");\n        printf(\"\\n\");\n    }\n    else {\n        char name[n][20], s[20];\n        int step[n];\n        int m = 0, t;\n        p = lst->next;\n        while(p) { //遍历链表，取出用户姓名和行走步数\n            strcpy(name[m], p->name);\n            step[m] = p->step;\n            m++;\n            p = p->next;\n        }\n        for(int i=0; i<n-1; i++) { //冒泡排序\n            for(int j=0; j<n-1-i; j++) {\n                if(step[j] < step[j+1]) {\n                    t = step[j];\n                    step[j] = step[j+1];\n                    step[j+1] = t;\n                    strcpy(s, name[j]);\n                    strcpy(name[j], name[j+1]);\n                    strcpy(name[j+1], s);\n                }\n            }\n        }\n        printf(\"行走步数排行榜\\n\\n\");\n        printf(\"排名\\t姓名\\t行走步数\\n\");\n        for(int i=0; i<n; i++) {\n            printf(\"%d\\t%s\\t%d\\n\", i+1, name[i], step[i]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"********************************\\n\");\n}\n\n//发送消息\nvoid sendMsg(UsrInfo *lst, Relation *rel, Buffer *buf, int id1, int id2, char *msg)\n{\n    if(lst == NULL || rel == NULL || buf == NULL) {\n        return;\n    }\n    int flag1 = 0, flag2 = 0;\n    UsrInfo *p = lst;\n    while(p) { //查找用户是否存在\n        if(p->id == id1) {\n            flag1 = 1;\n        }\n        if(p->id == id2) {\n            flag2 = 1;\n        }\n        p = p->next;\n    }\n    if(flag1 == 0) {\n        printf(\"发送消息失败，id1=%d的用户不存在！\\n\", id1);\n        return;\n    }\n    if(flag2 == 0) {\n        printf(\"发送消息失败，id2=%d的用户不存在！\\n\", id2);\n        return;\n    }\n    Relation *q = rel;\n    while(q) { //查找好友关系是否存在\n        if((q->id1 == id1 && q->id2 == id2) || (q->id1 == id2 || q->id2 == id1)) {\n            break;\n        }\n        q = q->next;\n    }\n    if(q == NULL) {\n        printf(\"发送消息失败，id1=%d和id2=%d不是好友关系！\\n\", id1, id2);\n    }\n    else {\n        Buffer *p2 = buf;\n        while(p2) { //查找用户是否存在\n            if(p2->id == id2) {\n                int msgLen = strlen(msg); //信息长度\n                if(p2->len + msgLen > THRESHOLD) { //缓冲区中积累的信息长度超过THRESHOLD=32个字符\n                    printf(\"接收信息缓冲区的内容： \");\n                    for(int i=0; i<p2->len; i++) {\n                        printf(\"%c\", p2->msg[i]);\n                    }\n                    printf(\"%s\\n\", msg);\n                    p2->len = 0;\n                }\n                else {\n                    strcpy(p2->msg + p2->len, msg);\n                    p2->len += msgLen;\n                }\n                printf(\"id1=%d向id2=%d发送信息成功，id2=%d用户接收信息缓冲区的信息长度为%d\\n\", id1, id2, id2, p2->len);\n                break;\n            }\n            p2 = p2->next;\n        }\n    }\n}\n\n//打印当前所有用户基本信息\nvoid printAllUsrInfo(UsrInfo *lst)\n{\n    if(lst == NULL) {\n        return;\n    }\n    printf(\"********************************\\n\\n\");\n    UsrInfo *p = lst->next;\n    while(p) {\n        printf(\"id:     %d\\n\", p->id);\n        printf(\"name:   %s\\n\", p->name);\n        printf(\"gender: %s\\n\", p->gender);\n        printf(\"age:    %d\\n\", p->age);\n        printf(\"step:   %d\\n\", p->step);\n        printf(\"\\n\");\n        p = p->next;\n    }\n    printf(\"********************************\\n\");\n}\n\n//计算各用户间的最短距离和最短路径（这个不好写）\n\nint main()\n{\n    int ret, select, running = 1;\n    lst = (UsrInfo *)malloc(sizeof(UsrInfo)); //用户基本信息链表头节点\n    rel = (Relation *)malloc(sizeof(Relation)); //用户好友关系以及熟悉程度信息链表头节点\n    buf = (Buffer *)malloc(sizeof(Buffer)); //用户接收信息缓冲区链表头节点\n    while(running == 1) {\n        printf(\"1 添加用户\\n\");\n        printf(\"2 添加好友\\n\");\n        printf(\"3 发送消息\\n\");\n        printf(\"4 打印行走步数的排行榜\\n\");\n        printf(\"5 打印当前所有用户基本信息\\n\");\n        printf(\"0 退出\\n\");\n        printf(\"Select > \");\n        scanf(\"%d\", &select);\n        printf(\"\\n\");\n        switch (select) {\n        case 1:\n        {\n            UsrInfo usrInfo;\n            printf(\"学号： \");\n            scanf(\"%d\", &usrInfo.id);\n            printf(\"姓名： \");\n            scanf(\"%s\", usrInfo.name);\n            printf(\"性别： \");\n            scanf(\"%s\", usrInfo.gender);\n            printf(\"年龄： \");\n            scanf(\"%d\", &usrInfo.age);\n            printf(\"行走步数： \");\n            scanf(\"%d\", &usrInfo.step);\n            ret = addUsr(lst, usrInfo.id, usrInfo.name, usrInfo.gender, usrInfo.age, usrInfo.step);\n            if(ret == 0) {\n                printf(\"添加id=%d的用户成功！\\n\", usrInfo.id);\n            }\n            else if(ret == -2) {\n                printf(\"添加用户失败，id=%d的用户已存在！\\n\", usrInfo.id);\n            }\n            break;\n        }\n        case 2:\n        {\n            int id1, id2, familiar;\n            printf(\"用户1学号： \");\n            scanf(\"%d\", &id1);\n            printf(\"用户2学号： \");\n            scanf(\"%d\", &id2);\n            printf(\"熟悉程度： \");\n            scanf(\"%d\", &familiar);\n            ret = addFriend(rel, id1, id2, familiar);\n            if(ret == 0) {\n                printf(\"添加好友成功！\\n\");\n            }\n            else if(ret == -2) {\n                printf(\"添加好友失败，id1=%d的用户不存在！\\n\", id1);\n            }\n            else if(ret == -3) {\n                printf(\"添加好友失败，id2=%d的用户不存在！\\n\", id2);\n            }\n            else if(ret == -4) {\n                printf(\"添加好友失败，id1=%d和id2=%d已经是好友关系！\\n\", id1, id2);\n            }\n            break;\n        }\n        case 3:\n        {\n            int id1, id2;\n            char msg[1000] = {0};\n            printf(\"发送方用户学号： \");\n            scanf(\"%d\", &id1);\n            printf(\"接收方用户学号： \");\n            scanf(\"%d\", &id2);\n            getchar();\n            printf(\"发送的信息： \");\n            gets(msg);\n            sendMsg(lst, rel, buf, id1, id2, msg);\n            break;\n        }\n        case 4:\n            printSteps(lst);\n            break;\n        case 5:\n            printAllUsrInfo(lst);\n            break;\n        case 0:\n            running = 0;\n            break;\n        default:\n            break;\n        }\n        if(running == 1) {\n            printf(\"\\n\");\n            system(\"pause\");\n            system(\"cls\");\n        }\n    }\n    //释放链表内存空间\n    if(lst) {\n        UsrInfo *p = lst;\n        UsrInfo *q = p;\n        while(p) {\n            q = p->next;\n            free(p);\n            p = q;\n        }\n        lst = NULL;\n    }\n    if(rel) {\n        Relation *p = rel;\n        Relation *q = p;\n        while(p) {\n            q = p->next;\n            free(p);\n            p = q;\n        }\n        rel = NULL;\n    }\n    if(buf) {\n        Buffer *p = buf;\n        Buffer *q = p;\n        while(p) {\n            q = p->next;\n            free(p);\n            p = q;\n        }\n        buf = NULL;\n    }\n    return 0;\n}\n\n", "Konwledge_Point": "最短路径", "Question": "数据结构题，比较急迫，c语言编写\n设计一个好友通信模拟软件，提供用户管理、好友管理、消息发送、运动健康等功能，具体需求如下：\n选择合适的数据结构（逻辑结构和物理结构）维护用户基本信息列表（即UsrInfo，包括学号id、姓名name、性别gender、年龄age、行走步数step）。（10分）\n选择合适的数据结构（逻辑结构和物理结构）维护用户间的好友关系以及熟悉程度（即Relation）。（10分）\n选择合适的数据结构（逻辑结构和物理结构）维护每个用户的接收信息缓冲区（即Buffer）。（10分）\n实现int addUsr(UsrInfo* lst, int id, char* name, char* gender, int age, int step)函数，向lst中新增用户并初始化基本信息，返回是否新增成功。（12分=算法设计与分析3分+算法实现9分）\n实现int addFriend(Relation* rel, int id1, int id2, int familiar)函数，向rel中新增id1和id2两个用户之间的好友关系；familiar为两用户间的熟悉程度（值越小表示熟悉程度越高），返回是否构建成功。（12分=算法设计与分析3分+算法实现9分）\n实现void printSteps(UsrInfo* lst)函数，从高到低打印用户行走步数的排行榜，包括姓名和步数。（12分=算法设计与分析3分+算法实现9分）\n实现void sendMsg(UsrInfo* lst, Relation* rel, Buffer* buf, int id1, int id2, char* msg)函数，如果id1和id2两个用户是好友，则把msg送入id2的接收信息缓冲区；如果id1和id2两个用户不是好友，则丢弃信息；若该缓冲区中积累的信息长度超过THRESHOLD=32个字符，则按接收先后顺序打印缓冲区中的信息，然后清空缓冲区。（16分=算法设计与分析4分+算法实现12分）\n实现int main()函数，通过调用addUsr、addFriend函数构建如图1所示的用户基本信息和好友关系；通过调用printSteps函数打印行走步数排行榜；通过调用sendMsg函数模拟信息发送过程。（8分）\n根据构建完成的好友关系，手动计算各用户间的最短距离和最短路径。（10分）", "Tag": "算法分析"}
{"Answer": "设open中有x,y两个点，全局最优路径中有x->y，等效证明x在y点前被取出：g(x)+h(x)<=g(x)+h*(x)<=g*(y)<=g(y)<=g(y)+h(y)", "Konwledge_Point": "最短路径", "Question": "A*算法大牛进，高分。\n1.如果h(n)经常都比从n移动到目标的实际代价小（或者相等），则A*保证能找到一条最短路径。h(n)越小，A*扩展的结点越多，运行就得越慢。\n\n2.如果h(n)有时比从n移动到目标的实际代价高，则A*不能保证找到一条最短路径，但它运行得更快。\n\n为什么？？？？？？？？？？？？？？？？？？？", "Tag": "算法分析"}
{"Answer": "https://github.com/daancode/a-star，可以参考这个项目如有帮助，请采纳，谢谢。", "Konwledge_Point": "最短路径", "Question": "使用Astar找最短路径\n\n\n使用Astar找最短路径  当到图中标记的那个点后  再往后就会到右边 无法继续行走  报错，\n代价的计算应该怎么改？ 有什么优化的方法吗 ", "Tag": "算法分析"}
{"Answer": "不同于网上找到的答案的\n#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\ntypedef struct data\n{\n    int x;\n    int y;\n    int len;\n} QDataType; //数据类型\n\ntypedef struct ListNode //通过链表实现的\n{\n    QDataType _data;\n    struct ListNode *_pNext;\n} ListNode, *pListNode;\n\ntypedef struct Queue\n{\n    pListNode _pHead; //头指针\n    pListNode _pTail; //尾指针\n} Queue;\n\npListNode BuyNode(QDataType d)\n{\n    pListNode new = malloc(sizeof(ListNode));\n    new->_data = d;\n    new->_pNext = NULL;\n    return new;\n}\n\nvoid QueueInit(Queue *q)\n{\n    assert(q);\n    QDataType d;\n    q->_pHead = BuyNode(d);\n    q->_pTail = q->_pHead;\n}\n\nvoid QueuePush(Queue *q, QDataType d)\n{\n    assert(q);\n    q->_pTail->_pNext = BuyNode(d);\n    q->_pTail = q->_pTail->_pNext;\n}\n\nvoid QueuePop(Queue *q)\n{\n    pListNode dNode = q->_pHead->_pNext;\n    if (dNode)\n    {\n        q->_pHead->_pNext = dNode->_pNext;\n        if (q->_pHead->_pNext == NULL)\n        {\n            q->_pTail = q->_pHead;\n        } //如果只有一个元素，删完后ptail会悬空\n        free(dNode);\n    }\n}\n\nint QueueSize(Queue *q)\n{\n    assert(q);\n    pListNode pre = q->_pHead->_pNext;\n    int count = 0;\n    while (pre)\n    {\n        count++;\n        pre = pre->_pNext;\n    }\n    return count;\n}\nint QueueEmpty(Queue *q)\n{\n    return NULL == q->_pHead->_pNext;\n}\nQDataType Front(Queue *q)\n{\n    return q->_pHead->_pNext->_data;\n}\nQDataType Back(Queue *q)\n{\n    return q->_pTail->_data;\n}\n\nQueue *q;\nint ds[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\nint m, n;\nint a[100][100];\n\nint bfs(int x, int y, int x2, int y2)\n{\n    QDataType d = {x, y, 0};\n    QueuePush(q, d);\n    a[x][y] = 2;\n    while (!QueueEmpty(q))\n    {\n        d = Front(q);\n        QueuePop(q);\n        for (int i = 0; i < 4; i++)\n        {\n            int tx = d.x + ds[i][0];\n            int ty = d.y + ds[i][1];\n            if (tx == x2 && ty == y2)\n            {\n                return d.len+1;\n            }\n            if (tx >= 0 && tx < m && ty >= 0 && ty < n && a[tx][ty] == 0)\n            {\n                QDataType t = {tx, ty, d.len+1};\n                QueuePush(q, t);\n                a[tx][ty] = 2;\n           }\n        }\n    }\n    return 0;\n}\n\nint main()\n{\n    int x1, y1, x2, y2;\n    int i, j;\n    q = (Queue *)malloc(sizeof(Queue));\n    QueueInit(q);\n    scanf(\"%d %d\", &m, &n);\n    for (i = 0; i < m; i++)\n    {\n        for (j = 0; j < n; j++)\n            scanf(\"%d\", &a[i][j]);\n    }\n    scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n    int len = bfs(x1, y1, x2, y2);\n    if (len>0)\n    {\n        printf(\"%d\", len);\n    }\n    else\n    {\n        printf(\"no path!\");\n    }\n    return 0;\n}\n\n", "Konwledge_Point": "最短路径", "Question": "c语言，运用队列的数据结构知识求解迷宫问题的最短路径步数。\n问题遇到的现象和发生背景\n\n\n给定一迷宫以及入口和出口的坐标，要求寻找从入口到出口的最短距离。\nInput\n第一行两个数m和n表示迷宫的行数和列数。迷宫大小不超过45×45。\n\n\n接下来是m行n列的数，用来表示迷宫，1表示墙，0表示通路。\n\n\n第二行四个数x1,y1,x2,y2分别表示起点和终点的坐标。\n\n\nOutput\n从起点到终点所经过的最短路径长度，如果不存在，输出\"no path!\"\n\n\nSample Input\n8 8\n0 0 0 0 0 0 0 1\n0 1 1 1 1 0 0 0\n0 1 0 1 1 1 1 0\n0 1 1 0 0 0 0 0\n0 0 0 1 0 1 1 1\n0 1 0 0 0 0 0 0\n0 1 1 1 1 1 1 0\n0 0 0 0 0 0 0 0\n0 0 1 7\nSample Output\n8\n\n\n问题相关代码，请勿粘贴截图\n\n\n运行结果及报错内容\n\n\n我的解答思路和尝试过的方法\n\n\n用队列求解。\n\n\n我想要达到的结果\n\n\n不同于网上找到的答案的，运用c语言的知识。", "Tag": "算法分析"}
{"Answer": "望采纳！！点击该回答右侧的“采纳”按钮即可采纳！", "Konwledge_Point": "最短路径", "Question": "如何用迪杰斯特拉函数得到最短路径和距离\n问题遇到的现象和发生背景\n\n\n利用迪杰斯特拉方法求最短路径\n\n\n遇到的现象和发生背景，请写出第一个错误信息\n\n\n代码中有错误 但是没有报错\n\n\n用代码块功能插入代码，请勿粘贴截图。 不用代码块回答率下降 50%\n\n\n\n> #\ninclude\n\n#\ninclude\n\n#\ninclude\n<\nstring\n.h>\n#\ninclude\n \n\n#define unreach \n100\n \n//没有途径的点之间的距离\n\n\n\nstruct\n map {\n    \nint\n edge\n[\n12\n]\n[\n12\n]\n;\n//储存距离\n\n    \nint\n S\n[\n12\n]\n;\n//储存点的信息\n\n    \nint\n edgenum;\n//边的个数\n\n}Map;\n\n\n//输入路径图的信息\n\nmap  \nCreatmap(\nint\n \nm\n)\n {\n    const \nchar\n* path = \n\"C:\\\\Users\\\\tyl666\\\\题目5-最短路径规划\\\\路径文件.txt\"\n;\n    FILE* fp = NULL;\n    fopen\n_s(&\nfp\n, \n\"path\"\n, \n\"r\"\n)\n;\n\n    \nint\n a, b, c;\n//点点边\n\n    \n//初始化点点距\n\n    \nfor\n (\nint\n i = \n0\n;i < \n12\n;i++) {\n        \nfor\n (\nint\n j = \n0\n;j < \n12\n;j++) {\n            \nif\n (i\n == \nj) {\n                \nMap\n.\nedge\n[\ni\n]\n[\nj\n]\n = \n0\n;\n            }\n            \nelse\n {\n                \nMap\n.\nedge\n[\ni\n]\n[\nj\n]\n = unreach;\n            }\n        }\n    }\n    \n//从文件中读取点与点之间的距离\n\n    \nfor\n (\nint\n i = \n0\n;i < \n21\n;i++)\n    {\n        fscanf\n_s(\nfp\n, \n\"%d,%d,%d\"\n, &\na\n, &\nb\n, &\nc\n)\n;\n        \nMap\n.\nedge\n[\na\n]\n[\nb\n]\n = c;\n        \nMap\n.\nedge\n[\nb\n]\n[\na\n]\n = c;\n    }\n    fclose(fp);\n\n    return Map;\n}\n\n//迪杰斯特拉算法\n\nvoid \nDijkstra(\nmap\n Map, \nint\n \nd\n, \nint\n \nm\n)\n//d设为起点\n\n{\n    \nint\n i, j, n;\n    d = \n1\n;\n    \n//利用动态数组\n\n    \nint\n* dist=\nnew\n \nint\n[\n12\n]\n;\n//储存当前最短路径的长度\n\n    \nchar\n* path=\nnew\n \nchar\n[\n12\n]\n;\n//储存最短路径\n\n    \nfor\n (i = \n0\n;i < \n12\n;i++) {\n        dist\n[\ni\n]\n = \nMap\n.\nedge\n[\nd\n]\n[\ni\n]\n;\n        path\n[\ni\n]\n = Map.S\n[\nd\n]\n + Map.S\n[\ni\n]\n;\n    }\n    \n//开始遍历路径图\n\n    \nfor\n (n = \n1\n;n < \n12\n;n++) {\n        \nfor\n (i = \n0\n, j = \n0\n;i < \n12\n;i++) {\n            \nif\n (dist\n[\ni\n]\n != \n0\n&&dist\n[\ni\n]\n dist\n[\nj\n]\n + \nMap\n.\nedge\n[\nj\n]\n[\ni\n]\n) {\n                dist\n[\ni\n]\n = dist\n[\nj\n]\n + \nMap\n.\nedge\n[\nj\n]\n[\ni\n]\n;\n                path\n[\ni\n]\n = path\n[\nj\n]\n + Map.S\n[\ni\n]\n;\n            }\n        }\n        dist\n[\nj\n]\n = \n0\n;\n    }\n}\n\n\nint\n main\n()\n\n{\n    \nint\n a = \n21\n;\n    \nint\n m = \n1\n;\n    Map = \nCreatmap(\na\n)\n;\n    \nDijkstra(Map, \nm\n, \na\n)\n;\n\n    return \n0\n;\n}\n\n\n\n\n运行结果及详细报错内容\n\n\n出现了debug警告\n\n\n我的解答思路和尝试过的方法，不写自己思路的，回答率下降 60%\n\n\n读取文件数据写入了地图数据，构造函数求最短路径\n\n\n我想要达到的结果，如果你需要快速回答，请尝试 “付费悬赏”\n\n\n得到最短路径和距离", "Tag": "算法分析"}
{"Answer": "i表示步数，从a顶点出发到b顶点只需要1步，故i=1。到其他顶点，以此类推；从a到d有3种走法，最短路径和是5（2+3，即 a -> b -> d），其他两种走法是  a -> c -> d， a -> b -> c -> d；∞表无穷大，即从某个节点到某个顶点之间是不可达。", "Konwledge_Point": "最短路径", "Question": "迪杰斯特拉算法求最短路径\n看不大懂以下这种迪杰斯特拉求最短路径的方法\n\n\n\n\n\n\n主要疑惑如下：\n1.答案中的i代表的是什么？\n2.为什么会有多个重复的结果出现，例如d行中有三个是完全一模一样的\n3.不是很能理解∞代表的是什么", "Tag": "算法分析"}
{"Answer": "最短路径不对，路径最短不代表它是由最短的边组成的比如最短的路径是1,100，第二短的路径是102条长度为1的路径组成，很显然最短路径跟这题完全不是同一个问题而且求最短路径你需要验证每个路径，很耗费时间这题其实最适合用贪心算法求，反正每路过一个节点，你都走最短的那条就对了", "Konwledge_Point": "最短路径", "Question": "与无向图最短路径有关\n问题\n：一个无向图有n个点，m条边，你现在在1号点，每条边有个对能力值的限制，要大于等于这个限制才能通过它。他们想知道他们至少要有多大的能力值，才能从1号点到n号点。\n\n\n输入\n：第一行两个正整数n,m。分别表示图的大小和边的数量。\n接下来m行，每行3个整数 u,v,l 。表示有一条u到v的边，至少要l能力值才能通过。地图保证1和n是连通的。\n\n\n数据规模\n：对于30%的数据： n<=m<=8\n对于100%的数据 , n<=m<=10^6,1<=u,v<=n,0<=l<=10^9\n\n\n输出描述\n：需要获得的最小的能力值，能够从1到n\n\n\n我的想法和出现的问题\n：我本来打算先求最短路径的，再找出最短路径上最长的一条边的值，但是它测试数据太大了，我邻接矩阵一开数组就爆栈了。有没有什么不爆数组的思路啊。", "Tag": "算法分析"}
{"Answer": "D\n最短路径算法：一个是迪杰斯特拉算法，求从某个源点到其余各顶点的最短路径，求解过程按路径长度递增的次序产生的最短路径，时间复杂度是O(n^2) ; 另一种算法是弗洛伊德算法，求 每一对顶点之间的最短路径，时间复杂度为O(n^3)。", "Konwledge_Point": "最短路径", "Question": "与费洛伊德算法中最短路径的时间复杂度相关的疑问\n请教图片中的这个内容该怎么做呢，我能该如何去解决，与费洛伊德算法中最短路径的时间复杂度相关的疑问", "Tag": "算法分析"}
{"Answer": "可以参考一下\nC语言——最短路径问题（Dijkstra算法）_秋米姐姐的博客-CSDN博客_c语言求最短路径\nC语言——最短路径问题（Dijkstra算法）优点——适用范围广，本代码属于公式型代码，可随意更换数据，适合零基础同学。主要思路：主要思路：1.用一个二维数组存放带权有向图的邻接矩阵；2.基于Dijkstra算法分别申请三个数组，distance[], path[], used[]分别记录从起点到其余各点的最短距离，到目标结点路径上的前一个结点，到图中某个结点是否已找到最短路径；3.逐渐确定从源点到图中各结点的最短路径，直至结束；最短路径例题：如下图所示，求最短经。<fn代码：\n\n\n\nhttps://blog.csdn.net/weixin_41598179/article/details/112795877\n\n", "Konwledge_Point": "最短路径", "Question": "【c语言】【数据结构】Dijkstra算法求最快送餐路径\n输入：第一行包含3个整数n,m,t，分别表示路口的个数，道路的条数和目的路口。\n（2 ≤ n ≤ 10，1 ≤ m ≤ 50，1 ≤ w ≤ 10）\n接下来m行每行包含三个整数 u,v,w，表示路口u到路口v存在一条耗时w的单行道。\n输出：骑手从商家（位于1号路口）到目的路口的最短时间，若路径不存在，输出-1。", "Tag": "算法分析"}
{"Answer": "shortest_path(G[, source, target, weight,...]) 计算图中的最短路径，可以用于无向图或有向图\ndijkstra_path(G, source, target[, weight]) 计算从源到目标的最短加权路径，用于有权图", "Konwledge_Point": "最短路径", "Question": "NetworkX 有权无向图计算最短路径\nNetworkX 有权无向图计算最短路径时函数shortest_path(G[, source, target, weight,…])和函数dijkstra_path(G, source, target[, weight])有什么区别？\n\n\n\n\n参考链接：\nhttps://blog.csdn.net/youcans/article/details/116999881?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167210396716800213045638%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167210396716800213045638&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-116999881-null-null.142^v68^control,201^v4^add_ask,213^v2^t3_control1&utm_term=networkx%20shortest_path&spm=1018.2226.3001.4187", "Tag": "算法分析"}
{"Answer": "如果想要在遍历图中的所有点之后得到最优路径，可以使用一种叫做旅行商问题（Travelling Salesman Problem，TSP）的算法。TSP 问题是指寻找遍历一个给定的城市列表的最短路径的问题。\n以下是一个示例实现：\ndef tsp(self, start, end):\n    # 初始化未遍历的点的集合\n    unvisited = set(self.nodes)\n    # 将起始点加入到已遍历的点的集合中\n    visited = {start}\n    # 初始化当前点为起始点\n    current = start\n    #初始化路径和距离为 0\n    path = []\n    distance = 0\nwhile unvisited:\n    # 寻找当前点的最近的未遍历的点\n    next_node, next_distance = min([(node, cost) for node, cost in self.adjacency_list[current] if node not in visited], key=lambda x: x[1])\n    # 将最近的未遍历的点加入到已遍历的点的集合中\n    visited.add(next_node)\n    # 从未遍历的点的集合中删除最近的未遍历的点\n    unvisited.remove(next_node)\n    # 更新当前点为最近的未遍历的点\n    current = next_node\n    # 更新路径和距离\n    path.append(next_node)\n    distance += next_distance\n\n# 如果最后一个遍历的点不是终点，添加一条从最后一个遍历的点到终点的边\nif current != end:\n    # 寻找最后一个遍历的点到终点的最短距离\n    next_distance = min([cost for node, cost in self.adjacency_list[current] if node == end])\n    # 更新路径和距离\n    path.append(end)\n    distance += next_distance\n\nreturn path, distance\n\n可以使用这个方法来解决 TSP 问题：\ngraph = Graph('map.txt')\npath, distance = graph.tsp('A', 'D')\nprint(path)  # ['A', 'B', 'C', 'D']\nprint(distance)  # 8\n\n仅供参考，望采纳，谢谢。", "Konwledge_Point": "最短路径", "Question": "怎么将任意两点间的最短路径改成任意两点间遍历完所有点后的最优路径呢\n\n\nclass\n \nGraph\n:\n            \ndef\n \n__init__\n(\nself,filename\n):\n#将地图建成一个邻接表\n\n        \n               graph_edges=[]\n#边的长度\n\n               \nwith\n \nopen\n(filename) \nas\n fhandle:\n#读取文件，一行一行的读\n\n                      \nfor\n line \nin\n fhandle:\n                          \nif\n line==\n\"\\n\"\n:\n#读取截止条件，注意必须加否则会报错\n\n                            \nbreak\n\n                \n#将map.txt文件中的数据按空格分离并存储，*_代表这一行后面所有的元素。\n\n                          edge_from,edge_to,cost,*_=line.strip().split(\n\" \"\n)\n                          graph_edges.append((edge_from,edge_to,cost))\n#以元组的形式加入到graph_edges\n\n        \n#建立节点，set() 函数创建一个无序不重复元素集，\n\n        \n#可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。\n\n               self.nodes =\nset\n()\n               \nfor\n edge \nin\n graph_edges:\n            \n#初始化节点\n\n            \n#update() 方法用于修改当前集合，可以添加新的元素或集合到当前集合中，\n\n            \n#如果添加的元素在集合中已存在，则该元素只会出现一次，重复的会忽略。\n\n                  self.nodes.update([edge[\n0\n],edge[\n1\n]])\n        \n#建立邻接表\n\n               self.adjacency_list = {node: \nset\n() \nfor\n node \nin\n self.nodes}\n               \nfor\n edge \nin\n graph_edges:\n           \n#字典中的键表示图中的节点，而键值则是以字典的形式存在里面包括几组一元组的形式储存的\n\n           \n#表示可达到节点以及权值\n\n                   self.adjacency_list[edge[\n0\n]].add((edge[\n1\n],edge[\n2\n]))\n            \ndef\n \nshortest_path\n(\nself, start_node, end_node\n):\n                start_node=nameEntry3.get()\n                end_node=nameEntry4.get()\n               \n        \n#使用Dijkstra算法找到从起始点到终点的最短路径，返回（path,distance）\n\n               \n        \n#创造一个未访问节点的集合初始化为所有节点\n\n                unvisited_nodes = self.nodes.copy()  \n        \n#创建一个字典表示每个点到起始点的距离，每个点先初始化为inf除了点本身初始化为0\n\n        \n#当我们找到一个更短路径的时候更新这个字典所对应的值，数据结构为 节点：距离\n\n                distance_from_start = {node: (\n0\n \nif\n node == start_node \nelse\n INFINITY) \nfor\n node \nin\n self.nodes}\n \n        \n#初始化前置节点也就是用来寻找路径的方法，结构为节点：节点其中后面的节点是前面\n\n        \n#的前置节点，由此可以一步步找到路径，如果找到更短路径就更新这个字典\n\n                previous_node = {node: \nNone\n \nfor\n node \nin\n self.nodes}\n                \nwhile\n unvisited_nodes:\n            \n#将当前节点设置为到目前为止在未访问节点这个字典中路径最短的节点\n\n                     current_node = \nmin\n(\n                \n#从unvisited_nodes中找到键值最小的节点作为当前节点\n\n                          unvisited_nodes, key=\nlambda\n node: distance_from_start[node]\n                       )\n            \n#从未访问的节点中，移除当前节点\n\n                     unvisited_nodes.remove(current_node)\n            \n#如果当前节点的距离为无穷大，则其余未访问的节点不会连接到开始节点，停止\n\n                     \nif\n distance_from_start[current_node] == INFINITY:\n                       \nbreak\n\n \n            \n#遍历每个当前节点的邻居，检查一下从起始节点到当前节点再到邻居节点的距离的大小\n\n            \n#与distance_form_start中的比较看看是否更小，是讲究更新distance中所对应的值\n\n                     \nfor\n neighbor, distance \nin\n self.adjacency_list[current_node]:\n                \n#新的路径的距离\n\n                        new_path = distance_from_start[current_node] + \nint\n(distance)\n                        \nif\n new_path < distance_from_start[neighbor]:\n                             distance_from_start[neighbor] = new_path\n#更新值\n\n                             previous_node[neighbor] = current_node\n#更新路径，将当前节点作为邻居的前置节点\n\n \n        \n#为了找到我们所建立的最短路径，使用迭代器遍历每个点的前置节点即可找到路径\n\n        \n#并且把他存入一个队列中之所以可以保证找得到前置节点，是因为算法完成时候每个点的前置节点都代表着\n\n        \n#到起始点的最短路径\n\n                path = deque()\n                current_node = end_node\n                \nwhile\n previous_node[current_node] \nis\n \nnot\n \nNone\n:\n                       path.appendleft(current_node)\n                       current_node = previous_node[current_node]\n                path.appendleft(start_node)\n                \nreturn\n path, distance_from_start[end_node]\n       \n                   \n\n\n\n怎么将任意两点间的最短路径改成任意两点间遍历完所有点后的最优路径呢", "Tag": "算法分析"}
{"Answer": "超时了，换个算法", "Konwledge_Point": "最短路径", "Question": "洛谷P4779最短路径问题TLE\n\n\n#include\nusing namespace std;\nint  a[10005][10005];\nint  d[10005],i,j;\nconst int INF=1e9;\nint t;\nint read()\n{\n    int x=0,y=1;\n    char c;\n    while(c<'0'||c>'9'){if(c=='-')y=-1;c=getchar();}\n    while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}\n    return x*y;\n}\nvoid dij(int n)//单源最短路径\n{\n    bool f[10005]={0};\n    f[1]=1;\n    int v;\n    for(i=1;id[j])//找未标记中最小的\n            {\n                min=d[j];\n                v=j;\n            }\n        }\n        f[v]=1;//标记\n        for(j=v;j<=n;j++)\n        {\n            if(!f[j]&&a[v][j]+d[v]<d[j])//更新路径长度\n            {\n                d[j]=a[v][j]+d[v];\n            }\n        }\n    }\n}\n\n\nint main()\n{\n    int n,m,x,y,z;\n    n=read(),m=read(),t=read();\n    for(i=1;i<=m;i++)\n    {\n        x=read(),y=read(),z=read();\n        a[x][y]=z;\n    }\n    for(i=1;i<=n;i++)\n    {\n        d[i]=a[t][i];//路径长度初始化]]\n    }\n    dij(n);\n    for(i=1;i<=n;i++)\n    {\n        printf(\"%d\\n\",d[i]);\n    }\n    return 0;\n}\n爆TLE，请问这个程序哪里出了问题？", "Tag": "算法分析"}
{"Answer": "直接bfs就行了，毕竟询问次数较少", "Konwledge_Point": "最短路径", "Question": "PTA 7-3 幸福小镇的故事! (最短路径直接用floyd会超时怎么办?)\n7-3 幸福小镇的故事！（简单） (25 分)\n\n\n\n在一个很远很远的地方，有一个幸福小镇！\n\n\n\n幸福小镇的治安很不好，所以生活在镇上很不幸福！\n\n\n\n新来的保安队队长小Z决心改变这一切，第一步要解决的是任何两个小镇之间的距离问题！\n\n\n\n我们需要解决这个问题的简化版本：\n\n\n\n幸福小镇可以划分为N个小小镇，从1到N编号！这些小小镇由N-1条道路连通，我们把每条道路的长度简化为1！只要在每个小小镇增派人手，就可以让小镇的治安情况变得越来越好！（题目保证两个小镇之间的道路只有一条！）\n\n\n\n每次小Z会询问你两个小小镇的编号，请你计算出这两个小镇之间的最短路径长度！\n\n\n\n输入格式:\n\n\n\n第一行包含一个正整数（N<=1000），表示小小镇的个数！\n\n\n\n接下来N-1行，每行包含两个1到N之间的整数，表示这两个编号的小小镇之间有一条路！\n\n\n\n接下来一行包含一个整数q（q<=100)，表示询问数！\n\n\n\n接下来q行，每行包含两个小小镇的编号，请在一行中输出这两个小小镇的最短路径长度！\n\n\n\n输出格式:\n\n\n\n输出答案即可！\n\n\n\n输入样例:\n\n\n\n在这里给出一组输入。例如：\n\n\n\n\n\n10\n1 2\n2 3\n1 4\n4 5\n4 6\n3 7\n3 8\n1 9\n9 10\n5\n3 8\n9 3\n1 1\n1 7\n1 9\n\n\n\n输出样例:\n\n\n\n在这里给出相应的输出。例如：\n\n\n\n\n\n1\n3\n0\n3\n1", "Tag": "算法分析"}
{"Answer": "这是一个实现迪杰斯特拉算法的代码，用于求解单源最短路径问题。该算法是一种贪心算法，每次求解的时候都会找到当前能到达的点中距离起点最近的点，并从该点开始搜索下一步能到达的点，直到到达终点。\n具体来说，代码中使用了三个栈：\n1、stack 栈用来存储搜索路径中的点。2、stackdata 栈用来存储每条边的距离。3、stackfindlj 栈用来存储所有可能的路径，其中的每一行都是一条路径，第一个元素为起点，其余的元素为路径中的每个点。首先，从起点开始搜索，如果找到了一条边且这条边还没有访问过，就将这条边加入路径中，并将这条边的距离加入路径距离中。然后从这条边的终点开始继续搜索，如果能找到一条边且这条边还没有访问过，就将这条边加入路径中，并将这条边的距离加入路径距离中。重复这个过程直到到达终点，或者找不到新的边可以加入路径中。\n所有的路径被保存在 stackfindlj 中，其中的每一行都是一条路径。接下来，遍历所有的路径，找到路径距离最小的路径。将这条最短路径的信息复制到一个名为 temp 的结构体中，并返回这个结构体。\n这个结构体中包含两个信息：\n1、stack 数组用来存储最短路径中的点。2、jl 变量用来存储最短路径的距离。\n如果想输出最短路径的途径点信息，可以在输出路径距离之后添加以下代码：\nprintf(\"最短路径为：\");\nfor (int i = 0; i < 50; i++) {\n  if (temp.stack[i] != 0) {\n    printf(\"%d \", temp.stack[i]);\n  }\n}\nprintf(\"\\n\");\n\n这段代码会依次输出最短路径中的所有点。仅供参考，望采纳，谢谢。", "Konwledge_Point": "最短路径", "Question": "构造了一个迪杰斯特拉函数，但是不会得出最短路径的途径点信息，需要更详细的注释\n问题遇到的现象和发生背景 构造了一个计算函数，如何得到最短路径的点的信息以及需要更详细的注释\n\n\n遇到的现象和发生背景，请写出第一个错误信息\n\n\n用代码块功能插入代码，请勿粘贴截图。 不用代码块回答率下降 50%\n\n\nstruct \nMyStack\n  \n{\n    int stack[\n50\n];//栈\n    int jl;//距离\n};\n//迪杰斯特拉算法\n\nMyStack\n \nDijkstra\n(map \nMap\n, int d, int e)//d设为起点,e设为终点\n{\n    int stack[\n50\n] = { \n0\n }, id1 = \n0\n;\n    int stackdata[\n50\n] = { \n0\n }, id2 = \n0\n;\n    int stackfindlj[\n50\n][\n50\n] = { \n0\n }, id3 = \n0\n;//路径保存\n    int stackfindjl[\n50\n] = { \n0\n };//距离保存\n    int isfind = \n0\n;\n    for (int i = d; i < d + \n1\n; i++)\n    {\n        for (int j = i; j < \n12\n; j++)\n        {\n            int edge[\n12\n][\n12\n] = { \n0\n };//辅助地图\n            if (\nMap\n.edge[i][j] != \n100\n && \nMap\n.edge[i][j] != \n0\n && edge[i][j] == \n0\n)\n            {\n                stack[id1++] = j;\n                stackdata[id2++] = \nMap\n.edge[i][j];//边的距离\n                edge[i][j] = \n1\n;//辅助地图\n                while (id1)\n                {\n                    for (int k = stack[id1 - \n1\n]; k < \n12\n; k++)\n                    {\n                        if (\nMap\n.edge[stack[id1 - \n1\n]][k] != \n100\n && \nMap\n.edge[stack[id1 - \n1\n]][k] != \n0\n && edge[stack[id1 - \n1\n]][k] == \n0\n)//开始搜寻路径\n                        {\n                            edge[stack[id1 - \n1\n]][k] = \n1\n;\n                            stackdata[id2++] = \nMap\n.edge[stack[id1 - \n1\n]][k];\n                            stack[id1++] = k;\n                            if (k == e)//到达了终点\n                                isfind = \n1\n;\n                            break;\n                        }\n                        if (k == \n11\n)\n                        {\n                            id1--; id2--;\n                        }\n                    }\n                    if (isfind == \n1\n)\n                    {\n                        stackfindlj[id3][\n0\n] = i + \n1\n;\n                        for (int k = \n0\n; k < id1; k++)\n                        {\n                            stackfindlj[id3][k + \n1\n] = stack[k] + \n1\n;\n                            stackfindjl[id3] += stackdata[k];\n                        }\n                        id3++;\n                        isfind = \n0\n;\n                    }\n                }\n            }\n        }\n    }\n    int min = stackfindjl[\n0\n], minidx = \n0\n;\n    for (int i = \n0\n; i < id3; i++)\n    {\n        if (min > stackfindjl[i])\n        {\n            min = stackfindjl[i];\n            minidx = i;\n        }\n    }\n    \nMyStack\n temp = { \n0\n };\n    memcpy(&temp.stack, &stackfindlj[minidx], sizeof(int) * \n50\n);//将得到的最短路径复制到结构体的数组之中\n    temp.jl = min;//将得到的最短距离赋值到结构体的距离中\n    printf(\n\"最短路径距离为：%d\\n\"\n, temp.jl);\n    return temp;\n\n\n\n\n运行结果及详细报错内容\n\n\n只会输出最短距离\n\n\n我的解答思路和尝试过的方法，不写自己思路的，回答率下降 60%\n\n\n迪杰斯特拉函数\n\n\n我想要达到的结果，如果你需要快速回答，请尝试 “付费悬赏”", "Tag": "算法分析"}
{"Answer": "\n \n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 100;\nstruct Edge{\n    int next;\n    int to;\n    int len;\n    int speed;\n}edge[MAXN];\nint cnt;\nint head[MAXN];\nvoid Add_Edge(int u, int v, int speed, int len){\n    edge[cnt].next = head[u];\n    edge[cnt].to = v;\n    edge[cnt].speed = speed;\n    edge[cnt].len = len;\n    head[u] = cnt++;\n}\nint dis[MAXN];\nstruct st{\n    int id;\n    int dis;\n    bool operator < (const st &B)const{\n        return dis > B.dis;\n    }\n};\nint vis[MAXN];\nconst int INF = 0x3f3f3f3f;\nvoid dijkstra(int s){\n    dis[s] = 0;\n    priority_queue<st> q;\n    q.push(st{s, dis[s]});\n    while(!q.empty()){\n        auto u = q.top();\n        q.pop();\n        if(vis[u.id]) continue;\n        vis[u.id] = 1;\n        for(int i=head[u.id];~i;i=edge[i].next){\n            int v = edge[i].to;\n            if(!vis[v] && dis[u.id] + edge[i].len < dis[v]){\n                dis[v] = dis[u.id] + edge[i].len;\n                q.push(st{v, dis[v]});\n            }\n        }\n    }\n}\nconst double eps = 1e-10;\nint dcmp(double x){\n    if(fabs(x) < eps) return 0;\n    return x < 0 ? -1 : 1;\n}\nstruct st2{\n    int id;\n    double t;\n    bool operator < (const st2 &B)const{\n        return dcmp(t - B.t) > 0;\n    }\n};\ndouble dis2[MAXN];\nconst double INF2 = 999999999.0;\nvoid dijkstra2(int s){\n    dis2[s] = 0.0;\n    priority_queue<st2> q;\n    q.push(st2{s, dis2[s]});\n    while(!q.empty()){\n        auto u = q.top();\n        q.pop();\n        if(vis[u.id]) continue;\n        vis[u.id] = 1;\n        for(int i=head[u.id];~i;i=edge[i].next){\n            int v = edge[i].to;\n            if(!vis[v] && dcmp(dis2[v] - dis2[u.id] - edge[i].len * 1.0 / edge[i].speed) > 0){\n                dis2[v] = dis2[u.id] + edge[i].len * 1.0 / edge[i].speed;\n                q.push(st2{v, dis2[v]});\n            }\n        }\n    }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin >> n >> m;\n    memset(head, -1, sizeof head);\n    memset(dis, 0x3f, sizeof dis);\n    for(int i=0;i<m;i++){\n        int u, v, speed, len;\n        cin >> u >> v >> speed >> len;\n        Add_Edge(u, v, speed, len);\n        Add_Edge(v, u, speed, len);\n    }\n    int q;\n    dijkstra(1);\n    memset(vis, 0, sizeof vis);\n    for(int i=0;i<=n;i++) dis2[i] = INF2;\n    dijkstra2(1);\n    cin >> q;\n    while(q--){\n        int j;\n        char c;\n        cin >> j >> c;\n        if(c == 's'){\n            if(dis[j] == INF) cout << \"IMPOSSIBLE\\n\";\n            else cout << dis[j] << ' ' << \"km\\n\";\n        }else{\n            if(dcmp(dis2[j] - INF2) == 0) cout << \"IMPOSSIBLE\\n\";\n            else cout << fixed << setprecision(8) << dis2[j] << ' ' << \"h\\n\";\n        }\n    }\n    return 0;\n}\n", "Konwledge_Point": "最短路径", "Question": "算法题求解！最短路径+动态规划 C++\n题目设计：\n你怀疑你的导航系统有时会选择低效的路线。\n所以你决定收集一些关于你所在地区的道路系统的数据并编写一个程序，计算出从你的家到你所在地区的最短（综合道路长度）和最快（预期旅行时间）的路线。\n为了使这一任务易于管理，你想出了一个简单的模型。道路系统道路系统由路口（数字从1到N）和连接它们的道路组成，每条道路都有一个限速（单位：km/h）和一个长度（单位：km）。\n在其中一个路口转换道路既不耗费时间也不耗费距离。\n为了简单起见，你还假设所有的道路都是双向的，并且你可以一直以限速行驶。\n\n\n输入的内容包括\n\n\n一行包含N和M(2 ≤ N ≤ 5 · 10^4^, 1 ≤ M ≤ 2 · 10^5^) --分别表示路口和道路的数量\nM行描述道路，第 i 行包含bi, ei, vi和 i (1 ≤ bi，ei≤N，20≤vi≤150，1≤ i ≤300）分别代表第i条道路，与其连接的路口，速度限制和长度（所有这些输入都是整数)\n一行包含 Q（1 ≤ Q ≤ 1000）--查询的数量\nQ行给出查询，每行包括一个整数 j：目的地路口的索引和一个字符c∈{'s', 'f'}\n\n\n 输出\n\n\n对于's'类型的查询，输出从你的家（1号路口）到指定目的地的最短路线的长度。\n对于'f'类型的查询，输出从你的家到指定目的地的最短旅行时间（假设一直按限速行驶），精度为10^-3^\n使用与输入相同的单位，用空格分隔数量和单位。如果一个给定的目的地不能到达，输出 \"IMPOSSIBLE\"。\n\n\n例如：\n\n\n\n\n第三组：\n20 80\n19 15 57 179\n20 20 125 175\n5 4 60 34\n9 10 24 85\n18 8 114 244\n19 9 23 245\n1 5 115 132\n7 17 45 117\n6 12 24 109\n1 12 116 83\n3 3 83 270\n20 20 145 65\n9 13 78 47\n11 14 40 152\n9 15 79 70\n18 9 72 101\n19 5 105 282\n2 3 120 90\n20 13 105 186\n2 4 72 145\n13 18 103 90\n1 3 26 143\n19 13 45 7\n5 14 39 295\n9 7 74 218\n15 5 73 131\n6 15 79 255\n6 15 56 113\n14 5 40 157\n17 17 57 216\n17 14 106 260\n18 9 121 201\n7 11 76 25\n14 17 20 144\n10 6 49 285\n6 16 88 95\n6 4 82 96\n10 16 121 187\n19 11 100 294\n6 9 129 241\n4 4 90 99\n11 15 79 130\n5 8 95 108\n19 15 29 285\n19 20 122 280\n19 13 76 13\n12 16 67 88\n18 10 107 56\n2 18 147 300\n6 15 27 130\n16 6 80 28\n8 5 101 96\n16 16 76 130\n12 3 134 1\n17 4 145 284\n14 9 24 203\n5 13 39 140\n12 9 116 254\n5 12 141 52\n16 3 68 95\n17 1 44 14\n12 20 62 161\n18 16 129 72\n16 18 117 114\n20 17 128 271\n2 1 92 255\n1 19 74 115\n15 2 57 240\n18 7 41 140\n14 1 107 280\n4 6 66 205\n6 10 60 209\n17 2 112 42\n8 2 45 14\n7 16 59 33\n13 16 40 270\n17 6 41 59\n4 13 57 245\n19 11 55 97\n2 8 115 80\n10\n2 s\n15 f\n7 s\n17 f\n8 f\n9 f\n17 s\n16 f\n2 s\n3 f\n\n\n输出：\n56 km\n2.87883212 h\n131 km\n0.31818182 h\n1.00429293 h\n2.31217371 h\n14 km\n2.02895008 h\n56 km\n0.72297993 h\n\n\n关于这道题应该要用到Dijkstra算法或者Moore-Bellman-Ford 算法？希望可以给个详细点的代码，谢谢！\n学到的算法如下代码\n\n\nvoid\n dijkstra_set (\nint\n s, \nint\n n) {\n    fill (d, d + n + \n1\n, INF ) ;\n    d[s] = \n0\n;\n\n    \nset\n  > dst ;\n    dst . \ninsert\n ({d[s], s}) ;\n\n    \nwhile\n (! dst. empty () ) {\n        \nint\n v = dst . \nbegin\n () -> second ;\n        dst . erase ( dst . \nbegin\n () );\n        \nfor\n ( auto e: edges [v])\n              \nif\n (d[v] + e. \ncost\n < d[e.u]) {\n                  dst . erase ({d[e.u], e.u}) ;\n                  d[e.u] = d[v] + e. \ncost\n ;\n                  dst . \ninsert\n ({d[e.u], e.u}) ;\n              }\n     }\n}\n", "Tag": "算法分析"}
{"Answer": "该回答引用ChatGPT \n1、Dijkstra算法可以用于解决最短路径问题。假设城市A为源点，城市B为终点，可以先将所有城市的距离初始化为无穷大，将城市A到其他城市的距离更新为实际距离，然后选取距离A最近的城市，将它到其他城市的距离与A到其他城市的距离进行比较并更新，直到所有城市的距离都被更新过。最终，从A到B的最短路径即为路径上所有边的距离之和。\n2、可以使用广度优先搜索算法（BFS）解决转车次数最少的问题。假设城市A为起点，城市B为终点，将A加入队列，从队列中取出A，遍历A可直达的城市并将其加入队列，标记A为已访问过。接着从队列中取出下一个城市，重复上述过程直到取出B或者队列为空。在遍历时，使用一个数组记录下每个城市到起点的最短距离，每当遍历到一个城市时，如果到达这个城市的路径比之前记录的路径短，就更新这个城市的最短路径。最终，到达B的路径上的中转次数即为B的最短路径上的城市个数减1。\n3、可以将1和2中的方法结合起来。先按照Dijkstra算法计算出从A到每个城市的最短路径，然后使用BFS算法，从A出发，遍历所有可达城市，更新到这些城市的最短路径和中转次数，直到遍历到B。如果遍历到的城市到A的最短路径加上这个城市到B的最短路径等于A到B的最短路径，说明找到了一条最短路径上的中转点。在更新最短路径和中转次数时，需要考虑到中转次数相同时的比较，可以使用一个优先队列（最小堆）存储城市信息，根据综合花费（最短路径+中转次数）的大小来决定优先级。", "Konwledge_Point": "最短路径", "Question": "数据结构（最短路径的应用）\n功能：现有10个城市之间的交通信息，若有火车，则提供两个城市之间火车票价格。\n（1）有旅客Ａ，准备从城市A出发到城市B，他希望总想花费最少。试设计一种方案。\n（2）有旅客Ｂ，准备从城市A出发到城市B，他想转车次数最少。试设计一种方案。\n( 3 ) 有旅客Ｂ，准备从城市A出发到城市B，他希望总想花费最少的情况下尽量减少中转次数。", "Tag": "算法分析"}
{"Answer": "邻接表：\n#include<iostream>\n#include<cstring>\n#include<string>\n#include<iomanip>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\n#include<queue>\n#include<deque>\n#include<vector>\nint i,j,a,b,n1,m1;\nusing namespace std;\n\nstruct node\n{\n    int v;\n    int w;\n};\nvector<node> e[105];\nint n,m,vis[100001],mapa[1001][1001],ans=1000000001;\nvoid dfs(int x,int dis)\n{\n    int i;\n    if(dis>=ans)//小剪枝 \n        return;\n        \n    if(x==n)\n    {\n        ans=min(ans,dis);\n        return;\n    }\n    node tt; \n    for(int i=0;i<e[x].size();i++)\n    {\n        tt=e[x][i];\n        if(vis[tt.v]==0)\n        {\n            vis[tt.v]=1;\n            dfs(tt.v,dis+tt.w);\n            vis[tt.v]=0;\n        }\n    } \n}\nint main()\n{\n    node t;\n    cin>>n>>m>>n1>>m1;\n    //memset(mapa,0x3f,sizeof(mapa));//初始化\n     \n    for(j=0;j<m;j++)\n    {\n        cin>>a>>b;\n        t.v=b;\n        t.w=1;\n        e[a].push_back(t);\n        t.v=a;\n        t.w=1;\n        e[b].push_back(t);\n       \n    }\n    vis[1]=1;\n    dfs(1,0);\n    cout<<ans<<endl;\n    return 0;\n}\n\n\n邻接矩阵：\n#include<bits/stdc++.h>\nusing namespace std;\nint n,m,vis[100001],mapa[1001][1001],ans=1000000001;\nvoid dfs(int x,int dis)\n{\n    int i;\n    if(dis>ans)//小剪枝 \n        return;\n    if(x==n)\n    {\n        ans=min(ans,dis);\n        return;\n    }\n    for(i=1;i<=n;i++) //不一定向前走，可能绕一下更近 \n    if(mapa[x][i]!=0x3f3f3f3f&&vis[i]==0) \n    {\n        vis[i]=1;\n        dfs(i,dis+mapa[x][i]);\n        vis[i]=0;\n     } \n}\nint main()\n{\n    int i,j,a,b,n1,m1;\n    cin>>n>>m>>n1>>m1;\n    memset(mapa,0x3f,sizeof(mapa));\n    for(j=0;j<m;j++)\n    {\n        cin>>a>>b;\n        mapa[b][a]=1;//保证单向 \n        mapa[a][b]=1;\n    }\n    vis[1]=1;\n    dfs(1,0);\n    cout<<ans<<endl;\n    return 0;\n}\n\n\n链式前向星\n#include<iostream>\n#include<cstring>\n#include<string>\n#include<iomanip>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\n#include<queue>\n#include<deque>\nusing namespace std;\n\nstruct edge\n{\n    int to;\n    int nxt;\n}e[300]; \nint cnt;\nint h[105];\nvoid addedge(int u,int v)\n{\n    cnt++;\n    e[cnt].to=v;\n    e[cnt].nxt=h[u];\n    h[u]=cnt;\n}\nint n,m,vis[100001],mapa[1001][1001],ans=1000000001;\nvoid dfs(int x,int dis)\n{\n    int i;\n    if(dis>=ans)\n        return;\n    if(x==n)\n    {\n        ans=min(ans,dis);\n        return;\n    }\n    for(int i=h[x];i>0;i=e[i].nxt)\n    {\n        int to=e[i].to;\n        if(vis[to]==0)\n        {\n            vis[to]=1;\n            dfs(to,dis+1);\n            vis[to]=0;\n        }\n    }\n}\nint main()\n{\n    int n1,m1; \n    cin>>n>>m>>n1>>m1;\n    int i,j,a,b,c;\n    for(j=0;j<m;j++)\n    {\n        cin>>a>>b;\n        addedge(a,b);\n        addedge(b,a);\n    }\n    vis[1]=1;\n    dfs(1,0);\n    cout<<ans<<endl;\n    return 0;\n}\n\n", "Konwledge_Point": "最短路径", "Question": "最小换乘，求最短路径的问题\n设某城市有n个车站，并有m条公交线路连接这些车站。设这些公交\n车都是单向的，这n个车站被顺序编号为0-n-l。本程序，输入该城市的公交线\n路数、车站个数、以及各公交线路上的各站编号。\n要求:\n\n\n（1求从站0出发乘公交车至其他车站的最少换车次数，并输出所经过的站点序\n列;\n(2利用输入信息构建一张有向图，分别用邻接矩阵和邻接表表示，并输出邻接\n矩阵和邻接表信息;\n\n\n(3从站0出发，对公交线路图进行遍历。\n\n\n收起全部 ", "Tag": "算法分析"}
{"Answer": "i=1, 2, 3, 4, 5, 6表示第几次迭代", "Konwledge_Point": "最短路径", "Question": "数据结构，最短路径问题求解？\n这个表里的i时什么意思？那个i=1 2 3 4 5 6，这个i是什么意思？", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/qq_35710556/article/details/79583229\n五种最短路径算法，自己研究一下", "Konwledge_Point": "最短路径", "Question": "C++求给出图的最短路径问题\n\n\n\n ", "Tag": "算法分析"}
{"Answer": "你理解的没错，但是我觉得你可能想复杂了，我感觉这一段就是解释和证明数组 distTo[v] 保存的是从 s 到 v 的最短距离， v 和 w 都不是定值，disTo[w]<=distTo[v] + e.weight() 的意思就是指到节点 w 的最短距离不可能比经由其他节点去往 w 的距离更长。附上英文原版帮助理解：", "Konwledge_Point": "最短路径", "Question": "算法第4版  4.4.3 最优路径算法的理论基础 最短路径的最优条件描述是不是不太准确？\n算法第4版  4.4.3 最优路径算法的理论基础 最短路径的最优条件描述是不是不太准确？\n\n\n\n\n当且仅当对于\n从v到w的任意一条边e\n，这些值都是满足\ndisTo[w]<=distTo[v] + e.weight()\n时（换句话说，就是不存在有效边时），它们是最短路径。\n\n\n刚开始我是这么理解w、v和e的\n\n\n\n\n后来才明白应该是这样\n\n", "Tag": "算法分析"}
{"Answer": "\nPlenty of reading/algorithms:\nShortest path problem. You effectively just have every edge (\"link\", as you called it) with an equal weight.\n", "Konwledge_Point": "最短路径", "Question": "线性阵列，节点随机链接到阵列中的其他节点，最短路径\n\n\n\nINFO:\nI have an Array of 100 nodes, [ 0 .. 99 ].  Each node can have an arbitrary number of linked nodes:\n\n\n\neg1, 0 links to 5, 10, 15, 20.\neg2, 1 links to 30, 40, 50.\neg3, etc..\n\n\n\nAll 100 nodes have at least one linked node, nodes do not know who links to them.\n\n\n\nQUESTION:\nHow can I find the shortest link-path if provided with START and END.\n\n\n\neg. START=5, END=80, Link Path (example) : [5]->10->24->36->[80]?\n\n\n\nI'm using Pascal and/or PHP, but understanding how is what I'm looking for [code helps too].\n\n    ", "Tag": "算法分析"}
{"Answer": "\nDijkstra should pass, I just make a submission using JAVA, and it took less than a second to complete each task.\nAs I have mentioned, each value in the matrix can go up to 10^9, your solution can encounter a number overflow problem, which can effect the running time.\nMy code:\n<!-- language:java -->\n\nstatic int[]X = {0,1,0,-1};\nstatic int[]Y = {1,0,-1,0};\npublic static void main(String[] args) throws FileNotFoundException {\n    // PrintWriter out = new PrintWriter(new FileOutputStream(new File(\n    // \"output.txt\")));\n    PrintWriter out = new PrintWriter(System.out);\n    Scanner in = new Scanner();        \n    int n = in.nextInt();\n    long[][]map = new long[n][n];\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            map[i][j] = in.nextLong();\n        }\n    }\n    PriorityQueue<Pos> q= new PriorityQueue();\n    long[][]dist = new long[n][n];\n    for(long[]a : dist){\n        Arrays.fill(a,Long.MAX_VALUE);\n    }\n    q.add(new Pos(0,0,map[0][0]));\n    dist[0][0] = map[0][0];\n    while(!q.isEmpty()){\n        Pos p = q.poll();\n        if(dist[p.x][p.y] == p.cost){\n            for(int i = 0; i < 4; i++){\n                int x = p.x + X[i];\n                int y = p.y + Y[i];\n                if(x >= 0 && y >= 0 && x < n && y < n && dist[x][y] > dist[p.x][p.y] + map[x][y] ){\n                    dist[x][y] = dist[p.x][p.y] + map[x][y];\n                    q.add(new Pos(x,y,dist[x][y]));\n                }\n            }\n        }\n    }\n    out.println(dist[n - 1][n - 1]);\n    out.close();\n}\n\nstatic class Pos implements Comparable<Pos>{\n    int x, y;\n    long cost;\n    public Pos(int x, int y, long cost) {\n        super();\n        this.x = x;\n        this.y = y;\n        this.cost = cost;\n    }\n    @Override\n    public int compareTo(Pos o) {\n        // TODO Auto-generated method stub\n        return Long.compare(cost, o.cost );\n    }\n}\n\nUpdate:\nI think your Dijkstra implementation is not correct:\nfor frontier.Len() > 0 {\n    element := heap.Pop(&frontier).(*Item)\n    vertex, cost := element.value, element.priority\n    //You didn't check for visited vertex here!\n    visited[vertex] = true\n    neighbors := graph[vertex]\n    for vertex_new, cost_new := range(neighbors){\n        if !visited[vertex_new]{//You can add same vertex multiple times here!\n            if vertex_new == end{\n                return cost + cost_new\n            }\n            heap.Push(&frontier, &Item{\n                value: vertex_new,\n                priority: cost + cost_new,\n            })\n        }\n    }\n}\n\nIn your implementation, you only update visited when the vertex pop out of the heap, thus, one vertex can be added and processed multiple time, so, it will significantly increase your time complexity.\nTo fix\nfor frontier.Len() > 0 {\n    element := heap.Pop(&frontier).(*Item)\n    vertex, cost := element.value, element.priority\n    if !visited[vertex]{\n        visited[vertex] = true\n        neighbors := graph[vertex]\n        for vertex_new, cost_new := range(neighbors){\n            if !visited[vertex_new]{\n                if vertex_new == end{\n                   return cost + cost_new\n                }\n                heap.Push(&frontier, &Item{\n                   value: vertex_new,\n                   priority: cost + cost_new,\n                })\n            }\n        }   \n    }\n\n", "Konwledge_Point": "最短路径", "Question": "在矩阵中找到最短路径总和。  Dijkstra是否不适用于这种情况？\n\n\n\nI am trying to solve \nthe following problem from project euler\n (please take a look at description and the example in the link, but here is the short explanation).\n\n\n\n\n  \nin the matrix, find the  minimal path sum from the top left to the bottom right, by moving left, right, up, and down\n\n\n\n\n\nRight after I looked at the problem, the obvious solution which came to mind is to create a graph from the matrix and then use \nDijkstra\n to find the shortest path.\n\n\n\nTo construct a graph from a \nN*M\n matrix, for every \n(i, j)\n element I create a vertex \ni * N + j\n and connect it to any other vertex (to which it is possible to connect with UP, RIGHT, DOWN, LEFT) and the edge will be the value of the element I am connecting to in the matrix. After that I create 2 other vertices \n-1\n connected to vertex \n0\n and \n-2\n connected to \nN*M - 1\n which will be my start and end vertices (both connection have 0 cost).\n\n\n\nAfter this I am doing Dijkstra to find shortest path cost from \n-1\n to \n-2\n. My Dijkstra implementation uses priority queue and looks this way:\n\n\n\nfunc dijkstraCost(graph map[int]map[int]int, start, end int) int{\n    if start == end{\n        return 0\n    }\n    frontier := make(PriorityQueue, 1)\n    frontier[0] = &Item{value: start, priority: 0, index: 0}\n    visited := map[int]bool{}\n    heap.Init(&frontier)\n\n    for frontier.Len() > 0 {\n        element := heap.Pop(&frontier).(*Item)\n        vertex, cost := element.value, element.priority\n        visited[vertex] = true\n        neighbors := graph[vertex]\n        for vertex_new, cost_new := range(neighbors){\n            if !visited[vertex_new]{\n                if vertex_new == end{\n                    return cost + cost_new\n                }\n                heap.Push(&frontier, &Item{\n                    value: vertex_new,\n                    priority: cost + cost_new,\n                })\n            }\n        }\n    }\n    return -1\n}\n\n\n\n\nwhere Priority Queue implementation is taken from heap container (example PriorityQueue) with one minor modification:\n\n\n\nfunc (pq PriorityQueue) Less(i, j int) bool {\n    return pq[i].priority > pq[j].priority // changed to <\n}\n\n\n\n\nThe graph that I am providing to the function looks like:\n\n\n\nmap[13:map[8:965 18:121 12:746 14:111] 16:map[11:803 21:732 15:537 17:497] 3:map[8:965 2:234 4:18] 4:map[9:150 3:103] 22:map[17:497 21:732 23:37] -1:map[0:131] 17:map[16:699 18:121 12:746 22:524] 1:map[6:96 0:131 2:234] 9:map[4:18 14:111 8:965] 11:map[6:96 16:699 10:630 12:746] 19:map[14:111 24:331 18:121] 24:map[23:37 -2:0 19:956] 2:map[3:103 7:342 1:673] 15:map[10:630 20:805 16:699] 18:map[13:422 23:37 17:497 19:956] 10:map[5:201 15:537 11:803] 14:map[19:956 13:422 9:150] 0:map[5:201 1:673] 6:map[5:201 7:342 1:673 11:803] 8:map[9:150 3:103 13:422 7:342] -2:map[] 12:map[7:342 17:497 11:803 13:422] 20:map[15:537 21:732] 21:map[16:699 20:805 22:524] 5:map[0:131 10:630 6:96] 23:map[18:121 22:524 24:331] 7:map[2:234 12:746 6:96 8:965]]\n\n\n\n\n\n\nThis works correctly but the problem is that it is considered inefficient (judging by \nHackerrank version of the problem\n). It should run find the value of the best solution for \n700x700\n matrix in less than 4 seconds, whereas my solution takes 10 seconds.\n\n\n\nI thought that I am doing something wrong in go, so I reimplemented the same solution in python (where it took approximately 70 seconds for 700x700 matrix)\n\n\n\n\n\nMy question is:\n Am I using the right approach to find the best solution in a matrix. If so what am I doing wrong with my implementation?\n\n\n\nP.S. I have full go and python solution, just thought that even without them the question is too long.\n\n    ", "Tag": "算法分析"}
{"Answer": "ryn 安装和python代码都是python2版本的？", "Konwledge_Point": "最短路径", "Question": "看到您一篇关于ryu最短路径转发的文章，想咨询您一点问题\n在Ubuntu执行自定义的ryu控制器脚本时出现的问题\nwjc@wjc-virtual-machine:~/ryu/ryu/app$ ryu-manager example_shortestForwarding.py --observe-links\nTraceback (most recent call last):\n  File \"/home/wjc/.local/bin/ryu-manager\", line 5, in \n    from ryu.cmd.manager import main\n  File \"/home/wjc/.local/lib/python2.7/site-packages/ryu/cmd/manager.py\", line 33, in \n    from ryu.app import wsgi\n  File \"/home/wjc/.local/lib/python2.7/site-packages/ryu/app/wsgi.py\", line 23, in \n    from tinyrpc.server import RPCServer\n  File \"/home/wjc/.local/lib/python2.7/site-packages/tinyrpc/\ninit\n.py\", line 4, in \n    from .protocols import *\n  File \"/home/wjc/.local/lib/python2.7/site-packages/tinyrpc/protocols/\ninit\n.py\", line 15\n    def \ninit\n(self) -> None:\n                       ^\nSyntaxError: invalid syntax\n\n\n不知道这个问题应该如何解决", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/xiaohang3414/article/details/73321625", "Konwledge_Point": "最短路径", "Question": "最短路径搜索，除了暴搜以外，采用C语言的还有更优化的办法怎么做呢？\nProblem Description\n\nThe discovery of anti-gravitations technology changed the world. The invention of anti-gravitation shoes (Grav-shoes) enables people to fly in the sky freely. This led to the rise of a new sky sport: ``Flying Circus\".\n\n\n\nUtilizing Grav-shoes and personal flying suits, competitors battle it out in a special field, where they compete scoring obtain m points within a certain time limit. The field is a square with edge length 300 meters. Moreover, there are four buoys floating at each corner of the square. Four buoys are numbered as 1,2,3,4 in clockwise order.\n\n\n\nTwo players start at buoy #1. When game begin, they will try to touch four floating buoys in clockwise order.\n\n(Since buoy #1 is the start point, the first buoy they need to touch will be buoy #2, and after that, they need to touch buoy #3,#4,#1 in order) Note that they could fly freely in the field, even fly inside the square field.\n\n\n\nUnder two situations the player could score one point.\n\n\n\n⋅1. If you touch a buoy before your opponent, you will get one point. For example if your opponent touch the buoy #2 before you after start, he will score one point. So when you touch the buoy #2, you won't get any point. Meanwhile, you cannot touch buoy #3 or any other buoys before touching the buoy #2.\n\n\n\n⋅2. Ignoring the buoys and relying on dogfighting to get point. If you and your opponent meet in the same position, you can try to fight with your opponent to score one point. For the proposal of game balance, two players are not allowed to fight before buoy #2 is touched by anybody.\n\n\n\nThere are three types of players.\n\n\n\nSpeeder: As a player specializing in high speed movement, he/she tries to avoid dogfighting while attempting to gain points by touching buoys.\n\nFighter: As a player specializing in dogfighting, he/she always tries to fight with the opponent to score points. Since a fighter is slower than a speeder, it's difficult for him/her to score points by touching buoys when the opponent is a speeder.\n\nAll-Rounder: A balanced player between Fighter and Speeder.\n\n\n\nThere will be a training match between Asuka (All-Rounder) and Shion (Speeder).\n\nSince the match is only a training match, the rules are simplified: the game will end after the buoy #1 is touched by anybody. Shion is a speed lover, and his strategy is very simple: touch buoy #2,#3,#4,#1 along the shortest path.\n\n\n\nAsuka is good at dogfighting, so she will always score one point by dogfighting with Shion, and the opponent will be stunned for T seconds after dogfighting. Since Asuka is slower than Shion, she decides to fight with Shion for only one time during the match. It is also assumed that if Asuka and Shion touch the buoy in the same time, the point will be given to Asuka and Asuka could also fight with Shion at the buoy. We assume that in such scenario, the dogfighting must happen after the buoy is touched by Asuka or Shion.\n\n\n\nThe speed of Asuka is V1 m/s. The speed of Shion is V2 m/s. Is there any possibility for Asuka to win the match (to have higher score)?\n\n\n\nInput\n\nThe first line contains an integer t (0<t≤1000), followed by t lines.\n\nEach line contains three double T, V1 and V2 (0≤V1≤V2≤2000,0≤T≤2000) with no more than two decimal places, stands for one case.\n\n\n\nOutput\n\nIf there exist any strategy for Asuka to win the match, output \nYes\", otherwise, output\nNo\".\n\n\n\nSample Input\n\n2\n\n1 10 13\n\n100 10 13\n\n\n\nSample Output\n\nCase #1: No\n\nCase #2: Yes", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/u012969412/article/details/44818029", "Konwledge_Point": "最短路径", "Question": "希望大神解答一下，这道题用bfs+优先队列为什么不对，只能用最短路径来写\nBessie and the rest of Farmer John's cows are taking a trip this winter to go skiing. One day Bessie finds herself at the top left corner of an R (1 <= R <= 100) by C (1 <= C <= 100) grid of elevations E (-25 <= E <= 25). In order to join FJ and the other cows at a discow party, she must get down to the bottom right corner as quickly as she can by travelling only north, south, east, and west.\n\nBessie starts out travelling at a initial speed V (1 <= V <= 1,000,000). She has discovered a remarkable relationship between her speed and her elevation change. When Bessie moves from a location of height A to an adjacent location of eight B, her speed is multiplied by the number 2^(A-B). The time it takes Bessie to travel from a location to an adjacent location is the reciprocal of her speed when she is at the first location.\n\nFind the both smallest amount of time it will take Bessie to join her cow friends.\n\n\n\n\nInput\n\n    * Line 1: Three space-separated integers: V, R, and C, which respectively represent Bessie's initial velocity and the number of rows and columns in the grid.\n\n\n\n* Lines 2..R+1: C integers representing the elevation E of the corresponding location on the grid. \n\n\n\n\nOutput\n\n    A single number value, printed to two exactly decimal places: the minimum amount of time that Bessie can take to reach the bottom right corner of the grid. \n\nSample Input\n\n\n\n1 3 3\n1 5 3\n6 3 5\n2 4 3\n\n\n\n\nSample Output\n\n\n\n29.00\n\n\n\n\nHint\n\n    Bessie's best route is:\n\n    Start at 1,1 time 0 speed 1\n\n    East to 1,2 time 1 speed 1/16\n\n    South to 2,2 time 17 speed 1/4\n\n    South to 3,2 time 21 speed 1/8\n\n    East to 3,3 time 29 speed 1/4 ", "Tag": "算法分析"}
{"Answer": "这种问题不应该用Dijkstra这种太理论化的算法去解决问题，因为专业的识别cad图的算法，不是那么轻易就能写好。建议：直接读取cad图，自己写识别算法，一张建筑平面图，适当处理下，二值化后就只剩墙壁的黑色部分，用程序遍历一次所有的路线，就能找到最佳路线了", "Konwledge_Point": "最短路径", "Question": "给出一张建筑平面图，如何将其转换成路径距离信息的无向图\n做建筑疏散的实验，考虑用Dijkstra找无向图的最短路径、疏散出口。目前无向图需要手画。\n\n\n\n\n\n\n正在思考如何根据一张建筑平面图，如cad图，去识别这张图，并自动生成他的路径距离信息的图。\n\n\n其中无向图的每个节点可以代表建筑的路口，权重代表路径的距离。", "Tag": "算法分析"}
{"Answer": "如果是写代码的话，邻接矩阵肯定比邻接表好写，毕竟是数组实现；\r\n就时间复杂度上而言对于稀疏图用邻接表比较好，对于稠密图用邻接矩阵比较好", "Konwledge_Point": "最短路径", "Question": "图的拓扑参数 点介数\\点核数\\度分布\n    对于一个图来说,度分布是比较好做的,列出所有点对计算每一点出现的次数,就是度数.\n    点介数是通过该点的最短路径的条数.\n    点核数定义较为复杂.\n    那么对于程序实现来说,狄克斯特拉算法只能算出最短路径并不能得到每一点的信息?\n下面问题来了\n        度分布的计算究竟是用邻接矩阵方便还是邻接表方便呢?\n        介数的计算思想究竟是什么呢?\n", "Tag": "算法分析"}
{"Answer": "由于题太长导致ChatGPT试了好几次才全部答完，可能答案不正确1、利用随机数原理，随机产生一个二维数组A（30*30），其中对角线元素为零，剩余元素中的50%是∞，其余元素的值为大于0的随机数。\n#include <iostream>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\nconst int N = 30;            // 定义数组大小为30*30\nconst int INF = 0x3f3f3f3f; // 定义∞的值\n\nint main()\n{\n    srand(time(NULL)); // 设置随机数种子\n    int A[N][N];       // 定义二维数组A\n    for (int i = 0; i < N; i++)\n    { // 遍历二维数组A\n        for (int j = 0; j < N; j++)\n        {\n            if (i == j)\n            { // 对角线元素为零\n                A[i][j] = 0;\n            }\n            else if (rand() % 2 == 0)\n            { // 50%的概率为∞\n                A[i][j] = INF;\n            }\n            else\n            { // 剩余元素的值为大于0的随机数\n                A[i][j] = rand() % 100 + 1;\n            }\n        }\n    }\n    // 输出二维数组A\n    for (int i = 0; i < N; i++)\n    {\n        for (int j = 0; j < N; j++)\n        {\n            cout << A[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}\n\n2、将上述二维数组作为图的邻接矩阵，以该数组作为输入，创建一个图形结构，该图使用邻接表作为存储结构。\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f; // 定义∞的值\n\nconst int N = 30; // 定义数组大小为30*30\n\nstruct Edge\n{                    // 定义边的结构体\n    int to, weight; // to表示边的终点，weight表示边的权值\n};\n\nvector<Edge> adj[N]; // 定义邻接表\n\nvoid addEdge(int u, int v, int w)\n{                              // 添加边的函数\n    adj[u].push_back({v, w}); // 将边(u, v)加入邻接表\n}\n\nint main()\n{\n    int A[N][N] = {// 定义二维数组A（邻接矩阵）\n                   {0, 2, 6, 4, INF, INF, INF},\n                   {INF, 0, 3, INF, 2, INF, INF},\n                   {INF, INF, 0, INF, INF, 5, INF},\n                   {INF, 1, 5, 0, INF, INF, INF},\n                   {INF, INF, INF, 3, 0, 2, 6},\n                   {INF, INF, INF, INF, INF, 0, 3},\n                   {INF, INF, INF, INF, INF, INF, 0}};\n    for (int i = 0; i < N; i++)\n    { // 遍历二维数组A\n        for (int j = 0; j < N; j++)\n        {\n            if (A[i][j] != INF)\n            {                            // 如果A[i][j]不是∞，说明存在边(i, j)\n                addEdge(i, j, A[i][j]); // 将边(i, j)加入邻接表\n                for (int i = 0; i < N; i++)\n                { // 遍历二维数组A\n                    for (int j = 0; j < N; j++)\n                    {\n                        cout << A[i][j] << \" \"; // 输出A[i][j]\n                    }\n                    cout << endl; // 输出换行符\n                }\n            }\n        }\n    }\n    return 0;\n}\n\n3、利用DFS或者BFS算法遍历该图，找到图中权值最小的边。首先是DFS。\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f; // 定义∞的值\n\nconst int N = 30; // 定义数组大小为30*30\n\nstruct Edge\n{                    // 定义边的结构体\n    int to, weight; // to表示边的终点，weight表示边的权值\n};\n\nvector<Edge> adj[N]; // 定义邻接表\n\nvoid addEdge(int u, int v, int w)\n{                              // 添加边的函数\n    adj[u].push_back({v, w}); // 将边(u, v)加入邻接表\n}\n\nvoid dfs(int u, vector<bool> &visited, int &min_weight)\n{                       // 定义DFS遍历的函数\n    visited[u] = true; // 标记顶点u为已访问\n    for (const Edge &e : adj[u])\n    { // 遍历顶点u的所有出边\n        int v = e.to;\n        int w = e.weight;\n        if (!visited[v])\n        {                                     // 如果顶点v未被访问过\n            min_weight = min(min_weight, w); // 更新最小边权值\n            dfs(v, visited, min_weight);     // 递归调用DFS遍历\n        }\n    }\n}\n\nint main()\n{\n    int A[N][N] = {// 定义二维数组A（邻接矩阵）\n                   {0, 2, 6, 4, INF, INF, INF},\n                   {INF, 0, 3, INF, 2, INF, INF},\n                   {INF, INF, 0, INF, INF, 5, INF},\n                   {INF, 1, 5, 0, INF, INF, INF},\n                   {INF, INF, INF, 3, 0, 2, 6},\n                   {INF, INF, INF, INF, INF, 0, 3},\n                   {INF, INF, INF, INF, INF, INF, 0}};\n    for (int i = 0; i < N; i++)\n    { // 遍历二维数组A\n        for (int j = 0; j < N; j++)\n        {\n            if (A[i][j] != INF)\n            {                            // 如果A[i][j]不是∞，说明存在边(i, j)\n                addEdge(i, j, A[i][j]); // 将边(i, j)加入邻接表\n            }\n        }\n    }\n    int min_weight = INF;                              // 定义最小边权值初始值为∞\n    vector<bool> visited(N, false);                      // 定义访问数组，初始值全部为false\n    dfs(0, visited, min_weight);                      // 从顶点0开始遍历图\n    cout << \"Minimum weight: \" << min_weight << endl; // 输出最小边权值\n    return 0;\n}\n\n其次是BFS\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f; // 定义∞的值\n\nconst int N = 30; // 定义数组大小为30*30\n\nstruct Edge\n{                    // 定义边的结构体\n    int to, weight; // to表示边的终点，weight表示边的权值\n};\n\nvector<Edge> adj[N]; // 定义邻接表\n\nvoid addEdge(int u, int v, int w)\n{                              // 添加边的函数\n    adj[u].push_back({v, w}); // 将边(u, v)加入邻接表\n}\n\nvoid bfs(int u, int &min_weight)\n{                                    // 定义BFS遍历的函数\n    queue<int> q;                    // 定义队列\n    vector<bool> visited(N, false); // 定义访问数组，初始值全部为false\n    visited[u] = true;                // 标记顶点u为已访问\n    q.push(u);                        // 将顶点u加入队列\n    while (!q.empty())\n    {                       // 当队列不为空时\n        int x = q.front(); // 取出队首元素\n        q.pop();           // 弹出队首元素\n        for (const Edge &e : adj[x])\n        { // 遍历顶点x的所有出边\n            int v = e.to;\n            int w = e.weight;\n            if (!visited[v])\n            {                                     // 如果顶点v未被访问过\n                visited[v] = true;                 // 标记顶点v为已访问\n                min_weight = min(min_weight, w); // 更新最小边权值\n                q.push(v);                         // 将顶点v加入队列\n            }\n        }\n    }\n}\n\nint main()\n{\n    int A[N][N] = {// 定义二维数组A（邻接矩阵）\n                   {0, 2, 6, 4, INF, INF, INF},\n                   {INF, 0, 3, INF, 2, INF, INF},\n                   {INF, INF, 0, INF, INF, 5, INF},\n                   {INF, 1, 5, 0, INF, INF, INF},\n                   {INF, INF, INF, 3, 0, 2, 6},\n                   {INF, INF, INF, INF, INF, 0, 3},\n                   {INF, INF, INF, INF, INF, INF, 0}};\n    for (int i = 0; i < N; i++)\n    { // 遍历二维数组A\n        for (int j = 0; j < N; j++)\n        {\n            if (A[i][j] != INF)\n            {                            // 如果A[i][j]不是∞，说明存在边(i, j)\n                addEdge(i, j, A[i][j]); // 将边(i, j)加入邻接表\n            }\n        }\n    }\n    int min_weight = INF;                              // 定义最小边权值初始值为∞\n    bfs(0, min_weight);                                  // 从顶点0开始遍历图\n    cout << \"Minimum weight: \" << min_weight << endl; // 输出最小边权值\n    return 0;\n}\n\n4、设计一个基于Floyd的最短路径算法，计算所有顶点之间的最短路径。\n#include <iostream>\n\nusing namespace std;\n\nconst int N = 30;            // 定义数组大小为30*30\nconst int INF = 0x3f3f3f3f; // 定义∞的值\n\nint main()\n{\n    int A[N][N] = {// 定义二维数组A（邻接矩阵）\n                   {0, 2, 6, 4, INF, INF, INF},\n                   {INF, 0, 3, INF, 2, INF, INF},\n                   {INF, INF, 0, INF, INF, 5, INF},\n                   {INF, 1, 5, 0, INF, INF, INF},\n                   {INF, INF, INF, 3, 0, 2, 6},\n                   {INF, INF, INF, INF, INF, 0, 3},\n                   {INF, INF, INF, INF, INF, INF, 0}};\n    for (int k = 0; k < N; k++)\n    { // 遍历所有顶点\n        for (int i = 0; i < N; i++)\n        {\n            for (int j = 0; j < N; j++)\n            {\n                A[i][j] = min(A[i][j], A[i][k] + A[k][j]); // 更新最短路径\n            }\n        }\n    }\n    // 输出最短路径矩阵\n    for (int i = 0; i < N; i++)\n    {\n        for (int j = 0; j < N; j++)\n        {\n            cout << A[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}\n\n以上就是ChatGPT给出的答案", "Konwledge_Point": "最短路径", "Question": "利用c++解决图论问题\n1、利用随机数原理，随机产生一个二维数组A（30*30），其中对角线元素为零，剩余元素中的50%是∞，其余元素的值为大于0的随机数。\n2、将上述二维数组作为图的邻接矩阵，以该数组作为输入，创建一个图形结构，该图使用邻接表作为存储结构。\n3、利用DFS或者BFS算法遍历该图，找到图中权值最小的边。\n4、设计一个基于Floyd的最短路径算法，计算所有顶点之间的最短路径。", "Tag": "算法分析"}
{"Answer": "\njava实现老鼠迷宫游戏_小小寂寞的城的博客-CSDN博客_老鼠迷宫java\n最近学java,在递归部分看到老鼠迷宫游戏,感觉挺有意思,记录一下我们可以把迷宫当成一个二位数组,其中1代表障碍物,走不了,初始化一个二维数组,设置好障碍物//老鼠迷宫        int[][] map = {                {1,1,1,1,1,1,1,1},                {1,0,0,0,0,0,0,1},                {1,1,0,0,0,0,0,1},                {1,0,1,0,0,0,0,1},     \n\n\n\nhttps://blog.csdn.net/Autumn_1/article/details/120704004\n\n", "Konwledge_Point": "最短路径", "Question": "Java语言迷宫鼠详解\n（1）概述：用java面向对象程序设计语言，设计和实现一电脑鼠走迷宫的软件程序，\n即一个假想的小车能在图示的迷宫中根据设定的起始点和终点自主寻找路径。\n（2）迷宫地图生成算法的设计和实现\n自动生成迷宫：根据迷宫生成算法自动生成一定复杂度的迷宫地图。\n手动生成迷宫：根据文件中存储的固定数据生成迷宫地图。\n单路径寻找算法的设计与实现：找出迷宫中一条单一的通路。\n迷宫遍历算法的设计与实现：遍历迷宫中所有的可行路径。\n最短路径计算算法的设计与实现：根据遍历结果，找出迷宫中所有通路中的最短通\n路。\n（3）通过动画展示出迷宫鼠在迷宫内的运动。\n（4)具有判断通路和障碍的功能；走不通具备返回的能力（路径记忆）；能够寻找最短路径；", "Tag": "算法分析"}
{"Answer": "只将有多条可行路径的点入栈就可以，每一个点从正确性上说也可以，但是不优化。", "Konwledge_Point": "最短路径", "Question": "想问大家C语言数据结构一个学术问题\n大家用C语言做迷宫最短路径问题，是将可行路径上的每一个经过的点都入栈，还是仅仅只将有多条可行路径的点入栈呀。我又看了下书，好像懂了QAQ，不过还是欢迎大佬提点一下。\n\n\n\n                                    拜托各位大佬的指点了\n", "Tag": "算法分析"}
{"Answer": "[http://www.it165.net/pro/html/201407/16957.html](http://www.it165.net/pro/html/201407/16957.html \"\")", "Konwledge_Point": "最短路径", "Question": "c语言课程设计分油问题\n输入三个油瓶容量与目标容量， 用邻接矩阵求它的最短路径   ，先判断两点间有没有路 最短路是什么，  调用邻接矩阵函数求   。", "Tag": "算法分析"}
{"Answer": "按照你这个matlab代码：\nfunction [min,path]=dijkstra(w,start,terminal)\n%% 函数介绍\n%输入变量w为所求图的带权邻接矩阵，start、terminal分别为路径的起点和终点的编号。\n%返回path为从start到termial的最短路径以及长度min\nn=size(w,1); label(start)=0; f(start)=start;\n%n为所求图的顶点个数，label存放到各点的最短路径，f(v)表示v的父顶点用来还原路径\n%初始化将除了start以外的顶点label均设置为无穷大\nfor i=1:n\nif i~=start\nlabel(i)=inf;\nend\nend\n%s数组存放已经搜好的顶点集，初始化只有start\ns(1)=start; u=start;\nwhile length(s)<n\n%遍历一遍顶点，将不在顶点集中的顶点选出来进行下面的if判定\nfor i=1:n\nins=0;\nfor j=1:length(s)\nif i==s(j)\nins=1;\nend\nend\n%判断是否有中继顶点使得它们之间的距离更短，如果有的话更新距离并更新前驱结点\nif ins==0\nv=i;\nif label(v)>(label(u)+w(u,v))\nlabel(v)=(label(u)+w(u,v)); f(v)=u;\nend\nend\nend\nv1=0;\nk=inf;\n%同上再次进行遍历，找到目前最短的路径顶点v1，放入顶点集并改变u的值\nfor i=1:n\nins=0;\nfor j=1:length(s)\nif i==s(j)\nins=1;\nend\nend\nif ins==0\nv=i;\nif k>label(v)\nk=label(v); v1=v;\nend\nend\nend\ns(length(s)+1)=v1;\nu=v1;\nend\n\nmin=label(terminal); path(1)=terminal;\ni=1;\n\n%按倒序结果推出最短路径\nwhile path(i)~=start\npath(i+1)=f(path(i));\ni=i+1 ;\nend\npath(i)=start;\nL=length(path);\n%翻转得到最短路径\npath=path(L:-1:1);\n\n并根据你给的点，我写了个命令窗口代码：\nclc,clear\nw=[0,0.8,2,3.8,6;inf,0,0.9,2.1,3.9;inf,inf,0,1.1,2.3;inf,inf,inf,0,1.4;inf,inf,inf,inf,0];\nstart=1;\nterminal=5;\n[min,path]=dijkstra(w,start,terminal);\nmin,path\n\n运行得出的结果是：并没有产生报错。", "Konwledge_Point": "最短路径", "Question": "一个问题算法的程序出现错误运行不出来\nfunction [min,path]=dijkstra(w,start,terminal)\n%输入变量w为所求图的带权邻接矩阵，start、terminal分别为路径的起点和终点的编号。\n%返回path为从start到termial的最短路径以及长度min\n\n\nn=size(w,1); label(start)=0; f(start)=start;\n%n为所求图的顶点个数，label存放到各点的最短路径，f(v)表示v的父顶点用来还原路径\n\n\n%初始化将除了start以外的顶点label均设置为无穷大\nfor i=1:n\n    if i~=start\n       label(i)=inf;\n    end\nend\n\n\n%s数组存放已经搜好的顶点集，初始化只有start\ns(1)=start; u=start;\nwhile length(s)(label(u)+w(u,v))\n                label(v)=(label(u)+w(u,v)); f(v)=u;\n            end\n        end\n    end\n    v1=0;\n    k=inf;\n    %同上再次进行遍历，找到目前最短的路径顶点v1，放入顶点集并改变u的值\n    for i=1:n\n        ins=0;\n        for j=1:length(s)\n            if i==s(j)\n                ins=1;\n            end\n        end\n        if ins==0\n            v=i;\n            if k>label(v)\n                k=label(v);  v1=v;\n            end\n        end\n    end\n    s(length(s)+1)=v1;\n    u=v1;\nend\n\n\nmin=label(terminal); path(1)=terminal;\ni=1; \n\n\n%按倒序结果推出最短路径\nwhile path(i)~=start\n    path(i+1)=f(path(i));\n    i=i+1 ;\nend\npath(i)=start;\nL=length(path);\n%翻转得到最短路径\npath=path(L:-1:1);\n\n\n\n", "Tag": "算法分析"}
{"Answer": "这个正无穷是初始化的时候的，初始化标记正无穷大表示该点无法到达", "Konwledge_Point": "最短路径", "Question": "这个地方的正无穷是如何看出来的，能否解释一下\n这个地方的正无穷是如何看的，最短路径。就是比如v1那个有一个正无穷，v5那有四个正无穷，这个正无穷数量该怎么看。", "Tag": "算法分析"}
{"Answer": "不停刷题，刷开源代码", "Konwledge_Point": "最短路径", "Question": "大三学生如何提升代码能力\n作为一名普通本科计算机专业大三的学生，应当具备怎样的代码能力？我只对c和c++比较熟悉，一些算法比如最短路径，我能手写在纸上，但调试总需要很久。", "Tag": "算法分析"}
{"Answer": "你好，我是有问必答小助手，非常抱歉，本次您提出的有问必答问题，技术专家团超时未为您做出解答本次提问扣除的有问必答次数，将会以问答VIP体验卡（1次有问必答机会、商城购买实体图书享受95折优惠）的形式为您补发到账户。因为有问必答VIP体验卡有效期仅有1天，您在需要使用的时候【私信】联系我，我会为您补发。", "Konwledge_Point": "最短路径", "Question": "关于#matlab# #算法# #python#的问题：校园导航制作\n需要录入许多个位置点，要怎么录入呢？利用算法快速获得最短路径，我打算使用弗洛伊德算法做，但是无从入手，算法具体应该怎么做，还有还有，这个算法适合做导航吗，请救救孩子吧wwww～ballballyou！", "Tag": "算法分析"}
{"Answer": "如果需要展示地图的话还是要调用地图接口的 看你这边的话应该用的是原生js走的你可以看一下我之前写的调用 高德地图的文章，应该还是比较适用你现在这种情况的\n\nhttps://blog.csdn.net/clli_Chain/article/details/107982453?spm=1001.2014.3001.5502", "Konwledge_Point": "最短路径", "Question": "怎么把搜索结果界面展示在搜索框下面\n做一个查询路线的界面，现在需要在搜索框搜索之后，把搜索结果就展示在搜索框的下方位置，应该怎么做\n\n\n把各种最短路径之类的展示在中间的小框里面\n要把查询出来的地图路线展示在下方的大框里面，\n应该怎么做啊", "Tag": "算法分析"}
{"Answer": "你这个问题就是一个加权无向图的最小路径求解的问题，我给个例子你参考一下，直接用现成的算法实现的，代码并不复杂，看看是否符合你的要求：\nimport matplotlib.pyplot as plt\nimport networkx\n\nG2 = networkx.Graph()  # 创建：空的 无向图\n#创建加权边，a、b、c等代表城市，后边的值代表乘车时间\nedges = [(\"a\", \"b\", 5), (\"a\", \"c\",13), (\"a\", \"e\",10),(\"a\", \"g\", 6), \n        (\"a\", \"i\", 5),(\"a\", \"k\", 6),(\"a\", \"l\", 2), (\"a\", \"m\", 5),\n        (\"b\", \"c\", 3), (\"b\", \"i\", 1),(\"c\", \"d\", 9), (\"d\", \"e\",11),\n        (\"e\", \"f\", 9), (\"f\", \"g\", 6),(\"g\", \"h\", 7), (\"h\", \"i\", 4),\n        (\"i\", \"j\", 9), (\"j\", \"k\", 6),(\"k\", \"l\", 7), (\"l\", \"m\", 4)]\nG2.add_weighted_edges_from(edges)  # 向图中添加多条赋权边: (node1,node2,weight)\n#指定要求解的两个点\nsource = 'b'\ntarget = 'f'\n# 两个指定顶点之间的最短加权路径\nminWPath= networkx.dijkstra_path(G2, source=source, target=target)\nprint(f\"顶点 {source} 到 顶点 {target} 的最短加权路径: {minWPath}\")\n# 两个指定顶点之间的最短加权路径的长度\nlMinWPath = networkx.dijkstra_path_length(G2, source=source, target=target)  #最短加权路径长度\nprint(f\"顶点 {source} 到 顶点 {target} 的最短加权路径长度: {lMinWPath}\")\n\npos = networkx.spring_layout(G2)  # 用 FR算法排列节点\nnetworkx.draw(G2, pos, with_labels=True, alpha=0.5) #画所有节点\nlabels = networkx.get_edge_attributes(G2,'weight') #取加权值为标签\nnetworkx.draw_networkx_edge_labels(G2, pos, edge_labels = labels) #画边和标签\nposCopy = pos.copy()  #复制所有节点\nedgesCopy = [] #最小路径加权边\n#遍历所有节点，保留最小路径相关节点\nfor k in pos.keys():\n    if k not in minWPath:\n        posCopy.pop(k)\n#遍历所有加权边，取出最小路径相关加权边\nfor i in range(len(minWPath)-1):\n    for edge in edges:\n        if minWPath[i] in edge and  minWPath[i+1] in edge:\n            edgesCopy.append(edge)\n            break\nminG2 = networkx.Graph() #创建空无向图\nminG2.add_weighted_edges_from(edgesCopy) #向图中添加最小路径加权边\nnetworkx.draw(minG2, posCopy, with_labels=False, alpha=1, edge_color='red')  #用红色标记最小路径边\nplt.show()\n\n", "Konwledge_Point": "最短路径", "Question": "尽快，求解以下问题如图中第五题的程序要求，文件夹压缩包的形式发我，最好于4月30号中午12点前发我\n求解最短路径\n提供算法思想描述，程序结构，测试结果\n\n\n设有n(n> 10)个城市之间的交通图。假设任意两个城市之间不一定有直接交通线路，权表示乘车时间。要求事先将交通图信息将存人磁盘文件中，求从某城市出发到其他城市的最少乘车时间和乘车路线。要求将结果以图形方式在屏幕上输出。", "Tag": "算法分析"}
{"Answer": "用Dijkstra算法求从顶点0出发的最短路径。简单来说，就是从起点开始，不断地选取未访问的距离起点最近的顶点，并更新该顶点到其他顶点的距离。这样不断执行直到所有顶点都被访问过，得到起点到各个顶点的最短路径。\n接着，给出了算法执行的某时刻，即已经访问了0、2、3、4四个顶点。这意味着此时已经找到了从起点到这些顶点的最短路径。\n最后，需要在这个时刻选取下一步目标顶点。因为题目没有给出完整的图，所以我也不知道顶点D与0、2、3、4之间的连边情况。因此无法确定顶点D是否为下一步的目标顶点。\n因此，选项A、B、C、D中只有选项D是无法确定的，其他三个选项的顶点都不是下一步的目标顶点的可能性比较小，但需要具体情况具体分析。如果需要确定下一步目标顶点，需要知道顶点D与0、2、3、4之间的连边情况。", "Konwledge_Point": "最短路径", "Question": "Dijkstra算法的问题\n用Dijkstra算法求一个带权有向图G中从顶点0出发的最短路径，在算法执行的某时刻，S={0,2,3,4}，下一步选取的目标顶点可能是   D   。\nA.顶点2            B.顶点3            C.顶点4            D.顶点7\n表达的是啥意思嘞，顶点7又是怎么出来的嘞", "Tag": "算法分析"}
{"Answer": "运行结果（ctrl+z结束输入，vs2022需要连续输入3次才ctrl+z可以）：\n\n代码：\n#define _CRT_SECURE_NO_WARNINGS 1\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MM 100\n\n\n//站点信息\ntypedef struct node\n{\n    int cost;      //两个站点间的花费\n    int vexnode;   //顶点编号\n    char name[30]; //站点名称\n    struct node* next;\n}Arcnode;\n\ntypedef struct _graph\n{\n    Arcnode* point[MM];\n    int  vexnum;\n} graph;\n//队列\ntypedef struct queue\n{\n    int father;\n    int son;\n    struct queue* next;\n}queue;\n\nqueue* init_queue()\n{\n    queue* head = (queue*)malloc(sizeof(queue));\n    head->next = 0;\n    return head;\n}\n//1为空\nint empty(queue* head)\n{\n    if (head == 0)\n        return 1;\n    else\n        return 0;\n}\n//入栈\nvoid push(queue* head, int i, int j)   // i:father point   j:son point\n{\n    queue* tmp = head;\n    queue* nn = (queue*)malloc(sizeof(queue));\n    nn->father = j;\n    nn->next = 0;\n    //nn->son = j;\n    while (tmp->next)\n        tmp = tmp->next;\n    tmp->next = nn;\n\n}\n//出栈\nvoid pop(queue* head, int* i, int* j)\n{\n    queue* tmp = head;\n    queue* pre = head;\n    if (head->next == 0)\n    {\n        *j = head->father;\n        free(head);\n        head = 0;\n    }\n    else\n    {\n        tmp = head->next;\n        while (tmp->next)\n        {\n            pre = tmp;\n            tmp = tmp->next;\n        }\n        *j = tmp->father;\n        free(tmp);\n        pre->next = 0;\n    }\n}\n\n//根据名字查找节点是否存在，如果存在返回节点编号，否则返回-1\nint findVertex(graph* g, char* name)\n{\n    int i;\n    for (i = 0; i < g->vexnum; i++)\n    {\n        if (strcmp(g->point[i]->name, name) == 0)\n            return i;\n    }\n    return -1;\n}\n\n\n//读数据并创建图\nvoid  readAndCreatGraph(graph* g)\n{\n    Arcnode* tmpnode, * curnode,*head;\n    int i = 0, j;\n    int cost;\n    char name[30] = { 0 }, dst[30] = { 0 };\n    g->vexnum = 0;\n    while (scanf(\"%s %s %d\",name,dst,&cost)!= EOF)\n    {\n        //查看节点是否已经存在\n        i = findVertex(g, name);\n        if (i == -1) //节点不存在\n        {\n            curnode = (Arcnode*)malloc(sizeof(Arcnode));\n            curnode->vexnode = g->vexnum;\n            strcpy(curnode->name, name);\n            //创建当前节点的链表\n            head = (Arcnode*)malloc(sizeof(Arcnode));\n            head->vexnode = g->vexnum;\n            head->next = 0;\n            curnode->next = head; //第一个节点不存储内容\n            g->point[g->vexnum] = curnode;\n            g->vexnum += 1; //个数加1\n\n            //将目的节点插入链表\n            j = findVertex(g, dst);\n            curnode = (Arcnode*)malloc(sizeof(Arcnode));\n            curnode->cost = cost;\n            curnode->next = 0;\n            strcpy(curnode->name, dst);\n            if (j == -1)\n                curnode->vexnode = g->vexnum;\n            else\n                curnode->vexnode = j;\n            //将节点插入\n            head->next = curnode;\n\n            //如果目的节点不再图中\n            if (j == -1)\n            {\n                tmpnode = (Arcnode*)malloc(sizeof(Arcnode));\n                tmpnode->vexnode = g->vexnum;\n                strcpy(tmpnode->name, dst);\n                head = (Arcnode*)malloc(sizeof(Arcnode));\n                head->vexnode = g->vexnum;\n                head->next = 0;\n                tmpnode->next = head;\n                g->point[g->vexnum] = tmpnode;\n                g->vexnum += 1; //节点数+1\n            }\n            \n        }\n        else\n        {\n            //源节点已经存在\n            tmpnode = g->point[i]->next; //得到链表头\n            curnode = (Arcnode*)malloc(sizeof(Arcnode));\n            curnode->cost = cost;\n            curnode->next = 0;\n            strcpy(curnode->name, dst);\n            j = findVertex(g, dst); //看看目的节点是否已经存在\n            if (j == -1)\n                curnode->vexnode = g->vexnum;\n            else\n                curnode->vexnode = j;\n            while (tmpnode->next)\n                tmpnode = tmpnode->next;\n            tmpnode->next = curnode;\n\n            //如果目的节点不存在，将该节点插入图中\n            if (j == -1)\n            {\n                tmpnode = (Arcnode*)malloc(sizeof(Arcnode));\n                tmpnode->vexnode = g->vexnum;\n                strcpy(tmpnode->name, dst);\n                head = (Arcnode*)malloc(sizeof(Arcnode));\n                head->vexnode = g->vexnum;\n                head->next = 0;\n                tmpnode->next = head;\n                g->point[g->vexnum] = tmpnode;\n                g->vexnum += 1;\n            }\n        }\n\n        \n\n    }\n\n}\n\n\n//找最短路径\nvoid dijkstra(graph* g)\n{\n    int inqueue[MM] = { 0 };  //是否已经入栈\n    int id, start_s;\n    Arcnode* ns = 0;\n    queue* last = 0;  //队列的最后一个元素\n    int una, unb, xx = 0, yy = 0;\n    queue* head = 0;\n\n\n    int pathMin[MM] = { 0 };                //最短路径\n    int pathTmp[MM] = { 0 };                //临时路径\n    int minDistance = -1, tmpdis = 0;       //最短路径距离\n    int lengpath = 0, minpathlen = 0;       //最短路径点个数\n    queue* qMin = 0;\n    int kktt = 0, vv = 0;\n\n    int start, end; //起点和终点\n    char str_start[30], str_end[30];\n    int flags[MM][MM];\n    //system(\"cls\");\n\n\n    //显示地图信息\n    //showBaseInfo(g);\n\n    printf(\"请输入起点和终点:\");\n    scanf(\"%s %s\", str_start , str_end);\n    start = findVertex(g,str_start);\n    end = findVertex(g,str_end);\n\n    //初始化邻接矩阵\n    for (xx = 0; xx < MM; xx++)\n    {\n        for (yy = 0; yy < MM; yy++)\n            flags[xx][yy] = -1;\n    }\n    for (xx = 0; xx < g->vexnum; xx++)\n    {\n        ns = g->point[xx]->next;\n        while (ns)\n        {\n            flags[xx][ns->vexnode] = 0;\n            ns = ns->next;\n        }\n    }\n\n    //起点入栈\n    head = init_queue();\n    head->father = start;\n    inqueue[start] = 1;    //起点已入栈\n\n    while (!empty(head))\n    {\n        //获取队列中的最后一个元素\n        last = head;\n        while (last->next)\n            last = last->next;\n        start_s = last->father;\n\n        //获取队列中最后一个元素的一个可到达的站\n        id = -1;\n        for (xx = 0; xx < g->vexnum; xx++)\n        {\n            if (flags[start_s][xx] == 0)\n            {\n                flags[start_s][xx] = 1;\n                id = xx;\n                break;\n            }\n        }\n\n        //如果未找到\n        if (id == -1)\n        {\n            pop(head, &una, &unb); //栈弹出一个元素\n            if (unb == start) head = 0;\n            //查找unb所有相邻节点，并将其状态设为未访问\n\n            for (xx = 0; xx < MM; xx++)\n            {\n                if (flags[unb][xx] == 1) flags[unb][xx] = 0;\n            }\n\n            inqueue[start_s] = 0; //该顶点标记为未入栈\n            continue;             //取栈顶的相邻节点\n        }\n        if (inqueue[id])  //若已经在栈中，取下一个顶点\n        {\n            continue;\n        }\n\n\n        push(head, 0, id);            //将该顶点入栈\n        inqueue[id] = 1;            //记为已入栈\n        if (id == end)              //如果栈顶已经为所求，将此路径记录\n        {\n            //-----------------计算路径的长度-----------------------------\n            qMin = head;\n            lengpath = 0;\n            while (qMin)\n            {\n                pathTmp[lengpath] = qMin->father;\n                lengpath++;\n                qMin = qMin->next;\n            }\n            tmpdis = 0;\n            for (kktt = 0; kktt < lengpath - 1; kktt++)\n            {\n                vv = pathTmp[kktt];\n                ns = g->point[vv]->next;\n                while (ns)\n                {\n                    if (ns->vexnode == pathTmp[kktt + 1])\n                    {\n                        tmpdis += ns->cost;\n                        break;\n                    }\n                    else\n                        ns = ns->next;\n                }\n            }\n\n            //显示所有路径\n            printf(\"花费=%d : \", tmpdis);\n            for ( xx = 0; xx < lengpath; xx++)//int\n            {\n                if (xx < lengpath - 1)\n                    printf(\"%s --> \", g->point[pathTmp[xx]]->name);\n                else\n                    printf(\"%s\\n\",g->point[pathTmp[xx]]->name );\n            }\n            //找最短路径\n            if (minDistance == -1 || minDistance > tmpdis)\n            {\n                minDistance = tmpdis;\n                minpathlen = lengpath;\n                for ( xx = 0; xx < lengpath; xx++)//int\n                    pathMin[xx] = pathTmp[xx];\n            }\n\n            //--------------------------------------------------------------\n            pop(head, &una, &unb); //将其弹出，继续探索\n            if (unb == start) head = 0;\n            inqueue[id] = 0;     //清空入栈的标志位\n        }\n    } //while end\n\n    //打印最短路径\n    if (minDistance == -1)\n    {\n        printf(\"无可用路径\\n\");\n        return;\n    }\n    printf(\"\\n最小花费:%d:\", minDistance);\n    for (kktt = 0; kktt < minpathlen; kktt++)\n    {\n        if (kktt < minpathlen - 1)\n            printf(\"%s --> \", g->point[pathMin[kktt]]->name);\n        else\n            printf(\"%s\\n\", g->point[pathMin[kktt]]->name);\n    }\n}\n\n\nint main()\n{\n    graph g;\n    g.vexnum = 0;\n    readAndCreatGraph(&g);\n    dijkstra(&g);\n    return 0;\n}\n\n\n\n", "Konwledge_Point": "最短路径", "Question": "迪杰斯特拉算法之解决最省钱的出游方案\n用迪杰斯特拉最短路径算法解决最省钱的出游方案。即给定一个出发地和目的地，给出最省钱的出游方案。各地票价如下：\n\n\n出发地 目的地 票价\n广州 北京 1000\n广州 深圳 200\n广州 上海 800\n深圳 北京 700\n深圳 上海 600\n深圳 拉萨1000\n北京 广州 1000\n北京 上海 500\n北京 深圳 700\n上海 广州 700\n上海 北京 500\n上海 深圳 700\n上海 拉萨1200\n拉萨 上海 1100", "Tag": "算法分析"}
{"Answer": "刚才到网上搜索到了一份A*算法的javascript实现.效果不错.\r\n楼主去看一下吧:[url]http://www.gissky.com/Download/ShowSoft.Asp?Type=4&ID=218[/url]\r\n不过代码没什么注释..看起来可能会有点头痛.", "Konwledge_Point": "最短路径", "Question": "求算法\n从A点（0，0）到B点（100，100）的最短路径\n\n\n\n如路线上存在障碍物，求绕过障碍物的最短路线\n\n[b]问题补充：[/b]\n\n其实我是自己无聊的时候在做html小游戏时遇到的问题， 我点击页面某一点， 然后页面中的小球则向我的点击坐标移动。\n\n那么在JS中又怎样实现这算法呢？\n\n这方面我还是太白，……", "Tag": "算法分析"}
{"Answer": "什么错误", "Konwledge_Point": "最短路径", "Question": "莫名的错误帮我看看吧\n\n\n这个错误很离谱，这是一个求图的最短路径代码，m和n分别表示起点和终点，但是如这个图所示，我cin两个指，然后调用shorts函数，这样程序运行时就会调用shorts函数失败，但如果我直接int m=0，n=5。这样它又能运行成功，感觉很疑惑，请教各位教导", "Tag": "算法分析"}
{"Answer": "这个是路径规划问题，可以参考一下：https://blog.csdn.net/YF_Li123/article/details/74090301如果对你有帮助，可以点击我这个回答右上方的【采纳】按钮，给我个采纳吗，谢谢", "Konwledge_Point": "最短路径", "Question": "此题不会做（C++给代码）\n\n描述\n现在有\nN\n个城市，编号分别为\n1\n到\nN\n，他们之间用单向道路进行相连。值得注意的是，每条道路有\n2\n个参数：道路长度和需要为此道路支付的通行费。\n\n现在周末来了，住在城市\n1\n的小明，拿上了他的钱包和他的\nswitch\n，准备和小红一起玩\n1\n小时游戏。但是小红住在城市\nN\n，且小明的零花钱有限。\n\n需要聪明的你帮助小明找到从城市\n1\n到城市\nN\n的最短路径，而且他能付得起这个通行费。\n\n输入格式\n第\n1\n行输入\nK\n。 这是小明拥有的零花钱\nK\n元。\n\n第\n2\n行输入\nN\n。这是城市总数\nN\n。\n\n第\n3\n行输入\nM\n。这是城市之间的单向道路数。\n\n接下来的\nM\n行，每行输入一道道路，道路信息包含\n4\n个数字，分别代表每条道路的\n4\n个信息：\nS\n,\n \nD\n,\n \nL\n,\n \nC\n。\n\n\nS\n为道路的起点（城市编号），\nD\n为道路终点（城市编号）， \nL\n为该道路的长度，\nC\n为该道路的通行费。\n\n依次类推，输入若干组样例。\n\n\n\n输出格式\n第\n1\n行输出第\n1\n个样例的结果，\n1\n个数字。代表小明从城市\n1\n到城市\nN\n的最短路径，该路径通行费小于等于\nK\n。如果不存在这样的最短路输出\n-\n1\n。\n\n依次类推，输出其他组样例的结果。\n\n输入样例\n\n5\n\n\n\n6\n\n\n\n7\n\n\n\n1\n \n2\n \n2\n \n3\n\n\n\n2\n \n4\n \n3\n \n3\n\n\n\n3\n \n4\n \n2\n \n4\n\n\n\n1\n \n3\n \n4\n \n1\n\n\n\n4\n \n6\n \n2\n \n1\n\n\n\n3\n \n5\n \n2\n \n0\n\n\n\n5\n \n4\n \n3\n \n2\n\n\n输出样例\n\n11\n\n\n数据范围\n\n0\n \n<=\n \nK\n \n<=\n \n10000\n,\n\n\n\n2\n \n<=\n \nN\n \n<=\n \n100\n,\n\n\n\n1\n \n<=\n \nM\n \n<=\n \n10000\n,\n\n", "Tag": "算法分析"}
{"Answer": "核心应该就是最短路径算法的实现：Demo\n#include<stdio.h>\n  \n#define SIZE 110  \n#define INF 1000000;  \n \nint map[SIZE][SIZE];  //邻接矩阵存储 \nint len[SIZE];      //d[i]表示源点到i这个点的距离 \nint visit[SIZE];  //节点是否被访问 \nint n,m;  \n \nint dijkstra(int from, int to){    //从源点到目标点 \n    \n    int i;  \n    \n    for(i = 1 ; i <= n ; i ++){    //初始化 \n        visit[i] = 0;    //一开始每个点都没被访问 \n        len[i] = map[from][i];    //先假设源点到其他点的距离 \n    }  \n  \n    int j;  \n    for(i = 1 ; i < n ; ++i){    //对除源点的每一个点进行最短计算 \n        int min = INF;  //记录最小len[i] \n        int pos;  //记录小len[i] 的点 \n  \n        for(j = 1 ; j <= n ; ++j){    \n            if(!visit[j] && min > len[j]){  \n                pos = j;  \n                min = len[j];  \n            }  \n        }  \n        visit[pos] = 1;  \n  \n        for(j = 1 ; j <= n ; ++j){\n            if(!visit[j] && (len[j] > (len[pos] +map[pos][j]))){ //如果j节点没有被访问过&&j节点到源节点的最短路径>pos节点到源节点的最短路径+pos节点到j节点的路径  \n                len[j] = len[pos] + map[pos][j];    //更新j节点到源节点的最短路径    \n            }  \n        }  \n    }  \n  \n    return len[to];\n}\n  \n  \nint main () {  \n \n    int i,j;  \n    \n  //  scanf(\"%d%d\",&n,&m);    //输入数据\n    n = 6;    //测试数据 \n    m = 9;\n \n    for(i = 1 ; i <= n ; ++i){    //设一开始每个点都不可达 \n        for(j = 1 ; j <= n ; ++j){  \n            map[i][j] = INF;  \n        }  \n    }  \n    \n/*    int a,b,c;    //输入数据 \n    for(i = 1 ; i <= m ; ++i){  \n        scanf(\"%d%d%d\",&a,&b,&c);  \n        map[a][b] = map[b][a] = c;  \n    }  */\n    \n    map[1][2] = 7;    //测试数据 \n    map[1][3] = 9;\n    map[1][6] = 14;\n    map[2][3] = 10;\n    map[2][4] = 15;\n    map[3][6] = 2;\n    map[5][6] = 9;\n    map[4][5] = 6;\n    map[3][4] = 11;\n    int temp = INF;\n    for(i = 1 ; i <= n ; ++i){\n        for(j = 1 ; j <= n ; ++j){\n            if(map[i][j] == temp)\n                map[i][j] = map[j][i];\n        }\n    }\n \n    int ans = dijkstra(1,5);  \n \n    printf(\"%d\",ans);  \n \n    return 0;  \n} \n \n/*    边的数据 \n1 2 7\n1 3 9\n1 6 14\n2 3 10\n2 4 15\n3 6 2\n5 6 9\n4 5 6\n3 4 11\n*/\n\n\n最短路径之Dijkstra算法 C语言实现_键盘有点滑的博客-CSDN博客_dijkstra算法c语言\nDijkstra算法（单源点路径算法，要求：图中不存在负权值边）：步骤：a.  初始时，S只包含源点，即S＝{v}，v的距离为0。U包含除v外的其他顶点，即: U={其余顶点}，若v与U中顶点u有边，则u的距离设置为相应的权值，若u v之间不存在边，则        设置u的距离为无穷大。b.  从U中选取一个距离 v 最小的顶点k，把k，加入S中（该选定的距离就是v到k的\n\n\n\nhttps://blog.csdn.net/qq_34845121/article/details/62056089\n\n\n最短路径—Dijkstra算法和Floyd算法 - as_ - 博客园\n注意：以下代码 只是描述思路，没有测试过！！ Dijkstra算法 1.定义概览 Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始\n\n\n\nhttps://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2615833.html\n\n", "Konwledge_Point": "最短路径", "Question": "利用c语音编程关于地铁路线的查询\n真的想不出来😭    要求不高 求个思路就行\n\n\n选题24、成都地铁查询系统假设成都已经建成了10条地铁形成地铁网络，要求该系统应用在地铁口的查询机上。程序目的是供旅客查询地铁的站点，票价，时间等信息。程序要求利用文件存储这些信息，自动计算出出发地和目的地如何换乘和价格。计算方法有最短路径，时间等选择。在过程中需要考虑到程序的易用性，程序提供站台表供用户选择出发点和目的地。题目提示站台的数据结构建议使用结构体，其中包括票价、站名、下一站，可换乘站台等信息。每条地铁线使用链表的结构来存储，元素为每个站台结构体。用户查询时，可在屏幕上打印每条地铁线的站名等信息使用户一目了然", "Tag": "算法分析"}
{"Answer": "可以参考这篇文章，希望对你有帮助：【数据结构】旅游景点咨询系统的设计与实现（图，DFS，迪杰斯特拉算法）_Chen_yuazzy的博客-CSDN博客", "Konwledge_Point": "最短路径", "Question": "这好像是我的作业，好想请教一下大神。\n题目13 旅游景点咨询系统的设计与实现\n\n\n\n[问题描述]:\n\n\n\n创建一个至少有15个点的有向网表示的某个旅游景点的导游图。顶点代表景点，类型为字符串(例如，泰山导游图:”天地广场门”，“十八盘”，“冯玉祥墓”  桃花峪门”，  中天门”，“南天门”，“玉皇顶”等)，  弧表示两个景点之间可以直达，弧上的权值表示两个景点之间的路程(公里数)，弧上还有到达方法的信息(有步行和索道两种)。建立一个游客咨询系统。\n\n\n\n[基本要求]\n\n\n\n(1)创建图的存储结构。\n\n\n\n(2)  输入两个景点名，就可以得到从一个景点到达另一个景点的所有简单路径、相应路径的路程公里数、行走的方法(每一段是步行，还是坐索道);\n\n\n\n(3)  输入两个景点名,  就可以得到其最短路径，  即:路程最短的行进方法;  如果两者无路径可通，就得出“两景点不可达的信息.\n\n\n\n难点\n\n[实现提示]:\n\n     (1)图的存储、遍历、运算等各种操作;\n\n     (2)  最短路径的计算与算法设计\n\n\n\n ", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/cambridgeacm/article/details/7741330\r\nhttp://blog.sina.com.cn/s/blog_7e5541250100ssue.html", "Konwledge_Point": "最短路径", "Question": "迷宫问题使用dp怎么求解？             \nDescription\n\n\n\n定义一个二维数组： \n\n\n\nint maze[5][5] = {\n\n\n\n0, 1, 0, 0, 0,\n\n0, 1, 0, 1, 0,\n\n0, 0, 0, 0, 0,\n\n0, 1, 1, 1, 0,\n\n0, 0, 0, 1, 0,\n\n\n\n\n};\n\n\n\n它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。\n\nInput\n\n\n\n一个5 × 5的二维数组，表示一个迷宫。数据保证有唯一解。\n\nOutput\n\n\n\n左上角到右下角的最短路径，格式如样例所示。\n\nSample Input\n\n\n\n0 1 0 0 0\n\n0 1 0 1 0\n\n0 0 0 0 0\n\n0 1 1 1 0\n\n0 0 0 1 0\n\nSample Output\n\n\n\n(0, 0)\n\n(1, 0)\n\n(2, 0)\n\n(2, 1)\n\n(2, 2)\n\n(2, 3)\n\n(2, 4)\n\n(3, 4)\n\n(4, 4)", "Tag": "算法分析"}
{"Answer": "java代码我在博文贴了，可以参考一下《如何在64m内存的运行环境下，靠Java完成旅游规划问题》,https://blog.csdn.net/BEYONDMA/article/details/115606833?utm_source=app&app_version=4.5.8", "Konwledge_Point": "最短路径", "Question": "Java 和 C 语言在内存使用和速度上有多少差别？\n题目来源：  \nhttps://pintia.cn/problem-sets/15/problems/717\n  \n\n\n\n7-9 旅游规划 \n\n\n\n \n\n\n\n有了一张自驾旅游路线图显示了城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。\n\n\n\n输入格式:\n\n\n\n输入说明：输入数据的第1行给出4个正整数N、M、S、D，其中N（2≤N≤500）是城市的个数，顺便假设城市的编号为0~(N−1)；M是高速公路的条数；S是出发地的城市编号；D是目的地的城市编号。随后的M行中，每行给出一条高速公路的信息，分别是：城市1、城市2、高速公路长度、收费额，中间用空格分开，数字均为整数且不超过500。输入保证解的存在。\n\n\n\n输出格式:\n\n\n\n在一行里输出路径的长度和收费总额，数字间以空格分隔，输出结尾不能有多余空格。", "Tag": "算法分析"}
{"Answer": "把报错信息贴出来", "Konwledge_Point": "最短路径", "Question": "pta甲级题1111，不知道哪出错了运行不了\n\n#include\nusing namespace std;\n#include\nint n, m;\nint es[\n510\n][\n510\n], et[\n510\n][\n510\n], diss[\n510\n], dist[\n510\n], books[\n510\n], bookt[\n510\n];\n#include\nvectortemppath, path, temptime, timepath, pres[\n510\n], pret[\n510\n];\nint start, jieshu;\nconst int inf = \n99999999\n;\nint minstime = inf;\nint mincount = inf;\nint minlength = inf;\nint minstime2 = inf;\n//求最短路径的dfs\nvoid dfss(int v) {\n    temppath.push_back(v);\n    if (v == start) {\n        int stime = \n0\n, length = \n0\n;\n        for (int i = temppath.size() - \n1\n; i >= \n1\n; i--) {\n            int id = temppath[i];\n            int nextid = temppath[i - \n1\n];\n            length += es[id][nextid];\n            stime += et[id][nextid];\n        }\n        if (length < minlength) {\n            minlength = length;\n            if (stime < minstime) {\n                minstime = stime;\n                path = temppath;\n            }\n        }\n    }\n    for (int i = \n0\n; i < pres[v].size() - \n1\n; i++) {\n        dfss(pres[v][i]);\n    }\n    temppath.pop_back();\n}\nvoid dfst(int v) {\n    \n    temptime.push_back(v);\n    if (v == start) {\n        int count = \n0\n, stime = \n0\n;\n        for (int i = temppath.size() - \n1\n; i >= \n1\n; i--) {\n            int id = temppath[i];\n            int nextid = temppath[i - \n1\n];\n            count++;\n            stime += et[id][nextid];\n        }\n        if (count < mincount) {\n            mincount = count;\n            if (stime < minstime2) {\n                minstime2 = stime;\n                timepath = temptime;\n            }\n        }\n    }\n    for (int i = \n0\n; i < pret[v].size() - \n1\n; i++) {\n        dfst(pret[v][i]);\n    }\n    temptime.pop_back();\n}\nint main()\n{\n    cin >> n, m;\n    fill(es[\n0\n], es[\n0\n] + \n510\n * \n510\n, inf);\n    fill(et[\n0\n], et[\n0\n] + \n510\n * \n510\n, inf);\n    fill(diss, diss + \n510\n, inf);\n    fill(dist, dist + \n510\n, inf);\n    //现在开始输入每个结点之间的距离和时间关系\n    int v1, v2, o, s, t;\n    for (int i = \n0\n; i < m; i++) {\n        cin >> v1 >> v2 >> o >> s >> t;\n        if (o == \n1\n)//说明是单行道\n        {\n            es[v1][v2] = s;\n            et[v1][v2] = t;\n        }\n        else if (o == \n0\n)//说明是双行道\n        {\n            es[v1][v2] = s;\n            es[v2][v1] = s;\n            et[v1][v2] = t;\n            et[v2][v1] = t;\n        }\n    }\n    //现在输出起始点\n    cin >>start >> jieshu;\n    //先从最短路径开始搞起\n    diss[start] = \n0\n;\n    for (int i = \n0\n; i < n; i++) {\n        int u = \n-1\n;\n        int minn = inf;\n        for (int j = \n0\n; j < n; j++) {\n            if (books[j] == \n0\n && diss[j] < minn) {\n                minn = diss[j];\n                u = j;\n            }\n        }\n            if (u == \n-1\n) {\n                break;\n            }\n            books[u] = \n1\n;\n            for (int v = \n0\n; v < n; v++) {\n                if (books[v] == \n0\n && es[u][v] != inf) {\n                    if (diss[v] > diss[u] + es[u][v]) {\n                        diss[v] = diss[u] + es[u][v];\n                        pres[v].clear();\n                        pres[v].push_back(u);\n                    }\n                    else if (diss[v] == diss[u] + es[u][v]) {\n                        pres[v].push_back(u);\n                    }\n                }\n            }\n        }\n    //现在开始dfs求最短路径\n    dfss(jieshu);\n    //现在开始求最短时间\n    dist[start] = \n0\n;\n    for (int i = \n0\n; i < n; i++) {\n        int u = \n-1\n;\n        int minn = inf;\n        for (int j = \n0\n; j < n; j++) {\n            if (bookt[j] == \n0\n && dist[j] < minn) {\n                minn = dist[j];\n                u = j;\n            }\n        }\n        if (u == \n-1\n) {\n            break;\n        }\n        bookt[u] = \n1\n;\n        for (int v = \n0\n; v < n; v++) {\n            if (bookt[v] == \n0\n && et[u][v] != inf) {\n                if (dist[v] > dist[u] + et[u][v]) {\n                    dist[v] = dist[u] + et[u][v];\n                    pret[v].clear();\n                    pret[v].push_back(u);\n                }\n                else if (dist[v] == dist[u] + et[u][v]) {\n                    pret[v].push_back(u);\n                }\n            }\n        }\n    }\n    //现在dfs\n    dfst(jieshu);\n    //现在判断最短路径和最短时间的是不是同一个\n    int index = \n1\n;\n    for (int i = \n0\n; i < path.size() - \n1\n; i++) {\n        if (path[i] == timepath[i]) {\n            index = \n0\n;\n        }\n    }\n    if (index == \n1\n)//说明两条路不相等\n    {\n        cout << \n\"Distance = \"\n << diss[jieshu] << \n\": \"\n << start;\n        for (int i = path.size() - \n2\n; i >= \n0\n; i--) {\n            cout << \n\"->\"\n << path[i];\n        }\n        cout << endl;\n        cout << \n\"Time = \"\n << minstime << \n\": \"\n<= \n0\n; i--) {\n            cout << \n\"->\"\n << timepath[i];\n        }\n    }\n    else if (index == \n0\n) {\n        cout << \n\"Distance =\"\n << diss[jieshu] << \n\": \"\n << \n\"Time = \"\n << minstime << \n\": \"\n<= \n0\n; i--) {\n            cout << \n\"->\"\n << path[i];\n        }\n\n    }\n    cout << endl;\n    system(\n\"pause\"\n);\n    return \n0\n;\n}\n", "Tag": "算法分析"}
{"Answer": "\n/**\n * @author cuiods\n */\npublic class MazeCell {\n    private int x;\n    private int y;\n    private int step;\n \n    public MazeCell(int x, int y, int step) {\n        this.x = x;\n        this.y = y;\n        this.step = step;\n    }\n \n    public int getX() {\n        return x;\n    }\n \n    public void setX(int x) {\n        this.x = x;\n    }\n \n    public int getY() {\n        return y;\n    }\n \n    public void setY(int y) {\n        this.y = y;\n    }\n \n    public int getStep() {\n        return step;\n    }\n \n    public void setStep(int step) {\n        this.step = step;\n    }\n}\n\nimport java.util.Scanner;\nimport java.util.Stack;\n \n/**\n * 迷宫类\n * 找到所有到达终点的路径\n * @author cuiods\n */\npublic class Maze {\n \n    /**\n     * 临时保存路径\n     */\n    private Stack<MazeCell> pathStack = new Stack<>();\n    /**\n     * 保存迷宫\n     */\n    private int[][] maze;\n    private boolean flag = false;\n    private MazeCell startCell;\n    private MazeCell endCell;\n \n    public Maze() {\n        initialMaze();\n    }\n \n    /**\n     * 寻找路径\n     */\n    public void findPath() {\n        assert flag;\n        processCell(startCell.getX(), startCell.getY(), startCell.getStep());\n    }\n \n    private void processCell(int x, int y, int step) {\n        if (x == endCell.getX() && y == endCell.getY()) {\n            pathStack.pop();\n            printPath();\n            System.out.println(\"(\"+endCell.getX()+\",\"+endCell.getY()+\")\");\n            return;\n        }\n        test(x,y-1,step+1);\n        test(x,y+1,step+1);\n        test(x-1,y,step+1);\n        test(x+1,y,step+1);\n    }\n \n    private void test(int x, int y, int step) {\n        if (canGo(x,y)){\n            MazeCell mazeCell = new MazeCell(x,y,step);\n            insertToPath(mazeCell);\n            processCell(x,y,step);\n        }\n    }\n \n    private void printPath(){\n        for (int i = 0; i < pathStack.size(); i++) {\n            MazeCell cell = pathStack.get(i);\n            System.out.print(\"(\"+cell.getX()+\",\"+cell.getY()+\")->\");\n        }\n    }\n \n    private void insertToPath(MazeCell mazeCell) {\n        while (pathStack.peek().getStep() >= mazeCell.getStep()) {\n            pathStack.pop();\n        }\n        pathStack.push(mazeCell);\n    }\n \n    private boolean canGo(int x, int y) {\n        if (maze[x][y]==1) {\n            return false;\n        }\n        for (int i = 0; i < pathStack.size(); i++) {\n            MazeCell mazeCell = pathStack.get(i);\n            if (mazeCell.getX()==x && mazeCell.getY()==y) {\n                return false;\n            }\n        }\n        return true;\n    }\n \n    private void initialMaze() {\n        int column;\n        int row;\n        Scanner scanner = new Scanner(System.in);\n        int temp = 0;\n        do {\n            System.out.println(\"请输入迷宫行数(>0)：\");\n            temp = scanner.nextInt();\n        } while (temp<=0);\n        row = temp;\n        do {\n            System.out.println(\"请输入迷宫列数(>0)：\");\n            temp = scanner.nextInt();\n        } while (temp<=0);\n        column = temp;\n        maze = new int[row+2][column+2];\n        System.out.println(\"请输入迷宫（1为墙，0为路，-1为起点，2为终点）:\");\n        for (int i = 0; i < column+2; i++) {\n            maze[0][i] = 1;\n        }\n        for (int i = 1; i < row+1; i++) {\n            maze[i][0] = 1;\n            for (int j = 1; j < column+1; j++) {\n                temp = scanner.nextInt();\n                switch (temp) {\n                    case -1:\n                        startCell = new MazeCell(i,j,0);\n                        maze[i][j] = temp;\n                        pathStack.push(startCell);\n                        break;\n                    case 2:endCell = new MazeCell(i,j,-1);\n                    case 0:\n                    case 1:maze[i][j] = temp;break;\n                    default:\n                        System.out.println(\"输入不符合要求T T\");\n                        return;\n                }\n            }\n            maze[i][column+1] = 1;\n        }\n        for (int i = 0; i < column+2; i++) {\n            maze[row+1][i] = 1;\n        }\n        if (startCell!=null && endCell!=null) {\n            flag = true;\n            System.out.println(\"输入成功:)\");\n        } else {\n            System.out.println(\"至少要有一个起点和终点:(\");\n        }\n    }\n}\n\n/** 测试类\n * @author csdn-zhangteacher\n * test main\n */\npublic class Main {\n \n    public static void main(String[] args) {\n        Maze maze = new Maze();\n        maze.findPath();\n    }\n}", "Konwledge_Point": "最短路径", "Question": "java实现迷宫问题\n给定一个迷宫，阵列中每个元素用0或1表示。0表示可以走，1表示不可走。给定入口位置后，用程序找到出口。输出从入口到出口的路径，路径中每一个节点位置用二维数组（左上角为0,0）表示，并找出最短路径\n\n\n\n以下面4*4的迷宫举例，入口为(0,1)\n\n\n\n1011\n\n\n\n1001\n\n\n\n1100\n\n\n\n1111\n\n\n\n输出应该为：\n\n\n\n(0,1)\n\n\n\n(1,1)\n\n\n\n(1,2)\n\n\n\n(2,2)\n\n\n\n(2,3)", "Tag": "算法分析"}
{"Answer": "cbcbbcdb", "Konwledge_Point": "最短路径", "Question": "计算机网络一些相关问题\n1.NAT重载如何提供一对多的地址转换？\n（选择一个）\nA.它使用了一个地址池\nB.它将IPV4地址转换为未使用的IPv6地址\nC. 它为每个会话分配一个唯一的TCP/UDP端口\nD. 它使用虚拟MAC地址和虚拟IP地址\nIPV4中支持哪些IPV6特性，但不常用？（选择一个）\nA. 单播\nB. 多点传送\nC. anycast\nD. 广播\n在哪种CLI配置模式下，您可以配置设备的主机名？（选择一个）\nA. 行方式\nB. 接口方式\nC. 全局方式\nD. 路由器模式\n4.关于跨树根桥选举的说法是正确的？（选择一个）\nA.它总是是自动执行的\nB.每个VLAN都必须有自己的根桥接器\nC. 每个VLAN都必须使用相同的根桥接器\nD. 每个根网桥必须停留在同一根交换机上\n您可以输入哪个命令来验证是否已建立到远程设备的BGP连接？\nA.显示ipbgp摘要\nB.显示ip社区列表\nC.显示ipbgp路径\nD.显示ip路由\n哪个项目代表标准的IPACL？（选择一个）\nA. 访问列表110允许任何任何内容\nB. 访问列表50拒绝192.168.1.10.0.0.255\nC. 访问列表101拒绝tvp任何主机192.168.1.1\nD. 访问列表2500拒绝tcp任何主机192.168.1.1eq22\n哪些特征代表了链路状态路由协议？（选择两个）\nA. 提供了整个拓扑结构的通用视图\nB. 与邻居交换路由表\nC. 计算最短路径\nD. 利用事件触发的更新\nE. 利用频繁的定期更新\n您可以使用哪个实用程序来确定交换机是否可以发送回声请求和回复？（选择一个）\nA. 平\nB. traceroute\nC. ssh\nD. 电视网", "Tag": "算法分析"}
{"Answer": "参考GPT和自己的思路，以下是一个解决这个问题的Python程序：\nimport sys\nfrom collections import deque\n\n# 有效的骑士移动\nMOVES = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]\n\ndef to_coord(square):\n    \"\"\"将棋盘位置转换为坐标\"\"\"\n    col, row = square[0], square[1]\n    x = ord(col) - ord('a')\n    y = int(row) - 1\n    return x, y\n\ndef to_square(coord):\n    \"\"\"将坐标转换为棋盘位置\"\"\"\n    x, y = coord\n    col = chr(x + ord('a'))\n    row = str(y + 1)\n    return col + row\n\ndef bfs(start, end):\n    \"\"\"使用广度优先搜索查找从起点到终点的最短骑士路径\"\"\"\n    start_coord = to_coord(start)\n    end_coord = to_coord(end)\n    queue = deque([(start_coord, 0)])\n    visited = set([start_coord])\n    while queue:\n        coord, moves = queue.popleft()\n        if coord == end_coord:\n            return moves\n        for dx, dy in MOVES:\n            x, y = coord[0] + dx, coord[1] + dy\n            if 0 <= x < 8 and 0 <= y < 8 and (x, y) not in visited:\n                visited.add((x, y))\n                queue.append(((x, y), moves+1))\n    return None\n\n# 读取输入文件\ninput_file = sys.stdin\nline = input_file.readline().strip()\na, b = line.split()\n\n# 查找最短骑士路径\nn = bfs(a, b)\n\n# 输出结果\nprint(\"To get from {} to {} takes {} knight moves.\".format(a, b, n))\n\n该程序首先定义了一个有效的骑士移动列表，然后定义了两个帮助函数，一个将棋盘位置转换为坐标，另一个将坐标转换为棋盘位置。接下来，它使用广度优先搜索算法来查找从起点到终点的最短骑士路径，并返回路径长度。最后，它将结果输出到标准输出流。\n程序的输入是一个包含两个棋盘位置的字符串的文件。程序可以使用以下命令将其运行：\npython knight_moves.py < input.txt\n\n其中，input.txt是包含输入的文本文件。程序将输出结果到标准输出流。", "Konwledge_Point": "最短路径", "Question": "python问题，详细请看问题\n你的一个朋友正在研究旅行骑士问题(TKP)，在这个问题中，你要找到最短的骑士移动封闭行程，该行程恰好访问棋盘上给定的n个方格中的每个方格一次。他认为问题中最困难的部分是确定在两个给定方格之间最小的骑士移动次数，一旦你完成了这一任务，找到旅程就变得很容易了。你当然知道，反之亦然。所以你让他写一个程序来解决“困难”的部分。你的工作是编写一个程序，将两个方块a和b作为输入，然后确定从a到b的最短路径上的骑士移动次数。\n\n\n输入\n一个输入文件由一行包含两个空格分隔的方格组成。\n方格是由字母(A ..h)和数字(1..8)组成的字符串，前者表示棋盘上的列，后者表示棋盘上的行。\n\n\n输出\n打印一行  ‘To get from xx to yy takes n knight moves.’.\n例子\n\n\n原题内容（英文）\nA friend of you is doing research on the Traveling Knight Problem (TKP) where you are to find the\nshortest closed tour of knight moves that visits each square of a given set of n squares on a chessboard\nexactly once. He thinks that the most difficult part of the problem is determining the smallest number of\nknight moves between two given squares and that, once you have accomplished this, finding the tour\nwould be easy. Of course you know that it is vice versa. So you offer him to write a program that solves\nthe ”difficult” part. Your job is to write a program that takes two squares a and b as input and then\ndetermines the number of knight moves on a shortest route from a to b.\n\n\nInput\n• An input file consists of one line containing two squares separated by one space.\n• A square is a string consisting of a letter (a..h) representing the column and a digit (1..8)\nrepresenting the row on the chessboard. \n\n\nOutput\nPrint one line saying ‘To get from xx to yy takes n knight moves.’.", "Tag": "算法分析"}
{"Answer": "如何调用函数？你定义好了参数列表中是两个整形变量，你调用的时候往括号里放实际的变量或者数值呀，怎么还在调用的时候在括号里定义变量呢", "Konwledge_Point": "最短路径", "Question": "这个Display函数该怎么调用\n下面Display函数调用为什么会出错，是括号里的参数不对嘛，正确的写法是什么\n\n\n\n\nvoid Display(int sight1,int sight2){\n   int a,b,c,d,\nq\n=0;\n    \na\n=sight2; \n    \nif\n(a!=sight1)\n    {\n        printf(\n\"\\n\\t从%s到%s的最短路径是\"\n,G.vex[sight1].sight,G.vex[sight2].sight);\n        printf(\n\"\\t(最短距离为%dm.)\\n\\n\\t\"\n,D[a]); \n        printf(\n\"\\t%s\"\n,G.vex[sight1].sight); \n        \nd\n=sight1;\n        \nfor\n(\nc\n=0;c%s\"\n,G.vex[b].sight); \n                    \nq\n=q+1;\n                    P[a][b]=0;\n                    \nd\n=b; \n                    \nif\n(q%\n8\n==0) printf(\n\"\\n\"\n);\n                }\n            }\n        }\n    }\n}\n\n\n\ncase\n \n2\n:\n        \ndo\n\n        {\n            system(\n\"cls\"\n);\n            cu=UMenu();\n            \nswitch\n(cu)\n            {\n            \ncase\n \n1\n:Info(); \nbreak\n; \n            \ncase\n \n2\n:Display(\nint\n sight1,\nint\n sight2); \nbreak\n;\n            \ncase\n \n3\n:\nMap\n(); \nbreak\n;\n            }getch();\n        }\nwhile\n(cu!=\n4\n);\n        \nbreak\n;\n    }\n", "Tag": "算法分析"}
{"Answer": "你这加了int以后，这个局部变量i就只在循环里使用，循环结束就销毁，这个i和外面的全局变量i不是同一个", "Konwledge_Point": "最短路径", "Question": "关于把全局变量改成局部变量结果出现了问题\n#include\nusing namespace std;\nint a[1005][1005],d[1005],i,j;\nconst int INF=1e9;\nvoid chushi(int n)//邻接矩阵初始化\n{\n    for(i=1;i<=n;i++)\n    {\n        for(j=1;j<=n;j++)\n        {\n            if(i!=j)\n            a[i][j]=INF;//求最短要初始化为无限大\n        }\n    }\n}\nvoid dij(int n)//单源最短路径\n{\n    bool f[1005]={0};\n    f[1]=1;\n    int v;\n    for(i=1;id[j])//找未标记中最小的\n            {\n                min=d[j];\n                v=j;\n            }\n        }\n        f[v]=1;//标记\n        for(j=1;j<=n;j++)\n        {\n            if(!f[j]&&a[v][j]+d[v]>n>>m;\n    chushi(n);\n    for(i=1;i<=m;i++)\n    {\n        cin>>x>>y>>z;\n        a[x][y]=min(a[x][y],z);//避坑：防止同一条路多次输入！\n    }\n    for(i=1;i<=n;i++)\n    {\n        d[i]=a[1][i];//路径长度初始化\n    }\n    dij(n);\n    int ans;\n    for(i=1;i<=n;i++)\n    {\n        ans+=d[i];\n    }\n    over(n);//翻转\n    for(i=1;i<=n;i++)//路径长度初始化\n    {\n        d[i]=a[1][i];\n    }\n    dij(n);\n    for(i=1;i<=n;i++)\n    {\n        ans+=d[i];//求和\n    }\n    cout<<ans<<endl;//华丽地输出\n    return 0;\n}\n输出\n\n\n但如果在i前面加个int，\n\n\n就变成了\n\n\n不过就是把一个i变成了局部变量，其他的也没变啊，为什么最终结果变了？", "Tag": "算法分析"}
{"Answer": "封装?你要封装成类吗，如果是，那可能绝大部分代码需要重构，因为你这是面向过程的代码", "Konwledge_Point": "最短路径", "Question": "这段函数如何进行封装？\n\n\n#include\n\n\n#include\n\n\n#include\n\n\n#include\n\n\n#include\n\n\n#include \n\nusing namespace std;\ntypedef struct\n{\n    \nint\n \nx\n,\ny\n;\n}item;\n\ntypedef struct\n{\n    \nint\n \nx\n,\ny\n,d;\n}Datetype;\ntypedef stack stack_int;\nvoid path (\nint\n **maze,\nint\n,\nint\n,\nint\n,\nint\n);\nvoid printpath();\n\n#define NUM 100    //队列大小；\n\ntypedef struct{\n    \nint\n \nx\n,\ny\n;  \n//\n所到点的坐标；\n    \nint\n pre;  \n//\n前驱点的下标；\n}SqType;  \n//\n队列；\n\nint\n front,rear;  \n//\n队首指针与队尾指针；\nvoid printpath(SqType s\nq[]\n,\nint\n){\n//\n打印路径\n    \nint\n i;\n    i=rear; \n    \ndo\n{\n        cout<<\n\"(\"\n<>m>>n;\n    \nint\n **maze=new \nint\n*[m+\n2\n];\n    \nfor\n(i=\n0\n;i<=m+\n1\n;i++)\n        maze[i]=new \nint\n[n+\n2\n];\n//\n申请迷宫的空间；\n    \nfor\n(i=\n0\n;i<=m+\n1\n;i++)   \n        maze[i][\n0\n]=\n1\n;\n    \nfor\n(i=\n0\n;i<=n+\n1\n;i++)\n        maze[\n0\n][i]=\n1\n;\n    \nfor\n(i=\n0\n;i<=m+\n1\n;i++)\n        maze[i][n+\n1\n]=\n1\n;\n    \nfor\n(i=\n0\n;i<=n+\n1\n;i++)\n        maze[m+\n1\n][i]=\n1\n;  \n//\n建立迷宫周围的墙；\n    cout<<\n\"1、采用创建好的迷宫; 2、自己创建迷宫（其他输入按'2'处理）\"\n<>s;\n    \nif\n(s==\n\"1\"\n)\n    {\n        \nsrand\n(\ntime\n(\n0\n));  \n//\n系统时间随机函数；\n        \nfor\n(i=\n1\n;i<=m;i++)\n            \nfor\n(j=\n1\n;j<=n;j++)\n                maze[i][j]=\nrand\n()%2;  \n//\n随机赋值\n        maze[\n1\n][\n1\n]=\n0\n;   \n//\n(\n1\n,\n1\n)点为可通过点；\n        maze[m][n]=\n0\n;   \n//\n(m,n)点为可通过点；\n    }\n    \nelse\n \n    {\n        cout<<\n\"请输入迷宫：\"\n<>maze[i][j];\n              A:\nif\n(maze[i][j]!=\n0\n && maze[i][j]!=\n1\n)\n                {\n                    cout<<\n\"请再次输入：\"\n;\n                    cin>>maze[i][j];\ngoto\n A;  \n//\n判错；\n                }\n            }    \n    }\n    cout<<\n\"迷宫如下：\"\n<>i>>j>>c>>d;\n    path(maze,i,j,c,d);    \n//\n调用路径函数，输出路径；\n    cout<>l;  \n    \nif\n(l==\n1\n){\n        restore(maze,m,n);  \n//\n恢复迷宫；\n        \ngoto\n H;\n    }\n    \nelse\n \nreturn\n;   \n//\n跳出此函数；\n}\n\nint\n main()\n{\n    string s=\n\"Y\"\n;\n    \ndo\n\n    {\n        cout<<\n\"--------------------------欢迎到达迷宫界面--------------------------\\n\"\n;\n        printpath();\n        cout<>s;\n    }\nwhile\n (s==\n\"Y\"\n||s==\n\"y\"\n);\n    \nsystem\n(\n\"pause\"\n);\n}\n", "Tag": "算法分析"}
{"Answer": "这篇文章讲的很详细，请看：最短路之Dijkstra+堆优化（单源最短路）", "Konwledge_Point": "最短路径", "Question": "利用dijkstra求解最短路计数出现问题\n利用dijkstra在枚举最短路的过程中顺便更新路径数\n[原题链接]（\nhttps://www.luogu.com.cn/problem/P1144\n\n\n用代码块功能插入代码，请勿粘贴截图\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\n\ntypedef\n \nlong\n \nlong\n LL;\n\nconst\n \nint\n N=\n1e6\n;\nLL h[N],e[N],ne[N],w[N],idx;  \n// 邻接表存储\n\n\nint\n n,m;  \n// n个顶点,m条边\n\nLL dist[N]; \n// 每个点到1的距离\n\nLL ans[N];  \n// 标记起点到每个点的路径条数\n\n\nbool\n st[N];  \n// 标记是否在点集内\n\n\n\n#\ndefine\n x first\n\n\n#\ndefine\n y second\n\n\ntypedef\n pair<\nint\n,\nint\n>PII;\n\n\nvoid\n \nadd\n(\nint\n a,\nint\n b)\n\n\n{\n    e[idx]=b,ne[idx]=h[a],w[idx]=\n1\n,h[a]=idx++;\n}\n\nvoid\n \ndijkstra\n()\n\n\n{\n    \nmemset\n(dist,\n0x3f\n,\nsizeof\n dist);\n    dist[\n1\n]=\n0\n;ans[\n1\n]=\n1\n;\n    priority_queue,greater>heap;\n    heap.\npush\n({\n0\n,\n1\n});\n    \n    \nwhile\n(heap.\nsize\n())\n    {\n        \nauto\n t=heap.\ntop\n();\n        heap.\npop\n();\n        \nint\n ver=t.y,distance=t.x;\n        \nif\n(st[ver]) \ncontinue\n;\n        st[ver]=\ntrue\n;\n        \nfor\n(\nint\n i=h[ver];i!=\n-1\n;i=ne[i])\n        {\n            \nint\n j=e[i];\n            \nif\n(dist[j]>distance+w[i])  \n// 比之前的距离小，到达该点的最短路径数修改为能到ver的数量\n\n            {\n                ans[j]=ans[ver];\n                dist[j]=distance+w[i];\n                heap.\npush\n({dist[j],j});\n            }\n          \nelse\n \nif\n(dist[j]==dist[ver]+w[i]) ans[j]+=ans[ver];\n        }\n    }\n}\n\nint\n \nmain\n()\n\n\n{\n   \nmemset\n(h,\n-1\n,\nsizeof\n h);\n   \nscanf\n(\n\"%d%d\"\n,&n,&m);\n   \nwhile\n(m--)\n   {\n    \nint\n a,b;\n    \nscanf\n(\n\"%d%d\"\n,&a,&b);\n    \nadd\n(a,b);\nadd\n(b,a);\n   }\n   \ndijkstra\n();\n   \nfor\n(\nint\n i=\n1\n;i<=n;i++)\n    cout<<ans[i]%\n100003\n<<endl;\n   \nreturn\n \n0\n;\n}\n\n\n\n\n运行结果及报错内容\n\n\n\n\n我的解答思路\n\n\n如果从起点到t有ans[t]条边，从t到j有x条边，那么从起点到j就有两者相乘条边，也可以相加x次，就是每找到一条从t到j的边就加ans[t]\n\n", "Tag": "算法分析"}
{"Answer": "看了一下。。这个博主代码完全没放全。。我说一下解决方案\n按照你当前的代码，把16行的import matrix去掉，该博主本身是将这份代码分成两份写的，第一份是matrix.py且代码没给全，比如tran_m方法\n然后将59行开始改为\n\ndata=matrix(address)\nfloyd(data)\n按该博主意思，tran_m仅用于数据处理，不影响数据输入floyd方法\n运行结果\n", "Konwledge_Point": "最短路径", "Question": "module matrix has no attribute matrix\n使用弗洛伊德算法模拟最短路径时出现module matrix has no attribute matrix\n\n\n\n\n\nimport xlrd\nimport sys\n\ndef matrix(address):                           #读取excel生成邻接矩阵\n    wb = xlrd.open_workbook(address)\n    sheet1 = wb.sheet_by_name('邻接矩阵_距离')\n    L = []\n    for i in range(1,51):\n        a = sheet1.row_values(i)\n        a.remove(a[0])\n        L.append([int(x) for x in a])\n    # print(L)\n    return L\n\nfrom pylab import *\nimport matrix\n\n\ndef floyd(d):\n    D=d\n    lengthD = len(D)                    #邻接矩阵大小\n    p = list(range(lengthD))\n    P = []\n    for i in range(lengthD):\n        P.append(p)\n    P = array(P)\n    for k in range(lengthD):\n        for i in range(lengthD):\n            for j in range(lengthD):\n                if(D[i][j] >D[i][k]+D[j][k]):         #两个顶点直接较小的间接路径替换较大的直接路径\n                    P[i][j] = P[i][k]                 #记录新路径的前驱\n                    D[i][j] = D[i][k]+D[j][k]\n    print('各个顶点的最短路径:')\n    for i in range(lengthD):\n        for j in range(i+1,lengthD):\n            print('v%d' % (i+1) + '--' + 'v%d' % (j+1) + '\\t' + 'dist_min:' + '\\t' + str(D[i][j]) + '\\t' + 'path:'+'v%d'%(i+1),end='' )\n            temp=P[i][j]\n            while (temp!=j):\n                print('--'+'v%d'%(temp+1),end='')\n                temp=P[temp][j]\n            print('--'+'v%d'%(j+1))\n    print('P矩阵:')\n    print(P)\n    print('D矩阵:')\n    for i in D:\n        print(i)\n    return D\n\n\nif __name__ == '__main__':\n    chararray = ['1','2','3','4','5','6','7','8','9','10','11','12','13','14','15','16','17','18','19','20','21','22','23','24','25','26','27','28','29','30','31','32','33','34','35','36','37','38','39','40','41','42','43','44','45','46','47','48','49','50']\n    L=[]\n    for i in range(1,len(chararray)+1):\n        L.append('v%d'%i)\n    Dict=dict(zip(L,chararray))\n    print('各点对应关系：')\n    print(Dict)\n    address = 'C:\\\\Users\\11573\\Desktop\\python\\数据及代码\\数据/邻接矩阵.xlsx'\n    data=matrix.matrix(address)\n    d=matrix.tran_m(data)\n    floyd(d)\n\n————————————————\n版权声明：本文为CSDN博主「heavenmark」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/heavenmark/article/details/82794565\n\n\n\n源代码来自与同站博主heavenmark", "Tag": "算法分析"}
{"Answer": "网友的相似疑问：https://stackoverflow.com/questions/41479316/maven-dependency-management-the-first-declaration-wins，但是没人去回答他....\r\n\r\n其实这个是 dependency 插件的功能，默认采用的是复写的策略，当构建声明处于同一 pom 中，且 groupid 和 artifactId 一致时，以**最新声明为准**，后面的覆盖前面的。注意这里没涉及到依赖调解的功能。我的理解是依赖调解只发生于构建来自不同 pom 时，而此时构建声明处于同一 pom，故不会触发依赖调解。\r\n\r\n参考：\r\nhttps://maven.apache.org/plugins/maven-dependency-plugin/usage.html\r\nhttps://juejin.im/post/5cbf27a95188250a505c2cd2#heading-18\r\nhttps://stackoverflow.com/questions/42113542/figuring-out-duplicate-dependency-in-war", "Konwledge_Point": "最短路径", "Question": "Maven 依赖调解原则失效？\n都知道 Maven 在出现依赖版本冲突问题时，会用最短路径原则和第一声明原则来解决冲突。但在自己电脑上引入如下依赖，却产生了与期望违背的效果：\n\n\n\n\ncommons-io\ncommons-io\n2.6\n\n\ncommons-io\ncommons-io\n2.4\n\n\n\n\n\n按照两个原则的话，最终引入的应该是版本为 2.6 的包，但实际却引入了版本为 2.4 的包。分析如下：\n\n\n\n> mvn dependency:tree\n[INFO] ------------------------------------------------------------------------\n[INFO] Building mvn-test 1.0.0\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ mvn-yilaitest ---\n[INFO] com.ariclee:mvn-yilaitest:jar:1.0.0\n[INFO] \\- commons-io:commons-io:jar:2.4:compile\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 1.068 s\n[INFO] Finished at: 2019-05-11T16:45:38+08:00\n[INFO] Final Memory: 12M/245M\n[INFO] ------------------------------------------------------------------------\n\n\n\n\n为什么依赖后声明的却被引入了，这不是违背了第一声明原则吗？", "Tag": "算法分析"}
{"Answer": "估计你的编译器不支持c++11标准，或者你么有打开你的编译器的C++11标准的开关，如果不支持的话可以用以下语句q.push(make_pair(1,1));替代", "Konwledge_Point": "最短路径", "Question": "如何使用“{ x,y}”向队列中传入二位数组元素(x,y)？\n在使用某博主关于BFS算法求解（迷宫）最短路径问题时，我看到了这样几条语句，并提出了我的疑问。\n\n\n（\n1\n）\ntypedef\n pair<\nint\n, \nint\n> PII;\n//pair?\n\n（\n2\n）queue q;\n//队列中使用二维数组作为元素？\n\n（\n3\n） q.\npush\n({\n0\n,\n0\n});\n//怎么push一个二维的数组元素(x,y)\n\n（\n4\n）\nauto\n t=q.\nfront\n();\n//哪里来的auto?\n\n\n\n\n我尝试在dev上运行，以下是完整的代码，和我在CSDN上找到的关于使用“{}”返回等的错误改写（其后用“//”标识），但是任然没有解决问题。\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n//#include \n\n\nusing\n \nnamespace\n std;\n\n//add_definitions(\"std=c++11\");\n\n\ntypedef\n pair<\nint\n, \nint\n> PII;\n//\n\n\nconst\n \nint\n N = \n110\n;\n\nint\n s[N][N];\n\nint\n n,m;\n\nint\n g[N][N];\n\nint\n \nbfs\n()\n\n\n{\n    queue q;\n//\n\n    \nmemset\n(g, \n-1\n, \nsizeof\n g);\n//\n\n    q.\npush\n({\n0\n,\n0\n});\n//\n\n    g[\n0\n][\n0\n]=\n0\n;\n    \nint\n dx[\n4\n] = {\n-1\n, \n0\n, \n1\n, \n0\n}, dy[\n4\n] = {\n0\n, \n1\n, \n0\n, \n-1\n};\n//\n\n    \nwhile\n(q.\nsize\n())\n    {\n        \nauto\n t=q.\nfront\n();\n//\n\n        q.\npop\n();\n        \nfor\n(\nint\n i=\n0\n;i<\n4\n;i++)\n        {\n            \nint\n a=t.first+dx[i];\n            \nint\n b=t.second+dy[i];\n            \nif\n(a>=\n0\n && a=\n0\n && b>n>>m;\n\nfor\n(\nint\n i=\n0\n;i>s[i][j];\ncout<<\nbfs\n()<据说是包括了很多头文件……那在这个地方，可以只写它吗？", "Tag": "算法分析"}
{"Answer": "引入 \r\n\r\ncommons-dbcp\r\n\r\n的时候把commons-collections-2.1 exclude掉就行了\r\n\r\n或者\r\n\r\n在你的直接的POM中引入\r\n\r\ncommons-collections\r\n\r\nMaven是按照最短路径来的，只要你直接在POM引入了，就会用你直接引入的。\r\n\r\nMaven2.0.9是这样的，不知道2.1这个规则有没有改，LZ试一试上面两种方法", "Konwledge_Point": "最短路径", "Question": "Maven集成时依赖jar包版本控制问题\n我有一个WEB工程需要用到commons-collections和commons-dbcp.\n\n代码中用到的是commons-collections的3.1版本特性，但是资源库中commons-dbcp依赖的\n\ncommons-collections指定了2.1版本。看了下commons-dbcp-1.2.1.pom：\ncommons-collections\ncommons-collections\n2.1\n\n\n\n当我将web工程打包时，maven会将commons-collections-3.1.jar\n\n和commons-collections-2.1.jar都拷贝进WAR包。 如何只让maven只将\n\ncommons-collections-3.1.jar拷贝到war包中去？\n\n\n\n[b]问题补充：[/b]\n\n谢谢，jansel的答复，方案1是可以行的，但是觉得maven应该有其它解决方案，所以发贴出来咨询一下。方案2我试过了，在我自己的工程pom.xml文件中指定了\n\n高版本的common-collections，但是maven做package的时候依赖会将两个版本的common-collections库都打进WEB-INF/lib，我的maven版本是2.0.9.\n\n[b]问题补充：[/b]\n\nE:\\NGWORK\\javaprj\\webapp>mvn dependency:tree -Dverbose -Dincludes=commons-collections\n\n\n\nE:\\NGWORK\\javaprj\\webapp>set MAVEN_OPTS=-Xms64m  -Xmx512m\n\n[INFO] Scanning for projects...\n\n[INFO] Searching repository for plugin with prefix: 'dependency'.\n\n[INFO] ------------------------------------------------------------------------\n\n[INFO] Building Unnamed - asiainfo.cboss:cboss:war:SNAPSHOT\n\n[INFO]    task-segment: [dependency:tree]\n\n[INFO] ------------------------------------------------------------------------\n\nDownloading: \nhttp://repo1.maven.org/maven2/asiainfo/cas/aicasclient/1.0/aicasclient-1.0.pom\n\nDownloading: \nhttp://repo1.maven.org/maven2/cmcc/twcmcc/1.4/twcmcc-1.4.pom\n\nDownloading: \nhttp://repo1.maven.org/maven2/castor/castor-xml/1.0/castor-xml-1.0.pom\n\nDownloading: \nhttp://repo1.maven.org/maven2/asiainfo/openboss/openclient/2.0/openclient-2.0.pom\n\nDownloading: \nhttp://repo1.maven.org/maven2/xstream/xstream/1.3/xstream-1.3.pom\n\nDownloading: \nhttp://repo1.maven.org/maven2/jdk/tools/1.4.2/tools-1.4.2.pom\n\nDownloading: \nhttp://repo1.maven.org/maven2/servlet/servlet/2.3/servlet-2.3.pom\n\nDownloading: \nhttp://repo1.maven.org/maven2/asiainfo/cboss/portalExternal/1.8/portalExternal-1.8.pom\n\nDownloading: \nhttp://repo1.maven.org/maven2/asiainfo/openbuff/EzfrmWeb/1.0/EzfrmWeb-1.0.pom\n\nDownloading: \nhttp://repo1.maven.org/maven2/asiainfo/openbuff/EzfrmBiz/1.0/EzfrmBiz-1.0.pom\n\nDownloading: \nhttp://repo1.maven.org/maven2/net/sf/jasperreports/2.0.3/jasperreports-2.0.3.pom\n\nDownloading: \nhttp://repo1.maven.org/maven2/lowagie/itext/1.3.1/itext-1.3.1.pom\n\nDownloading: \nhttp://repo1.maven.org/maven2/lowagie/itext-asian/1.0/itext-asian-1.0.pom\n\nDownloading: \nhttp://repo1.maven.org/maven2/net/sf/json/2.2.1/json-2.2.1.pom\n\nDownloading: \nhttp://repo1.maven.org/maven2/net/sf/ezmorph/1.0.4/ezmorph-1.0.4.pom\n\nDownloading: \nhttp://repo1.maven.org/maven2/edu/concurrent/1.0/concurrent-1.0.pom\n\nDownloading: \nhttp://repo1.maven.org/maven2/asiainfo/ny/nysecurity/1.0/nysecurity-1.0.pom\n\nDownloading: \nhttp://repo1.maven.org/maven2/cmcc/trustwork/1.4/trustwork-1.4.pom\n\nDownloading: \nhttp://repo1.maven.org/maven2/cmcc/pwdSvr/1.4/pwdSvr-1.4.pom\n\nDownloading: \nhttp://repo1.maven.org/maven2/poi/poi/2.5.1-FINAL/poi-2.5.1-FINAL.pom\n\n[INFO] [dependency:tree]\n\n[INFO] asiainfo.cboss:cboss:war:SNAPSHOT\n\n[INFO] +- asiainfo.cboss:cboss-common:jar:SNAPSHOT:compile\n\n[INFO] |  - org.apache.velocity:velocity:jar:1.5:compile\n\n[INFO] |     - (commons-collections:commons-collections:jar:3.1:compile - omitted for conflict with 2.1)\n\n[INFO] +- commons-collections:commons-collections:jar:3.1:runtime (scope not updated to compile)\n\n[INFO] +- commons-dbcp:commons-dbcp:jar:1.2.1:compile\n\n[INFO] |  - (commons-collections:commons-collections:jar:2.1:compile - omitted for conflict with 3.1)\n\n[INFO] +- commons-beanutils:commons-beanutils:jar:1.6:compile\n\n[INFO] |  - (commons-collections:commons-collections:jar:2.0:compile - omitted for conflict with 3.1)\n\n[INFO] - commons-pool:commons-pool:jar:1.2:compile\n\n[INFO]    - (commons-collections:commons-collections:jar:2.1:compile - omitted for conflict with 3.1)\n\n[INFO] ------------------------------------------------------------------------\n\n[INFO] BUILD SUCCESSFUL\n\n[INFO] ------------------------------------------------------------------------\n\n[INFO] Total time: 33 seconds\n\n[INFO] Finished at: Wed Sep 09 13:18:59 CST 2009\n\n[INFO] Final Memory: 13M/63M\n\n[b]问题补充：[/b]\n\n的确是按最短路径实现的，我在自己的pom.xml中指定了使用版本，maven就是使用这个版本的。 上午是因为忘记做clean了，所以原来已经拷贝到WEB-INF/lib目录的库没有被清理这样commons-collections－2.1.jar还是会存在， 让我误认为不能生效。", "Tag": "算法分析"}
{"Answer": "运筹学的内容吗？应该是可以的，这个应该是多元n次优化问题一般是lingo的强项，不过matlab也可以，你需要列出相应的约束，然后找一个前进的方向，定义一个终止条件。", "Konwledge_Point": "最短路径", "Question": "MATLAB求解二维平面的两点间路径规划\n有一个问题:给定加速度限制，速度限制(起点速度方向，终点速度方向)，起点(x1，y1)，终点(x2，y2)，这两点间的连线为一个n次多项式函数，可不可以利用MATLAB求出所用时间最短时，该路径函数各次项前的系数", "Tag": "算法分析"}
{"Answer": "\nint m, n, p, q, k; \nint min = 99999;\nint a[100][100];//1表示空,2表示障碍 \nint v[100][100];//0表示未访问,1表示访问 \n//迷宫问题\nvoid dfs(int x, int y, int step) \n{\n\t//将具体的移动方向转化为数据,4个方向\n\tint dx[4] = {1, 0, -1, 0};\n\tint dy[4] = {0, -1, 0, 1};\n\t\n\t//判断终点\n\tif(x == p && y == q)\n\t{\n\t\tif(step < min)\n\t\t{\n\t\t\tmin = step;\n\t\t}\n\t\treturn;\n\t}\n\t\n\t//开始进行移动\n\tfor(k = 0; k <= 3; k++)\n\t{\n\t\tint tx,ty;\n\t\t//现在的坐标位置\n\t\ttx = x + dx[k];\n\t\tty = y + dy[k];\n\t\tif(a[tx][ty] == 1 && v[tx][ty] == 0)\n\t\t{\n\t\t\tv[tx][ty] = 1;\n\t\t\tdfs(tx,ty,step+1);\n\t\t\tv[tx][ty] = 0;\n\t\t}\n\t}\n\t\n\treturn;\n}\n\nmain()\n{\n\t//为地图赋值\n\tint i, j;\n\tscanf(\"%d%d\",&m,&n);\n\t\n\tfor(i = 1; i <= m; i++)\n\t{\n\t\tfor(j = 1; j <= n; j++)\n\t\t{\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\t\n\tint startx,starty;\n\t//确定起点和终点\n\tscanf(\"%d%d%d%d\",&startx, &starty,&p,&q);\n\t//将起点设置已访问\n\ta[startx][starty] = 1;\n\tdfs(startx,starty,0);\n\t\n\tprintf(\"%d\",min);\n\t\n\treturn 0;\n}\n\n \n参考C语言实现，找出迷宫起点到终点的最短路径，最详细的DFS教程_s_meng_的博客-CSDN博客", "Konwledge_Point": "最短路径", "Question": "求各位大佬看一下c语言迷宫问题[急]\n项目要求：1、找到一条或多条从迷宫起点到迷宫终点的路径，并将路径输出；\n2、找到一条最短的路径，并将路径输出；\n3、以尽可能短的时间，找到路径，并将路径输出；\n4、解决方案能适用于任意同形式的迷宫。 ", "Tag": "算法分析"}
{"Answer": "以下是代码\r\n```\r\nimport random as rd\r\n\r\nminimum=999999  #初始化minimum为一个很大的值 保证任何结果都小于该值\r\nresult =\"\"  #全局最小路径结果\r\n\r\npathLen=[[0,38,42,27,41,24],[38,0,8,21,13,22],[42,8,0,26,10,29],[27,21,26,0,18,5],[41,13,10,18,0,25],[24,22,29,5,25,0]] #各个城市的距离表\r\n\r\nclass path():\r\n    def __init__(self,p1,p2,n=5): #类型初始化,p1为交叉概率,p2为变异概率,n为城市数 本例为5（北京先后到5个城市）\r\n        self.path=[i for i in range(n)]\r\n        self.p1=p1\r\n        self.p2=p2\r\n        self.n=n\r\n    def init(self): #用于第一代的基因生成\r\n        for i in range(self.n):\r\n            self.path[i]=rd.randint(0,self.n)\r\n        \r\n    def exchange(self): #交叉\r\n        if rd.randint(1,100)>(100-self.p1):   #有概率交叉\r\n            while 1:\r\n                position1=rd.randint(0,self.n-1)   #随机生成交叉位置\r\n                position2=rd.randint(0,self.n-1)\r\n                if position1 != position2:  #判断交叉位置非同一位置\r\n                    self.path[position1],self.path[position2]=self.path[position2],self.path[position1]\r\n                    break\r\n                else:\r\n                    continue\r\n    def change(self):\r\n        if rd.randint(1,100)>(100-self.p2):     #有概率变异\r\n            self.path[rd.randint(0,self.n-1)]=rd.randint(0,self.n)\r\n    def calculate(self):    #计算路径总长度\r\n        count=pathLen[1][self.path[0]]   #北京至第一个城市的路程\r\n        for i in range(self.n-1):\r\n            count+=pathLen[self.path[i]][self.path[i+1]]   #中途各个城市间的路程\r\n        count+=pathLen[self.path[-1]][1]  #最后一个城市到北京的路程\r\n        return count\r\n    def parity(self):   #校验是否为每个城市去一次且不包含北京\r\n        count=0\r\n        path=self.path.copy()\r\n        path.sort()\r\n        for i in range(len(path)-1):\r\n            if path[i]==path[i+1]:\r\n                count+=1\r\n            if path[i]==1:\r\n                count+=1\r\n        if count==0:\r\n            return 1\r\n        else:\r\n            return 0\r\n\r\n    def nxt(self,other): #产生子代\r\n        p=path(self.p1,self.p2)\r\n        for i in range(self.n):\r\n            if rd.randint(1,100)>50:\r\n                p.path[i]=self.path[i]\r\n            else:\r\n                p.path[i]=other.path[i]\r\n        return p\r\n        \r\n\r\ndef generate(n,p1,p2):  #生成种群 n为规模 p1为交叉概率 p2为变异概率\r\n    t=[]\r\n    for i in range(n):\r\n        father=path(p1,p2)\r\n        father.init()\r\n        t.append(father)\r\n    return t\r\n\r\n\r\ndef allChange(t):    #进行繁殖、变异、交换、淘汰\r\n    global minimum\r\n    global result\r\n    l=len(t)\r\n    print(\"本轮父代个数为:\",l)\r\n    if l>100:   #如果父代个数大于100则开始父代淘汰机制\r\n        path=[]\r\n        for i in t:\r\n            path.append(i.calculate())   #计算各个个体的路径长度\r\n        path.sort()  #路径长度排序\r\n        tt=[]\r\n        j=0\r\n        while len(tt)<100:\r\n            for i in t:\r\n                if i.calculate()==path[j]:\r\n                    tt.append(i)\r\n            j+=1\r\n        t=tt\r\n    l=len(t)\r\n    for i in range(l):   \r\n        for j in range(l-1-i):\r\n            child=t[i].nxt(t[j]) #两两交配产生子代\r\n            child.exchange()     #子代交换\r\n            child.change()      #子代变异\r\n            t.append(child)          #向种群添加子代\r\n    count=0\r\n    for i in range(len(t)):  #去除不符合的成员\r\n        if t[i-count].parity()==0: #杀死不符合要求的子代 （每个城市去一次且不包含北京）\r\n            del(t[i-count])\r\n            count+=1\r\n    print(\"本轮产生子代后总数:\",len(t))\r\n    result1=t[-1].path\r\n    mini=t[-1].calculate()\r\n    for i in range(len(t)-1):   #获得各个个体的路程长度\r\n        tt=t[i].calculate()     \r\n        if mini>tt:             #比较是否是新的最小路径\r\n            mini=tt\r\n            result1=t[i].path\r\n    print(\"本轮最小路径长度:\",mini)\r\n    print(\"本轮最小路径结果:\",result1)\r\n    if mini<minimum:\r\n        minimum=mini\r\n        result=result1\r\n            \r\n\r\n\r\n\r\nzq=generate(30,10,10) #generate(30,10,10)表示 初始种群30，交换概率10%，变异概率10%\r\nfor i in range(6):  #range(n) 标识迭代n代\r\n    allChange(zq)\r\nprint(\"最后最小路径长度为:\",minimum)\r\nprint(\"最后最小路径为:\",result)\r\n\r\n\r\n```\r\n运行结果\r\n![图片说明](https://img-ask.csdn.net/upload/202006/09/1591697988_503086.png)", "Konwledge_Point": "最短路径", "Question": "旅行商路径优化问题的遗传算法程序\n编制旅行商路径优化问题的遗传算法程序，并计算一个实例。(以不超过10个城市为例,给出初始种群规模、交叉概率、变异概率在不同设置情况下的总结分析)。\n\n要求：遗传算法路径结果图，适应函数自选（标明），附上全部代码。\n\n旅行商问题：\n\n\n\n从北京（B）乘飞机到威海(W)、贵阳(G)、上海(S)、昆明(K)、拉萨(L)\n\n五城市做旅游，每城市恰去一次再回北京，应如何安排旅游线，使旅程最短？各城市之间的航线距离如表7。\n\n表7 六城市间的距离\n\n   L    B    W    G    S    K\n\nL 0    38  42   27   41  24\n\nB 38  0    8    21   13   22\n\nW42  8    0    26   10   29\n\nG 27  21  26   0    18    5\n\nS 41  13  10  18    0     25\n\nK 24  22  29   5    25    0", "Tag": "算法分析"}
{"Answer": "这种必然要递归否则回溯会非常麻烦尤其有环路的时候容易造成死循环", "Konwledge_Point": "最短路径", "Question": "走一堆二维平面的点，如何实现最小路径？\n遇到的现象和发生背景，请写出第一个错误信息\n\n\n走一堆二维平面的点，如何实现最小路径？\n\n\n用代码块功能插入代码，请勿粘贴截图。 不用代码块回答率下降 50%\n\n\n  public static List<\nint\n> nextpoint(List currentlist, \nint\n currentpoint)\n//当前list,当前点\n\n        {\n            double  distence;\n            double minidistence;\n            \nfor\n (\nint\n i = \n0\n; i < currentlist.Count; i++)\n//去掉第一个点的新list\n\n            {\n                distence = Math.\nPow((\ncurrentlist\n[\ni\n].Track.Start_X - \ncurrentlist\n[\ncurrentpoint\n].Track.Start_X)\n, \n2.0\n) + Math.\nPow((\ncurrentlist\n[\ni\n].Track.Start_Y - \ncurrentlist\n[\ncurrentpoint\n].Track.Start_Y)\n, \n2.0\n);\n                Distencelist.\nAdd(\ndistence\n)\n;\n            }\n            minidistence = Distencelist.\nMin()\n;\n//获取list中的最小值\n\n            List<\nint\n> minilist = \nnew\n List<\nint\n>\n()\n;\n            \nint\n minIndex = Distencelist.\nIndexOf(\nminidistence\n)\n;\n//获取最小值的索引集合\n\n            \nfor\n (\nint\n i = minIndex - \n1\n; i < Distencelist.Count; i++)\n            {\n                \nif\n (Distencelist\n[\ni\n]\n == \nminIndex)\n                {\n                    minilist.\nAdd(\ni\n)\n;\n                }\n            }\n             List<\nint\n> index = \nnew\n List<\nint\n>\n()\n;\n             \nfor\n (\nint\n i = \n0\n; i < minilist.Count; i++)\n             {\n                 index.\nAdd(\ncurrentlist\n[\nminilist\n[\ni\n]].\noriginalIndex\n)\n;\n             }\n            return index;\n//原始list的顺序\n\n        }\n\n\n\n运行结果及详细报错内容\n\n\n我的解答思路和尝试过的方法，不写自己思路的，回答率下降 60%\n\n\n1、先定一个起始点A;\n2、计算出起始点A与其他点的距离，比较出距离最短的那个点B；\n3、再用点B与其他点（除点A）比较找出距离最短的点C;但是如果存在D，F点BF，BD距离和BC距离一样如何确定下一个点？\n4、循环操作直到最后一个点，无需比较，直接找到还没有排序的点，追加在最后即可。\n5、然后将所有点循环定为起始点，将每一种点排序组合都加到数组A中，并将这种排序组合所有点连线计算出长度加到数组B中；\n6、找出数组B中值最小的下标，到数组A中找对应的点排列组合，这个排序结果就是最短路线点的排序。\n\n\n我想要达到的结果，如果你需要快速回答，请尝试 “付费悬赏”", "Tag": "算法分析"}
{"Answer": "您好，想法非常好，也非常符合常识，但是我认为核心问题集中在以下几点 ：第一，‘从初始节点计算与其他节点的距离，使每次选取下一落脚点距离当前节点最近’    能不能更快逼近最优解？  能的。第二，是否有这个必要？我认为核心还是在于您不确定以这样的方式最终求得路径是否最短。也就是~~例如有【A1，A2。。。。。。。AN】 N个节点，取任一节点为起始节点，计算出相邻节点最短的一条路径就是我们求的路径？。。。这个我也不能肯定哈哈哈，常识提醒我是这样的，严谨告诉我最好在少量节点情况下验证一两次。第三，可行性。假设有n个节点，起始节点计算量为n-1次距离函数~~~~  =》倒数第二个节点计算量为1次函数。即总计算量为(1+n-1)(n-1)/2 次距离函数. 随着节点数量的增大，计算量也会逐渐增大，那么会不会造成内存不够？即第一次计算起始点与剩余所有点的距离取最小值就G了 ？如果节点在20~30个的话应该没太大的问题，另外时间上n(n-1)/2次距离计算是否超出预期？如果时间过长，那么就需要考虑如何简化距离函数，提高单次距离计算的效率。\n\n有用请采纳，感谢", "Konwledge_Point": "最短路径", "Question": "遗传算法种群初始化的优化必要性\n假设用遗传算法去做一个类旅行商问题，从节点0开始，用最短的路径遍历所有的其他节点。我们假设存在一个具体的小示例如下：\n\n\n\n\n这时候，种群初始化有两种方案：\n\n\n（正常操作）随机节点1234的排列，如1234，4231。\n\n\n\n\n（设想的操作）根据当前出发点0，根据当前出发点与其他节点的距离 取倒数并做归一化。实现\n距离越近，越大概率取为染色体路径的下一个节点\n。选取后，再根据最新的节点路径做新的计算与取值。从直觉上，这样可以更快逼近最优解。但是是否有这个必要\n\n\n想问下这种操作的可行性和必要性，在节点数量大约20个、30个的情况下，会对后续的操作产生什么影响，如果是好影响，是什么。如果有坏影响的话，会有解决方法吗？", "Tag": "算法分析"}
{"Answer": "这里有一个\r\n[url]http://blog.csdn.net/java2000_net/archive/2008/05/01/2357485.aspx[/url]", "Konwledge_Point": "最短路径", "Question": "谁有A*算法的DEMO\n我最近在做一个搞怪碰碰球的游戏，可能大家以前也玩过，就是在某一直线上如果有5个同色的球相连就消球子得分否则就自动生成3个随机颜色的球子。但选择位置的时候你所选中的球子会判断你选择的位置是否有效（在关闭链表中，有障碍物等）如果有效会生成一条最短的路径自动移动过去，否则不动。\n\n\n\n这个项目着实让我郁闷了好久，到现在还是没有思路。求哪位大虾能指点迷津，最好是能有源代码，因为本人脑子比较笨不太擅长理解那种文字讲述性的文章。感激不尽！", "Tag": "算法分析"}
{"Answer": "你可以将画布作为绘图函数的第一个参数，如：\nnx.draw(G, pos, with_labels=True, alpha=0.5, canvas=canvas)\n\n\n或者，可以使用 FigureCanvasTkAgg 将画布绑定到 tkinter 窗口中，例如：\nfrom matplotlib.backends.backend_tkagg import FigureCanvasTkAgg\n\nfig = plt.figure(figsize=(5, 5))\ncanvas = FigureCanvasTkAgg(fig, master=window2)\ncanvas.get_tk_widget().grid(row=8, column=10)\nnx.draw(G, pos, with_labels=True, alpha=0.5, fig=fig)\n\n\n在这种情况下，应该使用 fig 而不是 canvas 作为绘图函数的第一个参数。\n请注意，如果使用 FigureCanvasTkAgg，则需要导入 matplotlib.pyplot 模块，并使用 plt.figure 创建一个新图表。", "Konwledge_Point": "最短路径", "Question": "怎么让我画的无向图显示在canvas画布上\n\ndef main3():\n          canvas = tkinter.Canvas(window2, \nwidth\n=50, \nheight\n=50)\n          canvas.grid(\nrow\n=8,column=10)\n\n\n# 创建一个无向图\n\n          G = nx.Graph()\n          G.add_edge(\n'A'\n, \n'B'\n, \nweight\n=1)\n          G.add_edge(\n'A'\n, \n'D'\n, \nweight\n=7)\n          G.add_edge(\n'B'\n, \n'E'\n, \nweight\n=4)\n          G.add_edge(\n'D'\n, \n'E'\n, \nweight\n=3)\n          G.add_edge(\n'F'\n, \n'G'\n, \nweight\n=4)\n          G.add_edge(\n'F'\n, \n'E'\n, \nweight\n=5)\n          G.add_edge(\n'G'\n, \n'K'\n, \nweight\n=9)\n\n\n# 绘制图像\n\n          \nsource\n=nameEntry3.get()\n          \ntarget\n=nameEntry4.get()\n \n          minWPath_v1_v5 = nx.dijkstra_path(G, source, target)  # 顶点 0 到 顶点 3 的最短加权路径\n                \n\n# 两个指定顶点之间的最短加权路径的长度\n\n          \n          pos = nx.spring_layout(G)  # 使用 FR 算法排列节点\n          nx.draw(G, pos, \nwith_labels\n=\nTrue\n, \nalpha\n=0.5,on=canvas)\n          labels = nx.get_edge_attributes(G, \n'weight'\n)\n          nx.draw_networkx_edge_labels(G, pos, \nedge_labels\n=labels)\n          edgeList = []\n          \nfor\n i \nin\n range(len(minWPath_v1_v5)-1):\n                  edgeList.append((minWPath_v1_v5[i], minWPath_v1_v5[i+1]))\n                  nx.draw_networkx_edges(G, pos, \nedgelist\n=edgeList, \nedge_color\n=\n'm'\n, \nwidth\n=4,on=canvas)\n\n            \n          \n      \n\n\n\n怎么让我画的无向图显示在canvas画布上", "Tag": "算法分析"}
{"Answer": "可以参考这些资源，没有积分我可以帮你下载：关键路径问题：设计程序求工程关键活动-C文档类资源-CSDN下载\n数据结构综合课设关键路径问题.docx-C/C++文档类资源-CSDN下载", "Konwledge_Point": "最短路径", "Question": "帮帮忙吧，哥哥们！！！！\n最短工期的求解\n\n工程最短工期的求解\n\n基本要求：\n\n基本要求：\n\n设计一个程序，求出完成整项工程至少需要多少时间，以及整项工程中的关键活动。\n\n(1)通过菜单选项从键盘输入一个描述工程的AOE网（事件不少于10个），或者，从外部txt文件输入\n\nAOE网。\n\n(2)首先判断AOE网代表的施工图是否能够顺利进行。如果不能顺利进行，能通过菜单选项重新输入。\n\n(3)若该工程能顺利进行，输出关键路径和关键活动。\n\n(4)设计实现菜单方式的交互界面，界面友好，可反复操作。", "Tag": "算法分析"}
{"Answer": "哈密顿回路如果对你有帮助，望采纳", "Konwledge_Point": "最短路径", "Question": "历遍所有点再回到原点，属于什么问题\n手上只有点与点之间的距离，比如1到4、7、8,然后2到3、5、6,……之间的距离，每个点都能到达其中几个点且只知道距离不知道坐标。\n没有要求一定要走完每一条路，只要走完所有点回到原点就行，然后找最短的一条路径。\n我看了好像不属于tsp问题，因为不知道坐标\n也不属于邮递员问题，因为没必要走完每一条线。\n那么这种问题属于什么问题呢，我都不知道该怎么去查资料，或者可以用什么方法呢\n由于刚接触，可以不用给太详细（我也看不懂），给些查资料的方向吧，\n手头的数据是要做从至表然后整理成对称矩阵输入matlab吗？还是说其他什么矩阵", "Tag": "算法分析"}
{"Answer": "该程序似乎旨在解决迷宫问题并打印它找到的路径。该程序在搜索解决方案时使用堆栈来存储路径的位置和方向。栈在迷宫的起点被初始化，程序继续寻找解，直到栈为空。\n有几个可能的原因会导致程序在一段时间后自行停止。一种可能是程序遇到无限循环。这可能是由程序逻辑错误引起的，例如缺少 break 语句或条件始终为真。\n另一种可能性是程序内存不足。该程序使用一个结构数组来存储路径，如果该数组不够大以容纳所有路径，则可能导致程序崩溃或意外停止。\n如果没有关于程序的具体行为和输入数据的更多信息，就很难查明问题的确切原因。我建议检查代码并检查可能导致程序自行停止的任何潜在问题或错误。", "Konwledge_Point": "最短路径", "Question": "C语言数据结构链栈迷宫问题\n\n\n为什么我在输入完出口后，过一会程序就自己停止了？\n\n下面是迷宫求解函数，问题应该就在这\n\nvoid \nPath(\nint\n \n**\nmaze\n,\nint\n \nm\n,\nint\n \nn\n)\n    \n//迷宫求解 \n\n{\n    Direct direct\n[\n4\n]\n;    \n//定义东，南，西，北四个方向 \n\n    direct\n[\n0\n]\n.x = \n0\n,direct\n[\n0\n]\n.y = \n1\n;    \n//向东走 \n\n    direct\n[\n1\n]\n.x = \n1\n,direct\n[\n1\n]\n.y = \n0\n;    \n//向南走 \n\n    direct\n[\n2\n]\n.x = \n0\n,direct\n[\n2\n]\n.y = -\n1\n;    \n//向西走 \n\n    direct\n[\n3\n]\n.x = -\n1\n,direct\n[\n3\n]\n.y = \n0\n;    \n//向北走\n\n    LNode *stack;\n    Temp T\n[MAX]\n,temp;\n    \nint\n x,y,X,Y,d,count = \n0\n,length,minlength;\n    \nbool\n find = \nfalse\n;\n    *(*(maze+\n1\n)+\n1\n) = -\n1\n;\n    temp.x = \n1\n,temp.y = \n1\n,temp.d = -\n1\n;\n    \nInit(\nstack\n)\n;\n    \nPush(\nstack\n,\ntemp\n)\n;\n    \nwhile\n(!is\nEmpty(\nstack\n)\n)\n    {\n        get\nPop(\nstack\n,&\ntemp\n)\n;\n        x = temp.x,y = temp.y,d = temp.d + \n1\n;\n        \nif\n(x\n == \nm&&y\n == \nn)\n        {\n            length = \n0\n;\n            printf(\n\"迷宫第%d条路径如下：\"\n,++count);\n            \nwhile\n(!is\nEmpty(\nstack\n)\n){\n                \nPop(\nstack\n,&\ntemp\n)\n;\n                T\n[\nlength\n++\n]\n = temp;\n            }\n            \nif\n(length < minlength)\n            {\n                minlength = length;\n            }\n            \nfor\n(\nint\n i = \n1\n;length > \n0\n;i++)\n            {\n                printf(\n\"[%d,%d],%d \"\n,T\n[--\nlength\n]\n.x,T\n[\nlength\n]\n.y,T\n[\nlength\n]\n.d);\n                \nPush(\nstack\n,T[\nlength\n])\n;\n                \nif\n(i % \n5\n == \n0\n)\n                printf(\n\"\\n\"\n);\n            }\n            printf(\n\"\\n\"\n);\n            \nPop(\nstack\n,&\ntemp\n)\n;\n            *(*(maze+temp.x)+temp.y) = \n0\n;\n        }\n        \nelse\n\n        {\n            \nPop(\nstack\n,&\ntemp\n)\n;\n            *(*(maze+temp.x)+temp.y) = \n0\n;\n        }\n        \nwhile\n(d<\n4\n)\n        {\n            X = x + direct\n[\nd\n]\n.x;\n            Y = y + direct\n[\nd\n]\n.y;\n            \nif\n(*(*(maze+X)+Y)\n == \n0\n)\n            {\n                temp.x = X,temp.y = Y,temp.d = d;\n                \nPush(\nstack\n,\ntemp\n)\n;\n                x = X,y = Y,*(*(maze+X)+Y) = -\n1\n;\n                d = \n0\n;\n            }\n            \nelse\n\n            {\n                d++;\n            }\n        }\n    }\n    printf(\n\"最短的一条路径是路径是第%d条路径\\n\"\n,minlength);\n    \nif\n(find\n == \nfalse\n)\n    printf(\n\"该迷宫没有可以到达出口的路径！\\n\"\n);\n}\n\n", "Tag": "算法分析"}
{"Answer": "concat 可以一次性合并多个 dataFrame\nfilenames=os.listdir(path)\ndf_list = []\nfor filename in filenames:\n    df_list.append(pd.read_excel(path + '\\' + filename))\nresult_df = pd.concat(df_list)\n", "Konwledge_Point": "最短路径", "Question": "Python合并表格时间太长怎么解决?\n求助各位，我用的是pycharm教育版，合并三个表，累计行数在四万行左右，以下是我写的代码，运行时间最短的一次也是一百六十多秒，并且运行一次一次比一次久，最后一次将近四百秒了，求帮忙看下代码写的有什么问题，或者可以怎么改，谢谢，好人一生平安\n\n\nimport\n os\n\nimport\n pandas \nas\n pd\n\nimport\n time\nstart=time.time()\npath=\nr'D:\\我的工作文件夹\\A 可视化\\sales_order'\n\nempty=pd.DataFrame()\ny=os.listdir(path)\n\nfor\n i \nin\n y:\n    df=pd.read_excel(path+\n'\\%s'\n%i)\n    \n#连接路径和表名\n\n    empty=pd.concat([empty,df])\nempty.to_excel(excel_writer = \nr'D:\\我的工作文件夹\\A 可视化\\sales_order.xlsx'\n,sheet_name=\n'order'\n,index=\nFalse\n)\nend=time.time()\n\nprint\n(\n'代码运行时间为:%.2f 秒'\n%\nround\n(end-start,\n2\n)) \n\n", "Tag": "算法分析"}
{"Answer": "类似于“有限制条件的动态规划旅行商问题”的方法，我们需要定义一个状态 (S, i, p)，其中S是已访问过的顶点集合（包括取件点和送货点），i是当前所在的顶点，p表示当前手中的包裹来源（取件点集合）。转移方程\n```dp[S, i, p] = min(dp[S, i, p], dp[S-{i}, j, p-{i}] + dist(j, i))\n```j是S中的一个顶点，且满足以下条件：若i是一个送货点，则j必须是与i对应的取件点之一。在递推的过程中，需要保证p始终包含了当前所在的送货点所需的包裹来源初。始化状态和边界条件。dp[S, i, p]初始化为无穷大（表示不可达）。边界条件为：当S只包含一个顶点（即某个取件点）时，dp[S, i, p]为0，其中i表示该取件点。\n最后，遍历所有状态并更新动态规划数组，通过回溯法找到最短路径。送货点数量不会超过250个，可以试试看这个。", "Konwledge_Point": "最短路径", "Question": "TSP旅行商问题，多个取件点，可返回，不一定回原点算法\n我是一个送货员，我想计算出一日工作的最短路程。\n具体：\n\n\n公司有多个取件点，而我每天早上可以随意选从哪一个取件点开始配送\n每一个配送点要送的包裹都有对应的单个或多个取件点（可能一个送货点有来自取件点A和B甚至更多不同地方的包裹要取），要保证去配送的时候手里有对应的包裹（就是之前去过对应包裹的取件点）\n可多次去一个送货点\n每天不用回到初始点，只要回到任意取件点就行\n包裹不限重量，默认去一个取件点就把所有包裹都带上\n每日的送货点不会超过250个\n\n\n背景：之前做了一个GIS系统，需要加上这个送货员功能，目前可以计算两点之间的最短路线，在这里我用的是C++\n个人初步搜索：我浏览了网络上的TSP旅行商问题，也大致了解了解法（但不明白原理所以不知道怎么自己修改）。在想是忽略取货问题先找出所有点的最短路径，然后以那个基础上去改进路线比较好，还是这样子算走远了。如果可以的话，那我该怎么优化路径我也不知道。\n\n\n想问一下在这个条件下该怎么算会更快，谢谢大家", "Tag": "算法分析"}
{"Answer": "http://www.cnblogs.com/fenglianchen/p/7674766.html", "Konwledge_Point": "最短路径", "Question": "求大神，求大咖，不会安装啊\n请问如何安装 sql server 2008？？在win10环境下的", "Tag": "算法分析"}
