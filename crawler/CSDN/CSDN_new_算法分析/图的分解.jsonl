{"Answer": "String str = \"D:\\123.jsp\";\r\n使用正则时\"\\\"会转义1，建议\r\n  1.先把“\\”替换成\"/\",然后str.split(\"/\");\r\n  2.或者添加一个\"\\\",然后str.split(\"\\\\\\\\\");", "Konwledge_Point": "图的分解", "Question": "字符串分解问题\n现在我的问题是做一个图上传的功能点,但是取得文件路径的时候我想对路径进行解析,问题出在这,比如说:文件路径是D:\\123.jsp;我想取到123.jsp,我用的split(\"\\\");去分解,但是不行,我想问一下大家,为什么不行,怎么去分解他.\n\n还行有哪位高手做过图片上传,把你的代码贴出来分享一下,谢谢了\n\n[b]问题补充：[/b]\n\nredish这位哥们,你运行了吗,这样肯定是不行的\n\nString str=\"D:/123.jsp\";\n\nstr.split(\"/\");  \n\n\n\n[b]问题补充：[/b]\n\n我是取的文件夹的路径,我打出之后是[b][size=large][color=red]D:\\123.jsp[/color][/size][/b],而不是D:/123.jsp\n\n所以大家再帮我看看\n\nString str=\"D:\\123.jsp\";\n\nstr.split(\"\\\"); \n\n[b]问题补充：[/b]\n\n哥们儿们,你们那些还是不行,String str=request.getParameter(\"name\");而request.getParameter(\"name\")的值是[size=medium][color=red]D:\\123.jsp[/color][/size],我试过了,用jltest这位老兄的还是不行.希望大家继续指教 \n\n[b]问题补充：[/b]\n\ncprogrammer 这个哥们的也不行,String a = \"D:\\123.jsp\";\n\nString[] b = a.split(\"\\\");     你就住eclipse里面粘贴一下就会有错误\n\n[b]问题补充：[/b]\n\ngeniuslph老兄,能不能给一个例子,我一做就出错", "Tag": "算法分析"}
{"Answer": "一般都是新开一页，然后用换页参考来连接，Visio里面有个“换页参考”的图标Off-page reference，专门用来连接多页流程图的，可以试用一下", "Konwledge_Point": "图的分解", "Question": "Visio 画流程图，一页画不完了，该怎么处理得更好？\n一个模块。流程相对较多，这样竖着画下来，画到底部了，但还没有画完，此时该怎么做？是新建一页，还是画右边，中间出现的断层该怎么处理？页和页之间用什么符号链接起来？希望大家能解答一下，或者给我一些参考资料", "Tag": "算法分析"}
{"Answer": "\nint main()\n{\n    int a,b,c,d,e;           \n\n    printf(\"please input a number\");    \n    scanf(\"%d\",&a);                 \n    b=a/1000;   \n    c=(a-b*1000)/100;\n    d=(a-b*1000-c*100)/10;\n    e=(a-b*1000-c*100-d*10)%10;\n    printf(\"%d=%d+%d+%d+%d\",a,b*1000,c*100,d*10,e);\n\n    return 0;\n}\n\n", "Konwledge_Point": "图的分解", "Question": "如图，咋解各位，大数分解问题\n要求是给定一个四位整数，对该数进行分解。\n 如:输入:6321\n 输出:6321=6000+300+20+1;\n 输入:6000\n 输出:\n 6000=6000+0+0+0", "Tag": "算法分析"}
{"Answer": "已解决，看源码一下就知道了.......", "Konwledge_Point": "图的分解", "Question": "EMD分解 IMF图字体大小\n使用python PYEMD模块生成的分量图字体太小\n\n\n运行结果及报错内容\n\n\n\n\n我看它作图是基于plt来的，但是不知道怎么调字体", "Tag": "算法分析"}
{"Answer": "仔细看了下，好像没有错误。。。。 。", "Konwledge_Point": "图的分解", "Question": "这分解因式的代码有没有错误的地方？\n这分解因式的代码有不对的吗？", "Tag": "算法分析"}
{"Answer": "原因找到了，我原先是在y上正下负的坐标系里计算的，而实际图像处理中y坐标是上负下正的，我刚好算反了。", "Konwledge_Point": "图的分解", "Question": "仿射变换之旋转矩阵推导\nA点绕原点顺时针旋转theta角度到B点，我的推导如下图\n\n为什么跟别人推导出来的不一样呢？哪里错了，实在想不通，求解，不弄明白今晚睡不着啊", "Tag": "算法分析"}
{"Answer": "参考GPT和自己的思路：这个问题涉及到图的分割问题，一般可以使用基于贪心算法的启发式方法来求解。具体来讲，可以首先随机选择k个起始节点，然后把其余节点分配给这k个起始节点进行划分，不断迭代优化，直到满足要求为止。具体算法的时间复杂度是O(kn2)，其中n是节点数。同时，还可以使用图论中的最小割算法来解决该问题，但由于最小割算法涉及计算复杂度较大，不太适合应用于大型的图分割问题。", "Konwledge_Point": "图的分解", "Question": "关于图论中分解图的方法\n对于一个连通图，有没有什么方法能将图分割成k个连通子图？并且这些子图的节点数量尽量满足在一个差值范围内。", "Tag": "算法分析"}
{"Answer": "该回答通过自己思路及引用到GPTᴼᴾᴱᴺᴬᴵ搜索,得到内容具体如下：根据您提供的截图，您应该是想要使用 Matlab 中的 EMD（经验模态分解）算法来分解实际测得的震动数据，并绘制分解后的图像。\n下面是一些关于如何使用 EMD 算法分解数据的基本步骤：\n1、 准备数据\n首先，您需要将测得的震动数据保存在一个文本文件或 Matlab 中的变量中，以便后续分析。假设您将数据保存在一个名为 vibration_data.txt 的文本文件中，每一行代表一个数据点，数据点之间用空格或逗号分隔。\n2、 加载数据\n使用 Matlab 的 load 函数或 importdata 函数来导入数据文件，并将数据保存在一个 Matlab 数组中。例如，可以使用以下代码将数据加载到名为 data 的数组中：\ndata = importdata('vibration_data.txt');\n\n3、 运行 EMD 算法\n接下来，您可以使用 EMD 算法对数据进行分解。在您提供的截图中，似乎是使用了一个叫做 emd 的函数来进行分解。根据您提供的代码和截图，我猜测这个 emd 函数应该是一个 Matlab 函数文件，包含了 EMD 算法的实现。\n要使用该函数进行分解，您需要将数据作为输入参数传递给该函数，例如：\nIMFs = emd(data);\n\n该代码将返回一个名为 IMFs 的 Matlab 数组，其中包含了分解后的信号成分。该数组的每一行代表一个瞬态分量（Intrinsic Mode Function，IMF）。第一行是最高频率的 IMFs，最后一行是最低频率的 IMFs。\n4、 绘制分解后的图像\n最后，您可以使用 Matlab 的绘图函数（例如 plot、subplot、imagesc 等）来绘制分解后的信号成分。例如，以下代码将绘制第 1、3、5 行 IMFs 的图像：\nsubplot(3,1,1);\nplot(IMFs(1,:));\nsubplot(3,1,2);\nplot(IMFs(3,:));\nsubplot(3,1,3);\nplot(IMFs(5,:));\n\n您可以根据需要调整这些代码来绘制您感兴趣的 IMFs 图像。\n需要注意的是，EMD 算法是一种迭代算法，其结果可能会因为初始条件和参数的不同而有所不同。因此，您可能需要根据具体情况来调整算法的参数和初始条件，以获得最优的分解结果。\n\n如果以上回答对您有所帮助，点击一下采纳该答案～谢谢", "Konwledge_Point": "图的分解", "Question": "论文里关于matlab emd分解的代码，需要个朋友指导一下怎么带入数据最后输出分解图\n\n\n\n\n\n\n不太了解每个.m文件分别如何运行，每一个参数怎么替换进去，想用这个代码处理实际测得的震动数据。", "Tag": "算法分析"}
{"Answer": "分离固定数据及周期采集数据\r\n1）仪器信息表（字典表）：存放仪器的基本信息，设备ID作为主键\r\n2）数据采集表：设备ID、采集时间、状况参数\r\n数据采集比较密集的话，建议考虑按采集时间创建子表（表名称上加上月份等标记）", "Konwledge_Point": "图的分解", "Question": "MSSQL数据表如何分解合理\n用的是MSSql。 \n\n\n\n一张数据表是这样的，仪器有几十万台，间隔一段时间采集一次数据，该怎么建表合理", "Tag": "算法分析"}
{"Answer": "```\r\n[output,res]=emd(x);\r\nemd(x,'Interpolation','pchip');          % 此时输出左图\r\n```\r\n你的这句重复啦，明显的BUG！，emd默认‘Interpolation’是‘spline’，你显示的图示‘spline’的而不是‘pchip’，而存取的变量是‘pchip’的结果！\r\nemd函数前没有output arguments 时输出图片，若有输出变量则不会显示图片。", "Konwledge_Point": "图的分解", "Question": "MATLAB EMD分解结果和显示有差别\n为什么emd函数输出的结果和运行emd时显示的经验模态图不一样？左图是运行时显示的图，显示了原信号和5个经验模态图以及余项。右图是根据输出数据画的图，可以明显看出IMF3和原图不一样，请问这是为什么？\n\n代码如下：\n\n\n\nclc;clear\nx=load('sumsin');\nx=x.sumsin;\nt=1:length(x);\n[output,res]=emd(x);\nemd(x,'Interpolation','pchip');          % 此时输出左图\n\nfigure\nsubplot(711)\nplot(t,x)\nset(gca,'xticklabel','');\nfor i=1:6\n    subplot(7,1,i+1)\n    plot(t,imf(:,i))\n    if i<6;set(gca,'xticklabel','');end\nend                                     % 此时输出右图\n\n\n\n", "Tag": "算法分析"}
{"Answer": "import pandas as pd\nimport glob\nimport os\n# 获取当前路径\ncwd = os.getcwd()\n \n# 要拼接的文件夹及其完整路径，注不要包含中文\n## 待读取批量csv的文件夹 \nread_path =  'data_Q1_2018' \n## 待保存的合并后的csv的文件夹           \nsave_path =  'data_Q1_2018_merge'  \n## 待保存的合并后的csv       \nsave_name = 'Modified.csv'   \n# 修改当前工作目录\nos.chdir(read_path)\n \n# 将该文件夹下的所有文件名存入列表\ncsv_name_list = glob.glob('*csv')\n \n# 读取第一个CSV文件并包含表头，用于后续的csv文件拼接\ndf = pd.read_csv(csv_name_list[0])\ntableName = os.path.splitext(csv_name_list[0])[0]\ndf[tableName] = df[df.columns[1]] / df.iloc[0,0]\ntableList = []\ntableList.append(tableName)\n# # 循环遍历列表中各个CSV文件名，并完成文件拼接\nfor i in range(1,len(csv_name_list)):\n    data = pd.read_csv( csv_name_list[i] )\n    tableName2 = os.path.splitext(csv_name_list[i])[0]\n    tableList.append(tableName2)\n    data[tableName2] = data[data.columns[1]] / data.iloc[0,0]\n    df = pd.concat([df,data],axis=1)\n    finalData = df[tableList]\nfinalData.to_csv(cwd + '\\\\' + save_path + '\\\\' + save_name ,encoding=\"utf_8\",index=False)\n\n", "Konwledge_Point": "图的分解", "Question": "用python读取多个csv表指定数据写入一个表中\n我想用python 合并一组表格，麻烦给写可直接用的代码\n\n\n目录D:/001  文件下有多个cvs表（表1到表?），\n把第二列（B2到B?，数量不固定）除以固定值A2，\n得到新的列合并输出在all.csv中，放同目录下\n第一行输出表格文件名，原表第一行数据不需要，\n如图分表第3列是需要的生成的数据合并到总表\n\n\n\n\n下面是一组参考代码，用来改改可能快一点\n\n\nimport pandas as pd\nimport os\n\n# 获取当前路径\n\ncwd = os.getcwd()\n\n\n# 要拼接的文件夹及其完整路径，注不要包含中文\n\n\n# 待读取批量csv的文件夹 \n\nread_path =  \n'data_Q1_2018'\n \n\n# 待保存的合并后的csv的文件夹           \n\nsave_path =  \n'data_Q1_2018_merge'\n  \n\n# 待保存的合并后的csv       \n\nsave_name = \n'Modified.csv'\n   \n\n# 修改当前工作目录\n\nos.chdir(read_path)\n\n\n# 将该文件夹下的所有文件名存入列表\n\ncsv_name_list = os.listdir()\n\n\n# 读取第一个CSV文件并包含表头，用于后续的csv文件拼接\n\ndf = pd.read_csv( csv_name_list[0]) \n\n\n# 读取第一个CSV文件并保存\n\ndf.to_csv( cwd + \n'\\\\'\n + save_path + \n'\\\\'\n + save_name , \nencoding\n=\n\"utf_8\"\n,index=False)\n\n# 循环遍历列表中各个CSV文件名，并完成文件拼接\n\n\nfor\n i \nin\n range(1,18):\n    df = pd.read_csv( csv_name_list[i] )\n    df.to_csv(cwd + \n'\\\\'\n + save_path + \n'\\\\'\n + save_name ,\nencoding\n=\n\"utf_8\"\n,index=False, \nheader\n=\nFalse\n, \nmode\n=\n'a+'\n)\n\n\n", "Tag": "算法分析"}
{"Answer": "\nThe usual approach would be to send only a few emails at once and mark the sent ones on the background(via database flag sent=1 for example)\nThen call the script every few minutes via a cronjob\nThis way you dont run into problems with php timeouts when sending emails to a lot of subscribers\n", "Konwledge_Point": "图的分解", "Question": "通过延迟将循环过程分解成部分，需要建议\n\n\n\ni wanted to break down a process (loop) into some parts, for example if have 128 emails to send :\n\n\n\nfunction subs_emails(){    \n    $subscribers = //find subscribers\n\n    if(!empty($subscribers )){\n        foreach($subscribers as $i => $subscriber){\n            sendEmail($subscriber->id);\n            if($i % 15 == 0){ //<-- send email per 15\n                sleep(60); //to pause the process for 60 seconds \n            }\n        }\n        return true;\n    }else{\n        return false;\n    }\n}\n\n\n\n\nwill this works ?? or is there any other \"better approach\" solution ?? need advice please\n\n\n\nthanks\n\n    ", "Tag": "算法分析"}
{"Answer": "你好，我是有问必答小助手，非常抱歉，本次您提出的有问必答问题，技术专家团超时未为您做出解答本次提问扣除的有问必答次数，将会以问答VIP体验卡（1次有问必答机会、商城购买实体图书享受95折优惠）的形式为您补发到账户。因为有问必答VIP体验卡有效期仅有1天，您在需要使用的时候【私信】联系我，我会为您补发。", "Konwledge_Point": "图的分解", "Question": "基于奇异值分解的模糊检测与分割\n代码找不到类似的，就是基于奇异值曲线差异性的图像模糊检测与分割，只看到图片压缩的", "Tag": "算法分析"}
{"Answer": "你要把写的函数放到前面去 ", "Konwledge_Point": "图的分解", "Question": "matlab函数无法识别，如何解决？\n用牛顿插值法，计算有点多，编了3个函数都不能用。\n\n\ni = \n[-\n2\n,-\n1\n,-\n0.5\n,\n0.5\n,\n1\n,\n2\n]\n;\nV = \n[-\n637\n,-\n96.5\n,-\n20.5\n,\n20.5\n,\n96.5\n,\n637\n]\n;\niNew = \n0.1\n;\n%一次插值 选i\n[\n3\n,\n4\n]\n\nV1 = b1(\nV(3)\n)+b2(\nV(3)\n,i(\n3\n),\nV(4)\n,i(\n4\n))*(iNew-i(\n3\n));\n%二次插值 选i\n[\n3\n,\n4\n,\n5\n]\n\nV2 = b1(\nV(3)\n)+b2(\nV(3)\n,i(\n3\n),\nV(4)\n,i(\n4\n))*(iNew-i(\n3\n))+b3(\nV(3)\n,i(\n3\n),\nV(4)\n,i(\n4\n),\nV(5)\n,i(\n5\n))*(iNew-i(\n3\n))*(iNew-i(\n4\n));\n\n\nfunction\n sc3 = b3(f_x1,x1,f_x2,x2,f_x3,x3)\n    sc3 = (b2(f_x2,x2,f_x3,x3)-b2(f_x1,x1,f_x2,x2))/x3-x1;\n\nend\n\n\nfunction\n sc2 = b2(f_x1,x1,f_x2,x2)\n    sc2 = (f_x2-f_x1)/(x2-x1);\n\nend\n\n\nfunction\n sc1 = b1(f_x1)\n    sc1 = f_x1;\n\nend\n\n\n\n\n\n\n\n运行结果及报错内容\n\n\n函数或变量 'b1' 无法识别。\n\n\n怕误删了文件，重装了一次，", "Tag": "算法分析"}
{"Answer": "只需要将spectrogram函数的输入参数fs设定为250就可以", "Konwledge_Point": "图的分解", "Question": "matlab做时频变换，想把坐标轴从采样点个数变为真实时间\n关于matlab做stft的问题：我的输入是96×1的数据点（数据来源于250hz的实际电信号采样，这一段数据实际上是0.384秒的），\n现在用spectrogram函数做出的图横轴单位是采样点个数，但我想要横轴是真实时间点，纵轴频率根据横轴自动计算，应该怎么做呢？谢谢！", "Tag": "算法分析"}
{"Answer": "还是先判断(*pchb=*pcha)不等于0，再++", "Konwledge_Point": "图的分解", "Question": "这个是c++课上的一个例子，我有一行不明白\n如图while那一行，应该是先++，再赋值，判断不等于零，再进行下一步，还是先判断(*pchb=*pcha)不等于0，再++", "Tag": "算法分析"}
{"Answer": "可以用字符串拼接，例如J(1+i)，里面是i是数值型，可以先转换为字符串，然后拼接。\nJ(1+i)可以这样写：['J(',num2str(1+i),')']\n例如，当i=1时， ['J(1',num2str(1+1),')']则为J(2)", "Konwledge_Point": "图的分解", "Question": "matlab如何在循环中修改变量名称并再次使用？\n\n\nx = image;\n[J1,S1,C1,D1] = SWT2(x);\nL = 1;\nfor i = 1:15\n        [J(1+i),S(1+i),C(1+i),D(1+i)] = SWT2(J(i))\n        e_J(i) = Entropy(J(i))\n        e_J(1+i) = Entropy(J(1+i))\n        L = L+1\n    if e_J(1+i) > e_J(i)\n        break\n    end\nend\n\n\n\n程序思路：输入一幅图像x，通过SWT2函数使x可以产生4幅图像（J1,S1,C1,D1）。对J1再调用SWT2函数产生4幅图像（J2,S2,C2,D2）。对J2再调用SWT2函数产生4幅图像（J3,S3,C3,D3），如此循环15次。\n\n\n\nSWT2函数的功能：将输入的图像分解成近似图像，水平细节图像，垂直细节图像和对角细节图像\n\n\n\nEntropy函数的功能：计算输入图像的熵值\n\n\n\n上述代码肯定执行不了，那么在循环中如何利用i将J(1+i)定义成变量名？例如：当i=3时，J(1+i)表示为变量名为“J4”的一个变量。\n\n\n\n ", "Tag": "算法分析"}
{"Answer": "中间蓝色部分文字的大概意思是通过matlab的内置函数qz可以对矩阵进行QZ分解，而QZ分解的目的是为了求广义的特征值。对于qz(A,B)表示传入两个矩阵A,B，对其进行QZ分解，分解得到6个参数，这六个参数中要满足Q1,Z1为正交矩阵，且满足蓝色框里面的计算，分解出来得到一般的特征向量，用于后期的使用。同时对于：\ndiag(U)./diag(V)\n\n\n表示对取矩阵U,V上的对角元素，同时让U的对角元素除以V的对角元素！", "Konwledge_Point": "图的分解", "Question": "关于#matlab#的问题：第二张图片中蓝色框中间文字怎样理解\n\n\n源代码关于schur 方法的QZ分解，即把系数矩阵进行分块矩阵的处理。\n第二张图片中蓝色框中间文字怎样理解？\ndiag(U)./diag(V)是什么意思？", "Tag": "算法分析"}
{"Answer": "1、if（x==0）2、printf(\"%d \",t); %d后面加个空格，打印的数据好看些", "Konwledge_Point": "图的分解", "Question": "我的分解因数的C程序为什么输出是空白？\n\n\n\n\n问题就是上图\n\n\n\n\n#\ninclude\n \n\n\n\nint\n \nmain\n()\n\n\n{\n    \nint\n i = \n0\n;\n    \nint\n t = \n1\n;\n    \nint\n x = \n0\n;\n    \n    \nprintf\n(\n\"请输入一个数：\\n\"\n);\n    \nscanf\n(\n\"%d\"\n,&i);\n    \nprintf\n(\n\"此数的因数有：\\n\"\n); \n    \nfor\n(t=\n1\n;t<=i;++t) {\n        x= i%t;\n        \nif\n(x=\n0\n){\n            \nprintf\n(\n\"%d\"\n,t);\n        } \n    }\n    \n      \nreturn\n \n0\n;\n      \n}\n\n", "Tag": "算法分析"}
{"Answer": "\nx = int(input())\nresult = []\ndef answer_lb(xc):\n    lb = []\n    for i in range(2,xc):\n        if xc%i == 0:\n            lb.append(i)\n            lb += answer_lb(xc//i)\n            return lb\n    lb.append(xc)\n    return lb\nresult = answer_lb(x)\nresult.sort()\n# 输出结果，利用map()函数将结果按照规定字符串格式输出\nprint(x,'=','*'.join(map(str,result)))\n", "Konwledge_Point": "图的分解", "Question": "请问各位<将输入的一个正整数分解质因数>得出下图输入输出，我错在哪儿，该怎么改\n\n\nx\n = \nint\n(\ninput\n())\nresult = []\ndef answer_lb(xc):\n    \nlb\n = []\n    \nfor\n i in \nrange\n(\n2\n,xc):\n        \nif\n xc%i == \n0\n:\n            \nfor\n \nj\n in \nrange\n(\n2\n,i):\n                \nif\n i%\nj\n != \n0\n:\n                    \nlb\n.\nappend\n(i)\n                \nelse\n:\n                    answer_lb(i)\n        \nelse\n:\n            \ncontinue\n\n    \nreturn\n \nlb\n\nresult = answer_lb(\nx\n)\nresult.\nsort\n()\n# 输出结果，利用\nmap\n()函数将结果按照规定字符串格式输出\n\nprint\n(\nx\n,\n'='\n,\n'*'\n.\njoin\n(\nmap\n(str,result)))\n\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "```\r\n int[] data = {1,2,3,4,5,6,7,8,9};\r\nint[][] result = Enumerable.Range(0, data.Count() / 3).Select(x => data.Skip(x*3).Take(3).ToArray()).ToArray();\r\n```", "Konwledge_Point": "图的分解", "Question": "c#中如何将一个数组拆分多个小数组\n\n\n\n如图所示，每3个存为一个数组，该怎么写呢？请各位大神赐教！谢谢！", "Tag": "算法分析"}
{"Answer": "\n回答不易，求求您采纳点赞哦\n\n快速峭度图是用来提高窄带瞬态冲击信号分离的精度的一种图形。其中，三个分解频带的谱峭度值分别对应频带[0,1/6]、[1/6,1/3]和[1/3,1/2]。通过使用这种方法来替代传统的二叉树结构分解，可以提高精度。每一层的频带值是通过使用不同的准解析滤波器和高通低通滤波器配置来确定的。", "Konwledge_Point": "图的分解", "Question": "快速峭度图怎么看啊！！\n快速峭度图怎么看啊？\n它的层数为什么是0   1   1.6   2   2.6 这样呀？还有每一层的频带为什么是这样？论文里是下面这样的，我看不懂，有没有人帮我解答以下，谢谢。\n在窄带瞬态冲击信号分离中，二叉树结构分解精度太低，为了提高二叉树结构分解精度，采用通过频率分别为[0,1/6]、[1/6,1/3]和[1/3,1/2]的三个准解析滤波器与上述的高通低通滤波器交替配置，并计算三个分解频带信号的谱峭度值，形成1/3-二叉树结构快速峭度图。\n\n", "Tag": "算法分析"}
{"Answer": "请看👉 ：Android studio自动创建drawable-xhdpi等文件夹", "Konwledge_Point": "图的分解", "Question": "Android studio 如何管理 大量图片，drawable中无法建立文件夹吗？\n虽然已经有许多文件夹：\ndrawable\ndrawable-v24\nmipmap-anydpi-v26\nmipmap-mdpi\n但是很可惜我用SurfaceView好像不能直接绘制GIF动图，只能将其分解为修列静态图片，使用如下方法绘制：\n\n\n     p_canvas.draw\nBitmap(Config.\ntemplate_ones\n[\nf_frameIndex\n], \nf_locationX\n, \nf_locationY\n, \np_paint\n)\n;\n        f_frameIndex = (++f_frameIndex) % \n55\n;\n\n\n\n\n但是产生了大量的图片！！\n我想比如在drawable文件夹中 建立多个文件夹（即：一个GIF建一个文件夹），但是好像不行，除了有红色波浪线提示错误之外，\n而且R.drawble.还找不到", "Tag": "算法分析"}
{"Answer": "给个例子参考：\nn = int(input('请输入一个正整数：'))\nloop = True\nprint(f'{n}=',end='')\nwhile loop:\n    for i in range(2,n+1):\n        if n%i==0:\n            n = n//i\n            if n==1:\n                print(i)\n                loop = False\n            else:\n                print(i,end='*')\n            break\n\n\n如有帮助，请采纳！", "Konwledge_Point": "图的分解", "Question": "python编写程序读取一个大于1的正整数，然后显示它所有的最小因子，也称之为素因子 | 最后格式不知道如何体现\n编写程序读取一个大于1的正整数，然后显示它所有的最小因子，也称之为素因子\n例如：输入整数为90，输出90=2\n3\n3*5\n\n\n问题相关代码\n\n\nn = int(input('请输入一个正整数：'))\ni = 2\nwhile True:\n    if n % i == 0:\n        print('%d=' % n, i)\n        n = n / i\n    else:\n        i += 1\n    if n == 1:\n        break\n\n\n运行结果及报错内容\n\n\n得出来的因子好像都是对的，但是输出来的格式不是例子那样，不知道应该怎么输代码", "Tag": "算法分析"}
{"Answer": "\ndef factor(n):\n    l = []\n    while n > 1:\n        for i in range(2, n + 1):\n            if n % i == 0:\n                n = int(n / i)\n                if n == 1:\n                    l.append(i)\n                else:\n                    l.append(i)\n                break\n    return l\nprint(factor(45))\nprint(factor(100))\n\n", "Konwledge_Point": "图的分解", "Question": "想问一下这个怎么通过函数的方式实现\n想问一下这里的这个因式分解要怎么通过上图的这个函数来实现呢？", "Tag": "算法分析"}
{"Answer": "参考GPT和自己的思路，根据你提供的代码和错误信息，可能是由于变量名或函数名错误导致的无法识别错误。\n首先，出现错误的行中，变量名u_avg_vector可能存在拼写错误。请检查变量名是否正确，并且该变量是否在程序的其他位置正确定义或赋值。\n另外，代码中也存在其他的语法错误和逻辑错误，例如第一行中R=xflucxfluc:%16001600中的:可能是一个语法错误。在使用注释符号%时，应该将注释放在语句的后面，而不是与语句合并在一起。此外，在第二行中，应该使用lamda而不是landa。\n为了更好地解决问题，建议提供更多的代码信息和错误信息，或者将完整的代码放在一个单独的脚本中，以便我们更好地了解问题所在并进行修改和调试。下面是一个修改后的代码片段，你可以参考一下：\nfunction pod(xfluc, nsnapshots)\n% 计算速度平均值\nu_avg_vector = mean(xfluc, 2); % 按列计算平均值\navg = zeros(size(xfluc));\nfor j = 1:size(xfluc, 2)\n    avg(:,j) = u_avg_vector;\nend\n\n% 减去平均值\nxfluc = xfluc - avg;\n\n% 计算本征正交分解\nR = xfluc * xfluc';\n[eigenvector, eigenvalue] = eig(R);\nlamda = diag(eigenvalue);\nsum_eigenvalue = sum(lamda);\nenergy = lamda / sum_eigenvalue;\n\n% 选取能量占比达到95%的模态\nenergy_POD = 0.95;\nenergy_process = 0;\ni = 1;\nwhile energy_process < energy_POD && i <= nsnapshots\n    energy_process = energy_process + energy(i);\n    i = i + 1;\nend\ni = i - 1;\n\n% 计算POD模态\nu_pod = xfluc' * eigenvector(:,1:i);\nend\n\n希望这些修改可以帮助你解决问题。如果还有其他问题，请随时提出。", "Konwledge_Point": "图的分解", "Question": "MATLAB中函数或变量无法识别\nMATLAB中函数或变量无法识别\n对三维速度进行本征正交分解，但是这一个变量无法识别如图\n\n", "Tag": "算法分析"}
{"Answer": "\ndef reduceNum(n):\n    \n    '''策略:求解n的因式分解,首先从2开始到n遍历,\n    如果n%某一个数的结果是整数,则打印出该数,同时n=n/该数\n    直到n==1结束\n    '''\n    a='{} = '.format(n)\n \n    #判断n是否为正整数\n    if not isinstance(n, int) or n <= 0 :\n        print ('请输入一个正确的数字 !')\n        exit(0)\n        \n    #排除n的值为1 的特殊情况   \n    elif n in [1] :        \n        a+='{}'.format(n)\n \n    #n的值不为1的正整数   \n    while n not in [1] : # 循环保证递归\n        for temp in range(2, n + 1) :\n            \n            if n % temp == 0:#更改n的值,同时记录下它的因数并跳出for循环\n                n =int( n/temp)# n 等于 n/temp\n                \n                if n == 1: #此时n的值大小和因数相同,作为末尾因数\n                    a+=str(temp)\n                    \n                else : # index 一定是因数                    \n                    a+='{} *'.format(temp)\n                    \n                break\n    print(a)\n            \nreduceNum(999)\nreduceNum(90)\n参考一下，希望对你有帮助", "Konwledge_Point": "图的分解", "Question": "麻烦各位大佬帮忙看看\n【质因数分解】对用户输入的一个大于10的整数进行质因数分解。假设输入符合要求，程序显示该数的质因数分解结果，且各个质因数从小到大排列。\n\n\n\n程序的一次执行过程如下图所示：\n\n\n\n\n\n\n如果用户输入的是一个质数，则程序显示1乘以该数。下图是用户输入一个质数的分解结果：\n\n\n\n\n\n\n程序代码如下：\n\n\n\n#质因数分解\n\n\n\nimport math\n\n\n\nx = int(input(\"请输入一个大于10的整数：\"))\n\n\n\nprimes =[ ___1___  for p in range(2, x//2+1) if 0 not in[p%d for d in range(2, int(math.sqrt(p))+1)] ]\n\n\n\nfactorList = []\n\n\n\ny = x\n\n\n\nfor i in primes:\n\n\n\n   while y % i == 0:\n\n\n\n       factorList.append(i) \n\n\n\n       y = y // i\n\n\n\nif factorList == []:\n\n\n\n   print(\"%d=%d*%d\" % ___2___)\n\n\n\nelse:\n\n\n\n   s = \"*\".join( map( ___3___ , factorList) ) \n\n\n\n   print(\"%d=%s\" % (x,s)) \n\n\n\n#结束\n\n\n\n ", "Tag": "算法分析"}
{"Answer": "其实更多的考虑是面向对象的特性，一种对现实世界的一种自然模拟，其实在很多时候，一对多 多对多都可以做出来，但是你建模总得有个最佳方案。比如你举的例子\r\nPERSON  1：N   ADDRESS 这其实最直观的对生活中现实模拟，倒不是真的考虑到易用性。", "Konwledge_Point": "图的分解", "Question": "hibernate文档对于一对多关联的一些疑问\n[quote]基于外键关联的单向一对多关联是一种很少见的情况，我们不推荐使用它。[/quote]\n\n[quote]我们认为对于这种关联关系最好使用连接表。 [/quote]\n\n\n\nPERSON  1：N   ADDRESS\n\n\n\nER关系图多对多关系分解为两个一对多关系，没有一对多分解为一对一和一对多。这种推荐的处理方式是如何考虑的呢？", "Tag": "算法分析"}
{"Answer": "本来接口通过底层封装好就是为了方便调用，当然要遵循相应的规则，一千个人有一千种不一样的格式，那怎么读取？所以你要做的就是两件事，第一：找一下资料看看Matlab支不支持读取你这种格式，第二：想办法转成Matlab的格式，比如txt，csv等。有用请采纳，谢谢！", "Konwledge_Point": "图的分解", "Question": "matlab中自定义格式文件怎么读取\n问题遇到的现象和发生背景\n\n\n做图像奇异值分解，保存分解后的矩阵为自定义格式，最好不是常见的后缀格式\n\n\n问题相关代码，请勿粘贴截图\n\n\nxiaoye = cat(\n2\n,cramp_lst01,cramp_lst02,cramp_lst03)\n;%这个xiaoye是1063*168的矩阵\n\nsave('xiaoye.svd','xiaoye')\n;\n\n\n\n\n运行结果及报错内容\n\n\nfopen\n(\n'xiaoye.svd'\n)\n\n\nans =\n\n     \n3\n\n\n\n\n我想要达到的结果\n\n\n读取得到的数据还是xiaoye", "Tag": "算法分析"}
{"Answer": "```\r\n select * from user  where userDeviceid in(\r\nSELECT userDeviceid FROM user where channelId='301040' GROUP BY userDeviceid having count(*)>=2\r\n)\r\n```", "Konwledge_Point": "图的分解", "Question": "MySQL查询求帮助快绝望了\n所有的查询都在USER表，我分解开了条件，第一个SELECT * FROM USER u WHERE u.\nchannelId\n='301040';\n\n 根据查出来userDeviceid的值查，第二条件\n\n 想得到userDeviced字段相同的值大于2条和2条以上所对应的用户\n\n想最终得到，这种数据，每条用户的名字Code不一样,但是userDeviceId是一样的", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/weixin_30920597/article/details/96524904", "Konwledge_Point": "图的分解", "Question": "关于Database,如何确定架构中的keys，以及是否BCNF，3NF？\n\n\n\n描述：关于R架构特性A, B, C, D 有以下依赖关系：AB→C, AC→B, B→D, BC→A.\n\n\n\na. 列出R中所有的keys\n\nb. R是否BCNF，如果不是，把它分解为BCNF关系集\n\nc. R是否3NF，如果不是，把它转为3NF。", "Tag": "算法分析"}
{"Answer": "这个不属于第三范式，在我看来这属于反范式没有冗余的数据库设计可以做到。但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是：在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余，达到以空间换时间的目的。码字不易  望采纳", "Konwledge_Point": "图的分解", "Question": "请问该关系为第几范式？\n如图的关系，约定：同一日期、同一水池ID、同一指标名可以有不同的检测机构ID，也就是（日期，水池ID，指标名，检测机构ID）->值，即日期，水池ID，指标名，检测机构ID是主键，请教各位，这关系是第三范式了吗？\n\n\n如果分解成如下图的两个关系，\n\n\n关系R2的字段“R1_ID”是外键。这么一来，不得不新增一个ID标识，用于R2关联，否则回到图1了。请问我哪里错了", "Tag": "算法分析"}
{"Answer": "ORDER BY 字段 nulls last  非MSSQL的语法。\r\n\r\nSELECT * FROM (\r\nSELECT *,\r\n\tCASE WHEN 排序在前的条件 THEN 1  --排序在前的条件\r\n\t WHEN 排序在二的条件 THEN 2 --\t排序在二的条件\t\r\n\t WHEN 排序在二的条件 THEN 3 --\t排序在二的条件\t\r\n\tEND px\r\nFROM RM_RUL_Results )\r\nORDER BY px ASC", "Konwledge_Point": "图的分解", "Question": "sql server需要把查询结果中的为null的数据放在最后，且为null的字段越少，该数据就越往前\n在开发过程中，我碰到了一个数据排序的问题，大致情况是在某一张数据表中存在一些数据是空值的情况，显示的时候会比较丑，如图\n\n\n\n因此，我想要对结果进行排序处理，让“不可用设备”、“随机设备”、“敏感性分析”这三个字段中非空的数据优先显示，详细的逻辑可以分解为：\n\n\n\n1.“不可用设备”、“随机设备”、“敏感性分析”都为非空的数据最优先显示\n\n\n\n2.存在两个字段非空，一个字段为空的情形：\n\n\n\n     ①.“不可用设备”、“随机设备”非空，“敏感性分析”为空最优先显示\n     ②.“不可用设备”、“敏感性分析”非空，“随机设备”为空次之\n     ③.“随机设备”、“敏感性分析”非空，“不可用设备”为空最后显示\n\n\n\n\n3.存在一个字段非空，两个字段为空的情形,也分三种情况:\n\n\n\n     ①.“不可用设备非空最优先显示\n     ②.“随机设备”非空次之\n     ③.“敏感性分析”非空最后显示\n\n\n\n\n4.三个字段都为空最后显示\n\n\n\n在这种前提之下，按照字符串排序，那么sql应该怎么写呢\n\n\n\n附上我写的代码，我试过了很多种方法，始终无法实现这种效果，有没有大神能教教我：\n\n\n\n1.SELECT * FROM RM_RUL_Results WHERE 1=1\n\n      ORDER BY components nulls last, random_components nulls last, env nulls last\n\n\n\n我在百度找到的其中一种方法，但是这种方法存在语法错误\n\n\n\n\n\n\n2.SELECT * FROM RM_RUL_Results WHERE 1=1\n\norder by case when components is null then 'zzzzzzzzz' else components end,\n\n            case when random_components is null then 'zzzzzzzzz' else random_components end,\n\n            case when env is null then 'zzzzzzzzz' else env end\n\n\n\n通过case when可以实现对第一个字段“不可用设备”（components）的排序，但是因为优先级的关系，随机设备（random_components）和敏感性分析（env）的空字段会出现在前面\n\n\n\n\n\n\n实在无奈了，有没有大神知道z'm'jie'jue", "Tag": "算法分析"}
{"Answer": "供参考：\n#include <stdio.h>\nint  isPrime(int n)\n{\n    int i;\n    if (n <= 3)  return n > 1;\n    for (i = 2; i * i <= n; i++)\n        if (n % i == 0) return 0;\n    return 1;\n}\nint main()\n{\n    int i, n;\n    while (scanf(\"%d\", &n) == 1 && n <= 2000 && n > 0)\n    {\n        for (i = 2; i <= n / 2; i++) {\n            if (isPrime(i) && isPrime(n - i)) \n            {\n                printf(\"%-d=%-d+%-d\\n\", n, i, n - i);//输出\n                break;\n            }\n        }\n    }\n    return 0;\n}\n\n", "Konwledge_Point": "图的分解", "Question": "如何输入若干个任意数，用最简单的方法，好多内容还没学\n哥德巴赫猜想\n成绩: 5 / 折扣: 0.8\n题面描述：\n如图所示：魔法学院的图书馆珍藏着一份1742年德国中学教师哥德巴赫写给大数学家欧拉的珍贵手稿，这就是世界近代三大数学难题之哥德巴赫猜想。即任何一个大于 6的偶数都可以表示成两个素数之和；任何一个大于9的奇数都可以表示成三个素数之和。 1966年，中国数学家陈景润证明了“任何一个充分大的偶数都可以表示成一个素数与另一个素因子不超过2个的数之和”，简称“1+2”。\n试验证2000以内的正偶数都能够分解为两个素数之和(即验证哥德巴赫猜想对2000以内的正偶数成立)。\n\n\n输入：\n若干个2001以内的正偶数，如上所述。\n\n\n输出：\n标准输出，输出所给正偶数的素数之和，每个占一行，如4=2+2。如果有多种可能，只输出一种，即第一个素数最小的。\n\n\n示例输入：\n4\n6\n8\n\n\n示例输出：\n4=2+2\n6=3+3\n8=3+5\n\n\n测试用例 1    以文本方式显示\n422↵\n1932↵\n1182↵\n86↵\n1880↵\n以文本方式显示\n422=3+419↵\n1932=19+1913↵\n1182=11+1171↵\n86=3+83↵\n1880=3+1877↵\n1秒    无限制    0", "Tag": "算法分析"}
{"Answer": "我可以帮你看看程序，我也是研究这方面的。", "Konwledge_Point": "图的分解", "Question": "MATLAB  核熵成分分析 KECA 核参数怎么选取以及主元个数怎么计算\n最近在写KECA的程序，它是对KPCA的一种改进方法，利用Renyi熵来选取主元个数，并将其应用于TE过程进行故障检测，选取TE过程正常训练数据500*52，测试数据960*52，\n\n\n\n但是编程结果一直不对：高斯核参数大一些（100-128左右），计算出来的Renyi熵第一项远远大于其他项，导致主元计算不正确，只有1，但是整体的统计图走向趋势是对的；高斯核函数小一些（3.5-4.5），计算出保留的主元数较为合适（十几到几十不等），但是统计图的趋势完全不对；若是设定大的高斯核参数，自己手动设定合适的保留的主元数（15-27左右），统计图监测效果还行。\n\n\n\n所以怎么才能让设定合适的核参数时计算出合适的主元数？我现在的程序到底哪步出了问题？\n\n\n\n \n\n\n\nKECA基本原理\n\n\n\n \n\n\n\n \n\n\n\n \n\n\n\n \n\n\n\n程序的整个流程：\n\n\n\n1、导入训练数据X（500*52），计算均值，方差来标准化 \n\n\n\n2、计算高斯核函数K（500*500），核函数自己设定为128\n\n\n\n\n\nc=128;\nfor i = 1 : X_row\n    for j = 1 : X_row\n        K(i,j) = exp(-(norm(Xtrain(i,:) - Xtrain(j,:)))^2/c^2);%求核矩阵，采用径向基核函数，参数c\n    end\nend\n\n\n\n3、对K直接进行特征值分解（eig）,求解出对应的特征值D和特征向量V，第一个特征值496.8437远远大于第二大的特征向量0.3995。\n\n\n\n做特征值分解的时候是对K做，还是对K/N做？\n求出来的特征向量需要单位化吗？怎么单位化?\n\n\n\n\n\n[V,D]=eig(K);%求特征值和特征向量  \n\nlambda1=diag(D); %对角矩阵 求特征值\n[lambda,index]=sort(real(lambda1),'descend'); %sort 'descend'每行按从大到小排序，lamda为排序后结果，index为索引 按照降序排列\nL1=diag(lambda); %从大到小特征值对角矩阵形式\nVVV=V(:,index);  %按照特征值降序排列的特征向量 N*N\n\nVV=zeros(X_row,X_row);\nfor i=1:X_row\n  VV(:,i) = VVV(:,i)/norm(VVV(:,i));    %特征向量归一化 \nend\n\n\n\n\n4、计算每一项的Renyi熵值（按照熵大小排列，取前npc个特征值特征向量，熵是平方的形式还是不平方的形式？不平方有负值）\n\n\n\n\n\nn0=ones(1,X_row);%1*N 元素全为1\nentropy=zeros(1,X_row);\nfor i = 1 : X_row\n    entropy(i) = lambda(i)*(VV(:,i)'*n0')^2;%求二次熵\n    %entropy(i) =sqrt(lambda(i))*VV(:,i)'*n0';%求熵    \nend\n\n\n\n5、按照Renyi熵值的大小降序排列对应的特征值和特征向量\n\n\n\n\n\n[sorted_entropy,r]=sort(entropy,'descend');%将熵值按降序排列，sorted_entropy是排列后的数组，r是序号\nlamda=lambda(r);%对应于熵降序排列的特征值\nL=diag(lamda);%对应于熵降序排列的特征值对角阵\nP=VV(:,r);%对应于熵降序排列的特征向量\n\n\n\n6、计算Renyi熵值从大到小累计贡献99%的对应的主元个数\n\n\n\n\n\nnpc=1;\nwhile sum(sorted_entropy(1:npc))/sum(sorted_entropy)<0.99\n    npc=npc+1; %求保留的主元数\nend\n\n\n\n一般情况下npc=1可以占据99.99%甚至更高的贡献率，但是这种结果是不对的，但是不知道那里不对\n\n\n\n7、利用训练数据计算T2和SPE统计量的控制限\n\n\n\n训练数据主元向量T怎么计算？\n\n\n\n还是\n\n\n\n 计算出训练数据T2和SPE统计量使用核密度估计怎么计算控制限？\n\n\n\n公式怎么使用？x是代表一个样本的T2统计量值吗？\n\n\n\n\n\n%% 计算T2 SPE统计量\nZ_1=inv(sqrt(L))*P'*K'; %N1*N2 \nZ=Z_1';%N2*N1 \nSCORE=K*P; \nZ_ECA_1 =inv(sqrt(L(1:npc,1:npc)))*P(:,1:npc)'*K'; %npc*N2 \nZ_ECA=Z_ECA_1'; %N2*npc \n\n%T2统计量\nfor i=1:X_row\n        T2_1(i)=Z_ECA(i,:)*inv(L(1:npc,1:npc))*Z_ECA(i,:)';   % 1*1\nend\n%T22=diag(Z_ECA*inv(L(1:npc,1:npc))*Z_ECA'); %整体矩阵计算\n\n%Q统计量\nQ_1= sum(Z.^2,2)-sum(Z_ECA.^2 ,2);\n\n\n\n8、CS统计量怎么计算（训练数据的，以及测试数据的）\n\n\n\n\n\n\n CS统计量公式\n\n\n\n\n\n\n\n\n%训练数据CS统计量及控制限计算计算\nPhi_ECA1=sqrt(L(1:npc,1:npc))*P(:,1:npc)'; %npc*N    \nPhi_ECA=Phi_ECA1'; \nSM_ECA=0;\nfor i=1:X_row\n    SM_ECA=SM_ECA+Phi_ECA1(:,i); %npc*1\nend\nM_ECA=SM_ECA/X_row; %npc*1\n\nCS1=zeros(1,X_row);\nfor i=1:X_row\n    CS1(i)=1-M_ECA'*Phi_ECA1(:,i)/(norm(M_ECA')*norm(Phi_ECA1(:,i))); \nend\n\n%利用核密度估计计算控制限\nalpha = 0.99;\n[f,xi] = ksdensity(CS1);\ndelta=xi(2)-xi(1);\nsum_bb=0;\nblock=0;\nfor i=100:-1:1\n    sum_bb=sum_bb+delta*f(i);\n    if sum_bb>(1-alpha) & block==0;\n    bbb=i;\n    block=1;\n    end   \nend\nCSUCL=xi(1)+delta*bbb;\n\n\n\n%测试数据CS统计量\n[K_t] = computeKM(Xtest,Xtrain,c);%求核矩阵，采用径向基核函数，参数c N2*N1\n\nZt_1=inv(sqrt(L))*P'*K_t'; %N1*N2 \nZt=Zt_1';%N2*N1 \nZt_ECA1 =inv(sqrt(L(1:npc,1:npc)))*P(:,1:npc)'*K_t'; %npc*N2 \nZt_ECA=Zt_ECA1'; %N2*npc \n\n\nCS2=zeros(1,Xt_row);\nfor i=1:Xt_row\n      CS2(i)=1-M_ECA'*Zt_ECA1(:,i)/(norm(M_ECA')*norm(Zt_ECA1(:,i))); \nend", "Tag": "算法分析"}
{"Answer": "sym2poly你是不是拼错了", "Konwledge_Point": "图的分解", "Question": "请问一下，这个代码的问题可以怎样解决，结果如图所示\n请问一下，这个代码的问题可以怎样解决？\n报错结果如图：\n\n\n\n\nclear all\nclose all\n\nderad\n=pi/180;%角度转化为弧度\n\nradeg\n=180/pi;%弧度转化为角度\n\ntwpi\n=2*pi;\n\nkelm\n=8;%阵元数\n\ndd\n=0.5;%阵元间距\n\nd\n=0:dd:(kelm-1)*dd;\n\niwave\n=3;%信源数\ntheta=[10 30 60];%波动方向\n\nsnr\n=10;%信噪比\n\nn\n=500;%采样数\n\nA\n=exp(-j*twpi*d.'*sin(theta*derad));%方向向量\n\nS\n=randn(iwave,n);%信源数量\n\nX0\n=A*S;%接受信号\n\nX\n=awgn(X0,snr,'measured');%添加噪声\n\nRxx\n=X*X'/n;%计算协方差矩阵\n\nInvS\n=inv(Rxx);\n[EVx,Dx]=eig(Rxx);%特征值分解\n\nEVAx\n=diag(Dx)';\n[EVAx,Ix]=sort(EVAx);%特征值从小到大排序\n\nEVAx\n=fliplr(EVAx);%左右翻转，从小到大排序\n\nEVx\n=fliplr(EVx(:,Ix));%对应特征向量排序\n\n\nUnx\n=EVx(:,iwave+1:kelm);\nsyms z\n\npz\n=z.^([0:kelm-1]\n');\npz1=(z^(-1)).^([0:kelm-1]);\nfz=z.^(kelm-1)*pz1*Unx*Unx'\n*pz;\n\na\n=sym2ploy(fz);\n\nzx\n=roots(a);\n\nrx\n=zx.';\n[as,ad]=(sort(abs((abs(rx)-1))));\n\nDOAest\n=asin(sort(-angle(rx(ad([1,3,5])))/pi))\n*180\n/pi;\n\n", "Tag": "算法分析"}
{"Answer": "import java.util.Scanner;\n\npublic class MyDate {\n    private int year;\n    private int month;\n    private int day;\n\n    public int getYear() {\n        return year;\n    }\n\n    public void setYear(int year) {\n        this.year = year;\n    }\n\n    public int getMonth() {\n        return month;\n    }\n\n    public void setMonth(int month) {\n        this.month = month;\n    }\n\n    public int getDay() {\n        return day;\n    }\n\n    public void setDay(int day) {\n        this.day = day;\n    }\n\n    public boolean isLeapYear() {\n        return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;\n    }\n\n    public void nextDate() {\n        int num = getLengthOfMonth(month);\n        if (month == 12 && day == num) {\n            year++;\n            month = 1;\n            day = 1;\n        } else if (day == num && month != 12) {\n            month++;\n            day = 1;\n        } else if (day != num && month != 12) {\n            day++;\n        }\n    }\n\n    public int getLengthOfMonth(int month) {\n        /*判断月份，特殊为2月*/\n        int num;\n        switch (month) {\n            case 1:\n            case 3:\n            case 5:\n            case 7:\n            case 8:\n            case 10:\n            case 12:\n                num = 31;\n                break;\n            case 2:\n                num = (isLeapYear()) ? 29 : 28;\n                break;\n            default:\n                num = 30;\n        }\n        return num;\n    }\n\n    public void inputData() {\n        //创建对象\n        Scanner sc = new Scanner(System.in);\n        //分别输入年月日\n        System.out.println(\"请输入年月日\");\n        boolean error;\n        do {\n            System.out.println(\"请输入年份（1~5000）：\");\n            year = sc.nextInt();\n            error = year < 1 || year > 5000;\n        } while (error);//若error为true则重新输入年份\n\n        do {\n            System.out.println(\"请输入月份（1~12）：\");\n            month = sc.nextInt();\n            error = month < 1 || month > 12;\n        } while (error);\n        int num = getLengthOfMonth(month);\n\n        do {\n            System.out.println(\"请输入日（1~\" + num + \"）:\");\n            day = sc.nextInt();\n            error = day < 1 || day > num;\n        } while (error);\n\n        /*当输入的年月日都合法之后*/\n        /*特殊为年末和月末*/\n        System.out.println(\"请输入当前日期：\" + year + \"-\" + month + \"-\" + day);\n    }\n\n    public String getDate() {\n        return year + \"-\" + month + \"-\" + day;\n    }\n\n    public int getDayOfYear() {\n        int sum = 0;\n        for (int i = 0; i < 12; i++) {\n            sum += getLengthOfMonth(i + 1);\n        }\n        return sum;\n    }\n}\n", "Konwledge_Point": "图的分解", "Question": "关于#java#的问题，如何解决？\n一．源代码：题目是求当前日期（年月日）的下一天（年月日），源代码已编好。\n\n\n```java\n\npackage\n javaexperiment1;\n\n\n//导包\n\n\nimport\n java.util.Scanner;\n\n\npublic\n \nclass\n \nNextDate\n {\n\n\n\n\npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[] args) {\n    \nint\n \nyear\n,\nmonth\n,\nday\n;\n\n\n\n        \n//创建对象\n\n        Scanner sc = \nnew \nScanner\n(System.\nin\n);\n        \n//分别输入年月日\n\n        System.\nout\n.\nprintln\n(\n\"请输入年月日\"\n);\n        \n//接收数据\n\n        \n/*先定年月日输入值的界限*/\n\n        \nboolean\n error;\n        do{\n            System.\nout\n.\nprintln\n(\n\"请输入年份（1~5000）：\"\n);\n            \nyear\n = sc.\nnextInt\n();\n            error = \nyear\n<\n1\n || \nyear\n>\n5000\n;\n        }\nwhile\n(error);\n//若error为true则重新输入年份\n\n\n            do{\n                System.\nout\n.\nprintln\n(\n\"请输入月份（1~12）：\"\n);\n                \nmonth\n = sc.\nnextInt\n();\n                error = \nmonth\n<\n1\n || \nmonth\n>\n12\n;\n            }\nwhile\n (error);\n\n            \n/*判断月份，特殊为2月*/\n\n        \nint\n num;\n        \nswitch\n (\nmonth\n){\n            \ncase\n \n1\n:\n            \ncase\n \n3\n:\n            \ncase\n \n5\n:\n            \ncase\n \n7\n:\n            \ncase\n \n8\n:\n            \ncase\n \n10\n:\n            \ncase\n \n12\n: num = \n31\n; \nbreak\n;\n            \ncase\n \n2\n:  num = (\nyear\n%\n4\n==\n0\n&&\nyear\n%\n100\n!=\n0\n || \nyear\n%\n400\n==\n0\n)? \n29\n:\n28\n; \nbreak\n;\n            \ndefault\n: num = \n30\n;\n        }\n\n        do{\n            System.\nout\n.\nprintln\n(\n\"请输入日（1~\"\n+ num +\n\"）:\"\n);\n            \nday\n = sc.\nnextInt\n();\n            error = \nday\n<\n1\n || \nday\n>num;\n        }\nwhile\n (error);\n\n        \n/*当输入的年月日都合法之后*/\n\n        \n/*特殊为年末和月末*/\n\n        System.\nout\n.\nprintln\n(\n\"请输入当前日期：\"\n+ \nyear\n +\n\"-\"\n+ \nmonth\n +\n\"-\"\n+ \nday\n);\n\n\n        \nif\n (\nmonth\n == \n12\n && \nday\n==num){\n            \nyear\n++;\n            \nmonth\n = \n1\n;\n            \nday\n = \n1\n;\n        }\n        \nelse\n \nif\n (\nday\n==num && \nmonth\n!=\n12\n){\n            \nmonth\n++;\n            \nday\n = \n1\n;\n        }\n        \nelse\n \nif\n (\nday\n!=num && \nmonth\n!=\n12\n){\n            \nday\n++;\n        }\n\n        System.\nout\n.\nprintln\n(\n\"下一天日期：\"\n+ \nyear\n +\n\"-\"\n+ \nmonth\n +\n\"-\"\n+ \nday\n);\n\n\n\n\n\n\n\n\n    }\n}\n\n\n\n\n\n\n\n二．题目要求如下（修改已编好的“求下一天年月日的程序”）：\n实验内容 ：    \n\n\n（1）把实验一的项目文件夹JavaExperiment1复制一份，把新复制的文件夹修改为JavaExperiment3，在IDEA中打开项目文件夹JavaExperiment3，鼠标右键单击项目名称，在弹出的菜单中选择“重构”->\"重命名\"，把项目名称修改为JavaExperiment3，在JavaExperiment3项目中完成本次实验。\n\n\n  (2)  通过IDEA的重构功能把项目的顶层包重命名为javaexperiment3，把NextDate类重命名为MyDate类。\n\n\n  (3)  把原来main方法中完成的功能分解到MyDate类的属性和普通方法中：把变量year、month和day定义成私有的成员变量并定义每个属性的getter方法，定义获取日期的getDate方法，把判断是否是闰年的功能提取到isLeapYear方法中，把获取一个月包含的天数的功能提取到getLengthOfMonth方法中，把输入年月日并对输入的数据进行校验的功能提取到inputData方法中，把计算输入日期的下一个日期的方法提取到nextDate方法中，重构后的MyDate类的UML类图如下图所示：\n\n\n（4）在MyDate类中添加getDayOfYear方法，该方法判断输入的日期是一年中的第几天并返回判断结果。重构的MyDate类的UML类图如下图所示：\n\n\n  （5）在项目包中创建名为Test的测试类，在Test类的main方法中创建MyDate类的对象，通过创建的对象分别调用inputData、nextDate、getDayOfYear、getDate方法完成测试并输出结果。\n\n", "Tag": "算法分析"}
{"Answer": "sql语句写的是查询所有，当然不会分页", "Konwledge_Point": "图的分解", "Question": "jsp分页问题，，，，，，，，，，，，，，，\n求大神看看   显示列表只有第一页有全部信息，但是页码、上一页、下一页  都有  就是没有内容分页数目正确  但是内容全显示在第一页\n\npackage org.pan.web;\n\nimport java.sql.*;\n\nimport java.util.Vector;\n\nimport org.pan.util.*;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.pan.web.book.shopuser;\n\npublic > private shopuser user = new shopuser(); //新的用户对象\n\nprivate javax.servlet.http.HttpServletRequest request; //建立页面请求\n\nprivate Vector userlist;  //显示用户列表向量数组\n\nprivate int page = 1;   //显示的页码\n\nprivate int pageSize=3;   //每页显示的图书数\n\nprivate int pageCount =0;    //页面总数\n\nprivate long recordCount =0; //查询的记录总数\n\nprivate String message = \"\";    //出错信息提示\n\nprivate String username = \"\";   //注册后返回的用户名\n\nprivate long userid = 0;    //注册后返回的用户ID\n\npublic usermn() throws Exception{\n\nsuper();\n\n}\n\n\n\npublic Vector getUserlist() {\n\nreturn userlist;\n\n}\n\n\n\npublic String getGbk( String str) {\n\ntry\n\n{\n\nreturn new String(str.getBytes(\"ISO8859-1\"));\n\n}\n\ncatch (Exception e)\n\n{\n\nreturn str;\n\n}\n\n}\n\n\n\n//将页面表单传来的资料分解\n\npublic boolean getRequest(javax.servlet.http.HttpServletRequest newrequest) {\n\nboolean flag = false;\n\ntry\n\n{\n\nrequest = newrequest;\n\nString ID = request.getParameter(\"userid\");\n\nif (ID!=null )\n\n{\n\nuserid = 0;\n\ntry\n\n{\n\nuserid = Long.parseLong(ID);\n\nuser.setId(userid);\n\n}\n\ncatch (Exception e)\n\n{\n\nmessage = message + \"你要修改的用户号出错！\";\n\n}\n\n}   \n\n\n\nusername = request.getParameter(\"username\");\n\nif (username==null || username.equals(\"\"))\n\n{\n\nusername = \"\";\n\nmessage = message + \"用户名为空!\";\n\n}\n\nuser.setUserName(getGbk(username)); \n\nString password = request.getParameter(\"passwd\");\n\nif (password==null || password.equals(\"\"))\n\n{\n\npassword = \"\";\n\nmessage = message + \"密码为空!\";\n\n}\n\nString pwdconfirm = request.getParameter(\"passconfirm\");\n\nif (!password.equals(pwdconfirm))\n\n{\n\nmessage = message + \"确认密码不相同!\";\n\n}\n\nuser.setPassWord(getGbk(password));\n\nString names = request.getParameter(\"names\");;\n\nif (names==null)\n\n{\n\nnames = \"\";\n\n}\n\nuser.setNames(getGbk(names));\n\nString sex = request.getParameter(\"sex\");\n\nuser.setSex(getGbk(sex));\n\nString address = request.getParameter(\"address\");\n\nif (address == null)\n\n{\n\naddress = \"\";\n\n}\n\nuser.setAddress(getGbk(address));\n\nString post = request.getParameter(\"post\");\n\nif (post == null)\n\n{\n\npost = \"\";\n\n}\n\nuser.setPost(getGbk(post));\n\nString phone = request.getParameter(\"phone\");\n\nif (phone== null)\n\n{\n\nphone = \"\";\n\n}\n\nuser.setPhone(phone);\n\nString email = request.getParameter(\"email\");\n\nif (email == null)\n\n{\n\nemail = \"\";\n\n}\n\nuser.setEmail(getGbk(email));\n\nString IP = request.getRemoteAddr();\n\nuser.setRegIpAddress(IP);\n\nif (message.equals(\"\"))\n\n{\n\nflag = true;\n\n}\n\nreturn flag;\n\n}\n\ncatch (Exception e)\n\n{\n\nreturn flag;\n\n}\n\n}\n\n\n\npublic String getSql() {\n\nsqlStr = \"select * from my_users order by id\";\n\nreturn sqlStr;\n\n}\n\n\n\npublic boolean execute() throws Exception {\n\nsqlStr = \"select count(*) from my_users\";    //取出记录数\n\nint rscount = pageSize;\n\ntry\n\n{\n\nResultSet rs1 = stmt.executeQuery(sqlStr);\n\nif (rs1.next()) recordCount = rs1.getInt(1);\n\nrs1.close();\n\n}\n\ncatch (SQLException e)\n\n{\n\nclose();\n\nreturn false;\n\n}\n\n//设定有多少pageCount\n\nif (recordCount < 1)\n\n            pageCount = 0;\n\n        else\n\n            pageCount = (int)(recordCount - 1) / pageSize + 1;\n\n//检查查看的页面数是否在范围内\n\nif (page < 1)  \n\n            page = 1;\n\n        else if (page > pageCount)\n\n            page = pageCount;\n\n\n\nrscount = (int) recordCount % pageSize;  // 最后一页记录数        \n\n\n\n//sql为倒序取值\n\nsqlStr = \"select * from My_users \";\n\nif (page == 1)\n\n{\n\nsqlStr = sqlStr + \" order by Id desc\";\n\n} else {\n\nsqlStr = sqlStr + \" where Id not in ( select Id from My_users ORDER BY id) and Id in \" +\n\n\"(select Id from My_users ORDER BY ID) \" + \" order by Id desc\";\n\n}\n\ntry\n\n{\n\nrs = stmt.executeQuery(sqlStr);\n\nuserlist = new Vector();\n\nwhile (rs.next()){ \n\nshopuser user = new shopuser();\n\nuser.setId(rs.getLong(\"Id\"));\n\nuser.setUserName(rs.getString(\"UserName\"));\n\nuser.setPassWord(rs.getString(\"PassWord\"));\n\nuser.setNames(rs.getString(\"Names\"));\n\nuser.setSex(rs.getString(\"Sex\"));\n\nuser.setAddress(rs.getString(\"Address\"));\n\nuser.setPhone(rs.getString(\"Phone\"));\n\nuser.setPost(rs.getString(\"Post\"));\n\nuser.setEmail(rs.getString(\"Email\"));\n\nuser.setRegTime(rs.getString(\"RegTime\"));\n\nuser.setRegIpAddress(rs.getString(\"RegIpAddress\"));\n\nuserlist.addElement(user);\n\n}\n\nrs.close();\n\nreturn true;\n\n}\n\ncatch (SQLException e)\n\n{\n\nSystem.out.println(e);\n\nreturn false;\n\n}\n\n\n\n}\n\n\n\npublic boolean insert(HttpServletRequest req) throws Exception {\n\nif (getRequest(req)) {\n\nsqlStr = \"select * from My_users where username = '\" + user.getUserName() +\"'\";\n\nrs = stmt.executeQuery(sqlStr);\n\nif (rs.next())\n\n{\n\nmessage = message + \"该用户名已存在!\";\n\nrs.close();\n\nreturn false;\n\n}\n\nsqlStr = \"insert into my_users (username,password,Names,sex,Address,Phone,Post,Email,RegTime,RegIpaddress) values ('\";\n\nsqlStr = sqlStr + strFormat.toSql(user.getUserName()) + \"','\";\n\nsqlStr = sqlStr + strFormat.toSql(user.getPassWord()) + \"','\";\n\nsqlStr = sqlStr + strFormat.toSql(user.getNames()) + \"','\";\n\nsqlStr = sqlStr + strFormat.toSql(user.getSex()) + \"','\";\n\nsqlStr = sqlStr + strFormat.toSql(user.getAddress()) + \"','\";\n\nsqlStr = sqlStr + strFormat.toSql(user.getPhone()) + \"','\";\n\nsqlStr = sqlStr + strFormat.toSql(user.getPost()) + \"','\";\n\nsqlStr = sqlStr + strFormat.toSql(user.getEmail()) + \"',now(),'\";\n\nsqlStr = sqlStr + user.getRegIpAddress() + \"')\";\n\ntry\n\n{\n\nstmt.execute(sqlStr);\n\nsqlStr = \"select max(id) from My_users where username = '\" +user.getUserName()+ \"'\";\n\nrs = stmt.executeQuery(sqlStr);\n\nwhile (rs.next())\n\n{\n\nuserid = rs.getLong(1);\n\n}\n\nrs.close();\n\nreturn true;\n\n}\n\ncatch (SQLException sqle)\n\n{\n\nreturn false;\n\n}\n\n} else {\n\nreturn false;\n\n}\n\n\n\n}\n\n\n\npublic boolean update(HttpServletRequest req) throws Exception {\n\nif (getRequest(req)){\n\nsqlStr = \"update my_users set \";\n\nsqlStr = sqlStr + \"username = '\" + strFormat.toSql(user.getUserName()) + \"',\";\n\nsqlStr = sqlStr + \"password = '\" + strFormat.toSql(user.getPassWord()) + \"',\";\n\nsqlStr = sqlStr + \"Names = '\" + strFormat.toSql(user.getNames()) + \"',\";\n\nsqlStr = sqlStr + \"sex = '\" + strFormat.toSql(user.getSex()) + \"',\";\n\nsqlStr = sqlStr + \"address = '\" + strFormat.toSql(user.getAddress()) + \"',\";\n\nsqlStr = sqlStr + \"phone = '\" + strFormat.toSql(user.getPhone()) + \"',\";\n\nsqlStr = sqlStr + \"post = '\" + strFormat.toSql(user.getPost()) + \"',\";\n\nsqlStr = sqlStr + \"Email = '\" + strFormat.toSql(user.getEmail()) + \"' \";\n\nsqlStr = sqlStr + \" where id = '\" + user.getId() + \"'\";\n\ntry\n\n{\n\nstmt.execute(sqlStr);\n\nreturn true;\n\n}\n\ncatch (SQLException e)\n\n{\n\nreturn false;\n\n}\n\n} else {\n\nreturn false;\n\n}\n\n\n\n}\n\n\n\npublic boolean delete( long aid ) throws Exception {\n\n\n\nsqlStr = \"delete from My_users where id = \"  + aid ;\n\ntry\n\n{\n\nstmt.execute(sqlStr);\n\nreturn true;\n\n}\n\ncatch (SQLException e)\n\n{\n\nSystem.out.println(e);\n\nreturn false;\n\n}\n\n}\n\n\n\npublic boolean getUserinfo(long newid ) throws Exception {\n\ntry\n\n{\n\nsqlStr=\"select  * from My_users where Id = \" + newid ;\n\nrs = stmt.executeQuery(sqlStr);\n\nuserlist = new Vector();\n\nwhile (rs.next()){ \n\nuser.setId(rs.getLong(\"Id\"));\n\nuser.setUserName(rs.getString(\"UserName\"));\n\nuser.setPassWord(rs.getString(\"PassWord\"));\n\nuser.setNames(rs.getString(\"Names\"));\n\nuser.setSex(rs.getString(\"Sex\"));\n\nuser.setAddress(rs.getString(\"Address\"));\n\nuser.setPhone(rs.getString(\"Phone\"));\n\nuser.setPost(rs.getString(\"Post\"));\n\nuser.setEmail(rs.getString(\"Email\"));\n\nuser.setRegTime(rs.getString(\"RegTime\"));\n\nuser.setRegIpAddress(rs.getString(\"RegIpAddress\"));\n\nuserlist.addElement(user);\n\n}\n\nrs.close();\n\nreturn true;\n\n}\n\ncatch (SQLException e)\n\n{\n\nreturn false;\n\n}\n\n\n\n}\n\n\n\npublic int getPage() {   //显示的页码\n\nreturn page;\n\n}\n\npublic void setPage(int newpage) {\n\npage = newpage;\n\n}\n\n\n\npublic int getPageSize(){ //每页显示的图书数\n\nreturn pageSize;\n\n}\n\npublic void setPageSize(int newpsize) {\n\npageSize = newpsize;\n\n}\n\n\n\npublic int getPageCount() {  //页面总数\n\nreturn pageCount;\n\n}\n\npublic void setPageCount(int newpcount) {\n\npageCount = newpcount;\n\n}\n\n\n\npublic long getRecordCount() {\n\nreturn recordCount;\n\n}\n\npublic void setRecordCount(long newrcount) {\n\nrecordCount= newrcount;\n\n}\n\n\n\npublic String getMessage() {\n\nreturn message;\n\n}\n\n\n\npublic void setMessage(String msg) {\n\nmessage = msg;\n\n}\n\n\n\npublic void setUserid(long uid) {\n\nuserid = uid;\n\n}\n\npublic long getUserid() {\n\nreturn userid;\n\n}\n\n\n\npublic void setUserName(String uName) {\n\nusername = uName;\n\n}\n\n\n\npublic String getUserName() {\n\nreturn username;\n\n}\n\n};", "Tag": "算法分析"}
{"Answer": "以下内容部分参考ChatGPT模型：\n\n首先需要明确稀疏基和稀疏系数的概念：稀疏基：一组基底向量，用来表示信号的基础构成，通常使用正交基或者小波基。稀疏系数：信号在稀疏基下的系数，即用稀疏基去表示信号时各基底向量所占的比例。\n对于给定的n*1矩阵，我们可以采用傅里叶变换来得到其频域表示，即得到其在正交基下的系数，进而求得其稀疏系数。具体步骤如下：\n对n*1矩阵进行傅里叶变换，得到其频域表示。选取一组正交基，如离散余弦基（DCT）、小波基等。将频域系数投影到正交基上，得到其在正交基下的系数。对系数进行稀疏化处理，如使用L1范数最小化等方法。得到稀疏系数，进而得到原信号在稀疏基下的表示。\n以下是python代码示例，以DCT为例：\nimport numpy as np\nfrom scipy.fftpack import dct\n\n# 假设有一个10*1的矩阵\nx = np.random.rand(10, 1)\n\n# 进行DCT变换\nx_dct = dct(x, type=2, norm='ortho')\n\n# 选取前4个DCT基向量作为稀疏基\ndct_basis = np.zeros((10, 4))\nfor i in range(4):\n    dct_basis[:, i] = dct(np.eye(10)[:, i], type=2, norm='ortho')\n\n# 将频域系数投影到DCT基上，得到其在DCT基下的系数\nx_sparse = np.linalg.lstsq(dct_basis, x_dct, rcond=None)[0]\n\n# 对系数进行稀疏化处理\n# 这里使用L1范数最小化方法，即Lasso算法\nfrom sklearn.linear_model import Lasso\nlasso = Lasso(alpha=0.1)\nlasso.fit(dct_basis, x_dct)\nx_sparse = lasso.coef_\n\n# 得到原信号在DCT基下的表示\nx_rec = dct_basis @ x_sparse\n\n需要注意的是，稀疏基的选取需要考虑信号的特点，如能量分布、频率分布等，不同的信号可能需要选取不同的基底。而稀疏化处理的方法也有很多种，如L1范数最小化、L0范数最小化等，需要根据具体情况选择合适的方法。\n\n如果我的建议对您有帮助、请点击采纳、祝您生活愉快", "Konwledge_Point": "图的分解", "Question": "有懂信号学方面知识的朋友吗(标签-矩阵|关键词-傅里叶变换)\n我有一个n*1的矩阵，现在想用信号学的知识将其分解为稀疏基和稀疏系数，但是有点不清楚方法，网上搜集到的代码是\n\n\n有懂信号学方面知识的朋友吗？能指导我一下吗？图中代码想要采用傅里叶变换。但是我不知道怎么样去得到稀疏基，以及稀疏系数", "Tag": "算法分析"}
