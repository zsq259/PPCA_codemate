{"Answer": "你画个邻接表懂了，首先对于无向图，n个顶点表＋e个边表，每个都访问一次，就是n+e了，而对于有向图，用的是邻接表表示正向，逆邻接表来表示反响，不是用邻接表来表示正反两个方向的，理解错误，根据题意，问的是邻接表，所以也是n+e", "Konwledge_Point": "图的深度优先搜索", "Question": "数据结构图的深度优先搜索\n用邻接表存储的无向图，进行深度优先搜索，时间复杂度为什么不是O(n+2e)", "Tag": "算法分析"}
{"Answer": "广搜一般求最短路，算法时间复杂度比较固定深搜是穷举所有情况", "Konwledge_Point": "图的深度优先搜索", "Question": "广度优先搜索和深度优先搜索的区别\n广度优先搜索和深度优先搜索的区别在哪里啊？分不清楚什么时候用广度什么时候用宽度", "Tag": "算法分析"}
{"Answer": "你题目的解答代码如下：\n#include <stdio.h>\n#include <stdlib.h>\nint visited[105];\ntypedef struct EdgeNode//边结点\n{\n    int adjvex;\n    struct EdgeNode *next;\n}edge;\ntypedef struct vertexnode//临界点\n{\n    int data;\n    edge* firstedge;\n}vertexnode,Adjlist[105];\ntypedef struct LGraph//图\n{\n    int edgenum,nodenum;\n    Adjlist adjlist;\n}LGraph;\nLGraph* creategraph( )//创建图\n{\n    LGraph*G=(LGraph*)malloc(sizeof(LGraph));\n    scanf(\"%d %d\\n\",&(G->nodenum),&(G->edgenum));\n    int i,j;\n    for(i=1;i<=(G->nodenum);i++)//填充顶点表\n    {\n        int temp;\n        scanf(\"%d\",&temp);\n        G->adjlist[i].data=temp;\n        G->adjlist[i].firstedge=NULL;//勿漏\n    }\n    for(j=1;j<=(G->edgenum);j++)//填充边表\n    {\n        int temp1,temp2;\n        scanf(\"%d %d\\n\",&temp1,&temp2);//读入有向边的”入“，”出“\n        edge*e=(edge*)malloc(sizeof(edge));\n        // 有向边的”入“，”出“弄反正了\n        e->adjvex=temp2;     //temp1改成temp2\n        e->next=G->adjlist[temp1].firstedge;//头插法  temp2改成temp1\n        G->adjlist[temp1].firstedge=e;             //temp2改成temp1\n    }\n    return G;\n}\nint FLAG=0;//判断是否能通过v2的标志，全局变量\nvoid DFS(LGraph*G,int adjvex,int v2)//深度搜索\n{\n    edge*p;\n    visited[adjvex]=1;//标记已经访问过\n    p=G->adjlist[adjvex].firstedge;\n    if(visited[v2]==1) FLAG=1;\n    while(p)\n    {\n        if(visited[p->adjvex]==0)      //adjvex 改成 p->adjvex\n            DFS(G,p->adjvex,v2);\n        p=p->next;\n    }\n}\nint DFSTraverse(LGraph *G,int v1,int v2)\n{\n    int i;\n    for(i=1;i<=(G->nodenum);i++)//首先都初始化为未访问过的状态\n    {\n        visited[i]=0;\n    }\n        DFS(G,v1,v2);//从v1点开始深度搜索\n    return FLAG;\n}\n\nint main()\n{\n    LGraph*G;\n    G=creategraph();\n    int v1,v2,flag=0;\n    scanf(\"%d %d\",&v1,&v2);//要寻找的路径的两端下标\n    flag=DFSTraverse(G,v1,v2);\n    if(flag==1)\n        printf(\"yes\");\n    else\n        printf(\"no\");\n    return 0;\n}\n\n\n如有帮助，请点击我的回答下方的【采纳该答案】按钮帮忙采纳下，谢谢!\n", "Konwledge_Point": "图的深度优先搜索", "Question": "有向图的深度优先搜索\n样例输出应该是yes,但是输出no\n样例如下：\n4 4（结点数，边数）\n1 2 3 4（顶点下标）\n1 2（边信息）\n1 3\n1 4\n2 3\n2 3（要搜索是否存在的边信息）\n以下是代码\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\nint\n visited[\n105\n];\n\ntypedef\n \nstruct\n \nEdgeNode\n//边结点\n\n{\n    \nint\n adjvex;\n    \nstruct\n \nEdgeNode\n *next;\n}edge;\n\ntypedef\n \nstruct\n \nvertexnode\n//临界点\n\n{\n    \nint\n data;\n    edge* firstedge;\n}vertexnode,Adjlist[\n105\n];\n\ntypedef\n \nstruct\n \nLGraph\n//图\n\n{\n    \nint\n edgenum,nodenum;\n    Adjlist adjlist;\n}LGraph;\n\nLGraph* \ncreategraph\n( )\n//创建图\n\n\n{\n    LGraph*G=(LGraph*)\nmalloc\n(\nsizeof\n(LGraph));\n    \nscanf\n(\n\"%d %d\\n\"\n,&(G->nodenum),&(G->edgenum));\n    \nint\n i,j;\n    \nfor\n(i=\n1\n;i<=(G->nodenum);i++)\n//填充顶点表\n\n    {\n        \nint\n temp;\n        \nscanf\n(\n\"%d\"\n,&temp);\n        G->adjlist[i].data=temp;\n        G->adjlist[i].firstedge=\nNULL\n;\n//勿漏\n\n    }\n    \nfor\n(j=\n1\n;j<=(G->edgenum);j++)\n//填充边表\n\n    {\n        \nint\n temp1,temp2;\n        \nscanf\n(\n\"%d %d\\n\"\n,&temp1,&temp2);\n//读入有向边的”入“，”出“\n\n        edge*e=(edge*)\nmalloc\n(\nsizeof\n(edge));\n        e->adjvex=temp1;\n        e->next=G->adjlist[temp2].firstedge;\n//头插法\n\n        G->adjlist[temp2].firstedge=e;\n    }\n    \nreturn\n G;\n}\n\nint\n FLAG=\n0\n;\n//判断是否能通过v2的标志，全局变量\n\n\nvoid\n \nDFS\n(LGraph*G,\nint\n adjvex,\nint\n v2)\n//深度搜索\n\n\n{\n    edge*p;\n     visited[adjvex]=\n1\n;\n//标记已经访问过\n\n    p=G->adjlist[adjvex].firstedge;\n    \nif\n(visited[v2]==\n1\n) FLAG=\n1\n;\n    \nwhile\n(p)\n    {\n        \nif\n(visited[adjvex]==\n0\n)\n        \nDFS\n(G,p->adjvex,v2);\n        p=p->next;\n    }\n}\n\nint\n \nDFSTraverse\n(LGraph *G,\nint\n v1,\nint\n v2)\n\n\n{\n    \nint\n i;\n    \nfor\n(i=\n1\n;i<=(G->nodenum);i++)\n//首先都初始化为未访问过的状态\n\n    {\n        visited[i]=\n0\n;\n    }\n        \nDFS\n(G,v1,v2);\n//从v1点开始深度搜索\n\n    \nreturn\n FLAG;\n}\n\n\nint\n \nmain\n()\n\n\n{\n    LGraph*G;\n    G=\ncreategraph\n();\n    \nint\n v1,v2,flag=\n0\n;\n    \nscanf\n(\n\"%d %d\"\n,&v1,&v2);\n//要寻找的路径的两端下标\n\n    flag=\nDFSTraverse\n(G,v1,v2);\n    \nif\n(flag==\n1\n)\n        \nprintf\n(\n\"yes\"\n);\n    \nelse\n\n        \nprintf\n(\n\"no\"\n);\n    \nreturn\n \n0\n;\n}\n\n", "Tag": "算法分析"}
{"Answer": "额。。。注释得挺好把输出结果里的坐标数字替换成星号就好了\nfor i, j in res:\n    puzzle[i][j] = \"*\"\n\n如果要保存进txt，还要把之前的迷宫数字都换成字符串，当然，如果你是从txt读取的迷宫矩阵，就没这个问题了。", "Konwledge_Point": "图的深度优先搜索", "Question": "python走迷宫深度优先搜索\n有哦人知道这个程序要怎么改成打印出来的迷宫路径使用星号表示的吗，就是矩阵里面能显示路径\n\n\n\n```python\n\nfrom\n numpy import *\ndef findpath(puzzle, \nstart\n, \nend\n):\n    \n# 四个方向\n\n    d = [(\n-1\n,\n0\n),(\n0\n,\n1\n),(\n1\n,\n0\n),(\n0\n,\n-1\n)]\n    vis = [[\n-1\n \nfor\n _ \nin\n range(\nlen\n(puzzle[\n0\n]))] \nfor\n _ \nin\n range(\nlen\n(puzzle))]\n    \n#迷宫矩阵,0表示路， 1表示墙 \n\n    vis[\nstart\n[\n0\n]][\nstart\n[\n1\n]]=\nstart\n\n    dfs = [\nstart\n]     \n    \nwhile\n dfs:\n        x,y = dfs.pop()    \n#取栈顶及其探查方向\n\n        \nfor\n i \nin\n range(\n4\n): \n#依次检查未探查方向\n\n            m = x+d[i][\n0\n]\n            n = y+d[i][\n1\n]  \n#算出下一位\n\n            puzzle[\nstart\n[\n0\n]][\nstart\n[\n1\n]] = \n6\n \n#把走过的记录为6\n\n            \nif\n \n0\n<=m<\nlen\n(puzzle) \nand\n \n0\n<=n<\nlen\n(puzzle[\n0\n]) \nand\n puzzle[m][n]==\n0\n \nand\n vis[m][n]==\n-1\n:   \n#遇到未探查的新位置 \n\n                dfs.append((x,y))    \n#原位置和下一方向入栈\n\n                dfs.append((m,n))\n                vis[m][n]=(x,y)      \n#新位置入栈\n\n                puzzle[\nstart\n[\n0\n]][\nstart\n[\n1\n]] = \n6\n \n#把走过的记录为6\n\n                \nif\n \nend\n==(m,n): \n#到达出口，打印路径\n\n                    \nreturn\n dfs\n                break   \n#退出内层循环，下次迭代将以新栈顶为当前位置继续\n\n    \nreturn\n dfs  \n#找不到路径\n\n    \npuzzle = zeros((\n10\n, \n10\n), dtype=float) \n# 先创建一个全零方阵puzzle;，并且数据的类型设置为float浮点型\n\nf = \nopen\n(\n'test2.txt'\n) \n# 打开数据文件文件\n\n\nlines\n = f.readlines() \n# 把全部数据文件读到一个列表lines中\n\npuzzle_row = \n0\n  \n# 表示矩阵的行，从0行开始\n\n\nfor\n \nline\n \nin\n \nlines\n: \n# 把lines中的数据逐行读取出\n\n         list = \nline\n.strip(\n'\\n'\n).\nsplit\n(\n' '\n) \n# 处理逐行数据：strip表示把头尾的'\\n'去掉，split表示以空格来分割行数据，然后把处理后的行数据返回到list列表中\n\n         puzzle[puzzle_row:] = list[\n0\n:\n10\n] \n# 把处理后的数据放到方阵A中。list[0:4]表示列表的0,1,2,3列数据放到矩阵A中的A_row行\n\n         puzzle_row += \n1\n \n# 然后方阵A的下一行接着读\n\nprint(puzzle)        \n\nstart\n = eval(input(\n\"请输入起始坐标(x,y)：\"\n))\n\nend\n = \neval\n(\ninput\n(\"请输入终点坐标(\nm\n,\nn\n)：\"))\n\nres = findpath(puzzle, \nstart\n, \nend\n)\n\nif\n res:print(res)\n\nelse\n: print(\n'无路可走'\n)\n\n\n\n\n\n```", "Tag": "算法分析"}
{"Answer": "参考 https://blog.csdn.net/wd1603926823/article/details/128782281 可知：对于答案A：\n    1入；\n1出，3入；\n3出，5入；\n5出，4入；\n4出，2入；\n2出，6入；\n6出，7入；\n7出。    顶点已出完，结束搜索。\n所以顺序是：1 3 5 4 2 6 7\n\n对于答案B：顶点3 后还有接班人5 ，而它直接跳到了4，所以错误。对于答案C：\n    1入；\n1出，5入；\n5出，3入；\n3出，    （3已没有接班人，故此根枝条已捋到底）\n        （需返回上级5，发现有新分叉枝条4、6均未入队过，所以我们先入4）\n     4入；\n4出，2入；\n2出，7入；\n7出，6入；\n6出。     顶点已出完，结束搜索。\n所以顺序是：1 5 3 4 2 7 6\n\n对于答案D：顶点4还有接班人即未捋到底，而它直接跳到了7 ，所以错误。故答案是AC，我觉得你的标准答案A不正确。只能说A是树不分叉的深度优先搜索选择，因为C虽然也正确但树有一个分叉。", "Konwledge_Point": "图的深度优先搜索", "Question": "如图所示，给出由7个顶点组成的无向图。从顶点1出发，对它进行深度优先搜索得到的顶点序列是（\n如图所示，给出由7个顶点组成的无向图。从顶点1出发，对它进行深度优先搜索得到的顶点序列是（a　　）。\nA．1 3 5 4 2 6 7                            B．1 3 4 7 6 2 5\nC．1 5 3 4 2 7 6                            D．1 2 4 7 6 5 3\n\n\n这个深度优先搜索遍历，C选项不也可以吗", "Tag": "算法分析"}
{"Answer": "有具体的说明吗，什么题，什么场景\r\n如果非要到n^2，那就往里填平行边呗，某个图的dfs树种存在横叉边的话，把这些横叉边添加到n^2规模再搜索不就是你要的了。", "Konwledge_Point": "图的深度优先搜索", "Question": "通过深度优先搜索算法生成有向图的DFS树，是否有可能存在横叉边数目等于Ω(n^2)的情况？\n题中n代表树点。我现在能想到的就只有：有向图的最大边数为n(n-1)，但我不知道如何证明出Ω(n^2)？还是说这种情况并不可能？谢谢！", "Tag": "算法分析"}
{"Answer": "这两个都是正确的，以二叉树为例，dfs的思想是沿着一个子树一直找，找不到了就回溯，再换个子树继续找。当左右子树都找完了，就回到上一层，再在上一层换个子树。没有规定，先找哪个子树。所以上面两个答案都是对的", "Konwledge_Point": "图的深度优先搜索", "Question": "如图，关于数据结构 图 的深度优先遍历（DFS） 的遍历顺序问题\n①和② 两个深度优先遍历的顺序 都是正确 DFS吗？这块内容突然混乱了。\n还是说遇到岔路口时候必须走长的那条？", "Tag": "算法分析"}
{"Answer": "\nappend function may or may not modify the underlying array that your slice refers to. So you are not creating a completely new list when using append. I changed helper to match your desired behavior.\nfor i := index; i < length; i++ {\n    if i != index && nums[i] == nums[i - 1] {\n        continue\n    }\n    if nums[i] > target {\n        break\n    }\n    var newList []int\n    newList = append(newList, list...)\n    newList = append(newList, nums[i])\n    helper(nums, i, target - nums[i], newList, resultp, length)\n}\n\n", "Konwledge_Point": "图的深度优先搜索", "Question": "使用Golang时对深度优先搜索结果感到困惑\n\n\n\nI tried to solve the 'Combination Sum' on leetcode, and the result is wrong when using test case:\n\n\n\n\n  \n[7,3,2] 18\n\n\n\n\n\nI used C++ with the same logic and passed, but when using Golang, my result is:\n\n\n\n\n  \n[[2,2,2,2,2,2,2,2,2],[2,2,2,2,2,7,3,3],[2,2,2,2,3,7],[2,2,2,3,3,3,3],[2,2,7,7],[2,3,3,3,7],[3,3,3,3,3,3]]\n\n\n\n\n\nand the correct one should be\n\n\n\n\n  \n[[2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,3,3],[2,2,2,2,3,7],[2,2,2,3,3,3,3],[2,2,7,7],[2,3,3,3,7],[3,3,3,3,3,3]]\n\n\n\n\n\nthe code is shown below:\n\n\n\nimport \"sort\"\nfunc combinationSum(candidates []int, target int) [][]int {\n    result := make([][]int, 0, 0)\n    resultp := &result\n    sort.Ints(candidates)\n    helper(candidates, 0, target, make([]int, 0, 0), resultp, len(candidates))\n    return *resultp\n}\n\nfunc helper(nums []int, index int, target int, list []int, resultp *[][]int, length int) {\n    if target == 0 {\n        *resultp = append(*resultp, list)\n        return\n    }\n    for i := index; i < length; i++ {\n        if i != index && nums[i] == nums[i - 1] {\n            continue\n        }\n        if (nums[i] > target) {\n            break\n        }\n        helper(nums, i, target - nums[i], append(list, nums[i]), resultp, length)\n    }\n}\n\n\n\n\nCan anyone tell me why the result is incorrect, I am just confused about the [2,2,2,2,2,7,3,3] in my answer, why the 7 is before the 3 since the array has been sorted? Or anyone can tell me what mistake I have made in my code \n\n\n\n    ", "Tag": "算法分析"}
{"Answer": "1 2 4 8 9 5 10 11 3 6 7", "Konwledge_Point": "图的深度优先搜索", "Question": "已知一颗满二叉树可以用线性表1 2 3 4 5 6 7 8 9 10 11表示，求出深度优先遍历序列\n已知一颗满二叉树可以用线性表1 2 3 4 5 6 7 8 9 10 11表示，求出深度优先遍历序列", "Tag": "算法分析"}
{"Answer": "你题目的解答代码如下：\n#include <iostream>\nusing namespace std;\n\nint a[100][100];\nint ds[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\nint n, m;\n\nint dfs(int y,int x)\n{\n    if (y<0 || y>=n || x<0 || x>=m || a[y][x]!=1)\n        return 0;\n    int i,sum = 1;\n    a[y][x] = 0;  //这块草坪已经烧过了\n    for (i = 0; i < 4; i++)\n    {\n        sum += dfs(y+ds[i][0], x+ds[i][1]);\n    }\n    return sum;\n}\n\nint main()\n{\n    int i, j, d, max;\n    while (true)\n    {\n        cin >> n >> m;\n        if (n == 0 && m == 0)\n            break;\n        for (i = 0; i < n; i++)\n        {\n            for (j = 0; j < m; j++)\n            {\n                cin >> a[i][j];\n            }\n        }\n        max = 0;\n        for (i = 0; i < n; i++)\n        {\n            for (j = 0; j < m; j++)\n            {\n                if (a[i][j] == 1)\n                {\n                    d = dfs(i, j);\n                    if (d > max)\n                        max = d;\n                }\n            }\n        }\n        cout << max << endl;\n    }\n    return 0;\n}\n\n\n\n\n如有帮助，请点击我的回答下方的【采纳该答案】按钮帮忙采纳下，谢谢!\n", "Konwledge_Point": "图的深度优先搜索", "Question": "关于这道深度优先遍历的问题，如何解决？（C++）\n【问题描述】\n给你一块n\nm的草坪，问如果只点一次火，最多能烧多少块草坪。可以从n\nm的草地中任意一个地方开始点火，火只能往上下左右传递，没有草的地方不能燃烧。\n【输入格式】\n输入由多个测试例组成。每个测试例的第一行含两个整数n和m, (1 <=n,m<=100), 分别表示01矩阵的行数与列数，\n后面紧跟着n行，每行含m个整数0或1，1代表草坪，0表示啥也没有，相邻两个整数之间用一个空格隔开，两个测\n试例之间用一个空行隔开，最后一个测试例之后隔一个空行，最后一行含有两个整数0，表示输入结束。\n【输出格式】\n每个测试例对应一行输出，含一个整数，表示只点一次火最多能烧的草坪个数。\n【样例输入】\n5 6\n0 1 1 0 0 1\n1 1 0 1 0 1\n0 1 0 0 1 0\n0 0 0 1 1 1\n1 0 1 1 1 0\n\n\n0 0\n【样例输出】\n7\n【提示】\n深度优先搜索DFS的应用\n\n\n请问C++如何用深度优先搜索解决呢", "Tag": "算法分析"}
{"Answer": "试着写了一下，应该还可以优化\ndef findpath(puzzle, start, end):\n    d = [(-1,0),(0,1),(1,0),(0,-1)]\n    vis = [[-1 for _ in range(len(puzzle[0]))] for _ in range(len(puzzle))]\n    vis[start[0]][start[1]]=start\n    dfs = [start]\n    while dfs:\n        x,y = dfs.pop()\n        for i in range(4):\n            m = x+d[i][0]\n            n = y+d[i][1]\n            if 0<=m<len(puzzle) and 0<=n<len(puzzle[0]) and puzzle[m][n]==0 and vis[m][n]==-1:\n                dfs.append((x,y))\n                dfs.append((m,n))\n                vis[m][n]=(x,y)\n                if end==(m,n):return dfs\n                break   \n    return dfs\n\npuzzle = [\n    [0,0,0,0],\n    [0,1,1,0],\n    [0,0,1,1],\n    [1,0,0,0]\n]\nstart = eval(input(\"请输入起始坐标(x,y)：\"))\nend = eval(input(\"请输入终点坐标(m,n)：\"))\nres = findpath(puzzle, start, end)\nif res:print(res)\nelse: print('无路可走')\n\n测试：\n请输入起始坐标(x,y)：(0,0)\n请输入终点坐标(m,n)：(3,3)\n[(0, 0), (1, 0), (2, 0), (2, 1), (3, 1), (3, 2), (3, 3)]\n", "Konwledge_Point": "图的深度优先搜索", "Question": "深度优先搜索怎么实现走迷宫呀\n怎么用dfs深度优先搜索实现走迷宫呀,怎么实现两个坐标中走迷宫出一个路径", "Tag": "算法分析"}
{"Answer": "节点会有分叉是什么意思？你每行数据只有两个数据不同，是根据数据的大小排序吗？", "Konwledge_Point": "图的深度优先搜索", "Question": "如何将csv文件中的节点数据通过深度优先搜索进行排序，再进行重新编号\n举例：\n这些节点会有分叉，如何通过深度优先搜索进行排序编号。本人对此方面尚未接触过，求详细解答", "Tag": "算法分析"}
{"Answer": "不知道你这个问题是否已经解决, 如果还没有解决的话: 这篇文章讲的很详细，请看：找到搜索二叉树中两个错误的节点如果你已经解决了该问题, 非常希望你能够分享一下解决方案, 写成博客, 将相关链接放在评论区, 以帮助更多的人 ^-^", "Konwledge_Point": "图的深度优先搜索", "Question": "第二题深度优先搜索怎么做\n\n\n\n ", "Tag": "算法分析"}
{"Answer": "#define _CRT_SECURE_NO_WARNINGS\n#include \"stdio.h\"\n#include \"stdlib.h\"\n#include \"string.h\"\n#define MAXSIZE 3\n#define MAXNODESIZE 10\n\ntypedef struct Branch\n{\n    int index;\n    struct Branch* next;\n}branch;\n\ntypedef struct Tnode\n{\n    char data[MAXSIZE]=\"\\0\";\n    branch* first;\n}tnode;\n\nvoid create(tnode tree[], char str[], int cnt)  //创建邻接表\n{\n    int j = 0, t = 0;\n   \n\n    //printf(\"一共有%d个头节点\\n\", cnt);\n    for (int i = 0; i < cnt; i++)\n    {\n        j = 0;\n        while (str[t] != '/')  //遇到/就开始找换行符\\n，并跳转到下一行，录入下一行头节点\n        {\n            tree[i].data[j] = str[t];\n            j++;\n            t++;\n        }\n        tree[i].data[j] = '\\0';  //为tree[i].data加入终止符\n        tree[i].first = NULL;\n        while (str[t] != '\\n' && str[t] != EOF)  //跳转至下一行，准备录下一行的头节点\n            t++;\n        t++;\n        //puts(tree[i].data);  //将该行的头节点中的串打印出来以检验头节点的串是否成功录入\n    }\n    //头节点初始化完成，接下来将子节点连接到\n    t = 0;\n    int size = strlen(str);\n    for (int i = 0; i < cnt && t < size; i++)\n    {\n        while (t < size && str[t] != '/')  //先跳过头节点\n            t++;\n        t++;\n        // p = (branch*)malloc(sizeof(branch));\n        while (t < size &&str[t] != '\\n' && str[t] != '\\0') // 这里是bug1: t是数字， 也要可能是空了\n        {\n            j = 0;\n            char string[MAXSIZE];\n            while (t < size && str[t] != '/' && str[t] != '\\n')//将字符串截取出来 bug2:不能处理换行符\n            {\n                string[j] = str[t];\n                j++;\n                t++;\n            }\n            //此时str[t]=='/'\n            string[j] = '\\0';\n            //printf(\"子串为:\");\n            //puts(string);\n            int target = -1;\n            for (int n = 0; n < cnt; n++)\n            {\n                if (!strcmp(tree[n].data, string)) {\n                    target = n;\n                    break;\n                }\n            }\n            branch* p = tree[i].first;\n            //bug3:插入方式不正确，应该后插入\n            if (p == NULL) {\n                p = (branch*)malloc(sizeof(branch));\n                p->index = target;\n                p->next = NULL;\n                tree[i].first = p;\n            }\n            else {\n                while (p->next != NULL) {\n                    p = p->next;\n                }\n                p->next = (branch*)malloc(sizeof(branch));\n                p->next->index = target;\n                p->next->next = NULL;\n            }\n            if (t >= size ||str[t] == '\\n') {\n                break;\n            }\n            t++;  //使t指向下一个单词开头 \n        }\n        //此时t指向\\n\n        t++;  //将t指向下一行第一个字符\n    }\n}\n\nvoid dfs(int visited[], tnode tree[], int v);\n\nvoid DFS(tnode tree[])  //对邻接表进行深度优先遍历\n{\n    int cnt = 0;\n    int visited[MAXNODESIZE];\n  \n    for (int i = 0; i < MAXNODESIZE; i++) {\n        if (strlen(tree[i].data)>=2){\n            cnt++;\n        }\n        else {\n            break;\n        }\n    }\n    for (int i = 0; i < cnt; i++) visited[i] = 0;\n    \n    for (int i = 0; i < cnt; i++) {\n        if (!visited[i]) {\n            //没有遍历过\n            dfs(visited, tree,   i);\n        }\n    }\n}\nvoid dfs(int visited[], tnode tree[],   int v) {\n    tnode t = tree[v];\n    puts(t.data);\n    visited[v] = 1;\n \n    for (branch* w = t.first; w != NULL; w = w->next) {\n        if (!visited[w->index]) { \n            dfs(visited, tree, w->index);\n        }\n    }\n\n}\n \n\nvoid visit(tnode* node, char str[])  //对结点进行访问\n{\n    if (!strcmp(node->data, str))\n    {\n        printf(\"该结点存在！\");\n    }\n}\n\nvoid FillInText(char str[], FILE* fp)  //将文件中内容传入str中\n{\n    char ch;\n    int length = 0;\n    ch = fgetc(fp);\n    while (ch != EOF)\n    {\n        str[length] = ch;\n        ch = fgetc(fp);\n        length++;\n    }\n    str[length] = '\\0';\n}\n\nint getCount(char str[])  //获取邻接表头节点个数\n{\n    int cnt = 0;\n    for (int i = 0; i < strlen(str); i++)\n    {\n        if (str[i] == '\\n')\n            cnt++;\n    }\n    return cnt + 1;\n}\n\nint main()\n{\n    FILE* fp;\n    tnode tree[MAXNODESIZE];\n    \n    char ch, str[100];\n    fp = fopen(\"C:\\\\Users\\\\Lenovo\\\\Desktop\\\\1\\\\test.txt\", \"r\");\n    if (fp == NULL)\n    {\n        printf(\"文件打开失败\\n\");\n        exit(0);\n    }\n    FillInText(str, fp);\n    fclose(fp);\n    //printf(\"文件中的文本内容为:\\n\");\n    //puts(str);\n    create(tree, str, getCount(str)); \n    DFS(tree);\n    return 0;\n}\n", "Konwledge_Point": "图的深度优先搜索", "Question": "对邻接表进行深度优先遍历\n问题：\n将文本文件中的文本数据提取，并以此建立邻接表，再进行树的深度优先搜索。\n遇到的问题：\n在创建邻接表的时候，感觉逻辑有点混乱。\n我先是把邻接表的头节点都先加载出来，再将子节点接到头节点上。\n子节点接到头结点这个环节，感觉有点乱。\n文本文件内容：\n\n\n\n\n目标：\n将该内容变成存储内的邻接表\n\n\n\n\n并对该邻接表进行深度优先遍历\n\n\n求指教！\n以下为我的屎山代码XD（目前程序还是有问题的，问题在子节点连接到头节点那一块）：\n\n\n#\ndefine\n _CRT_SECURE_NO_WARNINGS\n\n\n#\ninclude\n \n\"stdio.h\"\n\n\n#\ninclude\n \n\"stdlib.h\"\n\n\n#\ninclude\n \n\"string.h\"\n\n\n#\ndefine\n MAXSIZE 20\n\n\ntypedef\n \nstruct\n \nBranch\n\n{\n    \nint\n index;\n    \nstruct\n \nBranch\n* next;\n}branch;\n\n\ntypedef\n \nstruct\n \nTnode\n\n{\n    \nchar\n data[MAXSIZE];\n    branch* first;\n}tnode;\n\n\nvoid\n \ncreate\n(tnode tree[],\nchar\n str[],\nint\n cnt)\n  \n//创建邻接表\n\n\n{\n    \nint\n j = \n0\n, t = \n0\n;\n    \nchar\n string[MAXSIZE];\n    branch* p;\n    \nprintf\n(\n\"一共有%d个头节点\\n\"\n, cnt);\n    \nfor\n (\nint\n i = \n0\n; i < cnt; i++)\n    {\n        j = \n0\n;\n        \nwhile\n (str[t] != \n'/'\n)  \n//遇到/就开始找换行符\\n，并跳转到下一行，录入下一行头节点\n\n        {\n            tree[i].data[j] = str[t];\n            j++;\n            t++;\n        }\n        tree[i].data[j] = \n'\\0'\n;  \n//为tree[i].data加入终止符\n\n        tree[i].first = \nNULL\n;\n        \nwhile\n (str[t] != \n'\\n'\n&&str[t]!=EOF)  \n//跳转至下一行，准备录下一行的头节点\n\n            t++;\n        t++;\n        \nputs\n(tree[i].data);  \n//将该行的头节点中的串打印出来以检验头节点的串是否成功录入\n\n    }\n    \n//头节点初始化完成，接下来将子节点连接到\n\n    t = \n0\n;\n    \nfor\n (\nint\n i = \n0\n; i < cnt; i++)\n    {\n        \nwhile\n (str[t] != \n'/'\n)  \n//先跳过头节点\n\n            t++;\n        t++;\n        p = (branch*)\nmalloc\n(\nsizeof\n(branch));\n        \nwhile\n (t != \n'\\n'\n)\n        {\n            j = \n0\n;\n            \nfor\n (\nint\n n = \n0\n; n < \nstrlen\n(string); n++)\n//字符串清空\n\n                string[n] = \n'\\0'\n;\n            \nwhile\n (str[t] != \n'/'\n)\n//将字符串截取出来\n\n            {\n                string[j] = str[t];\n                j++;\n                t++;\n            }\n            \n//此时str[t]=='/'\n\n            string[j] = \n'\\0'\n;\n            \nprintf\n(\n\"子串为:\"\n);\n            \nputs\n(string);\n            \nfor\n (\nint\n n = \n0\n; n < cnt; n++)\n            {\n                \nif\n (!\nstrcmp\n(tree[n].data, string))\n                    p->index = n;\n            }\n            p->next = tree[i].first;\n//将p接入头节点中\n\n            tree[i].first = p;\n            t++;  \n//使t指向下一个单词开头\n\n            p = (branch*)\nmalloc\n(\nsizeof\n(branch));\n        }\n        \n//此时t指向\\n\n\n        t++;  \n//将t指向下一行第一个字符\n\n    }\n}\n\n\nvoid\n \nDFS\n(tnode tree[])\n  \n//对邻接表进行深度优先遍历\n\n\n{\n\n}\n\n\nvoid\n \nvisit\n(tnode* node,\nchar\n str[])\n  \n//对结点进行访问\n\n\n{\n    \nif\n (!\nstrcmp\n(node->data, str))\n    {\n        \nprintf\n(\n\"该结点存在！\"\n);\n    }\n}\n\n\nvoid\n \nFillInText\n(\nchar\n str[], FILE* fp)\n  \n//将文件中内容传入str中\n\n\n{\n    \nchar\n ch;\n    \nint\n length = \n0\n;\n    ch = \nfgetc\n(fp);\n    \nwhile\n (ch != EOF)\n    {\n        str[length] = ch;\n        ch = \nfgetc\n(fp);\n        length++;\n    }\n    str[length] = \n'\\0'\n;\n}\n\n\nint\n \ngetCount\n(\nchar\n str[])\n  \n//获取邻接表头节点个数\n\n\n{\n    \nint\n cnt = \n0\n;\n    \nfor\n (\nint\n i = \n0\n; i < \nstrlen\n(str); i++)\n    {\n        \nif\n (str[i] == \n'\\n'\n)\n            cnt++;\n    }\n    \nreturn\n cnt + \n1\n;\n}\n\n\nint\n \nmain\n()\n\n\n{\n    FILE* fp;\n    tnode tree[MAXSIZE];\n    \nchar\n ch, str[\n100\n];\n    fp = \nfopen\n(\n\"test.txt\"\n, \n\"r\"\n);\n    \nif\n (fp == \nNULL\n)\n    {\n        \nprintf\n(\n\"文件打开失败\\n\"\n);\n        \nexit\n(\n0\n);\n    }\n    \nFillInText\n(str, fp);\n    \nprintf\n(\n\"文件中的文本内容为:\\n\"\n);\n    \nputs\n(str);\n    \ncreate\n(tree, str,\ngetCount\n(str));\n    \nfclose\n(fp);\n    \nreturn\n \n0\n;\n}\n\n", "Tag": "算法分析"}
{"Answer": "很明显就是你的内存分配以后，没有对其中的字段，比如firstChild nextSibling初始化\r\n\r\n邻接表G建立的有问题，排查一下邻接矩阵转换到邻接表的函数\r\n\r\n# 没有采纳之前先回答你这么多吧", "Konwledge_Point": "图的深度优先搜索", "Question": "求教大佬们，这个“读取位置 0xCCCCCCCC 时发生访问冲突。”的异常该如何解决？\n程序是数据结构的图的存储和遍历实验，功能是输入一个无向图并将其转换成邻接矩阵，然后把邻接矩阵变成邻接表，最后深度优先遍历该邻接表生成树（VS2017）：\n\n\n\n#include \n#include \n#include \n#include \n#include\nusing namespace std;\ntypedef int InfoType;\n#define MAXV 100                //最大顶点个数\n#define INF 32767               //INF表示∞\n#define isLetter(a)  ((((a)>='a')&&((a)<='z')) || (((a)>='A')&&((a)<='Z')))\n#define LENGTH(a)  (sizeof(a)/sizeof(a[0]))\n//以下定义邻接矩阵类型\ntypedef struct\n{\n    int no;                     //顶点编号\n    InfoType info;              //顶点其他信息\n} VertexType;                   //顶点类型\ntypedef struct              //图的定义\n{\n    char vexnum[MAXV];\n    int edges[MAXV][MAXV];      //邻接矩阵\n    int n, e;                       //顶点数，边数\n    VertexType vexs[MAXV];      //存放顶点信息\n} MGraph, *PGragh;                      //图的邻接矩阵类型\n//以下定义邻接表类型\ntypedef struct ANode            //边的节点结构类型\n{\n    int adjvex;                 //该边的终点位置\n    struct ANode *nextarc = NULL;       //指向下一条边的指针\n    InfoType *info;             //该边的相关信息,这里用于存放权值\n} ArcNode;\ntypedef int Vertex;\ntypedef struct Vnode            //邻接表头节点的类型\n{\n    Vertex data;                //顶点信息\n    ArcNode *firstarc;          //指向第一条边\n} VNode;\ntypedef VNode AdjList[MAXV];    //AdjList是邻接表类型\ntypedef struct\n{\n    AdjList adjlist;            //邻接表\n    int n, e;                   //图中顶点数n和边数e\n} ALGraph;                      //图的邻接表类型\n\nvoid MatToList(MGraph *g, ALGraph *G)\n//将邻接矩阵g转换成邻接表G\n{\n    int i, j;\n    ArcNode *p;\n    //G = (ALGraph *)malloc(sizeof(ALGraph));\n    for (i = 0; in; i++)                    //给邻接表中所有头节点的指针域置初值\n        G->adjlist[i].firstarc = NULL;\n    for (i = 0; in; i++)                    //检查邻接矩阵中每个元素\n    for (j = g->n - 1; j >= 0; j--)\n    if (g->edges[i][j] != 0)        //存在一条边\n    {\n        p = (ArcNode *)malloc(sizeof(ArcNode)); //创建一个节点*p\n        p->adjvex = j;\n        p->nextarc = G->adjlist[i].firstarc;        //采用头插法插入*p\n        G->adjlist[i].firstarc = p;\n    }\n    G->n = g->n; G->e = g->e;\n    //return G;\n}\n\nvoid DispMat(MGraph *g)\n//输出邻接矩阵g\n{\n    int i, j;\n    for (i = 0; in; i++)\n    {\n        for (j = 0; jn; j++)\n            printf(\"%3d\", g->edges[i][j]);\n        printf(\"\\n\");\n    }\n}\nvoid DispAdj(ALGraph G)\n//输出邻接表G\n{\n    int i;\n    ArcNode *p;\n    for (i = 0; iadjvex);\n            cout << p->adjvex << \" \";\n            p = p->nextarc;\n        }\n        printf(\"\\n\");\n    }\n}\nstatic int get_position(MGraph g, char ch)\n{\n    int i;\n    for (i = 0; i(vex * (vex - 1))))\n    {\n        printf(\"input error: invalid parameters!\\n\");\n        return NULL;\n    }\n\n    if ((pG = (MGraph*)malloc(sizeof(MGraph))) == NULL)\n        return NULL;\n    memset(pG, 0, sizeof(MGraph));\n\n    // 初始化顶点数和边数\n    pG->n = vex;\n    pG->e = edge;\n    // 初始化\"顶点\"\n    printf(\"输入各顶点名称：\\n\");\n    for (i = 0; i < pG->n; i++)\n    {\n        printf(\"vertex(%d): \", i);\n        pG->vexnum[i] = read_char();\n    }\n\n    // 初始化\"边\"\n    for (i = 0; i < pG->e; i++)\n    {\n        // 读取边的起始顶点和结束顶点\n        printf(\"edge(%d):\", i);\n        c1 = read_char();\n        c2 = read_char();\n\n        p1 = get_position(*pG, c1);\n        p2 = get_position(*pG, c2);\n        if (p1 == -1 || p2 == -1)\n        {\n            printf(\"input error: invalid edge!\\n\");\n            free(pG);\n            return NULL;\n        }\n\n        pG->edges[p1][p2] = 1;\n        pG->edges[p2][p1] = 1;\n    }\n\n    return pG;\n}\n// 打印矩阵队列图\n\nvoid print_graph(MGraph G)\n{\n    int i, j;\n\n    printf(\"Martix Graph:\\n\");\n    for (i = 0; i < G.n; i++)\n    {\n        for (j = 0; j < G.n; j++)\n            printf(\"%d \", G.edges[i][j]);\n        printf(\"\\n\");\n    }\n}\n//创建一个树的左子女，右兄弟结构\ntypedef struct node\n{\n    int data;\n    node *firstChild = NULL;\n    node *nextSibling = NULL;\n}TreeNode, *BinTree;\nint visited[MAXV];\nvoid Dfs(ALGraph G, int i, BinTree &T)\n{\n    visited[i] = 1;\n    bool first = true;//表示是否为当前节点第一个孩子\n    TreeNode *locat = new TreeNode;//同样是定位作用\n    while (G.adjlist[i].firstarc != NULL)//从此节点出发，访问邻接节点。\n    {\n        if (visited[G.adjlist[i].firstarc->adjvex] == 0)\n        {\n            visited[G.adjlist[i].firstarc->adjvex] = 1;\n            TreeNode *t = new TreeNode;//建立一颗小树\n            t->data = G.adjlist[i].firstarc->adjvex;\n            if (first)//是当前节点第一个孩子\n            {\n                T->nextSibling = t;//建立右孩子\n                first = false;//表示不是传进来的第一个孩子,则是孩子们的兄弟\n            }\n            else\n            {\n                locat->nextSibling = t;\n            }\n            locat = t;\n            Dfs(G, G.adjlist[i].firstarc->adjvex, t);//继续对小树找兄弟\n        }\n        G.adjlist[i].firstarc = G.adjlist[i].firstarc->nextarc;\n    }\n}\n\nvoid DFS_Traverse(ALGraph G, BinTree &T)\n{\n    TreeNode *locat = new TreeNode;//此处定义一个定位指针，用来定位当前树的位置\n    for (int i = 1; i <= G.n; i++)\n    {\n        visited[i] = 0;\n    }\n    for (int i = 1; i <= G.n; i++)\n    {\n        if (visited[i] == 0)\n        {\n            TreeNode *t = new TreeNode;//这代表一个小树\n            t->data = G.adjlist[i].data;\n            if (T == NULL)\n            {\n                T = t;//若树为空，建立头节点\n            }\n            else\n            {\n                locat->nextSibling = t;//若树不空，则是森林，插入右兄弟\n            }\n            locat = t;//定位至小树\n            Dfs(G, i, locat);//建立小树\n        }\n    }\n}\n\n//建立图深度优先搜索森林\nvoid DFSForest(ALGraph G, BinTree &T)\n{\n    DFS_Traverse(G, T);\n}\nvoid Display(BinTree T)\n{\n    if (T)\n    {\n        cout << T->data << ' ';\n        Display(T->firstChild);\n        Display(T->nextSibling);\n    }\n}\n\n\n\n//以下主函数用作调试\nint main()\n{\n    //int i, j;\n    MGraph* g, g1;\n    ALGraph G;\n    BinTree T;\n    g = create_graph();\n    printf(\"\\n\");\n    printf(\" 无向图G的邻接矩阵:\\n\");\n    DispMat(g);\n\n\n    //G = (ALGraph *)malloc(sizeof(ALGraph));\n    //M = (ALGraph *)malloc(sizeof(ALGraph));\n    printf(\" 图G的邻接矩阵转换成邻接表，顶点名称用编号表示:\\n\");\n    MatToList(g, &G);\n    DispAdj(G);\n    DFSForest(G, T);\n    Display(T);\n\n\n    system(\"pause\");\n}\n\n\n\n\n运行程序，输入顶点和边的信息，能够输出邻接矩阵和邻接表，但到了生成森林那一步就报异常：\n\n和同学研究了一下发现问题可能是出在执行到函数\n\n\n\nvoid DFS_Traverse(ALGraph G, BinTree &T)\n{\n    TreeNode *locat = new TreeNode;//此处定义一个定位指针，用来定位当前树的位置\n    for (int i = 1; i <= G.n; i++)\n    {\n        visited[i] = 0;\n    }\n    for (int i = 1; i <= G.n; i++)\n    {\n        if (visited[i] == 0)\n        {\n            TreeNode *t = new TreeNode;//这代表一个小树\n            t->data = G.adjlist[i].data;\n            if (T == NULL)\n            {\n                T = t;//若树为空，建立头节点\n            }\n            else\n            {\n                locat->nextSibling = t;//若树不空，则是森林，插入右兄弟\n            }\n            locat = t;//定位至小树\n            Dfs(G, i, locat);//建立小树\n        }\n    }\n}\n\n\n\n\n的最后一个for中的Dfs（G，i，locat）；这一句时出了问题，若在该处设置断点再重新运行程序并输入测试数据：\n\n然后按F11逐行运行，就跳到了函数Dfs（）那里：\n\n这时候按“继续”继续运行，到第二次循环时异常就出现了，请教大佬我应该如何修改这个程序，谢谢", "Tag": "算法分析"}
{"Answer": "给你写了个树，然后按照二叉树排序了一个数组，然后按中序遍历打印树的结点值\n\n\npublic class Tree {\n\n    public int value;\n    public Tree left;\n    public Tree right;\n\n    Tree(int v) {\n        value = v;\n    }\n\n    public void AddLeft(int v) {\n        left = new Tree(v);\n    }\n\n    public void AddRight(int v) {\n        right = new Tree(v);\n    }\n\n    public void Add(int v) {\n        if (v < value) {\n            if (left == null) {\n                AddLeft(v);\n            } else {\n                left.Add(v);\n            }\n        } else {\n            if (right == null) {\n                AddRight(v);\n            } else {\n                right.Add(v);\n            }\n        }\n    }\n\n    public void Print() {\n        if (left != null) {\n            left.Print();\n        }\n        System.out.println(value);\n        if (right != null) {\n            right.Print();\n        }\n    }\n\n    public static void main(String[] args) {\n        int values[] = new int[] { 4, 2, 3, 1, 5, 6, 2, 7, 8 };\n        Tree bt = new Tree(values[0]);\n        for (int i = 1; i < values.length; i++) {\n            bt.Add(values[i]);\n        }\n        bt.Print();\n    }\n\n}\n\n", "Konwledge_Point": "图的深度优先搜索", "Question": "二叉树怎么打印，为什么图中的left和right会报红？\n\n\n\n\nimport\n javax.swing.tree.TreeNode;  \n//这玩意儿也有导包，可以在非主方法里赋类型啥的\n\n\nimport\n java.util.ArrayList;\n\nimport\n java.util.List;\n\n\npublic\n \nclass\n \ndemoEz94\n {  \n//深度优先搜索跟递归有关跟深度优先搜索也有关\n\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(String[] args)\n {\n        \nTree\n \nbt\n \n=\n \nnew\n \nTree\n();\n        bt.createBinTree(bt.root);\n    }\n\n\n\n    \npublic\n List \nsolution\n(TreeNode root)\n{\n        List res = \nnew\n \nArrayList\n();\n        inorder(root, res);\n        \nreturn\n res;\n\n    }\n\n    \npublic\n \nvoid\n \ninorder\n(TreeNode root, List res)\n{\n        \nif\n(root == \nnull\n){\n            \nreturn\n;\n        }\n        inorder(root.left, res);\n        res.add(root.val);\n        inorder(root.right, res);\n\n    }\n}\n\n", "Tag": "算法分析"}
{"Answer": "xx✔x", "Konwledge_Point": "图的深度优先搜索", "Question": "请问这几句话哪几句是说法正确的？\n1.⼴度优先搜索和深度优先搜索不可以互相转化。\n2.如果递推得到的答案很⼤，需要取模，可以只在算出结果后取模，在中间过程不⽤取模。\n3.递推需要严格的边界条件和数据范围。\n4.编译正确，并且样例输出正确的代码，提交之后⼀定可以AC。", "Tag": "算法分析"}
{"Answer": "\n#include<bits/stdc++.h>\nusing namespace std;\nint ans[21];      //用于存放答案\nint n, total;    //总方案数\nvoid pr(int d){   //按照要求打印答案\n    total+=1;\n    cout<<n<<\"=\";\n    for(int i=1; i<=d-1; i++)cout<<ans[i]<<\"+\";\n    cout<<ans[d]<<endl;\n}\nvoid dfs(int dep, int rest){\n    if(rest==0){\n        if(dep>2){   //避免单独值的出现\n            pr(dep-1);\n            return;\n        }\n    }\n    for(int i=ans[dep-1]; i<=rest; i++){\n        ans[dep]=i;\n        dfs(dep+1, rest-i);\n    }\n}\nint main()\n{\n    cin>>n;\n    ans[0]=1;//初始化拆，18行循环语句的初始值\n    dfs(1, n);\n    //cout<<total;\n    return 0;\n}\n", "Konwledge_Point": "图的深度优先搜索", "Question": "请问谁能告诉我这道题的思路c++\n\n\n\n  \n自然数拆分 - 题库 - 计蒜客\n\n  \n题号：T1248；知识点：深度优先搜索；难度：普及T2；对于任意大于 $1$ 的自然数 $n$，总是可以拆分成若干个小于 $n$ 的自然数之和。现请你编写程序求出 $n$ 的所有拆分。输入格式输入文件共一行，包含一个自然数，即要拆分的自然数 $n(1 \\le n \\le 20)$。输出格式输出文件\n\n  \n\n  \n\n    \n\n      \nhttps://nanti.jisuanke.com/t/T1248\n\n    \n\n  ", "Tag": "算法分析"}
{"Answer": "它之前的表达是没错的，就像事件A=“今天会下雨” ，事件B=“明天会下雨”，虽然A or B表示今天或明天下雨即今明两天至少1天下雨。如果加个not即 not (A or B) 就表示“今明两天至少1天下雨”的反面事件-------也就是今明两天都不下雨。可以理解成not (A or B)=(not A) and (not B)所以它原来的not (left or right)=(not left) and (not right) 即左空且右空，即左右都空，它原来的注释正确。", "Konwledge_Point": "图的深度优先搜索", "Question": "对称二叉树Python解法\n# 深度优先搜索\n\nclass\n Solution:\n    def is\nSymmetric(\nself\n, \nroot\n: Optional[TreeNode])\n -> \nbool\n:\n        \nif\n not root: # 空树\n            return True\n        def \nDFS(\nleft\n, \nright\n)\n:\n            \nif\n not (left \nor\n right): # 左右子树，都为空\n                return True\n            \nif\n not (left \nand\n right): # 左右子树，一边为空\n                return False\n            \nif\n left.\nval\n != right.\nval\n:\n                return False\n            return \nDFS(\nleft\n.\nleft\n, \nright\n.\nright\n)\n \nand\n \nDFS(\nleft\n.\nright\n, \nright\n.\nleft\n)\n\n        return \nDFS(\nroot\n.\nleft\n, \nroot\n.\nright\n)\n\n\n\n\n\n第五行和第七行我在想and和or是不是弄反了\n还有对left和right有点疑问 ", "Tag": "算法分析"}
{"Answer": "额。。。注释得挺好把输出结果里的坐标数字替换成星号就好了\nfor i, j in res:\n    puzzle[i][j] = \"*\"\n\n如果要保存进txt，还要把之前的迷宫数字都换成字符串，当然，如果你是从txt读取的迷宫矩阵，就没这个问题了。", "Konwledge_Point": "图的深度优先搜索", "Question": "python走迷宫深度优先搜索\n有哦人知道这个程序要怎么改成打印出来的迷宫路径使用星号表示的吗，就是矩阵里面能显示路径\n\n\n\n```python\n\nfrom\n numpy import *\ndef findpath(puzzle, \nstart\n, \nend\n):\n    \n# 四个方向\n\n    d = [(\n-1\n,\n0\n),(\n0\n,\n1\n),(\n1\n,\n0\n),(\n0\n,\n-1\n)]\n    vis = [[\n-1\n \nfor\n _ \nin\n range(\nlen\n(puzzle[\n0\n]))] \nfor\n _ \nin\n range(\nlen\n(puzzle))]\n    \n#迷宫矩阵,0表示路， 1表示墙 \n\n    vis[\nstart\n[\n0\n]][\nstart\n[\n1\n]]=\nstart\n\n    dfs = [\nstart\n]     \n    \nwhile\n dfs:\n        x,y = dfs.pop()    \n#取栈顶及其探查方向\n\n        \nfor\n i \nin\n range(\n4\n): \n#依次检查未探查方向\n\n            m = x+d[i][\n0\n]\n            n = y+d[i][\n1\n]  \n#算出下一位\n\n            puzzle[\nstart\n[\n0\n]][\nstart\n[\n1\n]] = \n6\n \n#把走过的记录为6\n\n            \nif\n \n0\n<=m<\nlen\n(puzzle) \nand\n \n0\n<=n<\nlen\n(puzzle[\n0\n]) \nand\n puzzle[m][n]==\n0\n \nand\n vis[m][n]==\n-1\n:   \n#遇到未探查的新位置 \n\n                dfs.append((x,y))    \n#原位置和下一方向入栈\n\n                dfs.append((m,n))\n                vis[m][n]=(x,y)      \n#新位置入栈\n\n                puzzle[\nstart\n[\n0\n]][\nstart\n[\n1\n]] = \n6\n \n#把走过的记录为6\n\n                \nif\n \nend\n==(m,n): \n#到达出口，打印路径\n\n                    \nreturn\n dfs\n                break   \n#退出内层循环，下次迭代将以新栈顶为当前位置继续\n\n    \nreturn\n dfs  \n#找不到路径\n\n    \npuzzle = zeros((\n10\n, \n10\n), dtype=float) \n# 先创建一个全零方阵puzzle;，并且数据的类型设置为float浮点型\n\nf = \nopen\n(\n'test2.txt'\n) \n# 打开数据文件文件\n\n\nlines\n = f.readlines() \n# 把全部数据文件读到一个列表lines中\n\npuzzle_row = \n0\n  \n# 表示矩阵的行，从0行开始\n\n\nfor\n \nline\n \nin\n \nlines\n: \n# 把lines中的数据逐行读取出\n\n         list = \nline\n.strip(\n'\\n'\n).\nsplit\n(\n' '\n) \n# 处理逐行数据：strip表示把头尾的'\\n'去掉，split表示以空格来分割行数据，然后把处理后的行数据返回到list列表中\n\n         puzzle[puzzle_row:] = list[\n0\n:\n10\n] \n# 把处理后的数据放到方阵A中。list[0:4]表示列表的0,1,2,3列数据放到矩阵A中的A_row行\n\n         puzzle_row += \n1\n \n# 然后方阵A的下一行接着读\n\nprint(puzzle)        \n\nstart\n = eval(input(\n\"请输入起始坐标(x,y)：\"\n))\n\nend\n = \neval\n(\ninput\n(\"请输入终点坐标(\nm\n,\nn\n)：\"))\n\nres = findpath(puzzle, \nstart\n, \nend\n)\n\nif\n res:print(res)\n\nelse\n: print(\n'无路可走'\n)\n\n\n\n\n\n```", "Tag": "算法分析"}
{"Answer": "参考 https://blog.csdn.net/wd1603926823/article/details/128782281 可知：对于答案A：\n    1入；\n1出，3入；\n3出，5入；\n5出，4入；\n4出，2入；\n2出，6入；\n6出，7入；\n7出。    顶点已出完，结束搜索。\n所以顺序是：1 3 5 4 2 6 7\n\n对于答案B：顶点3 后还有接班人5 ，而它直接跳到了4，所以错误。对于答案C：\n    1入；\n1出，5入；\n5出，3入；\n3出，    （3已没有接班人，故此根枝条已捋到底）\n        （需返回上级5，发现有新分叉枝条4、6均未入队过，所以我们先入4）\n     4入；\n4出，2入；\n2出，7入；\n7出，6入；\n6出。     顶点已出完，结束搜索。\n所以顺序是：1 5 3 4 2 7 6\n\n对于答案D：顶点4还有接班人即未捋到底，而它直接跳到了7 ，所以错误。故答案是AC，我觉得你的标准答案A不正确。只能说A是树不分叉的深度优先搜索选择，因为C虽然也正确但树有一个分叉。", "Konwledge_Point": "图的深度优先搜索", "Question": "如图所示，给出由7个顶点组成的无向图。从顶点1出发，对它进行深度优先搜索得到的顶点序列是（\n如图所示，给出由7个顶点组成的无向图。从顶点1出发，对它进行深度优先搜索得到的顶点序列是（a　　）。\nA．1 3 5 4 2 6 7                            B．1 3 4 7 6 2 5\nC．1 5 3 4 2 7 6                            D．1 2 4 7 6 5 3\n\n\n这个深度优先搜索遍历，C选项不也可以吗", "Tag": "算法分析"}
{"Answer": "有具体的说明吗，什么题，什么场景\r\n如果非要到n^2，那就往里填平行边呗，某个图的dfs树种存在横叉边的话，把这些横叉边添加到n^2规模再搜索不就是你要的了。", "Konwledge_Point": "图的深度优先搜索", "Question": "通过深度优先搜索算法生成有向图的DFS树，是否有可能存在横叉边数目等于Ω(n^2)的情况？\n题中n代表树点。我现在能想到的就只有：有向图的最大边数为n(n-1)，但我不知道如何证明出Ω(n^2)？还是说这种情况并不可能？谢谢！", "Tag": "算法分析"}
{"Answer": "这两个都是正确的，以二叉树为例，dfs的思想是沿着一个子树一直找，找不到了就回溯，再换个子树继续找。当左右子树都找完了，就回到上一层，再在上一层换个子树。没有规定，先找哪个子树。所以上面两个答案都是对的", "Konwledge_Point": "图的深度优先搜索", "Question": "如图，关于数据结构 图 的深度优先遍历（DFS） 的遍历顺序问题\n①和② 两个深度优先遍历的顺序 都是正确 DFS吗？这块内容突然混乱了。\n还是说遇到岔路口时候必须走长的那条？", "Tag": "算法分析"}
{"Answer": "\nappend function may or may not modify the underlying array that your slice refers to. So you are not creating a completely new list when using append. I changed helper to match your desired behavior.\nfor i := index; i < length; i++ {\n    if i != index && nums[i] == nums[i - 1] {\n        continue\n    }\n    if nums[i] > target {\n        break\n    }\n    var newList []int\n    newList = append(newList, list...)\n    newList = append(newList, nums[i])\n    helper(nums, i, target - nums[i], newList, resultp, length)\n}\n\n", "Konwledge_Point": "图的深度优先搜索", "Question": "使用Golang时对深度优先搜索结果感到困惑\n\n\n\nI tried to solve the 'Combination Sum' on leetcode, and the result is wrong when using test case:\n\n\n\n\n  \n[7,3,2] 18\n\n\n\n\n\nI used C++ with the same logic and passed, but when using Golang, my result is:\n\n\n\n\n  \n[[2,2,2,2,2,2,2,2,2],[2,2,2,2,2,7,3,3],[2,2,2,2,3,7],[2,2,2,3,3,3,3],[2,2,7,7],[2,3,3,3,7],[3,3,3,3,3,3]]\n\n\n\n\n\nand the correct one should be\n\n\n\n\n  \n[[2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,3,3],[2,2,2,2,3,7],[2,2,2,3,3,3,3],[2,2,7,7],[2,3,3,3,7],[3,3,3,3,3,3]]\n\n\n\n\n\nthe code is shown below:\n\n\n\nimport \"sort\"\nfunc combinationSum(candidates []int, target int) [][]int {\n    result := make([][]int, 0, 0)\n    resultp := &result\n    sort.Ints(candidates)\n    helper(candidates, 0, target, make([]int, 0, 0), resultp, len(candidates))\n    return *resultp\n}\n\nfunc helper(nums []int, index int, target int, list []int, resultp *[][]int, length int) {\n    if target == 0 {\n        *resultp = append(*resultp, list)\n        return\n    }\n    for i := index; i < length; i++ {\n        if i != index && nums[i] == nums[i - 1] {\n            continue\n        }\n        if (nums[i] > target) {\n            break\n        }\n        helper(nums, i, target - nums[i], append(list, nums[i]), resultp, length)\n    }\n}\n\n\n\n\nCan anyone tell me why the result is incorrect, I am just confused about the [2,2,2,2,2,7,3,3] in my answer, why the 7 is before the 3 since the array has been sorted? Or anyone can tell me what mistake I have made in my code \n\n\n\n    ", "Tag": "算法分析"}
{"Answer": "1 2 4 8 9 5 10 11 3 6 7", "Konwledge_Point": "图的深度优先搜索", "Question": "已知一颗满二叉树可以用线性表1 2 3 4 5 6 7 8 9 10 11表示，求出深度优先遍历序列\n已知一颗满二叉树可以用线性表1 2 3 4 5 6 7 8 9 10 11表示，求出深度优先遍历序列", "Tag": "算法分析"}
{"Answer": "你题目的解答代码如下：\n#include <iostream>\nusing namespace std;\n\nint a[100][100];\nint ds[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\nint n, m;\n\nint dfs(int y,int x)\n{\n    if (y<0 || y>=n || x<0 || x>=m || a[y][x]!=1)\n        return 0;\n    int i,sum = 1;\n    a[y][x] = 0;  //这块草坪已经烧过了\n    for (i = 0; i < 4; i++)\n    {\n        sum += dfs(y+ds[i][0], x+ds[i][1]);\n    }\n    return sum;\n}\n\nint main()\n{\n    int i, j, d, max;\n    while (true)\n    {\n        cin >> n >> m;\n        if (n == 0 && m == 0)\n            break;\n        for (i = 0; i < n; i++)\n        {\n            for (j = 0; j < m; j++)\n            {\n                cin >> a[i][j];\n            }\n        }\n        max = 0;\n        for (i = 0; i < n; i++)\n        {\n            for (j = 0; j < m; j++)\n            {\n                if (a[i][j] == 1)\n                {\n                    d = dfs(i, j);\n                    if (d > max)\n                        max = d;\n                }\n            }\n        }\n        cout << max << endl;\n    }\n    return 0;\n}\n\n\n\n\n如有帮助，请点击我的回答下方的【采纳该答案】按钮帮忙采纳下，谢谢!\n", "Konwledge_Point": "图的深度优先搜索", "Question": "关于这道深度优先遍历的问题，如何解决？（C++）\n【问题描述】\n给你一块n\nm的草坪，问如果只点一次火，最多能烧多少块草坪。可以从n\nm的草地中任意一个地方开始点火，火只能往上下左右传递，没有草的地方不能燃烧。\n【输入格式】\n输入由多个测试例组成。每个测试例的第一行含两个整数n和m, (1 <=n,m<=100), 分别表示01矩阵的行数与列数，\n后面紧跟着n行，每行含m个整数0或1，1代表草坪，0表示啥也没有，相邻两个整数之间用一个空格隔开，两个测\n试例之间用一个空行隔开，最后一个测试例之后隔一个空行，最后一行含有两个整数0，表示输入结束。\n【输出格式】\n每个测试例对应一行输出，含一个整数，表示只点一次火最多能烧的草坪个数。\n【样例输入】\n5 6\n0 1 1 0 0 1\n1 1 0 1 0 1\n0 1 0 0 1 0\n0 0 0 1 1 1\n1 0 1 1 1 0\n\n\n0 0\n【样例输出】\n7\n【提示】\n深度优先搜索DFS的应用\n\n\n请问C++如何用深度优先搜索解决呢", "Tag": "算法分析"}
{"Answer": "试着写了一下，应该还可以优化\ndef findpath(puzzle, start, end):\n    d = [(-1,0),(0,1),(1,0),(0,-1)]\n    vis = [[-1 for _ in range(len(puzzle[0]))] for _ in range(len(puzzle))]\n    vis[start[0]][start[1]]=start\n    dfs = [start]\n    while dfs:\n        x,y = dfs.pop()\n        for i in range(4):\n            m = x+d[i][0]\n            n = y+d[i][1]\n            if 0<=m<len(puzzle) and 0<=n<len(puzzle[0]) and puzzle[m][n]==0 and vis[m][n]==-1:\n                dfs.append((x,y))\n                dfs.append((m,n))\n                vis[m][n]=(x,y)\n                if end==(m,n):return dfs\n                break   \n    return dfs\n\npuzzle = [\n    [0,0,0,0],\n    [0,1,1,0],\n    [0,0,1,1],\n    [1,0,0,0]\n]\nstart = eval(input(\"请输入起始坐标(x,y)：\"))\nend = eval(input(\"请输入终点坐标(m,n)：\"))\nres = findpath(puzzle, start, end)\nif res:print(res)\nelse: print('无路可走')\n\n测试：\n请输入起始坐标(x,y)：(0,0)\n请输入终点坐标(m,n)：(3,3)\n[(0, 0), (1, 0), (2, 0), (2, 1), (3, 1), (3, 2), (3, 3)]\n", "Konwledge_Point": "图的深度优先搜索", "Question": "深度优先搜索怎么实现走迷宫呀\n怎么用dfs深度优先搜索实现走迷宫呀,怎么实现两个坐标中走迷宫出一个路径", "Tag": "算法分析"}
{"Answer": "节点会有分叉是什么意思？你每行数据只有两个数据不同，是根据数据的大小排序吗？", "Konwledge_Point": "图的深度优先搜索", "Question": "如何将csv文件中的节点数据通过深度优先搜索进行排序，再进行重新编号\n举例：\n这些节点会有分叉，如何通过深度优先搜索进行排序编号。本人对此方面尚未接触过，求详细解答", "Tag": "算法分析"}
{"Answer": "不知道你这个问题是否已经解决, 如果还没有解决的话: 这篇文章讲的很详细，请看：找到搜索二叉树中两个错误的节点如果你已经解决了该问题, 非常希望你能够分享一下解决方案, 写成博客, 将相关链接放在评论区, 以帮助更多的人 ^-^", "Konwledge_Point": "图的深度优先搜索", "Question": "第二题深度优先搜索怎么做\n\n\n\n ", "Tag": "算法分析"}
{"Answer": "#define _CRT_SECURE_NO_WARNINGS\n#include \"stdio.h\"\n#include \"stdlib.h\"\n#include \"string.h\"\n#define MAXSIZE 3\n#define MAXNODESIZE 10\n\ntypedef struct Branch\n{\n    int index;\n    struct Branch* next;\n}branch;\n\ntypedef struct Tnode\n{\n    char data[MAXSIZE]=\"\\0\";\n    branch* first;\n}tnode;\n\nvoid create(tnode tree[], char str[], int cnt)  //创建邻接表\n{\n    int j = 0, t = 0;\n   \n\n    //printf(\"一共有%d个头节点\\n\", cnt);\n    for (int i = 0; i < cnt; i++)\n    {\n        j = 0;\n        while (str[t] != '/')  //遇到/就开始找换行符\\n，并跳转到下一行，录入下一行头节点\n        {\n            tree[i].data[j] = str[t];\n            j++;\n            t++;\n        }\n        tree[i].data[j] = '\\0';  //为tree[i].data加入终止符\n        tree[i].first = NULL;\n        while (str[t] != '\\n' && str[t] != EOF)  //跳转至下一行，准备录下一行的头节点\n            t++;\n        t++;\n        //puts(tree[i].data);  //将该行的头节点中的串打印出来以检验头节点的串是否成功录入\n    }\n    //头节点初始化完成，接下来将子节点连接到\n    t = 0;\n    int size = strlen(str);\n    for (int i = 0; i < cnt && t < size; i++)\n    {\n        while (t < size && str[t] != '/')  //先跳过头节点\n            t++;\n        t++;\n        // p = (branch*)malloc(sizeof(branch));\n        while (t < size &&str[t] != '\\n' && str[t] != '\\0') // 这里是bug1: t是数字， 也要可能是空了\n        {\n            j = 0;\n            char string[MAXSIZE];\n            while (t < size && str[t] != '/' && str[t] != '\\n')//将字符串截取出来 bug2:不能处理换行符\n            {\n                string[j] = str[t];\n                j++;\n                t++;\n            }\n            //此时str[t]=='/'\n            string[j] = '\\0';\n            //printf(\"子串为:\");\n            //puts(string);\n            int target = -1;\n            for (int n = 0; n < cnt; n++)\n            {\n                if (!strcmp(tree[n].data, string)) {\n                    target = n;\n                    break;\n                }\n            }\n            branch* p = tree[i].first;\n            //bug3:插入方式不正确，应该后插入\n            if (p == NULL) {\n                p = (branch*)malloc(sizeof(branch));\n                p->index = target;\n                p->next = NULL;\n                tree[i].first = p;\n            }\n            else {\n                while (p->next != NULL) {\n                    p = p->next;\n                }\n                p->next = (branch*)malloc(sizeof(branch));\n                p->next->index = target;\n                p->next->next = NULL;\n            }\n            if (t >= size ||str[t] == '\\n') {\n                break;\n            }\n            t++;  //使t指向下一个单词开头 \n        }\n        //此时t指向\\n\n        t++;  //将t指向下一行第一个字符\n    }\n}\n\nvoid dfs(int visited[], tnode tree[], int v);\n\nvoid DFS(tnode tree[])  //对邻接表进行深度优先遍历\n{\n    int cnt = 0;\n    int visited[MAXNODESIZE];\n  \n    for (int i = 0; i < MAXNODESIZE; i++) {\n        if (strlen(tree[i].data)>=2){\n            cnt++;\n        }\n        else {\n            break;\n        }\n    }\n    for (int i = 0; i < cnt; i++) visited[i] = 0;\n    \n    for (int i = 0; i < cnt; i++) {\n        if (!visited[i]) {\n            //没有遍历过\n            dfs(visited, tree,   i);\n        }\n    }\n}\nvoid dfs(int visited[], tnode tree[],   int v) {\n    tnode t = tree[v];\n    puts(t.data);\n    visited[v] = 1;\n \n    for (branch* w = t.first; w != NULL; w = w->next) {\n        if (!visited[w->index]) { \n            dfs(visited, tree, w->index);\n        }\n    }\n\n}\n \n\nvoid visit(tnode* node, char str[])  //对结点进行访问\n{\n    if (!strcmp(node->data, str))\n    {\n        printf(\"该结点存在！\");\n    }\n}\n\nvoid FillInText(char str[], FILE* fp)  //将文件中内容传入str中\n{\n    char ch;\n    int length = 0;\n    ch = fgetc(fp);\n    while (ch != EOF)\n    {\n        str[length] = ch;\n        ch = fgetc(fp);\n        length++;\n    }\n    str[length] = '\\0';\n}\n\nint getCount(char str[])  //获取邻接表头节点个数\n{\n    int cnt = 0;\n    for (int i = 0; i < strlen(str); i++)\n    {\n        if (str[i] == '\\n')\n            cnt++;\n    }\n    return cnt + 1;\n}\n\nint main()\n{\n    FILE* fp;\n    tnode tree[MAXNODESIZE];\n    \n    char ch, str[100];\n    fp = fopen(\"C:\\\\Users\\\\Lenovo\\\\Desktop\\\\1\\\\test.txt\", \"r\");\n    if (fp == NULL)\n    {\n        printf(\"文件打开失败\\n\");\n        exit(0);\n    }\n    FillInText(str, fp);\n    fclose(fp);\n    //printf(\"文件中的文本内容为:\\n\");\n    //puts(str);\n    create(tree, str, getCount(str)); \n    DFS(tree);\n    return 0;\n}\n", "Konwledge_Point": "图的深度优先搜索", "Question": "对邻接表进行深度优先遍历\n问题：\n将文本文件中的文本数据提取，并以此建立邻接表，再进行树的深度优先搜索。\n遇到的问题：\n在创建邻接表的时候，感觉逻辑有点混乱。\n我先是把邻接表的头节点都先加载出来，再将子节点接到头节点上。\n子节点接到头结点这个环节，感觉有点乱。\n文本文件内容：\n\n\n\n\n目标：\n将该内容变成存储内的邻接表\n\n\n\n\n并对该邻接表进行深度优先遍历\n\n\n求指教！\n以下为我的屎山代码XD（目前程序还是有问题的，问题在子节点连接到头节点那一块）：\n\n\n#\ndefine\n _CRT_SECURE_NO_WARNINGS\n\n\n#\ninclude\n \n\"stdio.h\"\n\n\n#\ninclude\n \n\"stdlib.h\"\n\n\n#\ninclude\n \n\"string.h\"\n\n\n#\ndefine\n MAXSIZE 20\n\n\ntypedef\n \nstruct\n \nBranch\n\n{\n    \nint\n index;\n    \nstruct\n \nBranch\n* next;\n}branch;\n\n\ntypedef\n \nstruct\n \nTnode\n\n{\n    \nchar\n data[MAXSIZE];\n    branch* first;\n}tnode;\n\n\nvoid\n \ncreate\n(tnode tree[],\nchar\n str[],\nint\n cnt)\n  \n//创建邻接表\n\n\n{\n    \nint\n j = \n0\n, t = \n0\n;\n    \nchar\n string[MAXSIZE];\n    branch* p;\n    \nprintf\n(\n\"一共有%d个头节点\\n\"\n, cnt);\n    \nfor\n (\nint\n i = \n0\n; i < cnt; i++)\n    {\n        j = \n0\n;\n        \nwhile\n (str[t] != \n'/'\n)  \n//遇到/就开始找换行符\\n，并跳转到下一行，录入下一行头节点\n\n        {\n            tree[i].data[j] = str[t];\n            j++;\n            t++;\n        }\n        tree[i].data[j] = \n'\\0'\n;  \n//为tree[i].data加入终止符\n\n        tree[i].first = \nNULL\n;\n        \nwhile\n (str[t] != \n'\\n'\n&&str[t]!=EOF)  \n//跳转至下一行，准备录下一行的头节点\n\n            t++;\n        t++;\n        \nputs\n(tree[i].data);  \n//将该行的头节点中的串打印出来以检验头节点的串是否成功录入\n\n    }\n    \n//头节点初始化完成，接下来将子节点连接到\n\n    t = \n0\n;\n    \nfor\n (\nint\n i = \n0\n; i < cnt; i++)\n    {\n        \nwhile\n (str[t] != \n'/'\n)  \n//先跳过头节点\n\n            t++;\n        t++;\n        p = (branch*)\nmalloc\n(\nsizeof\n(branch));\n        \nwhile\n (t != \n'\\n'\n)\n        {\n            j = \n0\n;\n            \nfor\n (\nint\n n = \n0\n; n < \nstrlen\n(string); n++)\n//字符串清空\n\n                string[n] = \n'\\0'\n;\n            \nwhile\n (str[t] != \n'/'\n)\n//将字符串截取出来\n\n            {\n                string[j] = str[t];\n                j++;\n                t++;\n            }\n            \n//此时str[t]=='/'\n\n            string[j] = \n'\\0'\n;\n            \nprintf\n(\n\"子串为:\"\n);\n            \nputs\n(string);\n            \nfor\n (\nint\n n = \n0\n; n < cnt; n++)\n            {\n                \nif\n (!\nstrcmp\n(tree[n].data, string))\n                    p->index = n;\n            }\n            p->next = tree[i].first;\n//将p接入头节点中\n\n            tree[i].first = p;\n            t++;  \n//使t指向下一个单词开头\n\n            p = (branch*)\nmalloc\n(\nsizeof\n(branch));\n        }\n        \n//此时t指向\\n\n\n        t++;  \n//将t指向下一行第一个字符\n\n    }\n}\n\n\nvoid\n \nDFS\n(tnode tree[])\n  \n//对邻接表进行深度优先遍历\n\n\n{\n\n}\n\n\nvoid\n \nvisit\n(tnode* node,\nchar\n str[])\n  \n//对结点进行访问\n\n\n{\n    \nif\n (!\nstrcmp\n(node->data, str))\n    {\n        \nprintf\n(\n\"该结点存在！\"\n);\n    }\n}\n\n\nvoid\n \nFillInText\n(\nchar\n str[], FILE* fp)\n  \n//将文件中内容传入str中\n\n\n{\n    \nchar\n ch;\n    \nint\n length = \n0\n;\n    ch = \nfgetc\n(fp);\n    \nwhile\n (ch != EOF)\n    {\n        str[length] = ch;\n        ch = \nfgetc\n(fp);\n        length++;\n    }\n    str[length] = \n'\\0'\n;\n}\n\n\nint\n \ngetCount\n(\nchar\n str[])\n  \n//获取邻接表头节点个数\n\n\n{\n    \nint\n cnt = \n0\n;\n    \nfor\n (\nint\n i = \n0\n; i < \nstrlen\n(str); i++)\n    {\n        \nif\n (str[i] == \n'\\n'\n)\n            cnt++;\n    }\n    \nreturn\n cnt + \n1\n;\n}\n\n\nint\n \nmain\n()\n\n\n{\n    FILE* fp;\n    tnode tree[MAXSIZE];\n    \nchar\n ch, str[\n100\n];\n    fp = \nfopen\n(\n\"test.txt\"\n, \n\"r\"\n);\n    \nif\n (fp == \nNULL\n)\n    {\n        \nprintf\n(\n\"文件打开失败\\n\"\n);\n        \nexit\n(\n0\n);\n    }\n    \nFillInText\n(str, fp);\n    \nprintf\n(\n\"文件中的文本内容为:\\n\"\n);\n    \nputs\n(str);\n    \ncreate\n(tree, str,\ngetCount\n(str));\n    \nfclose\n(fp);\n    \nreturn\n \n0\n;\n}\n\n", "Tag": "算法分析"}
{"Answer": "很明显就是你的内存分配以后，没有对其中的字段，比如firstChild nextSibling初始化\r\n\r\n邻接表G建立的有问题，排查一下邻接矩阵转换到邻接表的函数\r\n\r\n# 没有采纳之前先回答你这么多吧", "Konwledge_Point": "图的深度优先搜索", "Question": "求教大佬们，这个“读取位置 0xCCCCCCCC 时发生访问冲突。”的异常该如何解决？\n程序是数据结构的图的存储和遍历实验，功能是输入一个无向图并将其转换成邻接矩阵，然后把邻接矩阵变成邻接表，最后深度优先遍历该邻接表生成树（VS2017）：\n\n\n\n#include \n#include \n#include \n#include \n#include\nusing namespace std;\ntypedef int InfoType;\n#define MAXV 100                //最大顶点个数\n#define INF 32767               //INF表示∞\n#define isLetter(a)  ((((a)>='a')&&((a)<='z')) || (((a)>='A')&&((a)<='Z')))\n#define LENGTH(a)  (sizeof(a)/sizeof(a[0]))\n//以下定义邻接矩阵类型\ntypedef struct\n{\n    int no;                     //顶点编号\n    InfoType info;              //顶点其他信息\n} VertexType;                   //顶点类型\ntypedef struct              //图的定义\n{\n    char vexnum[MAXV];\n    int edges[MAXV][MAXV];      //邻接矩阵\n    int n, e;                       //顶点数，边数\n    VertexType vexs[MAXV];      //存放顶点信息\n} MGraph, *PGragh;                      //图的邻接矩阵类型\n//以下定义邻接表类型\ntypedef struct ANode            //边的节点结构类型\n{\n    int adjvex;                 //该边的终点位置\n    struct ANode *nextarc = NULL;       //指向下一条边的指针\n    InfoType *info;             //该边的相关信息,这里用于存放权值\n} ArcNode;\ntypedef int Vertex;\ntypedef struct Vnode            //邻接表头节点的类型\n{\n    Vertex data;                //顶点信息\n    ArcNode *firstarc;          //指向第一条边\n} VNode;\ntypedef VNode AdjList[MAXV];    //AdjList是邻接表类型\ntypedef struct\n{\n    AdjList adjlist;            //邻接表\n    int n, e;                   //图中顶点数n和边数e\n} ALGraph;                      //图的邻接表类型\n\nvoid MatToList(MGraph *g, ALGraph *G)\n//将邻接矩阵g转换成邻接表G\n{\n    int i, j;\n    ArcNode *p;\n    //G = (ALGraph *)malloc(sizeof(ALGraph));\n    for (i = 0; in; i++)                    //给邻接表中所有头节点的指针域置初值\n        G->adjlist[i].firstarc = NULL;\n    for (i = 0; in; i++)                    //检查邻接矩阵中每个元素\n    for (j = g->n - 1; j >= 0; j--)\n    if (g->edges[i][j] != 0)        //存在一条边\n    {\n        p = (ArcNode *)malloc(sizeof(ArcNode)); //创建一个节点*p\n        p->adjvex = j;\n        p->nextarc = G->adjlist[i].firstarc;        //采用头插法插入*p\n        G->adjlist[i].firstarc = p;\n    }\n    G->n = g->n; G->e = g->e;\n    //return G;\n}\n\nvoid DispMat(MGraph *g)\n//输出邻接矩阵g\n{\n    int i, j;\n    for (i = 0; in; i++)\n    {\n        for (j = 0; jn; j++)\n            printf(\"%3d\", g->edges[i][j]);\n        printf(\"\\n\");\n    }\n}\nvoid DispAdj(ALGraph G)\n//输出邻接表G\n{\n    int i;\n    ArcNode *p;\n    for (i = 0; iadjvex);\n            cout << p->adjvex << \" \";\n            p = p->nextarc;\n        }\n        printf(\"\\n\");\n    }\n}\nstatic int get_position(MGraph g, char ch)\n{\n    int i;\n    for (i = 0; i(vex * (vex - 1))))\n    {\n        printf(\"input error: invalid parameters!\\n\");\n        return NULL;\n    }\n\n    if ((pG = (MGraph*)malloc(sizeof(MGraph))) == NULL)\n        return NULL;\n    memset(pG, 0, sizeof(MGraph));\n\n    // 初始化顶点数和边数\n    pG->n = vex;\n    pG->e = edge;\n    // 初始化\"顶点\"\n    printf(\"输入各顶点名称：\\n\");\n    for (i = 0; i < pG->n; i++)\n    {\n        printf(\"vertex(%d): \", i);\n        pG->vexnum[i] = read_char();\n    }\n\n    // 初始化\"边\"\n    for (i = 0; i < pG->e; i++)\n    {\n        // 读取边的起始顶点和结束顶点\n        printf(\"edge(%d):\", i);\n        c1 = read_char();\n        c2 = read_char();\n\n        p1 = get_position(*pG, c1);\n        p2 = get_position(*pG, c2);\n        if (p1 == -1 || p2 == -1)\n        {\n            printf(\"input error: invalid edge!\\n\");\n            free(pG);\n            return NULL;\n        }\n\n        pG->edges[p1][p2] = 1;\n        pG->edges[p2][p1] = 1;\n    }\n\n    return pG;\n}\n// 打印矩阵队列图\n\nvoid print_graph(MGraph G)\n{\n    int i, j;\n\n    printf(\"Martix Graph:\\n\");\n    for (i = 0; i < G.n; i++)\n    {\n        for (j = 0; j < G.n; j++)\n            printf(\"%d \", G.edges[i][j]);\n        printf(\"\\n\");\n    }\n}\n//创建一个树的左子女，右兄弟结构\ntypedef struct node\n{\n    int data;\n    node *firstChild = NULL;\n    node *nextSibling = NULL;\n}TreeNode, *BinTree;\nint visited[MAXV];\nvoid Dfs(ALGraph G, int i, BinTree &T)\n{\n    visited[i] = 1;\n    bool first = true;//表示是否为当前节点第一个孩子\n    TreeNode *locat = new TreeNode;//同样是定位作用\n    while (G.adjlist[i].firstarc != NULL)//从此节点出发，访问邻接节点。\n    {\n        if (visited[G.adjlist[i].firstarc->adjvex] == 0)\n        {\n            visited[G.adjlist[i].firstarc->adjvex] = 1;\n            TreeNode *t = new TreeNode;//建立一颗小树\n            t->data = G.adjlist[i].firstarc->adjvex;\n            if (first)//是当前节点第一个孩子\n            {\n                T->nextSibling = t;//建立右孩子\n                first = false;//表示不是传进来的第一个孩子,则是孩子们的兄弟\n            }\n            else\n            {\n                locat->nextSibling = t;\n            }\n            locat = t;\n            Dfs(G, G.adjlist[i].firstarc->adjvex, t);//继续对小树找兄弟\n        }\n        G.adjlist[i].firstarc = G.adjlist[i].firstarc->nextarc;\n    }\n}\n\nvoid DFS_Traverse(ALGraph G, BinTree &T)\n{\n    TreeNode *locat = new TreeNode;//此处定义一个定位指针，用来定位当前树的位置\n    for (int i = 1; i <= G.n; i++)\n    {\n        visited[i] = 0;\n    }\n    for (int i = 1; i <= G.n; i++)\n    {\n        if (visited[i] == 0)\n        {\n            TreeNode *t = new TreeNode;//这代表一个小树\n            t->data = G.adjlist[i].data;\n            if (T == NULL)\n            {\n                T = t;//若树为空，建立头节点\n            }\n            else\n            {\n                locat->nextSibling = t;//若树不空，则是森林，插入右兄弟\n            }\n            locat = t;//定位至小树\n            Dfs(G, i, locat);//建立小树\n        }\n    }\n}\n\n//建立图深度优先搜索森林\nvoid DFSForest(ALGraph G, BinTree &T)\n{\n    DFS_Traverse(G, T);\n}\nvoid Display(BinTree T)\n{\n    if (T)\n    {\n        cout << T->data << ' ';\n        Display(T->firstChild);\n        Display(T->nextSibling);\n    }\n}\n\n\n\n//以下主函数用作调试\nint main()\n{\n    //int i, j;\n    MGraph* g, g1;\n    ALGraph G;\n    BinTree T;\n    g = create_graph();\n    printf(\"\\n\");\n    printf(\" 无向图G的邻接矩阵:\\n\");\n    DispMat(g);\n\n\n    //G = (ALGraph *)malloc(sizeof(ALGraph));\n    //M = (ALGraph *)malloc(sizeof(ALGraph));\n    printf(\" 图G的邻接矩阵转换成邻接表，顶点名称用编号表示:\\n\");\n    MatToList(g, &G);\n    DispAdj(G);\n    DFSForest(G, T);\n    Display(T);\n\n\n    system(\"pause\");\n}\n\n\n\n\n运行程序，输入顶点和边的信息，能够输出邻接矩阵和邻接表，但到了生成森林那一步就报异常：\n\n和同学研究了一下发现问题可能是出在执行到函数\n\n\n\nvoid DFS_Traverse(ALGraph G, BinTree &T)\n{\n    TreeNode *locat = new TreeNode;//此处定义一个定位指针，用来定位当前树的位置\n    for (int i = 1; i <= G.n; i++)\n    {\n        visited[i] = 0;\n    }\n    for (int i = 1; i <= G.n; i++)\n    {\n        if (visited[i] == 0)\n        {\n            TreeNode *t = new TreeNode;//这代表一个小树\n            t->data = G.adjlist[i].data;\n            if (T == NULL)\n            {\n                T = t;//若树为空，建立头节点\n            }\n            else\n            {\n                locat->nextSibling = t;//若树不空，则是森林，插入右兄弟\n            }\n            locat = t;//定位至小树\n            Dfs(G, i, locat);//建立小树\n        }\n    }\n}\n\n\n\n\n的最后一个for中的Dfs（G，i，locat）；这一句时出了问题，若在该处设置断点再重新运行程序并输入测试数据：\n\n然后按F11逐行运行，就跳到了函数Dfs（）那里：\n\n这时候按“继续”继续运行，到第二次循环时异常就出现了，请教大佬我应该如何修改这个程序，谢谢", "Tag": "算法分析"}
{"Answer": "给你写了个树，然后按照二叉树排序了一个数组，然后按中序遍历打印树的结点值\n\n\npublic class Tree {\n\n    public int value;\n    public Tree left;\n    public Tree right;\n\n    Tree(int v) {\n        value = v;\n    }\n\n    public void AddLeft(int v) {\n        left = new Tree(v);\n    }\n\n    public void AddRight(int v) {\n        right = new Tree(v);\n    }\n\n    public void Add(int v) {\n        if (v < value) {\n            if (left == null) {\n                AddLeft(v);\n            } else {\n                left.Add(v);\n            }\n        } else {\n            if (right == null) {\n                AddRight(v);\n            } else {\n                right.Add(v);\n            }\n        }\n    }\n\n    public void Print() {\n        if (left != null) {\n            left.Print();\n        }\n        System.out.println(value);\n        if (right != null) {\n            right.Print();\n        }\n    }\n\n    public static void main(String[] args) {\n        int values[] = new int[] { 4, 2, 3, 1, 5, 6, 2, 7, 8 };\n        Tree bt = new Tree(values[0]);\n        for (int i = 1; i < values.length; i++) {\n            bt.Add(values[i]);\n        }\n        bt.Print();\n    }\n\n}\n\n", "Konwledge_Point": "图的深度优先搜索", "Question": "二叉树怎么打印，为什么图中的left和right会报红？\n\n\n\n\nimport\n javax.swing.tree.TreeNode;  \n//这玩意儿也有导包，可以在非主方法里赋类型啥的\n\n\nimport\n java.util.ArrayList;\n\nimport\n java.util.List;\n\n\npublic\n \nclass\n \ndemoEz94\n {  \n//深度优先搜索跟递归有关跟深度优先搜索也有关\n\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(String[] args)\n {\n        \nTree\n \nbt\n \n=\n \nnew\n \nTree\n();\n        bt.createBinTree(bt.root);\n    }\n\n\n\n    \npublic\n List \nsolution\n(TreeNode root)\n{\n        List res = \nnew\n \nArrayList\n();\n        inorder(root, res);\n        \nreturn\n res;\n\n    }\n\n    \npublic\n \nvoid\n \ninorder\n(TreeNode root, List res)\n{\n        \nif\n(root == \nnull\n){\n            \nreturn\n;\n        }\n        inorder(root.left, res);\n        res.add(root.val);\n        inorder(root.right, res);\n\n    }\n}\n\n", "Tag": "算法分析"}
{"Answer": "xx✔x", "Konwledge_Point": "图的深度优先搜索", "Question": "请问这几句话哪几句是说法正确的？\n1.⼴度优先搜索和深度优先搜索不可以互相转化。\n2.如果递推得到的答案很⼤，需要取模，可以只在算出结果后取模，在中间过程不⽤取模。\n3.递推需要严格的边界条件和数据范围。\n4.编译正确，并且样例输出正确的代码，提交之后⼀定可以AC。", "Tag": "算法分析"}
{"Answer": "\n#include<bits/stdc++.h>\nusing namespace std;\nint ans[21];      //用于存放答案\nint n, total;    //总方案数\nvoid pr(int d){   //按照要求打印答案\n    total+=1;\n    cout<<n<<\"=\";\n    for(int i=1; i<=d-1; i++)cout<<ans[i]<<\"+\";\n    cout<<ans[d]<<endl;\n}\nvoid dfs(int dep, int rest){\n    if(rest==0){\n        if(dep>2){   //避免单独值的出现\n            pr(dep-1);\n            return;\n        }\n    }\n    for(int i=ans[dep-1]; i<=rest; i++){\n        ans[dep]=i;\n        dfs(dep+1, rest-i);\n    }\n}\nint main()\n{\n    cin>>n;\n    ans[0]=1;//初始化拆，18行循环语句的初始值\n    dfs(1, n);\n    //cout<<total;\n    return 0;\n}\n", "Konwledge_Point": "图的深度优先搜索", "Question": "请问谁能告诉我这道题的思路c++\n\n\n\n  \n自然数拆分 - 题库 - 计蒜客\n\n  \n题号：T1248；知识点：深度优先搜索；难度：普及T2；对于任意大于 $1$ 的自然数 $n$，总是可以拆分成若干个小于 $n$ 的自然数之和。现请你编写程序求出 $n$ 的所有拆分。输入格式输入文件共一行，包含一个自然数，即要拆分的自然数 $n(1 \\le n \\le 20)$。输出格式输出文件\n\n  \n\n  \n\n    \n\n      \nhttps://nanti.jisuanke.com/t/T1248\n\n    \n\n  ", "Tag": "算法分析"}
{"Answer": "它之前的表达是没错的，就像事件A=“今天会下雨” ，事件B=“明天会下雨”，虽然A or B表示今天或明天下雨即今明两天至少1天下雨。如果加个not即 not (A or B) 就表示“今明两天至少1天下雨”的反面事件-------也就是今明两天都不下雨。可以理解成not (A or B)=(not A) and (not B)所以它原来的not (left or right)=(not left) and (not right) 即左空且右空，即左右都空，它原来的注释正确。", "Konwledge_Point": "图的深度优先搜索", "Question": "对称二叉树Python解法\n# 深度优先搜索\n\nclass\n Solution:\n    def is\nSymmetric(\nself\n, \nroot\n: Optional[TreeNode])\n -> \nbool\n:\n        \nif\n not root: # 空树\n            return True\n        def \nDFS(\nleft\n, \nright\n)\n:\n            \nif\n not (left \nor\n right): # 左右子树，都为空\n                return True\n            \nif\n not (left \nand\n right): # 左右子树，一边为空\n                return False\n            \nif\n left.\nval\n != right.\nval\n:\n                return False\n            return \nDFS(\nleft\n.\nleft\n, \nright\n.\nright\n)\n \nand\n \nDFS(\nleft\n.\nright\n, \nright\n.\nleft\n)\n\n        return \nDFS(\nroot\n.\nleft\n, \nroot\n.\nright\n)\n\n\n\n\n\n第五行和第七行我在想and和or是不是弄反了\n还有对left和right有点疑问 ", "Tag": "算法分析"}
{"Answer": "\n有帮助的话，希望能够采纳支持一下，谢谢！\n\n\"\"\"\n-*- coding:utf-8 -*-\nAuthor：yang-roc\nQQ:327844461\nEmail：aida_pc@qq.com\nTime: 2021-07-30\n\"\"\"\n\nclass testMedium200:  # dfs  deep-first search  树分支深度优先搜索\n    def dfs(self, grid, r, c):\n        grid[r][c] = 0\n        nr, nc = len(grid), len(grid[0])\n        for x, y in [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]:\n            if 0 <= x < nr and 0 <= y < nc and grid[x][y] == '1':\n                self.dfs(grid, x, y)\n\n    def numIslands(self, grid):  # grid: List[List(str)] #集合字符串最后以集合的方式接受输出打印\n        nr = len(grid)\n        if nr == 0:\n            return 0\n        nc = len(grid[0])\n        num_islands = 0\n        for r in range(nr):\n            for c in range(nc):\n                if grid[r][c] == '1':\n                    num_islands += 1\n                    self.dfs(grid, r, c)\n        return num_islands\n\n\nif __name__ == '__main__':\n    t = testMedium200()\n    # 示例①\n    grid1 = [\n        [\"1\", \"1\", \"1\", \"1\", \"0\"],\n        [\"1\", \"1\", \"0\", \"1\", \"0\"],\n        [\"1\", \"1\", \"0\", \"0\", \"0\"],\n        [\"0\", \"0\", \"0\", \"0\", \"0\"]\n    ]\n    print(t.numIslands(grid1))\n    # 示例②\n    grid2 = [\n        [\"1\", \"1\", \"0\", \"0\", \"0\"],\n        [\"1\", \"1\", \"0\", \"0\", \"0\"],\n        [\"0\", \"0\", \"1\", \"0\", \"0\"],\n        [\"0\", \"0\", \"0\", \"1\", \"1\"]\n    ]\n    print(t.numIslands(grid2))\n\n 程序运行截图：\n", "Konwledge_Point": "图的深度优先搜索", "Question": "leetcode200题 dfs怎么打印呀，不会打印\n\n\n\n\n\n\nclass\n \ntestMedium200\n:      \n#dfs  deep-first search  树分支深度优先搜索\n\n    \ndef\n \ndfs\n(\nself, grid, r, c\n):\n        grid[r][c] = \n0\n\n        nr, nc = \nlen\n(grid), \nlen\n(grid[\n0\n])\n        \nfor\n x, y \nin\n [(r-\n1\n,c),(r+\n1\n, c), (r, c-\n1\n), (r, c+\n1\n)]:\n            \nif\n \n0\n <= x < nr \nand\n \n0\n <= y <nc \nand\n grid[x][y] == \n'1'\n:\n                self.dfs(grid, x, y)\n\n\n    \ndef\n \nnumIslands\n(\nself, grid\n): \n#grid: List[List(str)] #集合字符串最后以集合的方式接受输出打印\n\n        nr = \nlen\n(grid)\n        \nif\n nr == \n0\n:\n            \nreturn\n \n0\n\n        nc = \nlen\n(grid[\n0\n])\n\n        num_islands = \n0\n\n        \nfor\n r \nin\n \nrange\n(nr):\n            \nfor\n c \nin\n \nrange\n(nc):\n                \nif\n grid[r][c] == \n'1'\n:\n                    num_islands += \n1\n\n                    self.dfs(grid, r , c)\n\n        \nreturn\n num_islands\n\n    grid = [  [\n\"1\"\n,\n\"1\"\n,\n\"1\"\n,\n\"1\"\n,\n\"0\"\n],  [\n\"1\"\n,\n\"1\"\n,\n\"0\"\n,\n\"1\"\n,\n\"0\"\n],[\n\"1\"\n,\n\"1\"\n,\n\"0\"\n,\n\"0\"\n,\n\"0\"\n],[\n\"0\"\n,\n\"0\"\n,\n\"0\"\n,\n\"0\"\n,\n\"0\"\n\n    \nif\n __name__ == \n'__main__'\n:\n     t = testMedium200()\n    target = \n9\n\n    \nprint\n(t.dfs(grid))\n", "Tag": "算法分析"}
{"Answer": "不就调用一下方法吗。\n#include<stdio.h>\n#include<stdlib.h>\n#define MAXV 1000 //最大顶点数设为1000//\ntypedef struct { //定义结构体类型//\nint Visited[MAXV]; //顶点标记//\nint Edges[MAXV][MAXV]; //邻接矩阵数组//\nint VertexN,EdgeN; //顶点和边数//\n}Graph; //用邻接矩阵存储的图结构体//\n\nvoid InitializeG(Graph*G)\n{ //图的初始化//\nint i,j;\nfor(i=0;i<MAXV;i++)\n{\nfor(j=0;j<MAXV;j++)\nG->Edges[i][j]=0;\nG->Visited[i]=0;\n}\nG->VertexN=G->EdgeN=0;\n}\n\nvoid ReadG(Graph*G) //读入并存储一个图//\n{\nint i,V1,V2;\nscanf(\"%d%d\",&G->VertexN,&G->EdgeN); //用户输入顶点数和边数//\nfor(i=0;i<G->EdgeN;i++)\n{\nscanf(\"%d%d\",&V1,&V2); //输入顶点名称，比坐标大1（1到N）//\nG->Edges[V1-1][V2-1]=G->Edges[V2-1][V1-1]=1;\n}\n}\n\nvoid DFS(Graph*G,int V)\n{ //图G的深度优先搜索//\nint W;\nG->Visited[V]=1; //将访问到的结点进行标记//\nfor(W=0;G->VertexN;W++)\nif (G->Edges[V][W]&&!G->Visited[W])\nDFS(G,W);\n}\n\nint CheckG(Graph*G)\n{ //检查边的度是否全为偶数//\nint r,i,j;\nfor(i=0;i<G->VertexN;i++)\n{\nr=0;\nfor(j=0;j<G->VertexN;j++)\nr+=G->Edges[i][j];\nif (r%2) return 0; //发现奇数度的边则返回0//\n}\nreturn 1; //全是偶数度的边则返回1//\n}\n\nint main()\n{\nGraph *G=(Graph*)malloc(sizeof(Graph));\nInitializeG(G);\nReadG(G);\n\nprintf(\"%d\",CheckG(G));\nreturn 0;\n}\n", "Konwledge_Point": "图的深度优先搜索", "Question": "七巧问题 c语言程序已给出 mian函数问号处该怎么写呢\n#include\n#include\n#define MAXV 1000                                           /\n最大顶点数设为1000\n/\ntypedef struct {                                            /\n定义结构体类型\n/\n    int Visited[MAXV];                                      /\n顶点标记\n/\n    int Edges[MAXV][MAXV];                                  /\n邻接矩阵数组\n/\n    int VertexN,EdgeN;                                      /\n顶点和边数\n/\n}Graph;                                                     /\n用邻接矩阵存储的图结构体\n/ \n\n\nvoid InitializeG(Graph*G)\n{                                                           /\n图的初始化\n/\n    int i,j;\n    for(i=0;iEdges[i][j]=0;\n             G->Visited[i]=0;\n    }\n    G->VertexN=G->EdgeN=0;\n}                                                           \n\n\nvoid ReadG(Graph*G)                                         /\n读入并存储一个图\n/\n{\n    int i,V1,V2;\n    scanf(\"%d%d\",&G->VertexN,&G->EdgeN);                    /\n用户输入顶点数和边数\n/\n    for(i=0;i\nEdgeN;i++)\n    {\n        scanf(\"%d%d\",&V1,&V2);                              /\n输入顶点名称，比坐标大1（1到N）\n/\n        G->Edges[V1-1][V2-1]=G->Edges[V2-1][V1-1]=1;\n    }\n}\n\n\nvoid DFS(Graph*G,int V)\n{                                                           /\n图G的深度优先搜索\n/\n    int W;\n    G->Visited[V]=1;                                        /\n将访问到的结点进行标记\n/\n    for(W=0;W\nVertexN;W++)\n         if (G->Edges[V][W]&&!G->Visited[W])\n         DFS(G,W);\n}\n\n\nint CheckG(Graph*G)\n{                                                           /\n检查边的度是否全为偶数\n/\n    int r,i,j;\n    for(i=0;i\nVertexN;i++)\n    {\n        r=0;\n        for(j=0;j\nVertexN;j++)\n             r+=G->Edges[i][j];\n        if (r%2) return 0;                                  /\n发现奇数度的边则返回0\n/\n    }\n    return 1;                                               /\n全是偶数度的边则返回1\n/\n}\n\n\nint main()\n{\n    int i;\n    Graph\nG=(Graph\n)malloc(sizeof(Graph));\n    ？\n    return 0;\n}\n注：（1）\n输入说明：输入的第1行包含两个正整数，分别为结点数N(1<N<1000)和\n边数M。随后的M行对应M条边，每行给出一对正整数，分别是该条边连\n通的两个结点的编号（结点从1到N编号）。\n（2）\n输出说明：若欧拉回路存在则输出1，否则输出0。\n（3）\n测试实例：\n1）输入：\n6 10\n1 2\n2 3\n3 1\n4 5\n5 6\n6 4\n1 4\n1 6\n3 4\n3 6\n输出：1\n(说明：存在欧拉回路)\n２）输入：\n5 8\n1 2\n1 3\n2 3\n2 4\n2 5\n5 3\n5 4\n3 4\n输出：0\n（说明：不存在欧拉回路）", "Tag": "算法分析"}
{"Answer": "你的代码直接把我的Eclipse给卡顿了，停止按钮都没有效果了。\r\n参考个正确版本的吧，绝对秒出结果，只需修正打印语句末尾改为\"\\n\"打印换行即可。\r\nhttp://blog.csdn.net/zhong317/article/details/4586131", "Konwledge_Point": "图的深度优先搜索", "Question": "(已解决)自己用java写的八皇后问题算法，可是不行,求告知原因\n\npublic class Test {\n\n    public static void main(String[] args) {\n        Empress a=new Empress();\n        a.find(0,0);\n        System.out.println(a.map);\n    }\n}\n\nclass Empress{\n    public int[][] arry=new int[8][8];\n    public  int map=0;\n\n    public   boolean rule(int arry[][],int k,int j){    //判断节点是否合适\n        for(int i=0;i<8;i++){   //行列冲突\n            if(arry[k][i]==1)\n                return false;\n            else if(arry[i][j]==1)\n                return false;\n        }\n        for(int i=k-1,m=j-1;i>=0&&m>=0;i--,m--){    //左对角线\n            if(arry[i][m]==1)\n                return false;\n        }\n        for(int i=k-1,m=j+1;i>=0&&m<=7;i--,m++){    //右对角线\n            if(arry[i][m]==1)\n                return false;\n        }\n        return true;\n    }\n\n\n    public void find(int i,int m){  //寻找皇后节点\n        if(i>7){    //皇后解 \n            map++;\n        }else{\n            for(int j=i+1;j<8;j++){     //刷新当前结点下的数组\n                for(int k=0;k<8;k++){\n                    arry[j][k]=0;\n                }\n            }\n            for(;i<8;i++){      //深度优先搜索\n                for(;m<8;m++){\n                    if(rule(arry,i,m)){\n                        arry[i][m]=1;\n                        find(i+1,0);\n                    }\n                }\n            }\n        }\n    }\n}\n", "Tag": "算法分析"}
{"Answer": "v[i][k]==1;改成v[i][k]=1;", "Konwledge_Point": "图的深度优先搜索", "Question": "NOI / 2.5基本算法之搜索-1818：红与黑\n题目链接：\nhttp://noi.openjudge.cn/ch0205/solution/34697319/\n描述\n有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。你站在其中一块黑色的瓷砖上，只能向相邻的黑色瓷砖移动。请写一个程序，计算你总共能够到达多少块黑色的瓷砖。\n\n\n输入\n包括多个数据集合。每个数据集合的第一行是两个整数W和H，分别表示x方向和y方向瓷砖的数量。W和H都不超过20。在接下来的H行中，每行包括W个字符。每个字符表示一块瓷砖的颜色，规则如下\n1）‘.’黑色的瓷砖；\n2）‘#’红色的瓷砖；\n3）‘\n@’黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。\n当在一行中读入的是两个零时，表示输入结束。\n输出\n对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。\n\n\n#include\nusing namespace std;\nint n,m,v[\n25\n][\n25\n],dx[\n4\n]={\n1\n,\n-1\n,\n0\n,\n0\n},dy[\n4\n]={\n0\n,\n0\n,\n1\n,\n-1\n},t=\n0\n;\nchar a[\n25\n][\n25\n];\nint dfs(int x,int y)\n{\n    int i,tx,ty;\n    for(i=\n0\n;i<\n4\n;i++)\n    {\n        tx=dx[i]+x;\n        ty=dy[i]+y;\n        if(tx>\n0\n&&tx<=n&&ty>\n0\n&&ty<=m&&v[tx][ty]==\n0\n&&a[tx][ty]!=\n'#'\n)\n        {\n            v[tx][ty]=\n1\n;\n            t++;\n            dfs(tx,ty);\n        }\n    }\n} \nint main()\n{\n    int i,k,x,y;\n    while(\n1\n)\n    {\n        cin>>m>>n;\n        memset(v,\n0\n,sizeof(v));\n        t=\n0\n;\n        if(m==\n0\n&&n==\n0\n)\n        return \n0\n;\n        for(i=\n1\n;i<=n;i++)\n        {\n            for(k=\n1\n;k<=m;k++)\n            {\n                cin>>a[i][k];\n                if(a[i][k]==\n'@'\n)\n                {\n                    v[i][k]==\n1\n;\n                    x=i,y=k;\n                }\n            }\n        }\n        dfs(x,y);\n        cout<<t<<endl;\n        \n    }\n    return \n0\n;\n}\n\n\n\n\n运行结果：Runtime Error", "Tag": "算法分析"}
{"Answer": "1.由于多少个元素不确定，肯定是要递归的，写死循环不可行2.不用剪枝，递归的时候传递初始值内层与外层相等即可，这样4只能和4,5,6去加，5只能和5,6,7加，6只能和6,7,8加，不能输入的更小3.暴力搜索容易超时，你应该判断如果不是最后一层递归，相加的结果已经大于给定的数，就结束本次循环，不要继续了（只影响当前的层，返回上一层之后继续外层循环）4.如果是最后一层，不要再循环了，直接用给定的数减去前n-1项的和就是最后一项，为防止最后一项小于倒数第2项，这个条件可以在前面3的时候就过滤掉，不要继续循环了", "Konwledge_Point": "图的深度优先搜索", "Question": "暴搜所有组合应该怎么剪枝? 求思路\n题目简述\n\n\n要求输出n个正整数，他们的和为s, 每个元素值的范围在[1,m]之内。求输出所有可能的组合结果。\n\n\n输入: n = 2, m = 6, s = 10，下面简述为(n, m, s), 即（2，6，10）\n\n\n输出:\n(4,6)\n(5,5)\n\n\n注意:\n(6,4)属于重复的结果\n\n\n边界约束:\n1 <= n  <= 100\n1 <= m <= 1e9\n1 <= s <=  1e5\n\n\n问题\n\n\n我用dfs暴力搜索 + 剪枝，但是还是通过不过用例。\n(100, 100, 10000)\n(3, 1e5, 20)", "Tag": "算法分析"}
{"Answer": "假设bool占用1字节并按1字节对齐，900000005字节/1024/1024/1024=0.8381903218gb，小程序大内存。如果按照4字节对齐，那还真不得了。系统会如何处理我不知道，但是不应该这样写。最后，抱歉，没有看明白题目。", "Konwledge_Point": "图的深度优先搜索", "Question": "在某些情况中，为什么程序突然中断？\n问题\n【搜索与回溯算法】生成字符串 (Standard IO)\n时间限制: 1000 ms  空间限制: 262144 KB  具体限制  \n\n\n题目描述：\n假设一个字符串只由字符”0”、”1”、‘\n’组成，其中字符‘\n’表示该字符可由字符”0”或”1”替代。\n\n\n现有一些字符串，根据这些字符串生成所有可生成的字符串。\n\n\n注意后一个例子中”*01”并没有生成新的字符串。\n\n\n输入\n第一行是两个整数M,N（1≤M≤15,0≤N≤2500）。M表示字符串的长度，N表示字符串的个数。\n以下N行每行各有一个字符串。各行的行首、行末没有多余的空格。\n\n\n输出\n一行，为一个整数,Total表示所能生成的字符串的个数。 \n\n\n样例输入\n2 3\n10\n1\n0\n \n\n\n样例输出\n4\n\n\n代码：\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\nstring a[\n2505\n];\n\nint\n n,m,t,len,flag;\n\nbool\n visit[\n900000005\n];\n\nvoid\n \ndg\n(\nint\n x,\nint\n i)\n\n\n{\n    \nif\n(x>len)\n    {\n        \nlong\n \nlong\n qn=\natol\n(a[i].\nc_str\n());\n        \nif\n(visit[qn]==\n0\n)\n        {\n            t++;\n            visit[qn]=\n1\n;\n            cout<<\n1\n;\n        }\n    }\n    \nelse\n\n    {\n        \n        \nif\n(a[i][x]==\n'*'\n)\n        {\n            a[i][x]=\n'1'\n;\n            \ndg\n(x+\n1\n,i);\n            a[i][x]=\n'0'\n;\n            \ndg\n(x+\n1\n,i);            \n            a[i][x]=\n'*'\n;\n        }\n        \nelse\n \ndg\n(x+\n1\n,i);\n    }\n}\n\nint\n \nmain\n()\n\n\n{\n    cin>>m>>n;\n    \nfor\n(\nint\n i=\n1\n;i<=n;i++)\n    {\n        cin>>a[i];    \n        len=a[i].\nsize\n();\n        \ndg\n(\n0\n,i);\n    }\n    cout<<t;\n}\n\n\n\n", "Tag": "算法分析"}
{"Answer": "你程序中的问题比较多，我修改的地方我使用****************************标识出来了其中一点，new要和delete配对使用参考：https://blog.csdn.net/allen807733144/article/details/73608938\n\n#include<iostream>\n#include<stack>\nusing namespace std;\n//顺序查找\nint Sq_Sear(int* a, int n, int key)\n{\n    int i = n;\n    for (i = 0; i <= n; i++)//cpu要做两次判断，可做优化\n    {\n        if (a[i] == key)\n        {\n            return i;\n        }\n    }\n    return 0;\n    //改进,增加一个哨兵来减少循环次数，会污染数组\n\n    //int i = n;\n    //a[0] = key;\n    //while (a[i] != key)\n    //{\n    //    i--;\n    //}\n\n    //return i;\n\n}\n\n\n//插值查找(按比例查找)\nint bia_search(int str[], int n, int key)\n{\n    int low = 0, high = n - 1;\n    int mid = 0;\n    while (low <= high)\n    {\n        //折半与按比例的优劣，数的值跨度不是很大按比例更好，\n        mid = low + (key - str[low]) / (str[high] - str[low]) * (high - low);\n        if (str[mid] == key)\n            return mid;\n        if (str[mid] > key)\n            high = mid - 1;\n        if (str[mid] < key)\n            low = mid + 1;\n    }\n    return -1;\n\n}\n//斐波那契查找\n//1.首先创建斐波那契数组\n//2。找到有序表最大元素\n//3.补齐有序表最大值到最接近斐波那契数组的一个元素\n//4.根据斐波那契的规则对比查找\n\n\nvoid produceFib(int* fib, int size)\n{\n    int i;\n    fib[0] = 0;\n    fib[1] = 1;\n    for (i = 2; i < size; i++)\n    {\n        fib[i] = fib[i - 1] + fib[i - 2];\n    }\n}\n\n\nint FibonacciSearch(int* data, int length, int searchValue)\n{\n    int low = 0, high = length - 1;\n    int i = 0, mid = 0;\n    int fib[10];\n    produceFib(fib, length);\n\n\n    int k = 0;//最接近斐波那契的数\n\n    while (high > fib[k] - 1)\n    {\n        k++;\n    }\n\n\n    //补齐有序表\n    int* temp;\n    temp = (int*)new int[fib[k] - 1];\n    memcpy(temp, data, length * sizeof(int));\n    for (i = length; i < fib[k] - 1; i++)\n    {\n        data[i] = data[high];\n    }\n\n    while (low <= high)\n    {\n        if (k > 0)\n            mid = low + fib[k - 1] - 1;\n        else\n            mid = low;\n        if (temp[mid] == searchValue)\n        {\n            if (mid <= length - 1)\n                return mid;\n            else\n                return length - 1;\n        }\n\n\n\n\n        if (temp[mid] > searchValue)\n        {\n            high = mid - 1;\n            k = k - 1;\n        }\n        if (temp[mid] < searchValue)\n        {\n            low = mid + 1;\n            k = k - 2;\n        }\n    }\n\n    delete[] temp;\n    return -1;\n}\n\n\ntypedef struct BiNode\n{\n    int data;\n    struct BiNode* lchild;\n    struct BiNode* rchild;\n    BiNode(int x) :\n        data(x), lchild(NULL), rchild(NULL) {};\n\n\n}BiNode, * BiTree;\n\n//二叉查找树\n//T为搜索的树，f为记录父节点的指针，p作为临时指针保存输出\nbool SearchBST(BiTree T, int key, BiTree f, BiTree* p)\n{\n    if (!T)\n    {\n        *p = f;\n        return false;\n    }\n    else if (key == T->data)\n    {\n        *p = T;\n        return true;\n    }\n    else if (key < T->data)\n    {\n        return SearchBST(T->lchild, key, T, p);\n    }\n    else if (key > T->data)\n    {\n        return SearchBST(T->rchild, key, T, p);\n    }\n    else\n        return false;\n}\nbool SearchBST(BiTree T, int key)\n{\n    BiTree f(0);\n   // BiTree* p(0);****************************\n   // f = (BiTree)new BiNode(key); p = new BiTree;****************************\n    if (!T)\n    {\n        //*p = f;****************************\n        return false;\n    }\n    else if (key == T->data)\n    {\n        //*p = T;****************************\n        return true;\n    }\n    else if (key < T->data)\n    {\n        return SearchBST(T->lchild, key);\n    }\n    else if (key > T->data)\n    {\n        return SearchBST(T->rchild, key);\n    }\n    else\n        return false;\n}\n//删除\n//*p搜索位置结点\n//定义两个临时指针\n//三种情况\n\nbool Delete(BiTree* t)//传输的是指针域的地址,直接修改lchild or rchild\n{\n    BiTree q, s;\n    if ((*t)->lchild == NULL)//左子树为空，连接右子树\n    {\n        q = *t;\n        (*t) = (*t)->lchild;\n        //q = (*t)->rchild;//连接右子树，直接改变指针\n        //(*t)->data = q->data;\n        //(*t)->rchild = q->rchild;\n        delete q;//删除结点所占空间****************************\n    }\n    else if ((*t)->rchild == NULL)//右子树为空，连接左子树\n    {\n        q = *t;\n        (*t) = (*t)->lchild;//连接左子树，直接改变指针\n        //free(q);//删除结点所占空间\n    }\n    else//有两个孩子\n    {\n        q = (*t);//找到中序遍历时的前驱结点，即孩子结点的右子树最右边的叶子结点\n        s = (*t)->lchild;\n        while (s->rchild != NULL)\n        {\n            q = s;//记录当前结点值\n            s = s->rchild;//找到右子树最右边的叶子结点\n        }\n        (*t)->data = s->data;\n        if (q == *t)//孩子结点为目标结点\n        {\n            q->lchild = s->lchild;//链接\n        }\n        else//存在右子树\n        {\n            q->rchild = s->lchild;//目标结点的父亲结点链接孩子结点\n        }\n\n        delete s;//****************************\n\n    }\n\n    return true;\n}\n\n//删除二叉排序树的结点\n//1.判断是否为空树\n//2.搜索判断是否存在\n//3.执行删除函数\nint DelectBST(BiTree T, int key)\n{\n    if (T == NULL)\n    {\n        return false;\n\n    }\n\n\n    else if (key == T->data)\n    {\n        return Delete(&T);\n    }\n    else if (key < T->data)\n    {\n        return DelectBST(T->lchild, key);\n    }\n    else\n    {\n        return DelectBST(T->rchild, key);\n    }\n\n}\n\n\n//插入\nint InsertBST(BiTree* T, int key)\n{\n    BiTree p = nullptr, s = nullptr;\n\n\n    //传入临时结点指针p，通过搜索函数返回当前最接近该插入值的一个节点位置\n    if (!SearchBST(*T, key, NULL, &p))\n    {\n        s = (BiTree)new BiNode(key);//修改了一下这里****************************\n        s->data = key;\n        s->lchild = NULL;\n        s->rchild = NULL;\n        if (!p)\n        {\n            *T = s;//此处为插入根节点\n        }\n        else if (key < p->data)\n        {\n            p->lchild = s;\n        }\n        else\n        {\n            p->rchild = s;\n        }\n        return true;\n\n    }\n    else {\n        cout << \"已存在相同数据！\" << endl;\n\n\n        return false;\n    }\n}\n\n\n//遍历\n//遍历迭代\nvoid depthFirstSearch(BiNode* root)\n{\n    stack<BiNode*>sta;\n    sta.push(root);\n    BiNode* p;\n    while (!sta.empty())\n    {\n\n        p = sta.top();\n        if (p != NULL)\n            cout << p->data << ' ';\n        sta.pop();\n        if (p->rchild != NULL)\n            sta.push(p->rchild);\n        if (p->lchild != NULL)//这里等符号写错了\n            sta.push(p->lchild);\n\n    }\n    cout << endl;\n}\n\n\n\n\nint main(void)\n{\n    //int data[] = { 1,2,3,4,5,6,7,8,9,10 };\n    //int len = sizeof(data) / sizeof(data[0]);\n    //int index = FibonacciSearch(data,len,5);\n    //cout << index;\n    BiTree T = BiTree(0);\n\n\n    InsertBST(&T, 1);\n    InsertBST(&T, 2);\n    InsertBST(&T, 3);\n    InsertBST(&T, 5);\n    InsertBST(&T, 7);\n    InsertBST(&T, 8);\n    InsertBST(&T, 12);\n    InsertBST(&T, 11);\n    InsertBST(&T, 21);\n    InsertBST(&T, 31);\n    InsertBST(&T, 51);\n    InsertBST(&T, 17);\n    InsertBST(&T, 18);\n    InsertBST(&T, 121);\n    depthFirstSearch(T);\n\n    cout << SearchBST(T, 3) << endl;\n\n    depthFirstSearch(T);\n    DelectBST(T, 12);\n    depthFirstSearch(T);\n    return 0;\n}\n\n", "Konwledge_Point": "图的深度优先搜索", "Question": "二叉查找树的操作，删除节点的指针和内存释放问题\n学习删除二叉排序树时遇到的问题，在删除结点时遇到问题，如下，注释的是我自己的想法，原本的内容是看小甲鱼的视频弄的，但感觉不太对，找了不少博客还是没解决问题\n\n\n运行结果及报错内容\n\n\n问题\n每种情况的free（p），都会报错，没搞明白。\n到底为啥？\n\n\n\nbool Delete(BiTree* t)\n//\n传输的是指针域的地址,直接修改lchild or rchild\n{\n    BiTree q, s;\n    \nif\n ((*t)->lchild == NULL)\n//\n左子树为空，连接右子树\n    {\n        q = *t;\n        (*t) = (*t)->lchild;\n        \n//\nq = (*t)->rchild;\n//\n连接右子树，直接改变指针\n        \n//\n(*t)->data = q->data;\n        \n//\n(*t)->rchild = q->rchild;\n        free(q);\n//\n删除结点所占空间\n    }\n\n\n\n源程序如下：\n\n\n#\ninclude\n\n#\ninclude\n\nusing namespace std;\n\n//顺序查找\n\n\nint\n \nSq_Sear(\nint\n*\n \na\n, \nint\n \nn\n, \nint\n \nkey\n)\n\n{\n    \nint\n i = n;\n    \nfor\n (i = \n0\n; i <= n; i++)\n//cpu要做两次判断，可做优化\n\n    {\n        \nif\n (a\n[\ni\n]\n == \nkey)\n        {\n            return i;\n        }\n    }\n    return \n0\n;\n    \n//改进,增加一个哨兵来减少循环次数，会污染数组\n\n\n    \n//int i = n;\n\n    \n//a[0] = key;\n\n    \n//while (a[i] != key)\n\n    \n//{\n\n    \n//    i--;\n\n    \n//}\n\n\n    \n//return i;\n\n\n}\n\n\n\n//插值查找(按比例查找)\n\n\nint\n bia\n_search(\nint\n \nstr\n[], \nint\n \nn\n, \nint\n \nkey\n)\n\n{\n    \nint\n low = \n0\n, high = n-\n1\n;\n    \nint\n mid = \n0\n;\n    \nwhile\n (low <= high)\n    {\n        \n//折半与按比例的优劣，数的值跨度不是很大按比例更好，\n\n        mid = low + (key - str\n[\nlow\n]\n)\n / \n(str\n[\nhigh\n]\n - str\n[\nlow\n]\n)\n * \n(high - low);\n            \nif\n (str\n[\nmid\n]\n == \nkey)\n                return mid;\n            \nif\n (str\n[\nmid\n]\n > key)\n                high = mid - \n1\n;\n            \nif\n (str\n[\nmid\n]\n < key)\n            low = mid + \n1\n;\n    }\n    return -\n1\n;\n\n}\n\n//斐波那契查找\n\n\n//1.首先创建斐波那契数组\n\n\n//2。找到有序表最大元素\n\n\n//3.补齐有序表最大值到最接近斐波那契数组的一个元素\n\n\n//4.根据斐波那契的规则对比查找\n\n\n\nvoid produce\nFib(\nint\n*\n \nfib\n, \nint\n \nsize\n)\n\n{\n    \nint\n i;\n    fib\n[\n0\n]\n = \n0\n;\n    fib\n[\n1\n]\n = \n1\n;\n    \nfor\n (i = \n2\n; i < size; i++)\n    {\n        fib\n[\ni\n]\n = fib\n[\ni\n - \n1\n]\n + fib\n[\ni\n - \n2\n]\n;\n    }\n}\n\n\n\nint\n \nFibonacciSearch(\nint\n*\n \ndata\n, \nint\n \nlength\n, \nint\n \nsearchValue\n)\n\n{\n    \nint\n low = \n0\n, high = length - \n1\n;\n    \nint\n i = \n0\n,mid = \n0\n;\n    \nint\n fib\n[\n10\n]\n;\n    produce\nFib(\nfib\n, \nlength\n)\n;\n\n\n    \nint\n k = \n0\n;\n//最接近斐波那契的数\n\n\n    \nwhile\n (high > fib\n[\nk\n]\n - \n1\n)\n    {\n        k++;\n    }\n\n\n    \n//补齐有序表\n\n    \nint\n* temp;\n    temp = (\nint\n*)\nnew\n \nint\n[\nfib\n[\nk\n]\n - \n1\n];\n    memcpy(temp, data, length\n * \nsizeof(\nint\n));\n    \nfor\n (i = length; i < fib\n[\nk\n]\n - \n1\n; i++)\n    {\n        data\n[\ni\n]\n = data\n[\nhigh\n]\n;\n    }\n\n    \nwhile\n (low <= high)\n    {\n        \nif\n (k > \n0\n)\n            mid = low + fib\n[\nk\n - \n1\n]\n - \n1\n;\n        \nelse\n\n            mid = low;\n        \nif\n (temp\n[\nmid\n]\n == \nsearchValue)\n        {\n            \nif\n (mid <= length - \n1\n)\n                return mid;\n            \nelse\n\n                return length - \n1\n;\n        }\n\n\n\n\n        \nif\n (temp\n[\nmid\n]\n > searchValue)\n        {\n            high = mid - \n1\n;\n            k = k - \n1\n;\n        }\n        \nif\n (temp\n[\nmid\n]\n < searchValue)\n        {\n            low = mid + \n1\n;\n            k = k - \n2\n;\n        }\n    }\n\n    delete\n[]\n temp;\n    return -\n1\n;\n}\n\n\ntypedef \nstruct\n BiNode\n{\n    \nint\n data;\n    \nstruct\n BiNode* lchild;\n    \nstruct\n BiNode* rchild;\n    \nBiNode(\nint\n \nx\n)\n :\n        data(x), lchild(NULL), rchild(NULL) {};\n\n    \n}BiNode,*BiTree;\n\n\n//二叉查找树\n\n\n//T为搜索的树，f为记录父节点的指针，p作为临时指针保存输出\n\n\nbool\n \nSearchBST(BiTree T, \nint\n \nkey\n, BiTree \nf\n, BiTree\n*\n \np\n)\n\n{\n    \nif\n (!T)\n    {\n        *p = f;\n        return \nfalse\n;\n    }\n    \nelse\n \nif\n(key==T->data)\n    {\n        *p = T;\n        return \ntrue\n;\n    }\n    \nelse\n \nif\n(key < T->data)\n    {\n        return \nSearchBST(T->\nlchild\n,\nkey\n,T,\np\n)\n;\n    }\n    \nelse\n \nif\n(key > T->data)\n    {\n        return \nSearchBST(T->\nrchild\n,\nkey\n,T,\np\n)\n;\n    }\n    \nelse\n\n    return \nfalse\n;\n}\n\nbool\n \nSearchBST(BiTree T, \nint\n \nkey\n)\n\n{\n    BiTree f(\n0\n);\n    BiTree* p(\n0\n);\n     f = (BiTree)\nnew\n BiTree; p = \nnew\n BiTree;\n    \nif\n (!T)\n    {\n        *p = f;\n        return \nfalse\n;\n    }\n    \nelse\n \nif\n (key\n == \nT->data)\n    {\n        *p = T;\n        return \ntrue\n;\n    }\n    \nelse\n \nif\n (key < T->data)\n    {\n        return \nSearchBST(T->\nlchild\n, \nkey\n)\n;\n    }\n    \nelse\n \nif\n (key > T->data)\n    {\n        return \nSearchBST(T->\nrchild\n, \nkey\n)\n;\n    }\n    \nelse\n\n        return \nfalse\n;\n}\n\n//删除\n\n\n//*p搜索位置结点\n\n\n//定义两个临时指针\n\n\n//三种情况\n\n\n\nbool\n \nDelete(BiTree\n*\n \nt\n)\n//传输的是指针域的地址,直接修改lchild or rchild\n\n{\n    BiTree q, s;\n    \nif\n ((*t)->lchild\n == \nNULL)\n//左子树为空，连接右子树\n\n    {\n        q = *t;\n        (*t) = (*t)->lchild;\n        \n//q = (*t)->rchild;//连接右子树，直接改变指针\n\n        \n//(*t)->data = q->data;\n\n        \n//(*t)->rchild = q->rchild;\n\n        free(q);\n//删除结点所占空间\n\n    }\n    \nelse\n \nif\n ((*t)->rchild\n == \nNULL)\n//右子树为空，连接左子树\n\n    {\n        q = *t;\n        (*t) = (*t)->lchild;\n//连接左子树，直接改变指针\n\n        \n//free(q);//删除结点所占空间\n\n    }\n    \nelse\n//有两个孩子\n\n    {\n        q = (*t);\n//找到中序遍历时的前驱结点，即孩子结点的右子树最右边的叶子结点\n\n        s = (*t)->lchild;\n        \nwhile\n (s->rchild != NULL)\n        {\n            q = s;\n//记录当前结点值\n\n            s = s->rchild;\n//找到右子树最右边的叶子结点\n\n        }\n        (*t)->data = s->data;\n        \nif\n (q\n == \n*t)\n//孩子结点为目标结点\n\n        {\n            q->lchild = s->lchild;\n//链接\n\n        }\n        \nelse\n//存在右子树\n\n        {\n            q->rchild = s->lchild;\n//目标结点的父亲结点链接孩子结点\n\n        }\n        \n        free(s);\n\n    }\n    \n    return \ntrue\n;\n}\n\n\n//删除二叉排序树的结点\n\n\n//1.判断是否为空树\n\n\n//2.搜索判断是否存在\n\n\n//3.执行删除函数\n\n\nint\n \nDelectBST(BiTree T, \nint\n \nkey\n)\n\n{\n    \nif\n (T\n == \nNULL)\n    {\n        return \nfalse\n;\n\n    }\n\n\n    \nelse\n \nif\n (key\n == \nT->data)\n        {\n            return \nDelete(&T)\n;\n        }\n    \nelse\n \nif\n(key < T->data)\n        {\n            return \nDelectBST(T->\nlchild\n, \nkey\n)\n;\n        }\n    \nelse\n \n        {\n            return \nDelectBST(T->\nrchild\n,\nkey\n)\n;\n        }\n    \n}\n\n\n\n//插入\n\n\nint\n \nInsertBST(BiTree\n*\n T, \nint\n \nkey\n)\n\n{\n    BiTree p ,s;\n\n\n    \n//传入临时结点指针p，通过搜索函数返回当前最接近该插入值的一个节点位置\n\n    \nif\n (!\nSearchBST(\n*\nT, \nkey\n, NULL, &\np\n)\n)\n    {\n        s = (BiTree)\nnew\n BiTree;\n        s->data = key;\n        s->lchild = NULL;\n        s->rchild = NULL;\n        \nif\n (!p)\n        {\n            *T = s;\n//此处为插入根节点\n\n        }\n        \nelse\n \nif\n (key < p->data)\n        {\n            p->lchild = s;\n        }\n        \nelse\n\n        {\n            p->rchild = s;\n        }\n        return \ntrue\n;\n\n    }\n    \nelse\n {\n        cout << \n\"已存在相同数据！\"\n << endl;\n        \n\n        return \nfalse\n;\n    }\n}\n\n\n\n//遍历\n\n\n//遍历迭代\n\nvoid depth\nFirstSearch(BiNode\n*\n \nroot\n)\n\n{\n    stacksta;\n    sta.push(root);\n    BiNode* p;\n    \nwhile\n (!sta.empty\n()\n)\n    {\n        \n        p = sta.top\n()\n;\n        \nif\n (p != NULL)\n        cout << p->data<<\n' '\n;\n        sta.pop\n()\n;\n        \nif\n (p->rchild != NULL)\n            sta.push(p->rchild);\n        \nif\n (p->lchild= NULL)\n            sta.push(p->lchild);\n\n    }\n    cout << endl;\n}\n\n\n\n\n\nint\n main(void)\n{\n    \n//int data[] = { 1,2,3,4,5,6,7,8,9,10 };\n\n    \n//int len = sizeof(data) / sizeof(data[0]);\n\n    \n//int index = FibonacciSearch(data,len,5);\n\n    \n//cout << index;\n\n    BiTree T = \nBiTree(0)\n;\n    \n    \n    \nInsertBST(&T, 1)\n;\n    \nInsertBST(&T, 2)\n;\n    \nInsertBST(&T, 3)\n; \n    \nInsertBST(&T, 5)\n;\n    \nInsertBST(&T, 7)\n;\n    \nInsertBST(&T, 8)\n; \n    \nInsertBST(&T, 12)\n;\n    \nInsertBST(&T, 11)\n;\n    \nInsertBST(&T, 21)\n;\n    \nInsertBST(&T, 31)\n;\n    \nInsertBST(&T, 51)\n;\n    \nInsertBST(&T, 17)\n;\n    \nInsertBST(&T, 18)\n;\n    \nInsertBST(&T, 121)\n;\n    depth\nFirstSearch(T)\n;\n    \n    cout << \nSearchBST(T, 3)\n << endl;\n\n    depth\nFirstSearch(T)\n;\n    \nDelectBST(T,12)\n;\n    depth\nFirstSearch(T)\n;\n    return \n0\n;\n}\n\n", "Tag": "算法分析"}
{"Answer": "这篇文章讲的很详细，请看：力扣 76题 最小覆盖子串（双指针 + 滑动窗口）", "Konwledge_Point": "图的深度优先搜索", "Question": "力扣错误提示解惑，76题最小覆盖子串\n问题遇到的现象和发生背景\n\n\n力扣76.最小覆盖子串，请用通俗的语言概括一下下边这段错误提示的意思。\n同时，贴上我的代码\n\n\n遇到的现象和发生背景，请写出第一个错误信息\n\n\n报错内容：\nLine 137: Char 23: runtime error: constructor call on misaligned address 0xbebebebebebec0ba for type 'int', which requires 4 byte alignment (new_allocator.h)\n: note: pointer points here\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/ext/new_allocator.h:146:23\n\n\n用代码块功能插入代码，请勿粘贴截图。 不用代码块回答率下降 50%\n\n\nclass\n Solution {\npublic:\n    static \nbool\n comp\nSL(\ndeque\n<\nint\n>& \na\n,\ndeque\n<\nint\n>& \nb\n)\n\n    {\n        \nif\n(a.empty\n()\n) return \n0\n;\n        \nif\n(b.empty\n()\n) return \n1\n;\n        return a.front\n()\n& \nc\n,\ndeque\n<\nint\n>& \nd\n)\n\n    {\n        \nif\n(c.empty\n()\n) return \n0\n;\n        \nif\n(d.empty\n()\n) return \n1\n;\n        return c.back\n()\n>d.back\n()\n;\n    }\n    void \nDFS(\nint\n \nk\n,\nstring\n \nt\n,\nvector\n<\nint\n> \nsUCnt\n,\nvector\n<\nint\n> \nsLCnt\n,\nvector\n<\ndeque\n<\nint\n>> \nsU\n,\nvector\n<\ndeque\n<\nint\n>> \nsL\n)\n\n    {\n        \nif\n(k==n)\n        {\n            sort(tU.\nbegin\n()\n,tU.\nend\n()\n,compSL);ul=tU\n[\n0\n]\n.empty\n()\n? INT_MAX:tU\n[\n0\n]\n.front\n()\n;\n            sort(tU.\nbegin\n()\n,tU.\nend\n()\n,compSR);ur=tU\n[\n0\n]\n.empty\n()\n? INT_MIN:tU\n[\n0\n]\n.back\n()\n;\n            sort(tL.\nbegin\n()\n,tL.\nend\n()\n,compSL);ll=tL\n[\n0\n]\n.empty\n()\n? INT_MAX:tL\n[\n0\n]\n.front\n()\n;\n            sort(tL.\nbegin\n()\n,tL.\nend\n()\n,compSR);lr=tL\n[\n0\n]\n.empty\n()\n? INT_MIN:tL\n[\n0\n]\n.back\n()\n;\n            mx=max(ur,lr);mn=min(ul,ll);\n            tmp=mx-mn;\n            \nif\n(tmp+\n1\n<=len)\n            {\n                beg=mn;\n                len=tmp+\n1\n;\n            }\n            return;\n        }\n        \nint\n j=t\n[\nk\n]\n-\n'A'\n,e;\n        \nif\n(j<\n26\n)\n        {\n            tUCnt\n[\nj\n]\n--;\n            \nwhile\n(!sU\n[\nj\n]\n.empty\n()\n)\n            {\n                sUCnt\n[\nj\n]\n--;\n                \nif\n(tUCnt\n[\nj\n]\n>sUCnt\n[\nj\n]\n) break;\n                e=sU\n[\nj\n]\n.front\n()\n;\n                tU\n[\nj\n]\n.push\n_back(\ne\n)\n;\n                sU\n[\nj\n]\n.pop\n_front()\n;\n                \nDFS(\nk\n+1,\nt\n,\nsUCnt\n,\nsLCnt\n,\nsU\n,\nsL\n)\n;\n                tU\n[\nj\n]\n.pop\n_back()\n;\n            }\n            tUCnt\n[\nj\n]\n++;\n        }\n        \nelse\n\n        {\n            j=t\n[\nk\n]\n-\n'a'\n;\n            tLCnt\n[\nj\n]\n--;\n            \nwhile\n(!sL\n[\nj\n]\n.empty\n()\n)\n            {\n                sLCnt\n[\nj\n]\n--;\n                \nif\n(tLCnt\n[\nj\n]\n>sLCnt\n[\nj\n]\n) break;\n                e=sL\n[\nj\n]\n.front\n()\n;\n                tL\n[\nj\n]\n.push\n_back(\ne\n)\n;\n                sL\n[\nj\n]\n.pop\n_front()\n;\n                \nDFS(\nk\n+1,\nt\n,\nsUCnt\n,\nsLCnt\n,\nsU\n,\nsL\n)\n;\n                tL\n[\nj\n]\n.pop\n_back()\n;\n            }\n            tLCnt\n[\nj\n]\n++;\n        }\n    }\n    \nstring\n min\nWindow(\nstring\n \ns\n, \nstring\n \nt\n)\n\n    {\n        m=s.size\n()\n;\n        n=t.size\n()\n;\n        len=m;\n        vector<\nint\n> s\nUCnt(26)\n,sLCnt;\n        vector> s\nU(26)\n,sL;\n        tLCnt=sLCnt=tUCnt=sUCnt;\n        tL=sL=tU=sU;\n        \nfor\n(\nint\n i=\n0\n,j;i tUCnt,tLCnt;\n    vector> tU,tL;\n};\n\n\n\n\n运行结果及详细报错内容\n\n\n我的解答思路和尝试过的方法，不写自己思路的，回答率下降 60%\n\n\n我的代码怎么改是次要的，最主要想请教错误提示想要表达什么？\n如果可能，我还是希望能用回溯法解题\n我先分别对字符串s、t包含的字母统计数量。然后定义4个队列数组，其中两个用于存储s中各字母在s中的位置序号，另外两个用于存储t中各字母在字符串s中可能的位置序号。假如t中某一个字母的剩余数大于s中的剩余数，则终止当前操作，回退数据状态，不再进入更深的一层搜索。只要sU、sL当前字母的队列里还存有序号，则while循环不会停止。当k==n时，说明t中每个字母都匹配到了一个序号，通过自定义sort函数对匹配得到的所有序号进行排序，然后使其中最大值和最小值相减，取得包含t中所有字母的字符串长度，最后通过回溯的方式，找到满足题意长度最小的字符串。\n\n\n我想要达到的结果，如果你需要快速回答，请尝试 “付费悬赏”", "Tag": "算法分析"}
{"Answer": "该回答通过自己思路及引用到GPTᴼᴾᴱᴺᴬᴵ搜索,得到内容具体如下：这是一个典型的搜索问题，可以使用深度优先搜索（DFS）或广度优先搜索（BFS）算法来解决。以下是一个使用DFS算法的解决方案：\nn = int(input())\nmaze = [list(input()) for _ in range(n)]\nvisited = [[False] * n for _ in range(n)]\n\ndef dfs(x, y):\n    if x == n-1 and y == n-1:\n        return 1\n    visited[x][y] = True\n    res = 0\n    for dx, dy in [(1,0),(-1,0),(0,1),(0,-1)]:  # 向四个方向移动\n        nx, ny = x+dx, y+dy\n        if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny] and maze[nx][ny] == 'O':\n            res += dfs(nx, ny)\n    visited[x][y] = False  # 回溯\n    return min(res, 50000)  # 超过50000时返回50000\n\nprint(dfs(0, 0))\n\n首先读入迷宫和迷宫大小。然后定义一个visited数组来记录每个瓷砖是否已经走过，初始化为False。接下来定义一个dfs函数，用于搜索从当前位置出发到达终点的方案数。如果当前位置已经是终点，则返回1。否则，依次向四个方向移动，如果某个方向可以移动且未访问过且不是墙壁，则继续搜索从该位置出发到达终点的方案数。最后回溯并返回总方案数。注意，为了避免结果太大，当方案数超过50000时，返回50000。\n最后调用dfs函数并输出结果即可。\n\n如果以上回答对您有所帮助，点击一下采纳该答案～谢谢", "Konwledge_Point": "图的深度优先搜索", "Question": "迷宫路径方案数，初学者正在写但怕弄不出来，来问问大家\n有一个正方形的迷宫，上面铺着正方形的瓷砖，标记为’O’的瓷砖可以在上面移动，但是标记为‘X’不可以在上面移动。一个男人从左上角移动到右下角。请写一个程序来计算他有多少种方案可以完成这个移动，要求是走过的瓷砖不能重复走，同时标记为’X’的瓷砖也不能走。\n\n\n输入格式：\n\n\n第一行一个整数N,表示迷宫由N*N的瓷砖铺成，N<20\n\n\n接下来N行，每行N个字符，‘O’或‘X’\n\n\n输出格式：\n\n\n一个整数，表示移动方案数，如果大于50000则输出50000\n\n\n我自己写的在VS上过了，但学习通提交超时\n，然后写的深度优先搜索不对，求怎么解决呀，我已经快放弃了，能不能来个佬帮帮忙\n\n", "Tag": "算法分析"}
