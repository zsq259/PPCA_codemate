{"Answer": "1 3\r\n1 4\r\n首先1和1比，得到1 1\r\n然后3和1(这里的1是指第二个1)比，得到1 1 3\r\n最后3和4比，得到1 1 3 4\r\n后一个类似\r\n\r\n再举一个例子\r\n1 3 6和2 7 8归并\r\n首先1 2比得到1 2（此时可以得知第二个数组没有比2小的数字，但是第一个数组不一定，所以下面用第一个数组的3和2比）\r\n然后3 2比，得到1 2 3（此时可以得知第一个数组没有比3小的，但是第二个数组不一定，所以下面用3 7比）\r\n然后3 7比，得到1 2 3 7\r\n然后6 7比，得到1 2 3 6 7（此时第一个数组比完了，不会再有比6大的，输出第二个数组剩下的）\r\n结束，得到1 2 3 6 7 8", "Konwledge_Point": "归并排序", "Question": "归并排序比较次数问题\n第二趟排序，为什么前半部分比较次数和后半部门比较次数都是3，是那些数在比较，求大神。百度了很久都没找到", "Tag": "算法分析"}
{"Answer": "你可以参考如下链接：\nC语言归并排序（合并排序）算法及代码 - Alex_ShineSky - 博客园\n归并排序也称合并排序，其算法思想是将待排序序列分为两部分，依次对分得的两个部分再次使用归并排序，之后再对其进行合并。仅从算法思想上了解归并排序会觉得很抽象，接下来就以对序列A[0], A[l]…, A\n\n\n\nhttps://www.cnblogs.com/942267027wzmblog/p/6882267.html\n\n如果对你有帮助，可以给我个采纳吗，谢谢!! 点击我这个回答右上方的【采纳】按钮", "Konwledge_Point": "归并排序", "Question": "使用C++归并排序的方法\n使用C++\n通过奥运举重比赛运动员出场顺序的案例分析，掌握分而治之归并排序算法的应用 。\n输入：\n8个运动员参加比赛，每个运动员试举重量分次输入，如下：\n姓名    A    B    C    D    E    F    G    H\n试举1    98    95    95    93    92    90    100    96\n试举2    99    101    103    94    107    91    102    97\n试举3    100    102    104    105    108    109    104    101\n输出：形式如下\n出场顺序号    姓名    试举次数    试举重量\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24            ", "Tag": "算法分析"}
{"Answer": "https://www.cnblogs.com/yinheyi/p/10840465.html", "Konwledge_Point": "归并排序", "Question": "关于C++算法中归并排序的问题\n求助大神，我写的这个归并排序的代码有什么问题，为什么程序运行后什么也不输出呢？\n\n\n\n#include\nusing namespace std;\nvoid erfen(int A[],int low,int high);\nvoid paixu(int A[],int low,int mid,int high);\n\nint main()\n{\n    int num[2] = {3,4};\n    erfen(num, 0,1);\n    for (int i = 0; i < 2; i++)\n        cout << num[i] << endl;\n\n    return 0;\n}\nvoid paixu(int A[], int low, int mid, int high)\n{\n    int* B = new int[high - low + 1];\n    int i = low;\n    int j = mid + 1;\n    int k = 0;\n    while (i <= mid && j <= high)\n    {\n        if (A[i] <= A[j])B[k++] = A[i++];\n        else B[k++] = A[j++];\n    }\n    while (i <= mid)B[k++] = A[i++];\n    while (j <= high) B[k++] = A[j++];\n    //填充原数组\n    for (int x = low, k = 0; x <= high; i++)\n        A[i] = B[k++];\n    delete [] B;\n}\nvoid erfen(int A[], int low, int high)\n{\n\n    if (low < high)\n    {\n        int mid = (low + high) / 2;\n        erfen(A,low,mid);\n        erfen(A, mid + 1,high);\n        paixu(A, low, mid, high);\n    }\n}\n\n\n\n\n\n程序运行后，先是卡住几秒，然后输出“请按任意键继续...”", "Tag": "算法分析"}
{"Answer": "找到两处问题\r\n1.t应该从l开始\r\n2.l中间已经修改了\r\n修改后代码如下\r\n\r\n\r\n```\r\n #include\r\n#include \r\nusing namespace std;\r\nint a[100]; \r\nvoid merge(int m[],int l,int r,int rightend);\r\nvoid sort(int m[],int l,int r);\r\nvoid msort();\r\nint n;\r\nint main()\r\n{\r\n  cin>>n;\r\n  for(int i=0;i >a[i];\r\n  }\r\n  msort();\r\n  for(int i=0;i<n;i++)\r\n  {\r\n    cout<<a[i]<<\" \";\r\n  }\r\n}\r\nvoid sort(int m[],int l, int r)\r\n{\r\n  int center;\r\n  if(l<r)\r\n  {\r\n    center=(l+r)/2;\r\n    sort(m,l,center);\r\n    sort(m,center+1,r);\r\n    merge(m,l,center+1,r);\r\n  }\r\n}\r\nvoid merge(int m[],int l,int r,int rightend)\r\n{\r\n  //这里的t应该从该l开始而不是从0 开始\r\n  int t=l;\r\n  //这里要将l保存下来\r\n  int start = l;\r\n  int leftend=r-1;\r\n  while(l<=leftend && r<=rightend)\r\n  {\r\n    if(a[l]<=a[r])\r\n    {\r\n      m[t++]=a[l++];\r\n    }\r\n    else\r\n    {\r\n      m[t++]=a[r++];\r\n    }\r\n  }\r\n  while(l<=leftend) m[t++]=a[l++];\r\n  while(r<=rightend) m[t++]=a[r++];\r\n\r\n  //因为上面的l++,已经将l加到了leftend\r\n  //这里应该从开始start 到 最后的 t 都应该修改\r\n  for(int i=start;i<t;i++)\r\n  {\r\n    a[i]=m[i];\r\n  }\r\n}\r\nvoid msort()\r\n{\r\n  int temp[100];\r\n  sort(temp,0,n-1);\r\n}\r\n\r\n```", "Konwledge_Point": "归并排序", "Question": "用c++实现归并排序的问题\n打算用递归法实现归并排序，但结果总是不对，找不到问题，求大佬解答\n\n#include\n\nusing namespace std;\n\nint a[100]; \n\nvoid merge(int m[],int l,int r,int rightend);\n\nvoid sort(int m[],int l,int r);\n\nvoid msort();\n\nint n;\n\nint main()\n\n{\n\n    cin>>n;\n\n    for(int i=0;i\n    {\n\n        cin>>a[i];\n\n    }\n\n    msort();\n\n    for(int i=0;i<n;i++)\n\n    {\n\n        cout<<a[i]<<\" \";\n\n    }\n\n}\n\nvoid sort(int m[],int l, int r)\n\n{\n\n    int center;\n\n    if(l<r)\n\n    {\n\n      center=(l+r)/2;\n\n      sort(m,l,center);\n\n      sort(m,center+1,r);\n\n      merge(m,l,center+1,r);\n\n    }\n\n}\n\nvoid merge(int m[],int l,int r,int rightend)\n\n{\n\n    int t=0;\n\n    int leftend=r-1;\n\n    while(l<=leftend&&r<=rightend)\n\n    {\n\n        if(a[l]<=a[r])\n\n        {\n\n            m[t++]=a[l++];\n\n        }\n\n        else\n\n        {\n\n            m[t++]=a[r++];\n\n        }\n\n    }\n\n    while(l<=leftend) m[t++]=a[l++];\n\n    while(r<=rightend) m[t++]=a[r++];\n\n    for(int i=0;i<t;i++)\n\n    {\n\n        a[l+i]=m[i];\n\n    }\n\n}\n\nvoid msort()\n\n{\n\n    int temp[100];\n\n    sort(temp,0,n-1);\n\n}", "Tag": "算法分析"}
{"Answer": "排序效率根本就不能单纯的说哪种比哪种高吧，建议看看算法导论", "Konwledge_Point": "归并排序", "Question": "测试排序的效率,为什么:希尔排序>归并排序>快速排序?\n我看看几篇排序的算法的文章,大家都说效率一般都是:快速排序>归并排序>希尔排序\n\n\n\n然后就用java自己动手测了一下,测试结果却是:希尔排序>归并排序>快速排序\n\n\n\n而且当数据量过大时,归并排序 和 快速排序 会出现栈溢出.\n\n\n\n \n\n\n\n以下是我写的源代码,请帮我分析一下是什么原因?\n\n\n\n \n\n\n\npackage com.test;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class Sort {\n    public static void main(String[] args) {\n        int[] arr = new int[400000];\n        Random r = new Random();\n\n        long start, end;\n\n        init(arr, r);\n        System.out.print(\"希尔排序...\");\n        start = System.currentTimeMillis();\n        sort1(arr);\n        end = System.currentTimeMillis();\n        System.out.println(\"完成\" + (end - start));\n        //System.out.println(Arrays.toString(arr));\n\n        init(arr, r);\n        System.out.print(\"归并排序...\");\n        start = System.currentTimeMillis();\n        arr = sort2(arr, 0, arr.length - 1);\n        end = System.currentTimeMillis();\n        System.out.println(\"完成\" + (end - start));\n        //System.out.println(Arrays.toString(arr));\n\n        init(arr, r);\n        System.out.print(\"快速排序...\");\n        start = System.currentTimeMillis();\n        sort3(arr, 0, arr.length - 1);\n        end = System.currentTimeMillis();\n        System.out.println(\"完成\" + (end - start));\n        //System.out.println(Arrays.toString(arr));\n\n    }\n\n    /**\n     * 初始化\n     */\n    private static void init(int[] arr, Random r) {\n        System.out.print(\"\\n初始化...\");\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = r.nextInt(100);\n        }\n        //System.out.println(\"\\n\" + Arrays.toString(arr));\n    }\n\n    /**\n     * 希尔排序\n     */\n    private static void sort1(int[] a) {\n        int i, j, temp, increment;\n        // increment增量缩短，当增量为1时，即把整个数组进行插入排序\n        for (increment = a.length / 3; increment > 0; increment /= 3) {\n            for (i = increment; i < a.length; i++) {\n                temp = a[i];\n                for (j = i - increment; j >= 0 && temp < a[j]; j -= increment) {\n                    a[j + increment] = a[j];\n                }\n                a[j + increment] = temp;\n            }\n\n        }\n    }\n\n    /**\n     * 归并排序\n     * left,right参数表示:把a数组中fist--right之间的元素排序\n     * 排序结果以新数组返回.\n     */\n    private static int[] sort2(int[] a, int left, int right) {\n            //判断递归结束条件\n            if (right <= left) return new int[] { a[left] };\n            \n            //从数组中间切成左右两部分,mid为右边部分的起始下标\n            int mid = (left + right + 1) / 2;\n            //第一步:用递归把数组左边排序\n            int[] a1 = sort2(a, left, mid - 1);\n            //第二步:用递归把数组右边排序\n            int[] a2 = sort2(a, mid, right);\n            \n            //第三步:归并操作,把左右两边序列合并到新的数组\n            int[] result = new int[right - left + 1];\n            int i = 0, j = 0, k = 0;\n            while (i < a1.length && j < a2.length) {\n                if (a1[i] < a2[j])\n                    result[k++] = a1[i++];\n                else\n                    result[k++] = a2[j++];\n            }\n            while (j < a2.length) {\n                result[k++] = a2[j++];\n            }\n            while (i < a1.length) {\n                result[k++] = a1[i++];\n            }\n            return result;\n    }\n\n    /**\n     * 快速排序\n     * left,right参数表示:把a数组中left--right之间的元素排序\n     */\n    private static void sort3(int[] a, int left, int right) {\n        // 第四步:判断结束递归的条件\n        if(left>=right) return;\n        \n        // 第一步:以left为基数,把a分成左右两部分,使左边部分小于右边部分\n        int i = left;//最终i==j;\n        for (int b=1,j=right; i < j;) {// 最初b=1,表示以left为基数\n            if (a[i] > a[j]) {//交换位置\n                int temp = a[i];\n                a[i] = a[j];\n                a[j] = temp;\n                if (b==1) i++; else j--;//应基数位置不同,处理也不同\n                b = -b;//交换位置后,基数位置变化,b=1,表示以left为基数\n            } else {\n                if (b==1) j--; else i++;//应基数位置不同,处理也不同\n            }\n        }\n        // 第二步:递归排序左部分(left到i-1)\n        sort3(a,left,i-1);\n        // 第三步:递归排序右部分(i+1到right)\n        sort3(a,i+1,right);\n    }\n}\n\n\n\n\n 运行结果如下:\n\n\n\n \n\n\n\n初始化...希尔排序...完成40\n初始化...归并排序...完成53\n初始化...快速排序...完成1411\n\n\n\n \n\n\n\n ", "Tag": "算法分析"}
{"Answer": "```\r\nwhile (i < list1_size && j < list2_size)\r\n\t{\r\n\t\tif (list1[i] < list2[j])   //把j写成i了\r\n\t\t{\r\n\t\t\ttemp[k++] = list1[i++];\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\ttemp[k++] = list2[j++];\r\n\t\t}\r\n\t}\r\n```", "Konwledge_Point": "归并排序", "Question": "C语言归并排序问题 求解答\n请大家帮我看一下这段代码的问题，谢谢了\n\n\n\n/*先拆分，再两两归并!*/\n\n#include\n#define MAXSIZE 10\n\n/*归并后的数据存入list1*/\n\n\nvoid merging(int *list1, int list1_size, int *list2, int list2_size)//归并代码\n{\n    int temp[MAXSIZE];\n    int i, j, k;\n    int m;\n    i =j =k =0;\n\n\n    while(i < list1_size && j < list2_size)\n    {\n        if(list1[i] < list2[i])\n        {\n            temp[k++] = list1[i++];\n        }\n        else\n        {\n            temp[k++] = list2[j++];\n        }\n    }\n    while(i < list1_size)\n    {\n        temp[k++] = list1[i++];\n    }\n    while(j < list2_size)\n    {\n        temp[k++] = list2[j++];\n    }\n    for(m=0; m < (list1_size + list2_size); m++)\n    {\n        list1[m] = temp[m];\n    }\n}\n\n\n\nvoid MergeSort(int k[] , int n)//递归拆分代码\n{\n    if (n > 1)\n    {\n        int *list1 = k;\n        int list1_size = n/2;\n        int *list2 = k + n/2;\n        int list2_size = n - list1_size; \n\n        MergeSort(list1, list1_size);\n        MergeSort(list2, list2_size);\n\n        merging(list1, list1_size, list2, list2_size);//归并\n    }\n\n\n}\nint main()\n{\n    int i, a[10]={2,4,6,8,0,9,7,5,3,1};\n\n    MergeSort(a,10);\n\n    printf(\"排序后的结果是：\");\n\n    for(i=0;i<10;i++)\n    {\n        printf(\"%d \",a[i]);\n    }\n\n    printf(\"\\n\");\n\n    return 0;\n}\n\n\n\n\n\n图片说明", "Tag": "算法分析"}
{"Answer": "\n#include <iostream>\nusing namespace std;\n    void merge(int arr[], int start, int mid,int end)\n    { \n        mid = (start + end) / 2;\n        int mi = mid + 1;\n        int k = 0;\n        int  *tmp = new int[end-start+1];\n        int s = start;//下面start++自增，改变start的值，s为start备份 \n        while (start <= mid && mi <= end)\n        {\n            if (arr[start] <= arr[mi])//这里mid应该改为mi \n            {\n                tmp[k++] = arr[start++];\n            }\n            else \n            {\n                tmp[k++] = arr[mi++];\n            }\n           \n        }\n        //若其中一个没排完，把剩下的元素放进tmp\n        while (start <= mid) \n            tmp[k++] = arr[start++];\n        while (mi<= end)  \n            tmp[k++] = arr[mi++];\n \n        for (int i = s, j = 0; i <= end; i++, j++) {//用start的备份s，start已自增 \n            arr[i] = tmp[j];\n            cout << tmp[j] << \" \";\n        }\n        cout<<endl;\n        delete []tmp;\n        tmp = nullptr;\n    }\n \n    void merge_sort(int arr[], int start, int end)//递归\n    {\n        \n        if (arr==nullptr||end == 0 || ( end-start)==0)\n        {\n            return;\n        }\n        if(end-start == 1){//少了一步 \n        \tif(arr[start]>arr[end]){\n        \t\tint temp = arr[start];\n        \t\tarr[start] = arr[end];\n        \t\tarr[end] = temp;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n       \n        if (start < end)\n        {\n            int mid = (start + end) / 2;\n            int middle = mid + 1;\n           \n            merge_sort(arr, start, mid);\n            merge_sort(arr, middle , end);\n            merge(arr, start, mid, end);//将两个有序子数组合并操作\n        }\n      \n       \n    }\n   \n \nint main()\n{\n    int a[] = {3,2,9,20,8,15,18};\n    int length = sizeof(a) / sizeof(a[0]);\n    merge_sort(a, 0, length-1);\n    for (int i = 0; i < length; i++)\n        cout << a[i] << \" \";\n}\n ", "Konwledge_Point": "归并排序", "Question": "关于归并排序的一些BUG\n\n\n#include \nusing namespace std;\n\n /**\n   * 归并排序\n   * 简介:将两个（或两个以上）\"有序\"表合并成一个新的有序表 即把待排序序列分为若干个子序列，\n   *     每个子序列是有序的。然后再把有序子序列合并为整体有序序列\n   * 时间复杂度为O(nlogn)\n   * 稳定排序方式\n   * @param nums 待排序数组\n    @return 输出有序数组\n   **/\n    void merge(int arr[], int start, int mid,int end)\n    { \n        mid = (start + end) / 2;\n        int mi = mid + 1;\n        int k = 0;\n        int  *tmp = new int[end+1];\n        \n        while (start <= mid && mi <= end)\n        {\n            if (arr[start] <= arr[mid])\n            {\n                tmp[k++] = arr[start++];\n            }\n            else \n            {\n                tmp[k++] = arr[mi++];\n            }\n           \n        }\n        //若其中一个没排完，把剩下的元素放进tmp\n        while (start <= mid) \n            tmp[k++] = arr[start++];\n        while (mi<= end)  \n            tmp[k++] = arr[mi++];\n\n        for (int i = start, j = 0; i <= end; i++, j++) {\n            arr[i] = tmp[j];\n        }\n        delete []tmp;\n        tmp = nullptr;\n    }\n\n    void merge_sort(int arr[], int start, int end)//递归\n    {\n        \n        if (arr==nullptr||end == 0 || ( end-start)<=1)\n        {\n            return;\n        }\n       \n        if (start < end)\n        {\n            int mid = (start + end) / 2;\n            int middle = mid + 1;\n           \n            merge_sort(arr, start, mid);\n            merge_sort(arr, middle , end);\n            merge(arr, start, mid, end);//将两个有序子数组合并操作\n        }\n      \n       \n    }\n   \n\nint main()\n{\n    int a[] = {3,2,9,20,8,15,18};\n    int length = sizeof(a) / sizeof(a[0]);\n    merge_sort(a, 0, length-1);\n    for (int i = 0; i < length; i++)\n        cout << a[i] << \" \";\n}\n\n\n\n\n\n输出的时候发现排序不成功，有没有大佬帮忙看一下是哪里的问题？", "Tag": "算法分析"}
{"Answer": "结果没变化的原因![图片说明](https://img-ask.csdn.net/upload/202003/25/1585145095_87678.png)", "Konwledge_Point": "归并排序", "Question": "关于归并排序的输出问题\n使用归并排序后输出的数组还是原来的形式，没有变化，求大佬解决\n\n\n\n#include\nvoid merge(int arr[],int L,int M,int R)\n{\n    int left[M-L];\n    int right[R-M+1];\n    for(int i=L;i<M;i++)\n    {\n        left[i-L] = arr[i];\n    }\n    for(int i=M;i<=R;i++)\n    {\n        right[i-M] = arr[i];\n    }\n    int i=0,j=0,k=0;\n    while(i < M-L && j < R-M+1)\n    {\n        if(left[i] < right[j])\n        {\n        left[i] = arr[k];\n        i++;\n        k++;\n        }\n        else\n        {\n        right[j] = arr[k];\n        j++;\n        k++;\n        }\n    }\n    while(j < R-M+1)\n    {\n        right[j] = arr[k];\n        j++;\n        k++;\n    }\n\n    while(i < M-L)\n    {\n        left[i] = arr[k];\n        i++;\n        k++;\n    }\n}\n\nvoid merge_sort(int arr[],int L,int R)\n{\n    if(L == R)\n    return;\n    else \n    {   \n        int M = (L+R)/2;\n        merge_sort(arr,L,M); \n        merge_sort(arr,M+1,R); \n        merge(arr,L,M+1,R); \n    }\n}\n\nint main(void)\n{\n    int arr[] = {2,7,8,10,3,5,6,9}; \n    int L = 0;\n    int R = 7;\n    merge_sort(arr,L,R);\n    for(int i=0;i<=R;i++)\n    {\n        printf(\"%d \",arr[i]);\n    }\n    return 0;\n} \n", "Tag": "算法分析"}
{"Answer": "```\r\n#include\r\n#include\r\n#include\r\n//归并排序 先划分 分别排序 然后归并 \r\nint helper[100];\r\nvoid merger(int arr[], int left, int mid, int right, int *temp){\r\n\tint i = left;\r\n\tint j = mid + 1;\r\n\tint k = left;\r\n\twhile (i <= mid&&j <= right){\r\n\t\tif (arr[i] < arr[j]){\r\n\t\t\ttemp[k++] = arr[i++];\r\n\t\t}\r\n\t\telse{\r\n\t\t\ttemp[k++] = arr[j++];\r\n\t\t}\r\n\t}\r\n\twhile (i <= mid){\r\n\t\ttemp[k++] = arr[i++];\r\n\t}\r\n\twhile (j <= right){\r\n\t\ttemp[k++] = arr[j++];\r\n\t}\r\n\tmemcpy(arr + left, temp + left, sizeof(int)*(right - left+1));\r\n}\r\nvoid mergesort(int arr[],int left,int right,int *temp){\r\n\tint mid = 0;\r\n\tif (left < right){\r\n\t\tmid = left + (right - left) / 2;\r\n\t\tmergesort(arr, left, mid, temp);\r\n\t\tmergesort(arr, mid + 1, right, temp);\r\n\t\tmerger(arr, left, mid, right, temp);\r\n\t}\r\n}\r\nint main()\r\n{\r\nint a[]={1,3,5,7,9,2};\r\nmergesort(a,0,5,helper);\r\nfor(int i=0;i<6;i++)\r\nprintf(\"%d \",a[i]);\r\n}\r\n\r\n```", "Konwledge_Point": "归并排序", "Question": "请大神帮我看看 这归并排序哪里写错了\n#include\n\n#include\n\n#include\n\n//归并排序  先划分 分别排序 然后归并 \n\nint helper[100];\n\n\n\nvoid merger(int*a,int p,int mid,int r)\n\n{\n\n\n\nmemcpy(helper,a,sizeof(int)*(r-p+1));\n\nint left=p;//左侧队伍头部指针，指向带比较的元素 \nint right=mid+1;//右侧 \nint current=p;//原数组指针，指向代填入数据的位置; \nwhile(left<=mid&&right<=r)\n{\n    if(helper[left]<=helper[right])\n    { a[current]=helper[left];\n       current++;\n       left++;\n    }else{\n        a[current]=helper[left];\n       current++;\n       right++;\n    }\n}\nwhile(left<=mid)\n{\n    a[current]=helper[left];\n    current++;\n    left++;\n}\n\n\n\n\n}\n\nvoid mergersort(int*a,int p,int r)\n\n{\n\n    if(p<r)\n\n    {\n\n        int mid=(p+r)/2;\n\n        mergersort(a,p,mid);\n\n        for(int i=0;i<3;i++)\n\n\n\n    mergersort(a,mid+1,r);\n    for(int i=3;i<6;i++)\n\n    merger(a,p,mid,r);\n}\n\n\n\n\n} \n\nmain()\n\n{\n\n    int a[]={1,3,5,7,9,2};\n\n    mergersort(a,0,5);\n\n    for(int i=0;i<6;i++)\n\n    printf(\"%d\",a[i]);\n\n}", "Tag": "算法分析"}
{"Answer": "像这种递归的排序一部都有三个参数，数组，开始位置，结束位置，你这就两个参数，明显不对", "Konwledge_Point": "归并排序", "Question": "C语言利用归并排序法实现数据从小到大排列，最后执行时没有结果，想问一下大家这段代码问题出在哪里？\n\n", "Tag": "算法分析"}
{"Answer": "在针对java对象排序时，两个对象顺序一样，也只是一些key值一样，但是其他的成员变量不一样，这时就需要稳定的排序，保证原先在前面的对象排序后还是在前面。\r\n对于基本类型，如int, char，一样就是一样，没有先后顺序的区别。", "Konwledge_Point": "归并排序", "Question": "java 针对基本类型设计了“快速排序”，针对对象设计的“稳定归并排序”为什么？\n如题。为什么用两种不同方式？", "Tag": "算法分析"}
{"Answer": "结束条件应该是 if(lo>=hi) return;否则一开始的时候lo=1,hi=19，满足条件就结束了调试了一下，改成 if(lo>=hi) return;后排序正确", "Konwledge_Point": "归并排序", "Question": "归并排序未成功排序，求指正代码\n编译器未报错，但是为什么没有正确由小到大的排序呢？\n\n\n#\ninclude\n \n#\ninclude\n \n\nbool\n less(\nint\n a,\nint\n b);\nvoid \nMerge(\nint\n \n*\na\n,\nint\n \nlo\n,\nint\n \nmid\n,\nint\n \nhi\n)\n;\n//lo相当于left，hi相当于right。\n\nvoid \nSort(\nint\n \n*\na\n,\nint\n \nlo\n,\nint\n \nhi\n)\n;\n\nint\n main\n()\n\n{\n    \nint\n i;\n    \nint\n a\n[\n20\n]\n={\n1\n,\n4\n,\n3\n,\n5\n,\n7\n,\n8\n,\n5\n,\n4\n,\n7\n,\n9\n,\n11\n,\n43\n,\n54\n,\n32\n,\n56\n,\n234\n,\n6434\n,\n34\n,\n323\n,\n76\n,};\n    \nint\n length=\n20\n;\n    \nint\n lo=\n0\n;\n    \nint\n hi=length-\n1\n;\n    \nSort(\na\n,\nlo\n,\nhi\n)\n;\n    \nfor\n(i=\n0\n;imid){\n            a\n[\nk\n]\n=aux\n[\nj\n++\n]\n;\n        }\nelse\n \nif\n(j>hi){\n            a\n[\nk\n]\n=aux\n[\ni\n++\n]\n;\n        }\nelse\n \nif\n(less(aux\n[\nj\n]\n,aux\n[\ni\n]\n)){\n            a\n[\nk\n]\n=aux\n[\nj\n++\n]\n;\n        }\nelse\n{\n            a\n[\nk\n]\n=aux\n[\ni\n++\n]\n;\n        }      \n    }\n    return;\n}\nvoid \nSort(\nint\n \n*\na\n,\nint\n \nlo\n,\nint\n \nhi\n)\n\n{\n    \nif\n(lo<=hi) return;\n    \nint\n mid=lo+(hi-lo)/\n2\n;\n    \nSort(\na\n,\nlo\n,\nmid\n)\n;\n//左半边排序\n\n    \nSort(\na\n,\nmid\n+1,\nhi\n)\n;\n//右半边排序\n\n    \nMerge(\na\n,\nlo\n,\nmid\n,\nhi\n)\n;\n    return;\n}\n\n\n\n\n最后的输出仍然是原数组a的初始化数据，我甚至在想是不是根本没有比较。求指正。", "Tag": "算法分析"}
{"Answer": "我看到你这个问题，刚开始还以为是二分法，摸了半天瞎。后来发现时归并排序，然后我发现我也不会，就调你的程序，查资料什么事归并排序。\r\n然后发现其实问题很简单，\r\n\twhile(i<=mid) {\r\n\t\ts[k++]=a[i++];\r\n\t}\r\n\twhile(j<=end) {\r\n\t\ts[k++]=a[j++];\r\n\t}\r\n这个地方粗一看觉得是对的，但是后来我细想，要是1个排序的数组：4 5 3。然后经过你的这段程序，\r\nwhile(i<=mid && j<=end) {\r\n\t\tif(a[i]<a[j]) {\r\n\t\t\ts[k++]=a[i++];\r\n\t\t} else {\r\n\t\t\ts[k++]=a[j++];\r\n\t\t}\r\n\t}\r\n\r\nEnter 5 nimbers:\r\n5 4 3 2 1\r\n\r\n0-4\r\n0-2\r\n0-1\r\n0-0\r\n1-1\r\n 0 0 1\r\n    4    5    0    0    0\r\n2-2\r\n 0 1 2\r\n    3    4    0    0    0\r\n3-4\r\n3-3\r\n4-4\r\n 3 3 4\r\n    3    4    0    1    2\r\n 0 2 4\r\n    1    2    3    0    0\r\nThe sorted order is:\r\n    1    2    3    0    0\r\n第一次，把三排到最开始，i ++ 了，while就退出了，这是还有4 5没有合并，然后你下面的是if（），这就造成，最多只能加一个元素的情况，把5给\r\n丢了。现在是3 4，然后合并了 1 2，成了 3 4 0 1 2，在排序的时候，把 1 2 先拍， 这时候while退出，然后 就合并了一个 3 ， 4 给丢了。换成 while\r\n就行了。还有，定义数组要规范，然后还要初始化，这是规范化操作。我贴上了测试的数据。不知道你看不看得懂。", "Konwledge_Point": "归并排序", "Question": "哪位大神知道我这个归并排序的代码究竟哪里出了问题？\n代码如下：\n\n找了好久，实在找不出哪里的问题：\n\n\n\n #include\nvoid merge(int s[],int a[],int start,int mid,int end) \n{\n    int i=start;\n    int j=mid+1;\n    int k=start;\n    while(i<=mid && j<=end) {\n        if(a[i]<a[j]) {\n            s[k++]=a[i++];\n        } else {\n            s[k++]=a[j++];\n        }\n    }\n    if(i<=mid) {\n        s[k++]=a[i++];\n    }\n    if(j<=end) {\n        s[k++]=a[j++];\n    }\n}\n\nvoid merge_sort(int s[],int a[],int start,int end) \n{\n    int t[20]; \n    int mid; \n    if(start==end) {\n        s[start]=a[start];\n    } else {\n        mid=(start+end)/2;\n        merge_sort(t,a,start,mid);\n        merge_sort(t,a,mid+1,end);\n        merge(s,t,start,mid,end);\n    }\n}\n\nint main()\n{\n    int i;\n    int n=5;\n    int a[n],s[n];\n    printf(\"Enter %d nimbers: \\n\",n);\n    for(i=0;i<n;i++) {\n        scanf(\"%d\",&a[i]);\n    }\n    printf(\"\\n\");\n    merge_sort(s,a,0,n-1);\n    printf(\"The sorted order is: \\n\");\n    for(i=0;i<n;i++) {\n        printf(\"%5d\",s[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n", "Tag": "算法分析"}
{"Answer": "while(i<list2_size)\r\n    {\r\n        temp[k++]=list2[j++];\r\n    } \r\n\t\t\r\n这句中i改为j", "Konwledge_Point": "归并排序", "Question": "归并排序问题，代码是按照教学视频打的，为什么会出错，显示一些奇奇怪怪的数字\n如题，不知道是哪里疏漏了，请各位大神指教\n\n\n\n#include\n#include\n\nvoid merging(int list1[],int list1_size,int list2[],int list2_size)\n{\n    int temp[8],i=0,j=0,k=0;\n    while(i1)\n    {\n    int *list1=k;\n    int list1_size=n/2;\n    int *list2=k+n/2;\n    int list2_size=n/2;\n    merge_sort(list1,list1_size);\n    merge_sort(list2,list2_size);\n    merging(list1,list1_size,list2,list2_size);\n    }\n}\n\nint main()\n{\n    int a[8]={3,41,52,26,38,57,9,49};\n    merge_sort(a,8);\n    for(int i=0;i<8;i++)\n        printf(\"%d \",a[i]);\n    return 0;\n}\n", "Tag": "算法分析"}
{"Answer": "首先，int m=0; 这条语句有问题，应该是 int m=low;\r\n\r\n其次，\r\nfor(int i=0;i<=len;++i){\r\n\t\t data[i]=data2[i];\r\n}\r\n这条语句有问题，应该是\r\n\r\nfor( int i = 0; i < len; ++i,)\r\n\t\t data[ i + low ] = data2[ i ];\r\n}", "Konwledge_Point": "归并排序", "Question": "归并排序中合并总是少一些数，那个排序的函数已经写好了。\nint post_sort2(int data[] , int low   , int mid , int high)\n\n{\n\n    int len=high-low+1;\n\n    int data2[len];\n\n    int m=0;\n\n    int loc=0;\n\n    int n=mid+1;\n\n    while (m<=mid && n<=high)\n\n    {    if (data[m]<=data[n])\n\n        {    data2[loc]=data[m];\n\n            m=m+1;\n\n            loc=loc+1;\n\n        }\n\n        else\n\n        {    data2[loc]=data[n];\n\n            n=n+1;\n\n            loc=loc+1;\n\n        }\n\n    }\n\n    while (m<=mid)\n\n    {    data2[loc]=data[m];\n\n        loc=loc+1;\n\n        m=m+1;\n\n    }\n\n    while(n<=high)\n\n    {    data2[loc]=data[n];\n\n        loc=loc+1;\n\n        n=n+1;\n\n    }\n\n    for(int i=0;i<=len;++i)\n\n    {\n\n        data[i]=data2[i];\n\n    }\n\n    return 0;\n\n}", "Tag": "算法分析"}
{"Answer": "我说的是，在待排序数据本身有序的情况下，归并更快，我什么时候说“归并排序比快速排序快”了。", "Konwledge_Point": "归并排序", "Question": "link能不能改变排序算法？link如何实现归并排序？\n听说归并排序比快速排序快，有没有办法使用归并排序代替快速排序？", "Tag": "算法分析"}
{"Answer": "写了一个shell排序，把每一步的输出结果打印了一下\r\n```\r\n#include \r\n\r\nvoid shell_sort(int array[], int length){\r\n\tint i;\r\n\tint j;\r\n\tint k;\r\n\tint gap;\r\n\tint temp;\r\n\tfor(gap=length/2; gap>0; gap=gap/2){\r\n\t\tfor(i=0; i=0 && array[k]>temp){\r\n\t\t\t\t\t\tarray[k + gap] = array[k];\r\n\t\t\t\t\t\tk = k - gap;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tarray[k + gap] = temp;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nint main()\r\n{\r\n\tint arr[] = {12,2,16,30,8,128,4,10,20,6,18};\r\n\tshell_sort(arr, 11);\r\n\tfor (int ii = 0; ii < 11; ii++)\r\n\t\tprintf(\"%d \", arr[ii]);\r\n   printf(\"\\n\");\r\n   return 0;\r\n}\r\n```\r\n\r\n12 2 16 30 8 128 4 10 20 6 18 \r\n12 2 16 30 8 18 4 10 20 6 128 \r\n12 2 16 30 8 18 4 10 20 6 128 \r\n12 2 10 30 8 18 4 16 20 6 128 \r\n12 2 10 20 8 18 4 16 30 6 128 \r\n12 2 10 20 6 18 4 16 30 8 128 \r\n4 2 6 20 10 18 12 16 30 8 128 \r\n4 2 6 8 10 16 12 18 30 20 128 \r\n2 4 6 8 10 12 16 18 20 30 128 \r\n\r\n\r\n如果不理解，这里有动画过程，自己看看吧\r\nhttps://en.wikipedia.org/wiki/Shellsort", "Konwledge_Point": "归并排序", "Question": "【12，2，16，30，8，128，4，10，20，6，18】按照希尔排序\n上面的数字请按照希尔排序，并且有每一步详细的过程，还有它这种算法好在哪里，\n\n不还是要用直接插入排序吗。", "Tag": "算法分析"}
{"Answer": "（1）原因分析第9行的递归不会陷入死循环，因为它们都会递归到if(l==r)的情形然后return返回。（2）分析验证下面给出了一个用于验证的递归二叉树图上图表明初始(l,r)=(1,10)或(l,r)=(1,5)的情形最终都会递归到if(l==r)的情形然后return返回，因此不会陷入死循环。", "Konwledge_Point": "归并排序", "Question": "这个归并排序第8行不会死循环吗？\n这个归并排序第8行不会死循环吗？这个归并排序第8行不会死循环吗？为什么这个归并排序第8行不会死循环吗？", "Tag": "算法分析"}
{"Answer": "http://blog.sina.com.cn/s/blog_a80fd6510101b5u4.html", "Konwledge_Point": "归并排序", "Question": "Big String                     \nWe will construct an infinitely long string from two short strings: A = \"^__^\" (four characters), and B = \"T.T\" (three characters). Repeat the following steps:\n\nConcatenate A after B to obtain a new string C. For example, if A = \"^__^\" and B = \"T.T\", then C = BA = \"T.T^__^\".\n\nLet A = B, B = C -- as the example above A = \"T.T\", B = \"T.T^__^\".\n\nYour task is to find out the n-th character of this infinite string.\n\n\n\nInput\n\n\n\nThe input contains multiple test cases, each contains only one integer N (1 <= N <= 2^63 - 1). Proceed to the end of file.\n\n\n\nOutput\n\n\n\nFor each test case, print one character on each line, which is the N-th (index begins with 1) character of this infinite string.\n\n\n\nSample Input\n\n\n\n1\n\n2\n\n4\n\n8\n\n\n\nSample Output\n\n\n\nT\n\n.\n\n^\n\nT", "Tag": "算法分析"}
{"Answer": "望采纳！点击左下方的解决即可采纳！可以参考一下我的代码\n#include <stdio.h>\n#include <stdlib.h>\n\n// 归并两个有序子数组\nvoid merge(int* arr, int* temp, int left, int mid, int right)\n{\nint i = left, j = mid + 1, k = 0;\nwhile (i <= mid && j <= right)\n{\nif (arr[i] < arr[j])\n{\ntemp[k++] = arr[i++];\n}\nelse\n{\ntemp[k++] = arr[j++];\n}\n}\nwhile (i <= mid)\n{\ntemp[k++] = arr[i++];\n}\nwhile (j <= right)\n{\ntemp[k++] = arr[j++];\n}\nfor (int l = 0; l < k; l++)\n{\narr[left + l] = temp[l];\n}\n}\n\n// 递归归并排序\nvoid merge_sort(int* arr, int* temp, int left, int right)\n{\nif (left < right)\n{\nint mid = left + (right - left) / 2;\nmerge_sort(arr, temp, left, mid);\nmerge_sort(arr, temp, mid + 1, right);\nmerge(arr, temp, left, mid, right);\n}\n}\n\nint main()\n{\nint arr[] = { 9, 4, 5, 2, 7, 1, 3, 6, 8 };\nint len = sizeof(arr) / sizeof(int);\nint* temp = (int*)malloc(sizeof(int) * len);\nmerge_sort(arr, temp, 0, len - 1);\nfor (int i = 0; i < len; i++)\n{\nprintf(\"%d \", arr[i]);\n}\nreturn 0;\n}\n\n\n上面的代码包含了两个函数：merge和merge_sort。merge函数用于归并两个有序子数组，merge_sort函数用于递归调用merge函数实现归\n上面的代码包含了两个函数：merge和merge_sort。merge函数用于归并两个有序子数组，merge_sort函数用于递归调用merge函数实现归并排序", "Konwledge_Point": "归并排序", "Question": "一个归并排序的问题！\n归并排序，为什么没有运行排序，数组里的数据还是原封不动的顺序，求赐！", "Tag": "算法分析"}
{"Answer": "提个建议：问问题要有诚意，图都是模糊的，问题还要大家来猜吗", "Konwledge_Point": "归并排序", "Question": "最近在练习归并排序的算法，出现了一些问题怎么解决呢\n\n\n\n\n最近在练习归并排序的算法，出现了一些问题怎么解决呢最近在练习归并排序的算法，出现了一些问题怎么解决", "Tag": "算法分析"}
{"Answer": "修改完善如下，供参考：\n#include <stdio.h>\n#define MAX 100\ntypedef int Status;\nint e;\ntypedef struct {\n    int data[MAX];\n    int length;\n}Slist;\nint insert(Slist* L, int i, int e) {\n    if (i<1 || i>L->length + 1)\n        return 0;\n    for (int j = L->length; j >= i; j--)\n        L->data[j] = L->data[j - 1];\n    L->data[i - 1] = e;\n    L->length++;\n    return true;\n}\nStatus GetElem(Slist* L, int i, int& e) {\n    if (i<0 || i>L->length)\n        return 0;\n    e = L->data[i];\n    return e;\n}\nStatus locate(Slist L, int e) {\n    for (int i = 0; i < L.length; i++)\n        if (L.data[i] == e)\n            return i + 1;\n    return 0;\n}\nint length(Slist L) {\n    return L.length;\n}\nStatus  rank(Slist a, Slist b, Slist* c) {  //修改\n    Status ea, eb, ia = 0, ib = 0, ic = 1;\n    while (ia < a.length && ib < b.length) \n    {\n        GetElem(&a, ia, ea);\n        GetElem(&b, ib, eb);\n        if (ea <= eb){\n            insert(c, ic, ea);\n            ia++;\n        }\n        else {\n            insert(c, ic, eb);\n            ib++;\n        }\n        ic++;\n    }\n    while (ia < a.length) {\n        GetElem(&a, ia, ea);\n        insert(c, ic, ea);\n        ia++; ic++;\n    }\n    while (ib < b.length) {\n        GetElem(&b, ib, eb);\n        insert(c, ic, eb);\n        ib++; ic++;\n    }\n    return 0;\n    //Slist c{};\n    //c.length = 0;\n    //for (int k = 0; k < (a.length + b.length); k++) {\n    //    GetElem(&a, k, ea);\n    //    GetElem(&b, k, eb);\n    //    if (ea <= eb);\n    //    insert(&c, k + 1, ea);\n    //    insert(&c, k + 2, eb);\n    //    return 0;\n    //}\n}\nvoid print(Slist L)   //修改\n{\n    int i;\n    for (i = 0; i < L.length; i++)\n        printf(\"%d \", L.data[i]);\n    printf(\"\\n\");\n}\nint main() {\n    Slist La{};\n    La.length = 0;\n    Slist Lb{};\n    Lb.length = 0;\n    Slist Lc{};\n    Lc.length = 0;\n\n    insert(&La, 1, 1);\n    insert(&La, 2, 7);\n    insert(&La, 3, 8);\n    insert(&Lb, 1, 2);\n    insert(&Lb, 2, 4);\n    insert(&Lb, 3, 6);\n    insert(&Lb, 4, 8);\n    insert(&Lb, 5, 10);\n    insert(&Lb, 6, 11);\n\n    printf(\"La:\");\n    print(La);\n    printf(\"Lb:\");\n    print(Lb);\n\n    rank(La, Lb, &Lc);\n    printf(\"Lc:\");\n    print(Lc);\n    return 0;\n}\n\n", "Konwledge_Point": "归并排序", "Question": "已知线性表La和Lb中的数据元素按值非递减有序排列，现要求La和Lb归并排序为Lc\n我想知道我这段rank中a和b表的元素为什么只传递了1和2给c，后续就不在执行了?\n已知线性表La和Lb中的数据元素按值非递减有序排列，现要求La和Lb归并排序为Lc\n我想知道我这段rank中a和b表的元素为什么只传递了1和2给c，后续就不在执行了?\n代码如下\n#include \n\n\n\n#define MAX 100\ntypedef int Status;\nint e;\ntypedef struct {\n    int data[MAX];\n    int \nlength\n;\n}Slist;\nint \ninsert\n(Slist \n*L, int i, int e) {\n    if (i<1 || i>L->length + 1)\n        return 0;\n\n    for (int j = L->\nlength\n; j >= i; j--)\n        L->data[j] = L->data[j-1];\n    L->data[i - 1] = e;\n    L->\nlength\n++;\n    \nreturn\n true;\n}\nStatus GetElem(Slist\n* L, int i,int& e){\n        if (i<0 || i>L->length)\n            return 0;\n\n    e = L->data[i];\n    \nreturn\n e;\n}\nStatus locate(Slist L,int e) {\n    for (int i = 0; i < L.\nlength\n; i++)\n        \nif\n (L.data[i] == e)\n            \nreturn\n i + 1;\n    \nreturn\n 0;\n}\nint \nlength\n(Slist L){\n    \nreturn\n L.\nlength\n;\n}\nStatus  \nrank\n(Slist a,Slist b ) {\n    int ea;\n    int eb;\n    Slist c{};\n    c.\nlength\n = 0;\n    for (int k = 0; k < (a.\nlength\n+b.\nlength\n); k++) {\n        GetElem(\n&a\n, k, ea);\n        GetElem(\n&b\n, k, eb);\n        \nif\n (ea <= eb);\n        \ninsert\n(\n&c\n, k+1, ea);\n        \ninsert\n(\n&c\n, k+2, eb);\n        \nreturn\n 0;\n    }\n}\nint mai\nn\n() {\n    Slist La{};\n    La.\nlength\n = 0;\n    Slist Lb{};\n    Slist Lc{};\n    Lb.\nlength\n = 0;\n    Lc.\nlength\n = 0;\n    \ninsert\n(\n&La\n, 1, 1);\n    \ninsert\n(\n&La\n, 2, 7);\n    \ninsert\n(\n&La\n, 3, 8);\n    \ninsert\n(\n&Lb\n, 1, 2);\n    \ninsert\n(\n&Lb\n, 2, 4);\n    \ninsert\n(\n&Lb\n, 3, 6);\n    \ninsert\n(\n&Lb\n, 4, 8);\n    \ninsert\n(\n&Lb\n, 5, 10);\n    \ninsert\n(\n&Lb\n, 6, 11);\n    \nrank\n(La,Lb);\n}\n\n\n\nrank函数的运行结果：\n\n", "Tag": "算法分析"}
{"Answer": "sort 中最后for循环应该i<=t吧", "Konwledge_Point": "归并排序", "Question": "关于归并排序求逆序对数\n利用归并排序求逆序对数，但是结果是错误的，帮忙看看哪里出错了\n\n\n\n\n#include\n\n\nint\n \nindex\n = \n0\n;\n\nint\n main() {\n    \nvoid\n Merge(\nint\n a[], \nint\n a1[], \nint\n s, \nint\n m, \nint\n t);\n    \nvoid\n MergeSort(\nint\n a[], \nint\n s, \nint\n t);\n    \nint\n a[\n6\n];\n    \nfor\n (\nint\n i = \n0\n; i < \n6\n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n    printf(\"\\n\");\n    MergeSort(a, \n0\n, \n5\n);\n    printf(\"%d\", \nindex\n);\n}\n\nvoid\n Merge(\nint\n a[], \nint\n a1[], \nint\n s, \nint\n m, \nint\n t) {\n    \nint\n i = s;\n    \nint\n j = m + \n1\n;\n    \nint\n k = s;\n    \nwhile\n (i <= m && j <= t) {\n        \nif\n (a[i] <= a[j]) {\n            a1[k] = a[i];\n            k++;\n            i++;\n        }\n        \nelse\n {\n            a1[k] = a[j];\n            k++;\n            j++;\n            \nindex\n += m - i + \n1\n;\n        }\n    }\n    \nwhile\n (i <= m) a1[k++] = a[i++];\n    \nwhile\n (j <= t) a1[k++] = a[j++];\n}\n\nvoid\n MergeSort(\nint\n a[], \nint\n s, \nint\n t) {\n    \nint\n a1[\n1000\n];\n    \nint\n m;\n    \nif\n(s < t) {\n        m = (s + t) / \n2\n;\n        MergeSort(a, s, m);\n        MergeSort(a, m + \n1\n, t);\n        Merge(a, a1, s, m, t);\n    }\n    \nfor\n (\nint\n i = s; i < t; i++) {\n        a[i] = a1[i];\n    }\n}\n\n\n", "Tag": "算法分析"}
{"Answer": "不能<=L.end()的，end()已经是结束符，没有对象了。\n#include<vector>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nvoid mergesort(vector<int>&T,int left,int right)\n{\n    int mid=(right-left)/2;\n    vector<int>L;\n    vector<int>R;\n    vector<int>ans;\n    L.insert(L.begin(),T.begin()+left,T.begin()+left+mid);\n    R.insert(R.begin(),T.begin()+left+mid+1,T.begin()+right);\n    vector<int>::iterator i=L.begin();\n    vector<int>::iterator j=R.begin();\n    while(i<L.end()&&j<R.end())\n    {\n         if((*i)<=(*j))\n         {\n              ans.push_back((*i));\n              i++;\n         }\n         else if((*i)>=(*j))\n         {\n            ans.push_back((*j));\n            j++;    \n         }    \n    }\n    if(i<L.end())\n    {\n        while(i<L.end())\n        {\n            ans.push_back((*i));\n            i++;\n        }\n    }\n    else if(j<R.end())\n    {    \n        while(j<R.end())\n        {\n            ans.push_back((*j));\n            j++;\n        }\n    }\n     vector<int>::iterator k=ans.begin();\n    for(;k<ans.end();k++)\n    {\n        cout<<(*k)<<\" \";\n    }\n}\n int main()\n {\n     int i;\n     vector<int>T;\n     for(i=0;i<=9;i++)\n     {\n         int n;\n         cin>>n;\n         T.push_back(n);\n    }\n    mergesort(T,0,9);\n    return 0;\n }\n\n", "Konwledge_Point": "归并排序", "Question": "C++二路归并排序（非递归）\nC++二路归并排序（非递归）\n输入10个数组成的局部有序的数组，对所有数据进行二路归并排序再输出\n输入：0 2 4 7 9 1 3 4 5 0\n输出：0 0 1 2 3 4 4 5 7 9\n错误输出：0123445-1700（DEVC++）\n代码如下：\n\n\n\n```c++\n#\ninclude\n\n#\ninclude\n\n#\ninclude\n\n#\ninclude\n\nusing namespace std;\nvoid mergesort(vector<\nint\n>&T,\nint\n left,\nint\n right)\n{\n    \nint\n mid=(right-left)/\n2\n;\n    vector<\nint\n>L;\n    vector<\nint\n>R;\n    vector<\nint\n>ans;\n    \nL\n.\ninsert(\nL\n.\nbegin\n()\n,\nT\n.\nbegin\n()\n+left,\nT\n.\nbegin\n()\n+left+mid);\n    \nR\n.\ninsert(\nR\n.\nbegin\n()\n,\nT\n.\nbegin\n()\n+left+mid+\n1\n,\nT\n.\nbegin\n()\n+right);\n    vector<\nint\n>::iterator i=\nL\n.\nbegin\n()\n;\n    vector<\nint\n>::iterator j=\nR\n.\nbegin\n()\n;\n    \nwhile\n(i<=\nL\n.\nend\n()\n&&j<=\nR\n.\nend\n()\n)\n    {\n     \nif\n((*i)<=(*j))\n     {\n          ans.push\n_back((\n*\ni\n)\n);\n          i++;\n     }\n     \nif\n((*i)>=(*j))\n     {\n        ans.push\n_back((\n*\nj\n)\n);\n        j++;    \n     }    \n    }\n    \nif\n(i<=\nL\n.\nend\n()\n)\n    {\n        \nwhile\n(i<=\nL\n.\nend\n()\n)\n        {\n            ans.push\n_back((\n*\ni\n)\n);\n            i++;\n        }\n    }\n    \nelse\n \nif\n(j<=\nR\n.\nend\n()\n)\n    {    \n        \nwhile\n(j<=\nR\n.\nend\n()\n)\n        {\n            ans.push\n_back((\n*\nj\n)\n);\n            j++;\n        }\n    }\n     vector<\nint\n>::iterator k=ans.\nbegin\n()\n;\n    \nfor\n(;k<=ans.\nend\n()\n;k++)\n    {\n        cout<<(*k);\n    }\n}\n \nint\n main\n()\n\n {\n     \nint\n i;\n     vector<\nint\n>T;\n     \nfor\n(i=\n0\n;i<=\n9\n;i++)\n     {\n         \nint\n n;\n         cin>>n;\n         \nT\n.\npush\n_back(\nn\n)\n;\n    }\n    mergesort(T,\n0\n,\n9\n);\n    return \n0\n;\n }\n\n\n\n\n```", "Tag": "算法分析"}
{"Answer": "你别发图片 发代码吧，发图片分成几张 眼睛都看花了", "Konwledge_Point": "归并排序", "Question": "为什么C语言归并排序失败了\n如下是VS2022的C语言代码\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ndefine\n N 10\n\n\nint\n \nmain\n(\nvoid\n)\n\n\n{\n    \nint\n I, alx, alxEnd, blx, blxEnd, clx, glx, size;\n    _Bool CopyA, CopyB;\n    \nint\n arr[N];\n    \nint\n temp[N] = { \n0\n };\n    \nprintf\n(\n\"Define a random number group:\\n\"\n);\n    \nfor\n (I = \n0\n; I < N; ++I)      \n/*给数组赋值随机变量*/\n\n    {\n        arr[I] = (\nint\n)(\nrand\n() % \n100\n);\n        \nprintf\n(\n\"%d \"\n, arr[I]);\n    }\n    \nprintf\n(\n\"\\n\"\n);\n    \nfor\n (size = \n1\n; size < N; size += size);   \n//归并排序\n\n    {\n        \nfor\n (glx = \n0\n; glx < N; glx += \n2\n * size)\n        {\n            alx = glx;\n            alxEnd = (N < (alx + size)) ? N : (alx + size);\n            blx = glx + size;\n            blxEnd = (N < (blx + size)) ? N : (blx + size);\n            clx = glx;\n            \nwhile\n ((alx < alxEnd) || (blx < blxEnd))\n            {\n                CopyA = \n0\n;\n                CopyB = \n0\n;\n                \nif\n ((alx < alxEnd) && (blx < blxEnd))\n                {\n                    CopyA = (arr[alx] < arr[blx]);\n                    CopyB = !CopyA;\n                }\n                \nelse\n\n                {\n                    \nif\n (alx >= alxEnd)\n                    {\n                        CopyB = \n1\n;\n                    }\n                    \nelse\n\n                    {\n                        CopyA = \n1\n;\n                    }\n                }\n                \nif\n (CopyA == \n1\n)\n                {\n                    temp[clx] = arr[alx];\n                    alx++;\n                }\n                \nif\n (CopyB == \n1\n)\n                {\n                    temp[clx] = arr[blx];\n                    blx++;\n                }\n                clx++;\n            }\n        }\n        \nfor\n (I = \n0\n; I < N; ++I)\n        {\n            arr[I] = temp[I];\n        }\n    }\n    \nprintf\n(\n\"Here is the group that has been arranged:\\n\"\n);\n    \nfor\n (I = \n0\n; I < N; ++I)\n    {\n        \nprintf\n(\n\"%d \"\n, arr[I]);\n    }\n    \nreturn\n \n0\n;\n}\n\n\n\n\n\n\n我用X-program就成功了\n\n\n\n\n这是为什么呀？", "Tag": "算法分析"}
{"Answer": "sort是先快排1.5*log2(n)次，若长度大于32，则改用堆排。C++有个partial_sort堆排，和他的sort用的时间差不多一样，可以确定就是用的堆排", "Konwledge_Point": "归并排序", "Question": "对1000000个随机数的数组进行排序，测试c++库里的sort()用时比自己写的归并排序用时长，是出了什么问题吗？\n我想要比较sort和归并对同一个数组排序的用时长短，觉得应该sort（）比自己写的快，但实验结果却相反。1000000左右的排序似乎其他人测试的sort用时大概在0.15左右，但我运行的却是0.5以上。是代码有问题还是运行出了问题呢？\n\n\n#\ninclude\n \n#\ninclude\n\n#\ninclude\n \n#\ninclude\n\nusing namespace std;\ntemplate<\nclass\n T1>\nvoid \nMerge(T1 \na\n[], \nint\n \nl\n, \nint\n \nm\n, \nint\n \nr\n, T1 \nc\n[])\n\n{\n    \n//已知a[l]<=…<=a[m];a[m+1]<=a[r]\n\n    \n//归并到c[l]~c[r]，并复制到a[l]~a[r]\n\n    \nint\n i = l;\n    \nint\n j = m + \n1\n;\n    \nint\n k = l;\n    \nwhile\n (i <= m\n && \nj <= r)\n    {\n        \nif\n (a\n[\ni\n]\n < a\n[\nj\n]\n)\n        {\n            c\n[\nk\n]\n = a\n[\ni\n]\n;\n            i++;\n            k++;\n        }\n        \nelse\n\n        {\n            c\n[\nk\n++\n]\n = a\n[\nj\n++\n]\n;\n        }\n    }\n    \nwhile\n (i <= m)\n    {\n        c\n[\nk\n++\n]\n = a\n[\ni\n++\n]\n;\n    }\n    \nwhile\n (j <= r)\n    {\n        c\n[\nk\n++\n]\n = a\n[\nj\n++\n]\n;\n    }\n    k = l;\n    \nwhile\n (k <= r)\n    {\n        a\n[\nk\n]\n = c\n[\nk\n]\n;\n        k++;\n    }\n}\ntemplate<\nclass\n T11>\nvoid \nMergeSort(T11 \na\n[], \nint\n \nl\n, \nint\n \nr\n, T11 \nc\n[])\n\n{\n    \n//a[l]~a[r]进行排序\n\n    \nif\n (l >= r)\n    {\n        return;\n    }\n    \nint\n m = (l + r)\n / \n2\n;\n    \nMergeSort(\na\n, \nl\n, \nm\n, \nc\n)\n;\n    \nMergeSort(\na\n, \nm\n + 1, \nr\n, \nc\n)\n;\n    \nMerge(\na\n, \nl\n, \nm\n, \nr\n, \nc\n)\n;\n}\n\nvoid main\n()\n\n{\n    \nint\n n;\n    n = \n1000000\n;\n    \nfloat\n* a = \nnew\n \nfloat\n[\nn\n]\n;\n    \nfloat\n* b = \nnew\n \nfloat\n[\nn\n]\n;\n    \nfloat\n* c = \nnew\n \nfloat\n[\nn\n]\n;\n    \nfor\n (\nint\n i = \n0\n; i < n; i++)\n    {\n        \n//cout << \"随机生成a[\" << i << \"]的值为\";\n\n        a\n[\ni\n]\n = rand\n()\n % \n100000000\n;\n        b\n[\ni\n]\n = a\n[\ni\n]\n;\n        \n//cout << a[i] << endl;\n\n    }\n\n    clock_t start1, end1, start2, end2;\n    start1 = clock\n()\n;\n    \nMergeSort(\na\n, 0, 999999, \nc\n)\n;\n    end1 = clock\n()\n;\n    cout << start1 << \n\" \"\n << end1;\n    cout << \n\"归并排序用时为\"\n <<(double)( end1 - start1)/CLOCKS_PER_SEC << endl;\n\n    start2 = clock\n()\n;\n    sort(b, b + \n1000000\n);\n    end2 = clock\n()\n;\n    cout << start2 << \n\" \"\n << end2;;\n    cout << \n\"sort函数用时为\"\n << (double)(end2 - start2) /CLOCKS_PER_SEC << endl;\n\n    \nfor\n (\nint\n i = \n0\n; i < \n1000000\n; i++)\n    {\n        \nif\n (a\n[\ni\n]\n != b\n[\ni\n]\n)\n            cout << \n\"error!\"\n << endl;\n    }\n\n    delete\n[]\n a;\n    delete\n[]\n b;\n    delete\n[]\n c;\n\n}\n\n\n\n代码大概就是这样，通过前两个函数进行归并排序，并用了模板类。之后用rand（）随机产生随机数。a数组和b数组完全一样。对a数组进行归并排序，对b数组进行sort排序。c数组是为了辅助归并排序的数组。之后用clock（）进行计时，输出得到用时。最后那个循环是为了检测是否归并排序出错。\n\n\n运行结果及报错内容\n\n\n\n\n我的运行结果大概是这样的，归并0.15左右，而sort0.5以上。\n\n\n我的解答思路和尝试过的方法\n\n\n我尝试用不同的函数获取用时，timeGetTime（），GetTickCourt（）。但结果都是这样的\n\n\n我想要达到的结果\n\n\n我想要得到sort（）和归并到底谁更快，以及为什么我的实验结果sort（）运行有0.5s以上这么久？\n\n\n求高人指点！", "Tag": "算法分析"}
{"Answer": "你的递归函数跑到main函数里面去了。还在用记事本编辑java呢？ :lol:", "Konwledge_Point": "归并排序", "Question": "初学，请帮小弟. 运行结果已经写出帮看一下原因。万分感谢\nimport java.util.Scanner;\n\n\n\npublic class UseRecursion\n\n{\n\n    public static void main(String[] args)\n\n    {\n\n        Scanner scanner =new Scanner(System.in);\n\n\n\n    System.out.println(\"输入两数：\");\n    System.out.print(\"m=\");\n    int m = scanner.nextInt();\n\n    System.out.print(\"n=\");\n    int n = scanner.nextInt();\n\n    System.out.println(\"GCD：\"+ gcd(m, n));\n\nprivate static int gcd(int m, int n)//辗转相除法球最大公因式\n{\n     if(n == 0)\n        return m;\n     else\n        return gcd(n, m % n);\n    }\n}\n\n\n\n\n}\n\n     /*等价于下面的循环调用：\n\n     private static int gcd(int m,int n)\n\n     {\n\n      int r;\n\n      while(n!=0)\n\n      {\n\n        r = m % n;\n\n        m=n;\n\n        n=r;\n\n      }\n\n      return m;\n\n     }\n\n     */\n\n\n\n结果：\n\nUseRecursion.java:24: 非法的表达式开始\n\n    private static int gcd(int m, int n)//辗转相除法球最大公因式\n\n    ^\n\nUseRecursion.java:24: 非法的表达式开始\n\n    private static int gcd(int m, int n)//辗转相除法球最大公因式\n\n            ^\n\nUseRecursion.java:24: 需要 ';'\n\n    private static int gcd(int m, int n)//辗转相除法球最大公因式\n\n                  ^\n\nUseRecursion.java:24: 需要 \".class\"\n\n    private static int gcd(int m, int n)//辗转相除法球最大公因式\n\n                               ^\n\nUseRecursion.java:24: 需要 ';'\n\n    private static int gcd(int m, int n)//辗转相除法球最大公因式\n\n                                ^\n\nUseRecursion.java:24: 需要 ';'\n\n    private static int gcd(int m, int n)//辗转相除法球最大公因式\n\n                                       ^", "Tag": "算法分析"}
{"Answer": "```\r\n int lo, int mid, int hi\r\n分别是待归并的两部分数组的起始位置，第一个是lo~mid，第二个是mid+1~hi\r\n\r\n        int i = lo;\r\n        int j = mid + 1;\r\n开始的时候，i和j分别指向两部分数组的开始位置\r\n\r\nfor (int k = lo; k < hi + 1; k++) {\r\n            b[k] = a[k];\r\n        }\r\n首先复制一份拷贝到b里面，而原来的a数组的相应位置则保存排序后的结果\r\n\r\nfor (int k = lo; k < hi + 1; k++) {\r\n\r\n            if (i > mid) { //i > mid说明第一个数组中的数据都已经插入到a里面了，而第二个数组是有序的，所以照着复制就可以\r\n                a[k] = b[j++];\r\n            } else if (j > hi) { //j>h说明第二个数组已经都插入进去了，而第一个数组是有序的，所以照着复制\r\n                a[k] = b[i++];\r\n            } else if (less(b[i], b[j])) { //第一个数组的当前元素比第二个小，那么先插入第一个数组的（插入后i往后移动一个），第二个不动。\r\n                a[k] = b[i++];\r\n            } else { //第一个数组比第二个大，那么先插入第二个的，第一个不动\r\n                a[k] = b[j++];\r\n            }\r\n        }\r\n\r\n```", "Konwledge_Point": "归并排序", "Question": "关于java归并排序的问题\n下面是代码 我的问题是 Merge方法里面的那四种判断是根据什么来的？j>hi是怎么回事，\n\n\n\n public class Merge {\n\n    private static Comparable[] b;\n\n    public static boolean less(Comparable v, Comparable w) {\n        return v.compareTo(w) < 0;\n    }\n\n    public static void merge(Comparable[] a, int lo, int mid, int hi) {\n        int i = lo;\n        int j = mid + 1;\n\n        for (int k = lo; k < hi + 1; k++) {\n            b[k] = a[k];\n        }\n        for (int k = lo; k < hi + 1; k++) {\n\n            if (i > mid) {\n                a[k] = b[j++];\n            } else if (j > hi) {\n                a[k] = b[i++];\n            } else if (less(b[i], b[j])) {\n                a[k] = b[i++];\n            } else {\n                a[k] = b[j++];\n            }\n        }\n    }\n\n    /**\n     * 自顶向下和自底向上\n     *\n     * @param a\n     */\n    public static void sort(Comparable[] a) {\n        b = new Comparable[a.length];\n        // 自顶向下\n        sort(a, 0, a.length - 1);\n\n        //自底向上\n//        for (int i = 1; i < a.length; i++) {\n//            for (int lo = 0; lo < a.length - i; lo += i + i) {\n//                merge(a, lo, lo + i - 1, Math.min(lo + i + i - 1, a.length - 1));\n//            }\n//        }\n    }\n\n    public static void sort(Comparable[] a, int lo, int hi) {\n        if (hi <= lo) {\n            return;\n        }\n        int mid = lo + (hi - lo) / 2;\n        sort(a, lo, mid);\n        sort(a, mid + 1, hi);\n        merge(a, lo, mid, hi);\n    }\n\n    public static void show(Comparable[] a) {\n        for (int i = 0; i < a.length; i++) {\n            System.out.print(a[i] + \" \");\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        Integer[] a = new Integer[10];\n        for (int i = 0; i < 10; i++) {\n            a[i] = (int) (Math.random() * 10 + 1);\n        }\n        show(a);\n        sort(a);\n        show(a);\n    }\n\n}\n\n", "Tag": "算法分析"}
{"Answer": "你的merge代码没有考虑left和right数组元素数目不等的情况。\n#include <iostream>\nusing namespace std;\n\nvoid Merge(int *A, int p, int q, int r)\n{\n    int n1 = q - p + 1;\n    int n2 = r - q;\n\n    int *L = new int[n1];\n    int *R = new int[n2];\n\n    for (int i = 0; i < n1; i++)\n        L[i] = A[p + i];\n\n    for (int j = 0; j < n2; j++)\n        R[j] = A[q + j + 1];\n\n    int i = 0;\n    int j = 0;\n    int k = p;\n\n    // Merge L[] and R[] into A[]\n    while (i < n1 && j < n2)\n    {\n        if (L[i] <= R[j])\n            A[k++] = L[i++];\n        else\n            A[k++] = R[j++];\n    }\n    // Copy the remaining element of L[], if there are any\n    while (i < n1)\n        A[k++] = L[i++];\n    // Copy the remaining element of R[], if there are any\n    while (j < n2)\n        A[k++] = R[j++];\n\n    delete[] L;\n    delete[] R;\n}\n\nvoid Merge_Sort(int *A, int low, int high)\n{\n    int mid;\n    if (low < high)\n    {\n        mid = (low + high) / 2;\n        Merge_Sort(A, low, mid);\n        Merge_Sort(A, mid + 1, high);\n        Merge(A, low, mid, high);\n    }\n}\n\nint main()\n{\n    int A[10] = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};\n    int low = 0;\n    int high = 9;\n    int mid = (low + high) / 2;\n    Merge(A, low, mid, high);\n    Merge_Sort(A, 0, 9);\n\n    for (int m = 0; m < 10; m++)\n    {\n        cout << A[m] << \" \";\n    }\n\n    cout << endl;\n\n    return 0;\n}\n", "Konwledge_Point": "归并排序", "Question": "<算法导论第三版>的伪代码写的C++的归并排序\n问题遇到的现象和发生背景\n\n\n这是一个归并排序,是根据<算法导论第三版> 的伪代码写的,可是最终得到的结果总是错误的,不知道怎么回事总会访问到特定的数组外但是也没有发生编译过程的错误.\n\n\n用代码块功能插入代码，请勿粘贴截图\n\n\n\n\n我想要达到的结果\n\n\n#\ninclude\n\nusing namespace std;\n\nvoid \nMerge(\nint\n \n*\nA,\nint\n \np\n,\nint\n \nq\n,\nint\n \nr\n)\n\n{\n    \nint\n n1 = q - p;\n    \nint\n n2 = r - q;\n    \n    cout << \n\"q-p=\"\n << q - p << endl;\n    \nint\n* L = \nnew\n \nint\n[\nn1\n+\n1\n]\n;\n    \nint\n* R = \nnew\n \nint\n[\nn2\n]\n;\n\n    \nfor\n (\nint\n i = \n0\n; i <= n1; i++)\n    {\n        L\n[\ni\n]\n = A\n[\np\n + \ni\n]\n;\n        \n    }\n    \n    \nfor\n (\nint\n j = \n0\n; j < n2; j++)\n    {\n        R\n[\nj\n]\n = A\n[\nq\n + \nj\n + \n1\n]\n;\n    }\n    \nint\n i = \n0\n;\n    \nint\n j = \n0\n;\n\n    \nfor\n (\nint\n k = p; k < r; k++)\n    {\n        \nif\n (L\n[\ni\n]\n <= R\n[\nj\n]\n)\n        {\n            A\n[\nk\n]\n = L\n[\ni\n]\n;\n            i++;\n        }\n        \nelse\n\n        {\n                A\n[\nk\n]\n = R\n[\nj\n]\n;\n                j++;\n        }\n    }\n\n}\n\n\nvoid \nMerge_Sort(\nint\n*\n A, \nint\n \nlow\n, \nint\n \nhigh\n)\n\n{\n    \nint\n mid;\n    \nif\n (low < high)\n    {\n        mid = ((low + high)\n / \n2\n);\n        \nMerge_Sort(A, \nlow\n, \nmid\n)\n;\n        \nMerge_Sort(A, \nmid\n + 1, \nhigh\n)\n;\n        \nMerge(A, \nlow\n, \nmid\n, \nhigh\n)\n;\n    }\n\n}\n\n\n\nint\n main\n()\n\n{\n    \nint\n A\n[\n10\n]\n = {\n10\n,\n9\n,\n8\n,\n7\n,\n6\n,\n5\n,\n4\n,\n3\n,\n2\n,\n1\n};\n    \nint\n low = \n0\n;\n    \nint\n high = \n9\n;\n    \nint\n mid = (low + high)\n / \n2\n;\n    \nMerge(A, \nlow\n, \nmid\n, \nhigh\n)\n;\n    \nMerge_Sort(A, 0, 9)\n;\n\n    \nfor\n (\nint\n m = \n0\n; m < \n10\n; m++)\n    {\n        cout << A\n[\nm\n]\n << \n\" \"\n;\n    }\n\n    cout << endl;\n    \n    return \n0\n;\n}\n\n", "Tag": "算法分析"}
{"Answer": "可参考博文：https://blog.csdn.net/qq_42589613/article/details/110431662\n\n# -*- coding: utf-8 -*-\ndef merge(left, right):\n    # 合并两个有序列表\n    res = []\n    while len(left) > 0 and len(right) > 0:\n        if left[0] < right[0]:\n            res.append(left.pop(0))\n        else:\n            res.append(right.pop(0))\n    if left:\n        res.extend(left)\n    if right:\n        res.extend(right)\n    return res\n\ndef mergeSort(arr):\n    # 归并函数\n    n = len(arr)\n    if n < 2:\n        return arr\n    middle = n // 2\n    left = arr[:middle] # 取序列左边部分\n    right = arr[middle:]# 取序列右边部分\n    # 对左边部分序列递归调用归并函数\n    left_sort = mergeSort(left)\n    # 对右边部分序列递归调用归并函数\n    right_sort = mergeSort(right)\n    #\n    return merge(left_sort, right_sort)\narr = [1,4,7,9,2,3,5,8]\na = mergeSort(arr)\nprint(a)\n", "Konwledge_Point": "归并排序", "Question": "python实现归并排序时，输出“[0, 0, 0, 0, 0, 0, 0, 0]”\n问题遇到的现象和发生背景\n\n\npython实现归并排序时 ，单独调用merge可以输出正确，但是sort、merge一起调用输出结果 \n\n\n[0, 0, 0, 0, 0, 0, 0, 0]\n\n\n自学数据结构到归并排序，不知道哪里有错误\n\n\n用代码块功能插入代码，请勿粘贴截图\n\n\nimport\n sys\nsys.setrecursionlimit(\n100000\n) \n#例如这里设置为十万\n\n\n\ndef\n \nsort\n(\narr,low,high\n):\n    \nif\n low < high :\n        mid = \nint\n((low+high)/\n2\n)\n        sort(arr,low,mid)\n        sort(arr,mid+\n1\n,high)\n        merge(arr,low,mid,high)\n    \nreturn\n arr\n\n\n\ndef\n \nmerge\n(\narr,low,mid,high\n):\n    temp1 = [\n0\n]*\nlen\n(arr)\n    \n    x = low\n    y = mid + \n1\n\n    i = \n0\n\n    \nwhile\n x<mid \nand\n y<high:\n        \nif\n arr[x] <= arr[y]:\n            \n'''print(x)'''\n\n            temp1[i] = arr[x]\n            i += \n1\n\n            x += \n1\n\n        \nelse\n:\n            \n''' print(y)'''\n\n            temp1[i] = arr[y]\n            i += \n1\n\n            y += \n1\n\n    \nwhile\n y<=high:\n        temp1[i] = arr[y]\n        i += \n1\n\n        y += \n1\n\n\n    \nwhile\n x<=mid:\n        temp1[i] = arr[x]\n        i += \n1\n\n        x += \n1\n\n    a = \n0\n\n    b = \n0\n\n    \nwhile\n a < \nlen\n(arr):\n        arr[a] = temp1[b]\n        a += \n1\n\n        b += \n1\n\n    \nreturn\n arr\n        \n\n\narr = [\n7\n,\n1\n,\n4\n,\n9\n,\n3\n,\n5\n,\n2\n,\n8\n]\nlow = \n0\n\nhigh = \nlen\n(arr)-\n1\n\nmid =\nint\n((low+high)/\n2\n)\n\n\nprint\n (sort(arr,low,high))\n\n\n\n\n运行结果及报错内容\n\n\n运行结果：[0, 0, 0, 0, 0, 0, 0, 0]\n\n\n我的解答思路和尝试过的方法\n\n\n\n\ndef\n \nmerge\n(\narr,low,mid,high\n):\n    temp1 = [\n0\n]*\nlen\n(arr)\n    \n    x = low\n    y = mid + \n1\n\n    i = \n0\n\n    \nwhile\n x<mid \nand\n y<high:\n        \nif\n arr[x] <= arr[y]:\n            \n'''print(x)'''\n\n            temp1[i] = arr[x]\n            i += \n1\n\n            x += \n1\n\n        \nelse\n:\n            \n''' print(y)'''\n\n            temp1[i] = arr[y]\n            i += \n1\n\n            y += \n1\n\n    \nwhile\n y<=high:\n        temp1[i] = arr[y]\n        i += \n1\n\n        y += \n1\n\n\n    \nwhile\n x<=mid:\n        temp1[i] = arr[x]\n        i += \n1\n\n        x += \n1\n\n    a = \n0\n\n    b = \n0\n\n    \nwhile\n a < \nlen\n(arr):\n        arr[a] = temp1[b]\n        a += \n1\n\n        b += \n1\n\n    \nreturn\n arr\n\narr = [\n1\n,\n4\n,\n7\n,\n9\n,\n2\n,\n3\n,\n5\n,\n8\n]\nlow = \n0\n\nhigh = \nlen\n(arr)-\n1\n\nmid =\nint\n((low+high)/\n2\n)\n\n\nprint\n (merge(arr,low,mid,high))\n\n\n\n运行结果及报错内容\n\n\n运行结果：[1, 2, 3, 4, 5, 8, 7, 9]", "Tag": "算法分析"}
{"Answer": "你的代码中merge函数的while循环里，这个判断Right数组的下标错了，应该是Right[j]\r\n```\r\n if (Left[i] < Right[i])\r\n        {\r\n            arr[k] = Left[i];\r\n            i++;\r\n            k++;\r\n        }\r\n```", "Konwledge_Point": "归并排序", "Question": "求问归并排序代码哪里有问题，请大家指教，谢谢！\n代码如下所示：\n\n测试后结果排序不正确，不知哪里写错了，请大家指教，谢谢\n\n\n\n#include \n#include \n#include \n\nvoid mergeSort(int arr[], int L, int R);\n\nint main( )\n{\n    int arr[6] = { 12,24,22,14,18,91 };\n    mergeSort(arr, 0, 5);\n    for (int i = 0;i < 6;i++)\n    {\n        printf_s(\"%d\\n\", arr[i]);\n    }\n}\n//L和R都是index，注意\nvoid merge(int arr[], int L, int M, int R)\n{\n    int Left_Size = M - L;\n    int Right_Size = R - M + 1;\n    //int Left[Left_Size];\n    int* Left = (int*)malloc(sizeof(int) * Left_Size);\n    if (Left == nullptr) { exit(-1); }\n    int* Right = (int*)malloc(sizeof(int) * Right_Size);\n    if (Right == nullptr) { exit(-1); }\n    //int i; \n    for (int i = L;i < M;i++)\n    {\n        Left[i - L] = arr[i];\n    }\n    for (int i = M;i <= R;i++)\n    {\n        Right[i-M] = arr[i];\n    }\n\n    int i = 0,j = 0,k = L;\n    while (i < Left_Size && j < Right_Size)\n    {\n        if (Left[i] < Right[i])\n        {\n            arr[k] = Left[i];\n            i++;\n            k++;\n        }\n        else\n        {\n            arr[k] = Right[j];\n            j++;\n            k++;\n        }\n    }\n    while (i < Left_Size)\n    {\n        arr[k] = Left[i];\n        i++;\n        k++;\n    }\n    while (j < Right_Size)\n    {\n        arr[k] = Right[j];\n        j++;\n        k++;\n    }\n\n}\n//L和R都是index，注意\nvoid mergeSort(int arr[], int L,int R)\n{\n    if (L == R)\n    {\n        return;\n    }\n    else\n    {\n    int M = (L + R) / 2;\n    mergeSort(arr, L, M);\n    mergeSort(arr, M + 1, R);\n    //这里第二个参数表示的是第二个数组第一个开头元素，所以我们要传入M+1\n    merge(arr, L, M+1, R);\n    }\n}\n\n", "Tag": "算法分析"}
{"Answer": "我测试了下，可以正常排序的，mergeSort(a, 0, a.length);你是这样调用的吗", "Konwledge_Point": "归并排序", "Question": "归并排序法数组中的最后一个数字总是不能进入排序是怎么回事\n代码如下\n\n\npublic\n \nvoid\n mergeSort(\nint\n f[], \nint\n l, \nint\n u) {\n        // the algorithm \nof\n merge sorting\n        \nif\n (l + \n1\n < u) {\n            \nint\n mid = (l + u) / \n2\n;\n            mergeSort(f, l, mid);\n            mergeSort(f, mid, u);\n            merge(f, l, mid, u);\n        }\n    }\n\npublic\n \nvoid\n merge(\nint\n arr[], \nint\n l, \nint\n m, \nint\n r) {\n        // the algorithm \nof\n merging\n        \nint\n[] \ntemp\n = \nnew\n \nint\n[r - l + \n1\n];\n        \nint\n i = \n0\n, j = \n0\n, k = \n0\n;\n        // \ndeclare\n variable \nfor\n counting\n\n        \nif\n (r - l == \n1\n) {\n            \nint\n min = Math.min(arr[l], arr[r]);\n            \nint\n max = Math.max(arr[l], arr[r]);\n            arr[l] = min;\n            arr[r] = max;\n        }\n        // the situation that there are \nonly\n two numbers\n\n        \nelse\n {\n            \nwhile\n (l + i < m && m + j < r) {\n                \nif\n (arr[l + i] < arr[m + j]) {\n                    \ntemp\n[k] = arr[l + i];\n                    k += \n1\n;\n                    i += \n1\n;\n                } \nelse\n {\n                    \ntemp\n[k] = arr[m + j];\n                    k += \n1\n;\n                    j += \n1\n;\n                }\n            }\n            \nwhile\n (l + i < m) {\n                \ntemp\n[k] = arr[l + i];\n                k += \n1\n;\n                i += \n1\n;\n            }\n            \nwhile\n (m + j < r) {\n                \ntemp\n[k] = arr[m + j];\n                k += \n1\n;\n                j += \n1\n;\n            }\n            \nfor\n (\nint\n n = \n0\n; n < \ntemp\n.length - \n1\n; n++) {\n                arr[l + n] = \ntemp\n[n];\n            }\n        }\n    }\n\n", "Tag": "算法分析"}
{"Answer": "每个记录是一个区间，可以理解成一个块，比较顺序如图中虚线隔开的部分。不知道这样你能不能理解题目代码中两城记录什么时候++\n", "Konwledge_Point": "归并排序", "Question": "归并排序问题，信息技术\n这个题目怎么想才能思路清晰啊😭感觉看了很久还是觉得有点乱，主要的思路是怎么样的？\n\n\n\n\n\n \n\n\n", "Tag": "算法分析"}
{"Answer": "import java.util.Arrays;\npublic class HelloWorld {\npublic void merge_sort(int q[], int l, int r){\n    if (l == r) {\n        return;\n    }\n    int mid = (l+r)>>1;\n    merge_sort(q, l, mid);\n    merge_sort(q, mid + 1, r);\n\n    int temp[] = new int[r-l+1];\n    int i = l, j = mid + 1, k = 0;\n\n    while (i <= mid && j <= r) {\n        if (q[i] < q[j]) {\n            temp[k++] = q[i++];\n        } else {\n            temp[k++] = q[j++];\n        }\n    }\n\n    while (i <= mid) {\n        temp[k++] = q[i++];\n    }\n\n    while (j <= r) {\n        temp[k++] = q[j++];\n    }\n\n    for (int p = 0; p < temp.length; p++) {\n        q[l+p] = temp[p];\n    }\n}\n\npublic static void main(String[] args) {\n    int []qwe = {3,2,1,1};\n    HelloWorld demo = new HelloWorld();\n    demo.merge_sort(qwe, 0, qwe.length-1);\n    System.out.println(Arrays.toString(qwe));\n}\n}\n\n\n在线测试通过（因为在线平台的限制，我把主类类名略微修改了。）", "Konwledge_Point": "归并排序", "Question": "Java归并排序结果不对应\n归并排序出现错误，\n\n\npublic class demo1 {\n    static \nint\n[] a=new \nint\n[\n11000\n];\n    public void merge_sort(\nint\n \nq[]\n, \nint\n l, \nint\n r){\n        \nif\n (l == r) \nreturn\n;\n//\n若数组中只有一个或没有数，就直接返回了\n        \nint\n mid = (l+r)>>\n1\n;\n        merge_sort(\nq\n, l, mid);\n        merge_sort(\nq\n,mid +\n1\n ,r);\n        \nint\n k = l, i = l, j = mid + \n1\n;\n        \nint\n temp[] = new \nint\n[q.length];\n        \nwhile\n (i<=mid && j<=r){\n            \nif\n (\nq[i]\n < \nq[j]\n) temp[k++] = \nq[i++]\n;\n            \nelse\n temp[k++] = \nq[j++]\n;\n        }\n        \nwhile\n (i <= mid) temp[k++] = \nq[i++]\n;\n        \nwhile\n (j <= r) temp[k++] = \nq[j++]\n;\n        \nfor\n (i = \n1\n, j = \n0\n; i <= r; i++, j++) \nq[i]\n = temp[j];\n    }\n\n    public static void main(String[] args) {\n        \nint\n []qwe = {\n3\n,\n2\n,\n1\n,\n1\n};\n        demo1 demo = new demo1();\n        demo.merge_sort(qwe,\n0\n, qwe.length-\n1\n);\n        System.out.println(Arrays.toString(qwe));\n    }\n\n}\n\n\n\n运行结果却是：\n\n\n求解惑", "Tag": "算法分析"}
{"Answer": "你的代码实现了归并排序的思想，但是有一个小错误。在while循环结束后，你应该把result的赋值语句放在循环外面，否则会导致每次只返回一个元素。我修改了一下，你可以参考一下。\nshu = [5, 3, 7, 2, 4, 6, 1, 8]\ndef test(shu):\n    if len(shu) <= 1:\n        return shu\n    mid = int(len(shu)/2)\n    llist, rlist = test(shu[:mid]), test(shu[mid:])\n    result = []\n    i = 0\n    j = 0\n    while i < len(llist) and j < len(rlist):\n        if rlist[j] < llist[i]:\n            result.append(rlist[j])\n            j = j + 1\n        else:\n            result.append(llist[i])\n            i = i + 1\n    # 把result的赋值语句放在循环外面\n    result = result + llist[i:] + rlist[j:]\n    return result\nprint(test(shu))\n\n", "Konwledge_Point": "归并排序", "Question": "关于归并排序问题，如何解决？\nshu \n= [\n5\n, \n3\n, \n7\n, \n2\n, \n4\n, \n6\n, \n1\n, \n8\n]\ndef test(\nshu):\n\n    if len(\nshu) \n<= \n1\n:\n        return \nshu\n\n    mid = int(len(\nshu)/2)\n\n    \nllist, \nrlist = test(\nshu[:mid]), \ntest(\nshu[mid:])\n\n    result = []\n    i = \n0\n\n    \nj \n= \n0\n\n    while i < len(\nllist) \nand \nj \n< len(rlist):\n        if rlist[\nj] \n< \nllist[i]:\n\n            result.append(rlist[\nj])\n\n            \nj \n= \nj \n+ \n1\n\n\n        else:\n\n            result.append(\nllist[i])\n\n            i = i + \n1\n\n        result = result + \nllist[i:] \n+ rlist[\nj:]\n\n        return result\nprint(test(\nshu))\n\n\n\n\n\n\n为什么结果错误\n​", "Tag": "算法分析"}
{"Answer": "#define _CRT_SECURE_NO_WARNINGS 1\n#include <stdio.h>\n#include <malloc.h>\n#include <windows.h>\n#include <memory.h>\n//归并排序：\n/*\narr:指定数组\nleft:判定左边界\nright:判断右边界\nmid:判断中点\n*/\nvoid Merge(int* arr, int left, int right, int mid)\n{\n    int *p = (int*)malloc((right - left + 1) * sizeof(int));\n    int *temp = p;\n    memset(p, 0, (right - left + 1) * sizeof(int));\n    int L = left;\n    int R = mid + 1;\n    while (L <= mid && R <= right)\n    {\n        *p++ = arr[L] < arr[R] ? arr[L++] : arr[R++];\n    }\n    while (L <= mid)\n    {\n        *p++ = arr[L++];\n    }\n    while (R <= right)\n    {\n        *p++ = arr[R++];\n    }\n \n    memcpy(arr + left, temp, (right - left + 1) * sizeof(int));\n \n    free(temp);\n    temp = NULL;\n}\n \nvoid MergeSort(int* arr, int left, int right)\n{\n    if (left == right)\n        return;\n    int mid = left + ((right - left)>>1);\n \n    MergeSort(arr, left, mid);            //左半边\n    MergeSort(arr, mid + 1, right);        //右半边\n    Merge(arr, left, right, mid);        //排序\n}\n \nint main()\n{\n    int arr[10] = { 9,8,3,5,2,1,6,4,7,10};\n    MergeSort(arr, 0, sizeof(arr)/ sizeof(arr[0]) - 1);\n \n    for (int i = 0; i < sizeof(arr) / sizeof(arr[0]); i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n \n    system(\"pause\");\n    return 0;\n}\n", "Konwledge_Point": "归并排序", "Question": "我想问问，这归并排序为什么排不了啊😭\n排序完的数组出现0，-1，和原来的数组不同，为什么会这样呢？", "Tag": "算法分析"}
{"Answer": "溢出问题单点调试下，你看看right>arr长度的情况，修改下第一个循环：\nvoid merge(int* arr, const int& left, const int& mid, const int& right)\n{\n    int i = left;\n    int j = mid + 1;\n    const int len = (right - left) + 1;\n    int* temp = new int[len];\n    int k = 0;\n   while (i <= mid && j <= right && k < len)\n    temp[k++] = arr[i] < arr[j] ? arr[i++] : arr[j++];\n    while (i <= mid)\n        temp[k++] = arr[i++];\n    while (j <= right)\n        temp[k++] = arr[j++];//缓冲区溢出？\n    for (int i = 0; i < len; ++i)\n        arr[left + i] = temp[i];//未初始化内存？\n    delete[]temp;\n}\n\n\n", "Konwledge_Point": "归并排序", "Question": "C++归并排序产生缓冲区溢出和未初始化内存的警告\n写了一个简单的归并排序，产生了警告C6386写入 \"temp\" 时缓冲区溢出和警告C6001使用未初始化的内存“*temp”。\n\n\nvoid merge(\nint\n* arr, const \nint\n& \nleft\n, const \nint\n& \nmid\n, const \nint\n& \nright\n)\n{\n    \nint\n i = \nleft\n;\n    \nint\n j = \nmid\n + \n1\n;\n    const \nint\n \nlen\n = (\nright\n - \nleft\n) + \n1\n;\n    \nint\n* temp = new \nint\n[\nlen\n];\n    \nint\n k = \n0\n;\n    while (i <= \nmid\n && j <= \nright\n)\n        temp[k++] = arr[i] < arr[j] ? arr[i++] \n:\n arr[j++];\n    while (i <= \nmid\n)\n        temp[k++] = arr[i++];\n    while (j <= \nright\n)\n        temp[k++] = arr[j++];//缓冲区溢出？\n    for (\nint\n i = \n0\n; i < \nlen\n; ++i)\n        arr[\nleft\n + i] = temp[i];//未初始化内存？\n    delete[]temp;\n}\n\nvoid mergeSort(\nint\n* arr, const \nint\n& \nleft\n, const \nint\n& \nright\n)\n{\n    \nif\n (\nleft\n == \nright\n)\n        return;\n    \nint\n \nmid\n = (\nleft\n + \nright\n) >> \n1\n;\n    mergeSort(arr, \nleft\n, \nmid\n);\n    mergeSort(arr, \nmid\n + \n1\n, \nright\n);\n    merge(arr, \nleft\n, \nmid\n, \nright\n);\n}\n\nvoid MergeSo\nrt:\n:so\nrt(\nint\n* arr, const \nint\n& \nlen\n)\n{\n    cout << \n\"归并排序\"\n << endl;\n    mergeSort(arr, \n0\n, \nlen\n - \n1\n);\n}\n\n\n\n\n\n找了半天没发现警告的原因，经过测试程序是能正常运行的。", "Tag": "算法分析"}
{"Answer": "归并排序的空间复杂度是O(n)，即需要一个额外的数组来进行合并操作。而快速排序的空间复杂度是O(logn)。所以要求内存量最大的排序方法应该是归并排序，答案为D。\n如果对您有帮助，请给与采纳，谢谢。", "Konwledge_Point": "归并排序", "Question": "下述几种排序方法中，要求内存量最大的\n要求内存量最大的，这个怎么是归并排序，归并排序是O(n),而快速排序是O(nlogn),", "Tag": "算法分析"}
{"Answer": "改了三处：\r\n1.多传入了一个参数int c[]作为目标数组\r\n2.guibing函数里k初始成start\r\n3.guibing函数最后的for循环改成了for(i=start; i<=end; i++)a[i] = c[i];\r\n```\r\n #include\r\nusing namespace std; \r\nvoid fenkai(int a[], int c[], int l, int r);\r\nvoid guibing(int a[], int c[], int start, int mid, int end);\r\nint main(){\r\n\tint a[20], c[20];\r\n\tfor (int i = 0; i < 20; i++){\r\n\t\ta[i] = rand() % 100;\r\n\t\tcout << a[i] << \" \";\r\n\t}\r\n\tcout << endl;\r\n\tfenkai(a, c, 0,19);\r\n\tfor (int i = 0; i < 20; i++)\r\n\t\tcout << c[i] << \" \";\r\n}\r\nvoid guibing(int a[], int c[], int start, int mid, int end){\r\n\tint i, j, k;\r\n\ti = start, j = mid + 1, k = start;\r\n\t//int *c=new int[end-start+1];\r\n\twhile (i <= mid&&j <= end){\r\n\t\tif (a[i] < a[j])\r\n\t\t\tc[k++] = a[i++];\r\n\t\telse\r\n\t\t\tc[k++] = a[j++];\r\n\t}\r\n\twhile (i<=mid)\r\n\t\t\tc[k++] = a[i++];\r\n\twhile (j<=end)\r\n\t\t\tc[k++] = a[j++];\r\n\t//for (int i = start, k = 0; i<(end-start+1); i++, k++)\r\n\tfor(i=start; i<=end; i++)\r\n\t\ta[i] = c[i];\r\n\t//delete[] c;\r\n}\r\nvoid fenkai(int a[],int c[], int l,int r){\r\n\tif (l < r){\r\n\t\tint m = (l + r) / 2;\r\n\t\tfenkai(a, c, l, m);\r\n\t\tfenkai(a, c, m+1, r);\r\n\t\tguibing(a, c, l, m, r);\r\n\t}\r\n}\r\n```\r\n![图片说明](https://img-ask.csdn.net/upload/201605/24/1464083785_511567.png)", "Konwledge_Point": "归并排序", "Question": "大神们帮我看看这个归并排序代码，谢了。\n#include\n\nusing namespace std; \n\nvoid fenkai(int a[], int l, int r);\n\nvoid guibing(int a[], int start, int mid, int end);\n\nint main(){\n\n    int a[20];\n\n    for (int i = 0; i < 20; i++){\n\n        a[i] = rand() % 100;\n\n        cout << a[i] << \" \";\n\n    }\n\n    cout << endl;\n\n    fenkai(a, 0,19);\n\n    for (int i = 0; i < 20; i++)\n\n        cout << a[i] << \" \";\n\n}\n\nvoid guibing(int a[], int start, int mid, int end){\n\n    int i, j, k;\n\n    i = start, j = mid + 1, k = 0;\n\n    int *c=new int[end-start+1];\n\n    while (i <= mid&&j <= end){\n\n        if (a[i] < a[j])\n\n            c[k++] = a[i++];\n\n        else\n\n            c[k++] = a[j++];\n\n    }\n\n    while (i<=mid)\n\n            c[k++] = a[i++];\n\n    while (j<=end)\n\n            c[k++] = a[j++];\n\n    for (int i = start, k = 0; i<(end-start+1); i++, k++)\n\n        a[i] = c[k];\n\n    delete[] c;\n\n}\n\nvoid fenkai(int a[],int l,int r){\n\n    if (l < r){\n\n        int m = (l + r) / 2;\n\n        fenkai(a, l, m);\n\n        fenkai(a, m+1, r);\n\n        guibing(a, l, m, r);\n\n    }\n\n}", "Tag": "算法分析"}
{"Answer": "\nC语言：归并排序 - plain8 - 博客园\n归并排序（C语言）。 先上代码，理论会后面一起总结。 1. 递归 2. 非递归\n\n\n\nhttps://www.cnblogs.com/plain8/p/8093052.html\n\n", "Konwledge_Point": "归并排序", "Question": "不知道这个归并排序错在哪了，没有用动态内存分配。\n\n#include\n#include\n\n\nvoid merge(\nint\n* arr,\nint\n \nleft\n,\nint\n \nright\n,\nint\n \nmid\n){\n    \nint\n Arr[\n20\n];\n    \nint\n M=\nright\n-\nleft\n;\n    \nint\n k=\n0\n;\n    \nint\n \nt\n=\nmid\n+\n1\n;\n    while(\nleft\n<=\nmid\n&&\nt\n<=\nright\n){\n        \nif\n(arr[\nleft\n]<arr[\nt\n]){\n            Arr[k++]=arr[\nleft\n++];\n        }else{\n            Arr[k++]=arr[\nt\n++];\n        }\n    }\n    while(\nleft\n<=\nmid\n)\n        Arr[k++]=arr[\nleft\n++];\n    while(\nt\n<=\nright\n)\n        Arr[k++]=arr[\nt\n++];\n    \n    \nint\n i;\n    for(i=\n0\n;i<=M;i++){\n        arr[i]=Arr[i];\n    }\n}\n\nvoid merge_sort(\nint\n* arr,\nint\n \nleft\n,\nint\n \nright\n){\n    \nif\n(\nright\n==\nleft\n)\n        return ;\n        \n    \nint\n \nmid\n=(\nright\n+\nleft\n)/\n2\n;\n    merge_sort(arr,\nleft\n,\nmid\n);\n    merge_sort(arr,\nmid\n+\n1\n,\nright\n);\n    \n    merge(arr,\nleft\n,\nright\n,\nmid\n);\n}\n\nvoid print(\nint\n* arr,\nint\n \nn\n){\n    \nint\n i;\n    for(i=\n0\n;i<\nn\n;i++)\n        printf(\n\"%d\"\n,arr[i]);\n}\n\n\nint\n main(){\n    \nint\n arr[\n5\n]={\n5\n,\n4\n,\n3\n,\n2\n,\n1\n};\n    merge_sort(arr,\n0\n,\n4\n);\n    print(arr,\n5\n);\n    \n    return \n0\n; \n}\n", "Tag": "算法分析"}
{"Answer": "越界后, and的短路特性使得第二个条件没被执行. 另外我觉得没必要写这么复杂的条件, 可以在最后把剩下的放进去, 代码比较对称, 逻辑比较清晰:\n\ndef merge(s1, s2, s):\n    i = j = 0\n    while i < len(s1) and j < len(s2):\n        if s1[i] < s2[j]:\n            s[i+j] = s1[i]\n            i += 1\n        elif s1[i] >= s2[j]:\n            s[i+j] = s2[j]\n            j += 1\n    while i < len(s1):\n        s[i+j] = s1[i]\n        i += 1\n    while j < len(s2):\n        s[i+j] = s2[j]\n        j += 1\n或者直接舍弃指标i和j, 用列表的pop移动.", "Konwledge_Point": "归并排序", "Question": "python实现二归并排序时，为什么只是交换了and两边条件的位置，一个能出结果，一个就报错？\n\n\ndef merge(s1,s2,s):\n    i = j = 0\n    while i+j in ()\n     22 \n     23 s = [24,17,40,28,13,14,22,32,40,21,48,4,47,8,37,18,88,56,79,35,0,66,156]\n---> 24 merge_sort(s)\n     25 print(s)\n\n in merge_sort(s)\n     16     s1 = s[0:mid]\n     17     s2 = s[mid:n]\n---> 18     merge_sort(s1)\n     19     merge_sort(s2)\n     20     merge(s1,s2,s)\n\n in merge_sort(s)\n     16     s1 = s[0:mid]\n     17     s2 = s[mid:n]\n---> 18     merge_sort(s1)\n     19     merge_sort(s2)\n     20     merge(s1,s2,s)\n\n in merge_sort(s)\n     18     merge_sort(s1)\n     19     merge_sort(s2)\n---> 20     merge(s1,s2,s)\n     21 \n     22 \n\n in merge(s1, s2, s)\n      2     i = j = 0\n      3     while i+j 4         if j==len(s2) or (s1[i]<s2[j] and i<len(s1)):\n      5             s[i+j] = s1[i]\n      6             i += 1\n\nIndexError: list index out of range\n", "Tag": "算法分析"}
{"Answer": "找了一个描述： \r\n例如，需要归并文件A、B，则按固定长度从文件A、B中分别读取一小段AS、BS，将AS、BS的归并结果记录在CS中，如果AS先比较完（反之类似），则将CS追加写入文件C并清空CS内存，并从文件A中读取下一段保存在AS中，再运行归并函数，直到文件A或B完全读取完，再把剩下的AS或BS写入文件C\r\n好好理解一下", "Konwledge_Point": "归并排序", "Question": "海量数据多路归并的问题，求指点～\n归并排序我知道：就是把两个有序序列归并为一个有序序列\n\n\n\n海量数据的多路归并的思想我也看了，就是有一点不明白，它是一小段一小段归并的，那他是怎么做到整体有序的呢？\n\n\n\n多路归并排序并不是把所有数据都读取到内存中，而是从每个文件中读取一小块数据，归并好就保存一小块，再读取下一小块\n\n\n\n比方说1～2000 和2001～4000归并，10个10个归并\n\n\n\n那结果就是：1，2，。。。，9，10，2001，2002，。。。，2009，2010\n\n\n\n11，12，。。。，19，20，2011，2012，.。。，2019，2020\n\n\n\n.。。。。。。。。。。。。。。\n\n\n\n后面也是一样\n\n\n\n那他怎么做到 整体的有序呢？", "Tag": "算法分析"}
{"Answer": "对于第一个问题，根据题目中描述的第一趟排序结果为{14，5，19，20，11，19}，可以确定采用的排序算法是简单选择排序，因为简单选择排序的每一趟排序都会选择当前未排序部分中的最小元素，并将其与未排序部分的第一个元素进行交换，使得前面部分有序，而第一趟排序的结果与题目中给出的结果一致。\n对于第二个问题，若从节省存储空间的角度考虑，则应该首选快速排序，因为它的空间复杂度为O(log n)，而堆排序和归并排序的空间复杂度分别为O(n)和O(n log n)。其次选取堆排序，因为它的空间复杂度与数据规模无关，而归并排序的空间复杂度与数据规模成正比。\n但是，如果同时从最坏情况和节省内存的角度考虑，那么归并排序可能是更好的选择，因为它的时间复杂度为O(n log n)，且空间复杂度为O(n)，而快速排序在最坏情况下的时间复杂度为O(n^2)，且空间复杂度为O(log n)。因此，如果要同时考虑最坏情况和节省内存，应该选取归并排序方法。", "Konwledge_Point": "归并排序", "Question": "对给出的一组关键若按关键字非递减排序\n对给出的一组关键字。若按关键字非递减排序问采用的排序算法是\nA）简单选择排序\n\n\n\n\n这个应首选快速排序吧，它的空间复杂度是nlogn，堆是n²\n．在堆排序、快速排序和归并排序中，若从节省存储空间考虑，则应首先选取（）方法，其次选取()方法；若\n从最坏并且节省内存，不应该是归并排序吗\n\n\n若只从最坏情况下排序最快并且要节省内存考虑，则应选取__方法。，", "Tag": "算法分析"}
{"Answer": "所谓稳定的排序方法不是说有时候能排序成功，有时候不会成功是说在排序之后，能够使得具有相同大小的键值的记录前后位置没有发生变化那你想，两个链表要合并成一个链表，两个链表里有相同的项x，一开始肯定是较短的链表里x比较靠前，较长的链表里x比较靠后，而合并的时候到底谁在前就看你外层循环和内层循环是哪个，跟x原来的位置无关，所以x的相对位置就可能发生变化", "Konwledge_Point": "归并排序", "Question": "数据结构排序B选项为啥不选\n选项B为啥不对？基数排序和归并排序不都应该是稳定的算法吗？求！！", "Tag": "算法分析"}
{"Answer": "各种算法的时间空间复杂度如下：\n原理参考链接：\n\n\n\n\n\n         https://blog.csdn.net/YUBANGSHUANGYUER/article/details/114377566\n        \n\n\n有帮助的话，请点采纳~\n", "Konwledge_Point": "归并排序", "Question": "下列四种排序中（  ）的空间复杂度最大。\n14、下列四种排序中（  ）的空间复杂度最大。\n(A) 插入排序    (B) 冒泡排序    (C) 堆排序      (D) 归并排序\n为啥答案选择D选项，不是堆的空间复杂度为O（n^2)吗", "Tag": "算法分析"}
{"Answer": "是否可以理解为对数组排序呢？分别用不同排序方法。", "Konwledge_Point": "归并排序", "Question": "java学生成绩排序\n【问题描述】\n 对本班所有学生的上学期的各科平均成绩进行从高到低排序，学生的平均成绩可按照上学期真实平均成绩设计，也可利用随机数自动生成，并对这些平均成绩进行多种方法进行排序。\n【基本要求】\n请用Java语言编写程序，满足以下要求：\n（1）至少采用四种方法实现上述问题求解（提示，可采用的方法有插入排序、希尔排序、起泡排序、快速排序、选择排序、堆排序、归并排序），并把排序后的结果写出到不同的文本文件中，文件名自行设计。\n（2）统计每一种排序方法的性能（以上机运行程序所花费的时间为准进行对比），并分析各个排序算法的优劣。\n【测试数据】\n（1）要求使用全部合法数据，整体非法数据，局部非法数据进行程序测试，以保证程序的稳定。\n（2）若平均成绩随机生成，生成的范围为：[60 - 100]。\n【实现提示】\n成绩的排序可利用学过的排序算法实现，对于结果的写出可利用java的缓冲输入输出字符流进行实现。\n__", "Tag": "算法分析"}
{"Answer": "试试我这个呢,从结果看还是快排快些\n你可以按照自己的需求修改测试程序。\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nint arr1[1000];\nint arr2[2000];\nint arr3[3000];\nint arr4[4000];\nint arr5[5000];\nint arr6[6000];\nint arr7[7000];\nint arr8[8000];\nint arr9[9000];\nint arr10[10000];\n\nint brr[10000];\n\nvoid init()\n{\n    srand((unsigned int)time(NULL));\n    \n    for(int i=0; i<1000; i++)\n    {\n        arr1[i] = rand()%100000;\n    }\n    for(int i=0; i<2000; i++)\n    {\n        arr1[i] = rand()%100000;\n    }\n    for(int i=0; i<1000; i++)\n    {\n        arr2[i] = rand()%100000;\n    }\n    for(int i=0; i<3000; i++)\n    {\n        arr3[i] = rand()%100000;\n    }\n    for(int i=0; i<1000; i++)\n    {\n        arr1[i] = rand()%100000;\n    }\n    for(int i=0; i<4000; i++)\n    {\n        arr4[i] = rand()%100000;\n    }\n    for(int i=0; i<5000; i++)\n    {\n        arr5[i] = rand()%100000;\n    }\n    for(int i=0; i<6000; i++)\n    {\n        arr6[i] = rand()%100000;\n    }\n    for(int i=0; i<7000; i++)\n    {\n        arr7[i] = rand()%100000;\n    }\n    for(int i=0; i<8000; i++)\n    {\n        arr8[i] = rand()%100000;\n    }\n    for(int i=0; i<9000; i++)\n    {\n        arr9[i] = rand()%100000;\n    }\n    for(int i=0; i<10000; i++)\n    {\n        arr10[i] = rand()%100000;\n    }\n}\n\nvoid quickSort(int *number, int first, int last) {\n    int i, j, pivot;\n    int temp;\n    if (first<last) {\n        pivot = first;\n        i = first;\n        j = last;\n        while (i<j) {\n            while (number[i] <= number[pivot] && i<last)\n                i++;\n            while (number[j]>number[pivot])\n                j--;\n            if (i<j) {\n                temp = number[i];\n                number[i] = number[j];\n                number[j] = temp;\n            }\n        }\n        temp = number[pivot];\n        number[pivot] = number[j];\n        number[j] = temp;\n        quickSort(number, first, j - 1);\n        quickSort(number, j + 1, last);\n    }\n}\n\nvoid Merge(int sourceArr[],int tempArr[], int startIndex, int midIndex, int endIndex)\n{\n    int i = startIndex, j=midIndex+1, k = startIndex;\n    while(i!=midIndex+1 && j!=endIndex+1)\n    {\n        if(sourceArr[i] > sourceArr[j])\n            tempArr[k++] = sourceArr[j++];\n        else\n            tempArr[k++] = sourceArr[i++];\n    }\n    while(i != midIndex+1)\n        tempArr[k++] = sourceArr[i++];\n    while(j != endIndex+1)\n        tempArr[k++] = sourceArr[j++];\n    for(i=startIndex; i<=endIndex; i++)\n        sourceArr[i] = tempArr[i];\n}\n \n//内部使用递归\nvoid MergeSort(int sourceArr[], int tempArr[], int startIndex, int endIndex)\n{\n    int midIndex;\n    if(startIndex < endIndex)\n    {\n        midIndex = startIndex + (endIndex-startIndex) / 2;//避免溢出int\n        MergeSort(sourceArr, tempArr, startIndex, midIndex);\n        MergeSort(sourceArr, tempArr, midIndex+1, endIndex);\n        Merge(sourceArr, tempArr, startIndex, midIndex, endIndex);\n    }\n}\nvoid testMerge()\n{\n    MergeSort(arr1, brr, 0, 1000);\n    MergeSort(arr2, brr, 0, 2000);\n    MergeSort(arr3, brr, 0, 3000);\n    MergeSort(arr4, brr, 0, 4000);\n    MergeSort(arr5, brr, 0, 5000);\n    MergeSort(arr6, brr, 0, 6000);\n    MergeSort(arr7, brr, 0, 7000);\n    MergeSort(arr8, brr, 0, 8000);\n    MergeSort(arr9, brr, 0, 9000);\n    MergeSort(arr10, brr, 0, 10000);\n}\nvoid testQsort()\n{\n    quickSort(arr1,0,1000);\n    quickSort(arr2,0,2000);\n    quickSort(arr3,0,3000);\n    quickSort(arr4,0,4000);\n    quickSort(arr5,0,5000);\n    quickSort(arr6,0,6000);\n    quickSort(arr7,0,7000);\n    quickSort(arr8,0,8000);\n    quickSort(arr9,0,9000);\n    quickSort(arr10,0,10000);\n}\n\nvoid print()\n{\n    printf(\"\\n\\narr1:\\n\");\n    for(int i=0;i<1000;i++)\n        printf(\"arr1[%d]:%d \",i,arr1[i]);\n\n    printf(\"\\n\\narr2:\\n\");\n    for(int i=0;i<2000;i++)\n        printf(\"arr2[%d]:%d \",i,arr2[i]);\n        \n    printf(\"\\n\\narr3:\\n\");\n    for(int i=0;i<3000;i++)\n        printf(\"arr3[%d]:%d \",i,arr3[i]);\n        \n    printf(\"\\n\\narr4:\\n\");    \n    for(int i=0;i<4000;i++)\n        printf(\"arr4[%d]:%d \",i,arr4[i]);\n        \n    printf(\"\\n\\narr5:\\n\");    \n    for(int i=0;i<5000;i++)\n        printf(\"arr5[%d]:%d \",i,arr5[i]);\n        \n    printf(\"\\n\\narr6:\\n\");    \n    for(int i=0;i<6000;i++)\n        printf(\"arr6%d]:%d \",i,arr6[i]);\n        \n    printf(\"\\n\\narr7:\\n\");    \n    for(int i=0;i<7000;i++)\n        printf(\"arr7[%d]:%d \",i,arr7[i]);\n        \n    printf(\"\\n\\narr8:\\n\");    \n    for(int i=0;i<8000;i++)\n        printf(\"arr8[%d]:%d \",i,arr8[i]);\n        \n    printf(\"\\n\\narr9:\\n\");    \n    for(int i=0;i<9000;i++)\n        printf(\"arr9[%d]:%d \",i,arr9[i]);\n        \n    printf(\"\\n\\narr10:\\n\");\n    for(int i=0;i<10000;i++)\n        printf(\"arr10[%d]:%d \",i,arr10[i]);\n    \n}\n\nint main(void) \n{ \n    init();\n    \n    /*归并排序时间记录*/\n    \n    clock_t begin, end;\n    double time_cost;\n    // 开始记录\n    begin = clock();\n    /*这里输入待测试程序段*/\n    testMerge();\n    // 结束记录\n    end = clock();\n    time_cost = (double)(end - begin) / CLOCKS_PER_SEC;\n    printf(\"testMerge cost : %lf s\\n\", CLOCKS_PER_SEC, time_cost);\n    \n    \n     init();\n\n    /*快速排序时间记录*/\n    \n    clock_t begin1, end1;\n    double time_cost1;\n    // 开始记录\n    begin1 = clock();\n    /*这里输入待测试程序段*/\n    testQsort();\n    // 结束记录\n    end1 = clock();\n    time_cost1 = (double)(end1 - begin1) / CLOCKS_PER_SEC;\n    printf(\"testQsort cost : %lf s\\n\", CLOCKS_PER_SEC, time_cost1);\n    \n    print();\n\n    return 0;\n}\n", "Konwledge_Point": "归并排序", "Question": "关于#排序算法#的问题，如何用c++解决？\n题目是：用大小分别为1000 2000 3000 4000 5000 6000 7000 8000 9000和10000的10个数组的排列来统计归并排序算法和快速排序算法的时间复杂性。\n我尝试使用随机数生成10个数组中的数据，但是每次排列结束都会时间超限。", "Tag": "算法分析"}
{"Answer": "1, A2, B", "Konwledge_Point": "归并排序", "Question": "关于#线性回归#的问题：如果只想得到1000个元素组成的序列中第5个最小元素之前的部分排序的序列\n如果只想得到1000个元素组成的序列中第5个最小元素之前的部分排序的序列，用（    ）方法最快。\nA．堆排序                                B．快速排序\nC．插入排序                                D．归并排序\n广义表满足Head(A)=Tail(A)，则A为（   ）。\nA．（）                                 B．（（））\nC．（（），（））                           D．（（），（），（））", "Tag": "算法分析"}
{"Answer": "\ndef merge_sort(alist):\n    if len(alist) == 1:\n        return alist\n    mid = len(alist) // 2\n    left = merge_sort(alist[:mid])\n    right = merge_sort(alist[mid:])\n    result = []\n    while len(left) > 0 and len(right) > 0:\n        if left[0] <= right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result += left\n    result += right\n    return result\n\n\nprint(merge_sort([11, 99, 33, 69, 77, 88, 55, 11, 33, 36, 39, 66, 44, 22]))\n", "Konwledge_Point": "归并排序", "Question": "请问这个程序的代码该怎么写\n编写函数merge_sort(alist)使用“归并排序算法”对参数列表alist的各元素进行升序排序，排序后，\nalist的各元素按升序有序。", "Tag": "算法分析"}
{"Answer": "  可以创建中、英文标点码表字典，轮询字符输入文本字符串中、英标点替换就好。\n#!/usr/bin/nve python\n# coding: utf-8\n\nen_punc =',;.:!? '\nch_punc ='，；。：！？ '\nen_punc_dict = dict(zip(en_punc, ch_punc))\nch_punc_dict = dict(zip(ch_punc, en_punc))\n\n\ntext = '''\n排序算法一:冒泡排序。 排序算法二:快速排序。 排序算法三:堆排序。 排序算法四:归并排序 排序算法五:插入排序 排序算法六:基数排序 排序算法七:选择排序 排序算法八:堆排序。 排序算法九:希尔排序 排序算法十:快速排序(FIFO)。 排序算法十一:树结构排序……\n'''\n# 输入中文：，代码默认=:(英文)，反之一样\n\ntext2 = []\n\nfor i in text:\n\n    if i in en_punc:\n        i = en_punc_dict.get(i)\n    elif i in ch_punc:\n        i = ch_punc_dict.get(i)\n\n    text2.append(i)\n\ntext2 = ''.join(text2)\nprint(f\"\\n\\n输入文本：\\n{text}\\n\\n代码处理后：\\n{text2}\\n\")\n\n\n\n如果输入文本只有中、英文一种标点，只须轮询相反标点列表，用str.replace()、re.sub()任一个方法替换输入文本的标点为另一类标点。这样子，比轮询输入文本高效，特别是输入文本“很大“。", "Konwledge_Point": "归并排序", "Question": "全角半角切换，input输入中文：标点，代码默认=:(英文)，反之一样？\n# 输入，标点符号默认中英文相互切换\n\n\n\n# 编号①②③   ord( '①' ): 9312\n\nz=\ninput\n(\n''''''\n)\nb= \ninput\n(\n'''请输入切片位置：'''\n)\nd= \ninput\n(\n'''请输入回车位置：'''\n)\nz_list = z.strip().split(d)\n\nfor\n index,value \nin\n \nenumerate\n(z_list):\n    \nprint\n(\n'{}.{}'\n.\nformat\n(  \nchr\n( \n9312\n+index ) , value.split(b)[\n1\n] ))\n\n\n\n'''\n排序算法一:冒泡排序 排序算法二:快速排序 排序算法三:堆排序 排序算法四:归并排序 排序算法五:插入排序 排序算法六:基数排序 排序算法七:选择排序 排序算法八:堆排序 排序算法九:希尔排序 排序算法十:快速排序(FIFO) 排序算法十一:树结构排序\n'''\n\n\n\n# 输入中文：，代码默认=:(英文)，反之一样\n\n", "Tag": "算法分析"}
{"Answer": "如果有帮到你，请采纳一下~\n\nimport time\nimport tkinter as tk\nfrom tkinter import messagebox\n\n\nclass SortingAlgorithms:\n    def __init__(self):\n        pass\n\n    def bubble_sort(self, arr):\n        start_time = time.time()\n        n = len(arr)\n        for i in range(n):\n            for j in range(0, n-i-1):\n                if arr[j] > arr[j+1]:\n                    arr[j], arr[j+1] = arr[j+1], arr[j]\n        end_time = time.time()\n        time_complexity = end_time - start_time\n        space_complexity = 1\n        return arr, time_complexity, space_complexity\n\n    def selection_sort(self, arr):\n        start_time = time.time()\n        n = len(arr)\n        for i in range(n):\n            min_idx = i\n            for j in range(i+1, n):\n                if arr[min_idx] > arr[j]:\n                    min_idx = j\n            arr[i], arr[min_idx] = arr[min_idx], arr[i]\n        end_time = time.time()\n        time_complexity = end_time - start_time\n        space_complexity = 1\n        return arr, time_complexity, space_complexity\n\n    def quick_sort(self, arr):\n        start_time = time.time()\n\n        def partition(arr, low, high):\n            i = low - 1\n            pivot = arr[high]\n            for j in range(low, high):\n                if arr[j] <= pivot:\n                    i = i + 1\n                    arr[i], arr[j] = arr[j], arr[i]\n            arr[i+1], arr[high] = arr[high], arr[i+1]\n            return i+1\n\n        def quick_sort_helper(arr, low, high):\n            if low < high:\n                pi = partition(arr, low, high)\n                quick_sort_helper(arr, low, pi-1)\n                quick_sort_helper(arr, pi+1, high)\n\n        quick_sort_helper(arr, 0, len(arr)-1)\n        end_time = time.time()\n        time_complexity = end_time - start_time\n        space_complexity = len(arr)\n        return arr, time_complexity, space_complexity\n\n    def merge_sort(self, arr):\n        start_time = time.time()\n\n        def merge(arr, l, m, r):\n            n1 = m - l + 1\n            n2 = r - m\n            L = [0] * n1\n            R = [0] * n2\n            for i in range(n1):\n                L[i] = arr[l + i]\n            for j in range(n2):\n                R[j] = arr[m + 1 + j]\n            i = 0\n            j = 0\n            k = l\n            while i < n1 and j < n2:\n                if L[i] <= R[j]:\n                    arr[k] = L[i]\n                    i += 1\n                else:\n                    arr[k] = R[j]\n                    j += 1\n                k += 1\n            while i < n1:\n                arr[k] = L[i]\n                i += 1\n                k += 1\n            while j < n2:\n                arr[k] = R[j]\n                j += 1\n                k += 1\n\n        def merge_sort_helper(arr, l, r):\n            if l < r:\n                m = (l+(r-1)) // 2\n                merge_sort_helper(arr, l, m)\n                merge_sort_helper(arr, m+1, r)\n\n", "Konwledge_Point": "归并排序", "Question": "Python数据结构\n使用python编程语言实现Tkinter界面\n\n\n该界面要有以下功能\n(1)从键盘上输入n个长度为m的整数，程序可以输出这些整数的四种排序方式：快速排序，直接选择排序，冒泡排序，归并排序，并在界面显示每种排序的升序和降序以及排序的时间复杂度和空间复杂度；\n(2)程序能对所输入的数字进行判断，如果不是所要求的长度，弹出提醒消息框；\n(3)输出结果以逗号隔开。\n(4)只能使用数据结构的知识实现，不能使用数据库", "Tag": "算法分析"}
{"Answer": "望采纳", "Konwledge_Point": "归并排序", "Question": "CSDN反馈中心在哪里？\nCSDN反馈中心在哪里？\n我在私信中发了一张图片，是一幅讲解归并排序的动图为什么它说内容含有敏感信息，还把它删了，我想到CSDN反馈中心反馈。\n用的是电脑", "Tag": "算法分析"}
{"Answer": "运算符优先级的问题，优先级比较如下：\n除运算符 > 加运算符 > 位移运算符", "Konwledge_Point": "归并排序", "Question": "求中点的问题：为什么会栈溢出\n归并排序求中点时，为什么我写右移就会报栈溢出，而除以2就可以呢？", "Tag": "算法分析"}
{"Answer": "scanf_s需要指定每个输入字符串长度\r\n```\r\n scanf_s(\"%s %s\", inf[i].sName,8 ,inf[i].sTele,11);\r\n```", "Konwledge_Point": "归并排序", "Question": "VS2013使用scanf_s过界\n无法运行，代码如\n\n\n\n// info.cpp : Defines the entry point for the console application.\n//\n\n#include \"stdafx.h\"\n#include \n#include \n//infomation\n//technology\n//IT\n//冒泡 选择 插入排序\n//快速排序 归并排序\nstruct SInfo\n{\n    char sName[20];\n    char sTele[20];\n};\n\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    SInfo inf[5];\n#define COUNT sizeof(inf)/sizeof(inf[0])\n    int i = 0;\n    while (i < COUNT)\n    {\n        printf(\"请输入第%d个学生姓名和电话：【以空格间隔】\", i + 1);\n        fflush(stdin);\n        scanf_s(\"%s %s\", inf[i].sName, inf[i].sTele);       //调试到这错误\n        ++i;\n    }\n    //ccc aaa ddd bbb eee\n    i = 0;\n    unsigned int j = 0;\n    while (i < COUNT - i)\n    {\n        j = 0;\n        while (j < COUNT - i)\n        {\n            if (strcmp(inf[j].sName, inf[j + 1].sName) > 0)\n            {\n                SInfo t = inf[j];\n                inf[j] = inf[j + 1];\n                inf[j + 1] = t;\n            }\n            ++j;\n        }\n        ++i;\n    }\n    i = 0;\n    while (i < COUNT)\n    {\n        printf(\"%s\\t%s\\n\", inf[i].sName, inf[i].sTele);\n        ++i;\n    }\n    return 0;\n}\n\n\n\n\n\n调试之后出现\n\nUnhandled exception at 0xFEFEFEFE in info.exe: 0xC0000005: Access violation executing location 0xFEFEFEFE.\n\n麻烦大神讲解下，谢谢", "Tag": "算法分析"}
{"Answer": "```\r\n 因为是递归\r\n if (hi<=lo) return;\r\n    int mid=lo+(hi-lo)/2;\r\n    sort(a,lo,mid);\r\n    sort(a,mid+1,hi);\r\n你跳出的是sort(a,lo,mid);这一步函数调用，这个函数调用return返回后就是执行sort(a,mid+1,hi);\r\n```", "Konwledge_Point": "归并排序", "Question": "java递归 if（） return返回到哪里？\n学习归并排序时，遇到递归的思想。\n\n测试输入 mergesortexample\n\n单步调试到，if (hi<=lo) return;当hi=0，lo=0时，执行return，在我理解中，return就是退出方法了，为何会跳到 sort(a,mid+1,hi);而且此时，lo=0，hi=1？\n\n\n\nprivate static void sort(Comparable[] a,int lo,int hi){\n\n        //将数组a【lo hi】排序\n\n        if (hi<=lo) return;\n\n        int mid=lo+(hi-lo)/2;\n\n        sort(a,lo,mid);\n\n        sort(a,mid+1,hi);\n\n        merge(a,lo,mid,hi);\n\n    }\n\n\n\nimport java.util.Scanner;\n\n\n\npublic class Merge {\n\n    private static Comparable[] aux;\n\n\n\npublic static void sort(Comparable[] a){\n\n    aux=new Comparable[a.length];\n    sort(a,0,a.length-1);\n}\n\nprivate static boolean less(Comparable v,Comparable w){\n    return v.compareTo(w)<0;\n}\n\npublic static void merge(Comparable[] a,int lo,int mid,int hi){\n    //将a【lo mid】与a【mid+1，hi】归并\n    int i=lo;\n    int j=mid+1;\n\n    for(int k=lo;k<=hi;k++){\n        aux[k]=a[k];\n    }\n\n    for(int k=lo;k<=hi;k++){\n        if(i>mid)                          a[k]=aux[j++];\n        else if(j>hi)                      a[k]=aux[i++];\n             else if(less(aux[j],aux[i]))  a[k]=aux[j++];\n                  else                     a[k]=aux[i++];\n    }\n}\n\nprivate static void sort(Comparable[] a,int lo,int hi){\n    //将数组a【lo hi】排序\n    if (hi<=lo) return;\n    int mid=lo+(hi-lo)/2;\n    sort(a,lo,mid);\n    sort(a,mid+1,hi);\n    merge(a,lo,mid,hi);\n}\nprivate static void show(Comparable[] a){\n    //在单行中打印数组\n    for(int i=0; i<a.length;i++)\n        System.out.print(a[i]+\"\");\n    System.out.println();\n\n}\npublic static boolean isSorted(Comparable[] a){\n    //测试数组是否有序\n    for(int i=1;i<a.length;i++)\n        if(less(a[i],a[i-1])) return false;\n    return true;\n}\npublic static void main(String[] args){\n    //从标准输入读取字符串，将它们排序并输出\n     System.out.print(\"输入\");\n     Scanner s = new Scanner(System.in);\n     String line=s.nextLine();\n     System.out.println(\"输入的是\"+line);                \n\n    char [] charArr =line.toCharArray();    \n    String[] strArr = new String[charArr.length];\n\n    for(int i = 0; i < strArr.length; i++) {\n        strArr[i] = String.valueOf(charArr[i]);\n    }\n\n    sort(strArr);\n    assert isSorted(strArr);\n    show(strArr);\n}\n\n\n\n\n}", "Tag": "算法分析"}
{"Answer": "题目呢？另外快排时间复杂度也是O(nlogn)啊", "Konwledge_Point": "归并排序", "Question": "OJ时间超限问题，代码能改进什么地方\n问题遇到的现象和发生背景\n\n\n题目是输出数组第k大元素，要求多组输入，第一行是k,第二行是数组，要求时间复杂度为O(n)，用数据分区+递归查找加随机选取基准就可以,我明明用的是归并排序但oj老是时间超限。\n\n\n问题相关代码，请勿粘贴截图\n\n\n#include\n#include\nint main(){\n    int n;\n    int a[10000];\n    char c;\n    int k;\n    while(scanf(\"%d\",&k)!=EOF){\n    while(scanf(\"%d\",&a[0])!=EOF){\n        int n=0;\n        while(scanf(\"%d\",&a[++n])){\n            if(c=getchar()=='\\n')\n            break;\n        }\n       int result=quickselect(a,0,n,k);\n       printf(\"%d\\n\",result);\n    }\n   }\n    return 0;\n}\nvoid swap(int a[],int i,int j){\n    int t=a[i];\n    a[i]=a[j];\n    a[j]=t;\n}\nint random(int p,int q){\n    return rand()%(q-p+1)+p;\n}\nint rpart(int a[],int p,int q){\n    int r=random(p,q);\n    swap(a,p,r);\n    int i=part(a,p,q);\n    return i;\n}\n\n\nint part(int a[],int p,int q){\n    int x=a[p];\n    int i=p,j;\n    for(j=p+1;j<=q;j++){\n        if(a[j]>=x){\n            i++;\n            swap(a,i,j);\n        }\n    }\n    swap(a,p,i);\n    return i;\n}\nint quickselect(int a[],int p,int q,int k){\n    if(p==q){\n        return a[p];\n      }\n      else{\n        int i=rpart(a,p,q);\n        int j=i-p+1;\n        if(k<=j){\n        return quickselect(a,p,i,k);\n      }\n      else{\n          return quickselect(a,i+1,q,k-j);\n      }\n}\n\n\n}\n\n\n运行结果及报错内容\n\n\n我的解答思路和尝试过的方法\n\n\n想问问我这个代码需要改进什么地方\n\n\n我想要达到的结果", "Tag": "算法分析"}
{"Answer": "你的main函数中的k没有给他new一个数组，所以你cin的时候程序就崩了", "Konwledge_Point": "归并排序", "Question": "尝试数据结构中的mergesearch失败\n最近在学数据结构和算法，想简单模拟一下向量的归并排序\n\n\n\n#include\nusing namespace std;\nclass vector\n{\n    int* num;\n    public:\n        vector(int *k)\n        {\n            num=k;\n        }\n        void mergesort(int,int);\n        void merge(int,int,int);\n        void display()\n        {\n            for(int i=0;i<10;i++)\n            cout<>k[i];\n    cout<<\"一开始\"<<endl;\n    for(int i=0;i<10;i++)\n        cout<<\" \"<<k[i];\n    cout<<endl;\n    vector v(k);\n    v.mergesort(0,10);\n    v.display();\n}\n\n\n\n\n\n\n\n出现了一些错误", "Tag": "算法分析"}
{"Answer": "你在 heti （另外函数名尽量取英文名阿，merge 挺好）函数里打印下 left 的值就知道了，加一个 print", "Konwledge_Point": "归并排序", "Question": "一个让我非常疑惑的问题，恳请各路大佬抽空帮忙指点一下到底是哪里有问题！\n小弟先上正确代码\n\n\n\n\n\n#include \n\n//合体函数 \nvoid heti(int *arr, int *temp, int left, int right, int mid)\n{\n    int i = left;\n    int j = mid + 1;\n    int t = 0;\n    while(i <= mid && j <= right)\n    {\n        if(arr[i] >= arr[j])\n        {\n            temp[t++] = arr[j++];\n        }\n        else\n        {\n            temp[t++] = arr[i++];\n        }\n    }\n    while(i <= mid)\n    {\n        temp[t++] = arr[i++];\n    }\n    while(j <= right)\n    {\n        temp[t++] = arr[j++];\n    }\n    for (i = 0; i < t; i++)\n    {\n        arr[left + i] = temp[i];\n    }\n}\n\n//分开函数 \nvoid fenkai(int *arr, int *temp, int left, int right)\n{\n    if(left < right)\n    {\n        int mid = (left + right) / 2;\n        //向左进行递归分解\n        fenkai(arr, temp, left, mid);\n        fenkai(arr, temp, mid + 1, right); \n        //调用合体函数 \n        heti(arr, temp, left, right, mid);\n    }\n}\n\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    int arr[n], temp[n];\n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%d\", &arr[i]);\n    }\n    fenkai(arr, temp, 0, n - 1);\n    for(int i = 0; i < n; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n} \n\n\n\n问题描述：该问题是一个数组归并排序的代码，在合体函数的最后要把temp数组的元素全部复制到arr数组，为什么一定要\narr[left + i] = temp[i]\n，而不能直接用\narr[i] = temp[i]\n，我寻思我给left赋值就是赋的0啊，而且left的数据也没有变化，为什么两种方法却得到不一样的结果，下面附上两种方案的运行图片（第一个是对的，第二个是错的），跪求大佬告知！！！\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "http://www.codeproject.com/Articles/418776/How-to-replace-recursive-functions-using-stack-and", "Konwledge_Point": "归并排序", "Question": "排序的递归问题：能否用函数指针以及栈代替递归？？\n最近学习排序，对于快排，归并等处理海量数据效率高的算法很钟意，但是其自身的递归特性有很多缺点，譬如数据量过大时存在溢出的风险，也影响了算法的效率，故想到用栈代替递归这一过程。大致想法就是创建个函数指针类型的栈，然后将每个子排序的函数指针压入其中，然后再一个一个用*解引用来运行函数。当然我知道改成非递归有别的方法，但是可能会比这复杂，就想考虑用栈来实现。我想知道的是，对于快排和归并等递归排序算法，用以上方法实现的话，算法的开销（时间复杂度和空间复杂度），以及实际效率会是如何，有实际意义么。问题描述不全，毕竟第一次在CSDN提问，望前辈们多看看。本人大二，学了c++ java。", "Tag": "算法分析"}
{"Answer": "如果假定一个有序一个无序，是不是就相当于求逆序对个数O(nlogn)实现这个假定的时间复杂度是O(n)", "Konwledge_Point": "归并排序", "Question": "排序算法题（有关逆序对）\n首先，题目如下\n\n\n我的想法是利用归并，分别将两个数组逆序对存到两个哈希集合中，然后再遍历其中一个求出相同逆序对个数，得到答案。但最终超时。求问是否有更好的思路，或者提供相关资料，感谢！", "Tag": "算法分析"}
{"Answer": "题目里给出的条件是：L1和L2是给定的带头结点的单链表，List Merge( List L1, List L2 ); 函数里的操作要注意，修改如下，供参考：\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\ntypedef int ElementType;\ntypedef struct Node* PtrToNode;\nstruct Node {\n    ElementType Data;\n    PtrToNode   Next;\n};\ntypedef PtrToNode List;\nList Read(); /* 细节在此不表 */\nvoid Print(List L); /* 细节在此不表；空链表将输出NULL */\nList Merge(List L1, List L2);\nint main()\n{\n    List L1 = nullptr, L2 = nullptr, L;\n    srand((unsigned int)time(NULL));\n    L1 = Read();\n    L2 = Read();\n    L = Merge(L1, L2);\n    Print(L);\n    Print(L1);\n    Print(L2);\n    return 0;\n}\n\n\nList Read()\n{\n    List p, q, tmp;\n    int i, n;\n    p = q = (List)malloc(sizeof(struct Node));\n    p->Next = NULL;\n    printf(\"请输入链表的长度:\");\n    scanf(\"%d\", &n);\n    for (i = 0; i < n; i++)\n    {\n        tmp = (List)malloc(sizeof(struct Node));\n        tmp->Next = NULL;\n        tmp->Data = rand() % 100 + 1;\n        \n        p->Next = tmp;\n        p = tmp;\n    }\n    return q;\n}\n\nvoid Print(List L)\n{\n    List p = L->Next;\n    while (p)\n    {\n        printf(\"%d \", p->Data);\n        p = p->Next;\n    }\n    printf(\"\\n\");\n}\n\nint cmpfunc(const void* a, const void* b)\n{\n    return (*(int*)a - *(int*)b);\n}\n\nList Merge(List L1, List L2)\n{\n    List p, q, s, L;\n                         //L = (List)malloc(sizeof(List));\n    int i = 0, num = 0;\n    int a[10000] = {0};\n                         //临时变量yyds\n    p = L1->Next, q = L2->Next;\n                        //s = L;\n    while (p != NULL)   //while (p->Next != NULL)\n    {\n        a[i++] = p->Data;\n        p = p->Next;\n        num++;\n    }\n                         //p->Next = q;\n    while (q != NULL)  //while (q->Next != NULL)\n    {\n        a[i++] = q->Data;\n        q = q->Next;\n        num++;\n    }\n    qsort(a, num, sizeof(int), cmpfunc);\n\n    s = L = (List)malloc(sizeof(struct Node));\n    L->Next = NULL;\n    for (i = 0; i < num; i++)\n    {    \n        L->Next=(List)malloc(sizeof(struct Node));//L->Next=(List)malloc(sizeof(List));\n        L->Next->Data = a[i];\n        L->Next->Next = NULL;\n        L = L->Next;\n    }\n    //L1->Next = NULL;\n    //L2->Next = NULL;\n    return s;\n}\n\n", "Konwledge_Point": "归并排序", "Question": "关于新链表创建的具体问题\n原题是PTA02-线性结构1 两个有序链表序列的合并\n本题要求实现一个函数，将两个链表表示的递增整数序列合并为一个非递减的整数序列。\n函数接口定义：\nList Merge( List L1, List L2 );\n其中List结构定义如下：\n\n\ntypedef struct Node \nPtrToNode;\nstruct Node {\n    ElementType Data; /\n 存储结点数据 \n/\n    PtrToNode   Next; /\n 指向下一个结点的指针 \n/\n};\ntypedef PtrToNode List; /\n 定义单链表类型 */\nL1和L2是给定的带头结点的单链表，其结点存储的数据是递增有序的；函数Merge要将L1和L2合并为一个非递减的整数序列。应直接使用原序列中的结点，返回归并后的带头结点的链表头指针。\n\n\n裁判测试程序样例：\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n\ntypedef\n \nint\n ElementType;\n\ntypedef\n \nstruct\n \nNode\n *PtrToNode;\n\nstruct\n \nNode\n {\n    ElementType Data;\n    PtrToNode   Next;\n};\n\ntypedef\n PtrToNode List;\n\n\nList \nRead\n()\n; \n/* 细节在此不表 */\n\n\nvoid\n \nPrint\n( List L )\n; \n/* 细节在此不表；空链表将输出NULL */\n\n\n\nList \nMerge\n( List L1, List L2 )\n;\n\n\nint\n \nmain\n()\n\n\n{\n    List L1, L2, L;\n    L1 = \nRead\n();\n    L2 = \nRead\n();\n    L = \nMerge\n(L1, L2);\n    \nPrint\n(L);\n    \nPrint\n(L1);\n    \nPrint\n(L2);\n    \nreturn\n \n0\n;\n}\n\n\n\n我写的函数部分如下:\n\n\nint\n cmpfunc (\nconst\n \nvoid\n * a, \nconst\n \nvoid\n * b)\n{\n   \nreturn\n ( *(\nint\n*)a - *(\nint\n*)b );\n}\n\n\n\nList\n Merge( \nList\n L1, \nList\n L2 )\n{\n    \nList\n p,q,s,L;\n    \n    L=(\nList\n)malloc(sizeof(\nList\n));\n    \nint\n i=\n0\n,num=\n1\n;\n    \nint\n a[\n10000\n];\n    \n    \n//临时变量yyds\n\n    p=L1,q=L2;\n    s=L;\n    \n    \nwhile\n(p->Next!=\nNULL\n)\n    {\n        a[i++]=p->Data;\n        p=p->Next;\n        num++;\n    }\n    \n    p->Next=q;\n    \n    \nwhile\n(q->Next!=\nNULL\n)\n    {\n        a[i++]=q->Data;\n        q=q->Next;\n        num++;\n    }\n    \n    qsort(a,num,sizeof(\nint\n),cmpfunc);\n    \n    \nfor\n(i=\n0\n;iData=a[i];\n\n//      L->Next=(List)malloc(sizeof(List));\n\n        L=L->Next;\n    }\n    \n    L1->Next=\nNULL\n;\n    L2->Next=\nNULL\n;\n    \n    \nreturn\n s;\n}\n\n\n\n\n核心逻辑是将两个短的链表连起来,然后用一个数组放入所有的数据,再用c语言自带的qsort函数排序,但除了两个空链表的情况,永远都是段错误,我想过是否是我每增加一个新节点是否需要再次申请空间,在句中加入了 L->Next=(List)malloc(sizeof(List)); 但这样会全错,从新链表实际是否占有空间角度出发好像不对,思考了很久还是没想到问题出现在哪里\n\n\n此问题最快的O(n)算法我已经学习过了,但仍想找到自己的问题,所以来咨询大家!超级感谢!", "Tag": "算法分析"}
{"Answer": "\n#include <stdio.h>\n#include <stdlib.h>\n/************************************/\n/* 链表实现的头文件，文件名slnklist.h */\n/************************************/\ntypedef int datatype;\ntypedef struct link_node {\n    datatype info;\n    struct link_node *next;\n}node;\n\n\n/*****************************************************/\n/*  函数功能：建立一个空的带头结点的单链表           */\n/*  函数参数：空                                     */\n/*  函数返回值：指向node类型变量的指针             */\n/*  文件名：hlnklist.c，函数名：init()                    */\n/**************************************************** */\nnode *init()\n{\n    node *head;\n    head = (node*)malloc(sizeof(node));\n    head->next = NULL;\n    return head;\n}\n\n\n/*****************************************************/\n/*  函数功能：输出带头结点的单链表中各个结点的值     */\n/*  函数参数：指向node类型变量的指针head            */\n/* 函数返回值：无                          */\n/*  文件名：hlnklist.c，函数名：display()               */\n  /*****************************************************/\nvoid display(node *head)\n{\n    node *p;\n    p = head->next;/*从第一个（实际）结点开始*/\n    if (!p) printf(\"\\n带头结点的单链表是空的!\");\n    else\n    {\n        printf(\"\\n带头结点的单链表各个结点的值为：\\n\");\n        while (p) { printf(\"%5d\", p->info); p = p->next; }\n    }\n}\n\n\n/*****************************************************/\n/*  函数功能：在带头结点的单链表中查找第i个结点地址 */\n/*  函数参数：指向node类型变量的指针head           */\n/*             int类型变量i                          */\n/*  函数返回值：指向node类型变量的指针head          */\n/*  文件名hlnklist.c，函数名find()                     */\n/*****************************************************/\nnode *find(node *head, int i)\n{\n    int j = 0;\n    node *p = head;\n    if (i < 0) { printf(\"\\n带头结点的单链表中不存在第%d个结点！\", i); return NULL; }\n    else if (i == 0) return p;/*此时p指向的是头结点*/\n    while (p&&i != j)/*没有查找完并且还没有找到*/\n    {\n        p = p->next; j++;/*继续向后（左）查找，计数器加1*/\n    }\n    return p;/*返回结果，i=0时，p指示的是头结点*/\n}\n\n\n/***********************************************************************/\n/*  函数功能：在带头结点的单链表中第i个结点后插入一个值为x的新结点 */\n/*  函数参数：指向node类型变量的指针head                              */\n/*            datatype 类型变量x，int型变量i                            */\n /*  函数返回值：指向node类型变量的指针head                           */\n /* 文件名：hlnklist.c，函数名：insert()                     */\n /***********************************************************************/\nnode *insert(node *head, datatype x, int i)\n{\n    node *p, *q;\n    q = find(head, i);/*查找带头结点的单链表中的第i个结点*/\n                            /*i=0，表示新结点插入在头结点之后，此时q指向的是头结点*/\n    if (!q)/*没有找到*/\n    {\n        printf(\"\\n带头结点的单链表中不存在第%d个结点！不能插入%d！\", i, x); return head;\n    }\n    p = (node*)malloc(sizeof(node));/*为准备插入的新结点分配空间*/\n    p->info = x;/*为新结点设置值x*/\n    p->next = q->next;/*插入(1)*/\n    q->next = p;/*插入(2)，当i=0时，由于q指向的是头结点，本语句等价于head>next=p */\n    return head;\n}\n\n\nnode *mergelist(node *head1, node *head2)  /*本函数的作用是将两个有序表按结点值的大小合并成一个有序表，将本函数补充完整*/\n{\n    node *p, *q, *s;\n    p = head1->next;\n    q = head2->next;\n    node *head3;\n    head3 = head1;\n    head3->next = NULL;\n    free(head2);\n    while (p != NULL && q != NULL) {\n        if (p->info < q->info) {\n            s = p;\n            p = p->next;\n        }\n        else {\n            s = q;\n            q = q->next;\n        }\n        s->next = head3->next;\n        head3->next = s;\n    }\n    if (p == NULL) {\n        p = q;\n    }\n    while (p != NULL) {\n        s = p;\n        p = p->next;\n        s->next = head3->next;\n        head3->next = s;\n    }\n    node *ans = init();\n    p = head3->next;\n    while (p != NULL) {\n        s = p;\n        p = p->next;\n        s->next = ans->next;\n        ans->next = s;\n    }\n    return ans;\n}\nint main()\n{\n    node *L1, *L2;\n    datatype y;\n    int j, n;\n\n    L1 = init();  L2 = init();\n\n    /*建表*/\n    printf(\"请输入带头结点单链表A的结点个数：\");  scanf(\"%d\", &n);\n    printf(\"请输入带头结点单链表A的结点值：\");\n    for (j = 0; j < n; j++)\n    {\n        scanf(\"%d\", &y);  L1 = insert(L1, y, j);\n    }\n    display(L1);\n    printf(\"\\n\");\n    printf(\"请输入带头结点单链表B的结点个数：\");  scanf(\"%d\", &n);\n    printf(\"请输入带头结点单链表B的结点值：\");\n    for (j = 0; j < n; j++)\n    {\n        scanf(\"%d\", &y);  L2 = insert(L2, y, j);\n    }\n    display(L2);\n    printf(\"\\n\");\n\n    /*在此处完成对mergelist函数的调用，并进行测试*/\n    node *L3 = mergelist(L1, L2);\n    printf(\"输出合并后的链表：\");\n    display(L3);\n}\n\n\n", "Konwledge_Point": "归并排序", "Question": "各位善良的学长学姐们  帮学妹看看如何写出一个完整的有序表合并的代码吧\n#include\nusing namespace std;\n\n\ntemplate\nstruct LNode\n{ DT data;\n  LNode \nnext;\n};\n//初始化单链表\ntemplate\nbool InitList(LNode\n&L)\n{  L=new LNode;\n   if(!L)exit(1);\n   L->next=NULL;\n   return true;\n}\n//创建单链表\ntemplate\n  //尾插法\nbool CreateList(LNode*&L,int n)\n{ LNode *p;\n    p=L;\nLNode \ns;\nfor(int i=1;i<=n;i++)\n    {\n    s=new LNode\n;\n    if(!s)\n     return false;\n    cin>>s->data;\n    s->next=p->next ;\n    p->next=s;\n    p=s;\n    }\n    return true;\n}\n//销毁单链表\ntemplate\nvoid DestroyList(LNode\n&L)\n{\n    LNode\n *p;\n while(L)\n {  p=L;\n       L=L->next;\n    delete p;\n }\n L=NULL;\n}\n//遍历输出表\ntemplate\nvoid DispList(LNode *&L)\n{\nLNode *p;\np=L->next ;\n  while(p)\n  {\n   cout<\ndata;\n   p=p->next;\n  }\n}\n//从小到大排序\ntemplate\nvoid sort(LNode *&L)\n{\n    LNode *p,*q,*min;\n    for(p=L->next;p!=NULL;p=p->next)\n    {\n        min=p;\n        for(q=p->next;q!=NULL;q=q->next)\n        {\n            if(q->data\ndata)\n                min=q;\n\n\n    }\n    \nif\n(min!=p)\n    {\n        \nint\n temp=p->\ndata\n;\n        \np\n->\ndata\n=min->\ndata\n;\n        \nmin\n->\ndata\n=temp;\n    }\n}\n\n\n\n}\n\n\nint main()\n{  int i;\n   LNode\n  *LA;\n   LNode\n  *LB;\n   LNode\n  *LC;\n   InitList(LA);\n   InitList(LB);\n   InitList(LC);\n\n\ncout\n<<\n\"请输入创建链表LA的元素个数：\"\n;\n\ncin\n>>i;\n\ncout\n<<\n\"请依次输入集合A元素为：\"\n;\n\nCreateList\n(\nLA\n,i);\n\ncout\n<<\n\"有序表LA= \"\n;\n\nsort\n(\nLA\n);\n\nDispList\n(\nLA\n);\n\n\ncout\n<>i;\n\ncout\n<<\n\"请依次输入集合B元素为：\"\n;\n\nCreateList\n(\nLB\n,i);\n\ncout\n<<\n\"有序表LB= \"\n;    \n\nsort\n(\nLB\n);\n\nDispList\n(\nLB\n);\n\n\nLNode\n *pa=\nLA\n->next;\n\nLNode\n *pb=\nLB\n->next;\n    \n\nif\n(\nLB\n->next==\nNULL\n)\n    \nDispList\n(\nLA\n);\n\nif\n(\nLA\n->next==\nNULL\n)\n    \nDispList\n(\nLB\n);\n        \n\nLNode\n *pc=\nLC\n;          \n    while(pa && pb)\n    {        \n    \nif\n(pa ->\ndata\n <= pb->\ndata\n)\n\n      {\n        pc->\ndata\n = pa->\ndata\n ;\n\n        pa = pa->next;\n      }\n    \nelse\n\n      {\n        pc->\ndata\n =pb->\ndata\n;\n\n        pb = pb->next;\n      }\n    }\n\n    while(pa)\n    {            \n        pc->next = pa;\n        pc= pa;\n        pa = pa->next;\n    }\n    while(pb)\n    {      \n        pc->next = pb;\n        pc= pb;\n        pb = pb->next;\n    }\n\n\n\nCreateList\n(\nLC\n,pc->\ndata\n);\n\n\ncout\n<<\n\"有序表归并表LC= \"\n;\n\nfor\n(pc=\nLC\n->next;pc!=\nNULL\n;pc=pc->next)\n    {\n        cout<\ndata\n;\n\n    }\n\n    \n\ncout\n<<endl;\n\n\n\n   return 0;\n}", "Tag": "算法分析"}
