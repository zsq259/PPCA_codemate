{"Answer": "http://blog.csdn.net/u013487051/article/details/37660701", "Konwledge_Point": "二分匹配", "Question": "小行星问题，二分匹配怎么做？                 \nDescription\n\n\n\nBessie wants to navigate her spaceship through a dangerous asteroid field in the shape of an N x N grid (1 <= N <= 500). The grid contains K asteroids (1 <= K <= 10,000), which are conveniently located at the lattice points of the grid. \n\n\n\nFortunately, Bessie has a powerful weapon that can vaporize all the asteroids in any given row or column of the grid with a single shot.This weapon is quite expensive, so she wishes to use it sparingly.Given the location of all the asteroids in the field, find the minimum number of shots Bessie needs to fire to eliminate all of the asteroids.\n\nInput\n\n\n\n\n\nLine 1: Two integers N and K, separated by a single space. \n\n\nLines 2..K+1: Each line contains two space-separated integers R and C (1 <= R, C <= N) denoting the row and column coordinates of an asteroid, respectively.\n\nOutput\n\n\nLine 1: The integer representing the minimum number of times Bessie must shoot.\n\nSample Input\n\n\n3 4\n\n1 1\n\n1 3\n\n2 2\n\n3 2\n\nSample Output\n\n\n\n2", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/cnss/article/details/77628", "Konwledge_Point": "二分匹配", "Question": "dat格式的数据怎么使用二分查找的形式精确返回一个浮点数所在的序数？\ndat格式的数据怎么使用二分查找的形式精确返回一个浮点数所在的序数？精确匹配查找的算法是什么，怎么用代码实现？", "Tag": "算法分析"}
{"Answer": "不明白你要干什么 “联北1101分支线1号开关” 如果是固定的长度， 你直接substring就可以了。 如果你有规律类似的， 要把规律写明白， 比如\r\n\r\n联北11011分支线1号开关\r\n联北11015分支线11号开关\r\n联北1101435分支线111号开关\r\n联北11013分支线13号开关\r\n联北110134分支线15号开关\r\n\r\n这样也是能做到的， 你可以使用正则表达式获得这个substring.\r\n(联北[\\d]{1,}分支线[\\d]{1,}号开关)\r\n\r\n你最好提问要明白自己要干么。。也要对别人说清楚。：）", "Konwledge_Point": "二分匹配", "Question": "求一个匹配\n联北1101分支线1号开关A相避雷器 \n\n联北1101分支线1号开关B相避雷器\n\n\n\n从以上这些字符串中获取 联北1101分支线1号开关 怎么写 谢谢！", "Tag": "算法分析"}
{"Answer": "建议直接用bs4定位a标签获取数据比较好", "Konwledge_Point": "二分匹配", "Question": "爬虫的时候正则匹配不明白咋办，完全相同的东西多了不会弄，不一样的多了也不会弄= =\n一、有超过一个完全相同的，正则无法正确匹配\n\n\n二、分类中有格式不一样的内容，正则无法正确匹配\n就好比一个电影网站，他两个电影的网页设计不完全一样", "Tag": "算法分析"}
{"Answer": "https://zhidao.baidu.com/question/1047118235968767819.html?skiptype=2", "Konwledge_Point": "二分匹配", "Question": "请问如何用二分的搜索算法对dat文件的内容以查找的方式读取\n请问如何用二分的搜索算法对dat文件的内容以查找的方式读取，精确匹配浮点数要求做到高性能怎么才能实现？", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/bestrem_9/article/details/38355913", "Konwledge_Point": "二分匹配", "Question": "dat文件中存储的浮点数能不能在程序中精确匹配检索？   \ndat文件中存储的浮点数能不能在程序中精确匹配检索？看网页上说有一个二分查找，但是不能精确请问怎么克服这个问题？", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/jaryle/article/details/52023295", "Konwledge_Point": "二分匹配", "Question": "请教怎么使用hash的方式编制索引，为什么说hash的索引比排序还快\n请教怎么使用hash的方式编制索引，为什么说hash的索引比排序还快，不是排序以后可以二分搜索了么？怎么精确匹配效率最高？", "Tag": "算法分析"}
{"Answer": "1、是否可以再加一个字段，存储content的长度？这样分页问题就解决了；2、charcontent（content）只有这一个条件吗？没有时间，ID之类的其它条件去过滤吗？3、按照第二种方案，先查询后在内存里面做分页，那这种肯定不可取4、是否可以对这种数据先做处理？正常查询是越简单越好", "Konwledge_Point": "二分匹配", "Question": "使用mybatis plus分页查询后，如何再过滤一次条件了再分页\n问题遇到的现象和发生背景\n\n\n我的场景是很多条件查询，其中有一个条件是是否筛选A字段长度大于10的\n\n\n\n\n我的解答思路和尝试过的方法\n\n\n我有两个想法：1.我的分页查询和条件构造都是用mybatis plus完成的，计算“内容”字段content长度的话，就只能拼接sql语句：where charlength（content）> 10，但是这样就导致了整个构造的条件最终不走索引，于是我就想到了第二个方法\n                         2.先分页查询，然后再对分页查询出来的数据进行筛选，filter（a->a.getContent.length()>10）collect(Collectors.toList())，但是这样就有一个问题，就比如说，分页查询出来后，当前页是第一页，分页的size是10，筛选掉content小于10的有8条数据，那最终第一页就只有2条数据了\n 所以我想请教一下，有没有分页查询后→筛选数据后-→再按size分页/或者说，让筛选后的数据往前挤", "Tag": "算法分析"}
{"Answer": "你可以通过遍历所有的sheet的方式,追加数据\nfrom openpyxl import Workbook, load_workbook\nimport xlrd\nfilePath = \"some.xls\"\nwb = load_workbook(path)\nworkbook = xlrd.open_workbook(path)\n# 获取所有sheet\nsheetNamesList = workbook.sheet_names()\n# A表和B表的数据\ndata1 = [1,2,3]\ndata2 = [4,5,6]\ndata = {\"A\":data1,\"B\":data2}\nfor name in sheetNamesList:\n    sheet = wb[name]\n    for elem in data.get(\"name\",[]):\n        sheet.append(elem)\n\n如果觉得有帮助,请点击采纳,谢谢~", "Konwledge_Point": "二分匹配", "Question": "（初学者）关于Python操作Excel问题\n  本人初学编程，学习Python，想编写一个小程序对文本中的txt文件正则表达式匹配后生成列表，再用sheet.append(list)的方法更新到指定Excel表格指定sheet的末尾行。\n  现在问题，对文本分类后，需将匹配的第一个列表文本值逐个更新到sheet的A列，第二个列表文本值逐个更新到sheet的B列。\n  请问，第二列的更新方式可否改为sheet['B'].append()\n  请各位大佬不吝赐教，十分感谢！", "Tag": "算法分析"}
{"Answer": "表TBL_Message的时间字段应该是date类型的，所以你插入数据的时候就应该是date类型，否则会报错，改成\r\n\r\nINSERT INTO TBL_Message\r\nVALUES\r\n  (tbl_seq.NEXTVAL,\r\n   '我学到低二学期了，加油！',\r\n   '斯瓦辛格',\r\n   SYSDATE);\r\n\r\n你查询的时候用下面sql就行了\r\nselect TO_CHAR(tdate,'yyyy\"年\"mm\"月\"dd\"日\"hh\"时\"mi\"分\"ss\"秒\"') from TBL_Message", "Konwledge_Point": "二分匹配", "Question": "oracle插入\nSQL>  insert into TBL_Message values(tbl_seq.nextval,'我学到低二学期了，加油！','斯瓦辛格',TO_CHAR(S\n\nYSDATE,'yyyy\"年\"mm\"月\"dd\"日\"hh\"时\"mi\"分\"ss\"秒\"'));\n\n\n\ninsert into TBL_Message values(tbl_seq.nextval,'我学到低二学期了，加油！','斯瓦辛格',TO_CHAR(SYSDAT\n\nE,'yyyy\"年\"mm\"月\"dd\"日\"hh\"时\"mi\"分\"ss\"秒\"'))\n\n                                                                                      *\n\n第 1 行出现错误:\n\nORA-01861: 文字与格式字符串不匹配\n\n\n\n请问各位高手指出那里出错，帮我看看（在oracle插入数据，还有时间，主要是时间报错）\n\n我需要的是系统时间，精确到秒！！\n\n谢谢！！", "Tag": "算法分析"}
{"Answer": "find()对字符串进行匹配,匹配到的字符串可以在任何位置. \r\nJava代码示例: \r\nPattern p=Pattern.compile(\"\\\\d+\"); \r\nMatcher m=p.matcher(\"22bb23\"); \r\nm.find();//返回true \r\nMatcher m2=p.matcher(\"aa2223\"); \r\nm2.find();//返回true \r\nMatcher m3=p.matcher(\"aa2223bb\"); \r\nm3.find();//返回true \r\nMatcher m4=p.matcher(\"aabb\"); \r\nm4.find();//返回false \r\n\r\n可参照次链接。http://blog.csdn.net/cclovett/article/details/12448843", "Konwledge_Point": "二分匹配", "Question": "for循环中find是怎么工作的\npublic static void splitOper(String[] s){  \n    Pattern p = Pattern.compile(\"[0-9]+\");  // 以数字做分隔，正则表达式  \n    for(int i=0;i<s.length;i++){  \n        Matcher m = p.matcher(s[i]);    // 得到所有数字   \n        m.find();   // 得到第一个数字   \n        int Row = Integer.parseInt(m.group());  // 取出第一个数字   \n        m.find();   // 得到第二个数字   \n        int Col = Integer.parseInt(m.group());  // 取出第二个数字   \n        System.out.println(fun(Row,Col));   // 计算结果并输出   \n    }  \n} \n    如果String[] s是R12C4，这段代码的作用是使Row =12，Col =4，\n    我想问一下，在for循环是一个字符一个字符来的，里面的两个find是怎么匹配的\n", "Tag": "算法分析"}
{"Answer": "二分检索，时间复杂度为O(nlogn)。 \n排序时间复杂度O(nlogn), 二分查找每次左侧O(logn), 每次右侧O(logn),总复杂度O(nlogn + nlogn+nlogn)=O(nlogn).\n\nfrom typing import List\nimport bisect\n\n\ndef challenger_finder(socket_list: List[int], k:int) ->List[int]:\n\tn = len(socket_list)\n\tst = sorted(socket_list)\n\tans = []\n\n\tfor i in range(n):\n\t\tleft = socket_list[i] - k\n\t\tright = socket_list[i] + k\n\t\tlk = bisect.bisect_left(st, left)\n\t\trk = bisect.bisect_right(st, right)\n\t\tans.append(rk-lk-1)\n\treturn ans\n\n ", "Konwledge_Point": "二分匹配", "Question": "一个小程序，求大神们帮个忙\n时间复杂度必须不能大于nlogn\n\n\n\n要用python完成\n\n\n\n在这个问题中，你将得到一个整数列表，代表每个玩家在他们的最后一场比赛中持有的股票数量，以及一个整数，代表要检查的范围应该有多宽。使用这些给定的变量，你的目标是找到每个玩家所创造的范围内的玩家数量。\n\n\n\n例如，假设给定的列表为[5,1,3,1]，范围变量为2。第一个要处理的参与人在索引0处。他们在最后一场比赛中赢了5支股票。要检查的范围是2高于5所以是7,2低于5所以是3。然后，我们的范围将是[(5-2)，(5+2)]或[3,7]，两端都包括在内。在给定的列表中只有一个值3，所以索引为0的玩家只有1场比赛可用。有关更深入的示例，请查看后面的示例。\n\n\n\n您的目标是返回一个包含每个玩家可用对手数量的列表。上面示例的返回列表将是[1,2,3,2]。\n\n\n\n2、向列表中添加元素:List[int]， k [int]\n\n\n\n\n\n\n\nstocks_list: List[int]:一个长度为n的Python列表，包含整数，表示每个玩家在最后一场比赛中获得的股票。每个指数代表一个玩家。\n\n\n\nk: int: Integer表示用于确定每个玩家所有可用对手的范围\n\n\n\n返回:一个长度为n的Python列表，包含整数，包含每个玩家可用对手的数量。\n\n\n\n时间复杂度:O(nlog(n))，其中n是玩家数量\n\n\n\n保证的条件：\n\n\n\n范围k是非负的(可以是正的也可以是零的)\n\n\n\nstocks_list可以包含任何整数、负数、正数和0\n\n\n\nstocks_list可能包含重复的股票编号\n\n\n\n每个测试用例都是保证生成的\n\n\n\n\n\n\n例子:\n\n\n\n例1:\n\n\n\nstocks_list = [5, 1, 3, 2]\n\n\n\nk = 1\n\n\n\n第一个玩家的股票从指数0[5,1,3,2]到5，范围是1。检查可能的对手的范围将是1低于5和1高于5。因此，取值范围应该是[5 - 1,5 + 1]或[4,6]，两边都要包括。在给定的列表中，没有任何值在查找范围[4,6]内，除了这个玩家。因此，没有人会与这个球员匹配，并且一个0应该被放置在返回列表的索引0处。\n\n第二个玩家的股票从指数1[5,1,3,2]中取1，范围为1。检查可能的对手的范围将是1低于1和1高于1。因此，取值范围应该是[1 - 1,1 + 1]或[0,2]，两边都要包括。在给定的列表中，在查找范围内有一个值[0,2]，但不包括这个玩家。因此，只有一个玩家将与这个玩家匹配，并且1应该被放置在返回列表的索引1处。\n\n第三个玩家的股票是指数2[5,1,3,2]中的3，范围是1。检查可能的对手的范围将是1低于3和1高于3。因此，取值范围应该是[3 - 1,3 + 1]或[2,4]，两边都要包括。在给定的列表中，在查找范围内有一个值[2,4]，但不包括这个玩家。因此，只有一个玩家将与这个玩家匹配，并且1应该被放置在返回列表的索引2处。\n\n最后一个玩家的股票是指数3[5,1,3,2]中的2，范围是1。检查可能的对手的范围将是1低于2和1高于2。因此，取值范围为[2 - 1,2 + 1]或[1,3]，两边都要包含。在给定的列表中，在查找范围内有两个值[1,3]，不包括这个玩家。因此，两个玩家将与这个玩家匹配，一个2应该被放置在返回列表的索引3处。\n\n根据以上结果，每个玩家的可能对手数返回列表为[0,1,1,2]\n\n\n\n例2:\n\nstocks_list = [40,22,30,20]\n\n\n\nk = 5\n\n\n\n第一个玩家的股票是指数0[40,22,30,20]的40，范围是5。检查可能的对手的范围将是5低于40和5高于40。因此，取值范围应该是[40 - 5,40 + 5]或[35,45]，两边都要包括。在给定的列表中，除了这个玩家，在这个查找范围[35,45]内没有任何值。因此，没有人会与这个球员匹配，并且一个0应该被放置在返回列表的索引0处。\n\n\n\n第二个玩家的股票是指数1[40,22,30,20]中的22，范围是5。检查可能的对手的范围将是5低于22和5高于22。因此，取值范围应该是[22 - 5,22 + 5]或[17,27]，两边都要包括。在给定的列表中，在查找范围内有一个值[17,29]，但不包括这个玩家。因此，只有一个玩家将与这个玩家匹配，并且1应该被放置在返回列表的索引1处。\n\n\n\n第三个玩家的股票是指数2[40,22,30,20]的30，范围是5。检查可能的对手的范围将是5低于30和5高于30。因此，取值范围应该是[30 - 5,30 + 5]或[25,35]，两边都要包括。在给定的列表中，除了这个玩家之外，在这个查找范围[25,35]内没有任何值。因此，没有人会与这个玩家匹配，一个0应该被放置在返回列表的索引2处。\n\n\n\n最后一个玩家的股票是指数3[40,22,30,20]的20，范围是5。检查可能的对手的范围将是5低于20和5高于20。因此，取值范围应该是[20 - 5,20 + 5]或[15,25]，两边都要包括在内。在给定的列表中，有一个玩家在寻找范围内[15,25]，但不包括这个玩家。因此，一个玩家将与这个玩家匹配，并且1应该被放置在返回列表的索引3处。\n\n\n\n根据以上结果，每个玩家的可能对手数返回列表为[0,1,0,1]\n\n\n\n提示:\n\n\n\n试着从O(n²)方法开始，然后改进你的算法\n\n\n\n考虑使用排序、滑动窗口、二分搜索或这些方法的组合来减少时间复杂性\n\n\n\n考虑一种改变数字位置(即排序)的方法，同时维护对它们最初所在的列表中的位置(索引)的引用\n\n\n\n \n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n ", "Tag": "算法分析"}
{"Answer": "估计是代码输入有错误了", "Konwledge_Point": "二分匹配", "Question": "【python-docx】学习python-docx，想提取文字后分类别存入不同word，出现错误\n   本人小白学python，请各位大佬帮忙看一下是哪里出问题，感激不尽。\n   小弟想将一个word(新建 DOCX 文档.docx）中的字符串检索后分类别存储到几个word中，以下为代码：\n    jn = (\n'一年级'\n, \n'二年级'\n, \n'三年级'\n, \n'四年级'\n, \n'五年级'\n, \n'六年级'\n)\n    \nprint\n(\n'1.一年级    2.二年级    3.三年级   4.四年级    5.五年级    6.六年级'\n)\n    mc = \nint\n(\ninput\n(\n'请输入对应的数字：'\n)) - \n1\n\n    \nfrom\n docx \nimport\n Document\n    \nimport\n re\n    zzbdstx = {\n'拼音题(.*?)得分'\n: \n'拼音题'\n, \n'词语题(.*?)得分'\n: \n'词语题'\n, \n'句子题(.*?)得分'\n: \n'句子题'\n, \n'默写题(.*?)得分'\n: \n'默写题'\n, \n'阅读题(.*?)得分'\n: \n'阅读题'\n,\n               \n'作文题(.*?)得分'\n: \n'作文题'\n}\n    ypp_lb = []\n    xt_doc = Document(\nr'F:\\试题程序\\新建 DOCX 文档.docx'\n)\n    \nfor\n para \nin\n xt_doc.paragraphs:\n        ypp_lb.append(para.text)\n    ypp_st = \n''\n.join(ypp_lb) \n#获取新题拼接成一个字符串放入一个列表中\n\n    \ndef\n \nppxtwd\n(\nzzbds, liemc\n):\n        xtpp = zzbds.findall(ypp_st)\n        tk_gx = Document(\n'F:\\\\试题程序\\\\题库'\n + \n'\\\\'\n + \nstr\n(jn[mc]) + \n'\\\\'\n + \nstr\n(liemc) + \n'.docx'\n)\n        \nfor\n ppdx \nin\n xtpp:\n            tk_gx.add_paragraph(ppdx)\n            tk_gx.save(\n'F:\\\\试题程序\\\\题库'\n + \n'\\\\'\n + \nstr\n(jn[mc]) + \n'\\\\'\n + \nstr\n(liemc) + \n'.docx'\n)\n    \nfor\n txzzbds, bgxlie_n \nin\n zzbdstx.items():\n        xt = re.\ncompile\n(txzzbds)  \n# 匹配拼音部分题目\n\n        ppxtwd(xt, bgxlie_n)\n\n\n\n输入了数字‘5’以后，报错：docx.opc.exceptions.PackageNotFoundError: Package not found at 'F:\\试题程序\\题库\\五年级\\拼音题.docx'\nF:\\试题程序\\题库\\五年级\\拼音题.docx是已经建立好了的。", "Tag": "算法分析"}
{"Answer": "1. 卡号有限：\r\n将所有可能的卡号放在一张表中，使用了的卡号从表中删除，不再使用的增加回来，每次随便拿这个表的记录给用户就行了.\r\n\r\n2.卡号无限：\r\n记下当前已使用的最大卡号，给客户时只要返回大于这个卡号的即可。", "Konwledge_Point": "二分匹配", "Question": "高手们请进。急待解决\n目标：一个算号系统，要将系统产生的一亿条数据（卡号）,（没有存在与其他表中的卡号）呈现给客户使用。\n\n----  oracle 10g , java\n\n\n\n方法1：将数据卡号分阶段产生，并查询记录是否存在于其他表中，将结果分页返回。\n\n      问题：例如程序产生了 13 条卡号分别为，1,2,3......12,13。其中3和9的卡号存在，则为无效数据。每页返回5条数据。\n\n            目前每次取5条数据去数据库中匹配，如果存在1条则将第6-10条数据进行匹对，匹对到第7条数据时，第一页数据返回, 那么第二页数据如何取到。\n\n\n\n方法2：将所有数据存放到一张临时表中（只有一个字段）,  在将存在的卡号删除。 将剩余的卡号呈现给客户。\n\n      问题：将上亿条数据插入耗时太久,目前采用一次提交10W条,也要30个小时左右。怎么能让1E条数据快速插入数据库中。\n\n\n\n以上方法那种效率更高?或者有其他方法。有意帮忙的 直接回复或QQ 362129760 诚谢。", "Tag": "算法分析"}
{"Answer": "sc.nextInt()应该放在“你的答案是：”这句输出的后面；另外random.nextInt(4)，是随机 0-3的数字。", "Konwledge_Point": "二分匹配", "Question": "请问这个哪里错了呢？系统没有报错，但是一直运行不出来\n//任务需求：完成自动出题、判分程序：执行程序，系统自动显示试题\n//（两个数的算术运算即可），\n//并提示用户输入答案，待用户输入答案后，系统给出答案的判分结果。\n提示：\n1、随机数的产生：\nRandom ran = new Random();  //定义Random类的对ran\nx=ran.nextInt(10);  //产生一个0-9之间 的随机数\n2、加减乘除运算符号的产生：先生成一个随机数，而后和加减乘除符号相匹配。\n3、什么时候得到标准答案，如何判断对错。\n//\n\n\npackage 第二周实验题目;\nimport java.util.Random;\nimport java.util.Scanner;\npublic class exercise {\n\n\npublic static void main(String\n[]\n args) {\n    \n// TODO Auto-generated method stub\n\n    Random r=\nnew\n \nRandom()\n;\n    \nint\n number1=r.next\nInt(10)\n;\n    \nint\n number2=r.next\nInt(10)\n;\n    \nint\n code=r.next\nInt(4)\n;\n    Scanner sc=\nnew\n \nScanner(System.\nin\n)\n;\n    \nint\n answer=sc.next\nInt()\n;\n    \n//double answer2=sc.nextInt();\n\n    switch(code) {\n    case \n1\n:\n        \nSystem\n.\nout.println(\n\"你抽到的题目为：\\n\"\n);\n        \nSystem\n.\nout.printf(\n\"%d+%d=?\"\n,number1+number2);\n        \nSystem\n.\nout.println(\n\"你的答案是：\"\n);\n        \nif\n(answer==number1+number2) {\n            \nSystem\n.\nout.println(\n\"恭喜你答对了，你将获得10分\"\n);\n        }\nelse\n {\n            \nSystem\n.\nout.println(\n\"答错了，你将获得0分\"\n);\n            \n//score=0;\n\n        }\n        break;\n    case \n2\n:\n        \nSystem\n.\nout.println(\n\"你抽到的题目为：\\n\"\n);\n        \nSystem\n.\nout.printf(\n\"%d-%d=?\"\n,number1-number2);\n        \nSystem\n.\nout.println(\n\"你的答案是：\"\n);\n        \nif\n(answer==number1-number2) {\n            \nSystem\n.\nout.println(\n\"恭喜你答对了，你将获得10分\"\n);\n        \n//    score=10;\n\n        }\nelse\n {\n            \nSystem\n.\nout.println(\n\"答错了，你将获得0分\"\n);\n        \n//    score=0;\n\n        }\n        break;\n    case \n3\n:\n        \nSystem\n.\nout.println(\n\"你抽到的题目为：\\n\"\n);\n        \nSystem\n.\nout.printf(\n\"%d*%d=?\"\n,number1*number2);\n        \nSystem\n.\nout.println(\n\"你的答案是：\"\n);\n        \nif\n(answer==number1*number2) {\n            \nSystem\n.\nout.println(\n\"恭喜你答对了，你将获得10分\"\n);\n            \n//score=10;\n\n        }\nelse\n {\n            \nSystem\n.\nout.println(\n\"答错了，你将获得0分\"\n);\n            \n//score=0;\n\n        }\n        break;\n    case \n4\n:\n        \nSystem\n.\nout.println(\n\"你抽到的题目为：\\n\"\n);\n        \nSystem\n.\nout.printf(\n\"%d/%d=?\"\n,number1/number2);\n        \nSystem\n.\nout.println(\n\"你的答案是：\"\n);\n        \nif\n( answer–\n1.0\n*number1/number2＜\n0.001\n) {\n            \nSystem\n.\nout.println(\n\"恭喜你答对了，你将获得10分\"\n);\n            \n//score=10;\n\n        }\nelse\n {\n            \nSystem\n.\nout.println(\n\"答错了，你将获得0分\"\n);\n            \n//score=0;\n\n        }\n        break;\n    }\n    sc.close\n()\n;\n    \n}\n\n\n\n}", "Tag": "算法分析"}
{"Answer": "用simple_html_dom 解决了  不过还是感谢楼上的回答", "Konwledge_Point": "二分匹配", "Question": "php 采集正则 求大神解答\n```\n\n\n\n                                    \n新品专区\n\n\n\n\n\n保暖上装\n\n\n\n\n\n\n\n\n                                                                假两件（衬衫领）\n                                                            \n\n\n\n\n\n\n                                                                V领上装\n                                                            \n\n\n\n\n\n\n\n上面是分类  我匹配的一级分类\n$dafht='#(.*)#iUs';\npreg_match_all($dafht, $fenlei, $dafenlei);\n\n但是无效 求大神解答  \n\n\n一级分类主要是采集   category-907362761.htm     这个数字ID  和后面的名称\n\n二级分类采集   category-907362761.htm    parentCatId=907362759  这俩个数字ID  和后面的名称\n\n怎么写 卡主半天了 求解答\n\n\n", "Tag": "算法分析"}
{"Answer": "    \r\n    WebLogicHost localhost    \r\n    WebLogicPort 7001    \r\n    MatchExpression *.do  \r\n    MatchExpression *.jsp\r\n    MatchExpression /jobs*    \r\n", "Konwledge_Point": "二分匹配", "Question": "Apache+tomcat迁移到apache+Weblogic整合之动静分离问题？困惑两天了~\n先看看我的WEB应用是用Spring MVC 3.0.4做的，在Apache(mod_jk)+tomcat的时候完全没有问题。\n\n\n\n \n\n\n\n1. web.xml配置，\n注意url-pattern，是处理所有的请求，这是一个网站的根应用项目\n。\n\n\n\ncts-web\norg.springframework.web.servlet.DispatcherServlet\n\ncontextConfigLocation\n/WEB-INF/spring/webmvc-config.xml\n\n1\n\n\ncts-web\n/\n\n\n\n2. 上面为什么spring要拦截所有请求呢，是因为在处理URL路径时更方便,URL更友好,\n这就是spring MVC好用的地方，不需要专门的url rewrite\n\n\n  //处理首页\n        @RequestMapping(value = \"/\", method = {RequestMethod.GET, RequestMethod.POST})\n    public ModelAndView index(HttpServletResponse resp, HttpServletRequest req) throws Exception {\n        // TODO: something\n        ModelAndView result = new ModelAndView(\"index\");\n\n        return result;\n    }\n\n \n\n//处理learn首页\n@RequestMapping(value = \"/learn\", method = { RequestMethod.GET })\n\n//处理一级分类\n@RequestMapping(value = \"/learn/{sectionName}\", method = { RequestMethod.GET })\npublic ModelAndView sectionIndex(@PathVariable String sectionName)\n\n//处理二级分类\n@RequestMapping(value = \"/learn/{sectionName}/{categoryName}/{currPage}\", method = { RequestMethod.GET })\npublic ModelAndView categoryIndex(@PathVariable String sectionName,@PathVariable String categoryName,@PathVariable Integer currPage)\n\n\n\n\n3.  spring-mvc.xml配置，开发的时候静态内容不经过Spring MVC处理，直接交给容器\n\n\n\n        \n\n\n\n\n\n\n4. httpd.conf配置，在cts-web目录中放入静态内容\n\n\n\nJkAutoAlias \"D:\\apache-www\\cts-web\"\n\nJkMount /* cts\n\nJkUnMount /images/* cts\nJkUnMount /styles/* cts\nJkUnMount /scripts/* cts\n\n\n\n至此，apache+tomcat整合动静分离完全没有问题，run了好几个月。\n\n\n\n-----------------------------------------------------------------------------\n\n\n\n \n\n\n\n现在换成weblogic做应用服务器了，和apache整合就出问题了。\n\n\n\n用的是weblogic的plug in来整合，\n如果不做静态文件分离，下面的配置完全能够跑起来了，没有任何问题。\n\n\n\nLoadModule weblogic_module modules/mod_wl_22.so\n\n    WebLogicHost localhost\n    WebLogicPort 7001\n    MatchExpression *\n\n\n\n\n现在问题出来了，我如何才能把静态文件分离出来呢？\n\n\n\n1. mod_weblogic只有MatchExpression，他是正向匹配的，不像JkUnMount可以反向排除？\n\n\n\n2. 我的应用中动态处理的url有些有后缀名，有些没有（上面有详细描述），干脆直接就是个目录，比如 http://www.sample.com/jobs，导致没法用MatchExpression来匹配？\n\n\n\n3. \n在不修改我的程序的基础上有没有办法做到：apache+weblogic整合，并且做到静态文件分离由apache处理呢？\n\n\n\n ", "Tag": "算法分析"}
{"Answer": "好兄弟，发错地方啦，这里是问答区，你应该发博客的🤣🤣🤣黑马程序员卧槽，不好意思，当我没说😋😋😋", "Konwledge_Point": "二分匹配", "Question": "Java入门第八天：方法的定义和调用、返回值方法、方法重载等\n1. 方法概述\n\n\n1.1 方法的概念\n\n\n​    方法（method）是程序中最小的执行单元\n\n\n注意：\n方法必须先创建才可以使用，该过程成为方法定义\n方法创建后并不是直接可以运行的，需要手动使用后，才执行，该过程成为方法调用\n\n\n\n\n2. 方法的定义和调用\n\n\n2.1 无参数方法定义和调用\n\n\n定义格式：\n\n\npublic\n \nstatic\n \nvoid\n 方法名 (   ) {\n    \n// 方法体;\n\n}\n\n\n\n范例：\n\n\npublic\n \nstatic\n void \nmethod\n \n(    )\n \n{\n    // 方法体;\n}\n\n\n\n\n调用格式：\n\n\n方法名()\n;\n\n\n\n\n范例：\n\n\nmethod\n()\n;\n\n\n\n\n注意：\n\n\n​    方法必须先定义，后调用，否则程序将报错\n\n\n\n\n2.3 无参数方法的练习\n\n\n需求：设计一个方法用于打印两个数中的较大数 \n思路：\n①定义一个方法，用于打印两个数字中的较大数，例如getMax() \n②方法中定义两个变量，用于保存两个数字 \n③使用分支语句分两种情况对两个数字的大小关系进行处理 \n④在main()方法中调用定义好的方法 \n\n\n代码：\n\n\npublic\n \nclass\n \nMethodTest\n {\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString[] args\n)\n {\n        \n//在main()方法中调用定义好的方法\n\n        getMax();\n    }\n\n    \n//定义一个方法，用于打印两个数字中的较大数，例如getMax()\n\n    \npublic\n \nstatic\n \nvoid\n \ngetMax\n(\n)\n {\n        \n//方法中定义两个变量，用于保存两个数字\n\n        \nint\n a = \n10\n;\n        \nint\n b = \n20\n;\n\n        \n//使用分支语句分两种情况对两个数字的大小关系进行处理\n\n        \nif\n(a > b) {\n            System.\nout\n.println(a);\n        } \nelse\n {\n            System.\nout\n.println(b);\n        }\n    }\n}\n\n\n\n3. 带参数方法定义和调用\n\n\n3.1 带参数方法定义和调用\n\n\n定义格式：\n\n\n参数：由数据类型和变量名组成 -  数据类型 变量名\n\n\n参数范例：int a\n\n\npublic\n \nstatic\n \nvoid\n 方法名 (参数\n1\n) {\n    方法体;\n}\n\n\npublic\n \nstatic\n \nvoid\n 方法名 (参数\n1\n, 参数\n2\n, 参数\n3.\n..) {\n    方法体;\n}\n\n\n\n范例：\n\n\npublic\n \nstatic\n \nvoid\n \nisEvenNumber\n(\nint\n number)\n{\n    ...\n}\n\npublic\n \nstatic\n \nvoid\n \ngetMax\n(\nint\n num1, \nint\n num2)\n{\n    ...\n}\n\n\n\n注意：\n\n\n  方法定义时，参数中的数据类型与变量名都不能缺少，缺少任意一个程序将报错\n    \n  方法定义时，多个参数之间使用逗号\n( ，)\n分隔\n\n\n\n\n\n调用格式：\n\n\n方法名\n(参数)\n；\n\n方法名\n(参数1,参数2)\n;\n\n\n\n范例：\n\n\nisEvenNumber\n(\n10\n);\n\n\ngetMax\n(\n10\n,\n20\n);\n\n\n\n方法调用时，参数的数量与类型必须与方法定义中的设置相匹配，否则程序将报错 \n\n\n\n\n3.2 形参和实参\n\n\n形参：方法定义中的参数\n\n\n​          等同于变量定义格式，例如：int number\n\n\n实参：方法调用中的参数\n\n\n​          等同于使用变量或常量，例如： 10  number\n\n\n3.3 带参数方法练习\n\n\n需求：设计一个方法用于打印两个数中的较大数，数据来自于方法参数 }\n思路：\n①定义一个方法，用于打印两个数字中的较大数，例如getMax() \n②为方法定义两个参数，用于接收两个数字 \n③使用分支语句分两种情况对两个数字的大小关系进行处理 \n④在main()方法中调用定义好的方法（使用常量）\n⑤在main()方法中调用定义好的方法（使用变量） \n\n\n代码：\n\n\npublic\n \nclass\n \nMethodTest\n {\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString[] args\n)\n {\n        \n//在main()方法中调用定义好的方法（使用常量）\n\n        getMax(\n10\n,\n20\n);\n        \n//调用方法的时候，人家要几个，你就给几个，人家要什么类型的，你就给什么类型的\n\n        \n//getMax(30);\n\n        \n//getMax(10.0,20.0);\n\n\n        \n//在main()方法中调用定义好的方法（使用变量）\n\n        \nint\n a = \n10\n;\n        \nint\n b = \n20\n;\n        getMax(a, b);\n    }\n\n    \n//定义一个方法，用于打印两个数字中的较大数，例如getMax()\n\n    \n//为方法定义两个参数，用于接收两个数字\n\n    \npublic\n \nstatic\n \nvoid\n \ngetMax\n(\nint\n a, \nint\n b\n)\n {\n        \n//使用分支语句分两种情况对两个数字的大小关系进行处理\n\n        \nif\n(a > b) {\n            System.\nout\n.println(a);\n        } \nelse\n {\n            System.\nout\n.println(b);\n        }\n    }\n}\n\n\n\n4. 带返回值方法的定义和调用\n\n\n4.1 带返回值方法定义和调用\n\n\n定义格式\n\n\npublic\n \nstatic\n 数据类型 方法名 ( 参数 ) { \n    \nreturn\n 数据 ;\n}\n\n\n\n范例\n\n\npublic\n \nstatic\n \nboolean\n \nisEvenNumber\n( \nint\n number )\n \n{           \n    \nreturn\n \ntrue\n ;\n}\n\npublic\n \nstatic\n \nint\n \ngetMax\n( \nint\n a, \nint\n b )\n \n{\n    \nreturn\n  \n100\n ;\n}\n\n\n\n注意：\n方法定义时return后面的返回值与方法定义上的数据类型要匹配，否则程序将报错\n\n\n\n\n调用格式\n\n\n方法名 ( 参数 ) \n;\n\n数据类型 变量名 \n=\n 方法名 ( 参数 ) \n;\n\n\n\n\n范例\n\n\nisEvenNumber ( \n5\n ) \n;\n\nboolean  flag \n=\n  isEvenNumber ( \n5\n )\n; \n\n\n\n\n注意：\n方法的返回值通常会使用变量接收，否则该返回值将无意义\n\n\n\n\n\n\n4.2 带返回值方法练习1\n\n\n需求：设计一个方法可以获取两个数的较大值，数据来自于参数\n\n\n思路：\n\n\n①定义一个方法，用于获取两个数字中的较大数 \n②使用分支语句分两种情况对两个数字的大小关系进行处理 \n③根据题设分别设置两种情况下对应的返回结果 \n④在main()方法中调用定义好的方法并使用变量保存 \n⑤在main()方法中调用定义好的方法并直接打印结果 \n\n\n代码：\n\n\npublic\n \nclass\n \nMethodTest\n {\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString[] args\n)\n {\n        \n//在main()方法中调用定义好的方法并使用变量保存\n\n        \nint\n result = getMax(\n10\n,\n20\n);\n        System.\nout\n.println(result);\n\n        \n//在main()方法中调用定义好的方法并直接打印结果\n\n        System.\nout\n.println(getMax(\n10\n,\n20\n));\n    }\n\n    \n//定义一个方法，用于获取两个数字中的较大数\n\n    \npublic\n \nstatic\n \nint\n \ngetMax\n(\nint\n a, \nint\n b\n)\n {\n        \n//使用分支语句分两种情况对两个数字的大小关系进行处理\n\n        \n//根据题设分别设置两种情况下对应的返回结果\n\n        \nif\n(a > b) {\n            \nreturn\n a;\n        } \nelse\n {\n            \nreturn\n b;\n        }\n    }\n}\n\n\n\n\n\n4.3 带返回值方法练习2\n\n\n需求：\n\n\n​    定义一个方法，求一家商场每个季度的营业额。根据方法结果再计算出全年营业额。\n\n\n代码示例：\n\n\npackage\n com.itheima.demo;\n\n\npublic\n \nclass\n \nMethodDemo9\n {\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(String[] args)\n {\n        \n/*需求：定义一个方法，求一家商场每个季度的营业额。\n        根据方法结果再计算出全年营业额。*/\n\n        \nint\n \nsum1\n \n=\n getSum(\n10\n, \n20\n, \n30\n);\n        \nint\n \nsum2\n \n=\n getSum(\n10\n, \n20\n, \n30\n);\n        \nint\n \nsum3\n \n=\n getSum(\n10\n, \n20\n, \n30\n);\n        \nint\n \nsum4\n \n=\n getSum(\n10\n, \n20\n, \n30\n);\n\n        \nint\n \nsum\n \n=\n sum1 + sum2 + sum3 + sum4;\n        System.out.println(sum);\n\n    }\n\n    \n//心得：\n\n    \n//1.我要干嘛？  决定了方法体   每个季度的营业额\n\n    \n//2.我干这件事情，需要什么才能完成？ 决定了形参 需要三个月的营业额 a b c\n\n    \n//3.我干完这件事情，看调用处是否需要使用方法的结果。   决定了返回值\n\n    \n//如果需要使用，那么必须返回\n\n    \n//如果不需要使用，可以返回也可以不返回\n\n    \npublic\n \nstatic\n \nint\n \ngetSum\n(\nint\n month1,\nint\n month2,\nint\n month3)\n{\n        \nint\n \nsum\n \n=\n month1 + month2 + month3;\n        \n//因为方法的调用处，需要继续使用这个结果\n\n        \n//所以我们必须要把sum返回\n\n        \nreturn\n sum;\n    }\n}\n\n\n\n4.4 带返回值方法练习3\n\n\n需求：\n\n\n​    键盘录入两个圆的半径（整数），比较两个圆的面积。\n\n\n代码示例：\n\n\nimport java.util.Scanner;\n\n\npublic\n \nclass\n \nMethodDemo10\n {\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString[] args\n)\n {\n        \n//需求：键盘录入两个圆的半径（整数），比较两个圆的面积。\n\n        \n//键盘录入圆的半径\n\n        Scanner sc = \nnew\n Scanner(System.\nin\n);\n        System.\nout\n.println(\n\"请输入圆的半径\"\n);\n        \nint\n radii1 = sc.nextInt();\n\n        System.\nout\n.println(\n\"请输入第二个圆的半径\"\n);\n        \nint\n radii2 = sc.nextInt();\n        \ndouble\n area1 = getArea(radii1);\n        \ndouble\n area2 = getArea(radii2);\n        \nif\n(area1 > area2){\n            System.\nout\n.println(\n\"第一个圆更大\"\n);\n        }\nelse\n{\n            System.\nout\n.println(\n\"第二个圆更大\"\n);\n        }\n    }\n\n    \n//心得：\n\n    \n//1.我要干嘛？   求圆的面积\n\n    \n//2.我干这件事情，需要什么才能完成？        半径\n\n    \n//3.方法的调用处，是否需要继续使用方法的结果    要比较\n\n    \npublic\n \nstatic\n \ndouble\n \ngetArea\n(\nint\n radii\n)\n {\n        \ndouble\n area = \n3.14\n * radii * radii;\n        \nreturn\n area;\n    }\n}\n\n\n\n5. 方法的注意事项\n\n\n5.1 方法的注意事项\n\n\n方法不能嵌套定义\n\n\n示例代码：\n\n\npublic\n \nclass\n \nMethodDemo\n {\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[] args\n) {\n\n    }\n\n    \npublic\n \nstatic\n \nvoid\n \nmethodOne\n(\n) {\n        \npublic\n \nstatic\n \nvoid\n \nmethodTwo\n(\n) {\n               \n// 这里会引发编译错误!!!\n\n        }\n    }\n}\n\n\n\n\n\nvoid表示无返回值，可以省略return，也可以单独的书写return，后面不加数据\n\n\n示例代码：\n\n\npublic\n \nclass\n \nMethodDemo\n {\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[] args\n) {\n\n    }\n    \npublic\n \nstatic\n \nvoid\n \nmethodTwo\n(\n) {\n        \n//return 100; 编译错误，因为没有具体返回值类型\n\n        \nreturn\n;    \n        \n//System.out.println(100); return语句后面不能跟数据或代码\n\n    }\n}\n\n\n\n\n\n\n\n5.2 方法的通用格式\n\n\n格式：\n\n\npublic\n \nstatic\n 返回值类型 方法名(参数) {\n   方法体; \n   \nreturn\n 数据 ;\n}\n\n\n\n解释：\n\n\npublic static     修饰符，目前先记住这个格式\n\n\n   返回值类型    方法操作完毕之后返回的数据的数据类型\n\n\n​            如果方法操作完毕，没有数据返回，这里写void，而且方法体中一般不写return\n\n\n   方法名        调用方法时候使用的标识\n\n\n   参数        由数据类型和变量名组成，多个参数之间用逗号隔开\n\n\n   方法体        完成功能的代码块\n\n\n   return        如果方法操作完毕，有数据返回，用于把数据返回给调用者\n\n\n\n\n定义方法时，要做到两个明确\n\n\n明确返回值类型：主要是明确方法操作完毕之后是否有数据返回，如果没有，写void；如果有，写对应的数据类型\n明确参数：主要是明确参数的类型和数量\n\n\n调用方法时的注意：\n\n\nvoid类型的方法，直接调用即可\n非void类型的方法，推荐用变量接收调用\n\n\n\n\n6. 方法重载\n\n\n6.1 方法重载\n\n\n方法重载概念\n\n\n方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载\n\n\n多个方法在同一个类中\n多个方法具有相同的方法名\n多个方法的参数不相同，类型不同或者数量不同\n\n\n注意：\n\n\n重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式\n重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，换句话说不能通过返回值来判定两个方法是否相互构成重载\n\n\n正确范例：\n\n\npublic\n \nclass\n \nMethodDemo\n \n{\n    \npublic\n \nstatic\n \nvoid\n \nfn\n(\nint\n a\n) \n{\n        \n//方法体\n\n    }\n    \npublic\n \nstatic\n \nint\n \nfn\n(\ndouble\n a\n) \n{\n        \n//方法体\n\n    }\n}\n\n\npublic\n \nclass\n \nMethodDemo\n \n{\n    \npublic\n \nstatic\n \nfloat\n \nfn\n(\nint\n a\n) \n{\n        \n//方法体\n\n    }\n    \npublic\n \nstatic\n \nint\n \nfn\n(\nint\n a , \nint\n b\n) \n{\n        \n//方法体\n\n    }\n}\n\n\n\n错误范例：\n\n\npublic\n \nclass\n \nMethodDemo\n \n{\n    \npublic\n \nstatic\n \nvoid\n \nfn\n(\nint\n a\n) \n{\n        \n//方法体\n\n    }\n    \npublic\n \nstatic\n \nint\n \nfn\n(\nint\n a\n) \n{     \n/*错误原因：重载与返回值无关*/\n\n        \n//方法体\n\n    }\n}\n\n\npublic\n \nclass\n \nMethodDemo01\n \n{\n    \npublic\n \nstatic\n \nvoid\n \nfn\n(\nint\n a\n) \n{\n        \n//方法体\n\n    }\n} \n\npublic\n \nclass\n \nMethodDemo02\n \n{\n    \npublic\n \nstatic\n \nint\n \nfn\n(\ndouble\n a\n) \n{ \n/*错误原因：这是两个类的两个fn方法*/\n\n        \n//方法体\n\n    }\n}\n\n\n\n\n\n6.2 方法重载练习\n\n\n需求：使用方法重载的思想，设计比较两个整数是否相同的方法，兼容全整数类型（byte,short,int,long） \n\n\n思路：\n\n\n①定义比较两个数字的是否相同的方法compare()方法，参数选择两个int型参数\n②定义对应的重载方法，变更对应的参数类型，参数变更为两个long型参数\n③定义所有的重载方法，两个byte类型与两个short类型参数 \n④完成方法的调用，测试运行结果 \n\n\n代码：\n\n\npublic\n \nclass\n \nMethodTest\n {\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString[] args\n)\n {\n        \n//调用方法\n\n        System.\nout\n.println(compare(\n10\n, \n20\n));\n        System.\nout\n.println(compare((\nbyte\n) \n10\n, (\nbyte\n) \n20\n));\n        System.\nout\n.println(compare((\nshort\n) \n10\n, (\nshort\n) \n20\n));\n        System.\nout\n.println(compare(\n10L\n, \n20L\n));\n    }\n\n    \n//int\n\n    \npublic\n \nstatic\n boolean \ncompare\n(\nint\n a, \nint\n b\n)\n {\n        System.\nout\n.println(\n\"int\"\n);\n        \nreturn\n a == b;\n    }\n\n    \n//byte\n\n    \npublic\n \nstatic\n boolean \ncompare\n(\nbyte\n a, \nbyte\n b\n)\n {\n        System.\nout\n.println(\n\"byte\"\n);\n        \nreturn\n a == b;\n    }\n\n    \n//short\n\n    \npublic\n \nstatic\n boolean \ncompare\n(\nshort\n a, \nshort\n b\n)\n {\n        System.\nout\n.println(\n\"short\"\n);\n        \nreturn\n a == b;\n    }\n\n    \n//long\n\n    \npublic\n \nstatic\n boolean \ncompare\n(\nlong\n a, \nlong\n b\n)\n {\n        System.\nout\n.println(\n\"long\"\n);\n        \nreturn\n a == b;\n    }\n\n}\n\n\n\n\n\n7.3 数组遍历\n\n\n需求：设计一个方法用于数组遍历，要求遍历的结果是在一行上的。例如：[11, 22, 33, 44, 55] \n\n\n思路：\n\n\n①因为要求结果在一行上输出，所以这里需要在学习一个新的输出语句System.out.print(“内容”);\n\n\nSystem.out.println(“内容”); 输出内容并换行\n\n\nSystem.out.print(“内容”); 输出内容不换行\n\n\nSystem.out.println(); 起到换行的作用\n\n\n②定义一个数组，用静态初始化完成数组元素初始化\n\n\n③定义一个方法，用数组遍历通用格式对数组进行遍历\n\n\n④用新的输出语句修改遍历操作\n\n\n⑤调用遍历方法\n\n\n\n\n代码：\n\n\npublic\n \nclass\n \nTest1\n {\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString[] args\n)\n {\n      \n/*  //先打印数据，再进行换行\n        System.out.println(\"aaa\");\n        //只打印不换行\n        System.out.print(\"bbb\");\n        System.out.print(\"ddd\");\n        //不打印任何内容，只换行\n        System.out.println();\n        System.out.print(\"cc\");*/\n\n        \n//设计一个方法用于数组遍历，要求遍历的结果是在一行上的。例如：[11, 22, 33, 44, 55]\n\n        \nint\n[] arr = {\n1\n,\n2\n,\n3\n,\n4\n,\n5\n};\n        printArr(arr);\n    }\n    \n//1.我要遍历数组\n\n    \n//2.需要什么？  数组\n\n    \n//3.调用处是否需要使用方法的结果。\n\n    \npublic\n \nstatic\n \nvoid\n \nprintArr\n(\nint\n[] arr\n)\n{\n        System.\nout\n.print(\n\"[\"\n);\n        \nfor\n (\nint\n i = \n0\n; i < arr.length; i++) {\n            \nif\n(i == arr.length - \n1\n){\n                System.\nout\n.println(arr[i] + \n\"]\"\n);\n            }\nelse\n{\n                System.\nout\n.print(arr[i] + \n\", \"\n);\n            }\n        }\n    }\n}\n\n\n\n\n\n7.4 数组最大值\n\n\n需求：设计一个方法用于获取数组中元素的最大值 \n\n\n思路：\n\n\n①定义一个数组，用静态初始化完成数组元素初始化\n②定义一个方法，用来获取数组中的最大值，最值的认知和讲解我们在数组中已经讲解过了\n③调用获取最大值方法，用变量接收返回结果\n④把结果输出在控制台\n\n\n代码：\n\n\npublic\n \nclass\n \nMethodTest02\n {\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[] args)\n \n{\n        \n//定义一个数组，用静态初始化完成数组元素初始化\n\n        \nint\n[] arr = {\n12\n, \n45\n, \n98\n, \n73\n, \n60\n};\n\n        \n//调用获取最大值方法，用变量接收返回结果\n\n        \nint\n number = \ngetMax\n(arr);\n\n        \n//把结果输出在控制台\n\n        System.out.\nprintln\n(\n\"number:\"\n + number);\n    }\n\n    \n//定义一个方法，用来获取数组中的最大值\n\n    \n/*\n        两个明确：\n            返回值类型：int\n            参数：int[] arr\n     */\n\n    \npublic\n \nstatic\n \nint\n \ngetMax\n(\nint\n[] arr)\n \n{\n        \nint\n max = arr[\n0\n];\n\n        \nfor\n(\nint\n x=\n1\n; x max) {\n                max = arr[x];\n            }\n        }\n        \nreturn\n max;\n    }\n}\n\n\n\n\n\n7.6 获取索引\n\n\n需求：\n\n\n​    定义一个方法获取数字，在数组中的索引位置，将结果返回给调用处，如果有重复的，只要获取第一个即可。\n\n\n代码示例：\n\n\npackage com.itheima.demo;\n\n\npublic\n \nclass\n \nTest4\n {\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[] args)\n \n{\n        \n//定义一个方法获取数字，在数组中的索引位置，将结果返回给调用处\n\n        \n//如果有重复的，只要获取第一个即可\n\n\n        \nint\n[] arr = {\n1\n,\n2\n,\n3\n,\n4\n,\n5\n};\n        \nint\n index = \ncontains\n(arr, \n3\n);\n        System.out.\nprintln\n(index);\n    }\n\n    \n//1. 我要干嘛？判断数组中的某一个数是否存在\n\n    \n//2. 需要什么？数组 数字\n\n    \n//3. 调用处是否需要继续使用？返回\n\n    \n//获取number在arr中的位置\n\n    \npublic\n \nstatic\n \nint\n \ncontains\n(\nint\n[] arr, \nint\n number)\n \n{\n        \n//遍历arr得到每一个元素\n\n        \nfor\n (\nint\n i = \n0\n; i < arr.length; i++) {\n            \n//拿着每一个元素跟number比较\n\n            \nif\n(arr[i] == number){\n                \n//如果相等，表示找到了\n\n                \nreturn\n i;\n            }\n        }\n        \n//当循环结束之后，如果还不能返回索引，表示数组中不存在该数据\n\n        \n//可以返回-1\n\n        \nreturn\n \n-1\n;\n    }\n}\n", "Tag": "算法分析"}
{"Answer": "考虑字典套字典比如大类是外面字典的键，然后英汉翻译键值对作为值放在里面字典", "Konwledge_Point": "二分匹配", "Question": "左边是英语，右边是汉字，做成2个列表查找替换用，可是如何与大类做成映射关系呢？\n作为写代码翻译用，左边是英语，右边是汉字，做成2个列表查找替换用，可是如何与大类做成映射关系呢？让我们输入一个键值就懂是大类下的分类？\n\n\nPython常用英文单词：\n一、交互式环境与print输出\n1、print：打印/输出\n2、coding：编码\n3、syntax：语法\n4、error：错误\n5、invalid：无效\n6、identifier：名称/标识符\n7、character ：字符\n二、字符串的操作\n1、user：用户\n2、name：姓名/名称\n3、attribute：字段/属性\n4、value：值\n5、key：键\n三、重复/转换/替换/原始字符串\n1、upper：上面\n2、lower：下面\n3、capitalize：用大写字母写或印刷\n4、title：标题\n5、replace：替换\n6、old：旧的\n7、new：新的\n8、count：计数\n9、swap：互换\n10、case：情形\n11、path：路径\n12、new：新的\\新建\n13、project：项目\n14、test：测试\n15、file：文件\n16、data：数据\n四、去除/查询/计数\n1、strip：去除\n2、index：索引\n3、find：查找\n4、count：计数\n5、start：开始\n6、end：结束\n7、chars：字符\n8、sub：附属\n五、获取输入/格式化\n1、input：输入\n2、prompt：提示\n3、ID：身份证\n4、format：格式化\n5、args（argument）：参数\n6、kwargs：关键字参数\n7、year：年\n8、month：月\n9、day：日\n六、元组\n1、tuple：元组\n2、max：最大\n3、min：最小\n4、iterable：可迭代\n5、key：关键字\n6、function：方法/函数\n7、stop：停止\n8、object：对象\n七、列表\n1、list：列表\n2、reverse：反向\n3、true：真\n4、false：假\n5、append：附加\n6、extend：扩展\n7、insert：插入\n8、pop：取出\n9、remove：移除\n10、del（delete）：删除\n11、clear：清除\n12、sort：排序\n八、集合\n1、set：集合/设置\n2、add：添加\n3、update：更新\n4、discard：丢弃\n5、intersection：相交\n6、union：联合\n7、difference：差数\n8、symmetric：对称\n9、in：在…里面\n10、not：不/不是\n11、disjoint：不相交\n12、subset：子集\n13、superset：父集/超集\n14、copy：复制\n九、字典\n1、dict：字典\n2、key：键/关键字\n3、value：值\n4、item：项\n5、mapping：映射\n6、seq（sequence）：序列\n7、from：从/来自\n8、get：获取\n9、default：默认\n10、none：没有\n11、arg：可变元素\n12、kwargs（keyword args）：可变关键字元素\n十、循环\n1、for…in…循环的使用\n2、while…循环的使用\n3、range：范围\n4、sep(separate)：分隔\n5、flush：冲刷\n6、step：步长\n7、continue：继续\n8、break：突破/跳出\n十一、条件/跳出与结束循环\n1、if：如果\n2、else：否则\n十二、运算符与随机数\n1、module：模块\n2、sys(system)：系统\n3、path：路径\n4、import：导入\n5、from：从…\n十三、定义函数与设定参数\n1、birthday：出生日期\n2、year：年份\n3、month：月份\n4、day：日期\n5、type：类型\n6、error：错误\n7、missing：丢失\n8、required：必须\n9、positional：位置\n10、unsupported：不支持\n十四、设定收集参数\n1、create：创建\n2、info：信息\n3、age：年龄\n4、height：高度\n5、width：宽度\n6、weight：重量\n7、splicing：拼接\n8、params：参数\n9、volume：体积\n11、operand：操作数\n十五、嵌套函数/作用域/闭包\n1、inside：内部\n2、outside：外部\n3、radius：半径\n4、perimeter：周长\n5、case：情形\n6、synthesis：合成\n7、execute：执行\n十六、递归函数\n1、recursion：递归\n2、Infinite：无穷\n3、maximum：最大值\n4、depth：深度\n5、exceeded：超过\n6、factorial：阶乘\n7、search：查询\n8、power：幂\n9、lower：下方\n10、upper：上方\n11、middle：中间\n12、assert/assertion：异常\n十七、列表推导式/lambda表达式\n1、square：平方\n2、even：偶数\n3、comprehension：理解\n4、lambda：希腊字母λ的英文名称，大名鼎鼎的游戏半条命里面的logo就是这个。\n十八、列表推导式/lambda表达式\n1、regular：规则\n2、expression： 表达式\n3、group：组\n4、match：匹配\n5、span：跨度\n6、ignore case：忽略 大小写\n7、multi line：多 行\n8、dot all：点 全部\n9、unicode：万国码\n10、verbose：累赘\n11、pos/position：位置", "Tag": "算法分析"}
{"Answer": "严重怀疑是你 TF 装的过程出了问题，建议重新安装或者使用 conda 隔离环境，可以参考 https://tf.wiki/zh_hans/basic/installation.html 的教程，安装合适版本的 CUDA Toolkit 和 CUDNN，再看看问题会不会出现。还有要注意你 3060 显卡要用 CUDA 11 以上，例如现在 TF 官方推荐使用 CUDA 11.2 和 CUDNN 8.1.0。", "Konwledge_Point": "二分匹配", "Question": "使用Pycharm运行以下LeNet5的模型进行mnist的训练时报错且不运行\n使用Pycharm运行以下LeNet5的模型进行mnist的训练时报错且不运行\n\n\n\n\n'''\n@author: 唐十\n@project: AI\n@file: LeNet_5.py\n@time: 2022/7/18 14:55\n@desc:使用LeNet_5模型\n'''\n\n\nfrom\n keras.datasets \nimport\n mnist\n\nimport\n numpy \nas\n np\n\nfrom\n keras.utils \nimport\n to_categorical\n\nfrom\n matplotlib \nimport\n pyplot \nas\n plt\n\nfrom\n keras.models \nimport\n Sequential\n\nfrom\n keras.layers \nimport\n Dense\n\nfrom\n keras.layers \nimport\n Conv2D\n\nfrom\n keras.layers \nimport\n AvgPool2D\n\nfrom\n keras.layers \nimport\n Flatten\n\nfrom\n keras.optimizers \nimport\n SGD\n\n'''\nLeNet_5使用边长为5的卷积核，卷积前后的图片边长有如下规律：m=n-f+1，m为卷积后边长，n为卷积前边长，f为卷积核边长\n所以我们第一次卷积之后得到的是边长为24的图片\n'''\n\n(X_train, Y_train), (X_test, Y_test) = mnist.load_data()\n\n# 申明一个模型\n\nmodel = Sequential()\n\n'''\n这里使用的是卷积，所以不需要拉伸，但是我们需要明确通道数\n'''\n\nX_train = X_train.reshape(\n60000\n, \n28\n, \n28\n, \n1\n) / \n255.0\n\nX_test = X_test.reshape(\n10000\n, \n28\n, \n28\n, \n1\n) / \n255.0\n\n\n# 申明一个卷积层——filters表示有几个卷积核，kernel_size表示卷积核的大小，strides表示每次卷积核移动的步，input_shape表示输入的形状，灰度图*1彩色图*3，padding表示填充模式，有些时候为了避免卷积之后图片大小变化，会使用same的padding，在卷积前的图片上加一圈像素，此处使用valid表示不加\n\nconv2D1=Conv2D(filters=\n6\n,kernel_size=(\n5\n,\n5\n),strides=(\n1\n,\n1\n),input_shape=(\n28\n,\n28\n,\n1\n),padding=\n'valid'\n,activation=\n'relu'\n)\nmodel.add(conv2D1)\n\n# 申明一个池化层\n\navgPool2D1=AvgPool2D(pool_size=(\n2\n,\n2\n))\nmodel.add(avgPool2D1)\n\n# 申明一个卷积层，不是第一层就不用申明形状了，会自动推断\n\nconv2D2=Conv2D(filters=\n16\n,kernel_size=(\n5\n,\n5\n),strides=(\n1\n,\n1\n),padding=\n'valid'\n,activation=\n'relu'\n)\nmodel.add(conv2D2)\n\n# 申明一个池化层\n\navgPool2D2=AvgPool2D(pool_size=(\n2\n,\n2\n))\nmodel.add(avgPool2D2)\n\n# 卷积神经网络和全连接神经网络之间需要一个Flatten去铺开数据\n\nflatten=Flatten()\nmodel.add(flatten)\n\n# 我们采用One-Hot的编码模式，对Y进行分类，由于最终结果为0-9这10种可能，因此我们需要十位One-Hot编码\n\n\n'''\nOne-Hot编码：只有一位是1，其余是0\n'''\n\nY_train = to_categorical(Y_train, \n10\n)\nY_test = to_categorical(Y_test, \n10\n)\n\n# units 表示这一层有几个神经元，activation表示激活函数是哪个，input_dim表示要接收的参数的个数\n\n\n# 第一层（一个神经元接收一个x）\n\ndense1 = Dense(units=\n120\n, activation=\n'relu'\n)\ndense2 = Dense(units=\n84\n, activation=\n'relu'\n)\n\n\n# dense1=Dense(units=3,activation='relu',input_dim=2)\n\n\n# units 表示这一层有几个神经元，activation表示激活函数是哪个，input_dim表示要接收的参数的个数\n\n\n# 第二层（第二层接收的是第一层的数据，不接收x）\n\n\n'''\n由于最终结果为0-9这10种可能，因此需要10个输出神经元，而对这些输出，我们采用One-Hot的编码模式\n使用softmax作为激活函数，使得最终所有可能的概率之和等于1\n'''\n\ndense3 = Dense(units=\n10\n, activation=\n'softmax'\n)\nmodel.add(dense1)\nmodel.add(dense2)\nmodel.add(dense3)\n\n\n# 为模型添加配置:loss规定代价函数是什么，此处采用categorical_crossentropy（交叉熵），optimizer表示优化器，这里使用sgd随机梯度下降去优化，metrics为评估标准，accuracy的意思是准确度\n\n\n# model.compile(loss='mean_squared_error',optimizer='sgd',metrics=['accuracy'])# 这么写就代表使用默认学习率的sgd，想要指定学习率要使用对象\n\n\n# 关于多分类的输出，使用交叉熵代价函数\n\nmodel.\ncompile\n(loss=\n'categorical_crossentropy'\n, optimizer=SGD(learning_rate=\n0.05\n), metrics=[\n'accuracy'\n])\n\n# 开始训练，第一个参数为输入的数据，第二个数据为标准答案，第三个数据为epochs训练回合数，我们把在全部样本的一次训练称为一个回合，第四个参数batch_size表示批量数，表示一次训练使用多少个样本\n\nmodel.fit(X_train, Y_train, epochs=\n5000\n, batch_size=\n48\n)\n\n# 测试模型\n\nloss, accuracy = model.evaluate(X_test, Y_test)\n\nprint\n(\n\"损失率是：\"\n + \nstr\n(loss))\n\nprint\n(\n\"匹配度是：\"\n + \nstr\n(accuracy))\n\n\n\n\n\n运行结果及报错内容\n\n\nE:\\Code\\AI\\venv\\Scripts\\python.exe \"E:\\PyCharm 2021.3.3\\plugins\\python\\helpers\\pydev\\pydevconsole.py\" \n--mode=client --port=49250\n\n\nimport\n sys; print(\n'Python %s on %s'\n % (sys.\nversion\n, sys.platform))\nsys.path.extend([\n'E:\\\\Code\\\\AI'\n, \n'E:/Code/AI'\n])\nPyDev console: starting.\nPython \n3.10\n.5\n (tags/v3\n.10\n.5\n:f377153, Jun  \n6\n \n2022\n, \n16\n:\n14\n:\n13\n) [MSC v\n.1929\n \n64\n \nbit\n (AMD64)] \non\n win32\nrunfile(\n'E:/Code/AI/com/shi/tang/lesson9/LeNet_5.py'\n, wdir=\n'E:/Code/AI/com/shi/tang/lesson9'\n)\nBackend TkAgg \nis\n interactive backend. Turning interactive mode \non\n.\n\n2022\n-07\n-18\n \n18\n:\n28\n:\n02.609732\n: I tensorflow/core/platform/cpu_feature_guard.cc:\n193\n] This TensorFlow binary \nis\n optimized \nwith\n oneAPI Deep Neural Network Library (oneDNN) \nto\n use the \nfollowing\n CPU instructions \nin\n performance-critical operations:  AVX AVX2\n\nTo\n \nenable\n them \nin\n other operations, rebuild TensorFlow \nwith\n the appropriate compiler flags.\n\n2022\n-07\n-18\n \n18\n:\n28\n:\n02.950669\n: I tensorflow/core/common_runtime/gpu/gpu_device.cc:\n1532\n] Created device /job:localhost/\nreplica\n:\n0\n/task:\n0\n/device:GPU:\n0\n \nwith\n \n9622\n MB memory:  -> device: \n0\n, \nname\n: NVIDIA GeForce RTX \n3060\n, pci bus id: \n0000\n:\n01\n:\n00.0\n, compute capability: \n8.6\n\nEpoch \n1\n/\n5000\n\n进程已结束,退出代码\n-1073740791\n (\n0xC0000409\n)\n\n\n\n\n还有一些问题\n\n\n我之前训练的时候会提示少dll，但是仍然能正常训练，在我加入相应dll之后不爆红了，但是训练速度下降了，怎么处理？", "Tag": "算法分析"}
