{"Answer": "class Graph:\n    def __init__(self, num_vertices):\n        self.num_vertices = num_vertices\n        self.adj_list = [[] for _ in range(num_vertices)]\n        \n    def add_edge(self, u, v):\n        self.adj_list[u].append(v)\n        self.adj_list[v].append(u)\n\ndef bfs(graph, start, component_num, component):\n    queue = [start]\n    component[start] = component_num\n    while queue:\n        vertex = queue.pop(0)\n        for neighbor in graph.adj_list[vertex]:\n            if component[neighbor] is None:\n                queue.append(neighbor)\n                component[neighbor] = component_num\n\ndef get_connected_components(graph):\n    component_num = 0\n    component = [None] * graph.num_vertices\n    for vertex in range(graph.num_vertices):\n        if component[vertex] is None:\n            bfs(graph, vertex, component_num, component)\n            component_num += 1\n    return component\n\n# 创建图\ng = Graph(5)\ng.add_edge(0, 1)\ng.add_edge(0, 2)\ng.add_edge(1, 2)\ng.add_edge(2, 3)\n\n# 获取连通分量\ncomponents = get_connected_components(g)\nprint(components)  # 输出：[0, 0, 0, 1, 2]\n", "Konwledge_Point": "图的强连通分量", "Question": "利用广度优先搜索编程实现确定无向图的连通分量。\nPython数据结构，利用广度优先搜索编程实现确定无向图的连通分量。", "Tag": "算法分析"}
{"Answer": "http://www.cppblog.com/Ylemzy/archive/2011/04/02/143310.html", "Konwledge_Point": "图的强连通分量", "Question": "强连通分量                \nDescription\n\n\n\nOnce upon a time there lived a king and he had N sons. And there were N beautiful girls in the kingdom and the king knew about each of his sons which of those girls he did like. The sons of the king were young and light-headed, so it was possible for one son to like several girls. \n\n\n\nSo the king asked his wizard to find for each of his sons the girl he liked, so that he could marry her. And the king's wizard did it -- for each son the girl that he could marry was chosen, so that he liked this girl and, of course, each beautiful girl had to marry only one of the king's sons. \n\n\n\nHowever, the king looked at the list and said: \"I like the list you have made, but I am not completely satisfied. For each son I would like to know all the girls that he can marry. Of course, after he marries any of those girls, for each other son you must still be able to choose the girl he likes to marry.\" \n\n\n\nThe problem the king wanted the wizard to solve had become too hard for him. You must save wizard's head by solving this problem.\n\nInput\n\n\n\nThe first line of the input contains N -- the number of king's sons (1 <= N <= 2000). Next N lines for each of king's sons contain the list of the girls he likes: first Ki -- the number of those girls, and then Ki different integer numbers, ranging from 1 to N denoting the girls. The sum of all Ki does not exceed 200000. \n\n\n\nThe last line of the case contains the original list the wizard had made -- N different integer numbers: for each son the number of the girl he would marry in compliance with this list. It is guaranteed that the list is correct, that is, each son likes the girl he must marry according to this list. \n\nOutput\n\n\n\nOutput N lines.For each king's son first print Li -- the number of different girls he likes and can marry so that after his marriage it is possible to marry each of the other king's sons. After that print Li different integer numbers denoting those girls, in ascending order.\n\nSample Input\n\n\n\n4\n\n2 1 2\n\n2 1 2\n\n2 2 3\n\n2 3 4\n\n1 2 3 4\n\nSample Output\n\n\n\n2 1 2\n\n2 1 2\n\n1 3\n\n1 4", "Tag": "算法分析"}
{"Answer": "强连通分量是指在有向图中，任意两点之间都存在一条从一个点到另一个点的有向路径，并且从另一个点也能到达第一个点的点集。所以有3个，最左边一个，中间4个，右边1个一个顶点自然是一个连通分量。因为它不需要任何路径，它肯定能到达自身。", "Konwledge_Point": "图的强连通分量", "Question": "数据结构中有向图的强连通分量\n右图中的强连通分量的个数为（    ）个。\n\n\n这里左右两个顶点怎么是强连通分量了", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/keyboardmagician/article/details/53005003", "Konwledge_Point": "图的强连通分量", "Question": "求强连通分量入门题hdu1269迷宫城堡wa掉了大神帮忙看看\n迷宫城堡\n\n\n\nTime Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)\n\nTotal Submission(s): 17155    Accepted Submission(s): 7507\n\n\n\nProblem Description\n\n为了训练小希的方向感，Gardon建立了一座大城堡，里面有N个房间(N<=10000)和M条通道(M<=100000)，每个通道都是单向的，就是说若称某通道连通了A房间和B房间，只说明可以通过这个通道由A房间到达B房间，但并不说明通过它可以由B房间到达A房间。Gardon需要请你写个程序确认一下是否任意两个房间都是相互连通的，即：对于任意的i和j，至少存在一条路径可以从房间i到房间j，也存在一条路径可以从房间j到房间i。\n\n\n\nInput\n\n输入包含多组数据，输入的第一行有两个数：N和M，接下来的M行每行有两个数a和b，表示了一条通道可以从A房间来到B房间。文件最后以两个0结束。\n\n\n\nOutput\n\n对于输入的每组数据，如果任意两个房间都是相互连接的，输出\"Yes\"，否则输出\"No\"。\n\n\n\nSample Input\n\n3 3\n\n1 2\n\n2 3\n\n3 1\n\n3 3\n\n1 2\n\n2 3\n\n3 2\n\n0 0\n\n\n\nSample Output\n\nYes\n\nNo\n\n\n\n下面是我写了 注释是我自己理解的不知道对不对 求指点！\n\nimport java.util.ArrayList;\n\nimport java.util.Scanner;\n\nimport java.util.Stack;\n\n\n\npublic class Main {\n\n\n\nprivate static int n;\nprivate static int m;\nprivate static int[] dfn;\nprivate static int[] low;\nprivate static int time;\nprivate static Stack stack;\nprivate static int sum;\nprivate static ArrayList[] list;\n\npublic static void main(String[] args) {\n    // TODO 自动生成的方法存根\n    Scanner scanner = new Scanner(System.in);\n    while (scanner.hasNext()) {\n        scn(scanner);//输入\n        bud();       //算法\n        out();       //输出\n    }\n}\n\nprivate static void out() {\n    // TODO 自动生成的方法存根\n    if (sum==1) {\n        System.out.println(\"Yes\");\n    }else {\n        System.out.println(\"No\");\n    }\n}\n\nprivate static void bud() {\n        dfn = new int [n+1];//次序数组\n        low = new int [n+1];//记录此点所能到达最早栈中的值\n        time = 0;//时间戳\n        sum = 0;//记录此图有几个强连通分量\n        stack = new Stack();\n        //强连通分量一定是个环   此栈相当于这个环中的任意一条弧\n        Targan_bfs(1);\n}\n\nprivate static void Targan_bfs(int i) {\n        dfn[i] = low[i]    = ++time;//low先初始跟次序相同\n        stack.push(i);//将点i压入栈\n        //之后进行bfs搜索 枚举每一种成环的可能\n        for (int j = 0; j ();}\n    for (int i = 0; i <m; i++) {\n        int a = scanner.nextInt();\n        int b = scanner.nextInt();\n        list[a].add(b);\n    }        \n}\n\n\n\n\n}", "Tag": "算法分析"}
{"Answer": "联通分量分为强连通和弱连通，如果是弱连通，这里就不需要分了。", "Konwledge_Point": "图的强连通分量", "Question": "数据结构中的连通分量问题\n\n\n按照有向图看， 这6 个顶点 是一个 连通分量吗？是不是 要把 5 和 4 去掉， 0 1 2 3 是一个分量，5 、4 分别是另外两个分量", "Tag": "算法分析"}
{"Answer": "输入图的格式是什么？", "Konwledge_Point": "图的强连通分量", "Question": "用C++实现以下功能\n(1)输入一个无向图，打印出它的所有连通分量。如\n下示例，\n连通分量有2个，分别为{1,2,4,5}, {3,6}\n(2)输入一个有向图，打印出它的所有强连通分量。\n如下示例，\n强连通分量有3个，分别为{1}, {4}, {2,5,3,6}\n\n", "Tag": "算法分析"}
{"Answer": "只需要调用遍历过程一次必须调用（）次深度优先搜索遍历的算法注意这是在考语文-=-=-=-=-你知道搜索算法是个递归吧问你这个函数一共递归多少次不是问你主函数调用这个函数几次", "Konwledge_Point": "图的强连通分量", "Question": "要按照深度优先搜索的方法访问所有顶点，则必须调用（）次深度优先搜索遍历的算法。\n若一个图中包含有k个连通分量，若要按照深度优先搜索的方法访问所有顶点，则必须调用（）次深度优先搜索遍历的算法。\nA. kB. 1C. k-1D. k+1\n这个怎么是k次，不是连通图的话只需要调用遍历过程一次，就可以遍历图中所有的顶点了吗", "Tag": "算法分析"}
{"Answer": "基于Monster 组和GPT的调写：改了改：\nint visit[10000]={0};\n\nint c(LGraph Graph)\n{\n    visit[0]=1;\n    Ptr t=Graph->G[0].FirstEdge;\n    Ptr queue[10000];\n    int front=0,rear=0;\n    queue[rear++]=t;\n    int cnt=0;\n\n    while(front<rear){\n        Ptr temp=queue[front++];\n        while(temp){\n            if(!visit[temp->adjV]){\n                queue[rear++]=Graph->G[temp->adjV].FirstEdge;\n                visit[temp->adjV]=1;\n            }\n            temp=temp->next;\n        }\n    }\n\n    cnt++;\n    for(int i=0;i<Graph->Nv;i++){\n        if(!visit[i]){\n            Ptr t=Graph->G[i].FirstEdge;\n            front=0,rear=0;\n            queue[rear++]=t;\n            cnt++;\n            while(front<rear){\n                Ptr temp=queue[front++];\n                while(temp){\n                    if(!visit[temp->adjV]){\n                        queue[rear++]=Graph->G[temp->adjV].FirstEdge;\n                        visit[temp->adjV]=1;\n                    }\n                    temp=temp->next;\n                }\n            }\n        }\n    }\n    return cnt;\n}\n\n\n", "Konwledge_Point": "图的强连通分量", "Question": "显示的是段错误，问题详情如下\n\nint visit[\n10000\n]={\n0\n};\nint c(LGraph Graph)\n{\n    visit[\n0\n]=\n1\n;\n    P\ntr\n t=Graph->\nG[\n0\n].FirstEdge;\n    Ptr queue[\n10000\n];\n    int front=\n0\n,rear=\n0\n;\n    queue[rear++]=t;\n    int cnt=\n0\n;\n    \nwhile\n(front\nnext){\n            \nqueue\n[rear++]=temp->\nnext;\n            \nvisit\n[temp->\nnext\n->\nadjV]=\n1\n;\n            \ntemp\n=temp->\nnext;\n        }\n    }\n    cnt++;\n    \nfor\n(int i=0;i\nNv;i++){\n        \nif\n(visit[i]==\n0\n){\n            P\ntr\n t=Graph->\nG[i].FirstEdge;\n            Ptr queue[\n10000\n];\n            int front=\n0\n,rear=\n0\n;\n            queue[rear++]=t;\n            int cnt=\n0\n;\n            \nwhile\n(front\nnext){\n                    \nqueue\n[rear++]=temp->\nnext;\n                    \nvisit\n[temp->\nnext\n->\nadjV]=\n1\n;\n                    \ntemp\n=temp->\nnext;\n                }\n            }\n            cnt++;\n        }\n    }\n    return cnt;\n}\n\n\n\n因为我现在看不了原题了所以大概回忆着写了出来，就是让求有几个强连通分量，然后数据结构是邻接表，我的思路是首先从序号为0的结点开始进行广度优先遍历，也就是层序遍历，把序号0所在的强连通分量都遍历后，我再检查所有节点中谁没被遍历过，即visit[i]==0;\n然后用和上面同样的方法进行遍历\n但是总是不对，显示为段错误，到底怎么回事呢？", "Tag": "算法分析"}
