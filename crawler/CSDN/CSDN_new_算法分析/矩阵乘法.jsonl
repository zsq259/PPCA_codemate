{"Answer": "尝试一下这个\n[sigmak^2*(2^(re)-1)-p13,zeros(1,M_irs);\n    zeros(M_irs,1),p13*epsilong_e^(-2)*eye(M_irs)]+...\n    (S3*theta0*h_BI)*((2^(re)-1)*Zx-W1x)*((S3*theta0*h_BI)');\n\n\n", "Konwledge_Point": "矩阵乘法", "Question": "matlab用于矩阵乘法的维度不正确\n问题遇到的现象和发生背景\n\n\n编写代码时，提示用于矩阵乘法的维度不正确，但是我检查了矩阵的维度，保第一个矩阵中的列数与第二个矩阵中的行数匹配，不知道问题出在了哪里\n\n\n问题相关代码，请勿粘贴截图\n\n\n\n\n\n\n%% step2:优化预编码向量Wx和人工噪声协方差Zx\nS3=[h_I3.',eye(M_irs)].';     %转置是.',共轭转置是'\nS4=[h_I4.',eye(M_irs)].';\n%% 对于任何可行点W1t,W2t,Zxt\nM1=h_BI'*theta0'*(h_I1'*h_I1)*theta0*h_BI;\nM2=h_BI'*theta0'*(h_I2'*h_I2)*theta0*h_BI;\nW1t=eye(Nt,Nt);\nW2t=eye(Nt,Nt);\nZxt=eye(Nt,Nt);\ncvx_begin sdp\n    variables W1x(Nt,Nt) W2x(Nt,Nt) \n    variable Zx(Nt,Nt) complex semidefinite\n    variable p13  nonnegative\n    variable p23  nonnegative\n    variable p14  nonnegative\n    variable p24  nonnegative\nobj=-\nlog\n(\nreal\n(\ntrace\n(Zx*M1))+sigmak^2+\nreal\n(\ntrace\n(M1*W1x))+\nreal\n(\ntrace\n(M1*W2x)))-\nlog\n(\nreal\n(\ntrace\n(Zx*M2))+sigmak^2+\nreal\n(\ntrace\n(M2*W1x)))+\nreal\n(\ntrace\n(M2*W2x))-\nreal\n(\ntrace\n((-(1/\nlog\n(2))*(M1/\nreal\n((\ntrace\n(Zxt*M1))+sigmak^2+\nreal\n(\ntrace\n(M1*W2t)))+M2/(\nreal\n(\ntrace\n(Zxt*M2))+sigmak^2+\nreal\n(\ntrace\n(M2*W1t)))))'*Zx))-\nreal\n(\ntrace\n((-(1/\nlog\n(2))*M2/(\nreal\n(\ntrace\n(Zxt*M2))+sigmak^2+\nreal\n(\ntrace\n(M2*W1t))))'*W1x))-\nreal\n(\ntrace\n((-(1/\nlog\n(2))*M1/\nreal\n((\ntrace\n(Zxt*M1))+sigmak^2+\nreal\n(\ntrace\n(M1*W2t))))'*W2x))-re;\nminimize obj\n    subject to \n    \ntrace\n(W1x)+\ntrace\n(Zx)<=P;\n    \ntrace\n(W2x)+\ntrace\n(Zx)<=P;\n[sigmak^2*(2^(re)-1)-p13,zeros(1,M_irs);zeros(M_irs,1),p13*epsilong_e^(-2)*eye(M_irs)]+S3*theta0*h_BI*((2^(re)-1)*Zx-W1x)*h_BI'*theta0'*S3'>=0;\n%矩阵维度：前面是(M_irs+1)*(M_irs+1)的矩阵；S3是(M_irs+1)*(M_irs)；theta0是(M_irs)*(M_irs)；h_BI是(M_irs)*16；Zx,W1x是16*16；\nZx>=0;\nW1x>=0;\nW2x>=0;\ncvx_end\n\n\n\n\n\n运行结果及报错内容\n\n\n提示这句：[sigmak^2*(2^(re)-1)-p13,zeros(1,M_irs);zeros(M_irs,1),p13\nepsilong_e^(-2)\neye(M_irs)]+S3\ntheta0\nh_BI*((2^(re)-1)*Zx-W1x)*h_BI'*theta0'\nS3'>=0;\n错误使用  *\n用于矩阵乘法的维度不正确。请检查并确保第一个矩阵中的列数与第二个矩阵中的行数匹配。要执行按元素相乘，请使用 '.\n'。\n\n\n我的解答思路和尝试过的方法\n\n\n这是工作区的值\n\n\n\n\n我想要达到的结果\n\n\n不报错", "Tag": "算法分析"}
{"Answer": "提示的很明显啊，打断点找出来这两个矩阵，改成维度一样的不就行了。", "Konwledge_Point": "矩阵乘法", "Question": "代码运行出错，提示用于矩阵乘法的维度不正确。请检查并确保第一个矩阵中的列数与第二个矩阵中的行数匹配，然后不知道该怎么解决了\n问题遇到的现象和发生背景\n\n\n\n\n问题相关代码，请勿粘贴截图\n\n\nclear all;clc;close all;\nx_min = -1; % 输入最小值,\nx_max = 1/4; % 输入最大值,\n\n\nalpha = \n@(x,t) \nt.\n(2 + cos(2\npi\nx));\nbeta = \n@(x,t) \nt.\n(1 + cos(2\npi\nx));\ngamma = \n@(x,t) \nt.\n(2 + cos(4\npi*x));\n\n\nUexact = \n@(x,t) \nt.\nsin(2\npi\nx);\nUexact_x = \n@(x,t) \nt.\n2\npi\ncos(2\npi\nx);\nUexact_t = \n@(x,t) \nsin(2\npi\nx);\nUexact_xx = \n@(x,t) \n-t.\n4\npi^2\nsin(2\npi*x);\ng1 = \n@(t) \nUexact(x_min,t);\ng2 = \n@(t) \nUexact(x_max,t);\nfx = \n@(x,t) \nUexact_t(x,t) - alpha(x,t).*Uexact_xx(x,t) - beta(x,t)*Uexact_x(x,t) - gamma(x,t).*Uexact(x,t);\n\n\nT = 1;\nCons= 0.2;\nArrayN = [40 80 160 320 640];   % 对于dt的收敛;\n% AttayN = [10 20 40 80 160];   % 对于dx的收敛使用;\nArrayM = zeros(1,length(ArrayN));\ncounter = 1;\nfor N=ArrayN\n N = 40;\n M = ceil(T/(Cons*(x_max-x_min)^2)*N^2);\n % N=80;\n % ArrayM(counter)=M;\nh = (x_max-x_min)/(N-1);   % 步长h\n\n\nx = zeros(1,N);   % 中间点\nfor i = 1:N\n    x(i)=x_min+(i-1)*h;\nend\n\n\ndt = T/(M-1);   % 步长h\nt = zeros(1,M);   % 中间点\nfor n = 1:M\n    t(n)=(n-1)*dt;\nend\n\n\nu1 = Uexact(x(2:end-1),0).';\n\n\nA = zeros(N-2,N-2);   % 定义矩阵A\nA(1,1)=-2;\nA(1,2)=1;\nA(N-2,N-2)=-2;\nA(N-2,N-3)=1;\nfor j = 2:N-3\n    A(j,j-1)=1;\n    A(j,j)=-2;\n    A(j,j+1)=1;\nend\n\n\nfor n = 2:M\n    tn=(n-1)\ndt+dt;\n    % alpha\nu_xx\n    AlphaMatrix = diag(alpha(x(2:end-1),tn));\n    Atilda = AlphaMatrix*A;\n\n\n% beta*u_x\nBetaMatrix = diag(beta(x(\n2\n:\nend\n-\n1\n),tn));\nC=zeros(N-\n2\n,N-\n2\n);\n\nC(1,1)\n=\n0\n;\n\nC(1,2)\n=\n1\n;\n\nC(N-2,N-2)\n=\n0\n;\n\nC(N-2,N-3)\n=-\n1\n;\nBetaMatrix = diag(beta(x(\n2\n:\nend\n-\n1\n),tn));\n\nfor\n j = \n2\n:N-\n3\n\n    \nC(\nj\n,\nj\n+1)\n=\n1\n;\n    \nC(\nj\n,\nj\n)\n=\n0\n;\n    \nC(\nj\n,\nj\n-1)\n=-\n1\n;\n\nend\n\n\nCtilda = BetaMatrix*C;\n\n% Gamma*u\nGammaMatrix = diag(gamma(x(\n2\n:\nend\n-\n1\n),tn));\nD=eye(N-\n2\n,N-\n2\n);\nDtilda = GammaMatrix*D;\n\n% Implement BCs\nb = zeros(N-\n2\n,\n1\n);\nb(\n1\n) = (dt/h^\n2\n*alpha(x(\n2\n),tn) - beta(x(\n2\n),tn)*dt/(\n2\n*h))*g1(tn);\nb(\nend\n) = (dt/h^\n2\n*alpha(x(\nend\n-\n1\n),tn) + beta(x(\nend\n-\n1\n),tn)*dt/(\n2\n*h))*g2(tn);\nL=D - dt/h^\n2\n*Atilda - dt*Dtilda - dt/(\n2\n*h)*Ctilda;\nu2 = L\\(u1 + dt*fx(x(\n2\n:\nend\n-\n1\n),tn) + b);\n\nu1=u2;\n \nError(\ncounter\n,\nn\n-1)\n = max(max(abs(\nUexact(\nx\n(2:\nend\n-1)\n,tn).'-u2)));\n\n\n\nend\n\n\nplot(x(2:end-1),u2,'bo-',x(2:end-1),Uexact(x(2:end-1),T),'r*-');\nError2(counter) = max(abs(Error(counter,:)));\ncounter = counter + 1;\nend\nloglog(2./ArrayN,Error, 'o--',2./ArrayN,(2./ArrayN).^2,'*--');\nxlabel('h')\nylabel('Error')\nlegend('Exact','Numerical');\ngrid on;\n\n\ntitle('Stability of Implicit Euler method with respect to constant C','interpreter','latex')\nloglog((x_max-x_min)./ArrayN,Error2, 'o--',(x_max-x_min)./ArrayN,((x_max-x_min)./ArrayN).^2,'*−−');\nxlabel('$dx$','interpreter','latex');\nylabel('Error','interpreter','latex');\ntitle('Convergence with respect to $dx$','interpreter','latex');\nlegend('$|u(x_i,T)-u_{i,M}|_{\\infty}$','$O(dx^2)$','interpreter','latex');\nset(gca,'fontsize',13);\ngrid on;\n\n\nfigure;\nloglog(T./ArrayM,Error2,'o--',T./ArrayM,(T./ArrayM),'*--');\nxlabel('$dt$','interpreter','latex');\nylabel('Error','interpreter','latex');\ntitle('Convergence with respect to $dt$','interpreter','latex');\nlegend('$|u(x_i,T)-u_{i,M}|_{\\infty}$','$O(dt)$','interpreter','latex');\nset(gca,'fontsize',13);\ngrid on;\n\n\n运行结果及报错内容\n\n\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果", "Tag": "算法分析"}
{"Answer": "用点乘", "Konwledge_Point": "矩阵乘法", "Question": "matlab的矩阵乘法\n这一段的代码是：\nfor t=History:History+IRper\npath(t,:)=gy(t,:)\nb+ ebs(t,:);\n然后我用断点，在这一段前，path是一个127\n4的矩阵，gy是一个125\n9的矩阵，b是一个9\n4的矩阵，ebs是125\n4的矩阵。\n为什么运行后就报错，错误使用  *\n用于矩阵乘法的维度不正确。请检查并确保第一个矩阵中的列数与第二个矩阵中的行数匹配。要执行按元素相乘，请使用 '.\n'。", "Tag": "算法分析"}
{"Answer": "#include<stdio.h>\nint a[105][105],b[105][105],c[105][105];\nint main() {\n    int n,m,k;\n    scanf(\"%d%d%d\",&n,&m,&k);\n    for(int i=0; i<n; i++) {\n        for(int j=0; j<m; j++) {\n            scanf(\"%d\",&a[i][j]);\n        }\n    }\n    for(int i=0; i<m; i++) {\n        for(int j=0; j<k; j++) {\n            scanf(\"%d\",&b[i][j]);\n        }\n    }\n    for(int i=0; i<n; i++) {\n        for(int j=0; j<k; j++) {\n            c[i][j] = 0;\n            for(int x=0; x<m; x++) {\n                c[i][j] += a[i][x]*b[x][j];\n            }\n            printf(\"%d \",c[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n", "Konwledge_Point": "矩阵乘法", "Question": "使用c语言来求矩阵乘法\n，编写程序，实现矩阵乘法，读入，m，n和，w，3个正数，一个m\nn的数组和一个，n\nw的数组，输出一个m*w的数组。", "Tag": "算法分析"}
{"Answer": "\n<?php\n\n\n\n$a = Array('0' => Array('0' => 1,'1' => 2),'1' => Array('0' => 4,'1' => 5));\n\n\n$b = Array('0' => Array('0' => 7,'1' => 5),'1' => Array('0' => 3,'1' => 2));\n\n$sumArray = array();\n\n$c = array();\n\nfor($i=0;$i<2;$i++) {\n for($j=0;$j<2;$j++) \n { \n    $c[$i][$j]=0; \n    for($k=0;$k<2;$k++) \n        { $c[$i][$j]=$c[$i][$j]+($a[$i][$k]*$b[$k][$j]); \n    } \n} \n} \n\n\necho \"<pre/>\";\nprint_r($c);\n?>\n\n", "Konwledge_Point": "矩阵乘法", "Question": "我试图在PHP中制作矩阵乘法代码，但不是矩阵乘法，它只是简单的乘法与行和列\n\n\n\nI want to do matrix multiplication using array in PHP I have trying to do same but instead of matrix multiplication it just happening Simple multiplication as per output please help me to resolve it.\n\n\n\nHere is my code:\n\n\n\n Array('0' => 1,'1' => 2),'1' => Array('0' => 4,'1' => 5));\n\n$a2 = Array('0' => Array('0' => 7,'1' => 5),'1' => Array('0' => 3,'1' => 2));\n\n$sumArray = array();\n\n$result = array();\nfor($i=0; $i<=1; $i++)\n{\n    for($j=0; $j<=1; $j++)\n    {\n        $result[$i][$j] = $a1[$i][$j] * $a2[$i][$j];\n    }\n}\necho \"\";\nprint_r($result);\n?>\n\n\n\n\nOutput:\n\n\n\narray image\n\n    ", "Tag": "算法分析"}
{"Answer": "终于找到问题了，创建线程时的传参出错了，线程还没来得及保存传来的参数，参数就自增了（传递的是指针）    \r\n修改后的代码如下  \r\n```\r\n#include \r\n#include \r\n#include \r\n#include \r\n#define N 4\r\nint a[N][N], b[N][N],c[N][N],each;\r\n\r\nvoid *sum(void *vargp);\r\n\r\nint main(int argc, char **argv)\r\n{\r\n\tpthread_t tid[N];\r\n\tint i,j,begin[N], nthreads,temp[N][N];\r\n\r\n\t/*Get input arguments */\r\n\tif (argc != 2) {\r\n\t\tprintf(\"Usage: %s \\n\", argv[0]);\r\n\t\texit(0);\r\n\t}\r\n\tnthreads = atoi(argv[1]);\t//线程数\r\n\r\n\t//生成0-100随机数、初始化矩阵a，b\r\n\tsrand((int)time(NULL));\t//生成时间种子\r\n\tfor (i = 0; i<N; i++)\r\n\t\tfor (j = 0; j<N; j++)\r\n\t\t{\r\n\t\t\ta[i][j] = ((rand() % 10) + 1);\r\n\t\t\tb[i][j] = ((rand() % 10) + 1);\r\n\t\t\tc[i][j] = 0;\r\n\t\t}\r\n\r\n\teach = N / nthreads;\t//每个线程处理each行\t\r\n\t\r\n\tfor (i = 0; i < nthreads; i++){\r\n\t\tbegin[i]=i*each;\r\n\t}\r\n\r\n\tfor (i = 0; i < nthreads; i++) {\r\n\t\tpthread_create(&tid[i], NULL, sum, (void*)&begin[i]);\r\n\t}\r\n\r\n\tfor (i = 0; i < nthreads; i++)\r\n\t\tpthread_join(tid[i], NULL);\r\n\r\n\t//输出a矩阵\r\n\tfor (i = 0; i < N; i++)\r\n\t{\r\n\t\tfor (j = 0; j < N; j++)\r\n\t\t{\r\n\t\t\tprintf(\"%5d\", a[i][j]);\r\n\t\t}\r\n\t\tprintf(\"\\n\");\r\n\t}\r\n\tprintf(\"\\n\");\r\n\r\n\t//输出b矩阵\r\n\tfor (i = 0; i < N; i++)\r\n\t{\r\n\t\tfor (j = 0; j < N; j++)\r\n\t\t{\r\n\t\t\tprintf(\"%5d\", b[i][j]);\r\n\t\t}\r\n\t\tprintf(\"\\n\");\r\n\t}\r\n\tprintf(\"\\n\");\r\n\t\r\n\t//输出c矩阵\r\n\tfor (i = 0; i < N; i++)\r\n\t{\r\n\t\tfor (j = 0; j < N; j++)\r\n\t\t{\r\n\t\t\tprintf(\"%5d\", c[i][j]);\r\n\t\t}\r\n\t\tprintf(\"\\n\");\r\n\t}\r\n\r\n\texit(0);\r\n}\r\n\r\nvoid *sum(void* argp)\r\n{\r\n\tint begin = *((int*)argp);\r\n\tint end = begin + each\t;\r\n\tint i,j,m;\r\n\r\n\tfor (i = begin; i < end; i++)\r\n\t\tfor (j = 0; j < N; j++)\r\n\t\t\tfor(m=0;m<N;m++)\r\n\t\t\t{ \r\n\t\t\t\tc[i][j] += a[i][m] * b[m][j];\r\n\t\t\t}\r\n\treturn NULL;\r\n}\r\n```\r\n![图片说明](https://img-ask.csdn.net/upload/201905/14/1557834947_626366.png)", "Konwledge_Point": "矩阵乘法", "Question": "N阶矩阵乘法的并行线程化，创建k个线程，分别计算N/k行，存到同一数组，出错求助（Linux多线程编程）\nN阶矩阵相乘并线线程化\n\n比如8阶矩阵相乘，创建2个线程，则一个线程算1-4行，另一个线程算5-8行，然后存到同一个数组里。\n\n每次运行的结果有些行数全为0，请问是线程不安全吗？可是两个线程操作的是同一数组的不同行数，按道理是线程安全啊？\n\nLinux系统运行，编译命令：gcc -o 文件名 文件名.c -lpthread\n\n运行命令：./文件名 线程数\n\n代码如下：\n\n\n\n#include \n#include \n#include \n#include \n#define N 8\nint a[N][N], b[N][N],c[N][N],each;\n\nvoid *sum(void *vargp);\n\nint main(int argc, char **argv)\n{\n    pthread_t tid[N];\n    int i,j,begin=0, nthreads,temp[N][N];\n\n    /*Get input arguments */\n    if (argc != 2) {\n        printf(\"Usage: %s \\n\", argv[0]);\n        exit(0);\n    }\n    nthreads = atoi(argv[1]);   //线程数\n\n    //生成0-100随机数、初始化矩阵a，b\n    srand((int)time(NULL)); //生成时间种子\n    for (i = 0; i<N; i++)\n        for (j = 0; j<N; j++)\n        {\n            a[i][j] = ((rand() % 10) + 1);\n            b[i][j] = ((rand() % 10) + 1);\n            c[i][j] = 0;\n        }\n\n    each = N / nthreads;    //每个线程处理each行\n\n    for (i = 0; i < nthreads; i++) {\n        pthread_create(&tid[i], NULL, sum, (void*)&begin);\n        begin += each;\n    }\n    for (i = 0; i < nthreads; i++)\n        pthread_join(tid[i], NULL);\n\n    //输出a矩阵\n    for (i = 0; i < N; i++)\n    {\n        for (j = 0; j < N; j++)\n        {\n            printf(\"%5d\", a[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n\n    //输出b矩阵\n    for (i = 0; i < N; i++)\n    {\n        for (j = 0; j < N; j++)\n        {\n            printf(\"%5d\", b[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n\n    //输出c矩阵\n    for (i = 0; i < N; i++)\n    {\n        for (j = 0; j < N; j++)\n        {\n            printf(\"%5d\", c[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    exit(0);\n}\n\nvoid *sum(void* argp)\n{\n    int begin = *((int*)argp);\n    int end = begin + each  ;\n    int i,j,m;\n\n    for (i = begin; i < end; i++)\n        for (j = 0; j < N; j++)\n            for(m=0;m<N;m++)\n            { \n                c[i][j] += a[i][m] * b[m][j];\n            }\n    return NULL;\n}\n\n\n\n", "Tag": "算法分析"}
{"Answer": "#include<stdio.h>\n#include<stdlib.h>\n#define M 100\n\nint main(void)\n{\n    int i,j,k,matrix1[M][M],matrix2[M][M],row1=3,col1=4,row2=4,col2=3,matrix[M][M];\n   \n    printf(\"请输入第一个3X4矩阵:\\n\");\n    for(i=0;i<row1;i++){\n        for(j=0;j<col1;j++){\n            scanf(\"%d\",&matrix1[i][j]);\n        }\n    }\n   printf(\"请输入第二个4X3矩阵:\\n\");\n    for(i=0;i<row2;i++){\n        for(j=0;j<col2;j++){\n            scanf(\"%d\",&matrix2[i][j]);\n        }\n    }\n    \n    for(i=0;i<row1;i++){\n        for(j=0;j<col2;j++){\n            matrix[i][j]=0;\n        }\n    }\n\n    for(i=0;i<row1;i++){\n        for(j=0;j<col2;j++){\n            for(k=0;k<col1;k++){\n                matrix[i][j]=matrix[i][j]+matrix1[i][k]*matrix2[k][j];\n            }\n        }\n    }\n\n    for(i=0;i<row1;i++){\n        for(j=0;j<col2;j++){\n            printf(\"%d \",matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n", "Konwledge_Point": "矩阵乘法", "Question": "如何用C语言实现该矩阵乘法\n希望能得到一些指教，学不太明白怎么把四列的矩阵乘成三列的，希望能给出代码答复。", "Tag": "算法分析"}
{"Answer": "找找模板封装的例子看看，只是用typename T来代替数据类型而已。\n\n参考如下：\n#include <iostream>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix\n{\nprivate:\n    int m_m,m_n; //m*n\n    T** m_data;\npublic:\n    Matrix();\n    Matrix(int m,int n,T** data);//初始化时赋值\n    \n    //从键盘读入\n    void setData(int m,int n);\n    void show();\n    Matrix operator*(const Matrix<T> &b);\n    Matrix operator=(const Matrix<T> &b);\n};\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::operator=(const Matrix<T> &b)\n{\n    Matrix<T> a(b.m_m,b.m_n,b.m_data);\n    return a;\n}\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::operator*(const Matrix<T> &b)\n{\n    int m = this->m_m;\n    int n = b.m_n;\n    //无法相乘的情况\n    if(this->m_n != b.m_m)\n        return Matrix();\n\n    T** data = new T*[m];\n        \n    //计算\n    for (int i=0;i<m;i++)\n    {\n        data[i] = new T[n];\n        for (int j=0;j<n;j++)\n        {\n            data[i][j] = 0;\n            for(int k = 0;k<this->m_n;k++)\n                data[i][j] += this->m_data[i][k] * b.m_data[k][j];\n        }\n    }\n\n    Matrix<T> cc(m,n,data);\n    //释放空间\n    for(int i=0;i<m;i++)\n        delete[] data[i];\n    delete[] data;\n    data = 0;\n    return cc;\n}\n\ntemplate <typename T>\nvoid Matrix<T>::show()\n{\n    if(m_data)\n    {\n        for (int i =0;i<m_m;i++)\n        {\n            for(int j=0;j<m_n;j++)\n                cout << m_data[i][j] <<\" \";\n            cout <<endl;\n        }\n    }\n}\n\n\ntemplate <typename T>\nvoid Matrix<T>::setData(int m,int n)\n{\n    m_m =m;\n    m_n = n;\n    if(m_data)\n    {\n        for(int i=0;i<m_m;i++)\n            delete[] m_data[i];\n        delete[] m_data;\n        m_data = 0;\n    }\n    cout <<\"请输入\"<<m<<\"*\"<<n<<\"的矩阵：\"<<endl;\n    m_data = new T*[m];\n    for (int i = 0;i<m;i++)\n    {\n        m_data[i] = new T[n];\n        for(int j=0;j<n;j++)\n            cin >>m_data[i][j];\n    }\n}\n\n\ntemplate <typename T>\nMatrix<T>::Matrix()\n{\n    m_m = 0;\n    m_n = 0;\n    m_data = 0;\n}\n\ntemplate <typename T>\nMatrix<T>::Matrix(int m,int n,T** data)\n{\n    m_m = m;\n    m_n = n;\n    m_data = new T*[m];\n    for (int i = 0;i<m;i++)\n    {\n        m_data[i] = new T[n];\n        for(int j=0;j<n;j++)\n            m_data[i][j] = data[i][j];\n    }\n}\n\n\nint main()\n{\n    int m,n;\n    \n    cout <<\"请输入第一个矩阵的m和n:\";\n    cin >>m>>n;\n    cout << \"请输入\"<<m<<\"*\"<<n<<\"的整数矩阵：\"<<endl;\n    int** data = new int*[m];\n    for(int i = 0;i<m;i++)\n    {\n        data[i] = new int[n];\n        for(int j=0;j<n;j++)\n            cin >> data[i][j];\n    }\n    Matrix<int> ma(m,n,data);\n\n    for (int i=0;i<m;i++)\n    {\n        delete[] data[i];\n        data[i]=0;\n    }\n    delete[] data;\n\n    //ma.show();\n    \n    //构建第二个矩阵\n    cout << \"请输入第二个矩阵的m和n：\";\n    cin >>m>>n;\n    cout << \"请输入\"<<m<<\"*\"<<n<<\"的整数矩阵：\"<<endl;\n    data = new int*[m];\n    for(int i = 0;i<m;i++)\n    {\n        data[i] = new int[n];\n        for(int j=0;j<n;j++)\n            cin >> data[i][j];\n    }\n    Matrix<int> mb(m,n,data);\n\n    for (int i=0;i<m;i++)\n    {\n        delete[] data[i];\n        data[i]=0;\n    }\n    delete[] data;\n\n    //mb.show();\n    \n    Matrix<int> c = ma*mb;\n    c.show();\n    return 0;\n\n}\n\n", "Konwledge_Point": "矩阵乘法", "Question": "c++矩阵乘法，要求用类封装\n关键在于他有很多要求，不在于乘法的实现，要用类来封装矩阵，还要用模板，初学者感觉困难，求思路，最好有代码，谢", "Tag": "算法分析"}
{"Answer": "\nI see two problems:\n\nYou have a classic closure problem in multiply with i and j.\nThere's no guarantee that matrix_c will be computed before you return it in multiply.\n\nThe first one is right here:\nfor i := 0; i < 3; i++ {\n    for j := 0; j < 3; j++ {\n        go func(){\n            matrix_c[i][j] = pmultiply(matrix_a,matrix_b,i,j);\n        }()\n    }   \n}\n\nThe anonymous function is keeping a reference to i and j not the actual values of i and j when you go func() { ... }() so when the goroutine executes, i and j could be any values between zero and three (inclusive). That's where the error you know about comes from: i or j is three because the goroutine is executing after the loops have completed. The easiest solution is to force i and j to be evaluated at the right time:\ngo func(i, j int) {\n    matrix_c[i][j] = pmultiply(matrix_a, matrix_b, i, j)\n}(i, j)\n\nThe second problem is that the goroutines won't necessarily all finish before you return matrix_c, there's not even a guarantee that any of of them will finish. The easiest solution would be to use a sync.WaitGroup to wait for them to finish. First you'd import \"sync\", then adjust the loops:\nvar wg sync.WaitGroup\nfor i := 0; i < 3; i++ {\n    for j := 0; j < 3; j++ {\n        wg.Add(1) // Tell the WaitGroup to wait for another thing.\n        go func(i, j int) {\n            matrix_c[i][j] = pmultiply(matrix_a, matrix_b, i, j)\n            wg.Done() // Tell it that we're done.\n        }(i, j)\n    }\n}\n\nand then wait before returning:\nwg.Wait()\nreturn matrix_c\n\n\nResponse to Comments: defer doesn't work like that, the specification only says:\n\nA \"defer\" statement invokes a function whose execution is deferred to the moment the surrounding function returns, either because the surrounding function executed a return statement, reached the end of its function body, or because the corresponding goroutine is panicking.\n\nThat's it, it arranges for something to be executed when execution leaves the surrounding function. defer doesn't have anything to do with waiting for threads/goroutines nor does it know anything about goroutines that the deferred function may create.\n", "Konwledge_Point": "矩阵乘法", "Question": "Go例程矩阵乘法错误\n\n\n\nI am multiplying matrix in parallel using go routines. I am getting index out of range, but when i run the same code sequential it works. (by sequential i mean commenting go line). I am using defer so i do not have to wait for my routines to end as it will be the last thing called\n\n\n\nError \n    D:\\0000>go run Ap.go\n    panic: runtime error: index out of range\n\n\n\ngoroutine 5 [running]:\nmain.pmultiply(0xc04206c000, 0x3, 0x3, 0xc04206c050, 0x3, 0x3, 0x1, 0x3, 0x0)\n        D:/0000/Ap.go:48 +0x95\nmain.multiply.func1(0xc04206c0a0, 0x3, 0x3, 0xc04200e090, 0xc04200e098, 0xc04206\nc000, 0x3, 0x3, 0xc04206c050, 0x3, ...)\n        D:/0000/Ap.go:64 +0x94\ncreated by main.multiply\n        D:/0000/Ap.go:63 +0x1d7\nexit status 2\n\n\n\n\nCODE\n\n\n\npackage main\n\nimport \"fmt\"\n\nfunc main(){\n\n    matrix_a := make([][]int,3);\n\n    for i:=0;i<len(matrix_a);i++{\n\n        matrix_a[i]=make([]int,3);\n\n    }\n\n\n    for i:=0;i<len(matrix_a);i++{\n\n        for j:=0;j<len(matrix_a[0]);j++{\n            matrix_a[i][j] = 2;\n        }\n    }\n\n    matrix_b := make([][]int,3);\n\n    for i:=0;i<len(matrix_b);i++{\n\n        matrix_b[i]=make([]int,3);\n\n    }\n\n\n    for i:=0;i<len(matrix_b);i++{\n\n        for j:=0;j<len(matrix_b[0]);j++{\n            matrix_b[i][j] = 2;\n        }\n    }\n\n    defer fmt.Println(multiply(matrix_a,matrix_b));\n\n}\n\nfunc pmultiply(matrix_a [][] int,matrix_b [][] int,row int,col int) int{\n\n    sum := 0;\n\n    for z:=0;z<len(matrix_a[0]);z++{\n        sum = sum + matrix_a[row][z] *  matrix_b[z][col];\n    }\n    return sum;\n}\n\nfunc multiply(matrix_a [][] int,matrix_b [][] int) ([][] int){\n\n    matrix_c := make([][]int,3);\n\n    for i:=0;i<len(matrix_c);i++{\n        matrix_c[i]=make([]int,3);\n    }\n\n    for i := 0; i < 3; i++ {\n        for j := 0; j < 3; j++ {\n            go func(){\n                matrix_c[i][j] = pmultiply(matrix_a,matrix_b,i,j);\n            }()\n        }   \n    }\n\n    return matrix_c;\n}\n\n\n    ", "Tag": "算法分析"}
{"Answer": "把 ^改成 .^ 试一下", "Konwledge_Point": "矩阵乘法", "Question": "matlab的矩阵乘法的维度不正确，怎么解决呢。\nt=0:0.1:10\ny=(12\nt^2+1200\nt+1250)/(50+t)\nplot(t,y)\ngrid minor（这是代码）能帮我看看问题出在哪儿吗？", "Tag": "算法分析"}
{"Answer": "4×4的矩阵，数组大小应该定义为A[4][4]吧", "Konwledge_Point": "矩阵乘法", "Question": "用C语言实现两个4x4矩阵相乘，系统没有报错，但是结果是错的······\n\n                                                                                                                  这部分想要实现的功能是：在已经输入的一个二维数组中找到最大值和最小值并且输出，还要写出最大值和最小值所在的行和列数。\n\n问题：系统编译后没有报错，但是最后现实的结果却是错的，例如：\n\n这部分要实现的功能是：分别求出这个矩阵的两条对角线之和。问题：但是每次求和是总有一条是错的·······\n\n\n\n实在是不知道哪里错了，求各路大神帮帮忙。。。。\n\n\n\n有尝试过单步调试，但是它好像直接就跳过子函数了。。。。", "Tag": "算法分析"}
{"Answer": "这个好弄，用符号计算就行\nsyms a b c\nA = [1,1,0; 5,6,7; 2,1,5];\nB = [a,b,c; 1,2,3; 4,5,6];\nA.*B\n\n结果\nans =\n \n[ a,  b,  0]\n[ 5, 12, 21]\n[ 8,  5, 30]\n", "Konwledge_Point": "矩阵乘法", "Question": "MATLAB带未知量矩阵运算\n如图，我想带未知数进行矩阵运算，不需要求解具体值，怎么操作。", "Tag": "算法分析"}
{"Answer": "这个就是用到矩阵计算。根据图中的方法进行矩阵计算", "Konwledge_Point": "矩阵乘法", "Question": "AES列混淆中的类矩阵乘法运算\nAES加密过程中的在2^n上的类矩阵乘法运算\n这样的运算结果是怎么出现的呢，如果展开成多项式进行运算的话，模的那个多项式又是谁呢，算出来不对\n还是有其他的计算方式吗，不太明白", "Tag": "算法分析"}
{"Answer": "改成\nfor (i = 0; i < n; i++)\n{\n    for (j = 0; j < k; j++)\n    {\n        cout << ab[i][j] << \" \";\n    }\n    cout << endl;\n}\n", "Konwledge_Point": "矩阵乘法", "Question": "为什么输出的不是一个矩阵啊？（矩阵乘法C++）\n为什么输出的不是一个矩阵啊？（矩阵乘法C++）\n\n\n\n\n#include\nusing namespace std;\n\n\nint main(){\n    int n,m,k;\n    int i,j,ii;\n\n\nint a[\n100\n][\n100\n];\nint b[\n100\n][\n100\n];\nint ab[\n100\n][\n100\n];\n\ncout << \n\"请输入矩阵a的行数、列数以及b的列数:\"\n << endl;\ncin >> n >> m >> k;\n\ncout << \n\"请输入矩阵a:\"\n << endl;\nfor( i = \n0\n;i < n;i++)\nfor( j = \n0\n;j < m;j++){\n    cin >> a[i][j];\n}\n\ncout << \n\"请输入矩阵b:\"\n << endl;\nfor( i = \n0\n;i < m;i++)\nfor( j = \n0\n;j < k;j++){\n    cin >> b[i][j];\n}\n\nfor( i = \n0\n;i < n;i++){\n    for( j = \n0\n;j < k;j++){\n        ab[i][j] = \n0\n;\n        for( ii = \n0\n;ii < m;ii++){\n            ab[i][j] = ab[i][j]+a[i][ii]*b[ii][j];\n        }\n    }\n}\n\ncout << \n\"矩阵a和b的乘积为:\"\n << endl;\nfor( i = \n0\n;i < n;i++){\n    for( j = \n0\n;j < k;j++){\n        cout << ab[i][j] << endl;\n    }\n}\n\nsystem(\n\"pause\"\n);\nreturn \n0\n;\n\n\n\n}", "Tag": "算法分析"}
{"Answer": "np包的矩阵相乘有两种你需要逐个分清，dot和multiply。如果是矩阵的相乘的话需要检查两个矩阵的长和宽是否在每一次的迭代中都符合要求，同时也要避免矩阵中出现None值", "Konwledge_Point": "矩阵乘法", "Question": "numpy中矩阵无法相乘\n在使用numpy和sklearn自主实现逻辑回归的过程中，矩阵无法相乘\n\n\n\n```python\nimport sys\nimport pandas \nas\n pd\nimport numpy \nas\n np\nimport matplotlib.pyplot \nas\n plt\nfrom sklearn.datasets import load_breast_cancer\ndata = load_breast_cancer(return_X_y=True)\nX = np.array(data[0])\ny = np.array(data[1])\n\ndef sigmod(x):\n    \nreturn\n 1/(1+pow(np.\ne\n,(-x)))\n\ndef Logistic_Regression(feature_data,target_data,learning_rate,account):\n    \nm\n = feature_data.shape[0]\n    feature_data = np.hstack((np.full((\nm\n,1),1),feature_data))\n    \nm\n,\nn\n = feature_data.shape\n    para = np.random.\nuniform\n(-1,1,\nn\n).\nreshape\n(\nn\n,1) # \nn\n*1\n    para = np.\nmat\n(para)\n    feature_data = np.\nmat\n(feature_data)    # \nm\n*\nn\n\n    target_data = np.\nmat\n(target_data)\n    # =========问题代码，两矩阵阵无法相乘？？？？============#\n    \nd\n = pd.DataFrame(np.array(feature_data))\n    \nprint\n(\nd\n.\ndescribe\n())\n    \nprint\n(\ntype\n(feature_data), \ntype\n(para))\n    \nprint\n(feature_data.shape, para.shape)\n    \nprint\n(feature_data @ para)\n\n    \nError\n = (-1/\nm\n)*np.\nsum\n(np.multiply(target_data,np.\nlog\n(sigmod(feature_data @ para))) +\n                    np.multiply(1-target_data,np.\nlog\n(1-sigmod(feature_data @ para))))\n    \ncount\n = 1\n    error_list = [\nError\n]\n\n    \nwhile\n True:\n        grad_vector = (1/\nm\n) * [feature_data.T @ (sigmod(feature_data @ para) - target_data)]\n        para = para - learning_rate * grad_vector\n        \nError\n = (-1 / \nm\n) * np.\nsum\n(np.multiply(target_data, np.\nlog\n(sigmod(feature_data @ para))) +\n                                np.multiply(1 - target_data, np.\nlog\n(1 - sigmod(feature_data @ para))))\n        error_list.\nappend\n(\nError\n)\n        \ncount\n = \ncount\n + 1\n        \nif\n \ncount\n == account:\n            \nbreak\n\n    \nreturn\n para,error_list\n\npara,\ne\n = Logistic_Regression(X,y,0.01,100)\nplt.\nplot\n(\ne\n)\nplt.show()\n\n\n\n\n\n\n\n###### 无显式报错，但程序中止\n\n###### 试过更改库版本，无果\n", "Tag": "算法分析"}
{"Answer": "https://www.cnblogs.com/peter-le/p/6055782.html", "Konwledge_Point": "矩阵乘法", "Question": "如何利用矩阵乘法快速幂求斐波那契数列前n项和？\n【矩阵乘法】Fibonacci 前 n 项和 (Standard IO)\n\n\n\n题目描述\n\n\n\n\n\n\n输入\n\n输入n,m\n\n\n\n输出\n\n\n\n\n\n\n样例输入\n\n\n\n5 1000\n\n\n\n\n样例输出\n\n\n\n12\n\n\n\n\nn很大，要log（n）的时间才能过", "Tag": "算法分析"}
{"Answer": "那个for是啥玩意，你确定编译成功了", "Konwledge_Point": "矩阵乘法", "Question": "C语言矩阵乘法编码为什么结果不对？\n问题遇到的现象和发生背景 矩阵乘法编码\n\n\n用代码块功能插入代码，请勿粘贴截图\n\n\n\n\n#include\n\n\n#include\n\n\n#include\n\n\n#include\n\n\n#define N 100\n\n\nint\n main()\n{\n    \nint\n m,n,k;\n    \nint\n i,j,p,sum;\n    \nint\n \nx\n[N][N]=\n{0}\n;\n    \nint\n \ny\n[N][N]=\n{0}\n;\n    \nint\n z[N][N]=\n{0}\n;\n    \nprintf\n(\n\"请输入第一个矩阵的行数和列数：\\n\"\n);\n    scanf(\n\"%d %d\"\n,&m,&k);\n    \nprintf\n(\n\"第一个矩阵为：\\n\"\n);\n    \nsrand\n((unsigned)\ntime\n(NULL));\n    \nfor\n (i=\n0\n;i<m;i++)\n    {\n        \nfor\n (j=\n0\n;j<k;j++)\n        {\n            \nx\n[i][k]=\nrand\n()%100;\n            \nprintf\n(\n\"%5d \"\n,\nx\n[i][k]);\n        }\n        \nprintf\n(\n\"\\n\"\n);\n    } \n    \n    \nprintf\n(\n\"请输入第二个矩阵的列数：\\n\"\n);\n    scanf(\n\"%d\"\n,&n);\n    \nprintf\n(\n\"第二个矩阵为：\\n\"\n);\n    \nfor\n (i=\n0\n;i<k;i++)\n    {\n        \nfor\n (j=\n0\n;j<n;j++)\n        {\n            \ny[k][j]\n=\nrand\n()%100;\n            \nprintf\n(\n\"%5d \"\n,\ny[k][j]\n);\n        }\n        \nprintf\n(\n\"\\n\"\n);\n    }\n    \n    \nprintf\n(\n\"这个两个矩阵的乘积为：\\n\"\n);\n    \nfor\n (i=\n0\n;i<m;i++)\n    {\n        \nfor\n(j=\n0\n;j<n;j++)\n        {\n            sum=\n0\n;\n            \nfor\n(p=\n0\n;p<k;p++)\n            {\n                sum+=\nx\n[i][p]*\ny[p][j]\n;        \n            } \n            z[i][j]=sum;\n            \nprintf\n(\n\"%5d \"\n,z[i][j]);\n        }\n        \nprintf\n(\n\"\\n\"\n);\n    }\n    \nreturn\n \n0\n;\n    \n}\n\n\n\n运行结果及报错内容 乘法结果出错\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果 正确运行", "Tag": "算法分析"}
{"Answer": "报什么错呢，输出3个值后面没了吗", "Konwledge_Point": "矩阵乘法", "Question": "用Python试图实现矩阵乘法出现了程序问题\n问题遇到的现象和发生背景\n\n\n我在写一个Python程序想实现矩阵乘法时遇到了一些问题。\n\n\nm\n,n,\nk\n =\nmap\n(\nint\n,\ninput\n().\nsplit\n(\n\" \"\n))\n\nprint\n(\nm\n,\nk\n)\nmatrix1 =[]\n\nfor\n i in \nrange\n(\nm\n):\n    matrix1.\nappend\n(\nlist\n(\nmap\n(\nint\n,\ninput\n().\nsplit\n(\n\" \"\n))))\nmatrix2 =[]\n\nfor\n i in \nrange\n(n):\n    matrix2.\nappend\n(\nlist\n(\nmap\n(\nint\n,(\ninput\n().\nsplit\n(\n\" \"\n)))))\nmatrix3 =[[\n0\n \nfor\n i in \nrange\n(\nm\n)]\nfor\n \nj\n in \nrange\n(\nk\n)]\n\nfor\n i in \nrange\n(\nm\n):\n    \nfor\n \nj\n in \nrange\n(\nk\n):\n        \nfor\n q in \nrange\n(n):\n            matrix3[i][\nj\n] += matrix1[i][q] * matrix2[q][\nj\n]\n        \nprint\n(matrix3[i][\nj\n],end=\n' '\n)\n    \nprint\n(\n'\\r'\n)\n\n\n\n\n遇到的现象和发生背景，请写出第一个错误信息\n\n\n用代码块功能插入代码，请勿粘贴截图。 不用代码块回答率下降 50%\n\n\n运行结果及详细报错内容\n\n\n输出结果时只到第三个就结束了\n3 5 7\n3 7\n51 61 -2 66 66\n61 33 25 -14 19\n-17 -20 66 67 50\n-3 23 28 25 31 12 14\n11 -8 27 -8 25 9 12\n36 32 10 4 6 28 22\n30 37 23 -8 38 30 25\n38 24 -1 -5 -8 -1 28\n4934 4647 4507\n第二行和最后一行是这个程序输出的结果\n\n\n为什么会这样呢，看不出来是哪一步写的有问题🥲\n\n\n我的解答思路和尝试过的方法，不写自己思路的，回答率下降 60%\n\n\n我想要达到的结果，如果你需要快速回答，请尝试 “付费悬赏”", "Tag": "算法分析"}
{"Answer": "\nPerforming 8x8 matrix multipliciation is relatively small work.\nGoroutines (although may be lightweight) do have overhead. If the work they do is \"small\", the overhead of launching, synchronizing and throwing them away may outweight the performance gain of utilizing multiple cores / threads, and overall you might not gain performance by executing such small tasks concurrently (hell, you may even do worse than without using goroutines). Measure.\nIf we increase the matrix size to 80x80, running the benchmark we already see some performance gain in case of ParalMultNaivePerRow:\nBenchmarkMatrixDotNaive/A.MultNaive-4               2000     1054775 ns/op\nBenchmarkMatrixDotNaive/A.ParalMultNaivePerRow-4    2000      709367 ns/op\nBenchmarkMatrixDotNaive/A.ParalMultNaivePerElem-4    100    10224927 ns/op\n\n(As you see in the results, I have 4 CPU cores, running it on your 8-core machine might show more performance gain.)\nWhen rows are small, you are using goroutines to do minimal work, you may improve performance by not \"throwing\" away goroutines once they're done with their \"tiny\" work, but you may \"reuse\" them. See related question: Is this an idiomatic worker thread pool in Go?\nAlso see related / possible duplicate: Vectorise a function taking advantage of concurrency\n", "Konwledge_Point": "矩阵乘法", "Question": "具有goroutine的矩阵乘法会降低性能\n\n\n\nI am optimizing matrix multiplication via goroutines in Go.\n\n\n\nMy benchmark shows, introducing concurrency per row or per element largely drops performance:\n\n\n\ngoos: darwin\ngoarch: amd64\nBenchmarkMatrixDotNaive/A.MultNaive-8                            2000000               869 ns/op               0 B/op          0 allocs/op\nBenchmarkMatrixDotNaive/A.ParalMultNaivePerRow-8                  100000             14467 ns/op              80 B/op          9 allocs/op\nBenchmarkMatrixDotNaive/A.ParalMultNaivePerElem-8                  20000             77299 ns/op             528 B/op         65 allocs/op\n\n\n\n\nI know some basic prior knowledge of cache locality, it make sense that per element concurrency drops performance. However, why per row still drops the performance even in naive version?\n\n\n\nIn fact, I also wrote a block/tiling optimization, its vanilla version (without goroutine concurrency) even worse than naive version (not present here, let's focus on naive first). \n\n\n\nWhat did I do wrong here? Why? How to optimize here?\n\n\n\nMultiplication:\n\n\n\npackage naive\n\nimport (\n    \"errors\"\n    \"sync\"\n)\n\n// Errors\nvar (\n    ErrNumElements = errors.New(\"Error number of elements\")\n    ErrMatrixSize  = errors.New(\"Error size of matrix\")\n)\n\n// Matrix is a 2d array\ntype Matrix struct {\n    N    int\n    data [][]float64\n}\n\n// New a size by size matrix\nfunc New(size int) func(...float64) (*Matrix, error) {\n    wg := sync.WaitGroup{}\n    d := make([][]float64, size)\n    for i := range d {\n        wg.Add(1)\n        go func(i int) {\n            defer wg.Done()\n            d[i] = make([]float64, size)\n        }(i)\n    }\n    wg.Wait()\n    m := &Matrix{N: size, data: d}\n    return func(es ...float64) (*Matrix, error) {\n        if len(es) != size*size {\n            return nil, ErrNumElements\n        }\n        for i := range es {\n            wg.Add(1)\n            go func(i int) {\n                defer wg.Done()\n                m.data[i/size][i%size] = es[i]\n            }(i)\n        }\n        wg.Wait()\n        return m, nil\n    }\n}\n\n// At access element (i, j)\nfunc (A *Matrix) At(i, j int) float64 {\n    return A.data[i][j]\n}\n\n// Set set element (i, j) with val\nfunc (A *Matrix) Set(i, j int, val float64) {\n    A.data[i][j] = val\n}\n\n// MultNaive matrix multiplication O(n^3)\nfunc (A *Matrix) MultNaive(B, C *Matrix) (err error) {\n    var (\n        i, j, k int\n        sum     float64\n        N       = A.N\n    )\n\n    if N != B.N || N != C.N {\n        return ErrMatrixSize\n    }\n\n    for i = 0; i < N; i++ {\n        for j = 0; j < N; j++ {\n            sum = 0.0\n            for k = 0; k < N; k++ {\n                sum += A.At(i, k) * B.At(k, j)\n            }\n            C.Set(i, j, sum)\n        }\n    }\n    return\n}\n\n// ParalMultNaivePerRow matrix multiplication O(n^3) in concurrency per row\nfunc (A *Matrix) ParalMultNaivePerRow(B, C *Matrix) (err error) {\n    var N = A.N\n\n    if N != B.N || N != C.N {\n        return ErrMatrixSize\n    }\n\n    wg := sync.WaitGroup{}\n    for i := 0; i < N; i++ {\n        wg.Add(1)\n        go func(i int) {\n            defer wg.Done()\n            for j := 0; j < N; j++ {\n                sum := 0.0\n                for k := 0; k < N; k++ {\n                    sum += A.At(i, k) * B.At(k, j)\n                }\n                C.Set(i, j, sum)\n            }\n        }(i)\n    }\n    wg.Wait()\n    return\n}\n\n// ParalMultNaivePerElem matrix multiplication O(n^3) in concurrency per element\nfunc (A *Matrix) ParalMultNaivePerElem(B, C *Matrix) (err error) {\n    var N = A.N\n\n    if N != B.N || N != C.N {\n        return ErrMatrixSize\n    }\n\n    wg := sync.WaitGroup{}\n    for i := 0; i < N; i++ {\n        for j := 0; j < N; j++ {\n            wg.Add(1)\n            go func(i, j int) {\n                defer wg.Done()\n                sum := 0.0\n                for k := 0; k < N; k++ {\n                    sum += A.At(i, k) * B.At(k, j)\n                }\n                C.Set(i, j, sum)\n            }(i, j)\n        }\n    }\n    wg.Wait()\n    return\n}\n\n\n\n\nBenchmark:\n\n\n\npackage naive\n\nimport (\n    \"os\"\n    \"runtime/trace\"\n    \"testing\"\n)\n\ntype Dot func(B, C *Matrix) error\n\nvar (\n    A = &Matrix{\n        N: 8,\n        data: [][]float64{\n            []float64{1, 2, 3, 4, 5, 6, 7, 8},\n            []float64{9, 1, 2, 3, 4, 5, 6, 7},\n            []float64{8, 9, 1, 2, 3, 4, 5, 6},\n            []float64{7, 8, 9, 1, 2, 3, 4, 5},\n            []float64{6, 7, 8, 9, 1, 2, 3, 4},\n            []float64{5, 6, 7, 8, 9, 1, 2, 3},\n            []float64{4, 5, 6, 7, 8, 9, 1, 2},\n            []float64{3, 4, 5, 6, 7, 8, 9, 0},\n        },\n    }\n    B = &Matrix{\n        N: 8,\n        data: [][]float64{\n            []float64{9, 8, 7, 6, 5, 4, 3, 2},\n            []float64{1, 9, 8, 7, 6, 5, 4, 3},\n            []float64{2, 1, 9, 8, 7, 6, 5, 4},\n            []float64{3, 2, 1, 9, 8, 7, 6, 5},\n            []float64{4, 3, 2, 1, 9, 8, 7, 6},\n            []float64{5, 4, 3, 2, 1, 9, 8, 7},\n            []float64{6, 5, 4, 3, 2, 1, 9, 8},\n            []float64{7, 6, 5, 4, 3, 2, 1, 0},\n        },\n    }\n    C = &Matrix{\n        N: 8,\n        data: [][]float64{\n            []float64{0, 0, 0, 0, 0, 0, 0, 0},\n            []float64{0, 0, 0, 0, 0, 0, 0, 0},\n            []float64{0, 0, 0, 0, 0, 0, 0, 0},\n            []float64{0, 0, 0, 0, 0, 0, 0, 0},\n            []float64{0, 0, 0, 0, 0, 0, 0, 0},\n            []float64{0, 0, 0, 0, 0, 0, 0, 0},\n            []float64{0, 0, 0, 0, 0, 0, 0, 0},\n            []float64{0, 0, 0, 0, 0, 0, 0, 0},\n        },\n    }\n)\n\nfunc BenchmarkMatrixDotNaive(b *testing.B) {\n    f, _ := os.Create(\"bench.trace\")\n    defer f.Close()\n    trace.Start(f)\n    defer trace.Stop()\n\n    tests := []struct {\n        name string\n        f    Dot\n    }{\n        {\n            name: \"A.MultNaive\",\n            f:    A.MultNaive,\n        },\n        {\n            name: \"A.ParalMultNaivePerRow\",\n            f:    A.ParalMultNaivePerRow,\n        },\n        {\n            name: \"A.ParalMultNaivePerElem\",\n            f:    A.ParalMultNaivePerElem,\n        },\n    }\n    for _, tt := range tests {\n        b.Run(tt.name, func(b *testing.B) {\n            for i := 0; i < b.N; i++ {\n                tt.f(B, C)\n            }\n        })\n    }\n}\n\n\n    ", "Tag": "算法分析"}
{"Answer": "http://m.blog.csdn.net/article/details?id=38236769", "Konwledge_Point": "矩阵乘法", "Question": "Matrix Multiplication         矩阵乘法\nDescription\n\n\n\nMany studies have been done on developing efficient algorithms to calculate matrix multiplication. But it remains as a hard topic today. In this problem you are to calculate the 2006th power of a square Boolean matrix where addition and multiplication are defined as follows:\n\n\n\nA   B   A + B\n\n0   0   0\n\n0   1   1\n\n1   0   1\n\n1   1   1\n\nTruth Table of Addition\n\n\n\nA   B   AB\n\n0   0   0\n\n0   1   0\n\n1   0   0\n\n1   1   1\n\nTruth Table of Multiplication\n\n\n\nLet A be a square matrix. The zeroth power of A is the identity matrix. The n-th (n > 0) power of A is the product of A and its (n − 1)-th power.\n\n\n\nInput\n\n\n\nThe input contains multiple test cases. Each test cases consists of some lines:\n\n\n\nLine 1: Contains two integers K (K < 1000) and M (0 ≤ M ≤ 10K), indicating the dimension of the matrix is K × K and K + M elements of the matrix are 1’s.\n\nLines 2 ~ M + 1: Each contains two integers i and j (0 ≤ i, j < K, i ≠ j), indicating the element in the (i + 1)-th row and (j + 1)-th column is 1.\n\nAll elements on the primary diagonal of the matrix are 1’s.\n\n\n\nOutput\n\n\n\nFor each test case output one line containing the number of elements that are 1’s in the 2006th power of the given matrix.\n\n\n\nSample Input\n\n\n\n3 4\n\n1 2\n\n2 1\n\n0 1\n\n0 2\n\nSample Output\n\n\n\n7", "Tag": "算法分析"}
{"Answer": "\n#include <iostream>\nusing namespace std;\n\n \n#include<stdio.h>\nint main()\n{\n    double a[100][100],b[100][100],h[100][100];\n    int m,n,i,j,k,l,c,d;\n    scanf(\"%d %d\",&m,&n);//输入行数和列数\n    for(i=0; i<m; i++)\n    {\n        for(j=0; j<n; j++)\n        {\n            scanf(\"%lf\",&a[i][j]);//输入第一个矩阵\n        }\n    }\n \n \n    for(l=0; l<n; l++)\n    {\n        for(k=0; k<m; k++)\n        {\n            scanf(\"%lf\",&b[l][k]);//输入第二个矩阵\n        }\n    }\n    for(c=0; c<m; c++) //行数小于等于第一个矩阵的行数\n    {\n        for(d=0; d<m; d++) //列数小于等于第二个矩阵的列数\n        {\n            int sum = 0;\n            for(k=0; k<n; k++) //第一个矩阵行数和第二个矩阵列数\n            {\n                sum +=a[c][k]*b[k][d];//计算\n            }\n            h[c][d] = sum;\n        }\n    }\n    for(c=0; c<m; c++)\n    {\n        for(d=0; d<m; d++)\n        {\n            printf(\"%.0f \",h[c][d]);//输出\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n", "Konwledge_Point": "矩阵乘法", "Question": "关于矩阵乘法问题c++\n在主函数中输入M和N\n调用函数multiply（）\n并输出矩阵c\nc++", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/kalilili/article/details/44136861", "Konwledge_Point": "矩阵乘法", "Question": "AC自动机+矩阵乘法                  \nDescription\n\n背单词，始终是复习英语的重要环节。在荒废了3年大学生涯后，Lele也终于要开始背单词了。\n\n一天，Lele在某本单词书上看到了一个根据词根来背单词的方法。比如\"ab\",放在单词前一般表示\"相反，变坏，离去\"等。\n\n\n\n于是Lele想，如果背了N个词根，那这些词根到底会不会在单词里出现呢。更确切的描述是：长度不超过L，只由小写字母组成的，至少包含一个词根的单词，一共可能有多少个呢？这里就不考虑单词是否有实际意义。\n\n\n\n比如一共有2个词根 aa 和 ab ，则可能存在104个长度不超过3的单词，分别为\n\n(2个) aa,ab,\n\n(26个)aaa,aab,aac...aaz,\n\n(26个)aba,abb,abc...abz,\n\n(25个)baa,caa,daa...zaa,\n\n(25个)bab,cab,dab...zab。\n\n\n\n这个只是很小的情况。而对于其他复杂点的情况，Lele实在是数不出来了，现在就请你帮帮他。\n\n\n\nInput\n\n本题目包含多组数据，请处理到文件结束。\n\n每组数据占两行。\n\n第一行有两个正整数N和L。(0<N<6,0<L<2^31)\n\n第二行有N个词根，每个词根仅由小写字母组成，长度不超过5。两个词根中间用一个空格分隔开。\n\n\n\nOutput\n\n对于每组数据，请在一行里输出一共可能的单词数目。\n\n由于结果可能非常巨大，你只需要输出单词总数模2^64的值。\n\n\n\nSample Input\n\n2 3 aa ab 1 2 a\n\n\n\nSample Output\n\n104 52", "Tag": "算法分析"}
{"Answer": "除也需要点除即./\nZ = sin(sqrt(X.^2+Y.^2))./(sqrt(X.^2+Y.^2)); % XY都要大写\n\n有帮助望采纳呢", "Konwledge_Point": "矩阵乘法", "Question": "Matlab点乘与矩阵乘法问题的辨析\n这是我所要完成的题目\n\n\n这是我写的代码\n\n\n这是报的错误，请问这是为什么啊？我觉得两个矩阵都是同维度啊，为什么无法相乘啊。数学基础太差了，有点搞不懂为什么会这样，求解释一下！\n\n\n如果我把代码改写成.^的形式，又会导致Z不是矩阵了，这又是为什么？\n\n", "Tag": "算法分析"}
{"Answer": "import java.util.*;\nclass Solution {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int num = sc.nextInt();\n        Map<Integer,int[]> map = new HashMap<>();\n        for(int i = 1;i <= num;i++){\n            int[] temp = new int[2];\n            temp[0] = sc.nextInt();//行数\n            temp[1] = sc.nextInt();//列数\n            map.put(i,temp);\n        }\n        Map<Integer,int[][]> matrix = new HashMap<>();\n        for(int i = 1;i <= num;i++){\n            int[] temp1 = map.get(i);\n            int rows = temp1[0], clos = temp1[1];\n            int[][] arr = new int[rows][clos];\n            for(int j = 0;j < rows;j++){\n                for(int k = 0;k < clos;k++){\n                    arr[j][k] = sc.nextInt();\n                }\n            } \n            matrix.put(i, arr);\n        }\n        sc.close();\n        //开始遍历map进行矩阵乘法\n        int[][] res = multiply(matrix.get(1),matrix.get(2));\n        for(int i = 3;i <= num;i++){\n            res = multiply(res, matrix.get(i));\n        }\n        for(int i = 0;i < res.length;i++){\n            for(int j = 0;j < res[0].length;j++){\n                System.out.print(res[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n    public static int[][] multiply(int[][] m1, int[][] m2){\n        int[][] res = new int[m1.length][m2[0].length];\n        for(int i=0;i<m1.length;i++) {\n            for(int j=0;j<m2[0].length;j++) {\n                for(int k=0;k<m2.length;k++) {\n                    res[i][j] += (m1[i][k] * m2[k][j]) % 514329;\n                }\n            }\n        }\n        return res;\n    }\n}\n\n", "Konwledge_Point": "矩阵乘法", "Question": "简单的Java题，有关矩阵乘法\n凑个字数6666666666666666666666666666666666666666666666666666666666666", "Tag": "算法分析"}
{"Answer": "+=在循环中代表的是累加而=只是每循环一次给c[][]赋一次此次的值", "Konwledge_Point": "矩阵乘法", "Question": "矩阵乘法，+=与=有什么区别\n\n\n\n\n我知道那个22行应该换成+=，但是为什么?加不加“+”有什么区别吗？", "Tag": "算法分析"}
{"Answer": "基于new Bing的修改：\n#define ROW 3\n#define COL 4\nint main()\n{\nint arr1[ROW][COL] = { {1,2,3,4}, {5,6,7,8}, {9,10,11,12} };\nint arr2[COL][ROW] = { {12,11,10}, {9,8,7}, {6,5,4}, {3,2,1} };\nint arr3[ROW][ROW] = {0};\nint i,j,k;\nprintf(\"\\narray arr1:\\n\");\nfor(i=0; i<ROW; i++)\n{\nfor(j=0; j<COL; j++)\n{\nprintf(\"%5d\", arr1[i][j]);\n}\nprintf(\"\\n\");\n}\nprintf(\"\\narray arr2:\\n\");\nfor(i=0; i<COL; i++)\n{\nfor(j=0; j<ROW; j++)\n{\nprintf(\"%5d\", arr2[i][j]);\n}\nprintf(\"\\n\");\n}\nprintf(\"\\narray arr1*arr2:\\n\");\nfor(i=0; i<ROW; i++)\n{\nfor(j=0; j<ROW; j++)\n{\nfor(k=0; k<COL; k++)\n{\narr3[i][j] += arr1[i][k] * arr2[k][j];\n}\nprintf(\"%5d\", arr3[i][j]);\n}\nprintf(\"\\n\");\n}\nreturn 0;\n}\n\n", "Konwledge_Point": "矩阵乘法", "Question": "如何用二维数组实现矩阵乘法（初级）\n代码如下：\n\n\n#define \nROW\n \n3\n\n#define \nCOL\n \n4\n\nint main()\n{\n    int arr1[\nROW\n][\nCOL\n] = { \n1\n,\n2\n,\n3\n,\n4\n,\n5\n,\n6\n,\n7\n,\n8\n,\n9\n,\n10\n,\n11\n,\n12\n};\n    int arr2[\nROW\n][\nCOL\n] = { \n12\n,\n11\n,\n10\n,\n9\n,\n8\n,\n7\n,\n6\n,\n5\n,\n4\n,\n3\n,\n2\n,\n1\n };\n    int arr3[\nROW\n][\nCOL\n]={\n0\n};\n    int i,j,k;\n    printf(\n\"\\narray arr1:\\n\"\n); \n    for( i=\n0\n;i<\n3\n;i++)\n    {\n        for( j=\n0\n;j<\n4\n;j++)\n          {\n              arr3[i][j]=arr1[i][j];\n            printf(\n\"%5d\"\n,arr3[i][j]);\n        } \n        printf(\n\"\\n\"\n);\n    }\n    printf(\n\"\\narray arr2:\\n\"\n); \n    for(i=\n0\n;i<\n3\n;i++)\n    {\n        for(j=\n0\n;j<\n4\n;j++)\n          {\n              arr3[i][j]=arr2[i][j];\n            printf(\n\"%5d\"\n,arr3[i][j]);\n        } \n        printf(\n\"\\n\"\n);\n    }\n    printf(\n\"\\narray arr1*arr2:\\n\"\n); \n    for(i=\n0\n;i<\n3\n;i++)\n    {\n        for(j=\n0\n;j<\n4\n;j++)\n          {\n              for( k=\n0\n;k<\n4\n;k++)\n              arr3[i][j]+=arr1[i][k]*arr2[k][j];\n            printf(\n\"%5d\"\n,arr3[i][j]);\n        } \n        printf(\n\"\\n\"\n);\n    }\n    return \n0\n;\n}\n\n\n\n\n运行结果\n\n\n好像算错了，但是不知道哪里错了。", "Tag": "算法分析"}
{"Answer": "ChatGPT尝试为您解答，仅供参考\n#include <stdio.h>\n\n#define ROW_A 3\n#define COL_A 4\n#define COL_B 2\n\nint main(void) {\n    int A[ROW_A][COL_A];  // 定义 3x4 矩阵 A\n    int B[COL_A][COL_B];  // 定义 4x2 矩阵 B\n    int C[ROW_A][COL_B];  // 定义 3x2 矩阵 C\n\n    // 输入矩阵 A 的值\n    printf(\"Enter the values for matrix A (%dx%d):\\n\", ROW_A, COL_A);\n    for (int i = 0; i < ROW_A; i++) {\n        for (int j = 0; j < COL_A; j++) {\n            scanf(\"%d\", &A[i][j]);\n        }\n    }\n\n    // 输入矩阵 B 的值\n    printf(\"Enter the values for matrix B (%dx%d):\\n\", COL_A, COL_B);\n    for (int i = 0; i < COL_A; i++) {\n        for (int j = 0; j < COL_B; j++) {\n            scanf(\"%d\", &B[i][j]);\n        }\n    }\n    \n    // 计算矩阵乘法\n    for (int i = 0; i < ROW_A; i++) {\n        for (int j = 0; j < COL_B; j++) {\n            C[i][j] = 0;\n            for (int k = 0; k < COL_A; k++) {\n                C[i][j] += A[i][k] * B[k][j];\n            }\n        }\n    }\n\n    // 输出结果\n    printf(\"Result:\\n\");\n    for (int i = 0; i < ROW_A; i++) {\n        for (int j = 0; j < COL_B; j++) {\n            printf(\"%d \", C[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n\n在这个程序中，我们首先定义了 3x4 的矩阵 A、4x2 的矩阵 B 和 3x2 的矩阵 C，然后读入矩阵 A 和 B 的值。接下来，我们使用三重循环来计算矩阵乘法，最后输出。", "Konwledge_Point": "矩阵乘法", "Question": "😭真的不会！马上要交了！#C语言#数组矩阵乘法\n请设计一个程序：利用二维数组来表示矩阵，实现一个3x4矩阵 A 与4x2矩阵 B 相乘，并把结果存放在一个3x2的矩阵 C 中。矩阵 A 、 B 的初始化由用户进行输入。", "Tag": "算法分析"}
{"Answer": "没有初始化数组", "Konwledge_Point": "矩阵乘法", "Question": "请问这个求矩阵乘法的程序哪里错了？\n#include \n\nint main(void)\n\n{\n\n    int ar1[2][2] = { {2,0},{1,0} };\n\n    int ar2[2][2] = { {1,2} ,{0,0} };\n\n    int ar3[2][2];\n\n    int i;\n\n    int j;\n\n    int c=2;\n\n    int k;\n\n    for (i = 0; i < 2; i++)\n\n        for (j = 0; j < 2; j++)\n\n            for (k = 0; k < c; k++)\n\n                ar3[i][j] += ar1[i][k] * ar2[k][j];\n\n    for (i = 0; i < 2; i++)\n\n    {\n\n        for (j = 0; j < 2; j++)\n\n        {\n\n            printf(\"%d\\t\", ar3[i][j]);\n\n        }\n\n        printf(\"\\n\");\n\n    }\n\n\n\nreturn 0;\n\n\n\n\n}", "Tag": "算法分析"}
{"Answer": "代码是在设备上运行的么，没有使用主机变量吧，没有爆内存吧，还有驱动程序对不对。你可以先测试自带的例子程序，排除环境问题。", "Konwledge_Point": "矩阵乘法", "Question": "cuda核函数不执行的可能原因？\n练习了一个矩阵乘法的例子，每个block配置16×16个thread，\n\n当做5000×5000的矩阵乘法时，结果就全为0，核函数不执行不知道原因是什么？\n\n每个grid每一维可以包含至少65535个block，算了下没有超出但是核函数没执行。。。", "Tag": "算法分析"}
{"Answer": "解答如下\n#include<stdio.h>\nvoid input(int n,int t[][n])\n{\n    for(int i=0; i<n; i++)\n    {\n        for(int j=0; j<n; j++)\n        {\n            scanf(\"%d\",&t[i][j]);\n        }\n    }\n}\nvoid put(int n,int t[][n])\n{\n    for(int i=0; i<n; i++)\n    {\n        for(int j=0; j<n; j++)\n        {\n            printf(\"%d \",t[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}\nvoid swap(int *a,int *b)\n{\n    int c=*a;\n    *a=*b;\n    *b=c;\n}\nvoid trans(int n,int t[][n])\n{\n    for(int i=0; i<n; i++)\n    {\n        for(int j=i; j<n; j++)\n        {\n            swap(&t[i][j],&t[j][i]);\n        }\n    }\n}\nvoid add(int n,int t1[][n],int t2[][n])\n{\n    for(int i=0; i<n; i++)\n    {\n        for(int j=0; j<n; j++)\n        {\n            t1[i][j]+=t2[i][j];\n        }\n    }\n}\n\nvoid mul(int n,int t1[][n],int t2[][n])\n{\n    for(int i=0; i<n; i++)\n    {\n        for(int j=0; j<n; j++)\n        {\n            t1[i][j]*=t2[i][j];\n        }\n    }\n}\nint main()\n{\n    int n;\n    printf(\"1,转置\\n\");\n    printf(\"2,加法\\n\");\n    printf(\"3,乘法\\n\");\n    printf(\"other,退出\\n\");\n    int option;\n    scanf(\"%d\",&option);\n    if(option==1)\n    {\n        printf(\"输入矩阵行数：\");\n        scanf(\"%d\",&n);\n        printf(\"输入矩阵：\\n\");\n        int t1[n][n];\n        input(n,t1);\n        trans(n,t1);\n        printf(\"--------\\n\");\n        put(n,t1);\n    }\n    else if(option==2)\n    {\n        printf(\"输入矩阵行数：\");\n        scanf(\"%d\",&n);\n        int t1[n][n];\n        int t2[n][n];\n        printf(\"输入矩阵1：\\n\");\n        input(n,t1);\n        printf(\"输入矩阵2：\\n\");\n        input(n,t2);\n        add(n,t1,t2);\n        printf(\"--------\\n\");\n        put(n,t1);\n    }\n    else if(option==3)\n    {\n        printf(\"输入矩阵行数：\");\n        scanf(\"%d\",&n);\n        int t1[n][n];\n        int t2[n][n];\n        printf(\"输入矩阵1：\\n\");\n        input(n,t1);\n        printf(\"输入矩阵2：\\n\");\n        input(n,t2);\n        mul(n,t1,t2);\n        printf(\"--------\\n\");\n        put(n,t1);\n    }\n    else\n    {\n        return 0;\n    }\n}\n", "Konwledge_Point": "矩阵乘法", "Question": "C语言制作稀疏矩阵运算器，要求不使用三重及三重以上嵌套循环，时间复杂度较低\nC语言做一个稀疏矩阵运算器，要求不使用三重及三重以上嵌套循环，并且时间复杂度较低，可以实现矩阵运算器的矩阵转置，矩阵加减法，矩阵乘法，退出运算五个功能，可以适当追加赏金。", "Tag": "算法分析"}
{"Answer": "参考这篇文章https://blog.csdn.net/GreenHandCGL/article/details/81164349?ops_request_misc=&request_id=&biz_id=102&utm_term=python%20%E5%90%91%E9%87%8F%E7%9F%A9%E9%98%B5&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-81164349.142^v10^control,157^v4^control&spm=1018.2226.3001.4187", "Konwledge_Point": "矩阵乘法", "Question": "两个关于python 矩阵和向量计算方面的代码问题\n我现在想把一个向量中的多个指定位置的值替换成一个值，代码是怎么样的？（下图）\n\n\n\n\n另外要实现一下向量和矩阵乘法用什么代码？（下图）\n\n", "Tag": "算法分析"}
{"Answer": "python中乘法是使用好,你将@改为即可", "Konwledge_Point": "矩阵乘法", "Question": "python中列表转为矩阵后无法进行矩阵的乘法运算\n各位大佬，这个为什么一直报这个错误，为什么没办法进行矩阵的乘法呀？", "Tag": "算法分析"}
{"Answer": "供参考：\n#include <stdio.h>\n#define N 20\nint is_symmetricmatrix(int a[][N], int Row,int Col)//判断一个N*N矩阵，是否是对称矩阵，是返回1，否返回0\n{\n    int i, j, flag;\n    for (i = 0, flag = 1; i < Row; i++)\n    {\n        for (j = 0; j < i; j++)\n        {\n            if (a[i][j] != a[j][i])\n            {\n                flag = 0;\n                break;\n            }\n        }\n        if (j < i) break;\n    }\n    if (flag)\n        return 1;\n    else\n        return 0;\n}\nvoid getTransposeMatrix(int b[][N], int a[][N], int Row, int Col)//矩阵转置\n{\n    int i, j;\n    for (i = 0; i < Row; i++)\n        for (j = 0; j < Col; j++)\n            b[j][i] = a[i][j];\n}\nvoid matrixMul(int a[][N], int b[][N], int c[][N], int Rowa, int Cola, int Colb)//矩阵相乘\n{\n    int i, j, k;\n    for(i=0;i<Rowa;i++)\n    {\n        for (j = 0; j < Colb; j++)\n        {\n            for (k = 0; k < Cola; k++)\n                c[i][j] += a[i][k] * b[k][j];\n        }\n    }\n}\nvoid matrixAdd(int a[][N], int b[][N], int c[][N], int Rowa, int Cola)//矩阵相加\n{\n    int i, j;\n    for (i = 0; i < Rowa; i++)\n        for (j = 0; j < Cola; j++)\n            c[i][j] = a[i][j] + b[i][j];\n}\nvoid printmatrix(int a[][N], int Row, int Col)\n{\n    int i, j;\n    for (i = 0; i < Row; i++){\n        for (j = 0; j < Col; j++)\n        {\n            printf(\"%d \", a[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\nint main()\n{\n    int a[N][N] = { 0 }, b[N][N] = { 0 }, c[N][N] = {0}, i, j, n = 3;\n    scanf(\"%d\", &n);\n    for (i = 0; i < n; i++)\n        for (j = 0; j < n; j++)\n            scanf(\"%d\", &a[i][j]);\n    if (is_symmetricmatrix(a, n, n))\n    {\n        printf(\"YES\\n\");\n        getTransposeMatrix(b, a, n, n);\n        matrixMul(a, b, c, n, n, n);\n        printmatrix(c, n, n);\n    }\n    else{\n        printf(\"NO\\n\");\n        getTransposeMatrix(b, a, n, n);\n        matrixAdd(a, b, c, n, n);\n        printmatrix(c, n, n);\n    }\n    return 0;\n}\n\n", "Konwledge_Point": "矩阵乘法", "Question": "有关数组与函数的矩阵运算\n矩阵运算\n描述\n实现从键盘上读取一个数n，输入n*n的矩阵A，首先判断矩阵A是否为实对称矩阵（实对称矩阵：n阶矩阵A，其矩阵的元素都为实数，且矩阵A的转置等于其本身（aij=aji），(i,j为元素的脚标），则称A为实对称矩阵。）\n\n\n如果是实对称矩阵则输出 YES，再换行输出矩阵A*A^T的结果（A^T为A的转置） 。\n\n\n如果不是实对称矩阵则输出NO，再输出矩阵A+A^T的结果（A^T为A的转置）。\n\n\n以上矩阵输出都以n行n列的格式输出，每个元素用空格隔开，在每行最后一个元素输出换行。\n\n\n（1）矩阵加法公式：每行每列对应元素相加，Cij=Aij + Bij；\n\n\n（2）矩阵乘法公式：Cij = Ai0×B0j+Ai1×B1j+……+Ain×Bnj；\n\n\n输入\n从键盘上输入一个数n后再输入n*n的矩阵A。\n\n\n输出\n判断矩阵A是否为实对称矩阵（实对称矩阵：n阶矩阵A，其矩阵的元素都为实数，且矩阵A的转置等于其本身（aij=aji），(i,j为元素的脚标），则称A为实对称矩阵。）\n\n\n如果是实对称矩阵则输出 YES，再换行输出矩阵A*A^T的结果（A^T为A的转置） ，\n\n\n如果不是实对称矩阵则输出NO，再换行输出矩阵A+A^T的结果（A^T为A的转置）。\n\n\n以上矩阵输出都以n行n列的格式输出，每个元素用空格隔开，在每行最后一个元素输出换行。（最后一个元素后面没有空格）", "Tag": "算法分析"}
{"Answer": "package juzhen;\nimport java.util.Random;\n//1）生成一个d∗L维矩阵（2）矩阵乘法（3）主要计算矩阵H的Moore-Penrose广义逆，它可以通过矩阵H与其转置矩阵HT相乘\n\npublic class JuZhen {\n    public static Integer[][] getJuZhen(int d,int l){\n        Integer results[][]=new Integer[d][l];\n        Random random=new Random();\n        for(int i=0;i<d;i++) {\n            for(int j=0;j<l;j++) {\n                results[i][j]=random.nextInt(100);\n                System.out.print(results[i][j]+\"    \");\n            }\n            System.out.println();\n        }\n        return results;\n    }\n    \n    public static Integer[][] chengMethod(Integer[][] first,Integer[][] second){//求矩阵乘法\n        int firstD=first.length;\n        int firstL=first[0].length;\n        int secondD=second.length;\n        int secondL=second[0].length;\n        Integer results[][]=new Integer[firstD][secondL];\n        Integer firstLv[]=null;\n        Integer secondDv=0;\n        int j=0,m=0;\n        int i=0,n=0,count=0;\n        int temp=0;\n            for(;i<firstD;) {\n                firstLv=first[i];\n                for(n=0;n<secondD;n++) {\n                    secondDv=second[n][m];\n                    temp+=firstLv[n]*secondDv;                    \n                }\n                results[i][m]=temp;\n                temp=0;\n                System.out.println(results[i][m]);\n                m++;\n                if(m==secondL) {\n                    m=0;\n                    i++;\n                }\n            }\n        return results;\n    }\n    public static Integer[][] zhuanzhi(Integer[][] juzhen){\n        Integer m=juzhen.length;\n        Integer n=juzhen[0].length;\n        Integer results[][]=new Integer[n][m];\n//        for(int i=0;i<m;i++) {\n//            for(int j=0;j<n;j++) {\n//                System.out.print(juzhen[i][j] +\"   \");\n//            }\n//            System.out.println();\n//        }\n//        System.out.println(\"-----------------------------\");\n        for(int i=0;i<n;i++) {\n            for(int j=0;j<m;j++) {\n                results[i][j]=juzhen[j][i];\n                System.out.print(results[i][j]+\"    \");\n            }\n            System.out.println();\n        }\n        return results;\n    }\n    public static void main(String[] args) {\n        Integer first[][]= {{2,3,4},{3,4,5}};\n        Integer second[][]= {{4,7},{5,3},{2,3}};\n//        chengMethod(first,second);\n        Integer hInteger[][]=getJuZhen(3, 4);\n        Integer results[][]=zhuanzhi(hInteger);\n        chengMethod(hInteger, results);\n//        getJuZhen(3, 4);\n    }\n}\n ", "Konwledge_Point": "矩阵乘法", "Question": "Java实现以下算法\n\n\n\n（1）生成一个d∗L维矩阵（2）矩阵乘法（3）主要计算矩阵H的Moore-Penrose广义逆，它可以通过矩阵H与其转置矩阵HT相乘", "Tag": "算法分析"}
{"Answer": "把这些变量声明为符号变量就可以，比如sym a;  这就是声明a是符号变量。", "Konwledge_Point": "矩阵乘法", "Question": "MATLAB能实现含参矩阵的乘法吗\n比如[a b;c d]*[e f;g h],里面的状态变量不赋值，得出含参的二乘二矩阵", "Tag": "算法分析"}
{"Answer": "你好，我是有问必答小助手，非常抱歉，本次您提出的有问必答问题，技术专家团超时未为您做出解答 本次提问扣除的有问必答次数，已经为您补发到账户，我们后续会持续优化，扩大我们的服务范围，为您带来更好地服务。", "Konwledge_Point": "矩阵乘法", "Question": "matlab关于cvx sdp的问题\n问题遇到的现象和发生背景\n\n\n在cvx sdp中，我想在约束条件中表达一个矩阵为半正定，是用A>=0还是用A==semidefinite(n)来表示呢，两者都行嘛，还是有什么区别\n\n\n问题相关代码，请勿粘贴截图\n\n\nP13+S3*theta0*S1*theta0'*S3'>=0\n;\n\nP13+S3*theta0*S1*theta0'*S3'==semidefinite(\nn\n)\n;\n\n\n\n\n\n运行结果及报错内容\n\n\n第一个运行不报错；\n但第二个会报一个奇怪的错误说用于矩阵乘法的维度不正确。请检查并确保第一个矩阵中的列数与第二个矩阵中的行数匹配。要执行按元素相乘，请使用 '.*'。\n\n\n我的解答思路和尝试过的方法\n\n\n无\n\n\n我想要达到的结果\n\n\n想知道这两种都可以嘛，有什么区别嘛", "Tag": "算法分析"}
{"Answer": "这个问题很有可能是数组越界或者指针引用了无效的内存，你可以尝试在程序中添加一些调试代码，来追踪程序的执行情况。\n具体的，你可以使用以下方法来定位错误：\n在代码中加入许多 cout 语句，来追踪变量的值，以及程序的执行情况，这有助于你了解程序是如何执行的。\n使用断点调试，来检查程序在执行时是否出现错误。\n使用 assert 语句，如果一个表达式的结果为 false，则程序将中止执行，这有助于你定位错误。\n希望这些建议能帮助你找到问题所在。", "Konwledge_Point": "矩阵乘法", "Question": "C++矩阵类定义，遇到了Segmentation fault\nOJ系统一直提示：Segmentation fault:段错误，检查是否有数组越界，指针异常，访问到不应该访问的内存区域\n\n\n但是一直检查不出来哪里有错误。二维动态数组这个问题困扰我好久了，求指点！\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\n//矩阵类定义\n\n\nclass\n \nMatrix\n\n{\n\npublic\n:\n    \nMatrix\n(\nint\n, \nint\n);\n    \nvoid\n \nset\n(\nint\n, \nint\n)\n;\n    \nfriend\n istream& \noperator\n>>(istream &, Matrix&);\n    \nfriend\n ostream& \noperator\n<<(ostream&, \nconst\n Matrix&);\n    Matrix& \noperator\n*(Matrix&);\n    \nvoid\n \nDiagonalOrder\n()\n;\n    \nvoid\n \nsetZeros\n()\n;\n    \n\nprotected\n:\n    \nint\n** mat;                                     \n//矩阵（二位数组）\n\n    \nint\n row;                                        \n//行数\n\n    \nint\n col;                                         \n//列数\n\n};\n\nMatrix \ntemp\n(\n0\n,\n0\n)\n;                               \n//定义全局对象，用于接受矩阵乘法结果\n\n\nvoid\n \nMatrix::set\n(\nint\n n, \nint\n m)\n                \n\n{\n    row = n;\n    col = m;\n    mat = \nnew\n \nint\n* [n];\n    \nfor\n (\nint\n i = \n0\n; i < n; i++)\n    {\n        mat[i] = \nnew\n \nint\n[m];\n    }\n    \nif\n (mat == \nNULL\n)\n    {\n        cout << \n\"allocation failure!\\n\"\n;\n        \nreturn\n;\n    }\n    \nfor\n (\nint\n i = \n0\n; i < n; i++)\n    {\n        \nfor\n (\nint\n j = \n0\n; j < m; j++)\n        {\n            mat[i][j] = \n0\n;\n        }\n    }\n}\nMatrix::\nMatrix\n(\nint\n n, \nint\n m)                       \n//构造函数，初始化行数列数与矩阵\n\n{\n    row = n;\n    col = m;\n    \nif\n (m > \n0\n && n > \n0\n)\n    {\n        mat = \nnew\n \nint\n* [n];\n        \nfor\n (\nint\n i = \n0\n; i < n; i++)\n        {\n            mat[i] = \nnew\n \nint\n[m];\n        }\n        \nif\n (mat == \nNULL\n)\n        {\n            cout << \n\"allocation failure!\\n\"\n;\n            \nreturn\n;\n        }\n        \nfor\n (\nint\n i = \n0\n; i < n; i++)\n        {\n            \nfor\n (\nint\n j = \n0\n; j < m; j++)\n            {\n                mat[i][j] = \n0\n;\n            }\n        }\n    }\n    \nelse\n\n        mat = \nNULL\n;\n}\nistream& \noperator\n>>(istream& input, Matrix& a)        \n//重载输入运算符\n\n{\n    \nfor\n (\nint\n i = \n0\n; i < a.row; i++)\n    {\n        \nfor\n (\nint\n j = \n0\n; j < a.col; j++)\n        {\n            input >> a.mat[i][j];\n        }\n    }\n    \nreturn\n input;\n}\nostream& \noperator\n<<(ostream& output,\nconst\n Matrix& a)     \n//重载输出运算符\n\n{\n   \n    \nfor\n (\nint\n i = \n0\n; i < a.row; i++)\n    {\n        \nfor\n (\nint\n j = \n0\n; j < a.col\n-1\n; j++)\n        {\n            output << a.mat[i][j] << \n\" \"\n;\n        }\n        cout << a.mat[i][a.col - \n1\n] << endl;\n    }\n    \nreturn\n output;\n}\n\nMatrix& Matrix::\noperator\n*(Matrix&a)                        \n//重载矩阵乘法\n\n{\n    \nif\n (col == a.row)\n    {\n        temp.\nset\n(row, a.col);\n        \n        \nfor\n (\nint\n i = \n0\n; i < temp.row; i++)\n        {\n            \nfor\n (\nint\n j = \n0\n; j < temp.col; j++)\n            {\n                \nint\n sum = \n0\n;\n                \nint\n k = \n0\n,o = \n0\n;\n                \nwhile\n (k < col && o < a.row)\n                {\n                    sum += mat[i][k] * a.mat[o][j];\n                    k++; o++;\n                }\n                \n                temp.mat[i][j] = sum;\n            }\n        }\n        \nreturn\n temp;\n    }\n    \nelse\n\n    {\n        cout << \n\"can't multiply!\"\n << endl;\n        \n    }\n}\n\nvoid\n \nMatrix::DiagonalOrder\n()\n                                               \n//之字形打印\n\n\n{\n    \n        cout << mat[\n0\n][\n0\n] << \n\" \"\n;\n    \n       \n        \nint\n is_up = \n1\n;\n        \nint\n x = \n0\n, y = \n0\n;\n        \nwhile\n (x >= \n0\n && x <= row - \n1\n && y >= \n0\n && y <= col - \n1\n)\n        {\n            \nif\n (x == \n0\n)\n            {\n                \nif\n (y == \n0\n)\n                {\n                    y++;\n                    is_up = \n0\n;                  \n                }\n                \nelse\n \nif\n(y=\n0\n&&y> m >> n) {\n\n        \nMatrix \nmat1\n(m, n)\n;\n\n        cin >> mat1;\n\n\n\n        \nint\n x, y;\n\n        cin >> x >> y;\n\n        \nMatrix \nmat2\n(x, y)\n;\n\n        cin >> mat2;\n\n\n\n        Matrix res = mat1 * mat2;\n\n        cout << res;\n\n\n\n        mat1.\nDiagonalOrder\n();\n\n\n\n        mat1.\nsetZeros\n();\n\n        cout << mat1;\n\n    }\n\n    \nreturn\n \n0\n;\n\n}\n\n", "Tag": "算法分析"}
{"Answer": "我傻了，把加号写成乘号了", "Konwledge_Point": "矩阵乘法", "Question": "XD们，再来帮帮我哇.....\n  大一c语言，函数是矩阵乘法，输入两个矩阵及其行数和列数，把答案打印在屏幕上。我自己测试了一次，发现乘完的新矩阵的行列数和预期相符，但是里面的数字不对。\n\n\nvoid\n \nmultiply\n(\nint\n* p, \nint\n a, \nint\n b, \nint\n* q, \nint\n c, \nint\n d)\n//p和q 是用指针代替的二维数组，a,b是第一个矩阵的行数和列数，c,d是第二个矩阵的行数与列数\n\n\n{\n    \nif\n (b == c)\n//判断输入的两个矩阵是否满足矩阵相乘的条件\n\n    {\n        \nint\n w,x,y,z;\n        \nfloat\n o;\n        \nfor\n (w = \n0\n; w <= a - \n1\n; w++)\n//控制第一个矩阵的行数\n\n        {\n            \nfor\n(z=\n0\n;z<=d\n-1\n;z++)\n//控制第二个矩阵的列数\n\n            { \n                  \nfor\n (o = x = y = \n0\n; y <= c - \n1\n; y++,x++)\n//用第一个矩阵每行的数乘第二个矩阵对应的每一列的数\n\n                  {\n                    o = o + *(p + w * b + x) + *(q + d * y + z);\n//将每一次相乘得到的结果作为新矩阵的每一项\n\n                    \n                  }\n                  \nprintf\n(\n\"%1.3f  \"\n, o);\n//将新矩阵的每一项打印在屏幕上\n\n            }\n            \nprintf\n(\n\"\\n\"\n);\n//换行\n\n        }\n    }\n    \nelse\n \nprintf\n(\n\"输入的矩阵不符合做乘法运算的条件\\n\"\n);\n//判断输入的两个矩阵是否满足矩阵相乘的条件\n\n}\n", "Tag": "算法分析"}
{"Answer": "你好，我是有问必答小助手，非常抱歉，本次您提出的有问必答问题，技术专家团超时未为您做出解答 本次提问扣除的有问必答次数，已经为您补发到账户，我们后续会持续优化，扩大我们的服务范围，为您带来更好地服务。", "Konwledge_Point": "矩阵乘法", "Question": "matlab关于 cvx sdp的问题\n问题遇到的现象和发生背景\n\n\n我想在cvx sdp中写一个线性不等式的约束条件，如图\n\n\n问题相关代码，请勿粘贴截图\n\n\ncvx_begin sdp\n    variables W1x(\nNt\n,Nt) W2x(\nNt\n,Nt) \n    variable Zx(\nNt\n,Nt)  complex semidefinite\n    variable p13  nonnegative\n    variable p23  nonnegative\n    variable p14  nonnegative\n    variable p24  nonnegative\n S1=(\nh_BI*\n((\n2\n^(\nre\n)\n-1\n)*Zx-W1x)*h_BI')\n;\n\nP13=[k*(\n2\n^(\nre\n)\n-1\n)-p13,zeros(\n1\n,M_irs)\n;zeros(M_irs,1),p13*e*eye(M_irs)];\n\n中间省略\nsubject to\nP13+S3*theta0*S1*theta0'*S3' ==semidefinite(\nM_irs+1\n)\n;\n\n\n\n\n运行结果及报错内容\n\n\n错误使用  *\n用于矩阵乘法的维度不正确。请检查并确保第一个矩阵中的列数与第二个矩阵中的行数匹配。要执行按元素相乘，请使用 '.*'。\n\n\n我的解答思路和尝试过的方法\n\n\n只要加上上述约束条件就不对，但是矩阵维度都检查过了，没有问题，如果把约束条件单独拿出来运行，也不报错，只要放到约束条件里就报错，不知道是不是因为cvx不能检查LMI是否对称，我觉得不是矩阵维度问题，可能是我关于cvx sdp、LMI知识不熟练导致的\n\n\n我想要达到的结果\n\n\n不报错", "Tag": "算法分析"}
{"Answer": "这个搞掂了吗？提供一个 3*3 的样本来测试一下。", "Konwledge_Point": "矩阵乘法", "Question": "Python编程：新矩阵运算\n给定两个大小相同方阵，将经典矩阵乘积运算修改：将原来的元素之间的乘法改为加法，将原来的加法改为取小。 设A=(ai,j) n×n ,B=(bi,j\n)n×n， 新运算的结果为C=(ci,j) n×n，则ci,j = min{ai,k+bk,j,k=1,⋯,n}\n\n\n输入格式:\n第一行输入一个整数n，表示方阵的大小。\n第二行到2n+1行，每一行数据有n个，空格隔开。\n第二行行到n+1行是矩阵A的元素。\n最后n行是矩阵B的元素。\n\n\n说明：n不超过100，矩阵所有元素都是整数。\n\n\n输出格式:\n输出矩阵C\n\n\n输入样例:\n2\n33 44\n33 44\n55 33\n55 33\n输出样例:\n88 66\n88 66\n样例解释：\n矩阵A为\n\n\n33 44\n33 44\n\n\n矩阵B为\n55 33\n55 33\n输出结果矩阵C为\n88 66\n88 66", "Tag": "算法分析"}
{"Answer": "同学，你的indices搞反了\nindices = np.vstack(( arr.row, arr.col)).transpose()\n", "Konwledge_Point": "矩阵乘法", "Question": "关于 tensorflow 1.x sparse_tensor_dense_matmul 的问题\ntf.sparse_tensor_dense_matmul 是对稀疏张量和稠密张量做矩阵乘法的函数，但为什么我运算的结果与 numpy 运算结果不同？\n\n\nimport numpy \nas\n np\nimport tensorflow \nas\n tf\nimport scipy.sparse \nas\n sp\n\narr = np.\narray\n(\n[[\n1.\n,\n2.\n,\n5.\n,\n2.\n]\n,\n[\n3.\n,\n4.\n,\n1.\n,\n2.\n]\n,\n[\n3.\n,\n5.\n,\n2.\n,\n6.\n]\n,\n[\n4.\n,\n13.\n,\n2.\n,\n10.\n]\n]) # \n4\n*\n4\n\narr = sp.coo\n_matrix(\narr\n)\n\n\nb = np.\narray\n(\n[[\n1.\n]\n,\n[\n2.\n]\n,\n[\n3.\n]\n,\n[\n4.\n]\n])\nb = tf.convert\n_to_tensor(\nb\n, \ndtype\n=\ntf\n.\nfloat32\n)\n\n\n\n\nif\n not sp.isspmatrix\n_coo(\narr\n)\n:\n    arr = arr.tocoo\n()\n\n\narr = arr.astype(np.float32)\nindices = np.vstack((arr.col, arr.row)).transpose\n()\n\n\n\na_sp = tf.\nSparseTensor(\nindices\n=\nindices\n, \nvalues\n=\narr\n.\ndata\n, \ndense_shape\n=\narr\n.\nshape\n)\n\n\n\nwith\n tf.\nSession()\n \nas\n sess:\n    m=tf.sparse\n_tensor_dense_matmul(\na_sp\n, \nb\n)\n\n    print(sess.run(m))\n\n\n\n结果：\n\n\n[\n[32.]\n\n \n[77.]\n\n \n[21.]\n\n \n[64.]\n]\n\n\n\n\nnumpy 下：\n\n\nx\n = np.array([[\n1\n,\n2\n,\n5\n,\n2\n],[\n3\n,\n4\n,\n1\n,\n2\n],[\n3\n,\n5\n,\n2\n,\n6\n],[\n4\n,\n13\n,\n2\n,\n10\n]],dtype=np.float)\n\ny\n = np.array([[\n1\n],[\n2\n],[\n3\n],[\n4\n]], dtype=np.float)\n\nx\n @ y\n\n\n\n结果：\n\n\narray(\n[\n[28.]\n,\n       \n[22.]\n,\n       \n[43.]\n,\n       \n[76.]\n]\n\n", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/zufejsjcy/article/details/44604185", "Konwledge_Point": "矩阵乘法", "Question": "矩阵的乘法运算怎么求解？\nLet us consider undirected graph G = \n\nwhich has N vertices and M edges. Incidence matrix of this graph is N * M matrix A = {aij}, such that aij is 1 if i-th vertex is one of the ends of j-th edge and 0 in the other case. Your task is to find the sum of all elements of the matrix ATA.\n\n\n\nThis problem contains multiple test cases!\n\nThe first line of a multiple input is an integer N, then a blank line followed by N input blocks. Each input block is in the format indicated in the problem description. There is a blank line between input blocks.\n\nThe output format consists of N output blocks. There is a blank line between output blocks.\n\n\n\nInput\n\nThe first line of the input file contains two integer numbers - N and M (2 <= N <= 10 000, 1 <= M <= 100 000). 2M integer numbers follow, forming M pairs, each pair describes one edge of the graph. All edges are different and there are no loops (i.e. edge ends are distinct).\n\n\n\nOutput\n\nOutput the only number - the sum requested.\n\n\n\nSample Input\n\n1\n\n\n\n4 4\n\n1 2\n\n1 3\n\n2 3\n\n2 4\n\n\n\nSample Output\n\n18", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/weixin_45268427/article/details/106822204", "Konwledge_Point": "矩阵乘法", "Question": "编写一个Java程序，分别用点乘和叉乘的方法计算两个矩阵的乘法以及特征值?\n编写一个Java程序，分别用点乘和叉乘的方法计算两个矩阵的乘法以及特征值?", "Tag": "算法分析"}
{"Answer": "供参考：\n//【C0369】应用函数输出给定正整数的因子展开式\n#include <stdio.h>\n/* 请在这里填写答案*/\nvoid solve(int x)\n{\n    int i = 2, k = 0;\n    while (x != 1){\n        if (x % i == 0){\n            printf(k++ == 0 ? \"%d\" : \"*%d\", i);\n            x /= i;\n        }\n        else {\n            i++;\n        }\n    }\n}\nint main() {\n    void solve(int);\n    int x;\n    scanf(\"%d\", &x);\n    if (x < 2) printf(\"error data\");\n    else {\n        printf(\"%d=\", x);\n        solve(x);\n    }\n    return 0;\n}\n\n\n//【C0371】应用函数实现矩阵乘法\n//裁判测试程序样例：\n#include <stdio.h>\n/* 请在这里填写答案 */\nvoid f(int a[], int b[], int c[], int m, int n, int t)\n{\n    int i, j, k;\n    for (i = 0; i < m; i++)\n        for (j = 0; j < m; j++)\n            for (k = 0, c[i * t + j] = 0; k < n; k++)\n                c[i * t + j] += a[i * n + k] * b[k * m + j];\n}\nint main() {\n    int i, j, a[3][4], b[4][3], c[3][3];\n    for (i = 0; i < 3; i++)\n        for (j = 0; j < 4; j++)\n            scanf(\"%d\", &a[i][j]);\n    for (i = 0; i < 4; i++)\n        for (j = 0; j < 3; j++)\n            scanf(\"%d\", &b[i][j]);\n    f(a[0], b[0], c[0], 3, 4, 3);\n    for (i = 0; i < 3; i++) {\n        for (j = 0; j < 3; j++)\n            printf(\"%5d\", c[i][j]);\n        printf(\"\\n\");\n    }\n}\n\n\n//6-3 【C0373】应用递归函数实现起泡排序\n//裁判测试程序样例：\n#include <stdio.h>\n#define N 20\n/* 请在这里填写答案 */\nvoid sort(int a[], int n)\n{\n    int tmp;\n    if (n == 1)\n        return;\n    else {\n        for (int i = 0; i < n - 1; i++) {\n            if (a[i] < a[i + 1]) {\n                tmp = a[i];\n                a[i] = a[i + 1];\n                a[i + 1] = tmp;\n            }\n        }\n        sort(a, n - 1);\n    }\n}\nint main() {\n    int a[N], i, n;\n    scanf(\"%d\", &n);\n    if (n > 20) printf(\"error data\");\n    else {\n        for (i = 0; i < n; i++)\n            scanf(\"%d\", &a[i]);\n        sort(a, n);\n        for (i = 0; i < n; i++)\n            printf(\"%5d\", a[i]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n", "Konwledge_Point": "矩阵乘法", "Question": "拼题a上的几个难题，几个同学对照着答案尝试了几次依就报错\n实验题，总是不对\n【C0369】应用函数输出给定正整数的因子展开式\n\n\n完成程序，设计实现函数void solve(int x) ，其功能为输出一个给定正整数x（x>1）的质因子展开式。\n\n\n函数接口定义：\nvoid solve(int x);/\n功能为输出一个给定正整数x（x>1）的质因子展开式\n/\n裁判测试程序样例：\n#include \n\n\n/* 请在这里填写答案 */\n\n\nint main(){\n    void solve(int);\n    int x;\n    scanf(\"%d\",&x);\n    if(x<2)  printf(\"error data\");\n    else{\n        printf(\"%d=\",x);\n        solve(x);\n    }\n    return 0;\n}\n输入格式：\n请在一行中输入整数x的值。\n\n\n输出格式：\n对每一组输入的x，按以下格式输出x的质因子展开式（假如x的质因子分别为a、b、c）：\n\n\nx=a\nb\nc\n\n\n输入样例1：\n72\n输出样例1：\n72=2\n2\n2\n3\n3\n输入样例2：\n1\n输出样例2：\nerror data\n输入样例3：\n5\n输出样例3：\n5=5\n\n\n【C0371】应用函数实现矩阵乘法\n\n\n完成程序，设计实现函数void f(int a[],int b[],int c[],int m,int n,int t)，其功能为计算给定的两个整型数组（一个为m行n列，一个为n行t列）的乘积矩阵。\n\n\n函数接口定义：\nvoid f(int a[],int b[],int c[],int m,int n,int t);/\n功能为计算给定的矩阵a（m行n列）和矩阵b（n行t列）的乘积矩阵c\n/\n裁判测试程序样例：\n#include \n\n\n/* 请在这里填写答案 */\n\n\nint main(){\n    int i,j,a[3][4],b[4][3],c[3][3];\n    for(i=0; i<3; i++)\n        for(j=0; j<4; j++)\n            scanf(\"%d\",&a[i][j]);\n    for(i=0; i<4; i++)\n        for(j=0; j<3; j++)\n            scanf(\"%d\",&b[i][j]);\n    f(a[0],b[0],c[0],3,4,3);\n    for(i=0; i<3; i++){\n        for(j=0; j<3; j++)\n            printf(\"%5d\",c[i][j]);\n        printf(\"\\n\");\n    }\n}\n输入格式：\n首先输入整型数组a[3][4]的各元素的值，再输入整型数组b[4][3]的各元素的值，数据中间以空格为间隔。\n\n\n输出格式：\n对于输入的a数组和b数组，输出a和b的乘积矩阵c[3][3]，其中每个元素显示格式为：占5列，右对齐。\n\n\n输入样例：\n1 2 3 4\n2 3 4 5\n3 4 5 6\n1 2 3\n2 3 4\n3 4 5\n4 5 6\n输出样例：\n   30   40   50\n   40   54   68\n   50   68   86\n\n\n6-3 【C0373】应用递归函数实现起泡排序\n\n\n完成程序，设计实现递归函数void sort(int a[],int n)，其功能为使用“起泡法”对a数组存储的n（n<=20）个数按从大到小排序，排列后任然存储a数组中。\n\n\n函数接口定义：\nvoid sort(int a[],int n);/*功能为使用“起泡法”对a数组存储的n（n<=20）个数按从大到小排序，排列后任然存储a数组中*/\n裁判测试程序样例：\n#include \n#define N 20\n\n\n/* 请在这里填写答案 */\n\n\nint main(){\n    int a[N],i,n;\n    scanf(\"%d\",&n);\n    if(n>20)  printf(\"error data\");\n    else{\n        for(i=0; i<n; i++)\n            scanf(\"%d\",&a[i]);\n        sort(a,n);\n        for(i=0; i<n; i++)\n            printf(\"%5d\",a[i]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n输入格式：\n请在第一行中输入整数n的值，表示数据的个数。\n\n\n在第二行中输入n个无序整数，数据中间以空格为间隔。\n\n\n输出格式：\n对每一组输入的n个无序整数，输出按照从小到大顺序的排序结果，其中每个数显示格式为：占5列，右对齐。\n\n\n输入样例1：\n10\n1 2 3 4 5 0 9 8 7 6\n输出样例1：\n    9    8    7    6    5    4    3    2    1    0\n输入样例2：\n45\n输出样例2：\nerror data", "Tag": "算法分析"}
{"Answer": "请问有哪里需要解答的地方吗？\n#include<stdio.h>\nint main()\n{\n    int a[20][20],b[20][20],c[20][20]={0},i,j,k,min,max,n;\n    scanf(\"%d\",&n);\n    for(i=0;i<=n-1;++i)\n        for(j=0;j<=n-1;++j)\n            scanf(\"%d\",&a[i][j]);\n    for(i=0;i<=n-1;++i)\n        for(j=0;j<=n-1;++j)\n            scanf(\"%d\",&b[i][j]);\n    for(i=0;i<=n-1;++i)\n        for(j=0;j<=n-1;++j)\n            for(k=0;k<=n-1;++k)\n                c[i][j]+=a[i][k]*b[k][j];\n    min=max=c[0][0];\n    for(i=0;i<=n-1;++i)\n        for(j=0;j<=n-1;++j)\n        {\n            if(min>c[i][j])\n                min=c[i][j];\n            if(max<c[i][j])\n                max=c[i][j];\n        }\n    for(i=0;i<=n-1;++i)\n    {\n        for(j=0;j<=n-1;++j)\n        {\n            printf(\"%d\",c[i][j]);\n            if(j!=n-1)\n                printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n    printf(\"%d %d\",min,max);\n    return 0;\n}\n\n", "Konwledge_Point": "矩阵乘法", "Question": "C语言编程问题求解答\n题目描述\n矩阵int a[n][n]，矩阵int b[n][n]（1≤n≤20）。矩阵的大小和数据由用户输入。输出新的矩阵c=a*b，以及其中的最小值和最大值，输出格式：\nc00      c01      c02      ……  c0(n-2)      c0(n-1)\nc10      c11      c12      ……  c1(n-2)      c1(n-1)\nc20      c21      c22      ……  c2(n-2)      c2(n-1)\n……     ……     ……     ……  ……         ……\nc(n-2)0  c(n-2)1  c(n-2)2  ……  c(n-2)(n-2)  c(n-2)(n-1)\nc(n-1)0  c(n-1)1  c(n-1)2  ……  c(n-1)(n-2)  c(n-1)(n-1)\ncmin cmax\n\n\n矩阵乘法的计算方法 :\n对于矩阵A[n][n]*B[n][n]，\n相乘的结果为矩阵C[n][n]，且对于矩阵C中每一项都有\nC[i][j] = A[i][0]*B[0][j] + A[i][1]*B[1][j] + ..... + A[i][n-1]*B[n-1][j]\n\n\n关于输入\n第一行为矩阵的大小，后面跟着输入两个矩阵\nn\na00      a01      a02      ……  a0(n-2)      a0(n-1)\na10      a11      a12      ……  a1(n-2)      a1(n-1)\na20      a21      a22      ……  a2(n-2)      a2(n-1)\n……     ……     ……     ……  ……         ……\na(n-2)0  a(n-2)1  a(n-2)2  ……  a(n-2)(n-2)  a(n-2)(n-1)\na(n-1)0  a(n-1)1  a(n-1)2  ……  a(n-1)(n-2)  a(n-1)(n-1)\nb00      b01      b02      ……  b0(n-2)      b0(n-1)\nb10      b11      b12      ……  b1(n-2)      b1(n-1)\nb20      b21      b22      ……  b2(n-2)      b2(n-1)\n……     ……     ……     ……  ……         ……\nb(n-2)0  b(n-2)1  b(n-2)2  ……  b(n-2)(n-2)  b(n-2)(n-1)\nb(n-1)0  b(n-1)1  b(n-1)2  ……  b(n-1)(n-2)  b(n-1)(n-1)\n\n\n关于输出\n矩阵c\nc00      c01      c02      ……  c0(n-2)      c0(n-1)\nc10      c11      c12      ……  c1(n-2)      c1(n-1)\nc20      c21      c22      ……  c2(n-2)      c2(n-1)\n……     ……     ……     ……  ……         ……\nc(n-2)0  c(n-2)1  c(n-2)2  ……  c(n-2)(n-2)  c(n-2)(n-1)\nc(n-1)0  c(n-1)1  c(n-1)2  ……  c(n-1)(n-2)  c(n-1)(n-1)\ncmin cmax\n\n\n例子输入\n3\n1 2 3\n4 5 6\n7 8 9\n1 2 3\n4 5 6\n7 8 9\n例子输出\n30 36 42\n66 81 96\n102 126 150\n30 150\n提示信息\n注意矩阵边界，以防计算时越界", "Tag": "算法分析"}
{"Answer": "以下答案引用自GPT-3大模型,请合理使用：\n示例，谢谢\n\n这可能是因为使用了不正确的共享内存的实现，或者由于没有考虑到适当的优化。如果要使用共享内存，则需要确保使用一致的数据结构和传输方式，以便每个线程可以快速访问内存中的数据。这样可以减少CPU和GPU之间的交互，大大加快计算性能。\n\n此外，还有一些实用的优化技巧，比如常量表达式计算，以及使用特定于 GPU 的指令集和函数，可以使代码更加有效。以下是一个示例，实现本问题的优化版本：\n\n@cuda.jit\ndef arggetmin_opt(Fitness, IN_index, OutResult, OutIndex, n):\n    tid = cuda.threadIdx.x;\n    idx = cuda.threadIdx.x + cuda.blockIdx.x * cuda.blockDim.x\n    tmp = cuda.shared.array(shape=BLOCK_SIZE, dtype=float32)\n    index = cuda.shared.array(shape=BLOCK_SIZE, dtype=int32)\n    tmp[tid] = MAX\n    if (tid > n): return\n\n    #将数据传入共享内存\n    if (idx < n):\n        tmp[tid] = Fitness[idx]\n        index[tid] = IN_index[idx]\n    else:\n        tmp[tid] = MAX\n        index[tid] = IN_index[idx]\n\n    cuda.syncthreads();\n\n    #没个块内进行归约处理\n    stride = cuda.blockDim.x \n    while stride > 0:\n        if (tid < stride):\n            if (tmp[tid] > tmp[tid + (stride >>1)]):\n                tmp[tid] = tmp[tid + (stride >>1)]\n                index[tid] = index[tid + (stride >>1)]\n        cuda.syncthreads()\n        stride = (stride >> 1) \n\n    if (tid == 0):\n        OutResult[cuda.blockIdx.x] = tmp[0]\n        OutIndex[cuda.blockIdx.x] = index[0]\n\n如果我的回答解决了您的问题，请采纳我的回答", "Konwledge_Point": "矩阵乘法", "Question": "在GPU进行最小值归约运行时间比CPU长\n函数实现目的：求大小为100的一维数组最小值的下标，使用的归约运算\n\n\n出现问题：GPU总比CPU运行时间久（GPU：MX150，CPU：i5 8th）\n\n\n\n\n@cuda.jit\ndef arggetmin(Fitness, IN_index, OutResult, OutIndex, n):\n    \ntid\n = cuda.threadIdx.x;\n    \nidx\n = cuda.threadIdx.x + cuda.blockIdx.x * cuda.blockDim.x\n    \ntmp\n = cuda.shared.array(\nshape=BLOCK_SIZE,\n \ndtype=float32)\n\n    \nindex\n = cuda.shared.array(\nshape=BLOCK_SIZE,\n \ndtype=int32)\n\n    tmp[tid] = MAX\n    \nif\n (tid > n): return\n\n    \n#将数据传入共享内存\n\n    \nif\n (idx < n):\n        tmp[tid] = Fitness[idx]\n        index[tid] = IN_index[idx]\n    \nelse\n:\n        tmp[tid] = MAX\n        index[tid] = IN_index[idx]\n\n    cuda.syncthreads();\n\n    \n#没个块内进行归约处理\n\n    \nstride\n = int(cuda.blockDim.x / \n2\n)\n    while stride > \n0\n:\n        \nif\n (tid < stride):\n            \nif\n (tmp[tid] > tmp[tid + stride]):\n                tmp[tid] = tmp[tid + stride]\n                index[tid] = index[tid + stride]\n        cuda.syncthreads()\n        \nstride\n = int(stride / \n2\n)\n\n    \nif\n (\ntid\n == \n0\n):\n        OutResult[cuda.blockIdx.x] = tmp[\n0\n]\n        OutIndex[cuda.blockIdx.x] = index[\n0\n]\n\ndef main():\n    \nn\n = \n100\n        \n#数组大小\n\n   \n   \n#生成数组和下标\n\n    \na\n = getRamdomlist(n)\n    \nindex\n = getIndex(n)\n    \n    \n#传入到GPU中\n\n    \na_device\n = cuda.to_device(a)\n    \nindex_device\n = cuda.to_device(index)\n\n    \nthreads_per_block\n = BLOCK_SIZE\n    \nblock_per_grid\n = math.ceil(n / threads_per_block)\n    \ngpu_result\n = cuda.device_array(\nshape=block_per_grid,\n \ndtype=float)\n \n    \ngpu_index\n = cuda.device_array(\nshape=block_per_grid,\n \ndtype=int)\n\n\n    \n#GPU部分\n\n    \ntime1\n = perf_counter()\n    arggetmin[block_per_grid, threads_per_block](a_device, index_device, gpu_result, gpu_index, n)\n    cuda.synchronize()\n    \ntime2\n = perf_counter()\n    print(\n\"matmul GPU time :\"\n, (time2 - time1))\n  \n    \n#CPU部分\n\n    \nstart\n = perf_counter()\n    \ninnn\n = np.argmin(a)\n    \nend\n = perf_counter()\n    print(\n\"matmul CPU time :\"\n, (end - start))\n\n\n\nif\n \n__name__\n == \n\"__main__\"\n:\n    main()\n\n\n\n\n\nGPU运算时间0.5s左右，CPU运算时间0.0005s左右\n\n\n使用过“循环展开”的方法，但结果更加糟糕。（运行Nvidia官方的“矩阵乘法”的代码时，使用共享内存的代码比不使用共享内存的代码要慢）\n\n\n为什么会出现这种情况，一直不太明白", "Tag": "算法分析"}
{"Answer": "14行，i=i++改成i++10、11行删掉函数定义都是错误的。改成void jiajia(int a[4][4],int b[4][4],int c[4][4])，乘法相同。将a+b和a*b的结果写入c数组就行貌似你jiajia函数直接输出结果了，可以不用将c[4][4]作为参数，但你输出语句啥内容也没写，cout<<endl;这只是输出换行啊。cout<<c[i][j]<<\" \";if(i%4==0)      cout<<endl;", "Konwledge_Point": "矩阵乘法", "Question": "想计算C++矩阵加法乘法为什么得不到结果？\n\n", "Tag": "算法分析"}
{"Answer": "import numpy as np\nn=int(input(\"n:\"))\nm=int(input(\"m:\"))\n# 生成随机矩阵\nprint('生成随机矩阵')\nlist1=np.random.randint(n,size=m*n)\nlist2=np.random.randint(n,size=m*n)\nprint(list1)\nprint(list2)\n\n# 矩阵相加\nprint('矩阵相加')\nlist3=list1+list2\nprint(list3)\n# 矩阵相减\nprint('矩阵相减')\nlist4=list1-list2\nprint(list4)\n# 矩阵和数相乘\nprint('矩阵和数相乘')\nlist4=list1*5\nprint(list4)\n# n1m和mn2二维的矩阵 n1*n2的矩阵的乘法运算\nprint('n1m和mn2二维的矩阵 n1*n2的矩阵的乘法运算')\nlist1=list1.reshape(n,m)\nlist2=list2.reshape(n,m)\nprint(list1)\nprint(list2)\nlist5=list1*list2\nprint(list5)\n\n", "Konwledge_Point": "矩阵乘法", "Question": "生成由随机整数构成的n*m的二维矩阵\n生成由随机整数构成的n*m的二维矩阵\n\n\n（5.2）生成n*n维的单位矩阵\n\n\n（5.3）实现矩阵相加的运算，注意只有相同维度的矩阵才能进行加减运算。\n\n\n（5.4）实现矩阵相减的运算，注意只有相同维度的矩阵才能进行加减运算。\n\n\n（5.5）实现矩阵和数相乘的运算\n\n\n（5.6）实现n1\nm和m\nn2二维的矩阵，并得到n1*n2的矩阵的乘法运算。", "Tag": "算法分析"}
{"Answer": "\n#define _CRT_SECURE_NO_WARNINGS\n#include<stdio.h>\nint main()\n{\n  int a[10][10], b[10][10], c[10][10];\n  int n;\n  printf(\"方阵阶数: \");\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < n; j++)\n      scanf(\"%d\", &a[i][j]);\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < n; j++)\n      scanf(\"%d\", &b[i][j]);\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = 0; j < n; j++)\n    {\n      c[i][j] = 0;\n      for (int k = 0; k < n; k++)\n        c[i][j] += a[i][k] * b[k][j];\n      printf(\"%10d\", c[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}\n", "Konwledge_Point": "矩阵乘法", "Question": "C语言中求解方阵乘法运算\n【问题描述】\n    从键盘输入一个正整数n（n∈[1,10]），表示进行乘法运算的两个整形方阵的阶。然后分别输入两个整形方阵A和B，计算A×B后将结果输出到屏幕。\n【输入形式】\n    从键盘输入一个正整数，然后再输入两个整形方阵。\n【输出形式】\n    在屏幕上输出两个整形方阵的乘积。\n【输入样例】\n3\n1 1 1\n3 3 3\n6 6 6\n9 9 9\n6 6 6\n5 5 5\n【输出样例】\n########20########20########20\n########60########60########60\n#######120#######120#######120\n【样例说明】\n首先输入正整数3,说明接下来要输入的方阵是3×3的。因为\n1 1 1         9 9 9          20  20  20\n3 3 3  ×   6 6 6    =    60  60  60\n6 6 6        5 5 5          120 120 120\n所以在屏幕上打印：\n########20########20########20\n########60########60########60\n#######120#######120#######120\n注：\"#\"代表空格，每个输出的整数占10位，不足10位在整数的左边用空格补足。\n\n\n#\ninclude\n\n\n \nint\n \nmain\n()\n\n\n{   \nint\n a[\n3\n][\n3\n], b[\n3\n][\n3\n], c[\n3\n][\n3\n];\n    \nint\n i, j, k, sum;\n    \nprintf\n(\n\"输入一个3*3的矩阵：\\n\"\n);\n    \nfor\n(i=\n0\n;i<\n3\n;i++)                    \n//处理矩阵a中的一行中各元素\n\n     \nfor\n(j=\n0\n;j<\n3\n;j++)               \n//处理矩阵a中某一列中各元素\n\n   \nscanf\n(\n\"%d\"\n,&a[i][j]);   \n//输入数据\n\n \nprintf\n(\n\"输入一个3*3的矩阵；\\n\"\n);\n \nfor\n(i=\n0\n;i<\n3\n;i++)                   \n//处理矩阵b中的一行中各元素\n\n  \nfor\n(j=\n0\n;j<\n3\n;j++)               \n//处理矩阵b中某一列中各元素\n\n   \nscanf\n(\n\"%d\"\n,&b[i][j]);    \n//输入数据\n\n \nfor\n(i=\n0\n;i<\n3\n;i++)                 \n//对矩阵c进行处理\n\n { \nfor\n(j=\n0\n;j<\n3\n;j++)\n  { sum=\n0\n;\n   \nfor\n(k=\n0\n;k<\n4\n;k++)   \n//矩阵c中每一个元素的循环计算\n\n   {\n     sum+=a[i][k]*b[k][j]; \n//对矩阵c中的某一元素进行计算\n\n   }\n   c[i][j]=sum;           \n//给矩阵c中的某一元素进行赋值\n\n  }\n }\n \nprintf\n(\n\"得到一个3×3的矩阵：\\n\"\n);\n \nfor\n(i=\n0\n;i<\n3\n;i++)            \n//输出矩阵c\n\n {\n  \nfor\n(j=\n0\n;j<\n3\n;j++)\n    \nprintf\n(\n\"%5d\"\n,c[i][j]);\n   \nprintf\n(\n\"\\n\"\n);\n   }\n   \nreturn\n \n0\n;\n}\n\n\n\n\n我的运算结果是错的，然后输出也不对，不知道怎么去修改。", "Tag": "算法分析"}
{"Answer": "*是对应位置相乘你写数字 *矩阵可以，但是最后两行是矩阵 *矩阵了，维度没法对应相乘，就报错了np.multiply(H,G)和H *G是一个意思，表示矩阵点乘\n我看你测试的样子，应该是想测试multiply和dot函数吧，应该写：\nprint(np.multiply(H,G))   #这里也会报错，因为维度不匹配\nprint(np.dot(G,E))\n\n有帮助麻烦点个采纳～～", "Konwledge_Point": "矩阵乘法", "Question": "Python的乘法出错问题，operands could not be broadcast together with shapes (3,3) (3,2)\n\n\nimport\n numpy as np\n\nA\n = np.array([\n5\n, -\n2\n])\n\nB\n = np.array([\n1\n, \n6\n, \n2\n, \n0\n, -\n1\n, -\n1\n])\n\nC\n = np.array([\n2\n, \n0\n, -\n1\n, \n3\n, -\n1\n, \n6\n])\n\nD\n = np.array([\n3\n, \n0\n, \n1\n, \n1\n, -\n2\n, \n2\n, \n3\n, \n4\n, -\n1\n])\n\n\nE\n = A.reshape((\n2\n, \n1\n))\n\nF\n = B.reshape((\n3\n, \n2\n))\n\nG\n = C.reshape((\n3\n, \n2\n))\n\nH\n = D.reshape((\n3\n, \n3\n))\n\n\nprint\n(-\n2\n*E)\n\nprint\n(G + F)\n\nprint\n(\n4\n*F - G)\n\nprint\n(np.multiply(H*G))\n\nprint\n(np.dot(G*E))\n\n\n\n最后两行总是出错，是个什么原因？（倒数第二行是一个（3,3）\n（3,2）的矩阵，倒数第一行是一个（3,2）\n（2,1）的矩阵）", "Tag": "算法分析"}
{"Answer": "这里全是静态方法直接LeastSquare.方法(参数)这样调用就行了", "Konwledge_Point": "矩阵乘法", "Question": "怎样调用下面最小二乘法的类，并运行测试\n\npublic \nclass\n LeastSquare\n//最小二乘法\n\n    {\n        \n///\n\n        \n///用最小二乘法拟合二元多次曲线（任意次）\n\n        \n///\n\n        \n///已知点的x坐标集合\n\n        \n///已知点的y坐标集合\n\n        \n///已知点的个数\n\n        \n///方程的最高次数\n\n        #region 总计算方法\n        public static double\n[]\n \nMultiLine(\ndouble\n[] \narrX\n, \ndouble\n[] \narrY\n, \nint\n \nlength\n, \nint\n \ndimension\n)\n//二元多次线性方程拟合曲线\n\n        {\n            \nint\n n = dimension + \n1\n;                  \n//dimension次方程需要求 dimension+1个 系数\n\n            double\n[,]\n Guass = \nnew\n double\n[\nn\n, \nn\n + \n1\n]\n;      \n//高斯矩阵 例如：y=a0+a1*x+a2*x*x\n\n            \nfor\n (\nint\n i = \n0\n; i < n; i++)\n            {\n                \nint\n j;\n                \nfor\n (j = \n0\n; j < n; j++)\n                {\n                    Guass\n[\ni\n, \nj\n]\n = \nSumArr(\narrX\n, \nj\n + \ni\n, \nlength\n)\n;\n                }\n                Guass\n[\ni\n, \nj\n]\n = \nSumArr(\narrX\n, \ni\n, \narrY\n, 1, \nlength\n)\n;\n            }\n            return \nComputGauss(Guass, \nn\n)\n;\n//返回值是函数的系数\n\n        }\n        #endregion\n        #region 求数组的元素的n次方的和\n1\n(中间方法)\n        public static double \nSumArr(\ndouble\n[] \narr\n, \nint\n \nn\n, \nint\n \nlength\n)\n \n        {\n            double s = \n0\n;\n            \nfor\n (\nint\n i = \n0\n; i < length; i++)\n            {\n                \nif\n (arr\n[\ni\n]\n != \n0\n || \nn != \n0\n)\n                    s = s + Math.\nPow(\narr\n[\ni\n], \nn\n)\n;\n                \nelse\n\n                    s = s + \n1\n;\n            }\n            return s;\n        }\n        #endregion\n        #region 求数组的元素的n次方的和\n2\n(中间方法)\n        public static double \nSumArr(\ndouble\n[] \narr1\n, \nint\n \nn1\n, \ndouble\n[] \narr2\n, \nint\n \nn2\n, \nint\n \nlength\n)\n\n        {\n            double s = \n0\n;\n            \nfor\n (\nint\n i = \n0\n; i < length; i++)\n            {\n                \nif\n ((arr1\n[\ni\n]\n != \n0\n || \nn1 != \n0\n)\n && \n(arr2\n[\ni\n]\n != \n0\n || \nn2 != \n0\n))\n                    s = s + Math.\nPow(\narr1\n[\ni\n], \nn1\n)\n * \nMath.\nPow(\narr2\n[\ni\n], \nn2\n)\n;\n                \nelse\n\n                    s = s + \n1\n;\n            }\n            return s;\n \n        }\n        #endregion\n        #region 返回值是函数的系数(中间方法)\n        public static double\n[]\n \nComputGauss(\ndouble\n[,] Guass, \nint\n \nn\n)\n\n        {\n            \nint\n i, j;\n            \nint\n k, m;\n            double temp;\n            double max;\n            double s;\n            double\n[]\n x = \nnew\n double\n[\nn\n]\n;\n            \nfor\n (i = \n0\n; i < n; i++) x\n[\ni\n]\n = \n0.0\n;\n//初始化\n\n \n            \nfor\n (j = \n0\n; j < n; j++)\n            {\n                max = \n0\n;\n                k = j;\n                \nfor\n (i = j; i < n; i++)\n                {\n                    \nif\n (Math.\nAbs(Guass[\ni\n, \nj\n])\n > max)\n                    {\n                        max = Guass\n[\ni\n, \nj\n]\n;\n                        k = i;\n                    }\n                }\n \n \n                \nif\n (k != j)\n                {\n                    \nfor\n (m = j; m < n + \n1\n; m++)\n                    {\n                        temp = Guass\n[\nj\n, \nm\n]\n;\n                        Guass\n[\nj\n, \nm\n]\n = Guass\n[\nk\n, \nm\n]\n;\n                        Guass\n[\nk\n, \nm\n]\n = temp;\n                    }\n                }\n                \nif\n (\n0\n == \nmax)\n                {\n                    \n// \"此线性方程为奇异线性方程\" \n\n                    return x;\n                }\n \n                \nfor\n (i = j + \n1\n; i < n; i++)\n                {\n                    s = Guass\n[\ni\n, \nj\n]\n;\n                    \nfor\n (m = j; m < n + \n1\n; m++)\n                    {\n                        Guass\n[\ni\n, \nm\n]\n = Guass\n[\ni\n, \nm\n]\n - Guass\n[\nj\n, \nm\n]\n * \ns\n / \n(Guass\n[\nj\n, \nj\n]\n);\n                    }\n                }\n \n            }\n//结束for (j=0;j= \n0\n; i--)\n            {\n                s = \n0\n;\n                \nfor\n (j = i + \n1\n; j < n; j++)\n                {\n                    s = s + Guass\n[\ni\n, \nj\n]\n * \nx\n[\nj\n]\n;\n                }\n                x\n[\ni\n]\n = (Guass\n[\ni\n, \nn\n]\n - s)\n / \nGuass\n[\ni\n, \ni\n]\n;\n            }\n            return x;\n        }\n#endregion\n    }\n\n\n\n参考于C#利用最小二乘法拟合任意次函数曲线\n作者：未来无限", "Tag": "算法分析"}
{"Answer": "参考GPT和自己的思路，一、要证明集合G关于矩阵的乘法构成一个群，需要满足以下四个条件：\n1  闭合性：对于G中的任意两个元素A和B，它们的积AB仍然属于G。\n2  结合律：对于G中的任意三个元素A、B和C，满足(A B)C=A (BC)。\n3  单位元：存在一个单位元I，使得对于G中的任意元素A，都有AI=IA=A。\n4  逆元：对于G中的任意元素A，存在一个逆元A'，使得AA'=A'A=I。\n我们逐一证明这四个条件：\n1  对于任意两个元素A和B，由于IA=AI=A和IB=BI=B，所以IA(IB)=A(BI)=AB，因此AB∈G，G对于矩阵的乘法是闭合的。\n2  对于任意三个元素A、B和C，由于G中的元素满足IA=AI=A和IB=BI=B和IC=CI=C，所以((AB)C)D=(AB)(CD)=A(BC)D=A(B(CD))=A(BD)，因此G对于矩阵的乘法是结合的。\n3  存在一个单位元I，使得对于G中的任意元素A，都有AI=IA=A。当A的行列式为1时，A即为行列式为1的n阶矩阵，此时有AI=IA=A。\n4  对于任意元素A，由于G中的元素满足IA=AI=A和IA=-A，因此A的行列式只可能是1或-1。当A的行列式为1时，A即为行列式为1的n阶矩阵，此时存在一个逆元A'，使得AA'=A'A=I。当A的行列式为-1时，A不属于G，因此不考虑该情况。\n综上所述，集合G关于矩阵的乘法构成一个群。\n二、要证明关系w是等价关系，需要满足以下三个条件：\n1  自反性：对于GLn(R)中的任意矩阵A，都有A w A。\n2  对称性：对于GLn(R)中的任意矩阵A和B，如果A w B，则B w A。\n3  传递性：对于GLn(R)中的任意矩阵A、B和C，如果A w B且B w C，则A w C。\n我们逐一证明这三个条件：\n1  对于GLn(R)中的任意矩阵A，有AI=IA=A和A(A-1)=I，因此A(A-1)A=A，即AA=A(A-1)A属于G。因此A w A，关系w具有自反性。2  对于GLn(R)中的任意矩阵A和B，如果A w B，则存在矩阵C，使得AC=B，即A(B-1)=C属于G。则有B(A-1)=(A(B-1))(-1)属于G，因此B w A，关系w具有对称性。\n3  对于GLn(R)中的任意矩阵A、B和C，如果A w B且B w C，则存在矩阵D和E，使得AD=B，BE=C，即A(B-1)=D属于G和B(C-1)=E属于G。则有A(C-1)=(A(B-1))(B(C-1))属于G，因此A w C，关系w具有传递性。\n综上所述，关系w是等价关系。", "Konwledge_Point": "矩阵乘法", "Question": "求解高等代数相关问题解答\n设G＝｛A∈Mn(Z)I IAI＝1或IAI＝-1｝，其中Mn(Z)是指由元素皆为整数的所有n阶矩阵构成的集合\n一，证明集合G关于矩阵的乘法构成一个群\n二，设GLn(R)＝｛A∈Mn(R)I IAI≠0｝为一般线性群，在GLn(R)上定义一个关系w如下，对GLn(R)中任意两个矩阵A和B，如果A (B-1)∈G，那么称A和N满足关系w，记作AwB，证明，关系w是等价关系", "Tag": "算法分析"}
{"Answer": "你好，xy构成的多项式也可以写，但是比较繁琐，而且求解很难满足最后一个条件，全局大于0，下面是我的一维拓展方案：主函数：\n%% 为了得到分布，假设了一个协方差矩阵\nmu=[20,180];%数学期望\nsigma=[20/3 0;0,60].^2;%协方差矩阵\nr=mvnrnd(mu,sigma,100000);%生成100000个样本\nx = r(:,1);\ny = r(:,2);\n[X, Y, C, xmid, ymid] = ef2(x,y,21,21,[0,40],[0,360]);% ,50,50,[-3, 3],[-3, 3]\nC = C/(18*2);\nfigure(1);clf;\nbar3(C)\ntitle('原先数据')\nxtick = 1:size(C,2); xticklabel = xmid; % xtick和xticklabel一定要对应，长度相等\nytick = 1:size(C,1); yticklabel = ymid; % ytick和yticklabel一定要对应，长度相等\nset(gca, 'xtick', xtick, 'xticklabel',xticklabel,...\n    'ytick', ytick, 'yticklabel',yticklabel)\nxlabel('X')\nylabel('Y')\nx = X(:);\ny = Y(:);\nz = C(:);\n\n\nn = 7; % n为多项式的阶数，参数一共为(n+1)²个\n[i1, i2] = meshgrid(0:n);\nF = arrayfun(@(i)x.^i1(i).*y.^i2(i), 1:numel(i1), 'uniform', 0);\nF = cell2mat(F);\n\nA = F'*F;\nb = F'*z;\na = A\\b;%最小二乘法\n\nzfit1 = polyfunval(X,Y,a,n);\nfigure(2);clf;\nbar3(zfit1)\nxtick = 1:size(C,2); xticklabel = xmid; % xtick和xticklabel一定要对应，长度相等\nytick = 1:size(C,1); yticklabel = ymid; % ytick和yticklabel一定要对应，长度相等\nset(gca, 'xtick', xtick, 'xticklabel',xticklabel,...\n    'ytick', ytick, 'yticklabel',yticklabel)\ntitle('最小二乘法')\n\nG = arrayfun(@(i)40^(i1(i)+1)*360^(i2(i)+1)/((i1(i)+1)*(i2(i)+1)), 1:numel(i1));\naa = [A, G'; G,1]\\[b;1];\nzfit2 = polyfunval(X,Y,aa,n);\nfigure(3);clf;\nbar3(zfit2)\nfprintf('zfit最小值%f\\n', min(zfit2(:)))\nxtick = 1:size(C,2); xticklabel = xmid; % xtick和xticklabel一定要对应，长度相等\nytick = 1:size(C,1); yticklabel = ymid; % ytick和yticklabel一定要对应，长度相等\nset(gca, 'xtick', xtick, 'xticklabel',xticklabel,...\n    'ytick', ytick, 'yticklabel',yticklabel)\ntitle('最小二乘法+拉格朗日乘子法（保证积分为1）')\npause(0.01)\n\na = getIniA(x,y,z,n);\noptions = optimoptions('fmincon','Algorithm','interior-point');% \nflag = -1; %设初始不收敛\nf = @(a)myfun(a,x,y,z,n);\nnlinf = @(a)nlinfunc(a,x,y,n);\n\nwhile(flag<=0)\n    ratio = 0.1;%如果长时间不收敛，减少n或者改动ratio再计算\n    [aa,~,flag] = fmincon(f,a+ratio*(rand(size(a))-0.5).*a,[],[],G,1, [], [], nlinf,options);\nend\n\n多项式求值函数polyfunval.m\nfunction f = polyfunval(x,y,a,n)\n[i1, i2] = meshgrid(0:n);\nCfit = arrayfun(@(i)a(i)*x.^i1(i).*y.^i2(i), 1:numel(i1), 'uniform', 0);\nf = Cfit{1};\nfor i = 2:numel(Cfit)\n    f = f + Cfit{i};\nend\nend\n\n目标函数：优化函数\nfunction f = myfun(a,x,y,z,n)\nzf = polyfunval(x,y,a,n);\nf = norm(zf-z);\nend\n\n非线性约束\nfunction [c,ceq] = nlinfunc(a,x,y,n)\nF = polyfunval(x,y,a,n);\nc = - min(F);\nceq = [];\nend\n\n分布统计函数\nfunction [X, Y, CDF, xmid, ymid] = ef2(x,y,nx,ny,xminmax,yminmax)\n% x：x的值\n% y：y的值\n% nx：x方向划分段数\n% ny：y方向划分段数\n% xminmax = [xmin, xmax]\n% yminmax = [ymin, ymax]\nnum = length(x);\nif(num~=length(y))\n   error('输入的x和y长度必须相等') \nend\nif(nargin>6) % 如果变量个数大于6个，太多了\n    error('太多输入变量')\nelseif(nargin<2) % 如果变量个数小于2个，太少了\n    error('输入变量数目不足!!')\nend\nif(nargin==6) % 如果变量个数等于6个，赋值给ymin和ymax\n    ymin = yminmax(1);\n    ymax = yminmax(2);\nend\nif(nargin>=5)% 如果变量个数大于等于5个，赋值给xmin和xmax\n    xmin = xminmax(1);\n    xmax = xminmax(2);\nend\nif(nargin<=4)% 如果变量个数小于等于4个，自定义xmin和xmax\n    xmin = min(x);\n    xmax = max(x)+eps;\n    ymin = min(y);\n    ymax = max(y)+eps;\nend\nif(nargin<=3)% 如果变量个数小于等于3个，自定义y方向划分段数ny\n    ny = 30;\nend\nif(nargin==2)% 如果变量个数等于2个，自定义x方向划分段数nx\n    nx = 30;\nend\nxg = linspace(xmin, xmax, nx);%x方向的点\nyg = linspace(ymin, ymax, ny);%y方向的点\nxmid = (xg(1:end-1)+xg(2:end))/2;\nymid = (yg(1:end-1)+yg(2:end))/2;\n[X,Y] = meshgrid(xmid, ymid);%形成网格\n[I,J] = meshgrid(2:nx, 2:ny);%下标网格\nCDF = arrayfun(@(i,j)sum(x>=xg(i-1)&x<xg(i)&y<yg(j)&y>=yg(j-1))/num,I,J);%形成经验分布\nend\n\n初始化参数函数\nfunction aa = getIniA(x,y,z, n)\n % n为多项式的阶数，参数一共为(n+1)²个\n[i1, i2] = meshgrid(0:n);\nF = arrayfun(@(i)x.^i1(i).*y.^i2(i), 1:numel(i1), 'uniform', 0);\nF = cell2mat(F);\nA = F'*F;\nb = F'*z;\nG = arrayfun(@(i)40^(i1(i)+1)*360^(i2(i)+1)/((i1(i)+1)*(i2(i)+1)), 1:numel(i1));\naa = [A, G'; G,1]\\[b;1];\naa = aa(1:end-1);\nend\n\n最后可见zfit最小值为-1e-7，很小（但不是正数），只满足了多项式拟合和积分为1的优化。全局为0搜索非常久也难得到结果，可能原因在于系数太过于敏感，因为360的7次方非常大，而1的7次方又特别小。", "Konwledge_Point": "矩阵乘法", "Question": "MATLAB如何实现带等式和不等式约束条件的最小二乘法拟合多元多项式\n多元多项式的公式如图，现在有n个数据（x,y,f(x,y)）来拟合这个多项式，用最小二乘法，具体程序如下面的代码\n\n\nZ\n=\nxlsread('Linton.xlsx')\n;\n\n\nx\n=\nZ(:\n,\n1\n)\n;%x的数据，为风速，范围是0到40\n\ny\n=\nZ(:\n,\n2\n)\n;%y的数据，为风向，范围是0到360\n\nz\n=\nZ(:\n,\n3\n)\n;%频率数据\n\nn \n=\n \n7\n; % n为多项式的阶数，参数一共为(n+1)²个\n\np \n=\n length(\nx\n)\n; q = length(y);\n\n[X\n,\nY\n,\ni1\n,\ni2\n] \n=\n ndgrid(\nx\n,\ny\n,\n0\n:n\n,\n0\n:n)\n;\n\nF \n=\n X.^\ni1\n.*Y.^\ni2\n;\n\nF \n=\n reshape(F\n,\n p*q\n,\n (n+\n1\n)^\n2\n)\n; %这一段是最小二乘法的左边矩阵，F矩阵具体形式如下图\n\nA \n=\n F'*F\n;\n\nb \n=\n F'*z\n;\n\na \n=\n A\\b\n;%最小二乘法\n\n\n\n\n\n\n然后现在就是得加入2个约束条件，一个是x在0到40，y在0到360，f(x,y)的积分等于1，然后f(x,y）永远大于0这两个约束条件。积分为1这个约束可以用拉格朗日乘子法来写。如果是下图的普通多项式，可以加下面一段代码解决积分为1\n\n\n\n\nG = \n1.\n/\n(n+1:-1:1)\n.*\n40.\n^\n(n+1:-1:1)\n;\n%\n 这段是上图的普通多项式积分为\n1\n，直接写出了积分形式然后用拉格朗日乘子法\n\n%\n现在需要对最上面的多元多项式积分为\n1\n，需要改成x在\n0\n到\n40\n，y在\n0\n到\n360\n的二重积分为\n1\n\naa = [A, F\n'; F, 0]\\[b;1];%拉格朗日乘子法\n\n\n\n\n现在是得把G矩阵写成二重积分，想问下这种多元多项式进行二重积分的代码应该怎么写。再就是f(x,y)永远大于0的约束要如何加上，以前只写过一维数据，然后普通多项式MATLAB也有代码，这个多元多项式得自己编写", "Tag": "算法分析"}
{"Answer": "楼主可以发下整个代码吗？\n ", "Konwledge_Point": "矩阵乘法", "Question": "c 语言 c free 报错求解决\nerror: (Each undeclared identifier is reported only once for each function it appears in.)\n\n\n\n头文件也加了\n\n\n\n\n\n\n\n\n\n\n\n#include \nvoid rabbitPrint()\n{\n\t printf(\"\\n\");\n\t printf(\"\\n\");\n     printf(\"\\t this is a rabbit!\\n\");\n\t printf(\"\\n\");\n\t printf(\"\\n\");\n\t printf(\"\\t*           *\\n\");\n\t printf(\"\\t**         **\\n\");\n\t printf(\"\\t **       **\\n\");\n     printf(\"\\t  **     **\\n\");\n\t printf(\"\\t     ***\\n\");\n     printf(\"\\t    *    *\\n\");\n\t printf(\"\\t   *   ** *\\n\");\n\t printf(\"\\t  *        *\\n\");\n\t printf(\"\\t *      *   *\\n\");\n\t printf(\"\\t*      ***   *\\n\");\n\t printf(\"\\t *          *\\n\");\n\t printf(\"\\t    *******    \\n\");\n\t printf(\"\\n\");\n\t printf(\"\\n\");\n   \n}\n\nfloat maxIQ(float you,float me)\n{\n\tif(you>me)\n\treturn you;\n\telse return me;\n\t\n}\n\n\nint main()\n{   int mflag=1; \n    int sflag;\n\tint mSelect;\n\tint sSelect;\n\twhile(mflag) \n    {\t\t\t\n\tprintf(\"\\t\\tHI,我是机器人小c，请问需要什么帮助吗？\\n\");\n\tprintf(\"\\t\\t我在听，请继续！\\n\"); \n\tprintf(\"\\t\\t你可以这样问我：\\n\"); \n\tprintf(\"\\n\\n\");\n\tprintf(\"\\t\\t1.请给我讲个笑话！\\n\");\n\tprintf(\"\\t\\t2.请给我打印一些漂亮的图形！\\n\");\n\tprintf(\"\\t\\t3.我要进行一些智能运算！\\n\");\n \tprintf(\"\\n\\n\");\n\tprintf(\"请输入选择项:\");\n\tscanf(\"%d\",&mSelect);\n\tif(mSelect==1)\n\t{\n    printf(\"\\t\\t   1--我有个朋友，讲了一生电话，有一天他挂了。\\n\");\n    printf(\"\\t\\t   0--退出\\n\");\t\n\t}\n\telse if(mSelect==2)\n\t{\n\tsflag=1;\n\twhile(sflag) \n\t{ \n    printf(\"\\t\\t   1--我要一只小兔子图形\\n\");\n    printf(\"\\t\\t   2--我要一张99乘法表\\n\");\n    printf(\"\\t\\t   3--我要一个任意尺寸的星号矩阵\\n\");\n    printf(\"\\t\\t   0--退出\\n\");\n    printf(\"请输入你的选择:\");\n    scanf(\"%d\",&sSelect);\n\tswitch(sSelect)\n\t{\n\tcase 1: rabbitPrint(); break;\n\tcase 2:printf(\"我要一张99乘法表！功能待实现\");break;\n\tcase 3:printf(\"我要一个任意尺寸的星号矩阵！功能待实现\");break;\n\tcase 0:sflag=0;\n\tbreak;\n\tdefault: printf(\"输入有误\");\n\tbreak;\n\t}\n\t}\n\t}\n\telse if(mSelect==3)\n\t{ sflag=1;\n\t while(sflag)\n    {\t\n\tprintf(\"\\t\\t   1--比较一下我和你的智商谁高！\\n\");\n    printf(\"\\t\\t   2--给你一队王者荣耀游戏人物，按照战斗值重新排队哦！嘿嘿！\\n\");\n    printf(\"\\t\\t   3--从几队游戏人物里，找到战斗值最高的给我！\\n\");\n    printf(\"\\t\\t   0--退出\\n\");\n    printf(\"\\n\\n\");\n    printf(\"请输入你的选择:\");\n    scanf(\"%d\",&sSelect);\n   \tswitch(sSelect)\n\t{\n\tcase 1:float you,me;\n    printf(\"输入你的智商:\");\n\tscanf(\"%f\",&you);\n\tprintf(\"输入我的智商:\");\n\tscanf(\"%f\",&me);\n    printf(\"智商最高的是:%f\\n\",maxIQ(you,me));break;\t\t\t\n\tcase 2:printf(\"给你一队王者荣耀游戏人物，按照战斗值重新排队哦！嘿嘿！功能待实现\");break;\n\tcase 3:printf(\"从几队游戏人物里，找到战斗值最高的给我！功能待实现\");break;\n\tcase 0:sflag=0;\n\tbreak;\n\tdefault: printf(\"输入有误\");\n\t}\n\t}\n    }\n\telse if(mSelect==0)\n\t{\n\tmflag=0;\n\tprintf(\"退出\\n\");\n\t}\n\telse\n\tprintf(\"输入有误\\n\");\n\tgetchar();\n\tgetchar();\n\treturn 0;\t\n\t}\n\t} \n", "Tag": "算法分析"}
{"Answer": "我引用ChatGPT作答：大概这样呢？不知道行不行。\n\nlamd=0.193*10^-3; % 入射波长\nw=1.5; % 入射光束腰\nR=1.5; % 元件的极限孔径\nD=175*10^-3; % 衍射距离\nL0=10.5*10^-3; % 照明区域半径\nr1=7.5*10^-3; % 内半径\nr2=10.5*10^-3; % 外半径\n%theta=45*pi/180; % 极角\ntheta = pi/4;\nk=2*pi/lamd; % 波数\nN=256;\n\n\n% 生成坐标网格\nx=linspace(-L0/2,L0/2,N);\ny=linspace(-L0/2,L0/2,N);\n[X,Y]=meshgrid(x,y);\n\n% 生成圆形光阑\nJ1=zeros(N);\nfor m=1:N\n    for n=1:N\n        if X(m,n)^2+Y(m,n)^2<=R^2\n            J1(m,n)=1;\n        end\n    end\nend\n\n% 生成高斯光束\nA=exp(-(X.^2+Y.^2)/w^2).*J1;\n\n% 生成偶极照明\nJ4=zeros(N);\nfor m=1:N\n    for n=1:N\n        if X(m,n)^2+Y(m,n)^2>=r1^2 && X(m,n)^2+Y(m,n)^2<=r2^2 && abs(atan2(Y(m,n),X(m,n)))<=theta/2\n            J4(m,n)=1;\n        end\n    end\nend\n\n% 计算光阑和高斯光束的中心\nJ1_center = [round(N/2), round(N/2)];\nA_center = [round(N/2), round(N/2)];\n\n% 计算光阑和高斯光束需要平移的距离\nJ1_shift = J1_center - [find(J1(:,1),1,'first'), find(J1(1,:),1,'first')];\nA_shift = A_center - [find(A(:,1),1,'first'), find(A(1,:),1,'first')];\n\n% 平移光阑和高斯光束\nJ1 = circshift(J1, J1_shift);\nA = circshift(A, A_shift);\n\n% 生成扇形光阑\nfor m=1:N\n    for n=1:N\n        if J4(m,n) && abs(atan2(Y(m,n),X(m,n)))>theta/2\n            J4(m,n)=0;\n        end\n    end\nend\n\n% 计算归一化系数\na=sum(sum(A.^2))/sum(sum(J4.^2));\nJ4=J4*sqrt(a);\n\n% 变换到衍射面\nA_fft=fftshift(fft2(A));\nJ4_fft=fftshift(fft2(J4));\nx_fft=linspace(-1/(2*D),1/(2*D),N);\n[X_fft,Y_fft]=meshgrid(x_fft,x_fft);\nphase_term=exp(1i*k*(X_fft.^2+Y_fft.^2)*D);\nB_fft=J4_fft.*phase_term.*A_fft;\n\n% 变换回物面\nB=ifft2(ifftshift(B_fft));\n\n% 显示照明光斑\nsubplot(1,3,1);\nimagesc(x,y,J4); axis square;\ntitle('Illumination Pattern')\nxlabel('x / mm'); ylabel('y / mm');\n\n\n% 显示高斯光束\nsubplot(1,3,2);\nimagesc(x11,y11,A);axis square;\ntitle('Gaussian Beam')\nxlabel('x / mm');ylabel('y / mm');\n% 显示衍射图样\nsubplot(1,3,3);\nimagesc(x,y,abs(B).^2); axis square;\ntitle('Diffraction Pattern')\nxlabel('x / mm'); ylabel('y / mm');\n\n% 生成偶极照明和高斯光束的交叉项\nJ5 = zeros(N);\nfor m=1:N\nfor n=1:N\nif ~isnan(J2(m,n)) && ~isnan(A(m,n)) && J2(m,n) && A(m,n)\nJ5(m,n) = 1;\nend\nend\nend\n\n% 显示交叉项\nsubplot(1,3,3);\nimagesc(x11,y11,J5);axis square;\ntitle('Cross Term')\nxlabel('x / mm');ylabel('y / mm');\n", "Konwledge_Point": "矩阵乘法", "Question": "关于matlab的问题\n关于高斯光束整形的问题\n需要把环形的高斯光束，加个偶级照明，截取两部分扇形，下面这个程序是高斯光束整形成环形的程序，我该在什么地方加个什么样的程序？最好是直接编写好的_(:з」∠)_最后成片是类似图中的样子，不过是有偏转，极角是45°\n\n\n具体指标包括：入射光束为直径1.5mm平面波，光强为高斯分布，波长193nm；DOE通光口径为1.5mm，目标平面与DOE所在平面的距离为175mm，目标平面光场分布形式为偶极照明，外半径10.5mm，内半径7.5mm，极角45°，照明区域内要求光强均匀分布，光能利用率≥80%，光强不均匀性≤20%\n\n\n%内能量超过90%的衍射圆\n\n\n% 衍射距离。程序中的uint是毫米\n\n\n% 定义变量\n\nlamd=\n0.193\n*\n10\n^\n-3\n; \n% 入射波长\n\nw=\n1.5\n; \n% 入射光束腰\n\nR=\n1.5\n; \n% 元件的极限孔径\n\nD=\n700\n; \n% 衍射距离\n\nr1=\n1.5\n; \n% 圆的内半径\n\nr2=\n3\n; \n% 圆的外半径\n\nL0=\n10\n; \n% 水平长度（以毫米为单位）\n\nk=\n2\n*\npi\n/lamd; \n% 波数\n\nN=\n256\n; \n% 采样点数\n\n\n%%%%%%%%%%%%% 判断（分析变换）\n\n\n% 判断是否满足菲涅尔变换条件\n\nJudging=(\nsqrt\n(N*lamd*D)<=L0); \n% 计算一个非负数的平方根\n\n\nif\n Judging==\n0\n\n    \ndisp\n(\n'????ERROR'\n);\n    \ndisp\n(\n'......Fresnel Analytic Transformation is not satisfied'\n); \n% 菲涅尔变换不满足\n\n    \n% break;\n\n\nend\n\n\n%%%%%%%%%%%%%\n\n\n% 生成网格点\n\nx11=\nlinspace\n(-L0/\n2\n,L0/\n2\n,N); \n% 在[-L0/2, L0/2]范围内生成N个点\n\ny11=\nlinspace\n(-L0/\n2\n,L0/\n2\n,N); \n% 在[-L0/2, L0/2]范围内生成N个点\n\n[x1,y1]=\nmeshgrid\n(x11,y11); \n% 生成网格点\n\n\n% 生成光强函数J1\n\nJ1=\nzeros\n(N);\n\nfor\n m=\n1\n:N\n    \nfor\n n=\n1\n:N\n        \nif\n x1(m,n)^\n2\n+y1(m,n)^\n2\n<=R^\n2\n \n% 如果点在圆内部，则取值为1，否则为0\n\n            J1(m,n)=\n1\n;\n        \nend\n\n    \nend\n\n\nend\n\n\n% 生成干涉图的振幅函数A\n\nA=\nexp\n(-(x1.^\n2\n+y1.^\n2\n)/w^\n2\n).*J1;\n\n%%%%%\n\n\n% 生成频率域上的网格点\n\nfx=\n1\n/L0*(-N/\n2\n:N/\n2\n-1\n);\nfy=\n1\n/L0*(-N/\n2\n:N/\n2\n-1\n);\n[fx,fy]=\nmeshgrid\n(fx,fy);\n\n%%%%%%\n\n\n% 生成干涉图的掩模函数JJ\n\nJJ=\nzeros\n(N);\n\nfor\n m=\n1\n:N\n    \nfor\n n=\n1\n:N\n        \nif\n x1(m,n)^\n2\n+y1(m,n)^\n2\n>=r1^\n2\n && x1(m,n)^\n2\n+y1(m,n)^\n2\n<=r2^\n2\n \n% 如果点在圆环内，则取值为1，否则为0\n\n            JJ(m,n)=\n1\n;\n        \nend\n\n    \nend\n\n\nend\n\na=sum(sum(A.^\n2\n))/sum(sum(JJ.^\n2\n)); \n% 计算放缩系数\n\nJ2=JJ*\nsqrt\n(a); \n% 对JJ进行缩放，使其平均光强等于A\n\n\n%imagesc(J2);axis square;colormap(gray)图像SC（J2）；轴线正方形；颜色图（灰色）\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% G-S\n\n\n%pha0=load('C:\\Documents and Settings\\wjq\\My Documents\\MATLAB\\pha90.txt');\n\npha0=\n2\npirand(N)-\npi\n; \n% 生成一个N×N大小的矩阵，矩阵中的每个元素都是在[-pi, pi]范围内随机生成的一个角度，作为初相。\n\nM=\n0\n;CC=[];eta=\n0\n;\n\nwhile\n eta<\n0.90\n \n% 当eta小于0.9时，进行循环计算\n\nM=M+\n1\n; \n% 循环次数自加1\n\nU1=A.\nexp\n(ipha0); \n% 通过矩阵乘法生成初始的光强分布\n\ntemp1=(fft2(U1)); \n% 对初始光强分布进行二维傅里叶变换\n\ntemp2=\nexp\n(ikD*(\n1\n-lamd^\n2\n/\n2\n*(fx.^\n2\n+fy.^\n2\n))); \n% 计算平面波前传播的相位调制因子\n\nU2=ifft2(temp1.temp2); \n% 对相位调制后的光强分布进行二维傅里叶逆变换，得到通过透镜后的光强分布\n\npha2=\nangle\n(U2); \n% 对通过透镜后的光强分布求相位，得到相位分布\n\nA2=\nabs\n(U2); \n% 对通过透镜后的光强分布求幅值，得到幅值分布\n\nI2=\nabs\n(U2).^\n2\n; \n% 对通过透镜后的光强分布求强度，得到强度分布\n\nErr(M)=sum(sum((I2-J2.^\n2\n ).^\n2\n)); \n% 计算输出光强与目标光强之间的误差\n\neta(M)=sum(sum(I2.JJ))/sum(sum(I2)); \n% 计算输出光强与目标光强之间的相似度\n\nsubplot(\n221\n);plotyy(\n1\n:M,Err,\n1\n:M,eta) \n% 绘制误差和相似度的变化曲线\n\ntitle(\n'Err (left) and eta (right)'\n);xlabel(\n'M'\n);\nsubplot(\n222\n);imagesc(x11,y11,J2);axis square;title(\n'Object function'\n)\nxlabel(\n'x / mm'\n);ylabel(\n'y / mm'\n);zlabel(\n'Amplitude'\n) \n% 绘制目标光强分布的图像\n\nsubplot(\n223\n);imagesc(x11,y11,A2);axis square;title(\n'Output function'\n)\nxlabel(\n'x / mm'\n);ylabel(\n'y / mm'\n);zlabel(\n'Amplitude'\n) \n% 绘制透镜后的光强分布的图像\n\n\n%%%%%%%%\n\nU2=J2.\nexp\n(ipha2); \n% 将通过透镜后的光强分布的相位分布与目标光强分布相乘，得到下一次迭代的初始光强分布\n\ntmep3=fft2(U2); \n% 对下一次迭代的初始光强分布进行二维傅里叶变换\n\ntemp4=\nexp\n(-ikD*(\n1\n-lamd^\n2\n/\n2\n*(fx.^\n2\n+fy.^\n2\n))); \n% 计算平面波后传播的相位调制因子\n\nU11=ifft2(tmep3.*temp4); \n% 利用傅里叶变换将初始光强分布与相位调制因子相乘得到通过光阑后的光强分布，然后再进行傅里叶反变换得到下一次迭代的光强分布\n\nsubplot(\n224\n);imagesc(x11,y11,pha0);axis square; title(\n'phase of DOE xlabel('\nx / mm');ylabel(\n'y / mm'\n) \n%绘图\n\npause(\n0.01\n)\n\nend\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "package yh_juzhen;import java.util.Scanner;\n/*编写一个Java程序，实现矩阵类，至少包含三个属性：行数，列数，存储数据的二维数组；至少两个构造函数，实现矩阵的数乘，加法，减法以及两个矩阵的乘法。*/\npublic class juzhen {        \nprivate int row;        \nprivate int col;        \nint data[][];        \n//  三个属性    其中data用于存储二维数组                \n\n//三个构造函数        \npublic juzhen() {        //无参构造函数  空的以便以后使用    \n    }        \n    public juzhen(int row, int col) {            \n    // 根据用户输入构造矩阵 即构造行列的        \n    }        \n    public juzhen(int data[][]) {// 根据传入的二维数组构建矩阵                         \n    this.row = data.length;\n    //row的值为传过来矩阵的行数            \n    this.col = data[0].length;            \n    this.data = new int[row][col];        \n    for (int i = 0; i < this.row; i++)//for循环赋值给date              \n    for (int j = 0; j < this.col; j++) {                    \n    this.data[i][j] = data[i][j];                \n    }        \n    }                        \n\n//打印数据   输出函数        \npublic void print() {//输出传过来的矩阵           \n for (int i = 0; i < this.row; i++) {                \n  for (int j = 0; j < this.col; j++) {                    \n  System.out.print(\" \" + this.data[i][j]);                \n  }                \n  System.out.println();//一行之后回车        \n      }        \n      }                        \n\n//get set 方法  获取矩阵属性行数列数\n        public int getRow() {\n            return row;\n        }\n\n        public void setRow(int row) {\n            this.row = row;\n        }\n\n        public int getCol() {\n            return col;\n        }\n\n        public void setCol(int col) {\n            this.col = col;\n        }\n\n        public int[][] getData() {\n            return data;\n        }\n\n        public void setData(int[][] data) {\n            this.data = data;\n        }\n\n//利用函数  获取第i行j列的元素\n        public int get(int i, int j) {\n            return this.data[i][j];//仍用this获取这个矩阵的数据\n        }\n\n//矩阵加法  c[i][j]= a[i][j]+b[i][j]        \npublic static juzhen add(juzhen a, juzhen b) {\n// 矩阵加法    结果返回给矩阵c   传过来对象的加法            \njuzhen c = null;//先给矩阵c设为空            \nif (a.getRow() != b.getRow() || a.getCol() != b.getCol()) {\n//矩阵a b不同行或不同列   且利用get set 函数                \nSystem.out.println(\"不是同型矩阵，不能相加\");                return c;            \n}            \nint[][] data = new int[a.getRow()][a.getCol()];\n//仍用原来的构造函数用data  并给它分配大小            \nfor (int i = 0; i < a.getRow(); i++)//做循环 进行相加                \nfor (int j = 0; j < a.getCol(); j++) {                \n    data[i][j] = a.get(i, j) + b.get(i, j);                    \n    /*不用data[i][j] = a.data[i][j] + b.data[i][j]                     因为为私有  要获取i行j列的元素的数据  创建函数get(int i,int j)*/                \n    }            \n    c = new juzhen(data);//将data给矩阵c            return c;        \n    }\n\n//矩阵减法 c[i][j]= a[i][j]-b[i][j]\n        public static juzhen subtract(juzhen a, juzhen b) {// 矩阵加法    结果返回给矩阵e   传过来对象的减法\n            juzhen e = null;//先给矩阵e设为空\n            if (a.getRow() != b.getRow() || a.getCol() != b.getCol()) {//矩阵a b不同行或不同列   且利用get set 函数\n                System.out.println(\"不是同型矩阵，不能相加\");\n                return e;\n            }\n    int[][] data = new int[a.getRow()][a.getCol()];//仍用原来的构造函数 用data  并给它分配大小\n            for (int i = 0; i < a.getRow(); i++)//做循环 进行相加\n                for (int j = 0; j < a.getCol(); j++) {\n                    data[i][j] = a.get(i, j) - b.get(i, j);\n                }\n            e = new juzhen(data);//将data给矩阵e\n            return e;\n        }\n\n\n//矩阵的数乘   c[i][j]= a[i][j]*h\n        public static juzhen shucheng(juzhen a, int h) {\n            juzhen f = null;//先给矩阵f设为空\n            int[][] data = new int[a.getRow()][a.getCol()];//仍用原来的构造函数 用data  并给它分配大小\n            for (int i = 0; i < a.getRow(); i++)//做循环 进行相加\n                for (int j = 0; j < a.getCol(); j++) {\n                    data[i][j] = a.get(i, j) *h;\n                }\n            f = new juzhen(data);//将data给矩阵f\n            return f;\n        }\n\n//矩阵乘法  \n        public static juzhen multiply(juzhen a, juzhen b) {//传过来对象\n            juzhen d=null;//先设矩阵d为空\n            if(a.getCol() !=b.getRow())//判是否可以相乘\n            {\n                System.out.println(\"矩阵不能相乘\");\n                return d;\n            }\n            int [][]data = new int [a.getRow()][b.getCol()];//给data分配空间  a的行数 b的列数  data暂存数据\n            for (int i =0 ;i< a.getRow();i++)\n                for(int j = 0; j< b.getCol();j++)\n                    for(int k =0; k < a.getCol();k++)\n                    {\n                        data[i][j]=data[i][j]+a.get(i, k)*b.get(k, j);//矩阵乘法运算\n                    }\n        \n           d= new juzhen(data);//将矩阵给d\n            return d;//返回矩阵d    \n        }\n    }\n\nclass test {\n    public static void main(String[] args) {\n\n        int a[][] = { { 1, 2, 3 }, { 2, 3, 4 }, { 2, 1, 3 } };\n        juzhen ma = new juzhen(a);//将矩阵a传过去\n        System.out.println(\"矩阵a为：\");\n        ma.print();//输出矩阵a\n        System.out.println(\"\\n\");//回车进行隔开\n        int b[][]=  { { 1, 2, 3 }, { 2, 3, 4 }, { 2, 1, 3 } };\n        juzhen mb = new juzhen(b);\n        System.out.println(\"矩阵b为：\");\n        mb.print();    \n        System.out.println(\"\\n\");\n\n//输入h的值  进行数乘运算\n        Scanner input = new Scanner(System.in);    \n        System.out.println(\"请输入h的值：\");    \n        int h = input.nextInt();  \n        System.out.println(\"\\n\");\n        \n        System.out.println(\"矩阵a与数h相乘结果为：\");\n        juzhen mf = juzhen.shucheng(ma, h);\n        mf.print();\n        System.out.println(\"\\n\");\n        \n        System.out.println(\"矩阵b与数h相乘结果为：\");\n        juzhen mg = juzhen.shucheng(mb, h);\n        mf.print();\n        System.out.println(\"\\n\");\n\njuzhen mc =juzhen.add(ma, mb);\n        System.out.println(\"矩阵相加结果为：\");\n        mc.print();//输出mc\n        System.out.println(\"\\n\");\n        \n        System.out.println(\"矩阵相减结果为：\");\n        juzhen me = juzhen.subtract(ma, mb);\n        me.print();\n        System.out.println(\"\\n\");\n        \n        System.out.println(\"矩阵相乘结果为：\");\n        juzhen md = juzhen.multiply(ma, mb);\n        md.print();\n    }\n}\n\n\n", "Konwledge_Point": "矩阵乘法", "Question": "关于#Java#的问题，如何解决？\n编写一个Java程序，实现矩阵类，至少包含三个属性：行数，列数，存储数据的二维数组；至少两个构造函数，实现矩阵的数乘，加法，减法以及两个矩阵的乘法。", "Tag": "算法分析"}
