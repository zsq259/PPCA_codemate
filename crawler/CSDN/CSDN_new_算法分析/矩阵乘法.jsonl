{"Answer": "å°è¯•ä¸€ä¸‹è¿™ä¸ª\n[sigmak^2*(2^(re)-1)-p13,zeros(1,M_irs);\n    zeros(M_irs,1),p13*epsilong_e^(-2)*eye(M_irs)]+...\n    (S3*theta0*h_BI)*((2^(re)-1)*Zx-W1x)*((S3*theta0*h_BI)');\n\n\n", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "matlabç”¨äºçŸ©é˜µä¹˜æ³•çš„ç»´åº¦ä¸æ­£ç¡®\né—®é¢˜é‡åˆ°çš„ç°è±¡å’Œå‘ç”ŸèƒŒæ™¯\n\n\nç¼–å†™ä»£ç æ—¶ï¼Œæç¤ºç”¨äºçŸ©é˜µä¹˜æ³•çš„ç»´åº¦ä¸æ­£ç¡®ï¼Œä½†æ˜¯æˆ‘æ£€æŸ¥äº†çŸ©é˜µçš„ç»´åº¦ï¼Œä¿ç¬¬ä¸€ä¸ªçŸ©é˜µä¸­çš„åˆ—æ•°ä¸ç¬¬äºŒä¸ªçŸ©é˜µä¸­çš„è¡Œæ•°åŒ¹é…ï¼Œä¸çŸ¥é“é—®é¢˜å‡ºåœ¨äº†å“ªé‡Œ\n\n\né—®é¢˜ç›¸å…³ä»£ç ï¼Œè¯·å‹¿ç²˜è´´æˆªå›¾\n\n\n\n\n\n\n%% step2:ä¼˜åŒ–é¢„ç¼–ç å‘é‡Wxå’Œäººå·¥å™ªå£°åæ–¹å·®Zx\nS3=[h_I3.',eye(M_irs)].';     %è½¬ç½®æ˜¯.',å…±è½­è½¬ç½®æ˜¯'\nS4=[h_I4.',eye(M_irs)].';\n%% å¯¹äºä»»ä½•å¯è¡Œç‚¹W1t,W2t,Zxt\nM1=h_BI'*theta0'*(h_I1'*h_I1)*theta0*h_BI;\nM2=h_BI'*theta0'*(h_I2'*h_I2)*theta0*h_BI;\nW1t=eye(Nt,Nt);\nW2t=eye(Nt,Nt);\nZxt=eye(Nt,Nt);\ncvx_begin sdp\n    variables W1x(Nt,Nt) W2x(Nt,Nt) \n    variable Zx(Nt,Nt) complex semidefinite\n    variable p13  nonnegative\n    variable p23  nonnegative\n    variable p14  nonnegative\n    variable p24  nonnegative\nobj=-\nlog\n(\nreal\n(\ntrace\n(Zx*M1))+sigmak^2+\nreal\n(\ntrace\n(M1*W1x))+\nreal\n(\ntrace\n(M1*W2x)))-\nlog\n(\nreal\n(\ntrace\n(Zx*M2))+sigmak^2+\nreal\n(\ntrace\n(M2*W1x)))+\nreal\n(\ntrace\n(M2*W2x))-\nreal\n(\ntrace\n((-(1/\nlog\n(2))*(M1/\nreal\n((\ntrace\n(Zxt*M1))+sigmak^2+\nreal\n(\ntrace\n(M1*W2t)))+M2/(\nreal\n(\ntrace\n(Zxt*M2))+sigmak^2+\nreal\n(\ntrace\n(M2*W1t)))))'*Zx))-\nreal\n(\ntrace\n((-(1/\nlog\n(2))*M2/(\nreal\n(\ntrace\n(Zxt*M2))+sigmak^2+\nreal\n(\ntrace\n(M2*W1t))))'*W1x))-\nreal\n(\ntrace\n((-(1/\nlog\n(2))*M1/\nreal\n((\ntrace\n(Zxt*M1))+sigmak^2+\nreal\n(\ntrace\n(M1*W2t))))'*W2x))-re;\nminimize obj\n    subject to \n    \ntrace\n(W1x)+\ntrace\n(Zx)<=P;\n    \ntrace\n(W2x)+\ntrace\n(Zx)<=P;\n[sigmak^2*(2^(re)-1)-p13,zeros(1,M_irs);zeros(M_irs,1),p13*epsilong_e^(-2)*eye(M_irs)]+S3*theta0*h_BI*((2^(re)-1)*Zx-W1x)*h_BI'*theta0'*S3'>=0;\n%çŸ©é˜µç»´åº¦ï¼šå‰é¢æ˜¯(M_irs+1)*(M_irs+1)çš„çŸ©é˜µï¼›S3æ˜¯(M_irs+1)*(M_irs)ï¼›theta0æ˜¯(M_irs)*(M_irs)ï¼›h_BIæ˜¯(M_irs)*16ï¼›Zx,W1xæ˜¯16*16ï¼›\nZx>=0;\nW1x>=0;\nW2x>=0;\ncvx_end\n\n\n\n\n\nè¿è¡Œç»“æœåŠæŠ¥é”™å†…å®¹\n\n\næç¤ºè¿™å¥ï¼š[sigmak^2*(2^(re)-1)-p13,zeros(1,M_irs);zeros(M_irs,1),p13\nepsilong_e^(-2)\neye(M_irs)]+S3\ntheta0\nh_BI*((2^(re)-1)*Zx-W1x)*h_BI'*theta0'\nS3'>=0;\né”™è¯¯ä½¿ç”¨  *\nç”¨äºçŸ©é˜µä¹˜æ³•çš„ç»´åº¦ä¸æ­£ç¡®ã€‚è¯·æ£€æŸ¥å¹¶ç¡®ä¿ç¬¬ä¸€ä¸ªçŸ©é˜µä¸­çš„åˆ—æ•°ä¸ç¬¬äºŒä¸ªçŸ©é˜µä¸­çš„è¡Œæ•°åŒ¹é…ã€‚è¦æ‰§è¡ŒæŒ‰å…ƒç´ ç›¸ä¹˜ï¼Œè¯·ä½¿ç”¨ '.\n'ã€‚\n\n\næˆ‘çš„è§£ç­”æ€è·¯å’Œå°è¯•è¿‡çš„æ–¹æ³•\n\n\nè¿™æ˜¯å·¥ä½œåŒºçš„å€¼\n\n\n\n\næˆ‘æƒ³è¦è¾¾åˆ°çš„ç»“æœ\n\n\nä¸æŠ¥é”™", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "æç¤ºçš„å¾ˆæ˜æ˜¾å•Šï¼Œæ‰“æ–­ç‚¹æ‰¾å‡ºæ¥è¿™ä¸¤ä¸ªçŸ©é˜µï¼Œæ”¹æˆç»´åº¦ä¸€æ ·çš„ä¸å°±è¡Œäº†ã€‚", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "ä»£ç è¿è¡Œå‡ºé”™ï¼Œæç¤ºç”¨äºçŸ©é˜µä¹˜æ³•çš„ç»´åº¦ä¸æ­£ç¡®ã€‚è¯·æ£€æŸ¥å¹¶ç¡®ä¿ç¬¬ä¸€ä¸ªçŸ©é˜µä¸­çš„åˆ—æ•°ä¸ç¬¬äºŒä¸ªçŸ©é˜µä¸­çš„è¡Œæ•°åŒ¹é…ï¼Œç„¶åä¸çŸ¥é“è¯¥æ€ä¹ˆè§£å†³äº†\né—®é¢˜é‡åˆ°çš„ç°è±¡å’Œå‘ç”ŸèƒŒæ™¯\n\n\n\n\né—®é¢˜ç›¸å…³ä»£ç ï¼Œè¯·å‹¿ç²˜è´´æˆªå›¾\n\n\nclear all;clc;close all;\nx_min = -1; % è¾“å…¥æœ€å°å€¼,\nx_max = 1/4; % è¾“å…¥æœ€å¤§å€¼,\n\n\nalpha = \n@(x,t) \nt.\n(2 + cos(2\npi\nx));\nbeta = \n@(x,t) \nt.\n(1 + cos(2\npi\nx));\ngamma = \n@(x,t) \nt.\n(2 + cos(4\npi*x));\n\n\nUexact = \n@(x,t) \nt.\nsin(2\npi\nx);\nUexact_x = \n@(x,t) \nt.\n2\npi\ncos(2\npi\nx);\nUexact_t = \n@(x,t) \nsin(2\npi\nx);\nUexact_xx = \n@(x,t) \n-t.\n4\npi^2\nsin(2\npi*x);\ng1 = \n@(t) \nUexact(x_min,t);\ng2 = \n@(t) \nUexact(x_max,t);\nfx = \n@(x,t) \nUexact_t(x,t) - alpha(x,t).*Uexact_xx(x,t) - beta(x,t)*Uexact_x(x,t) - gamma(x,t).*Uexact(x,t);\n\n\nT = 1;\nCons= 0.2;\nArrayN = [40 80 160 320 640];   % å¯¹äºdtçš„æ”¶æ•›;\n% AttayN = [10 20 40 80 160];   % å¯¹äºdxçš„æ”¶æ•›ä½¿ç”¨;\nArrayM = zeros(1,length(ArrayN));\ncounter = 1;\nfor N=ArrayN\n N = 40;\n M = ceil(T/(Cons*(x_max-x_min)^2)*N^2);\n % N=80;\n % ArrayM(counter)=M;\nh = (x_max-x_min)/(N-1);   % æ­¥é•¿h\n\n\nx = zeros(1,N);   % ä¸­é—´ç‚¹\nfor i = 1:N\n    x(i)=x_min+(i-1)*h;\nend\n\n\ndt = T/(M-1);   % æ­¥é•¿h\nt = zeros(1,M);   % ä¸­é—´ç‚¹\nfor n = 1:M\n    t(n)=(n-1)*dt;\nend\n\n\nu1 = Uexact(x(2:end-1),0).';\n\n\nA = zeros(N-2,N-2);   % å®šä¹‰çŸ©é˜µA\nA(1,1)=-2;\nA(1,2)=1;\nA(N-2,N-2)=-2;\nA(N-2,N-3)=1;\nfor j = 2:N-3\n    A(j,j-1)=1;\n    A(j,j)=-2;\n    A(j,j+1)=1;\nend\n\n\nfor n = 2:M\n    tn=(n-1)\ndt+dt;\n    % alpha\nu_xx\n    AlphaMatrix = diag(alpha(x(2:end-1),tn));\n    Atilda = AlphaMatrix*A;\n\n\n% beta*u_x\nBetaMatrix = diag(beta(x(\n2\n:\nend\n-\n1\n),tn));\nC=zeros(N-\n2\n,N-\n2\n);\n\nC(1,1)\n=\n0\n;\n\nC(1,2)\n=\n1\n;\n\nC(N-2,N-2)\n=\n0\n;\n\nC(N-2,N-3)\n=-\n1\n;\nBetaMatrix = diag(beta(x(\n2\n:\nend\n-\n1\n),tn));\n\nfor\n j = \n2\n:N-\n3\n\n    \nC(\nj\n,\nj\n+1)\n=\n1\n;\n    \nC(\nj\n,\nj\n)\n=\n0\n;\n    \nC(\nj\n,\nj\n-1)\n=-\n1\n;\n\nend\n\n\nCtilda = BetaMatrix*C;\n\n% Gamma*u\nGammaMatrix = diag(gamma(x(\n2\n:\nend\n-\n1\n),tn));\nD=eye(N-\n2\n,N-\n2\n);\nDtilda = GammaMatrix*D;\n\n% Implement BCs\nb = zeros(N-\n2\n,\n1\n);\nb(\n1\n) = (dt/h^\n2\n*alpha(x(\n2\n),tn) - beta(x(\n2\n),tn)*dt/(\n2\n*h))*g1(tn);\nb(\nend\n) = (dt/h^\n2\n*alpha(x(\nend\n-\n1\n),tn) + beta(x(\nend\n-\n1\n),tn)*dt/(\n2\n*h))*g2(tn);\nL=D - dt/h^\n2\n*Atilda - dt*Dtilda - dt/(\n2\n*h)*Ctilda;\nu2 = L\\(u1 + dt*fx(x(\n2\n:\nend\n-\n1\n),tn) + b);\n\nu1=u2;\n \nError(\ncounter\n,\nn\n-1)\n = max(max(abs(\nUexact(\nx\n(2:\nend\n-1)\n,tn).'-u2)));\n\n\n\nend\n\n\nplot(x(2:end-1),u2,'bo-',x(2:end-1),Uexact(x(2:end-1),T),'r*-');\nError2(counter) = max(abs(Error(counter,:)));\ncounter = counter + 1;\nend\nloglog(2./ArrayN,Error, 'o--',2./ArrayN,(2./ArrayN).^2,'*--');\nxlabel('h')\nylabel('Error')\nlegend('Exact','Numerical');\ngrid on;\n\n\ntitle('Stability of Implicit Euler method with respect to constant C','interpreter','latex')\nloglog((x_max-x_min)./ArrayN,Error2, 'o--',(x_max-x_min)./ArrayN,((x_max-x_min)./ArrayN).^2,'*âˆ’âˆ’');\nxlabel('$dx$','interpreter','latex');\nylabel('Error','interpreter','latex');\ntitle('Convergence with respect to $dx$','interpreter','latex');\nlegend('$|u(x_i,T)-u_{i,M}|_{\\infty}$','$O(dx^2)$','interpreter','latex');\nset(gca,'fontsize',13);\ngrid on;\n\n\nfigure;\nloglog(T./ArrayM,Error2,'o--',T./ArrayM,(T./ArrayM),'*--');\nxlabel('$dt$','interpreter','latex');\nylabel('Error','interpreter','latex');\ntitle('Convergence with respect to $dt$','interpreter','latex');\nlegend('$|u(x_i,T)-u_{i,M}|_{\\infty}$','$O(dt)$','interpreter','latex');\nset(gca,'fontsize',13);\ngrid on;\n\n\nè¿è¡Œç»“æœåŠæŠ¥é”™å†…å®¹\n\n\n\n\næˆ‘çš„è§£ç­”æ€è·¯å’Œå°è¯•è¿‡çš„æ–¹æ³•\n\n\næˆ‘æƒ³è¦è¾¾åˆ°çš„ç»“æœ", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "ç”¨ç‚¹ä¹˜", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "matlabçš„çŸ©é˜µä¹˜æ³•\nè¿™ä¸€æ®µçš„ä»£ç æ˜¯ï¼š\nfor t=History:History+IRper\npath(t,:)=gy(t,:)\nb+ ebs(t,:);\nç„¶åæˆ‘ç”¨æ–­ç‚¹ï¼Œåœ¨è¿™ä¸€æ®µå‰ï¼Œpathæ˜¯ä¸€ä¸ª127\n4çš„çŸ©é˜µï¼Œgyæ˜¯ä¸€ä¸ª125\n9çš„çŸ©é˜µï¼Œbæ˜¯ä¸€ä¸ª9\n4çš„çŸ©é˜µï¼Œebsæ˜¯125\n4çš„çŸ©é˜µã€‚\nä¸ºä»€ä¹ˆè¿è¡Œåå°±æŠ¥é”™ï¼Œé”™è¯¯ä½¿ç”¨  *\nç”¨äºçŸ©é˜µä¹˜æ³•çš„ç»´åº¦ä¸æ­£ç¡®ã€‚è¯·æ£€æŸ¥å¹¶ç¡®ä¿ç¬¬ä¸€ä¸ªçŸ©é˜µä¸­çš„åˆ—æ•°ä¸ç¬¬äºŒä¸ªçŸ©é˜µä¸­çš„è¡Œæ•°åŒ¹é…ã€‚è¦æ‰§è¡ŒæŒ‰å…ƒç´ ç›¸ä¹˜ï¼Œè¯·ä½¿ç”¨ '.\n'ã€‚", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "#include<stdio.h>\nint a[105][105],b[105][105],c[105][105];\nint main() {\n    int n,m,k;\n    scanf(\"%d%d%d\",&n,&m,&k);\n    for(int i=0; i<n; i++) {\n        for(int j=0; j<m; j++) {\n            scanf(\"%d\",&a[i][j]);\n        }\n    }\n    for(int i=0; i<m; i++) {\n        for(int j=0; j<k; j++) {\n            scanf(\"%d\",&b[i][j]);\n        }\n    }\n    for(int i=0; i<n; i++) {\n        for(int j=0; j<k; j++) {\n            c[i][j] = 0;\n            for(int x=0; x<m; x++) {\n                c[i][j] += a[i][x]*b[x][j];\n            }\n            printf(\"%d \",c[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "ä½¿ç”¨cè¯­è¨€æ¥æ±‚çŸ©é˜µä¹˜æ³•\nï¼Œç¼–å†™ç¨‹åºï¼Œå®ç°çŸ©é˜µä¹˜æ³•ï¼Œè¯»å…¥ï¼Œmï¼Œnå’Œï¼Œwï¼Œ3ä¸ªæ­£æ•°ï¼Œä¸€ä¸ªm\nnçš„æ•°ç»„å’Œä¸€ä¸ªï¼Œn\nwçš„æ•°ç»„ï¼Œè¾“å‡ºä¸€ä¸ªm*wçš„æ•°ç»„ã€‚", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "\n<?php\n\n\n\n$a = Array('0' => Array('0' => 1,'1' => 2),'1' => Array('0' => 4,'1' => 5));\n\n\n$b = Array('0' => Array('0' => 7,'1' => 5),'1' => Array('0' => 3,'1' => 2));\n\n$sumArray = array();\n\n$c = array();\n\nfor($i=0;$i<2;$i++) {\n for($j=0;$j<2;$j++) \n { \n    $c[$i][$j]=0; \n    for($k=0;$k<2;$k++) \n        { $c[$i][$j]=$c[$i][$j]+($a[$i][$k]*$b[$k][$j]); \n    } \n} \n} \n\n\necho \"<pre/>\";\nprint_r($c);\n?>\n\n", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "æˆ‘è¯•å›¾åœ¨PHPä¸­åˆ¶ä½œçŸ©é˜µä¹˜æ³•ä»£ç ï¼Œä½†ä¸æ˜¯çŸ©é˜µä¹˜æ³•ï¼Œå®ƒåªæ˜¯ç®€å•çš„ä¹˜æ³•ä¸è¡Œå’Œåˆ—\n\n\n\nI want to do matrix multiplication using array in PHP I have trying to do same but instead of matrix multiplication it just happening Simple multiplication as per output please help me to resolve it.\n\n\n\nHere is my code:\n\n\n\n Array('0' => 1,'1' => 2),'1' => Array('0' => 4,'1' => 5));\n\n$a2 = Array('0' => Array('0' => 7,'1' => 5),'1' => Array('0' => 3,'1' => 2));\n\n$sumArray = array();\n\n$result = array();\nfor($i=0; $i<=1; $i++)\n{\n    for($j=0; $j<=1; $j++)\n    {\n        $result[$i][$j] = $a1[$i][$j] * $a2[$i][$j];\n    }\n}\necho \"\";\nprint_r($result);\n?>\n\n\n\n\nOutput:\n\n\n\narray image\n\n    ", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "ç»ˆäºæ‰¾åˆ°é—®é¢˜äº†ï¼Œåˆ›å»ºçº¿ç¨‹æ—¶çš„ä¼ å‚å‡ºé”™äº†ï¼Œçº¿ç¨‹è¿˜æ²¡æ¥å¾—åŠä¿å­˜ä¼ æ¥çš„å‚æ•°ï¼Œå‚æ•°å°±è‡ªå¢äº†ï¼ˆä¼ é€’çš„æ˜¯æŒ‡é’ˆï¼‰    \r\nä¿®æ”¹åçš„ä»£ç å¦‚ä¸‹  \r\n```\r\n#include \r\n#include \r\n#include \r\n#include \r\n#define N 4\r\nint a[N][N], b[N][N],c[N][N],each;\r\n\r\nvoid *sum(void *vargp);\r\n\r\nint main(int argc, char **argv)\r\n{\r\n\tpthread_t tid[N];\r\n\tint i,j,begin[N], nthreads,temp[N][N];\r\n\r\n\t/*Get input arguments */\r\n\tif (argc != 2) {\r\n\t\tprintf(\"Usage: %s \\n\", argv[0]);\r\n\t\texit(0);\r\n\t}\r\n\tnthreads = atoi(argv[1]);\t//çº¿ç¨‹æ•°\r\n\r\n\t//ç”Ÿæˆ0-100éšæœºæ•°ã€åˆå§‹åŒ–çŸ©é˜µaï¼Œb\r\n\tsrand((int)time(NULL));\t//ç”Ÿæˆæ—¶é—´ç§å­\r\n\tfor (i = 0; i<N; i++)\r\n\t\tfor (j = 0; j<N; j++)\r\n\t\t{\r\n\t\t\ta[i][j] = ((rand() % 10) + 1);\r\n\t\t\tb[i][j] = ((rand() % 10) + 1);\r\n\t\t\tc[i][j] = 0;\r\n\t\t}\r\n\r\n\teach = N / nthreads;\t//æ¯ä¸ªçº¿ç¨‹å¤„ç†eachè¡Œ\t\r\n\t\r\n\tfor (i = 0; i < nthreads; i++){\r\n\t\tbegin[i]=i*each;\r\n\t}\r\n\r\n\tfor (i = 0; i < nthreads; i++) {\r\n\t\tpthread_create(&tid[i], NULL, sum, (void*)&begin[i]);\r\n\t}\r\n\r\n\tfor (i = 0; i < nthreads; i++)\r\n\t\tpthread_join(tid[i], NULL);\r\n\r\n\t//è¾“å‡ºaçŸ©é˜µ\r\n\tfor (i = 0; i < N; i++)\r\n\t{\r\n\t\tfor (j = 0; j < N; j++)\r\n\t\t{\r\n\t\t\tprintf(\"%5d\", a[i][j]);\r\n\t\t}\r\n\t\tprintf(\"\\n\");\r\n\t}\r\n\tprintf(\"\\n\");\r\n\r\n\t//è¾“å‡ºbçŸ©é˜µ\r\n\tfor (i = 0; i < N; i++)\r\n\t{\r\n\t\tfor (j = 0; j < N; j++)\r\n\t\t{\r\n\t\t\tprintf(\"%5d\", b[i][j]);\r\n\t\t}\r\n\t\tprintf(\"\\n\");\r\n\t}\r\n\tprintf(\"\\n\");\r\n\t\r\n\t//è¾“å‡ºcçŸ©é˜µ\r\n\tfor (i = 0; i < N; i++)\r\n\t{\r\n\t\tfor (j = 0; j < N; j++)\r\n\t\t{\r\n\t\t\tprintf(\"%5d\", c[i][j]);\r\n\t\t}\r\n\t\tprintf(\"\\n\");\r\n\t}\r\n\r\n\texit(0);\r\n}\r\n\r\nvoid *sum(void* argp)\r\n{\r\n\tint begin = *((int*)argp);\r\n\tint end = begin + each\t;\r\n\tint i,j,m;\r\n\r\n\tfor (i = begin; i < end; i++)\r\n\t\tfor (j = 0; j < N; j++)\r\n\t\t\tfor(m=0;m<N;m++)\r\n\t\t\t{ \r\n\t\t\t\tc[i][j] += a[i][m] * b[m][j];\r\n\t\t\t}\r\n\treturn NULL;\r\n}\r\n```\r\n![å›¾ç‰‡è¯´æ˜](https://img-ask.csdn.net/upload/201905/14/1557834947_626366.png)", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "Né˜¶çŸ©é˜µä¹˜æ³•çš„å¹¶è¡Œçº¿ç¨‹åŒ–ï¼Œåˆ›å»ºkä¸ªçº¿ç¨‹ï¼Œåˆ†åˆ«è®¡ç®—N/kè¡Œï¼Œå­˜åˆ°åŒä¸€æ•°ç»„ï¼Œå‡ºé”™æ±‚åŠ©ï¼ˆLinuxå¤šçº¿ç¨‹ç¼–ç¨‹ï¼‰\nNé˜¶çŸ©é˜µç›¸ä¹˜å¹¶çº¿çº¿ç¨‹åŒ–\n\næ¯”å¦‚8é˜¶çŸ©é˜µç›¸ä¹˜ï¼Œåˆ›å»º2ä¸ªçº¿ç¨‹ï¼Œåˆ™ä¸€ä¸ªçº¿ç¨‹ç®—1-4è¡Œï¼Œå¦ä¸€ä¸ªçº¿ç¨‹ç®—5-8è¡Œï¼Œç„¶åå­˜åˆ°åŒä¸€ä¸ªæ•°ç»„é‡Œã€‚\n\næ¯æ¬¡è¿è¡Œçš„ç»“æœæœ‰äº›è¡Œæ•°å…¨ä¸º0ï¼Œè¯·é—®æ˜¯çº¿ç¨‹ä¸å®‰å…¨å—ï¼Ÿå¯æ˜¯ä¸¤ä¸ªçº¿ç¨‹æ“ä½œçš„æ˜¯åŒä¸€æ•°ç»„çš„ä¸åŒè¡Œæ•°ï¼ŒæŒ‰é“ç†æ˜¯çº¿ç¨‹å®‰å…¨å•Šï¼Ÿ\n\nLinuxç³»ç»Ÿè¿è¡Œï¼Œç¼–è¯‘å‘½ä»¤ï¼šgcc -o æ–‡ä»¶å æ–‡ä»¶å.c -lpthread\n\nè¿è¡Œå‘½ä»¤ï¼š./æ–‡ä»¶å çº¿ç¨‹æ•°\n\nä»£ç å¦‚ä¸‹ï¼š\n\n\n\n#include \n#include \n#include \n#include \n#define N 8\nint a[N][N], b[N][N],c[N][N],each;\n\nvoid *sum(void *vargp);\n\nint main(int argc, char **argv)\n{\n    pthread_t tid[N];\n    int i,j,begin=0, nthreads,temp[N][N];\n\n    /*Get input arguments */\n    if (argc != 2) {\n        printf(\"Usage: %s \\n\", argv[0]);\n        exit(0);\n    }\n    nthreads = atoi(argv[1]);   //çº¿ç¨‹æ•°\n\n    //ç”Ÿæˆ0-100éšæœºæ•°ã€åˆå§‹åŒ–çŸ©é˜µaï¼Œb\n    srand((int)time(NULL)); //ç”Ÿæˆæ—¶é—´ç§å­\n    for (i = 0; i<N; i++)\n        for (j = 0; j<N; j++)\n        {\n            a[i][j] = ((rand() % 10) + 1);\n            b[i][j] = ((rand() % 10) + 1);\n            c[i][j] = 0;\n        }\n\n    each = N / nthreads;    //æ¯ä¸ªçº¿ç¨‹å¤„ç†eachè¡Œ\n\n    for (i = 0; i < nthreads; i++) {\n        pthread_create(&tid[i], NULL, sum, (void*)&begin);\n        begin += each;\n    }\n    for (i = 0; i < nthreads; i++)\n        pthread_join(tid[i], NULL);\n\n    //è¾“å‡ºaçŸ©é˜µ\n    for (i = 0; i < N; i++)\n    {\n        for (j = 0; j < N; j++)\n        {\n            printf(\"%5d\", a[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n\n    //è¾“å‡ºbçŸ©é˜µ\n    for (i = 0; i < N; i++)\n    {\n        for (j = 0; j < N; j++)\n        {\n            printf(\"%5d\", b[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n\n    //è¾“å‡ºcçŸ©é˜µ\n    for (i = 0; i < N; i++)\n    {\n        for (j = 0; j < N; j++)\n        {\n            printf(\"%5d\", c[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    exit(0);\n}\n\nvoid *sum(void* argp)\n{\n    int begin = *((int*)argp);\n    int end = begin + each  ;\n    int i,j,m;\n\n    for (i = begin; i < end; i++)\n        for (j = 0; j < N; j++)\n            for(m=0;m<N;m++)\n            { \n                c[i][j] += a[i][m] * b[m][j];\n            }\n    return NULL;\n}\n\n\n\n", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "#include<stdio.h>\n#include<stdlib.h>\n#define M 100\n\nint main(void)\n{\n    int i,j,k,matrix1[M][M],matrix2[M][M],row1=3,col1=4,row2=4,col2=3,matrix[M][M];\n   \n    printf(\"è¯·è¾“å…¥ç¬¬ä¸€ä¸ª3X4çŸ©é˜µ:\\n\");\n    for(i=0;i<row1;i++){\n        for(j=0;j<col1;j++){\n            scanf(\"%d\",&matrix1[i][j]);\n        }\n    }\n   printf(\"è¯·è¾“å…¥ç¬¬äºŒä¸ª4X3çŸ©é˜µ:\\n\");\n    for(i=0;i<row2;i++){\n        for(j=0;j<col2;j++){\n            scanf(\"%d\",&matrix2[i][j]);\n        }\n    }\n    \n    for(i=0;i<row1;i++){\n        for(j=0;j<col2;j++){\n            matrix[i][j]=0;\n        }\n    }\n\n    for(i=0;i<row1;i++){\n        for(j=0;j<col2;j++){\n            for(k=0;k<col1;k++){\n                matrix[i][j]=matrix[i][j]+matrix1[i][k]*matrix2[k][j];\n            }\n        }\n    }\n\n    for(i=0;i<row1;i++){\n        for(j=0;j<col2;j++){\n            printf(\"%d \",matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "å¦‚ä½•ç”¨Cè¯­è¨€å®ç°è¯¥çŸ©é˜µä¹˜æ³•\nå¸Œæœ›èƒ½å¾—åˆ°ä¸€äº›æŒ‡æ•™ï¼Œå­¦ä¸å¤ªæ˜ç™½æ€ä¹ˆæŠŠå››åˆ—çš„çŸ©é˜µä¹˜æˆä¸‰åˆ—çš„ï¼Œå¸Œæœ›èƒ½ç»™å‡ºä»£ç ç­”å¤ã€‚", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "æ‰¾æ‰¾æ¨¡æ¿å°è£…çš„ä¾‹å­çœ‹çœ‹ï¼Œåªæ˜¯ç”¨typename Tæ¥ä»£æ›¿æ•°æ®ç±»å‹è€Œå·²ã€‚\n\nå‚è€ƒå¦‚ä¸‹ï¼š\n#include <iostream>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix\n{\nprivate:\n    int m_m,m_n; //m*n\n    T** m_data;\npublic:\n    Matrix();\n    Matrix(int m,int n,T** data);//åˆå§‹åŒ–æ—¶èµ‹å€¼\n    \n    //ä»é”®ç›˜è¯»å…¥\n    void setData(int m,int n);\n    void show();\n    Matrix operator*(const Matrix<T> &b);\n    Matrix operator=(const Matrix<T> &b);\n};\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::operator=(const Matrix<T> &b)\n{\n    Matrix<T> a(b.m_m,b.m_n,b.m_data);\n    return a;\n}\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::operator*(const Matrix<T> &b)\n{\n    int m = this->m_m;\n    int n = b.m_n;\n    //æ— æ³•ç›¸ä¹˜çš„æƒ…å†µ\n    if(this->m_n != b.m_m)\n        return Matrix();\n\n    T** data = new T*[m];\n        \n    //è®¡ç®—\n    for (int i=0;i<m;i++)\n    {\n        data[i] = new T[n];\n        for (int j=0;j<n;j++)\n        {\n            data[i][j] = 0;\n            for(int k = 0;k<this->m_n;k++)\n                data[i][j] += this->m_data[i][k] * b.m_data[k][j];\n        }\n    }\n\n    Matrix<T> cc(m,n,data);\n    //é‡Šæ”¾ç©ºé—´\n    for(int i=0;i<m;i++)\n        delete[] data[i];\n    delete[] data;\n    data = 0;\n    return cc;\n}\n\ntemplate <typename T>\nvoid Matrix<T>::show()\n{\n    if(m_data)\n    {\n        for (int i =0;i<m_m;i++)\n        {\n            for(int j=0;j<m_n;j++)\n                cout << m_data[i][j] <<\" \";\n            cout <<endl;\n        }\n    }\n}\n\n\ntemplate <typename T>\nvoid Matrix<T>::setData(int m,int n)\n{\n    m_m =m;\n    m_n = n;\n    if(m_data)\n    {\n        for(int i=0;i<m_m;i++)\n            delete[] m_data[i];\n        delete[] m_data;\n        m_data = 0;\n    }\n    cout <<\"è¯·è¾“å…¥\"<<m<<\"*\"<<n<<\"çš„çŸ©é˜µï¼š\"<<endl;\n    m_data = new T*[m];\n    for (int i = 0;i<m;i++)\n    {\n        m_data[i] = new T[n];\n        for(int j=0;j<n;j++)\n            cin >>m_data[i][j];\n    }\n}\n\n\ntemplate <typename T>\nMatrix<T>::Matrix()\n{\n    m_m = 0;\n    m_n = 0;\n    m_data = 0;\n}\n\ntemplate <typename T>\nMatrix<T>::Matrix(int m,int n,T** data)\n{\n    m_m = m;\n    m_n = n;\n    m_data = new T*[m];\n    for (int i = 0;i<m;i++)\n    {\n        m_data[i] = new T[n];\n        for(int j=0;j<n;j++)\n            m_data[i][j] = data[i][j];\n    }\n}\n\n\nint main()\n{\n    int m,n;\n    \n    cout <<\"è¯·è¾“å…¥ç¬¬ä¸€ä¸ªçŸ©é˜µçš„må’Œn:\";\n    cin >>m>>n;\n    cout << \"è¯·è¾“å…¥\"<<m<<\"*\"<<n<<\"çš„æ•´æ•°çŸ©é˜µï¼š\"<<endl;\n    int** data = new int*[m];\n    for(int i = 0;i<m;i++)\n    {\n        data[i] = new int[n];\n        for(int j=0;j<n;j++)\n            cin >> data[i][j];\n    }\n    Matrix<int> ma(m,n,data);\n\n    for (int i=0;i<m;i++)\n    {\n        delete[] data[i];\n        data[i]=0;\n    }\n    delete[] data;\n\n    //ma.show();\n    \n    //æ„å»ºç¬¬äºŒä¸ªçŸ©é˜µ\n    cout << \"è¯·è¾“å…¥ç¬¬äºŒä¸ªçŸ©é˜µçš„må’Œnï¼š\";\n    cin >>m>>n;\n    cout << \"è¯·è¾“å…¥\"<<m<<\"*\"<<n<<\"çš„æ•´æ•°çŸ©é˜µï¼š\"<<endl;\n    data = new int*[m];\n    for(int i = 0;i<m;i++)\n    {\n        data[i] = new int[n];\n        for(int j=0;j<n;j++)\n            cin >> data[i][j];\n    }\n    Matrix<int> mb(m,n,data);\n\n    for (int i=0;i<m;i++)\n    {\n        delete[] data[i];\n        data[i]=0;\n    }\n    delete[] data;\n\n    //mb.show();\n    \n    Matrix<int> c = ma*mb;\n    c.show();\n    return 0;\n\n}\n\n", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "c++çŸ©é˜µä¹˜æ³•ï¼Œè¦æ±‚ç”¨ç±»å°è£…\nå…³é”®åœ¨äºä»–æœ‰å¾ˆå¤šè¦æ±‚ï¼Œä¸åœ¨äºä¹˜æ³•çš„å®ç°ï¼Œè¦ç”¨ç±»æ¥å°è£…çŸ©é˜µï¼Œè¿˜è¦ç”¨æ¨¡æ¿ï¼Œåˆå­¦è€…æ„Ÿè§‰å›°éš¾ï¼Œæ±‚æ€è·¯ï¼Œæœ€å¥½æœ‰ä»£ç ï¼Œè°¢", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "\nI see two problems:\n\nYou have a classic closure problem in multiply with i and j.\nThere's no guarantee that matrix_c will be computed before you return it in multiply.\n\nThe first one is right here:\nfor i := 0; i < 3; i++ {\n    for j := 0; j < 3; j++ {\n        go func(){\n            matrix_c[i][j] = pmultiply(matrix_a,matrix_b,i,j);\n        }()\n    }   \n}\n\nThe anonymous function is keeping a reference to i and j not the actual values of i and j when you go func() { ... }() so when the goroutine executes, i and j could be any values between zero and three (inclusive). That's where the error you know about comes from: i or j is three because the goroutine is executing after the loops have completed. The easiest solution is to force i and j to be evaluated at the right time:\ngo func(i, j int) {\n    matrix_c[i][j] = pmultiply(matrix_a, matrix_b, i, j)\n}(i, j)\n\nThe second problem is that the goroutines won't necessarily all finish before you return matrix_c, there's not even a guarantee that any of of them will finish. The easiest solution would be to use a sync.WaitGroup to wait for them to finish. First you'd import \"sync\", then adjust the loops:\nvar wg sync.WaitGroup\nfor i := 0; i < 3; i++ {\n    for j := 0; j < 3; j++ {\n        wg.Add(1) // Tell the WaitGroup to wait for another thing.\n        go func(i, j int) {\n            matrix_c[i][j] = pmultiply(matrix_a, matrix_b, i, j)\n            wg.Done() // Tell it that we're done.\n        }(i, j)\n    }\n}\n\nand then wait before returning:\nwg.Wait()\nreturn matrix_c\n\n\nResponse to Comments: defer doesn't work like that, the specification only says:\n\nA \"defer\" statement invokes a function whose execution is deferred to the moment the surrounding function returns, either because the surrounding function executed a return statement, reached the end of its function body, or because the corresponding goroutine is panicking.\n\nThat's it, it arranges for something to be executed when execution leaves the surrounding function. defer doesn't have anything to do with waiting for threads/goroutines nor does it know anything about goroutines that the deferred function may create.\n", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "Goä¾‹ç¨‹çŸ©é˜µä¹˜æ³•é”™è¯¯\n\n\n\nI am multiplying matrix in parallel using go routines. I am getting index out of range, but when i run the same code sequential it works. (by sequential i mean commenting go line). I am using defer so i do not have to wait for my routines to end as it will be the last thing called\n\n\n\nError \n    D:\\0000>go run Ap.go\n    panic: runtime error: index out of range\n\n\n\ngoroutine 5 [running]:\nmain.pmultiply(0xc04206c000, 0x3, 0x3, 0xc04206c050, 0x3, 0x3, 0x1, 0x3, 0x0)\n        D:/0000/Ap.go:48 +0x95\nmain.multiply.func1(0xc04206c0a0, 0x3, 0x3, 0xc04200e090, 0xc04200e098, 0xc04206\nc000, 0x3, 0x3, 0xc04206c050, 0x3, ...)\n        D:/0000/Ap.go:64 +0x94\ncreated by main.multiply\n        D:/0000/Ap.go:63 +0x1d7\nexit status 2\n\n\n\n\nCODE\n\n\n\npackage main\n\nimport \"fmt\"\n\nfunc main(){\n\n    matrix_a := make([][]int,3);\n\n    for i:=0;i<len(matrix_a);i++{\n\n        matrix_a[i]=make([]int,3);\n\n    }\n\n\n    for i:=0;i<len(matrix_a);i++{\n\n        for j:=0;j<len(matrix_a[0]);j++{\n            matrix_a[i][j] = 2;\n        }\n    }\n\n    matrix_b := make([][]int,3);\n\n    for i:=0;i<len(matrix_b);i++{\n\n        matrix_b[i]=make([]int,3);\n\n    }\n\n\n    for i:=0;i<len(matrix_b);i++{\n\n        for j:=0;j<len(matrix_b[0]);j++{\n            matrix_b[i][j] = 2;\n        }\n    }\n\n    defer fmt.Println(multiply(matrix_a,matrix_b));\n\n}\n\nfunc pmultiply(matrix_a [][] int,matrix_b [][] int,row int,col int) int{\n\n    sum := 0;\n\n    for z:=0;z<len(matrix_a[0]);z++{\n        sum = sum + matrix_a[row][z] *  matrix_b[z][col];\n    }\n    return sum;\n}\n\nfunc multiply(matrix_a [][] int,matrix_b [][] int) ([][] int){\n\n    matrix_c := make([][]int,3);\n\n    for i:=0;i<len(matrix_c);i++{\n        matrix_c[i]=make([]int,3);\n    }\n\n    for i := 0; i < 3; i++ {\n        for j := 0; j < 3; j++ {\n            go func(){\n                matrix_c[i][j] = pmultiply(matrix_a,matrix_b,i,j);\n            }()\n        }   \n    }\n\n    return matrix_c;\n}\n\n\n    ", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "æŠŠ ^æ”¹æˆ .^ è¯•ä¸€ä¸‹", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "matlabçš„çŸ©é˜µä¹˜æ³•çš„ç»´åº¦ä¸æ­£ç¡®ï¼Œæ€ä¹ˆè§£å†³å‘¢ã€‚\nt=0:0.1:10\ny=(12\nt^2+1200\nt+1250)/(50+t)\nplot(t,y)\ngrid minorï¼ˆè¿™æ˜¯ä»£ç ï¼‰èƒ½å¸®æˆ‘çœ‹çœ‹é—®é¢˜å‡ºåœ¨å“ªå„¿å—ï¼Ÿ", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "4Ã—4çš„çŸ©é˜µï¼Œæ•°ç»„å¤§å°åº”è¯¥å®šä¹‰ä¸ºA[4][4]å§", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "ç”¨Cè¯­è¨€å®ç°ä¸¤ä¸ª4x4çŸ©é˜µç›¸ä¹˜ï¼Œç³»ç»Ÿæ²¡æœ‰æŠ¥é”™ï¼Œä½†æ˜¯ç»“æœæ˜¯é”™çš„Â·Â·Â·Â·Â·Â·\n\n                                                                                                                  è¿™éƒ¨åˆ†æƒ³è¦å®ç°çš„åŠŸèƒ½æ˜¯ï¼šåœ¨å·²ç»è¾“å…¥çš„ä¸€ä¸ªäºŒç»´æ•°ç»„ä¸­æ‰¾åˆ°æœ€å¤§å€¼å’Œæœ€å°å€¼å¹¶ä¸”è¾“å‡ºï¼Œè¿˜è¦å†™å‡ºæœ€å¤§å€¼å’Œæœ€å°å€¼æ‰€åœ¨çš„è¡Œå’Œåˆ—æ•°ã€‚\n\né—®é¢˜ï¼šç³»ç»Ÿç¼–è¯‘åæ²¡æœ‰æŠ¥é”™ï¼Œä½†æ˜¯æœ€åç°å®çš„ç»“æœå´æ˜¯é”™çš„ï¼Œä¾‹å¦‚ï¼š\n\nè¿™éƒ¨åˆ†è¦å®ç°çš„åŠŸèƒ½æ˜¯ï¼šåˆ†åˆ«æ±‚å‡ºè¿™ä¸ªçŸ©é˜µçš„ä¸¤æ¡å¯¹è§’çº¿ä¹‹å’Œã€‚é—®é¢˜ï¼šä½†æ˜¯æ¯æ¬¡æ±‚å’Œæ˜¯æ€»æœ‰ä¸€æ¡æ˜¯é”™çš„Â·Â·Â·Â·Â·Â·Â·\n\n\n\nå®åœ¨æ˜¯ä¸çŸ¥é“å“ªé‡Œé”™äº†ï¼Œæ±‚å„è·¯å¤§ç¥å¸®å¸®å¿™ã€‚ã€‚ã€‚ã€‚\n\n\n\næœ‰å°è¯•è¿‡å•æ­¥è°ƒè¯•ï¼Œä½†æ˜¯å®ƒå¥½åƒç›´æ¥å°±è·³è¿‡å­å‡½æ•°äº†ã€‚ã€‚ã€‚ã€‚", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "è¿™ä¸ªå¥½å¼„ï¼Œç”¨ç¬¦å·è®¡ç®—å°±è¡Œ\nsyms a b c\nA = [1,1,0; 5,6,7; 2,1,5];\nB = [a,b,c; 1,2,3; 4,5,6];\nA.*B\n\nç»“æœ\nans =\n \n[ a,  b,  0]\n[ 5, 12, 21]\n[ 8,  5, 30]\n", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "MATLABå¸¦æœªçŸ¥é‡çŸ©é˜µè¿ç®—\nå¦‚å›¾ï¼Œæˆ‘æƒ³å¸¦æœªçŸ¥æ•°è¿›è¡ŒçŸ©é˜µè¿ç®—ï¼Œä¸éœ€è¦æ±‚è§£å…·ä½“å€¼ï¼Œæ€ä¹ˆæ“ä½œã€‚", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "è¿™ä¸ªå°±æ˜¯ç”¨åˆ°çŸ©é˜µè®¡ç®—ã€‚æ ¹æ®å›¾ä¸­çš„æ–¹æ³•è¿›è¡ŒçŸ©é˜µè®¡ç®—", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "AESåˆ—æ··æ·†ä¸­çš„ç±»çŸ©é˜µä¹˜æ³•è¿ç®—\nAESåŠ å¯†è¿‡ç¨‹ä¸­çš„åœ¨2^nä¸Šçš„ç±»çŸ©é˜µä¹˜æ³•è¿ç®—\nè¿™æ ·çš„è¿ç®—ç»“æœæ˜¯æ€ä¹ˆå‡ºç°çš„å‘¢ï¼Œå¦‚æœå±•å¼€æˆå¤šé¡¹å¼è¿›è¡Œè¿ç®—çš„è¯ï¼Œæ¨¡çš„é‚£ä¸ªå¤šé¡¹å¼åˆæ˜¯è°å‘¢ï¼Œç®—å‡ºæ¥ä¸å¯¹\nè¿˜æ˜¯æœ‰å…¶ä»–çš„è®¡ç®—æ–¹å¼å—ï¼Œä¸å¤ªæ˜ç™½", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "æ”¹æˆ\nfor (i = 0; i < n; i++)\n{\n    for (j = 0; j < k; j++)\n    {\n        cout << ab[i][j] << \" \";\n    }\n    cout << endl;\n}\n", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "ä¸ºä»€ä¹ˆè¾“å‡ºçš„ä¸æ˜¯ä¸€ä¸ªçŸ©é˜µå•Šï¼Ÿï¼ˆçŸ©é˜µä¹˜æ³•C++ï¼‰\nä¸ºä»€ä¹ˆè¾“å‡ºçš„ä¸æ˜¯ä¸€ä¸ªçŸ©é˜µå•Šï¼Ÿï¼ˆçŸ©é˜µä¹˜æ³•C++ï¼‰\n\n\n\n\n#include\nusing namespace std;\n\n\nint main(){\n    int n,m,k;\n    int i,j,ii;\n\n\nint a[\n100\n][\n100\n];\nint b[\n100\n][\n100\n];\nint ab[\n100\n][\n100\n];\n\ncout << \n\"è¯·è¾“å…¥çŸ©é˜µaçš„è¡Œæ•°ã€åˆ—æ•°ä»¥åŠbçš„åˆ—æ•°:\"\n << endl;\ncin >> n >> m >> k;\n\ncout << \n\"è¯·è¾“å…¥çŸ©é˜µa:\"\n << endl;\nfor( i = \n0\n;i < n;i++)\nfor( j = \n0\n;j < m;j++){\n    cin >> a[i][j];\n}\n\ncout << \n\"è¯·è¾“å…¥çŸ©é˜µb:\"\n << endl;\nfor( i = \n0\n;i < m;i++)\nfor( j = \n0\n;j < k;j++){\n    cin >> b[i][j];\n}\n\nfor( i = \n0\n;i < n;i++){\n    for( j = \n0\n;j < k;j++){\n        ab[i][j] = \n0\n;\n        for( ii = \n0\n;ii < m;ii++){\n            ab[i][j] = ab[i][j]+a[i][ii]*b[ii][j];\n        }\n    }\n}\n\ncout << \n\"çŸ©é˜µaå’Œbçš„ä¹˜ç§¯ä¸º:\"\n << endl;\nfor( i = \n0\n;i < n;i++){\n    for( j = \n0\n;j < k;j++){\n        cout << ab[i][j] << endl;\n    }\n}\n\nsystem(\n\"pause\"\n);\nreturn \n0\n;\n\n\n\n}", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "npåŒ…çš„çŸ©é˜µç›¸ä¹˜æœ‰ä¸¤ç§ä½ éœ€è¦é€ä¸ªåˆ†æ¸…ï¼Œdotå’Œmultiplyã€‚å¦‚æœæ˜¯çŸ©é˜µçš„ç›¸ä¹˜çš„è¯éœ€è¦æ£€æŸ¥ä¸¤ä¸ªçŸ©é˜µçš„é•¿å’Œå®½æ˜¯å¦åœ¨æ¯ä¸€æ¬¡çš„è¿­ä»£ä¸­éƒ½ç¬¦åˆè¦æ±‚ï¼ŒåŒæ—¶ä¹Ÿè¦é¿å…çŸ©é˜µä¸­å‡ºç°Noneå€¼", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "numpyä¸­çŸ©é˜µæ— æ³•ç›¸ä¹˜\nåœ¨ä½¿ç”¨numpyå’Œsklearnè‡ªä¸»å®ç°é€»è¾‘å›å½’çš„è¿‡ç¨‹ä¸­ï¼ŒçŸ©é˜µæ— æ³•ç›¸ä¹˜\n\n\n\n```python\nimport sys\nimport pandas \nas\n pd\nimport numpy \nas\n np\nimport matplotlib.pyplot \nas\n plt\nfrom sklearn.datasets import load_breast_cancer\ndata = load_breast_cancer(return_X_y=True)\nX = np.array(data[0])\ny = np.array(data[1])\n\ndef sigmod(x):\n    \nreturn\n 1/(1+pow(np.\ne\n,(-x)))\n\ndef Logistic_Regression(feature_data,target_data,learning_rate,account):\n    \nm\n = feature_data.shape[0]\n    feature_data = np.hstack((np.full((\nm\n,1),1),feature_data))\n    \nm\n,\nn\n = feature_data.shape\n    para = np.random.\nuniform\n(-1,1,\nn\n).\nreshape\n(\nn\n,1) # \nn\n*1\n    para = np.\nmat\n(para)\n    feature_data = np.\nmat\n(feature_data)    # \nm\n*\nn\n\n    target_data = np.\nmat\n(target_data)\n    # =========é—®é¢˜ä»£ç ï¼Œä¸¤çŸ©é˜µé˜µæ— æ³•ç›¸ä¹˜ï¼Ÿï¼Ÿï¼Ÿï¼Ÿ============#\n    \nd\n = pd.DataFrame(np.array(feature_data))\n    \nprint\n(\nd\n.\ndescribe\n())\n    \nprint\n(\ntype\n(feature_data), \ntype\n(para))\n    \nprint\n(feature_data.shape, para.shape)\n    \nprint\n(feature_data @ para)\n\n    \nError\n = (-1/\nm\n)*np.\nsum\n(np.multiply(target_data,np.\nlog\n(sigmod(feature_data @ para))) +\n                    np.multiply(1-target_data,np.\nlog\n(1-sigmod(feature_data @ para))))\n    \ncount\n = 1\n    error_list = [\nError\n]\n\n    \nwhile\n True:\n        grad_vector = (1/\nm\n) * [feature_data.T @ (sigmod(feature_data @ para) - target_data)]\n        para = para - learning_rate * grad_vector\n        \nError\n = (-1 / \nm\n) * np.\nsum\n(np.multiply(target_data, np.\nlog\n(sigmod(feature_data @ para))) +\n                                np.multiply(1 - target_data, np.\nlog\n(1 - sigmod(feature_data @ para))))\n        error_list.\nappend\n(\nError\n)\n        \ncount\n = \ncount\n + 1\n        \nif\n \ncount\n == account:\n            \nbreak\n\n    \nreturn\n para,error_list\n\npara,\ne\n = Logistic_Regression(X,y,0.01,100)\nplt.\nplot\n(\ne\n)\nplt.show()\n\n\n\n\n\n\n\n###### æ— æ˜¾å¼æŠ¥é”™ï¼Œä½†ç¨‹åºä¸­æ­¢\n\n###### è¯•è¿‡æ›´æ”¹åº“ç‰ˆæœ¬ï¼Œæ— æœ\n", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "https://www.cnblogs.com/peter-le/p/6055782.html", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "å¦‚ä½•åˆ©ç”¨çŸ©é˜µä¹˜æ³•å¿«é€Ÿå¹‚æ±‚æ–æ³¢é‚£å¥‘æ•°åˆ—å‰né¡¹å’Œï¼Ÿ\nã€çŸ©é˜µä¹˜æ³•ã€‘Fibonacci å‰ n é¡¹å’Œ (Standard IO)\n\n\n\né¢˜ç›®æè¿°\n\n\n\n\n\n\nè¾“å…¥\n\nè¾“å…¥n,m\n\n\n\nè¾“å‡º\n\n\n\n\n\n\næ ·ä¾‹è¾“å…¥\n\n\n\n5 1000\n\n\n\n\næ ·ä¾‹è¾“å‡º\n\n\n\n12\n\n\n\n\nnå¾ˆå¤§ï¼Œè¦logï¼ˆnï¼‰çš„æ—¶é—´æ‰èƒ½è¿‡", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "é‚£ä¸ªforæ˜¯å•¥ç©æ„ï¼Œä½ ç¡®å®šç¼–è¯‘æˆåŠŸäº†", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "Cè¯­è¨€çŸ©é˜µä¹˜æ³•ç¼–ç ä¸ºä»€ä¹ˆç»“æœä¸å¯¹ï¼Ÿ\né—®é¢˜é‡åˆ°çš„ç°è±¡å’Œå‘ç”ŸèƒŒæ™¯ çŸ©é˜µä¹˜æ³•ç¼–ç \n\n\nç”¨ä»£ç å—åŠŸèƒ½æ’å…¥ä»£ç ï¼Œè¯·å‹¿ç²˜è´´æˆªå›¾\n\n\n\n\n#include\n\n\n#include\n\n\n#include\n\n\n#include\n\n\n#define N 100\n\n\nint\n main()\n{\n    \nint\n m,n,k;\n    \nint\n i,j,p,sum;\n    \nint\n \nx\n[N][N]=\n{0}\n;\n    \nint\n \ny\n[N][N]=\n{0}\n;\n    \nint\n z[N][N]=\n{0}\n;\n    \nprintf\n(\n\"è¯·è¾“å…¥ç¬¬ä¸€ä¸ªçŸ©é˜µçš„è¡Œæ•°å’Œåˆ—æ•°ï¼š\\n\"\n);\n    scanf(\n\"%d %d\"\n,&m,&k);\n    \nprintf\n(\n\"ç¬¬ä¸€ä¸ªçŸ©é˜µä¸ºï¼š\\n\"\n);\n    \nsrand\n((unsigned)\ntime\n(NULL));\n    \nfor\n (i=\n0\n;i<m;i++)\n    {\n        \nfor\n (j=\n0\n;j<k;j++)\n        {\n            \nx\n[i][k]=\nrand\n()%100;\n            \nprintf\n(\n\"%5d \"\n,\nx\n[i][k]);\n        }\n        \nprintf\n(\n\"\\n\"\n);\n    } \n    \n    \nprintf\n(\n\"è¯·è¾“å…¥ç¬¬äºŒä¸ªçŸ©é˜µçš„åˆ—æ•°ï¼š\\n\"\n);\n    scanf(\n\"%d\"\n,&n);\n    \nprintf\n(\n\"ç¬¬äºŒä¸ªçŸ©é˜µä¸ºï¼š\\n\"\n);\n    \nfor\n (i=\n0\n;i<k;i++)\n    {\n        \nfor\n (j=\n0\n;j<n;j++)\n        {\n            \ny[k][j]\n=\nrand\n()%100;\n            \nprintf\n(\n\"%5d \"\n,\ny[k][j]\n);\n        }\n        \nprintf\n(\n\"\\n\"\n);\n    }\n    \n    \nprintf\n(\n\"è¿™ä¸ªä¸¤ä¸ªçŸ©é˜µçš„ä¹˜ç§¯ä¸ºï¼š\\n\"\n);\n    \nfor\n (i=\n0\n;i<m;i++)\n    {\n        \nfor\n(j=\n0\n;j<n;j++)\n        {\n            sum=\n0\n;\n            \nfor\n(p=\n0\n;p<k;p++)\n            {\n                sum+=\nx\n[i][p]*\ny[p][j]\n;        \n            } \n            z[i][j]=sum;\n            \nprintf\n(\n\"%5d \"\n,z[i][j]);\n        }\n        \nprintf\n(\n\"\\n\"\n);\n    }\n    \nreturn\n \n0\n;\n    \n}\n\n\n\nè¿è¡Œç»“æœåŠæŠ¥é”™å†…å®¹ ä¹˜æ³•ç»“æœå‡ºé”™\n\n\næˆ‘çš„è§£ç­”æ€è·¯å’Œå°è¯•è¿‡çš„æ–¹æ³•\n\n\næˆ‘æƒ³è¦è¾¾åˆ°çš„ç»“æœ æ­£ç¡®è¿è¡Œ", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "æŠ¥ä»€ä¹ˆé”™å‘¢ï¼Œè¾“å‡º3ä¸ªå€¼åé¢æ²¡äº†å—", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "ç”¨Pythonè¯•å›¾å®ç°çŸ©é˜µä¹˜æ³•å‡ºç°äº†ç¨‹åºé—®é¢˜\né—®é¢˜é‡åˆ°çš„ç°è±¡å’Œå‘ç”ŸèƒŒæ™¯\n\n\næˆ‘åœ¨å†™ä¸€ä¸ªPythonç¨‹åºæƒ³å®ç°çŸ©é˜µä¹˜æ³•æ—¶é‡åˆ°äº†ä¸€äº›é—®é¢˜ã€‚\n\n\nm\n,n,\nk\n =\nmap\n(\nint\n,\ninput\n().\nsplit\n(\n\" \"\n))\n\nprint\n(\nm\n,\nk\n)\nmatrix1 =[]\n\nfor\n i in \nrange\n(\nm\n):\n    matrix1.\nappend\n(\nlist\n(\nmap\n(\nint\n,\ninput\n().\nsplit\n(\n\" \"\n))))\nmatrix2 =[]\n\nfor\n i in \nrange\n(n):\n    matrix2.\nappend\n(\nlist\n(\nmap\n(\nint\n,(\ninput\n().\nsplit\n(\n\" \"\n)))))\nmatrix3 =[[\n0\n \nfor\n i in \nrange\n(\nm\n)]\nfor\n \nj\n in \nrange\n(\nk\n)]\n\nfor\n i in \nrange\n(\nm\n):\n    \nfor\n \nj\n in \nrange\n(\nk\n):\n        \nfor\n q in \nrange\n(n):\n            matrix3[i][\nj\n] += matrix1[i][q] * matrix2[q][\nj\n]\n        \nprint\n(matrix3[i][\nj\n],end=\n' '\n)\n    \nprint\n(\n'\\r'\n)\n\n\n\n\né‡åˆ°çš„ç°è±¡å’Œå‘ç”ŸèƒŒæ™¯ï¼Œè¯·å†™å‡ºç¬¬ä¸€ä¸ªé”™è¯¯ä¿¡æ¯\n\n\nç”¨ä»£ç å—åŠŸèƒ½æ’å…¥ä»£ç ï¼Œè¯·å‹¿ç²˜è´´æˆªå›¾ã€‚ ä¸ç”¨ä»£ç å—å›ç­”ç‡ä¸‹é™ 50%\n\n\nè¿è¡Œç»“æœåŠè¯¦ç»†æŠ¥é”™å†…å®¹\n\n\nè¾“å‡ºç»“æœæ—¶åªåˆ°ç¬¬ä¸‰ä¸ªå°±ç»“æŸäº†\n3 5 7\n3 7\n51 61 -2 66 66\n61 33 25 -14 19\n-17 -20 66 67 50\n-3 23 28 25 31 12 14\n11 -8 27 -8 25 9 12\n36 32 10 4 6 28 22\n30 37 23 -8 38 30 25\n38 24 -1 -5 -8 -1 28\n4934 4647 4507\nç¬¬äºŒè¡Œå’Œæœ€åä¸€è¡Œæ˜¯è¿™ä¸ªç¨‹åºè¾“å‡ºçš„ç»“æœ\n\n\nä¸ºä»€ä¹ˆä¼šè¿™æ ·å‘¢ï¼Œçœ‹ä¸å‡ºæ¥æ˜¯å“ªä¸€æ­¥å†™çš„æœ‰é—®é¢˜ğŸ¥²\n\n\næˆ‘çš„è§£ç­”æ€è·¯å’Œå°è¯•è¿‡çš„æ–¹æ³•ï¼Œä¸å†™è‡ªå·±æ€è·¯çš„ï¼Œå›ç­”ç‡ä¸‹é™ 60%\n\n\næˆ‘æƒ³è¦è¾¾åˆ°çš„ç»“æœï¼Œå¦‚æœä½ éœ€è¦å¿«é€Ÿå›ç­”ï¼Œè¯·å°è¯• â€œä»˜è´¹æ‚¬èµâ€", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "\nPerforming 8x8 matrix multipliciation is relatively small work.\nGoroutines (although may be lightweight) do have overhead. If the work they do is \"small\", the overhead of launching, synchronizing and throwing them away may outweight the performance gain of utilizing multiple cores / threads, and overall you might not gain performance by executing such small tasks concurrently (hell, you may even do worse than without using goroutines). Measure.\nIf we increase the matrix size to 80x80, running the benchmark we already see some performance gain in case of ParalMultNaivePerRow:\nBenchmarkMatrixDotNaive/A.MultNaive-4               2000     1054775 ns/op\nBenchmarkMatrixDotNaive/A.ParalMultNaivePerRow-4    2000      709367 ns/op\nBenchmarkMatrixDotNaive/A.ParalMultNaivePerElem-4    100    10224927 ns/op\n\n(As you see in the results, I have 4 CPU cores, running it on your 8-core machine might show more performance gain.)\nWhen rows are small, you are using goroutines to do minimal work, you may improve performance by not \"throwing\" away goroutines once they're done with their \"tiny\" work, but you may \"reuse\" them. See related question: Is this an idiomatic worker thread pool in Go?\nAlso see related / possible duplicate: Vectorise a function taking advantage of concurrency\n", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "å…·æœ‰goroutineçš„çŸ©é˜µä¹˜æ³•ä¼šé™ä½æ€§èƒ½\n\n\n\nI am optimizing matrix multiplication via goroutines in Go.\n\n\n\nMy benchmark shows, introducing concurrency per row or per element largely drops performance:\n\n\n\ngoos: darwin\ngoarch: amd64\nBenchmarkMatrixDotNaive/A.MultNaive-8                            2000000               869 ns/op               0 B/op          0 allocs/op\nBenchmarkMatrixDotNaive/A.ParalMultNaivePerRow-8                  100000             14467 ns/op              80 B/op          9 allocs/op\nBenchmarkMatrixDotNaive/A.ParalMultNaivePerElem-8                  20000             77299 ns/op             528 B/op         65 allocs/op\n\n\n\n\nI know some basic prior knowledge of cache locality, it make sense that per element concurrency drops performance. However, why per row still drops the performance even in naive version?\n\n\n\nIn fact, I also wrote a block/tiling optimization, its vanilla version (without goroutine concurrency) even worse than naive version (not present here, let's focus on naive first). \n\n\n\nWhat did I do wrong here? Why? How to optimize here?\n\n\n\nMultiplication:\n\n\n\npackage naive\n\nimport (\n    \"errors\"\n    \"sync\"\n)\n\n// Errors\nvar (\n    ErrNumElements = errors.New(\"Error number of elements\")\n    ErrMatrixSize  = errors.New(\"Error size of matrix\")\n)\n\n// Matrix is a 2d array\ntype Matrix struct {\n    N    int\n    data [][]float64\n}\n\n// New a size by size matrix\nfunc New(size int) func(...float64) (*Matrix, error) {\n    wg := sync.WaitGroup{}\n    d := make([][]float64, size)\n    for i := range d {\n        wg.Add(1)\n        go func(i int) {\n            defer wg.Done()\n            d[i] = make([]float64, size)\n        }(i)\n    }\n    wg.Wait()\n    m := &Matrix{N: size, data: d}\n    return func(es ...float64) (*Matrix, error) {\n        if len(es) != size*size {\n            return nil, ErrNumElements\n        }\n        for i := range es {\n            wg.Add(1)\n            go func(i int) {\n                defer wg.Done()\n                m.data[i/size][i%size] = es[i]\n            }(i)\n        }\n        wg.Wait()\n        return m, nil\n    }\n}\n\n// At access element (i, j)\nfunc (A *Matrix) At(i, j int) float64 {\n    return A.data[i][j]\n}\n\n// Set set element (i, j) with val\nfunc (A *Matrix) Set(i, j int, val float64) {\n    A.data[i][j] = val\n}\n\n// MultNaive matrix multiplication O(n^3)\nfunc (A *Matrix) MultNaive(B, C *Matrix) (err error) {\n    var (\n        i, j, k int\n        sum     float64\n        N       = A.N\n    )\n\n    if N != B.N || N != C.N {\n        return ErrMatrixSize\n    }\n\n    for i = 0; i < N; i++ {\n        for j = 0; j < N; j++ {\n            sum = 0.0\n            for k = 0; k < N; k++ {\n                sum += A.At(i, k) * B.At(k, j)\n            }\n            C.Set(i, j, sum)\n        }\n    }\n    return\n}\n\n// ParalMultNaivePerRow matrix multiplication O(n^3) in concurrency per row\nfunc (A *Matrix) ParalMultNaivePerRow(B, C *Matrix) (err error) {\n    var N = A.N\n\n    if N != B.N || N != C.N {\n        return ErrMatrixSize\n    }\n\n    wg := sync.WaitGroup{}\n    for i := 0; i < N; i++ {\n        wg.Add(1)\n        go func(i int) {\n            defer wg.Done()\n            for j := 0; j < N; j++ {\n                sum := 0.0\n                for k := 0; k < N; k++ {\n                    sum += A.At(i, k) * B.At(k, j)\n                }\n                C.Set(i, j, sum)\n            }\n        }(i)\n    }\n    wg.Wait()\n    return\n}\n\n// ParalMultNaivePerElem matrix multiplication O(n^3) in concurrency per element\nfunc (A *Matrix) ParalMultNaivePerElem(B, C *Matrix) (err error) {\n    var N = A.N\n\n    if N != B.N || N != C.N {\n        return ErrMatrixSize\n    }\n\n    wg := sync.WaitGroup{}\n    for i := 0; i < N; i++ {\n        for j := 0; j < N; j++ {\n            wg.Add(1)\n            go func(i, j int) {\n                defer wg.Done()\n                sum := 0.0\n                for k := 0; k < N; k++ {\n                    sum += A.At(i, k) * B.At(k, j)\n                }\n                C.Set(i, j, sum)\n            }(i, j)\n        }\n    }\n    wg.Wait()\n    return\n}\n\n\n\n\nBenchmark:\n\n\n\npackage naive\n\nimport (\n    \"os\"\n    \"runtime/trace\"\n    \"testing\"\n)\n\ntype Dot func(B, C *Matrix) error\n\nvar (\n    A = &Matrix{\n        N: 8,\n        data: [][]float64{\n            []float64{1, 2, 3, 4, 5, 6, 7, 8},\n            []float64{9, 1, 2, 3, 4, 5, 6, 7},\n            []float64{8, 9, 1, 2, 3, 4, 5, 6},\n            []float64{7, 8, 9, 1, 2, 3, 4, 5},\n            []float64{6, 7, 8, 9, 1, 2, 3, 4},\n            []float64{5, 6, 7, 8, 9, 1, 2, 3},\n            []float64{4, 5, 6, 7, 8, 9, 1, 2},\n            []float64{3, 4, 5, 6, 7, 8, 9, 0},\n        },\n    }\n    B = &Matrix{\n        N: 8,\n        data: [][]float64{\n            []float64{9, 8, 7, 6, 5, 4, 3, 2},\n            []float64{1, 9, 8, 7, 6, 5, 4, 3},\n            []float64{2, 1, 9, 8, 7, 6, 5, 4},\n            []float64{3, 2, 1, 9, 8, 7, 6, 5},\n            []float64{4, 3, 2, 1, 9, 8, 7, 6},\n            []float64{5, 4, 3, 2, 1, 9, 8, 7},\n            []float64{6, 5, 4, 3, 2, 1, 9, 8},\n            []float64{7, 6, 5, 4, 3, 2, 1, 0},\n        },\n    }\n    C = &Matrix{\n        N: 8,\n        data: [][]float64{\n            []float64{0, 0, 0, 0, 0, 0, 0, 0},\n            []float64{0, 0, 0, 0, 0, 0, 0, 0},\n            []float64{0, 0, 0, 0, 0, 0, 0, 0},\n            []float64{0, 0, 0, 0, 0, 0, 0, 0},\n            []float64{0, 0, 0, 0, 0, 0, 0, 0},\n            []float64{0, 0, 0, 0, 0, 0, 0, 0},\n            []float64{0, 0, 0, 0, 0, 0, 0, 0},\n            []float64{0, 0, 0, 0, 0, 0, 0, 0},\n        },\n    }\n)\n\nfunc BenchmarkMatrixDotNaive(b *testing.B) {\n    f, _ := os.Create(\"bench.trace\")\n    defer f.Close()\n    trace.Start(f)\n    defer trace.Stop()\n\n    tests := []struct {\n        name string\n        f    Dot\n    }{\n        {\n            name: \"A.MultNaive\",\n            f:    A.MultNaive,\n        },\n        {\n            name: \"A.ParalMultNaivePerRow\",\n            f:    A.ParalMultNaivePerRow,\n        },\n        {\n            name: \"A.ParalMultNaivePerElem\",\n            f:    A.ParalMultNaivePerElem,\n        },\n    }\n    for _, tt := range tests {\n        b.Run(tt.name, func(b *testing.B) {\n            for i := 0; i < b.N; i++ {\n                tt.f(B, C)\n            }\n        })\n    }\n}\n\n\n    ", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "http://m.blog.csdn.net/article/details?id=38236769", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "Matrix Multiplication         çŸ©é˜µä¹˜æ³•\nDescription\n\n\n\nMany studies have been done on developing efficient algorithms to calculate matrix multiplication. But it remains as a hard topic today. In this problem you are to calculate the 2006th power of a square Boolean matrix where addition and multiplication are defined as follows:\n\n\n\nA   B   A + B\n\n0   0   0\n\n0   1   1\n\n1   0   1\n\n1   1   1\n\nTruth Table of Addition\n\n\n\nA   B   AB\n\n0   0   0\n\n0   1   0\n\n1   0   0\n\n1   1   1\n\nTruth Table of Multiplication\n\n\n\nLet A be a square matrix. The zeroth power of A is the identity matrix. The n-th (n > 0) power of A is the product of A and its (n âˆ’ 1)-th power.\n\n\n\nInput\n\n\n\nThe input contains multiple test cases. Each test cases consists of some lines:\n\n\n\nLine 1: Contains two integers K (K < 1000) and M (0 â‰¤ M â‰¤ 10K), indicating the dimension of the matrix is K Ã— K and K + M elements of the matrix are 1â€™s.\n\nLines 2 ~ M + 1: Each contains two integers i and j (0 â‰¤ i, j < K, i â‰  j), indicating the element in the (i + 1)-th row and (j + 1)-th column is 1.\n\nAll elements on the primary diagonal of the matrix are 1â€™s.\n\n\n\nOutput\n\n\n\nFor each test case output one line containing the number of elements that are 1â€™s in the 2006th power of the given matrix.\n\n\n\nSample Input\n\n\n\n3 4\n\n1 2\n\n2 1\n\n0 1\n\n0 2\n\nSample Output\n\n\n\n7", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "\n#include <iostream>\nusing namespace std;\n\n \n#include<stdio.h>\nint main()\n{\n    double a[100][100],b[100][100],h[100][100];\n    int m,n,i,j,k,l,c,d;\n    scanf(\"%d %d\",&m,&n);//è¾“å…¥è¡Œæ•°å’Œåˆ—æ•°\n    for(i=0; i<m; i++)\n    {\n        for(j=0; j<n; j++)\n        {\n            scanf(\"%lf\",&a[i][j]);//è¾“å…¥ç¬¬ä¸€ä¸ªçŸ©é˜µ\n        }\n    }\n \n \n    for(l=0; l<n; l++)\n    {\n        for(k=0; k<m; k++)\n        {\n            scanf(\"%lf\",&b[l][k]);//è¾“å…¥ç¬¬äºŒä¸ªçŸ©é˜µ\n        }\n    }\n    for(c=0; c<m; c++) //è¡Œæ•°å°äºç­‰äºç¬¬ä¸€ä¸ªçŸ©é˜µçš„è¡Œæ•°\n    {\n        for(d=0; d<m; d++) //åˆ—æ•°å°äºç­‰äºç¬¬äºŒä¸ªçŸ©é˜µçš„åˆ—æ•°\n        {\n            int sum = 0;\n            for(k=0; k<n; k++) //ç¬¬ä¸€ä¸ªçŸ©é˜µè¡Œæ•°å’Œç¬¬äºŒä¸ªçŸ©é˜µåˆ—æ•°\n            {\n                sum +=a[c][k]*b[k][d];//è®¡ç®—\n            }\n            h[c][d] = sum;\n        }\n    }\n    for(c=0; c<m; c++)\n    {\n        for(d=0; d<m; d++)\n        {\n            printf(\"%.0f \",h[c][d]);//è¾“å‡º\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "å…³äºçŸ©é˜µä¹˜æ³•é—®é¢˜c++\nåœ¨ä¸»å‡½æ•°ä¸­è¾“å…¥Må’ŒN\nè°ƒç”¨å‡½æ•°multiplyï¼ˆï¼‰\nå¹¶è¾“å‡ºçŸ©é˜µc\nc++", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "http://blog.csdn.net/kalilili/article/details/44136861", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "ACè‡ªåŠ¨æœº+çŸ©é˜µä¹˜æ³•                  \nDescription\n\nèƒŒå•è¯ï¼Œå§‹ç»ˆæ˜¯å¤ä¹ è‹±è¯­çš„é‡è¦ç¯èŠ‚ã€‚åœ¨è’åºŸäº†3å¹´å¤§å­¦ç”Ÿæ¶¯åï¼ŒLeleä¹Ÿç»ˆäºè¦å¼€å§‹èƒŒå•è¯äº†ã€‚\n\nä¸€å¤©ï¼ŒLeleåœ¨æŸæœ¬å•è¯ä¹¦ä¸Šçœ‹åˆ°äº†ä¸€ä¸ªæ ¹æ®è¯æ ¹æ¥èƒŒå•è¯çš„æ–¹æ³•ã€‚æ¯”å¦‚\"ab\",æ”¾åœ¨å•è¯å‰ä¸€èˆ¬è¡¨ç¤º\"ç›¸åï¼Œå˜åï¼Œç¦»å»\"ç­‰ã€‚\n\n\n\näºæ˜¯Leleæƒ³ï¼Œå¦‚æœèƒŒäº†Nä¸ªè¯æ ¹ï¼Œé‚£è¿™äº›è¯æ ¹åˆ°åº•ä¼šä¸ä¼šåœ¨å•è¯é‡Œå‡ºç°å‘¢ã€‚æ›´ç¡®åˆ‡çš„æè¿°æ˜¯ï¼šé•¿åº¦ä¸è¶…è¿‡Lï¼Œåªç”±å°å†™å­—æ¯ç»„æˆçš„ï¼Œè‡³å°‘åŒ…å«ä¸€ä¸ªè¯æ ¹çš„å•è¯ï¼Œä¸€å…±å¯èƒ½æœ‰å¤šå°‘ä¸ªå‘¢ï¼Ÿè¿™é‡Œå°±ä¸è€ƒè™‘å•è¯æ˜¯å¦æœ‰å®é™…æ„ä¹‰ã€‚\n\n\n\næ¯”å¦‚ä¸€å…±æœ‰2ä¸ªè¯æ ¹ aa å’Œ ab ï¼Œåˆ™å¯èƒ½å­˜åœ¨104ä¸ªé•¿åº¦ä¸è¶…è¿‡3çš„å•è¯ï¼Œåˆ†åˆ«ä¸º\n\n(2ä¸ª) aa,ab,\n\n(26ä¸ª)aaa,aab,aac...aaz,\n\n(26ä¸ª)aba,abb,abc...abz,\n\n(25ä¸ª)baa,caa,daa...zaa,\n\n(25ä¸ª)bab,cab,dab...zabã€‚\n\n\n\nè¿™ä¸ªåªæ˜¯å¾ˆå°çš„æƒ…å†µã€‚è€Œå¯¹äºå…¶ä»–å¤æ‚ç‚¹çš„æƒ…å†µï¼ŒLeleå®åœ¨æ˜¯æ•°ä¸å‡ºæ¥äº†ï¼Œç°åœ¨å°±è¯·ä½ å¸®å¸®ä»–ã€‚\n\n\n\nInput\n\næœ¬é¢˜ç›®åŒ…å«å¤šç»„æ•°æ®ï¼Œè¯·å¤„ç†åˆ°æ–‡ä»¶ç»“æŸã€‚\n\næ¯ç»„æ•°æ®å ä¸¤è¡Œã€‚\n\nç¬¬ä¸€è¡Œæœ‰ä¸¤ä¸ªæ­£æ•´æ•°Nå’ŒLã€‚(0<N<6,0<L<2^31)\n\nç¬¬äºŒè¡Œæœ‰Nä¸ªè¯æ ¹ï¼Œæ¯ä¸ªè¯æ ¹ä»…ç”±å°å†™å­—æ¯ç»„æˆï¼Œé•¿åº¦ä¸è¶…è¿‡5ã€‚ä¸¤ä¸ªè¯æ ¹ä¸­é—´ç”¨ä¸€ä¸ªç©ºæ ¼åˆ†éš”å¼€ã€‚\n\n\n\nOutput\n\nå¯¹äºæ¯ç»„æ•°æ®ï¼Œè¯·åœ¨ä¸€è¡Œé‡Œè¾“å‡ºä¸€å…±å¯èƒ½çš„å•è¯æ•°ç›®ã€‚\n\nç”±äºç»“æœå¯èƒ½éå¸¸å·¨å¤§ï¼Œä½ åªéœ€è¦è¾“å‡ºå•è¯æ€»æ•°æ¨¡2^64çš„å€¼ã€‚\n\n\n\nSample Input\n\n2 3 aa ab 1 2 a\n\n\n\nSample Output\n\n104 52", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "é™¤ä¹Ÿéœ€è¦ç‚¹é™¤å³./\nZ = sin(sqrt(X.^2+Y.^2))./(sqrt(X.^2+Y.^2)); % XYéƒ½è¦å¤§å†™\n\næœ‰å¸®åŠ©æœ›é‡‡çº³å‘¢", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "Matlabç‚¹ä¹˜ä¸çŸ©é˜µä¹˜æ³•é—®é¢˜çš„è¾¨æ\nè¿™æ˜¯æˆ‘æ‰€è¦å®Œæˆçš„é¢˜ç›®\n\n\nè¿™æ˜¯æˆ‘å†™çš„ä»£ç \n\n\nè¿™æ˜¯æŠ¥çš„é”™è¯¯ï¼Œè¯·é—®è¿™æ˜¯ä¸ºä»€ä¹ˆå•Šï¼Ÿæˆ‘è§‰å¾—ä¸¤ä¸ªçŸ©é˜µéƒ½æ˜¯åŒç»´åº¦å•Šï¼Œä¸ºä»€ä¹ˆæ— æ³•ç›¸ä¹˜å•Šã€‚æ•°å­¦åŸºç¡€å¤ªå·®äº†ï¼Œæœ‰ç‚¹æä¸æ‡‚ä¸ºä»€ä¹ˆä¼šè¿™æ ·ï¼Œæ±‚è§£é‡Šä¸€ä¸‹ï¼\n\n\nå¦‚æœæˆ‘æŠŠä»£ç æ”¹å†™æˆ.^çš„å½¢å¼ï¼Œåˆä¼šå¯¼è‡´Zä¸æ˜¯çŸ©é˜µäº†ï¼Œè¿™åˆæ˜¯ä¸ºä»€ä¹ˆï¼Ÿ\n\n", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "import java.util.*;\nclass Solution {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int num = sc.nextInt();\n        Map<Integer,int[]> map = new HashMap<>();\n        for(int i = 1;i <= num;i++){\n            int[] temp = new int[2];\n            temp[0] = sc.nextInt();//è¡Œæ•°\n            temp[1] = sc.nextInt();//åˆ—æ•°\n            map.put(i,temp);\n        }\n        Map<Integer,int[][]> matrix = new HashMap<>();\n        for(int i = 1;i <= num;i++){\n            int[] temp1 = map.get(i);\n            int rows = temp1[0], clos = temp1[1];\n            int[][] arr = new int[rows][clos];\n            for(int j = 0;j < rows;j++){\n                for(int k = 0;k < clos;k++){\n                    arr[j][k] = sc.nextInt();\n                }\n            } \n            matrix.put(i, arr);\n        }\n        sc.close();\n        //å¼€å§‹éå†mapè¿›è¡ŒçŸ©é˜µä¹˜æ³•\n        int[][] res = multiply(matrix.get(1),matrix.get(2));\n        for(int i = 3;i <= num;i++){\n            res = multiply(res, matrix.get(i));\n        }\n        for(int i = 0;i < res.length;i++){\n            for(int j = 0;j < res[0].length;j++){\n                System.out.print(res[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n    public static int[][] multiply(int[][] m1, int[][] m2){\n        int[][] res = new int[m1.length][m2[0].length];\n        for(int i=0;i<m1.length;i++) {\n            for(int j=0;j<m2[0].length;j++) {\n                for(int k=0;k<m2.length;k++) {\n                    res[i][j] += (m1[i][k] * m2[k][j]) % 514329;\n                }\n            }\n        }\n        return res;\n    }\n}\n\n", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "ç®€å•çš„Javaé¢˜ï¼Œæœ‰å…³çŸ©é˜µä¹˜æ³•\nå‡‘ä¸ªå­—æ•°6666666666666666666666666666666666666666666666666666666666666", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "+=åœ¨å¾ªç¯ä¸­ä»£è¡¨çš„æ˜¯ç´¯åŠ è€Œ=åªæ˜¯æ¯å¾ªç¯ä¸€æ¬¡ç»™c[][]èµ‹ä¸€æ¬¡æ­¤æ¬¡çš„å€¼", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "çŸ©é˜µä¹˜æ³•ï¼Œ+=ä¸=æœ‰ä»€ä¹ˆåŒºåˆ«\n\n\n\n\næˆ‘çŸ¥é“é‚£ä¸ª22è¡Œåº”è¯¥æ¢æˆ+=ï¼Œä½†æ˜¯ä¸ºä»€ä¹ˆ?åŠ ä¸åŠ â€œ+â€æœ‰ä»€ä¹ˆåŒºåˆ«å—ï¼Ÿ", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "åŸºäºnew Bingçš„ä¿®æ”¹ï¼š\n#define ROW 3\n#define COL 4\nint main()\n{\nint arr1[ROW][COL] = { {1,2,3,4}, {5,6,7,8}, {9,10,11,12} };\nint arr2[COL][ROW] = { {12,11,10}, {9,8,7}, {6,5,4}, {3,2,1} };\nint arr3[ROW][ROW] = {0};\nint i,j,k;\nprintf(\"\\narray arr1:\\n\");\nfor(i=0; i<ROW; i++)\n{\nfor(j=0; j<COL; j++)\n{\nprintf(\"%5d\", arr1[i][j]);\n}\nprintf(\"\\n\");\n}\nprintf(\"\\narray arr2:\\n\");\nfor(i=0; i<COL; i++)\n{\nfor(j=0; j<ROW; j++)\n{\nprintf(\"%5d\", arr2[i][j]);\n}\nprintf(\"\\n\");\n}\nprintf(\"\\narray arr1*arr2:\\n\");\nfor(i=0; i<ROW; i++)\n{\nfor(j=0; j<ROW; j++)\n{\nfor(k=0; k<COL; k++)\n{\narr3[i][j] += arr1[i][k] * arr2[k][j];\n}\nprintf(\"%5d\", arr3[i][j]);\n}\nprintf(\"\\n\");\n}\nreturn 0;\n}\n\n", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "å¦‚ä½•ç”¨äºŒç»´æ•°ç»„å®ç°çŸ©é˜µä¹˜æ³•ï¼ˆåˆçº§ï¼‰\nä»£ç å¦‚ä¸‹ï¼š\n\n\n#define \nROW\n \n3\n\n#define \nCOL\n \n4\n\nint main()\n{\n    int arr1[\nROW\n][\nCOL\n] = { \n1\n,\n2\n,\n3\n,\n4\n,\n5\n,\n6\n,\n7\n,\n8\n,\n9\n,\n10\n,\n11\n,\n12\n};\n    int arr2[\nROW\n][\nCOL\n] = { \n12\n,\n11\n,\n10\n,\n9\n,\n8\n,\n7\n,\n6\n,\n5\n,\n4\n,\n3\n,\n2\n,\n1\n };\n    int arr3[\nROW\n][\nCOL\n]={\n0\n};\n    int i,j,k;\n    printf(\n\"\\narray arr1:\\n\"\n); \n    for( i=\n0\n;i<\n3\n;i++)\n    {\n        for( j=\n0\n;j<\n4\n;j++)\n          {\n              arr3[i][j]=arr1[i][j];\n            printf(\n\"%5d\"\n,arr3[i][j]);\n        } \n        printf(\n\"\\n\"\n);\n    }\n    printf(\n\"\\narray arr2:\\n\"\n); \n    for(i=\n0\n;i<\n3\n;i++)\n    {\n        for(j=\n0\n;j<\n4\n;j++)\n          {\n              arr3[i][j]=arr2[i][j];\n            printf(\n\"%5d\"\n,arr3[i][j]);\n        } \n        printf(\n\"\\n\"\n);\n    }\n    printf(\n\"\\narray arr1*arr2:\\n\"\n); \n    for(i=\n0\n;i<\n3\n;i++)\n    {\n        for(j=\n0\n;j<\n4\n;j++)\n          {\n              for( k=\n0\n;k<\n4\n;k++)\n              arr3[i][j]+=arr1[i][k]*arr2[k][j];\n            printf(\n\"%5d\"\n,arr3[i][j]);\n        } \n        printf(\n\"\\n\"\n);\n    }\n    return \n0\n;\n}\n\n\n\n\nè¿è¡Œç»“æœ\n\n\nå¥½åƒç®—é”™äº†ï¼Œä½†æ˜¯ä¸çŸ¥é“å“ªé‡Œé”™äº†ã€‚", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "ChatGPTå°è¯•ä¸ºæ‚¨è§£ç­”ï¼Œä»…ä¾›å‚è€ƒ\n#include <stdio.h>\n\n#define ROW_A 3\n#define COL_A 4\n#define COL_B 2\n\nint main(void) {\n    int A[ROW_A][COL_A];  // å®šä¹‰ 3x4 çŸ©é˜µ A\n    int B[COL_A][COL_B];  // å®šä¹‰ 4x2 çŸ©é˜µ B\n    int C[ROW_A][COL_B];  // å®šä¹‰ 3x2 çŸ©é˜µ C\n\n    // è¾“å…¥çŸ©é˜µ A çš„å€¼\n    printf(\"Enter the values for matrix A (%dx%d):\\n\", ROW_A, COL_A);\n    for (int i = 0; i < ROW_A; i++) {\n        for (int j = 0; j < COL_A; j++) {\n            scanf(\"%d\", &A[i][j]);\n        }\n    }\n\n    // è¾“å…¥çŸ©é˜µ B çš„å€¼\n    printf(\"Enter the values for matrix B (%dx%d):\\n\", COL_A, COL_B);\n    for (int i = 0; i < COL_A; i++) {\n        for (int j = 0; j < COL_B; j++) {\n            scanf(\"%d\", &B[i][j]);\n        }\n    }\n    \n    // è®¡ç®—çŸ©é˜µä¹˜æ³•\n    for (int i = 0; i < ROW_A; i++) {\n        for (int j = 0; j < COL_B; j++) {\n            C[i][j] = 0;\n            for (int k = 0; k < COL_A; k++) {\n                C[i][j] += A[i][k] * B[k][j];\n            }\n        }\n    }\n\n    // è¾“å‡ºç»“æœ\n    printf(\"Result:\\n\");\n    for (int i = 0; i < ROW_A; i++) {\n        for (int j = 0; j < COL_B; j++) {\n            printf(\"%d \", C[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n\nåœ¨è¿™ä¸ªç¨‹åºä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆå®šä¹‰äº† 3x4 çš„çŸ©é˜µ Aã€4x2 çš„çŸ©é˜µ B å’Œ 3x2 çš„çŸ©é˜µ Cï¼Œç„¶åè¯»å…¥çŸ©é˜µ A å’Œ B çš„å€¼ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸‰é‡å¾ªç¯æ¥è®¡ç®—çŸ©é˜µä¹˜æ³•ï¼Œæœ€åè¾“å‡ºã€‚", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "ğŸ˜­çœŸçš„ä¸ä¼šï¼é©¬ä¸Šè¦äº¤äº†ï¼#Cè¯­è¨€#æ•°ç»„çŸ©é˜µä¹˜æ³•\nè¯·è®¾è®¡ä¸€ä¸ªç¨‹åºï¼šåˆ©ç”¨äºŒç»´æ•°ç»„æ¥è¡¨ç¤ºçŸ©é˜µï¼Œå®ç°ä¸€ä¸ª3x4çŸ©é˜µ A ä¸4x2çŸ©é˜µ B ç›¸ä¹˜ï¼Œå¹¶æŠŠç»“æœå­˜æ”¾åœ¨ä¸€ä¸ª3x2çš„çŸ©é˜µ C ä¸­ã€‚çŸ©é˜µ A ã€ B çš„åˆå§‹åŒ–ç”±ç”¨æˆ·è¿›è¡Œè¾“å…¥ã€‚", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "æ²¡æœ‰åˆå§‹åŒ–æ•°ç»„", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "è¯·é—®è¿™ä¸ªæ±‚çŸ©é˜µä¹˜æ³•çš„ç¨‹åºå“ªé‡Œé”™äº†ï¼Ÿ\n#include \n\nint main(void)\n\n{\n\n    int ar1[2][2] = { {2,0},{1,0} };\n\n    int ar2[2][2] = { {1,2} ,{0,0} };\n\n    int ar3[2][2];\n\n    int i;\n\n    int j;\n\n    int c=2;\n\n    int k;\n\n    for (i = 0; i < 2; i++)\n\n        for (j = 0; j < 2; j++)\n\n            for (k = 0; k < c; k++)\n\n                ar3[i][j] += ar1[i][k] * ar2[k][j];\n\n    for (i = 0; i < 2; i++)\n\n    {\n\n        for (j = 0; j < 2; j++)\n\n        {\n\n            printf(\"%d\\t\", ar3[i][j]);\n\n        }\n\n        printf(\"\\n\");\n\n    }\n\n\n\nreturn 0;\n\n\n\n\n}", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "ä»£ç æ˜¯åœ¨è®¾å¤‡ä¸Šè¿è¡Œçš„ä¹ˆï¼Œæ²¡æœ‰ä½¿ç”¨ä¸»æœºå˜é‡å§ï¼Œæ²¡æœ‰çˆ†å†…å­˜å§ï¼Œè¿˜æœ‰é©±åŠ¨ç¨‹åºå¯¹ä¸å¯¹ã€‚ä½ å¯ä»¥å…ˆæµ‹è¯•è‡ªå¸¦çš„ä¾‹å­ç¨‹åºï¼Œæ’é™¤ç¯å¢ƒé—®é¢˜ã€‚", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "cudaæ ¸å‡½æ•°ä¸æ‰§è¡Œçš„å¯èƒ½åŸå› ï¼Ÿ\nç»ƒä¹ äº†ä¸€ä¸ªçŸ©é˜µä¹˜æ³•çš„ä¾‹å­ï¼Œæ¯ä¸ªblocké…ç½®16Ã—16ä¸ªthreadï¼Œ\n\nå½“åš5000Ã—5000çš„çŸ©é˜µä¹˜æ³•æ—¶ï¼Œç»“æœå°±å…¨ä¸º0ï¼Œæ ¸å‡½æ•°ä¸æ‰§è¡Œä¸çŸ¥é“åŸå› æ˜¯ä»€ä¹ˆï¼Ÿ\n\næ¯ä¸ªgridæ¯ä¸€ç»´å¯ä»¥åŒ…å«è‡³å°‘65535ä¸ªblockï¼Œç®—äº†ä¸‹æ²¡æœ‰è¶…å‡ºä½†æ˜¯æ ¸å‡½æ•°æ²¡æ‰§è¡Œã€‚ã€‚ã€‚", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "è§£ç­”å¦‚ä¸‹\n#include<stdio.h>\nvoid input(int n,int t[][n])\n{\n    for(int i=0; i<n; i++)\n    {\n        for(int j=0; j<n; j++)\n        {\n            scanf(\"%d\",&t[i][j]);\n        }\n    }\n}\nvoid put(int n,int t[][n])\n{\n    for(int i=0; i<n; i++)\n    {\n        for(int j=0; j<n; j++)\n        {\n            printf(\"%d \",t[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}\nvoid swap(int *a,int *b)\n{\n    int c=*a;\n    *a=*b;\n    *b=c;\n}\nvoid trans(int n,int t[][n])\n{\n    for(int i=0; i<n; i++)\n    {\n        for(int j=i; j<n; j++)\n        {\n            swap(&t[i][j],&t[j][i]);\n        }\n    }\n}\nvoid add(int n,int t1[][n],int t2[][n])\n{\n    for(int i=0; i<n; i++)\n    {\n        for(int j=0; j<n; j++)\n        {\n            t1[i][j]+=t2[i][j];\n        }\n    }\n}\n\nvoid mul(int n,int t1[][n],int t2[][n])\n{\n    for(int i=0; i<n; i++)\n    {\n        for(int j=0; j<n; j++)\n        {\n            t1[i][j]*=t2[i][j];\n        }\n    }\n}\nint main()\n{\n    int n;\n    printf(\"1,è½¬ç½®\\n\");\n    printf(\"2,åŠ æ³•\\n\");\n    printf(\"3,ä¹˜æ³•\\n\");\n    printf(\"other,é€€å‡º\\n\");\n    int option;\n    scanf(\"%d\",&option);\n    if(option==1)\n    {\n        printf(\"è¾“å…¥çŸ©é˜µè¡Œæ•°ï¼š\");\n        scanf(\"%d\",&n);\n        printf(\"è¾“å…¥çŸ©é˜µï¼š\\n\");\n        int t1[n][n];\n        input(n,t1);\n        trans(n,t1);\n        printf(\"--------\\n\");\n        put(n,t1);\n    }\n    else if(option==2)\n    {\n        printf(\"è¾“å…¥çŸ©é˜µè¡Œæ•°ï¼š\");\n        scanf(\"%d\",&n);\n        int t1[n][n];\n        int t2[n][n];\n        printf(\"è¾“å…¥çŸ©é˜µ1ï¼š\\n\");\n        input(n,t1);\n        printf(\"è¾“å…¥çŸ©é˜µ2ï¼š\\n\");\n        input(n,t2);\n        add(n,t1,t2);\n        printf(\"--------\\n\");\n        put(n,t1);\n    }\n    else if(option==3)\n    {\n        printf(\"è¾“å…¥çŸ©é˜µè¡Œæ•°ï¼š\");\n        scanf(\"%d\",&n);\n        int t1[n][n];\n        int t2[n][n];\n        printf(\"è¾“å…¥çŸ©é˜µ1ï¼š\\n\");\n        input(n,t1);\n        printf(\"è¾“å…¥çŸ©é˜µ2ï¼š\\n\");\n        input(n,t2);\n        mul(n,t1,t2);\n        printf(\"--------\\n\");\n        put(n,t1);\n    }\n    else\n    {\n        return 0;\n    }\n}\n", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "Cè¯­è¨€åˆ¶ä½œç¨€ç–çŸ©é˜µè¿ç®—å™¨ï¼Œè¦æ±‚ä¸ä½¿ç”¨ä¸‰é‡åŠä¸‰é‡ä»¥ä¸ŠåµŒå¥—å¾ªç¯ï¼Œæ—¶é—´å¤æ‚åº¦è¾ƒä½\nCè¯­è¨€åšä¸€ä¸ªç¨€ç–çŸ©é˜µè¿ç®—å™¨ï¼Œè¦æ±‚ä¸ä½¿ç”¨ä¸‰é‡åŠä¸‰é‡ä»¥ä¸ŠåµŒå¥—å¾ªç¯ï¼Œå¹¶ä¸”æ—¶é—´å¤æ‚åº¦è¾ƒä½ï¼Œå¯ä»¥å®ç°çŸ©é˜µè¿ç®—å™¨çš„çŸ©é˜µè½¬ç½®ï¼ŒçŸ©é˜µåŠ å‡æ³•ï¼ŒçŸ©é˜µä¹˜æ³•ï¼Œé€€å‡ºè¿ç®—äº”ä¸ªåŠŸèƒ½ï¼Œå¯ä»¥é€‚å½“è¿½åŠ èµé‡‘ã€‚", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "å‚è€ƒè¿™ç¯‡æ–‡ç« https://blog.csdn.net/GreenHandCGL/article/details/81164349?ops_request_misc=&request_id=&biz_id=102&utm_term=python%20%E5%90%91%E9%87%8F%E7%9F%A9%E9%98%B5&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-81164349.142^v10^control,157^v4^control&spm=1018.2226.3001.4187", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "ä¸¤ä¸ªå…³äºpython çŸ©é˜µå’Œå‘é‡è®¡ç®—æ–¹é¢çš„ä»£ç é—®é¢˜\næˆ‘ç°åœ¨æƒ³æŠŠä¸€ä¸ªå‘é‡ä¸­çš„å¤šä¸ªæŒ‡å®šä½ç½®çš„å€¼æ›¿æ¢æˆä¸€ä¸ªå€¼ï¼Œä»£ç æ˜¯æ€ä¹ˆæ ·çš„ï¼Ÿï¼ˆä¸‹å›¾ï¼‰\n\n\n\n\nå¦å¤–è¦å®ç°ä¸€ä¸‹å‘é‡å’ŒçŸ©é˜µä¹˜æ³•ç”¨ä»€ä¹ˆä»£ç ï¼Ÿï¼ˆä¸‹å›¾ï¼‰\n\n", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "pythonä¸­ä¹˜æ³•æ˜¯ä½¿ç”¨å¥½,ä½ å°†@æ”¹ä¸ºå³å¯", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "pythonä¸­åˆ—è¡¨è½¬ä¸ºçŸ©é˜µåæ— æ³•è¿›è¡ŒçŸ©é˜µçš„ä¹˜æ³•è¿ç®—\nå„ä½å¤§ä½¬ï¼Œè¿™ä¸ªä¸ºä»€ä¹ˆä¸€ç›´æŠ¥è¿™ä¸ªé”™è¯¯ï¼Œä¸ºä»€ä¹ˆæ²¡åŠæ³•è¿›è¡ŒçŸ©é˜µçš„ä¹˜æ³•å‘€ï¼Ÿ", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "ä¾›å‚è€ƒï¼š\n#include <stdio.h>\n#define N 20\nint is_symmetricmatrix(int a[][N], int Row,int Col)//åˆ¤æ–­ä¸€ä¸ªN*NçŸ©é˜µï¼Œæ˜¯å¦æ˜¯å¯¹ç§°çŸ©é˜µï¼Œæ˜¯è¿”å›1ï¼Œå¦è¿”å›0\n{\n    int i, j, flag;\n    for (i = 0, flag = 1; i < Row; i++)\n    {\n        for (j = 0; j < i; j++)\n        {\n            if (a[i][j] != a[j][i])\n            {\n                flag = 0;\n                break;\n            }\n        }\n        if (j < i) break;\n    }\n    if (flag)\n        return 1;\n    else\n        return 0;\n}\nvoid getTransposeMatrix(int b[][N], int a[][N], int Row, int Col)//çŸ©é˜µè½¬ç½®\n{\n    int i, j;\n    for (i = 0; i < Row; i++)\n        for (j = 0; j < Col; j++)\n            b[j][i] = a[i][j];\n}\nvoid matrixMul(int a[][N], int b[][N], int c[][N], int Rowa, int Cola, int Colb)//çŸ©é˜µç›¸ä¹˜\n{\n    int i, j, k;\n    for(i=0;i<Rowa;i++)\n    {\n        for (j = 0; j < Colb; j++)\n        {\n            for (k = 0; k < Cola; k++)\n                c[i][j] += a[i][k] * b[k][j];\n        }\n    }\n}\nvoid matrixAdd(int a[][N], int b[][N], int c[][N], int Rowa, int Cola)//çŸ©é˜µç›¸åŠ \n{\n    int i, j;\n    for (i = 0; i < Rowa; i++)\n        for (j = 0; j < Cola; j++)\n            c[i][j] = a[i][j] + b[i][j];\n}\nvoid printmatrix(int a[][N], int Row, int Col)\n{\n    int i, j;\n    for (i = 0; i < Row; i++){\n        for (j = 0; j < Col; j++)\n        {\n            printf(\"%d \", a[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\nint main()\n{\n    int a[N][N] = { 0 }, b[N][N] = { 0 }, c[N][N] = {0}, i, j, n = 3;\n    scanf(\"%d\", &n);\n    for (i = 0; i < n; i++)\n        for (j = 0; j < n; j++)\n            scanf(\"%d\", &a[i][j]);\n    if (is_symmetricmatrix(a, n, n))\n    {\n        printf(\"YES\\n\");\n        getTransposeMatrix(b, a, n, n);\n        matrixMul(a, b, c, n, n, n);\n        printmatrix(c, n, n);\n    }\n    else{\n        printf(\"NO\\n\");\n        getTransposeMatrix(b, a, n, n);\n        matrixAdd(a, b, c, n, n);\n        printmatrix(c, n, n);\n    }\n    return 0;\n}\n\n", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "æœ‰å…³æ•°ç»„ä¸å‡½æ•°çš„çŸ©é˜µè¿ç®—\nçŸ©é˜µè¿ç®—\næè¿°\nå®ç°ä»é”®ç›˜ä¸Šè¯»å–ä¸€ä¸ªæ•°nï¼Œè¾“å…¥n*nçš„çŸ©é˜µAï¼Œé¦–å…ˆåˆ¤æ–­çŸ©é˜µAæ˜¯å¦ä¸ºå®å¯¹ç§°çŸ©é˜µï¼ˆå®å¯¹ç§°çŸ©é˜µï¼šné˜¶çŸ©é˜µAï¼Œå…¶çŸ©é˜µçš„å…ƒç´ éƒ½ä¸ºå®æ•°ï¼Œä¸”çŸ©é˜µAçš„è½¬ç½®ç­‰äºå…¶æœ¬èº«ï¼ˆaij=ajiï¼‰ï¼Œ(i,jä¸ºå…ƒç´ çš„è„šæ ‡ï¼‰ï¼Œåˆ™ç§°Aä¸ºå®å¯¹ç§°çŸ©é˜µã€‚ï¼‰\n\n\nå¦‚æœæ˜¯å®å¯¹ç§°çŸ©é˜µåˆ™è¾“å‡º YESï¼Œå†æ¢è¡Œè¾“å‡ºçŸ©é˜µA*A^Tçš„ç»“æœï¼ˆA^Tä¸ºAçš„è½¬ç½®ï¼‰ ã€‚\n\n\nå¦‚æœä¸æ˜¯å®å¯¹ç§°çŸ©é˜µåˆ™è¾“å‡ºNOï¼Œå†è¾“å‡ºçŸ©é˜µA+A^Tçš„ç»“æœï¼ˆA^Tä¸ºAçš„è½¬ç½®ï¼‰ã€‚\n\n\nä»¥ä¸ŠçŸ©é˜µè¾“å‡ºéƒ½ä»¥nè¡Œnåˆ—çš„æ ¼å¼è¾“å‡ºï¼Œæ¯ä¸ªå…ƒç´ ç”¨ç©ºæ ¼éš”å¼€ï¼Œåœ¨æ¯è¡Œæœ€åä¸€ä¸ªå…ƒç´ è¾“å‡ºæ¢è¡Œã€‚\n\n\nï¼ˆ1ï¼‰çŸ©é˜µåŠ æ³•å…¬å¼ï¼šæ¯è¡Œæ¯åˆ—å¯¹åº”å…ƒç´ ç›¸åŠ ï¼ŒCij=Aij + Bijï¼›\n\n\nï¼ˆ2ï¼‰çŸ©é˜µä¹˜æ³•å…¬å¼ï¼šCij = Ai0Ã—B0j+Ai1Ã—B1j+â€¦â€¦+AinÃ—Bnjï¼›\n\n\nè¾“å…¥\nä»é”®ç›˜ä¸Šè¾“å…¥ä¸€ä¸ªæ•°nåå†è¾“å…¥n*nçš„çŸ©é˜µAã€‚\n\n\nè¾“å‡º\nåˆ¤æ–­çŸ©é˜µAæ˜¯å¦ä¸ºå®å¯¹ç§°çŸ©é˜µï¼ˆå®å¯¹ç§°çŸ©é˜µï¼šné˜¶çŸ©é˜µAï¼Œå…¶çŸ©é˜µçš„å…ƒç´ éƒ½ä¸ºå®æ•°ï¼Œä¸”çŸ©é˜µAçš„è½¬ç½®ç­‰äºå…¶æœ¬èº«ï¼ˆaij=ajiï¼‰ï¼Œ(i,jä¸ºå…ƒç´ çš„è„šæ ‡ï¼‰ï¼Œåˆ™ç§°Aä¸ºå®å¯¹ç§°çŸ©é˜µã€‚ï¼‰\n\n\nå¦‚æœæ˜¯å®å¯¹ç§°çŸ©é˜µåˆ™è¾“å‡º YESï¼Œå†æ¢è¡Œè¾“å‡ºçŸ©é˜µA*A^Tçš„ç»“æœï¼ˆA^Tä¸ºAçš„è½¬ç½®ï¼‰ ï¼Œ\n\n\nå¦‚æœä¸æ˜¯å®å¯¹ç§°çŸ©é˜µåˆ™è¾“å‡ºNOï¼Œå†æ¢è¡Œè¾“å‡ºçŸ©é˜µA+A^Tçš„ç»“æœï¼ˆA^Tä¸ºAçš„è½¬ç½®ï¼‰ã€‚\n\n\nä»¥ä¸ŠçŸ©é˜µè¾“å‡ºéƒ½ä»¥nè¡Œnåˆ—çš„æ ¼å¼è¾“å‡ºï¼Œæ¯ä¸ªå…ƒç´ ç”¨ç©ºæ ¼éš”å¼€ï¼Œåœ¨æ¯è¡Œæœ€åä¸€ä¸ªå…ƒç´ è¾“å‡ºæ¢è¡Œã€‚ï¼ˆæœ€åä¸€ä¸ªå…ƒç´ åé¢æ²¡æœ‰ç©ºæ ¼ï¼‰", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "package juzhen;\nimport java.util.Random;\n//1ï¼‰ç”Ÿæˆä¸€ä¸ªdâˆ—Lç»´çŸ©é˜µï¼ˆ2ï¼‰çŸ©é˜µä¹˜æ³•ï¼ˆ3ï¼‰ä¸»è¦è®¡ç®—çŸ©é˜µHçš„Moore-Penroseå¹¿ä¹‰é€†ï¼Œå®ƒå¯ä»¥é€šè¿‡çŸ©é˜µHä¸å…¶è½¬ç½®çŸ©é˜µHTç›¸ä¹˜\n\npublic class JuZhen {\nÂ Â  Â public static Integer[][] getJuZhen(int d,int l){\nÂ Â  Â Â Â  Â Integer results[][]=new Integer[d][l];\nÂ Â  Â Â Â  Â Random random=new Random();\nÂ Â  Â Â Â  Â for(int i=0;i<d;i++) {\nÂ Â  Â Â Â  Â Â Â  Â for(int j=0;j<l;j++) {\nÂ Â  Â Â Â  Â Â Â  Â Â Â  Â results[i][j]=random.nextInt(100);\nÂ Â  Â Â Â  Â Â Â  Â Â Â  Â System.out.print(results[i][j]+\" Â  Â \");\nÂ Â  Â Â Â  Â Â Â  Â }\nÂ Â  Â Â Â  Â Â Â  Â System.out.println();\nÂ Â  Â Â Â  Â }\nÂ Â  Â Â Â  Â return results;\nÂ Â  Â }\nÂ Â  Â \nÂ Â  Â public static Integer[][] chengMethod(Integer[][] first,Integer[][] second){//æ±‚çŸ©é˜µä¹˜æ³•\nÂ Â  Â Â Â  Â int firstD=first.length;\nÂ Â  Â Â Â  Â int firstL=first[0].length;\nÂ Â  Â Â Â  Â int secondD=second.length;\nÂ Â  Â Â Â  Â int secondL=second[0].length;\nÂ Â  Â Â Â  Â Integer results[][]=new Integer[firstD][secondL];\nÂ Â  Â Â Â  Â Integer firstLv[]=null;\nÂ Â  Â Â Â  Â Integer secondDv=0;\nÂ Â  Â Â Â  Â int j=0,m=0;\nÂ Â  Â Â Â  Â int i=0,n=0,count=0;\nÂ Â  Â Â Â  Â int temp=0;\nÂ Â  Â Â Â  Â Â Â  Â for(;i<firstD;) {\nÂ Â  Â Â Â  Â Â Â  Â Â Â  Â firstLv=first[i];\nÂ Â  Â Â Â  Â Â Â  Â Â Â  Â for(n=0;n<secondD;n++) {\nÂ Â  Â Â Â  Â Â Â  Â Â Â  Â Â Â  Â secondDv=second[n][m];\nÂ Â  Â Â Â  Â Â Â  Â Â Â  Â Â Â  Â temp+=firstLv[n]*secondDv;Â Â  Â Â Â  Â Â Â  Â Â Â  Â Â Â  Â \nÂ Â  Â Â Â  Â Â Â  Â Â Â  Â }\nÂ Â  Â Â Â  Â Â Â  Â Â Â  Â results[i][m]=temp;\nÂ Â  Â Â Â  Â Â Â  Â Â Â  Â temp=0;\nÂ Â  Â Â Â  Â Â Â  Â Â Â  Â System.out.println(results[i][m]);\nÂ Â  Â Â Â  Â Â Â  Â Â Â  Â m++;\nÂ Â  Â Â Â  Â Â Â  Â Â Â  Â if(m==secondL) {\nÂ Â  Â Â Â  Â Â Â  Â Â Â  Â Â Â  Â m=0;\nÂ Â  Â Â Â  Â Â Â  Â Â Â  Â Â Â  Â i++;\nÂ Â  Â Â Â  Â Â Â  Â Â Â  Â }\nÂ Â  Â Â Â  Â Â Â  Â }\nÂ Â  Â Â Â  Â return results;\nÂ Â  Â }\nÂ Â  Â public static Integer[][] zhuanzhi(Integer[][] juzhen){\nÂ Â  Â Â Â  Â Integer m=juzhen.length;\nÂ Â  Â Â Â  Â Integer n=juzhen[0].length;\nÂ Â  Â Â Â  Â Integer results[][]=new Integer[n][m];\n//Â Â  Â Â Â  Â for(int i=0;i<m;i++) {\n//Â Â  Â Â Â  Â Â Â  Â for(int j=0;j<n;j++) {\n//Â Â  Â Â Â  Â Â Â  Â Â Â  Â System.out.print(juzhen[i][j] +\" Â  \");\n//Â Â  Â Â Â  Â Â Â  Â }\n//Â Â  Â Â Â  Â Â Â  Â System.out.println();\n//Â Â  Â Â Â  Â }\n//Â Â  Â Â Â  Â System.out.println(\"-----------------------------\");\nÂ Â  Â Â Â  Â for(int i=0;i<n;i++) {\nÂ Â  Â Â Â  Â Â Â  Â for(int j=0;j<m;j++) {\nÂ Â  Â Â Â  Â Â Â  Â Â Â  Â results[i][j]=juzhen[j][i];\nÂ Â  Â Â Â  Â Â Â  Â Â Â  Â System.out.print(results[i][j]+\" Â  Â \");\nÂ Â  Â Â Â  Â Â Â  Â }\nÂ Â  Â Â Â  Â Â Â  Â System.out.println();\nÂ Â  Â Â Â  Â }\nÂ Â  Â Â Â  Â return results;\nÂ Â  Â }\nÂ Â  Â public static void main(String[] args) {\nÂ Â  Â Â Â  Â Integer first[][]= {{2,3,4},{3,4,5}};\nÂ Â  Â Â Â  Â Integer second[][]= {{4,7},{5,3},{2,3}};\n//Â Â  Â Â Â  Â chengMethod(first,second);\nÂ Â  Â Â Â  Â Integer hInteger[][]=getJuZhen(3, 4);\nÂ Â  Â Â Â  Â Integer results[][]=zhuanzhi(hInteger);\nÂ Â  Â Â Â  Â chengMethod(hInteger, results);\n//Â Â  Â Â Â  Â getJuZhen(3, 4);\nÂ Â  Â }\n}\nÂ ", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "Javaå®ç°ä»¥ä¸‹ç®—æ³•\n\n\n\nï¼ˆ1ï¼‰ç”Ÿæˆä¸€ä¸ªdâˆ—Lç»´çŸ©é˜µï¼ˆ2ï¼‰çŸ©é˜µä¹˜æ³•ï¼ˆ3ï¼‰ä¸»è¦è®¡ç®—çŸ©é˜µHçš„Moore-Penroseå¹¿ä¹‰é€†ï¼Œå®ƒå¯ä»¥é€šè¿‡çŸ©é˜µHä¸å…¶è½¬ç½®çŸ©é˜µHTç›¸ä¹˜", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "æŠŠè¿™äº›å˜é‡å£°æ˜ä¸ºç¬¦å·å˜é‡å°±å¯ä»¥ï¼Œæ¯”å¦‚sym a;  è¿™å°±æ˜¯å£°æ˜aæ˜¯ç¬¦å·å˜é‡ã€‚", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "MATLABèƒ½å®ç°å«å‚çŸ©é˜µçš„ä¹˜æ³•å—\næ¯”å¦‚[a b;c d]*[e f;g h],é‡Œé¢çš„çŠ¶æ€å˜é‡ä¸èµ‹å€¼ï¼Œå¾—å‡ºå«å‚çš„äºŒä¹˜äºŒçŸ©é˜µ", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "ä½ å¥½ï¼Œæˆ‘æ˜¯æœ‰é—®å¿…ç­”å°åŠ©æ‰‹ï¼Œéå¸¸æŠ±æ­‰ï¼Œæœ¬æ¬¡æ‚¨æå‡ºçš„æœ‰é—®å¿…ç­”é—®é¢˜ï¼ŒæŠ€æœ¯ä¸“å®¶å›¢è¶…æ—¶æœªä¸ºæ‚¨åšå‡ºè§£ç­” æœ¬æ¬¡æé—®æ‰£é™¤çš„æœ‰é—®å¿…ç­”æ¬¡æ•°ï¼Œå·²ç»ä¸ºæ‚¨è¡¥å‘åˆ°è´¦æˆ·ï¼Œæˆ‘ä»¬åç»­ä¼šæŒç»­ä¼˜åŒ–ï¼Œæ‰©å¤§æˆ‘ä»¬çš„æœåŠ¡èŒƒå›´ï¼Œä¸ºæ‚¨å¸¦æ¥æ›´å¥½åœ°æœåŠ¡ã€‚", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "matlabå…³äºcvx sdpçš„é—®é¢˜\né—®é¢˜é‡åˆ°çš„ç°è±¡å’Œå‘ç”ŸèƒŒæ™¯\n\n\nåœ¨cvx sdpä¸­ï¼Œæˆ‘æƒ³åœ¨çº¦æŸæ¡ä»¶ä¸­è¡¨è¾¾ä¸€ä¸ªçŸ©é˜µä¸ºåŠæ­£å®šï¼Œæ˜¯ç”¨A>=0è¿˜æ˜¯ç”¨A==semidefinite(n)æ¥è¡¨ç¤ºå‘¢ï¼Œä¸¤è€…éƒ½è¡Œå˜›ï¼Œè¿˜æ˜¯æœ‰ä»€ä¹ˆåŒºåˆ«\n\n\né—®é¢˜ç›¸å…³ä»£ç ï¼Œè¯·å‹¿ç²˜è´´æˆªå›¾\n\n\nP13+S3*theta0*S1*theta0'*S3'>=0\n;\n\nP13+S3*theta0*S1*theta0'*S3'==semidefinite(\nn\n)\n;\n\n\n\n\n\nè¿è¡Œç»“æœåŠæŠ¥é”™å†…å®¹\n\n\nç¬¬ä¸€ä¸ªè¿è¡Œä¸æŠ¥é”™ï¼›\nä½†ç¬¬äºŒä¸ªä¼šæŠ¥ä¸€ä¸ªå¥‡æ€ªçš„é”™è¯¯è¯´ç”¨äºçŸ©é˜µä¹˜æ³•çš„ç»´åº¦ä¸æ­£ç¡®ã€‚è¯·æ£€æŸ¥å¹¶ç¡®ä¿ç¬¬ä¸€ä¸ªçŸ©é˜µä¸­çš„åˆ—æ•°ä¸ç¬¬äºŒä¸ªçŸ©é˜µä¸­çš„è¡Œæ•°åŒ¹é…ã€‚è¦æ‰§è¡ŒæŒ‰å…ƒç´ ç›¸ä¹˜ï¼Œè¯·ä½¿ç”¨ '.*'ã€‚\n\n\næˆ‘çš„è§£ç­”æ€è·¯å’Œå°è¯•è¿‡çš„æ–¹æ³•\n\n\næ— \n\n\næˆ‘æƒ³è¦è¾¾åˆ°çš„ç»“æœ\n\n\næƒ³çŸ¥é“è¿™ä¸¤ç§éƒ½å¯ä»¥å˜›ï¼Œæœ‰ä»€ä¹ˆåŒºåˆ«å˜›", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "è¿™ä¸ªé—®é¢˜å¾ˆæœ‰å¯èƒ½æ˜¯æ•°ç»„è¶Šç•Œæˆ–è€…æŒ‡é’ˆå¼•ç”¨äº†æ— æ•ˆçš„å†…å­˜ï¼Œä½ å¯ä»¥å°è¯•åœ¨ç¨‹åºä¸­æ·»åŠ ä¸€äº›è°ƒè¯•ä»£ç ï¼Œæ¥è¿½è¸ªç¨‹åºçš„æ‰§è¡Œæƒ…å†µã€‚\nå…·ä½“çš„ï¼Œä½ å¯ä»¥ä½¿ç”¨ä»¥ä¸‹æ–¹æ³•æ¥å®šä½é”™è¯¯ï¼š\nåœ¨ä»£ç ä¸­åŠ å…¥è®¸å¤š cout è¯­å¥ï¼Œæ¥è¿½è¸ªå˜é‡çš„å€¼ï¼Œä»¥åŠç¨‹åºçš„æ‰§è¡Œæƒ…å†µï¼Œè¿™æœ‰åŠ©äºä½ äº†è§£ç¨‹åºæ˜¯å¦‚ä½•æ‰§è¡Œçš„ã€‚\nä½¿ç”¨æ–­ç‚¹è°ƒè¯•ï¼Œæ¥æ£€æŸ¥ç¨‹åºåœ¨æ‰§è¡Œæ—¶æ˜¯å¦å‡ºç°é”™è¯¯ã€‚\nä½¿ç”¨ assert è¯­å¥ï¼Œå¦‚æœä¸€ä¸ªè¡¨è¾¾å¼çš„ç»“æœä¸º falseï¼Œåˆ™ç¨‹åºå°†ä¸­æ­¢æ‰§è¡Œï¼Œè¿™æœ‰åŠ©äºä½ å®šä½é”™è¯¯ã€‚\nå¸Œæœ›è¿™äº›å»ºè®®èƒ½å¸®åŠ©ä½ æ‰¾åˆ°é—®é¢˜æ‰€åœ¨ã€‚", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "C++çŸ©é˜µç±»å®šä¹‰ï¼Œé‡åˆ°äº†Segmentation fault\nOJç³»ç»Ÿä¸€ç›´æç¤ºï¼šSegmentation fault:æ®µé”™è¯¯ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰æ•°ç»„è¶Šç•Œï¼ŒæŒ‡é’ˆå¼‚å¸¸ï¼Œè®¿é—®åˆ°ä¸åº”è¯¥è®¿é—®çš„å†…å­˜åŒºåŸŸ\n\n\nä½†æ˜¯ä¸€ç›´æ£€æŸ¥ä¸å‡ºæ¥å“ªé‡Œæœ‰é”™è¯¯ã€‚äºŒç»´åŠ¨æ€æ•°ç»„è¿™ä¸ªé—®é¢˜å›°æ‰°æˆ‘å¥½ä¹…äº†ï¼Œæ±‚æŒ‡ç‚¹ï¼\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\n//çŸ©é˜µç±»å®šä¹‰\n\n\nclass\n \nMatrix\n\n{\n\npublic\n:\n    \nMatrix\n(\nint\n, \nint\n);\n    \nvoid\n \nset\n(\nint\n, \nint\n)\n;\n    \nfriend\n istream& \noperator\n>>(istream &, Matrix&);\n    \nfriend\n ostream& \noperator\n<<(ostream&, \nconst\n Matrix&);\n    Matrix& \noperator\n*(Matrix&);\n    \nvoid\n \nDiagonalOrder\n()\n;\n    \nvoid\n \nsetZeros\n()\n;\n    \n\nprotected\n:\n    \nint\n** mat;                                     \n//çŸ©é˜µï¼ˆäºŒä½æ•°ç»„ï¼‰\n\n    \nint\n row;                                        \n//è¡Œæ•°\n\n    \nint\n col;                                         \n//åˆ—æ•°\n\n};\n\nMatrix \ntemp\n(\n0\n,\n0\n)\n;                               \n//å®šä¹‰å…¨å±€å¯¹è±¡ï¼Œç”¨äºæ¥å—çŸ©é˜µä¹˜æ³•ç»“æœ\n\n\nvoid\n \nMatrix::set\n(\nint\n n, \nint\n m)\n                \n\n{\n    row = n;\n    col = m;\n    mat = \nnew\n \nint\n* [n];\n    \nfor\n (\nint\n i = \n0\n; i < n; i++)\n    {\n        mat[i] = \nnew\n \nint\n[m];\n    }\n    \nif\n (mat == \nNULL\n)\n    {\n        cout << \n\"allocation failure!\\n\"\n;\n        \nreturn\n;\n    }\n    \nfor\n (\nint\n i = \n0\n; i < n; i++)\n    {\n        \nfor\n (\nint\n j = \n0\n; j < m; j++)\n        {\n            mat[i][j] = \n0\n;\n        }\n    }\n}\nMatrix::\nMatrix\n(\nint\n n, \nint\n m)                       \n//æ„é€ å‡½æ•°ï¼Œåˆå§‹åŒ–è¡Œæ•°åˆ—æ•°ä¸çŸ©é˜µ\n\n{\n    row = n;\n    col = m;\n    \nif\n (m > \n0\n && n > \n0\n)\n    {\n        mat = \nnew\n \nint\n* [n];\n        \nfor\n (\nint\n i = \n0\n; i < n; i++)\n        {\n            mat[i] = \nnew\n \nint\n[m];\n        }\n        \nif\n (mat == \nNULL\n)\n        {\n            cout << \n\"allocation failure!\\n\"\n;\n            \nreturn\n;\n        }\n        \nfor\n (\nint\n i = \n0\n; i < n; i++)\n        {\n            \nfor\n (\nint\n j = \n0\n; j < m; j++)\n            {\n                mat[i][j] = \n0\n;\n            }\n        }\n    }\n    \nelse\n\n        mat = \nNULL\n;\n}\nistream& \noperator\n>>(istream& input, Matrix& a)        \n//é‡è½½è¾“å…¥è¿ç®—ç¬¦\n\n{\n    \nfor\n (\nint\n i = \n0\n; i < a.row; i++)\n    {\n        \nfor\n (\nint\n j = \n0\n; j < a.col; j++)\n        {\n            input >> a.mat[i][j];\n        }\n    }\n    \nreturn\n input;\n}\nostream& \noperator\n<<(ostream& output,\nconst\n Matrix& a)     \n//é‡è½½è¾“å‡ºè¿ç®—ç¬¦\n\n{\n   \n    \nfor\n (\nint\n i = \n0\n; i < a.row; i++)\n    {\n        \nfor\n (\nint\n j = \n0\n; j < a.col\n-1\n; j++)\n        {\n            output << a.mat[i][j] << \n\" \"\n;\n        }\n        cout << a.mat[i][a.col - \n1\n] << endl;\n    }\n    \nreturn\n output;\n}\n\nMatrix& Matrix::\noperator\n*(Matrix&a)                        \n//é‡è½½çŸ©é˜µä¹˜æ³•\n\n{\n    \nif\n (col == a.row)\n    {\n        temp.\nset\n(row, a.col);\n        \n        \nfor\n (\nint\n i = \n0\n; i < temp.row; i++)\n        {\n            \nfor\n (\nint\n j = \n0\n; j < temp.col; j++)\n            {\n                \nint\n sum = \n0\n;\n                \nint\n k = \n0\n,o = \n0\n;\n                \nwhile\n (k < col && o < a.row)\n                {\n                    sum += mat[i][k] * a.mat[o][j];\n                    k++; o++;\n                }\n                \n                temp.mat[i][j] = sum;\n            }\n        }\n        \nreturn\n temp;\n    }\n    \nelse\n\n    {\n        cout << \n\"can't multiply!\"\n << endl;\n        \n    }\n}\n\nvoid\n \nMatrix::DiagonalOrder\n()\n                                               \n//ä¹‹å­—å½¢æ‰“å°\n\n\n{\n    \n        cout << mat[\n0\n][\n0\n] << \n\" \"\n;\n    \n       \n        \nint\n is_up = \n1\n;\n        \nint\n x = \n0\n, y = \n0\n;\n        \nwhile\n (x >= \n0\n && x <= row - \n1\n && y >= \n0\n && y <= col - \n1\n)\n        {\n            \nif\n (x == \n0\n)\n            {\n                \nif\n (y == \n0\n)\n                {\n                    y++;\n                    is_up = \n0\n;                  \n                }\n                \nelse\n \nif\n(y=\n0\n&&y> m >> n) {\n\n        \nMatrix \nmat1\n(m, n)\n;\n\n        cin >> mat1;\n\n\n\n        \nint\n x, y;\n\n        cin >> x >> y;\n\n        \nMatrix \nmat2\n(x, y)\n;\n\n        cin >> mat2;\n\n\n\n        Matrix res = mat1 * mat2;\n\n        cout << res;\n\n\n\n        mat1.\nDiagonalOrder\n();\n\n\n\n        mat1.\nsetZeros\n();\n\n        cout << mat1;\n\n    }\n\n    \nreturn\n \n0\n;\n\n}\n\n", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "æˆ‘å‚»äº†ï¼ŒæŠŠåŠ å·å†™æˆä¹˜å·äº†", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "XDä»¬ï¼Œå†æ¥å¸®å¸®æˆ‘å“‡.....\n  å¤§ä¸€cè¯­è¨€ï¼Œå‡½æ•°æ˜¯çŸ©é˜µä¹˜æ³•ï¼Œè¾“å…¥ä¸¤ä¸ªçŸ©é˜µåŠå…¶è¡Œæ•°å’Œåˆ—æ•°ï¼ŒæŠŠç­”æ¡ˆæ‰“å°åœ¨å±å¹•ä¸Šã€‚æˆ‘è‡ªå·±æµ‹è¯•äº†ä¸€æ¬¡ï¼Œå‘ç°ä¹˜å®Œçš„æ–°çŸ©é˜µçš„è¡Œåˆ—æ•°å’Œé¢„æœŸç›¸ç¬¦ï¼Œä½†æ˜¯é‡Œé¢çš„æ•°å­—ä¸å¯¹ã€‚\n\n\nvoid\n \nmultiply\n(\nint\n* p, \nint\n a, \nint\n b, \nint\n* q, \nint\n c, \nint\n d)\n//på’Œq æ˜¯ç”¨æŒ‡é’ˆä»£æ›¿çš„äºŒç»´æ•°ç»„ï¼Œa,bæ˜¯ç¬¬ä¸€ä¸ªçŸ©é˜µçš„è¡Œæ•°å’Œåˆ—æ•°ï¼Œc,dæ˜¯ç¬¬äºŒä¸ªçŸ©é˜µçš„è¡Œæ•°ä¸åˆ—æ•°\n\n\n{\n    \nif\n (b == c)\n//åˆ¤æ–­è¾“å…¥çš„ä¸¤ä¸ªçŸ©é˜µæ˜¯å¦æ»¡è¶³çŸ©é˜µç›¸ä¹˜çš„æ¡ä»¶\n\n    {\n        \nint\n w,x,y,z;\n        \nfloat\n o;\n        \nfor\n (w = \n0\n; w <= a - \n1\n; w++)\n//æ§åˆ¶ç¬¬ä¸€ä¸ªçŸ©é˜µçš„è¡Œæ•°\n\n        {\n            \nfor\n(z=\n0\n;z<=d\n-1\n;z++)\n//æ§åˆ¶ç¬¬äºŒä¸ªçŸ©é˜µçš„åˆ—æ•°\n\n            { \n                  \nfor\n (o = x = y = \n0\n; y <= c - \n1\n; y++,x++)\n//ç”¨ç¬¬ä¸€ä¸ªçŸ©é˜µæ¯è¡Œçš„æ•°ä¹˜ç¬¬äºŒä¸ªçŸ©é˜µå¯¹åº”çš„æ¯ä¸€åˆ—çš„æ•°\n\n                  {\n                    o = o + *(p + w * b + x) + *(q + d * y + z);\n//å°†æ¯ä¸€æ¬¡ç›¸ä¹˜å¾—åˆ°çš„ç»“æœä½œä¸ºæ–°çŸ©é˜µçš„æ¯ä¸€é¡¹\n\n                    \n                  }\n                  \nprintf\n(\n\"%1.3f  \"\n, o);\n//å°†æ–°çŸ©é˜µçš„æ¯ä¸€é¡¹æ‰“å°åœ¨å±å¹•ä¸Š\n\n            }\n            \nprintf\n(\n\"\\n\"\n);\n//æ¢è¡Œ\n\n        }\n    }\n    \nelse\n \nprintf\n(\n\"è¾“å…¥çš„çŸ©é˜µä¸ç¬¦åˆåšä¹˜æ³•è¿ç®—çš„æ¡ä»¶\\n\"\n);\n//åˆ¤æ–­è¾“å…¥çš„ä¸¤ä¸ªçŸ©é˜µæ˜¯å¦æ»¡è¶³çŸ©é˜µç›¸ä¹˜çš„æ¡ä»¶\n\n}\n", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "ä½ å¥½ï¼Œæˆ‘æ˜¯æœ‰é—®å¿…ç­”å°åŠ©æ‰‹ï¼Œéå¸¸æŠ±æ­‰ï¼Œæœ¬æ¬¡æ‚¨æå‡ºçš„æœ‰é—®å¿…ç­”é—®é¢˜ï¼ŒæŠ€æœ¯ä¸“å®¶å›¢è¶…æ—¶æœªä¸ºæ‚¨åšå‡ºè§£ç­” æœ¬æ¬¡æé—®æ‰£é™¤çš„æœ‰é—®å¿…ç­”æ¬¡æ•°ï¼Œå·²ç»ä¸ºæ‚¨è¡¥å‘åˆ°è´¦æˆ·ï¼Œæˆ‘ä»¬åç»­ä¼šæŒç»­ä¼˜åŒ–ï¼Œæ‰©å¤§æˆ‘ä»¬çš„æœåŠ¡èŒƒå›´ï¼Œä¸ºæ‚¨å¸¦æ¥æ›´å¥½åœ°æœåŠ¡ã€‚", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "matlabå…³äº cvx sdpçš„é—®é¢˜\né—®é¢˜é‡åˆ°çš„ç°è±¡å’Œå‘ç”ŸèƒŒæ™¯\n\n\næˆ‘æƒ³åœ¨cvx sdpä¸­å†™ä¸€ä¸ªçº¿æ€§ä¸ç­‰å¼çš„çº¦æŸæ¡ä»¶ï¼Œå¦‚å›¾\n\n\né—®é¢˜ç›¸å…³ä»£ç ï¼Œè¯·å‹¿ç²˜è´´æˆªå›¾\n\n\ncvx_begin sdp\n    variables W1x(\nNt\n,Nt) W2x(\nNt\n,Nt) \n    variable Zx(\nNt\n,Nt)  complex semidefinite\n    variable p13  nonnegative\n    variable p23  nonnegative\n    variable p14  nonnegative\n    variable p24  nonnegative\n S1=(\nh_BI*\n((\n2\n^(\nre\n)\n-1\n)*Zx-W1x)*h_BI')\n;\n\nP13=[k*(\n2\n^(\nre\n)\n-1\n)-p13,zeros(\n1\n,M_irs)\n;zeros(M_irs,1),p13*e*eye(M_irs)];\n\nä¸­é—´çœç•¥\nsubject to\nP13+S3*theta0*S1*theta0'*S3' ==semidefinite(\nM_irs+1\n)\n;\n\n\n\n\nè¿è¡Œç»“æœåŠæŠ¥é”™å†…å®¹\n\n\né”™è¯¯ä½¿ç”¨  *\nç”¨äºçŸ©é˜µä¹˜æ³•çš„ç»´åº¦ä¸æ­£ç¡®ã€‚è¯·æ£€æŸ¥å¹¶ç¡®ä¿ç¬¬ä¸€ä¸ªçŸ©é˜µä¸­çš„åˆ—æ•°ä¸ç¬¬äºŒä¸ªçŸ©é˜µä¸­çš„è¡Œæ•°åŒ¹é…ã€‚è¦æ‰§è¡ŒæŒ‰å…ƒç´ ç›¸ä¹˜ï¼Œè¯·ä½¿ç”¨ '.*'ã€‚\n\n\næˆ‘çš„è§£ç­”æ€è·¯å’Œå°è¯•è¿‡çš„æ–¹æ³•\n\n\nåªè¦åŠ ä¸Šä¸Šè¿°çº¦æŸæ¡ä»¶å°±ä¸å¯¹ï¼Œä½†æ˜¯çŸ©é˜µç»´åº¦éƒ½æ£€æŸ¥è¿‡äº†ï¼Œæ²¡æœ‰é—®é¢˜ï¼Œå¦‚æœæŠŠçº¦æŸæ¡ä»¶å•ç‹¬æ‹¿å‡ºæ¥è¿è¡Œï¼Œä¹Ÿä¸æŠ¥é”™ï¼Œåªè¦æ”¾åˆ°çº¦æŸæ¡ä»¶é‡Œå°±æŠ¥é”™ï¼Œä¸çŸ¥é“æ˜¯ä¸æ˜¯å› ä¸ºcvxä¸èƒ½æ£€æŸ¥LMIæ˜¯å¦å¯¹ç§°ï¼Œæˆ‘è§‰å¾—ä¸æ˜¯çŸ©é˜µç»´åº¦é—®é¢˜ï¼Œå¯èƒ½æ˜¯æˆ‘å…³äºcvx sdpã€LMIçŸ¥è¯†ä¸ç†Ÿç»ƒå¯¼è‡´çš„\n\n\næˆ‘æƒ³è¦è¾¾åˆ°çš„ç»“æœ\n\n\nä¸æŠ¥é”™", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "è¿™ä¸ªææ‚äº†å—ï¼Ÿæä¾›ä¸€ä¸ª 3*3 çš„æ ·æœ¬æ¥æµ‹è¯•ä¸€ä¸‹ã€‚", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "Pythonç¼–ç¨‹ï¼šæ–°çŸ©é˜µè¿ç®—\nç»™å®šä¸¤ä¸ªå¤§å°ç›¸åŒæ–¹é˜µï¼Œå°†ç»å…¸çŸ©é˜µä¹˜ç§¯è¿ç®—ä¿®æ”¹ï¼šå°†åŸæ¥çš„å…ƒç´ ä¹‹é—´çš„ä¹˜æ³•æ”¹ä¸ºåŠ æ³•ï¼Œå°†åŸæ¥çš„åŠ æ³•æ”¹ä¸ºå–å°ã€‚ è®¾A=(ai,j) nÃ—n ,B=(bi,j\n)nÃ—nï¼Œ æ–°è¿ç®—çš„ç»“æœä¸ºC=(ci,j) nÃ—nï¼Œåˆ™ci,j = min{ai,k+bk,j,k=1,â‹¯,n}\n\n\nè¾“å…¥æ ¼å¼:\nç¬¬ä¸€è¡Œè¾“å…¥ä¸€ä¸ªæ•´æ•°nï¼Œè¡¨ç¤ºæ–¹é˜µçš„å¤§å°ã€‚\nç¬¬äºŒè¡Œåˆ°2n+1è¡Œï¼Œæ¯ä¸€è¡Œæ•°æ®æœ‰nä¸ªï¼Œç©ºæ ¼éš”å¼€ã€‚\nç¬¬äºŒè¡Œè¡Œåˆ°n+1è¡Œæ˜¯çŸ©é˜µAçš„å…ƒç´ ã€‚\næœ€ånè¡Œæ˜¯çŸ©é˜µBçš„å…ƒç´ ã€‚\n\n\nè¯´æ˜ï¼šnä¸è¶…è¿‡100ï¼ŒçŸ©é˜µæ‰€æœ‰å…ƒç´ éƒ½æ˜¯æ•´æ•°ã€‚\n\n\nè¾“å‡ºæ ¼å¼:\nè¾“å‡ºçŸ©é˜µC\n\n\nè¾“å…¥æ ·ä¾‹:\n2\n33 44\n33 44\n55 33\n55 33\nè¾“å‡ºæ ·ä¾‹:\n88 66\n88 66\næ ·ä¾‹è§£é‡Šï¼š\nçŸ©é˜µAä¸º\n\n\n33 44\n33 44\n\n\nçŸ©é˜µBä¸º\n55 33\n55 33\nè¾“å‡ºç»“æœçŸ©é˜µCä¸º\n88 66\n88 66", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "åŒå­¦ï¼Œä½ çš„indicesæåäº†\nindices = np.vstack(( arr.row, arr.col)).transpose()\n", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "å…³äº tensorflow 1.x sparse_tensor_dense_matmul çš„é—®é¢˜\ntf.sparse_tensor_dense_matmul æ˜¯å¯¹ç¨€ç–å¼ é‡å’Œç¨ å¯†å¼ é‡åšçŸ©é˜µä¹˜æ³•çš„å‡½æ•°ï¼Œä½†ä¸ºä»€ä¹ˆæˆ‘è¿ç®—çš„ç»“æœä¸ numpy è¿ç®—ç»“æœä¸åŒï¼Ÿ\n\n\nimport numpy \nas\n np\nimport tensorflow \nas\n tf\nimport scipy.sparse \nas\n sp\n\narr = np.\narray\n(\n[[\n1.\n,\n2.\n,\n5.\n,\n2.\n]\n,\n[\n3.\n,\n4.\n,\n1.\n,\n2.\n]\n,\n[\n3.\n,\n5.\n,\n2.\n,\n6.\n]\n,\n[\n4.\n,\n13.\n,\n2.\n,\n10.\n]\n]) # \n4\n*\n4\n\narr = sp.coo\n_matrix(\narr\n)\n\n\nb = np.\narray\n(\n[[\n1.\n]\n,\n[\n2.\n]\n,\n[\n3.\n]\n,\n[\n4.\n]\n])\nb = tf.convert\n_to_tensor(\nb\n, \ndtype\n=\ntf\n.\nfloat32\n)\n\n\n\n\nif\n not sp.isspmatrix\n_coo(\narr\n)\n:\n    arr = arr.tocoo\n()\n\n\narr = arr.astype(np.float32)\nindices = np.vstack((arr.col, arr.row)).transpose\n()\n\n\n\na_sp = tf.\nSparseTensor(\nindices\n=\nindices\n, \nvalues\n=\narr\n.\ndata\n, \ndense_shape\n=\narr\n.\nshape\n)\n\n\n\nwith\n tf.\nSession()\n \nas\n sess:\n    m=tf.sparse\n_tensor_dense_matmul(\na_sp\n, \nb\n)\n\n    print(sess.run(m))\n\n\n\nç»“æœï¼š\n\n\n[\n[32.]\n\n \n[77.]\n\n \n[21.]\n\n \n[64.]\n]\n\n\n\n\nnumpy ä¸‹ï¼š\n\n\nx\n = np.array([[\n1\n,\n2\n,\n5\n,\n2\n],[\n3\n,\n4\n,\n1\n,\n2\n],[\n3\n,\n5\n,\n2\n,\n6\n],[\n4\n,\n13\n,\n2\n,\n10\n]],dtype=np.float)\n\ny\n = np.array([[\n1\n],[\n2\n],[\n3\n],[\n4\n]], dtype=np.float)\n\nx\n @ y\n\n\n\nç»“æœï¼š\n\n\narray(\n[\n[28.]\n,\n       \n[22.]\n,\n       \n[43.]\n,\n       \n[76.]\n]\n\n", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "http://blog.csdn.net/zufejsjcy/article/details/44604185", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "çŸ©é˜µçš„ä¹˜æ³•è¿ç®—æ€ä¹ˆæ±‚è§£ï¼Ÿ\nLet us consider undirected graph G = \n\nwhich has N vertices and M edges. Incidence matrix of this graph is N * M matrix A = {aij}, such that aij is 1 if i-th vertex is one of the ends of j-th edge and 0 in the other case. Your task is to find the sum of all elements of the matrix ATA.\n\n\n\nThis problem contains multiple test cases!\n\nThe first line of a multiple input is an integer N, then a blank line followed by N input blocks. Each input block is in the format indicated in the problem description. There is a blank line between input blocks.\n\nThe output format consists of N output blocks. There is a blank line between output blocks.\n\n\n\nInput\n\nThe first line of the input file contains two integer numbers - N and M (2 <= N <= 10 000, 1 <= M <= 100 000). 2M integer numbers follow, forming M pairs, each pair describes one edge of the graph. All edges are different and there are no loops (i.e. edge ends are distinct).\n\n\n\nOutput\n\nOutput the only number - the sum requested.\n\n\n\nSample Input\n\n1\n\n\n\n4 4\n\n1 2\n\n1 3\n\n2 3\n\n2 4\n\n\n\nSample Output\n\n18", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "https://blog.csdn.net/weixin_45268427/article/details/106822204", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "ç¼–å†™ä¸€ä¸ªJavaç¨‹åºï¼Œåˆ†åˆ«ç”¨ç‚¹ä¹˜å’Œå‰ä¹˜çš„æ–¹æ³•è®¡ç®—ä¸¤ä¸ªçŸ©é˜µçš„ä¹˜æ³•ä»¥åŠç‰¹å¾å€¼?\nç¼–å†™ä¸€ä¸ªJavaç¨‹åºï¼Œåˆ†åˆ«ç”¨ç‚¹ä¹˜å’Œå‰ä¹˜çš„æ–¹æ³•è®¡ç®—ä¸¤ä¸ªçŸ©é˜µçš„ä¹˜æ³•ä»¥åŠç‰¹å¾å€¼?", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "ä¾›å‚è€ƒï¼š\n//ã€C0369ã€‘åº”ç”¨å‡½æ•°è¾“å‡ºç»™å®šæ­£æ•´æ•°çš„å› å­å±•å¼€å¼\n#include <stdio.h>\n/* è¯·åœ¨è¿™é‡Œå¡«å†™ç­”æ¡ˆ*/\nvoid solve(int x)\n{\n    int i = 2, k = 0;\n    while (x != 1){\n        if (x % i == 0){\n            printf(k++ == 0 ? \"%d\" : \"*%d\", i);\n            x /= i;\n        }\n        else {\n            i++;\n        }\n    }\n}\nint main() {\n    void solve(int);\n    int x;\n    scanf(\"%d\", &x);\n    if (x < 2) printf(\"error data\");\n    else {\n        printf(\"%d=\", x);\n        solve(x);\n    }\n    return 0;\n}\n\n\n//ã€C0371ã€‘åº”ç”¨å‡½æ•°å®ç°çŸ©é˜µä¹˜æ³•\n//è£åˆ¤æµ‹è¯•ç¨‹åºæ ·ä¾‹ï¼š\n#include <stdio.h>\n/* è¯·åœ¨è¿™é‡Œå¡«å†™ç­”æ¡ˆ */\nvoid f(int a[], int b[], int c[], int m, int n, int t)\n{\n    int i, j, k;\n    for (i = 0; i < m; i++)\n        for (j = 0; j < m; j++)\n            for (k = 0, c[i * t + j] = 0; k < n; k++)\n                c[i * t + j] += a[i * n + k] * b[k * m + j];\n}\nint main() {\n    int i, j, a[3][4], b[4][3], c[3][3];\n    for (i = 0; i < 3; i++)\n        for (j = 0; j < 4; j++)\n            scanf(\"%d\", &a[i][j]);\n    for (i = 0; i < 4; i++)\n        for (j = 0; j < 3; j++)\n            scanf(\"%d\", &b[i][j]);\n    f(a[0], b[0], c[0], 3, 4, 3);\n    for (i = 0; i < 3; i++) {\n        for (j = 0; j < 3; j++)\n            printf(\"%5d\", c[i][j]);\n        printf(\"\\n\");\n    }\n}\n\n\n//6-3 ã€C0373ã€‘åº”ç”¨é€’å½’å‡½æ•°å®ç°èµ·æ³¡æ’åº\n//è£åˆ¤æµ‹è¯•ç¨‹åºæ ·ä¾‹ï¼š\n#include <stdio.h>\n#define N 20\n/* è¯·åœ¨è¿™é‡Œå¡«å†™ç­”æ¡ˆ */\nvoid sort(int a[], int n)\n{\n    int tmp;\n    if (n == 1)\n        return;\n    else {\n        for (int i = 0; i < n - 1; i++) {\n            if (a[i] < a[i + 1]) {\n                tmp = a[i];\n                a[i] = a[i + 1];\n                a[i + 1] = tmp;\n            }\n        }\n        sort(a, n - 1);\n    }\n}\nint main() {\n    int a[N], i, n;\n    scanf(\"%d\", &n);\n    if (n > 20) printf(\"error data\");\n    else {\n        for (i = 0; i < n; i++)\n            scanf(\"%d\", &a[i]);\n        sort(a, n);\n        for (i = 0; i < n; i++)\n            printf(\"%5d\", a[i]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "æ‹¼é¢˜aä¸Šçš„å‡ ä¸ªéš¾é¢˜ï¼Œå‡ ä¸ªåŒå­¦å¯¹ç…§ç€ç­”æ¡ˆå°è¯•äº†å‡ æ¬¡ä¾å°±æŠ¥é”™\nå®éªŒé¢˜ï¼Œæ€»æ˜¯ä¸å¯¹\nã€C0369ã€‘åº”ç”¨å‡½æ•°è¾“å‡ºç»™å®šæ­£æ•´æ•°çš„å› å­å±•å¼€å¼\n\n\nå®Œæˆç¨‹åºï¼Œè®¾è®¡å®ç°å‡½æ•°void solve(int x) ï¼Œå…¶åŠŸèƒ½ä¸ºè¾“å‡ºä¸€ä¸ªç»™å®šæ­£æ•´æ•°xï¼ˆx>1ï¼‰çš„è´¨å› å­å±•å¼€å¼ã€‚\n\n\nå‡½æ•°æ¥å£å®šä¹‰ï¼š\nvoid solve(int x);/\nåŠŸèƒ½ä¸ºè¾“å‡ºä¸€ä¸ªç»™å®šæ­£æ•´æ•°xï¼ˆx>1ï¼‰çš„è´¨å› å­å±•å¼€å¼\n/\nè£åˆ¤æµ‹è¯•ç¨‹åºæ ·ä¾‹ï¼š\n#include \n\n\n/* è¯·åœ¨è¿™é‡Œå¡«å†™ç­”æ¡ˆ */\n\n\nint main(){\n    void solve(int);\n    int x;\n    scanf(\"%d\",&x);\n    if(x<2)  printf(\"error data\");\n    else{\n        printf(\"%d=\",x);\n        solve(x);\n    }\n    return 0;\n}\nè¾“å…¥æ ¼å¼ï¼š\nè¯·åœ¨ä¸€è¡Œä¸­è¾“å…¥æ•´æ•°xçš„å€¼ã€‚\n\n\nè¾“å‡ºæ ¼å¼ï¼š\nå¯¹æ¯ä¸€ç»„è¾“å…¥çš„xï¼ŒæŒ‰ä»¥ä¸‹æ ¼å¼è¾“å‡ºxçš„è´¨å› å­å±•å¼€å¼ï¼ˆå‡å¦‚xçš„è´¨å› å­åˆ†åˆ«ä¸ºaã€bã€cï¼‰ï¼š\n\n\nx=a\nb\nc\n\n\nè¾“å…¥æ ·ä¾‹1ï¼š\n72\nè¾“å‡ºæ ·ä¾‹1ï¼š\n72=2\n2\n2\n3\n3\nè¾“å…¥æ ·ä¾‹2ï¼š\n1\nè¾“å‡ºæ ·ä¾‹2ï¼š\nerror data\nè¾“å…¥æ ·ä¾‹3ï¼š\n5\nè¾“å‡ºæ ·ä¾‹3ï¼š\n5=5\n\n\nã€C0371ã€‘åº”ç”¨å‡½æ•°å®ç°çŸ©é˜µä¹˜æ³•\n\n\nå®Œæˆç¨‹åºï¼Œè®¾è®¡å®ç°å‡½æ•°void f(int a[],int b[],int c[],int m,int n,int t)ï¼Œå…¶åŠŸèƒ½ä¸ºè®¡ç®—ç»™å®šçš„ä¸¤ä¸ªæ•´å‹æ•°ç»„ï¼ˆä¸€ä¸ªä¸ºmè¡Œnåˆ—ï¼Œä¸€ä¸ªä¸ºnè¡Œtåˆ—ï¼‰çš„ä¹˜ç§¯çŸ©é˜µã€‚\n\n\nå‡½æ•°æ¥å£å®šä¹‰ï¼š\nvoid f(int a[],int b[],int c[],int m,int n,int t);/\nåŠŸèƒ½ä¸ºè®¡ç®—ç»™å®šçš„çŸ©é˜µaï¼ˆmè¡Œnåˆ—ï¼‰å’ŒçŸ©é˜µbï¼ˆnè¡Œtåˆ—ï¼‰çš„ä¹˜ç§¯çŸ©é˜µc\n/\nè£åˆ¤æµ‹è¯•ç¨‹åºæ ·ä¾‹ï¼š\n#include \n\n\n/* è¯·åœ¨è¿™é‡Œå¡«å†™ç­”æ¡ˆ */\n\n\nint main(){\n    int i,j,a[3][4],b[4][3],c[3][3];\n    for(i=0; i<3; i++)\n        for(j=0; j<4; j++)\n            scanf(\"%d\",&a[i][j]);\n    for(i=0; i<4; i++)\n        for(j=0; j<3; j++)\n            scanf(\"%d\",&b[i][j]);\n    f(a[0],b[0],c[0],3,4,3);\n    for(i=0; i<3; i++){\n        for(j=0; j<3; j++)\n            printf(\"%5d\",c[i][j]);\n        printf(\"\\n\");\n    }\n}\nè¾“å…¥æ ¼å¼ï¼š\né¦–å…ˆè¾“å…¥æ•´å‹æ•°ç»„a[3][4]çš„å„å…ƒç´ çš„å€¼ï¼Œå†è¾“å…¥æ•´å‹æ•°ç»„b[4][3]çš„å„å…ƒç´ çš„å€¼ï¼Œæ•°æ®ä¸­é—´ä»¥ç©ºæ ¼ä¸ºé—´éš”ã€‚\n\n\nè¾“å‡ºæ ¼å¼ï¼š\nå¯¹äºè¾“å…¥çš„aæ•°ç»„å’Œbæ•°ç»„ï¼Œè¾“å‡ºaå’Œbçš„ä¹˜ç§¯çŸ©é˜µc[3][3]ï¼Œå…¶ä¸­æ¯ä¸ªå…ƒç´ æ˜¾ç¤ºæ ¼å¼ä¸ºï¼šå 5åˆ—ï¼Œå³å¯¹é½ã€‚\n\n\nè¾“å…¥æ ·ä¾‹ï¼š\n1 2 3 4\n2 3 4 5\n3 4 5 6\n1 2 3\n2 3 4\n3 4 5\n4 5 6\nè¾“å‡ºæ ·ä¾‹ï¼š\n   30   40   50\n   40   54   68\n   50   68   86\n\n\n6-3 ã€C0373ã€‘åº”ç”¨é€’å½’å‡½æ•°å®ç°èµ·æ³¡æ’åº\n\n\nå®Œæˆç¨‹åºï¼Œè®¾è®¡å®ç°é€’å½’å‡½æ•°void sort(int a[],int n)ï¼Œå…¶åŠŸèƒ½ä¸ºä½¿ç”¨â€œèµ·æ³¡æ³•â€å¯¹aæ•°ç»„å­˜å‚¨çš„nï¼ˆn<=20ï¼‰ä¸ªæ•°æŒ‰ä»å¤§åˆ°å°æ’åºï¼Œæ’åˆ—åä»»ç„¶å­˜å‚¨aæ•°ç»„ä¸­ã€‚\n\n\nå‡½æ•°æ¥å£å®šä¹‰ï¼š\nvoid sort(int a[],int n);/*åŠŸèƒ½ä¸ºä½¿ç”¨â€œèµ·æ³¡æ³•â€å¯¹aæ•°ç»„å­˜å‚¨çš„nï¼ˆn<=20ï¼‰ä¸ªæ•°æŒ‰ä»å¤§åˆ°å°æ’åºï¼Œæ’åˆ—åä»»ç„¶å­˜å‚¨aæ•°ç»„ä¸­*/\nè£åˆ¤æµ‹è¯•ç¨‹åºæ ·ä¾‹ï¼š\n#include \n#define N 20\n\n\n/* è¯·åœ¨è¿™é‡Œå¡«å†™ç­”æ¡ˆ */\n\n\nint main(){\n    int a[N],i,n;\n    scanf(\"%d\",&n);\n    if(n>20)  printf(\"error data\");\n    else{\n        for(i=0; i<n; i++)\n            scanf(\"%d\",&a[i]);\n        sort(a,n);\n        for(i=0; i<n; i++)\n            printf(\"%5d\",a[i]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\nè¾“å…¥æ ¼å¼ï¼š\nè¯·åœ¨ç¬¬ä¸€è¡Œä¸­è¾“å…¥æ•´æ•°nçš„å€¼ï¼Œè¡¨ç¤ºæ•°æ®çš„ä¸ªæ•°ã€‚\n\n\nåœ¨ç¬¬äºŒè¡Œä¸­è¾“å…¥nä¸ªæ— åºæ•´æ•°ï¼Œæ•°æ®ä¸­é—´ä»¥ç©ºæ ¼ä¸ºé—´éš”ã€‚\n\n\nè¾“å‡ºæ ¼å¼ï¼š\nå¯¹æ¯ä¸€ç»„è¾“å…¥çš„nä¸ªæ— åºæ•´æ•°ï¼Œè¾“å‡ºæŒ‰ç…§ä»å°åˆ°å¤§é¡ºåºçš„æ’åºç»“æœï¼Œå…¶ä¸­æ¯ä¸ªæ•°æ˜¾ç¤ºæ ¼å¼ä¸ºï¼šå 5åˆ—ï¼Œå³å¯¹é½ã€‚\n\n\nè¾“å…¥æ ·ä¾‹1ï¼š\n10\n1 2 3 4 5 0 9 8 7 6\nè¾“å‡ºæ ·ä¾‹1ï¼š\n    9    8    7    6    5    4    3    2    1    0\nè¾“å…¥æ ·ä¾‹2ï¼š\n45\nè¾“å‡ºæ ·ä¾‹2ï¼š\nerror data", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "è¯·é—®æœ‰å“ªé‡Œéœ€è¦è§£ç­”çš„åœ°æ–¹å—ï¼Ÿ\n#include<stdio.h>\nint main()\n{\n    int a[20][20],b[20][20],c[20][20]={0},i,j,k,min,max,n;\n    scanf(\"%d\",&n);\n    for(i=0;i<=n-1;++i)\n        for(j=0;j<=n-1;++j)\n            scanf(\"%d\",&a[i][j]);\n    for(i=0;i<=n-1;++i)\n        for(j=0;j<=n-1;++j)\n            scanf(\"%d\",&b[i][j]);\n    for(i=0;i<=n-1;++i)\n        for(j=0;j<=n-1;++j)\n            for(k=0;k<=n-1;++k)\n                c[i][j]+=a[i][k]*b[k][j];\n    min=max=c[0][0];\n    for(i=0;i<=n-1;++i)\n        for(j=0;j<=n-1;++j)\n        {\n            if(min>c[i][j])\n                min=c[i][j];\n            if(max<c[i][j])\n                max=c[i][j];\n        }\n    for(i=0;i<=n-1;++i)\n    {\n        for(j=0;j<=n-1;++j)\n        {\n            printf(\"%d\",c[i][j]);\n            if(j!=n-1)\n                printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n    printf(\"%d %d\",min,max);\n    return 0;\n}\n\n", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "Cè¯­è¨€ç¼–ç¨‹é—®é¢˜æ±‚è§£ç­”\né¢˜ç›®æè¿°\nçŸ©é˜µint a[n][n]ï¼ŒçŸ©é˜µint b[n][n]ï¼ˆ1â‰¤nâ‰¤20ï¼‰ã€‚çŸ©é˜µçš„å¤§å°å’Œæ•°æ®ç”±ç”¨æˆ·è¾“å…¥ã€‚è¾“å‡ºæ–°çš„çŸ©é˜µc=a*bï¼Œä»¥åŠå…¶ä¸­çš„æœ€å°å€¼å’Œæœ€å¤§å€¼ï¼Œè¾“å‡ºæ ¼å¼ï¼š\nc00      c01      c02      â€¦â€¦  c0(n-2)      c0(n-1)\nc10      c11      c12      â€¦â€¦  c1(n-2)      c1(n-1)\nc20      c21      c22      â€¦â€¦  c2(n-2)      c2(n-1)\nâ€¦â€¦     â€¦â€¦     â€¦â€¦     â€¦â€¦  â€¦â€¦         â€¦â€¦\nc(n-2)0  c(n-2)1  c(n-2)2  â€¦â€¦  c(n-2)(n-2)  c(n-2)(n-1)\nc(n-1)0  c(n-1)1  c(n-1)2  â€¦â€¦  c(n-1)(n-2)  c(n-1)(n-1)\ncmin cmax\n\n\nçŸ©é˜µä¹˜æ³•çš„è®¡ç®—æ–¹æ³• :\nå¯¹äºçŸ©é˜µA[n][n]*B[n][n]ï¼Œ\nç›¸ä¹˜çš„ç»“æœä¸ºçŸ©é˜µC[n][n]ï¼Œä¸”å¯¹äºçŸ©é˜µCä¸­æ¯ä¸€é¡¹éƒ½æœ‰\nC[i][j] = A[i][0]*B[0][j] + A[i][1]*B[1][j] + ..... + A[i][n-1]*B[n-1][j]\n\n\nå…³äºè¾“å…¥\nç¬¬ä¸€è¡Œä¸ºçŸ©é˜µçš„å¤§å°ï¼Œåé¢è·Ÿç€è¾“å…¥ä¸¤ä¸ªçŸ©é˜µ\nn\na00      a01      a02      â€¦â€¦  a0(n-2)      a0(n-1)\na10      a11      a12      â€¦â€¦  a1(n-2)      a1(n-1)\na20      a21      a22      â€¦â€¦  a2(n-2)      a2(n-1)\nâ€¦â€¦     â€¦â€¦     â€¦â€¦     â€¦â€¦  â€¦â€¦         â€¦â€¦\na(n-2)0  a(n-2)1  a(n-2)2  â€¦â€¦  a(n-2)(n-2)  a(n-2)(n-1)\na(n-1)0  a(n-1)1  a(n-1)2  â€¦â€¦  a(n-1)(n-2)  a(n-1)(n-1)\nb00      b01      b02      â€¦â€¦  b0(n-2)      b0(n-1)\nb10      b11      b12      â€¦â€¦  b1(n-2)      b1(n-1)\nb20      b21      b22      â€¦â€¦  b2(n-2)      b2(n-1)\nâ€¦â€¦     â€¦â€¦     â€¦â€¦     â€¦â€¦  â€¦â€¦         â€¦â€¦\nb(n-2)0  b(n-2)1  b(n-2)2  â€¦â€¦  b(n-2)(n-2)  b(n-2)(n-1)\nb(n-1)0  b(n-1)1  b(n-1)2  â€¦â€¦  b(n-1)(n-2)  b(n-1)(n-1)\n\n\nå…³äºè¾“å‡º\nçŸ©é˜µc\nc00      c01      c02      â€¦â€¦  c0(n-2)      c0(n-1)\nc10      c11      c12      â€¦â€¦  c1(n-2)      c1(n-1)\nc20      c21      c22      â€¦â€¦  c2(n-2)      c2(n-1)\nâ€¦â€¦     â€¦â€¦     â€¦â€¦     â€¦â€¦  â€¦â€¦         â€¦â€¦\nc(n-2)0  c(n-2)1  c(n-2)2  â€¦â€¦  c(n-2)(n-2)  c(n-2)(n-1)\nc(n-1)0  c(n-1)1  c(n-1)2  â€¦â€¦  c(n-1)(n-2)  c(n-1)(n-1)\ncmin cmax\n\n\nä¾‹å­è¾“å…¥\n3\n1 2 3\n4 5 6\n7 8 9\n1 2 3\n4 5 6\n7 8 9\nä¾‹å­è¾“å‡º\n30 36 42\n66 81 96\n102 126 150\n30 150\næç¤ºä¿¡æ¯\næ³¨æ„çŸ©é˜µè¾¹ç•Œï¼Œä»¥é˜²è®¡ç®—æ—¶è¶Šç•Œ", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "ä»¥ä¸‹ç­”æ¡ˆå¼•ç”¨è‡ªGPT-3å¤§æ¨¡å‹,è¯·åˆç†ä½¿ç”¨ï¼š\nç¤ºä¾‹ï¼Œè°¢è°¢\n\nè¿™å¯èƒ½æ˜¯å› ä¸ºä½¿ç”¨äº†ä¸æ­£ç¡®çš„å…±äº«å†…å­˜çš„å®ç°ï¼Œæˆ–è€…ç”±äºæ²¡æœ‰è€ƒè™‘åˆ°é€‚å½“çš„ä¼˜åŒ–ã€‚å¦‚æœè¦ä½¿ç”¨å…±äº«å†…å­˜ï¼Œåˆ™éœ€è¦ç¡®ä¿ä½¿ç”¨ä¸€è‡´çš„æ•°æ®ç»“æ„å’Œä¼ è¾“æ–¹å¼ï¼Œä»¥ä¾¿æ¯ä¸ªçº¿ç¨‹å¯ä»¥å¿«é€Ÿè®¿é—®å†…å­˜ä¸­çš„æ•°æ®ã€‚è¿™æ ·å¯ä»¥å‡å°‘CPUå’ŒGPUä¹‹é—´çš„äº¤äº’ï¼Œå¤§å¤§åŠ å¿«è®¡ç®—æ€§èƒ½ã€‚\n\næ­¤å¤–ï¼Œè¿˜æœ‰ä¸€äº›å®ç”¨çš„ä¼˜åŒ–æŠ€å·§ï¼Œæ¯”å¦‚å¸¸é‡è¡¨è¾¾å¼è®¡ç®—ï¼Œä»¥åŠä½¿ç”¨ç‰¹å®šäº GPU çš„æŒ‡ä»¤é›†å’Œå‡½æ•°ï¼Œå¯ä»¥ä½¿ä»£ç æ›´åŠ æœ‰æ•ˆã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼Œå®ç°æœ¬é—®é¢˜çš„ä¼˜åŒ–ç‰ˆæœ¬ï¼š\n\n@cuda.jit\ndef arggetmin_opt(Fitness, IN_index, OutResult, OutIndex, n):\n    tid = cuda.threadIdx.x;\n    idx = cuda.threadIdx.x + cuda.blockIdx.x * cuda.blockDim.x\n    tmp = cuda.shared.array(shape=BLOCK_SIZE, dtype=float32)\n    index = cuda.shared.array(shape=BLOCK_SIZE, dtype=int32)\n    tmp[tid] = MAX\n    if (tid > n): return\n\n    #å°†æ•°æ®ä¼ å…¥å…±äº«å†…å­˜\n    if (idx < n):\n        tmp[tid] = Fitness[idx]\n        index[tid] = IN_index[idx]\n    else:\n        tmp[tid] = MAX\n        index[tid] = IN_index[idx]\n\n    cuda.syncthreads();\n\n    #æ²¡ä¸ªå—å†…è¿›è¡Œå½’çº¦å¤„ç†\n    stride = cuda.blockDim.x \n    while stride > 0:\n        if (tid < stride):\n            if (tmp[tid] > tmp[tid + (stride >>1)]):\n                tmp[tid] = tmp[tid + (stride >>1)]\n                index[tid] = index[tid + (stride >>1)]\n        cuda.syncthreads()\n        stride = (stride >> 1) \n\n    if (tid == 0):\n        OutResult[cuda.blockIdx.x] = tmp[0]\n        OutIndex[cuda.blockIdx.x] = index[0]\n\nå¦‚æœæˆ‘çš„å›ç­”è§£å†³äº†æ‚¨çš„é—®é¢˜ï¼Œè¯·é‡‡çº³æˆ‘çš„å›ç­”", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "åœ¨GPUè¿›è¡Œæœ€å°å€¼å½’çº¦è¿è¡Œæ—¶é—´æ¯”CPUé•¿\nå‡½æ•°å®ç°ç›®çš„ï¼šæ±‚å¤§å°ä¸º100çš„ä¸€ç»´æ•°ç»„æœ€å°å€¼çš„ä¸‹æ ‡ï¼Œä½¿ç”¨çš„å½’çº¦è¿ç®—\n\n\nå‡ºç°é—®é¢˜ï¼šGPUæ€»æ¯”CPUè¿è¡Œæ—¶é—´ä¹…ï¼ˆGPUï¼šMX150ï¼ŒCPUï¼ši5 8thï¼‰\n\n\n\n\n@cuda.jit\ndef arggetmin(Fitness, IN_index, OutResult, OutIndex, n):\n    \ntid\n = cuda.threadIdx.x;\n    \nidx\n = cuda.threadIdx.x + cuda.blockIdx.x * cuda.blockDim.x\n    \ntmp\n = cuda.shared.array(\nshape=BLOCK_SIZE,\n \ndtype=float32)\n\n    \nindex\n = cuda.shared.array(\nshape=BLOCK_SIZE,\n \ndtype=int32)\n\n    tmp[tid] = MAX\n    \nif\n (tid > n): return\n\n    \n#å°†æ•°æ®ä¼ å…¥å…±äº«å†…å­˜\n\n    \nif\n (idx < n):\n        tmp[tid] = Fitness[idx]\n        index[tid] = IN_index[idx]\n    \nelse\n:\n        tmp[tid] = MAX\n        index[tid] = IN_index[idx]\n\n    cuda.syncthreads();\n\n    \n#æ²¡ä¸ªå—å†…è¿›è¡Œå½’çº¦å¤„ç†\n\n    \nstride\n = int(cuda.blockDim.x / \n2\n)\n    while stride > \n0\n:\n        \nif\n (tid < stride):\n            \nif\n (tmp[tid] > tmp[tid + stride]):\n                tmp[tid] = tmp[tid + stride]\n                index[tid] = index[tid + stride]\n        cuda.syncthreads()\n        \nstride\n = int(stride / \n2\n)\n\n    \nif\n (\ntid\n == \n0\n):\n        OutResult[cuda.blockIdx.x] = tmp[\n0\n]\n        OutIndex[cuda.blockIdx.x] = index[\n0\n]\n\ndef main():\n    \nn\n = \n100\n        \n#æ•°ç»„å¤§å°\n\n   \n   \n#ç”Ÿæˆæ•°ç»„å’Œä¸‹æ ‡\n\n    \na\n = getRamdomlist(n)\n    \nindex\n = getIndex(n)\n    \n    \n#ä¼ å…¥åˆ°GPUä¸­\n\n    \na_device\n = cuda.to_device(a)\n    \nindex_device\n = cuda.to_device(index)\n\n    \nthreads_per_block\n = BLOCK_SIZE\n    \nblock_per_grid\n = math.ceil(n / threads_per_block)\n    \ngpu_result\n = cuda.device_array(\nshape=block_per_grid,\n \ndtype=float)\n \n    \ngpu_index\n = cuda.device_array(\nshape=block_per_grid,\n \ndtype=int)\n\n\n    \n#GPUéƒ¨åˆ†\n\n    \ntime1\n = perf_counter()\n    arggetmin[block_per_grid, threads_per_block](a_device, index_device, gpu_result, gpu_index, n)\n    cuda.synchronize()\n    \ntime2\n = perf_counter()\n    print(\n\"matmul GPU time :\"\n, (time2 - time1))\n  \n    \n#CPUéƒ¨åˆ†\n\n    \nstart\n = perf_counter()\n    \ninnn\n = np.argmin(a)\n    \nend\n = perf_counter()\n    print(\n\"matmul CPU time :\"\n, (end - start))\n\n\n\nif\n \n__name__\n == \n\"__main__\"\n:\n    main()\n\n\n\n\n\nGPUè¿ç®—æ—¶é—´0.5så·¦å³ï¼ŒCPUè¿ç®—æ—¶é—´0.0005så·¦å³\n\n\nä½¿ç”¨è¿‡â€œå¾ªç¯å±•å¼€â€çš„æ–¹æ³•ï¼Œä½†ç»“æœæ›´åŠ ç³Ÿç³•ã€‚ï¼ˆè¿è¡ŒNvidiaå®˜æ–¹çš„â€œçŸ©é˜µä¹˜æ³•â€çš„ä»£ç æ—¶ï¼Œä½¿ç”¨å…±äº«å†…å­˜çš„ä»£ç æ¯”ä¸ä½¿ç”¨å…±äº«å†…å­˜çš„ä»£ç è¦æ…¢ï¼‰\n\n\nä¸ºä»€ä¹ˆä¼šå‡ºç°è¿™ç§æƒ…å†µï¼Œä¸€ç›´ä¸å¤ªæ˜ç™½", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "14è¡Œï¼Œi=i++æ”¹æˆi++10ã€11è¡Œåˆ æ‰å‡½æ•°å®šä¹‰éƒ½æ˜¯é”™è¯¯çš„ã€‚æ”¹æˆvoid jiajia(int a[4][4],int b[4][4],int c[4][4])ï¼Œä¹˜æ³•ç›¸åŒã€‚å°†a+bå’Œa*bçš„ç»“æœå†™å…¥cæ•°ç»„å°±è¡Œè²Œä¼¼ä½ jiajiaå‡½æ•°ç›´æ¥è¾“å‡ºç»“æœäº†ï¼Œå¯ä»¥ä¸ç”¨å°†c[4][4]ä½œä¸ºå‚æ•°ï¼Œä½†ä½ è¾“å‡ºè¯­å¥å•¥å†…å®¹ä¹Ÿæ²¡å†™ï¼Œcout<<endl;è¿™åªæ˜¯è¾“å‡ºæ¢è¡Œå•Šã€‚cout<<c[i][j]<<\" \";if(i%4==0)      cout<<endl;", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "æƒ³è®¡ç®—C++çŸ©é˜µåŠ æ³•ä¹˜æ³•ä¸ºä»€ä¹ˆå¾—ä¸åˆ°ç»“æœï¼Ÿ\n\n", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "import numpy as np\nn=int(input(\"n:\"))\nm=int(input(\"m:\"))\n# ç”ŸæˆéšæœºçŸ©é˜µ\nprint('ç”ŸæˆéšæœºçŸ©é˜µ')\nlist1=np.random.randint(n,size=m*n)\nlist2=np.random.randint(n,size=m*n)\nprint(list1)\nprint(list2)\n\n# çŸ©é˜µç›¸åŠ \nprint('çŸ©é˜µç›¸åŠ ')\nlist3=list1+list2\nprint(list3)\n# çŸ©é˜µç›¸å‡\nprint('çŸ©é˜µç›¸å‡')\nlist4=list1-list2\nprint(list4)\n# çŸ©é˜µå’Œæ•°ç›¸ä¹˜\nprint('çŸ©é˜µå’Œæ•°ç›¸ä¹˜')\nlist4=list1*5\nprint(list4)\n# n1må’Œmn2äºŒç»´çš„çŸ©é˜µ n1*n2çš„çŸ©é˜µçš„ä¹˜æ³•è¿ç®—\nprint('n1må’Œmn2äºŒç»´çš„çŸ©é˜µ n1*n2çš„çŸ©é˜µçš„ä¹˜æ³•è¿ç®—')\nlist1=list1.reshape(n,m)\nlist2=list2.reshape(n,m)\nprint(list1)\nprint(list2)\nlist5=list1*list2\nprint(list5)\n\n", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "ç”Ÿæˆç”±éšæœºæ•´æ•°æ„æˆçš„n*mçš„äºŒç»´çŸ©é˜µ\nç”Ÿæˆç”±éšæœºæ•´æ•°æ„æˆçš„n*mçš„äºŒç»´çŸ©é˜µ\n\n\nï¼ˆ5.2ï¼‰ç”Ÿæˆn*nç»´çš„å•ä½çŸ©é˜µ\n\n\nï¼ˆ5.3ï¼‰å®ç°çŸ©é˜µç›¸åŠ çš„è¿ç®—ï¼Œæ³¨æ„åªæœ‰ç›¸åŒç»´åº¦çš„çŸ©é˜µæ‰èƒ½è¿›è¡ŒåŠ å‡è¿ç®—ã€‚\n\n\nï¼ˆ5.4ï¼‰å®ç°çŸ©é˜µç›¸å‡çš„è¿ç®—ï¼Œæ³¨æ„åªæœ‰ç›¸åŒç»´åº¦çš„çŸ©é˜µæ‰èƒ½è¿›è¡ŒåŠ å‡è¿ç®—ã€‚\n\n\nï¼ˆ5.5ï¼‰å®ç°çŸ©é˜µå’Œæ•°ç›¸ä¹˜çš„è¿ç®—\n\n\nï¼ˆ5.6ï¼‰å®ç°n1\nmå’Œm\nn2äºŒç»´çš„çŸ©é˜µï¼Œå¹¶å¾—åˆ°n1*n2çš„çŸ©é˜µçš„ä¹˜æ³•è¿ç®—ã€‚", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "\n#define _CRT_SECURE_NO_WARNINGS\n#include<stdio.h>\nint main()\n{\n  int a[10][10], b[10][10], c[10][10];\n  int n;\n  printf(\"æ–¹é˜µé˜¶æ•°: \");\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < n; j++)\n      scanf(\"%d\", &a[i][j]);\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < n; j++)\n      scanf(\"%d\", &b[i][j]);\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = 0; j < n; j++)\n    {\n      c[i][j] = 0;\n      for (int k = 0; k < n; k++)\n        c[i][j] += a[i][k] * b[k][j];\n      printf(\"%10d\", c[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}\n", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "Cè¯­è¨€ä¸­æ±‚è§£æ–¹é˜µä¹˜æ³•è¿ç®—\nã€é—®é¢˜æè¿°ã€‘\nÂ Â Â  ä»é”®ç›˜è¾“å…¥ä¸€ä¸ªæ­£æ•´æ•°nï¼ˆnâˆˆ[1,10]ï¼‰ï¼Œè¡¨ç¤ºè¿›è¡Œä¹˜æ³•è¿ç®—çš„ä¸¤ä¸ªæ•´å½¢æ–¹é˜µçš„é˜¶ã€‚ç„¶ååˆ†åˆ«è¾“å…¥ä¸¤ä¸ªæ•´å½¢æ–¹é˜µAå’ŒBï¼Œè®¡ç®—AÃ—Båå°†ç»“æœè¾“å‡ºåˆ°å±å¹•ã€‚\nã€è¾“å…¥å½¢å¼ã€‘\nÂ Â Â  ä»é”®ç›˜è¾“å…¥ä¸€ä¸ªæ­£æ•´æ•°ï¼Œç„¶åå†è¾“å…¥ä¸¤ä¸ªæ•´å½¢æ–¹é˜µã€‚\nã€è¾“å‡ºå½¢å¼ã€‘\nÂ Â Â  åœ¨å±å¹•ä¸Šè¾“å‡ºä¸¤ä¸ªæ•´å½¢æ–¹é˜µçš„ä¹˜ç§¯ã€‚\nã€è¾“å…¥æ ·ä¾‹ã€‘\n3\n1 1 1\n3 3 3\n6 6 6\n9 9 9\n6 6 6\n5 5 5\nã€è¾“å‡ºæ ·ä¾‹ã€‘\n########20########20########20\n########60########60########60\n#######120#######120#######120\nã€æ ·ä¾‹è¯´æ˜ã€‘\né¦–å…ˆè¾“å…¥æ­£æ•´æ•°3,è¯´æ˜æ¥ä¸‹æ¥è¦è¾“å…¥çš„æ–¹é˜µæ˜¯3Ã—3çš„ã€‚å› ä¸º\n1 1 1Â Â Â Â Â Â Â Â  9 9 9Â Â Â Â Â Â Â Â Â  20Â  20Â  20\n3 3 3Â Â Ã—Â Â  6 6 6Â Â Â  =Â Â Â Â 60Â  60Â  60\n6 6 6Â Â Â Â Â Â Â Â 5 5 5Â Â Â Â Â Â Â Â Â  120 120 120\næ‰€ä»¥åœ¨å±å¹•ä¸Šæ‰“å°ï¼š\n########20########20########20\n########60########60########60\n#######120#######120#######120\næ³¨ï¼š\"#\"ä»£è¡¨ç©ºæ ¼ï¼Œæ¯ä¸ªè¾“å‡ºçš„æ•´æ•°å 10ä½ï¼Œä¸è¶³10ä½åœ¨æ•´æ•°çš„å·¦è¾¹ç”¨ç©ºæ ¼è¡¥è¶³ã€‚\n\n\n#\ninclude\n\n\n \nint\n \nmain\n()\n\n\n{   \nint\n a[\n3\n][\n3\n], b[\n3\n][\n3\n], c[\n3\n][\n3\n];\n    \nint\n i, j, k, sum;\n    \nprintf\n(\n\"è¾“å…¥ä¸€ä¸ª3*3çš„çŸ©é˜µï¼š\\n\"\n);\n    \nfor\n(i=\n0\n;i<\n3\n;i++)                    \n//å¤„ç†çŸ©é˜µaä¸­çš„ä¸€è¡Œä¸­å„å…ƒç´ \n\n     \nfor\n(j=\n0\n;j<\n3\n;j++)               \n//å¤„ç†çŸ©é˜µaä¸­æŸä¸€åˆ—ä¸­å„å…ƒç´ \n\n   \nscanf\n(\n\"%d\"\n,&a[i][j]);   \n//è¾“å…¥æ•°æ®\n\n \nprintf\n(\n\"è¾“å…¥ä¸€ä¸ª3*3çš„çŸ©é˜µï¼›\\n\"\n);\n \nfor\n(i=\n0\n;i<\n3\n;i++)                   \n//å¤„ç†çŸ©é˜µbä¸­çš„ä¸€è¡Œä¸­å„å…ƒç´ \n\n  \nfor\n(j=\n0\n;j<\n3\n;j++)               \n//å¤„ç†çŸ©é˜µbä¸­æŸä¸€åˆ—ä¸­å„å…ƒç´ \n\n   \nscanf\n(\n\"%d\"\n,&b[i][j]);    \n//è¾“å…¥æ•°æ®\n\n \nfor\n(i=\n0\n;i<\n3\n;i++)                 \n//å¯¹çŸ©é˜µcè¿›è¡Œå¤„ç†\n\n { \nfor\n(j=\n0\n;j<\n3\n;j++)\n  { sum=\n0\n;\n   \nfor\n(k=\n0\n;k<\n4\n;k++)   \n//çŸ©é˜µcä¸­æ¯ä¸€ä¸ªå…ƒç´ çš„å¾ªç¯è®¡ç®—\n\n   {\n     sum+=a[i][k]*b[k][j]; \n//å¯¹çŸ©é˜µcä¸­çš„æŸä¸€å…ƒç´ è¿›è¡Œè®¡ç®—\n\n   }\n   c[i][j]=sum;           \n//ç»™çŸ©é˜µcä¸­çš„æŸä¸€å…ƒç´ è¿›è¡Œèµ‹å€¼\n\n  }\n }\n \nprintf\n(\n\"å¾—åˆ°ä¸€ä¸ª3Ã—3çš„çŸ©é˜µï¼š\\n\"\n);\n \nfor\n(i=\n0\n;i<\n3\n;i++)            \n//è¾“å‡ºçŸ©é˜µc\n\n {\n  \nfor\n(j=\n0\n;j<\n3\n;j++)\n    \nprintf\n(\n\"%5d\"\n,c[i][j]);\n   \nprintf\n(\n\"\\n\"\n);\n   }\n   \nreturn\n \n0\n;\n}\n\n\n\n\næˆ‘çš„è¿ç®—ç»“æœæ˜¯é”™çš„ï¼Œç„¶åè¾“å‡ºä¹Ÿä¸å¯¹ï¼Œä¸çŸ¥é“æ€ä¹ˆå»ä¿®æ”¹ã€‚", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "*æ˜¯å¯¹åº”ä½ç½®ç›¸ä¹˜ä½ å†™æ•°å­— *çŸ©é˜µå¯ä»¥ï¼Œä½†æ˜¯æœ€åä¸¤è¡Œæ˜¯çŸ©é˜µ *çŸ©é˜µäº†ï¼Œç»´åº¦æ²¡æ³•å¯¹åº”ç›¸ä¹˜ï¼Œå°±æŠ¥é”™äº†np.multiply(H,G)å’ŒH *Gæ˜¯ä¸€ä¸ªæ„æ€ï¼Œè¡¨ç¤ºçŸ©é˜µç‚¹ä¹˜\næˆ‘çœ‹ä½ æµ‹è¯•çš„æ ·å­ï¼Œåº”è¯¥æ˜¯æƒ³æµ‹è¯•multiplyå’Œdotå‡½æ•°å§ï¼Œåº”è¯¥å†™ï¼š\nprint(np.multiply(H,G))   #è¿™é‡Œä¹Ÿä¼šæŠ¥é”™ï¼Œå› ä¸ºç»´åº¦ä¸åŒ¹é…\nprint(np.dot(G,E))\n\næœ‰å¸®åŠ©éº»çƒ¦ç‚¹ä¸ªé‡‡çº³ï½ï½", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "Pythonçš„ä¹˜æ³•å‡ºé”™é—®é¢˜ï¼Œoperands could not be broadcast together with shapes (3,3) (3,2)\n\n\nimport\n numpy as np\n\nA\n = np.array([\n5\n, -\n2\n])\n\nB\n = np.array([\n1\n, \n6\n, \n2\n, \n0\n, -\n1\n, -\n1\n])\n\nC\n = np.array([\n2\n, \n0\n, -\n1\n, \n3\n, -\n1\n, \n6\n])\n\nD\n = np.array([\n3\n, \n0\n, \n1\n, \n1\n, -\n2\n, \n2\n, \n3\n, \n4\n, -\n1\n])\n\n\nE\n = A.reshape((\n2\n, \n1\n))\n\nF\n = B.reshape((\n3\n, \n2\n))\n\nG\n = C.reshape((\n3\n, \n2\n))\n\nH\n = D.reshape((\n3\n, \n3\n))\n\n\nprint\n(-\n2\n*E)\n\nprint\n(G + F)\n\nprint\n(\n4\n*F - G)\n\nprint\n(np.multiply(H*G))\n\nprint\n(np.dot(G*E))\n\n\n\næœ€åä¸¤è¡Œæ€»æ˜¯å‡ºé”™ï¼Œæ˜¯ä¸ªä»€ä¹ˆåŸå› ï¼Ÿï¼ˆå€’æ•°ç¬¬äºŒè¡Œæ˜¯ä¸€ä¸ªï¼ˆ3,3ï¼‰\nï¼ˆ3,2ï¼‰çš„çŸ©é˜µï¼Œå€’æ•°ç¬¬ä¸€è¡Œæ˜¯ä¸€ä¸ªï¼ˆ3,2ï¼‰\nï¼ˆ2,1ï¼‰çš„çŸ©é˜µï¼‰", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "è¿™é‡Œå…¨æ˜¯é™æ€æ–¹æ³•ç›´æ¥LeastSquare.æ–¹æ³•(å‚æ•°)è¿™æ ·è°ƒç”¨å°±è¡Œäº†", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "æ€æ ·è°ƒç”¨ä¸‹é¢æœ€å°äºŒä¹˜æ³•çš„ç±»ï¼Œå¹¶è¿è¡Œæµ‹è¯•\n\npublic \nclass\n LeastSquare\n//æœ€å°äºŒä¹˜æ³•\n\n    {\n        \n///\n\n        \n///ç”¨æœ€å°äºŒä¹˜æ³•æ‹ŸåˆäºŒå…ƒå¤šæ¬¡æ›²çº¿ï¼ˆä»»æ„æ¬¡ï¼‰\n\n        \n///\n\n        \n///å·²çŸ¥ç‚¹çš„xåæ ‡é›†åˆ\n\n        \n///å·²çŸ¥ç‚¹çš„yåæ ‡é›†åˆ\n\n        \n///å·²çŸ¥ç‚¹çš„ä¸ªæ•°\n\n        \n///æ–¹ç¨‹çš„æœ€é«˜æ¬¡æ•°\n\n        #region æ€»è®¡ç®—æ–¹æ³•\n        public static double\n[]\n \nMultiLine(\ndouble\n[] \narrX\n, \ndouble\n[] \narrY\n, \nint\n \nlength\n, \nint\n \ndimension\n)\n//äºŒå…ƒå¤šæ¬¡çº¿æ€§æ–¹ç¨‹æ‹Ÿåˆæ›²çº¿\n\n        {\n            \nint\n n = dimension + \n1\n;                  \n//dimensionæ¬¡æ–¹ç¨‹éœ€è¦æ±‚ dimension+1ä¸ª ç³»æ•°\n\n            double\n[,]\n Guass = \nnew\n double\n[\nn\n, \nn\n + \n1\n]\n;      \n//é«˜æ–¯çŸ©é˜µ ä¾‹å¦‚ï¼šy=a0+a1*x+a2*x*x\n\n            \nfor\n (\nint\n i = \n0\n; i < n; i++)\n            {\n                \nint\n j;\n                \nfor\n (j = \n0\n; j < n; j++)\n                {\n                    Guass\n[\ni\n, \nj\n]\n = \nSumArr(\narrX\n, \nj\n + \ni\n, \nlength\n)\n;\n                }\n                Guass\n[\ni\n, \nj\n]\n = \nSumArr(\narrX\n, \ni\n, \narrY\n, 1, \nlength\n)\n;\n            }\n            return \nComputGauss(Guass, \nn\n)\n;\n//è¿”å›å€¼æ˜¯å‡½æ•°çš„ç³»æ•°\n\n        }\n        #endregion\n        #region æ±‚æ•°ç»„çš„å…ƒç´ çš„næ¬¡æ–¹çš„å’Œ\n1\n(ä¸­é—´æ–¹æ³•)\n        public static double \nSumArr(\ndouble\n[] \narr\n, \nint\n \nn\n, \nint\n \nlength\n)\n \n        {\n            double s = \n0\n;\n            \nfor\n (\nint\n i = \n0\n; i < length; i++)\n            {\n                \nif\n (arr\n[\ni\n]\n != \n0\n || \nn != \n0\n)\n                    s = s + Math.\nPow(\narr\n[\ni\n], \nn\n)\n;\n                \nelse\n\n                    s = s + \n1\n;\n            }\n            return s;\n        }\n        #endregion\n        #region æ±‚æ•°ç»„çš„å…ƒç´ çš„næ¬¡æ–¹çš„å’Œ\n2\n(ä¸­é—´æ–¹æ³•)\n        public static double \nSumArr(\ndouble\n[] \narr1\n, \nint\n \nn1\n, \ndouble\n[] \narr2\n, \nint\n \nn2\n, \nint\n \nlength\n)\n\n        {\n            double s = \n0\n;\n            \nfor\n (\nint\n i = \n0\n; i < length; i++)\n            {\n                \nif\n ((arr1\n[\ni\n]\n != \n0\n || \nn1 != \n0\n)\n && \n(arr2\n[\ni\n]\n != \n0\n || \nn2 != \n0\n))\n                    s = s + Math.\nPow(\narr1\n[\ni\n], \nn1\n)\n * \nMath.\nPow(\narr2\n[\ni\n], \nn2\n)\n;\n                \nelse\n\n                    s = s + \n1\n;\n            }\n            return s;\n \n        }\n        #endregion\n        #region è¿”å›å€¼æ˜¯å‡½æ•°çš„ç³»æ•°(ä¸­é—´æ–¹æ³•)\n        public static double\n[]\n \nComputGauss(\ndouble\n[,] Guass, \nint\n \nn\n)\n\n        {\n            \nint\n i, j;\n            \nint\n k, m;\n            double temp;\n            double max;\n            double s;\n            double\n[]\n x = \nnew\n double\n[\nn\n]\n;\n            \nfor\n (i = \n0\n; i < n; i++) x\n[\ni\n]\n = \n0.0\n;\n//åˆå§‹åŒ–\n\n \n            \nfor\n (j = \n0\n; j < n; j++)\n            {\n                max = \n0\n;\n                k = j;\n                \nfor\n (i = j; i < n; i++)\n                {\n                    \nif\n (Math.\nAbs(Guass[\ni\n, \nj\n])\n > max)\n                    {\n                        max = Guass\n[\ni\n, \nj\n]\n;\n                        k = i;\n                    }\n                }\n \n \n                \nif\n (k != j)\n                {\n                    \nfor\n (m = j; m < n + \n1\n; m++)\n                    {\n                        temp = Guass\n[\nj\n, \nm\n]\n;\n                        Guass\n[\nj\n, \nm\n]\n = Guass\n[\nk\n, \nm\n]\n;\n                        Guass\n[\nk\n, \nm\n]\n = temp;\n                    }\n                }\n                \nif\n (\n0\n == \nmax)\n                {\n                    \n// \"æ­¤çº¿æ€§æ–¹ç¨‹ä¸ºå¥‡å¼‚çº¿æ€§æ–¹ç¨‹\" \n\n                    return x;\n                }\n \n                \nfor\n (i = j + \n1\n; i < n; i++)\n                {\n                    s = Guass\n[\ni\n, \nj\n]\n;\n                    \nfor\n (m = j; m < n + \n1\n; m++)\n                    {\n                        Guass\n[\ni\n, \nm\n]\n = Guass\n[\ni\n, \nm\n]\n - Guass\n[\nj\n, \nm\n]\n * \ns\n / \n(Guass\n[\nj\n, \nj\n]\n);\n                    }\n                }\n \n            }\n//ç»“æŸfor (j=0;j= \n0\n; i--)\n            {\n                s = \n0\n;\n                \nfor\n (j = i + \n1\n; j < n; j++)\n                {\n                    s = s + Guass\n[\ni\n, \nj\n]\n * \nx\n[\nj\n]\n;\n                }\n                x\n[\ni\n]\n = (Guass\n[\ni\n, \nn\n]\n - s)\n / \nGuass\n[\ni\n, \ni\n]\n;\n            }\n            return x;\n        }\n#endregion\n    }\n\n\n\nå‚è€ƒäºC#åˆ©ç”¨æœ€å°äºŒä¹˜æ³•æ‹Ÿåˆä»»æ„æ¬¡å‡½æ•°æ›²çº¿\nä½œè€…ï¼šæœªæ¥æ— é™", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "å‚è€ƒGPTå’Œè‡ªå·±çš„æ€è·¯ï¼Œä¸€ã€è¦è¯æ˜é›†åˆGå…³äºçŸ©é˜µçš„ä¹˜æ³•æ„æˆä¸€ä¸ªç¾¤ï¼Œéœ€è¦æ»¡è¶³ä»¥ä¸‹å››ä¸ªæ¡ä»¶ï¼š\n1  é—­åˆæ€§ï¼šå¯¹äºGä¸­çš„ä»»æ„ä¸¤ä¸ªå…ƒç´ Aå’ŒBï¼Œå®ƒä»¬çš„ç§¯ABä»ç„¶å±äºGã€‚\n2  ç»“åˆå¾‹ï¼šå¯¹äºGä¸­çš„ä»»æ„ä¸‰ä¸ªå…ƒç´ Aã€Bå’ŒCï¼Œæ»¡è¶³(A B)C=A (BC)ã€‚\n3  å•ä½å…ƒï¼šå­˜åœ¨ä¸€ä¸ªå•ä½å…ƒIï¼Œä½¿å¾—å¯¹äºGä¸­çš„ä»»æ„å…ƒç´ Aï¼Œéƒ½æœ‰AI=IA=Aã€‚\n4  é€†å…ƒï¼šå¯¹äºGä¸­çš„ä»»æ„å…ƒç´ Aï¼Œå­˜åœ¨ä¸€ä¸ªé€†å…ƒA'ï¼Œä½¿å¾—AA'=A'A=Iã€‚\næˆ‘ä»¬é€ä¸€è¯æ˜è¿™å››ä¸ªæ¡ä»¶ï¼š\n1  å¯¹äºä»»æ„ä¸¤ä¸ªå…ƒç´ Aå’ŒBï¼Œç”±äºIA=AI=Aå’ŒIB=BI=Bï¼Œæ‰€ä»¥IA(IB)=A(BI)=ABï¼Œå› æ­¤ABâˆˆGï¼ŒGå¯¹äºçŸ©é˜µçš„ä¹˜æ³•æ˜¯é—­åˆçš„ã€‚\n2  å¯¹äºä»»æ„ä¸‰ä¸ªå…ƒç´ Aã€Bå’ŒCï¼Œç”±äºGä¸­çš„å…ƒç´ æ»¡è¶³IA=AI=Aå’ŒIB=BI=Bå’ŒIC=CI=Cï¼Œæ‰€ä»¥((AB)C)D=(AB)(CD)=A(BC)D=A(B(CD))=A(BD)ï¼Œå› æ­¤Gå¯¹äºçŸ©é˜µçš„ä¹˜æ³•æ˜¯ç»“åˆçš„ã€‚\n3  å­˜åœ¨ä¸€ä¸ªå•ä½å…ƒIï¼Œä½¿å¾—å¯¹äºGä¸­çš„ä»»æ„å…ƒç´ Aï¼Œéƒ½æœ‰AI=IA=Aã€‚å½“Açš„è¡Œåˆ—å¼ä¸º1æ—¶ï¼ŒAå³ä¸ºè¡Œåˆ—å¼ä¸º1çš„né˜¶çŸ©é˜µï¼Œæ­¤æ—¶æœ‰AI=IA=Aã€‚\n4  å¯¹äºä»»æ„å…ƒç´ Aï¼Œç”±äºGä¸­çš„å…ƒç´ æ»¡è¶³IA=AI=Aå’ŒIA=-Aï¼Œå› æ­¤Açš„è¡Œåˆ—å¼åªå¯èƒ½æ˜¯1æˆ–-1ã€‚å½“Açš„è¡Œåˆ—å¼ä¸º1æ—¶ï¼ŒAå³ä¸ºè¡Œåˆ—å¼ä¸º1çš„né˜¶çŸ©é˜µï¼Œæ­¤æ—¶å­˜åœ¨ä¸€ä¸ªé€†å…ƒA'ï¼Œä½¿å¾—AA'=A'A=Iã€‚å½“Açš„è¡Œåˆ—å¼ä¸º-1æ—¶ï¼ŒAä¸å±äºGï¼Œå› æ­¤ä¸è€ƒè™‘è¯¥æƒ…å†µã€‚\nç»¼ä¸Šæ‰€è¿°ï¼Œé›†åˆGå…³äºçŸ©é˜µçš„ä¹˜æ³•æ„æˆä¸€ä¸ªç¾¤ã€‚\näºŒã€è¦è¯æ˜å…³ç³»wæ˜¯ç­‰ä»·å…³ç³»ï¼Œéœ€è¦æ»¡è¶³ä»¥ä¸‹ä¸‰ä¸ªæ¡ä»¶ï¼š\n1  è‡ªåæ€§ï¼šå¯¹äºGLn(R)ä¸­çš„ä»»æ„çŸ©é˜µAï¼Œéƒ½æœ‰A w Aã€‚\n2  å¯¹ç§°æ€§ï¼šå¯¹äºGLn(R)ä¸­çš„ä»»æ„çŸ©é˜µAå’ŒBï¼Œå¦‚æœA w Bï¼Œåˆ™B w Aã€‚\n3  ä¼ é€’æ€§ï¼šå¯¹äºGLn(R)ä¸­çš„ä»»æ„çŸ©é˜µAã€Bå’ŒCï¼Œå¦‚æœA w Bä¸”B w Cï¼Œåˆ™A w Cã€‚\næˆ‘ä»¬é€ä¸€è¯æ˜è¿™ä¸‰ä¸ªæ¡ä»¶ï¼š\n1  å¯¹äºGLn(R)ä¸­çš„ä»»æ„çŸ©é˜µAï¼Œæœ‰AI=IA=Aå’ŒA(A-1)=Iï¼Œå› æ­¤A(A-1)A=Aï¼Œå³AA=A(A-1)Aå±äºGã€‚å› æ­¤A w Aï¼Œå…³ç³»wå…·æœ‰è‡ªåæ€§ã€‚2  å¯¹äºGLn(R)ä¸­çš„ä»»æ„çŸ©é˜µAå’ŒBï¼Œå¦‚æœA w Bï¼Œåˆ™å­˜åœ¨çŸ©é˜µCï¼Œä½¿å¾—AC=Bï¼Œå³A(B-1)=Cå±äºGã€‚åˆ™æœ‰B(A-1)=(A(B-1))(-1)å±äºGï¼Œå› æ­¤B w Aï¼Œå…³ç³»wå…·æœ‰å¯¹ç§°æ€§ã€‚\n3  å¯¹äºGLn(R)ä¸­çš„ä»»æ„çŸ©é˜µAã€Bå’ŒCï¼Œå¦‚æœA w Bä¸”B w Cï¼Œåˆ™å­˜åœ¨çŸ©é˜µDå’ŒEï¼Œä½¿å¾—AD=Bï¼ŒBE=Cï¼Œå³A(B-1)=Då±äºGå’ŒB(C-1)=Eå±äºGã€‚åˆ™æœ‰A(C-1)=(A(B-1))(B(C-1))å±äºGï¼Œå› æ­¤A w Cï¼Œå…³ç³»wå…·æœ‰ä¼ é€’æ€§ã€‚\nç»¼ä¸Šæ‰€è¿°ï¼Œå…³ç³»wæ˜¯ç­‰ä»·å…³ç³»ã€‚", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "æ±‚è§£é«˜ç­‰ä»£æ•°ç›¸å…³é—®é¢˜è§£ç­”\nè®¾Gï¼ï½›AâˆˆMn(Z)I IAIï¼1æˆ–IAIï¼-1ï½ï¼Œå…¶ä¸­Mn(Z)æ˜¯æŒ‡ç”±å…ƒç´ çš†ä¸ºæ•´æ•°çš„æ‰€æœ‰né˜¶çŸ©é˜µæ„æˆçš„é›†åˆ\nä¸€ï¼Œè¯æ˜é›†åˆGå…³äºçŸ©é˜µçš„ä¹˜æ³•æ„æˆä¸€ä¸ªç¾¤\näºŒï¼Œè®¾GLn(R)ï¼ï½›AâˆˆMn(R)I IAIâ‰ 0ï½ä¸ºä¸€èˆ¬çº¿æ€§ç¾¤ï¼Œåœ¨GLn(R)ä¸Šå®šä¹‰ä¸€ä¸ªå…³ç³»wå¦‚ä¸‹ï¼Œå¯¹GLn(R)ä¸­ä»»æ„ä¸¤ä¸ªçŸ©é˜µAå’ŒBï¼Œå¦‚æœA (B-1)âˆˆGï¼Œé‚£ä¹ˆç§°Aå’ŒNæ»¡è¶³å…³ç³»wï¼Œè®°ä½œAwBï¼Œè¯æ˜ï¼Œå…³ç³»wæ˜¯ç­‰ä»·å…³ç³»", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "ä½ å¥½ï¼Œxyæ„æˆçš„å¤šé¡¹å¼ä¹Ÿå¯ä»¥å†™ï¼Œä½†æ˜¯æ¯”è¾ƒç¹çï¼Œè€Œä¸”æ±‚è§£å¾ˆéš¾æ»¡è¶³æœ€åä¸€ä¸ªæ¡ä»¶ï¼Œå…¨å±€å¤§äº0ï¼Œä¸‹é¢æ˜¯æˆ‘çš„ä¸€ç»´æ‹“å±•æ–¹æ¡ˆï¼šä¸»å‡½æ•°ï¼š\n%% ä¸ºäº†å¾—åˆ°åˆ†å¸ƒï¼Œå‡è®¾äº†ä¸€ä¸ªåæ–¹å·®çŸ©é˜µ\nmu=[20,180];%æ•°å­¦æœŸæœ›\nsigma=[20/3 0;0,60].^2;%åæ–¹å·®çŸ©é˜µ\nr=mvnrnd(mu,sigma,100000);%ç”Ÿæˆ100000ä¸ªæ ·æœ¬\nx = r(:,1);\ny = r(:,2);\n[X, Y, C, xmid, ymid] = ef2(x,y,21,21,[0,40],[0,360]);% ,50,50,[-3, 3],[-3, 3]\nC = C/(18*2);\nfigure(1);clf;\nbar3(C)\ntitle('åŸå…ˆæ•°æ®')\nxtick = 1:size(C,2); xticklabel = xmid; % xtickå’Œxticklabelä¸€å®šè¦å¯¹åº”ï¼Œé•¿åº¦ç›¸ç­‰\nytick = 1:size(C,1); yticklabel = ymid; % ytickå’Œyticklabelä¸€å®šè¦å¯¹åº”ï¼Œé•¿åº¦ç›¸ç­‰\nset(gca, 'xtick', xtick, 'xticklabel',xticklabel,...\n    'ytick', ytick, 'yticklabel',yticklabel)\nxlabel('X')\nylabel('Y')\nx = X(:);\ny = Y(:);\nz = C(:);\n\n\nn = 7; % nä¸ºå¤šé¡¹å¼çš„é˜¶æ•°ï¼Œå‚æ•°ä¸€å…±ä¸º(n+1)Â²ä¸ª\n[i1, i2] = meshgrid(0:n);\nF = arrayfun(@(i)x.^i1(i).*y.^i2(i), 1:numel(i1), 'uniform', 0);\nF = cell2mat(F);\n\nA = F'*F;\nb = F'*z;\na = A\\b;%æœ€å°äºŒä¹˜æ³•\n\nzfit1 = polyfunval(X,Y,a,n);\nfigure(2);clf;\nbar3(zfit1)\nxtick = 1:size(C,2); xticklabel = xmid; % xtickå’Œxticklabelä¸€å®šè¦å¯¹åº”ï¼Œé•¿åº¦ç›¸ç­‰\nytick = 1:size(C,1); yticklabel = ymid; % ytickå’Œyticklabelä¸€å®šè¦å¯¹åº”ï¼Œé•¿åº¦ç›¸ç­‰\nset(gca, 'xtick', xtick, 'xticklabel',xticklabel,...\n    'ytick', ytick, 'yticklabel',yticklabel)\ntitle('æœ€å°äºŒä¹˜æ³•')\n\nG = arrayfun(@(i)40^(i1(i)+1)*360^(i2(i)+1)/((i1(i)+1)*(i2(i)+1)), 1:numel(i1));\naa = [A, G'; G,1]\\[b;1];\nzfit2 = polyfunval(X,Y,aa,n);\nfigure(3);clf;\nbar3(zfit2)\nfprintf('zfitæœ€å°å€¼%f\\n', min(zfit2(:)))\nxtick = 1:size(C,2); xticklabel = xmid; % xtickå’Œxticklabelä¸€å®šè¦å¯¹åº”ï¼Œé•¿åº¦ç›¸ç­‰\nytick = 1:size(C,1); yticklabel = ymid; % ytickå’Œyticklabelä¸€å®šè¦å¯¹åº”ï¼Œé•¿åº¦ç›¸ç­‰\nset(gca, 'xtick', xtick, 'xticklabel',xticklabel,...\n    'ytick', ytick, 'yticklabel',yticklabel)\ntitle('æœ€å°äºŒä¹˜æ³•+æ‹‰æ ¼æœ—æ—¥ä¹˜å­æ³•ï¼ˆä¿è¯ç§¯åˆ†ä¸º1ï¼‰')\npause(0.01)\n\na = getIniA(x,y,z,n);\noptions = optimoptions('fmincon','Algorithm','interior-point');% \nflag = -1; %è®¾åˆå§‹ä¸æ”¶æ•›\nf = @(a)myfun(a,x,y,z,n);\nnlinf = @(a)nlinfunc(a,x,y,n);\n\nwhile(flag<=0)\n    ratio = 0.1;%å¦‚æœé•¿æ—¶é—´ä¸æ”¶æ•›ï¼Œå‡å°‘næˆ–è€…æ”¹åŠ¨ratioå†è®¡ç®—\n    [aa,~,flag] = fmincon(f,a+ratio*(rand(size(a))-0.5).*a,[],[],G,1, [], [], nlinf,options);\nend\n\nå¤šé¡¹å¼æ±‚å€¼å‡½æ•°polyfunval.m\nfunction f = polyfunval(x,y,a,n)\n[i1, i2] = meshgrid(0:n);\nCfit = arrayfun(@(i)a(i)*x.^i1(i).*y.^i2(i), 1:numel(i1), 'uniform', 0);\nf = Cfit{1};\nfor i = 2:numel(Cfit)\n    f = f + Cfit{i};\nend\nend\n\nç›®æ ‡å‡½æ•°ï¼šä¼˜åŒ–å‡½æ•°\nfunction f = myfun(a,x,y,z,n)\nzf = polyfunval(x,y,a,n);\nf = norm(zf-z);\nend\n\néçº¿æ€§çº¦æŸ\nfunction [c,ceq] = nlinfunc(a,x,y,n)\nF = polyfunval(x,y,a,n);\nc = - min(F);\nceq = [];\nend\n\nåˆ†å¸ƒç»Ÿè®¡å‡½æ•°\nfunction [X, Y, CDF, xmid, ymid] = ef2(x,y,nx,ny,xminmax,yminmax)\n% xï¼šxçš„å€¼\n% yï¼šyçš„å€¼\n% nxï¼šxæ–¹å‘åˆ’åˆ†æ®µæ•°\n% nyï¼šyæ–¹å‘åˆ’åˆ†æ®µæ•°\n% xminmax = [xmin, xmax]\n% yminmax = [ymin, ymax]\nnum = length(x);\nif(num~=length(y))\n   error('è¾“å…¥çš„xå’Œyé•¿åº¦å¿…é¡»ç›¸ç­‰') \nend\nif(nargin>6) % å¦‚æœå˜é‡ä¸ªæ•°å¤§äº6ä¸ªï¼Œå¤ªå¤šäº†\n    error('å¤ªå¤šè¾“å…¥å˜é‡')\nelseif(nargin<2) % å¦‚æœå˜é‡ä¸ªæ•°å°äº2ä¸ªï¼Œå¤ªå°‘äº†\n    error('è¾“å…¥å˜é‡æ•°ç›®ä¸è¶³!!')\nend\nif(nargin==6) % å¦‚æœå˜é‡ä¸ªæ•°ç­‰äº6ä¸ªï¼Œèµ‹å€¼ç»™yminå’Œymax\n    ymin = yminmax(1);\n    ymax = yminmax(2);\nend\nif(nargin>=5)% å¦‚æœå˜é‡ä¸ªæ•°å¤§äºç­‰äº5ä¸ªï¼Œèµ‹å€¼ç»™xminå’Œxmax\n    xmin = xminmax(1);\n    xmax = xminmax(2);\nend\nif(nargin<=4)% å¦‚æœå˜é‡ä¸ªæ•°å°äºç­‰äº4ä¸ªï¼Œè‡ªå®šä¹‰xminå’Œxmax\n    xmin = min(x);\n    xmax = max(x)+eps;\n    ymin = min(y);\n    ymax = max(y)+eps;\nend\nif(nargin<=3)% å¦‚æœå˜é‡ä¸ªæ•°å°äºç­‰äº3ä¸ªï¼Œè‡ªå®šä¹‰yæ–¹å‘åˆ’åˆ†æ®µæ•°ny\n    ny = 30;\nend\nif(nargin==2)% å¦‚æœå˜é‡ä¸ªæ•°ç­‰äº2ä¸ªï¼Œè‡ªå®šä¹‰xæ–¹å‘åˆ’åˆ†æ®µæ•°nx\n    nx = 30;\nend\nxg = linspace(xmin, xmax, nx);%xæ–¹å‘çš„ç‚¹\nyg = linspace(ymin, ymax, ny);%yæ–¹å‘çš„ç‚¹\nxmid = (xg(1:end-1)+xg(2:end))/2;\nymid = (yg(1:end-1)+yg(2:end))/2;\n[X,Y] = meshgrid(xmid, ymid);%å½¢æˆç½‘æ ¼\n[I,J] = meshgrid(2:nx, 2:ny);%ä¸‹æ ‡ç½‘æ ¼\nCDF = arrayfun(@(i,j)sum(x>=xg(i-1)&x<xg(i)&y<yg(j)&y>=yg(j-1))/num,I,J);%å½¢æˆç»éªŒåˆ†å¸ƒ\nend\n\nåˆå§‹åŒ–å‚æ•°å‡½æ•°\nfunction aa = getIniA(x,y,z, n)\n % nä¸ºå¤šé¡¹å¼çš„é˜¶æ•°ï¼Œå‚æ•°ä¸€å…±ä¸º(n+1)Â²ä¸ª\n[i1, i2] = meshgrid(0:n);\nF = arrayfun(@(i)x.^i1(i).*y.^i2(i), 1:numel(i1), 'uniform', 0);\nF = cell2mat(F);\nA = F'*F;\nb = F'*z;\nG = arrayfun(@(i)40^(i1(i)+1)*360^(i2(i)+1)/((i1(i)+1)*(i2(i)+1)), 1:numel(i1));\naa = [A, G'; G,1]\\[b;1];\naa = aa(1:end-1);\nend\n\næœ€åå¯è§zfitæœ€å°å€¼ä¸º-1e-7ï¼Œå¾ˆå°ï¼ˆä½†ä¸æ˜¯æ­£æ•°ï¼‰ï¼Œåªæ»¡è¶³äº†å¤šé¡¹å¼æ‹Ÿåˆå’Œç§¯åˆ†ä¸º1çš„ä¼˜åŒ–ã€‚å…¨å±€ä¸º0æœç´¢éå¸¸ä¹…ä¹Ÿéš¾å¾—åˆ°ç»“æœï¼Œå¯èƒ½åŸå› åœ¨äºç³»æ•°å¤ªè¿‡äºæ•æ„Ÿï¼Œå› ä¸º360çš„7æ¬¡æ–¹éå¸¸å¤§ï¼Œè€Œ1çš„7æ¬¡æ–¹åˆç‰¹åˆ«å°ã€‚", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "MATLABå¦‚ä½•å®ç°å¸¦ç­‰å¼å’Œä¸ç­‰å¼çº¦æŸæ¡ä»¶çš„æœ€å°äºŒä¹˜æ³•æ‹Ÿåˆå¤šå…ƒå¤šé¡¹å¼\nå¤šå…ƒå¤šé¡¹å¼çš„å…¬å¼å¦‚å›¾ï¼Œç°åœ¨æœ‰nä¸ªæ•°æ®ï¼ˆx,y,f(x,y)ï¼‰æ¥æ‹Ÿåˆè¿™ä¸ªå¤šé¡¹å¼ï¼Œç”¨æœ€å°äºŒä¹˜æ³•ï¼Œå…·ä½“ç¨‹åºå¦‚ä¸‹é¢çš„ä»£ç \n\n\nZ\n=\nxlsread('Linton.xlsx')\n;\n\n\nx\n=\nZ(:\n,\n1\n)\n;%xçš„æ•°æ®ï¼Œä¸ºé£é€Ÿï¼ŒèŒƒå›´æ˜¯0åˆ°40\n\ny\n=\nZ(:\n,\n2\n)\n;%yçš„æ•°æ®ï¼Œä¸ºé£å‘ï¼ŒèŒƒå›´æ˜¯0åˆ°360\n\nz\n=\nZ(:\n,\n3\n)\n;%é¢‘ç‡æ•°æ®\n\nn \n=\n \n7\n; % nä¸ºå¤šé¡¹å¼çš„é˜¶æ•°ï¼Œå‚æ•°ä¸€å…±ä¸º(n+1)Â²ä¸ª\n\np \n=\n length(\nx\n)\n; q = length(y);\n\n[X\n,\nY\n,\ni1\n,\ni2\n] \n=\n ndgrid(\nx\n,\ny\n,\n0\n:n\n,\n0\n:n)\n;\n\nF \n=\n X.^\ni1\n.*Y.^\ni2\n;\n\nF \n=\n reshape(F\n,\n p*q\n,\n (n+\n1\n)^\n2\n)\n; %è¿™ä¸€æ®µæ˜¯æœ€å°äºŒä¹˜æ³•çš„å·¦è¾¹çŸ©é˜µï¼ŒFçŸ©é˜µå…·ä½“å½¢å¼å¦‚ä¸‹å›¾\n\nA \n=\n F'*F\n;\n\nb \n=\n F'*z\n;\n\na \n=\n A\\b\n;%æœ€å°äºŒä¹˜æ³•\n\n\n\n\n\n\nç„¶åç°åœ¨å°±æ˜¯å¾—åŠ å…¥2ä¸ªçº¦æŸæ¡ä»¶ï¼Œä¸€ä¸ªæ˜¯xåœ¨0åˆ°40ï¼Œyåœ¨0åˆ°360ï¼Œf(x,y)çš„ç§¯åˆ†ç­‰äº1ï¼Œç„¶åf(x,yï¼‰æ°¸è¿œå¤§äº0è¿™ä¸¤ä¸ªçº¦æŸæ¡ä»¶ã€‚ç§¯åˆ†ä¸º1è¿™ä¸ªçº¦æŸå¯ä»¥ç”¨æ‹‰æ ¼æœ—æ—¥ä¹˜å­æ³•æ¥å†™ã€‚å¦‚æœæ˜¯ä¸‹å›¾çš„æ™®é€šå¤šé¡¹å¼ï¼Œå¯ä»¥åŠ ä¸‹é¢ä¸€æ®µä»£ç è§£å†³ç§¯åˆ†ä¸º1\n\n\n\n\nG = \n1.\n/\n(n+1:-1:1)\n.*\n40.\n^\n(n+1:-1:1)\n;\n%\n è¿™æ®µæ˜¯ä¸Šå›¾çš„æ™®é€šå¤šé¡¹å¼ç§¯åˆ†ä¸º\n1\nï¼Œç›´æ¥å†™å‡ºäº†ç§¯åˆ†å½¢å¼ç„¶åç”¨æ‹‰æ ¼æœ—æ—¥ä¹˜å­æ³•\n\n%\nç°åœ¨éœ€è¦å¯¹æœ€ä¸Šé¢çš„å¤šå…ƒå¤šé¡¹å¼ç§¯åˆ†ä¸º\n1\nï¼Œéœ€è¦æ”¹æˆxåœ¨\n0\nåˆ°\n40\nï¼Œyåœ¨\n0\nåˆ°\n360\nçš„äºŒé‡ç§¯åˆ†ä¸º\n1\n\naa = [A, F\n'; F, 0]\\[b;1];%æ‹‰æ ¼æœ—æ—¥ä¹˜å­æ³•\n\n\n\n\nç°åœ¨æ˜¯å¾—æŠŠGçŸ©é˜µå†™æˆäºŒé‡ç§¯åˆ†ï¼Œæƒ³é—®ä¸‹è¿™ç§å¤šå…ƒå¤šé¡¹å¼è¿›è¡ŒäºŒé‡ç§¯åˆ†çš„ä»£ç åº”è¯¥æ€ä¹ˆå†™ã€‚å†å°±æ˜¯f(x,y)æ°¸è¿œå¤§äº0çš„çº¦æŸè¦å¦‚ä½•åŠ ä¸Šï¼Œä»¥å‰åªå†™è¿‡ä¸€ç»´æ•°æ®ï¼Œç„¶åæ™®é€šå¤šé¡¹å¼MATLABä¹Ÿæœ‰ä»£ç ï¼Œè¿™ä¸ªå¤šå…ƒå¤šé¡¹å¼å¾—è‡ªå·±ç¼–å†™", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "æ¥¼ä¸»å¯ä»¥å‘ä¸‹æ•´ä¸ªä»£ç å—ï¼Ÿ\nÂ ", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "c è¯­è¨€ c free æŠ¥é”™æ±‚è§£å†³\nerror: (Each undeclared identifier is reported only once for each function it appears in.)\n\n\n\nå¤´æ–‡ä»¶ä¹ŸåŠ äº†\n\n\n\n\n\n\n\n\n\n\n\n#include \nvoid rabbitPrint()\n{\n\t printf(\"\\n\");\n\t printf(\"\\n\");\n     printf(\"\\t this is a rabbit!\\n\");\n\t printf(\"\\n\");\n\t printf(\"\\n\");\n\t printf(\"\\t*           *\\n\");\n\t printf(\"\\t**         **\\n\");\n\t printf(\"\\t **       **\\n\");\n     printf(\"\\t  **     **\\n\");\n\t printf(\"\\t     ***\\n\");\n     printf(\"\\t    *    *\\n\");\n\t printf(\"\\t   *   ** *\\n\");\n\t printf(\"\\t  *        *\\n\");\n\t printf(\"\\t *      *   *\\n\");\n\t printf(\"\\t*      ***   *\\n\");\n\t printf(\"\\t *          *\\n\");\n\t printf(\"\\t    *******    \\n\");\n\t printf(\"\\n\");\n\t printf(\"\\n\");\n   \n}\n\nfloat maxIQ(float you,float me)\n{\n\tif(you>me)\n\treturn you;\n\telse return me;\n\t\n}\n\n\nint main()\n{   int mflag=1; \n    int sflag;\n\tint mSelect;\n\tint sSelect;\n\twhile(mflag) \n    {\t\t\t\n\tprintf(\"\\t\\tHI,æˆ‘æ˜¯æœºå™¨äººå°cï¼Œè¯·é—®éœ€è¦ä»€ä¹ˆå¸®åŠ©å—ï¼Ÿ\\n\");\n\tprintf(\"\\t\\tæˆ‘åœ¨å¬ï¼Œè¯·ç»§ç»­ï¼\\n\"); \n\tprintf(\"\\t\\tä½ å¯ä»¥è¿™æ ·é—®æˆ‘ï¼š\\n\"); \n\tprintf(\"\\n\\n\");\n\tprintf(\"\\t\\t1.è¯·ç»™æˆ‘è®²ä¸ªç¬‘è¯ï¼\\n\");\n\tprintf(\"\\t\\t2.è¯·ç»™æˆ‘æ‰“å°ä¸€äº›æ¼‚äº®çš„å›¾å½¢ï¼\\n\");\n\tprintf(\"\\t\\t3.æˆ‘è¦è¿›è¡Œä¸€äº›æ™ºèƒ½è¿ç®—ï¼\\n\");\n \tprintf(\"\\n\\n\");\n\tprintf(\"è¯·è¾“å…¥é€‰æ‹©é¡¹:\");\n\tscanf(\"%d\",&mSelect);\n\tif(mSelect==1)\n\t{\n    printf(\"\\t\\t   1--æˆ‘æœ‰ä¸ªæœ‹å‹ï¼Œè®²äº†ä¸€ç”Ÿç”µè¯ï¼Œæœ‰ä¸€å¤©ä»–æŒ‚äº†ã€‚\\n\");\n    printf(\"\\t\\t   0--é€€å‡º\\n\");\t\n\t}\n\telse if(mSelect==2)\n\t{\n\tsflag=1;\n\twhile(sflag) \n\t{ \n    printf(\"\\t\\t   1--æˆ‘è¦ä¸€åªå°å…”å­å›¾å½¢\\n\");\n    printf(\"\\t\\t   2--æˆ‘è¦ä¸€å¼ 99ä¹˜æ³•è¡¨\\n\");\n    printf(\"\\t\\t   3--æˆ‘è¦ä¸€ä¸ªä»»æ„å°ºå¯¸çš„æ˜Ÿå·çŸ©é˜µ\\n\");\n    printf(\"\\t\\t   0--é€€å‡º\\n\");\n    printf(\"è¯·è¾“å…¥ä½ çš„é€‰æ‹©:\");\n    scanf(\"%d\",&sSelect);\n\tswitch(sSelect)\n\t{\n\tcase 1: rabbitPrint(); break;\n\tcase 2:printf(\"æˆ‘è¦ä¸€å¼ 99ä¹˜æ³•è¡¨ï¼åŠŸèƒ½å¾…å®ç°\");break;\n\tcase 3:printf(\"æˆ‘è¦ä¸€ä¸ªä»»æ„å°ºå¯¸çš„æ˜Ÿå·çŸ©é˜µï¼åŠŸèƒ½å¾…å®ç°\");break;\n\tcase 0:sflag=0;\n\tbreak;\n\tdefault: printf(\"è¾“å…¥æœ‰è¯¯\");\n\tbreak;\n\t}\n\t}\n\t}\n\telse if(mSelect==3)\n\t{ sflag=1;\n\t while(sflag)\n    {\t\n\tprintf(\"\\t\\t   1--æ¯”è¾ƒä¸€ä¸‹æˆ‘å’Œä½ çš„æ™ºå•†è°é«˜ï¼\\n\");\n    printf(\"\\t\\t   2--ç»™ä½ ä¸€é˜Ÿç‹è€…è£è€€æ¸¸æˆäººç‰©ï¼ŒæŒ‰ç…§æˆ˜æ–—å€¼é‡æ–°æ’é˜Ÿå“¦ï¼å˜¿å˜¿ï¼\\n\");\n    printf(\"\\t\\t   3--ä»å‡ é˜Ÿæ¸¸æˆäººç‰©é‡Œï¼Œæ‰¾åˆ°æˆ˜æ–—å€¼æœ€é«˜çš„ç»™æˆ‘ï¼\\n\");\n    printf(\"\\t\\t   0--é€€å‡º\\n\");\n    printf(\"\\n\\n\");\n    printf(\"è¯·è¾“å…¥ä½ çš„é€‰æ‹©:\");\n    scanf(\"%d\",&sSelect);\n   \tswitch(sSelect)\n\t{\n\tcase 1:float you,me;\n    printf(\"è¾“å…¥ä½ çš„æ™ºå•†:\");\n\tscanf(\"%f\",&you);\n\tprintf(\"è¾“å…¥æˆ‘çš„æ™ºå•†:\");\n\tscanf(\"%f\",&me);\n    printf(\"æ™ºå•†æœ€é«˜çš„æ˜¯:%f\\n\",maxIQ(you,me));break;\t\t\t\n\tcase 2:printf(\"ç»™ä½ ä¸€é˜Ÿç‹è€…è£è€€æ¸¸æˆäººç‰©ï¼ŒæŒ‰ç…§æˆ˜æ–—å€¼é‡æ–°æ’é˜Ÿå“¦ï¼å˜¿å˜¿ï¼åŠŸèƒ½å¾…å®ç°\");break;\n\tcase 3:printf(\"ä»å‡ é˜Ÿæ¸¸æˆäººç‰©é‡Œï¼Œæ‰¾åˆ°æˆ˜æ–—å€¼æœ€é«˜çš„ç»™æˆ‘ï¼åŠŸèƒ½å¾…å®ç°\");break;\n\tcase 0:sflag=0;\n\tbreak;\n\tdefault: printf(\"è¾“å…¥æœ‰è¯¯\");\n\t}\n\t}\n    }\n\telse if(mSelect==0)\n\t{\n\tmflag=0;\n\tprintf(\"é€€å‡º\\n\");\n\t}\n\telse\n\tprintf(\"è¾“å…¥æœ‰è¯¯\\n\");\n\tgetchar();\n\tgetchar();\n\treturn 0;\t\n\t}\n\t} \n", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "æˆ‘å¼•ç”¨ChatGPTä½œç­”ï¼šå¤§æ¦‚è¿™æ ·å‘¢ï¼Ÿä¸çŸ¥é“è¡Œä¸è¡Œã€‚\n\nlamd=0.193*10^-3; % å…¥å°„æ³¢é•¿\nw=1.5; % å…¥å°„å…‰æŸè…°\nR=1.5; % å…ƒä»¶çš„æé™å­”å¾„\nD=175*10^-3; % è¡å°„è·ç¦»\nL0=10.5*10^-3; % ç…§æ˜åŒºåŸŸåŠå¾„\nr1=7.5*10^-3; % å†…åŠå¾„\nr2=10.5*10^-3; % å¤–åŠå¾„\n%theta=45*pi/180; % æè§’\ntheta = pi/4;\nk=2*pi/lamd; % æ³¢æ•°\nN=256;\n\n\n% ç”Ÿæˆåæ ‡ç½‘æ ¼\nx=linspace(-L0/2,L0/2,N);\ny=linspace(-L0/2,L0/2,N);\n[X,Y]=meshgrid(x,y);\n\n% ç”Ÿæˆåœ†å½¢å…‰é˜‘\nJ1=zeros(N);\nfor m=1:N\n    for n=1:N\n        if X(m,n)^2+Y(m,n)^2<=R^2\n            J1(m,n)=1;\n        end\n    end\nend\n\n% ç”Ÿæˆé«˜æ–¯å…‰æŸ\nA=exp(-(X.^2+Y.^2)/w^2).*J1;\n\n% ç”Ÿæˆå¶æç…§æ˜\nJ4=zeros(N);\nfor m=1:N\n    for n=1:N\n        if X(m,n)^2+Y(m,n)^2>=r1^2 && X(m,n)^2+Y(m,n)^2<=r2^2 && abs(atan2(Y(m,n),X(m,n)))<=theta/2\n            J4(m,n)=1;\n        end\n    end\nend\n\n% è®¡ç®—å…‰é˜‘å’Œé«˜æ–¯å…‰æŸçš„ä¸­å¿ƒ\nJ1_center = [round(N/2), round(N/2)];\nA_center = [round(N/2), round(N/2)];\n\n% è®¡ç®—å…‰é˜‘å’Œé«˜æ–¯å…‰æŸéœ€è¦å¹³ç§»çš„è·ç¦»\nJ1_shift = J1_center - [find(J1(:,1),1,'first'), find(J1(1,:),1,'first')];\nA_shift = A_center - [find(A(:,1),1,'first'), find(A(1,:),1,'first')];\n\n% å¹³ç§»å…‰é˜‘å’Œé«˜æ–¯å…‰æŸ\nJ1 = circshift(J1, J1_shift);\nA = circshift(A, A_shift);\n\n% ç”Ÿæˆæ‰‡å½¢å…‰é˜‘\nfor m=1:N\n    for n=1:N\n        if J4(m,n) && abs(atan2(Y(m,n),X(m,n)))>theta/2\n            J4(m,n)=0;\n        end\n    end\nend\n\n% è®¡ç®—å½’ä¸€åŒ–ç³»æ•°\na=sum(sum(A.^2))/sum(sum(J4.^2));\nJ4=J4*sqrt(a);\n\n% å˜æ¢åˆ°è¡å°„é¢\nA_fft=fftshift(fft2(A));\nJ4_fft=fftshift(fft2(J4));\nx_fft=linspace(-1/(2*D),1/(2*D),N);\n[X_fft,Y_fft]=meshgrid(x_fft,x_fft);\nphase_term=exp(1i*k*(X_fft.^2+Y_fft.^2)*D);\nB_fft=J4_fft.*phase_term.*A_fft;\n\n% å˜æ¢å›ç‰©é¢\nB=ifft2(ifftshift(B_fft));\n\n% æ˜¾ç¤ºç…§æ˜å…‰æ–‘\nsubplot(1,3,1);\nimagesc(x,y,J4); axis square;\ntitle('Illumination Pattern')\nxlabel('x / mm'); ylabel('y / mm');\n\n\n% æ˜¾ç¤ºé«˜æ–¯å…‰æŸ\nsubplot(1,3,2);\nimagesc(x11,y11,A);axis square;\ntitle('Gaussian Beam')\nxlabel('x / mm');ylabel('y / mm');\n% æ˜¾ç¤ºè¡å°„å›¾æ ·\nsubplot(1,3,3);\nimagesc(x,y,abs(B).^2); axis square;\ntitle('Diffraction Pattern')\nxlabel('x / mm'); ylabel('y / mm');\n\n% ç”Ÿæˆå¶æç…§æ˜å’Œé«˜æ–¯å…‰æŸçš„äº¤å‰é¡¹\nJ5 = zeros(N);\nfor m=1:N\nfor n=1:N\nif ~isnan(J2(m,n)) && ~isnan(A(m,n)) && J2(m,n) && A(m,n)\nJ5(m,n) = 1;\nend\nend\nend\n\n% æ˜¾ç¤ºäº¤å‰é¡¹\nsubplot(1,3,3);\nimagesc(x11,y11,J5);axis square;\ntitle('Cross Term')\nxlabel('x / mm');ylabel('y / mm');\n", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "å…³äºmatlabçš„é—®é¢˜\nå…³äºé«˜æ–¯å…‰æŸæ•´å½¢çš„é—®é¢˜\néœ€è¦æŠŠç¯å½¢çš„é«˜æ–¯å…‰æŸï¼ŒåŠ ä¸ªå¶çº§ç…§æ˜ï¼Œæˆªå–ä¸¤éƒ¨åˆ†æ‰‡å½¢ï¼Œä¸‹é¢è¿™ä¸ªç¨‹åºæ˜¯é«˜æ–¯å…‰æŸæ•´å½¢æˆç¯å½¢çš„ç¨‹åºï¼Œæˆ‘è¯¥åœ¨ä»€ä¹ˆåœ°æ–¹åŠ ä¸ªä»€ä¹ˆæ ·çš„ç¨‹åºï¼Ÿæœ€å¥½æ˜¯ç›´æ¥ç¼–å†™å¥½çš„_(:Ğ·ã€âˆ )_æœ€åæˆç‰‡æ˜¯ç±»ä¼¼å›¾ä¸­çš„æ ·å­ï¼Œä¸è¿‡æ˜¯æœ‰åè½¬ï¼Œæè§’æ˜¯45Â°\n\n\nå…·ä½“æŒ‡æ ‡åŒ…æ‹¬ï¼šå…¥å°„å…‰æŸä¸ºç›´å¾„1.5mmå¹³é¢æ³¢ï¼Œå…‰å¼ºä¸ºé«˜æ–¯åˆ†å¸ƒï¼Œæ³¢é•¿193nmï¼›DOEé€šå…‰å£å¾„ä¸º1.5mmï¼Œç›®æ ‡å¹³é¢ä¸DOEæ‰€åœ¨å¹³é¢çš„è·ç¦»ä¸º175mmï¼Œç›®æ ‡å¹³é¢å…‰åœºåˆ†å¸ƒå½¢å¼ä¸ºå¶æç…§æ˜ï¼Œå¤–åŠå¾„10.5mmï¼Œå†…åŠå¾„7.5mmï¼Œæè§’45Â°ï¼Œç…§æ˜åŒºåŸŸå†…è¦æ±‚å…‰å¼ºå‡åŒ€åˆ†å¸ƒï¼Œå…‰èƒ½åˆ©ç”¨ç‡â‰¥80%ï¼Œå…‰å¼ºä¸å‡åŒ€æ€§â‰¤20%\n\n\n%å†…èƒ½é‡è¶…è¿‡90%çš„è¡å°„åœ†\n\n\n% è¡å°„è·ç¦»ã€‚ç¨‹åºä¸­çš„uintæ˜¯æ¯«ç±³\n\n\n% å®šä¹‰å˜é‡\n\nlamd=\n0.193\n*\n10\n^\n-3\n; \n% å…¥å°„æ³¢é•¿\n\nw=\n1.5\n; \n% å…¥å°„å…‰æŸè…°\n\nR=\n1.5\n; \n% å…ƒä»¶çš„æé™å­”å¾„\n\nD=\n700\n; \n% è¡å°„è·ç¦»\n\nr1=\n1.5\n; \n% åœ†çš„å†…åŠå¾„\n\nr2=\n3\n; \n% åœ†çš„å¤–åŠå¾„\n\nL0=\n10\n; \n% æ°´å¹³é•¿åº¦ï¼ˆä»¥æ¯«ç±³ä¸ºå•ä½ï¼‰\n\nk=\n2\n*\npi\n/lamd; \n% æ³¢æ•°\n\nN=\n256\n; \n% é‡‡æ ·ç‚¹æ•°\n\n\n%%%%%%%%%%%%% åˆ¤æ–­ï¼ˆåˆ†æå˜æ¢ï¼‰\n\n\n% åˆ¤æ–­æ˜¯å¦æ»¡è¶³è²æ¶…å°”å˜æ¢æ¡ä»¶\n\nJudging=(\nsqrt\n(N*lamd*D)<=L0); \n% è®¡ç®—ä¸€ä¸ªéè´Ÿæ•°çš„å¹³æ–¹æ ¹\n\n\nif\n Judging==\n0\n\n    \ndisp\n(\n'????ERROR'\n);\n    \ndisp\n(\n'......Fresnel Analytic Transformation is not satisfied'\n); \n% è²æ¶…å°”å˜æ¢ä¸æ»¡è¶³\n\n    \n% break;\n\n\nend\n\n\n%%%%%%%%%%%%%\n\n\n% ç”Ÿæˆç½‘æ ¼ç‚¹\n\nx11=\nlinspace\n(-L0/\n2\n,L0/\n2\n,N); \n% åœ¨[-L0/2, L0/2]èŒƒå›´å†…ç”ŸæˆNä¸ªç‚¹\n\ny11=\nlinspace\n(-L0/\n2\n,L0/\n2\n,N); \n% åœ¨[-L0/2, L0/2]èŒƒå›´å†…ç”ŸæˆNä¸ªç‚¹\n\n[x1,y1]=\nmeshgrid\n(x11,y11); \n% ç”Ÿæˆç½‘æ ¼ç‚¹\n\n\n% ç”Ÿæˆå…‰å¼ºå‡½æ•°J1\n\nJ1=\nzeros\n(N);\n\nfor\n m=\n1\n:N\n    \nfor\n n=\n1\n:N\n        \nif\n x1(m,n)^\n2\n+y1(m,n)^\n2\n<=R^\n2\n \n% å¦‚æœç‚¹åœ¨åœ†å†…éƒ¨ï¼Œåˆ™å–å€¼ä¸º1ï¼Œå¦åˆ™ä¸º0\n\n            J1(m,n)=\n1\n;\n        \nend\n\n    \nend\n\n\nend\n\n\n% ç”Ÿæˆå¹²æ¶‰å›¾çš„æŒ¯å¹…å‡½æ•°A\n\nA=\nexp\n(-(x1.^\n2\n+y1.^\n2\n)/w^\n2\n).*J1;\n\n%%%%%\n\n\n% ç”Ÿæˆé¢‘ç‡åŸŸä¸Šçš„ç½‘æ ¼ç‚¹\n\nfx=\n1\n/L0*(-N/\n2\n:N/\n2\n-1\n);\nfy=\n1\n/L0*(-N/\n2\n:N/\n2\n-1\n);\n[fx,fy]=\nmeshgrid\n(fx,fy);\n\n%%%%%%\n\n\n% ç”Ÿæˆå¹²æ¶‰å›¾çš„æ©æ¨¡å‡½æ•°JJ\n\nJJ=\nzeros\n(N);\n\nfor\n m=\n1\n:N\n    \nfor\n n=\n1\n:N\n        \nif\n x1(m,n)^\n2\n+y1(m,n)^\n2\n>=r1^\n2\n && x1(m,n)^\n2\n+y1(m,n)^\n2\n<=r2^\n2\n \n% å¦‚æœç‚¹åœ¨åœ†ç¯å†…ï¼Œåˆ™å–å€¼ä¸º1ï¼Œå¦åˆ™ä¸º0\n\n            JJ(m,n)=\n1\n;\n        \nend\n\n    \nend\n\n\nend\n\na=sum(sum(A.^\n2\n))/sum(sum(JJ.^\n2\n)); \n% è®¡ç®—æ”¾ç¼©ç³»æ•°\n\nJ2=JJ*\nsqrt\n(a); \n% å¯¹JJè¿›è¡Œç¼©æ”¾ï¼Œä½¿å…¶å¹³å‡å…‰å¼ºç­‰äºA\n\n\n%imagesc(J2);axis square;colormap(gray)å›¾åƒSCï¼ˆJ2ï¼‰ï¼›è½´çº¿æ­£æ–¹å½¢ï¼›é¢œè‰²å›¾ï¼ˆç°è‰²ï¼‰\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% G-S\n\n\n%pha0=load('C:\\Documents and Settings\\wjq\\My Documents\\MATLAB\\pha90.txt');\n\npha0=\n2\npirand(N)-\npi\n; \n% ç”Ÿæˆä¸€ä¸ªNÃ—Nå¤§å°çš„çŸ©é˜µï¼ŒçŸ©é˜µä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯åœ¨[-pi, pi]èŒƒå›´å†…éšæœºç”Ÿæˆçš„ä¸€ä¸ªè§’åº¦ï¼Œä½œä¸ºåˆç›¸ã€‚\n\nM=\n0\n;CC=[];eta=\n0\n;\n\nwhile\n eta<\n0.90\n \n% å½“etaå°äº0.9æ—¶ï¼Œè¿›è¡Œå¾ªç¯è®¡ç®—\n\nM=M+\n1\n; \n% å¾ªç¯æ¬¡æ•°è‡ªåŠ 1\n\nU1=A.\nexp\n(ipha0); \n% é€šè¿‡çŸ©é˜µä¹˜æ³•ç”Ÿæˆåˆå§‹çš„å…‰å¼ºåˆ†å¸ƒ\n\ntemp1=(fft2(U1)); \n% å¯¹åˆå§‹å…‰å¼ºåˆ†å¸ƒè¿›è¡ŒäºŒç»´å‚…é‡Œå¶å˜æ¢\n\ntemp2=\nexp\n(ikD*(\n1\n-lamd^\n2\n/\n2\n*(fx.^\n2\n+fy.^\n2\n))); \n% è®¡ç®—å¹³é¢æ³¢å‰ä¼ æ’­çš„ç›¸ä½è°ƒåˆ¶å› å­\n\nU2=ifft2(temp1.temp2); \n% å¯¹ç›¸ä½è°ƒåˆ¶åçš„å…‰å¼ºåˆ†å¸ƒè¿›è¡ŒäºŒç»´å‚…é‡Œå¶é€†å˜æ¢ï¼Œå¾—åˆ°é€šè¿‡é€é•œåçš„å…‰å¼ºåˆ†å¸ƒ\n\npha2=\nangle\n(U2); \n% å¯¹é€šè¿‡é€é•œåçš„å…‰å¼ºåˆ†å¸ƒæ±‚ç›¸ä½ï¼Œå¾—åˆ°ç›¸ä½åˆ†å¸ƒ\n\nA2=\nabs\n(U2); \n% å¯¹é€šè¿‡é€é•œåçš„å…‰å¼ºåˆ†å¸ƒæ±‚å¹…å€¼ï¼Œå¾—åˆ°å¹…å€¼åˆ†å¸ƒ\n\nI2=\nabs\n(U2).^\n2\n; \n% å¯¹é€šè¿‡é€é•œåçš„å…‰å¼ºåˆ†å¸ƒæ±‚å¼ºåº¦ï¼Œå¾—åˆ°å¼ºåº¦åˆ†å¸ƒ\n\nErr(M)=sum(sum((I2-J2.^\n2\n ).^\n2\n)); \n% è®¡ç®—è¾“å‡ºå…‰å¼ºä¸ç›®æ ‡å…‰å¼ºä¹‹é—´çš„è¯¯å·®\n\neta(M)=sum(sum(I2.JJ))/sum(sum(I2)); \n% è®¡ç®—è¾“å‡ºå…‰å¼ºä¸ç›®æ ‡å…‰å¼ºä¹‹é—´çš„ç›¸ä¼¼åº¦\n\nsubplot(\n221\n);plotyy(\n1\n:M,Err,\n1\n:M,eta) \n% ç»˜åˆ¶è¯¯å·®å’Œç›¸ä¼¼åº¦çš„å˜åŒ–æ›²çº¿\n\ntitle(\n'Err (left) and eta (right)'\n);xlabel(\n'M'\n);\nsubplot(\n222\n);imagesc(x11,y11,J2);axis square;title(\n'Object function'\n)\nxlabel(\n'x / mm'\n);ylabel(\n'y / mm'\n);zlabel(\n'Amplitude'\n) \n% ç»˜åˆ¶ç›®æ ‡å…‰å¼ºåˆ†å¸ƒçš„å›¾åƒ\n\nsubplot(\n223\n);imagesc(x11,y11,A2);axis square;title(\n'Output function'\n)\nxlabel(\n'x / mm'\n);ylabel(\n'y / mm'\n);zlabel(\n'Amplitude'\n) \n% ç»˜åˆ¶é€é•œåçš„å…‰å¼ºåˆ†å¸ƒçš„å›¾åƒ\n\n\n%%%%%%%%\n\nU2=J2.\nexp\n(ipha2); \n% å°†é€šè¿‡é€é•œåçš„å…‰å¼ºåˆ†å¸ƒçš„ç›¸ä½åˆ†å¸ƒä¸ç›®æ ‡å…‰å¼ºåˆ†å¸ƒç›¸ä¹˜ï¼Œå¾—åˆ°ä¸‹ä¸€æ¬¡è¿­ä»£çš„åˆå§‹å…‰å¼ºåˆ†å¸ƒ\n\ntmep3=fft2(U2); \n% å¯¹ä¸‹ä¸€æ¬¡è¿­ä»£çš„åˆå§‹å…‰å¼ºåˆ†å¸ƒè¿›è¡ŒäºŒç»´å‚…é‡Œå¶å˜æ¢\n\ntemp4=\nexp\n(-ikD*(\n1\n-lamd^\n2\n/\n2\n*(fx.^\n2\n+fy.^\n2\n))); \n% è®¡ç®—å¹³é¢æ³¢åä¼ æ’­çš„ç›¸ä½è°ƒåˆ¶å› å­\n\nU11=ifft2(tmep3.*temp4); \n% åˆ©ç”¨å‚…é‡Œå¶å˜æ¢å°†åˆå§‹å…‰å¼ºåˆ†å¸ƒä¸ç›¸ä½è°ƒåˆ¶å› å­ç›¸ä¹˜å¾—åˆ°é€šè¿‡å…‰é˜‘åçš„å…‰å¼ºåˆ†å¸ƒï¼Œç„¶åå†è¿›è¡Œå‚…é‡Œå¶åå˜æ¢å¾—åˆ°ä¸‹ä¸€æ¬¡è¿­ä»£çš„å…‰å¼ºåˆ†å¸ƒ\n\nsubplot(\n224\n);imagesc(x11,y11,pha0);axis square; title(\n'phase of DOE xlabel('\nx / mm');ylabel(\n'y / mm'\n) \n%ç»˜å›¾\n\npause(\n0.01\n)\n\nend\n\n\n\n\n", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "package yh_juzhen;import java.util.Scanner;\n/*ç¼–å†™ä¸€ä¸ªJavaç¨‹åºï¼Œå®ç°çŸ©é˜µç±»ï¼Œè‡³å°‘åŒ…å«ä¸‰ä¸ªå±æ€§ï¼šè¡Œæ•°ï¼Œåˆ—æ•°ï¼Œå­˜å‚¨æ•°æ®çš„äºŒç»´æ•°ç»„ï¼›è‡³å°‘ä¸¤ä¸ªæ„é€ å‡½æ•°ï¼Œå®ç°çŸ©é˜µçš„æ•°ä¹˜ï¼ŒåŠ æ³•ï¼Œå‡æ³•ä»¥åŠä¸¤ä¸ªçŸ©é˜µçš„ä¹˜æ³•ã€‚*/\npublic class juzhen {        \nprivate int row;        \nprivate int col;        \nint data[][];        \n//  ä¸‰ä¸ªå±æ€§    å…¶ä¸­dataç”¨äºå­˜å‚¨äºŒç»´æ•°ç»„                \n\n//ä¸‰ä¸ªæ„é€ å‡½æ•°        \npublic juzhen() {        //æ— å‚æ„é€ å‡½æ•°  ç©ºçš„ä»¥ä¾¿ä»¥åä½¿ç”¨    \n    }        \n    public juzhen(int row, int col) {            \n    // æ ¹æ®ç”¨æˆ·è¾“å…¥æ„é€ çŸ©é˜µ å³æ„é€ è¡Œåˆ—çš„        \n    }        \n    public juzhen(int data[][]) {// æ ¹æ®ä¼ å…¥çš„äºŒç»´æ•°ç»„æ„å»ºçŸ©é˜µ                         \n    this.row = data.length;\n    //rowçš„å€¼ä¸ºä¼ è¿‡æ¥çŸ©é˜µçš„è¡Œæ•°            \n    this.col = data[0].length;            \n    this.data = new int[row][col];        \n    for (int i = 0; i < this.row; i++)//forå¾ªç¯èµ‹å€¼ç»™date              \n    for (int j = 0; j < this.col; j++) {                    \n    this.data[i][j] = data[i][j];                \n    }        \n    }                        \n\n//æ‰“å°æ•°æ®   è¾“å‡ºå‡½æ•°        \npublic void print() {//è¾“å‡ºä¼ è¿‡æ¥çš„çŸ©é˜µ           \n for (int i = 0; i < this.row; i++) {                \n  for (int j = 0; j < this.col; j++) {                    \n  System.out.print(\" \" + this.data[i][j]);                \n  }                \n  System.out.println();//ä¸€è¡Œä¹‹åå›è½¦        \n      }        \n      }                        \n\n//get set æ–¹æ³•  è·å–çŸ©é˜µå±æ€§è¡Œæ•°åˆ—æ•°\n        public int getRow() {\n            return row;\n        }\n\n        public void setRow(int row) {\n            this.row = row;\n        }\n\n        public int getCol() {\n            return col;\n        }\n\n        public void setCol(int col) {\n            this.col = col;\n        }\n\n        public int[][] getData() {\n            return data;\n        }\n\n        public void setData(int[][] data) {\n            this.data = data;\n        }\n\n//åˆ©ç”¨å‡½æ•°  è·å–ç¬¬iè¡Œjåˆ—çš„å…ƒç´ \n        public int get(int i, int j) {\n            return this.data[i][j];//ä»ç”¨thisè·å–è¿™ä¸ªçŸ©é˜µçš„æ•°æ®\n        }\n\n//çŸ©é˜µåŠ æ³•  c[i][j]= a[i][j]+b[i][j]        \npublic static juzhen add(juzhen a, juzhen b) {\n// çŸ©é˜µåŠ æ³•    ç»“æœè¿”å›ç»™çŸ©é˜µc   ä¼ è¿‡æ¥å¯¹è±¡çš„åŠ æ³•            \njuzhen c = null;//å…ˆç»™çŸ©é˜µcè®¾ä¸ºç©º            \nif (a.getRow() != b.getRow() || a.getCol() != b.getCol()) {\n//çŸ©é˜µa bä¸åŒè¡Œæˆ–ä¸åŒåˆ—   ä¸”åˆ©ç”¨get set å‡½æ•°                \nSystem.out.println(\"ä¸æ˜¯åŒå‹çŸ©é˜µï¼Œä¸èƒ½ç›¸åŠ \");                return c;            \n}            \nint[][] data = new int[a.getRow()][a.getCol()];\n//ä»ç”¨åŸæ¥çš„æ„é€ å‡½æ•°ç”¨data  å¹¶ç»™å®ƒåˆ†é…å¤§å°            \nfor (int i = 0; i < a.getRow(); i++)//åšå¾ªç¯ è¿›è¡Œç›¸åŠ                 \nfor (int j = 0; j < a.getCol(); j++) {                \n    data[i][j] = a.get(i, j) + b.get(i, j);                    \n    /*ä¸ç”¨data[i][j] = a.data[i][j] + b.data[i][j]                     å› ä¸ºä¸ºç§æœ‰  è¦è·å–iè¡Œjåˆ—çš„å…ƒç´ çš„æ•°æ®  åˆ›å»ºå‡½æ•°get(int i,int j)*/                \n    }            \n    c = new juzhen(data);//å°†dataç»™çŸ©é˜µc            return c;        \n    }\n\n//çŸ©é˜µå‡æ³• c[i][j]= a[i][j]-b[i][j]\n        public static juzhen subtract(juzhen a, juzhen b) {// çŸ©é˜µåŠ æ³•    ç»“æœè¿”å›ç»™çŸ©é˜µe   ä¼ è¿‡æ¥å¯¹è±¡çš„å‡æ³•\n            juzhen e = null;//å…ˆç»™çŸ©é˜µeè®¾ä¸ºç©º\n            if (a.getRow() != b.getRow() || a.getCol() != b.getCol()) {//çŸ©é˜µa bä¸åŒè¡Œæˆ–ä¸åŒåˆ—   ä¸”åˆ©ç”¨get set å‡½æ•°\n                System.out.println(\"ä¸æ˜¯åŒå‹çŸ©é˜µï¼Œä¸èƒ½ç›¸åŠ \");\n                return e;\n            }\n    int[][] data = new int[a.getRow()][a.getCol()];//ä»ç”¨åŸæ¥çš„æ„é€ å‡½æ•° ç”¨data  å¹¶ç»™å®ƒåˆ†é…å¤§å°\n            for (int i = 0; i < a.getRow(); i++)//åšå¾ªç¯ è¿›è¡Œç›¸åŠ \n                for (int j = 0; j < a.getCol(); j++) {\n                    data[i][j] = a.get(i, j) - b.get(i, j);\n                }\n            e = new juzhen(data);//å°†dataç»™çŸ©é˜µe\n            return e;\n        }\n\n\n//çŸ©é˜µçš„æ•°ä¹˜   c[i][j]= a[i][j]*h\n        public static juzhen shucheng(juzhen a, int h) {\n            juzhen f = null;//å…ˆç»™çŸ©é˜µfè®¾ä¸ºç©º\n            int[][] data = new int[a.getRow()][a.getCol()];//ä»ç”¨åŸæ¥çš„æ„é€ å‡½æ•° ç”¨data  å¹¶ç»™å®ƒåˆ†é…å¤§å°\n            for (int i = 0; i < a.getRow(); i++)//åšå¾ªç¯ è¿›è¡Œç›¸åŠ \n                for (int j = 0; j < a.getCol(); j++) {\n                    data[i][j] = a.get(i, j) *h;\n                }\n            f = new juzhen(data);//å°†dataç»™çŸ©é˜µf\n            return f;\n        }\n\n//çŸ©é˜µä¹˜æ³•  \n        public static juzhen multiply(juzhen a, juzhen b) {//ä¼ è¿‡æ¥å¯¹è±¡\n            juzhen d=null;//å…ˆè®¾çŸ©é˜µdä¸ºç©º\n            if(a.getCol() !=b.getRow())//åˆ¤æ˜¯å¦å¯ä»¥ç›¸ä¹˜\n            {\n                System.out.println(\"çŸ©é˜µä¸èƒ½ç›¸ä¹˜\");\n                return d;\n            }\n            int [][]data = new int [a.getRow()][b.getCol()];//ç»™dataåˆ†é…ç©ºé—´  açš„è¡Œæ•° bçš„åˆ—æ•°  dataæš‚å­˜æ•°æ®\n            for (int i =0 ;i< a.getRow();i++)\n                for(int j = 0; j< b.getCol();j++)\n                    for(int k =0; k < a.getCol();k++)\n                    {\n                        data[i][j]=data[i][j]+a.get(i, k)*b.get(k, j);//çŸ©é˜µä¹˜æ³•è¿ç®—\n                    }\n        \n           d= new juzhen(data);//å°†çŸ©é˜µç»™d\n            return d;//è¿”å›çŸ©é˜µd    \n        }\n    }\n\nclass test {\n    public static void main(String[] args) {\n\n        int a[][] = { { 1, 2, 3 }, { 2, 3, 4 }, { 2, 1, 3 } };\n        juzhen ma = new juzhen(a);//å°†çŸ©é˜µaä¼ è¿‡å»\n        System.out.println(\"çŸ©é˜µaä¸ºï¼š\");\n        ma.print();//è¾“å‡ºçŸ©é˜µa\n        System.out.println(\"\\n\");//å›è½¦è¿›è¡Œéš”å¼€\n        int b[][]=  { { 1, 2, 3 }, { 2, 3, 4 }, { 2, 1, 3 } };\n        juzhen mb = new juzhen(b);\n        System.out.println(\"çŸ©é˜µbä¸ºï¼š\");\n        mb.print();    \n        System.out.println(\"\\n\");\n\n//è¾“å…¥hçš„å€¼  è¿›è¡Œæ•°ä¹˜è¿ç®—\n        Scanner input = new Scanner(System.in);    \n        System.out.println(\"è¯·è¾“å…¥hçš„å€¼ï¼š\");    \n        int h = input.nextInt();  \n        System.out.println(\"\\n\");\n        \n        System.out.println(\"çŸ©é˜µaä¸æ•°hç›¸ä¹˜ç»“æœä¸ºï¼š\");\n        juzhen mf = juzhen.shucheng(ma, h);\n        mf.print();\n        System.out.println(\"\\n\");\n        \n        System.out.println(\"çŸ©é˜µbä¸æ•°hç›¸ä¹˜ç»“æœä¸ºï¼š\");\n        juzhen mg = juzhen.shucheng(mb, h);\n        mf.print();\n        System.out.println(\"\\n\");\n\njuzhen mc =juzhen.add(ma, mb);\n        System.out.println(\"çŸ©é˜µç›¸åŠ ç»“æœä¸ºï¼š\");\n        mc.print();//è¾“å‡ºmc\n        System.out.println(\"\\n\");\n        \n        System.out.println(\"çŸ©é˜µç›¸å‡ç»“æœä¸ºï¼š\");\n        juzhen me = juzhen.subtract(ma, mb);\n        me.print();\n        System.out.println(\"\\n\");\n        \n        System.out.println(\"çŸ©é˜µç›¸ä¹˜ç»“æœä¸ºï¼š\");\n        juzhen md = juzhen.multiply(ma, mb);\n        md.print();\n    }\n}\n\n\n", "Konwledge_Point": "çŸ©é˜µä¹˜æ³•", "Question": "å…³äº#Java#çš„é—®é¢˜ï¼Œå¦‚ä½•è§£å†³ï¼Ÿ\nç¼–å†™ä¸€ä¸ªJavaç¨‹åºï¼Œå®ç°çŸ©é˜µç±»ï¼Œè‡³å°‘åŒ…å«ä¸‰ä¸ªå±æ€§ï¼šè¡Œæ•°ï¼Œåˆ—æ•°ï¼Œå­˜å‚¨æ•°æ®çš„äºŒç»´æ•°ç»„ï¼›è‡³å°‘ä¸¤ä¸ªæ„é€ å‡½æ•°ï¼Œå®ç°çŸ©é˜µçš„æ•°ä¹˜ï¼ŒåŠ æ³•ï¼Œå‡æ³•ä»¥åŠä¸¤ä¸ªçŸ©é˜µçš„ä¹˜æ³•ã€‚", "Tag": "ç®—æ³•åˆ†æ"}
