{"Answer": "设置一个变量，保存最优解，在得到解的过程中设置判断， 一旦比最优解更差，则停止计算，继续下一组，如果计算出比之前的解更优，则把最优解改成当前的解，然后继续循环", "Konwledge_Point": "智能穷举搜索", "Question": "穷举法最优解的比较方式\n穷举法的最优解的得到方式\n我是采用生成可能所得结果的全排列并存储。最终调用再一个一个比较。\n如何修改成在得到排列的过程中比较，即生成一个解就与前一个比较，直至到最终求得最优解。", "Tag": "算法分析"}
{"Answer": "#include<stdio.h>\nint main() {\n    int m,n,i,j,k,s;\n    scanf(\"%d %d\",&m,&n);\n    s=n-m; \n    for(i=0;i<=s;i++){//做对2题的人有i个 \n        for(j=0;j<=s/2;j++){//做对3题的人有j个 \n            for(k=0;k<=s/3;k++){//做对3题的人有k个 \n                if(i+2*j+3*k==s){\n                    printf(\"%d %d %d\\n\",i,j,k);\n                }    \n            }    \n        }\n    }\n    return 0;\n}\n\n\n觉得有用的话采纳一下哈", "Konwledge_Point": "智能穷举搜索", "Question": "穷举算法问题，求助大佬\n计算导论与程序设计某次上机考试共出了4道题，其中每名同学都至少做对了一道题。根据已知条件求做对了2、3、4题的可能的人数。。\n输入格式:\n只有一行，为两个用空格分隔的正整数m和n，分别代表参加考试的总人数和总的解题数。\n输出格式:\n有若干行，每一行为一组解，格式均为用空格分隔的三个整数，依次代表解2题的人数，解3题的人数和解4题的人数。多组解的输出顺序按解2题人数由小到大排序，如果解2题的人数相同则按解3题的人数由小到大排序。所有测试数据保证可以用int存储。\n输入样例:\n15 20\n输出样例:\n0 1 1\n1 2 0\n2 0 1\n3 1 0\n5 0 0", "Tag": "算法分析"}
{"Answer": "1.题目说的很明白。就是汉字和数字游戏，先说一下人怎么思考：\n       范邓韩王\n+    范邓李王 \n  李王韩范王\n比如两个加数个位是王+王，最终的和个位也还是王，那说明王是0,因为只有0+0才等于0\n       范邓韩0\n+    范邓李0 \n   李0韩范0\n题目就变成这样了。\n比如李是进了一位，两个数相加只可能进1，所以李是1\n       范邓韩0\n+    范邓1  0 \n      10韩范0\n千位：范+范= 10，可以退出范为5，因为如果百位有进位的话，两个相同的数结果为偶数加上进位不可能是10所以百位没有进位，百位没有进位的话，千位两个一样的数相加为10就只能是5+5\n       5邓韩0\n+    5邓1 0 \n     10韩50\n十位，韩+1=5所以韩是4,  邓+邓=韩，韩是4，邓是2\n       5240\n+    521 0 \n     10450\n2.编程解决的话，最简单的就是多级循环。用穷举的办法试出结果。\n邓、王、范、韩、李分别从0-9循环，\n当这五个数都不相等，并且 （1000*范+100*邓+10*韩+王） + （1000*范+100*邓+10*李+王）等于（10000 * 李 + 1000*王+100*韩+10*范+王）时。\n就可以得出结果。\n希望对你有帮助。", "Konwledge_Point": "智能穷举搜索", "Question": "c++穷举法的一个题目，题干在👇\n题目：\n\n\n\n奔跑吧兄弟成员：邓超、王祖蓝、范冰冰、韩庚、李晨的加法如下：\n\n\n\n范邓韩王\n\n\n\n+\n 范邓李王 \n\n\n\n李王韩范王\n\n\n\n其中邓、王、范、韩、李均为1位数字（0-9），编写程序求邓、王、范、韩、李的取值。\n\n\n\n我的程序：\n\n\n\n\n\n\n出现错误：输出答案是这样：\n\n\n\n邓=0\n\n\n\n王=0\n\n\n\n范=0\n\n\n\n韩=1\n\n\n\n李=0\n\n\n\n邓=0\n\n\n\n王=0\n\n\n\n范=0\n\n\n\n韩=2\n\n\n\n李=0\n\n\n\n邓=0\n\n\n\n王=0\n\n\n\n范=0\n\n\n\n韩=3\n\n\n\n李=0\n\n\n\n邓=0\n\n\n\n王=0\n\n\n\n范=0\n\n\n\n韩=4\n\n\n\n李=0\n\n\n\n邓=0\n\n\n\n王=0\n\n\n\n范=0\n\n\n\n韩=5\n\n\n\n李=0\n\n\n\n邓=0\n\n\n\n王=0\n\n\n\n范=0\n\n\n\n韩=6\n\n\n\n李=0\n\n\n\n邓=0\n\n\n\n王=0\n\n\n\n范=0\n\n\n\n韩=7\n\n\n\n李=0\n\n\n\n邓=0\n\n\n\n王=0\n\n\n\n范=0\n\n\n\n韩=8\n\n\n\n李=0\n\n\n\n邓=0\n\n\n\n王=0\n\n\n\n范=0\n\n\n\n韩=9\n\n\n\n李=0\n\n\n\nProgram ended with exit code: 0\n\n\n\n可以帮我改一下程序，告诉我错误在哪里么，谢谢各位", "Tag": "算法分析"}
{"Answer": "修改了3个地方：\r\n 1.  数组改成static，这样才能保存每次递归出来产生的数\r\n 2.  在递归函数中，让m++，否则无法结束递归\r\n 3.  调整了下边界，让最终输出结果是5位以内的二进制。\r\n代码如下：\r\n\r\nint n;\r\nvoid f(int m)\r\n{\r\n    int i = 0;\r\n    static int a[20];\r\n    m++;\r\n    if(m == n)\r\n    {\r\n        for(i = 1; i < n; i++)\r\n        {\r\n            printf(\"%d\",a[i]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n    else\r\n    {\r\n        a[m] = 0;\r\n        f(m);\r\n        a[m] = 1;\r\n        f(m);\r\n    }\r\n}\r\nint main(void)\r\n{\r\n    int m = 0;\r\n    // scanf(\"%d\",&n);\r\n    n = 5 + 1;\r\n    f(m);\r\n    return 0;\r\n}", "Konwledge_Point": "智能穷举搜索", "Question": "我要穷举m位的二进制数，但是出错了，调试时候也没发现问题~~望指教\nenter code here\n\n\n\n\ninclude \n\n\n\nint n;\n\n\n\nvoid  f(int m)\n\n{\n\n    int i = 0;\n\n    int a[20];\n\n    if(m==n)\n\n    {\n\n        for(i = 0; i < n; i++)\n\n        {\n\n            printf(\"%d\",a[i]);\n\n        }\n\n        printf(\"\\n\");\n\n    }\n\n    else\n\n    {\n\n        a[m] = 0;\n\n        f(m);\n\n        a[m] = 1;\n\n        f(m);\n\n    }\n\n}\n\n\n\nint main(void)\n\n{\n\n    int m = 0;\n\n//  scanf(\"%d\",&n);\n\n    n = 5;\n\n    f(m);\n\n    return 0;\n\n}", "Tag": "算法分析"}
{"Answer": "这个问题的详细论述，请参考这个文章\nhttps://mp.weixin.qq.com/s?__biz=MzIzODAxNjE1OQ==&mid=2247484908&idx=1&sn=f65249db53819e13e51facf833fca6a0&chksm=e93e861cde490f0a92cdceb4aedb529acb5a54f3fa5f20974c5be0cc576edc9c2b64b5a5ad4a&token=1187079490&lang=zh_CN#rd", "Konwledge_Point": "智能穷举搜索", "Question": "鸡兔同笼穷举法哪错了\n#include\"stdio.h\" \n\nint main()\n\n{\n\nint a,b,c,d;\n\nscanf(\"%d%d\",&a,&b);\n\nfor(c=0;c<=a;c++)\n\n{\n\nfor(d=0;d<=a;d++)\n\n    {\n\n    if(c*2+d*4==b&&c+d==a)    \n\n{\n\n    printf(\"%d%d\",c,d);\n\n}\n\nelse\n\n{\n\nprintf(\"error\");    \n\n}\n\n        \n\n    }    \n\n    \n\n}    \n\n    return 0;\n\n}", "Tag": "算法分析"}
{"Answer": "有一个数i, 从2开始到sqrt(i)挨个跟i取模%，也就是求余数，余数为0，说明能被整除，i不是质数。", "Konwledge_Point": "智能穷举搜索", "Question": "请问穷举法找质数的算法思路是什么样的\n", "Tag": "算法分析"}
{"Answer": "假设1元，2元，5元硬币分别为a,b,c个\r\n\r\n```\r\n求满足约束条件\r\na + b + c = n            (1)         \r\n的情况下，\r\na + 2*b + 5*c = m    (2)\r\n解的个数。\r\n```\r\n直接用(1) - (2), 得到公式(3)\r\n\r\n\r\n```\r\n b + 4c = m-n        (3)\r\n a被消去了，因为\r\n 0 <= a <= n\r\n 所以约束条件变为,\r\n 0 <= b + c <= n\r\n```\r\n\r\n最终就变成了求\r\nb+4c = m - n\r\n有多少组整数解的问题\r\n\r\n\r\n```\r\nint resolve(int n, int m) {\r\n\tint b = 0, c = 0;\r\n\tint temp = m - n;\r\n\tint sum = 0;\r\n\t  \r\n\tif ((temp % 4) > n) return 0;\r\n\t\r\n\tfor (int c = (temp/4); c >= 0; --c) {\r\n\t\tb = temp - (c * 4);\r\n\t\tif (b + c <= n)\r\n\t\t\tsum += 1;\r\n\t\telse\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\treturn sum;\r\n\r\n}\r\n \r\n```\r\n\r\n思路大概这样，代码随手写得...", "Konwledge_Point": "智能穷举搜索", "Question": "acm 里硬币问题 具体题目见下，采用穷举法时间超限，请问怎么修改\n主页  讨论版   问题  名次  状态  统计\n\n问题 L: 还是硬币问题\n\n时间限制: 1 Sec  内存限制: 128 MB\n\n提交: 183  解决: 30\n\n状态\n\n题目描述\n\n给你无限多个1元的硬币和2元的硬币，还有5元的硬币。\n\n\n\n现在要你从这3种硬币中取n个硬币，使得他们的价值和为m\n\n\n\n输入\n\n多组输入\n\n\n\n每组n ， m \n\n\n\nn < 1e6 , m <1e6 \n\n\n\n输出\n\n总的方案数目\n\n\n\n样例输入\n\n2 3\n\n样例输出\n\n1\n\n\n\n#include\n\nint main()\n\n{\n\n    int n,m;\n\n    int x,y,z,i,k,j;\n\n    i=0;\n\n    while(scanf(\"%d%d\",&n,&m)!=EOF)\n\n    {\n\n        for(x=0; x<=n; x++)\n\n        {\n\n            for(y=0; y<=n-x; y++)\n\n            {\n\n                for(z=0; z<=n-x-y; z++)\n\n                {\n\n                    if((x+y+z==n)&&(x+2*y+5*z==m))\n\n                    {\n\n                        i++;\n\n                    }\n\n\n\n            }\n        }\n    }\n    printf(\"%d\\n\",i);\n}\nreturn 0;\n\n\n\n\n}", "Tag": "算法分析"}
{"Answer": "\n用while：\n```c\n#include<stdio.h>\nint main(){\n    int a=1,b=1,c=1,i=0;\n    while (a<=33){\n       b=  0;\n        while(b<=50){\n            c = 0;\n            while(c<=100){\n                if(3*a+2*b+0.5*c==100&&a+b+c==100){\n                   i++;\n                }\n               c++;\n            }\n            b++;\n        }\n        a++;\n    }\n    printf(\"%d\",i);\n    return 0;\n}\n\n", "Konwledge_Point": "智能穷举搜索", "Question": "c语言while穷举法\nc语言穷举法，100 匹马驮 100 担货，大马一匹驮了担，中马一匹驮2担，小马两匹驮一担。有多少种方法？\n用三个for嵌套可以做，用while的话为什么我这么写不行呢？\n用for：\n\n\n\n```c\n\n#include\n\n\nint main(){\n    int a,b,c,d,\ni\n=0;\n    \nfor\n(\na\n=1;a<=33;a++){\n        \nfor\n(\nb\n=1;b<=50;b++){\n            \nfor\n(\nc\n=1;c<=200;c++){\n                \nif\n(3\n*a\n+2\n*b\n+0.5\n*c\n==100&&a+b+\nc\n==100){\n                    i++;\n                }\n            }\n        }\n    }\nprintf(\n\"%d\"\n,i);\n\nreturn 0;\n\n}\n\n\n\n\n\n用\nwhile\n：\n\n```c\n\n#\ninclude\n\n\n\nint\n \nmain\n()\n{\n    \nint\n a=\n1\n,b=\n1\n,c=\n1\n,i=\n0\n;\n    \nwhile\n (a<=\n33\n){\n        \nwhile\n(b<=\n50\n){\n            \nwhile\n(c<=\n100\n){\n                \nif\n(\n3\n*a+\n2\n*b+\n0.5\n*c==\n100\n&&a+b+c==\n100\n){\n                   i++;\n                }\n               c++;\n            }\n            b++;\n        }\n        a++;\n    }\n    \nprintf\n(\n\"%d\"\n,i);\n    \nreturn\n \n0\n;\n}\n\n\n", "Tag": "算法分析"}
{"Answer": "import itertools as it \n\ns = map(int, input(\">>>\").split(\",\"))\ns = set(s)\nif len(s) < 3:\n    print(\"不足三位数！\")\nelse:\n    res = it.permutations(s, 3)    \n    res = [''.join(map(str, i)) for i in res if i[0] != 0]\n    res.sort()\n    print(' '.join(map(str, res)))\n    print(f\"共{len(res)}个\")\n\n", "Konwledge_Point": "智能穷举搜索", "Question": "关于python 特殊的穷举三位数\n请问像这样的题目，数字由用户输入，怎么实现穷举三位数呢 请问详细的代码是什么呢\n谢谢解答", "Tag": "算法分析"}
{"Answer": "你可以用 ArrayList，不用考虑长度，用add动态添加，最后一次性\r\nfor (int i = al.length - 1; i >= 0; i--)  逆序遍历 a;[i];\r\n单个数字转换内存不足有点夸张了，你的数字能有多大？100位？1000位？宇宙中的所有原子的个数应该也没有10的1000次方。", "Konwledge_Point": "智能穷举搜索", "Question": "如何解决数组的空间不足的问题\n\n\n在一个进制转换的问题上卡了很久，十六进制转八进制，我是想先将十六进制转换成十进制，再将十进制转换成八进制。十六进制转十进制我可以很好实现，就是将字符串逐一取出求出权值就行。问题在十进制转八进制上。因为在数学上，\n\n\n十进制转八进制就是该数求余再倒序，问题就出在这。\n\n\n为实现将数倒序，我得先将数放在数组里，再将数组进行逆向输出。可是数组是创建时就初始化好空间大小的，当所转换的数非常大时数组都无法满足时就错了，想请问是否有更好的方法解决？或者当数组的使用遇到空间上的问题是有没有什么好的处置方法？求教~~~\n\n\n以下献上十六进制转八进制代码（请大家对我的代码多多指正，初学者比较生疏，谢谢~）：\n\n\n\n//多次运算十六进制转八进制\nimport java.util.*;\npublic class BASIC_12_3_3 {\n    public static void main(String args[]){\n        int n,tag=0;\n        long sum=0,b,tmp=1,k,c; \n        String H[] = new String[11];\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        for(int i=0;i < n;i++){\n            H[i] = sc.next();\n        }\n        for(int z=0;z < n;z++){\n            int i = 0;\n            //十六进制转成十进制\n            for(int j=H[z].length()-1;j >= 0;j--){\n                b = H[z].charAt(j);\n                if(b>='0' && b<='9'){\n                    b = (b - '0') * tmp;\n                    sum = sum + b;\n                    tmp = tmp * 16;\n                }\n                else if(b>='A' && b<='F'){\n                    b = (b - 'A' + 10) * tmp;\n                    sum = sum + b;\n                    tmp = tmp * 16;\n                }\n            }\n            //此处得出该数的十进制sum，以下是十进制转八进制\n            if(sum>=0 && sum<8){\n                System.out.print(sum);\n            }\n            else if(sum >= 8){\n                k = sum;\n                long list[] = new long[20];//此处用数组进行逆序输出，但容易出现数据溢出\n                while(k != 0){\n                    c = k % 8;\n                    list[i] = c;\n                    k = k / 8;\n                    i ++;\n                }\n                if(k == 0){\n                    list[i] = k;\n                }\n                //以上数制转换完毕，以下是进行逆向输出\n                for(int j=list.length - 1;j >= 0;j--){\n                    if(list[j] == 0){\n\n                    }else if(list[j] != 0){\n                        tag = 1;\n                    }\n                    if(tag == 1){\n                        System.out.print(list[j]);\n                    }\n                }\n                System.out.println();\n            }\n            sum = 0;//sum置零!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n            tag = 0;\n            tmp = 1;\n        }\n    }\n}\n\n", "Tag": "算法分析"}
{"Answer": "就是把A、B、C、D说的话当成一个逻辑表达式，然后判断四个表达式中只有一个是FALSE的情况", "Konwledge_Point": "智能穷举搜索", "Question": "关于穷举法的应用，如何按课件中得方法解决问题\n\n\n如何用课件中这种穷举的方法完成这个问题？", "Tag": "算法分析"}
{"Answer": "# 问题解决的话，请点下`采纳`，谢谢\r\n```\r\n// Q1051673.cpp : Defines the entry point for the console application.\r\n//\r\n\r\n#include \"stdafx.h\"\r\n\r\n\r\n#include \r\n#include \r\n\r\nvoid solve(int * seed, int nseed, int * cand, int ncand, int target)\r\n{\r\n\tif (target == 0)\r\n\t{\r\n\t\tfor (int i = 0; i < nseed; i++)\r\n\t\t{\r\n\t\t\tprintf(\"%d \", seed[i]);\r\n\t\t}\r\n\t\tprintf(\"\\n\");\r\n\t\treturn;\r\n\t}\r\n\tfor (int i = 0; i < ncand; i++)\r\n\t{\r\n\t\tif (target >= cand[i] && cand[i] <= seed[nseed - 1])\r\n\t\t{\r\n\t\t\tint * seed1 = new int[nseed + 1];\r\n\t\t\tmemcpy(seed1, seed, nseed * sizeof(int));\r\n\t\t\tseed1[nseed] = cand[i];\r\n\t\t\tsolve(seed1, nseed + 1, cand, ncand, target - cand[i]);\r\n\t\t\tdelete[] seed1;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nint main()\r\n{\r\n\tint cand[4] = { 10, 5, 2, 1 };\r\n\tint target = 25; //钱数\r\n\tfor (int i = 0; i < 4; i++)\r\n\t{\r\n\t\tint * seed = new int[1];\r\n\t\tseed[0] = cand[i];\r\n\t\tsolve(seed, 1, cand, 4, target - seed[0]);\r\n\t\tdelete[] seed;\r\n\t}\r\n}\r\n```\r\n10 10 5\r\n10 10 2 2 1\r\n10 10 2 1 1 1\r\n10 10 1 1 1 1 1\r\n10 5 5 5\r\n10 5 5 2 2 1\r\n10 5 5 2 1 1 1\r\n10 5 5 1 1 1 1 1\r\n10 5 2 2 2 2 2\r\n10 5 2 2 2 2 1 1\r\n10 5 2 2 2 1 1 1 1\r\n10 5 2 2 1 1 1 1 1 1\r\n10 5 2 1 1 1 1 1 1 1 1\r\n10 5 1 1 1 1 1 1 1 1 1 1\r\n10 2 2 2 2 2 2 2 1\r\n10 2 2 2 2 2 2 1 1 1\r\n10 2 2 2 2 2 1 1 1 1 1\r\n10 2 2 2 2 1 1 1 1 1 1 1\r\n10 2 2 2 1 1 1 1 1 1 1 1 1\r\n10 2 2 1 1 1 1 1 1 1 1 1 1 1\r\n10 2 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n10 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n5 5 5 5 5\r\n5 5 5 5 2 2 1\r\n5 5 5 5 2 1 1 1\r\n5 5 5 5 1 1 1 1 1\r\n5 5 5 2 2 2 2 2\r\n5 5 5 2 2 2 2 1 1\r\n5 5 5 2 2 2 1 1 1 1\r\n5 5 5 2 2 1 1 1 1 1 1\r\n5 5 5 2 1 1 1 1 1 1 1 1\r\n5 5 5 1 1 1 1 1 1 1 1 1 1\r\n5 5 2 2 2 2 2 2 2 1\r\n5 5 2 2 2 2 2 2 1 1 1\r\n5 5 2 2 2 2 2 1 1 1 1 1\r\n5 5 2 2 2 2 1 1 1 1 1 1 1\r\n5 5 2 2 2 1 1 1 1 1 1 1 1 1\r\n5 5 2 2 1 1 1 1 1 1 1 1 1 1 1\r\n5 5 2 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n5 5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n5 2 2 2 2 2 2 2 2 2 2\r\n5 2 2 2 2 2 2 2 2 2 1 1\r\n5 2 2 2 2 2 2 2 2 1 1 1 1\r\n5 2 2 2 2 2 2 2 1 1 1 1 1 1\r\n5 2 2 2 2 2 2 1 1 1 1 1 1 1 1\r\n5 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1\r\n5 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1\r\n5 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n5 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n5 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n2 2 2 2 2 2 2 2 2 2 2 2 1\r\n2 2 2 2 2 2 2 2 2 2 2 1 1 1\r\n2 2 2 2 2 2 2 2 2 2 1 1 1 1 1\r\n2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1\r\n2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1\r\n2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1\r\n2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\nPress any key to continue . . .", "Konwledge_Point": "智能穷举搜索", "Question": "新手c语言编程穷举问题\n有四种面值不一样的货币分别是10元，5元，2元，1元。现在给你一个钱数你能求求它的组成方法都有多少吗？\n\n\n\n运行时间尽可能短", "Tag": "算法分析"}
{"Answer": "\nScanner input = new Scanner(System.in);\nint i = input.nextInt();\nboolean flag = false;\nfor (int a=0;a<9;a++){\n    for(int b=0;b<8;b++){\n        int ab = a*10+b;\n        int ba = b*10+a;\n        if(ab*ba==i){\n            System.out.println(\"a===\"+a);\n            System.out.println(\"b===\"+b);\n            flag = true;\n            break;\n        }\n    }\n}\nif(!flag){\n    System.out.println(\"No Answer\");\n}\n用Java写的  把Scanner input = new Scanner(System.in); int i = input.nextInt();换成scanf输入\nSystem.out.println（）换成print输出就行 算法是正确的 试过", "Konwledge_Point": "智能穷举搜索", "Question": "c语言迭代穷举问题。\n输入三位数字N，求两位数AB（其中个位数字为B，十位数字为A，且有0 < A < B ≤9）。使得下列等式成立：\n\n AB x BA = N\n\n其中BA是把AB中个、十位数字交换所得的两位数。\n\n \n\n编写程序，接收控制台输入的三位整数N，求解A，B并输出。\n\n如果没有解则输出“No Answer”。求大佬jie'da", "Tag": "算法分析"}
{"Answer": "dfs暴搜一下就行，其实剪完枝复杂度不是很大(最深只有10层)，加上输出c++也只要不到10s。\n/*----------------------------------*/\n/* Author : KaMtuo                  */\n/* Email : kamtuo@qq.com            */\n/* Creation_time : 2022-08-08 20:06 */\n/* Software : Visual Studio Code    */\n/*----------------------------------*/\n\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#include <vector>\n#include <map>\n\n#define endl \"\\n\"\n\nusing std::cin;\nusing std::cout;\nusing std::max;\nusing std::min;\nusing std::sort;\nusing std::queue;\nusing std::priority_queue;\nusing std::vector;\nusing std::map;\nusing std::string;\n\nconst int N = 30;\nconst int target_num = 500;\n\nint cnt;\nvector<int> in;\n\nvoid dfs(int now, int sum, int to) {\n    if (sum == target_num && to == 10) {\n        cnt ++;\n        for (int i = 0; i < in.size(); i ++) cout << in[i] << ' ';\n        cout << endl;\n    }\n    if (sum >= target_num || to >= 10) return;\n    for (int i = now; i <= 73; i ++) {\n        in.push_back(i);\n        dfs(i, sum + i, to + 1);\n        in.pop_back();\n    }\n}\n\nint main() {\n    freopen(\"all.txt\", \"w\", stdout);\n    dfs(44, 0, 0);\n    cout << cnt << endl;\n    return 0;\n}\n\n总共177376种，以下是部分方案", "Konwledge_Point": "智能穷举搜索", "Question": "如何穷举符合条件的数组？求算法\n从44、45、46...72、73共有29个数字，每次取10个数，每个数字可以重复取，要求这10个数的和为500，共有多少种情况？\n\n\n比如：50取出10次就是500算符合情况。44和54各取出5次也算符合的情况，以下这些都算：\n50    50    50    50    50    50    50    50    50    50\n44    54    44    54    44    54    44    54    44    54\n44    44    44    44    44    54    54    54    54    54\n47    47    48    48    49    49    51    52    52    57\n45    46    47    48    48    49    53    54    55    55\n47    47    47    48    49    49    51    53    54    55\n其他还有那些符合条件的情况？请穷举出来。", "Tag": "算法分析"}
{"Answer": "sum = sum1 * 1 + sum3 * 3;", "Konwledge_Point": "智能穷举搜索", "Question": "为什么我这样用穷举法不对\n我的思路应该很好看出来，就是穷举，如果卡片1和卡片3能组成总精美程度的一半，那就可以平分，可是我输入2和1后居然输出yes就不知道哪有问题\n问题\n\n\n\n\n我的代码\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\nint\n \nmain\n(\nvoid\n)\n\n\n{\n    \nint\n sum1;\n    \nint\n sum3;\n    \nint\n half;\n    \nint\n sum;\n    \nint\n i;\n    \nint\n x;\n    \nscanf\n(\n\"%d %d\"\n,&sum1, &sum3);\n\n    sum = sum1*\n1\n + sum*\n3\n;\n    \nif\n(sum%\n2\n == \n1\n)\n    {\n        \nprintf\n(\n\"No\"\n);\n        \nexit\n(\n0\n);\n    }\n    half = sum/\n2\n;\n    \nfor\n(i=\n0\n; i<=sum1; i++){\n        \nfor\n(x=\n0\n; x<=sum3; x++){\n            \nif\n(i*\n1\n+x*\n3\n==half)\n            {\n                \nprintf\n(\n\"Yes\"\n);\n                \nexit\n(\n0\n);\n            }\n\n\n        }\n\n\n\n    }\n    \nprintf\n(\n\"No\"\n);\n\nreturn\n \n0\n;\n}\n\n", "Tag": "算法分析"}
{"Answer": "\ndef get_pwd(str, num):\n    if(num == 1):\n        for x in str:\n            yield x\n    else:\n        for x in str:\n            for y in get_pwd(str, num-1):\n                yield x+y\n\nstrKey=\"abcdefghijklmnopqrstuvwxyz0123456789\"\nfor x in get_pwd(strKey,4):\n    print(x)\n\n可以根据给定字典，穷举规定长度所有字符串", "Konwledge_Point": "智能穷举搜索", "Question": "如何用Python穷举出四位的数字与小写字母组合\n 我想要做一个密码的暴力破解，想要输出所有的四位的数字与小写字母组合，请问用Python该怎么写呢？", "Tag": "算法分析"}
{"Answer": "\n\n```python\nimport math\n\ncity = {'x': [87, 91, 83, 71, 64, 68], 'y': [7, 38, 46, 44, 60, 58]}\nn = 6\nx = city['x']\ny = city['y']\nimport numpy as np\n\n# 计算距离\na = np.zeros((n, n))\nfor i in range(6):\n    for j in range(6):\n        a[i, j] = math.sqrt(pow(x[i] - x[j], 2) + pow(y[i] - y[j], 2))\n# 生成6个城市的全部排列\nimport itertools\n\nv = list(itertools.permutations([1, 2, 3, 4, 5, 6], n))\n# 计算最短总距离\nm = len(v)\njuli = []\nmin_sum = \"inf\"  # ==========================================================初始化min_sum为正无穷\nfor i in range(m):\n    sum = 0\n    \n    for j in range(n - 1):\n        sum = sum + a[v[i][j] - 1, v[i][j + 1] - 1]\n        sum = sum + a[v[i][j + 1] - 1, v[i][0] - 1]\n        \"\"\"\n        if sum < min_sum:\n            min_sum = sun =========================================== 在计算出结果后，前一个结果和后一个结果直接比较\n        \"\"\"\n    juli.append(sum)\nprint('最小距离：', min(juli))\nzuiyou = min(juli)   # ==========================================这行可以注释\nc = juli.index(min(juli))\nprint('最短路径：', v[c])\n# 原问题采用先生成全部可能结果的排列，存下来，在比较的方法；\n# 如何修改为不依赖存储的排列结果，换句话说，一个一个比较，算一个，比较一个的方法呢？\n\n\n\n```", "Konwledge_Point": "智能穷举搜索", "Question": "穷举法的结果比较方法\n#输入6个城市坐标，字典形式\ncity={'x':[87,91,83,71,64,68],'y':[7,38,46,44,60,58]}\nn=6\nx=city['x']\ny=city['y']\nimport numpy as np\n#计算距离\na=np.zeros((n,n))\nfor i in range(6):\n    for j in range(6):\n        a[i,j] = math.sqrt(pow(x[i]-x[j],2)+pow(y[i]-y[j],2))\n#生成6个城市的全部排列\nimport itertools\nv=list(itertools.permutations([1,2,3,4,5,6],n))\n#计算最短总距离\nm=len(v)\njuli=[]\nfor i in range(m):\n    sum=0\n    for j in range(n-1):\n        sum=sum+a[v[i][j]-1,v[i][j+1]-1]\n    sum=sum+a[v[i][j+1]-1,v[i][0]-1]\n    juli.append(sum)\nprint('最小距离：',min(juli))\nzuiyou=min(juli)\nc=juli.index(min(juli))\nprint('最短路径：',v[c])\n我是先生成全排列之后再把全排列存起来，然后再一个一个比较的；\n能否修改成不依赖存储的排列结果，换句话说，一个一个比较，算一个，比较一个的方法呢？", "Tag": "算法分析"}
{"Answer": " 将输入数据放于\"read.txt\"文件中，编译运行程序即可。\n\n#include<stdio.h>\n\nint main(void){\n\tFILE *fp=NULL;\n\tchar c[200000],x;\n\tint i=0,n=0,j=0;\n\t\n\tfp=fopen(\"read.txt\",\"r\"); //读取txt文件数据 \n\twhile((x=fgetc(fp))!=EOF){\n\t\tc[i]=x;\n\t\ti++;\n\t}\n\tn=i;\n\tc[n]='\\0';\n\tfclose(fp);\n\t\n\tchar f[20]=\"write00.txt\";\n\tfor(i=1;i<=26;i++){\n\t\tif(f[6]=='9'){  //将输出文件从01至26排序 \n\t\t\tf[6]='0';\n\t\t\tf[5]++;\n\t\t}\n\t\telse\n\t\t\tf[6]++;\n\t\n\t\tfor(j=0;j<n;j++){  //进行暴力破解，一次将所有字母往后移动一位 \n\t\t\tif(c[j]>='a'&&c[j]<'z')\n\t\t\t\tc[j]+=1;\n\t\t\telse if(c[j]=='z')\n\t\t\t\tc[j]='a';\n\t\t\tif(c[j]>='A'&&c[j]<'Z')\n\t\t\t\tc[j]+=1;\n\t\t\telse if(c[j]=='Z')\n\t\t\t\tc[j]='A';\n\t\t}\n\t\t\n\t\tfp=fopen(f,\"w\");//输出文件 \n\t\tfputs(c,fp);\n\t\tfclose(fp);\n\t}\n\treturn 0;\n}\n ", "Konwledge_Point": "智能穷举搜索", "Question": "如何用C语言实现凯撒密码对文本文件(.txt)的读取穷举暴力破解？\n用C语言实现对文本文件中凯撒密码穷举破解 并把26次结果 输出为二十六个文本文件（.txt）", "Tag": "算法分析"}
{"Answer": "#include<stdio.h>\nint main() {\n    int a,b,t,f;\n    scanf(\"%d%d\",&a,&b);\n    //1、先判断a,b大小，若a>b,交换a和b；\n    if(a>b){\n        t=a;\n        a=b;\n        b=t;\n    } \n    //2、for循环遍历从a到b的每一个整数\n    for(int i=a;i<=b;i++){\n        f=1;//f=1表示假设i是素数 \n        //3、若该整数是素数，则输出。\n        for(int j=2;j<i;j++){\n            if(i%j==0){//i%j==0表示i有除了1和它本身的因子 \n                f=0; //假设不成立 ，i不是素数 \n                break;\n            }\n        }\n        //如果i未被改为0，表示假设成立，即i是素数 \n        if(f) printf(\"%d \",i);\n    }\n    return 0;\n}\n", "Konwledge_Point": "智能穷举搜索", "Question": "C语言-8-穷举法C++\n#include  \nint main()\n{\n    Begin\n     End\nreturn0;\n}\n任务描述\n本关任务：从键盘读入两个大于5的正整数，打印出这两个数之间（包含这两个数）的所有素数，一行打印5个。\n编程要求\n输出格式用 %4d\n注意：输入的第一个数有可能比第二个数大。\n测试说明\n平台会对你编写的代码进行测试：\n测试输入：\n100 200\n预期输出：\n101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199\n测试输入：\n100 20\n预期输出：\n23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97", "Tag": "算法分析"}
{"Answer": "判断式有很多种写法：\n>>> for i in range(1,300):\n    if i%3==0 and i%5==0 and i%7==0:\n        print(i)\n\n        \n105\n210\n>>> for i in range(1,300):\n    if all([i%3==0,i%5==0,i%7==0]):\n        print(i)\n\n        \n105\n210\n>>> for i in range(1,300):\n    if all([not i%3,not i%5, not i%7]):\n        print(i)\n\n        \n105\n210\n>>> for i in range(1,300):\n    if not any([i%3,i%5,i%7]):\n        print(i)\n\n        \n105\n210\n>>> for i in range(1,300):\n    if not i%(3*5*7):\n        print(i)\n\n        \n105\n210\n>>> \n\n最后一种方法有前提：三个数都是质数，且互质\n如有帮助，请采纳。谢谢!", "Konwledge_Point": "智能穷举搜索", "Question": "一个小数学的穷举问题\n找出1到300以内所有能同时被3，5，7整除的正整数。要求每行打印一个数", "Tag": "算法分析"}
{"Answer": "傻一点的办法就是穷举了，把8位数都遍历一遍。分解出8位数字，判断是否符合条件。题目的时间限制是多长？\n#include<stdio.h>\n#include <math.h>\nvoid int2arr(int n,int *a)\n{\n    int i = 7;\n    while(n>0)\n    {\n        a[i--] = n%10;\n        n/=10;\n    }\n}\n\nint isprime(int n)\n{\n    if(n<2)\n        return 0;\n    int k = sqrt(n*1.0);\n    for(int i=2;i<=k;i++)\n        if(n%2==0)\n            return 0;\n    return 1;\n}\n\nint main()\n{ \n    /*有7个人在一起玩猜电话号码的游戏。\n这是一个8位的电话号码。\n甲说，这个数字的千万位数字比百万位数字大。\n乙说，这个数字的百位数字与十位数字相同。\n丙说，这个数字的百万位、十万位、万位数字相乘的结果与百位、十位、个位数字相乘的结果相同，并且这个乘积不为0。\n丁说，把这个数字的十万位、万位、千位、百位数字看作一个四位数，这个四位数是一个非负整数的平方。\n戊说，把这个数字的千万位、千位、个位数字相加，和是一个质数。\n己说，把这个数字的所有数位相加，和是10的整数倍。\n你是庚，请列出所有满足条件的8位数字。*/\n    for(int i=10000000;i<=99999999;i++)\n    {\n        int a[8];\n        int2arr(i,a);\n        if(a[0] <= a[1])\n            continue;\n        if(a[5] != a[6])\n            continue;\n        if(a[1]*a[2]*a[3] == 0 || a[1]*a[2]*a[3] != a[5]*a[6]*a[7])\n            continue;\n        int k = a[2]*1000 + a[3]*100 + a[4]*10 + a[5];\n        int p = sqrt(k*1.0);\n        if(fabs(p*p-k*1.0) > 0.00001)\n            continue;\n        if(!isprime(a[0]+a[4] + a[7]))\n            continue;\n        int sum = 0;\n        for(int j=0;j<8;j++)\n            sum += a[j];\n        if(sum %10 != 0)\n            continue;\n        printf(\"%d\\n\",i);\n    }\n    return  0;\n\n}\n\n", "Konwledge_Point": "智能穷举搜索", "Question": "C语言用穷举循环判断实现猜字游戏\n问题遇到的现象和发生背景\n\n\n有7个人在一起玩猜电话号码的游戏。\n这是一个8位的电话号码。\n甲说，这个数字的千万位数字比百万位数字大。\n乙说，这个数字的百位数字与十位数字相同。\n丙说，这个数字的百万位、十万位、万位数字相乘的结果与百位、十位、个位数字相乘的结果相同，并且这个乘积不为0。\n丁说，把这个数字的十万位、万位、千位、百位数字看作一个四位数，这个四位数是一个非负整数的平方。\n戊说，把这个数字的千万位、千位、个位数字相加，和是一个质数。\n己说，把这个数字的所有数位相加，和是10的整数倍。\n你是庚，请列出所有满足条件的8位数字。\n\n\n用代码块功能插入代码，请勿粘贴截图\n\n\n我的解答思路和尝试过的方法\n\n\n用循环和判断\n\n\n我想要达到的结果\n\n\n庚：53846446\n甲：5>3\n乙：4=4\n丙：3\n8\n4=4\n4\n6\n丁：8464=92*92\n戊：5+6+6=17\n己：5+3+8+4+6+4+4+6=40", "Tag": "算法分析"}
{"Answer": "你有结果就在循环里输出，没结果才在循环外输出无结果", "Konwledge_Point": "智能穷举搜索", "Question": "鸡兔同笼问题为什么我输出的数都是我输入的头数，输出数不正确怎么办\n\n", "Tag": "算法分析"}
{"Answer": "曲线拟合也是一种最优化算法，有成熟的数值优化算法，如trust-region-reflective'和 'levenberg-marquardt，这些成熟的算法在python中实现，要想自己写出程序，首先需要理解算法。", "Konwledge_Point": "智能穷举搜索", "Question": "请问python curve_fit函数的搜索原理是什么呢，为什么它可以迅速搜索出最优解呢\n请问python curve_fit函数的搜索原理是什么呢，为什么它可以迅速搜索出最优解呢，而我自己手写最小二乘法暴力穷举最优解确需要搜索很久", "Tag": "算法分析"}
{"Answer": "\nscanf(\"%d %d\", &head, &feet);\n", "Konwledge_Point": "智能穷举搜索", "Question": "鸡兔同笼C++，想用穷举法但失败了，SOS\n最普通的鸡兔同笼，但我想用穷举法来做，结果为什么没有输出勒？，求大家指点。\n#include\nint main()\n{\n    int chicken,rabbit;\n    int head,feet;\n    printf(\"请输入头数和脚数：\");\n    scanf(\"%d %d\",head,feet);\n    for (chicken=0;chicken<=head;chicken++)\n    {\n        for (rabbit=0;rabbit<=head;rabbit++)\n        {\n            if (rabbit+chicken==head && rabbit\n4+chicken\n2==feet)\n                {\n                printf(\"%d %d\",chicken,rabbit);\n                return 0;}\n            else\n                {\n                printf(\"Worry!\");\n                return 0;\n            }\n    }\n    }\n    return 0;\n}", "Tag": "算法分析"}
{"Answer": "ab至少有一个参与，那应该是a或b==1你为什么用a*b，那ab都是0也成立呀", "Konwledge_Point": "智能穷举搜索", "Question": "c语言循环用穷举查作案嫌疑人\n\n\n请问为什么我if里面的条件是不对的，问题出在哪里呢？这里运行的结果不对，应该是最后AC那个条件写错了，但是不知道错哪里了，是小白菜鸡\n\n", "Tag": "算法分析"}
{"Answer": "http://blog.csdn.net/haut_ykc/article/details/52154202", "Konwledge_Point": "智能穷举搜索", "Question": "Euclid's Game               \nProblem Description\n\nTwo players, Stan and Ollie, play, starting with two natural numbers. Stan, the first player, subtracts any positive multiple of the lesser of the two numbers from the greater of the two numbers, provided that the resulting number must be nonnegative. Then Ollie, the second player, does the same with the two resulting numbers, then Stan, etc., alternately, until one player is able to subtract a multiple of the lesser number from the greater to reach 0, and thereby wins. For example, the players may start with (25,7): \n\n\n\n25 7\n\n11 7\n\n4 7\n\n4 3\n\n1 3\n\n1 0 \n\n\n\nan Stan wins. \n\n\n\nInput\n\nThe input consists of a number of lines. Each line contains two positive integers giving the starting two numbers of the game. Stan always starts.\n\n\n\nOutput\n\nFor each line of input, output one line saying either Stan wins or Ollie wins assuming that both of them play perfectly. The last line of input contains two zeroes and should not be processed. \n\n\n\nSample Input\n\n34 12\n\n15 24\n\n0 0\n\n\n\nSample Output\n\nStan wins\n\nOllie wins", "Tag": "算法分析"}
{"Answer": "参考地址：\n一个自然数的七进制表达式是一个三位数，而这个自然数的九进制表示也是一个三位数，且这两个三位数的数码顺序正好相反，求这个三位数。_RViewSonic的博客-CSDN博客\n这又是一个数字问题的代码化,首先解释里面的几个概念并用数学的方法将这个三位数推导出来.数码:数的基本单元,也就是数字.例如123和321二者分别含有三个数码,且数码顺序相反。进制:可看作是特殊进制转换为默认进制(10进制)时的底数。数学推导:由上述数学推导过程可知,函数体内的判断条件即是七进制和九进制化为十进制时二者相等,而这需要在所有符合七进制(七和九取并集)的三位数内进行筛选,而七进制遇七进一的特点就是突破口.\tfor(i=1;i<7;i++)\tfor(j=0;j<7;j++)\n\n\n\nhttps://blog.csdn.net/RViewSonic/article/details/107127807\n\n\n#include<stdio.h>\nint main()\n{\n    int i,j,k;\n    for(i=1;i<7;i++)\n    for(j=0;j<7;j++)\n    for(k=1;k<7;k++)\n    if(i+j*7+k*7*7==i*9*9+j*9+k)\n    {\n        printf(\"%d\\n\",i*9*9+j*9+k);\n    }\n } \n\n", "Konwledge_Point": "智能穷举搜索", "Question": "大一C语言课，7进制9进制的三位数，求解\n大一学生c语言课\n不明白10进制和9进制和7进制的关系，求解\n怎么写程序才能判断他是7或者9进制的三位数啊", "Tag": "算法分析"}
{"Answer": "import java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\n\r\n\r\npublic class Coin {\r\n\r\n    public static int getNums(int n){\r\n   \r\n        List list = new ArrayList();\r\n        \r\n        for(int i=0;i<1000;i++){\r\n            for(int j=0; j < 1000; j++) {\r\n                for(int z=0; z < 1000; z++) {\r\n                    if(25*i+10*j+z==n){\r\n                        list.add(i+j+z);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        Collections.sort(list);\r\n        return list.get(0);\r\n    }\r\n    \r\n    public static void main(String[] args) {\r\n       int a = getNums(34);\r\n       System.out.println(\"--->\" + a);\r\n    }\r\n}\r\njava版穷举法", "Konwledge_Point": "智能穷举搜索", "Question": "用Python写这个作业，谢谢\nPart I ( points)\n\n\n\n“找硬币问题”：设有3种硬币，面值分别为25分，10分和1分。编写程序，输入n（分钱），用穷举法或者回溯法求解，求最少需要找多少个硬币。", "Tag": "算法分析"}
{"Answer": "\npublic static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        System.out.println(\"鸡兔同笼：请输入头和脚数量：\");\n        int h = in.nextInt();\n        int f = in.nextInt();\n        int chicken=0,rabbit = 0;\n        for(;chicken<=h;chicken++){\n            rabbit = h-chicken;\n            if((chicken*2)+(rabbit*4) == f){\n                System.out.println(String.format(\"鸡：%d,兔：%d\",chicken,rabbit));\n                return;\n            }\n        }\n        System.out.println(\"没有解\");\n    }\n\n", "Konwledge_Point": "智能穷举搜索", "Question": "鸡兔同笼问题 （穷举法)\n已知 鸡兔共35只 共94支脚  那么鸡兔各几只?！～-=.：$……～%\n@＼* \n            ", "Tag": "算法分析"}
{"Answer": "温馨提醒：如果我的回答对你有帮助，请点击旁边的采纳按钮，谢谢\n（1）子序列：一个序列X ＝ x1x2...xn,中任意删除若干项，剩余的序列叫做A的一个子序列。也可以认为是从序列A按原顺序保留任意若干项得到的序列。      例如：对序列 1,3,5,4,2,6,8,7来说，序列3,4,8,7 是它的一个子序列。对于一个长度为n的序列，它一共有2^n 个子序列，有(2^n – 1)个非空子序列。在这里需要提醒大家，子序列不是子集，它和原始序列的元素顺序是相关的。\n（2）公共子序列：如果序列Z既是序列X的子序列，同时也是序列Y的子序列，则称它为序列X和序列Y的公共子序列。空序列是任何两个序列的公共子序列。\n\n （3）最长公共子序列：X和Y的公共子序列中长度最长的（包含元素最多的）叫做X和Y的最长公共子序列。\n\n  这个问题如果用穷举法时间，最终求出最长公共子序列时，时间复杂度是Ο（2mn），是指数级别的复杂度，对于长序列是不适用的。因此我们使用动态规划法来求解。\n\n刻画最长公共子序列问题的最优子结构      设X=x1x2…xm和Y=y1y2…yn是两个序列，Z=z1z2…zk是这两个序列的一个最长公共子序列。\n  1.      如果xm=yn，那么zk=xm=yn，且Zk-1是Xm-1，Yn-1的一个最长公共子序列；\n\n  2.      如果xm≠yn，那么zk≠xm，意味着Z是Xm-1，Y的一个最长公共子序列；\n\n  3.      如果xm≠yn，那么zk≠yn，意味着Z是X，Yn-1的一个最长公共子序列。\n\n  从上面三种情况可以看出，两个序列的LCS包含两个序列的前缀的LCS。因此，LCS问题具有最优子结构特征。\n\n递归的定义最优值      从最优子结构可以看出，如果xm=yn，那么我们应该求解Xm-1，Yn-1的一个LCS，并且将xm=yn加入到这个LCS的末尾，这样得到的一个新的LCS就是所求。\n  如果xm≠yn，我们需要求解两个子问题，分别求Xm-1，Y的一个LCS和X，Yn-1的一个LCS。两个LCS中较长者就是X和Y的一个LCS。\n\n  可以看出LCS问题具有重叠子问题性质。为了求X和Y的一个LCS，我们需要分别求出Xm-1，Y的一个LCS和X，Yn-1的一个LCS，这几个字问题又包含了求出Xm-1，Yn-1的一个LCS的子子问题。（有点绕了。。。晕没晕。。。。）\n\n   根据上面的分析，我们可以得出下面的公式；\n\n\n所以：S1和S2的LCS就等于：{S1减去最后一个元素}与S2的LCS， {S2减去最后一个元素}与S1的 LCS 中的最大的那个序列", "Konwledge_Point": "智能穷举搜索", "Question": "最长公共子序列求解DP\n题目\n 字符序列的子序列是指从给定字符序列中随意地（不一定连续）去掉若干个字符（可能一个也不去掉）后所形成的字符序列。令给定的字符序列X和Y，使得对所有的\nj\n=\n0\n,\n1\n,\n⋯\n \n,\nk\n−\n1\nj=0,1,⋯,k−1 ，有\nx\ni\nj\n=\ny\nj\nx\nij\n​\n =y\nj\n​\n  。例如，\nX\n=\n\"ABCBDAB\"\nX=\"ABCBDAB\" ，\nY\n=\n\"BCDB\"\nY=\"BCDB\" 是 X 的一个子序列。对给定的两个字符序列，求出他们最长的公共子序列长度，以及最长公共子序列个数。X 的一个子序列。对给定的两个字符序列，求出他们最长的公共子序列长度，以及最长公共子序列个数。\n##**这道题的解析里面假如S1的最后一个元素与S2的最后一个元素相等，那么S1和S2的LCS就等于{S1减去最 后一个元素}与{S2减去最后一个元素} 的LCS再加上S1和S2相等的最后一个元素（如下图）\n\n\nS1 A B C B D A B S2 B D C A B A\n\n\n假如S1的最后一个元素与S2的最后一个元素不等（本例子就是属于这种情况），那么 S1和S2的LCS就等于：{S1减去最后一个元素}与S2的LCS， {S2减去最后一个元素}与S1的 LCS 中的最大的那个序列。**请问啥意思啊？", "Tag": "算法分析"}
{"Answer": "\nimport math\n\ncity = {'x': [87, 91, 83, 71, 64, 68], 'y': [7, 38, 46, 44, 60, 58]}\nn = 6\nx = city['x']\ny = city['y']\nimport numpy as np\n\n# 计算距离\na = np.zeros((n, n))\nfor i in range(6):\n    for j in range(6):\n        a[i, j] = math.sqrt(pow(x[i] - x[j], 2) + pow(y[i] - y[j], 2))\n# 生成6个城市的全部排列\nimport itertools\n\nv = list(itertools.permutations([1, 2, 3, 4, 5, 6], n))\n# 计算最短总距离\nm = len(v)\njuli = []\nmin_sum = \"inf\"  # ==========================================================初始化min_sum为正无穷\nfor i in range(m):\n    sum = 0\n    \n    for j in range(n - 1):\n        sum = sum + a[v[i][j] - 1, v[i][j + 1] - 1]\n        sum = sum + a[v[i][j + 1] - 1, v[i][0] - 1]\n        \"\"\"\n        if sum < min_sum:\n            min_sum = sun =========================================== 在计算出结果后，前一个结果和后一个结果直接比较\n        \"\"\"\n    juli.append(sum)\nprint('最小距离：', min(juli))\nzuiyou = min(juli)   # ==========================================这行可以注释\nc = juli.index(min(juli))\nprint('最短路径：', v[c])\n# 原问题采用先生成全部可能结果的排列，存下来，在比较的方法；\n# 如何修改为不依赖存储的排列结果，换句话说，一个一个比较，算一个，比较一个的方法呢？\n\n", "Konwledge_Point": "智能穷举搜索", "Question": "穷举法的排列比较，比较方式的改变\n#从其中的某一城市出发，不重复地走完其余5个并回到原出发点，在所有可能的路径中求出路径长度最短的一条。\n\n\n六个市坐标为：1(87,7).2(91,38)、3(83,46).4(71,44).5(64,60)、6(68,58)\n\n\nimport math\ncity={'x':[87,91,83,71,64,68],'y':[7,38,46,44,60,58]}\nn=6\nx=city['x']\ny=city['y']\nimport numpy as np\n#计算距离\na=np.zeros((n,n))\nfor i in range(6):\n    for j in range(6):\n        a[i,j] = math.sqrt(pow(x[i]-x[j],2)+pow(y[i]-y[j],2))\n#生成6个城市的全部排列\nimport itertools\nv=list(itertools.permutations([1,2,3,4,5,6],n))\n#计算最短总距离\nm=len(v)\njuli=[]\nfor i in range(m):\n    sum=0\n    for j in range(n-1):\n        sum=sum+a[v[i][j]-1,v[i][j+1]-1]\n    sum=sum+a[v[i][j+1]-1,v[i][0]-1]\n    juli.append(sum)\nprint('最小距离：',min(juli))\nzuiyou=min(juli)\nc=juli.index(min(juli))\nprint('最短路径：',v[c])\n原问题采用先生成全部可能结果的排列，存下来，在比较的方法；\n如何修改为不依赖存储的排列结果，换句话说，一个一个比较，算一个，比较一个的方法呢？", "Tag": "算法分析"}
{"Answer": "可以尝试用itertools这个模块进行迭代，这个模块里面有很多创建迭代器的函数。\n给一个思路：\n第一组的元素个数最多可能有8个，取值范围为1-10。\n当第一个组为1个元素的时候，第二组的元素个数最多可能为8个；\n当第一个组为2个元素的时候，第二组的元素个数最多可能为7个；\n以此类推，当第一个组为i个元素的时候，第二组的元素个数最可能为9-i，取值范围为1-10，并减去第一组的元素，剩余记为rem。\n第三组的元素则为rem减去第二组中的元素。\nitertools.combinations可以对一个集合的元素按照个数进行不同的组合，例如，从1-10中任取2个数字，可能有以下组合。\n\nimport itertools\nL1 = itertools.combinations(range(1,11), 2)\nprint(list(L1))\n\n[(1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9), (1, 10), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7), (2, 8), (2, 9), (2, 10), (3, 4), (3, 5), (3, 6), (3, 7), (3, 8), (3, 9), (3, 10), (4, 5), (4, 6), (4, 7), (4, 8), (4, 9), (4, 10), (5, 6), (5, 7), (5, 8), (5, 9), (5, 10), (6, 7), (6, 8), (6, 9), (6, 10), (7, 8), (7, 9), (7, 10), (8, 9), (8, 10), (9, 10)]\n所以，可以按照如下方式写代码：\n\nimport itertools\n\ncount=0\n\nset_all=set(range(1,11))\n\nfor i in range(1,9):\n    for L1 in itertools.combinations(range(1,11), i):\n        rem=set_all-set(L1)\n        for j in range(1,10-i):\n            for L2 in itertools.combinations(rem, j):\n                L3=rem-set(L2)\n                count+=1\n                print(count,end=' ')\n                print(set(L1),set(L2),L3)\n ", "Konwledge_Point": "智能穷举搜索", "Question": "python 穷举10个人划分到三个组的所有组合\n我想10个人划分到3个组（A,B,C）中，也就是每个人都有三种选择，所以一共有3**10=59049种，想最终得出来的结果是\n\n\n\nA=[1],B=[2],C=[3，4，5，6，7,8，9，10]\n\n\n\nA=[1],B=[3],C=[2，4，5，6，7,8，9，10]\n\n\n\nA=[1],B=[4],C=[2，3，5，6，7,8，9，10]\n\n\n\n························································\n\n\n\nA=[3，4，5，6，7,8，9，10],B=[2], C=[1]", "Tag": "算法分析"}
{"Answer": "供参考：\n#include <stdio.h>\nint main()\n{\n    int i, k, t, s;\n    scanf(\"%d\", &i);\n    if(i >= 1 && i <= 10000)\n    {\n        t = i; k = i * i; s = 1;\n        while (t) { s *= 10; t /= 10; }\n        if ((k % s) == i)\n            printf(\"Yes\");\n        else\n            printf(\"No\");\n    }\n    else\n        printf(\"%d out of range\",i);\n    return 0;\n}\n\n", "Konwledge_Point": "智能穷举搜索", "Question": "同构数的问题，可以用穷举法写写么\n所谓“同构数”是指这样的数，它出现在它的平方数的右边，例如5的平方数是25, 25的平方数是625，所以5和25都是同构数。你的任务是判断整数x是否是同构数。若是同构数，输出“Yes”，否则输出“No”。x的取值范围是(1<=x<=10000),如果输入的x不在允许范围内，则输出错误提示信息“x out of range”。\n输入格式:\n只有一个整数。测试用例保证所有输入可以用int存储。\n输出格式:\n只有一行，为判断结果。\n输入样例:\n20000\n输出样例:\n20000 out of range\n\n\n\n\n```\n\n\n\n\n\n\n\n```", "Tag": "算法分析"}
{"Answer": "https://www.cnblogs.com/handsomecui/p/5233812.html", "Konwledge_Point": "智能穷举搜索", "Question": "Necklace of Beads这个除了用穷举还有更好的算法么\nProblem Description\n\nBeads of red, blue or green colors are connected together into a circular necklace of n beads ( n < 40 ). If the repetitions that are produced by rotation around the center of the circular necklace or reflection to the axis of symmetry are all neglected, how many different forms of the necklace are there? \n\n\n\n\n\n\nInput\n\nThe input has several lines, and each line contains the input data n. \n\n-1 denotes the end of the input file. \n\n\n\nOutput\n\nThe output should contain the output data: Number of different forms, in each line correspondent to the input data.\n\n\n\nSample Input\n\n4\n\n5\n\n-1\n\n\n\nSample Output\n\n21\n\n39", "Tag": "算法分析"}
{"Answer": "增加去重步骤，答案是10种：\ncolor=['red','orange','yellow','green','blue']\nres = []\nfor i in range(0,5):\n    for j in range(0,5):\n        for m in range(0,5):\n            a=color[i]\n            b=color[j]\n            c=color[m]\n            if a!=b and b!=c and a!=c:\n                res.append([a,b,c])\n\ncount = []\nfor i in range(len(res)):\n    res[i]=sorted(res[i])\nfor i in res:\n    if i not in count:\n        count.append(i)\nprint(len(count))\n", "Konwledge_Point": "智能穷举搜索", "Question": "python用穷举法时怎么才能不考虑顺序对最后结果的影响啊\n这个是题目要求：\n一个看不见的袋子中装有若干红、橙、黄、绿、蓝五种颜色的小球，每次随意摸出三个小球，输出三个小球颜色都不一样的所有可能的方案总数。\n【提示】不计算取求顺序的区别，例如红橙黄与黄橙红为一个方案。\n这是我写的代码：\n\n\ncolor=[\n'red'\n,\n'orange'\n,\n'yellow'\n,\n'green'\n,\n'blue'\n]\n\nn\n=0\n\nfor\n i \nin\n range(0,5):\n    \nfor\n j \nin\n range(0,5):\n        \nfor\n m \nin\n range(0,5):\n            \na\n=color[i]\n            \nb\n=color[j]\n            \nc\n=color[m]\n            \nif\n a!=b \nand\n b!=c \nand\n a!=c:\n                n+=1\n\nprint\n(n)\n\n\n\n但是这样求的话就考虑了顺序，所以要怎么改啊", "Tag": "算法分析"}
{"Answer": "最近在学Python，就做了一下", "Konwledge_Point": "智能穷举搜索", "Question": "使用穷举法将0.1.2.3输出全部互不相同且无重复数字的三位数\n请问怎么样才能使用python实现这个程序?", "Tag": "算法分析"}
{"Answer": "Directory.GetFiles\r\nhttps://msdn.microsoft.com/zh-cn/library/wz42302f.aspx\r\n\r\n\r\n\r\n\r\n```\r\n Imports System\r\nImports System.IO\r\n\r\nPublic Class Test\r\n    Public Shared Sub Main()\r\n        Try\r\n            ' Only get files that begin with the letter \"c.\"\r\n            Dim dirs As String() = Directory.GetFiles(\"c:\\\", \"c*\") '列出C:\\下c开头的文件，你需要稍微修改，你的路径，列出所有文件是*.*\r\n            Console.WriteLine(\"The number of files starting with c is {0}.\", dirs.Length)\r\n            Dim dir As String\r\n            For Each dir In dirs\r\n                Console.WriteLine(dir)\r\n            Next\r\n        Catch e As Exception\r\n            Console.WriteLine(\"The process failed: {0}\", e.ToString())\r\n        End Try\r\n    End Sub\r\nEnd Class\r\n```", "Konwledge_Point": "智能穷举搜索", "Question": "vb.net如何获取指定文件夹内所有文件的名称\n最近vb2005写了个WinCE的程序,需要采集器读取本机指定文件夹内的文件名，并通过文件名处理每个文件里的内容。\n\n请各位高手指点一下，这个问题困扰我好几天了，一直找不到好的解决办法，再次谢过。\n\n比较着急，有此类开发经验的高手指点一二，谢谢。。。", "Tag": "算法分析"}
{"Answer": "#include<stdio.h>\n\nint maxgys(int m,int n)\n{\n    int r = m>n?m:n;\n    while(r)\n    {\n        if(m%r==0 && n%r==0)break;//最大的可以同时整除二者的数，即为最大公约数。\n        r--;\n    } \n    return r;\n}\n\nint main()\n{\n    int  m,n, c;\n    scanf(\"%d%d\", &m, &n);\n    c = maxgys(m, n);\n    printf(\"%d\", c);\n    return 0;\n}\n\n", "Konwledge_Point": "智能穷举搜索", "Question": "求两个数的最大公约数用穷举法怎么写呀，按初学者最好理解的写\n求两个数的最大公约数：\nint maxgys(int m,int n）", "Tag": "算法分析"}
{"Answer": "scanf(\"%d %d\",&m,&n);", "Konwledge_Point": "智能穷举搜索", "Question": "鸡兔同笼问题用穷举法解决，为啥输出不了东西，错在哪里了呀\n", "Tag": "算法分析"}
{"Answer": "牛客网 ，很多题，可以在线编程测试。https://www.nowcoder.com/finalexam", "Konwledge_Point": "智能穷举搜索", "Question": "有没有适合C语言的初学者做的题，在PTA上发的很少，想多做点，穷举，递推，迭代，的算法题\n有没有什么网站，或者题库也行，我只想练练手，马上要考试了，思路不行，总是想不对", "Tag": "算法分析"}
{"Answer": "因为两个队列都是有序的，所以可以记录上次比较的位置，然后下次比较接着往后比较就行例如：我先取 dfmopsyz 中的d ,然后往后遍历abcegikint，d比a大，接着往后取b,d比b大，接着取c，d比c大，接着取e，d比e小，d插在e前面，然后记录下e，此时d应该放的位置找到了；第二次接着取f，现在直接用f和e比，f比e大，取g，f比g小，此时记录下f的位置，g放f前，g应该插哪里也知道了。第三次取m，就是m>h,m>i,m>j,m>K,m>l,m<n，此时记录下n的位置，m在n前，m的位置也找到了以此类推，直到两个队列其中一个遍历完成，剩下一个队列未遍历的直接接在后面就可以；可以搜搜归并排序看看思路", "Konwledge_Point": "智能穷举搜索", "Question": "各位，看看这个排序如何实现，我有穷举法可以求，但是我想要更简单的方法来求这个，支个招。\n这个结果代码怎么实现啊，书没写。各位帮忙看看，帮我想想更简单的方法，一定采纳正确的答案", "Tag": "算法分析"}
{"Answer": "\nfor men in range(16):\n    for women in range(23):\n        child=45-women-men\n        if (men * 3+women * 2+ child * 0.5 == 45):\n            print men, women, child\n\n结果：\nmen=0 women=15 child=30\nmen=3 women=10 child=32\nmen=6 women=5 child=34\nmen=9 women=0 child=36\n由于最多只有45块砖，男人的数量不会超过15人，女人的数量不会超过22人，一旦男人和女人的数量确定下来后，小孩的人数应该是45-男人数-女人数。", "Konwledge_Point": "智能穷举搜索", "Question": "python搬砖问题\n某工地需要搬运砖块，已知男人一人可以搬3块，女人一人可以搬2块，小孩两人可以搬1块。用45个人正好搬45块砖，问有多少种搬法？‪‬‪‬‪‬‪‬‪‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‭‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‭‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‭‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‭‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‭‬‫‬‭‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬\n输出所有可能组合，即男人、女人、小孩的人数（人数可以为0）。", "Tag": "算法分析"}
{"Answer": "\nfor (int a = 0; a <= 168; a++) {\n        if ((float)1 / 8 * a + (float)3 / 4 * (168 - a) == (float)76)\n        {\n            printf(\"a=%d,b=%d\", a, 168 - a);\n            break;\n        }\n    }\n", "Konwledge_Point": "智能穷举搜索", "Question": "穷举法甲、乙两数的和为168，甲数的八分之一与乙数的四分之三的和 为76，求甲、乙两数各是多少？\n甲、乙两数的和为168，甲数的八分之一与乙数的四分之三的和\n为76，求甲、乙两数各是多少？", "Tag": "算法分析"}
{"Answer": "n ** 0.5是求n的二分之一幂，也就是求根号nn//i是整数除法，比如9/2=4.5   9//2=4", "Konwledge_Point": "智能穷举搜索", "Question": "用python去求一个数的所有约数\n为什么这里要n\n0.5? n\n0.5之后不就取不到他本身和他的一半了吗\n然后还有那个d.add(n//i)是什么意思  ", "Tag": "算法分析"}
{"Answer": "三重循环就行了\n#include <stdio.h>\nint main()\n{\n    int n,count=0;\n    int a,b,c;\n    scanf(\"%d\",&n);\n    for(a=0;a<=n/3;a++)\n        for(b=0;b<=n/2;b++)\n            for(c=0;c<=n*2;c++)\n            {\n                if(a+b+c == n && c%2==0 && 3*a+2*b+c/2==n )\n                    count++;\n            }\n    printf(\"%d\\n\",count);\n    return 0;\n}\n\n", "Konwledge_Point": "智能穷举搜索", "Question": "某工地需要搬运砖块，已知男人一人搬3块，女人一人搬2块，小孩两人搬1块。从键盘输入正整数N，用N人正好搬N块，问有多少种搬法？\nC语言\n示例：\n思路：穷举法。与学生植树类似\n输入格式：100\n输出格式：7", "Tag": "算法分析"}
{"Answer": "用subprocess模块就可以不输出在日志中\r\n\r\n到后面使用管道的时候，再使用输出，详细的\r\n\r\n官方文档里说明了：[https://docs.python.org/zh-cn/3/library/subprocess.html](https://docs.python.org/zh-cn/3/library/subprocess.html \"\")\r\n\r\n当然，我的博客也有说明：[https://blog.csdn.net/oSuiYing12/article/details/106192075](https://blog.csdn.net/oSuiYing12/article/details/106192075 \"\")", "Konwledge_Point": "智能穷举搜索", "Question": "如何让os.system结果不输出在日志里?\n最近在搞个调用7z的穷举密码解压的脚本, 但是每次调用os.system(cmd), 日志就会疯狂打印密码错误, 有什么办法吗?", "Tag": "算法分析"}
{"Answer": "二分法：https://blog.csdn.net/weixin_45740510/article/details/121100694模拟：就是按照题目的要求和步骤来写程序贪心：https://blog.csdn.net/weixin_49370884/article/details/126247776穷举：https://blog.csdn.net/qq_44836294/article/details/108246866", "Konwledge_Point": "智能穷举搜索", "Question": "程序设计竞赛中的问题\n二分，模拟，贪心，穷举分别是什么意思，不是很了解，希望大家帮助", "Tag": "算法分析"}
{"Answer": "穷举法就设置几个循环即可，这里有三个变量设置三个循环，不过这个时间可能有点多，需要执行60w次循环体，不满足约束条件的可以直接continue即可", "Konwledge_Point": "智能穷举搜索", "Question": "请问这种问题怎么写代码比较好？\n求目标函数的最小值，X为整数，YZ精度0.1即可。穷举法不知道怎么弄", "Tag": "算法分析"}
{"Answer": "for i = 0 to 9\r\nfor j = 0 to 9\r\nprint \"12\" & i & \"5\" & j\r\nnext\r\nnext", "Konwledge_Point": "智能穷举搜索", "Question": "VB语言一个关于字符串组合的程序\n这样的数字构成的字符串在VB中怎么穷举？\n\n12*5*\n\n输出12051 12052 ... 12959 ", "Tag": "算法分析"}
{"Answer": "\n/* Note:Your choice is C IDE */\n#include \"stdio.h\"\nvoid OutputPrimeFactor(int i);\nvoid main()\n{\n    /*\n    \t调用函数解决，在主函数中穷举90 ~ 100间所有整数，对每个整数调用函数OutputPrimeFactor( )进行求解，\n    \t该函数没有返回值，函数类型可以定义为void。\n    */\n    int i;\n    printf(\"90~100以内的数如下：\\n\");\n    for(i=90;i<=100;i++)\n    {\n   \t\tOutputPrimeFactor(i);\n    }\n}\n\nvoid OutputPrimeFactor(int i){\n\tint a=0;\n\tint j=0;\n\t//求i对应的所有的因子\n\tprintf(\"%d=\",i);\n\tfor(j=i;j>1;j--)\n\t{\n\t\tif(i%j==0)\n\t\t{\n\t\t\t\n\t\t\ta=i/j;\n\t\t\tprintf(\"%d*\",a);\n\t\t}\n\t\t\n\t}\n\tprintf(\"\\n\");\n}\n ", "Konwledge_Point": "智能穷举搜索", "Question": "对90 ~ 100以内的所有整数，逐一对其进行质因子分解，并按照质数因子从小到大顺序以乘积形式输出，\n调用函数解决，在主函数中穷举90 ~ 100间所有整数，对每个整数调用函数OutputPrimeFactor( )进行求解，该函数没有返回值，函数类型可以定义为void。\n", "Tag": "算法分析"}
{"Answer": "你好，穷举法可以这么做：\nfor i = 1:100\nfor j = i+1:100\nfor k = j+1:100\nfor l = k+1:100\nif( i+j+k+l==100)\ndisp([i,j,k,l])\nend\nend\nend\nend\nend\n\n结果比较长，就不显示出来啦有帮助望采纳", "Konwledge_Point": "智能穷举搜索", "Question": "matlab关于for循环的问题\n从1--100中选择四个整数，使得这四个数之和等于100，用for_loop穷举法，找出所有的可能组合", "Tag": "算法分析"}
{"Answer": "#include<stdio.h>\n#include<math.h>\nint main() {\n    int a,b,c,d,s1,s2,t;\n    for(a=0;a<=9;a++){\n        for(b=0;b<=9;b++){\n            s1=100+a*10+2;\n            s2=30+b;\n            t=s1*s2;\n            if(t/1000>0&&t/100%10==7&&t/10%10==5){\n                c=t/1000;\n                d=t%10;\n                printf(\"%d %d %d %d\\n\",a,b,c,d);\n            }\n        }\n    } \n    return 0;\n}\n", "Konwledge_Point": "智能穷举搜索", "Question": "请看一下这个应该怎么写啊谢蟹！\n有一个乘法算式，1A2*3B=C75D，该算式在四个字母所在处缺四个数，利用穷举法找出这四个数", "Tag": "算法分析"}
{"Answer": "http://blog.chinaunix.net/uid-24753924-id-177343.html", "Konwledge_Point": "智能穷举搜索", "Question": "VB编码的排列问题，怎么代入变量呢？\nVB编码的排列问题，1xyz2345，其中x y z必须都不同，也可能是1 x y 345，总之变量个数也不确定，所以不能直接循环，请问这种情况下怎么穷举呢？", "Tag": "算法分析"}
{"Answer": "先把数码管点亮，注意位选和段选，然后做按键检测，最后按下了就让数码管数字加1就行了", "Konwledge_Point": "智能穷举搜索", "Question": "如何用动态数码管来显示按键按下次数的记录\n调用P3_0口\n不用穷举法\n如何才能实现这个功能。。‧⁺◟( ᵒ̴̶̥́ ·̫ ᵒ̴̶̣̥̀ )ꈨຶꎁꈨຶ꒦ິ^꒦ິ •᷄ࡇ•᷅ ˃ ˄ ˂̥̥ ", "Tag": "算法分析"}
{"Answer": "使用k-均值算法进行聚类\n ", "Konwledge_Point": "智能穷举搜索", "Question": "matlab关于排列组合的一个问题,求大佬们指点\n课题是已知十个点,坐标已知,要求将十个点分为两组,每组5个点,并用循环的形式表达出所有组合可能。题主只会穷举法列出，对循环毫无思路，请大家指教一下", "Tag": "算法分析"}
{"Answer": "可以利用n位二进制数中有C（k，n）个含有k个1的数，例如四位二进制数里含有2个1的数为C（2，4）=4*3/2=6个。这样可以利用这个规律来提高效率，比如1-18这个范围就减少到16-18，算这个范围即可。", "Konwledge_Point": "智能穷举搜索", "Question": "#C语言题目 #二进制\n想问下这个题目有没有什么好的思路？\n穷举法的话会超出题目给的时间限制\n一开始想的是设置一个数组来存放二进制的01，然后通过类似于全排列的算法来解决\n不知道大家有没有什么更好的解决方法", "Tag": "算法分析"}
{"Answer": "```\r\nint main()\r\n{\r\n\tint x, g, m;\r\n\tfor (x = 3; x <= 100; x += 3) {\r\n\t\tfor (g = 1; g <= 100; g++) {\r\n\t\t\tfor (m = 1; m <= 100; m++) {\r\n\t\t\t\tif ((x + g + m == 100) && (x * 3 + g + m / 3 == 100) && (m % 3 == 0)) {\r\n\t\t\t\t\tprintf(\"小鸡，公鸡，母鸡的个数分别是：%d,%d,%d\\n\", x, g, m);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n} \r\n```", "Konwledge_Point": "智能穷举搜索", "Question": "初学者百元买百鸡程序问题\n题目是小鸡3元一只，公鸡1元一只，母鸡1元3只，一百元买一百只鸡，要用穷举法 \n这是我打的程序，好像没什么问题，当运行一直无限循环的？", "Tag": "算法分析"}
{"Answer": "老实说，这代码问题太多，判断i是否是素数的循环里，Target范围不用从2到达i，到达i平方根即可，其次，i跟1,2的比较没用，\r\n再次，target不用累加，如果i是素数，判断到i的平方根即可确定是素数，如果i不是素数，则必然可以由素数的乘积构成，所以target\r\n的取值只需全部取素数即可", "Konwledge_Point": "智能穷举搜索", "Question": "一个简单程序出错了求纠错，谢谢\n我写了一个求1000-10000素数的程序，代码去图片，但为什么求出的从是9701后的所有数？\n\n\n\n#include \"stdafx.h\"\n\n#include \n\n#include \n\n\n\nint calculate(int i)\n\n{\n\n    int judge;\n\n    for (judge = 2; judge < i; judge++)    //穷举i的所有除数\n\n    {\n\n        if (i%judge == 0)\n\n        {\n\n            return 0;                   //不是素数\n\n        }\n\n        else if (i!=judge+1)                  //判断i有没有被所有除数除完   如果除完都没有余数就返回1  即这个数十素数！  如果没有除完继续循环除！\n\n            continue;\n\n        else\n\n            return 1;\n\n    }\n\n}\n\n\n\nint main()\n\n{\n\n    int i;\n\n    for (i = 1000; i < 10000; i++)      //穷举所有i \n\n        if (calculate(i) == 1)\n\n            printf(\"%d\\n\", i);         //输出素数！\n\n    system(\"pause\");", "Tag": "算法分析"}
{"Answer": "你这个while 的判断条件不应该是n！=6174，应该是别的，不然你的while循环就没有跳出了，当你的值是1000的时候就会卡在里面", "Konwledge_Point": "智能穷举搜索", "Question": "用python验证卡普雷卡尔黑洞问题时运行不正常\n问题遇到的现象和发生背景\n\n\n尝试用for循环在1000~9999内验证卡普雷卡尔黑洞问题时程序无终止(最终期望得到数值：6174）\n\n\n问题相关代码\n\n\n#Main exe\n\n\ndef\n \nmain\n():\n    \nfor\n n \nin\n \nrange\n(\n1000\n,\n10000\n):\n        check(\nstr\n(n))\n        \nif\n check(\nstr\n(n)):\n            blackhole(\nstr\n(n))\n        \nelse\n:\n            \nprint\n(\n'Illegal'\n)\n\n\n#Check the number\n\n\ndef\n \ncheck\n(\nn\n):\n    \nif\n \nnot\n n.isnumeric():\n        \nreturn\n \nFalse\n\n    \nelif\n \nlen\n(n)!=\n4\n:\n        \nreturn\n \nFalse\n\n    \nelif\n n==n[\n0\n]*\n4\n:\n        \nreturn\n \nFalse\n\n    \nelse\n:\n        \nreturn\n \nTrue\n\n\n\n#Blackhole transform\n\n\ndef\n \nblackhole\n(\nn\n):\n    rom=n\n    \nwhile\n n!=\n'6174'\n:\n        a=\nlist\n(n)\n        b=max_number(a)\n        c=min_number(a)\n        n=\nstr\n(b-c)          \n#The type of n is string instead of int\n\n    \nprint\n(\n'{} OK'\n.\nformat\n(rom))\n\n\ndef\n \nmax_number\n(\na\n):\n    a.sort(reverse=\nTrue\n)\n    \nreturn\n \nint\n(\n''\n.join(a))\n\ndef\n \nmin_number\n(\na\n):\n    a.sort()\n    \nreturn\n \nint\n(\n''\n.join(a))\n\n\n#Exe entrance\n\n\nif\n __name__==\n'__main__'\n:\n    main()\n\n\n\n运行结果及报错内容\n\n\nTraceback (most recent call last):\n  File \"G:/程序/数字黑洞穷举验证.py\", line 40, in \n    main()\n  File \"G:/程序/数字黑洞穷举验证.py\", line 6, in main\n    blackhole(str(n))\n  File \"G:/程序/数字黑洞穷举验证.py\", line 26, in blackhole\n    b=max_number(a)\nKeyboardInterrupt\n运行时一直没有print的任何显示，只好手动终止程序。\n使用键盘手动终止程序时正在执行的位置也不同。\n\n\n我的解答思路和尝试过的方法\n\n\n怀疑过计算量较大，尝试过缩小验证范围（1000~1005），但没有用，好奇为什么。\n\n\n我想要达到的结果\n\n\n在1000~9999内验证卡普雷卡尔黑洞问题", "Tag": "算法分析"}
{"Answer": "只用了些基础的方式，算法很简单，只要计算一下位置正确且数字正确的个数和数字正确的个数，然后和你给的条件暴力枚举即可\n    public static void main(String[] args) {\n        // 枚举法 out: 0518 3510\n        String str1 = \"3628\";\n        String str2 = \"7019\";\n        String str3 = \"1429\";\n        String str4 = \"4576\";\n\n        for (int i = 0; i <= 9999; i++) {\n            // 补0\n            String cur = String.format(\"%04d\", i);\n            if (!check(cur, str1, 1, 1)) continue;\n            if (!check(cur, str2, 1, 2)) continue;\n            if (!check(cur, str3, 0, 1)) continue;\n            if (!check(cur, str4, 1, 1)) continue;\n            System.out.println(\"密码：\" + cur);\n        }\n    }\n\n    public static boolean check(String target, String condition, int targetPos, int targetSame) {\n        int[] cnt1 = new int[10];\n        int[] cnt2 = new int[10];\n        // 位置正确且数字正确个数\n        int posCnt = 0;\n        for (int i = 0; i < 4; i++) {\n            char c1 = target.charAt(i);\n            char c2 = condition.charAt(i);\n            cnt1[c1 - '0']++;\n            cnt2[c2 - '0']++;\n            // 重复数字直接返回false\n            if (cnt1[c1 - '0'] > 1) return false;\n            if (c1 == c2) posCnt ++;\n        }\n        // 数字正确个数\n        int sameCnt = 0;\n        for (int i = 0; i < 10; i++) {\n            sameCnt += Math.min(cnt1[i], cnt2[i]);\n        }\n        return posCnt == targetPos && sameCnt == targetSame;\n    }\n\n输出\n密码：0518\n密码：3510\n", "Konwledge_Point": "智能穷举搜索", "Question": "如何用java猜四位数密码？\n猜密码:\n3 6 2 8 其中一个数字正确且位置正确\n7 0 1 9 其中两个数字正确，一个位置正确，一个位置不对\n1 4 2 9 一个数字正确，位置不对\n4 5 7 6 一个数字正确且位置正确\n以上条件成立，且四位密码数字不重复，实用java程序实现。\n有点类似力扣里的猜数字问题，这个问题仅用java基础进行编写(数组或者字符串，哈希和list不能用)，大概都是暴力穷举，希望网友们多多参与讨论。", "Tag": "算法分析"}
{"Answer": "供参考：\n#include<stdio.h>\n\nint main()\n{\n    int i, j, k, l, s = 0;\n    for (i = 1; i <= 9; i++)\n        for (j = 1; j <= 9; j++)\n            for (k = 1; k <= 9; k++)\n                for (l = 1; l <= 9; l++)\n                    if (i + j + k + l == 9){\n                        printf(\"%d,%d,%d,%d\\n\", i, j, k, l);\n                        s++;\n                    }\n    printf(\"%d\\n\",s);\n    return 0;\n}\n\n", "Konwledge_Point": "智能穷举搜索", "Question": "问一下这题怎么做（Devc++）\n这题穷举不会请大家教我一下越初级越好\n\n\n#include\n\n\nusing\n \nnamespace\n std;\n\nint\n main(){\n    \nint\n a,b,c,\nsum\n=\n0\n;\n    \nfor\n(\nint\n i=\n1\n;i<\n10000\n;i++){    \n        a++;\n        b++;\n        c++;\n        \nif\n(a+b+c+i==\n9\n){\n            \nsum\n=\nsum\n+\n1\n;\n        }\n    \n    }\n    cout<<\nsum\n;\n    \n    \n    \nreturn\n \n0\n;\n} \n\n\n\n\n这是错的不知道怎么改\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "spark基本数据处理之推荐数据movielens_小李飞刀李寻欢的博客-CSDN博客", "Konwledge_Point": "智能穷举搜索", "Question": "spark-sql如何按用户对time排序，序号为新增的一列\n问题遇到的现象和发生背景\n\n\n怎么给dataset增加一列并按照用户编号啊？\n比如\nuid，movieid，time\n1   1009      20220101\n1     1002  20220104\n2   1019     20220203\n2   1012   20220209\n要求：按用户uid对time进行倒排序，序号增加一列\n\n\n我想要达到的结果\n\n\n增加后\nuid movieid   time      order\n1   1009     20220101 1\n1    1002    20220104  2\n2   1019     20220203  1\n2   1012     20220209 2\n\n\nuid很多很多，不能用穷举的方法（一个一个写的那种）", "Tag": "算法分析"}
{"Answer": "\nn=eval(input())\ni=1\nfor i in range(1,n+1):\n    if i%3==2 and i%5==1 and i%7==0:\n        print(i,end=' ')\n    i=i+1\n \n ", "Konwledge_Point": "智能穷举搜索", "Question": "关于#python#的问题：要求全列举出来）【输入形式】人数上限 n【输出形式】士兵人数【样例输入】60【样例输出】56 【样例输入】300【样例输出】56 161 266\n有一群士兵，人数不超过n。韩信将其按照一行3人排队，余2人；按照一行5人排队，余1人；按照一行7人排队，刚好排成若干行。编写程序 计算士兵的人数。\n（提示：可以采用穷举法求解。当人数上限比较大时，会有多种结果，要求全列举出来）\n【输入形式】\n人数上限 n\n【输出形式】\n士兵人数\n【样例输入】\n60\n【样例输出】\n56\n \n【样例输入】\n300\n【样例输出】\n56 161 266", "Tag": "算法分析"}
{"Answer": "1.当然是正确的不能被素数整除，必然也不能被合数整除，因为合数是素数相乘得到的呀，这还用写程序论证？问题是在求素数的过程中如果还要顺带求比它小的素数，反而复杂化了，所以写程序一般都不考虑是素数还是合数，直接遍历。如果你不是要验证一个数是质数还是合数，而是要求N以内的所有质数，那么筛法才是最效率的。2.穷举当然是可以破解的，问题是需要花多长时间呢？如果你花600年能破解，跟破解不了有多大区别呢实际上，算法也是在不断迭代的，最早RSA算法只有128位，现在512位也不止了吧，好像已经有2048位的RSA了所以实际应用中你不需要600年破解，只要3年不被破解基本上就等于永远不会被破解了，因为3年之后算法提升，破解难度又变大了", "Konwledge_Point": "智能穷举搜索", "Question": "素数与RSA算法的疑问\n我有几点思考，个人能力有限想不明白，望有人指点下：\n1、找素数的时候，我在想：不能被比他小的素数整除的数就是素数。请各位指正该推理成立吗？1亿以内的素数我都写程序论证过了，没有问题。\n2、都说RSA很难破译，是真的吗？人类目前找到的素数是个有限集合，公钥里面包含了两个大素数的乘积，如果进行穷举，是不是就可以破解了？", "Tag": "算法分析"}
{"Answer": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath> \n#include <vector>\n#include <queue>\n#include <map>\n#include <stack>\n#include <set>\n#include <sstream>\n#include <iomanip> \nusing namespace std;\n\nint result = 0;\nint a[30];\nvoid output(int n)\n{\n    int i;\n    for(i=0;i<=n-1;i++)\n     {\n          if (i < n - 2)\n        {\n            if (a[i] == 1 && a[i + 1] == 0 && a[i + 2] == 1)\n            {\n                return;\n            }\n        }\n        if (i == n - 1)\n        {\n            result++;\n        }\n     }\n}\n\nvoid search(int m,int n)                                     \n{\n     int i;\n    if(m==n)\n     {\n          output(n);\n     }\n     else\n     {\n          for(i=0;i<=1;i++)\n          {\n               a[m]=i;\n               search(m+1,n);\n          }\n     }\n}\n\nint main()\n{\n    int array[30]={0,2,4,7,12,21,37,65,114,200,351,616,1081,1897,3329,5842,10252,17991,31572,55405,97229,170625,299426,525456,922111,1618192};\n    int n;\n    cin>>n;\n    search(0,n);\n    if(array[n] != result)cout<<\"error\"<<endl;\n    cout<<result<<endl;\n    result = 0;\n    return 0;\n}\n\n源码给你你继续研究吧", "Konwledge_Point": "智能穷举搜索", "Question": "取数游戏 Description\n题目描述\n我们来玩一个游戏：自然数1到N，按顺序列成一排，你可以从中取走任意个数，但是间隔一个的不能同时被取走，如果1表示取走，0表示不取走，则不能出现101的连续串。\n如果你能算出一共有多少种取法，那么你会被天神小泰泰奖励。\n输入\n输入仅包含一个数n（1≤ n ≤ 25）。\n输出\n输出仅包含一个数你的答案。\n样例\n输入  复制\n4\n输出  复制\n12\n提示\n递归穷举即可。答案在2147483647以内。", "Tag": "算法分析"}
{"Answer": "这段程序是一个求解1000以内的阿姆斯特朗数的简单 C 语言程序。它采用穷举法来寻找所有符合条件的数，并输出它们。\n该程序主要分为两个循环：\n1.外层循环从2到999依次取出待判定的数i。\n2.内层循环将i的每一位数字分解并计算它们的立方和，然后与i比较是否相等。如果相等，则说明i是一个阿姆斯特朗数，输出i的值。\n值得注意的是，该程序在截取整数i的各位数字时，使用了一个循环和一个数组a。循环用来重复执行3次，每次截取i的一个数字，并将它赋值给数组a的一个元素。这样，a数组就存储了i的各位数字。然后，程序使用a数组计算i的立方和，并与i比较，判断i是否是阿姆斯特朗数。\n另外，该程序的输出结果会在一行内输出所有阿姆斯特朗数，每个数之间用空格隔开。如果您想让输出结果每行输出一定数量的数，请在printf语句中添加换行符。例如：\nif(a[0]*a[0]*a[0]+a[1]*a[1]*a[1]+a[2]*a[2]*a[2]==i)\n    printf(\"%5d\\n\",i); /*每个数单独占一行*/\n\n\n\n或者：\n\nif(a[0]*a[0]*a[0]+a[1]*a[1]*a[1]+a[2]*a[2]*a[2]==i)\n{\n    printf(\"%5d\",i); /*每个数占用一定的宽度*/\n    if(i%10==0) printf(\"\\n\"); /*每行输出10个数*/\n}\n\n", "Konwledge_Point": "智能穷举搜索", "Question": "C语言，解释如下算法\nC语言，解释代码意思。\n如下，请问为什么内循环是呢？不太明白\n\n\n\n\nfor\n(t=\n0\n,k=\n1000\n;k>=\n10\n;t++)\n\n\n\n\n\n/*如果一个正整数等于其各个数字的立方和，则称该数为阿姆斯特朗数(亦称为自恋性数)。\n如 407=43+03+73就是一个阿姆斯特朗数。试编程求1000以内的所有阿姆斯特朗数。\n*问题分析与算法设计\n可采用穷举法，依次取1000以内的各数(设为i)，将i的各位数字分解后，据阿姆斯特朗数的性质进行计算和判断。*/\n\n#include\nint main()\n{\n    int i,t,k,a[\n3\n];\n    printf(\n\"There are follwing Armstrong number smaller than 1000:\\n\"\n);\n    for(i=\n2\n;i<\n1000\n;i++) \n/*穷举要判定的数i的取值范围2~1000*/\n\n    {\n        for(t=\n0\n,k=\n1000\n;k>=\n10\n;t++) \n/*截取整数i的各位(从高向低位)*/\n\n        {\n            a[t]=(i\n%k)/(k/10); /*分别赋于a[0]~a[2}*/\n\n            k/=\n10\n;\n        }\n        if(a[\n0\n]*a[\n0\n]*a[\n0\n]+a[\n1\n]*a[\n1\n]*a[\n1\n]+a[\n2\n]*a[\n2\n]*a[\n2\n]==i)\n/*判断i是否为阿姆斯特朗数*/\n\n        printf(\n\"%5d\"\n,i); \n/*若满足条件，则输出*/\n\n    }\n    printf(\n\"\\n\"\n);\n}\n", "Tag": "算法分析"}
{"Answer": "机器学习里面回归拟合啊，至于逻辑回归还是线性，这个看你的数据了", "Konwledge_Point": "智能穷举搜索", "Question": "【毕不了业了】这玩意除了神经网络还有什么别的好的算法吗？\n​接了个方向，现在毕不了业了……\n\n\n如下：\n\n\nA到L是12个变量，其中前5个是输入，后7个是输出；\n\n\nQ1:  我现在知道这12个变量的范围，比如A（100~400）；我现在要建立输入与输出之间的关系。\n        我需要去了解什么算法呢？除了神经网络还有好的办法吗？\n​\n\n\n\n\nQ2:  现在输出区间里有个最优的数值，但是我不知道它是多少，也不知道该怎么去取得它。怎么搞呢？在Q1的基础上直接穷举法吗？\n\n\n恳请回答，万分感谢", "Tag": "算法分析"}
{"Answer": "\n#include<stdio.h>\nint main()\n{\nint j,i[5];\nint sign;\nint result;\nint count=0;\nint num[6];\nint left,right;\nchar oper[5]={' ','+','-','*','/'};\nfor(j=1;j<=5;j++)\nscanf(\"%d\",&num[j]);\nscanf(\"%d\",&result);\nfor(i[1]=1;i[1]<=4;i[1]++)\n{\nif((i[1]<4)||(num[2]!=0))\n{\nfor(i[2]=1;i[2]<=4;i[2]++)\n{\nif((i[2]<4)||(num[3]!=0))\n{\nfor(i[3]=1;i[3]<=4;i[3]++)\n{\nif((i[3]<4)||(num[4]!=0))\n{\nfor(i[4]=1;i[4]<=4;i[4]++)\n{\nif((i[4]<4)||(num[5]!=0))\n{\nleft=0;\nright=num[1];\nsign=1;\n\n                                        for(j=1;j<=4;j++)\n                                            {\n                                                switch(oper[i[j]])\n                                                {\n                                                    case '+':\n                                                    left=left+sign*right;\n                                                    sign=1;\n                                                    right=num[j+1];\n                                                    break;\n                                                    case '-':\n                                                    left=left+sign*right;\n                                                    sign=-1;\n                                                    right=num[j+1];\n                                                    break;\n                                                    case '*':\n                                                    right=right*num[j+1];\n                                                    break;\n                                                    case '/':\n                                                    right=right/num[j+1];\n                                                    break;\n                                                }\n                                             }\n                    if(left+sign*right==result)\n                    {\n                        count++;\n                        for(j=1;j<=4;j++)  \n                            printf(\"%c \",oper[i[j]]);\n                    }\n                                    }\n                                }\n                        }\n                }\n            }\n        }\n    }\n}\nif(count==0)\n    printf(\"No solution\");\n    getchar();\n    return 0;\n}\n", "Konwledge_Point": "智能穷举搜索", "Question": "C语言编程填入运算符\n问题描述：输入 5 个数与一个结果，设计程序在 5 个数中填入运算符（ + - * /）使其与结果相等，或回答做不到。5个数顺序固定，运算顺序固定为从左向右，不考虑运算符优先性。除法按整数除法来运算，保证有解的输入都是有唯一解的。\n输入形式：5个整数a, b, c, d, e和一个结果整数result。0<a,b,c,d,e<=50。\n输出形式：依次输出4个运算符，以空格隔开；没有解时输出\"No solution\"。\n如何遍历各种情况呢？一共64种填入可能，如何穷举完全？", "Tag": "算法分析"}
{"Answer": "先排序，再去除重复数字，然后遍历一遍，若前后两个数据之差为1，则符合题目要求", "Konwledge_Point": "智能穷举搜索", "Question": "如何用C语言完成，希望大家给于思路\n提示用户输入数据规模N，然后随机生成N个正整数（所有整数均小于10000），输出其中包含的所有相邻数对（数值相差为1的两个整数）以及相邻数对的总数。例如，若N=7，随机生成7个数据{2,0,3,6,1,0,4}，其中一共包括4个相邻数对，即（1,0）、（1,2）、（2,3）和（4,3）。注意，（0,1）和（1,0）是相同的相邻数对，不要重复统计和输出显示。要求：不允许使用双重循环穷举的方式查找相邻数对。", "Tag": "算法分析"}
{"Answer": "1、内循环上增加 sum = 0; temp = i;2、内循环内部只需要 sum += pow(temp % 10, n); temp /= 10;代码参考：\n#include<stdio.h>\n#include<math.h>\nint main(void) {\n    int n, min, max, t, sum;\n    printf(\"Enter n(2<n<8):\");\n    scanf(\"%d\", &n);\n    min = pow(10, n - 1);\n    max = pow(10, n);\n    for (int i = min; i < max; i++) {\n        t = i;\n        sum = 0;\n        for (int j = 1; j <= n; j++) {\n            sum += pow(t % 10, n);\n            t /= 10;\n        }\n        if (sum == i) {\n            printf(\"%d\\n\", i);\n        }\n    }\n    return 0;\n}\n", "Konwledge_Point": "智能穷举搜索", "Question": "关于水仙花数如何解决\n输出n位数全部的水仙花数\n\n\n#\ninclude\n\n\n\nint\n \nmain\n(\nvoid\n)\n\n\n{\n    \nint\n n,min,max,k,i,bit,temp,sum=\n0\n;\n    \nprintf\n(\n\"Enter n(2<n<8):\"\n);\n/*输入n*/\n \n    \nscanf\n(\n\"%d\"\n,&n);\n    min=\npow\n(\n10\n,n);\n/*下限，比如n==3，min=100*/\n \n    max=\npow\n(\n10\n,n+\n1\n);\n/*上限限，比如n==3，max=1000*/\n\n    \nfor\n(i=min;i<max;i++)\n/*穷举min~max中的数*/\n\n    {\n        \nfor\n(k=\n1\n;k<=n;k++)\n/*判断水仙花数*/\n\n        {\n            temp=i;\n            bit=i%\n10\n;\n            i=i/\n10\n;\n            sum=sum+\npow\n(bit,n);\n        }\n        \nif\n(sum==i)\n        {\n            \nprintf\n(\n\"%d \"\n,i);\n        }\n    }\n    \n    \n    \n    \nreturn\n \n0\n;\n } \n\n\n\n\n运行结果及报错内容\n\n\n可以通过编译，没有输出", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/wind__chaser/article/details/91386065", "Konwledge_Point": "智能穷举搜索", "Question": "网络博客回溯法素数环问题疑惑？\n#include\n#include\n#include\n#include\nusing namespace std;\nbool b[11]= {0};\nint total=0,a[11]= {0};\nint search(int);//回溯过程\nint print();//输出方案\nbool pd(int,int);//判断素数\nint main()\n{\n    search(1);\n    cout<\";\n    for (int j=1; j<=10; j++)\n        cout<sqrt(i))\n        return 1;\n    else\n        return 0;\n}\n\n\n\n\n以上是网上博客解决素数环的问题，我一直比较疑惑的点是最终的输出结果为什么只有1，2，3，5，7开头的，4，6，8，9，10开头的呢\n\n当前结果6 1 10 7 4 9 2 3 8 5\n\n当前结果6 1 10 7 4 9 8 3 2 5\n\n当前结果6 1 10 9 2 5 8 3 4 7\n\n当前结果6 1 10 9 8 5 2 3 4 7\n\n比如以上也是满足的\n\n另外一个穷举法\n\n\n\n#include\n#include\n\nusing namespace std;\n\nint A[100], isp[100], n;//isp是素数表，用于存放素数 \n\nint is_prime(int x){\n    for(int i = 2; i < x; i++){\n        if(x % i == 0) return 0;\n    }\n    return 1;\n}\n\nvoid printPrime(){\n    //生成第一个排列，顺序排列， A[1] = 1 A[2] = 2 \n    for(int i = 1; i <= n; i++){\n        A[i] = i;\n    }\n    do{\n        bool ok = true;\n        for(int i = 1; i < n; i++){\n            int index = A[i]+A[i+1];\n            if(!isp[index]){\n                ok = false;\n                break;\n            }\n        }\n        //第一个和最后一个数的和 \n        if(!isp[A[1] + A[n]]){\n            ok = false;\n        }\n        if(ok){\n            cout << \"当前结果\"; \n            for(int i = 1; i <= n; i++){\n                cout << A[i] << \" \";\n            }\n            cout << endl;\n        }\n    } while(next_permutation(A+2, A+n+1));//第一个一定为1不变，只更新第2个到最后1个的排列\n}   //因为A[0]=0,A[1]=1\n\nint main(){\n    cin >> n;\n    //记录1~n*2的值是否为素数 \n    for(int i = 2; i <= n*2; i++){\n        isp[i] = is_prime(i);\n    }\n    printPrime();\n}\n\n\n\n\n穷举法却可以有1到10开头的都有，我想不明白第一个程序为什么不能输出全部，实在想不明白，希望大佬指点一下，", "Tag": "算法分析"}
{"Answer": "1.多了个分号2.if没括号\n", "Konwledge_Point": "智能穷举搜索", "Question": "c语言程序设计函数章节课后习题\nc语言程序设计课后题目搞不懂\n\n\n遇到一个错误翻译过来也看不懂\n\n\n\n\n#include \n\n//穷举法\n\n\nint\n gcd(\nint\n a,\nint\n b)\n{    \n \nif\n(a==\n0\n);\n    \nreturn\n b;\n    \nif\n (b==\n0\n)\n    \nreturn\n a;\n    \nif\n (a==b)\n    \nreturn\n a;\n    \nint\n gcd_res = a > b?b : a;\n    \nwhile\n(gcd_res > \n1\n)\n    {\n        \nif\n(a%gcd_res==\n0\n)&& (b%gcd_res==\n0\n)\n        \nreturn\n gcd_res;\n            gcd_res--;\n        }\n    \nreturn\n gcd_res;\n}\n\nint\n main()\n{\n    \nint\n a , b;\n    \nprintf\n(\n\"请输入a和b\"\n);\n    scanf(\n\"%d %d\"\n,&a,&b);\n    \n    \n//\n最大公约数\n    \nint\n gcd_result = gcd(a,b);\n    \nprintf\n(\n\"%d 和 %d的最大公约数为：>%d\\n\"\n,a,b,gcd_result);\n    \nreturn\n \n0\n;\n    }\n\n\n\n\n[Error] expected identifier before '(' token\n\n\n我用#define，再找了一下同学，同学说我这个少个中括号，但是我每次审查都发现不了错在哪\n\n\n我想要明白这个问题出在哪里", "Tag": "算法分析"}
{"Answer": "因为x,y,z均是没有初始值的变量，但你把它们作为了循环的条件", "Konwledge_Point": "智能穷举搜索", "Question": "小白看着大神：内心渴望满满：千言万语归为一句话：哪位大神帮我看看这个程序\n题目内容：\n\nn块砖( 27=0&&x<=20)\n\n{\n\nwhile(y>=0&&y<=25)\n\n{\n\nwhile(z>=0&&z<=150)\n\n{\n\nif(x*4+y*3+z/2==n)\n\nprintf(\"men=%d,women=%d,children=%d\\n\",x,y,z);\n\n}\n\n}\n\n}\n\nreturn 0;\n\n}\n\n那么问题来了，为啥我按下回车键它没有反应", "Tag": "算法分析"}
{"Answer": "![图片说明](https://img-ask.csdn.net/upload/202010/12/1602471631_269551.png)\r\n基本功啊基本功\r\n首先告诉我你的参数d是干嘛用的？ 是没用的\r\n然后我明白你是想每次都用当前的利润总和与当前最大利润对比，但是你仔细看看，每次比较，当前最大利润都是m = 0，这还有比较的必要吗？\r\n为什么是这样呢？因为你没有把每次计算好的m传递出来，回溯什么的不明白就自己拿笔把每一次的结果都写出来，多练多写\r\n好了回到正题，既然要保持一个最大利润参数作为每次比较的依据，你得把它传递出来!\r\n[图片说明](https://img-ask.csdn.net/upload/202010/12/1602472698_275202.png)\r\n代码结构我就不动了，增加一个m参数传递\r\n结果你自己看看对不对，第一个return是为了em.回溯的参数传递，第二个return传出最终结果\r\n![图片说明](https://img-ask.csdn.net/upload/202010/12/1602472886_26278.png)", "Konwledge_Point": "智能穷举搜索", "Question": "小白搞不懂回溯啊 求大佬指教\n问题是这样的：\n\n有一个行李箱\n\n给出最多能装_多少kg__的限制（w_limit)\n\n，又给了一个货物利润的array1和对应货物重量的array2\n\n，要求output利润的最大值\n\n\n\n然后这是我写的代码\n\n\n\ndef subset(S,sub,array1,array2,n,d):\n    m=0\n    if len(S) == 0:\n        pft_sum=0\n        wgt_sum=0\n        for i in sub:\n            pft_sum += array1[i]\n            wgt_sum += array2[i]\n            if wgt_sum <= n:\n                if pft_sum > m:\n                    m = pft_sum\n        return \n    subset(S[1:],sub,array1,array2,n,d)\n    subset(S[1:],sub+[S[0]],array1,array2,n,d)\n    return m\n\n\n\n\n\n\nw_limit=25\nwgt=[2, 8, 5, 6, 15, 3, 7]\npft=[30, 100, 10, 120, 280, 50, 40]\n\nS=[]\nfor i in range(len(wgt)):\n    S.append(i)\n\n\nd=subset(S,[],pft,wgt,w_limit,[])\nprint(d)\n\n\n\n\n\n但是这样子算出来的d一直是0，是因为输出的m每一个回溯都会=0一下吗\n\n求解！", "Tag": "算法分析"}
{"Answer": "先说你代码问题再给你ac的代码。问题1. sr太小了，而且这个数组没必要。这种算法题不必等着读入完毕再处理，可以输入一个处理一个问题2. 生成小于pd的所有素数这个for循环，只需要执行一次，应该放在main中就行了，放在PD函数里面，每次执行太浪费时间问题3. 判断是不是素数只需要ii<= n就行了，因为如果n%i==0，那么n%(n/i)==也可以。就相当于i(n/i)=n问题4 and在C++是关键字，虽然在C不是关键字，但是也要注意一下另外你代码太多冗余了，我就你代码的基础上进行了优化，思路还是你的思路\nac的代码在下面，没问题的话，请点击采纳答案\n#include <stdio.h>\nint su[1229], sum, q; //小于10000的所有素数有1229个, and在C++中是关键字，改成了Sum\n\nint PD(int pd) {\n    int number = 0, w;\n    for (int r = 0; r < q; r++) {\n        //穷举法，用number标出该数的所有分解方式\n        sum = 0;\n        for (w = r; w < q; w++) {\n            sum = sum + su[w];\n            if (sum == pd) {\n                number++;\n            }\n            if (sum > pd)\n                break;\n        }\n    }\n    printf(\"%d\\n\", number);\n    return 0;\n}\nint main() {\n\n    for (int n = 2; n <= 10000; n++) {\n        //生成小于pd的所有素数,并安置在su数组中\n        int i;\n        for (i = 2; i * i <= n; i++) {\n            // i只需要枚举到 根号n即可\n            if (n % i == 0)\n                break;\n        }\n        if (i * i > n) su[q++] = n;\n    }\n    int x;\n    while (scanf(\"%d\", &x), x) {\n        PD(x);\n    }\n\n    return 0;\n}\n\n\n", "Konwledge_Point": "智能穷举搜索", "Question": "c语言 我的代码出现问题但是我找不到，如何解决？\n本人c语言初学者，在pta上做题过程中，我的代码符合题目要求也能运行，但是最后出现了\n段错误\n，但是找不到错误在哪。\n\n\n题目\n：\n(有一些正整数可以分解为一个或连续多个素数的和。给定一个正整数，有多少种可能的分解方式？例如，53可以分解为 5 + 7 + 11 + 13 + 17和53。整数41有三种分解方式，即2+3+5+7+11+13, 11+13+17和41。而整数3只有一种分解方式，即3。整数20无法分解为连续素数的和。 注意：在分解一个整数时，素数必须是连续的, 因此7 + 13 和 3 + 5 + 5 + 7 都不是20的有效分解方式，因为7和13之间有一个素数11，而 3 + 5 + 5 + 7这种分解方式中5重复出现了。)\n\n\n请编写一个程序，对于给定的一个正整数，输出其有效的分解方式有多少。\n\n\n输入：\n每行给出一个正整数，其值在2到10000之间，包括2和10000。遇到0时代表输入结束，并且0不用分解。\n\n\n输出：\n输出由多行组成。每行对应输入的一行（输入中由0结束的行除外），该行的值对应输入中整数的有效素数分解的个数，行尾不得有多余的符号\n。\n\n\n输入样例\n：\n2\n3\n17\n41\n20\n666\n12\n53\n0\n\n\n输出样例\n：\n1\n1\n2\n3\n0\n0\n1\n2\n\n\n代码\n：(变量设置的有点乱 请见谅)\n\n\n#\ninclude\n \n\n\n\nint\n \nmain\n()\n\n\n{\n    \nint\n \nPD\n(\nint\n pd)\n;\n//声明函数\n\n    \nint\n o;\n    \nint\n sr[\n30\n],x=\n0\n;\n    \nfor\n(;;)\n        {\n            \nif\n(\nscanf\n(\n\"%d\"\n,&sr[x])==\n1\n)\n            {\n            \nif\n(sr[x]==\n0\n)\n                \nbreak\n;\n            x++;\n            }\n        }\n//输入一组数据储存在名为sr的数组中\n\n    \nfor\n(\nint\n a=\n0\n;apd)\n            \nbreak\n;\n        }\n    }   \n//穷举法，用number标出该数的所有分解方式\n\n        \nprintf\n(\n\"%d\\n\"\n,number);\n    \nreturn\n \n0\n;\n}\n", "Tag": "算法分析"}
{"Answer": "\n#include<stdio.h>\n#define MAXSTRLEN 20\ntypedef struct SString {\n    int leng;\n    char data[MAXSTRLEN+1];   //第一个位置不使用\n}SString;\n\nvoid InitSString(SString &S, int le){\n    printf(\"Init(%d): \",le);\n    S.leng = le;\n    for(int i=1;i<=S.leng;i++) scanf(\"%c\",&S.data[i]);\n    getchar();\n}\n\n//简单模式匹配\nint Index(SString S, SString T, int pos){\n    //返回  模式串T  在主串S中第pos个字符之后 的位置。如果不存在，返回0\n    //T非空  1<=pos<=S.leng\n    int i=pos, j=1;\n    while(i<=S.leng && j<=T.leng){\n        if(S.data[i]==T.data[j]) {i++;j++;}\n        else{i = i-j+2; j=1;}\n    }\n    if(j>T.leng) return i-T.leng;\n    else return 0;\n}\n\n\n//KMP算法\nint Index_KMP(SString S, SString T, int pos, int next[]){\n    //T非空，1<=pos<=S.leng\n    int i=pos,j=1;\n    while(i<=S.leng && j<=T.leng)\n        if(j==0||S.data[i]==T.data[j]) {i++;j++;}\n        else j = next[j];\n    if(j>T.leng) return i-T.leng;\n    else return 0;\n}\n//next的计算方法\nvoid get_next(SString T, int next[]){\n    int i=1,j=0;\n    next[1]=0;\n    while(i<T.leng)\n        if(j==0 || T.data[i]==T.data[j]) {i++;j++;next[i]=j;}\n        else j = next[j];\n}\n//next的计算方法的修正\nvoid get_nextval(SString T, int *nextval){\n    int i=1,j=0;\n    nextval[1]=0;\n    while(i<T.leng)\n        if(j==0 || T.data[i]==T.data[j]) {\n            i++;j++;\n            if(T.data[i]!=T.data[j]) nextval[i]=j;\n            else nextval[i] = nextval[j];\n        }\n        else j = nextval[j];\n}\nint main(){\n    SString S,T;\n    InitSString(S,10);\n    InitSString(T,5);\n    printf(\"Easy_Index:%d\\n\",Index(S,T,1));\n\n    int next[T.leng+1];\n    get_nextval(T,next);\n    printf(\"KMP_next:%d\\n\",Index_KMP(S,T,1,next));\n\n    get_next(T,next);\n    printf(\"KMP_nextval:%d\\n\",Index_KMP(S,T,1,next));\n\n    return 1;\n}\nC语言描述简单模式匹配和KMP算法。\n定长顺序存储SString串：一个结构体中：一个数组存储字符串，一个整型存储长度", "Konwledge_Point": "智能穷举搜索", "Question": "kmp函数代码填空 字符串匹配\n\n\n#include \n#include \n#define N 100\n#include\nint lengthStr(char str[])\n{\n    int i;\n    int len;\n    len = 0;\n    i = 0;\n    while (str[i] != '\\0')\n    {\n        i ++;\n    }\n    len = i;\n    return len;\n}\nint strMatchBF(char mainStr[], char subStr[])\n{\n    // 穷举法进行字符串匹配\n    // 返回子串subStr与主串mainStr相匹配的第一个位置\n    int  lenMS,lenSS;\n    int i,j;\n    int isOK;\n    lenMS = lengthStr(mainStr); // 计算主串的长度\n    lenSS = lengthStr(subStr); // 计算子串（模式串）的长度\n    i = 0;\n    isOK = 0;\n    while (i endp) return ;\n    for(i = startp,j=0;i<=endp;i++,j++){\n        strcopy[j] = str[i];\n    }\n}\n\nint isEqual(char s1[], char s2[])\n{\n    // 判断两个字符串是否相等\n    int len1,len2;\n    int i;\n    len1 = lengthStr(s1);\n    len2 = lengthStr(s2);\n    if (len1 != len2)\n    {\n        return 0;\n    }\n    for (i=0;i<len1;i++){\n        if (s1[i] != s2[i])\n            return 0;\n    }\n    return 1;\n}\nint computePrefixLen(char str[],int startp,int endp)\n{\n    // 计算字符串str的最大相等前缀后缀长度\n    char *s1, *s2;\n    int len;\n    int i;\n\n    if(startp == endp) return 0;\n    s1 = (char*)malloc(sizeof (char) * (endp - startp+1));\n    s2 = (char*)malloc(sizeof (char) * (endp - startp+1));\n\n    i = 1;\n    do {\n        copyStrTo(str,s1,startp,endp-i);\n        copyStrTo(str,s2,startp+i,endp);\n        if (isEqual(s1,s2))\n            return lengthStr(s1);\n        else\n            i = i+1;\n    } while (startp <= endp-i);\n    return 0;\n}\nvoid computeNext(char str[], int next[])\n{\n    // 计算字符串的next数组\n    int i,j;\n    int len;\n    int preLen;\n    len = lengthStr(str);\n    // 初始化 next 数组\n    for (i = 0; i < len; ++i) {\n        next[i] = -2;\n    }\n    // 将所有与 str[0] 相等的字符的位置设置为 -1\n    for (i = 0; i < len; ++i){\n        if (str[i] == str[0])\n            next[i] = -1;\n    }\n    // 对于 next[i]==-2的位置，计算匹配失败时，下一个需要匹配的位置，使用相等最大前缀和后缀\n    for (i = 0; i < len; ++i){\n        if (next[i] == -2){\n            preLen = computePrefixLen(str,0,i);  // 计算字符串str[0]-str[i]的最大相等前缀后缀长度\n            next[i] = preLen;\n        }\n    }\n\n}\nint strMatchKMP(char mainStr[], char subStr[])\n{\n    // KMP法进行字符串匹配\n    // 返回子串subStr与主串mainStr相匹配的第一个位置\n\n    int * next;\n    int lenSS,lenMS;\n    int i,j;\n    lenSS = lengthStr(subStr);\n    next = (int *)malloc(sizeof (int ) * lenSS);\n    computeNext(subStr,next);\n    lenMS = lengthStr(mainStr);\n    i = 0;\n    j = 0;\n    while (i<lenMS-lenSS+1){\n        while (j<lenSS)\n        {\n            if (mainStr[i] == subStr[j]){\n                i++;\n                j++;\n            } else{\n                j = next[j];\n                if (j == -1) {j = 0;i = i+1;}\n            }\n        }\n        return i-j;\n    }\n    return -1;\n}\nint searchAllMatchingStr(char mainS[],char subS[],int pos[])\n{\n   \n\n\n\n    // 编写代码来搜索主串 mainS 中所有与子串 subS 相匹配的位置，将每个匹配串的起始位置存入 pos中。\n    // 同时，返回主串 mainS 中与子串 subS相匹配的个数\n\n\n    return 0;\n}\nvoid fuzzyMatching(char mainS[], char subS[], int pos[])\n{\n    // 模糊匹配，搜索在主串 mainS 中，与子串 subS中，'*'符号前后两个字符串相匹配的位置，将与'*'符号前面字符串相匹配的\n    // 字符串的第一个位置存储 pos[0] 中，与'*'符号后面字符串相匹配的最后一个位置存储 pos[1]中。\n\n}\nint main() {\n    char mainS[30] = {'a','r','b','c','d','p','w','d','p','a','r','p','d','p','w','a','o','d','p','w','d','p','a','y'};\n    char subS[10] = {'d','p','w','d','p','a'};\n    char subS2[10] = {'p','a','*','p','a'};\n    int pos[10];\n    int matchLen;\n    matchLen = searchAllMatchingStr(mainS,subS,pos);\n    for (int i = 0; i < matchLen; ++i) {\n        printf(\"\\n matching is ok. the %d substring position is %d\",i,pos[i]);\n    }\n\n    fuzzyMatching(mainS,subS2,pos);\n    printf(\"\\n matching is ok. the start position is %d, and the last position is %d\",pos[0],pos[1]);\n\n    return 0;\n}", "Tag": "算法分析"}
{"Answer": "初学者常犯错误  if(a=0)...这种写法并没有语法错误（正是因为如此，所以更容易犯错），但是实际的作用和你想的可能完全不一样。不过不管怎么样，那几个IO操作应该是不会被跳过的，不知道你是怎么判断代码直接跳到return的。", "Konwledge_Point": "智能穷举搜索", "Question": "关于Keil5中，函数不执行问题\n最近在学51单片机，在矩阵键盘时，我想用穷举法扫描所有的矩阵键盘，然后用return返回，但是一直不成功，去调试函数的时候，发现都是跳过return语句，没有执行到。\n\n\n\n\n\n#include \n#include \"Delay1.h\"\n\nunsigned char MatrixKey()\n{\n\tunsigned char KeyNumber=0;\n\tP1=0xFF;\n\tP1_3=0;\n\tif(P1_7=0){Delay(20);while(P1_7=0);Delay(20);KeyNumber=1;} //扫描矩阵键盘\n\tif(P1_6=0){Delay(20);while(P1_6=0);Delay(20);KeyNumber=5;}\n\tif(P1_5=0){Delay(20);while(P1_5=0);Delay(20);KeyNumber=9;}\n\tif(P1_4=0){Delay(20);while(P1_4=0);Delay(20);KeyNumber=13;}\n\t\n\tP1=0xFF;\n\tP1_2=0;\n\tif(P1_7=0){Delay(20);while(P1_7=0);Delay(20);KeyNumber=2;}\n\tif(P1_6=0){Delay(20);while(P1_6=0);Delay(20);KeyNumber=6;}\n\tif(P1_5=0){Delay(20);while(P1_5=0);Delay(20);KeyNumber=10;}\n\tif(P1_4=0){Delay(20);while(P1_4=0);Delay(20);KeyNumber=14;}\n\t\n\tP1=0xFF;\n\tP1_1=0;\n\tif(P1_7=0){Delay(20);while(P1_7=0);Delay(20);KeyNumber=3;}\n\tif(P1_6=0){Delay(20);while(P1_6=0);Delay(20);KeyNumber=7;}\n\tif(P1_5=0){Delay(20);while(P1_5=0);Delay(20);KeyNumber=11;}\n\tif(P1_4=0){Delay(20);while(P1_4=0);Delay(20);KeyNumber=15;}\n\t\n\tP1=0xFF;\n\tP1_0=0;\n\tif(P1_7=0){Delay(20);while(P1_7=0);Delay(20);KeyNumber=4;}\n\tif(P1_6=0){Delay(20);while(P1_6=0);Delay(20);KeyNumber=8;}\n\tif(P1_5=0){Delay(20);while(P1_5=0);Delay(20);KeyNumber=12;}\n\tif(P1_4=0){Delay(20);while(P1_4=0);Delay(20);KeyNumber=16;}\n\t\n\treturn KeyNumber;\n}\n\n\n#include // 这下面是主函数\n\n#include \"Delay1.h\"\n#include \"LCD1602.h\"\n#include \"MatrixKey.h\"\n\nunsigned char KeyNum;\n\nvoid main()\n{\n\tLCD_Init();\n\tLCD_ShowString(2,1,\"CHINA\");\n\twhile(1)\n\t{\n\t\tKeyNum=MatrixKey();\n\t\tif(KeyNum!=0)\n\t\t{\n\t\t\tLCD_ShowNum(1,1,KeyNum,2);\n\t\t}\n\t}\n}\n", "Tag": "算法分析"}
{"Answer": "发完整代码出来看看，现在代码不完整，看不到问题。", "Konwledge_Point": "智能穷举搜索", "Question": "语法错误说:种类前少一个分号,但是我觉得我并没有错\nVC++ 6.0 C语言问题\n报错语法错误，说我种类前少一个分号，但是我看报错的那一行并没有错呀，该定义的都在最开始的地方定义了，唯一需要分号的就是在结尾，但是结尾我已经打了呀，其他地方好像并没有需要封号的地方。\n以下是代码:\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n \n\n\n#\ninclude\n\n\n\nstruct\n \ncanhui\n//定义结构体\n\n    {\n        \nchar\n name[\n40\n];\n        \nchar\n tel[\n11\n];\n        \nchar\n id[\n18\n];\n        \nchar\n unit[\n60\n];\n        \nchar\n room[\n6\n];\n    }huiyuan;\n\n\nint\n \nMENU\n()\n//第6组总领菜单，包含3大题\n\n\n{\n    \nprintf\n(\n\"**************************************************\\n\"\n);\n    \nprintf\n(\n\"          《第6组    参会人员管理系统》            \\n\"\n);\n    \nprintf\n(\n\"                                                  \\n\"\n);\n    \nprintf\n(\n\"                1.勾股数                          \\n\"\n);\n    \nprintf\n(\n\"                2.大赛现场统分                    \\n\"\n);\n    \nprintf\n(\n\"                3.参会人员管理系统                \\n\"\n);\n//4.看书上的班级管理系统3.0以及相关知识点\n\n    \nprintf\n(\n\"                4.退出                            \\n\"\n);\n    \nprintf\n(\n\"                                                  \\n\"\n);\n    \nprintf\n(\n\"           请选择对应序号查看相应问题求解         \\n\"\n);\n    \nprintf\n(\n\"**************************************************\\n\"\n);\n    \nprintf\n(\n\"                                                  \\n\"\n);\n    }\n\n\n\n\nvoid\n \ngougushu\n(\nint\n a,\nint\n b)\n//给定区间，三循环穷举求勾股数\n\n\n{\n    \nint\n x,y,z;\n    \nfor\n(x=a;x<=b;x++)\n        \nfor\n(y=a;y<=b;y++)\n            \nfor\n(z=a;z<=b;z++)\n            {\n                \nif\n(x*x+y*y==z*z&&x<=y&&xy&&y>z&&x>z)\n                    \nprintf\n(\n\"1/(%d*%d)+1/(%d*%d)=1/(%d*%d)\\n\"\n,x,x,y,y,z,z);\n            }\n}\n\n\n\n\nint\n max,min;\n\nint\n max2[\n20\n],min2[\n20\n];\n\nvoid\n \nmax_min\n(\nint\n a[\n20\n][\n20\n],\nint\n p,\nint\n q)\n//求二维数组每一行的最大值和最小值，并分别存入最大值数组和最小值数组\n\n\n{\n    \nint\n i,j;\n    \nfor\n(j=\n0\n;jmax)\n                max=a[j][i];\n            \nif\n(a[j][i]=b)\n//输入的区间需符合要求\n\n               {\n                    \nprintf\n(\n\"\\n区间输入错误，请重新输入!\\n\"\n);\n                    \ngoto\n biaohao1;\n               }\n               \ngougushu\n(a,b);\n//用于寻找勾股数的函数\n\n               \nprintf\n(\n\"第一问第1小题求解完成！\\n\"\n);\n               \n//1.做一个判定，若无输出，则输出无结果2.若输入小数，负数如何反映，反正考虑输入情况！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\n\n               biaohao2:\n//做标记，方便goto跳转\n\n               \nprintf\n(\n\"\\n(2)输入区间【a,b】可求出该范围内所有的倒立勾股数组\\n\"\n);\n               \nprintf\n(\n\"请输入a=\"\n);\n               \nscanf\n(\n\"%d\"\n,&a);\n               \nprintf\n(\n\"请输入b=\"\n);\n               \nscanf\n(\n\"%d\"\n,&b);\n               \nif\n(a>=b)\n//输入的区间需符合要求\n\n               {\n                    \nprintf\n(\n\"\\n区间输入错误，请重新输入!\\n\"\n);\n                    \ngoto\n biaohao2;\n               }\n               \ndaoli_gougushu\n(a,b);\n//用于寻找倒立勾股数的函数\n\n               \nprintf\n(\n\"第一问第2小题求解完成！\\n\"\n);\n               \nbreak\n;\n//3.完成后反应？\n\n        \ncase\n \n2\n:\nprintf\n(\n\"\\n你选择了问题 二\\n\"\n);\n               \n//5.过程操作可视化\n\n               \nprintf\n(\n\"某大奖赛有n个选手参赛，m(m>2)个评委为依次参赛的选手评判打分：最高10分，最低0分。\\n\"\n);\n               \nprintf\n(\n\"统分规则：每个选手所得m个评分中，去掉一个最高分和一个最低分，然后将计算的平均值作为最后得分。\\n\"\n);\n               \nprintf\n(\n\"根据n个选手的最后得分，从高到低排出名次，以便确定获奖名单。\\n\"\n);\n               \nprintf\n(\n\"\\n\"\n);\n               \nprintf\n(\n\"请确定参赛选手人数n和评委人数m\\n\"\n);\n               \nprintf\n(\n\"选手人数n=\"\n);\n               \nscanf\n(\n\"%d\"\n,&n);\n               \nprintf\n(\n\"评委人数m=\"\n);\n               \nscanf\n(\n\"%d\"\n,&m);\n               \nfor\n(i=\n0\n;i<=n\n-1\n;i++)\n                   xuanshou_bianhao[i]=\n65\n+i;\n               \nprintf\n(\n\"\\n%d名参赛选手依次编号为：A\"\n,n);\n               \nfor\n(a=\n66\n;a<=\n64\n+n;a++)\n                   \nprintf\n(\n\",%c\"\n,a);\n               \nprintf\n(\n\"\\n\"\n);\n               \nprintf\n(\n\"\\n请依次输入参赛选手的评委打分\\n\"\n);\n               \nfor\n(i=\n0\n;i<=n\n-1\n;i++)\n               {\n                    \nprintf\n(\n\"第%d个选手评分：\"\n,i+\n1\n);\n                    \nfor\n(j=\n0\n;j<=m\n-1\n;j++)\n                        \nscanf\n(\n\"%d\"\n,&pinfen[i][j]);\n               }\n//8.scanf无法同tab结束输入\n\n               \nprintf\n(\n\"\\n输入数据如下：\\n\"\n);\n               \nfor\n(i=\n0\n;i<=n\n-1\n;i++)\n               {\n                    \nprintf\n(\n\"第%d个选手评分    \"\n,i+\n1\n);\n                    \nfor\n(j=\n0\n;j<=m\n-1\n;j++)\n                        \nprintf\n(\n\"%-5d\"\n,pinfen[i][j]);\n//i选手j\n\n                    \nprintf\n(\n\"\\n\"\n);\n               }\n//9.输入结果可视化？\n\n               \nfor\n(i=\n0\n;izuizhongfen[j+\n1\n])\n                        {\n                            e=zuizhongfen[j+\n1\n];\n                            zuizhongfen[j+\n1\n]=zuizhongfen[j];\n                            zuizhongfen[j]=e;\n\n                            d=xuanshou_biaohao[j+\n1\n];\n                            xuanshou_biaohao[j+\n1\n]=xuanshou_biaohao[j];\n                            xuanshou_biaohao[j]=d;\n                        }\n                    }\n                \nprintf\n(\n\"结果如下\\n\"\n);\n                \nfor\n(i=\n0\n;i<n;i++)\n                    \nprintf\n(\n\"%c%d\\t\"\n,xuanshou_biaohao[i],zuizhongfen[i]);\n               \nbreak\n;\n        \ncase\n \n3\n:\nwhile\n(\n1\n)\n               {\n                    \nprintf\n(\n\"你选择了题目 3\\n\"\n);\n                    \nprintf\n(\n\"请输入参会人员人数：\"\n);\n                    \nscanf\n(\n\"%d\"\n,&m);\n//参会人数\n\n                    \nprintf\n(\n\"请依次输入参会人员信息:\\n\"\n);\n                    \nfor\n(i=\n0\n;i<m;i++)\n                    {\n                        \nprintf\n(\n\"姓名：\"\n);\n                            \nscanf\n(\n\"%s\"\n,&huiyuan[i].name);\n                        \nprintf\n(\n\"电话：\"\n);\n                            \nscanf\n(\n\"%s\"\n,&huiyuan[i].tel);\n                        \nprintf\n(\n\"身份证号码：\"\n);\n                            \nscanf\n(\n\"%s\"\n,&huiyuan[i].id);\n                        \nprintf\n(\n\"单位：\"\n);\n                            \nscanf\n(\n\"%s\"\n,&huiyuan[i].unit);\n                        \nprintf\n(\n\"房间号：\"\n);\n                            \nscanf\n(\n\"%s\"\n,&huiyuan[i].room);\n                    }\n                    \nmenu\n();\n                    \nscanf\n(\n\"%d\"\n,&xuhao);\n                    \nswitch\n(xuhao)\n                    {\n                    \ncase\n \n1\n:\nvoid\n \nsearchByID\n(\nstruct\n canhui huiyuan[\n20\n],m)\n;\n                           \nbreak\n;\n                    \ncase\n \n2\n:\nedit\n(huiyuan,m);\nbreak\n;\n                    \ncase\n \n3\n:m=\nDelete\n(huiyuan,m);\nbreak\n;\n                    \ncase\n \n4\n:\nfor\n(m=\n0\n;huiyuan[m].name!=\n0\n;m++);\n                           \nprintf\n(\n\"请输入相关信息\"\n);\n                           \nscanf\n(\n\"%s\"\n,&huiyuan[m+\n1\n].name);\n                           \nscanf\n(\n\"%s\"\n,&huiyuan[m+\n1\n].tel);\n                           \nscanf\n(\n\"%s\"\n,&huiyuan[m+\n1\n].id);\n                           \nscanf\n(\n\"%s\"\n,&huiyuan[m+\n1\n].unit);\n                           \nscanf\n(\n\"%s\"\n,&huiyuan[m+\n1\n].room);\n                           \nbreak\n;\n                    \ncase\n \n5\n:\ntongji\n(huiyuan,m);\n                           \nbreak\n;\n                    \ncase\n \n6\n:\nexit\n (\n0\n);\nbreak\n;\n                }\n               \nbreak\n;\n        \ncase\n \n4\n:\nexit\n(\n0\n);\nbreak\n;\n        \ndefault\n:\nprintf\n(\n\"错误！\"\n);\n//6.循环输入或选择？\n\n                \n//7.输入出错如何反映\n\n                \nbreak\n;\n    }\n    }\n}\n}\n\n\n", "Tag": "算法分析"}
{"Answer": "下面这句话引起的，你以400的线粗画了个矩形，但是没有fill. 中间就是黑的类，bitmap尺寸小的时候，线把所有bitmap的地方都占据了，所以没有问题\r\ng.DrawRectangle(new Pen(Color.White, 400), 0, 0, img.Width, img.Height); //矩形 底色\r\n\r\n要填充底色用下面的语句\r\ng.FillRectangle(new SolidBrush(Color.White), 0, 0, img.Width, img.Height);", "Konwledge_Point": "智能穷举搜索", "Question": "C#画图：用C#画图的时候遇到了问题\n using System;\nusing System.Data;\nusing System.Configuration;\nusing System.Collections;\nusing System.Web;\nusing System.Web.Security;\nusing System.Web.UI;\nusing System.Web.UI.WebControls;\nusing System.Web.UI.WebControls.WebParts;\nusing System.Web.UI.HtmlControls;\nusing System.Text;\nusing System.Drawing;\nusing System.Text.RegularExpressions;\nusing System.Reflection;\nusing System.Collections.Generic;\nusing Tools;\nusing DBAPI;\nusing Functions;\nusing System.Web.Script.Serialization;\nusing System.IO;//文件存取\nusing System.Drawing;//画图基本功能\nusing System.Drawing.Drawing2D;//二维画图\nusing System.Drawing.Imaging;//高级功能\n\npublic partial class V2_NodeState_AirCleaner2_Chart2 : System.Web.UI.Page\n{\n    protected void Page_Load(object sender, EventArgs e)\n    {\n        Bitmap img = new Bitmap(400, 200);//创建Bitmap对象\n        MemoryStream stream = draw();\n\n        img.Save(stream, ImageFormat.Jpeg);          //保存绘制的图片\n        Response.Clear();\n        Response.ContentType = \"image/jpeg\";\n        Response.BinaryWrite(stream.ToArray());\n    }\n    public MemoryStream draw()\n    {\n        Bitmap img = new Bitmap(400, 200);//创建Bitmap对象\n        Graphics g = Graphics.FromImage(img);//创建Graphics对象\n\n        Pen Bp = new Pen(Color.Black); //定义黑色画笔\n        Pen Rp = new Pen(Color.Red);//红色画笔\n        Pen Sp = new Pen(Color.Blue);//蓝色\n        SolidBrush redBrush = new SolidBrush(Color.Red);\n        AdjustableArrowCap aac;  //定义箭头帽\n\n        aac = new System.Drawing.Drawing2D.AdjustableArrowCap(4, 4);\n        Sp.CustomStartCap = aac;  //开始端箭头帽\n        //Sp.CustomEndCap = aac;\n\n        Font Bfont = new Font(\"Arial\", 12, FontStyle.Bold);//大标题字体\n        Font font = new Font(\"Arial\", 6);//一般字\n        Font Tfont = new Font(\"Arial\", 9);//较大字体\n\n        float w = 1.5F;\n        float h = 1.5F;\n        g.DrawRectangle(new Pen(Color.White, 400), 0, 0, img.Width, img.Height); //矩形 底色\n\n\n        //黑色过度型笔刷\n        LinearGradientBrush brush = new LinearGradientBrush(new Rectangle(0, 0, img.Width, img.Height), Color.Black, Color.Black, 1.2F, true);\n\n\n        //蓝色过度型笔刷\n        LinearGradientBrush Bluebrush = new LinearGradientBrush(new Rectangle(0, 0, img.Width, img.Height), Color.Blue, Color.Blue, 1.2F, true);\n\n        //g.DrawString(\"我的实验\",Bfont,brush,40,5); //绘制大标题\n\n        g.DrawRectangle(Bp, 0, 0, img.Width - 100, img.Height - 40); //绘制矩形与上面的矩形即是边框\n\n        //原点坐标（150,90），一个单位坐标=8px\n        g.DrawLine(Sp, 150, 10, 150, 150);//纵坐标\n        g.DrawLine(Sp, 300, 90, 20, 90);//横坐标\n\n\n        g.DrawString(\"5\", font, brush, 188, 91); //横坐标数字\n        g.DrawString(\"10\", font, brush, 226, 91);\n        g.DrawString(\"15\", font, brush, 266, 91);\n\n        //g.DrawString(\"0.5\", font, brush, 135, 86); //纵坐标数字\n        g.DrawString(\"1\", font, brush, 135, 78);\n        //g.DrawString(\"1.5\", font, brush, 135, 78);\n        g.DrawString(\"2\", font, brush, 135, 70);\n        g.DrawString(\"3\", font, brush, 135, 62);\n\n        g.DrawLine(Bp, 190, 85, 190, 90); //横坐标刻度线\n        g.DrawLine(Bp, 230, 85, 230, 90);\n        g.DrawLine(Bp, 270, 85, 270, 90);\n\n        g.DrawLine(Bp, 155, 82, 150, 82);//纵坐标刻度线\n        g.DrawLine(Bp, 155, 74, 150, 74);\n        g.DrawLine(Bp, 155, 66, 150, 66);\n\n        //画函数曲线   这样以   y=x^2  为例   用穷举函数曲线中的两点画曲线\n        //画0-2中的点，步长为0.1\n        for (double i = 0; i <= 2; )\n        {\n            double Write11 = (150 + 8 * i);\n            double Write12 = 90 - 8 * (Math.Pow(i, 2));\n\n            double Write21 = (150 + 8 * (i + 0.1));\n            double Write22 = 90 - 8 * (Math.Pow(i + 0.1, 2));\n\n            g.DrawLine(Bp, (float)Write11, (float)Write12, (float)Write21, (float)Write22);\n            //img.SetPixel((int)Write11, (int)Write12, Color.Red);\n            g.FillEllipse(redBrush,(float)Write11,(float)Write12, w, h);\n\n\n            i = i + 0.1;\n        }\n\n        for (double i = -2; i <= 0; )\n        {\n            double Write11 = (150 + 8 * i);\n            double Write12 = 90 - 8 * (Math.Pow(i, 2));\n\n            double Write21 = (150 + 8 * (i + 0.1));\n            double Write22 = 90 - 8 * (Math.Pow(i + 0.1, 2));\n\n            g.DrawLine(Bp, (float)Write11, (float)Write12, (float)Write21, (float)Write22);\n            i = i + 0.1;\n        }\n\n        MemoryStream stream = new MemoryStream();   //保存绘制的图片\n        img.Save(stream, ImageFormat.Jpeg);          //保存绘制的图片\n        return stream;\n    }\n\n}\n\n Bitmap img = new Bitmap(1000, 500);//创建Bitmap对象\n将new Bitmap(400, 200)中的值修改为（1000，500）就会在图片中出现一个黑色的矩形框\n而且经过尝试，发现只要改大，就会出现黑色的框，同时这个框也会随着修改的值而变。\n\n\n\n\n如下图所示：", "Tag": "算法分析"}
{"Answer": "已回答，莫辜负————————————————————————————————————————\n大括号不配对：在第6行和第12行之间，大括号没有配对。这会导致编译错误。输出错误：在第20行，缺少一个大括号，导致“Count”只会输出一次。\n改了一下：\n#include <stdio.h>\n\nint main() {\n    int x, y = 0, i, j, k, a, b, z;\n    scanf(\"%d\", &x);\n    for (i = 0; i <= 10; i++) {\n        for (j = 0; j <= 10; j++) {\n            a = j * 2;\n            for (k = 0; k <= 10; k++) {\n                b = k * 5;\n                if (i + a + b == x && i + j + k == 10) {\n                    printf(\"fen1:%d张 fen2:%d张 fen3:%d张\\n\", i, j, k);\n                    y++;\n                }\n            }\n        }\n    }\n    printf(\"Count=%d(%d元有%d种支付方式)\", y, x, y);\n    return 0;\n}\n\n", "Konwledge_Point": "智能穷举搜索", "Question": "关于#c语言#的问题：为什么运行起来输出的值是0\n为什么运行起来输出的值是0？\n\n\n取1元、2元和5元的纸币共10张，现要支付15元。编写程序输出所有的付法。针对每一种付法，输出各种面额的纸币数量。要求将1元、2元和5元设置在最合理的取值范围内。\n提示：利用穷举的法来求解该问题。\n\n\n\n#include \n\n\nint main() {\n    int x, y = \n0\n, i, \nj, \nk, a, \nb, \nz;\n    \nscanf(\"%d\", \n&x);\n    for (i = \n0\n; i <= 10; i++) {\n\n        for (\nj \n= \n0\n; j <= 10; j++)\n\n            a = \nj \n* \n2\n;\n        {\n            for (k = \n0\n; k <= 10; k++) {\n\n                \nb \n= k * \n5\n;\n                if ( i + a + \nb \n== x && i + \nj \n+ \nb \n== \n10\n) {\n                    printf(\n\"fen1:%d张 fen2:%d张 fen3:%d张\\n\"\n, i, \nj, \nk);\n                    y++;\n                }\n            }\n        }\n        printf(\n\"Count=%d(%d元有%d种支付方式)\"\n, y, x, y);\n        return \n0\n;\n    }\n\n}\n    }\n\n}\n\n", "Tag": "算法分析"}
