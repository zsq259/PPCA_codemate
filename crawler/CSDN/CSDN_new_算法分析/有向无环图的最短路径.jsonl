{"Answer": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> road[10001];    // 储存每个点能通向的其他点\nvector<int> finds,key;       // 查找过错 and 储存答案\nbool flag = false;          // 查找结果\nbool op[10001]={false};             // 避免查询过程重复路径\nvoid find_RoadMin(int x, int y);\nint main()\n{\n    int N,num,a,b;             // 总点数,边个数,俩个边\n    cin >> N >> num;\n\n    // 数据读入\n    while (num--){\n        cin >> a >> b;\n        road[a].push_back(b);\n//        road[b].push_back(a);  // 注意无向的话俩个顶点应该是互通的,可你这道题是不互通\n    }\n\n    //  开始查询\n    cin >> a >> b;\n    find_RoadMin(a,b);\n\n    //  答案输出\n    if(flag){\n        cout << key[0];\n        for(int z=1;z<key.size();z++) cout << \" \" << key[z];\n    }else cout << \"false\" << endl;\n    return 0;\n}\n\nvoid find_RoadMin(int x, int y){\n    if(op[x]) return;\n    op[x] = true;\n    finds.push_back(x);\n    if(x==y)\n    {\n//        cout<< \"*****\";  // 解开注释观察测试数据\n        if(finds.size()<key.size() || key.empty() ) {\n            key.assign(finds.begin(),finds.end());  // key复制finds\n        }\n        else if(finds.size()==key.size()){\n            for(int z=0;z<finds.size();z++){\n                if(key[z]==finds[z]) continue;\n                if(key[z]>finds[z]) key.assign(finds.begin(),finds.end());  // key下一个数比finds的大\n                break;\n            }\n        }\n        flag = true;\n    }\n\n//    解开注释观察每次测试数据变换\n//    for(int z:finds) cout << z << \" \";\n//    cout << endl;\n\n    for(int z:road[x])  find_RoadMin(z,y);\n    finds.pop_back();\n    op[x] = false;\n}\n\n", "Konwledge_Point": "有向无环图的最短路径", "Question": "图，最短路径，好难，求解\n路径存在\n对一个包含 N 个顶点的有向图 G(V, E) 用邻接表进行存储，其中顶点以数组保存。对于该有向图类 adjListGraph，\n要求增加一个成员函数 existPath，对于图中的任两个顶点 i, j，检查它们之间是否有路径存在。如有，输出其中最小的一条路径。\n如无，输出字符串 \"false\"。(40')\n\n\n对于最小路径，首先判断长度，输出较小长度的路径，若存在多条长度相同的路径，则输出路径顺序中结点编号较小的路径。例如路径 6 1 5 4 和 6 2 3 4，应选择前者输出。 \n\n\n注：图中可能存在环。\n\n\n要求：在文件头部说明新增成员函数的设计思路，并分析时间复杂度分析。(10')\n\n\n输入描述\n第1行输入顶点个数 N，N 为正整数。\n\n\n第2行输入有向边信息，边的起点和终点分别为顶点的编号，编号间以逗号相隔，边之间以空格相隔。\n\n\n第3行输入路径起点和终点的编号，以空格相隔。\n\n\n输出描述\n输出路径检查的结果。\n\n\n输入举例\n6\n1,3 2,3 1,4 3,5 2,5 4,2 5,6 3,6\n4 6\n输出举例\n4 2 3 6\n\n\n#\ninclude\n\nusing namespace std;\ntemplate<\nclass\n elemType>\n\nclass\n linkQueue\n{\n    \nprivate\n:\n        \nstruct\n node\n        {\n            elemType data;\n            node *next;\n            node( elemType &x,node *N=NULL)\n            {\n                data=x;\n                next=N;\n            }\n            node\n()\n:next(NULL){}\n            ~node\n()\n{}\n        };\n    node *front,*rear;\n    public:\n        link\nQueue()\n;\n        ~link\nQueue()\n;\n        \nbool\n is\nEmpty()\n ;\n        elemType de\nQueue()\n;\n        void en\nQueue( \nelemType\n &\nx\n)\n;\n};\n\ntemplate<\nclass\n elemType>\n\nbool\n linkQueue::is\nEmpty()\n \n{\n    return front==NULL;\n}\ntemplate<\nclass\n elemType>\nlinkQueue::link\nQueue()\n\n{\n    front=rear=NULL;\n}\ntemplate<\nclass\n elemType>\nlinkQueue::~link\nQueue()\n\n{\n    node *tmp;\n    \nwhile\n(front!=NULL)\n    {\n        tmp=front;\n        front=front->next;\n        delete tmp;\n    }\n}\ntemplate<\nclass\n elemType>\nvoid linkQueue::en\nQueue(\nelemType\n &\nx\n)\n\n{\n    \nif\n(rear==NULL)\n        front=rear=\nnew\n node(x);\n    \nelse\n\n        rear=rear->next=\nnew\n node(x);\n}\ntemplate<\nclass\n elemType>\nelemType linkQueue::de\nQueue()\n\n{\n    node *tmp=front;\n    elemType value=front->data;\n    front=front->next;\n    \nif\n(front==NULL)\n        rear=NULL;\n    delete tmp;\n    return value;\n}\ntemplate<\nclass\n TypeOfVer,\nclass\n TypeOfEdge>\n\nclass\n adjListGraph\n{\n    public:\n        adj\nListGraph(\nint\n \nvSize\n)\n;\n        void insert(TypeOfVer x,TypeOfVer y,TypeOfEdge w);\n        \n//void remove(TypeOfVer x,TypeOfVer y);\n\n        \n//bool exist(TypeOfVer x,TypeOfVer y)const;\n\n        \nbool\n check\nRoute(\nint\n \nstart\n,\nint\n \nend\n)\n;\n        \n//void existPath(int start,int end);\n\n        \n//~adjListGraph();\n\n        void unweighted\nShortDistance(TypeOfVer \nstart\n,TypeOfVer \nend\n,TypeOfEdge \nnoEdge\n)\n;\n    \nprivate\n:\n        \nint\n Vers,Edges;\n        \nstruct\n edgeNode \n        {\n            \nint\n \nend\n;\n            TypeOfEdge weight;\n            edgeNode *next;\n            edge\nNode(\nint\n \ne\n,TypeOfEdge \nw\n,\nedgeNode\n \n*\nn\n=NULL)\n\n            {\n                \nend\n=e;\n                weight=w;\n                next=n;\n            }\n        };\n        \nstruct\n verNode\n        {\n            TypeOfVer ver;\n            edgeNode *head;\n            ver\nNode(\nedgeNode\n \n*\nh\n=NULL)\n\n            {\n                head=h;\n            }\n        };\n        verNode *verList;\n        \nint\n find(TypeOfVer v)const\n        {\n            \nfor\n(\nint\n i=\n0\n;i\nadjListGraph::adj\nListGraph(\nint\n \nvSize\n)\n\n{\n    Vers=vSize;\n    Edges=\n0\n;\n    verList=\nnew\n verNode\n[\nvSize\n]\n;\n    \nfor\n(\nint\n i=\n0\n;i\nadjListGraph::~adjListGraph()\n{\n    int i;\n    edgeNode *p;\n    for(i=0;inext;\n            delete p;\n        }\n    }\n    delete []verList;\n}*/\n\ntemplate<\nclass\n TypeOfVer,\nclass\n TypeOfEdge>\nvoid adjListGraph::insert(TypeOfVer x,TypeOfVer y,TypeOfEdge w)\n{\n    \nint\n u=find(x);\n    \nint\n v=find(y);\n    verList\n[\nu\n]\n.head=\nnew\n edge\nNode(\nv\n,\nw\n,\nverList\n[\nu\n].\nhead\n)\n;\n    ++Edges;\n}\ntemplate<\nclass\n TypeOfVer,\nclass\n TypeOfEdge>\n\nbool\n adjListGraph::check\nRoute(\nint\n \nstart\n,\nint\n \nend\n)\n\n{\n    \nbool\n *visited=\nnew\n \nbool\n[V\ners\n]\n;\n    \nint\n startNo,endNo;\n    \nfor\n(\nint\n i=\n0\n;i\n\nbool\n adjListGraph::check\nRoute(\nint\n \nstart\n,\nint\n \nend\n,\nbool\n \nvisited\n[])\n\n{\n    edgeNode *p=verList\n[\nstart\n]\n.head;\n    \nbool\n flag=\n0\n;\n    visited\n[\nstart\n]\n=\ntrue\n;\n    \nwhile\n(p!=NULL)\n    {\n        \nif\n(p->\nend\n==\nend\n)return \ntrue\n;\n        \nif\n(!visited\n[\np\n->\nend\n]\n)\n        {\n            flag=check\nRoute(\np\n->\nend\n,\nend\n,\nvisited\n)\n;\n            \nif\n(flag)return \ntrue\n;\n        }\n        p=p->next;\n    }\n    \n//cout<<\"okok\";\n\n    return \nfalse\n;\n}\n\n/*template\nvoid adjListGraph::existPath(int start,int end)\n{\n    bool *visited=new bool[Vers];\n    for(int i=0;i\nvoid adjListGraph::existPath(int start,int end,bool visited[])\n{\n    edgeNode *p=verList[start].head;\n    L[o]=start;\n    o++;\n    //cout<end==end)\n        {\n            L[o]=end;\n            o++;\n            //cout<<\"okok\";\n            break;\n        }\n        else if(!visited[p->end]&&checkRoute(p->end,end))\n        {\n            existPath(p->end,end,visited);\n        }\n        p=p->next;\n    }\n}*/\n\ntemplate<\nclass\n TypeOfVer,\nclass\n TypeOfEdge>\nvoid adjListGraph::unweighted\nShortDistance(TypeOfVer \nstart\n,TypeOfVer \nend\n,TypeOfEdge \nnoEdge\n)\n\n{\n    linkQueue<\nint\n> q;\n    TypeOfEdge *distance=\nnew\n TypeOfEdge\n[V\ners\n]\n;\n    \nint\n *prev=\nnew\n \nint\n[V\ners\n]\n;\n    \nint\n u,sNo;\n    edgeNode *p;\n    \nfor\n(\nint\n i=\n0\n;inext)\n        {\n            \nif\n(distance\n[\np\n->\nend\n]\n==noEdge)\n            {\n                distance\n[\np\n->\nend\n]\n=distance\n[\nu\n]\n+\n1\n;\n                prev\n[\np\n->\nend\n]\n=u;\n                q.en\nQueue(\np\n->\nend\n)\n;\n            }\n        }\n    }\n    \n//cout<\nvoid adjListGraph::print\nPath(\nint\n \nstart\n,\nint\n \nend\n,\nint\n \nprev\n[])\n\n{\n    \nif\n(start==\nend\n)\n    {\n        cout<>n;\n    \nstring\n str;\n    getline(cin,str);\n    getline(cin,str);\n    \n//cout<>x>>y;\n    \n//cout< \nA(\nn\n)\n;\n    \nint\n k=\n0\n;\n    \nfor\n(\nint\n i=\n0\n;i<str.size\n()\n;i++)\n    {\n        \nif\n(str\n[\ni\n]\n==\n','\n)\n        {\n            k++;\n        }\n    }\n    \n//cout<<k;\n\n    \nfor\n(\nint\n i=\n0\n;i<k;i++)\n    {\n        \nint\n t1,t2,u,v;\n        u=\n4\n*i;v=\n4\n*i+\n2\n;\n        t1=str\n[\nu\n]\n-\n'0'\n;\n        t2=str\n[\nv\n]\n-\n'0'\n;\n        \n//cout<<t1<<\" \"<<t2<<endl;\n\n        \nA\n.\ninsert(t1,t2,\n0\n);\n    }    \n    \nbool\n flg=\nA\n.\ncheck\nRoute(\nx\n,\ny\n)\n;\n    \n//cout<<flg;\n\n    \nif\n(flg)\n    {\n        \nA\n.\nunweighted\nShortDistance(\nx\n,\ny\n,-1)\n;\n    }\n    \nelse\n\n    {\n        cout<<\n\"false\"\n;\n    }\n}\n\n\n\n\n这个是自己写的但是没有办法满足“若存在多条长度相同的路径，则输出路径顺序中结点编号较小的路径”", "Tag": "算法分析"}
{"Answer": "解决方法：\n把MTGraph G1, G2, G3挪到main函数外，定义为全局变量动态分配G1, G2, G3的内存", "Konwledge_Point": "有向无环图的最短路径", "Question": "VS2019 栈溢出：Stack overflow，数组可能定义太大？\n\n#include\n#include\n#include\n#include\n#include\n#include\n#include\n#define \nNumVertices\n \n405\n\n#define \nINFINITY\n \n65535\n //设\n65535\n为无穷大 \nusing namespace std;\ntypedef int \nEdgeDate\n;\ntypedef int \nPathmatrix\n[\nNumVertices\n][\nNumVertices\n];\ntypedef int \nShortPathTable\n[\nNumVertices\n][\nNumVertices\n];\n\ntypedef struct\n{\n    char name[\n50\n];//站点名\n    int linenum[\n5\n];//线路对应序列 \n}station;\n\ntypedef struct\n{\n     char linename[\n20\n];//线路名称   \n}linesystem;\n\ntypedef struct \n{\n    linesystem line[\n15\n]; \n    station \nVerList\n[\nNumVertices\n];//站点信息 \n    \nEdgeDate\n \nEdge\n[\nNumVertices\n][\nNumVertices\n];         // 距离边权值 \n    int n,e;        \n}\nMTGraph\n;\n\nvoid \nSetLine\n(\nMTGraph\n &\nG\n)//初始化站点所在线路对应的序列 \n{\n    \n/*\n    605路        1\n    615路        2\n    402路        3\n    368外环      4 \n    368内环      5\n    400外环      6\n    400快内环    7\n    973路        8\n    135路        9\n    26路         10\n    300快外环    11\n    94路         12\n    34路         13\n    200外环      14\n    671路        15\n    */\n\n     int i;\n     \nG\n.\nVerList\n[\n0\n].linenum[\n0\n] = \n3\n; \nG\n.\nVerList\n[\n0\n].linenum[\n1\n] = \n4\n; \nG\n.\nVerList\n[\n0\n].linenum[\n2\n] = \n5\n; \nG\n.\nVerList\n[\n0\n].linenum[\n3\n] = \n11\n; \nG\n.\nVerList\n[\n0\n].linenum[\n4\n] = \n15\n;\n     \nG\n.\nVerList\n[\n1\n].linenum[\n0\n] = \n3\n; \nG\n.\nVerList\n[\n1\n].linenum[\n1\n] = \n4\n; \nG\n.\nVerList\n[\n1\n].linenum[\n2\n] = \n5\n; \nG\n.\nVerList\n[\n1\n].linenum[\n3\n] = \n11\n; \nG\n.\nVerList\n[\n1\n].linenum[\n4\n] = \n3\n;\n     \nG\n.\nVerList\n[\n2\n].linenum[\n0\n] = \n4\n; \nG\n.\nVerList\n[\n2\n].linenum[\n1\n] = \n5\n; \nG\n.\nVerList\n[\n2\n].linenum[\n2\n] = \n8\n; \nG\n.\nVerList\n[\n2\n].linenum[\n3\n] = \n11\n; \nG\n.\nVerList\n[\n2\n].linenum[\n4\n] = \n4\n;\n     \nG\n.\nVerList\n[\n3\n].linenum[\n0\n] = \n4\n; \nG\n.\nVerList\n[\n3\n].linenum[\n1\n] = \n5\n; \nG\n.\nVerList\n[\n3\n].linenum[\n2\n] = \n8\n; \nG\n.\nVerList\n[\n3\n].linenum[\n3\n] = \n11\n; \nG\n.\nVerList\n[\n3\n].linenum[\n4\n] = \n4\n;\n    //\n15\n\n    for(i=\n391\n;i<=\n404\n;i++){\n        \nG\n.\nVerList\n[i].linenum[\n0\n]=\n15\n;\nG\n.\nVerList\n[i].linenum[\n1\n]=\n15\n;\nG\n.\nVerList\n[i].linenum[\n2\n]=\n15\n;\nG\n.\nVerList\n[i].linenum[\n3\n]=\n15\n;\nG\n.\nVerList\n[i].linenum[\n4\n]=\n15\n;\n    }\n}\n\nvoid \nGetline\n(\nMTGraph\n &\nG\n) //读入线路 名称 \n{\n      int i=\n0\n;\n      ifstream ifp; \n      ifp.open(\n\"bus_Rname.txt\"\n,ios::in);\n      while(!ifp.eof())                    // 如果未读完，继续读文本      eof end of file\n      {                                  \n          ifp>>\nG\n.line[i].linename;       //\n          i++;\n      } \n      ifp.close();\n}\n\nvoid \nCreateGraph_2\n(\nMTGraph\n& \nG\n)//初始化一般时间段 \n{\n    \nGetline\n(\nG\n);\n    \nSetLine\n(\nG\n);//读入线路信息     \n    int i;\n    \nG\n.n = \n0\n;\n    \nG\n.e = \n0\n;\n    int j = \n0\n;\n    ifstream ifp;\n    ifp.open(\n\"bus_name.txt\"\n, ios::in);\n    while (!ifp.eof())\n    {\n        ++\nG\n.n;\n        ifp >> \nG\n.\nVerList\n[j].name;//读入站点相关信息 \n        j++;\n    }\n    ifp.close();\n    for (i = \n0\n; i < \nG\n.n; i++)\n    {\n        for (j = \n0\n; j < \nG\n.n; j++)\n        {\n            \nG\n.\nEdge\n[i][j] = \nINFINITY\n;//权值初始化 \n        }\n        \nG\n.\nEdge\n[i][i] = \n0\n;\n    }\n    int v1, v2, w;\n    \nFILE\n* fp2;\n    fp2=fopen(\n\"bus_time.txt\"\n, \n\"r\"\n);\n    if (\nNULL\n == fp2) printf(\n\"文件打开失败\"\n);\n    else\n    {\n        while (!feof(fp2))\n        {\n            fscanf(fp2, \n\"%d %d %d\"\n, &v1, &v2, &w);//读入边权值 \n            \nG\n.\nEdge\n[v1][v2] = w;\n            \nG\n.\nEdge\n[v2][v1] = w;\n            ++\nG\n.e;\n        }\n        fclose(fp2);\n    }\n}\n\nint \nGetnum\n(\nMTGraph\n& \nG\n, char* a)//取得站点对应下标 \n{\n    int i = \n0\n;\n    while (i < \nG\n.n)\n    {\n        if (strcmp(\nG\n.\nVerList\n[i].name, a) == \n0\n)\n        {\n            return i;\n            break;\n        }\n        else\n            i++;\n    }\n    if (i >= \nG\n.n)\n        return \n-1\n;\n}\n\n\nvoid \nShortestPath\n(\nMTGraph\n &\nG\n,\nPathmatrix\n \nP\n,\nShortPathTable\n \nD\n)//求最短路径 \n{\n    int trans[\n118\n]; \n    char a[\n20\n],b[\n20\n];\n    int i,j,v,w,k,m,n,p,q,r,t,\nT\n;\n    char s;\n    for(i=\n-1\n;i<\n118\n;i++)\n    {\n        trans[i]=i;//对比是否为换乘 \n    }\n    for(v=\n0\n;v<\nG\n.n;v++)//初始化\nD\n与\nP\n \n    {\n        for(w=\n0\n;w<\nG\n.n;w++)\n        {\n           \nD\n[v][w]=\nG\n.\nEdge\n[v][w];//\nD\n值为对应权值 \n           \nP\n[v][w]=w;//初始化\nP\n                  \n        }                  \n    }    \n    for(k=\n0\n;k<\nG\n.n;k++)\n    {\n        for(v=\n0\n;v<\nG\n.n;v++)\n        {\n           for(w=\n0\n;w<\nG\n.n;w++)\n           {\n               if(\nD\n[v][w]>\nD\n[v][k]+\nD\n[k][w])//如果经过下标为k顶点路径比原两点间路径更短，将当前权值设为更小的 \n               {\n                   \nD\n[v][w]=\nD\n[v][k]+\nD\n[k][w];// \n                   \nP\n[v][w]=\nP\n[v][k];//路径设置经过下标为k的顶点                           \n               }\n           }\n        }                  \n    }//\nFloyd\n算法求最小路径 \n  while(\n1\n)\n  {\n    cout<>>>>>>>>请输入起点站：\"\n;\n            cin>>a;\n            v=\nGetnum\n(\nG\n,a);\n            if(v==\n-1\n)\n            cout<<\n\"站点不存在请重新输入！\"\n<>>>>>>>>请输入终点站：\"\n;\n            cin>>b;\n            w=\nGetnum\n(\nG\n,b); \n            if(w==\n-1\n)\n            cout<<\n\"站点不存在请重新输入！\"\n<>>>>>>>>用时最短路径: \"\n<>>>>>>>> ->在 \"\n<<\nG\n.\nVerList\n[v].name<<\n\" 乘 \"\n<<\nG\n.line[p\n-1\n].linename<<\n\" (\"\n<<\nG\n.\nVerList\n[k].name<<\n\"方向)\"\n<>>>>>>>> ->距离为\"\n<<\nD\n[r][k]<<\n\"米，用时约\"\n<>>>>>>>> ->距离为\"\n<<\nD\n[r][w]<<\n\"米，用时约\"\n<>>>>>>>>总里程为\"\n<<\nD\n[v][w]<<\n\"米，考虑换乘以及等车一共约用时为：\"\n<>>>>>>>>是否继续查询？（Y/N）\"\n;\n    scanf(\n\"%s\"\n,&s);\n    if(s!=\n'y'\n&&s!=\n'Y'\n)\n    break;\n    else\n    system(\n\"cls\"\n);\n    }                \n}\n\nint main()\n{\n    \nMTGraph\n \nG1\n,\nG2\n,\nG3\n;\n    char a,d;\n    int c; \n    char b[\n10\n];\n\n\n     scanf(\n\"%s\"\n,&d);\n     system(\n\"cls\"\n);\n               if(d==\n'2'\n)\n              { \n                      \nCreateGraph_2\n(\nG2\n);\n                      \nPathmatrix\n \nP\n;\n                      \nShortPathTable\n \nD\n;\n                      \nShortestPath\n(\nG2\n,\nP\n,\nD\n);\n                      printf(\n\"\\n\"\n);\n                      printf(\n\"请按Enter键返回上一级菜单\"\n);\n                      \n_getch\n();\n                      system(\n\"cls\"\n);\n                      \n              }           \nreturn \n0\n;\n}\n\n\n\n初始定义了一个结构体中的数组，大小为405，在dev上能够正常运行，但在VS2019上则出现异常。\n\n", "Tag": "算法分析"}
