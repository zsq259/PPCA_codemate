{"Answer": "不行。因为各种路径的 步数并不一定相同。所有边权值加正数，只有在各种路径步数相同的情况下才可行。求带负权值边的单源最短路径可以用贝尔曼-福特算法。", "Konwledge_Point": "Dijkstra算法", "Question": "迪杰斯特拉算法带负权值，每条边权值同时加上一个数全都变为正数，再用迪杰斯特拉算法 这样对吗\n迪杰斯特拉算法带负权值，每条边权值同时加上一个数全都变为正数，再用迪杰斯特拉算法 这样对吗", "Tag": "算法分析"}
{"Answer": "邻接表你可以理解为多个链表，每个链表的头是一个节点，而你添加一条边add（a,b,c）相当于给a增添一个出度b长度为c，而 next[a]中储存的是就是a所有的出度的地址，next存储的是下一个出度的地址，ver[i]就是出度点的标号，edge[i]头节点到出度的距离，dj的基本思路是每次选取一个离原点最近的边来更新其他点的距离，我们先将{0，1}加入堆中，堆排序pair根据first优先原则，所以意思就是堆中1号点到一号点的距离为0，那么此时会用1号点先更新它出度，并且每个点有且只会被加入一次，我们将它打上标记，如果堆中已经加入过这个最短边，我们直接将它continue，否则而循环的终点就是没有边再被更新的时候，也就是没有东西可以入队了，循环结束。", "Konwledge_Point": "Dijkstra算法", "Question": "Dijkstra算法及邻接表 C++\npriority_queue>q;\n//大根堆-小根堆\n\n    \nmemset\n(d,\n0x3f\n,\nsizeof\n(d);\n    \nmemset\n(v,\n0\n,\nsizeof\n(v));\n    d[\n1\n]=\n0\n;\n    q.\npush\n(\nmake_pair\n(\n0\n,\n1\n));\n    \nwhile\n(q.\nsize\n())\n    \nint\n x=q.\ntop\n().second;q.\npop\n();\n    \nif\n(v[x])\ncontinue\n;\n    v[x]=\n1\n;\n    \nfor\n(\nint\n i=head[x];i;i=Next[i])\n    \nint\n y=ver[i],z=edge[i];\n    \nif\n(d[y]>d[x]+z){\n        d[y]=d[x]+z;\n        q.\npush\n(\nmake_pair\n(-d[y],y));\n    }\n    } \n\n\n\n如上，请问一下：\n\n\nwhile\n(q.\nsize\n())\n\nif\n(v[x])\ncontinue\n;\n\nfor\n(\nint\n i=head[x];i;i=\nNext\n[i])\n\n\n\n各是什么意思？还有邻接表的原理是什么？麻烦了！", "Tag": "算法分析"}
{"Answer": "可以有偿啊，大神快来啊![图片说明](http://forum.csdn.net/PointForum/ui/scripts/csdn/Plugin/001/face/9.gif)![图片说明](http://forum.csdn.net/PointForum/ui/scripts/csdn/Plugin/001/face/9.gif)", "Konwledge_Point": "Dijkstra算法", "Question": "OPNET卫星网络路由算法仿真\n最近要交毕设啦，OPNET的卫星网络路由仿真还不会做，求大神指导啊，真的很着急。算法主要\n\n是收集链路状态信息，比如时延、带宽、丢包率，然后归一化到[0,1]，分配权重作为\n\n链路的Cost，然后用Dijkstra算法。\n\n求指导啊，怎么做仿真，呜呜呜~", "Tag": "算法分析"}
{"Answer": "基于最新版ChatGPT4的回答，望采纳!!!有其他问题也可以询问我哦、”(最新版更智能，功能更加强大)\n为了解决这个问题，我们需要修改Dijkstra算法，使其最大化概率乘积而不是最小化权重和。我们将进行以下更改：\n初始化时，将源节点的距离设置为1，而不是0。在寻找最小距离的节点时，寻找具有最大距离的节点。在更新节点的距离时，使用概率乘积而不是权重和。\n以下是修改后的dijkstra.c文件中的代码：\n// DSA Programming task 4.2 - Dijsktra\n// You work on this file where TODO is located\n#include <stdio.h>\n#include <stdlib.h>\n#include \"dijkstra.h\"\n\n// Initializes graph for Dijkstra\nvoid init_graph(weightedgraph* g, int vertices){\n    g->nVertices = vertices;\n    int i;\n    for(i=1; i <= vertices; i++) {\n        g->adj_list[i] = 0;\n        g->pred[i] = 0;\n        // TODO! Note the distance\n        g->dist[i] = 0.0;\n    }\n}\n\n// ...\n\n// Dijkstra search from node s\nvoid dijkstra(weightedgraph* g, int s){\n    int queue[MAXVERTS];\n    int i=0;\n\n    // Initialize graph\n    for(i=1; i <= g->nVertices; i++) {\n        g->pred[i] = 0;\n        g->dist[i] = 0.0;\n        // All vertices in queue\n        queue[i] = i;\n    }\n\n    // TODO! Modification should start from here\n    //       Note that the propability should be maximized\n    //       Chanage names of variables accordingly\n    g->dist[s] = 1.0;\n\n    for(i=g->nVertices; i >= 1; i--) {\n        // Search for maximum from the queue\n        double maxval = g->dist[queue[1]];\n        int maxnode = queue[1];\n        int maxj=1;\n        for(int j = 1; j <= i; j++) {\n            if( g->dist[queue[j]] > maxval ){\n                maxval = g->dist[queue[j]];\n                maxnode = queue[j];\n                maxj = j;\n            }\n        }\n\n        // Switches the maximum to end (out of the queue)\n        int temp = queue[i];\n        queue[i] = queue[maxj];\n        queue[maxj] = temp;\n\n        pweightededgenode pedge = g->adj_list[maxnode];\n\n        // Relax the neighbors\n        while(pedge != 0){\n            int v = pedge->nodenum;\n            if(g->dist[v] < (g->dist[maxnode]*pedge->weight))  {\n                g->dist[v] = g->dist[maxnode]*pedge->weight;\n                g->pred[v] = maxnode;\n            }\n            pedge = pedge->next;\n        }\n\n        // DEBUG INFO:\n        // printf(\"%d processed: d[%d] = %f\\n\",maxnode,maxnode,g->dist[maxnode]);\n    }\n}\n//No need to change anyting after this point!\n\n// ...\n\n使用此修改后的算法，您将能够找到具有最佳概率传递消息的路径。在给定示例中，该算法将找到从站1到站8的最佳路径。我们将使用修改过的Dijkstra算法计算给定图中从节点1到节点8的最佳传输路径。请确保您使用了上述提供的修改后的dijkstra.c文件代码。使用此修改后的算法，您可以通过运行main.c文件找到所需的路径。\n现在，我们已经修改了Dijkstra算法以解决您的问题，您可以运行main.c文件，以找到从站1到站8的最佳传输路径。在您提供的示例中，该算法将找到具有最佳概率传递消息的路径。\n请注意，修改后的Dijkstra算法可以适用于您的问题。但是，在特定情况下，这种方法可能不是最有效的。例如，对于具有大量节点和边的大型网络，这种方法可能需要更多的计算资源和时间。在这种情况下，可以考虑使用其他更高效的算法，如A*搜索算法或其他启发式搜索方法。\n如果您有其他关于Dijkstra算法或其他算法的问题，请随时提问。", "Konwledge_Point": "Dijkstra算法", "Question": "c语言，修改基于第一个图的旧算法算法以解决新的问题，并将新算法用于最后一张图\n有一个关于Dijkstra的无向图算法的实现，队列的处理简单，使算法的时间复杂度为𝛩(𝑛2),n是图中的节点数,将该算法应用于无向算法,下面是最初使用的加权图\n\n\n\n\n修改算法以解决下列问题：\n在一个链路网络中，有n个基站，我们可以在它们之间传输消息，一个网络包含n个互相传输信息的站点t1, t2, …, tn,由于干扰，消息可能在传输过程中被损坏。对于每一对站点，我们都知道消息被正确传输的概率（一个在0到1之间的实数）。 我们打算从t1站到tn站。设计一种算法来找到站点的路径，以最佳的概率传递消息.请注意，当一个消息通过一系列站点传输时，没有错误地传递它的概率是序列中概率的乘积。\n例子，在下图中，有三个站点和给定的概率\n通过v从t向u传递信息比直接传递信息更好，因为直接传递信息概率为0.5，而通过v的概率为0.7 × 0.8 = 0.56 > 0.50\n\n\n因此，应该修改给定的算法而不是边的和。我们考虑乘积，并选择最大值（而不是像原始算法中那样的最小值）\n\n\n将该算法应用于以下网络，其中边的权值为概率。该消息将从站1传送到站8，以此图用作新的算法。\n\n\ndijkstra.不需要修改\n\n\n// DSA Programming task 4.2 - Dijkstra\n\n\n// You do not need to change anything here\n\n\n\n#\nifndef\n DIJKSTRA_H_INCLUDED\n\n\n#\ndefine\n DIJKSTRA_H_INCLUDED\n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n\n// Maximum number of vertices\n\n\n// define according to your needs\n\n\n#\ndefine\n MAXVERTS 1000\n\n\n\n// Nodes are numbered as integers from 1\n\n\n\n// Maximum value in the distance table\n\n\n#\ndefine\n INF DBL_MAX\n\n\n\n// Defines edge in the adjacency list\n\n\ntypedef\n \nstruct\n \nweightedgnd\n {\n    \nint\n nodenum;\n    \ndouble\n weight;\n    \nstruct\n \nweightedgnd\n* next;\n} weightededgenode, *pweightededgenode;\n\n\n// Defines the graph\n\n\ntypedef\n \nstruct\n \nweightedg\n {\n    pweightededgenode adj_list[MAXVERTS+\n1\n];\n    \nint\n pred[MAXVERTS+\n1\n];\n    \ndouble\n dist[MAXVERTS+\n1\n];\n    \nint\n nVertices;\n} weightedgraph;\n\n\n// Initializes graph for breadth-first search\n\n\nvoid\n \ninit_graph\n(weightedgraph* g, \nint\n vertices)\n;\n\n\n// Adds new edge (x,y)\n\n\nvoid\n \nadd_edge\n(weightedgraph* g, \nint\n x, \nint\n y, \ndouble\n wght)\n;\n\n\n// Actual breadth-first search from node s\n\n\nvoid\n \ndijkstra\n(weightedgraph* g, \nint\n s)\n;\n\n\n// Frees allocated memory\n\n\nvoid\n \ndelete_graph\n(weightedgraph* g, \nint\n vertices)\n;\n\n\n// Print a path after search\n\n\nvoid\n \nprint_path\n(weightedgraph* g, \nint\n dest)\n;\n\n\n#\nendif\n\n\n\n\n\nmain.c，不需要修改\n\n\n// DSA Programming task 4.2 - Dijkstra\n\n\n// You do not need to change anything here\n\n\n#\ninclude\n \n#\ninclude\n \n\"dijkstra.h\"\n\n\n\nint\n main\n()\n{\n    weightedgraph g;\n    init\n_graph(&\ng\n,8)\n;\n\n    add\n_edge(&\ng\n,1,2,1)\n;\n    add\n_edge(&\ng\n,1,4,7)\n;\n    add\n_edge(&\ng\n,1,5,3)\n;\n\n    add\n_edge(&\ng\n,2,3,1)\n;\n    add\n_edge(&\ng\n,3,4,2)\n;\n    add\n_edge(&\ng\n,5,6,3)\n;\n\n    add\n_edge(&\ng\n,6,7,3)\n;\n    add\n_edge(&\ng\n,6,8,3)\n;\n\n    \n// The other graph\n\n    add\n_edge(&\ng\n,2,4,2)\n;\n    add\n_edge(&\ng\n,4,6,2)\n;\n\n    dijkstra(&g,\n1\n);\n\n    printf(\n\"The path from 1 to 8 with cumulative weights:\\n\"\n);\n    print\n_path(&\ng\n,8)\n;\n\n    delete\n_graph(&\ng\n,8)\n;\n\n    return \n0\n;\n}\n\n\n\n\ndijkstra.c只对有TODO的部分进行修改（即为void init_graph函数的TODO部分和void dijkstra的TODO部分），具体修改要求详情见代码部分的注释\n\n\n// DSA Programming task 4.2 - Dijsktra\n\n\n// You work on this file where TODO is located\n\n#include \n#include \n#include \n\"dijkstra.h\"\n\n\n\n// Initializes graph for Dijkstra\n\nvoid init_graph(weightedgraph* g, int vertices){\n    \ng\n->\nnVertices = vertices;\n    int i;\n    \nfor\n(i=\n1\n; i <= vertices; i++) {\n        \ng\n->\nadj_list[i] = \n0\n;\n        \ng\n->\npred[i] = \n0\n;\n        \n// TODO! Note the distance\n\n        \ng\n->\ndist[i] = INF;\n    }\n}\n\n\n// Adds new edge (x,y)\n\nvoid add_edge(weightedgraph* g, int x, int y, double wght){\n    \nif\n( x <= g->\nnVertices\n && y <= g->\nnVertices){\n        pweightededgenode pxy = malloc(sizeof(weightededgenode));\n        pweightededgenode pyx = malloc(sizeof(weightededgenode));\n\n        \npxy\n->\nnodenum = y;\n        \npxy\n->\nnext\n = g->\nadj_list[x];\n        \npxy\n->\nweight = wght;\n        \ng\n->\nadj_list[x] = pxy;\n\n        \npyx\n->\nnodenum = x;\n        \npyx\n->\nnext\n = g->\nadj_list[y];\n        \npyx\n->\nweight = wght;\n        \ng\n->\nadj_list[y] = pyx;\n    }\n}\n\n\n\n/*\n   Dijkstra's algorithm:\n   DIJKSTRA(G,w,s)\n   for each vertex v in V\n      d[v] = INF\n      p[v] = NIL\n   d[s] = 0\n   S = EMPTY\n   Q = V[G]\n   while Q != EMPTY\n         u =  EXTRACT-MIN(Q)\n         S = S UNION {u}\n         for each vertex v in Adj[u] do\n            if d[v] > d[u] + w(u,v) then\n               d[v] = d[u] + w(u,v)\n               p[v] = u\n*/\n\n\n\n// Dijkstra search from node s\n\nvoid dijkstra(weightedgraph* g, int s){\n    int queue[MAXVERTS];\n    int i=\n0\n;\n\n    \n// Initialize graph\n\n    \nfor\n(i=1; i <= g->\nnVertices; i++) {\n        \ng\n->\npred[i] = \n0\n;\n        \ng\n->\ndist[i] = INF;\n        \n// All vertices in queue\n\n        queue[i] = i;\n    }\n\n    \n// TODO! Modification should start from here\n\n    \n//       Note that the propability should be maximized\n\n    \n//       Chanage names of variables accordingly\n\n    \ng\n->\ndist[s] = \n0\n;\n\n    \nfor\n(i=g->\nnVertices; i >= \n1\n; i--) {\n        \n// Search for minimum from the queue\n\n        \ndouble\n minval = g->\ndist[queue[\n1\n]];\n        int minnode = queue[\n1\n];\n        int minj=\n1\n;\n        \nfor\n(int j = \n1\n; j <= i; j++) {\n            \nif\n( g->\ndist[queue[j]] < minval ){\n                \nminval\n = g->\ndist[queue[j]];\n                minnode = queue[j];\n                minj = j;\n            }\n        }\n\n        \n// Switches the minimum to end (out of the queue)\n\n        int temp = queue[i];\n        queue[i] = queue[minj];\n        queue[minj] = temp;\n\n        \npweightededgenode\n pedge = g->\nadj_list[minnode];\n\n        \n// Relax the neighbors\n\n        \nwhile\n(pedge != \n0\n){\n            \nint\n v = pedge->\nnodenum;\n            \nif\n(g->\ndist\n[v] > (g->\ndist\n[minnode]+pedge->\nweight))  {\n                \ng\n->\ndist\n[v] = g->\ndist\n[minnode]+pedge->\nweight;\n                \ng\n->\npred[v] = minnode;\n            }\n            \npedge\n = pedge->\nnext;\n        }\n\n        \n// DEBUG INFO:\n\n        \n// printf(\"%d processed: d[%d] = %f\\n\",minnode,minnode,g->dist[minnode]);\n\n    }\n}\n\n//No need to change anyting after this point!\n\n\n\n// Free allocated memory\n\nvoid delete_graph(weightedgraph* g, int vertices){\n    int i;\n    \nfor\n(i=\n1\n; i <= vertices; i++) {\n        \npweightededgenode\n pedge = g->\nadj_list[i];\n        pweightededgenode pnext = \n0\n;\n\n        \nwhile\n(pedge != \n0\n) {\n            \npnext\n = pedge->\nnext;\n            free(pedge);\n            pedge = pnext;\n        }\n    }\n}\n\n\n// Print a path after search\n\nvoid print_path(weightedgraph* g, int dest){\n    \nif\n( g->\npred[dest] != \n0\n){\n        \nprint_path\n(g, g->\npred[dest]);\n        \nprintf\n(\"%d:%f\\n\",dest,g->\ndist[dest]);\n    }\n    \nelse\n \nif\n(g->\ndist[dest]==\n0\n){\n        \nprintf\n(\"%d:%f\\n\",dest,g->\ndist[dest]);\n    }\n}\n\n\n\n", "Tag": "算法分析"}
{"Answer": "\nIf you're just starting with Go I would recommend sticking with the standard library for a bit and not adding more to your learning curve. Try to implement a simple graph data structure with some basic algorithms - it's very easy, and will let you practice with the language. Later on when you need more performance/features, you can look around for libraries (gonum or others). For example, a simple graph can be represented with:\n// Node is a node in the graph; it has a (unique) ID and a sequence of\n// edges to other nodes.\ntype Node struct {\n    Id    int64\n    Edges []int64\n}\n\n// Graph contains a set of Nodes, uniquely identified by numeric IDs.\ntype Graph struct {\n    Nodes map[int64]Node\n}\n\n", "Konwledge_Point": "Dijkstra算法", "Question": "在Go中使用Gonum进行图算法\n\n\n\nI am a new Go programmer, just finished the \"A tour of Go\" tutorial a couple days ago. I want to create a graph of a 150 x 120 size and then get all the edge nodes for each node and implement some graph search algorithms such as BFS and Dijkstra. I found a great looking library called Gonum with a \ngraph package\n  that looks promising to use. \n\n\n\nMy problem is that it is a lot of information and I don't know where to get started. I was hoping there would be a tutorial of some sorts to get me started in the right direction, but I haven't had any luck finding one. \n\n\n\nThe way I set this up in Python was making a numpy arrays of zero's to represent the size of the graph and then iterate through it to get each edge for each node, but I am not sure that this is the best way to think about how graphs are set up in Go. \n\n    ", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/qq_29320587/article/details/104842330", "Konwledge_Point": "Dijkstra算法", "Question": "ROS在进行导航时，出现一直下发角速度和线速度为0的情况\n\n\n\n如图所示，在存在路径规划的情况下，一直下发线速度和角速度为0 的情况。\n\n\n\n\n\n局部规划采用的是DWA算法\n\n\n全局规划采用的是Dijkstra.\n\n\n膨胀系数设置是15厘米。\n小车放置在一个空旷区域\n\n", "Tag": "算法分析"}
{"Answer": "应该是没有visited数组标记的问题，存边是存双向边，需要标记visited（有时也叫used）数组进行标记这个点已经到达过了", "Konwledge_Point": "Dijkstra算法", "Question": "洛谷P1462 dij的问题\nhttps://www.luogu.com.cn/problem/P1462\n\n\nhttps://www.luogu.com.cn/record/78581018\n\n\n只对了3个点，都是无解点，也就是说dij可能不对\n\n\n#\ninclude\n\n\n\n#\ndefine\n INF 0x3f3f3f3f\n\n\nusing\n \nnamespace\n std;\n\nconst\n \nint\n MAXN=\n10008\n;\n\ntypedef\n pair<\nint\n,\nint\n> pi;\npriority_queue< pi,vector,greater > q;\n\nint\n n,m,b;\n\nint\n f[MAXN],dis[MAXN];\n\nstruct\n \nnode\n{\n    \nint\n v,w;\n};\nvector a[MAXN];\n\nbool\n vis[MAXN];\n\nint\n l=INT_MAX,r=INT_MIN,mid;\n\nbool\n \ndijkstra\n(\nint\n st)\n{\n    \nmemset\n(vis,\n0\n,\nsizeof\n(vis));\n    \nmemset\n(dis,INF,\nsizeof\n(dis));\n    dis[\n1\n]=st;\n    q.\npush\n({\nmake_pair\n(dis[\n1\n],\n1\n)});\n    \nwhile\n(!q.\nempty\n()){\n        \nint\n x=q.\ntop\n().second;\n        q.\npop\n();\n        \nif\n(vis[x]) \ncontinue\n;\n        vis[x]=\ntrue\n;\n        \nfor\n(\nint\n i=\n0\n;i<a[x].\nsize\n();i++){\n            \nint\n y=a[x][i].v,z=a[x][i].w;\n            dis[y]=\nmin\n(dis[y],dis[x]+z);\n            q.\npush\n(\nmake_pair\n(dis[y],y));\n        }\n    }\n    \nreturn\n dis[n]<b;\n}\n\nint\n \nmain\n()\n{\n    \nscanf\n(\n\"%d%d%d\"\n,&n,&m,&b);\n    \nfor\n(\nint\n i=\n1\n;i<=n;i++){\n        \nscanf\n(\n\"%d\"\n,&f[i]);\n        l=\nmin\n(l,f[i]);\n        r=\nmax\n(r,f[i]);\n    }\n    \nint\n maxi=r;\n    \nfor\n(\nint\n i=\n1\n;i<=n;i++){\n        \nint\n u,v,w;\n        \nscanf\n(\n\"%d%d%d\"\n,&u,&v,&w);\n        a[u].\npush_back\n({v,w});\n        a[v].\npush_back\n({u,w});\n    }\n    \nwhile\n(l<=r){\n        mid=(l+r)/\n2\n;\n        \nif\n(\ndijkstra\n(mid)) r=mid\n-1\n;\n        \nelse\n l=mid+\n1\n;\n    }\n    \nif\n(l==maxi+\n1\n) \n        \nprintf\n(\n\"AFK\\n\"\n);\n    \nelse\n\n        \nprintf\n(\n\"%d\\n\"\n,l);\n    \nreturn\n \n0\n;\n}\n\n\n\n\n求给出以如上代码改对了的代码或修改方式，谢谢", "Tag": "算法分析"}
{"Answer": "我试着照着你的deque输出的代码写了一个测试，可以正常输出，所以问题应该不在这里", "Konwledge_Point": "Dijkstra算法", "Question": "问题：为什么用deque反向输出会报错而用递归反向输出没问题\nhttp://poj.org/problem?id=2457\n（由于题目是英文，以下图片时中文翻译后的图片）\nhttps://img-mid.csdnimg.cn/release/static/image/mid/ask/800335390746158.png?x-oss-process=image/auto-orient,1\nhttps://img-mid.csdnimg.cn/release/static/image/mid/ask/394075390746180.png?x-oss-process=image/auto-orient,1\n\n\n（由于题目是英文，以下图片时中文翻译后的图片）\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\nconst\n \nint\n  N=\n1e5\n+\n10\n,M=\n2e5\n+\n10\n;\n\ntypedef\n pair<\nint\n,\nint\n> PII;\n\nint\n dis[N],k,head[N],n,idx,m,s=\n1\n,t,vis0[N];\n\nbool\n vis[N];\n\nstruct\n \nEdge\n{\n    \nint\n to,w,next;\n}edge[M];\n\nvoid\n \nadd\n(\nint\n a,\nint\n b ,\nint\n c)\n\n\n{\n    edge[idx].to=b,edge[idx].w=c,edge[idx].next=head[a],head[a]=idx++;\n}\n\nvoid\n \ndijkstra\n()\n\n\n{\n    \nmemset\n(dis,\n0x3f\n,\nsizeof\n dis);\n    dis[s]=\n1\n;\n    priority_queue,greater > heap;\n    heap.\npush\n({\n1\n,s});\n\n//    vis0[1]=1;\n\n    \nwhile\n(heap.\nsize\n())\n    {\n        \nint\n vertax = heap.\ntop\n().second;\n        heap.\npop\n();\n        \n        \nif\n(vis[vertax])\ncontinue\n;\n        vis[vertax]=\ntrue\n;\n\n//        cout<dis[vertax]+edge[i].w)\n            {\n                dis[j]=dis[vertax]+edge[i].w;\n                vis0[j]=vertax;\n                heap.\npush\n({dis[j],j});\n            }\n        }\n        \n    }\n}\ndeque<\nint\n> stars;\n\nvoid\n \nprint_stars\n()\n\n\n{\n \n    \n    stars.\npush_front\n(n);\n    k=n;\n    \nwhile\n(vis0[k]!=s)\n    {\n        k=vis0[k]; \n        stars.\npush_front\n(k);\n    }\n    stars.\npush_front\n(s);\n}\n\nint\n \nmain\n()\n\n\n{\n    \nint\n a,b,c;\n    \nmemset\n(head,\n-1\n,\nsizeof\n head);\n    cin>>m>>n;\n\n//    if(n==1)\n\n\n//    {\n\n\n//        cout<<\"1\"<<'\\n'<<\"1\"<<'\\n';\n\n\n//    }\n\n\n//    else{\n\n    \n        \nfor\n(\nint\n i=\n1\n;i<=m;i++)\n        {\n            cin>>a>>b;\n            c=\n1\n;\n            \nadd\n(a,b,c);\n\n//            add(b,a,c);\n\n        }\n        \ndijkstra\n();\n        \nif\n(dis[n]==\n0x3f3f3f3f\n)\n        {\n            cout<<\n\"-1\"\n;\n        }\n        \nelse\n{\n            cout<\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\nconst\n \nint\n  N=\n1e5\n+\n10\n,M=\n2e5\n+\n10\n;\n\ntypedef\n pair<\nint\n,\nint\n> PII;\n\nint\n dis[N],k,head[N],n,idx,m,s=\n1\n,t,vis0[N];\n\nbool\n vis[N];\n\nstruct\n \nEdge\n{\n    \nint\n to,w,next;\n}edge[M];\n\nvoid\n \nadd\n(\nint\n a,\nint\n b ,\nint\n c)\n\n\n{\n    edge[idx].to=b,edge[idx].w=c,edge[idx].next=head[a],head[a]=idx++;\n}\n\nvoid\n \ndijkstra\n()\n\n\n{\n    \nmemset\n(dis,\n0x3f\n,\nsizeof\n dis);\n    dis[s]=\n0\n;\n    priority_queue,greater > heap;\n    heap.\npush\n({\n0\n,s});\n\n//    vis0[1]=1;\n\n    \nwhile\n(heap.\nsize\n())\n    {\n        \nint\n vertax = heap.\ntop\n().second;\n        heap.\npop\n();\n        \n        \nif\n(vis[vertax])\ncontinue\n;\n        vis[vertax]=\ntrue\n;\n\n//        cout<dis[vertax]+edge[i].w)\n            {\n                dis[j]=dis[vertax]+edge[i].w;\n                vis0[j]=vertax;\n                heap.\npush\n({dis[j],j});\n            }\n        }\n        \n    }\n}\n\n//deque stars;\n\n\n//void print_stars()\n\n\n//{\n\n\n//\n\n\n//    \n\n\n//    stars.push_front(n);\n\n\n//    k=n;\n\n\n//    while(vis0[k]!=s)\n\n\n//    {\n\n\n//        k=vis0[k]; \n\n\n//        stars.push_front(k);\n\n\n//    }\n\n\n//    stars.push_front(s);\n\n\n//}\n\n\nvoid\n \nprintf_path\n(\nint\n vertax)\n\n\n{\n    \nif\n(vis0[vertax] != \n-1\n ) \nprintf_path\n(vis0[vertax]);\n    cout<>m>>n;\n        \nfor\n(\nint\n i=\n1\n;i<=m;i++)\n        {\n            cin>>a>>b;\n            c=\n1\n;\n            \nadd\n(a,b,c);\n\n//            add(b,a,c);    \n\n        }\n    \nif\n(n==\n1\n)\n    {\n        cout<<\n\"1\"\n<<\n'\\n'\n<<\n\"1\"\n<<\n'\\n'\n;\n    }\n    \nelse\n{\n    \n    \n        \ndijkstra\n();\n        \nif\n(dis[n]==\n0x3f3f3f3f\n)\n        {\n            cout<<\n\"-1\"\n;\n        }\n        \nelse\n{\n            cout<<dis[n]+\n1\n<<\n'\\n'\n;\n            \nprintf_path\n(n);\n\n//            while(stars.size())\n\n\n//            {\n\n\n//                cout<<stars.front()<<'\\n';\n\n\n//                stars.pop_front();\n\n\n//            }\n\n        }\n    }\n    \nreturn\n \n0\n;\n}\n\n", "Tag": "算法分析"}
{"Answer": "不行。因为各种路径的 步数并不一定相同。所有边权值加正数，只有在各种路径步数相同的情况下才可行。求带负权值边的单源最短路径可以用贝尔曼-福特算法。", "Konwledge_Point": "Dijkstra算法", "Question": "迪杰斯特拉算法带负权值，每条边权值同时加上一个数全都变为正数，再用迪杰斯特拉算法 这样对吗\n迪杰斯特拉算法带负权值，每条边权值同时加上一个数全都变为正数，再用迪杰斯特拉算法 这样对吗", "Tag": "算法分析"}
{"Answer": "邻接表你可以理解为多个链表，每个链表的头是一个节点，而你添加一条边add（a,b,c）相当于给a增添一个出度b长度为c，而 next[a]中储存的是就是a所有的出度的地址，next存储的是下一个出度的地址，ver[i]就是出度点的标号，edge[i]头节点到出度的距离，dj的基本思路是每次选取一个离原点最近的边来更新其他点的距离，我们先将{0，1}加入堆中，堆排序pair根据first优先原则，所以意思就是堆中1号点到一号点的距离为0，那么此时会用1号点先更新它出度，并且每个点有且只会被加入一次，我们将它打上标记，如果堆中已经加入过这个最短边，我们直接将它continue，否则而循环的终点就是没有边再被更新的时候，也就是没有东西可以入队了，循环结束。", "Konwledge_Point": "Dijkstra算法", "Question": "Dijkstra算法及邻接表 C++\npriority_queue>q;\n//大根堆-小根堆\n\n    \nmemset\n(d,\n0x3f\n,\nsizeof\n(d);\n    \nmemset\n(v,\n0\n,\nsizeof\n(v));\n    d[\n1\n]=\n0\n;\n    q.\npush\n(\nmake_pair\n(\n0\n,\n1\n));\n    \nwhile\n(q.\nsize\n())\n    \nint\n x=q.\ntop\n().second;q.\npop\n();\n    \nif\n(v[x])\ncontinue\n;\n    v[x]=\n1\n;\n    \nfor\n(\nint\n i=head[x];i;i=Next[i])\n    \nint\n y=ver[i],z=edge[i];\n    \nif\n(d[y]>d[x]+z){\n        d[y]=d[x]+z;\n        q.\npush\n(\nmake_pair\n(-d[y],y));\n    }\n    } \n\n\n\n如上，请问一下：\n\n\nwhile\n(q.\nsize\n())\n\nif\n(v[x])\ncontinue\n;\n\nfor\n(\nint\n i=head[x];i;i=\nNext\n[i])\n\n\n\n各是什么意思？还有邻接表的原理是什么？麻烦了！", "Tag": "算法分析"}
{"Answer": "可以有偿啊，大神快来啊![图片说明](http://forum.csdn.net/PointForum/ui/scripts/csdn/Plugin/001/face/9.gif)![图片说明](http://forum.csdn.net/PointForum/ui/scripts/csdn/Plugin/001/face/9.gif)", "Konwledge_Point": "Dijkstra算法", "Question": "OPNET卫星网络路由算法仿真\n最近要交毕设啦，OPNET的卫星网络路由仿真还不会做，求大神指导啊，真的很着急。算法主要\n\n是收集链路状态信息，比如时延、带宽、丢包率，然后归一化到[0,1]，分配权重作为\n\n链路的Cost，然后用Dijkstra算法。\n\n求指导啊，怎么做仿真，呜呜呜~", "Tag": "算法分析"}
{"Answer": "基于最新版ChatGPT4的回答，望采纳!!!有其他问题也可以询问我哦、”(最新版更智能，功能更加强大)\n为了解决这个问题，我们需要修改Dijkstra算法，使其最大化概率乘积而不是最小化权重和。我们将进行以下更改：\n初始化时，将源节点的距离设置为1，而不是0。在寻找最小距离的节点时，寻找具有最大距离的节点。在更新节点的距离时，使用概率乘积而不是权重和。\n以下是修改后的dijkstra.c文件中的代码：\n// DSA Programming task 4.2 - Dijsktra\n// You work on this file where TODO is located\n#include <stdio.h>\n#include <stdlib.h>\n#include \"dijkstra.h\"\n\n// Initializes graph for Dijkstra\nvoid init_graph(weightedgraph* g, int vertices){\n    g->nVertices = vertices;\n    int i;\n    for(i=1; i <= vertices; i++) {\n        g->adj_list[i] = 0;\n        g->pred[i] = 0;\n        // TODO! Note the distance\n        g->dist[i] = 0.0;\n    }\n}\n\n// ...\n\n// Dijkstra search from node s\nvoid dijkstra(weightedgraph* g, int s){\n    int queue[MAXVERTS];\n    int i=0;\n\n    // Initialize graph\n    for(i=1; i <= g->nVertices; i++) {\n        g->pred[i] = 0;\n        g->dist[i] = 0.0;\n        // All vertices in queue\n        queue[i] = i;\n    }\n\n    // TODO! Modification should start from here\n    //       Note that the propability should be maximized\n    //       Chanage names of variables accordingly\n    g->dist[s] = 1.0;\n\n    for(i=g->nVertices; i >= 1; i--) {\n        // Search for maximum from the queue\n        double maxval = g->dist[queue[1]];\n        int maxnode = queue[1];\n        int maxj=1;\n        for(int j = 1; j <= i; j++) {\n            if( g->dist[queue[j]] > maxval ){\n                maxval = g->dist[queue[j]];\n                maxnode = queue[j];\n                maxj = j;\n            }\n        }\n\n        // Switches the maximum to end (out of the queue)\n        int temp = queue[i];\n        queue[i] = queue[maxj];\n        queue[maxj] = temp;\n\n        pweightededgenode pedge = g->adj_list[maxnode];\n\n        // Relax the neighbors\n        while(pedge != 0){\n            int v = pedge->nodenum;\n            if(g->dist[v] < (g->dist[maxnode]*pedge->weight))  {\n                g->dist[v] = g->dist[maxnode]*pedge->weight;\n                g->pred[v] = maxnode;\n            }\n            pedge = pedge->next;\n        }\n\n        // DEBUG INFO:\n        // printf(\"%d processed: d[%d] = %f\\n\",maxnode,maxnode,g->dist[maxnode]);\n    }\n}\n//No need to change anyting after this point!\n\n// ...\n\n使用此修改后的算法，您将能够找到具有最佳概率传递消息的路径。在给定示例中，该算法将找到从站1到站8的最佳路径。我们将使用修改过的Dijkstra算法计算给定图中从节点1到节点8的最佳传输路径。请确保您使用了上述提供的修改后的dijkstra.c文件代码。使用此修改后的算法，您可以通过运行main.c文件找到所需的路径。\n现在，我们已经修改了Dijkstra算法以解决您的问题，您可以运行main.c文件，以找到从站1到站8的最佳传输路径。在您提供的示例中，该算法将找到具有最佳概率传递消息的路径。\n请注意，修改后的Dijkstra算法可以适用于您的问题。但是，在特定情况下，这种方法可能不是最有效的。例如，对于具有大量节点和边的大型网络，这种方法可能需要更多的计算资源和时间。在这种情况下，可以考虑使用其他更高效的算法，如A*搜索算法或其他启发式搜索方法。\n如果您有其他关于Dijkstra算法或其他算法的问题，请随时提问。", "Konwledge_Point": "Dijkstra算法", "Question": "c语言，修改基于第一个图的旧算法算法以解决新的问题，并将新算法用于最后一张图\n有一个关于Dijkstra的无向图算法的实现，队列的处理简单，使算法的时间复杂度为𝛩(𝑛2),n是图中的节点数,将该算法应用于无向算法,下面是最初使用的加权图\n\n\n\n\n修改算法以解决下列问题：\n在一个链路网络中，有n个基站，我们可以在它们之间传输消息，一个网络包含n个互相传输信息的站点t1, t2, …, tn,由于干扰，消息可能在传输过程中被损坏。对于每一对站点，我们都知道消息被正确传输的概率（一个在0到1之间的实数）。 我们打算从t1站到tn站。设计一种算法来找到站点的路径，以最佳的概率传递消息.请注意，当一个消息通过一系列站点传输时，没有错误地传递它的概率是序列中概率的乘积。\n例子，在下图中，有三个站点和给定的概率\n通过v从t向u传递信息比直接传递信息更好，因为直接传递信息概率为0.5，而通过v的概率为0.7 × 0.8 = 0.56 > 0.50\n\n\n因此，应该修改给定的算法而不是边的和。我们考虑乘积，并选择最大值（而不是像原始算法中那样的最小值）\n\n\n将该算法应用于以下网络，其中边的权值为概率。该消息将从站1传送到站8，以此图用作新的算法。\n\n\ndijkstra.不需要修改\n\n\n// DSA Programming task 4.2 - Dijkstra\n\n\n// You do not need to change anything here\n\n\n\n#\nifndef\n DIJKSTRA_H_INCLUDED\n\n\n#\ndefine\n DIJKSTRA_H_INCLUDED\n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n\n// Maximum number of vertices\n\n\n// define according to your needs\n\n\n#\ndefine\n MAXVERTS 1000\n\n\n\n// Nodes are numbered as integers from 1\n\n\n\n// Maximum value in the distance table\n\n\n#\ndefine\n INF DBL_MAX\n\n\n\n// Defines edge in the adjacency list\n\n\ntypedef\n \nstruct\n \nweightedgnd\n {\n    \nint\n nodenum;\n    \ndouble\n weight;\n    \nstruct\n \nweightedgnd\n* next;\n} weightededgenode, *pweightededgenode;\n\n\n// Defines the graph\n\n\ntypedef\n \nstruct\n \nweightedg\n {\n    pweightededgenode adj_list[MAXVERTS+\n1\n];\n    \nint\n pred[MAXVERTS+\n1\n];\n    \ndouble\n dist[MAXVERTS+\n1\n];\n    \nint\n nVertices;\n} weightedgraph;\n\n\n// Initializes graph for breadth-first search\n\n\nvoid\n \ninit_graph\n(weightedgraph* g, \nint\n vertices)\n;\n\n\n// Adds new edge (x,y)\n\n\nvoid\n \nadd_edge\n(weightedgraph* g, \nint\n x, \nint\n y, \ndouble\n wght)\n;\n\n\n// Actual breadth-first search from node s\n\n\nvoid\n \ndijkstra\n(weightedgraph* g, \nint\n s)\n;\n\n\n// Frees allocated memory\n\n\nvoid\n \ndelete_graph\n(weightedgraph* g, \nint\n vertices)\n;\n\n\n// Print a path after search\n\n\nvoid\n \nprint_path\n(weightedgraph* g, \nint\n dest)\n;\n\n\n#\nendif\n\n\n\n\n\nmain.c，不需要修改\n\n\n// DSA Programming task 4.2 - Dijkstra\n\n\n// You do not need to change anything here\n\n\n#\ninclude\n \n#\ninclude\n \n\"dijkstra.h\"\n\n\n\nint\n main\n()\n{\n    weightedgraph g;\n    init\n_graph(&\ng\n,8)\n;\n\n    add\n_edge(&\ng\n,1,2,1)\n;\n    add\n_edge(&\ng\n,1,4,7)\n;\n    add\n_edge(&\ng\n,1,5,3)\n;\n\n    add\n_edge(&\ng\n,2,3,1)\n;\n    add\n_edge(&\ng\n,3,4,2)\n;\n    add\n_edge(&\ng\n,5,6,3)\n;\n\n    add\n_edge(&\ng\n,6,7,3)\n;\n    add\n_edge(&\ng\n,6,8,3)\n;\n\n    \n// The other graph\n\n    add\n_edge(&\ng\n,2,4,2)\n;\n    add\n_edge(&\ng\n,4,6,2)\n;\n\n    dijkstra(&g,\n1\n);\n\n    printf(\n\"The path from 1 to 8 with cumulative weights:\\n\"\n);\n    print\n_path(&\ng\n,8)\n;\n\n    delete\n_graph(&\ng\n,8)\n;\n\n    return \n0\n;\n}\n\n\n\n\ndijkstra.c只对有TODO的部分进行修改（即为void init_graph函数的TODO部分和void dijkstra的TODO部分），具体修改要求详情见代码部分的注释\n\n\n// DSA Programming task 4.2 - Dijsktra\n\n\n// You work on this file where TODO is located\n\n#include \n#include \n#include \n\"dijkstra.h\"\n\n\n\n// Initializes graph for Dijkstra\n\nvoid init_graph(weightedgraph* g, int vertices){\n    \ng\n->\nnVertices = vertices;\n    int i;\n    \nfor\n(i=\n1\n; i <= vertices; i++) {\n        \ng\n->\nadj_list[i] = \n0\n;\n        \ng\n->\npred[i] = \n0\n;\n        \n// TODO! Note the distance\n\n        \ng\n->\ndist[i] = INF;\n    }\n}\n\n\n// Adds new edge (x,y)\n\nvoid add_edge(weightedgraph* g, int x, int y, double wght){\n    \nif\n( x <= g->\nnVertices\n && y <= g->\nnVertices){\n        pweightededgenode pxy = malloc(sizeof(weightededgenode));\n        pweightededgenode pyx = malloc(sizeof(weightededgenode));\n\n        \npxy\n->\nnodenum = y;\n        \npxy\n->\nnext\n = g->\nadj_list[x];\n        \npxy\n->\nweight = wght;\n        \ng\n->\nadj_list[x] = pxy;\n\n        \npyx\n->\nnodenum = x;\n        \npyx\n->\nnext\n = g->\nadj_list[y];\n        \npyx\n->\nweight = wght;\n        \ng\n->\nadj_list[y] = pyx;\n    }\n}\n\n\n\n/*\n   Dijkstra's algorithm:\n   DIJKSTRA(G,w,s)\n   for each vertex v in V\n      d[v] = INF\n      p[v] = NIL\n   d[s] = 0\n   S = EMPTY\n   Q = V[G]\n   while Q != EMPTY\n         u =  EXTRACT-MIN(Q)\n         S = S UNION {u}\n         for each vertex v in Adj[u] do\n            if d[v] > d[u] + w(u,v) then\n               d[v] = d[u] + w(u,v)\n               p[v] = u\n*/\n\n\n\n// Dijkstra search from node s\n\nvoid dijkstra(weightedgraph* g, int s){\n    int queue[MAXVERTS];\n    int i=\n0\n;\n\n    \n// Initialize graph\n\n    \nfor\n(i=1; i <= g->\nnVertices; i++) {\n        \ng\n->\npred[i] = \n0\n;\n        \ng\n->\ndist[i] = INF;\n        \n// All vertices in queue\n\n        queue[i] = i;\n    }\n\n    \n// TODO! Modification should start from here\n\n    \n//       Note that the propability should be maximized\n\n    \n//       Chanage names of variables accordingly\n\n    \ng\n->\ndist[s] = \n0\n;\n\n    \nfor\n(i=g->\nnVertices; i >= \n1\n; i--) {\n        \n// Search for minimum from the queue\n\n        \ndouble\n minval = g->\ndist[queue[\n1\n]];\n        int minnode = queue[\n1\n];\n        int minj=\n1\n;\n        \nfor\n(int j = \n1\n; j <= i; j++) {\n            \nif\n( g->\ndist[queue[j]] < minval ){\n                \nminval\n = g->\ndist[queue[j]];\n                minnode = queue[j];\n                minj = j;\n            }\n        }\n\n        \n// Switches the minimum to end (out of the queue)\n\n        int temp = queue[i];\n        queue[i] = queue[minj];\n        queue[minj] = temp;\n\n        \npweightededgenode\n pedge = g->\nadj_list[minnode];\n\n        \n// Relax the neighbors\n\n        \nwhile\n(pedge != \n0\n){\n            \nint\n v = pedge->\nnodenum;\n            \nif\n(g->\ndist\n[v] > (g->\ndist\n[minnode]+pedge->\nweight))  {\n                \ng\n->\ndist\n[v] = g->\ndist\n[minnode]+pedge->\nweight;\n                \ng\n->\npred[v] = minnode;\n            }\n            \npedge\n = pedge->\nnext;\n        }\n\n        \n// DEBUG INFO:\n\n        \n// printf(\"%d processed: d[%d] = %f\\n\",minnode,minnode,g->dist[minnode]);\n\n    }\n}\n\n//No need to change anyting after this point!\n\n\n\n// Free allocated memory\n\nvoid delete_graph(weightedgraph* g, int vertices){\n    int i;\n    \nfor\n(i=\n1\n; i <= vertices; i++) {\n        \npweightededgenode\n pedge = g->\nadj_list[i];\n        pweightededgenode pnext = \n0\n;\n\n        \nwhile\n(pedge != \n0\n) {\n            \npnext\n = pedge->\nnext;\n            free(pedge);\n            pedge = pnext;\n        }\n    }\n}\n\n\n// Print a path after search\n\nvoid print_path(weightedgraph* g, int dest){\n    \nif\n( g->\npred[dest] != \n0\n){\n        \nprint_path\n(g, g->\npred[dest]);\n        \nprintf\n(\"%d:%f\\n\",dest,g->\ndist[dest]);\n    }\n    \nelse\n \nif\n(g->\ndist[dest]==\n0\n){\n        \nprintf\n(\"%d:%f\\n\",dest,g->\ndist[dest]);\n    }\n}\n\n\n\n", "Tag": "算法分析"}
{"Answer": "\nIf you're just starting with Go I would recommend sticking with the standard library for a bit and not adding more to your learning curve. Try to implement a simple graph data structure with some basic algorithms - it's very easy, and will let you practice with the language. Later on when you need more performance/features, you can look around for libraries (gonum or others). For example, a simple graph can be represented with:\n// Node is a node in the graph; it has a (unique) ID and a sequence of\n// edges to other nodes.\ntype Node struct {\n    Id    int64\n    Edges []int64\n}\n\n// Graph contains a set of Nodes, uniquely identified by numeric IDs.\ntype Graph struct {\n    Nodes map[int64]Node\n}\n\n", "Konwledge_Point": "Dijkstra算法", "Question": "在Go中使用Gonum进行图算法\n\n\n\nI am a new Go programmer, just finished the \"A tour of Go\" tutorial a couple days ago. I want to create a graph of a 150 x 120 size and then get all the edge nodes for each node and implement some graph search algorithms such as BFS and Dijkstra. I found a great looking library called Gonum with a \ngraph package\n  that looks promising to use. \n\n\n\nMy problem is that it is a lot of information and I don't know where to get started. I was hoping there would be a tutorial of some sorts to get me started in the right direction, but I haven't had any luck finding one. \n\n\n\nThe way I set this up in Python was making a numpy arrays of zero's to represent the size of the graph and then iterate through it to get each edge for each node, but I am not sure that this is the best way to think about how graphs are set up in Go. \n\n    ", "Tag": "算法分析"}
{"Answer": "https://blog.csdn.net/qq_29320587/article/details/104842330", "Konwledge_Point": "Dijkstra算法", "Question": "ROS在进行导航时，出现一直下发角速度和线速度为0的情况\n\n\n\n如图所示，在存在路径规划的情况下，一直下发线速度和角速度为0 的情况。\n\n\n\n\n\n局部规划采用的是DWA算法\n\n\n全局规划采用的是Dijkstra.\n\n\n膨胀系数设置是15厘米。\n小车放置在一个空旷区域\n\n", "Tag": "算法分析"}
{"Answer": "应该是没有visited数组标记的问题，存边是存双向边，需要标记visited（有时也叫used）数组进行标记这个点已经到达过了", "Konwledge_Point": "Dijkstra算法", "Question": "洛谷P1462 dij的问题\nhttps://www.luogu.com.cn/problem/P1462\n\n\nhttps://www.luogu.com.cn/record/78581018\n\n\n只对了3个点，都是无解点，也就是说dij可能不对\n\n\n#\ninclude\n\n\n\n#\ndefine\n INF 0x3f3f3f3f\n\n\nusing\n \nnamespace\n std;\n\nconst\n \nint\n MAXN=\n10008\n;\n\ntypedef\n pair<\nint\n,\nint\n> pi;\npriority_queue< pi,vector,greater > q;\n\nint\n n,m,b;\n\nint\n f[MAXN],dis[MAXN];\n\nstruct\n \nnode\n{\n    \nint\n v,w;\n};\nvector a[MAXN];\n\nbool\n vis[MAXN];\n\nint\n l=INT_MAX,r=INT_MIN,mid;\n\nbool\n \ndijkstra\n(\nint\n st)\n{\n    \nmemset\n(vis,\n0\n,\nsizeof\n(vis));\n    \nmemset\n(dis,INF,\nsizeof\n(dis));\n    dis[\n1\n]=st;\n    q.\npush\n({\nmake_pair\n(dis[\n1\n],\n1\n)});\n    \nwhile\n(!q.\nempty\n()){\n        \nint\n x=q.\ntop\n().second;\n        q.\npop\n();\n        \nif\n(vis[x]) \ncontinue\n;\n        vis[x]=\ntrue\n;\n        \nfor\n(\nint\n i=\n0\n;i<a[x].\nsize\n();i++){\n            \nint\n y=a[x][i].v,z=a[x][i].w;\n            dis[y]=\nmin\n(dis[y],dis[x]+z);\n            q.\npush\n(\nmake_pair\n(dis[y],y));\n        }\n    }\n    \nreturn\n dis[n]<b;\n}\n\nint\n \nmain\n()\n{\n    \nscanf\n(\n\"%d%d%d\"\n,&n,&m,&b);\n    \nfor\n(\nint\n i=\n1\n;i<=n;i++){\n        \nscanf\n(\n\"%d\"\n,&f[i]);\n        l=\nmin\n(l,f[i]);\n        r=\nmax\n(r,f[i]);\n    }\n    \nint\n maxi=r;\n    \nfor\n(\nint\n i=\n1\n;i<=n;i++){\n        \nint\n u,v,w;\n        \nscanf\n(\n\"%d%d%d\"\n,&u,&v,&w);\n        a[u].\npush_back\n({v,w});\n        a[v].\npush_back\n({u,w});\n    }\n    \nwhile\n(l<=r){\n        mid=(l+r)/\n2\n;\n        \nif\n(\ndijkstra\n(mid)) r=mid\n-1\n;\n        \nelse\n l=mid+\n1\n;\n    }\n    \nif\n(l==maxi+\n1\n) \n        \nprintf\n(\n\"AFK\\n\"\n);\n    \nelse\n\n        \nprintf\n(\n\"%d\\n\"\n,l);\n    \nreturn\n \n0\n;\n}\n\n\n\n\n求给出以如上代码改对了的代码或修改方式，谢谢", "Tag": "算法分析"}
{"Answer": "我试着照着你的deque输出的代码写了一个测试，可以正常输出，所以问题应该不在这里", "Konwledge_Point": "Dijkstra算法", "Question": "问题：为什么用deque反向输出会报错而用递归反向输出没问题\nhttp://poj.org/problem?id=2457\n（由于题目是英文，以下图片时中文翻译后的图片）\nhttps://img-mid.csdnimg.cn/release/static/image/mid/ask/800335390746158.png?x-oss-process=image/auto-orient,1\nhttps://img-mid.csdnimg.cn/release/static/image/mid/ask/394075390746180.png?x-oss-process=image/auto-orient,1\n\n\n（由于题目是英文，以下图片时中文翻译后的图片）\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\nconst\n \nint\n  N=\n1e5\n+\n10\n,M=\n2e5\n+\n10\n;\n\ntypedef\n pair<\nint\n,\nint\n> PII;\n\nint\n dis[N],k,head[N],n,idx,m,s=\n1\n,t,vis0[N];\n\nbool\n vis[N];\n\nstruct\n \nEdge\n{\n    \nint\n to,w,next;\n}edge[M];\n\nvoid\n \nadd\n(\nint\n a,\nint\n b ,\nint\n c)\n\n\n{\n    edge[idx].to=b,edge[idx].w=c,edge[idx].next=head[a],head[a]=idx++;\n}\n\nvoid\n \ndijkstra\n()\n\n\n{\n    \nmemset\n(dis,\n0x3f\n,\nsizeof\n dis);\n    dis[s]=\n1\n;\n    priority_queue,greater > heap;\n    heap.\npush\n({\n1\n,s});\n\n//    vis0[1]=1;\n\n    \nwhile\n(heap.\nsize\n())\n    {\n        \nint\n vertax = heap.\ntop\n().second;\n        heap.\npop\n();\n        \n        \nif\n(vis[vertax])\ncontinue\n;\n        vis[vertax]=\ntrue\n;\n\n//        cout<dis[vertax]+edge[i].w)\n            {\n                dis[j]=dis[vertax]+edge[i].w;\n                vis0[j]=vertax;\n                heap.\npush\n({dis[j],j});\n            }\n        }\n        \n    }\n}\ndeque<\nint\n> stars;\n\nvoid\n \nprint_stars\n()\n\n\n{\n \n    \n    stars.\npush_front\n(n);\n    k=n;\n    \nwhile\n(vis0[k]!=s)\n    {\n        k=vis0[k]; \n        stars.\npush_front\n(k);\n    }\n    stars.\npush_front\n(s);\n}\n\nint\n \nmain\n()\n\n\n{\n    \nint\n a,b,c;\n    \nmemset\n(head,\n-1\n,\nsizeof\n head);\n    cin>>m>>n;\n\n//    if(n==1)\n\n\n//    {\n\n\n//        cout<<\"1\"<<'\\n'<<\"1\"<<'\\n';\n\n\n//    }\n\n\n//    else{\n\n    \n        \nfor\n(\nint\n i=\n1\n;i<=m;i++)\n        {\n            cin>>a>>b;\n            c=\n1\n;\n            \nadd\n(a,b,c);\n\n//            add(b,a,c);\n\n        }\n        \ndijkstra\n();\n        \nif\n(dis[n]==\n0x3f3f3f3f\n)\n        {\n            cout<<\n\"-1\"\n;\n        }\n        \nelse\n{\n            cout<\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\nconst\n \nint\n  N=\n1e5\n+\n10\n,M=\n2e5\n+\n10\n;\n\ntypedef\n pair<\nint\n,\nint\n> PII;\n\nint\n dis[N],k,head[N],n,idx,m,s=\n1\n,t,vis0[N];\n\nbool\n vis[N];\n\nstruct\n \nEdge\n{\n    \nint\n to,w,next;\n}edge[M];\n\nvoid\n \nadd\n(\nint\n a,\nint\n b ,\nint\n c)\n\n\n{\n    edge[idx].to=b,edge[idx].w=c,edge[idx].next=head[a],head[a]=idx++;\n}\n\nvoid\n \ndijkstra\n()\n\n\n{\n    \nmemset\n(dis,\n0x3f\n,\nsizeof\n dis);\n    dis[s]=\n0\n;\n    priority_queue,greater > heap;\n    heap.\npush\n({\n0\n,s});\n\n//    vis0[1]=1;\n\n    \nwhile\n(heap.\nsize\n())\n    {\n        \nint\n vertax = heap.\ntop\n().second;\n        heap.\npop\n();\n        \n        \nif\n(vis[vertax])\ncontinue\n;\n        vis[vertax]=\ntrue\n;\n\n//        cout<dis[vertax]+edge[i].w)\n            {\n                dis[j]=dis[vertax]+edge[i].w;\n                vis0[j]=vertax;\n                heap.\npush\n({dis[j],j});\n            }\n        }\n        \n    }\n}\n\n//deque stars;\n\n\n//void print_stars()\n\n\n//{\n\n\n//\n\n\n//    \n\n\n//    stars.push_front(n);\n\n\n//    k=n;\n\n\n//    while(vis0[k]!=s)\n\n\n//    {\n\n\n//        k=vis0[k]; \n\n\n//        stars.push_front(k);\n\n\n//    }\n\n\n//    stars.push_front(s);\n\n\n//}\n\n\nvoid\n \nprintf_path\n(\nint\n vertax)\n\n\n{\n    \nif\n(vis0[vertax] != \n-1\n ) \nprintf_path\n(vis0[vertax]);\n    cout<>m>>n;\n        \nfor\n(\nint\n i=\n1\n;i<=m;i++)\n        {\n            cin>>a>>b;\n            c=\n1\n;\n            \nadd\n(a,b,c);\n\n//            add(b,a,c);    \n\n        }\n    \nif\n(n==\n1\n)\n    {\n        cout<<\n\"1\"\n<<\n'\\n'\n<<\n\"1\"\n<<\n'\\n'\n;\n    }\n    \nelse\n{\n    \n    \n        \ndijkstra\n();\n        \nif\n(dis[n]==\n0x3f3f3f3f\n)\n        {\n            cout<<\n\"-1\"\n;\n        }\n        \nelse\n{\n            cout<<dis[n]+\n1\n<<\n'\\n'\n;\n            \nprintf_path\n(n);\n\n//            while(stars.size())\n\n\n//            {\n\n\n//                cout<<stars.front()<<'\\n';\n\n\n//                stars.pop_front();\n\n\n//            }\n\n        }\n    }\n    \nreturn\n \n0\n;\n}\n\n", "Tag": "算法分析"}
