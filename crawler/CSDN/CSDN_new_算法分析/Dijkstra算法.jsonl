{"Answer": "ä¸è¡Œã€‚å› ä¸ºå„ç§è·¯å¾„çš„ æ­¥æ•°å¹¶ä¸ä¸€å®šç›¸åŒã€‚æ‰€æœ‰è¾¹æƒå€¼åŠ æ­£æ•°ï¼Œåªæœ‰åœ¨å„ç§è·¯å¾„æ­¥æ•°ç›¸åŒçš„æƒ…å†µä¸‹æ‰å¯è¡Œã€‚æ±‚å¸¦è´Ÿæƒå€¼è¾¹çš„å•æºæœ€çŸ­è·¯å¾„å¯ä»¥ç”¨è´å°”æ›¼-ç¦ç‰¹ç®—æ³•ã€‚", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": "è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•å¸¦è´Ÿæƒå€¼ï¼Œæ¯æ¡è¾¹æƒå€¼åŒæ—¶åŠ ä¸Šä¸€ä¸ªæ•°å…¨éƒ½å˜ä¸ºæ­£æ•°ï¼Œå†ç”¨è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³• è¿™æ ·å¯¹å—\nè¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•å¸¦è´Ÿæƒå€¼ï¼Œæ¯æ¡è¾¹æƒå€¼åŒæ—¶åŠ ä¸Šä¸€ä¸ªæ•°å…¨éƒ½å˜ä¸ºæ­£æ•°ï¼Œå†ç”¨è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³• è¿™æ ·å¯¹å—", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "é‚»æ¥è¡¨ä½ å¯ä»¥ç†è§£ä¸ºå¤šä¸ªé“¾è¡¨ï¼Œæ¯ä¸ªé“¾è¡¨çš„å¤´æ˜¯ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè€Œä½ æ·»åŠ ä¸€æ¡è¾¹addï¼ˆa,b,cï¼‰ç›¸å½“äºç»™aå¢æ·»ä¸€ä¸ªå‡ºåº¦bé•¿åº¦ä¸ºcï¼Œè€Œ next[a]ä¸­å‚¨å­˜çš„æ˜¯å°±æ˜¯aæ‰€æœ‰çš„å‡ºåº¦çš„åœ°å€ï¼Œnextå­˜å‚¨çš„æ˜¯ä¸‹ä¸€ä¸ªå‡ºåº¦çš„åœ°å€ï¼Œver[i]å°±æ˜¯å‡ºåº¦ç‚¹çš„æ ‡å·ï¼Œedge[i]å¤´èŠ‚ç‚¹åˆ°å‡ºåº¦çš„è·ç¦»ï¼Œdjçš„åŸºæœ¬æ€è·¯æ˜¯æ¯æ¬¡é€‰å–ä¸€ä¸ªç¦»åŸç‚¹æœ€è¿‘çš„è¾¹æ¥æ›´æ–°å…¶ä»–ç‚¹çš„è·ç¦»ï¼Œæˆ‘ä»¬å…ˆå°†{0ï¼Œ1}åŠ å…¥å †ä¸­ï¼Œå †æ’åºpairæ ¹æ®firstä¼˜å…ˆåŸåˆ™ï¼Œæ‰€ä»¥æ„æ€å°±æ˜¯å †ä¸­1å·ç‚¹åˆ°ä¸€å·ç‚¹çš„è·ç¦»ä¸º0ï¼Œé‚£ä¹ˆæ­¤æ—¶ä¼šç”¨1å·ç‚¹å…ˆæ›´æ–°å®ƒå‡ºåº¦ï¼Œå¹¶ä¸”æ¯ä¸ªç‚¹æœ‰ä¸”åªä¼šè¢«åŠ å…¥ä¸€æ¬¡ï¼Œæˆ‘ä»¬å°†å®ƒæ‰“ä¸Šæ ‡è®°ï¼Œå¦‚æœå †ä¸­å·²ç»åŠ å…¥è¿‡è¿™ä¸ªæœ€çŸ­è¾¹ï¼Œæˆ‘ä»¬ç›´æ¥å°†å®ƒcontinueï¼Œå¦åˆ™è€Œå¾ªç¯çš„ç»ˆç‚¹å°±æ˜¯æ²¡æœ‰è¾¹å†è¢«æ›´æ–°çš„æ—¶å€™ï¼Œä¹Ÿå°±æ˜¯æ²¡æœ‰ä¸œè¥¿å¯ä»¥å…¥é˜Ÿäº†ï¼Œå¾ªç¯ç»“æŸã€‚", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": "Dijkstraç®—æ³•åŠé‚»æ¥è¡¨ C++\npriority_queue>q;\n//å¤§æ ¹å †-å°æ ¹å †\n\n    \nmemset\n(d,\n0x3f\n,\nsizeof\n(d);\n    \nmemset\n(v,\n0\n,\nsizeof\n(v));\n    d[\n1\n]=\n0\n;\n    q.\npush\n(\nmake_pair\n(\n0\n,\n1\n));\n    \nwhile\n(q.\nsize\n())\n    \nint\n x=q.\ntop\n().second;q.\npop\n();\n    \nif\n(v[x])\ncontinue\n;\n    v[x]=\n1\n;\n    \nfor\n(\nint\n i=head[x];i;i=Next[i])\n    \nint\n y=ver[i],z=edge[i];\n    \nif\n(d[y]>d[x]+z){\n        d[y]=d[x]+z;\n        q.\npush\n(\nmake_pair\n(-d[y],y));\n    }\n    } \n\n\n\nå¦‚ä¸Šï¼Œè¯·é—®ä¸€ä¸‹ï¼š\n\n\nwhile\n(q.\nsize\n())\n\nif\n(v[x])\ncontinue\n;\n\nfor\n(\nint\n i=head[x];i;i=\nNext\n[i])\n\n\n\nå„æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿè¿˜æœ‰é‚»æ¥è¡¨çš„åŸç†æ˜¯ä»€ä¹ˆï¼Ÿéº»çƒ¦äº†ï¼", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "å¯ä»¥æœ‰å¿å•Šï¼Œå¤§ç¥å¿«æ¥å•Š![å›¾ç‰‡è¯´æ˜](http://forum.csdn.net/PointForum/ui/scripts/csdn/Plugin/001/face/9.gif)![å›¾ç‰‡è¯´æ˜](http://forum.csdn.net/PointForum/ui/scripts/csdn/Plugin/001/face/9.gif)", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": "OPNETå«æ˜Ÿç½‘ç»œè·¯ç”±ç®—æ³•ä»¿çœŸ\næœ€è¿‘è¦äº¤æ¯•è®¾å•¦ï¼ŒOPNETçš„å«æ˜Ÿç½‘ç»œè·¯ç”±ä»¿çœŸè¿˜ä¸ä¼šåšï¼Œæ±‚å¤§ç¥æŒ‡å¯¼å•Šï¼ŒçœŸçš„å¾ˆç€æ€¥ã€‚ç®—æ³•ä¸»è¦\n\næ˜¯æ”¶é›†é“¾è·¯çŠ¶æ€ä¿¡æ¯ï¼Œæ¯”å¦‚æ—¶å»¶ã€å¸¦å®½ã€ä¸¢åŒ…ç‡ï¼Œç„¶åå½’ä¸€åŒ–åˆ°[0,1]ï¼Œåˆ†é…æƒé‡ä½œä¸º\n\né“¾è·¯çš„Costï¼Œç„¶åç”¨Dijkstraç®—æ³•ã€‚\n\næ±‚æŒ‡å¯¼å•Šï¼Œæ€ä¹ˆåšä»¿çœŸï¼Œå‘œå‘œå‘œ~", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "åŸºäºæœ€æ–°ç‰ˆChatGPT4çš„å›ç­”ï¼Œæœ›é‡‡çº³!!!æœ‰å…¶ä»–é—®é¢˜ä¹Ÿå¯ä»¥è¯¢é—®æˆ‘å“¦ã€â€(æœ€æ–°ç‰ˆæ›´æ™ºèƒ½ï¼ŒåŠŸèƒ½æ›´åŠ å¼ºå¤§)\nä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦ä¿®æ”¹Dijkstraç®—æ³•ï¼Œä½¿å…¶æœ€å¤§åŒ–æ¦‚ç‡ä¹˜ç§¯è€Œä¸æ˜¯æœ€å°åŒ–æƒé‡å’Œã€‚æˆ‘ä»¬å°†è¿›è¡Œä»¥ä¸‹æ›´æ”¹ï¼š\nåˆå§‹åŒ–æ—¶ï¼Œå°†æºèŠ‚ç‚¹çš„è·ç¦»è®¾ç½®ä¸º1ï¼Œè€Œä¸æ˜¯0ã€‚åœ¨å¯»æ‰¾æœ€å°è·ç¦»çš„èŠ‚ç‚¹æ—¶ï¼Œå¯»æ‰¾å…·æœ‰æœ€å¤§è·ç¦»çš„èŠ‚ç‚¹ã€‚åœ¨æ›´æ–°èŠ‚ç‚¹çš„è·ç¦»æ—¶ï¼Œä½¿ç”¨æ¦‚ç‡ä¹˜ç§¯è€Œä¸æ˜¯æƒé‡å’Œã€‚\nä»¥ä¸‹æ˜¯ä¿®æ”¹åçš„dijkstra.cæ–‡ä»¶ä¸­çš„ä»£ç ï¼š\n// DSA Programming task 4.2 - Dijsktra\n// You work on this file where TODO is located\n#include <stdio.h>\n#include <stdlib.h>\n#include \"dijkstra.h\"\n\n// Initializes graph for Dijkstra\nvoid init_graph(weightedgraph* g, int vertices){\n    g->nVertices = vertices;\n    int i;\n    for(i=1; i <= vertices; i++) {\n        g->adj_list[i] = 0;\n        g->pred[i] = 0;\n        // TODO! Note the distance\n        g->dist[i] = 0.0;\n    }\n}\n\n// ...\n\n// Dijkstra search from node s\nvoid dijkstra(weightedgraph* g, int s){\n    int queue[MAXVERTS];\n    int i=0;\n\n    // Initialize graph\n    for(i=1; i <= g->nVertices; i++) {\n        g->pred[i] = 0;\n        g->dist[i] = 0.0;\n        // All vertices in queue\n        queue[i] = i;\n    }\n\n    // TODO! Modification should start from here\n    //       Note that the propability should be maximized\n    //       Chanage names of variables accordingly\n    g->dist[s] = 1.0;\n\n    for(i=g->nVertices; i >= 1; i--) {\n        // Search for maximum from the queue\n        double maxval = g->dist[queue[1]];\n        int maxnode = queue[1];\n        int maxj=1;\n        for(int j = 1; j <= i; j++) {\n            if( g->dist[queue[j]] > maxval ){\n                maxval = g->dist[queue[j]];\n                maxnode = queue[j];\n                maxj = j;\n            }\n        }\n\n        // Switches the maximum to end (out of the queue)\n        int temp = queue[i];\n        queue[i] = queue[maxj];\n        queue[maxj] = temp;\n\n        pweightededgenode pedge = g->adj_list[maxnode];\n\n        // Relax the neighbors\n        while(pedge != 0){\n            int v = pedge->nodenum;\n            if(g->dist[v] < (g->dist[maxnode]*pedge->weight))  {\n                g->dist[v] = g->dist[maxnode]*pedge->weight;\n                g->pred[v] = maxnode;\n            }\n            pedge = pedge->next;\n        }\n\n        // DEBUG INFO:\n        // printf(\"%d processed: d[%d] = %f\\n\",maxnode,maxnode,g->dist[maxnode]);\n    }\n}\n//No need to change anyting after this point!\n\n// ...\n\nä½¿ç”¨æ­¤ä¿®æ”¹åçš„ç®—æ³•ï¼Œæ‚¨å°†èƒ½å¤Ÿæ‰¾åˆ°å…·æœ‰æœ€ä½³æ¦‚ç‡ä¼ é€’æ¶ˆæ¯çš„è·¯å¾„ã€‚åœ¨ç»™å®šç¤ºä¾‹ä¸­ï¼Œè¯¥ç®—æ³•å°†æ‰¾åˆ°ä»ç«™1åˆ°ç«™8çš„æœ€ä½³è·¯å¾„ã€‚æˆ‘ä»¬å°†ä½¿ç”¨ä¿®æ”¹è¿‡çš„Dijkstraç®—æ³•è®¡ç®—ç»™å®šå›¾ä¸­ä»èŠ‚ç‚¹1åˆ°èŠ‚ç‚¹8çš„æœ€ä½³ä¼ è¾“è·¯å¾„ã€‚è¯·ç¡®ä¿æ‚¨ä½¿ç”¨äº†ä¸Šè¿°æä¾›çš„ä¿®æ”¹åçš„dijkstra.cæ–‡ä»¶ä»£ç ã€‚ä½¿ç”¨æ­¤ä¿®æ”¹åçš„ç®—æ³•ï¼Œæ‚¨å¯ä»¥é€šè¿‡è¿è¡Œmain.cæ–‡ä»¶æ‰¾åˆ°æ‰€éœ€çš„è·¯å¾„ã€‚\nç°åœ¨ï¼Œæˆ‘ä»¬å·²ç»ä¿®æ”¹äº†Dijkstraç®—æ³•ä»¥è§£å†³æ‚¨çš„é—®é¢˜ï¼Œæ‚¨å¯ä»¥è¿è¡Œmain.cæ–‡ä»¶ï¼Œä»¥æ‰¾åˆ°ä»ç«™1åˆ°ç«™8çš„æœ€ä½³ä¼ è¾“è·¯å¾„ã€‚åœ¨æ‚¨æä¾›çš„ç¤ºä¾‹ä¸­ï¼Œè¯¥ç®—æ³•å°†æ‰¾åˆ°å…·æœ‰æœ€ä½³æ¦‚ç‡ä¼ é€’æ¶ˆæ¯çš„è·¯å¾„ã€‚\nè¯·æ³¨æ„ï¼Œä¿®æ”¹åçš„Dijkstraç®—æ³•å¯ä»¥é€‚ç”¨äºæ‚¨çš„é—®é¢˜ã€‚ä½†æ˜¯ï¼Œåœ¨ç‰¹å®šæƒ…å†µä¸‹ï¼Œè¿™ç§æ–¹æ³•å¯èƒ½ä¸æ˜¯æœ€æœ‰æ•ˆçš„ã€‚ä¾‹å¦‚ï¼Œå¯¹äºå…·æœ‰å¤§é‡èŠ‚ç‚¹å’Œè¾¹çš„å¤§å‹ç½‘ç»œï¼Œè¿™ç§æ–¹æ³•å¯èƒ½éœ€è¦æ›´å¤šçš„è®¡ç®—èµ„æºå’Œæ—¶é—´ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨å…¶ä»–æ›´é«˜æ•ˆçš„ç®—æ³•ï¼Œå¦‚A*æœç´¢ç®—æ³•æˆ–å…¶ä»–å¯å‘å¼æœç´¢æ–¹æ³•ã€‚\nå¦‚æœæ‚¨æœ‰å…¶ä»–å…³äºDijkstraç®—æ³•æˆ–å…¶ä»–ç®—æ³•çš„é—®é¢˜ï¼Œè¯·éšæ—¶æé—®ã€‚", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": "cè¯­è¨€ï¼Œä¿®æ”¹åŸºäºç¬¬ä¸€ä¸ªå›¾çš„æ—§ç®—æ³•ç®—æ³•ä»¥è§£å†³æ–°çš„é—®é¢˜ï¼Œå¹¶å°†æ–°ç®—æ³•ç”¨äºæœ€åä¸€å¼ å›¾\næœ‰ä¸€ä¸ªå…³äºDijkstraçš„æ— å‘å›¾ç®—æ³•çš„å®ç°ï¼Œé˜Ÿåˆ—çš„å¤„ç†ç®€å•ï¼Œä½¿ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸ºğ›©(ğ‘›2),næ˜¯å›¾ä¸­çš„èŠ‚ç‚¹æ•°,å°†è¯¥ç®—æ³•åº”ç”¨äºæ— å‘ç®—æ³•,ä¸‹é¢æ˜¯æœ€åˆä½¿ç”¨çš„åŠ æƒå›¾\n\n\n\n\nä¿®æ”¹ç®—æ³•ä»¥è§£å†³ä¸‹åˆ—é—®é¢˜ï¼š\nåœ¨ä¸€ä¸ªé“¾è·¯ç½‘ç»œä¸­ï¼Œæœ‰nä¸ªåŸºç«™ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å®ƒä»¬ä¹‹é—´ä¼ è¾“æ¶ˆæ¯ï¼Œä¸€ä¸ªç½‘ç»œåŒ…å«nä¸ªäº’ç›¸ä¼ è¾“ä¿¡æ¯çš„ç«™ç‚¹t1, t2, â€¦, tn,ç”±äºå¹²æ‰°ï¼Œæ¶ˆæ¯å¯èƒ½åœ¨ä¼ è¾“è¿‡ç¨‹ä¸­è¢«æŸåã€‚å¯¹äºæ¯ä¸€å¯¹ç«™ç‚¹ï¼Œæˆ‘ä»¬éƒ½çŸ¥é“æ¶ˆæ¯è¢«æ­£ç¡®ä¼ è¾“çš„æ¦‚ç‡ï¼ˆä¸€ä¸ªåœ¨0åˆ°1ä¹‹é—´çš„å®æ•°ï¼‰ã€‚ æˆ‘ä»¬æ‰“ç®—ä»t1ç«™åˆ°tnç«™ã€‚è®¾è®¡ä¸€ç§ç®—æ³•æ¥æ‰¾åˆ°ç«™ç‚¹çš„è·¯å¾„ï¼Œä»¥æœ€ä½³çš„æ¦‚ç‡ä¼ é€’æ¶ˆæ¯.è¯·æ³¨æ„ï¼Œå½“ä¸€ä¸ªæ¶ˆæ¯é€šè¿‡ä¸€ç³»åˆ—ç«™ç‚¹ä¼ è¾“æ—¶ï¼Œæ²¡æœ‰é”™è¯¯åœ°ä¼ é€’å®ƒçš„æ¦‚ç‡æ˜¯åºåˆ—ä¸­æ¦‚ç‡çš„ä¹˜ç§¯ã€‚\nä¾‹å­ï¼Œåœ¨ä¸‹å›¾ä¸­ï¼Œæœ‰ä¸‰ä¸ªç«™ç‚¹å’Œç»™å®šçš„æ¦‚ç‡\né€šè¿‡vä»tå‘uä¼ é€’ä¿¡æ¯æ¯”ç›´æ¥ä¼ é€’ä¿¡æ¯æ›´å¥½ï¼Œå› ä¸ºç›´æ¥ä¼ é€’ä¿¡æ¯æ¦‚ç‡ä¸º0.5ï¼Œè€Œé€šè¿‡vçš„æ¦‚ç‡ä¸º0.7 Ã— 0.8 = 0.56 > 0.50\n\n\nå› æ­¤ï¼Œåº”è¯¥ä¿®æ”¹ç»™å®šçš„ç®—æ³•è€Œä¸æ˜¯è¾¹çš„å’Œã€‚æˆ‘ä»¬è€ƒè™‘ä¹˜ç§¯ï¼Œå¹¶é€‰æ‹©æœ€å¤§å€¼ï¼ˆè€Œä¸æ˜¯åƒåŸå§‹ç®—æ³•ä¸­é‚£æ ·çš„æœ€å°å€¼ï¼‰\n\n\nå°†è¯¥ç®—æ³•åº”ç”¨äºä»¥ä¸‹ç½‘ç»œï¼Œå…¶ä¸­è¾¹çš„æƒå€¼ä¸ºæ¦‚ç‡ã€‚è¯¥æ¶ˆæ¯å°†ä»ç«™1ä¼ é€åˆ°ç«™8ï¼Œä»¥æ­¤å›¾ç”¨ä½œæ–°çš„ç®—æ³•ã€‚\n\n\ndijkstra.ä¸éœ€è¦ä¿®æ”¹\n\n\n// DSA Programming task 4.2 - Dijkstra\n\n\n// You do not need to change anything here\n\n\n\n#\nifndef\n DIJKSTRA_H_INCLUDED\n\n\n#\ndefine\n DIJKSTRA_H_INCLUDED\n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n\n// Maximum number of vertices\n\n\n// define according to your needs\n\n\n#\ndefine\n MAXVERTS 1000\n\n\n\n// Nodes are numbered as integers from 1\n\n\n\n// Maximum value in the distance table\n\n\n#\ndefine\n INF DBL_MAX\n\n\n\n// Defines edge in the adjacency list\n\n\ntypedef\n \nstruct\n \nweightedgnd\n {\n    \nint\n nodenum;\n    \ndouble\n weight;\n    \nstruct\n \nweightedgnd\n* next;\n} weightededgenode, *pweightededgenode;\n\n\n// Defines the graph\n\n\ntypedef\n \nstruct\n \nweightedg\n {\n    pweightededgenode adj_list[MAXVERTS+\n1\n];\n    \nint\n pred[MAXVERTS+\n1\n];\n    \ndouble\n dist[MAXVERTS+\n1\n];\n    \nint\n nVertices;\n} weightedgraph;\n\n\n// Initializes graph for breadth-first search\n\n\nvoid\n \ninit_graph\n(weightedgraph* g, \nint\n vertices)\n;\n\n\n// Adds new edge (x,y)\n\n\nvoid\n \nadd_edge\n(weightedgraph* g, \nint\n x, \nint\n y, \ndouble\n wght)\n;\n\n\n// Actual breadth-first search from node s\n\n\nvoid\n \ndijkstra\n(weightedgraph* g, \nint\n s)\n;\n\n\n// Frees allocated memory\n\n\nvoid\n \ndelete_graph\n(weightedgraph* g, \nint\n vertices)\n;\n\n\n// Print a path after search\n\n\nvoid\n \nprint_path\n(weightedgraph* g, \nint\n dest)\n;\n\n\n#\nendif\n\n\n\n\n\nmain.cï¼Œä¸éœ€è¦ä¿®æ”¹\n\n\n// DSA Programming task 4.2 - Dijkstra\n\n\n// You do not need to change anything here\n\n\n#\ninclude\n \n#\ninclude\n \n\"dijkstra.h\"\n\n\n\nint\n main\n()\n{\n    weightedgraph g;\n    init\n_graph(&\ng\n,8)\n;\n\n    add\n_edge(&\ng\n,1,2,1)\n;\n    add\n_edge(&\ng\n,1,4,7)\n;\n    add\n_edge(&\ng\n,1,5,3)\n;\n\n    add\n_edge(&\ng\n,2,3,1)\n;\n    add\n_edge(&\ng\n,3,4,2)\n;\n    add\n_edge(&\ng\n,5,6,3)\n;\n\n    add\n_edge(&\ng\n,6,7,3)\n;\n    add\n_edge(&\ng\n,6,8,3)\n;\n\n    \n// The other graph\n\n    add\n_edge(&\ng\n,2,4,2)\n;\n    add\n_edge(&\ng\n,4,6,2)\n;\n\n    dijkstra(&g,\n1\n);\n\n    printf(\n\"The path from 1 to 8 with cumulative weights:\\n\"\n);\n    print\n_path(&\ng\n,8)\n;\n\n    delete\n_graph(&\ng\n,8)\n;\n\n    return \n0\n;\n}\n\n\n\n\ndijkstra.cåªå¯¹æœ‰TODOçš„éƒ¨åˆ†è¿›è¡Œä¿®æ”¹ï¼ˆå³ä¸ºvoid init_graphå‡½æ•°çš„TODOéƒ¨åˆ†å’Œvoid dijkstraçš„TODOéƒ¨åˆ†ï¼‰ï¼Œå…·ä½“ä¿®æ”¹è¦æ±‚è¯¦æƒ…è§ä»£ç éƒ¨åˆ†çš„æ³¨é‡Š\n\n\n// DSA Programming task 4.2 - Dijsktra\n\n\n// You work on this file where TODO is located\n\n#include \n#include \n#include \n\"dijkstra.h\"\n\n\n\n// Initializes graph for Dijkstra\n\nvoid init_graph(weightedgraph* g, int vertices){\n    \ng\n->\nnVertices = vertices;\n    int i;\n    \nfor\n(i=\n1\n; i <= vertices; i++) {\n        \ng\n->\nadj_list[i] = \n0\n;\n        \ng\n->\npred[i] = \n0\n;\n        \n// TODO! Note the distance\n\n        \ng\n->\ndist[i] = INF;\n    }\n}\n\n\n// Adds new edge (x,y)\n\nvoid add_edge(weightedgraph* g, int x, int y, double wght){\n    \nif\n( x <= g->\nnVertices\n && y <= g->\nnVertices){\n        pweightededgenode pxy = malloc(sizeof(weightededgenode));\n        pweightededgenode pyx = malloc(sizeof(weightededgenode));\n\n        \npxy\n->\nnodenum = y;\n        \npxy\n->\nnext\n = g->\nadj_list[x];\n        \npxy\n->\nweight = wght;\n        \ng\n->\nadj_list[x] = pxy;\n\n        \npyx\n->\nnodenum = x;\n        \npyx\n->\nnext\n = g->\nadj_list[y];\n        \npyx\n->\nweight = wght;\n        \ng\n->\nadj_list[y] = pyx;\n    }\n}\n\n\n\n/*\n   Dijkstra's algorithm:\n   DIJKSTRA(G,w,s)\n   for each vertex v in V\n      d[v] = INF\n      p[v] = NIL\n   d[s] = 0\n   S = EMPTY\n   Q = V[G]\n   while Q != EMPTY\n         u =  EXTRACT-MIN(Q)\n         S = S UNION {u}\n         for each vertex v in Adj[u] do\n            if d[v] > d[u] + w(u,v) then\n               d[v] = d[u] + w(u,v)\n               p[v] = u\n*/\n\n\n\n// Dijkstra search from node s\n\nvoid dijkstra(weightedgraph* g, int s){\n    int queue[MAXVERTS];\n    int i=\n0\n;\n\n    \n// Initialize graph\n\n    \nfor\n(i=1; i <= g->\nnVertices; i++) {\n        \ng\n->\npred[i] = \n0\n;\n        \ng\n->\ndist[i] = INF;\n        \n// All vertices in queue\n\n        queue[i] = i;\n    }\n\n    \n// TODO! Modification should start from here\n\n    \n//       Note that the propability should be maximized\n\n    \n//       Chanage names of variables accordingly\n\n    \ng\n->\ndist[s] = \n0\n;\n\n    \nfor\n(i=g->\nnVertices; i >= \n1\n; i--) {\n        \n// Search for minimum from the queue\n\n        \ndouble\n minval = g->\ndist[queue[\n1\n]];\n        int minnode = queue[\n1\n];\n        int minj=\n1\n;\n        \nfor\n(int j = \n1\n; j <= i; j++) {\n            \nif\n( g->\ndist[queue[j]] < minval ){\n                \nminval\n = g->\ndist[queue[j]];\n                minnode = queue[j];\n                minj = j;\n            }\n        }\n\n        \n// Switches the minimum to end (out of the queue)\n\n        int temp = queue[i];\n        queue[i] = queue[minj];\n        queue[minj] = temp;\n\n        \npweightededgenode\n pedge = g->\nadj_list[minnode];\n\n        \n// Relax the neighbors\n\n        \nwhile\n(pedge != \n0\n){\n            \nint\n v = pedge->\nnodenum;\n            \nif\n(g->\ndist\n[v] > (g->\ndist\n[minnode]+pedge->\nweight))  {\n                \ng\n->\ndist\n[v] = g->\ndist\n[minnode]+pedge->\nweight;\n                \ng\n->\npred[v] = minnode;\n            }\n            \npedge\n = pedge->\nnext;\n        }\n\n        \n// DEBUG INFO:\n\n        \n// printf(\"%d processed: d[%d] = %f\\n\",minnode,minnode,g->dist[minnode]);\n\n    }\n}\n\n//No need to change anyting after this point!\n\n\n\n// Free allocated memory\n\nvoid delete_graph(weightedgraph* g, int vertices){\n    int i;\n    \nfor\n(i=\n1\n; i <= vertices; i++) {\n        \npweightededgenode\n pedge = g->\nadj_list[i];\n        pweightededgenode pnext = \n0\n;\n\n        \nwhile\n(pedge != \n0\n) {\n            \npnext\n = pedge->\nnext;\n            free(pedge);\n            pedge = pnext;\n        }\n    }\n}\n\n\n// Print a path after search\n\nvoid print_path(weightedgraph* g, int dest){\n    \nif\n( g->\npred[dest] != \n0\n){\n        \nprint_path\n(g, g->\npred[dest]);\n        \nprintf\n(\"%d:%f\\n\",dest,g->\ndist[dest]);\n    }\n    \nelse\n \nif\n(g->\ndist[dest]==\n0\n){\n        \nprintf\n(\"%d:%f\\n\",dest,g->\ndist[dest]);\n    }\n}\n\n\n\n", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "\nIf you're just starting with Go I would recommend sticking with the standard library for a bit and not adding more to your learning curve. Try to implement a simple graph data structure with some basic algorithms - it's very easy, and will let you practice with the language. Later on when you need more performance/features, you can look around for libraries (gonum or others). For example, a simple graph can be represented with:\n// Node is a node in the graph; it has a (unique) ID and a sequence of\n// edges to other nodes.\ntype Node struct {\n    Id    int64\n    Edges []int64\n}\n\n// Graph contains a set of Nodes, uniquely identified by numeric IDs.\ntype Graph struct {\n    Nodes map[int64]Node\n}\n\n", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": "åœ¨Goä¸­ä½¿ç”¨Gonumè¿›è¡Œå›¾ç®—æ³•\n\n\n\nI am a new Go programmer, just finished the \"A tour of Go\" tutorial a couple days ago. I want to create a graph of a 150 x 120 size and then get all the edge nodes for each node and implement some graph search algorithms such as BFS and Dijkstra. I found a great looking library called Gonum with a \ngraph package\n  that looks promising to use. \n\n\n\nMy problem is that it is a lot of information and I don't know where to get started. I was hoping there would be a tutorial of some sorts to get me started in the right direction, but I haven't had any luck finding one. \n\n\n\nThe way I set this up in Python was making a numpy arrays of zero's to represent the size of the graph and then iterate through it to get each edge for each node, but I am not sure that this is the best way to think about how graphs are set up in Go. \n\n    ", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "https://blog.csdn.net/qq_29320587/article/details/104842330", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": "ROSåœ¨è¿›è¡Œå¯¼èˆªæ—¶ï¼Œå‡ºç°ä¸€ç›´ä¸‹å‘è§’é€Ÿåº¦å’Œçº¿é€Ÿåº¦ä¸º0çš„æƒ…å†µ\n\n\n\nå¦‚å›¾æ‰€ç¤ºï¼Œåœ¨å­˜åœ¨è·¯å¾„è§„åˆ’çš„æƒ…å†µä¸‹ï¼Œä¸€ç›´ä¸‹å‘çº¿é€Ÿåº¦å’Œè§’é€Ÿåº¦ä¸º0 çš„æƒ…å†µã€‚\n\n\n\n\n\nå±€éƒ¨è§„åˆ’é‡‡ç”¨çš„æ˜¯DWAç®—æ³•\n\n\nå…¨å±€è§„åˆ’é‡‡ç”¨çš„æ˜¯Dijkstra.\n\n\nè†¨èƒ€ç³»æ•°è®¾ç½®æ˜¯15å˜ç±³ã€‚\nå°è½¦æ”¾ç½®åœ¨ä¸€ä¸ªç©ºæ—·åŒºåŸŸ\n\n", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "åº”è¯¥æ˜¯æ²¡æœ‰visitedæ•°ç»„æ ‡è®°çš„é—®é¢˜ï¼Œå­˜è¾¹æ˜¯å­˜åŒå‘è¾¹ï¼Œéœ€è¦æ ‡è®°visitedï¼ˆæœ‰æ—¶ä¹Ÿå«usedï¼‰æ•°ç»„è¿›è¡Œæ ‡è®°è¿™ä¸ªç‚¹å·²ç»åˆ°è¾¾è¿‡äº†", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": "æ´›è°·P1462 dijçš„é—®é¢˜\nhttps://www.luogu.com.cn/problem/P1462\n\n\nhttps://www.luogu.com.cn/record/78581018\n\n\nåªå¯¹äº†3ä¸ªç‚¹ï¼Œéƒ½æ˜¯æ— è§£ç‚¹ï¼Œä¹Ÿå°±æ˜¯è¯´dijå¯èƒ½ä¸å¯¹\n\n\n#\ninclude\n\n\n\n#\ndefine\n INF 0x3f3f3f3f\n\n\nusing\n \nnamespace\n std;\n\nconst\n \nint\n MAXN=\n10008\n;\n\ntypedef\n pair<\nint\n,\nint\n> pi;\npriority_queue< pi,vector,greater > q;\n\nint\n n,m,b;\n\nint\n f[MAXN],dis[MAXN];\n\nstruct\n \nnode\n{\n    \nint\n v,w;\n};\nvector a[MAXN];\n\nbool\n vis[MAXN];\n\nint\n l=INT_MAX,r=INT_MIN,mid;\n\nbool\n \ndijkstra\n(\nint\n st)\n{\n    \nmemset\n(vis,\n0\n,\nsizeof\n(vis));\n    \nmemset\n(dis,INF,\nsizeof\n(dis));\n    dis[\n1\n]=st;\n    q.\npush\n({\nmake_pair\n(dis[\n1\n],\n1\n)});\n    \nwhile\n(!q.\nempty\n()){\n        \nint\n x=q.\ntop\n().second;\n        q.\npop\n();\n        \nif\n(vis[x]) \ncontinue\n;\n        vis[x]=\ntrue\n;\n        \nfor\n(\nint\n i=\n0\n;i<a[x].\nsize\n();i++){\n            \nint\n y=a[x][i].v,z=a[x][i].w;\n            dis[y]=\nmin\n(dis[y],dis[x]+z);\n            q.\npush\n(\nmake_pair\n(dis[y],y));\n        }\n    }\n    \nreturn\n dis[n]<b;\n}\n\nint\n \nmain\n()\n{\n    \nscanf\n(\n\"%d%d%d\"\n,&n,&m,&b);\n    \nfor\n(\nint\n i=\n1\n;i<=n;i++){\n        \nscanf\n(\n\"%d\"\n,&f[i]);\n        l=\nmin\n(l,f[i]);\n        r=\nmax\n(r,f[i]);\n    }\n    \nint\n maxi=r;\n    \nfor\n(\nint\n i=\n1\n;i<=n;i++){\n        \nint\n u,v,w;\n        \nscanf\n(\n\"%d%d%d\"\n,&u,&v,&w);\n        a[u].\npush_back\n({v,w});\n        a[v].\npush_back\n({u,w});\n    }\n    \nwhile\n(l<=r){\n        mid=(l+r)/\n2\n;\n        \nif\n(\ndijkstra\n(mid)) r=mid\n-1\n;\n        \nelse\n l=mid+\n1\n;\n    }\n    \nif\n(l==maxi+\n1\n) \n        \nprintf\n(\n\"AFK\\n\"\n);\n    \nelse\n\n        \nprintf\n(\n\"%d\\n\"\n,l);\n    \nreturn\n \n0\n;\n}\n\n\n\n\næ±‚ç»™å‡ºä»¥å¦‚ä¸Šä»£ç æ”¹å¯¹äº†çš„ä»£ç æˆ–ä¿®æ”¹æ–¹å¼ï¼Œè°¢è°¢", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "æˆ‘è¯•ç€ç…§ç€ä½ çš„dequeè¾“å‡ºçš„ä»£ç å†™äº†ä¸€ä¸ªæµ‹è¯•ï¼Œå¯ä»¥æ­£å¸¸è¾“å‡ºï¼Œæ‰€ä»¥é—®é¢˜åº”è¯¥ä¸åœ¨è¿™é‡Œ", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": "é—®é¢˜ï¼šä¸ºä»€ä¹ˆç”¨dequeåå‘è¾“å‡ºä¼šæŠ¥é”™è€Œç”¨é€’å½’åå‘è¾“å‡ºæ²¡é—®é¢˜\nhttp://poj.org/problem?id=2457\nï¼ˆç”±äºé¢˜ç›®æ˜¯è‹±æ–‡ï¼Œä»¥ä¸‹å›¾ç‰‡æ—¶ä¸­æ–‡ç¿»è¯‘åçš„å›¾ç‰‡ï¼‰\nhttps://img-mid.csdnimg.cn/release/static/image/mid/ask/800335390746158.png?x-oss-process=image/auto-orient,1\nhttps://img-mid.csdnimg.cn/release/static/image/mid/ask/394075390746180.png?x-oss-process=image/auto-orient,1\n\n\nï¼ˆç”±äºé¢˜ç›®æ˜¯è‹±æ–‡ï¼Œä»¥ä¸‹å›¾ç‰‡æ—¶ä¸­æ–‡ç¿»è¯‘åçš„å›¾ç‰‡ï¼‰\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\nconst\n \nint\n  N=\n1e5\n+\n10\n,M=\n2e5\n+\n10\n;\n\ntypedef\n pair<\nint\n,\nint\n> PII;\n\nint\n dis[N],k,head[N],n,idx,m,s=\n1\n,t,vis0[N];\n\nbool\n vis[N];\n\nstruct\n \nEdge\n{\n    \nint\n to,w,next;\n}edge[M];\n\nvoid\n \nadd\n(\nint\n a,\nint\n b ,\nint\n c)\n\n\n{\n    edge[idx].to=b,edge[idx].w=c,edge[idx].next=head[a],head[a]=idx++;\n}\n\nvoid\n \ndijkstra\n()\n\n\n{\n    \nmemset\n(dis,\n0x3f\n,\nsizeof\n dis);\n    dis[s]=\n1\n;\n    priority_queue,greater > heap;\n    heap.\npush\n({\n1\n,s});\n\n//    vis0[1]=1;\n\n    \nwhile\n(heap.\nsize\n())\n    {\n        \nint\n vertax = heap.\ntop\n().second;\n        heap.\npop\n();\n        \n        \nif\n(vis[vertax])\ncontinue\n;\n        vis[vertax]=\ntrue\n;\n\n//        cout<dis[vertax]+edge[i].w)\n            {\n                dis[j]=dis[vertax]+edge[i].w;\n                vis0[j]=vertax;\n                heap.\npush\n({dis[j],j});\n            }\n        }\n        \n    }\n}\ndeque<\nint\n> stars;\n\nvoid\n \nprint_stars\n()\n\n\n{\n \n    \n    stars.\npush_front\n(n);\n    k=n;\n    \nwhile\n(vis0[k]!=s)\n    {\n        k=vis0[k]; \n        stars.\npush_front\n(k);\n    }\n    stars.\npush_front\n(s);\n}\n\nint\n \nmain\n()\n\n\n{\n    \nint\n a,b,c;\n    \nmemset\n(head,\n-1\n,\nsizeof\n head);\n    cin>>m>>n;\n\n//    if(n==1)\n\n\n//    {\n\n\n//        cout<<\"1\"<<'\\n'<<\"1\"<<'\\n';\n\n\n//    }\n\n\n//    else{\n\n    \n        \nfor\n(\nint\n i=\n1\n;i<=m;i++)\n        {\n            cin>>a>>b;\n            c=\n1\n;\n            \nadd\n(a,b,c);\n\n//            add(b,a,c);\n\n        }\n        \ndijkstra\n();\n        \nif\n(dis[n]==\n0x3f3f3f3f\n)\n        {\n            cout<<\n\"-1\"\n;\n        }\n        \nelse\n{\n            cout<\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\nconst\n \nint\n  N=\n1e5\n+\n10\n,M=\n2e5\n+\n10\n;\n\ntypedef\n pair<\nint\n,\nint\n> PII;\n\nint\n dis[N],k,head[N],n,idx,m,s=\n1\n,t,vis0[N];\n\nbool\n vis[N];\n\nstruct\n \nEdge\n{\n    \nint\n to,w,next;\n}edge[M];\n\nvoid\n \nadd\n(\nint\n a,\nint\n b ,\nint\n c)\n\n\n{\n    edge[idx].to=b,edge[idx].w=c,edge[idx].next=head[a],head[a]=idx++;\n}\n\nvoid\n \ndijkstra\n()\n\n\n{\n    \nmemset\n(dis,\n0x3f\n,\nsizeof\n dis);\n    dis[s]=\n0\n;\n    priority_queue,greater > heap;\n    heap.\npush\n({\n0\n,s});\n\n//    vis0[1]=1;\n\n    \nwhile\n(heap.\nsize\n())\n    {\n        \nint\n vertax = heap.\ntop\n().second;\n        heap.\npop\n();\n        \n        \nif\n(vis[vertax])\ncontinue\n;\n        vis[vertax]=\ntrue\n;\n\n//        cout<dis[vertax]+edge[i].w)\n            {\n                dis[j]=dis[vertax]+edge[i].w;\n                vis0[j]=vertax;\n                heap.\npush\n({dis[j],j});\n            }\n        }\n        \n    }\n}\n\n//deque stars;\n\n\n//void print_stars()\n\n\n//{\n\n\n//\n\n\n//    \n\n\n//    stars.push_front(n);\n\n\n//    k=n;\n\n\n//    while(vis0[k]!=s)\n\n\n//    {\n\n\n//        k=vis0[k]; \n\n\n//        stars.push_front(k);\n\n\n//    }\n\n\n//    stars.push_front(s);\n\n\n//}\n\n\nvoid\n \nprintf_path\n(\nint\n vertax)\n\n\n{\n    \nif\n(vis0[vertax] != \n-1\n ) \nprintf_path\n(vis0[vertax]);\n    cout<>m>>n;\n        \nfor\n(\nint\n i=\n1\n;i<=m;i++)\n        {\n            cin>>a>>b;\n            c=\n1\n;\n            \nadd\n(a,b,c);\n\n//            add(b,a,c);    \n\n        }\n    \nif\n(n==\n1\n)\n    {\n        cout<<\n\"1\"\n<<\n'\\n'\n<<\n\"1\"\n<<\n'\\n'\n;\n    }\n    \nelse\n{\n    \n    \n        \ndijkstra\n();\n        \nif\n(dis[n]==\n0x3f3f3f3f\n)\n        {\n            cout<<\n\"-1\"\n;\n        }\n        \nelse\n{\n            cout<<dis[n]+\n1\n<<\n'\\n'\n;\n            \nprintf_path\n(n);\n\n//            while(stars.size())\n\n\n//            {\n\n\n//                cout<<stars.front()<<'\\n';\n\n\n//                stars.pop_front();\n\n\n//            }\n\n        }\n    }\n    \nreturn\n \n0\n;\n}\n\n", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "ä¸è¡Œã€‚å› ä¸ºå„ç§è·¯å¾„çš„ æ­¥æ•°å¹¶ä¸ä¸€å®šç›¸åŒã€‚æ‰€æœ‰è¾¹æƒå€¼åŠ æ­£æ•°ï¼Œåªæœ‰åœ¨å„ç§è·¯å¾„æ­¥æ•°ç›¸åŒçš„æƒ…å†µä¸‹æ‰å¯è¡Œã€‚æ±‚å¸¦è´Ÿæƒå€¼è¾¹çš„å•æºæœ€çŸ­è·¯å¾„å¯ä»¥ç”¨è´å°”æ›¼-ç¦ç‰¹ç®—æ³•ã€‚", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": "è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•å¸¦è´Ÿæƒå€¼ï¼Œæ¯æ¡è¾¹æƒå€¼åŒæ—¶åŠ ä¸Šä¸€ä¸ªæ•°å…¨éƒ½å˜ä¸ºæ­£æ•°ï¼Œå†ç”¨è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³• è¿™æ ·å¯¹å—\nè¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•å¸¦è´Ÿæƒå€¼ï¼Œæ¯æ¡è¾¹æƒå€¼åŒæ—¶åŠ ä¸Šä¸€ä¸ªæ•°å…¨éƒ½å˜ä¸ºæ­£æ•°ï¼Œå†ç”¨è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³• è¿™æ ·å¯¹å—", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "é‚»æ¥è¡¨ä½ å¯ä»¥ç†è§£ä¸ºå¤šä¸ªé“¾è¡¨ï¼Œæ¯ä¸ªé“¾è¡¨çš„å¤´æ˜¯ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè€Œä½ æ·»åŠ ä¸€æ¡è¾¹addï¼ˆa,b,cï¼‰ç›¸å½“äºç»™aå¢æ·»ä¸€ä¸ªå‡ºåº¦bé•¿åº¦ä¸ºcï¼Œè€Œ next[a]ä¸­å‚¨å­˜çš„æ˜¯å°±æ˜¯aæ‰€æœ‰çš„å‡ºåº¦çš„åœ°å€ï¼Œnextå­˜å‚¨çš„æ˜¯ä¸‹ä¸€ä¸ªå‡ºåº¦çš„åœ°å€ï¼Œver[i]å°±æ˜¯å‡ºåº¦ç‚¹çš„æ ‡å·ï¼Œedge[i]å¤´èŠ‚ç‚¹åˆ°å‡ºåº¦çš„è·ç¦»ï¼Œdjçš„åŸºæœ¬æ€è·¯æ˜¯æ¯æ¬¡é€‰å–ä¸€ä¸ªç¦»åŸç‚¹æœ€è¿‘çš„è¾¹æ¥æ›´æ–°å…¶ä»–ç‚¹çš„è·ç¦»ï¼Œæˆ‘ä»¬å…ˆå°†{0ï¼Œ1}åŠ å…¥å †ä¸­ï¼Œå †æ’åºpairæ ¹æ®firstä¼˜å…ˆåŸåˆ™ï¼Œæ‰€ä»¥æ„æ€å°±æ˜¯å †ä¸­1å·ç‚¹åˆ°ä¸€å·ç‚¹çš„è·ç¦»ä¸º0ï¼Œé‚£ä¹ˆæ­¤æ—¶ä¼šç”¨1å·ç‚¹å…ˆæ›´æ–°å®ƒå‡ºåº¦ï¼Œå¹¶ä¸”æ¯ä¸ªç‚¹æœ‰ä¸”åªä¼šè¢«åŠ å…¥ä¸€æ¬¡ï¼Œæˆ‘ä»¬å°†å®ƒæ‰“ä¸Šæ ‡è®°ï¼Œå¦‚æœå †ä¸­å·²ç»åŠ å…¥è¿‡è¿™ä¸ªæœ€çŸ­è¾¹ï¼Œæˆ‘ä»¬ç›´æ¥å°†å®ƒcontinueï¼Œå¦åˆ™è€Œå¾ªç¯çš„ç»ˆç‚¹å°±æ˜¯æ²¡æœ‰è¾¹å†è¢«æ›´æ–°çš„æ—¶å€™ï¼Œä¹Ÿå°±æ˜¯æ²¡æœ‰ä¸œè¥¿å¯ä»¥å…¥é˜Ÿäº†ï¼Œå¾ªç¯ç»“æŸã€‚", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": "Dijkstraç®—æ³•åŠé‚»æ¥è¡¨ C++\npriority_queue>q;\n//å¤§æ ¹å †-å°æ ¹å †\n\n    \nmemset\n(d,\n0x3f\n,\nsizeof\n(d);\n    \nmemset\n(v,\n0\n,\nsizeof\n(v));\n    d[\n1\n]=\n0\n;\n    q.\npush\n(\nmake_pair\n(\n0\n,\n1\n));\n    \nwhile\n(q.\nsize\n())\n    \nint\n x=q.\ntop\n().second;q.\npop\n();\n    \nif\n(v[x])\ncontinue\n;\n    v[x]=\n1\n;\n    \nfor\n(\nint\n i=head[x];i;i=Next[i])\n    \nint\n y=ver[i],z=edge[i];\n    \nif\n(d[y]>d[x]+z){\n        d[y]=d[x]+z;\n        q.\npush\n(\nmake_pair\n(-d[y],y));\n    }\n    } \n\n\n\nå¦‚ä¸Šï¼Œè¯·é—®ä¸€ä¸‹ï¼š\n\n\nwhile\n(q.\nsize\n())\n\nif\n(v[x])\ncontinue\n;\n\nfor\n(\nint\n i=head[x];i;i=\nNext\n[i])\n\n\n\nå„æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿè¿˜æœ‰é‚»æ¥è¡¨çš„åŸç†æ˜¯ä»€ä¹ˆï¼Ÿéº»çƒ¦äº†ï¼", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "å¯ä»¥æœ‰å¿å•Šï¼Œå¤§ç¥å¿«æ¥å•Š![å›¾ç‰‡è¯´æ˜](http://forum.csdn.net/PointForum/ui/scripts/csdn/Plugin/001/face/9.gif)![å›¾ç‰‡è¯´æ˜](http://forum.csdn.net/PointForum/ui/scripts/csdn/Plugin/001/face/9.gif)", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": "OPNETå«æ˜Ÿç½‘ç»œè·¯ç”±ç®—æ³•ä»¿çœŸ\næœ€è¿‘è¦äº¤æ¯•è®¾å•¦ï¼ŒOPNETçš„å«æ˜Ÿç½‘ç»œè·¯ç”±ä»¿çœŸè¿˜ä¸ä¼šåšï¼Œæ±‚å¤§ç¥æŒ‡å¯¼å•Šï¼ŒçœŸçš„å¾ˆç€æ€¥ã€‚ç®—æ³•ä¸»è¦\n\næ˜¯æ”¶é›†é“¾è·¯çŠ¶æ€ä¿¡æ¯ï¼Œæ¯”å¦‚æ—¶å»¶ã€å¸¦å®½ã€ä¸¢åŒ…ç‡ï¼Œç„¶åå½’ä¸€åŒ–åˆ°[0,1]ï¼Œåˆ†é…æƒé‡ä½œä¸º\n\né“¾è·¯çš„Costï¼Œç„¶åç”¨Dijkstraç®—æ³•ã€‚\n\næ±‚æŒ‡å¯¼å•Šï¼Œæ€ä¹ˆåšä»¿çœŸï¼Œå‘œå‘œå‘œ~", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "åŸºäºæœ€æ–°ç‰ˆChatGPT4çš„å›ç­”ï¼Œæœ›é‡‡çº³!!!æœ‰å…¶ä»–é—®é¢˜ä¹Ÿå¯ä»¥è¯¢é—®æˆ‘å“¦ã€â€(æœ€æ–°ç‰ˆæ›´æ™ºèƒ½ï¼ŒåŠŸèƒ½æ›´åŠ å¼ºå¤§)\nä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦ä¿®æ”¹Dijkstraç®—æ³•ï¼Œä½¿å…¶æœ€å¤§åŒ–æ¦‚ç‡ä¹˜ç§¯è€Œä¸æ˜¯æœ€å°åŒ–æƒé‡å’Œã€‚æˆ‘ä»¬å°†è¿›è¡Œä»¥ä¸‹æ›´æ”¹ï¼š\nåˆå§‹åŒ–æ—¶ï¼Œå°†æºèŠ‚ç‚¹çš„è·ç¦»è®¾ç½®ä¸º1ï¼Œè€Œä¸æ˜¯0ã€‚åœ¨å¯»æ‰¾æœ€å°è·ç¦»çš„èŠ‚ç‚¹æ—¶ï¼Œå¯»æ‰¾å…·æœ‰æœ€å¤§è·ç¦»çš„èŠ‚ç‚¹ã€‚åœ¨æ›´æ–°èŠ‚ç‚¹çš„è·ç¦»æ—¶ï¼Œä½¿ç”¨æ¦‚ç‡ä¹˜ç§¯è€Œä¸æ˜¯æƒé‡å’Œã€‚\nä»¥ä¸‹æ˜¯ä¿®æ”¹åçš„dijkstra.cæ–‡ä»¶ä¸­çš„ä»£ç ï¼š\n// DSA Programming task 4.2 - Dijsktra\n// You work on this file where TODO is located\n#include <stdio.h>\n#include <stdlib.h>\n#include \"dijkstra.h\"\n\n// Initializes graph for Dijkstra\nvoid init_graph(weightedgraph* g, int vertices){\n    g->nVertices = vertices;\n    int i;\n    for(i=1; i <= vertices; i++) {\n        g->adj_list[i] = 0;\n        g->pred[i] = 0;\n        // TODO! Note the distance\n        g->dist[i] = 0.0;\n    }\n}\n\n// ...\n\n// Dijkstra search from node s\nvoid dijkstra(weightedgraph* g, int s){\n    int queue[MAXVERTS];\n    int i=0;\n\n    // Initialize graph\n    for(i=1; i <= g->nVertices; i++) {\n        g->pred[i] = 0;\n        g->dist[i] = 0.0;\n        // All vertices in queue\n        queue[i] = i;\n    }\n\n    // TODO! Modification should start from here\n    //       Note that the propability should be maximized\n    //       Chanage names of variables accordingly\n    g->dist[s] = 1.0;\n\n    for(i=g->nVertices; i >= 1; i--) {\n        // Search for maximum from the queue\n        double maxval = g->dist[queue[1]];\n        int maxnode = queue[1];\n        int maxj=1;\n        for(int j = 1; j <= i; j++) {\n            if( g->dist[queue[j]] > maxval ){\n                maxval = g->dist[queue[j]];\n                maxnode = queue[j];\n                maxj = j;\n            }\n        }\n\n        // Switches the maximum to end (out of the queue)\n        int temp = queue[i];\n        queue[i] = queue[maxj];\n        queue[maxj] = temp;\n\n        pweightededgenode pedge = g->adj_list[maxnode];\n\n        // Relax the neighbors\n        while(pedge != 0){\n            int v = pedge->nodenum;\n            if(g->dist[v] < (g->dist[maxnode]*pedge->weight))  {\n                g->dist[v] = g->dist[maxnode]*pedge->weight;\n                g->pred[v] = maxnode;\n            }\n            pedge = pedge->next;\n        }\n\n        // DEBUG INFO:\n        // printf(\"%d processed: d[%d] = %f\\n\",maxnode,maxnode,g->dist[maxnode]);\n    }\n}\n//No need to change anyting after this point!\n\n// ...\n\nä½¿ç”¨æ­¤ä¿®æ”¹åçš„ç®—æ³•ï¼Œæ‚¨å°†èƒ½å¤Ÿæ‰¾åˆ°å…·æœ‰æœ€ä½³æ¦‚ç‡ä¼ é€’æ¶ˆæ¯çš„è·¯å¾„ã€‚åœ¨ç»™å®šç¤ºä¾‹ä¸­ï¼Œè¯¥ç®—æ³•å°†æ‰¾åˆ°ä»ç«™1åˆ°ç«™8çš„æœ€ä½³è·¯å¾„ã€‚æˆ‘ä»¬å°†ä½¿ç”¨ä¿®æ”¹è¿‡çš„Dijkstraç®—æ³•è®¡ç®—ç»™å®šå›¾ä¸­ä»èŠ‚ç‚¹1åˆ°èŠ‚ç‚¹8çš„æœ€ä½³ä¼ è¾“è·¯å¾„ã€‚è¯·ç¡®ä¿æ‚¨ä½¿ç”¨äº†ä¸Šè¿°æä¾›çš„ä¿®æ”¹åçš„dijkstra.cæ–‡ä»¶ä»£ç ã€‚ä½¿ç”¨æ­¤ä¿®æ”¹åçš„ç®—æ³•ï¼Œæ‚¨å¯ä»¥é€šè¿‡è¿è¡Œmain.cæ–‡ä»¶æ‰¾åˆ°æ‰€éœ€çš„è·¯å¾„ã€‚\nç°åœ¨ï¼Œæˆ‘ä»¬å·²ç»ä¿®æ”¹äº†Dijkstraç®—æ³•ä»¥è§£å†³æ‚¨çš„é—®é¢˜ï¼Œæ‚¨å¯ä»¥è¿è¡Œmain.cæ–‡ä»¶ï¼Œä»¥æ‰¾åˆ°ä»ç«™1åˆ°ç«™8çš„æœ€ä½³ä¼ è¾“è·¯å¾„ã€‚åœ¨æ‚¨æä¾›çš„ç¤ºä¾‹ä¸­ï¼Œè¯¥ç®—æ³•å°†æ‰¾åˆ°å…·æœ‰æœ€ä½³æ¦‚ç‡ä¼ é€’æ¶ˆæ¯çš„è·¯å¾„ã€‚\nè¯·æ³¨æ„ï¼Œä¿®æ”¹åçš„Dijkstraç®—æ³•å¯ä»¥é€‚ç”¨äºæ‚¨çš„é—®é¢˜ã€‚ä½†æ˜¯ï¼Œåœ¨ç‰¹å®šæƒ…å†µä¸‹ï¼Œè¿™ç§æ–¹æ³•å¯èƒ½ä¸æ˜¯æœ€æœ‰æ•ˆçš„ã€‚ä¾‹å¦‚ï¼Œå¯¹äºå…·æœ‰å¤§é‡èŠ‚ç‚¹å’Œè¾¹çš„å¤§å‹ç½‘ç»œï¼Œè¿™ç§æ–¹æ³•å¯èƒ½éœ€è¦æ›´å¤šçš„è®¡ç®—èµ„æºå’Œæ—¶é—´ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨å…¶ä»–æ›´é«˜æ•ˆçš„ç®—æ³•ï¼Œå¦‚A*æœç´¢ç®—æ³•æˆ–å…¶ä»–å¯å‘å¼æœç´¢æ–¹æ³•ã€‚\nå¦‚æœæ‚¨æœ‰å…¶ä»–å…³äºDijkstraç®—æ³•æˆ–å…¶ä»–ç®—æ³•çš„é—®é¢˜ï¼Œè¯·éšæ—¶æé—®ã€‚", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": "cè¯­è¨€ï¼Œä¿®æ”¹åŸºäºç¬¬ä¸€ä¸ªå›¾çš„æ—§ç®—æ³•ç®—æ³•ä»¥è§£å†³æ–°çš„é—®é¢˜ï¼Œå¹¶å°†æ–°ç®—æ³•ç”¨äºæœ€åä¸€å¼ å›¾\næœ‰ä¸€ä¸ªå…³äºDijkstraçš„æ— å‘å›¾ç®—æ³•çš„å®ç°ï¼Œé˜Ÿåˆ—çš„å¤„ç†ç®€å•ï¼Œä½¿ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸ºğ›©(ğ‘›2),næ˜¯å›¾ä¸­çš„èŠ‚ç‚¹æ•°,å°†è¯¥ç®—æ³•åº”ç”¨äºæ— å‘ç®—æ³•,ä¸‹é¢æ˜¯æœ€åˆä½¿ç”¨çš„åŠ æƒå›¾\n\n\n\n\nä¿®æ”¹ç®—æ³•ä»¥è§£å†³ä¸‹åˆ—é—®é¢˜ï¼š\nåœ¨ä¸€ä¸ªé“¾è·¯ç½‘ç»œä¸­ï¼Œæœ‰nä¸ªåŸºç«™ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å®ƒä»¬ä¹‹é—´ä¼ è¾“æ¶ˆæ¯ï¼Œä¸€ä¸ªç½‘ç»œåŒ…å«nä¸ªäº’ç›¸ä¼ è¾“ä¿¡æ¯çš„ç«™ç‚¹t1, t2, â€¦, tn,ç”±äºå¹²æ‰°ï¼Œæ¶ˆæ¯å¯èƒ½åœ¨ä¼ è¾“è¿‡ç¨‹ä¸­è¢«æŸåã€‚å¯¹äºæ¯ä¸€å¯¹ç«™ç‚¹ï¼Œæˆ‘ä»¬éƒ½çŸ¥é“æ¶ˆæ¯è¢«æ­£ç¡®ä¼ è¾“çš„æ¦‚ç‡ï¼ˆä¸€ä¸ªåœ¨0åˆ°1ä¹‹é—´çš„å®æ•°ï¼‰ã€‚ æˆ‘ä»¬æ‰“ç®—ä»t1ç«™åˆ°tnç«™ã€‚è®¾è®¡ä¸€ç§ç®—æ³•æ¥æ‰¾åˆ°ç«™ç‚¹çš„è·¯å¾„ï¼Œä»¥æœ€ä½³çš„æ¦‚ç‡ä¼ é€’æ¶ˆæ¯.è¯·æ³¨æ„ï¼Œå½“ä¸€ä¸ªæ¶ˆæ¯é€šè¿‡ä¸€ç³»åˆ—ç«™ç‚¹ä¼ è¾“æ—¶ï¼Œæ²¡æœ‰é”™è¯¯åœ°ä¼ é€’å®ƒçš„æ¦‚ç‡æ˜¯åºåˆ—ä¸­æ¦‚ç‡çš„ä¹˜ç§¯ã€‚\nä¾‹å­ï¼Œåœ¨ä¸‹å›¾ä¸­ï¼Œæœ‰ä¸‰ä¸ªç«™ç‚¹å’Œç»™å®šçš„æ¦‚ç‡\né€šè¿‡vä»tå‘uä¼ é€’ä¿¡æ¯æ¯”ç›´æ¥ä¼ é€’ä¿¡æ¯æ›´å¥½ï¼Œå› ä¸ºç›´æ¥ä¼ é€’ä¿¡æ¯æ¦‚ç‡ä¸º0.5ï¼Œè€Œé€šè¿‡vçš„æ¦‚ç‡ä¸º0.7 Ã— 0.8 = 0.56 > 0.50\n\n\nå› æ­¤ï¼Œåº”è¯¥ä¿®æ”¹ç»™å®šçš„ç®—æ³•è€Œä¸æ˜¯è¾¹çš„å’Œã€‚æˆ‘ä»¬è€ƒè™‘ä¹˜ç§¯ï¼Œå¹¶é€‰æ‹©æœ€å¤§å€¼ï¼ˆè€Œä¸æ˜¯åƒåŸå§‹ç®—æ³•ä¸­é‚£æ ·çš„æœ€å°å€¼ï¼‰\n\n\nå°†è¯¥ç®—æ³•åº”ç”¨äºä»¥ä¸‹ç½‘ç»œï¼Œå…¶ä¸­è¾¹çš„æƒå€¼ä¸ºæ¦‚ç‡ã€‚è¯¥æ¶ˆæ¯å°†ä»ç«™1ä¼ é€åˆ°ç«™8ï¼Œä»¥æ­¤å›¾ç”¨ä½œæ–°çš„ç®—æ³•ã€‚\n\n\ndijkstra.ä¸éœ€è¦ä¿®æ”¹\n\n\n// DSA Programming task 4.2 - Dijkstra\n\n\n// You do not need to change anything here\n\n\n\n#\nifndef\n DIJKSTRA_H_INCLUDED\n\n\n#\ndefine\n DIJKSTRA_H_INCLUDED\n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n\n// Maximum number of vertices\n\n\n// define according to your needs\n\n\n#\ndefine\n MAXVERTS 1000\n\n\n\n// Nodes are numbered as integers from 1\n\n\n\n// Maximum value in the distance table\n\n\n#\ndefine\n INF DBL_MAX\n\n\n\n// Defines edge in the adjacency list\n\n\ntypedef\n \nstruct\n \nweightedgnd\n {\n    \nint\n nodenum;\n    \ndouble\n weight;\n    \nstruct\n \nweightedgnd\n* next;\n} weightededgenode, *pweightededgenode;\n\n\n// Defines the graph\n\n\ntypedef\n \nstruct\n \nweightedg\n {\n    pweightededgenode adj_list[MAXVERTS+\n1\n];\n    \nint\n pred[MAXVERTS+\n1\n];\n    \ndouble\n dist[MAXVERTS+\n1\n];\n    \nint\n nVertices;\n} weightedgraph;\n\n\n// Initializes graph for breadth-first search\n\n\nvoid\n \ninit_graph\n(weightedgraph* g, \nint\n vertices)\n;\n\n\n// Adds new edge (x,y)\n\n\nvoid\n \nadd_edge\n(weightedgraph* g, \nint\n x, \nint\n y, \ndouble\n wght)\n;\n\n\n// Actual breadth-first search from node s\n\n\nvoid\n \ndijkstra\n(weightedgraph* g, \nint\n s)\n;\n\n\n// Frees allocated memory\n\n\nvoid\n \ndelete_graph\n(weightedgraph* g, \nint\n vertices)\n;\n\n\n// Print a path after search\n\n\nvoid\n \nprint_path\n(weightedgraph* g, \nint\n dest)\n;\n\n\n#\nendif\n\n\n\n\n\nmain.cï¼Œä¸éœ€è¦ä¿®æ”¹\n\n\n// DSA Programming task 4.2 - Dijkstra\n\n\n// You do not need to change anything here\n\n\n#\ninclude\n \n#\ninclude\n \n\"dijkstra.h\"\n\n\n\nint\n main\n()\n{\n    weightedgraph g;\n    init\n_graph(&\ng\n,8)\n;\n\n    add\n_edge(&\ng\n,1,2,1)\n;\n    add\n_edge(&\ng\n,1,4,7)\n;\n    add\n_edge(&\ng\n,1,5,3)\n;\n\n    add\n_edge(&\ng\n,2,3,1)\n;\n    add\n_edge(&\ng\n,3,4,2)\n;\n    add\n_edge(&\ng\n,5,6,3)\n;\n\n    add\n_edge(&\ng\n,6,7,3)\n;\n    add\n_edge(&\ng\n,6,8,3)\n;\n\n    \n// The other graph\n\n    add\n_edge(&\ng\n,2,4,2)\n;\n    add\n_edge(&\ng\n,4,6,2)\n;\n\n    dijkstra(&g,\n1\n);\n\n    printf(\n\"The path from 1 to 8 with cumulative weights:\\n\"\n);\n    print\n_path(&\ng\n,8)\n;\n\n    delete\n_graph(&\ng\n,8)\n;\n\n    return \n0\n;\n}\n\n\n\n\ndijkstra.cåªå¯¹æœ‰TODOçš„éƒ¨åˆ†è¿›è¡Œä¿®æ”¹ï¼ˆå³ä¸ºvoid init_graphå‡½æ•°çš„TODOéƒ¨åˆ†å’Œvoid dijkstraçš„TODOéƒ¨åˆ†ï¼‰ï¼Œå…·ä½“ä¿®æ”¹è¦æ±‚è¯¦æƒ…è§ä»£ç éƒ¨åˆ†çš„æ³¨é‡Š\n\n\n// DSA Programming task 4.2 - Dijsktra\n\n\n// You work on this file where TODO is located\n\n#include \n#include \n#include \n\"dijkstra.h\"\n\n\n\n// Initializes graph for Dijkstra\n\nvoid init_graph(weightedgraph* g, int vertices){\n    \ng\n->\nnVertices = vertices;\n    int i;\n    \nfor\n(i=\n1\n; i <= vertices; i++) {\n        \ng\n->\nadj_list[i] = \n0\n;\n        \ng\n->\npred[i] = \n0\n;\n        \n// TODO! Note the distance\n\n        \ng\n->\ndist[i] = INF;\n    }\n}\n\n\n// Adds new edge (x,y)\n\nvoid add_edge(weightedgraph* g, int x, int y, double wght){\n    \nif\n( x <= g->\nnVertices\n && y <= g->\nnVertices){\n        pweightededgenode pxy = malloc(sizeof(weightededgenode));\n        pweightededgenode pyx = malloc(sizeof(weightededgenode));\n\n        \npxy\n->\nnodenum = y;\n        \npxy\n->\nnext\n = g->\nadj_list[x];\n        \npxy\n->\nweight = wght;\n        \ng\n->\nadj_list[x] = pxy;\n\n        \npyx\n->\nnodenum = x;\n        \npyx\n->\nnext\n = g->\nadj_list[y];\n        \npyx\n->\nweight = wght;\n        \ng\n->\nadj_list[y] = pyx;\n    }\n}\n\n\n\n/*\n   Dijkstra's algorithm:\n   DIJKSTRA(G,w,s)\n   for each vertex v in V\n      d[v] = INF\n      p[v] = NIL\n   d[s] = 0\n   S = EMPTY\n   Q = V[G]\n   while Q != EMPTY\n         u =  EXTRACT-MIN(Q)\n         S = S UNION {u}\n         for each vertex v in Adj[u] do\n            if d[v] > d[u] + w(u,v) then\n               d[v] = d[u] + w(u,v)\n               p[v] = u\n*/\n\n\n\n// Dijkstra search from node s\n\nvoid dijkstra(weightedgraph* g, int s){\n    int queue[MAXVERTS];\n    int i=\n0\n;\n\n    \n// Initialize graph\n\n    \nfor\n(i=1; i <= g->\nnVertices; i++) {\n        \ng\n->\npred[i] = \n0\n;\n        \ng\n->\ndist[i] = INF;\n        \n// All vertices in queue\n\n        queue[i] = i;\n    }\n\n    \n// TODO! Modification should start from here\n\n    \n//       Note that the propability should be maximized\n\n    \n//       Chanage names of variables accordingly\n\n    \ng\n->\ndist[s] = \n0\n;\n\n    \nfor\n(i=g->\nnVertices; i >= \n1\n; i--) {\n        \n// Search for minimum from the queue\n\n        \ndouble\n minval = g->\ndist[queue[\n1\n]];\n        int minnode = queue[\n1\n];\n        int minj=\n1\n;\n        \nfor\n(int j = \n1\n; j <= i; j++) {\n            \nif\n( g->\ndist[queue[j]] < minval ){\n                \nminval\n = g->\ndist[queue[j]];\n                minnode = queue[j];\n                minj = j;\n            }\n        }\n\n        \n// Switches the minimum to end (out of the queue)\n\n        int temp = queue[i];\n        queue[i] = queue[minj];\n        queue[minj] = temp;\n\n        \npweightededgenode\n pedge = g->\nadj_list[minnode];\n\n        \n// Relax the neighbors\n\n        \nwhile\n(pedge != \n0\n){\n            \nint\n v = pedge->\nnodenum;\n            \nif\n(g->\ndist\n[v] > (g->\ndist\n[minnode]+pedge->\nweight))  {\n                \ng\n->\ndist\n[v] = g->\ndist\n[minnode]+pedge->\nweight;\n                \ng\n->\npred[v] = minnode;\n            }\n            \npedge\n = pedge->\nnext;\n        }\n\n        \n// DEBUG INFO:\n\n        \n// printf(\"%d processed: d[%d] = %f\\n\",minnode,minnode,g->dist[minnode]);\n\n    }\n}\n\n//No need to change anyting after this point!\n\n\n\n// Free allocated memory\n\nvoid delete_graph(weightedgraph* g, int vertices){\n    int i;\n    \nfor\n(i=\n1\n; i <= vertices; i++) {\n        \npweightededgenode\n pedge = g->\nadj_list[i];\n        pweightededgenode pnext = \n0\n;\n\n        \nwhile\n(pedge != \n0\n) {\n            \npnext\n = pedge->\nnext;\n            free(pedge);\n            pedge = pnext;\n        }\n    }\n}\n\n\n// Print a path after search\n\nvoid print_path(weightedgraph* g, int dest){\n    \nif\n( g->\npred[dest] != \n0\n){\n        \nprint_path\n(g, g->\npred[dest]);\n        \nprintf\n(\"%d:%f\\n\",dest,g->\ndist[dest]);\n    }\n    \nelse\n \nif\n(g->\ndist[dest]==\n0\n){\n        \nprintf\n(\"%d:%f\\n\",dest,g->\ndist[dest]);\n    }\n}\n\n\n\n", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "\nIf you're just starting with Go I would recommend sticking with the standard library for a bit and not adding more to your learning curve. Try to implement a simple graph data structure with some basic algorithms - it's very easy, and will let you practice with the language. Later on when you need more performance/features, you can look around for libraries (gonum or others). For example, a simple graph can be represented with:\n// Node is a node in the graph; it has a (unique) ID and a sequence of\n// edges to other nodes.\ntype Node struct {\n    Id    int64\n    Edges []int64\n}\n\n// Graph contains a set of Nodes, uniquely identified by numeric IDs.\ntype Graph struct {\n    Nodes map[int64]Node\n}\n\n", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": "åœ¨Goä¸­ä½¿ç”¨Gonumè¿›è¡Œå›¾ç®—æ³•\n\n\n\nI am a new Go programmer, just finished the \"A tour of Go\" tutorial a couple days ago. I want to create a graph of a 150 x 120 size and then get all the edge nodes for each node and implement some graph search algorithms such as BFS and Dijkstra. I found a great looking library called Gonum with a \ngraph package\n  that looks promising to use. \n\n\n\nMy problem is that it is a lot of information and I don't know where to get started. I was hoping there would be a tutorial of some sorts to get me started in the right direction, but I haven't had any luck finding one. \n\n\n\nThe way I set this up in Python was making a numpy arrays of zero's to represent the size of the graph and then iterate through it to get each edge for each node, but I am not sure that this is the best way to think about how graphs are set up in Go. \n\n    ", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "https://blog.csdn.net/qq_29320587/article/details/104842330", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": "ROSåœ¨è¿›è¡Œå¯¼èˆªæ—¶ï¼Œå‡ºç°ä¸€ç›´ä¸‹å‘è§’é€Ÿåº¦å’Œçº¿é€Ÿåº¦ä¸º0çš„æƒ…å†µ\n\n\n\nå¦‚å›¾æ‰€ç¤ºï¼Œåœ¨å­˜åœ¨è·¯å¾„è§„åˆ’çš„æƒ…å†µä¸‹ï¼Œä¸€ç›´ä¸‹å‘çº¿é€Ÿåº¦å’Œè§’é€Ÿåº¦ä¸º0 çš„æƒ…å†µã€‚\n\n\n\n\n\nå±€éƒ¨è§„åˆ’é‡‡ç”¨çš„æ˜¯DWAç®—æ³•\n\n\nå…¨å±€è§„åˆ’é‡‡ç”¨çš„æ˜¯Dijkstra.\n\n\nè†¨èƒ€ç³»æ•°è®¾ç½®æ˜¯15å˜ç±³ã€‚\nå°è½¦æ”¾ç½®åœ¨ä¸€ä¸ªç©ºæ—·åŒºåŸŸ\n\n", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "åº”è¯¥æ˜¯æ²¡æœ‰visitedæ•°ç»„æ ‡è®°çš„é—®é¢˜ï¼Œå­˜è¾¹æ˜¯å­˜åŒå‘è¾¹ï¼Œéœ€è¦æ ‡è®°visitedï¼ˆæœ‰æ—¶ä¹Ÿå«usedï¼‰æ•°ç»„è¿›è¡Œæ ‡è®°è¿™ä¸ªç‚¹å·²ç»åˆ°è¾¾è¿‡äº†", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": "æ´›è°·P1462 dijçš„é—®é¢˜\nhttps://www.luogu.com.cn/problem/P1462\n\n\nhttps://www.luogu.com.cn/record/78581018\n\n\nåªå¯¹äº†3ä¸ªç‚¹ï¼Œéƒ½æ˜¯æ— è§£ç‚¹ï¼Œä¹Ÿå°±æ˜¯è¯´dijå¯èƒ½ä¸å¯¹\n\n\n#\ninclude\n\n\n\n#\ndefine\n INF 0x3f3f3f3f\n\n\nusing\n \nnamespace\n std;\n\nconst\n \nint\n MAXN=\n10008\n;\n\ntypedef\n pair<\nint\n,\nint\n> pi;\npriority_queue< pi,vector,greater > q;\n\nint\n n,m,b;\n\nint\n f[MAXN],dis[MAXN];\n\nstruct\n \nnode\n{\n    \nint\n v,w;\n};\nvector a[MAXN];\n\nbool\n vis[MAXN];\n\nint\n l=INT_MAX,r=INT_MIN,mid;\n\nbool\n \ndijkstra\n(\nint\n st)\n{\n    \nmemset\n(vis,\n0\n,\nsizeof\n(vis));\n    \nmemset\n(dis,INF,\nsizeof\n(dis));\n    dis[\n1\n]=st;\n    q.\npush\n({\nmake_pair\n(dis[\n1\n],\n1\n)});\n    \nwhile\n(!q.\nempty\n()){\n        \nint\n x=q.\ntop\n().second;\n        q.\npop\n();\n        \nif\n(vis[x]) \ncontinue\n;\n        vis[x]=\ntrue\n;\n        \nfor\n(\nint\n i=\n0\n;i<a[x].\nsize\n();i++){\n            \nint\n y=a[x][i].v,z=a[x][i].w;\n            dis[y]=\nmin\n(dis[y],dis[x]+z);\n            q.\npush\n(\nmake_pair\n(dis[y],y));\n        }\n    }\n    \nreturn\n dis[n]<b;\n}\n\nint\n \nmain\n()\n{\n    \nscanf\n(\n\"%d%d%d\"\n,&n,&m,&b);\n    \nfor\n(\nint\n i=\n1\n;i<=n;i++){\n        \nscanf\n(\n\"%d\"\n,&f[i]);\n        l=\nmin\n(l,f[i]);\n        r=\nmax\n(r,f[i]);\n    }\n    \nint\n maxi=r;\n    \nfor\n(\nint\n i=\n1\n;i<=n;i++){\n        \nint\n u,v,w;\n        \nscanf\n(\n\"%d%d%d\"\n,&u,&v,&w);\n        a[u].\npush_back\n({v,w});\n        a[v].\npush_back\n({u,w});\n    }\n    \nwhile\n(l<=r){\n        mid=(l+r)/\n2\n;\n        \nif\n(\ndijkstra\n(mid)) r=mid\n-1\n;\n        \nelse\n l=mid+\n1\n;\n    }\n    \nif\n(l==maxi+\n1\n) \n        \nprintf\n(\n\"AFK\\n\"\n);\n    \nelse\n\n        \nprintf\n(\n\"%d\\n\"\n,l);\n    \nreturn\n \n0\n;\n}\n\n\n\n\næ±‚ç»™å‡ºä»¥å¦‚ä¸Šä»£ç æ”¹å¯¹äº†çš„ä»£ç æˆ–ä¿®æ”¹æ–¹å¼ï¼Œè°¢è°¢", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "æˆ‘è¯•ç€ç…§ç€ä½ çš„dequeè¾“å‡ºçš„ä»£ç å†™äº†ä¸€ä¸ªæµ‹è¯•ï¼Œå¯ä»¥æ­£å¸¸è¾“å‡ºï¼Œæ‰€ä»¥é—®é¢˜åº”è¯¥ä¸åœ¨è¿™é‡Œ", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": "é—®é¢˜ï¼šä¸ºä»€ä¹ˆç”¨dequeåå‘è¾“å‡ºä¼šæŠ¥é”™è€Œç”¨é€’å½’åå‘è¾“å‡ºæ²¡é—®é¢˜\nhttp://poj.org/problem?id=2457\nï¼ˆç”±äºé¢˜ç›®æ˜¯è‹±æ–‡ï¼Œä»¥ä¸‹å›¾ç‰‡æ—¶ä¸­æ–‡ç¿»è¯‘åçš„å›¾ç‰‡ï¼‰\nhttps://img-mid.csdnimg.cn/release/static/image/mid/ask/800335390746158.png?x-oss-process=image/auto-orient,1\nhttps://img-mid.csdnimg.cn/release/static/image/mid/ask/394075390746180.png?x-oss-process=image/auto-orient,1\n\n\nï¼ˆç”±äºé¢˜ç›®æ˜¯è‹±æ–‡ï¼Œä»¥ä¸‹å›¾ç‰‡æ—¶ä¸­æ–‡ç¿»è¯‘åçš„å›¾ç‰‡ï¼‰\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\nconst\n \nint\n  N=\n1e5\n+\n10\n,M=\n2e5\n+\n10\n;\n\ntypedef\n pair<\nint\n,\nint\n> PII;\n\nint\n dis[N],k,head[N],n,idx,m,s=\n1\n,t,vis0[N];\n\nbool\n vis[N];\n\nstruct\n \nEdge\n{\n    \nint\n to,w,next;\n}edge[M];\n\nvoid\n \nadd\n(\nint\n a,\nint\n b ,\nint\n c)\n\n\n{\n    edge[idx].to=b,edge[idx].w=c,edge[idx].next=head[a],head[a]=idx++;\n}\n\nvoid\n \ndijkstra\n()\n\n\n{\n    \nmemset\n(dis,\n0x3f\n,\nsizeof\n dis);\n    dis[s]=\n1\n;\n    priority_queue,greater > heap;\n    heap.\npush\n({\n1\n,s});\n\n//    vis0[1]=1;\n\n    \nwhile\n(heap.\nsize\n())\n    {\n        \nint\n vertax = heap.\ntop\n().second;\n        heap.\npop\n();\n        \n        \nif\n(vis[vertax])\ncontinue\n;\n        vis[vertax]=\ntrue\n;\n\n//        cout<dis[vertax]+edge[i].w)\n            {\n                dis[j]=dis[vertax]+edge[i].w;\n                vis0[j]=vertax;\n                heap.\npush\n({dis[j],j});\n            }\n        }\n        \n    }\n}\ndeque<\nint\n> stars;\n\nvoid\n \nprint_stars\n()\n\n\n{\n \n    \n    stars.\npush_front\n(n);\n    k=n;\n    \nwhile\n(vis0[k]!=s)\n    {\n        k=vis0[k]; \n        stars.\npush_front\n(k);\n    }\n    stars.\npush_front\n(s);\n}\n\nint\n \nmain\n()\n\n\n{\n    \nint\n a,b,c;\n    \nmemset\n(head,\n-1\n,\nsizeof\n head);\n    cin>>m>>n;\n\n//    if(n==1)\n\n\n//    {\n\n\n//        cout<<\"1\"<<'\\n'<<\"1\"<<'\\n';\n\n\n//    }\n\n\n//    else{\n\n    \n        \nfor\n(\nint\n i=\n1\n;i<=m;i++)\n        {\n            cin>>a>>b;\n            c=\n1\n;\n            \nadd\n(a,b,c);\n\n//            add(b,a,c);\n\n        }\n        \ndijkstra\n();\n        \nif\n(dis[n]==\n0x3f3f3f3f\n)\n        {\n            cout<<\n\"-1\"\n;\n        }\n        \nelse\n{\n            cout<\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\nconst\n \nint\n  N=\n1e5\n+\n10\n,M=\n2e5\n+\n10\n;\n\ntypedef\n pair<\nint\n,\nint\n> PII;\n\nint\n dis[N],k,head[N],n,idx,m,s=\n1\n,t,vis0[N];\n\nbool\n vis[N];\n\nstruct\n \nEdge\n{\n    \nint\n to,w,next;\n}edge[M];\n\nvoid\n \nadd\n(\nint\n a,\nint\n b ,\nint\n c)\n\n\n{\n    edge[idx].to=b,edge[idx].w=c,edge[idx].next=head[a],head[a]=idx++;\n}\n\nvoid\n \ndijkstra\n()\n\n\n{\n    \nmemset\n(dis,\n0x3f\n,\nsizeof\n dis);\n    dis[s]=\n0\n;\n    priority_queue,greater > heap;\n    heap.\npush\n({\n0\n,s});\n\n//    vis0[1]=1;\n\n    \nwhile\n(heap.\nsize\n())\n    {\n        \nint\n vertax = heap.\ntop\n().second;\n        heap.\npop\n();\n        \n        \nif\n(vis[vertax])\ncontinue\n;\n        vis[vertax]=\ntrue\n;\n\n//        cout<dis[vertax]+edge[i].w)\n            {\n                dis[j]=dis[vertax]+edge[i].w;\n                vis0[j]=vertax;\n                heap.\npush\n({dis[j],j});\n            }\n        }\n        \n    }\n}\n\n//deque stars;\n\n\n//void print_stars()\n\n\n//{\n\n\n//\n\n\n//    \n\n\n//    stars.push_front(n);\n\n\n//    k=n;\n\n\n//    while(vis0[k]!=s)\n\n\n//    {\n\n\n//        k=vis0[k]; \n\n\n//        stars.push_front(k);\n\n\n//    }\n\n\n//    stars.push_front(s);\n\n\n//}\n\n\nvoid\n \nprintf_path\n(\nint\n vertax)\n\n\n{\n    \nif\n(vis0[vertax] != \n-1\n ) \nprintf_path\n(vis0[vertax]);\n    cout<>m>>n;\n        \nfor\n(\nint\n i=\n1\n;i<=m;i++)\n        {\n            cin>>a>>b;\n            c=\n1\n;\n            \nadd\n(a,b,c);\n\n//            add(b,a,c);    \n\n        }\n    \nif\n(n==\n1\n)\n    {\n        cout<<\n\"1\"\n<<\n'\\n'\n<<\n\"1\"\n<<\n'\\n'\n;\n    }\n    \nelse\n{\n    \n    \n        \ndijkstra\n();\n        \nif\n(dis[n]==\n0x3f3f3f3f\n)\n        {\n            cout<<\n\"-1\"\n;\n        }\n        \nelse\n{\n            cout<<dis[n]+\n1\n<<\n'\\n'\n;\n            \nprintf_path\n(n);\n\n//            while(stars.size())\n\n\n//            {\n\n\n//                cout<<stars.front()<<'\\n';\n\n\n//                stars.pop_front();\n\n\n//            }\n\n        }\n    }\n    \nreturn\n \n0\n;\n}\n\n", "Tag": "ç®—æ³•åˆ†æ"}
