{"Answer": "我用蚁群和量子蚁群算法做过，一个是比赛用的，一个是毕设\r\n没用遗传实现过", "Konwledge_Point": "集合覆盖", "Question": "用遗传算法解决集合覆盖模型\n求用遗传算法解决集合覆盖模型的程序试例或源程序，最好能相关物流配送中心和物流中心选址问题", "Tag": "算法分析"}
{"Answer": "先从redis取出来，然后把新map的值赋给旧map，然后再存进去", "Konwledge_Point": "集合覆盖", "Question": "redis的value存map集合新数据覆盖老数据怎么办\n", "Tag": "算法分析"}
{"Answer": "集合之间并没有关联。是添加的数据相同而已。", "Konwledge_Point": "集合覆盖", "Question": "java两个for循环add不同的集合为什么第二个集合会把第一个集合数据搬过来\n两个String类型的集合\n\n\n\n\n两个数据库都按过来6个数据,当personIdList的for循环结束以后开始执行emcodeList的for循环的时候personIdList 第零位数据被拿到了emcodeList集合的第零位是怎么回事?", "Tag": "算法分析"}
{"Answer": "这种你可以在外面定义Map，然后再循环里面new，每次也就能够装入List里面。", "Konwledge_Point": "集合覆盖", "Question": "Java循环数据 如果Map在循环外 循环添加数据就会被覆盖 但是在里面 就不会\nMap在里面 添加到list里面数据不会被覆盖\nMap在外面 添加到list里面数据会被覆盖\n\n\n疑惑", "Tag": "算法分析"}
{"Answer": "一个map中，key值是唯一的，所以想要一个相同的key值拥有多个值。就得采用key -> 数组或集合（将同个key值的value用数组或集合收集，再设置），你上面这种相当于将map一个key值所对应的值设置了无数次", "Konwledge_Point": "集合覆盖", "Question": "这个HashMap的值循环一次就会被覆盖，应该怎么解决呢？？？\n\n这个HashMap存的map的值循环一次就会被覆盖，应该怎么解决呢？？？\n\n能让它存入每一次put的值。", "Tag": "算法分析"}
{"Answer": "set原则是添加相同元素操作是无效,是因为在做二叉树或哈希算法时,相同元素计算值相同不允许插入,这个可以改的,你在\r\n①hashSet的所需要元素的类重写hashCode方法,和equal方法,而方法里什么也不做返回false,\r\n②在TreeSet中,不管自定义选择器还是重写选择方法,还是一样什么也不做,返回0.\r\n这样set也能插入相同元素了,然后这样Set就失去了元素唯一性了.\r\n其实set就是map集合的键列集合,而**值列都是Object()**,是map集合的特殊表现,map插入key重复时,覆盖的是值(!!!!这个你看清楚,你插入成功的前提是\r\n键一样,**值是不一样**).如果键和值都一样还是无法插入的,这就是如果set插入相同元素,相对于map集合键和值都一样,当然无法插入啊.", "Konwledge_Point": "集合覆盖", "Question": "求解map集合和set集合的问题\nset集合中添加两个相同元素，会导致添加操作无效。\n\nmap集合中的key不能是重复的，如果重复，那么后面添加的的映射关系会覆盖前面的映射关系，map集合中的key的维护是依靠set集合完成的。\n\n为什么同是set集合，map集合在key重复时是先进去再覆盖，而set集合是添加操作无效，不能进去。", "Tag": "算法分析"}
{"Answer": "j因为赋值的下标是index，num1和num2赋值的时候index一直在增加，所以不会覆盖", "Konwledge_Point": "集合覆盖", "Question": "对数组进行赋值是为什么后面赋值不会覆盖前面的的赋值？\n全部代码如下:\n {\n\n\npublic\n \nstatic\n \nvoid\n main(String[] args) {\n    \n// 复制某个数组元素数据至另外一个数组中\n\n    String[] num1 = \nnew\n String[\n3\n];\n    num1[\n0\n] = \n\"1\"\n;\n\n    String[] num2 = {\n\"3\"\n, \n\"2\"\n, \n\"1\"\n};\n\n    \n// 把num2中的元素存储到num1中\n\n    \n// 获得数组剩余的空间大小  默认为0\n\n    \nint\n len = num1.length;\n    \nint\n \ncount\n = \n0\n;\n// 原数组以及属于的空间\n\n    \nfor\n (\nint\n i = \n0\n; i < len; i++) {\n        \nif\n (num1[i] == \nnull\n) {\n            \nbreak\n;\n        } \nelse\n {\n            \ncount\n++;\n        }\n    }\n\n    \nint\n shengyv = len - \ncount\n;\n// 求得原数组的剩余空间\n\n\n    \nint\n len2 = num2.length;\n// 要复制元素的个数\n\n    String[] newStringArray = \nnull\n;\n    \nif\n (shengyv < len2) {\n        \n// 原数组的空间不够使用   手动扩大一个数组的空间大小   扩容\n\n        \n// 简单来说：就是创建一个新的数组\n\n        newStringArray = \nnew\n String[\ncount\n + len2];\n        \n// 遍历原数组以及复制的数字元素   存储到newStringArray\n\n        \nint\n \nindex\n = \n0\n;\n        \nfor\n (\nint\n j = \n0\n; j < \ncount\n; j++) {\n            newStringArray[\nindex\n] = num1[j];\n            \nindex\n++;\n        }\n        \nfor\n (\nint\n j = \n0\n; j < len2; j++) {\n            newStringArray[\nindex\n] = num2[j];\n            \nindex\n++;\n        }\n        System.out.println(Arrays.toString(newStringArray));\n    } \nelse\n {\n        \n// 直接将复制数组内容村粗到原数组中即可\n\n        \nfor\n (\nint\n j = \n0\n; j < len2; j++) {\n            num1[\ncount\n] = num2[j];\n            \ncount\n++;\n        }\n        System.out.println(Arrays.toString(num1));\n    }\n\n\n\n下面代码不太懂，第一个循环num1先对newStringArray进行赋值，当第二个循环运行是num2对newStringArray进行赋值，为什么num2赋的值不会覆盖num1的赋值？\n\n\n｛\nfor (int j = 0; j < count; j++) {\n                newStringArray[index] = num1[j];\n                index++;\n            }\nfor (int j = 0; j < len2; j++) {\n                newStringArray[index] = num2[j];\n                index++;\n            }\n｝\n刚接触Java不太懂，", "Tag": "算法分析"}
{"Answer": "Book book=new Book();\r\n//创建TreeSet集合，里面储存book对象的属性\r\nTreeSet tree=new TreeSet();\r\n\r\n第一次添加的是book对象，保存到tree中。tree获得book的地址。\r\n第二次添加的还是book对象，只是改了下值。保存到tree中进行覆盖。\r\n\r\n\r\n第一个修改的地方\r\n//创建引用名，不new对象\r\nBook book ;\r\n//创建TreeSet集合，里面储存book对象的属性\r\nTreeSet tree=new TreeSet();\r\n\r\n\r\n第二个修改的地方\r\npublic boolean addBook(String bookName, String author, String press, String price, String bookID, String pubdate){\r\n    boolean bl2=false;\r\n\t\t\r\n\t\t//在方法中new对象，可以保证每次的对象不一样\r\n\t\tbook = new Book();\r\n\t\t\r\n    book.setBookName(bookName);\r\n    book.setAuthor(author);\r\n    book.setPress(press);\r\n    book.setPrice(price);\r\n    book.setBookID(bookID);\r\n    book.setPubdate(pubdate);\r\n    System.out.println(\"新书信息如下:\"+book.toStrings());\r\n    System.out.println(\"是否保存该书？ (Y)是 (N)否\");\r\n    option=sc.next();\r\n    if(\"y\".equalsIgnoreCase(option)){\r\n        System.out.println(\"正在添加....\");\r\n        tree.add(book);//把图书的信息添加到tree集合中\r\n        bl2=true;\r\n    }\r\n    else{\r\n        System.out.println(\"已取消\");\r\n    }\r\n    return bl2;\r\n}", "Konwledge_Point": "集合覆盖", "Question": "java关于TreeSet集合的问题，为什么每次添加只能添加进去一个，再添加的时候就会覆盖掉前面那个\n不知道为什么只能添加一个对象进去，添加第二次的时候就覆盖掉了第一次添加进去的。麻烦大家了!\n\n\n\n这是main方法\n\nif(\"a\".equalsIgnoreCase(option)){\n\n                                //查看图书的功能\n\n                                d.cheekBook();\n\n                            }\n\n                            else if(\"b\".equalsIgnoreCase(option)){\n\n                                //添加图书的功能\n\n                                System.out.println(\"请输入书名:\");\n\n                                bookName=sc.next();\n\n                                System.out.println(\"请输入作者:\");\n\n                                author=sc.next();\n\n                                System.out.println(\"请输入出版社:\");\n\n                                press=sc.next();\n\n                                System.out.println(\"请输入价格:\");\n\n                                price=sc.next();\n\n                                System.out.println(\"请输入书号:\");\n\n                                bookID=sc.next();\n\n                                System.out.println(\"请输入出版日期:\");\n\n                                pubdate=sc.next();\n\n                                boolean bl2=d.addBook(bookName,author,press,price,bookID,pubdate);\n\n                                if(bl2){\n\n                                    System.out.println(\"添加成功\");\n\n                                    System.out.println(\"请选择功能:查看图书(A) 添加图书(B) 修改图书(C) 删除图书(D)\");\n\n                                    option=sc.next();\n\n                                    if(\"a\".equalsIgnoreCase(option)){\n\n                                        //查看图书\n\n                                        d.cheekBook();\n\n                                    }\n\n                                    else if(\"b\".equalsIgnoreCase(option)){\n\n                                        //添加图书\n\n                                        System.out.println(\"请输入书名:\");\n\n                                        bookName=sc.next();\n\n                                        System.out.println(\"请输入作者:\");\n\n                                        author=sc.next();\n\n                                        System.out.println(\"请输入出版社:\");\n\n                                        press=sc.next();\n\n                                        System.out.println(\"请输入价格:\");\n\n                                        price=sc.next();\n\n                                        System.out.println(\"请输入书号:\");\n\n                                        bookID=sc.next();\n\n                                        System.out.println(\"请输入出版日期:\");\n\n                                        pubdate=sc.next();\n\n                                        bln=d.addBook(bookName,author,press,price,bookID,pubdate);\n\n                                        if(bln){\n\n                                            System.out.println(\"添加成功\");\n\n                                        }\n\n                                    }\n\n\n\n    这是添加图书和查看图书的的方法                       \n                                //创建book对象\nBook book=new Book();\n//创建TreeSet集合，里面储存book对象的属性\nTreeSet tree=new TreeSet();\n//查看图书的功能\npublic void cheekBook(){\n    if(tree.isEmpty()){\n        System.out.println(\"请添加图书!!!\");\n    }\n    else{\n        System.out.println(\"查看图书\");\n        System.out.println(\"|书名|     |作者|     |出版社|    |价格|   |书号|   |出版日期|\");\n        Iterator it=tree.iterator();\n        while(it.hasNext()){\n            System.out.println(it.next());\n        }\n\n    }\n}\n\n//添加图书\npublic boolean addBook(String bookName, String author, String press, String price, String bookID, String pubdate){\n    boolean bl2=false;\n    book.setBookName(bookName);\n    book.setAuthor(author);\n    book.setPress(press);\n    book.setPrice(price);\n    book.setBookID(bookID);\n    book.setPubdate(pubdate);\n    System.out.println(\"新书信息如下:\"+book.toStrings());\n    System.out.println(\"是否保存该书？ (Y)是 (N)否\");\n    option=sc.next();\n    if(\"y\".equalsIgnoreCase(option)){\n        System.out.println(\"正在添加....\");\n        tree.add(book);//把图书的信息添加到tree集合中\n        bl2=true;\n    }\n    else{\n        System.out.println(\"已取消\");\n    }\n    return bl2;\n}\n", "Tag": "算法分析"}
{"Answer": "static静态变量是属于类的变量，任何时候只有一份，你在循环中给这个变量的赋值了3次，第3次赋值覆盖了前两次，所以最终的结果是 2 2 2", "Konwledge_Point": "集合覆盖", "Question": "list.add() 添加对象时为什么显示的都是最后一个对象的属性？以前添加的值被覆盖了\nimport java.util.ArrayList;\n\nimport java.util.List;\n\n\n\npublic class Listaa {\n\n    private static List list = new ArrayList();\n\n\n\nprivate static int i;\n\npublic static void maain(int i) {\n    Listaa t = new Listaa();\n    t.setI(i);\n    list.add(t);\n}\n\npublic static void main(String args[]) {\n    Listaa a = new Listaa();\n    for (int i = 0; i < 3; i++)\n        maain(i);\n    for (int i = 0; i < list.size(); i++) {\n\n        a = (Listaa) list.get(i);\n        System.out.println(a.getI());\n    }\n}\n\npublic int getI() {\n    return i;\n}\n\npublic void setI(int i) {\n    this.i = i;\n}\n\n\n\n\n}\n\n输出结果是 2 2 2，为什么不是 0 1 2 ？", "Tag": "算法分析"}
{"Answer": "\nSolution:\nIf you want to append array elements from the second array to the first array while not overwriting the elements from the first array and not re-indexing, use the + array union operator:\n$a = array(10 => array(25,26));\n$b = array(22 => array(45,66));\n$c = $a + $b;\nprint_r($c);\n\nOutput:\nArray\n(\n    [10] => Array\n        (\n            [0] => 25\n            [1] => 26\n        )\n\n    [22] => Array\n        (\n            [0] => 45\n            [1] => 66\n        )\n)\n\nThe keys are preserved in this case.\n\nSame answer from the other question\n  you posted relating this issue:\n  merging a multi-dimensional array into another multi-dimensional array\n\n", "Konwledge_Point": "集合覆盖", "Question": "如何创建多维数组的集合，而不是在推送新的数组时覆盖原始值\n\n\n\nHere is my site\n\nhttp://69.231.195.173:8888/iadprint/products?product=flyers\n\n\n\nWhen the user selects a few selections that relate to the flyer product and presses add to cart. this is what code is executed.\n\n\n\nif(isset($_POST['btnAddToCart']) && isset($_GET['product']))\n    {\n        $product_id = $action->getProductID($_GET['product']);\n\n        $attribute[$product_id] = array();\n\n\n        foreach ($_POST as $field=>$hash) \n        {\n            $hash = $security->clean_numeric($hash);\n\n            if($field != \"btnAddToCart\" && $field != 'price' && !empty($hash))\n            {\n                array_push($attribute[$product_id], $hash);\n\n            }\n        } \n\n        $_SESSION['iadprint_cart'] = $attribute;\n}\n\n\n\n\nthe array that gets formed looks like this\n\n\n\nArray\n(\n    [10] => Array\n        (\n            [0] => 30\n            [1] => 36\n        )\n)\n\n\n\n\ninside that main array the 10 refers to flyer product id name. inside of that the 30 and 36 are the ids of the selections. \n\n\n\nthe problem i'm having is if you select business card and make your selections and add to cart instead of pushing in a format like the picture that is everything inside the array()  for the new product. the data gets overridden. I am using array_push and it should work but it is not.\n\n    ", "Tag": "算法分析"}
{"Answer": "应该是服务器那边的问题，服务器在每个上传的图片都应该保存到不同的文件名上", "Konwledge_Point": "集合覆盖", "Question": "Android多图片上传会发生覆盖问题\n我写了一个多图片上传的小程序，选出的图片存在List集合里，然后通过for循环发送到服务器里。可是却发生了收到都是最后一张图片，这该怎么解决！求大神相助！！！！！！！！！！！！！！！！！！！！", "Tag": "算法分析"}
{"Answer": "是不是putstring 和 获取的时候  有一个异步的顺序?获取的时候其实还没有put进去?", "Konwledge_Point": "集合覆盖", "Question": "Android sharedpreferences使用putString()无法覆盖相同key的值\n问题遇到的现象和发生背景\n\n\n使用sharedpreferences全局存储map将map转成json字符串进行存储，在清空时使用putString方法将值设置成空字符串，但是在获取时，还是之前的值 并没有为空字符串。\n\n\n问题相关代码，请勿粘贴截图\n\n\nprivate\n \nSharedPreferences\n share;\n \nprivate\n \nSharedPreferences\n.\nEditor\n editor;\n \nprivate\n \nMap\n<\nString\n,\nString\n> moreData = \nnew\n \nHashMap\n<>();\n\nprivate\n \nSharedPreferencesUtils\n() {\n        share = \nEallApplication\n.\ngetContext\n().\ngetSharedPreferences\n(\nSHARED_NAME\n, \nContext\n.\nMODE_PRIVATE\n);\n        editor = share.\nedit\n();\n    }\n\n\n/**\n     * 单例模式\n     */\n\n    \nprivate\n \nstatic\n \nSharedPreferencesUtils\n instance;\n//单例模式 双重检查锁定\n\n\n    \npublic\n \nstatic\n \nSharedPreferencesUtils\n \ngetInstance\n(\n) {\n        \nif\n (instance == \nnull\n) {\n            synchronized (\nSharedPreferencesUtils\n.\nclass\n) {\n                \nif\n (instance == \nnull\n) {\n                    instance = \nnew\n \nSharedPreferencesUtils\n();\n                }\n            }\n        }\n        \nreturn\n instance;\n    }\n\n\n\n/**\n     * 用于保存集合\n     *\n     * \n@param\n key key\n     * \n@param\n map map数据\n     * \n@return\n 保存结果\n     */\n\n    \npublic\n \nvoid\n \nputHashMapData\n(\nString\n key, \nMap\n<\nString\n, \nString\n> map\n) {\n        \nif\n (map == \nnull\n){\n            moreData.\nclear\n();\n            editor.\nputString\n(key, \n\"\"\n);\n            editor.\napply\n();\n            \nreturn\n;\n        }\n\n        moreData.\nputAll\n(map);\n        \ntry\n {\n            \nGson\n gson = \nnew\n \nGson\n();\n            \nString\n json = gson.\ntoJson\n(moreData);\n            editor.\nputString\n(key, json);\n        } \ncatch\n (\nException\n e) {\n            e.\nprintStackTrace\n();\n        }\n        editor.\napply\n();\n        \nreturn\n;\n    }\n\n    \npublic\n \nMap\n<\nString\n, \nString\n> \ngetHashMapData\n(\nString\n key\n) {\n        \nString\n json = share.\ngetString\n(key, \n\"\"\n);\n        \nMap\n<\nString\n,\nString\n> map = \nnew\n \nGson\n().\nfromJson\n(json, \nnew\n \nTypeToken\n<\nHashMap\n<\nString\n,\nObject\n>>(){}.\ngetType\n());\n        \nreturn\n map;\n    }\n\n\n\n运行结果及报错内容\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果", "Tag": "算法分析"}
{"Answer": "和游标没有关系了，看个例子\r\nSELECT *\r\n  FROM aa t\r\n WHERE num <= 40\r\n ORDER BY num DESC\r\n结果：\r\n1    40\r\n1    30\r\n2    10\r\nSELECT *\r\n  FROM aa t\r\n WHERE num <= 30\r\n ORDER BY num DESC\r\n   FOR UPDATE SKIP LOCKED\r\n\r\n结果：\r\n1    30\r\n2    10\r\nSELECT *\r\n  FROM aa t\r\n WHERE num <= 40\r\n ORDER BY num DESC\r\n   FOR UPDATE SKIP LOCKED\r\n结果：\r\n1    40", "Konwledge_Point": "集合覆盖", "Question": "oracle里有没有其他方法替代游标\n存储过程内使用了游标遍历数据，需要对数据进行更新。\n\n当多用户同时请求时，多个session的游标查询的数据可能重复，游标锁定了数据，\n\n第一个用户 更新了数据，\n\n后面用户可能会覆盖前一个用户更新的数据。\n\n需要频繁查询数据，考虑到性能方面，希望用存储过程完成数据处理。\n\n有没有其他方法替代游标呢？", "Tag": "算法分析"}
{"Answer": "你原来在方法中每次调用方法都会新建一个list。所以每一次元素都是当次的元素。把list作为类的全局变量，list就可以增加了", "Konwledge_Point": "集合覆盖", "Question": "如何在一个方法内将对象存入list中，放入session,再次执行该方法如何将新的对象继续存入？\n1.在执行方法SavaQuestion，定义一个list对象 questionNaireQuestionslist\n\n2.再将questionNaireQuestion对象放入这个list对象questionNaireQuestionslist中\n\n3.将list对象questionNaireQuestionslist保存入session中，将questionNaireQuestion保存入session中\n\n4.如何再次执行这个方法SavaQuestion，将新的questionNaireQuesion对象存入list中\n\n5.我每次将新的questionNaireQuesion对象存入list中时都会覆盖原有的，list对象questionNaireQuestionslist永远只有一个元素\n\n\n\npublic String saveQuestion(HttpServletRequest request) {\n   List questionNaireQuestionslist = new ArrayList();\n        QuestionNaireQuestion questionNaireQuestion = new QuestionNaireQuestion();\n                //......\n                 questionNaireQuestionslist.add(questionNaireQuestion);\n                 //将List对象questionNaireQuestionslist存入session中\n                request.getSession().setAttribute(\"questionNaireQuestionslist\", questionNaireQuestionslist);\n                 //将questionNaireQuestion对象存入session中\n                 request.getSession().setAttribute(\"questionNaireQuestion\", questionNaireQuestion);\n\n", "Tag": "算法分析"}
{"Answer": "缓存问题。\r\n拿过来之前把session同步下再看看。", "Konwledge_Point": "集合覆盖", "Question": "Hibernate的一对多映射的问题，集合的size不对。\nParent和Children建立一对多的双向关联。\n\nParent类的Children属性是Set类型的。\n\n\n\n数据库里面和parent关联的child记录是2条，这个确认过。\n\n\n\n但是parent.getChindren().size()的值是1。\n\n\n\n但是用HQL方式用相同的条件查询，\"from Child c where c.parentId=\" + parent.getId()，结果是2。\n\n我把parent.getChindren().size()时在控制台输出的sql语句复制出来替换掉问号，直接去查询数据库，结果也是2条记录。\n\n\n\n为什么直接输出size的值是1而其他方法查询的结果是2？\n\n\n\n我已经覆盖了对象的hashCode和equals方法了，我在hashCode和equals里添加了输出，发现hashCode执行了一遍，equals没有执行，是不是说在初始化children的时候只有1个对象被添加到set里？ \n\n\n\n应用里其他地方的一对多映射都正常，唯独这里有问题。\n\nChild不止和Parent有关联，还和其他的对象有同样的关联，那些就正常。\n\n\n\n[code=\"xml\"]\n\n\n\n\n class=\"com.bean.Parent\" not-null=\"false\" cascade=\"none\" />\n\n[/code]", "Tag": "算法分析"}
{"Answer": "entry应该指的就是键值对吧", "Konwledge_Point": "集合覆盖", "Question": "hashmap 中的Entry链问题\n引用网上的一段话：[quote]当程序试图将一个key-value对放入HashMap中时，程序首先根据该 key 的 hashCode() 返回值决定该 Entry 的存储位置：如果两个 Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同。如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有 Entry 的 value，但key不会覆盖。如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位于 Entry 链的头部[/quote]\n\n\n\n我的疑问是，这段话要怎么理解\n\n因为当我定义\n\n[code=\"java\"]\n\nmap.put(1,\"a\");\n\nmap.put(1,\"b\");\n\n[/code]\n\n\n\n此时map的size实际是1,map.get(1)为b也就是说后put的元素把前面的覆盖了。\n\n所以我想知道的是这个Entry里有多个元素，该怎么理解？", "Tag": "算法分析"}
{"Answer": "https://leetcode-cn.com/circle/discuss/7HUB28/", "Konwledge_Point": "集合覆盖", "Question": "求“最大公共偏序子集”\n有两个各自具有一种序结构的集合，如何寻找这两个集合的一种共同子集使得：\n1、子集中元素的排列顺序能同时满足这两个集合上的序结构；\n2、符合1的前提下，子集尽可能大\n\n\n比如把两个字符串当做集合：\na=\"我不知道如何解决这个问题\"\nb=\"不知道我能否想出解决该问题的办法\"\n那么符合条件的所谓“最大公共偏序子集”就是：\n\"不知道解决问题\"\n\n\n稍微解释一下c怎么来的，所谓的序结构，比如a字符串的就是：“我”要排在“不”前面，“不”又要排在后面的其他字前面，字符串上这种覆盖每个字的一维的从左到右的可传导的顺序关系，就可以当做是a字符串所具有的一个序结构，同理b字符串也一样。\n然后c在是a，b的公共子集的同时，c中的每一个元素，还要满足a，b上的顺序关系，比如开头的\"我\"和\"不\"字，虽然是a，b的共同元素，但是它们两个字在a中和在b中的先后顺序不一样，所以它们不能同时出现在c中。\n就是这么回事吧，有点像是在找最长公共子串，也有点像求交集。\n声明一下，标题中的“最大公共偏序子集”这个名字是我乱取的，只是为了简要概括题意而已，不过或许数学里真有这么个说法。\n其实这里的集合，也不是严格数学定义的集合，可以当他是一个collection而不是set，也就是说，元素可重复。\n请各位给点思路就好", "Tag": "算法分析"}
{"Answer": "：D， 大概知道你是什么意思了。其实你用list 这个Collection就完全可以达到你要的效果了。\r\nSet 不允许有相同的对象如果你一定要把相同的对像放在一个Collection中的话那建议用List好了，这样就不会存在一个覆盖问题了。\r\n\r\n能不能在每次循环的完后即在还没有覆盖就把值给在前台给获得\r\n-----------------------------------------------------------\r\n不行，看一下Struts2 的流程图。顺便建议看一下Struts2的时序图。从页面到Action再到页面其实是一整个流程。Web Application都是按照这个流程走的。", "Konwledge_Point": "集合覆盖", "Question": "一个ssh问题\n初学ssh框架。对那个注射的原理有点模糊\n\n下面是我遇到的一个问题。请大家帮忙指教\n\n    public String queryAllCatory(){\n\n        catorys = this.getCatoryManager().queryCatory();\n\n        for(int i=0; i\n            catory = catorys.get(i);\n\n            sub = catory.getSubcatories();\n\n//          sub.add(catory.getSubcatories().iterator().next());\n\n//          System.out.println(\"-----------\"+ catory.getCatoryname()+\":\" + catory.getSubcatories().iterator().next());  \n\n//          sub.add(catory.getSubcatories().iterator().next());\n\n        }\n\n        return SUCCESS;\n\n    }\n\n上面是action代码\n\n下面是jsp代码\n\n\n\n                \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n我想在jsp页面获得值。但是我不明白为什么问题获得set集合最后一个值。他们不是一边循环一边把那个值传到jsp页面上的吗。请大家指教。\n\n\n\n我记得前面我做过类似的好像能获得这样的值的呀。弄不明白了。折腾了两天了也不知道怎么回事\n\n[b]问题补充：[/b]\n\n谢谢你的回答。我在后台给打出来了。sub里面是有值的。是最后一个值，我想知道怎么把他循环里面的每一个值都在前台给显示出来，我记得前面我做过就这样能把他给显示出来。  我的意思就是把他每一个循环的值在页面都能够显示出来。\n\n[b]问题补充：[/b]\n\n可能还没有表达清楚。可能在循环的时候每一次向sub里面放值的时候这次放的值把上次的值给覆盖了。我就是想知道的是：能不能在每次循环的完后即在还没有覆盖就把值给在前台给获得。", "Tag": "算法分析"}
{"Answer": "/war exploded/addCart  这里是有空格的吗？", "Konwledge_Point": "集合覆盖", "Question": "java-web练习，点击addCart.html文档后，无法跳转到AddCartServlet，请问是不是下图红框所示的地址写错了？\n这是项目文件列表及html文档的跳转地址\n以下为具体实现代码\n\n\n\n\n\n\n\nTitle\n\n\n\n\n商品列表\n杯子\n书包\n笔记本\n\n\n\n\n\npackage\n session;\n\n\nimport\n javax.servlet.*;\n\nimport\n javax.servlet.http.*;\n\nimport\n javax.servlet.annotation.*;\n\nimport\n java.io.\nIOException\n;\n\nimport\n java.util.\nArrayList\n;\n\nimport\n java.util.\nList\n;\n\n\n@WebServlet\n(name = \n\"AddCartServlet\"\n, urlPatterns = \n\"/addCart\"\n)\npublic \nclass\n \nAddCartServlet\n \nextends\n \nHttpServlet\n \n{\n    \n@Override\n\n    \nprotected\n void doGet(\nHttpServletRequest\n request, \nHttpServletResponse\n response) \nthrows\n \nServletException\n, \nIOException\n {\n\n        \n//获取商品信息\n\n        \nString\n name=request.getParameter(\n\"name\"\n);\n        \n//在服务器中开辟一个能保存商品信息的内存空间session\n\n        \nHttpSession\n session= request.getSession();\n\n        \n//重点：以下代码实现目的为--在连续点击打开多个商品链接后，使多个商品信息可以通过name传进来保存在session中，不会被前个商品信息覆盖，只出现一个商品；\n\n\n        \n//创建一个list类集合对象用来保存此前session中的所有商品信息；此处需要强转（将session转为List类使等号两边类型相等）\n\n        \nList\n list=(\nList\n)session.getAttribute(\n\"list\"\n);\n        \n//第一次访问的时候，list不存在，需要创建一个；\n\n        \nif\n (list==\nnull\n){\n            list=\nnew\n \nArrayList\n();\n        }\n        \n//将商品信息保存到list集合中\n\n        list.add(name);\n        \n//在session内存空间中保存一个键为\"list\",值为list的商品\n\n        session.setAttribute(\n\"list\"\n,list);\n\n        \n//方法重载，对session进行持久化操作，也就是持久化cookie里的JSESSIONID（标识id）\n\n        \nCookie\n cookie=\nnew\n \nCookie\n(\n\"JSESSIONID\"\n,session.getId());\n        \n//使session内存空间在无操作情况下存在时间变为24小时；\n\n        cookie.setMaxAge(\n60\n*\n60\n*\n24\n);\n        \n//使cookie参数在war exploded目录下才会被携带；\n\n        cookie.setPath(\n\"/war exploded\"\n);\n        response.addCookie(cookie);\n    }\n\n    \n@Override\n\n    \nprotected\n void doPost(\nHttpServletRequest\n request, \nHttpServletResponse\n response) \nthrows\n \nServletException\n, \nIOException\n {\n\n    }\n}\n\n\npackage\n session;\n\n\nimport\n javax.servlet.*;\n\nimport\n javax.servlet.http.*;\n\nimport\n javax.servlet.annotation.*;\n\nimport\n java.io.\nIOException\n;\n\nimport\n java.util.\nList\n;\n\n\n@WebServlet\n(name = \n\"GetCartServlet\"\n, urlPatterns = \n\"/getCart\"\n)\npublic \nclass\n \nGetCartServlet\n \nextends\n \nHttpServlet\n \n{\n    \n@Override\n\n    \nprotected\n void doGet(\nHttpServletRequest\n request, \nHttpServletResponse\n response) \nthrows\n \nServletException\n, \nIOException\n {\n\n        \nHttpSession\n session=request.getSession();\n        \nList\n<\nString\n> list=(\nList\n<\nString\n>) session.getAttribute(\n\"list\"\n);\n        response.setCharacterEncoding(\n\"UTF-8\"\n);\n        response.setContentType(\n\"text/html;charset=UTF-8\"\n);\n\n        \nfor\n (\nString\n s : list){\n            response.getWriter().write(s+\n\"\"\n);\n        }\n    }\n\n    \n@Override\n\n    \nprotected\n void doPost(\nHttpServletRequest\n request, \nHttpServletResponse\n response) \nthrows\n \nServletException\n, \nIOException\n {\n\n    }\n}\n\n\n", "Tag": "算法分析"}
{"Answer": "以前是plug-in 现在是dropins文件夹了\r\n\r\n看这个博客你就知道了http://jyw.iteye.com/blog/210109\r\n还解决不了我就不信了", "Konwledge_Point": "集合覆盖", "Question": "myeclipse7.1到底怎么装插件啊\n想装javafx，只能用7 版本的myeclipse。\n\n但是，昏过去，这个插件到底怎么装啊，不管本地，还是远程都没法装插件啊。\n\n\n\n不管怎么弄，它好像都要去联网去装或者升级很多不相关的插件，而不是只安装某个指定的插件。\n\n但是，每次都在网上卡死。\n\n我只要装一个javafx插件啊，难道我就不能直接装它一下就行了么。搞了两天了，还是装不上。\n\n\n\n真不知道为什么要搞个什么pulse,是不是eclipse以后也想搞专制。\n\n[b]问题补充：[/b]\n\n[quote]覆盖到 features 和 plugins 目录下是一种办法,一般插件下载了都是压缩包你解压到eclipse安装目录覆盖这就可以了 \n\n\n\n还有就是通过 Help---> Softwere Updates ---> find and install...-->>search for new features [/quote]\n\n\n\n这是以前版本才能用的；现在根本就不行了貌似。\n\n现在eclipse使用pulse来管理插件，以及升级。\n\n\n\n但我觉得这肯定通过某种方法还是能本地直接安装的，所以等待达人出现。\n\n[b]问题补充：[/b]\n\n[quote]\nhttp://www.vogella.de/articles/JavaFX/article.html#eclipse_install\n \n\n\n\n这个肯定可以帮到你了.图文并茂,教你怎么装javaFX插件[/quote]\n\n\n\n这个根本没用，没讲怎么装，我以前看过\n\n[b]问题补充：[/b]\n\n补充一下；从myeclipse7开始貌似跟以前结构完全不一样了。\n\n连原始eclipse都没有，全都集合在myeclipse自己里面了。\n\n连links目录也没有\n\n[b]问题补充：[/b]\n\n[quote]\nhttp://www.vogella.de/articles/Eclipse/article.html#updatemanager\n \n\n\n\n这里有说到怎么安装呀 \n\nHelp -> Software Updates-> \n\n单击Check for updates...(系统检测有没有可用跟新) \n\n选择Available Software选项卡 \n\n然后选择你要更新或者安装的插件,比如\"JavaFX plug-in\", \n\n单击manage sites按钮 \n\n选择JavaFx plug-in的更新站点,打开则可以看到安装包列表 \n\n\n\nTo add a new update site select on the tab \"Available Software\" the button \"Add Site\" and input the URL. This will then make this update site available and will allow you to install software from this site. \n\n\n\n添加一个新的更新站点,选择\"available Software\"(可用软件)选项卡,点击\"add site\"按钮,输入url(\nhttp://download.java.net/general/javafx/eclipse/windows/site.xml)不知道是不是这个,你试一下,就可以更新\n. \n\n\n\n1.4. Manual installation of plug-ins (dropins folder) \n\n\n\nIf you can't use or don't want to use the Eclipse update manager you can also put the plug-in into Eclipse dropins folder and restart Eclipse. After the restart Eclipse should detect the new plugin and install it for you. \n\n另外也可以从\nhttp://download.java.net/general/javafx/eclipse/windows/\n 这里下载插件来拷贝到 eclipse安装目录中的相应文件夹中,然后重启,就可以检测到 [/quote]\n\n\n\n这个网站说的方法是通过网络安装，这是不可能装的，好像国内根本就连不上那些网现在。\n\n另外已经说了，myeclipse7开始，就已经没有什么eclipse目录了，不支持link目录了。\n\n\n\n我现在网上看到有些人说可以放在dropins目录下，就是不知道怎么使用", "Tag": "算法分析"}
{"Answer": "＝ ＝ 在java内部实际上是有指针概念的。你想，使用具有指针概念的cpu写出来的java解释器哪能离开指针概念？再说就像代词一样，你哪能少了指向其它变量的变量啊。\r\n解释你的问题：你的obj指向一个数组对象，你每次是在把同一个数组对象add到了list里，也即list里每一个坑指向的都是同一个数组对象。", "Konwledge_Point": "集合覆盖", "Question": "关于 java Mysql的一个小问题，求帮忙解答\npackage ceshiJDBC;\n\n\n\nimport java.util.Properties;\n\nimport java.io.FileNotFoundException;\n\nimport java.io.FileReader;\n\nimport java.io.IOException;\n\nimport java.security.KeyStore.ProtectionParameter;\n\nimport java.sql.*;\n\nimport java.util.ArrayList;\n\nimport java.util.List;\n\n//object数组存储\n\npublic class ORMDemo {\n\n\n\nstatic Properties pro=null;\nstatic Connection con=null;\nstatic PreparedStatement ps=null;\nstatic ResultSet rs=null;\nstatic Object[] obj=null;\nstatic List list=new ArrayList();\n\nstatic {\n    try {\n        pro=new Properties();\n        pro.load(new FileReader(\"D:\\\\JavaEEeclipse\\\\ceshiJDBC\\\\src\\\\ceshiJDBC\\\\JDBC.properties\"));\n    } catch (FileNotFoundException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\npublic static void main(String[] args) {\n\n\n    try {\n        Class.forName(pro.getProperty(\"mysqlDriver\"));\n    } catch (ClassNotFoundException e) {\n        e.printStackTrace();\n    }\n\n    try {\n        con=new JDBCUtil().getCon();\n        ps=con.prepareStatement(\"select username,regTime from t_user where id>?\");\n        ps.setInt(1, 2);\n        rs=ps.executeQuery();\n         obj=new Object[2];\n        while(rs.next()) {\n            obj[0]=rs.getString(1);\n            obj[1]=rs.getDate(2);\n            list.add(obj);\n            System.out.println(rs.getString(1)+\"--\"+rs.getDate(2));\n        }\n    } catch (ClassNotFoundException e) {\n        e.printStackTrace();\n    } catch (SQLException e) {\n        e.printStackTrace();\n    }\n    for(Object[] lists:list) {\n\n            System.out.println(\"\"+lists[0]+lists[1]);\n\n    }\n\n}\n\n\n\n\n}\n\n输出结果：\n\nnam--2017-11-27\n\n??--2017-11-27\n\ngerg--2017-11-27\n\nrg--2017-11-27\n\nrg2017-11-27\n\nrg2017-11-27\n\nrg2017-11-27\n\nrg2017-11-27\n\n\n\n为什么数据存到集合中时正常，而最后都被覆盖了？\n\n就是说，为什么最后结果都是rg2017-11-27？？", "Tag": "算法分析"}
{"Answer": "* The List interface places additional stipulations, beyond those\r\n * specified in the Collection interface, on the contracts of the\r\n * iterator, add, remove, equals, and\r\n * hashCode methods.  Declarations for other inherited methods are\r\n * also included here for convenience.\r\n\r\n这个说的明白只是为了方便的，这样你就可以直接看到这个这个方法的注释了，不用再进入collection接口。因为基本上我们使用的都是list或是set。", "Konwledge_Point": "集合覆盖", "Question": "一个关于接口的继承的问题\n[code=\"java\"]public interface List extends Collection[/code]\n\n\n\n这是jdk中的结构.\n\ncollection中已经有size,isEmpty,toArray,isEmpty等方法,可是在list接口中,又去覆盖它,这是为什么啊,干嘛要多此一举?\n\n\n\n:x ", "Tag": "算法分析"}
{"Answer": "###解决了，我之前不知道为什么 @Autowried会失败，最后我使用手动注入RedisUtils，成功了。\n将原本的自动注入：\n@Autowired\n    private RedisUtils redisUtil\n\n改为手动注入：\nprivate RedisUtils redisUtil = BeanUtils.getBean(RedisUtils.class);\n\nBean工具类：\n@Component\npublic class BeanUtils implements ApplicationContextAware  {\n    protected static ApplicationContext applicationContext ;\n\n    @Override\n    public void setApplicationContext(ApplicationContext arg0) throws BeansException {\n        if (applicationContext == null) {\n            applicationContext = arg0;\n        }\n \n    }\n    /**\n     * 拿到ApplicationContext对象实例后就可以手动获取Bean的注入实例对象\n     */\n    public static <T> T getBean(Class<T> clazz) {\n        return applicationContext.getBean(clazz);\n    }\n}\n\n完美解决", "Konwledge_Point": "集合覆盖", "Question": "【报NullPointerException】springboot 中 websocket 的 @OnMessage 中使用自定义的工具类，报空指针异常\n问题遇到的现象和发生背景\n\n\n使用websocket谢了一个简单的聊天室，当聊天用户未上线的时候，给该未上线的用户发送消息，我是想保存将未上线用户为收到的消息保存到redis中，以便该未登录用户下次登录后可以从redis中获取其未登录是本应收到的消息。因为用户发送的消息是在onMessge中发送的，我在onMessage中使用自定义的RedisUtils（通过\n@Component注入到了springboot中了，用的时候使用了@Autowired自动装配），总是报“NullPointerException”。\n\n\n问题相关代码，请勿粘贴截图\n\n\n   @Autowired\n    \nprivate\n RedisUtils redisUtil;\n\n    \n// static：因为这个类是所有用户共享的，使用 static 可以保证存储的数据不会被覆盖\n\n    \nprivate\n static Map onlineUser = \nnew\n ConcurrentHashMap<>\n()\n;\n\n    \n// 声明 websocket session对象，使得每一个用户拥有自己的独立的 session，因此我们不能使用 static\n\n    \nprivate\n Session wsSession;\n\n    \n// 用户取出当前用户存在 httpSession 中的信息\n\n    \nprivate\n HttpSession httpSession;\n\n    @OnOpen\n    public void on\nOpen(Session \nsession\n, EndpointConfig \nendpointConfig\n)\n{\n        \ntry\n {\n            \n// 给当前的 WebSocket Session 赋值\n\n            this.wsSession = session;\n            \n// 获取 httpSession，并存入当前的 httpSession\n\n            this.httpSession = (HttpSession) endpointConfig.get\nUserProperties()\n.get(\nHttpSession\n.\nclass\n.get\nName()\n);\n\n            onlineUser.put((String) httpSession.get\nAttribute(\n\"userId\"\n)\n, this);\n        } catch (Exception e) {\n            e.print\nStackTrace()\n;\n        }\n    }\n\n@OnMessage\n    public void on\nMessage(String \nmessage\n, Session \nsession\n)\n{\n        \ntry\n {\n            \n// 将JSON 转换成 Object\n\n            MyMessage myMessage = \nJSON\n.\nparse\nObject(\nmessage\n, MyMessage.\nclass\n)\n;\n\n            \n// 获取要发送的消息（JSON）\n\n            String targetSendMessage = \nMessageUtils\n.\nget\nMessage(\nfalse\n,(String)\n httpSession.get\nAttribute(\n\"userId\"\n)\n, myMessage.get\nMessage()\n);\n\n            String listID = myMessage.get\nToName()\n + httpSession.get\nAttribute(\n\"userId\"\n)\n;\n\n            \n// 获取当前在线的用户集合\n\n            Set onlineUsers = onlineUser.key\nSet()\n;\n            \n// 若发送消息的目标在线，直接发送消息\n\n            \nif\n (onlineUsers.contains(myMessage.get\nToName()\n)) {\n                \n// 发送消息\n\n                onlineUser.get(myMessage.get\nToName()\n)    \n// 获取目标用户对应的 ChatEndpoint 类\n\n                        .wsSession   \n// 目标用户对应的 ChatEndpoint 类的成员变量\n\n                        .get\nBasicRemote()\n  \n//\n\n                        .send\nText(\ntargetSendMessage\n)\n;  \n// 发送消息（targetSendMessage  : JSON）\n\n\n            } \nelse\n { \n// 发送消息的目标不在线\n\n                \n// 获取以目标用户为主角的我们的聊天记录\n\n                List chatRecordOfText = get\nChatRecordOfText(\nlistID\n)\n;\n        } catch (IOException e) {\n            e.print\nStackTrace()\n;\n        }\n    }\n\n    \nprivate\n List get\nChatRecordOfText(String \nlistID\n)\n{\n        \ntry\n {\n            return redisUtil.l\nGet(\nlistID\n+\n\"chattxt\"\n, 0, -1)\n;\n        } catch (Exception e) {\n            e.print\nStackTrace()\n;\n            return \nnew\n ArrayList<>\n()\n;\n        }\n    }\n\n\n\n运行结果及报错内容\n\n\n\n\n\n\n我的解答思路和尝试过的方法\n\n\n1、我试过 new RedisUtils()，结果也是“空指针异常”\n\n\n我想要达到的结果\n\n\n能够在 OnMessage 使用自定义个 RedisUtils 访问 redis 服务器", "Tag": "算法分析"}
{"Answer": "需要先确定是否正确安装了jinja2，如果没有，通过pip install Jinja2安装一下，如果已经安装，那就可能是环境配置问题，确定一下你安装的什么版本的python，运行的时候又是用的什么版本的", "Konwledge_Point": "集合覆盖", "Question": "出现cannot import name 'Markup' from 'jinja2'怎么解决\n\n```python\n\nimport\n pandas \nas\n pd\n\nfrom\n pyecharts \nimport\n Geo,Line,Bar\n\nfrom\n pyecharts \nimport\n Overlap  \n# 图表叠加类\n\n\nfrom\n wordcloud \nimport\n WordCloud, ImageColorGenerator    \n# 词云图相关模块\n\n\nimport\n matplotlib.pyplot \nas\n plt                         \n# 绘制图表的模块\n\n\nfrom\n os \nimport\n path                                     \n# 路径\n\n\nimport\n collections                                      \n# 集合模块\n\n\nimport\n jieba                                            \n# 分词模块\n\n\nimport\n imageio                                          \n# 图片读取\n\n\n# 读取文件内容\n\ntomato_com = pd.read_excel(\n'夏洛特烦恼.xlsx'\n)\ngrouped = tomato_com.groupby([\n'city'\n])  \n# 按照城市名称进行数据的分组\n\ngrouped_pct = grouped[\n'score'\n]  \n# 获取分组后的评分信息\n\ncity_com = grouped_pct.agg([\n'mean'\n, \n'count'\n])  \n# 聚合数据，城市、平均分、数量\n\n        \n# 重置数据的索引\n\ncity_com.reset_index(inplace=\nTrue\n)\n        \n# 返回浮点数 0.01 返回到后两位\n\ncity_com[\n'mean'\n] = \nround\n(city_com[\n'mean'\n], \n2\n)\n        \n# 创建热力图实例对象\n\ngeo = Geo(\n'《夏洛特烦恼 》 全国热力图'\n, title_color=\n\"#fff\"\n,\n                  title_pos=\n\"center\"\n, width=\n1200\n,\n                  height=\n600\n, background_color=\n'#404a59'\n)\nflag = \nTrue\n\n        \n# 创建城市与对应数量的列表数据\n\ndata = [(city_com[\n'city'\n][i], city_com[\n'count'\n][i]) \nfor\n i \nin\n \nrange\n(\n0\n, city_com.shape[\n0\n])]\n\nwhile\n flag:\n            \n# 转换数据序列，将带字典和元组类型的序列转换为 k_lst,v_lst 两个列表\n\n    attr, value = geo.cast(data)\n    \ntry\n:\n                \n# 添加城市热点图\n\n                \n# attr城市名称、value对应数量、type类型、visual_range热点区间值、visual_text_color字体颜色\n\n                \n# is_visualmap是否为视觉地图、\n\n        geo.add(\n\"\"\n, attr, value, \ntype\n=\n\"heatmap\"\n, visual_range=[\n0\n, \n50\n], visual_text_color=\n\"#fff\"\n,\n                        is_visualmap=\nTrue\n)\n        flag = \nFalse\n     \n# 修改循环标记\n\n    \nexcept\n ValueError \nas\n e:\n        e = \nstr\n(e)\n        e = e.split(\n\"No coordinate is specified for \"\n)[\n1\n]  \n# 获取不支持的城市名\n\n        \nfor\n i \nin\n \nrange\n(\n0\n, \nlen\n(data)):\n            \nif\n e \nin\n \nlist\n(data[i]):\n                \ndel\n data[i]  \n# 将不支持城市名的数据删除\n\n                \nbreak\n\n            flag = \nTrue\n\n        \n# 生成全国热力图html文件\n\ngeo.render(\n'夏洛特烦恼全国热力图.html'\n)\n\n\n# 2、生成主要城市评论数及平均分文件\n\n\n# 通过排序获取数量排行前30的城市信息\n\ncity_main = city_com.sort_values(\n'count'\n, ascending=\nFalse\n)[\n0\n:\n30\n]\nattr = city_main[\n'city'\n]     \n# 获取城市名称的数据\n\nv1 = city_main[\n'count'\n]      \n# 获取数量\n\nv2 = city_main[\n'mean'\n]       \n# 获取平均分\n\nline = Line(\n\"主要城市评分\"\n)  \n# 折线图对象\n\n        \n# is_stack是否堆叠、xaxis_rotate（x轴城市名称旋转角度）\n\n        \n# yaxis_min（y轴最小值）\n\n        \n# mark_point（覆盖物的方式显示最高值和最小值）\n\n        \n# xaxis_interval（x轴间隔距离，底部显示城市名称之间的距离）\n\n        \n# line_color（线的颜色）\n\n        \n# line_width（线宽度）\n\n        \n# mark_point_textcolor（标记点文字的颜色）\n\n        \n# is_splitline_show（是否显示分割线）\n\nline.add(\n\"城市\"\n, attr, v2, is_stack=\nTrue\n, xaxis_rotate=\n45\n, yaxis_min=\n0\n,\n                 mark_point=[\n'min'\n, \n'max'\n], xaxis_interval=\n0\n, line_color=\n'lightblue'\n,\n                 line_width=\n4\n, mark_point_textcolor=\n'black'\n, mark_point_color=\n'yellow'\n,\n                 is_splitline_show=\nFalse\n)    \n# 添加折线图\n\nbar = Bar(\n\"主要城市评论数\"\n)          \n# 柱形图对象\n\nbar.add(\n\"城市\"\n, attr, v1, is_stack=\nFalse\n, xaxis_rotate=\n45\n, yaxis_min=\n0\n,\n                xaxis_interval=\n0\n, is_splitline_show=\nFalse\n,mark_point_color=\n'yellow'\n)   \n# 添加柱形图\n\noverlap = Overlap()    \n# 叠加图表对象\n\n        \n# 默认不新增 x y 轴，并且 x y 轴的索引都为 0\n\noverlap.add(bar)\noverlap.add(line, yaxis_index=\n1\n, is_add_yaxis=\nTrue\n)\n        \n# 生成主要城市评论数_平均分.html文件\n\noverlap.render(\n'主要城市评论数_平均分.html'\n)\n\n\n# 3、生成词云图\n\n\n# 获取评论内容\n\ntomato_str = \n' '\n.join(tomato_com[\n'comment'\n])\nwords_list = []  \n# 保存词汇的列表\n\n        \n# 分词\n\nword_generator = jieba.cut_for_search(tomato_str)\n\nfor\n word \nin\n word_generator:\n    words_list.append(word)  \n# 将拆分后的词汇添加至列表当中\n\nwords_list = [k \nfor\n k \nin\n words_list \nif\n \nlen\n(k) > \n1\n]  \n# 筛选词汇长度大于1的\n\nback_color = imageio.imread(\n'词云背景.jpg'\n)  \n# 读取图片\n\nwc = WordCloud(background_color=\n'white'\n,  \n# 背景颜色\n\n                       max_words=\n200\n,  \n# 最大词数\n\n                       mask=back_color,  \n# 以该参数值作图绘制词云，这个参数不为空时，width和height会被忽略\n\n                       max_font_size=\n300\n,  \n# 显示字体的最大值\n\n                       font_path=\n\"STFANGSO.ttf\"\n,  \n# 字体\n\n                       random_state=\n42\n,  \n# 为每个词返回一个PIL颜色\n\n                       \n# width=1000,  # 图片的宽\n\n                       \n# height=860  # 图片的长\n\n                       )\ntomato_count = collections.Counter(words_list)  \n# 统计数量\n\nwc.generate_from_frequencies(tomato_count)  \n# 生成词云图\n\n        \n# 基于彩色图像生成相应彩色\n\nimage_colors = ImageColorGenerator(back_color)\n        \n# 创建图形\n\nplt.figure()\n        \n# 显示彩色图像\n\nplt.imshow(wc.recolor(color_func=image_colors))\n        \n# 去掉坐标轴\n\nplt.axis(\n'off'\n)\n        \n# 保存词云图片\n\nwc.to_file(path.join(\n'词云.png'\n))\n\n\n\n\n为什么会出现这样的报错，这些库都安装了一个遍，是在pycharm上运行的\n\n\n\n\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "大部分比较基础，操作题有点费点时间。\n一、选择题\n1、D\n2、C\n3、B\n4、A\n5、B\n6、C\n7、C\n8、B\n9、A\n10、D\n11、C\n12、A\n13、D\n14、D\n15、B\n二、填空题\n1、[1,2]\n2、[6, 7, 9, 11]\n3、评分、降序\n4、代码如下，按照填空需求填空即可。\n\nlist1=['张杨华','韩冠浩','刘斯','李弘','关申海','李晓思','李思慧','刘潇斯','刘斯']\nlist1[list1.index('李弘')]='李泓'\nlist1.remove('刘斯')\nlist1.append('张瀚') \nprint(list1)\n5、代码如下，按照填空需求填空即可。\n\nt_array=[(4,5,6,7),(8,9,10,11),(12,13,14,15),(16,17,18,19)]\nsum=0\nfor arr in t_array:\n    for i in range(4):\n        sum+=arr[i]\nprint(sum)\n三、操作题\n1、代码如下，网上有一模一样的题目，不过代码有点问题，改正如下，思路就是排除法。\n\nimport string\ndef str_count(str):\n    count_en = count_dg = count_sp =count_zh = count_pu = 0\n    for s in str:\n        # 统计英文字母个数 \n        if s in string.ascii_letters:\n            count_en += 1 \n        # 统计数字个数\n        elif s.isdigit(): \n            count_dg += 1\n        # 统计空格个数 \n        elif s.isspace():\n            count_sp += 1 \n        # 统计中文个数\n        elif s.isalpha():\n            count_zh += 1\n        # 剩余就是标点符号 \n        else:\n            count_pu += 1 \n    print('英文字符:', count_en)\n    print('数字:', count_dg) \n    print('空格:', count_sp) \n    print('中文:', count_zh) \n    print('标点符号:', count_pu)\n2、代码如下，网上有类似的题目，不过这个题目要求更严格，所以for循环中这样写。\n\nimport random\nrandom.seed(0x1010)\ns=\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMOPQRSTUVWXYZ0123456789!@#$%&*-\" \nls=[]\nexcludes=\"\"\n\nwhile len(ls)<20:\n    pwd=\"\"\n\n    for i in range(3):\n        pwd+=random.choice(s[:26])\n        pwd+=random.choice(s[26:53])\n        pwd+=random.choice(s[53:64])\n        pwd+=random.choice(s[64:len(s)+1])\n        \n    if pwd[0] in excludes:\n        continue\n    else:\n        ls.append(pwd)\n        excludes+=pwd[0]\n\n    with open('激活码.txt','w') as f:\n        f.write('\\n'.join(ls))", "Konwledge_Point": "集合覆盖", "Question": "大佬们，可以帮我做做这张试卷吗。很快考试了。做一道也可以，给个答案就行了，\n  全国高等学校计算机水平考试II级---《Python 程序设计》考试大纲 (试行)\n\n一、考试目标与要求\n\n考试目标:测试考生系统掌握 Python 基本概念及其编程思想，了解 Python 计算生态，利 用 Python 进行数据处理及解决问题的能力。\n\n考试要求:\n\n1. 熟练掌握 Python 语言基础语法，掌握模块化程序设计思想，了解面向对象基本概念。 2. 熟练掌握 Python 常用标准库及第三方库的使用。\n\n3. 能够阅读和分析 Python 程序，利用 Python 进行简单的数据处理及数据可视化。\n\n二、考试内容\n\n(一)基础知识\n\n【考试要求】\n\n掌握Python中的常量、变量、数据类型、运算符、表达式、内置函数和基本输入输出。 【主要考点】\n\n1.常量与变量\n\n2.基本数据类型 3.运算符与表达式 4.数据类型转换 5.字符串类型及相关函数/方法 6.基本输入输出\n\n7. Python常用内置函数 8.注释\n\n(二)流程控制\n\n【考试要求】 掌握Python程序格式框架及书写风格，掌握顺序、选择、循环结构在Python中的实现方\n\n法，能灵活运用不同的控制结构解决实际问题。 【主要考点】\n\n1.顺序结构\n\n2. 选择结构:单分支、双分支、多分支选择结构，选择结构的嵌套\n\n3. 循环结构:for 循环、while 循环，带有 else 子句的循环，break 与 continue 语句的作\n\n用\n\n4. 程序的异常处理:try ---except\n\n(三)高级数据类型\n\n【考试要求】 掌握Python中列表、元组、字典、集合的使用方法以及应用场合;了解不同数据类型的\n\n     1/7\n\n\n\n  优缺点和适用领域;学会综合应用多种数据类型解决实际问题。 【主要考点】 1.列表:创建、删除、修改、切片、访问、排序;多维列表\n\n2. 元组:创建、删除、切片、访问\n\n3. 字典:创建、删除、添加、修改及访问，有序字典的使用\n\n4. 集合:创建、删除、访问，集合的并、交、差以及对称差等运算 5. 列表、元组、集合的区别及相互转换\n\n(四)模块化程序设计\n\n【考试要求】 了解模块化程序设计思想，掌握分而治之的结构化程序设计方法;掌握函数定义、参数传\n\n递及高级函数的使用;了解变量作用域的含义;掌握匿名函数的定义及使用。 【主要考点】\n\n1. 函数定义与使用\n\n2. 函数参数:默认参数、可变参数、关键字参数\n\n3. 变量作用域:局部变量和全局变量\n\n4. 匿名函数的定义及使用\n\n5. 高级函数(map、reduce、filter)的使用\n\n(五)面向对象程序设计\n\n【考试要求】 了解Python中面向对象程序设计的基本方法，包括类的定义与使用、类的属性、类中的\n\n特殊方法。\n\n【主要考点】\n\n1. 类的定义与使用\n\n2. 类成员访问控制\n\n3. 继承与多态\n\n4. 特殊方法与运算符重载\n\n(六)文件操作\n\n【考试要求】 要求考生掌握文件的基本操作,掌握CSV、Excel文件的读取。\n\n【主要考点】\n\n1. 文件的使用:打开、读写、定位和关闭 2. 一二维数据组织:存储、处理及可视化 3. 读写CSV格式数据文件\n\n4. 读取Excel格式数据文件(pandas库)\n\n(七)模块与库\n\n【考试要求】 了解Python生态系统，掌握Python常用标准库，运用第三方库解决实际问题,包括但不限\n\n于网络爬虫、数据分析、文本处理、数据可视化、机器学习、Web应用开发、网络编程等领域。 【主要考点】\n\n     2/7\n\n\n\n  1. Python常用标准库:random、math、string、OS、time、datetime、urllib.request。 2.第三方库:Matplotlib、pandas、jieba、wordcloud、requests、BeautifulSoup4、XPath、 NumPy、Scrapy。\n\n三、考试方式\n\n机试(考试时间:105 分钟)\n\n考卷题型题量:卷面总分 100。单选题(15 题，30 分)、填空题(5 题，30 分)和操作题\n\n(程序代码挖空题)(2 题，40 分)。\n\n四、考试环境要求\n\nPython 3.7 及以上，可选装 PyScripter、Pycharm、Anaconda、VSCode 等 IDE 编程环境。\n\n五、考试样题\n\n(一)单选题(15 题，30 分) 1、下面__________不是 Python 合法标识符。\n\nA) __name32 B) name32\n\nC) __name32__ D) 32name\n\n2、关于 Python 内存管理，下面__________说法错误。\n\nA) 当 Python 运行时垃圾回收也会启动\n\nB) python 会自己管理内存，对于占用很大内存的对象，并不会马上释放 C) Python 采用了类似 Windows 内核对象一样的方式来对内存进行管理 D) Python 语言，对象的类型和内存都是在运行时确定的\n\n3、在 Python3 中，下列不支持的数字类型是__________。\n\nA) 浮点型 B) 分数 C) 复数 D) 长整型\n\n4、下列不能作为字典的键是__________。 A) 变量\n\nB) 字符 C) 元组 D) 数字\n\n5、关于单引号，双引号，三引号的说法错误的是__________。\n\nA) 单引号和双引号是等效的\n\nB) 单引号，双引号，三引号，如果要换行，需要符号(\\)，不可以直接换行 C) 三引号则可以直接换行，并且可以包含注释\n\nD) 三引号可以包含双引号，而不需要转义\n\n6、在 Python3 中下列__________语句是非法的。\n\n     3/7\n\n\n\n  A) m=(n=a+1) B) a,b=b,a\n\nC) m,n='ab' D) m,n=3,4\n\n7、在 Python3 中，关于模块说法错误的是__________。\n\nA) 模块是对象\n\nB)模块是一个 Python 文件\n\nC) 模块能定义函数和变量，但不能定义类\n\nD) 在不同的模块中可以存在相同名字的函数名和变量名\n\n8、关于变量的作用域说法错误的是__________。\n\nA) 如果一个局部变量和一个全局变量重名，则局部变量会覆盖全局变量 B) Python 变量的作用域不由变量所在源代码中的位置决定\n\nC) 全局变量如果是在函数内部赋值的话，必须经过声明\n\nD) 全局变量在函数内部不经过声明也可以使用\n\n9、以下关于异常处理的描述，正确的是__________。\n\nA) try 语句中有 except 子句，但也可以有 finally 子句\n\nB) Python 中不允许利用 raise 语句由程序主动引发异常 C)引发一个不存在索引的列表元素会引发 NameError 错误 D)Python 中，可以用异常处理捕获程序中的所有错误\n\n  10、以下语句会无限循环下去的是__________。\n\n A) for n in range(1000): time.sleep(5)\n\nC) while False: continue\n\nB) while 1<10: time.sleep(10)\n\nD) while True: break\n\n11、Python 变量命名规则说法错误的是__________。\n\nA) 变量名不能包含空格，但可使用下划线来分隔其中的单词。 B) 不论是类成员变量还是全局变量，均不使用 m 或 g 前缀 C) 变量名只能包含字母、数字和下划线。以字母或数字开头 D) 变量名不应带有类型信息，因为 Python 是动态类型语言\n\n12、关于 Python 的 lambda 函数，以下选项中描述错误的是__________。\n\nA) f = lambda x,y:x+y 执行后，f 的类型为数字类型\n\nB) lambda 函数是指一类无需定义标识符(函数名)的函数或子程序\n\nC) lambda 函数可以接收任意多个参数 (包括可选参数) 并且返回单个表达式的值 D) lambda 的主体是一个表达式，而不是一个代码块\n\n13、以下选项中，不是 Python 语言保留字的是__________。 A) pass\n\nB) continue C) except D) next\n\n14、关于 Python 程序中与“缩进”有关的说法中，以下选项中不正确的是__________。\n\nA) 缩进统一为 4 个空格且强制使用\n\nB) Python 中的每一条语句都有一个缩进级别，并且缩进级别会使用栈的数据结构进行存\n\n储\n\n  4/7\n\n\n\n  C) Python 中的缩进是有语法含义的，它用来表示一个代码块 D) 一条比较长的语句也可以用缩进分成多行\n\n15、关于 Python 循环结构，以下选项中描述错误的是__________。\n\nA) 每个 continue 语句只有能力跳出当前层次的循环\n\nB) continue 语句被用来告诉 Python 跳过当前循环块中的剩余语句，然后继续进行下一轮\n\n循环\n\nC) break 跳出并结束当前整个循环，执行循环后的语句\n\nD) while 循环不会迭代 list 或 tuple 的元素，而是根据表达式判断循环是否结束\n\n(二)填空题(5 题，30 分)\n\n1、表达式 [x for x in [1,2,3,4,5] if x<3]的值为 1\n\n2、设列表对象 aList 的值为[3, 4, 5, 6, 7, 9, 11, 13, 15, 17]，那么 aList[3:7]得到的值是 2 3、从猫眼电影热门榜单上爬取电影信息(包括电影名、主演、上映时间、评分)，结果保存 形式为 item= [('少年的你','主演:周冬雨','上映时间:06-27',9.5),┈],那么使用 item.sort(key=lambda x:x[3],reverse=True)语句的作用是对 3 (电影名/主演/上映时间/评 分)进行 4 (升序/降序)排列\n\n4、list1 中存放李小姐结婚请帖名单，她发现把“李泓”写成了“李弘”，少写“张瀚”， “刘 斯”名字有重复，得把第一删除，请补全横线处的代码，请你帮她更正过来。\n\nlist1=['张杨华','韩冠浩','刘斯','李弘','关申海','李晓思','李思慧','刘潇斯','刘斯'] 5 ('李泓')\n\n6 ('刘斯')\n\n7 ('张瀚') print(list1)\n\n5、t_array 中存放 4╳4 的二维数组，下列程序是计算该二维数组各元素的和，请完善下列代 码。\n\nt_array=[(4,5,6,7),(8,9,10,11),(12,13,14,15),(16,17,18,19)] sum= 8\n\nfor arr in t_array:\n\nfor i in 9 : 10\n\nprint(sum)\n\n(三)操作题(程序代码挖空题)(2 题，40 分)\n\n                  5/7\n\n\n\n  1、在考试操作试题文件夹里，打开“gdpython1.py”文件，按下面的要求完成操作: 从键盘上输入一段文字，调用下列函数，能统计出该段文字的中文个数、英文个数、数\n\n字个数和标点符号的个数。请完善代码。\n\nimport string\n\ndef str_count(str):\n\ncount_en = count_dg = count_sp =count_zh = count_pu = 0 for s in str:\n\n# 统计英文字母个数 if s in string. 1 :\n\ncount_en += 1 # 统计数字个数\n\nelifs. 2 : count_dg += 1\n\n# 统计中文个数 elifs. 3 :\n\ncount_zh += 1 # 统计空格个数\n\nelif s. 4 : count_sp += 1\n\n# 统计标点符号个数 else:\n\ncount_pu += 1 print('英文字符:', count_en)\n\nprint('数字:', count_dg) print('空格:', count_sp) print('中文:', count_zh) print('标点符号:', count_pu)\n\n2、在考试操作试题文件夹里，打开“gdpython2.py”文件，按下面的要求完善列代码，生产 随机激活码。具体要求如下:\n\n(1) 使用random库，采用0x1011作为随机种子。\n\n(2) 每次产生20条激活码，且首字不能一样。每条激活码单独一行。\n\n(3) 必须包含大写字母、小写字母和数字，必需包括“!@#$%&*-”8个特殊符号中的某\n\n一个。\n\n(4) 每次激活码产生的长度为12位。\n\n(5) 不能重复。\n\n(6) 程序所产生的激活码保存在“激活码.txt”文件中。\n\nimport random\n\nrandom. 1 s=\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMOPQRSTUVWXYZ0123456789!@#$%&*-\" ls=[]\n\nexcludes=\"\"\n\nwhile 2 :\n\n          pwd=\"\"\n\n 6/7\n\n\n\n  for i in 3 : 4\n\nif pwd[0] in excludes:\n\n5\n\nelse:\n\nls. 6\n\nexcludes+= 7 with open('激活码.txt','w') as f:\n\nf.write('\\n'. 8 )\n\n           7/7", "Tag": "算法分析"}
{"Answer": "题太多。。。。\r\n第3题，B\r\n第42题，静态变量是用static修饰的，在内存中只有一份，所有实例共享，实例变量是每个实例自己的。\r\n41：tomcat是web服务器，同时也是servlet的容器\r\n35：jsp有4种会话跟踪技术？ cookie和url重写2种\r\n32：j2ee是技术规范，也可以理解为平台\r\n25：string是final类了", "Konwledge_Point": "集合覆盖", "Question": "做了一个小时的面试题（没有过  希望大家帮忙答下  虽然很幼稚  毕竟每个人都是这么过来的吗  感激了！）\nXX软件工程师笔试试题\n\n注：1、请参考人员将答案写在答题纸上，勿将答案写在此卷上。\n\n2、请参考人员将编号与姓名填写在答题纸上。\n\n\n\n1、    以下数据结构中不属于线性数据结构的是（）。\n\nA、队列   B、线性表   C、二叉树  D、栈\n\n我的答案：C\n\n\n\n2、    在结构化方法中，用数据流程图（DFD）作为描述工具的软件开发阶段是（）。\n\nA、    可行性分析  B、需求分析  C、详细设计  D、程序编码\n\n我的答案：B\n\n\n\n3、    结构化程序设计主要强调的是（）。\n\nA、    程序的规模  B、程序的易读性  C、程序的执行效率  D、程序的可移植性\n\n我的答案：C\n\n\n\n4、    在软件生命周期中，能准确地确定软件系统必须做什么和必须具备哪些功能的阶段（）。\n\nA、    概要设计  B、详细设计  C、可行性分析  D、需求分析\n\n我的答案：B\n\n\n\n5、    下列关于栈的叙述中正确的是（）。\n\nA、    在栈中只能插入数据  B、在栈中只能删除数据\n\nB、    栈是先进先出的线性表  D、栈是先进后出的线性表\n\n我的答案：D\n\n\n\n6、    下面不属于软件设计原则的是（）。\n\nA、    抽象  B、模块化  C、自底向上  D、信息隐蔽\n\n我的答案：C\n\n\n\n7、    对长度为N的线性表进行顺序查找，在最坏情况下所需要的比较次数为（）。\n\nA、    N+1  B、N  C、（N+1）/2  D、N/2\n\n我的答案：C\n\n\n\n8、    视图设计一般有3种设计次序，下列不属于视图设计的是（）。\n\nA、    自顶向下  B、由外向内  C、由内向外  D、自底向上\n\n我的答案：C\n\n\n\n9、下列有关数据库的描述，正确的是（）。\n\nA、数据库是一个DBF文件  B、数据库是一个关系\n\nC、数据库是一个结构化的数据集合  D、数据库是一组文件\n\n我的答案：C\n\n\n\n10、下列说法中，不属于数据模型所描述的内容的是（）。\n\nA、数据结构  B、数据操作  C、数据查询  D、数据约束\n\n我的答案：A\n\n\n\n11、若按功能划分，软件测试的方法通常分为白盒测试方法和（黑盒测试方法）。\n\n\n\n12、数据库系统的三级模式分别为（级联）模式、内部级模式与外部级模式。\n\n\n\n13、在最坏情况下，冒泡排序的时间复杂度为（N+1/2）。\n\n\n\n14、在面向对象方法中，信息隐蔽是通过对象的（封装）性来实现的。\n\n\n\n15、关系模型的数据操纵既是建立在关系上的数据操纵，一般有（插入）、增加、删除、和修改四种操作。\n\n\n\n16、TIME（）的返回值的数据类型是（String）类型。\n\n\n\n17、编写SQL语句\n\n  1）、创建一张学生表，包含以下信息，学号，姓名，年龄，性别，家庭住址，联系电话\n\n  我的答案：\n\n  create table student(\n\n  studentCardNo number(2) primary key,\n\n  name char(10),\n\n  age number(2),\n\n  sex char(2) check(sex in (‘男’,’女’)),\n\n  address varchar2(100),\n\n  tel number(2)\n\n  )\n\n\n\n2)、修改学生表的结构，添加一列信息，学历\n\n  我的答案：\n\n  alter table student add(xueli varchar2(20));\n\n\n\n3)、修改学生表的结构，删除一列信息，家庭住址\n\n  我的答案：\n\n  alter table student drop column address;\n\n\n\n4)、向学生表添加如下信息：\n\n      学号  姓名  年龄  性别  联系电话  学历\n\n        1    A     22    男    123456   小学\n\n        2    B     21    男     119     中学\n\n        3    C     23    男     110     高中\n\n        4    D     18    女     114     大学\n\n   我的答案：\n\n   insert into student values(‘&1’,’&2’,’&3’);\n\n   一次一次添加\n\n\n\n5)修改学生表的数据，将电话号码以11开头的学员的学历改为“大专”\n\n   我的答案：\n\n   update student set xueli=”大专” where tel like 11%;\n\n\n\n6)删除学生表的数据，姓名以C开头，性别为‘男’的记录删除\n\n   我的答案：\n\n   delete student where name like C% or sex=”男”;\n\n  7)查询学生表的数据，将所有年龄小于22岁的，学历为“大专”的，学生的姓名和学号显示出来\n\n   我的答案：\n\n   select name,studentCardNo from student where age<22 and xueli=”大专”;\n\n  8)查询学生表的数据，查询所有信息，列出前25%的记录\n\n   我的答案：\n\n   select top*0.25 from student;\n\n  9）查询出所有学生的姓名，性别，年龄降序排列\n\n   我的答案：\n\n   select name,sex,age from student where age desc;\n\n  10）按照性别分组查询所有的平均年龄\n\n   我的答案：\n\n   select avg(age) from student group by sex;\n\n\n\n18、什么是存储过程？为什么存储过程要比单纯的SQL语句执行起来要快？\n\n   我的答案：\n\n   存储过程算是一种优化查询需要比单存SQL语句执行的要快\n\n19、两张关联表，删除主表中已经在副表中没有的信息\n\n我的答案\n\n   delete from  fubiao a where a.fid not in(select id from zhubiao)\n\n20、程序题：\n\n用1、2、2、3、4、5这六个数字，用java或你熟悉的语言，打印出所有不同的排列，如：512234、412345等，要求：“4”不能再第三位，“3”与“5”不能相连。并将这些数据按从小到大输出。\n\n我的答案\n\n   我的写的不好 没贴下  笔试的时候没写全\n\n21、String 和 StringBuffer的区别\n\n我的答案\n\n    String定长 StringBuffer 变长\n\n22、&和&&的区别\n\n我的答案\n\n  &短路与 &&逻辑与\n\n网上答案：\n\n& 是位运算符，表示按位与运算，\n\n  && 是逻辑运算符，表示逻辑与（and）。\n\n23、final，finally，finalize的区别\n\n我的答案\n\nFinal静变量关键字，finally异常关键字，finalize\n\n网上答案\n\nfinal 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。\n\n  finally是异常处理语句结构的一部分，表示总是执行。\n\n  finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，\n\n  可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。\n\n24、数组有没有length（）这个方法？String有没有length（）这个方法？\n\n我的答案：\n\n数组没有length()这个方法，有length的属性。\n\nString有length()这个方法。\n\n25、是否可以继承String类？\n\n我的答案：\n\n不可以  解释的很乱\n\n26、说出数据连接池的工作机制是什么？\n\n我的答案：\n\n反正解释的很乱我感觉\n\n27、垃圾回收的优点和原理。并考虑2种回收机制。\n\n    我的答案：\n\n动态回收  解释的很乱\n\n网上答案：\n\nJava语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，\n\n  它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有\"作用域\"的概念，\n\n  只有对象的引用才有\"作用域\"。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。\n\n  垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有\n\n  使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。\n\n  回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。  \n\n\n\n28、你所知道的集合类都有哪些？区别？主要方法？\n\n    我的答案：\n\n    Arraylist 非线性的、Vertor线性的 \n\n29、JSP的内置对象及方法。\n\n    我的答案：\n\n    Page,exception,out,page content,application,request,reponse,session,config\n\n30、页面间对象传递的方法。\n\n我的答案：\n\n那几个方法都写错了\n\n31、你知道Request对象的主要方法有哪些？\n\n\n\n32、J2EE是技术还是平台还是框架？\n\n    我的答案：\n\nJ2EE是技术也是平台\n\n网上答案：\n\nJ2EE本身是一个标准，一个为企业分布式应用的开发提供的标准平台。\n\n J2EE也是一个框架，包括JDBC、JNDI、RMI、JMS、EJB、JTA等技术。\n\n33、我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种（例如GBK编码类型）编码的字符串？\n\n   Request encording(“GBK”)\n\n34、j2ee常用的设计模式？说明工厂模式。\n\nGof23种设计模式\n\n工厂模式：Factory\n\n网上答案：\n\nJava中的23种设计模式：\n\n    Factory（工厂模式），      Builder（建造模式），       Factory Method（工厂方法模式），\n\n    Prototype（原始模型模式），Singleton（单例模式），    Facade（门面模式），\n\n    Adapter（适配器模式），    Bridge（桥梁模式），        Composite（合成模式），\n\n    Decorator（装饰模式），    Flyweight（享元模式），     Proxy（代理模式），\n\n    Command（命令模式），      Interpreter（解释器模式）， Visitor（访问者模式），\n\n    Iterator（迭代子模式），   Mediator（调停者模式），    Memento（备忘录模式），\n\n    Observer（观察者模式），   State（状态模式），         Strategy（策略模式），\n\n    Template Method（模板方法模式）， Chain Of Responsibleity（责任链模式）\n\n  工厂模式：工厂模式是一种经常被使用到的模式，根据工厂模式实现的类可以根据提供的数据生成一组类中某一个类的实例，\n\n  通常这一组类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作。\n\n  首先需要定义一个基类，该类的子类通过不同的方法实现了基类中的方法。\n\n  然后需要定义一个工厂类，工厂类可以根据条件生成不同的子类实例。\n\n  当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。\n\n35、JSP四种会话跟踪技术\n\n    我的答案：\n\n    Application  cookie  session\n\n36、排序都有哪几种方法？请举例\n\n冒泡 选择 快序 二分查找\n\n网上答案：\n\n排序的方法有：插入排序（直接插入排序、希尔排序），\n\n                交换排序（冒泡排序、快速排序），\n\n                选择排序（直接选择排序、堆排序），\n\n                归并排序，分配排序（箱排序、基数排序）\n\n  快速排序的伪代码。\n\n    //使用快速排序方法对a[ 0 :n- 1 ]排序\n\n    从a[ 0 :n- 1 ]中选择一个元素作为m i d d l e，该元素为支点\n\n   把余下的元素分割为两段left 和r i g h t，使得l e f t中的元素都小于等于支点，而right 中的元素都大于等于支点\n\n   递归地使用快速排序方法对left 进行排序\n\n   递归地使用快速排序方法对right 进行排序\n\n   所得结果为l e f t + m i d d l e + r i g h t\n\n37、关于模块间的设计原则？\n\n    规范要一样\n\n38、项目过程一般是怎样的？你参加过几个项目开发？参加过的项目流程是怎样的？自己负责与人合作工作内容及自我评价？\n\n   从需求调研——设计开发——实施\n\n参加过网站的实施 模板的制作\n\n39、tomcat自动关闭常见原因？\n\n我的答案：\n\n现在没遇到过\n\n40、如何设置TOMCAT内存和连接数？\n\n    我的答案：\n\n    Tomcat群集\n\n41、你如何理解Tomcat是什么？\n\n    我的答案：\n\n    Tomcat是JSP Servlet 容器恰当的说\n\n42、静态变量和实例变量的区别？\n\n    我的答案：\n\n    静态变量域用final修饰，每次都被调用 实例变量则不会\n\n43、IE、FF下面CSS的解释区别\n\n    我的答案：\n\n    自己编的\n\n44、web前端技术你了解哪些技术？\n\n    我的答案：\n\n    JAVAScript,CSS,DIV,Ajax,Ajax框架，DWR,dojo,jguery\n\n45、什么是报表？什么是报表控件，作用是什么？你了解哪些报表工具？\n\n    我的答案：\n\n    解释的很乱\n\n46、你了解的那些统计图表类型？\n\n    我的答案：\n\n    自己编的\n\n47、Flex与数据库连接的三种方式？ \n\n    我的答案：\n\n    自己编的\n\n\n\n我答错的、  错在哪里？  没答上的帮忙解答下？  感激了 ！  ", "Tag": "算法分析"}
