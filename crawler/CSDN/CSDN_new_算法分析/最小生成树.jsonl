{"Answer": "普里姆算法是选顶点\r\n假设从A点出发构造最小生成树，距离A点最近的是D点，连接AD；然后距离A、D最近的是B点，连接BD；然后距离A、D、B最近的是C点，连接BC；\r\n然后距离A、D、B、C最近的是F点，连接CF；然后距离A、D、B、C、F最近的是G，连接FG；然后距离A、D、B、C、F、G点最近的是E点，连接GE；\r\n然后距离A、D、B、C、F、G、E点最近的是H点，连接EH。\r\n最小生成树为ADBCFGEH\r\n克鲁斯卡尔算法是选边\r\n边权为2最小，连接BC，EG；然后边权为3最小，连接EH；然后边权为4最小，连接CF，AD；然后边权为5最小，连接BD，FG。\r\n最小生成树为ADBCFGEH", "Konwledge_Point": "最小生成树", "Question": "用普里姆算法或克鲁斯卡尔算法求下面无向带权图的最小生成树\n用普里姆算法或克鲁斯卡尔算法求下面无向带权图的最小生成树", "Tag": "算法分析"}
{"Answer": "不对，这题应该选A\r\n求顶点的入度的时间复杂度为O(e)*n=O(n*e)\r\n遍历顶点的时间复杂度是O(n^2)\r\n相加是O(n^2+n*e)=O(n^2)", "Konwledge_Point": "最小生成树", "Question": "在图采用邻接表存储时，求最小生成树的Prime算法的时间复杂度为?\n在图采用邻接表存储时，求最小生成树的Prime算法的时间复杂度为?\n\nA o(n^2) B o(n^3) C o(n) D o(n+e)\n\n答案是o(n+e)。。。不理解..求过程", "Tag": "算法分析"}
{"Answer": "原理可以从 算法4th 中学习，\r\n里面讲了三种算法 csharp 代码：\r\n1. [KruskalMinimumSpanTree](https://github.com/FuGangqiang/algorithms/blob/master/Books/Algorithms/Chap4/KruskalMinimumSpanTree.cs \"\")\r\n2. [LazyPrimMinimumSpanTree](https://github.com/FuGangqiang/algorithms/blob/master/Books/Algorithms/Chap4/LazyPrimMinimumSpanTree.cs \"\")\r\n3. [PrimMinimumSpanTree](https://github.com/FuGangqiang/algorithms/blob/master/Books/Algorithms/Chap4/PrimMinimumSpanTree.cs \"\")", "Konwledge_Point": "最小生成树", "Question": "求一个   最小生成树聚类  的程序\n求一个最小生成树的聚类的程序，谢谢。最好是c++语言，当然matlab，java，python程序也可以。", "Tag": "算法分析"}
{"Answer": "http://bbs.csdn.net/topics/380240225", "Konwledge_Point": "最小生成树", "Question": "类似最小生成树的算法求解答\n输入一些二元组，二元组代表连通的两个节点。所有的二元组构成一个无向图。现在请你设计一个算法，求出一个最小生成树，使得图中没有回路，并且连接所有节点。输出的数据也用二元组表达。\n\n要用Java或者C#来实现。", "Tag": "算法分析"}
{"Answer": "当然不一定了。例如： 5个顶点 12345 的全连通图，取出 4条边（12，13，23，45）和 5个顶点 12345，并不是连通图。", "Konwledge_Point": "最小生成树", "Question": "关于连通图和最小生成树\n对于一个有n个顶点的连通图，最少有N-1条边，最多有C(n,2)条边\n那么如果现在这个连通图有C（n,2)条边，那么我取任意n-1条边出来和n个顶点组成一个新图，那么这个新图还是连通图吗", "Tag": "算法分析"}
{"Answer": "https://www.cnblogs.com/qscqesze/p/5246222.html", "Konwledge_Point": "最小生成树", "Question": "最小生成树方面的一个问题，用C语言怎么解决的？？？？\nProblem Description\n\nThere is an undirected graph G with n vertices and m edges. Every time, you can select several edges and delete them. The edges selected must meet the following condition: let G′ be graph induced from these edges, then every connected component of G′ has at most one cycle. What is the minimum number of deletion needed in order to delete all the edges.\n\n\n\nInput\n\nThere are multiple test cases. The first line of input contains an integer T indicating the number of test cases. For each test case:\n\n\n\nThe first line contains two integers n and m (1≤n≤2000,0≤m≤2000) -- the number of vertices and the number of edges.\n\n\n\nFor the next m lines, each line contains two integers ui and vi, which means there is an undirected edge between ui and vi (1≤ui,vi≤n,ui≠vi).\n\n\n\nThe sum of values of n in all test cases doesn't exceed 2⋅104. The sum of values of m in all test cases doesn't exceed 2⋅104.\n\n\n\nOutput\n\nFor each test case, output the minimum number of deletion needed.\n\n\n\nSample Input\n\n3\n\n4 2\n\n1 2\n\n1 3\n\n4 5\n\n1 2\n\n1 3\n\n1 4\n\n2 3\n\n2 4\n\n4 4\n\n1 2\n\n2 3\n\n3 4\n\n4 1\n\n\n\nSample Output\n\n1\n\n2\n\n1", "Tag": "算法分析"}
{"Answer": "http://hzwer.com/3666.html", "Konwledge_Point": "最小生成树", "Question": "最小生成树                 \nDescription\n\n\n\n　给定一个边带正权的连通无向图G=(V,E)，其中N=|V|，M=|E|，N个点从1到N依次编号，给定三个正整数u，v，和L (u≠v)，假设现在加入一条边权为L的边(u,v)，那么需要删掉最少多少条边，才能够使得这条边既可能出现在最小生成树上，也可能出现在最大生成树上？\n\n\n\nInput\n\n\n\n　　第一行包含用空格隔开的两个整数，分别为N和M；\n\n接下来M行，每行包含三个正整数u，v和w表示图G存在一条边权为w的边(u,v)。\n\n最后一行包含用空格隔开的三个整数，分别为u，v，和 L；\n\n数据保证图中没有自环。\n\nOutput\n\n\n\n　输出一行一个整数表示最少需要删掉的边的数量。\n\n\n\nSample Input\n\n\n\n3 2\n\n3 2 1\n\n1 2 3\n\n1 2 2\n\nSample Output\n\n\n\n1", "Tag": "算法分析"}
{"Answer": "prim算法\ndef findTree(G:dict):\n    start = list(G.keys())[0]\n    choice = [(start, i, j) for i, j in G[start].items()]\n    choice.sort(key=lambda x:x[2])\n    tree = list()\n    seen = {start}\n    while choice:\n        node = choice.pop(0)\n        if node[1] not in seen:\n            seen.add(node[1])\n            line = sorted([node[0],node[1]])\n            line.append(node[2])\n            tree.append(line)\n            for i, j in G[node[1]].items():\n                choice.append((node[1],i,j))\n            choice.sort(key=lambda x:x[2])\n    return tree\n\nif __name__ == \"__main__\":\n    graph = {\n    \"a\":{\"b\":10, \"c\":8, \"f\":5},\n    \"b\":{\"a\":10, \"d\":9, \"f\":7},\n    \"c\":{\"a\":8, \"e\":10, \"f\":17},\n    \"d\":{\"b\":9, \"e\":11, \"f\":12, \"g\":4},\n    \"e\":{\"c\":10, \"d\":11, \"f\":3, \"g\":16},\n    \"f\":{\"a\":5, \"b\":7, \"c\":17, \"d\":12, \"e\":3},\n    \"g\":{\"d\":4, \"e\":16}\n    }\n    lines = set()\n    for node, value in graph.items():\n        for i, j in value.items():\n            temp = sorted([node,i])\n            temp.append(j)\n            lines.add(tuple(temp))\n    print(lines)\n    tree = findTree(graph)\n    print(tree)\n", "Konwledge_Point": "最小生成树", "Question": "关于最小生成树的应用\n已知带权无向图（如下所示），求最小生成树。Program2用图要求输出：(1)所有的边及权值，如：（‘a’,’b’,10）…(2)最小生成树所包含的边，如：（’a’,‘c’,‘weight’:8）…\n\n", "Tag": "算法分析"}
{"Answer": "ArcGIS是一个功能丰富的地理信息系统(GIS)工具，可以用来处理和分析地理数据。要在ArcGIS中构建最小生成树网络(Minimum Spanning Tree, MST)，可以使用其中的\"Network Analyst\"工具。\n首先，需要拥有一个点数据集和一个边数据集。这些数据集可以来自 shapefile 文件，CSV文件或者是GDB文件。\n打开ArcMap，添加点数据集和边数据集到地图中。\n打开 \"Network Analyst\"工具，在工具栏中选\"New Network Analysis Layer\"。\n在弹出的窗口中，选择“Connectivity”作为类型，并指定点数据集作为终点，边数据集作为边。\n点击 \"OK\"按钮，创建网络分析层。\n在 \"Network Analyst\"面板中，选择 \"Generate Service Area\"工具。\n在弹出的窗口中，选择要求的选项（比如网络设置，分析阈值等）\n在 \"Solver\"栏中，选择“Minimum Spanning Tree\"，并点击 \"Solve\"按钮运行分析。\n分析完成后，结果将显示在地图上，表示最小生成树的路径。\n可以通过导出成 shapefile或者其他文件格式来保存结果，或者在 ArcGIS Pro里继续分析。\n另外，需要注意的是,使用\"Network Analyst\"工具构建的最小生成树，是基于空间关系的，即根据点之间的距离构建最小生成树,如果需要根据权重来构建最小生成树，需要在边数据中设置权重属性,并在Network Analyst中对权重属性进行设置。", "Konwledge_Point": "最小生成树", "Question": "如何用argis构建最小生成树网络\n想使用arcgis构建最小生成树网络 该方法来源于faber2014的一篇文章 但是不知道如何具体操作", "Tag": "算法分析"}
{"Answer": "第一题D  1+2+4+7=14第二题 一个或多个", "Konwledge_Point": "最小生成树", "Question": "分别选择什么，第一道题有没有最小生成树的图示啊\n分别选择什么，第一道题有没有最小生成树的图示啊，谢谢，辛苦辛苦\n\n", "Tag": "算法分析"}
{"Answer": "这道题一看就是最小生成树，有两种方法，分别为普里姆算法（prim）和克鲁斯卡尔（kruskal）本题解使用的是 kruskal假设连通网G＝（V，E），则令最小生成树的初始状态为只有n个顶点而无边的非连通网，图中每个顶点自成一个连通分量。在E中选择代价最小的边，若该边依附的顶点落在T中不同的连通分量上，则将此边加入到T中，否则舍去此边而选择下一条代价最小的边。依此类推，直至T中所有顶点都在同一连通分量上为止。\n\n#include<stdio.h>\n#include<string.h>\n#include<iostream>\nusing namespace std;\nint n,a[105][105],v[105],p,q,minn,ans,m;\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n     for(int j=1;j<=n;j++)\n      scanf(\"%d\",&a[i][j]);\n    for(int i=1;i<=n;i++)v[i]=i; //全部点都是一定单独的集合\n    for(int i=1;i<=n-1;i++){ //只用循环到n-1，因为只有n-1条边\n        minn=99999999; //minn要赋最大值，一定不要赋0x7f\n        for(int k=1;k<=n;k++)\n         for(int j=1;j<=n;j++)\n          if(v[k]!=v[j] and a[k][j]<=minn and a[k][j]!=0){\n              minn=a[k][j];\n              p=j; //记录j和k，供后面使用\n              q=k;\n          }\n        ans+=minn; //把权值加上去\n        int t=v[p];\n        for(int k=1;k<=n;k++){\n            if(v[k]==t)v[k]=v[q]; //把v[k]集合的点全部变成v[q]集合的点，符合克鲁斯卡尔算法的思想\n        }\n    }\n    printf(\"%d\",ans);\n    return 0;\n}\n", "Konwledge_Point": "最小生成树", "Question": "关于最小生成树的问题，如何修改？(语言-c++)\n\n\n【最小生成树专题】最短网络 (Standard IO)\n时间限制: 1000 ms  空间限制: 262144 KB  具体限制  \n\n\n\n\n题目描述\n农民约翰被选为他们镇的镇长！他其中一个竞选承诺就是在镇上建立起互联网，并连接到所有的农场。当然，他需要你的帮助。约翰已经给他的农场安排了一条高速的网络线路，他想把这条线路共享给其他农场。为了用最小的消费，他想铺设最短的光纤去连接所有的农场。你将得到一份各农场之间连接费用的列表，你必须找出能连接所有农场并所用光纤最短的方案。每两个农场间的距离不会超过100000。\n\n\n输入\n第一行：农场的个数，N（3<=N<=100）。\n后来的行包含了一个N*N的矩阵,表示每个农场之间的距离。理论上，他们是N行，每行由N个用空格分隔的数组成，实际上，他们限制在80个字符，因此，某些行会紧接着另一些行。当然，对角线将会是0，因为不会有线路从第i个农场到它本身。\n\n\n输出\n只有一个输出，其中包含连接到每个农场的光纤的最小长度。\n\n\n样例输入\n4\n0  4  9  21\n4  0  8  17\n9  8  0  16\n21 17 16  0\n\n\n样例输出\n28\n\n\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\nint\n a[\n105\n][\n105\n],s,n,visit[\n105\n],visitt;\nqueue<\nint\n> q;\n\nvoid\n \npr\n()\n\n\n{\n    q.\npush\n(\n1\n);\n    visit[\n1\n]=\n1\n;\n    \nwhile\n(\n1\n)\n    {\n        \nint\n minn=\n100005\n,minni;\n        \nfor\n(\nint\n j=\n1\n;j<=n;j++)\n        {\n            \nif\n(a[q.\nfront\n()][j]>n;\n    \nfor\n(\nint\n i=\n1\n;i<=n;i++)\n    {\n        \nfor\n(\nint\n j=\n1\n;j<=n;j++)\n        {\n            cin>>a[i][j];\n        }\n    }\n    \npr\n();\n    cout<<s;\n}\n\n\n\n\n\n我哪里错了，求指明！", "Tag": "算法分析"}
{"Answer": "楼主可以参考这个，很可能对楼主有用： [url]http://www.cnblogs.com/codeyu/archive/2009/09/03/1559736.html[/url]", "Konwledge_Point": "最小生成树", "Question": "我有个java连接网络的程序，想要在windows登陆前执行这个程序，请教该如何做\n我有个java连接网络的程序，想要在windows开机以后，用户登陆前执行这个程序，请教该如何做", "Tag": "算法分析"}
{"Answer": "http://www.cnblogs.com/Fatedayt/archive/2011/09/19/2181775.html", "Konwledge_Point": "最小生成树", "Question": "迷宫城堡             \nProblem Description\n\n为了训练小希的方向感，Gardon建立了一座大城堡，里面有N个房间(N<=10000)和M条通道(M<=100000)，每个通道都是单向的，就是说若称某通道连通了A房间和B房间，只说明可以通过这个通道由A房间到达B房间，但并不说明通过它可以由B房间到达A房间。Gardon需要请你写个程序确认一下是否任意两个房间都是相互连通的，即：对于任意的i和j，至少存在一条路径可以从房间i到房间j，也存在一条路径可以从房间j到房间i。\n\n\n\nInput\n\n输入包含多组数据，输入的第一行有两个数：N和M，接下来的M行每行有两个数a和b，表示了一条通道可以从A房间来到B房间。文件最后以两个0结束。\n\n\n\nOutput\n\n对于输入的每组数据，如果任意两个房间都是相互连接的，输出\"Yes\"，否则输出\"No\"。\n\n\n\nSample Input\n\n3 3 1 2 2 3 3 1 3 3 1 2 2 3 3 2 0 0\n\n\n\nSample Output\n\nYes No", "Tag": "算法分析"}
{"Answer": "#include<bits/stdc++.h>using namespace std;const int inf=0x3f3f3f3f;int n,m;int mp[50][50],book[50],dis[50],parent[50];void prim(){    for(int i=1;i<=n;i++)    {        dis[i]=mp[1][i];        if(mp[1][i]!=inf)            parent[i]=1;    }    int ans;    book[1]=1;    for(int i=1;i<n;i++)    {        int minn=inf,u;        for(int j=1;j<=n;j++)        {            if(!book[j]&&minn>dis[j])            {                u=j;                minn=dis[j];            }        }        book[u]=1;\n    int x=parent[u];\n    int y=u;\n    int z=mp[parent[u]][u];\n    if(x>y) \n        swap(x,y);\n    printf(\"%d,%d,%d\\n\",x,y,z);\n    \n    for(int v=1;v<=n;v++)\n    {\n        if(!book[v]&&dis[v]>mp[u][v])\n        {\n            dis[v]=mp[u][v];\n            parent[v]=u;\n        }    \n    }\n}\n\n}\nint main(){    memset(book,0,sizeof(book));    cin>>n>>m;    memset(mp,0x3f,sizeof(mp));    for(int i=1;i<=n;i++)        mp[i][i]=0;    for(int i=1;i<=m;i++)    {        int a,b,c;        cin>>a>>b>>c;        mp[a][b]=mp[b][a]=min(mp[a][b],c);    }    prim();}", "Konwledge_Point": "最小生成树", "Question": "R7-2 最小生成树构造 (25 分)\n giegie们！！\n\n\n输入样例：\n4 6\n1 2 1\n1 3 4\n1 4 1\n2 3 3\n2 4 2\n3 4 5", "Tag": "算法分析"}
{"Answer": "\ndef mctFromLeafValues( arr):\n    res = 0\n    while len(arr) > 1:\n        min_val = min(arr)\n        idx = arr.index(min_val)\n        if idx > 0 and idx < len(arr) - 1: #有左有右\n            left_val, right_val = arr[idx - 1], arr[idx + 1]\n        elif idx == len(arr) - 1: #有左没右\n            left_val, right_val = arr[idx - 1], 16 #为什么是16？因为最大只有15\n        elif idx == 0: #有右没左\n            left_val, right_val = 16, arr[idx + 1]\n            \n        res += min(min_val * left_val, min_val * right_val)\n        arr.remove(min_val) #把当前最小值删掉，已经用完了\n    return res\narr = [5,1,4]\nprint(mctFromLeafValues(arr))\n", "Konwledge_Point": "最小生成树", "Question": "用python语言实现“最小代价生成树”问题的分支限界算法\n求Python的各位帮忙看看，用python语言实现“最小代价生成树”问题的分支限界算法", "Tag": "算法分析"}
{"Answer": "打断点追一下这个t值，有可能t值还是-1。", "Konwledge_Point": "最小生成树", "Question": "这个缓冲区溢出和无效数据怎么解决啊\n大一求问，用prim算法求最小生成树，⚠️缓冲区溢出和无效数据，不知道怎么改", "Tag": "算法分析"}
{"Answer": "#include\"MST.h\"之前的部分保存为MST.h文件这行前面缺个花括号", "Konwledge_Point": "最小生成树", "Question": "我从别人那复制过来的但是找不到MST.h文件\n帮我看看这些代码为什么运行不了，我缺少的MST.h文件应该是什么内容才能让这些正常运行在vs2013里写的\n\n\n\n```c++\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\nclass\n \nMST\n{\n\npublic\n:\n    \nMST\n(){ pNumber = \n0\n; map = \nNULL\n; }  \n    ~\nMST\n(){ \ndelete\n []map; }\n    \nvoid\n \ncreatePoint\n()\n;        \n//对应通信网造价模拟系统的A选项创建电网顶点\n\n    \nvoid\n \naddEdge\n()\n;            \n//对应通信网造价模拟系统的B选项添加电网的边\n\n    \nvoid\n \ncreateTree\n()\n;           \n//对应通信网造价模拟系统的C选项构造最小生成树\n\n    \nvoid\n \ndisplayTree\n()\n;           \n//对应通信网造价模拟系统的D选项显示最小生成树\n\n    \nstring \nfindPoint\n(\nint\n iPos)\n;\n//寻找pName中iPos位置的节点名称\n\n    \nbool\n \njudgePoint\n(\nint\n iPos)\n; \n//判断iPos位置的点是否已经放入store容器中\n\n    \nint\n \njudgeEdge\n(\nint\n temp)\n;   \n//判断是否存在权值比temp数值还小的边\n\n\nprivate\n:\n    \nint\n pNumber;               \n//通信网节点的个数\n\n    \nint\n iCount = \n0\n;            \n//通信网节点个数计数器\n\n    \nint\n iStart;                \n//起始点位置对应pName中的位置\n\n    \nint\n iWeight;               \n//存在比temp数值更小的边的权\n\n    \nint\n **map;                 \n//用于存储各边之间的权\n\n    string start;              \n//起始点位置的名称\n\n    vector pName;      \n//存储所有节点的名称\n\n    vector>store;\n//store中的起点存储的每条边的终点和对应的权值\n\n\n\n#\ninclude\n\"MST.h\"\n\n\nusing\n \nnamespace\n std;\n\nbool\n \nMST::judgePoint\n(\nint\n iPos)\n{\n    \nfor\n (\nint\n iX=\n0\n ; iX < store.\nsize\n(); iX++){         \n        \nif\n (iPos == store[iX].first&&store[iX].second != \n0\n)\n            \nreturn\n \nfalse\n;               \n//store中存在这个点\n\n    }\n    \nreturn\n \ntrue\n;                        \n//store中不存在这个点\n\n}\n\nint\n \nMST::judgeEdge\n(\nint\n temp)\n{\n    \nint\n iPos;\n    \nif\n (iCount == \n1\n){                   \n//第二个顶点开始的位置单独讨论\n\n        \nfor\n (\nint\n iX = \n0\n; iX < pNumber; iX++){\n            \nif\n (map[iStart][iX] < temp&↦[iStart][iX]>\n0\n && map[iStart][iX] != store[\n0\n].second){\n                iWeight = map[iStart][iX];\n                \nreturn\n iX;\n            }\n        }\n    }\n    \nif\n(iCount>\n1\n){\n        \nint\n iPos = iCount\n-1\n;\n        \nfor\n (iPos;iPos>=\n0\n;iPos--)\n            \nfor\n (\nint\n iX = \n0\n; iX < pNumber;iX++)\n                \nif\n (map[iPos][iX] < temp&↦[iPos][iX] != store[iPos].second&↦[iPos][iX]>\n0\n && iX != iStart){\n                iWeight = map[iPos][iX];\n                \nreturn\n iX;                \n//之前的顶点对应有权更小的边\n\n            }\n        }\n    \nreturn\n \n-1\n;\n//没有权更小的边\n\n}\n\nvoid\n \nMST::createTree\n()\n{\n    cout << \n\"请输入起始顶点：\"\n;\n    cin >> start;\n    iCount = \n0\n;        \n//计数器每次操作前置0                     \n\n    \nint\n iPos,temp,iName;  \n//iPos对应每次搜索的起点 temp对应起点对应的边的权 iName对应搜索后的终点\n\n    store.\nclear\n();       \n//store每次操作前清空\n\n    store.\nresize\n(pNumber);\n    \nfor\n (iPos = \n0\n; iPos < pNumber; iPos++){  \n//首先找到起始点对应pName中的位置\n\n        \nif\n (start == pName[iPos]){\n            iStart = iPos;\n            \nbreak\n;\n        }\n    }\n    \nwhile\n (iCount=map[iPos][iX] && map[iPos][iX]>\n0\n && iPos != iX&&\njudgePoint\n(iX)){\n                \nif\n ((iCount != \n0\n && iPos != iStart||iCount==\n0\n&&iPos==iStart)&&iX!=iStart){\n                    temp = map[iPos][iX];\n                    iName = iX;\n                }\n            }\n        }\n        \nif\n (\njudgeEdge\n(temp) == \n-1\n){   \n//如果store之前的顶点不存在权比temp更小的边\n\n            store[iCount].second = temp;\n            store[iCount].first = iName;\n        }\n\n        \nif\n (\njudgeEdge\n(temp) != \n-1\n){    \n//如果存在权比temp更小的边\n\n            store[iCount].first = \njudgeEdge\n(temp);\n            store[iCount].second = iWeight;\n        }\n        iPos = store[iCount].first;\n        iCount++;\n    }\n    cout << \n\"生成Prim最小生成树！\"\n<> pNumber;\n    cout << \n\"请依次输入各顶点的名称：\"\n << endl;\n    \nfor\n (\nint\n iX = \n0\n; iX < pNumber; iX++){\n        cin >> name;\n        pName.\npush_back\n(name);\n    }\n    cout << endl;\n}\n\nvoid\n \nMST::addEdge\n()\n{\n    string pA, pB;\n    \nint\n iA = \n0\n, iB = \n0\n;\n    map = \nnew\n \nint\n*[pNumber];\n    \nfor\n (\nint\n iX = \n0\n; iX < pNumber; iX++)\n        map[iX] = \nnew\n \nint\n[pNumber];\n\n    \nfor\n (\nint\n iX = \n0\n; iX < pNumber - \n1\n; iX++){\n        map[iX][iX] = \n0\n;\n        cout << \n\"请输入两个顶点及边: \"\n;\n        \nfor\n (\nint\n iY = iX + \n1\n; iY < pNumber; iY++){ \n            iA = iB = \n0\n;\n            cin >> pA >> pB;\n            \nwhile\n (pA != pName[iA])   \n//搜索输入两个顶点对应的位置，并将权赋值到对应的map中\n\n                iA++;\n            \nwhile\n (pB != pName[iB])\n                iB++;\n            cin >> map[iA][iB];\n            \nif\n (iY != pNumber - \n1\n)\n                cout << \n\"请输入两个顶点及边: \"\n;\n        }\n    }\n    \nfor\n (\nint\n iX = \n0\n; iX < pNumber; iX++){\n        \nfor\n (\nint\n iY = \n0\n; iY < iX; iY++){\n            map[iX][iY] = map[iY][iX];\n        }\n    }\n    cout << endl;\n    \n}\n\nvoid\n \nMST::displayTree\n()\n{\n    string end;\n    string begin;\n    cout << \n\"最小生成树的的顶点及边为：\"\n << endl;\n    cout << endl;\n    cout << start << \n\"-<\"\n << store[\n0\n].second << \n\">-\"\n << \nfindPoint\n(store[\n0\n].first);\n    \nfor\n (\nint\n iX = \n1\n; iX < pNumber - \n1\n; iX++){\n        \nif\n (store[iX].second == map[store[iX].first][iX]){\n//如果最小生成树没有分支\n\n            begin = \nfindPoint\n(store[iX - \n1\n].first);\n            end = \nfindPoint\n(store[iX].first);\n            cout << \n\"        \"\n << begin << \n\"-<\"\n << store[iX].second << \n\">-\"\n << end;\n        }\n        \nelse\n{\n//最小生成树存在分支，依据终点和权找到对应的起点\n\n            \nint\n iStart = store[iX].second;\n            \nint\n iJ = \n0\n;\n            \nint\n iK = \n0\n;\n            \nbool\n flag = \nfalse\n;\n            \nfor\n (iJ = \n0\n; iJ < pNumber; iJ++){\n                \nfor\n (iK = \n0\n; iK < pNumber; iK++){\n                    \nif\n (map[iJ][iK] == iStart){\n                        flag = \ntrue\n;\n                        \nbreak\n;\n                    }\n                }\n                \nif\n (flag == \ntrue\n)\n                    \nbreak\n;\n            }\n            \nif\n (iK == store[iX].first){\n                begin = \nfindPoint\n(iJ);\n                end = \nfindPoint\n(iK);\n                cout << \n\"        \"\n << begin << \n\"-<\"\n << store[iX].second << \n\">-\"\n << end;\n            }\n            \nif\n (iJ == store[iX].first){\n                begin = \nfindPoint\n(iK);\n                end = \nfindPoint\n(iJ);\n                cout << \n\"        \"\n << begin << \n\"-<\"\n << store[iX].second << \n\">-\"\n << end;\n            }\n        }\n    }\n    cout << endl << endl;\n}\n\nstring \nMST::findPoint\n(\nint\n iPos)\n{\n    string point;\n    point = pName[iPos];\n    \nreturn\n point;\n}\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\"MST.h\"\n\n\nusing\n \nnamespace\n std;\n\nvoid\n \nmain\n()\n{\n    MST tree;\n    \nchar\n order;\n    cout << \n\"**                     通信网造价模拟系统                     **\"\n << endl;\n    cout << \n\"==============================================================\"\n << endl;\n    cout << \n\"**                     A---创建通信网顶点                     **\"\n << endl;\n    cout << \n\"**                     B---添加通信网的边                     **\"\n << endl;\n    cout << \n\"**                     C---构造最小生成树                   **\"\n << endl;\n    cout << \n\"**                     D---显示最小生成树                   **\"\n << endl;\n    cout << \n\"**                     E---退出   程序                      **\"\n << endl;\n    cout << \n\"==============================================================\"\n << endl<> order;\n    \nwhile\n (order!=\n'E'\n){\n        \nswitch\n (order)\n        {\n        \ncase\n \n'A'\n:\n            tree.\ncreatePoint\n();\n            \nbreak\n;\n        \ncase\n \n'B'\n:\n            tree.\naddEdge\n();\n            \nbreak\n;\n        \ncase\n \n'C'\n:\n            tree.\ncreateTree\n();\n            \nbreak\n;\n        \ncase\n \n'D'\n:\n            tree.\ndisplayTree\n();\n        \ndefault\n:\n            \nbreak\n;\n        }\n        cout << \n\"请选择操作：\"\n;\n        cin >> order;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n```", "Tag": "算法分析"}
{"Answer": "[http://www.cnblogs.com/hxsyl/p/3286956.html](http://www.cnblogs.com/hxsyl/p/3286956.html \"\")", "Konwledge_Point": "最小生成树", "Question": "如何在克鲁斯卡尔中加入并查集的运用\n在运用克鲁斯卡尔算法求最小生成树时如何将并查集的相关内容也运用进去？第一次发问，请大家给力点！", "Tag": "算法分析"}
{"Answer": "一个人搞确实有难度，建议和老师同学多交流，参加一些相关的比赛，积累经验", "Konwledge_Point": "最小生成树", "Question": "想问下做项目是啥意思\n目前学完了c，数据结构与算法学到了图的最小生成树，力扣也刷了五六十道题了，听说做项目提升快，但现在还没见过项目，也不知道咋找项目，有大佬能指导下吗😂", "Tag": "算法分析"}
{"Answer": "\n\n#include<bits/stdc++.h>\n#define NUM 6\nusing namespace std;\n\n//利用二维数组创建有向图的邻接矩阵\nvoid CreateMatrix(int mat[NUM][NUM]);\n//利用Prim算法求解最小生成树\nvoid DijkstraSearch(int mat[NUM][NUM], int i, int visit[NUM], int dist[NUM], int path[NUM]);\n\nint main()\n{\n    //创建有向图的带有权值的邻接矩阵\n    int mat[NUM][NUM];\n    for (int i = 0; i < NUM;i++)\n    {\n        for (int j = 0; j < NUM;j++)\n        {\n            mat[i][j] = INT_MAX;\n        }\n    }\n    CreateMatrix(mat);\n    int visit[NUM] = {0};\n    int dist[NUM];\n    for (int i = 0; i < NUM;i++)\n    {\n        dist[i] = INT_MAX;\n    }\n    int path[NUM] = {0};\n\n    //利用Prim算法求解最小生成树\n    //初始源点的dist初始化为0，path初始化为0\n    dist[0] = 0;\n    path[0] = 0;\n    DijkstraSearch(mat,0,visit,dist,path);\n\n    //输出最小生成树的边及相应权值，总权值\n    int totalValue = 0;\n    for (int i = 1; i < NUM;i++)\n    {\n        totalValue += dist[i];\n        printf(\"最小生成树的边：<v%d , v%d>\",(i+1),(path[i]+1));\n        printf(\" 权值：%d\",dist[i]);\n        printf(\"\\n\");\n    }\n    printf(\"最小生成树的总权值：%d\",totalValue);\n    printf(\"\\n\");\n\n    return 0;\n}\n\n\n//利用二维数组创建有向图的邻接矩阵，带权值\nvoid CreateMatrix(int mat[NUM][NUM])\n{\n    mat[0][1] = 4;\n    mat[0][2] = 2;\n\n    mat[1][0] = 4;\n    mat[1][2] = 5;\n    mat[1][3] = 5;\n    mat[1][4] = 9;\n\n    mat[2][0] = 2;\n    mat[2][1] = 5;\n    mat[2][3] = 6;\n\n    mat[3][1] = 5;\n    mat[3][2] = 6;\n    mat[3][4] = 7;\n    mat[3][5] = 6;\n\n    mat[4][1] = 9;\n    mat[4][3] = 7;\n    mat[4][5] = 3;\n\n    mat[5][3] = 6;\n    mat[5][4] = 3;\n}\n\n//利用Prim算法求解最小生成树\nvoid DijkstraSearch(int mat[NUM][NUM], int i, int visit[NUM], int dist[NUM], int path[NUM])\n{\n    //初始化\n    visit[i] = 1;\n    //dist[i] = 0;\n    //path[i]=0;\n\n    //访问与顶点i相邻接的未被访问的顶点，获取路径长度，如果小于之前路径长度则替换，并记录路径\n    for (int j = 0; j < NUM;j++)\n    {\n        if (visit[j] == 0 && mat[i][j] != INT_MAX)\n        {\n            if (mat[i][j]<dist[j])\n            {\n                dist[j] = mat[i][j];\n                path[j] = i;\n            }\n        }\n    }\n\n    //在未被访问过的顶点中寻找路径最短的顶点\n    int minDist = -1;\n    for (int m = 0;m<NUM;m++)\n    {\n        if (visit[m] == 0)\n        {\n            minDist = m;\n            break;\n        }\n    }\n    for (int k = minDist + 1; k<NUM; k++)\n    {\n        if (visit[k] == 0 && dist[k]<dist[minDist])\n        {\n            minDist = k;\n        }\n\n    }\n    //如果找到继续寻找到下一个顶点的最短路径（递归）\n    if (minDist != -1)\n    {\n        DijkstraSearch(mat, minDist, visit, dist, path);\n    }\n}\n\n", "Konwledge_Point": "最小生成树", "Question": "求下面问题的完整答案，图在链接里\n已知顶点集合{a,b,c,d,e,f}，构成的无向图的带权邻接矩阵如下：\nhttps://cg.sau.edu.cn/userfiles/image/1483599133822034852.png\n① 画出无向带权图；   \n② 给出无向带权图的最小生成树；", "Tag": "算法分析"}
{"Answer": "你的toString方法里递归调用了,死循环出不来了...\r\n这是AbstractMap的toString方法:\r\n\r\npublic String toString() {\r\n\tIterator> i = entrySet().iterator();\r\n\tif (! i.hasNext())\r\n\t    return \"{}\";\r\n\r\n\tStringBuilder sb = new StringBuilder();\r\n\tsb.append('{');\r\n\tfor (;;) {\r\n\t    Entry e = i.next();\r\n\t    K key = e.getKey();\r\n\t    V value = e.getValue();\r\n\t    sb.append(key   == this ? \"(this Map)\" : key);\r\n\t    sb.append('=');\r\n\t    sb.append(value == this ? \"(this Map)\" : value);\r\n\t    if (! i.hasNext())\r\n\t\treturn sb.append('}').toString();\r\n\t    sb.append(\", \");\r\n\t}\r\n    }\r\n\r\n由于你的Map里Key还是City对象,所以执行Map的toString时这一行 sb.append(key   == this ? \"(this Map)\" : key);会自动调用key的toString方法,这样又进入了City的toString方法,然后就挂了.....", "Konwledge_Point": "最小生成树", "Question": "StackOverflowError异常，哪位好心人看看啊\n   打算用面向对象思想，写个求最小生成树问题。写了一半，就出现问题了import java.util.HashMap;\n\n\n\npublic class City {\n    private String cityName; \n\n    private HashMap adjCities = new HashMap(); \n\n    public City(String cityName) {\n        this.cityName = cityName;\n\n    }\n\n    public void addAjdCity(City city, double cost) {\n        adjCities.put(city, cost);\n        // System.out.println(\"test1\");\n        city.adjCities.put(this, cost);\n        // System.out.println(\"test2\");\n\n    }\n\n    public void removeAjdCity(City city) {\n\n    }\n\n    public void removeAjdCity(String cityName) {\n\n    }\n\n    public String toString() {\n        return cityName + \":\" + \"\\n\" + adjCities;\n    }\n\n    public static void main(String[] args) {\n        City c1 = new City(\"上海\");\n        City c2 = new City(\"杭州\");\n\n        c1.addAjdCity(c2, 100);\n        // 怎么输出c1 c2时会出问题？StackOverflowError异常。如果把最后两句println注释掉，就不会报错？？\n        System.out.println(c1);\n        System.out.println(c2);\n\n    }\n\n}\n", "Tag": "算法分析"}
{"Answer": "就是将下标为k的顶点各边权值小于此前这些顶点未被加入的生成树权值", "Konwledge_Point": "最小生成树", "Question": "小白求教，请问**部分是什么意思？\n//Prim算法最小生成树\n\nvoid MiniSpanTree_Prime(Graph g)\n\n{\n\n    int min, i, j, k;\n\n    int adjvex[MAXVEX];         //保存相关顶点下标\n\n    int lowcost[MAXVEX];        //保存相关顶点间边的权值\n\n    lowcost[0] = 0;             //初始化第一个权值为0，即v0加入生成树  \n\n\n\nadjvex[0] = 0;              //初始化第一个顶点下标为0  \nfor(i = 1; i < g.numVertexes; i++)  \n{  \n    //循环除下标为0外的全部顶点  \n    lowcost[i] = g.arc[0][i];   //将v0顶点与之有边的权值存入数组  \n    adjvex[i] = 0;              //初始化都为v0下标  \n}  \nfor(i = 1; i < g.numVertexes; i++)  \n{  \n    min = INFINITY;             //初始化最小权值为无穷大  \n    j = 1;  \n    k = 0;  \n    while(j < g.numVertexes) //循环全部顶点  \n    {  \n        //如果权值不为0,且权值小于min  \n        if(lowcost[j] != 0 && lowcost[j] < min)  \n        {  \n            min = lowcost[j];       //则让当前权值成为最小值  \n            k = j;                  //将当前最小值的下标存入k  \n        }  \n        j++;  \n    }  \n    printf(\"(%d,%d)\", adjvex[k], k);//打印当前顶点边中权值最小边  \n    lowcost[k] = 0;                 //将当前顶点的权值设置为0，表示此顶点已经完成任务  \n\n    for(j = 1; j < g.numVertexes; j++)//循环所有顶点  \n    {  \n        if(lowcost[j] != 0 && g.arc[k][j] < lowcost[j])  \n        {  \n          **  //若下标为k的顶点各边权值小于此前这些顶点未被加入的生成树权值 ** \n            lowcost[j] = g.arc[k][j];  \n            adjvex[j] = k;         //将下标为k的顶点存入adjvex  \n        }  \n    }  \n}  \nprintf(\"\\n\");  \n\n\n\n\n}", "Tag": "算法分析"}
{"Answer": "错误在这行：\r\n```\r\nMiniSpanTree_Prim(AdjMatrix &gn,char u)/*从顶点u出发，按普里姆算法构造连通网gn的最小生成树，并输出生成树的每条边*/\r\n{int i,e;\r\n.....\r\n```\r\n\r\n\r\n\r\n\r\nMiniSpanTree_Prim函数定义时，应明确返回值类型。\r\n假设该函数无返回值，也应该定义成:\r\n\r\n\r\n\r\n```\r\nvoid MiniSpanTree_Prim(AdjMatrix &gn,char u){\r\n......\r\n}\r\n```\r\n\r\n**用心回答每个问题，如果对您有帮助，请采纳答案好吗，谢谢！**", "Konwledge_Point": "最小生成树", "Question": "数据结构关于图的小错误\n#include\n\n#include\n\n#define Infinity 32768\n\n#define OK 1\n\n#define Error -1\n\n#define True 1\n\n#define False 0\n\n#define MAX_VERTEX_NUM 10\n\ntypedef enum{DG,DN,UDG,UDN}GraphKind;      /*图的种类分别为有向图，有向网，无向图，无向网*/\n\ntypedef char VertexData;\n\ntypedef struct ArcNode\n\n{int adj;\n\n\n\n}ArcNode;\n\ntypedef struct \n\n{VertexData vertex[MAX_VERTEX_NUM];\n\n ArcNode arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM];\n\n int vexnum,arcnum;                       /*图的顶点数和弧数*/\n\n GraphKind kind;\n\n}AdjMatrix;\n\nstruct Record{\n\n     char  adjvex;  // U集中的顶点\n\n     int   lowcost;  // 边的权值\n\n}closedge[MAX_VERTEX_NUM];\n\nint LocateVertex(AdjMatrix \nG,VertexData v)/\n求顶点位置函数*/\n\n{int j=Error,k;\n\n for(k=0;kvexnum;k++)\n\n  if(G->vertex[k]==v)\n\n   {j=k;break;\n\n   }\n\n   return(j);\n\n}\n\nint CreateDN(AdjMatrix \nG)             /\n创建一个有向网*/\n\n{int i,j,k,weight;VertexData v1,v2;\n\n printf(\"请输入两个数字表示弧数和顶点数\\n\");\n\n fflush(stdin);                         /*清空输入缓冲区*/ \n\n scanf(\"%d,%d\",&G->arcnum,&G->vexnum);\n\n for(i=0;ivexnum;i++)               /*初始化邻接矩阵*/\n\n  for(j=0;jvexnum;j++)\n\n   G->arcs[i][j].adj=Infinity;\n\n for(i=0;ivexnum;i++)\n\n  printf(\"请输入图的顶点\\n\");\n\n  fflush(stdin);\n\n  scanf(\"%c\",&G->vertex[i]);\n\n for(k=0;karcnum;k++)\n\n {printf(\"请输入一条弧的两个顶点及权值\\n\");\n\n  fflush(stdin);\n\n  scanf(\"%c,%c,%d\",&v1,&v2,&weight);\n\n  i=LocateVertex(G,v1);\n\n  j=LocateVertex(G,v2);\n\n  G->arcs[i][j].adj=weight;              /*建立弧*/\n\n }\n\n return(OK);\n\n}\n\nint Minimum (Record closedge[])\n\n{int reserve=Infinity;\n\n int min;\n\n for(int i=1;i\n {\n\n   if(closedge[i].lowcost0)//没有访问过但是存路径\n\n    {\n\n      reserve=closedge[i].lowcost;\n\n      min=i;\n\n    }\n\n   }\n\n return min;\n\n}\n\nMiniSpanTree_Prim(AdjMatrix &gn,char u)/*从顶点u出发，按普里姆算法构造连通网gn的最小生成树，并输出生成树的每条边*/\n\n{int i,e;\n\n closedge[u].lowcost=0;              /*初始化，U={u}*/\n\n for(i=0;i<gn.vexnum;i++)\n\n      if(i!=u)                        /*对V-U中的顶点i，初始化closedge[i]*/\n\n      {closedge[i].adjvex=u;\n\n       closedge[i].lowcost=gn.arcs[u][i].adj;\n\n      }\n\n for(e=1;e<=gn.vexnum-1;e++)          /*找n-1条边（n=gn.vexnum*/\n\n {int v=Minimum(closedge);            /*closedge[v]中存有当前最小边（u，v）的信息*/\n\n  u=closedge[v].adjvex;               /*u属于U*/\n\n  printf(\"%c,%c\",u,v);                /*输出生成树的当前最小边（u，v）*/\n\n  closedge[v].lowcost=0;              /*将顶点v纳入U的集合*/\n\n  for(i=0;i<gn.vexnum;i++)            /*在顶点v并入U之后，更新closedge[i]*/\n\n      if(gn.arcs[v][i].adj<closedge[i].lowcost)\n\n      {closedge[i].lowcost=gn.arcs[v][i].adj;\n\n       closedge[i].adjvex=v;\n\n      }\n\n }\n\n}\n\nint main()\n\n{AdjMatrix G;\n\n CreateDN(&G);\n\n char first=' ';\n\n printf(\"请输入第一个访问的结点\\n\");\n\n scanf(\"%c\",&first);\n\n MiniSpanTree_Prim(G,first) ;\n\n return 0;\n\n}\n\n出现这个错误\\Users\\Administrator\\Desktop\\3.2.cpp 69 C:\\Users\\Administrator\\Desktop\\C [Error] ISO C++ forbids declaration of `MiniSpanTree_Prim' with no type ", "Tag": "算法分析"}
{"Answer": "def mctFromLeafValues( arr):\n    res = 0\n    while len(arr) > 1:\n        min_val = min(arr)\n        idx = arr.index(min_val)\n        if idx > 0 and idx < len(arr) - 1: #有左有右\n            left_val, right_val = arr[idx - 1], arr[idx + 1]\n        elif idx == len(arr) - 1: #有左没右\n            left_val, right_val = arr[idx - 1], 16 #为什么是16？因为最大只有15\n        elif idx == 0: #有右没左\n            left_val, right_val = 16, arr[idx + 1]\n            \n        res += min(min_val * left_val, min_val * right_val)\n        arr.remove(min_val) #把当前最小值删掉，已经用完了\n    return res\narr = [5,1,4]\nprint(mctFromLeafValues(arr))\n", "Konwledge_Point": "最小生成树", "Question": "python分支限界算法\n用python语言实现最小代价生成树问题，利用分支限界算法python", "Tag": "算法分析"}
{"Answer": "      def mctFromLeafValues(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        res = 0\n        while len(arr) > 1:\n            min_val = min(arr)\n            idx = arr.index(min_val)\n            if idx > 0 and idx < len(arr) - 1: #有左有右\n                left_val, right_val = arr[idx - 1], arr[idx + 1]\n            elif idx == len(arr) - 1: #有左没右\n                left_val, right_val = arr[idx - 1], 16 #为什么是16？因为最大只有15\n            elif idx == 0: #有右没左\n                left_val, right_val = 16, arr[idx + 1]\n                \n            res += min(min_val * left_val, min_val * right_val)\n            arr.remove(min_val) #把当前最小值删掉，已经用完了\n        return res\n", "Konwledge_Point": "最小生成树", "Question": "python初学者，问一个简单的分支限界算法\n用python语言实现“最小代价生成树”问题的分支限界算法\n求解答……", "Tag": "算法分析"}
{"Answer": "网上很多原题解析：\n哈夫曼树 - 九度教程第30题_Yoc Lu的博客-CSDN博客\n哈夫曼树 - 九度教程第30题题目时间限制：1 秒 内存限制：32 兆 特殊判题：否题目描述：哈夫曼树，第一行输入一个数n，表示叶结点的个数。需要用这些叶结点生成哈夫曼树，根据哈夫曼树的概念，这些结点有权值，即weight，题目需要输出所有结点的值与权值的乘积之和。输入：输入有多组数据。每组第一行输入一个数n，接着输入n个叶节点（叶节点权值不超过100，2&amp;lt;=n&amp;lt;=10...\n\n\n\nhttps://blog.csdn.net/LYKXHTP/article/details/88316879\n\n", "Konwledge_Point": "最小生成树", "Question": "构造哈夫曼树以及计算带权路径长度\n7-1 哈夫曼树\n分数 15\n作者 李廷元\n单位 中国民用航空飞行学院\n哈夫曼树，第一行输入一个数n，表示叶结点的个数。\n\n\n需要用这些叶结点生成哈夫曼树，根据哈夫曼树的概念，这些结点有权值，即weight，题目需要输出哈夫曼树的带权路径长度（WPL）。\n\n\n输入格式:\n第一行输入一个数n，第二行输入n个叶结点（叶结点权值不超过1000，2<=n<=1000）。\n\n\n输出格式:\n在一行中输出WPL值。\n\n\n输入样例:\n5\n1 2 2 5 9\n输出样例:\n37\n\n\n我的问题：\n我们老师上课讲解过如何构造哈夫曼树这是方法：\n结点结构如下。\n\n\ndefine MAXBIT 10\ndefine MAXVALUE 1000\ntypedef struct HNode /定义结点结构/\n{ int weight;\nint parent , lchild , rchild;\n}HNode, *HTree;\n\n\nHTree HuffmanTree( int w , int n) /给定n个权值构造哈夫曼树/\n{ / w存储n个字符的权值，构造哈夫曼树HT*/\nint m, m1, m2, x1, x2, i, j; HTree ht;\nHNode *p;\nif (n <= 1) return NULL;\nm= 2*n-1;\nht = (HNode *)malloc (m*sizeof(HNode) ); /*哈夫曼树的构造*/\nif(ht==NULL) return ht;\nfor(p = ht, i =0; i < n; ++ i, ++ p, ++w) /*初始化叶子结点信息*/\n{ p->weight = *w; p->lchild = -1;\np->rchild = -1; p->parent = -1;\n}\nfor( ; i < m; ++ i, ++ p) /*初始化分支结点信息*/\n{ p->weight = 0; p->lchild = -1;\np->rchild = -1; p->parent = -1;\n}\nfor( i = n; i < m; ++ i) /*构造哈夫曼树 */\n{ m1 = m2 = MAXVALUE;\nx1 = x2 = 0; /寻找parent为-1且权值最小的两棵子树/\nfor(j = 0; j < i; ++ j)\n{ if( ht[j].parent == -1 && ht[j].weight < m1)\n{ m2 = m1; x2 = x1; m1 = ht[j].weight; x1 = j; }\nelse if( ht[j].parent == -1 && ht[j].weight < m2)\n{ m2 = ht[j].weight; x2 = j; }\n}\n/合并成一棵新的子树/\nht[x1].parent = i; ht[x2].parent = i;\nht[i].lchild = x1; ht[i].rchild = x2;\nht[i].weight = m1 + m2;\n}\nreturn ht;\n}\n说实话看的有的云里雾里的能不能用中文描述下思路\n而且题中要让求最短路径长度，我这上面只有构造哈夫曼树这一块，求解最短路径长度这块有点不知道如何下手，还有主函数也不太知道咋写，希望能同时提供解题思路以及完整运行结果，感谢感谢，因为基础太差了，我就算知道思路自己也打不出来，答案错误看半天也找不出错误，辛苦", "Tag": "算法分析"}
{"Answer": "在动态创建的过程中，总是出现未利用的空间出现乱码。通过专门建立一个变量来统计用到的数组长度，可以解决了这个问题。", "Konwledge_Point": "最小生成树", "Question": "哈夫曼树构造过程中出现乱码？\n程序是根据用户输入的一些列字符及其对应的权值，生成哈夫曼树，再根据生成的哈夫曼树进行编码，在测试时，发现输出每个元素对应的哈夫曼编码时，总会出现一些乱码的文字，知道原因的网友点拨一些，谢谢。程序如下：\n\n\n\n #include \n#include\nusing namespace std;\nclass HuffNode\n{\npublic:\n    char c;  // 结点的字符\n    int weight;  // 权值\n    int parent, lChild, rChild; // 左右孩子指针\n};\nclass HuffTree\n{\nprivate:\n    int Node_cnt=0;\n    HuffNode* huff=NULL;\n    string* HuffCode = NULL;\npublic:\n    HuffTree(int n, char* c, int* weights);  // 创建Huffman树\n    ~HuffTree();        // 析构函数\n     void setNode_cnt(int cnt){ Node_cnt = cnt; }\n     void select(int end, int& index1, int& index2); // 选出最小和次小叶子结点\n     void printHuffTree();\n     void setHuffCode();\n     void printHuffCode();\n\n};\nHuffTree::~HuffTree()\n{\n    delete[] huff;\n    delete[] HuffCode;\n}\nvoid HuffTree::printHuffCode()\n{\n    for (int i = 0; i < Node_cnt; i++)\n    {\n        cout << huff[i].c << \"的哈夫曼编码为：\" << HuffCode[i] << endl;\n    }\n}\nvoid HuffTree::setHuffCode()  // 左孩子为0，右孩子为1\n{\n    HuffCode = new string[Node_cnt];\n    for (int i = 0; i < Node_cnt; i++)\n    {\n        int son, father; // 孩子指针和双亲指针\n        int cnt = 0;\n        string str;\n        son = i;\n        father = huff[son].parent;\n        while (father != -1)\n        {\n            if (huff[father].lChild == son)\n            {\n                str.append(\"0\");\n            }\n            else\n            {\n                str.append(\"1\");\n            }\n\n            son = father;  // 孩子指针为当前双亲指针\n            father = huff[father].parent;  // 双亲指针为当前双亲指针的双亲\n        }\n        HuffCode[i] = new char[str.size()];\n        for (unsigned int j = 0; j < str.size(); j++)  // 由于求哈夫曼编码时是从叶子结点一直找到树根，故编码为之前的逆序\n        {\n            HuffCode[i][j] = str[str.size() - 1-j];// 逆序\n        }\n    }\n}\nHuffTree::HuffTree(int n,char* ch,int* weights){\n    Node_cnt = n;\n    huff = new HuffNode[2 * Node_cnt - 1];\n    for (int i = 0; i < Node_cnt; i++) // 初始化\n    {\n        huff[i].c = ch[i];\n        huff[i].weight = weights[i];\n        huff[i].lChild = -1;\n        huff[i].rChild = -1;\n        huff[i].parent = -1;\n    }\n    for (int i = Node_cnt; i < Node_cnt * 2 - 1; i++)\n    {\n        int index1 = -1, index2 = -1;\n        select(i - 1, index1, index2);// 选出最小和次小中间树结点索引\n        huff[index1].parent = i;\n        huff[index2].parent = i;\n        huff[i].weight = huff[index1].weight + huff[index2].weight;\n        huff[i].lChild = index1;\n        huff[i].rChild = index2;\n        huff[i].parent = -1;\n    }\n}\n\nvoid HuffTree::printHuffTree()\n{\n    cout << \"所建哈夫曼静态链表示如下：\" << endl;\n    cout << \"位置\\t\" << \"字符\\t\" << \"权值\\t\" << \"双亲\\t\" << \"左孩子\\t\" << \"右孩子\\t\" << endl;\n    for (int i = 0; i < Node_cnt*2-1; i++)\n    {\n        cout << i << \"\\t\" << huff[i].c << \"\\t\" << huff[i].weight << \"\\t\" << huff[i].parent << \"\\t\" << huff[i].lChild << \"\\t\" << huff[i].rChild << endl;\n    }\n}\nvoid  HuffTree::select(int end, int& index1, int& index2)\n    {\n        int min1=100000,min2 = 100000;  // 设m1为最小值，m2为次小值\n        for (int j = 0; j <=end; j++)\n        {\n            if (huff[j].parent == -1)\n            {\n                if (huff[j].weight < min1)  // 如果当前权值比最小值小\n                {\n                    index2 = index1;\n                    index1 = j;\n                    min2 = min1;\n                    min1 = huff[j].weight;\n                }\n                else if (huff[j].weight < min2)  // 如果当前权值比次小值小\n                {\n                    min2 = huff[j].weight;\n                    index2 = j;\n                }\n            }\n        }\n    }\n\nint main()\n{\n\n    int n;\n    cout << \"请输入树叶结点的个数(小于等于1结束)：\" << endl;\n    cin >> n;\n    if (n < 1) return 0;\n    char chs[256];\n    int weights[256];\n\n    for (int i = 0; i < n; i++){\n        cout << \"请输入第\" << i+1 << \"个字符及权值\" << endl;\n        cin >> chs[i] >> weights[i];\n    }\n    HuffTree tree(n,chs,weights);\n    tree.printHuffTree();\n    tree.setHuffCode();\n    tree.printHuffCode();\n\n    return 0;\n}\n", "Tag": "算法分析"}
{"Answer": "Problem1：https://paste.ubuntu.com/p/p5vmGWqFYh/\r\nProblem2：https://paste.ubuntu.com/p/kSSnfGDpMy/", "Konwledge_Point": "最小生成树", "Question": "麻烦用c语言解决一下。。\nA、编写一个读取1000个随机数整数的c程序，创建一个二叉树并打印树的深度。\n\n使用shuf-i1-1000命令生成随机数。（自己生成也行）\n\n B、编写一个c程序，重复上一个问题的实验1000次（每次一千个随机数都不同）。计算所创建的1000个二叉树的平均深度，最小深度和最大深度。不要忘记在实验之间释放树。使用shuf-i1-1000000生成一个1000x1000=1000000个整数的列表。", "Tag": "算法分析"}
{"Answer": "#include<stdio.h>\n#include<stdlib.h>\n#define max 100\nconst int m=100;\nint n,i,top=0,first=0,last=0,first1=0,last1=0;\nint s[m],z[m];\ntypedef struct snodelinked{undefined\nint data;\nchar bianma;\nint parent;\nstruct snodelinked *Rson,*Lson,*next;\n}snodelinked,*ptr;\nptr hfcreat(ptr head);\n//void bianma(ptr root);\nvoid preorder(ptr root);\nvoid push(int s[],int &top,int x);\nvoid pop(int s[],int &top);\nvoid addq(int s[],int first,int &last,char x);\nint delq(int s[],int &first,int last);\nptr hfinition();\nvoid translate(ptr root);\nint main(){undefined\nptr head,root;\nhead=hfinition();\nroot=hfcreat(head);\npreorder(root);\n// putchar(’\\n’);\ngetchar();\ntranslate(root);\nreturn 0;\n}\nptr hfinition(){undefined\nptr head,p;\nscanf(\"%d\",&n);\nhead=p=(ptr)malloc(sizeof(snodelinked));\nhead->data=max;\nhead->bianma=’ ‘;\ngetchar();\nfor(i=0;i<n;i++){undefined\np->next=(ptr)malloc(sizeof(snodelinked));\np=p->next;\nscanf(\"%c%1d\",&p->bianma,&p->data);\np->Lson=p->Rson=NULL;\np->parent=0;\n}\np->next=head;\nreturn head;\n}\nptr hfcreat(ptr head){undefined\nptr t1,t2,p,q,r;\nfor(i=0;i<n-1;i++){undefined\nr=(ptr)malloc(sizeof(snodelinked));\nt1=head->next;\nt2=t1->next;\nr->data=t1->data+t2->data;\nr->Lson=t1;\nr->Rson=t2;\nr->bianma=’ ‘;\nt1->parent=0;\nt2->parent=1;\nhead->next=t2->next;\np=head;\nq=p->next;\nwhile(1){undefined\nif(r->data>=q->data){undefined\np=p->next;\nq=p->next;\n}else{undefined\nr->next=q;\np->next=r;\nbreak;\n}\n}\n}\np=head->next;\nfree(head);\nreturn p;\n}\nvoid preorder(ptr root){undefined\nif(root->bianma!=’ ‘){undefined\nputchar(root->bianma);\nprintf( “:”);\nfor(i=1;i<=top;i++){undefined\nprintf(\"%d\",s[i]);\n}\nputchar(’\\n’);\n}\nif(root->Lson!=NULL) {undefined\npush(s,top,root->Lson->parent);\npreorder(root->Lson);\ntop–;\n}\nif(root->Rson!=NULL) {undefined\npush(s,top,root->Rson->parent);\npreorder(root->Rson);\ntop–;\n}\n}\nvoid push(int s[],int &top,int x){undefined\ns[++top]=x;\n}\nvoid pop(int s[],int &top){undefined\nprintf(\"%d\",s[top–]);\n}\nvoid translate(ptr root){undefined\nptr h;\nh=root;\nint y;\nchar x;\nx=getchar();\nprintf(“original:”);\nwhile(x!=’\\n’){undefined\naddq(z,first1,last1,x);\nx=getchar();\n}\nwhile(first1!=last1){undefined\ny=delq(z,first1,last1);\nif(y== 0) {undefined\nh = h->Lson;\n}\nelse if(y== 1) h=h->Rson;\nif(h->bianma!=’ '){undefined\nputchar(h->bianma);\nh=root;\n}\n}\n}\nvoid addq(int z[],int first,int &last,char x){undefined\nif(x==‘0’) z[last]=0;\nelse if(x==‘1’) z[last]=1;\nlast=(last+1)%m;\n}\nint delq(int z[],int &first,int last){undefined\nreturn z[first++];\n}\n\n", "Konwledge_Point": "最小生成树", "Question": "程序设计：编写一个哈夫曼编码译码程序。\n按词频从小到大的顺序给出各个字符（不超过30个）的词频，根据词频构造哈夫曼树，给出每个字符的哈夫曼编码，并对给出的语句进行译码。\n为确保构建的哈夫曼树唯一，本题做如下限定：\n（1）选择根结点权值最小的两棵二叉树时，选取权值较小者作为左子树。\n（2）若多棵二叉树根结点权值相等，按先后次序分左右，先出现的作为左子树，后出现的作为右子树。\n生成哈夫曼编码时，哈夫曼树左分支标记为0，右分支标记为1。\n【输入格式】\n第一行输入字符个数n；\n第二行到第n行输入相应的字符及其词频(可以是整数，与可以是小数）；\n最后一行输入需进行译码的串。\n【输出格式】\n首先按树的先序顺序输出所有字符的编码，每个编码占一行；\n最后一行输出需译码的原文，加上original:字样。\n输出中均无空格\n【样例输入】\n3\nm1\nn1\nc2\n10110\n【样例输出】\nc:0\nm:10\nn:11\noriginal:mnc", "Tag": "算法分析"}
{"Answer": "仅供参考：\n#include <iostream>\n#include <string>\nusing namespace std;\nstruct huffTree {\n    int parent;\n    int lchild;\n    int rchild;\n    int weight;\n    string flag;\n};\nstruct Lowest_node {\n    char ch;\n    int ch_num;\n};\nvoid coding(int length,huffTree *tree,int n,int &a,int &b) {\n    int i;\n    int r,s;\n\n    r=s=length;\n    for (i=0;i<n;i++) {\n        if (tree[i].weight<r\n         && tree[i].parent==-1) {\n            r=tree[i].weight;\n            a=i;\n        }\n    }\n    for (i=0;i<n;i++) {\n        if (tree[i].weight<s\n         && i!=a\n         && tree[i].parent==-1) {\n            s=tree[i].weight;\n            b=i;\n        }\n    }\n}\nvoid frequency(string str) {\n    int i,j;\n    int length=str.length();\n    Lowest_node *node=new Lowest_node[length];\n\n    for (i=0;i<length;i++) node[i].ch_num=0;\n\n    int char_type_num=0;\n    for (i=0;i<length;i++) {\n        for (j=0;j<char_type_num;j++)\n            if (str[i]==node[j].ch\n            || ('a'<=node[j].ch && node[j].ch<='z'\n                && str[i]+32==node[j].ch))\n                break;//\n        if (j<char_type_num) node[j].ch_num++;\n        else {\n            if ('A'<=str[i] && str[i] <= 'Z') node[j].ch=str[i]+32;\n            else node[j].ch=str[i];\n            node[j].ch_num++;\n            char_type_num++;\n        }\n    }\n    for (i=0;i<char_type_num;i++) {\n        for (j=i;j<char_type_num;j++) {\n            if (node[j].ch_num<node[j+1].ch_num) {\n                int temp;\n                char ch_temp;\n                temp=node[j].ch_num;\n                ch_temp=node[j].ch;\n                node[j].ch_num=node[j+1].ch_num;\n                node[j].ch=node[j+1].ch;\n                node[j+1].ch_num=temp;\n                node[j+1].ch=ch_temp;\n            }\n        }\n    }\n    for (i=0;i<char_type_num;i++)\n        cout<<\"字符\"<<node[i].ch<<\"出现了\"<<node[i].ch_num<<\"次\"<<endl;\n    huffTree *huff=new huffTree[2*char_type_num-1];\n    huffTree temp;\n    string *code=new string[2*char_type_num-1];\n\n    for (i=0;i<2*char_type_num-1;i++) {\n        huff[i].lchild=-1;\n        huff[i].parent=-1;\n        huff[i].rchild=-1;\n        huff[i].flag=-1;\n    }\n    for (j=0;j<char_type_num;j++) huff[j].weight=node[j].ch_num;\n    int min1,min2;\n    for (int k=char_type_num;k<2*char_type_num-1;k++) {\n        coding(length,huff,k,min1,min2);\n        huff[min1].parent=k;\n        huff[min2].parent=k;\n        huff[min1].flag=\"0\";\n        huff[min2].flag=\"1\";\n        huff[k].lchild=min1;\n        huff[k].rchild=min2;\n        huff[k].weight=huff[min1].weight+huff[min2].weight;\n    }\n    for (i=0;i<char_type_num;i++) {\n        temp=huff[i];\n        while (1) {\n            code[i]=temp.flag+code[i];\n            temp=huff[temp.parent];\n            if (temp.parent==-1) break;//\n        }\n    }\n    cout<<\"字符串的每个字符huffman编码为：\"<<endl;\n    for (i=0;i<char_type_num;i++) cout<<node[i].ch<<\"  \"<<code[i]<<endl;\n    cout<<\"整个字符串的huffman编码为：\"<<endl;\n    for (i=0;i<length;i++) {                                                                                     //S?\n        for (j=0;j<char_type_num;j++) {\n            if (str[i]==node[j].ch)\n                cout<<code[j];\n        }\n    }\n    delete[] node;\n    node=NULL;\n    delete[] huff;\n    huff=NULL;\n    delete[] code;\n    code=NULL;\n}\nint main() {\n    int length=0;\n    string str;\n    cout<<\"请输入一个字符串：\";\n    cin>>str;\n    frequency(str);\n    return 0;\n}\n//请输入一个字符串：2333abcde\n//字符3出现了3次\n//字符2出现了1次\n//字符a出现了1次\n//字符b出现了1次\n//字符c出现了1次\n//字符d出现了1次\n//字符e出现了1次\n//字符串的每个字符huffman编码为：\n//3  11\n//2  000\n//a  001\n//b  010\n//c  011\n//d  100\n//e  101\n//整个字符串的huffman编码为：\n//000111111001010011100101\n\n\n", "Konwledge_Point": "最小生成树", "Question": "哈夫曼算法的编码译码系统\n实现一个哈夫曼编码系统，系统包括以下功能：\n\n\n字符信息统计：读取待编码的源文件SourceFile.txt，统计出现的字符及其频率。\n建立哈夫曼树：根据统计结果建立哈夫曼树。\n建立哈夫曼码表：利用得到的哈夫曼树，将各字符对应的编码表保存在文件Code.txt中。\n对源文件进行编码：根据哈夫曼码表，将SourceFile.txt中的字符转换成相应的编码文件ResultFile.txt。\n\n\n#define _CRT_SECURE_NO_WARNINGS 1\n#include \n#include \n#include \n#define MAXVALUE 32767        //极大值相当于无穷大\n#define NODENUM 10            //叶子结点数\ntypedef struct\n{\n    char data;                //数据域\n    int weight;                //结点的权值\n    int parent, lch, rch;    //下标\n}htNode,*huffmanTree;        \n\n\ntypedef char** huffmanCode;    //第一个\n是代表它是指针变量，说明它是数组\n                            //第二个\n说明它是指针数组，代表这个char类型数组里每个元素都是*huffmanCode变量\n\n\nint initHuffmanTree(huffmanTree& HT);                                //初始化哈夫曼树\nvoid creatHuffmanTree(huffmanTree& HT, int n);                        //构建哈夫曼树\nvoid createHuffmanCode(huffmanTree HT, huffmanCode &HC, int n);        //编写哈夫曼编码\nint main()\n{\n    huffmanTree HT ;\n    initHuffmanTree(HT);\n    huffmanCode HC;\n    creatHuffmanTree(HT,NODENUM);\n    createHuffmanCode(HT,HC,NODENUM);\n    /\nfor (int i = NODENUM + 1; i <= 2 * NODENUM - 1; i++)\n        printf(\"%d \", HT[i].weight);\n/\n    for (int i = 1; i <= NODENUM; i++)                                //遍历输出编码\n    {\n        printf(\"%c:\\t\",HT[i].data);\n        printf(\"%s\\n\", HC[i]);\n    }\n    return 0;\n}\nint initHuffmanTree(huffmanTree& HT)\n{\n    HT = (htNode*)malloc(sizeof(htNode) * (2 * NODENUM));            //给HT分配2 * NODENUM个htNOde大小的htNode类型的数组\n    for (int i = 1; i <= 2 * NODENUM - 1; i++)                        //下标从1开始到2 * NODENUM\n    {\n        HT[i].parent = HT[i].lch = HT[i].rch = -1;                    //双亲和  的值都置为-1\n    }\n    printf(\"please input some weight!\\n\");\n    for (int i = 1; i <= NODENUM; i++)                                //权值只有1-n个\n    {\n        scanf(\"%d\",&HT[i].weight);                                    //给每个结点赋予权值\n    }\n        char c = getchar();                                            //这个来接收上面的回车\n    printf(\"please input some data!\\n\");\n    for (int i = 1; i <= NODENUM; i++)\n    {\n            //scanf(\"%c \",&HT[i].data);\n            char a = getchar();\n        if(a == '\\n')                                                //遇到回车就结束\n            break;\n        else\n            HT[i].data = a;                                            //给每个结点赋予数据\n    }\n\n\nreturn\n \n1\n;\n\n\n\n}\n\n\nvoid creatHuffmanTree(huffmanTree& HT, int n)\n{\n    if (n <= 1)                                                            //如果结点数小于等于1，不创建\n        return;\n    int min1, min2;                                                        //定义两个数，来存储每次选取最小两个结点的权值\n    int rnode, lnode;                                                    //定义两个下标值，来存储每次选取最小两个结点的下标\n    for (int i = n + 1; i <= 2 * n -1; i++)                                //要生成n-1个结点，所以要操作n—1次且从下标为n+1开始存储\n    {\n        int min1 = MAXVALUE; int lnode = -1;                            //让最小值初始化为极大值，这样叶子结点的最大值再大也不会超过这个值了\n        int min2 = MAXVALUE; int rnode = -1;\n        for (int j = 1; j <= i - 1; j++)                                //因为起先是在前n个中选择最小的两个结点的权值，但新生成一个后就得在前n+1个中选择最小的两个结点的权值\n        {                                                                //假设n = 10 总结点数就得为19，那我们就只要比较18次就可以得出结果了，记住比较的次数比生成的总结点数少1\n                if (HT[j].weight < min1 && HT[j].parent == -1)            //这个小于就使得当出现相同的权值时优先考虑先出现的值，可以假设下\n                {\n                    min2 = min1;    rnode = lnode;                        //碰到比min1小的，那min1的值就给第二小的min2，下标也给它\n                    min1 = HT[j].weight; lnode = j;                        //然后最小的给min1，下标同理\n                }\n                else if (HT[j].weight < min2 && HT[j].parent == -1)        //这是第二小的判断\n                {\n                    min2 = HT[j].weight;\n                    rnode = j;\n                }\n        }\n        HT[lnode].parent = HT[rnode].parent = i;                        //最小两个结点的parent变为生成结点的下标\n        HT[i].lch = lnode; HT[i].rch = rnode;                            //生成结点的左为最小的min1的下标，右同理\n        HT[i].weight = HT[lnode].weight + HT[rnode].weight;                //生成结点的权值等于最小结点的权值相加\n    }\n\n\n}\n\n\nvoid createHuffmanCode(huffmanTree HT, huffmanCode& HC, int n)\n{\n    HC = (huffmanCode)malloc(sizeof(huffmanCode) * n + 1);                //申请n + 1个huffmanCode大小huffmanCode类型的临时空间\n                                                                        //因为下标是从一开始，所以我们要申请比结点多一个的结点，和哈夫曼树的结构对应，方便输出\n    char* cd = (char*)malloc(sizeof(char) * n);                            //申请n个char大小char类型的临时空间，这个临时数组记录每次遍历出来的编码\n    int start = 0,c = 0,f = 0;                                            //start为cd数组记录下标，c初始为叶子结点下标，而后就是  结点的下标，f记录双亲结点的下标\n    cd[n - 1] = '\\0';                                                    //这个就是给printf留着的，因为printf不会生成'\\0'，如果用puts就不用这句语句了\n    for (int i = 1; i <= n; i++)                                        //只要叶子结点的编码\n    {\n        start = n - 1;                                                    //这句要赋值n的话，start--要写在判断后方\n        c = i;\n        f = HT[c].parent;\n        while (f != -1)                                                    //根节点没有双亲\n        {\n            start--;\n            if (HT[f].lch == c)                                            //是左就是0，右就为1\n                cd[start] = '0';\n            else\n                cd[start] = '1';\n            c = f; f = HT[c].parent;                                    //向根结点接近\n        }\n        HC[i] = (char*)malloc(sizeof(char) * (n - start));                //给数组里的数组申请n - start个char大小的char*类型的临时空间\n        strcpy(HC[i], &cd[start]);                                        //cd里记录的编码给HC的第i个数组\n    }\n    free(cd);                                                            //释放临时空间\n}\n想问一问为什么输入字符后程序闪退\n ", "Tag": "算法分析"}
