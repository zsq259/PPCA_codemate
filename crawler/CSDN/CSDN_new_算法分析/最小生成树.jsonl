{"Answer": "æ™®é‡Œå§†ç®—æ³•æ˜¯é€‰é¡¶ç‚¹\r\nå‡è®¾ä»Aç‚¹å‡ºå‘æ„é€ æœ€å°ç”Ÿæˆæ ‘ï¼Œè·ç¦»Aç‚¹æœ€è¿‘çš„æ˜¯Dç‚¹ï¼Œè¿æ¥ADï¼›ç„¶åè·ç¦»Aã€Dæœ€è¿‘çš„æ˜¯Bç‚¹ï¼Œè¿æ¥BDï¼›ç„¶åè·ç¦»Aã€Dã€Bæœ€è¿‘çš„æ˜¯Cç‚¹ï¼Œè¿æ¥BCï¼›\r\nç„¶åè·ç¦»Aã€Dã€Bã€Cæœ€è¿‘çš„æ˜¯Fç‚¹ï¼Œè¿æ¥CFï¼›ç„¶åè·ç¦»Aã€Dã€Bã€Cã€Fæœ€è¿‘çš„æ˜¯Gï¼Œè¿æ¥FGï¼›ç„¶åè·ç¦»Aã€Dã€Bã€Cã€Fã€Gç‚¹æœ€è¿‘çš„æ˜¯Eç‚¹ï¼Œè¿æ¥GEï¼›\r\nç„¶åè·ç¦»Aã€Dã€Bã€Cã€Fã€Gã€Eç‚¹æœ€è¿‘çš„æ˜¯Hç‚¹ï¼Œè¿æ¥EHã€‚\r\næœ€å°ç”Ÿæˆæ ‘ä¸ºADBCFGEH\r\nå…‹é²æ–¯å¡å°”ç®—æ³•æ˜¯é€‰è¾¹\r\nè¾¹æƒä¸º2æœ€å°ï¼Œè¿æ¥BCï¼ŒEGï¼›ç„¶åè¾¹æƒä¸º3æœ€å°ï¼Œè¿æ¥EHï¼›ç„¶åè¾¹æƒä¸º4æœ€å°ï¼Œè¿æ¥CFï¼ŒADï¼›ç„¶åè¾¹æƒä¸º5æœ€å°ï¼Œè¿æ¥BDï¼ŒFGã€‚\r\næœ€å°ç”Ÿæˆæ ‘ä¸ºADBCFGEH", "Konwledge_Point": "æœ€å°ç”Ÿæˆæ ‘", "Question": "ç”¨æ™®é‡Œå§†ç®—æ³•æˆ–å…‹é²æ–¯å¡å°”ç®—æ³•æ±‚ä¸‹é¢æ— å‘å¸¦æƒå›¾çš„æœ€å°ç”Ÿæˆæ ‘\nç”¨æ™®é‡Œå§†ç®—æ³•æˆ–å…‹é²æ–¯å¡å°”ç®—æ³•æ±‚ä¸‹é¢æ— å‘å¸¦æƒå›¾çš„æœ€å°ç”Ÿæˆæ ‘", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "ä¸å¯¹ï¼Œè¿™é¢˜åº”è¯¥é€‰A\r\næ±‚é¡¶ç‚¹çš„å…¥åº¦çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(e)*n=O(n*e)\r\néå†é¡¶ç‚¹çš„æ—¶é—´å¤æ‚åº¦æ˜¯O(n^2)\r\nç›¸åŠ æ˜¯O(n^2+n*e)=O(n^2)", "Konwledge_Point": "æœ€å°ç”Ÿæˆæ ‘", "Question": "åœ¨å›¾é‡‡ç”¨é‚»æ¥è¡¨å­˜å‚¨æ—¶ï¼Œæ±‚æœ€å°ç”Ÿæˆæ ‘çš„Primeç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º?\nåœ¨å›¾é‡‡ç”¨é‚»æ¥è¡¨å­˜å‚¨æ—¶ï¼Œæ±‚æœ€å°ç”Ÿæˆæ ‘çš„Primeç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º?\n\nA o(n^2) B o(n^3) C o(n) D o(n+e)\n\nç­”æ¡ˆæ˜¯o(n+e)ã€‚ã€‚ã€‚ä¸ç†è§£..æ±‚è¿‡ç¨‹", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "åŸç†å¯ä»¥ä» ç®—æ³•4th ä¸­å­¦ä¹ ï¼Œ\r\né‡Œé¢è®²äº†ä¸‰ç§ç®—æ³• csharp ä»£ç ï¼š\r\n1. [KruskalMinimumSpanTree](https://github.com/FuGangqiang/algorithms/blob/master/Books/Algorithms/Chap4/KruskalMinimumSpanTree.cs \"\")\r\n2. [LazyPrimMinimumSpanTree](https://github.com/FuGangqiang/algorithms/blob/master/Books/Algorithms/Chap4/LazyPrimMinimumSpanTree.cs \"\")\r\n3. [PrimMinimumSpanTree](https://github.com/FuGangqiang/algorithms/blob/master/Books/Algorithms/Chap4/PrimMinimumSpanTree.cs \"\")", "Konwledge_Point": "æœ€å°ç”Ÿæˆæ ‘", "Question": "æ±‚ä¸€ä¸ª   æœ€å°ç”Ÿæˆæ ‘èšç±»  çš„ç¨‹åº\næ±‚ä¸€ä¸ªæœ€å°ç”Ÿæˆæ ‘çš„èšç±»çš„ç¨‹åºï¼Œè°¢è°¢ã€‚æœ€å¥½æ˜¯c++è¯­è¨€ï¼Œå½“ç„¶matlabï¼Œjavaï¼Œpythonç¨‹åºä¹Ÿå¯ä»¥ã€‚", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "http://bbs.csdn.net/topics/380240225", "Konwledge_Point": "æœ€å°ç”Ÿæˆæ ‘", "Question": "ç±»ä¼¼æœ€å°ç”Ÿæˆæ ‘çš„ç®—æ³•æ±‚è§£ç­”\nè¾“å…¥ä¸€äº›äºŒå…ƒç»„ï¼ŒäºŒå…ƒç»„ä»£è¡¨è¿é€šçš„ä¸¤ä¸ªèŠ‚ç‚¹ã€‚æ‰€æœ‰çš„äºŒå…ƒç»„æ„æˆä¸€ä¸ªæ— å‘å›¾ã€‚ç°åœ¨è¯·ä½ è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œæ±‚å‡ºä¸€ä¸ªæœ€å°ç”Ÿæˆæ ‘ï¼Œä½¿å¾—å›¾ä¸­æ²¡æœ‰å›è·¯ï¼Œå¹¶ä¸”è¿æ¥æ‰€æœ‰èŠ‚ç‚¹ã€‚è¾“å‡ºçš„æ•°æ®ä¹Ÿç”¨äºŒå…ƒç»„è¡¨è¾¾ã€‚\n\nè¦ç”¨Javaæˆ–è€…C#æ¥å®ç°ã€‚", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "å½“ç„¶ä¸ä¸€å®šäº†ã€‚ä¾‹å¦‚ï¼š 5ä¸ªé¡¶ç‚¹ 12345 çš„å…¨è¿é€šå›¾ï¼Œå–å‡º 4æ¡è¾¹ï¼ˆ12ï¼Œ13ï¼Œ23ï¼Œ45ï¼‰å’Œ 5ä¸ªé¡¶ç‚¹ 12345ï¼Œå¹¶ä¸æ˜¯è¿é€šå›¾ã€‚", "Konwledge_Point": "æœ€å°ç”Ÿæˆæ ‘", "Question": "å…³äºè¿é€šå›¾å’Œæœ€å°ç”Ÿæˆæ ‘\nå¯¹äºä¸€ä¸ªæœ‰nä¸ªé¡¶ç‚¹çš„è¿é€šå›¾ï¼Œæœ€å°‘æœ‰N-1æ¡è¾¹ï¼Œæœ€å¤šæœ‰C(n,2)æ¡è¾¹\né‚£ä¹ˆå¦‚æœç°åœ¨è¿™ä¸ªè¿é€šå›¾æœ‰Cï¼ˆn,2)æ¡è¾¹ï¼Œé‚£ä¹ˆæˆ‘å–ä»»æ„n-1æ¡è¾¹å‡ºæ¥å’Œnä¸ªé¡¶ç‚¹ç»„æˆä¸€ä¸ªæ–°å›¾ï¼Œé‚£ä¹ˆè¿™ä¸ªæ–°å›¾è¿˜æ˜¯è¿é€šå›¾å—", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "https://www.cnblogs.com/qscqesze/p/5246222.html", "Konwledge_Point": "æœ€å°ç”Ÿæˆæ ‘", "Question": "æœ€å°ç”Ÿæˆæ ‘æ–¹é¢çš„ä¸€ä¸ªé—®é¢˜ï¼Œç”¨Cè¯­è¨€æ€ä¹ˆè§£å†³çš„ï¼Ÿï¼Ÿï¼Ÿï¼Ÿ\nProblem Description\n\nThere is an undirected graph G with n vertices and m edges. Every time, you can select several edges and delete them. The edges selected must meet the following condition: let Gâ€² be graph induced from these edges, then every connected component of Gâ€² has at most one cycle. What is the minimum number of deletion needed in order to delete all the edges.\n\n\n\nInput\n\nThere are multiple test cases. The first line of input contains an integer T indicating the number of test cases. For each test case:\n\n\n\nThe first line contains two integers n and m (1â‰¤nâ‰¤2000,0â‰¤mâ‰¤2000) -- the number of vertices and the number of edges.\n\n\n\nFor the next m lines, each line contains two integers ui and vi, which means there is an undirected edge between ui and vi (1â‰¤ui,viâ‰¤n,uiâ‰ vi).\n\n\n\nThe sum of values of n in all test cases doesn't exceed 2â‹…104. The sum of values of m in all test cases doesn't exceed 2â‹…104.\n\n\n\nOutput\n\nFor each test case, output the minimum number of deletion needed.\n\n\n\nSample Input\n\n3\n\n4 2\n\n1 2\n\n1 3\n\n4 5\n\n1 2\n\n1 3\n\n1 4\n\n2 3\n\n2 4\n\n4 4\n\n1 2\n\n2 3\n\n3 4\n\n4 1\n\n\n\nSample Output\n\n1\n\n2\n\n1", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "http://hzwer.com/3666.html", "Konwledge_Point": "æœ€å°ç”Ÿæˆæ ‘", "Question": "æœ€å°ç”Ÿæˆæ ‘                 \nDescription\n\n\n\nã€€ç»™å®šä¸€ä¸ªè¾¹å¸¦æ­£æƒçš„è¿é€šæ— å‘å›¾G=(V,E)ï¼Œå…¶ä¸­N=|V|ï¼ŒM=|E|ï¼ŒNä¸ªç‚¹ä»1åˆ°Nä¾æ¬¡ç¼–å·ï¼Œç»™å®šä¸‰ä¸ªæ­£æ•´æ•°uï¼Œvï¼Œå’ŒL (uâ‰ v)ï¼Œå‡è®¾ç°åœ¨åŠ å…¥ä¸€æ¡è¾¹æƒä¸ºLçš„è¾¹(u,v)ï¼Œé‚£ä¹ˆéœ€è¦åˆ æ‰æœ€å°‘å¤šå°‘æ¡è¾¹ï¼Œæ‰èƒ½å¤Ÿä½¿å¾—è¿™æ¡è¾¹æ—¢å¯èƒ½å‡ºç°åœ¨æœ€å°ç”Ÿæˆæ ‘ä¸Šï¼Œä¹Ÿå¯èƒ½å‡ºç°åœ¨æœ€å¤§ç”Ÿæˆæ ‘ä¸Šï¼Ÿ\n\n\n\nInput\n\n\n\nã€€ã€€ç¬¬ä¸€è¡ŒåŒ…å«ç”¨ç©ºæ ¼éš”å¼€çš„ä¸¤ä¸ªæ•´æ•°ï¼Œåˆ†åˆ«ä¸ºNå’ŒMï¼›\n\næ¥ä¸‹æ¥Mè¡Œï¼Œæ¯è¡ŒåŒ…å«ä¸‰ä¸ªæ­£æ•´æ•°uï¼Œvå’Œwè¡¨ç¤ºå›¾Gå­˜åœ¨ä¸€æ¡è¾¹æƒä¸ºwçš„è¾¹(u,v)ã€‚\n\næœ€åä¸€è¡ŒåŒ…å«ç”¨ç©ºæ ¼éš”å¼€çš„ä¸‰ä¸ªæ•´æ•°ï¼Œåˆ†åˆ«ä¸ºuï¼Œvï¼Œå’Œ Lï¼›\n\næ•°æ®ä¿è¯å›¾ä¸­æ²¡æœ‰è‡ªç¯ã€‚\n\nOutput\n\n\n\nã€€è¾“å‡ºä¸€è¡Œä¸€ä¸ªæ•´æ•°è¡¨ç¤ºæœ€å°‘éœ€è¦åˆ æ‰çš„è¾¹çš„æ•°é‡ã€‚\n\n\n\nSample Input\n\n\n\n3 2\n\n3 2 1\n\n1 2 3\n\n1 2 2\n\nSample Output\n\n\n\n1", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "primç®—æ³•\ndef findTree(G:dict):\n    start = list(G.keys())[0]\n    choice = [(start, i, j) for i, j in G[start].items()]\n    choice.sort(key=lambda x:x[2])\n    tree = list()\n    seen = {start}\n    while choice:\n        node = choice.pop(0)\n        if node[1] not in seen:\n            seen.add(node[1])\n            line = sorted([node[0],node[1]])\n            line.append(node[2])\n            tree.append(line)\n            for i, j in G[node[1]].items():\n                choice.append((node[1],i,j))\n            choice.sort(key=lambda x:x[2])\n    return tree\n\nif __name__ == \"__main__\":\n    graph = {\n    \"a\":{\"b\":10, \"c\":8, \"f\":5},\n    \"b\":{\"a\":10, \"d\":9, \"f\":7},\n    \"c\":{\"a\":8, \"e\":10, \"f\":17},\n    \"d\":{\"b\":9, \"e\":11, \"f\":12, \"g\":4},\n    \"e\":{\"c\":10, \"d\":11, \"f\":3, \"g\":16},\n    \"f\":{\"a\":5, \"b\":7, \"c\":17, \"d\":12, \"e\":3},\n    \"g\":{\"d\":4, \"e\":16}\n    }\n    lines = set()\n    for node, value in graph.items():\n        for i, j in value.items():\n            temp = sorted([node,i])\n            temp.append(j)\n            lines.add(tuple(temp))\n    print(lines)\n    tree = findTree(graph)\n    print(tree)\n", "Konwledge_Point": "æœ€å°ç”Ÿæˆæ ‘", "Question": "å…³äºæœ€å°ç”Ÿæˆæ ‘çš„åº”ç”¨\nå·²çŸ¥å¸¦æƒæ— å‘å›¾ï¼ˆå¦‚ä¸‹æ‰€ç¤ºï¼‰ï¼Œæ±‚æœ€å°ç”Ÿæˆæ ‘ã€‚Program2ç”¨å›¾è¦æ±‚è¾“å‡ºï¼š(1)æ‰€æœ‰çš„è¾¹åŠæƒå€¼ï¼Œå¦‚ï¼šï¼ˆâ€˜aâ€™,â€™bâ€™,10ï¼‰â€¦(2)æœ€å°ç”Ÿæˆæ ‘æ‰€åŒ…å«çš„è¾¹ï¼Œå¦‚ï¼šï¼ˆâ€™aâ€™,â€˜câ€™,â€˜weightâ€™:8ï¼‰â€¦\n\n", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "ArcGISæ˜¯ä¸€ä¸ªåŠŸèƒ½ä¸°å¯Œçš„åœ°ç†ä¿¡æ¯ç³»ç»Ÿ(GIS)å·¥å…·ï¼Œå¯ä»¥ç”¨æ¥å¤„ç†å’Œåˆ†æåœ°ç†æ•°æ®ã€‚è¦åœ¨ArcGISä¸­æ„å»ºæœ€å°ç”Ÿæˆæ ‘ç½‘ç»œ(Minimum Spanning Tree, MST)ï¼Œå¯ä»¥ä½¿ç”¨å…¶ä¸­çš„\"Network Analyst\"å·¥å…·ã€‚\né¦–å…ˆï¼Œéœ€è¦æ‹¥æœ‰ä¸€ä¸ªç‚¹æ•°æ®é›†å’Œä¸€ä¸ªè¾¹æ•°æ®é›†ã€‚è¿™äº›æ•°æ®é›†å¯ä»¥æ¥è‡ª shapefile æ–‡ä»¶ï¼ŒCSVæ–‡ä»¶æˆ–è€…æ˜¯GDBæ–‡ä»¶ã€‚\næ‰“å¼€ArcMapï¼Œæ·»åŠ ç‚¹æ•°æ®é›†å’Œè¾¹æ•°æ®é›†åˆ°åœ°å›¾ä¸­ã€‚\næ‰“å¼€ \"Network Analyst\"å·¥å…·ï¼Œåœ¨å·¥å…·æ ä¸­é€‰\"New Network Analysis Layer\"ã€‚\nåœ¨å¼¹å‡ºçš„çª—å£ä¸­ï¼Œé€‰æ‹©â€œConnectivityâ€ä½œä¸ºç±»å‹ï¼Œå¹¶æŒ‡å®šç‚¹æ•°æ®é›†ä½œä¸ºç»ˆç‚¹ï¼Œè¾¹æ•°æ®é›†ä½œä¸ºè¾¹ã€‚\nç‚¹å‡» \"OK\"æŒ‰é’®ï¼Œåˆ›å»ºç½‘ç»œåˆ†æå±‚ã€‚\nåœ¨ \"Network Analyst\"é¢æ¿ä¸­ï¼Œé€‰æ‹© \"Generate Service Area\"å·¥å…·ã€‚\nåœ¨å¼¹å‡ºçš„çª—å£ä¸­ï¼Œé€‰æ‹©è¦æ±‚çš„é€‰é¡¹ï¼ˆæ¯”å¦‚ç½‘ç»œè®¾ç½®ï¼Œåˆ†æé˜ˆå€¼ç­‰ï¼‰\nåœ¨ \"Solver\"æ ä¸­ï¼Œé€‰æ‹©â€œMinimum Spanning Tree\"ï¼Œå¹¶ç‚¹å‡» \"Solve\"æŒ‰é’®è¿è¡Œåˆ†æã€‚\nåˆ†æå®Œæˆåï¼Œç»“æœå°†æ˜¾ç¤ºåœ¨åœ°å›¾ä¸Šï¼Œè¡¨ç¤ºæœ€å°ç”Ÿæˆæ ‘çš„è·¯å¾„ã€‚\nå¯ä»¥é€šè¿‡å¯¼å‡ºæˆ shapefileæˆ–è€…å…¶ä»–æ–‡ä»¶æ ¼å¼æ¥ä¿å­˜ç»“æœï¼Œæˆ–è€…åœ¨ ArcGIS Proé‡Œç»§ç»­åˆ†æã€‚\nå¦å¤–ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯,ä½¿ç”¨\"Network Analyst\"å·¥å…·æ„å»ºçš„æœ€å°ç”Ÿæˆæ ‘ï¼Œæ˜¯åŸºäºç©ºé—´å…³ç³»çš„ï¼Œå³æ ¹æ®ç‚¹ä¹‹é—´çš„è·ç¦»æ„å»ºæœ€å°ç”Ÿæˆæ ‘,å¦‚æœéœ€è¦æ ¹æ®æƒé‡æ¥æ„å»ºæœ€å°ç”Ÿæˆæ ‘ï¼Œéœ€è¦åœ¨è¾¹æ•°æ®ä¸­è®¾ç½®æƒé‡å±æ€§,å¹¶åœ¨Network Analystä¸­å¯¹æƒé‡å±æ€§è¿›è¡Œè®¾ç½®ã€‚", "Konwledge_Point": "æœ€å°ç”Ÿæˆæ ‘", "Question": "å¦‚ä½•ç”¨argisæ„å»ºæœ€å°ç”Ÿæˆæ ‘ç½‘ç»œ\næƒ³ä½¿ç”¨arcgisæ„å»ºæœ€å°ç”Ÿæˆæ ‘ç½‘ç»œ è¯¥æ–¹æ³•æ¥æºäºfaber2014çš„ä¸€ç¯‡æ–‡ç«  ä½†æ˜¯ä¸çŸ¥é“å¦‚ä½•å…·ä½“æ“ä½œ", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "ç¬¬ä¸€é¢˜D  1+2+4+7=14ç¬¬äºŒé¢˜ ä¸€ä¸ªæˆ–å¤šä¸ª", "Konwledge_Point": "æœ€å°ç”Ÿæˆæ ‘", "Question": "åˆ†åˆ«é€‰æ‹©ä»€ä¹ˆï¼Œç¬¬ä¸€é“é¢˜æœ‰æ²¡æœ‰æœ€å°ç”Ÿæˆæ ‘çš„å›¾ç¤ºå•Š\nåˆ†åˆ«é€‰æ‹©ä»€ä¹ˆï¼Œç¬¬ä¸€é“é¢˜æœ‰æ²¡æœ‰æœ€å°ç”Ÿæˆæ ‘çš„å›¾ç¤ºå•Šï¼Œè°¢è°¢ï¼Œè¾›è‹¦è¾›è‹¦\n\n", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "è¿™é“é¢˜ä¸€çœ‹å°±æ˜¯æœ€å°ç”Ÿæˆæ ‘ï¼Œæœ‰ä¸¤ç§æ–¹æ³•ï¼Œåˆ†åˆ«ä¸ºæ™®é‡Œå§†ç®—æ³•ï¼ˆprimï¼‰å’Œå…‹é²æ–¯å¡å°”ï¼ˆkruskalï¼‰æœ¬é¢˜è§£ä½¿ç”¨çš„æ˜¯ kruskalå‡è®¾è¿é€šç½‘Gï¼ï¼ˆVï¼ŒEï¼‰ï¼Œåˆ™ä»¤æœ€å°ç”Ÿæˆæ ‘çš„åˆå§‹çŠ¶æ€ä¸ºåªæœ‰nä¸ªé¡¶ç‚¹è€Œæ— è¾¹çš„éè¿é€šç½‘ï¼Œå›¾ä¸­æ¯ä¸ªé¡¶ç‚¹è‡ªæˆä¸€ä¸ªè¿é€šåˆ†é‡ã€‚åœ¨Eä¸­é€‰æ‹©ä»£ä»·æœ€å°çš„è¾¹ï¼Œè‹¥è¯¥è¾¹ä¾é™„çš„é¡¶ç‚¹è½åœ¨Tä¸­ä¸åŒçš„è¿é€šåˆ†é‡ä¸Šï¼Œåˆ™å°†æ­¤è¾¹åŠ å…¥åˆ°Tä¸­ï¼Œå¦åˆ™èˆå»æ­¤è¾¹è€Œé€‰æ‹©ä¸‹ä¸€æ¡ä»£ä»·æœ€å°çš„è¾¹ã€‚ä¾æ­¤ç±»æ¨ï¼Œç›´è‡³Tä¸­æ‰€æœ‰é¡¶ç‚¹éƒ½åœ¨åŒä¸€è¿é€šåˆ†é‡ä¸Šä¸ºæ­¢ã€‚\n\n#include<stdio.h>\n#include<string.h>\n#include<iostream>\nusing namespace std;\nint n,a[105][105],v[105],p,q,minn,ans,m;\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n     for(int j=1;j<=n;j++)\n      scanf(\"%d\",&a[i][j]);\n    for(int i=1;i<=n;i++)v[i]=i; //å…¨éƒ¨ç‚¹éƒ½æ˜¯ä¸€å®šå•ç‹¬çš„é›†åˆ\n    for(int i=1;i<=n-1;i++){ //åªç”¨å¾ªç¯åˆ°n-1ï¼Œå› ä¸ºåªæœ‰n-1æ¡è¾¹\n        minn=99999999; //minnè¦èµ‹æœ€å¤§å€¼ï¼Œä¸€å®šä¸è¦èµ‹0x7f\n        for(int k=1;k<=n;k++)\n         for(int j=1;j<=n;j++)\n          if(v[k]!=v[j] and a[k][j]<=minn and a[k][j]!=0){\n              minn=a[k][j];\n              p=j; //è®°å½•jå’Œkï¼Œä¾›åé¢ä½¿ç”¨\n              q=k;\n          }\n        ans+=minn; //æŠŠæƒå€¼åŠ ä¸Šå»\n        int t=v[p];\n        for(int k=1;k<=n;k++){\n            if(v[k]==t)v[k]=v[q]; //æŠŠv[k]é›†åˆçš„ç‚¹å…¨éƒ¨å˜æˆv[q]é›†åˆçš„ç‚¹ï¼Œç¬¦åˆå…‹é²æ–¯å¡å°”ç®—æ³•çš„æ€æƒ³\n        }\n    }\n    printf(\"%d\",ans);\n    return 0;\n}\n", "Konwledge_Point": "æœ€å°ç”Ÿæˆæ ‘", "Question": "å…³äºæœ€å°ç”Ÿæˆæ ‘çš„é—®é¢˜ï¼Œå¦‚ä½•ä¿®æ”¹ï¼Ÿ(è¯­è¨€-c++)\n\n\nã€æœ€å°ç”Ÿæˆæ ‘ä¸“é¢˜ã€‘æœ€çŸ­ç½‘ç»œ (Standard IO)\næ—¶é—´é™åˆ¶: 1000 ms  ç©ºé—´é™åˆ¶: 262144 KB  å…·ä½“é™åˆ¶  \n\n\n\n\né¢˜ç›®æè¿°\nå†œæ°‘çº¦ç¿°è¢«é€‰ä¸ºä»–ä»¬é•‡çš„é•‡é•¿ï¼ä»–å…¶ä¸­ä¸€ä¸ªç«é€‰æ‰¿è¯ºå°±æ˜¯åœ¨é•‡ä¸Šå»ºç«‹èµ·äº’è”ç½‘ï¼Œå¹¶è¿æ¥åˆ°æ‰€æœ‰çš„å†œåœºã€‚å½“ç„¶ï¼Œä»–éœ€è¦ä½ çš„å¸®åŠ©ã€‚çº¦ç¿°å·²ç»ç»™ä»–çš„å†œåœºå®‰æ’äº†ä¸€æ¡é«˜é€Ÿçš„ç½‘ç»œçº¿è·¯ï¼Œä»–æƒ³æŠŠè¿™æ¡çº¿è·¯å…±äº«ç»™å…¶ä»–å†œåœºã€‚ä¸ºäº†ç”¨æœ€å°çš„æ¶ˆè´¹ï¼Œä»–æƒ³é“ºè®¾æœ€çŸ­çš„å…‰çº¤å»è¿æ¥æ‰€æœ‰çš„å†œåœºã€‚ä½ å°†å¾—åˆ°ä¸€ä»½å„å†œåœºä¹‹é—´è¿æ¥è´¹ç”¨çš„åˆ—è¡¨ï¼Œä½ å¿…é¡»æ‰¾å‡ºèƒ½è¿æ¥æ‰€æœ‰å†œåœºå¹¶æ‰€ç”¨å…‰çº¤æœ€çŸ­çš„æ–¹æ¡ˆã€‚æ¯ä¸¤ä¸ªå†œåœºé—´çš„è·ç¦»ä¸ä¼šè¶…è¿‡100000ã€‚\n\n\nè¾“å…¥\nç¬¬ä¸€è¡Œï¼šå†œåœºçš„ä¸ªæ•°ï¼ŒNï¼ˆ3<=N<=100ï¼‰ã€‚\nåæ¥çš„è¡ŒåŒ…å«äº†ä¸€ä¸ªN*Nçš„çŸ©é˜µ,è¡¨ç¤ºæ¯ä¸ªå†œåœºä¹‹é—´çš„è·ç¦»ã€‚ç†è®ºä¸Šï¼Œä»–ä»¬æ˜¯Nè¡Œï¼Œæ¯è¡Œç”±Nä¸ªç”¨ç©ºæ ¼åˆ†éš”çš„æ•°ç»„æˆï¼Œå®é™…ä¸Šï¼Œä»–ä»¬é™åˆ¶åœ¨80ä¸ªå­—ç¬¦ï¼Œå› æ­¤ï¼ŒæŸäº›è¡Œä¼šç´§æ¥ç€å¦ä¸€äº›è¡Œã€‚å½“ç„¶ï¼Œå¯¹è§’çº¿å°†ä¼šæ˜¯0ï¼Œå› ä¸ºä¸ä¼šæœ‰çº¿è·¯ä»ç¬¬iä¸ªå†œåœºåˆ°å®ƒæœ¬èº«ã€‚\n\n\nè¾“å‡º\nåªæœ‰ä¸€ä¸ªè¾“å‡ºï¼Œå…¶ä¸­åŒ…å«è¿æ¥åˆ°æ¯ä¸ªå†œåœºçš„å…‰çº¤çš„æœ€å°é•¿åº¦ã€‚\n\n\næ ·ä¾‹è¾“å…¥\n4\n0  4  9  21\n4  0  8  17\n9  8  0  16\n21 17 16  0\n\n\næ ·ä¾‹è¾“å‡º\n28\n\n\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\nint\n a[\n105\n][\n105\n],s,n,visit[\n105\n],visitt;\nqueue<\nint\n> q;\n\nvoid\n \npr\n()\n\n\n{\n    q.\npush\n(\n1\n);\n    visit[\n1\n]=\n1\n;\n    \nwhile\n(\n1\n)\n    {\n        \nint\n minn=\n100005\n,minni;\n        \nfor\n(\nint\n j=\n1\n;j<=n;j++)\n        {\n            \nif\n(a[q.\nfront\n()][j]>n;\n    \nfor\n(\nint\n i=\n1\n;i<=n;i++)\n    {\n        \nfor\n(\nint\n j=\n1\n;j<=n;j++)\n        {\n            cin>>a[i][j];\n        }\n    }\n    \npr\n();\n    cout<<s;\n}\n\n\n\n\n\næˆ‘å“ªé‡Œé”™äº†ï¼Œæ±‚æŒ‡æ˜ï¼", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "æ¥¼ä¸»å¯ä»¥å‚è€ƒè¿™ä¸ªï¼Œå¾ˆå¯èƒ½å¯¹æ¥¼ä¸»æœ‰ç”¨ï¼š [url]http://www.cnblogs.com/codeyu/archive/2009/09/03/1559736.html[/url]", "Konwledge_Point": "æœ€å°ç”Ÿæˆæ ‘", "Question": "æˆ‘æœ‰ä¸ªjavaè¿æ¥ç½‘ç»œçš„ç¨‹åºï¼Œæƒ³è¦åœ¨windowsç™»é™†å‰æ‰§è¡Œè¿™ä¸ªç¨‹åºï¼Œè¯·æ•™è¯¥å¦‚ä½•åš\næˆ‘æœ‰ä¸ªjavaè¿æ¥ç½‘ç»œçš„ç¨‹åºï¼Œæƒ³è¦åœ¨windowså¼€æœºä»¥åï¼Œç”¨æˆ·ç™»é™†å‰æ‰§è¡Œè¿™ä¸ªç¨‹åºï¼Œè¯·æ•™è¯¥å¦‚ä½•åš", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "http://www.cnblogs.com/Fatedayt/archive/2011/09/19/2181775.html", "Konwledge_Point": "æœ€å°ç”Ÿæˆæ ‘", "Question": "è¿·å®«åŸå ¡             \nProblem Description\n\nä¸ºäº†è®­ç»ƒå°å¸Œçš„æ–¹å‘æ„Ÿï¼ŒGardonå»ºç«‹äº†ä¸€åº§å¤§åŸå ¡ï¼Œé‡Œé¢æœ‰Nä¸ªæˆ¿é—´(N<=10000)å’ŒMæ¡é€šé“(M<=100000)ï¼Œæ¯ä¸ªé€šé“éƒ½æ˜¯å•å‘çš„ï¼Œå°±æ˜¯è¯´è‹¥ç§°æŸé€šé“è¿é€šäº†Aæˆ¿é—´å’ŒBæˆ¿é—´ï¼Œåªè¯´æ˜å¯ä»¥é€šè¿‡è¿™ä¸ªé€šé“ç”±Aæˆ¿é—´åˆ°è¾¾Bæˆ¿é—´ï¼Œä½†å¹¶ä¸è¯´æ˜é€šè¿‡å®ƒå¯ä»¥ç”±Bæˆ¿é—´åˆ°è¾¾Aæˆ¿é—´ã€‚Gardonéœ€è¦è¯·ä½ å†™ä¸ªç¨‹åºç¡®è®¤ä¸€ä¸‹æ˜¯å¦ä»»æ„ä¸¤ä¸ªæˆ¿é—´éƒ½æ˜¯ç›¸äº’è¿é€šçš„ï¼Œå³ï¼šå¯¹äºä»»æ„çš„iå’Œjï¼Œè‡³å°‘å­˜åœ¨ä¸€æ¡è·¯å¾„å¯ä»¥ä»æˆ¿é—´iåˆ°æˆ¿é—´jï¼Œä¹Ÿå­˜åœ¨ä¸€æ¡è·¯å¾„å¯ä»¥ä»æˆ¿é—´jåˆ°æˆ¿é—´iã€‚\n\n\n\nInput\n\nè¾“å…¥åŒ…å«å¤šç»„æ•°æ®ï¼Œè¾“å…¥çš„ç¬¬ä¸€è¡Œæœ‰ä¸¤ä¸ªæ•°ï¼šNå’ŒMï¼Œæ¥ä¸‹æ¥çš„Mè¡Œæ¯è¡Œæœ‰ä¸¤ä¸ªæ•°aå’Œbï¼Œè¡¨ç¤ºäº†ä¸€æ¡é€šé“å¯ä»¥ä»Aæˆ¿é—´æ¥åˆ°Bæˆ¿é—´ã€‚æ–‡ä»¶æœ€åä»¥ä¸¤ä¸ª0ç»“æŸã€‚\n\n\n\nOutput\n\nå¯¹äºè¾“å…¥çš„æ¯ç»„æ•°æ®ï¼Œå¦‚æœä»»æ„ä¸¤ä¸ªæˆ¿é—´éƒ½æ˜¯ç›¸äº’è¿æ¥çš„ï¼Œè¾“å‡º\"Yes\"ï¼Œå¦åˆ™è¾“å‡º\"No\"ã€‚\n\n\n\nSample Input\n\n3 3 1 2 2 3 3 1 3 3 1 2 2 3 3 2 0 0\n\n\n\nSample Output\n\nYes No", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "#include<bits/stdc++.h>using namespace std;const int inf=0x3f3f3f3f;int n,m;int mp[50][50],book[50],dis[50],parent[50];void prim(){    for(int i=1;i<=n;i++)    {        dis[i]=mp[1][i];        if(mp[1][i]!=inf)            parent[i]=1;    }    int ans;    book[1]=1;    for(int i=1;i<n;i++)    {        int minn=inf,u;        for(int j=1;j<=n;j++)        {            if(!book[j]&&minn>dis[j])            {                u=j;                minn=dis[j];            }        }        book[u]=1;\n    int x=parent[u];\n    int y=u;\n    int z=mp[parent[u]][u];\n    if(x>y) \n        swap(x,y);\n    printf(\"%d,%d,%d\\n\",x,y,z);\n    \n    for(int v=1;v<=n;v++)\n    {\n        if(!book[v]&&dis[v]>mp[u][v])\n        {\n            dis[v]=mp[u][v];\n            parent[v]=u;\n        }    \n    }\n}\n\n}\nint main(){    memset(book,0,sizeof(book));    cin>>n>>m;    memset(mp,0x3f,sizeof(mp));    for(int i=1;i<=n;i++)        mp[i][i]=0;    for(int i=1;i<=m;i++)    {        int a,b,c;        cin>>a>>b>>c;        mp[a][b]=mp[b][a]=min(mp[a][b],c);    }    prim();}", "Konwledge_Point": "æœ€å°ç”Ÿæˆæ ‘", "Question": "R7-2 æœ€å°ç”Ÿæˆæ ‘æ„é€  (25 åˆ†)\n giegieä»¬ï¼ï¼\n\n\nè¾“å…¥æ ·ä¾‹ï¼š\n4 6\n1 2 1\n1 3 4\n1 4 1\n2 3 3\n2 4 2\n3 4 5", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "\ndef mctFromLeafValues( arr):\n    res = 0\n    while len(arr) > 1:\n        min_val = min(arr)\n        idx = arr.index(min_val)\n        if idx > 0 and idx < len(arr) - 1: #æœ‰å·¦æœ‰å³\n            left_val, right_val = arr[idx - 1], arr[idx + 1]\n        elif idx == len(arr) - 1: #æœ‰å·¦æ²¡å³\n            left_val, right_val = arr[idx - 1], 16 #ä¸ºä»€ä¹ˆæ˜¯16ï¼Ÿå› ä¸ºæœ€å¤§åªæœ‰15\n        elif idx == 0: #æœ‰å³æ²¡å·¦\n            left_val, right_val = 16, arr[idx + 1]\n            \n        res += min(min_val * left_val, min_val * right_val)\n        arr.remove(min_val) #æŠŠå½“å‰æœ€å°å€¼åˆ æ‰ï¼Œå·²ç»ç”¨å®Œäº†\n    return res\narr = [5,1,4]\nprint(mctFromLeafValues(arr))\n", "Konwledge_Point": "æœ€å°ç”Ÿæˆæ ‘", "Question": "ç”¨pythonè¯­è¨€å®ç°â€œæœ€å°ä»£ä»·ç”Ÿæˆæ ‘â€é—®é¢˜çš„åˆ†æ”¯é™ç•Œç®—æ³•\næ±‚Pythonçš„å„ä½å¸®å¿™çœ‹çœ‹ï¼Œç”¨pythonè¯­è¨€å®ç°â€œæœ€å°ä»£ä»·ç”Ÿæˆæ ‘â€é—®é¢˜çš„åˆ†æ”¯é™ç•Œç®—æ³•", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "æ‰“æ–­ç‚¹è¿½ä¸€ä¸‹è¿™ä¸ªtå€¼ï¼Œæœ‰å¯èƒ½tå€¼è¿˜æ˜¯-1ã€‚", "Konwledge_Point": "æœ€å°ç”Ÿæˆæ ‘", "Question": "è¿™ä¸ªç¼“å†²åŒºæº¢å‡ºå’Œæ— æ•ˆæ•°æ®æ€ä¹ˆè§£å†³å•Š\nå¤§ä¸€æ±‚é—®ï¼Œç”¨primç®—æ³•æ±‚æœ€å°ç”Ÿæˆæ ‘ï¼Œâš ï¸ç¼“å†²åŒºæº¢å‡ºå’Œæ— æ•ˆæ•°æ®ï¼Œä¸çŸ¥é“æ€ä¹ˆæ”¹", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "#include\"MST.h\"ä¹‹å‰çš„éƒ¨åˆ†ä¿å­˜ä¸ºMST.hæ–‡ä»¶è¿™è¡Œå‰é¢ç¼ºä¸ªèŠ±æ‹¬å·", "Konwledge_Point": "æœ€å°ç”Ÿæˆæ ‘", "Question": "æˆ‘ä»åˆ«äººé‚£å¤åˆ¶è¿‡æ¥çš„ä½†æ˜¯æ‰¾ä¸åˆ°MST.hæ–‡ä»¶\nå¸®æˆ‘çœ‹çœ‹è¿™äº›ä»£ç ä¸ºä»€ä¹ˆè¿è¡Œä¸äº†ï¼Œæˆ‘ç¼ºå°‘çš„MST.hæ–‡ä»¶åº”è¯¥æ˜¯ä»€ä¹ˆå†…å®¹æ‰èƒ½è®©è¿™äº›æ­£å¸¸è¿è¡Œåœ¨vs2013é‡Œå†™çš„\n\n\n\n```c++\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\nusing\n \nnamespace\n std;\n\nclass\n \nMST\n{\n\npublic\n:\n    \nMST\n(){ pNumber = \n0\n; map = \nNULL\n; }  \n    ~\nMST\n(){ \ndelete\n []map; }\n    \nvoid\n \ncreatePoint\n()\n;        \n//å¯¹åº”é€šä¿¡ç½‘é€ ä»·æ¨¡æ‹Ÿç³»ç»Ÿçš„Aé€‰é¡¹åˆ›å»ºç”µç½‘é¡¶ç‚¹\n\n    \nvoid\n \naddEdge\n()\n;            \n//å¯¹åº”é€šä¿¡ç½‘é€ ä»·æ¨¡æ‹Ÿç³»ç»Ÿçš„Bé€‰é¡¹æ·»åŠ ç”µç½‘çš„è¾¹\n\n    \nvoid\n \ncreateTree\n()\n;           \n//å¯¹åº”é€šä¿¡ç½‘é€ ä»·æ¨¡æ‹Ÿç³»ç»Ÿçš„Cé€‰é¡¹æ„é€ æœ€å°ç”Ÿæˆæ ‘\n\n    \nvoid\n \ndisplayTree\n()\n;           \n//å¯¹åº”é€šä¿¡ç½‘é€ ä»·æ¨¡æ‹Ÿç³»ç»Ÿçš„Dé€‰é¡¹æ˜¾ç¤ºæœ€å°ç”Ÿæˆæ ‘\n\n    \nstring \nfindPoint\n(\nint\n iPos)\n;\n//å¯»æ‰¾pNameä¸­iPosä½ç½®çš„èŠ‚ç‚¹åç§°\n\n    \nbool\n \njudgePoint\n(\nint\n iPos)\n; \n//åˆ¤æ–­iPosä½ç½®çš„ç‚¹æ˜¯å¦å·²ç»æ”¾å…¥storeå®¹å™¨ä¸­\n\n    \nint\n \njudgeEdge\n(\nint\n temp)\n;   \n//åˆ¤æ–­æ˜¯å¦å­˜åœ¨æƒå€¼æ¯”tempæ•°å€¼è¿˜å°çš„è¾¹\n\n\nprivate\n:\n    \nint\n pNumber;               \n//é€šä¿¡ç½‘èŠ‚ç‚¹çš„ä¸ªæ•°\n\n    \nint\n iCount = \n0\n;            \n//é€šä¿¡ç½‘èŠ‚ç‚¹ä¸ªæ•°è®¡æ•°å™¨\n\n    \nint\n iStart;                \n//èµ·å§‹ç‚¹ä½ç½®å¯¹åº”pNameä¸­çš„ä½ç½®\n\n    \nint\n iWeight;               \n//å­˜åœ¨æ¯”tempæ•°å€¼æ›´å°çš„è¾¹çš„æƒ\n\n    \nint\n **map;                 \n//ç”¨äºå­˜å‚¨å„è¾¹ä¹‹é—´çš„æƒ\n\n    string start;              \n//èµ·å§‹ç‚¹ä½ç½®çš„åç§°\n\n    vector pName;      \n//å­˜å‚¨æ‰€æœ‰èŠ‚ç‚¹çš„åç§°\n\n    vector>store;\n//storeä¸­çš„èµ·ç‚¹å­˜å‚¨çš„æ¯æ¡è¾¹çš„ç»ˆç‚¹å’Œå¯¹åº”çš„æƒå€¼\n\n\n\n#\ninclude\n\"MST.h\"\n\n\nusing\n \nnamespace\n std;\n\nbool\n \nMST::judgePoint\n(\nint\n iPos)\n{\n    \nfor\n (\nint\n iX=\n0\n ; iX < store.\nsize\n(); iX++){         \n        \nif\n (iPos == store[iX].first&&store[iX].second != \n0\n)\n            \nreturn\n \nfalse\n;               \n//storeä¸­å­˜åœ¨è¿™ä¸ªç‚¹\n\n    }\n    \nreturn\n \ntrue\n;                        \n//storeä¸­ä¸å­˜åœ¨è¿™ä¸ªç‚¹\n\n}\n\nint\n \nMST::judgeEdge\n(\nint\n temp)\n{\n    \nint\n iPos;\n    \nif\n (iCount == \n1\n){                   \n//ç¬¬äºŒä¸ªé¡¶ç‚¹å¼€å§‹çš„ä½ç½®å•ç‹¬è®¨è®º\n\n        \nfor\n (\nint\n iX = \n0\n; iX < pNumber; iX++){\n            \nif\n (map[iStart][iX] < temp&â†¦[iStart][iX]>\n0\n && map[iStart][iX] != store[\n0\n].second){\n                iWeight = map[iStart][iX];\n                \nreturn\n iX;\n            }\n        }\n    }\n    \nif\n(iCount>\n1\n){\n        \nint\n iPos = iCount\n-1\n;\n        \nfor\n (iPos;iPos>=\n0\n;iPos--)\n            \nfor\n (\nint\n iX = \n0\n; iX < pNumber;iX++)\n                \nif\n (map[iPos][iX] < temp&â†¦[iPos][iX] != store[iPos].second&â†¦[iPos][iX]>\n0\n && iX != iStart){\n                iWeight = map[iPos][iX];\n                \nreturn\n iX;                \n//ä¹‹å‰çš„é¡¶ç‚¹å¯¹åº”æœ‰æƒæ›´å°çš„è¾¹\n\n            }\n        }\n    \nreturn\n \n-1\n;\n//æ²¡æœ‰æƒæ›´å°çš„è¾¹\n\n}\n\nvoid\n \nMST::createTree\n()\n{\n    cout << \n\"è¯·è¾“å…¥èµ·å§‹é¡¶ç‚¹ï¼š\"\n;\n    cin >> start;\n    iCount = \n0\n;        \n//è®¡æ•°å™¨æ¯æ¬¡æ“ä½œå‰ç½®0                     \n\n    \nint\n iPos,temp,iName;  \n//iPoså¯¹åº”æ¯æ¬¡æœç´¢çš„èµ·ç‚¹ tempå¯¹åº”èµ·ç‚¹å¯¹åº”çš„è¾¹çš„æƒ iNameå¯¹åº”æœç´¢åçš„ç»ˆç‚¹\n\n    store.\nclear\n();       \n//storeæ¯æ¬¡æ“ä½œå‰æ¸…ç©º\n\n    store.\nresize\n(pNumber);\n    \nfor\n (iPos = \n0\n; iPos < pNumber; iPos++){  \n//é¦–å…ˆæ‰¾åˆ°èµ·å§‹ç‚¹å¯¹åº”pNameä¸­çš„ä½ç½®\n\n        \nif\n (start == pName[iPos]){\n            iStart = iPos;\n            \nbreak\n;\n        }\n    }\n    \nwhile\n (iCount=map[iPos][iX] && map[iPos][iX]>\n0\n && iPos != iX&&\njudgePoint\n(iX)){\n                \nif\n ((iCount != \n0\n && iPos != iStart||iCount==\n0\n&&iPos==iStart)&&iX!=iStart){\n                    temp = map[iPos][iX];\n                    iName = iX;\n                }\n            }\n        }\n        \nif\n (\njudgeEdge\n(temp) == \n-1\n){   \n//å¦‚æœstoreä¹‹å‰çš„é¡¶ç‚¹ä¸å­˜åœ¨æƒæ¯”tempæ›´å°çš„è¾¹\n\n            store[iCount].second = temp;\n            store[iCount].first = iName;\n        }\n\n        \nif\n (\njudgeEdge\n(temp) != \n-1\n){    \n//å¦‚æœå­˜åœ¨æƒæ¯”tempæ›´å°çš„è¾¹\n\n            store[iCount].first = \njudgeEdge\n(temp);\n            store[iCount].second = iWeight;\n        }\n        iPos = store[iCount].first;\n        iCount++;\n    }\n    cout << \n\"ç”ŸæˆPrimæœ€å°ç”Ÿæˆæ ‘ï¼\"\n<> pNumber;\n    cout << \n\"è¯·ä¾æ¬¡è¾“å…¥å„é¡¶ç‚¹çš„åç§°ï¼š\"\n << endl;\n    \nfor\n (\nint\n iX = \n0\n; iX < pNumber; iX++){\n        cin >> name;\n        pName.\npush_back\n(name);\n    }\n    cout << endl;\n}\n\nvoid\n \nMST::addEdge\n()\n{\n    string pA, pB;\n    \nint\n iA = \n0\n, iB = \n0\n;\n    map = \nnew\n \nint\n*[pNumber];\n    \nfor\n (\nint\n iX = \n0\n; iX < pNumber; iX++)\n        map[iX] = \nnew\n \nint\n[pNumber];\n\n    \nfor\n (\nint\n iX = \n0\n; iX < pNumber - \n1\n; iX++){\n        map[iX][iX] = \n0\n;\n        cout << \n\"è¯·è¾“å…¥ä¸¤ä¸ªé¡¶ç‚¹åŠè¾¹: \"\n;\n        \nfor\n (\nint\n iY = iX + \n1\n; iY < pNumber; iY++){ \n            iA = iB = \n0\n;\n            cin >> pA >> pB;\n            \nwhile\n (pA != pName[iA])   \n//æœç´¢è¾“å…¥ä¸¤ä¸ªé¡¶ç‚¹å¯¹åº”çš„ä½ç½®ï¼Œå¹¶å°†æƒèµ‹å€¼åˆ°å¯¹åº”çš„mapä¸­\n\n                iA++;\n            \nwhile\n (pB != pName[iB])\n                iB++;\n            cin >> map[iA][iB];\n            \nif\n (iY != pNumber - \n1\n)\n                cout << \n\"è¯·è¾“å…¥ä¸¤ä¸ªé¡¶ç‚¹åŠè¾¹: \"\n;\n        }\n    }\n    \nfor\n (\nint\n iX = \n0\n; iX < pNumber; iX++){\n        \nfor\n (\nint\n iY = \n0\n; iY < iX; iY++){\n            map[iX][iY] = map[iY][iX];\n        }\n    }\n    cout << endl;\n    \n}\n\nvoid\n \nMST::displayTree\n()\n{\n    string end;\n    string begin;\n    cout << \n\"æœ€å°ç”Ÿæˆæ ‘çš„çš„é¡¶ç‚¹åŠè¾¹ä¸ºï¼š\"\n << endl;\n    cout << endl;\n    cout << start << \n\"-<\"\n << store[\n0\n].second << \n\">-\"\n << \nfindPoint\n(store[\n0\n].first);\n    \nfor\n (\nint\n iX = \n1\n; iX < pNumber - \n1\n; iX++){\n        \nif\n (store[iX].second == map[store[iX].first][iX]){\n//å¦‚æœæœ€å°ç”Ÿæˆæ ‘æ²¡æœ‰åˆ†æ”¯\n\n            begin = \nfindPoint\n(store[iX - \n1\n].first);\n            end = \nfindPoint\n(store[iX].first);\n            cout << \n\"        \"\n << begin << \n\"-<\"\n << store[iX].second << \n\">-\"\n << end;\n        }\n        \nelse\n{\n//æœ€å°ç”Ÿæˆæ ‘å­˜åœ¨åˆ†æ”¯ï¼Œä¾æ®ç»ˆç‚¹å’Œæƒæ‰¾åˆ°å¯¹åº”çš„èµ·ç‚¹\n\n            \nint\n iStart = store[iX].second;\n            \nint\n iJ = \n0\n;\n            \nint\n iK = \n0\n;\n            \nbool\n flag = \nfalse\n;\n            \nfor\n (iJ = \n0\n; iJ < pNumber; iJ++){\n                \nfor\n (iK = \n0\n; iK < pNumber; iK++){\n                    \nif\n (map[iJ][iK] == iStart){\n                        flag = \ntrue\n;\n                        \nbreak\n;\n                    }\n                }\n                \nif\n (flag == \ntrue\n)\n                    \nbreak\n;\n            }\n            \nif\n (iK == store[iX].first){\n                begin = \nfindPoint\n(iJ);\n                end = \nfindPoint\n(iK);\n                cout << \n\"        \"\n << begin << \n\"-<\"\n << store[iX].second << \n\">-\"\n << end;\n            }\n            \nif\n (iJ == store[iX].first){\n                begin = \nfindPoint\n(iK);\n                end = \nfindPoint\n(iJ);\n                cout << \n\"        \"\n << begin << \n\"-<\"\n << store[iX].second << \n\">-\"\n << end;\n            }\n        }\n    }\n    cout << endl << endl;\n}\n\nstring \nMST::findPoint\n(\nint\n iPos)\n{\n    string point;\n    point = pName[iPos];\n    \nreturn\n point;\n}\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\"MST.h\"\n\n\nusing\n \nnamespace\n std;\n\nvoid\n \nmain\n()\n{\n    MST tree;\n    \nchar\n order;\n    cout << \n\"**                     é€šä¿¡ç½‘é€ ä»·æ¨¡æ‹Ÿç³»ç»Ÿ                     **\"\n << endl;\n    cout << \n\"==============================================================\"\n << endl;\n    cout << \n\"**                     A---åˆ›å»ºé€šä¿¡ç½‘é¡¶ç‚¹                     **\"\n << endl;\n    cout << \n\"**                     B---æ·»åŠ é€šä¿¡ç½‘çš„è¾¹                     **\"\n << endl;\n    cout << \n\"**                     C---æ„é€ æœ€å°ç”Ÿæˆæ ‘                   **\"\n << endl;\n    cout << \n\"**                     D---æ˜¾ç¤ºæœ€å°ç”Ÿæˆæ ‘                   **\"\n << endl;\n    cout << \n\"**                     E---é€€å‡º   ç¨‹åº                      **\"\n << endl;\n    cout << \n\"==============================================================\"\n << endl<> order;\n    \nwhile\n (order!=\n'E'\n){\n        \nswitch\n (order)\n        {\n        \ncase\n \n'A'\n:\n            tree.\ncreatePoint\n();\n            \nbreak\n;\n        \ncase\n \n'B'\n:\n            tree.\naddEdge\n();\n            \nbreak\n;\n        \ncase\n \n'C'\n:\n            tree.\ncreateTree\n();\n            \nbreak\n;\n        \ncase\n \n'D'\n:\n            tree.\ndisplayTree\n();\n        \ndefault\n:\n            \nbreak\n;\n        }\n        cout << \n\"è¯·é€‰æ‹©æ“ä½œï¼š\"\n;\n        cin >> order;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n```", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "[http://www.cnblogs.com/hxsyl/p/3286956.html](http://www.cnblogs.com/hxsyl/p/3286956.html \"\")", "Konwledge_Point": "æœ€å°ç”Ÿæˆæ ‘", "Question": "å¦‚ä½•åœ¨å…‹é²æ–¯å¡å°”ä¸­åŠ å…¥å¹¶æŸ¥é›†çš„è¿ç”¨\nåœ¨è¿ç”¨å…‹é²æ–¯å¡å°”ç®—æ³•æ±‚æœ€å°ç”Ÿæˆæ ‘æ—¶å¦‚ä½•å°†å¹¶æŸ¥é›†çš„ç›¸å…³å†…å®¹ä¹Ÿè¿ç”¨è¿›å»ï¼Ÿç¬¬ä¸€æ¬¡å‘é—®ï¼Œè¯·å¤§å®¶ç»™åŠ›ç‚¹ï¼", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "ä¸€ä¸ªäººæç¡®å®æœ‰éš¾åº¦ï¼Œå»ºè®®å’Œè€å¸ˆåŒå­¦å¤šäº¤æµï¼Œå‚åŠ ä¸€äº›ç›¸å…³çš„æ¯”èµ›ï¼Œç§¯ç´¯ç»éªŒ", "Konwledge_Point": "æœ€å°ç”Ÿæˆæ ‘", "Question": "æƒ³é—®ä¸‹åšé¡¹ç›®æ˜¯å•¥æ„æ€\nç›®å‰å­¦å®Œäº†cï¼Œæ•°æ®ç»“æ„ä¸ç®—æ³•å­¦åˆ°äº†å›¾çš„æœ€å°ç”Ÿæˆæ ‘ï¼ŒåŠ›æ‰£ä¹Ÿåˆ·äº†äº”å…­åé“é¢˜äº†ï¼Œå¬è¯´åšé¡¹ç›®æå‡å¿«ï¼Œä½†ç°åœ¨è¿˜æ²¡è§è¿‡é¡¹ç›®ï¼Œä¹Ÿä¸çŸ¥é“å’‹æ‰¾é¡¹ç›®ï¼Œæœ‰å¤§ä½¬èƒ½æŒ‡å¯¼ä¸‹å—ğŸ˜‚", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "\n\n#include<bits/stdc++.h>\n#define NUM 6\nusing namespace std;\n\n//åˆ©ç”¨äºŒç»´æ•°ç»„åˆ›å»ºæœ‰å‘å›¾çš„é‚»æ¥çŸ©é˜µ\nvoid CreateMatrix(int mat[NUM][NUM]);\n//åˆ©ç”¨Primç®—æ³•æ±‚è§£æœ€å°ç”Ÿæˆæ ‘\nvoid DijkstraSearch(int mat[NUM][NUM], int i, int visit[NUM], int dist[NUM], int path[NUM]);\n\nint main()\n{\n    //åˆ›å»ºæœ‰å‘å›¾çš„å¸¦æœ‰æƒå€¼çš„é‚»æ¥çŸ©é˜µ\n    int mat[NUM][NUM];\n    for (int i = 0; i < NUM;i++)\n    {\n        for (int j = 0; j < NUM;j++)\n        {\n            mat[i][j] = INT_MAX;\n        }\n    }\n    CreateMatrix(mat);\n    int visit[NUM] = {0};\n    int dist[NUM];\n    for (int i = 0; i < NUM;i++)\n    {\n        dist[i] = INT_MAX;\n    }\n    int path[NUM] = {0};\n\n    //åˆ©ç”¨Primç®—æ³•æ±‚è§£æœ€å°ç”Ÿæˆæ ‘\n    //åˆå§‹æºç‚¹çš„diståˆå§‹åŒ–ä¸º0ï¼Œpathåˆå§‹åŒ–ä¸º0\n    dist[0] = 0;\n    path[0] = 0;\n    DijkstraSearch(mat,0,visit,dist,path);\n\n    //è¾“å‡ºæœ€å°ç”Ÿæˆæ ‘çš„è¾¹åŠç›¸åº”æƒå€¼ï¼Œæ€»æƒå€¼\n    int totalValue = 0;\n    for (int i = 1; i < NUM;i++)\n    {\n        totalValue += dist[i];\n        printf(\"æœ€å°ç”Ÿæˆæ ‘çš„è¾¹ï¼š<v%d , v%d>\",(i+1),(path[i]+1));\n        printf(\" æƒå€¼ï¼š%d\",dist[i]);\n        printf(\"\\n\");\n    }\n    printf(\"æœ€å°ç”Ÿæˆæ ‘çš„æ€»æƒå€¼ï¼š%d\",totalValue);\n    printf(\"\\n\");\n\n    return 0;\n}\n\n\n//åˆ©ç”¨äºŒç»´æ•°ç»„åˆ›å»ºæœ‰å‘å›¾çš„é‚»æ¥çŸ©é˜µï¼Œå¸¦æƒå€¼\nvoid CreateMatrix(int mat[NUM][NUM])\n{\n    mat[0][1] = 4;\n    mat[0][2] = 2;\n\n    mat[1][0] = 4;\n    mat[1][2] = 5;\n    mat[1][3] = 5;\n    mat[1][4] = 9;\n\n    mat[2][0] = 2;\n    mat[2][1] = 5;\n    mat[2][3] = 6;\n\n    mat[3][1] = 5;\n    mat[3][2] = 6;\n    mat[3][4] = 7;\n    mat[3][5] = 6;\n\n    mat[4][1] = 9;\n    mat[4][3] = 7;\n    mat[4][5] = 3;\n\n    mat[5][3] = 6;\n    mat[5][4] = 3;\n}\n\n//åˆ©ç”¨Primç®—æ³•æ±‚è§£æœ€å°ç”Ÿæˆæ ‘\nvoid DijkstraSearch(int mat[NUM][NUM], int i, int visit[NUM], int dist[NUM], int path[NUM])\n{\n    //åˆå§‹åŒ–\n    visit[i] = 1;\n    //dist[i] = 0;\n    //path[i]=0;\n\n    //è®¿é—®ä¸é¡¶ç‚¹iç›¸é‚»æ¥çš„æœªè¢«è®¿é—®çš„é¡¶ç‚¹ï¼Œè·å–è·¯å¾„é•¿åº¦ï¼Œå¦‚æœå°äºä¹‹å‰è·¯å¾„é•¿åº¦åˆ™æ›¿æ¢ï¼Œå¹¶è®°å½•è·¯å¾„\n    for (int j = 0; j < NUM;j++)\n    {\n        if (visit[j] == 0 && mat[i][j] != INT_MAX)\n        {\n            if (mat[i][j]<dist[j])\n            {\n                dist[j] = mat[i][j];\n                path[j] = i;\n            }\n        }\n    }\n\n    //åœ¨æœªè¢«è®¿é—®è¿‡çš„é¡¶ç‚¹ä¸­å¯»æ‰¾è·¯å¾„æœ€çŸ­çš„é¡¶ç‚¹\n    int minDist = -1;\n    for (int m = 0;m<NUM;m++)\n    {\n        if (visit[m] == 0)\n        {\n            minDist = m;\n            break;\n        }\n    }\n    for (int k = minDist + 1; k<NUM; k++)\n    {\n        if (visit[k] == 0 && dist[k]<dist[minDist])\n        {\n            minDist = k;\n        }\n\n    }\n    //å¦‚æœæ‰¾åˆ°ç»§ç»­å¯»æ‰¾åˆ°ä¸‹ä¸€ä¸ªé¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ï¼ˆé€’å½’ï¼‰\n    if (minDist != -1)\n    {\n        DijkstraSearch(mat, minDist, visit, dist, path);\n    }\n}\n\n", "Konwledge_Point": "æœ€å°ç”Ÿæˆæ ‘", "Question": "æ±‚ä¸‹é¢é—®é¢˜çš„å®Œæ•´ç­”æ¡ˆï¼Œå›¾åœ¨é“¾æ¥é‡Œ\nå·²çŸ¥é¡¶ç‚¹é›†åˆ{a,b,c,d,e,f}ï¼Œæ„æˆçš„æ— å‘å›¾çš„å¸¦æƒé‚»æ¥çŸ©é˜µå¦‚ä¸‹ï¼š\nhttps://cg.sau.edu.cn/userfiles/image/1483599133822034852.png\nâ‘ Â ç”»å‡ºæ— å‘å¸¦æƒå›¾ï¼›Â Â Â \nâ‘¡Â ç»™å‡ºæ— å‘å¸¦æƒå›¾çš„æœ€å°ç”Ÿæˆæ ‘ï¼›", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "ä½ çš„toStringæ–¹æ³•é‡Œé€’å½’è°ƒç”¨äº†,æ­»å¾ªç¯å‡ºä¸æ¥äº†...\r\nè¿™æ˜¯AbstractMapçš„toStringæ–¹æ³•:\r\n\r\npublic String toString() {\r\n\tIterator> i = entrySet().iterator();\r\n\tif (! i.hasNext())\r\n\t    return \"{}\";\r\n\r\n\tStringBuilder sb = new StringBuilder();\r\n\tsb.append('{');\r\n\tfor (;;) {\r\n\t    Entry e = i.next();\r\n\t    K key = e.getKey();\r\n\t    V value = e.getValue();\r\n\t    sb.append(key   == this ? \"(this Map)\" : key);\r\n\t    sb.append('=');\r\n\t    sb.append(value == this ? \"(this Map)\" : value);\r\n\t    if (! i.hasNext())\r\n\t\treturn sb.append('}').toString();\r\n\t    sb.append(\", \");\r\n\t}\r\n    }\r\n\r\nç”±äºä½ çš„Mapé‡ŒKeyè¿˜æ˜¯Cityå¯¹è±¡,æ‰€ä»¥æ‰§è¡ŒMapçš„toStringæ—¶è¿™ä¸€è¡Œ sb.append(key   == this ? \"(this Map)\" : key);ä¼šè‡ªåŠ¨è°ƒç”¨keyçš„toStringæ–¹æ³•,è¿™æ ·åˆè¿›å…¥äº†Cityçš„toStringæ–¹æ³•,ç„¶åå°±æŒ‚äº†.....", "Konwledge_Point": "æœ€å°ç”Ÿæˆæ ‘", "Question": "StackOverflowErrorå¼‚å¸¸ï¼Œå“ªä½å¥½å¿ƒäººçœ‹çœ‹å•Š\nÂ  Â æ‰“ç®—ç”¨é¢å‘å¯¹è±¡æ€æƒ³ï¼Œå†™ä¸ªæ±‚æœ€å°ç”Ÿæˆæ ‘é—®é¢˜ã€‚å†™äº†ä¸€åŠï¼Œå°±å‡ºç°é—®é¢˜äº†import java.util.HashMap;\n\n\n\npublic class City {\n    private String cityName; \n\n    private HashMap adjCities = new HashMap(); \n\n    public City(String cityName) {\n        this.cityName = cityName;\n\n    }\n\n    public void addAjdCity(City city, double cost) {\n        adjCities.put(city, cost);\n        // System.out.println(\"test1\");\n        city.adjCities.put(this, cost);\n        // System.out.println(\"test2\");\n\n    }\n\n    public void removeAjdCity(City city) {\n\n    }\n\n    public void removeAjdCity(String cityName) {\n\n    }\n\n    public String toString() {\n        return cityName + \":\" + \"\\n\" + adjCities;\n    }\n\n    public static void main(String[] args) {\n        City c1 = new City(\"ä¸Šæµ·\");\n        City c2 = new City(\"æ­å·\");\n\n        c1.addAjdCity(c2, 100);\n        // æ€ä¹ˆè¾“å‡ºc1 c2æ—¶ä¼šå‡ºé—®é¢˜ï¼ŸStackOverflowErrorå¼‚å¸¸ã€‚å¦‚æœæŠŠæœ€åä¸¤å¥printlnæ³¨é‡Šæ‰ï¼Œå°±ä¸ä¼šæŠ¥é”™ï¼Ÿï¼Ÿ\n        System.out.println(c1);\n        System.out.println(c2);\n\n    }\n\n}\n", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "å°±æ˜¯å°†ä¸‹æ ‡ä¸ºkçš„é¡¶ç‚¹å„è¾¹æƒå€¼å°äºæ­¤å‰è¿™äº›é¡¶ç‚¹æœªè¢«åŠ å…¥çš„ç”Ÿæˆæ ‘æƒå€¼", "Konwledge_Point": "æœ€å°ç”Ÿæˆæ ‘", "Question": "å°ç™½æ±‚æ•™ï¼Œè¯·é—®**éƒ¨åˆ†æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿ\n//Primç®—æ³•æœ€å°ç”Ÿæˆæ ‘\n\nvoid MiniSpanTree_Prime(Graph g)\n\n{\n\n    int min, i, j, k;\n\n    int adjvex[MAXVEX];         //ä¿å­˜ç›¸å…³é¡¶ç‚¹ä¸‹æ ‡\n\n    int lowcost[MAXVEX];        //ä¿å­˜ç›¸å…³é¡¶ç‚¹é—´è¾¹çš„æƒå€¼\n\n    lowcost[0] = 0;             //åˆå§‹åŒ–ç¬¬ä¸€ä¸ªæƒå€¼ä¸º0ï¼Œå³v0åŠ å…¥ç”Ÿæˆæ ‘  \n\n\n\nadjvex[0] = 0;              //åˆå§‹åŒ–ç¬¬ä¸€ä¸ªé¡¶ç‚¹ä¸‹æ ‡ä¸º0  \nfor(i = 1; i < g.numVertexes; i++)  \n{  \n    //å¾ªç¯é™¤ä¸‹æ ‡ä¸º0å¤–çš„å…¨éƒ¨é¡¶ç‚¹  \n    lowcost[i] = g.arc[0][i];   //å°†v0é¡¶ç‚¹ä¸ä¹‹æœ‰è¾¹çš„æƒå€¼å­˜å…¥æ•°ç»„  \n    adjvex[i] = 0;              //åˆå§‹åŒ–éƒ½ä¸ºv0ä¸‹æ ‡  \n}  \nfor(i = 1; i < g.numVertexes; i++)  \n{  \n    min = INFINITY;             //åˆå§‹åŒ–æœ€å°æƒå€¼ä¸ºæ— ç©·å¤§  \n    j = 1;  \n    k = 0;  \n    while(j < g.numVertexes) //å¾ªç¯å…¨éƒ¨é¡¶ç‚¹  \n    {  \n        //å¦‚æœæƒå€¼ä¸ä¸º0,ä¸”æƒå€¼å°äºmin  \n        if(lowcost[j] != 0 && lowcost[j] < min)  \n        {  \n            min = lowcost[j];       //åˆ™è®©å½“å‰æƒå€¼æˆä¸ºæœ€å°å€¼  \n            k = j;                  //å°†å½“å‰æœ€å°å€¼çš„ä¸‹æ ‡å­˜å…¥k  \n        }  \n        j++;  \n    }  \n    printf(\"(%d,%d)\", adjvex[k], k);//æ‰“å°å½“å‰é¡¶ç‚¹è¾¹ä¸­æƒå€¼æœ€å°è¾¹  \n    lowcost[k] = 0;                 //å°†å½“å‰é¡¶ç‚¹çš„æƒå€¼è®¾ç½®ä¸º0ï¼Œè¡¨ç¤ºæ­¤é¡¶ç‚¹å·²ç»å®Œæˆä»»åŠ¡  \n\n    for(j = 1; j < g.numVertexes; j++)//å¾ªç¯æ‰€æœ‰é¡¶ç‚¹  \n    {  \n        if(lowcost[j] != 0 && g.arc[k][j] < lowcost[j])  \n        {  \n          **  //è‹¥ä¸‹æ ‡ä¸ºkçš„é¡¶ç‚¹å„è¾¹æƒå€¼å°äºæ­¤å‰è¿™äº›é¡¶ç‚¹æœªè¢«åŠ å…¥çš„ç”Ÿæˆæ ‘æƒå€¼ ** \n            lowcost[j] = g.arc[k][j];  \n            adjvex[j] = k;         //å°†ä¸‹æ ‡ä¸ºkçš„é¡¶ç‚¹å­˜å…¥adjvex  \n        }  \n    }  \n}  \nprintf(\"\\n\");  \n\n\n\n\n}", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "é”™è¯¯åœ¨è¿™è¡Œï¼š\r\n```\r\nMiniSpanTree_Prim(AdjMatrix &gn,char u)/*ä»é¡¶ç‚¹uå‡ºå‘ï¼ŒæŒ‰æ™®é‡Œå§†ç®—æ³•æ„é€ è¿é€šç½‘gnçš„æœ€å°ç”Ÿæˆæ ‘ï¼Œå¹¶è¾“å‡ºç”Ÿæˆæ ‘çš„æ¯æ¡è¾¹*/\r\n{int i,e;\r\n.....\r\n```\r\n\r\n\r\n\r\n\r\nMiniSpanTree_Primå‡½æ•°å®šä¹‰æ—¶ï¼Œåº”æ˜ç¡®è¿”å›å€¼ç±»å‹ã€‚\r\nå‡è®¾è¯¥å‡½æ•°æ— è¿”å›å€¼ï¼Œä¹Ÿåº”è¯¥å®šä¹‰æˆ:\r\n\r\n\r\n\r\n```\r\nvoid MiniSpanTree_Prim(AdjMatrix &gn,char u){\r\n......\r\n}\r\n```\r\n\r\n**ç”¨å¿ƒå›ç­”æ¯ä¸ªé—®é¢˜ï¼Œå¦‚æœå¯¹æ‚¨æœ‰å¸®åŠ©ï¼Œè¯·é‡‡çº³ç­”æ¡ˆå¥½å—ï¼Œè°¢è°¢ï¼**", "Konwledge_Point": "æœ€å°ç”Ÿæˆæ ‘", "Question": "æ•°æ®ç»“æ„å…³äºå›¾çš„å°é”™è¯¯\n#include\n\n#include\n\n#define Infinity 32768\n\n#define OK 1\n\n#define Error -1\n\n#define True 1\n\n#define False 0\n\n#define MAX_VERTEX_NUM 10\n\ntypedef enum{DG,DN,UDG,UDN}GraphKind;      /*å›¾çš„ç§ç±»åˆ†åˆ«ä¸ºæœ‰å‘å›¾ï¼Œæœ‰å‘ç½‘ï¼Œæ— å‘å›¾ï¼Œæ— å‘ç½‘*/\n\ntypedef char VertexData;\n\ntypedef struct ArcNode\n\n{int adj;\n\n\n\n}ArcNode;\n\ntypedef struct \n\n{VertexData vertex[MAX_VERTEX_NUM];\n\n ArcNode arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM];\n\n int vexnum,arcnum;                       /*å›¾çš„é¡¶ç‚¹æ•°å’Œå¼§æ•°*/\n\n GraphKind kind;\n\n}AdjMatrix;\n\nstruct Record{\n\n     char  adjvex;  // Ué›†ä¸­çš„é¡¶ç‚¹\n\n     int   lowcost;  // è¾¹çš„æƒå€¼\n\n}closedge[MAX_VERTEX_NUM];\n\nint LocateVertex(AdjMatrix \nG,VertexData v)/\næ±‚é¡¶ç‚¹ä½ç½®å‡½æ•°*/\n\n{int j=Error,k;\n\n for(k=0;kvexnum;k++)\n\n  if(G->vertex[k]==v)\n\n   {j=k;break;\n\n   }\n\n   return(j);\n\n}\n\nint CreateDN(AdjMatrix \nG)             /\nåˆ›å»ºä¸€ä¸ªæœ‰å‘ç½‘*/\n\n{int i,j,k,weight;VertexData v1,v2;\n\n printf(\"è¯·è¾“å…¥ä¸¤ä¸ªæ•°å­—è¡¨ç¤ºå¼§æ•°å’Œé¡¶ç‚¹æ•°\\n\");\n\n fflush(stdin);                         /*æ¸…ç©ºè¾“å…¥ç¼“å†²åŒº*/ \n\n scanf(\"%d,%d\",&G->arcnum,&G->vexnum);\n\n for(i=0;ivexnum;i++)               /*åˆå§‹åŒ–é‚»æ¥çŸ©é˜µ*/\n\n  for(j=0;jvexnum;j++)\n\n   G->arcs[i][j].adj=Infinity;\n\n for(i=0;ivexnum;i++)\n\n  printf(\"è¯·è¾“å…¥å›¾çš„é¡¶ç‚¹\\n\");\n\n  fflush(stdin);\n\n  scanf(\"%c\",&G->vertex[i]);\n\n for(k=0;karcnum;k++)\n\n {printf(\"è¯·è¾“å…¥ä¸€æ¡å¼§çš„ä¸¤ä¸ªé¡¶ç‚¹åŠæƒå€¼\\n\");\n\n  fflush(stdin);\n\n  scanf(\"%c,%c,%d\",&v1,&v2,&weight);\n\n  i=LocateVertex(G,v1);\n\n  j=LocateVertex(G,v2);\n\n  G->arcs[i][j].adj=weight;              /*å»ºç«‹å¼§*/\n\n }\n\n return(OK);\n\n}\n\nint Minimum (Record closedge[])\n\n{int reserve=Infinity;\n\n int min;\n\n for(int i=1;i\n {\n\n   if(closedge[i].lowcost0)//æ²¡æœ‰è®¿é—®è¿‡ä½†æ˜¯å­˜è·¯å¾„\n\n    {\n\n      reserve=closedge[i].lowcost;\n\n      min=i;\n\n    }\n\n   }\n\n return min;\n\n}\n\nMiniSpanTree_Prim(AdjMatrix &gn,char u)/*ä»é¡¶ç‚¹uå‡ºå‘ï¼ŒæŒ‰æ™®é‡Œå§†ç®—æ³•æ„é€ è¿é€šç½‘gnçš„æœ€å°ç”Ÿæˆæ ‘ï¼Œå¹¶è¾“å‡ºç”Ÿæˆæ ‘çš„æ¯æ¡è¾¹*/\n\n{int i,e;\n\n closedge[u].lowcost=0;              /*åˆå§‹åŒ–ï¼ŒU={u}*/\n\n for(i=0;i<gn.vexnum;i++)\n\n      if(i!=u)                        /*å¯¹V-Uä¸­çš„é¡¶ç‚¹iï¼Œåˆå§‹åŒ–closedge[i]*/\n\n      {closedge[i].adjvex=u;\n\n       closedge[i].lowcost=gn.arcs[u][i].adj;\n\n      }\n\n for(e=1;e<=gn.vexnum-1;e++)          /*æ‰¾n-1æ¡è¾¹ï¼ˆn=gn.vexnum*/\n\n {int v=Minimum(closedge);            /*closedge[v]ä¸­å­˜æœ‰å½“å‰æœ€å°è¾¹ï¼ˆuï¼Œvï¼‰çš„ä¿¡æ¯*/\n\n  u=closedge[v].adjvex;               /*uå±äºU*/\n\n  printf(\"%c,%c\",u,v);                /*è¾“å‡ºç”Ÿæˆæ ‘çš„å½“å‰æœ€å°è¾¹ï¼ˆuï¼Œvï¼‰*/\n\n  closedge[v].lowcost=0;              /*å°†é¡¶ç‚¹vçº³å…¥Uçš„é›†åˆ*/\n\n  for(i=0;i<gn.vexnum;i++)            /*åœ¨é¡¶ç‚¹vå¹¶å…¥Uä¹‹åï¼Œæ›´æ–°closedge[i]*/\n\n      if(gn.arcs[v][i].adj<closedge[i].lowcost)\n\n      {closedge[i].lowcost=gn.arcs[v][i].adj;\n\n       closedge[i].adjvex=v;\n\n      }\n\n }\n\n}\n\nint main()\n\n{AdjMatrix G;\n\n CreateDN(&G);\n\n char first=' ';\n\n printf(\"è¯·è¾“å…¥ç¬¬ä¸€ä¸ªè®¿é—®çš„ç»“ç‚¹\\n\");\n\n scanf(\"%c\",&first);\n\n MiniSpanTree_Prim(G,first) ;\n\n return 0;\n\n}\n\nå‡ºç°è¿™ä¸ªé”™è¯¯\\Users\\Administrator\\Desktop\\3.2.cpp 69 C:\\Users\\Administrator\\Desktop\\C [Error] ISO C++ forbids declaration of `MiniSpanTree_Prim' with no type ", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "def mctFromLeafValues( arr):\n    res = 0\n    while len(arr) > 1:\n        min_val = min(arr)\n        idx = arr.index(min_val)\n        if idx > 0 and idx < len(arr) - 1: #æœ‰å·¦æœ‰å³\n            left_val, right_val = arr[idx - 1], arr[idx + 1]\n        elif idx == len(arr) - 1: #æœ‰å·¦æ²¡å³\n            left_val, right_val = arr[idx - 1], 16 #ä¸ºä»€ä¹ˆæ˜¯16ï¼Ÿå› ä¸ºæœ€å¤§åªæœ‰15\n        elif idx == 0: #æœ‰å³æ²¡å·¦\n            left_val, right_val = 16, arr[idx + 1]\n            \n        res += min(min_val * left_val, min_val * right_val)\n        arr.remove(min_val) #æŠŠå½“å‰æœ€å°å€¼åˆ æ‰ï¼Œå·²ç»ç”¨å®Œäº†\n    return res\narr = [5,1,4]\nprint(mctFromLeafValues(arr))\n", "Konwledge_Point": "æœ€å°ç”Ÿæˆæ ‘", "Question": "pythonåˆ†æ”¯é™ç•Œç®—æ³•\nç”¨pythonè¯­è¨€å®ç°æœ€å°ä»£ä»·ç”Ÿæˆæ ‘é—®é¢˜ï¼Œåˆ©ç”¨åˆ†æ”¯é™ç•Œç®—æ³•python", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "      def mctFromLeafValues(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        res = 0\n        while len(arr) > 1:\n            min_val = min(arr)\n            idx = arr.index(min_val)\n            if idx > 0 and idx < len(arr) - 1: #æœ‰å·¦æœ‰å³\n                left_val, right_val = arr[idx - 1], arr[idx + 1]\n            elif idx == len(arr) - 1: #æœ‰å·¦æ²¡å³\n                left_val, right_val = arr[idx - 1], 16 #ä¸ºä»€ä¹ˆæ˜¯16ï¼Ÿå› ä¸ºæœ€å¤§åªæœ‰15\n            elif idx == 0: #æœ‰å³æ²¡å·¦\n                left_val, right_val = 16, arr[idx + 1]\n                \n            res += min(min_val * left_val, min_val * right_val)\n            arr.remove(min_val) #æŠŠå½“å‰æœ€å°å€¼åˆ æ‰ï¼Œå·²ç»ç”¨å®Œäº†\n        return res\n", "Konwledge_Point": "æœ€å°ç”Ÿæˆæ ‘", "Question": "pythonåˆå­¦è€…ï¼Œé—®ä¸€ä¸ªç®€å•çš„åˆ†æ”¯é™ç•Œç®—æ³•\nç”¨pythonè¯­è¨€å®ç°â€œæœ€å°ä»£ä»·ç”Ÿæˆæ ‘â€é—®é¢˜çš„åˆ†æ”¯é™ç•Œç®—æ³•\næ±‚è§£ç­”â€¦â€¦", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "ç½‘ä¸Šå¾ˆå¤šåŸé¢˜è§£æï¼š\nå“ˆå¤«æ›¼æ ‘ - ä¹åº¦æ•™ç¨‹ç¬¬30é¢˜_Yoc Luçš„åšå®¢-CSDNåšå®¢\nå“ˆå¤«æ›¼æ ‘ - ä¹åº¦æ•™ç¨‹ç¬¬30é¢˜é¢˜ç›®æ—¶é—´é™åˆ¶ï¼š1 ç§’ å†…å­˜é™åˆ¶ï¼š32 å…† ç‰¹æ®Šåˆ¤é¢˜ï¼šå¦é¢˜ç›®æè¿°ï¼šå“ˆå¤«æ›¼æ ‘ï¼Œç¬¬ä¸€è¡Œè¾“å…¥ä¸€ä¸ªæ•°nï¼Œè¡¨ç¤ºå¶ç»“ç‚¹çš„ä¸ªæ•°ã€‚éœ€è¦ç”¨è¿™äº›å¶ç»“ç‚¹ç”Ÿæˆå“ˆå¤«æ›¼æ ‘ï¼Œæ ¹æ®å“ˆå¤«æ›¼æ ‘çš„æ¦‚å¿µï¼Œè¿™äº›ç»“ç‚¹æœ‰æƒå€¼ï¼Œå³weightï¼Œé¢˜ç›®éœ€è¦è¾“å‡ºæ‰€æœ‰ç»“ç‚¹çš„å€¼ä¸æƒå€¼çš„ä¹˜ç§¯ä¹‹å’Œã€‚è¾“å…¥ï¼šè¾“å…¥æœ‰å¤šç»„æ•°æ®ã€‚æ¯ç»„ç¬¬ä¸€è¡Œè¾“å…¥ä¸€ä¸ªæ•°nï¼Œæ¥ç€è¾“å…¥nä¸ªå¶èŠ‚ç‚¹ï¼ˆå¶èŠ‚ç‚¹æƒå€¼ä¸è¶…è¿‡100ï¼Œ2&amp;lt;=n&amp;lt;=10...\n\n\n\nhttps://blog.csdn.net/LYKXHTP/article/details/88316879\n\n", "Konwledge_Point": "æœ€å°ç”Ÿæˆæ ‘", "Question": "æ„é€ å“ˆå¤«æ›¼æ ‘ä»¥åŠè®¡ç®—å¸¦æƒè·¯å¾„é•¿åº¦\n7-1 å“ˆå¤«æ›¼æ ‘\nåˆ†æ•° 15\nä½œè€… æå»·å…ƒ\nå•ä½ ä¸­å›½æ°‘ç”¨èˆªç©ºé£è¡Œå­¦é™¢\nå“ˆå¤«æ›¼æ ‘ï¼Œç¬¬ä¸€è¡Œè¾“å…¥ä¸€ä¸ªæ•°nï¼Œè¡¨ç¤ºå¶ç»“ç‚¹çš„ä¸ªæ•°ã€‚\n\n\néœ€è¦ç”¨è¿™äº›å¶ç»“ç‚¹ç”Ÿæˆå“ˆå¤«æ›¼æ ‘ï¼Œæ ¹æ®å“ˆå¤«æ›¼æ ‘çš„æ¦‚å¿µï¼Œè¿™äº›ç»“ç‚¹æœ‰æƒå€¼ï¼Œå³weightï¼Œé¢˜ç›®éœ€è¦è¾“å‡ºå“ˆå¤«æ›¼æ ‘çš„å¸¦æƒè·¯å¾„é•¿åº¦ï¼ˆWPLï¼‰ã€‚\n\n\nè¾“å…¥æ ¼å¼:\nç¬¬ä¸€è¡Œè¾“å…¥ä¸€ä¸ªæ•°nï¼Œç¬¬äºŒè¡Œè¾“å…¥nä¸ªå¶ç»“ç‚¹ï¼ˆå¶ç»“ç‚¹æƒå€¼ä¸è¶…è¿‡1000ï¼Œ2<=n<=1000ï¼‰ã€‚\n\n\nè¾“å‡ºæ ¼å¼:\nåœ¨ä¸€è¡Œä¸­è¾“å‡ºWPLå€¼ã€‚\n\n\nè¾“å…¥æ ·ä¾‹:\n5\n1 2 2 5 9\nè¾“å‡ºæ ·ä¾‹:\n37\n\n\næˆ‘çš„é—®é¢˜ï¼š\næˆ‘ä»¬è€å¸ˆä¸Šè¯¾è®²è§£è¿‡å¦‚ä½•æ„é€ å“ˆå¤«æ›¼æ ‘è¿™æ˜¯æ–¹æ³•ï¼š\nç»“ç‚¹ç»“æ„å¦‚ä¸‹ã€‚\n\n\ndefine MAXBIT 10\ndefine MAXVALUE 1000\ntypedef struct HNode /å®šä¹‰ç»“ç‚¹ç»“æ„/\n{ int weight;\nint parent , lchild , rchild;\n}HNode, *HTree;\n\n\nHTree HuffmanTree( int w , int n) /ç»™å®šnä¸ªæƒå€¼æ„é€ å“ˆå¤«æ›¼æ ‘/\n{ / wå­˜å‚¨nä¸ªå­—ç¬¦çš„æƒå€¼ï¼Œæ„é€ å“ˆå¤«æ›¼æ ‘HT*/\nint m, m1, m2, x1, x2, i, j; HTree ht;\nHNode *p;\nif (n <= 1) return NULL;\nm= 2*n-1;\nht = (HNode *)malloc (m*sizeof(HNode) ); /*å“ˆå¤«æ›¼æ ‘çš„æ„é€ */\nif(ht==NULL) return ht;\nfor(p = ht, i =0; i < n; ++ i, ++ p, ++w) /*åˆå§‹åŒ–å¶å­ç»“ç‚¹ä¿¡æ¯*/\n{ p->weight = *w; p->lchild = -1;\np->rchild = -1; p->parent = -1;\n}\nfor( ; i < m; ++ i, ++ p) /*åˆå§‹åŒ–åˆ†æ”¯ç»“ç‚¹ä¿¡æ¯*/\n{ p->weight = 0; p->lchild = -1;\np->rchild = -1; p->parent = -1;\n}\nfor( i = n; i < m; ++ i) /*æ„é€ å“ˆå¤«æ›¼æ ‘ */\n{ m1 = m2 = MAXVALUE;\nx1 = x2 = 0; /å¯»æ‰¾parentä¸º-1ä¸”æƒå€¼æœ€å°çš„ä¸¤æ£µå­æ ‘/\nfor(j = 0; j < i; ++ j)\n{ if( ht[j].parent == -1 && ht[j].weight < m1)\n{ m2 = m1; x2 = x1; m1 = ht[j].weight; x1 = j; }\nelse if( ht[j].parent == -1 && ht[j].weight < m2)\n{ m2 = ht[j].weight; x2 = j; }\n}\n/åˆå¹¶æˆä¸€æ£µæ–°çš„å­æ ‘/\nht[x1].parent = i; ht[x2].parent = i;\nht[i].lchild = x1; ht[i].rchild = x2;\nht[i].weight = m1 + m2;\n}\nreturn ht;\n}\nè¯´å®è¯çœ‹çš„æœ‰çš„äº‘é‡Œé›¾é‡Œçš„èƒ½ä¸èƒ½ç”¨ä¸­æ–‡æè¿°ä¸‹æ€è·¯\nè€Œä¸”é¢˜ä¸­è¦è®©æ±‚æœ€çŸ­è·¯å¾„é•¿åº¦ï¼Œæˆ‘è¿™ä¸Šé¢åªæœ‰æ„é€ å“ˆå¤«æ›¼æ ‘è¿™ä¸€å—ï¼Œæ±‚è§£æœ€çŸ­è·¯å¾„é•¿åº¦è¿™å—æœ‰ç‚¹ä¸çŸ¥é“å¦‚ä½•ä¸‹æ‰‹ï¼Œè¿˜æœ‰ä¸»å‡½æ•°ä¹Ÿä¸å¤ªçŸ¥é“å’‹å†™ï¼Œå¸Œæœ›èƒ½åŒæ—¶æä¾›è§£é¢˜æ€è·¯ä»¥åŠå®Œæ•´è¿è¡Œç»“æœï¼Œæ„Ÿè°¢æ„Ÿè°¢ï¼Œå› ä¸ºåŸºç¡€å¤ªå·®äº†ï¼Œæˆ‘å°±ç®—çŸ¥é“æ€è·¯è‡ªå·±ä¹Ÿæ‰“ä¸å‡ºæ¥ï¼Œç­”æ¡ˆé”™è¯¯çœ‹åŠå¤©ä¹Ÿæ‰¾ä¸å‡ºé”™è¯¯ï¼Œè¾›è‹¦", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "åœ¨åŠ¨æ€åˆ›å»ºçš„è¿‡ç¨‹ä¸­ï¼Œæ€»æ˜¯å‡ºç°æœªåˆ©ç”¨çš„ç©ºé—´å‡ºç°ä¹±ç ã€‚é€šè¿‡ä¸“é—¨å»ºç«‹ä¸€ä¸ªå˜é‡æ¥ç»Ÿè®¡ç”¨åˆ°çš„æ•°ç»„é•¿åº¦ï¼Œå¯ä»¥è§£å†³äº†è¿™ä¸ªé—®é¢˜ã€‚", "Konwledge_Point": "æœ€å°ç”Ÿæˆæ ‘", "Question": "å“ˆå¤«æ›¼æ ‘æ„é€ è¿‡ç¨‹ä¸­å‡ºç°ä¹±ç ï¼Ÿ\nç¨‹åºæ˜¯æ ¹æ®ç”¨æˆ·è¾“å…¥çš„ä¸€äº›åˆ—å­—ç¬¦åŠå…¶å¯¹åº”çš„æƒå€¼ï¼Œç”Ÿæˆå“ˆå¤«æ›¼æ ‘ï¼Œå†æ ¹æ®ç”Ÿæˆçš„å“ˆå¤«æ›¼æ ‘è¿›è¡Œç¼–ç ï¼Œåœ¨æµ‹è¯•æ—¶ï¼Œå‘ç°è¾“å‡ºæ¯ä¸ªå…ƒç´ å¯¹åº”çš„å“ˆå¤«æ›¼ç¼–ç æ—¶ï¼Œæ€»ä¼šå‡ºç°ä¸€äº›ä¹±ç çš„æ–‡å­—ï¼ŒçŸ¥é“åŸå› çš„ç½‘å‹ç‚¹æ‹¨ä¸€äº›ï¼Œè°¢è°¢ã€‚ç¨‹åºå¦‚ä¸‹ï¼š\n\n\n\n #include \n#include\nusing namespace std;\nclass HuffNode\n{\npublic:\n    char c;  // ç»“ç‚¹çš„å­—ç¬¦\n    int weight;  // æƒå€¼\n    int parent, lChild, rChild; // å·¦å³å­©å­æŒ‡é’ˆ\n};\nclass HuffTree\n{\nprivate:\n    int Node_cnt=0;\n    HuffNode* huff=NULL;\n    string* HuffCode = NULL;\npublic:\n    HuffTree(int n, char* c, int* weights);  // åˆ›å»ºHuffmanæ ‘\n    ~HuffTree();        // ææ„å‡½æ•°\n     void setNode_cnt(int cnt){ Node_cnt = cnt; }\n     void select(int end, int& index1, int& index2); // é€‰å‡ºæœ€å°å’Œæ¬¡å°å¶å­ç»“ç‚¹\n     void printHuffTree();\n     void setHuffCode();\n     void printHuffCode();\n\n};\nHuffTree::~HuffTree()\n{\n    delete[] huff;\n    delete[] HuffCode;\n}\nvoid HuffTree::printHuffCode()\n{\n    for (int i = 0; i < Node_cnt; i++)\n    {\n        cout << huff[i].c << \"çš„å“ˆå¤«æ›¼ç¼–ç ä¸ºï¼š\" << HuffCode[i] << endl;\n    }\n}\nvoid HuffTree::setHuffCode()  // å·¦å­©å­ä¸º0ï¼Œå³å­©å­ä¸º1\n{\n    HuffCode = new string[Node_cnt];\n    for (int i = 0; i < Node_cnt; i++)\n    {\n        int son, father; // å­©å­æŒ‡é’ˆå’ŒåŒäº²æŒ‡é’ˆ\n        int cnt = 0;\n        string str;\n        son = i;\n        father = huff[son].parent;\n        while (father != -1)\n        {\n            if (huff[father].lChild == son)\n            {\n                str.append(\"0\");\n            }\n            else\n            {\n                str.append(\"1\");\n            }\n\n            son = father;  // å­©å­æŒ‡é’ˆä¸ºå½“å‰åŒäº²æŒ‡é’ˆ\n            father = huff[father].parent;  // åŒäº²æŒ‡é’ˆä¸ºå½“å‰åŒäº²æŒ‡é’ˆçš„åŒäº²\n        }\n        HuffCode[i] = new char[str.size()];\n        for (unsigned int j = 0; j < str.size(); j++)  // ç”±äºæ±‚å“ˆå¤«æ›¼ç¼–ç æ—¶æ˜¯ä»å¶å­ç»“ç‚¹ä¸€ç›´æ‰¾åˆ°æ ‘æ ¹ï¼Œæ•…ç¼–ç ä¸ºä¹‹å‰çš„é€†åº\n        {\n            HuffCode[i][j] = str[str.size() - 1-j];// é€†åº\n        }\n    }\n}\nHuffTree::HuffTree(int n,char* ch,int* weights){\n    Node_cnt = n;\n    huff = new HuffNode[2 * Node_cnt - 1];\n    for (int i = 0; i < Node_cnt; i++) // åˆå§‹åŒ–\n    {\n        huff[i].c = ch[i];\n        huff[i].weight = weights[i];\n        huff[i].lChild = -1;\n        huff[i].rChild = -1;\n        huff[i].parent = -1;\n    }\n    for (int i = Node_cnt; i < Node_cnt * 2 - 1; i++)\n    {\n        int index1 = -1, index2 = -1;\n        select(i - 1, index1, index2);// é€‰å‡ºæœ€å°å’Œæ¬¡å°ä¸­é—´æ ‘ç»“ç‚¹ç´¢å¼•\n        huff[index1].parent = i;\n        huff[index2].parent = i;\n        huff[i].weight = huff[index1].weight + huff[index2].weight;\n        huff[i].lChild = index1;\n        huff[i].rChild = index2;\n        huff[i].parent = -1;\n    }\n}\n\nvoid HuffTree::printHuffTree()\n{\n    cout << \"æ‰€å»ºå“ˆå¤«æ›¼é™æ€é“¾è¡¨ç¤ºå¦‚ä¸‹ï¼š\" << endl;\n    cout << \"ä½ç½®\\t\" << \"å­—ç¬¦\\t\" << \"æƒå€¼\\t\" << \"åŒäº²\\t\" << \"å·¦å­©å­\\t\" << \"å³å­©å­\\t\" << endl;\n    for (int i = 0; i < Node_cnt*2-1; i++)\n    {\n        cout << i << \"\\t\" << huff[i].c << \"\\t\" << huff[i].weight << \"\\t\" << huff[i].parent << \"\\t\" << huff[i].lChild << \"\\t\" << huff[i].rChild << endl;\n    }\n}\nvoid  HuffTree::select(int end, int& index1, int& index2)\n    {\n        int min1=100000,min2 = 100000;  // è®¾m1ä¸ºæœ€å°å€¼ï¼Œm2ä¸ºæ¬¡å°å€¼\n        for (int j = 0; j <=end; j++)\n        {\n            if (huff[j].parent == -1)\n            {\n                if (huff[j].weight < min1)  // å¦‚æœå½“å‰æƒå€¼æ¯”æœ€å°å€¼å°\n                {\n                    index2 = index1;\n                    index1 = j;\n                    min2 = min1;\n                    min1 = huff[j].weight;\n                }\n                else if (huff[j].weight < min2)  // å¦‚æœå½“å‰æƒå€¼æ¯”æ¬¡å°å€¼å°\n                {\n                    min2 = huff[j].weight;\n                    index2 = j;\n                }\n            }\n        }\n    }\n\nint main()\n{\n\n    int n;\n    cout << \"è¯·è¾“å…¥æ ‘å¶ç»“ç‚¹çš„ä¸ªæ•°(å°äºç­‰äº1ç»“æŸ)ï¼š\" << endl;\n    cin >> n;\n    if (n < 1) return 0;\n    char chs[256];\n    int weights[256];\n\n    for (int i = 0; i < n; i++){\n        cout << \"è¯·è¾“å…¥ç¬¬\" << i+1 << \"ä¸ªå­—ç¬¦åŠæƒå€¼\" << endl;\n        cin >> chs[i] >> weights[i];\n    }\n    HuffTree tree(n,chs,weights);\n    tree.printHuffTree();\n    tree.setHuffCode();\n    tree.printHuffCode();\n\n    return 0;\n}\n", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "Problem1ï¼šhttps://paste.ubuntu.com/p/p5vmGWqFYh/\r\nProblem2ï¼šhttps://paste.ubuntu.com/p/kSSnfGDpMy/", "Konwledge_Point": "æœ€å°ç”Ÿæˆæ ‘", "Question": "éº»çƒ¦ç”¨cè¯­è¨€è§£å†³ä¸€ä¸‹ã€‚ã€‚\nAã€ç¼–å†™ä¸€ä¸ªè¯»å–1000ä¸ªéšæœºæ•°æ•´æ•°çš„cç¨‹åºï¼Œåˆ›å»ºä¸€ä¸ªäºŒå‰æ ‘å¹¶æ‰“å°æ ‘çš„æ·±åº¦ã€‚\n\nä½¿ç”¨shuf-i1-1000å‘½ä»¤ç”Ÿæˆéšæœºæ•°ã€‚ï¼ˆè‡ªå·±ç”Ÿæˆä¹Ÿè¡Œï¼‰\n\n Bã€ç¼–å†™ä¸€ä¸ªcç¨‹åºï¼Œé‡å¤ä¸Šä¸€ä¸ªé—®é¢˜çš„å®éªŒ1000æ¬¡ï¼ˆæ¯æ¬¡ä¸€åƒä¸ªéšæœºæ•°éƒ½ä¸åŒï¼‰ã€‚è®¡ç®—æ‰€åˆ›å»ºçš„1000ä¸ªäºŒå‰æ ‘çš„å¹³å‡æ·±åº¦ï¼Œæœ€å°æ·±åº¦å’Œæœ€å¤§æ·±åº¦ã€‚ä¸è¦å¿˜è®°åœ¨å®éªŒä¹‹é—´é‡Šæ”¾æ ‘ã€‚ä½¿ç”¨shuf-i1-1000000ç”Ÿæˆä¸€ä¸ª1000x1000=1000000ä¸ªæ•´æ•°çš„åˆ—è¡¨ã€‚", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "#include<stdio.h>\n#include<stdlib.h>\n#define max 100\nconst int m=100;\nint n,i,top=0,first=0,last=0,first1=0,last1=0;\nint s[m],z[m];\ntypedef struct snodelinked{undefined\nint data;\nchar bianma;\nint parent;\nstruct snodelinked *Rson,*Lson,*next;\n}snodelinked,*ptr;\nptr hfcreat(ptr head);\n//void bianma(ptr root);\nvoid preorder(ptr root);\nvoid push(int s[],int &top,int x);\nvoid pop(int s[],int &top);\nvoid addq(int s[],int first,int &last,char x);\nint delq(int s[],int &first,int last);\nptr hfinition();\nvoid translate(ptr root);\nint main(){undefined\nptr head,root;\nhead=hfinition();\nroot=hfcreat(head);\npreorder(root);\n// putchar(â€™\\nâ€™);\ngetchar();\ntranslate(root);\nreturn 0;\n}\nptr hfinition(){undefined\nptr head,p;\nscanf(\"%d\",&n);\nhead=p=(ptr)malloc(sizeof(snodelinked));\nhead->data=max;\nhead->bianma=â€™ â€˜;\ngetchar();\nfor(i=0;i<n;i++){undefined\np->next=(ptr)malloc(sizeof(snodelinked));\np=p->next;\nscanf(\"%c%1d\",&p->bianma,&p->data);\np->Lson=p->Rson=NULL;\np->parent=0;\n}\np->next=head;\nreturn head;\n}\nptr hfcreat(ptr head){undefined\nptr t1,t2,p,q,r;\nfor(i=0;i<n-1;i++){undefined\nr=(ptr)malloc(sizeof(snodelinked));\nt1=head->next;\nt2=t1->next;\nr->data=t1->data+t2->data;\nr->Lson=t1;\nr->Rson=t2;\nr->bianma=â€™ â€˜;\nt1->parent=0;\nt2->parent=1;\nhead->next=t2->next;\np=head;\nq=p->next;\nwhile(1){undefined\nif(r->data>=q->data){undefined\np=p->next;\nq=p->next;\n}else{undefined\nr->next=q;\np->next=r;\nbreak;\n}\n}\n}\np=head->next;\nfree(head);\nreturn p;\n}\nvoid preorder(ptr root){undefined\nif(root->bianma!=â€™ â€˜){undefined\nputchar(root->bianma);\nprintf( â€œ:â€);\nfor(i=1;i<=top;i++){undefined\nprintf(\"%d\",s[i]);\n}\nputchar(â€™\\nâ€™);\n}\nif(root->Lson!=NULL) {undefined\npush(s,top,root->Lson->parent);\npreorder(root->Lson);\ntopâ€“;\n}\nif(root->Rson!=NULL) {undefined\npush(s,top,root->Rson->parent);\npreorder(root->Rson);\ntopâ€“;\n}\n}\nvoid push(int s[],int &top,int x){undefined\ns[++top]=x;\n}\nvoid pop(int s[],int &top){undefined\nprintf(\"%d\",s[topâ€“]);\n}\nvoid translate(ptr root){undefined\nptr h;\nh=root;\nint y;\nchar x;\nx=getchar();\nprintf(â€œoriginal:â€);\nwhile(x!=â€™\\nâ€™){undefined\naddq(z,first1,last1,x);\nx=getchar();\n}\nwhile(first1!=last1){undefined\ny=delq(z,first1,last1);\nif(y== 0) {undefined\nh = h->Lson;\n}\nelse if(y== 1) h=h->Rson;\nif(h->bianma!=â€™ '){undefined\nputchar(h->bianma);\nh=root;\n}\n}\n}\nvoid addq(int z[],int first,int &last,char x){undefined\nif(x==â€˜0â€™) z[last]=0;\nelse if(x==â€˜1â€™) z[last]=1;\nlast=(last+1)%m;\n}\nint delq(int z[],int &first,int last){undefined\nreturn z[first++];\n}\n\n", "Konwledge_Point": "æœ€å°ç”Ÿæˆæ ‘", "Question": "ç¨‹åºè®¾è®¡ï¼šç¼–å†™ä¸€ä¸ªå“ˆå¤«æ›¼ç¼–ç è¯‘ç ç¨‹åºã€‚\næŒ‰è¯é¢‘ä»å°åˆ°å¤§çš„é¡ºåºç»™å‡ºå„ä¸ªå­—ç¬¦ï¼ˆä¸è¶…è¿‡30ä¸ªï¼‰çš„è¯é¢‘ï¼Œæ ¹æ®è¯é¢‘æ„é€ å“ˆå¤«æ›¼æ ‘ï¼Œç»™å‡ºæ¯ä¸ªå­—ç¬¦çš„å“ˆå¤«æ›¼ç¼–ç ï¼Œå¹¶å¯¹ç»™å‡ºçš„è¯­å¥è¿›è¡Œè¯‘ç ã€‚\nä¸ºç¡®ä¿æ„å»ºçš„å“ˆå¤«æ›¼æ ‘å”¯ä¸€ï¼Œæœ¬é¢˜åšå¦‚ä¸‹é™å®šï¼š\nï¼ˆ1ï¼‰é€‰æ‹©æ ¹ç»“ç‚¹æƒå€¼æœ€å°çš„ä¸¤æ£µäºŒå‰æ ‘æ—¶ï¼Œé€‰å–æƒå€¼è¾ƒå°è€…ä½œä¸ºå·¦å­æ ‘ã€‚\nï¼ˆ2ï¼‰è‹¥å¤šæ£µäºŒå‰æ ‘æ ¹ç»“ç‚¹æƒå€¼ç›¸ç­‰ï¼ŒæŒ‰å…ˆåæ¬¡åºåˆ†å·¦å³ï¼Œå…ˆå‡ºç°çš„ä½œä¸ºå·¦å­æ ‘ï¼Œåå‡ºç°çš„ä½œä¸ºå³å­æ ‘ã€‚\nç”Ÿæˆå“ˆå¤«æ›¼ç¼–ç æ—¶ï¼Œå“ˆå¤«æ›¼æ ‘å·¦åˆ†æ”¯æ ‡è®°ä¸º0ï¼Œå³åˆ†æ”¯æ ‡è®°ä¸º1ã€‚\nã€è¾“å…¥æ ¼å¼ã€‘\nç¬¬ä¸€è¡Œè¾“å…¥å­—ç¬¦ä¸ªæ•°nï¼›\nç¬¬äºŒè¡Œåˆ°ç¬¬nè¡Œè¾“å…¥ç›¸åº”çš„å­—ç¬¦åŠå…¶è¯é¢‘(å¯ä»¥æ˜¯æ•´æ•°ï¼Œä¸å¯ä»¥æ˜¯å°æ•°ï¼‰ï¼›\næœ€åä¸€è¡Œè¾“å…¥éœ€è¿›è¡Œè¯‘ç çš„ä¸²ã€‚\nã€è¾“å‡ºæ ¼å¼ã€‘\né¦–å…ˆæŒ‰æ ‘çš„å…ˆåºé¡ºåºè¾“å‡ºæ‰€æœ‰å­—ç¬¦çš„ç¼–ç ï¼Œæ¯ä¸ªç¼–ç å ä¸€è¡Œï¼›\næœ€åä¸€è¡Œè¾“å‡ºéœ€è¯‘ç çš„åŸæ–‡ï¼ŒåŠ ä¸Šoriginal:å­—æ ·ã€‚\nè¾“å‡ºä¸­å‡æ— ç©ºæ ¼\nã€æ ·ä¾‹è¾“å…¥ã€‘\n3\nm1\nn1\nc2\n10110\nã€æ ·ä¾‹è¾“å‡ºã€‘\nc:0\nm:10\nn:11\noriginal:mnc", "Tag": "ç®—æ³•åˆ†æ"}
{"Answer": "ä»…ä¾›å‚è€ƒï¼š\n#include <iostream>\n#include <string>\nusing namespace std;\nstruct huffTree {\n    int parent;\n    int lchild;\n    int rchild;\n    int weight;\n    string flag;\n};\nstruct Lowest_node {\n    char ch;\n    int ch_num;\n};\nvoid coding(int length,huffTree *tree,int n,int &a,int &b) {\n    int i;\n    int r,s;\n\n    r=s=length;\n    for (i=0;i<n;i++) {\n        if (tree[i].weight<r\n         && tree[i].parent==-1) {\n            r=tree[i].weight;\n            a=i;\n        }\n    }\n    for (i=0;i<n;i++) {\n        if (tree[i].weight<s\n         && i!=a\n         && tree[i].parent==-1) {\n            s=tree[i].weight;\n            b=i;\n        }\n    }\n}\nvoid frequency(string str) {\n    int i,j;\n    int length=str.length();\n    Lowest_node *node=new Lowest_node[length];\n\n    for (i=0;i<length;i++) node[i].ch_num=0;\n\n    int char_type_num=0;\n    for (i=0;i<length;i++) {\n        for (j=0;j<char_type_num;j++)\n            if (str[i]==node[j].ch\n            || ('a'<=node[j].ch && node[j].ch<='z'\n                && str[i]+32==node[j].ch))\n                break;//\n        if (j<char_type_num) node[j].ch_num++;\n        else {\n            if ('A'<=str[i] && str[i] <= 'Z') node[j].ch=str[i]+32;\n            else node[j].ch=str[i];\n            node[j].ch_num++;\n            char_type_num++;\n        }\n    }\n    for (i=0;i<char_type_num;i++) {\n        for (j=i;j<char_type_num;j++) {\n            if (node[j].ch_num<node[j+1].ch_num) {\n                int temp;\n                char ch_temp;\n                temp=node[j].ch_num;\n                ch_temp=node[j].ch;\n                node[j].ch_num=node[j+1].ch_num;\n                node[j].ch=node[j+1].ch;\n                node[j+1].ch_num=temp;\n                node[j+1].ch=ch_temp;\n            }\n        }\n    }\n    for (i=0;i<char_type_num;i++)\n        cout<<\"å­—ç¬¦\"<<node[i].ch<<\"å‡ºç°äº†\"<<node[i].ch_num<<\"æ¬¡\"<<endl;\n    huffTree *huff=new huffTree[2*char_type_num-1];\n    huffTree temp;\n    string *code=new string[2*char_type_num-1];\n\n    for (i=0;i<2*char_type_num-1;i++) {\n        huff[i].lchild=-1;\n        huff[i].parent=-1;\n        huff[i].rchild=-1;\n        huff[i].flag=-1;\n    }\n    for (j=0;j<char_type_num;j++) huff[j].weight=node[j].ch_num;\n    int min1,min2;\n    for (int k=char_type_num;k<2*char_type_num-1;k++) {\n        coding(length,huff,k,min1,min2);\n        huff[min1].parent=k;\n        huff[min2].parent=k;\n        huff[min1].flag=\"0\";\n        huff[min2].flag=\"1\";\n        huff[k].lchild=min1;\n        huff[k].rchild=min2;\n        huff[k].weight=huff[min1].weight+huff[min2].weight;\n    }\n    for (i=0;i<char_type_num;i++) {\n        temp=huff[i];\n        while (1) {\n            code[i]=temp.flag+code[i];\n            temp=huff[temp.parent];\n            if (temp.parent==-1) break;//\n        }\n    }\n    cout<<\"å­—ç¬¦ä¸²çš„æ¯ä¸ªå­—ç¬¦huffmanç¼–ç ä¸ºï¼š\"<<endl;\n    for (i=0;i<char_type_num;i++) cout<<node[i].ch<<\"  \"<<code[i]<<endl;\n    cout<<\"æ•´ä¸ªå­—ç¬¦ä¸²çš„huffmanç¼–ç ä¸ºï¼š\"<<endl;\n    for (i=0;i<length;i++) {                                                                                     //S?\n        for (j=0;j<char_type_num;j++) {\n            if (str[i]==node[j].ch)\n                cout<<code[j];\n        }\n    }\n    delete[] node;\n    node=NULL;\n    delete[] huff;\n    huff=NULL;\n    delete[] code;\n    code=NULL;\n}\nint main() {\n    int length=0;\n    string str;\n    cout<<\"è¯·è¾“å…¥ä¸€ä¸ªå­—ç¬¦ä¸²ï¼š\";\n    cin>>str;\n    frequency(str);\n    return 0;\n}\n//è¯·è¾“å…¥ä¸€ä¸ªå­—ç¬¦ä¸²ï¼š2333abcde\n//å­—ç¬¦3å‡ºç°äº†3æ¬¡\n//å­—ç¬¦2å‡ºç°äº†1æ¬¡\n//å­—ç¬¦aå‡ºç°äº†1æ¬¡\n//å­—ç¬¦bå‡ºç°äº†1æ¬¡\n//å­—ç¬¦cå‡ºç°äº†1æ¬¡\n//å­—ç¬¦då‡ºç°äº†1æ¬¡\n//å­—ç¬¦eå‡ºç°äº†1æ¬¡\n//å­—ç¬¦ä¸²çš„æ¯ä¸ªå­—ç¬¦huffmanç¼–ç ä¸ºï¼š\n//3  11\n//2  000\n//a  001\n//b  010\n//c  011\n//d  100\n//e  101\n//æ•´ä¸ªå­—ç¬¦ä¸²çš„huffmanç¼–ç ä¸ºï¼š\n//000111111001010011100101\n\n\n", "Konwledge_Point": "æœ€å°ç”Ÿæˆæ ‘", "Question": "å“ˆå¤«æ›¼ç®—æ³•çš„ç¼–ç è¯‘ç ç³»ç»Ÿ\nå®ç°ä¸€ä¸ªå“ˆå¤«æ›¼ç¼–ç ç³»ç»Ÿï¼Œç³»ç»ŸåŒ…æ‹¬ä»¥ä¸‹åŠŸèƒ½ï¼š\n\n\nå­—ç¬¦ä¿¡æ¯ç»Ÿè®¡ï¼šè¯»å–å¾…ç¼–ç çš„æºæ–‡ä»¶SourceFile.txtï¼Œç»Ÿè®¡å‡ºç°çš„å­—ç¬¦åŠå…¶é¢‘ç‡ã€‚\nå»ºç«‹å“ˆå¤«æ›¼æ ‘ï¼šæ ¹æ®ç»Ÿè®¡ç»“æœå»ºç«‹å“ˆå¤«æ›¼æ ‘ã€‚\nå»ºç«‹å“ˆå¤«æ›¼ç è¡¨ï¼šåˆ©ç”¨å¾—åˆ°çš„å“ˆå¤«æ›¼æ ‘ï¼Œå°†å„å­—ç¬¦å¯¹åº”çš„ç¼–ç è¡¨ä¿å­˜åœ¨æ–‡ä»¶Code.txtä¸­ã€‚\nå¯¹æºæ–‡ä»¶è¿›è¡Œç¼–ç ï¼šæ ¹æ®å“ˆå¤«æ›¼ç è¡¨ï¼Œå°†SourceFile.txtä¸­çš„å­—ç¬¦è½¬æ¢æˆç›¸åº”çš„ç¼–ç æ–‡ä»¶ResultFile.txtã€‚\n\n\n#define _CRT_SECURE_NO_WARNINGS 1\n#include \n#include \n#include \n#define MAXVALUE 32767        //æå¤§å€¼ç›¸å½“äºæ— ç©·å¤§\n#define NODENUM 10            //å¶å­ç»“ç‚¹æ•°\ntypedef struct\n{\n    char data;                //æ•°æ®åŸŸ\n    int weight;                //ç»“ç‚¹çš„æƒå€¼\n    int parent, lch, rch;    //ä¸‹æ ‡\n}htNode,*huffmanTree;        \n\n\ntypedef char** huffmanCode;    //ç¬¬ä¸€ä¸ª\næ˜¯ä»£è¡¨å®ƒæ˜¯æŒ‡é’ˆå˜é‡ï¼Œè¯´æ˜å®ƒæ˜¯æ•°ç»„\n                            //ç¬¬äºŒä¸ª\nè¯´æ˜å®ƒæ˜¯æŒ‡é’ˆæ•°ç»„ï¼Œä»£è¡¨è¿™ä¸ªcharç±»å‹æ•°ç»„é‡Œæ¯ä¸ªå…ƒç´ éƒ½æ˜¯*huffmanCodeå˜é‡\n\n\nint initHuffmanTree(huffmanTree& HT);                                //åˆå§‹åŒ–å“ˆå¤«æ›¼æ ‘\nvoid creatHuffmanTree(huffmanTree& HT, int n);                        //æ„å»ºå“ˆå¤«æ›¼æ ‘\nvoid createHuffmanCode(huffmanTree HT, huffmanCode &HC, int n);        //ç¼–å†™å“ˆå¤«æ›¼ç¼–ç \nint main()\n{\n    huffmanTree HT ;\n    initHuffmanTree(HT);\n    huffmanCode HC;\n    creatHuffmanTree(HT,NODENUM);\n    createHuffmanCode(HT,HC,NODENUM);\n    /\nfor (int i = NODENUM + 1; i <= 2 * NODENUM - 1; i++)\n        printf(\"%d \", HT[i].weight);\n/\n    for (int i = 1; i <= NODENUM; i++)                                //éå†è¾“å‡ºç¼–ç \n    {\n        printf(\"%c:\\t\",HT[i].data);\n        printf(\"%s\\n\", HC[i]);\n    }\n    return 0;\n}\nint initHuffmanTree(huffmanTree& HT)\n{\n    HT = (htNode*)malloc(sizeof(htNode) * (2 * NODENUM));            //ç»™HTåˆ†é…2 * NODENUMä¸ªhtNOdeå¤§å°çš„htNodeç±»å‹çš„æ•°ç»„\n    for (int i = 1; i <= 2 * NODENUM - 1; i++)                        //ä¸‹æ ‡ä»1å¼€å§‹åˆ°2 * NODENUM\n    {\n        HT[i].parent = HT[i].lch = HT[i].rch = -1;                    //åŒäº²å’Œ  çš„å€¼éƒ½ç½®ä¸º-1\n    }\n    printf(\"please input some weight!\\n\");\n    for (int i = 1; i <= NODENUM; i++)                                //æƒå€¼åªæœ‰1-nä¸ª\n    {\n        scanf(\"%d\",&HT[i].weight);                                    //ç»™æ¯ä¸ªç»“ç‚¹èµ‹äºˆæƒå€¼\n    }\n        char c = getchar();                                            //è¿™ä¸ªæ¥æ¥æ”¶ä¸Šé¢çš„å›è½¦\n    printf(\"please input some data!\\n\");\n    for (int i = 1; i <= NODENUM; i++)\n    {\n            //scanf(\"%c \",&HT[i].data);\n            char a = getchar();\n        if(a == '\\n')                                                //é‡åˆ°å›è½¦å°±ç»“æŸ\n            break;\n        else\n            HT[i].data = a;                                            //ç»™æ¯ä¸ªç»“ç‚¹èµ‹äºˆæ•°æ®\n    }\n\n\nreturn\n \n1\n;\n\n\n\n}\n\n\nvoid creatHuffmanTree(huffmanTree& HT, int n)\n{\n    if (n <= 1)                                                            //å¦‚æœç»“ç‚¹æ•°å°äºç­‰äº1ï¼Œä¸åˆ›å»º\n        return;\n    int min1, min2;                                                        //å®šä¹‰ä¸¤ä¸ªæ•°ï¼Œæ¥å­˜å‚¨æ¯æ¬¡é€‰å–æœ€å°ä¸¤ä¸ªç»“ç‚¹çš„æƒå€¼\n    int rnode, lnode;                                                    //å®šä¹‰ä¸¤ä¸ªä¸‹æ ‡å€¼ï¼Œæ¥å­˜å‚¨æ¯æ¬¡é€‰å–æœ€å°ä¸¤ä¸ªç»“ç‚¹çš„ä¸‹æ ‡\n    for (int i = n + 1; i <= 2 * n -1; i++)                                //è¦ç”Ÿæˆn-1ä¸ªç»“ç‚¹ï¼Œæ‰€ä»¥è¦æ“ä½œnâ€”1æ¬¡ä¸”ä»ä¸‹æ ‡ä¸ºn+1å¼€å§‹å­˜å‚¨\n    {\n        int min1 = MAXVALUE; int lnode = -1;                            //è®©æœ€å°å€¼åˆå§‹åŒ–ä¸ºæå¤§å€¼ï¼Œè¿™æ ·å¶å­ç»“ç‚¹çš„æœ€å¤§å€¼å†å¤§ä¹Ÿä¸ä¼šè¶…è¿‡è¿™ä¸ªå€¼äº†\n        int min2 = MAXVALUE; int rnode = -1;\n        for (int j = 1; j <= i - 1; j++)                                //å› ä¸ºèµ·å…ˆæ˜¯åœ¨å‰nä¸ªä¸­é€‰æ‹©æœ€å°çš„ä¸¤ä¸ªç»“ç‚¹çš„æƒå€¼ï¼Œä½†æ–°ç”Ÿæˆä¸€ä¸ªåå°±å¾—åœ¨å‰n+1ä¸ªä¸­é€‰æ‹©æœ€å°çš„ä¸¤ä¸ªç»“ç‚¹çš„æƒå€¼\n        {                                                                //å‡è®¾n = 10 æ€»ç»“ç‚¹æ•°å°±å¾—ä¸º19ï¼Œé‚£æˆ‘ä»¬å°±åªè¦æ¯”è¾ƒ18æ¬¡å°±å¯ä»¥å¾—å‡ºç»“æœäº†ï¼Œè®°ä½æ¯”è¾ƒçš„æ¬¡æ•°æ¯”ç”Ÿæˆçš„æ€»ç»“ç‚¹æ•°å°‘1\n                if (HT[j].weight < min1 && HT[j].parent == -1)            //è¿™ä¸ªå°äºå°±ä½¿å¾—å½“å‡ºç°ç›¸åŒçš„æƒå€¼æ—¶ä¼˜å…ˆè€ƒè™‘å…ˆå‡ºç°çš„å€¼ï¼Œå¯ä»¥å‡è®¾ä¸‹\n                {\n                    min2 = min1;    rnode = lnode;                        //ç¢°åˆ°æ¯”min1å°çš„ï¼Œé‚£min1çš„å€¼å°±ç»™ç¬¬äºŒå°çš„min2ï¼Œä¸‹æ ‡ä¹Ÿç»™å®ƒ\n                    min1 = HT[j].weight; lnode = j;                        //ç„¶åæœ€å°çš„ç»™min1ï¼Œä¸‹æ ‡åŒç†\n                }\n                else if (HT[j].weight < min2 && HT[j].parent == -1)        //è¿™æ˜¯ç¬¬äºŒå°çš„åˆ¤æ–­\n                {\n                    min2 = HT[j].weight;\n                    rnode = j;\n                }\n        }\n        HT[lnode].parent = HT[rnode].parent = i;                        //æœ€å°ä¸¤ä¸ªç»“ç‚¹çš„parentå˜ä¸ºç”Ÿæˆç»“ç‚¹çš„ä¸‹æ ‡\n        HT[i].lch = lnode; HT[i].rch = rnode;                            //ç”Ÿæˆç»“ç‚¹çš„å·¦ä¸ºæœ€å°çš„min1çš„ä¸‹æ ‡ï¼Œå³åŒç†\n        HT[i].weight = HT[lnode].weight + HT[rnode].weight;                //ç”Ÿæˆç»“ç‚¹çš„æƒå€¼ç­‰äºæœ€å°ç»“ç‚¹çš„æƒå€¼ç›¸åŠ \n    }\n\n\n}\n\n\nvoid createHuffmanCode(huffmanTree HT, huffmanCode& HC, int n)\n{\n    HC = (huffmanCode)malloc(sizeof(huffmanCode) * n + 1);                //ç”³è¯·n + 1ä¸ªhuffmanCodeå¤§å°huffmanCodeç±»å‹çš„ä¸´æ—¶ç©ºé—´\n                                                                        //å› ä¸ºä¸‹æ ‡æ˜¯ä»ä¸€å¼€å§‹ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦ç”³è¯·æ¯”ç»“ç‚¹å¤šä¸€ä¸ªçš„ç»“ç‚¹ï¼Œå’Œå“ˆå¤«æ›¼æ ‘çš„ç»“æ„å¯¹åº”ï¼Œæ–¹ä¾¿è¾“å‡º\n    char* cd = (char*)malloc(sizeof(char) * n);                            //ç”³è¯·nä¸ªcharå¤§å°charç±»å‹çš„ä¸´æ—¶ç©ºé—´ï¼Œè¿™ä¸ªä¸´æ—¶æ•°ç»„è®°å½•æ¯æ¬¡éå†å‡ºæ¥çš„ç¼–ç \n    int start = 0,c = 0,f = 0;                                            //startä¸ºcdæ•°ç»„è®°å½•ä¸‹æ ‡ï¼Œcåˆå§‹ä¸ºå¶å­ç»“ç‚¹ä¸‹æ ‡ï¼Œè€Œåå°±æ˜¯  ç»“ç‚¹çš„ä¸‹æ ‡ï¼Œfè®°å½•åŒäº²ç»“ç‚¹çš„ä¸‹æ ‡\n    cd[n - 1] = '\\0';                                                    //è¿™ä¸ªå°±æ˜¯ç»™printfç•™ç€çš„ï¼Œå› ä¸ºprintfä¸ä¼šç”Ÿæˆ'\\0'ï¼Œå¦‚æœç”¨putså°±ä¸ç”¨è¿™å¥è¯­å¥äº†\n    for (int i = 1; i <= n; i++)                                        //åªè¦å¶å­ç»“ç‚¹çš„ç¼–ç \n    {\n        start = n - 1;                                                    //è¿™å¥è¦èµ‹å€¼nçš„è¯ï¼Œstart--è¦å†™åœ¨åˆ¤æ–­åæ–¹\n        c = i;\n        f = HT[c].parent;\n        while (f != -1)                                                    //æ ¹èŠ‚ç‚¹æ²¡æœ‰åŒäº²\n        {\n            start--;\n            if (HT[f].lch == c)                                            //æ˜¯å·¦å°±æ˜¯0ï¼Œå³å°±ä¸º1\n                cd[start] = '0';\n            else\n                cd[start] = '1';\n            c = f; f = HT[c].parent;                                    //å‘æ ¹ç»“ç‚¹æ¥è¿‘\n        }\n        HC[i] = (char*)malloc(sizeof(char) * (n - start));                //ç»™æ•°ç»„é‡Œçš„æ•°ç»„ç”³è¯·n - startä¸ªcharå¤§å°çš„char*ç±»å‹çš„ä¸´æ—¶ç©ºé—´\n        strcpy(HC[i], &cd[start]);                                        //cdé‡Œè®°å½•çš„ç¼–ç ç»™HCçš„ç¬¬iä¸ªæ•°ç»„\n    }\n    free(cd);                                                            //é‡Šæ”¾ä¸´æ—¶ç©ºé—´\n}\næƒ³é—®ä¸€é—®ä¸ºä»€ä¹ˆè¾“å…¥å­—ç¬¦åç¨‹åºé—ªé€€\n ", "Tag": "ç®—æ³•åˆ†æ"}
