{"Question": "Knight's Shortest Path on Chessboard\r\n                \r\nI've been practicing for an upcoming programming competition and I have stumbled across a question that I am just completely bewildered at. However, I feel as though it's a concept I should learn now rather than cross my fingers that it never comes up.\n\nBasically, it deals with a knight piece on a chess board. You are given two inputs: starting location and ending location. The goal is to then calculate and print the shortest path that the knight can take to get to the target location.\n\nI've never dealt with shortest-path-esque things, and I don't even know where to start. What logic do I employ to go about tackling this?\n\nP.S. If it's of any relevance, they want you to supplement the knight's normal moves by also allowing it to move to the four corners of the square formed by the (potentially) eight moves a knight can make, given that the center of the square is the knight's location.\n    ", "Answer": "\r\nEDIT: See simon's answer, where he fixed the formula presented here.\n\nActually there is an O(1) formula\n\nThis is an image that I've made to visualize it ( Squares a knight can reach on Nth move are painted with same color ).\n\n\nCan you notice the pattern here?\n\nAlthough we can see the pattern, it is really hard to find the function ```\nf( x , y )```\n that returns the number of moves required to go from square ```\n( 0 , 0 )```\n to square ```\n( x , y )```\n\n\nBut here is the formula that works when ```\n0 <= y <= x```\n\n\n```\nint f( int x , int y )\n{\n    int delta = x - y;\n\n    if( y > delta )\n        return 2 * ( ( y - delta ) / 3 ) + delta;\n    else\n        return delta - 2 * ( ( delta - y ) / 4 );\n}\n```\n\n\nNote: This question was asked on SACO 2007 Day 1\nAnd solutions are here\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Finding kth-shortest paths?\r\n                \r\nFinding the shortest path between two points in a graph is a classic algorithms question with many good answers (Dijkstra's algorithm, Bellman-Ford, etc.)  My question is whether there is an efficient algorithm that, given a directed, weighted graph, a pair of nodes s and t, and a value k, finds the kth-shortest path between s and t.  In the event that there are multiple paths of the same length that all tie for the kth-shortest, it's fine for the algorithm to return any of them.\n\nI suspect that this algorithm can probably be done in polynomial time, though I'm aware that there might be a reduction from the longest path problem that would make it NP-hard.\n\nDoes anyone know of such an algorithm, or of a reduction that show that it is NP-hard?\n    ", "Answer": "\r\nYou're looking for Yen's algorithm for finding ```\nK```\n shortest paths. The ```\nk```\nth shortest path will then be the last path in that set.\n\nHere's an implementation of Yen's algorithm.\n\nAnd here's the original paper describing it.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Floyd-Warshall: all shortest paths\r\n                \r\nI've implemented Floyd-Warshall to return the distance of the shortest path between every pair of nodes/vertices and a single shortest path between each of these pairs.\n\nIs there any way to get it to return every shortest path, even when there are multiple paths that are tied for shortest, for every pair of nodes?  (I just want to know if I'm wasting my time trying)\n    ", "Answer": "\r\nIf you just need the count of how many different shortest path exist, you can keep a ```\ncount```\n array in addition to the ```\nshortestPath```\n array. Here's is a quick modification of the pseudocode from wiki.\n\n```\nprocedure FloydWarshall ()\n    for k := 1 to n\n        for i := 1 to n\n            for j := 1 to n\n                if path[i][j] == path[i][k]+path[k][j] and k != j and k != i\n                    count[i][j] += 1;\n                else if path[i][j] > path[i][k] + path[k][j]\n                    path[i][j] = path[i][k] + path[k][j]\n                    count[i][j] = 1\n```\n\n\nIf you need a way to find all the paths, you can store a ```\nvector/arraylist```\n like structure for each pair to expand and collapse. Here is a modification of the pseudocode from the same wiki.\n\n```\nprocedure FloydWarshallWithPathReconstruction ()\n    for k := 1 to n\n        for i := 1 to n\n            for j := 1 to n\n                if path[i][k] + path[k][j] < path[i][j]\n                    path[i][j] := path[i][k]+path[k][j];\n                    next[i][j].clear()\n                    next[i][j].push_back(k) // assuming its a c++ vector\n                else if path[i][k] + path[k][j] == path[i][j] and path[i][j] != MAX_VALUE and k != j and k != i\n                    next[i][j].push_back(k)\n```\n\n\nNote: if ```\nk==j```\n or ```\nk==i```\n, that means, you're checking either ```\npath[i][i]+path[i][j]```\n or ```\npath[i][j]+path[j][j]```\n, both should be equal to ```\npath[i][j]```\n and that does not get pushed into ```\nnext[i][j]```\n.\n\nPath reconstruction should be modified to handle the ```\nvector```\n. The count in this case would be each ```\nvector```\n's size. Here is a modification of the pseudocode (python) from the same wiki.\n\n```\nprocedure GetPath(i, j):\n    allPaths = empty 2d array\n    if next[i][j] is not empty:\n        for every k in next[i][j]:\n            if k == -1: // add the path = [i, j]\n                allPaths.add( array[ i, j] ) \n            else: // add the path = [i .. k .. j]\n                paths_I_K = GetPath(i,k) // get all paths from i to k\n                paths_K_J = GetPath(k,j) // get all paths from k to j\n                for every path between i and k, i_k in paths_I_K:\n                    for every path between k and j, k_j in paths_K_J:\n                        i_k = i_k.popk() // remove the last element since that repeats in k_j\n                        allPaths.add( array( i_k + j_k) )\n\n    return allPaths\n```\n\n\nNote: ```\npath[i][j]```\n is an adjacency list. While initializing ```\npath[i][j]```\n, you can also initialize ```\nnext[i][j]```\n by adding a ```\n-1```\n to the array. For instance an initialization of ```\nnext[i][j]```\n would be \n\n```\nfor every edge (i,j) in graph:\n   next[i][j].push_back(-1)\n```\n\n\nThis takes care of an edge being the shortest path itself. You'll have to handle this special case in the path reconstruction, which is what i'm doing in ```\nGetPath```\n.\n\nEdit: \"MAX_VALUE\" is the initialized value in the array of distances.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest paths network\r\n                \r\nI have a problem in computing the shortest paths in a network in R. In particular, I have randomized a two-mode network with the following code:\n```\nlibrary(tnet)\nn1 <- 441\nn2 <- 210\nptie <- nrow(data_network)/(n1*n2)\nrandom_data <- rg_tm(ni=n1, np=n2,ties=ptie, seed = 1000)\nrandom_network = network(random_data,matrix.type=\"edgelist\",directed = TRUE)\n```\n\nBut then when I try to compute the shortest paths with the following code:\n```\ndistance_tm(random_network, projection.method=\"sum\")\n```\n\nI have the following error:\n```\nError in if (ncol(net) == 3) { : the argument has lenght zero\n```\n\nDoes anyone knows why? The same happens with the following real two mode network:\n```\nstructure(list(owner = c(\"ABBA JEANS MINING Sprl\", \"ABBA JEANS MINING Sprl\", \"ACACIA Sprl\", \"ACACIA Sprl\", \"ACACIA Sprl\", \"ACACIA Sprl\", \"AFRICAN ENGINEERING CORPORATE Sprl\",  \"AFRICAN ENGINEERING CORPORATE Sprl\", \"AFRICAN ENGINEERING CORPORATE Sprl\",  \"AFRICAN MINERALS (Barbados) Ltd Sprl\"), armed_band = c(\"Mayi Mayi Militia (Bakata Katanga)\",  \"Militia (Elements)\", \"Batwa Ethnic Militia\", \"FDD\", \"Militia (Kamwina Nsapu)\",  \"RCD-Goma\", \"Anti-Balaka\", \"Kuluna Communal Militia\", \"Militia (Kamwina Nsapu)\",  \"Mayi Mayi Militia (Bakata Katanga)\"), freq = c(1, 1, 1, 1, 4,  1, 1, 1, 1, 1)), row.names = c(NA, -10L), class = c(\"tbl_df\",  \"tbl\", \"data.frame\"))\n```\n\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path of multiple shortest pathes\r\n                \r\nI have 2 groups of nodes, persons and movies, and I want to find the closest movie to each person. I found the shortest path to the closest movie this way:\n```\nmatch path = shortestPath( (p: {id: 1)-[*]-(:MOVIE))\nwith path order by length(path)\nreturn collect(path)[0]\n```\n\nNow, and I want to find the closest movie to each person (for each person, the shortest path of the shortest paths between the person and all movies) but, I didn't find a way to take the shortest path for each person separated.\nI wish to have something like that:\n```\nmatch (p:PERSON)\nwith p\nmatch path = shortestPath( (person)-[*]-(:MOVIE) )\nwith person.id as p_id, path ORDER BY length(path)\nreturn collect(path)[0]\n```\n\nbut, the query order by length the whole response. I didn't find a way to order the paths collection per person_id individually\n    ", "Answer": "\r\nYou just need to add the person id in the return statement, so the collect aggregates by person id\n```\nmatch (p:PERSON)\nwith p\nmatch path = shortestPath( (person)-[*]-(:MOVIE) )\nwith person.id as p_id, path ORDER BY length(path)\nreturn p_id, collect(path)[0]\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How to find all shortest paths\r\n                \r\nI have a graph and I want to find all shortest paths between two nodes. I've found a shortest path between two nodes by BFS. However, it just gives me one of the shortest paths if there exists one more than. \n\nHow could I get all of them using BFS?\n\nI've implement my code from well-known BFS pseudocode.\nAlso, I have a adjacency list vector which holds adjacency vertices for all nodes.\n    ", "Answer": "\r\nYou can easily do it by maintaining a list or vector of parents for each node.\nIf two or more nodes ( say X, Y, Z) at the same distance from the starting node , leads to another node M , make all X , Y and Z as the parents of M.\n\nYou just have to add a check to see while adding a parent to the node whether that parent is in the same level as the previous parents.\n\nBy level , I mean the distance from the starting point.\n\nThis way you can get all the shortest paths by tracing back the parent vectors.\nBelow is my C++ implementation.\n\nI hope you know how to print the paths by starting from the destination ,tracing the parents and reach the starting point.\n\nEDIT : Pseudo Code \n\n```\nbfs (start , end)\n\n    enqueue(start)\n    visited[start] = 1\n\n    while queue is NOT empty\n\n        currentNode = queue.front()\n        dequeue()\n\n        if(currentNode == end)\n            break\n\n        for each node adjacent to currentNode\n\n            if node is unvisited\n                visited[node] = visited[curr] + 1\n                enqueue(node)\n                parent[node].add(currentNode)\n\n            else if(currentNode is in same level as node's parents)\n                parent[node].add(currentNode)\n\nreturn \n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest paths and dictionary\r\n                \r\nI have the following shortest paths\n```\n{'A': {'B': ['A', 'B'],\n  'A': ['A'],\n  'C': ['A', 'C']},\n 'D': {'A': ['D', 'A'],\n  'B': ['D', 'B'],\n  'C': ['D', 'C']}}\n```\n\nbuilt as follows:\n```\nselected_shortest = {source: {target: nx.shortest_path(G, source, target) for target in list4path if nx.has_path(G, source, target)} for source in G.nodes()}\n```\n\nwhere G is a network\n```\nG = nx.from_pandas_edgelist(edges, source='Node', target='Target')\n```\n\nand ```\nlist4path```\n is a list of potential targets(e.g., A,B and C).\nI would like to get, instead of the name of nodes between the source and the target in the list, the distance (or separation) between them. So, for example,\n```\n{'A': {'B': 1,\n  'A': 0\n  'C': 1},\n 'D': {'A': 1,\n  'B': 1,\n  'C': 1}}\n```\n\nin order to take the average of these calculated shortest paths.\nCould you please help me to get these values for average?\n    ", "Answer": "\r\nI think you want to replace ```\nshortest_path```\n by ```\nshortest_path_length```\n.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How does a Breadth-First Search work when looking for Shortest Path?\r\n                \r\nI've done some research, and I seem to be missing one small part of this algorithm. I understand how a Breadth-First Search works, but I don't understand how exactly it will get me to a specific path, as opposed to just telling me where each individual node can go. I guess the easiest way to explain my confusion is to provide an example:\nSo for instance, let's say I have a graph like this:\n\nAnd my goal is to get from A to E (all edges are unweighted).\nI start at A, because that's my origin. I queue A, followed by immediately dequeueing A and exploring it. This yields B and D, because A is connected to B and D. I thus queue both B and D.\nI dequeue B and explore it, and find that it leads to A (already explored), and C, so I queue C. I then dequeue D, and find that it leads to E, my goal. I then dequeue C, and find that it also leads to E, my goal.\nI know logically that the fastest path is A->D->E, but I'm not sure how exactly the breadth-first search helps - how should I be recording paths such that when I finish, I can analyze the results and see that the shortest path is A->D->E?\nAlso, note that I'm not actually using a tree, so there are no \"parent\" nodes, only children.\n    ", "Answer": "\r\nTechnically, Breadth-first search (BFS) by itself does not let you find the shortest path, simply because BFS is not looking for a shortest path: BFS describes a strategy for searching a graph, but it does not say that you must search for anything in particular.\n\nDijkstra's algorithm adapts BFS to let you find single-source shortest paths.\n\nIn order to retrieve the shortest path from the origin to a node, you need to maintain two items for each node in the graph: its current shortest distance, and the preceding node in the shortest path. Initially all distances are set to infinity, and all predecessors are set to empty. In your example, you set A's distance to zero, and then proceed with the BFS. On each step you check if you can improve the distance of a descendant, i.e. the distance from the origin to the predecessor plus the length of the edge that you are exploring is less than the current best distance for the node in question. If you can improve the distance, set the new shortest path, and remember the predecessor through which that path has been acquired. When the BFS queue is empty, pick a node (in your example, it's E) and traverse its predecessors back to the origin. This would give you the shortest path.\n\nIf this sounds a bit confusing, wikipedia has a nice pseudocode section on the topic.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "shortest paths & geodesics\r\n                \r\ngiven a mesh made entirely of quads, where every vertex has valence n (with n >= 3), and does not lie on the same plane, I need to find the distance of every vertex in the mesh from a closed set of seed vertices. That is, given one or more mesh vertices (a seed set), I need to build a distance map that stores the distance of each mesh vertex from the seed set (which will have distance 0 from themselves).\n\nafter spending some time searching for possible solutions, I got the following picture:\n\n1) it is not trivial, and different approaches have been developed during the last 20 years or so\n\n2) every algorithm that takes into account a 3d domain is restricted to a triangular domain\n\nsaid that, this is the picture I got:\n\nDijkstra algorithm may be used as a way to find the shortest path between 2 vertices, following the edges of the mesh, but it is very inaccurate and  will lead to an erroneous geodesic. Lanthier (LA) proposed an improvement, but the error is still quite high.\n\nKimmel and Sethian (KS) proposed a Fast Marching Method -FMM- to solve the Eikonal equation, addressing the issue calculating the propagation of a wave starting at the seed points and recording the time the wave crosses every vertex. Unfortunately this algorithm, while simple enough to implement, still brings a quite inaccurate result, and care has to be taken to avoid obtuse triangles, or treat them in a very special way.\nNovotni (NV) addressed the problem of (KS) precision in a single seed scenario, but it is unclear to me if:\n\na) it still suffers from the obtuse angle problem\n\nb) when used in a multiple seed points scenario, a single FMM has to be implemented for every single seed in order to find the minimum distance for each mesh vertex from each seed (that is, in a 10 seed points scenario, FMM would have to be run 10 times per each mesh vertex)\n\nOn the other side, an exact algorithm -MMP- that leads to 0 error has been presented by Mitchell & al. (MI) in 87, and AFAIK has never been really implmeneted (probably due to the computing power required). On the same exact approach, Surazhsky & al. (SU) provided an alternative exact algorithm based on MMP that should outperform the latter in terms of speed, still leading to a correct result. Unfortunately the computing power required for the calculation, even if much less than the original MMP, is still high enough so that realtime interactive implementation is not feasible at this time.\n(SU) also proposed an approximation of their exact algorithm, what they called flat-exact. It should take the same computational time of FMM, while bringing only 1/5th of the error, but:\n\nc) it is unclear to me if it can be used in a multiple seeds scenario.\n\nOther exact shortest path algorithms have been proposed by Chen & Han (CH) and Kapoor (KP), but while the first is absolutely slow, the second is just too complicated to be implemented in practice.\n\nso.. the bottom line is: I need a distance from a set, not the shortest path between 2 points.\n\nif I got it right,\n\neither I use FMM to get a distance of each vertex from a set in a single pass,\n\n-or-\n\nuse another algorithm to calulate the geodesic from every mesh vertex to every seed point and find the shortest one (and If I got it right that would mean calling that algorithm on every seed point for every mesh vertex, that is, on a 10,000 vertex mesh and a seed set of 50 points, I would have to calculate 500,000 geodesics in order to get the 10,000 shortest one)\n\nAm I missing something? is FMM the only way to deal with multiple seeds distances in a single pass? Someone knows if the flat-exact algorithm may be used in a multiple seed points scenario?\n\nthnx\n\nNotes:\n\n(LA): Lanthier & al. \"Approximating weighted shortest paths on polyhedral surfaces\"\n\n(KS): Kimmel, Sethian \"Computing geodesic paths on manifolds\"\n\n(NV): Novotni \"Computing geodesic distances on triangular meshes\"\n\n(MI): Mitchell & al. \"The discrete geodesic problem\"\n\n(SU): Surazhsky, Kirsanov & al. \"Fast exact and approximate geodesics on meshes\"\n\n(CH): Chen, Han, \"Shortest paths on polyhedron\"\n\n(KP): Kapoor \"Efficient computation of geodeisc shortest paths\"\n    ", "Answer": "\r\nThere is a new paper that discusses exactly how to solve your problem: Geodesics in Heat by Keenan Crane, Clarisse Weischedel and Max Wardetzky. (Just spotted it and it reminded me of your question.) The idea is that the heat equation can be thought of as describing the diffusion of particles from some central point. Although it models random diffusion, if you run the heat equation for a short enough time then any particles that get from A to B must have followed the shortest path so mathematically you can get an estimate of distance.\nThe catch is that the proportion of particles that follow a path close to the shortest path is tiny so you have to solve a differential equation that starts large at some region and rapidly ends up small elsewhere. That's not likely to be well behaved numerically. The trick is that for larger t, even though it doesn't measure distance correctly, it does give the gradient of the distance function and this can be used with other methods to get the distance.\nTL;DR The linked paper solves distance from every point in a mesh to any subdomain, including finite sets of seed points.\nOh...and I haven't tested it myself.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Multiple shortest paths using Dijkstra\r\n                \r\nI'm currently using Dijkstra Algorithm for find shortest path. This algorithm gives me best shortest path but I want to have 2 or more paths. How can I achieve this?\n\nAlgorithm is as follows:\n\n```\npublic class Dijkstra\n{\n    public static void computePaths(Vertex source)\n    {\n        source.minDistance = 0.;\n        PriorityQueue<Vertex> vertexQueue = new PriorityQueue<Vertex>();\n    vertexQueue.add(source);\n\n    while (!vertexQueue.isEmpty()) {\n        Vertex u = vertexQueue.poll();\n\n            // Visit each edge exiting u\n            for (Edge e : u.adjacencies)\n            {\n                Vertex v = e.target;\n                double weight = e.weight;\n                double distanceThroughU = u.minDistance + weight;\n        if (distanceThroughU < v.minDistance) {\n            vertexQueue.remove(v);\n\n            v.minDistance = distanceThroughU ;\n            v.previous = u;\n            vertexQueue.add(v);\n        }\n            }\n        }\n    }\n```\n\n    ", "Answer": "\r\nThere is the Yen top K shortest path algorithm which uses Dijkstra to calculate the optimal path, after that it uses Dijkstra to calculate the second most optimal path etc.\n\nI found a Java implementation for that here: https://github.com/yan-qi/k-shortest-paths-java-version/tree/master/src/main/java/edu/asu/emit/algorithm/graph/shortestpaths\n\nHope that helps\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "python graph_tool: get _all_ shortest paths\r\n                \r\nI want to compute all shortest paths between all pairs in a graph. To achieve this, I am using graph_tool's all_shortest_paths function for every node pair in the graph. According to the documentation, the function is able to respect edge weights, if given. At first glance this works fine. I found, however, that the returned list of shortest paths is incomplete. It seemingly only includes shortest paths, which also use the least amount of hops from the complete set of shortest paths.\n\nHere is a small example: \n\n```\nimport graph_tool\nimport graph_tool.topology\n\n#setup graph\ng = graph_tool.Graph()\ng.add_vertex(5)\nedges = [(0,1),(1,2),(3,2),(0,4),(4,3)]\nmetrics = [3, 4, 2, 1, 3]\ng.edge_properties[\"metric\"] = g.new_edge_property(\"int\")\nfor i in range(len(metrics)):\n    e = g.add_edge(*(edges[i]))\n    g.edge_properties[\"metric\"][e] = metrics[i]\n\n#compute all shortest paths from 0 to 2\npaths = graph_tool.topology.all_shortest_paths(g, 0, 2, weights=g.edge_properties[\"metric\"])\n\nfor path in paths:\n    print(path)\n\nprint(\"-\"*10)\n\n#increase metric of edge 0-4\ng.edge_properties[\"metric\"][g.edge(0,4)] = 2\n\n#recompute all shortest paths from 0 to 2\npaths = graph_tool.topology.all_shortest_paths(g, 0, 2, weights=g.edge_properties[\"metric\"])\n\nfor path in paths:\n    print(path)\n```\n\n\nIt generates a graph with 5 vertices and edges that form 2 paths from vertex 0 to vertex 2 like so:\n\n```\n0 --- 1 --- 2\n \\         /\n  \\       /\n   4 --- 3\n```\n\n\nObviously, the path [0, 1, 2] is shorter than [0, 4, 3, 2] in terms of hop count. If no metric is given, this is correctly recognized (not demonstrated here). \n\nIn the beginning of the example, the edges are weighted in such a way, that the second path, which has more hops, is 'shorter'. The sum of the metrics is 6, whereas the other path has a total value of 7. Consequently, the algorithm correctly returns [0, 4, 3, 2].\n\nThen, the metric of the edge between 0 and 4 is increased by 1. Now both paths have the same total value and should both be returned. Yet, the algorithm only returns [0, 1, 2]. I can only assume that hop count is still somehow factored in, even though I specified a metric, and this is why the second path is neglected. As far as I've seen, there is no mention of this behavior in the official documentation.\n\nAm I overlooking something? Is there a better function to do this, perhaps even if a different library? I already looked into igraph as an alternative, but it does appear to only be capable of computing one shortest path per node pair.\n    ", "Answer": "\r\nThis is behavior is indeed a bug in graph-tool, that occurs when weights are being used! I have just committed a fix that solves it: https://git.skewed.de/count0/graph-tool/commit/dc06771604dfd8f38d40e68ce16b537bc1afc272\n\nThanks for catching this, and for the very clear example!\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "JgraphT - Equal cost shortest paths\r\n                \r\nI am using Jgrapht library for developing a tool and if the graph has multiple equal cost shortest paths, the path computation returns one of the shortest paths randomly every time path computation is run. What is the way to make it deterministic? Is there any way to set tie-breakers?\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Arangodb find conditional shortest paths\r\n                \r\nI need to calculate shortest paths with conditions (conditions may be very hard). I've tried next sample query but it takes me a lot of time\n\n```\nFOR p IN ANY K_SHORTEST_PATHS\n'graph_vertices/1' TO 'graph_vertices/2'\ngraph_edges\nOPTIONS {\n    weightAttribute: 'weight',\n    defaultWeight: 1\n}\nFILTER p.edges[*]._key NONE IN ['736023', '659112', '695090', '731912', '680907', '699903'] \nLIMIT 3\nRETURN {name: CONCAT_SEPARATOR(' -> ', p.edges[*]._key), weight: sum(p.edges[*].weight)}\n```\n\n\nIs there any way to make pre filtration? I mean filter edges collection and then start finding shortest path. May be some other tips which can help me?\n\np.s. I can't use traversal because I don't know about length of path and also I need shortest paths according to weights. \n    ", "Answer": "\r\nDiscussed in slack, arangodb team confirmed that this is currently not supported, created feature request in https://github.com/arangodb/arangodb/issues/10957\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "ArangoDB: Find all shortest paths\r\n                \r\ni want to get all shortest paths between 2 vertex.\n\nExample: Give me all shortest path between node A and B should only return the 2 blue paths\n\n\n\nthis is what i have got so far:\n\n```\nLET source = (FOR x IN Entity FILTER x.objectID == \"organization_1\"\n    return x)[0]\nLET destination = (FOR x IN Entity FILTER x.objectID == \"organization_129\"\n    return x)[0]\nFOR node, edge, path IN 1..2 ANY source._id GRAPH \"m\" \n    FILTER LAST(path.vertices)._id == destination._id\n    LIMIT 100\nRETURN path\n```\n\n\nProblems:\n1. it is very slow (took 18 seconds on a graph with like 70 mio nodes)\n2. it finds every path, but i want only all shortest path\n\nUPDATE\ni tried the 2-step query solution from the comments.\nthe problem is that the second query is also very slow\n\n```\nQuery string:\n FOR source IN Entity FILTER source.objectID == \"organization_1\"\n LIMIT 1\n FOR node, edge, path \n   IN 1..@depth ANY source._id \n   GRAPH \"m\" \n   OPTIONS {uniqueVertices: \"path\"}\n   FILTER node.objectID == \"organization_129\"\n   RETURN path\n\nExecution plan:\n Id   NodeType          Est.   Comment\n  1   SingletonNode        1   * ROOT\n 11   IndexNode            1     - FOR source IN Entity   /* hash index scan */\n  5   LimitNode            1       - LIMIT 0, 1\n  6   CalculationNode      1       - LET #6 = source.`_id`   /* attribute expression */   /* collections used: source : Entity */\n  7   TraversalNode      346       - FOR node  /* vertex */, path  /* paths */ IN 1..2  /* min..maxPathDepth */ ANY #6 /* startnode */  GRAPH 'm'\n  8   CalculationNode    346       - LET #10 = (node.`objectID` == \"organization_129\")   /* simple expression */\n  9   FilterNode         346       - FILTER #10\n 10   ReturnNode         346       - RETURN path\n\nIndexes used:\n By   Type   Collection      Unique   Sparse   Selectivity   Fields                       Ranges\n 11   hash   Entity          false    false       100.00 %   [ `objectID` ]   (source.`objectID` == \"organization_1\")\n  7   edge   ACTIVITYPARTY   false    false       100.00 %   [ `_from`, `_to` ]           base INBOUND\n  7   edge   ACTIVITYPARTY   false    false       100.00 %   [ `_from`, `_to` ]           base OUTBOUND\n  7   edge   ACTIVITY_LINK   false    false       100.00 %   [ `_from`, `_to` ]           base INBOUND\n  7   edge   ACTIVITY_LINK   false    false       100.00 %   [ `_from`, `_to` ]           base OUTBOUND\n  7   edge   ENTITY_LINK     false    false        70.38 %   [ `_from`, `_to` ]           base INBOUND\n  7   edge   ENTITY_LINK     false    false        70.38 %   [ `_from`, `_to` ]           base OUTBOUND\n  7   edge   RELATION        false    false        20.49 %   [ `_from`, `_to` ]           base INBOUND\n  7   edge   RELATION        false    false        20.49 %   [ `_from`, `_to` ]           base OUTBOUND\n  7   edge   SOFT_LINK       false    false       100.00 %   [ `_from`, `_to` ]           base INBOUND\n  7   edge   SOFT_LINK       false    false       100.00 %   [ `_from`, `_to` ]           base OUTBOUND\n\nTraversals on graphs:\n Id   Depth   Vertex collections                      Edge collections                                                 Options                                   Filter conditions\n  7   1..2    Activity, Entity, SOFT_LINK, Property   ACTIVITYPARTY, ENTITY_LINK, SOFT_LINK, RELATION, ACTIVITY_LINK   uniqueVertices: path, uniqueEdges: path   \n\nOptimization rules applied:\n Id   RuleName\n  1   move-calculations-up\n  2   move-filters-up\n  3   move-calculations-up-2\n  4   move-filters-up-2\n  5   use-indexes\n  6   remove-filter-covered-by-index\n  7   remove-unnecessary-calculations-2\n  8   optimize-traversals\n  9   move-calculations-down\n```\n\n    ", "Answer": "\r\nFirst of all you need a hash index on field ```\nobjectID```\n in collection ```\nEntity```\n to avoid the full collection scans, which heavily slows down your performance.\n\nTo get all shortest path I would first search for one shortest path with the AQL ```\nSHORTEST_PATH```\n and return the number of visited vertices. There is also no need of subqueries (like in your query).\n\n```\nFOR source IN Entity FILTER source.objectID == \"organization_1\"\nLIMIT 1\nFOR destination IN Entity FILTER destination.objectID == \"organization_129\"\nLIMIT 1\nRETURN sum(\n  FOR v, e\n  IN ANY\n  SHORTEST_PATH source._id TO destination._id\n  GRAPH \"m\"\n  RETURN 1)-1\n```\n\n\nAfter that I would execute another query with the result from the first query as bind parameter ```\n@depth```\n, which is used to limit the depth of the traversal.\n\n```\nFOR source IN Entity FILTER source.objectID == \"organization_1\"\nLIMIT 1\nFOR node, edge, path \n  IN 1..@depth ANY source._id \n  GRAPH \"m\" \n  OPTIONS {uniqueVertices: \"path\"}\n  FILTER node.objectID == \"organization_129\"\n  RETURN path\n```\n\n\nNote: To filter the last vertex in the path you don't have to use ```\nLAST(path.vertices)```\n, you can simply use ```\nnode```\n because it is already the last vertex (the same applies for ```\nedge```\n).\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "C++ k shortest paths algorithm\r\n                \r\nDoes someone know if there is any production-ready ```\nK-shortest-paths```\n algorithm for ```\nC++```\n?\n\nThe only available implementation (k-shortest-paths), unfortunately, leaks memory, has counter-intuitive interfaces and another \"reinvented wheel\" - the ```\nGraph```\n class.\n\nI'm looking for something better, probably, ```\nboost::graph```\n-based.\n\nThere are two possible algorithms available - ```\nsimple Yen's algorithm```\n and ```\noptimized Yen's algorithm```\n, both would suit me.\n\nThanks in advance.\n    ", "Answer": "\r\nThere is another one, but you'll have to check if this also leaks memory.\n\nhttp://sourceforge.net/projects/ksp/files/ksp/ksp-1.0/\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "FInding All Shortest Paths Between Two Vertices\r\n                \r\nGiven a directed graph ```\nG=(V,E)```\n, two vertices ```\ns```\n, ```\nt```\n and two weight functions ```\nw1```\n, ```\nw2```\n, I need to find the shortest path from ```\ns```\n to ```\nt```\n by ```\nw2```\n among all the shortest paths between ```\ns```\n to ```\nt```\n by ```\nw1```\n.\nFirst of all , how could I find all the shortest paths between two vertices ```\ns```\n and ```\nt```\n? Dijkstra's algorithm helps us find shortest path from a vertex to to every other accessible vertex, is it possible to modify it in order to get all the shortest paths between two vertices?\n    ", "Answer": "\r\nThis is quite strightforward. Completely from Wikipedia:\n\n\n  A more general problem would be to find all the shortest paths between source and target (there might be several different ones of the same length). Then instead of storing only a single node in each entry of previous[] we would store all nodes satisfying the relaxation condition. For example, if both r and source connect to target and both of them lie on different shortest paths through target (because the edge cost is the same in both cases), then we would add both r and source to previous[target]. When the algorithm completes, previous[] data structure will actually describe a graph that is a subset of the original graph with some edges removed. Its key property will be that if the algorithm was run with some starting node, then every path from that node to any other node in the new graph will be the shortest path between those nodes in the original graph, and all paths of that length from the original graph will be present in the new graph. Then to actually find all these shortest paths between two given nodes we would use a path finding algorithm on the new graph, such as depth-first search.\n\n\nIn other words, after Dijkstra terminates, you should be able to know all the previous nodes for the nodes on the shortest path from ```\ns```\n to ```\nt```\n, and do a backward BFS/DFS with these edges would give you all the shortest pathes.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Find all shortest paths using TraversalDescription\r\n                \r\nI need to find all all shortest paths between two nodes using TraversalDescription.\n\n(I cannot use Cypher procedure allShortestPaths() because I need to add some specific evaluator later:\nNeo4J: shortest paths with specific relation types sequence constrain\n)\n\n```\nNode startNode = ...;\nNode endNode = ...;\nTraversalDescription td = graphDb.traversalDescription()\n    .breadthFirst()\n    .evaluator(Evaluators.endNodeIs(Evaluation.INCLUDE_AND_PRUNE,\n                                    Evaluation.EXCLUDE_AND_CONTINUE,\n                                    endNode));\n\nfor (Path path : td.traverse(startNode)) {\n    // only 1 path found\n}\n```\n\n\nI get only 1 path.\n\nBut if I run the Cypher query:\n\n```\nMATCH (startNode{...})\nMATCH (endNode{...})\nMATCH path = allShortestPaths((startNode)-[*]-(endNode))\nRETURN path;\n```\n\n\nThere are more then one paths found for the same startNode and endNode.\n\nHow to set up the TraversalDescription to find all (shortest) paths?\n    ", "Answer": "\r\nSome suggestions:\n\n\nTake a look at how ```\nshortestpath```\n and ```\nallshortestpths```\n are actually implemented. You may be able to modify a copy of the code to do what you want.\nTraversaDescription is not used at all.\nThere is also an \"experimental\" BidirectionalTraversalDescription that seems to be closer to the design of the ```\nshortestpath```\n and ```\nallshortestpths```\n implementations. You might be able to use that instead.\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Finding all the shortest paths between two nodes in unweighted undirected graph\r\n                \r\nI need help finding all the shortest paths between two nodes in an unweighted undirected graph.   \n\nI am able to find one of the shortest paths using BFS, but so far I am lost as to how I could find and print out all of them. \n\nAny idea of the algorithm / pseudocode I could use?\n    ", "Answer": "\r\nAs a caveat, remember that there can be exponentially many shortest paths between two nodes in a graph.  Any algorithm for this will potentially take exponential time.\nThat said, there are a few relatively straightforward algorithms that can find all the paths. Here's two.\nBFS + Reverse DFS\nWhen running a breadth-first search over a graph, you can tag each node with its distance from the start node. The start node is at distance 0, and then, whenever a new node is discovered for the first time, its distance is one plus the distance of the node that discovered it. So begin by running a BFS over the graph, writing down the distances to each node.\nOnce you have this, you can find a shortest path from the source to the destination as follows. Start at the destination, which will be at some distance d from the start node. Now, look at all nodes with edges entering the destination node. A shortest path from the source to the destination must end by following an edge from a node at distance d-1 to the destination at distance d. So, starting at the destination node, walk backwards across some edge to any node you'd like at distance d-1. From there, walk to a node at distance d-2, a node at distance d-3, etc. until you're back at the start node at distance 0.\nThis procedure will give you one path back in reverse order, and you can flip it at the end to get the overall path.\nYou can then find all the paths from the source to the destination by running a depth-first search from the end node back to the start node, at each point trying all possible ways to walk backwards from the current node to a previous node whose distance is exactly one less than the current node's distance.\n(I personally think this is the easiest and cleanest way to find all possible paths, but that's just my opinion.)\nBFS With Multiple Parents\nThis next algorithm is a modification to BFS that you can use as a preprocessing step to speed up generation of all possible paths.  Remember that as BFS runs, it proceeds outwards in \"layers,\" getting a single shortest path to all nodes at distance 0, then distance 1, then distance 2, etc.  The motivating idea behind BFS is that any node at distance k + 1 from the start node must be connected by an edge to some node at distance k from the start node.  BFS discovers this node at distance k + 1 by finding some path of length k to a node at distance k, then extending it by some edge.\nIf your goal is to find all shortest paths, then you can modify BFS by extending every path to a node at distance k to all the nodes at distance k + 1 that they connect to, rather than picking a single edge.  To do this, modify BFS in the following way: whenever you process an edge by adding its endpoint in the processing queue, don't immediately mark that node as being done.  Instead, insert that node into the queue annotated with which edge you followed to get to it.  This will potentially let you insert the same node into the queue multiple times if there are multiple nodes that link to it.  When you remove a node from the queue, then you mark it as being done and never insert it into the queue again.  Similarly, rather than storing a single parent pointer, you'll store multiple parent pointers, one for each node that linked into that node.\nIf you do this modified BFS, you will end up with a DAG where every node will either be the start node and have no outgoing edges, or will be at distance k + 1 from the start node and will have a pointer to each node of distance k that it is connected to.  From there, you can reconstruct all shortest paths from some node to the start node by listing of all possible paths from your node of choice back to the start node within the DAG.  This can be done recursively:\n\nThere is only one path from the start node to itself, namely the empty path.\nFor any other node, the paths can be found by following each outgoing edge, then recursively extending those paths to yield a path back to the start node.\n\nThis approach takes more time and space than the one listed above because many of the paths found this way will not be moving in the direction of the destination node. However, it only requires a modification to BFS, rather than a BFS followed by a reverse search.\nHope this helps!\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Minimize absolute difference between shortest paths\r\n                \r\nI am trying to solve the following shortest path problem:\n\n\n  There are 2 friends travelling to a city C from cities A and B (one starts at A, the other at B). Find\n  the shortest paths that these 2 friends could take from A to C and B to\n  C that minimizes the absolute difference between the distance of the 2\n  shortest paths.\n\n\nI am thinking that using computing shortest paths from A to C and B to C and taking their difference might just work. I do not know whether my solution is correct or how to prove it. Could anyone give me some advice?\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest paths excluding one node\r\n                \r\nI am working on a query on the movie database to check the shortest paths between n nodes. In this simplified example, we want all the shortest paths between 2 movies:\n\n```\nmatch p=allShortestPaths((n)-[*]-(m)) where id(n) = 87 and id(m) = 121\nreturn p;```\n\n\n\n\nNow I want to have all the shortest paths that don't include Keanu Reeves in it.\nI tried this: \n\n```\nmatch p=allShortestPaths((n)-[*]-(m)) where id(n) = 87 and id(m) = 121 and NONE(n in nodes(p) where n.name = \"Keanu Reeves\")\nreturn p;```\n\n\nThis however takes an eternity to load, even after I have indexed the name field of Person...\n\nThen In tried the following: \n\n```\nmatch p=allShortestPaths((n)-[*]-(m)) where id(n) = 87 and id(m) = 121\nwith p WHERE NONE(n in nodes(p) where n.name = \"Keanu Reeves\")\nreturn p;```\n\n\nThis however gives me no results. I misinterpreted this by thinking it would just return those paths which don't have Keanu Reeves in between:\n\n```\n(no changes, no records)```\n\n\nI tested if I could get only those with Keanu Reeves in between with the ```\nany()```\n function. This works perfectly:\n\n```\nmatch p=allShortestPaths((n)-[*]-(m)) where id(n) = 87 and id(m) = 121\nwith p WHERE ANY(n in nodes(p) where n.name = \"Keanu Reeves\")\nreturn p;```\n\n\n\n\nWhat is the best approach to tackle this? I must say that my production query is way more complex than this, but it all boils down to this problem. It has to be a performant solution.\n    ", "Answer": "\r\nThe problem is that if one of the nodes from the path does not have the property ```\nname```\n, then the entire check will not be passed.\n\nSo or do we check for the existence of a property:\n\n```\nmatch p=allShortestPaths((n)-[*]-(m)) \nwhere \n    n.title = 'The Replacements' and \n    m.title = 'Speed Racer' and\n    NONE(n in nodes(p) where EXISTS(n.name) and n.name = \"Keanu Reeves\")\nreturn p\n```\n\n\nOr use the ```\nCOALESCE```\n function:\n\n```\nmatch p=allShortestPaths((n)-[*]-(m)) \nwhere \n    n.title = 'The Replacements' and \n    m.title = 'Speed Racer' and\n    NONE(n in nodes(p) where COALESCE(n.name, '') = \"Keanu Reeves\")\nreturn p\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Elementary shortest path problem vs. shortest path problem\r\n                \r\nWhat is the difference between an elementary shortest path problem and shortest path problem?\n\nA shortest path problem, is solved by finding the shortest path from a source node s to a target node t in a graph.\n\nA simple shortest path problem, is solved by finding the shortest path from a source node s to a target node t in a graph, such that each arc in the shortest path is used at most 1 time.\n\nWhat is an elementary shortest path?\n    ", "Answer": "\r\nThe term \"elementary shortest path\" means \"a shortest path that doesn't repeat any nodes or edges.\" If you're looking to compute the shortest path from one node to another in a graph with no negative cycles, then there's no difference between \"shortest path\" and \"elementary shortest path,\" since they mean the same thing. However, \"shortest path\" in other contexts might not be the same as \"elementary shortest path.\" For example:\n\n\nIf your goal is to find a path that starts at some node s, ends at some node t, and visits all the nodes in some set X along the way, the shortest path that does so may not be the same as the elementary shortest path. There may not even be an elementary shortest path that accomplishes this goal, depending on the shape of the graph.\nIf the graph has negative cycles, then the notion of \"the shortest path from s to t\" might not be mathematically well-defined, because following a negative cycle over and over and over will keep dropping the cost. However, the \"elementary shortest path\" may is defined provided there's a path from s to t, since you can't follow negative cycles.\n\n\nHope this helps!\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "QuickGraph - Ranked Shortest Path - paths missing\r\n                \r\nBit of a long shot here as I've not found too much documentation on the             ```\nHoffmanPavleyRankedShortestPathAlgorithm```\n in QuickGraph, so I'm guessing not a lot of people use it, but I'm having a few issues returning the correct results with the Ranked Shortest Path Algorithm and wonder if anyone had found the same problem.\n\nI'm populating a BiDirectional graph with 1900 Vertices and 20000 Edges, and I've set the graph to return 150 paths.  It does this, but it doesn't bring back several paths that would be expected, namely one that should rank in the top 20 shortest paths.  My expectation of the system is that if I asked for 150 paths, it would return the 150 shortest paths in order.\n\nNow, when I set it to return over 1000 paths, then the expected path shows up.  Has anyone come across a problem like this before and might have a way of refining the graph set up? I can't have the system return 1000 paths because it takes far too long to process.\n\nHere is the relevant code:\nGraph setup:\n\n```\nBidirectionalGraph<string, TaggedEdge<string, int>> pathGraph = new BidirectionalGraph<string, TaggedEdge<string, int>>();\n\n... add vertices and edges\n```\n\n\nAlgorithm setup:\n\n```\nHoffmanPavleyRankedShortestPathAlgorithm<string, TaggedEdge<string, int>> hoffmanAlgorithm = new HoffmanPavleyRankedShortestPathAlgorithm<string, TaggedEdge<string, int>>(pathGraph, E => 1.0);\ntry\n{\n    hoffmanAlgorithm.ShortestPathCount = 150;\n    hoffmanAlgorithm.SetRootVertex(startPoint.ToString());\n    hoffmanAlgorithm.Compute(startPoint.ToString(), endPoint.ToString());\n\n    foreach (IEnumerable<TaggedEdge<string, int>> path in hoffmanAlgorithm.ComputedShortestPaths)\n    {\n         //process results...\n    }\n}\n```\n\n\nAs I said, I'm not overly confident of getting a response here, but thought I'd try anyway. The QuickGraph discussion forum on CodePlex doesn't seem to be manned anymore\nor I would try there.\n\nThanks very much\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest Paths Faster - SPFA Algorithm?\r\n                \r\nI am implementing a k-shortest vertex-disjoint paths algorithm and need a\nfast algorithm to find the shortest path. There are negative weights so I cant\nuse dijkstra and bellman-ford is O(ne). In a paper I read recently the authors\nused a so called SPFA algorithm for finding the shortest path in a graph with\nnegative weight, which - according to them - has a complexity of O(e). Sounds\ninteresting, but I cant seem to find information on the algorithm. Appearently\nthis: http://en.cnki.com.cn/Article_en/CJFDTOTAL-XNJT402.015.htm is the original\npaper, but I dont have access to it.\n\nDoes anyone have good information or maybe an implementatin of this algorithm?\nAlso, is there any source for the k-shortest vertex-disjoint paths problem available?\nI cant find anything.\n\nThanks!\n    ", "Answer": "\r\nThe SPFA algorithm is an optimization over Bellman-Ford. While in Bellman-Ford we just blindly go through each edge for |V| rounds, in SPFA, a queue is maintained to make sure we only check those relaxed vertices. The idea is similar to Dijkstra's. It also has the same flavor with BFS, but a node can be put in the queue multiple times.\n\nThe source is first added into the queue. Then, while the queue is not empty, a vertex u is popped from the queue, and we look at all its neighbors v. If the distance of v is changed, we add v to the queue (unless it is already in the queue).\n\nThe author proved that SPFA is often fast (\\Theta(k|E|), where k < 2).\n\nHere is pseudo code from wikipedia in Chinese, where you can also find an implementation in C.\n\n```\nProcedure SPFA;\nBegin\n  initialize-single-source(G,s);\n  initialize-queue(Q);\n  enqueue(Q,s);\n  while not empty(Q) do \n    begin\n      u:=dequeue(Q);\n      for each v∈adj[u] do \n        begin\n          tmp:=d[v];\n          relax(u,v);\n          if (tmp<>d[v]) and (not v in Q) then\n            enqueue(Q,v);\n        end;\n    end;\nEnd;\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Modified Shortest path algorithm, forbidden paths\r\n                \r\nWe are provided with a graph G = (V, E), where each edge is associated with some positive weight (W[i] > 0). We are asked to find the shortest path from A to B provided we follow the following conditions :\n\nWe are also given some forbidden paths, say x. The goal is the shortest path should not contain any forbidden path as its sub-path. \n\nFor example: Consider a graph G with 4 vertices and 5 edges (1, 2, 1), (2, 1, 1), (1, 4, 5), (1, 3, 1.5), (3, 4, 1). Here, the 3rd entity in the bracket denotes the weight of edge between 'u' and 'v'. We are required to find the shortest path between 1 and 4, and the list of forbidden paths contains only the path 1->3->4.\n\nThe paths from 1 to 4 are 1 -> 4, 1 -> 2 -> 3 -> 4, 1 -> 3 -> 4.\n\nOut of these, only 1st 2 are valid paths, and among them the shortest path is 1 -> 2 -> 3 -> 4 of total weight as 3.0.\n\nIs there an efficient algorithm for the above task? Please describe the algorithm with the complexity analysis. I would be highly thankful if you could provide a code as well.\n    ", "Answer": "\r\nYou can preprocess the graph in such a way to embed forbidden paths in-to it. For every forbidden path you duplicate vertices which belong to it and then drop some of the edges. That duplicates would have special meaning: walking along duplicated edge would mean that you have come to a vertex along the forbidden path and you can't walk along the last edge of it. If you are walking along original edges, then you have come somewhere to the middle of forbidden path so it does not affect you. To achieve that you drop all incoming edges to a duplicate path excepting edge to it's second vertex from it's first vertex. But you drop that edge from original path.\n\na forYou split vertices which are part of forbidden paths in-to several virtual vertices and drop some of the edges. Let's suppose that in following graph path ABC is forbidden:\n\n```\nA-->B-->C\nD->/\n```\n\n\nThen you split B to BA and BD (depending from which vertex you have come to B) and drop  BA->C edge.\n\n```\nA->BA  /->C\nD->BD-/\n```\n\n\nNow you can use classic dijkstra on that preprocessed graph.\n\nMore complex example, let's suppose that ABCF is forbidden:\n\n```\n    G->\\\nA-->B-->C-->F\nD->/ \\->E\n```\n\n\nSo we duplicate B and C as internal vertices of the forbidden route, we drop A->B edge and leave only A->B'. We also drop all other incoming edges to B' and C' but we leave B'->E edge because it drives away from forbidden route. We also drop C'->F edge.\n\n```\n /->B'-->C'\n|    \\------->\\\n|              \\\n|   G->\\        \\\nA   B-->C---->F  \\\nD->/ \\----------->E\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path in a directed, unweighted graph with a selection criterion between multiple shortest paths?\r\n                \r\nI am looking for the best way to solve this variation on the shortest-path problem:\n\nI have a directed graph with unweighted edges. I need to be able to find the shortest path between any two nodes, if such a path exists. What makes this problem different than a regular shortest path problem is this: If multiple paths exist with shortest length, I need to be able to choose the path with the highest \"authority\". \n\nEach node has a numerical authority and the path with the highest authority is simply the one with the highest sum of node authorities.\n\nIn summary:\nI need the shortest path between a pair of nodes in a directed graph, but if there are multiple paths with the same, minimum length, I need to find the one with the highest path authority.\n\nWhat is the best way to go about doing this? Is there some way to convert this into a weighted graph and then just use Dijkstra's algorithm? Is there some way to modify breadth-first search to give me the set of shortest paths, which I can then iterate through to find the highest authority path?\n    ", "Answer": "\r\nThe edges are unweighted, so give eacn edge a weight of ```\n1+auth(v,u)```\n. [auth is explained in the following line]\n\nfor each (v,u) set ```\nauth(v,u) = max{authority} - authority(v)```\n (*) [this is true becuase if you use the edge leaving from ```\nv```\n, you definetly visited it].\n\n(*)```\nmax{authority}```\n is the the highest authority in the graph.\n\nnormalize your \"auth rank\" so, ```\nSigma(auth(v,u),for each (v,u) in E) < 1```\n [by dividing, so the authority of edges will still be proportional to the original]\n\nnow, run dijkstra on the graph with the new modified weights. \n\nThe shortest path found must be shortest, because the authority factor cannot overcome the distance factor, because it is to 'weak' [normalized to less then 1].\nAnd it is the one with the highest ```\nauthority```\n [for vertices], since it is the one with the lowest ```\nauth```\n [for edges], since it is minimal.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Floyd-Warshall algorithm: get the shortest paths\r\n                \r\nAssume a graph is represented by a ```\nn x n```\n dimension adjacency matrix. I know the how to get the shortest path matrix for all pairs. But I wonder is there a way to trace all the shortest paths?\nBlow is the python code implementation.\n\n```\nv = len(graph)\nfor k in range(0,v):\n    for i in range(0,v):\n        for j in range(0,v):\n            if graph[i,j] > graph[i,k] + graph[k,j]:\n                graph[i,j] = graph[i,k] + graph[k,j]\n```\n\n    ", "Answer": "\r\nYou have to add to your if statement a new matrix to store path reconstruction data (array ```\np```\n which is predecessor matrix):\n\n```\n    if graph[i,j] > graph[i,k] + graph[k,j]:\n        graph[i,j] = graph[i,k] + graph[k,j]\n        p[i,j] = p[k,j]\n```\n\n\nAt the beginning the matrix ```\np```\n have to be filled as:\n\n```\nfor i in range(0,v):\n    for j in range(0,v):\n        p[i,j] = i\n        if (i != j and graph[i,j] == 0):\n             p[i,j] = -30000  # any big negative number to show no arc (F-W does not work with negative weights)\n```\n\n\nTo reconstruct the path between ```\ni```\n and ```\nj```\n nodes you have to call:\n\n```\ndef ConstructPath(p, i, j):\n    i,j = int(i), int(j)\n    if(i==j):\n      print (i,)\n    elif(p[i,j] == -30000):\n      print (i,'-',j)\n    else:\n      ConstructPath(p, i, p[i,j]);\n      print(j,)\n```\n\n\nAnd the test with above function:\n\n```\nimport numpy as np\n\ngraph = np.array([[0,10,20,30,0,0],[0,0,0,0,0,7],[0,0,0,0,0,5],[0,0,0,0,10,0],[2,0,0,0,0,4],[0,5,7,0,6,0]])\n\nv = len(graph)\n\n# path reconstruction matrix\np = np.zeros(graph.shape)\nfor i in range(0,v):\n    for j in range(0,v):\n        p[i,j] = i\n        if (i != j and graph[i,j] == 0): \n            p[i,j] = -30000 \n            graph[i,j] = 30000 # set zeros to any large number which is bigger then the longest way\n\nfor k in range(0,v):\n    for i in range(0,v):\n        for j in range(0,v):\n            if graph[i,j] > graph[i,k] + graph[k,j]:\n                graph[i,j] = graph[i,k] + graph[k,j]\n                p[i,j] = p[k,j]\n\n# show p matrix\nprint(p)\n\n# reconstruct the path from 0 to 4\nConstructPath(p,0,4)\n```\n\n\nOutput:\n\np:\n\n```\n[[ 0.  0.  0.  0.  5.  1.]\n [ 4.  1.  5.  0.  5.  1.]\n [ 4.  5.  2.  0.  5.  2.]\n [ 4.  5.  5.  3.  3.  4.]\n [ 4.  5.  5.  0.  4.  4.]\n [ 4.  5.  5.  0.  5.  5.]]\n```\n\n\nPath 0-4:\n\n```\n0\n1\n5\n4\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Dijkstra algorithm: Are all shortest paths acyclic?\r\n                \r\nI know that the algorithm wont terminate if it reaches negativ cycles and\na path wouldnt be a shortest path, if it would contain a cycle with distance greater than 0.\n\nMy question is what happens if there exists a shortest path with a cycle of distance 0 , would the algorithm include that cycle into the shortest path?\n\nWould you say all shortest paths are acyclic?\n    ", "Answer": "\r\nWith the Dijkstra algorithm, All paths are guaranteed to be acyclic as long as there are no negative paths. Dijkstra adds a path to a node as soon as a path is found, and only updates that path if a new, cheaper path is found. Since 0 < 0 is false, the algorithm won't bother considering that path, so 0 edge cycles will be ignored.\n\nThis does not mean a shortest path can't be cyclic. (if there is a negative edge cycle, you can go into an infinite loop, or if there is a zero edge cycle, a path that takes it 5 times is just as valid as one that takes it once.) It's just Dijkstra is optimized to ignore anything that takes extra pointless computing, so Dijkstra will never produce a path with a cycle. Key point here being just because a cycle is not returned, does not imply they do not exist.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How to find all the shortest paths by using A* algorithm?\r\n                \r\nI know A* algorithm can find the shortest path. But the problem in my work is that I need to find all the shortest paths. More precisely, there may exist several shortest paths, but I need to choose the one shortest path in the precedence of clockwise.\n\nIf I can get all the shortest paths, I can get the one(clockwise precedence) I want.\n    ", "Answer": "\r\nThe thing with the A* algorithm is that it is complete and optimal. That means that it will find a path to the solution if a path exists but also, that it is guaranteed to find the shortest path first.\n\nThat is because the heuristic function A* uses must be an admissible heuristic; that is, it must not overestimate the distance to the goal.\n\nThis in turn ensures that as soon as you find a path to the solution, you know that there are no paths shorter than that one in the rest of the search space.\n\nLet's say that the distance to your first solution was d(problem). Now, my last statement actually means, if you just keep going after you find the first solution d(problem), and find another solution, d2(problem) there are two possibilities:\n\n\nd2(problem) = d(problem) : you want to keep that one since you want all the optimal paths. Also, all new paths can be equal to or larger than d2 = d\nd2(problem) > d(problem) : now, the same thing I wrote above is valid: there are no paths shorter than d2 anymore. And, d2 is already longer than the solutions you are looking for. So, you can discard d2 and finish your search\nnote that there is no third option, d2(problem) can never be shorter than the optimal d(problem) you already found because that is one of the basic properties of the algorithm.\n\n\nSo, to summarize: you just keep going after you find the first optimal solutions, and you accept all the solutions that are of the same distance. First path that has a worse (longer) distance, you discard and stop your search.\n\n\n\nI just saw the \"clockwise\" part of the question. You can probably avoid searching for all the optimal solutions by somehow inserting the clockwise-ness in to your heuristic or your cost function. E.g. a trick I've been using sometimes is: you have your cost as an integer number, going from 0 to inf. And then, you add the clockwise-ness component, that can have real values from the interval [0, 1) . This way, wherever it was true ```\na > b```\n before, it will stay so, but the relation ```\na == b```\n might be changed if the clockwise-ness component is different.\n\nA different way you can compare, if you do not explicitly want to work with a numeric value, is to have the cost be a pair of values. If the first component of the pair is different in two path costs, you just compare those. If the first components are the same, only then you compare the second values in the pairs.\n\nThat said, off the top of my head, I am not sure if I would advise you to modify your cost or your heuristic function (or both). Also, I'm not sure if this precise trick will work in your problem, but I believe that you should be able to stir the algorithm towards the most clockwise solution just by modifying one of these functions if you just play a little.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "All-Pairs Shortest Paths by Dijkstra [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                This question is unlikely to help any future visitors; it is only relevant to a small geographic area, a specific moment in time,  or an extraordinarily narrow situation that is not generally applicable to the worldwide audience of the internet. For help making  this question more broadly applicable, visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI searched for the Java implementation of all-pairs shortest paths by Dijkstra.\nI found an algorithm for one source shortest path. I actually don't know Java, but I'm studying discrete mathematics, so maybe someone can help me. What I have to change to make it an all-pairs shortest path? \n\n----------Edit -------\nthanks templatetypedef again. i try it. now i think there is another little mistake in the code.\n\nThe input file(try.txt):\n\n```\n 0 2 68\n 3 4 97\n 0 3 8\n```\n\n\nThis is the wrong output i get:\n\n```\n    From 3:\nShortest Path Cost to 3 is: 0.0\nShortest Path Cost to 2 is: Infinity\nShortest Path Cost to 0 is: Infinity\nShortest Path Cost to 4 is: 97.0\n\nFrom 2:\nShortest Path Cost to 3 is: Infinity\nShortest Path Cost to 2 is: 0.0\nShortest Path Cost to 0 is: Infinity\nShortest Path Cost to 4 is: 97.0\n\nFrom 0:\nShortest Path Cost to 3 is: 8.0\nShortest Path Cost to 2 is: 68.0\nShortest Path Cost to 0 is: 0.0\nShortest Path Cost to 4 is: 97.0\n\nFrom 4:\nShortest Path Cost to 3 is: 8.0\nShortest Path Cost to 2 is: 68.0\nShortest Path Cost to 0 is: Infinity\nShortest Path Cost to 4 is: 0.0\n```\n\n\nThe code: \n\n```\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\n\nclass Vertex implements Comparable<Vertex> {\n    public final String name;\n    public List<Edge1> adjacencies;\n    public double minDistance = Double.POSITIVE_INFINITY;\n    public Vertex previous;\n\n    public Vertex(String argName) {\n        name = argName;\n        adjacencies = new ArrayList<Edge1>();\n    }\n\n    public void addEdge(Edge1 e) {\n        adjacencies.add(e);\n    }\n\n    public String toString() {\n        return name;\n    }\n\n    public int compareTo(Vertex other) {\n        return Double.compare(minDistance, other.minDistance);\n    }\n\n}\n\nclass Edge1{\n    public final Vertex target;\n    public final double weight;\n\n    public Edge1(Vertex argTarget, double argWeight) {\n        target = argTarget;\n        weight = argWeight;\n    }\n}\n\n\npublic class Dijkstra {\n\n    public static void computePaths(Vertex source) {\n        source.minDistance = 0.;\n        PriorityQueue<Vertex> vertexQueue = new PriorityQueue<Vertex>();\n        vertexQueue.add(source);\n\n        while (!vertexQueue.isEmpty()) {\n            Vertex u = vertexQueue.poll();\n\n            // Visit each Edge exiting u\n\n            for (Edge1 e : u.adjacencies) {\n                Vertex v = e.target;\n                double weight = e.weight;\n                double distanceThroughU = u.minDistance + weight;\n                if (distanceThroughU < v.minDistance) {\n                    vertexQueue.remove(v);\n                    v.minDistance = distanceThroughU;\n                    v.previous = u;\n                    vertexQueue.add(v);\n                }\n\n            }\n        }\n    }\n\n    public static List<Vertex> getShortestPathTo(Vertex target) {\n        List<Vertex> path = new ArrayList<Vertex>();\n        for (Vertex vertex = target; vertex != null; vertex = vertex.previous)\n            path.add(vertex);\n\n        Collections.reverse(path);\n        return path;\n    }\n\n    public static void main(String args[]) {\n\n        Map<String, Vertex> vertexMap = new HashMap<String, Vertex>();\n        BufferedReader in = null;\n        try {\n            in = new BufferedReader(new FileReader(\"try.txt\"));\n            String line;\n            boolean inVertex = true;\n\n            while ((line = in.readLine()) != null) {\n\n\n                    //store the edges\n                    String[] parts = line.split(\" \");\n                    String vFrom = parts[0];\n                    String vTo = parts[1];\n                    if(!vertexMap.containsKey(vFrom))\n                    {\n                        Vertex v= new Vertex(vFrom);\n                        vertexMap.put(vFrom, v);\n                    }\n                    if(!vertexMap.containsKey(vTo))\n                    {\n                        Vertex v1= new Vertex(vTo);\n                        vertexMap.put(vTo, v1);\n                    }\n\n\n                    double weight = Double.parseDouble(parts[2]);\n                    Vertex v = vertexMap.get(vFrom);\n                    if (v != null) {\n                        v.addEdge(new Edge1(vertexMap.get(vTo), weight));\n\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            return;\n        }\n        finally{\n            if(in!= null)\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n        }\n\n        //get a list of all the vertices\n        Collection<Vertex> vertices = vertexMap.values();\n\n        //Vertex source = vertices.iterator().next();\n        for(Vertex source:vertices){\n        System.out.println(\"From \" + source+\":\");\n        computePaths(source);\n        for (Vertex v : vertices) {\n            System.out.println(\"Shortest Path Cost to \" + v + \" is: \" + v.minDistance);\n           // List<Vertex> path = getShortestPathTo(v);\n          //  System.out.println(\"Path: \" + path);\n        }System.out.println();\n        source.minDistance=Double.POSITIVE_INFINITY;\n        source.previous=null;}\n    }\n}\n```\n\n    ", "Answer": "\r\nTo compute all-pairs shortest paths with Dijkstra's algorithm, you would just rerun Dijkstra's algorithm multiple times, one for each possible starting node.  You should be able to easily adapt the above algorithm to get this logic to work by calling ```\ncomputePaths(source)```\n for each possible source and remembering the shortest paths found at each point.\n\nHope this helps!\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest paths graph\r\n                \r\nGiven a directed graph G , weights, s source vertex and d[v] for each vertex in the graph (the distance from s to v)\nI need to find an algorithm that builds the shortest paths graph.\n\nI was thinking of going on edges by BFS but than how can I know which edge should be in the tree and how to check that the d[v] for each vertex is true.\n    ", "Answer": "\r\nRun Dijkstra. If an edge e connecting {u,v} has the property that d[u]+w[e]=d[v] then that edge is part of the tree you are looking for.\n\nThis way, you may not actually end up with a tree, but any MST has the properties you are looking for\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Algorithms. Single source shortest paths. Dijkstra's algorithm\r\n                \r\nHow do I find all possible shortest paths from a source vertex to more than one destination, such that the edge-weights in the shortest paths tree are in decreasing order of weights?\n    ", "Answer": "\r\nLet us assume here a strict decreasing of the weights among a path. \n\nThis implies that when considering a given path, we have to memorize/consider not only the corresponding total distance, but also the value of the last weight.\n\nTherefore, at a given node, we have to memorize different possible paths, i.e. different pairs (total distance, last weight), and not only one. This does not not mean that all combinations must be memorized. For example, if we have two paths (13,2) and (15,2), only (13,2) is kept. In the same spirit, if we get (10,3) and (10,2), only (10,3) must be kept. \n\nThis is illustrated in figure hereafter, hopefully self explaining. I assume directed edges here. \n\n```\n     3                     4                      2\nA(3,3) -->C (6,2), (11,5)---->D (11,4), (13,3) ------>F (13,2)\n|         |                   |                      NB: (15,2) skipped\n|3        |5                  |3\n|         |             4     |\nS ------->B (6,6)------------>E (10, 4)\n    6      \n```\n\n\nIn practice, existing short path finding algorithms should be adapted for that. My understanding is that for example the Floyd–Warshall algorithm\ncan be adapted for that purpose. \n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "The best shortest path algorithm\r\n                \r\nWhat is the difference between the \"Floyd-Warshall algorithm\" and \"Dijkstra's Algorithm\", and which is the best for finding the shortest path in a graph?\n\nI need to calculate the shortest path between all the pairs in a net and save the results to an array as follows:\n\n```\n**A     B     C     D      E**\nA 0     10    15    5     20\nB 10     0    5     5     10\nC 15     5    0     10    15\nD 5      5    10    0     15\nE 20     10    15   15    0\n```\n\n    ", "Answer": "\r\nDijkstra's algorithm finds the shortest path between a node and every other node in the graph.  You'd run it once for every node.  Weights must be non-negative, so if necessary you have to normalise the values in the graph first.\n\nFloyd-Warshall calculates the shortest routes between all pairs of nodes in a single run!  Cycle weights must be non-negative, and the graph must be directed (your diagram is not).\n\nJohnson's algorithm is using Dijkstra's algorithm to find all pairs in a single pass, and is faster for sparse trees (see the link for analysis).\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest Path Implementation Issue\r\n                \r\nI am implementing the Shortest Path Problem in C++. Basically the user enters a ```\nSourceVertex```\n and the function ```\nFindShortestPath(int SourceVertex)```\n finds and prints the shortest paths from the ```\nSourceVertex```\n to all the remaining vertices.\n\n```\nvoid Graph::FindShortestPath(int SourceVertex)\n{\n    cout<<\"The shortest paths from \"<<SourceVertex<<\" are\"<<endl;\n    //initialize the ShortestPathArray\n    for(int a=0;a<NumberOfVertices;a++)\n        ShortestPathArray[a]=numeric_limits<int>::max();\n    ShortestPathArray[SourceVertex]=0;\n\n    for(int a=0;a<NumberOfVertices;a++)\n    {\n        if(WeightMatrix[SourceVertex][a]!=0)\n            ShortestPathArray[a]=WeightMatrix[SourceVertex][a];\n\n    }\n    cout<<\"Direct Edges Length\"<<endl;\n    for(int a=0;a<NumberOfVertices;a++)\n    {\n        cout<<SourceVertex<<\"->\"<<a<<\"=\"<<ShortestPathArray[a]<<endl;\n    }\n    cout<<\"Shortest Path after updating\"<<endl;\n\n    for(int a=0;a<NumberOfVertices;a++)\n        for(int b=0;b<NumberOfVertices;b++)\n\n            if(WeightMatrix[a][b]!=0)//edge exists\n            {   if(ShortestPathArray[b]>(ShortestPathArray[a]+WeightMatrix[a][b]))\n            {\n                ShortestPathArray[b]= ShortestPathArray[a]+WeightMatrix[a][b];}}   \n\n    for(int a=0;a<NumberOfVertices;a++)\n    cout<<SourceVertex<<\"->\"<<a<<\"=\"<<ShortestPathArray[a]<<endl;}\n```\n\n\nI get the following output\n\n```\nThe shortest paths from 4 are\nDirect Edges Length\n4->0=2147483647\n4->1=6\n4->2=10\n4->3=4\n4->4=0\nShortest Path after updating\n4->0=2147483647\n4->1=-2147483645\n4->2=-2147483646\n4->3=-2147483644\n4->4=-2147483647\n```\n\n\nThe first set that is printed is correct. Something in wrong in the updating part. I can't seem to figure that out. \n\nEDIT-1\n\n```\nint main(){\n\n    Graph g(5);\n    g.AddEdge(0,4,2);\n    g.AddEdge(0,2,3);\n    g.AddEdge(0,1,5);\n    g.AddEdge(1,3,6);\n    g.AddEdge(1,2,2);\n    g.AddEdge(4,3,4);\n    g.AddEdge(4,1,6);\n    g.AddEdge(4,2,10);\n    g.AddEdge(2,1,1);\n    g.AddEdge(2,3,2);\n    g.FindShortestPath(4);\n\n    return 0;\n\n}\n```\n\n\nFollowing is my input code\n    ", "Answer": "\r\n```\nif(WeightMatrix[a][b]!=0)//edge exists\n{   \n    if(ShortestPathArray[b]>(ShortestPathArray[a]+WeightMatrix[a][b]))\n    {\n        ShortestPathArray[b]= ShortestPathArray[a]+WeightMatrix[a][b];\n    }\n}\n```\n\n\nhere for e.g a=0 value of ShortestPathArray[a]=2147483647; i.e the max range, and in this value you are adding more value so it is going out of range.\ntry with some smaller value than the max limit.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest Path Implementation Issue\r\n                \r\nI am implementing the Shortest Path Problem in C++. Basically the user enters a ```\nSourceVertex```\n and the function ```\nFindShortestPath(int SourceVertex)```\n finds and prints the shortest paths from the ```\nSourceVertex```\n to all the remaining vertices.\n\n```\nvoid Graph::FindShortestPath(int SourceVertex)\n{\n    cout<<\"The shortest paths from \"<<SourceVertex<<\" are\"<<endl;\n    //initialize the ShortestPathArray\n    for(int a=0;a<NumberOfVertices;a++)\n        ShortestPathArray[a]=numeric_limits<int>::max();\n    ShortestPathArray[SourceVertex]=0;\n\n    for(int a=0;a<NumberOfVertices;a++)\n    {\n        if(WeightMatrix[SourceVertex][a]!=0)\n            ShortestPathArray[a]=WeightMatrix[SourceVertex][a];\n\n    }\n    cout<<\"Direct Edges Length\"<<endl;\n    for(int a=0;a<NumberOfVertices;a++)\n    {\n        cout<<SourceVertex<<\"->\"<<a<<\"=\"<<ShortestPathArray[a]<<endl;\n    }\n    cout<<\"Shortest Path after updating\"<<endl;\n\n    for(int a=0;a<NumberOfVertices;a++)\n        for(int b=0;b<NumberOfVertices;b++)\n\n            if(WeightMatrix[a][b]!=0)//edge exists\n            {   if(ShortestPathArray[b]>(ShortestPathArray[a]+WeightMatrix[a][b]))\n            {\n                ShortestPathArray[b]= ShortestPathArray[a]+WeightMatrix[a][b];}}   \n\n    for(int a=0;a<NumberOfVertices;a++)\n    cout<<SourceVertex<<\"->\"<<a<<\"=\"<<ShortestPathArray[a]<<endl;}\n```\n\n\nI get the following output\n\n```\nThe shortest paths from 4 are\nDirect Edges Length\n4->0=2147483647\n4->1=6\n4->2=10\n4->3=4\n4->4=0\nShortest Path after updating\n4->0=2147483647\n4->1=-2147483645\n4->2=-2147483646\n4->3=-2147483644\n4->4=-2147483647\n```\n\n\nThe first set that is printed is correct. Something in wrong in the updating part. I can't seem to figure that out. \n\nEDIT-1\n\n```\nint main(){\n\n    Graph g(5);\n    g.AddEdge(0,4,2);\n    g.AddEdge(0,2,3);\n    g.AddEdge(0,1,5);\n    g.AddEdge(1,3,6);\n    g.AddEdge(1,2,2);\n    g.AddEdge(4,3,4);\n    g.AddEdge(4,1,6);\n    g.AddEdge(4,2,10);\n    g.AddEdge(2,1,1);\n    g.AddEdge(2,3,2);\n    g.FindShortestPath(4);\n\n    return 0;\n\n}\n```\n\n\nFollowing is my input code\n    ", "Answer": "\r\n```\nif(WeightMatrix[a][b]!=0)//edge exists\n{   \n    if(ShortestPathArray[b]>(ShortestPathArray[a]+WeightMatrix[a][b]))\n    {\n        ShortestPathArray[b]= ShortestPathArray[a]+WeightMatrix[a][b];\n    }\n}\n```\n\n\nhere for e.g a=0 value of ShortestPathArray[a]=2147483647; i.e the max range, and in this value you are adding more value so it is going out of range.\ntry with some smaller value than the max limit.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How to select shortest paths according to selected edges?\r\n                \r\nI am using NetowrkX and OsmnX Python packages to analyze a road network.\nOnce I obtained the simplified graph, I would like to evaluate the performance of the network through the shortest path calculation. In order to obtain a specific index, I need the length of the shortest paths that include selected edges that are shortest paths through the motorway edges.\n\nFirst I listed the motorway edges which I am interested in (G5 is the corresponding graph of my network):\n\n```\nMW_edges=[(u,v,k,d) for u,v,k,d in G5.edges(keys=True, data=True) if  d['highway']=='motorway']\n```\n\n\nI used the following function to evaluate the shortest paths in the network for all pairs of nodes:\n\n```\npaths=dict(nx.all_pairs_dijkstra_path(G5, cutoff=None, weight='length'))\n```\n\n\nHow can obtain/extract the demanded shortest paths including motorway edges?\n    ", "Answer": "\r\nI do not have access to your graph or a toy example that resembles it, and plus I do not get what it is that you want exactly. Mainly:\n\n\nis the graph weighted or not? The fact that you use dijkstra makes me think that it is, but then the fact that you are working with a road network makes me think that it is not.\nwhat is your objective? Do you want, given two nodes (let's say ```\nsource```\n and ```\ntarget```\n), to get the nodes that make up the shortest path between them? Or do you want all the shortest paths for all node pairs? There are different functions that are optimized for doing each of these things.\n\n\nI made a toy example where given two nodes, the algorithm returns the nodes that make up the shortest path between them. Finding the edges is then trivial (just pick the nodes in pairs consecutively from the returned list):\n\n```\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\nnodes = [i for i in range(10)]\nedges = [(i, i+1) for i in range(len(nodes)-1)] + [(nodes[0], nodes[-1])] + [(nodes[4], nodes[8])]\nG = nx.Graph()\nG.add_nodes_from(nodes)\nG.add_edges_from(edges)\n\nsource, target = 4, 9\nprint(\"Shortest path between nodes {} and {} = {}\"\n      .format(source, target, nx.bidirectional_shortest_path(G, source, destination)))\n\nnx.draw_networkx(G)\n```\n\n\nI left the drawing line to help visualize things better. I also suggest you take a look at the docs here to better understand which algorithm is better for your use case.\nIf I misunderstood things, please correct me!\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path variation\r\n                \r\nI'm looking for a solution to the following problem, related to shortest path.\n\nGiven a directed Graph G = (V,E), source s, targets t1, t2, ..., tk and the costs for traveling edge {i,j} is cij. Now I want to know the shortest paths from s to t1, ..., tk. BUT, if a vertext vi (not source or targets) is used then we have an additional cost of C. Note that is two paths use the same vertext vi, the costs C is only paid once.\n    ", "Answer": "\r\nIf you are looking for the shortest path, and each path is penaltised if using c then:\n\nCreate a modified weightning function:\n\n```\nw'(u,v) = w(u,v) + C    if v == c\nw'(u,v) = w(u,v)        otherwise\n```\n\n\nIt is easy to see that when running dijkstra's algorithm or Bellman Ford, with ```\nw'```\n any path that uses ```\nc```\n is penaltized by exactly ```\nC```\n, since if ```\nc```\n appears in the path - it appears exactly once, so ```\nC```\n is added to the total weight [note that ```\nc```\n cannot appear more then once in a shortest path], and of course there is no penalty if ```\nc```\n is not used in this path.\n\n\n\nEDIT: I am not sure I understood correctly, if what @SaeedAmiri is mentioning is correct, and if you want to give the penalty only once [and minimize the total sum of paths to t1,...,tk] Then you should use a different solution - with a similar idea:\n\ncreate a weightning function w' such that:\n\n```\nw'(u,v) = w(u,v) + C + epsilon    if v == c\nw'(u,v) = w(u,v)                  otherwise\n```\n\n\nNote that it is important epsilon is a small size that can be achieved only on w', and is the smallest possible size.\n\n\nRun dijkstra or BF on the graph with ```\nw```\n, let's denote the weights as\n```\nW1```\n\nRun dijkstra or BF in the graph with ```\nw'```\n let's denote the weights as ```\nW2```\n\nIf ```\nW1[ti] == W2[ti]```\n for each ti &in; { t1, ..., tk } - then you don't need ```\nc```\n in the shortest paths, and the total result is ```\nSUM(W1[ti])```\n\nOtherwise - the result is min { SUM(W1[ti]) + C , SUM(W2[ti])`\n\n\nThe idea behind step 4 is you got two possibilities:\n\n\nYou can get to all of t1, ... , tk without using c, and it will be cheaper then using a path with it, so you return the sum of W2.\nOr, if ignoring ```\nc```\n - will only be more expansive - thus you use it freely [and return the sum of W1], and add the penalty only once.\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Python Dijkstra k shortest paths\r\n                \r\nI'm trying to make a small public transport routing application.\n\nMy data is represented in a following structure:\n\n```\ngraph = {'A': {'B':3, 'C':5},\n     'B': {'C':2, 'D':2},\n     'C': {'D':1},\n     'D': {'C':3},\n     'E': {'F':8},\n     'F': {'C':2}}\n```\n\n\nWhere:\n\n\ngraph dict key is a node\nsubdict key is an edge between 2 nodes\nsubdict value is an edge weight\n\n\nI was using find_shortest_path algorithm described here https://www.python.org/doc/essays/graphs/ but it is rather slow because of recursion and has no support of weights.\n\nSo I moved to the algorithm described by Davide Epstein here http://code.activestate.com/recipes/119466-dijkstras-algorithm-for-shortest-paths/ (and even better implementation could be find there in comments with the usage of heapq)\n\nIt works great, it is really fast, but I get only the best route instead of the list of all possible routes. And that is where I stuck.\n\nCould somebody help me with that please, or at least give a direction? I'm not very good in graph shortest paths algorithms. \n\nThanks in advance!\n    ", "Answer": "\r\nIt's no doubt that there would be a huge amount of shortest paths in the graph. So it is hard to generate all shortest path in a satisfied time-complexity. But I can give you a simple method that can get as much shortest paths as you want.\n\nAlgorithm\n\n\nRun Dijkstra algorithm from starting point, and get disS[i] list(the shortest distance\nbetween starting point and point i). And then run Dijkstra algorithm from ending point, and get disT[i] list(the shortest distance between ending point and point i)\nMake a new graph: for a edge  in the original graph, if\ndisS[a] + disT[b] + w(a, b) == disS[ending point], we add a edge  in new graph. It's obviously that the new graph is a DAG(Directed acyclic graph), and has a sink(starting point) and a target(ending point). Any path from sink to the target would be a shortest path in the original graph.\nYou can run DFS in the new graph. Save the path information in the\nrecursion and backtracking, any time you reach the target, the saved\ninformation would be one shortest path. When the algorithm ending is all depend on you.\n\n\nPseudo Code：\n\n```\ndef find_one_shortest_path(graph, now, target, path_info):\n    if now == target:\n        print path_info\n        return\n    for each neighbor_point of graph[now]:\n        path_info.append(neighbor_point) \n        find_one_shortest_path(graph, neighbor_point, target, path_info) #recursion\n        path_info.pop(-1) #backtracking\n\ndef all_shortest_paths(graph, starting_point, ending_point):\n    disS = [] # shortest path from S\n    disT = [] # shortest path from T\n    new_graph = []\n    disS = Dijkstra(graph, starting_point)\n    disT = Dijkstra(graph, endinng_point)\n    for each edge<a, b> in graph:\n        if disS[a] + w<a, b> + disT[b] == disS[ending_point]:\n            new_graph.add(<a, b>)\n    find_one_shortest_path(new_graph, starting_point, ending_point, []) \n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Reconstructing the paths for multiple shortest paths between 2 vertices\r\n                \r\nI'm trying to write an algorithm which will reconstruct the shortest path/s (multiple paths tied for the shortest if there are any) between all pairs of vertices in the Floyd-Warshall algorithm. I took some hints from the question here: https://stackoverflow.com/a/11371588/7447425\n\nBased on this, I've modified the Floyd-Warshall algorithm:\n\n```\nfrom math import inf\n\ndef floyd_warshall(n, edge):\n    rn = range(n)\n    dist = [[inf] * n for i in rn]\n    next  = [[-1]   * n for i in rn]\n\n    for i in rn:\n        for j in rn:\n            next[i][j]=[-1]\n\n    for i in rn:\n        dist[i][i] = 0\n\n    for u, v, w in edge:\n        dist[u][v] = w\n        next[u][v]=[v]\n\n    for k in rn:\n        for i in rn:\n            for j in rn:   \n                sum_ik_kj = dist[i][k] + dist[k][j]\n                if dist[i][j] > sum_ik_kj:\n                   dist[i][j] = sum_ik_kj\n                   next[i][j]=nxt[i][k]\n\n                elif(sum_ik_kj==dist[i][j] and dist[i][j]!=inf and k!=j and k!=i):\n                   next[i][j].extend(next[i][k])\n\nreturn next\n```\n\n\nThe graph is in the form of edge-list for e.g.,:\n\n```\nedge = [[0,2,2],[2,3,2],[3,1,1],[1,0,4],[1,2,3],[0,3,4],[3,0,5]]\n# Here n is the value of the highest numbered-vertex. In the above graph, n=4\nn=4\nnext=floyd_warshall(n,edge)\n```\n\n\nEverything seems to be working well till this point.\n\nFor the path-reconstruction, \n\n```\nfor i in range(n):\n    for j in range(n):\n        if(i!=j):\n            allPaths=[]\n            allPaths=getpath(i,j,next,allPaths)\n            print(allPaths)\n\ndef getpath(i,j,nxt,allPaths):\n    for k in next[i][j]:\n        if(k==-1):\n            allPaths.extend([i,j])\n\n        elif(k==j):\n            allPaths.append(j)\n\n        else:\n            paths_I_K=getpath(i,k,next,allPaths)\n            paths_K_J=getpath(k,j,next,allPaths)\n            for i_k in paths_I_K:\n                for k_j in paths_K_J:\n                    i_k.pop()\n                    allPaths.append(i_k+k_j)\n    return allPaths\n```\n\n\nBut this isn't working. So, can anyone kindly rectify the getpath function (or write a more efficient one) so that I can get all the shortest paths (paths tied for shortest paths) between every pair of vertices?\n\nFor the graph above, I've got \n\n```\nnext=\n[[[-1], [3, 2], [2], [3, 2]],\n [[0], [-1], [2], [2]],\n [[3], [3], [-1], [3]],\n [[0, 1], [1], [1], [-1]]]\n```\n\n\nwhich is accurate, but path reconstruction through this is becoming quite a hassle.\n    ", "Answer": "\r\nHere are the changes I made to your function.\n\n\nI renamed ```\nnext```\n to ```\nnext_node```\n because ```\nnext```\n is actually a Python keyword.\nI renamed ```\ndist```\n to ```\ncost```\n to be more descriptive.\nI stored ```\nnext_node```\n as a ```\nset()```\n to avoid having the same element added twice.\nI made sure to make a new ```\nset()```\n when paths lead through ```\nk```\n.  That is to avoid unintentional data aliasing.  Your code had a bug where if the route from ```\n1 - 3 - 2```\n matches ```\n1 - 4 - 2```\n that you alias ```\nnext[1][2]```\n to ```\nnext[1][3]```\n then add ```\n4```\n to it, which could be wrong for ```\nnext[1][3]```\n. \nI took into account the fact that your format allows multiple edges between nodes.\n\n\nThis gave me the following function that is very similar to yours:\n\n```\ndef floyd_warshall(n, edge):\n    rn = range(n)\n    cost = [[inf] * n for i in rn]\n    next_node = [[set() for j in rn] for i in rn]\n\n    for i in rn:\n        cost[i][i] = 0\n\n    for u, v, w in edge:\n        # The data format allows multiple edges between two nodes.\n        if w < cost[u][v]:\n            cost[u][v] = w\n            next_node[u][v] = set([v])\n        elif w == cost[u][v] and w < inf:\n            next_node[u][v].add(v)\n\n    for k in rn:\n        for i in rn:\n            for j in rn:\n                cost_ik_kj = cost[i][k] + cost[k][j]\n                if cost_ik_kj < cost[i][j]:\n                    cost[i][j] = cost_ik_kj\n                    next_node[i][j] = set(next_node[i][k]) # Want a copy.\n                elif cost_ik_kj == cost[i][j] and cost_ik_kj < inf:\n                    next_node[i][j].update( next_node[i][k] )\n\n    return next_node\n```\n\n\nI then wrote ```\nall_paths```\n as an iterator.  This made it very simple.  It is also possible that there will be many, many paths between two points, and an iterator avoids using too much memory in that case.  And if you want, you can always turn it from an iterator into an array very easily.  Here is that function:\n\n```\ndef all_paths(next_node, i, j):\n    if 0 == len(next_node[i][j]):\n        if i == j:\n            yield [j]\n        else:\n            pass # There is no path.\n    else:\n        for k in next_node[i][j]:\n            for rest in all_paths(next_node, k, j):\n                yield [i] + rest\n```\n\n\nAnd here is some test code to demonstrate it:\n\n```\nedge = [[0,2,2],[2,3,2],[3,1,1],[1,0,4],[1,2,3],[0,3,4],[3,0,5]]\n# Here n is the value of the highest numbered-vertex. In the above graph, n=4\nn=4\nnext_node = floyd_warshall(n,edge)\nfor i in range(4):\n    for j in range(4):\n        for path in all_paths(next_node, i, j):\n            print((i, j, path))\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Count number of shortest paths on a board\r\n                \r\nI'm trying to create a program that finds the number of shortest paths on a board that is nxn. This should use binary tree recursion. It takes two numbers representing the position of some square on the board, and returns the number of distinct shortest paths between the indicated square and the upper left corner. And you can only move up, down, left, or right.\n\n```\n  0 1 2 3 4 5 6 7 8 \n0 . . . . . . . . .\n1 . . . . . . . . .\n2 . . . . . . . . .\n3 . . . . . . . . .\n4 . . . . . . x . .\n5 . . . . . . . . .\n6 . . . . . . . . .\n```\n\n\nIn this case x is at row 4 col 6. The program should count the number of shortest paths. Obviously if x is on an edge then there is only one shortest path.\n\n```\n(check-expect (shortest 0 0) 0)\n(check-expect (shortest 0 1) 1) \n(check-expect (shortest 1 0) 1) \n(check-expect (shortest 1 1) 2) \n(check-expect (shortest 1 2) 3) \n(check-expect (shortest 2 1) 3) \n(check-expect (shortest 2 2) 6) \n(check-expect (shortest 2 3) 10) \n(check-expect (shortest 2 7) 36) \n(check-expect (shortest 6 5) 462) \n```\n\n\nI believe I'm really close, but I'm having a problem in the else case:\n\n```\n(define (shortest x y)\n  (cond\n    [(= x y 0) 0]\n    [(or (zero? y) (zero? x)) 1]\n    [else (+ 1 (shortest (sub1 x) y)\n               (shortest x (sub1 y)))]))\n```\n\n\nI thought there would be an if statement within the else, but I'm not sure what to test. \n\nThis should not have any helpers, lambdas, locals, etc.. and in ISL+. Any help would be great.\n    ", "Answer": "\r\nAs far as I can tell if you change the 4th line from \n\n```\n [else (+ 1 (shortest (sub1 x) y)\n```\n\n\nto\n\n```\n [else (+ (shortest (sub1 x) y)\n```\n\n\nthe function should work as required.  So...\n\n```\n(define (shortest x y)\n  (cond\n    [(= x y 0) 0]\n    [(or (zero? y) (zero? x)) 1]\n    [else (+ (shortest (sub1 x) y)\n             (shortest x (sub1 y)))]))\n```\n\n\nand no need for ifs in the else.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "All Shortest Paths To A Given Vertex\r\n                \r\nGiven a directed graph G=(V,E) and a weight function w : E - > R+  (only positive weights for edges in the graph) , I need to find all the shortest paths from every vertex v in V to a given vertex k.\n\nI've thought about reversing the edges in the graph and then running Dijkstra's algorithm from the vertex k. I wonder whether a shortest path p from k to v1 is actually the shortest path from v1 to k in the original graph ( before reversing edges ).  \n\nI'd be grateful if anyone could explain if and why it does / does not happen.\n\nThanks in advance.\n    ", "Answer": "\r\n(This won't be the most formal proof in the world, but hopefully its good enough to convince yourself).\n\nLets say for a vertex v, in graph G, the shortest path from v to k is of length m.\nThe two things you want to know are:\n 1. In the reversed graph, G*, there is a path of length m from k to v.\n 2. In the reversed graph, G*, there are no paths from k to v that are shorter than m.\n\nBefore I start, can we take one thing on faith:\nLemma 1: If you have a directed path from vertex v to vertex w, and you reverse every edge on the path, then you have a path from vertex w to vertex v. This is provable, but I think its fairly common sense. I'll prove it if you want me to. \n\nFor point 1: Consider the path in G from v to k consisting of m edges. If you reverse each of these edges, you will have a path from k to v of length m (by Lemma 1).\n\nFor point 2: Suppose there exists a path in the reversed graph G*, from k to v of length n < m. If you reverse this path, then there is a path of length n from v to k (Lemma 1). This means that there is a path from v to k in the original graph that is shorter than m, contradicting the statement that the path of length m is the shortest. \n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "second shortest / k-th shortest path\r\n                \r\nWith the code below, I am trying to find the second shortest path / k-th shortest path.     \n\n```\n// Run Dijkstra's algorithm on given graph\n    public static void shortestPath(GraphModel graph, int source, int destination, int numberOfVertices)\n    {\n        // create min heap and push source node having distance 0\n        PriorityQueue<NodeModel> minHeap = new PriorityQueue<>((lhs, rhs) -> lhs.weight - rhs.weight);\n        minHeap.add(new NodeModel(source, 0));\n\n        // set infinite distance from source to v initially\n        List<Integer> dist = new ArrayList<>(Collections.nCopies(numberOfVertices, Integer.MAX_VALUE));\n\n        // distance from source to itself is zero\n        dist.set(source, 0);\n\n        // boolean array to track vertices for which minimum\n        // cost is already found\n        boolean[] done = new boolean[numberOfVertices];\n        done[0] = true;\n\n        // stores predecessor of a vertex (to print path)\n        int prev[] = new int[numberOfVertices];\n        prev[0] = -1;\n\n        // run till minHeap is not empty\n        while (!minHeap.isEmpty())\n        {\n            // Remove and return best vertex\n            NodeModel node = minHeap.poll();\n            node = minHeap.poll();\n            // get vertex number\n            int u = node.vertex;\n\n            // do for each neighbor v of u\n            for (EdgeModel edge: graph.adjList.get(u))\n            {\n                int v = edge.dest;\n                int weight = edge.weight;\n                // Relaxation step\n                if (!done[v] && (dist.get(u) + weight) < dist.get(v))\n                {\n                    dist.set(v, dist.get(u) + weight);\n                    prev[v] = u;\n                    minHeap.add(new NodeModel(v, dist.get(v)));\n                }\n            }\n\n            // marked vertex u as done so it will not get picked up again\n            done[u] = true;\n        }\n```\n\n\nHere is the graph.\n\n```\n    List<EdgeModel> edges = Arrays.asList(\n            new EdgeModel(0, 1, 10), \n            new EdgeModel(0, 4, 3),\n            new EdgeModel(1, 2, 5), \n            new EdgeModel(1, 4, 1),\n            new EdgeModel(2, 3, 7), \n            new EdgeModel(2, 4, 8),\n            new EdgeModel(3, 4, 2), \n            new EdgeModel(4, 1, 20)\n    );\n```\n\n\n\n  The shortest path from 0-4 is 3\n  \n  The second shortest path from 0-4 is 11\n\n\n\n    ", "Answer": "\r\nYou can have a look at the Yen's Algorithm. This Algorithm is used to find the k-th shortest paths(multiple paths) for single source and single destination.The algorithm assumes that you have found the shortest path using Djikstra or any other Algorithm. Here is the link for your reference: https://en.wikipedia.org/wiki/Yen%27s_algorithm\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "ALL shortest paths between a given node and a destination\r\n                \r\nI want an algorithm to find ALL the shortest paths between source S and destination E. I know that Dijkstra's algorithm can find one of the shortest paths, but I'm stuck at finding an algorithm for all the shortest paths using an adjacency matrix and BFS (breadth first search) in C.\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Listing the shortest path available using heapq for dijkstra shortest path algorithm\r\n                \r\nI was given a task where I need to apply Dijkstra's Shortest Path Algorithm in my python code. Let say we have a few cities involved. I need to find the one that has the shortest route. In summary, the task is to:\n\nFind the shortest route.\nList all the possible paths.\n\nI was successfully be able to find the shortest path among the cities, but I do not know how to list all the possible paths using heapq. Can anyone help me?\nThis is the graph I provided for better understanding of the graph:\n\nThe Code:\n```\nimport heapq\nfrom collections import defaultdict\nglobal shortestPath\nglobal shortestCost\nshortestPath = \"null\"\nshortestCost = 100000\ndef dijkstra(graph,src,dest): \n    h = []\n  \n    heapq.heappush(h,(0,src))\n    global shortestPath\n    global shortestCost\n    global source\n    while len(h)!=0:\n        currcost,currvtx = heapq.heappop(h)\n        if currvtx == dest:\n            print(\"\\t\\t\\t{} to {} with cost {}\".format(src,dest,currcost))\n            if currcost < shortestCost:\n                if dest == src:\n                    continue\n                else:\n                    shortestCost = currcost\n                    shortestPath = dest\n            break\n        for neigh,neighcost in graph[currvtx]:\n            heapq.heappush(h,(currcost+neighcost,neigh))\n\ncity = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"]\ngraph = defaultdict(list) \ngraph[\"A\"] = [(\"B\",1),(\"C\",5)]\ngraph[\"B\"] = [('C', 6), ('D', 23)]\ngraph[\"C\"] = [('E', 35)]\ngraph[\"D\"] = [('F', 26)]\ngraph[\"E\"] = [('D', 54)]\n\nprint (\"\\t=============================================================================\")\nprint (\"\\t                     Dijkstra's Shortest Path Algorithm\")\nprint (\"\\t=============================================================================\")\nprint (\"\\n\\tAssume 1 cost = 10 km\")\nprint (\"\\n\\tCity availability: {} \".format(city))\nsrc = \"A\"\nprint (\"\\n\\tPossible paths from {} :\\n\".format(src))\nfor i in city:\n    dijkstra(graph,src,i)\nprint (\"\\n\\t=============================================================================\")\nprint(\"\\t\\tThe shortest path from {} is {} to {} with cost {}\".format(src,src,shortestPath,shortestCost))\nprint (\"\\t=============================================================================\")\n```\n\nThe output:\n```\n    =============================================================================\n                         Dijkstra's Shortest Path Algorithm\n    =============================================================================\n\n    Assume 1 cost = 10 km\n\n    City availability: ['A', 'B', 'C', 'D', 'E', 'F'] \n\n    Possible paths from A :\n\n            A to A with cost 0\n            A to B with cost 1\n            A to C with cost 5\n            A to D with cost 24\n            A to E with cost 40\n            A to F with cost 50\n\n    =============================================================================\n        The shortest path from A is A to B with cost 1\n    =============================================================================\n```\n\nMy apologies if this post seems unfitting as this is my first question that I have posted in here.\nYour help is highly appreciated. Thank you.\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Yen's K shortest paths algoritm - wiki pseudocode\r\n                \r\nWhen analysing pseudocode (from Wiki) of Yen's K shortest paths algorithm I noticed that it is possible to find duplicate candidate paths, i.e., a candidate path identical to one already existing either in the candidate stack or among the previously found shortest paths. In short, this can happen because we eliminate from candidates any path which starts with the sequence of nodes identical to the beginning of the last shortest path but don't take account of earlier shortest paths (which could fork from the last one in an earlier node, and thus a candidate can follow it even if it was previously used).\nThen I implemented the pseudocode (in PHP) and I was able to find graph examples in which this phenomenon occurs.\nIf I'm right then it is necessary to supplement the algorithm (pseudocode) with \"duplicate check\" for any new candidate.\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Neo4j Find alternative shortest paths between nodes\r\n                \r\nHow do I find multiple distinct short paths between 2 nodes in a graph with 7.5M nodes and 20M relationships?\nWe want a feature similar to how google maps shows other alternative routes.\nproblems with:\nDijkstra, shortestPath and allShortestPaths:\nOnly returns the shortest path or paths with the shortest length.\nYen's k shortest paths:\nAbsurdly slow on a big graph\nIterate over list of numbers 0-10 and call allShortestPaths with minimum number of length of i:\nAbsurdly slow on a big graph\n    ", "Answer": "\r\nAfter some time, I figured that filtering/blacklisting for certain relationships that already has been used for another path could work. However, when I tried this in practice i noticed that filtering after running allShortestPaths wasn't a viable solution. After this I figured doing allShortestPaths mulitple times and when a path is found I could rename the type to currentTypeName_TEMP, then rename it after again.\nTo find multiple distinct paths, this could be done with an algorithm shown on the picture, and given the effectiveness of allShortestPaths, this will not be that computational or time intensive (dotted lines means found relationships).\n\nEDIT:\nturns out this is rather difficult in cypher, since it is very restricive in nature, we ended up writing a plugin, where we made a hack of dijkstra where it takes N of the shortest paths.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Kth Shortest Path\r\n                \r\nDoes anyone know how can I write a programming graph-algorithm (C++ code would be great) that finds the Kth shortest path for a given set of nodes and edges in a cyclic graph?\n\nFor example, the shortest path (that could be found by Dijkstra or Bellman Ford) is considered to be the 1th shortest path. Now the 2nd shortest path is the shortest one that comes after the 1st shortest path. Now I want the algorithm to find the Kth shortest path.\nyou are given the number of nodes, edges and the set of edges, as the following:\n\nnumber of nodes: 5\nnumber of edges: 6\nedges:\n0 1\n0 2\n1 2\n2 3\n3 1\n1 4\nsource node:0\ndestination node: 4\n\n\"Note that this graph contains a cycle\"\nThank you.\n    ", "Answer": "\r\nUse a uniform cost search algorithm. Where the Wikipedia says \"return solution\", don't quit and ```\nreturn```\n but append the result to some list until that list contains k paths. The k'th element of the list (counting from 1) will be the k'th shortest path.\n\nDon't keep a \"closed\"/\"explored\" set or this algorithm won't work properly.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Number of shortest paths\r\n                \r\nHere is the problem:\n\nGiven the input n = 4 x = 5, we must imagine a chessboard that is 4 squares across (x-axis) and 5 squares tall (y-axis). (This input changes, all the up to n = 200 x = 200)\n\nThen, we are asked to determine the minimum shortest path from the bottom left square on the board to the top right square on the board for the Knight (the Knight can move 2 spaces on one axis, then 1 space on the other axis).\n\nMy current ideas:\n\nUse a 2d array to store all the possible moves, perform breadth-first \nsearch(BFS) on the 2d array to find the shortest path.\n\nFloyd-Warshall shortest path algorithm.\n\nCreate an adjacency list and perform BFS on that (but I think this would be inefficient).\n\nTo be honest though I don't really have a solid grasp on the logic.\n\nCan anyone help me with psuedocode, python code, or even just a logical walk-through of the problem?\n    ", "Answer": "\r\nBFS is efficient enough for this problem as it's complexity is O(n*x) since you explore each cell only one time. For keeping the number of shortest paths, you just have to keep an auxiliary array to save them.\n\nYou can also use A* to solve this faster but it's not necessary in this case because it is a programming contest problem.\n\n```\ndist = {}\nways = {}\n\ndef bfs():\n    start = 1,1\n    goal = 6,6\n\n    queue = [start]\n    dist[start] = 0\n    ways[start] = 1\n\n    while len(queue):\n        cur = queue[0]\n        queue.pop(0)\n        if cur == goal:\n            print \"reached goal in %d moves and %d ways\"%(dist[cur],ways[cur])\n            return\n\n        for move in [ (1,2),(2,1),(-1,-2),(-2,-1),(1,-2),(-1,2),(-2,1),(2,-1) ]:\n            next_pos = cur[0]+move[0], cur[1]+move[1]\n            if next_pos[0] > goal[0] or next_pos[1] > goal[1] or next_pos[0] < 1 or next_pos[1] < 1:\n                continue\n            if next_pos in dist and dist[next_pos] == dist[cur]+1:\n                ways[next_pos] += ways[cur]\n            if next_pos not in dist:\n                dist[next_pos] = dist[cur]+1\n                ways[next_pos] = ways[cur]\n                queue.append(next_pos)\n\nbfs()\n```\n\n\nOutput\n\n```\nreached goal in 4 moves and 4 ways\n```\n\n\nNote that the number of ways to reach the goal can get exponentially big\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest Paths based on edge attribute with igraph\r\n                \r\nI'm trying to get the shortest paths of a graph but based on its edge ids.\nSo having the following graph:\n\n```\nlibrary(igraph)\n\nset.seed(45)\ng <- erdos.renyi.game(25, 1/10, directed = TRUE)\nE(g)$id <- sample(1:3, length(E(g)), replace = TRUE)\n```\n\n\nThe ```\nshortest_paths(g, 1, V(g))```\n function finds all the shortest paths from node 1 to all the other nodes. However, I would like to calculate this, not just by following the geodesic distance, but a mix between the geodesic distance, and the minimum of edge id changes.\nFor example if this would be a train network, and the edge ids would represent trains. I would like to calculate how to get from node A to all the other nodes using the shortest path, but while changing the least amount of time of trains.\n    ", "Answer": "\r\nOK I think I have a working solution, although the code is a little ugly. The basic algorithm (lets call it gs(i, j)) goes like this: If we want to find the shortest train journey from i to j (gs(i, j)) we:\n\n\nfind the shortest path from i to j considering all trains. if this path is length 0 or 1 return it (there is either no path or a path on 1 train)\nsplit the graph up by 'trains' (subset graph by edges) so as to consider each train network separately, and find the shortest path between i and j in each individual train network\nif a single train will get you from i to j, return the train route with the fewest stops between i and j, else\nif no single train runs from i to j then call gs(i, j-1) where (j-1) is the stop before j in the shortest path between i and j on the full network.\n\n\nSo basically, we look to see if a single train can do it, and if it can't we call the function recursively looking if a single train can get you to the stop before the last stop, etc. etc.\n\n\n\n```\nlibrary(igraph)\n\n# First your data\nset.seed(45)\ng <- erdos.renyi.game(25, 1/10, directed = TRUE)\nE(g)$id <- sample(1:3, length(E(g)), replace = TRUE)\n\nplot(g, edge.color = E(g)$id)\n```\n\n\n\n\n```\n# The function takes as arguments the graph, and the id of the vertex\n# you want to go from/to. It should work for a vector of \n# destinations but I have not rigorously tested it so proceed with\n# caution!\nget.shortest.routes <- function(g, from, to){\n  train.routes <- lapply(unique(E(g)$id), function(id){subgraph.edges(g, eids = which(E(g)$id==id), delete.vertices = F)})\n  target.sp <- shortest_paths(g, from = from, to = to, output = 'vpath')$vpath\n  single.train.paths <- lapply(train.routes, function(gs){shortest_paths(gs, from = from, to = to, output = 'vpath')$vpath})\n  for (i in length(target.sp)){\n    if (length(target.sp[[i]]>1)) {\n      cands <- lapply(single.train.paths, function(l){l[[i]]})\n      if (sum(unlist(lapply(cands, length)))!=0) {\n        cands <- cands[lapply(cands, length)!=0]\n        cands <- cands[lapply(cands, length)==min(unlist(lapply(cands, length)))]\n        target.sp[[i]] <- cands[[1]]\n      } else {\n        target.sp[[i]] <- c(get.shortest.routes(g, from = as.numeric(target.sp[[i]][1]),\n                                              to = as.numeric(target.sp[[i]][(length(target.sp[[i]]) - 1)]))[[1]],\n                            get.shortest.routes(g, from = as.numeric(target.sp[[i]][(length(target.sp[[i]]) - 1)]),\n                                                to = as.numeric(target.sp[[i]][length(target.sp[[i]])]))[[1]][-1])\n      }\n    }\n  }\n  target.sp\n}\n```\n\n\nOK now lets run some tests. If you squint at the graph above you can see that the path from vertex 5 to vertex 21 is length-2 if you take two trains, but that you can get there on 1 train if you pass through an extra station. Our new function should return the longer path:\n\n```\nshortest_paths(g, 5, 21)$vpath\n#> [[1]]\n#> + 3/25 vertices, from b014eb9:\n#> [1]  5 13 21\nget.shortest.routes(g, 5, 21)\n#> Warning in shortest_paths(gs, from = from, to = to, output = \"vpath\"): At\n#> structural_properties.c:745 :Couldn't reach some vertices\n\n#> Warning in shortest_paths(gs, from = from, to = to, output = \"vpath\"): At\n#> structural_properties.c:745 :Couldn't reach some vertices\n#> [[1]]\n#> + 4/25 vertices, from c22246c:\n#> [1]  5 13 15 21\n```\n\n\nLets make a really easy graph where we are sure what we want to see: here we should get 1-2-4-5 instead of 1-3-5:\n\n```\ndf <- data.frame(from = c(1, 1, 2, 3, 4), to = c(2, 3, 4, 5, 5))\ng1 <- graph_from_data_frame(df)\nE(g1)$id <- c(1, 2, 1, 3, 1)\nplot(g1, edge.color = E(g1)$id)\n```\n\n\n\n\n```\nget.shortest.routes(g1, 1, 5)\n#> Warning in shortest_paths(gs, from = from, to = to, output = \"vpath\"): At\n#> structural_properties.c:745 :Couldn't reach some vertices\n\n#> Warning in shortest_paths(gs, from = from, to = to, output = \"vpath\"): At\n#> structural_properties.c:745 :Couldn't reach some vertices\n#> [[1]]\n#> + 4/5 vertices, named, from c406649:\n#> [1] 1 2 4 5\n```\n\n\nI'm sure there is a more rigorous solution, and you'll probably want to optimize the code a bit. For instance, I just realized that I don't stop the function immediately if the shortest path on the full graph has only two nodes -- doing so would avoid some needless computations! This was a fun problem, I hope some other answers gets posted.\n\nCreated on 2018-05-11 by the reprex package (v0.2.0).\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Neo4j find first n-shortest paths\r\n                \r\nI'm trying to figure out way in neo4j to find N (const) number of path between two nodes. \n\nWith bigger graph:\n\n```\nPathFinder<Path> finder = GraphAlgoFactory.allSimplePaths(\n                        Traversal.expanderForTypes( Relationship.KNOWS ), 20 );\nIterable<Path> paths = finder.findAllPaths( startNode, endNode );\n```\n\n\nReturns way to much paths (actually I had to kill process cause it was keep on returning possible paths).\n\nMy first idea (abstract) is to find n-shortest paths like this:\n\n\nFind shortest path with ```\nGraphAlgoFactory.shortestPath(...)```\n\nLook for additional paths with ```\nGraphAlgoFactory.pathsWithLength()```\n increment in each iteration by 1, starting from length == path length+1 from 1.\nIter until you reach max length (depth) or max hit count.\n\n\nBut maybe I'm trying to invent wheel once again? Is there such alhorithm provided with Neo4j? I can't find any\n    ", "Answer": "\r\nI think this algo might be something you can develop yourself and contribute to the graph-algo package, maybe as variation of allSimplePaths?\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path with given edges\r\n                \r\nI want to find the shortest path from source(u) using ```\nk```\n edges. This solution seems to work, but it searches paths with ```\nk```\n edges to a given node ```\nv```\n. What if ```\nk```\n edges are covered before reaching ```\nv```\n? I just want shortest path from all the paths covered from ```\nu```\n covering ```\nk```\n edges. Reaching ```\nv```\n is not needed.\nCode from the above link:\n```\n# Python3 program to find shortest path \n# with exactly k edges \n\n# Define number of vertices in the graph \n# and inifinite value \n\n# A naive recursive function to count \n# walks from u to v with k edges \ndef shortestPath(graph, u, v, k): \n    V = 4\n    INF = 999999999999\n    \n    # Base cases \n    if k == 0 and u == v: \n        return 0\n    if k == 1 and graph[u][v] != INF: \n        return graph[u][v] \n    if k <= 0: \n        return INF \n\n# Initialize result \n    res = INF \n\n# Go to all adjacents of u and recur \n    for i in range(V): \n        if graph[u][i] != INF and u != i and v != i: \n            rec_res = shortestPath(graph, i, v, k - 1) \n            if rec_res != INF: \n                res = min(res, graph[u][i] + rec_res) \n    return res \n\n# Driver Code \nif __name__ == '__main__': \n    INF = 999999999999\n    \n    # Let us create the graph shown \n    # in above diagram \n    graph = [[0, 4, 2, 6, 5], \n            [INF, 0, 4, 2, 5], \n            [INF, INF, 0, 4, 3], \n            [INF, INF, INF, 0, 3],\n            [INF, INF, INF, INF, 0]] \n    u = 0\n    v = 4\n    k = 3\n    print(\"Weight of the shortest path is\", \n            shortestPath(graph, u, v, k)) \n```\n\n    ", "Answer": "\r\nYou can probably fix that code (by not passing in, or looking at, ```\nv```\n at all - see below). But I would recommend simply modifying Dijkstra's algorithm to, at most, explore 3 edges from the start node. Dijkstra finds all shortest-length paths from a start. Simply stop it when paths reach their 3rd edge (this will require you to keep edge-counts in addition to distances).\nModifying the above code also works, but is certainly slower, since you will be looking at each edge multiple times unless the graph is a tree.\n```\nINF = 999999999999\ndef nearest_in_k_steps(graph, u, k): \n    print(f\"Entering {u}, {k} steps remaining\")\n    V = len(graph)\n   \n    # Base case\n    if k == 0: \n        return 0, u\n\n    # Initialize result \n    best_dist = INF \n    best_target = None\n\n    # Go to all adjacents of u and recurse \n    for i in range(V): \n        if graph[u][i] != INF and u != i: \n            candidate_dist, candidate_target = nearest_in_k_steps(graph, i, k - 1) \n            candidate_dist += graph[u][i]\n            if candidate_dist < best_dist:\n                print(f\"Hmm, path via {i} (d={candidate_dist}) is better than via {best_target} (d={best_dist})\")\n                best_dist = candidate_dist\n                best_target = candidate_target\n\n    print(f\"Returning from {u}, {k} steps remaining: d={best_dist} to {best_target}\")\n    return best_dist, best_target\n\n# Driver Code \nif __name__ == '__main__': \n    # Let us create the graph shown \n    # in above diagram \n    graph = [[0,    4,   2,   6,   5], \n            [INF,   0,   4,   2,   5], \n            [INF, INF,   0,   4,   3], \n            [INF, INF, INF,   0,   3],\n            [INF, INF, INF, INF,   0]] \n    start = 0\n    steps = 3\n    nearest_dist, nearest_target = nearest_in_k_steps(graph, start, steps)\n    print(f\"Node {nearest_target} is the nearest {steps}-step neighbor of {start}: distance = {nearest_dist}\")\n```\n\nNote that there are several prints that are there only to help you understand how the code works.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "networkx not giving all shortest paths for weighted graphs\r\n                \r\nI am trying to find all possible shortest paths\n\nHere is my code:\n\n```\nimport networkx as nx\ng=nx.Graph()\ne=[('a', 'b', 2), ('a', 'c', 6), ('b', 'c', 4), ('c', 'e', 5), ('c', 'f', 1)]\npaths=nx.shortest_paths(g,'a','c',weight=True)\nprint('%s' %list(paths))\n```\n\n\nHere is the output:\n\n```\n[['a', 'c']]\n```\n\n\nAccording to weights, a->b->c is also a shortest path. \n\nWhy it is not coming in output?\n    ", "Answer": "\r\nInstead of ```\nshortest_paths```\n use ```\nall_shortest_paths```\n function.\n\nTry the below code:\n\n```\nimport networkx as nx\ng=nx.Graph()\ng.add_edge('a','b', distance=2)\ng.add_edge('a','c', distance=6)\ng.add_edge('b','c', distance=4)\ng.add_edge('c','e', distance=5)\ng.add_edge('c','f', distance=1)\nprint([p for p in nx.all_shortest_paths(g,source='a',target='c',weight='distance')])\n```\n\n\nOutput:\n\n```\n[['a', 'c'], ['a', 'b', 'c']]\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Computing shortest paths with networkx\r\n                \r\nI have an edgelist (node1 node2 weight).  Attempting to identify the weighted shortest path lengths among all nodes.  Here is my data: \nhttps://drive.google.com/file/d/1DxSL5lSgsHYdR7kWmauVWA7CW_Q05xPS/view?usp=sharing\n\nCan't get it to produce output.\n\nNot sure if I am reading in the weights correctly or including them in the shortest path production.  \n\n```\nimport networkx as nx\nG=nx.read_weighted_edgelist\n(r'C:\\Users\\james\\Desktop\\Documents\\Downloads\\\\bpAFTSi.pr',create_using= \nnx.DiGraph())  \n\nG=nx.path_graph(48)\nlen_path = dict(nx.all_pairs_dijkstra(G))\nprint(len_path[3][0][1])\n\nfor node in G:\n    print('3 - {}: {}'.format(node, len_path[3][0][node]))\n```\n\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Networkx, using shortest paths to make shortest cycles\r\n                \r\nthis question is specific to NetworkX.  I could make my own functions to accomplish all the things I need, but it would take much longer so I want to avoid it.\n\nThe situation:\n\nI have an unweighted graph, represented by a NetworkX Undirected Graph.  From this graph, I seek \"shortest cycles\" - that is to say, for a given node k, I am finding the shortest simple path (only passes through a node once), that leaves k and then comes back to k.\n\nTo accomplish this, I would like to use any NetworkX Shortest Paths algorithm, and do the search from node k, to node k.  The problem is, it seems that every shortest path algorithm simply returns node k as the path.  So, it never actually leaves.  And, I don't know how to change this.\n\nA possible solution would be for me to do:\n\n```\nfor each edge from k\n    disconnect that edge\n    do shortest path from the other side of that edge to k\n    reconnect that edge\n```\n\n\nHowever, the sheer number of times I plan on doing this \"shortest cycle\" technique is extremely huge, and I would prefer to not have to do that.  So, is there an easier way to do what I want with NetworkX?\n\nThank you.\n    ", "Answer": "\r\nYou may try ```\ncycle_basis```\n, which tries to find a set of cycles that forms a basis and select the minimal cycle:\n\n```\nimport networkx as nx\n\ng = nx.Graph()\ng.add_nodes_from([1,2,3,4,5,6,7])\ng.add_edges_from([(1,2), (1,3), (2,4), (2,7), (3,5), (6,7), (5,6), (1,5), (3,4)])\n\nmin(nx.cycle_basis(g, 1), key=lambda cycle: len(cycle))\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest paths problem with one alteration\r\n                \r\nLet's say i have a directed graph G(V,E) with positive integer weights at it's edges.What i need to do is find the shortest paths between all vertices using at most K(integer) reverse edges.What i mean by that is:If we are at edge u and there is only a directed edge from v to u we can use it as long as we have not used K reverse edges for this path.This has to be implemented in C++ and give the shortest paths as a result.\n\nI think the main approach to this problem is to conceptually create K+1 copies of the graph where each copy has one reverse edge,copy G_0 has one G_1 two etc.I could then run dijkstra in this graph and find the shortest path from a vertex to all others using as much as K reversed edges.This could be done V times(like johnsons algorithm)to find all possible shortest paths.My question is:how could this be implemented in c++?I excpect we don't have to create this multigraph but i can't see how it can be done otherwise.\n    ", "Answer": "\r\nIf you know Dijkstra, you know that every vertex has a tentative distance label (initially infinite, except for the source) and you process the vertices in order of that tentative distance by \"relaxing\" their arcs, that is, updating the tentative distances of their neighbors. \n\nIf you allow for a number of arcs to be travelled in the wrong direction, I would go for a dynamic programming approach and have K labels for each vertex with the following semantics: Label 0 is the classic Dijstra label, Label 1 is the minimum distance from the start on a path with at most one reverse arc and so on. \n\nNow, if I am correct, all you got to do is start with infinite labels and labels 0 for the source. Process labels instead of arcs and (again) start with the minimum tentative distance.\nIn contrast to the original, relaxing reverse arcs is allowed, but will update the K+1 label of the other side of the arc, while relaxing arcs in their normal direction will update the Kth label.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Find the First Shortest Path and then the Second Shortest Path in a Matrix\r\n                \r\nSo as the title says I want my code to output the full shortest paths, my matrix has 10 nodes so the output should be for example 1-2-6-10 but in my case, the output for both the first shortest path and the second only gives the value of 10 the last vertex and I want it to show the full path from node 1 to node 10, the last one. This matrix is just an example because I want Matlab to read a matrix from excel.\n```\nmatrix = [0  3  6  8  2  inf  inf  inf  inf  inf;          3  0  5  7  9   1  inf  inf  inf  inf;          6  5  0  5  8   10  2  inf  inf  inf;          8  7  5  0  4   9   14  3  inf  inf;          2  9  8  4  0   5   12  15  4  inf;          inf  1  10  9  5  0   10  20  25  5;          inf  inf  2  14  12  10  0   12  30  35;          inf  inf  inf  3  15  20  12  0   25  40;          inf  inf  inf  inf  4  25  30  25  0   45;          inf  inf  inf  inf  inf  5  35  40  45  0];\n\n\n% Input:\nstart = 1;\nending = 10;\n\n% Initialize variables\nn = size(matrix,1); % number of vertices\nd = inf(1,n); % distance array\nd(start) = 0; % starting vertex distance = 0\nprev = zeros(1,n); % predecessor array\nS = false(1, n); % set of labeled vertices\nS(start) = true;\n\nfor i = 1:size(matrix,1)\n    for j = 1:size(matrix,2)\n        if matrix(i,j) == 0\n            matrix(i,j) = inf;\n        end\n    end\nend\n\n% First shortest path\nmatrix = matrix + matrix';\nmatrix(matrix == inf) = 0;\nmatrix(matrix > 0) = inf;\n\nwhile S(ending) == false;\n    % Select vertex with smallest distance\n    [,v] = min(d(~S));\n    v = find(~S,1,'first');\n    S(v) = true; % \"permanently\" label vertex\n\n    % Update distances and predecessors of neighbors\n    for u = find(matrix(v,:)~=inf)\n        if d(v) + matrix(v,u) < d(u) && matrix(v,u) <= inf\n\n            d(u) = d(v) + matrix(v,u);\n            prev(u) = v;\n        end\n    end\nend\n\n% Output first shortest path\npath = [ending];\nwhile prev(path(end)) ~= 0\n    path = [path, prev(path(end))];\nend\nfprintf('First Shortest Path: ')\nfor i = 1:length(path)\n    fprintf('%d ', path(i))\nend\n\nfprintf('\\n')\n\n\n\n% Second shortest path\nfor i = 2:length(path)\n    matrix(path(i), path(i-1)) = inf; % remove the edge from first path\nend\n\nd = inf(1,n); % distance array\nd(start) = 0; % starting vertex distance = 0\nprev = zeros(1,n); % predecessor array\nS = false(1, n); % set of labeled vertices\nS(start) = true;\n\n% Repeat the process to find the second shortest path\nwhile S(ending) == false\n    % Select vertex with smallest distance\n    [,v] = min(d(~S)); \n    v = find(~S,1,'first');\n    S(v) = true; % \"permanently\" label vertex\n    % Update distances and predecessors of neighbors\n    for u = find(matrix(v,:)~=inf)\n        if d(v) + matrix(v,u) < d(u) && matrix(v,u) <= inf\n\n            d(u) = d(v) + matrix(v,u);\n            prev(u) = v;\n        end\n    end\nend\n\n% Output second shortest path\npath = [ending];\nwhile prev(path(1)) ~= 0\n    path = [prev(path(1)),path];\nend\nfprintf('Second Shortest Path: ')\nfor i = 1:length(path)\n    fprintf('%d ', path(i))\nend\nfprintf('\\n') `\n```\n\nI tried using a different Matrix at first, but still the same.\nI want the First Shortest path from node 1 to node 10 and then remove that path and give me the second shortest path.\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Preprocess shortest paths under contention\r\n                \r\nIt is easy to prove that if P is a shortest path between u and v, then every subpath is also a shortest path. \nGiven a connected Graph, I want to preprocess a the shortest path between every pair of nodes in a Matrix, such that:\n\n\nPath[u,v] = Path[v,u]\nIf x,y in Path[u,v] then Path[x,y] is a subpath of Path[u,v].\n\n\nI can not figure out an algorithm or a prove and actually I do not know if this is posible. \nAny idea is welcome.Thank you. \n    ", "Answer": "\r\nYou can only get (1) if you are working with undirected graphs OR if it is guaranteed that the weight of the arc (a, b) is equal to the weight of the arc (b, a) for all arcs in your graph.\n\nThe problem you describe sounds like the all-pairs shortest path problem: for each pair of nodes in a connected graph, find the shortest paths between nodes in the pair. The Floyd-Warshall algorithm can be used to find the lengths of paths and it is straightforward to reconstruct the shortest paths from there.\n\nThis algorithm further requires that there are no negative cycles (otherwise a shorter path could always be obtained by running through that cycle again) but that requirement seems reasonable.\n\nTo guarantee property (2), you need to make sure when reconstructing paths you are reconstructing \"canonical\" paths whenever more than one shortest path may be possible. To do this, impose an ordering on the vertices and always test candidate nodes in ascending order, always preferring the lowest-ordered node which maintains the shortest-path property.\n\nWikipedia has a fairly good write-up.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Prolog: Shortest Path for Knight\r\n                \r\nHi so before I get told that this question has been asked many times, I have looked through a bunch of questions but none of them relate to Prolog. Which is what I'm having difficulty with. \n\nI am trying to find the shortest path between two points on a chess board. The code I have is specifically for a knight. This is my code so far: \n\n```\nmove1( (X1,Y1), (X2,Y2) ) :- up1( X1, X2 ), up2( Y1, Y2 ).\nmove1( (X1,Y1), (X2,Y2) ) :- up2( X1, X2 ), up1( Y1, Y2 ).\nmove1( (X1,Y1), (X2,Y2) ) :- up1( X1, X2 ), down2( Y1, Y2 ).\nmove1( (X1,Y1), (X2,Y2) ) :- up2( X1, X2 ), down1( Y1, Y2 ).\nmove1( (X1,Y1), (X2,Y2) ) :- down1( X1, X2 ), up2( Y1, Y2 ).\nmove1( (X1,Y1), (X2,Y2) ) :- down2( X1, X2 ), up1( Y1, Y2 ).\nmove1( (X1,Y1), (X2,Y2) ) :- down1( X1, X2 ), down2( Y1, Y2 ).\nmove1( (X1,Y1), (X2,Y2) ) :- down2( X1, X2 ), down1( Y1, Y2 ).\n\nup1( U, V ) :- successor( U, V ).\nup2( U, W ) :- successor( U, V ), successor( V, W ).\ndown1( U, V ) :- up1( V, U ).\ndown2( U, V ) :- up2( V, U ).\n\nsuccessor( 1, 2 ).\nsuccessor( 2, 3 ).\nsuccessor( 3, 4 ).\nsuccessor( 4, 5 ).\n\nedge((X1,Y1) , (X2,Y2)) :- move1( (X1,Y1), (X2,Y2) ).\n\npath((X1,Y1), (X2,Y2),N,[(X1,Y1), (X2,Y2)]) :- N > 0, edge((X1,Y1), (X2,Y2)).\npath((X1,Y1), (X3,Y3),N,[(X1,Y1)|P1]) :- N > 0, N1 is N-1, path((X2,Y2), (X3,Y3),N1,P1), edge((X1,Y1), (X2,Y2)), nonmember((X1,Y1),P1).\n\nshortest((X1,Y1),(X2,Y2),P) :- path((X1,Y1),(X2,Y2),24,P),!.\n\nvisit((X1,Y1),P,N) :-  path((X1,Y1), (X2,Y2),N,P),N2 is N+1,len(P,N2).\n\nlen([],0).\nlen([_|T],N)  :-  len(T,X),  N is X+1. \n\nnonmember(X,[]).\nnonmember(X,[U|Y]) :- X \\= U, nonmember(X,Y).\n```\n\n\nAs you can see, I only find the first path rather than the shortest path. I'm not sure how to code in prolog and figure out a way to get all the shortest paths. I was thinking about making a list of all the possible paths then going through and finding the shortest but I cannot seem to write the code. \n\n```\nfindAll((X1,Y1),(X2,Y2),P,L) :- path((X1,Y1),(X2,Y2),24,P),length(P,L).\n```\n\n\nGives me the length of every path but I'm not sure what to do with it. \nAny help in how to code in Prolog to find the shortest path would be very helpful and is what I am looking for. \n    ", "Answer": "\r\nTo follow your approach which seem to enumerate all paths and find the minimum, I would go with the ```\naggregate```\n library.\n\nBut first, I would suggest some cleanup of your code as I'm not sure it would work correctly that way (but I have just checked very quickly).\n\nIn particular, you want to arrive to a predicate ```\npath((X1, Y1),(X2, Y2),Path)```\n that would allow for an enumeration of all the paths (if you retry it multiple times) and then stops. Yours seem to loop indefinitely once all paths have been exhausted.\nYou can find some inpiration on how to enumerate all non looping paths here.\n\nOnce that is fixed, you can use ```\naggregate/3```\n in the following way:\n\n```\n:-use_module(library(aggregate)).    \n\nfind_min(Start, End, Path) :-\n    aggregate(\n        min(Length, Path),\n        (path(Start, End, Path), length(Path, Length)),\n        min(_,P)\n     ).\n```\n\n\n```\nfind_min(Start, End, Path)```\n will then allow you to enumerate all shortest paths from one cell to another.\nNote that there may be multiple shortest path from ```\nStart```\n to ```\nEnd```\n; this will return all shortest paths, not just one.\n\nAnother possible solution would be to implement Djikstra's shortest path algorithm, which is likely be much more efficient than enumerating all the paths and finding the minimum like we are doing here. But that would be a totally different approach.\n\nEDIT: With a small board 4x4 or 5x5 then the enumerating all paths and finding the min approach may work, but on a 8x8 board the complexity will become unmangeable.\nHere, the best way would be to change your approach and implement, e.g., Djikstra's algorithm.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Yen's Algorithm implementation not choosing shortest paths\r\n                \r\nI am using Yen's Algorithm (Wikipedia) to find k shortest paths in a graph. In the example below, my graph is a dictionary where each node is a key, with its value being the neighbors. ```\nMap()```\n from ```\ndotmap```\n simply allows for dictionaries to be converted into an object where keys can be accessed with dot notation. I want to find the four shortest paths in descending order from A to F where every edge has equal weight. The first two are ties (A > B > D > F) and (A > E > D > F), and the next two are (A > B > C > G > F) and finally (A > B > D > C > G > F). It is possible that my implementation of Dijkstra's (called AStar despite having no heuristic) is flawed because it is returning an empty list when no path is found. How can I have my code only pick the valid paths? Currently it returns ```\n[['A', 'B', 'D', 'F'], ['A', 'E', 'D', 'F'], [], []]```\n -- it should return ```\n[['A', 'B', 'D', 'F'], ['A', 'E', 'D', 'F'], ['A', 'B', 'C', 'G', 'F'], ['A', 'B', 'D', 'C', 'G', 'F']]```\n which are the shortest paths.\n\n```\nimport copy\nimport heapq\nfrom dotmap import Map\nfrom itertools import count\n\ngraph = {\n    'A': ['B', 'E'],\n    'B': ['C', 'D'],\n    'C': ['G'],\n    'D': ['C', 'F'],\n    'E': ['D'],\n    'F': [],\n    'G': ['F']\n}\n\nclass PriorityQueue:\n    def __init__(self):\n        self.elements = []\n        self._counter = count()\n\n    def empty(self):\n        return len(self.elements) == 0\n\n    def put(self, item, priority):\n        heapq.heappush(self.elements, (priority, item,))\n\n    def get(self):\n        return heapq.heappop(self.elements)[1]\n\n\nclass AStar:\n    def __init__(self, graph, start, goals=[]):\n        self.graph = graph\n        self.start = start\n        self.frontier = PriorityQueue()\n        self.frontier.put(start, 0)\n        self.previous = {}\n        self.previous[start] = None\n        self.costs = {}\n        self.costs[start] = 0\n        self.final_path = None\n        self.goals = goals\n        self.goal = None\n\n    def search(self):\n        graph = self.graph\n        frontier = self.frontier\n        goals = self.goals\n        costs = self.costs\n        while not frontier.empty():\n            state = frontier.get()\n            if state in goals:\n                cost = self.costs[state]\n                self.goal = state\n                self.final_path = self.trace_path()\n                return Map({'path': self.final_path, 'cost': cost})\n\n            for next_state in graph[state]:\n                new_cost = costs[state] + 1\n                if next_state not in costs or new_cost < costs[next_state]:\n                    costs[next_state] = new_cost\n                    priority = new_cost\n                    frontier.put(next_state, priority)\n                    self.previous[next_state] = state\n        # No path found\n        return Map({'path': [], 'cost': 0})\n\n    def trace_path(self):\n        current = self.goal\n        path = []\n        while current != self.start:\n            path.append(current)\n            current = self.previous[current]\n        path.append(self.start)\n        path.reverse()\n        return path\n\ndef YenKSP(graph, source, sink, k_paths):   \n    graph_clone = copy.deepcopy(graph)\n    A = [AStar(graph, source, sink).search().path]\n    B = []\n\n    for k in range(1, k_paths):\n        for i in range(len(A[-1]) - 1):\n            spur_node = A[-1][i]\n            root_path = A[-1][:i+1]\n            for path in A:\n                if len(path) > i and root_path == path[:i+1]:\n                    graph_clone[path[i]].remove(path[i+1])\n\n            result = AStar(graph_clone, spur_node, sink).search()\n            spur_path = result.path\n            total_path = root_path[:-1] + spur_path\n            spur_cost = AStar(graph_clone, source, spur_node).search().cost\n            B.append(Map({'path': total_path, 'cost': result.cost + spur_cost}))\n            graph_clone = copy.deepcopy(graph)\n        if len(B) == 0:\n            break\n        B.sort(key=lambda p: (p.cost, len(p.path)))\n        A.append(B[0].path)\n        B.pop()\n    return A\n\npaths = YenKSP(graph, 'A', 'F', 4)\nprint(paths)\n```\n\n    ", "Answer": "\r\n```\nimport copy\nimport heapq\n#from dotmap import Map\nfrom itertools import count\n\nclass Map(dict):\n    def __getattr__(self, k):\n        return self[k]\n    def __setattr__(self, k, v):\n        self[k] = v\n\ngraph = {\n    'A': ['B', 'E'],\n    'B': ['C', 'D'],\n    'C': ['G'],\n    'D': ['C', 'F'],\n    'E': ['D'],\n    'F': [],\n    'G': ['F']\n}\n\nclass PriorityQueue:\n    def __init__(self):\n        self.elements = []\n        self._counter = count()\n\n    def empty(self):\n        return len(self.elements) == 0\n\n    def put(self, item, priority):\n        heapq.heappush(self.elements, (priority, item,))\n\n    def get(self):\n        return heapq.heappop(self.elements)[1]\n\n\nclass AStar:\n    def __init__(self, graph, start, goals=[]):\n        self.graph = graph\n        self.start = start\n        self.frontier = PriorityQueue()\n        self.frontier.put(start, 0)\n        self.previous = {}\n        self.previous[start] = None\n        self.costs = {}\n        self.costs[start] = 0\n        self.final_path = None\n        self.goals = goals\n        self.goal = None\n\n    def search(self):\n        graph = self.graph\n        frontier = self.frontier\n        goals = self.goals\n        costs = self.costs\n        while not frontier.empty():\n            state = frontier.get()\n            if state in goals:\n                cost = self.costs[state]\n                self.goal = state\n                self.final_path = self.trace_path()\n                return Map({'path': self.final_path, 'cost': cost})\n\n            for next_state in graph[state]:\n                new_cost = costs[state] + 1\n                if next_state not in costs or new_cost < costs[next_state]:\n                    costs[next_state] = new_cost\n                    priority = new_cost\n                    frontier.put(next_state, priority)\n                    self.previous[next_state] = state\n        # No path found\n        return Map({'path': [], 'cost': float('inf')})\n\n    def trace_path(self):\n        current = self.goal\n        path = []\n        while current != self.start:\n            path.append(current)\n            current = self.previous[current]\n        path.append(self.start)\n        path.reverse()\n        return path\n\ndef YenKSP(graph, source, sink, k_paths):\n    A = [AStar(graph, source, sink).search().path]\n    B = []\n\n    for _ in range(1, k_paths):\n        for i in range(len(A[-1]) - 1):\n            graph_clone = copy.deepcopy(graph)\n\n            spur_node = A[-1][i]\n            root_path = A[-1][:i+1]\n            for path in A:\n                if len(path) > i and root_path == path[:i+1]:\n                    if path[i+1] in graph_clone[path[i]]:\n                        graph_clone[path[i]].remove(path[i+1])\n\n            result = AStar(graph_clone, spur_node, sink).search()\n            spur_path = result.path\n            total_path = root_path[:-1] + spur_path\n            spur_cost = AStar(graph_clone, source, spur_node).search().cost\n            B.append(Map({'path': total_path, 'cost': result.cost + spur_cost}))\n\n        if len(B) == 0:\n            break\n\n        B.sort(key=lambda p: (p.cost, len(p.path)))\n        best_b = B.pop(0)\n        if best_b.cost != float('inf'):\n            A.append(best_b.path)\n    return A\n\npaths = YenKSP(graph, 'A', 'F', 4)\nprint(paths)\n```\n\n\nProduces:\n\n\n[['A', 'B', 'D', 'F'], ['A', 'E', 'D', 'F'], ['A', 'B', 'C', 'G', 'F'], ['A', 'B', 'D', 'C', 'G', 'F']]\n\n\nThe main issue was that when there was no path found, your default returned a path with 0 cost.  So when sorted by path cost, these paths were appearing as the best choice in ```\nB```\n and being added to ```\nA```\n.  I changed the default path cost to ```\nfloat('inf')```\n.  Doing so revealed an error that could occur when you tried to remove the same edge twice from ```\ngraph_clone```\n (inside ```\nfor path in A: ...```\n), so I added an ```\nif```\n check to conditionally remove the edge.  The two last things the diff indicate that I did were (a) imitate your ```\ndotmap.Map```\n class (you can remove this and uncomment the import), and (b) only add a path to the resultset ```\nA```\n if the cost is finite.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Find next shortest path in neo4j\r\n                \r\nI want to find a couple of paths between 2 nodes. I don't just want the shortest path or all paths with the shortest length (allShortestPaths). I need all the shortest paths and the next shortest paths. Since it is not possible to set allShortestPaths with minimal length different from 0/1.\n\"allShortestPaths(...) does not support a minimal length different from 0 or 1\"\nIt could be solved with projections or apoc.path.expandConfig, however we have a database with 14 million nodes and 56 million relationships, so when I tried doing this, we could deliver paths with lengths of 4 in 20-30 seconds and lengths of more than 4 was not possible. Is there a way to find a subset of all paths that are shortest, but also fast to execute?\nLets say my source node is A, and target node is F, and I wanted the 3 shortest paths, the 3 paths would then be:\n(A-f), (A-C-F), (A-B-F)\n\n    ", "Answer": "\r\nI figured that yen's algorithm would be very suitable after I tried using projections (which was pretty fast)\nhttps://neo4j.com/docs/graph-data-science/current/algorithms/yens/\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path generator in NetworkX\r\n                \r\nI have graph with a few hundred to few thousands nodes, with weights and its named ```\nG```\n.\nI want to calculate all shortest paths of this graph. To do this, I wrote\n```\npathlens = nx.algorithms.shortest_paths.generic.shortest_path_length(G, weight=\"weight\")\n```\n\nBut due to the size of the dictionary it returns a generator object, so I can't simply do ```\npathlens[x][y]```\n to get the shortest path length from ```\nx```\n to ```\ny```\n.\nI tried to convert it to a dict using ```\ndict(pathlens)```\n but this operation is taking a long time (at least a few seconds, and it's still going as I write this question). Is there any better way to access shortest paths from this generator?\n    ", "Answer": "\r\nTry iterating over the generator, something like that:\n```\nimport networkx as nx\n\nG = nx.path_graph(5)\nP = nx.shortest_path_length(G)\nfor key, value in P:\n  print(key,'-->',value)\n```\n\nIf you have too much results, convert it to a dictionary will consume too much memory (It makes no sense to do that).  If you want a specific path, pass the source or the destination nodes or both, so the function will will not return a generator Networkx documentation, see 'Returns'.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Betweenness and shortest paths in R\r\n                \r\nI've been reviewing this interesting article:\n\nhttp://kieranhealy.org/blog/archives/2013/06/09/using-metadata-to-find-paul-revere/\n\nAs an exercise, I've been picking through the various steps taken to convict Mr. Revere of treason.  At one point, the author uses the betweenness function of the igraph library, which is described as:\n\n\n  \"The vertex and edge betweenness are (roughly) defined by the number of geodesics (shortest paths) going through a vertex or an edge.\"\n\n\nSo, in the case of the article, how many shortest communication paths between pairs of people go through each of the 254 people being considered?  I diverted a little from the article, though, and I'm wondering if I'm thinking naively.\n\nA 254 x 254 matrix has 64516 elements.  However, trivial elements (those on the diagonal-- a person talking to herself is obviously the shortest path from X to X) can be discounted, leaving (it seems) 254 * 254 - 254 = 64262 total nontrivial ordered pairings.  But, these are not directional-- that is, the shortest path between a particular pair X and Y is the same, regardless of which of X or Y is the sender and which is the receiver.  \n\nSo, we can reduce our number of pairings:  ```\n(254 * 254 - 254) / 2 = 32131```\n.\n\nSince this also happens to be the number of combinations of 2 selected from 254, even better-- a fine coincidence! ;-)\n\nThen, just for fun, I did:\n\n```\n((254 * 254 - 254) / 2) - sum(betweenness(person.g)) = 10061\n```\n\n\nWhat does this number mean?  It almost seems to say that there are 10,061 pairings for whom no path exists, but I don't see how that can be.  Do I misunderstand betweenness?  Many thanks in advance.\n    ", "Answer": "\r\nIf you check what happens on a simpler graph,\nyou will notice that shortest paths of length 1 \ndo not enter the computation.\n\n```\nbetweenness( graph.lattice( 3 ) )\n# [1] 0 1 0\n```\n\n\nShortest paths of length 2 will be used once (for the point in the middle),\nbut shortest paths of length 3 or more will be used several times: \nonce for each point in the middle.\n\n```\nbetweenness( graph.lattice( 5 ) )\n# [1] 0 3 4 3 0\n```\n\n\nIn this example, the shortest paths are \n\n```\nlength 1: 1-2, 2-3, 3-4, 4-5  (not used)\nlength 2: 1-3, 2-4, 3-5       (each used once, for the betweenness of 2, 3 and 4)\nlength 3: 1-4, 2-5            (each used twice, for 2,3 and 2,4)\nlength 4: 1-5                 (each used 3 times, for 2, 3 and 4)\n```\n\n\nIn other words, a shortest path of length k is counted k-1 times.\n\n```\np <- shortest.paths(person.g)\nsum( p[upper.tri(p)] - 1 )\n# [1] 22070\nsum( betweenness( person.g ) )\n# [1] 22070\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Visualize the paths and find shortest path(s) in 3D cube\r\n                \r\nI have some problems about the visualization of the paths and find the shortest paths from top to bottom.\n\nHere is my code:\n\n```\nclc; clear all; close all;\n\nPorosity = .3;\nm=20;\nn=20;\no=20;\n\nNodes= ones(m,n,o);\n\nHLines = zeros(m,n-1,o-1);\nHLines(randperm(numel(HLines),floor(Porosity*m*(n-1)*(o-1))))=1;\nHLines\n\nVLines = zeros(m-1,n,o-1);\nVLines(randperm(numel(VLines),floor(Porosity*(m-1)*n*(o-1))))=1;\nVLines\n\nPLines = zeros(m-1,n-1,o);\nPLines(randperm(numel(PLines),floor(Porosity*(m-1)*(n-1)*o)))=1;\nPLines\n\nfor i=1:m\n    for j=1:n-1\n        for k=1:o-1\n        if HLines(i,j)==1;\n            hold on\n            x = [i i+1];\n            y = [j j];\n            z = [k k];\n            plot3(x,y,z,'r','linewidth',2)\n        end\n        end\n    end\nend\n\nfor i=1:m-1\n    for j=1:n\n        for k=1:o-1\n        if VLines(i,j)==1;\n            hold on\n            x = [i i];\n            y = [j+1 j];\n            z = [k k];\n            plot3(x,y,z,'r','linewidth',2)\n        end\n        end\n    end\nend\n\n   for i=1:m-1\n      for j=1:n-1\n          for k=1:o\n          if PLines(i,j,k)==1;\n              hold on\n              x = [i i];\n              y = [j j];\n              z = [k+1 k];\n              plot3(x,y,z,'r','linewidth',2)\n          end\n          end\n      end\n   end\n\n   axis([0 m 0 n 0 o])\n   view(30,45)\n   set(gcf,'Position', [0 0 1500 1000])\n   xlabel('X'); ylabel('Y'); zlabel('Z')\n```\n\n\nThis code gives me the following figure which consists of a 3D cube and randomly distributed of ```\n1```\n and ```\n0```\n:\n\n\n\nIf there is ```\n1```\n then keep going; if there is ```\n0```\n, then stop.\n\nI want to visualize all of the paths from top to bottom, and I want to choose the shortest path(s).\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Generating Shortest Paths\r\n                \r\nI'm interested in attempting to (quickly) the shortest paths for a given grid.  The grid is n by m where each node corresponds to a position of x,y. Each node can be traveled to by all adjacent nodes with with either a cost of 1 or infinity from adjacent nodes (meaning that's its an unweighted graph where some nodes are impassible).  I haven't chosen constraints on n or m yet but I'd like to be able to pathfind a 100 by 100 graph. I've already tried a couple of options but none have been fast enough.  However, the constraints on the problem (unweighted, easy heuristic), make me think that someone might have a better solution to the problem. \n\nOne option that occurred to me (and I would like to do if possible) was pre-generating all of the paths for all options of n and m between 0 and 100. Obviously, that takes a significant amount of time but I was wondering if maybe there was some sort of online resource where I could find paths. Alternatively, if anyone has a method of computing all of the paths for all of the graphs reasonably quickly that would be great to.\n    ", "Answer": "\r\nNo one seems to be commenting on this question with anything very useful but I'd like to note that the comments given above are not entirely correct on the point that A* is the best solution. This isn't exactly an answer but I thought I would answer my question with some of the information I have found.\n\nJPS, a jump point search: https://gamedevelopment.tutsplus.com/tutorials/how-to-speed-up-a-pathfinding-with-the-jump-point-search-algorithm--gamedev-5818 can be used for an 8 way grid (a logical way of doing any cartesian grids) and is certainly one way of improving A* (though there may be others that people more informed on the topic could provide)\n\nIn addition, localizing the graph problem to smaller areas may help solve the problem for a general graph pathfinding algorithm\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Algorithm to find the number of shortest paths\r\n                \r\nGiven an undirected（no lengths） graph G=(V,E) with |V|=n and |E|= m, and two vertices v,w, find the algorithm that outputs the number of shortest v-w-paths in G. The running time should be O(m+n)\n\nI have been working with this problem but have difficulties to let the running time be O(m+n)\n\nSince this graph is both undirected and unweighted, I have tried this way. Use BFS to determine the length of the shortest v-w-path. Then use DFS to find the number of the v-w-shortest paths such that two nodes are connected and the length of path equals to the output of BFS.\nBut the running time of this plan is O(m+n)+O(m+n). \n\nAlso I've tried to modify the Dijkstra algorithm. Store the length of the shortest path and the number of the shortest path when there is a node adding to the set of visited nodes. And I 'm stuck with the computation of running time.\n    ", "Answer": "\r\nThis question may be looking for a modification of Dijsktra's algorithm. With Dijkstra's algorithm you maintain, for each node, the length of the shortest path to that node, and you update this at a node based on the shortest path to a neighbouring node and the length of the simple link from that neighbouring node to the node in question. \n\nAt each node you could keep, as well as the length of a shortest path to it, a table of the nodes that can precede it on a shortest path to it, and the number of shortest paths to that node, which should be the sum of the number of shortest paths to these neighbours. When you find a new shortest path to a node you either delete all of this information (if the new shortest path is shorter than before) or update the entry in that table for the second last node in the path, if the new path is the same length as the previous shortest path to that node.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Boost BGL Dijkstra Shortest Paths\r\n                \r\nI'm not familiar with boost libraries and trying to learn. I have used boost graphics library to call dijstra's shortest paths function to find a path to destination in a map. Vertices are intersections and edges are street segments. \n\nI am finding the shortest path by minimum time. For that I have edge weights defined as time, time = st segment length * its speed/limit. This indeed does give me the shortest path (by time). However, I'm to also account for a turn and add 15 seconds to total time for each. How I detect a turn is given two street segments (edges), if the st name of second is not equal to st name of first, it's a turn. \n\nBasically, I want to assign weights dynamically (not just setting them in the beginning like I'm doing here). When the program visits an edge during the search, I'd like it to check the parents (or predecessors here) at this stage. How do I pass in a function or something in the arguments that can do it? \n\n```\nvector<unsigned>  OurGraph::find_awesome_path(unsigned start, unsigned finish)\n{\n\n    // start and finish are intersection IDs,\n    // Get the corresponding Vertices in the graph. \n    Vertex start_node = vertex_map[start]; \n    Vertex dest_node = vertex_map[finish];   \n\n    std::vector<Vertex> predecessors(boost::num_vertices(my_graph)); // To store parents\n    std::vector<float> distances(boost::num_vertices(my_graph)); // To store dijkstra distances\n\n    IndexMap indexMap = boost::get(boost::vertex_index, my_graph);\n    PredecessorMap predecessorMap(&predecessors[0], indexMap);\n    DistanceMap distanceMap(&distances[0], indexMap);\n\n    boost::dijkstra_shortest_paths(my_graph, start_node, boost::distance_map(distanceMap).predecessor_map(predecessorMap));\nvector<Edge> path;\n\n    path = get_edge_path(dest_node, predecessorMap);    // Extracts edges from edge descriptors in predecessor map\n                                                    // and piles them in a vector of Edge. \n    return segment_list_from_edges(path);           // Convert edges to street segment IDs and return.\n}\n```\n\n\nWhere my_graph is a type Graph and Graph , Vertex, Edge, IndexMap, PredecessorMap and DistanceMap are type defined as following: \n\n```\ntypedef boost::property<boost::edge_weight_t, float> WeightProperty;\ntypedef boost::property<boost::vertex_name_t, unsigned> IntersectionProperty;  \ntypedef boost::adjacency_list < boost::listS, boost::vecS, boost::directedS,\n  IntersectionProperty, WeightProperty > Graph;\ntypedef boost::graph_traits < Graph >::vertex_descriptor Vertex;\ntypedef boost::graph_traits < Graph >::edge_descriptor Edge;\ntypedef boost::property_map < Graph, boost::vertex_index_t >::type IndexMap;\ntypedef boost::iterator_property_map < Vertex*, IndexMap, Vertex, Vertex& > PredecessorMap;\ntypedef boost::iterator_property_map < float*, IndexMap, float, float& > DistanceMap;\n```\n\n    ", "Answer": "\r\nOne way you can do this is to use a differential graph. In that case each vertex in the differential graph would be equivalent to an edge in your current graph. So a vertex would encapsulate a turn for example. Then you can add the turn weights to the edges which involve a change in street name (or whatever mechanism you use to determine turns.)\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "All Nodes shortest Paths\r\n                \r\nI am a new user to Python. The following code is working for finding the shortest path from a source node, say B to all other nodes. I am interested to find shortest distance from every node.i.e, from A to all , from B to all, ..... from G to all. Can some body help me please how to do it. Thank you.\n\n```\nnodes = ('A', 'B', 'C', 'D', 'E', 'F', 'G')\n\ndistances = {\n\n    'B': {'A': 5, 'D': 1, 'G': 2},\n\n    'A': {'B': 5, 'D': 3, 'E': 12, 'F' :5},\n\n    'D': {'B': 1, 'G': 1, 'E': 1, 'A': 3},\n\n    'G': {'B': 2, 'D': 1, 'C': 2},\n\n    'C': {'G': 2, 'E': 1, 'F': 16},\n\n    'E': {'A': 12, 'D': 1, 'C': 1, 'F': 2},\n\n    'F': {'A': 5, 'E': 2, 'C': 16}}\n\nunvisited = {node: None for node in nodes} \n\nvisited = {}\n\ncurrent = 'B'\n\ncurrentDistance = 0\n\nunvisited[current] = currentDistance\n\n\nwhile True:\n\n    for neighbour, distance in distances[current].items():\n\n        if neighbour not in unvisited: continue\n\n        newDistance = currentDistance + distance\n\n        if unvisited[neighbour] is None or unvisited[neighbour] > newDistance:\n\n            unvisited[neighbour] = newDistance\n\n    visited[current] = currentDistance\n\n    del unvisited[current]\n\n    if not unvisited: break\n\n    candidates = [node for node in unvisited.items() if node[1]]\n\n    current, currentDistance = sorted(candidates, key = lambda x: x[1])[0]\n\n\nprint(visited)\n```\n\n    ", "Answer": "\r\nIf you are trying to loop over all the nodes, you can do a loop over the initial value of ```\ncurrent```\n. This will require minimal modification to your code:\n\n```\nnodes = ('A', 'B', 'C', 'D', 'E', 'F', 'G')\ndistances = {\n    'B': {'A': 5, 'D': 1, 'G': 2},\n    'A': {'B': 5, 'D': 3, 'E': 12, 'F' :5},\n    'D': {'B': 1, 'G': 1, 'E': 1, 'A': 3},\n    'G': {'B': 2, 'D': 1, 'C': 2},\n    'C': {'G': 2, 'E': 1, 'F': 16},\n    'E': {'A': 12, 'D': 1, 'C': 1, 'F': 2},\n    'F': {'A': 5, 'E': 2, 'C': 16}}\n\nfor start in nodes:\n    current = start\n    currentDistance = 0\n    unvisited = {node: None for node in nodes} \n    visited = {}\n    unvisited[current] = currentDistance\n\n    while True:\n        for neighbour, distance in distances[current].items():\n            if neighbour not in unvisited: continue\n            newDistance = currentDistance + distance\n            if unvisited[neighbour] is None or unvisited[neighbour] > newDistance:\n                unvisited[neighbour] = newDistance\n        visited[current] = currentDistance\n        del unvisited[current]\n        if not unvisited: break\n        candidates = [node for node in unvisited.items() if node[1]]\n        current, currentDistance = sorted(candidates, key = lambda x: x[1])[0]\n\n    print('-- Shortest distances from %s --' % start)\n    print(visited)\n```\n\n\nBasically, I made a loop over ```\nstart```\n and set the initial ```\ncurrent```\n to ```\nstart```\n. I also added a printout at the end to tell you which starting node the information is displayed for.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How to extract edge types for all shortest paths in R with igraph?\r\n                \r\nigraph has two useful functions, ```\nshortest_paths```\n and ```\nall_shortest_paths```\n. The former outputs one of the shortest paths, the other outputs all of them. However, the former also is able to output the edge types of the path while the latter doesn't seem to be able to.\nHow do I use ```\nall_shortest_paths```\n to extract the \"edge type\" for all of the shortest paths? I have provided clarifying code below:\n```\nlibrary(igraph)\nm <- read.table(row.names=1, header=TRUE, text=\n                  \" A B C D\n                A 0  1  1  0  \n                B 0  0 0  1 \n                C 0 0  0  1\n                D 0  0  0  0\")\nm <- as.matrix(m)\nig <- graph.adjacency(m, mode=\"directed\")\nplot(ig)\nE(ig)\nfor (i in 1:length(E(ig))) {\n  \n  if (i == 4) {\n    \n    E(ig)[i]$type <- -1\n  } else {\n\n    E(ig)[i]$type <- 1\n  }\n  \n}\n\n###This gets one of the shortest paths\ntest1 <- shortest_paths(ig, from = V(ig)[1], to = V(ig)[4], mode = \"out\", output = \"epath\")\n\n###This outputs the types for the shortest path above\ntest1$epath[[1]]$type\n\n###This gets all the shortest paths\ntest2 <- all_shortest_paths(ig, from = V(ig)[1], to = V(ig)[4], mode = \"out\")\n\n###The code below doesn't work. How do I get the types for ALL the shortest paths?\ntest2$res[[1]]$type\n```\n\n    ", "Answer": "\r\nTry the code below\n```\ndf <- get.data.frame(ig)\nlapply(\n  test2$res,\n  function(x) {\n    nm <- names(x)\n    merge(\n      df,\n      data.frame(from = head(nm, -1), to = tail(nm, -1))\n    )$type\n  }\n)\n```\n\nand you will get\n```\n[[1]]\n[1]  1 -1\n\n[[2]]\n[1] 1 1\n```\n\n\nIf you want to see more information, you can use\n```\ndf <- get.data.frame(ig)\nlapply(\n  test2$res,\n  function(x) {\n    nm <- names(x)\n    merge(\n      df,\n      data.frame(from = head(nm, -1), to = tail(nm, -1))\n    )\n  }\n)\n```\n\nand you will get\n```\n[[1]]\n  from to type\n1    A  C    1\n2    C  D   -1\n\n[[2]]\n  from to type\n1    A  B    1\n2    B  D    1\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "K-shortest paths using networkx package in python\r\n                \r\nI have created a multidigraph of motorway of Netherlands using osmnx package. \n\nThe graph is a multidigraph returned from osmnx. Since I am interested to compute k-shortest paths between an origin and a destination, I tried networkx library. However, networkx does not seem to work with multidigraph. All I can compute the shortest path.\n\nI would like to ask if there is any other way to perform the k-shortest path computation in python over multidigraph.\n    ", "Answer": "\r\nTry using the networkx command ```\nshortest_simple_paths```\n (documentation).\n\nIt returns a generator which returns one path at a time from shortest to longest.\n\n```\nG = nx.karate_club_graph()\nX = nx.shortest_simple_paths(G, 0, 5)\nk = 5\nfor counter, path in enumerate(X):\n     print(path)\n     if counter == k-1:\n         break\n> [0, 5]\n> [0, 6, 5]\n> [0, 10, 5]\n> [0, 6, 16, 5]\n> [0, 4, 6, 5]\n```\n\n\nThis will work with ```\nDiGraph```\ns, but I'm not sure about a ```\nMultiDiGraph```\n.  It's not clear to me that a road network would be a MultiDiGraph, however.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path (path + length) in Igraph\r\n                \r\nI have a (possibly dumb) shortest path question. What is the best way to get both the path (vpath is perfect for me) and the total weight of the shortest path. I see functions ```\nshortest_paths```\n (returns paths) and ```\ndistances```\n (returns total weight) but that would mean calculating things twice. NB, I have weights in my graph. Is there a function to quickly calculate the total weight of a path?\n```\n> print(g)\nIGRAPH 6c62431 DNW- 14 28 -- \n+ attr: name (v/c), weight (e/n)\n+ edges from 6c62431 (vertex names):\n [1] src  ->i1-j1 src  ->i1-j2 src  ->i1-j3 src  ->i1-j4 i1-j1->i2-j2\n [6] i1-j1->i2-j3 i1-j1->i2-j4 i1-j1->i2-j5 i1-j2->i2-j3 i1-j2->i2-j4\n[11] i1-j2->i2-j5 i1-j3->i2-j4 i1-j3->i2-j5 i1-j4->i2-j5 i2-j2->i3-j3\n[16] i2-j2->i3-j4 i2-j2->i3-j5 i2-j2->i3-j6 i2-j3->i3-j4 i2-j3->i3-j5\n[21] i2-j3->i3-j6 i2-j4->i3-j5 i2-j4->i3-j6 i2-j5->i3-j6 i3-j3->snk  \n[26] i3-j4->snk   i3-j5->snk   i3-j6->snk  \n> shortest_paths(g,from=\"src\",to=c(\"snk\"),output=\"both\")\n$vpath\n$vpath[[1]]\n+ 5/14 vertices, named, from 6c62431:\n[1] src   i1-j1 i2-j4 i3-j5 snk  \n\n\n$epath\n$epath[[1]]\n+ 4/28 edges from 6c62431 (vertex names):\n[1] src  ->i1-j1 i1-j1->i2-j4 i2-j4->i3-j5 i3-j5->snk  \n\n\n$predecessors\nNULL\n\n$inbound_edges\nNULL\n\n> distances(g,v=c(\"src\"),to=c(\"snk\"))\n    snk\nsrc  16 \n```\n\n    ", "Answer": "\r\nThis seems to work:\n```\n> sp <- shortest_paths(g,from=\"src\",to=\"snk\",output=\"both\")\n> sp[\"vpath\"][[1]][[1]]\n+ 12/112 vertices, named, from 1e5c3a5:\n [1] src     i1-j2   i2-j5   i3-j7   i4-j8   i5-j11  i6-j12  i7-j13  i8-j14 \n[10] i9-j15  i10-j17 snk    \n> sum(E(g)$weight[sp[\"epath\"][[1]][[1]]])\n[1] 8860.797\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "BFS Modification For Total Shortest Paths\r\n                \r\nI was given the following problem as an assignment but it is really confusing me:\n\n\n  Consider the BFS algorithm. Given a digraph G = (V, E) and a starting\n  vertex s ∈ V, this algorithm computes for each vertex u ∈ V the value\n  d[u], which is the length (number of edges) on the shortest path from\n  s to u. The objective of this problem is to modify the BFS algorithm\n  of class to compute the number of shortest paths from s to each vertex\n  of G. \n  \n  This can be done in two steps:\n  \n  (a) First run the standard BFS on G, starting from s. Explain how to use the result of this BFS to produce a new digraph G2 = (V 2,E2),\n  where V 2 ⊆ V and E2 ⊆ E, such that every path in G2 that starts at s,\n  is a shortest path in G starting from s, and conversely, every\n  shortest path in G starting from s is a path in G2.\n  \n  (b) Explain how to take the result of part (a) to compute for each vertex u ∈ V , a quantity n[u], which is the number of paths in G2\n  from s to u. (Hint: This can be done by a modification of BFS.) Both\n  of your algorithms should run in O(V + E) time.\n\n\nFor part a I am not quite sure how to use the results from the BFS to produce a new digraph. I don't understand how/in what way it should be formed. Do I use the nodes that were visited to form a new graph? All nodes are visited when doing a BFS, how am I supposed to form a different graph. \n    ", "Answer": "\r\nThe question ```\n(a)```\n can be solved by running the BFS normally, but for every edge ```\n(u, v)```\n you find while doing it, if ```\nshortest-path(u)+1 <= shortest-path(v)```\n (no matter if ```\nv```\n was already visited) then ```\n(u, v)```\n is a directed edge in ```\nG2```\n. \n\nAlso, while doing it, to solve ```\n(b)```\n you should increase ```\nn[v] += n[u]```\n. In the beginning, ```\nn[u] = 0```\n for everyone except ```\ns```\n, where ```\nn[s] = 1```\n.\n\nHere is an example Python implementation:\n\n```\nfrom collections import deque\n\ndef bfs(G, s):\n    shortest = [float('+Inf')]*len(G)\n    count = [0]*len(G)\n\n    shortest[s] = 0\n    count[s] = 1\n\n    Q = deque([s])\n\n    while Q:\n        u = Q.popleft()\n        for v in G[u]:\n            if not count[v]: \n                Q.append(v)\n\n            if shortest[u]+1 <= shortest[v]:\n                shortest[v] = shortest[u]+1\n                count[v] += count[u]\n    return count\n\nG = [\n    [1, 2, 3],\n    [4],\n    [4],\n    [4],\n    []\n]\n\nprint bfs(G, 0)       \n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path in Answer Set Programming\r\n                \r\nI'm trying to find all the shortest path from one source node to all other destination node (so 1-3, 1-5, 1-4) with the relative cost for each shortest path.\nI've tried with this code\n```\nnode(1..5).\n\nedge(1,2,1).\nedge(2,3,9).\nedge(3,4,4).\nedge(4,1,4).\nedge(1,3,1).\nedge(3,5,7).\n\nstart(1).\nend(3).\nend(4).\nend(5).\n\n0{selected(X,Y)}1:-edge(X,Y,W).\npath(X,Y):-selected(X,Y).\npath(X,Z):-path(X,Y),path(Y,Z).\n:-start(X),end(Y),not path(X,Y).\ncost(C):-C=#sum{W,X,Y:edge(X,Y,W),selected(X,Y)}.\n#minimize{C:cost(C)}.\n\n#show selected/2.\n```\n\nbut my code return this answer\n```\n> `clingo version 5.6.0 (c0a2cf99)\n> Reading from stdin\n> Solving...\n> Answer: 1\n> selected(3,4) selected(1,3) selected(3,5)\n> Optimization: 12\n> OPTIMUM FOUND\n> \n> Models       : 1\n> Optimum    : yes\n> Optimization : 12\n> Calls        : 1\n> Time         : 0.043s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)\n> CPU Time     : 0.000s`\n```\n\nWhat is wrong? How can I enumerate all shortest paths with relative costs?\n    ", "Answer": "\r\nSurely an error is that you are aggregating all the costs in ```\nC```\n but, if I have correctly understood, you need distinct costs depending on the ending node.\nThen there may be also other errors, but I can't exactly understand what do you mean with that program.\nI would write it as follows:\n```\nnode(1..5) .\n\nedge(1,2,1) .\nedge(2,3,9) .\nedge(3,4,4) .\nedge(4,1,4) .\nedge(1,3,1) .\nedge(3,5,7) .\n\nstart(1) .\nend(3) .\nend(4) .\nend(5) .\n\n% For each destination E, some outgoing edge from the start node should be selected\n:- start(S), end(E), not selected(S,_,E) .\n\n% No edge pointing to the start node should be selected\n:- start(S), selected(_,S,_) .\n\n% If an edge points to the end node, then it may be (or not be) selected for reaching it\n0{selected(X,E,E)}1 :- edge(X,E,_), end(E) .\n\n% If an outgoing edge from Y has been selected for reaching E, then an incoming edge may be (or not be) selected for reaching E\n0{selected(X,Y,E)}1 :- edge(X,Y,_), selected(Y,_,E) .\n\n% Compute the cost for reaching E\ncost(E,C) :- C=#sum{W : edge(X,Y,W), selected(X,Y,E)}, end(E) .\n#minimize{C : cost(E,C)} .\n\n#show selected/3 .\n#show cost/2 .\n```\n\nThe execution of the above program is as follows:\n```\nclingo version 5.3.0\nReading from test.lp\nSolving...\nAnswer: 1\nselected(3,5,5) selected(1,3,3) selected(3,4,4) selected(1,3,4) selected(1,3,5) cost(3,1) cost(4,5) cost(5,8)\nOptimization: 14\nOPTIMUM FOUND\n\nModels       : 1\n  Optimum    : yes\nOptimization : 14\nCalls        : 1\nTime         : 0.017s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)\nCPU Time     : 0.000s\n```\n\nwhere:\n\nan atom ```\nselect(X,Y,Z)```\n indicates that the edge ```\n(X,Y)```\n has been selected for reaching the node ```\nZ```\n;\nan atom ```\ncost(E,C)```\n indicates that the minimum cost for reaching the end node ```\nE```\n is ```\nC```\n.\n\nThe starting node is implicit since it is unique.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "The shortest paths from all nodes to one node?\r\n                \r\nI'm looking for an algorithm that if we pass an adjacency matrix (graph) and a node, we can get the shortest path from every node to that node. I was investigating about Dijkstra algorithm. I like it because its complexity is O(V*lg(V)), the problem is that Dijkstra finds the shortest path from one node to all the nodes, I want the opposite: The shortest path from all the nodes to one node. I can use Dijkstra only if I work with undirected graphs, but if I use a directed graph, it won't work.\nI also was investigating about Floyd-Wharshall, I don't really like it for this problem, because its complexity is O(n^3) and it finds the shortest paths from all the nodes to all the nodes and I just want the shortest paths from all the nodes to one specific node.\nSomething like this:\n```\n \nit graph[n][n];\nint node = 2;\n\nint *shortest_paths = algorithm(graph, node)\n\n```\n\nMaybe there can be a variant of Dijkstra that I don't know.\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Find all shortest paths between all pairs of nodes in NetworkX\r\n                \r\nI am trying to get all shortest paths between all pairs of nodes in an undirected unweighted graph. I am currently using ```\nnx.all_pairs_shortest_path()```\n, but I don't understand why it only returns one shortest path for every pair of nodes. There are cycles in my graph so there should exist multiple shortest paths between certain nodes. Any suggestions?\n    ", "Answer": "\r\nIterate over all nodes in the graph:\n```\nresults = []\nfor n1 in G.nodes():\n    for n2 in G.nodes():\n        shortest_path = nx.single_source_dijkstra(G, source=n1, target=n2, weight=f)\n        results.append(shortest_path)\n        \n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How does boost graph dijkstra_shortest_paths pick the shortest path when there are multiple shortest paths between a specific pair of nodes?\r\n                \r\nI have an unweighted, undirected network of around 50000 nodes, from this network I need to extract the shortest path between any pair of nodes. I used the dijkstra_shortest_paths function from the boost library and it worked fine. Later I realised that between a given pair of nodes A and B, there can be more than one shortest path. In this case, how does the Dijkstra function pick among these shortest paths? Is it dependent on the node ids or the order of how these nodes are stored in the memory?\nI found a few questions asking about how to extract all of the shortest paths between two nodes as normally only one of them is extracted, for example this question and this question. However, I don't want to extract all of the shortest paths between two nodes. Instead, I want to know how exactly the very path returned by the function is picked up among other shortest paths that have the same length.\nI tried to have a deeper look into the related source code within the boost library, but it seems it is too advanced for me and I got lost soon. Also, I couldn't find an answer by googling, so I ask here.\n    ", "Answer": "\r\nThe exact algorithm is documented:\n```\nDIJKSTRA(G, s, w)\n  for each vertex u in V (This loop is not run in dijkstra_shortest_paths_no_init)\n    d[u] := infinity\n    p[u] := u\n    color[u] := WHITE\n  end for\n  color[s] := GRAY\n  d[s] := 0\n  INSERT(Q, s)\n  while (Q != Ø)\n    u := EXTRACT-MIN(Q)\n    S := S U { u }\n    for each vertex v in Adj[u]\n      if (w(u,v) + d[u] < d[v])\n        d[v] := w(u,v) + d[u]\n        p[v] := u\n        if (color[v] = WHITE)\n          color[v] := GRAY\n          INSERT(Q, v)\n        else if (color[v] = GRAY)\n          DECREASE-KEY(Q, v)\n      else\n        ...\n    end for\n    color[u] := BLACK\n  end while\n  return (d, p)\n```\n\nIn the linked page it highlights where events happen.\nIt follows that the order in which vertices are discovered dictates your answer.\nYou can achieve other tie-breakers without modifying the graph by specifying a custom comparison (```\nCompareFunction```\n).\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Throw an error if multiple shortest paths are found\r\n                \r\nGiven an undirected weighted graph, a start, and an end point. You need to find the shortest path to that end point, but throw an error if multiple shortest paths are found. How would we do the error part? Is there a way to check if multiple shortest paths to a destination node exist?\nMy idea is that when we pop out of the priority queue in dijkstra's algorithm, at that time if the node is the destination node, then we check if in this priority queue, another element exists for the same destination node.\nDuring the relaxation, instead of only pushing to the queue if the distance is less than, we can push if the distance is less than or equal to. But I am not sure about it.\nEDIT - Its a weighted undirected graph\n    ", "Answer": "\r\nOne way to do this is by creating a shortest path DAG. Whenever you relax some edge from node A to node B with cost C (assuming the current shortest distance from source to each node is stored in array dist), if dist[A] + C is greater than dist[B] then do nothing, if dist[A] + C is equal to dist[B], then we can reach B in a shortest path using a different route than before, so we add A to the list of nodes that can reach B in its shortest path (let's call this array pars), so we add A to pars of B, and finally if dist[A] + C is less than dist[B], then we update dist[B] and clear the previous values from pars[B], and add A to pars[B].\nThe resulting graph is guaranteed to be a DAG if all edge weights are strictly greater than 0. Then you can count the number of paths to the destination node using some easy dynamic programming methods, process node in a topological order, then the number of paths of each node is the sum of number of paths of nodes that reach it (nodes in pars[node]).\nHopefully this was useful and clear.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Effect on shortest paths after edges have been deleted\r\n                \r\nAn input of directed graph has been provided and I have found shortest paths to a particular node 'T' using both - asynchronous and synchronous Bellman-Ford algorithm.\nI was trying to find out the effect on the shortest paths after some edges are deleted. \nIn my approach, I tried to mark the distances at start nodes of the deleted edges as infinity and was trying to apply asynchronous Bellman-Ford, but I get stuck at the point because other nodes will not update their value as they already have the shortest path minimum value.\n\nCan anyone help me to figure out a way to find the new shortest paths without having to run the full algorithm again on the new graph?\n    ", "Answer": "\r\nYou can not. And a simple explanation can be found in Bellman-Ford algorithm itself:\n\nIf V is the set of nodes. A minimal path from starting node to any other node will pass maximum |V| nodes ( |V|-1 edges). This is the reason why you relax the edges for |V|-1 time, so that the 'information' from all nodes will propagate to the source. \n\nIs you already have applied Bellman-Ford algorithm on a graph, you can start relaxing all the deleted node's neighbors and propagate the changes to their neighbors until a path that wasn't using the deleted node (until no updates are being made). Aware of negative cycle.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Modified shortest path algorithm\r\n                \r\nI've been looking for solution but got stuck. \n\nI need to find shortest path in undirected graph. As input I got set of undirected edges ```\n(x,y,p)```\n where ```\nx```\n and ```\ny```\n are nodes and ```\np```\n which is weight of the edge between ```\nx```\n and ```\ny```\n. \n\nThe length of a path is defined as the sum of of absolute differences between adjacent edges of each node.\n\nExample edges:\n\n```\n1 2 1\n1 3 5\n2 4 5\n3 4 5\n4 6 2\n```\n\n\nThere are multiple paths from ```\n1```\n to ```\n6```\n:\n\n```\n1 -> 2 -> 4 -> 6   weight = |5 - 1| + |2 - 5| = 7\n1 -> 3 -> 4 -> 6   weight = |5 - 5| + |2 - 5| = 3\n```\n\n\nThus the shortest path has length ```\n3```\n, which should be the output of the algorithm.\n    ", "Answer": "\r\nYou can use Dijkstra on edges instead of nodes and it will work. Let ```\ns```\n be the source node and ```\nt```\n be the target. ```\nw(i,j)```\n be the weight of the edge ```\n(i,j)```\n. \n\n```\nd(i,j) = infinity for all edges (i,j)\nq = new empty priority queue, ordered by d\nfor all edges (s,x):\n    d(s,x) = 0\n    insert (s,x) into q\nwhile q is not empty:\n    (x,y) = q.dequeue\n    for all edges (y,z):\n        if z != x and d(x,y) + |w(x,y) - w(y,z)| < d(y,z):\n            d(y,z) = d(x,y) + |w(x,y) - w(y,z)|\n            insert (y,z) into q\n```\n\n\nThe result will be the minimum distance of an edge ```\n(x,t)```\n. The runtime is ```\nO(m * log m)```\n if the priority queue is implemented as a binary heap.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How to get more paths than the shortest path between nodes?\r\n                \r\nin d3.js I am using a fuction called ```\npath```\n to get the shortest path between 2 nodes.\nThe API says this: \n\n\n  node.path(target) <>\n  \n  Returns the shortest path through the hierarchy from this node to the\n  specified target node. The path starts at this node, ascends to the\n  least common ancestor of this node and the target node, and then\n  descends to the target node.\n\n\nWith this definition i created a new array to save the data between 2 nodes. I am able to click on a first node called ```\nbeginNode```\n and on a second node, which is ```\nd```\n. It works very good and the shortest path between them is saved in the array ```\nshortest_path```\n:\n\n```\n .on(\"click\", function(d, i) //Hier beginnt große \"click\"-Funktion\n              {\nshortest_path = beginNode && beginNode.path(d) || [];.....\n```\n\n\nSometimes there are many ways to get the path between 2 nodes, not only the shortest paths, also longer paths. Now, my goal is to store more paths between the 2 clicked nodes into that array or another array. But unfortunally, d3,js only offer that shortest path function. I hope some of you can help. Would be Djikstra  a right solution for this problem?\nThanks\n    ", "Answer": "\r\nThis is called the k shortest paths problem.  You can solve it using a variant of Dijkstra's algorithm called Eppstein's Algorithm\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path: DFS, BFS or both?\r\n                \r\nI know BFS alone can find the shortest path in an unweighted graph but I also read on a couple of sites where people were claiming that either BFS or DFS could do this. I just wanted to confirm that these were probably mistakes and that only BFS can do this (I wasn't completely confident even after doing a quick google search). If I'm incorrect, can someone please explain how it's possible for DFS to give shortest path.\n    ", "Answer": "\r\nDFS does not necessarily yield shortest paths in an undirected graph.  BFS would be the correct choice here.\n\nAs an example, consider a graph formed by taking the corners of a triangle and connecting them.  If you try to find the shortest path from one node to another using DFS, then you will get the wrong answer unless you follow the edge directly connecting the start and destination nodes.\n\nAs @nhahtdh notes below, there’s a variant of DFS called iterative deepening in which you run DFS with a maximum depth of one, then two, then three, etc. until you find your target. This will always find the shortest path, and does so using less memory than BFS.\n\nHope this helps!\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Verify the shortest path of a graph\r\n                \r\n[Edited] \nFor a graph G, we are given the shortest path distances from a vertex V1 to every other vertex of the graph. How can we verify that the distance given are the actual shortest paths that one can find (by Dijkstra's or some other algorithm)? and its running time?\n    ", "Answer": "\r\nI assume your graph is directed (undirected case works similar). For every edge (u,v) you have to verify that dist(v) <= dist(u) + length(u,v) holds. Moreover, for every vertex v, you need an edge (u,v) such that dist(v) = dist(u) + length(u,v). This can obviously be done in O(m) time, which is faster than just applying another shortest path computation. Moreover, it is less likely to have bugs.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How to count all of the shortest paths between 2 vertices?\r\n                \r\nSo if I have two vertices in a graph, and they are connected through more than one edge while having the same shortest path between them (i.e if I have node A and node B and they are connected directly through three edges (there are 3 shortest paths between them each of distance 1) so the count should return 3) How can I modify the BFS algorithm to achieve that? This is my code, it only compute the shortest path between 2 nodes but not the number of these shortest paths. \n\n```\npublic void BFSDegree(Graph g, string s, string p)\n    {\n        Queue<string> q = new Queue<string>();\n        dist.Add(s, 0);       \n        q.Enqueue(s);\n\n        while (q.Count() != 0)\n        {\n            string j = q.Dequeue();\n            foreach (string h in g.adjacentTo(j))\n            {\n                if (!dist.ContainsKey(h))\n                {\n                    q.Enqueue(h);\n                    dist.Add(h, 1 + dist[j]);\n                }\n\n                if (j == p)\n                {\n                    Console.WriteLine(\"               \" + dist[j]);\n                    return;\n                }\n            }\n        }\n    }\n```\n\n    ", "Answer": "\r\nIf a node u has x shortest paths, then an adjacent node v discovered thru it, would have x times y shortest paths, where y is the number of edges from u to v. Moreover, if v is reachable thru other adjacent nodes (with the same path length), then its count of shortest paths would be the sum of all the xy factors computed for each parent.\n\nSo the algorithm would be quite different than your prototype. I would suggest a main loop which increases the current length in each iteration, and then process the queue by looking at all the unvisited adjacent nodes of the nodes in the queue, computing the sum of xy factors for each of these adjacent nodes, and then clearing the queue and enqueing all the adjacent nodes (and marking them as visied) for the next iteration. In the first iteration the path length is 0 and the queue contains only the source node.\n\n```\npublic void BFSDegree(Graph g, string s, string p)\n{\n    Queue<string> q = new Queue<string>();\n    HashMap<string, int> path_counts = new HashMap<string, int>();\n    path_counts.put(s, 1);       \n    q.Enqueue(s);\n\n    while (q.size()>0)\n    {\n        HashMap<string, int> adj_nodes = new HashMap<string, int>();\n        foreach (string j in q) \n        {\n            foreach (string h in g.adjacentTo(j))\n            {\n                if (!path_counts.ContainsKey(h))\n                {\n                    int count = 0;\n                    if (adj_nodes.containsKey(h))\n                        count=adj_nodes.get(h);\n                    count += path_counts.get(j);\n                    adj_nodes.put(h, count);\n                }\n            }\n        }\n        if (adj_nodes.containsKey(p))\n        {\n            Console.WriteLine(\"               \" + adj_nodes.get(p));\n            return;\n        }\n        path_counts.putAll(adj_nodes);\n        q.clear();\n        q.addAll(adj_nodes.keySet());\n    }\n}\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "how to find the weight of shortest paths in sparse matrix\r\n                \r\nI need to find the shortest paths from a node to others node (based on the number of edges) in a sparse matrix and then calculate sum of the weights of the edges on the shortest path.\nI am using scipy.sparse but I do not know how to calculate the weight of the paths.\n```\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import shortest_path\n...\ngraph = csr_matrix(graph)\n...\ndist_matrix, predecessors = shortest_path(csgraph=graph, directed=False, indices=0, return_predecessors=True)\n\ndef _get_path_length(predecessors, target):\n    lngth = 1\n    end = target \n    while predecessors[end] != -9999:\n        lngth = 1 + lngth\n        end = predecessors[end]\n    return lngth\n\nfor idx, val in enumerate(lngth):\n        path_length = _get_path_length(predecessors, idx)\n        lngth[idx] = path_length\n        path_weighs [idx] = dist_matrix[idx] / path_length\n```\n\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Sum up shortest paths in a weighted network\r\n                \r\nI have a ```\ngraph```\n with 340 ```\nnodes```\n and 700 ```\nlinks```\n. As for performance indicator of the network, I want to compute the sum of all ```\nweighted shortest paths```\n in my network. \n\nI tried the ```\nall_shortest_paths```\n command from the ```\nigraph```\n package. But my system doesn't have enough RAM to store the resulting matrix. \nCan someone recommend a ```\npackage```\n or ```\ncode```\n which computes the sum of all shortest paths? (So the big matrix is not needed?)\nFor ```\nunweighted```\n networks is the command ```\nmean_distance```\n, which does basically something similar!?\n    ", "Answer": "\r\nYou could try the package dodgr. With \n\n```\ndodgr_dists(graph)\n```\n\n\nyou can generate a square matrix of distances between your nodes (more info).\n\nNote: This will only work if your graph is directed.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Python: how to optimize the count of all possible shortest paths?\r\n                \r\nIn a ```\n3x3```\n network I want to be able to determine all the shortest paths between any two nodes. Then, for each node in the network, I want to compute how many shortest paths pass through one specific node.\n\nThis requires using the ```\nnx.all_shortest_paths(G,source,target)```\n function, which returns a ```\ngenerator```\n. This is at variance from using the ```\nnx.all_pairs_shortest_path(G)```\n, as suggested here. The difference is that in the former case the function computes all the shortest paths between any two nodes, while in the latter case it computes only one shortest path between the same pair of nodes. \n\nGiven that I need to consider all shortest paths, I have come up with the following script. This is how I generate the network I am working with:\n\n```\nimport networkx as nx\nN=3\nG=nx.grid_2d_graph(N,N)\npos = dict( (n, n) for n in G.nodes() )\nlabels = dict( ((i, j), i + (N-1-j) * N ) for i, j in G.nodes() )\nnx.relabel_nodes(G,labels,False)\ninds=labels.keys()\nvals=labels.values()\ninds.sort()\nvals.sort()\npos2=dict(zip(vals,inds))\nnx.draw_networkx(G, pos=pos2, with_labels=False, node_size = 15)\n```\n\n\nAnd this is how I print all the shortest paths between any two nodes:\n\n```\nfor n in G.nodes():\n    for j in G.nodes():\n        if (n!=j): #Self-loops are excluded\n            gener=nx.all_shortest_paths(G,source=n,target=j)\n            print('From node '+str(n)+' to '+str(j))\n            for p in gener:\n                print(p) \n            print('------')\n```\n\n\nThe result is a path from node ```\nx```\n to node ```\ny```\n which only includes the nodes along the way. An excerpt of what I get is:\n\n```\nFrom node 0 to 2 #Only one path exists\n[0, 1, 2] #Node 1 is passed through while going from node 0 to node 2\n------\nFrom node 0 to 4 #Two paths exist\n[0, 1, 4] #Node 1 is passed through while going from node 0 to node 4\n[0, 3, 4] #Node 3 is passed through while going from node 0 to node 4\n------\n...continues until all pairs of nodes are covered...\n```\n\n\nMy question: how could I amend the last code block to make sure that I know how many shortest paths, in total, pass through each node? According to the excerpt outcome I've provided, node 1 is passed through 2 times, while node 3 is passed through 1 time (starting and ending node are excluded). This calculation needs to be carried out to the end to figure out the final number of paths through each node.\n    ", "Answer": "\r\nI would suggest making a dict mapping each node to 0\n\n```\ncounts = {}\nfor n in G.nodes(): counts[n] = 0\n```\n\n\nand then for each path you find -- you're already finding and printing them all -- iterate through the vertices on the path incrementing the appropriate values in your dict:\n\n```\n# ...\nfor p in gener:\n    print(p)\n    for v in p: counts[v] += 1\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Find the shortest path with the least number of edges\r\n                \r\nI need to modify Dijkstra's algorithm so that if there are several shortest paths I need to find the one with minimum number of edges on the path.\n\nI've been stuck on how to use Dijkstra's method to find multiple shortest paths, how do you do that? doesn't it always output only 1 shortest path? pseudo code or any general direction would be very helpful.\n    ", "Answer": "\r\nInstead of assigning every node with the distance from source you can assign the number of edges traversed so far also. So each node will have ```\n(distance,edges)```\n instead of ```\ndistance```\n only. Everything else works as usual and for every terminal node you record the one with minimum value of ```\n(distance,edges)```\n.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How turn restrictions in k-shortest paths algorithm in pgRouting\r\n                \r\nI want to turn restrictions in k-shortest paths in pgRouting.\nI calculate one path using pgr_trsp function now, but it gives only one route. I need several shortests paths and turn restriction.\n    ", "Answer": "\r\npgRouting does not have that functionality today. The best you can do today is write a wrapper that calls pgr_trsp multiple times.\n\nThere is additional work we want to do on trsp to convert it to boost along the lines of the work done on dijkstra in version 2.1.0 but it is not a priority at the moment without some funding.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Partial All Pairs Shortest Paths\r\n                \r\nGiven an undirected weighted graph which contains many nodes, how to compute a subset of the all pairs shortest path?\n\nA subset means some of the nodes in graph, not all of them(The subset of vertices of the graph, may be appointed manually, or from some clustering algorithm. The count of the selected vertices may be 1%~5% of the total vertices).\n\nEither Dijkstra or Floyd-Warshall may compute extra nodes, which may not be efficient enough for my application.\n\nIs there algorithms which compute all pair shortest path between specific nodes and result good performance?\n    ", "Answer": "\r\nBasically, I don't think you could just consider some nodes because the shortest path in the subgraph may not be globally shortest. So you have to consider all the nodes.\n\nMaybe you can implement the Dijkstra's algorithm like this: set a check subroutine in each iteration. if all the needed nodes have been fixed (the minimum paths have been found) terminate the algorithm. This will save time for the rest nodes.\n\nFor efficiency, I recommend use n times Dijkstra's algorithm if there are no negative edge lengths. If there are, use Johnson's algorithm, which offers a special reweighting technique to convert negative edge lengths into non-negative ones.\n\nMaybe you just need a faster server.\n\nHope that helps.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Edges used in Shortest Path\r\n                \r\nI have just learnt \"shortest path algorithm\". Now I am wondering how the shortest path graphs looks like.\n\nI.e. I am at Node ```\nN```\n and I have run the shortest path algorithm from here. So if I make a Graph using edges used in the shortest path algorithm, how the graphs looks like?\n\nI guess the graph will be Tree with Root at ```\nN```\n with shortest path between Root to any other Node.\n    ", "Answer": "\r\nBasically if you see the sub-graph constructed from the shortest paths, yes, it will be a tree, in fact,  a spanning tree. It will have similar properties as well. see the links, I have posted.   \n\n\n  Given a connected, undirected graph G, a shortest-path tree rooted at\n  vertex v is a spanning tree T of G, such that the path distance from\n  root v to any other vertex u in T is the shortest path distance from v\n  to u in G.\n\n\nReferences\n\n\n  shortest-path-tree\n  \n  Spanning Tree.\n  \n  shortest ptah tree.pdf\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest-path, 2 weight functions\r\n                \r\nThe question goes like this:\nA directed graph G = (V,E) is given, two vertices s,t, and two weight functions w1, w2.\nThere are no negative weighted cycles in G (by both w1 and w2).\nI need to describe an algorithm that finds the shortest-path from s to t by w2, among the given shortest-paths from s to t.\n\nI've found this:\nFInding All Shortest Paths Between Two Vertices\nbut the answers seem pretty vauge to me.\n\nI have no idea how to solve this (even a lame one).\nany help would be appreciated.\n    ", "Answer": "\r\nThe idea is to make ```\nw2```\n important - but not enough to affect thew outcome of ```\nw1```\n.\n\nLet ```\nSUM2```\n be the sum of ```\nw2```\n on all edges: ```\nSUM2 = Sum { w2(e) | e in E }```\n, and ```\nmin{w1} = min { w1(e) | e in E }```\n (minimal value according to ```\nw1```\n)\n\nBased on this, create your new weight function:\n\n```\nw(e) = w1(e) + w2(e)/min{w1}*(SUM2+1)\n```\n\n\nNow, given all shortest paths according to ```\nw1```\n - it is obvious why shortest paths according to ```\nw2```\n will be favored among them.\n\nOn the other hand, ```\nw2```\n is not 'strong' enough to overcome the importance of ```\nw1```\n and dominate, since note that the combined sum of ALL edges according to ```\nw2```\n is now less than a single node in ```\nw1```\n\n\nUse the above ```\nw```\n with any shortest path algorithm to get your desired shortest path.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Floyd Warshall: computing top-k shortest paths per vertex pair\r\n                \r\nIn the Floyd-Warshall algorithm, the shortest path cost is computed for any pair of vertices. Additional book-keeping allows us to keep the actual path (list of vertices) on the shortest path.\n\nHow can I extend Floyd-Warshall so that for any pair of vertices, the top-K shortest paths are found? For example, for K=3, the result would be that the 3 shortest paths are computed and maintained?\n\nI have been using the Java implementation from Sedgewick.\n    ", "Answer": "\r\nSounds more like Dijkstra would be simpler to modify for returning N shortest paths. The search is allowed to enter the vertex until K shortest alternatives has entered the vertex.\n\nFor more information you can check wikipedia article\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest paths with 2 constraints (Weight and Colour)\r\n                \r\nInput: We have a directed graph G=(V,E) and each edge has a weight and a colour {red,green}. We are also given a starting node s.Problem/Algorithm: Can we find for all u edges of G, the shortest paths s-u with at most k red edges ? First approach: We save for each node the shortest path with 0,1...k red edges. We modify Dijkstra's algorithm and depending on the colour of the edges we are looking into, we update the distances respectively. This approach fails due to its complexity. Second approach: We make k copies of G graph (G1,G2 ...Gk+1). In order to utilise the k red edges constraint, while we are searching for shortest paths with Dijkstra, every time we \"meet\" a red edge {ui,vi} in Gi, we connect ui with vi+1 in Gi+1. Because Gk+1 doesn't have any red edges, we can only reach Gk+1 with at most k edges.But it fails. For example with k=2 if a 2 red edges shortest path is found to X node then will not take into consideration a heavier path with less red edges which could lead to an undiscovered node. (If i had enough reputation i could post an image as example). Any ideas ?\n    ", "Answer": "\r\nI think your approaches are actually equivalent, provided that for approach #1, you record only the shortest distance to each node for each number of red edges used -- you don't need to record the entire path (just as you don't need to record it for ordinary Dijkstra on an ordinary shortest path problem)\n\nAlso this approach is sound.  In particular, your reasoning that approach #2 is faulty is itself wrong: for any node X in the original graph, there is no single corresponding node X in the new graph; instead there are separate vertices for each number of red edges used. So the two paths \"to X\" you are considering are not actually to the same node: one is to (X, 2 red edges used) and one is to e.g. (X, 1 red edge used).  Then you can use a single Dijkstra run to calculate shortest paths to all k+1 copies of every vertex (i.e. to the vertices (v, i red edges used) for each 0 <= i <= k and for each v in V(G)), and return the lowest.  (I'm assuming here that when you wrote \"Can we find for all u edges of G, the shortest paths s-u\", you meant \"for all nodes u of G, the shortest paths s-u\".)\n\nFinally, you need to make sure that for any red edge {u, v} in G, you delete the corresponding edge {ui, vi} for all Gi (as well as add in the edge {ui, vi+1}). You probably intended this, but you weren't explicit about it.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Find a minimum in a list of shortest paths\r\n                \r\nI have my graph object, im trying to find a method to find a minimum for a group of nodes.\n\nEx. Nodes:\n\n```\n      input_nodes=[123,45]\n      graph_nodes=[10, 76,123,45,98,456]\n```\n\n\nI  run an algoritm which calculate shortest path between every node in the graph and every node in the input. \n I have a dictionary with all shortest paths beetwen nodes :\n\n```\n                {10:{123:0.56, 45:0.2}, 76:{123:0, 45:0.23}......\n```\n\n\nand so on for every graphs node. \nHow to get only min weight which is different from zero:\n\nLike this:\n\nMinimum path node 10 has with node 45,\nMinimum path node 76 has with node 45, \n......\nThatnks\n    ", "Answer": "\r\nI assume there might be ties in the weights, i.e. one node can be equally \"close\" to more than one other node. The following code will include them all in a dict. The structure of the result is essentially the same as the input ```\nd```\n, but only the minimum weight items are retained. \n\nUpdate: if a node has no neighbors or only neighbors with weight 0, this node will map to a empty dict in the result. \n\n```\nd = {10:{123:0.56, 45:0.2}, 76:{123:0, 45:0.23}, 19:{17:0}, 20:{}}\n\ndef closest(ns):\n    m = min((v for v in ns.values() if v != 0), default=-1)\n    return {k: v for k, v in ns.items() if v == m}\n\nprint({k: closest(v) for k, v in d.items()})\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "ArangoDB: Find all shortest paths with conditions\r\n                \r\nproblem: I have a start node and i am searching for nodes with a certain property. But i want only the nodes connected with the shortest ones.\n\nExample: The green nodes have the property set, but i want only \"A\" and \"C\" back, because \"E\" has a longer path\n\n\n\nWhat ive got so far:\n\n```\nLET source = (FOR x IN Entity FILTER x.objectID == @nodeId\n    return x)[0]\nFOR node, edge, path IN 1..5 ANY source._id GRAPH 'm' \n FILTER CONTAINS(node.label,  @search)\n  LIMIT @limit\n  RETURN path\n```\n\n\nbut this returns everything instead of only the shortest paths\n    ", "Answer": "\r\nYou can get the distance from the origin node using ```\nLENGTH(path.edges)```\n, so if you put the traversal into a subquery you can find the shortest path length afterward and then filter by that length:\n\n```\nLET allMatches = (\n  FOR node, edge, path IN 1..3 ANY \"[vertex_id]\" GRAPH \"[my_graph]\"\n    FILTER CONTAINS(node.label,  @search)\n    LIMIT @limit\n    RETURN {node,path})\nLET shortestPathLength = MIN(FOR m IN allMatches COLLECT len = LENGTH(m.edges) RETURN len)\nFOR m IN allMatches\n  FILTER LENGTH(m.path.edges) == shortestPathLength\n  RETURN m.node\n```\n\n\nThere might be a nicer way to do this in one query (e.g. doing a breadth-first traversal and then getting it to stop somehow) but I'm not seeing it.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest Paths (all) between Source and Destination vertex\r\n                \r\nGiven an undirected graph (G) with edge weights. How do I find all possible shortest paths from source to destination.\nI cannot modify Dijkstra's algo, but allowed to use it as a procedure by providing inputs.\nMy first approach was to run Dijkstra's; extract the 1st set of shortest paths and then rip these edges from the graph and run Dijkstra's again. We run this until a path from source to destination does not change from every run of Dijkstra's\nIs there a better approach ?\n    ", "Answer": "\r\nYou should run Dijkstra only once. This executation will set the minimum cost to reach each vertice.\nAfter that, you can run a simple DFS (backtracking) from source to destination. But using only edges (v,u,c) that  cost[v]+c==cost[u].\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Find a minimum in a list of shortest paths\r\n                \r\nI have my graph object, im trying to find a method to find a minimum for a group of nodes.\n\nEx. Nodes:\n\n```\n      input_nodes=[123,45]\n      graph_nodes=[10, 76,123,45,98,456]\n```\n\n\nI  run an algoritm which calculate shortest path between every node in the graph and every node in the input. \n I have a dictionary with all shortest paths beetwen nodes :\n\n```\n                {10:{123:0.56, 45:0.2}, 76:{123:0, 45:0.23}......\n```\n\n\nand so on for every graphs node. \nHow to get only min weight which is different from zero:\n\nLike this:\n\nMinimum path node 10 has with node 45,\nMinimum path node 76 has with node 45, \n......\nThatnks\n    ", "Answer": "\r\nI assume there might be ties in the weights, i.e. one node can be equally \"close\" to more than one other node. The following code will include them all in a dict. The structure of the result is essentially the same as the input ```\nd```\n, but only the minimum weight items are retained. \n\nUpdate: if a node has no neighbors or only neighbors with weight 0, this node will map to a empty dict in the result. \n\n```\nd = {10:{123:0.56, 45:0.2}, 76:{123:0, 45:0.23}, 19:{17:0}, 20:{}}\n\ndef closest(ns):\n    m = min((v for v in ns.values() if v != 0), default=-1)\n    return {k: v for k, v in ns.items() if v == m}\n\nprint({k: closest(v) for k, v in d.items()})\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How to record the paths in shortest path algorithm (Floyd-Warshall)\r\n                \r\nMy code to find the shortest path via the Floyd-Warshall algorithm is working, but what I need is to actually store the path that is taken, not just the minimum value/cost/distance.\nHere is my code.\n```\n# import the vertices/distance matrix\nimport numpy as np\nfrom datetime import datetime\nimport gsheets_LH\n\nm1 = np.asarray(gsheets_LH.rangestore)\n\n# Store destinations\nfirstrow = m1[0, 1:]\n\n# Store origens\nfirstcolumn = m1[:, 0]\n\n# Delete first row from table (headers)\nG = np.delete(m1, 0, 0)\n\n# Delete column, leaving only numbers/values\nG = np.delete(G, 0, 1)\n\n# The number of origins\nnV = len(G)\n\n# Defining matrix to receive result\ndistance = list(map(lambda i: list(map(lambda j: j, i)), G))\n\n# Algorithm implementation for Line Haul Distance/Time Optimization\n\n\ndef floyd_warshall(G):\n    distance = list(map(lambda i: list(map(lambda j: j, i)), G))\n    # Adding vertices individually\n    for k in range(nV):\n        for i in range(nV):\n            for j in range(nV):\n                distance[i][j] = min(\n                    distance[i][j], distance[i][k] + distance[k][j])\n```\n\nI just want to store a matrix or some other way to return to me ALL the shortest paths between all nodes.\nAny help?\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Match doesn't found shortest paths\r\n                \r\nI have task. I have array of point. I know time, which need spent to go from one point to second. For me reccomended use neo4j to search shortest path .\nFirst I create in c# point(s):\n\n```\npublic bool AddPoint(Point point)\n{\n    bool sucess = false;\n    try\n    {\n        client.Cypher\n            .Create(\"(point:Point {newPoint})\")\n            .WithParam(\"newPoint\", point)\n            .ExecuteWithoutResults();\n\n        sucess = true;\n        Console.WriteLine(\"The point was added!\");\n    }\n    catch (Exception exception)\n    {\n        Console.WriteLine(\"Error! \" + exception);\n    }\n    return sucess;\n}\n```\n\n\nSecond function link two points:\n\n```\npublic void LinkTwoPoint(string firstName, string secondName, string time)\n        {\n            try\n            {\n                client.Cypher\n                .Match(\"(point1:Point)\", \"(point2:Point)\")\n                .Where((Point point1) => point1.Name == firstName)\n                .AndWhere((Point point2) => point2.Name == secondName)\n                .Create(string.Format(\"point1-[r:Time{0}time:{1}{2}]->point2\",\"{\", time,\"}\"))\n                .ExecuteWithoutResults();\n\n                Console.WriteLine(\"Ok. Point was connected!\");\n            }\n            catch (Exception exception)\n            {\n                Console.WriteLine(\"Error! \" + exception);\n            }\n        }\n```\n\n\nBut when I try search shortest path (query in browser. This is not c# code), the system doesn't found anything:\n\n```\nMATCH (pointStart:Point { name:\"Point_B\" }),(pointEnd:Point { name:\"Point_E\" }),\n  p = allShortestPaths((pointStart)-[*]-(pointEnd))\nRETURN p\n```\n\n\nCan you suggest anything to fix it?\n\nP.S. After execute this query:\n\n```\nMATCH (pointStart:Point { name:\"Point_B\" })-[r]-(pointEnd:Point { name:\"Point_E\" })\nRETURN pointStart, pointEnd, r\n```\n\n\nNo rows was founded.\n\n\n    ", "Answer": "\r\nFirst, try following query\n\n```\nMATCH (pointStart:Point { name:\"Point_B\" })-[r]-(pointEnd:Point { name:\"Point_E\" })\nRETURN pointStart, pointEnd, r\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "finding all the shortest paths between two node using jung\r\n                \r\ni know how to find a shortest path by using DijkstraShortestPath\nbut i wonder how i can find all the shortest paths between two node, and print them out.\n\nFor example there are two shortest path both are 3 hops between vertex A and C,\nprint out like this [A,B,D,C] and  [A,E,F,C]\nThanks!!\n    ", "Answer": "\r\nYou'll have to hack the DSP code a bit to do this; JUNG does not have this capability built in.  There are a few different ways you could go about this depending on what your needs are, but the basic idea is that you find the termination conditions and adjust them, and make sure that the data structures will store what you need as well.  \n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Find shortest path using GremlinPipeline\r\n                \r\nMy data is stored in a Titan graph database. I am trying to find the shortest path between two vertices (v1 and v2). Currently I have the following code:\n\n```\n    final Vertex v1 = titanGraph.getVertices(\"nodeId\", \"110969224\").iterator().next();\n    final Vertex v2 = titanGraph.getVertices(\"nodeId\", \"141396276\").iterator().next();\n    System.out.println(v2);\n\n    final GremlinPipeline<String, List> pipe = new GremlinPipeline<String, List>(v1)\n            .as(\"similar\")\n            .both(\"similar\")\n            .loop(\"similar\", new PipeFunction<LoopBundle<Vertex>, Boolean>() {\n                @Override\n                public Boolean compute(LoopBundle<Vertex> bundle) {\n                    return bundle.getLoops() < 4 && bundle.getObject() != v2;\n                }\n            })  \n            .path();\n```\n\n\nwhich returns alls the paths. I have the following questions:\n\n\nIs this tha fastest way to find the shortest path?\nHow can I get the shortest of all these paths?\n\n\nEDIT:\nI am trying to do the same work but with GremlinGroovyScriptEngine. I have the following code:\n\n```\n    List results = new ArrayList();\n    Bindings bindings = engine.createBindings();\n    bindings.put(\"v1\", v1); \n    bindings.put(\"v2\", v2); \n    bindings.put(\"results\", results);\n\n    engine.eval(\"v1.both.filter{it.nodeId!='nodeId'}.loop('similar'){!it.object.equals(v2) && it.loop < 5}.paths.fill(results)\", bindings);\n```\n\n\nbut I get the following error:\n\n```\nException in thread \"main\" javax.script.ScriptException: javax.script.ScriptException: java.lang.NullPointerException\n    at com.tinkerpop.gremlin.groovy.jsr223.GremlinGroovyScriptEngine.eval(GremlinGroovyScriptEngine.java:94)\n    at javax.script.AbstractScriptEngine.eval(AbstractScriptEngine.java:233)\n    at TitanQuery.findShortestPath(TitanQuery.java:89)\n    at TitanQuery.main(TitanQuery.java:40)\nCaused by: javax.script.ScriptException: java.lang.NullPointerException\n    at com.tinkerpop.gremlin.groovy.jsr223.GremlinGroovyScriptEngine.eval(GremlinGroovyScriptEngine.java:221)\n    at com.tinkerpop.gremlin.groovy.jsr223.GremlinGroovyScriptEngine.eval(GremlinGroovyScriptEngine.java:90)\n    ... 3 more\nCaused by: java.lang.NullPointerException\n    at com.tinkerpop.pipes.branch.LoopPipe.getLoops(LoopPipe.java:75)\n    at com.tinkerpop.pipes.branch.LoopPipe.processNextStart(LoopPipe.java:49)\n    at com.tinkerpop.pipes.AbstractPipe.next(AbstractPipe.java:89)\n    at com.tinkerpop.pipes.transform.PropertyPipe.processNextStart(PropertyPipe.java:29)\n    at com.tinkerpop.pipes.AbstractPipe.next(AbstractPipe.java:89)\n    at com.tinkerpop.pipes.util.Pipeline.next(Pipeline.java:115)\n    at com.tinkerpop.pipes.util.PipeHelper.fillCollection(PipeHelper.java:52)\n    at com.tinkerpop.gremlin.java.GremlinPipeline.fill(GremlinPipeline.java:1575)\n    at com.tinkerpop.gremlin.java.GremlinFluentPipeline$fill.call(Unknown Source)\n    at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:42)\n    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)\n    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)\n    at Script1.run(Script1.groovy:1)\n    at com.tinkerpop.gremlin.groovy.jsr223.GremlinGroovyScriptEngine.eval(GremlinGroovyScriptEngine.java:219)\n    ... 4 more\n```\n\n\nAny advice for any of these issues would be great.\n    ", "Answer": "\r\nYour code looks to be somewhat similar to the the shortest path recipe in GremlinDocs:\n\nhttp://gremlindocs.com/#recipes/shortest-path\n\nYou might want to read that section in full as you are evaluating ```\nboth```\n directions of a vertex which has consequences and has been shown to be better handled with the store/except pattern.\n\nOnce you have all the paths need to just select the shortest one from the returned list.  In pure Java that's a bit more work than with Groovy, but it basically boils down to a sort on the path length and then choosing the shortest one.  In groovy that would be something like:\n\n```\ngremlin> g.v(1).out.loop(1){it.object.id != \"3\" && it.loops < 6}.path.sort{a,b->a.size()<=>b.size()}   \n==>[v[1], v[3]]\n==>[v[1], v[4], v[3]]\n```\n\n\nLooking at that made me wonder if you could always just pop-off the first item in the pipeline as it would be the earliest path detected and hence the shortest:\n\n```\ngremlin> g.v(1).out.loop(1){it.object.id != \"3\" && it.loops < 6}.path[0]                            \n==>[v[1], v[3]]\n```\n\n\nYou might want to experiment with that a bit, but it sounds like a promising theory that would allow you to short-circuit the pipeline if you just needed the first shortest path detected.  \n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Property path does not work for getting shortest paths in Corese\r\n                \r\nI am using Corese to find shortest path between nodes in a simple FOAF file as follows:  \n\n\n\nHowever, when I use the following queries, it does not give me the shortest path. As the graph has different paths with loops, the result includes only one path for each node which is not the shortest one. \n\nQuery: \n\n```\nselect ?x ?y (pathLength($path) as ?p) \nwhere { ?x s (foaf:knows)+::$path ?y.\n        graph $path {?x foaf:knows ?pd}.\n        ?x foaf:nick \"Ali\". }\n```\n\n\nRESULT:\n\n```\n...\n source                       target                    shortest path length\n<http://www.example.org/Ali> to <http://www.example.org/Yu>    10\n...\n```\n\n\nAs you can see, \"Ali\" has a direct path to \"Yu\", but the query gives the longer path. Am I missing something in the query? \n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How to compute single source shortest paths with OSRM?\r\n                \r\nI've been playing around with the OSRM routing library recently. It seems to be highly efficient at solving the shortest path problem. However, I didn't see how to compute single source shortest paths with it. More precisely, given a fixed starting point, compute the shortest distances to all locations that can be reached within a given distance limit (e.g., reachable within 30 minutes).\n\nOSRM uses contraction hierarchies internally. From my understanding, this technique is way superior to Dijkstra's algorithm when it comes to computing the distance between two locations in real world data. However, for my problem, Dijkstra's algorithm seems to fit better, doesn't it? \n\nDoes OSRM provide an API to compute single source shortest path problems (with a limit on the distance)? Are there other free routing libraries that are better suited for this type of problem? Preferably one with good support for OpenStreetMap data.\n    ", "Answer": "\r\nOSRM is using contraction hierarchies (CH) to be that fast for \"one to one routing\". To make CH working you need an adapted bidirectional algorithm (A*, Dijkstra, ...) so the single source case is more difficult. BUT a one to many algorithm is relative simple if you know up front which destinations you want.\n\nAlso have a look into the paper \"Fast Detour Computation for Ride Sharing\" or here if you want a solution for a \"non goal-directed, bidirectional search\" which uses lookup tables.\n\n\n  other free routing libraries? \n\n\nI would suggest my Java GraphHopper project ;)\n\nbut there are of course more: http://wiki.openstreetmap.org/wiki/Routing\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "All-pairs shortest paths, tie breaking\r\n                \r\nI am creating a program which will calculate Betwenness Centrality for all nodes in a unweighted graph. To do that I have to find ASSSP (All Single Source Shortest Paths). While creating the program, I came to realize that eventually I will have ties (same distance from source to destination but different paths). This lead me to this question. How should I resolves these ties? If I use random tie breakers, then each output of the Betweenness Centrality might be slightly different for the same input. Let me make a small exemplary graph:\n\n```\n   A\n  / \\\nB    C\n  \\ /\n   D\n```\n\n\nNow lets say that the A node is our source for which we wish to find ASSSP. It can be clearly seen that There exist two paths (A->B->D and A->C->D), bot of them have the same length, both of them are the shortest ones. Now which one should I choose, and on what condition?\n\nRandom Tie breakers (problem)\n\nIf I use random tie breakers, like the first one to be found, is marked as the shortest path (the program is distributed so this solution will work in a random fashion). Then I will have problem with Betweenness Centrality, as the value will vary for nodes B and C; depending on which path was marked as the shortest.\n\nDoes anyone know how to solve this issue, or am I just missing something?\n    ", "Answer": "\r\nTo calculate the betweenness centrality properly, you must take into account every shortest path in the graph. If two nodes A and B have k shortest paths between them, each shortest path will contribute 1/k to the total betweenness scores of the nodes that the paths pass through. In general, you should not calculate betweenness centrality by actually finding (and storing) all the shortest paths in the networks; see the following paper for a more efficient algorithm:\n\nA Faster Algorithm for Betweenness Centrality\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Corner to corner shortest paths in a rectangular grid\r\n                \r\nI came across this question for an interview that I could not solve.\nCode to calculate the number of shortest paths from botton left to upper right corner of an mxn grid. How to solve this? \n    ", "Answer": "\r\nAssuming you want to solve it, but not the solution: consider 1x1, 1x2, (m-1)x(n-1)\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Cypher: Shortest Path with Constraint\r\n                \r\nI want to perform a shortest path query like the following:\n\n```\nSTART source=node:myIndex(name=\"<src>\"), destination=node:myIndex(name = \"<dst>\")                                                                               \nMATCH p = shortestPath(source-[:REL1*..5]-destination),\n          source-[sourceRel:REL1]-m, \n          destination-[destRel:REL1]-k\nWHERE sourceRel.a=<someValue> and destRel.a=<someOtherValue>                                                                                                      \nRETURN NODES(p);\n```\n\n\nI want to get the shortest path between ```\n<src>```\n and ```\n<dst>```\n with the constraint that the property ```\na```\n has a certain value on the first relationship from src and dst respectively to the next node.\n\nHowever, neo4j just returns any shortest path it finds without taking into account my constraint.\nWhat am I doing wrong? What is the correct way to specify constraints on the first \"hop\" of a shortest path for a shortest path query?\n\nedit: I'm using Neo4j 1.8.2.\n    ", "Answer": "\r\nAs of 2.0.0-M03 there's no good way to introduce constraints to ```\nshortestPath```\n. They are working on a new syntax to be able to do that, but it's still in the design phase. In order to do this, you'd need to take the less efficient route of not using ```\nshortestPath```\n, order by length and get the shortest one that matches all your constraints.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Successive Shortest Paths vs Ford–Fulkerson\r\n                \r\nCan someone explain how exactly Successive Shortest Paths (SSP) is a generalization of the Ford–Fulkerson algorithm? I've found this stated in a few papers and websites as well as the Wikipedia page for the Minimum-cost flow problem. But none of them go any further than that statement or explain how exactly they differ. Any help would be greatly appreciated. Thanks.\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Printing shortest path in adjacency matrix\r\n                \r\nI've made a Network (directed weighted graph) that contains an adjacency matrix with vertices and weighted edges.\n\nI've got a Path class set up, and a Queue of potential paths, and a Deque of possible solutions. If a node has already been visited, it is marked as visited, otherwise it is added to the potential paths, and its adjacent nodes are checked. Then, the best path is calculated, based on weight.\n\nI'm having problems with returning a String of the shortest path. I'm trying to produce a string of the vertices in the shortest path, from origin to destination. However, when I test and run getShortestPath, I get memory locations rather than String values.\n\nHere's the code for the shortest path:\n\n```\n// get shortest path from a starting vertex to ending vertex\n\n  public String getShortestPath(String origin, String destination)\n  {\n    origin = origin.toUpperCase();\n    destination = destination.toUpperCase();\n\n    for (int i = 0; i < vertices.size(); i++)\n    {\n      return findShortestPath(origin, destination).toString();\n    }\n    return \"\";\n  }\n\n  public List<Edge> adjacentEdges(String origin)\n  {\n    List<Edge> result = new LinkedList<Edge>();\n\n    for (Edge e : edges)\n    {\n      if (e.origin.name.compareTo(origin) == 0)\n        result.add(new Edge(e.origin, e.destination, e.weight));\n    }\n    return result;\n  }\n\n  public Path findShortestPath(String origin, String destination)\n  {\n    if (origin.compareTo(destination) == 0)\n    {\n      return null;\n    }\n\n    Queue<Path> potentialPaths = new LinkedList<Path>();\n\n    for (Edge e : adjacentEdges(origin))\n    {\n      Path current = new Path();\n      current.edges.add(new Edge(e.origin, e.destination, e.weight));\n      potentialPaths.add(current);\n      System.out.println(potentialPaths);\n    }\n\n    Deque<Path> solutions = new LinkedList<Path>();\n\n    while (!potentialPaths.isEmpty())\n    {\n      Path current = potentialPaths.remove(); // dequeue\n      String[] nodes = current.toString().split(\"-\");\n      Edge last = current.edges.getLast();\n\n      if (last.destination.name.compareTo(destination) == 0) // found valid path\n      {\n        solutions.add(current);\n        continue;\n      }\n      // if not at the destination\n      List<Edge> adjacencies = adjacentEdges(last.destination.name);\n\n      for (Edge adj : adjacencies)\n      {\n        boolean visited = false;\n\n        for (Edge pe : current.edges)\n        {\n          if (adj.destination.name.compareTo(pe.origin.name) == 0) // already been to this node in the path\n          {\n            visited = true;\n          }\n        }\n\n        // if not already visited, add edge to path and enqueue it to potential paths\n        if (!visited)\n        {\n          Path candidate = new Path();\n\n          for (Edge pe : current.edges)\n          {\n            candidate.edges.add(new Edge(pe.origin, pe.destination, pe.weight));\n          }\n\n          candidate.edges.add(new Edge(adj.origin, adj.destination, adj.weight));\n\n          potentialPaths.add(candidate);\n        }\n      }\n    }\n    // done going through all potential paths\n    // loop through solutions for best weight\n\n    if (solutions.isEmpty())\n      return null;\n\n    Path best = solutions.remove();\n    double weight = calcWeight(best);\n\n    while (!(solutions.isEmpty()))\n    {\n      Path current = solutions.remove();\n      double currentWeight = calcWeight(current);\n\n      if (currentWeight < weight)\n      {\n        best = current;\n        weight = currentWeight;\n      }\n    }\n\n    return best;\n  }\n\n  public double calcWeight(Path path)\n  {\n    double weight = 0.0;\n\n    for (Edge e : path.edges)\n    {\n      weight += e.weight;\n    }\n\n    return weight;\n  }\n\n  public class Path\n  {\n    public Deque<Edge> edges;\n\n    public Path()\n    {\n      edges = new LinkedList<Edge>();\n    }\n  }\n```\n\n\nAnd the rest of my Network class code, if needed:\n\n```\npublic class Network\n{\n  // instance variables\n\n  public List<Vertex> vertices;\n  public List<Edge> edges;\n\n  // constructor\n\n  public Network()\n  {\n    vertices = new LinkedList<Vertex>();\n    edges = new LinkedList<Edge>();\n  }\n\n  // adjacency matrix\n\n  public class AdjacencyMatrix\n  {\n    String vertexNames[];\n    double matrix[][];\n\n    public AdjacencyMatrix()\n    {\n      final int size = vertices.size();\n      vertexNames = new String[size];\n      matrix = new double[size][size];\n\n      int i = 0;\n      for (Vertex v : vertices)\n      {\n        vertexNames[i++] = v.name;\n      }\n\n\n    for (Edge e : edges)\n    {\n      int row = getIndex(e.origin.name);\n      int column = getIndex(e.destination.name);\n      matrix[row][column] = e.weight;\n    }\n  }\n\n   private int getIndex(String name)\n    {\n     for (int i = 0; i < vertexNames.length; i++)\n      {\n       if (vertexNames[i].compareTo(name) == 0)\n         return i;\n       }\n     return -1;\n     }\n  }\n\n  // getAdjacencyMatrix\n\n  public AdjacencyMatrix getAdjacencyMatrix()\n  {\n    return new AdjacencyMatrix();\n  }\n\n // add vertices \n\n  public boolean addVertex(String name)\n  {\n    for (Vertex v : vertices)\n    {\n      if (v.name.compareTo(name) == 0)\n      {\n        return false;\n      }\n    }\n\n      Vertex v = new Vertex(name);\n      v.name = name.toUpperCase();\n      vertices.add(v);\n      return true;\n  }\n\n  // add edges\n\n  public boolean addEdge(String origin, String destination, double weight)\n  {\n    origin = origin.toUpperCase();\n    destination = destination.toUpperCase();\n\n    Vertex originVertex = null;\n\n    for (Vertex v : vertices)\n    {\n      if (v.name.compareTo(origin) == 0)\n      {\n        originVertex = v;\n        break;\n      }\n    }\n\n    if (originVertex == null)\n    {\n      return false;\n    }\n\n    Vertex destinationVertex = null;\n\n    for (Vertex v : vertices)\n    {\n      if (v.name.compareTo(destination) == 0)\n      {\n        destinationVertex = v;\n        break;\n      }\n    }\n\n    if (destinationVertex == null)\n    {\n      return false;\n    }\n\n    for (Edge e : edges)\n    {\n      if (e.origin == originVertex && e.destination == destinationVertex)\n      {\n        return false;\n      }\n    }\n\n    Edge e = new Edge(originVertex, destinationVertex, weight);\n    e.origin = originVertex;\n    e.destination = destinationVertex;\n    e.weight = weight;\n    edges.add(e);\n\n    return true;\n  }\n\n  // support classes\n\n  public class Vertex<T extends Comparable>\n  {\n    public String name;\n\n    public List<Edge> edges;\n\n    public Vertex(String name)\n    {\n      this.name = name;\n    }\n  }\n\n  public class Edge\n  {\n    public Vertex origin, destination;\n    public double weight;\n\n    public Vertex getSource()\n    {\n      return origin;\n    }\n\n    public Vertex getDestination()\n    {\n      return destination;\n    }\n\n    public int getWeight()\n    {\n      return (int)weight;\n    }\n\n    public Edge(Vertex origin, Vertex destination, double weight)\n    {\n      this.origin = origin;\n      this.destination = destination;\n      this.weight = weight;\n    }\n\n    public Edge(String origin, String destination, double weight)\n    {\n      this.origin = new Vertex(origin);\n      this.destination = new Vertex(destination);\n      this.weight = weight;\n    }\n  }\n\n  public List<Vertex> getVertices()\n  {\n    return vertices;\n  }\n\n  public List<Edge> getEdges()\n  {\n    return edges;\n  }\n```\n\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How to find the number of different shortest paths between two vertices, in directed graph and with linear-time?\r\n                \r\nHere is the exercise:\n\n\n  Let v and w be two vertices in a directed graph G = (V, E). Design a linear-time algorithm to find the number of different shortest paths (not necessarily vertex disjoint) between v and w. Note: the edges in G are unweighted\n\n\n\n\nFor this excise, I summarise as follows:\n\n\nIt is a directed graph\nIt asks for the number of different shortest paths. First, the paths should be shortest, then there might be more than one such shortest paths whose length are the same.\nbetween v and w, so both from v to w and from w to v should be counted.\nlinear-time. \nThe graph is not weighted.\n\n\n\n\nFrom the points above, I have the following thoughts:\n\n\nI don't need to use Dijkstra’s Algorithm because the graph is not weighted and we are try to find all shortest paths, not just single one.\nI maintain a ```\ncount```\n for the number of shortest paths\nI would like to use BFS from v first and also maintain a ```\nglobal level```\n information\nI increase the ```\nglobal level```\n by one each time then BFS reaches a new level\nI also maintain the ```\nshortest level```\n info for shortest path to w\nThe first time I meet w while traveling, I assign the ```\nglobal level```\n to the ```\nshortest level```\n and ```\ncount++```\n; \nas long as the ```\nglobal level```\n equals to the ```\nshortest level```\n, I increase ```\ncount```\n each time I met w again.\nif the ```\nglobal level```\n becomes bigger than the ```\nshortest level```\n, I terminate the travelling, because I am looking for shortest path not path.\nThen I do 2 - 8 again for w to v\n\n\n\n\nIs my algorithm correct? If I do v to w and then w to v, is that still considered as linear-time?\n    ", "Answer": "\r\nHere are some ideas on this.\n\n\nThere can only be multiple shortest paths from v->w through node x, either if there are multiple paths into x through the same vertice or if x is encountered multiple time at the same DFS level.\n\n\nProof: If there are multiple paths entering ```\nx```\n through the same vertex there are obviously multiple ways through ```\nx```\n. This is simple. Now let us assume there is only one way into ```\nx```\n through each vertex going into ```\nx```\n (at maximum). \n\nIf x has been encountered before, none of the current paths can contribute to another shortest path. Since x has been encountered before, all paths that can follow will be at least one longer than the previous shortest path. Hence none of these paths can contribute to the sum. \n\nThis means however we encounter each node at most once and are done. So a normal BFS is just fine.\n\n\nWe do not even need to know the level, instead we can get the final number once we encounter the final node.\n\n\nThis can be compiled into a very simple algorithm, which is mainly just BFS.\n\n```\n - Mark nodes as visited as usual with BFS.\n - Instead of adding just nodes to the queue in the DFS add nodes plus number of incoming paths.\n - If a node that has been visited should be added ignore it.\n - If you find a node again, which is currently in the queue, do not add it again, instead add the counts together.\n - Propagate the counts on the queue when adding new nodes.\n - when you encounter the final, the number that is stored with it, is the number of possible paths.\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Python: distribution of shortest paths is irregular with regular grid\r\n                \r\nIn a regular ```\nNxN```\n network, I want to color code the nodes based on the number of shortest paths passing through them. This is known in literature as the Stress Centrality (SC).\n\nTo do this, I use the ```\nnx.all_shortest_paths()```\n function, which computes all the shortest paths between any two nodes in the graph.\n\nThe network in question is highly regular, so I firmly believe the distribution of shortest paths should follow the same pattern regardless of the size of the network.\n\nBut here is the deal: if the size is ```\n9x9```\n, it is clear the central nodes are the most \"stressed\", as seen below (nodes in white); if the size is ```\n10x10```\n, this cloud of stressed nodes moves elsewhere. I don't know if this is a Python/computational effect or if it is normal. I haven't tested networks bigger than ```\n10x10```\n as it takes ages to do the calculations (time complexity seems to be exponential for this computation).\n\nHow can this happen? I expect the most stressed nodes to always stay in the center. Why is this not true when I increase the network size? After all, the topology remains unaltered (thus, symmetrical).\n\n\n\nImages:\n\n\nCode:\n\n```\nfrom __future__ import print_function, division\nimport numpy\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport matplotlib.colors as mcolors\n\n#Creating the network\nN=9\nG=nx.grid_2d_graph(N,N)\npos = dict( (n, n) for n in G.nodes() )\nlabels = dict( ((i,j), i + (N-1-j) * N ) for i, j in G.nodes() )\nnx.relabel_nodes(G,labels,False)\ninds=labels.keys()\nvals=labels.values()\ninds.sort()\nvals.sort()\npos2=dict(zip(vals,inds))\nnx.draw_networkx(G, pos=pos2, with_labels=True, node_size = 15)\n\n#Function counting all shortest paths between any two nodes\ncounts={}\nfor n in G.nodes(): counts[n]=0\nfor n in G.nodes():\n    for j in G.nodes():\n        if (n!=j):\n            gener=nx.all_shortest_paths(G,source=n,target=j)\n            for p in gener: \n                for v in p: counts[v]+=1\n\n#Plotting the color coded nodes\nfig, ax = plt.subplots()\nunaltered_shortest_paths = counts.values() #List\nnodes = G.nodes()\nn_color = numpy.asarray([unaltered_shortest_paths[n] for n in range(len(nodes))])\nsc = nx.draw_networkx_nodes(G, pos=pos2, node_color=n_color, cmap='gist_heat',\n                            with_labels=False, ax=ax, node_size=45)\nmin_val=int(min(unaltered_shortest_paths))\nmax_val=int(max(unaltered_shortest_paths))\nsc.set_norm(mcolors.Normalize(vmin=0,vmax=max_val))\ncbar=fig.colorbar(sc)\ncbar.set_label('Number of Shortest Paths')\nplt.xlim(-2,N+1,5)\nplt.xticks(numpy.arange(0, N, 1))\nplt.ylim(N+1,-2,5) \nplt.yticks(numpy.arange(0, N, 1))\nplt.axis('on')\ntitle_string=('Stress Centrality (SC)') \nsubtitle_string=('Network size: '+str(N)+'x'+str(N))\nplt.suptitle(title_string, y=0.99, fontsize=17)\nplt.title(subtitle_string, fontsize=9)\nplt.xlabel('X')\nplt.ylabel('Y')\nplt.show()\n```\n\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest Path Challenge\r\n                \r\nGiven a graph with a start vertex S and end vertex E, how to find k shortest paths from S to E conditioned that all vertices must be visited exactly once?\n\nThe graph can have cycles. \nCan someone please elaborate how to use Dijkstra or Viterbi algorithm to solve this? Start = S, End = End, A,B and C should be visit exactly once\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Storing the shortest path\r\n                \r\nI am referring this tutorial: http://www.geeksforgeeks.org/dynamic-programming-set-16-floyd-warshall-algorithm/\n\nThe author mentions this:\n\n\n  We can modify the solution to print the shortest paths also by storing the predecessor information in a separate 2D matrix.\n\n\nAm a bit confused at what this predecessor information is.\n\nSo, how do I store the path for displaying later?\n    ", "Answer": "\r\nIf you want to reconstruct the path from node x_1 to x_n, you can do so by going to node x_2 and reconstructing the path from x_2 to x_n. The path from x_2 to x_n does not change if x_1 change. So what you want to store is information about what node is next when going from x_1 to x_n. This can be done with a |V| x |V| matrix, where entry [i][j] gives the index of the next node on the path from i to j.\n\nIn this part of the code\n\n```\nif (dist[i][k] + dist[k][j] < dist[i][j])\n    dist[i][j] = dist[i][k] + dist[k][j];\n```\n\n\nyou should add an assignment to a next node matrix.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Updating shortest path tree\r\n                \r\nAssume we are given a weighted, connected, directed graph G, a vertex s and the shortest path tree for s. So we already know all the shortest distances from s to every other vertex in the graph.\nNow the following happens, we add an edge to the graph.\nIs there an efficient way to get the new shortest path tree?\nHow can I calculate the new shortest path tree by encountering the old one?\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Modify Dijkstra algorithm to find the shortest path\r\n                \r\nHere is Dijkstra pseudocode:\n\n```\nDijkstra(G,s) {\nforeach vεV do { d[v] = infinity }\nQueue priority initialization Q with n elements\nQ = V\nd[s] = 0\nwhile(Q is not empty) {\n    v = ExtractMin(Q)\n    foreach e = (v,w) ε E do\n        if d(w) > d(v) + l {\n            d(w) = d(v) + l //reduce priority\n            ChangeKey(Q,w,d[w]) //reduce key\n        }\n    }\n}\n```\n\n\nHow can i modify this algorithm to find the shortest path that also has the smallest number of edges among all shortest paths.\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Export all shortest paths to CSV with R\r\n                \r\nI currently have the code below to export all shortest paths to CSV. It works fine, but it's quite slow with a large network. Is there a more efficient way to do the export?\n\n```\nlibrary(igraph)\n\ng.links.data<-structure(list(OriginID = structure(c(2L, 3L, 1L, 3L, 1L, 2L), .Label = c(\"IAD\", \n\"JFK\", \"MIA\"), class = \"factor\"), DestinationID = structure(c(1L, \n1L, 2L, 2L, 3L, 3L), .Label = c(\"IAD\", \"JFK\", \"MIA\"), class = \"factor\"), \n    Weight = c(1.504321, 2.454545, 1.454348, 3.022917, 2.666667, \n    3.32619)), .Names = c(\"OriginID\", \"DestinationID\", \"Weight\"\n), class = \"data.frame\", row.names = c(NA, -6L))\n\ng.nodes.data<-structure(list(Airport_Index = 1:3, Airport_ID = structure(1:3, .Label = c(\"IAD\", \n\"JFK\", \"MIA\"), class = \"factor\")), .Names = c(\"Airport_Index\", \n\"Airport_ID\"), class = \"data.frame\", row.names = c(NA, -3L))\n\ng.graph<-graph.edgelist(as.matrix(g.links.data[,1:2]))\nE(g.graph)$weight=as.numeric(g.links.data[,3])\ng.graph.adjmatrix<-get.adjacency(g.graph,sparse=F)\n\nfile.remove(\"shortest_paths.csv\")\nfor (v in 1:length(V(g.graph))) {\n    g.shortest_paths<-get.all.shortest.paths(g.graph, v, to = V(g.graph))\n    nb_of_sp <- length(g.shortest_paths[1][[1]]);\n    for (i in 1:nb_of_sp) {\n        SP <- as.matrix(t(g.shortest_paths[1][[1]][[i]]))\n        write.table(SP, file = \"shortest_paths.csv\", append = TRUE, sep = \",\", col.names = FALSE, row.names = FALSE)\n    }\n}\n```\n\n\nThis gives me the following output:\n\n```\n1\n1,2\n1,3\n2,1\n2\n2,3\n3,1\n3,2\n3\n```\n\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path in a matrix\r\n                \r\nI am a bit confused, i have following pattern\n\n```\nS...*...\n....*.....\n**...**.\n.G1....*.\n........\n...G2**..\n........\n....*.G3D\n```\n\n\nmeaning of legends are as follows\n\n```\nS = source \nD = Destination \nG = point to be visited before reaching destination\n. = paths \n* = blocked path\n```\n\n\nWill this approach give me the shortest path?\n\n```\nDistance = Min((S,G1) (S,G2) (S,G3))  \nDistance = Distance + Min((G1,G2) (G1,G3))  // Assuming that G1 is shortest  \nDistance = Distance + Distance(G3 , D)\n```\n\n\nG points can be randomly distributed  and i am using BFS\n\nG<15 and matrix <= 100x100\n    ", "Answer": "\r\nNo. That won't work. That is what's called a greedy approach, and it will not work because it may force you to do a bad last move.\n\nConsider for instance this case:\n\n```\n            S                    \n\n G3         G1     G2               \n\n            D\n```\n\n\n\n```\nG1```\n is closest to ```\nS```\n, so that will be chosen first.\n```\nG2```\n is then closest to ```\nG1```\n, so that will be chosen second\nLeft is ```\nG3```\n\n\n\ni.e. your approach will chose ```\nG1```\n, ```\nG2```\n, ```\nG3```\n while the optimal solution is to visit ```\nG3```\n, ```\nG1```\n then ```\nG2```\n in a straight line.\n\nIn fact, it's trivial to reduce the traveling salesman problem to this problem. Just set ```\nS```\n and ```\nD```\n next to each other. This proves that the problem you're describing is NP-hard, i.e. you can't do better than an exhaustive search.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Continuous space shortest path\r\n                \r\nI need a shortest path algorithm for controlling a real life robot.\n\nLets say i have map of the environment in the form of a matrix where 1 is an obstacle and 0 is free space. If i use a conventional shortest path algorithm, such as A* then that would give me a Manhattan distance shortest path. So nowhere near a the actual shortest path. This problem arises since i cannot think of a way to penalize movement in such a way that a diagonal line is better than two straight lines. I can make a heuristic that will make A* try euclidean shortest path between two points first, but not actually make euclidean shortest path a better path. \n\nDoes anyone know of a method to get the continuous space shortest path? It does not have to be the actual optimal path, but a better one than straight lines and 90 degree angles.\n\nI have one idea:\nFrom the start point make a circle. \nIncrease the radius of the circle until the one point on the circle is next to a wall, or at the goal. All the points on the edge of the circle are set as children nodes with the penalty of the radius of the circle. All points inside the circle, that are not open, will be closed since there is no reason to test them. Repeat this in an A* way with euclidean shortest path as heuristic, until the goal state is reached.Make the robot go from one point to the next in a straight line.\n\nThis should give something closer to what i am looking for. A set of straight lines with various angles. It would of course be better with a continuous curvy line...\n    ", "Answer": "\r\nI have implemented a continuous space path planning algorithm and blogged about it here. It uses A* to get an initial estimate and finalizes it (and pennalizes for sharp turns and robot's orientation at the destination) by using the simple gradient descent algorithm.\n\n\n\nLet's say the discrete path from A* has ```\nn```\n \"waypoints\" (coordinates on the grid). First and last ones cannot be moved but others can, as long as the path doesn't go through blocked grid cells. The function to be minimized is parametrized by ```\nn - 2```\n parameters which move waypoints perpendicular to its current direction.\n\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Number of intermediate nodes in shortest path\r\n                \r\nI am calculating all the shortest paths in a weighted graph with the ```\ncsgraph```\n module from ```\nscipy.sparse```\n\n\nI have a matrix (```\nInputMatrix```\n) of N*N and I am using the following function:\n\n```\nDijstraMatrix, DijkstraPredecessors=sp.sparse.csgraph.shortest_path(InputMatrix, method=\"D\", return_predecessors=True)\n```\n\n\nI think that because of efficiency reasons, the explicit paths are not returned by a list of predecessors for each node. And then the shortest path  between any two nodes i and j can be reconstructed from the ```\nDijkstraPredecessors```\n list.\n\nMy problem is that I need the shortest path that maximizes the number of visited nodes. If I implement a reconstruction for a big matrix, it takes forever to calculate all the reconstructed paths. \n\nThe function is somehow calculating that information internally.. is there any way of getting a matrix of N*N with the information of how many nodes are visited in the shortest path between i and j? Is it an efficient way to calculate it?\n\nThis is the one I coded:\n\n```\n    def SinglePath(DijkstraPredecesors, i, j):\n        length=0\n        k=j\n        while (i != k) & (k >= 0):\n            length+=1\n            k = DijkstraPredecesors[i,k]\n        return (length)\n\n    def calculate_bi_longerpath(Distancias, DijkstraPredecesors):\n        node1=-1\n        node2=-1\n        n_nodes=0\n        distance=-1\n\n        for i in range(0, Distancias.shape[0]):\n            print(i)\n            for j in range(0, Distancias.shape[1]):\n                if(i<j):\n                    path=SinglePath(DijkstraPredecesors, i, j)\n                    if(path>n_nodes):\n                        node1=i\n                        node2=j\n                        distance=Distancias[i][j]\n                        n_nodes=path\n        return(node1, node2, distance, n_nodes)\n\n\n    print(\"Longest larger path...\")\n    node1, node2, n_nodes, distance=calculate_bi_longerpath(DijkstraMatrix, DijkstraPredecesors)\n    print(node1, node2, n_nodes, distance)\n```\n\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path algoritmh\r\n                \r\nI'm trying to calculate the shortest path between two vertices on a unweighted graph. My graph is obtaneid from a csv file and I put all the information in a dictionary structure:\nEDIT:\nclass Graph:\n```\ndef __init__(self, directed=False):\n    self._directed = directed\n    self._number = 0            \n    self._vertices = {}    \n\ndef insert_vertex(self, x):\n    v = Vertex(x)\n    self._vertices[v] = {}      \n    self._number = len(self._vertices)\n    return v\n\ndef insert_edge(self, u, v, x=None):\n    e = Edge(u, v, x)\n    self._vertices[u][v] = e  \n    self._vertices[v][u] = e  \n\ndef incident_edges(self, v, outgoing=True):\n    for edge in self._vertices[v].values(): \n        if not self._directed:\n                yield edge\n        else:  \n            x, y = edge.endpoints()\n            if (outgoing and x == v) or (not outgoing and y == v):\n                yield edge\n\ndef is_directed(self):\n    return self._directed  \n\ndef vertex_count(self):\n    return self._number\n\ndef vertices(self):\n    return self._vertices.keys()\n\ndef edge_count(self):\n    total = sum(len(self._vertices[v]) for v in self._vertices)\n    return total if self._directed else total // 2\n\n\ndef edges(self):\n    result = set()     \n    for secondary_map in self._vertices.values():\n        result.update(secondary_map.values())  \n    return result\n\n\ndef get_edge(self, u, v):\n    edge = self._vertices[u].get(v) \n    if edge != None and self._directed: \n        _, x = edge.endpoints           \n        if x != v:\n            edge = None\n    return edge\n\n\ndef degree(self, v, outgoing=True):\n    adj = self._vertices\n    if not self._directed:\n        count = len(adj[v])\n    else:\n        count = 0\n        for edge in adj[v].values():\n            x, y = edge.endpoints()\n            if (outgoing and x == v) or (not outgoing and y == v):\n                count += 1\n    return count\n\n\ndef remove_edge(self, u, v):\n    if  u in self._vertices.keys() and v in self._vertices[u].keys():\n        del self._vertices[u][v]\n        del self._vertices[v][u]\n\ndef remove_vertex(self, v):\n    if v in self._vertices.keys():\n        lst = [i for i in self.incident_edges(v)]\n        for i in lst:\n            x, y = i.endpoints()\n            self.remove_edge(x,y)\n        del self._vertices[v]\n    #return v\n\ndef github_csv():\n    lista = []\n    with open('Github1.csv', 'r') as csv_file:\n        data = csv.DictReader(csv_file)\n        next(data)\n        for row in data:\n            lista.append(row)\n        rel_dict = {}\n        for d in lista:\n            if d[\"follower\"] in rel_dict.keys():\n                rel_dict[d['follower']].append(d['followed'])\n            else:\n                rel_dict[d['follower']] = [d['followed']]\n        return rel_dict\n```\n\nThe output of git_hub() is:\n```\n{'9236': ['1570', '13256', '45703', '10005', '30355', '1564', '11917'], '13256': ['9236', '1570', '1563', '22390', '4140', '28106', '11914', '10005', '1567', '1565', '28464', '14922', '41223', '1564', '14613', '1569', '1934', '32872', '11917', '109144', '144589']}\n\ndef build_graph():\n    graph = Graph(True)\n    git = github_csv()\n    for k,v in git.items():\n        k_vertex = graph.insert_vertex(k)\n        for v_item in v:\n            v_item_vertex = graph.insert_vertex(v_item)\n            graph.insert_edge(k_vertex,v_item_vertex)\n    graph.printG()\n    return graph\n```\n\nThe output is something like:\n```\nvertex  59216  grau_in:  1 grau_out:  1\n  (4140, 59216) \nvertex  59570  grau_in:  1 grau_out:  1\n  (4140, 59570) \n```\n\nI'm using the following to calculate the shortest path between two vertexs:\n```\ndef shortest_path(graph, start, goal):\n    explored = []\n\n    queue = [[start]]\n\n    if start == goal:\n        print(\"Same Node\")\n        return\n\n    while queue:\n        path = queue.pop(0)\n        node = path[-1]\n\n        if node not in explored:\n            neighbours = graph[node]\n\n            for neighbour in neighbours:\n                new_path = list(path)\n                new_path.append(neighbour)\n                queue.append(new_path)\n\n                if neighbour == goal:\n                    print(\"Shortest path = \", *new_path)\n                    return\n            explored.append(node)\n\n    print(\"So sorry, but a connecting\" \\\n          \"path doesn't exist :(\")\n    return\n```\n\nThe outuput is:\n```\n Traceback (most recent call last):\n  File \"<input>\", line 1, in <module>\n  File \"C:\\Program Files\\JetBrains\\PyCharm Community Edition 2020.2.3\\plugins\\python-ce\\helpers\\pydev\\_pydev_bundle\\pydev_umd.py\", line 197, in runfile\n    pydev_imports.execfile(filename, global_vars, local_vars)  # execute the script\n  File \"C:\\Program Files\\JetBrains\\PyCharm Community Edition 2020.2.3\\plugins\\python-ce\\helpers\\pydev\\_pydev_imps\\_pydev_execfile.py\", line 18, in execfile\n    exec(compile(contents+\"\\n\", file, 'exec'), glob, loc)\n  File \"C:/Users/sandr/PycharmProjects/ProjetoEDA/main.py\", line 334, in <module>\n    shortest_path(graph,'1563','133')\n  File \"C:/Users/sandr/PycharmProjects/ProjetoEDA/main.py\", line 271, in shortest_path\n    neighbours = graph[node]\nTypeError: 'Graph' object is not subscriptable\n```\n\nCan somenone help me understand what I'm doing wrong?\n    ", "Answer": "\r\nFrom the general flow of your code, I gather that you expect ```\ngraph[node]```\n to magically return a sequence of neighboring nodes.  Again, you need to learn the interface you've implemented (or chosen).  There is no such facility in ```\nGraph```\n.  Instead, you need to iterate through the ```\nincident_edges```\n, working with the destination node of each such edge.\n```\nfor neighbour_edge in graph.incident_edges(node):\n    # access the edge endpoint that is *not* \"node\"\n    neighbour = neighbour_edge.???    # Again, your posting is incomplete.  You'll have to do this part.\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path linear programming\r\n                \r\ni am stuck at the point maximize d_t at page 4 https://courses.engr.illinois.edu/cs498dl1/sp2015/notes/26-lp.pdf.\nI absolutely cannot follow the author argument \n\n\n  These relaxation constraints imply that in any feasible solution, d_v\n  is atmost the shortest path distance from s to v .Thus, somewhat\n  counterintuitively,we are correctly maximizing the objective function\n  to compute the shortest path!\n\n\nWe are looking for the shortest path but why do we  loogking for max d_t?\n    ", "Answer": "\r\nImagine the trivial case of the shortest path between two directly connected vertices ```\ns```\n and ```\nt```\n without any other edges or vertices. Here the LP boils down to this:\n\n```\nmaximize   d_t\nsubject to d_s = 0\n           d_t − d_s ≤ l_st for every edge s -> t\n```\n\n\nThe only way to maximize ```\nd_t```\n is to set it to the shortest path from ```\ns```\n to ```\nt```\n - in this case the edge between the two. This is because the second constraint ```\nd_t ≤ l_st```\n prohibits any larger value, i.e. any longer path from ```\ns```\n to ```\nt```\n.\n\nNow, this idea can be transferred to the general case where ```\ns```\n and ```\nt```\n are not neighbouring vertices: Think of the ```\nd```\n variables as shortest paths to all the neighbouring vertices of ```\nt```\n. Then the contraints concerned with ```\nd_t```\n determine which of these edges must be chosen to define the overall shortest path. It will be satisfied with equality while any higher value for ```\nd_t```\n will violate at least one of these contraints.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "The shortest path\r\n                \r\nThis is my code to generate a 2-dimensional table with pseudo numbers.\nwhen it creates a so-called square of numbers for me, e.g.\n```\n2 1 1 1\n1 9 1 2\n9 8 3 1\n```\n\nthen I have to choose the shortest path from left to right and I can go down and up and diagonally and the exit is to be that the path leads through 1 1 1 1 and that the sum of half is equal to 4\nAnd I dont know how to start writing code for the shortest path can somebody help me or give me advise how i can do it. i searched for matrix in c++ but i dont know how it need works.\n```\nfor (int i = 0; i < a; i++)\n{\n    for (int j = 0; j < b; j++)\n    {\n        tab[i][j] = rand() % 9 + 1; \n        cout << tab[i][j] << \" \"; \n    }\n    cout << endl;\n}\n\nreturn 0;\n```\n\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How to subset a list of shortest paths by a sequence of vertices?\r\n                \r\nUsing this for loop, I have stored all the shortest paths between every node in the network \"```\noriginal.graph```\n\".\n\n```\nPOI <- list()\nfor(i in seq_along(V(original.graph))){\n    this.name <- V(original.graph)[[i]]\n    sp <- shortest_paths(original.graph, from = this.name[1], to = V(original.graph), mode = \"out\")\n    POI[[this.name$name]] <- sp$vpath\n  }\n```\n\n\nHere is an example of the data:\n\n```\n> POI[[1]][1:5]\n[[1]]\n+ 1/44 vertex, named:\n[1] V1\n\n[[2]]\n+ 2/44 vertices, named:\n[1] V1 V2\n\n[[3]]\n+ 2/44 vertices, named:\n[1] V1 V3\n\n[[4]]\n+ 2/44 vertices, named:\n[1] V1  V3A\n\n[[5]]\n+ 2/44 vertices, named:\n[1] V1 V4\n```\n\n\nSo let's say that we want to subset all of the shortest paths that have \"V1\" \"V4\" in them, it would only select ```\nPOI[[1]][5]```\n in this case. \n\nI am trying to subset all of the shortest paths that contain a given sequence. I have been trying to convert ```\nPOI[[i]]```\n to another object type, and it seems that using ```\nas.data.frame.vector```\n has been successful. If someone could give me suggestions on how to approach this problem, or point me where to go from here I would be grateful.  \n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest paths problem with two conditions\r\n                \r\nLet's say i have a directed graph G(V,E,w,c) where w is the positive weight of each edge and c is the cost of every edge being either 1 or 0.I need to find an algorithm that for given source vertice u finds the shortest paths from u to every vertice in V that have cost ≤ k(where k≥1).\n\nI tried modifying Bellman ford's algorithm but i can't seem to find the solution.\n    ", "Answer": "\r\nLet me restate my understanding of the problem.\n\nFor all vertices that you can reach with a cost of no more than ```\nk```\n, you want the path of minimal weight that gets there from a vertex ```\nu```\n.\n\nYou need a combination of ideas to get there.\n\nSuppose that a ```\nRouteToNode```\n object has the following attributes:  ```\ncost```\n, ```\nweight```\n, ```\nnode```\n, ```\nlastRouteToNode```\n and an autoincrementing ```\nid```\n.  This is a linked list carrying us back to the original node, letting us reconstruct the route.  We compare them by ```\ncost```\n, then ```\nweight```\n, then ```\nid```\n.\n\nWe have a hash/dictionary/whatever you want to call it that maps nodes to the lowest weight ```\nRouteToNode```\n object reaching that node.  Call it ```\nbestRoute```\n.\n\nWe have a ```\ntodo```\n list that has ```\nRouteToNode```\ns that we have not yet processed which is a priority queue that always returns the minimal ```\nRouteToNode```\n.  Note that it always returns them from lowest cost to highest.\n\nWe start with ```\nbestRoute```\n having nothing in it, and a ```\ntodo```\n queue with only a single ```\nRouteToNode```\n, namely:\n\n```\n{\n    id: 0,\n    cost: 0,\n    weight: 0,\n    node: u,\n    lastRouteToNode: null\n}\n```\n\n\nAnd now we execute the following pseudocode:\n\n```\nwhile todo is not empty:\n    thisRouteToNode = todo.pop()\n    if thisRouteToNode.node not in bestRoute or\n      thisRouteToNode.weight < bestRoute[thisRouteToNode.node].weight:\n        bestRoute[thisRouteToNode.node] = thisRouteToNode\n        for edge adjacent to thisRouteToNode.node:\n            construct nextRouteToNode by adding edge\n            if nextRouteToNode.cost <= k:\n                todo.push(nextRouteToNode)\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Edge attributes of multiple shortest paths (in dictionary) using networkx\r\n                \r\nI have an additional question to the problem, which is solved here: Edge attributes of shortest path using networkx\nI want to have the attributes of all shortest paths in a transport network. So in the case described above,  @swatchai answered how to get attributes of one path. But in my network, I have from Amsterdam to the rest of the world 300 shortest paths. The script looks like this:\n```\nsp2 = nx.shortest_path(g, source='NLAMS', weight='weight')\nfor key, value in sp2.items():\n    print(key, ' : ', value)\n```\n\nIt works till here!\nIn the answer of @swatchai he suggested the following script as answer, but I think it doesn't work for me because it is a dictionary instead of a list.\n```\npathGraph2 = nx.path_graph(sp2)  # does not pass edges attributes\n\nfor edgeatr in pathGraph2.edges(): #print from_node, to_node, edge's attributes\n    print(edgeatr, g.edges[edgeatr[0], edgeatr[1]])\n```\n\nThank you in advance!\n    ", "Answer": "\r\nI believe that you may be confused between what you obtain when you do:\n```\n>>> nx.shortest_path(g, source=1, target=2, weight='weight')\n[1, 7, 2]\n```\n\nversus\n```\n>>> nx.shortest_path(g, source=1, weight='weight')\n{1: [1], 0: [1, 0], 5: [1, 5], 7: [1, 7], 4: [1, 0, 4], 2: [1, 0, 2], 6: [1, 5, 6], 3: [1, 0, 4, 3]}\n```\n\nAs you can see the second one gives you all targets from source plus all paths.\nTo create the ```\npath_graph```\n you can only use the ```\npath```\n.\nHere is an example:\n```\n# Create a random graph with 8 nodes, with degree=3\ng = nx.random_regular_graph(3, 8, seed=None)\n\n# Add 'cost' attributes to the edges\nfor (start, end) in g.edges:\n    g.edges[start, end]['cost'] = np.random.randint(1,10)\n\nSOURCE = 1\nsp_SOURCE = nx.shortest_path(g, source=SOURCE, weight='weight')\n\nfor target, path in sp_SOURCE.items(): \n    print(\"Shortest path from SOURCE to {} is {}\".format(target,path))\n    pathGraph = nx.path_graph(path)   # for each target we create a path_graph\n    for ea in pathGraph.edges():\n        #print from_node, to_node, edge's attributes\n        print(\"\\t\", ea, g.edges[ea[0], ea[1]])\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Calculating the shortest path on a grid\r\n                \r\nI'm trying to calculate on a 2D array 8X8 grid all paths and have the algorithm go over all squares on the grid and configure the shortest path.\n\nSee code below:\n\n```\npublic static int Mileage(int[,] arr, int x, int y, int miles)\n{    \n    if (x < 0 || y < 0 || x > 5 || y > 5 || arr[x, y] == 2) return 99; \n    if (arr[x, y] == 1) return miles;\n    arr[x, y] = 2;\n    miles++;\n    Console.WriteLine(miles);\n    int want2 = Math.Min(Mileage(arr, x - 1, y, miles), Mileage(arr, x + 1, y, miles));\n    int want1 = Math.Min(Mileage(arr, x, y - 1, miles), Mileage(arr, x, y + 1, miles));\n    return Math.Min(want1, want2);\n\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How to find shortest paths between specific set of nodes using networkx\r\n                \r\nI have an undirected graph ```\nG```\n with hundreds of nodes.\nA sample network of ```\nG```\n can be created as:\n```\nG = nx.Graph()\nG.add_nodes_from([0, 1, 2, 3, 4, 5])\nG.add_edges_from([(0, 1), (1, 2), (1, 3), (3, 4), (3, 5)])\n```\n\nI want to find the shortest paths between nodes that have degree of 1. These nodes in the above sample are ```\n0, 2, 4, 5```\n.\nI have the following function that returns nodes with degree = 1:\n```\ndef find_leaf_nodes(g):\n  leaf_nodes = ()\n  for d in list(g.degree()):\n    if d[1] == 1:\n      val = d[0]\n      leaf_nodes = leaf_nodes + (val,)\n  return leaf_nodes\n\nl_nodes = find_leaf_nodes(G)\nprint(l_nodes)\n```\n\nNow I want to get the shortest paths between nodes in ```\nl_nodes```\n only and not all nodes in ```\nG```\n. For example, from node ```\n0 to 2```\n, ```\n0 to 4```\n, ```\n2 to 5```\n, etc. However when I use:\n```\npaths = nx.shortest_path(G, source=l_nodes, target=l_nodes, weight='cost')\n```\n\nI get the same tuple returned by ```\nfind_leaf_nodes```\n function and not the shortest paths.\nI would expect something like:\n```\n{0: {0: [0],\n  1: [0, 3, 1],\n  2: [0, 3, 2],\n  3: [0, 3], ...}\n```\n\nInstead I get a tuple that look something like:\n```\n[(0, 2, 1, 3, ...)]\n```\n\nIs there a function other than ```\nshortest_path```\n that can take a set of same nodes as source and target to find the shortest paths among them?\nIf there is no such function, how can I find the shortest paths among certain nodes (specifically nodes with degree of 1)?\n    ", "Answer": "\r\nFirst, how to get what you're after.  I don't see an incredibly efficient algorithm. Looking at the methods in networkx that do something like this, there is ```\nall_pairs_shortest_path```\n, which turns out to just do:\n```\nfor n in G:\n        yield (n, single_source_shortest_path(G, n, cutoff=cutoff))\n```\n\nSo it just checks for each node what all shortest paths are from that node.  If you aren't going to be doing this a lot, I would adapt this code and replace ```\nfor n in G```\n with ```\nfor n in l_nodes```\n.  The problem is that this will find the shortest path from every leaf node to every other node in the graph.  Then I would discard all the ones that don't end in another leaf.\nIf you're going to do this more often, then I would get into the guts of ```\nsingle_source_shortest_path```\n (available here) and set up a test that will stop calculation once I find all the other leaf nodes.  Note that you'll still have to trace much of the graph first until you find all the leaf nodes, so I'm not sure this will substantially improve matters.\nIf there is a cost associated with the edges, then instead you should look at the dijkstra shortest path length methods.  The ```\nall_pairs...```\n equivalent is similarly simple, just calling the dijkstra algorithm for each node.  So you can do this just for the leaf nodes.  Again, you can probably speed it up a bit if you get it to stop once it's found all of the leaf nodes.\nI think there is probably the potential to build a significantly faster algorithm by modifying the the bi-directional dijkstra algorithm to somehow deal with a lot of nodes  However, this would be a significant bit of coding, and it would be subtle, and I'm not convinced it can work.  I would need to spend a lot of time to figure out if it's doable and a real improvement.  So for that you're on your own.\n\nSecond, you might be wondering, why is my current implementation just returning the tuple back to me?\nI think you've run into a strange bug in the shortest path algorithms.  I think it's interpreting your tuple as a node [tuples are allowed as nodes, but lists are not, and if I pass in the equivalent list, it breaks].  So it understands you want the shortest path from that node to itself, which is just itself.  Because you've assigned a weight (even if you haven't used it), it's using the dijkstra algorithms, and as I look into the details, it looks like the dijkstra algorithm checks if ```\nsource==target```\n before it does a check if ```\nsource```\n is in the graph.  So it's telling you that the shortest path from that tuple to itself is just the single node (the tuple), even though the tuple is not a node of the graph.\nI've submitted a bug report\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Apache Spark computing shortest path\r\n                \r\nI am trying to compute the shortest path in a large network from a given source to a given target based on weights unsing Apache Spark. Since all my other code is written in python I don't wanna change. It should be somehow possible, shoundn't it? Since I am quite new to Spark maybe I dont see how I can solve the problem.\n\nMaybe someone can help me out?\nThanks in advance!\n\nWhat I tried so far:\n\n\ncreating a vertex and edge list\nusing GraphFrame() to create a graph\nunsing the GraphFrames shortest path method to compute the shortest path\n\n\nSo far so good (not really). The problem with the GraphFrames shortest path method is that it computes the shortest path from every node to the given set of nodes, which works for small graphs but takes ages for huge networks. A lot of \"unnecessary\" computation is done because all nodes are considered. I just need to get the shortest path from one node to another one.\n\nI was searching the internet and found that the Spark graphx library has such a function I am looking for, but sadly its only available for Scala...\n\nMaybe I just can use the rdds to compute the shortest path based on weights? Or is there an shortest path implementation for pyspark I wasn't able to find? \nCan't believe that no shortest path algorithm is implemented for pyspark.\n\n```\n    vertices_rdd = vertices_rdd3.zipWithIndex()\n    # vertices_rdd.take(3): \n    # [((552897.813699282, 4164322.19502139), 0), ((583743.487097408, 4158379.86761575), 1), ((585964.589845657, 4158443.96863072), 2)]\n\n    edges_rdd = edges_rdd1.flatMap(lambda x: x)\n    # edges_rdd.take(3): \n    # [(62734, 107857, 102.19468251940246, '8'), (107857, 62734, 102.19468251940246, '8'), (79903, 191109, 21.81675476329727, '13')]\n\n    spark = SparkSession(sc)\n\n    vertices_df = vertices_rdd.toDF([\"coordinate\",\"id\"])\n    edges_df = edges_rdd.toDF([\"src\", \"dst\", \"distance\", \"streetclass\"])\n\n    vertices_df.show()\n    #+--------------------+---+\n    #|          coordinate| id|\n    #+--------------------+---+\n    #|[552897.813699282...|  0|\n    #|[583743.487097408...|  1|\n    #|[585964.589845657...|  2|\n    #|[588646.795215483...|  3|\n    #|[582405.137425844...|  4|\n    #|[582823.612980657...|  5|\n    #...\n\n    edges_df.show()\n    #+------+------+------------------+-----------+\n    #|   src|   dst|          distance|streetclass|\n    #+------+------+------------------+-----------+\n    #| 62734|107857|102.19468251940246|          8|\n    #|107857| 62734|102.19468251940246|          8|\n    #| 79903|191109| 21.81675476329727|         13|\n    #|191109| 79903| 21.81675476329727|         13|\n    #| 60790| 66205|19.362434806339824|         13|\n    #... \n\n    from graphframes import *\n    g = GraphFrame(vertices_df, edges_df)\n\n    results = g.shortestPaths(landmarks=[\"0\"])\n    results.select(\"id\", \"distances\").show()\n    #+---+-----------+\n    #| id|  distances|\n    #+---+-----------+\n    #|  0|Map(0 -> 0)|\n    #|  7|Map(0 -> 1)|\n    #|  6|      Map()|\n    #|  9|      Map()|\n    #|  5|      Map()|\n    #|  1|      Map()|\n    #|  3|      Map()|\n    #|  8|      Map()|\n    #...\n```\n\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "sna: modification of the Dijkstra algorithm (shortest paths)\r\n                \r\nI've been using the function ```\nshortest_paths```\n from the ```\nigraph```\n package in order to calculate the shortest path between two links.\n\nMy ```\nigraph```\n object contains the weighted links. \n\nThe integrated Dijkstra algorithm uses sums in order to express the shortest path. \n\nHow can I use the product instead of the sum?\n    ", "Answer": "\r\nLog is a monotonically increasing function so the path that minimizes the product of the edge weights will also minimize the log of the product of the edge weights, or equivalently the sum of the log of the edge weights.  Therefore, you can just replace the edge weights with their log transformation and use the shortest path function.  \n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "boost shortest path finding algorithm\r\n                \r\nGood day, dear friends.\n\nI want to find shortest path in random graph. I use boost graph library. As I understand I need to build graph using existing distances between dots. After that I need to use some algorithm...\n\nAs I see Dijkstra's algorithm is really finds all paths from 1 point to others. (It should be slow?)\n\nA*  wants some additional data (not only distances)\n\nHow can I find the shortest path between 2 points? I saw many shortest path algorithms headers in bgl folder, but I didn't find examples how to use them.\n\nAlso I can precompute something for graph is needed.\n\nWhat should I do?\n    ", "Answer": "\r\nit depends on how many nodes you have , as you mentioned your nodes are around O(10^4) and edges are O(10^4) which is good\nso in BOOST LIBRARY DOCS it sasy The time complexity is O(V log V + E). so if you put V = 10^4 and E = 10^4 you get about O(10^5) which is very good and can run less than 1 second on a normal computer so you can use it.\nA* Algorithm can run faster than Dijkstra but it needs a heuristic function which must be monotonic and admissible and it might be hard to find that function depending on your problem.\nso i think Dijkstra would be good enough for your case\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Finding all shortest paths between two nodes in NetworkX\r\n                \r\nAssume I have a BA network with N nodes where each node has at least 2 edges. The network is unweighted. I am trying to find all the shortest paths between every node ```\ni```\n and ```\nj```\n for all nodes in the network. But if there are more than 1 shortest path between node ```\ni```\n and ```\nj```\n, then I need every single shortest path between ```\ni ```\nand ```\nj```\n.\nSo if node 2 can be reached from 0 by using the paths ```\n[0,1,2], [0,3,4,2], [0,3,4,5,2], [0,4,5,2]```\n and ```\n[0,3,2]```\n, I need a list that says ```\n[[0,1,2], [0,3,2]]```\n.\nIs the only way of doing this is calculating each path from i to j and getting the smallest lenghted lists? Can this be founded in a more efficient way?\nEdit: Apparently there's a path finding method called all_shortest_paths. I will try this and see if it is efficient.\n    ", "Answer": "\r\nYou can use ```\nnx.nx.all_shortest_paths```\n for this:\n\nall_shortest_paths(G, source, target, weight=None, method='dijkstra')\n\nWhich allows you to specify a source and target nodes. Here's a simple example:\n```\nplt.figure(figsize=(6,4))\nG = nx.from_edgelist([[1,2],[2,3],[7,8],[3,8],[1,8], [2,9],[9,0],[0,7]])\nnx.draw(G, with_labels=True, node_color='lightgreen')\n```\n\n\n```\nlist(nx.all_shortest_paths(G, 2, 8))\n# [[2, 1, 8], [2, 3, 8]]\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Performance of shortest path algorithm in JUNG API\r\n                \r\nI use the JUNG API to calculate shortest paths between several nodes in medium large graphs (20 to 100 nodes). Right now I'm iterating over my nodes and use the simple 'ShortetsPath' function to calculate the shortest path for two nodes. All the shortest paths are put in an ArrayList.\n\n```\nUnweightedShortestPath<Vertex, SEdge> dist = new UnweightedShortestPath<Vertex, SEdge>(undir);\nArrayList<Vertex> tv = new ArrayList<Vertex>(); // contains nodes for shortestpath\nArrayList<Integer> distances = new ArrayList<Integer>(); // for the distances\n\nfor (int j = 0; j <tv.size()-1;j++){ //iterate over nodes\nVertex one = tv.get(j);\n\nfor (int k = j+1; k<tv.size();k++){ //iterate over next nodes\n    Vertex two = tv.get(k);\n    Number n = dist.getDistance(one, two);\n    int d;\n    if (n == null) {\n        d = 5000000;\n    }\n    else {\n        d = n.intValue();\n    }\n    distances.add(d);\n}\n```\n\n\n}\n\nI would like to speed up the calculation because I have to calculate this for many graphs and nodes. As far as I know, only Dijkstra is available in the JUNG API. So my questions are: Can I use Dijkstra to boost performance? Are other algorithms available in the JUNG API? Would it make sense to use another graph implementation which offers more different methods for shortest paths?\n\nThanks so far :)\n    ", "Answer": "\r\nThe UnweightedShortestPath class in JUNG uses a Breadth-First-Search Algorithm, which has O(n^2) runtime. The Dijkstra algorithm works essentially the same, just for weighted graphs instead of unweighted graphs, so it's runtime is also O(n^2).\n\nHowever, it looks like you're interested in the distances between all possible pairs of nodes in your graph, but you're using a pairwise approach. So your total runtime is O(n * n^2) = O(n^3).  Instead you could use a global shortest path algorithm like the Johnson's algorithm (http://en.wikipedia.org/wiki/Johnson's_algorithm). That's runtime O(n^2 * log(n+ne)). So a bit faster overall. \n\nIt's not implemented in JUNG as far as I know, but you might be able to grab it off google code search. \n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "shortest Path finder in NEO4j\r\n                \r\nI'm trying to use below method to find the shortest path between two nodes\n\n```\npublic static PathFinder<Path> shortestPath(PathExpander expander,\n                                        int maxDepth,\n                                        int maxHitCount)\n```\n\n\nI have created a function, where I'm trying to get only certain number of paths \nand till specific depth.\n\n```\npublic List<Path> run2(Node start, Node end, int k, int maxLength) {\n\n    List<Path> result = new LinkedList<Path>();\n    for (Path path : GraphAlgoFactory.shortestPath(expander, maxLength, k).findAllPaths(start, end))\n    {\n        result.add(path);\n\n    }\n    return result;\n\n}\n```\n\n\nbut when I call this function \n\n```\nrun2(source, target, 5,5);\n```\n\n\nI get more than 5 paths in many cases. How can I limit this method to return the less than or equal to specific number of paths? \n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path with dynamic programming\r\n                \r\nI don't want the answer to this problem, I just need a nudge in the right direction.\n\nGiven an undirected graph ```\nG```\n having ```\nN```\n (```\n1<N<=1000```\n) vertices and positive weights. Find the shortest path from vertex ```\n1```\n to vertex ```\nN```\n, or state that such path doesn’t exist.\nHint: At each step, among the vertices which weren’t yet checked and for which a path from vertex ```\n1```\n was found, take the one which has the shortest path, from vertex ```\n1```\n to it, yet found.\n\nFirst I have to define a state. This is what I said:\n\nThe state is the solution for vertex ```\ni```\n, where ```\ni <= N```\n. Smaller state would be the solution for ```\nj```\n, where ```\nj<i```\n. To find state ```\ni```\n, we need to find all smaller states ```\nj```\n (```\nj<i```\n). Having found the shortest path to ```\ni```\n, we can easily find the next state - the solution for ```\ni+1```\n.\n\nI took this from a different problem and just replaced variable names and some words because it sounded applicable to this one.\nI have to write a program for the solution, but I don't know how to start. Here are my questions:\n\nIs my definition of the state correct?\n\nMoreover, since this is an undirected graph, and each vertex is bidirectional, will the weights be passed in as a multidimensional array (i.e ```\nint W[N][2]```\n) where ```\nW[N][0]```\n is the weight of one vertex and ```\nW[N][1]```\n the weight of the other?\n\nHow do I represent the shortest path? Is it the number of paths taken, the sum of all the weights of the paths taken, or is it an array of all the weights of the paths taken?\n\n\n    ", "Answer": "\r\nHave you considered All-Pairs Shortest Paths algorithms? The Floyd-Warshall algorithm for example sounds as a possible solution for your problem. \n\nFloyd-Warshall algorithm is a dynamic programing algorithm. Also Floyd-Warshal algorithm supports directed graphs hence also undirected.\n\nFloyd-Warshall has a time complexity of Θ(|V|^3) and space complexity of Θ(|V|^2)\n\nWikipedia Link\nhttps://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm\n\nC implementation\nhttp://www.c-program-example.com/2011/10/c-program-to-implement-warshalls.html\n\nFinding the path can be left as an exercise\nThis link has an example of how its done but you will need to translate it to C. You can find it under Matrix of Predecessors\nhttp://www.programming-algorithms.net/article/45708/Floyd-Warshall-algorithm\n\nThis seems as a nice visual representation of the algorithm\nhttps://www.cs.usfca.edu/~galles/visualization/Floyd.html\n\nAnother approach would be the Bellman Ford algorithm. This is not an all pairs shortest path, instead it computes the shortest path from a single point to all other vertices.\n\nBellman-Ford algorithm is a dynamic programing algorithm. Also Bellman-Ford algorithm supports weighted directed graphs hence also undirected.\n\nBellman-Ford has a time complexity of Θ(|V||E|) and space complexity of Θ(|V|)\n\nWikipedia Link\nhttps://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm\n\nC implementation\nhttp://www.cs.dartmouth.edu/~cs57/Project/bellman-ford.c\n\nIn your case (assuming the space complexity is not an issue here) choosing between the two would mainly depend on the number of vertices compared to the number of edges. Generally if |E| is much greater than (|V|^2) then you should probably go with Warshall-Floyd otherwise if (|V|^2) is much greater than |E| you should probably go with Bellman-Ford.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path C# [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nIam trying to do a program which gives us shortest path on a map(map is a picture which has Rectangle on it. and my turn points are Rectangle's edge points. can anybody help me to find shortest path on this points?\n\nAs you can see ı have begin point and an end point. ımust start from begin to end and path must be from point. path can not be on Rectangle because it is my wall so ı cant go in or over it.\nSo can any body help???\n    ", "Answer": "\r\nIf efficiency is not an issue and a simple solution is OK, you could consider the following pseudo-code:\n\n```\nvisited = new bool[N,M]\npoints = new List<Point>()\nprev = new List<int>() \npoints.Add(Begin)\nprev.Add(-1)\nvisited[Begin.X, Begin.Y] = true\n\nfor(i = 0; i < points.Length; i++)\n    p = points(i)\n    foreach neighbor of p\n        if neighbor is not wall && !visited[neighbor.X, neighbor.Y]\n            points.Add(neighbor)\n            prev.Add(i)\n            visited[neighbor.X, neighbor.Y] = true\n            if neighbor == End\n                 // we are done, print path (without Begin and End)\n                 j = i\n                 while j != 0\n                     print points[j]\n                     j = prev[j]\n                 return\n// no solution found\n```\n\n\n(It is just a modification of Flood fill algorithm, http://en.wikipedia.org/wiki/Flood_fill.)\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Graph shortest path?\r\n                \r\nI am facing which I believe is a kind of shortest path problem on a graph.\n\nI need to find shortest path from node A to B, considering all edges have positive weight for connected vertexes, ∞ for not connected ones.\n\nVertexes have variable positive weightes.\n\nThe cost of a path is the weight of the vertex with maximum weight considering all vertexes involved in that path.\n\nShould I apply Dijkstra in this situation, and if so how, considering that the weight of each Vertex changes depending on the previous vertexes visited?\n\nCan you point me on how to tackle this problem otherwise?\n    ", "Answer": "\r\nI cant understand if you should consider the weights of the edges,because you said that you want the path with the max/min weight on a vertice possible,from A to B.\nMy solution for that is to convert every weight on vertex,to a weight on edge , just like in the image:\n\nnow you want to find the path from A to B where the the biggest weight on edge is min/max.\nyou can use MST algotirhm for this,because you dont care about the path lenght,but only the max/min edge cost.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "BFS can only search shortest path\r\n                \r\nMy question is motivated from a leetcode:\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/\n\nGiven an n x n binary matrix grid with 1/0, return the shortest path that is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that: All the visited cells of the path are 0. All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).\n\nObviously we will use ```\nqueue```\n for ```\nBFS```\n:\n```\nint shortestPathBinaryMatrix(vector<vector<int>>& grid) {\n    if (grid[0][0] == 1) return -1;\n    int res = 0, n = grid.size(), m = grid[0].size();\n    vector<vector<int>> visited(n, vector<int>(m, 0));\n    visited[0][0] = 1;\n    queue<vector<int>> q;\n    q.push({ 0, 0 });\n    vector<vector<int>> dirs{ {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}, {-1, -1} };\n    while (!q.empty()) {\n        ++res;\n        for (int i = q.size(); i > 0; --i) {\n            auto t = q.front(); q.pop();\n            if (t[0] == n - 1 && t[1] == n - 1) return res;\n            for (auto dir : dirs) {\n                int x = t[0] + dir[0], y = t[1] + dir[1];\n                if (x < 0 || x >= n || y < 0 || y >= m || grid[x][y] == 1 || visited[x][y]) continue;\n                visited[x][y] = 1; \n                q.push({ x, y });\n            }\n        }\n    }\n    return -1;\n}\n```\n\nMy question is can BFS only solve the shortest path? For example to find all the available paths, then above BFS will not work since here we mark all the visited cells to avoid duplicate visits, which guarantees the result is shortest path. And usually we use recursion to find all available paths.\nHere is using BFS to search all paths:\nUpdate:\n```\nvector<vector<vector<int>>> fun2(vector<vector<int>> grid, int x, int y)\n{\n    vector<vector<vector<int>>> res;\n    if (grid[x][y] == 1) return res;\n    int n = grid.size(), m = grid[0].size();\n    queue<vector<vector<int>>> q;\n    q.push({ { x, y } });\n    vector<vector<int>> dirs{ {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}, {-1, -1} };\n    while (!q.empty()) {\n        for (int i = q.size(); i > 0; --i) {\n            auto t = q.front(); q.pop();\n            unordered_set<string> st;\n            for (auto &it : t) st.insert(to_string(it[0]) + ',' + to_string(it[1]));\n            int xx = t.back()[0], yy = t.back()[1];\n            if (grid[xx][yy] == 2) res.push_back(t);\n            for (auto dir : dirs) {\n                int x = xx + dir[0], y = yy + dir[1];\n                if (x < 0 || x >= n || y < 0 || y >= m || grid[x][y] == 1 || st.count(to_string(x) + ',' + to_string(y))) continue;\n                auto tem = t;\n                tem.push_back({ x, y });\n                q.push(tem);\n            }\n        }\n    }\n    return res;\n}\n```\n\n    ", "Answer": "\r\nBFS could be used also to find all paths, but then it should not have a ```\nvisited```\n structure that is shared by all paths, but a separate structure for each path.\nSo instead of putting a single cell's coordinate on the queue, you'd put a path on the queue (consisting of coordinates of the cells on the path), and extend those paths with a next node when that node did not yet occur in that path.\nAs you can see that will require a lot more memory than DFS would need, without any clear compensating benefit.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "What is the difference between Travelling Salesman and finding Shortest Path?\r\n                \r\nThe only difference I could think of for the question is that in the Travelling Salesman Problem (TSP) I need to find a \nminimum permutation of all the vertices in the graph and in Shortest Paths problem there is no need to consider all the vertices we can search the states space for minimum path length routes can anyone suggest more differences.\n    ", "Answer": "\r\nYou've already called out the essential difference: the TSP is to find a path that contains a permutation of every node in the graph, while in the shortest path problem, any given shortest path may, and often does, contain a proper subset of the nodes in the graph.\n\nOther differences include:\n\n\nThe TSP solution requires its answer to be a cycle.\nThe TSP solution will necessarily repeat a node in its path, while a shortest path will not (unless one is looking for shortest path from a node to itself).\nTSP is an NP-complete problem and shortest path is known polynomial-time.\n\n\nIf you are looking for a precise statement of the difference I would say you just need to replace your idea of the \"permuation\" with the more technical and precise term \"simple cycle visiting every node in the graph\", or better, \"Hamilton cycle\":\n\n\n  The TSP requires one to find the simple cycle covering every node in the graph with the smallest weight (alternatively, the Hamilton cycle with the least weight).  The Shortest Path problem requires one to find the path between two given nodes with the smallest weight.  Shortest paths need not be Hamiltonian, nor do they need to be cycles.\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest Path With Priority Nodes\r\n                \r\nI have to find shortest path I guess djistra's algorithm is efficient for that. But I have added constraint that nodes have priority other than distance between them. So considering priority we have to find the shortest path. Can anyone spread some light on this.\nThanks in advance.\n    ", "Answer": "\r\nLet's say you have a graph ```\nG = (V, E)```\n, where ```\nV```\n is the set of vertices, ```\nE```\n is the set of edges. Since you want to introduce another parameter called priority in a set ```\nP```\n, defined as ```\nP = {pi | pi is the priority of vertex vi}```\n.\n\nYou can update your distance as ```\nd_ij_new = d_ij - (pi + pj)```\n. This will ensure that the distance decreases as a function of priorities of the vertices being considered. You will also need to make sure the distance does not go negative. To ensure that, add ```\n2 * pmax```\n to all the weights (```\npi + pj < 2 * pmax```\n).\n\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "SQL Shortest Path\r\n                \r\nI have a table with a bunch of edges which I made by: ```\nCREATE TABLE example ([FromId] INT, [ToId] INT);```\n (I must use a format like this). I am trying to find the shortest path between a given \"FromId\" to a \"ToId\" (ie we are trying to get from one node to other).\nI understand there is a SHORTEST PATH but I am unsure how to use this in my case as I did not declare my table a SQL graph.\nSorry if this is a stupid question I am new to StackOverflow and to SQL. I am using SQLite.\n    ", "Answer": "\r\nThis is a recursive CTE.  Here is one method:\n```\nwith recursive cte as (\n      select f, t, 1 as lev, (f || '->' || t) as path\n      from edges\n      where f = 1\n      union all\n      select e.f, e.t, lev + 1 , (cte.path || '->' || e.t) as path\n      from cte join\n           edges e\n           on e.f = cte.t\n      where lev < 100 or e.t = 4\n     )\nselect cte.*\nfrom cte\nwhere cte.t = 4\norder by lev\nlimit 1;\n```\n\nThis limits the path length to 100 -- a reasonable maximum in most cases -- to handle potential cycles in your graph.\nHere is a db<>fiddle.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Find shortest paths through predefined set of vertices and edges in arangodb\r\n                \r\nI need to find shortest paths which should pass through several nodes and edges. Few details:\n\n\nIt should be shortest paths according to weights.\nInclude set can be ordered and unordered.\nGraph size - 50 000 vertices and 450 0000 edges\n\n\nIs there any way to find paths like this using arangodb?\nI've tried K_SHORTEST_PATHS but it is too slow for some cases.\n    ", "Answer": "\r\nWithout a data set, this is tricky to test.  Unfortunately, ```\nK_SHORTEST_PATHS```\n is the only built-in way to add \"weight\" to edges, unless you build something yourself.  Also, both ```\nSHORTEST_PATH```\n methods do not implement ```\nPRUNE```\n, which is the best way to speed graph traversal.\n\nMy suggestion would be to use a directed graph method (```\nFOR v,e,p IN 1..9 INBOUND x...```\n), implementing both ```\nPRUNE```\n and ```\nFILTER```\n clauses to reduce the number of hops, and something like ```\nCOLLECT path = p AGGREGATE weight = SUM(e.weight)```\n to calculate weight.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "JGraphT graph shortest path\r\n                \r\nI am trying to calculate the total cost of the shortest path for a flight itinerary system, but it seems to be calculate the number of paths it take instead of the length/cost. I am unable to workout how to get the cost for each journey from the ```\nFlight_Info```\n object.\n\nHere is my code:\n\n```\nimport java.util.Scanner;\nimport org.jgrapht.graph.*;\nimport org.jgrapht.Graphs;\nimport org.jgrapht.alg.DijkstraShortestPath;\n\npublic class Flights2 {\n\npublic static SimpleDirectedWeightedGraph<String, Flight_Info> createGraph() {\n\n    SimpleDirectedWeightedGraph<String, Flight_Info> airport = new SimpleDirectedWeightedGraph<String, Flight_Info>(\n            Flight_Info.class);\n\n    String Edinburgh = new String(\"Edinburgh\");\n    String Heathrow = new String(\"Heathrow\");\n    String Dubai = new String(\"Dubai\");\n    String Sydney = new String(\"Sydney\");\n    String KualaLumpur = new String(\"Kuala Lumpur\");\n    String Frankfurt = new String(\"Frankfurt\");\n    String Aukland = new String(\"Aukland\");\n    String RioDeJanerio = new String(\"Rio De Janerio\");\n    String NewYork = new String(\"New York\");\n    String Santiago = new String(\"Santiago\");\n\n    airport.addVertex(Edinburgh);\n    airport.addVertex(Heathrow);\n    airport.addVertex(Dubai);\n    airport.addVertex(Sydney);\n    airport.addVertex(KualaLumpur);\n    airport.addVertex(Frankfurt);\n    airport.addVertex(Aukland);\n    airport.addVertex(RioDeJanerio);\n    airport.addVertex(NewYork);\n    airport.addVertex(Santiago);\n\n\n\n    Flight_Info FL1001 = new Flight_Info(\"FL1001\", 1530, 1630, 1, 80);\n    airport.addEdge(Edinburgh, Heathrow, FL1001);\n    Flight_Info FL1002 = new Flight_Info(\"FL1002\", 1630, 1730, 1, 80);\n    airport.addEdge(Heathrow, Edinburgh, FL1002);\n    Flight_Info FL1003 = new Flight_Info(\"FL1003\", 1630, 1730, 1, 80);\n    airport.addEdge(Heathrow, Dubai, FL1003);\n    Flight_Info FL1004 = new Flight_Info(\"FL1004\", 1630, 1730, 1, 80);\n    airport.addEdge(Dubai, Heathrow, FL1004);\n    Flight_Info FL1005 = new Flight_Info(\"FL1005\", 1630, 1730, 1, 80);\n    airport.addEdge(Heathrow, Sydney, FL1005);\n    Flight_Info FL1006 = new Flight_Info(\"FL1006\", 1630, 1730, 1, 80);\n    airport.addEdge(Sydney, Heathrow, FL1006);\n    Flight_Info FL1007 = new Flight_Info(\"FL1007\", 1630, 1730, 1, 80);\n    airport.addEdge(Dubai, KualaLumpur, FL1007);\n    Flight_Info FL1008 = new Flight_Info(\"FL1008\", 1630, 1730, 1, 80);\n    airport.addEdge(KualaLumpur, Dubai, FL1008);\n    Flight_Info FL1009 = new Flight_Info(\"FL1009\", 1630, 1730, 1, 80);\n    airport.addEdge(Dubai, Edinburgh, FL1009);\n    Flight_Info FL1010 = new Flight_Info(\"FL10010\", 1630, 1730, 1, 80);\n    airport.addEdge(Edinburgh, Dubai, FL1010);\n    Flight_Info FL1011 = new Flight_Info(\"FL1011\", 1630, 1730, 1, 80);\n    airport.addEdge(KualaLumpur, Sydney, FL1011);\n    Flight_Info FL1012 = new Flight_Info(\"FL1012\", 1630, 1730, 1, 80);\n    airport.addEdge(Sydney, KualaLumpur, FL1012);\n    Flight_Info FL1013 = new Flight_Info(\"FL1013\", 1630, 1730, 1, 80);\n    airport.addEdge(Edinburgh, Frankfurt, FL1013);\n    Flight_Info FL1014 = new Flight_Info(\"FL1014\", 1630, 1730, 1, 80);\n    airport.addEdge(Frankfurt, Edinburgh, FL1014);\n    Flight_Info FL1015 = new Flight_Info(\"FL1015\", 1630, 1730, 1, 80);\n    airport.addEdge(Sydney, Aukland, FL1015);\n    Flight_Info FL1016 = new Flight_Info(\"FL1016\", 1630, 1730, 1, 80);\n    airport.addEdge(Aukland, Sydney, FL1016);\n    Flight_Info FL1017 = new Flight_Info(\"FL1017\", 1630, 1730, 1, 80);\n    airport.addEdge(RioDeJanerio, NewYork, FL1017);\n    Flight_Info FL1018 = new Flight_Info(\"FL1018\", 1630, 1730, 1, 80);\n    airport.addEdge(NewYork, RioDeJanerio, FL1018);\n    Flight_Info FL1019 = new Flight_Info(\"FL1019\", 1630, 1730, 1, 80);\n    airport.addEdge(Santiago, NewYork, FL1019);\n    Flight_Info FL1020 = new Flight_Info(\"FL1020\", 1630, 1730, 1, 80);\n    airport.addEdge(NewYork, Santiago, FL1020);\n\n    return airport;\n}\n\npublic static void itinerary(SimpleDirectedWeightedGraph<String, Flight_Info> airport, String departure,\n        String destination) {\n    DijkstraShortestPath<String, Flight_Info> p = new DijkstraShortestPath<String, Flight_Info>(airport, departure,\n            destination);\n\n\n\n\n    System.out.println(p.getPathEdgeList());\n    System.out.println(\"Cost of shortest (i.e cheapest) path = £\" + p.getPathLength() );\n}\n\npublic static void main(String args[]) {\n\n    SimpleDirectedWeightedGraph<String, Flight_Info> airport = createGraph();\n    System.out.println(\"The following airports are in use:\" + airport.vertexSet());\n    @SuppressWarnings(\"resource\")\n    Scanner s = new Scanner(System.in);\n    System.out.println(\"Please enter the starting airport:\");\n    String departure = s.nextLine();\n    System.out.println(\"Please enter the destination aiport:\");\n    String destination = s.nextLine();\n    itinerary(airport, departure, destination);\n\n\n}\n```\n\n\n\n\n```\n  import org.jgrapht.graph.DefaultWeightedEdge;\n\npublic class Flight_Info extends DefaultWeightedEdge {\n\nprivate String departure, destination, flightNumber;\nprivate int departureTime, arrivalTime, duration, ticketPrice;\n\npublic Flight_Info() {\n\n}\n\npublic Flight_Info(String flightNumber, int departureTime, int arrivalTime, int duration, int ticketPrice) {\n    super();\n    this.flightNumber = flightNumber;\n    this.departureTime = departureTime;\n    this.arrivalTime = arrivalTime;\n    this.duration = duration;\n    this.ticketPrice = ticketPrice;\n\n}\n\n\npublic int getDuration(){\n    return duration;\n}\n```\n\n    ", "Answer": "\r\nI'm only guessing, but it seems that your Flight_Info class lacks a getter for the ticket price. Then you're reading the cost of the computed shortest path in edges. I think it would be better to iterate over the edges of the shortest path and sum up the ticket prices.\n\nAs I said: Just guessing after a short look...   =)\n\nBest regards\n\nAlex\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest Path DFS\r\n                \r\nContinuing my education of graph theory, I started to tackle the Maze II problem\n\nThere is a ball in a maze with empty spaces (represented as 0) and\nwalls (represented as 1). The ball can go through the empty spaces by\nrolling up, down, left or right, but it won't stop rolling until\nhitting a wall. When the ball stops, it could choose the next\ndirection.\nGiven the m x n maze, the ball's start position and the destination,\nwhere start = [startrow, startcol] and destination = [destinationrow,\ndestinationcol], return the shortest distance for the ball to stop at\nthe destination. If the ball cannot stop at destination, return -1.\nThe distance is the number of empty spaces traveled by the ball from\nthe start position (excluded) to the destination (included).\n\nTo get my feet wet, I wrote an algorithm based on DFS to check each direction for each cell and continue in a depth first manner if possible to find \"paths\", each time keeping count of the number of steps. I have a global variable that checks if the current count is less and then replaces the value. However, my shortest path isn't always right. Can anyone explain what I am doing wrong? I do understand that BFS yields a shortest path but I have having trouble visualizing the BFS done in different directions.\nBasically, I change direction only when I hit a wall and each time the count would start off with the count that the recursive function would have started with. As an example, running the algorithm below should produce a shortest path of 12 but my algorithm spits out 16\n```\npublic class MazeII {\n    int shortest = Integer.MAX_VALUE;\n    int[][] dirs = { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };\n\n    public static void main(String[] args) {\n        int[][] maze = {{0,0,1,0,0},{0,0,0,0,0},{0,0,0,1,0},{1,1,0,1,1},{0,0,0,0,0}};\n        int[] start = {0,4};\n        int[] destination = {4,4};\n        MazeII mii = new MazeII();\n        System.out.println(mii.shortestDistance(maze, start, destination));\n    }\n\n    public int shortestDistance(int[][] maze, int[] start, int[] destination) {\n        int count = 0;\n        boolean[][] visited = new boolean[maze.length][maze[0].length];\n        dfs(maze, start[0], start[1], destination, visited, count);\n        return shortest == Integer.MAX_VALUE? -1 : shortest;\n        \n    }\n    \n    private void dfs(int[][] maze, int i, int j, int[] destination, boolean[][]visited, int count) {\n        if( visited[i][j]) {\n            return;\n        }\n        if (i == destination[0] && j == destination[1]) {\n            shortest = Math.min(shortest, count);\n            return;\n        }\n        \n        visited[i][j] = true;\n\n        for (int[] dir : dirs) {\n            int x = i;\n            int y  = j;\n            int newcount = count;\n            while (x + dir[0] >= 0 && x + dir[0] < maze.length &&\n                    y + dir[1] >= 0 && y + dir[1] < maze[0].length &&\n                    maze[x + dir[0]][y + dir[1]] == 0) {\n                x+=dir[0];\n                y+=dir[1];\n                newcount++;\n            }\n            dfs(maze, x , y, destination, visited, newcount);\n        }\n    }\n\n}\n \n```\n\n    ", "Answer": "\r\nBelow is what I was trying to explain in comments:\n```\npublic class MazeII {\n    int shortest = Integer.MAX_VALUE;\n    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    public static void main(String[] args) {\n        int[][] maze = {{0, 0, 1, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 1, 0}, {1, 1, 0, 1, 1}, {0, 0, 0, 0, 0}};\n        int[] start = {0, 4};\n        int[] destination = {4, 4};\n        MazeII mii = new MazeII();\n        System.out.println(mii.shortestDistance(maze, start, destination));\n    }\n\n    public int shortestDistance(int[][] maze, int[] start, int[] destination) {\n        int count = 0;\n        boolean[][][] visited = new boolean[maze.length][maze[0].length][4];\n        dfs(maze, start[0], start[1], destination, visited, count);\n        return shortest == Integer.MAX_VALUE ? -1 : shortest;\n\n    }\n\n    private void dfs(int[][] maze, int i, int j, int[] destination, boolean[][][] visited, int count) {\n        if (i == destination[0] && j == destination[1]) {\n            shortest = Math.min(shortest, count);\n            return;\n        }\n\n        for (int k = 0; k < dirs.length; k++) {\n            int[] dir = dirs[k];\n            int x = i;\n            int y = j;\n            int newcount = count;\n            while (x + dir[0] >= 0 && x + dir[0] < maze.length &&\n                    y + dir[1] >= 0 && y + dir[1] < maze[0].length &&\n                    maze[x + dir[0]][y + dir[1]] == 0) {\n                x += dir[0];\n                y += dir[1];\n                newcount++;\n            }\n            if (!visited[x][y][k]) {\n                visited[x][y][k] = true;\n                dfs(maze, x, y, destination, visited, newcount);\n                visited[x][y][k] = false;\n            }\n        }\n    }\n\n}\n```\n\nHowever, in order to make traversal algorithm more optimal, you need somehow eliminate sub-optimal paths, for example store distance from cell to the destination when particular direction has been chosen:\n```\npublic class MazeII {\n    int shortest = Integer.MAX_VALUE;\n    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    public static void main(String[] args) {\n        int[][] maze = {{0, 0, 1, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 1, 0}, {1, 1, 0, 1, 1}, {0, 0, 0, 0, 0}};\n        int[] start = {0, 4};\n        int[] destination = {4, 4};\n        MazeII mii = new MazeII();\n        System.out.println(mii.shortestDistance(maze, start, destination));\n    }\n\n    public int shortestDistance(int[][] maze, int[] start, int[] destination) {\n        int count = 0;\n        int[][][] visited = new int[maze.length][maze[0].length][4];\n        for (int i = 0; i < maze.length; i++) {\n            for (int j = 0; j < maze[0].length; j++) {\n                Arrays.fill(visited[i][j], Integer.MAX_VALUE);\n            }\n        }\n\n        dfs(maze, start[0], start[1], destination, visited, count);\n        return shortest == Integer.MAX_VALUE ? -1 : shortest;\n\n    }\n\n    private void dfs(int[][] maze, int i, int j, int[] destination, int[][][] visited, int count) {\n        if (i == destination[0] && j == destination[1]) {\n            shortest = Math.min(shortest, count);\n            return;\n        }\n\n        for (int k = 0; k < dirs.length; k++) {\n            int[] dir = dirs[k];\n            int x = i;\n            int y = j;\n            int newcount = count;\n            while (x + dir[0] >= 0 && x + dir[0] < maze.length &&\n                    y + dir[1] >= 0 && y + dir[1] < maze[0].length &&\n                    maze[x + dir[0]][y + dir[1]] == 0) {\n                x += dir[0];\n                y += dir[1];\n                newcount++;\n            }\n            if (newcount < visited[x][y][k]) {\n                visited[x][y][k] = newcount;\n                dfs(maze, x, y, destination, visited, newcount);\n            }\n        }\n    }\n\n}\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path with one skippable edge\r\n                \r\nI have this problem: \"Shortest path with one skippable edge. Given an edge-weighted digraph, design an ```\nE*log(V)```\n algorithm to find a shortest path from ```\ns```\n to ```\nt```\n where you can change the weight of any one edge to zero. Assume the edge weights are nonnegative.\"\n\nI don't understand what they want me to do. What does it mean to change the weight to zero? I think that I can change any edge in any shortest path to zero and it will still be the shortest.\n    ", "Answer": "\r\nFirst use Dijkstra to find the length ```\nS(v)```\n of shortest path from ```\ns```\n to ```\nv```\n for every vertex ```\nv```\n. Then use Dijkstra to find the length ```\nT(v)```\n of shortest path from ```\nv```\n to ```\nt```\n for every vertex ```\nv```\n. Then for every edge ```\n(v, w)```\n find the sum ```\nS(v) + T(w)```\n by using the rules above. Finally, choose the minimum path. \n\nNote: In this approach we nullify the edge ```\n(v,w)```\n weight and find the shortest path through ```\n(v,w)```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "shortest path algorithm without loading graph in memory\r\n                \r\nhttps://networkx.github.io/documentation/stable/reference/algorithms/generated/networkx.algorithms.shortest_paths.generic.all_shortest_paths.html#networkx.algorithms.shortest_paths.generic.all_shortest_paths\n\nI need to find all shortest paths given the source and target nodes.\n\n```\nnetworkx```\n has a function to compute all shortest paths. But it requires the construction of the whole graph first.\n\nIn many cases, the shortest paths can be simple. For example, if the input is a TSV with each edge in a row, and the target node and the source node already has an edge between them, there is no need to construction such a graph in networkx first.\n\nIs there an efficient algorithm to find all shortest paths so that the graph is constructed only when it is needed?\n\nEDIT:\n\nFor start ```\na```\n and end ```\nd```\n.\n\nInput:\n\n```\na   a\na   b\nb   c\nc   d\nb   1\n1   d\n```\n\n\nOutput:\n\n```\na   b   1   d\na   b   c   d\n```\n\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Find shortest paths through predefined set of vertices and edges in arangodb\r\n                \r\nI need to find shortest paths which should pass through several nodes and edges. Few details:\n\n\nIt should be shortest paths according to weights.\nInclude set can be ordered and unordered.\nGraph size - 50 000 vertices and 450 0000 edges\n\n\nIs there any way to find paths like this using arangodb?\nI've tried K_SHORTEST_PATHS but it is too slow for some cases.\n    ", "Answer": "\r\nWithout a data set, this is tricky to test.  Unfortunately, ```\nK_SHORTEST_PATHS```\n is the only built-in way to add \"weight\" to edges, unless you build something yourself.  Also, both ```\nSHORTEST_PATH```\n methods do not implement ```\nPRUNE```\n, which is the best way to speed graph traversal.\n\nMy suggestion would be to use a directed graph method (```\nFOR v,e,p IN 1..9 INBOUND x...```\n), implementing both ```\nPRUNE```\n and ```\nFILTER```\n clauses to reduce the number of hops, and something like ```\nCOLLECT path = p AGGREGATE weight = SUM(e.weight)```\n to calculate weight.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Python: how to compute the number of shortest paths passing through one node?\r\n                \r\nSay that I have a regular network of ```\nNxN```\n nodes. The shortest path between two nodes is the minimum number of hops required to reach one target node from a source node. Now, each shortest path passes through a number of nodes along the way. \n\nMy goal: for each node in the network, I want to count the number of shortest paths that pass through a specific node, and save that number in a ```\ndict```\n.\n\nIn this little example, node B has 4 shortest paths passing through it:\n```\nA -> B```\n, ```\nA -> C```\n, ```\nC -> B```\n, ```\nC -> A```\n. I want to be able to compute this number for each node in a generic graph.\n\n\nI know I could use the nx.betweenness_centrality(), but this will give me a numerator (which is, for each node, what I want) divided by a denominator which stores all the possible shortest paths between two nodes. I have even accessed the source code but I wasn't able to figure out where the division is performed.\n\nI know this is a wordy question but I had no other means to explain my problem. Thank you to anyone who will help.\n\nEDIT\n\nThis is the source code for ```\nnx.betweenness_centrality()```\n. My graph is undirected. It is unclear which line hosts the division I introduced above: \n\n```\ndef betweenness_centrality(G, k=None, normalized=True, weight=None,\n                           endpoints=False,\n                           seed=None): #G is the graph\n\n    betweenness = dict.fromkeys(G, 0.0)  \n    if k is None:\n        nodes = G\n    else:\n        random.seed(seed)\n        nodes = random.sample(G.nodes(), k)\n    for s in nodes:\n        # single source shortest paths\n        if weight is None:  # use BFS\n            S, P, sigma = _single_source_shortest_path_basic(G, s)\n        else:  # use Dijkstra's algorithm\n            S, P, sigma = _single_source_dijkstra_path_basic(G, s, weight)\n        # accumulation\n        if endpoints:\n            betweenness = _accumulate_endpoints(betweenness, S, P, sigma, s)\n        else:\n            betweenness = _accumulate_basic(betweenness, S, P, sigma, s)\n    # rescaling\n    betweenness = _rescale(betweenness, len(G),\n                           normalized=normalized,\n                           directed=G.is_directed(),\n                           k=k)\n    return betweenness #Returns a dict with the node ID as a key and the value\n```\n\n    ", "Answer": "\r\nYou could just use ```\nnx.all_pairs_shortest_path(G)```\n:\n\n```\n>>> G = nx.Graph()\n>>> G.add_path([0,1,2])\n\n>>> spaths = nx.all_pairs_shortest_path(G)\n>>> spaths\n{0: {0: [0], 1: [0, 1], 2: [0, 1, 2]},\n 1: {0: [1, 0], 1: [1], 2: [1, 2]},\n 2: {0: [2, 1, 0], 1: [2, 1], 2: [2]}}\n```\n\n\nWhich finds you all the shortest paths between all pair of nodes in a graph (which is very expensive for large graphs). Then, the following code gives you the desired result:\n\n```\ndef num_spaths(G):\n    n_spaths = dict.fromkeys(G, 0.0)\n    spaths = nx.all_pairs_shortest_path(G)\n\n    for source in G:\n        for path in spaths[source].values():\n            for node in path[1:]: # ignore firs element (source == node)\n                n_spaths[node] += 1 # this path passes through `node`\n\n    return n_spaths\n```\n\n\nIn your example:\n\n```\n>>> num_spaths(G)\n{0: 2.0, 1: 4.0, 2: 2.0}\n```\n\n\n\n\nAdditionally, if you could go inside the ```\nall_pairs_shortest_path```\n code and sightly edit it to add a counter for shortest paths and\n\n```\nfor node in path[1:]:\n    n_spaths[node] += 1\n```\n\n\nthis way, you would update the number of paths online at the same time you find one, rather than having to iterate over all them (as my code does) after all them are calculated.\n\nEDIT: in networkx (github), line 251 says:\n\n```\npaths[w]=paths[v]+[w]\n```\n\n\nYou could potentially modify that function to update the number of shortest paths online (at the same time they are found) by passing ```\nn_spath```\n as an argument to the modified function and updating it inside. Then calling the function would be as:\n\n```\ndef num_spaths(G):\n    n_spaths = dict.fromkeys(G, 0.0)\n    for n in G:\n        my_single_source_shortest_path(G, n, n_spaths)\n    return n_spaths\n```\n\n\nand ```\nn_spaths```\n would have the number of shortest path updated.\n\n\n\nEDIT: The above only works if there is only 1 shortest path between A and B, as ```\nnx.all_pairs_shortest_path```\n only returns one shortest paths per each node pair. Find bellow the brute force search for all posible shortest paths. I wouldn't recommend runing this in a large graph:\n\n```\ndef bf_num_spaths(G):\n    n_spaths = dict.fromkeys(G, 0.0)\n\n    for source in G:\n        for target in G:\n            if source == target:\n                continue\n            for path in nx.all_shortest_paths(G, source, target):\n                for node in path[1:]: # ignore firs element (source == node)\n                    n_spaths[node] += 1 # this path passes through `node`\n\n    return n_spaths\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Standard Deviation of shortest path lengths in networkx\r\n                \r\n```\nnetworkx.average_shortest_path_length(G)```\n gives the average of shortest paths between all pairs of nodes in a graph ```\nG```\n. I want the standard deviation of all these shortest path lengths. Is there an inbuilt method in the networkx package?\n\nI am aware of using ```\nnx.all_pairs_shortest_path_length(G)```\n, which gives a dictionary of all the shortest path length. I was hoping that networkx has some inbuilt method instead, since it already has a method to calculate average.\n    ", "Answer": "\r\nThe current version of the software (2,4rc1 as of writing) does not have such a method. \n\nYou can check the list of methods available within this context here: https://networkx.github.io/documentation/latest/reference/algorithms/shortest_paths.html#module-networkx.algorithms.shortest_paths.unweighted\n\nDue to the fact that shortest path length calculation can be done with a multitude of algorithmic means, and each of them have a list of their own peculiar disadvantages, such a method would not really make sense in terms of what NetworkX is meant to do, or aims to achieve. Depending on how you aim to calculate the shortest path you should implement your own function for that, which can then circumvent these limitations within the specific graph you are working with. \n\nYou can easily calculate it from the dictionary NetworkX is already providing. \n\n```\nimport numpy as np\nimport networkx as nx\n\nPairs = nx.all_pairs_shortest_path_length(G)\nnp.std(Pairs)\n```\n\n\nMore about numpy.std here: https://docs.scipy.org/doc/numpy/reference/generated/numpy.std.html\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest Path in Hexagon plan?\r\n                \r\nIn the latest IEEE Xtreme Competition, a problem I've tried to solve is this,\n\nInput Two points p1(x1,y1) , p2(x2,y2) you must find the length of shortest path from p1 to p2,\n\nfor example if p1(1,1) , p2(4,4) then the shortest path has lenght of 9 edges,\n\n\n\nI did something like depth first search, it works great if the distance between the two point is small, and take long time for example for the points (1,1) & (10,10),\n\nAnd there is a limit on the points the maximum point is (12,12).\n\nmy approach is to convert the above picture to an undirected graph with all weights to 1, and then find the shortest path.\n\nhere are my function that finds the shortest path: \n\n```\nint minCost;\nvector<int> path;\nmultimap<int,int> Connections;\ntypedef multimap<int,int>::iterator mmit;\n\nvoid shortestPath(int cs){\n    if(cs > minCost)\n        return;\n    if(path.back() == Target){\n        if(cs < minCost)\n            minCost = cs;\n        return;\n    }\n\n    pair<mmit,mmit> it = Connections.equal_range(path.back());\n    mmit mit = it.first;\n\n    for( ; mit != it.second ; ++mit){\n        if(isVisited(mit->second))\n            continue;\n        markVisited(mit->second);\n        path.push_back(mit->second);\n        shortestPath(cs+1);\n        markUnvisited(mit->second);\n        path.pop_back();\n    }\n}\n```\n\n\nIs there any way faster than this ?? could i use dijkstra for this undirected graph ??\n    ", "Answer": "\r\nUsing Dijkstra or any kind of graph-based search seems like total overkill here.  At each vertex, you just need to choose the next vertex that brings you closer to your target.\n\nSo you start in the centre of (1,1).  You need to choose the starting vertex.  Obviously this is the one in the south-east.\n\nFrom there, you have three choices: move west, move north-east or move south-east.  This is in fact the choice you have at every second vertex.  You choose the direction that brings you closer (ie, subtends smallest angle with your target).\n\nIn fact, you can represent all your vertex co-ordinates in a sort of cheaty way.  Notice that they are all roughly half-way between the hexagon coordinates.  So you could say the first vertex is at ```\n(1.5,1.33)```\n.\n\nYour possible moves at the first co-ordinate are the directions:\n\n```\nwest       = (0, -0.67)\nnorth-east = (-0.5, 0.33)\nsouth-east = (0.5, 0.33)\n```\n\n\nLet's call that the odd-movement.  Now, the even-movement you have these choices:\n\n```\neast       = (0, 0.67)\nnorth-west = (-0.5, -0.33)\nsouth-west = (0.5, -0.33)\n```\n\n\nSo all you have to do is, for each possible direction, test the new distance (as the crow flies -- ie pythagoras) to your target.  Choose the new vertex that has the smallest distance of the three choices.  Obviously you don't have to compute the actual distance -- distance squared is fine.\n\nYou can figure out the initial and final moves, I'm sure.\n\nOne final point, obviously I'm using double arithmetic which is imprecise.  You can scale all your directions (and of course your hexagon co-ordinates) by 6 and use integers.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path in a maze with health loss\r\n                \r\nSuppose you have a dungeon, represented by a 2D matrix.  You have a start point S (x1,y1) and an end point E (x2, y2).  Along the way, some cells have a number in them, which subtract from your health score.  Other cells are obstacles that you can't go through.  You start with 5 health points, and you need to find the shortest path from S to E where you don't die on the way.\n\nI know that Dijikstra is used to find shortest paths.  But in this case the shortest path might be one in which you die along the way.  How do you find the shortest path where you don't die?  Note that there is no advantage to completing the race with more health points so long as you're alive at the end.\n    ", "Answer": "\r\nThe standard approach to problems like this is sometimes called 'graph layering'.  You make 5 copies of the original graph (numbered 0 through 4 in this case), where getting to a vertext v in graph n means getting to the corresponding vertex in the original graph after suffering n deaths.\n\nIf an edge in the original graph costs you a life, then it connects a vertex in each graph i to a vertex in graph i+1, and otherwise it connects vertices in the same version of the graph just like the original.\n\nAfter constructing this graph, use Dijkstra's algorithm to find the shortest path to the terminal vertex in any layer.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest-path in a grid using prolog\r\n                \r\nSorry by the first ask, I'm new at the hood... I did a cleaning on the code. The problem is:\nI have a square grid with paths and obstacles. I want to find the shortest path from a point to another. This is part of an artificial intelligence. When the path is too large, I can not see the whole list of points on the bash, but in the game, the character who travels this path, it does not at shortest path. So, my question is, how I can change this code to solve the shortest path. Thank you so much!\n\n```\nmov(X1,Y1,X2,Y2):-\n   pos(X1,Y1), X2 is X1 , Y2 is Y1+1 ,pos(X2,Y2).\nmov(X1,Y1,X2,Y2):-\n   pos(X1,Y1), X2 is X1 , Y2 is Y1-1 ,pos(X2,Y2). \nmov(X1,Y1,X2,Y2):-\n   pos(X1,Y1), X2 is X1+1 , Y2 is Y1 , pos(X2,Y2).\nmov(X1,Y1,X2,Y2):-\n   pos(X1,Y1), X2 is X1 -1 , Y2 is Y1 , pos(X2,Y2).\n\npath(X1,Y1,X2,Y2,Path) :-\n   travel(pos(X1,Y1),pos(X2,Y2),[pos(X1,Y1)],Q),\n   reverse(Q,Path).\n\ntravel(pos(X1,Y1),pos(X2,Y2),P,[pos(X2,Y2)|P]) :-\n   mov(X1,Y1,X2,Y2).\ntravel(pos(X1,Y1),pos(X2,Y2),Visited,Path) :-\n   mov(X1,Y1,X,Y),\n   pos(X,Y) \\== pos(X2,Y2), \n   \\+member(pos(X,Y),Visited),\n   travel(pos(X,Y),pos(X2,Y2),[pos(X,Y)|Visited],Path).\n```\n\n    ", "Answer": "\r\nFirst some Prolog advice.\n\n\n```\nmember/2```\n is a built-in, you should not have to define it.\nISO negation is ```\n\\+```\n, not ```\nnot/1```\n.\nFor performance, ```\nmemberchk/2```\n beats ```\nmember/2```\n.\nI see a lot of ```\nfoo(X,Y) :- X == Y, ...```\n in your code. It's much better if you just say ```\nfoo(X,X)```\n and save yourself the trouble of making explicit tests like this, unless you're going to do a conditional expression to avoid a choice point or something.\nLots of cuts in this code. Cuts and bugs tend to be great friends because the cut can undermine reasonable-looking code by preventing it from being executed.\n\n\nIf I had to solve this problem, I would want to separate the shortest-path logic from the grid traversal logic. You'll never be able to debug this, and even if you do, what you'll have is a one of those unreadable blocks of code that cannot be modified. It's clear that you have an explosion of terms because you're embedding the traversal logic in the path finding logic. Break them out into two separate steps and you will probably find that you get smaller pieces you can meaningfully test and debug. This is a good way of life with programming, regardless of the language: what would you do if you needed to change the grid structure or make the pathfinding more intelligent or complex? Keeping pieces granular always helps for managing change.\n\nAs for S.O. etiquette, this isn't great: you should talk about what doesn't work and what you've tried and you want to supply a minimum, complete, verifiable example. I suspect in producing such a thing you'd probably solve the problem yourself.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Finding the number of all the shortest paths between two nodes in directed unweighted graph\r\n                \r\nI need help to finding the number of all the shortest paths between two nodes in an directed unweighted graph.\n\nI am able to find one of the shortest paths using BFS algorithm, but i dont know how to find all the shortest paths.\n\nAny idea of the algorithm / pseudocode I could use?\n\nThanks!!\n    ", "Answer": "\r\nYou can do it by remembering how many paths are leading to each node, and when discovering a new node - summarize that number.\n\nFor simplicity, let's assume you have regular BFS algorithm, that whenever you use an edge ```\n(u,v)```\n, calls ```\nvisit(u,v,k)```\n, where:\n\n```\nu - the source node of the edge\nv - the target node of the edge\nk - the distance from the original source to u\n```\n\n\nIn addition to this, assume you have a mapping ```\nd:(vertex,distance)->#paths```\n.\nThis is basically a map (or 2D matrix) that it's key is a pair of vertex and an integer - distance, and its value is the number of shortest paths leading from the source, to that vertex, with distance ```\nk```\n.\n\nIt is easy to see that for each vertex v:\n\n```\nd[v,k] = sum { d[u,k-1] | for all edges (u,v) } \nd[source,0] = 0\n```\n\n\nAnd now, you can easily find the number of shortest paths of length ```\nk```\n leading to each node.\n\nOptimization:\n\nYou can see that \"number of shortest paths of length k\" is redundant, you actually need only one value of ```\nk```\n for each vertex. This requires some book-keeping, but saves you some space.\n\nGood luck!\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Algorithm to check track of shortest path\r\n                \r\nI have a matrix ```\nA```\n of size ```\nIxJ```\n with each element (weight) defining the distance between nodes ```\ni```\n and ```\nj```\n. I want to check the shortest path between each pair of nodes and have used the ```\nBrain Connectivity Toolbox```\n script ```\ncharpath.m```\n for this previously. However, this algorithm does not tell me exactly which path is taken, only the length. \n\nNow my question is:\nIs anyone familiar with a Matlab algorithm that provides the path taken between each node pair? E.g. if a shortest path between node ```\n1```\n and ```\n2```\n is ```\n4```\n, it should output the path taken (e.g. ```\n[1,74,43,4]```\n). Ideally in case of multiple shortest path of the same length it should report all of these paths. \n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Is there a true single-pair shortest path algorithm?\r\n                \r\nI came across this term today \"single-pair shortest path problem\". I was wondering if a single-pair shortest path algorithm exists for weighted graphs. My reasoning might be flawed, but I imagine that if you want to find the shortest path between A and Z, you absolutely have to know the shortest path from A to B, C, D, ... Y.\n\nIf you do not know the latter you can not be sure that your path is in fact the shortest one. Thus for me any shortest path algorithm has to compute the shortest path from A to every other vertex in the graph, in order to get the shortest path from A to Z. \n\nIs this correct? \n\nPS: If yes, any research paper properly proving this?\n    ", "Answer": "\r\nFor non-negative weighted edges graph problem Dijkstra itself solves given problem.\n\nA quote from wiki\n\n\n  The algorithm exists in many variants; Dijkstra's original variant\n  found the shortest path between two nodes, but a more common variant\n  fixes a single node as the \"source\" node and finds shortest paths from\n  the source to all other nodes in the graph, producing a shortest-path\n  tree.\n\n\nConsider following pseudo code from wiki:\n\n```\n 1  function Dijkstra(Graph, source):\n 2\n 3      create vertex set Q\n 4\n 5      for each vertex v in Graph:             // Initialization\n 6          dist[v] ← INFINITY                  // Unknown distance from source to v\n 7          prev[v] ← UNDEFINED                 // Previous node in optimal path from source\n 8          add v to Q                          // All nodes initially in Q (unvisited nodes)\n 9\n10      dist[source] ← 0                        // Distance from source to source\n11      \n12      while Q is not empty:\n13          u ← vertex in Q with min dist[u]    // Node with the least distance will be selected first\n14          remove u from Q \n15          \n16          for each neighbor v of u:           // where v is still in Q.\n17              alt ← dist[u] + length(u, v)\n18              if alt < dist[v]:               // A shorter path to v has been found\n19                  dist[v] ← alt \n20                  prev[v] ← u \n21\n22      return dist[], prev[]\n```\n\n\nwith each new iteration of ```\nwhile```\n (12), first step it to pick the vertex ```\nu```\n with shortest distance from the remaining set ```\nQ```\n (13) and then that vertex is removed from the ```\nQ```\n (14) notifying that shortest distance to ```\nu```\n has been achieved. If ```\nu```\n is your destination then you can halt without considering further edges.\n\nNote that all vertices were used but not all edges and shortest path to all vertices was not yet found.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How to ignore paths of equal length in Yen's shortest path algorithm (python networkx)\r\n                \r\nI am using a code to implement Yen's algorithm in order to find the k shortest paths. However I would like it to produce the k shortest paths of different lengths, i.e. if multiple paths have the same length it just chooses one of those and returns the length.\n\nThe code of Yen's algorithm is as follows (credits to https://github.com/nextgis/metro4all/wiki/Yen%27s-algorithm-for-networkx):\n\n```\n\nimport networkx as nx \nimport Queue\n\n\ndef path_cost(graph, path, weight=None):\n    pathcost = 0\n    for i in range(len(path)):\n        if i > 0:\n            edge = (path[i-1], path[i])\n            if weight != None:\n                pathcost += graph.get_edge_data(*edge)[weight]\n            else:\n                #just count the number of edges\n                pathcost += 1\n    return pathcost\n\n\ndef ksp(graph, source, target, num_k, weight):\n    # Shortest path from the source to the target\n    A = [nx.shortest_path(graph, source, target, weight=weight)]\n    A_costs = [path_cost(graph, A[0], weight)]#[nx.shortest_path_length(graph, source, target, weight=weight)]\n\n    # Initialize the heap to store the potential kth shortest path\n    B = Queue.PriorityQueue()\n\n    for k in range(1, num_k):\n        # The spur node ranges from the first node to the next to last node in the shortest path\n        try:\n            for i in range(len(A[k-1])-1):\n                # Spur node is retrieved from the previous k-shortest path, k - 1\n                spurNode = A[k-1][i]\n                # The sequence of nodes from the source to the spur node of the previous k-shortest path\n                rootPath = A[k-1][:i]\n\n                # We store the removed edges\n                removed_edges = []\n\n                for path in A:\n                    if len(path) - 1 > i and rootPath == path[:i]:\n                        # Remove the links that are part of the previous shortest paths which share the same root path\n                        edge = (path[i], path[i+1])\n                        if not graph.has_edge(*edge):\n                            continue\n                        removed_edges.append((edge, graph.get_edge_data(*edge)))\n                        graph.remove_edge(*edge)\n\n                # Calculate the spur path from the spur node to the sink\n                try:\n                    spurPath = nx.shortest_path(graph, spurNode, target, weight=weight)\n\n                    # Entire path is made up of the root path and spur path\n                    totalPath = rootPath + spurPath\n                    totalPathCost = path_cost(graph, totalPath, weight)\n                    # Add the potential k-shortest path to the heap\n                    B.put((totalPathCost, totalPath))\n\n                except nx.NetworkXNoPath:\n                    pass\n\n                #Add back the edges that were removed from the graph\n                for removed_edge in removed_edges:\n                    graph.add_edge(\n                        *removed_edge[0],\n                        **removed_edge[1]\n                    )\n\n            # Sort the potential k-shortest paths by cost\n            # B is already sorted\n            # Add the lowest cost path becomes the k-shortest path.\n            while True:\n                try:\n                    cost_, path_ = B.get(False)\n                    if path_ not in A:\n                        A.append(path_)\n                        A_costs.append(cost_)\n                        break\n                except Empty:\n                    break\n        except Queue.IndexError:\n            pass\n\n    return A_costs\n```\n\n\nI tried to change the line at the end ```\nif path_ not in A:```\n to ```\nif (path_ not in A) and (cost_ not in A_costs):```\n, but that returns the error\n\n```\nAttributeError                            Traceback (most recent call last)\n<ipython-input-58-038c80524d5d> in <module>()\n----> 1 ksp(G,'source','target',100,\"weight\")\n\n<ipython-input-54-7b3d0aa42558> in ksp(graph, source, target, num_k, weight)\n     77                 except Empty:\n     78                     break\n---> 79         except Queue.IndexError:\n     80             pass\n     81 \n\nAttributeError: 'module' object has no attribute 'IndexError'\n```\n\n\nWhat would be a better way?\n\nEDIT:\nMy test graph is the following:\n\n```\nG = nx.DiGraph()\n\nG.add_node(\"source\")\nG.add_node(\"target\")\n\nfor i in range(16):\n    G.add_node(i+1)\n\nfor i in range(4):\n    G.add_edge(\"source\",i+1,weight=0)\n    G.add_edge(16-i,\"target\",weight=0)\n\nW=np.empty([3,4,4])\n\nW[0::]=np.array([[3,9,7,16],\n                 [21,2,18,29],\n                 [37,32,41,17],\n                 [42,12,19,26]])\nW[1::]=np.array([[9,12,10,22],\n                 [24,5,11,28],\n                 [40,35,38,19],\n                 [45,6,43,27]])\nW[2::]=np.array([[1,2,3,4],\n                 [5,6,7,8],\n                 [9,10,11,12],\n                 [13,14,15,16]])\n\nfor i in range(4):\n    for j in range(4):\n        G.add_edge(i+1,j+5,weight=W[0,i,j])\n        G.add_edge(i+5,j+9,weight=W[1,i,j])\n        G.add_edge(i+9,j+13,weight=W[2,i,j])\n```\n\n\nIf I do\n\n```\nprint newnewksp(G,'source','target',8,\"weight\")\nprint newksp(G,'source','target',35,\"weight\")\nprint ksp(G,'source','target',35,\"weight\")\n```\n\n\n(where ```\nnewksp```\n is my suggestion, and ```\nnewnewksp```\n @H4kim 's), I get\n\n```\n[12.0, 13.0, 22.0, 27.0, 31.0, 40.0, 43.0, 50.0]\n[12.0, 13.0, 14.0, 15.0, 16.0, 19.0, 20.0, 21.0, 22.0, 23.0, 27.0, 28.0, 29.0, 30.0, 31.0, 32.0, 34.0, 35.0, 36.0, 37.0, 39.0, 40.0, 41.0, 42.0, 47.0, 48.0, 49.0, 50.0, 51.0, 52.0, 53.0, 54.0, 55.0, 56.0, 57.0]\n[12.0, 13.0, 13.0, 14.0, 14.0, 15.0, 15.0, 16.0, 19.0, 20.0, 20.0, 21.0, 21.0, 22.0, 22.0, 22.0, 22.0, 22.0, 23.0, 23.0, 23.0, 23.0, 24.0, 24.0, 24.0, 25.0, 25.0, 25.0, 27.0, 27.0, 28.0, 28.0, 28.0, 29.0, 29.0]\n```\n\n    ", "Answer": "\r\nI think your change is ok but ```\nQueue.IndexError```\n should be replaced by ```\nIndexError```\n since it is a python built-in exception. At the opposite ```\nEmpty```\n is not a built-in exception so it should be ```\nQueue.Empty```\n.\n\nI suppose we shouldn't change ```\nA```\n in the main loop because is critical for the algorithm. Instead we could try to change the end condition by tracking the different costs values in a ```\nset```\n :\n\n```\nimport networkx as nx \nimport Queue\n\n\ndef path_cost(graph, path, weight=None):\n    pathcost = 0\n    for i in range(len(path)):\n        if i > 0:\n            edge = (path[i-1], path[i])\n            if weight != None:\n                pathcost += graph.get_edge_data(*edge)[weight]\n            else:\n                #just count the number of edges\n                pathcost += 1\n    return pathcost\n\n\ndef ksp(graph, source, target, num_k, weight):\n    # Shortest path from the source to the target\n    A = [nx.shortest_path(graph, source, target, weight=weight)]\n    A_costs = [path_cost(graph, A[0], weight)]\n\n    unique_costs = set(A_costs)\n\n    # Initialize the heap to store the potential kth shortest path\n    B = Queue.PriorityQueue()\n\n    k = 1\n    while len(unique_costs) < num_k:\n        # The spur node ranges from the first node to the next to last node in the shortest path\n        try:\n            for i in range(len(A[k-1])-1):\n                # Spur node is retrieved from the previous k-shortest path, k - 1\n                spurNode = A[k-1][i]\n                # The sequence of nodes from the source to the spur node of the previous k-shortest path\n                rootPath = A[k-1][:i]\n\n                # We store the removed edges\n                removed_edges = []\n\n                for path in A:\n                    if len(path) - 1 > i and rootPath == path[:i]:\n                        # Remove the links that are part of the previous shortest paths which share the same root path\n                        edge = (path[i], path[i+1])\n                        if not graph.has_edge(*edge):\n                            continue\n                        removed_edges.append((edge, graph.get_edge_data(*edge)))\n                        graph.remove_edge(*edge)\n\n                # Calculate the spur path from the spur node to the sink\n                try:\n                    spurPath = nx.shortest_path(graph, spurNode, target, weight=weight)\n\n                    # Entire path is made up of the root path and spur path\n                    totalPath = rootPath + spurPath\n                    totalPathCost = path_cost(graph, totalPath, weight)\n                    # Add the potential k-shortest path to the heap\n                    B.put((totalPathCost, totalPath))\n\n                except nx.NetworkXNoPath:\n                    pass\n\n                #Add back the edges that were removed from the graph\n                for removed_edge in removed_edges:\n                    graph.add_edge(\n                        *removed_edge[0],\n                        **removed_edge[1]\n                    )\n\n            # Sort the potential k-shortest paths by cost\n            # B is already sorted\n            # Add the lowest cost path becomes the k-shortest path.\n            while True:\n                try:\n                    cost_, path_ = B.get(False)\n                    if path_ not in A:\n                        A.append(path_)\n                        A_costs.append(cost_)\n                        unique_costs.add(cost_)\n                        break\n                except Queue.Empty:\n                    break\n        except IndexError:\n            pass\n\n        k += 1\n\n    return list(unique_costs)\n```\n\n\nIt returns the following with your example : \n\n```\n>>> print ksp(G,'source','target',35,\"weight\")\n[12.0, 13.0, 14.0, 15.0, 16.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0, 27.0, 28.0, 29.0, 30.0, 31.0, 32.0, 33.0, 34.0, 35.0, 36.0, 37.0, 38.0, 39.0, 40.0, 41.0, 42.0, 43.0, 44.0, 45.0, 46.0, 47.0, 48.0, 49.0]\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest paths without supernodes in Neo4j\r\n                \r\nI have a graph with 0.5 billion of nodes and edges in Neo. I want to find shortest path between 2 nodes that avoids supernodes (even if it is longer than paths having supernodes on them).\n\nThe below query works fine for smaller graphs, but never finishes for the graph of the size I am dealing with:\n\n```\nMATCH (n:Node { id:'123'}),(m:Node { id:'234' }), p = shortestPath((n)-[*..6]-(m)) \nWHERE NONE(x IN NODES(p) WHERE size((x)--())>1000)\nRETURN p\n```\n\n\nIf I remove the WHERE clause it is super fast. Typically subsecond. \n\nHow can I speed it up? Would precalculating node degrees and indexing them help? Should I resort to duplicating all the edges apart from the ones adjacent to supernodes, giving them a new label and using them for my shortestPath query without the WHERE clause? Any other suggestions?\n    ", "Answer": "\r\nAs far as I can tell the Neo4j shortest path implementation prunes paths when the WHERE ALL contains relationships only (not nodes). Where it cannot prune the queries it finds all the paths then filters them (slow).\n\nAs Martin says you can add a label:\n\n```\nMATCH (x:Node)\nWHERE size((x)--())>1000\nSET n:Supernode\n```\n\n\nAnd then interrogate the nodes' label via the edges:\n\n```\nMATCH p = shortestPath((n:Node { id:'1'})-[*..6]-(m:Node { id:'2' })) \nWHERE ALL( rel IN relationships(p) WHERE not (startNode(rel):Supernode or endNode(rel):Supernode))\nRETURN p\n```\n\n\nThis will allow Neo4j to use the optimised, bi-directional, breadth-first (fast) query.\n\nSome more reading here:\nhttps://neo4j.com/docs/developer-manual/current/cypher/execution-plans/shortestpath-planning/\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "O(E) shortest path\r\n                \r\nIs there a way to find the shortest path from a single source to a vertex in a graph with arbitrary weights in O(E) but you only need to worry about it if the shortest path has 7 edges or less.\n\nBellman-Ford algorithm has a best case run time of O(E), would that apply here?\n    ", "Answer": "\r\nIf you know the shortest paths with <= N steps to all vertices, then it's easy to calculate the shortest paths with <= N+1 steps by iterating over the edges and evaluating the longer paths you could make with each one.\n\nAt N=0, the shortest path to the source vertex has length 0 and the shortest paths to all other vertices have length infinity (i.e., you can't get there).  You only have to iterate over the edges 7 times to find the shortest paths to everywhere you can get in <= N=7 steps, for a total running time of O(E) if you're a little bit careful about your data structures.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Floyd algorithm shortest path\r\n                \r\ni have written the code below,it works for shortest distance but not for shortest path,\n\n```\n         import math\n         def floyd(dist_mat):\n         n=len(dist_mat)\n         p=[[0]*n]*n\n            for k in range(n):\n                for i in range(n):\n                    for j in range(n):\n                        if dist_mat[i][j]>dist_mat[i][k]+dist_mat[k][j]:\n                            dist_mat[i][j] = dist_mat[i][k] + dist_mat[k][j]\n                            p[i][j] = k+1\n            return p\n\n        if __name__ == '__main__':\n             print(floyd([[0,5,9999,9999],\n                   [50,0,15,5],\n                   [30,9999,0,15],\n                   [15,9999,5,0]]))\n```\n\n\nresult of this code is: ```\n[[4, 1, 4, 2], [4, 1, 4, 2], [4, 1, 4, 2], [4, 1, 4, 2]]```\n\ntrue result is: ```\n[[0, 0, 4, 2], [4, 0, 4, 0], [0, 1, 0, 0], [0, 1, 0, 0]]```\n,\n\nI will be happy to receive your ideas about why it works wrong soon\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest Path LinkedList\r\n                \r\nI want to find the shortest path on a list of linked list, which represents a directed graph with cost per edge/path. \n\nThe output would look something like this, It tells me the cost it would take me to get from vertex 0 to the other vertices:\n\n```\nd[0 to 0] = 0\nd[0 to 1] = 20\nd[0 to 2] = 10\n```\n\n\nThis is how I populate my list for testing.\n\n```\nLinkedList<GraphData> g = new LinkedList[3];\n\nfor (int i = 0; i < 3; i++)\n    weight[i] = new LinkedList<GraphData>();\n\ng[0].add(new GraphData(1, 20);\ng[0].add(new GraphData(2, 10);\n```\n\n\nThe GraphData class looks something like this:\n\n```\nint vertex, int edgeCost;\n```\n\n\nNow for my problem:\n\nI want to find the shortest path from vertex v to all the others.\n\n```\n public static int[] shortestPaths(int v, LinkedList<GraphData>[] cost)\n{\n    // get the set of vertices\n    int n = cost.length;\n\n    // dist[i] is the distance from v to i\n    int[] dist = new int[n];\n\n    // s[i] is true if there is a path from v to i\n    boolean[] s = new boolean[n];\n\n    // initialize dist\n    for(int i = 0; i < n; i++)\n        dist[i] = cost[v].get(i).getCost();\n\n    s[v] = true;\n\n    // determine n-1 paths from v \n    for ( int j = 2 ; j < n  ; j++ )\n    {\n        // choose u such that dist[u] is minimal for all w with s[w] = false\n        // and dist[u] < INFINITY\n        int u = -1;\n\n        for (int k = 0; k < n; k++)\n            if ( !s[k] && dist[k] < INFINITY)\n                // check if u needs updating\n                if ( u < 0 || dist[k] < dist[u])\n                    u = k;\n        if (u < 0)\n            break; \n\n        // set s[u] to true and update the distances\n        s[u]=true;\n\n        for (int k = 0; k < n; k++)\n            if ( !s[k] && cost[u].get(k).getCost() < INFINITY )\n                if( dist[k] > dist[u] + cost[u].get(k).getCost())\n                    dist[k] = dist[u] + cost[u].get(k).getCost();\n\n        // at this point dist[k] is the smallest cost path from\n        // v to k of length j.\n    }       \n    return dist;\n}\n```\n\n\nThis line dist[i] = cost[v].get(i).getCost(); throws \"IndexOutOfBoundsException\" \n\nAny idea what I am doing wrong? Any help will be appreciated.\n    ", "Answer": "\r\nThere are two common ways to represent graphs: adjacency lists and adjacency matrices.\n\nAdjacency List: Array of lists. The element at index ```\ni```\n is a small list containing the outgoing edges of vertex ```\ni```\n. This is what you are creating when you populate the list.\n\nAdjacency Matrix: Array of arrays, with ```\ncost[i][j]```\n containing the cost of the edge from vertex ```\ni```\n to vertex ```\nj```\n. You are using the ```\ncost```\n parameter as if it is an adjacency matrix.\n\nYou have two options:\n\n\nChange the graph construction to create an adjacency matrix and use an array of arrays\nChange the algorithm to treat ```\ncost```\n as an adjacency list instead of an adjacency matrix\n\n\nHere is the second option. I renamed a few things and simplified the initialization so that the first iteration calculates the distance to the immediate neighbours of ```\nv```\n (as opposed to doing it as a special case at the start).\n\n```\nimport java.util.*;\n\npublic class Main\n{\n    public static int[] shortestPaths(int v, LinkedList<Edge>[] edges)\n    {\n        // get the set of vertices\n        int n = edges.length;\n\n        // dist[i] is the distance from v to i\n        int[] dist = new int[n];\n        for (int i = 0; i < n; i++) {\n            dist[i] = Integer.MAX_VALUE;\n        }\n\n        // seen[i] is true if there is a path from v to i\n        boolean[] seen = new boolean[n];\n\n        dist[v] = 0;\n\n        // determine n-1 paths from v\n        for (int j = 0; j < n; j++) {\n            // choose closest unseen vertex\n            int u = -1;\n\n            for (int k = 0; k < n; k++) {\n                if (!seen[k]) {\n                    // check if u needs updating\n                    if (u < 0 || dist[k] < dist[u]) {\n                        u = k;\n                    }\n                }\n            }\n\n            if (u < 0 || dist[u] == Integer.MAX_VALUE) {\n                break;\n            }\n\n            // at this point dist[u] is the cost of the\n            // shortest path from v to u\n\n            // set seen[u] to true and update the distances\n            seen[u] = true;\n\n            for (Edge e : edges[u]) {\n                int nbr = e.getTarget();\n                int altDist = dist[u] + e.getCost();\n                dist[nbr] = Math.min(dist[nbr], altDist);\n            }\n        }\n\n        return dist;\n    }\n\n    public static void main(String[] args)\n    {\n        int n = 5;\n        int start = 0;\n        LinkedList<Edge>[] cost = new LinkedList[n];\n        for (int i = 0; i < n; i++) {\n            cost[i] = new LinkedList<Edge>();\n        }\n\n        cost[0].add(new Edge(1, 20));\n        cost[0].add(new Edge(2, 10));\n        cost[1].add(new Edge(3, 5));\n        cost[2].add(new Edge(1, 6));\n\n        int[] d = shortestPaths(start, cost);\n        for (int i = 0; i < n; i++) {\n            System.out.print(\"d[\" + start + \" to \" + i + \"] = \");\n            System.out.println(d[i]);\n        }\n    }\n}\n\nclass Edge\n{\n    int target, cost;\n\n    public Edge(int target, int cost) {\n        this.target = target;\n        this.cost = cost;\n    }\n\n    public int getTarget() {\n        return target;\n    }\n\n    public int getCost() {\n        return cost;\n    }\n}\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "About |A| shortest path\r\n                \r\nIs there anything called |A| shortest path problem. Why is that used for? Please provide any reference to it. I want to know this of my curiosity. \n    ", "Answer": "\r\n```\n|A|```\n is a notation meaning the cardinality of A or the number of elements in ```\nA```\n. In the answer you refer to, the user meant you are reducing the problem to several other problems of type shortest path problem and the number of these problems is equal to the number of elements in ```\nA```\n.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "count number of shortest paths BOOST graph c++\r\n                \r\nI'm trying to get the number of shortest paths from points 1 to 7.\n\nI know there are many methods in the BOOST c ++ library like kruskal, dijkstra , r_c_shortest_path or just dfs/bfs....\n\nThe problem is that I understand that all these methods return only 1 way.\n\nthere is some method that pulls all the different paths to get from one point to another?\n\nFor example i have this:\n\n   \n\n```\n#include <boost/config.hpp>\n#include <boost/graph/adjacency_list.hpp>\nusing namespace boost;\n#include <iostream>\nusing namespace std;\n\nint main(int, char*[])\n{\n    typedef adjacency_list<> Graph ;\n    Graph g(10);\n    typedef std::pair<int, int> E;\n    const int num_nodes = 7;\n    E edge_array[] = { E(1, 2), E(1, 3), E(2, 4), E(3, 4), E(2, 5),\n      E(4, 5), E(4, 7), E(4, 6), E(5,7), E(6,7)\n    };\n    int weights[] = { 5,7,10,8,30,12,25,11,13,30 };\n    boost::graph_traits<Graph>::vertex_descriptor vd, vd2; \n    typedef typename boost::graph_traits<Graph>::edge_descriptor e;\n    std::pair<e, bool> p[10];\n    for (int i = 0; i < 10; ++i) {\n        vd = edge_array[i].first;\n        vd2 = edge_array[i].second;\n        p[i] = add_edge(vd, vd2, g);\n    }\n\n    graph_traits<Graph>::vertex_descriptor s = source(p[0].first,g);\n    graph_traits<Graph>::vertex_descriptor t = target(p[9].first,g);\n\n\n//And now here i need to save all the posible shortest paths using:\n//kruskal\ntemplate <class Graph, class OutputIterator, class P, class T, class R>\nOutputIterator\nkruskal_minimum_spanning_tree(Graph& g, OutputIterator tree_edges, \n    const bgl_named_params<P, T, R>& params = all defaults);\n\n\n// dijkstra\ntemplate <typename Graph, typename P, typename T, typename R>\nvoid\ndijkstra_shortest_paths(Graph& g,\n  typename graph_traits<Graph>::vertex_descriptor s,\n  const bgl_named_params<P, T, R>& params);\n\n\n//r_c_shortest_paths\nr_c_shortest_paths( g,\n                    vertex_index_map,\n                    edge_index_map,\n                    s,\n                    t,\n                    pareto_optimal_solutions,\n                    pareto_optimal_resource_containers,\n                    rc,\n                    ref,\n                    dominance,\n                    la,\n                    vis )\n\n    return 0;\n}\n```\n\n\n\n\nsummary: dont know how to get all the shorttest paths and save it for compare\n\nI turn here because I can not get it out after several hours\n\nthank you, greetings and sorry for my bad english\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Different shortest path for each test\r\n                \r\nI'm writing a program counting average delay in given network. I use a JUNG library. On input my program reads information how many packets vertex x want to send to vertex y for second. My graph is unweighted and I assume that packets are sending by shortest path.\n\nI use JUNG methods to get shortest path:\n\n```\npublic class NetworkGraph {\n\n    protected final Graph graph;\n\n    protected Vertex[] vertices;\n    protected Random random;\n    protected double sumOfFlowStrengthMatrix;\n\n    protected final int[][] flowStrengthMatrix;\n\n\n\n    NetworkGraph(Input input, Graph graph) {\n        random = new Random();\n        this.graph = graph;\n\n        loadVertices(input);\n        loadEdges(input);\n        loadSumOfFlowStrengthMatrix(input);\n        flowStrengthMatrix = input.getFlowStrengthMatrix();\n    }\n\n    private void loadVertices(Input input) {\n        vertices = new Vertex[input.getNumberOfVertices()];\n\n        for (int i = 0; i < input.getNumberOfVertices(); i++) {\n            vertices[i] = new Vertex(i + 1);\n            graph.addVertex(vertices[i]);\n        }\n    }\n\n    private void loadEdges(Input input) {\n        for (int i = 0; i < input.getNumberOfVertices(); i++) {\n            for (int j = 0; j < input.getNumberOfVertices(); j++) {\n                if (input.getProbabilityOfDivulsionArray()[i][j] != 0) {\n                    if (graph.findEdge(vertices[i], vertices[j]) == null) {\n                        graph.addEdge(new Edge(input.getCapacityArray()[i][j], input.getProbabilityOfDivulsionArray()[i][j]), vertices[i], vertices[j]);\n                    }\n                }\n            }\n        }\n    }\n\n    private void loadSumOfFlowStrengthMatrix(Input input) {\n        double sum = 0;\n\n        for (int i = 0; i < input.getNumberOfVertices(); i++) {\n            for (int j = 0; j < input.getNumberOfVertices(); j++) {\n                sum += input.getFlowStrengthMatrix()[i][j];\n            }\n        }\n\n        this.sumOfFlowStrengthMatrix = sum;\n    }\n\n\n    public double countAveragePacketDelayInNetwork() throws EdgeException {\n        double out = 0;\n        ArrayList<Edge> edges = new ArrayList<>(graph.getEdges());\n\n        recountFlows();\n\n        for (Edge e : edges) {\n            out += e.getAveragePacketDelay();\n        }\n\n        return round((out / sumOfFlowStrengthMatrix), 4);\n    }\n\n    protected void recountFlows() {\n        for (int i = 0; i < vertices.length; i++) {\n            for (int j = 0; j < vertices.length; j++) {\n                DijkstraShortestPath<Vertex, Edge> algorithm = new DijkstraShortestPath<>(graph);\n                List<Edge> edges = algorithm.getPath(vertices[i], vertices[j]);\n\n                for (Edge edge : edges) {\n                    edge.addToFlowStrength(flowStrengthMatrix[i][j]);\n                }\n            }\n        }\n    }\n}\n```\n\n\nI ran my program several times with the same sample graph. Unfortunately I got a different results - for each time I have different average delay - it's really annoying.\n\nProbably it's caused by Dijkstra algorithm - I noticed that Dijkstra algorithm returns different results for the same input. I know that it can be many shortest path from x to y, but why Dijkstra algorithm returns different paths when the input and way of creating graph is exactly the same every time? \n\nIs there any way to make this algorithm returns always the same shortest path for given x and y?\n    ", "Answer": "\r\nAs Tony_craft said, we lack enough information about how the graph is built that a definitive answer is not possible.\n\nHowever, there are two basic reasons why you might be getting different paths each time:\n(1) The graph is not the same each time.\n(2) The edges are being iterated over in a different order and you're getting a different edge of the same weight.  Order of iteration over a Set (of outgoing edges) is not guaranteed to be consistent.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Neo4j search for second shortest path\r\n                \r\nWe know that we can get the shortest path between nodes by the following statement\n\n```\nMATCH p=allShortestPaths((a)-[*]->(b))\n```\n\n\nIs there any way to search for the second shortest path without exhaustive search?\n    ", "Answer": "\r\nThere's no way to specify something like second shortest path via ```\nshortestPath()```\n or ```\nallShortestPaths()```\n. However: You could search for all paths, ordered by path length, and just limit the depth and number of items returned. For example:\n\n```\nMATCH p =(a)-[*2..5]-(b)\nRETURN p, length(p)\norder by length(p)\nLIMIT 5;\n```\n\n\nYou'd have to fine-tune this based on your knowledge of the domain (such as min # and max # of relationship hops). And you can further optimize with the addition of labels and relationship types.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Finding a shortest path that passes through some arbitrary sequence of nodes?\r\n                \r\nIn this earlier question the OP asked how to find a shortest path in a graph that goes from u to v and also passes through some node w.  The accepted answer, which is quite good, was to run Dijkstra's algorithm twice - once to get from u to w and once to get from w to v.  This has time complexity equal to two calls to Dijkstra's algorithm, which is O(m + n log n).\n\nNow consider a related question - you are given a sequence of nodes u1, u2, ..., uk and want to find the shortest path from u1 to uk such that the path passes through u1, u2, ..., uk in order.  Clearly this could be done by running k-1 instances of Dijkstra's algorithm, one for each pair of adjacent vertices, then concatenating the shortest paths together.  This takes time O(km + k n log n).  Alternatively, you could use an all-pairs shortest paths algorithm like Johnson's algorithm to compute all shortest paths, then concatenate the appropriate shortest paths together in O(mn + n2 log n) time, which is good for k much larger than n.\n\nMy question is whether there is an algorithm for solving this problem that is faster than the above approaches when k is small.  Does such an algorithm exist?  Or is iterated Dijkstra's as good as it gets?\n    ", "Answer": "\r\nRather than running isolated instances of Dijkstra's algorithm to find the paths ```\nu(k) -> u(k+1)```\n one path at a time, can a single instance of a modified Dijkstra-like search be started at each node in the sequence simultaneously, with the paths formed when search regions meet \"in-the-middle\".\n\nThis would potentially cut down on the total number of edges visited and reduce re-traversal of edges compared to making a series of isolated calls to Dijkstra's algorithm.\n\nAn easy example would be finding the path between two nodes. It would be better to expand the search regions about both nodes than just expanding about one. In the case of a uniform graph, the second option would give a search region with radius equal to the distance between the nodes, the first option would give two regions of half the radius - less overall search area.\n\nJust a thought.\n\nEDIT: I guess I'm talking about a multi-directional variant of a bi-directional search, with as many directions as there are nodes in the sequence ```\n{u(1), u(2), ..., u(m)}```\n.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How to get all the shortest paths of the length of the diameter for iGraph object?\r\n                \r\nI want to get all the longest shortest paths for iGraph object. There is this function \n\n```\nget.diameter (graph, directed = TRUE, unconnected = TRUE) \n```\n\n\nBut it returns only one path. So if there are many shortest paths of the length of the diameter, then it returns the first one found\n    ", "Answer": "\r\nYou can easily extract which nodes are connected at what lengths using the shortest-distance matrix returned by shortest.paths(graph). In R, you can use ```\nwhich()```\n and ```\narr.ind=TRUE```\n like so:\n\n```\nlongest.shortest.paths <- function(graph){\n    # Return edgelist of all node-pairs between which the shortest path\n    # in a graph are the longest shortest path observed in that graph.\n\n    # Get all the shortest paths of a graph\n    shortest.paths = shortest.paths(graph)\n\n    # Make sure that there are no Inf-values caused by isolates in the graph\n    shortest.paths[shortest.paths == Inf] <- 0\n\n    # What nodes in the distance matrix are linked by longest shortest paths?\n    el <- which(shortest.paths==max(shortest.paths), arr.ind=TRUE)\n    colnames(el) <- c(\"i\",\"j\")\n    (el)\n}\n\ngraph <- erdos.renyi.game(100, 140, \"gnm\", directed=FALSE)\nlongest.shortest.paths(graph)\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Multiple source and multiple target shortest path problem\r\n                \r\nI'm trying to figure out the most optimal way to get the shortest paths from all the source nodes to any one of the target nodes that leads to the minimum weight in a weighted graph. All nodes are either a source node or a target node. So figure we have a graph consisting of A, B, C as source nodes and D, E, F as target nodes. A, B, C has to find the shortest path to any one of the target nodes that happens to have the shortest path.\nThe naive solution is to use the Dijkstra's algorithm or something similar to first find the shortest path from A to D and then from A to E etc. and then comparing the final weight of each of those shortest paths to see which is actually the shortest. I want to know if there is a more efficient solution to this.\n    ", "Answer": "\r\nAdd a new node that leads to all the sources (make these new edges 0-weight), and run Dijkstra's from the new node.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Finding shortest path\r\n                \r\nI have a set of points in a graph. I want to find the shortest path connecting a subset of this graph using lines which are either horizontal, vertical or at 45 degree left or right. Can anybody suggest an algorithm to do this?\n    ", "Answer": "\r\nI think you need to modify the solution for Rectilinear minimum steniar tree problem. \n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest paths that are impossible for BFS to find?\r\n                \r\nI took an exam earlier and there was a question that baffled me and everyone else I talked to. It asked the following:\n\n\n  Give an example of an unweighted graph G and two vertices s and f such that there is a shortest path between s and f that breadth-first search (beginning at s) will never find, regardless of the order it visits the vertices adjacent to a particular edge.\n\n\nTo us, this seems impossible. My first thought was that if a shortest path contained a vertex as its nth step that could be reached in m steps from s, where m<n, then that path will never be found by BFS because the vertex will have already been marked as visited. But if that were the case, said path would not be a shortest path at all, since there would be a shorter path obtained by getting to the vertex in m steps and then continuing on as normal. \n\nDid our professor pose an impossible question (perhaps as a typo), or am I missing something?\n\nEDIT: To clear up any possible ambiguity, the question does not ask to give an example where BFS fails to find a shortest path from s to f. Rather, it asks to give an example where there exists some shortest path from s to f that BFS will never find. So the fact that BFS is complete and optimal alone does not preclude this possibility, unless I misunderstand the meaning of the terms.\n\nEDIT 2: It may be assumed also that the BFS algorithm we are working with will not process the same node twice. See, for example, the algorithm outline on the BFS Wiki.\n    ", "Answer": "\r\nThe Example\nLet ```\nG = (V,E)```\n a graph with\n```\nV = ℕ ∪ {-1, 0}```\n and ```\nE = { {-1,t}, {t,0} | t ∈ ℕ }```\n\nand let ```\ns = -1```\n and ```\nf = 0```\n. There exist an infinite number of paths of length 2 from ```\ns```\n to ```\nf```\n, but since ```\ns```\n has an infinite number of neighbors, BFS will never come to ```\nf```\n.\nNo finite examples possible\nThere exists no finite graph, such that BFS does not find the shortest path from ```\ns```\n to ```\nf```\n. Lets say ```\nG```\n is a finite graph and ```\ns = a₀ → a₁ → ... → an → an+1 = f```\n is a shortest path from ```\ns```\n to ```\nf```\n. Then exist an execution order of BFS that looks like this:\n\nFor all ```\ni```\n from ```\n0```\n to ```\nn```\n visit ```\nai+1```\n first and then all other direct neighbors of ```\nai```\n.\n\nSince ```\nG```\n is a finite graph there exist also only finite many direct neighbors of each node ```\nai```\n. So it will finish the listing and come to the next node on the path. Since the path is a shortest one, it is the first one that is found to connect ```\ns```\n and ```\nf```\n. So there cannot  exist a finite graph such that BFS does not find the shortest path from ```\ns```\n to ```\nf```\n.\nPaths cannot be shorter than two edges\nThere can also be no example with a path from ```\ns```\n to ```\nf```\n shorter than 2.\nThe shortest path one can think of would be of length 1, if ```\ns```\n and ```\nf```\n are considered not to be the same node. But this means that ```\nf```\n is an direct neighbor of ```\ns```\n and so there exists a BFS that visits ```\nf```\n first and after that goes on with the infinite number of other neighbors.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Number of shortest paths exponential to the number of nodes (Dijkstra)\r\n                \r\nI was asked to figure out a kind of graph whose total number of shortest paths (using Dijkstra's algorithm) is exponential to the number of nodes.\nI came up with a graph like that:\n\nA->B->C (each edge with weight 1)\nA->C (edge with weight 2)\n\nC->A'->B' (weight=1 for all edges)\nC->B' (weight = 2)\n\nB'->A''->B'' (weight=1 for all edges)\nB'->B'' (weight = 2)\n\nAnd so on...\n\nThis way, the total number of shortest paths found by Dijkstra's algorithm for this graph would be Ω(2^(n/2)). \nI'm now trying to figure out, if it can be generalized in something like Ω(2^(n/k)), where k = number of shortest paths per node. I also still don't know, how I can properly prove the correctness of the solution. Any advice or hint very appreciated!\nI also would appreciate if you would point out any existing flaw in my solution.\n\nThanks in advance!\n    ", "Answer": "\r\nYour solution is a good starting point. The number of solution can be doubled that way for every few nodes you add. However, I do not immediately see how every node would have about the same amount of shortest paths. This could lead to an average that is lower, which would nullify your proposal.\n\nTo solve that problem, you can make 2 slight adjustments to your graph: make it cyclical and add some more links. \n\nmake it cyclical:\nYou should connect your starting node with your last node. This would make every node in the graph equal so all of them have the same number of shortest paths.\n\nadd some more links: \nIn your example you give node A a link to node B and a link to node C. You should also give node B a link to node C (already ok) and a link to node A'. This equal to eachother.\n\nTo prove the correctness, you can now calculate the number of distinct path for 1 node to all other nodes and that's a valid result for all nodes in the graph (which is why they should be equal). To prove the exponentiality, you could look at what happens if you add more nodes to your graph and how that impacts the number of solutions.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest Path Between two vertexes\r\n                \r\nI got a graph, and asks me to find the shortest path between two vertices. We have to visit all of the vertices, or if we reach the destination vertex without visiting all the other vertices is correct?\nThanks, and sorry for the incovenience.\n\nThis is the graph:\ngraph\n\nAnd the question is: \nApply the shortest path algorithm to find the shortest path from A to G.\n    ", "Answer": "\r\nThe usual strategy for the shortest path between two vertices in an unweighted graph is a Breadth-First Search (BFS), which visits every node of distance 1 from the starting point, then every node of distance 2... until it finds the target vertex.\n\nThe premise is simple: by visiting every node of increasing distance from the starting point, the path to the ending point must be the shortest possible path, because otherwise you would have found it previously.  As a more concrete example: if the first path you find is distance 4, that must be the shortest path, because you've already checked all paths of distance 3 or less.\n\nThus, to find the shortest path between two vertices in an unweighted graph, you conduct a BFS until you find the target vertex, then backtrack to the starting vertex, tracking the nodes you traverse.  This is guaranteed to be the shortest path (or tied for the shortest path).\n\nIf the graph is weighted (you do not specify), then you must traverse every possible path to the target node, not just the one passing through the fewest vertices.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "networkx shortest path from a path to vertex\r\n                \r\nI am using netwrokx to calculate the shortest path between different vertices using Dijkstra algorithm. I have a case where I want to connect three different vertices (for example A, B and C in an undirected graph). First I find the shortest path from A to B and then I want to find the shortest path from the path of A to B. What I have tried so far is I have calculate shortest path length from all the nodes of the A to B path to C and then I calculate the shortest path from the node which gives the minimum path length. This is computationally intensive as path may have up to 200 to 300 nodes.\n\nCan anyone give me a hint how can I improve approach? or easier way to find the shortest path from the already existing edges to the target ?\n    ", "Answer": "\r\nAdd a new node, ```\n'auxiliary'```\n to your graph.  For each node ```\nu```\n in the ```\nA```\n-```\nB```\n path, add an edge from ```\nu```\n to ```\n'auxiliary'```\n.\n\nFind the shortest path from ```\nC```\n to ```\n'auxiliary'```\n.  Truncate that path by removing the final node ```\n'auxiliary'```\n.  This is now the shortest path from ```\nC```\n to that path.\n\nMore generally, this approach works whenever you want to find the shortest path from a node to a set of nodes and (with a bit of generalization) it finds the shortest path from one set of nodes to another set.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "shortest path or route algorithm [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Questions asking for code must demonstrate a minimal understanding of the problem being solved. Include attempted solutions, why they didn't work, and the expected results. See also: Stack Overflow question checklist\r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nThere are pre-defined routes.\n\n```\nRoute1 [Edirne (1)-Kırklareli (2)-Istanbul (3)]\nRoute2 [Istanbul (3) - Sakarya (4) - Zonguldak (5)]\nRoute3 [Istanbul (3) - Kutahya (6) - Afyon(7)]\nRoute4 [Afyon(7) - Isparta (8) - Anatlya(9)]\n```\n\n\nEvery route has a vehicle which traverses on it.\n\nFor example, if some goods will be sent from Edirne(1) to Antalya(9) Route1-Route3-Route4 must be chosen.\n\nIf the case is Zonguldak to Edirne Route1-Route2 must be choosen.\n\netc..\n\nShortest path algorithms based on distances between steps and find the \"shortest path\" not route. Because my locations are in routes, shortest path algorithms are not the correct method for me for this situation. Any ideas on how to solve this problem, || Does anyone have a suggestion?\n    ", "Answer": "\r\nShortest Path still applies; you just need to change your thinking. Rather than include edges between every city on your route, translate Route 1 into Vertices at Edirne and Istanbul and a single edge between them (weighted to your route length). Ignore the fact that it goes through Kirklareli. \n\nDo the same for your other routes and you'll have something like \n\n```\nEdirne--1--Istanbul--2--Zonguldak\n               |\n               3 \n               |\n             Afyon--4--Anatlya\n```\n\n\nThen you can apply a shortest path and you'll find that Edirne to Anatlya is 1-3-4, which you then translate back into the full route (Edirne - Kırklareli - Istanbul - Isparta - Anatlya)\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Bidirectional A* (A-Star) Not Returning the Shortest Path\r\n                \r\nFor some reason, my implementation of bidirectional A* isn't returning the shortest path in very specific initializations of the graph. \n\nI'm running two A* searches, one from the source to the destination, and one from the destination to the source. From what I've read, when the closed sets for both of these searches intersect, then we've connected the shortest paths from both searches and have found the shortest path.\n\nThe problem is, in very specific situations, the closed sets for both searches are intersecting before the searches can actually discover the nodes which should be included in their respective shortest paths. This means A* doesn't get to explore enough nodes to find the shortest path.\n\nIs this intersection condition the right way to go about things, or is there a different condition I should be using to figure out when to stop both searches?\n\nYou can run my code here: https://jasperhuangg.github.io/pathfinding-visualizer. \n\nThe cases where this problem occurs are certain (not all) situations when both walls and weights have been placed on the grid.\n\nHere is the code if it helps, sorry if it is very messy!:\n\n```\nasync function bidirectionalAStar(graph, startNode, finishNode) {\n  recolorGrid();\n  searching = true;\n\n  const infinity = Number.MAX_VALUE;\n  var openSource = [];\n  var openDest = [];\n  var closedSource = [];\n  var closedDest = [];\n\n  var numSteps = -3; // -2 for both start and finish nodes + -1 for overlapping connecting node\n\n  $(\"#steps-taken\").html(\"Cells Examined: \" + numSteps);\n\n  const startX = startNode.x;\n  const startY = startNode.y;\n\n  const finishX = finishNode.x;\n  const finishY = finishNode.y;\n\n  var bidirectionalAStarGraph = shallowCopyGraph(graph, []);\n\n  // initialize all nodes to dist infinity from the startNode\n  for (let i = 0; i < bidirectionalAStarGraph.length; i++) {\n    for (let j = 0; j < bidirectionalAStarGraph[i].length; j++) {\n      bidirectionalAStarGraph[i][j].fSrc = infinity;\n      bidirectionalAStarGraph[i][j].gSrc = infinity;\n      bidirectionalAStarGraph[i][j].hSrc = infinity;\n      bidirectionalAStarGraph[i][j].fDest = infinity;\n      bidirectionalAStarGraph[i][j].gDest = infinity;\n      bidirectionalAStarGraph[i][j].hDest = infinity;\n      bidirectionalAStarGraph[i][j].setSource = \"neither\";\n      bidirectionalAStarGraph[i][j].setDest = \"neither\";\n    }\n  }\n\n  // initialize start/finish node distance from start/finish to 0\n  bidirectionalAStarGraph[startX][startY].fSrc = 0;\n  bidirectionalAStarGraph[startX][startY].gSrc = 0;\n  bidirectionalAStarGraph[startX][startY].hSrc = 0;\n  bidirectionalAStarGraph[startX][startY].setSource = \"open\";\n  openSource.push(bidirectionalAStarGraph[startX][startY]);\n\n  bidirectionalAStarGraph[finishX][finishY].fDest = 0;\n  bidirectionalAStarGraph[finishX][finishY].gDest = 0;\n  bidirectionalAStarGraph[finishX][finishY].hDest = 0;\n  bidirectionalAStarGraph[finishX][finishY].setDest = \"open\";\n  openDest.push(bidirectionalAStarGraph[finishX][finishY]);\n\n  var lastNodeSource;\n  var lastNodeDest;\n\n  while (openSource.length > 0 && openDest.length > 0) {\n    openSource.sort((a, b) => {\n      if (a.fSrc !== b.fSrc) return a.fSrc - b.fSrc;\n      else return a.hSrc - b.hSrc;\n    });\n    openDest.sort((a, b) => {\n      if (a.fDest !== b.fDest) return a.fDest - b.fDest;\n      else return a.hDest - b.hDest;\n    });\n\n    var currNodeSource = openSource.shift();\n    var currNodeDest = openDest.shift();\n\n    $(\".currentNodeGray\").removeClass(\"currentNodeGray\");\n    $(\".currentNodeSunset\").removeClass(\"currentNodeSunset\");\n    $(\".currentNodeOcean\").removeClass(\"currentNodeOcean\");\n    $(\".currentNodeChaos\").removeClass(\"currentNodeChaos\");\n    $(\".currentNodeGreen\").removeClass(\"currentNodeGreen\");\n    $(\".currentNodeCottonCandy\").removeClass(\"currentNodeCottonCandy\");\n\n    if (checkIntersection(closedSource, closedDest)) {\n      break; // the paths have reached each other\n    }\n    numSteps += 2;\n\n    $(\"#steps-taken\").html(\"Cells Examined: \" + numSteps);\n\n    currNodeSource.setSource = \"closed\";\n    currNodeDest.setDest = \"closed\";\n    closedSource.push(currNodeSource);\n    closedDest.push(currNodeDest);\n\n    colorNode(currNodeSource, \"currentNode\");\n    colorNode(currNodeDest, \"currentNode\");\n    if (lastNodeSource !== undefined && currentSpeed !== \"instantaneous\")\n      colorNode(lastNodeSource, \"visited\");\n    if (lastNodeDest !== undefined && currentSpeed !== \"instantaneous\")\n      colorNode(lastNodeDest, \"visited\");\n\n    if (currentSpeed === \"fast\") await sleep(20);\n    else if (currentSpeed === \"medium\") await sleep(180);\n    else if (currentSpeed === \"slow\") await sleep(500);\n\n    var validNeighborsSource = [];\n    var validNeighborsDest = [];\n    var left = currNodeSource.x - 1;\n    var right = currNodeSource.x + 1;\n    var up = currNodeSource.y - 1;\n    var down = currNodeSource.y + 1;\n\n    // consider all of the current node's (from source) valid neighbors\n    if (left >= 0 && !bidirectionalAStarGraph[left][currNodeSource.y].blocked) {\n      validNeighborsSource.push(\n        bidirectionalAStarGraph[left][currNodeSource.y]\n      );\n    }\n    if (\n      right < grid_width &&\n      !bidirectionalAStarGraph[right][currNodeSource.y].blocked\n    ) {\n      validNeighborsSource.push(\n        bidirectionalAStarGraph[right][currNodeSource.y]\n      );\n    }\n    if (up >= 0 && !bidirectionalAStarGraph[currNodeSource.x][up].blocked) {\n      validNeighborsSource.push(bidirectionalAStarGraph[currNodeSource.x][up]);\n    }\n    if (\n      down < grid_height &&\n      !bidirectionalAStarGraph[currNodeSource.x][down].blocked\n    ) {\n      validNeighborsSource.push(\n        bidirectionalAStarGraph[currNodeSource.x][down]\n      );\n    }\n\n    left = currNodeDest.x - 1;\n    right = currNodeDest.x + 1;\n    up = currNodeDest.y - 1;\n    down = currNodeDest.y + 1;\n\n    // consider all of the current node's (from dest) valid neighbors\n    if (left >= 0 && !bidirectionalAStarGraph[left][currNodeDest.y].blocked) {\n      validNeighborsDest.push(bidirectionalAStarGraph[left][currNodeDest.y]);\n    }\n    if (\n      right < grid_width &&\n      !bidirectionalAStarGraph[right][currNodeDest.y].blocked\n    ) {\n      validNeighborsDest.push(bidirectionalAStarGraph[right][currNodeDest.y]);\n    }\n    if (up >= 0 && !bidirectionalAStarGraph[currNodeDest.x][up].blocked) {\n      validNeighborsDest.push(bidirectionalAStarGraph[currNodeDest.x][up]);\n    }\n    if (\n      down < grid_height &&\n      !bidirectionalAStarGraph[currNodeDest.x][down].blocked\n    ) {\n      validNeighborsDest.push(bidirectionalAStarGraph[currNodeDest.x][down]);\n    }\n\n    // UPDATE NEIGHBORS FROM SOURCE\n    for (let i = 0; i < validNeighborsSource.length; i++) {\n      let neighbor = validNeighborsSource[i];\n\n      if (neighbor.setSource === \"closed\") continue;\n\n      let cost = 0;\n      if (currNodeSource.weighted === true || neighbor.weighted === true)\n        cost = currNodeSource.gSrc + 10;\n      else cost = currNodeSource.gSrc + 1;\n\n      if (neighbor.setSource === \"open\" && cost < neighbor.gSrc) {\n        neighbor.setSource = \"neither\";\n        neighbor.gSrc = cost;\n        neighbor.fSrc = neighbor.gSrc + neighbor.hSrc;\n        openSource.remove(neighbor);\n      }\n      if (neighbor.setSource === \"neither\") {\n        openSource.push(neighbor);\n        neighbor.setSource = \"open\";\n        neighbor.gSrc = cost;\n        neighbor.hSrc = calculateHeuristic(neighbor, finishNode);\n        neighbor.fSrc = neighbor.gSrc + neighbor.hSrc;\n        neighbor.predecessorSource = currNodeSource;\n      }\n    }\n    lastNodeSource = currNodeSource;\n\n    // UPDATE NEIGHBORS FROM DEST\n    for (let i = 0; i < validNeighborsDest.length; i++) {\n      let neighbor = validNeighborsDest[i];\n\n      if (neighbor.setDest === \"closed\") continue;\n\n      let cost = 0;\n      if (currNodeDest.weighted === true || neighbor.weighted === true)\n        cost = currNodeDest.gDest + 10;\n      else cost = currNodeDest.gDest + 1;\n\n      if (neighbor.setDest === \"open\" && cost < neighbor.gDest) {\n        neighbor.setDest = \"neither\";\n        neighbor.gDest = cost;\n        neighbor.fDest = neighbor.gDest + neighbor.hDest;\n        openDest.remove(neighbor);\n      }\n      if (neighbor.setDest === \"neither\") {\n        openDest.push(neighbor);\n        neighbor.setDest = \"open\";\n        neighbor.gDest = cost;\n        neighbor.hDest = calculateHeuristic(neighbor, startNode);\n        neighbor.fDest = neighbor.gDest + neighbor.hDest;\n        neighbor.predecessorDest = currNodeDest;\n      }\n    }\n    lastNodeDest = currNodeDest;\n  }\n```\n\n    ", "Answer": "\r\nWithout any code I can't identify any specific bugs in your algorithm but the thing about Bidirectional A* is that it is only as good as your A*.\n\nA* is flexible in that it is capable of acting just like a dumb breadth first search and just like a dumb depth first search - usually it's somewhere in the middle, and that \"middle\" is defined by the quality of your heuristic.\n\nAdding a second A* on the other side is a good way to \"speed up\" an A* heuristic that leans towards breadth, but, it won't \"fix\" a heuristic that leans towards depth.\n\nIf you want a guarantee that your Bidirectional A* search will always find the shortest possible path, then your heuristic needs to lean towards breadth.  (Usually this is done by estimating the heuristic - the imagined cost of a node to explore as the Manhattan distance to the target plus the distance traveled to that node.  Then sort the nodes and toss nodes more than 1.5x the lowest node -- 1.5 being a variable you can play with, too high and you'll do a traditional breadth first and too low and you might toss the actual lowest path, if it's a complicated one.)\n\nSorry for the vagueness, some code snippets might help give more direction!\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Graph with colored edges: shortest paths with at most k color changes?\r\n                \r\nI have a directed graph with coloured, weighted edges. There are 2 colours. Each edge can have only 1 colour. I want to find shortest path with limited changes of colours. From one vertex there can be max 2 edges with 2 different colors going out and 2 edges with 2 different colors going in.\n\nFor example in this graph:\n\n\n\nShortest path with maximum of 3 colour changes will be ```\n9```\n\nWith max ```\n0```\n colour changes shortest path is ```\n6+1+4=11```\n, etc.\n\nMy solution is to recursively visit all possible paths and exchange if recursion find a better one which makes this problem exponential.\n\nIs there a non-exponential solution to this problem?\n    ", "Answer": "\r\nThis can be solved in time O(nm + n2 log n) by running Dijkstra's algorithm on an appropriately-constructed graph.\n\nTo motivate the intuition for where we're going, let's assume for now that the optimal path makes at most one color change and starts by following a red edge. The path therefore either follows no blue edges, in which case we only follow red edges, or it follows some number of red edges, then some number of blue edges.\n\nThink about what happens if you transform G as follows:\n\n\nBegin by copying the nodes in the graph twice to give two layers G0 and G1. We'll denote the copy of node v in G0 as v0 and the copy of node v in G1 as v1.\nFor each blue edge (u0, v0), replace that edge with the edge (u0, v1).\nDelete all red edges from G1.\n\n\nYou can think of this graph as two copies of G stacked on top of one another with some tweaks to the edges. Specifically, edges running inside of G0 are all red, and the blue edges take you down to G1. There are then no red edges in G1.\n\nThink about what a path in this graph looks like. If you stay purely in G0, it consists only of red edges. If you start in G0 and end up in G1, then the path starts of by following some number of red edges, then at least one blue edge, and then some larger number of blue edges. Therefore, any path in this graph will have exactly one color change involved.\n\nYou can use this graph to find the shortest path from a node u to a node v that makes at most one color change. Start by running Dijkstra's algorithm starting at u, and look at the distances of v0 and v1. The distance to v0 is the length of the shortest path to v0 that makes no color changes. The distance to v1 is the length of the shortest path to v1 that makes at most one color change. The shorter of these two distances then gives you the length of the shortest path from u to v that makes at most one color change.\n\nWe can extend this trick to work for any number of steps k as follows. Create k copies of G, called G0, G1, G2, ..., G(k-1). Assuming the path starts with a red edge, we can then change the graph as follows. Make all blue edges in G0 instead run from G0 to G1. Then, make all red edges in G1 run from G1 to G2. Then, make all blue edges in G2 run from G2 to G3, etc. Finally, delete all edges out of G(k-1) that are not of the color leading into G(k-1). This graph maintains the same property as before - any path from a node u0 to a node v_r represents a path from u to v that makes exactly r color changes, assuming the first edge is red. The best path making at most r color changes can then be found by looking at the lowest cost of the paths to v_0, v_1, ..., v_(k-1).\n\nThis approach so far assumes that the first step is red, but we're not guaranteed that's the case. But that's okay - we can run this algorithm once assuming the first step is red and once assuming the first step is blue and take the best of both options.\n\nSo how expensive is this? Well, if we get at most k color changes, the graph we construct will have a total of O(nk) nodes and O(mk) edges, so constructing it will take time O(k(m + n)). Running Dijkstra's in the graph to find the shortest paths to all the destination nodes then takes time O(mk + nk log nk), so the total runtime is O(mk + nk log nk).\n\nWe can actually upper-bound this at O(mn + n2 log n) for the following reason: since all edges have strictly positive weight, we know that no path can make more than n - 1 color changes. If a path did, it would have at least n edges in it, so it would have a cycle. That cycle has strictly positive cost, so we could improve the cost by eliminating the cycle. Therefore, if k ≥ n, we can just cap k at n. Plugging in k = n to the above expression gives the asymptotic runtime of O(mn + n2 log n).\n\nHope this helps!\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Bidirectional A* (A-Star) Not Returning the Shortest Path\r\n                \r\nFor some reason, my implementation of bidirectional A* isn't returning the shortest path in very specific initializations of the graph. \n\nI'm running two A* searches, one from the source to the destination, and one from the destination to the source. From what I've read, when the closed sets for both of these searches intersect, then we've connected the shortest paths from both searches and have found the shortest path.\n\nThe problem is, in very specific situations, the closed sets for both searches are intersecting before the searches can actually discover the nodes which should be included in their respective shortest paths. This means A* doesn't get to explore enough nodes to find the shortest path.\n\nIs this intersection condition the right way to go about things, or is there a different condition I should be using to figure out when to stop both searches?\n\nYou can run my code here: https://jasperhuangg.github.io/pathfinding-visualizer. \n\nThe cases where this problem occurs are certain (not all) situations when both walls and weights have been placed on the grid.\n\nHere is the code if it helps, sorry if it is very messy!:\n\n```\nasync function bidirectionalAStar(graph, startNode, finishNode) {\n  recolorGrid();\n  searching = true;\n\n  const infinity = Number.MAX_VALUE;\n  var openSource = [];\n  var openDest = [];\n  var closedSource = [];\n  var closedDest = [];\n\n  var numSteps = -3; // -2 for both start and finish nodes + -1 for overlapping connecting node\n\n  $(\"#steps-taken\").html(\"Cells Examined: \" + numSteps);\n\n  const startX = startNode.x;\n  const startY = startNode.y;\n\n  const finishX = finishNode.x;\n  const finishY = finishNode.y;\n\n  var bidirectionalAStarGraph = shallowCopyGraph(graph, []);\n\n  // initialize all nodes to dist infinity from the startNode\n  for (let i = 0; i < bidirectionalAStarGraph.length; i++) {\n    for (let j = 0; j < bidirectionalAStarGraph[i].length; j++) {\n      bidirectionalAStarGraph[i][j].fSrc = infinity;\n      bidirectionalAStarGraph[i][j].gSrc = infinity;\n      bidirectionalAStarGraph[i][j].hSrc = infinity;\n      bidirectionalAStarGraph[i][j].fDest = infinity;\n      bidirectionalAStarGraph[i][j].gDest = infinity;\n      bidirectionalAStarGraph[i][j].hDest = infinity;\n      bidirectionalAStarGraph[i][j].setSource = \"neither\";\n      bidirectionalAStarGraph[i][j].setDest = \"neither\";\n    }\n  }\n\n  // initialize start/finish node distance from start/finish to 0\n  bidirectionalAStarGraph[startX][startY].fSrc = 0;\n  bidirectionalAStarGraph[startX][startY].gSrc = 0;\n  bidirectionalAStarGraph[startX][startY].hSrc = 0;\n  bidirectionalAStarGraph[startX][startY].setSource = \"open\";\n  openSource.push(bidirectionalAStarGraph[startX][startY]);\n\n  bidirectionalAStarGraph[finishX][finishY].fDest = 0;\n  bidirectionalAStarGraph[finishX][finishY].gDest = 0;\n  bidirectionalAStarGraph[finishX][finishY].hDest = 0;\n  bidirectionalAStarGraph[finishX][finishY].setDest = \"open\";\n  openDest.push(bidirectionalAStarGraph[finishX][finishY]);\n\n  var lastNodeSource;\n  var lastNodeDest;\n\n  while (openSource.length > 0 && openDest.length > 0) {\n    openSource.sort((a, b) => {\n      if (a.fSrc !== b.fSrc) return a.fSrc - b.fSrc;\n      else return a.hSrc - b.hSrc;\n    });\n    openDest.sort((a, b) => {\n      if (a.fDest !== b.fDest) return a.fDest - b.fDest;\n      else return a.hDest - b.hDest;\n    });\n\n    var currNodeSource = openSource.shift();\n    var currNodeDest = openDest.shift();\n\n    $(\".currentNodeGray\").removeClass(\"currentNodeGray\");\n    $(\".currentNodeSunset\").removeClass(\"currentNodeSunset\");\n    $(\".currentNodeOcean\").removeClass(\"currentNodeOcean\");\n    $(\".currentNodeChaos\").removeClass(\"currentNodeChaos\");\n    $(\".currentNodeGreen\").removeClass(\"currentNodeGreen\");\n    $(\".currentNodeCottonCandy\").removeClass(\"currentNodeCottonCandy\");\n\n    if (checkIntersection(closedSource, closedDest)) {\n      break; // the paths have reached each other\n    }\n    numSteps += 2;\n\n    $(\"#steps-taken\").html(\"Cells Examined: \" + numSteps);\n\n    currNodeSource.setSource = \"closed\";\n    currNodeDest.setDest = \"closed\";\n    closedSource.push(currNodeSource);\n    closedDest.push(currNodeDest);\n\n    colorNode(currNodeSource, \"currentNode\");\n    colorNode(currNodeDest, \"currentNode\");\n    if (lastNodeSource !== undefined && currentSpeed !== \"instantaneous\")\n      colorNode(lastNodeSource, \"visited\");\n    if (lastNodeDest !== undefined && currentSpeed !== \"instantaneous\")\n      colorNode(lastNodeDest, \"visited\");\n\n    if (currentSpeed === \"fast\") await sleep(20);\n    else if (currentSpeed === \"medium\") await sleep(180);\n    else if (currentSpeed === \"slow\") await sleep(500);\n\n    var validNeighborsSource = [];\n    var validNeighborsDest = [];\n    var left = currNodeSource.x - 1;\n    var right = currNodeSource.x + 1;\n    var up = currNodeSource.y - 1;\n    var down = currNodeSource.y + 1;\n\n    // consider all of the current node's (from source) valid neighbors\n    if (left >= 0 && !bidirectionalAStarGraph[left][currNodeSource.y].blocked) {\n      validNeighborsSource.push(\n        bidirectionalAStarGraph[left][currNodeSource.y]\n      );\n    }\n    if (\n      right < grid_width &&\n      !bidirectionalAStarGraph[right][currNodeSource.y].blocked\n    ) {\n      validNeighborsSource.push(\n        bidirectionalAStarGraph[right][currNodeSource.y]\n      );\n    }\n    if (up >= 0 && !bidirectionalAStarGraph[currNodeSource.x][up].blocked) {\n      validNeighborsSource.push(bidirectionalAStarGraph[currNodeSource.x][up]);\n    }\n    if (\n      down < grid_height &&\n      !bidirectionalAStarGraph[currNodeSource.x][down].blocked\n    ) {\n      validNeighborsSource.push(\n        bidirectionalAStarGraph[currNodeSource.x][down]\n      );\n    }\n\n    left = currNodeDest.x - 1;\n    right = currNodeDest.x + 1;\n    up = currNodeDest.y - 1;\n    down = currNodeDest.y + 1;\n\n    // consider all of the current node's (from dest) valid neighbors\n    if (left >= 0 && !bidirectionalAStarGraph[left][currNodeDest.y].blocked) {\n      validNeighborsDest.push(bidirectionalAStarGraph[left][currNodeDest.y]);\n    }\n    if (\n      right < grid_width &&\n      !bidirectionalAStarGraph[right][currNodeDest.y].blocked\n    ) {\n      validNeighborsDest.push(bidirectionalAStarGraph[right][currNodeDest.y]);\n    }\n    if (up >= 0 && !bidirectionalAStarGraph[currNodeDest.x][up].blocked) {\n      validNeighborsDest.push(bidirectionalAStarGraph[currNodeDest.x][up]);\n    }\n    if (\n      down < grid_height &&\n      !bidirectionalAStarGraph[currNodeDest.x][down].blocked\n    ) {\n      validNeighborsDest.push(bidirectionalAStarGraph[currNodeDest.x][down]);\n    }\n\n    // UPDATE NEIGHBORS FROM SOURCE\n    for (let i = 0; i < validNeighborsSource.length; i++) {\n      let neighbor = validNeighborsSource[i];\n\n      if (neighbor.setSource === \"closed\") continue;\n\n      let cost = 0;\n      if (currNodeSource.weighted === true || neighbor.weighted === true)\n        cost = currNodeSource.gSrc + 10;\n      else cost = currNodeSource.gSrc + 1;\n\n      if (neighbor.setSource === \"open\" && cost < neighbor.gSrc) {\n        neighbor.setSource = \"neither\";\n        neighbor.gSrc = cost;\n        neighbor.fSrc = neighbor.gSrc + neighbor.hSrc;\n        openSource.remove(neighbor);\n      }\n      if (neighbor.setSource === \"neither\") {\n        openSource.push(neighbor);\n        neighbor.setSource = \"open\";\n        neighbor.gSrc = cost;\n        neighbor.hSrc = calculateHeuristic(neighbor, finishNode);\n        neighbor.fSrc = neighbor.gSrc + neighbor.hSrc;\n        neighbor.predecessorSource = currNodeSource;\n      }\n    }\n    lastNodeSource = currNodeSource;\n\n    // UPDATE NEIGHBORS FROM DEST\n    for (let i = 0; i < validNeighborsDest.length; i++) {\n      let neighbor = validNeighborsDest[i];\n\n      if (neighbor.setDest === \"closed\") continue;\n\n      let cost = 0;\n      if (currNodeDest.weighted === true || neighbor.weighted === true)\n        cost = currNodeDest.gDest + 10;\n      else cost = currNodeDest.gDest + 1;\n\n      if (neighbor.setDest === \"open\" && cost < neighbor.gDest) {\n        neighbor.setDest = \"neither\";\n        neighbor.gDest = cost;\n        neighbor.fDest = neighbor.gDest + neighbor.hDest;\n        openDest.remove(neighbor);\n      }\n      if (neighbor.setDest === \"neither\") {\n        openDest.push(neighbor);\n        neighbor.setDest = \"open\";\n        neighbor.gDest = cost;\n        neighbor.hDest = calculateHeuristic(neighbor, startNode);\n        neighbor.fDest = neighbor.gDest + neighbor.hDest;\n        neighbor.predecessorDest = currNodeDest;\n      }\n    }\n    lastNodeDest = currNodeDest;\n  }\n```\n\n    ", "Answer": "\r\nWithout any code I can't identify any specific bugs in your algorithm but the thing about Bidirectional A* is that it is only as good as your A*.\n\nA* is flexible in that it is capable of acting just like a dumb breadth first search and just like a dumb depth first search - usually it's somewhere in the middle, and that \"middle\" is defined by the quality of your heuristic.\n\nAdding a second A* on the other side is a good way to \"speed up\" an A* heuristic that leans towards breadth, but, it won't \"fix\" a heuristic that leans towards depth.\n\nIf you want a guarantee that your Bidirectional A* search will always find the shortest possible path, then your heuristic needs to lean towards breadth.  (Usually this is done by estimating the heuristic - the imagined cost of a node to explore as the Manhattan distance to the target plus the distance traveled to that node.  Then sort the nodes and toss nodes more than 1.5x the lowest node -- 1.5 being a variable you can play with, too high and you'll do a traditional breadth first and too low and you might toss the actual lowest path, if it's a complicated one.)\n\nSorry for the vagueness, some code snippets might help give more direction!\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path direction in Android\r\n                \r\nI'm new in Google maps V2, i want to find the shortest path for my current location and the destination place. So, i tried some code and it works but it dose not draw the shortest path. i need a help please:\n\nHere is my code:\n\n```\ngps = new GPSTracker(ViewOnMap.this);\n\n// check if GPS enabled     \nif(gps.canGetLocation()){\n\n     latitude = gps.getLatitude();\n     longitude = gps.getLongitude();\n}\n                LatLng origin = new LatLng(latitude,longitude);\n                LatLng dest = new LatLng(lat,lon);\n\n                // Getting URL to the Google Directions API\n                String url = getDirectionsUrl(origin, dest);\n\n                DownloadTask downloadTask = new DownloadTask();\n\n                // Start downloading json data from Google Directions API\n                downloadTask.execute(url);\n\n}\n\n\n\n\n@Override\npublic boolean onCreateOptionsMenu(Menu menu) {\n    // Inflate the menu; this adds items to the action bar if it is present.\n    getMenuInflater().inflate(R.menu.view_on_map, menu);\n    return true;\n}\n\n@Override\npublic void onInfoWindowClick(Marker arg0) {\n    // TODO Auto-generated method stub\n\n}\n\n@Override\npublic void onLocationChanged(Location location) {\n    // TODO Auto-generated method stub\n     LatLng latLng = new LatLng(location.getLatitude(), location.getLongitude());\n        CameraUpdate cameraUpdate = CameraUpdateFactory.newLatLngZoom(latLng, 15);\n        mMap.animateCamera(cameraUpdate);\n        locationManager.removeUpdates(this);\n\n}\n\n@Override\npublic void onProviderDisabled(String arg0) {\n    // TODO Auto-generated method stub\n\n}\n\n@Override\npublic void onProviderEnabled(String provider) {\n    // TODO Auto-generated method stub\n\n}\n\n@Override\npublic void onStatusChanged(String provider, int status, Bundle extras) {\n    // TODO Auto-generated method stub\n\n}\n\nprivate String getDirectionsUrl(LatLng origin,LatLng dest){\n\n    // Origin of route\n    String str_origin = \"origin=\"+origin.latitude+\",\"+origin.longitude;\n\n    // Destination of route\n    String str_dest = \"destination=\"+dest.latitude+\",\"+dest.longitude;\n\n    // Sensor enabled\n    String sensor = \"sensor=false\";\n\n    // Building the parameters to the web service\n    String parameters = str_origin+\"&\"+str_dest+\"&\"+sensor;\n\n    // Output format\n    String output = \"json\";\n\n    // Building the url to the web service\n    String url = \"https://maps.googleapis.com/maps/api/directions/\"+output+\"?\"+parameters;\n\n    return url;\n}\n/** A method to download json data from url */\nprivate String downloadUrl(String strUrl) throws IOException{\n    String data = \"\";\n    InputStream iStream = null;\n    HttpURLConnection urlConnection = null;\n    try{\n        URL url = new URL(strUrl);\n\n        // Creating an http connection to communicate with url\n        urlConnection = (HttpURLConnection) url.openConnection();\n\n        // Connecting to url\n        urlConnection.connect();\n\n        // Reading data from url\n        iStream = urlConnection.getInputStream();\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(iStream));\n\n        StringBuffer sb = new StringBuffer();\n\n        String line = \"\";\n        while( ( line = br.readLine()) != null){\n            sb.append(line);\n        }\n\n        data = sb.toString();\n\n        br.close();\n\n    }catch(Exception e){\n        Log.d(\"Exception while downloading url\", e.toString());\n    }finally{\n        iStream.close();\n        urlConnection.disconnect();\n    }\n    return data;\n}\n\n// Fetches data from url passed\nprivate class DownloadTask extends AsyncTask<String, Void, String>{\n\n    // Downloading data in non-ui thread\n    @Override\n    protected String doInBackground(String... url) {\n\n        // For storing data from web service\n        String data = \"\";\n\n        try{\n            // Fetching the data from web service\n            data = downloadUrl(url[0]);\n        }catch(Exception e){\n            Log.d(\"Background Task\",e.toString());\n        }\n        return data;\n    }\n\n    // Executes in UI thread, after the execution of\n    // doInBackground()\n    @Override\n    protected void onPostExecute(String result) {\n        super.onPostExecute(result);\n\n        ParserTask parserTask = new ParserTask();\n\n        // Invokes the thread for parsing the JSON data\n        parserTask.execute(result);\n    }\n}\n\n/** A class to parse the Google Places in JSON format */\nprivate class ParserTask extends AsyncTask<String, Integer, List<List<HashMap<String,String>>> >{\n\n    // Parsing the data in non-ui thread\n    @Override\n    protected List<List<HashMap<String, String>>> doInBackground(String... jsonData) {\n\n        JSONObject jObject;\n        List<List<HashMap<String, String>>> routes = null;\n\n        try{\n            jObject = new JSONObject(jsonData[0]);\n            DirectionsJSONParser parser = new DirectionsJSONParser();\n\n            // Starts parsing data\n            routes = parser.parse(jObject);\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n        return routes;\n    }\n\n    // Executes in UI thread, after the parsing process\n    @Override\n    protected void onPostExecute(List<List<HashMap<String, String>>> result) {\n        ArrayList<LatLng> points = null;\n        PolylineOptions lineOptions = null;\n        MarkerOptions markerOptions = new MarkerOptions();\n\n        // Traversing through all the routes\n        for(int i=0;i<result.size();i++){\n            points = new ArrayList<LatLng>();\n            lineOptions = new PolylineOptions();\n\n            // Fetching i-th route\n            List<HashMap<String, String>> path = result.get(i);\n\n            // Fetching all the points in i-th route\n            for(int j=0;j<path.size();j++){\n                HashMap<String,String> point = path.get(j);\n\n                double lat = Double.parseDouble(point.get(\"lat\"));\n                double lng = Double.parseDouble(point.get(\"lng\"));\n                LatLng position = new LatLng(lat, lng);\n\n                points.add(position);\n            }\n\n            // Adding all the points in the route to LineOptions\n            lineOptions.addAll(points);\n            lineOptions.width(8);\n            lineOptions.color(Color.BLUE);\n        }\n\n        // Drawing polyline in the Google Map for the i-th route\n        mMap.addPolyline(lineOptions);\n    }\n}\n\n\n}\n```\n\n\nThank you in advance =)\n    ", "Answer": "\r\nLook here. And use:\n\n```\n...\nDirectonTask dirTask = new DirectonTask(this);\n        dirTask.execute(md.getUrl(new LatLng(loc1.getLatitude(), loc1.getLongitude()), \n                new LatLng(loc2.getLatitude(), loc2.getLongitude(),GMapV2Direction.MODE_DRIVING));\n...\n```\n\n\nand method calling after task completed\n\n```\nGMapV2Direction md = new GMapV2Direction();\n    Document doc;\n    Polyline currentPath;\n    public void drawDirection(Document doc) {\n        this.doc = doc;\n        ArrayList<LatLng> directionPoint = md.getDirection(doc);\n        PolylineOptions rectLine = new PolylineOptions().width(3).color(\n                Color.RED);\n\n        for (int i = 0; i < directionPoint.size(); i++) \n            rectLine.add(directionPoint.get(i));\n\n        map.addPolyline(rectLine);\n\n\n}\n```\n\n\nGMapV2Direction.java:\n\n```\npublic class GMapV2Direction {\npublic final static String MODE_DRIVING = \"driving\";\npublic final static String MODE_WALKING = \"walking\";\nprivate static final String TAG = \"google_map_GMapV2Direction\";\npublic GMapV2Direction() { }\n\npublic String getUrl(LatLng start, LatLng end, String mode){\n    String url = \"http://maps.googleapis.com/maps/api/directions/xml?\" \n            + \"origin=\" + start.latitude + \",\" + start.longitude  \n            + \"&destination=\" + end.latitude + \",\" + end.longitude \n            + \"&sensor=false&mode=\"+mode;\n    return url;\n}\npublic Document getDocument(LatLng start, LatLng end, String mode) {\n    String url = \"http://maps.googleapis.com/maps/api/directions/xml?\" \n            + \"origin=\" + start.latitude + \",\" + start.longitude  \n            + \"&destination=\" + end.latitude + \",\" + end.longitude \n            + \"&sensor=false&mode=\"+mode;\n\n    try {\n        LOG.d(TAG, \"url = \"+url);\n        HttpClient httpClient = new DefaultHttpClient();\n        HttpGet httpGet = new HttpGet(url);\n        HttpResponse response = httpClient.execute(httpGet);\n        InputStream in = response.getEntity().getContent();\n        DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n        Document doc = builder.parse(in);\n        return doc;\n    } catch (Exception e) {\n        e.printStackTrace();\n\n    }\n    return null;\n}\n\npublic String getDurationText (Document doc) {\n    NodeList nl1 = doc.getElementsByTagName(\"duration\");\n    Node node1 = nl1.item(nl1.getLength() - 1);\n    NodeList nl2 = node1.getChildNodes();\n    Node node2 = nl2.item(getNodeIndex(nl2, \"text\"));\n    LOG.i(TAG,\"DurationText: \"+ node2.getTextContent());\n    return node2.getTextContent();\n}\n\npublic int getDurationValue (Document doc) {\n    NodeList nl1 = doc.getElementsByTagName(\"duration\");\n    Node node1 = nl1.item(nl1.getLength() - 1);\n    NodeList nl2 = node1.getChildNodes();\n    Node node2 = nl2.item(getNodeIndex(nl2, \"value\"));\n    LOG.i(TAG,\"DurationValue: \"+ node2.getTextContent());\n    return Integer.parseInt(node2.getTextContent());\n}\n\npublic String getDistanceText (Document doc) {\n    NodeList nl1 = doc.getElementsByTagName(\"distance\");\n    Node node1 = nl1.item(nl1.getLength() - 1);\n    NodeList nl2 = node1.getChildNodes();\n    Node node2 = nl2.item(getNodeIndex(nl2, \"text\"));\n    LOG.i(TAG,\"DistanceText: \"+ node2.getTextContent());\n    return node2.getTextContent();\n}\n\npublic int getDistanceValue (Document doc) {\n    NodeList nl1 = doc.getElementsByTagName(\"distance\");\n    Node node1 = nl1.item(nl1.getLength() - 1);\n    NodeList nl2 = node1.getChildNodes();\n    Node node2 = nl2.item(getNodeIndex(nl2, \"value\"));\n    LOG.i(TAG,\"DistanceValue: \" +node2.getTextContent());\n    return Integer.parseInt(node2.getTextContent());\n}\n\npublic String getStartAddress (Document doc) {\n    NodeList nl1 = doc.getElementsByTagName(\"start_address\");\n    Node node1 = nl1.item(0);\n    LOG.i(TAG,\"StartAddress: \"+node1.getTextContent());\n    return node1.getTextContent();\n}\n\npublic String getEndAddress (Document doc) {\n    NodeList nl1 = doc.getElementsByTagName(\"end_address\");\n    Node node1 = nl1.item(0);\n    LOG.i(TAG,\"StartAddress: \"+node1.getTextContent());\n    return node1.getTextContent();\n}\n\npublic String getCopyRights (Document doc) {\n    NodeList nl1 = doc.getElementsByTagName(\"copyrights\");\n    Node node1 = nl1.item(0);\n    LOG.i(TAG,\"CopyRights: \"+node1.getTextContent());\n    return node1.getTextContent();\n}\n\npublic ArrayList<LatLng> getDirection (Document doc) {\n    NodeList nl1, nl2, nl3;\n    ArrayList<LatLng> listGeopoints = new ArrayList<LatLng>();\n    nl1 = doc.getElementsByTagName(\"step\");\n    if (nl1.getLength() > 0) {\n        for (int i = 0; i < nl1.getLength(); i++) {\n            Node node1 = nl1.item(i);\n            nl2 = node1.getChildNodes();\n\n            Node locationNode = nl2.item(getNodeIndex(nl2, \"start_location\"));\n            nl3 = locationNode.getChildNodes();\n            Node latNode = nl3.item(getNodeIndex(nl3, \"lat\"));\n            double lat = Double.parseDouble(latNode.getTextContent());\n            Node lngNode = nl3.item(getNodeIndex(nl3, \"lng\"));\n            double lng = Double.parseDouble(lngNode.getTextContent());\n            listGeopoints.add(new LatLng(lat, lng));\n\n            locationNode = nl2.item(getNodeIndex(nl2, \"polyline\"));\n            nl3 = locationNode.getChildNodes();\n            latNode = nl3.item(getNodeIndex(nl3, \"points\"));\n            ArrayList<LatLng> arr = decodePoly(latNode.getTextContent());\n            for(int j = 0 ; j < arr.size() ; j++) {\n                listGeopoints.add(new LatLng(arr.get(j).latitude, arr.get(j).longitude));\n            }\n\n            locationNode = nl2.item(getNodeIndex(nl2, \"end_location\"));\n            nl3 = locationNode.getChildNodes();\n            latNode = nl3.item(getNodeIndex(nl3, \"lat\"));\n            lat = Double.parseDouble(latNode.getTextContent());\n            lngNode = nl3.item(getNodeIndex(nl3, \"lng\"));\n            lng = Double.parseDouble(lngNode.getTextContent());\n            listGeopoints.add(new LatLng(lat, lng));\n        }\n    }\n\n    return listGeopoints;\n}\n\nprivate int getNodeIndex(NodeList nl, String nodename) {\n    for(int i = 0 ; i < nl.getLength() ; i++) {\n        if(nl.item(i).getNodeName().equals(nodename))\n            return i;\n    }\n    return -1;\n}\n\nprivate ArrayList<LatLng> decodePoly(String encoded) {\n    ArrayList<LatLng> poly = new ArrayList<LatLng>();\n    int index = 0, len = encoded.length();\n    int lat = 0, lng = 0;\n    while (index < len) {\n        int b, shift = 0, result = 0;\n        do {\n            b = encoded.charAt(index++) - 63;\n            result |= (b & 0x1f) << shift;\n            shift += 5;\n        } while (b >= 0x20);\n        int dlat = ((result & 1) != 0 ? ~(result >> 1) : (result >> 1));\n        lat += dlat;\n        shift = 0;\n        result = 0;\n        do {\n            b = encoded.charAt(index++) - 63;\n            result |= (b & 0x1f) << shift;\n            shift += 5;\n        } while (b >= 0x20);\n        int dlng = ((result & 1) != 0 ? ~(result >> 1) : (result >> 1));\n        lng += dlng;\n\n        LatLng position = new LatLng((double) lat / 1E5, (double) lng / 1E5);\n        poly.add(position);\n    }\n    return poly;\n}\n```\n\n\n}\n\nAnd DirectionTask:\n\n```\npublic class DirectonTask extends AsyncTask<String, Void, Document> {\n    private static final String TAG = \"google_map_DirectonTask\";\n    Context c;\n    MapGoogle map;\n    public DirectonTask(MapGoogle map) {\n        super();\n        this.map = map;\n//      this.c = c;\n    }\n\n    @Override\n    protected void onPreExecute() {\n        super.onPreExecute(); \n\n    }\n\n\n\n    @Override\n    protected Document doInBackground(String... url) {\n//      LOG.d(TAG, \"url = \" + url[0]);\n        HttpClient httpClient = new DefaultHttpClient();\n        // HttpContext localContext = new BasicHttpContext();\n        // HttpPost httpPost = new HttpPost(url);\n\n        try {\n            HttpGet httpGet = new HttpGet(url[0]);\n            HttpResponse response;\n            response = httpClient.execute(httpGet);\n            InputStream in = response.getEntity().getContent();\n            DocumentBuilder builder = DocumentBuilderFactory.newInstance()\n                    .newDocumentBuilder();\n            Document doc = builder.parse(in);\n            return doc;\n        } catch (ClientProtocolException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }catch (Exception e) {\n            e.printStackTrace();\n\n        }\n\n        return null;\n\n    }\n\n\n\n    @Override\n    protected void onPostExecute(Document result) {\n        if (result != null) {\n\n            map.drawDirection(result);\n\n        } else {\n            LOG.d(\"onPostExecute: direction = null\");\n        }\n    }\n}\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Giraph Shortest Paths Example ClassNotFoundException\r\n                \r\nI am trying to run the shortest paths example from the giraph incubator (https://cwiki.apache.org/confluence/display/GIRAPH/Shortest+Paths+Example). However instead of executing the example from the giraph-*-dependencies.jar, I have created my own job jar. When I created a single Job file as presented in the example, I was getting \n\n```\njava.lang.RuntimeException: java.lang.RuntimeException: java.lang.ClassNotFoundException: org.test.giraph.Test$SimpleShortestPathsVertexInputFormat\n```\n\n\nThen I have moved the inner classes (SimpleShortestPathsVertexInputFormat and SimpleShortestPathsVertexOutputFormat) to separates files and renamed them just in case (SimpleShortestPathsVertexInputFormat_v2, SimpleShortestPathsVertexOutputFormat_v2); the classes are not static anymore. This have solved the issues of class not found for the SimpleShortestPathsVertexInputFormat_v2, however I am still getting the same error for the SimpleShortestPathsVertexOutputFormat_v2. Below is my stack trace.\n\n```\nINFO mapred.JobClient: Running job: job_201205221101_0003\nINFO mapred.JobClient:  map 0% reduce 0%\nINFO mapred.JobClient: Task Id : attempt_201205221101_0003_m_000005_0, Status : FAILED\n    java.lang.RuntimeException: java.lang.RuntimeException: java.lang.ClassNotFoundException: org.test.giraph.utils.SimpleShortestPathsVertexOutputFormat_v2\n            at org.apache.hadoop.conf.Configuration.getClass(Configuration.java:898)\n            at org.apache.giraph.graph.BspUtils.getVertexOutputFormatClass(BspUtils.java:134)\n            at org.apache.giraph.bsp.BspOutputFormat.getOutputCommitter(BspOutputFormat.java:56)\n            at org.apache.hadoop.mapred.Task.initialize(Task.java:490)\n            at org.apache.hadoop.mapred.MapTask.run(MapTask.java:352)\n            at org.apache.hadoop.mapred.Child$4.run(Child.java:259)\n            at java.security.AccessController.doPrivileged(Native Method)\n            at javax.security.auth.Subject.doAs(Subject.java:415)\n            at org.apache.hadoop.security.UserGroupInformation.doAs(UserGroupInformation.java:1059)\n            at org.apache.hadoop.mapred.Child.main(Child.java:253)\n    Caused by: java.lang.RuntimeException: java.lang.ClassNotFoundException: org.test.giraph.utils.SimpleShortestPathsVertexOutputFormat_v2\n            at org.apache.hadoop.conf.Configuration.getClass(Configuration.java:866)\n            at org.apache.hadoop.conf.Configuration.getClass(Configuration.java:890)\n            ... 9 more\n```\n\n\nI have inspected my job jar and all classes are there. Furthermore I am using hadoop 0.20.203 in a pseudo distributed mode. The way I launch my job is presented below.\n\n```\nhadoop jar giraphJobs.jar org.test.giraph.Test -libjars /path/to/giraph-0.2-SNAPSHOT-jar-with-dependencies.jar /path/to/input /path/to/output 0 3\n```\n\n\nAlso I have defined HADOOP_CLASSPATH for the giraph-*-dependencies.jar. I can run the PageRankBenchmark example without a problem (directly from the giraph-*-dependencies.jar), and the shortes path example works as well (also directly from the giraph-*-dependencies.jar). Other hadoop jobs work without a problem (somewhere I have read to test if my \"cluster\" works correctly). Does anyone came across similar problem? Any help will be appreciated.\n\n\n\nSolution (sorry to post it like this but I can't answer my own question for a couple of more hours)\n\nTo solve this issue I had to add my Job jar to the -libjars (no changes to HADOOP_CLASSPATH where made). The command to launch job now looks like this.\n\n```\nhadoop jar giraphJobs.jar org.test.giraph.Test -libjars /path/to/giraph-0.2-SNAPSHOT-jar-with-dependencies.jar,/path/to/job.jar /path/to/input /path/to/output 0 3\n```\n\n\nList of jars has to be comma separated. Though this has solved my problem. I am still curious why I have to pass my job jar as a \"classpath\" parameter? Can someone explain me what is the rational behind this? As I found it strange (to say the least) to invoke my job jar and then pass it again as a \"classpath\" jar. I am really curious about the explanation.\n    ", "Answer": "\r\nI found an alternative programmatic solution to the problem.\nWe need to modify the run() method in the following way - \n\n```\n...\n@Override\npublic int run(String[] argArray) throws Exception {\n    Preconditions.checkArgument(argArray.length == 4,\n        \"run: Must have 4 arguments <input path> <output path> \" +\n        \"<source vertex id> <# of workers>\");\n\n    GiraphJob job = new GiraphJob(getConf(), getClass().getName());\n    // This is the addition - it will make hadoop look for other classes in the same     jar that contains this class\n    job.getInternalJob().setJarByClass(getClass());\n    job.setVertexClass(getClass());\n    ...\n}\n```\n\n\nsetJarByClass() will make hadoop look for the missing classes in the same jar that contains the class returned by getClass(), and we will not need to add the job jar name separately to the -libjars option.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest Path Bounded By Circles\r\n                \r\nThere are ```\nn```\n circles with radius ```\nr```\n, the origin of the ```\ni```\n-th circle is located at ```\n(x[i], y[i])```\n. I would like to find the distance of the shortest path from the origin of the first circle to the origin of the last circle, and any point on the path is located inside one or more circle.\nBelow is a demonstration for three circles located at (3, 3), (3, 7) and (6, 7), the blue line is the shortest path.\n\nI have tried to find the intersections of each pair of circles and run a shortest path algorithm, however that result in a time complexity of ```\nO(n^5)```\n. I would like to know if there exists a better algorithm that runs faster. Thanks.\n    ", "Answer": "\r\nI found a solution of ```\nO(n^3)```\n. Notice the optimal path is made up of line segments joining the starting point, the ending point, or the intersections of circles which do not lie inside another circle (in other words, the \"outside intersections\" of the graph). The number of candidate points is ```\nO(n)```\n.\nThen for each pair of points, if the every point on the straight line connecting them lies inside the figure, mark the distance of this pair of points to be the straight line distance between them. Otherwise, mark the distance as infinity. This takes ```\nO(n^3)```\n as there are ```\nO(n^2)```\n pairs of points and the check takes ```\nO(n)```\n.\nFinally, run any shortest path algorithm from the starting position to the ending position. Floyd-Warshall would be a nice choice because its time complexity is ```\nO(n^3)```\n and the adjacency matrix is given.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "BFS print shortest path\r\n                \r\nI am trying to implement BFS algorithm to find the shortest path on a uniformly weighted graph. The code below is a straight implementation of the BFS from here: https://www.redblobgames.com/pathfinding/a-star/introduction.html\n\n```\nvoid print_path(vector<vector<int>> & gr, int xf, int yf, int xt, int yt)\n{\n    /* Cell neighbours */\n    const vector<pair<int,int>> nbr {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\n\n    /* route breadcrumbs */\n    map<pair<int,int>,pair<int,int>> route;\n    queue<pair<int,int>> q;\n\n    /* Represent each node as a pair<int,int> */\n    pair<int,int> start = {xf, yf};\n    pair<int,int> end = {xt, yt};\n\n    /* NULL node */\n    route[start] = {-1, -1};\n    q.push(start);\n\n    while (!q.empty()) {\n        auto current = q.front();\n        q.pop();\n\n        if (current == end) break;\n\n        /* Iterate through all possible neighbours */\n        for (const auto & n : nbr) {\n            /* pair<int,int> operator+ overloaded */\n            auto next = current + n;\n\n            /* Can move to the next node and it is not yet in the route */\n            if (can_move_to(next, gr) && route.find(next) == route.end()) {\n                q.push(next);\n                route[next] = current;\n            }\n        }\n    }\n\n    /* Trace back the shortest path */\n    while (route[end] != pair<int,int>(-1, -1)) {\n        cout << end.first << ';' << end.second << endl;\n        end = route[end];\n    }\n    /* Print the starting node */\n    cout << end.first << ';' << end.second << endl;\n}\n```\n\n\nMaybe I miss something, but the code does not yield the shortest path (and I don't see why should it). This function prints the path along the right angle sides, rather than \"wiggle\" around the hypotenuse.\n    ", "Answer": "\r\nWell, with the help of paper and pencil, the solution was pretty obvious (yet I can not prove it). If I alter the neighbours iteration order each \"layer\", then the diagonal paths will alter it's direction and so yield the valid (shortest?) path. That being said, the inner nbr loop should look something like this:\n\n```\nif ((current.first + current.second) & 1) {\n    /* Odd layers */\n    for (auto it = nbr.begin(); it != nbr.end(); it++) {\n        auto next = current + *it;\n        if (can_move_to(next, gr) && route.find(next) == route.end()) {\n            q.push(next);\n            route[next] = current;\n        }\n    }\n}\nelse {\n    /* Even layers */\n    for (auto it = nbr.rbegin(); it != nbr.rend(); it++) {\n        auto next = current + *it;\n\n        if (can_move_to(next, gr) && route.find(next) == route.end()) {\n            q.push(next);\n            route[next] = current;\n        }\n    }\n}\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Does A* always provide shortest path?\r\n                \r\nI am trying to understand how A*, Uniform cost and greedy search algorithms work. I know that the way in which nodes are explored changes in all 3 algorithms (greedy will explore based on  heuristic value, A* based on heuristic plus distance, uniform based on distance). \n\nI want to know if for a given source and destination should all 3 algorithms provide the shortest path (with just a different number of cities explored?) or can they provide a different path.\n\nI am mostly confused due to the implementation part of - if you store nodes in queue then when you are about to explore the destination node you will have the shortest path for it but if you have queue of paths (and this queue is now sorted based on heuristic + distance) then you might not always get the shortest path.\n    ", "Answer": "\r\nNot necessarily, it depends on your heuristic. See this section in Wikipedia that explains it in detail.\n\nTo summarize, A* gives an optimal solution if the heuristic is admissable (meaning it never overestimates the cost).\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "K negative edges - single source shortest path\r\n                \r\nI've managed to solve the problem finding all single source shortest paths when there's exactly one negative edge using dijkstra.\n\nNow i'm trying to face a new problem, how to find all shortest paths from a given source when there are exactly K negative edges using dijkstra only (Not bellman ford). (k is known).\n\nCan't really think of a good way to do it. \n\nany suggestions?\n    ", "Answer": "\r\nIf it is a nondirectional graph, there is no single shortest path because even with a single negative edge, you could just go back and forth on that negative edge and have an infinite number of paths of negative infinity. \n\nHowever, assuming a directional graph with no negative cycles, you could use Breadth First Search and keep track of both the negative edges you've already hit and the shortest path to each node you've discovered so far. If you see a node you've already visited, you only go there again if it would be better than the previous path you took to get there.\n\nSince there are no negative cycles the algorithm must terminate. After the algorithm terminates the target node should have the best path that was used to get there. \n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Is R IGraph computing undirected shortest path in directed network?\r\n                \r\nthere is something that i'm missing about IGraph shortest paths computation.\n\nsuppose I generate a network (find somewhere in stackoverflow) and perform simple computations:\n\n```\nlibrary(igraph);\nrelations <- data.frame(from=c(\"Bob\", \"Cecil\", \"Cecil\", \"David\", \"David\", \"Esmeralda\"), to=c(\"Alice\", \"Bob\", \"Alice\", \"Alice\", \"Bob\", \"Alice\"));\ng = simplify(graph_from_data_frame(d=relations, directed=T), remove.multiple = F, remove.loops = T);\n#plotting the network in order to appreciate the directions of the edges\nplot(g,edge.arrow.size=0.5);\n#V(g)[5] is \"Alice\" which apparently should not be able to reach any node\nprint(all_shortest_paths(g,from=V(g)[5],to=V(g),mode=\"all\")$res);\n```\n\n\nas you can see, the shortest paths found are:\n\n```\n> print(all_shortest_paths(g,from=V(g)[5],to=V(g),mode=\"all\")$res);\n[[1]]\n+ 2/5 vertices, named, from 823c15d:\n[1] Alice Bob  \n\n[[2]]\n+ 2/5 vertices, named, from 823c15d:\n[1] Alice Cecil\n\n[[3]]\n+ 2/5 vertices, named, from 823c15d:\n[1] Alice David\n\n[[4]]\n+ 2/5 vertices, named, from 823c15d:\n[1] Alice     Esmeralda\n\n[[5]]\n+ 1/5 vertex, named, from 823c15d:\n[1] Alice\n```\n\n\nwhat I'm expecting is that no shortest paths should be returned since Alice, in a directed graph, has no edges that are going out from itself.\nIs this due to the fact that, when I compute the shortest paths, I'm using the option:\n\n```\nmode=\"all\"\n```\n\n\nand this, somehow, works even for directed graphs?\n\nOf course, if I change the graph construction and set:\n\n```\ndirected=F\n```\n\n\ni.e.\n\n```\nlibrary(igraph);\nrelations <- data.frame(from=c(\"Bob\", \"Cecil\", \"Cecil\", \"David\", \"David\", \"Esmeralda\"), to=c(\"Alice\", \"Bob\", \"Alice\", \"Alice\", \"Bob\", \"Alice\"));\n\ng = simplify(graph_from_data_frame(d=relations, directed=F), remove.multiple = F, remove.loops = T);\n\n#plottin the network in order to appreciate the directions of the edges\nplot(g,edge.arrow.size=0.5);\n\n#V(g)[5] is \"Alice\" which apparently should not be able to reach any node\nprint(all_shortest_paths(g,from=V(g)[5],to=V(g),mode=\"all\")$res);\n```\n\n\nthe same results are returned.\n\nWhat is going on? Am I just too tired to get this straight?\n    ", "Answer": "\r\nThat is just what ```\nmode=\"all\"```\n means - use all edges regardless of direction. \n\nI will use a simpler graph to make it easy to see what is going on. \n\n```\nrel2 <- data.frame(from=c(\"Bob\", \"Bob\", \"David\"), \n        to=c(\"Alice\", \"Carol\", \"Carol\"))\ng = simplify(graph_from_data_frame(d=rel2, directed=T))\nLO = layout_as_bipartite(g, types=c(F,F,T,T))\nplot(g, layout=LO)\n```\n\n\n\n\nNow with your shortest path statement\n\n```\nprint(all_shortest_paths(g,from=V(g)[3],to=V(g),mode=\"all\")$res)\n[[1]]\n+ 2/4 vertices, named:\n[1] Alice Bob  \n[[2]]\n+ 4/4 vertices, named:\n[1] Alice Bob   Carol David\n[[3]]\n+ 1/4 vertex, named:\n[1] Alice\n[[4]]\n+ 3/4 vertices, named:\n[1] Alice Bob   Carol\n```\n\n\nWe get all paths connecting Alice to another node, even though the edges go in opposite directions. \n\nI think that what you want is:\n\n```\nprint(all_shortest_paths(g,from=V(g)[3],to=V(g),mode=\"out\")$res)\n[[1]]\n+ 1/4 vertex, named:\n```\n\n\nWhich gives only the zero-length path from Alice to itself. \n\nJust for completeness, \n\n```\nprint(all_shortest_paths(g,from=V(g)[3],to=V(g),mode=\"in\")$res)\n[[1]]\n+ 2/4 vertices, named:\n[1] Alice Bob  \n\n[[2]]\n+ 1/4 vertex, named:\n[1] Alice\n```\n\n\nThis follows paths using only incoming edges, so we get the path \"from\" Alice \"to\" Bob using the edge into Alice,  but we get nothing else because there are no edges into Bob.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "shortest path algorithm in android [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                It's difficult to tell what is being asked here. This question is ambiguous, vague, incomplete, overly broad, or rhetorical and  cannot be reasonably answered in its current form. For help clarifying this question so that it can be reopened,  visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI am implementing an offline Map Navigation project in android, So I am using mbtiles as my map source. Now I want to overlay path( route ) between points in that map, Can anybody please give an idea on how to implement shortest path algorithms in android to route the shortest path between points?\n    ", "Answer": "\r\nCheck out JUNG (Java Universal Network/Graph Framework).  The package contains GUI examples that utilize several graph algorithms, including those for shortest path.  I found the framework very interesting.\n\nIn it, check out classes: TestShortestPath, DijkstraShortestPath, UnweightedShortestPath, and other classes in package edu.uci.ics.jung.algorithms.shortestpath. \n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path after doubling edge weights\r\n                \r\nSuppose we have a weighted directed graph G and we've found the shortest path between vertices u and v in G using A* search or any other shortest path algorithm. Now suppose that we double all of the edge weights in G. Does the shortest path change?\n\nMy argument is as follows: the shortest path does not change. Call the original path P and suppose that there exists a second, different path P' from u to v such that after doubling the weights of the edges, P' is shorter than P. Then,\n\n```\n    weight(P') < weight(P)\n```\n\n\nafter the doubling. However, dividing both sides by 2 we see that P' must have also been shorter before the doubling, so P was not the shortest path to begin with and we have a contradiction. Thus, P remains the shortest path after doubling the edge weights.\n\nCould someone critique this solution? Is it correct?\n    ", "Answer": "\r\nYes, the shortest path remains the same. Applying a linear transformation to the edge weights does not change the shortest path, so long as you do not negate the edge weights.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Implementing the k-shortest paths problem\r\n                \r\nI have implemented a directed weighted graph using map.\n```\nstruct Edge\n{\n    int destination;\n    int weight;\n    Edge(int, int);\n};\n\nprivate:\n    int number;\n    std::map<std::string, int> vertices;\n    std::map<int, std::string> reverseV;\n    std::map<int, std::vector<Edge>> vEdges;\npublic:\npublic:\n    Graph();\n    Graph(std::string);\n    void addVertex(std::string);\n    void addEdge(std::string, std::string, int);\n    void ShortestPaths(std::string, std::string);\n};\n```\n\nI have to implement function, which solves the k-shortest path routing. Here is the algorithm:\nhttps://en.wikipedia.org/wiki/K_shortest_path_routing\nAnd here is my function:\n```\nvoid Graph::ShortestPaths(std::string from, std::string to);\nint numberOfwantedPaths = 3; \n    //int sumW = 0;\n    std::vector<std::string> path; \n    std::pair<std::vector<std::string>, int> pathANDsumW; \n    std::set<std::pair<std::vector<std::string>, int> > Allpaths; \n\n\n    path.push_back(from);\n    pathANDsumW = make_pair(path, 0);\n    \n    std::map<int, int> numberOfpaths; \n\n    for (auto& it : this->reverseV) \n    {\n        numberOfpaths[it.first] = 0;\n    }\n\n    std::priority_queue<std::pair<std::vector<std::string>, int>, \n        std::vector<std::pair<std::vector<std::string>, int>>, \n        std::greater<std::pair<std::vector<std::string>, int> > > MinHeap;\n\n    MinHeap.push(pathANDsumW);\n\n    while (!MinHeap.empty() && numberOfpaths[this->vertices[to]] < numberOfwantedPaths)\n    {\n        std::vector<std::string> tempPath = MinHeap.top().first;\n        int sumW = MinHeap.top().second;\n        std::string currKey = tempPath[tempPath.size() - 1]; \n        int currKeyVal = this->vertices[currKey];\n        numberOfpaths[currKeyVal]++;\n        MinHeap.pop();\n\n        if (currKey == to)\n        {\n            Allpaths.insert(make_pair(tempPath, sumW));\n            break;\n        }\n        if (numberOfpaths[currKeyVal] <= numberOfwantedPaths)\n        {\n            for (auto& it : this->vEdges[currKeyVal])\n            {\n                std::vector<std::string> newPath = tempPath;\n                newPath.push_back(this->reverseV[it.destination]);\n                if (newPath[newPath.size()-1] == to)\n                {\n                    Allpaths.insert(make_pair(newPath, sumW));\n                }\n                MinHeap.push(make_pair(newPath, sumW + it.weight));\n\n            }\n        }\n    }\n//printing part\n    for (auto& it : Allpaths)\n    {\n        for (int i = 0; i < it.first.size(); i++)\n        {\n            std::cout << it.first[i] << \" \";\n            if (i < it.first.size() - 1)\n            {\n                std::cout << \" -> \";\n            }\n        }\n        std::cout << std::endl;\n    }\n```\n\nI can't find the error. What am I doing wrong? It prints only one path 3 times.\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Create subgraph from shortest path calculation sfnetworks R\r\n                \r\nI have a network, and a focal node within the network. I have calculated the shortest paths to all other nodes from that node, and I'm trying to figure out how to make a sub-graph of the original network from that shortest path calculation.\nThe goal is to be able to show the all the paths from my focal node to any other node that match a criteria (e.g. that the path is less than 50m or longer than 100m but shorter than 500m).\n```\nlibrary(sfnetworks)\nlibrary(sf)\nlibrary(tidygraph)\nlibrary(dplyr)\nlibrary(ggplot2)\n\n# the base network\nnet <- as_sfnetwork(roxel, directed = FALSE) %>%\n  st_transform(3035) %>%\n  activate(\"edges\") %>%\n  mutate(weight = edge_length()) \n\n# the network with the focal point\nggplot() +\n  geom_sf(data = net %>%\n            activate(\"edges\") %>%  \n            st_as_sf(), colour = \"grey90\") +\n  geom_sf(data = net %>%\n            activate(\"nodes\") %>%  \n            st_as_sf())  + \n    geom_sf(data = net %>%\n            activate(\"nodes\") %>%  \n            slice(495) %>% \n            st_as_sf(), size = 3.5, fill = \"orange\", \n          colour = \"black\", shape = 21) +\n  theme_void()\n```\n\n\nI can get the shortest paths using the ```\nsfnetworks```\n wrapper or directly from ```\nigraph```\n:\n```\nshort_paths_sf <- st_network_paths(net %>% activate(nodes), \n                          from = 495, to = c(1:701), weights = \"weight\")\nshort_paths_ig <- igraph::shortest_paths(\n  graph = net, \n  from = 495,\n  to = c(1:701),\n  output = \"both\",\n  weights = net %>% activate(edges) %>% pull(weight)\n)\n```\n\nBut I think I'm missing two key parts here. 1) Making the subgraph from the ```\nnet```\n object and containing just the shortest paths and 2) then transforming the subgraph so I can do operations on the length of the whole path not just the weight of an edge.\nI know I can get the length of a single path between two points with something like\n```\nsingle_path <- st_network_paths(net %>% activate(nodes),\n                 from = 495,\n                 to = 701,\n                 weights = \"weight\") %>% \n  pull(edge_paths) %>% \n  unlist()\n\nnet %>% \n  activate(edges) %>%\n  slice(single_path) %>%\n  st_as_sf() %>%\n  st_combine() %>%\n  st_length()\n> 482.0495 [m]\n```\n\nWhich I can plot with\n```\nggplot() +\n  geom_sf(data = net %>%\n            activate(\"edges\") %>%  \n            st_as_sf(), colour = \"grey90\") +\n  geom_sf(data = net %>%\n            activate(\"nodes\") %>%  \n            st_as_sf())  + \n    geom_sf(data = net %>%\n            activate(\"nodes\") %>%  \n            slice(495) %>% \n            st_as_sf(), size = 3.5, fill = \"orange\", \n          colour = \"black\", shape = 21) +\n  geom_sf(data = net %>%\n            activate(edges) %>%\n            slice(single_path) %>% \n            st_as_sf(), colour = \"firebrick\") +\n  theme_void()\n```\n\n\nBut I'm struggling to figure out how to do that for the single-to-many case, and then especially, how to filter those paths such that, for example, I could look at only paths from point 495 that are shorter than 500m.\nI tried to apply what the authors here suggest in the shortest paths section:\n```\nsub_graph <- net %>% \n  igraph::subgraph.edges(eids = short_paths_ig$epath %>% unlist()) %>% \n  as_tbl_graph()\n```\n\nBut then it's unclear to me how this will show me my shortest paths?\nAny help much appreciated!!\n    ", "Answer": "\r\nEDIT:\nI spent a while figuring out a better version of my first solution (below) so here's a much faster way (I didn't benchmark the final solution just step-wise, but it ends up being like >50x faster).\nSo we start the same way exactly:\n```\nlibrary(sfnetworks)\nlibrary(parallel)\nlibrary(tidyverse)\n\n# Load the roxel dataset\nnet <- as_sfnetwork(roxel, directed = FALSE) %>%\n  st_transform(3035) %>%\n  activate(\"edges\") %>%\n  mutate(weight = edge_length())\n```\n\nCalculate shortest paths from focal node to all other nodes, and save the edge and node paths:\n```\npaths = st_network_paths(net, from = 495, weights = \"weight\")\n\nnodes_all <- paths %>%\n  pull(node_paths) \n\nedges_all <- paths %>%\n  pull(edge_paths) \n```\n\nNow, the longest part of this is actually getting the length of each of the paths to check against our criteria, so I put this process into a function and parallelized it. First the function:\n```\nslice_fun <- function(net, temp_edges) {\n  #' Find path length of one path\n  #' \n  #' @description Taking a single path (i.e. set of edges), get the length \n  #' of that path, and remove the units on it\n  #' @param net sfnetwork. A network of sfnetwork\n  #' @param temp_edges vector. The edges of the path at hand \n  #' \n  #' @return numeric value (units removed) of the length of that path\n  \n  return(units::drop_units(net %>% \n    activate(\"edges\") %>% \n    slice(temp_edges) %>% \n    st_as_sf() %>% \n    st_combine() %>% \n    st_length()))\n}\n```\n\nNow parllelize with ```\nparSapply()```\n (this is the biggest time saver since the calculation of the length with all the ```\nsf::```\n/```\nsfnetworks::```\n functions take the longest):\n```\nstart_time <- Sys.time()\n# start the cluster\ncl <- parallel::makeCluster(8)\n\n# the libraries need to be evaluated so they're available on all workers\nparallel::clusterEvalQ(cl, {library(dplyr); library(sfnetworks); \n  library(magrittr); library(sf)})\n\n# export the objects you need for the process\nparallel::clusterExport(cl, varlist = c(\"edges_all\", \"net\"))\n\n# run in parallel\nresult <- parSapply(cl, edges_all, slice_fun, net = net)\n\nparallel::stopCluster(cl)\nend_time <- Sys.time()\nend_time - start_time\n# > Time difference of 14.49258 secs\n```\n\nNow, find the indices of the ```\nedges_all```\n that pass our criteria (here, we only want paths longer than 1000m), and filter the edges by those indices, ```\nunlist()```\n so all the edges are together, and keep only unique edges:\n```\nindices_keep <- which(result > 1000)\nkeep_edges <- unique(edges_all[indices_keep] %>% unlist())\n```\n\nIf we want the nodes at the ends of the the paths that fulfill our requirement, we can do so like this:\n```\n# we can get the nodes if we want too\nnodes_to_keep_all <- nodes_all[indices_keep]\nnodes_to_keep <- unlist(lapply(nodes_to_keep_all, tail, n = 1L) %>% unlist())\n```\n\nNow plot:\n```\nggplot() + \n  geom_sf(data = net %>%\n            activate(\"edges\") %>%  \n            st_as_sf(), colour = \"grey90\") +\n  geom_sf(data = net %>%\n            activate(\"nodes\") %>%  \n            st_as_sf(), colour = \"grey90\")  + \n  geom_sf(data = net %>%\n            activate(\"edges\") %>%\n            slice(keep_edges) %>% \n            st_as_sf()\n  ) +\n  geom_sf(data = net %>%\n            activate(\"nodes\") %>%  \n            slice(495) %>% \n            st_as_sf(), size = 3.5, fill = \"orange\", colour = \"black\", shape = 21) +\n  geom_sf(data = net %>%\n            activate(\"nodes\") %>%\n            slice(nodes_to_keep) %>%\n            st_as_sf(), size = 2, fill = \"red\", colour = \"black\", shape = 21,\n          alpha = 0.4) +\n  theme_void()\n```\n\n\n\nOriginal solution:\nOk so I figured out a custom solution to this, where the criteria is if the path is > 1000m.\nWe can start by getting our network:\n```\nnet = as_sfnetwork(roxel, directed = FALSE) %>%\n  st_transform(3035) %>%\n  activate(\"edges\") %>%\n  mutate(weight = edge_length())\n\n```\n\nThen we calculate the shortest paths from a focal node to all the other nodes, and we save the ```\nedge_paths```\n and ```\nnode_paths```\n from that run to objects for easy access.\n```\npaths = st_network_paths(net, from = 495, weights = \"weight\")\n\n# get nodes & edges both as paths (this results in a list format)\nnodes_all <- paths %>%\n  pull(node_paths) \n\nedges_all <- paths %>%\n  pull(edge_paths) \n\n```\n\nNow I wrote a custom function that I have not optimized, it's not very fast at all, but it's a verbosely explicit version of what I'm trying to do. The function takes a particular path, figures out if that path is long enough for my criteria, and if so, keeps the edges involved in that path. There's also an option to keep or leave out the nodes that are at the end of those long-enough paths.\nThe function:\n```\nlen_crit <- function(net, edges, nodes = NULL) {\n  #' Look at whether or not each of the individual paths calcualted actually\n  #' pass the required test\n  #' \n  #' @description  Look at whether or not each of the individual paths \n  #' calculated actually pass the required test\n  #' @param net sfnetwork. A network of sfnetwork\n  #' @param slice_val integer. The value to slice the edges into \n  #' @param edges list. The list of the edges in the shortest path\n  \n  # initialize empty vector\n  all_edges <- as.numeric()\n  # initialize empty vector for nodes if applicable \n  if(!is.null(nodes)) {\n    all_nodes <- as.numeric()\n  }\n  \n  # go through each of the slices (aka each of the paths)\n  for(slice in 1:length(edges)) {\n    \n    # check what the temporary path length is\n    temp_len <- net %>% \n      activate(\"edges\") %>% \n      slice(edges[[slice]]) %>% \n      st_as_sf() %>% \n      st_combine() %>% \n      st_length()\n    \n    # if the temporary length is long enough, add the edges of that path to \n    # the total edges\n    if(temp_len > units::set_units(1000, m)) {\n      # if the length of the current path is long enough, add it to all_edges\n      all_edges <- c(all_edges, edges[[slice]])\n      \n      # if we also want to plot the nodes, we can do so\n      if(!is.null(nodes)) {\n        # if the length is long enough, keep the LAST node in that set\n        all_nodes <- c(all_nodes, nodes[[slice]][[length(nodes[[slice]])]]) \n      }\n    }\n  }\n  \n  # if the nodes are selected return both that and the edges\n  if(!is.null(nodes)) {\n    # keep only the unique ones\n    unique_nodes <- unique(all_nodes)\n    # keep only the unique ones\n    unique_edges <- unique(all_edges)\n    # list up both\n    nodes_edges <- list(\n      nodes = unique_nodes,\n      edges = unique_edges \n    )\n    # return both\n    return(nodes_edges)\n  }\n\n  # keep only the unique ones\n  unique_edges <- unique(all_edges)\n  \n  return(unique_edges)\n}\n\n```\n\nNow I can run it:\n```\nshort_edges <- len_crit(net = net, edges = edges_all, nodes = nodes_all)\n```\n\nAnd plot it by slicing the net, with ```\nactivate```\n of the nodes and edges respectively, and sliced by the ```\nshort_edges$nodes/edges```\n:\n```\n  ggplot() + \n    geom_sf(data = net %>%\n              activate(\"edges\") %>%  \n              st_as_sf(), colour = \"grey90\") +\n    geom_sf(data = net %>%\n              activate(\"nodes\") %>%  \n              st_as_sf(), colour = \"grey90\")  + \n    geom_sf(data = net %>%\n                 activate(\"edges\") %>%\n                 slice(short_edges$edges) %>% \n                 st_as_sf()\n                 ) +\n    geom_sf(data = net %>%\n              activate(\"nodes\") %>%  \n              slice(495) %>% \n              st_as_sf(), size = 3.5, fill = \"orange\", colour = \"black\", shape = 21) +\n    geom_sf(data = net %>%\n              activate(\"nodes\") %>%  \n              slice(short_edges$nodes) %>% \n              st_as_sf(), size = 2, fill = \"red\", colour = \"black\", shape = 21,\n            alpha = 0.4) +\n    theme_void()\n```\n\nWhich gives this, exactly what I want :)\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path with a fixed number of edges\r\n                \r\nFind the shortest path through a graph in efficient time, with the additional constraint that the path must contain exactly n nodes.\n\nWe have a directed, weighted graph. It may, or may not contain a loop. We can easily find the shortest path using Dijkstra's algorithm, but Dijkstra's makes no guarantee about the number of edges.\n\nThe best we could come up with was to keep a list of the best n paths to a node, but this uses  a huge amount of memory over vanilla Dijkstra's.\n    ", "Answer": "\r\nIt is a simple dynamic programming algorithm.\nLet us assume that we want to go from vertex ```\nx```\n to vertex ```\ny```\n.\nMake a table ```\nD[.,.]```\n, where ```\nD[v,k]```\n is the cost of the shortest path of length ```\nk```\n from the starting vertex ```\nx```\n to the vertex ```\nv```\n.\n```\nInitially D[x,1] = 0. Set D[v,1] = infinity for all v != x.\nFor k=2 to n:\n  D[v,k] = min_u D[u,k-1] + wt(u,v), where we assume that wt(u,v) is infinite for missing edges. \n  P[v,k] = the u that gave us the above minimum.\n```\n\nThe length of the shortest path will then be stored in D[y,n].\nIf we have a graph with fewer edges (sparse graph), we can do this efficiently by only searching over the ```\nu```\n that ```\nv```\n is connected to. This can be done optimally with an array of adjacency lists.\nTo recover the shortest path:\n```\nPath = empty list\nv = y\nFor k= n downto 1:\n  Path.append(v)\n  v = P[v,k]\nPath.append(x)\nPath.reverse()\n```\n\nThe last node is ```\ny```\n. The node before that is ```\nP[y,n]```\n. We can keep following backwards, and we will eventually arrive at ```\nP[v,2] = x```\n for some ```\nv```\n.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "GraphFrames Shortest Paths gives distance and not the actual path\r\n                \r\nI'm new to Graphframes and trying to implement edge-betweenness. \n\nI tried using shortest Paths function that is built-in. It returns the distance from the source to the destination vertex but not the actual path between them.\n\nThe output is:\n\n```\n| id |   name  | age | distances|\n|  g | Gabriel | 33  | [e -> 2] |\n```\n\n\nIs there any way to get the actual path instead of distance value ? \n\nIf anyone could tell me how to implement edge-betweenness efficiently in graph frames that would be really great.\n    ", "Answer": "\r\nYou can try the BFS algorithm as described https://graphframes.github.io/graphframes/docs/_site/user-guide.html#breadth-first-search-bfs. It will give you the list of nodes that have been traversed from the source to the destination.\nAnother way could be using motifs. You can create patterns and let Graphframes to show all the paths that have a length of whatever is on the motif you have created\nFor example:\n(a)-[e1]->(b); (b)-[e2]->(c)\nmeans show me all the paths with a length of 2 and include vertex names and edges names with their properties. From there you could filter the one that you want or even use anonymous vertices or edges if required.\nOne note on it is that when you have a lot of data you may find performance problems using motifs or bfs because they are using self joins on their implementations. Please refer to https://www.waitingforcode.com/apache-spark-graphframes/motifs-finding-graphframes/read for more information\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "GraphFrames Shortest Paths gives distance and not the actual path\r\n                \r\nI'm new to Graphframes and trying to implement edge-betweenness. \n\nI tried using shortest Paths function that is built-in. It returns the distance from the source to the destination vertex but not the actual path between them.\n\nThe output is:\n\n```\n| id |   name  | age | distances|\n|  g | Gabriel | 33  | [e -> 2] |\n```\n\n\nIs there any way to get the actual path instead of distance value ? \n\nIf anyone could tell me how to implement edge-betweenness efficiently in graph frames that would be really great.\n    ", "Answer": "\r\nYou can try the BFS algorithm as described https://graphframes.github.io/graphframes/docs/_site/user-guide.html#breadth-first-search-bfs. It will give you the list of nodes that have been traversed from the source to the destination.\nAnother way could be using motifs. You can create patterns and let Graphframes to show all the paths that have a length of whatever is on the motif you have created\nFor example:\n(a)-[e1]->(b); (b)-[e2]->(c)\nmeans show me all the paths with a length of 2 and include vertex names and edges names with their properties. From there you could filter the one that you want or even use anonymous vertices or edges if required.\nOne note on it is that when you have a lot of data you may find performance problems using motifs or bfs because they are using self joins on their implementations. Please refer to https://www.waitingforcode.com/apache-spark-graphframes/motifs-finding-graphframes/read for more information\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Find All Shortest Paths using igraph/R\r\n                \r\nFirst off I am not very proficient with R, but I have a network of 100 nodes I'm doing analysis on. I'm looking to find all the shortest paths between every single pair of nodes in the network (100 calculations), and the trick is to return them as integers, path lengths if you will. \n\n```\n#construct a small sample of the graph\ng = graph.formula('insert graph') \n\n#use the function to retrieve shortest paths from a single vertex\nget.all.shortest.paths(g, 1, to = V(g))\n\n#output\n$res\n$res[[1]]\n[1] 1\n\n$res[[2]]\n[1] 1 2\n\n$res[[3]]\n[1] 1 2 3\n\n$res[[4]]\n[1] 1 2 3 4\n\n$res[[5]]\n[1] 1 2 3 4 5\n\n$res[[6]]\n[1]  1 10  9  8  7  6\n\n$res[[7]]\n[1] 1 2 3 4 5 6\n\n$res[[8]]\n[1]  1 10  9  8  7\n\n$res[[9]]\n[1]  1 10  9  8\n\n$res[[10]]\n[1]  1 10  9\n\n$res[[11]]\n[1]  1 10\n\n\n$nrgeo\n [1] 1 1 1 1 1 2 1 1 1 1\n```\n\n\nWhile this is good it is not practical to manually iterate for all 100 nodes. Is there a way of automating this? A second component to my question is that I wish to output each path as a number, like a path length, instead of being given the actual path. Another thing I want is to calculate the mode path length (or the path length that is more frequently found in the network). Looking at 100 numbers is not feasible so it must be automated. \n\nAny help would be thoroughly appreciated, this might seem like a novice question, I am somewhat of a novice user.\n    ", "Answer": "\r\nYou could use ```\nshortest.paths```\n that returns the matrix of the distances between each node:\n\n```\ndistMatrix <- shortest.paths(g, v=V(g), to=V(g))\n```\n\n\nResult:\n\n```\n      cdc42 ste20 mkk2 bul1 mth1 vma6 vma2  ... \ncdc42     0     1  Inf  Inf    4    3    2  \nste20     1     0  Inf  Inf    3    2    1  \nmkk2    Inf   Inf    0    1  Inf  Inf  Inf  \nbul1    Inf   Inf    1    0  Inf  Inf  Inf  \nmth1      4     3  Inf  Inf    0    1    2  \nvma6      3     2  Inf  Inf    1    0    1\nvma2      2     1  Inf  Inf    2    1    0  \n...      \n```\n\n\nAnd it's very easy to access it:\n\n```\n# e.g. shortest path length between the second node and the fifth\ndistMatrix[2,5]\n>\n[1] 3\n\n# or using node names:\ndistMatrix[\"ste20\", \"mth1\"]\n>\n[1] 3\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Stuck with shortest path in Java\r\n                \r\nI've been working for days in this project where (as the title says), I have to create an array with a given graph with nodes and then find the shortest path from a \"source\" to a \"target\". \n\nI wrote all the methods given except for the \"findPath\" which obviously finds the shortest path from node A to node B. I tried to wrote a simple code using recursion but it doesn't work as i'd...\n\nI know where are the problems but i really don't know how to fix them.\n\nHere's the array (\"path\") with all the linked nodes:\n\nMy input:\n\n\n```\nsource: 0```\n\n```\ntarget: 9```\n\n\n\nMy set: \n\n```\n    (0, 0)\n    (0, 1)\n    (1, 2)\n    (2, 1)\n    (2, 3)\n    (3, 4)\n    (2, 5)\n    (5, 6)\n    (6, 4)\n    (2, 7)\n    (2, 8)\n    (8, 9)\n```\n\n\nThis should be the method that finds the shortest path:\n\n```\n    public void findPath(Integer[][] path, int rowPath, int colPath, Integer[][] possiblePath, int colPoss, int rowPoss, int cont, Integer[] distance, int topDist) {\n        if(path[rowPath][colPath+1] == path[rowPath+1][colPath]){\n            possiblePath[rowPoss][colPoss] = path[rowPath][colPath+1];\n            colPoss++;\n            rowPath++;\n            cont++;\n            findPath(path, rowPath, colPath, possiblePath, colPoss, rowPoss, cont, distance, topDist);\n        }else {\n            distance[topDist] = cont;\n            topDist++;\n            rowPoss++;\n            rowPath = 0;\n            colPoss = 0;\n            if (rowPoss == 5) return;\n            findPath(path, rowPath, colPath, possiblePath, colPoss, rowPoss, cont, distance, topDist);\n        }\n    }\n```\n\n\nFor those who're asking why the recursive method stops when ```\nrowPoss```\n reaches ```\n5```\n, it's because i know that in the primitive array there are a maximum of ```\n5```\n possible paths...but i'll later update it so that the program can possibly work with all the graphs.\n\nAs you can see there are a lot of variables inside this recursive method ```\n--> 4```\n to move inside ```\npath```\n and ```\npossiblePath```\n (row/col), the 2D arrays with ```\npath```\n containing all the linked nodes and ```\npossiblePath```\n which will contain all the possible paths from ```\nA```\n to ```\nB```\n and finally ```\ndistance```\n that (using ```\ncont```\n) will update itself with the length of each path so that at the end it can choose the shortest.\n\nThis is the output for ```\nfindPath```\n (it iterates ```\n5```\n times inside the first possible path which is also wrong): \n\n```\n0 1 2 null null 0 1 2 null null 0 1 2 null null 0 1 2 null null 0 1 2 null null```\n\n    ", "Answer": "\r\nFirst consider the very basic dfs\n\nSyntax looks like js but I didn't try to run it. Consider it pseudocode.\n\n```\nconst dfs = node => {\n  if (node.value === 9) {\n    return console.log('target reached')\n  }\n  node.children.forEach(child => {\n    dfs(child)\n  })\n}\n```\n\n\nThen you want to avoid cycles. In your example I don't think there are any but just do it anyway since you are learning\n\n```\nconst dfs = (node, visited) => {\n  if (node.value === 9) {\n    return console.log('target reached')\n  }\n  if (visited.has(node)) { return console.log('ignore cycle') }\n\n  visited.add(node)\n\n  node.children.forEach(child => {\n    dfs(child, visited)\n  })\n\n  // clean visited once we are finished exploring current node\n  visited.remove(node)\n}\ndfs({ value: 0 }, new Set()) // use a Set for O(1) access\n```\n\n\nThen you want to know which path you used to reach 9\n\n```\nconst dfs = (node, visited) => {\n  if (node.value === 9) {\n    return [node] // return the path\n  }\n  if (visited.has(node)) { return null }\n\n  visited.add(node)\n\n  let somePath = null\n  node.children.forEach(child => {\n    const path = dfs(child, visited)\n    if (path !== null) {\n      // theorically we could stop here but that's not the purpose of illustration\n      somePath = [node].concat(path)\n    }\n  })\n\n  // clean visited once we are finished exploring current node\n  visited.remove(node)\n\n  return somePath\n}\n```\n\n\nFinally you don't want any path to target but only the shortest one\n\n```\nconst dfs = (node, visited) => {\n  if (node.value === 9) {\n    return { size: 0, path: [node] } //return the path AND its size\n  }\n  if (visited.has(node)) { return { size: Math.infinity, path: null } }\n\n  visited.add(node)\n\n  let best = { size: Math.infinity, path: null }\n  node.children.some(child => {\n    const { size, path } = dfs(child, visited)\n    if (size + distance(node, child) < best.size) {\n      best = {\n        size: size + distance(node, child),\n        path: [node].concat(path)\n      }\n    }\n  })\n\n  // clean visited once we are finished exploring current node\n  visited.remove(node)\n\n  return best\n}\n```\n\n\nThis is by no means efficient but this is a possible way of doing your recursion\n\n\r\n\r\n```\nconst data = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,3],[3,4],[2,5],[5,6],[6,4],[2,7],[2,8],[8,9]]\r\nconst nodes = data.reduce((acc, [a, b]) => {\r\n  acc[a] = acc[a] || { value: a, children: []}\r\n  acc[b] = acc[b] || { value: b, children: []}\r\n  acc[a].children.push(acc[b])\r\n  return acc\r\n}, {})\r\n\r\nconst dfs = (node, visited) => {\r\n  if (node.value === 9) { return { size: 0, path: [node] } }\r\n  if (visited.has(node)) { return { size: 9001, path: null } }\r\n  visited.add(node)\r\n  let best = { size: 9001, path: null }\r\n  node.children.forEach(child => {\r\n    const { size, path } = dfs(child, visited)\r\n    if (size + 1 < best.size) {\r\n      best = {\r\n        size: size + 1,\r\n        path: [node].concat(path)\r\n      }\r\n    }\r\n  })\r\n  visited.delete(node)\r\n  return best\r\n}\r\n\r\nconsole.log(dfs(nodes[0], new Set()).path.map(x => x.value))```\n\r\n\r\n\r\n\n\nI would waste too much time transposing this in java, hope it will be enough so you can come up to a java implem on your own\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Prolog Shortest Path using list of lists\r\n                \r\nOkay, so I've been trying to teach myself Prolog recently, and am having a hard time wrapping my head around finding a \"Shortest Path\" between two (defined) elements in a list of lists. It may not be the most effective way of representing a Grid or finding a Shortest Path, but I'd like to try it this way.\n\nFor example:\n\n```\n[[x,x,x,x,x,x,x],\n [x,1,o,o,o,o,x],\n [x,-,-,-,o,-,x],\n [x,-,-,o,o,-,x],\n [x,o,o,o,o,2,x],\n [x,o,-,-,o,o,x],\n [x,x,x,x,x,x,x]]\n```\n\n\nA few assumptions I can make (either given or based on checking before path-finding):\n\n\nThe grid is square\nTheir will always exist a path from 1 to 2\n'1' can pass through anything except '-' (walls) or 'x' (borders)\n\n\nThe goal is for '1' to find a shortest path to '2'.\n\nIn the instance of:\n\n```\n[[x,x,x,x,x,x,x],\n [x,o,o,1,o,o,x],\n [x,-,o,o,o,-,x],\n [x,-,o,-,o,-,x],\n [x,o,o,2,o,o,x],\n [x,o,-,-,-,o,x],\n [x,x,x,x,x,x,x]]\n```\n\n\nNotice, there are two \"Shortest paths\":\n\n```\n[d,l,d,d,r]\n```\n\n\nand\n\n```\n[d,r,d,d,l]\n```\n\n\nIn Prolog, I'm trying to make the function (if that's the proper name):\n\n```\nshortestPath(Grid,Path)\n```\n\n\nI've made a function to find elements '1' and '2', and a function that verifies that the grid is valid, but I can't even begin how to start constructing a function to find a shortest path from '1' to '2'.\n\nGiven a defined Grid, I'd like the output of Path to be the shortest path. Or, given a defined Grid AND a defined Path, I'd like to check if it's indeed a shortest path.\n\nHelp would be much appreciated! If I missed anything, or was unclear, let me know!\n    ", "Answer": "\r\nnot optimized solution\n\n```\nshortestPath(G, S) :-\n    findall(L-P, (findPath(G,P), length(P,L)), All),\n    keysort(All, [_-S|_]).\n\nfindPath(G, Path) :-\n    pos(G, (Rs,Cs), 1),\n    findPath(G, [(Rs,Cs)], [], Path).\n\nfindPath(G, [Act|Rest], Trail, Path) :-\n    move(Act,Next,Move),\n    pos(G, Next, Elem),\n    (   Elem == 2\n    ->  reverse([Move|Trail], Path)\n    ;   Elem == o\n    ->  \\+ memberchk(Next, Rest),\n        findPath(G, [Next,Act|Rest], [Move|Trail], Path)\n    ).\n\nmove((R,C), (R1,C1), M) :-\n    R1 is R-1, C1 is C  , M = u;\n    R1 is R  , C1 is C-1, M = l;\n    R1 is R+1, C1 is C  , M = d;\n    R1 is R  , C1 is C+1, M = r.\n\npos(G, (R,C), E) :- nth1(R, G, Row), nth1(C, Row, E).\n\ngrid(1,\n[[x,x,x,x,x,x,x],\n [x,1,o,o,o,o,x],\n [x,-,-,-,o,-,x],\n [x,-,-,o,o,-,x],\n [x,o,o,o,o,2,x],\n [x,o,-,-,o,o,x],\n [x,x,x,x,x,x,x]]).\n\ngrid(2,\n[[x,x,x,x,x,x,x],\n [x,o,o,1,o,o,x],\n [x,-,o,o,o,-,x],\n [x,-,o,-,o,-,x],\n [x,o,o,2,o,o,x],\n [x,o,-,-,-,o,x],\n [x,x,x,x,x,x,x]]).\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Find total number of shortest paths between nodes u and v that pass through node g\r\n                \r\nI have the following matrix that generates an undirected network diagram:\n\n```\n  a b c d e f g h i j\na 0 1 1 0 0 0 0 0 0 0\nb 1 0 1 0 0 0 0 0 0 0\nc 1 1 0 1 1 0 1 0 0 0\nd 0 0 1 0 1 0 0 0 0 0\ne 0 0 1 1 0 1 0 0 0 0\nf 0 0 0 0 1 0 1 0 0 0\ng 0 0 1 0 0 1 0 1 0 0\nh 0 0 0 0 0 0 1 0 1 1\ni 0 0 0 0 0 0 0 1 0 0\nj 0 0 0 0 0 0 0 1 0 0\n\nm <- structure(c(0L, 1L, 1L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 1L, 0L, 1L, \n0L, 0L, 0L, 0L, 0L, 0L, 0L, 1L, 1L, 0L, 1L, 1L, 0L, 1L, 0L, 0L, \n0L, 0L, 0L, 1L, 0L, 1L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 1L, 1L, 0L, \n1L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 1L, 0L, 1L, 0L, 0L, 0L, 0L, \n0L, 1L, 0L, 0L, 1L, 0L, 1L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 1L, \n0L, 1L, 1L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 1L, 0L, 0L, 0L, 0L, 0L, \n0L, 0L, 0L, 0L, 1L, 0L, 0L), .Dim = c(10L, 10L), .Dimnames = list(\n    c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"), c(\"a\", \n    \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\")))\n\nlibrary(igraph)\ng3n <- graph.adjacency(m)\n```\n\n\nI'm interested in manually calculating the betweeness of node 'g', which requires the finding of shortest paths among all possible nodes as the denominator and the numerator as the number of shortest paths contain node 'g'.\n\nI used the following code to generate the lengths of shortest paths among all nodes:\n\n```\nshortest.paths(g3n, v=V(g3n), to=V(g3n))\n```\n\n\nShortest path matrix:\n\n```\n  a b c d e f g h i j\na 0 1 1 2 2 3 2 3 4 4\nb 1 0 1 2 2 3 2 3 4 4\nc 1 1 0 1 1 2 1 2 3 3\nd 2 2 1 0 1 2 2 3 4 4\ne 2 2 1 1 0 1 2 3 4 4\nf 3 3 2 2 1 0 1 2 3 3\ng 2 2 1 2 2 1 0 1 2 2\nh 3 3 2 3 3 2 1 0 1 1\ni 4 4 3 4 4 3 2 1 0 2\nj 4 4 3 4 4 3 2 1 2 0\n```\n\n\nIs there a way to count the number of times shortest path between 2 nodes contains node 'g' as a matrix or just in any other ways in R? \n    ", "Answer": "\r\nSo, I'm not sure how elegant this solution is, but the following should work:\n\n```\n#initialize a list to populate with all the shortest paths in the graphy\nallpaths <- list()\n\n\n#Assuming this is an undirected graph, we don't want to calculate both a %--% b and b %--% a  \nfor(x in V(g3n)$name){\n  for(y in V(g3n)$name){\n    if(x < y){\n      shortest_path_options <- all_shortest_paths(g3n, x, y)$res\n\n      #sometimes there are multiple shortest paths, we will include them all\n      for(z in shortest_path_options){\n        allpaths[[length(allpaths)+1]] <- z$name\n      }\n    }\n}\n\n#create a boolean of whether a shortest path contains 'g' or not\nallpaths_bool <- sapply(allpaths, function(x){\n  ('g' %in% x) & (head(x, 1) != 'g') & (tail(x, 1) != 'g')\n  })\n\n#Show all the paths that contain 'g'\nallpaths[allpaths_bool]\n```\n\n\nYou can calculate this for every vertex by wrapping everything into a ```\nsapply```\n function.\n\n```\nsapply(V(g3n)$name, function(x){\n  temp_bool <- sapply(allpaths, function(y){\n    (x %in% y) & (head(y, 1) != x) & (tail(y, 1) != x)\n  })\n  length(allpaths[temp_bool])\n})\n```\n\n\n\n\nThere has to be an easier way, but I'm not really sure of it. There might be a way to infer this information by using the ```\nbetweeness```\n function which provides the betweeness centrality measurements, but I'm not that well read up on graph theory.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Dijkstra Shortest-Paths fast recalculation if only an edge got removed\r\n                \r\nI'm trying to calculate the shortest paths. This does work with the below pasted implementation of Dijkstra. However I want to speed the things up. \n\nI use this implementation to decide to which field I want to go next. The graph represents an two dimensional array where all fields are connected to each neighbours. But over time the following happens: I need to remove some edges (there are obstacles). The start node is my current position which does also change over time.\n\nThis means:\n\n\nI do never add a node, never add a new edge, never change the weight of an edge. The only operation is removing an edge\nThe start node does change over time\n\n\nQuestions: \n\n\nIs there an algorithm wich can do a fast recalculation of the shortest-paths when I know that the only change in the graph is the removal of an edge?\nIs there an algorithm wich allows me to fast recalculate the shortest path when the start node changes only to one of it's neighbours?\nIs another algorithm maybe better suited for my problem?\n\n\nThx for your help\n\n```\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\nusing System.Text;\n\npublic class Dijkstra<T>\n{\n    private Node<T> calculatedStart;\n\n    private ReadOnlyCollection<Node<T>> Nodes {\n        get ;\n        set ;\n    }\n\n    private ReadOnlyCollection<Edge<T>> Edges {\n        get;\n        set;\n    }\n\n    private List<Node<T>> NodesToInspect {\n        get;\n        set ;\n    }\n\n    private Dictionary<Node<T>, int> Distance {\n        get ;\n        set ;\n    }\n\n    private Dictionary<Node<T>, Node<T>> PreviousNode {\n        get;\n        set ;\n    }\n\n    public Dijkstra (ReadOnlyCollection<Edge<T>> edges, ReadOnlyCollection<Node<T>> nodes)\n    {\n        Edges = edges;\n        Nodes = nodes;\n        NodesToInspect = new List<Node<T>> ();\n        Distance = new Dictionary<Node<T>, int> ();\n        PreviousNode = new Dictionary<Node<T>, Node<T>> ();\n\n        foreach (Node<T> n in Nodes) {\n            PreviousNode.Add (n, null);\n            NodesToInspect.Add (n);\n            Distance.Add (n, int.MaxValue);\n        }\n    }\n\n    public LinkedList<T> GetPath (T start, T destination)\n    {\n        Node<T> startNode = new Node<T> (start);\n        Node<T> destinationNode = new Node<T> (destination);\n\n        CalculateAllShortestDistances (startNode);\n\n        // building path going back from the destination to the start always taking the nearest node\n        LinkedList<T> path = new LinkedList<T> ();\n        path.AddFirst (destinationNode.Value);\n\n        while (PreviousNode[destinationNode] != null) {\n            destinationNode = PreviousNode [destinationNode];\n            path.AddFirst (destinationNode.Value);\n        }\n\n        path.RemoveFirst ();\n\n        return path;\n    }\n\n    private void CalculateAllShortestDistances (Node<T> startNode)\n    {\n        if (startNode.Value.Equals (calculatedStart)) {\n            return;\n        }\n\n        Distance [startNode] = 0;\n\n        while (NodesToInspect.Count > 0) {\n            Node<T> nearestNode = GetNodeWithSmallestDistance ();\n            // if we cannot find another node with the function above we can exit the algorithm and clear the\n            // nodes to inspect because they would not be reachable from the start or will not be able to shorten the paths...\n            // this algorithm does also implicitly kind of calculate the minimum spanning tree...\n            if (nearestNode == null) {\n                NodesToInspect.Clear ();\n            } else {\n                foreach (Node<T> neighbour in GetNeighborsFromNodesToInspect(nearestNode)) {\n                    // calculate distance with the currently inspected neighbour\n                    int dist = Distance [nearestNode] + GetDirectDistanceBetween (nearestNode, neighbour);\n\n                    // set the neighbour as shortest if it is better than the current shortest distance\n                    if (dist < Distance [neighbour]) {\n                        Distance [neighbour] = dist;\n                        PreviousNode [neighbour] = nearestNode;\n                    }\n                }\n                NodesToInspect.Remove (nearestNode);\n            }\n        }\n\n        calculatedStart = startNode;\n    }\n\n    private Node<T> GetNodeWithSmallestDistance ()\n    {\n        int distance = int.MaxValue;\n        Node<T> smallest = null;\n\n        foreach (Node<T> inspectedNode in NodesToInspect) {\n            if (Distance [inspectedNode] < distance) {\n                distance = Distance [inspectedNode];\n                smallest = inspectedNode;\n            }\n        }\n\n        return smallest;\n    }\n\n    private List<Node<T>> GetNeighborsFromNodesToInspect (Node<T> n)\n    {\n        List<Node<T>> neighbors = new List<Node<T>> ();\n\n        foreach (Edge<T> e in Edges) {\n            if (e.Start.Equals (n) && NodesToInspect.Contains (n)) {\n                neighbors.Add (e.End);\n            }\n        }\n\n        return neighbors;\n    }\n\n    private int GetDirectDistanceBetween (Node<T> startNode, Node<T> endNode)\n    {\n        foreach (Edge<T> e in Edges) {\n            if (e.Start.Equals (startNode) && e.End.Equals (endNode)) {\n                return e.Distance;\n            }\n        }\n\n        return int.MaxValue;\n    }\n}\n```\n\n    ", "Answer": "\r\n\nIs there an algorithm wich can do a fast recalculation of the shortest-paths when I know that the only change in the graph is the removal of an edge?\nIs there an algorithm wich allows me to fast recalculate the shortest path when the start node changes only to one of it's neighbours?\n\nThe answer to both of these questions is yes.\n\nFor the first case, the algorithm you're looking for is called LPA* (sometimes, less commonly, called Incremental A*.  The title on that paper is outdated).  It's a (rather complicated) modification to A* that allows fast recalculation of best paths when only a few edges have changed.\nLike A*, LPA* requires an admissible distance heuristic.  If no such heuristic exists, you can just set it to 0.  Doing this in A* will essentially turn it into Djikstra's algorithm; doing this in LPA* will turn it into an obscure, rarely-used algorithm called DynamicSWSF-SP.\n\nFor the second case, you're looking for D*-Lite.  It is a pretty simple modification to LPA* (simple, at least, once you understand LPA*) that does incremental pathfinding as the unit moves from start-to-finish and new information is gained (edges are added/removed/changed).  It is primarily used for robots traversing an unknown or partially-known terrain.\n\nI've written up a fairly comprehensive answer (with links to papers, in the question) on various pathfinding algorithms here.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest Path in a Trie\r\n                \r\nFor a Data Structures project, I must find the shortest path between two words like \"cat\" and \"dog but i'm only allowed to change one letter at a time. I'm trying to do it by implementing a trie, and can't seem to be able to implement a shortest path search.\n\ncat -> cot -> cog -> dog\n\nAll the words will be of the same length and I am populating them from a dictionary file.\nWe must move from word to word. So the word in between must be a valid word.\n\nI think it's not really possible using a trie, but anyone have any knowledge?\n    ", "Answer": "\r\nYou want to use a VP-Tree  and the algorithm is called Levenshtein distance\nA C implementation can be found here, the code is far too long to post as an answer:\nC VP-Tree\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "single_source_shortest_path : criterion in case of multiple shortest paths?\r\n                \r\nIn case more than one shortest path between two nodes is available, which is the criterion used by single_source_shortest_path to pick one path? \n    ", "Answer": "\r\nThere is none. Since it traverses the graph with a ```\nBFS```\nish approach, and the order it visits a node's neighbors, is determined by a for loop, and that has an arbitrary order.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path ( destination = origin )\r\n                \r\n\n  What algorithm can I apply to find the shortest path from a node,\n  throw all the other nodes and return to origin ?\n\n\n\n    ", "Answer": "\r\nThis link has C# ```\n( exact optimal solution )```\n implementation of Held–Karp algorithm that solves the problem in time O ( n^2 2^n ) :\n\nhttp://www.codeproject.com/Articles/762581/Held-Karp-algorithm-implementation-in-Csharp\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "What are the applications of the shortest-path-algorithm?\r\n                \r\nThe shortest path between nodes in a graph can be found by several algorithms (Dikstra, A-star, etc).\n\nBut what applications does this problem have? (I know quite a few already, but I would like to see many more examples).\n\nPlease give only one application/answer! Explain the application, and how it can be transformed to a shortest-path problem.\n    ", "Answer": "\r\nThere is an interesting, not directly obvious, application of the shortest path algorithms that is probably used quite often in algorithmic trading and financial sector that deals with trading assets and goods.\n\nImagine that you could convert 1000 USD to 950 EUR and then 950 EUR to 1020 CAD which you convert back to 1007 USD :) Just by converting from currency to currency you can make money.\n\nThis situation is called arbitrage opportunity. This can be done with any asset and between different markets.\n\nIn this case, the relations between assets are modeled as directed edge-weighted graph and finding so called negative-cycles in the graph is in fact finding these arbitrage opportunities.\n\nYou can see more details with nice explanation and examples here: http://algs4.cs.princeton.edu/44sp/\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Floyd warshall implementation appears to be missing a shortest path\r\n                \r\nI'm collecting a count of the shortest paths that floyd warshall finds. For this particular graph the shortest path for 1 -> 3 is 5, and there are two paths with this weight: 1->4->2->3, and 1->4->3. \n\nI wasn't sure the best way to display the graph, so I'm going to use a matrix, please feel free to suggest another way if you know of a better alternative.\n\n```\n //i = infinity, no path exists initially\n //for u==v, 0\n    1   2   3   4\n1|  0   i   8   2\n2|  i   0   2   i\n3|  i   7   0   6\n4|  i   1   3   0\n```\n\n\nSo when I run my code, I'm getting the count of shortest paths from 1 -> 3 as just 1, but there are most certainly 2 ways as I mentioned before.\n\nHere is the implementation of the algorithm:\n\n```\n //count[][] is initialized with a 0 if no path between [u][v], and 1 at [u][v] if there is a weight at [u][v]. \n\n    for (int k = 1; k <= N; k++){\n        for (int i = 1; i <= N; i++){\n            for (int j = 1; j <= N; j++){\n                if (dist[i][j] > dist[i][k] + dist[k][j]){\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                    counts[i][j] = 1;\n                }\n                else if (dist[i][j] == dist[i][k] + dist[k][j] && k != i && k != j){\n                    counts[i][j] ++;                \n                }\n            }\n        }\n    }\n```\n\n\nI basically copy/pasted the code from the wikipedia page and modified to keep the count. \n\nUpdate: I should mention that I am getting the correct shortest length for all vertices, and for all of them I'm getting the correct count except for [1][3].\n\nPrintout of full output:\n\n```\n// Shortest paths              // counts\n    1    2    3    4               1    2    3    4    \n1   0    3    5    2           1   1    1    1    1\n2   i    0    2    8           2   0    1    1    1      \n3   i    7    0    6           3   0    2    1    1 \n4   i    1    3    0           4   0    1    2    1\n```\n\n\nUpdate: Stepping through the code line by line, we find a shortest path from 1->3 of weight 5 when k = 4, i = 1, j = 3.  \n\nUpdate: Reading the wikipedia entry for the Floyd-Warshall algorithm, I've gathered that when k = 4, we are checking for paths going through the vertices {1, 2, 3, 4}. However, in every iteration of k we will only look at [1][3] only once. I think maybe this is the problem. \n    ", "Answer": "\r\nIf you are using a two dimensional int array to store your data, it would be best to change your double loop to run from 0 to N-1 to avoid any potential errors. I did that and the results are correct (shortest distance from 1->3 is 5). Here is the updated code and printout:\n\n```\n     //count[][] is initialized with a 0 if no path between [u][v], and 1 at [u][v] if there is a weight at [u][v]. \n    int N = 4;\n    int max = 1000000;\n    int[][] dist = new int[N][N];\n    int[][] counts = new int[N][N];\n    dist[0][0] = 0;         dist[0][1] = max;   dist[0][2] = 8;     dist[0][3] = 2;\n    dist[1][0] = max;       dist[1][1] = 0;     dist[1][2] = 2;     dist[1][3] = max;\n    dist[2][0] = max;       dist[2][1] = 7;     dist[2][2] = 0;     dist[2][3] = 6;\n    dist[3][0] = max;       dist[3][1] = 1;     dist[3][2] = 3;     dist[3][3] = 0;\n    //initialize counts\n    for (int i=0; i<N; i++){\n        for (int j=0; j<N; j++){\n            if (dist[i][j]<max){\n                counts[i][j]=1;\n            }\n        }\n    }\n    for (int k = 0; k < N; k++){\n        for (int i = 0; i < N; i++){\n            for (int j = 0; j < N; j++){\n                if (dist[i][j] > dist[i][k] + dist[k][j]){\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                    counts[i][j] = 1;\n                }\n                else if (dist[i][j] == dist[i][k] + dist[k][j] && k != i && k != j){\n                    counts[i][j] ++;                \n                }\n            }\n        }\n    }\n    System.out.println(\"i  1 2 3 4\");\n    for (int i=0; i<N; i++){\n        System.out.print(i+1 + \": \");\n        for (int j=0; j<N; j++){\n            System.out.print(dist[i][j]>=max ? \"i \":dist[i][j] + \" \");\n        }\n        System.out.println();\n    }\n    System.out.println();\n    System.out.println(\"i  1 2 3 4\");\n    for (int i=0; i<N; i++){\n        System.out.print(i+1 + \": \");\n        for (int j=0; j<N; j++){\n            System.out.print(counts[i][j] + \" \");\n        }\n        System.out.println();\n    }\n```\n\n\nPrintout:\ni  1 2 3 4\n1: 0 3 5 2 \n2: i 0 2 8 \n3: i 7 0 6 \n4: i 1 3 0 \n\ni  1 2 3 4\n1: 1 1 1 1 \n2: 0 1 1 1 \n3: 0 2 1 1 \n4: 0 1 2 1 \n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Time complexity of shortest path algorithm\r\n                \r\nSo I wrote an algorithm that finds the number of distinct shortest paths in an undirected, unweighted graph. I believe it is correct and I'm having trouble figuring out what the running time is. All help is greatly appreciated! \n\n```\nshortestPaths(undirected graph G, startNode v, endNode end)\n    initialize  all levels of nodes to -1\n    count = 1;\n    initialize queue Q = {v}\n    level(v) = 0\n\n    while Q is not empty\n        curr = pop(Q)\n\n        if( curr == end)\n            w = pop(Q)\n            while(level(w)==level(curr))\n                if(w == end)\n                    count++\n                w=pop(Q)\n            return count\n\n        for all neighbors (nxt) of node curr do \n            if( level(nxt) == -1 )\n                level(nxt) = level(curr) + 1\n                Push(Q, nxt)\n            else if( level(nxt) == level(curr) + 1 )\n                Push(Q, nxt)\n            else if( level(nxt) > level(curr) + 1)\n                Level(nxt) = Level(curr) + 1\n    return count        \n```\n\n    ", "Answer": "\r\nRun time of your algorithm is exponential. You can avoid this by not pushing a vertex into heap several times, but instead by associating a counter with every vertex and incrementing it with every new path to this vertex.\n\nTry something like this:\n\n```\ninitialize  all counts of nodes to 0                     // added\ncounts(v) = 1                                            // added\n...\nwhile Q is not empty\n    curr = pop(Q)\n\n    if( curr == end)\n        return counts(curr)\n\n    for all neighbors (nxt) of node curr do \n        if( level(nxt) == -1 )\n            level(nxt) = level(curr) + 1\n            counts(nxt) = counts(curr)                   // added\n            Push(Q, nxt)\n        else if( level(nxt) == level(curr) + 1 )\n            counts(nxt) += counts(curr)                  // added & removed\nreturn 0\n```\n\n\nAnd this has the same complexity as BFS - ```\nO(|E|+|V|)```\n.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "A* find the second shortest path\r\n                \r\nI am trying to achieve 2nd, preferably nth shortest path using the A* pathfinding algorithm. I have implemented the shortest path already:\n\n```\nwhile(open.length > 0) {\n    max = worldSize;\n    min = -1;\n    for(i in open) {\n        if(open[i].f < max) {\n            max = open[i].f;\n            min = i;\n        }\n    }\n\n    node = open.splice(min, 1)[0];\n    if(node.value === nodeEnd.value) {\n        path = closed[closed.push(node)-1];\n        do {\n            result.push({x: path.x, y:path.y});\n        } while(path = path.parent);\n            open = closed = astar = [];\n        result.reverse();\n    } else {\n        neighbors = findNeighbors(node.x, node.y);\n        for(i = 0; i < neighbors.length; ++i) {\n            path = newNode(node, neighbors[i]);\n            if(!astar[path.value]) {\n                path.g = node.g + manhattanDistance(neighbors[i], node);\n                path.f = path.g + manhattanDistance(neighbors[i], nodeEnd);\n                open.push(path);\n                astar[path.value] = true;\n            }\n\n        }\n        closed.push(node);\n    }   \n}\n```\n\n\nWhat can I do? I have zero experience in this and don't even understand the algorithm to its fullest (still researching at the moment). Thank you.\n    ", "Answer": "\r\nSo this problem is in general NP hard. Since you only need the second shortest path, you can do it tractably. Basically, given the shortest path, you generate a collection of graphs by taking the original graph and removing one edge from the shortest path. So if you have a shortest path of length N, on a graph G(E,N), you end up with N graphs of G(E-1,V). Now you run A* on each of these graphs, and the shortest one is your second shortest path, as is it the shortest path which is different from the original shortest path by at least one edge.\n\nThis also shows why it is NP hard in practice. If I want the third shortest path, I have to to the following procedure only removing one edge from each of the two shortest paths, and the number of such pairs grows exponentially. N->N^2->N^3 etc\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "find ALL shortest paths in 2D array\r\n                \r\nI try to figure out how to find ALL shortest paths in my data strucutre, but trying it with a recursive approach failed so far. An example input looks like this: (s= start cell, e= end cell). I want to find all shortes ways from 's' to 'e' and store them in an ArrayList.\n\n```\n. . . . .\n. s . . .\n. . . . .\n. . . e .\n. . . . . \n. . . . .\n```\n\n\nthe Cell class looks like this and represents one cell in the above matrix: \n\n```\npublic class Cell {\n    private int line;\n    private int column;\n    private char character;\n    ...\n    public Cell(int line, int column) {\n        this.line = line;\n        this.column = column;\n    }\n\n}\n```\n\n\nI also have a Field Class, which contains an ArrayList with all nodes in it, and the total number of columns and lines which represent the field (in the above case, columns=5, lines=6, and List contains all 30 Cells of the field).\n\n```\npublic class Field {\n    private List<Cell> cells;\n    private int lines;\n    private int columns;\n    ...\n    }\n\n```\n\n\nand what I tried so far was:\n\n```\n// starti= line-index of cell s, starj= column-index of cell s\n// should create an ArrayList<Cell> current which contains one shortest path, should add current to the \n// ArrayList<ArrayList<Cell>> path, which contains all shortest paths.\nprivate void shortpath (int starti, int startj, int endi, int endj) {\n\n        if (endi == starti && endj == startj) {\n            current = new ArrayList<Cell>();\n            current.add(new Cell(starti, startj));\n            path1.add(current);\n            return;\n        }\n\n        if (starti < endi) {\n            shortpath (starti+1, startj, endi, endj);\n            current.add(new Cell(starti, startj));\n        }\n        if (startj < endj) {    \n            shortpath (starti, startj+1, endi, endj);\n            current.add(new Cell(starti, startj));\n        }\n}\n```\n\n\nI do not really know how to do it better. \nThanks in advance, \nPatrick\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Find shortest path on SVG Object\r\n                \r\nI have an SVG object with a floor map which is made from a creator user and I want to find dynamically the shortest path between 2 points on this object.\nDijkstra algorithm is the better solution for finding shortest path into a graph but this solution required the knowledge of all nodes of graph.\nI think that there are two solutions to make the shortest path.\n\nSolution No1: http://postimg.org/image/sok88bsgd/\n\nWhen user creates the floor map should make simultaneously the graph of this map. In other words user should make all of possible path in this map. The advantage of this solution is that the calculation of the shortest path is very fast but the disadvantage is that the creator should make all the possible path with his hand.\n\nSolution No2: http://postimg.org/image/4c2bd7smr/\n\nThe system calculate all of the SVG object and calculate the shortest path. The huge disadvantage of this solution is that the calculation is very very slow.\nDo you have a better solution? \nThank you for your response.\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Variation (complex?) on the shortest path\r\n                \r\nI have the following problem. Given a directed graph G=(V,E) with edge costs cij between all edges {i,j}. We have multiple sources, say s1,...,sk, and one target, say t. The problem is to find the lowest combined costs going from s1,...sk to t, where the total amount of visited vertexes by all different paths is M. (The sources and target don't count as visited vertexes and 0 <= M <= |V|-k+1, so if M = 0 all paths go directly from source to target.)\n\nI came up with the following, but haven't found a solution yet. \n\n\nThe problem is similar to multiple targets (t1,...,tk) and one source by just reversing all the edges and making the sources targets and the target source. I thought this could be useful since e.g. Dijkstra computes shortest path from one source to all other vertexes in the graph. \nWith just one target and one source one can find the shortest path with max. amount of visited vertexes M with the Bellman Ford algorithm. This is done by increasing the number of visited vertexes iteratively. \nThe problem of finding the shortest path from one source to one target while vertexes v1,...,vk have to be visited can, for small k, be solved as follows: \ni) compute shortest path between all vertexes.\nii) check which of the k! permutations is the shortest.\nI thought this could be useful when transforming my adjusted problem at 1) into the problem of going from one source to one \"supertarget\", with mandatory visits at the \"old\" targets t1=v1,...,tk=vk.\n\n\nUnfortunately, combining 1, 2 and 3 doesn't provide a solution but it may help. Does anyone know the solution? Can this be solved efficiently?\n    ", "Answer": "\r\nWhy not do a separate Dijkstra for each s, and later sum the costs?\n\nSomething like:\n\n```\nfloat totalCost;\nfor (int i=0; i<k; i++)\n  totalCost += Dijkstra(myGraph,s[i],t);\n```\n\n\nI hope I understood the question correctly.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "find ALL shortest paths in 2D array\r\n                \r\nI try to figure out how to find ALL shortest paths in my data strucutre, but trying it with a recursive approach failed so far. An example input looks like this: (s= start cell, e= end cell). I want to find all shortes ways from 's' to 'e' and store them in an ArrayList.\n\n```\n. . . . .\n. s . . .\n. . . . .\n. . . e .\n. . . . . \n. . . . .\n```\n\n\nthe Cell class looks like this and represents one cell in the above matrix: \n\n```\npublic class Cell {\n    private int line;\n    private int column;\n    private char character;\n    ...\n    public Cell(int line, int column) {\n        this.line = line;\n        this.column = column;\n    }\n\n}\n```\n\n\nI also have a Field Class, which contains an ArrayList with all nodes in it, and the total number of columns and lines which represent the field (in the above case, columns=5, lines=6, and List contains all 30 Cells of the field).\n\n```\npublic class Field {\n    private List<Cell> cells;\n    private int lines;\n    private int columns;\n    ...\n    }\n\n```\n\n\nand what I tried so far was:\n\n```\n// starti= line-index of cell s, starj= column-index of cell s\n// should create an ArrayList<Cell> current which contains one shortest path, should add current to the \n// ArrayList<ArrayList<Cell>> path, which contains all shortest paths.\nprivate void shortpath (int starti, int startj, int endi, int endj) {\n\n        if (endi == starti && endj == startj) {\n            current = new ArrayList<Cell>();\n            current.add(new Cell(starti, startj));\n            path1.add(current);\n            return;\n        }\n\n        if (starti < endi) {\n            shortpath (starti+1, startj, endi, endj);\n            current.add(new Cell(starti, startj));\n        }\n        if (startj < endj) {    \n            shortpath (starti, startj+1, endi, endj);\n            current.add(new Cell(starti, startj));\n        }\n}\n```\n\n\nI do not really know how to do it better. \nThanks in advance, \nPatrick\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Optimal substructure of shortest path and Dijkstra\r\n                \r\nI have very well understood Optimal substructure property of shortest path. Which says that-\n\nA shortest path from x to y via z contains a shortest path from x to\nz.\n\nNow I want to understand how Dijkstra's algorithm is exploiting this property. All Dijkstra does is- Find minimum at current time and finalise that vertex's shortest distance.\nHow Dijkstra's algorithm is making use of Optimal substructure property of shortest path?.\nI have referred many sources and nowhere found any connecting relation in these two.\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Get subgraph of shortest path between n nodes\r\n                \r\nI have an unweighted graph and I want to get a subgraph that has just the nodes and edges that contain the shortest paths between n known nodes.  In this case 3 nodes (11, 29, & 13 are the names).\n\nQuestion\n\nHow can I get a subgraph of shortest path between n nodes in R?\n\nMWE\n\n```\nlibrary(ggraph)\nlibrary(igraph)\n\nhs <- highschool[highschool$year == '1958',]\nset.seed(11)\ngraph <- graph_from_data_frame(hs[sample.int(nrow(hs), 60),])\n\n\n# plot using ggraph\nggraph(graph, layout = 'kk') + \n    geom_edge_fan() + \n    geom_node_text(aes(label = name)) \n```\n\n\n\n\nDesired Output\n\nThe desired output would be the following green subgraph (Or close, I'm eyeballing the graph above and visually picking out what would be the subgraph) ignoring/removing the other nodes and edges.\n\n\n    ", "Answer": "\r\nYou can't find the shortest path between n nodes. Since the shortest path is defined only between two nodes.   \n\nI think you want shortest path from ```\n1```\n node to other ```\nn-1```\n node you can use\n```\nget_all_shortest_paths(v, to=None, mode=ALL)```\n  from ```\nigraph```\n library.  \n\n\nv - the source for the calculated paths\nto - a vertex selector describing the destination for the\ncalculated paths. This can be a single vertex ID, a list of vertex\nIDs, a single vertex name, a list of vertex names. None means all the vertices.\nmode - the directionality of the paths. IN means to calculate\nincoming paths, OUT mean to calculate outgoing paths, ALL means to calculate both ones.  \n\n\nReturns: all of the shortest path from the given node to every other reachable node in the graph in a list.\nget_all_shortest_paths  \n\nSo, now you have to create a graph from a list of the shortest paths. \n\n\nInitialize an empty graph then add all path to it from the list of\nthe path\nadding path in graph   \n\nOR   \nmake a graph for every shortest path found and take graphs union.\nunion igraph\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Find number of non edge-intersecting shortest paths\r\n                \r\nGiven a weighted unoriented graph, start and finish vertices, I need to find number of exactly equal(in sum of weights) shortest paths that do not intersect at any edge. \n\nI tried to use the Ford-Fulkerson's algorithm  here but it gives only the potential maximum number and does not find shortest paths. \n\nUse of Dijkstra's algorithm  to find a path during Ford-Fulkerson does not help either since it may find path with one or more edges that connects paths in optimal solution.\n\nAs far as I see, there are some answers to a similar problems but with an unweighted and oriented graphs. I guess I need some kind of brute force method that will remove edges in some order. Or may be there is a known way to solve this problem? Thanks.\n\nEdit 1: here is the graph that shows an example of Dijkstra's going the wrong way. The red edge (most likely) will be found 1st and it will make optimal solution impossible. I see the goal of algorithm is to remove somehow all the red edges and do what Vedang Mehta suggested\n\n\n    ", "Answer": "\r\nWe can first calculate dis[u] := length of shortest path from start to u.\n\nThen we construct a direct graph(flow network) G' from dis[] and G:\n\ncheck every edge(u,v) in G\n\n```\nif dis[u] = dis[v] + weight(u,v) then add a direct edge (u->v) to G'(capacities 1)\n\nif dis[v] = dis[u] + weight(u,v) then add a direct edge (v->u) to G'(capacities 1)\n```\n\n\nThe maximum number of non edge-intersecting shortest paths is just \n\nthe maximum flow from start vertex to finish vertex on G'.\n\nProof of Correctness\n\nobvious.\n\nHere is an implementation\n\nhttp://lemon.cs.elte.hu/pub/doc/latest-svn/a00238.html\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "neo4j uni directional shortest path\r\n                \r\nI have a graph with multiple nodes and edges that have a relation of (links_to) between them. Nodes represent web pages and edges a hyperlink. Pages have many links, inclusive reciprocal links.\n\nProblem:\n\nWhen I run the shortest path between A and C I'm getting a path that contains an invalid direction. Shortest path A-C\n\nInstead of A->B->C I'm getting A<-B->C. \n\nHow can I get the shortest path in the right direction? \n\nThis is my query:\n\n```\nMATCH (home { Label:'/' }),(paris { Label:'/paris/2012/intervenants.php' }), \np = shortestPath((home)-[:links_to]-(paris))\nRETURN p\n```\n\n\nhttps://i.stack.imgur.com/VHTQ3.png\n    ", "Answer": "\r\nYou have to add ```\n*```\n (for many relationships between nodes) and direction:\n\n\n  MATCH (home { Label:'/' }), (paris {\n  Label:'/paris/2012/intervenants.php' }),\n  p =\n  shortestPath((home)-[:links_to*]->(paris))\n  RETURN p\n\n\nThe good example of cypher query is in link.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Incorrect shortest path in Python igraph?\r\n                \r\nWhen I run this for node 11 (you get to enter that) it produces a shortest path of 90 via nodes 0,1,4,11. However, there is a shorter path of 85 via nodes 0,2,6,4,11 of length 85.\nIt appears to be an error in the igraph function, is someone able to confirm or advise otherwise please?\nCheers, Paul\nigraph shortest path which is incorrect I think\n```\n    M = np.array(\n    [# W    1    2    3    4    5    6    7    8   9    10   11   12   13 \n    [  0,  20,  35,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0],   #W\n    [ 20,   0,   0,   0,  50,  35,   0,   0,   0,   0,   0,   0,   0,   0],   #1\n    [ 35,   0,   0,  15,  40,  0,   20,   0,   0,   0,   0,   0,   0,   0],   #2\n    [ 25,   0,  15,   0,   0,   0,  35,  25,   0,   0,   0,   0,   0,   0],   #3     \n    [  0,  50,  40,   0,   0,  20,  10,   0,  20,   0,   0,  20,   0,   0],   #4\n    [  0,  35,   0,   0,  20,   0,   0,   0,   0,   0,   0,  60,   0,   0],   #5\n    [  0,   0,  20,  35,  10,   0,   0,  25,  15,  15,   0,   0,  35,   0],   #6\n    [  0,   0,   0,  25,   0,   0,  25,   0,   0,  20,   0,   0,   0,   0],   #7\n    [  0,   0,   0,   0,  20,   0,  15,   0,   0,   0,  30,  30,  40,   0],   #8\n    [  0,   0,   0,   0,   0,   0,  15,  20,   0,   0,   0,   0,  20,   0],   #9\n    [  0,   0,   0,   0,   0,   0,   0,   0,  30,   0,   0,  15,  15,  10],   #10\n    [  0,   0,   0,   0,  20,  60,   0,   0,  30,   0,  15,   0,   0,  20],   #11\n    [  0,   0,   0,   0,   0,   0,  35,   0,  40,  20,  15,   0,   0,  15],   #12\n    [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  10,  20,  15,   0],   #13\n    \n    ])\n#M[M>0]=1\n\n\n\n#weights=[0.6, 0.7, 0.3, 0.6, 0.8, 0.3, 0.7, 0.9, 0.6, 0.3, 0.8, 0.9, 0.4, 0.5, 0.7, 0.3, 0.4, 1.8, 1.5, 1.7, 0.6, 0.5, 1.4, 1.5, 1.6, 1.8, 1.2, 0.7, 1.5, 1.4, 0.6, 0.5, 1.3, 1.5, 1.2, 1.7, 1.2, 0.6, 1.7, 0.3, 1.6, 0.5, 1.2, 0.8, 0.4, 1.3, 1.7, 0.8, 0.8, 0.7, 0.6, 0.3, 0.8, 0.8, 0.4, 0.7, 0.5, 0.6, 0.8, 0.5]\nprint(\"input matrix is symmetrical =\", np.all((M == np.transpose(M))))\nprint()\nM=np.triu(M)\n\nm=ig.Graph.Weighted_Adjacency(M)\n\n\"\"\"for i in range(m.vcount()):\n# g.get_shortest_paths() returns a list of edge ID paths\n    results = m.get_shortest_paths(\n        0,\n        to=i,\n        weights=m.es[\"weight\"],\n        output=\"vpath\",\n        #mode=ALL\n    )\n    #print(i, sum(m.es[results[0]][\"weight\"]),m.es[results[0]][\"weight\"]), \n    #for n in results[i]:\n    #    print(\"{}\".format(m.vs[i][n]['name']))\"\"\"\n\n#for i in range(m.vcount()):\n#for i in range(12):\ni = int(input('input node number'))\nresults = m.get_shortest_paths(0,to=i,weights=m.es[\"weight\"],output=\"epath\")\n\nprint(\"Shortest path 'W' and {} is {} \".format( i,m.es[results[0]][\"weight\"]))\n\nif len(results[0]) > 0:\n    # Add up the weights across all edges on the shortest path\n    distance = 0\n    for e in results[0]:\n        distance += m.es[e][\"weight\"]\n    print(\"Shortest weighted distance is: \", distance)\nelse:\n    print(\"End node could not be reached!\")\n#spanning_tree = m.spanning_tree(weights=weights,return_tree=False)\nm.es[\"color\"] = \"black\"\nm.es[\"width\"] = 0.5\nm.es[results[0]][\"color\"] = \"red\"\nm.es[results[0]][\"width\"] = 3\nm.es[\"label_size\"]= 10\n\n\nfig, ax = plt.subplots(1,1,figsize=(16,24))\nig.plot(\n    m,\n    bbox=(512,512),    \n    vertex_size=1,    \n    target=ax,    \n    layout=np.multiply([(0,1),(1,2),(1,1),(1,0),(2,2),(2,3),(2,1),(2,0),(3,2),(3,0),(4,2),(4,3),(4,1),(5,2)],4),\n    edge_curve=0,\n    vertex_color=\"lightblue\",\n    vertex_label=range(m.vcount()),\n\n    edge_width=m.es[\"width\"],\n    edge_label=m.es[\"weight\"],\n    autocurve=False,   \n)\nplt.show()\n\nprint(\"Shortest path {0}\".format(distance))\n```\n\n    ", "Answer": "\r\nLooking at the image it seems like the graph is directed (you cant move both ways between nodes, only in the direction indicated by the arrow). So 4 and 6 is connected as ```\n4 -> 6```\n and in your path you use it as ```\n4 <- 6```\n that is not valid according to the image.\nSo I would say that igraph is correct and you are wrong.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "One-to-Many Shortest Path query support in Neo4j\r\n                \r\nDoes neo4j have support for one-to-many shortest path queries?\nAn example of such query would be: Given a node i, and a list of several other nodes N, compute the shortest paths from i to all the nodes that belong to N.\n\nI am aware of this thread: Neo4j shortest path (BFS) distances query variants, but it is specifically for one-to-all queries. \nMy question is for one-to-many queries.\n\nThank you.\n    ", "Answer": "\r\nTo get All paths from one node to multiple nodes\n\n```\nMATCH p = shortestPath((s:skill)-[r]->(s1:skill))\nWHERE id(s) = 123\nAND id(s1) IN [1,2,3]\n\nRETURN p\n```\n\n\nThis is the one way to get paths between one-to-many.\nI hope this is what you need.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "MySQL Shortest Path between two nodes\r\n                \r\nI have a MySQL table as defined below:\n\n```\nSELECT * FROM paths```\n\n\n```\nsource | destination\n1 | 2\n1 | 3\n2 | 4\n4 | 5\n3 | 5\n```\n\n\nI am trying to find the shortest path between 1 and 5 and not sure what SQL query would get that result. This is what I have right now:\n\n```\nWITH RECURSIVE cte AS\n(\n  SELECT destination, CAST(destination AS CHAR(200)) AS path\n  FROM paths WHERE source = 1\n  UNION ALL\n  SELECT c.destination, CONCAT(cte.path, \",\", c.destination)\n  FROM paths c JOIN cte ON cte.destination=c.source\n)\nSELECT * FROM cte ORDER BY path;\n```\n\n\nI am not sure how I would limit the query above to only find paths that end at 5. Example of what I am looking for:\n\nAll paths between 1 to 5:\n\n\n(1 -> 2), (2 -> 4), (4 -> 5)\n(1 -> 3), (3 -> 5)\n\n\nIn this case, the shortest path that I want the query to return is the second option.\n    ", "Answer": "\r\nYou're not too far away. Just add the paths' lengths in the recursion. Then filter the final result for the destination node and use ```\nORDER BY```\n the paths' lengths and ```\nLIMIT```\n to get only one shortest path (if there are more than one path with the minimum length one of them is chosen randomly).\n\n```\nWITH RECURSIVE\ncte\nAS\n(\nSELECT p.destination,\n       concat(p.source, '->', p.destination) path,\n       1 length\n       FROM paths p\n       WHERE p.source = 1\nUNION ALL\nSELECT p.destination,\n       concat(c.path, '->', p.destination) path,\n       c.length + 1 length\n       FROM cte c\n            INNER JOIN paths p\n                       ON p.source = c.destination\n       WHERE c.destination <> 5\n)\nSELECT c.path\n       FROM cte c\n       WHERE c.destination = 5\n       ORDER BY c.length\n       LIMIT 1;\n```\n\n\ndb<>fiddle\n\nOne thing you might consider though is loop handling, if there can be loops in the graph. Unless node 5 is in such a loop you'd have an endless recursion.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path with a maximum number of vertices\r\n                \r\nI want to find the shortest path between two vertices with an additional constraint : max n vertices can be visited. The graph is directed, connected, non negative weights and may contain cycles.\n\nExample:\n\n\n\n\nShortest path 0->2 with n = 2 is 18\nShortest path 0->3 with n = 3 is 22\nShortest path 0->3 with n = 4 is 9\n\n\nSo far I've implemented Djikstras algorithm to get the simple shortest path, and my idea was to keep a counter of the current vertices visited, if it exceeds n it takes one or more steps back and tries with another path.. but as far as I know Djikstras can't be used for backtracking as explained here.\n\nAnother idea is somehow to store every path between every node in a table. But I'm not really sure how Djikstra can discover the path 0->2 with weight 18 since it is not really a shortest path...\n\nDoes anyone have any ideas how to tackle this problem?\n    ", "Answer": "\r\nDivided each vertices into ```\nn```\n vertices, that is, for vertices ```\nu```\n, we create ```\nn```\n vertices expressed as ```\n(u, 1) ... (u, n)```\n, the second number shows the number of steps to this vertices. For each edge from u to v, we create an edge from (u, i) to (v, i+1) where ```\n1<=i<=n-1```\n in new graph. Now if you want to calculate the shortest path between u and v with n, just do Dijkstra from (u, 1), then your answer is ```\nmin(result (v, i) | 1<=i<=n)```\n\n\nThe total number of vertices can be n*n, so the complexity is about ```\nO(n^2*log(n^2))```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "K Shortest Path in R: igraph\r\n                \r\nI have to find the K Shortest Path,However the below code i tried gives the same path when i choose different ```\nK```\n Values and the distance computed is not correct.\n\nMy dataset is ```\nmy.graph```\n with class ```\nigraph```\n\n\n```\ndput(my.graph)\n    structure(list(169, FALSE, c(22, 1, 2, 1, 2, 3, 114, 3, 4, 5, \n    4, 5, 6, 6, 7, 7, 8, 9, 8, 110, 78, 159, 9, 159, 30, 11, 13, \n    160, 11, 66, 160, 138, 14, 13, 14, 15, 81, 16, 15, 17, 16, 17, \n    18, 18, 19, 130, 19, 62, 62, 23, 42, 22, 22, 22, 23, 24, 161, \n    24, 25, 25, 26, 64, 26, 28, 161, 29, 28, 29, 47, 48, 53, 142, \n    31, 30, 32, 31, 32, 33, 33, 34, 35, 118, 34, 36, 35, 37, 36, \n    37, 38, 39, 38, 162, 40, 39, 40, 41, 41, 42, 43, 44, 43, 44, \n    45, 45, 46, 47, 46, 47, 47, 49, 48, 49, 50, 51, 50, 52, 51, 52, \n    53, 60, 53, 54, 53, 55, 54, 56, 55, 57, 56, 57, 58, 58, 59, 59, \n    60, 60, 60, 63, 162, 62, 62, 63, 64, 65, 65, 66, 166, 68, 163, \n    164, 69, 165, 68, 70, 69, 71, 70, 71, 72, 72, 73, 112, 73, 74, \n    75, 74, 76, 75, 76, 77, 78, 77, 78, 110, 78, 79, 80, 79, 146, \n    80, 81, 82, 81, 81, 82, 137, 164, 84, 85, 84, 86, 85, 86, 87, \n    87, 164, 165, 89, 89, 90, 90, 91, 92, 91, 93, 92, 93, 94, 95, \n    94, 165, 95, 163, 97, 97, 98, 99, 98, 99, 100, 101, 100, 101, \n    102, 102, 163, 104, 166, 105, 104, 106, 105, 106, 107, 108, 107, \n    109, 108, 109, 166, 110, 110, 125, 116, 112, 113, 112, 112, 114, \n    113, 114, 115, 114, 126, 115, 116, 117, 118, 117, 119, 118, 118, \n    120, 119, 120, 121, 121, 122, 123, 122, 124, 168, 141, 123, 124, \n    125, 125, 125, 126, 140, 140, 128, 128, 129, 130, 129, 130, 130, \n    131, 131, 132, 133, 132, 134, 133, 134, 135, 135, 136, 137, 136, \n    137, 137, 139, 138, 139, 168, 143, 140, 140, 141, 142, 158, 167, \n    143, 167, 144, 145, 144, 145, 146, 146, 146, 148, 148, 149, 149, \n    150, 151, 150, 152, 151, 153, 152, 153, 154, 154, 155, 156, 155, \n    156, 157, 157, 158, 158, 158, 159, 160, 159, 160, 160, 160, 161, \n    161, 162, 162, 163, 163, 163, 164, 164, 164, 165, 165, 165, 166, \n    166, 166, 167, 167, 168, 168), c(0, 0, 1, 0, 1, 2, 2, 2, 3, 4, \n    3, 4, 5, 5, 6, 6, 7, 8, 7, 9, 9, 9, 8, 10, 10, 10, 11, 11, 10, \n    12, 12, 12, 13, 11, 13, 14, 14, 15, 14, 16, 15, 16, 17, 17, 18, \n    19, 18, 19, 20, 20, 21, 21, 0, 21, 20, 23, 23, 23, 24, 24, 25, \n    26, 25, 27, 27, 28, 27, 28, 29, 29, 29, 30, 30, 10, 31, 30, 31, \n    32, 32, 33, 34, 34, 33, 35, 34, 36, 35, 36, 37, 38, 37, 38, 39, \n    38, 39, 40, 40, 21, 42, 43, 42, 43, 44, 44, 45, 46, 45, 29, 46, \n    48, 29, 48, 49, 50, 49, 51, 50, 51, 52, 53, 52, 53, 29, 54, 53, \n    55, 54, 56, 55, 56, 57, 57, 58, 58, 59, 53, 59, 61, 61, 20, 19, \n    61, 26, 64, 64, 12, 67, 67, 67, 68, 68, 68, 67, 69, 68, 70, 69, \n    70, 71, 71, 72, 72, 72, 73, 74, 73, 75, 74, 75, 76, 77, 76, 77, \n    78, 9, 78, 79, 78, 80, 79, 80, 81, 80, 14, 81, 82, 83, 83, 84, \n    83, 85, 84, 85, 86, 86, 87, 88, 88, 88, 89, 89, 90, 91, 90, 92, \n    91, 92, 93, 94, 93, 95, 94, 96, 96, 96, 97, 98, 97, 98, 99, 100, \n    99, 100, 101, 101, 102, 103, 103, 104, 103, 105, 104, 105, 106, \n    107, 106, 108, 107, 108, 109, 9, 78, 110, 111, 111, 112, 72, \n    111, 113, 112, 113, 114, 2, 115, 114, 111, 116, 117, 116, 118, \n    117, 34, 119, 118, 119, 120, 120, 121, 122, 121, 123, 123, 123, \n    122, 123, 124, 124, 110, 115, 126, 127, 127, 127, 128, 129, 128, \n    129, 19, 130, 130, 131, 132, 131, 133, 132, 133, 134, 134, 135, \n    136, 135, 136, 82, 138, 12, 138, 139, 139, 127, 126, 123, 30, \n    142, 142, 139, 143, 143, 144, 143, 144, 145, 80, 145, 147, 147, \n    148, 148, 149, 150, 149, 151, 150, 152, 151, 152, 153, 153, 154, \n    155, 154, 155, 156, 156, 157, 142, 157, 9, 159, 10, 12, 11, 159, \n    23, 27, 61, 38, 96, 67, 102, 68, 83, 87, 95, 88, 68, 67, 109, \n    103, 142, 143, 123, 139), c(3, 1, 4, 2, 7, 5, 10, 8, 11, 9, 13, \n    12, 15, 14, 18, 16, 22, 17, 28, 25, 33, 26, 34, 32, 38, 35, 40, \n    37, 41, 39, 43, 42, 46, 44, 52, 0, 53, 51, 54, 49, 57, 55, 59, \n    58, 62, 60, 66, 63, 67, 65, 73, 24, 75, 72, 76, 74, 78, 77, 82, \n    79, 84, 80, 86, 83, 87, 85, 90, 88, 93, 89, 94, 92, 96, 95, 97, \n    50, 100, 98, 101, 99, 103, 102, 106, 104, 107, 68, 108, 105, \n    110, 69, 111, 109, 114, 112, 116, 113, 117, 115, 122, 70, 120, \n    118, 124, 121, 126, 123, 128, 125, 129, 127, 131, 130, 133, 132, \n    135, 119, 136, 134, 140, 47, 139, 48, 141, 137, 142, 61, 144, \n    143, 145, 29, 152, 147, 154, 150, 156, 153, 157, 155, 159, 158, \n    162, 160, 165, 163, 167, 164, 168, 166, 171, 169, 174, 20, 172, \n    170, 177, 175, 179, 176, 183, 36, 182, 180, 184, 181, 189, 187, \n    191, 188, 192, 190, 194, 193, 198, 197, 200, 199, 203, 201, 205, \n    202, 206, 204, 209, 207, 211, 208, 214, 213, 217, 215, 218, 216, \n    221, 219, 222, 220, 224, 223, 229, 226, 231, 228, 232, 230, 235, \n    233, 237, 234, 238, 236, 240, 19, 241, 173, 246, 161, 247, 244, \n    249, 245, 252, 6, 250, 248, 254, 251, 255, 243, 258, 256, 261, \n    81, 260, 257, 263, 259, 264, 262, 266, 265, 269, 267, 273, 268, \n    274, 270, 277, 242, 276, 275, 278, 253, 282, 281, 285, 283, 287, \n    45, 286, 284, 289, 288, 292, 290, 294, 291, 295, 293, 297, 296, \n    300, 298, 302, 185, 301, 299, 304, 31, 305, 303, 309, 279, 308, \n    280, 310, 272, 311, 71, 314, 307, 318, 316, 319, 317, 321, 178, \n    322, 320, 324, 323, 326, 325, 329, 327, 331, 328, 333, 330, 334, \n    332, 336, 335, 339, 337, 340, 338, 342, 341, 344, 312, 345, 343, \n    346, 21, 348, 23, 350, 27, 349, 30, 351, 347, 352, 56, 353, 64, \n    355, 91, 354, 138, 357, 148, 356, 212, 358, 225, 359, 149, 360, \n    186, 361, 195, 364, 151, 363, 196, 362, 210, 365, 146, 367, 227, \n    366, 239, 368, 313, 369, 315, 370, 271, 371, 306), c(3, 1, 52, \n    0, 4, 2, 7, 5, 252, 6, 10, 8, 11, 9, 13, 12, 15, 14, 18, 16, \n    22, 17, 174, 20, 240, 19, 346, 21, 28, 25, 73, 24, 348, 23, 33, \n    26, 350, 27, 145, 29, 304, 31, 349, 30, 34, 32, 38, 35, 183, \n    36, 40, 37, 41, 39, 43, 42, 46, 44, 140, 47, 287, 45, 54, 49, \n    139, 48, 53, 51, 97, 50, 57, 55, 352, 56, 59, 58, 62, 60, 142, \n    61, 66, 63, 353, 64, 67, 65, 107, 68, 110, 69, 122, 70, 75, 72, \n    311, 71, 76, 74, 78, 77, 82, 79, 84, 80, 261, 81, 86, 83, 87, \n    85, 90, 88, 93, 89, 355, 91, 94, 92, 96, 95, 100, 98, 101, 99, \n    103, 102, 106, 104, 108, 105, 111, 109, 114, 112, 116, 113, 117, \n    115, 120, 118, 124, 121, 135, 119, 126, 123, 128, 125, 129, 127, \n    131, 130, 133, 132, 136, 134, 141, 137, 354, 138, 144, 143, 152, \n    147, 357, 148, 365, 146, 154, 150, 359, 149, 364, 151, 156, 153, \n    157, 155, 159, 158, 162, 160, 246, 161, 165, 163, 167, 164, 168, \n    166, 171, 169, 172, 170, 177, 175, 241, 173, 179, 176, 182, 180, \n    321, 178, 184, 181, 302, 185, 189, 187, 360, 186, 191, 188, 192, \n    190, 194, 193, 361, 195, 198, 197, 363, 196, 200, 199, 203, 201, \n    205, 202, 206, 204, 209, 207, 211, 208, 362, 210, 214, 213, 356, \n    212, 217, 215, 218, 216, 221, 219, 222, 220, 224, 223, 358, 225, \n    229, 226, 367, 227, 231, 228, 232, 230, 235, 233, 237, 234, 238, \n    236, 366, 239, 277, 242, 247, 244, 255, 243, 249, 245, 250, 248, \n    254, 251, 278, 253, 258, 256, 260, 257, 263, 259, 264, 262, 266, \n    265, 269, 267, 273, 268, 274, 270, 310, 272, 370, 271, 276, 275, \n    309, 279, 282, 281, 308, 280, 285, 283, 286, 284, 289, 288, 292, \n    290, 294, 291, 295, 293, 297, 296, 300, 298, 301, 299, 305, 303, \n    314, 307, 371, 306, 344, 312, 368, 313, 318, 316, 369, 315, 319, \n    317, 322, 320, 324, 323, 326, 325, 329, 327, 331, 328, 333, 330, \n    334, 332, 336, 335, 339, 337, 340, 338, 342, 341, 345, 343, 351, \n    347), c(0, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 18, 20, 20, 22, \n    24, 26, 28, 30, 32, 34, 34, 34, 38, 40, 42, 44, 46, 46, 48, 50, \n    52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, \n    84, 88, 90, 92, 94, 96, 98, 102, 104, 106, 108, 110, 112, 114, \n    118, 118, 122, 124, 126, 128, 130, 130, 132, 134, 136, 138, 140, \n    142, 144, 146, 148, 150, 154, 156, 158, 162, 164, 164, 166, 168, \n    170, 172, 172, 174, 176, 178, 180, 182, 184, 186, 186, 188, 190, \n    192, 194, 196, 198, 198, 200, 202, 204, 206, 208, 210, 214, 214, \n    218, 220, 224, 226, 228, 230, 234, 236, 238, 240, 242, 244, 246, \n    250, 252, 252, 254, 256, 260, 262, 264, 266, 268, 270, 272, 276, \n    278, 280, 284, 286, 288, 290, 292, 294, 298, 298, 300, 302, 304, \n    306, 308, 310, 312, 314, 316, 318, 322, 326, 332, 336, 340, 346, \n    352, 358, 364, 368, 372), c(0, 4, 6, 10, 12, 14, 16, 18, 20, \n    22, 28, 34, 38, 44, 46, 50, 52, 54, 56, 58, 62, 66, 70, 70, 74, \n    76, 78, 80, 84, 86, 92, 96, 98, 100, 102, 106, 108, 110, 112, \n    116, 118, 120, 120, 122, 124, 126, 128, 130, 130, 132, 134, 136, \n    138, 140, 144, 146, 148, 150, 152, 154, 156, 156, 160, 160, 160, \n    162, 162, 162, 168, 174, 176, 178, 180, 184, 186, 188, 190, 192, \n    194, 198, 200, 204, 206, 208, 212, 214, 216, 218, 220, 224, 226, \n    228, 230, 232, 234, 236, 238, 242, 244, 246, 248, 250, 252, 254, \n    258, 260, 262, 264, 266, 268, 270, 272, 276, 278, 280, 282, 284, \n    286, 288, 290, 292, 294, 296, 298, 304, 306, 306, 308, 312, 314, \n    316, 318, 320, 322, 324, 326, 328, 330, 330, 332, 336, 336, 336, \n    340, 344, 346, 348, 348, 350, 352, 354, 356, 358, 360, 362, 364, \n    366, 368, 370, 370, 372, 372, 372, 372, 372, 372, 372, 372, 372, \n    372), list(c(1, 0, 1), structure(list(), .Names = character(0)), \n        structure(list(name = c(\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \n        \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \n        \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \n        \"28\", \"29\", \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \n        \"38\", \"39\", \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \n        \"48\", \"49\", \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \n        \"58\", \"59\", \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \n        \"68\", \"69\", \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \n        \"78\", \"79\", \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \n        \"88\", \"89\", \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \n        \"98\", \"99\", \"100\", \"101\", \"102\", \"103\", \"104\", \"105\", \"106\", \n        \"107\", \"108\", \"109\", \"110\", \"111\", \"112\", \"113\", \"114\", \"115\", \n        \"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\", \"123\", \"124\", \n        \"125\", \"126\", \"127\", \"128\", \"129\", \"130\", \"131\", \"132\", \"133\", \n        \"134\", \"135\", \"136\", \"137\", \"138\", \"139\", \"140\", \"141\", \"142\", \n        \"143\", \"144\", \"145\", \"146\", \"147\", \"148\", \"149\", \"150\", \"151\", \n        \"152\", \"153\", \"154\", \"155\", \"156\", \"157\", \"158\", \"159\", \"160\", \n        \"161\", \"162\", \"163\", \"164\", \"165\", \"166\", \"167\", \"168\", \"169\"\n        )), .Names = \"name\"), structure(list(DIST_KM_CNT = c(4.89, \n        1.45, 2.36, 1.45, 2.36, 1.18, 0, 1.18, 0.89, 1.47, 0.89, \n        1.47, 1.16, 1.16, 1.2, 1.2, 1.02, 0.79, 1.02, 0, 0, 1, 0.79, \n        0, 0.98, 1.03, 1.15, 0, 1.03, 1.35, 0.95, 0, 0.99, 1.15, \n        0.99, 1.53, 0, 1.22, 1.53, 1.37, 1.22, 1.37, 1.23, 1.23, \n        1.1, 0, 1.1, 1.38, 1.69, 3.49, 3.16, 1.38, 4.89, 1.38, 3.49, \n        1.51, 0, 1.51, 1.39, 1.39, 1.78, 0.947, 1.78, 1.17, 2.12, \n        3.26, 1.17, 3.26, 1.43, 0, 0, 15.58, 1.11, 0.98, 1.09, 1.11, \n        1.09, 1.43, 1.43, 1.15, 1.11, 0, 1.15, 1.13, 1.11, 1.96, \n        1.13, 1.96, 1.86, 2.48, 1.86, 0, 1.44, 2.48, 1.44, 2.38, \n        2.38, 3.16, 2.41, 1.691, 2.41, 1.691, 1.54, 1.54, 1.65, 4.14, \n        1.65, 1.43, 4.14, 0.572, 0, 0.572, 0.455, 0.558, 0.455, 0.54, \n        0.558, 0.54, 0.682, 0.638, 0.682, 0.42, 0, 0.624, 0.42, 0.47, \n        0.624, 0.895, 0.47, 0.895, 0.493, 0.493, 0.703, 0.703, 0.553, \n        0.638, 0.553, 4.52, 1.94, 1.69, 1.38, 4.52, 0.947, 2.647, \n        2.647, 1.35, 0, 1.66, 0, 0, 1.05, 0, 1.66, 1.31, 1.05, 1.54, \n        1.31, 1.54, 1.72, 1.72, 1.24, 0, 1.24, 0.94, 1.57, 0.94, \n        1.15, 1.57, 1.15, 0.77, 0.95, 0.77, 0.95, 0, 0, 1.38, 0.6, \n        1.38, 11.42, 0.6, 0.72, 2.64, 0.72, 0, 2.64, 0, 0.82, 0.708, \n        0.467, 0.708, 0.59, 0.467, 0.59, 0.828, 0.828, 1.047, 0.77, \n        0.517, 0.517, 0.897, 0.897, 0.727, 0.602, 0.727, 0.481, 0.602, \n        0.481, 0.726, 0.602, 0.726, 0.92, 0.602, 0.986, 0.44, 0.44, \n        0.513, 0.548, 0.513, 0.548, 0.721, 0.513, 0.721, 0.513, 0.564, \n        0.564, 0.937, 0.412, 0.576, 0.542, 0.412, 0.567, 0.542, 0.567, \n        0.497, 0.426, 0.497, 0.379, 0.426, 0.379, 0.987, 0, 0, 0.614, \n        1.321, 1.327, 0.912, 0, 1.327, 1.735, 0.912, 1.735, 1.577, \n        0, 1.188, 1.577, 1.321, 1.017, 1.057, 1.017, 1.239, 1.057, \n        0, 0.732, 1.239, 0.732, 0.877, 0.877, 1.548, 0.816, 1.548, \n        0.806, 0, 11.5, 0.816, 0.806, 0.689, 0.689, 0.614, 1.188, \n        1.357, 2.496, 1.028, 1.028, 1.432, 0.93, 1.432, 0.93, 0, \n        0.794, 0.794, 0.811, 1.395, 0.811, 1.323, 1.395, 1.323, 1.385, \n        1.385, 0.774, 1.53, 0.774, 1.53, 0, 0.841, 0, 0.841, 1.317, \n        7.75, 2.496, 1.357, 11.5, 15.58, 0.75, 0.905, 7.75, 1.317, \n        0.89, 0.593, 0.89, 0.593, 0.555, 11.42, 0.555, 1.18, 1.18, \n        0.87, 0.87, 2.63, 1.21, 2.63, 1.6, 1.21, 1.26, 1.6, 1.26, \n        1.09, 1.09, 1.12, 1.58, 1.12, 1.58, 1.42, 1.42, 0.54, 0.75, \n        0.54, 1, 1.03, 0, 0.95, 0, 1.03, 0, 2.12, 1.94, 0, 0.986, \n        0, 0.937, 0, 0.82, 1.047, 0.92, 0.77, 0, 0, 0.987, 0.576, \n        0.905, 1.317, 0, 1.317)), .Names = \"DIST_KM_CNT\")), <environment>), class = \"igraph\")\n```\n\n\nK Shortest Path logic \n\n```\n# find k shortest paths\nk.shortest.paths <- function(graph, from, to, k){\n  # first shortest path\n  k0 <- get.shortest.paths(graph,from,to, output='both')\n\n  # number of currently found shortest paths\n  kk <- 1\n\n  # list of alternatives\n  variants <- list()\n\n  # shortest variants\n  shortest.variants <- list(list(g=graph, path=k0$epath, vert=k0$vpath, dist=shortest.paths(graph,from,to)))\n\n  # until k shortest paths are found\n  while(kk<k){\n    # take last found shortest path\n    last.variant <- shortest.variants[[length(shortest.variants)]]              \n\n    # calculate all alternatives\n    variants <- calculate.variants(variants, last.variant, from, to)\n\n    # find shortest alternative\n    sp <- select.shortest.path(variants)\n\n    # add to list, increase kk, remove shortest path from list of alternatives\n    shortest.variants[[length(shortest.variants)+1]] <- list(g=variants[[sp]]$g, path=variants[[sp]]$variants$path, vert=variants[[sp]]$variants$vert, dist=variants[[sp]]$variants$dist)\n    kk <- kk+1\n    variants <- variants[-sp]\n  }\n\n  return(shortest.variants)\n}\n\n# found all alternative routes\ncalculate.variants <- function(variants, variant, from, to){\n  # take graph from current path\n  g <- variant$g\n\n  # iterate through edges, removing one each iterations\n  for (j in unlist(variant$path)){\n    newgraph <- delete.edges(g, j) # remove adge\n    sp <- get.shortest.paths(newgraph,from,to, output='both') # calculate shortest path\n    spd <- shortest.paths(newgraph,from,to) # calculate length\n    if (spd != Inf){ # the the path is found\n      if (!contains.path(variants, sp$vpath)) # add to list, unless it already contains the same path\n      {\n        variants[[length(variants)+1]] <- list(g=newgraph, variants=list(path=sp$epath, vert=sp$vpath, dist=spd))\n      }\n    }\n  }\n\n  return(variants)\n}\n\n# does a list contain this path?\ncontains.path <- function(variants, variant){\n  return( any( unlist( lapply( variants, function(x){ identical(x$variant$vert,variant) } ) ) ) )\n}\n\n# which path from the list is the shortest?\nselect.shortest.path <- function(variants){\n  return( which.min( unlist( lapply( variants, function(x){x$variants$dist} ) ) ) )\n}\n```\n\n\nThe results are below with Same Path and and the distance computed is also not correct.I am not sure about where i am making the mistake\n\n```\nlibrary(igraph)\nk.shortest.paths(my.graph, from = 37, to = 8, k = 2)\n\n[[1]]\n[[1]]$g\nIGRAPH UN-- 169 372 -- \n+ attr: name (v/c), DIST_KM_CNT (e/n)\n+ edges (vertex names):\n [1] 1 --23  1 --2   2 --3   1 --2   2 --3   3 --4   3 --115 3 --4   4 --5  \n[10] 5 --6   4 --5   5 --6   6 --7   6 --7   7 --8   7 --8   8 --9   9 --10 \n[19] 8 --9   10--111 10--79  10--160 9 --10  11--160 11--31  11--12  12--14 \n[28] 12--161 11--12  13--67  13--161 13--139 14--15  12--14  14--15  15--16 \n[37] 15--82  16--17  15--16  17--18  16--17  17--18  18--19  18--19  19--20 \n[46] 20--131 19--20  20--63  21--63  21--24  22--43  22--23  1 --23  22--23 \n[55] 21--24  24--25  24--162 24--25  25--26  25--26  26--27  27--65  26--27 \n[64] 28--29  28--162 29--30  28--29  29--30  30--48  30--49  30--54  31--143\n+ ... omitted several edges\n\n[[1]]$path\n[[1]]$path[[1]]\n+ 11/372 edges (vertex names):\n [1] 36--37  35--36  34--35  33--34  32--33  31--32  11--31  11--160 10--160\n[10] 9 --10  8 --9  \n\n\n[[1]]$vert\n[[1]]$vert[[1]]\n+ 12/169 vertices, named:\n [1] 37  36  35  34  33  32  31  11  160 10  9   8  \n\n\n[[1]]$dist\n    8\n37 11\n\n\n[[2]]\n[[2]]$g\nIGRAPH UN-- 169 371 -- \n+ attr: name (v/c), DIST_KM_CNT (e/n)\n+ edges (vertex names):\n [1] 1 --23  1 --2   2 --3   1 --2   2 --3   3 --4   3 --115 3 --4   4 --5  \n[10] 5 --6   4 --5   5 --6   6 --7   6 --7   7 --8   7 --8   8 --9   9 --10 \n[19] 8 --9   10--111 10--79  10--160 9 --10  11--160 11--31  11--12  12--14 \n[28] 12--161 11--12  13--67  13--161 13--139 14--15  12--14  14--15  15--16 \n[37] 15--82  16--17  15--16  17--18  16--17  17--18  18--19  18--19  19--20 \n[46] 20--131 19--20  20--63  21--63  21--24  22--43  22--23  1 --23  22--23 \n[55] 21--24  24--25  24--162 24--25  25--26  25--26  26--27  27--65  26--27 \n[64] 28--29  28--162 29--30  28--29  29--30  30--48  30--49  30--54  31--143\n+ ... omitted several edges\n\n[[2]]$path\n[[2]]$path[[1]]\n+ 11/371 edges (vertex names):\n [1] 36--37  35--36  34--35  33--34  32--33  31--32  11--31  11--160 10--160\n[10] 9 --10  8 --9  \n\n\n[[2]]$vert\n[[2]]$vert[[1]]\n+ 12/169 vertices, named:\n [1] 37  36  35  34  33  32  31  11  160 10  9   8  \n\n\n[[2]]$dist\n    8\n37 11\n```\n\n    ", "Answer": "\r\nI know this is like 2 years late but hopefully this will be useful for other people who needs an implementation of yen's algorithm in R.\n\n```\nlibrary(igraph)\nlibrary(tidyverse)\n\n#'@return the shortest path as a list of vertices or NULL if there is no path between src and dest\nshortest_path <- function(graph, src, dest){\n  path <- suppressWarnings(get.shortest.paths(graph, src, dest))\n  path <- names(path$vpath[[1]])\n  if (length(path)==1) NULL else path\n} \n\n#'@return the sum of the weights of all the edges in the given path\npath_weight <- function(path, graph) sum(E(graph, path=path)$weight)\n\n#'@description sorts a list of paths based on the weight of the path\nsort_paths <- function(graph, paths) paths[paths %>% sapply(path_weight, graph) %>% order]\n\n#'@description creates a list of edges that should be deleted\nfind_edges_to_delete <- function(A,i,rootPath){\n  edgesToDelete <- NULL\n  for (p in A){\n    rootPath_p <- p[1:i]\n    if (all(rootPath_p == rootPath)){\n      edge <- paste(p[i], ifelse(is.na(p[i+1]),p[i],p[i+1]), sep = '|')\n      edgesToDelete[length(edgesToDelete)+1] <- edge\n    }\n  }\n  unique(edgesToDelete)\n}\n\n#returns the k shortest path from src to dest\n#sometimes it will return less than k shortest paths. This occurs when the max possible number of paths are less than k\nk_shortest_yen <- function(graph, src, dest, k){\n  if (src == dest) stop('src and dest can not be the same (currently)')\n\n  #accepted paths\n  A <- list(shortest_path(graph, src, dest))\n  if (k == 1) return (A)\n  #potential paths\n  B <- list()\n\n  for (k_i in 2:k){\n    prev_path <- A[[k_i-1]]\n    num_nodes_to_loop <- length(prev_path)-1\n    for(i in 1:num_nodes_to_loop){\n      spurNode <- prev_path[i]\n      rootPath <- prev_path[1:i]\n\n      edgesToDelete <- find_edges_to_delete(A, i,rootPath)\n      t_g <- delete.edges(graph, edgesToDelete)\n      #for (edge in edgesToDelete) t_g <- delete.edges(t_g, edge)\n\n      spurPath <- shortest_path(t_g,spurNode, dest)\n\n      if (!is.null(spurPath)){\n        total_path <- list(c(rootPath[-i], spurPath))\n        if (!total_path %in% B) B[length(B)+1] <- total_path\n      }\n    }\n    if (length(B) == 0) break\n    B <- sort_paths(graph, B)\n    A[k_i] <- B[1]\n    B <- B[-1]\n    }\n  A\n}\n\n#===================Test==========================#\nedgeList <- tibble(from=character(), to=character(), weight = numeric())\n\nedgeList[nrow(edgeList)+1,] <-list('c','d',3)\nedgeList[nrow(edgeList)+1,] <-list('d','f',4)\nedgeList[nrow(edgeList)+1,] <-list('f','h',1)\nedgeList[nrow(edgeList)+1,] <-list('c','e',2)\nedgeList[nrow(edgeList)+1,] <-list('e','d',1)\nedgeList[nrow(edgeList)+1,] <-list('e','f',2)\nedgeList[nrow(edgeList)+1,] <-list('e','g',3)\nedgeList[nrow(edgeList)+1,] <-list('g','h',2)\nedgeList[nrow(edgeList)+1,] <-list('f','g',2)\n\ngraph <- graph.data.frame(edgeList)\n\n#k_shortest.yen(graph, 'c','c',7) #expect error\n#expect all 7 paths \nk_shortest_yen(graph,'c','h',7)\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Sub-Tree of Shortest path Tree is also a shortest Tree?\r\n                \r\nI have an undirected weighted graph G=(V,E) where V represent nodes and E represent edges. Through Dijkstra Algorithm, I got a shortest path tree Ts=(s,V) rooted at source node s and spanning all nodes V in the graph G. Then I selected a sub-tree Tm=(s,K), (where K is a subset of V) of shortest path tree Ts=(s, V)  that connect s to only K nodes among all V nodes, i.e, the sub-tree Tm is a subset of shortest path tree Ts.\n\nMy question is how can now I prove by arguments or a lemma/Theorem that this sub-tree Tm of shortest path tree Ts is also a shortest tree?. Thank you in advance. \n    ", "Answer": "\r\nWell, I guess that this SPT (Shortest Path Tree) is just a tree that has an edge from the source to each other node (cos if it isn't this way, it may contain cycles).\n\nThen,  if you choose some sub-tree of the original SPT, you will have to keep the properties of a tree, then we have some cases:\n\n\nTrivial Tree: just one node, no edges\n\n```\nno problems in here, it's a SPT (empty)\n```\n\nNot-Trivial Tree: two or more nodes, obviously with edges.\n\n```\nthis is kind of tricky. \n\nif you suppose that this sub-tree is rooted on source, then its easy\nto see that the sub-tree will be a set of shortest paths between\nthe source and the other nodes, making it be a SPT ROOTED ON SOURCE.\n\notherwise, it wont be a SPT, cause if its rooted on some other node\n(instead of source), the path from the root to other node (different\nfrom source) may not be minimum.\n```\n\n\n\nAs I guess you are interested in a sub-tree that is rooted on the source, than it's easy to see that a sub-tree will contain only shortest paths (as it's a subtree of a SPT itself), and then it will be a SPT.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Getting the shortest path geometry using python networkx\r\n                \r\nHow do I get the path as a geometry from networkx?\nBelow is my worked example which returns the ```\nnx.shortest_path_length```\n\n```\nimport osmnx as ox\nimport networkx as nx\nfrom shapely.geometry import Point\n\ndef get_network(centre_point, dist):\n    G = ox.graph_from_point(centre_point, dist=dist, network_type='walk', simplify=False)\n    G = ox.add_edge_speeds(G)\n    G = ox.add_edge_travel_times(G)\n    nodes, edges = ox.graph_to_gdfs(G, nodes=True, edges=True)\n    return G, nodes, edges\n\n\npoint = (50.864595387190924, -2.153190840083006)\nG, nodes, edges = get_network(centre_point=point, dist=1000)\n\na = nodes.iloc[4].name\nb = nodes.iloc[20].name\n\nnx.shortest_path_length(G, a, b, weight='length', method='dijkstra')\n```\n\nThis gives the shortest path length as ```\n223.964```\n, how do I get the actual path geometry of this shortest path? The paths are in ```\nedges```\n but how do I extract the correct ones for this path?\n    ", "Answer": "\r\nYou can use ```\nshortest_path```\n instead of ```\nshortest_path_length```\n. Example:\n```\nnx.shortest_path(G, a, b, weight='length', method='dijkstra')\n```\n\nResult:\n```\n[29954468,\n 1586097212,\n 1586097440,\n 1586097310,\n 4500037088,\n 2279573449,\n 2279573451,\n 2279573460,\n 10081635099,\n 1585877072,\n 294588504,\n 8515680389,\n 294588511,\n 294588514,\n 8515680388,\n 294588551]\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "highlight shortest path on plot of graph\r\n                \r\nI am trying to find a way to highlight some shortest paths on my graph. \nI am trying to automate the use the output of get.shortest.paths into the path= function of E() but the data structure seems wrong. See below:\n\n```\n###################################################################\ng <- graph.ring(10,directed=TRUE)               \nplot(g)\nShortPth <- get.shortest.paths(g, 8, 2)    # List of path 8->2\nShortPth\nE(g)$color <- \"SkyBlue2\"\nE(g)$width <- 1\nE(g, path=ShortPth)$color <- \"red\" \n\n### setting edges by path= is failing !!!!!!!!!!\nplot(g)\n```\n\n\n#############################################################\n\nany help would be greatly appreciated....\n    ", "Answer": "\r\nI think you just missed a few brackets.  The ```\npath```\n argument wants a numeric vector, but ```\nShortPth```\n is a list.  So, you can supply a vector by typing ```\nShortPth[[1]]```\n\nTry the following:\n\n```\nE(g, path=ShortPth[[1]])$color <- \"red\"\nplot(g)\n```\n\n\nUpdate:\n\nAs pointed out in the comment by jcarlos, the above solution throws an error with ```\nigraph_1.0.1```\n:\n\n\n  Error in as.igraph.vs(graph, path) :    (list) object cannot be\n  coerced to type 'double'\n\n\nThe documentation says the ```\npath```\n argument should be ```\nA list of vertices, to select edges along a path.```\n  Passing in a list throws an error, though.  Any of the following are working at the moment with ```\nigraph_1.0.1```\n:\n\n```\nE(g, path=ShortPth$vpath[[1]])$color <- \"red\"\nE(g, path=unlist(ShortPth$vpath))$color <- \"red\"\nE(g, path=unlist(ShortPth[[1]]))$color <- \"red\"\n\nShortPth$vpath[[1]]  # class \"igraph.vs\"\n# + 5/10 vertices:\n# [1]  8  9 10  1  2\nunlist(ShortPth$vpath)\n# [1]  8  9 10  1  2\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Incorrect shortest path in Python igraph?\r\n                \r\nWhen I run this for node 11 (you get to enter that) it produces a shortest path of 90 via nodes 0,1,4,11. However, there is a shorter path of 85 via nodes 0,2,6,4,11 of length 85.\nIt appears to be an error in the igraph function, is someone able to confirm or advise otherwise please?\nCheers, Paul\nigraph shortest path which is incorrect I think\n```\n    M = np.array(\n    [# W    1    2    3    4    5    6    7    8   9    10   11   12   13 \n    [  0,  20,  35,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0],   #W\n    [ 20,   0,   0,   0,  50,  35,   0,   0,   0,   0,   0,   0,   0,   0],   #1\n    [ 35,   0,   0,  15,  40,  0,   20,   0,   0,   0,   0,   0,   0,   0],   #2\n    [ 25,   0,  15,   0,   0,   0,  35,  25,   0,   0,   0,   0,   0,   0],   #3     \n    [  0,  50,  40,   0,   0,  20,  10,   0,  20,   0,   0,  20,   0,   0],   #4\n    [  0,  35,   0,   0,  20,   0,   0,   0,   0,   0,   0,  60,   0,   0],   #5\n    [  0,   0,  20,  35,  10,   0,   0,  25,  15,  15,   0,   0,  35,   0],   #6\n    [  0,   0,   0,  25,   0,   0,  25,   0,   0,  20,   0,   0,   0,   0],   #7\n    [  0,   0,   0,   0,  20,   0,  15,   0,   0,   0,  30,  30,  40,   0],   #8\n    [  0,   0,   0,   0,   0,   0,  15,  20,   0,   0,   0,   0,  20,   0],   #9\n    [  0,   0,   0,   0,   0,   0,   0,   0,  30,   0,   0,  15,  15,  10],   #10\n    [  0,   0,   0,   0,  20,  60,   0,   0,  30,   0,  15,   0,   0,  20],   #11\n    [  0,   0,   0,   0,   0,   0,  35,   0,  40,  20,  15,   0,   0,  15],   #12\n    [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  10,  20,  15,   0],   #13\n    \n    ])\n#M[M>0]=1\n\n\n\n#weights=[0.6, 0.7, 0.3, 0.6, 0.8, 0.3, 0.7, 0.9, 0.6, 0.3, 0.8, 0.9, 0.4, 0.5, 0.7, 0.3, 0.4, 1.8, 1.5, 1.7, 0.6, 0.5, 1.4, 1.5, 1.6, 1.8, 1.2, 0.7, 1.5, 1.4, 0.6, 0.5, 1.3, 1.5, 1.2, 1.7, 1.2, 0.6, 1.7, 0.3, 1.6, 0.5, 1.2, 0.8, 0.4, 1.3, 1.7, 0.8, 0.8, 0.7, 0.6, 0.3, 0.8, 0.8, 0.4, 0.7, 0.5, 0.6, 0.8, 0.5]\nprint(\"input matrix is symmetrical =\", np.all((M == np.transpose(M))))\nprint()\nM=np.triu(M)\n\nm=ig.Graph.Weighted_Adjacency(M)\n\n\"\"\"for i in range(m.vcount()):\n# g.get_shortest_paths() returns a list of edge ID paths\n    results = m.get_shortest_paths(\n        0,\n        to=i,\n        weights=m.es[\"weight\"],\n        output=\"vpath\",\n        #mode=ALL\n    )\n    #print(i, sum(m.es[results[0]][\"weight\"]),m.es[results[0]][\"weight\"]), \n    #for n in results[i]:\n    #    print(\"{}\".format(m.vs[i][n]['name']))\"\"\"\n\n#for i in range(m.vcount()):\n#for i in range(12):\ni = int(input('input node number'))\nresults = m.get_shortest_paths(0,to=i,weights=m.es[\"weight\"],output=\"epath\")\n\nprint(\"Shortest path 'W' and {} is {} \".format( i,m.es[results[0]][\"weight\"]))\n\nif len(results[0]) > 0:\n    # Add up the weights across all edges on the shortest path\n    distance = 0\n    for e in results[0]:\n        distance += m.es[e][\"weight\"]\n    print(\"Shortest weighted distance is: \", distance)\nelse:\n    print(\"End node could not be reached!\")\n#spanning_tree = m.spanning_tree(weights=weights,return_tree=False)\nm.es[\"color\"] = \"black\"\nm.es[\"width\"] = 0.5\nm.es[results[0]][\"color\"] = \"red\"\nm.es[results[0]][\"width\"] = 3\nm.es[\"label_size\"]= 10\n\n\nfig, ax = plt.subplots(1,1,figsize=(16,24))\nig.plot(\n    m,\n    bbox=(512,512),    \n    vertex_size=1,    \n    target=ax,    \n    layout=np.multiply([(0,1),(1,2),(1,1),(1,0),(2,2),(2,3),(2,1),(2,0),(3,2),(3,0),(4,2),(4,3),(4,1),(5,2)],4),\n    edge_curve=0,\n    vertex_color=\"lightblue\",\n    vertex_label=range(m.vcount()),\n\n    edge_width=m.es[\"width\"],\n    edge_label=m.es[\"weight\"],\n    autocurve=False,   \n)\nplt.show()\n\nprint(\"Shortest path {0}\".format(distance))\n```\n\n    ", "Answer": "\r\nLooking at the image it seems like the graph is directed (you cant move both ways between nodes, only in the direction indicated by the arrow). So 4 and 6 is connected as ```\n4 -> 6```\n and in your path you use it as ```\n4 <- 6```\n that is not valid according to the image.\nSo I would say that igraph is correct and you are wrong.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Sub-Tree of Shortest path Tree is also a shortest Tree?\r\n                \r\nI have an undirected weighted graph G=(V,E) where V represent nodes and E represent edges. Through Dijkstra Algorithm, I got a shortest path tree Ts=(s,V) rooted at source node s and spanning all nodes V in the graph G. Then I selected a sub-tree Tm=(s,K), (where K is a subset of V) of shortest path tree Ts=(s, V)  that connect s to only K nodes among all V nodes, i.e, the sub-tree Tm is a subset of shortest path tree Ts.\n\nMy question is how can now I prove by arguments or a lemma/Theorem that this sub-tree Tm of shortest path tree Ts is also a shortest tree?. Thank you in advance. \n    ", "Answer": "\r\nWell, I guess that this SPT (Shortest Path Tree) is just a tree that has an edge from the source to each other node (cos if it isn't this way, it may contain cycles).\n\nThen,  if you choose some sub-tree of the original SPT, you will have to keep the properties of a tree, then we have some cases:\n\n\nTrivial Tree: just one node, no edges\n\n```\nno problems in here, it's a SPT (empty)\n```\n\nNot-Trivial Tree: two or more nodes, obviously with edges.\n\n```\nthis is kind of tricky. \n\nif you suppose that this sub-tree is rooted on source, then its easy\nto see that the sub-tree will be a set of shortest paths between\nthe source and the other nodes, making it be a SPT ROOTED ON SOURCE.\n\notherwise, it wont be a SPT, cause if its rooted on some other node\n(instead of source), the path from the root to other node (different\nfrom source) may not be minimum.\n```\n\n\n\nAs I guess you are interested in a sub-tree that is rooted on the source, than it's easy to see that a sub-tree will contain only shortest paths (as it's a subtree of a SPT itself), and then it will be a SPT.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "shortest path in R\r\n                \r\nI'm trying to get the shortest path between random points. I made the following algorithm, I'm not sure if the median is correct and it plots a double line between the points. Can someone help me fix it?\n\n```\n# We create a field (matrix) with a fixed length and width.\n# there we randomise some points.\n\nlengte = 12\nbreedte = 10\naantalpunten = 15\nv = 0*(1:(lengte*breedte))\nv[1:aantalpunten] = 1\nv = sample(v) \npunten = matrix(v, lengte, breedte)\n\n# We create a line somewhere in the middle on such way it makes the connections as short as possible.\n# This is in fact the median of the rowsums (Pythagoras).\n\nrp = rowSums(punten)\ncsrp = cumsum(rp)\nm = length(csrp[csrp <= ceiling(csrp[length(csrp)]/2)])\npunten\nm\nbegin = min(which(rp>0))\nend = max(which(rp>0))\nlijnen = c()\n\n# create a median\n\nfor (i in begin:(end-1))\n{\n    lijnen = c(lijnen, i, m, i+1, m)\n}\n\n# connect other points\n\nfor (i in 1:lengte)\n{\n    for (j in 1:breedte)\n    {\n        if (punten[i,j] >0)\n        {\n            lijnen = c(lijnen, i,j,i,m)\n        }\n    }\n}\nlijnenmatrix = matrix(lijnen, nrow = 2, byrow = FALSE)\nlength_lijnenmatrix = length(lijnenmatrix)\nplot(1, type=\"n\", xlab=\"\", ylab=\"\",  xlim=c(0, lengte+2), ylim=c(0, breedte+2))\nfor (i in 1:(length_lijnenmatrix/4))\n{\n    lines(lijnenmatrix[1, c(2*i-1, 2*i)],lijnenmatrix[2,c(2*i-1, 2*i)])\n}\nfor (i in 1:lengte)\n{\n    for (j in 1:breedte)\n    {\n        if (punten[i,j] >0)\n        {\n            points(i,j)\n        }\n    }\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Searching for shortest path\r\n                \r\nIsn't it always better when searching for shortest path to use for connected nodes lists instead of grid?  \n\nWhen using grid, you have to iterate over the grid every time, whereas using lists saves lots of time.\n    ", "Answer": "\r\nWith adjacency matrix usually each check costs you O(n) time. It may be a bit slower than a list of connected nodes. However, you can do some fancy stuff with it. For example, if you want to delete a lot of edges, you can do it in O(1) using adjacency matrix (it may take a lot longer using a list of nodes depending on what data structure you use for it). Adjacency matrix is also a matrix. What do I mean by that? If you want to check in how many ways you can get from node A to node B in k steps, you can raise this matrix to the power of k, which is impossible to do with a list.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Fastest way to find all-pair shortest paths in a undirected cycle\r\n                \r\nI have and undirected graph that is in itself a simple cycle like this\n\n```\na---b---c\n|       |       \nd---e---f\n```\n\n\nWhich is the fastest way to compute all-pair shortest paths knowing this condition ?\n    ", "Answer": "\r\nIn one pass starting from ```\nA```\n traverse the graph clockwise, and for every node compute the distance from ```\nA```\n. Let's say the distance to the node ```\nX```\n is ```\na[X]```\n. This way for any pair ```\n(X, Y)```\n of nodes the distance will be:\n\n```\nmin(abs(aX - aY), total - abs(aY - aX))\n```\n\n\nWhere ```\ntotal```\n is the sum of all the edges weights.\n\nIn your case ```\na[B]```\n (I will use upper case for nodes) would be 1, ```\na[C]```\n would be 2, ```\na[D]```\n would be 3 etc and the total would be 6. Then if you want to compute the distance between b and f, it would be\n\n```\nmin(abs(aB - aF), total - abs(aB - aF)) = \nmin(abs( 1 -  3),     6 - abs( 1 -  3)) = \nmin(           2,                    4) =\n2\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "shortest path with specified number of edges\r\n                \r\ni'm looking for an algorithm that finds the shortest path between two vertices (i and j) in a graph that contains a specified number of edges, n. i have a dynamic program that looks at the shortest path to the destination with n-1 edges, but how can i be sure that the shortest path being found starts at i?\n    ", "Answer": "\r\nI guess the edges have different costs / lengths and that the constraint is that there are n edges, and among all paths from i to j that have exactly n individual edges, the goal is to find the one that has least total cost / length.\n\nIf you do this using dynamic programming, the recurrences are\n\n```\nspath(f, t, n): --- returns shortest path from 'f' to 't' that has 'n' edges\n\nspath(x, x, 0) = [x] --- path that has only one vertex\nspath(x, y, 0) = NO PATH --- when x != y\n\nspath(f, t, n) =\n  min cost path over (x is any node that is connected to t):\n     spath(f, x, n-1) + [t] (x can be appended because there is edge x - t)\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Find all paths between two graph nodes\r\n                \r\nI am working on an implementation of Dijkstra's Algorithm to retrieve the shortest path between interconnected nodes on a network of routes. I have the implementation working. It returns all the shortest paths to all the nodes when I pass the start node into the algorithm.\nMy question:\nHow does one go about retrieving all possible paths from Node A to, say, Node G or even all possible paths from Node A and back to Node A?\n    ", "Answer": "\r\nFinding all possible paths is a hard problem, since there are exponential number of simple paths. Even finding the kth shortest path [or longest path] are NP-Hard.\n\nOne possible solution to find all paths [or all paths up to a certain length] from ```\ns```\n to ```\nt```\n is BFS, without keeping a ```\nvisited```\n set, or for the weighted version - you might want to use uniform cost search\n\nNote that also in every graph which has cycles [it is not a DAG] there might be infinite number of paths between ```\ns```\n to ```\nt```\n.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Python, Circular Shortest Path [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is seeking recommendations for books, tools, software libraries, and more. It does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     We don’t allow questions seeking recommendations for books, tools, software libraries, and more. You can edit the question so it can be answered with facts and citations.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI am trying to make strange shortest path finder method. But I don't know how I can.\n\nI need a algorithm. I did some research and found some algorithm for finding shortest path, like Dijkstra's algorithm, Floyd–Warshall algorithm, Johnson's algorithm. But I think they don't meet my expectation.\n\n\n\nI want that: Should start at red dots, should walk through all blue dots and ends at red dot.\n\nIs there a algorithm for that?\n\n(Really sorry for my English. I hope you can understand me.)\n    ", "Answer": "\r\nYour problem is a variant of a Hamiltonian Cycle Problem, which is NP-Complete, so there is no known efficient solution to it (and most believe a solution does not exist, but it is not proven yet)\n\nThe Hamiltonian Cycle Problem says: Given a graph ```\nG=(V,E)```\n, find if there is a simple cycle (each vertex is traversed at most once) that goes through all vertices, and is a classic NP-Complete Problem.\n\nThe reduction is quite simple, given a Hamiltonian Cycle Problem, color one random point in red, and the rest of the points in blue. There is a solution to the Hamiltonian Cycle Problem if and only if the solution to your problem is a simple path on the \"modified\" problem on the new graph.\n\n\n\nSince the problem is NP-Complete, it means there is no known optimal efficient solution for it. You can try using some brute force techniques that might be feasible for small graphs, or sattle for approximation/heuristic solutions.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Fastest way to find all-pair shortest paths in a undirected cycle\r\n                \r\nI have and undirected graph that is in itself a simple cycle like this\n\n```\na---b---c\n|       |       \nd---e---f\n```\n\n\nWhich is the fastest way to compute all-pair shortest paths knowing this condition ?\n    ", "Answer": "\r\nIn one pass starting from ```\nA```\n traverse the graph clockwise, and for every node compute the distance from ```\nA```\n. Let's say the distance to the node ```\nX```\n is ```\na[X]```\n. This way for any pair ```\n(X, Y)```\n of nodes the distance will be:\n\n```\nmin(abs(aX - aY), total - abs(aY - aX))\n```\n\n\nWhere ```\ntotal```\n is the sum of all the edges weights.\n\nIn your case ```\na[B]```\n (I will use upper case for nodes) would be 1, ```\na[C]```\n would be 2, ```\na[D]```\n would be 3 etc and the total would be 6. Then if you want to compute the distance between b and f, it would be\n\n```\nmin(abs(aB - aF), total - abs(aB - aF)) = \nmin(abs( 1 -  3),     6 - abs( 1 -  3)) = \nmin(           2,                    4) =\n2\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Find shortest path on graph python\r\n                \r\nI am writing a python program to find shortest path from source to destination. My code is\n\n```\ndef gridGraph(row,column):\n    for x in range(0,row):\n        for y in range(0,column):\n            graphNodes.append([x,y])\n            neighbor1=x+1,y+0\n            neighbor2=x+0,y+1\n            weight=randint(1,10)\n            graph.append([(x,y),(neighbor1),weight])\n            graph.append([(x,y),(neighbor2),weight])\n    return graph\n\ndef shortestPath(graph,source,destination):\n    weight=0\n    path=[]\n    for data in graph:\n        if data[0]==source:\n            path.append(data[1])\n            weight+=data[2]\n            if destination == data[0]:\n                newWeight=checkWeights(weight)\n                if newWeight<=weight:\n                    print(path)\n                    return path \n                else:\n                    path.clear()\n                    weight=0\n            else :\n                source=data[1]\n        else:\n            continue    \n\n\ndef checkWeights(weight):\n    global x\n    if(weight<=x):\n        x=weight\n        return x\n    else:\n        return weight\n```\n\n\n```\ngraph=hr.gridGraph(2,2)\nhr.shortestPath(graph,(0,0),(0,1))\n```\n\n\nMy graph output is in this form:\n\n```\n[[(0, 0), (1, 0), 3], [(0, 0), (0, 1), 3], [(0, 1), (1, 1), 6], [(0, 1), (0, 2), 6], [(1, 0), (2, 0), 4], [(1, 0), (1, 1), 4], [(1, 1), (2, 1), 10], [(1, 1), (1, 2), 10]]\n```\n\n\nI am not getting the shortest path. can anyone please help?\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "NetworkX vs Scipy all shortest path algorithms\r\n                \r\nWhat are the differences between the NetworkX all shortest paths algorithm and the scipy floyd warshall algorithm?  Are there any reasons to prefer one over another?  Which is fastest?\n    ", "Answer": "\r\n(for those who aren't aware the numpy floyd-warshall algorithm is available in networkx)\n\nThe networkx description of floyd_warshall_numpy states: \n\n\n  Floyd’s algorithm is appropriate for finding shortest paths in dense graphs or graphs with negative weights when Dijkstra’s algorithm fails. This algorithm can still fail if there are negative cycles. It has running time O(n^3) with running space of O(n^2).\n\n\nThe networkx single_source_shortest_path works better on sparse graphs.  You should be aware that if you use the various \"shortest_path\" algorithms, these ignore edge weights.  The various Dijkstra algorithms incorporate edge weights.\n\nThere is more description here.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Neo4J: shortest paths with specific relation types sequence constrain\r\n                \r\nI need to find shortest paths between nodes, but with some restrictions on relations types in good paths.\n\nI have two relation types: A & B.\nPath is considered bad if it has two or more consecutive relation of type B:\n\nGood path: ()-A->()-A->()<-A-()-B->()-A->()-B->()\nBad path: ()-A->()-A->()<-A-()-B->()<-B-()-A->()\n\nThe Cypher query:\n\n```\nMATCH path=allShortestPaths( (p:P{idp:123})-[rel:A|B*]-(p2:P{idp:124}) )\nWHERE *some-predicate-on-path-or-rel*\nRETURN path\n```\n\n\nis not a solution because the shortest good path may be longer than shortest bad paths.\n\nQ1: Can this problem be solved by some Cypher query?\n\nI can solve my problem with the embedded Java Neo4J API:\n\n```\nGraphDatabaseService graphDb = new GraphDatabaseFactory().newEmbeddedDatabase(\"db/store/dir/path\");\nTraversalDescription td = graphDb.traversalDescription()\n    .breadthFirst()\n    .evaluator(Evaluators.toDepth(max_depth))\n    .evaluator(Evaluators.endNodeIs(Evaluation.INCLUDE_AND_PRUNE, Evaluation.EXCLUDE_AND_CONTINUE, endNode))\n    .evaluator(new DoubleB_PruneEvaluator());\n\nstatic class DoubleB_PruneEvaluator implements Evaluator {\n    @Override\n    public Evaluation evaluate(final Path path) {\n        Iterator<Relationship> lRels = path.reverseRelationships().iterator();\n        if (lRels.hasNext()  &&  lRels.next().isType(MyRelTypes.B)) {\n            if (lRels.hasNext()  &&  lRels.next().isType(MyRelTypes.B))\n                return Evaluation.EXCLUDE_AND_PRUNE;\n        }\n        return Evaluation.INCLUDE_AND_CONTINUE;\n    }\n}\n```\n\n\nQ2: Is this solution is quite efficient? Or how to improve?\n\nBut my application is written on PHP and interacts with Neo4j server via REST protocol.\n\nQ3: How can I run this solution by some REST query?\n    ", "Answer": "\r\nNo intelligent person wouldn't answer me. So I will try myself.\n\nA1: This problem cannot be solved by standard Cypher query. (My Neo4j version 3.1.1)\n\nA2: This solution is not quite efficient for several reasons:\n\n\nThe standard function shortestPath is implemented by using more\nefficient Bidirectional BFS.\nThis traversal description does not contain a stop condition when\nthe solution is found. The traversal will continue until the maximum\ndepth.\n\n\nIn addition, this solution finds only one path. The other paths of the same length will not be found.\n\nA3: Java coded solutions can be added to a server by extending Neo4j.\nI solve my problem using user-defined procedures:\n\nmy/app/RelType.java:\n\n```\npackage my.app;\n\nimport org.neo4j.graphdb.*;\n\npublic enum RelType implements RelationshipType {\n    A, B\n}\n```\n\n\nmy/app/DoubleB_PruneEvaluator.java:\n\n```\npackage my.app;\n\nimport java.util.*;\nimport org.neo4j.graphdb.*;\nimport org.neo4j.graphdb.traversal.*;\n\npublic class DoubleB_PruneEvaluator implements Evaluator {\n    @Override\n    public Evaluation evaluate(final Path path) {\n        Iterator<Relationship> lRels = path.reverseRelationships().iterator();\n        if (lRels.hasNext()  &&  lRels.next().isType(RelType.marry)) {\n            if (lRels.hasNext()  &&  lRels.next().isType(RelType.marry))\n                return Evaluation.EXCLUDE_AND_PRUNE;\n        }\n        return Evaluation.INCLUDE_AND_CONTINUE;\n    }\n}\n```\n\n\nmy/app/Procedures.java:\n\n```\npackage my.app;\n\nimport java.util.stream.Stream;\n\nimport org.neo4j.graphdb.*;\nimport org.neo4j.procedure.*;\nimport org.neo4j.graphdb.traversal.*;\n\npublic class Procedures {\n    @Context\n    public GraphDatabaseService db;\n\n    @Procedure\n    public Stream<PathHit> shortestWo2B( \n                                @Name(\"from\") Node fromNode,\n                                @Name(\"to\")   Node toNode,\n                                @Name(\"maxDepth\") long maxDepth)\n    {\n        TraversalDescription td = db.traversalDescription()\n            .breadthFirst()\n            .relationships(RelType.A)\n            .relationships(RelType.B)\n            .evaluator(Evaluators.toDepth((int)maxDepth))\n            .evaluator(Evaluators.endNodeIs(Evaluation.INCLUDE_AND_PRUNE, Evaluation.EXCLUDE_AND_CONTINUE, toNode))\n            .evaluator(new DoubleB_PruneEvaluator());\n\n        return td.traverse(fromNode)\n                .stream()\n                .map( PathHit::new );\n    }\n\n    public static class PathHit {\n        public Path path;\n\n        public PathHit(Path path) {\n            this.path = path;\n        }\n    }\n}\n```\n\n\nDoc: https://neo4j.com/docs/java-reference/3.1/javadocs/index.html?org/neo4j/procedure/Procedure.html\n\nA few words about the compilation and installation plugin:\n\nAs a beginner in Java, I decided that utilities Eclipse and Maven is too heavy. I prefer to use simple javac & jar:\n\n```\n$ export CLASSPATH=/path/to/neo4j-install-dir/lib/*:.\n$ javac my/app/*.java\n$ jar -cf my-neo4j-plugin.jar my/app/*.class\n$ cp my-neo4j-plugin.jar /path/to/neo4j-install-dir/plugins/\n$ /path/to/neo4j-install-dir/bin/neo4j restart\n```\n\n\nNow we can run the Cypher query:\n\n```\nMATCH (p1:P{idp:123}) \nMATCH (p2:P{idp:124})\nCALL my.app.shortestWo2B(p1,p2,100) YIELD path \nRETURN path;\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Java Shortest Path Problems\r\n                \r\nI am trying to solve a shortest path problem.  IT is an old waterloo CCC question and I am practicing for 2019.  Essentially it is a \"choose an adventurer book\" there are N pages (up to 10000) each page can lead to Ni pages.  The first input is N, there are then N lines of input where the first number is the number of branches to other pages followed by which page it branches to.  If it is a 0 it is an end point and there are no other branches.  We have to state if all pages are reached and the shortest path.  Sample input and output:\n\n```\ninput:\n3\n2 2 3\n0\n1 1\noutput\nY\n2\n```\n\n\nI was able to solve the problem however, I keep failing the time limit tests.  How can I make my code more efficient to pass the time tests?  Here is my recursive method that I use to avoid cycles and get shortest path.\n\n```\n   public static void shortestPath(Page p, ArrayList<Page> list){\n        ArrayList<Page> currentList = new ArrayList<>();\n        for(Page pg : list){\n            currentList.add(pg);\n        }\n        p.visited = true;\n        if(p.paths.get(0) == 0){\n            currentList.add(p);\n            Paths temp = new Paths();\n            temp.aPath = currentList;\n            completedPaths.add(temp);\n        }else{\n            for(int i=0;i<p.paths.size();i++){\n                if(!currentList.contains(pages.get(p.paths.get(i) - 1))){\n                    if(!currentList.contains(p)){\n                        currentList.add(p);\n                    }\n                    shortestPath(pages.get(p.paths.get(i) - 1), currentList);\n                }\n            }\n        }\n   }\n```\n\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Calculating shortest paths from points that originates mid-edge\r\n                \r\nI have a set of origin-destination coordinates that I want to calculate the shortest paths between them. \n\nMy origin-destination coordinates are sometimes located in the middle of a long straight-line road. However, the shortest path calculated by OSMnx/networkx will not consider that mid-edge to nearest-node path.\n\nIs there any ready function in OSMnx or networkx that I can use to find shortest path that originates/ends in the middle of the road? \n\nIf there is no such function, I am thinking of using the following steps.\n\n\nGet nearest edges of origin and destination\nGet nodes of those nearest edges: let's say (a,b) for origin, and (c,d) for destination\nCalculate distance of 4 possible combinations: a->c, a->d, b->c, b->d\nProject origin/destination onto their nearest edges: let's call them o1 and e1\nCalculate distance o1->a, o1->b, e1->c, e1->d\nAdd (5) distance to (3): to get\n\n\no1->a->c->e1\no1->a->d->e1\no1->b->c->e1\no1->b->d->e1\n\nSelect path with smallest distance\n\n    ", "Answer": "\r\nOSMnx produces a networkx graph object for routing/analysis. As you note, networkx shortest path calculation takes an origin and a destination node, so trying to calculate a shortest graph path from an edge midpoint won't work.\n\nA couple things you could try:\n\n\ntry to set ```\nsimplify=False```\n when you create the graph to retain as many nodes in the middle of streets as possible.\nif that doesn't work, you could try to subdivide edges (with greater than some threshold length) into 50 meter chunks or somesuch to discretize them with more nodes.\n\n\nSee also: https://stackoverflow.com/a/55601732/7321942\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Updating Shortest path distances matrix if one edge weight is decreased\r\n                \r\nWe are given a weighed graph G and its Shortest path distance's matrix delta. So that delta(i,j) denotes the weight of shortest path from i to j (i and j are two vertexes of the graph).\ndelta is initially given containing the value of the shortest paths. Suddenly weight of edge E is decreased from W to W'. How to update delta(i,j) in O(n^2)? (n=number of vertexes of graph)\nThe problem is NOT computing all-pair shortest paths again which has the best O(n^3) complexity. the problem is UPDATING delta, so that we won't need to re-compute all-pair shortest paths.\n\nMore clarified : All we have is a graph and its delta matrix. delta matrix contains just value of the shortest path. now we want to update delta matrix according to a change in graph: decreased edge weight. how to update it in O(n^2)?\n    ", "Answer": "\r\nIf edge E from node a to node b has its weight decreased, then we can update the shortest path length from node i to node j in constant time. The new shortest path from i to j is either the same as the old one or it contains the edge from a to b. If it contains the edge from a to b, then its length is ```\ndelta(i, a) + edge(a,b) +  delta(b, j)```\n.\n\nFrom this the O(n^2) algorithm to update the entire matrix is trivial, as is the one dealing with undirected graphs.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Hamiltonian Path vs Shortest Path\r\n                \r\nAfter researching about both problems, I can't conclude what is the difference amongst them.\n\nHamiltonian Path\n\nA Hamiltonian path is a path between two vertices of a graph that visits each vertex exactly once. Given a graph ```\nG```\n and two distinct nodes ```\nS```\n and ```\nE```\n, is there a Hamiltonian path in ```\nG```\n from ```\nS```\n to ```\nE```\n?\n\nI've found that this problem is NP-Complete\n\nShortest Path\n\nIn graph theory, the shortest path problem is the problem of finding a path between two vertices (or nodes) in a graph such that the sum of the weights of its constituent edges is minimized.\nThis problem is P\n\nWhat is the actual difference between them? And how is their complexity calculated?\n    ", "Answer": "\r\nThe Hamiltonian Path problem is actually looking for a longest simple path in a graph. It is easy to see that the two problems are basically equivalent (longest simple path and hamiltonian path). This problem is indeed a classic NP-Complete Problem.\nIt is NP-Complete since there is a polynomial reduction from another (already proved) NP-Hard Problem to this problem, and thus (from transitivity of polynomial reductions) this problem is NP-Hard as well. Since it is also in NP, it is NP-Complete.\n\nThe shortest path on the other hand is a different one, it asks what is the shortest way from point A to point B, and it is in P because there is a polynomial time algorithm that solves it (Dijkstra's algorithm, Bellman-Ford, BFS for non weighted graphs).\n\n\n\nRegarding ```\n\"And how is there complexity calculated?\"```\n I assume you mean how do we determine their complexity classes - in this case, Shortest Path is in P because we have a deterministic polynomial time algorithm that solves it (some mentioned above), while the complexity class of Hamiltonian Path is NP-Complete because it is both NP-Hard (there is polynomial reduction from another proven NP-Hard problem), and NP (we can solve it easily in polynomial time on non-determinitic turing machine). \nNote that we DO NOT KNOW if Hamiltonian Path is in P or not, because we do not know if P=NP.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path without diagonally moves [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 6 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI know there is alot of shortest path Algorithms but i want to ask if there any modifications can be done , to make some Algorithms like a* or Dijkstra chose the shortest path but without the diagonally moves so up and\n\ndown and right and left are the allowed moves \n    ", "Answer": "\r\nThe algorithm you probably want is A* (if you want a short path over a large map with some coherent obstacles), though you might just need Dijkstra's (if you must have the mathematically shortest path, or if the map doesn't have any real relation to anything physical). You simply disallow diagonal moves and you might get better results if you use Manhattan distance as your heuristic for A*. For Dijkstra's, the graph has no diagonal links. \n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Breadth-first search for shortest path code doesn't work\r\n                \r\nWhy this code doesn't work? For this input: \n\n```\n5 5\n0 0 0 0 0\n0 0 0 0 0\n0 0 0 0 0\n0 0 0 0 0\n0 0 0 0 0\n```\n\n\nit outputs strange number for shortest path to the given vertex but the matrix is ok (it contains the shortest paths to every cell in the matrix). But if I add ```\nreturn 1;```\n or something else with ```\nreturn```\n at the end of the function shortest path, then it outputs the correct solution. Can someone tell me what's wrong with the code?\n\n```\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nstruct node\n{\n    int x,y,spath,val;\n}v,c;\n\nnode mat[100][100];\nint dy[] = {-1,1,0,0}, dx[] = {0,0,-1,1}, n, m;\n\nvoid input()\n{\n    cin >> n >> m;\n    for (int i=0; i<n; i++) {\n        for (int j=0; j<m; j++) {\n            cin >> mat[i][j].val;\n            mat[i][j].spath = 0;\n        }\n    }\n}\n\nint shortest_path(node start, node end)\n{\n    queue<node> q;\n    q.push(start);\n    mat[start.y][start.x].val = 1;\n\n    while (!q.empty())\n    {\n        v = q.front();\n        q.pop();\n\n        for (int i=0; i<4; i++) {\n            c.y = v.y + dy[i];\n            c.x = v.x + dx[i];\n\n            if (c.y == end.y && c.x == end.x) {\n                return mat[v.y][v.x].spath + 1;\n            }\n            else if (c.y >=0 && c.y < n && c.x >=0 && c.x < m && mat[c.y][c.x].val == 0)\n                {\n                    mat[c.y][c.x].val = 1;\n                    mat[c.y][c.x].spath = mat[v.y][v.x].spath + 1;\n                    q.push(c);\n                }\n        }\n    }\n}\n\nint main()\n{\n    node start,end;\n    start.x = start.y = 0;\n    end.y = end.x = 4;\n    input();\n    cout << shortest_path(start,end) << endl;\n\n    for (int i=0; i<n; i++) {\n        for (int j=0; j<m; j++) {\n            cout << mat[i][j].spath;\n        }\n        cout << endl;\n    }\n    return 0;\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "shortest path in matrix\r\n                \r\nThere are a 30x30 matrix with 0,1,2 elements which are randomized. I need to find the shortest path from the top to the bottom of the matrix. I can move only in 1. I have no idea whats wrong with this.\n\nthe code:\n\n```\n#include <iostream>\n#include <ctime>\n#include <cstdlib>\n\n#define max 30\n\nusing namespace std;\n\nint matrix[max][max];\nint smatrix[max][max]; ///all elements are 0\n\nint lenght=0; ///út hossza\n\nvoid showMtx()\n{\n    for(int i=0; i<max; i++)\n    {\n        cout<<i+1<<\".\\t\";\n        for(int j=0; j<max; j++)\n        {\n            //if(matrix[i][j]==1)cout<<\"k \";\n            //else cout<<\" \";\n            cout<<matrix[i][j]<<\" \";\n\n        }\n        cout<<\"\\n\";\n    }\n}\nvoid path()\n{\n\n\n    for(int i=0; i<max; i++)\n    {\n        for(int j=0; j<max; j++)\n        {\n            if(matrix[i+1][j+1]==1 && smatrix[i+1][j+1]!=1) ///diagonally down\n            {\n                smatrix[i+1][j+1]=1; ///indicates that the i and j was here\n                lenght++; ///step counter\n                cout<<\"->(\"<<i+1<<\",\"<<j+1<<\")\";\n            }\n\n            else if(matrix[i][j+1]==1 && smatrix[i][j+1]!=1) ///right\n            {\n                smatrix[i][j+1]=1;\n                lenght++;\n                cout<<\"->(\"<<i<<\",\"<<j+1<<\")\";\n            }\n\n            else if(matrix[i+1][j]==1 && smatrix[i+1][j]!=1) /// down\n            {\n                matrix[i+1][j-1]=1;\n                lenght++;\n                cout<<\"->(\"<<i+1<<\",\"<<j<<\")\";\n            }\n            else if(matrix[i+1][j-1] && smatrix[i+1][j-1]!=1) ///diagonally down up\n            {\n\n                smatrix[i+1][j-1]=1;\n                lenght++;\n                cout<<\"->(\"<<i+1<<\",\"<<j-1<<\")\";\n            }\n\n            else if(matrix[i][j-1]==1 && smatrix[i][j-1]!=1) ///left\n            {\n\n                lenght++;\n                smatrix[i][j-1]=1;\n                cout<<\"->(\"<<i<<\",\"<<j-1<<\")\";\n            }\n\n            else if(matrix[i-1][j]==1 && smatrix[i-1][j]!=1) ///up\n            {\n\n                lenght++;\n                smatrix[i-1][j]=1;\n                cout<<\"->(\"<<i-1<<\",\"<<j<<\")\";\n            }\n            else if(matrix[i-1][j-1]==1 && smatrix[i-1][j-1]!=1) /// diagonally down\n            {\n\n                lenght++;\n                smatrix[i-1][j-1]=1;\n                cout<<\"->(\"<<i-1<<\",\"<<j-1<<\")\";\n            }\n            else\n            {\n\n            }\n            if(i==30)break;\n        }\n    }\n}\nvoid shortestPath()\n{\n\n    int i=0,j;\n    for(j=0; j<max; j++) ///find the first 1\n    {\n        if(matrix[i][j]==1)\n        {\n            path();\n            break;\n        }\n\n    }\n\n    cout<<\"\\nlepesek szama: \"<<lenght<<endl;\n}\nint main()\n{\n\n    srand(time(NULL));\n\n    for(int i=0; i<max; i++)\n    {\n        for(int j=0; j<max; j++)\n        {\n            matrix[i][j]=rand()%3;\n            smatrix[i][j]=0;\n        }\n    }\n    showMtx();\n    cout<<endl;\n    shortestPath();\n\n    return 0;\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path preventing particular edge combinations\r\n                \r\nI have been using networkX to compute the shortest path distance between two points A and B in a graph thanks to Dijkstra's algorithm.\nThe edges of my graph represent road segments, and the nodes the connections between segments. The weight function is the segment length, so that the returned path distance is the actual geographical distance.\nHowever, the calculated paths are sometimes unrealistic for my use. More specifically, I would like to prevent the algorithm from using paths implying very sharp turns between two successive edges. This implies that the weight of a particular edge is a function of the edge itself, but also of its precedessor in the path (so that the turn angle can be computed and sharp turns dismissed).\nAs a (simplistic) example, let's consider the below graph (assuming that the nodes and represented according to their actual geographical position). For the sake of simplicity, each edge has a weight (or distance) equal to 1.\nThe shortest path from A to B is shown in green, and the corresponding distance is 2.\nShortest path without \"sharp turn\" constraint\n\nHowever, the proposed path involve a sharp turn at node C (which can be detected based on the geographical coordinates of nodes A, B and C). This kind of turn should be forbidden, such that the proposed shortest path becomes the one described below.\nShortest path with \"sharp turn\" constraint\n\nThe distance is now 6, but the path avoids the transition A-B-C which involved a sharp turn.\nWhat do you think are my options to implement such requirement?\n    ", "Answer": "\r\nI have done something similar by making it a multi edge graph. Such as there is more than one edge between any two nodes. The 2nd edge in your case could be a numerical value identifying the orientation of the edge(road).\nConsidering south to north as 0, you could assign -180 to 180 to each orientation and then your algorithm need only compute the difference between the two weights of these edges to figure out if the node is sharp turn and thus eliminate it.\nLook up “multgraph” or “multidigraph” in networkx api for implementation\nOne edge has to be distance other has to be orientation, encoding both orientation and distance to a single weight will require trignometric coding from a central (0) point\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "The first 10 shortest paths in a graph - Igraph 0.6 - Python 2.7\r\n                \r\nI was wondering about this ever since I've started to successfully implement Igraph into my coding: Can you retrieve with get_all_shortest_paths as many shortest paths as you like. Let's say first 10.\n\nI've understood so far that retrieving ALL shortest paths in a undirected graph is non-sense since in most cases you have infinite amount of them. \n\nBut can I simply retrieve first 10 shortest paths? \n\nI've tried to achieve this with an undirected g = Graph() :\n\n```\nlist = []\nlist.append(g.get_all_shortest_paths(index1,index2, \"distance\")[0])   # shortest path\nlist.append(g.get_all_shortest_paths(index1,index2, \"distance\")[1])   # second shortest path\nlist.append(g.get_all_shortest_paths(index1,index2, \"distance\")[2])   # third shortest path\nlist.append(g.get_all_shortest_paths(index1,index2, \"distance\")[3])   # forth shortest path\nlist.append(g.get_all_shortest_paths(index1,index2, \"distance\")[4])   # fifth shortest path\nlist.append(g.get_all_shortest_paths(index1,index2, \"distance\")[5])   # sixth shortest path\nlist.append(g.get_all_shortest_paths(index1,index2, \"distance\")[6])   # seventh shortest path\nlist.append(g.get_all_shortest_paths(index1,index2, \"distance\")[7])   # eigth shortest path\nlist.append(g.get_all_shortest_paths(index1,index2, \"distance\")[8])   # ninth shortest path\nlist.append(g.get_all_shortest_paths(index1,index2, \"distance\")[9])   # tenth shortest path\n\n#\"distance\" is from g.es[\"distance\"]\n```\n\n\nIt would alway give me error that list index is out of range. \nActually I can't even get ```\nlist.append(g.get_all_shortest_paths(index1,index2, \"distance\")[1])```\n, though I know there are more then 10 paths there.\n\nThere is nothing special about the graph. thousands of vertexes, all connected somehow, I mean various vertex degrees. \n\nFinally I would like to have a wx.spin or wx.ComboBox to choose between the paths (i.e. the shortest path which is a national highway in real life has ice on it during winter so I would like to take the second shortest road between City1 and City2... then oh no.. that has kangoroos jumping all over it so I take the third, or better forth path because there I know a McDonalds and I really like to eat junk food bla bla)\n\nI know shortest != short, though I need something like: if shortest no good then ignore that, go to second and so on.\nI've searched Google but it is not clear for me how can I do this.\n\nThank you in advance! \n\nEdit: I might mention that ```\nlist.append(g.get_all_shortest_paths(index1,index2, \"distance\")[1])```\n of course is working when there are exactly 2 shortest paths with naturally the exact same distances.\n\nImportant Update:\n\nSince I've ingloriously misunderstood ```\ng.get_all_shortest_paths```\n this part will change in my code to ```\ng.get_shortest_paths(index1, index2, weights=distance, mode=ALL, output=\"vpath\")```\n and I also mention that the graph is weighted, but that bit is obvious anyway:\n\n```\nlist = []\ng.es[\"weight\"] = distance\nlist.append(g.get_shortest_paths(index1, index2, weights=distance, mode=ALL, output=\"vpath\")[0])   # shortest path\nlist.append(g.get_shortest_paths(index1, index2, weights=distance, mode=ALL, output=\"vpath\")[1])   # second shortest path\nlist.append(g.get_shortest_paths(index1, index2, weights=distance, mode=ALL, output=\"vpath\")[2])   # third shortest path\nlist.append(g.get_shortest_paths(index1, index2, weights=distance, mode=ALL, output=\"vpath\")[3])   # forth shortest path\nlist.append(g.get_shortest_paths(index1, index2, weights=distance, mode=ALL, output=\"vpath\")[4])   # fifth shortest path\nlist.append(g.get_shortest_paths(index1, index2, weights=distance, mode=ALL, output=\"vpath\")[5])   # sixth shortest path\nlist.append(g.get_shortest_paths(index1, index2, weights=distance, mode=ALL, output=\"vpath\")[6])   # seventh shortest path\nlist.append(g.get_shortest_paths(index1, index2, weights=distance, mode=ALL, output=\"vpath\")[7])   # eigth shortest path\nlist.append(g.get_shortest_paths(index1, index2, weights=distance, mode=ALL, output=\"vpath\")[8])   # ninth shortest path\nlist.append(g.get_shortest_paths(index1, index2, weights=distance, mode=ALL, output=\"vpath\")[9])   # tenth shortest path\n\n#\"distance\" is a list containing the weights\n# graph is TRUE-ly weighted now\n```\n\n\nHow to get the first 10 or all short paths between two vertex's?\n\nThis question is still looking for its answer to be accepted. Thank you.\n\n(P.S. I've kept the wrong approach in the first part of the question since might be other enormous idiobooms out there like me who try the same thing)\n    ", "Answer": "\r\nOkay, I'm still unsure what you mean by the \"first 10 shortest paths\", but here is what I think you might want to achieve. You have a graph where the edges are labeled by the actual (say, Euclidean) distance of the two endpoints. You are given two points, and you wish to find a few alternate paths between them while trying to keep these paths as short as possible. Note that since your graph is weighted, it is very unlikely that you will have many shortest paths between two points - in order for all of the paths to be the shortest, they must have exactly the same total weight. If your weights measure actual distances \"as the crow flies\", it is very unlikely that such a co-occurrence ever happens - the ten paths you would be looking for would have slightly different lengths. So, ```\nget_all_shortest_paths```\n is not useful to you, not only because it does not use weights, but also because even if it did, you are unlikely find multiple paths between two points that have exactly the same length.\n\nAn alternative is ```\nget_shortest_paths```\n, which can consider weights, but it will return only one path between a pair of vertices. (The reason why it is called ```\nget_shortest_paths```\n is because it returns multiple paths if you specify multiple target vertices - more precisely, it gives you one path for each target vertex). So, you cannot use ```\nget_shortest_paths```\n to obtain the ten paths you are looking for.\n\nAfter some googling, I have found an implementation of the k-shortest-paths algorithm that might be useful for you. It is not part of ```\nigraph```\n, but you can save your graph from ```\nigraph```\n, call out to the compiled executable of the k-shortest-paths algorithm using ```\nos.system```\n or the ```\nsubprocess```\n module in Python and then parse the result somehow.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How to improve several shortest paths search over the same graph ?\r\n                \r\nI had the next situation and i need to find the best optimization to solve the problem.\n\nI graph G\n\nfor putting an example lets asume the graph looks like this\n\n\nAnd the problem require find the addition of the weights in shortest paths (just lets call it ```\nSP```\n) between several vertices and add them all. \n\nI mean if the shortest paths between ```\na - b```\n is ```\na -> c -> d```\n his ```\nSP```\n would be ```\nx0 + x1 + x2```\n\n\nSo a set of my problem would look like this:\n\n\na - g \na - h \ne - f\n.... etc\n\n\nSo the naive solution is to found the ```\nSP```\n for between every set every time\n\n```\nSP(a,g) + SP(a,h) + SP(e,f) + ... = result\n```\n\n\nSo this is when the optimization task begin , i already implement two improvements but i need the best optimization (if it is possible), let see what i already did:\n\n\nSave every result of every shortest path found so if there is asked again i had the problem\n\n\nexample. if the ```\nSP```\n between ```\na - g```\n is ```\nw```\n  i save it so if i asked again which is the value of ```\nSP```\n between ```\na - g```\n or ```\ng - a```\n i already know the result\n\n\nSave every subsequent ```\nSP```\n found and save it\n\n\nexample.\n\nIf i asked to found the SP between ```\na - g```\n. Lets assume that the shortest paths between that two vertices is ```\na -> c -> d -> j -> g```\n so the ```\nSP```\n would be\n\n```\nx0 + x1 + x2 + x3\n```\n\n\nso i can save  ```\na - g```\n but also i can save the SP of all the subsequent paths found.\n\nfor example the shortest paths between ```\na```\n and ```\nj```\n is ```\na -> c -> d -> j```\n \nor the paths between ```\nc and j```\n is ```\nc -> d -> j```\n\n\nhere are all the ```\nSP```\n founds\n\n```\nSP(a,c) = x0\nSP(a,d) = x0 + x1\nSP(a,j) = x0 + + x1 + x2\n\nSP(c,d) = x1\nSP(c,j) = x1 + x2\nSP(c,g) = x1 + x2 + x3\n\nSP(d,j) = x2\nSP(d,g) = x2 + x3\n\nSP(j,g) = x3\n```\n\n\nAnd i save every result.\n\nSo now this last improvement has save a lot time but it seems don't enough since the quantity of nodes and the set of the SP to found is considerable big.\n\nSo any suggestion or any particular algorithms that i can use to improve this problems (i hope been enough clear please write a comment if any details is not explained) ?\n    ", "Answer": "\r\nIf you have many pairs to compute, consider Floyd-Warshall; it will give you the shortest-path distance from any point to any other point (at the cost of O(n^3) runtime).\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Dijkstra’s shortest-path algorithm what if there are paths with same distance?\r\n                \r\n\n\nIn this network Dijkstra’s shortest-path algorithm is used. \nThe question is which path will A use to reach D because both are equal? \n\n\n\nis that table missing?\n    ", "Answer": "\r\nIt depends on your actual implementation and the way your input graph was described (e.g. edges can go in different order and this will have an impact on the result if there are many). \n\nHowever, it's guaranteed that it will find some path which has optimal length.\n\nYour table seems to be wrong at E and F vertices. The parent vertex for E is D (AB->BD->DE = 3 + 4 + 2 = 9), so is for F.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "The first 10 shortest paths in a graph - Igraph 0.6 - Python 2.7\r\n                \r\nI was wondering about this ever since I've started to successfully implement Igraph into my coding: Can you retrieve with get_all_shortest_paths as many shortest paths as you like. Let's say first 10.\n\nI've understood so far that retrieving ALL shortest paths in a undirected graph is non-sense since in most cases you have infinite amount of them. \n\nBut can I simply retrieve first 10 shortest paths? \n\nI've tried to achieve this with an undirected g = Graph() :\n\n```\nlist = []\nlist.append(g.get_all_shortest_paths(index1,index2, \"distance\")[0])   # shortest path\nlist.append(g.get_all_shortest_paths(index1,index2, \"distance\")[1])   # second shortest path\nlist.append(g.get_all_shortest_paths(index1,index2, \"distance\")[2])   # third shortest path\nlist.append(g.get_all_shortest_paths(index1,index2, \"distance\")[3])   # forth shortest path\nlist.append(g.get_all_shortest_paths(index1,index2, \"distance\")[4])   # fifth shortest path\nlist.append(g.get_all_shortest_paths(index1,index2, \"distance\")[5])   # sixth shortest path\nlist.append(g.get_all_shortest_paths(index1,index2, \"distance\")[6])   # seventh shortest path\nlist.append(g.get_all_shortest_paths(index1,index2, \"distance\")[7])   # eigth shortest path\nlist.append(g.get_all_shortest_paths(index1,index2, \"distance\")[8])   # ninth shortest path\nlist.append(g.get_all_shortest_paths(index1,index2, \"distance\")[9])   # tenth shortest path\n\n#\"distance\" is from g.es[\"distance\"]\n```\n\n\nIt would alway give me error that list index is out of range. \nActually I can't even get ```\nlist.append(g.get_all_shortest_paths(index1,index2, \"distance\")[1])```\n, though I know there are more then 10 paths there.\n\nThere is nothing special about the graph. thousands of vertexes, all connected somehow, I mean various vertex degrees. \n\nFinally I would like to have a wx.spin or wx.ComboBox to choose between the paths (i.e. the shortest path which is a national highway in real life has ice on it during winter so I would like to take the second shortest road between City1 and City2... then oh no.. that has kangoroos jumping all over it so I take the third, or better forth path because there I know a McDonalds and I really like to eat junk food bla bla)\n\nI know shortest != short, though I need something like: if shortest no good then ignore that, go to second and so on.\nI've searched Google but it is not clear for me how can I do this.\n\nThank you in advance! \n\nEdit: I might mention that ```\nlist.append(g.get_all_shortest_paths(index1,index2, \"distance\")[1])```\n of course is working when there are exactly 2 shortest paths with naturally the exact same distances.\n\nImportant Update:\n\nSince I've ingloriously misunderstood ```\ng.get_all_shortest_paths```\n this part will change in my code to ```\ng.get_shortest_paths(index1, index2, weights=distance, mode=ALL, output=\"vpath\")```\n and I also mention that the graph is weighted, but that bit is obvious anyway:\n\n```\nlist = []\ng.es[\"weight\"] = distance\nlist.append(g.get_shortest_paths(index1, index2, weights=distance, mode=ALL, output=\"vpath\")[0])   # shortest path\nlist.append(g.get_shortest_paths(index1, index2, weights=distance, mode=ALL, output=\"vpath\")[1])   # second shortest path\nlist.append(g.get_shortest_paths(index1, index2, weights=distance, mode=ALL, output=\"vpath\")[2])   # third shortest path\nlist.append(g.get_shortest_paths(index1, index2, weights=distance, mode=ALL, output=\"vpath\")[3])   # forth shortest path\nlist.append(g.get_shortest_paths(index1, index2, weights=distance, mode=ALL, output=\"vpath\")[4])   # fifth shortest path\nlist.append(g.get_shortest_paths(index1, index2, weights=distance, mode=ALL, output=\"vpath\")[5])   # sixth shortest path\nlist.append(g.get_shortest_paths(index1, index2, weights=distance, mode=ALL, output=\"vpath\")[6])   # seventh shortest path\nlist.append(g.get_shortest_paths(index1, index2, weights=distance, mode=ALL, output=\"vpath\")[7])   # eigth shortest path\nlist.append(g.get_shortest_paths(index1, index2, weights=distance, mode=ALL, output=\"vpath\")[8])   # ninth shortest path\nlist.append(g.get_shortest_paths(index1, index2, weights=distance, mode=ALL, output=\"vpath\")[9])   # tenth shortest path\n\n#\"distance\" is a list containing the weights\n# graph is TRUE-ly weighted now\n```\n\n\nHow to get the first 10 or all short paths between two vertex's?\n\nThis question is still looking for its answer to be accepted. Thank you.\n\n(P.S. I've kept the wrong approach in the first part of the question since might be other enormous idiobooms out there like me who try the same thing)\n    ", "Answer": "\r\nOkay, I'm still unsure what you mean by the \"first 10 shortest paths\", but here is what I think you might want to achieve. You have a graph where the edges are labeled by the actual (say, Euclidean) distance of the two endpoints. You are given two points, and you wish to find a few alternate paths between them while trying to keep these paths as short as possible. Note that since your graph is weighted, it is very unlikely that you will have many shortest paths between two points - in order for all of the paths to be the shortest, they must have exactly the same total weight. If your weights measure actual distances \"as the crow flies\", it is very unlikely that such a co-occurrence ever happens - the ten paths you would be looking for would have slightly different lengths. So, ```\nget_all_shortest_paths```\n is not useful to you, not only because it does not use weights, but also because even if it did, you are unlikely find multiple paths between two points that have exactly the same length.\n\nAn alternative is ```\nget_shortest_paths```\n, which can consider weights, but it will return only one path between a pair of vertices. (The reason why it is called ```\nget_shortest_paths```\n is because it returns multiple paths if you specify multiple target vertices - more precisely, it gives you one path for each target vertex). So, you cannot use ```\nget_shortest_paths```\n to obtain the ten paths you are looking for.\n\nAfter some googling, I have found an implementation of the k-shortest-paths algorithm that might be useful for you. It is not part of ```\nigraph```\n, but you can save your graph from ```\nigraph```\n, call out to the compiled executable of the k-shortest-paths algorithm using ```\nos.system```\n or the ```\nsubprocess```\n module in Python and then parse the result somehow.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Neo4j shortest path with cycles\r\n                \r\nI've been evaluating Neo4j 1.9.M03 for a while now, and have come to a head that I did not expect. \n\nI have a graph of ~140,000 vertices. I also have three classes of edges, let's call them father, mother, and husband. There are about 80,000 edges per class. There are no properties, and no indexes. The vertex store size is about 1.3 MB, and the edge store is about 8 MB. \n\nThe data originates in SQL Server and the quality of migration from SQL to Neo4j is known to be correct. A SQL shortest path stored procedure has been run for dozens of vertex pairs, such that the shortest path distance and path is known.\n\nThe shortest path query is Cypher: ```\nSTART one=node(0), two=node(1234) MATCH p = shortestPath(one-[*..1000]-two) RETURN p;```\n\n\nPARTIAL TEST CASE ONE: I use only husband and father relations, the occurrence of cycles (e.g. ```\nv[0] -> v[1] -> v[2] -> v[0])```\n is low. If I perform a shortest path calculation on a specific known long path (e.g. known to be ~450 hops), it returns within 50ms (non-cached) with a path of ~550 hops. The increased length is expected, since we are excluding a portion of the edges.\n\nPARTIAL TEST CASE TWO: Likewise, if I use only husband and mother relations, the occurrence of cycles (e.g. ```\nv[0] -> v[1] -> v[2] -> v[0])```\n is low. If I perform the same shortest path, I get a result on the same order as before: about 50ms (non-cached), with a similar increase in path length.\n\nFULL TEST CASE: I use all (father, mother, and husband) relations. The occurrence of cycles is now predictably high because of the common case ```\nv[0] mother-> v[1] husband-> v[2] <-father v[0]```\n. When I execute the shortest path query, the JVM allocates 4 gigabytes of memory and the calculation does not complete. This is the problem.\n\n\n\nMy thesis is that the regular occurrence of cycles is causing this behavior, otherwise I would not expect such a huge difference in performance when I only add another class of parent edge--unless the shortest path algorithm was not accounting for cycles.\n\nI applied the Dijkstra Algorithm using the Java API directly, with a cost of 1 across all edges, and achieved similar results to the standard ShortestPath algorithm used. As a result, I received this exception after 6 minutes of IntelliJ debug time.\n\n```\nException in thread \"main\" java.lang.OutOfMemoryError: GC overhead limit exceeded\n    at org.neo4j.kernel.impl.util.RelIdArray$RelIdIteratorImpl.<init>(RelIdArray.java:661)\n    at org.neo4j.kernel.impl.util.RelIdArray$DirectionWrapper$3.iterator(RelIdArray.java:327)\n    at org.neo4j.kernel.impl.util.RelIdArray.iterator(RelIdArray.java:270)\n    at org.neo4j.kernel.impl.core.NodeImpl.getAllRelationships(NodeImpl.java:172)\n    at org.neo4j.kernel.impl.core.NodeImpl.getRelationships(NodeImpl.java:270)\n    at org.neo4j.kernel.impl.core.NodeProxy.getRelationships(NodeProxy.java:82)\n    at org.neo4j.kernel.StandardExpander$AllExpander.doExpand(StandardExpander.java:303)\n    at org.neo4j.kernel.StandardExpander$RelationshipExpansion.iterator(StandardExpander.java:194)\n    at org.neo4j.kernel.impl.traversal.TraversalBranchImpl.expandRelationshipsWithoutChecks(TraversalBranchImpl.java:114)\n    at org.neo4j.kernel.impl.traversal.TraversalBranchImpl.expandRelationships(TraversalBranchImpl.java:104)\n    at org.neo4j.kernel.impl.traversal.TraversalBranchImpl.initialize(TraversalBranchImpl.java:130)\n    at org.neo4j.kernel.impl.traversal.TraversalBranchImpl.next(TraversalBranchImpl.java:150)\n    at org.neo4j.graphalgo.impl.util.BestFirstSelectorFactory$BestFirstSelector.next(BestFirstSelectorFactory.java:73)\n    at org.neo4j.kernel.impl.traversal.TraverserIterator.fetchNextOrNull(TraverserIterator.java:65)\n    at org.neo4j.kernel.impl.traversal.TraverserIterator.fetchNextOrNull(TraverserIterator.java:34)\n    at org.neo4j.helpers.collection.PrefetchingIterator.hasNext(PrefetchingIterator.java:55)\n    at org.neo4j.graphalgo.impl.util.StopAfterWeightIterator.fetchNextOrNull(StopAfterWeightIterator.java:45)\n    at org.neo4j.graphalgo.impl.util.StopAfterWeightIterator.fetchNextOrNull(StopAfterWeightIterator.java:29)\n    at org.neo4j.helpers.collection.PrefetchingIterator.hasNext(PrefetchingIterator.java:55)\n    at org.neo4j.helpers.collection.IteratorUtil.firstOrNull(IteratorUtil.java:51)\n    at org.neo4j.helpers.collection.IteratorUtil.firstOrNull(IteratorUtil.java:201)\n    at org.neo4j.graphalgo.impl.path.Dijkstra.findSinglePath(Dijkstra.java:98)\n    at org.neo4j.graphalgo.impl.path.Dijkstra.findSinglePath(Dijkstra.java:50)\n    at ShortestPathCalc.Dijkstra(Main.java:198)\n    at Main.main(Main.java:53)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:601)\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120)\n```\n\n\nDo you think I'm right? Is this a known limitation of graph databases or their shortest path algorithms? It seems quite silly to me that previously-visited vertexes would not be stored in a hash table, such that the shortest path algorithm would not attempt to path out of a previously visited vertex more than once.\n\n\n\nUPDATE 1/25/2013 \n\nA Github repo so you can follow along!\n\n```\nhttps://github.com/squirrelsama/neo4j-shortestpath-issue\n```\n\n\n\n\nUPDATE 2/7/2013\n\nSee the accepted answer. In short, cycles have nothing to do with it.\n    ", "Answer": "\r\nUsing the neo4j traversal framework you can select which uniqueness to use in a traversal, for example RELATIONSHIP_GLOBAL, such that it only traverses a relationship once during a traversal. That may that would resolve your problems:\n\n\n// single directional\nTraversal.traversal( Uniqueness.RELATIONSHIP_GLOBAL )\n         .evaluator( Evaluators.returnWhereEndNodeIs( myEndNode )\n         .traverse( myStartNode );\n\n// bi-directional\nTraversal.bidirectionalTraversal()\n         .mirroredSides( Traversal.traversal( Uniqueness.RELATIONSHIP_GLOBAL ) )\n         .traverse( myStartNode, myEndNode );\n\n\nthe above examples are in principal and may need to be modified to work with your query though.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Bidirectional A* not finding the shortest path\r\n                \r\nI'm implementing bidirectional ```\nA*```\n algorithm in Python 2.7.12 and testing it on the map of Romania from from Russell and Norvig, Chapter 3. The edges have weights and the aim is to find the shortest path between two nodes.\n\nHere is the visualization of the testing graph:\n\n\n\nThe example where my Bidirectional A* is failing is that where the starting point is ```\n'a'```\n and the goal is ```\n'u'```\n. This is the path that my implementation has found:\n\nThe length of ```\n['a', 's', 'f', 'b', 'u']```\n is ```\n535```\n.\n\nThis is the actual shortest path from ```\n'a'```\n to ```\n'u'```\n:\n\nThe length of ```\n['a', 's', 'r', 'p', 'b', 'u']```\n is ```\n503```\n.\n\nAs we can see, my implementation failed to find the shortest path. I think that the problem may be in my stopping conditions, but I don't know. \n\nThis is the python script with my implementation of A* (I used Euclidean distance as a heuristic) and few other help classes and functions:\n\n```\nfrom __future__ import division\nimport math\nfrom networkx import *\nimport random\nimport pickle\nimport sys\nimport heapq\nimport matplotlib.pyplot as plt\n\n\nclass PriorityQueue():\n    \"\"\"Implementation of a priority queue\"\"\"\n    def __init__(self):\n        self.queue = []\n        self.node_finder = dict()\n        self.current = 0\n        self.REMOVED_SYMBOL = '<removed>'\n\n    def next(self):\n        if self.current >=len(self.queue):\n            self.current\n            raise StopIteration\n\n        out = self.queue[self.current]\n        self.current += 1\n        return out\n\n    def pop(self):\n        while self.queue:\n            node = heapq.heappop(self.queue)\n            nodeId = node[1]\n            if nodeId is not self.REMOVED_SYMBOL:\n                try:\n                    del self.node_finder[nodeId]\n                except KeyError:\n                    dummy=1\n                return node\n\n    def remove(self, nodeId):\n        node = self.node_finder[nodeId]\n        node[1] = self.REMOVED_SYMBOL\n\n    def __iter__(self):\n        return self\n\n    def __str__(self):\n        return 'PQ:[%s]'%(', '.join([str(i) for i in self.queue]))\n\n    def append(self, node):\n        nodeId = node[1]\n        nodePriority = node[0]\n        node = [nodePriority, nodeId]\n        self.node_finder[nodeId] = node\n        heapq.heappush(self.queue, node)\n\n    def update(self, node):\n        nodeId = node[1]\n        nodePriority = node[0]\n        node = [nodePriority, nodeId]\n        self.remove(nodeId)\n        self.node_finder[nodeId] = node\n        heapq.heappush(self.queue, node)\n\n    def getPriority(self, nodeId):\n        return self.node_finder[nodeId][0]\n\n    def __contains__(self, key):\n        self.current = 0\n        return key in [n for v,n in self.queue]\n\n    def __eq__(self, other):\n        return self == other\n\n    def size(self):\n        return len(self.queue)\n\n    def clear(self):\n        self.queue = []\n\n    def top(self):\n        return self.queue[0]\n\n    __next__ = next\n\ndef bidirectional_a_star(graph, start, goal):\n    if start == goal:\n        return []\n\n    pq_s = PriorityQueue()\n    pq_t = PriorityQueue()\n    closed_s = dict()\n    closed_t = dict()\n    g_s = dict()\n    g_t = dict()\n\n    g_s[start] = 0\n    g_t[goal] = 0\n\n    cameFrom1 = dict()\n    cameFrom2 = dict()\n\n    def euclidean_distance(graph, v, goal):\n        xv, yv = graph.node[v]['pos']\n        xg, yg = graph.node[goal]['pos']\n        return ((xv-xg)**2 + (yv-yg)**2)**0.5\n\n    def h1(v): # heuristic for forward search (from start to goal)\n        return euclidean_distance(graph, v, goal)\n\n    def h2(v): # heuristic for backward search (from goal to start)\n        return euclidean_distance(graph, v, start)\n\n    cameFrom1[start] = False\n    cameFrom2[goal] = False\n\n    pq_s.append((0+h1(start), start)) \n    pq_t.append((0+h2(goal), goal))\n\n    done = False\n    i = 0\n\n    mu = 10**301 # 10**301 plays the role of infinity\n    connection = None\n\n    while pq_s.size() > 0 and pq_t.size() > 0 and done == False:\n        i = i + 1\n        if i % 2 == 1: # alternate between forward and backward A*\n            fu, u = pq_s.pop()\n            closed_s[u] = True\n            for v in graph[u]:\n                weight = graph[u][v]['weight']\n                if v in g_s:\n                    if g_s[u] + weight < g_s[v]:\n                        g_s[v] = g_s[u] + weight\n                        cameFrom1[v] = u\n                        if v in closed_s:\n                            del closed_s[v]\n                        if v in pq_s:\n                            pq_s.update((g_s[v]+h1(v), v))\n                        else:\n                            pq_s.append((g_s[v]+h1(v), v))\n                else:\n                    g_s[v] = g_s[u] + weight\n                    cameFrom1[v] = u\n                    pq_s.append((g_s[v]+h1(v), v))\n                if v in closed_t:\n                    if g_s[u] + weight + g_t[v] < mu:\n                        mu = g_s[u] + weight + g_t[v]\n                        connection = v\n                        done = True\n        else:\n            fu, u = pq_t.pop()\n            closed_t[u] = True\n            for v in graph[u]:\n                weight = graph[u][v]['weight']\n                if v in g_t:\n                    if g_t[u] + weight < g_t[v]:\n                        g_t[v] = g_t[u] + weight\n                        cameFrom2[v] = u\n                        if v in closed_t:\n                            del closed_t[v]\n                        if v in pq_t:\n                            pq_t.update((g_t[v]+h2(v), v))\n                        else:\n                            pq_t.append((g_t[v]+h2(v), v))\n                else:\n                    g_t[v] = g_t[u] + weight\n                    cameFrom2[v] = u\n                    pq_t.append((g_t[v]+h2(v), v))\n                if v in closed_s:\n                    if g_t[u] + weight + g_s[v] < mu:\n                        mu = g_t[u] + weight + g_s[v] \n                        connection = v\n                        done = True\n\n        if u in closed_s and u in closed_t:\n            if g_s[u] + g_t[u] < mu:\n                mu = g_s[u] + g_t[u]\n                connection = u\n                stopping_distance = min(min([f for (f,x) in pq_s]), min([f for (f,x) in pq_t]))\n                if mu <= stopping_distance:\n                    done = True\n                    #connection = u\n                    continue\n\n    if connection is None:\n        # start and goal are not connected\n        return None\n\n    #print cameFrom1\n    #print cameFrom2\n\n    path = []\n    current = connection\n    #print current\n    while current != False:\n        #print predecessor\n        path = [current] + path\n        current = cameFrom1[current]\n\n    current = connection\n    successor = cameFrom2[current]\n    while successor != False:\n        path = path + [successor]\n        current = successor\n        successor = cameFrom2[current]\n\n    return path\n\n\n# This function visualizes paths\ndef draw_graph(graph, node_positions={}, start=None, goal=None, path=[]):\n\n    explored = list(graph.get_explored_nodes())\n\n    labels ={}\n    for node in graph:\n        labels[node]=node\n\n    if not node_positions:\n        node_positions = networkx.spring_layout(graph)\n\n    edge_labels = networkx.get_edge_attributes(graph,'weight')\n\n    networkx.draw_networkx_nodes(graph, node_positions)\n    networkx.draw_networkx_edges(graph, node_positions, style='dashed')\n    networkx.draw_networkx_edge_labels(graph, node_positions, edge_labels=edge_labels)\n    networkx.draw_networkx_labels(graph,node_positions, labels)\n\n    networkx.draw_networkx_nodes(graph, node_positions, nodelist=explored, node_color='g') \n\n    if path:\n        edges = [(path[i], path[i+1]) for i in range(0, len(path)-1)]\n        networkx.draw_networkx_edges(graph, node_positions, edgelist=edges, edge_color='b')\n\n    if start:\n        networkx.draw_networkx_nodes(graph, node_positions, nodelist=[start], node_color='b')\n\n    if goal:\n        networkx.draw_networkx_nodes(graph, node_positions, nodelist=[goal], node_color='y')\n\n\n    plt.plot()\n    plt.show()\n\n# this function calculates the length of the path\ndef calculate_length(graph, path):\n    pairs = zip(path, path[1:])\n    return sum([graph.get_edge_data(a, b)['weight'] for a, b in pairs])\n\n#Romania map data from Russell and Norvig, Chapter 3.\nromania = pickle.load(open('romania_graph.pickle', 'rb'))\n\nnode_positions = {n: romania.node[n]['pos'] for n in romania.node.keys()}\n\nstart = 'a'\ngoal = 'u'\n\npath = bidirectional_a_star(romania, start, goal)\nprint \"This is the path found by bidirectional A* :\", path\nprint \"Its length :\", calculate_length(romania, path)\n# visualize my path\ndraw_graph(romania, node_positions=node_positions, start=start, goal=goal, path=path)\n\n\n# compare to the true shortest path between start and goal\n\ntrue_path = networkx.shortest_path(romania, start, goal, weight='weight')\nprint \"This is the actual shortest path: \", true_path\nprint \"Its lenght: \", calculate_length(romania, true_path)\n#visualize true_path\ndraw_graph(romania, node_positions=node_positions, start=start, goal=goal, path=true_path)\n```\n\n\nPickle data for Romania can be downloaded from here.\n    ", "Answer": "\r\nI corrected some errors in ```\nPriorityQueue```\n and ```\nbidirectional_a_star```\n. It's working fine now.\n\nThe corrected code for the class and the function is as follows:\n\n```\nclass PriorityQueue():\n    \"\"\"Implementation of a priority queue\"\"\"\n    def __init__(self):\n        self.queue = []\n        self.node_finder = dict()\n        self.current = 0\n        self.REMOVED_SYMBOL = '<removed>'\n\n    def next(self):\n        if self.current >=len(self.queue):\n            self.current\n            raise StopIteration\n\n        out = self.queue[self.current]\n        while out == self.REMOVED_SYMBOL:\n            self.current += 1\n            out = self.queue[self.current]\n        self.current += 1\n        return out\n\n    def pop(self):\n        # TODO: finish this\n        while self.queue:\n            node = heapq.heappop(self.queue)\n            nodeId = node[1]\n            if nodeId is not self.REMOVED_SYMBOL:\n                try:\n                    del self.node_finder[nodeId]\n                except KeyError:\n                    dummy=1\n                return node\n        #raise KeyError('pop from an empty priority queue')\n\n    def remove(self, nodeId):\n        node = self.node_finder[nodeId]\n        node[1] = self.REMOVED_SYMBOL\n\n    def __iter__(self):\n        return self\n\n    def __str__(self):\n        return 'PQ:[%s]'%(', '.join([str(i) for i in self.queue]))\n\n    def append(self, node):\n        # node = (priority, nodeId)\n        nodeId = node[1]\n        nodePriority = node[0]\n        node = [nodePriority, nodeId]\n        self.node_finder[nodeId] = node\n        heapq.heappush(self.queue, node)\n\n    def update(self, node):\n        nodeId = node[1]\n        nodePriority = node[0]\n        node = [nodePriority, nodeId]\n        self.remove(nodeId)\n        self.node_finder[nodeId] = node\n        heapq.heappush(self.queue, node)\n\n    def getPriority(self, nodeId):\n        return self.node_finder[nodeId][0]\n\n    def __contains__(self, key):\n        self.current = 0\n        return key in [n for v,n in self.queue]\n\n    def __eq__(self, other):\n        return self == other\n\n    def size(self):\n        return len([1 for priority, node in self.queue if node!=self.REMOVED_SYMBOL])\n\n    def clear(self):\n        self.queue = []\n\n    def top(self):\n        return self.queue[0]\n\n    __next__ = next\n\ndef bidirectional_a_star(graph, start, goal):\n    if start == goal:\n        return []\n\n    pq_s = PriorityQueue()\n    pq_t = PriorityQueue()\n    closed_s = dict()\n    closed_t = dict()\n    g_s = dict()\n    g_t = dict()\n\n    g_s[start] = 0\n    g_t[goal] = 0\n\n    cameFrom1 = dict()\n    cameFrom2 = dict()\n\n    def euclidean_distance(graph, v, goal):\n        xv, yv = graph.node[v]['pos']\n        xg, yg = graph.node[goal]['pos']\n        return ((xv-xg)**2 + (yv-yg)**2)**0.5\n\n    def h1(v): # heuristic for forward search (from start to goal)\n        return euclidean_distance(graph, v, goal)\n\n    def h2(v): # heuristic for backward search (from goal to start)\n        return euclidean_distance(graph, v, start)\n\n    cameFrom1[start] = False\n    cameFrom2[goal] = False\n\n    pq_s.append((0+h1(start), start)) \n    pq_t.append((0+h2(goal), goal))\n\n    done = False\n    i = 0\n\n    mu = 10**301 # 10**301 plays the role of infinity\n    connection = None\n\n    while pq_s.size() > 0 and pq_t.size() > 0 and done == False:\n        i = i + 1\n        if i % 2 == 1: # alternate between forward and backward A*\n            fu, u = pq_s.pop()\n            closed_s[u] = True\n            for v in graph[u]:\n                weight = graph[u][v]['weight']\n                if v in g_s:\n                    if g_s[u] + weight < g_s[v]:\n                        g_s[v] = g_s[u] + weight\n                        cameFrom1[v] = u\n                        if v in closed_s:\n                            del closed_s[v]\n                        if v in pq_s:\n                            pq_s.update((g_s[v]+h1(v), v))\n                        else:\n                            pq_s.append((g_s[v]+h1(v), v))\n                else:\n                    g_s[v] = g_s[u] + weight\n                    cameFrom1[v] = u\n                    pq_s.append((g_s[v]+h1(v), v))\n        else:\n            fu, u = pq_t.pop()\n            closed_t[u] = True\n            for v in graph[u]:\n                weight = graph[u][v]['weight']\n                if v in g_t:\n                    if g_t[u] + weight < g_t[v]:\n                        g_t[v] = g_t[u] + weight\n                        cameFrom2[v] = u\n                        if v in closed_t:\n                            del closed_t[v]\n                        if v in pq_t:\n                            pq_t.update((g_t[v]+h2(v), v))\n                        else:\n                            pq_t.append((g_t[v]+h2(v), v))\n                else:\n                    g_t[v] = g_t[u] + weight\n                    cameFrom2[v] = u\n                    pq_t.append((g_t[v]+h2(v), v))\n\n        if u in closed_s and u in closed_t:\n            if g_s[u] + g_t[u] < mu:\n                mu = g_s[u] + g_t[u]\n                connection = u\n                try:\n                    stopping_distance = max(min([f for (f,x) in pq_s]), min([f for (f,x) in pq_t]))\n                except ValueError:\n                    continue\n                if mu <= stopping_distance:\n                    done = True\n                    connection = u\n                    continue\n\n    if connection is None:\n        # start and goal are not connected\n        return None\n\n    #print cameFrom1\n    #print cameFrom2\n\n    path = []\n    current = connection\n    #print current\n    while current != False:\n        #print predecessor\n        path = [current] + path\n        current = cameFrom1[current]\n\n    current = connection\n    successor = cameFrom2[current]\n    while successor != False:\n        path = path + [successor]\n        current = successor\n        successor = cameFrom2[current]\n\n    return path\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Find the shortest path with maximum gain\r\n                \r\nProblem link How can i modify my code so it give me shortest path with maximum weight.\nProblem overview: I am giving a matrix and i have to go from one index to other with minimum index each index is having some gain , so i have to find the shortest path(if more than one shortest path are possible so path with maximum gain)\nMy code:\n\n```\npublic static int min(int x , int y ,int endx,int endy,int n ,int m,int[][] p){\n     int[] dirx ={1,-1,0,0 };\n        int[] diry={0,0,1,-1};\n        LinkedList<Point> som = new LinkedList<Point>();\n        som.add(new Point(x,y));\n       //dp[x][y]=p[x][y];\n\n        while(!som.isEmpty()){\n          Point xx = som.pop();\n          for(int i=0;i<4;i++){\n\n              int x1 =  xx.x + dirx[i];\n              int y1  = xx.y + diry[i];\n\n              if(x1>=0 && x1<n && y1>=0 && y1<m && p[x1][y1]!=-1 && dp[x1][y1]==-1){\n\n                  dp[x1][y1] =  dp[xx.x][xx.y]+ 1;\n                  som.add(new Point(x1,y1));\n\n              }\n          }\n\n        }\n\n    return dp[endx][endy];\n}\n```\n\n    ", "Answer": "\r\nfrom your code add\n\n```\n((dp[x1][y1]==-1) || ((dp[x1][y1] == dp[xx.x][xx.y] + 1) && (w[xx.x][xx.y]+p[x1][y1] > w[x1][y1])))\n```\n\n\ninstead of\n\n```\n(dp[x1][y1]==-1)\n```\n\n\nand inside the condition\n\n```\nw[x1][y1] = w[xx.x][xx.y] + p[x1][y1];\n```\n\n\nwhich means you will update the path result if you found better way of the same length\n\nalso you may optimize not to add same point several times, but i think this is not necessary in this particular problem\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "python shortest path point\r\n                \r\nI have a points geodataframe, and I have two geodatafram with inicial point and end point.\nI would like to know the index of the nearby points from shortest path \n\n```\ngdf_points = gpd.GeoDataFrame(geometry=gpd.points_from_xy([0,1,2,3,4,5,0,1,2,3,4,5,0,1,2,3,4,5,0,1,2,3,4,5,0,1,2,3,4,5], \n                                                          [0,0,0,0,0,0,1,1,1,1,1,1,2,2,2,2,2,2,3,3,3,3,3,3,4,4,4,4,4,4]))\ngdf_start= gpd.GeoSeries(gpd.points_from_xy([2.5],[0.5]))\ngdf_end= gpd.GeoSeries(gpd.points_from_xy([0.5],[3.5]))\nax=gdf_points.plot() \ngdf_start.plot(ax=ax)\ngdf_end.plot(ax=ax)\n```\n\n\n\n\n\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "igraph how to get edge ids along the shortest paths\r\n                \r\nI have a graph with multiple shortest paths and want to retrieve the ids of the vertices and the ids of the edges:\n\n```\nigraph_get_all_shortest_paths(...)```\n computes only the list of the vertices.\n\nIsn't \n\n```\nigraph_get_shortest_paths(&g, &vertices, &edges, from,igraph_vss_1(to), IGRAPH_ALL);\n```\n\n\nsupposed to do that ?\n\nWhen I run:\n\n```\nigraph_t g1;\nigraph_vector_t v1;\nint ret;\n\n/* Create a graph */\nigraph_vector_init(&v1, 0);\n\nigraph_create(&g1, &v1, 0, 0);\nigraph_add_vertices(&g1, 1, 0);\nigraph_add_vertices(&g1, 1, 0);\nigraph_add_vertices(&g1, 1, 0);\nigraph_add_vertices(&g1, 1, 0);\nigraph_add_vertices(&g1, 1, 0);\n\nigraph_add_edge(&g1,0,1);\nigraph_add_edge(&g1,0,2);\nigraph_add_edge(&g1,2,3);\nigraph_add_edge(&g1,1,3);\nigraph_add_edge(&g1,0,4);\nigraph_add_edge(&g1,4,3);\nigraph_add_edge(&g1,4,3);\nigraph_add_edge(&g1,4,3);\n\nigraph_vector_ptr_t verts;\nigraph_vector_ptr_init(&verts, 2);\n\n\nigraph_vector_ptr_t eds;\nigraph_vector_ptr_init(&eds, 2);\n\nigraph_vector_t v2;\nigraph_vector_init(&v2,2);\nVECTOR(v2)[0] = 3;\nVECTOR(v2)[1] = 3;\n\nigraph_vs_t tovs = igraph_vss_vector(&v2);\n\nigraph_get_shortest_paths(&g1, &verts, &eds, 0, tovs , IGRAPH_ALL);\nigraph_destroy(&g1);\n```\n\n\nI get error: igraph_vector_clear: Assertion `v != ((void *)0)' failed\n    ", "Answer": "\r\nYes it is supposed to do that. From the docs at the igraph homepage:\n\n[...]\n\n```\nvertices```\n:\n\nThe result, the ids of the vertices along the paths. This is a pointer vector, each element points to a vector object. These should be initialized before passing them to the function, which will properly clear and/or resize them and fill the ids of the vertices along the geodesics from/to the vertices. Supply a null pointer here if you don't need these vectors. Normally, either this argument, or the edges should be non-null, but no error or warning is given if they are both null pointers.\n\n```\nedges```\n:\n\nThe result, the ids of the edges along the paths. This is a pointer vector, each element points to a vector object. These should be initialized before passing them to the function, which will properly clear and/or resize them and fill the ids of the vertices along the geodesics from/to the vertices. Supply a null pointer here if you don't need these vectors. Normally, either this argument, or the vertices should be non-null, but no error or warning is given if they are both null pointers.\n\n[...]\n\nSo the vertices along the paths are returned in ```\nvertices```\n and the edges along the paths are returned in ```\nedges```\n.\n\nEdit\n\nI see you added some source code. As the docs says, the vectors in the pointer vector(s) must be allocated and initialized before calling this function. This is somewhat strange, because it is different from other igraph functions, but still, this is why you get the error message.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm shortest path\r\n                \r\nI'm attempting to build a shortest path program and I have a question about the graph.  Are you supposed to draw the graph first??? How else would I define which nodes are neighbors???\n    ", "Answer": "\r\nI assume you mean programatically.\n\nYou define the adjacent nodes in your graph by the structure that you use to store the graph for your program to process it. There are several options: adjacency matrix, adjacency lists and incidence matrix for example.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Dynamically updating shortest paths\r\n                \r\nI have a graph on which I frequently need to know all shortest paths (or rather their lengths). Because I do not want to recalculate them I store them in a simple array and just retrieve them from there. However since the graph might also change over time I will have to recalculate them at given times.\n\nFor now the following changes might happen:\n\n\nAdding a node and an edge to it to the graph\nChanging the length of an edge\nAdding a new edge of the graph\nDeleting an edge or deleting a node\n\n\nIn all cases all nodes will always be connected and all edges have positive weights. Also the graph is undirected. The sequence of operations is such, that all nodes will always be from the same component of the graph. If a node or edge is deleted before this other nodes and edges will have been added so that the graph never becomes separated.\n\nFor now I am planning to just do the updates and then propagate all the changes through the graph structure. However I am not sure yet how to handle this correctly. How would you try to achieve these updates of the cached length.\n\nEDIT:\n\nAs some of you have pointed out it might be neccessary to recalculate everything when a node is added or a link is changed. This might be for example when all distances change through the update. However if I just propagate the changes through the graph and do a relaxation similar to the way it is done dijkstras, I might have to relax the same node multiple times, because I might not choose the optimal order. The question would be how to order the relaxation steps, so I avoid multiple updates as good as possible.\n\nNot sure this makes much sense without the actual idea I have in mind, but I hope this clarifies some more.\n    ", "Answer": "\r\nThe D* family of search algorithms are exactly concerned with the updating of shorting paths in dynamically changing graphs. The algorithms were developed for mobile robot path planning problems. Although the algorithms only return the shortest path from the goal to the current robot location, you might be able to use their bookkeeping and updating rules for all-shortest-paths problems too.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "neo4j shortest path with label constraint\r\n                \r\nlooking to understand if anything can be done to make the query below performant on a large graph.  I'm trying to find the shortest path between two nodes but exclude paths that include certain other kinds of nodes. The issue seems to be the WHERE clause. The query below just completely grinds to a halt.\n\n```\nMATCH p=shortestPath((p1:Party{suprRC:\"21\"})-[*..15]-(p2:Party{suprRC:\"21\"}))\nWITH p\nWHERE NONE(n in nodes(p) where labels(n) in [[\"Reporter\"],[\"FirstName\"],[\"LastName\"]]) \nRETURN p limit 500;\n```\n\n    ", "Answer": "\r\nThe comparison is wrong, ```\nlabels(n)```\n returns a collection of labels and you will match a collection against a collection of single String elements.\n\nAs mentioned by Tom, you can leave off the WITH but you will have to use two ```\nNONE```\n predicates\n\n```\nMATCH p=shortestPath((p1:Party{suprRC:\"21\"})-[*..15]-(p2:Party{suprRC:\"21\"}))\nWHERE NONE(x IN nodes(p) \n             WHERE NONE(l IN ['Reporter','LastName', 'FirstName'] \n                      WHERE l IN labels(x)\n                      )\n          )\nRETURN p limit 500;\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Getting shortest path between 2 nodes in quickgraph\r\n                \r\ni want to ask if there is any way to generate the shortest path from node A to node B\nwithout generating the shortest paths to all the other nodes (stop when node B is in the examined set)\nwith A-star in QuickGraph.\n\nI want to plug QuickGraph into a game and thus generating all the paths is not allowed from the time\nlimitations the environment imposes.\n\nAny other suggestions to solve my problem in C# are welcome\n\nThanks in advance,\nXtapodi\n    ", "Answer": "\r\nQuickgraph 3.3 has a built-in implementation of A* :\n\n```\nQuickGraph.Algorithms.ShortestPath.AStarShortestPathAlgorithm<TVertex,TEdge>\n```\n\n\nwhich version of quickgraph are you using ?\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Finding all the shortest paths between two nodes in unweighted directed graphs using BFS algorithm\r\n                \r\nI am working on a problem that I need to find all the shortest path between two nodes in a given directed unweighted graph. I have used BFS algorithm to do the job, but unfortunately I can only print one shortest path not all of them, for example if they are 4 paths having lenght 3, my algorithm only prints the first one but I would like it to print all the four shortest paths. I was wondering in the following code, how should I change it so that all the shortest paths between two nodes could be printed out?\n\n```\nclass graphNode{\n    public:\n        int id;\n        string name;\n        bool status;\n        double weight;\n};\n\n\nmap<int, map<int,graphNode>* > graph; \n\n\nint Graph::BFS(graphNode &v, graphNode &w){\n\n    queue <int> q;\n    map <int, int> map1;  // this is to check if the node has been visited or not.\n    std::string str= \"\";\n    map<int,int> inQ;  // just to check that we do not insert the same iterm twice in the queue\n\n\n    map <int, map<int, graphNode>* >::iterator pos;\n    pos = graph.find(v.id);\n    if(pos == graph.end()) {\n        cout << v.id << \" does not exists in the graph \" <<endl;\n        return 1;\n\n    }\n\n    int parents[graph.size()+1];   // this vector keeps track of the parents for the node\n    parents[v.id] = -1;\n\n\n    if (findDirectEdge(v.id,w.id) == 1 ){\n        cout << \" Shortest Path: \" << v.id << \" -> \" << w.id << endl;\n        return 1;\n    } //if\n    else{\n        int gn;\n        map <int, map<int, graphNode>* >::iterator pos;\n\n        q.push(v.id);\n        inQ.insert(make_pair(v.id, v.id));\n\n        while (!q.empty()){\n        gn = q.front();\n        q.pop();\n        map<int, int>::iterator it;\n        cout << \" Popping: \" << gn <<endl;\n        map1.insert(make_pair(gn,gn));\n\n\n        if (gn == w.id){//backtracing to  print all the nodes if gn is the same as our target node such as w.id\n            int current = w.id;\n            cout << current << \" - > \";\n            while (current!=v.id){\n                current = parents[current];\n                cout << current << \" -> \";\n            }\n        cout <<endl;\n        }\n                          if ((pos = graph.find(gn)) == graph.end()) {\n            cout << \" pos is empty \" <<endl;\n            continue;\n        }\n        map<int, graphNode>* pn = pos->second;\n\n                          map<int, graphNode>::iterator p = pn->begin();\n        while(p != pn->end()) {\n            map<int, int>::iterator it;\n\n            it = map1.find(p->first);//map1 keeps track of the visited nodes\n            graphNode gn1= p->second;\n            if (it== map1.end())    {\n                map<int, int>::iterator it1;\n                it1 = inQ.find(p->first);  //if the node already exits in the inQ, we do not insert it twice\n\n                if (it1== inQ.end()){\n                    parents[p->first] = gn;\n                    cout << \" inserting \" << p->first << \" into the queue \" <<endl;\n                    q.push(p->first);  // add it to the queue\n                } //if\n            }  //if\n            p++;\n          } //while\n\n    } //while\n}\n```\n\n\nI do appreciate all your great help\nThanks,\nAndra\n    ", "Answer": "\r\n\n```\nmap<int, map<int,graphNode>* > graph```\n declares a graph with one ```\ngraphNode```\n object per edge.\n\nOne ```\ngraphNode```\n per node would have type ```\nmap<int, map<int,graphNode*> >```\n or, even better, ```\nmap<graphNode*, set /* or vector */<graphNode*> >```\n, or perhaps better yet, ```\nmultimap< graphNode *, graphNode * >```\n.\n\nThe ```\ngraphNode```\ns need to be stored in a separate structure (say, ```\nvector```\n or ```\ndeque```\n) from whatever ```\nmap```\n you use.\n```\nint parents[graph.size()+1];```\n is nonstandard. Use ```\nvector<int> parents( graph.size()+1 );```\n instead.\nTo answer your question, you want to continue the BFS until you reach the first node of topological order greater than the first result. Introduce a variable ```\nint first_id_of_next_level = v.id;```\n. (Or better, use a pointer.) When you find a match, append its path to a list of paths. When ```\ngn == first_id_of_next_level```\n, either ```\nreturn```\n the list if it is not ```\nempty```\n or set ```\nfirst_id_of_next_level = p->first```\n, the first child of the current parent, so you know the next opportunity to stop the search.\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How can I use the A star algorithm to find the first 100 shortest paths?\r\n                \r\nHow can I use the A star algorithm to find the first 100 shortest paths?\n    ", "Answer": "\r\nThe problem of finding k'th shortest path is NP-Hard, so any modification to A-Star that will do what you are after - will be exponential in the size of the input.\n\nProof:\n(Note: I will show on simple paths)\nAssume you had a polynomial algorithm that runs in polynomial time and returns the length of ```\nk```\nthe shortest path let the algorithm be ```\nA(G,k)```\n \n\nThe maximal number of paths is ```\nn!```\n, and by applying binary search on the range ```\n[1,n!]```\n to find a shortest path of length ```\nn```\n, you need ```\nO(log(n!)) = O(nlogn)```\n invokations of ```\nA```\n.\nIf you have found there is a path of length ```\nn```\n - it is a hamiltonian path. \nBy repeating the process for each source and target in the graph (```\nO(n^2)```\n of those), you can solve the Hamiltonian Path Problem polynomially, assuming such ```\nA```\n exists.\nQED\n\nFrom this we can conclude, that unless P=NP (and it is very unlikely according to most CS researchers), the problem cannot be solved polynomially.\n\nAn alternative is using a variation of Uniform Cost Search without maintaining ```\nvisited```\n/```\nclosed```\n set. You might be able to modify A* as well, by disabling the closed nodes, and yielding/generating solutions once encountered instead of returning them and finishing, but I cannot think of a way to prove it for A* at the moment.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path in a 3D maze\r\n                \r\nI'm trying to write a program to find the shortest path in a 3D maze using recursion.\n\nI am able to write the code that finds a random path through the maze but I'm wondering how I can modify my code in order to find the shortest path. \n\nPlease note that I want to keep the recursive approach. \n\nCan someone suggest a solution?\n\nHere is a sample 2D maze:\n\n```\ns    \nXXXX \nXX X\nXXX  \nXe  X\n```\n\n\nOne starts from ```\ns```\n going to ```\ne```\n. ```\nX```\n is an obstacle and ```\n```\n is the route.\n    ", "Answer": "\r\nIt depends on the algorithm you are implementing. If you want a recursive approach then finding a random path is a good start point (although if the problem is too complex then a bad choice could have huge effects on number of attempts needed for convergence). Afterwards you need to modify the path and for example check whether the new path is shorter than the pervious one; if yes then you continue modifying your parameters in the same direction. Otherwise you have to change your direction.\nExit criterium for the algorithm/ program is normally the difference between the found solution and the ideal solution. So if you know the length of the ideal path (the optimal solution, you need not know the path itself but only its length) in advance then you can define an error margin of 10^-9 for example and once the difference between both solutions is less than this margin your algorithm exits.\n\nIn conclusion, this question is a mathematical optimization problem. Optimization is a field which has well-established literature eventhough it is a little bit complex. However if I were you I would search for shortest path algorithms and implement one which is best suited to my application (3D Maze)\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Find the shortest path through a store\r\n                \r\nI'd like an algorithm to calculate the shortest path through a store while passing through a predetermined set of points.\nSo for example: My targets are Milk and Eggs and I want the shortest path through the store while picking up these items.\nFormally the requirements for the algorithm are as follows:\n\nStart at Entrance\nEnd at Exit\nPass through a predetermined set of points in the store\nPath must optimal or close to optimal\n\nI started off by visualizing this problem as a graph where the shelves of the items are the vertices in the graph and the paths through the store are the edges. The graph is weighted by distance.\nThe following is a store represented as a graph, A is the entrance and F is the exit (I left out the weights in this example):\n\nHow can the shortest path be calculated from A to F whilst also passing through C and D? (C and D can be visited in any order)\nAn idea I had was to use Dijkstra's Algorithm to find the shortest path from A to C and then from C to D and then from D to F. However I think this solution may fail in larger graphs. Does an algorithm exist which solves this problem?\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Display the Shortest Path using BFS in java\r\n                \r\nThis is my ```\nBFS```\n algorithm code. \n\nI can calculate the shortest path distance, but somehow I am not able to display the shortest path. \n\nLike for example, I calculated the shortest path from source to destination is 2. But i would like to also display the pathway. (PlaceA -> PlaceB -> PlaceC) for example.  \n\nMay i know how do i display out the shortest path out using ```\nJava```\n?\nPlease do help me! Thank you! \n\n```\n public static void main(String[] args) {\n        // TODO Auto-generated method stub\n\n        chooseNumOfVertices();\n        chooseNumOfEdges();\n        generateGraph();\n\n        in.close();\n    }\n\n    private static void generateGraph() {\n        int source = 0;\n        int destination = 0;\n        int edge = chooseEdge;\n\n        // TODO Auto-generated method stub\n        ArrayList<LinkedList<Integer>> graph = new ArrayList<LinkedList<Integer>>();\n        for (int i = 0; i < limit; i++) {\n            LinkedList<Integer> vertex = new LinkedList<Integer>();\n            vertex.add(i);\n            graph.add(vertex);\n        }\n\n        while (chooseEdge > 0) {\n            // Randomize the value\n            int value = new Random().nextInt(cityMapping.size());\n            int value2 = new Random().nextInt(cityMapping.size());\n\n            //\n            if (value != value2 && !graph.get(value).contains(value2) && !graph.get(value2).contains(value)) {\n                graph.get(value).add(value2);\n                graph.get(value2).add(value);\n                chooseEdge--;\n            }\n        }\n\n        // Printing out the Nodes\n\n        for (int i = 0; i < graph.size(); i++) {\n            // Return each LinkedList nodes\n            // System.out.println(graph.get(i));\n\n            for (int j = 0; j < graph.get(i).size(); j++) {\n                // Return each individual nodes inside LinkedList\n                for (Entry<Integer, String> entry : cityMapping.entrySet()) {\n                    if (entry.getKey() == graph.get(i).get(j)) {\n                        //System.out.print(graph.get(i).get(j) + \"-> \");\n                        System.out.print(graph.get(i).get(j) + \". \" + entry.getValue() + \" -> \");\n                    }\n                }\n            }\n            System.out.println();\n        }\n        do {\n        for (\n\n                int i = 0; i < limit; i++) {\n            int[] newArray = new int[limit];\n            distance.add(newArray);\n            predecessor.add(newArray);\n        }\n        long time = System.nanoTime();\n        System.out.println(\"Searching BFS\");\n        System.out.println(\"--------------------------------------------\");\n\n        for (int i = 0; i < limit; i++) {\n            BFS(graph, i);\n        }\n\n        long CPUTime =  (System.nanoTime() - time);\n        System.out.println(\"CPU Time for BFS for \" + limit + \"vertices and \" + edge + \"edges (in ns): \" + CPUTime);\n\n        System.out.print(\"Enter -1 to exit! Enter source vertex (between 0 to \" + (limit - 1) + \") : \");\n\n        source = in.nextInt();\n        if (source == -1) {\n            System.out.print(\"System terminating...\");\n            break;\n        }\n        System.out.print(\"Enter destination vertex (between 0 to \" + (limit - 1) + \") : \");\n        destination = in.nextInt();\n\n        System.out.println(\"Distance from \" + source + \" to \" + destination + \" is: \" +\n\n                getDistance(source, destination));\n        System.out.println(\"The Predecessor of the path from \" + source + \" to \" + destination + \" is: \"\n                + getPredecessor(source, destination));\n\n\n        } while (source != -1);\n    }\n\n    private static void BFS(ArrayList<LinkedList<Integer>> graph, int i) {\n        // TODO Auto-generated method stub\n        boolean[] mark = new boolean[graph.size()]; \n        Queue<Integer> L = new ArrayBlockingQueue<Integer>(graph.size()); //Queue\n\n        L.add(i);\n        mark[i] = true; \n        Arrays.fill(predecessor.get(i), -1);\n        Arrays.fill(distance.get(i), -1);\n        distance.get(i)[i] = 0;\n\n        while (!L.isEmpty()) {\n            int vertex = L.remove(); \n\n            for (int i1 = 0; i1 < graph.get(vertex).size(); i1++) {\n                int v = graph.get(vertex).get(i1);\n                if (!mark[v]) {\n                    mark[v] = true;\n                    predecessor.get(i)[v] = vertex;\n                    L.add(v);\n                    distance.get(i)[v] = distance.get(i)[predecessor.get(i)[v]] + 1;\n                }\n            }\n        }\n\n    }\n\n\n    public static int getDistance(int start, int end) {\n        return (distance.get(start)[end]);\n    }\n\n    public static int getPredecessor(int start, int end) {\n        return (predecessor.get(start)[end]);\n    }\n\n    private static void chooseNumOfEdges() {\n        System.out.println(\"Please input the number of Edges:\");\n        chooseEdge = in.nextInt();\n    }\n\n    // Number of Vertices\n    private static void chooseNumOfVertices() {\n        in = new Scanner(System.in);\n        System.out.println(\"Please input the number of Vertices:\");\n        limit = in.nextInt();\n\n        // Read CSV\n        List<String[]> content = readCsvFile();\n\n        // Map each number to a city name\n        cityMapping = new HashMap<>();\n        for (int i = 0; i < limit; i++) {\n            cityMapping.put(i, content.get(i)[0]);\n        }\n\n        // System.out.println(cityMapping);\n    }\n\n    // Read CSV file\n    public static List<String[]> readCsvFile() {\n        String csvFile = \"./Lab 4/country.csv\";\n        BufferedReader br = null;\n        ArrayList<String> names = new ArrayList<String>();\n        List<String[]> content = new ArrayList<>();\n        String cvsSplitBy = \",\";\n\n        try {\n            String line = \"\";\n            br = new BufferedReader(new FileReader(csvFile));\n            while ((line = br.readLine()) != null) {\n                content.add(line.split(cvsSplitBy));    \n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        Random r = new Random();\n        Collections.shuffle(content);\n        return content;\n    }\n\n\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest Path Algorithm With Updates\r\n                \r\nThere are N cities and there are M bidirectional roads connected to them , I have to find the shortest path between two fixed cities A and B.\n\nBut the problem is there are Q queries given such that path between two cities is blocked , i have to find the shortest path in each Q queries.\n\nMy time Complexity in my brute force Algorithm is O(QNlogN) which give me Time Limit Exceeded Error, How can i improve my solution please Help\n\nPseduo Code:\n\n```\nfor u in Q:\n  cin>>a>>b;\ngraph[a][b] = graph[b][a] = INFINITY VALUE\ndijkstra algorithm();\ncout<<Distance[D]<<endl; \n```\n\n\nProblem LINK\n\nMY CODE Which Is giving me Time Limit Exceeded Error \nPlese Help How can I improve my algorithm ?\n    ", "Answer": "\r\nThe paper Vickrey Prices and Shortest Paths:\nWhat is an edge worth? by John Hershberger and Subhash Suri shows how to solve this problem in time O(NlogN+M) where N is the number of vertices, and M is the number of edges.\n\nThis allows you to precalculate the M answers depending on which road is blocked, so you can answer each query in O(1), for a total complexity of O(NlogN+M+Q).\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Gremlin All shortest paths from multiple vertices to a single vertex\r\n                \r\nThe following stack overflow question \n\nHow to increase performance of shortest path using Gremlin?\n\nshows how to find the shortest path from a start a single starting vertex with id ```\n687```\n to an ending vertex with id ```\n1343```\n and does so efficiently by ensuring no paths are repeated using ```\nstore```\n, ```\nwithout```\n, and ```\naggregate```\n\n\n```\ng.V(687).store('x').repeat(out().where(without('x')).aggregate('x')).until(hasId(1343)).limit(1).path()```\n \n\nI would like to perform the same query with the same level of efficiency, however I need all the shortest paths from multiple starting vertices with the same label all to the same ending vertex, for example it would look something like this (though this doesn't work)\n\n```\ng.V().hasLabel('label').store('x').repeat(out().where(without('x')).aggregate('x')).until(hasId(1343)).limit(1).path()```\n\n\nI have tried multiple constructs with two repeats in the statement, but am not able to get an independent ```\nstore('x')```\n for each starting vertex. I am also using ```\nAWS Neptune```\n platform, so it restricts the usage of Gremlin where loops/scripts are not allowed. All gremlin queries must start with ```\ng.```\n and be composed of commands chained together with ```\n.```\n\n\nhttps://docs.aws.amazon.com/neptune/latest/userguide/access-graph-gremlin-differences.html\n    ", "Answer": "\r\nThis technique can not be applied to multiple start vertices. However, you can just start from the other side as this is a single known vertex:\n\n```\ng.V(1343).store('x').\n  repeat(__.in().where(without('x')).aggregate('x')).\n    until(hasLabel('label')).\n  path()\n```\n\n\nIf one of the start vertices can be part of the path of another start vertex, then you may not break at a potential start vertex and instead do this:\n\n```\ng.V(1343).store('x').\n  repeat(__.in().where(without('x')).aggregate('x')).\n    emit(hasLabel('label')).\n  path()\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How to record all the shortest paths from a source vertex to a destination vertex\r\n                \r\nI'm currently using Boost graph library's dijkstra algorithm http://www.boost.org/doc/libs/1_53_0/libs/graph/doc/dijkstra_shortest_paths.html to compute shortest distance path between a pair of vertices. So far, I can only obtain one shortest path stored in the predecessor map. \n\nSo my question is: is it possible to let the function return all possible shortest paths between a pair of vertices?\n    ", "Answer": "\r\nNo, you need to build that yourself. One way is to compute distances from the source vertex s (in G) and to the sink vertex t (i.e., distances from t in the transpose graph) using two calls to Dijkstra. Then, extract a subgraph containing exactly those nodes u such that distance(s, u) + distance(u, t) = distance(s, t) and those arcs uv such that distance(s, u) + length(u, v) + distance(v, t) = distance(s, t) and recursively enumerate all s-t paths in this subgraph.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "how to understand details in this program of Dijkstra’s shortest path algorithm\r\n                \r\nI'm reading Dijkstra’s shortest path algorithm .\n\n\n  Given a graph and a source vertex in graph, find shortest paths value from\n  source to all vertices in the given graph.\n\n\nI can't understand why ```\ndist[u] != INT_MAX```\n is needed.\n\n```\n#include <stdio.h>\n#include <limits.h>\n\n// Number of vertices in the graph\n#define V 9\n\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], bool sptSet[])\n{\n   // Initialize min value\n   int min = INT_MAX, min_index;\n\n   for (int v = 0; v < V; v++)\n     if (sptSet[v] == false && dist[v] <= min)\n         min = dist[v], min_index = v;\n\n   return min_index;\n}\n\n// A utility function to print the constructed distance array\nvoid printSolution(int dist[], int n)\n{\n   printf(\"Vertex   Distance from Source\\n\");\n   for (int i = 0; i < V; i++)\n      printf(\"%d \\t\\t %d\\n\", i, dist[i]);\n}\n\n// Funtion that implements Dijkstra's single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src)\n{\n     int dist[V];     // The output array.  dist[i] will hold the shortest\n                      // distance from src to i\n\n     bool sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n                     // path tree or shortest distance from src to i is finalized\n\n     // Initialize all distances as INFINITE and stpSet[] as false\n     for (int i = 0; i < V; i++)\n        dist[i] = INT_MAX, sptSet[i] = false;\n\n     // Distance of source vertex from itself is always 0\n     dist[src] = 0;\n\n     // Find shortest path for all vertices\n     for (int count = 0; count < V-1; count++)\n     {\n       // Pick the minimum distance vertex from the set of vertices not\n       // yet processed. u is always equal to src in first iteration.\n       int u = minDistance(dist, sptSet);\n\n       // Mark the picked vertex as processed\n       sptSet[u] = true;\n\n       // Update dist value of the adjacent vertices of the picked vertex.\n       for (int v = 0; v < V; v++)\n\n         // Update dist[v] only if is not in sptSet, there is an edge from \n         // u to v, and total weight of path from src to  v through u is \n         // smaller than current value of dist[v]\n\n         /*  \n          * \n          * Why dist[u] != INT_MAX is needed? Can this condition be deleted? \n          *\n          */\n         if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n                                       && dist[u]+graph[u][v] < dist[v])\n            dist[v] = dist[u] + graph[u][v];\n     }\n\n     // print the constructed distance array\n     printSolution(dist, V);\n}\n\nint main(void)\n{\n   /* Let us create the example graph discussed above */\n   int graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n                      {4, 0, 8, 0, 0, 0, 0, 11, 0},\n                      {0, 8, 0, 7, 0, 4, 0, 0, 2},\n                      {0, 0, 7, 0, 9, 14, 0, 0, 0},\n                      {0, 0, 0, 9, 0, 10, 0, 0, 0},\n                      {0, 0, 4, 0, 10, 0, 2, 0, 0},\n                      {0, 0, 0, 14, 0, 2, 0, 1, 6},\n                      {8, 11, 0, 0, 0, 0, 1, 0, 7},\n                      {0, 0, 2, 0, 0, 0, 6, 7, 0}\n                     };\n\n    dijkstra(graph, 0);\n\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nWithout the check ```\ndist[u] != INT_MAX```\n, ```\ndist[u]+graph[u][v]```\n may cause signed integer overflow, which invokes undefined behavior.\n\nWith the check, thanks to short-circuit evaluation, ```\ndist[u]+graph[u][v] < dist[v]```\n won't be evaluated when the value in ```\ndist[u]```\n is ```\nINT_MAX```\n, so the undefined behavior can be avoided if the input costs are small enough not to cause overflow.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Sum of all shortest paths queries\r\n                \r\nI need help with this problem.\n\nWe have that ```\nD(G,u,v)```\n is number of edges on shortest path from ```\nu```\n to ```\nv```\n in graph ```\nG```\n.\n\nWe are given a tree ```\nT```\n with ```\nN```\n vertices and ```\nQ```\n queries of following type:\n\nIf we add edge ```\n(a,b)```\n to tree ```\nT```\n, obtaining graph ```\nG1```\n, then what is the value of ```\nsum(1 <=u < v <= N) D(G1,u,v)```\n\n\nQueries are independent\n\n```\n1<=N<=260000\n\n1<=Q<=200000\n\nD(T,a,b)<=16\n```\n\n\nFor each query I called BFS from every node and calculated sum of distances, but my algorithm was to slow. Can someone give me more efficient approach?\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Dijkstra algorithm for finding shortest paths\r\n                \r\nI need help to write code on Dijkstra algorithm for finding shortest paths by using java, and use only this version given below :\n\n**procedure Dijkstra(G, w, r, Parent[0:n-1], Dist)\n\nfor v← 0 to n-1 do\n\nDist[v] ← ∞\n\nInTheTree[v] ← .false.\n\nendfor\n\nParent[r] ←-1\n\nDist[r] ←0\n\nfor Stage ←1 to n-1 do \n\nSelect vertex u that minimises Dist[u] over all u such that InTheTree[u] = .false. \n\nInTheTree[u] = .true.            // add u to T\n\nfor each vertex v such that uv ∈ E do             // update Dist[v] and \n\nif .not. InTheTree[v]  then                // Parent[v] arrays\n\nif Dist[u] ← w(uv) < Dist[v] then \n\nDist[v] = Dist[u] + w(uv)\n\nNearest[v] ←𝑤(𝑢𝑣)\n\nParent[r] ← u\n\nendif\n\nendif\n\nendfor\n\nendfor\n\nend Dijkstra**\n\n.....................\nThanks\n    ", "Answer": "\r\nArgoList has an implementation I just googled :\n\n```\nimport java.util.PriorityQueue;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\nclass Vertex implements Comparable<Vertex>\n{\npublic final String name;\npublic Edge[] adjacencies;\npublic double minDistance = Double.POSITIVE_INFINITY;\npublic Vertex previous;\npublic Vertex(String argName) { name = argName; }\npublic String toString() { return name; }\npublic int compareTo(Vertex other)\n{\n    return Double.compare(minDistance, other.minDistance);\n}\n}\n\nclass Edge\n{\npublic final Vertex target;\npublic final double weight;\npublic Edge(Vertex argTarget, double argWeight)\n{ target = argTarget; weight = argWeight; }\n}\n\npublic class Dijkstra\n{\npublic static void computePaths(Vertex source)\n{\n    source.minDistance = 0.;\n    PriorityQueue<Vertex> vertexQueue = new PriorityQueue<Vertex>();\n    vertexQueue.add(source);\n\nwhile (!vertexQueue.isEmpty()) {\n    Vertex u = vertexQueue.poll();\n\n        // Visit each edge exiting u\n        for (Edge e : u.adjacencies)\n        {\n            Vertex v = e.target;\n            double weight = e.weight;\n            double distanceThroughU = u.minDistance + weight;\n    if (distanceThroughU < v.minDistance) {\n        vertexQueue.remove(v);\n        v.minDistance = distanceThroughU ;\n        v.previous = u;\n        vertexQueue.add(v);\n    }\n        }\n    }\n}\n\npublic static List<Vertex> getShortestPathTo(Vertex target)\n{\n    List<Vertex> path = new ArrayList<Vertex>();\n    for (Vertex vertex = target; vertex != null; vertex = vertex.previous)\n        path.add(vertex);\n    Collections.reverse(path);\n    return path;\n}\n\npublic static void main(String[] args)\n{\n    Vertex v0 = new Vertex(\"Redvile\");\nVertex v1 = new Vertex(\"Blueville\");\nVertex v2 = new Vertex(\"Greenville\");\nVertex v3 = new Vertex(\"Orangeville\");\nVertex v4 = new Vertex(\"Purpleville\");\n\nv0.adjacencies = new Edge[]{ new Edge(v1, 5),\n                             new Edge(v2, 10),\n                           new Edge(v3, 8) };\nv1.adjacencies = new Edge[]{ new Edge(v0, 5),\n                             new Edge(v2, 3),\n                             new Edge(v4, 7) };\nv2.adjacencies = new Edge[]{ new Edge(v0, 10),\n                           new Edge(v1, 3) };\nv3.adjacencies = new Edge[]{ new Edge(v0, 8),\n                             new Edge(v4, 2) };\nv4.adjacencies = new Edge[]{ new Edge(v1, 7),\n                           new Edge(v3, 2) };\nVertex[] vertices = { v0, v1, v2, v3, v4 };\n    computePaths(v0);\n    for (Vertex v : vertices)\n{\n    System.out.println(\"Distance to \" + v + \": \" + v.minDistance);\n    List<Vertex> path = getShortestPathTo(v);\n    System.out.println(\"Path: \" + path);\n}\n}\n}\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path using php [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Questions concerning problems with code you've written must describe the specific problem — and include valid code to reproduce it — in the question itself. See SSCCE.org for guidance.\r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\ni have an array of coordinates in php like this:\n\n```\nArray ( \n    [0] => Array ( \n        [0] => 39.1057579 \n        [1] => 26.5451331 \n    ) \n    [1] => Array ( \n        [0] => 39.1057579 \n        [1] => 26.5451331 \n        [2] => 39.1055889 \n        [3] => 26.5452403 \n    ) \n    [2] => Array ( \n        [0] => 39.1057579 \n        [1] => 26.5451331 \n        [2] => 39.1055889\n    )\n)\n```\n\n\nI'm going to find a function with start latlng and end latlng as inputs and return an array of coordinates as the shortest path.\n    ", "Answer": "\r\nAs Mark Baker pointed out, you'll need to use something like Dijkstra's algorithm to traverse a weighted graph (which is what you'll have when you include distances).\n\nHere's a simple distance function I found here:\n\n```\n<?php\n\n/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/\n/*::                                                                         :*/\n/*::  This routine calculates the distance between two points (given the     :*/\n/*::  latitude/longitude of those points). It is being used to calculate     :*/\n/*::  the distance between two locations using GeoDataSource(TM) Products    :*/\n/*::                                                                         :*/\n/*::  Definitions:                                                           :*/\n/*::    South latitudes are negative, east longitudes are positive           :*/\n/*::                                                                         :*/\n/*::  Passed to function:                                                    :*/\n/*::    lat1, lon1 = Latitude and Longitude of point 1 (in decimal degrees)  :*/\n/*::    lat2, lon2 = Latitude and Longitude of point 2 (in decimal degrees)  :*/\n/*::    unit = the unit you desire for results                               :*/\n/*::           where: 'M' is statute miles                                   :*/\n/*::                  'K' is kilometers (default)                            :*/\n/*::                  'N' is nautical miles                                  :*/\n/*::  Worldwide cities and other features databases with latitude longitude  :*/\n/*::  are available at http://www.geodatasource.com                          :*/\n/*::                                                                         :*/\n/*::  For enquiries, please contact sales@geodatasource.com                  :*/\n/*::                                                                         :*/\n/*::  Official Web site: http://www.geodatasource.com                        :*/\n/*::                                                                         :*/\n/*::         GeoDataSource.com (C) All Rights Reserved 2013                  :*/\n/*::                                                                         :*/\n/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/\nfunction distance($lat1, $lon1, $lat2, $lon2, $unit) {\n\n  $theta = $lon1 - $lon2;\n  $dist = sin(deg2rad($lat1)) * sin(deg2rad($lat2)) +  cos(deg2rad($lat1)) * cos(deg2rad($lat2)) * cos(deg2rad($theta));\n  $dist = acos($dist);\n  $dist = rad2deg($dist);\n  $miles = $dist * 60 * 1.1515;\n  $unit = strtoupper($unit);\n\n  if ($unit == \"K\") {\n    return ($miles * 1.609344);\n  } else if ($unit == \"N\") {\n      return ($miles * 0.8684);\n    } else {\n        return $miles;\n      }\n}\n\necho distance(32.9697, -96.80322, 29.46786, -98.53506, \"M\") . \" Miles<br>\";\necho distance(32.9697, -96.80322, 29.46786, -98.53506, \"K\") . \" Kilometers<br>\";\necho distance(32.9697, -96.80322, 29.46786, -98.53506, \"N\") . \" Nautical Miles<br>\";\n\n?>\n```\n\n\nTo find all distances between nodes, you'll need to simply loop through all your nodes.  You'll come out with an array that looks something like this:\n\n```\n$distance[0][1] = 10;\n$distance[0][2] = 12;\n$distance[0][3] = 7;\n...\n$distance[4][3] = 14;\n```\n\n\nWhere the dimensions of your array represent your node numbers, and the assigned value is the distance.  You'd run this array through Dijkstra to find the shortest weighted path.\n\nHope this helps you.  If you need further assistance you might want to try to refine your question to be more narrow.  Graph traversal is a VERY broad area of study.  Good luck.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Finding ALL shortest paths between two nodes in a graph having a multidimensional predecessor array\r\n                \r\nso I've been trying to look up ways to find ALL shortest paths between two specific nodes in an unweighted graph and I've written code up to the point where I have built up a \"predecessor\" array that keeps track of what nodes I have used to reach the given node. This array is a multidimensional array so for example, if the shortest path from A to D can be from A > B > D OR A > C > D then the predecessor array will look like this (where the first row is the index, and then rows below are a multidimensional array):\n\n```\nA    | B    | C    | D    | \n---------------------------\n     | A    | A    | B    |\n---------------------------\n     |      |      | C    |\n```\n\n\nBut now I am lost as to how I can find every permutation in this predecessor array to get every possible combination of shortest paths possible to then print out e.g I would like to print out:\n\n```\nAll shortest paths:\nA > B > D\nA > C > D\n```\n\n\nI have heard people say you can do this by recursion? But am very lost. (Also please note that I am not too worried about time complexity). Thank you for any guidance!\n    ", "Answer": "\r\n\n  I have heard people say you can do this by recursion? \n\n\nI'm not sure what they have in mind when saying this, but I'm giving you a simple way to solve this, and it will solve this in good time complexity as well. Solve this situation using BFS. IMO, this is your best bet.\n\nSolution:\n\n```\nExample graph:\n(A,B,C,D,E)\nA->B, A->C, B->D, B->E, C->E, D->E\n\nSource: A, Destination: E\nPaths: (marked with # are solution paths)\n# A->B->E\n# A->C->E\n  A->B->D->E\n```\n\n\n\nStart with the source node. Keep a queue, with each element having 3 information points:\n\n\nNode\nLevel\nPath (till now)\n\nDo a BFS on the graph. At each level, check if destination is reached. Continue this until it is done.\nWhen you reach the destination on a certain level, don't stop there as we do in usual cases. You need to complete this level fully and stop when you are done with this level.\nPrint all paths for destination, this will be your answer.\n\n\nWorking this on our example:\n\n\nEach element of queue is represented as a 3 value tuple (Node, Level, Path)\n\n\nInitial Queue: (A,0,null)\n\n```\nLevel         Queue\n 0            (A,0,null)\n 1            (B,1,A)\n 1            (C,1,A)\n 2            (D,2,AB)\n 2            (E,2,AB)      #       --> found destination, so, complete L2 fully\n 2            (E,2,AC)      #\n 3...stop\n```\n\n\nPrint paths: ABE and ACE from above.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "shortest path in hash map\r\n                \r\nThe following is a data set I have stored in a hash map, and I have to find the shortest path between two values.\n\n```\n9244, 4322, 4886, 5989, 8598, 9979, 1447, 9657\n8598, 6752, 7146, 1951, 660, 1447, 7779\n568, 1951, 4886, 2570, 9026, 9489, 7779\n6752, 3424, 1977, 4746, 9657\n77\n```\n\n\nThe key value of the hash map is the first value of each line, the rest are the supposed \"friends\" of 9244 (same in each case).\n\ni have saved in hash table in this format: ```\nhashmap(key, array)```\n, where:\n\n\nkey is e.g. 9244\narray then holds [ 4322, 4886, 5989, 8598, 9979, 1447, 9657 ]\n\n\nHow to find shortest path between two keys?\n    ", "Answer": "\r\nIf I interpret your question correctly, you're talking about the Shortest Path problem with a directed graph.\n\n\nStarting with an integer, get the array of integers it maps to.\nEach of those integers is the key to a new array.\nFollow those paths and find the shortest one.\n\n\nIf you do a google search, and look on the Wikipedia page, you'll be able to find plenty of code samples and algorithms that will help you.\n\nAs Peter Smit mentioned, the A* algorithm is a common one for this problem.  Others include Dijkstra's and Bellman-Ford.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "shortest path tsp algorithm\r\n                \r\nNow below is a dictonary, I am trying find the shortest path.we have to go to all 5 houses based on shortest time. Each key is a house, each list of values is the time in seconds. For example, the first house has a time of 0 because it's obvious, now from 1st house to second house has 74 seconds... and so on. Each index is a time represenation to the next house.\n\nnow second row, with 2 as key. from second house to first house it's 74 seconds, and now from 2nd house to third house it's 4069 seconds as show below. \n\nI am trying to find the best algo for this i am confused what should i use? combinations? permutations?\n\nThe goal is to find the shortest path FROM house to house with represetation below and SUM of all time traveld in the shortest path you find\n\n```\nlist = 0, 74 , 2213, 816, 1172 ,\n```\n\n\nThe shortest path.\n\n```\n1 -> 2 -> 5 -> 4 -> 3 -> 1 \n```\n\n\nWE HAVE to return to first house again thats why 1 is shown again \n\nnumbers 1 through 5, represents houses\nlist\n\n\ngo through each key,value find the minimum and index of the min. Add the time to a time_list\naccess the next home(keys) with the index found in previous\nmatch the index of min to the next home, in the home ignore zero and \nthe times already encounters in previous home times\n\n    ", "Answer": "\r\nYou could try to reduce the amount of paths to be checked by tracking the current house and all the houses visited so far. Let's say you have paths ```\n[1, 2, 3, 4]```\n and ```\n[1, 3, 2, 4]```\n you can check which one is shorter and only continue with it. Here's a example with the data that you provided, it's storing the distances in 2D array instead of ```\ndict```\n but the principle is the same:\n\n```\ndist = [\n    [0, 74, 4109, 3047, 2266], \n    [74, 0, 4069, 2999, 2213],\n    [4109, 4069, 0, 1172, 1972], \n    [3047, 2999, 1172, 0, 816], \n    [2266, 2213, 1972, 816, 0]\n]\n\n# Helper function to calculate path length\ndef path_len(path):\n    return sum(dist[i][j] for i, j in zip(path, path[1:]))\n\n# Set of all nodes to visit\nto_visit = set(xrange(len(dist)))\n\n# Current state {(node, visited_nodes): shortest_path}\nstate = {(i, frozenset([0, i])): [0, i] for i in xrange(1, len(dist[0]))}\n\nfor _ in xrange(len(dist) - 2):\n    next_state = {}\n    for position, path in state.iteritems():\n        current_node, visited = position\n\n        # Check all nodes that haven't been visited so far\n        for node in to_visit - visited:\n            new_path = path + [node]\n            new_pos = (node, frozenset(new_path))\n\n            # Update if (current node, visited) is not in next state or we found shorter path\n            if new_pos not in next_state or path_len(new_path) < path_len(next_state[new_pos]):\n                next_state[new_pos] = new_path\n\n    state = next_state\n\n# Find the shortest path from possible candidates\nshortest = min((path + [0] for path in state.itervalues()), key=path_len)\nprint 'path: {0}, length: {1}'.format(shortest, path_len(shortest))\n```\n\n\nIt will output one of the shortest paths and the total distance:\n\n```\npath: [0, 2, 3, 4, 1, 0], length: 8384\n```\n\n\nNote that with data you provided there are two possible solutions which have equal length: ```\n[0, 2, 3, 4, 1, 0]```\n and ```\n[0, 1, 4, 3, 2, 0]```\n.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "True shortest path in binary image/map\r\n                \r\nHow can i find the true shortest path in a binary image/map?\n\nI have looked into Different algorithms, e.g. Dijkstra and A* but they only yield an approximateion of the the shortest path as all pixels are only connected in a \"8 connected\" way. \n\nWhat algorithm can i use to get the true shortest path - The red line in the figure below?\n\n\n    ", "Answer": "\r\nWell, using a 8-connected grid implies that you only can will find paths which advance in the orientations given by the 8-neighbors (0, +/-45, +/-90, +/-135, 180). As you show in the picture attached.\n\nIf you are required to solve this problem using A*, Dijkstra or similar, the only way to patch this problem is to increase the variety of angles for your paths, increasing the connectivity of your grid (16 or 32-connected). Even with this, you have limited orientations for your paths.\n\nTo solve the problem you are describing in your question, other kind of algorithms are used, like Theta*, Field D* or Block A*. These algorithms are able to find paths in any angle (as you require in your problem) even using a 8-connected grid as basis for the search. Take a look to the Wikipedia entry: Any-angle path planning to have more information about this kind of search.\n\nI hope my answer helps.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "shortest path in hash map\r\n                \r\nThe following is a data set I have stored in a hash map, and I have to find the shortest path between two values.\n\n```\n9244, 4322, 4886, 5989, 8598, 9979, 1447, 9657\n8598, 6752, 7146, 1951, 660, 1447, 7779\n568, 1951, 4886, 2570, 9026, 9489, 7779\n6752, 3424, 1977, 4746, 9657\n77\n```\n\n\nThe key value of the hash map is the first value of each line, the rest are the supposed \"friends\" of 9244 (same in each case).\n\ni have saved in hash table in this format: ```\nhashmap(key, array)```\n, where:\n\n\nkey is e.g. 9244\narray then holds [ 4322, 4886, 5989, 8598, 9979, 1447, 9657 ]\n\n\nHow to find shortest path between two keys?\n    ", "Answer": "\r\nIf I interpret your question correctly, you're talking about the Shortest Path problem with a directed graph.\n\n\nStarting with an integer, get the array of integers it maps to.\nEach of those integers is the key to a new array.\nFollow those paths and find the shortest one.\n\n\nIf you do a google search, and look on the Wikipedia page, you'll be able to find plenty of code samples and algorithms that will help you.\n\nAs Peter Smit mentioned, the A* algorithm is a common one for this problem.  Others include Dijkstra's and Bellman-Ford.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "R: calculating single shortest path between two vertices\r\n                \r\nCurrently, I am working on a project that involves NYC Taxi data, in which I am given where a person is picked up and dropped off in a network.\n\nI am working with an ```\nESRI```\n ```\nshapefile```\n, which I can load into R as an ```\nigraph```\n object with the ```\nshp2graph```\n package; I need to utilize Dijkstra's algorithm (or a similar shortest-path algorithm) to find the single shortest path between two given vertices. I thought that the ```\nget.shortest.paths()```\n method of the ```\nigraph```\n package would be my solution, but to my surprise, this calculates all shortest paths from a vertex to all others in a network. \n\nTo me, this seems like overkill, because I need only one single path between two specified nodes. I did some poking around online and in the ```\nigraph```\n documentation, but all I can find are methods surrounding calculating many shortest paths from a given vertex to all others.\n\nDue to how computationally expensive it would be to calculate every single shortest path from a vertex, and then just select one from the behemoth of a list, I'm looking for a way to utilize Dijkstra's algorithm between two specified vertices in a graph. Is there a way to do this in the ```\nigraph```\n package, or if not, is there a good way to do this with a different package in R?\n\nEDIT: In the end, I am hoping to look for a function that will take in the graph object and the ID of two vertices I wish to find the shortest path between, then return a list of paths/edges (or IDs) along that shortest path. This would help me to inspect each individual street along the shortest path between the two vertices.\n\nEDIT: As an example of how I am currently using the function:\n```\npath <- get.shortest.paths(NYCgraph, from=32, mode=\"out\")```\n. Something I would hope to find is ```\npath <- shortestPathFunction(NYCgraph, from=32, to=37)```\n to arbitrary calculate a shortest path between vertex ID 32 and vertex ID 37 (two random street intersections in the network).\n    ", "Answer": "\r\nI found my issue, which occurred before I called get.shortest.paths(). For those who are curious on how to read in an ESRI shapefile, and find a single shortest path between two points (which was my dilemma):\n\n```\nmyShapefile <- readOGR(dsn=\".\", layer=\"MyShapefileName\") # i.e. \"MyShapefileName.shp\"\nshpData <- readshpnw(myShapefile, ELComputed=TRUE)\nigraphShpObject <- nel2igraph(shpData[[2]], shpData[[3]], weight=shpData[[4]])\ntestPath <- get.shortest.paths(igraphShpObject, from=42, to=52) # arbitrary nodes\ntestPath[1] # print the node IDs to the console\n```\n\n\nFurthermore, if one was interested in getting the ID of the edge connecting two nodes (perhaps from nodes in the testPath):\n\n```\nget.edge.ids(igraphShpObject, c(42,45) # arbitrary nodes 42 and 45```\n\n\nThis indexing is the same as the indexing in shpData; for example, if you want to get the length of edge ID x, as found in ```\nget.edge.ids()```\n, you may type ```\nshpData[[4]][x]```\n.\n\nI hope these tidbits may be helpful to somebody in the future encountering the same problems! This method utilizes the ```\nshp2graph```\n, ```\nrgdal```\n, and ```\nigraph```\n packages in R.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path program\r\n                \r\nI want to write a shortest path program. I know how the algorithm works, but I don't know where to start\n\nInitially, I thought of using an adjacency matrix but then decided against it because of space. Now I think adjacency list would be better. \n\nCan anyone suggest me a websites or tutorials how to start writing adjacency list to give the input to the program?\n    ", "Answer": "\r\nYou might start with Boost::Graph, which will provide you both mechanisms for storing graph data and a structure for writing an algorithm that consumes that data.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Networkx - Shortest path length\r\n                \r\nI'm  using ```\nnetworkx```\n to manage large network graph which consists of 50k nodes. \n\nI want to calculate the shortest path length between a specific set of nodes, say N.\nFor that i'm using the ```\nnx.shortest_path_length```\n function.\n\nIn some of the nodes from N there might not be a path so networkx is raising and stopping my program.\n\nIs there any way to run this program without any error?\nAnd to tell to ```\nshortest_path_length```\n to return some maximum value? \n\nCode simply uses ```\nnx.shortest_path_length(G,i,j)```\nin loop.\nand error is as follows\n\n```\nraise nx.NetworkXNoPath(\"No path between %s and %s.\" % (source, target))\nnetworkx.exception.NetworkXNoPath: No path between V and J```\n\n    ", "Answer": "\r\n```\nimport networkx as nx\nG=nx.Graph()\nG.add_nodes_from([1,2,3,4])\nG.add_edge(1,2)\nG.add_edge(3,4)\ntry:\n    n=nx.shortest_path_length(G,1,4)\n    print n\nexcept nx.NetworkXNoPath:\n    print 'No path'\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Parallel implementation of shortest path in graph_tool\r\n                \r\nI want to compute all shortest paths between each pair of nodes in an undirected weighted graph. I am currently using graph_tool.topology.shortest_distance, from the graph_tool python library, but it seems to be running in one core only. Is there a way to make it run in parallel?\n    ", "Answer": "\r\ngraph-tool uses the boost graph library for its shortest path algorithms, but doesn't use its parallel graph library, as far as I know.\nYou could try calling the parallel library from python using some methods referenced here.\nAlternatively, you could try JuliaGraphs's parallel implementations in Julia.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path by minimum number of vertices\r\n                \r\nI have read about Floyd and Dijkstra, but they to find shortest path by minimum length of edges between nodes\n\nHow can I find the shortest path in a directed graph by traversing the minimum number of nodes?\n    ", "Answer": "\r\nTrivial way:\n\nAssign equal weights to all edges.\n\nNo. of edges = total weight of path / weight of each edge.\n\nNo. of nodes = No. of edges + 1 (or - 1 if you don't count the ends).\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "To find shortest path\r\n                \r\nI have latitude and longitude of 50 node or more. Its not connected to each other. We will consider one node as start and end both. \n\nI need to find the shortest path through these node that starts at 'start', ends at same point of start and passes through all of the nodes.\n\nNote: Without using google maps api\n    ", "Answer": "\r\nThe problem you describe is the Euclidean TSP, which is NP-hard.\n\nFor very small inputs you can do it using brute force. For larger inputs, an approximation algorithm can be used (such as the one mentioned in the link, which guarantees a 2-approximation).\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Is a graph database better for shortest paths algorithms?\r\n                \r\nMy objective is to write a shortest path algorithm for a road network.\n\nCurrently my architecture is something like that: I store all the data in the PostGIS enabled PostgreSQL database. I do one ```\nSELECT * FROM ways```\n, which takes less than 3 seconds on a table with 100,000 edges (ways) and after that I will apply a (Java, Ruby or anything-based) shortest path algorithm to the graph that already resides in memory. The second operation can take about 1.5 seconds on a graph with 100,000 edges. \n\nSo, it takes:\n\n\n2-3 seconds to load all the ways from the database into memory and create a graph (nodes are stored in one table with ways(edges));\n1-1.5 seconds to calculate a shortest path on a graph which is already in memory.\n\n\nThis is very similar to what pgRouting does (to my knowledge it uses C Boost to store the graph in memory), except pgRouting takes about 2 seconds in total to compute a shortest path on the same data set (yes, it is fast, but it is a black box for me, so I need my own).\n\nBut recently I found about Graph databases and about Neo4j. On their site they claim that \"Still being able to do these calculations in sub-second speeds on graphs of millions of roads and waypoints makes it possible in many cases to abandon the normal approach of precomputing indexes with K/V stores and be able to put routing into the critical path with the possibility to adapt to the live conditions and build highly personalized and dynamic spatial services.\".\n\nSo the question is: Will a graph database be faster with my particular problem?\n\nThe problem has the following properties:\n\n\nthe database consists of one table (ways);\nthe only query to the database is to get all the ways into the memory (to build a graph);\nI do not need scalability, i.e. it is likely that the graph will not grow.\n\n    ", "Answer": "\r\nYou certainly dont have to reinvent the wheel if you are using any graph database, like Neo4j. Many shortest path algorithms are built into this and it's designed to handle complexity in case you have to consider speed limitation in any specific road, one-way road, score of a road etc. How do you keep up with performance when your data grows 10 times, or, 100 times. Considering your total computation time 3sec for 100,000 ways, it can be in minutes for 1M ways and in Neo4j, the response will be in milli sec.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "\"Least nodes traversed\" shortest-path algorithm\r\n                \r\nI'm looking for an algorithm to find the shortest-path from 2 points in a graph. However I don't mean shortest-path as in distance, I mean shortest-path as in least nodes traversed. So lets say the distance from A->B is 100, but A->C is 1, C->D is 1 and D->B is 1, I'd want A->B rather than A->C->D->B. Any thoughts?\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path with SPARQL and blazegraph\r\n                \r\nThis code gives the descendants of Genghis Kahn up to a certain depth (as a graph which can be changed to a table) :\n```\nPREFIX bd: <http://www.bigdata.com/rdf#> \nPREFIX wd: <http://www.wikidata.org/entity/> \nPREFIX wdt: <http://www.wikidata.org/prop/direct/> \nPREFIX wikibase: <http://wikiba.se/ontology#> \n#defaultView:Graph\nPREFIX gas: <http://www.bigdata.com/rdf/gas#>\n\nSELECT DISTINCT ?depth ?item ?itemLabel ?pic #?linkTo\nWHERE {\n  SERVICE gas:service {\n    gas:program gas:gasClass \"com.bigdata.rdf.graph.analytics.SSSP\" ;\n                gas:in wd:Q720 ;\n                gas:traversalDirection \"Forward\" ;\n                gas:out ?item ;\n                gas:out1 ?depth ;\n\n                gas:maxIterations 4 ;\n                gas:linkType wdt:P40 .\n  }\n # OPTIONAL { ?item wdt:P40 ?linkTo }\n  OPTIONAL { ?item wdt:P18 ?pic }\n  SERVICE wikibase:label {bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }\n}\nORDER BY ?depth\n```\n\nIs it possible to modify this code in order to obtain the shortest path between Genghis Khan and a particular descendant (e.g. Baltu, Q7070636), including the persons in between and the kinds of relationship (linkType) between them? Generally: How to obtain the shortest path between two certain nodes and as the result a table with the nodes between these nodes and the kinds of relationship between all these nodes (limited to a certain depth)?\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path in matrix with obstacles with cheat paths\r\n                \r\nFirst of all this is an assingment and I am not looking for direct answers but instead the complexity of the best solution as you might be thinking it .\n\nThis is the known problem of shortest path between 2 points in a matrix (Start and End) while having obstacles in the way. Moves acceptables is up,down,left and right  . Lets say when moving i carry sth and the cost of each movement is 2 . There are points in the matrix (lets name them B points) where I can leave this sth in one B point and pick it up from another B point . Cost of dumping sth in B point is 1 and cost of picking sth up from a B point is 1 again .  Whenever I move without this sth , my cost of moving now is 1 . \nWhat I think of the solution is transform the matrix into a tree and have a BFS applied . However that works without the B points . \n\nWhenever i take into account the B points complexity comes to a worst case scenario N^2. \nHere is an example :\n\n```\nS - - -\n- - - -\nB - - B\n- - O E\n```\n\n\nS = Start , E = End , B = B point to drop sth, O = obstacle\nSo i start with S move down down to the B point (2*2=4 points) leave sth in the B point (1 point ) move right right (2*1= 2 points ) , pick it up (1 point ) , move down 2 points = total of 10 points . \n\nWhat i thought was build the tree with nodes every B point , however this would create a very dense cyclic graph of almost (V-1)*(V-1) edges which takes the algortithm in N^2 boundaries just to create the graph . \nThat is the worst case scenario as above :\n\n```\nS b b b\nb b b b\nb b b b \nb b b E\n```\n\n\nAnother option I thought was that of first calculating shortest paths withouth B points . \nThen have iterations where at each iteration :\nFirst have bfs on S and closest B\nhave BFS on E and closest B \nThen see if there is a path between B of closest to S and B closest to E . \nIf there is then I would see if the path is smaller than that of regular shortest path with obstacles . \nIf that is bigger then there is no shortest path (no greedy test). \nIf there is no path between the 2 B points , try second closest to S and try again . \nIf no path again , the second closest to E and closest to S .\nHowever I am not able to calculate the complexity in this one in the worst case scenario plus there is no greedy test that evaluates that. \nAny help on calculating the complexity or even pointing out the best complexity solution (not the solution but just the complexity ) would be greatly appreciated \n    ", "Answer": "\r\nYour matrix is a representation of a graph. Without the cheat paths it is quite easy to implement a nice BFS. Implementing the cheat paths is not a big deal. Just add the same matrix as another 'layer' on top of the first one. bottom layer is 'carry', top layer is 'no carry'. You can move to the other layer only at B-points for the given cost. This is the same BFS with a third dimension.\n\nYou have n^2 nodes and (n-1)^2 edges per layer and additionally a maximum of n^2 eges connecting the layers. That's O(n^2).\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "very hard and elegant question on shortest path\r\n                \r\nGiven a weighed, connected and directed graph ```\nG=(V,E)```\n with ```\nn```\n vertexes and ```\nm```\n edges, and given a pre-calculated shortest path distance's matrix ```\nS```\n where ```\nS```\n is ```\nn*n```\n ```\nS(i,j)```\n denotes the weight of shortest path from vertex ```\ni```\n to vertex ```\nj```\n.\nwe know just weight of one edge ```\n(u, v)```\n is changed (increased or decreased).\nfor two specific vertex ```\ns```\n and ```\nt```\n  we want to update the shortest path length between these two vertex.\nThis can be done in ```\nO(1).```\n\nHow is this possible? what is the trick of this answer?\n    ", "Answer": "\r\nYou certainly can for decreases. I assume ```\nS```\n will always refer to the old distances. Let ```\nl```\n be the new distance between ```\n(u, v)```\n. Check if\n```\nS(s, u) + l + S(v, t) < S(s, t)\n```\n\nif yes then the left hand side is the new optimal distance between ```\ns```\n and ```\nt```\n.\n\nIncreases are impossible. Consider the following graph (edges in red have zero weight):\n\nSuppose ```\nm```\n is the minimum weight edge here, except for ```\n(u, v)```\n which used to be lower. Now we update ```\n(u, v)```\n to some weight ```\nl > m```\n. This means we must find ```\nm```\n to find the new optimum length.\nSuppose we could do this in O(1) time. Then it means we could find the minimum of any array in O(1) time by feeding it into this algorithm after adding ```\n(u, v)```\n with weight ```\n-BIGNUMBER```\n and then 'updating' it to ```\nBIGNUMBER```\n (we can lazily construct the distance matrix because all distances are either ```\n0```\n, ```\ninf```\n or just the edge weights). That is clearly not possible, thus we can't solve this problem in O(1) either.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "very hard and elegant question on shortest path\r\n                \r\nGiven a weighed, connected and directed graph ```\nG=(V,E)```\n with ```\nn```\n vertexes and ```\nm```\n edges, and given a pre-calculated shortest path distance's matrix ```\nS```\n where ```\nS```\n is ```\nn*n```\n ```\nS(i,j)```\n denotes the weight of shortest path from vertex ```\ni```\n to vertex ```\nj```\n.\nwe know just weight of one edge ```\n(u, v)```\n is changed (increased or decreased).\nfor two specific vertex ```\ns```\n and ```\nt```\n  we want to update the shortest path length between these two vertex.\nThis can be done in ```\nO(1).```\n\nHow is this possible? what is the trick of this answer?\n    ", "Answer": "\r\nYou certainly can for decreases. I assume ```\nS```\n will always refer to the old distances. Let ```\nl```\n be the new distance between ```\n(u, v)```\n. Check if\n```\nS(s, u) + l + S(v, t) < S(s, t)\n```\n\nif yes then the left hand side is the new optimal distance between ```\ns```\n and ```\nt```\n.\n\nIncreases are impossible. Consider the following graph (edges in red have zero weight):\n\nSuppose ```\nm```\n is the minimum weight edge here, except for ```\n(u, v)```\n which used to be lower. Now we update ```\n(u, v)```\n to some weight ```\nl > m```\n. This means we must find ```\nm```\n to find the new optimum length.\nSuppose we could do this in O(1) time. Then it means we could find the minimum of any array in O(1) time by feeding it into this algorithm after adding ```\n(u, v)```\n with weight ```\n-BIGNUMBER```\n and then 'updating' it to ```\nBIGNUMBER```\n (we can lazily construct the distance matrix because all distances are either ```\n0```\n, ```\ninf```\n or just the edge weights). That is clearly not possible, thus we can't solve this problem in O(1) either.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Storing a huge graph for shortest path calculations\r\n                \r\nI'm trying to store an unweighted, directed graph of over 5GB in a MySQL database in an efficient way for finding shortest paths. \nCurrently it is stored in a single table with a column source and a comlumn targets (comma seperated), but I am getting the feeling this isn't the way to go so I am planning on converting it to a table with vertices and a table with edges.\n\nI've got two questions:\n\n\nWhat is the best way of storing the graph?\nWhat shortest path algorithm should I use?\n\n    ", "Answer": "\r\nYou should have two tables. One for nodes and one for edges. In the edges table you should have source_node_id and dest_node_id. This way you can easily make queries on the edges table to get all the outgoing nodes that are used by Dijkstra algorithm.\n\nFor a simple Dijksra algorithm explanation see this:\nhttp://www.sce.carleton.ca/faculty/chinneck/po/Chapter8.pdf\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How to output the shortest path in Floyd-Warshall algorithm?\r\n                \r\nI'm trying to implement Floyd-Warshall algorithm (all pairs shortest path). In the code below, when I enter some numbers, it gives the last number as input. I know the code is not complete.\n\nNow what should I do to print shortest paths for each i and j? Or what do you suggest to me to do to complete this code. Thanks.\n\n```\nprivate void button10_Click(object sender, EventArgs e)\n{\n\n    string ab = textBox11.Text;\n    int matrixDimention = Convert.ToInt32(ab);\n    int[,] intValues = new int[matrixDimention, matrixDimention];\n    string[] splitValues = textBox9.Text.Split(',');\n    for (int i = 0; i < splitValues.Length; i++)\n        intValues[i / (matrixDimention), i % (matrixDimention)] =    Convert.ToInt32(splitValues[i]);\n    string displayString = \"\";\n    for (int inner = 0; inner < intValues.GetLength(0); inner++)\n    {\n        for (int outer = 0; outer < intValues.GetLength(0); outer++)\n            displayString += String.Format(\"{0}\\t\", intValues[inner, outer]);\n        displayString += Environment.NewLine;\n    }\n    int n = (int)Math.Pow(matrixDimention, 2);\n    string strn = n.ToString();\n\n    MessageBox.Show(\"matrix\"+strn+ \"in\" + strn + \"is\\n\\n\\n\" +displayString);\n////before this line i wrote the codes to get the numbers that user enter in textbox and put it in an 2d array\n    for (int k = 1; k < n+1; k++)\n\n        for (int i = 1; i < n+1; i++)\n\n            for (int j = 1; j < n+1; j++)\n\n                if (intValues[i, j] > intValues[i, k] + intValues[k, j])\n                {\n                    intValues[i, j] = intValues[i, k] + intValues[k, j];\n                    string str_intvalues = intValues[i, j].ToString();\n                    MessageBox.Show(\"Shortest Path from i to j is: \" + str_intvalues);\n\n                }\n                else\n                {\n                    string str_intvalues = intValues[i, j].ToString();\n                    MessageBox.Show(\"Shortest Path from i to j is: \" + str_intvalues);\n                }\n}\n```\n\n    ", "Answer": "\r\nTo be on a same page, let me show you the Floyd-Warshall algorithm first:\n\nLet us have a graph, described by matrix ```\nD```\n, where ```\nD[i][j]```\n is the length of edge ```\n(i -> j)```\n (from graph's vertex with index ```\ni```\n to the vertex with index ```\nj```\n).\n\nMatrix ```\nD```\n has the size of ```\nN * N```\n, where ```\nN```\n is total number of vertices in graph, because we can reach the maximum of paths by connecting each graph's vertex to each other.\n\nAlso we'll need matrix ```\nR```\n, where we will store shortest paths (```\nR[i][j]```\n contains the index of a next vertex in the shortest path, starting at vertex ```\ni```\n and ending at vertex ```\nj```\n).\n\nMatrix ```\nR```\n has the same size as ```\nD```\n.\n\nThe Floyd-Warshall algorithm performs these steps:\n\n\ninitialize the matrix of all the paths between any two pairs or vertices in a graph with the edge's end vertex (this is important, since this value will be used for path reconstruction)\nfor each pair of connected vertices (read: for each edge ```\n(u -> v)```\n), ```\nu```\n and ```\nv```\n, find the vertex, which forms shortest path between them: if the vertex ```\nk```\n defines two valid edges ```\n(u -> k)```\n and ```\n(k -> v)```\n (if they are present in the graph), which are together shorter than path ```\n(u -> v)```\n, then assume the shortest path between ```\nu```\n and ```\nv```\n lies through ```\nk```\n; set the shortest pivot point in matrix ```\nR```\n for edge ```\n(u -> v)```\n to be the corresponding pivot point for edge ```\n(u -> k)```\n\n\n\nNow that we are on a same page with definitions, algorithm can be implemented like this:\n\n```\n// Initialise the routes matrix R\nfor (int i = 0; i < N; i++) {\n    for (int t = 0; t < N; t++) {\n        R[i][t] = t;\n    }\n}\n\n// Floyd-Warshall algorithm:\nfor (int k = 0; k < N; k++) {\n    for (int u = 0; u < N; u++) {\n        for (int v = 0; v < N; v++) {\n            if (D[u, v] > D[u, k] + D[k, v]) {\n                D[u, v] = D[u, k] + D[k, v];\n                R[u, v] = R[u, k];\n            }\n        }\n    }\n}\n```\n\n\nBut how do we read the matrix ```\nD```\n?\n\nLet us have a graph:\n\n\n\n\n  In GraphViz it would be described as follows:\n\n```\ndigraph G {\n    0->2 [label = \"1\"];\n    2->3 [label = \"5\"];\n    3->1 [label = \"2\"];\n    1->2 [label = \"6\"];\n    1->0 [label = \"7\"];\n}\n```\n\n\n\nWe first create a two-dimensional array of size ```\n4```\n (since there are exactly ```\n4```\n vertices in our graph). \n\nWe initialize its main diagonal (the items, whose indices are equal, for ex. ```\nG[0, 0]```\n, ```\nG[1, 1]```\n, etc.) with zeros, because\nthe shortest path from vertex to itself has the length ```\n0```\n and the other elements with a very large number (to indicate there is no edge or an infinitely long edge between them). The defined elements, corresponding to graph's edges, we fill with edges' lengths:\n\n```\nint N = 4;\nint[,] D = new int[N, N];\n\nfor (int i = 0; i < N; i++) {\n    for (int t = 0; t < N; t++) {\n        if (i == t) {\n            D[i, t] = 0;\n        } else {\n            D[i, t] = 9999;\n        }\n    }\n}\n\nD[0, 2] = 1;\nD[1, 0] = 7;\nD[1, 2] = 6;\nD[2, 3] = 5;\nD[3, 1] = 2;\n```\n\n\nAfter the algorithm run, the matrix ```\nR```\n will be filled with vertices' indices, describing shortest paths between them. In order to reconstruct the path from vertex ```\nu```\n to vertex ```\nv```\n, you need follow the elements of matrix ```\nR```\n:\n\n```\nList<Int32> Path = new List<Int32>();\n\nwhile (start != end)\n{\n    Path.Add(start);\n\n    start = R[start, end];\n}\n\nPath.Add(end);\n```\n\n\nThe whole code could be wrapped in a couple of methods:\n\n```\nusing System;\nusing System.Collections.Generic;\n\npublic class FloydWarshallPathFinder {\n    private int N;\n    private int[,] D;\n    private int[,] R;\n\n    public FloydWarshallPathFinder(int NumberOfVertices, int[,] EdgesLengths) {\n        N = NumberOfVertices;\n        D = EdgesLengths;\n        R = null;\n    }\n\n    public int[,] FindAllPaths() {\n        R = new int[N, N];\n\n        for (int i = 0; i < N; i++)\n        {\n            for (int t = 0; t < N; t++)\n            {\n                R[i, t] = t;\n            }\n        }\n\n        for (int k = 0; k < N; k++)\n        {\n            for (int v = 0; v < N; v++)\n            {\n                for (int u = 0; u < N; u++)\n                {\n                    if (D[u, k] + D[k, v] < D[u, v])\n                    {\n                        D[u, v] = D[u, k] + D[k, v];\n                        R[u, v] = R[u, k];\n                    }\n                }\n            }\n        }\n\n        return R;\n    }\n\n    public List<Int32> FindShortestPath(int start, int end) {\n        if (R == null) {\n            FindAllPaths();\n        }\n\n        List<Int32> Path = new List<Int32>();\n\n        while (start != end)\n        {\n            Path.Add(start);\n\n            start = R[start, end];\n        }\n\n        Path.Add(end);\n\n        return Path;\n    }\n}\n\npublic class MainClass\n{\n    public static void Main()\n    {\n        int N = 4;\n        int[,] D = new int[N, N];\n\n        for (int i = 0; i < N; i++) {\n            for (int t = 0; t < N; t++) {\n                if (i == t) {\n                    D[i, t] = 0;\n                } else {\n                    D[i, t] = 9999;\n                }\n            }\n        }\n\n        D[0, 2] = 1;\n        D[1, 0] = 7;\n        D[1, 2] = 6;\n        D[2, 3] = 5;\n        D[3, 1] = 2;\n\n        FloydWarshallPathFinder pathFinder = new FloydWarshallPathFinder(N, D);\n\n        int start = 0;\n        int end = 1;\n\n        Console.WriteLine(\"Path: {0}\", String.Join(\" -> \", pathFinder.FindShortestPath(start, end).ToArray()));\n    }\n}\n```\n\n\nYou can read 'bout this algorithm on wikipedia and get some data structures generated automatically here\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "neo4j: shortest paths constrained by node and rel properties\r\n                \r\nFrom the tutorial:\n\n```\nMATCH p=shortestPath( (keanu:Person)-[:KNOWS*]-(kevin:Person) ) \nWHERE keanu.name=\"Keanu Reeves\" and kevin.name = \"Kevin Bacon\"\nRETURN length(p)\n```\n\n\nImagine each Person node has an age property and an occupation.  Every KNOWS edge has a ```\nlength of acquaintance```\n property.  \n\nWhat Cypher query would return a shortest path with, for instance,\n\n```\nage > 40 years\nnot (occupation = ACTOR)\nlengthOfAcquaintance > 10 years\n```\n\n\nIn molecular biology interaction data, we wish to make yet more complex queries - probably of the sort which cypher handles well, but just how eludes me. For example:\n\nFind the shortest paths between receptor molecule A and transcription factor B, where most edges are from small-scale experiments, most of the genes are annotated as kinase, and evidence (weight) for the edges is ```\ngreater than 0.5```\n\n\nThese queries probably come up in lots of settings. Can anyone point me towards readings and examples which will help me understand how this is done?  And maybe provide a modest extension of the \"Bacon Number\" query which accommodates one node and one edge property?\n\nThanks!\n\n\nPaul\n\n    ", "Answer": "\r\nI think that what you are looking for is the ALL predicate.\n\nHere are a couple of examples using it :\n\nShortestPath where all actors in the paths should have an ```\nage > 40```\n :\n\n```\nMATCH p=shortestPath( (keanu:Person)-[:KNOWS*]-(kevin:Person) ) \nWHERE keanu.name = \"Keanu Reeves\"\nAND kevin.name = \"Kevin Bacon\" \nAND ALL(x IN nodes(p) WHERE x.age > 40)\nRETURN p\n```\n\n\nShortestPath where all edges should have a ```\nlengthOfAcquaintance > 10```\n\n\n```\nMATCH p=shortestPath( (keanu:Person)-[:KNOWS*]-(kevin:Person) ) \nWHERE keanu.name = \"Keanu Reeves\" \nAND kevin.name = \"Kevin Bacon\"\nAND ALL(x in rels(p) WHERE x.lengthOfAcquaintance > 100\nRETURN p\n```\n\n\nOf course you can combine the both :\n\n```\nMATCH p=shortestPath( (keanu:Person)-[:KNOWS*]-(kevin:Person) ) \nWHERE keanu.name = \"Keanu Reeves\" \nAND kevin.name = \"Kevin Bacon\"\nAND ALL(x in rels(p) WHERE x.lengthOfAcquaintance > 10)\nAND ALL(x in nodes(p) WHERE x.age > 40)\nRETURN p\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "K shortest path python\r\n                \r\nI'm having issues in finding K shortest path from a source called S to a destination called T. My Code looks like this\n\n```\nK = 4\nS = 'C'\nT = 'A'\nB = {}\nP = set()\ncount = {}\nfor U in graph.keys():\n    count[U] = 0 \n\nB[S] = 0 \nwhile(len(B)>=1 and count[T]<K):\n    PU = min(B, key = B.get)\n    cost = B[PU]\n    U = PU[len(PU)-1]\n    del B[PU]\n    count[U] += 1 \n    if U==T:\n       P.add(U)\n       if count[U]<=K:\n          V = graph[U].keys()\n          for v in V:\n             if v not in PU:\n                PV = PU+v\n                B[PV] = cost+1\n```\n\n\nThis is equivalent to the actual code equivalent of Pseudo Code which can be found at https://en.wikipedia.org/wiki/K_shortest_path_routing . The actual variables are also the same as in Pseudo Code.Furthermore, my graph looks like this:\n\n{\n\n```\n'A': {'C': 4.0, 'B': 10.0, 'E': 10.0, 'D': 10.0, 'G': 1.0, 'F': 2.0, 'I': 3.0, 'H': 3.0, 'J': 10.0}, 'C': {'A': 4.0, 'B': 5.0, 'E': 9.0, 'D': 6.0, 'G': 9.0, 'F': 10.0, 'I': 5.0, 'H': 10.0, 'J': 5.0}, 'B': {'A': 2.0, 'C': 10.0, 'E': 8.0, 'D': 1.0, 'G': 8.0, 'F': 4.0, 'I': 2.0, 'H': 2.0, 'J': 6.0}, 'E': {'A': 9.0, 'C': 5.0, 'B': 10.0, 'D': 4.0, 'G': 9.0, 'F': 9.0, 'I': 3.0, 'H': 3.0, 'J': 7.0}, 'D': {'A': 4.0, 'C': 6.0, 'B': 5.0, 'E': 7.0, 'G': 1.0, 'F': 1.0, 'I': 2.0, 'H': 9.0, 'J': 3.0}, \n'G': {'A': 2.0, 'C': 10.0, 'B': 3.0, 'E': 1.0, 'D': 10.0, 'F': 5.0, 'I': 5.0, 'H': 6.0, 'J': 1.0}, 'F': {'A': 2.0, 'C': 3.0, 'B': 6.0, 'E': 7.0, 'D': 8.0, 'G': 10.0, 'I': 1.0, 'H': 8.0, 'J': 2.0}, 'I': {'A': 1.0, 'C': 1.0, 'B': 2.0, 'E': 1.0, 'D': 6.0, 'G': 7.0, 'F': 1.0, 'H': 6.0, 'J': 2.0}, \n'H': {'A': 3.0, 'C': 4.0, 'B': 5.0, 'E': 1.0, 'D': 2.0, 'G': 6.0, 'F': 4.0, 'I': 1.0, 'J': 4.0}, \n'J': {'A': 5.0, 'C': 6.0, 'B': 1.0, 'E': 8.0, 'D': 7.0, 'G': 9.0, 'F': 8.0, 'I': 10.0, 'H': 1.0}}\n```\n\n\nMy Output looks like this \n\n```\n{'A'}\n```\n\n\nWhereas there should be four paths.\n\nAlso, Please Note I'm not allowed to Use Networkx or Graph libraries. I have to use the basic libraries in Python only. \n\nIs Someone able to understand the Problem ?\n    ", "Answer": "\r\nI made a few changes in your code. There was an error in your where you check if the node is the target and the code following that. \n\n```\nK = 4\nS = 'C'\nT = 'F'\nB = {}\nP = set()\ncount = {}\nfor U in graph.keys():\n    count[U] = 0\n\nB[S] = 0\nwhile(len(B)>=1 and count[T]<K):\n    PU = min(B, key = B.get)\n    print('Minimum Distance found in this loop : ' , PU)\n    cost = B[PU]\n    U = PU[len(PU)-1]\n    del B[PU]\n    count[U] += 1\n    if(U == T):\n        P.add(PU)\n        print('Closest neighbour of ' , S , ' is : ', U)\n        print('Reached target')\n        print('Final map : ', P)\n        exit(0)\n    else:\n       if count[U] <= K:\n          V = graph[U].keys()\n          print('Looking at neighbours of : ', PU)\n          for v in V:\n             if v not in PU:\n                PV = PU + v\n                print(PV)\n                B[PV] = cost+1\n          print('B dictionary is : ', B)\n```\n\n\nRun this program and you will get something like : \n\n```\nMinimum Distance found in this loop :  C\nLooking at neighbours of :  C\nCA\nCB\nCE\nCD\nCG\nCF\nCI\nCH\nCJ\nB dictionary is :  {'CA': 1, 'CB': 1, 'CE': 1, 'CD': 1, 'CG': 1, 'CF': 1, 'CI': 1, 'CH': 1, 'CJ': 1}\nMinimum Distance found in this loop :  CA\nClosest neighbour of  C  is :  A\nReached target\nFinal map :  {'CA'}\n```\n\n\nThe output should be fairly self-descriptive. \nAlso, you have weights associated with each node (I presume it is that), then I don't understand why you increment the distance count by just 1 to each corresponding neighbour\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest Path - Breadth first search\r\n                \r\nI have an assignment for a paper and in no means am I asking for any code help, only help to understand how to approach this problem.\n\nWe where given minimal material to work from and the professor only skimmed over the content of Breadth first search.\n\nWe need to find our way through a maze, the maze is is created and your person lands on a random space every time.\n\nWhen the key is pressed the current position is sent to the function and from there we have to use breadth first search to find the shortest path.\n\nNow what I understand from this search algorithm is the following:\n\n\nTree or graph must be searched in levels\nWe need to store the paths in a queue (FIFO)\nThen find the shortest path out of all paths to the end item\n\n\nHow exactly do I approach this type of problem?\n\nWe know the start and end, plus we can get all the neighbour blocks of the current block easily.\n\nMuch appreciated.\n    ", "Answer": "\r\nYou seem to have missed some nuance of Breadth first search.\n\n\n  Tree or graph must be searched in levels\n\n\nThis is correct. Although you won't necessarily keep track of a set of distinct levels, you just naturally continue to the next one after one is completed.\n\n\n  We need to store the paths in a queue (FIFO)\n\n\nNot really. You typically store future nodes to explore in a queue, not entire paths. Maintaining the path, if required is an extra problem.\n\n\n  Then find the shortest path out of all paths to the end item\n\n\nIn a graph that has uniform edge weights, this is unnecessary. The first path you find is the shortest. (Do note the requirement of uniform edge weights for this to be true for BFS)\n\nThe general code for a BFS for a goal node is something like the following:\n\n```\nq := new Queue\nq.enqueue(start)\ngoal_found := false\nwhile( q is not empty )\n    n := q.dequeue()\n    if n is goal then\n        goal_found := true\n        break\n    for each neighbour v of n\n        q.enqueue(v)\n\nif(goal_found)\n    //do something (success)\nelse\n    //do something else (failure)\n```\n\n\nThere is a little more to add to this skeleton if you wish to track the path you traversed, prevent doubling back on your path (in an undirected graph this is very important for ensuring termination), prevent repeat processing of a node in general (necessary if there are cycles and you want to terminate), keep track of length, etc. But this is the basic framework for it.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How to find the shortest path matrix?\r\n                \r\nI have an weighted adjacency matrix ```\nm```\n and I need the find the shortest path matrix. The expected result is:\n\n```\nlibrary(igraph)\n\nn = 8\nm <- t(matrix(c(\n0,0,0,0,0,0,0,8,\n3,0,0,0,0,0,0,0,\n5,0,0,5,1,0,0,0,\n0,0,6,0,0,7,1,0,\n0,6,2,0,0,0,0,0,\n0,0,0,0,0,0,0,0,\n7,4,0,0,8,0,0,3,\n0,3,0,0,0,9,0,0),ncol=n))\n\ng1 <- graph_from_adjacency_matrix(m, weighted=TRUE, mode=\"directed\")\n\nV(g1)$names <-  letters[1:n]\nplot(g1, vertex.label = V(g1)$names, edge.arrow.size=0.5)\n```\n\nMy attept is:\n```\npath_name <- c()\n\nfor (i in c(1,2,6,8)){\nfor (path in all_simple_paths(g1, i, V(g1), mode=\"out\")) {\n       path_name <- c(path_name, paste(V(g1)[path]$names, collapse='')); \n}\n}\npath_name\n    [1] \"ah\"   \"ahb\"  \"ahf\"  \"ba\"   \"bah\"  \"bahf\" \"hb\"   \"hba\"  \"hf\"\n```\n\nOne can see that I have found the paths just for four nodes: 1, 2, 5, 6 with names a,  b, f, h. If we take a, b, h as a start node we can obtain 3 paths for each node while for h no path.\nQuestion. How to reconstruct the paths for all nodes?\nI don't found the Lee (wave) algoritms.\n    ", "Answer": "\r\nYou can try the code below\n```\nm <- d <- distances(g1, mode = \"out\")\nfor (i in row.names(d)) {\n    for (j in colnames(d)) {\n        if (i != j) {\n            if (!is.infinite(d[i, j])) {\n                m[i, j] <- paste0(names(shortest_paths(g1, i, j)$vpath[[1]]), collapse = \"\")\n            } else {\n                m[i,j] <- NA\n            }\n        } else {\n            m[i, j] <- \"\"\n        }\n    }\n}\n```\n\nand you will see the shortest-path matrix ```\nm```\n\n```\n> m\n  a     b     c     d      e     f      g      h\na \"\"    \"ahb\" NA    NA     NA    \"ahf\"  NA     \"ah\"\nb \"ba\"  \"\"    NA    NA     NA    \"bahf\" NA     \"bah\"\nc \"ca\"  \"ceb\" \"\"    \"cd\"   \"ce\"  \"cdf\"  \"cdg\"  \"cdgh\"\nd \"dga\" \"dgb\" \"dc\"  \"\"     \"dce\" \"df\"   \"dg\"   \"dgh\"\ne \"eca\" \"eb\"  \"ec\"  \"ecd\"  \"\"    \"ecdf\" \"ecdg\" \"ecdgh\"\nf NA    NA    NA    NA     NA    \"\"     NA     NA\ng \"ga\"  \"gb\"  \"gec\" \"gecd\" \"ge\"  \"ghf\"  \"\"     \"gh\"\nh \"hba\" \"hb\"  NA    NA     NA    \"hf\"   NA     \"\" \n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path in paragliding race\r\n                \r\nI'm a paragliding pilot. A paragliding race is defined as a set of virtual buoys. The pilot who flies through all buoys first wins.\n\nA buoy is defined with two parameters:\n\n\nthe coordinates of a point\na radius\n\n\nThis defines a cylinder in a 3D space, but for simplicity let's keep the problem in 2D. A race could look something like this (approximate drawing):\n\nA=1000m; B=3000m; C=2000m; D=500m\n\nThe pilot should start inside circle A, then fly inside circle B and C (or at least just 'touch' it) and should end inside circle D.\n\nHow do you calculate the optimal (shortest) path?\n\nThe result should be the coordinates of all segments that make part of the shortest path.\n    ", "Answer": "\r\nIf the path is known a priori to be ABCD and only the exact points are unknown, then the total distance (squared) can be written as a function of 4 variables.\n\nOne parameterization of point i is of course\n\n```\nx(t_i) = x0_i + r_i * cos(t_i)\ny(t_i) = y0_i + r_i * sin(t_i)\n```\n\n\nThe path length squared is \n\n```\nD^2 = sum_{i = 1, n-1} (x(t_{i+i}) - x(t_i))^2 + (y(t_{i+i}) - y(t_i))^2\n```\n\n\nThe four variables you're solving for are t_1,...t_4. After substitution, the final expression for D^2 is a pretty hairy quadratic over sine and cosine. You're out to minimize that quantity.\n\nThis is not something likely to admit an analytic solution.  \n\nYou could also try a rational quadratic parameterization of the circle, but you'd end up with a rational quartic. Not much (any?) simpler.\n\nHappily even such hairy functions can be minimized by standard numerical non-linear optimization algorithms such as (as someone suggested in comments) gradient descent.  \n\nIn the general case, you can't guarantee that minimums found by such algorithms  are global. But here it seems the solution space might be convex, at least for most problem instances, which makes a local minimum also global.\n\nThere's also likely to exist good heuristic ways of choosing starting points for the numerical iteration. For example take the path along the centers of the circles. For each circle pick the midpoint between its two intersections with the path.\n\nWith similar logic you can constrain the values of each t_i to a range always less than \\pi.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "dijkstra algorithm, run only one time for shortest paths of some nodes (not two, not the whole graph)\r\n                \r\nSo, dijkstra algorithm is (the best one) used to search for the shortest path of a weighted(without negative) and connected graph. Dijkstra algorithm can be used to find the shortest path of two points/vertices. AND it can be used to find the shortest path of all the vertices. \n\nquestions:\nis my understanding correct? \nCan it also be used to find the shortest paths of some pair of vertices ? for example, the graph has A, B, C, D, E, F, G, H, I, J, K.  and we are only interested in the shortest paths of A,B ; C,K. it that possible we only turn the algorithm only one time to find out two paths? \n    ", "Answer": "\r\nYou will need to run two Dijkstras. One starting from ```\nA```\n and one from ```\nC```\n.\n\nWhat you could do is to run it from ```\n{A, C}```\n (a set Dijkstra) until you have found paths to ```\nB```\n and ```\nK```\n. But that is no guarantee that the resulting paths are actually from ```\nA```\n to ```\nB```\n and ```\nC```\n to ```\nK```\n, it could as well be ```\nC, B```\n and ```\nC, K```\n. Actually, all combinations of ```\n{A, C}, B```\n and ```\n{A, C}, K```\n are then possible.\n\n\n\n\n  the best one\n\n\nNot at all. It is a good concept and heavily used for many other similar algorithms. There are many variants, like A*, Arc-Flags, and others. But raw Dijkstra is super slow since it equally searches in all directions.\n\nImagine a query where you have modeled the whole world. Your destination is ```\n1 hour```\n away. Then Dijkstra will find shortest paths to all nodes that can be reached in ```\n1 hour```\n. So it will also consider a short flight to your neighboring country, even if it's the totally wrong direction. The algorithm ```\nA*```\n is a simple modification of Dijkstra that tries to improve on that by introducing a heuristic function that is able to make (hopefully) good guesses about shortest path distances. By that your Dijkstra gets a sense of direction and tries to first prioritize a search into the direction of the destination.\n\nA simple heuristic is as-the-crows-fly. Note that this heuristic does not perform well on road networks and especially bad on transit networks (you often need to drive ```\n10 mins```\n into the wrong direction to get on a highway that lets you arrive earlier in the end, or you need to first drive to some big city to get a good fast train). Other heuristics involve computing landmarks, they yield pretty good results but need a lot of pre-computation and space (usually not a problem).\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path performance in Graphx with Spark\r\n                \r\nI am creating a graph from a ```\ngz```\n compressed ```\njson```\n file of ```\nedge```\n and ```\nvertices```\n type.\n\nI have put the files in a dropbox folder here\n\nI load and map these ```\njson```\n records to create the ```\nvertices```\n and ```\nedge```\n types required by ```\ngraphx```\n like this:\n\n```\nval vertices_raw = sqlContext.read.json(\"path/vertices.json.gz\")\nval vertices = vertices_raw.rdd.map(row=> ((row.getAs[String](\"toid\").stripPrefix(\"osgb\").toLong),row.getAs[Long](\"index\")))\nval verticesRDD: RDD[(VertexId, Long)] = vertices\nval edges_raw = sqlContext.read.json(\"path/edges.json.gz\")\nval edgesRDD = edges_raw.rdd.map(row=>(Edge(row.getAs[String](\"positiveNode\").stripPrefix(\"osgb\").toLong, row.getAs[String](\"negativeNode\").stripPrefix(\"osgb\").toLong, row.getAs[Double](\"length\"))))\nval my_graph: Graph[(Long),Double] = Graph.apply(verticesRDD, edgesRDD).partitionBy(PartitionStrategy.RandomVertexCut)\n```\n\n\nI then use this ```\ndijkstra```\n implementation I found to compute a shortest path between two vertices:\n\n```\ndef dijkstra[VD](g: Graph[VD, Double], origin: VertexId) = {\n          var g2 = g.mapVertices(\n        (vid, vd) => (false, if (vid == origin) 0 else Double.MaxValue, List[VertexId]())\n          )\n          for (i <- 1L to g.vertices.count - 1) {\n            val currentVertexId: VertexId = g2.vertices.filter(!_._2._1)\n              .fold((0L, (false, Double.MaxValue, List[VertexId]())))(\n                (a, b) => if (a._2._2 < b._2._2) a else b)\n              ._1\n\n            val newDistances: VertexRDD[(Double, List[VertexId])] =\n              g2.aggregateMessages[(Double, List[VertexId])](\n            ctx => if (ctx.srcId == currentVertexId) {\n              ctx.sendToDst((ctx.srcAttr._2 + ctx.attr, ctx.srcAttr._3 :+ ctx.srcId))\n            },\n            (a, b) => if (a._1 < b._1) a else b\n          )\n        g2 = g2.outerJoinVertices(newDistances)((vid, vd, newSum) => {\n          val newSumVal = newSum.getOrElse((Double.MaxValue, List[VertexId]()))\n          (\n            vd._1 || vid == currentVertexId,\n            math.min(vd._2, newSumVal._1),\n            if (vd._2 < newSumVal._1) vd._3 else newSumVal._2\n            )\n        })\n        }\n\n          g.outerJoinVertices(g2.vertices)((vid, vd, dist) =>\n        (vd, dist.getOrElse((false, Double.MaxValue, List[VertexId]()))\n          .productIterator.toList.tail\n          ))\n        }\n```\n\n\nI take two random vertex id's:\n\n```\nval v1 = 4000000028222916L\nval v2 = 4000000031019012L\n```\n\n\nand compute the path between them:\n\n```\nval results = dijkstra(my_graph, v1).vertices.map(_._2).collect\n```\n\n\nI am unable to compute this locally on my laptop without getting a stackoverflow error. I can see that it is using 3 out of 4 cores available. I can load this graph and compute shortest 10 paths per second with the ```\nigraph```\n library in Python on exactly the same graph. Is this an inefficient means of computing paths? At scale, on multiple nodes the paths will compute (no stackoverflow error) but it is still 30/40seconds per path computation.  \n    ", "Answer": "\r\nAs you can read on the python-igraph github \n\n\n  \"It is intended to be as powerful (ie. fast) as possible to enable the\n  analysis of large graphs.\"\n\n\nIn order to explain why it is taking 4000x more time on apache-spark than on local python, you may take a look here (A deep dive into performance bottlenecks with Spark PMC member Kay Ousterhout.) to see that it is probably due to a bottleneck:\n\n\n  ... beginning with the idea that network and disk I/O are major bottlenecks ...\n  You may not need to store your data in-memory because the job may not get that much faster. This is saying that if you moved the serialized compressed data from on-disk to in-memory...\n\n\nyou may also see here & here some informations , but best final method is to benchmark your code to know where the bottleneck is.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "how can i get Shortest Path cypher query?\r\n                \r\nI created a Neo4j database with the cypher statement here:https://gist.github.com/neoecos/8748091\n\ni want to know : how to get :\n           1.less Transfer Paths (order by transfer)\n           2.the Shortest Path （order by path length)\n           3.the optimal Path (less Transfer and the Shortest Path)\n\nplease give the corresponding query. \nAnd do you think that is the best way to create a Bus inquiry system？\nThanks a lot.\n    ", "Answer": "\r\nThe shortest path is pretty easy:\n\n```\nMATCH path=shortestPath((station_44:STATION {id:44})-[*0..10]-(station_46:STATION {id:46}))\nRETURN path\n```\n\n\nAs far as counting transfers you can do something like this:\n\n```\nMATCH path=allShortestPaths((station_44:STATION {id:44})-[rels*0..10]-(station_46:STATION {id:46}))\nRETURN length(path) AS stop_count, length(FILTER(index IN RANGE(1, length(rels)-1) WHERE (rels[index]).bus <> (rels[index - 1]).bus)) AS transfer_count\n```\n\n\nOnce you have those two variables you can calculate / sort however you like.  For example:\n\n```\nMATCH path=(station_44:STATION {id:44})-[rels*0..4]-(station_46:STATION {id:46})\nWITH length(path) AS stop_count, length(FILTER(index IN RANGE(1, length(rels)-1) WHERE (rels[index]).bus <> (rels[index - 1]).bus)) AS transfer_count\nRETURN stop_count, transfer_count\nORDER BY (stop_count * 0.5) + (transfer_count * 2.0) DESC\n```\n\n\nHere I removed the ```\nallShortestPaths```\n call so that you get different lengths of paths.  The ```\nORDER BY```\n uses weights on the two metrics.  Unfortunately, at least in my DB, if you go beyond a path length of four it starts to get really slow.  You might be able to improve that by introducing a direction arrow in the path, if that makes sense in your case.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Dijkstra's Shortest Path algorithm not returning shortest path with smallest weight\r\n                \r\nI'm using a graph library called JGraphT and in my program I have several vertex's connected together by an edge with a weight of the cost of travel.\n\nIn one example where i weight by just an integer, it works! But when i change this to using my class ```\nFlightData```\n as the weight, it doesn't work.\n\nHere is my code with the weight as just an integer:\n\n```\nList<DefaultWeightedEdge> path = DijkstraShortestPath.findPathBetween(graph, start, end);\n    for(int i = 0; i < path.size(); i++) {\n        DefaultWeightedEdge edge = path.get(i);\n        System.out.println((i+1) + \" \" + graph.getEdgeSource(edge) + \" -> \" + graph.getEdgeTarget(edge));\n    }\n```\n\n\nHere is my code for the weight as my FlightData class:\n\n```\nList<FlightData> path = DijkstraShortestPath.findPathBetween(graph, start, end);    \nfor(int i = 0; i < path.size(); i++) {\n        FlightData f = path.get(i);\n    System.out.println((i+1) + \" \" + graph.getEdgeSource(f) + \" -> \" + graph.getEdgeTarget(f));\n}\n```\n\n\nMy FlightData class is simply just a class with accessor methods:\n\n```\nimport org.jgrapht.graph.DefaultWeightedEdge;\n\npublic class FlightData extends DefaultWeightedEdge\n{\n    private String flightNumber, depTime, arrTime;\n    private double price;\n\n    public FlightData(String flightNumber, String depTime,\n            String arrTime, double price) {\n        this.flightNumber = flightNumber;\n        this.depTime = depTime;\n        this.arrTime = arrTime;\n        this.price = price;\n    }\n\n    public String getFlightNumber() {\n        return flightNumber;\n    }\n    public String getDepartureTime() {\n        return depTime;\n    }\n    public String getArrivalTime() {\n        return arrTime;\n    }\n    public double getFlightPrice() {\n        return price;\n    }\n}\n```\n\n\nCan anyone point me in the right direction as to why one reveals the shortest path with the lowest weight and the other with the shortest path and not necessarily the lowest weight? (If there is a direct path between two vertexes it will just return that!)\n    ", "Answer": "\r\nYou need to override ```\nDefaultWeightedEdge.getWeight()```\n in ```\nFlightData```\n, e.g. to return ```\nprice```\n:\n\n```\n@Override\nprotected double getWeight() {\n  return price;\n}\n```\n\n\nOtherwise, you will use the default edge weight, which is ```\n1.0```\n.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "A* pathfinding guaranteed to find shortest path?\r\n                \r\nIs the A* path finding algorithm guaranteed to find the shortest path 100% or the time, if implemented correctly?\n\n```\nint Graph::FindPath(Node *start, Node *finish, list< vec2f > &path)\n{\n    list<NodeRecord*> open;\n    list<NodeRecord*> closed;\n    list<NodeRecord*>::iterator openIt;\n    list<NodeRecord*>::iterator closedIt;\n\n    // add the starting node to the open list\n    open.push_back( new NodeRecord(start, NULL, 0.0f, 0.0f + start->pos.DistanceSq(finish->pos) ) );\n  // NodeRecord(Node *node, Node *from, float cost, float totalCost)\n\n    while(!open.empty())\n    {\n        // find the node record with the lowest cost\n        NodeRecord *currentRecord = open.front();\n        openIt = ++open.begin();\n\n        while(openIt != open.end())\n        {\n            if((*openIt)->total < currentRecord->total)\n                currentRecord = (*openIt);\n\n            openIt++;\n        }\n\n        // get a pointer to the current node\n        Node *currentNode = currentRecord->node;\n\n        // if the current node is the finish point\n        if(currentNode == finish)\n        {\n            // add the finish node\n            path.push_front(currentNode->pos);\n\n            // add all the from nodes\n            Node *from = currentRecord->from;\n\n            while(!closed.empty())\n            {\n                // if this node record is where the path came from,\n                if(closed.back()->node == from) //&& closed.back()->from != NULL\n                {\n                    // add it to the path\n                    path.push_front( from->pos );\n\n                    // get the next 'from' node\n                    from = closed.back()->from;\n                }\n\n                // delete the node record\n                delete closed.back();\n                closed.pop_back();\n            }\n\n            while(! open.empty() )\n            {\n                delete open.back();\n                open.pop_back();\n            }\n\n            // a path was found\n            return 0;\n        }\n\n        // cycle through all neighbours of the current node\n\n        bool isClosed, isOpen;\n\n        for(int i = 0; i < (int)currentNode->neighbours.size(); i++)\n        {\n            // check if neigbour is on the closed list\n            isClosed = false;\n            closedIt = closed.begin();\n            while(closedIt != closed.end())\n            {\n                if(currentNode->neighbours[i] == (*closedIt)->node)\n                {\n                    isClosed = true;\n                    break;\n                }\n\n                closedIt++;\n            }\n\n            // skip if already on the closed list\n            if(isClosed == true)\n                continue;\n\n            float cost = currentRecord->cost + currentNode->distance[i];\n            float totalCost = cost + currentNode->neighbours[i]->pos.DistanceSq(finish->pos);\n\n            // check if this neighbour is already on the open list\n            isOpen = false;\n            openIt = open.begin();\n            while(openIt != open.end())\n            {\n                if(currentNode->neighbours[i] == (*openIt)->node)\n                {\n                    // node was found on the open list\n                    if(totalCost < (*openIt)->total)\n                    {\n                        // node on open list was updated\n                        (*openIt)->cost = cost;\n                        (*openIt)->total = totalCost;\n                        (*openIt)->from = currentNode;\n                    }\n\n                    isOpen = true;\n                    break;\n                }\n\n                openIt++;\n\n            }\n\n            // skip if already on the open list\n            if(isOpen == true)\n                continue;\n\n            // add to the open list\n            open.push_back( new NodeRecord(currentNode->neighbours[i], currentNode, cost, totalCost) );\n        }\n\n        // move the current node to the closed list after it has been evaluated\n        closed.push_back( currentRecord );\n        open.remove( currentRecord );\n    }\n\n    // free any nodes left on the closed list\n    while(! closed.empty() )\n    {\n        delete closed.back();\n        closed.pop_back();\n    }\n\n    // no path was found\n    return -1;\n}\n```\n\n    ", "Answer": "\r\nYes (but I haven't looked deeply at your implementation).\n\nThe thing that most people miss is that the heuristic algorithm MUST underestimate the cost of traversal to the final solution (this is called \"admissible\").  It is also good (but not absolutely required) for the heuristic to monotonically approach the solution (this is called \"consistent\")\n\n\n\nAnyway, at my glance at your code, you probably should use ```\nstd::set```\n for your closed list and ```\nstd::deque```\n for your open one so that your searches and insertion in these two lists aren't O(n).  You also shouldn't make ```\nnew NodeRecords```\n, since it gives you a level of indirection with no benefit (and your algorithm will leak memory if an exception is thrown).\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Dissimilarity between shortest path trees\r\n                \r\nI am trying to find dissimilarity between shortest path tree of two nodes.\n\nA sample undirected graph of 5 nodes with edges,edgeweight:\n\n(4 1) 2\n(1 2) 3\n(3 2) 4\n(1 3) 8\n(4 3) 5\n(2 4) 1\n(5 4) 6\n(1 5) 4\n(2 5) 7\n\nThe Node names/Labels are:\nLabels:\nNode 1:s\nNode 2:u\nNode 3:x\nNode 4:v\nNode 5:y\n\nI have computed the shortest path for the Nodes 1 and 2.\n\nThe shortest path for Node 1 is: {[1],[1 2],[1 3],[1 2 4],[1 5]}\nThe shortest path for Node 2 is: {[1],[2],[2 4 3],[ 2 4],[2 5]}\n\nGiven that shortest path can be represented as a vector of vertex labels T=[tk],k=1..N such that tk is the label of the parent of vertex k with a symbol 0 to indicate the root.\nI need to find dissimilarity ie., the number of places where corresponding labels in T1 and T2 do not match.\n\nCan any one be able to help me with this?\n\nI am confused about the representation of T as a vector of vertex labels.\n\nThank you.\n    ", "Answer": "\r\nYour vector T is a vector containing the parent labels of each node. For your sample, T1 would look like [0,0,0,2,0], indicating that, in order to get to 4, you have to follow the path to node 2 and then take a link to 4.\n\nThis is a rather simple way of representing your paths. If you need to find the differences between both vectors, you could compare them elementwise or do a xor between both vectors. If you take that difference, the differences you'll find are the nodes that have different parents.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "shortest path through weighted graph\r\n                \r\nI'd like to create a network optimization model that uses probability distributions instead of single-point estimates for the weights between nodes. To get started, I wrote a python script that builds a sample network in Neo4j:\n\n```\nfrom py2neo import neo4j\nimport random\n\nrandom.seed(1234)\n\ndef makeGraph():\n    graph_db = neo4j.GraphDatabaseService()\n    graph_db.clear()\n    location = graph_db.get_or_create_index(neo4j.Node, \"LOCATION\")\n    loss = graph_db.get_or_create_index(neo4j.Relationship, \"LOSS\")\n    fromToLoss = []\n    fromToLoss.append(('start', 'm', random.gammavariate(alpha=3, beta=1)))\n    fromToLoss.append(('start', 'n', random.normalvariate(mu = 5, sigma = 0.5)))\n    fromToLoss.append(('start', 'o', random.gammavariate(alpha=6, beta=0.5)))\n    fromToLoss.append(('m', 'p', random.gammavariate(alpha=5, beta=0.5)))\n    fromToLoss.append(('n', 'p', random.gammavariate(alpha=7, beta=0.5)))\n    fromToLoss.append(('n', 'q', random.gammavariate(alpha=6, beta=0.5)))\n    fromToLoss.append(('o', 'q', random.normalvariate(mu = 5, sigma = 0.5)))\n    fromToLoss.append(('p', 'r', random.gammavariate(alpha=6, beta=0.5)))\n    fromToLoss.append(('p', 's', random.gammavariate(alpha=6, beta=0.5)))\n    fromToLoss.append(('q', 's', random.normalvariate(mu = 6, sigma = 0.4)))\n    fromToLoss.append(('q', 't', random.gammavariate(alpha=6, beta=0.5)))\n    fromToLoss.append(('r', 'end', random.normalvariate(mu = 5, sigma = 0.5)))\n    fromToLoss.append(('s', 'end', random.gammavariate(alpha = 5, beta=0.7)))\n    fromToLoss.append(('t', 'end', random.normalvariate(mu = 5, sigma = 0.5)))\n    for edge in fromToLoss:\n        vertexFrom, vertexTo, loss = edge\n        fromLocation = location.get_or_create('LOCATION', vertexFrom, {'location':vertexFrom})\n        toLocation = location.get_or_create('LOCATION', vertexTo, {'location':vertexTo})\n        path = fromLocation.get_or_create_path((\"CONNECTS\", {\"distance\": loss}), toLocation)\n\nmakeGraph()\n```\n\n\nThe Python script creates the following graph:\n\n\n\nLonger term, my intention was iteratively sample costs/times from real legs of the journey in order to understand how to best route goods through the network, and what sort of service levels can be expected. It's effectively a Monte Carlo simulation of the shortest path through a weighted network.\n\nI'm new to Neo4j and attempted to write a shortest path Cypher query:\n\n```\nSTART beginning=node(228068), end=node(228077) \nMATCH p = shortestPath(beginning-[*..500]-end) \nRETURN p\n```\n\n\nIt returns the following path through the network:\n\n\n\nThe route through the network that's returned by the query is not the shortest one in terms of distance. I imagine that the edges between the vertices are being weighted equally.\n\nCan you see what needs to be done to the Cypher query in order to weight the shortest path by distance?\n    ", "Answer": "\r\n```\nSTART start=node(244667), end=node(244676)\nMATCH p=(start)-[:CONNECTS*1..4]->(end)\nRETURN p as shortestPath,\nREDUCE(distance=0, r in relationships(p) | distance+r.distance) AS totalDistance\nORDER BY totalDistance ASC\nLIMIT 1\n```\n\n\ntry this query, this should work for you. \n\nAt first you try to get the Path from StartNode to your EndNode, then call the ```\nREDUCE```\n function, set an accumulator with the initial value 0. The we run through the Collection (Path) and hav a look at the Relationships, an ```\nREDUCE```\n will run the Expression behind the Pipe Stroke on every Element of the Collection, therfor we need the r and sums all distances. Last but not least, we ORDER BY the totalDistance and it will show the shortestPath from Node 228068 to Node 228077... \n\nPatrick\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Spark Graphx shortest paths and print the vertexs\r\n                \r\nI have generate a  graph G in Spark GraphX using Scala. I would like to find the number of edges that should be crossed starting from a known vertex pointA to arrive in another vertex pointB. In other words, I need the some shortest paths  and display the points from the vertex pointA to the vertex pointB calculated in number of edges (not using the edges' weights).\n\nI am new to spark and scala , and i am struggling about these problems. is any possible that i can use the pregel to do that , pls let me know ! Thanks a lot!  \n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path with even number of edges\r\n                \r\nGiven a weighted undirected graph G and two nodes U,V to get the shortest path. How can i get the shortest path from U to V that uses a even number of edges (if possible to get it) ?\n\nI've found some articles on the web speaking that a modification on the original graph is necessary. But i can't understand how to do it.\n\nThere is some good material to study on this problem ?\n    ", "Answer": "\r\nYou'll need to build an intermediate graph and run Dijkstra's on that graph.\n\nGiven a graph ```\nG = (V, E)```\n, create a new graph ```\nG' = (V', E')```\n, with ```\nV'```\n a new set of vertices ```\nv_even```\n and ```\nv_odd```\n for every vertex ```\nv```\n in ```\nV```\n and ```\nE'```\n the set of vertices as follows:\nIf ```\n(u, v)```\n is an edge in ```\nG```\n, then ```\n(u_odd, v_even)```\n and ```\n(u_even, v_odd)```\n are edges in ```\nG'```\n, with the same weight.\n\nObviously, the new graph has twice as many edges and vertices as the original graph.\n\nNow, if you wanted to find the shortest path between ```\ns```\n and ```\nt```\n in ```\nG```\n, simply run Dijkstra's on ```\nG'```\n to find the shortest path between ```\ns_even```\n and ```\nt_even```\n. \n\nThe running time is still ```\nO(|V| log |E|)```\n.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest Path problem with priority queue\r\n                \r\nI created a program that tries to find the shortest path between train stations in NYC. I have a shortest path algorithm working with a priority queue but for some reason my queue isn't working. The autoAssLinks function is what is creating my links for my hashset. That's the only place I can think might have a problem. \n\n```\npublic void autoAddLinks() {\n\n    InputReader input = new InputReader(\"StationsModified2.txt\");\n    new Graph();\n    String currentLine = \"\";\n    String stationPrev = \"\";\n    String stationCurr = \"\";\n    String inputLine = input.readLine();\n    while (inputLine != null) { \n      if (inputLine.trim().equals(\"\")) { //line is empty\n        inputLine = input.readLine(); //reads next line\n        continue; //ignore empty line\n\n      } else {\n        if (stationCurr.equals(\"\")) { //first station of the line\n          stationCurr = inputLine.trim();\n        } else { //already have a station stored\n          stationPrev = stationCurr;\n          stationCurr = inputLine.trim();\n          addLink(stationPrev, stationCurr, currentLine);\n          addStation(stationCurr);\n        }\n      }\n      inputLine = input.readLine();\n\n    }\n\n  }\npublic void path(Station a, Station b){\n    q = new PriorityQueue();\n    visited = new HashMap();\n    Label from = new Label(a);\n    from.cost = 0;\n    q.add(from);\n    for(Station station: g.stations.values()){\n        if(!a.equals(station)){\n            from = new Label(station);\n            q.add(from);\n        }\n    }\n    while(!q.isEmpty()){\n        Label u = q.poll();\n        visited.put(u.here.name, u);\n        for(Link link: g.links){\n            Label v = getLabel(link.from);\n            if(link.from.equals(u.here.name)&& v != null){\n                int newCost = u.cost + link.weight;\n                if(newCost<v.cost){\n                    v.cost = newCost;\n                    v.from = u;\n                    q.remove(v);\n                    q.add(v);\n                }\n            }\n        }\n    }\n    Label label = visited.get(b.name);\n    route = new ArrayList();\n    while(!label.here.equals(a)){\n        route.add(label.here);\n        label = label.from;\n    }\n    route.add(a);\n\n    Collections.reverse(route);\n    for(int i =0;i<route.size();i++){\n        System.out.println(route.get(i).name);\n    }\n    }\n```\n\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Find all shortest paths between two nodes in a graph without adding weight attributes\r\n                \r\nGiven a directed graph G, source node s, target node t and a weight function f.\nIs it possible to calculate all shortest paths between s-t using networkx without adding the weights as edge attributes?\nFor a single shortest path I am using single_source_dijkstra\n```\nshortest_path = nx.single_source_dijkstra(G, source=s, target=t, weight=f)\n```\n\nI know that if I would add the weights as edge attributes, I could use all_shortest_paths\n```\nall_shortest_paths = nx.all_shortest_paths(G, source=s, target=t, weight='weight', method='dijkstra')\n```\n\nIs there a similar way of computing all shortest paths, where I don't have to add weight attributes to every edge and instead input a weight function f and get a list of (path_length, path)-tuples?\n    ", "Answer": "\r\nI think you have two easy to implement possibilities.\nA: Define a function, that returns the sepcific weights you to an edge, add as attribute to graph, then run the all_shortest_paths on the edge attributed you just created.\nB: Simply iterate over all nodes in the graph:\n```\nresults = []\nfor n1 in G.nodes():\n    for n2 in G.nodes():\n        shortest_path = nx.single_source_dijkstra(G, source=n1, target=n2, weight=f)\n        results.append(shortest_path)\n        \n```\n\nEDIT:\nYou can use\n```\nnx.all_shortest_paths = nx.all_shortest_paths(G, source=s, target=t, weight=cost_function, method='dijkstra')\n```\n\nwith a custom function.\nIt will correctly return all shortest paths based on your metric.\nBut be aware, as far as I understand the implementation in networkx, this will calculate the shortest paths for all nodes, then simply return as selection based on your source and target node.\nIt will not return you the path lenghts, as they are all the same...\nYou can get it out if you would have to...\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Seemingly correct BFS implementation finding paths, but not *shortest* paths (weightless edges)\r\n                \r\nBelow is an attempt at an algorithm to find shortest paths in a graph with weightless edges, with one added constrain: a set of nodes that cannot be in the path.  So instead of finding the absolute shortest path between nodes, it finds the shortest path that doesn't include certain nodes.  \n\nWordnode is the node class, and HashSet avoids is the set of nodes that must be avoided.  The only place in the algorithm where this comes into play is when checking whether to add a node to the queue.  If it's in avoids (or if it's already been visited), don't add it.  I believe the effect of this check should be equivalent to temporarily removing any edges into and out of nodes in avoids, though by using the HashSet I avoid actually mutating the data structure.\n\nI thought the algorithm was working until I managed to get shorter paths by adding words to avoids.  e.g., if avoids is empty, then for shortestPath(A, Z, {}) it might return (A, B, E, C, F, L, D, Z), but upon adding E and C to avoids and calling shortestPath(A, Z, {E, C}), I get (A, R, K, Z), which is shorter...  \n\nThe graph I'm using has thousands of nodes, but I have checked that both (A, B, E, C, F, L, D, Z) and (A, R, K, Z) are valid paths.  The problem is that the algorithm is returning a path of length 8 when avoids is empty, when there are demonstrably existent paths of length only 4.\n\nThis suggests to me that either my algorithm (below) is incorrect, or there are problems with my graph data structure.  It will be more difficult to check the latter, so I figured I would see if anyone spots a problem below first.\n\nSo, can you see any reason the algorithm below would find shorter paths when avoids is non-empty than when it's empty?\n\nNote: \"this\" is the origin, and the destination (\"dest\") is an argument.\n\nThanks\n\n```\npublic LinkedList<String> shortestPath(Wordnode dest, int limit, HashSet<Wordnode> avoids)\n{\n    HashSet<Wordnode> visited = new HashSet<>();\n    HashMap<Wordnode, Wordnode> previous = new HashMap<>();\n    LinkedList<Wordnode> q = new LinkedList<Wordnode>();\n    previous.put(this, null);\n    q.add(this);\n    Wordnode curr = null;\n    boolean found = false;\n    while(!q.isEmpty() && !found)\n    {\n        curr = q.removeLast();\n        visited.add(curr);\n        if(curr == dest)\n            found = true;\n        else\n        {\n            for(Wordnode n: curr.neighbors)\n            {\n                if(!visited.contains(n) && !avoids.contains(n))\n                {\n                    q.addFirst(n);\n                    previous.put(n, curr);\n                }\n            }\n        }\n    }\n    if(!found)\n        return null;\n    LinkedList<String> ret = new LinkedList<>();\n    while(curr != null)\n    {\n        ret.addFirst(curr.word);\n        curr = previous.get(curr);\n    }\n    return ret;\n}\n```\n\n    ", "Answer": "\r\nI think your problem is how you build the edge list using the ```\nprevious```\n map.  You store the last seen edge when queuing nodes, but this edge may not be lie on the shortest path.\n\nYou check for ```\ndest```\n when you pull it from the queue, but the edge stored in ```\nprevious```\n for the ```\ndest```\n node may no longer be the edge that was followed to get to ```\ndest```\n when it was added to the queue.\n\nWhen you provide ```\navoids```\n nodes you skip the process of updating the edges in ```\nprevious```\n so you may end up with a shorter path - it is not whether ```\navoids```\n is specified or not, but rather whether ```\navoids```\n contains nodes on the longer path that may 'corrupt' the edge list.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "A recursive DFS template to find the shortest path\r\n                \r\nI am learning DFS through dfs-template I - LeetCode\n\nIt introduced a recursion template \n\n```\n/*\n * Return true if there is a path from cur to target.\n */\nboolean DFS(Node cur, Node target, Set<Node> visited) {\n    return true if cur is target;\n    for (next : each neighbor of cur) {\n        if (next is not in visited) {\n            add next to visted;\n            return true if DFS(next, target, visited) == true;\n        }\n    }\n    return false;\n}\n```\n\n\nA question raised in the end\n\n\n  In the template above, we stop when we find the ```\nfirst```\n path.\n  \n  What if you want to find the ```\nshortest```\n path?\n  \n  Hint: Add one more parameter to indicate the shortest path you have already found.\n\n\nHow to find the shortest path?\n\nI assumed that a ```\nstep```\n parameter should be added to remember  ```\ndepth```\n of  each turn to traverse, after exhausted all all the possible paths, compare the depths and return the minimal.\n\nWhere is the parameter ```\nstep```\n  placed?\n    ", "Answer": "\r\n```\ndistances = new int[numberOfNodes];\nboolean DFS(Node cur, Node target, Set<Node> visited, level) {\n    for (next : each neighbor of cur) {\n        if (next is not in visited and level + 1 < distances[next]) {\n            distances[neighbor] = level + 1\n            add next to visted;\n            DFS(next, target, visited, level + 1)\n        }\n    }\n    return false;\n}\n```\n\n\nthe array distances will store shortest path for every node\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Find shortest path with relationships condition\r\n                \r\nI created a graph of bus stops interconnected by bus lines. Two stations can be connected by multiple lines. When searching for paths, I need to get paths with a minimum number of lines.\n\nThe relationships are coded like this:\n\n```\n(a)-[:CONNECTED_TO {line:lineid}]->(b)\n```\n\n\nI need to get the shortest paths between two nodes ordered by the number of different lineids. For example:\n\n```\npath 1 : (a)-[lineid1]->(b)-[lineid1]->(b)\npath 2 : (a)-[lineid1]->(b)-[lineid2]->(b)\n```\n\n\nThe first path must be ordered first because all of the stops are connected by the same line.\nTo choose between two paths,I have to pick the one with the minimum different lines but also with the minimum line transfer, for example:\n\n```\npath1 : 1-2-2-1-2-3\npath2 : 1-1-2-2-3-3\n```\n\n\nI have to pick the path2\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "The number of shortest path between two nodes [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                It's difficult to tell what is being asked here. This question is ambiguous, vague, incomplete, overly broad, or rhetorical and  cannot be reasonably answered in its current form. For help clarifying this question so that it can be reopened,  visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI use a two-dimensional array to store the distance of the network. ```\n1```\n indicates there is connection between two nodes, ```\n0```\n indicates there is no connection:\n\n```\n     A     B    C   D\n\nA    0     1    1   0   \n\nB    1     0    0   1 \n\nC    1     0    0   1\n\nD    0     1    1   0\n```\n\n\n.\n\nI want to use Java to find the number of shortest paths. For example, there are 2 paths from Node A to node D. Node B to node C also has 2 paths.\n    ", "Answer": "\r\nThe problem you have is called \"routefinding\" or \"pathfinding\". There are a lot of stock algorithms you can use to solve it. Like for example:\n\n\nDijkstras algorithm\nA* algorithm\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "R igraph: Fast shortest path\r\n                \r\nI'm writing a script to calculate shortest paths between 352k pairs of 983 nodes, for which I'm currently using igraph's shortest.paths function. It currently takes around 35 seconds, which isn't practical for my application - I'd ideally need it down to around 5 seconds but I'm not sure if this is feasible.\nThe main inefficiency of shortest.paths that I can think of is that it's calculating shortest paths for every single possible node pair (all 966k).\nDoes anyone know of a faster way of doing this (including any reasonable pre-processing I could do, or a way of getting the algorithm to only run on the node pairs I need it for?\nThanks\nExample\n```\nset.seed(1)\nnodes <- c(1:1000)\nedgelist <- expand.grid(nodes,nodes) %>%\n  mutate(weight = runif(nrow(.))) %>%\n  arrange(weight) %>%\n  slice(1:350000)\n\ngraph <- edgelist %>%\n  select(c(1,2)) %>%\n  as.matrix(.) %>%\n  graph_from_edgelist(., directed = F)\n\ngraph <- set.edge.attribute(graph, \"weight\", index=E(graph), edgelist$weight)\n\nstart <- Sys.time()\ns.paths <- shortest.paths(graph,\n                          algorithm = \"dijkstra\")\nSys.time() - start\n```\n\nRuntime: 18s\nIn this example, I only actually want the 350k node-pairs in the edgelist, but it's calculating all 1 million possible pairs. I can extract the ones I want easily, but I'm wondering whether I can get the run time down by somehow getting it to only calculate the distances for the pairs I actually need (or by any other means).\n    ", "Answer": "\r\nHere ```\nshortest.paths```\n is equivalent to ```\ndistances```\n, which yields a matrix (type ```\n?distances```\n to see the examples there)\nFor you solution, you could use ```\ndiag```\n like below to retrieve the three distances you are after:\n```\ndiag(s.paths)\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "bi-directional really gives shortest path?\r\n                \r\nI was told by the cracking interview book that bi-directional algorithm give shortest path between 2 points in graph.\nI don't get why it is guaranteed shortest path.  Doesn't collision point change depended on vertexs' queuing order during breadth-first search?\nthx\n    ", "Answer": "\r\n\nDoesn't collision point change depended on vertexs' queuing order during breadth-first search?\n\nYes, it does. However, whichever node ends up being chosen, it will connect one of the shortest paths between the source and target nodes.\nSo if there are multiple such choices, it can be through any of them depending on queueing order as you said. But you are guaranteed that the resulting path will be of the same optimal length.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Query shortest path with conditions on Orient-db\r\n                \r\nWe are working with OrientDB (V 2.2.30) and using ‘shortestPath’ function.\n\nWe want to get the shortest path between 2 vertices but only a path that applies to a condition on a specific field such as \"Status=Active\". \ni.e. if one of the items within the shortest path doesn't match to the condition \"Status=Active\", the whole path will not come as an output and we will get the \"next\" shortest path that matches to the condition.\nWe saw in the Orient documentation that there is an additionalParams parameter,\nBut the only parameter Currently allowed is 'maxDepth'.\n\nIs there any way we can get the shortest path with conditions?\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Optimizing search of all the shortest paths in a Graph with N vertices and N edges\r\n                \r\nI need to find the shortest paths between all pairs in a Graph ```\nG```\n. I'm using the Floyd–Warshall algorithm to compute the solution.\n\nI need to know if there is a better option to find all the shortest paths given these facts about ```\nG```\n:\n\n\n```\nG```\n is an undirected graph.\nThe numbers of vertices and the edges is the same.\nAll edge weights are positive.\n\n\nIs there a better solution than Floyd–Warshall given these facts?\n    ", "Answer": "\r\nThere is modification of Dijkstra Shortest Path algorithm for sparse graphs that works very fast and reveals log-linear (close to linear) asymptotic behavior. You need N searches from N vertices that gives O(N^2*LogN) asymptotic time that is better than O(N^3) Floyd–Warshall algorithm.\n\nProbably your graph has special topology that allows more efficient approaches...\n\nC++ code with Russian description (may be translated by Google Chrome)\n\nI have delphi implementation for grid graph here.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Number of shortest paths between two coordinate points in a graph with constraints\r\n                \r\nI have been given few coordinate points :\n\n\nsource ```\n(0,0)```\n\ndestination ```\n(m,n)```\n\na set of coordinate points ```\nS = {(x,y)```\n such that ```\n0 < x < m```\n and ```\n0 < y < n}```\n\n\n\nObjective is to find out the number of shortest paths between ```\n(0,0)```\n and ```\n(m,n)```\n such that any point in the set ```\nS```\n is never encountered in these paths. How do i find it?\n    ", "Answer": "\r\nHere you have a solution in C# but can converted easily to Java. Hopefully you will find it useful.\n\n```\nusing System;\nusing System.Collections.Generic;\nusing System.Drawing;\n\nnamespace Game\n{\n    class Program\n    {\n        /// <summary>\n        /// Find a matrix with all possible optimum paths from point A to point B\n        /// </summary>\n        /// <param name=\"rows\">Rows of the matrix</param>\n        /// <param name=\"cols\">Cols of the matrix</param>\n        /// <param name=\"points\">Obstacles location</param>\n        /// <param name=\"moves\">Allowed moves</param>\n        /// <param name=\"matrix\">Resulting matrix</param>\n        /// <param name=\"A\">Starting point</param>\n        /// <param name=\"B\">Ending point</param>\n        private static void FindMatrix(int rows, int cols, List<Point> points, List<Point> moves, out List<List<int>> matrix, out Point A, out Point B)\n        {\n            matrix = new List<List<int>>();\n            A = new Point(-1, -1);\n            B = new Point(-1, -1);\n            //Init values of the matrix\n            for (int row = 0; row <= rows; row++)\n            {\n                matrix.Add(new List<int>());\n                for (int col = 0; col <= cols; col++)\n                    matrix[matrix.Count - 1].Add(0);\n            }\n            var index = 0;\n            while ((index < points.Count) && (points[index].Y >= 0) && (points[index].Y <= rows) && (points[index].X >= 0) && (points[index].X <= cols))\n            {\n                matrix[points[index].Y][points[index].X] = -1;\n                index++;\n            }\n            if ((index == points.Count) && (matrix[0][0] == 0) && (matrix[rows][cols] == 0))\n            {\n                A.X = 0;\n                A.Y = 0;\n                B.X = cols;\n                B.Y = rows;\n            }\n            if ((A.X >= 0) && (A.Y >= 0) && (B.X >= 0) && (B.Y >= 0)) //To check if points A and B exist in the board\n            {\n                var pairs = new List<Point>[2] { new List<Point>(), new List<Point>() };\n                int level = 0;\n                index = 0;\n                pairs[index].Add(A);\n                while ((pairs[index].Count > 0) && (pairs[index][pairs[index].Count - 1] != B))\n                {\n                    pairs[Math.Abs(1 - index)].Clear();\n                    level++;\n                    foreach (var pair in pairs[index])\n                        foreach (var move in moves) //Test all possible moves\n                            if ((pair.Y + move.Y >= 0) && (pair.Y + move.Y < matrix.Count) && (pair.X + move.X >= 0) && (pair.X + move.X < matrix[pair.Y + move.Y].Count) && (matrix[pair.Y + move.Y][pair.X + move.X] == 0)) //Inside the boundaries? Not visited before?\n                            {\n                                pairs[Math.Abs(1 - index)].Add(new Point(pair.X + move.X, pair.Y + move.Y));\n                                matrix[pair.Y + move.Y][pair.X + move.X] = level;\n                            }\n                    index = Math.Abs(1 - index);\n                }\n                matrix[A.Y][A.X] = 0;\n            }\n        }\n\n        /// <summary>\n        /// Finds all possible optimum paths from point A to point B in a matix with obstacles\n        /// </summary>\n        /// <param name=\"matrix\">Matrix with obstacles</param>\n        /// <param name=\"moves\">Allowed moves</param>\n        /// <param name=\"A\">Starting point</param>\n        /// <param name=\"B\">Ending point</param>\n        /// <param name=\"result\">Resulting optimum paths</param>\n        /// <param name=\"list\">Temporary single optimum path</param>\n        private static void WalkMatrix(List<List<int>> matrix, List<Point> moves, Point A, Point B, ref List<List<Point>> result, ref List<Point> list)\n        {\n            if ((list.Count > 0) && (list[list.Count - 1] == B)) //Stop condition\n            {\n                result.Add(new List<Point>(list));\n            }\n            else\n            {\n                foreach (var move in moves)\n                    if ((A.Y + move.Y >= 0) && (A.Y + move.Y < matrix.Count) && (A.X + move.X >= 0) && (A.X + move.X < matrix[A.Y + move.Y].Count) && (matrix[A.Y + move.Y][A.X + move.X] == matrix[A.Y][A.X] + 1)) //Inside the boundaries? Next step?\n                    {\n                        list.Add(new Point(A.X + move.X, A.Y + move.Y)); //Store temporary cell\n                        WalkMatrix(matrix, moves, list[list.Count - 1], B, ref result, ref list);\n                        list.RemoveAt(list.Count - 1); //Clean temporary cell\n                    }\n            }\n        }\n\n        public static List<List<Point>> FindPaths(int rows, int cols, List<Point> points)\n        {\n            var result = new List<List<Point>>();\n            var moves = new List<Point> { new Point(1, 0), new Point(0, 1), new Point(-1, 0), new Point(0, -1) }; //Right, Down, Left, Up (clockwise)\n            List<List<int>> matrix; //Matrix temporary representation to store all possible optimum paths\n            Point A; //Starting point\n            Point B; //Ending point\n            FindMatrix(rows, cols, points, moves, out matrix, out A, out B);\n            if ((A.X >= 0) && (A.Y >= 0) && (B.X >= 0) && (B.Y >= 0)) //To check if points A and B exist\n            {\n                List<Point> list = new List<Point>();\n                list.Add(A);\n                WalkMatrix(matrix, moves, A, B, ref result, ref list);\n            }\n            return result;\n        }\n\n        static void Main(string[] args)\n        {\n            var points = new List<Point>\n            {\n                new Point(3, 2),\n                new Point(4, 2),\n                new Point(5, 2),\n                new Point(3, 3),\n                new Point(4, 3),\n                new Point(5, 3),\n                new Point(3, 4),\n                new Point(4, 4),\n                new Point(5, 4)\n            };\n            List<List<Point>> paths = FindPaths(5, 10, points); //path.Count store the quantity of optimum paths\n        }\n    }\n}\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "BFS reconstructing the path to get shortest path\r\n                \r\nI would like to construct a shortest path from a Breadth First Search. I have implemented the BFS in Java code (as shown below), but now I do not know how to reconstruct the path to get the shortest path from the implementation of the code. \n\nWhile I know I have to keep an array of parents, I do not know where to put it in my code. Basically, I would like to trace back the shortest path using BFS from the start point to goal point. Note that I am using a 2D array. \n\nAm I doing it correctly? Can someone please help me with that?\n\n```\npublic ArrayList<Point> shortestPath=new ArrayList<>();\npublic ArrayList<Point> BFS(Point start, Point end){\n   int[][] distanceBoard=new int[50][50]; Point current,parent;\n    for(int i=0;i<distanceBoard.length;i++)\n        for(int j=0;j<distanceBoard.length;j++) distanceBoard[i][j]=Integer.MAX_VALUE;\n    distanceBoard[start.getX()][start.getY()]=0;\n    LinkedList<Point> q=new LinkedList<>();\n    q.addFirst(start);\n    while(!q.isEmpty()){\n        current=q.getFirst();\n        if((new Point(current.getX(),current.getY()))==end) return shortestPath;\n        q.removeFirst();\n        for(Point point:current.getNeighbours()){\n            if(distanceBoard[point.getX()][point.getY()]==Integer.MAX_VALUE){\n                distanceBoard[point.getX()][point.getY()]=distanceBoard[current.getX()][current.getY()]+1;\n                parent=current;\n                q.addLast(point);\n            }\n            shortestPath.add(current);\n        }\n    }return null;\n}\n```\n\n    ", "Answer": "\r\nTo backtrack you can just use the parent of the destination point and continue until you reach the place you started... something like\n\n```\nArrayList < vertex > points = new ArrayList < > ();\nwhile ((current.x != startx) || (current.y != starty)) {\n  points.add(current);\n  current = current.parent;\n}\n```\n\n\nwhere ```\nstartx```\n and ```\nstarty```\n is the (x,y) position you start from in your grid. You want to do this after you have found the destination your looking for i.e. after you break out of the ```\nwhile(!q.isEmpty()){...}```\n. \n\n```\nwhile (!q.isEmpty()) {\n  current = q.dequeue();\n  if (current.x == targetx && current.y == targety) break; //quite when path is found\n  ...\n}\nArrayList < vertex > vertices = new ArrayList < > ();\nwhile ((current.x != startx) || (current.y != starty)) {\n  vertices.add(current);\n  current = current.parent;\n}\n```\n\n\nSo the ```\nparent```\n ```\nPoint```\n is a way of remembering where you came from and so if you have the destination ```\nPoint```\n then you should have the destination ```\nPoint```\n's ```\nparent```\n (or previous position) and once you have the destination ```\nPoint```\n's ```\nparent```\nyou want to find the destination ```\nPoint```\n's ```\nparent```\n ```\nparent```\n and so on until you have the ```\nPoint```\n you began the search at. I also, just to add to your confusion, made a mistake in the ```\nwhile ((current.x != startx)...)```\n so instead of it being ```\nwhile ((current.x != startx) && (current.y != starty))```\n i changed it to ```\nwhile ((current.x != startx) || (current.y != start))```\n  since you don't want to stop iterating when for example you have just the correct y-value, you want it to stop when both sides are false i.e. when both ```\ncurrent.x != startx```\n and ```\ncurrent.y != start```\n are false.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Neo4j: Shortest Path based on Property\r\n                \r\nSuppose I want to calculate the shortest path of a graph with Neo4j's built-in shortestPath algorithm. Is there a way to use the algorithm where the distance between nodes is encoded in a property of the relationship?\n\nWhat I mean, in case it is not clear is the following: my graph G consists of 3 vertices A, B, C and 3 edges:\n\n\nE1: (A)-->(B)\nE2: (A)-->(C)\nE3: (C)-->(B)\n\n\nIf I ask for the shortest path between A and B in this graph I get E1. However, if the \"distance\" properties of the edges are as follows, then I would want to get E2-E3 as the shortest path:\n\n\nE1: distance = 10\nE2: distance = 4\nE3: distance = 3\n\n\nIs this possible and if so how?\n    ", "Answer": "\r\nUse ```\ndijkstra```\n instead of ```\nshortestPath```\n, it allows you to specify a ```\ncost_property```\n. More info can be found here\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Find K-shortest Path in Orientdb\r\n                \r\nI am new to OrientDB and I am trying to find top k shortest path in my graph.So I am creating my algorithm by applying from Yen's algorithm but I do not know how to use it to work in OrientDB ,or is there another ways to find K-shortest path in Orient Graph?\nHow should I do ?\n\nThank for all helping :]\n    ", "Answer": "\r\nIf you already have the shortest path (only the shorter) could use directly the function present in OrientDB ShortestPath:\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Find k-shortest path in neo4j\r\n                \r\nI'm using  GraphAlgoFactory.shortestPath(PathExpander expander,int maxDepth,int maxHitCount)  to find the k-shortest path, but the problem, I don't get direct path between two nodes. For example, I have relationship like \n\n```\nn1--n2\nn1--n3\nn3--n2\n```\n\n\nIf I try to find the path between n1 and n2 I get only single path as n1--n3--n2, but actually, there are two paths one of which is a direct path from n1 to n2.\n\n```\nCustomPathExpander expander = toExpander(constraints, db, Collections.<FakeNode>emptyList());\n\nList<Path> result = new LinkedList<Path>();\nfor (Path path : GraphAlgoFactory.shortestPath(expander, 3, 3).findAllPaths(n1, n2)) \n{\nresult.add(path);\n}\n\n\nstatic CustomPathExpander toExpander(String constraints, FakeGraphDatabase db, Iterable<FakeNode> extraNodes) {\n    return toExpander(toMap(constraints), db, extraNodes);\n}\n\n\nstatic CustomPathExpander toExpander(Map<String,Object> c, FakeGraphDatabase db, Iterable<FakeNode> extraNodes) {\n    Map<String,String> directions = (Map<String, String>) (c == null ? null : c.get(\"dir\"));\n    Map<String,Object> constraints = (Map<String, Object>) (c == null ? null : c.get(\"c\"));\n    Map<String,Object> inline = (Map<String,Object>)(c == null ? null : c.get(\"inline\"));\n\n    DirectionContraints d = new DirectionContraints(directions);\n    IPathConstraint path = PathConstraints.parse(constraints);\n    InlineRelationships rel = InlineRelationships.of(inline, db);\n\n    return new CustomPathExpander(d, path, rel, extraNodes, c != null && c.get(\"acyclic\") == Boolean.TRUE);\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Java shortest path\r\n                \r\nI'm trying to make an small tower defender game in Java. I have a grid that is made up of a ```\nPoint2D.Double```\n array named: \n\nFieldArr[h][v]\n\n```\nh```\n represents horizontal fields, ```\nv```\n the vertical vertical fields\n\nthis makes a grid like this\n\n```\n+ + + + + + +\nS + X + + + +\n+ + + X + + +\n+ X + + + + F\n+ + X + + + +\n```\n\n\nS represents start, F represents Finish, X represents Towers\n\nnow I want to calculate the shortest route for but i don't have any clue how to start on this\n\nTowers have the following vars for location:\nHorizontalNr and VerticalNr.\n\nfor paint I do then:\n\n```\npublic void paint(Graphics2D g2) {\n    int Xpos = HorizontalNr * playfield.getSquarewidth() + playfield.GetinitialXPos();\n    int Ypos = VerticalNr * playfield.getSquarewidth() + playfield.GetinitialYPos();\n    g2.fillRect(Xpos, Ypos, 50, 50);\n}\n```\n\n\nAnyone have any tips, on how I should make my enemy class, so I won't get in any problem with the algorithm?\nand/or have tips on how to calculate the shortest path?\n\nalready thanks\ngrt kiwi\n    ", "Answer": "\r\nThe shortest path problem has been studied a lot and a lot of literature exists on this problem. It's probably best to just using an existing algorithm rather than trying to invent an algorithm yourself.\n\nFor example, a simple and efficient algorithm is Dijkstra's algorithm. From Wikipedia:\n\n\n  \n  Let the node at which we are starting be called the initial node. Let the distance of node Y be the distance from the initial node to Y. Dijkstra's algorithm will assign some initial distance values and will try to improve them step by step.\n  Assign to every node a tentative distance value: set it to zero for our initial node and to infinity for all other nodes.\n  Mark all nodes unvisited. Set the initial node as current. Create a set of the unvisited nodes called the unvisited set consisting of all the nodes except the initial node.\n  For the current node, consider all of its unvisited neighbors and calculate their tentative distances. For example, if the current node A is marked with a tentative distance of 6, and the edge connecting it with a neighbor B has length 2, then the distance to B (through A) will be 6+2=8. If this distance is less than the previously recorded tentative distance of B, then overwrite that distance. Even though a neighbor has been examined, it is not marked as visited at this time, and it remains in the unvisited set.\n  When we are done considering all of the neighbors of the current node, mark the current node as visited and remove it from the unvisited set. A visited node will never be checked again; its distance recorded now is final and minimal.\n  If the destination node has been marked visited (when planning a route between two specific nodes) or if the smallest tentative distance among the nodes in the unvisited set is infinity (when planning a complete traversal), then stop. The algorithm has finished.\n  Set the unvisited node marked with the smallest tentative distance as the next \"current node\" and go back to step 3.\n  \n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "maximum flow algorithm of shortest path?\r\n                \r\nIs there some resources on such algorithm?\n\nI have an unweighted graph (with all edges to one capacity more precisely), and I want to find all the distinct paths between a source and sink vertex(all the paths possible with no one sharing a vertex with another), so I've thought of max-flow problem and algo, but the problem is that I would like to have an algo which permits me to have all the Shortest distinct paths.\n\nSince the max flow algo are just searching with a BFS or something in the residual graph, it will increase randomly my flow( because of the weighting of one, each iteration of a max flow algo will increase my flow of one, which correspond to finding a new distinct path) and i will end up with the maximum number of distinct paths, but I could not end up with the maximum number of distinct shortest paths.\n    ", "Answer": "\r\nTo get the maximum amount of shortest paths, how about: \n\n\nFirst do a BFS and assign a number to each node, which would\ndenote the distance from the source. \nThen remove all edges between the nodes that have the same number\nDirect the edges, so no flow could move back from higher value nodes to lower value nodes\nRun max flow from source to sink.\n\n\nSince there is no other option, max flow would always have to only go one step closer to the sink in regards to the shortest path. There could not be any shortest path which is impossible to find after the changes, because any shortest path would have to increase it's next node's value in each step, otherwise there would be another path that was shorter.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path in a grid\r\n                \r\nI have a two dimensional matrix like\n\n```\nA......... \n##....##..\n.####...##\n..........\n.......###\nB.........\n####...### \n#...#.###.\n```\n\n\nWhere  '.'  represents path and '#' represents wall.I have to find the shortest path possible from point A to point B.I am familiar with BFS algorithm and it seems like a reasonable algorithm for the problem. But I find it confusing to apply on the grid.Can anyone suggest implementation of BFS algorithm in this problem with some pseudo-codes ?\n    ", "Answer": "\r\nThe BFS algorithms is basically:\n\n1.Enqueue the source vertex and mark it visited.\n\n2.While the Q is not empty repeat 3 and 4.\n\n3. Perform  deque and the for the dequed vertex x, do\n\n4. For all adjacent vertices of x, that are not visited and mark them visited and enqueue them to the Q. \n\nSo thats the basic algorithm, if we go step by step its very easy to apply these steps to grid,the only thing that we should be careful is for a cell in a grid there are 8 neighbours possible, and we must check the boundary conditions before traversing the neighbours, to avoid array index out of bounds.\n\nSay we are at position ```\nA(a,b)```\n and we want to reach ```\nB(c,d)```\n. We follow the similar 4 steps but with some modification as follows:\n\n1.Make a Q of 2-d points,(You can do that easily in languages like Java, by making a class of 2-d points and then Q of objects of that class)\n\n2.Make a 2-d array ```\nvisited```\n of size of grid of type boolean, initialized to false.\n\n3.Make a 2-d array ```\ndistance```\n of size of grid of type integer, that will be used for the distance.\n\nLet size of grid be ```\nnxm```\n\n\nNow the pseudocode is as follows:\n\n```\nEnqueue A(a,b) to the Q\n\nMark dist[a][b] = 0 and visited[a][b] = true\n\nwhile( Q is not empty )\n{\n Point p = deque(Q)\n\n if( p matches B(c,d) )\n {\n   print( Yes path is possible from A to B with distance[c][d] )\n   return\n }\n else\n {\n  //Now all we have to do is check all the possible neighbour cells according\n  // to our current position in the grid\n  // So we have to check all the 8 neighbour cells\n   if(p.y < m - 1)\n   {\n    if( grid[p.x][p.y + 1] != '#' and visited[p.x][p.y + 1] == false )\n    {\n     enqueue (p.x,p.y + 1) to the Q // step s1\n     distance[p.x][p.y + 1] = distance[p.x][p.y] + 1 // step s2\n     visited[p.x][p.y + 1] = true // step s3\n    }\n   }\n   if(p.x < n - 1)\n   {\n    if( grid[p.x + 1][p.y] != '#' and visited[p.x + 1][p.y] == false )\n    {\n     Repeat steps s1,s2,s3 for point (p.x + 1,p.y)\n    }\n   }\n   if(p.y > 0)\n   {\n    if( grid[p.x][p.y - 1] != '#' and visited[p.x][p.y - 1] == false )\n    {\n     Repeat steps s1,s2,s3 for point (p.x,p.y - 1)\n    }\n   }\n   if(p.x > 0)\n   {\n    if( grid[p.x - 1][p.y] != '#' and visited[p.x - 1][p.y] == false )\n    {\n     Repeat steps s1,s2,s3 for point (p.x - 1,p.y)\n    }\n   }\n   if(p.x > 0 and p.y > 0)\n   {\n    if( grid[p.x - 1][p.y - 1] != '#' and visited[p.x - 1][p.y - 1] == false )\n    {\n     Repeat steps s1,s2,s3 for point (p.x - 1,p.y - 1)\n    }\n   }\n   if(p.x > 0 and p.y < m-1)\n   {\n    if( grid[p.x - 1][p.y + 1] != '#' and visited[p.x - 1][p.y + 1] == false )\n    {\n     Repeat steps s1,s2,s3 for point (p.x - 1,p.y + 1)\n    }\n   }\n   if(p.x < n-1 and p.y > 0)\n   {\n    if( grid[p.x + 1][p.y - 1] != '#' and visited[p.x + 1][p.y - 1] == false )\n    {\n     Repeat steps s1,s2,s3 for point (p.x + 1,p.y - 1)\n    }\n   }\n   if(p.x < n-1 and p.y < m-1)\n   {\n    if( grid[p.x + 1][p.y + 1] != '#' and visited[p.x + 1][p.y + 1] == false )\n    {\n     Repeat steps s1,s2,s3 for point (p.x + 1,p.y + 1)\n    }\n   }\n }     \n}\nprint( the path is not possible )\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Networkx shortest paths for two point layers\r\n                \r\nI have a task to know the best way from houses to subway station.\n\n\n\nThere are three types of data on a picture below:\n\n\norange dots are the entrances to subway stations\nviolet dots are centerspoints of houses\nblue lines is a road network (let it firstly contain all types of\nroad data)\n\n\nThe goal is to determine the shortest path from every house point to the closest subway entry and build a polyline layer.\nI was thinking of using ```\narcpy```\n library for that but recently heard about ```\nnetworkx```\n module, but right now I know only how to load data in graph, however, I cannot figure out how to look for desirable shortest path and what to do next in general.\n\nHere is my draft for loading data to nx.Multigraph():\n\n```\nimport arcpy\nimport networkx as nx \nimport numpy as np\n\nline_fc = 'lines'\npoints_hs = 'house_points'\n\ngraph = nx.MultiGraph()\nwith arcpy.da.SearchCursor(line_fc, 'SHAPE@') as sc:\n    for row in sc:\n        line_geom = row[0].getPart(0)\n        list_geom_cors = np.array([(n.X, n.Y) for n in line_geom])\n        graph.add_edges_from(list_geom_cors)\n\nwith arcpy.da.SearchCursor(points_hs, 'SHAPE@XY') as sc:\n    for row in sc:\n        graph.add_node(row[0])\n```\n\n\nHow to perform this task as correctly as possible?\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How can I find the number of distinct shortest paths in undirected graph in linear time?\r\n                \r\nGiven an undirected path, what is an algorithm that number of distinct shortest paths, after inputing the start node u and end node v? The algorithm can depend on |V| and |E|, but must be linear in terms of each one.\nA proof that it actually returns the number of distinct shortest paths for any u and v would also be helpful.\n    ", "Answer": "\r\nI think something like this is what you're looking for:\nNote: Graph is stored as an adjacency list\n```\npublic int shortestPath(int u, int v, ArrayList<Integer>[] adj) {\n    Queue<Integer> bfs = new ArrayDeque();\n    bfs.add(u);\n\n    int ret = 0;\n\n    boolean[] visited = new boolean[adj.length];\n\n    while (!bfs.isEmpty() && (ret == 0 || bfs.peek() == v)) {\n        int node = bfs.poll();\n        visited[node] = true;\n\n        if (node == v) {\n            ret++;\n        }\n\n        for (int next : adj[node]) {\n            if (!visited[next]) {\n                bfs.add(next);\n            }\n        }\n    }\n    return ret;\n}\n```\n\nThe ideas are in the comments, but essentially you're running a bfs, and tracking how many paths visit v when the first path visits v. Notice how I set the node as visited only after I polled it from the queue, which is needed to count the number of paths.\nLet me know if you're still confused\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "print shortest path in terminal [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 7 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\ni have this python code to calculate Dijkstra algorithm. How can i print the shortest path in terminal (ubuntu)? I tried some print functions but they raised a different kinds of exceptions...\nThanks in advance!\n\n```\nclass Graph(object):\n\"\"\"\nA simple undirected, weighted graph\n\"\"\"\n   def __init__(self):\n       self.nodes = set()\n       self.edges = {}\n       self.distances = {}\n\n   def add_node(self, value):\n       self.nodes.add(value)\n\n   def add_edge(self, from_node, to_node, distance):\n       self._add_edge(from_node, to_node, distance)\n       self._add_edge(to_node, from_node, distance)\n\n   def _add_edge(self, from_node, to_node, distance):\n       self.edges.setdefault(from_node, [])\n       self.edges[from_node].append(to_node)\n       self.distances[(from_node, to_node)] = distance\n\n\ndef dijkstra(graph, initial_node):\n    visited = {initial_node: 0}\n    current_node = initial_node\n    path = {}\n\n    nodes = set(graph.nodes)\n\n    while nodes:\n        min_node = None\n        for node in nodes:\n            if node in visited:\n                if min_node is None:\n                    min_node = node\n                elif visited[node] < visited[min_node]:\n                    min_node = node\n\n        if min_node is None:\n            break\n\n        nodes.remove(min_node)\n        cur_wt = visited[min_node]\n\n        for edge in graph.edges[min_node]:\n            wt = cur_wt + graph.distances[(min_node, edge)]\n            if edge not in visited or wt < visited[edge]:\n                visited[edge] = wt\n                path[edge] = min_node\n\n    return visited, path\n\ndef route(graph, x, y):\n    distances, paths = dijkstra(graph, x)\n    route = [y]\n\n    while y != x:\n        route.append(paths[y])\n        y = paths[y]\n\n    route.reverse()\n    return route\n\n\n\nif __name__ == '__main__':\n    g = Graph()\n    g.nodes = set(range(1, 7))\n    g.add_edge(1, 2, 7)\n    g.add_edge(1, 3, 9)\n    g.add_edge(1, 6, 14)\n    g.add_edge(2, 3, 10)\n    g.add_edge(2, 4, 15)\n    g.add_edge(3, 4, 11)\n    g.add_edge(3, 6, 2)\n    g.add_edge(4, 5, 6)\n    g.add_edge(5, 6, 9)\n    assert route(g, 1, 5) == [1, 3, 6, 5]\n    assert route(g, 5, 1) == [5, 6, 3, 1]\n    assert route(g, 2, 5) == [2, 3, 6, 5]\n    assert route(g, 1, 4) == [1, 3, 4]\n```\n\n    ", "Answer": "\r\nVisualize resulting path:\n\n```\ndef print_route(graph, x, y):\n  r = route(graph, x, y)\n  prmpt = ['({})'.format(x)]\n  for y in r[1:]:\n    d = graph.distances.get((x, y))\n    prmpt.append(' --{}-> ({})'.format(d,y))\n    x = y\n  print(''.join(prmpt))\n```\n\n\noutput for shortest path between nodes 1 and 5:\n\n```\n(1) --9-> (3) --2-> (6) --9-> (5)\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Find a shortest path with some conditions\r\n                \r\nLet me introduce the problem :\n\nYou have a QR code (the QR code is always a square in this problem) like this one.\none http://img11.hostingpics.net/pics/514457code.png\nYou can start anywhere in the top of the QR code (so anywhere in the first line) and you have to find a path to reach a case anywhere in the bottom line (so anywhere in the last line).\n\nYou have to minimize the number of black cases in the path, and if you have several paths with the same number of black cases, you have to find the shortest one.\n\nExample of solution :\n\nFind an algorithm to find the shortest path with those conditions.\n\nMy Solution\n\nFirst, I consider the problem as a directed grid graph, where each pixel is a vertex, and each vertex has as many edges as neighbors.\n\nSo for example, the vertex at the top left can reach its right neighbor and its bottom neighbor.\n\nI attribute the weight of the edge as follow :\n\n\nFor an edge going from a white case to a black one -> weight of 1\nFor an edge going from a white case to a white one -> weight of 0 + a small value \nFor an edge going from a black case to a white one -> wieght of 0 + a small value\nFor an edge going from a black case to a black one -> weight of 1\n\n\nA small value (<<1) is here to find the shortest path in the case where we have several paths with the same number of black cases.\n\nSo with this representation, let V be the number of vertices, W the number of vertices in a line and E the number of edges, we have E = W(W-1)*2*2.\n\nThen I create 2 subsets : the first one contains all the possible starting vertex (first line of the QR code, so W vertices) and another one with the possible final destination(last line and so W vertices).\n\nI use Dijkstra to compute the shortest path in O(V lg(V)) (with the library I use) and I do it W times for all the starting nodes and I look for the shortest path to each destination vertex. \n\nSo I find the shortest path in O(V*W lg(V)) = O(V^3/2 Lg(V)).\n\nQuestion\n\nDo you have a better solution to this problem ? With a grid graph representation or whatever ?\n    ", "Answer": "\r\nHere is a faster solution:\n\n\nLet's find paths that contain the smallest number of black cells. We can use 0-1 breadth-first search. An edge that leads to a white cell should have a weight ```\n0```\n and an edge that leads to a black cell should have a weight ```\n1```\n. There is no need to run it from each of the vertices in the top row separately: we can add them all to the queue in the beginning and then run a breadth-first search only once(we should not forget to add all white cells from the first line before the black ones).\nLet's call a directed edge from ```\nu```\n to ```\nv```\n good if ```\ndist[v] == dist[u] + weight(u, v)```\n. Now we can run a simple breadth first search(again, from all cells of the top row in a batch) on a graph that contains only \"good\" edges(this time all edges have weight ```\n1```\n). \nNow we can just choose the best cell from the last row.\n\n\nThis solution requires ```\nO(V)```\n time(its just two breadth-first searches) and it always produces an optimal answer(no small magic numbers are required). \n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Constrained shortest path in LEMON C++\r\n                \r\nI have a simple example of graph:\n```\nListDigraph g;\nListDigraph::ArcMap<int> length(g);\nListDigraph::ArcMap<string> color(g);\nbuild_graph(g, length, color); // function building the graph\n```\n\nThe map ```\nlength```\n contains the weights of the graph, while the map ```\ncolor```\n contains the color of the arcs.\nI would like to solve shortest path using Dijkstra, but in a constrained way: for example, I want to avoid two consecutive red arcs in the path.\nDijkstra in LEMON can be called simply by:\n```\nDijkstra<ListDigraph, ListDigraph::ArcMap> dijkstra_test(g,length);\ndijkstra_test.run(s);\n```\n\nHow can I add a constrain the shortest path computation ?\n    ", "Answer": "\r\nUse a modified BFS to search through all paths between start and end.  Stop the search when a path is found that meets the constraints.\n\nStart by putting the start vertex on top of a stack.\nLOOP\n\nIF stack empty\n\nOutput 'NO PATH' and STOP\n\n\nTake the top vertex off the stack and add it to the visited list and the current path\nAdd adjacent vertices which aren't in the visited list to the top of the stack.\nIF the destination has been reached\n\nIF current path meets constraints\n\nOutput path and STOP\n\n\nAdd current path to output\nBacktrack along path to vertex adjacent to vertex on top of stack, marking vertices as unvisited\n\n\n\n\n\nNotice that this does not give the shortest path that meets the constraints.  If you need that, then the search must continue until exhaustion, replacing the path to be output whenever a shorter one is found that meets the constraints.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Maze solve and shortest path with Java BFS [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 5 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nThe goal is to draw a maze after resolving it (using BFS) with the shortest path from start to exit.\n\nOUTPUT must be like this\n\n```\n***************************************************\n[20,19]\n***************************************************\n#####################\n..#...........#.....#\n#.#.#########.#.###.#\n#...#.........#.#...#\n###############.#.###\n#.....#.......#.#...#\n#.#######.###.#.#.#.#\n#...#...#...#...#.#.#\n###.###.###.###.#.#.#\n#.#.#.#...#.#...#.#.#\n#.#.#.#.#1#.#.###.#.#\n#...#.#.#1#.#...#.#.#\n#####.###1#.#####.###\n#.#1111111#.#...#...#\n#.#1#######.#.#.###.#\n#.#1#...#...#.#.#...#\n#.#1###.#.#####.#####\n#.#11111111111111111#\n#.##.####.#########1#\n#..................11\n#####################\n```\n\n\nThere are many path to go to the exit [20,19] , but we must draw with the shortest path.\n\nMy code is below but it doesn't print the shortest path.\n\nCODE\n\n```\nclass Maze {\n\n    public static void main(String args[]) {\n        int W = 21;\n        int H = 21;\n        int X = 9;\n        int Y = 10;\n        String[] mazeString = {\n            \"##########.##########\",\n            \"..#...........#.....#\",\n            \"#.#.#########.#.###.#\",\n            \"#...#.........#.#...#\",\n            \"###############.#.###\",\n            \"#.....#.......#.#...#\",\n            \"#.#######.###.#.#.#.#\",\n            \"#...#...#...#...#.#..\",\n            \"###.###.###.###.#.#.#\",\n            \"#.#.#.#...#.#...#.#.#\",\n            \"#.#.#.#.#.#.#.###.#.#\",\n            \"#...#.#.#.#.#...#.#.#\",\n            \"#####.###.#.#####.###\",\n            \"#.#.......#.#...#...#\",\n            \"#.#.#######.#.#.###.#\",\n            \"#.#.#...#...#.#.#...#\",\n            \"#.#.###.#.#####.#####\",\n            \"#.#.................#\",\n            \"#.##.####.#########.#\",\n            \"#.........#..........\",\n            \"####.######.#########\"\n        };\n        Node[][] nodes = new Node[W][H];\n        Node start = null;\n        List<Node> result = new ArrayList<>();\n        Boolean[][] visited = new Boolean[W][H];\n        Boolean[][] blocked = new Boolean[W][H];\n        Boolean[][] exits = new Boolean[W][H];\n        for (int i = 0; i < H; i++) {\n            String R = mazeString[i];\n            for (int j = 0; j < W; j++) {\n                Node node = new Node(j, i);\n                blocked[j][i] = R.charAt(j) == '#';\n                node.blocked = R.charAt(j) == '#';\n                exits[j][i] = (!node.blocked) && (i == (H - 1) || j == (W - 1) || i == 0 || j == 0);\n                visited[j][i] = false;\n                node.exit = (!node.blocked) && (i == (H - 1) || j == (W - 1) || i == 0 || j == 0);\n                nodes[j][i] = node;\n                if (X == j && Y == i) {\n                    start = nodes[j][i];\n                }\n            }\n        }\n        List<List<Node>> paths = new ArrayList<>();\n        findExits(start, nodes, visited, W, H, result, paths);\n        if (!result.isEmpty()) {\n            Collections.sort(result, new Comparator<Node>() {\n                @Override\n                public int compare(Node o1, Node o2) {\n                    if (Integer.compare(o1.x, o2.x) == 0) {\n                        return Integer.compare(o1.y, o2.y);\n                    } else {\n                        return Integer.compare(o1.x, o2.x);\n                    }\n                }\n            });\n        }\n        for (List<Node> path : paths) {\n            System.out.println(\"***************************************************\");\n            System.out.println(\"[\" + path.get(0).x + \",\" + path.get(0).y + \"]\");\n            System.out.println(\"***************************************************\");\n            for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                    String s = blocked[j][i] ? \"#\" : path.contains(new Node(j, i)) ? \"1\" : \".\";\n                    System.out.print(s);\n                }\n                System.out.println(\"\");\n            }\n        }\n    }\n\n    public static void findExits(Node start, Node[][] nodes, Boolean[][] visited, int W, int H, List<Node> result, List<List<Node>> paths) {\n        int x = start.x;\n        int y = start.y;\n        visited[x][y] = true;\n        if (start.exit) {\n            result.add(start);\n            visited[x][y] = false;\n            List<Node> path = new ArrayList<Node>();\n            while (start.parent != null) {\n                path.add(start);\n                start = start.parent;\n            }\n            path.add(start);\n            paths.add(path);\n        }\n        //TOP\n        if ((y - 1) >= 0) {\n            if (!visited[x][y - 1] && (!nodes[x][y - 1].blocked)) {\n                nodes[x][y - 1].parent = start;\n                findExits(nodes[x][y - 1], nodes, visited, W, H, result, paths);\n            }\n        }\n        //BOT\n        if ((y + 1) < H) {\n            if (!visited[x][y + 1] && (!nodes[x][y + 1].blocked)) {\n                nodes[x][y + 1].parent = start;\n                findExits(nodes[x][y + 1], nodes, visited, W, H, result, paths);\n            }\n        }\n        //LEFT\n        if ((x - 1) >= 0) {\n            if (!visited[x - 1][y] && (!nodes[x - 1][y].blocked)) {\n                nodes[x - 1][y].parent = start;\n                findExits(nodes[x - 1][y], nodes, visited, W, H, result, paths);\n            }\n        }\n        //RIGHT\n        if ((x + 1) < W) {\n            if (!visited[x + 1][y] && (!nodes[x + 1][y].blocked)) {\n                nodes[x + 1][y].parent = start;\n                findExits(nodes[x + 1][y], nodes, visited, W, H, result, paths);\n            }\n        }\n    }\n\n    public static class Node {\n\n        public int x, y;\n        boolean blocked = false;\n        boolean exit = false;\n        Node parent = null;\n\n        public Node(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            final Node other = (Node) obj;\n            if (this.x != other.x) {\n                return false;\n            }\n            if (this.y != other.y) {\n                return false;\n            }\n            return true;\n        }\n\n    }\n}\n```\n\n\nI want to solve a maze and print the shortest path from start to exit usign BFS. I already solve the maze but my code doesnt print the shortest path, this is my problem.\n\nNB (Additional informations, not questions) :\n\n\nthe maze can have many exit\nW (width), H (height), [X,Y] (start point)\n'#' (blocked cell), '.' (free cell)\nthe path from start and exit is represented by '11111...' on the output\n\n    ", "Answer": "\r\nPlease review the following code. It lets you printout all paths found, as well as the shortest one found. \nI did not change nor checked the search algorithm. I think it needs more work because I think it does not find the shortest path possible to each exit. I will look into it later. \nI did not figure out yet what is the use of ```\nList<Node> result```\n. Also I did not see you implement backtracking. \n\n```\nclass Maze {\n\n    private static char NUMBER_SIGN = '#', DOT = '.', START = 'S';\n    private static char EXIT = 'E', PATH = '1';\n    private static Node[][] nodes;\n    private static Node start;\n    private static boolean[][] visited; //no need to use Boolean\n    //exit holds the same information as Node.blocked. No need to duplicate\n    //private static boolean[][] blocked;\n    //exit holds the same information as Node.exit. No need to duplicate\n    //private static boolean[][] exits;\n\n    private static int mazeWidth, mazeHeight, startH, startW; //use meaningful names\n    private static List<List<Node>> paths;\n\n    public static void main(String args[]) {\n\n        mazeWidth = 21;//use meaningful names\n        mazeHeight = 21;\n        startH = 9; startW = 10;\n\n        String[] mazeData = getMazeData()  ;\n        makeMaze(mazeData);\n        drawMaze(); //draw maze as built from input data\n\n        List<Node> result = new ArrayList<>();\n        paths = new ArrayList<>();\n\n        findExits(start, nodes, visited, mazeWidth, mazeHeight, result, paths);\n\n        if (!result.isEmpty()) {\n            Collections.sort(result, new Comparator<Node>() {\n                @Override\n                public int compare(Node o1, Node o2) {\n                    if (Integer.compare(o1.x, o2.x) == 0) {\n                        return Integer.compare(o1.y, o2.y);\n                    } else {\n                        return Integer.compare(o1.x, o2.x);\n                    }\n                }\n            });\n        }\n        drawAllPaths(); // see all paths found\n        List<Node> shortestPath = getShortestPath();\n        drawShortestPath(shortestPath);\n    }\n\n    private static void drawMaze() {\n\n        System.out.println(\"***************************************************\");\n        System.out.println(\"Maze as defined by input\");\n        System.out.println(\"***************************************************\");\n        drawMaze(null);\n    }\n\n    private static void drawAllPaths() {\n\n        for (List<Node> path : paths) {\n            System.out.println(\"***************************************************\");\n            System.out.println(\"Path to exit [\"\n            + path.get(0).x + \",\" + path.get(0).y + \"] length:\"+ path.size());\n            System.out.println(\"***************************************************\");\n            drawMaze(path);\n        }\n    }\n\n    private static void drawShortestPath(List<Node> path) {\n\n        System.out.println(\"***************************************************\");\n        System.out.println(\"Shortest path is to exit [\"\n        + path.get(0).x + \",\" + path.get(0).y + \"] length:\"+ path.size());\n        System.out.println(\"***************************************************\");\n        drawMaze(path);\n    }\n\n    private static void drawMaze(List<Node> path) {\n\n        for(Node[] row : nodes ) {\n\n            for(Node node : row) {\n\n                char c = node.getGraphics();\n                if ((path != null) && path.contains(node)) {c = PATH;}\n                System.out.print(c);\n            }\n            System.out.println(\"\");\n        }\n    }\n\n    private static void makeMaze(String[] mazeData) {\n\n        nodes = new Node[mazeHeight][mazeWidth];\n        visited = new boolean[mazeHeight][mazeWidth];\n\n        for (int height = 0; height < mazeHeight; height++) {\n            String row = mazeData[height];\n            for (int width = 0; width < mazeWidth; width++) {\n                Node node = new Node(height, width);\n                node.blocked = row.charAt(width) == NUMBER_SIGN;\n                visited[width][height] = false;\n                node.exit = (!node.blocked) && ((height == (mazeHeight - 1)) ||\n                                (width == (mazeWidth - 1)) || (height == 0) || (width == 0));\n                nodes[height][width] = node;\n            }\n        }\n        start = nodes[startH][startW];//no need to set it in the loop\n    }\n\n    //use boolean instead of Boolean\n    private static void findExits(Node start, Node[][] nodes,\n            boolean[][] visited, int W, int H, List<Node> result, List<List<Node>> paths) {\n\n        int x = start.x;\n        int y = start.y;\n        visited[x][y] = true;\n        if (start.exit) {\n            result.add(start);\n            visited[x][y] = false;\n            List<Node> path = new ArrayList<>();\n            while (start.parent != null) {\n                path.add(start);\n                start = start.parent;\n            }\n            path.add(start);\n            paths.add(path);\n        }\n        //TOP\n        if ((y - 1) >= 0) {\n            if (!visited[x][y - 1] && (!nodes[x][y - 1].blocked)) {\n                nodes[x][y - 1].parent = start;\n                findExits(nodes[x][y - 1], nodes, visited, W, H, result, paths);\n            }\n        }\n        //BOT\n        if ((y + 1) < H) {\n            if (!visited[x][y + 1] && (!nodes[x][y + 1].blocked)) {\n                nodes[x][y + 1].parent = start;\n                findExits(nodes[x][y + 1], nodes, visited, W, H, result, paths);\n            }\n        }\n        //LEFT\n        if ((x - 1) >= 0) {\n            if (!visited[x - 1][y] && (!nodes[x - 1][y].blocked)) {\n                nodes[x - 1][y].parent = start;\n                findExits(nodes[x - 1][y], nodes, visited, W, H, result, paths);\n            }\n        }\n        //RIGHT\n        if ((x + 1) < W) {\n            if (!visited[x + 1][y] && (!nodes[x + 1][y].blocked)) {\n                nodes[x + 1][y].parent = start;\n                findExits(nodes[x + 1][y], nodes, visited, W, H, result, paths);\n            }\n        }\n    }\n\n    public static class Node {\n\n        public int x, y;\n        boolean blocked = false;\n        boolean exit = false;\n        Node parent = null;\n\n        public Node(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            final Node other = (Node) obj;\n            if (x != other.x) {\n                return false;\n            }\n            if (y != other.y) {\n                return false;\n            }\n            return true;\n        }\n\n        //it is simpler to have Node return its graphic representation\n        char getGraphics() {\n\n            char c = blocked ? NUMBER_SIGN : DOT;\n            if(equals(start)) { c=START;}\n            else if (exit) { c=EXIT;}\n\n            return c;\n        }\n    }\n\n    private static List<Node> getShortestPath() {\n        //initialize with an arbitrary path\n        List<Node> shortest = paths.get(0);\n        for (List<Node> path : paths) {\n            if(path.size() < shortest.size()) {\n                shortest = path;\n            }\n        }\n        return shortest;\n    }\n\n    private static String[] getMazeData() {\n\n        return  new String[] {\n                \"##########.##########\",\n                \"..#...........#.....#\",\n                \"#.#.#########.#.###.#\",\n                \"#...#.........#.#...#\",\n                \"###############.#.###\",\n                \"#.....#.......#.#...#\",\n                \"#.#######.###.#.#.#.#\",\n                \"#...#...#...#...#.#..\",\n                \"###.###.###.###.#.#.#\",\n                \"#.#.#.#...#.#...#.#.#\",\n                \"#.#.#.#.#.#.#.###.#.#\",\n                \"#...#.#.#.#.#...#.#.#\",\n                \"#####.###.#.#####.###\",\n                \"#.#.......#.#...#...#\",\n                \"#.#.#######.#.#.###.#\",\n                \"#.#.#...#...#.#.#...#\",\n                \"#.#.###.#.#####.#####\",\n                \"#.#.................#\",\n                \"#.##.####.#########.#\",\n                \"#.........#..........\",\n                \"####.######.#########\"\n                };\n    }\n}\n```\n\n\nEDIT\nAn improved version. Please test carefully. \n\n```\nclass Maze {\n\n    private static char NUMBER_SIGN = '#', DOT = '.', START = 'S';\n    private static char EXIT = 'E', PATH = '1';\n    private static Node[][] nodes;\n    private static Node startNode;\n    private static boolean[][] visited; //no need to use Boolean\n    //exit holds the same information as Node.blocked. No need to duplicate\n    //private static boolean[][] blocked;\n    //exit holds the same information as Node.exit. No need to duplicate\n    //private static boolean[][] exits;\n\n    private static int mazeRows, mazeCols, startRow, startCol; //use meaningful names\n    private static List<List<Node>> paths;\n\n    public static void main(String args[]) {\n\n        mazeCols = 21; mazeRows = 21;//use meaningful and consistent names\n        startRow = 9; startCol = 10;        //better keep h,w or height,width all over\n\n        String[] mazeData = getMazeData()  ;\n        makeMaze(mazeData);\n        drawMaze(); //draw maze as built from input data\n        paths = new ArrayList<>();\n        findExits(startNode);\n        drawAllPaths(); // print all paths found\n        List<Node> shortestPath = getShortestPath();\n        drawShortestPath(shortestPath);\n    }\n\n    private static void drawMaze() {\n\n        System.out.println(\"*****************************************\");\n        System.out.println(\"Maze as defined by input\");\n        System.out.println(\"*****************************************\");\n        drawMaze(null);\n    }\n\n    private static void drawAllPaths() {\n\n        for (List<Node> path : paths) {\n            System.out.println(\"*****************************************\");\n            System.out.println(\"Path to exit [\"\n                    + path.get(0).row + \",\" + path.get(0).col + \"] length:\"+ path.size());\n            System.out.println(\"*****************************************\");\n            drawMaze(path);\n        }\n    }\n\n    private static void drawShortestPath(List<Node> path) {\n\n        System.out.println(\"*****************************************\");\n        System.out.println(\"Shortest path is to exit [\"\n                + path.get(0).row + \",\" + path.get(0).col + \"] length:\"+ path.size());\n        System.out.println(\"*****************************************\");\n        drawMaze(path);\n    }\n\n    private static void drawMaze(List<Node> path) {\n\n        for(Node[] row : nodes ) {\n            for(Node node : row) {\n                char c = node.getGraphics();\n                //overwrite c if node is in path\n                if ( (c != EXIT) && ( c != START ) &&\n                        (path != null) && path.contains(node)) {c = PATH;}\n                System.out.print(c);\n            }\n            System.out.println(\"\");\n        }\n    }\n\n    private static void makeMaze(String[] mazeData) {\n\n        nodes = new Node[mazeRows][mazeCols];\n        visited = new boolean[mazeRows][mazeCols];\n\n        for (int rowIndex = 0; rowIndex < mazeRows; rowIndex++) {\n            String row = mazeData[rowIndex];\n            for (int colIndex = 0; colIndex < mazeCols; colIndex++) {\n                Node node = new Node(rowIndex, colIndex);\n                node.blocked = row.charAt(colIndex) == NUMBER_SIGN;\n                visited[rowIndex][colIndex] = false;\n                node.exit = (!node.blocked) && ((rowIndex == (mazeRows - 1)) ||\n                        (colIndex == (mazeCols - 1)) || (rowIndex == 0) || (colIndex == 0));\n                nodes[rowIndex][colIndex] = node;\n            }\n        }\n        startNode = nodes[startRow][startCol];//no need to set it in the loop\n    }\n\n    //use boolean instead of Boolean\n    private static void findExits(Node node) {\n\n        int row = node.row;\n        int col = node.col;\n\n        if(visited[row][col]) { return; }\n\n        if (node.exit) {\n            List<Node> path = new ArrayList<>();\n            while (node.parent != null) {\n                path.add(node);\n                node = node.parent;\n            }\n            path.add(node);\n            paths.add(path);\n            return; //do not continue to check exit neighbors\n        }\n\n        //LEFT\n        if ((col - 1) >= 0) {\n            Node testNode = nodes[row][col - 1];\n            //the following if statement repeats for all directions\n            //better put in a method\n            if ((testNode.parent == null) && ! testNode.blocked) {\n                testNode.parent = node; //parent ! null indicates that cell is tested\n                findExits(testNode);\n                testNode.parent = null; //set back to null: test finished\n            }\n        }\n\n        //RIGHT\n        if ((col + 1) < mazeCols) {\n            Node testNode = nodes[row][col + 1];\n            if ((testNode.parent == null) && ! testNode.blocked) {\n                testNode.parent = node;\n                findExits(testNode);\n                testNode.parent = null;\n            }\n        }\n\n        //TOP\n        if ((row - 1) >= 0) {\n            Node testNode = nodes[row-1][col];\n            if ((testNode.parent == null) && ! testNode.blocked) {\n                testNode.parent = node;\n                findExits(testNode);\n                testNode.parent = null;\n            }\n        }\n\n        //BOTTOM\n        if ((row + 1) < mazeRows) {\n            Node testNode = nodes[row+1][col];\n            if ((testNode.parent == null) && ! testNode.blocked) {\n                testNode.parent = node;\n                findExits(testNode);\n                testNode.parent = null;\n            }\n        }\n\n        visited[row][col] = true; //mark as visited after all directions explored\n        node.parent = null;\n    }\n\n    public static class Node {\n\n        public int row, col;\n        boolean blocked = false;\n        boolean exit = false;\n        Node parent = null;\n\n        public Node(int row, int col) {\n            this.row = row;\n            this.col = col;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            final Node other = (Node) obj;\n            if (row != other.row) {\n                return false;\n            }\n            if (col != other.col) {\n                return false;\n            }\n            return true;\n        }\n\n        //it is simpler to have Node return its graphic representation\n        char getGraphics() {\n\n            char c = blocked ? NUMBER_SIGN : DOT;\n            if(equals(startNode)) { c=START;}\n            else if (exit) { c=EXIT;}\n\n            return c;\n        }\n\n        @Override\n        public String toString() {\n\n            return \"Node \" + row +\"-\"+ col +\" (\"+ getGraphics() + \")\";\n        }\n    }\n\n    private static List<Node> getShortestPath() {\n        //initialize with an arbitrary path\n        List<Node> shortest = paths.get(0);\n        for (List<Node> path : paths) {\n            if(path.size() < shortest.size()) {\n                shortest = path;\n            }\n        }\n        return shortest;\n    }\n\n    private static String[] getMazeData() {\n\n        return  new String[] {\n                \"##########.##########\",\n                \"..#...........#.....#\",\n                \"#.#.#########.#.###.#\",\n                \"#...#.........#.#...#\",\n                \"###############.#.###\",\n                \"#.....#.......#.#...#\",\n                \"#.#######.###.#.#.#.#\",\n                \"#...#...#...#...#.#..\",\n                \"###.###.###.###.#.#.#\",\n                \"#.#.#.#...#.#...#.#.#\",\n                \"#.#.#.#.#.#.#.###.#.#\",\n                \"#...#.#.#.#.#...#.#.#\",\n                \"#####.###.#.#####.###\",\n                \"#.#.......#.#...#...#\",\n                \"#.#.#######.#.#.###.#\",\n                \"#.#.#...#...#.#.#...#\",\n                \"#.#.###.#.#####.#####\",\n                \"#.#.................#\",\n                \"#.##.####.#########.#\",\n                \"#.........#..........\",\n                \"####.######.#########\"\n        };\n    }\n}\n```\n\n\nFeedback would be appreciated. \n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "BGL Dijkstra Shortest Paths with Bundled Properties\r\n                \r\nI'm trying to use the dijkstra shortest path algorithm in BGL to compute a simple ST path on an unweighted undirected graph.  I may care about edge weights in the future, but for now I just want to consider edge traversals to be a uniform cost.\n\nI am also tracking multiple edge and vertex properties so I've based what I've done so far on the bundled properties example that seemed to be the closest to what I'm attempting to do.\n\nNow I'm trying to figure out how to get dijkstra working so I can do my ST search but I am getting stuck on getting the right parameters set up for it.\n\nHere's a simplified example of the code I have so far:\n\n```\n#include <iostream>\n#include <vector>\n\n#include <boost/config.hpp>\n#include <boost/graph/graph_traits.hpp>\n#include <boost/graph/adjacency_list.hpp>\n#include <boost/graph/dijkstra_shortest_paths.hpp>\n#include <boost/property_map/property_map.hpp>\n\n// Create a struct to hold properties for each vertex\ntypedef struct VertexProperties\n{\n  int p1;\n} VertexProperties;\n\n// Create a struct to hold properties for each edge\ntypedef struct EdgeProperties\n{\n  int   p1;\n} EdgeProperties;\n\n// Define the type of the graph\ntypedef boost::adjacency_list<boost::vecS, boost::vecS, boost::undirectedS, VertexProperties, EdgeProperties> Graph;\n\n\nint main(int,char*[])\n{\n  // Create a graph object\n  Graph g;\n\n  // Add vertices\n  Graph::vertex_descriptor v0 = boost::add_vertex(g);\n  Graph::vertex_descriptor v1 = boost::add_vertex(g);\n  Graph::vertex_descriptor v2 = boost::add_vertex(g);\n\n  // Set vertex properties\n  g[v0].p1 = 1;\n  g[v1].p1 = 2;\n  g[v2].p1 = 3;\n\n  // Add edges\n  std::pair<Graph::edge_descriptor, bool> e01 = boost::add_edge(v0, v1, g);\n  std::pair<Graph::edge_descriptor, bool> e02 = boost::add_edge(v1, v2, g);\n\n  // Set edge properties\n  g[e01.first].p1 = 1;\n  g[e02.first].p1 = 2;\n\n  std::cout << \"num_verts: \" << boost::num_vertices(g) << std::endl;\n  std::cout << \"num_edges: \" << boost::num_edges(g) << std::endl;\n\n  // compute ST shortest paths here...\n\n  return 0;\n}\n```\n\n\nI'm getting tripped up on the right parameters for the call to dijkstra's algorithm.  They take the graph, a starting vertex, and then a predecessor map and distance map.  The examples I've seen so far, like this one set up their graph with just an edge weight without the bundled edge properties, which simplifies things.\n\nUltimately, I'm after the ST shortest path so I'd need to recover the path from S to T.  From the looks of things, we need to set up a predecessor map and then we can use that to extract the path from a particular T back to S?\n\nI should also note that the environment I'm in does not allow C++11 language features. :(\n\nAny help here would be greatly appreciated!\n    ", "Answer": "\r\nSo the question was \"how to use a bundled property as weight map with Boost Graph Library?\".\nGood. You use property maps. The bundled property can be accessed with a little bit of funky syntax documented right on the \"Bundled Properties\" page: http://www.boost.org/doc/libs/1_58_0/libs/graph/doc/bundles.html, see heading \"Property maps from bundled properties\".\nNow for a quick demo:\n```\n// set up a weight map:\nauto weights = boost::get(&EdgeProperties::p1, g);\n```\n\nPassing the minimum amount of arguments to dijkstra:\n```\n// you can pass it to dijkstra using direct or named params. Let's do the simplest\nboost::dijkstra_shortest_paths(g, v0, boost::no_named_parameters() .weight_map(weights));\n```\n\nYou will want to add more parameters, but hey, this is your start :)\nLive On Coliru\n```\n#include <iostream>\n#include <vector>\n\n#include <boost/config.hpp>\n#include <boost/graph/graph_traits.hpp>\n#include <boost/graph/adjacency_list.hpp>\n#include <boost/graph/dijkstra_shortest_paths.hpp>\n#include <boost/property_map/property_map.hpp>\n#include <boost/graph/graph_utility.hpp>\n\n// Create a struct to hold properties for each vertex\nstruct VertexProperties { int p1; };\n\n// Create a struct to hold properties for each edge\nstruct EdgeProperties { int p1; };\n\n// Define the type of the graph\ntypedef boost::adjacency_list<boost::vecS, boost::vecS, boost::undirectedS, VertexProperties, EdgeProperties> Graph;\n\nint main() {\n    // Create a graph object\n    Graph g;\n\n    // Add vertices\n    auto v0 = boost::add_vertex({1}, g),\n         v1 = boost::add_vertex({2}, g),\n         v2 = boost::add_vertex({3}, g);\n\n    // Add edges\n    boost::add_edge(v0, v1, EdgeProperties{1}, g);\n    boost::add_edge(v1, v2, EdgeProperties{2}, g);\n\n    boost::print_graph(g, boost::get(&VertexProperties::p1, g));\n\n    // set up a weight map:\n    auto weights = boost::get(&EdgeProperties::p1, g);\n\n    // you can pass itprint_graph`enter code here` to dijkstra using direct or named params. Let's do the simplest\n    boost::dijkstra_shortest_paths(g, v0, boost::no_named_parameters() .weight_map(weights));\n}\n```\n\nYou'll note that I simplified the initialization of the vertex/edge properties as well. The print_graph utility is neat if you want to have an idea of what the graph \"looks\" like (short of using Graphviz).\nThe output on Coliru is:\n```\n1 <--> 2 \n2 <--> 1 3 \n3 <--> 2 \n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path tree claim (Graph)\r\n                \r\nClaim: If all the edges weights in a graph are distinct, then there is a unique shortest path tree. Either give a convincing argument that the claim is true or give a counterexample.\n    ", "Answer": "\r\nIf you have MST then there is a unique path from every two vertices which makes the shortest path tree senseless. I assume you meant the result is a MST. However, this is not true. Shortest path trees are different from minimum spanning trees for the same graph and even for the same root. Shortest Path tree rooted on vertex ```\nv```\n  is usually the result of applying Dijkstra's algorithm over ```\nv```\n. \n\nIn general, uniqueness for trees over graphs is hard to be believed in unless strict requirements were given (like the new weights equal old ones +1).  @rici gave a counterexample with a polytree structure. Here is another counterexample for undirected graphs. Both trees are shortest path trees rooted at ```\nA```\n.  Note that:\n\n\nWhile both are shortest path trees, their total cost differ.\nBoth are spanning trees but neither one of them is a minimum. \n\n\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Is there anyway I can output all the shortest path in Coq?\r\n                \r\nI am trying to write a function that can find all the shortest paths for different vertices. However, my function can only find the shortest path of two vertices. Below is my code:\n```\nFrom LF Require Export Lists.\nFrom LF Require Export Basics.\nRequire Import Program.\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nDefinition vertics := list(nat).\nDefinition edges := list(nat*nat*nat).\n\nDefinition myEdges : edges := [(1,2,2);(1,3,1);(1,4,5);(2,3,4);(2,4,2);(3,4,2)].\n\nFixpoint minEdge (l: edges)(m: nat*nat*nat): nat*nat*nat :=\nmatch l with\n  | nil => m\n  | cons h t => match h, m with\n                | (a,b,w), (a2,b2,m) => if (leb w m) \n                 then (minEdge t (a,b,w))\n                 else (minEdge t (a2,b2,m))\n                end\n  end.\n```\n\nThe edges (natnatnat) represents (vertice1,vertice2,distance between 2 vertices).\nSo I was expecting the function will start from vertice1, find the paths of (1,3,1),(3,4,2),(4,2,2),(2,1,2) like the pic shown below. (shortest path for the whole graph)\n\nHowever, my function can only output (1,3,1).\nCan anyone help me with this? How can I fix the function?\n    ", "Answer": "\r\nHere is a naive algorithm\n```\nRequire Import Program.\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\n(* Vertices : we use nat *)\nDefinition vertex := nat.\nDefinition vertices := list vertex.\n\n(* Weight : we use nat *)\nDefinition weight := nat.\n\n(* Edge : 2 vertices + weight *)\nDefinition edge := (vertex * vertex * weight)%type.\nDefinition edges := list edge.\n\n(* Path : 2 vertices + weight + intermediate vertices *)\nDefinition path := (vertex * vertex * weight * vertices)%type.\nDefinition paths := list path.\n\nDefinition leb := Nat.leb.\nDefinition eqb a b := (leb a b && leb b a)%bool.\n\n(* The example *)\nDefinition myEdges : edges := \n  [(1, 2, 2); (1, 3, 1); (1, 4, 5);\n   (2, 3, 4) ; (2, 4, 2); (3, 4, 2)].\nDefinition myVertics := [1; 2; 3; 4].\n\n(* edgesToPaths *)\n\nFixpoint edgesToPaths (l: edges) : paths :=\nmatch l with\n  | nil => nil\n  | cons h t => match h with\n                | (a, b, w) => (a, b, w, []) :: edgesToPaths t \n                end\n  end.\n\nDefinition myPaths := edgesToPaths myEdges.\n\nCompute myPaths.\n\n(* Add a path in a list of paths keeping only the shortest *)\nFixpoint addPath1 (p : path) (l : paths) : paths :=\nmatch l with\n  | nil => cons p nil\n  | cons h t => match h, p with\n                | (a1, b1, w1, _), (a2, b2, w2, _) => \n                if (eqb a1 a2 && eqb b1 b2)%bool then\n                  if (leb w1 w2)%bool then l else p :: t\n                else if (eqb a1 b2 && eqb b1 a2)%bool then\n                  if (leb w1 w2)%bool then l else p :: t\n                else h :: addPath1 p t\n                end\n  end.\n\nDefinition addPath p ls := \n  match p with\n  | (a, b, w, l) => if (eqb a b) then ls\n                    else if (leb a b) then addPath1 p ls\n                    else addPath1 (b, a, w, rev l) ls\n  end.\n\n\n(* Test *)\n\n(* No progress *)\nCompute addPath (1, 4, 10, []) myPaths.\n\n(* Progress *)\nCompute addPath (1, 4, 2, []) myPaths.\n\n(* Reflexive *)\nCompute addPath (1, 1, 2, []) myPaths.\n\n(* extend  *)\nFixpoint extendPaths (p : path) (l: paths) : paths :=\nmatch l with\n  | nil => nil\n  | cons h t => match p, h with\n                | (a1, b1, w1, l1), (a2, b2, w2, l2) =>\n                      let t1 := addPath h (extendPaths p t) in\n                      if (eqb b1 a2) then\n                        addPath (a1, b2, w1 + w2, l1 ++ b1 :: l2) t1\n                      else if (eqb b1 b2) then\n                        addPath (a1, a2, w1 + w2, l1 ++ b1 :: rev l2) t1\n                      else if (eqb a1 a2) then\n                        addPath (b1, b2, w1 + w2, rev l1 ++ a1 :: l2) t1\n                      else if (eqb a1 b2) then\n                        addPath (b1, a2, w1 + w2, rev l1 ++ a1 :: rev l2) t1\n                      else t1\n               end\nend.\n\n(* Test *)\n\nCompute extendPaths (1, 2, 2, []) myPaths.\n\n(* Use the path in l1 to extend the path in l2 *)\nFixpoint listExtendPaths (l1 l2 : paths) : paths :=\nmatch l1 with\n  | nil => l2\n  | cons h t => listExtendPaths t (extendPaths h l2)\n  end.\n\n\n(* Test *)\n\nCompute listExtendPaths myPaths myPaths.\n\n(* To get the minimal the paths we iter the listExtendPath enough time\n   (a minimal path has no repetition of vertices)   *)\nFixpoint iter n l :=\nmatch n with \n  0 => l \n|\n  S n1 => iter n1 (listExtendPaths l l)\nend.\n\nDefinition getMinPaths (vs : vertices) (es : edges) := \n    iter (length vs) (edgesToPaths es).\n\nCompute myPaths.\nCompute getMinPaths myVertics myEdges.\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Quickest way to find shortest paths from origin to all destinations in a directed weighted graph\r\n                \r\nBackground\nI'm performing an iterative traffic assignment (ITA) on a directed weighted graph with ~12k nodes and ~25k edges. At each stage of the four iterations in ITA, I have to find the shortest path between an origin and a set of destinations (i.e., all the origins). The pseudocode looks like this:\n```\nfor iteration in iterations:\n    for origin in origins:\n        paths = find the shortest paths between origin and destinations\n        for destination in destinations:\n            for each edge between origin and destination:\n                assign traffic to edge\n            compute some quantities based on path properties\n```\n\nThere are ~30 nodes that are origins/destinations. The code I'm using is currently in Python 2.7 and uses networkx 1.8.1 to find the shortest paths between an origin and all destinations -- specifically, the function ```\nnetworkx.single_source_dijkstra_path```\n.\nQuestion\nOne call of ITA takes ~6.2 seconds on my local machine; about 95% of the time ITA takes to run is just finding these shortest paths. Since ```\ngraph-tool```\n has been shown to be 100x faster than ```\nnetworkx```\n at finding shortest paths per its own documentation, I tried implementing the same code using ```\ngraph-tool```\n functions. Of note: the documentation of ```\ngraph-tool```\n's performance is based on a different machine than the one I am using (a MacBook Pro).\nI've profiled the performance of ```\nnetworkx```\n (version 1.8 in Python 2.7) and ```\ngraph-tool```\n (version 2.35 in Python 3.6), considering two metrics: (a) the time to complete one call of ITA and (b) the average time to find a set of paths between an origin and destination using shortest path functions in each package.\n\n```\nnetworkx```\n (a) 6.2 seconds (b) 0.036 seconds\n\nusing ```\npaths_dict = networkx.single_source_dijkstra_path(G, origin, cutoff=None, weight='t_a')```\n\n\n\n```\ngraph-tool```\n (a) 6.8 seconds (b) 0.050 seconds\n\nusing ```\npaths_dict = {destination:topology.shortest_path(G, origin, destination, weights=G.edge_properties.ta) for destination in od_dict[origin]}```\n where topology is graphtool.\n\n\n\nWhy is ```\ngraph-tool```\n slower than ```\nnetworkx```\n in my code? Is there a faster way to implement a single-origin-to-multiple-destinations shortest path search in ```\ngraph-tool```\n?\nFull code\nHere's the relevant portion of the ITA algorithm using ```\ngraph-tool```\n.\n```\ndef test_traffic_assignment_graph_tool():\n    iteration_vals = [0.4, 0.3, 0.2,\n                      0.1]  # assign od vals in this amount per iteration. These are recommended values from the Nature paper, http://www.nature.com/srep/2012/121220/srep01001/pdf/srep01001.pdf\n\n    G = gt.load_graph(\"input/graphMTC_GB.gml\")\n\n    original_node_ids = [G.vertex_properties.label[temp] for temp in G.vertices()] # these are the original node IDs (match the networkx graph)\n    new_node_ids = [G.vertex_index[v] for v in G.vertices()] # these are the new node IDs assigned by graphtool\n\n    # Create a mapping from original to new node ids -- since G.get_vertices() always returns the same order, it's ok.\n    original_to_new = dict(zip(original_node_ids, new_node_ids))\n    new_to_original = dict(zip(new_node_ids, original_node_ids))\n\n    demand = bd.build_demand('input/BATS2000_34SuperD_TripTableData.csv',\n                             'input/superdistricts_centroids_dummies.csv')\n\n    overall_start = time.time()\n    paths_time = []\n\n    # sort OD pairs to fix inconsistency across different runs of the traffic assignment\n    origins = [int(i) for i in demand.keys()]  # get SD node IDs as integers\n    origins.sort()  # sort them\n    origins = [str(i) for i in origins]  # make them strings again\n\n    od_dict = bd.build_od(\n        demand)\n\n    for i in range(len(iteration_vals)):  # do 4 iterations\n\n        for origin in origins:\n            paths_start = time.time()\n            paths_dict = {destination:topology.shortest_path(G, original_to_new[origin], original_to_new[destination], weights=G.edge_properties.ta) for destination in od_dict[origin]}\n            paths_time.append(time.time() - paths_start)\n\n    overall_end = time.time()\n\n    print('Graphtool total pathfinding time = ', sum(paths_time))\n    print('Graphtool average pathfinding time = ', sum(paths_time) / len(paths_time))\n```\n\n    ", "Answer": "\r\nThe ```\nnetworkx```\n command ```\npaths_dict = networkx.single_source_dijkstra_path(G, origin, cutoff=None, weight='t_a')```\n computes all of the paths from ```\norigin```\n at once.  Calculating a shortest path requires a lot of effort, but if you're calculating multiple paths, much of the effort is repeated.  By calculating all paths at once, a lot of repetition is avoided.\nThe way you've set up the ```\ngraph-tool```\n call, for a given origin, you're redoing the calculation for each possible target node.  So it's building up all of the shortest paths until it finally finds the target.  Then it starts the process over.  So it is doing much more calculation than the networkx code.\nI don't know ```\ngraph-tool```\n well enough to know if it has an option to return shortest paths to all possible targets at once.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How get the shortest path\r\n                \r\nAm using ionic and firebase to develop my project.I use ngmap to display the events but I would display the shortest path to the event location. Can you provide me by a useful link or exemple please. \n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Find shortest path between two vertices in undirected graph\r\n                \r\nI must find the shortest path. This gives me the list of all paths. How can I pick the smallest out of these?\n\n```\npath(X,Y,[X,Y],L) :- edge(X,Y,L).\npath(X,Y,[X|W],L) :- edge(X,Z,L1), path(Z,Y,W,L2), L is L1 + L2.\n```\n\n    ", "Answer": "\r\nStarting from your program, you can solve this problem with this code:\n\n```\npath(X,Y,[X,Y],L):- \n    edge(X,Y,L).\n\npath(X,Y,[X|W],L):- \n    edge(X,Z,L1), \n    path(Z,Y,W,L2), \n    L is L1 + L2.\n\nshortestPath(X,X,[X,X],0):- !.\nshortestPath(X,Y,MinP,MinD):-\n    findall([L,P],path(X,Y,P,L),Set),\n    sort(Set,Sorted),\n    Sorted = [[MinD,MinP]|_].\n\n?- shortestPath(1,5,Path,Length).\nLength = 3.5,\nPath = [1, 2, 5]\n```\n\n\nIf you don't want to use ```\nsort/2```\n (note that ```\nsort/2```\n removes duplicates), you can wite something like this:\n\n```\nshortestPath(X,X,[X,X],0):- !.\nshortestPath(X,Y,MinP,MinD):-\n    findall([L,P],path(X,Y,P,L),Set),\n    splitList(Set,LD,LP),\n    min_list(LD,MinD),\n    nth1(I,LD,MinD),\n    nth1(I,LP,MinP).\n\nsplitList([],[],[]).\nsplitList([[L,D]|T],[L|TP],[D|TD]):-\n    splitList(T,TP,TD). \n\n?- shortestPath(1,5,Path,Length).\n    Length = 3.5,\n    Path = [1, 2, 5]\n    false.\n```\n\n\nSo basically, you find all the solutions and pick the smallest one...\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "BFS shortest path only using adjacency matrix?\r\n                \r\nI'm trying to implement Ford-Fulkerson/Edmonds-Karp only using adjacency matrix'. The only thing I'm not able to program is the function to calculate the shortest path, using BFS. The function to see if a shortest path actually exists is fine, but is it possible to also get the shortest path? Or is the only way to get the shortest path with BFS to use some kind of parent pointers, and traverse backwards to get the path?\n\nHere is my code for see if path exists:\n\n```\npublic static boolean existsPathFromSourceToSinkInGf(int Gf[][])\n{\n    LinkedList<Integer> queue = new LinkedList<Integer>();\n    queue.add(0);\n\n    while (!queue.isEmpty())\n    {\n        int v = queue.remove();\n        if (v == sink) return true;\n        for (int i = 0; i < 5; i++)\n        {\n\n            if (Gf[v][i] != 0)\n            {\n                if (!queue.contains((Integer)i))\n                {\n                    queue.add((Integer)i); \n                }\n            }\n        }\n    }\n\n    return false;\n\n  }\n```\n\n    ", "Answer": "\r\nThe common way to do it would indeed be to maintain parent pointers each time you settle a node and to go backwards once you found your path. \n\nYou could also keep track of paths explicitly in your queue. Instead of using just an integer for your linkedlist, you could create your own class consisting of the integer and a string with something like \"node 1-> node 3->...\". It's less commonly used because of the overhead of the class and the paths, but it avoids having to keep the parent pointers on their own and having to traverse them in the end.\n\nOn a side note 2 remarks on your code:\n\n\nWhy does it run for i=0..5?\nYou check ```\nif (!queue.contains((Integer)i))```\n so you don't put a vertex on your queue that's already on it. You should also avoid putting vertices on that have already been removed from the list (try maintaining a set of visited nodes).\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path tree claim (Graph)\r\n                \r\nClaim: If all the edges weights in a graph are distinct, then there is a unique shortest path tree. Either give a convincing argument that the claim is true or give a counterexample.\n    ", "Answer": "\r\nIf you have MST then there is a unique path from every two vertices which makes the shortest path tree senseless. I assume you meant the result is a MST. However, this is not true. Shortest path trees are different from minimum spanning trees for the same graph and even for the same root. Shortest Path tree rooted on vertex ```\nv```\n  is usually the result of applying Dijkstra's algorithm over ```\nv```\n. \n\nIn general, uniqueness for trees over graphs is hard to be believed in unless strict requirements were given (like the new weights equal old ones +1).  @rici gave a counterexample with a polytree structure. Here is another counterexample for undirected graphs. Both trees are shortest path trees rooted at ```\nA```\n.  Note that:\n\n\nWhile both are shortest path trees, their total cost differ.\nBoth are spanning trees but neither one of them is a minimum. \n\n\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Find shortest path between two vertices in undirected graph\r\n                \r\nI must find the shortest path. This gives me the list of all paths. How can I pick the smallest out of these?\n\n```\npath(X,Y,[X,Y],L) :- edge(X,Y,L).\npath(X,Y,[X|W],L) :- edge(X,Z,L1), path(Z,Y,W,L2), L is L1 + L2.\n```\n\n    ", "Answer": "\r\nStarting from your program, you can solve this problem with this code:\n\n```\npath(X,Y,[X,Y],L):- \n    edge(X,Y,L).\n\npath(X,Y,[X|W],L):- \n    edge(X,Z,L1), \n    path(Z,Y,W,L2), \n    L is L1 + L2.\n\nshortestPath(X,X,[X,X],0):- !.\nshortestPath(X,Y,MinP,MinD):-\n    findall([L,P],path(X,Y,P,L),Set),\n    sort(Set,Sorted),\n    Sorted = [[MinD,MinP]|_].\n\n?- shortestPath(1,5,Path,Length).\nLength = 3.5,\nPath = [1, 2, 5]\n```\n\n\nIf you don't want to use ```\nsort/2```\n (note that ```\nsort/2```\n removes duplicates), you can wite something like this:\n\n```\nshortestPath(X,X,[X,X],0):- !.\nshortestPath(X,Y,MinP,MinD):-\n    findall([L,P],path(X,Y,P,L),Set),\n    splitList(Set,LD,LP),\n    min_list(LD,MinD),\n    nth1(I,LD,MinD),\n    nth1(I,LP,MinP).\n\nsplitList([],[],[]).\nsplitList([[L,D]|T],[L|TP],[D|TD]):-\n    splitList(T,TP,TD). \n\n?- shortestPath(1,5,Path,Length).\n    Length = 3.5,\n    Path = [1, 2, 5]\n    false.\n```\n\n\nSo basically, you find all the solutions and pick the smallest one...\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest-path algorithms which use a space-time tradeoff?\r\n                \r\nProblem: finding shortest paths in an unweighted, undirected graph.\n\nBreadth-first search can find the shortest path between two nodes, but this can take up to O(|V| + |E|) time. A precomputed lookup table would allow requests to be answered in O(1) time, but at the cost of O(|V|^2) space.\n\nWhat I'm wondering: Is there an algorithm which offers a space-time tradeoff that's more fine-grained? In other words, is there an algorithm which:\n\n\nFinds shortest paths in more time than O(1), but is faster than a bidirectional breadth-first search\nUses precomputed data which takes up less space than O(|V|^2)?\n\n\nOn the practical side: The graph is 800,000 nodes and is believed to be a small-world network. The all-pairs shortest paths table would be on the order of gigabytes -- that's not outrageous these days, but it doesn't suit our requirements.\n\nHowever, I am asking my question out of curiosity. What's keeping me up at night is not \"how can I reduce cache misses for an all-pairs lookup table?\", but \"Is there a completely different algorithm out there that I've never heard of?\"\n\nThe answer may be no, and that's okay.\n    ", "Answer": "\r\nYou should start by looking at Dijkstra's algorithm for finding the shortest path. The a* algorithm is a variant that uses a heuristic to reduce the time taken to calculate the optimal route between the start and goal node (such as the euclidean distance). You can modify this heuristic for performance or accuracy.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "BFS shortest path only using adjacency matrix?\r\n                \r\nI'm trying to implement Ford-Fulkerson/Edmonds-Karp only using adjacency matrix'. The only thing I'm not able to program is the function to calculate the shortest path, using BFS. The function to see if a shortest path actually exists is fine, but is it possible to also get the shortest path? Or is the only way to get the shortest path with BFS to use some kind of parent pointers, and traverse backwards to get the path?\n\nHere is my code for see if path exists:\n\n```\npublic static boolean existsPathFromSourceToSinkInGf(int Gf[][])\n{\n    LinkedList<Integer> queue = new LinkedList<Integer>();\n    queue.add(0);\n\n    while (!queue.isEmpty())\n    {\n        int v = queue.remove();\n        if (v == sink) return true;\n        for (int i = 0; i < 5; i++)\n        {\n\n            if (Gf[v][i] != 0)\n            {\n                if (!queue.contains((Integer)i))\n                {\n                    queue.add((Integer)i); \n                }\n            }\n        }\n    }\n\n    return false;\n\n  }\n```\n\n    ", "Answer": "\r\nThe common way to do it would indeed be to maintain parent pointers each time you settle a node and to go backwards once you found your path. \n\nYou could also keep track of paths explicitly in your queue. Instead of using just an integer for your linkedlist, you could create your own class consisting of the integer and a string with something like \"node 1-> node 3->...\". It's less commonly used because of the overhead of the class and the paths, but it avoids having to keep the parent pointers on their own and having to traverse them in the end.\n\nOn a side note 2 remarks on your code:\n\n\nWhy does it run for i=0..5?\nYou check ```\nif (!queue.contains((Integer)i))```\n so you don't put a vertex on your queue that's already on it. You should also avoid putting vertices on that have already been removed from the list (try maintaining a set of visited nodes).\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Find shortest path using Boost Dijkstra with specified MAX DISTANCE\r\n                \r\nI love using boost's dijkstra implementation to find the shortest path from a node\n\nHowever, in my current problem, I have a huge graph and only need to find shortest paths to nodes that are within a certain distance\n\nI can implement this myself, but I believe boost's implementation is much more efficient than mine, so I prefer to use boost for the task\n\nI just wonder if there is a way to tell boost's dijkstra to stop looking for shortest paths if nodes are too far -- as it will significantly speed up the algorithm in this case\n    ", "Answer": "\r\nIt is a very simple modification of the Dijkstra algorithm. While you iterate over outgoing edges from vertex v, just ignore each edge e, where ```\ne.weight + v.dist > max```\n.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Maze Recursion and shortest path\r\n                \r\nI know this isn't perfect, and I know that it isn't near done. The board is a 19 by 19 array, where 1's represent empty squares. Right now, it will go straight down, then go west. If there is a wall to the left of it, then it will have a stack overflow. The reason why is when it trys to 'climb' up the wall, it ends up going back down over and over and crashes. Even if I fix this, though, it wont find the shortest path. The solutions I've found draw paths, not count how many squares it is away.\n\n```\nprivate static int turnsforshortestmove(Vector2 location, int[,] board, int endrow)\n{\n    if (location.Y == endrow)\n    {\n        return 0;\n    }\n    if (board[(int)location.X, (int)location.Y - 1] == 1)\n    {\n        return 1 + turnsforshortestmove(new Vector2(location.X, location.Y - 2), board, endrow);\n    }\n    else if (board[(int)location.X - 1, (int)location.Y] == 1)\n    {\n        return 1 + turnsforshortestmove(new Vector2(location.X - 2, location.Y), board, endrow);\n    }\n    else if (board[(int)location.X, (int)location.Y + 1] == 1)\n    {\n        return 1 + turnsforshortestmove(new Vector2(location.X, location.Y + 2), board, endrow);\n    }\n    else if (board[(int)location.X + 1, (int)location.Y ] == 1)\n    {\n        return 1 + turnsforshortestmove(new Vector2(location.X + 2, location.Y), board, endrow);\n    }\n\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nThis is a path-finding problem.  As SJuan76 has already suggested, Dijkstra's algorithm is the best starting point for this sort of problem.\n\nGiven a grid-style map of open/blocked squares where only orthogonal moves (up, down, left and right) are allowed and each move costs the same amount, finding a path from one grid cell to another involves a fairly simple but time-consuming iteration over possible moves.\n\nThe basic principle is to create a list of possible moves and process each one looking for the shortest path.  In each step you check the possible moves from the current position, check if the target location has been moved to previously, and add the ones that haven't been checked already - or that can be moved to more quickly than the previous check - to the list to be processed.  Keep processing the list until you find the location you're aiming for.\n\nHow you do this is the fun part.\n\nThere are a few things you need to get started on this:\n\n\nA method for finding possible moves from an arbitrary point in the grid.\nA way to track locations you've already visited, and what location they were visited from.\nA fast way to figure out the best location to check next.\n\n\nGiven that you're working from a simple square grid, that you're only doing orthogonal moves (up, down, left, right) and that all moves will cost the same, you can gloss over some of the concepts that are not useful in your scenario.  So...\n\n\nCreate two collections: one to store the list of locations to ```\nprocess```\n, and one to store the list of ```\nvisited```\n locations.\nAdd your starting point to the ```\nprocess```\n list.\nWhile the ```\nprocess```\n list is not empty\n\n\nGet the next location from the ```\nprocess```\n list\nIf current location is the target, return the list of previous locations that form the path.\nFind available moves from that location, excluding any moves in the ```\nvisited```\n list\nPush all un-visited possible moves into the ```\nprocess```\n list\n\n\n\nEventually, one of two things will happen: either you'll run out of possible moves that haven't already been checked, or you will find your target point.\n\nHere's a structure similar to what I used last time I did path-finding like this:\n\n```\npublic struct SearchNode\n{\n    public Vector2 position;\n    public SearchNode prior;\n    public int TotalCost;\n}\n```\n\n\nThe ```\nvisited```\n list can be done with a Dictionary:\n\n```\nvar visited = new Dictionary<Vector2, SearchNode>();\n```\n\n\nThe ```\nprocess```\n list can be done with a bunch of collection types.  The simplest form would be:\n\n```\nvar process = new Queue<Vector2>();\n```\n\n\nHopefully I've given you something to start with.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "All shortest paths that traverse at least one node of a given group(s) of nodes\r\n                \r\nBasically i want to find the shortest paths for all (s,t) pairs but with several considerations. For instance the network contains several clusters/communities or group of nodes. These groups will be predefined and can be relatively large in the number of nodes.\n\nI want to find the shortest paths for all s,t pairs that traverse at least one node e.g., from gourp1. In the general case if i have only one group of nodes the problem is reduced to the traditional betweenness centrality. Later i would like to find for all s,t pairs the shortest paths that traverse at least one node from gourp1 and group2.\n\nAny suggestions?\n\nThanks! :)\n    ", "Answer": "\r\nAccording to your description, it seems to me that you are willing to get the shortest paths for individual group of nodes. If you are willing to do that, I think you are heading to the right direction.\n\nIt will be more robust if you can find the shortest paths of individual groups then combine the nodes of different groups together. That must save the time.\n\nI think You can use Particle Swarm Optimization Algorithm for the solution of the problem. It can help you through using multiple swarms to get the shortest path of different groups. Then you can combine the nodes from different groups.\n\nHope it helps. :)\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "shortest path along skeletonized 3d mask\r\n                \r\nI have a 3D array with curved lines (skeletonized data) and need to find the shortest connecting path between two points on those lines. \n\nHow do I find the shortest path between two points along a 3D skeleton array in Matlab?\n\nThere are several people asking a similar question both here and on the mathworks forum. But most answers point to this blog post on finding shortest paths, which does not search along a skeleton. If I try to force it along the skeleton it also returns paths that are not between the two points but farther away from both. Also some matlab functions that people suggest can only handle 2D data (like ```\nbwdistgeodesic```\n, which could be used to evade non-skeleton voxels).\n\nI use two functions from the file exchange. Here's what I do:\n\n```\n%get data\nload mri\nD = double(squeeze(D)); D = D./max(D(:)); D = real(ifft(ifft(ifft(ifftshift(ifftshift(ifftshift( padarray( fftshift(fftshift(fftshift(fft(fft(fft(D,[],1),[],2),[],3),1),2),3), size(D),0,'both' ) ,1),2),3),[],1),[],2),[],3));\nfigure; ax(1) = subplot(1,3,1); imshow(mean(D,3),[]); title('mean image')\n\n%find vasculature\nspacing = [1 1 1];sigmas = [0.5:0.5:2];tau = 1;whiteondark = false;Dvess = vesselness3D(D, sigmas, spacing, tau, whiteondark);\nax(2) = subplot(1,3,2); imshow(imfuse(squeeze(max(Dvess,[],3)), squeeze(max(Dvess>0.5,[],3))),[]); title('masked \"vessels\"')\n\n%skeletonize\nDskel = Skeleton3D(Dvess>0.5);\nax(3) = subplot(1,3,3); imshow(imfuse(squeeze(max(Dskel,[],3)), squeeze(max(Dvess>0.5,[],3))),[]); title('skeletonized mask'); linkaxes(ax); zoom(2);\n\n%select seeds\ncorline1 = imline(); idx1 = find(repmat(corline1.createMask, [1 1 size(Dskel,3)]).*Dskel); [sub11, sub21, sub31] = ind2sub(size(Dskel), idx1);\ncorline2 = imline(); idx2 = find(repmat(corline2.createMask, [1 1 size(Dskel,3)]).*Dskel); [sub12, sub22, sub32] = ind2sub(size(Dskel), idx2);\n```\n\n\nSo far so good with these results:\n\n\n\nThe white lines in the right image show the skeleton and the blue lines show the seeds. But then if I try to apply distance transforms I cant find the shortest path:\n\n```\n%distance map\ndist1 = zeros(size(Dskel)); dist1(sub11, sub21, sub31) = 1; dist1 = bwdist(dist1);\ndist2 = zeros(size(Dskel)); dist2(sub12, sub22, sub32) = 1; dist2 = bwdist(dist2);\ndist12 = dist1+dist2;\n\n%path\npath1 = imregionalmin(Dskel.*dist12);\npath2 = imregionalmin(Dskel.*dist12+10000.*(~Dskel));\n%path3 = imregionalmin(Dskel.*dist12+Inf.*Dskel); %function cant handle inf\n\nfigure; ax(1) = subplot(1,3,1); imshow(squeeze(sum(double(path1),3)),[]); title('')\nax(2) = subplot(1,3,2); imshow(squeeze(sum(double(path2),3)),[]); title('')\n%ax(2) = subplot(1,3,2); imshow(squeeze(sum(double(path3),3)),[]); title('')\nlinkaxes(ax); zoom(3);\n```\n\n\n\n\nThe first finds finds pretty much the entire skeleton again and the second looks like bogus. The regional minimum definitely is not appropriate to find the path, but not sure what else would be. Also my distance calculation does not account for the skeleton, which I tried to circumvent in the second path but that also did not work nicely.\n\nWhat should I do different?\n\n\n\nJust found something called 'fast marching', maybe that would work. Looking into it now.\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest Path algorithm isnt working as intended\r\n                \r\n```\n\n\n\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Set;\n\nimport ca.mcmaster.cas.se2aa4.a4.pathfinder.graph.Edge;\nimport ca.mcmaster.cas.se2aa4.a4.pathfinder.graph.Graph;\nimport ca.mcmaster.cas.se2aa4.a4.pathfinder.graph.Node;\n\npublic class GraphShortestPath implements PathFinder {\n    private Graph graph;\n    Map<Node, Double> distances = new HashMap<>(); // tentative distances from start node to each node\n    Map<Node, Node> predecessors = new HashMap<>(); // predecessors of each node in the shortest path\n    \n    public GraphShortestPath(Graph graph) {\n        this.graph = graph;\n    }\n    \n    @Override\n    public List<Node> findPath(Node start, Node end) {\n        \n\n        PriorityQueue<Node> unvisitedNodes = new PriorityQueue<>(Comparator.comparingDouble(distances::get)); // nodes not visited yet\n        Set<Node> visitedNodes = new HashSet<>(); // visited nodes\n        \n        // initialize tentative distances and add all nodes to unvisited nodes\n        for (Node node : graph.getNodesList()) {\n            if (node.equals(start)) {\n                distances.put(node, 0.0);\n            } else {\n                distances.put(node, Double.POSITIVE_INFINITY);\n            }\n            unvisitedNodes.offer(node);\n        }\n        \n        // loop until we reach the end node or there are no more nodes to visit\n        while (!unvisitedNodes.isEmpty()) {\n            Node current = unvisitedNodes.poll();\n            \n            \n            if (current.equals(end)) {\n\n                // we have found the shortest path, reconstruct it using predecessors and return it\n                List<Node> shortestPath = new ArrayList<>();\n                Node node = end;\n                System.out.println(predecessors.size());\n                System.out.println();\n                while (node != null) {\n                    System.out.println(node.getId());\n                    shortestPath.add(0, node);\n                    node = predecessors.get(node);\n                    \n                }\n                return shortestPath;\n            }\n            visitedNodes.add(current);\n            for (Edge edge : current.getOutEdges()) {\n                Node neighbor = edge.getDestination();\n                if (visitedNodes.contains(neighbor)) {\n                    continue;\n                }\n                double tentativeDistance = distances.get(current) + edge.getWeight();\n                if (tentativeDistance < distances.get(neighbor)) {\n                    distances.put(neighbor, tentativeDistance);\n                    predecessors.put(neighbor, current);\n                    unvisitedNodes.remove(neighbor);\n                    unvisitedNodes.offer(neighbor);\n                }\n            }\n        }\n        \n        // end node is not reachable from start node\n        System.out.println(\"no path was found\");\n        return null;\n\n\n\n    }\n}\n```\n\nthis data structure for finding the shortest path will sometimes not construct the path correctly, after it throws the end node in to the shortest path array list, where it does 'node = predesccors.get(node)' it returns null when there should be a predesccor b4 it, how to fix this? this doesnt happen all the time, for example when I manually create a graph like the following:\n```\nimport java.util.List;\n\nimport ca.mcmaster.cas.se2aa4.a4.pathfinder.graph.Graph;\nimport ca.mcmaster.cas.se2aa4.a4.pathfinder.graph.Node;\nimport ca.mcmaster.cas.se2aa4.a4.pathfinder.path.GraphShortestPath;\nimport ca.mcmaster.cas.se2aa4.a4.pathfinder.path.PathFinder;\n\npublic class Main {\n    \n\n    public static void main(String[] args) {\n        \n        Graph graph = new Graph();\n\n        graph.addNode(0);\n        graph.addNode(1);\n        graph.addNode(2);\n        graph.addNode(3);\n        graph.addNode(4);\n        graph.addNode(5);\n        graph.addNode(6);\n        graph.addNode(7);\n        graph.addNode(8);\n        graph.addNode(9);\n        graph.addNode(10);\n        graph.addNode(11);\n        graph.addNode(12);\n        graph.addNode(13);\n        graph.addNode(14);\n        graph.addNode(15);\n        graph.addNode(16);\n        graph.addNode(17);\n        graph.addNode(18);\n        graph.addNode(19);\n        graph.addNode(20);\n        \n        graph.addEdge(graph.getNode(0), graph.getNode(1));\n        graph.addEdge(graph.getNode(0), graph.getNode(7));\n\n        graph.addEdge(graph.getNode(1), graph.getNode(0));\n        graph.addEdge(graph.getNode(1), graph.getNode(7));\n        graph.addEdge(graph.getNode(1), graph.getNode(2));\n        graph.addEdge(graph.getNode(1), graph.getNode(8));\n\n        graph.addEdge(graph.getNode(2), graph.getNode(1));\n        graph.addEdge(graph.getNode(2), graph.getNode(8));\n        graph.addEdge(graph.getNode(2), graph.getNode(9));\n        graph.addEdge(graph.getNode(2), graph.getNode(3));\n\n        graph.addEdge(graph.getNode(3), graph.getNode(2));\n        graph.addEdge(graph.getNode(3), graph.getNode(9));\n        graph.addEdge(graph.getNode(3), graph.getNode(4));\n        graph.addEdge(graph.getNode(3), graph.getNode(10));\n\n        graph.addEdge(graph.getNode(4), graph.getNode(3));\n        graph.addEdge(graph.getNode(4), graph.getNode(10));\n        graph.addEdge(graph.getNode(4), graph.getNode(11));\n        graph.addEdge(graph.getNode(4), graph.getNode(5));\n\n        graph.addEdge(graph.getNode(5), graph.getNode(4));\n        graph.addEdge(graph.getNode(5), graph.getNode(11));\n        graph.addEdge(graph.getNode(5), graph.getNode(12));\n        graph.addEdge(graph.getNode(5), graph.getNode(6));\n\n        graph.addEdge(graph.getNode(6), graph.getNode(5));\n        graph.addEdge(graph.getNode(6), graph.getNode(12));\n\n        graph.addEdge(graph.getNode(8), graph.getNode(1));\n        graph.addEdge(graph.getNode(8), graph.getNode(2));\n        graph.addEdge(graph.getNode(8), graph.getNode(9));\n        graph.addEdge(graph.getNode(8), graph.getNode(16));\n        graph.addEdge(graph.getNode(8), graph.getNode(15));\n        graph.addEdge(graph.getNode(8), graph.getNode(14));\n        graph.addEdge(graph.getNode(8), graph.getNode(7));\n\n        PathFinder path = new GraphShortestPath(graph);\n        List<Node> l = path.findPath(graph.getNode(0), graph.getNode(6));\n\n        for(Node n: l){\n            System.out.println(n.getId());\n        }\n\n\n\n\n    }\n\n}\n```\n\nthis will provide me with the correct shortest path, but sometimes im finding an issue where the shortest path returned to me is just the destination node and Im not quite sure why that is happening\nI tried to add the predesccor node manually when reaching the end node but that didnt work.\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "All pairs shortest path issue\r\n                \r\nI've written this program that implements a graph with 100 nodes using an adjacency matrix. I've also used a Floyd-Warshall algorithm to find all pairs shortest path for all 100 nodes. Now, I'd like to condense the 100 x 100 matrix down to a 10 x 10 matrix that contains the all pairs shortest path only for the 10 indexes specified by ```\npublic static final int A = 100```\n...```\npublic static final int W = 66```\n. How should I condense the array? I've begun construction of a new method called ```\narrayCondenser```\n, but is there a simpler way to do this?\n\n```\npublic class AdjacencyMatrix\n{       \n    public static final int NUM_NODES = 100;\n    public static final int INF = 99999;\n\n    public static final int A = 20;\n    public static final int B = 18;\n    public static final int C = 47;\n    public static final int D = 44;\n    public static final int E = 53;\n    public static final int F = 67;\n    public static final int G = 95;\n    public static final int H = 93;\n    public static final int I = 88;\n    public static final int W = 66;\n\n    public static boolean even(int num) \n    {\n        return num%2==0;\n    }\n\n    public static boolean odd(int num) \n    {\n        return num%2==1;\n    }\n\n    public static void initialize(int [][] adjMat, int N) \n    {\n        for(int i = 0; i < N; i++)\n            for(int j = 0; j <N; j++)\n                adjMat[i][j]=INF;\n\n        for(int x = 0; x<N; x++)\n        {\n            int row = x/10;\n            int column = x%10;\n\n            if (even(row)) {\n                if (column!=9)\n                    adjMat[x][x+1]=1;\n            }\n            if (odd(row)) {\n                if (column!=0)\n                    adjMat[x][x-1]=1;\n            }\n            if (even(column)){\n                if (row!=9)\n                    adjMat[x][x+10]=1;\n            }\n            if (odd(column)) {\n                if (row!=0)\n                    adjMat[x][x-10]=1;\n            }\n        }\n    }\n\n    public static int[][] floydWarshall(int[][] adjMat, int N)\n    {\n        adjMat = new int[N][N];\n        initialize(adjMat, N);\n\n        for(int k = 0; k < N; ++k) \n        {\n           for(int i = 0; i < N; ++i) \n           {\n              for(int j = 0; j < N; ++j) \n              {\n                 adjMat[i][j] = Math.min(adjMat[i][j], adjMat[i][k] +   adjMat[k][j]);\n              }\n           }\n        }\n\n        return adjMat;\n    }\n\n    public static int[][] arrayCondenser(int[][] adjMat, int N)\n    {\n        int[] array = {A,B,C,D,E,F,G,H,I,W};\n        adjMat = floydWarshall(adjMat, N);\n\n\n\n\n        return adjMat;\n    }\n\n    public static void printGrid(int[][] adjMat)\n    {\n        for (int i=0; i<NUM_NODES; ++i)\n        {\n           for (int j=0; j<NUM_NODES; ++j)\n           {\n               if (adjMat[i][j]==INF)\n                   System.out.printf(\"%5s\", \"INF\");\n               else\n                   System.out.printf(\"%5d\",adjMat[i][j]);\n           }\n           System.out.println();\n        }\n    }\n\n    public static void main(String[] args)\n    {\n\n        int adjMat[][] = new int[NUM_NODES][NUM_NODES];\n        adjMat = floydWarshall(adjMat, NUM_NODES);\n\n        printGrid(adjMat);            \n\n        System.out.println();\n    }\n}\n```\n\n    ", "Answer": "\r\nI don't think what you are trying to do is possible. The Floyd-Warshall algorithm considers iteratively (as you know) each shortest path using the previous vertices. Once you remove the vertices (and by proxy, edges) then you are removing the valid scenarios for shortest path which may or may not include those vertices.\n\nOnce you change which set of vertices you are using, you would have to recalculate the shortest paths for your new graph. Otherwise, you'd basically have to keep track of every single path so that when you removed vertices, you could remove any paths that used those vertices - and thereby have your new shortest paths.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How to use jsprit for calculating the shortest path\r\n                \r\nI have came across Jsprit which is the collection of the algorithms for calculating the shortest path but i have added the maven dependencies in IDE, is there any information for classes and methods that can be used for calculating the shortest path and where does network topology located calculation of the shortest path?\n    ", "Answer": "\r\njsprit has no meaning of a network topology - you can use euclidean, real or manhatten distances or whatever. To calculate real distances or even time estimates you can use GraphHopper (as you've tagged you question with that) or other software for that purpose. Note: I'm the author of GraphHopper. Then feed the distance matrix you calculated into jsprit. See the documentation and examples of the projects on how to do this.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Which algorithm can I use to find the next to shortest path in a graph?\r\n                \r\nI want to find the next shortest path between 2 vertices in a graph and the path has a positive cost.The next shortest path is allowed to share edges of the shortest path .Which algorithm can I use? \n    ", "Answer": "\r\nUse the K-shortest path algorithm, where k=2 for you, some sample reference:\n\nFinding the k shortest paths.\nD. Eppstein.\n35th IEEE Symp. Foundations of Comp. Sci., Santa Fe, 1994, pp. 154-165.\nTech. Rep. 94-26, ICS, UCI, 1994.\nSIAM J. Computing 28(2):652-673, 1998.\n\nhttp://www.ics.uci.edu/~eppstein/pubs/Epp-TR-94-26.pdf\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Graphs: traverse every edge in undirected graph with shortest path\r\n                \r\nI have n roads and m cities. Each road has its own length. I need to visit all roads and find the shortest path for that.\nA graph is connected. I can start from any city.\nHow can i do this? I can use dfs or bfs to traverse the graph. But it’s not only about traversing all edges but finding the shortest path.\nI can find shortest paths from the source node to all other nodes, but it doesn’t guarantee traversal of all edges.\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "An algorithmic question concerning shortest paths and such\r\n                \r\nI have a very, very large graph, and I want to find the shortest path from one vertex to another. The graph is directed and unweighted. \n\nI have considered using some modification of Dijkstra's algorithm, but I usually use that for weighted undirected graphs. \n\nSo then my other thought was to use a DFS, since I can treat all the weights as one. \n\nAny suggestions? a\n\nEDIT: Ok, I meant to say BFS, I'm sorry. \n    ", "Answer": "\r\nTry a BFS instead.\n\n(Note that Dijkstra's algorithm works perfectly fine for unweighted directed graphs — it just happens that in the unweighted case, doing it smartly is essentially equivalent to a breadth-first search.)\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Counts the number of shortest paths passing through an arc (u, v)\r\n                \r\nGiven a directed weighted graph with n vertex and m arc (n < 1500, m < 5000) and one arc (u, v). And answer the question is how many shortest paths (can begin at any position a and end in b such that a! = b) passes through a given arc.  \n\nExample:\nn = 4, m = 4\narc (1, 2) with weight is 5\narc (2, 3) with weight is 5\narc (3, 4) with weight is 5\narc (1, 4) with weight is 8\nand arc (1, 2).\nThe answer is 2 because arc (1, 2) in shortest path 1->3 and 1->2.  \n\nDijkstra can solve this problem?\n    ", "Answer": "\r\nOne quick thought is, since it's all about path reconstruction, you may use ```\nFloyd-Warshall's algorithm```\n for finding shortest path between every pair of nodes in much cheaper way compared to running ```\nDijkstra's algorithm```\n for every node. After that, by doing path reconstruction for every node, you simply check if the provided arc exists on the path found.\n(Note however that Floyd-Warshall's algorithm does not support graphs with negative cycles)\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "spark one to one shortest path using pregel graphx\r\n                \r\ni tried to find shortest path from single source to n vertices using code from link\n\n```\nval graph: Graph[Long, Double] =\n  GraphGenerators.logNormalGraph(sc, numVertices = 100).mapEdges(e => e.attr.toDouble)\nval sourceId: VertexId = 42\n\nval initialGraph = graph.mapVertices((id, _) =>\n    if (id == sourceId) 0.0 else Double.PositiveInfinity)\nval sssp = initialGraph.pregel(Double.PositiveInfinity)(\n  (id, dist, newDist) => math.min(dist, newDist),\n  triplet => {\n    if (triplet.srcAttr + triplet.attr < triplet.dstAttr) {\n      Iterator((triplet.dstId, triplet.srcAttr + triplet.attr))\n    } else {\n      Iterator.empty\n    }\n  },\n  (a, b) => math.min(a, b)\n)\nprintln(sssp.vertices.collect.mkString(\"\\n\"))\n```\n\n\nit gives me output shortest path from 42 to N verticies.\nhowever, how to find the shortest path between single source to single destination?\ni.e. source=42, dest = 135 then i want to find the shortest path between them.\n\nthanks\n    ", "Answer": "\r\nYou can't find the shortest distance between two vertices otherwise i.e., without exploring the whole graph. Because, even if you stop your exploration once your message is received by the destination, nothing guarantees that it's the shortest distance.\nSo, this algorithm is fine in terms of complexity. You should just pick the sssp value from the different destinations obtained.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest Path Dijkstra Java\r\n                \r\nI am trying to print the shortest path for a specific adjacency matrix using dijktra's algorithm. My dijkstra algorithm works fine, I am getting the correct distances. However when printing out the path I am getting an incorrect path. Here is my code for printing the path:\n\nMy first class is my driver that takes in an adjacency matrix. The matrix contains the size at the top of the file, the actual matrix in the middle, and the source vertex at the end of the file. That all works fine for calculating the shortest distance. The following is my full code.\n\n```\npublic void findPath(int size, int s) {\n\n    // print the path and the distance of each vertex\n\n    int j;\n    // iterate to find the distances\n    for (int i = 0; i < size; i++) {\n        System.out.print(\"[\" + distance[i] + \"] \");\n\n        if (i != 0) {\n\n            System.out.print(s);\n            j = i;\n            do {\n\n                j = path[j];\n                System.out.print(\" <- \" + j);\n\n            } while (j != startVertex);\n\n        }\n\n        System.out.println();\n\n    }\n\n}\n}\n```\n\n    ", "Answer": "\r\nYou have the following problems in your ```\nfindPath```\n method:\n\n\nYou are skipping output for no reason with the ```\nif (i != 0)```\n line.\nYour data is in the form of 0-based indices, and your desired output is 1-based, and you aren't converting between them.\nYou are outputting data in the opposite order of what you want, printing the path's starting point first when your expected output puts the starting point last.\nBy following one step in the path before printing anything, you are skipping the path's first step.\nBy using a ```\ndo```\n loop instead of ```\nwhile```\n, you are printing spurious \"move by standing still\" path steps for short paths.\n\n\nI haven't examined your dijkstra logic much, but these errors in combination would transform path data that matches your expected output into the observed output, so I think you're correct that the dijkstra algorithm is working properly.\n\nFixing most of these should be trivial, but fixing error #3 will require a minor algorithmic change - trace and reverse the path before outputting any of it.\n\nFor greater clarity, here's your original code with all the fix points marked:\n\n```\npublic void findPath(int size, int s) {\n\n    // print the path and the distance of each vertex\n\n    int j;\n    // iterate to find the distances\n    for (int i = 0; i < size; i++) {\n        System.out.print(\"[\" + distance[i] + \"] \");\n\n        // FIX #1: Remove this if statement\n        if (i != 0) {\n\n            System.out.print(s);\n            j = i;\n            // FIX #5: Use while instead of do\n            do {\n\n                // FIX #4: swap the order of these two lines\n                j = path[j];\n                // FIX #2: print j+1, not j\n                // FIX #3: Instead of print, push onto a stack\n                System.out.print(\" <- \" + j);\n\n            } while (j != startVertex);\n\n            // FIX #3: Put your pop-and-print loop here. It should not\n            // involve i, and should end when the stack is empty, not\n            // any other condition.\n        }\n\n        System.out.println();\n\n        }\n    }\n}\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path in a street network\r\n                \r\nI'm working with NYC taxi dataset. Street network are obtained using osmnx and red dots are taxi pickup GPS locations.\n\nI did some map-matching. I projected the GPS locations to its nearest edge, and the projections are treated as nodes and added to the network (graph), its edges were updated accordingly. I get the following network. The yellow dots are the real nodes, and the purple dots are the projections of the GPS locations (also treated as nodes but differentiated by its attribute).\n\nNext I want to find the shortest path between two purple dots. For instance I get the following.\n\nThe red line is obviously NOT the shortest path. It seems to me that the shortest_path function accounts for the direction of the edges (i.e. for an edge, it always goes from the starting point to the end point). Is there a way that I can get the true shortest path? In fact, I only want the shortest network distance between two points.\nI guess I could duplicate each edge with its starting and end points reversed. But maybe there's a cleaner way to do this?\n    ", "Answer": "\r\nI found a clean way for this. I can simply do\n```\nroute = nx.shortest_path(nx.compose(G, G.reverse(copy=False)), source=9990000067, target=9990000003, weight='length')\nfig, ax = ox.plot_graph_route(nx.compose(G, G.reverse(copy=False)), route)\n```\n\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "shortest path between two strings\r\n                \r\nI am having to do a problem which creates the adjacency matrix the finds the shortest path between to strings that the user enters. I have already read the data file full of strings and have built the adjacency matrix if the shortest path between strings is one. I am confused on how to do this if the shortest path is 2,3,4,5, etc. The way to tell if the strings are connected is if the first words last three character, two characters, or last character matches the second word's first three characters, first two character, or first three characters. \n\nAn example I was given is \"everyday\" and \"daytime\" because the last and first three match. \n\nIf the last two and first two match an example is \"brother\" and \"eraser\".\n\nIf the last character and first character matches an example is \"scorpion\" and \"night\".\n\n```\n    int i,j;\n    String[] s = new String[sizOfFile];\nint[][] a = new int[sizeOfFile][sizeOfFile]; \nfor(i=0;i<n;i++)\n{\n    for(j=0;j<n;j++)\n    {\n        if((s[i].charAt(s[i].length()-3) == s[j].charAt(0) && s[i].charAt(s[i].length()-2) == s[j].charAt(1) && s                [i].charAt(s[i].length()-1) == s[j].charAt(2)))\n            {\n                a[i][j]=1;\n            }\n            else if(s[i].charAt(s[i].length()-1) == s[j].charAt(1) && s[i].charAt(s[i].length()-2) == s[j].charAt(0))\n            {\n                a[i][j]=1;\n            }\n            else if(s[i].charAt(s[i].length()-1) == s[j].charAt(0))\n            {\n                a[i][j]=1;\n            }\n            else\n            {\n                a[i][j]=0;\n            }\n            //Prints adjacency matrix\n        }\n    }\n```\n\n    ", "Answer": "\r\nFirst, to find the shortest path without wasted effort, you need to do a breadth-first search, not a depth-first search.\n\nE.g. to illustrate what I mean, imagine a directory search for a file by name. You search the current directory and for each sub-directory you call the search method recursively. That is a depth-first search, because it'll search the full hierarchy of the first sub-directory before continuing, and that's not what you want.\n\nInstead, collect all the sub-directory names, then if file not found yet, iterate the list to search each sub-directory, collecting the list of sub-sub-directories, and if file still not found, repeat using new list.\n\nThat's is what you want. Collect a list of all the words that are \"connected\" to the current word, then for each word in that list, build a new list of all words connected to those words, and repeat until target word found.\n\n\n\nThat was the overall algorithm. The search for connected words should be done by adding all words to a ```\nTreeSet```\n.\n\nFor each suffix (1-, 2-, or 3-letter), call ```\nsubSet(suffix, nextSuffix)```\n, where ```\nnextSuffix```\n is the same as ```\nsuffix```\n except last character incremented by one.\n\nCheck each subset for the target word and stop if found.\n\nKeep a separate ```\nHashSet```\n called ```\nused```\n of words found so far, to prevent infinite looping and to prevent using longer paths to a word that was already found using a shorter path. Remove any words in the subset that's in the ```\nused```\n set.\n\nAdd unused words in subset to ```\nused```\n set, and (together with \"path\" of words traveled to get to the word) add to list of words to process on next iteration.\n\nKeep iterating until done, or list is empty (no path found).\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Single-source shortest bitonic path\r\n                \r\nI'm trying to solve a question from Sedgewick & Wayne's Algorithms book: the single-source shortest bitonic path.\nSome definitions for those that are not familiar with the problem:\n\nMonotonic shortest-path: a monotonic shortest-path is a shortest-path in which the edges are either strictly increasing or strictly decreasing.\nBitonic shortest-path: a shortest-path from s to t in which there is an intermediate vertex v such that the weights of the edges on the path s to v are strictly increasing and the weights of the edges on the path from v to t are strictly decreasing.\n\nThe idea of the problem is:\n\nGiven an edge-weighted digraph, find a bitonic shortest path from a given source vertex to every other vertex (if one exists). The path should be simple (no repeated vertices).\n\nWhat I have so far is the following:\nA monotonic shortest-path can be computed by relaxing all the edges in the graph in either ascending order (to find an ascending monotonic shortest-path) or relaxing all the edges in the graph in descending order (to find a descending monotonic shortest-path).\nI pre-computed the ascending monotonic shortest-path from the source vertex to all other vertices (this can be done in O(E) as it is just one shortest-paths tree).\nI then pre-computed the descending monotonic shortest-path from all pairs of vertices, since any vertex can be the intermediate vertex and any vertex can be the target vertex. This is taking O(E * V) time.\nNow, for each path starting from s and ending at t, I could check all the combinations of (1) ascending monotonic shortest-path from s to an intermediate vertex v and (2) descending monotonic shortest-path from v to t and select the path with lowest weight.\nThis would give me a bitonic shortest-path from s to t.\nHowever, there is a catch: we cannot have repeated vertices in the path and the above idea does not address this issue.\nAny ideas for solving this last part of the problem?\nAny other ideas/approaches that solve the problem are also welcome.\n    ", "Answer": "\r\n(Note: I did not check whether the grand scheme of your idea really holds up, or whether there might be a faster algorithm. This solely addresses the issue of repeated vertices.)\n\nAssuming that neither the decreasing- nor the increasing paths contain repeated vertices, the only chance for repeated vertices is if a vertex exists in both, the decreasing and the increasing portion of the \"bitonic\" path.\n\n```\nA --1-- B --3-- C --5-- D --7-- E --7-- D --5-- C --2-- F --1-- Z\n```\n\n\nIn this example, ```\nC```\n is in both parts of the path, with ```\nE```\n being the intermediate vertex. As can be seen, this also means that the segment from ```\nC```\n to ```\nE```\n and from ```\nE```\n to ```\nC```\n have to be the same in both the increasing and the decreasing path. If there was a different (shorter) path in the decreasing path, then the increasing path would also be shorter when routed via that node.\n\nThis means, that we can simply cut the segment between the two instance of ```\nC```\n and are left with an even shorter \"bitonic\" path. (Or, we can just ignore the longer bitonic path, as we will find the shorter one later, anyway, when considering ```\nC```\n instead of ```\nE```\n as the intermediate node.)\n\n```\nA --1-- B --3-- C --2-- F --1-- Z\n```\n\n\nThis would result in seemingly weird results like ```\nA --1-- B --1-- Z```\n, where two consecutive edges have the same weight. But according to your definition \"a shortest-path from s to t in which there is an intermediate vertex v such that the weights of the edges on the path s to v are strictly increasing and the weights of the edges on the path from v to t are strictly decreasing\", this should still be a bitonic path, since both ```\nA --1-- C```\n as well as ```\nC --1-- Z```\n are strictly monotonic increasing and decreasing, respectively.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Google maps API : Finding the shortest Path\r\n                \r\nHello Guys I hope that you are well ! \n\ni'm developping an android App for delivery system ;\n\ni'd like to know if there is a ready library or a way to know  what's the\n\nshortest path to drive thru all the locations . \n\nfor example : \n\nthe driver has to fetch objects that are located in :(A,B,C,D)=>Locations\n\n\nA(lat,long) \nB(lat,long)\nC(lat,long)\nD(lat,long)\n\n\nthe app shows the driver what's the shortest path to take : \nDloc(lat,long) = (Driver's Location)\nthe shortest path for example : \n\n\nDloc(to)A\nthen\nA(to)C\nthen\nC(to)B\nthen\nB(to)D\n\n\nlike the Djikstra's Shortest Path Algorithm does (Graph Theory).\ni hope you guys understand my question \n    ", "Answer": "\r\nJust use the google map direction API, it will give you the shortest path to travel all sites as well as add ur origin and destination and add your other locations with the waypoint will give you optimised path and live traffic update..\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "find shortest path, must visit at least 1 node from a list\r\n                \r\nThis question asked exactly what I want to ask, but I don't get answer I need there. I'd like to add few points to clarify what I cannot figure out:\nI tried dijkstra algo,\n\nwhen do I check if shortest path contains 1 must-visit node?\n\nwhat do I do if shortest path does NOT contain any must-node?\n\n\nLike shortest path does not contain any must-node, but second shortest path has, how do I check for the shortest allowed path?\nI'm confused since prev[] indicates 1 shortest path from source to dest. How do I check other paths?\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How can I use the A star algorithm to find the first 100 shortest paths?\r\n                \r\nHow can I use the A star algorithm to find the first 100 shortest paths?\n    ", "Answer": "\r\nThe problem of finding k'th shortest path is NP-Hard, so any modification to A-Star that will do what you are after - will be exponential in the size of the input.\n\nProof:\n(Note: I will show on simple paths)\nAssume you had a polynomial algorithm that runs in polynomial time and returns the length of ```\nk```\nthe shortest path let the algorithm be ```\nA(G,k)```\n \n\nThe maximal number of paths is ```\nn!```\n, and by applying binary search on the range ```\n[1,n!]```\n to find a shortest path of length ```\nn```\n, you need ```\nO(log(n!)) = O(nlogn)```\n invokations of ```\nA```\n.\nIf you have found there is a path of length ```\nn```\n - it is a hamiltonian path. \nBy repeating the process for each source and target in the graph (```\nO(n^2)```\n of those), you can solve the Hamiltonian Path Problem polynomially, assuming such ```\nA```\n exists.\nQED\n\nFrom this we can conclude, that unless P=NP (and it is very unlikely according to most CS researchers), the problem cannot be solved polynomially.\n\nAn alternative is using a variation of Uniform Cost Search without maintaining ```\nvisited```\n/```\nclosed```\n set. You might be able to modify A* as well, by disabling the closed nodes, and yielding/generating solutions once encountered instead of returning them and finishing, but I cannot think of a way to prove it for A* at the moment.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Find shortest path between nodes with additional filter\r\n                \r\nI'm trying to model flights between airports on certain dates. So far my test graph looks like this:\n\n\n\nFinding shortest path between for example LTN and WAW is trivial with:\n\n```\nMATCH (f:Airport {code: \"LTN\"}), (t:Airport {code: \"WAW\"}), \np = shortestPath((f)-[]-(t)) RETURN p\n```\n\n\nWhich gives me:\n\n\n\nBut I have no idea how to get only paths with Flights that have relation FLIES_ON with given Date.\n\nLink to Neo4j console\n    ", "Answer": "\r\nHere's what I would do with your given model. The other commenters' queries don't seem right, as they use ```\nANY()```\n instead of ```\nALL()```\n. You specifically said you only want paths where all ```\nFlight```\n nodes on the path are attached to a given ```\nDate```\n node with a ```\n:FLIES_ON```\n relationship:\n\n```\nMATCH (LTN:Airport {code:\"LTN\"}),\n      (WAW:Airport {code:\"WAW\"}), \n      p =(LTN)-[:ROUTE*]-(WAW)\nWHERE ALL(x IN FILTER(x IN NODES(p) WHERE x:Flight) \n          WHERE (x)<-[:FLIES_ON]-(:Date {date:\"130114\"}))\nWITH p ORDER BY LENGTH(p) LIMIT 1\nRETURN p\n```\n\n\nhttp://console.neo4j.org/r/xgz84y\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path on graph with changing weights\r\n                \r\nI was trying to solve a local programming contest question. The problem is basically about finding the shortest path in a weighted graph. I am pretty new to these types of problems and I thought I could use Dijkstra's algorithm. However, there is a small complication - certain values are different, depending on the situation of this current path.\n\nProblem\n\nThere are two types of weights: normal weights and weights with condition (let's call them K). The condition is this: once you move through edge with weight K, all other weights of type K have value of 0. This brings a few more problems, because the apparent shortest path can be beaten by a combination of edges with weights of type K.\n\nExample\n\nBelow is this type of problem. If no weights would change their value, we could find the shortest path easily with Dijkstra. However, when weights K change their value, we can find a shorter path, because the weight of the edge C-D is 0 after moving through the edge A-C.\n\n\nQuestion\n\nHow can I find the shortest path?\n\nCan I use Dijkstra's algorithm here or is it better to use another algorithm like A* or BFS?\n    ", "Answer": "\r\nHow many K's are there? \n\nI it's only one, Dijkstra is good.\nI will add to say that BFS does not handle weighs well.\n\nReminder: Dijkstra finds the shortest path from a vertex to all vertexes.\n\nRun Dijkstra twice and define a different wight function for each run. First the wight function for K values is infinite. Second wight function for K values is 0. \n\nThan compare the result from run1 to run2+K.\n\nThis is true because if the shortest path is without K first run will find it. otherwise it's with K and the second run will find it. Either way the algorithm will find it. \n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Confused about Dijkstras shortest path and MST\r\n                \r\nIs Dijkstra's shortest path algorithm supposed to return a tree like it does in my textbook intro to algorithms? In examples I see online, it just shows the shortest path between 2 vertices. In my textbook it returns a tree with edges connected to every vertex. Im confused. \n    ", "Answer": "\r\nIt depends on the textbook you're using: Dijkstra's algorithm solves the single source shortest path problem, and storing the predecessor of each vertex in a shortest path is not a lot of additional work if you're computing those paths or their lengths anyway. So depending on the sources and the applications, you may read something like:\n\n\nDijkstraParents(G, s), which returns the parent of each vertex in a shortest path from s to any other vertex in graph G;\nDijkstraTree(G, s), which can use the result of DijkstraParents(G, s) to return the actual shortest path tree;\nDijkstraPath(G, s, t), which can use the result of DijkstraParents(G, s) or DijkstraTree(G, s) to explicitly return a shortest path from s to t;\n... and so on, including the computation of mere path lengths using the above.\n\n\nIn the end, all these versions are minor variations on the main algorithm, so use whichever one suits your needs.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Graphical tool for shortest path problem?\r\n                \r\nI need Graphical tool to display and edit the data of shortest path problem(or other Graph Theory problem), so anybody knows this tool? \n    ", "Answer": "\r\nHere is an applet I could find which illustrates Shortest Path problem. Select All items from the drop down, click example and step through it.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest Path Maximum Profit\r\n                \r\nSuppose you have an undirected Graph G=(V,E) and two vertices s,t in V, s not equal t. Every Edge e in E has a length and a profit. \n\nThe problem is:\nHow can I find a path P=(s,a1,a2,...,t) between s-t such that the total length of the path is the minimum possible and the profit is the maximum possible. \nWith Dijkstra I can find the first constraint, but How can I be sure for the second one? \n\nYou can do a backtrack but, Is there any faster algorithm? Any help is welcome.\n\nEDIT:\nFirst find the value x of the shortest path, then over the set of all the\npaths with the same length x, find one with the maximum profit.  \n\nSee this picture: \n    ", "Answer": "\r\nInstead of storing a single value for each candidate path in Dijkstra's algorithm, store a tuple of (total length, total profit). Consider a path shorter in the relaxation step if the total length is less, or the total lengths are the same but the total profit is higher.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Confused about Dijkstras shortest path and MST\r\n                \r\nIs Dijkstra's shortest path algorithm supposed to return a tree like it does in my textbook intro to algorithms? In examples I see online, it just shows the shortest path between 2 vertices. In my textbook it returns a tree with edges connected to every vertex. Im confused. \n    ", "Answer": "\r\nIt depends on the textbook you're using: Dijkstra's algorithm solves the single source shortest path problem, and storing the predecessor of each vertex in a shortest path is not a lot of additional work if you're computing those paths or their lengths anyway. So depending on the sources and the applications, you may read something like:\n\n\nDijkstraParents(G, s), which returns the parent of each vertex in a shortest path from s to any other vertex in graph G;\nDijkstraTree(G, s), which can use the result of DijkstraParents(G, s) to return the actual shortest path tree;\nDijkstraPath(G, s, t), which can use the result of DijkstraParents(G, s) or DijkstraTree(G, s) to explicitly return a shortest path from s to t;\n... and so on, including the computation of mere path lengths using the above.\n\n\nIn the end, all these versions are minor variations on the main algorithm, so use whichever one suits your needs.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Complexity of Dijkstra shortest path\r\n                \r\nI don't seem to understand Wikipedia's paragraph on why Dijkstra shortest path problem is ```\nO((|E|+|V|)*log(|V|))```\n\n\nSupposing that I used a binary heap, extracting all vertices would require V*logV, where does the E*logV term come from?\n\nCan somebody enlighten me please?\n    ", "Answer": "\r\nWhen you extract a vertex from the heap, you then need to examine all the edges coming out of that node and do some processing for each neighbour (decreasing key).\n\nThis means that we end up examining all edges during the entire algorithm, and may require O(logV) for each edge, so total of O(ElogV) in addition to the O(VlogV) cost for removing the minimum entry from the heap for each vertex.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Networkx Average shortest path with labels\r\n                \r\nI would like to calculate the average shortest path for nodes with the same label in a labeled graph. For instance, red is labeled A and black is labeled B. \n\n```\nG = nx.DiGraph()\nG.add_node('A', label = 'A')\nG.add_node('B', label = 'B')\nG.add_node('C', label = 'A')\nG.add_node('D', label = 'B')\nG.add_edges_from([('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'A')])\nH = G.to_undirected()\n```\n\n\n\n\nNow i just want to calculate the average shortest path for A, based on this\n\n\nV_m are the vertices with the same label. n_{i,j} is the number of shortest path and \nd_{i,j} is the geodesic distance.\n\nI would like to use Networkx to implement that. Starting to use the node attributes for the labeling.\n\nI can read out the nodes with their labels with \n\n```\ngraph_labels = (nx.get_node_attributes(G, 'label'))\n```\n\n\nNow i would just like to keep the key/value pair where the label is e.g. \"A\". So I can focus on the nodes with the same label. I hope that it is not to abstract but do you have any idea?\n\nThanks in advance.\n    ", "Answer": "\r\nSelect nodes by labels\n\n```\ndef select_nodes_by_label(G, lab):\n    return [node[0] for node in G.nodes(data='label') if node[1] == lab ]\n```\n\n\nThis returns a list of nodes that we can use to get the shortest paths of all combinations.\n\n```\nfrom itertools import combinations\n\ndef avg_shortest_path_labeled_node(G, lab):\n    sel_nodes = select_nodes_by_label(G,lab)\n    V_m = len(sel_nodes)\n\n    # collect all lengths of shortest paths from combinations of labeled nodes \n    sp_len = [len(nx.shortest_path(G,c[0], c[1]))  for c in combinations(sel_nodes,2)]\n    n = len(sp_len)\n    return sum(sp_len)/(n) * 1/(V_m * (V_m - 1))\n```\n\n\nTest\n\n```\navg_shortest_path_labeled_node(G,'A')\n```\n\n\n[out]:\n\n```\n1.5\n```\n\n\nIs it the result that you expect? It might be interesting to test this function on a more complex graph.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "SQL Graph shortest path example\r\n                \r\nProvide an example of using shortest path on SQL Server 2019. Technology is called SQL Graph.\n\n```\nCar -> BodyWork\n |\n V\nWheel -> Tyre\n```\n\n\nHow do we list all parts and the associated path coming down from the root ? \n    ", "Answer": "\r\n```\nCREATE TABLE PRODUCT (\n       ProductID int not null identity primary key,\n       ProductName varchar(50) \n) AS Node;\n\nINSERT INTO PRODUCT(ProductName) VALUES ('Car'),('BodyWork'),('Wheel'),('Tyre');\n\nSELECT * FROM PRODUCT;\n\nCREATE TABLE HAS_PART AS EDGE;\n\n\nINSERT INTO HAS_PART ($from_id, $to_id)\nVALUES ((SELECT $node_id FROM PRODUCT WHERE ProductId=1), (SELECT $node_id FROM PRODUCT WHERE ProductId=2))\n,((SELECT $node_id FROM PRODUCT WHERE ProductId=1), (SELECT $node_id FROM PRODUCT WHERE ProductId=3))\n,((SELECT $node_id FROM PRODUCT WHERE ProductId=3), (SELECT $node_id FROM PRODUCT WHERE ProductId=4));\n\nSELECT * FROM HAS_PART;\n\nSELECT\n       P1.ProductID,\n       P1.ProductName,\n       COUNT(P2.ProductName) WITHIN GROUP (GRAPH PATH) AS [Depth],\n       STRING_AGG(P2.ProductName,'->') WITHIN GROUP (GRAPH PATH) AS [Assembly],\n       LAST_VALUE(P2.ProductID) WITHIN GROUP (GRAPH PATH) AS [Final Product ID]\nFROM\n       PRODUCT P1,\n       PRODUCT FOR PATH P2,\n       HAS_PART FOR PATH HP\nWHERE MATCH(SHORTEST_PATH(P1(-(HP)->P2)+))\nAND P1.ProductID = 1\nORDER BY P1.ProductID;\n```\n\n\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path on a grid with obstacles [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nPlease help me finding the shortest path between two points on a 2d grid with obstacles.\nyou will be provide starting coordinates and end cordinates. Also you know where the obstacles are.\n    ", "Answer": "\r\nI suggest ```\nA* Pathfinding```\n.\n\nIt's a really neat algorithm that should do what you want.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Design an algorithm for the single-source shortest path problem [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has an answer here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Design an algorithm for the single source shortest path problem that runs in time O(k(|V|+|E|))\r\n                            \r\n                                (1 answer)\r\n                            \r\n                    \r\n                Closed 4 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nSuppose a directed graph G = (V, E) with potentially positive and negative edge lengths, but no negative cycles. Let s ∈ V be a given source vertex. How to design an algorithm for the single-source shortest path problem that runs in\ntime O k(|V | + |E|), if the shortest paths from s to any other vertex takes at most k edges, and we don't know what is k is.\n    ", "Answer": "\r\nHere`s O(k(|V | + |E|)) approach:\n\n\nWe can use Bellman-Ford algorithm with some modifications\nCreate array D[] to store shortest path from node s to some node u\ninitially D[s]=0, and all other D[i]=+oo (infinity)\nNow after we iterate throught all edges k times and relax them, D[u] holds shortest path value from node s to u after <=k edges\nSo if on some iteration we can't relax any edge, that means we have already reached iteration k+1 and we can terminate the algorithm because shortests paths won't improve\n\nPseudocode:\n\n```\n   for each vertex v in vertices:  \n       D[v] := +oo  \n\n D[s] = 0  \n lastRelaxation = 0  \n    for i in [1,n]:  \n    {  \n     for each edge (u, v) with weight w in edges:  \n           if D[u] + w < D[v]:  \n              {   \n              D[v] = D[u] + w  \n              lastRelaxation = i  \n              }  \n     if lastRelaxation != i) break;\n    }\n```\n\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Specific Graph and some claims on shortest path?\r\n                \r\nI stuck in one challenging question, I read on my notes. \n\nan Undirected, Weighted and Connected Graph ```\nG```\n, (without ```\nnegative```\n weight and all weights are ```\ndistinct```\n) is given, we know in this graph the shortest path between any two vertexes is on ```\nMinimum Spanning Tree```\n (MST). (for any pair of vertices and for any shortest path between them, it lies on MST). Which of The following Is ```\nTrue```\n?\n\n\n  1) Graph G is a Tree.\n  \n  2) weight of each {u,v} edge, at least is equal (same) to heaviest edge in shortest path from u to v. \n  \n  3) shortest path between any two vertex u, v is unique.\n  \n  4) suppose start from vertex ```\ns```\n, Prime (for calculating MST) and Dijkstra (for calculating shortest path), process and add the\n  vertexes into their Trees, with the same order. (two algorithm works with same order in processing and adding node)\n\n\nHow can verify me these options? This is a challenging question. \n    ", "Answer": "\r\n\nNo. For example: ```\nV = {1, 2, 3}```\n, ```\nE = {(1, 2, 1), (2, 3, 2), (1, 3, 4)}```\n(each edge is encoded as a tuple (one vertex, another vertex, weight)). It is not a tree, but all shortest path are on the minimum spanning tree.\nYes. If the weight of this edge is less than the weight of the heaviest edge which is in the shortest path, this edge is shorter than the shortest path(because there are no edges with negative weight). Thus, the shortest path is not the shortest. It is a contradiction.\nNo*. Let's assume that we have a graph with two vertices ```\n{1, 2}```\n and one edge between them with zero weight. There are infinitely many shortest paths between the first and the second vertex(```\n[1, 2], [1, 2, 1, 2], ...```\n)\n\n*However, there is a unique simple shortest path between any two vertices because there is only one simple path between any two vertices in a tree, any path which does not fully lie in a minimum spanning tree is longer  due to the problem statement and there is only one minimum spanning tree in a graph with distinct edges weights.\nNo. Consider this tree: ```\nV = {1, 2, 3, 4}```\n, ```\nE = {(1, 2, 3), (2, 3, 2), (1, 4, 4)}```\n. Let's assume that the start vertex is ```\n1```\n. Prim's algorithm will take the first vertex, than the second one, than the third one and only after this the fourth. But Dijkstra's algorithm will take the fourth vertex before the third one. It happens because the third vertex is located closer to the tree after processing the first two vertices, but it the total distance to it from the start node is larger.\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How do I calculate average shortest path of a network in Neo4J using cypher\r\n                \r\nI have 9 nodes in a directed network (all have at least 1 connection) so a total of 72 shortest paths. I want to find the average of the 72 shortest paths.\n\nHere is the code I used to find all shortest paths between a set of nodes (modified from https://community.neo4j.com/t/all-shortest-paths-between-a-set-of-nodes/241)\n\n```\nMATCH (p:Person)\nWITH collect(p) as nodes\nUNWIND nodes as n\nUNWIND nodes as m\nWITH * WHERE id(n)<id(m)\nMATCH path = allShortestPaths((n)-[:KNOWS*]-(m))\nRETURN length(path)\n```\n\n\nThe result at first looks to be correct. It has paths of 1, 2, 3, 4, 5, and 6. However, I noticed there are 408 results when there should only be 72. \n\nWould appreciate any insight into where I went wrong.\n    ", "Answer": "\r\n\nThe allShortestPaths function returns all shortest paths, so it can return multiple paths if they all have the same (shortest) length. To get just 1 shortest path, you should use the ```\nshortestPath```\n function instead.\nThe number of unique pairs of nodes out of 9 nodes is not 9*8 (or 72). It is half of that, or 36.\n\n\nThis query should return 36 results:\n\n```\nMATCH (p:Person)\nWITH collect(p) as nodes\nUNWIND nodes as n\nUNWIND nodes as m\nWITH n, m WHERE id(n)<id(m)\nMATCH path = shortestPath((n)-[:KNOWS*]-(m))\nRETURN length(path)\n```\n\n\nTo get the average length, just use this ```\nRETURN```\n clause instead:\n\n```\nRETURN AVG(length(path))\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Parallel BGL - Dijkstra shortest paths\r\n                \r\nI am currently trying to run a parallel Dijkstra shortest paths algorithm with the Parallel Boost Graph Library.\nIt is explained in detail, how it should be done, on this page: http://www.boost.org/doc/libs/1_65_1/libs/graph_parallel/doc/html/dijkstra_example.html\n\nHowever the first Problem I've encountered is, that my windows HPC MPI and boost 1.63 could not recognize the following line:\n\n\n  typedef mpi::process_group <mpi::immediateS> process_group_type;\n\n\nI've found out that one could use the boost::graph::distributed::mpi_process_group in this case. \n\nMy code looks like this, and as explained is almost identical to the tutorial, beside the one line:\n\n```\nusing namespace boost;\nusing boost::graph::distributed::mpi_process_group;\n\n\n\nint main(int argc, char *argv[]) {\n\n    boost::mpi::environment env(argc, argv);\n\n    typedef adjacency_list < listS, distributedS<mpi_process_group, vecS>,\n        directedS,\n        no_property,                 // Vertex properties\n        property<edge_weight_t, int> // Edge properties\n    > graph_t;\n    typedef graph_traits < graph_t >::vertex_descriptor vertex_descriptor;\n    typedef graph_traits < graph_t >::edge_descriptor edge_descriptor;\n\n    typedef std::pair<int, int> Edge;\n    const int num_nodes = 5;\n    enum nodes { A, B, C, D, E };\n    char name[] = \"ABCDE\";\n    Edge edge_array[] = { Edge(A, C), Edge(B, B), Edge(B, D), Edge(B, E),\n        Edge(C, B), Edge(C, D), Edge(D, E), Edge(E, A), Edge(E, B)\n    };\n    int weights[] = { 1, 2, 1, 2, 7, 3, 1, 1, 1 };\n    int num_arcs = sizeof(edge_array) / sizeof(Edge);\n\n    graph_t g(edge_array, edge_array + num_arcs, weights, num_nodes);\n    // Keeps track of the predecessor of each vertex\n    std::vector<vertex_descriptor> p(num_vertices(g));\n    // Keeps track of the distance to each vertex\n    std::vector<int> d(num_vertices(g));\n\n    vertex_descriptor s = vertex(A, g);\n    dijkstra_shortest_paths\n        (g, s,\n            predecessor_map(\n                make_iterator_property_map(p.begin(), get(vertex_index, g))).\n            distance_map(\n                make_iterator_property_map(d.begin(), get(vertex_index, g)))\n            );\n\n\n    std::cout << std::endl;\n\n    return EXIT_SUCCESS;\n\n}\n```\n\n\nNonetheless I still have an error:\n\n\n  ..boost_1_63_0\\boost\\graph\\distributed\\dijkstra_shortest_paths.hpp(116): error C2664: 'void boost::local_put,boost::default_color_type>(boost::dummy_property_map,const Key &,const Value &)': cannot convert argument 1 from 'boost::iterator_property_map>>,IndexMap,boost::default_color_type,boost::default_color_type &>' to 'boost::dummy_property_map'\n\n\nI've searched through many sites and I am considering right now to try another boost version or another mpi. Does the tutorial work as explained in the link,and does my code work, or did I do something completely wrong?\n\nThank you very much!\n\n\n\nAddendum: Problem was solved  \n\nSolution to this problem were basically two things:\n\n\nFirst of all, to check the includes, I included the boost directories in a wrong order, begin with serialization and continue...\nThe second factor are the libraries and the os. Boost Graph library in general seems to work much smoother on unix systems.\n\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Computing shortest path from complete graph [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                It's difficult to tell what is being asked here. This question is ambiguous, vague, incomplete, overly broad, or rhetorical and  cannot be reasonably answered in its current form. For help clarifying this question so that it can be reopened,  visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI have a matrice NxN where ```\nmatrice[i][j]```\n is a cost of a edge between vertex ```\ni```\n and ```\nf```\nj in a non-oriented graph.\n\nWhat I need to determine is the shortest path containing all of the\nvertexes in matrice.\n\nSo for input like:\n\n```\n0 198 67 368\n198 0 131 432\n67 131 0 301\n368 432 301 0\n```\n\n\nI need to try all posible paths and in this case:\n\n```\n0-->1-->2-->3-->0\n```\n\n\nis correct wich gives length 998.\n\nHow can I implement this?\n    ", "Answer": "\r\nYou are describing the Traveling Salesman Problem, which is widely studied.\n\nThough there are many ways to approximate a solution - the exact solution requires exponential run-time indeed, and brute force is one option to solve it (in O```\n(n!)```\n).\n\nThe idea is to generate all possible permutations and evaluate each - and find the minimal.\nThis question for example discusses how to generate all permutations. The same ideas apply to your problem.\n\nThere are some possible optimizations that can be done such as branch & bound technique - or using a smart DP solution.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Implementing shortest path in racket using BFS in a purely functional way?\r\n                \r\nHow would we go about implementing get the shortest path between the start vertex and the end vertex?\nThe program should return a list of edges (shortest path) using BFS.\n```\n(define (new-paths path node net)\n   (map (lambda (n) (cons n path)) (cdr (assoc node net))))\n(define (shortest-path start end net)\n    (bfs end (list (list start)) net))\n\n ;; Breadth-first search\n  (define (bfs end queue net)\n    (display queue) (newline) (newline) ; entertainment\n    (if (null? queue)\n      '()\n      (let ((path (car queue)))\n       (let ((node (car path)))\n         (if (equal? node end) ;; Graham used CL eql\n             (reverse path)\n             (bfs end \n                  (append (cdr queue)\n                          (new-paths path node net))\n                  net))))))\n```\n\nI came up with but this does not seem to work. Can someone provide an implementation in a purely functional way?\nIn the form (get-shortest-path vertices edges src dest)\nAn example of the call would be\n```\n(get-shortest-path '(a b c d) (cons (cons a b) (cons b c) (cons c d)) 'a 'c) \n; Get the shortest path between a and c\n```\n\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path between 2 nodes in DAG unweighed\r\n                \r\n```\n#include <bits/stdc++.h>\n\n#define MAX_NODES 1005\n#define INFINITE \nusing namespace std;\n\nvector<int> graph[MAX_NODES];\nint numOfVertices, numOfEdges;\n\nint shortest_path[MAX_NODES][MAX_NODES]; // shortest_path[i][j] holds the shortest path between i and j\n\nint k;\n\nint shortestPath(int i, int j) {\n    // k ++;\n    if (i == j) \n        shortest_path[i][j] = 1;\n\n    // if we didn't solve shortest_path between i and j before\n\n        // than solve it\n    if (!shortest_path[i][j]) {\n\n        int min_path = 10e6;\n        for (auto vertice : graph[i])\n            min_path = min(min_path, shortestPath(vertice, j) + 1);\n\n\n        shortest_path[i][j] = min_path;\n    }\n    return shortest_path[i][j];\n}\n\n// the graph will be directed\nvoid read() {\n    int x, y; // temporary variables to read vertices and store them in our \"graph\"\n    cin >> numOfVertices >> numOfEdges;\n\n    for (int i = 0;i < numOfEdges;i ++) {\n        cin >> x >> y;\n        graph[x].push_back(y);\n    }\n}\n\nvoid print() {\n    for (int i = 0;i < numOfVertices;i ++) {\n        if (graph[i].size())\n            cout << i << \" : \";\n        for (int j = 0;j < graph[i].size();j ++) {\n            cout << graph[i][j] << ' ';\n        }\n        if (graph[i].size())\n            cout << '\\n';\n    }\n}\n\n\nint main() {\n    freopen(\"input.in\", \"r\", stdin);\n    freopen(\"output.out\", \"w\", stdout);\n\n    // ios_base :: sync_with_stdio(false);\n    // cin.tie(NULL);\n    // cout.tie(NULL);\n\n    read();\n    // print();\n\n    int i = 1;\n    int j = 7;\n    int answer = shortestPath(i, j);\n\n    if (answer == 10e6)\n        printf(\"There are no paths between vertice %d and vertice %d\\n\", i, j);\n    else\n        printf(\"Shortest path between vertice %d and vertice %d ins: %d\\n\", i, j, answer - 1);\n\n    // cout << k << endl;\n    return 0;\n}\n```\n\n\nThe above program calculates the shortest path between 2 vertices in an unweighed DAG.\n\n\n  shortest_path[i][j] = shortest path between vertice i and vertice j.\n\n\nWhat's the complexity of the function ```\nint shortestPath(int i, int j)```\n ?\n\nI think is O(V + E) where V is number of vertices and E number of edges but I don't know how to prove it.\n    ", "Answer": "\r\nNotice that ```\nj```\n is not changing in function call so the complexity of the function depends only on ```\ni```\n.\n\n```\nshortest_path[i][j] = min_path```\n is accomplishing two things: saving the minimum path from ```\ni```\n to ```\nj```\n and marking ```\ni```\n visited (since j is not changing). Hence a vertex once visited will not be visited again.\n\nSo ```\nshortest_path```\n will be called for the different values ```\ni```\n can take let's call it ```\nN```\n which is the total number of vertices in the graph. Therefore the minimum time complexity will be atleast ```\nO(N)```\n. Inside each call, the for loop runs for ```\noutdegree of vertex i```\n. Now adding the for loop costs of all vertices, it will be ```\noutdegree of V1 + outdegree of V2 + ... + outdegree of Vn```\n which equals ```\nO(E)```\n. Hence total time complexity is ```\nO(N + E)```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How to find all shortest paths efficiently based on the cost in neo4j using cypher\r\n                \r\nHow to find all shortest paths efficiently based on the cost in neo4j (3.1.0) using cypher?\n\nMy current approach is to use ```\nallShortestPaths```\n and then order by\n\nSample Data\n\n```\n//node with cost\nMERGE (a:A{name:\"A\"})\nMERGE (b:A{name:\"B\"})\nMERGE (c:A{name:\"C\"})\nMERGE (d:A{name:\"D\"})\nMERGE (ee:A{name:\"E\"})\nMERGE (a) -[:R{cost:-4}]-> (b)\nMERGE (a) -[:R{cost:-1}]-> (c)\nMERGE (a) -[:R{cost:2}]-> (d)\nMERGE (b) -[:R{cost:5}]-> (ee)\nMERGE (d) -[:R{cost:-2}]-> (ee)\n```\n\n\nCypher\n\n```\n//list all paths with cost\nMATCH (n1),(n2) ,p=allShortestPaths((n1)-[*..10]->(n2))\nWITH \np,\nreduce(cost=0,x in relationships(p) | cost+x.cost) AS cost ,\nreduce(s=\"(\",x in nodes(p) | s+\"->\"+x.name)+\")\" AS path\nORDER BY cost DESC, LENGTH(p) DESC\nreturn path,cost\n```\n\n\nResult\n\n```\n╒═════════════╤══════╕\n│\"path\"       │\"cost\"│\n╞═════════════╪══════╡\n│\"(->B->E)\"   │\"5\"   │\n├─────────────┼──────┤\n│\"(->A->D)\"   │\"2\"   │\n├─────────────┼──────┤\n│\"(->A->B->E)\"│\"1\"   │\n├─────────────┼──────┤\n│\"(->A->D->E)\"│\"0\"   │\n├─────────────┼──────┤\n│\"(->A->C)\"   │\"-1\"  │\n├─────────────┼──────┤\n│\"(->D->E)\"   │\"-2\"  │\n├─────────────┼──────┤\n│\"(->A->B)\"   │\"-4\"  │\n└─────────────┴──────┘\n```\n\n\nSee\nhttp://console.neo4j.org/?id=lh5lym\n\nExecution Plan\n\n```\nTotal database accesses: 98\n```\n\n\nis this the correct way to find the shortest path based on cost or if  there is any better/efficient approach (when number of nodes and depth of path increases) ?\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "shortest path through a maze\r\n                \r\nI am working on a project that i must traverse a maze using the left-hand rule and based upon the intersections the program comes upon i need to create a node to connect to a graph that I will then determine the shortest path. The goal is for the program to run through the maze then close out the program and read from a file that contains the graph and determines the shortest path to the finish. what i have done is i can traverse the maze using the left-hand rule. what im thinking to do is create a node when i find the intersection and there after every time the program moves i increase the cost of that path by one. on a side note do you need to have an adjacency matrix when use dijkstra's algorithm? \n    ", "Answer": "\r\nTry something like this, it should work:\n\n\n0 - create an empty \"solution path\" stack of location objects.\n\n1 - if current position is maze exit, return \"solution path\" stack.\n\n2 - wall in front? turn left and repeat 2, else continue to 3.\n\n3 - if current position is at top of \"solution path\" stack, \n       pop it off of the stack\n       else push it onto the stack \n\n4 - move forward.\n\n\nWhen you're checking the top of the stack for the current position, you might need to check the element just before the very last one, since the last one will be the position you just left.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Google map. finding shortest path\r\n                \r\nIm having scenario like.\none place to another place route\nif the user in way of that route\nwe have to fine the which one is shortest path.\nThanks in advance..!\n    ", "Answer": "\r\nUse the travelling sales-man algorithm to find the shortest path.  This algorithm tells that how a salesman can travel all the different places with the total distance traveled equals to minimum from among all other routes. \n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How do I calculate average shortest path of a network in Neo4J using cypher\r\n                \r\nI have 9 nodes in a directed network (all have at least 1 connection) so a total of 72 shortest paths. I want to find the average of the 72 shortest paths.\n\nHere is the code I used to find all shortest paths between a set of nodes (modified from https://community.neo4j.com/t/all-shortest-paths-between-a-set-of-nodes/241)\n\n```\nMATCH (p:Person)\nWITH collect(p) as nodes\nUNWIND nodes as n\nUNWIND nodes as m\nWITH * WHERE id(n)<id(m)\nMATCH path = allShortestPaths((n)-[:KNOWS*]-(m))\nRETURN length(path)\n```\n\n\nThe result at first looks to be correct. It has paths of 1, 2, 3, 4, 5, and 6. However, I noticed there are 408 results when there should only be 72. \n\nWould appreciate any insight into where I went wrong.\n    ", "Answer": "\r\n\nThe allShortestPaths function returns all shortest paths, so it can return multiple paths if they all have the same (shortest) length. To get just 1 shortest path, you should use the ```\nshortestPath```\n function instead.\nThe number of unique pairs of nodes out of 9 nodes is not 9*8 (or 72). It is half of that, or 36.\n\n\nThis query should return 36 results:\n\n```\nMATCH (p:Person)\nWITH collect(p) as nodes\nUNWIND nodes as n\nUNWIND nodes as m\nWITH n, m WHERE id(n)<id(m)\nMATCH path = shortestPath((n)-[:KNOWS*]-(m))\nRETURN length(path)\n```\n\n\nTo get the average length, just use this ```\nRETURN```\n clause instead:\n\n```\nRETURN AVG(length(path))\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Parallel BGL - Dijkstra shortest paths\r\n                \r\nI am currently trying to run a parallel Dijkstra shortest paths algorithm with the Parallel Boost Graph Library.\nIt is explained in detail, how it should be done, on this page: http://www.boost.org/doc/libs/1_65_1/libs/graph_parallel/doc/html/dijkstra_example.html\n\nHowever the first Problem I've encountered is, that my windows HPC MPI and boost 1.63 could not recognize the following line:\n\n\n  typedef mpi::process_group <mpi::immediateS> process_group_type;\n\n\nI've found out that one could use the boost::graph::distributed::mpi_process_group in this case. \n\nMy code looks like this, and as explained is almost identical to the tutorial, beside the one line:\n\n```\nusing namespace boost;\nusing boost::graph::distributed::mpi_process_group;\n\n\n\nint main(int argc, char *argv[]) {\n\n    boost::mpi::environment env(argc, argv);\n\n    typedef adjacency_list < listS, distributedS<mpi_process_group, vecS>,\n        directedS,\n        no_property,                 // Vertex properties\n        property<edge_weight_t, int> // Edge properties\n    > graph_t;\n    typedef graph_traits < graph_t >::vertex_descriptor vertex_descriptor;\n    typedef graph_traits < graph_t >::edge_descriptor edge_descriptor;\n\n    typedef std::pair<int, int> Edge;\n    const int num_nodes = 5;\n    enum nodes { A, B, C, D, E };\n    char name[] = \"ABCDE\";\n    Edge edge_array[] = { Edge(A, C), Edge(B, B), Edge(B, D), Edge(B, E),\n        Edge(C, B), Edge(C, D), Edge(D, E), Edge(E, A), Edge(E, B)\n    };\n    int weights[] = { 1, 2, 1, 2, 7, 3, 1, 1, 1 };\n    int num_arcs = sizeof(edge_array) / sizeof(Edge);\n\n    graph_t g(edge_array, edge_array + num_arcs, weights, num_nodes);\n    // Keeps track of the predecessor of each vertex\n    std::vector<vertex_descriptor> p(num_vertices(g));\n    // Keeps track of the distance to each vertex\n    std::vector<int> d(num_vertices(g));\n\n    vertex_descriptor s = vertex(A, g);\n    dijkstra_shortest_paths\n        (g, s,\n            predecessor_map(\n                make_iterator_property_map(p.begin(), get(vertex_index, g))).\n            distance_map(\n                make_iterator_property_map(d.begin(), get(vertex_index, g)))\n            );\n\n\n    std::cout << std::endl;\n\n    return EXIT_SUCCESS;\n\n}\n```\n\n\nNonetheless I still have an error:\n\n\n  ..boost_1_63_0\\boost\\graph\\distributed\\dijkstra_shortest_paths.hpp(116): error C2664: 'void boost::local_put,boost::default_color_type>(boost::dummy_property_map,const Key &,const Value &)': cannot convert argument 1 from 'boost::iterator_property_map>>,IndexMap,boost::default_color_type,boost::default_color_type &>' to 'boost::dummy_property_map'\n\n\nI've searched through many sites and I am considering right now to try another boost version or another mpi. Does the tutorial work as explained in the link,and does my code work, or did I do something completely wrong?\n\nThank you very much!\n\n\n\nAddendum: Problem was solved  \n\nSolution to this problem were basically two things:\n\n\nFirst of all, to check the includes, I included the boost directories in a wrong order, begin with serialization and continue...\nThe second factor are the libraries and the os. Boost Graph library in general seems to work much smoother on unix systems.\n\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How to get path on Dijkstra Shortest Path\r\n                \r\nI have a graph implementation. My graph class is shown below:\n\n```\npublic class Graph<V> {\n\nprivate HashMap<V, ArrayList<Edge<V>>> adjacencyList;\n\n/**\n * This list holds all the vertices so that we can iterate over them in the\n * toString function\n */\nprivate ArrayList<V> vertexList;\n\nprivate boolean directed;\n\npublic Graph(boolean isDirected) {\n    directed = isDirected;\n    adjacencyList = new HashMap<V, ArrayList<Edge<V>>>();\n    vertexList = new ArrayList<V>();\n} \n}\n```\n\n\nAlso I have a method on my driver class which is to calculate shortest path from another vertice. It works quite fine and shows from one source vertice to all other vertices shortest path's weight:\n\n```\npublic static <V> HashMap<V, ArrayList<Sehir>> dijkstraShortestPath(Graph<V> graph, V source, V son) {\n    HashMap<V, Double> distances = new HashMap<V, Double>();\n\n    HashMap<V, ArrayList<Sehir>> path = new HashMap<V, ArrayList<Sehir>>();//This is not working!\n\n    //ArrayList<Sehir> arrList = new ArrayList<>();\n    ArrayList<V> queue = new ArrayList<V>();\n    ArrayList<V> visited = new ArrayList<V>();\n    queue.add(0, source);\n    distances.put(source, 0.0);\n    path.put(source, new ArrayList<>());\n    while (!queue.isEmpty()) {\n\n        V currentVertex = queue.remove(queue.size() - 1);\n        if(path.get(currentVertex)==null){\n            path.put(currentVertex, new ArrayList<>());\n        }\n\n\n        // to save time we initialize all the distances to infinity as we go\n        if (distances.get(currentVertex) == null) {\n            distances.put(currentVertex, Double.POSITIVE_INFINITY);\n        }\n        // if(distances.get(currentVertex))\n        for (V adjacentVertex : graph.getAdjacentVertices(currentVertex)) {\n\n            if (distances.get(adjacentVertex) == null) {\n                distances.put(adjacentVertex, Double.POSITIVE_INFINITY);\n            }\n            // if (!graph.getEdgeBetween(currentVertex,\n            // adjacentVertex).isGidebilirMi()) {\n            // // System.out.println(graph.getEdgeBetween(currentVertex,\n            // // adjacentVertex).toString());\n            // distances.put(adjacentVertex, Double.POSITIVE_INFINITY);\n            // }\n\n            // if the distance between the source and the adjacent vertex is\n            // greater than the distance between the source and the current\n            // vertex PLUS the weight between the current and adjacent\n            // vertex, then we have found a shorter path than already\n            // existed\n            if (true) {\n\n                if (distances.get(adjacentVertex) > graph.getDistanceBetween(currentVertex, adjacentVertex)\n                        + distances.get(currentVertex)) {\n\n                    distances.put(adjacentVertex,\n                            graph.getDistanceBetween(currentVertex, adjacentVertex) + distances.get(currentVertex));\n\n                    path.get(currentVertex).add((Sehir) adjacentVertex);\n                }\n            }\n\n            if (!visited.contains(adjacentVertex) && !queue.contains(adjacentVertex)) {\n                queue.add(0, adjacentVertex);\n            }\n        }\n        visited.add(currentVertex);\n\n    }\n    // since the above statments only added the vertices as needed,\n    // verticies that are completely unconnected to the source are not added\n    // yet, so this adds them now\n    for (V v : graph.getVertexList()) {\n        if (!distances.containsKey(v)) {\n            distances.put(v, Double.POSITIVE_INFINITY);\n        }\n    }\n\n    return path;\n}\n```\n\n\nHere, if I return distances, it works fine. But Path HashMap doesn't store right Information about path. How can I fix this? I want to get path, such as an object arrayList. By the way \"Sehir\" means \"City\" which is my objects on Graph.\n    ", "Answer": "\r\nuse following code (from  http://www.baeldung.com/java-dijkstra)\n\n1.define object to store graph\n\n```\npublic class Graph {\n\n    private Set<Node> nodes = new HashSet<>();\n\n    public void addNode(Node nodeA) {\n        nodes.add(nodeA);\n    }\n\n    // getters and setters \n}\n```\n\n\n2.define your node object\n\n```\npublic class Node {\n\n    private String name;\n\n    private List<Node> shortestPath = new LinkedList<>();\n\n    private Integer distance = Integer.MAX_VALUE;\n\n    Map<Node, Integer> adjacentNodes = new HashMap<>();\n\n    public void addDestination(Node destination, int distance) {\n        adjacentNodes.put(destination, distance);\n    }\n\n    public Node(String name) {\n        this.name = name;\n    }\n\n    // getters and setters\n}\n```\n\n\n3.calculating shortest path from source:\n\n```\npublic static Graph calculateShortestPathFromSource(Graph graph, Node source) {\n    source.setDistance(0);\n\n    Set<Node> settledNodes = new HashSet<>();\n    Set<Node> unsettledNodes = new HashSet<>();\n\n    unsettledNodes.add(source);\n\n    while (unsettledNodes.size() != 0) {\n        Node currentNode = getLowestDistanceNode(unsettledNodes);\n        unsettledNodes.remove(currentNode);\n        for (Entry < Node, Integer> adjacencyPair: \n          currentNode.getAdjacentNodes().entrySet()) {\n            Node adjacentNode = adjacencyPair.getKey();\n            Integer edgeWeight = adjacencyPair.getValue();\n            if (!settledNodes.contains(adjacentNode)) {\n                calculateMinimumDistance(adjacentNode, edgeWeight, currentNode);\n                unsettledNodes.add(adjacentNode);\n            }\n        }\n        settledNodes.add(currentNode);\n    }\n    return graph;\n}\n\nprivate static Node getLowestDistanceNode(Set < Node > unsettledNodes) {\n    Node lowestDistanceNode = null;\n    int lowestDistance = Integer.MAX_VALUE;\n    for (Node node: unsettledNodes) {\n        int nodeDistance = node.getDistance();\n        if (nodeDistance < lowestDistance) {\n            lowestDistance = nodeDistance;\n            lowestDistanceNode = node;\n        }\n    }\n    return lowestDistanceNode;\n}\n```\n\n\n4.calculate shortest path:\n\n```\nprivate static void CalculateMinimumDistance(Node evaluationNode,\n  Integer edgeWeigh, Node sourceNode) {\n    Integer sourceDistance = sourceNode.getDistance();\n    if (sourceDistance + edgeWeigh < evaluationNode.getDistance()) {\n        evaluationNode.setDistance(sourceDistance + edgeWeigh);\n        LinkedList<Node> shortestPath = new LinkedList<>(sourceNode.getShortestPath());\n        shortestPath.add(sourceNode);\n        evaluationNode.setShortestPath(shortestPath);\n    }\n}\n```\n\n\ntest some scenario such as follow:\n\n```\nNode nodeA = new Node(\"A\");\nNode nodeB = new Node(\"B\");\nNode nodeC = new Node(\"C\");\nNode nodeD = new Node(\"D\"); \nNode nodeE = new Node(\"E\");\nNode nodeF = new Node(\"F\");\n\nnodeA.addDestination(nodeB, 10);\nnodeA.addDestination(nodeC, 15);\n\nnodeB.addDestination(nodeD, 12);\nnodeB.addDestination(nodeF, 15);\n\nnodeC.addDestination(nodeE, 10);\n\nnodeD.addDestination(nodeE, 2);\nnodeD.addDestination(nodeF, 1);\n\nnodeF.addDestination(nodeE, 5);\n\nGraph graph = new Graph();\n\ngraph.addNode(nodeA);\ngraph.addNode(nodeB);\ngraph.addNode(nodeC);\ngraph.addNode(nodeD);\ngraph.addNode(nodeE);\ngraph.addNode(nodeF);\n\ngraph = Dijkstra.calculateShortestPathFromSource(graph, nodeA);\n```\n\n\nAlso you can use this implementation: https://gist.github.com/gennad/791938\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Algorithms - Shortest Path with Contingent Costs\r\n                \r\nI am looking for an efficient algorithm to solve the following problem :\n\nGiven a directed, weighted graph G = (V,E), a source vertex S, a destination vertex T, and M, a subset of V, It's required to find the shortest path from S to T.\nA special feature present in M is that each vertex in M, once 'visited', the weight of a certain edge changes to another value. Both the edge and the new weight will be given for each vertex in M. \n\nTo help in understanding the problem, I have drawn an example using mspaint. (sorry for the quality).\n\nIn this example, the 'regular' shortest path from S to T is 1000.\nHowever, visiting the vertex C will reduce the edge weight from 1000 to just 500, so the shortest path in this case is 200+100+500=800.\n    ", "Answer": "\r\nThis problem is NP-hard and it is clearly in NP. The proof is a relatively straightforward gadget reduction.\n\nThis more or less rules out making significant improvements on the trivial, brute force algorithm for this problem. So what exactly are you hoping for when you say \"efficient\" here?\n\n===\n\nProof\n\nIt might be that the problem statement has been unclear somehow so the version OP cares about isn't actually NP-complete. So I'll give some details of the proof.\n\nFor technical reasons, usually when we want to show a search problem is NP-hard we actually do it for an associated decision problem which is interreducible to the search problem. The decision problem here is \"Given a directed weighted graph as described with associated edge-weight changing data, and a numeric value V, does the shortest path have value at most V?\". Clearly, if you have an algorithm for the search problem, you can solve the decision problem easily, and if you have an algorithm for the decision problem, you can use it for the search problem -- you could use binary search essentially to determine the optimal value of V to precision greater than the input numbers, then alter the problem instance by deleting edges and checking if the optimal solution value changed in order to determine if an edge is in the path. So in the sequel I talk about the decision version of the problem.\n\nThe problem is in NP\n\nFirst to see that it is in NP, we want to see that \"yes\" instances of the decision problem are certifiable in polynomial time. The certificate here is simply the shortest path. It is easy to see that the shortest path does not take more bits to describe than the graph itself. It is also easy to calculate the value of any particular path, you just go through the steps of the path and check what the value of the next edge was at that time. So the problem is in NP.\n\nThe problem is NP-hard\n\nTo see that it is NP-hard we reduce from 3SAT to the decision problem. That is the problem of determining the satisfiability of a boolean formula in CNF form in which each clause has at most 3 literals. For a complete definition of 3SAT see here: https://en.wikipedia.org/wiki/Boolean_satisfiability_problem\n\nThe reduction which I will describe is a transformation which takes an instance of 3SAT and produces an input to the decision problem, with the property that the 3SAT instance is satisfiable if and only if the shortest path value is less than the specified threshold.\n\nFor any given 3SAT formula, the graph which we will produce has the following high-level structure. For each variable, there will be a \"cloud\" of vertices associated to it which are connected in certain ways, and some of those vertices are in M. The graph is arranged so that the shortest path must pass through each cloud exactly once, passing through the cloud for ```\nx1```\n first, then the cloud for ```\nx2```\n, and so on. Then, there is also a (differently arranged) cloud for each clause of the formula. After passing through the last variable's cloud, the path must pass through the clouds of the clauses in succession. Then it reaches the terminal.\n\nThe basic idea is that, when going through the cloud for variable ```\nxi```\n, there are exactly two different possible paths, and the choice represents a commitment to a truth value of ```\nxi```\n. All of the costs of the edges for the variable clouds are the same, so it doesn't directly affect the path value. But, since some of them are in M, the choice of path there changes what the costs will later in the clause clouds. The clause clouds enforce that if the variables we picked don't satisfy the clause, then we pay a price.\n\nThe variable cloud looks like this:\n\n```\n        *_*_*_*\n       /       \\\nEntry *         * Exit\n       \\       /\n        *_*_*_*\n```\n\n\nWhere, the stars are vertices, and the lines are edges, and all the edges are directed to the right, and the have same cost, we can take it to be zero, or if thats a problem they could all be one, it doesn't really matter. Here I showed 4 vertices on the two paths, but actually the number of vertices will depend on some things, as we will see.\n\nThe clause cloud looks like this:\n\n```\n        *\n       / \\\nEntry *_*_* Exit\n       \\ /\n        *\n```\n\n\nWhere, again all edges are directed to the right.\n\nEach of the 3 central vertices is \"labelled\" (in our minds) and corresponds to one of the three literals in the clause. All of these edges again have cost 0.\n\nThe idea is that when I go through the variable cloud, and pick a value for that variable, if I didn't satisfy the literal of some clause, then the cost of the corresponding edge in the clause cloud should go up. Thus, as long as at least I actually satisfied the clause I have a path from the entry to the exit which costs 0. And if every one of the literals was missed by this assignment, then I have to pay something larger than zero. Maybe, 100 or something, it doesn't really matter.\n\nGoing back to the variable cloud now, the variable cloud for ```\nxi```\n has ```\n2m```\n vertices in the middle part where ```\nm```\n is the number of clauses that ```\nxi```\n appears in. Then, depending whether it appears positively or negatively in the ```\nk```\n'th such clause, the ```\nk```\n'th vertex of the top or the bottom path is in ```\nM```\n and changes the edge in the corresponding clause cloud, to have cost 100 or whatever other fixed value.\n\nThe overall graph is made by simply pasting together the variable and clause clouds at their entry - exit nodes in succession. The threshold value is, say, 50.\n\nThe point is that, if there is a satisfying assignment to the 3SAT instance, then we can construct from it a path through the graph instance of cost 0, since we never pay anything in the vertex clouds, and we always can pick a path in each clause cloud where the clause was satsified and we don't pay anything there either. If there is no satisfying assignment to the 3SAT instance, then any path must get a clause wrong at some point and then pay at least 100. So if we set the threshold to 50 and make that part of the instance, the reduction is sound.\n\nIf the problem statement doesn't actually allow 0 cost edges, we can easily change the solution so that it only has positive cost edges. Because, the total number of edges in any path from start to finish is the same for every path. So if we add 1 to every edge cost, and take the threshold to be 50 + length instead, nothing is changed.\n\nThat same trick of adding a fixed value to all of the edges and adjusting the threshold can be used to see that the problem is very strongly inapproximable also, as pointed out by David Eisenstat in comments.\n\nRunning time implications\n\nIf you are economical in how many vertices you assign to each variable cloud, the reduction takes a 3SAT instance with ```\nn```\n variables (and hence input length ```\nO(n)```\n) also to a graph instance of ```\nO(n)```\n vertices, and the graph is sparse. (```\n100n```\n vertices should be way more than sufficient.) As a result, if you can give an algorithm for the stated problem with running time less than ```\n2^{o(n)}```\n on sparse graphs with ```\nn```\n vertices, it implies a ```\n2^{o(n)}```\n algorithm for 3SAT which would be a major breakthrough in algorithms, and would disprove the \"Exponential Time Hypothesis\" of Impagliazzo and Paturi. So you can't really hope for more than a constant-factor-in-the-exponent improvement over the trivial algorithm in this problem.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Maze shortest path c++\r\n                \r\nI need to calculate the distance and the path from one start point to another end point.\nhttp://coliru.stacked-crooked.com/a/b15078829f49df3c\n\n```\nint pathExists(char maze[][10], int sr, int sc, int er, int ec, int distance, int direction) {\n\n    /*if(maze[sr][sc] != '.') . es visitable, x pared\n        return 0;\n */\n int lmin=99, l;\n    if(maze[sr][sc] != '.') //You cannot visit it, or is wall or is @ visited\n        return 0;\n\n    if(sr == er  &&  sc == ec) {\n        display(maze); \n        cout << \"Distance to end point is:  \" << distance << endl; \n        //if ( lmin==l) PathBueno = PathInt;\n        for (int i = 0; i < PathInt.size(); i++) {\n            cout << PathInt[i];\n            }\n        return distance;\n    }\n    /*\n    if(distance == 15) {\n        cout << \"Cant make it in 15 steps\" << endl;\n        return 0;\n    }\n    */\n   // path.push_back(vertex);\n    //Path.append(direction);\n    PathInt.push_back(direction);\n    maze[sr][sc] = '@';  // anything non-'.' will do\n\n\n\n    //Row --  Norte\n    l = pathExists(maze, sr - 1, sc, er, ec, distance + 1,1);\n    if(l > 0 && l<lmin) {\n        lmin = l; \n       // Path.append(\"N\");\n    }\n    //Row ++  Sur\n    l = pathExists(maze, sr + 1, sc, er, ec, distance + 1,2);\n    if(l > 0 && l<lmin) {\n        lmin = l; \n        //Path.append(\"S\");\n    }\n\n    //Column --  Oeste\n    l = pathExists(maze, sr, sc - 1, er, ec, distance + 1,3);\n    if(l > 0 && l<lmin) \n        {\n        lmin = l; \n        //Path.append(\"W\");\n    }\n\n    //Column ++  Este\n    l = pathExists(maze, sr, sc + 1, er, ec, distance + 1,4);\n    if(l > 0 && l<lmin) \n    {\n        lmin = l; \n        //Path.append(\"E\");\n    }\n\n    maze[sr][sc] = '.'; //restore\n    PathInt.pop_back();\n    //if ( Path.size() > 2) Path.erase(Path.size() - 1);\n\n    return lmin;\n}\n```\n\n\nI've been trying lots of things. But I can't print or save in ```\nPathGood```\n the shortest path from one point to another.\nIn the example I want to move from 8.4 to 8.1... so the shortest path has 3 steps of distance and the path would be EEE or 333 (suppose 3 is EAST).\n\nVerifiable example:\n\n```\nint main() {\n    char maze[10][10] = {\n        {'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X'},\n        {'X', '.', '.', '.', '.', '.', '.', '.', '.', 'X'},\n        {'X', '.', 'X', 'X', 'X', 'X', '.', 'X', 'X', 'X'},\n        {'X', '.', '.', 'X', '.', 'X', '.', '.', '.', 'X'},\n        {'X', '.', '.', 'X', '.', '.', '.', 'X', '.', 'X'},\n        {'X', '.', 'X', 'X', '.', 'X', 'X', 'X', '.', 'X'},\n        {'X', '.', 'X', '.', '.', '.', '.', 'X', 'X', 'X'},\n        {'X', '.', '.', 'X', 'X', '.', 'X', 'X', '.', 'X'},\n        {'X', '.', '.', '.', '.', '.', '.', '.', '.', 'X'},\n        {'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X'}\n    };\n\n    Path.clear();\n\n    int  slen = pathExists(maze,8,4, 8, 1,0,0); \n\n\n\n\n    if(slen) {\n        cout << \"Solvable in \"<<slen<<\" steps !\" << endl;\n    //  cout << \"Complete path is : \" << Path;\n    //    std::cout << \"Complete path is : \" << PathGood;\n    }\n    else\n        cout << \"Out of luck!\" << endl;\n    cin.get();\n\n    //int len, i;\n  /*  len = (int)strlen(string);\n        for (int i = 0; i < PathBueno.size(); i++) {\n            cout << PathBueno[i];\n            }*/\n}\n```\n\n\nI'm trying to give some IA to ghosts in a pacman game. So I need to know the shortest distance in steps (avoiding walls) and then began to move.\n\nAny help would be appreciated...\n\nBy the way I'm trying to use DFS and I think BFS would be more efficient, so if anyone could help to convert it to BFS .. (it its true that BFS is better than DFS)\n\nNow I know whats the better solution, but I don't know which direction to take as the program can storage the best path.\n\nPS: \n\nI began trying to use string and append character and \"N\", \"W\", \"S\" and so on...\n    ", "Answer": "\r\nThe problem is that you do not store the shortest path (```\nPathMin```\n?).\n\nThere is more than one way to solve this problem. In your code, ```\npathExists```\n returns an ```\nint```\n which is the length of the shortest path. Instead, it could return a ```\nvector<int>```\n which is the shortest path.\n\nI think that BFS is better than DFS for this task; converting this code to a BFS will be difficult. I suggest you maintain a vector of locations, like a squad of searchers moving outward through the maze from the starting point. The searchers take turns moving; when a searcher has more than one move it can make, it splits into multiple searchers; when a searcher can make no move, it dies; when a searcher reaches the destination, the search ends.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Other uses of shortest path algorithm in Neo4j\r\n                \r\nI understand using the shortest path algorithm for find the fastest way to travel from node A to node Z, but in presentation by the ICIJ journalist at GraphConnect on the SwissLeaks data, how would the shortest path have been used to uncover spurious account activity?\n    ", "Answer": "\r\nYou probably would pick suspect nodes and see how they are connected, e.g. to mark other people between them also with a suspect weight which is incremented each time a person is on such a path.\n\nYou would probably use allShortestPaths then.\n\nAlso use shortest-path to compute betweenness centrality between a number of nodes. Which nodes are repeatedly found on paths between other nodes.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How to limit the number of shortest path in igraph/R\r\n                \r\nUsing the ```\nshortest.paths```\n function we get the shortest path from a graph. Now, I want to limit the length of the shortest path.\nFor example, when I am running the below code, I am getting all the shortest paths from a vertex to any vertex.\n```\ndf <- read.csv(\"~/data.csv\")\ng1 <- df\ngraph1 <- graph_from_data_frame(g1, directed = FALSE)\nplot(graph1, vertex.label = V(graph1)$name)\nmat <- shortest.paths(graph1)\n```\n\nThe output I am getting\n```\n       ID_1 ID_2 ID_3 ID_4 ID_8 ID_5 ID_7 ID_100\nID_1      0    1    1    1  Inf    2    2    Inf\nID_2      1    0    2    1  Inf    1    2    Inf\nID_3      1    2    0    2  Inf    3    1    Inf\nID_4      1    1    2    0  Inf    2    1    Inf\nID_8    Inf  Inf  Inf  Inf    0  Inf  Inf      1\nID_5      2    1    3    2  Inf    0    3    Inf\nID_7      2    2    1    1  Inf    3    0    Inf\nID_100  Inf  Inf  Inf  Inf    1  Inf  Inf      0\n```\n\nBut, I want to keep only (say) the path length is 3 and the other will be ```\n0 or Inf```\n. Actually, I do not need other except (path length =3).\nMoreover, I want the ```\nsum of the path weight```\n not only the number of the path. I thought I Can do this just by changing only one line\n```\nmat <- shortest.paths(graph1, weights=E(graph1)$weight)\n```\n\nBut, how can limit the path length?\nReproducible Data\n```\nstructure(list(nodeA = structure(c(1L, 1L, 1L, 2L, 2L, 3L, 4L, \n5L), .Label = c(\"ID_1\", \"ID_2\", \"ID_3\", \"ID_4\", \"ID_8\"), class = \"factor\"), \n    nodeB = structure(c(2L, 3L, 4L, 5L, 4L, 6L, 6L, 1L), .Label = c(\"ID_100\", \n    \"ID_2\", \"ID_3\", \"ID_4\", \"ID_5\", \"ID_7\"), class = \"factor\"), \n    weight = c(0.5, 0.77, 0.5, 0.9, 0.44, 0.32, 0.45, 0.543)), class = \"data.frame\", row.names = c(NA, \n-8L))\n```\n\n    ", "Answer": "\r\nRunning ```\nshortest.path```\n on the data you provided returns directly shortest path (the minimum sum of the path weight) for all nodes combinations.\n```\ng1 <- structure(list(nodeA = structure(c(1L, 1L, 1L, 2L, 2L, 3L, 4L, \n                                         5L), .Label = c(\"ID_1\", \"ID_2\", \"ID_3\", \"ID_4\", \"ID_8\"), class = \"factor\"), \n                     nodeB = structure(c(2L, 3L, 4L, 5L, 4L, 6L, 6L, 1L), .Label = c(\"ID_100\", \n                                                                                     \"ID_2\", \"ID_3\", \"ID_4\", \"ID_5\", \"ID_7\"), class = \"factor\"), \n                     weight = c(0.5, 0.77, 0.5, 0.9, 0.44, 0.32, 0.45, 0.543)), class = \"data.frame\", row.names = c(NA, \n                                                                                                                    -8L))\nlibrary(igraph)\n\ngraph1 <- graph_from_data_frame(g1, directed = FALSE)\nplot(graph1, vertex.label = V(graph1)$name)\n```\n\n\n```\nmat <- shortest.paths(graph1)\nmat\n#>        ID_1 ID_2 ID_3 ID_4  ID_8 ID_5 ID_7 ID_100\n#> ID_1   0.00 0.50 0.77 0.50   Inf 1.40 0.95    Inf\n#> ID_2   0.50 0.00 1.21 0.44   Inf 0.90 0.89    Inf\n#> ID_3   0.77 1.21 0.00 0.77   Inf 2.11 0.32    Inf\n#> ID_4   0.50 0.44 0.77 0.00   Inf 1.34 0.45    Inf\n#> ID_8    Inf  Inf  Inf  Inf 0.000  Inf  Inf  0.543\n#> ID_5   1.40 0.90 2.11 1.34   Inf 0.00 1.79    Inf\n#> ID_7   0.95 0.89 0.32 0.45   Inf 1.79 0.00    Inf\n#> ID_100  Inf  Inf  Inf  Inf 0.543  Inf  Inf  0.000\n\nlibrary(reshape)\n\nedges <- melt(mat)\nedges[as.character(edges$X1)>as.character(edges$X2)&!is.infinite(edges$value),]\n     X1     X2 value\n2  ID_2   ID_1 0.500\n3  ID_3   ID_1 0.770\n4  ID_4   ID_1 0.500\n6  ID_5   ID_1 1.400\n7  ID_7   ID_1 0.950\n11 ID_3   ID_2 1.210\n12 ID_4   ID_2 0.440\n14 ID_5   ID_2 0.900\n15 ID_7   ID_2 0.890\n20 ID_4   ID_3 0.770\n22 ID_5   ID_3 2.110\n23 ID_7   ID_3 0.320\n30 ID_5   ID_4 1.340\n31 ID_7   ID_4 0.450\n47 ID_7   ID_5 1.790\n61 ID_8 ID_100 0.543\n\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Generalization of the longest/shortest path algorithms (Bellman-Ford, Floyd-Warshall, Dijkstra)\r\n                \r\nI am looking into a problem of finding the shortest/longest paths in a graph with weighted edges (i.e. edges having length). The typical approaches are Belmann-Ford, Floyd-Warshall, and Dijkstra algorithms, which allow for significantly accelerated search (as compared to enumerating all the paths).\nI am interested in the generalizations of the above algorithms to the following cases:\n\nFinding suboptimal paths, i.e. not only the shortest path between two points, but the second shortest path, the third shortest path, etc.\nFinding the shortest/longest paths in a multigraph with parallel edges of different length\nCombination of the two.\n\nRegarding (2) I suppose that one could reduce the graph by choosing the shortest/longest branch between every pair of nodes and then apply the above mentioned algorithms. However, this approach would not work for (3).\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Find the shortest path for scanner\r\n                \r\nI am working on a nearfieldscanner and need to find a way to get the shortest path for the scannerhead.\n\nSuppose I want to use 13 points at once. \n\n\nThen I take the current position (point0) from the scanner and look for the nearest point (Point1).\nNow Point1 becomes the current position and I look for the nearest point to point1 -(point2).\nNow point2 becomes the current point and so on...\n\n\nOffcourse this isn't really the shortest path.\n\nThe scanner has to be able to handle 25points or more at once so permutations are not an option.\nIt takes 0.45s to travel 1cm and the surface is mostly 10x15cm.\n\nThe main goal is to win time and make the scan faster. \n\nThis has to be done in C# or Matlab.\n\nIs this possible? \n    ", "Answer": "\r\nThere is no mathematical \"solution\" except for brute forcing all possible combinations.\nhttp://en.wikipedia.org/wiki/Travelling_salesman_problem\n\nYou can try different algorithms to find a \"good\" solution (genetic algorithm, etc), but you will never be able to tell, if you found the BEST solution.\n\nOn SO see What is an NP-complete in computer science? for example\n\nEDIT\nSOMETIMES you can determine IF you have the BEST solution (except after trying all). But these are some rare special cases. If the \"length\" of your path equals the sum of the shortest distance of each point, you have found the optimum. Like all your points lying on a line and you go 1-2-3-n. But usually you can only find something that is NOT the best solution without knowing if there would be a better one.\n\nEDIT2\nAs an idea: If the main goal is not to \"waste\" any time, I'd do it like this: Select the first point, you want the scanner to move to. Start moving the scanner. WHILE the scanner moves (different thread), calculate the path with the NN algorithm. Now run a Monte Carlo algo on the path to find something better. When the scanner reaches the first point, stop the MC algo (Scanner needs to signal the MoveCompletetion!) and take the first point from the path as new Scanner target. Repeat the previous steps until you reached the last point.\nBy this, you are only using the time for calculating that the scanner needs for moving anyway. And since you always use the NN path as base, you'll never be worse, but sometimes (often?) be better. The algorithm could easily be done in parallel and therefore get better results on multicore machines.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How do you use a Bidirectional BFS to find the shortest path?\r\n                \r\nHow do you use a Bidirectional BFS to find the shortest path? Let's say there is a 6x6 grid.\nThe start point is in (0,5) and the end point is in (4,1). What is the shortest path using bidirectional bfs? There are no path costs. And it is undirected.\n    ", "Answer": "\r\nHow does Bi-directional BFS work?\n\nSimultaneously run two BFS's from both source and target vertices, terminating once a vertex common to both runs is discovered.  This vertex will be halfway between the source and the target.\n\nWhy is it better than BFS?\n\nBi-directional BFS will yield much better results than simple BFS in most cases.  Assume the distance between source and target is ```\nk```\n, and the branching factor is ```\nB```\n (every vertex has on average B edges).\n\n\nBFS will traverse ```\n1 + B + B^2 + ... + B^k```\n vertices.\nBi-directional BFS will traverse ```\n2 + 2B^2 + ... + 2B^(k/2)```\n vertices.\n\n\nFor large ```\nB```\n and ```\nk```\n, the second is obviously much faster the the first.\n\n\n\nIn your case:\n\nFor simplicity I am going to assume that there are no obstacles in the matrix. Here is what happens:\n\n```\niteration 0 (init):\nfront1 = { (0,5) }\nfront2 = { (4,1) }\n\niteration 1: \nfront1 = { (0,4), (1,5) }\nfront2 = { (4,0), (4,2), (3,1), (5,1) }\n\niteration 2:\nfront1 = { (0,3), (1,4), (2,5) }\nfront2 = { (3,0), (5,0), (4,3), (5,2), (3,2), (2,1) }\n\niteration 3:\nfront1 = { (0,2), (1,3), (2,4), (3,5) }\nfront2 = { (2,0), (4,4), (3,3), (5,3), (2,2), (1,1), }\n\niteration 4:\nfront1 = { (0,1), (1,2), .... }\nfront2 = { (1,2) , .... }\n```\n\n\nNow, we have discovered that the fronts intersect at (1,2), together with the paths taken to get there from the source and target vertices:\n\n```\npath1: (0,5) -> (0,4) -> (0,3) -> (0,2) -> (1,2)\npath2: (4,1) -> (3,1) -> (2,1) -> (1,1) -> (1,2)\n```\n\n\nWe now just need to reverse path 2 and append it to path 1 (removing one of the common intersecting vertices of course), to give us our complete path:\n\n```\n(0,5) -> (0,4) -> (0,3) -> (0,2) -> (1,2) -> (1,1) -> (2,1) -> (3,1) -> (4,1)\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "BFS to find all shortest paths between source S and multiple destination\r\n                \r\nI have an algorithm that can find a path between a source S and a destination D without passing by the vertice in N. Now I want to modify the algorithm to find all shortest paths between a source S and a multiple destination.\n```\n# Python implementation to find the\n# shortest path in the graph using\n# dictionaries\n\n# Function to find the shortest\n# path between two nodes of a graph\ndef BFS_SP(graph, start, goal,N):\n    explored = []\n    \n    # Queue for traversing the\n    # graph in the BFS\n    queue = [[start]]\n    \n    # If the desired node is\n    # reached\n    if start == goal:\n        print(\"Same Node\")\n        return []\n    \n    # Loop to traverse the graph\n    # with the help of the queue\n    while queue:\n        path = queue.pop(0)\n        node = path[-1]\n        \n        # Condition to check if the\n        # current node is not visited\n        if node not in explored and node not in N:\n            neighbours = graph.edges[node]\n            \n            # Loop to iterate over the\n            # neighbours of the node\n            for neighbour in neighbours:\n                new_path = list(path)\n                new_path.append(neighbour)\n                queue.append(new_path)\n                \n                # Condition to check if the\n                # neighbour node is the goal\n                if neighbour == goal:\n                    print(\"Shortest path = \", new_path)\n                    return new_path\n            explored.append(node)\n\n    # Condition when the nodes\n    # are not connected\n    print(\"So sorry, but a connecting\"\\\n                \"path doesn't exist :(\")\n    return []\n\n\n#BFS_SP(graph, 'A', 'D')\n```\n\n    ", "Answer": "\r\nYou only have to change your condition \"if neighbour == goal:\". When you reach that line you already have the shortest path for \"neighbour\" which is \"new_path\" and don't forget to add a condition at the beginning to print the shortest path when the target is the source.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Generalization of the longest/shortest path algorithms (Bellman-Ford, Floyd-Warshall, Dijkstra)\r\n                \r\nI am looking into a problem of finding the shortest/longest paths in a graph with weighted edges (i.e. edges having length). The typical approaches are Belmann-Ford, Floyd-Warshall, and Dijkstra algorithms, which allow for significantly accelerated search (as compared to enumerating all the paths).\nI am interested in the generalizations of the above algorithms to the following cases:\n\nFinding suboptimal paths, i.e. not only the shortest path between two points, but the second shortest path, the third shortest path, etc.\nFinding the shortest/longest paths in a multigraph with parallel edges of different length\nCombination of the two.\n\nRegarding (2) I suppose that one could reduce the graph by choosing the shortest/longest branch between every pair of nodes and then apply the above mentioned algorithms. However, this approach would not work for (3).\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "BFS to find all shortest paths between source S and multiple destination\r\n                \r\nI have an algorithm that can find a path between a source S and a destination D without passing by the vertice in N. Now I want to modify the algorithm to find all shortest paths between a source S and a multiple destination.\n```\n# Python implementation to find the\n# shortest path in the graph using\n# dictionaries\n\n# Function to find the shortest\n# path between two nodes of a graph\ndef BFS_SP(graph, start, goal,N):\n    explored = []\n    \n    # Queue for traversing the\n    # graph in the BFS\n    queue = [[start]]\n    \n    # If the desired node is\n    # reached\n    if start == goal:\n        print(\"Same Node\")\n        return []\n    \n    # Loop to traverse the graph\n    # with the help of the queue\n    while queue:\n        path = queue.pop(0)\n        node = path[-1]\n        \n        # Condition to check if the\n        # current node is not visited\n        if node not in explored and node not in N:\n            neighbours = graph.edges[node]\n            \n            # Loop to iterate over the\n            # neighbours of the node\n            for neighbour in neighbours:\n                new_path = list(path)\n                new_path.append(neighbour)\n                queue.append(new_path)\n                \n                # Condition to check if the\n                # neighbour node is the goal\n                if neighbour == goal:\n                    print(\"Shortest path = \", new_path)\n                    return new_path\n            explored.append(node)\n\n    # Condition when the nodes\n    # are not connected\n    print(\"So sorry, but a connecting\"\\\n                \"path doesn't exist :(\")\n    return []\n\n\n#BFS_SP(graph, 'A', 'D')\n```\n\n    ", "Answer": "\r\nYou only have to change your condition \"if neighbour == goal:\". When you reach that line you already have the shortest path for \"neighbour\" which is \"new_path\" and don't forget to add a condition at the beginning to print the shortest path when the target is the source.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path in 2d arrays\r\n                \r\n```\n*...*..D\n.G..*.....\n**...**.\n.S....*.\n........\n...G**..\n........\n.G..*...\n```\n\n\nHere is 2d array where\nS- SourceD-DestinationG-Point must be visited.\" . \"Free paths\"*\"Block PathsCan you help me which would be the efficient algorithm to find the length of shortest pathi in javaOnly Horizontal and Vertical movements are possiable\n    ", "Answer": "\r\nTo find the shortest distance from ```\nstart```\n point to all other points in the map, you can use a BFS.\nSample code:\n\n```\npublic void visit(String []map , Point start){\n        int []x = {0,0,1,-1};//This represent 4 directions right, left, down , up\n        int []y = {1,-1,0,0};\n        LinkedList<Point> q = new LinkedList();\n        q.add(start);\n        int n = map.length;\n        int m = map[0].length();\n        int[][]dist = new int[n][m];\n        for(int []a : dist){\n            Arrays.fill(a,-1);\n        }\n        dist[start.x][start.y] = 0;\n        while(!q.isEmpty()){\n            Point p = q.removeFirst();\n            for(int i = 0; i < 4; i++){\n                int a = p.x + x[i];\n                int b = p.y + y[i];\n                if(a >= 0 && b >= 0 && a < n && b < m && dist[a][b] == -1 && map[a].charAt(b) != '*' ){\n                    dist[a][b] = 1 + dist[p.x][p.y];\n                    q.add(new Point(a,b));\n                }\n            }\n        }\n    }\n```\n\n\nThe second path of the problem is actually a traveling salesman problem, so you need to convert from your original graph to a graph which ```\nonly contains G,D and S points```\n, with the ```\nweight```\n of each edge in this graph is the ```\nshortest path between them in original path```\n. From that onward, if the number of G is small (less than 17) you can use ```\ndynamic programming and bitmask```\n to solve the problem.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Find the shortest path for scanner\r\n                \r\nI am working on a nearfieldscanner and need to find a way to get the shortest path for the scannerhead.\n\nSuppose I want to use 13 points at once. \n\n\nThen I take the current position (point0) from the scanner and look for the nearest point (Point1).\nNow Point1 becomes the current position and I look for the nearest point to point1 -(point2).\nNow point2 becomes the current point and so on...\n\n\nOffcourse this isn't really the shortest path.\n\nThe scanner has to be able to handle 25points or more at once so permutations are not an option.\nIt takes 0.45s to travel 1cm and the surface is mostly 10x15cm.\n\nThe main goal is to win time and make the scan faster. \n\nThis has to be done in C# or Matlab.\n\nIs this possible? \n    ", "Answer": "\r\nThere is no mathematical \"solution\" except for brute forcing all possible combinations.\nhttp://en.wikipedia.org/wiki/Travelling_salesman_problem\n\nYou can try different algorithms to find a \"good\" solution (genetic algorithm, etc), but you will never be able to tell, if you found the BEST solution.\n\nOn SO see What is an NP-complete in computer science? for example\n\nEDIT\nSOMETIMES you can determine IF you have the BEST solution (except after trying all). But these are some rare special cases. If the \"length\" of your path equals the sum of the shortest distance of each point, you have found the optimum. Like all your points lying on a line and you go 1-2-3-n. But usually you can only find something that is NOT the best solution without knowing if there would be a better one.\n\nEDIT2\nAs an idea: If the main goal is not to \"waste\" any time, I'd do it like this: Select the first point, you want the scanner to move to. Start moving the scanner. WHILE the scanner moves (different thread), calculate the path with the NN algorithm. Now run a Monte Carlo algo on the path to find something better. When the scanner reaches the first point, stop the MC algo (Scanner needs to signal the MoveCompletetion!) and take the first point from the path as new Scanner target. Repeat the previous steps until you reached the last point.\nBy this, you are only using the time for calculating that the scanner needs for moving anyway. And since you always use the NN path as base, you'll never be worse, but sometimes (often?) be better. The algorithm could easily be done in parallel and therefore get better results on multicore machines.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Boost: Create Graph from shortest Path\r\n                \r\ncurrently i'm working with boost graph library.\nMy Graph consist of custom Vertex and Edge Properties: \n\n```\ntypedef boost::labeled_graph<boost::adjacency_list<\n    boost::listS, boost::vecS, boost::directedS, Vertex, Edge>, int> Graph;\n Graph g;```\n\n\nI need the functionality of calculating the shortest Path (Dijkstra), thereby the user has to select one or multiple start and end nodes. After selecting the Nodes and calculating the shortest path between every start and end node, a new graph should be created. In the end, the new graph should contain all vertices/edges which are lying on every shortest path.  \n\nMy idea was:\n\n1: I do a backtracking of the calculated shortest Path of type\n\n```\n   typedef std::vector< VertexDescriptor> Path;\n```\n\n\n2: I check if the vertex is already contained in the new Graph. (I dont know how to handle that one), if so i copy the vertex into the new Graph.\n\n3: I check if the edge is already contained in the new Graph, if so i copy the edge into the new Graph. \n\n```\nGraph graphPaths;\nPath::reverse_iterator rit;\nVertexDescriptor lastNode = *path.rbegin();\n\nfor (rit = path.rbegin(); rit != path.rend(); ++rit) {\n   //   Vertex v =\n        // check if vertices already exist in new GraphPath\n    if (graphPaths[indexMap[*rit]] == NULL) {\n        Vertex v = g[indexMap[*rit]];\n        VertexDescriptor vd = boost::add_vertex(indexMap[*rit], graphPaths);\n        graphPaths[indexMap[*rit]] = v;\n    }\n\n    // check if edge is already included in new Graph\n        if (!boost::edge(lastNode, *rit, graphPaths).second) {\n\n        Graph::edge_descriptor ep = boost::edge(lastNode, *rit, g).first;\n        boost::add_edge_by_label(indexMap[lastNode], indexMap[*rit], g[ep],\n            graphPaths);\n        }\n\n    }\n    lastNode = *rit;\n}\n```\n\n\nHow can i check the presence of a Vertex in a Graph. Do you have other ideas to improve the process or solve the issue.\n\nThanks\nMichael\n    ", "Answer": "\r\nI'd consider doing a filtered_graph adaptor on the original graph, filtering out all vertices/edges not visited in the interesting paths.\n\nThen it's a a simple ```\ncopy_graph```\n to create the new graph. \n\nIf  you change the graph type to a ```\nlabeled_graph```\n of the ```\nfiltered_graph```\n then you don't even need the copy, depending on your performance trade-offs.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path between a source and multiple destinations\r\n                \r\nI have a Neo4j graph which looks like this\n\nIt has a hierarchy of relations using the CHILD_OF relationship.\nAll the green nodes (see) are entitlements on Books.\nAll the books which a parent can see are also visible to the child but not the other way round.\nAlso, there is a possibility for child to see the books directly without involving the parent.\nThe ask here is to find the shortest path from the Child to the books.\nIn this case C1 has 2 paths (via entitlements) to Book1 but only 1 to Book2. And none to Book3.\n\nThe Neo4j Cypher query should return only the shortest paths from C1 to all the books.\nI tried using the Neo4j shortestPath function but it does not work.\n```\nMATCH (c:Child {name:'C1'} ),\n  (b:Book),\n  p = shortestPath((c)-[*]-(b))\nRETURN p\n```\n\nOutput of this query returns this:\n\nDesired final graph should look like this:\n\n    ", "Answer": "\r\nYou need to make the relationship to be directional from Child to Book.  This is because when you put *, it will include a path from book3 to library which you don't need.\n```\nMATCH (c:Child {name:'C1'} ),\n  (b:Book),\n  p = shortestPath((c)-[*]->(b))\nRETURN p\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Mapbox Shortest path for routing API\r\n                \r\nFor \"driving-traffic\" or \"driving profile\" i need to fetch shortest path from point A to B. Does \"alternatives\" option helps or am i missing something.\n    ", "Answer": "\r\nYou indeed can use alternatives. There are more options to play with incl. Avoid highways.. no ferry ( might be shorter but higher cost (time schedule)\nA route calculation gives back total time and distance, so play around with it!\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path on a sphere direction descision\r\n                \r\nI'm trying to write an algorithm that does the following.\n\nGiven a current position (in Azimuth and Inclination) and a target position (again in A, I) in what direction should I travel to travel over the shortest path. The return value could be something like a vector A = -1, I = +0.5, that I can then scale for step size/time.\n\nThe shortest path can be found by using a great circle, this is easy to visualize, but it's hard to implement like above because my coordinate system isn't continuous.\n\nMy coordinate system is as followed (imagine standing in front of the sphere)\n\nThe azimuth is 0 ~ pi when traveling along the equator along the front side, it's 0 ~ -pi when traveling along the equator along the rear side.\n\nThe inclination is 0~+pi when traveling from the top to the bottom of the sphere.\n\nSo given this non-continuous coordinate system, how do I create a decision function that says 'increase A' to travel over the shortest path?\n    ", "Answer": "\r\nYou have a couple of alternatives.  The first is to use a Haversine formulation.  There is some Javascript source code here.  It requires using more traditional lat / lon where the equator is at 0 latitude and the poles are at +/- π or +/- 90° latitude (depending on your units) and longitude is in the range [-180°, 180°) or [-π, π) again depending on your units.  You can repeatedly find the midpoint until you have an approximate path that suites your needs.  The azimuth / inclination vector would just be the difference in lat / lon between two adjacent points, though over time this will likely induce an error if you repeatedly apply those lat / lon deltas to the location of your agent.\n\nAnother approach that may work well for you is to transform your spherical coordinates of your starting and ending location to cartesian coordinates, call them points ub and ue for beginning and end points.  The normal vector v of the great circle connecting the two points is the cross product of the two (i.e. v = ub x ue) and the angle θ is just the arccosine of the normalized inner product (ie. θ = cos-1( (ue ∙ ue) / (|ub||ue)).  You can then use quaternion rotation and iterate from 0 to θ about the vector v to actually navigate the path.  With this approach, the actual instantaneous vector at some point p along the path is just the p x v, or you can just approximate this by using the cartesian difference between two adjacent points along the path.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Slow neo4j Cypher Queries, using Baconator query for less-short paths than shortest path\r\n                \r\nI have an indexed neo4j DB with 200,000 nodes and close to 4 million relationships (two types of relationships). Using the C# API, I am trying to do a \"Baconator\" type of query that not only gives me the shortest path, but gives me the some of the other shorter paths. (E.g. If the shortest path has 3 nodes, I would also like to see the other runner-up results of length 4, 5.. ect.).\n\nThis is the query I use first (in C# call):\n\n```\nstring whereClause = \"a.Id='\" + userId.ToUpper() + \"' and b.Id='\" + targetId.ToUpper() + \"'\";\n\n            var query = graphClient.Cypher\n                .Match(\"p=allShortestPaths((a:Person)-[*..6]-(b:Person))\")\n                .Where(whereClause)\n                .ReturnDistinct<List<Person>>(\"nodes(p)\").Limit(5);\n```\n\n\nThis only gives me the paths of the shortest length. To get the other less-short paths, I am using the following:\n\n```\n//nextDegree starts at the degree of the shortest path\nwhile (nextDegree <= 6)\n{\n    var auxiliaryQuery = graphClient.Cypher\n                    .Match(\"p=(a:Person)-[*\" + (nextDegree) + \"..\" + (nextDegree) + \"]-(b:Person)\")\n                    .Where(whereClause)\n                    .ReturnDistinct<List<Person>>(\"nodes(p)\").Limit(limit);\n}\n```\n\n\nThis works, but performance takes quite a hit, as queries take over 30 seconds when reaching length of 5, and minutes when reaching 6.\n\nMy question is: Is there a way I can optimize this? (Either by using the simple path algorithm within Cypher or other methods)\n    ", "Answer": "\r\nHave a look at this plugin to the GraphAware Framework which has been written precisely for this use case. It finds increasingly longer shortest paths. It hasn't been properly released yet, but it's ready to go and fully tested, you'll just have to build it yourself (get in touch if you need help). \n\nOnce built, it's a matter of dropping jar files into the plugins directory and calling a REST API.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest Path between two matrices\r\n                \r\nI have two distance matrices with overlapping variable names.\n\ndfA:\n\n```\n    Start   A1  A2  A3  A4  … A150\nLocation                        \nA           12  4   12  2      9\nB           5   2   19  4      3\nC           1   4   8   7      12\n```\n\n\ndfB:\n\n```\n    A   B   C           \nX   4   12  32          \nY   1   6   12          \nZ   2   8,5 11\n```\n\n\nSo from start A1, A2, etc. through ABC there are paths to X, Y and Z\n\nI would like to see what is the shortest path for an item, for example the the combination A1 -> Z. I programmed this by loading csv's with the distance matrices and unstack them. Then with df.itterows() and two for loops loop through the possible combinations and see what the smallest is for the combination A1 -> Z.\n\nBut since i have to do this for around 30000 items, it takes way to long. \n\nAnybody know how to do this in a vectorized way? \n    ", "Answer": "\r\nI added ```\nD```\n so that the axis lengths will be different (```\ndfB```\n won't be square matrix) just for my convenience (it works with square matrices too).\n\n```\nimport pandas as pd\nimport numpy as np\ndf_a = pd.read_csv('dfA.csv', delim_whitespace=True, index_col=0, decimal=\",\")\ndf_b = pd.read_csv('dfB.csv', delim_whitespace=True, index_col=0, decimal=\",\")\nmat_a = df_a.values\nmat_b = df_b.values\nmat_a2 = np.expand_dims(mat_a, axis=2)\nmat_b2 = np.expand_dims(mat_b.T, axis=1)\nmat_a3 = np.tile(mat_a2, (1, 1, mat_b.shape[0]))\nmat_b3 = np.tile(mat_b2, (1, mat_a.shape[1], 1))\ntot = mat_a3 + mat_b3\nind = np.argmin(tot, axis=0).T\ndf_c = pd.DataFrame(df_b.columns.values[ind], columns=df_a.columns, index=df_b.index)\nprint(df_c)\n```\n\n\ndfA:\n\n```\nStart_Location   A1  A2  A3  A4  A150\nA                12  4   12  2      9\nB                5   2   19  4      3\nC                1   4   8   7      12\nD                5   2   9   11     4\n```\n\n\ndfB:\n\n```\n    A   B   C   D\nX   4   12  32  11,4\nY   1   6   2  9,3\nZ   2   8,5 11  1,4\n```\n\n\ndfC:\n\n```\n  A1 A2 A3 A4 A150\nX  A  A  A  A    A\nY  C  A  C  A    B\nZ  D  D  D  A    D\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Algorithm for shortest path between 2 vertices\r\n                \r\nI have a weighted Graph with all positive weights.I need to find the shortest path from vertex x to vertex y. Should I prefer in this case the Floyd–Warshall algorithm  over Dijkstra's algorithm since I'm not interested in shortest path from a single source to all vertices but just between specific 2. I can restrict Floyd–Warshall to care only about the 2 vertices of interest, x and y. In that case it looks to me that Floyd–Warshall can find he shortest path from vertex x to vertex y in O(|V|).\n\nIs that correct ?\n\nThanks!\n    ", "Answer": "\r\nI would recommend a breadth-first search starting at both ends in parallel.  With a hash of nodes visited so that you know when the searches met.\n\nAssuming a random graph with decent connectivity, your average run-time will be on the order of sqrt(V).\n\nThis is a common trick to use to find, for example, the distance between two people in a social graph without having to look at most of it.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest Path to accomplish given scenario\r\n                \r\nI was asked in an interview to code the following scenario\n\nA tv has 0-450 channels but the remote buttons 2,5,8,9 have malfunctioned so write \na program to get input from the user and traverse that channel through the shortest path\n\nEXAMPLE:\n\n\n  47 -> no need to traverse button 4,7 is available\n  \n  45 -> 44+1 output from which channel to traverse and how many traversal\n  required to reach 45.\n  \n  55 -> 55 can be reached from 47 only coz 54 has 5. |||ly (50-55) has 5\n  in it so again 48 and 49 has 8 and 9 respectively.\n\n\nI've tried my logic but not even able to code in such a way it is best shortest path for all input PLEASE help me with the logic or show me the program.\n    ", "Answer": "\r\nThink in another way. A valid solution can only be formed by valid digits. \n\n\n\n\nBuild a valid button set by remove malfunctioned buttons from all possible buttons\n\n\n  0,1,3,4,6,7\n\nFind first invalid digit of the channel number from left to right. If found, go to step 3. Otherwise, no need to traverse button.\nGenerate two numbers nearest to the channel number on both side with valid button set only.\n\n\n  For example: channel number = 189\n  \n  Blind all digits on the right of first invalid digit -> 18x\n  \n  Upper bound: Look for a slightly bigger digit of 8 from valid set, but not found. In such case, we look for a bigger valid digit of 1, we get 3. Then pad smallest valid digit for the rest. We get 300.\n  \n  Lower bound: Look for a slightly smaller digit of 8 from valid set, we get 7. Then pad largest valid digit for the rest. We get 177.\n\nConsider boundary case if lower or upper bound cannot be formed (channel number 450 should get 0 as valid solution) and out of upper limit\nCompare the two numbers with the channel number and obtain the closest one.\nFormat and Output\n\n\n\n\nTime complexity: O(log(n)) for all cases\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Find a shortest path for a directed graph\r\n                \r\nThere is a directed graph ```\nG = [V ; E]```\n with edge weights ```\nw(u, v)```\n for ```\n(u, v) ∈ E```\n.\n\nSuppose the values for ```\n{d[v], π[v]}; v ∈ V```\n and claims\n\nthat these are the length of the shortest path and the predecessor node in\n\nit for ```\nv ∈ V```\n , how could I verify if this statement is true or false that does not solve the entire shortest path problem from scratch? This is an problem I met with not many ideas in my head ..\n    ", "Answer": "\r\nThe problem is a bit unclear, but to clarify:\n\nThere's a node ```\ns```\n in your graph, and that for each vertex ```\nv```\n:\n\n\nfor ```\nv != s```\n, ```\npi[v]```\n is intended to be a node adjacent to ```\nv```\n that's on a shortest path from ```\nv```\n to ```\ns```\n.\n```\nd[v]```\n is intended to store the shortest distance from ```\nv```\n to ```\ns```\n.\n\n\nThe problem is to verify, given a ```\npi```\n, ```\nd```\n, that they legitimately contain back-edges and minimal distances.\n\nAn easily implemented condition that verifies this is as follows:\n\n```\nFor each vertex v\n   Either:\n      v = s and d[v] = 0\n   Or:\n     d[pi[v]] = d[v] - 1\n     d[u] >= d[v] - 1 for each u adjacent to v\n     pi[v] is adjacent to v\n```\n\n\nThis check runs in O(V + E) time.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Finding the shortest paths of a directed graph C++\r\n                \r\nOver the last week, I have implemented a Digraph by parsing an input file. The graph is guaranteed to have no cycles. I have successfully created the graph, used methods to return the number of vertices and edges, and performed a topological sort of the graph. The graph is composed of different major courses and their prereqs. Here is my graph setup:\n\n```\nclass vertex{\npublic:\n    typedef std::pair<int, vertex*> ve;     \n    std::vector<ve> adjacency;              \n    std::string course;                     \n    vertex(std::string c){\n        course = c;\n    }\n};\n\nclass Digraph{\npublic:\n    typedef std::map<std::string, vertex *> vmap;           \n    vmap work;\n    typedef std::unordered_set<vertex*> marksSet;           \n    marksSet marks;\n    typedef std::deque<vertex*> stack;                      \n    stack topo;\n    void dfs(vertex* vcur);                                 \n    void addVertex(std::string&);                           \n    void addEdge(std::string& from, std::string& to, int cost);     \n    int getNumVertices();                                   \n    int getNumEdges();                                      \n    void getTopoSort();                                     \n\n};\n```\n\n\nThe implementation\n\n```\n//function to add vertex's to the graph\nvoid Digraph::addVertex(std::string& course){\n    vmap::iterator iter = work.begin();\n    iter = work.find(course);\n    if(iter == work.end()){\n        vertex *v;\n        v = new vertex(course);\n        work[course] = v;\n        return;\n    }\n}\n\n//method to add edges to the graph\nvoid Digraph::addEdge(std::string& from, std::string& to, int cost){\n    vertex *f = (work.find(from)->second);\n    vertex *t = (work.find(to)->second);\n    std::pair<int, vertex *> edge = std::make_pair(cost, t);\n    f->adjacency.push_back(edge);\n}\n\n//method to return the number of vertices in the graph\nint Digraph::getNumVertices(){\n    return work.size();\n}\n\n//method to return the number of edges in the graph\nint Digraph::getNumEdges(){\n    int count = 0;\n    for (const auto & v : work) {\n         count += v.second->adjacency.size();\n     }\n     return count;\n}\n\n//recursive function used by the topological sort method\nvoid Digraph::dfs(vertex* vcur) {\n  marks.insert(vcur);\n  for (const auto & adj : vcur->adjacency) {\n    vertex* suc = adj.second;\n    if (marks.find(suc) == marks.end()) {\n      this->dfs(suc);\n    } \n  }\n  topo.push_front(vcur);\n}\n\n//method to calculate and print out a topological sort of the graph\nvoid Digraph::getTopoSort(){\n    marks.clear();\n    topo.clear();\n    for (const auto & v : work) {\n        if (marks.find(v.second) == marks.end()) {\n            this->dfs(v.second);\n        }\n    }\n    // Display it\n   for (const auto v : topo) {\n    std::cout << v->course << \"\\n\";\n  }\n}\n```\n\n\nFor the last part of my implementation, I have been trying to do 2 things. Find the shortest path from the first vertex to every other vertices, and also find the shortest path that visits every vertex and returns to the first one. I am completely lost on this implementation. I assumed from reading I need to use Dijkstra's algorithm to implement this. I have been trying for the last 3 days to no avail. Did i set up my digraph in a bad way to implement these steps? Any guidance is appreciated.\n    ", "Answer": "\r\nThe fact that there are no cycles makes the problem much simpler. Finding the shortest paths and a minimal \"grand tour\" are O(n).\n\nImplement Dijkstra and run it, without a \"destination\" node; just keep going until all nodes have been visited. Once every node has been marked (with its distance to the root), you can start at any node and follow the shortest (and only) path back to the root by always stepping to the only neighbor whose distance is less than this one. If you want, you can construct these paths quite easily as you go, and mark each node with the full path back to the root, but copying those paths can push the cost to O(n2) if you're not careful.\n\nAnd once all the nodes are marked, you can construct a minimal grand tour. Start at the root; when you visit a node, iterate over its unvisited neighbors (i.e. all but the one you just came from), visiting each, then go back the one you came from. (I can put this with more mathematical rigor, or give an example, if you like.)\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Finding the shortest paths of a directed graph C++\r\n                \r\nOver the last week, I have implemented a Digraph by parsing an input file. The graph is guaranteed to have no cycles. I have successfully created the graph, used methods to return the number of vertices and edges, and performed a topological sort of the graph. The graph is composed of different major courses and their prereqs. Here is my graph setup:\n\n```\nclass vertex{\npublic:\n    typedef std::pair<int, vertex*> ve;     \n    std::vector<ve> adjacency;              \n    std::string course;                     \n    vertex(std::string c){\n        course = c;\n    }\n};\n\nclass Digraph{\npublic:\n    typedef std::map<std::string, vertex *> vmap;           \n    vmap work;\n    typedef std::unordered_set<vertex*> marksSet;           \n    marksSet marks;\n    typedef std::deque<vertex*> stack;                      \n    stack topo;\n    void dfs(vertex* vcur);                                 \n    void addVertex(std::string&);                           \n    void addEdge(std::string& from, std::string& to, int cost);     \n    int getNumVertices();                                   \n    int getNumEdges();                                      \n    void getTopoSort();                                     \n\n};\n```\n\n\nThe implementation\n\n```\n//function to add vertex's to the graph\nvoid Digraph::addVertex(std::string& course){\n    vmap::iterator iter = work.begin();\n    iter = work.find(course);\n    if(iter == work.end()){\n        vertex *v;\n        v = new vertex(course);\n        work[course] = v;\n        return;\n    }\n}\n\n//method to add edges to the graph\nvoid Digraph::addEdge(std::string& from, std::string& to, int cost){\n    vertex *f = (work.find(from)->second);\n    vertex *t = (work.find(to)->second);\n    std::pair<int, vertex *> edge = std::make_pair(cost, t);\n    f->adjacency.push_back(edge);\n}\n\n//method to return the number of vertices in the graph\nint Digraph::getNumVertices(){\n    return work.size();\n}\n\n//method to return the number of edges in the graph\nint Digraph::getNumEdges(){\n    int count = 0;\n    for (const auto & v : work) {\n         count += v.second->adjacency.size();\n     }\n     return count;\n}\n\n//recursive function used by the topological sort method\nvoid Digraph::dfs(vertex* vcur) {\n  marks.insert(vcur);\n  for (const auto & adj : vcur->adjacency) {\n    vertex* suc = adj.second;\n    if (marks.find(suc) == marks.end()) {\n      this->dfs(suc);\n    } \n  }\n  topo.push_front(vcur);\n}\n\n//method to calculate and print out a topological sort of the graph\nvoid Digraph::getTopoSort(){\n    marks.clear();\n    topo.clear();\n    for (const auto & v : work) {\n        if (marks.find(v.second) == marks.end()) {\n            this->dfs(v.second);\n        }\n    }\n    // Display it\n   for (const auto v : topo) {\n    std::cout << v->course << \"\\n\";\n  }\n}\n```\n\n\nFor the last part of my implementation, I have been trying to do 2 things. Find the shortest path from the first vertex to every other vertices, and also find the shortest path that visits every vertex and returns to the first one. I am completely lost on this implementation. I assumed from reading I need to use Dijkstra's algorithm to implement this. I have been trying for the last 3 days to no avail. Did i set up my digraph in a bad way to implement these steps? Any guidance is appreciated.\n    ", "Answer": "\r\nThe fact that there are no cycles makes the problem much simpler. Finding the shortest paths and a minimal \"grand tour\" are O(n).\n\nImplement Dijkstra and run it, without a \"destination\" node; just keep going until all nodes have been visited. Once every node has been marked (with its distance to the root), you can start at any node and follow the shortest (and only) path back to the root by always stepping to the only neighbor whose distance is less than this one. If you want, you can construct these paths quite easily as you go, and mark each node with the full path back to the root, but copying those paths can push the cost to O(n2) if you're not careful.\n\nAnd once all the nodes are marked, you can construct a minimal grand tour. Start at the root; when you visit a node, iterate over its unvisited neighbors (i.e. all but the one you just came from), visiting each, then go back the one you came from. (I can put this with more mathematical rigor, or give an example, if you like.)\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Find shortest path in a weighted digraph with GraphFrames Spark\r\n                \r\nThe graphFrames package of spark is great. I can find the shortest path from \"a\" to \"d\" with the command\n\n```\nval results = g.shortestPaths.landmarks(Seq(\"a\", \"d\")).run()\n```\n\n\nbut what how can I define a weighted graph and compute shortest path between two nodes?\n\nThanks.\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "The shortest path between two integers by adding or subtracting\r\n                \r\nHere's the description of this problem:\n\n\n  You are given two integers a and b.  You want to find the shortest sequence of operations necessary to transform a into b, where at each step you are allowed to add or subtract 5, 7, or 12.\n\n\nFor example, if you are given a = -5 and b = 19, the shortest path is\n\n```\n-5 + 12 + 12 = 19\n```\n\n\nIf you were given 1 and 3, the shortest path would be\n\n```\n1 + 7 - 5 = 2\n```\n\n\nThe only way I can think about solving this is using BFS and maybe some more pruning.  Is there a better algorithm I could use instead?\n\nThanks!\n    ", "Answer": "\r\nLet's start off with a set of interesting observations.  As many others have noted, the goal is to find some linear combination 5x + 7y + 12z = b - a with integer coefficients such that |x| + |y| + |z| is minimized.  But there are some very interesting connections between these three numbers that we can exploit:\n\n\nIf we ever have a combination 5x + 7y + 12z where x and y are both positive or both negative, we can cancel out some number of x's and y's to add an equivalent number of 12s.  In other words, no optimal solution has the same sign on both x and y, because we could always make this solution better.\nIf we ever have a combination 5x + 7y + 12z where y and z have opposite signs, we can always remove a 7 and 12 and add in a 5 of the appropriate sign to get a better solution.  Similarly, if x and z have opposite signs, we can always remove a 5 and 12 and add a 7 of the appropriate sign.  This means that we never need to consider any solution where z has the same sign as either x or y, because it means that there would have to be a better solution.\n\n\nLet's think about what (1) and (2) collectively tell us.  (1) says that the signs on x and y can't be the same, since we can always do better.  (2) says that if x and z have opposite signs or if y and z have opposite signs, we can always do better.  Collectively this means that\n\n\n  Lemma: At least one of x, y, or z must be zero in the optimal solution.\n\n\nTo see this, if all three are nonzero, if x and y have the same sign, then we can clearly make the solution better by replacing them with 12s.  Otherwise, x and y have opposite signs.  Thus if x and z have different signs, by (2) we can replace them with fewer 7's, otherwise y and z have different signs and by (2) we can replace them with fewer 5's.\n\nOkay, this is looking really great!  This means that we just need to solve these three integer equations and find which one has the smallest sum of coefficients:\n\n\n5x + 7y = b - a\n5x + 12z = b - a\n7y + 12z = b - a\n\n\nFortunately, by Bezout's identity, because gcd(5, 7) = gcd(5, 12) = gcd(7, 12) = 1, all of these systems of equations have a solution for any value of b - a.\n\nNow, let's see how to solve each of these equations.  Fortunately, we can use some cute tricks to greatly reduce our search space.  For example, for 5x + 7y = b - a, the value of x can't be outside of [-6, +6], since if it were we could just replace seven of the 5's with five 7's.  This means that we can solve the above equation by doing the following:\n\n\n  For x = -6 to +6, see if 5x + 7y = b - a has an integer solution by computing (b - a) - 5x and seeing if it's divisible by seven.  If so, the number of steps required to solve the problem is given by |x| + |((b - a) - 5x) / 7|.\n\n\nWe can use similar tricks to solve the latter two equations - for the second equation, x ranges from -11 to +11, and for the third y ranges from -11 to +11 as well.  We can then just take the best answer out of all three equations to see what the answer is.\n\nHere's some pseudocode to record the fewest number of steps possible.  This can easily be modified to return what those steps are by just recording which of the solutions was used and then expanding it out into a full path:\n\n```\nLet best = infinity\n\n# Solve 5x + 7y = b - a\nfor x = -6 to +6:\n    if ((b - a) - 5 * x) mod 7 = 0:\n        best = min(best, |x| + |((b - a) - 5 * x) / 7|)\n\n# Solve 5x + 12y = b - a\nfor x = -11 to +11:\n    if ((b - a) - 5 * x) mod 12 = 0:\n        best = min(best, |x| + |((b - a) - 5 * x) / 12|)\n\n# Solve 7x + 12y = b - a\nfor x = -11 to +11:\n    if ((b - a) - 7 * x) mod 12 = 0:\n        best = min(best, |x| + |((b - a) - 7 * x) / 12|)\n\nreturn best;\n```\n\n\nThis algorithm is amazingly fast - it runs in O(1) time because the number of iterations required to solve each three of the linear systems is a constant (at most 23).  It requires only O(1) memory to hold the possible values, and I think that in practice it's probably the fastest algorithm you'll be able to write.\n\nHope this helps!\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path queries in a graph\r\n                \r\nWe are given a static graph of ```\nN```\n nodes, where we have edges as given below:\n```\n 1. node-1 to node-i (for all 2 <= i <= N) of weight N + 1.\n 2. node-x to node-y (for all 2 <= x,y <= N) of weight 1, if and only if x divides y OR y divides x.\n```\n\nWe are given ```\nQ```\n queries of type```\n(u, v)```\n and we need to find shortest path between nodes ```\nu```\n and ```\nv.```\n\nConstraints :\n```\nT <= 10^5     // number of test cases\nN <= 2 * 10^5 // number of nodes\nQ <= 2 * 10^5 // number of queries\nu,v <= N      \n```\n\nApproach : Almost constant time - O(1).\n```\nprivate int gcd(int x, int y) {\n    if(x % y == 0) return y;\n    return gcd(y, x % y);\n}\n\nprivate int lcm(int x, int y) {\n    return (x * y) / gcd(x, y);\n}\n\nprivate int[] shortest_path(int N, int Q, int[][] queries) {\n    int[] result = new int[Q];\n\n    int[] smallestDivisor = new int[N + 1];\n    for(int i = 2; i <= N; i++) {\n        if(smallestDivisor[i] == 0) {\n            int f = 1;\n            while(i * f <= N) {\n                if(smallestDivisor[i * f] == 0)\n                    smallestDivisor[i*f] = i;\n                f += 1;\n            }\n        }   \n    }\n\n    for(int i = 0; i < Q; i++) {\n        int u = queries[i][0];\n        int v = queries[i][1];\n        int LCM = lcm(u, v);\n        int GCD = gcd(u, v);\n\n        int smallestDivisorOfU = smallestDivisor[u];\n        int smallestDivisorOfV = smallestDivisor[v];\n\n        if(u == v)\n            result[i] = 0;       // if nodes are same \n        else if(u == 1 || v == 1)\n            result[i] = N + 1;  // if any of the node is '1'\n        else if(u % v == 0 || v % u == 0)\n            result[i] = 1;      // if nodes are divisible\n        else if(GCD != 1 || LCM <= N)\n            result[i] = 2;    // if gcd != 1 || lcm exists thus we can go as: 'x' --> gcd(x, y)/lcm(x,y) --> 'y' : 2 distance\n        else if(Math.min(smallestDivisorOfU * v, smallestDivisorOfV * u) <= N) \n            result[i] = 3;\n        else\n            result[i] = 2 * (N + 1); // we have to go via '1' node\n    }\n\n    return result;\n}\n```\n\n\nWill this approach work for every test case?\n\n    ", "Answer": "\r\n\nAdd GCD claculation before LCM to provide path ```\nA => GCD(A,B) => B```\n (done)\n\nWhen LCM checking fails, make factorization of values. If they are prime, move through ```\n\"1\"```\n node. Otherwise check\n\n\n```\n   if (min(SmallestDivisorOfA * B , SmallestDivisorOfB * A) <= N) \n        result[i] = 3; \n```\n\n```\nExample: 7=>14=>2=>6\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Restrictions on Dijkstra, Bellman ford, and topoloical Shortest path algorithms?\r\n                \r\nWhat exact restrictions/conditions are there to be able to use either of these 3 SPT algorithms on graphs in order to compute the shortest paths? \n    ", "Answer": "\r\nDijkstra's algorithm requires the edge lengths to be nonnegative, while Bellman-Ford only requires the nonexistence of cycles of negative length.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How do I plot in real-time in a while loop?\r\n                \r\nI am trying to plot some data from a camera in real time using OpenCV. However, the real-time plotting (using matplotlib) doesn't seem to be working.\n\nI've isolated the problem into this simple example:\n\n```\nfig = plt.figure()\nplt.axis([0, 1000, 0, 1])\n\ni = 0\nx = list()\ny = list()\n\nwhile i < 1000:\n    temp_y = np.random.random()\n    x.append(i)\n    y.append(temp_y)\n    plt.scatter(i, temp_y)\n    i += 1\n    plt.show()\n```\n\n\nI would expect this example to plot 1000 points individually. What actually happens is that the window pops up with the first point showing (ok with that), then waits for the loop to finish before it populates the rest of the graph.\n\nAny thoughts why I am not seeing points populated one at a time?\n    ", "Answer": "\r\nHere's the working version of the code in question (requires at least version Matplotlib 1.1.0 from 2011-11-14):\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nplt.axis([0, 10, 0, 1])\n\nfor i in range(10):\n    y = np.random.random()\n    plt.scatter(i, y)\n    plt.pause(0.05)\n\nplt.show()\n```\n\nNote the call to ```\nplt.pause(0.05)```\n, which both draws the new data and runs the GUI's event loop (allowing for mouse interaction).\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path algorithm js error\r\n                \r\nI am quite new into JS and a friend of mine sent me this fiddle\n\n```\nfunction shortestPath(g, s) {\n    g.vertexes.forEach(function(u) {\n        u.dist = Infinity;\n        u.prev = null;\n    });\n\n    s.dist = 0;\n\n    for (var i = 0; i < g.vertexes.length - 1; i++) {\n        g.edges.forEach(function(e) {\n            update(e);\n        });\n    }\n\n    printResult(); }\n\nfunction update(e) {\n    var u = e.from;\n    var v = e.to;\n\n    if (v.dist > u.dist + e.data) {\n        v.dist = u.dist + e.data;\n        v.prev = u;\n    } }\n\nvar result = [];\n\nfunction printResult() {\n    var str = '';\n    debugger;\n    for (var i = 0; i < result[0].length; i++) {\n        for (var j = 0; j < result.length; j++) {\n            str += result[i][j] + ' ';\n        }\n        console.log(str);\n        str = '';\n    } }\n\nfunction printGraph(G) {\n    var a = [];\n\n    G.vertexes.forEach(function(u) {\n        a.push(u.dist);\n    });\n    result.push(a); }\n\n\nfunction Graph(options) {\n    options = options || {};\n    this.directed = (options.directed != null) ? options.directed : true;\n    this.vertexes = [];\n    this.edges = []; }\n\nGraph.prototype.vertex = function(name) {\n    var v = {\n        adjacent: [],\n        name: name.toString()\n    };\n\n    this.vertexes.push(v);\n\n    return this; };\n\nGraph.prototype.get = function(name) {\n    return this.vertexes.filter(function(el) {\n        return el.name === name.toString();\n    })[0]; };\n\nGraph.prototype.edge = function(a, b, w) {\n    var that = this;\n\n    connect(a, b, w);\n    if (!this.directed) {\n        connect(b, a, w);\n    }\n\n    function connect(a, b, data) {\n        var u = that.vertexes.filter(function(el) {\n            return el.name === a.toString();\n        })[0];\n        var v = that.vertexes.filter(function(el) {\n            return el.name === b.toString();\n        })[0];\n\n        u.adjacent.push(v);\n        that.edges.push({\n            from: u,\n            to: v,\n            data: data\n        });\n    }\n\n    return this; };\n\n\n\nfunction main() {\n    var g = new Graph();\n    g.vertex(1)\n        .vertex(2)\n        .vertex(3)\n        .vertex(4)\n        .vertex(5)\n        .vertex(6)\n        .vertex(7)\n        .vertex(8);\n\n    g.edge(1, 2, -2);\n    g.edge(1, 5, -2);\n    g.edge(1, 6, -3);\n    g.edge(1, 8, -1);\n\n    g.edge(2, 6, 7);\n    g.edge(2, 8, 4);\n    g.edge(3, 2, 2);\n    g.edge(3, 4, 5);\n\n    g.edge(3, 7, 9);\n    g.edge(4, 7, 4);\n    g.edge(5, 7, 5);\n    g.edge(7, 8, -1);\n\n    g.edge(8, 2, 2);\n    g.edge(8, 5, 8);\n    g.edge(8, 6, 3);\n    g.edge(8, 7, 7);\n\n    shortestPath(g, g.get(3));\n    console.log(g); }\n\nmain();\n```\n\n\n(Shortest path Bellman-Ford)\nand don't really get it why it throws the error ```\nproperty 'length' of undefined```\n in the console.\n\nAny advice how to fix this error?\n    ", "Answer": "\r\nIn general, when JS complains ```\nCannot read property \"xxx\" of undefined```\n, that means that somewhere you have ```\nfoo.xxx```\n and ```\nfoo```\n is the JavaScript value ```\nundefined```\n (which is not an object, and has no properties).\n\nTrack such a problem down by finding the line in question (using debugging tools, or even just looking for ```\n.length```\n in your case) and considering: when might the variable in question be ```\nundefined```\n?\n\nIn your specific case, the error occurs on this line:\n\n```\nfor (var i = 0; i < result[0].length; i++) {\n```\n\n\nwhich means that ```\nresult[0]```\n is ```\nundefined```\n. Which means that your ```\nresult```\n array has no value at ```\n[0]```\n. It is empty.\n\nSince the ```\nprintResult```\n function is called from one place (line 59), this likely means that ```\nresult```\n is still an empty array when ```\nprintResult()```\n is called. You can confirm this by setting a breakpoint at that location and examining what ```\nresult```\n is.\n\nAs for why it is empty:\n\nThe only code that affects the ```\nresult```\n array is ```\nresult.push(a)```\n in the ```\nprintGraph()```\n function. And this function is never called. Ask your friend why s/he defined ```\nprintGraph()```\n but never invoked it.\n\nIt may be as simple as calling ```\nprintGraph(g)```\n right before ```\nprintResult()```\n.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "heuristic function for shortest path\r\n                \r\nI Want to find shortest path (between two red circles) with lowest cost (numbers in squares are cost in each step).\n\nIn the following picture with A* method can solve the problem But I don't have any idea about a promising heuristic function. Can anybody gives me a good heuristic function? \n\n\n    ", "Answer": "\r\nSince there's a 0, and you didn't state any restrictions on distribution, presumably there can be any number of 0s, thus potentially the cost to reach the target from any given point can be 0, thus, for an admissible heuristic, without looking around, you can only use ```\nh(x) = 0```\n, which is Dijkstra's algorithm.\n\nA slightly better, but still not very good, heuristic would be to simply take the minimum of the surrounding cells.\n\nAnything else I can think of would either take too long to be useful, or would not guarantee getting to the target.\n\nYou can also consider running Dijkstra's algorithm from both points at the same time, you'll just have to be clever about when you stop.\n\n\n\nIf you're going to run multiple shortest path calculations on the same grid, you could consider preprocessing the grid to determine the lowest cost path consisting of ```\nn```\n nodes, then use this in your heuristic, based on something like the Manhattan distance.\n\nFor your example, if ```\nn = 3```\n, that would probably be ```\n2-3-9```\n, since ```\n2+3+9 = 14```\n is the lowest sum of 3 neighbouring nodes I can see.\n\nThen you can divide this by 3 (```\nn```\n) to get the cost of a single move, and calculate the Manhattan distance to the target (assuming only left, right, up and down moves, otherwise the calculation will be a little more complex), subtract ```\n2```\n (```\nn-1```\n), and multiply by the cost of a single move as the heuristic.\n\nWe need to divide by ```\nn-1```\n since if the distance to the target is ```\nn-1```\n, the cost to get there might be less than the calculated cost - consider the above example of ```\n2-3-9```\n - if the remaining path were to be ```\n2-3```\n, we'd have a per-move cost of less than ```\n14/3```\n, so we need to ignore ```\nn-1```\n of the distance.\n\nFor your grid, the heuristic from the starting point will be:\n\n```\nh(x) = cost for single move * (change in x + change in y - (n-1))\n     = 14/3 * (7 + 14 - 2)\n     = 88.7\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "backtracking algorithm to solve shortest path?\r\n                \r\nI have been extensively searching all over the net last night until today and I can't seem to find a resources discussing how to solve the shortest path problem by specifically using the backtracking algorithm. I tried solving it with this algo but I doesn't make sense to me. If it's the n-queens problem, it wouldn't be this complicated. \n\nSo can anyone give some internet links that would point me to some resources? I appreciate it very much. \n\n*UPDATE: Just curious, can the backtracking algorithm really solve the shortest path problem?\n    ", "Answer": "\r\nIt is wired you specified to use backtracking algoritm, in fact dijkstra SPFA or bellman-ford algorithm will be perfect to solve your problem. If you HAVE TO use backtracking, I am afraid that you could only reach a bad time complexity----just try your next road segment, and when the sum length of your chosen segments exceeded \"current shortest path\", start backtracking.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Dijkstra shortest path algorithm with edge cost\r\n                \r\nI have a directed, positive weighted graph. Each edge have a cost of use.\nI have only A money, i want to calculate shortest paths with dijkstra algorithm, but sum of edges costs on route must be less or equal to A.\n\nI want to do this with most smallest Dijstra modification (if I can do it with small modification of Dijkstra). I must do this in ```\nO(n*log(n))```\n if I can, but i think i can.\n\nAnyone can help me with this?\n    ", "Answer": "\r\nhttps://www.spoj.pl/problems/ROADS/\n\nThe problem was given at CEOI '98 and its official solution can be found here.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Floyd-Warshall algorithm shortest path\r\n                \r\nI implemented Floyd-Warshall algorithm. According to their matrices, I can get the correct result, about the shortest path between two places and their distance. My question is how to print the shortest distance from i to j. I made some researches and I found an algorithm like that. Can anyone explain me how should it be, or how does it works, or say any other suggestion?\n\n```\nPrintShortestPath(P,i,j){\n    if(i==j) print i\n    else if (P[i][j]==NULL)\n        print \"No path from i to j\"\n    else{\n        PrintShortestPath(P,i,P[i][j])\n        print j\n    }\n}\n```\n\n    ", "Answer": "\r\nFloyd's algorithm considers all paths between two nodes and keeps the cheapest found this far.\nYour code goes about this recursively.\nHere is another implementation with a good explanation for this in C:\nhttp://www.fearme.com/misc/alg/node88.html\n\nYou may also consider Dijkstra's algorithm, which might be better performing for sparse graphs.\n\n--L.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Hadoop MapReduce implementation of shortest PATH in a graph, not just the distance\r\n                \r\nI have been looking for \"MapReduce implementation of Shortest path search algorithms\". \n\nHowever, all the instances I could find \"computed the shortest distance form node x to y\", and none actually output the \"actual shortest path like x-a-b-c-y\".\n\nAs for what am I trying to achieve is that I have graphs with hundreds of 1000s of nodes and I need to perform frequent pattern analysis on shortest paths among the various nodes. This is for a research project I am working on.\n\nIt would be a great help if some one could point me to some implementation (if it exists) or give some pointers as to ```\nhow to hack the existing SSSP implementations to generate the paths along with the distances```\n.\n    ", "Answer": "\r\nBasically these implementations work with some kind of messaging. So messages are send to HDFS between map and reduce stage.\n\nIn the reducer they are grouped and filtered by distance, the lowest distance wins. When the distance is updated in this case, you have to set the vertex (well, some ID probably) where the message came from. \n\nSo you have additional space requirement per vertex, but you can reconstruct every possible shortest path in the graph. \n\nBased on your comment:\n\nyes probably \n\n\n  I will need to write another class of the vertex object to hold this\n  additional information. Thanks for the tip, though it would be very\n  helpful if you could point out where and when I can capture this\n  information of where the minimum weight came from, anything from your blog maybe :-)\n\n\nYea, could be a quite cool theme, also for Apache Hama. Most of the implementations are just considering the costs not the real path. In your case (from the blog you've linked above) you will have to extract a vertex class which actually holds the adjacent vertices as ```\nLongWritable```\n (maybe a list instead of this split on the text object) and simply add a parent or source id as field (of course also ```\nLongWritable```\n). \nYou will set this when propagating in the mapper, that is the for loop that is looping over the adjacent vertices of the current key node.\n\nIn the reducer you will update the lowest somewhere while iterating over the grouped values, there you will have to set the source vertex in the key vertex by the vertex that updated to the minimum.\n\nYou can actually get some of the vertices classes here from my blog:\nSource\nor directly from the repository:\nSource\n\nMaybe it helps you, it is quite unmaintained so please come back to me if you have a specific question. \n\nHere is the same algorithm in BSP with Apache Hama:\n\nhttps://github.com/thomasjungblut/tjungblut-graph/blob/master/src/de/jungblut/graph/bsp/SSSP.java\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Converting BFS to Djikstra to find the shortest path\r\n                \r\nHow can I convert the following BFS algorithm to find the shortest path using Djikstra?  I know that I need to update distances of neighbors, but I am confused on how exactly to extend the following BFS with it. The constraint is we can move only along L shaped paths between two nodes.\n\n```\nfrom collections import deque\n\nN = 8\nboard_p = [[(-1,-1) for f in range(0,N)] for i in range(0,N)]\n\ndef Adjacents(u):    \n    adj = []\n    for e in [(-2,-1),(-2,1),(2,1),(2,-1),(-1,-2),(1,-2),(-1,2),(1,2)]:        \n        v = (u[0] + e[0], u[1] + e[1])\n        if v[0] >= 0 and v[0] < N and v[1] >= 0 and v[1] < N: adj.append(v)\n    return adj;\n\ndef Moves(s,t):\n    q = deque()\n    q.append(s)\n    board_p[s[0]][s[1]] = s # \"root\" of BFS-traversal points to it self (avoid loop over \"back-edge\" to s)\n    while q:\n        u = q.popleft()\n        if u == t: break\n        for v in Adjacents(u):\n            if board_p[v[0]][v[1]] == (-1,-1):\n                board_p[v[0]][v[1]] = u\n                q.append(v)\n\n    # walk the path back (using parent \"pointers\")\n    path = [(t)]    \n    while t != s:\n        t = board_p[t[0]][t[1]]\n        path.append(t)\n\n    path.reverse()\n    return path\n\n\nprint(Moves((1,1),(5,5)))\n```\n\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Compute the shortest path in a maze through backtracking\r\n                \r\nI need to find the shortest path in a maze of 0's and 1's of ```\nm x n```\n (where 1 is a wall and 0 is an empty space) from ```\n[0][0]```\n to ```\n[m-1][n-1]```\n and the allowed moves are U, D, L and R. By path I mean the number of cells to cover, including the source and the destination.\nFor some purposes I need to do it recursively. I wrote a function that finds all the paths possible and their length. In a brute way it just looks around (U, D, L, R) and if the cell has not been visited yet and it is not a wall, it recursively visits it.\n```\ndef find_path(maze, i = 0, j = 0, path = 1):\n    m = len(maze)\n    n = len(maze[0])\n    if i == m - 1 and j == n - 1:\n        print(\"Path to destination [m - 1][n - 1]: {0}\".format(path))\n    maze[i][j] = 1\n    if 0 <= i < m and 0 <= j - 1 < n and maze[i][j - 1] == 0:\n        find_path(maze, i, j - 1, path + 1)\n    if 0 <= i < m and 0 <= j + 1 < n and maze[i][j + 1] == 0:\n        find_path(maze, i, j + 1, path + 1)\n    if 0 <= i - 1 < m and 0 <= j < n and maze[i - 1][j] == 0:\n        find_path(maze, i - 1, j, path + 1)\n    if 0 <= i + 1 < m and 0 <= j < n and maze[i + 1][j] == 0:\n        find_path(maze, i + 1, j, path + 1)\n    maze[i][j] = 0\n    return path\n```\n\nMy problem:\n\nI do not understand how to save the shortest path and pass it to all the function calls when I reach the destination. Somewhere in the function should be a line something like if ```\npath < shortest_path: shortest_path = path```\n;\n\nI don't understand how to return the shortest path from the function. Should I return a tuple ```\n(path, shortest_path)```\n or what?\n\n\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Can Tensorflow-NSL solve the shortest path problem?\r\n                \r\nI'm looking at the general class of graph algorithms that are solvable using neural networks. \n\nFor example - https://medium.com/octavian-ai/finding-shortest-paths-with-graph-networks-807c5bbfc9c8 - refers to an interesting solution to the shortest problem using graph neural networks. \n\nAll the examples in NSL illustrate examples where the graph adds to information in an existing model. But can NSL solve graph problems itself ?\n    ", "Answer": "\r\nAlthough NSL could potentially be used to improve the accuracy or robustness of a neural network specifically trained to solve the shortest-path problem (like the RNN described in the Medium article you linked to), NSL was not developed to solve graph problems directly. That said, we'd certainly be interested in hearing about any progress in using our libraries to do so.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "is it true in case of graphs that shortest path change?\r\n                \r\nIn a graph, there is a shortest path between two nodes. Now, If I add a constant value to each of the edge weights of the graph, will this shortest path change?\n    ", "Answer": "\r\nIt can change, if the weighted shortest path is not the unweighted shortest path.  Here is a simple example.\n\nThere are two paths between 1 and 3:\n1-> 2 -> 3    has weight 2\n1-> 3         has weight 3\nso the shortest path is 1->2->3.\nBut if you add 10 to the weight for each path,  the weights become\n1-> 2 -> 3    has weight 22\n1-> 3         has weight 13\nso the shortest path is 1->3.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path with stopover in circular graph\r\n                \r\nI have a directed (weighted) circular graph like this:\n\nI would like to find the shortest path through a number of nodes with same start and end node. For example I would like to find the shortest path starting from node ```\n0```\n going through node ```\n3```\n and ```\n4```\n and ending again at node ```\n0```\n. It gets a little more complicated due to constraints e.g. node ```\n4```\n should always be visited after node ```\n3```\n. I visualized this constraint here:\n\nIs there any algorithm to solve this problem?\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Finding shortest path algorithms [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     This question does not appear to be about programming within the scope defined in the help center.\r\n                \r\n                    \r\n                        Closed 3 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nFirst, thank you for taking time to read this post.\n\n\n  Problem:\n  \n  \n    Find the shortest path from i to j (i != j; i, j >= 0) from a given array, whereas you can only move left, right, or go to any element which has the same value to current element.\n  \n  \n  Example:\n  I have an array contains 9 numbers: ```\nint arr[9] = {7, 2, 5, 3, 8, 6, 9, 7, 0}```\n;\n  ```\nint i = 1, j = 6;```\n\n  \n  According to above declarations, i want to go from ```\narr[i]```\n to ```\narr[j]```\n (2 to 9) then the shortest path is ```\narr[1]```\n(2) -> ```\narr[0]```\n(1st 7) -> ```\narr[7]```\n(2nd 7) -> ```\narr[6]```\n(9) (total steps: 3)\n  \n  More Example:\n  \n  ```\nint arr[9] = {7, 2, 5, 3, 8, 6, 9, 7, 0}```\n;\n  ```\nint i = 7, j = 8;```\n steps: 1 (7 -> 8)\n  \n  ```\nint arr[9] = {8, 2, 0, 3, 8, 6, 9, 7, 0}```\n;\n  ```\nint i = 0, j = 8;```\n steps: 3 (0 -> 1 -> 2 -> 8)\n  \n  ```\nint arr[9] = {1, 5, 7, 3, 4, 22, 9, 8, 6}```\n;\n  ```\nint i = 2, j = 7;```\n steps: 5 (2 -> 3 -> 4 -> 5 -> 6 -> 7)\n\n\nI was trying to traverse all the elements in array (except i & j) to see whether any element have the same value and closest to j, but i'm end up getting more cases to deal with. Hope you guys can help me out, thanks in advance!\n    ", "Answer": "\r\nok, the easiest way is to:\n\n\ncreate another array, call it ```\ndistance```\n and fill it with value ```\n-1```\n.\nset ```\ndistance[i] = 0```\n, since it's free to move from the element to itself\nloop over the ```\ndistance```\n and for every existing number that's not ```\n-1```\n fill the element on the left and on the right with the number of the current element + 1 (do that only if the elements on left/right are equal to ```\n-1```\n)\nfor the newly filled elements, find the elements with the same value in ```\narray```\n and set the ```\ndistance```\n for them to the same value as you just did on the step 3.\n\n\nOnce you loop over this enough times, you'll have the array ```\ndistance```\n fully filled, which will tell you how far is any element from the element ```\narray[i]```\n.\n\nYou may exit loop early, if you just need the ```\ndistance[j]```\n and you have already found it.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How to find shortest path in prolog with weighted graph\r\n                \r\nI have this code :\n\n```\nlink(a,b,4). \nlink(a,c,2). \nlink(b,g,5). \nlink(c,g,6). \nlink(c,d,5). \nlink(d,g,3). \n\npath(S,D,TDist):- \n    link(S,D,TDist). \npath(S,D,TDist):- \n    link(S,X,TD1), path(X,D,TD2), TDist=TD1+TD2. \n```\n\n\nThis will follow a depth first search strategy, but the result is that it will give me all the paths, and it won't show which is the shortest. Is it possible to still use that strategy and find the shortest path? if not, what search strategy to use? and how can I implement it.\n    ", "Answer": "\r\nI think there are problems with your code:\n\n\n```\nTDist=TD1+TD2```\n doesn't compute the sum, use is/2 instead, at least when a path is returned.\nIt will loop if the graph contains cycles, but assuming the data actually is a DAG, we can ignore by now.\nWe can't say what the actual path will be, just its value.\n\n\nAnyway, library(aggregate) can be used to find the shortest path. For instance\n\n```\n?- aggregate(min(D), path(a,g,D), D).\nD = 8.\n```\n\n\nOr, since gnu-prolog doesn't have library(aggregate), take the first element computed by setof/3:\n\n```\n?- setof(D, path(a,g,D), [Min|Rest]).\nMin = 8,\nRest = [9, 10].\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "C++ Modify Djikstra's Algorithm To Give Second Shortest Path\r\n                \r\nHow can you modify this Djikstra's algorithm to give the second shortest path? Another way I have done this function is using **G to pass a dynamically initialized 2D array.\nI understand the shortest path here, however the second shortest path is confusing.\n```\nint main() {\n   int G[max][max]={{0,1,0,3,10},{1,0,5,0,0},{0,5,0,2,1},{3,0,2,0,6},{10,0,1,6,0}};\n   int n=5;\n   int u=0;\n   dijkstra(G,n,u);\n   return 0;\n}\nvoid dijkstra(int G[max][max],int n,int startnode) {\n   int cost[max][max],distance[max],pred[max];\n   int visited[max],count,mindistance,nextnode,i,j;\n   for(i=0;i<n;i++)\n      for(j=0;j<n;j++)\n   if(G[i][j]==0)\n      cost[i][j]=INFINITY;\n   else\n      cost[i][j]=G[i][j];\n   for(i=0;i<n;i++) {\n      distance[i]=cost[startnode][i];\n      pred[i]=startnode;\n      visited[i]=0;\n   }\n   distance[startnode]=0;\n   visited[startnode]=1;\n   count=1;\n   while(count<n-1) {\n      mindistance=INFINITY;\n      for(i=0;i<n;i++)\n         if(distance[i]<mindistance&&!visited[i]) {\n         mindistance=distance[i];\n         nextnode=i;\n      }\n      visited[nextnode]=1;\n      for(i=0;i<n;i++)\n         if(!visited[i])\n      if(mindistance+cost[nextnode][i]<distance[i]) {\n         distance[i]=mindistance+cost[nextnode][i];\n         pred[i]=nextnode;\n      }\n      count++;\n   }\n   for(i=0;i<n;i++)\n   if(i!=startnode) {\n      cout<<\"\\nDistance of node\"<<i<<\"=\"<<distance[i];\n      cout<<\"\\nPath=\"<<i;\n      j=i;\n      do {\n         j=pred[j];\n         cout<<\"<-\"<<j;\n      }while(j!=startnode);\n   }\n}\n\nThis algorithm is from tutorials point. \n```\n\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Algorithm not returning shortest path in python\r\n                \r\nI have to make an algorithm that finds the shortest path from a graph, similar to a traveling salesman problem, the graph should visit all the nodes an return back the shortest path.\nThe algorithm worked fine, but as the nodes should only be visited once, I've tried to cater for visited nodes, but my function is returning none.\nI have added a visited set to cater for visited nodes, but my algorithm is returning none since then.\nHere is my algorithm:\n```\n# The main function to perform the A* algorithm\ndef a_star(start, goal, graph):\n    # The nodes to be visited, stored as (cost, current, path) tuples\n    heap = [(0 + euclidean_distance((start, goal), (goal, goal)), start, [start], 0)]\n\n    # Keep track of visited nodes to avoid revisiting\n    visited = set()\n\n    while heap:\n        (cost, current, path, weight) = heap.pop(0)\n        if len(path) == N:\n            return path, weight\n        if current in visited:\n            continue\n        visited.add(current)\n        for i, node in enumerate(graph[current]):\n            if node > 0 and i not in path:\n                heap.append((cost + node + euclidean_distance((i, goal), (goal, goal)), i, path + [i], weight + node))\n        heap = sorted(heap, key=lambda x: x[0])\n\n    return None, None\n```\n\n    ", "Answer": "\r\nYour first bug is that using ```\npop(0)```\n on an array does NOT make it work like a heap.  Your ```\ncost```\n is being ignored.  Instead you need to heapq.heappop() to make this an actual A* search.\nBut the more fundamental bug is in trying to use A* search at all on this problem.  The reason why is that you won't revisit a node if any other path has reached it.  And often another path DOES reach it before the one you want to find.  So you can never find the path that you want.\nHere is an example.  Suppose your graph looks like\n```\n       A\n     / | \\\nstart  |  goal\n     \\ | /\n       B\n```\n\nHere are the steps:\n\nFrom ```\nstart```\n you add to the queue that you can get to ```\nA```\n and ```\nB```\n. Mark ```\nstart```\n as ```\nvisited```\n\nYou look at the path ```\nstart - A```\n, see that ```\nA```\n is not visited, add to the queue that you can get to ```\ngoal```\n, ```\nB```\n and ```\nstart```\n. Mark ```\nA```\n as visited.\nYou look at the path ```\nstart - B```\n, see that ```\nB```\n is not visited, add to the queue that you can get to ```\ngoal```\n, ```\nA```\n and ```\nstart```\n. Mark ```\nB```\n as visited.\nYou look at the path ```\nstart - A - goal```\n, see that ```\ngoal```\n is not visited.  Find that your path is too short.\nYou look at the path ```\nstart - B - goal```\n, see that ```\ngoal```\n is not visited.  Find that your path is too short.\nYou look at the path ```\nstart - A - B```\n, see that ```\nB```\n IS visited and stop.\nYou look at the path ```\nstart - B - A```\n, see that ```\nA```\n IS visited and stop.\nYou look at the path ```\nstart - A - start```\n, see that ```\nstart```\n IS visited and stop.\nYou look at the path ```\nstart - B - start```\n, see that ```\nstart```\n IS visited and stop.\nYou give up.\n\nAnd you see that you abandoned ```\nstart - A - B```\n because ```\nstart - B```\n is shorter.  And likewise abandoned ```\nstart - B - A```\n because ```\nstart - A```\n is shorter.  Which gives you no chance of finding ```\nstart - A - B - goal```\n or ```\nstart - B - A - goal```\n.  (Either of which would have made you happy.)\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "CGAL Triangulated Surface Mesh Shortest Paths algorithm - assertion errors\r\n                \r\nI am experimenting with the Triangulated Surface Mesh Shortest Paths algorithm of the CGAL library.\nI'm using the following triangulated square case for testing purposes:\n\n\nWhen I try to compute the shortest distance between any two vertices I always get one of the following two errors:\n\nerror1:\n\n```\nterminate called after throwing an instance of  'CGAL::Assertion_exception'\nwhat():  CGAL ERROR: assertion violation!\nExpr: baseOrientation != CGAL::COLLINEAR\nFile: /usr/local/include/CGAL/Surface_mesh_shortest_path/function_objects.h  \nLine: 588\n```\n\n\nerror 2:\n\n```\nterminate called after throwing an instance of 'CGAL::Assertion_exception'\nwhat():  CGAL ERROR: assertion violation!\nExpr: _idx < data_.size()\nFile: /usr/local/include/CGAL/Surface_mesh/Properties.h\nLine: 204\n```\n\n\nYou can download the minimal code example including the mesh in off format here. I followed the implementation shown on the CGAL site. Compilation requires the CGAL and gmp libraries:\n\n```\ng++ main.cpp -lCGAL -lgmp\n```\n\n\nThe executable requires two arguments: the indices of the source and target point:\n\n```\na.out 2 6\n```\n\n\nTry 2 and 6 to get the first error, or 0 and 2 to get the second error.\n    ", "Answer": "", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "R, determine shortest path\r\n                \r\nI have a graph and need the shortest distance between all nodes.\nNow I made the following function, \n\n```\nshortestPath <- function(streets, length)\n{\n    streets <- matrix(streets, byrow=TRUE, ncol=2)    # from -> to\n    g <- graph.data.frame(as.data.frame(streets))     # create graph, see plot(g)\n    return <- shortest.paths(g, weights = length)     # return routes lengths\n}\n```\n\n\nHere ```\nstreets```\n is a vector which contains data where we have an edge and ```\nlength```\n is (obviously) the length of the edge.\n\nI have the following graph where each edge has length two, note that the graph has to be undirected.\n\n\n\nYou can use the following data to reproduce the problem.\n\n```\n# Data\nedges <- c(1,2, 2,3, 3,4, 4,5, 2,6, 3,7, 4,8, 6,8);\nlength <- rep(2,8);\naantalNodes <- 8;\n\n# Determine shortest path\nroutes <- matrix(shortestPath(edges,length), byrow=FALSE, ncol=aantalNodes);\n```\n\n\nWe clearly see that the shortest path between node 6 and node 8 has length 2, however, this function returns length 4. What's going wrong? I'm already tinker with it for two days. Looking forward for you help!\n    ", "Answer": "\r\nYou may want to have a look at the rownames and colnames of ```\nshortestPath(edges,length)```\n. It's really rather revealing...\n\n```\nres <- shortestPath(edges,length)\nres[order(as.integer(rownames(res))),\n    order(as.integer(colnames(res)))]\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Dijkstra’s shortest path algorithm\r\n                \r\nThe following is algorithm summary given to us by our professor.  \n\nWhat is the parent of a node in a graph as referred to in step 3?  I'm a little confused as I though that the nodes only had neighbors and doesn't have a parent?\n\nMy second question is about step 3, \"pick up the index’th record in stack.\"  Since a stack only allows you to view the top, I'm not sure what it means by picking up the index'th record?  \n\nDijkstra’s shortest path:\n\n```\nStep 0: if s == d, stop.\nStep 1: current node c= s, c.length = 0, stack.push (c, its length, and parent). \n        If u is the source s then no need for parent.\nStep 2: min = 0, hop = infinite, index = 1\nStep 3: pick up the index’th record in stack, say node u, its length u.length, \n        and its parent w.\nStep 4: find a neighbor of u in the table of neighbors, say v, such that v is \n        not found in any item in stack and <u,v> +u.length< hop. \nStep 5: if such a neighbor is found, hop=min=u.length + <u,v> and record_node = v\nStep 6: go to step 4 until all the neighbors of u have been tried (all can be \n        found in stack).\nStep 7: index ++, go to step 3 until all the nodes have been tried (found in \n        stack).\nStep 8: c = record_node, c.length = min, stack_push(c, c.length, u). If c == d \n        stop the entire process and goes to step 9 for data collection, \n        otherwise go to step 2.\nStep 9: (t, d.length, and t.parent) = (d, d.length, and d.parent) in stack, \n        keep searching on (t.parent, t.parent.length, t.parent.parent), \n        until t.parent = s.\n```\n\n    ", "Answer": "\r\nIn a graph, nodes only have neighbors, but while running Dijkstra's algorithm you build a \"tree\" describing the shortest path from the starting node to all the nodes in the original graph.\n\nat the beginning of the algorithm run, all the nodes have their predecessor node set to null, and on each iteration a parent is set to the node leading to the shortest path.\n\nHave a look at this Visualization of Dijkstra's Algorithm and notice that the result of the algorithm is in fact a sub-tree of the graph.\n\nHope that answers your question :)\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "How to find shortest path in a equal weighted graph\r\n                \r\nI have a graph which looks like this:\nAll the edges between nodes have distance = 1.\n\n```\n      F\n      |\n      E\n      |\nA-B-C-D\n|     |\nG     O\n|     |\nH     P\n|     |\nI     Q\n|     |\nJ     R\n|     |\nK-L-M-N\n```\n\n\nI have to find the shortest path from A node to Q.\nThe algorithm which i use is as follows(borrowed from wikipedia): \n\n```\n 1 function Dijkstra(Graph, source):\n 2\n 3      create vertex set Q\n 4\n 5      for each vertex v in Graph:             // Initialization\n 6          dist[v] ← INFINITY                  // Unknown distance from source to v\n 7          prev[v] ← UNDEFINED                 // Previous node in optimal path from source\n 8          add v to Q                          // All nodes initially in Q (unvisited nodes)\n 9\n10      dist[source] ← 0                        // Distance from source to source\n11      \n12      while Q is not empty:\n13          u ← vertex in Q with min dist[u]    // Source node will be selected first\n14          remove u from Q \n15          \n16          for each neighbor v of u:           // where v is still in Q.\n17              alt ← dist[u] + length(u, v)\n18              if alt < dist[v]:               // A shorter path to v has been found\n19                  dist[v] ← alt \n20                  prev[v] ← u \n21\n22      return dist[], prev[]\n```\n\n\nThe main problem when i use djikstra's algo is that i am not able to get the shortest path to traverse from source to destination.\nAlgorithm traverses across nodes which are not in the shortest path,to find the shortest path.\n\n```\nE.g if i traverse from A->Q i traverse through other nodes like(G->H->I..)\nBut the path from G->H->I does not lead to the destination.\nBut the path from A->B->C... leads to the shortest path.\n```\n\n\nHow do i backtrace the correct path?\n    ", "Answer": "\r\nThat is what the prev array in djikstra's algorithm is for\n\nYou know the destination is Q, so prev[Q] is the node right before Q in the optimal path (which in this case is P)\n\nprev[P] is O, prev[O] is D, and so on until you get to A which is the origin of the path.\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
{"Question": "Shortest path in a grid using BFS\r\n                \r\nThe grid consists of following items as python list of lists\n\n```\ng = [\n    ['1', '1', '1', '1', '1'],\n    ['S', '1', 'X', '1', '1'],\n    ['1', '1', '1', '1', '1'],\n    ['X', '1', '1', 'E', '1'],\n    ['1', '1', '1', '1', 'X']\n]\n```\n\n\nS indicates the start, E indicates the end.\n\n1 indicates the allowed paths, X are not allowed paths\n\nA simple BFS traversal code is \n\n```\ndef find_path_bfs(s, e, grid):\n    queue = list()\n    path = list()\n    queue.append(s)\n\n    while len(queue) > 0:\n        node = queue.pop(0)\n        path.append(node)\n        mark_visited(node, v)\n\n        if node == e:\n            break\n\n        adj_nodes = get_neighbors(node, grid)\n        for item in adj_nodes:\n            if is_visited(item, v) is False:\n                queue.append(item)\n\n    return path\n```\n\n\nThe algorithm, as far as I can tell is traversing correctly with the following output \n\n```\n[(1, 0), (1, 1), (2, 0), (0, 0), (2, 1), (0, 1), (2, 1), (0, 1), (2, 2), (3, 1), (0, 2), (2, 2), (3, 1), (0, 2), (2, 3), (3, 2), (3, 2), (4, 1), (0, 3), (2, 3), (3, 2), (3, 2), (4, 1), (0, 3), (2, 4), (3, 3)]\n```\n\n\nEach tuple in the list represents the indices for the node in the original graph. \n\nHow can rewrite my BFS code to return the shortest path instead of the entire traversal path followed to reach the destination node? I have spent hours to find answers on my own but so far I have been unsuccessful.\n    ", "Answer": "\r\nIn order to get shortest path you should save path to current node in your queue too, so format of queue item will be:\n\n```\n(node, path_to_this_node)\n```\n\n\nModified code:\n\n```\ndef find_path_bfs(s, e, grid):\n    queue = [(s, [])]  # start point, empty path\n\n    while len(queue) > 0:\n        node, path = queue.pop(0)\n        path.append(node)\n        mark_visited(node, v)\n\n        if node == e:\n            return path\n\n        adj_nodes = get_neighbors(node, grid)\n        for item in adj_nodes:\n            if not is_visited(item, v):\n                queue.append((item, path[:]))\n\n    return None  # no path found\n```\n\n    ", "Knowledge_point": "Shortest Paths", "Tag": "算法分析"}
