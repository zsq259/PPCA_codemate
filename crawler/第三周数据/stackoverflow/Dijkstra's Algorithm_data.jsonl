{"Question": "Why doesn't Dijkstra's algorithm work for negative weight edges?\r\n                \r\nCan somebody tell me why Dijkstra's algorithm for single source shortest path assumes that the edges must be non-negative. \n\nI am talking about only edges not the negative weight cycles.\n    ", "Answer": "\r\nRecall that in Dijkstra's algorithm, once a vertex is marked as \"closed\" (and out of the open set) - the algorithm found the shortest path to it, and will never have to develop this node again - it assumes the path developed to this path is the shortest.\n\nBut with negative weights - it might not be true. For example:\n\n```\n       A\n      / \\\n     /   \\\n    /     \\\n   5       2\n  /         \\\n  B--(-10)-->C\n\nV={A,B,C} ; E = {(A,C,2), (A,B,5), (B,C,-10)}\n```\n\n\nDijkstra from A will first develop C, and will later fail to find ```\nA->B->C```\n\n\n\n\nEDIT a bit deeper explanation:\n\nNote that this is important, because in each relaxation step, the algorithm assumes the \"cost\" to the \"closed\" nodes is indeed minimal, and thus the node that will next be selected is also minimal.\n\nThe idea of it is: If we have a vertex in open such that its cost is minimal - by adding any positive number to any vertex - the minimality will never change.\nWithout the constraint on positive numbers - the above assumption is not true.\n\nSince we do \"know\" each vertex which was \"closed\" is minimal - we can safely do the relaxation step - without \"looking back\". If we do need to \"look back\" - Bellman-Ford offers a recursive-like (DP) solution of doing so.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Negative weights using Dijkstra's Algorithm\r\n                \r\nI am trying to understand why Dijkstra's algorithm will not work with negative weights. Reading an example on Shortest Paths, I am trying to figure out the following scenario:\n\n```\n    2\nA-------B\n \\     /\n3 \\   / -2\n   \\ /\n    C\n```\n\n\nFrom the website:\n\n\n  Assuming the edges are all directed from left to right, If we start\n  with A, Dijkstra's algorithm will choose the edge (A,x) minimizing\n  d(A,A)+length(edge), namely (A,B). It then sets d(A,B)=2 and chooses\n  another edge (y,C) minimizing d(A,y)+d(y,C); the only choice is (A,C)\n  and it sets d(A,C)=3. But it never finds the shortest path from A to\n  B, via C, with total length 1.\n\n\nI can not understand why using the following implementation of Dijkstra, d[B] will not be updated to ```\n1```\n (When the algorithm reaches vertex C, it will run a relax on B, see that the d[B] equals to ```\n2```\n, and therefore update its value to ```\n1```\n).\n\n```\nDijkstra(G, w, s)  {\n   Initialize-Single-Source(G, s)\n   S ← Ø\n   Q ← V[G]//priority queue by d[v]\n   while Q ≠ Ø do\n      u ← Extract-Min(Q)\n      S ← S U {u}\n      for each vertex v in Adj[u] do\n         Relax(u, v)\n}\n\nInitialize-Single-Source(G, s) {\n   for each vertex v  V(G)\n      d[v] ← ∞\n      π[v] ← NIL\n   d[s] ← 0\n}\n\nRelax(u, v) {\n   //update only if we found a strictly shortest path\n   if d[v] > d[u] + w(u,v) \n      d[v] ← d[u] + w(u,v)\n      π[v] ← u\n      Update(Q, v)\n}\n```\n\n\nThanks,\n\nMeir\n    ", "Answer": "\r\nThe algorithm you have suggested will indeed find the shortest path in this graph, but not all graphs in general. For example, consider this graph:\n\nLet's trace through the execution of your algorithm.\n\nFirst, you set d(A) to 0 and the other distances to ∞.\nYou then expand out node A, setting d(B) to 1, d(C) to 0, and d(D) to 99.\nNext, you expand out C, with no net changes.\nYou then expand out B, which has no effect.\nFinally, you expand D, which changes d(B) to -201.\n\nNotice that at the end of this, though, that d(C) is still 0, even though the shortest path to C has length -200. This means that your algorithm doesn't compute the correct distances to all the nodes. Moreover, even if you were to store back pointers saying how to get from each node to the start node A, you'd end taking the wrong path back from C to A.\nThe reason for this is that Dijkstra's algorithm (and your algorithm) are greedy algorithms that assume that once they've computed the distance to some node, the distance found must be the optimal distance. In other words, the algorithm doesn't allow itself to take the distance of a node it has expanded and change what that distance is. In the case of negative edges, your algorithm, and Dijkstra's algorithm, can be \"surprised\" by seeing a negative-cost edge that would indeed decrease the cost of the best path from the starting node to some other node.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Why does Dijkstra's algorithm use decrease-key?\r\n                \r\nDijkstra's algorithm was taught to me was as follows\n\n```\nwhile pqueue is not empty:\n    distance, node = pqueue.delete_min()\n    if node has been visited:\n        continue\n    else:\n        mark node as visited\n    if node == target:\n        break\n    for each neighbor of node:\n         pqueue.insert(distance + distance_to_neighbor, neighbor)\n```\n\n\nBut I've been doing some reading regarding the algorithm, and a lot of versions I see use decrease-key as opposed to insert.\n\nWhy is this, and what are the differences between the two approaches?\n    ", "Answer": "\r\nThe reason for using decrease-key rather than reinserting nodes is to keep the number of nodes in the priority queue small, thus keeping the total number of priority queue dequeues small and the cost of each priority queue balance low.\n\nIn an implementation of Dijkstra's algorithm that reinserts nodes into the priority queue with their new priorities, one node is added to the priority queue for each of the m edges in the graph.  This means that there are m enqueue operations and m dequeue operations on the priority queue, giving a total runtime of O(m Te + m Td), where Te is the time required to enqueue into the priority queue and Td is the time required to dequeue from the priority queue.\n\nIn an implementation of Dijkstra's algorithm that supports decrease-key, the priority queue holding the nodes begins with n nodes in it and on each step of the algorithm removes one node.  This means that the total number of heap dequeues is n.  Each node will have decrease-key called on it potentially once for each edge leading into it, so the total number of decrease-keys done is at most m.  This gives a runtime of (n Te + n Td + m Tk), where Tk is the time required to call decrease-key.\n\nSo what effect does this have on the runtime?  That depends on what priority queue you use.  Here's a quick table that shows off different priority queues and the overall runtimes of the different Dijkstra's algorithm implementations:\n\n```\nQueue          |  T_e   |  T_d   |  T_k   | w/o Dec-Key |   w/Dec-Key\n---------------+--------+--------+--------+-------------+---------------\nBinary Heap    |O(log N)|O(log N)|O(log N)| O(M log N)  |   O(M log N)\nBinomial Heap  |O(log N)|O(log N)|O(log N)| O(M log N)  |   O(M log N)\nFibonacci Heap |  O(1)  |O(log N)|  O(1)  | O(M log N)  | O(M + N log N)\n```\n\n\nAs you can see, with most types of priority queues, there really isn't a difference in the asymptotic runtime, and the decrease-key version isn't likely to do much better.  However, if you use a Fibonacci heap implementation of the priority queue, then indeed Dijkstra's algorithm will be asymptotically more efficient when using decrease-key.\n\nIn short, using decrease-key, plus a good priority queue, can drop the asymptotic runtime of Dijkstra's beyond what's possible if you keep doing enqueues and dequeues.\n\nBesides this point, some more advanced algorithms, such as Gabow's Shortest Paths Algorithm, use Dijkstra's algorithm as a subroutine and rely heavily on the decrease-key implementation.  They use the fact that if you know the range of valid distances in advance, you can build a super efficient priority queue based on that fact.\n\nHope this helps!\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Why use Dijkstra's Algorithm if Breadth First Search (BFS) can do the same thing faster?\r\n                \r\nBoth can be used to find the shortest path from single source. BFS runs in ```\nO(E+V)```\n, while Dijkstra's runs in ```\nO((V+E)*log(V))```\n.\n\nAlso, I've seen Dijkstra used a lot like in routing protocols.\n\nThus, why use Dijkstra's algorithm if BFS can do the same thing faster?\n    ", "Answer": "\r\nDijkstra allows assigning distances other than 1 for each step. For example, in routing the distances (or weights) could be assigned by speed, cost, preference, etc. The algorithm then gives you the shortest path from your source to every node in the traversed graph.\n\nMeanwhile BFS basically just expands the search by one “step” (link, edge, whatever you want to call it in your application) on every iteration, which happens to have the effect of finding the smallest number of steps it takes to get to any given node from your source (“root”).\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "What's the difference between uniform-cost search and Dijkstra's algorithm?\r\n                \r\nI was wondering what's the difference between uniform-cost search and Dijkstra's algorithm. They seem to be the same algorithm.\n    ", "Answer": "\r\n\n  Dijkstra's algorithm, which is perhaps better-known, can be regarded\n  as a variant of uniform-cost search, where there is no goal state and\n  processing continues until all nodes have been removed from the\n  priority queue, i.e. until shortest paths to all nodes (not just a\n  goal node) have been determined\n\n\nhttp://en.wikipedia.org/wiki/Uniform-cost_search#Relationship_to_other_algorithms\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Why does Dijkstra's algorithm work?\r\n                \r\nI understand what Dijkstra's algorithm is, but I don't understand why it works.\n\nWhen selecting the next vertex to examine, why does Dijkstra's algorithm select the one with the smallest weight? Why not just select a vertex arbitrarily, since the algorithm visits all vertices anyway? \n    ", "Answer": "\r\nYou can think of Djikstra's algorithm as a water-filling algorithm (i.e. a pruned breadth-first search).  At each stage, the goal is to cover more of the whole graph with the lowest-cost path possible.  Suppose you have vertices at the edge of the area you've filled in, and you list them in terms of distance:\n\n```\nv0 <= v1 <= v2 <= v3 ...\n```\n\n\nCould there possibly be a cheaper way to get to vertex ```\nv1```\n?  If so, the path must go through ```\nv0```\n, since no untested vertex could be closer.  So you examine vertex ```\nv0```\n to see where you can get to, checking if any path through ```\nv0```\n is cheaper (to any other vertex one step away).\n\nIf you peel away the problem this way, you're guaranteed that your distances are all minimums, because you always check exactly that vertex that could lead to a shortest path.  Either you find that shortest path, or you rule it out, and move on to the next vertex.  Thus, you're guaranteed to consume one vertex per step.\n\nAnd you stop without doing any more work than you need to, because you stop when your destination vertex occupies the \"I am smallest\" ```\nv0```\n slot.\n\nLet's look at a brief example.  Suppose we're trying to get from ```\n1```\n to ```\n12```\n by multiplication, and the cost between nodes is the number you have to multiply by.  (We'll restrict the vertices to the numbers from ```\n1```\n to ```\n12```\n.)\n\nWe start with ```\n1```\n, and we can get to any other node by multiplying by that value.  So node ```\n2```\n has cost ```\n2```\n, ```\n3```\n has cost ```\n3```\n, ... ```\n12```\n has cost ```\n12```\n if you go in one step.\n\nNow, a path through ```\n2```\n could (without knowing about the structure) get to ```\n12```\n fastest if there was a free link from ```\n2```\n to ```\n12```\n.  There isn't, but if there was, it would be fastest.  So we check ```\n2```\n.  And we find that we can get to ```\n4```\n for cost ```\n2```\n, to ```\n6```\n for ```\n3```\n, and so on.  We thus have a table of costs like so:\n\n```\n3  4  5  6  7  8  9 10 11 12 // Vertex\n3  4  5  5  7  6  9  7 11  8 // Best cost to get there so far.\n```\n\n\nOkay, now maybe we can get to ```\n12```\n from ```\n3```\n for free!  Better check.  And we find that ```\n3*2==6```\n so the cost to ```\n6```\n is the cost to ```\n3```\n plus ```\n2```\n, and to ```\n9```\n is plus ```\n3```\n, and ```\n12```\n is plus ```\n4```\n.\n\n```\n4  5  6  7  8  9 10 11 12\n4  5  5  7  6  6  7 11  7\n```\n\n\nFair enough.  Now we test ```\n4```\n, and we see we can get to ```\n8```\n for an extra ```\n2```\n, and to ```\n12```\n for an extra ```\n3```\n.  Again, the cost to get to ```\n12```\n is thus no more than ```\n4```\n+```\n3```\n = ```\n7```\n:\n\n```\n5  6  7  8  9 10 11 12\n5  5  7  6  8  7 11  7\n```\n\n\nNow we try ```\n5```\n and ```\n6```\n--no improvements so far.  This leaves us with\n\n```\n7  8  9 10 11 12\n7  6  8  7 11  7\n```\n\n\nNow, for the first time, we see that the cost of getting to ```\n8```\n is less than the cost of getting to ```\n7```\n, so we had better check that there isn't some free way to get to ```\n12```\n from ```\n8```\n.  There isn't--there's no way to get there at all with integers--so we throw it away.\n\n```\n7  9 10 11 12\n7  8  7 11  7\n```\n\n\nAnd now we see that ```\n12```\n is as cheap as any path left, so the cost to reach ```\n12```\n must be ```\n7```\n.  If we'd kept track of the cheapest path so far (only replacing the path when it's strictly better), we'd find that ```\n3*4```\n is the first cheapest way to hit ```\n12```\n.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Relaxation of an edge in Dijkstra's algorithm\r\n                \r\nWhat does ```\nrelaxation of an edge```\n mean in the context of graph theory ? I came across this while studying up on Dijkstra's algorithm for single source shortest path.\n    ", "Answer": "\r\nHere's a nice description of the Algorithm that also explains the notion of relaxation.\n\n\n  The notion of \"relaxation\" comes from an analogy between the estimate\n  of the shortest path and the length of a helical tension spring, which\n  is not designed for compression. Initially, the cost of the shortest\n  path is an overestimate, likened to a stretched out spring. As shorter\n  paths are found, the estimated cost is lowered, and the spring is\n  relaxed. Eventually, the shortest path, if one exists, is found and\n  the spring has been relaxed to its resting length.\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How does Dijkstra's Algorithm and A-Star compare?\r\n                \r\nI was looking at what the guys in the Mario AI Competition have been doing and some of them have built some pretty neat Mario bots utilizing the A* (A-Star) Pathing Algorithm.  \n\n\n(Video of Mario A* Bot In Action)\n\nMy question is, how does A-Star compare with Dijkstra?  Looking over them, they seem similar.\n\nWhy would someone use one over the other?  Especially in the context of pathing in games?\n    ", "Answer": "\r\nDijkstra is a special case for A* (when the heuristics is zero).\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm and Cycles\r\n                \r\nIt's stated in a book that \"Dijkstra's algorithm only works with Directed Acyclic Graphs\". \n\nIt appears the algorithm works for graphs with cycles too as long as there are no negative cycles. Is that correct?\n\nEdit 1:\n The book \"Grokking Algorithms\" -Aditya Bhargava. \n Chapter 7. Page 122.\n    ", "Answer": "\r\nI'm the author of Grokking Algorithms. Sorry for this error—Dijkstra's algorithm does work on graphs with cycles, as long as it is a positive weight cycle. I have updated the errata page to reflect this error. Dijkstra's doesn't work on negative weight cycles, and here's an image that explains why:\n\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Difference between Prim's and Dijkstra's algorithms?\r\n                \r\nWhat  is the exact difference between Dijkstra's and Prim's algorithms? I know Prim's will give a MST but the tree generated by Dijkstra will also be a MST. Then what is the exact difference?\n    ", "Answer": "\r\nPrim's algorithm constructs a minimum spanning tree for the graph, which is a tree that connects all nodes in the graph and has the least total cost among all trees that connect all the nodes.  However, the length of a path between any two nodes in the MST might not be the shortest path between those two nodes in the original graph.  MSTs are useful, for example, if you wanted to physically wire up the nodes in the graph to provide electricity to them at the least total cost.  It doesn't matter that the path length between two nodes might not be optimal, since all you care about is the fact that they're connected.\nDijkstra's algorithm constructs a shortest path tree starting from some source node.  A shortest path tree is a tree that connects all nodes in the graph back to the source node and has the property that the length of any path from the source node to any other node in the graph is minimized.  This is useful, for example, if you wanted to build a road network that made it as efficient as possible for everyone to get to some major important landmark.  However, the shortest path tree is not guaranteed to be a minimum spanning tree, and the sum of the costs on the edges of a shortest-path tree can be much larger than the cost of an MST.\nAnother important difference concerns what types of graphs the algorithms work on.  Prim's algorithm works on undirected graphs only, since the concept of an MST assumes that graphs are inherently undirected.  (There is something called a \"minimum spanning arborescence\" for directed graphs, but algorithms to find them are much more complicated).  Dijkstra's algorithm will work fine on directed graphs, since shortest path trees can indeed be directed.  Additionally, Dijkstra's algorithm does not necessarily yield the correct solution in graphs containing negative edge weights, while Prim's algorithm can handle this.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Is Dijkstra's algorithm, dynamic programming\r\n                \r\nAll implementation of Dijkstra's algorithms I have seen do not have a recursive function, but I have also read that by definition dynamic programming is an algorithm with a recursive function and \"memory\" of things already calculated.\n\nSo is Dijkstra's algorithm with a loop qualified as dynamic programming?Or in order to qualify as dynamic algorithm I have to change a loop into a recursive function.\n    ", "Answer": "\r\n\n  All implementation of Dijkstra's algorithms I have seen do not have a\n  recursive function\n\n\nRecursion gives us a stack. But we don't need a stack here. We need a priority queue. The efficient way to implement Dijkstra's algorithm uses a heap (stl priority_queue in c++). \n\n\n  but I have also read that by definition dynamic programming is an\n  algorithm with a recursive function and \"memory\" of things already\n  calculated.\n\n\nDynamic Programming need not be written in a recursive way though most people prefer to write it in a recursive way.\n\nFor example: \n\n```\nint dp[MAX]={-1,-1,...};\nfind fibonacci(int nthTerm){\n   if(n <= 1) return n;\n   if(dp[n]!=-1) return dp[n];\n   return dp[n]=fibonacci(n-1)+fibonacci(n-2);\n}\n```\n\n\nis a recursive implementation of DP\n\nand\n\n```\nint dp[MAX]={0,1,-1,-1,-1,..};\nint lastFound = 1;\nint fibonacci(int nthTerm){\n    for(int i=lastFound+1;i<=n;i++){\n       dp[i]=dp[i-1]+dp[i-2];\n    }\n    return dp[n];\n}\n```\n\n\nis an iterative way of writing it to save stack memory.\n\nRemember that any algorithm \n\n1) that does not recalculate the result that is already found and\n\n2) uses the existing result to find the required result\n\ncan be called as a DP.\n\n\n  So is Dijkstra's algorithm with a loop qualified as dynamic\n  programming?\n\n\nDijkstra is DP!\n\n\n  Or in order to qualify as dynamic algorithm I have to change a loop\n  into a recursive function.\n\n\nNo\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm in python\r\n                \r\nI am trying to implement Dijkstra's algorithm in python using arrays. This is my implementation.\n```\ndef extract(Q, w):\n    m=0\n    minimum=w[0]\n    for i in range(len(w)):\n        if w[i]<minimum:\n            minimum=w[i]\n            m=i\n    return m, Q[m]\n\ndef dijkstra(G, s, t='B'):\n    Q=[s]\n    p={s:None}\n    w=[0]\n    d={}\n    for i in G:\n        d[i]=float('inf')\n        Q.append(i)\n        w.append(d[i])\n    d[s]=0\n    S=[]\n    n=len(Q)\n    while Q:\n        u=extract(Q,w)[1]\n        S.append(u)\n        #w.remove(extract(Q, d, w)[0])\n        Q.remove(u)\n        for v in G[u]:\n            if d[v]>=d[u]+G[u][v]:\n                d[v]=d[u]+G[u][v]\n                p[v]=u\n    return d, p\n\nB='B'\nA='A'\nD='D'\nG='G'\nE='E'\nC='C'\nF='F'\nG={B:{A:5, D:1, G:2}, A:{B:5, D:3, E:12, F:5}, D:{B:1, G:1, E:1, A:3}, G:{B:2, D:1, C:2}, C:{G:2, E:1, F:16}, E:{A:12, D:1, C:1, F:2}, F:{A:5, E:2, C:16}}\nprint \"Assuming the start vertex to be B:\"\nprint \"Shortest distances\", dijkstra(G, B)[0]\nprint \"Parents\", dijkstra(G, B)[1]\n\n```\n\nI expect the answer to be:\n```\nAssuming the start vertex to be B:\nShortest distances {'A': 4, 'C': 4, 'B': 0, 'E': 2, 'D': 1, 'G': 2, 'F': 4}\nParents {'A': 'D', 'C': 'G', 'B': None, 'E': 'D', 'D': 'B', 'G': 'D', 'F': 'E'}\n```\n\nHowever, the answer that I get is this:\n```\nAssuming the start vertex to be B:\nShortest distances {'A': 4, 'C': 4, 'B': 0, 'E': 2, 'D': 1, 'G': 2, 'F': 10}\nParents {'A': 'D', 'C': 'G', 'B': None, 'E': 'D', 'D': 'B', 'G': 'D', 'F': 'A'}.\n```\n\nFor the node F, the program gives the incorrect answer. Can someone please tell me why?\n    ", "Answer": "\r\nAs others have pointed out, due to not using understandable variable names, it is almost impossible to debug your code.\n\nFollowing the wiki article about Dijkstra's algorithm, one can implement it along these lines (and in a million other manners):\n\n```\nnodes = ('A', 'B', 'C', 'D', 'E', 'F', 'G')\ndistances = {\n    'B': {'A': 5, 'D': 1, 'G': 2},\n    'A': {'B': 5, 'D': 3, 'E': 12, 'F' :5},\n    'D': {'B': 1, 'G': 1, 'E': 1, 'A': 3},\n    'G': {'B': 2, 'D': 1, 'C': 2},\n    'C': {'G': 2, 'E': 1, 'F': 16},\n    'E': {'A': 12, 'D': 1, 'C': 1, 'F': 2},\n    'F': {'A': 5, 'E': 2, 'C': 16}}\n\nunvisited = {node: None for node in nodes} #using None as +inf\nvisited = {}\ncurrent = 'B'\ncurrentDistance = 0\nunvisited[current] = currentDistance\n\nwhile True:\n    for neighbour, distance in distances[current].items():\n        if neighbour not in unvisited: continue\n        newDistance = currentDistance + distance\n        if unvisited[neighbour] is None or unvisited[neighbour] > newDistance:\n            unvisited[neighbour] = newDistance\n    visited[current] = currentDistance\n    del unvisited[current]\n    if not unvisited: break\n    candidates = [node for node in unvisited.items() if node[1]]\n    current, currentDistance = sorted(candidates, key = lambda x: x[1])[0]\n\nprint(visited)\n```\n\n\nThis code is more verbous than necessary and I hope comparing your code with mine you might spot some differences.\n\nThe result is:\n\n```\n{'E': 2, 'D': 1, 'G': 2, 'F': 4, 'A': 4, 'C': 3, 'B': 0}\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "dijkstra's algorithm - in c++?\r\n                \r\nfor the past four days I am trying to understand the dijkstra's algorithm. But I can't. I have a vector of points. From that I created a cost matrix. But I don't know how to make the dijkstra's algorithm. Sources are available in net, but I am not from Computer science background, So I can't understand them. I am trying to make a function like this \n\n```\nvector<int> dijkstra(costMatrix[][])\n{\n  ....\n  ....\n  return vector<int>pathPointindex\n}\n\nmain()\n{\n    vector<Point> availablePoints;\n    costMatrix[][]=createCostMatrix();\n    vector<int> indexes=dijikstra(costMatrix)\n    for(int i=0;i<indexes.size();i++)\n       cout << \"path points are \" << availablePoints[indexes[i]] << endl;\n}\n```\n\n\nIf anybody, can you please post the code. I am not lazy. But my project already crossed the deadline one day ago. Now I lost my hope to understand the logic. Now Just I want the function. \"A man in need is the angel indeed\" .\n\nEDIT: Special thanks to \"Loki astari\" for his excellent answer\n    ", "Answer": "\r\nDijkstra’s algorithm\nIn English:\nThis is an algorithm for finding the shortest route from point A to point B.\nIn computing terms we simplify the route to a graph consisting of nodes and arcs. Each node represents an intermediate point while each arc connect two nodes and has a (non negative) weight representing the cost to traverse between the two nodes.\nTo implement the algorithm you need two lists:\n\nfinished: A set of (node,cost) where you have computed the minimum cost to reach.\nworking:  A sorted list of (node,cost) that have been checked.\n\nAlgorithm:\n```\nworking.addNode(Start, 0); // No cost to get to start.\n\nfor( (node, cost) = working.popHead(); node != End; (node,cost) = working.popHead())\n{\n    // If we have already processed this node ignore it.\n    if (finished.find(node))\n    {    continue;\n    }\n\n    // We have just removed a node from working.\n    // Because it is the top of the list it is guaranteed to be the shortest route to\n    // the node. If there is another route to the node it must go through one of the\n    // other nodes in the working list which means the cost to reach it will be higher\n    // (because working is sorted). Thus we have found the shortest route to the node.\n\n    // As we have found the shortest route to the node save it in finished.\n    finished.addNode(node,cost);\n\n    // For each arc leading from this node we need to find where we can get to.\n    foreach(arc in node.arcs())\n    {\n        dest = arc.dest();\n        if (NOT (finished.find(dest)))\n        {\n            // If the node is already in finished then we don't need to worry about it\n            // as that will be the shortest route other wise calculate the cost and add\n            // this new node to the working list.\n            destCost = arc.cost() + cost;\n            working.addNode(dest,destCost); // Note. Working is sorted list\n        }\n    }\n} \n```\n\nSo if you think about this algorithm. Say you are traveling from London to Manchester.\n```\nfinished = {} // empty.\nworking  = { (London,0) }\n```\n\nUsing the following Costs matrix:\n```\n                  L    S    O    B    N    M    W\n(L) ondon         -    50   60   100  130  -    -\n(S) outhampton    50   -    70   -    -    -    -\n(O) xford         60   70   -    50   -    200  -\n(B) irmingham     100  -    50   -    -    80   110\n(N) orwich        130  -    -    -    -    -    -\n(M) anchester     -    -    200  80   -    -    80\nNe(W) castle      -    -    -    110  -    80   -\n```\n\nNow you take London out of the working list (as it is at the head) and place it into the finished list. Then add to the working list all the towns directly connected to London.\n```\nfinished = { (London,0) }\nworking  = { (Southampton, 50), (Oxford, 60), (Birmingham, 100), (Norwich,130) }\n```\n\nConsider the towns in the working set the outer edge of a bubble that has expanded from London. The job of Dijkstra's algorithm is to keep expanding the bubble until we hit Manchester (without retracing any steps we have already taken). So the bubble always expands outwards and we always expand the part of the bubble that is smallest.\nSo the next step is to take the head of the list and repeat. From Southampton there are only two destinations. Back to London (which we discard as it is in the finished list) and Oxford. The cost to get to Oxford is 50 + the cost from Southampton to Oxford (so notice it is in the working list twice but don;t worry we will discard it later as not an optimal route).\n```\nfinished = { (London,0), (Southampton,50) }\nworking  = { (Oxford, 60), (Birmingham, 100), (Oxford, 120), (Norwich,130) }\n```\n\nSo repeat the loop. The head of the list is Oxford. From Oxford we can go to Manchester(200), Birmingham(50) or back to London(60) or Southampton(Remember we need to add the cost of getting to oxford to each of these costs above. Note that from Oxford we could have gone to Southampton but we have already found the shortest route to Southampton so no processing is required) This will leave us with:\n```\nfinished = { (London,0), (Southampton,50), (Oxford, 60) }\nworking  = { (Birmingham, 100), (Birmingham,110), (Oxford, 120), (Norwich,130), (Manchester,200)}\n```\n\nNotice we have Manchester in the working list now (this is our destination). But we need to keep working as we may find a shorter route. So now we expand from Birmingham. From there we can go to Oxford(50), Manchester(80), London(100), Newcastle(110). Adding the cost of getting to Birmingham in the first place this gives us:\n```\nfinished = { (London,0), (Southampton,50), (Oxford, 60), (Birmingham, 100) }\nworking  = { (Birmingham,110), (Oxford, 120), (Norwich,130), {Manchester, 180), (Manchester,200), (Newcastle, 210)}\n```\n\nThe next two nodes. Oxford and Birmingham are already in the finished list so we can ignore them. So unless there is a route from Norwich to Manchester that is less than 50 miles we will reach Manchester in the iteration after that.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm with negative weights\r\n                \r\nCan we use Dijkstra's algorithm with negative weights?\n\nSTOP! Before you think \"lol nub you can just endlessly hop between two points and get an infinitely cheap path\", I'm more thinking of one-way paths.\n\nAn application for this would be a mountainous terrain with points on it. Obviously going from high to low doesn't take energy, in fact, it generates energy (thus a negative path weight)! But going back again just wouldn't work that way, unless you are Chuck Norris.\n\nI was thinking of incrementing the weight of all points until they are non-negative, but I'm not sure whether that will work.\n    ", "Answer": "\r\nAs long as the graph does not contain a negative cycle (a directed cycle whose edge weights have a negative sum), it will have a shortest path between any two points, but Dijkstra's algorithm is not designed to find them. The best-known algorithm for finding single-source shortest paths in a directed graph with negative edge weights is the Bellman-Ford algorithm. This comes at a cost, however: Bellman-Ford requires O(|V|·|E|) time, while Dijkstra's requires O(|E| + |V|log|V|) time, which is asymptotically faster for both sparse graphs (where E is O(|V|)) and dense graphs (where E is O(|V|^2)).\n\nIn your example of a mountainous terrain (necessarily a directed graph, since going up and down an incline have different weights) there is no possibility of a negative cycle, since this would imply leaving a point and then returning to it with a net energy gain - which could be used to create a perpetual motion machine.\n\nIncreasing all the weights by a constant value so that they are non-negative will not work. To see this, consider the graph where there are two paths from A to B, one traversing a single edge of length 2, and one traversing edges of length 1, 1, and -2. The second path is shorter, but if you increase all edge weights by 2, the first path now has length 4, and the second path has length 6, reversing the shortest paths. This tactic will only work if all possible paths between the two points use the same number of edges.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Understanding Time complexity calculation for Dijkstra Algorithm\r\n                \r\nAs per my understanding, I have calculated time complexity of Dijkstra Algorithm as big-O notation using adjacency list given below. It didn't come out as it was supposed to and that led me to understand it step by step.\n\n\nEach vertex can be connected to (V-1) vertices, hence the number of adjacent edges to each vertex is V - 1. Let us say E represents V-1 edges connected to each vertex.\nFinding & Updating each adjacent vertex's weight in min heap is O(log(V)) + O(1) or ```\nO(log(V))```\n.\nHence from step1 and step2 above, the time complexity for updating all adjacent vertices of a vertex is E*(logV). or ```\nE*logV```\n.\nHence time complexity for all V vertices is V * (E*logV) i.e ```\nO(VElogV)```\n.\n\n\nBut the time complexity for Dijkstra Algorithm is O(ElogV). Why?\n    ", "Answer": "\r\nDijkstra's shortest path algorithm is ```\nO(ElogV)```\n where:\n\n\n```\nV```\n is the number of vertices\n```\nE```\n is the total number of edges\n\n\nYour analysis is correct, but your symbols have different meanings! You say the algorithm is ```\nO(VElogV)```\n where:\n\n\n```\nV```\n is the number of vertices\n```\nE```\n is the maximum number of edges attached to a single node.\n\n\nLet's rename your ```\nE```\n to ```\nN```\n. So one analysis says ```\nO(ElogV)```\n and another says ```\nO(VNlogV)```\n. Both are correct and in fact ```\nE = O(VN)```\n. The difference is that ```\nElogV```\n is a tighter estimation.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "backwards Dijkstra's algorithm\r\n                \r\nI have started to implement backwards Dijkstra's algorithm in python:\n\n```\ndef backwardsDijkstra(g: DoubleDictGraph, s, t):\n    q = PriorityQueue()\n    dist = {}\n    next = {}\n    q.add(t, 0)\n    dist[t] = 0\n    found = False\n    while not q.isEmpty() and not found:\n        x = q.pop()\n        for y in g.parseNin(x):\n            if y not in dist.keys() or dist[x] + g.Cost(x, y) < dist[y]:\n                dist[y] = dist[x] + g.Cost(x, y)\n                q.add(y, dist[y])\n                next[y] = x\n        if x == t:\n            found = True\n    return dist[s], next\n```\n\n\nAnd I can't figure out why it stops at the second iteration for the next graph for example:\n\n```\n5 7\n0 1 5\n0 2 20\n1 2 10\n1 3 30\n2 3 5\n2 4 20\n3 4 10\n(number of vertices, number of edges, (start,end,cost)\n```\n\n    ", "Answer": "\r\nThe bug in you code is at this line:\n```\n        if x == t:\n            found = True\n```\n\nSince you are starting from ```\nt```\n (target), you should be looking for ```\ns```\n (source). Currently you are breaking out of the loop for the first candidate (which is t).\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Is Dijkstra's algorithm a heuristic?\r\n                \r\nCan someone explain to me whether Dijkstra's algorithm is  heuristic or not and how this algorithm works\n    ", "Answer": "\r\nNo. For this reason, the A* search algorithm is used, which is made on the principles of Dijkstra’s shortest path algorithm to provide a faster solution when faced with the problem of finding the shortest path between two nodes. It achieves this by introducing a heuristic element to help decide the next node to consider as it moves along the path. The A* algorithm uses a heuristic function to help decide which path to follow next.\n\nOne of the drawbacks with Dijkstra's algorithm is that it can (and will) evaluate paths that will never provide the shortest option. The heuristic function provides an estimate of the minimum cost between a given node and the target node. The algorithm will combine the actual cost from the start node - referred to as g(n) - with the estimated cost to the target node - referred to as h(n) - and uses the result to select the next node to evaluate. This is explained in more detail in the step-by-step method that follows.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Interpreting Dijkstra's Algorithm\r\n                \r\n\n\nI understand how to find the shortest path from start to finish as explained by the Dijkstra's Algorithm, what I do not understand is the interpretation. Here, from the graph in the picture, order added to my known set from A to E is ```\nA,C,B,D,F,H,G,E```\n what I do not get is, how to get the path from A to E as shown in the picture (the mathematical aspect)\n    ", "Answer": "\r\nEvery node has a parent node. When you reach ```\n'E'```\n, you simply look at its parent and so on until you find ```\n'A'```\n. This way you'll find the list in reverse order. Reverse the list it to find the path from ```\n'A'```\n to ```\n'E'```\n. \n\nYour parent list will be ```\n'E' 'G'  'H'  'F'  'B'  'A'```\n if you append in order.\n\nNOTE: The \"parent node\" is the node indicated in the table's \"path\" column\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm Pseudocode Confusion\r\n                \r\nI am trying to implement a version of Dijkstra's algorithm for the traveling salesman problem and I found this paper: https://www.researchgate.net/figure/Dijkstras-algorithm-for-many-targets-with-a-pruning-heuristic-An-upper-bound-B-for-d-v_fig2_257428759\nI understand the algorithm but I am confused about what 'free' means in this pseudocode. Can anyone explain it to me?\ni.e. in the following lines:\nif u is free then STOP fl\nif v is free then B = min{c, b} fl\nA Heuristic for Dijkstra's Algorithm with Many Targets (Pseudocode)\n    ", "Answer": "\r\nThe paper you link to does not seem to deal with the Traveling Salesman Problem, but with bipartite matchings:\n\nBoth versions of the problem can be solved by solving\nn,n=max(|A|,|B|), single-source many-targets shortest-path (SSMTSP)\nproblems in a derived graph, see Section 4.\n\nA ```\nfree```\n node refers to a node that is not matched with any other node in the bipartite graph. This is stated in section 4 of the linked paper (page label 87), footnote ```\n5```\n:\n\nA node is free if no edge in M is incident to it.\n\n```\nM```\n is defined as the matching that needs to be computed on the previous page.\nThis algorithm seems to only be useful for this matching problem, which requires that you run it multiple times. It's only an improvement across these multiple runs for bipartite matchings, it is not a standalone algorithm.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm help in Python\r\n                \r\nIm having trouble with Dijkstra's algorithm in python. I understand how the Dijkstra's algorithm works, but im not that good in converting it into code. Is there any way to add the nodes of the path and print them out. I keep getting the path. Thank you.\n\n```\nimport heapq\nimport sys\n\nx = raw_input()\ny = raw_input()\nclass Graph:\n\ndef __init__(self):\n    self.vertices = {}\n\ndef add_vertex(self, name, edges):\n    self.vertices[name] = edges\n\ndef shortest_path(self, start, finish):\n    distances = {} # Distance from start to node\n    previous = {}  # Previous node in optimal path from source\n    nodes = [] # Priority queue of all nodes in Graph\n\n    for vertex in self.vertices:\n        if vertex == start: # Set root node as distance of 0\n            distances[vertex] = 0\n            heapq.heappush(nodes, [0, vertex])\n        else:\n            distances[vertex] = sys.maxint\n            heapq.heappush(nodes, [sys.maxint, vertex])\n        previous[vertex] = None\n\n    while nodes:\n        smallest = heapq.heappop(nodes)[1] # Vertex in nodes with smallest distance in distances\n        if smallest == finish: # If the closest node is our target we're done so print the path\n            path = []\n            while previous[smallest]: # Traverse through nodes til we reach the root which is 0\n                path.append(smallest)\n                smallest = previous[smallest]\n            return path\n        if distances[smallest] == sys.maxint: # All remaining vertices are inaccessible from source\n            break\n\n        for neighbor in self.vertices[smallest]: # Look at all the nodes that this vertex is attached to\n            alt = distances[smallest] + self.vertices[smallest][neighbor] # Alternative path distance\n            if alt < distances[neighbor]: # If there is a new shortest path update our priority queue (relax)\n                distances[neighbor] = alt\n                previous[neighbor] = smallest\n                for n in nodes:\n                    if n[1] == neighbor:\n                        n[0] = alt\n                        break\n                heapq.heapify(nodes)\n    return distances\n\ndef __str__(self):\n    return str(self.vertices)\n\ng = Graph()\ng.add_vertex('A', {'B': 7, 'C': 8})\ng.add_vertex('B', {'A': 7, 'F': 2})\ng.add_vertex('C', {'A': 8, 'F': 6, 'G': 4})\ng.add_vertex('D', {'F': 8})\ng.add_vertex('E', {'H': 1})\ng.add_vertex('F', {'B': 2, 'C': 6, 'D': 8, 'G': 9, 'H': 3})\ng.add_vertex('G', {'C': 4, 'F': 9})\ng.add_vertex('H', {'E': 1, 'F': 3})\nprint g.shortest_path(x, y)\n```\n\n    ", "Answer": "\r\nSo I was able to figure out how to use algorithm. Here what I came up with.\n```\nimport heapq\n\nx = raw_input()\ny = raw_input()\n\ndef shortestPath(start, end):\n    queue,seen = [(0, start, [])], set()\n    while True:\n        (cost, v, path) = heapq.heappop(queue)\n        if v not in seen:\n            path = path + [v]\n            seen.add(v)\n            if v == end:\n                return cost, path\n            for (next, c) in graph[v].iteritems():\n                heapq.heappush(queue, (cost + c, next, path))\n\ngraph = {\n    'a': {'w': 14, 'x': 7, 'y': 9},\n    'b': {'w': 9, 'z': 6},\n    'w': {'a': 14, 'b': 9, 'y': 2},\n    'x': {'a': 7, 'y': 10, 'z': 15},\n    'y': {'a': 9, 'w': 2, 'x': 10, 'z': 11},\n    'z': {'b': 6, 'x': 15, 'y': 11},\n}\n\ncost, path = shortestPath(x, y)\nprint cost, path\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "CUDA dijkstra's algorithm [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                It's difficult to tell what is being asked here. This question is ambiguous, vague, incomplete, overly broad, or rhetorical and  cannot be reasonably answered in its current form. For help clarifying this question so that it can be reopened,  visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nHas anybody implemented a CUDA parallelization version of Dijkstra's Algorithm for a given sparse matrix (cuSPARSE) graph, and for source, and target node, find the minimal K path?\n\nI really need it to solve a general graph I'll be constructing.\n\nVincent\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Compute Paths - Dijkstra's algorithm\r\n                \r\nI was seeing a implementation of dijkstra's algorithm and I didn't quite understand some parts of this code:\n\n```\npublic static void computePaths(Vertex source) {\n    source.minDistance = 0;\n    PriorityQueue<Vertex> vertexQueue = new PriorityQueue<Vertex>();\n    vertexQueue.add(source);\n\n    while (!vertexQueue.isEmpty()) {\n        Vertex u = vertexQueue.poll();\n\n        // Visit each edge exiting u\n        for (Edge e : u.adjacencies) {\n            Vertex v = e.target;\n            double distanceThroughU = u.minDistance + e.getweight();\n            if (distanceThroughU < v.minDistance) {\n                vertexQueue.remove(v);      //How can I remove if I didn't add it first, and why do I need to remove?\n                v.minDistance = distanceThroughU;\n                v.previous = u;\n                vertexQueue.add(v);        //Why is it add again?\n            }\n        }\n    }\n}\n```\n\n\nI read about dijkstra's algorithm so I know the general logic but while I was seeing this implementation there was a few things that I didn't understand why they were done. Can someone please try to explain? Especially where I have the comments!\n    ", "Answer": "\r\nTo update the information of node v\n\nYou want to update the information of node v that is stored in the priority queue because you found a shorter path to it.\n\nRemove() function removes the node if it exists in the priority queue.\n\nAfter that you update the information, then add it again with the updated information.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Optimizing the Dijkstra's algorithm\r\n                \r\nI need a graph-search algorithm that is enough in our application of robot navigation and I chose Dijkstra's algorithm. \n\nWe are given the gridmap which contains free, occupied and unknown cells where the robot is only permitted to pass through the free cells. The user will input the starting position and the goal position. In return, I will retrieve the sequence of free cells leading the robot from starting position to the goal position which corresponds to the path.\n\nSince executing the dijkstra's algorithm from start to goal would give us a reverse path coming from goal to start, I decided to execute the dijkstra's algorithm backwards such that I would retrieve the path from start to goal.\n\nStarting from the goal cell, I would have 8 neighbors whose cost horizontally and vertically is 1 while diagonally would be sqrt(2) only if the cells are reachable (i.e. not out-of-bounds and free cell).\n\nHere are the rules that should be observe in updating the neighboring cells, the current cell can only assume 8 neighboring cells to be reachable (e.g. distance of 1 or ```\nsqrt(2)```\n) with the following conditions:\n\n\nThe neighboring cell is not out of bounds\nThe neighboring cell is unvisited.\nThe neighboring cell is a free cell which can be checked via the 2-D grid map. \n\n\nHere is my implementation:\n\n```\n#include <opencv2/opencv.hpp>\n#include <algorithm>\n#include \"Timer.h\"\n\n/// CONSTANTS\nstatic const int UNKNOWN_CELL  = 197;\nstatic const int FREE_CELL     = 255;\nstatic const int OCCUPIED_CELL = 0;\n\n/// STRUCTURES for easier management.\nstruct vertex {\n    cv::Point2i id_;\n    cv::Point2i from_;\n\n    vertex(cv::Point2i id, cv::Point2i from)\n    {\n        id_ = id;\n        from_ = from;\n    }\n};\n\n/// To be used for finding an element in std::multimap STL.\nstruct CompareID\n{\n    CompareID(cv::Point2i val) : val_(val) {}\n    bool operator()(const std::pair<double, vertex> & elem) const {\n        return val_ == elem.second.id_;\n    }\nprivate:\n    cv::Point2i val_;\n};\n\n/// Some helper functions for dijkstra's algorithm.\nuint8_t get_cell_at(const cv::Mat & image, int x, int y)\n{\n    assert(x < image.rows);\n    assert(y < image.cols);\n    return image.data[x * image.cols + y];\n}\n\n/// Some helper functions for dijkstra's algorithm.\nbool checkIfNotOutOfBounds(cv::Point2i current, int rows, int cols)\n{\n    return (current.x >= 0 && current.y >= 0 &&\n            current.x < cols && current.y < rows);\n}\n\n/// Brief: Finds the shortest possible path from starting position to the goal position\n/// Param gridMap: The stage where the tracing of the shortest possible path will be performed.\n/// Param start: The starting position in the gridMap. It is assumed that start cell is a free cell.\n/// Param goal: The goal position in the gridMap. It is assumed that the goal cell is a free cell.\n/// Param path: Returns the sequence of free cells leading to the goal starting from the starting cell.\nbool findPathViaDijkstra(const cv::Mat& gridMap, cv::Point2i start, cv::Point2i goal, std::vector<cv::Point2i>& path)\n{\n    // Clear the path just in case\n    path.clear();\n    // Create working and visited set.\n    std::multimap<double,vertex> working, visited;\n\n    // Initialize working set. We are going to perform the djikstra's\n    // backwards in order to get the actual path without reversing the path.\n    working.insert(std::make_pair(0, vertex(goal, goal)));\n\n    // Conditions in continuing\n    // 1.) Working is empty implies all nodes are visited.\n    // 2.) If the start is still not found in the working visited set.\n    // The Dijkstra's algorithm\n    while(!working.empty() && std::find_if(visited.begin(), visited.end(), CompareID(start)) == visited.end())\n    {\n\n        // Get the top of the STL.\n        // It is already given that the top of the multimap has the lowest cost.\n        std::pair<double, vertex> currentPair = *working.begin();\n        cv::Point2i current = currentPair.second.id_;\n        visited.insert(currentPair);\n        working.erase(working.begin());\n\n        // Check all arcs\n        // Only insert the cells into working under these 3 conditions:\n        // 1. The cell is not in visited cell\n        // 2. The cell is not out of bounds\n        // 3. The cell is free\n        for (int x = current.x-1; x <= current.x+1; x++)\n            for (int y = current.y-1; y <= current.y+1; y++)\n            {\n\n                if (checkIfNotOutOfBounds(cv::Point2i(x, y), gridMap.rows, gridMap.cols) &&\n                        get_cell_at(gridMap, x, y) == FREE_CELL &&\n                        std::find_if(visited.begin(), visited.end(), CompareID(cv::Point2i(x, y))) == visited.end())\n                {\n                    vertex newVertex = vertex(cv::Point2i(x,y), current);\n                    double cost = currentPair.first + sqrt(2);\n                    // Cost is 1\n                    if (x == current.x || y == current.y)\n                        cost = currentPair.first + 1;\n                    std::multimap<double, vertex>::iterator it =\n                            std::find_if(working.begin(), working.end(), CompareID(cv::Point2i(x, y)));\n                    if (it == working.end())\n                        working.insert(std::make_pair(cost, newVertex));\n                    else if(cost < (*it).first)\n                    {\n                        working.erase(it);\n                        working.insert(std::make_pair(cost, newVertex));\n                    }\n                }\n            }\n    }\n\n    // Now, recover the path.\n    // Path is valid!\n    if (std::find_if(visited.begin(), visited.end(), CompareID(start)) != visited.end())\n    {\n        std::pair <double, vertex> currentPair = *std::find_if(visited.begin(), visited.end(), CompareID(start));\n        path.push_back(currentPair.second.id_);\n        do\n        {\n            currentPair = *std::find_if(visited.begin(), visited.end(), CompareID(currentPair.second.from_));\n            path.push_back(currentPair.second.id_);\n        } while(currentPair.second.id_.x != goal.x || currentPair.second.id_.y != goal.y);\n        return true;\n    }\n    // Path is invalid!\n    else\n        return false;\n\n}\n\nint main()\n{\n    //    cv::Mat image = cv::imread(\"filteredmap1.jpg\", CV_LOAD_IMAGE_GRAYSCALE);\n    cv::Mat image = cv::Mat(100,100,CV_8UC1);\n    std::vector<cv::Point2i> path;\n\n    for (int i = 0; i < image.rows; i++)\n        for(int j = 0; j < image.cols; j++)\n        {\n            image.data[i*image.cols+j] = FREE_CELL;\n\n            if (j == image.cols/2 && (i > 3 && i < image.rows - 3))\n                image.data[i*image.cols+j] = OCCUPIED_CELL;\n\n            //            if (image.data[i*image.cols+j] > 215)\n            //                image.data[i*image.cols+j] = FREE_CELL;\n            //            else if(image.data[i*image.cols+j] < 100)\n            //                image.data[i*image.cols+j] = OCCUPIED_CELL;\n            //            else\n            //                image.data[i*image.cols+j] = UNKNOWN_CELL;\n        }\n\n    // Start top right\n    cv::Point2i goal(image.cols-1, 0);\n    // Goal bottom left\n    cv::Point2i start(0, image.rows-1);\n\n    // Time the algorithm.\n    Timer timer;\n    timer.start();\n    findPathViaDijkstra(image, start, goal, path);\n    std::cerr << \"Time elapsed: \" << timer.getElapsedTimeInMilliSec() << \" ms\";\n\n\n    // Add the path in the image for visualization purpose.\n    cv::cvtColor(image, image, CV_GRAY2BGRA);\n    int cn = image.channels();\n    for (int i = 0; i < path.size(); i++)\n    {\n        image.data[path[i].x*cn*image.cols+path[i].y*cn+0] = 0;\n               image.data[path[i].x*cn*image.cols+path[i].y*cn+1] = 255;\n               image.data[path[i].x*cn*image.cols+path[i].y*cn+2] = 0;\n\n    }\n    cv::imshow(\"Map with path\", image);\n    cv::waitKey();\n    return 0;\n}\n```\n\n\nFor the algorithm implementation, I decided to have two sets namely the visited and working set whose each elements contain:\n\n\nThe location of itself in the 2D grid map.\nThe accumulated cost\nThrough what cell did it get its accumulated cost (for path recovery)\n\n\nAnd here is the result:\n\n\n\nThe black pixels represent obstacles, the white pixels represent free space and the green line represents the path computed.\n\nOn this implementation, I would only search within the current working set for the minimum value and DO NOT need to scan throughout the cost matrix (where initially, the initially cost of all cells are set to infinity and the starting point 0). Maintaining a separate vector of the working set I think promises a better code performance because all the cells that have cost of infinity is surely to be not included in the working set but only those cells that have been touched. \n\nI also took advantage of the STL which C++ provides. I decided to use the std::multimap since it can store duplicating keys (which is the cost) and it sorts the lists automatically. However, I was forced to use std::find_if() to find the id (which is the row,col of the current cell in the set) in the visited set to check if the current cell is on it which promises linear complexity. I really think this is the bottleneck of the Dijkstra's algorithm. \n\nI am well aware that A* algorithm is much faster than Dijkstra's algorithm but what I wanted to ask is my implementation of Dijkstra's algorithm optimal? Even if I implemented A* algorithm using my current implementation in Dijkstra's which is I believe suboptimal, then consequently A* algorithm will also be suboptimal.\n\nWhat improvement can I perform? What STL is the most appropriate for this algorithm? Particularly, how do I improve the bottleneck? \n    ", "Answer": "\r\nYou're using a ```\nstd::multimap```\n for 'working' and 'visited'.  That's not great.\n\nThe first thing you should do is change ```\nvisited```\n into a per-vertex flag so you can do your ```\nfind_if```\n in constant time instead of linear times and also so that operations on the list of visited vertices take constant instead of logarithmic time.  You know what all the vertices are and you can map them to small integers trivially, so you can use either a ```\nstd::vector```\n or a ```\nstd::bitset```\n.\n\nThe second thing you should do is turn ```\nworking```\n into a priority queue, rather than a balanced binary tree structure, so that operations are a (largish) constant factor faster.  ```\nstd::priority_queue```\n is a barebones binary heap.  A higher-radix heap---say quaternary for concreteness---will probably be faster on modern computers due to its reduced depth.  Andrew Goldberg suggests some bucket-based data structures; I can dig up references for you if you get to that stage.  (They're not too complicated.)\n\nOnce you've taken care of these two things, you might look at A* or meet-in-the-middle tricks to speed things up even more.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm in java\r\n                \r\nI'm implementing Dijkstra's algorithm in one of my projects but when i pass those points :  \n\n```\nVertex A = new Vertex(\"A\");\nVertex B = new Vertex(\"B\");\nVertex D = new Vertex(\"D\");\nVertex F = new Vertex(\"F\");\nVertex K = new Vertex(\"K\");\n\n\n// set the edges and weight\nA.adjacencies = new Edge[]{ new Edge(B, 6) };\nA.adjacencies = new Edge[]{ new Edge(D, 8) };\n\nB.adjacencies = new Edge[]{ new Edge(F, 5) };\nD.adjacencies = new Edge[]{ new Edge(F, 3) };\nB.adjacencies = new Edge[]{ new Edge(A, 6) };\nD.adjacencies = new Edge[]{ new Edge(A, 8) };\n\nF.adjacencies = new Edge[]{ new Edge(B, 5) };\nF.adjacencies = new Edge[]{ new Edge(D, 3) };\nF.adjacencies = new Edge[]{ new Edge(K, 40) };\n\nK.adjacencies = new Edge[]{ new Edge(F, 40) };\n\n computePaths(A); // run Dijkstra\nSystem.out.println(\"Distance to \" + K + \": \" + K.minDistance);\nList<Vertex> path2 = getShortestPathTo(K);\nSystem.out.println(\"Path: \" + path2);\n```\n\n\nthe algo's giving me : Distance to K: Infinity where's the problem ? \n\nthis's the full code of the algorithm : \n\n```\n   class Vertex implements Comparable<Vertex>\n{\n    public final String name;\n    public Edge[] adjacencies;\n    public double minDistance = Double.POSITIVE_INFINITY;\n    public Vertex previous;\n    public Vertex(String argName) { name = argName; }\n    public String toString() { return name; }\n    public int compareTo(Vertex other)\n    {\n        return Double.compare(minDistance, other.minDistance);\n    }\n\n}\n\n\nclass Edge\n{\n    public final Vertex target;\n    public final double weight;\n    public Edge(Vertex argTarget, double argWeight)\n    { target = argTarget; weight = argWeight; }\n}\n\n    public void computePaths(Vertex source) {\n        source.minDistance = 0.;\n        PriorityQueue<Vertex> vertexQueue = new PriorityQueue<Vertex>();\n        vertexQueue.add(source);\n\n        while (!vertexQueue.isEmpty()) {\n            Vertex u = vertexQueue.poll();\n\n            // Visit each edge exiting u\n            for (Edge e : u.adjacencies) {\n                Vertex v = e.target;\n                double weight = e.weight;\n                double distanceThroughU = u.minDistance + weight;\n                if (distanceThroughU < v.minDistance) {\n                    vertexQueue.remove(v);\n\n                    v.minDistance = distanceThroughU;\n                    v.previous = u;\n                    vertexQueue.add(v);\n                }\n            }\n        }}\n\n\n    public List<Vertex> getShortestPathTo(Vertex target) {\n        List<Vertex> path = new ArrayList<Vertex>();\n        for (Vertex vertex = target; vertex != null; vertex = vertex.previous)\n            path.add(vertex);\n\n        Collections.reverse(path);\n        return path;\n    }\n```\n\n\nany ideas why the distance = infinity ? \n    ", "Answer": "\r\nHere you overwrite the field's value. When you assign a new value of ```\nEdge[]```\n, the old one gets deleted.\nDid you intend to add instead?\n\n```\nB.adjacencies = new Edge[]{ new Edge(F, 5) };\nD.adjacencies = new Edge[]{ new Edge(F, 3) };\nB.adjacencies = new Edge[]{ new Edge(A, 6) };\nD.adjacencies = new Edge[]{ new Edge(A, 8) };\n```\n\n\nTo assign several ```\nEdges```\n to each ```\nVertex```\n use array initializers with several elements:\n\n```\nA.adjacencies = new Edge[]{ new Edge(B, 6), new Edge(D, 8) };\nB.adjacencies = new Edge[]{ new Edge(F, 5), new Edge(A, 6) };\nD.adjacencies = new Edge[]{ new Edge(F, 3), new Edge(A, 8) };\nF.adjacencies = new Edge[]{ new Edge(B, 5), new Edge(D, 3), new Edge(K, 40)};\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Boost's Dijkstra's Algorithm Tutorial\r\n                \r\nI am having difficulty figuring out how to use Boost's Dijkstra's algorithm. I have gone over their example and documentation, but I still cannot understand how to use it. \n\n[Boost's documentation: http://www.boost.org/doc/libs/1_50_0/libs/graph/doc/dijkstra_shortest_paths.html]\n[Example of Dijkstra: http://www.boost.org/doc/libs/1_36_0/libs/graph/example/dijkstra-example.cpp]\n\nCan someone please offer a step by step explanation with code examples to show how to use Boost's Dijkstra's algorithm?\nI am using Boost's adjacency_list for my graph, just as in the example link above. (adjacency_list: http://www.boost.org/doc/libs/1_50_0/libs/graph/doc/adjacency_list.html)\n    ", "Answer": "\r\nAbout the questions in the comments:\n\n\nAccording to the comment in the sourcecode of the example VC++ has some problems with the named parameter mechanism used. Therefore I'd assume that both branches do basically the same think with the VC++ version just being more verbose (I didn't dive into it long enough to be 100% sure though).\nA ```\nproperty_map```\n maps vertices/edges to additional data associated with the particular vertex/edge. E.g. the ```\nweightmap```\n in the example associates a weight (travelling cost) with each edge.\nThe ```\npredecessor_map```\n is used to record the paths for all vertices (for every vertex the predecessor on the path from the root is recorded). As for why it's needed: Well that information is something one often hopes to get out of the algorithm. \nThe parameters are clearly listed in the description. Note the two versions, one with named parameters and one without (the later being used in VC++). \n\n\nnow for a somewhat step by step of the example code given in the documentation (note that I never actually used Boost.Graph, so this is no guarantees on correctness, also I only included the relevant parts and omitted the ```\n#if```\n for VC++):\n\n```\n  const int num_nodes = 5;\n  //names of graph nodes\n  enum nodes { A, B, C, D, E };\n  char name[] = \"ABCDE\";\n  //edges of the graph\n  Edge edge_array[] = { Edge(A, C), Edge(B, B), Edge(B, D), Edge(B, E),\n    Edge(C, B), Edge(C, D), Edge(D, E), Edge(E, A), Edge(E, B)\n  };\n  //weights/travelling costs for the edges\n  int weights[] = { 1, 2, 1, 2, 7, 3, 1, 1, 1 };\n  int num_arcs = sizeof(edge_array) / sizeof(Edge);\n\n  //graph created from the list of edges\n  graph_t g(edge_array, edge_array + num_arcs, weights, num_nodes);\n  //create the property_map from edges to weights\n  property_map<graph_t, edge_weight_t>::type weightmap = get(edge_weight, g);\n\n  //create vectors to store the predecessors (p) and the distances from the root (d)\n  std::vector<vertex_descriptor> p(num_vertices(g));\n  std::vector<int> d(num_vertices(g));\n  //create a descriptor for the source node\n  vertex_descriptor s = vertex(A, g);\n\n  //evaluate dijkstra on graph g with source s, predecessor_map p and distance_map d\n  //note that predecessor_map(..).distance_map(..) is a bgl_named_params<P, T, R>, so a named parameter\n  dijkstra_shortest_paths(g, s, predecessor_map(&p[0]).distance_map(&d[0]));\n```\n\n\nAs I mentioned in the comments personally I find lemon more intuitive to use then Boost.Graph, so maybe you might want to give that a look instead\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Multiple inputs for Dijkstra's algorithm\r\n                \r\nThe inputs to Dijkstra's algorithm are a directed and weighted graph, generally represented by an adjacency (distance) matrix and a start node.\n\nI have two different distance matrices to be used as inputs, representing two different infrastructure (e.g., roads and cycle ways). Any ideas how modify Dijkstra's algorithm to be use these two inputs? I want to implement in Python. \n\nThanks!\n    ", "Answer": "\r\nDoes your requirement have a function through which the both matrices are related \nIf yes then on the basis of that function find a new weight matrix. Use this matrix on the flow path\n\nIf no, then try running matrix one first and then two and vice-versa and choose the one with corresponding cost output to your requirement\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm not working\r\n                \r\nI'm creating a game for a school project, and I want to use Dijkstra's algorithm as part of an AI for the objects the player needs to dodge.\n\nSo I have a graph (an adjacency matrix) and I want to use Dijkstra to get the path from each object to the player, but right now when I call the algorithm, it will not find the player if the player comes after the object.\n\nIn my understanding, Dijkstra's algorithm should visit all of the nodes until it finds the destination, but it doesn't in my case.\n\nHere's what my algorithm looks like so far:\n\n```\nNode* Graph::DijkstrasAlgorithm(Node* sNode, Node* dNode){\n    std::cout<<\"Hello Dijkstra!!\"<<std::endl;\n    for(unsigned int i = 0; i < this->nodeList.size(); ++i){\n        nodeList.at(i)->setDistance(INT_MAX);\n        nodeList.at(i)->setVisited(false);\n    }\n    std::cout<<\"everything is set\"<<std::endl;\n    sNode->setDistance(0);\n    int numberVisited = 0;\n    Node* u = new Node();\n    std::cout<<\"before while lus\"<<std::endl;\n    while(numberVisited < numberOfNodes){\n        u->setDistance(INT_MAX);\n        for(unsigned int j = 0; j < this->nodeList.size(); ++j){\n            if((u->getDistance() > this->nodeList.at(j)->getDistance()) && !this->nodeList.at(j)->isVisited() ){\n                u = this->nodeList.at(j);\n                u->setVisited(true);\n                numberVisited++;\n            }\n        }\n\n    std::cout<<u->getNodeName()<<\"==\"<<dNode->getNodeName()<<std::endl;\n        if((u == dNode) || (u->getDistance() == INT_MAX)){\n            std::cout<<\"true\"<<std::endl;\n            break;\n        }\n\n\n        for(int k = 0; k < u->numberOfneighbors(); ++k){\n            if(!u->getNeighbors(k)->isVisited())\n            {\n            //  std::cout<<u->getDistance()<<std::endl;\n                int alt = u->getDistance() + 1;\n                if( alt < u->getNeighbors(k)->getDistance()){\n                     u->getNeighbors(k)->setDistance(alt);\n                     u->getNeighbors(k)->setPrevious(u);\n                }\n            }\n        }\n\n    }\n    std::vector<Node* > stack;\n    u = dNode;\n    while(u->getPrevious() != NULL){\n        stack.insert(stack.begin(), u);\n        u = u->getPrevious();\n    }\n    if(!stack.empty())\n        return stack.at(0);\n    else\n        return sNode;\n\n\n}\n```\n\n\nIn this case, ```\ndNode```\n is the destination node, and ```\nsNode```\n is the start node.\n\nDoes anyone know what I'm doing wrong?\n    ", "Answer": "\r\nIn Dijkstra algorithm you mark as visited only the node to which the shortest augmenting path points to. I can see an error you make here:\n\n```\nu = this->nodeList.at(j);\nu->setVisited(true);\n```\n\n\nDon't mark the nodes as visited immediately.\n\nMark as visited only the node ```\nu```\n will point to after the cycle\n\n```\nfor(unsigned int j = 0; j < this->nodeList.size(); ++j){\n```\n\n\nOtherwise for every improvement you will mark the node as visited, not even processing all of them.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Implementing Dijkstra's algorithm using STL make_heap\r\n                \r\nAt least a couple of answers recommend using the STL heap functions to implement the priority queue in Dijkstra's algorithm:\n\nPerformance of Dijkstra's algorithm implementation\n\nImplementing Dijkstra's Algorithm\n\nWhat's the best way to reorder vertices in the heap (line 19) given that the STL doesn't include a heap function for updating keys? \n    ", "Answer": "\r\nYou need to let the vertex 'bubble up' through the heap (swapping it with its parent as needed) until it reaches its new position in the heap. \n\nIn pseudo-c++ adapted from Introduction to Algorithms 2nd ed. pg. 140:\n\n```\nheap[pos] = new_weight;\nwhile (pos > 0 && heap[parent(pos)] > heap[pos]) {\n    swap(heap[parent(pos)], heap[pos]);\n    pos = parent(pos);\n}\n```\n\n\nwhere ```\nint parent(int pos) { return (pos-1)/2; }```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Combining Dijkstra's algorithm and A* search? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nIs it possible to combine Dijkstra's Algorithm and A* search? How?\n    ", "Answer": "\r\nDijkstra's algorithm is just a special case of A* search where the heuristic function is 0. The less accurate the heuristic, the more A* behaves like Dijkstra's algorithm. You actually probably wouldn't want to combine them, since as long as you have an admissible heuristic A* will never expand more nodes than Dijkstra's algorithm. You'd only weaken the algorithm.\n\nHope this helps!\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "What is difference between BFS and Dijkstra's algorithms when looking for shortest path?\r\n                \r\nI was reading about Graph algorithms and I came across these two algorithms:\n\nDijkstra's algorithm\nBreadth-first search\n\nWhat is the difference between Dijkstra's algorithm and BFS while looking for the shortest-path between nodes?\nI searched a lot about this but didn't get any satisfactory answer!\n\nThe rules for BFS for finding shortest-path in a graph are:\n\nWe discover all the connected vertices,\nAdd them in the queue and also\nStore the distance (weight/length) from source u to that vertex v.\nUpdate with path from source u to that vertex v with shortest distance and we have it!\n\nThis is exactly the same thing we do in Dijkstra's algorithm!\n\nSo why are the time complexities of these algorithms so different?\nIf anyone can explain it with the help of a pseudo code then I will be\nvery grateful!\nI know I am missing something! Please help!\n    ", "Answer": "\r\nBreadth-first search is just Dijkstra's algorithm with all edge weights equal to 1.\n\nDijkstra's algorithm is conceptually breadth-first search that respects edge costs.\n\nThe process for exploring the graph is structurally the same in both cases.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm with minimum edge\r\n                \r\nSo first let's define Dijkstra algorithm:\nDijkstra's algorithm finds single-source shortest paths in a directed graph with non-negative edge weights.\nIf I have a source S and destination T I can find a shortest path between this two vertices with Dijkstra algorithm but here is the problem I want to find the shortest path between this two vertices which the number of edges between this two does not exceed form K.\nThe first part is Dijkstra algorithm but second is kind of BFS algorithm because we can find the shortest path in none weighted graph with BFS algorithm.\nSo I am wondering is there a way that can some how change the dijkstra in order to solve this problem?\nAny solution would be grateful.\n    ", "Answer": "\r\nYou can use Bellman-Ford's algorithm, and instead to run until ```\n|V| - 1```\n in the outer loop, run until ```\nk```\n. The outer loop iterator indicates the maximal length of the shortest path from the source to each target.\n\nFrom wikipedia (with the outer loop index modification)\n\n```\n   for i from 1 to k: //here up to k instead to |V|\n       for each edge (u, v) with weight w in edges:\n           if distance[u] + w < distance[v]:\n               distance[v] := distance[u] + w\n               predecessor[v] := u\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm Equal Weights\r\n                \r\nI'm working on my assignment about Dijkstra's Algorithm, and have gotten to a point where the remaining points are:\n\n```\nB: 30 from H\nC: Infinite\nE: 40 from H\nF: 30 from D\nG: Infinite\n```\n\n\nWould the next point that I chose be ```\nB```\n because alphabetically it comes before ```\nF```\n?\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Proving a modification in Dijkstra's Algorithm [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     This question appears to be off-topic because it lacks sufficient information to diagnose the problem. Describe your problem in more detail or include a minimal example in the question itself.\r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nIn Dijkstra's Algorithm, we compute path length to find the shortest path. The regular version of Dijkstra's Algorithm computes path length as sum of weights upto some node v. \nWhat if the path length is computed as sum of the lengths upto v + maximum weight traversed upto v ?\n\nI have worked out on paper and found that it still works. But how do I prove it?\n\nHelp will be much appreciated\n    ", "Answer": "\r\nIf by \"still works\", you mean it results in the same shortest paths, here's a counter-example:\n\n```\nB --1-- C -- 1 -- D  \n|                 |  \n1                 1\n|                 |  \nS --3-- A ----1----   \n```\n\n\nUsing just path length, the shortest path from S to A, will be via the edge from S to A. Using\npath length + max weight, the shortest path will be S to B to C to D to A, (weight 5). S to A will be weight 6.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Why does A* run faster than Dijkstra's algorithm?\r\n                \r\nWikipedia says A* runs in O(|E|) where |E| is the number of edges in the graph.  But my friend says A* is just a general case of Dijkstra's algorithm, and Dijkstra's algorithm runs in O(|E| + |V| log |V|).  So I am confused about why A* runs faster than Dijkstra's algorithm.\n    ", "Answer": "\r\nI think the time complexity of A* listed on Wikipedia is incorrect (or at least, it's misleading). That time complexity only seems to count the number of states expanded in the search, rather than the time required to determine which states to explore.\n\nTo be efficient, A* search needs to store a priority queue containing what nodes in the fringe need to be explored and it has to be able to call decrease-key on those priorities. The runtime for this is, in the worst-case, O(n log n + m) if implemented using a good priority queue. Therefore, in the worst case, you'd expect A* to degrade to Dijkstra's algorithm. Given a good heuristic, A* will not expand out all the nodes and edges that Dijkstra's algorithm would, which is the main reason why A* is faster.\n\nOf course, the time complexity of A* search needs to factor in the cost of computing the heuristic. Some complex heuristics might not be computable in time O(1), in which case the runtime for A* could actually be worse than Dijkstra's algorithm.\n\nHope this helps!\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Datatype for Dijkstra's algorithm?\r\n                \r\nI'd like to turn a 2D array (having nodes but also obstacles) into a graph in order to run Dijkstra's algorithm in SML, but as a beginner I don't come up with a good idea about the datatype I should use.\n\nAny help is welcome, thanks.\n    ", "Answer": "\r\nSince we dont have much data structures in SML we can use list to represent the graph(This is one way to do that).\nRepresent the graph using adjacency list. List of list of list.\n\n```\n-val graph=[  [[3,5],[6,9]],\n              [[4,7],[2,6]]    ];\n\nval graph = [[[3,5],[6,9]],[[4,7],[2,6]]] : int list list list\n```\n\n\nPresume that the first element of the list is vertex '1', the second element of the  list is vertex '2' and so on.\n\nIn this example vertex 1 has 2 edges (3,6) with the distance of (5,9). And the same way vertex 2 has 2 edges (4,2) with the distance of (7,6) respectively.\n\nWhenever a new edge comes in , add to the respective vertex list with the distance.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "bidirectional Dijkstra's algorithm Julia\r\n                \r\nIs there any implementation or package for bidirectional Dijkstra's algorithm in Julia?\nOr is there any better way to find the  the shortest path (time) from location i to location j then to  location i′ ?\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm in C++\r\n                \r\nI'm required to implement the Dijkstra's algorithm via ADT graph using the adjacency matrix representation for finding a shortest path by enhancing the pseudo code below using either C/C++ language.\n\n```\nprocedure Dijkstra(G, w, r, Parent[0:n-1], Dist)\n  for v← 0 to n-1 do\n    Dist[v] ← ∞\n    InTheTree[v] ← .false.\n  endfor\n  Parent[r] ←-1\n  Dist[r] ←0\n  for Stage ←1 to n-1 do \n    Select vertex u that minimises Dist[u] over all u such that InTheTree[u] = .false. \n    InTheTree[u] = .true.                                       // add u to T\n    for each vertex v such that uv ∈ E do             // update Dist[v] and \n      if .not. InTheTree[v]  then                // Parent[v] arrays\n        if Dist[u] + w(uv) < Dist[v]\n          Dist[v] = Dist[u] + w(uv)\n          Nearest[v] ←w(uv) \n          Parent[v] ← u\n        endif\n      endif\n    endfor\n  endfor\nend Dijkstra\n```\n\n\nHere is my solution of code which is being coded in C++. My lecturer claim that the code does not meet the pseudocode requirements and I'm not sure \nwhere it went wrong so can anyone help me to spot what doesn't match between the code and the pseudocode?\n\n```\n#include <stdio.h>\n#include <limits.h>\n#define N 9\n\nint minDistance(int dist[], bool sptSet[])\n{\n   int min = INT_MAX, min_index;\n\n   for (int n = 0; n < N; n++)\n     if (sptSet[v] == false && dist[n] <= min)\n         min = dist[n], min_index = n;\n\n   return min_index;\n}\nint printSolution(int dist[], int v)\n{\n   printf(\"Vertex   Distance from Source\\n\");\n   for (int i = 0; i < N; i++)\n      printf(\"%d \\t\\t %d\\n\", i, dist[i]);\n}\nvoid dijkstra(int graph[N][N], int src)\n{\n     int dist[N];     \n\n     bool sptSet[N];                         \n\n     for (int i = 0; i < N; i++) {\n        dist[i] = INT_MAX;\n        sptSet[i] = false;\n     }\n\n     dist[src] = 0;\n\n\n     for (int count = 0; count < N-1; count++)\n     {\n\n       int u = minDistance(dist, sptSet);\n            sptSet[u] = true;\n       for (int n = 0; n < N; n++)\n         if (!sptSet[n] && graph[u][n] && dist[u] != INT_MAX \n                                       && dist[u]+graph[u][n] < dist[n])\n            dist[n] = dist[u] + graph[u][n];\n     }\n     printSolution(dist, N);\n}\n\nint main()\n{\n   int graph[N][N] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n                      {4, 0, 8, 0, 0, 0, 0, 11, 0},\n                      {0, 8, 0, 7, 0, 4, 0, 0, 2},\n                      {0, 0, 7, 0, 9, 14, 0, 0, 0},\n                      {0, 0, 0, 9, 0, 10, 0, 0, 0},\n                      {0, 0, 4, 0, 10, 0, 2, 0, 0},\n                      {0, 0, 0, 14, 0, 2, 0, 1, 6},\n                      {8, 11, 0, 0, 0, 0, 1, 0, 7},\n                      {0, 0, 2, 0, 0, 0, 6, 7, 0}\n                     };\n\n    dijkstra(graph, 0);\n\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nThe most obvious mismatch is that your code does not have anything corresponding to to the pseudocode's ```\nParent```\n array.  I take that as an output parameter, though it's not explicitly so marked.  As you seem to have recognized, it is not needed for computing only the lengths of the minimum paths, but it contains all the information about the actual steps in those paths, and that is often desired information.\n\nYou also have no analog of the pseudocode's ```\nNearest```\n; it would be a bit mean to complain about that, though, as ```\nNearest```\n is not a parameter to the routine, and the pseudocode does not show its elements ever being read.  As such, it does not appear to serve any useful purpose.\n\nIt appears that this code also does not quite match:\n\n```\n         if (!sptSet[n] && graph[u][n] && dist[u] != INT_MAX \n                                       && dist[u]+graph[u][n] < dist[n])\n            dist[n] = dist[u] + graph[u][n];\n```\n\n\nThe condition ```\n&& dist[u] != INT_MAX```\n does not correspond to anything in the pseudocode. (It's also unnecessary, inasmuch as ```\nu```\n was returned by ```\nminDistance()```\n, and therefore that condition should always be satisfied).\n\nConceivably, your instructor may also be dissatisfied that you print the min path lengths instead of returning them.  It depends a bit on the pseudocode dialect, but I'd be inclined to take the appearance of ```\nDist```\n in the parameter list as an indication that it is an output parameter, not merely an internal variable.\n\nIf your instructor is being extremely picky, then perhaps you can get some slack by pointing out some apparent errors in the pseudocode:\n\n\nAs already mentioned, ```\nNearest```\n is not a parameter, and it is written to but never read from.\nIt looks like the conditional ```\nif Dist[u] ← w(uv) < Dist[v] then```\n should instead be ```\nif Dist[u] + w(uv) < Dist[v] then```\n.  (You have implemented the correct version, which could be construed as another difference from the pseudocode.)\nIt looks like ```\nParent[r] ← u```\n should be ```\nParent[v] ← u```\n.\n\n\nOf course, it could be that your instructor wanted you to implement the pseudocode exactly, errors and all ....\n\nAs a matter of strategy, I would have tried to use variable names better matching the pseudocode.  I don't think it would be fair for your instructor to reject the code on those grounds, but comparing the C++ code to the pseudocode would have been easier for everyone if you had stuck a bit closer with your names.\n\nWhile I'm talking about your code, by the way, I observe that although your ```\nminDistance()```\n function appears to implement the pseudocode's requirements, it does so in an inefficient way (and Dijkstra isn't particularly efficient to begin with).  The usual approach uses a min-heap to track nodes that have been seen but not yet visited, which reduces the cost of selecting the min-distance node from O(n) to O(log n).  Not that it matters for so few elements as you are testing on, of course, but for large graphs the difference is enormous.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm c++\r\n                \r\nI am supposed to implement a Dijkstra's algorithm with an adjacency matrix and a distance array. These are implemented through the class ```\nGraph300```\n. The program inputs a file with a weighted matrix and it is getting into the matrix fine. \n\nThe distance array is outputted for the user. But my Dijkstras is not working correctly. I keep getting ```\nUINT_MAX```\n for every vertex except the starting vertex (user specified) : \n\n```\nInput matrix (4x4):\n0           5           10           4294967295\n4294967295  0           4294967295   3\n4294967295  7           0            4294967295\n4294967295  4294967295  4            0\n\nMy distance array should output:\ndistance[0]=4294967295 -nopath\ndistance[1]=0  -startnode\ndistance[2]=7\ndistance[3]=3\n\nMy output now (that is wrong):\ndistance[0]=4294967295 -nopath\ndistance[1]=0  -startnode\ndistance[2]=4294967295\ndistance[3]=4294967295\n```\n\n\nHere is my algorithm; ```\nnumberNodes```\n is the the dimension of the vertex. ```\nstartNode```\n is user specified. The matrix array and distance array are of type ```\nunsigned int```\n:\n\n```\nvoid Graph300::dijkstra300()\n{\n    int startNode=getStartNode300();\n\n    for (int i = 0; i < numberNodes; i++)\n        distanceArray[i] = UINT_MAX;\n\n    distanceArray[startNode] = 0;\n\n    for (int count = 0; count < numberNodes-1; count++)\n    {\n         unsigned int min = INT_MAX, min_index;\n\n         for (int v = 0; v < numberNodes; v++)\n             if (visitedSet[v] == false && distanceArray[v] <= min)\n                 min = distanceArray[v], min_index = v;\n\n         int u = min_index;\n         visitedSet[u] = true;\n\n         for (int v = 0; v < numberNodes; v++)\n             if (!visitedSet[v] && adjacencyMatrix[u][v] && distanceArray[u] != UINT_MAX\n                && distanceArray[u]+adjacencyMatrix[u][v] < distanceArray[v])\n                  distanceArray[v] = distanceArray[u] + adjacencyMatrix[u][v];\n    }\n    view300();  // display result\n}\n```\n\n    ", "Answer": "\r\nFirst look:\nIt's difficult to be 100% sure to solve the issue, because you didn't show us the class member types nor a typical example of failure.  Nevertheless a confustion pops to the eye:  is the type of distanceArray[] ```\nunsigned int```\n or ```\nint```\n ?\nHere you assume it's unsigned:\n```\ndistanceArray[i] = UINT_MAX;   \n```\n\nBut later you compare this unsigned with a signed integer:\n```\nint min = INT_MAX, min_index;   // min is signed integer !\n\nfor (int v = 0; v < numberNodes; v++)\n   if (... && distanceArray[v] <= min)  // when comparing signed and unsigned you might not get the expected result !!\n```\n\nMismatches between signed and unsigned might lead to unexpected results in your comparison (see online demo).  To avoid this kind of issues, either you work only with unsigned values, or, change all your ```\nUINT_MAX```\n to ```\nINT_MAX```\n.\nSolution\nI could find out the problem with the additional data you provided, and switching all distances to unsigned int. You have to correct your ```\nif```\n:\n```\n        if (!visitedSet[v] && adjacencyMatrix[u][v] && adjacencyMatrix[u][v] != UINT_MAX  \n            && distanceArray[u] + adjacencyMatrix[u][v] < distanceArray[v])\n```\n\nbecause you have to consider only existing edges (```\nadjacencyMatrix[u][v]!= UINT_MAX```\n).  In your code you made the comparison with ```\ndistanceArray```\n.\nI could run your code (outside of a class) and with your input obtain the expected output.  Here the online demo.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm for matrices\r\n                \r\nI've been trying to implement Dijkstra's algorithm in C++11 to work on matrices of arbitrary size. Specifically, I am interested in solving question 83 on Project Euler.\n\nI appear to always run in to a situation where every node neighboring the current node has already been visited, which, if I understand the algorithm correctly, should never happen.\n\nI've tried poking around in a debugger, and I've re-read the code several times, but I have no idea where I am going wrong.\n\nHere is what I have done so far:\n\n```\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <tuple>\n#include <cstdint>\n#include <cinttypes>\n\ntypedef std::tuple<size_t, size_t> Index;\n\nstd::ostream& operator<<(std::ostream& os, Index i)\n{\n    os << \"(\" << std::get<0>(i) << \", \" << std::get<1>(i) << \")\";\n    return os;\n}\n\ntemplate<typename T>\nclass Matrix\n{\npublic:\n    Matrix(size_t i, size_t j):\n        n(i),\n        m(j),\n        xs(i * j)\n    {}\n\n    Matrix(size_t n, size_t m, const std::string& path):\n        n(n),\n        m(m),\n        xs(n * m)\n    {\n        std::ifstream mat_in {path};\n        char c;\n        for (size_t i = 0; i < n; ++i) {\n            for (size_t j = 0; j < m - 1; ++j) {\n                mat_in >> (*this)(i,j);\n                mat_in >> c;\n            }\n            mat_in >> (*this)(i,m - 1);\n        }\n    }\n\n    T& operator()(size_t i, size_t j)\n    {\n        return xs[n * i + j];\n    }\n\n    T& operator()(Index i)\n    {\n        return xs[n * std::get<0>(i) + std::get<1>(i)];\n    }\n\n    T operator()(Index i) const\n    {\n        return xs[n * std::get<0>(i) + std::get<1>(i)];\n    }\n\n    std::vector<Index> surrounding(Index ind) const\n    {\n        size_t i = std::get<0>(ind);\n        size_t j = std::get<1>(ind);\n        std::vector<Index> is;\n        if (i > 0)\n            is.push_back(Index(i - 1, j));\n        if (i < n - 1)\n            is.push_back(Index(i + 1, j));\n        if (j > 0)\n            is.push_back(Index(i, j - 1));\n        if (j < m - 1)\n            is.push_back(Index(i, j + 1));\n        return is;\n    }\n\n    size_t rows() const { return n; }\n    size_t cols() const { return m; }\n\nprivate:\n    size_t n;\n    size_t m;\n    std::vector<T> xs;\n};\n\n/* Finds the minimum sum of the weights of the nodes along a path from 1,1 to n,m using Dijkstra's algorithm modified for matrices */\nint64_t shortest_path(const Matrix<int>& m)\n{\n    Index origin(0,0);\n    Index current { m.rows() - 1, m.cols() - 1 };\n    Matrix<int64_t> nodes(m.rows(), m.cols());\n    std::set<Index> in_path;\n    for (size_t i = 0; i < m.rows(); ++i)\n        for (size_t j = 0; j < m.cols(); ++j)\n            nodes(i,j) = INTMAX_MAX;\n    nodes(current) = m(current);\n    while (1) {\n        auto is = m.surrounding(current);\n        Index next = origin;\n        for (auto i : is) {\n            if (in_path.find(i) == in_path.end()) {\n                nodes(i) = std::min(nodes(i), nodes(current) + m(i));\n                if (nodes(i) < nodes(next))\n                    next = i;\n            }\n        }\n        in_path.insert(current);\n        current = next;\n        if (current == origin)\n            return nodes(current);\n    }\n}\n\nint64_t at(const Matrix<int64_t>& m, const Index& i) { return m(i); }\nint at(const Matrix<int>& m, const Index& i) { return m(i); }\n\nint main()\n{\n    Matrix<int> m(80,80,\"mat.txt\");\n    printf(\"%\" PRIi64 \"\\n\", shortest_path(m));\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nYou do not understand the algorithm correctly.  There is nothing stopping you from running into dead ends.  As long as there are other options you have not yet explored, just mark it as a dead end and move on.\n\nBTW I agree with commentators who say that you are overcomplicating the solution.  It suffices to create a matrix of \"cost to get to here\" and have a queue of points to explore paths from.  Initialize the total cost matrix to a value for NOT_VISITED, -1 would work.  For each point, you look at the neighbors.  If the neighbor either has not been visited, or you just found a cheaper path to it, then adjust the cost matrix and add the point to the queue.\n\nKeep going until the queue is empty.  And then you have guaranteed lowest costs everywhere.\n\nA* is a lot more efficient than this naive approach, but what I just described is more than efficient enough to solve the problem.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm to find all the shortest paths possible\r\n                \r\nI'm working on Dijkstra's algorithm, and I really need to find all the possible shortest paths, not just one. I'm using an adjacency matrix and I applied Dijkstra's algorithm, and I can find the shortest path. But I need to find all the paths with that minimum cost, I mean all the possible solutions, if they exist.\n\nThis is how my algorithm works, for a single solution:\n\n```\npublic void dijkstra( int graph[][] )\n{\n    int d[] = new int[ graph.length ];\n    int dC[] = new int[ graph.length ];\n    int p[] = new int[ graph.length ];\n\n    for( int i = 0; i < graph.length; i++ ){\n        d[ i ] = 100; dC[ i ] = 100; p[ i ] = -1;\n    }\n    d[ 0 ] = 0; dC[ 0 ] = 0;\n\n    int i = 0, min = 200, pos = 0; //You can change the min to 1000 to make it the largest number\n    while( i < graph.length ){\n        //extract minimum\n        for( int j = 0; j < dC.length; j++ ){\n            if( min > d[ j ] && dC[ j ] != -1 ){\n                min = d[ j ]; pos = j;\n            }\n        }\n        dC[ pos ] = -1;\n\n        //relax\n        for( int j = 0; j < graph.length; j++ ){\n            if( d[ j ] > graph[ pos ][ j ] + d[ pos ] ){\n                d[ j ] = graph[ pos ][ j ] + d[ pos ];\n                p[ j ] = pos;\n            }\n        }\n        i++; min = 200;\n    }\n\n    for( int j = 0; j < p.length; j++ ){\n        System.out.print( p[ j ] + \" \" );\n    }\n    System.out.print( \"\\n\" );\n    for( int j = 0; j < d.length; j++ ){\n        System.out.print( d[ j ] + \" \" );\n    }\n    System.out.print( \"\\n\" );\n}\n```\n\n    ", "Answer": "\r\nIf you look at Dijkstra's algorithm in pseudocode form here:\nWikipedia Dijkstra's Algorithm Pseudocode\n\nYou will notice the line referred to as a Relax.  Right now it only contains a case for if the path found is less than the current shortest path, but there isn't anything done if they are equal.  You should probably keep all the equally short paths in a List.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm with Topological Sort\r\n                \r\nI came across this passage in a textbook:\n\n\"If the graph is acyclic, we can improve Dijkstra’s algorithm. Vertices may be selected in topological order since when a vertex is selected, its distance can no longer be lowered, because there are no  incoming edges from unknown nodes.\"\n\nI understand Topological Sort and Dijkstra's algorithm but do not understand how topological order can help speed up Dijkstra's especially when the order is not always unique. (unless its referring to space complexity which doesn't make sense either)\n\nCan someone explain how it improves it and give an example? \n    ", "Answer": "\r\nYou can choose an arbitrary topological sorting and process the vertices in this order.\n\nThe time complexity is linear in the size of the graph as there is no need for a priority queue anymore. You can just iterate over all vertices in topological order and compute the distance for them. \n\nIt goes like this:\n\n```\ndist = 0 for the start vertex and +inf for the rest\nfor v in topological order:\n     for u in neighbors[v] in reverse graph:\n        dist[v] = min(dist[v], dist[u] + weight(u, v))    \n```\n\n\nThe correctness follows from the fact that by the time we reach ```\nv```\n, we've already processed all vertices that have an edge to ```\nv```\n (by the definition of a topological order).\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Python - Dijkstra's Algorithm\r\n                \r\nI need to implement Dijkstra's Algorithm in Python. However, I have to use a 2D array to hold three pieces of information - predecessor, length and unvisited/visited.\nI know in C a Struct can be used, though I am stuck on how I can do a similar thing in Python, I am told it's possible but I have no idea to be honest\n    ", "Answer": "\r\nCreate a class for it.\n\n```\nclass XXX(object):\n    def __init__(self, predecessor, length, visited):\n        self.predecessor = predecessor\n        self.length = length\n        self.visited = visited\n```\n\n\nOr use collections.namedtuple, which is particular cool for holding struct-like compound types without own behaviour but named members: ```\nXXX = collections.namedtuple('XXX', 'predecessor length visited')```\n.\n\nCreate one with ```\nXXX(predecessor, length, visited)```\n.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm finding all possible shortest paths\r\n                \r\nI'm working on Dijkstra's algorithm,and I need to find all possible shortest paths. Dijkstra's algorithm returns only one short path, if another path has the same cost I would like to print it. I'm out of ideas, please help me.\n\nThank you.\n\nHere's my algorithm:\n\n```\npublic class Dijkstra {\n  private static final Graph.Edge[] GRAPH = {\n    new Graph.Edge(\"a\", \"b\", 7),\n    new Graph.Edge(\"a\", \"c\", 9),\n    new Graph.Edge(\"a\", \"f\", 14),\n    new Graph.Edge(\"b\", \"c\", 10),\n    new Graph.Edge(\"b\", \"d\", 13),\n    new Graph.Edge(\"c\", \"d\", 11),\n    new Graph.Edge(\"c\", \"f\", 2),\n    new Graph.Edge(\"d\", \"e\", 6),\n    new Graph.Edge(\"e\", \"f\", 9),\n  };\n  private static final String START = \"a\";\n  private static final String END = \"e\";\n\n  public static void main(String[] args) {\n    Graph g = new Graph(GRAPH);\n    g.dijkstra(START);\n    g.printPath(END);\n    //g.printAllPaths();\n  }\n}\n\nimport java.io.*;\nimport java.util.*;\n\nclass Graph {\n  private final Map<String, Vertex>\n      graph; // mapping of vertex names to Vertex objects, built from a set of Edges\n\n  /** One edge of the graph (only used by Graph constructor) */\n  public static class Edge {\n    public final String v1, v2;\n    public final int dist;\n\n    public Edge(String v1, String v2, int dist) {\n      this.v1 = v1;\n      this.v2 = v2;\n      this.dist = dist;\n    }\n  }\n\n  /** One vertex of the graph, complete with mappings to neighbouring vertices */\n  public static class Vertex implements Comparable<Vertex> {\n    public final String name;\n    public int dist = Integer.MAX_VALUE; // MAX_VALUE assumed to be infinity\n    public Vertex previous = null;\n    public final Map<Vertex, Integer> neighbours = new HashMap<>();\n\n    public Vertex(String name) {\n      this.name = name;\n    }\n\n    private void printPath() {\n      if (this == this.previous) {\n        System.out.printf(\"%s\", this.name);\n      } else if (this.previous == null) {\n        System.out.printf(\"%s(unreached)\", this.name);\n      } else {\n        this.previous.printPath();\n        System.out.printf(\" -> %s(%d)\", this.name, this.dist);\n      }\n    }\n\n    public int compareTo(Vertex other) {\n      return Integer.compare(dist, other.dist);\n    }\n  }\n\n  /** Builds a graph from a set of edges */\n  public Graph(Edge[] edges) {\n    graph = new HashMap<>(edges.length);\n\n    //one pass to find all vertices\n    for (Edge e : edges) {\n      if (!graph.containsKey(e.v1)) graph.put(e.v1, new Vertex(e.v1));\n      if (!graph.containsKey(e.v2)) graph.put(e.v2, new Vertex(e.v2));\n    }\n\n    //another pass to set neighbouring vertices\n    for (Edge e : edges) {\n      graph.get(e.v1).neighbours.put(graph.get(e.v2), e.dist);\n      //graph.get(e.v2).neighbours.put(graph.get(e.v1), e.dist); // also do this for an undirected graph\n    }\n  }\n\n  /** Runs dijkstra using a specified source vertex */\n  public void dijkstra(String startName) {\n    if (!graph.containsKey(startName)) {\n      System.err.printf(\"Graph doesn't contain start vertex \\\"%s\\\"\\n\", startName);\n      return;\n    }\n    final Vertex source = graph.get(startName);\n    NavigableSet<Vertex> q = new TreeSet<>();\n\n    // set-up vertices\n    for (Vertex v : graph.values()) {\n      v.previous = v == source ? source : null;\n      v.dist = v == source ? 0 : Integer.MAX_VALUE;\n      q.add(v);\n    }\n\n    dijkstra(q);\n  }\n\n  /** Implementation of dijkstra's algorithm using a binary heap. */\n  private void dijkstra(final NavigableSet<Vertex> q) {\n    Vertex u, v;\n    while (!q.isEmpty()) {\n\n      u = q.pollFirst(); // vertex with shortest distance (first iteration will return source)\n      if (u.dist == Integer.MAX_VALUE)\n        break; // we can ignore u (and any other remaining vertices) since they are unreachable\n\n      //look at distances to each neighbour\n      for (Map.Entry<Vertex, Integer> a : u.neighbours.entrySet()) {\n        v = a.getKey(); //the neighbour in this iteration\n\n        final int alternateDist = u.dist + a.getValue();\n        if (alternateDist < v.dist) { // shorter path to neighbour found\n          q.remove(v);\n          v.dist = alternateDist;\n          v.previous = u;\n          q.add(v);\n        } else if (alternateDist == v.dist) {\n          // Here I Would do something\n        }\n      }\n    }\n  }\n\n  /** Prints a path from the source to the specified vertex */\n  public void printPath(String endName) {\n    if (!graph.containsKey(endName)) {\n      System.err.printf(\"Graph doesn't contain end vertex \\\"%s\\\"\\n\", endName);\n      return;\n    }\n\n    graph.get(endName).printPath();\n    System.out.println();\n  }\n  /** Prints the path from the source to every vertex (output order is not guaranteed) */\n  public void printAllPaths() {\n    for (Vertex v : graph.values()) {\n      v.printPath();\n      System.out.println();\n    }\n  }\n\n  public void printAllPaths2() {\n    graph.get(\"e\").printPath();\n    System.out.println();\n  }\n}\n```\n\n    ", "Answer": "\r\nHave a look into so called ```\nk```\n-shortest path algorithms. These solve the problem of enumerating the first, second, ..., kth shortest path in a graph. There are several algorithms in the literature, see for example this paper,  or Yen's algorithm. \n\nNote, that most algorithms do not require that you specify ```\nk```\n upfront, ie. you can use them to enumerate shortest paths in an increasing order, and stop when the length has strictly increased.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm implement\r\n                \r\nI have seen dijkstra's algorithm for weighted graphs what should I do to implement that to find shortest path in an unweighted graph? \n\nShould i consider weights between all edges 0 or 1?\n\nSecondly I want to implement a bfs on ```\n10^5```\n nodes to check whether a node is reachable from any other node? Is it possible, as defining a 2-D array of ```\n[10^5][10^5]```\n gives a memory fault. \n    ", "Answer": "\r\nFor your first question, I did implement Dijkstra on unweighted path with weights of 1, it's working fine, but there may be a better solution.\n\nI don't remember much about bfs, sorry !\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "What's the time complexity of Dijkstra's Algorithm\r\n                \r\n```\nDijkstra((V, E)):\n  S = {}    //O(1)\n  for each vertex v ∈ V:    //O(V)\n    d[v] = ∞    //O(1)\n  d[source] = 0    //O(1)\n  while S != V:    //O(V)\n    v = non visited vertex with the smallest d[v]    //O(V)\n    for each edge (v, u):    //O(E)\n      if u ∈/ S and d[v] + w(v, u) < d[u]:\n        d[u] = d[v] + w(v, u)\n    S = S ∪ {v}\n```\n\n\nNote: ∈/ means not in, i can't type it in the code.\n\nThis question maybe duplicates with some posts. \n\nUnderstanding Time complexity calculation for Dijkstra Algorithm\n\n\nComplexity Of Dijkstra's algorithm\n\nComplexity in Dijkstras algorithm\n\nI read them and even some posts on Quora, but still cannot understand. I put some comments in the pseudo code and tried to work it out. I really confuse on why it is O(E log V) \n    ", "Answer": "\r\nThe \"non visited vertex with the smallest d[v]\" is actually O(1) if you use a min heap and insertion in the min heap is O(log V).\n\nTherefore the complexity is as you correctly mentioned for the other loops:\n\n```\n  O((V logV) + (E logV)) = O(E logV) // Assuming E > V which is reasonable\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Which datatype to use as queue in Dijkstra's algorithm?\r\n                \r\nI'm trying to implement Dijkstra's algorithm in Java (self-study). I use the pseudo-code provided by Wikipedia (link). Now near the end of the algorithm, I should ```\ndecrease-key v in Q;```\n. I guess i should have implemented Q with a BinaryHeap or something like that? What would be the right (built-in) datatype to use here?\n\n```\nprivate void dijkstra(int source) {\n        int[] dist = new int[this.adjacencyMatrix.length];\n        int[] previous = new int[this.adjacencyMatrix.length];\n        Queue<Integer> q = new LinkedList<Integer>();\n\n        for (int i = 0; i < this.adjacencyMatrix.length; i++) {\n            dist[i] = this.INFINITY;\n            previous[i] = this.UNDEFINED;\n            q.add(i);\n        }\n\n        dist[source] = 0;\n\n        while(!q.isEmpty()) {\n            // get node with smallest dist;\n            int u = 0;\n            for(int i = 0; i < this.adjacencyMatrix.length; i++) {\n                if(dist[i] < dist[u])\n                    u = i;\n            }\n\n            // break if dist == INFINITY\n            if(dist[u] == this.INFINITY) break;\n\n            // remove u from q\n            q.remove(u);\n\n            for(int i = 0; i < this.adjacencyMatrix.length; i++) {\n                if(this.adjacencyMatrix[u][i] == 1) {\n                    // in a unweighted graph, this.adjacencyMatrix[u][i] always == 1;\n                    int alt = dist[u] + this.adjacencyMatrix[u][i]; \n                    if(alt < dist[i]) {\n                        dist[i] = alt;\n                        previous[i] = u;\n\n                        // here's where I should \"decrease the key\"\n                    }\n                }\n            }\n        }\n    }\n```\n\n    ", "Answer": "\r\nThe simplest way is to use a priority queue and not to care about the previously added key in the priority queue. This means you will have each node multiple times in the queue, but this does not hurt the algorithm at all. If you have a look at it, all versions of the node which have been replaced will be picked up later and by then the closest distance will already have been determined.\n\nThe check ```\nif alt < dist[v]:```\n from the wikipedia is what makes this work. The runtime will only degrade a little from this, but if you need the very fast version you have to optimize further.\n\nNOTE:\n\nLike any optimization, this one should be handled with care and may lead to curious and hard to find bugs (see e.g. here). For most cases, just using remove and re-insert should be fine, but the trick I mentioned here, can speed up your code a little if your Dijkstra implementation is the bottleneck.\n\nMost importantly: Before trying this, make sure how your priority queue handles the priority. The actual priority in the queue should never change, or you may mess up invariants of the queue, which means items stored in the queue may not be retrievable any more. E.g. in Java, priorities are stored together with the object, so you do need an additional wrapper:\n\nThis will not work:\n\n```\nimport java.util.PriorityQueue;\n\n// Store node information and priority together\nclass Node implements Comparable<Node> {\n  public int prio;\n  public Node(int prio) { this.prio = prio; }\n\n  public int compareTo(Node n) {\n     return Integer.compare(this.prio, n.prio);\n  }\n}\n\n...\n...\nPriorityQueue<Node> q = new PriorityQueue<Node>();\nn = new Node(10);\nq.add(n)\n...\n// let's update the priority\nn.prio = 0;\n// re-add\nq.add(n);\n// q may be broken now\n```\n\n\nBecause at ```\nn.prio=0```\n you are also changing the priority of the object within the queue. However, this will work fine:\n\n```\nimport java.util.PriorityQueue;\n\n// Only node information\nclass Node {\n  // Whatever you need for your graph\n  public Node() {}\n}\n\nclass PrioNode {\n   public Node n;\n   public int prio;\n   public PrioNode(Node n, int prio) {\n     this.n = n;\n     this.prio = prio;\n   }\n\n   public int compareTo(PrioNode p) {\n      return Integer.compare(this.prio, p.prio);\n   }\n}\n\n...\n...\nPriorityQueue<PrioNode> q = new PriorityQueue<PrioNode>();\nn = new Node();\nq.add(new PrioNode(n,10));\n...\n// let's update the priority and re-add\nq.add(new PrioNode(n,0));\n// Everything is fine, because we have not changed the value\n// in the queue.\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm in CUDA\r\n                \r\nI am having troubles with this piece of CUDA code I have written. This is supposed to be the CUDA implementation of the Dijkstra's algorithm. The code is as follows: \n\n```\n    __global__ void cuda_dijkstra_kernel_1(float* Va, int* Ea, int* Sa, float* Ca, float* Ua, char* Ma, unsigned int* lock){\n\n        int tid = blockIdx.x;\n        if(Ma[tid]=='1'){\n            Ma[tid] = '0';\n            int ind_Ea = Sa[tid * 2];\n            int num_edges = Sa[(tid * 2) + 1];\n            int v;\n            float wt = 0;\n            unsigned int leaveloop;\n            leaveloop = 0u;\n            while(leaveloop==0u){\n                if(atomicExch(lock, 1u) == 0u){\n                    for(v = 0; v < num_edges; v++){\n                        wt = (Va[tid * 3] - Va[Ea[ind_Ea + v] * 3]) * (Va[tid * 3] - Va[Ea[ind_Ea + v] * 3]) +\n                                (Va[(tid * 3) + 1] - Va[(Ea[ind_Ea + v] * 3) + 1]) * (Va[(tid * 3) + 1] - Va[(Ea[ind_Ea + v] * 3) + 1]) + \n                                (Va[(tid * 3) + 2] - Va[(Ea[ind_Ea + v] * 3) + 2]) * (Va[(tid * 3) + 2] - Va[(Ea[ind_Ea + v] * 3) + 2]) ;\n                        wt = sqrt(wt);\n\n                        if(Ca[Ea[ind_Ea + v]] > (Ca[tid] + wt)){\n                            Ca[Ea[ind_Ea + v]] = Ca[tid]  + wt;\n                            Ma[Ea[ind_Ea + v]] = '1';\n                        }\n                        __threadfence();\n                        leaveloop = 1u;\n                        atomicExch(lock, 0u);\n                    }\n                }\n            }\n        }\n    }\n```\n\n\nThe problem is in the relaxation phase of the Dijkstra's algorithm. I have implemented such a phase as a critical section. If there is a vertex (lets say ```\na```\n) which is a neighbor of more than one vertex (i.e., connecting to other vertices with edges), then all of the threads for those vertices will try to write to the location of vertex ```\na```\n in the Cost Array ```\nCa```\n. Now my goal is to have the smaller value written in that location. To do that, I am trying to serialize the process and applying ```\n__threadfence()```\n as well so that value written by one thread is visible to others and then eventually the smaller value is retained in the location of vertex ```\na```\n. But the problem is, that this logic is not working. The location of vertex ```\na```\n does not get the smallest value of all the threads trying to write to that location and I don't understand why. Any help will be highly appreciated.\n    ", "Answer": "\r\nThere is a \"classical\" (at least, mostly referenced) implementation of Dijkstra's Single-Source Shortest Path (SSSP) algorithm on the GPU contained in the paper\n\n\n  Accelerating large graph algorithms on the GPU using CUDA by Parwan Harish and P.J. Narayanan\n\n\nHowever, the implementation in that paper has been recognized to be bugged, see\n\n\n  CUDA Solutions for the SSSP Problem by Pedro J. Martín, Roberto Torres, and Antonio Gavilanes\n\n\nI'm reporting below the implementation suggested in the first paper fixed according to the remark of the second. The code also contains a C++ version.\n\n```\n#include <sstream>\n#include <vector>\n#include <iostream>\n#include <stdio.h>\n#include <float.h>\n\n#include \"Utilities.cuh\"\n\n#define NUM_ASYNCHRONOUS_ITERATIONS 20  // Number of async loop iterations before attempting to read results back\n\n#define BLOCK_SIZE 16\n\n/***********************/\n/* GRAPHDATA STRUCTURE */\n/***********************/\n// --- The graph data structure is an adjacency list.\ntypedef struct {\n\n    // --- Contains the integer offset to point to the edge list for each vertex\n    int *vertexArray;\n\n    // --- Overall number of vertices\n    int numVertices;\n\n    // --- Contains the \"destination\" vertices each edge is attached to\n    int *edgeArray;\n\n    // --- Overall number of edges\n    int numEdges;\n\n    // --- Contains the weight of each edge\n    float *weightArray;\n\n} GraphData;\n\n/**********************************/\n/* GENERATE RANDOM GRAPH FUNCTION */\n/**********************************/\nvoid generateRandomGraph(GraphData *graph, int numVertices, int neighborsPerVertex) {\n\n    graph -> numVertices    = numVertices;\n    graph -> vertexArray    = (int *)malloc(graph -> numVertices * sizeof(int));\n    graph -> numEdges       = numVertices * neighborsPerVertex;\n    graph -> edgeArray      = (int *)malloc(graph -> numEdges    * sizeof(int));\n    graph -> weightArray    = (float *)malloc(graph -> numEdges  * sizeof(float));\n\n    for (int i = 0; i < graph -> numVertices; i++) graph -> vertexArray[i] = i * neighborsPerVertex;\n\n    int *tempArray = (int *)malloc(neighborsPerVertex * sizeof(int));\n    for (int k = 0; k < numVertices; k++) {\n        for (int l = 0; l < neighborsPerVertex; l++) tempArray[l] = INT_MAX;\n        for (int l = 0; l < neighborsPerVertex; l++) {\n            bool goOn = false;\n            int temp;\n            while (goOn == false) {\n                goOn = true;\n                temp = (rand() % graph->numVertices);\n                for (int t = 0; t < neighborsPerVertex; t++)\n                    if (temp == tempArray[t]) goOn = false;\n                if (temp == k) goOn = false;\n                if (goOn == true) tempArray[l] = temp;\n            }\n            graph -> edgeArray  [k * neighborsPerVertex + l] = temp;\n            graph -> weightArray[k * neighborsPerVertex + l] = (float)(rand() % 1000) / 1000.0f;\n        }\n    }\n}\n\n/************************/\n/* minDistance FUNCTION */\n/************************/\n// --- Finds the vertex with minimum distance value, from the set of vertices not yet included in shortest path tree\nint minDistance(float *shortestDistances, bool *finalizedVertices, const int sourceVertex, const int N) {\n\n    // --- Initialize minimum value\n    int minIndex = sourceVertex;\n    float min = FLT_MAX;\n\n    for (int v = 0; v < N; v++)\n        if (finalizedVertices[v] == false && shortestDistances[v] <= min) min = shortestDistances[v], minIndex = v;\n\n    return minIndex;\n}\n\n/************************/\n/* dijkstraCPU FUNCTION */\n/************************/\nvoid dijkstraCPU(float *graph, float *h_shortestDistances, int sourceVertex, const int N) {\n\n    // --- h_finalizedVertices[i] is true if vertex i is included in the shortest path tree\n    //     or the shortest distance from the source node to i is finalized\n    bool *h_finalizedVertices = (bool *)malloc(N * sizeof(bool));\n\n    // --- Initialize h_shortestDistancesances as infinite and h_shortestDistances as false\n    for (int i = 0; i < N; i++) h_shortestDistances[i] = FLT_MAX, h_finalizedVertices[i] = false;\n\n    // --- h_shortestDistancesance of the source vertex from itself is always 0\n    h_shortestDistances[sourceVertex] = 0.f;\n\n    // --- Dijkstra iterations\n    for (int iterCount = 0; iterCount < N - 1; iterCount++) {\n\n        // --- Selecting the minimum distance vertex from the set of vertices not yet\n        //     processed. currentVertex is always equal to sourceVertex in the first iteration.\n        int currentVertex = minDistance(h_shortestDistances, h_finalizedVertices, sourceVertex, N);\n\n        // --- Mark the current vertex as processed\n        h_finalizedVertices[currentVertex] = true;\n\n        // --- Relaxation loop\n        for (int v = 0; v < N; v++) {\n\n            // --- Update dist[v] only if it is not in h_finalizedVertices, there is an edge\n            //     from u to v, and the cost of the path from the source vertex to v through\n            //     currentVertex is smaller than the current value of h_shortestDistances[v]\n            if (!h_finalizedVertices[v] &&\n                graph[currentVertex * N + v] &&\n                h_shortestDistances[currentVertex] != FLT_MAX &&\n                h_shortestDistances[currentVertex] + graph[currentVertex * N + v] < h_shortestDistances[v])\n\n                h_shortestDistances[v] = h_shortestDistances[currentVertex] + graph[currentVertex * N + v];\n        }\n    }\n}\n\n/***************************/\n/* MASKARRAYEMPTY FUNCTION */\n/***************************/\n// --- Check whether all the vertices have been finalized. This tells the algorithm whether it needs to continue running or not.\nbool allFinalizedVertices(bool *finalizedVertices, int numVertices) {\n\n    for (int i = 0; i < numVertices; i++)  if (finalizedVertices[i] == true) { return false; }\n\n    return true;\n}\n\n/*************************/\n/* ARRAY INITIALIZATIONS */\n/*************************/\n__global__ void initializeArrays(bool * __restrict__ d_finalizedVertices, float* __restrict__ d_shortestDistances, float* __restrict__ d_updatingShortestDistances,\n                                 const int sourceVertex, const int numVertices) {\n\n    int tid = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (tid < numVertices) {\n\n        if (sourceVertex == tid) {\n\n            d_finalizedVertices[tid]            = true;\n            d_shortestDistances[tid]            = 0.f;\n            d_updatingShortestDistances[tid]    = 0.f; }\n\n        else {\n\n            d_finalizedVertices[tid]            = false;\n            d_shortestDistances[tid]            = FLT_MAX;\n            d_updatingShortestDistances[tid]    = FLT_MAX;\n        }\n    }\n}\n\n/**************************/\n/* DIJKSTRA GPU KERNEL #1 */\n/**************************/\n__global__  void Kernel1(const int * __restrict__ vertexArray, const int* __restrict__ edgeArray,\n                         const float * __restrict__ weightArray, bool * __restrict__ finalizedVertices, float* __restrict__ shortestDistances,\n                         float * __restrict__ updatingShortestDistances, const int numVertices, const int numEdges) {\n\n    int tid = blockIdx.x*blockDim.x + threadIdx.x;\n\n    if (tid < numVertices) {\n\n        if (finalizedVertices[tid] == true) {\n\n            finalizedVertices[tid] = false;\n\n            int edgeStart = vertexArray[tid], edgeEnd;\n\n            if (tid + 1 < (numVertices)) edgeEnd = vertexArray[tid + 1];\n            else                         edgeEnd = numEdges;\n\n            for (int edge = edgeStart; edge < edgeEnd; edge++) {\n                int nid = edgeArray[edge];\n                atomicMin(&updatingShortestDistances[nid], shortestDistances[tid] + weightArray[edge]);\n            }\n        }\n    }\n}\n\n/**************************/\n/* DIJKSTRA GPU KERNEL #1 */\n/**************************/\n__global__  void Kernel2(const int * __restrict__ vertexArray, const int * __restrict__ edgeArray, const float* __restrict__ weightArray,\n                         bool * __restrict__ finalizedVertices, float* __restrict__ shortestDistances, float* __restrict__ updatingShortestDistances,\n                         const int numVertices) {\n\n    int tid = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (tid < numVertices) {\n\n        if (shortestDistances[tid] > updatingShortestDistances[tid]) {\n            shortestDistances[tid] = updatingShortestDistances[tid];\n            finalizedVertices[tid] = true; }\n\n        updatingShortestDistances[tid] = shortestDistances[tid];\n    }\n}\n\n/************************/\n/* dijkstraGPU FUNCTION */\n/************************/\nvoid dijkstraGPU(GraphData *graph, const int sourceVertex, float * __restrict__ h_shortestDistances) {\n\n    // --- Create device-side adjacency-list, namely, vertex array Va, edge array Ea and weight array Wa from G(V,E,W)\n    int     *d_vertexArray;         gpuErrchk(cudaMalloc(&d_vertexArray,    sizeof(int)   * graph -> numVertices));\n    int     *d_edgeArray;           gpuErrchk(cudaMalloc(&d_edgeArray,  sizeof(int)   * graph -> numEdges));\n    float   *d_weightArray;         gpuErrchk(cudaMalloc(&d_weightArray,    sizeof(float) * graph -> numEdges));\n\n    // --- Copy adjacency-list to the device\n    gpuErrchk(cudaMemcpy(d_vertexArray, graph -> vertexArray, sizeof(int)   * graph -> numVertices, cudaMemcpyHostToDevice));\n    gpuErrchk(cudaMemcpy(d_edgeArray,   graph -> edgeArray,   sizeof(int)   * graph -> numEdges,    cudaMemcpyHostToDevice));\n    gpuErrchk(cudaMemcpy(d_weightArray, graph -> weightArray, sizeof(float) * graph -> numEdges,    cudaMemcpyHostToDevice));\n\n    // --- Create mask array Ma, cost array Ca and updating cost array Ua of size V\n    bool    *d_finalizedVertices;           gpuErrchk(cudaMalloc(&d_finalizedVertices,       sizeof(bool)   * graph->numVertices));\n    float   *d_shortestDistances;           gpuErrchk(cudaMalloc(&d_shortestDistances,       sizeof(float) * graph->numVertices));\n    float   *d_updatingShortestDistances;   gpuErrchk(cudaMalloc(&d_updatingShortestDistances, sizeof(float) * graph->numVertices));\n\n    bool *h_finalizedVertices = (bool *)malloc(sizeof(bool) * graph->numVertices);\n\n    // --- Initialize mask Ma to false, cost array Ca and Updating cost array Ua to \\u221e\n    initializeArrays <<<iDivUp(graph->numVertices, BLOCK_SIZE), BLOCK_SIZE >>>(d_finalizedVertices, d_shortestDistances,\n                                                            d_updatingShortestDistances, sourceVertex, graph -> numVertices);\n    gpuErrchk(cudaPeekAtLastError());\n    gpuErrchk(cudaDeviceSynchronize());\n\n    // --- Read mask array from device -> host\n    gpuErrchk(cudaMemcpy(h_finalizedVertices, d_finalizedVertices, sizeof(bool) * graph->numVertices, cudaMemcpyDeviceToHost));\n\n    while (!allFinalizedVertices(h_finalizedVertices, graph->numVertices)) {\n\n        // --- In order to improve performance, we run some number of iterations without reading the results.  This might result\n        //     in running more iterations than necessary at times, but it will in most cases be faster because we are doing less\n        //     stalling of the GPU waiting for results.\n        for (int asyncIter = 0; asyncIter < NUM_ASYNCHRONOUS_ITERATIONS; asyncIter++) {\n\n            Kernel1 <<<iDivUp(graph->numVertices, BLOCK_SIZE), BLOCK_SIZE >>>(d_vertexArray, d_edgeArray, d_weightArray, d_finalizedVertices, d_shortestDistances,\n                                                            d_updatingShortestDistances, graph->numVertices, graph->numEdges);\n            gpuErrchk(cudaPeekAtLastError());\n            gpuErrchk(cudaDeviceSynchronize());\n            Kernel2 <<<iDivUp(graph->numVertices, BLOCK_SIZE), BLOCK_SIZE >>>(d_vertexArray, d_edgeArray, d_weightArray, d_finalizedVertices, d_shortestDistances, d_updatingShortestDistances,\n                                                            graph->numVertices);\n            gpuErrchk(cudaPeekAtLastError());\n            gpuErrchk(cudaDeviceSynchronize());\n        }\n\n        gpuErrchk(cudaMemcpy(h_finalizedVertices, d_finalizedVertices, sizeof(bool) * graph->numVertices, cudaMemcpyDeviceToHost));\n    }\n\n    // --- Copy the result to host\n    gpuErrchk(cudaMemcpy(h_shortestDistances, d_shortestDistances, sizeof(float) * graph->numVertices, cudaMemcpyDeviceToHost));\n\n    free(h_finalizedVertices);\n\n    gpuErrchk(cudaFree(d_vertexArray));\n    gpuErrchk(cudaFree(d_edgeArray));\n    gpuErrchk(cudaFree(d_weightArray));\n    gpuErrchk(cudaFree(d_finalizedVertices));\n    gpuErrchk(cudaFree(d_shortestDistances));\n    gpuErrchk(cudaFree(d_updatingShortestDistances));\n}\n\n/****************/\n/* MAIN PROGRAM */\n/****************/\nint main() {\n\n    // --- Number of graph vertices\n    int numVertices = 8;\n\n    // --- Number of edges per graph vertex\n    int neighborsPerVertex = 6;\n\n    // --- Source vertex\n    int sourceVertex = 0;\n\n    // --- Allocate memory for arrays\n    GraphData graph;\n    generateRandomGraph(&graph, numVertices, neighborsPerVertex);\n\n    // --- From adjacency list to adjacency matrix.\n    //     Initializing the adjacency matrix\n    float *weightMatrix = (float *)malloc(numVertices * numVertices * sizeof(float));\n    for (int k = 0; k < numVertices * numVertices; k++) weightMatrix[k] = FLT_MAX;\n\n    // --- Displaying the adjacency list and constructing the adjacency matrix\n    printf(\"Adjacency list\\n\");\n    for (int k = 0; k < numVertices; k++) weightMatrix[k * numVertices + k] = 0.f;\n    for (int k = 0; k < numVertices; k++)\n        for (int l = 0; l < neighborsPerVertex; l++) {\n            weightMatrix[k * numVertices + graph.edgeArray[graph.vertexArray[k] + l]] = graph.weightArray[graph.vertexArray[k] + l];\n            printf(\"Vertex nr. %i; Edge nr. %i; Weight = %f\\n\", k, graph.edgeArray[graph.vertexArray[k] + l],\n                                                                   graph.weightArray[graph.vertexArray[k] + l]);\n        }\n\n    for (int k = 0; k < numVertices * neighborsPerVertex; k++)\n        printf(\"%i %i %f\\n\", k, graph.edgeArray[k], graph.weightArray[k]);\n\n    // --- Displaying the adjacency matrix\n    printf(\"\\nAdjacency matrix\\n\");\n    for (int k = 0; k < numVertices; k++) {\n        for (int l = 0; l < numVertices; l++)\n            if (weightMatrix[k * numVertices + l] < FLT_MAX)\n                printf(\"%1.3f\\t\", weightMatrix[k * numVertices + l]);\n            else\n                printf(\"--\\t\");\n            printf(\"\\n\");\n        }\n\n    // --- Running Dijkstra on the CPU\n    float *h_shortestDistancesCPU = (float *)malloc(numVertices * sizeof(float));\n    dijkstraCPU(weightMatrix, h_shortestDistancesCPU, sourceVertex, numVertices);\n\n    printf(\"\\nCPU results\\n\");\n    for (int k = 0; k < numVertices; k++) printf(\"From vertex %i to vertex %i = %f\\n\", sourceVertex, k, h_shortestDistancesCPU[k]);\n\n    // --- Allocate space for the h_shortestDistancesGPU\n    float *h_shortestDistancesGPU = (float*)malloc(sizeof(float) * graph.numVertices);\n    dijkstraGPU(&graph, sourceVertex, h_shortestDistancesGPU);\n\n    printf(\"\\nGPU results\\n\");\n    for (int k = 0; k < numVertices; k++) printf(\"From vertex %i to vertex %i = %f\\n\", sourceVertex, k, h_shortestDistancesGPU[k]);\n\n    free(h_shortestDistancesCPU);\n    free(h_shortestDistancesGPU);\n\n    return 0;\n}\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm on a reverse graph\r\n                \r\nIf we reverse a graph G to G' and run Dijkstra's algorithm on G' from a source vertex 't', will this algorithm give shortest path from all vertices to 't' in G. Can someone prove or find counter example?\n    ", "Answer": "\r\nShort answer: YES, your statement is correct in a DIRECTED Graph\nIn an undirected graph ```\nG```\n, the reversal, ```\nG'```\n would produce the same graph ```\nG```\n, and thus, when you find the shortest distance from source vertex ```\ns```\n to all other vertices, you are automatically finding the shortest path from all vertices to ```\ns```\n since the graph can be traversed in reverse direction (undirected).\nIn a directed graph, when you find shortest path from ```\ns```\n (source) to all other vertices (destinations), you are travelling in a single direction, from ```\nsource```\n ```\n--->```\n ```\ndestination_1```\n, from ```\nsource```\n ```\n--->```\n ```\ndestination_2```\n, from ```\nsource```\n ```\n--->```\n ```\ndestination_3```\n ...\nSo, if you reversed all directions in the graph, all your shortest paths will be: to ```\nsource```\n ```\n<---```\n ```\ndestination_1```\n, to ```\nsource```\n ```\n<---```\n ```\ndestination_2```\n, to ```\nsource```\n ```\n<---```\n ```\ndestination_3```\n ... and note that These paths will NOT be the same as before i.e. when you run ```\nDijkstras```\n on ```\nG'```\n, the algorithm thinks it is finding shortest path from ```\ns```\n to all ```\nd```\n's, whereas in reality, since you reversed the directions, the shortest path arrows are actually pointing in reverse direction giving us shortest path from all ```\nd```\n's to ```\ns```\n and NOT from ```\ns```\n to ```\nd```\n's.\n```\nGraph G:  \n\n       7           +++++  \n   //===>===>====>/ D2 /  \n  //              +++++  \n //   /--<<---<--/   /|\\\ns <---         2      | 1 \n \\\\   \\__<<___        |\n  \\\\      9    \\      |\n   \\\\           \\ +++++  \n    \\\\===>=====>/ D1 /  \n          10    +++++  \n\n\nGraph G':\n\n       7           +++++\n   /----<----<---</ D2 /\n  /               +++++\n /    //==>>====>==/   ||\ns >===       2         || 1\n \\    \\__>>___         || \n  \\      9    \\       \\||/\n   \\           \\ +++++\n    \\---<------</ D1 /\n          1     +++++\n```\n\nAs you can see above, in G, shortest paths from ```\ns```\n to ```\nd1```\n is ```\ns -> d1```\n and from ```\ns```\n to ```\nd2```\n is ```\ns -> d2```\n (shown in double lines (```\n=```\n, ```\n\\\\```\n, ```\n//```\n)).\nUpon reversing the directions, but NOT the weights (obviously), we see that the shortest paths from ```\ns```\n to ```\nd1```\n is ```\ns -> d2 -> d1```\n and from ```\ns```\n to ```\nd2```\n is ```\ns -> d2```\n which is the output of ```\nDjikstras```\n algorithm.\nIf you were to now set the direction to what it was originally, clearly all the chosen paths are actually the shortest paths TO ```\ns```\n and NOT from ```\ns```\n.\n```\nGraph G:\n\n       7           +++++\n   /---->---->--->/ D2 /\n  /               +++++\n /    //==<<===<==/   /||\\\ns <===       2         || 1\n \\    \\__<<___         || \n  \\      9    \\        ||\n   \\           \\ +++++\n    \\--->------>/ D1 /\n          1     +++++\n```\n\nP.S.: I know that the presentation isn't that great. sorry 'bout it.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm and trouble with A* algorithm\r\n                \r\nSo I have been searching these two algorithms on the Internet and was able to, after days of working on it, get Dijkstra's Algorithm working. From what I have read the two Algorithms are not that different. So I am going to post what I did for Dijkstra's and I was hoping that you can show me or point me into the direction on how to modify it to the A* algorithm.\n\n```\npublic Integer processGraph(int graph[][], int algorithm, int s, int d) {\n\n\n    if(algorithm == 1) {\n\n\n        // shortestDist[index] will hold the distance from s to the index\n        int shortestDist[] = new int[graph.length];\n\n        // added[i] is true if vertex index is included / the shortest distance from the source to the index is finalized\n        boolean added[] = new boolean[graph.length];\n\n\n        // establish all distances as Integer.Max_Value and added[] as false\n        for (int vertexIndex = 0; vertexIndex < graph.length; vertexIndex++) {\n            shortestDist[vertexIndex] = Integer.MAX_VALUE;\n            added[vertexIndex] = false;\n        }\n\n        // Distance of the source from itself is always 0\n        shortestDist[s] = 0;\n\n        // Parent array to store shortest the shortest path -- example: [num, num, num]\n        int[] parents = new int[graph.length];\n\n\n        // Find shortest path for all vertices\n        for (int i = 1; i < graph.length; i++) {\n\n            // Pick the minimum distance vertex\n            // from the set of vertices not yet\n            // processed. nearestVertex is\n            // always equal to the source in\n            // first iteration.\n            int u = minDistance(shortestDist, added);\n            added[u] = true;\n            for (int vertexIndex = 0; vertexIndex < graph.length; vertexIndex++) {\n                if (!added[vertexIndex] && graph[u][vertexIndex] != 0 && shortestDist[u] != Integer.MAX_VALUE && shortestDist[u] + graph[u][vertexIndex] < shortestDist[vertexIndex]) {\n                    shortestDist[vertexIndex] = shortestDist[u] + graph[u][vertexIndex];\n                    parents[vertexIndex] = u;\n                }\n\n            }\n\n        }\n\n        if(shortestDist[d] == Integer.MAX_VALUE) {\n            System.out.println(\" \");\n            System.out.println(\"ERROR MESSAGE -- No path present from \" + s + \" to \" + d);\n            System.out.println(\"ERROR MESSAGE --no path present from \" + s + \" to \" + d);\n            System.out.println(\" \");\n            return null;\n        }\n\n\n        //pathPrint(s, shortestDist, d); this only works for the first test\n        return shortestDist[d];\n    } // end algorithm 1\n```\n\n\nTO add more context to this, I have a driver class in which with several graphs upon which this finds the shortest path.\nExample of graph[][]:\n\n```\nint regValid[][] = {{0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n                        {1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n                        {0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n                        {0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n                        {0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n                        {1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n                        {0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n                        {0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n                        {0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n                        {0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n                        {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n                        {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n                        {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n                        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0},\n                        {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},\n                        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0},\n                        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0},\n                        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0},\n                        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0},\n                        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},\n                        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0},\n                        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0},\n                        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0},\n                        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1},\n                        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0}};\n```\n\n\nAgain, how can I modify what I have to work with the A* algorithm instead of Dijkstras. Thank you and hopefully this makes sense.\n    ", "Answer": "\r\nYou have full information about all nodes, edges and destination node, so Dijkstra is the best solution for your problem. A* would be useful if you hadn't known complete graph (most often for huge node space) and were forced to prioritize decisions according to some heuristics.\n\nIf you really want to simulate A* on your graph, you have to think out some artificial criterion (heuristics) which describes the estimated distance between given node and target node (in other words, pretend you don't know the path). Since your data set doesn't contain such additional information (and thinking out any satisfying admissibility condition is not trivial), your question doesn't make much sense to me.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm with Gremlin\r\n                \r\nI want to implement Dijkstra's algorithm in Gremlin to create a fully-meshed graph containing the shortest paths only.\n\nI'm using Gremlin on top of an OrientDB database. Since the shortest path algorithm in Furnace is not implemented yet, I need to implement it by myself. I understand the basic workings of Gremlin, but I'm currently stuck with it.\n\nI could also write it in Java, but I need the flexibility of a Gremlin solution. How can this be done?\n    ", "Answer": "\r\nLook at https://github.com/tinkerpop/rexster/issues/144. It uses Neo4J but OrientDB implements the same API, so it's identical.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Performance of Dijkstra's algorithm implementation\r\n                \r\nBelow is an implementation of Dijkstra's algorithm I wrote from the pseudocode in the Wikipedia article.  For a graph with about 40 000 nodes and 80 000 edges, it takes 3 or 4 minutes to run.  Is that anything like the right order of magnitude?  If not, what's wrong with my implementation?\n\n```\nstruct DijkstraVertex {\n  int index;\n  vector<int> adj;\n  vector<double> weights;\n  double dist;\n  int prev;\n  bool opt;\n  DijkstraVertex(int vertexIndex, vector<int> adjacentVertices, vector<double> edgeWeights) {\n    index = vertexIndex;\n    adj = adjacentVertices;\n    weights = edgeWeights;\n    dist = numeric_limits<double>::infinity();\n    prev = -1; // \"undefined\" node\n    opt = false; // unoptimized node\n   }\n};\n\nvoid dijsktra(vector<DijkstraVertex*> graph, int source, vector<double> &dist, vector<int> &prev) {\n  vector<DijkstraVertex*> Q(G); // set of unoptimized nodes\n  G[source]->dist = 0;\n  while (!Q.empty()) {\n    sort(Q.begin(), Q.end(), dijkstraDistComp); // sort nodes in Q by dist from source\n    DijkstraVertex* u = Q.front(); // u = node in Q with lowest dist\n    u->opt = true;\n    Q.erase(Q.begin());\n    if (u->dist == numeric_limits<double>::infinity()) {\n      break; // all remaining vertices are inaccessible from the source\n    }\n    for (int i = 0; i < (signed)u->adj.size(); i++) { // for each neighbour of u not in Q\n    DijkstraVertex* v = G[u->adj[i]];\n    if (!v->opt) {\n      double alt = u->dist + u->weights[i];\n      if (alt < v->dist) {\n        v->dist = alt;\n        v->prev = u->index;\n      }\n    }\n    }\n  }\n  for (int i = 0; i < (signed)G.size(); i++) {\n    assert(G[i] != NULL);\n    dist.push_back(G[i]->dist); // transfer data to dist for output\n    prev.push_back(G[i]->prev); // transfer data to prev for output\n  }  \n}\n```\n\n    ", "Answer": "\r\nThere are several things you can improve on this:\n\n\nimplementing the priority queue with sort and erase adds a factor of |E| to the runtime - use the heap functions of the STL to get a log(N) insertion and removal into the queue.\ndo not put all the nodes in the queue at once but only those where you have discovered a path (which may or may not be the optimal, as you can find an indirect path through nodes in the queue).\ncreating objects for every node creates unneccessary memory fragmentation. If you care about squeezing out the last 5-10%, you could think about a solution to represent the incidence matrix and other information directly as arrays.\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Is Dijkstra's algorithm deterministic?\r\n                \r\nI think that Dijkstra's algorithm is determined, so that if you choose the same starting vertex, you will get the same result (the same distances to every other vertex). But I don't think that it is deterministic (that it has defined the following operation for each operation), because that would mean that it wouldn't have to search for the shortest distances in the first place.\n\nAm I correct? If I'm wrong, could you please explain why it is deterministic, and maybe give an example?\n    ", "Answer": "\r\nI'm not sure there is a universal definition of determinism, but Wikipedia defines it as...\n\n\n  ... an algorithm which, given a particular input, will always produce the same output, with the underlying machine always passing through the same sequence of states. \n\n\nSo this requires both determinism of the output and determinism of the execution. The output of Dijkstra's algorithm is deterministic no matter how you look at it, because it's the length of the shortest path, and there is only one such length.\n\nThe execution of Dijkstra's algorithm in the abstract sense is not deterministic, because the final step is:\n\n\n  \n  Otherwise, select the unvisited node that is marked with the smallest tentative distance, set it as the new \"current node\", and go back to step 3.\n  \n\n\nIf there are multiple nodes with the same smallest tentative distance, the algorithm is free to select one arbitrarily. This doesn't affect the output, but it does affect the order of operations within the algorithm.\n\nA particular implementation of Dijkstra's algorithm, however, probably is deterministic, because the nodes will be stored in a deterministic data structure like a min heap. This will result in the same node being selected each time the program is run. Although things like hashtable salts may also affect determinism even here.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Would Dijkstra's algorithm work in this case? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        How do I find the shortest path that covers all nodes in a directed cyclic graph?\r\n                            \r\n                                (4 answers)\r\n                            \r\n                    \r\n                Closed 4 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nUsually, Dijkstra's algorithm finds out the shortest distance to get from one node to another.\n\nBut can it work out the shortest distance to get from one node to another by going through every other single node. I need it to go to every other node before reaching the end node.\n\nHow would I apply this using Dijkstra's algorithm for an undirected graph, or is it not possible?\n    ", "Answer": "\r\nThe problem described is a variation of the Travelling salesman problem (TSP). This problem is NP-hard. A brute force solution has time complexity of O(n!). Using dynamic programming, you can achieve a time complexity of O(n2 2n). There are various heuristics to achieve a near optimal solution in polynomial time.\n\nDijsktra's algorithm will pick the shortest path to each new node found which may not be the optimal solution for the travelling salesman problem. As counter example, consider a graph connecting nodes with very short paths to each node except the end node. Imagine the shortest path from the 2nd last node to the end node to be exceptionally large such that it is optimal to take an intermediate non-shortest path between intermediate nodes so as to reach the end node.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Trying to understand Dijkstra's Algorithm\r\n                \r\nI am trying to better understand Dijkstra's Algorithm. I have attached an image of the algorithm that is in my textbook. The pseudocode shows the input is an undirected graph, but is the algorithm any different for a directed graph? I have looked up the algorithms with the input of a directed graph and I did not identify any differences. \n\n```\nAlgorithm ShortestPath(G, v)\n\nInput: A simple undirected weighted graph G with nonnegative edge weights and a distinguished vertex v of G\n\nOutput: A label D[u], for each vertex u of G, such that D[u] is the length of a shortest path from v to u in G\n\nInitialize D[v]<--0 and D[u]<--+infinity for each vertex u != v.\n\nLet priority queue Q contain all the vertices of G using the D labels as keys.\n\nwhile Q is not empty do\n\n    {pull a new vertex u into the cloud}\n\nu<-- Q.removeMin()\n\nfor each vertex z adjacent to u such that z is in Q do\n\n    {preform the relaxation procedure on edge (u,z)}\n\n    if D[u]+w((u,z))<D[z] then\n\n         D[z]<-- D[u]+w((u,z))\n\n         change to D[z] the of vertex z in Q\n\nreturn the label D[u] of each vertex u\n```\n\n\n\n    ", "Answer": "\r\nYou can use Dijkstra's algorithm in both directed and undirected graphs, because you simply add edges into the PriorityQueue when you have an edge to travel to from your adjacency list. For example, if one of my nodes has an edge from A to B of weight 3, then if it's directed from B I won't be able to add the edge back into A, while from A I could add it to B.\n\nLike the other answers, make sure you do not confuse it with weights. Dijkstra's algorithm runs on positive weighed graphs, otherwise the priority queue would be useless.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "getPath() Dijkstra's Algorithm in C\r\n                \r\nhttp://www.algolist.com/code/c/Dijkstra's_algorithm\n\nThis is the codes for getting the shortest path. I don't know how to implement the getpath() in the said implementation.\n\nIf you have better Dijkstra's Algorithm implementation in C. It would mean a lot  to me.\n\n```\nvoid getpath(int s, int t, int pred[]) { \n     int current = t;\n     while (current != s) { \n         printf(\"%d -> \", current); current = pred[current]; \n     }\n     printf(\"%d\\n\",current); \n}\n```\n\n    ", "Answer": "\r\nin this link    make cost as global variable of 2d array of type int and call ```\nshortpath(cost,preced,distance);```\n\nin the ```\nmain()```\n\n\nafter that in the ```\ncost[][]```\n 2d array will have paths along with length  select the shortest among them \n\nbefore applying it  i suggest you  understand Dijkstra's algo first here is the link [Dijkstra's algo2\nor http://www.youtube.com/watch?v=0nVYi3o161A\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Why use Dijkstra's algorithm instead of Best (Cheapest) First Search?\r\n                \r\nFrom what I have read so far. The Best First Search seems faster in terms of finding the shortest path to the goal because Dijkstra's algorithm has to relax all the nodes as it traverses the graph. What makes Dijkstra's algorithm better than Best First Search?\n    ", "Answer": "\r\nEDIT: Your edit clarifies you are interested in Best-First Search, and not BFS.\n\nBest-First Search is actually an informed algorithm, which expands the most promising node first. Very similar to the well known A* algorithm (actually A* is a specific best-first search algorithm). \n\nDijkstra is uninformed algorithm - it should be used when you have no knowledge on the graph, and cannot estimate the distance from each node to the target.\n\nNote that A* (which is a s best-first search) decays into Dijkstra's algorithm when you use heuristic function ```\nh(v)  = 0```\n for each ```\nv```\n.\n\nIn addition, Best First Search is not optimal [not guaranteed to find the shortest path], and also A*, if you do not use an admissible heuristic function, while Dijkstra's algorithm is always optimal, since it does not relay on any heuristic.\n\nConclusion: Best-First Search should be prefered over dijkstra when you have some knowledge on the graph, and can estimate a distance from target. If you don't - an uninformed Best-First Search that uses ```\nh(v) = 0```\n, and relays only on already explored vertices, decays into Dijkstra's algorithm.\nAlso, if optimality is important - Dijkstra's Algorithm always fit, while a best-first search algorithm (A* specifically) can be used only if an appropriate heuristic function is available.\n\n\n\nOriginal answer - answering why to chose Dijkstra over BFS:\n\nBFS fails when it comes to weighted graphs.\n\nExample:\n\n```\n     A\n   /   \\\n  1     5\n /       \\\nB----1----C\n```\n\n\nIn here: ```\nw(A,B) = w(B,C) = 1, w(A,C) = 5```\n.\n\nBFS from A will return ```\nA->C```\n as the shortest path, but for the weighted graph, it is a path of weight 5!!! while the shortest path is of weight 2: ```\nA->B->C```\n.\nDijkstra's algorithm will not make this mistake, and return the shortest weighted path.\n\nIf your graph is unweighted - BFS is both optimal and complete - and should usually be prefered over dijkstra - both because it is simpler and faster (at least asymptotically speaking).\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Modification of Dijkstra's Algorithm\r\n                \r\nI am currently playing around with the very famous Dijkstra's Algorithm, and am a little stuck. I am trying to modify the pseudo code to take an input of BOTH the source and destination, in efforts to find the SHORTEST path between the two vertices in an implemented Graph. I want to the inputs SOURCE AND DEST to be string values. I am also trying to modify, so the input is simply the list SHORTEST PATH. Any ideas on how I can modify the algorithm to obtain this? \n\n```\n1:  function Dijkstra(Graph, source):\n2:  for each vertex v in Graph: // Initialization\n3:  dist[v] := infinity // initial distance from source to vertex v is set to infinite\n4:  previous[v] := undefined    // Previous node in optimal path from source\n5:  dist[source] := 0   // Distance from source to source\n6:  Q := the set of all nodes in Graph  // all nodes in the graph are unoptimized - thus are in Q\n7:  while Q is not empty:   // main loop\n8:  u := node in Q with smallest dist[ ]\n9:  remove u from Q\n10: for each neighbor v of u:   // where v has not yet been removed from Q.\n11: alt := dist[u] + dist_between(u, v)\n12: if alt < dist[v]    // Relax (u,v)\n13: dist[v] := alt\n14: previous[v] := u\n15: return previous[ ]\n```\n\n    ", "Answer": "\r\nSimple, add DESTINATION as an argument that your function accepts as input and continue the algorithm as usual. Just remove the last line\n\n```\nreturn previous[ ]\n```\n\n\nAnd add the following lines which accesses the previous[] list only for the nodes in the shortest path. You start this traversal from the DEST node and go till you reach SOURCE\n\n```\nx := DEST\nshortest_path := []\nwhile x is not equal to SOURCE:\n       shortest_path.add(x)\n       x := previous[x]\n shortest_path.add(x) //finally add the SOURCE outside the loop\n return shortest_path[]\n```\n\n\nTo take SOURCE and DEST as string values, you need a routine which takes a string and returns a Node that is in that Graph with the value given by the input string.\n\n```\nAlgorithm getNodeFromString(Graph G, String s):\n      for every node N in G:\n             if N.id == s:\n                   return N\n```\n\n\nThis is, of course, assuming that every node in Graph has a unique identifier.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm (updating the heap)\r\n                \r\nI am implementing Dijkstra's algorithm using a heap data structure. I also use an array that keeps track of the \"probable minimum distances\" of the nodes. The problem is when I am updating the array, how to update the corresponding values in the heap?\n\nok here's the code\n\n```\ntypedef struct temp                       \n{\n    int nodeTag;    \n    int weight; \n    struct temp *next;\n}myStruct;  //this structure corresponds to the elements of the linked list \n\ntypedef struct temp *link;\n\ntypedef struct\n{ \n    int nodeTag;   //each node has an integer nodeTag associated with it\n    link l;\n}head;    //the head of the elements of the adjacency list\n\ntypedef struct {\n    head *adjList;\n    int numNodes;\n    int numEdges;\n} Graph;\n\ntypedef struct {\n    int possibleMinWeight;\n    int minFound;    //minFound==1 if true min is found\n} dummy;\n\ndummy *dijkstraSSSP(Graph G, int nodeTag)\n{\n    minHeap H=createEmptyHeap(G.numNodes);  \n    while(i=0;i<G.numNodes;i++)\n    {\n        if(i!=nodeTag)      \n            H.A[i].priority=INFINITY;\n        else \n            H.A[i].priority=0;\n        H.A[i].nodeTag=i;\n    }\n\n    convertIntoHeap(H);\n\n    int min;    \n\n    dummy *A=(dummy *)malloc(sizeof(int)*G.numNodes);\n\n    A[nodeTag-1].possibleMinWeight=0;\n    A[nodeTag-1].minFound=1; \n\n    while(!isEmpty(H))\n    {\n        element e=findMin(H);   H=deleteMin(H);\n\n        A[e.nodeTag-1].minFound=1;      \n\n        link l=G.adjList[e.nodeTag-1].l;        \n        while(l!=NULL)\n        {\n            if(A[l->nodeTag-1].minFound==0);    //its true minimum distance is yet to be found \n            {               \n                if(A[l->nodeTag-1].possibleMinWeight>A[x-1].possibleMinWeight+(l->weight))\n                    A[l->nodeTag-1].possibleMinWeight=A[x-1]+(l->weight);\n            }                   \n            l=l->next;\n        }\n    }   \n    return A;\n}\n```\n\n    ", "Answer": "\r\nTo write DecreaseKey, you need the priority-queue implementation to maintain a map from ```\nnodeTag```\ns to locations in the queue. That means updating this map whenever the binary-heap data structure calls for a swap or perhaps choosing a pointer-based implementation like pairing heaps that never moves nodes in memory.\n\nUnless you have a large, somewhat dense graph, DecreaseKey isn't worth it; just insert a node multiple times and ignore duplicate results from ExtractMin. (To detect duplicates: every time I've implemented Dijkstra, I've needed either the distances or the tree. In my programming languages of choice, it's easy enough to shake loose a bit from either array to remember whether each node has been visited.)\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Difficulty with Dijkstra's algorithm\r\n                \r\nI am new to advanced algorithms, so please bear with me. I am currently trying to get Dijkstra's algorithm to work, and have spend 2 days trying to figure this out. I also read the pseudo-code on Wikipedia and got this far.  I want to get the shortest distance between two vertices. In the below sample, I keep getting the wrong distance. Please help?\n\nSample graph setup is as follow:\n\n```\nGraph graph = new Graph();\ngraph.Vertices.Add(new Vertex(\"A\"));\ngraph.Vertices.Add(new Vertex(\"B\"));\ngraph.Vertices.Add(new Vertex(\"C\"));\ngraph.Vertices.Add(new Vertex(\"D\"));\ngraph.Vertices.Add(new Vertex(\"E\"));\n\ngraph.Edges.Add(new Edge\n                    {\n                        From = graph.Vertices.FindVertexByName(\"A\"),\n                        To = graph.Vertices.FindVertexByName(\"B\"),\n                        Weight = 5\n                    });\n\ngraph.Edges.Add(new Edge\n                    {\n                        From = graph.Vertices.FindVertexByName(\"B\"),\n                        To = graph.Vertices.FindVertexByName(\"C\"),\n                        Weight = 4\n                    });\n\ngraph.Edges.Add(new Edge\n                    {\n                        From = graph.Vertices.FindVertexByName(\"C\"),\n                        To = graph.Vertices.FindVertexByName(\"D\"),\n                        Weight = 8\n                    });\n\n\ngraph.Edges.Add(new Edge\n                    {\n                        From = graph.Vertices.FindVertexByName(\"D\"),\n                        To = graph.Vertices.FindVertexByName(\"C\"),\n                        Weight = 8\n                    });\n\n//graph is passed as param with source and dest vertices\npublic int Run(Graph graph, Vertex source, Vertex destvertex)\n{\n    Vertex current = source;\n    List<Vertex> queue = new List<Vertex>();\n\n    foreach (var vertex in graph.Vertices)\n    {\n        vertex.Weight = int.MaxValue;\n        vertex.PreviousVertex = null;\n        vertex.State = VertexStates.UnVisited;\n        queue.Add(vertex);\n    }\n\n    current = graph.Vertices.FindVertexByName(current.Name);\n    current.Weight = 0;\n    queue.Add(current);\n    while (queue.Count > 0)\n    {\n        Vertex minDistance = queue.OrderBy(o => o.Weight).FirstOrDefault();\n        queue.Remove(minDistance);\n\n        if (current.Weight == int.MaxValue)\n        {\n            break;\n        }\n\n        minDistance.Neighbors = graph.GetVerTextNeigbours(current);\n\n        foreach (Vertex neighbour in minDistance.Neighbors)\n        {\n            Edge edge = graph.Edges.FindEdgeByStartingAndEndVertex(minDistance, neighbour);\n            int dist = minDistance.Weight + (edge.Weight);\n            if (dist < neighbour.Weight)\n            {\n                //from this point onwards i get stuck\n                neighbour.Weight = dist;\n                neighbour.PreviousVertex = minDistance;\n                queue.Remove(neighbour);\n                queueVisited.Enqueue(neighbor);\n            }\n        }\n        minDistance.State = VertexStates.Visited;\n    }\n\n      //here i want to record all node that was visited\n     while (queueVisited.Count > 0)\n    {\n        Vertex temp = queueVisited.Dequeue();\n        count += temp.Neighbors.Sum(x => x.Weight);\n    }\n\n    return count;\n}\n```\n\n    ", "Answer": "\r\nThere are several immediate issues with the above code.\n\n\nThe ```\ncurrent```\n variable is never re-assigned, nor is the object mutatd, so ```\ngraph.GetVerTextNeigbours(current)```\n always returning the same set.\n\nAs a result, this will never even find the target vertex if more than one edge must be traversed.\nThe neighbor node is removed from the queue via ```\nqueue.Remove(neighbour)```\n. This is incorrect and can prevent a node/vertex from being [re]explored. Instead, it should just have the weight updated in the queue.\n\nIn this case the \"decrease-key v in Q\" is the psuedo-code results in a NO-OP in the implementation due object-mutation and not using a priority queue (i.e. sorted) structure.\nThe visited queue, as per ```\nqueueVisited.Enqueue(neighbor)```\n and the later \"sum of all neighbor weights of all visited nodes\", is incorrect.\n\nAfter the algorithm runs, the cost (```\nWeight```\n) of any node/vertex that was explored is the cost of the shortest path to that vertex. Thus, you can trivially ask the goal vertex what the cost is.\n\n\n\n\nIn addition, for the sake of the algorithm simplicity, I recommend giving up the \"Graph/Vertex/Edge\" layout initially created and, instead, pass in a simple Node. This Node can enumerate its neighbor Nodes, knows the weights to each neighbor, its own current weight, and the best-cost node to it.\n\nSimply build this Node graph once, at the start, then pass the starting Node. This eliminates (or greatly simplifies) calls like ```\nGetVerTextNeighbors```\n and ```\nFindEdgeByStartingAndEndVertex```\n, and strange/unnecessary side-effects like assigning ```\nNeighbors```\n each time the algorithm visits the vertex.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm with back tracking?\r\n                \r\nIn a related thread, it was suggested that I impliment Dijkstra's algorithm for finding the shortest path on a graph.  Looking at this .gif of the algorithm from wikipedia:\n\n\n\nWhat if the path 1,3,6,5 turned out to be very low cost?  For example, the weight on 3-6 was 1, and the weight on 6-5 was 2?  Dijkstra's algorithm would not consider this path because it only looks one step ahead; it skipped node 3.  \n\nIs it acceptable to specify a parameter that makes the algorithm look 2,3,4...n steps ahead before choosing each node?  I realize that this could potentially blow up computational time, but as long as the nodes aren't very dense (ie not more than 3 or 4 connections per node), this could provide a decent tradeoff between performance and optimal solution for our specific dataset.  \n\nDoes anyone have strong feelings about this?  And is such a shortest-path algorithm with this adjustable parameter likely to be in graph packages or not?\n    ", "Answer": "\r\nDijkstra algorithm always finds the shortest path (in graphs without negative edges) and never backtracks. It is easy to reason about it.\nAlways choosing the minimum\nThink about a node and its edges (it's just part of a larger graph):\n```\n    6   _ 3\n    |  /\n  14| /9\n    |/\n    1-------2\n        7  \n```\n\nDijkstra's algorithm will begin choosing the edge ```\n1-2 (7)```\n. I does so because it is the minimum it has seen so far. It then sets the value of the shortest path to ```\n2```\n as ```\n7```\n. It will never change this value again, because any other path from ```\n1```\n to ```\n2```\n must be larger (as it must start with one of the edges ```\n1-3 (9)```\n or ```\n1-6 (14)```\n).\nConsider the known nodes as a single node\nOne way to reason about what comes next is to pretend the algorithm merges \"known\" nodes into a single one. In the example, as soon as the shortest path to ```\n2```\n is chosen, it merges ```\n1```\n and ```\n2```\n as a single logical node. All edges going out of ```\n2```\n are increased by ```\n7```\n (the shortest path to ```\n2```\n). The next step is to choose the smallest edge outgoing from the \"supernode\". The reasoning then is the same as the first step:\n```\n    6   _ 3\n    |  /\n  14| /9\n    |/\n   1,2-------4\n        22  \n```\n\nIn this state, the next chosen edge is ```\n1,2-3 (9)```\n. The shortest path to ```\n3```\n is set as ```\n9```\n and all of its edges are now considered to choose the next minimum (please note how the edges to ```\n6```\n and ```\n4```\n have been updated):\n```\n    6\n    |\n  11|\n    |\n   1,2,3----4\n         20  \n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm With Negative Weights (But No Negative Cycles)\r\n                \r\nI believe that the implementation of Dijkstra's Algorithm below works for all graphs with negative weights but no cycles with a negative sum. \n\nHowever, I have seen many people say that Dijkstra's doesn't work for graphs with negative weights, so I am believing that either the algorithm is wrong or the execution time is far slower than Dijkstra's Algorithm.\n\nI was just wondering if someone could please help me with this code? Thank you very much for all your help!\n\n(Edit: This question is different from others since I am also wondering if the execution time of this algorithm is far longer than Dijkstra's Algorithm since nodes may be visited multiple times)\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<int, int> > G[N];\nint cost[N];\nint main() {\n\n    queue<int> q;\n    q.push(0);\n    cost[0] = 0;\n    for(int i=1; i<N; i++) {\n        cost[i] = infinity;\n    }\n\n    while(! q.empty()) {\n        int v = q.front();\n        q.pop();\n\n        for(int i=0; i<G[v].size(); i++) {\n            if(cost[G[v][i].first] > cost[v] + G[v][i].second) {\n                cost[G[v][i].first] = cost[v] + G[v][i].second;\n                q.push(G[v][i].first);\n            }\n        }\n    }\n}\n```\n\n    ", "Answer": "\r\nEven if correct (didn't prove it, but it seems to be), your algorithm suffers from bad time complexity.\n\nSpecifically, if you look at a complete DAG:\n\n```\nG = (V, E, w)\nV = {1, ..., n}\nE = { (i,j) | i < j }\nw(u,v) = 2^ (v - u)\n```\n\n\nAnd for simplicity of the example we assume the algorithm traverses edges in reverse order (```\n(u,v)```\n before ```\n(u,x)```\n if ```\nx < v```\n) (Note that this is just for simplification, and even without it you can build a counter example by reversing the directions of the edges).\n\nNote that your algorithm reopens each edge every time it opens it. That means you traverse all paths in this graph, which is exponential in the number of nodes.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm Issue\r\n                \r\nI'm working on a program where I have to find the shortest path between 12 cities, starting in Seattle and ending in Miami. I'm using Dijkstra's Algorithm because the paths are weighted. Here is my code so far, it all works except the answer I get is not the one I need, although it is correct.\n\nThis part of the code sets everything up as well as creates the sorting algorithm.\n\n```\nclass Graph\n{\n    Dictionary<string, Dictionary<string, int>> vertices = new Dictionary<string, Dictionary<string, int>>();\n\n    public void add_vertex(string name, Dictionary<string, int> edges)\n    {\n        vertices[name] = edges;\n    }\n\n    public List<string> shortest_path(string start, string finish)\n    {\n        var previous = new Dictionary<string, string>();\n        var distances = new Dictionary<string, int>();\n        var nodes = new List<string>();\n\n        List<string> path = null;\n\n        foreach (var vertex in vertices)\n        {\n            if (vertex.Key == start)\n            {\n                distances[vertex.Key] = 1;\n            }\n            else\n            {\n                distances[vertex.Key] = int.MaxValue;\n            }\n\n            nodes.Add(vertex.Key);\n        }\n\n        while (nodes.Count != 0)\n        {\n            nodes.Sort((x, y) => distances[x] - distances[y]);\n\n            var smallest = nodes[0];\n            nodes.Remove(smallest);\n\n            if (smallest == finish)\n            {\n                path = new List<string>();\n                while (previous.ContainsKey(smallest))\n                {\n                    path.Add(smallest);\n                    smallest = previous[smallest];\n                }\n\n                break;\n            }\n\n            if (distances[smallest] == int.MaxValue)\n            {\n                break;\n            }\n\n            foreach (var neighbor in vertices[smallest])\n            {\n                var alt = distances[smallest] + neighbor.Value;\n                if (alt < distances[neighbor.Key])\n                {\n                    distances[neighbor.Key] = alt;\n                    previous[neighbor.Key] = smallest;\n                }\n            }\n        }\n\n        return path;\n    }\n}\n```\n\n\nBelow is where I create the \"cities\" along with creating the values between them.\n\n```\nclass MainClass\n{\n    public static void Main(string[] args)\n    {\n        Graph g = new Graph();\n        g.add_vertex(\"Seattle\", new Dictionary<string, int>() { {\"San Francisco\", 1306}, {\"Denver\", 2161}, {\"Minneapolis\", 2661} });\n        g.add_vertex(\"San Francisco\", new Dictionary<string, int>() { {\"Seattle\", 1306}, {\"Las Vegas\", 919}, {\"Los Angeles\", 629} });\n        g.add_vertex(\"Las Vegas\", new Dictionary<string, int>() { {\"San Francisco\", 919}, {\"Los Angeles\", 435}, {\"Denver\", 1225}, {\"Dallas\", 1983} });\n        g.add_vertex(\"Los Angeles\", new Dictionary<string, int>() { {\"San Francisco\", 629}, {\"Las Vegas\", 435} });\n        g.add_vertex(\"Denver\", new Dictionary<string, int>() { {\"Seattle\", 2161}, {\"Las Vegas\", 1225}, {\"Minneapolis\", 1483}, {\"Dallas\", 1258} });\n        g.add_vertex(\"Minneapolis\", new Dictionary<string, int>() { {\"Seattle\", 2661}, {\"Denver\", 1483}, {\"Dallas\", 1532}, {\"Chicago\", 661} });\n        g.add_vertex(\"Dallas\", new Dictionary<string, int>() { {\"Las Vegas\", 1983}, {\"Denver\", 1258}, {\"Minneapolis\", 1532}, {\"Washington DC\", 2113} });\n        g.add_vertex(\"Chicago\", new Dictionary<string, int>() { {\"Minneapolis\", 661}, {\"Washington DC\", 1145}, {\"Boston\", 1613} });\n        g.add_vertex(\"Washington DC\", new Dictionary<string, int>() { {\"Dallas\", 2113}, {\"Chicago\", 1145}, {\"Boston\", 725}, {\"New York\", 383}, {\"Miami\", 1709} });\n        g.add_vertex(\"Boston\", new Dictionary<string, int>() { {\"Chicago\", 1613}, {\"Washington DC\", 725}, {\"New York\", 338} });\n        g.add_vertex(\"New York\", new Dictionary<string, int>() { {\"Washington DC\", 383}, {\"Boston\", 338}, {\"Miami\", 2145} });\n        g.add_vertex(\"Miami\", new Dictionary<string, int>() { {\"Dallas\", 2161}, {\"Washington DC\", 1709}, {\"New York\", 2145} });\n\n        g.shortest_path(\"Miami\", \"Seattle\").ForEach(x => Console.Write(x + \" > \"));\n    }\n}\n```\n\n\nThe part that I need help figuring out is when I run the program, I get: Seattle > Denver > Dallas. That answer is correct for the shortest distance to Miami, but I need the shortest distance to every city, not just Miami. I just don't know what I need to change to display that properly.\n    ", "Answer": "\r\nTo my understanding, the provided code implements Dijkstra's Algorithm, modified to terminate as soon as some desired destination node is selected into the set of nodes for which the shortest path from the initial node is known. Dijkstra's algorithm solves the so-called Single Source Shortest Path problem. This means that some initial node, in this case ```\nMiami```\n, is specified, and the desired result is consituted by the shortest paths to all other nodes. It does not solve the All-Pairs Shortest Path problem, which requires calculation of the respective distance for each pair nodes. This problem can be solved by the Floyd-Warshall Algorithm, however.\n\nIn contrast, if you need the shortest path from ```\nMiami```\n to all other cities, modifiy the implementation ```\nnot```\n to break the loop early and remove the second argument.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm in Memgraph\r\n                \r\nI'm trying to run Dijkstra's algorithm in Memgraph on a dataset containing nodes with different properties, one of them being ```\nEuro```\n and with different relationships, one of them being ```\n:MarriedTo```\n.\nMy goal is to find the weighted shortest path between nodes based on the value of the ```\nEuro```\n node property, traversing only across ```\nMarriedTo```\n relationships and return the result as  path nodes. This is the query I've come up with:\n```\nMATCH path=(n {id: 0})-[:MarriedTo *WSHORTEST (r, n)]-(m {id: 9})\nUNWIND (nodes(path)) AS node\nRETURN node.id;\n```\n\nBut I'm getting this error:\n```\nQuery failed: Function 'WSHORTEST' doesn't exist.\n```\n\nand I'm not sure how to fix it\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm - comparisons in priority queue\r\n                \r\nI've copied dijkstra's algorithm in C++ from this page and modified it to suit my graph representation classes. Basically, I replaced only ```\nstd::pair```\n as template parameter to ```\nstd::set```\n by my own structure ```\nedge```\n:\n\n```\nstruct edge\n{\n    int vertex;\n    unsigned long weight;\n\n    edge(int v = 0, unsigned long wt = 0) : vertex(v), weight(wt) { }\n\n    bool operator<(const edge& e2) const\n    {\n        //return weight < e2.weight;\n        return weight < e2.weight || ((e2.weight >= weight) && vertex < e2.vertex);\n    }\n};\n```\n\n\nHowever, I had to implement operator< similarly to the one found in std::pair. When I use commented return statement, the outputs are wrong. But the longer statement returns ```\ntrue```\n if ```\ne2.weight >= weight```\n (so ```\ne2.weight```\n might actually be bigger than ```\nweight```\n) as long as ```\nvertex < e2.vertex```\n. But vertex numbers do not appear in the definition of the Dijkstra's algorithm.\n\nSo how come the program is working properly with only the second return statement?\n    ", "Answer": "\r\nrephrasing the correct return statement:\n\n```\nreturn (this->weight < e2.weight) || ((this->weight <= e2.weight) && this->vertex < e2.vertex);\n```\n\n\nequivalent to:\n\n```\nreturn (this->weight < e2.weight) || ((this->weight == e2.weight) && this->vertex < e2.vertex);\n```\n\n\n(<= breaks down into == because of the shortcircuiting from the first condition)\n\nso I want my weight to be lesser.... or if equal, the vertex to be lesser.\n\nedit (misunderstood the original why does it fail phrasing):\nA standard set requires a strict ordering....\n\nAs you insert graph edges, the weights of these edges can be the same - and therefore, weights alone aren't a unique identifier for your edges, so it is not about a logical ordering mechanism as per Djikstra's - it is a way of holding all your edges without overwriting one another in the set.\n\nFor a more obvious failure case, try doing this with both definitions of op<:\n\n```\n//int verticeIdx[4] = {0, 1, 2, 3} \nint constWeight = 3;\nedge myEdge(0, constWeight), myNewEdge(1, constWeight);\nstd::set<edge> edges;\nedges.insert(myEdge);\nedges.insert(myNewEdge);\nstd::cout << edges.size();\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm in Javascript Maze Implementation\r\n                \r\nI'm trying to use Dijkstra's Algorithm to path find every position of a maze back to a specific point. \n\nI found a JavaScript version of Dijkstra's Algorithm here: \n\nhttps://github.com/bm1362/dijkstra-js/blob/master/nodes.js\n\n(Thank you bm1362!)\n\nThe way I've approached creating the maze graph is as follows:\n\n```\n// the maze\nvar maze = \n[[1, 1, 1, 1],\n [1, 0, 0, 0],\n [1, 0, 0, 0],\n [1, 1, 1, 1]];\n\n\nmaze2 = [];\nvar i = 0;\nvar mazeSize = 30;\nfor (var x = 0; x < maze[0].length; x++) {\n\n    for (var y = 0; y < maze[0].length; y++) {\n\n        if (maze[x][y] == 1) {\n            nodes.push(new node);\n            nodes[i].setPos((x) * (maze[0].length + 100), (y) * ((maze[0].length + 100)))\n            nodes[i].tmppos = [x, y];\n            nodes[i].id = i;\n            maze2[x + ',' + y] = nodes[i];\n            i++;\n        }\n\n    }\n}\n\n//sort nodes in order of x position\nvar sortedNodes = quickSort(nodes);\n//var sortedNodes = nodes;\nfor (var i = 0; i < sortedNodes.length; i++) {\n    sortedNodes[i].number = i;\n\n\n    var n1 = sortedNodes[i];\n    var up = {}, down = {}, left = {}, right = {};\n    var pos = [];\n    up.x = n1.tmppos[0];\n    up.y = n1.tmppos[1] - 1;\n    pos.push(up);\n    down.x = n1.tmppos[0];\n    down.y = n1.tmppos[1] + 1;\n    pos.push(down);\n    left.x = n1.tmppos[0] - 1;\n    left.y = n1.tmppos[1];\n    pos.push(left);\n    right.x = n1.tmppos[0] + 1;\n    right.y = n1.tmppos[1];\n    pos.push(right);\n\n    for (var m = 0; m < pos.length; m++) {\n\n        if (maze[pos[m].x] != undefined && maze[pos[m].x][pos[m].y] != undefined && maze[pos[m].x][pos[m].y] == 1) {\n            var n2 = maze2[pos[m].x + ',' + pos[m].y];\n            var dist = calcDist(n1, n2);\n            sortedNodes[i].addConnection(n2);\n            connections.push({\n                a: n1,\n                b: n2,\n                dist: dist\n            })\n        }\n    }\n\n\n}\n```\n\n\nThe issue that I'm having is even though all the nodes do seem to have a connection, when the algorithm runs, some of the nodes do not get a parent set. But I've tried many different ways and I still cannot get it to set all the parents.\n\nI've created a JS fiddle here: http://jsfiddle.net/XcdCr/3/\n\nAny help would be greatly appreciated. \n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Complexity Of Dijkstra's algorithm\r\n                \r\nI read from many sources that Dijkstra's Shortest Path also will run in O(V^2) complexity if using a naive way to get the min element (linear search). However, it can be optimised to O(VLogV) if priority queue is used as this data structure will return min element in O(1) time but takes O(LogV) time to restore the heap property after deleting the min element.\n\nI have implemented Dijkstra's algo in the following code for the UVA problem at this link: https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=1927:\n\n```\n#include<iostream>\n#include<vector>\n#include <climits>\n#include <cmath>\n#include <set>\n\nusing namespace std;\n\n#define rep(a,b,c) for(int c=a;c<b;c++)\n\ntypedef std::vector<int> VI;\ntypedef std::vector<VI> VVI;\n\nstruct cmp {\n    bool operator()(const pair<int,int> &a,const pair<int,int> &b) const {\n        return a.second < b.second;\n    }\n};\n\nvoid sp(VVI &graph,set<pair<int,int>,cmp> &minv,VI &ans,int S,int T) {\n    int e = -1;\n    minv.insert(pair<int,int>(S,0));\n    rep(0,graph.size() && !minv.empty() && minv.begin()->first != T,s) {\n        e = minv.begin()->first;\n        minv.erase(minv.begin());\n        int nb = 0;\n        rep(0,graph[e].size(),d) {\n            nb = d;\n            if(graph[e][d] != INT_MAX && ans[e] + graph[e][d] < ans[d]) {\n                set<pair<int,int>,cmp>::iterator si = minv.find(pair<int,int>(d,ans[d]));\n                if(si != minv.end())\n                    minv.erase(*si);\n                ans[d] = ans[e] + graph[e][d];\n                minv.insert(pair<int,int>(d,ans[d]));\n            }\n        }\n    }\n}\n\nint main(void) {\n    int cc = 0,N = 0,M = 0,S = -1,T = -1,A=-1,B=-1,W=-1;\n    VVI graph;\n    VI ans;\n    set<pair<int,int>,cmp> minv;\n    cin >> cc;\n\n    rep(0,cc,i) {\n        cin >> N >> M >> S >> T;\n        graph.clear();\n        ans.clear();\n        graph.assign(N,VI());\n        ans.assign(graph.size(),INT_MAX);\n        minv.clear();\n        rep(0,N,j) {\n            graph[j].assign(N,INT_MAX);\n        }\n        ans[S] = 0;\n        graph[S][S] = 0;\n        rep(0,M,j) {\n            cin >> A >> B >> W;\n            graph[A][B] = min(W,graph[A][B]);\n            graph[B][A] = min(W,graph[B][A]);\n        }\n        sp(graph,minv,ans,S,T);\n        cout << \"Case #\" << i + 1 << \": \";\n        if(ans[T] != INT_MAX)\n            cout << ans[T] << endl;\n        else\n            cout << \"unreachable\" << endl;\n    }\n}\n```\n\n\nBased on my analysis, my algorithm has a O(VLogV) complexity. The STL std::set is implemented as a binary search tree. Furthermore, the set is sorted too.\nHence getting the minimum element from it is O(1), insertion and deletion is O(LogV) each. However, I am still getting a TLE from this problem which should be solvable in O(VLogV) based on the given time limit.\n\nThis led me to think deeper. What if all nodes were interconnected such that each vertex V has V-1 neighbours? Won't it make Dijkstra's algorithm run in O(V^2) since each vertex has to look at V-1,V-2,V-3... nodes every round?\n\nOn second thoughts, I might have misinterpreted the worst case complexity. Could someone please advise me on the following issues:\n\n\nHow is Dijkstra's algo O(VLogV) especially given the above counterexample?\nHow could I optimise my code so that it could achieve O(VLogV) complexity (or better)?\n\n\nEdit:\n\nI realised that my program does not run in O(ElogV) after all. The bottleneck is caused by my input processing which runs in O(V^2). The dijkstra part indeed runs in (ElogV).\n    ", "Answer": "\r\nIn order to understand the time complexity of Dijkstra's algorithm, we need to study the operations that are performed on the data structure that is used to implement the Frontier set (i.e. the data structure used for ```\nminv```\n in your algorithm):\n\n\nInsert\nUpdate\nFind/Delete minimum\n\n\nThere are ```\nO(|V|)```\n inserts, ```\nO(|E|)```\n updates, ```\nO(|V|)```\n Find/Delete Minimums in total that occur on the data structure for the entire duration of the algorithm.\n\n\nOriginally Dijkstra implemented the Frontier set using an unsorted array. Thus it was ```\nO(1)```\n for Insert and Update, but ```\nO(|V|)```\n for Find/Delete minimum, resulting in ```\nO(|E| + |V|^2)```\n, but since ```\n|E| < |V|^2```\n, you have ```\nO(|V|^2)```\n.\nIf a binary min-heap is used to implement the Frontier set, you have ```\nlog(|v|)```\n for all operations, resulting in ```\nO(|E|log|V| + |V|log|V|)```\n, but since it is reasonable to assume ```\n|E| > |V|```\n, you have ```\nO(|E|log|V|)```\n.\nThen came the Fibonacci heap, where you have ```\nO(1)```\n amortized time for Insert/Update/Find minimum, but ```\nO(log|V|)```\n amortized time for Delete minimum, giving you the currently best known time bound of ```\nO(|E| + |V|log|V|)```\n for Dijkstra's algorithm.\n\n\nFinally, an algorithm for solving the Single Source Shortest Paths problem in ```\nO(|V|log|V|)```\n worst case time complexity is not possible if ```\n(|V|log|V| < |E|)```\n, since the problem has the trivial lower time bound of ```\nO(|E| + |V|)```\n i.e. you need to inspect each vertex and edge at least once to solve the problem.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm when two edges have same weight\r\n                \r\n\nI use Dijkstra's algorithm to find the shortest path from vertex A to vertex D. But edges AB and AC have the same weight. How does Dijkstra's algorithm work if a graph has some same weight edges?\n    ", "Answer": "\r\nDijkstra's algorithm doesn't throw away possibilities -- it keeps both edge AB and edge AC \"in the running\". It does so by putting both B and C in the priority queue, keyed by the distance they have from node A, which is 1 in both cases. So the priority queue will give them the same priority. Depending on the implementation -- and possibly the order in which you had inserted these two nodes in that priority queue -- either B or C will be the first item in that queue. But eventually, it doesn't matter for the end result.\nFor instance, if B is first, then in a next cycle of the algorithm, that B will be pulled from the queue, and D is pushed unto it with a distance of 6. In a next iteration C is pulled from the queue and D gets added again to the queue (or updated -- depends on implementation), this time with distance 4. We are sure that when we pull D from the queue, it will be the version with distance 4, and so it will correctly find the shortest path.\nIf B was not first, but C was first, then D gets pushed into the queue with distance 4, and when B is processed, D is either rejected now (as its distance is greater than the smallest distance we have for it), or in some implementations it still gets pushed to the queue, but never reaches the front of the queue, because the other version of D (already in the queue) has a higher priority. So also in this scenario the queue will give us a D with the shortest distance, the next time we pull D from it.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm concepts [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI am just learning Dijkstra algorithm and just a little bit confuse in this\n\n```\nIf min(A,B) = x;\n   min(A,C) = y;\n   min(B,C) = must be x-y;\n```\n\n\nPlease justify it or i am wrong?\n    ", "Answer": "\r\nOkay here's what you meant to say:\n\nI will be referring to a directed non-negative weight graph in all of this.\n\nThe shortest path problem:\n\nFor a digraph G and a node r in V and a real cost vector (c_e:e in E) (I wish we had LaTeX here)\n\nwe wish to find:\n\nfor each v in V a dipath from r to v of least cost (supposing it exists)\n\nHere's the gist of what you want:\n\nsuppose we know there's a path from r to v of cost y_v for each v in V, and we find an edge vw in E satisfying y_v + c_vw < y_w \n\nSince appending vw to the dipath to v (to get a path to w) gives a path of length y_v+c_vw\n\nA least cost dipath satisfies: \n\ny_v+c_vw >= y_w for all vw in E\n\nWe call such a y vector a \"feasible potential\"\n\nProposition: y_v is minimal\n\nLet y be a feasible potential, and let P be a dipath from r to v, then it follows c(P) >= y_v\n\nProof:\n\nc(P) = sum c_ei (the the ith edge in the path's cost)\n\nRecall that a feasible potential statisfies y_v + c_vw >= y_w\n\nSo c_vw >= y_w - y_v this is what you have\n\nThus \n\nc(P) >= sum (y_vi-y_v{i-1}) (the cost to the ith item take the cost of the previous one)\n\nif you write it as sum (-y_v{i-1} + y_vi) then expand the sum: (y_v0 = 0 obviously)\n\n-y_v0+y_v1 -y_v1 + y_v2 - .... -y_v{k-2} + y_v{k-1} -y_v{k-1} + y_vk\n\nyou see all the terms cancel out, giving:\n\nc(P) >= y_vk - y_v0 = y_vk\n\nThus we have shown c(P) >= y_vk\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm modification\r\n                \r\nLet ```\nG (V, E)```\n be a weighted, directed graph with non negative weight function\n```\nW : E -> {0, 1, 2... W }```\n for some non negative integer ```\nW```\n . How to modify Dijkstra’s algorithm to compute the shortest paths from a given source vertex s in ```\nO(V W + E)```\n time.\n    ", "Answer": "\r\nStandard Dijkstra's uses a priority queue and can handle floating-point values. This allows all the weights to differ from each other and implies no upper bound.\n\nBut now you have integer weights and an upper bound: given these additional constraints you should be able to build a faster algorithm. And, indeed, you can, by using buckets (one for each weight) to store the nodes.\n\nIn full:\n\n\nCreate buckets labeled ```\n0, 1, 2, 3, ..., W(V-1)```\n where ```\nW```\n is the maximum weight and ```\nV```\n is the number of nodes. Bucket ```\nk```\n will contain all nodes labeled with distance ```\nk```\n. Each bucket can be represented by a vector or list of nodes.\nBuckets ```\n0, 1, 2, ..., WV```\n are checked sequentially until the first non-empty bucket is found. The nodes in this bucket are at the frontier.\nEach node in this bucket is labeled with its true distance and then deleted from the bucket.\nSteps (2-4) are now repeated (though begin scanning in 2 at the bucket you just emptied) until all buckets are empty.\n\n\nYou need ```\nWV```\n buckets to account for the degenerate case in which ```\nW=1```\n but the graph is a line. In this case, the farthest apart two nodes can be is ```\nW(V-1)```\n.\n\nA more complete explanation is available here.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's and Prim's algorithm\r\n                \r\nas I see Dijkstra's and Prim's algorithms are amost the same. Here is the pseudocode from wikipedia, I'll explain the poinf of my confusion.\n\n```\n1  function Dijkstra(Graph, source):\n2      dist[source] ← 0                                    // Initialization\n3\n4      create vertex set Q\n5\n6      for each vertex v in Graph:           \n7          if v ≠ source\n8              dist[v] ← INFINITY                          // Unknown distance from source to v\n9              prev[v] ← UNDEFINED                         // Predecessor of v\n10\n11         Q.add_with_priority(v, dist[v])\n12\n13\n14     while Q is not empty:                              // The main loop\n15         u ← Q.extract_min()                            // Remove and return best vertex\n16         for each neighbor v of u:                      // only v that is still in Q\n17             alt ← dist[u] + length(u, v) \n18             if alt < dist[v]\n19                 dist[v] ← alt\n20                 prev[v] ← u\n21                 Q.decrease_priority(v, alt)\n22\n23     return dist[], prev[]\n```\n\n\nPrim's algorithm is almost the same, for convenience, I'll just change the loop that starts in 14th line\n\n```\n14     while Q is not empty:                              \n15         u ← Q.extract_min()                            \n16         for each neighbor v of u:                      \n17             if v ∈ Q and length(u, v) < cost[v]\n18                 cost[v] ← length(u, v)\n19                 prev[v] ← u\n20                 Q.decrease_priority(v, length(u, v))\n```\n\n\nThere are two changes, the first is replacing ```\ndist[]```\n with ```\ncost[]```\n and as I understand this is related to the fact that algorithms solve different problems.\nThe second one is obscure for me, namely the absence of  ```\nif v ∈ Q```\n this condition in Dijkstra's algorithm. I don't really get why we CAN return to the set of visited vertices in Prim's algorithm and this CANNOT happen in Dijkstra's algorithm. \n    ", "Answer": "\r\nIn Dijkstra, we compute ```\nalt ← dist[u] + length(u, v)```\n and set ```\ndist[v]```\n to ```\nalt```\n if ```\nalt```\n is smaller than the current value of ```\ndist[v]```\n. ```\nalt```\n represents the distance from the start node to ```\nv```\n if we go via ```\nu```\n. However, ```\nu```\n is the node that was just taken out of ```\nQ```\n, and so, its distance from the start node is greater than or equal to all other nodes that have previously been taken out of ```\nQ```\n. Because Dijkstra requires all edge weights to be nonnegative, ```\nalt```\n is guaranteed to be greater than or equal to ```\ndist[v]```\n if ```\nv```\n is not in ```\nQ```\n since it is the sum of ```\ndist[u]```\n and ```\nlength(u, v)```\n, and so it won't pass the condition in the ```\nif```\n. In other words, if ```\nv```\n is not in ```\nQ```\n, ```\nu```\n will be a detour relative to the path we already have to ```\nv```\n.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Has anyone used Dijkstra's algorithm in OPL?\r\n                \r\nI have a model for a mining problem. I am working on adding into the model to use the shortest path inside a mine(open pit) for hauling ore and waste. For this, I was thinking of Dijkstra's algorithm. I could not find any example of the use of Dijkstra's algorithm in OPL. Has anyone done it before and can you share some ideas, please.\n    ", "Answer": "\r\nif you need to write Dijsktra's algorithm then Daniel is right and you d rather use the scripting part. Now if you need a shortest path within an existing OPL model you could use the following shortest path example:\n\n.mod\n\n```\ntuple edge\n{\n   key int o;\n   key int d;\n   int weight;\n}\n\n{edge} edges=...;\n\n{int} nodes={i.o | i in edges} union {i.d | i in edges};\nint st=1; // start\nint en=8; // end\n\ndvar int obj; // distance\ndvar boolean x[edges]; // do we use that edge ?\n\nminimize obj;\n\nsubject to\n{\nobj==sum(e in edges) x[e]*e.weight;\n\nforall(i in nodes) \n    sum(e in edges:e.o==i) x[e]\n    -sum(e in edges:e.d==i) x[e]    \n    ==\n    ((i==st)?1:((i==en)?(-1):0));\n}\n\n{edge} shortestPath={e | e in edges : x[e]==1};\n\nexecute\n{\nwriteln(shortestPath);\n}\n```\n\n\n.dat\n\n```\nedges=\n{\n<1,2,9>,\n<1,3,9>,\n<1,4,8>,\n<1,10,18>,\n<2,3,3>,\n<2,6,6>,\n<3,4,9>,\n<3,5,2>,\n<3,6,2>,\n<4,5,8>,\n<4,7,7>,\n<4,9,9>,\n<4,10,10>,\n<5,6,2>,\n<5,7,9>,\n<6,7,9>,\n<7,8,4>,\n<7,9,5>,\n<8,9,1>,\n<8,10,4>,\n<9,10,3>,\n}; \n```\n\n\nwhich gives\n\n```\n// solution (optimal) with objective 19\n {<1 4 8> <4 7 7> <7 8 4>}\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "When will Dijkstra's algorithm and Prim's algorithm produce different outputs?\r\n                \r\nI know the difference between Prim's and Dijkstra's algorithm. The former produces a MST while latter gives shortest path from source to all node.  Mathematically, these aren't the same, so we wouldn't always expect the two algorithms to produce the same results.\n\nHowever, while trying different examples I am getting the same result. The pseudocode for Prim's algorithm and Dijkstra's algorithm also look very similar. Can someone please give me an example where Prim's produces a MST which will not be obtained while solving with Dijkstra's or vice-versa.\n\nAlso, according to my knowledge. Both of these algorithm uses following approach. Please correct me if I am wrong:\n\n\n  Find shortest i-j where i from set which has already been included and j\n       from set which hasn't been included yet and then add j to the set.\n\n    ", "Answer": "\r\nA simple example is a collection of four nodes placed at the corners of a square.  Place edges of cost 2 between any two adjacent corners, and place edges of cost 3 running diagonally across the square.  Running Dijkstra's algorithm from any corner will pick these edges:\n\n```\n* -- *\n| \\\n|  \\\n*    *\n```\n\n\nThese are the shortest paths, and the total cost of the edges is 7.\n\nRunning Prim's algorithm will pick these edges:\n\n```\n* -- *\n| \n|\n* -- *\n```\n\n\nThis is an MST (total edge cost is 6), but these aren't shortest paths (the path from the upper-left corner to the lower-right corner has cost 4, but there's a more direct route possible.)\n\nAs a challenge: try finding graphs where\n\n\nDijkstra's algorithm finds a shortest-path tree that is Ω(n) times heavier than the actual MST, and\nPrim's algorithm finds an MST where the paths in the tree are Ω(n) times longer than in a corresponding shortest-path tree.\n\n\nPrim's and Dijkstra's both choose a node by finding some node not in a set and bringing it into the set, but they differ in how they adjust the distances.  In Prim's algorithm, the distances used are always the minimum distance from any node out of the set to any node inside the set.  In Dijkstra's algorithm, the distance is the minimum of the following value:\n\n\n  distance(start node, u) + l(u, v)\n\n\nIn other words, Dijkstra's algorithm factors in the distance from the start node to nodes outside the set, while Prim's does not.\n\nHope this helps!\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Returning the path in Dijkstra's Algorithm\r\n                \r\nSo, I've been implementing Dijkstra's algorithm for pathfinding through a maze I generate (I know some of you might think something like A* would be better, but Dijkstra's perfectly fits my needs), and I've run into a small issue. I feel like I'm overlooking something, but when I return the \"path\" from the start node to the end node, it returns the entire search path the algorithm took (every node it visited), and not the path to the node.\n\n```\n//Uses djikstra's algorithm to find the shortest path between two nodes\n//\"vertices\" is the global ArrayList in the class with all vertices in the graph.\n@Override\npublic ArrayList<Vertex> pathfind(Vertex v1, Vertex v2) {\n    ArrayList<Vertex> path = new ArrayList<Vertex>();\n    ArrayList<Vertex> unvisited = new ArrayList<Vertex>();\n    ArrayList<Vertex> visited = new ArrayList<Vertex>();\n\n    if (!vertices.contains(v1) || !vertices.contains(v2)) {\n        return path;\n    }\n\n    //initialize distances\n    v1.setDistance(0);\n    for(Vertex vert : vertices) {\n        if(vert != v1) {\n            vert.setDistance(Integer.MAX_VALUE);\n        }\n        unvisited.add(vert);\n    }\n    Vertex current = v1;\n\n    //begin\n    while (!unvisited.isEmpty()) {  \n        //for all adjacent vertices that are unvisited\n        for (Vertex v : current.adjacentVertices()) {\n            if (!visited.contains(v)) {\n                //if the distance of that vertex is greater than \n                //the added distance of the current node + the edge connecting the two\n                int pathDist = current.getDistance() + findEdge(current, v).getElement(); \n                if (v.getDistance() > pathDist) {\n                    //assign the new distance\n                    v.setDistance(pathDist);\n                }\n            }\n        }\n\n        //remove the current node from the visited set and add it to visited\n        visited.add(current);\n        unvisited.remove(current);\n\n        //add current node to the path\n        path.add(current);\n\n        //return if we found the destination\n        if (current == v2)) {\n            return path;\n        }\n\n        //else move to the lowest value node\n        current = findSmallest(unvisited);\n\n    }\n    return path;\n\n}\n```\n\n\nI know it must be something painfully obvious but I'm hitting my head against the wall, any help would be appreciated. Thanks!\n    ", "Answer": "\r\nYou might want to calculate the distances first/ stabilize the distance to minimum value using the algo, then run over the graph to get the nodes for the path.\n\nAs ```\ncurrent = findSmallest(unvisited)```\n might get you node from a path which is not connected.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "why PriorityQueue used in Dijkstra's Algorithm?\r\n                \r\nI've been trying to understand the internals of the Dijkstra's Algorithm to find the shortest path for the weighted graph.\n\nAfter visiting one vertex, why we have to store the adjacent vertex's into a PriorityQueue instead of normal Queue ?\n\nThe reason I'm asking the above question was : \nI understand with PriorityQueue we can get either biggest / smallest numbers from the Queue. But in the case of Dijkstra's Algorithm, we are anyway visiting all the vertex's irrespective of distance / priority. In such cases why do we need to use PriorityQueue with O(log N) complexity, where normal Queue would do O(1) ?\n\nAm I missing anything ?\n    ", "Answer": "\r\nThere can be multiple ways to reach a vertex, and using a priority queue ensures that we have found the shortest distance to a vertex by the time we visit it.\n\nConsider the following graph:\n\n```\n a\n |\\\n1| \\3\n |  \\\n c---b\n   1  \\\n       \\\n       ...\n```\n\n\nWhen we visit vertex ```\na```\n, we will put vertex ```\nb```\n and vertex ```\nc```\n into the priority queue with distances of 3 and 1 respectively. If we don't use a priority queue, we might visit ```\nb```\n first which is a problem because the shortest distance to ```\nb```\n that we currently know is suboptimal.\n\nIf we use a priority queue, we can prove that when we explore a vertex there is no path to this vertex shorter than the distance which we currently know. Assume for the sake of contradiction that we visit a vertex ```\nb```\n when there is a shorter path to it. Let ```\n(u, v)```\n be an edge on the shorter path to ```\nb```\n such that ```\nu```\n has been visited and ```\nv```\n has not been visited. Since ```\nu```\n has been visited, we must have added ```\nv```\n to the queue, and since ```\nv```\n is on a shorter path to ```\nb```\n, it's distance must be shorter than the distance to ```\nb```\n which means it must have been visited before ```\nb```\n. Therefore, we have a contradiction and we know that no shorter path can exist.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm for graph structure\r\n                \r\nI'm currently trying to learn some graph theory online and from a friend and he's had me working with a specific structure of graph, I now want to implement Dijkstra's algorithm using the struct but i cant figure out how to. I understand the on-paper theory of Dijkstra but cannot interpret it into code\n\nBelow is the header file, used to define the graph\n\n```\ntypedef struct edge {\n    int to_vertex;\n    float weight;\n} Edge;\n\ntypedef struct edgeNode {\n    Edge edge;\n    struct edgeNode *next;\n} *EdgeNodePtr;\n\ntypedef struct edgeList {\n    EdgeNodePtr head;\n} EdgeList;\n\ntypedef struct graph {\n    int V;\n    int *vertex_types;\n    EdgeList *edges;\n} Graph;\n```\n\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Difference between Prim's and Dijkstra's algorithms?\r\n                \r\nWhat  is the exact difference between Dijkstra's and Prim's algorithms? I know Prim's will give a MST but the tree generated by Dijkstra will also be a MST. Then what is the exact difference?\n    ", "Answer": "\r\nPrim's algorithm constructs a minimum spanning tree for the graph, which is a tree that connects all nodes in the graph and has the least total cost among all trees that connect all the nodes.  However, the length of a path between any two nodes in the MST might not be the shortest path between those two nodes in the original graph.  MSTs are useful, for example, if you wanted to physically wire up the nodes in the graph to provide electricity to them at the least total cost.  It doesn't matter that the path length between two nodes might not be optimal, since all you care about is the fact that they're connected.\nDijkstra's algorithm constructs a shortest path tree starting from some source node.  A shortest path tree is a tree that connects all nodes in the graph back to the source node and has the property that the length of any path from the source node to any other node in the graph is minimized.  This is useful, for example, if you wanted to build a road network that made it as efficient as possible for everyone to get to some major important landmark.  However, the shortest path tree is not guaranteed to be a minimum spanning tree, and the sum of the costs on the edges of a shortest-path tree can be much larger than the cost of an MST.\nAnother important difference concerns what types of graphs the algorithms work on.  Prim's algorithm works on undirected graphs only, since the concept of an MST assumes that graphs are inherently undirected.  (There is something called a \"minimum spanning arborescence\" for directed graphs, but algorithms to find them are much more complicated).  Dijkstra's algorithm will work fine on directed graphs, since shortest path trees can indeed be directed.  Additionally, Dijkstra's algorithm does not necessarily yield the correct solution in graphs containing negative edge weights, while Prim's algorithm can handle this.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm - adjacency matrix and list\r\n                \r\nI've got strange problem with my Dijkstra's implementation... I have 2 algorithms, one for adjacency matrix and the second one for adjacency list. They are almost identical and only difference is with passing numbers from these structures.\n\nI keep numbers from matrix in simple two-dimensional matrix called weightmat.\nNumbers from list are kept in array of lists called nbhlist.\nLists are composed from structs called ListNode.\n\n```\nstruct ListNode{    \n        int number;             \n        int weight;         \n        ListNode* next;             \n        ListNode(){                         \n            number = weight = 0;\n            next = 0;\n        }\n    };\n```\n\n\nAnd few general variables: vertex (number of vertices), edge (number of edges), vstart (number of start vertex).\n\nNow code of Dijkstra's algorithm for matrix:\n\n```\ntypedef vector<vector<pair<int, float> > > Graph;\nstruct Compare{\n    int operator() (const pair<int,float>& p1, const pair<int,float>& p2)\n    {\n        return p1.second > p2.second;\n    }\n};\n\nvector<float> d(vertex);\nvector<int> parent(vertex);\n\nfor (int i = 0; i < vertex; i++){\n    d[i] = numeric_limits<float>::max();\n    parent[i] = -1;\n}\n\npriority_queue<pair<int, float>, vector<pair<int, float> >, Compare> MatQueue;\n\nd[vstart] = 0;\nMatQueue.push(make_pair(vstart, d[vstart]));\nwhile (!MatQueue.empty()){\n    int u = MatQueue.top().first;\n    if (u == vertex - 1) break;\n    MatQueue.pop();\n    for (int i = 0; i < vertex; i++){\n        if (weightmat[u][i] != 0){\n            int v = i;\n            float w = weightmat[u][i];\n            //cout << \"U \" << u << \"Number \" << i << \" Weight \" << weightmat[u][i] << endl;\n            if (d[v]> d[u] + w){\n                d[v] = d[u] + w;\n                parent[v] = u;\n                MatQueue.push(make_pair(v, d[v]));\n            }\n        }\n    }\n}\n\nvector<int> path;\npath.clear();\nint p = vertex - 1;\npath.push_back(vertex - 1);\nwhile (p != vstart)\n{\n    p = parent[p];\n    path.push_back(p);\n}\nfor (int i = path.size()-1; i >=0; i--){\n    cout << path[i] << \"->\";\n}\n```\n\n\nAnd this is code of Dijkstra's algorithm for my lists:\n\n```\ntypedef vector<vector<pair<int, float> > > Graph;\n\n    struct Compare{\n        int operator() (const pair<int, float>& p1, const pair<int, float>& p2)\n        {\n            return p1.second > p2.second;\n        }\n    };\n\n    vector<float> d(vertex);\n    vector<int> parent(vertex);\n\n    for (int i = 0; i < vertex; i++){\n        d[i] = numeric_limits<float>::max();\n        parent[i] = -1;\n    }\n\n    priority_queue<pair<int, float>, vector<pair<int, float> >, Compare> MatQueue;\n\n    d[vstart] = 0;\n    MatQueue.push(make_pair(vstart, d[vstart]));\n\n    ListNode* hand = new ListNode;\n\n    while (!MatQueue.empty()){\n        int u = MatQueue.top().first;\n        if (u == vertex - 1) break;\n        MatQueue.pop();\n        hand = NbhList[u];\n        while (hand){\n            int v = hand->number;\n            float w = hand->weight;\n            //cout << \"U \" << u << \"Number \" << v << \" Weight \" << w << endl;\n            hand = hand->next;\n            if (d[v] > d[u] + w){\n                d[v] = d[u] + w;\n                parent[v] = u;\n                MatQueue.push(make_pair(v, d[v]));\n            }\n        }\n    }\n\n\n    vector<int> path;\n    path.clear();\n    int p = (vertex-1);\n    path.push_back(p);\n    while (p != vstart)\n    {\n        p = parent[p];\n        path.push_back(p);\n    }\n    cout << endl << endl;\n    for (int i = path.size() - 1; i >= 0; i--){\n        cout << path[i] << \"->\";\n    }\n```\n\n\nAs I said, they are almost identical. Only difference:\n\n```\nMatQueue.pop();\n        hand = NbhList[u];\n        while (hand){\n            int v = hand->number;\n            float w = hand->weight;\n            //cout << \"U \" << u << \"Number \" << v << \" Weight \" << w << endl;\n            hand = hand->next;\n            if (d[v] > d[u] + w){\n                d[v] = d[u] + w;\n                parent[v] = u;\n                MatQueue.push(make_pair(v, d[v]));\n            }\n        }\n```\n\n\nAnd:\n\n```\nMatQueue.pop();\n        for (int i = 0; i < vertex; i++){\n            if (weightmat[u][i] != 0){\n                int v = i;\n                float w = weightmat[u][i];\n                //cout << \"U \" << u << \"Number \" << i << \" Weight \" << weightmat[u][i] << endl;\n                if (d[v]> d[u] + w){\n                    d[v] = d[u] + w;\n                    parent[v] = u;\n                    MatQueue.push(make_pair(v, d[v]));\n                }\n            }\n        }\n```\n\n\nMy problem is - they give me sometimes different outputs and I have no idea why.\nCould you help me find my problem?\n    ", "Answer": "\r\nOne possible bug is that in your ```\nListNode```\n struct:\n\n```\nstruct ListNode{    \n        int number;             \n        int weight;         \n        ListNode* next;             \n        ListNode(){                         \n            number = weight = 0;\n            next = 0;\n        }\n    };\n```\n\n\n```\nweight```\n is an ```\nint```\n, but your weights are ```\nfloat```\ns according to the rest of your code, which might result in unwanted truncation.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm pseudocode\r\n                \r\nI'm trying to write Dijkstra's algorithm in C++, and there are countless examples on the internet but I just can't seem to grasp how the examples work. I'd rather do it in a way that makes sense to me so I can understand the algorithm better. I know how the algorithm itself should work, and I have written some code. I was wondering if someone could point out the flaw in my thought process. I'm choosing to represent my graph as an edge list. I'll write in pseudocode because my actual code is a huge mess:\n\n```\nclass Node{\n   vector<node> linkVector;           //links to other nodes, generated at random\n   int cost;                     //randomly generated by constructor\n   bool visited = false;\n}\n\nvector<node> edgelist;           //contains all nodes\n\n\nint main(){\n   create n Nodes\n   add all nodes to edgeList\n   for each node {\n      randomly add WEIGHT nodes to linkVector\n   }\nfindPath(initialNode)\n}\n\nint findPath(Node start, node want, int cost=0){   //returns cost from src to dest\nif(start==want) return cost;\nif(every node has been visited) return 0;        //this is in case of failure\nNode result = getMinimumCost()    //finds node in linkVector with least cost\nresult.visited(true)  //so we don't get stuck in a loop\nfindPath(result, want, result.getCost() + cost);  //recursive call\n}\n```\n\n\nVia recursion, I'm trying to explore all the nodes until I find the one I'm looking for, then return and ride the cascading returns back up to the top of the function call stack, all the while adding up the total cost.\n\nPerformance doesn't really matter, but if using recursion makes it much harder than it needs to be, I am open to rewriting my code.\n    ", "Answer": "\r\nDijkstra's algorithm isn't recursive. A recursive algorithm would end up being depth-first whereas Dijkstra's algorithm is a breadth-first search.\n\nThe central idea is that you have a priority queue of unvisited nodes. Each iteration you pull the node with the shortest distance off of the front of the queue and visit it. Then you update the distances to each of its unvisited neighbors.\n\nA queue-based algorithm such as this does not lend itself to a recursive implementation. The search does not explore one path to exhaustion before it tries an alternate path as a depth-first search would do. It explores many paths simultaneously, only exploring them as long as they are the cheapest path. As soon as the current path is no longer the cheapest it moves on to another path. Recursion doesn't let you \"jump\" from path to path.\n\nYou can see this behavior in the graphic from the Wikipedia article.\n\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Shortest path using Dijkstra's algorithm\r\n                \r\nI'm currently reviving an old homework assignment, where I'm writing a program that among other functions, involves finding the shortest path in a graph using Dijkstra's algorithm. \n\nI think I've got it right for the most part, but I keep getting ```\nNullPointerException```\n at line 58 when executing ```\nif(currentNode.getAktuell())```\n.\n\nI've been trying several solutions back and forth but can't seem to figure out what is wrong but ```\nprioQueue.poll();```\n returns ```\nnull```\n when the queue is empty. I've tried to handle that last ```\ncurrentNode```\n that eventually turns into null but have not been able to find a working solution, so I'm starting to think that I've missed out on something here.\n\nI would really appreciate it if someone familiar with dijkstras algorithm could help me out here. There's probably a better solution to the algorithm but I only want help with finding out what is wrong with the one I've written, and not \"the answer\" using someone else's algorithm.\n\n```\npublic static List<String> shortestPath(Graph<String> graph, String från, String till){\n\n    //if(!pathExists(graph, från, till))\n    //return null;\n\n    PriorityQueue<DjikstraObjekt<String>> prioQueue = new PriorityQueue<DjikstraObjekt<String>>();\n    LinkedHashMap<String, DjikstraObjekt<String>> samling = new LinkedHashMap<String, DjikstraObjekt<String>>();\n\n    for(String bla : graph.getNodes())\n        samling.put(bla, new DjikstraObjekt<String>(bla, Integer.MAX_VALUE, null, false));\n    samling.get(från).updateVikt(0);\n    prioQueue.add(samling.get(från));\n\n    while(!samling.get(till).getAktuell())\n    {\n\n        DjikstraObjekt<String> currentNode = prioQueue.poll();\n        if(currentNode==null)\n            break;\n        if(currentNode.getAktuell())\n            continue;\n\n\n        currentNode.aktuellNod();\n\n        for(ListEdge<String> edge : graph.getEdgesFrom(currentNode.getNode()))\n        {\n            System.out.println(\"get edges from\");\n            int nyVikt = edge.getVikt() + currentNode.getVikt();\n            DjikstraObjekt<String> toNode = samling.get(edge.getDest());\n            if(!toNode.getAktuell() && nyVikt < toNode.getVikt()) {\n                toNode.updateVikt(nyVikt);\n                toNode.setFrån(currentNode.getNode());\n                prioQueue.add(toNode);\n            }\n        }\n\n    }       \n\n    List<String> djikstaList = new ArrayList<String>();\n    for(int i=0;i<samling.size();i++){\n        if(samling.get(i).getNode()!=från){\n            System.out.println(samling.get(i).getNode());\n            djikstaList.add(samling.get(i).getNode());\n        }       \n    }\n\n    return djikstaList;\n}\n\n\npublic class DjikstraObjekt<E> implements Comparable<DjikstraObjekt<E>> {\n    private E nod;\n    private int vikt;\n    private E frånNod;\n    private boolean aktuellNod=false;\n\n    public DjikstraObjekt(E nod, int vikt, E frånNod, boolean aktuellNod){\n\n        this.nod=nod;\n        this.vikt=vikt;\n        this.frånNod=frånNod;\n        this.aktuellNod=aktuellNod;\n\n    }\n    public E getNode() {\n        return nod;\n    }\n    public void updateVikt(int nyvikt){\n        vikt=nyvikt;\n    }\n    public int getVikt() {\n        return vikt;\n    }\n    public boolean getAktuell() {\n        return aktuellNod;\n    }\n    public void aktuellNod(){\n        aktuellNod=true;\n    }\n    public void setFrån(E från)\n    {\n        frånNod = från;\n    }\n    public int compareTo(DjikstraObjekt<E> other) {\n        return getVikt() - other.getVikt();\n    }\n}\n```\n\n\nHeres my listEdge class:\n\n```\npublic class ListEdge<E> {\n\n    private E dest;\n    private String namn;\n    private Integer vikt;\n\n\n    public ListEdge(E dest, String namn, Integer vikt){\n        this.dest=dest;\n        this.namn=namn;\n        this.vikt=vikt;\n\n    }\n\n    public E getDest(){\n        return dest;\n    }\n    public void ändraVikt(Integer nyVikt){\n        if(vikt<0)\n            throw new IllegalArgumentException();\n        vikt=nyVikt;\n\n        }\n    public String getNamn(){\n        return namn;\n    }\n     public int compareTo(ListEdge other) {\n         return this.vikt.compareTo(other.getVikt());\n }\n\n    public int getVikt(){\n        return vikt;\n    }\n    public String toString(){\n        return \"till \" + dest + \" med \" + namn +\" \"+ vikt;\n    }\n}\n```\n\n\nThese should be the relevent methods from my ListGraph class:\n\n```\npublic List<E> getNodes(){\n    List<E> temp = new ArrayList<E>();\n    for(E test : noder.keySet()){\n        temp.add(test);\n\n    }\nreturn temp;\n}\n\npublic List<ListEdge<E>> getEdgesFrom(E nod) {\n        List<ListEdge<E>> temp = new ArrayList<ListEdge<E>>();\n        if(noder.containsKey(nod)){\n            try{\n                for(Map.Entry<E, List<ListEdge<E>>> test : noder.entrySet()){\n                    if(test.getKey().equals(nod)){\n                        System.out.println(nod+\" \"+test.getKey());\n                        for(ListEdge<E> e: test.getValue()){\n                            temp.add(e);\n                    }\n                }\n            }\n        }\n            catch(NoSuchElementException E){\n\n            }\n\n        }\n        return temp;\n    }\n```\n\n    ", "Answer": "\r\nI couldn't reconstruct the NullPointerException you told us about. As Leandro pointed out, the problem might lay with your implementation of ListEdge and Graph.\n\nI did an implementation of both classes myself to test your code.\n\nThe only problem I could find was in the end where you create the result list:\n\n```\nfor(int i=0;i<samling.size();i++){\n        if(samling.get(i).getNode()!=från){\n```\n\n\nThis will always Result in a ```\nNullPointerException```\n because ```\nget()```\n expects a key and in your case that's a ```\nString```\n, not an ```\nint```\n. To iterate over the Map use something like\n\n```\nList<String> djikstaList = new ArrayList<String>();\nfor(String key : samling.keySet()){\n    if(samling.get(key).getNode()!=från){\n        System.out.println(samling.get(key).getNode());\n        djikstaList.add(samling.get(key).getNode());\n    }       \n}\n```\n\n\nFurthermore, i assume you wan't to return the actual path from ```\nfrom```\n to ```\nto```\n so you would need to add a getter ```\ngetFrån()```\n to ```\nDijkstraObjekt```\n and then build up the list like this:\n\n```\n   String fromNode = samling.get(to).getNode();\n   djikstaList.add(to);\n   while(fromNode != from){   \n       fromNode = samling.get(fromNode).getFrån();\n       djikstaList.add(fromNode);\n   }\n```\n\n\nAfter this the List will contain the complete path (including Start and End node) in reverse order.\n\nIf wanted, I can post all of my classes I used for testing/debugging.\n\nCheers\ntannerli\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm pseudocode \"U\" symbol\r\n                \r\nI'm currently trying to follow pseudocode for Dijkstra's Algorithm, but I'm having difficulty understand what one of the lines means.\n\n```\nDijkstrasAlgorithm(G, w, s)\n    InitalizeSingleSource(G, s)\n    S = 0\n    Q = G.V\n    while Q != 0\n        u = ExtractMin(Q)\n        S = S∪{u}\n        for each vertex v ∈ G.Adj[u]\n            Relax(u, v, w)\n```\n\n\nThis part right here \"S = S∪{u}\" is what's confusing me. I'm not sure what S is supposed to be equal to. Could someone explain? Thanks!\n    ", "Answer": "\r\nThat’s the set union operator. S here is the set of all nodes for which the shortest path has been computed, and this line means “add the node u to that set.”\n\nMechanically, S ∪ {u} is the set consisting of everything already in S, plus the node u. That’s why S = S ∪ {u} means to add u to S.\n\n(As a note, I think the pseudocode has a typo in where S was declared. You probably meant to initialize it to the empty set ∅ rather than the number 0.)\n\nDijkstra’s algorithm is a pretty tough one to understand purely from pseudocode. I recommend checking out a tutorial somewhere so that you have a high-level intuition for what’s going on. It’s much easier to understand this pseudocode by mapping the contents onto your conceptual understanding.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm using the priority queue\r\n                \r\nSo I am trying to implement Dijkstra's algorithm using the priority queue data structure in java. Since  comparable operator in java cannot compare two variables, so i need to \"modify its ```\nComparator```\n. How do I modify it ?\n\n```\n while(!Q.isEmpty()){\n         int index = Q.peek().edge;\n         long d = Q.peek().dis;\n         Q.remove();\n\n         if(d!=D[index]) continue; // HERE I AM CHECKING IF IT ALREADY PROCEEDED OR NOT\n\n         for(int i=0;i<maps[index].size();i++){\n               int e = maps[index].get(i).edge;\n                d =  maps[index].get(i).dis;\n                if(D[e]>D[index]+d){\n                    D[e]= D[index]+d;\n                    Q.add(new Node(e,D[e])); // NEED TO MODIFY\n                }\n         }\n     }\n```\n\n\nThen i came across this code:\n\n```\n while (!q.isEmpty()) {\n      long cur = q.remove();\n      int curu = (int) cur;\n      if (cur >>> 32 != prio[curu])\n        continue;\n      for (Edge e : edges[curu]) {\n        int v = e.t;\n        int nprio = prio[curu] + e.cost;\n        if (prio[v] > nprio) {\n          prio[v] = nprio;\n          pred[v] = curu;\n          q.add(((long) nprio << 32) + v);\n        }\n```\n\n\nHow  ```\nq.add(((long) nprio << 32) + v);```\n and ```\ncur >>> 32 != prio[curu]```\n statements works. Please HElp.\n    ", "Answer": "\r\nJava's Priorityqueue sorts according to the natural ordering if no comparator is given.\n\nYou either need to:\n\n\nimplement compareTo in your Node class\ncreate a Comparator that compares your nodes according to priority (priority = distance from start for Dijkstra)\n\n\nThe second code you showed uses the upper 32 bits of a long to store the priority, thereby making the natural order reflect the distance from start.\n\nBasically, the code is 100% the same as yours, with the difference being the data structure. You use a class, the second code uses a long to embed two integers (node id and distance/priority).\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Segmentation fault in dijkstra's algorithm\r\n                \r\nI am writing a c++ program to code for dijkstra's algorithm. Here is the code.\n\n```\n#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\nclass vertex;\nclass node\n{\npublic:\nint value;\n//bool exp=false;\nchar c;\n};\nclass edge\n{\npublic:\n    vertex* head;\n    vertex* tail;\n    int length;\n    edge(vertex*h,vertex* t, int l)\n    {\n        head=h;\n        tail=t;\n        length=l;\n    }\n};\nclass vertex:public node\n{\npublic:\n    vector<edge*> a;\n    vertex& operator|(vertex &p)\n    {\n        int l;\n        cout<<\"Give the length of edge \"<<this->c<<p.c<<endl;\n        cin>>l;\n        edge q(&p,this,l);\n        a.push_back(&q);\n    }\n    vertex(char a)\n    {\n        c=a;\n    }\n};\nint main()\n{\n    vertex e('e');\n    vertex d('d');\n    vertex b('b');\n    vertex c('c');\n    vertex a('a');\n    vertex s('s');\n    s.value=1;\n    a.value=2;\n    b.value=3;\n    c.value=4;\n    d.value=5;\n    e.value=6;\n    s|a;\n    s|b;\n    a|c;\n    b|c;    \n    b|d;\n    c|d;\n    c|e;\n    d|e;\n    cout<<\"4\";\n    map <char ,int >A;\n    vector<edge*>::iterator minin;\n    vector<edge*>::iterator j;\n    int min=0;\n    vector<vertex*> X;\n    X.push_back(&s);\n    A['s']=0;\n    vector<vertex*>::iterator i=X.begin();\n    for(; i<X.end(); i++)\n    {\n        cout<<\"1\";\n        j=((*i)->a).begin();\n        for(; j<((*i)->a).end(); j++)\n        {\n            cout<<\"2\";\n            if((*j)->length+A[((*j)->tail)->c]>min)\n            {\n                cout<<\"3\";\n                minin=j;\n                min=(*j)->length+A[((*j)->tail)->c];\n            }\n\n        }\n\n    }\n    X.push_back((*minin)->head);\n    A[((*minin)->tail)->c]=min;\n    cout<<((*minin)->head)->value;\n\n}\n```\n\n\nThe program returns a segmentation fault. I have used various ```\ncout```\n statements to check where the fault occured but nothing is printed in console. However, I am able to input the edge length in the console but after giving the input it directly gives segmentation fault.\n    ", "Answer": "\r\nIn\n\n```\na.push_back(&q);\n```\n\n\nyou are storing the address of a local object, which will cease to exist once the function terminates.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "implementing Dijkstra's Algorithm using priority queue\r\n                \r\nI'm implementing Dijkstra's Algorithm using priority queue, I want a function to remove an element from the heap but I can only send it the vertex index from the Dijkstra's main and I can't find its position on the heap and I can't afford to do a binary search. Any ideas?\n\n```\npublic class MinHeap {\nVertex[] Heap = null; // Vertex array\nint Lenght;\nint Size;\nint[] elementsPostion; // Array of Index of Vertices\n\nprivate int parent(int i) {\n    if (i % 2 == 0)\n        return (i / 2) - 1;\n    else\n        return i / 2;\n}\n\nprivate int leftChild(int i) {\n    return (2 * i) + 1;\n}\n\nprivate int rightChild(int i) {\n    return (2 * i) + 2;\n}\n\n// Initialize PQ\npublic MinHeap(int len) {\n    Lenght = len;\n    Size = 0;\n    Heap = new Vertex[Lenght];\n    elementsPostion = new int[Lenght];\n}\n\n// Extract Min\npublic Vertex ExtractMin() {\n\n    Vertex v;\n    v = Heap[0]; // min = index of min\n    elementsPostion[Heap[0].index] = -1;\n    Heap[0] = Heap[Size - 1];\n    elementsPostion[Heap[0].index] = 0;\n    Size = Size - 1;\n    minHeapify(0);\n    return v;\n}\n\n// ----------------------------\n// Sort Inside PQ\npublic void minHeapify(int pos) {\n    int L;\n    int R;\n    L = leftChild(pos);\n    R = rightChild(pos);\n    while (pos < Size\n            && (Heap[L].minDistance < Heap[pos].minDistance || Heap[R].minDistance < Heap[pos].minDistance)) {\n        Vertex tmp;\n        if (Heap[L].minDistance < Heap[R].minDistance) {\n            elementsPostion[Heap[L].index] = pos;\n            elementsPostion[Heap[pos].index] = L;\n\n            tmp = Heap[L];\n            Heap[L] = Heap[pos];\n            Heap[pos] = tmp;\n            pos = L;\n        } else {\n            elementsPostion[Heap[R].index] = pos;\n            elementsPostion[Heap[pos].index] = R;\n\n            tmp = Heap[R];\n            Heap[R] = Heap[pos];\n            Heap[pos] = tmp;\n            pos = R;\n        }\n        L = leftChild(pos);\n        R = rightChild(pos);\n        /*\n         * if(pos< Size && Heap[L].minDistance <Heap[pos].minDistance)\n         * min=L.index; else min=pos; if(R.index<=Size &&Heap[R]<Heap[pos])\n         * min=R.index; if(min !=pos) { int tmp = Heap[pos]; Heap[pos] =\n         * Heap[min]; Heap[min] = tmp; minHeapify(min); }\n         */\n    }\n\n    // swap in P.Q with Swapping in arrayofVertNum\n}\n\n\n// insert vertex\npublic void insertVertex(Vertex element) {\n    Heap[Size] = element; // size = number of verticies\n    HeapDecreaseKey(Size, element); //\n    Size++;\n}\n\n// Compare when insert with Parents\npublic void HeapDecreaseKey(int index, Vertex key) // bta5od el element ele hy3mlo insert ,,\n{ \n    // index=size , key=element // add in last\n    // Heap[index]=key; //add in last\n    Vertex v = new Vertex(key.index, key.xPos, key.yPos, key.minDistance);\n\n    //int swap;\n    boolean b = false;\n    while (index > 0\n            && Heap[parent(index)].minDistance > Heap[index].minDistance) {\n        b = true;\n        elementsPostion[Heap[parent(index)].index] = index;\n        elementsPostion[Heap[index].index] = parent(index);\n\n        Vertex tmp = Heap[parent(index)];\n        Heap[parent(index)] = Heap[index];\n        Heap[index] = tmp;\n\n        index = parent(index);\n    }\n    if (b == false)\n        elementsPostion[key.index] = index;\n\n    // Swap in array\n}\n\n// check if PQ is empty\npublic boolean isEmpty() {\n    return Heap == null;\n}\n\npublic void display() {\n\n\n\n    for (int i = 0; i < Size; i++) {\n        System.out.print(Heap[i].minDistance);\n    }\n    System.out.println();\n}\n}\n```\n\n    ", "Answer": "\r\nKeep track of the vertex in the heap using simple index array ```\nPositions[Vertex]```\n and record ```\n(Vertex,Distance)```\n as element in heap array. But implementing  only this is not enough because you need to update positions of vertex very time you do swap operation on heap in any routine.  \n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Unvisited nodes in Dijkstra's algorithm?\r\n                \r\nIn the priority queue implementation of Dijkstra's Algorithm we remove the node at the top, mark it as visited and update the distance values of all the vertices adjacent to the top.\n\nIn doing so do we need to check whether the vertices adjacent to the top have already been visited or do we update it for all the vertices irrespective of if they have been visited or not?\n    ", "Answer": "\r\nSuppose current node removed from priority queue is ```\ncur```\n then we need to check that from cur node we can find any edge that can reduce distance of any adjacency node then we need to update the distance.\n\nNote that when node is removed from priority queue that means we have already found the minimum distance for that node from the source vertex.I think you are confused a bit, so go over the algorithm once again.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Is Dijkstra's algorithm for directed or undirected graphs?\r\n                \r\nI keep trying to google this, but the results I'm finding are just adding to my confusion. It seems that it can be possibly used for both? If so, which is it designed for by default and what needs to change to make it work the non-default way (whether that be directed or undirected)? \n\nEdit: for reference, I had a problem last semester where I was given a list like this (airports):\n\n```\nAER,KZN,1.8835\nASF,KZN,1.3005\nASF,MRV,1.1204\nCEK,KZN,1.9263\nCEK,OVB,1.6733\nDME,KZN,1.7892\nDME,NBC,2.2319\nDME,UUA,2.3786\nEGO,KGD,1.4649\nEGO,KZN,1.2603\nGYD,NBC,2.0755\n```\n\n\nI was told it was directed, and asked to find the shortest path. I put it into a Dijkstra's algorithm I found on Github (it was an open-computer midterm so we didn't have nearly enough time to write the algorithm from scratch) and my professor said the shortest path it returned was incorrect and that it was not even a possible path because the list was supposed to be directed. I wasn't sure if I was supposed to then modify the algorithm or the list to make this correction. It ended up being the case that the 2nd shortest path it returned was actually the directed shortest path, but I'm still wondering what the problem was.\n    ", "Answer": "\r\nIt can be applied to both. Here is why:\n\nAn undirected graph is basically the same as a directed graph with bidirectional connections (= two connections in opposite directions) between the connected nodes. \n\nSo you don't really have to do anything to make it work for an undirected graph. You only need to know all of the nodes that can be reached from every given node through e.g. an adjacency list.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Assess complexity for Dijkstra's algorithm\r\n                \r\nI am trying to assess the complexity of my python implementation of Dijkstra's algorithm by creating both a loop based and time based big(o) plot.\n\ni understand that from my bid input dataset - which in my case is a CSV. file with three rows: city1, city2, distance, i have to randomly select a series of smaller data sets to run my algorithm on.\n\nhow can i randomly select let's say: 5 rows, then 10 rows, 15 rows, 20 rows?\n    ", "Answer": "\r\nYou can use ```\nrandom.sample```\n. If you have a list then you can use it like this:\n\n```\nimport random\nrows = [f'city1,city2,{i}\\n' for i in range(5)] # equal to f.readlines()\n\nsample_size = 5 # or whatever you need\nsamples = random.sample(rows, sample_size)\n\nfor sample in samples:\n    city1, city2, distance = sample.strip().split(',')\n    distance = int(distance) # distance is a string because of csv, convert it to a number\n    # do your thing here\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm from Adjacency Matrix\r\n                \r\nI have an adjacency matrix of a directed acyclic graph represented by a 2D array:\n\n```\n[[0, 4, 3, 0]\n [0, 0, 0, 1]\n [0, 3, 0, 1]\n [2, 0, 0, 0]]\n```\n\n\nIs there a Python module or a quick code snippet that can run Dijkstra's Algorithm on this data type? The Python cookbook uses a priority dictionary I believe, but I'd really like to keep it in a 2D array. Any help would be appreciated.\n    ", "Answer": "\r\nnetworkx might fit your needs:\n```\nimport networkx as nx\nimport numpy as np\nA = np.array([[0, 4, 3, 0],\n              [0, 0, 0, 1],\n              [0, 3, 0, 1],\n              [2, 0, 0, 0]])\nG = nx.from_numpy_matrix(A, create_using=nx.DiGraph())\nprint(nx.dijkstra_path(G, 0, 1))\n```\n\nSee also: networkx.dijkstra_path\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Implementing Dijkstra's algorithm in Neo4j\r\n                \r\nI am very new to Neo4j. Could someone kindly explain to me (step-by-step please) how I could implement the Dijkstra's algorithm to find the shortest path between two nodes? Is it possible to simply do it using Cypher?\n\nI already tried the shortestPath algorithm, but it is very slow:\n\n```\nMATCH (from: Location {LocationName:\"x\"}), (to: Location {LocationName:\"y\"}) , path = (from)-[:CONNECTED_TO*1..5]->(to)\nRETURN path AS shortestPath, \n    reduce(distance = 0, r in relationships(path)| distance+toInt(r.Distance)) \nAS totalDistance\n    ORDER BY totalDistance ASC\n    LIMIT 1\n```\n\n\nmy nodes are: Location with properties LocationID and LocationName\nmy relationships are: CONNECTED_TO with property Distance\n\nI have more than 6000 relationships\n\nplease note in the code above that I have limited to 1..5\nwhen I do not define this limit, the query does not give any results (keeps on executing)\n\nthanks\n    ", "Answer": "\r\nYes it is possible with Cypher or with a dedicated endpoint of the Neo4j ReST API.\n\nBTW, the examples from the Cypher Neo4j documentation are self explaining :\n\nhttp://neo4j.com/docs/milestone/query-match.html#_shortest_path\n\nTo get the shortestPath between two nodes : \n\n```\nMATCH (from: Location {LocationName:\"x\"}), (to: Location {LocationName:\"y\"}) , \npath = shortestPath((from)-[:CONNECTED_TO*]->(to))\nRETURN path\n```\n\n\nIf you want to get all the shortest\n\n```\nMATCH (from: Location {LocationName:\"x\"}), (to: Location {LocationName:\"y\"}) , \npaths = allShortestPaths((from)-[:CONNECTED_TO*]->(to))\nRETURN paths\n```\n\n\nIf you want to order by the length (number of hops) of the paths in descending order :\n\n```\nMATCH (from: Location {LocationName:\"x\"}), (to: Location {LocationName:\"y\"}) , \npaths = allShortestPaths((from)-[:CONNECTED_TO*]->(to))\nRETURN paths\nORDER BY length(paths) DESC\n```\n\n\nIf you to to get the shortestPath + the sum of the relationship distance property :\n\n```\nMATCH (from: Location {LocationName:\"x\"}), (to: Location {LocationName:\"y\"}) , \npath = shortestPath((from)-[:CONNECTED_TO*]->(to))\nWITH REDUCE(dist = 0, rel in rels(path) | dist + rel.distance) AS distance, p\nRETURN p, distance\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm Implementation\r\n                \r\nSo I'm writing a JavaScript implementation of Dijkstra's Algorithm.\nI've read a lot from the Wikipedia page, which has helped me translate the steps into code. I've also read this Stack Overflow question, which is part of my question.\n\nFrom A, the only path is B, this gives us\nO => AB = 12;\nO => C = 7\nC is now lowest distance, and is the new current node\nO => CD = 8\nSince D is destination and 8 < 12, the route CD is chosen.\n\nHow do you implement this decision into code? Right now, my script bases what node to choose on which ones are adjacent to the current one, does every decision need to be run through this new kind of evaluation?\nBy the way, here is my (messy) code.\n    ", "Answer": "\r\n\n  my script bases what node to choose on which ones are adjacent to the current one\n\n\nNo. Your ```\nconnectedNodes```\n list (sorted by distance) should be global, not only for the current node.\n\nThen, for the first (least distance) node, add all non-visited neighbors to the list, still sorted by distance. Mark the current node visited and go on with the next least-distance-non-visited node.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Finding the starting vertex for Dijkstra's algorithm?\r\n                \r\nImagine I am implementing Dijkstra's algorithm at a park. There are points and connections between those points; these specify valid paths the user can walk on (e.g. sidewalks).\n\nNow imagine that the user is on the grass (i.e. not on a path) and wants to navigate to another location. The problem is not in Dijkstra's algorithm (which works fine), the problem is determining at which vertex to begin.\n\nHere is a picture of the problem: (ignore the dotted lines for now)\n\n\n\nBlack lines show the edges in Dijkstra's algorithm; likewise, purple circles show the vertices. Sidewalks are in gray. The grass is, you guessed it, green. The user is located at the red star, and wants to get to the orange X.\n\nIf I naively look for the nearest vertex and use that as my starting point, the user is often directed to a suboptimal path, that involves walking further away from their destination at the start (i.e. the red solid path).\n\nThe blue solid path is the optimal path that my algorithm would ideally come up with.\n\nNotes:\n\n\nAssume no paths cross over other paths.\nWhen navigating to a starting point, the user should never cross over a path (e.g. sidewalk).\nIn the image above, the first line segment coming out of the star is created dynamically, simply to assist the user. The star is not a vertex in the graph (since the user can be anywhere inside the grass region). The line segment from the star to a vertex is simply being displayed so that the user knows how to get to the first valid vertex in the graph.\n\n\nHow can I implement this efficiently and correctly?\n\n\n\nIdea #1: Find the enclosing polygon\n\nIf I find the smallest polygon which surrounds my starting point, I can now create new paths for Dijkstra's algorithm from the starting point (which will be added as a new vertex temporarily) to each of the vertices that make up the polygon. In the example above, the polygon has 6 sides, so this would mean creating 6 new paths to each of its vertices (i.e. the blue dotted lines). I would then be able to run Dijkstra's algorithm and it would easily determine that the blue solid line is the optimal path.\n\nThe problem with this method is in determining which vertices comprise the smallest polygon that surrounds my point. I cannot create new paths to each vertex in the graph, otherwise I will end up with the red dotted lines as well, which completely defeats the purpose of using Dijkstra's algorithm (I should not be allowed to cross over a sidewalk). Therefore, I must take care to only create paths to the vertices of the enclosing polygon. Is there an algorithm for this?\n\nThere is another complication with this solution: imagine the user now starts at the purple lightning bolt. It has no enclosing polygon, yet the algorithm should still work by connecting it to the 3 points at the top right. Again, once it is connected to those, running Dijkstra's is easy.\nUpdate: the reason we want to connect to one of these 3 points and not walk around everything to reach the orange X directly is because we want to minimize the walking done on unpaved paths. (Note: This is only a constraint if you start outside a polygon. We don't care how long you walk on the grass if it is within a polygon).\n\nIf this is the correct solution, then please post its algorithm as an answer.\n\nOtherwise, please post a better solution.\n    ", "Answer": "\r\nYou can start off by running Dijkstra from the target to find its distance to all vertices.\n\nNow let's consider the case where you start \"inside\" the graph on the grass. We want to find all vertices that we can reach via a straight line without crossing any edge. For that we can throw together all the line segments representing the edges and the line segments connecting the start point to every vertex and use a sweep-line algorithm to find whether the start-vertex lines intersect any edge. \n\nAlternatively you can use any offline algorithm for planar point location, those also work with a sweep line. I believe this is in the spirit of the more abstract algorithm proposed in the question in that it reports the polygon that surrounds the point.\n\nThen we just need to find the vertex whose connection line to the start does not intersect any edge and the sum d(vertex, target) + d(vertex, start) is minimum.\n\nThe procedure when the vertex is outside the graph is somewhat underspecified, but I guess the exact same idea would work. Just keep in mind that there is the possibility to walk all around the graph to the target if it is on the border, like in your example.\n\nThis could probably be implemented in O((n+m) log m) per query. If you run an all-pairs shortest path algorithm as a preprocessing step and use an online point location algorithm, you can get logarithmic query time at the cost of the space necessary to store the information to speed up shortest path queries (quadratic if you just store all distance pairs). \n\nI believe simple planar point location works just like the sweep line approaches, only with persistent BSTs to store all the sweepline states.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm in Java\r\n                \r\nI've been trying to use Dijkstra's Algorithm to find the shortest path in a set of vertices in Java. I've found code for when people have preset values, but I haven't managed to find anything involving files that have matrices read in. Here's the code I currently have:\n\n```\nimport java.util.*;\n\nclass Vertex implements Comparable<Vertex>\n{\n    public final String name;\n    public Edge[] adjacencies;\n    public double minDistance = Double.POSITIVE_INFINITY;\n    public Vertex previous;\n    public Vertex(String argName) { name = argName; }\n    public String toString() { return name; }\n    public int compareTo(Vertex other)\n    {\n        return Double.compare(minDistance, other.minDistance);\n    }\n\n}\n\n\nclass Edge\n{\n    public final Vertex target;\n    public final double weight;\n    public Edge(Vertex argTarget, double argWeight)\n    { target = argTarget; weight = argWeight; }\n}\n\npublic class Dijkstra\n{\n    public static void computePaths(Vertex source)\n    {\n        source.minDistance = 0.;\n        PriorityQueue<Vertex> vertexQueue = new PriorityQueue<Vertex>();\n    vertexQueue.add(source);\n\n    while (!vertexQueue.isEmpty()) {\n        Vertex u = vertexQueue.poll();\n\n            // Visit each edge exiting u\n            for (Edge e : u.adjacencies)\n            {\n                Vertex v = e.target;\n                double weight = e.weight;\n                double distanceThroughU = u.minDistance + weight;\n                if (distanceThroughU < v.minDistance) {\n                    vertexQueue.remove(v);\n\n                    v.minDistance = distanceThroughU ;\n                    v.previous = u;\n                    vertexQueue.add(v);\n                }\n            }\n        }\n    }\n\n    public static List<Vertex> getShortestPathTo(Vertex target)\n    {\n        List<Vertex> path = new ArrayList<Vertex>();\n        for (Vertex vertex = target; vertex != null; vertex = vertex.previous)\n            path.add(vertex);\n\n        Collections.reverse(path);\n        return path;\n    }\n\n    public static void main(String[] args)\n    {\n        // mark all the vertices \n        Vertex A = new Vertex(\"A\");\n        Vertex B = new Vertex(\"B\");\n        Vertex D = new Vertex(\"D\");\n        Vertex F = new Vertex(\"F\");\n        Vertex K = new Vertex(\"K\");\n        Vertex J = new Vertex(\"J\");\n        Vertex M = new Vertex(\"M\");\n        Vertex O = new Vertex(\"O\");\n        Vertex P = new Vertex(\"P\");\n        Vertex R = new Vertex(\"R\");\n        Vertex Z = new Vertex(\"Z\");\n\n        // set the edges and weight\n        A.adjacencies = new Edge[]{ new Edge(M, 8) };\n        B.adjacencies = new Edge[]{ new Edge(D, 11) };\n        D.adjacencies = new Edge[]{ new Edge(B, 11) };\n        F.adjacencies = new Edge[]{ new Edge(K, 23) };\n        K.adjacencies = new Edge[]{ new Edge(O, 40) };\n        J.adjacencies = new Edge[]{ new Edge(K, 25) };\n        M.adjacencies = new Edge[]{ new Edge(R, 8) };\n        O.adjacencies = new Edge[]{ new Edge(K, 40) };\n        P.adjacencies = new Edge[]{ new Edge(Z, 18) };\n        R.adjacencies = new Edge[]{ new Edge(P, 15) };\n        Z.adjacencies = new Edge[]{ new Edge(P, 18) };\n\n\n        computePaths(A); // run Dijkstra\n        System.out.println(\"Distance to \" + Z + \": \" + Z.minDistance);\n        List<Vertex> path = getShortestPathTo(Z);\n        System.out.println(\"Path: \" + path);\n    }\n}\n```\n\n\nI need to make it be able to read in a matrix of any size in the form of a .csv file and use the algorithm to find the path.\n\nOne of the sample files looks like this:\n\n```\n0,5,0,5,0,0,0,0,0\n5,0,5,0,8,0,0,0,0\n0,5,0,0,0,1,0,0,0\n5,0,0,0,6,0,0,0,0\n0,8,0,6,0,2,0,0,0\n0,0,1,0,2,0,0,0,6\n0,0,0,0,0,0,0,0,0\n0,0,0,0,0,0,0,0,9\n0,0,0,0,0,6,0,9,0\n```\n\n\nThe file name is NineUnDirected.csv. The largest sample I have to read in has 100 vertices.\n\nI'd appreciate any help you could give me as to reading in the file and running it through the program.\n    ", "Answer": "\r\n```\nScanner scanner = new Scanner(new File(\"NineUnDirected.csv\"));\nList<Integer> matrix = new ArrayList<>();\nwhile(scanner.hasNextInt()){\n   matrix.add(scanner.nextInt());\n}\n```\n\n\nAnd then you can convert matrix in a more convenient form, if it is neccessary.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Why is it mandatory that Dijkstra's algorithm extracts min in each round?\r\n                \r\nConsider the graph is valid for applying Dijkstra's algorithm i.e. there are no negative edge weights. I'm having a difficult time convincing myself that Dijkstra's algorithm only works if the minimum distance node in each round is chosen to be extracted. What would constitute a proof that extracting anything but the minimum distance node would lead to failure of the Dijkstra's algorithm?\nI'm looking for a good argument but supporting examples are welcome. \n    ", "Answer": "\r\nIf you extract a non-minimum node, then you will have extracted a node for which the shortest distance was not known at the time of extraction. It will be computed later, but the node will not be extracted again, so you will be left with at least one wrong minimum distance at the end.\n\nExample:\n\n\n\nYou will have ```\nd[1] = 0```\n, then you will extract this since it's the only one to extract.\n\nThis will set:\n\n```\nd[3] = 3\nd[2] = 1\n```\n\n\nNow you should extract ```\n2```\n, but let's say you extract ```\n3```\n.\n\nYou will set ```\nd[4] = 4```\n.\n\nNow let's say you extract ```\n2```\n and set ```\nd[3] = 2```\n.\n\nNext, only ```\n4```\n is left to be extracted. You extract it and you're done.\n\nYou're left with a wrong value of ```\nd[4] = 4```\n instead of ```\nd[4] = 3```\n.\n\nNote that this assumes that you cannot extract a node multiple times (which you cannot in a classical Dijkstra's algorithm). If you allow for this, then what you suggest does work, but is arguably neither efficient nor Dijkstra's anymore.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm and Cycles\r\n                \r\nIt's stated in a book that \"Dijkstra's algorithm only works with Directed Acyclic Graphs\". \n\nIt appears the algorithm works for graphs with cycles too as long as there are no negative cycles. Is that correct?\n\nEdit 1:\n The book \"Grokking Algorithms\" -Aditya Bhargava. \n Chapter 7. Page 122.\n    ", "Answer": "\r\nI'm the author of Grokking Algorithms. Sorry for this error—Dijkstra's algorithm does work on graphs with cycles, as long as it is a positive weight cycle. I have updated the errata page to reflect this error. Dijkstra's doesn't work on negative weight cycles, and here's an image that explains why:\n\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Redundant Checks in Python Implementation of Dijkstra's Algorithm\r\n                \r\nEDIT: I've added some output to highlight what I believe the problem is.\nThere are so many versions of Dijkstra's Algorithm out there, and when you are learning it is hard to assess their quality.\nThe implementation below appears to be from a reputable source (https://bradfieldcs.com/algos/graphs/dijkstras-algorithm/)\nHowever, it seems that since this version doesn't keep track of visited nodes, these lines:\n```\nfor neighbor, weight in graph[current_vertex].items():\n            distance = current_distance + weight\n```\n\npotentially create a lot of unnecessary checking.\nThe output from the code below is:\n```\nNeighbor: V, weight: 6, distance: 6\nNeighbor: W, weight: 7, distance: 7\nNeighbor: U, weight: 6, distance: 12\nNeighbor: X, weight: 10, distance: 16\nNeighbor: U, weight: 7, distance: 14\nNeighbor: X, weight: 1, distance: 8\nNeighbor: W, weight: 1, distance: 9\nNeighbor: V, weight: 10, distance: 18\n{'U': 0, 'V': 6, 'W': 7, 'X': 8}\n```\n\nTo me this suggests that the algorithm is doing unnecessary work, as node ```\nU```\n becomes a neighbor multiple times, its distance is calculated as twice the distance already calculated, and therefore it is rejected. My understanding is that once a  node is processed, it no longer needs to be considered. I may be misunderstanding the algorithm, but this looks suspicious to me.\nSince keeping track of visited nodes seems integral to the definition of Dijkstra's Algorithm, is it fair to say that this particular implementation is \"not great\"? Or am I missing something?\nIt would be great to see a \"best practices\" version of Dijkstra's Algorithm in Python, preferably using the same kind of structure for the graph.\n```\nimport heapq\n\n\ndef calculate_distances(graph, starting_vertex):\n    distances = {vertex: float('infinity') for vertex in graph}\n    distances[starting_vertex] = 0\n\n    pq = [(0, starting_vertex)]\n    while len(pq) > 0:\n        current_distance, current_vertex = heapq.heappop(pq)\n\n        # Nodes can get added to the priority queue multiple times. We only\n        # process a vertex the first time we remove it from the priority queue.\n        if current_distance > distances[current_vertex]:\n            continue\n\n        for neighbor, weight in graph[current_vertex].items():\n            distance = current_distance + weight\n            print(f\"Neighbor: {neighbor}, weight: {weight}, distance: {distance}\")\n\n            # Only consider this new path if it's better than any path we've\n            # already found.\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return distances\n\n\nexample_graph = {\n    'U': {'V': 6, 'W': 7},\n    'V': {'U': 6, 'X': 10},\n    'W': {'U': 7, 'X': 1},\n    'X': {'W': 1, 'V': 10}\n}\nprint(calculate_distances(example_graph, 'U'))\n```\n\n    ", "Answer": "\r\n\nMy understanding is that once a node is processed, it no longer needs to be considered.\n\nIf you mean with \"considered\" that its distance along the path is calculated, then this is true, but also consider that comparing a distance with the best value so far is not significantly more complex than checking whether a neighbor was already visited. In either case (algorithm), a truly visited node (i.e. a node that has been popped from the heap) will never be pushed unto the heap again.\nLet's look at a variant of the algorithm where (only) the concept of \"visited\" is used to determine whether a neighbor should be put on the heap. I intentionally have tried to limit code changes, so the differences can be highlighted better:\n```\nINF = float('infinity')\ndef calculate_distances_2(graph, starting_vertex):\n    distances = {vertex: INF for vertex in graph}\n    pq = [(0, starting_vertex)]\n    while len(pq) > 0:\n        current_distance, current_vertex = heapq.heappop(pq)\n        if distances[current_vertex] != INF:  # Already visited?\n            continue\n        distances[current_vertex] = current_distance\n        for neighbor, weight in graph[current_vertex].items():\n            print(f\"Neighbor: {neighbor}, weight: {weight}, goes on heap? {distances[neighbor] == INF}\")\n            if distances[neighbor] == INF:  # Not yet visited?\n                heapq.heappush(pq, (current_distance + weight, neighbor))\n    return distances\n```\n\nSo what is different here?\n\nThe distance of a node is only set when the node is popped of the heap, and this also serves for marking a node as visited: it no longer has Infinity as associated distance. This means that :\n\nwe don't set ```\ndistances[starting_vertex] = 0```\n before the loop starts.\nwe only check whether a neighbor has been visited (implicitly, by checking ```\ndistances[starting_vertex]```\n is Infinity or not), but don't compare whether the current neighbor's distance is an improvement. This is entirely left to the heap mechanics now\n\n\nA neighbor's distance along the current path does not have to be calculated when the node was already visited.\n\n\nThe first point practically means that the second algorithm may push a node on the heap (again), while the first algorithm might not. In the worst case there is no difference, but in random cases we can expect such a difference to occur. This is because the first algorithm uses more information: when the same node is already present one or more times on the heap, the first algorithm knows the shortest distance among the traversed paths to that node, while the second algorithm \"only\" knows that this node has not yet been visited (i.e. has not yet been popped).\nConcrete example\nFor your example there is no difference. I tried with this graph:\n\n...and used the code below to make the comparison. Note that I changed your ```\nprint```\n call: I removed the output of ```\ndistance```\n (as in the second algorithm it is not yet calculated), and added one more information: whether the neighbor will be pushed on the heap or not (False/True):\n```\nimport heapq\n\nINF = float('infinity')\n\ndef calculate_distances(graph, starting_vertex):\n    distances = {vertex: INF for vertex in graph}\n    distances[starting_vertex] = 0\n\n    pq = [(0, starting_vertex)]\n    while len(pq) > 0:\n        current_distance, current_vertex = heapq.heappop(pq)\n        if current_distance > distances[current_vertex]:\n            continue\n        for neighbor, weight in graph[current_vertex].items():\n            distance = current_distance + weight\n            print(f\"Neighbor: {neighbor}, weight: {weight}, goes on heap?: {distance < distances[neighbor]}\")\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances\n\n\n### Alternative\n\ndef calculate_distances_2(graph, starting_vertex):\n    distances = {vertex: INF for vertex in graph}\n    pq = [(0, starting_vertex)]\n    while len(pq) > 0:\n        current_distance, current_vertex = heapq.heappop(pq)\n        if distances[current_vertex] != INF:\n            continue\n        distances[current_vertex] = current_distance\n        for neighbor, weight in graph[current_vertex].items():\n            print(f\"Neighbor: {neighbor}, weight: {weight}, goes on heap? {distances[neighbor] == INF}\")\n            if distances[neighbor] == INF:\n                heapq.heappush(pq, (current_distance + weight, neighbor))\n    return distances\n\n\nexample_graph = {\n    \"0\": { \"1\": 2, \"2\": 6 },\n    \"1\": { \"0\": 2, \"3\": 5 },\n    \"2\": { \"0\": 6, \"3\": 8 },\n    \"3\": { \"1\": 5, \"2\": 8, \"4\": 10, \"5\": 15 },\n    \"4\": { \"3\": 10, \"5\": 6, \"6\": 2 },\n    \"5\": { \"3\": 15, \"4\": 6, \"6\": 6 },\n    \"6\": { \"4\": 2, \"5\": 6 }\n}\n\nprint(calculate_distances(example_graph, '0'))\nprint(calculate_distances_2(example_graph, '0'))\n```\n\nI provide here the output that is generated by the first algorithm only, and mark the lines where the second algorithm has a different output:\n```\nNeighbor: 1, weight: 2, goes on heap?: True\nNeighbor: 2, weight: 6, goes on heap?: True\nNeighbor: 0, weight: 2, goes on heap?: False\nNeighbor: 3, weight: 5, goes on heap?: True\nNeighbor: 0, weight: 6, goes on heap?: False\nNeighbor: 3, weight: 8, goes on heap?: False ****\nNeighbor: 1, weight: 5, goes on heap?: False\nNeighbor: 2, weight: 8, goes on heap?: False\nNeighbor: 4, weight: 10, goes on heap?: True\nNeighbor: 5, weight: 15, goes on heap?: True\nNeighbor: 3, weight: 10, goes on heap?: False\nNeighbor: 5, weight: 6, goes on heap?: False ****\nNeighbor: 6, weight: 2, goes on heap?: True\nNeighbor: 4, weight: 2, goes on heap?: False\nNeighbor: 5, weight: 6, goes on heap?: False ****\nNeighbor: 3, weight: 15, goes on heap?: False\nNeighbor: 4, weight: 6, goes on heap?: False\nNeighbor: 6, weight: 6, goes on heap?: False\n{'0': 0, '1': 2, '2': 6, '3': 7, '4': 17, '5': 22, '6': 19}\n```\n\nThe places where the output is different (3 places) indicate where the first algorithm outputs ```\nFalse```\n and the second ```\nTrue```\n.\nConclusion\n\n\n\n\nAttribute\nFirst algorithm\nSecond algorithm\n\n\n\n\nHeap size\nBetter\nWorse\n\n\nAdditions\nWorse\nBetter\n\n\n\n\nThe heap size will in random cases be more determining for execution times, and so the the first algorithm is expected to run slightly faster.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm Java-- Distance not right\r\n                \r\nI am trying to code dijkstra's algorithm, starting at any vertex I need to show the distance and print the path of nodes. It works for vertex 2,4, and 5, but for 1 and 3 it gets messed up. It's probably something stupidly small, but I can't see it.\n\n```\npublic static void main(String[] args)\n{\n    int INF = Integer.MAX_VALUE;\n    int verticies = 5;\n    int W[][] = {{INF,7,4,6,1},\n    {0,INF,0,0,0},\n    {0,2,INF,4,0},\n    {0,0,0,INF,0},\n    {0,0,0,1,INF}};\n\n    int startNode = 1;\n    dijkstra(W,verticies,startNode-1);\n\n}\n\npublic static void dijkstra(int G[][],int n,int startnode)\n{\n    int INF = Integer.MAX_VALUE, nINF = Integer.MIN_VALUE;\n    //int cost[MAX][MAX],distance[MAX],pred[MAX];\n    //int visited[MAX],count,mindistance,nextnode,i,j;\n    int cost[][] = new int[n][n];\n    int distance[] = new int[n];\n    int pred[] = new int[n];\n    boolean visited[] = new boolean[n];\n    int count=0, mindistance=0, nextnode=0,i,j;\n\n    //pred[] stores the predecessor of each node\n    //count gives the number of nodes seen so far\n    //create the cost matrix\n    for(i=0;i<n;i++)\n        for(j=0;j<n;j++)\n            if(G[i][j]==0)\n                cost[i][j]=INF;\n            else\n                cost[i][j]=G[i][j];\n\n    //initialize pred[],distance[] and visited[]\n    for(i=0;i<n;i++)\n    {\n        distance[i]=cost[startnode][i];\n        pred[i]=startnode;\n        visited[i]=false;\n    }\n\n    distance[startnode]=0;\n    visited[startnode]=true;\n    count=1;\n\n    while(count<n-1)\n    {\n        mindistance=INF;\n\n        //nextnode gives the node at minimum distance\n        for(i=0;i<n;i++)\n            if(distance[i]<mindistance&&!visited[i])\n            {\n                mindistance=distance[i];\n                nextnode=i;\n            }\n\n        //check if a better path exists through nextnode\n        visited[nextnode]=true;\n        for(i=0;i<n;i++)\n            if(!visited[i])\n                if(mindistance+cost[nextnode][i]<distance[i])\n                {\n                    distance[i]=mindistance+cost[nextnode][i];\n                    pred[i]=nextnode;\n                }\n        count++;\n    }\n\n    //print the path and distance of each node\n    for(i=0;i<n;i++)\n        if(i!=startnode)\n        {\n            if(distance[i] == INF || distance[i] < 0){\n                System.out.print(\"\\nNo edge exists between node \"+(startnode+1)+\" and node \"+(i+1));\n            } else {\n                System.out.format(\"\\nDistance of node %d = %d\", (i + 1), distance[i]);\n                System.out.format(\"\\nPath = %d\", (i + 1));\n\n                j = i;\n                do {\n                    j = pred[j];\n                    System.out.format(\"<-%d\", (j + 1));\n                } while (j != startnode);\n            }\n        }\n}\n```\n\n    ", "Answer": "\r\nI don’t know exactly how, but you are somehow getting ```\nINF```\n into your calculations. My suspicion goes to the line ```\ndistance[i]=mindistance+cost[nextnode][i];```\n, but it may not be the only culprit, I have not checked. When ```\nmindistance```\n is 1 (or greater) and cost is ```\nInteger.MAX_VALUE```\n, you get an arithmetic overflow and the result gets negative. Further behaviour, I have not predicted, but it’s not as expected.\n\nWhen in the two places you define ```\nINF```\n I change the value to 1,000,000, I get the following output from your program:\n\n```\nDistance of node 2 = 6\nPath = 2<-3<-1\nDistance of node 3 = 4\nPath = 3<-1\nDistance of node 4 = 2\nPath = 4<-5<-1\nDistance of node 5 = 1\nPath = 5<-1\n```\n\n\nI believe this is correct.\n\nThe way I found out? I stuck this statement into the middle of your outer while loop:\n\n```\n        System.out.println(\"count \" + count + \" nextnode \" + nextnode + \" mindistance \" + mindistance);\n```\n\n\nWhen it printed a large negative number, I started suspecting an arithmetic overflow. Until you learn to use a debugger, ```\nSystem.out.println()```\n is your friend for debugging.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm for directed graphs with negative-weight edges [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Why doesn't Dijkstra's algorithm work for negative weight edges?\r\n                            \r\n                                (13 answers)\r\n                            \r\n                    \r\n                    \r\n                        Negative weights using Dijkstra's Algorithm\r\n                            \r\n                                (9 answers)\r\n                            \r\n                    \r\n                Closed 8 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nThe following is an example of a directd graph with negative-weight edges for which Dijkstra's algorithm produces incorrect answers:\n\n\n\nApplying the Dijkstra's algorihm, we get the following:\n\n\n\nThe path that we get from s to w is not the shortest. Therefore, we don't get right results.\n\nHow could we justify for the general case why we cannot apply the Dijkstra's algorithm on directed graphs with negative-weight edges?\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Implementing Dijkstra's Algorithm\r\n                \r\nI've been tasked (coursework @ university) to implement a form of path-finding. Now, in-spec, I could just implement a brute force, since there's a limit on the number of nodes to search (begin, two in the middle, end), but I want to re-use this code and came to implement Dijkstra's algorithm.\n\nI've seen the pseudo on Wikipedia and a friend wrote some for me as well, but it flat out doesn't make sense. The algorithm seems pretty simple and it's not a problem for me to understand it, but I just can't for the life of me visualize the code that would realize such a thing.\n\nAny suggestions/tips?\n\nEdit for some confusions:\nYes, there is a target node and a source node. \nI'm looking to implement Dijkstra's in a general case, not the \"only two intermediate stops\" case, because  I want to use the code again afterwards. Else, I'd just write a brute-force implementation.\nThe specific issue that I'm having a little trouble with is storing the sub-optimal half-formed paths, in case they may become optimal. When I'm visiting a given node, I just don't see how I'm going to update all the connections that go through it.\nMore edit:\nGoing through a couple of the answers now and having a go.\n\nREALLY EDIT:\nI forgot to mention a serious complication, which is that any two vertices can have up to UINT_MAX different distances between them. Sorry. Infact, the fact that I forgot to deal with this is probably the cause of the damn problem in the first place, although the solution: pick the shortest is fortunately obvious to me. No wonder other people's pseudo for a distance variable didn't take into account my variable distance.\n    ", "Answer": "\r\nHere's a high level breakdown of Dijkstra's algorithm:\n\nYou stick all of the vertices in a priority queue where all of the vertices have a priority (distance) of infinity except for the source vertex, which has a distance of zero (the source vertex is zero units of distance away from itself, right?).\n\nPop the priority queue.  The vertex removed is the vertex with the shortest distance from the source.  Obviously the first vertex popped from the queue is the source.  Well call that popped vertex v.\n\nLook at each of the neighbors of v.  All of them will have a distance greater than v's distance (otherwise we would have already popped them from the queue, right?).  Let's say v has a distance of 3, and v has 3 neighbors x (dist-from-source: 5), y (dist-from-source: 10) and z (dist-from-source: infinity).\n\nNow we look at each neighbors distance from v.  Let's say they are: x - 3, y - 2, z - 4.  This means that the path from the source to x that goes through v has a distance of |v| + 3 (3 + 3 = 6), y has a distance of 5 (3 + 2 = 5) and z has a distance of 7 (3 + 4 = 7).\n\nThe path to x through v is longer than the current shortest path to x so we ignore it.  However the paths to y and z that go through v are shorter than the previous known shortest path so we update them.\n\nYou keep doing this until you have gone through all the vertices.  At each point, when you pop the min from the priority queue you know you have found the shortest path to that vertex because any possible shorter path must pass through a vertex with a distance less than v's, which means we would have already popped that from the queue.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "can Dijkstra's algorithm be considered under linear programming?\r\n                \r\ni know that Dijkstra's algorithm is a graph search algorithm.but can it be considered under linear programming? \n    ", "Answer": "\r\nYou can form the shortest path problem as a linear program problem. So basically yes:\n\nhttp://en.wikipedia.org/wiki/Shortest_path_problem#Linear_programming_formulation\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm: memory consumption\r\n                \r\nI have an implementation of Dijkstra's Algorithm, based on the code on this website. Basically, I have a number of nodes (say 10000), and each node can have 1 to 3 connections to other nodes. \n\nThe nodes are generated randomly within a 3d space. The connections are also randomly generated, however it always tries to find connections with it's closest neighbors first and slowly increases the search radius. Each connection is given a distance of one. (I doubt any of this matters but it's just background). \n\nIn this case then, the algorithm is just being used to find the shortest number of hops from the starting point to all the other nodes. And it works well for 10,000 nodes. The problem I have is that, as the number of nodes increases, say towards 2 million, I use up all of my computers memory when trying to build the graph.  \n\nDoes anyone know of an alternative way of implementing the algorithm to reduce the memory footprint, or is there another algorithm out there that uses less memory?\n    ", "Answer": "\r\nAccording to your comment above, you are representing the edges of the graph with a distance matrix ```\nlong dist[GRAPHSIZE][GRAPHSIZE]```\n. This will take ```\nO(n^2)```\n memory, which is too much for large values of ```\nn```\n. It is also not a good representation in terms of execution time when you only have a small number of edges: it will cause Dijkstra's algorithm to take ```\nO(n^2)```\n time (where ```\nn```\n is the number of nodes) when it could potentially be faster, depending on the data structures used.\n\nSince in your case you said each node is only connected to up to 3 other nodes, you shouldn't use this matrix: Instead, for each node you should store a list of the nodes it is connected to. Then when you want to go over the neighbors of a node, you just need to iterate over this list.\n\nIn some specific cases you don't even need to store this list because it can be calculated for each node when needed. For example, when the graph is a grid and each node is connected to the adjacent grid nodes, it's easy to find a node's neighbors on the fly.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm in graph (Python)\r\n                \r\nI need some help with the graph and Dijkstra's algorithm in python 3. I tested this code (look below) at one site and it says to me that the code works too long. Can anybody say me how to solve that or paste the example of code for this algorithm? I don't know how to speed up this code. I read many sites but l don't found normal examples...\nP.S. Now l edit code in few places and tried to optimize it, nut it still too slow(\n```\nfrom collections import deque\n\n\nclass node: \n\n    def __init__(self, name, neighbors, distance, visited):\n        self.neighbors = neighbors\n        self.distance = distance\n        self.visited = visited\n        self.name = name\n    \n    def addNeighbor(self, neighbor_name, dist): # adding new neighbor and length to him\n    \n        if neighbor_name not in self.neighbors:\n            self.neighbors.append(neighbor_name)\n            self.distance.append(dist)\n\nclass graph:\n\n    def __init__(self):\n        self.graphStructure = {} # vocabulary with information in format: node_name, [neighbors], [length to every neighbor], visited_status \n    \n    \n    def addNode(self, index): # adding new node to graph structure\n    \n        if self.graphStructure.get(index) is None:\n            self.graphStructure[index] = node(index, [], [], False)\n\n\n    def addConnection(self, node0_name, node1_name, length): # adding connection between 2 nodes\n        n0 = self.graphStructure.get(node0_name)\n\n        n0.addNeighbor(node1_name, length)\n\n        n1 = self.graphStructure.get(node1_name)\n        n1.addNeighbor(node0_name, length)\n    \n    def returnGraph(self): # printing graph nodes and connections\n\n        print('')\n        for i in range(len(self.graphStructure)):\n            nodeInfo = self.graphStructure.get(i + 1)\n            print('name =', nodeInfo.name, '  neighborns =', nodeInfo.neighbors, '           length to neighborns =', nodeInfo.distance)\n        \n    def bfs(self, index): # bfs method of searching (also used Dijkstra's algorithm)\n\n        distanceToNodes = [float('inf')] * len(self.graphStructure)\n        distanceToNodes[index - 1] = 0\n        currentNode = self.graphStructure.get(index)\n        queue = deque()\n        \n        for i in range(len(currentNode.neighbors)):\n            n = currentNode.neighbors[i]\n            distanceToNodes[n - 1] = currentNode.distance[i]\n            queue.append(n)\n        \n        while len(queue) > 0: # creating queue and visition all nodes\n            u = queue.popleft()\n            node_u = self.graphStructure.get(u)\n            node_u.visited = True\n\n            for v in range(len(node_u.neighbors)):\n                node_v = self.graphStructure.get(node_u.neighbors[v])\n                distanceToNodes[node_u.neighbors[v] - 1] =  min(distanceToNodes[node_u.neighbors[v] - 1], distanceToNodes[u - 1] + node_u.distance[v]) # update minimal length to node\n                if not node_v.visited:\n                    queue.append(node_u.neighbors[v])\n                    \n        return distanceToNodes\n\ndef readInputToGraph(graph): # reading input data and write to graph datatbase\n    node0, node1, length = map(int, input().split())\n\n    graph.addNode(node0)\n    graph.addNode(node1)\n    graph.addConnection(node0, node1, length)\n\n\ndef main():\n  newGraph = graph()\n  countOfNodes, countOfPairs = map(int, input().split())\n\n  if countOfPairs == 0:\n      print('0')\n      exit()\n\n  for _ in range(countOfPairs): # reading input data for n(countOfPairs) rows\n      readInputToGraph(newGraph)\n\n  # newGraph.returnGraph() # printing information\n\n  print(sum(newGraph.bfs(1))) # starting bfs from start position\n\n  \n\nmain()\n```\n\nThe input graph structure may look like this:\n```\n15 17\n3 7 2\n7 5 1\n7 11 5\n11 5 1\n11 1 2\n1 12 1\n1 13 3\n12 10 1\n12 4 3\n12 15 1\n12 13 4\n1 2 1\n2 8 2\n8 14 1\n14 6 3\n6 9 1\n13 9 2\n```\n\nI'm only learning python so l think l could do something wrong(\n    ", "Answer": "\r\nThe correctness of Dijkstra's algorithm relies on retrieving the node with the shortest distance from the source in each iteration. Using your code as an example, the operation ```\nu = queue.popleft()```\n MUST return the node that has the shortest distance from the source out of all nodes that are currently in the queue.\nLooking at the documentation for ```\ncollections.deque```\n, I don't think the implementation guarantees that ```\npopleft()```\n always returns the node with the lowest key. It simply returns the left most item in what is effectively a double linked list.\nThe run time of Dijkstra's algorithm (once you implement it correctly) almost entirely lies on the underlying data structure used to implement ```\nqueue```\n. I would suggest that you first revisit the correctness of your implementation, and once you can confirm that it is actually correct, then start experimenting with different data structures for ```\nqueue```\n.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Priority queue in Dijkstra's algorithm\r\n                \r\nThis is my code for Dijkstra's algorithm:\n\n```\n#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n\n#define pp pair<int,int>\nusing namespace std;\nstruct pri\n{\n    int operator() (const pair<int,int>&p1,const pair<int,int>&p2)\n    {\n        return p1.second<p2.second;\n    }\n}p;\nint main()\n{\n    priority_queue<pp,vector<pp>,pri> q;\n    int n;\n    cin>>n;\n    vector<pp> g[n+1];\n    int e,u,v,w,i;\n    cin>>e;\n    for(i=0;i<e;i++)\n    {\n        cin>>u>>v>>w;\n        g[u].push_back(pp(v,w));\n        g[v].push_back(pp(u,w));\n    }\n    int s;\n    cin>>s;\n    int d[n+1];\n    for(i=1;i<=n;i++)\n        d[i]=999;\n    d[s]=0;\n    q.push(pp(s,d[s]));\n    while(!q.empty())\n    {\n        u=q.top().first;\n        q.pop();\n        int size=g[u].size();\n        for(int i=0;i<size;i++)\n        {\n            v=g[u][i].first;\n            w=g[u][i].second;\n            cout<<u<<\" \"<<\" \"<<w<<endl;\n            if(d[v]>d[u]+w)\n            {\n                d[v]=d[u]+w;\n                q.push(pp(v,d[v]));\n            }\n        }\n    }\n    for(i=1;i<=n;i++)\n        printf(\"node %d,min weight=%d\\n\",i,d[i]);\n    return 0;\n}\n```\n\n\nIn this I can't understand the working of\n\n```\n priority_queue<pp,vector<pp>,pri> q;\n```\n\n\nThat is related to:\n\n```\nstruct pri\n{\n    int operator() (const pair<int,int>&p1,const pair<int,int>&p2)\n    {\n        return p1.second<p2.second;\n    }\n}p;\n```\n\n\nWhat is the use of ```\n()```\n operator in this? I mean how it functions in this code?\n\nAlso why are we using ```\n&```\n in ```\noperator()```\n?\n\nAlso, how does this comparator work in priority queue definition?\nAnd why are we using constant in operator definition?\n\ni mean to say how is exactly this comparison in operator working and cant we use any\nother symbol as = * @ or any other instead of ()\n    ", "Answer": "\r\nI think the compare function you write is wrong.\n\n```\nint operator() (const pair<int,int>&p1,const pair<int,int>&p2)\n{\n    return p1.second<p2.second;\n}\n```\n\n\nwhich the correct one should be \n\n```\nint operator() (const pair<int,int>&p1,const pair<int,int>&p2)\n{\n    return p1.second>p2.second;\n}\n```\n\n\nBecause in priority_quequeyou can find that The expression comp(a,b), where comp is an object of this type and a and b are elements in the container, shall return true if a is considered to go before b in the strict weak ordering the function defines.\n\nBecause in the Dijkstra algorithm, the node with smaller value should has higher priority, thus the operator we used here should be \n\n```\np1.second>p2.second\n```\n\n\n(By using your code to solve a problem, it took me a long time to figure out this problem that my program's results were always different with the correct one.)\n(By the way, in the Dijkstra algorithm itself, I think once a node was pop as the smallest one, there is no need to pop it again and update all the nodes that connected to it. This could save a lot of time.)\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Using Dijkstra's Algorithm with the Lemon Graph Library\r\n                \r\nI have a question regarding some of the parameters necessary to run Dijkstra's algorithm from the Lemon Graph Libraries (Lemon's Dijkstra's http://lemon.cs.elte.hu/pub/tutorial/a00009.html).\nTo run the algorithm, one would write something like ```\ndijkstra(g, length).distMap(dist).run(s,t);```\n where ```\ng```\n is the graph, ```\ns```\n is that starting node and ```\nt```\n is the destination node. My question is what is ```\nlength```\n and ```\ndist```\n, and how are they used.\nThanks!\n    ", "Answer": "\r\nThe way I read it, they both need to be maps, one to edge lengths (input)\none to vertex distances(output), \n\nAlso check lgf_demo.cc and dijkstra_test.cc \nand note\n\n\n  Dijkstra& distMap     (   DistMap &   m    )      [inline]\n  \n  Sets the map that stores the distances of the nodes calculated by the\n  algorithm. If you don't use this function before calling run() or\n  init(), an instance will be allocated automatically. The destructor\n  deallocates this automatically allocated map, of course.\n  \n  Returns:\n      (*this)\n  \n  \n  \n  const DistMap& distMap    ( )     const [inline]\n  \n  Returns a const reference to the node map that stores the distances of\n  the nodes calculated by the algorithm.\n  \n  Precondition:\n      Either run() or init() must be called before using this function.\n\n\nso this is your output of Dijstra. \n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Negative Cycles with Dijkstra's Algorithm\r\n                \r\nSo I completely understand why negative edge weights will not work with Dijkstra's algorithm with an example like so: \n\n```\n       A\n      / \\\n     /   \\\n    /     \\\n   5       2\n  /         \\\n  B--(-10)-->C\n```\n\n\nHowever, I have read that \"if there is any negative cycle in graph you would never stop updating distance in vertices. This will cause a infinite loop.\" I don't understand how this would be the case if we declare vertices \"done\" when we visit them. How could we ever enter a cycle if we cannot revisit vertices we have already visited?\n    ", "Answer": "\r\nThe version that you describe will indeed avoid loops.  It can also fail to discover the correct lowest cost path in cases where the lowest cost path has negative edges, but there is a more direct route without them.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Implementing Dijkstra's algorithm with vector of pointers\r\n                \r\nI'm working on a program involving Dijkstra's algorithm. \n\nAfter searching long and far, I have only found help pertaining to Dijkstra's algorithm using Queues or Heaps, however, I am not using these. I have been tasked to used a vector of pointers to Vertex objects (a custom class I have defined). \n\nI have attempted to convert the Queue pseudo code (from my textbook) to the best of my ability below:\n\n```\nvoid Dijkstra(vector<Vertex*> & V, int startNum)\n{\n    vector<Vertex*> sortedVertices = V;\n\n    sortedVertices[startNum]->setDV(0);\n\n    insertionSort(sortedVertices);\n\n    while(sortedVertices.size() != 0)\n    {\n        sortedVertices[sortedVertices.size() - 1]->setKnown(true);\n        sortedVertices.pop_back();\n        insertionSort(sortedVertices);\n        Vertex * v = V[1]; // Will always bring the first element off the list\n        v->setKnown(true);\n\n        for(int m = 0; m < sortedVertices->getAdjacentVertices().size(); m++)\n        {\n            int dist = getAdjacentVertices()[m].getWeight();\n            if((sortedVertices[1].getDV() + dist) < sortedVertices[m+1]->getAdjacentVertices()[m].getDV())\n            {\n                //WE WILL DECREASE THE VALUE HERE by finding the distance between two vertices\n                cout << \"It works so far\" << endl;\n                // BOOK has this, somehow need to change it: w.path = v\n            }\n        }\n    } \n}\n```\n\n\nHowever, when I attempt to compile, I keep receiving the following errors: \n\n```\nMain.cpp: In function 'void Dijkstra(std::vector<Vertex*>&, int)':\nMain.cpp:154:42: error: base operand of '->' has non-pointer type 'std::vector<Vertex*>'\nMain.cpp:156:44: error: 'getAdjacentVertices' was not declared in this scope\nMain.cpp:157:35: error: request for member 'getDV' in 'sortedVertices.std::vector<_Tp, _Alloc>::operator[]<Vertex*, std::allocator<Vertex*> >(1ul)', which is of pointer type '__gnu_cxx::__alloc_traits<std::allocator<Vertex*> >::value_type {aka Vertex*}' (maybe you meant to use '->' ?)\nMain.cpp:157:99: error: '__gnu_cxx::__alloc_traits<std::allocator<Edge> >::value_type' has no member named 'getDV'\n```\n\n\nI am trying to reduce the amount of Code in this post, but if need to be, my entire code is below:\n\nMain.cpp:\n\n```\n#include \"Vertex.h\"\n#include <iostream>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <fstream>\n\nusing namespace std;\nvoid shortestPath(vector<Vertex> & v);\n\ntemplate <typename Comparable>\nvoid insertionSort(vector<Comparable> & a);\n\ntemplate <typename Comparable>\nvoid insertionSort( vector<Comparable> & a, int left, int right );\n\n\n///overload the less than operator in order to use the stl sort for vector\n///print out the path for each vertex\n\nint main()\n{\n\n    /////READ ALL THE STUFF INTO THE GRAPH////\n    ifstream file;\n    file.open(\"graph.txt\");\n    cout << \"Opening file...\" << endl;\n    if(!file)\n    {\n        cout << \"System failed to open file.\";\n    }\n    else\n    {\n        cout << \"File successfully opened\" << endl;\n    }\n\n    int numVertices;\n    int numEdges;\n    int num;\n    int adjacentVertex;\n    int weight;\n\n    file >> numVertices;\n    cout << \"The number of vertices that are being read into the graph from the file: \" << numVertices;\n    cout << endl;\n    vector<Vertex*> vertices;\n    //vector<Vertex> vertices(numVertices + 1);\n\n    Vertex * newVertex;\n\n    vertices.push_back(NULL);\n\n    cout << \"SIZE: \" << vertices.size() << endl;\n    cout << \"NUM VERTICES: \" << numVertices << endl;\n    for(int i=1;i < numVertices + 1; i++)\n    {   \n        file >> numEdges;\n        cout << \"At vertex \" << i << \" the number of edges is \" << numEdges << endl;\n        newVertex = new Vertex();\n\n        //Using the i counter variable in the outer for loop to identify\n        //the what vertex what are currently looking at in order to read in the correct adjacent vertex and weight\n        cout << \"LENGTH OF VERTICES[i]: \" << vertices.size() << endl;\n        newVertex->setVertexNum(i);\n        //newVertex.setVertexNum(i);\n\n        for(int j=1;j<=numEdges;j++)\n        {\n            file >> adjacentVertex;\n            cout << \"The adjacent vertex is: \" << adjacentVertex << endl;\n\n\n            file >> weight;\n            cout << \"The weight is: \" <<  weight << endl;\n            cout << endl;\n\n            newVertex->setAdjacentVertex(adjacentVertex, weight);\n        }\n        //cout << \"LENGTH OF VERTICES[i]: \" << vertices.size() << endl;\n        vertices.push_back(newVertex);\n    }\n    file.close();\n    vector<Vertex*> sortedVertices = vertices;\n    insertionSort(sortedVertices);\n\n\n    cout << \"SIZE: \" << vertices.size() << endl;\n    for(int i=0;i<vertices.size();i++)\n    {\n        cout << \"V\" << i << \":  \";\n        cout << endl;\n        if(vertices[i] != NULL)\n        {\n            cout << \"DV Value: \" << vertices[i]->getDV();\n            cout << endl;\n            cout << \"Known Value: \" << vertices[i]->getKnown();\n            cout << endl;\n        }\n    }\n\n\n    cout << \"Sorted: \" << endl;\n    for(int i=0;i<sortedVertices.size();i++)\n    {\n        cout << \"V\" << i << \":  \";\n        cout << endl;\n        if(vertices[i] != NULL)\n        {\n            cout << \"DV Value: \" << sortedVertices[i]->getDV();\n            cout << endl;\n            cout << \"Known Value: \" << sortedVertices[i]->getKnown();\n            cout << endl;\n        }\n    }    \n\n\n\n\n\n    //CALL THE SHORTEST PATH FUNCTION ON THE GRAPH/////\n\n\n\n}\n\n/*\nconst bool myFunction(const Vertex & x, const Vertex & y)\n{\n    return (x.getDV() >= y.getDV());\n}\n*/\n\nbool operator < (const Vertex & v1, const Vertex & v2)\n{\n    return v1.getDV() > v2.getDV();\n}\n\nvoid Dijkstra(vector<Vertex*> & V, int startNum)\n{\n    vector<Vertex*> sortedVertices = V;\n\n    sortedVertices[startNum]->setDV(0);\n\n    insertionSort(sortedVertices);\n\n    while(sortedVertices.size() != 0)\n    {\n        sortedVertices[sortedVertices.size() - 1]->setKnown(true);\n        sortedVertices.pop_back();\n        insertionSort(sortedVertices);\n        Vertex * v = V[1]; // Will always bring the first element off the list\n        v->setKnown(true);\n\n        for(int m = 0; m < sortedVertices->getAdjacentVertices().size(); m++)\n        {\n            int dist = getAdjacentVertices()[m].getWeight();\n            if((sortedVertices[1].getDV() + dist) < sortedVertices[m+1]->getAdjacentVertices()[m].getDV())\n            {\n                //WE WILL DECREASE THE VALUE HERE by finding the distance between two vertices\n                cout << \"It works so far\" << endl;\n                // BOOK has this, somehow need to change it: w.path = v\n            }\n        }\n    } \n}\n\n////////INSERTION SORT////////////\ntemplate <typename Comparable>\nvoid insertionSort( vector<Comparable> & a )\n{\n    for( int p = 1; p < a.size( ); ++p )\n    {\n        Comparable tmp = std::move( a[ p ] );\n\n        int j;\n        for( j = p; j > 0 && tmp < a[ j - 1 ]; --j )\n            a[ j ] = std::move( a[ j - 1 ] );\n        a[ j ] = std::move( tmp );\n    }\n}\n\ntemplate <typename Comparable>\nvoid insertionSort( vector<Comparable> & a, int left, int right )\n{\n    for( int p = left + 1; p <= right; ++p )\n    {\n        Comparable tmp = std::move( a[ p ] );\n        int j;\n\n        for( j = p; j > left && tmp < a[ j - 1 ]; --j )\n            a[ j ] = std::move( a[ j - 1 ] );\n        a[ j ] = std::move( tmp );\n    }\n}\n```\n\n\nVertex.h:\n\n```\n#include \"Edge.h\"\n#include <vector>\n#include <climits>\n#include <fstream>\nusing namespace std;\nclass Vertex\n{\n    private:\n        int vertexNum; //number of the vertex for identification purposes\n        int degree;\n        bool known;\n        vector<Edge> adjacentVertices; //vector of vertices that are adjacent to the vertex we are currently looking at\n        int dv; //distance \n        int pv; //previous vertex\n        Vertex *vertex;\n    public:\n        Vertex()\n        {\n            dv = INT_MAX;\n            known = false;\n        }\n\n        void setKnown(bool Known)\n        {\n            known = Known;\n        }\n\n        bool getKnown()\n        {\n            return known;\n        }\n\n        void setVertexNum(int VertexNum)\n        {\n            vertexNum = VertexNum;\n        }\n\n        void setDegree(int Degree)\n        {\n            degree = Degree;\n        }\n\n        vector<Edge> & getAdjacentVertices()\n        {\n            return adjacentVertices;\n        }\n\n        int getVertexNum()\n        {\n            return vertexNum;\n        }\n\n        int getDegree()\n        {\n            return degree;\n        }\n\n        int getDV() const \n        {\n            return dv;\n        }\n\n        int setDV(int Dv)\n        {\n            dv = Dv;\n        }\n\n        void setAdjacentVertex(int AdjacentVertex, int Weight)\n        {\n            Edge newEdge;\n            newEdge.setWeight(Weight);\n            newEdge.setAdjVertex(AdjacentVertex);\n            adjacentVertices.push_back(newEdge);\n        }\n\n        friend ostream & operator <<(ostream & outstream, Vertex *vertex)\n        {\n            outstream << vertex->getVertexNum() << endl;\n            outstream << vertex->getDegree() << endl;\n            outstream << vertex->getKnown() << endl;\n            vector<Edge> E = vertex->getAdjacentVertices();\n            for(int x=0;x<E.size();x++)\n            {\n                outstream << E[x].getAdjVertex() << endl;\n                outstream << E[x].getWeight() << endl;\n            }\n            return outstream;\n        }\n\n        friend bool operator < (const Vertex & v1, const Vertex & v2);\n\n};\n```\n\n\nEdge.h:\n\n```\n#include <cstdlib>\nclass Edge\n{\n    private:\n        int adjVertex; //represents the vertex that the edge leads to\n        int weight;\n    public:\n        Edge()\n        {\n            adjVertex = 0;\n            weight = 0;\n        }\n        void setWeight(int Weight)\n        {\n            weight = Weight;\n        }\n\n        void setAdjVertex(int adjacent)\n        {\n            adjVertex = adjacent;\n        }\n\n        int getAdjVertex()\n        {\n            return adjVertex;\n        }\n\n        int getWeight()\n        {\n            return weight;\n        }\n};\n```\n\n    ", "Answer": "\r\nFrom ```\ng++```\n to English:\n\n```\nMain.cpp: In function 'void Dijkstra(std::vector<Vertex*>&, int)':\nMain.cpp:154:42: error: base operand of '->' has non-pointer type 'std::vector<Vertex*>'\nMain.cpp:156:44: error: 'getAdjacentVertices' was not declared in this scope\nMain.cpp:157:35: error: request for member 'getDV' in 'sortedVertices.std::vector<_Tp, _Alloc>::operator[]<Vertex*, std::allocator<Vertex*> >(1ul)', which is of pointer type '__gnu_cxx::__alloc_traits<std::allocator<Vertex*> >::value_type {aka Vertex*}' (maybe you meant to use '->' ?)\nMain.cpp:157:99: error: '__gnu_cxx::__alloc_traits<std::allocator<Edge> >::value_type' has no member named 'getDV'\n```\n\n\nExplanation:\n\n```\nfor(int m = 0; m < sortedVertices->getAdjacentVertices().size(); m++)```\n <- this is 154. ```\nsortedVertices```\n is not a pointer. It is a ```\nstd::vector```\n of some pointers.\n\n```\nint dist = getAdjacentVertices()[m].getWeight();```\n <- 156. What is ```\ngetAdjacentVertices```\n?\n\n```\nsortedVertices[1].getDV()```\n <- 157 ```\nsortedVertices[1]```\n is a pointer. Look at ```\noperator[]```\n\n\n```\nsortedVertices[m+1]->getAdjacentVertices()```\n is a ```\nvector```\n of ```\nEdge```\n. ```\nEdge```\n does not have a ```\ngetDV()```\n method defined.\n\nIs this really your code?\n\nAs an author you should not have trouble understanding the error messages. Those are simple mistakes, that took 5 minutes for a stranger to understand. You need to put more effort in understanding what you write, and what compiler tells you. Or get some sleep to get some focus.\n\nI would also suggest to spend some time working out what ```\nstd::vector```\n really is and how to understand ```\nstd::vector<Vertex*> vector_of_vertices;```\n object.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra algorithm python\r\n                \r\nI'm trying to implement Dijkstra's algorithm in Python and something doesn't work. I think there is a problem somewhere and I cannot find it.\nHere's my code:\n\n```\ndef Dijkstra(self, start, end, visited=[], distances = {}, predecessors = {}):\n        allV = self.__repo.read_first_line()\n        verteces = allV[0]\n        if start == end:\n        # We build the shortest path and display it\n            path=[]\n            pred=end\n            while pred != None:\n                path.append(pred)\n                pred=predecessors.get(pred,None)\n            path.reverse()\n            print('Shortest path: '+str(path)+ \" - \" + \"Cost = \"+str(distances[start])) \n        else :     \n            if not visited: \n                distances[start]=0\n                # visit the neighbors\n                neighbours = self.__repo.get_neighbours(start)\n                for neighbor in neighbours :\n                    if neighbor not in visited:\n                        new_distance = distances[start] + self.get_cost(start, neighbor)\n                        if new_distance < distances.get(neighbor,float('inf')):\n                            distances[neighbor] = new_distance\n                            predecessors[neighbor] = start\n            # mark as visited\n            visited.append(start)\n        # now that all neighbors have been visited: recurse                         \n        # select the non visited node with lowest distance 'x'\n        # run Dijskstra with start='x'\n            unvisited={}\n            for k in range(1,int(verteces) + 1):\n                if k not in visited:\n                    unvisited[k] = distances.get(k,float('inf'))  \n            x=min(unvisited, key=unvisited.get)\n            self.Dijkstra(x,end,visited,distances,predecessors)\n```\n\n    ", "Answer": "\r\nThere are far simpler ways to implement Dijkstra's algorithm.\n\nYou can think of it as the same as a BFS, except:\n\n\nInstead of a queue, you use a min-priority queue.\nWe only considered a node 'visited', after we have found the minimum cost path to it.\n\n\nPlease see below a python implementation with comments:\n\nThe example inputs is taken from this youtube Dijkstra's algorithm tutorial\n\n```\nimport heapq\n\ngraph = {\n    'A': {'B': 20, 'D': 80, 'G': 90},\n    'B': {'F': 10},\n    'F': {'C': 10, 'D': 40},\n    'C': {'F': 50, 'D': 10, 'H': 20},\n    'D': {'G': 20, 'C': 10},\n    'H': {},\n    'G': {'A': 20},\n    'E': {'B': 50, 'G': 30}\n}\n\n\ndef dijkstra(graph, source):\n    priority_queue = []\n    # The cost is 0, because the distance between source to itself is 0\n    heapq.heappush(priority_queue, (0, source))\n    visited = {}\n    # basically the same as a normal BFS\n    while priority_queue:\n        # dequeue from the priority queue\n        # dequeue the minimum cost path\n        (current_distance, current) = heapq.heappop(priority_queue)\n\n        # When we extract min from the priority queue\n        # we know that we have found the minimum cost path to this node\n        # so we consider it visited\n        visited[current] = current_distance\n\n        if current not in graph: continue\n        for neighbour, distance in graph[current].items():\n            # We only continue to explore neighbours that have been visited\n            # (same as a normal BFS)\n            if neighbour in visited: continue\n            # If we haven't found the min cost path to this node, we push the new distance back onto the queue\n            # because this is a min queue, if the new distance is the new min cost path, it will be at the front of the queue\n            new_distance = current_distance + distance\n            heapq.heappush(priority_queue, (new_distance, neighbour))\n\n    return visited\n\nprint dijkstra(graph, 'A')\n# {'A': 0, 'C': 40, 'B': 20, 'D': 80, 'G': 90, 'F': 30, 'H': 60}\n```\n\n\nP.S. Ideally, you would use a priority queue dictionary where you can decrease the priority on existing nodes. This will decrease memory usage and time. \n\nHowever, a normal heap queue will give you the same level of correctness, because if we find a new min cost path, it will get put into the front of the queue. \n\nAnd when we get to the older items with higher costs, those nodes would have already been processed and therefore does not impact the output\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Would Dijkstra's Algorithm go into dead end? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                It's difficult to tell what is being asked here. This question is ambiguous, vague, incomplete, overly broad, or rhetorical and  cannot be reasonably answered in its current form. For help clarifying this question so that it can be reopened,  visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nSay I have the following graph:\n\n```\n           e (destination)\n           |\n           | (1)\n           |\n           d\n           |\n           | (100)\n           |\n  (start)  a - - - b - - - c\n             (1)      (1)\n```\n\n\nWould Dijkstra's algorithm run into a dead end? I think if I start from a, it will go a->b->c and went into dead end, therefore cannot reach e. Is that so?\n    ", "Answer": "\r\nObviously not. From the wikipedia description of Dijkstra's algorithm:\n\n\n  .3. For the current node, consider all of its unvisited neighbors and calculate their tentative distances.\n\n\nThat means that if you start at ```\na```\n, ```\nb```\n and ```\nd```\n are both examined (i.e. their tentative distances are calculated) because they are unvisited neighbours. Because ```\nb```\n has the smaller tentative distance, you visit that one next.\n\nFor your update with the extra node ```\ne```\n: You arrive at ```\nc```\n as described above. But you're not stuck - there is still an unvisited node with a precalculated tentative distance, namely ```\nd```\n - so you visit that one next.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm in Java source and target\r\n                \r\nI'm trying to use Dijkstra's algorithm to find the shortest path between two nodes in the graph.\n\nwhat should I do to the following code to stop calculating when the shortest path between the source and the target is found? \n\n```\npublic void calculate(Vertex source){\n    // Algo:\n    // 1. Take the unvisited node with minimum weight.\n    // 2. Visit all its neighbours.\n    // 3. Update the distances for all the neighbours (In the Priority Queue).\n    // Repeat the process till all the connected nodes are visited.\n\n    source.minDistance = 0;\n    PriorityQueue<Vertex> queue = new PriorityQueue<Vertex>();\n    queue.add(source);\n\n    while(!queue.isEmpty()){\n\n        Vertex u = queue.poll();\n\n        for(Edge neighbour:u.neighbours){\n            Double newDist = u.minDistance+neighbour.weight;\n\n            if(neighbour.target.minDistance>newDist){\n                // Remove the node from the queue to update the distance value.\n                queue.remove(neighbour.target);\n                neighbour.target.minDistance = newDist;\n\n                // Take the path visited till now and add the new node.s\n                neighbour.target.path = new LinkedList<Vertex>(u.path);\n                neighbour.target.path.add(u);\n\n                //Reenter the node with new distance.\n                queue.add(neighbour.target);                    \n            }\n        }\n    }\n}\n```\n\n    ", "Answer": "\r\n\n  what should I do to the following code to stop calculating when the\n  shortest path between the source and the target is found\n\n\nYou can't \"break\" in the middle because you can't tell if there isn't a shorter path than the one you've already found until the algorithm finishes.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Issue in Implementing Dijkstra's algorithm\r\n                \r\nI am trying to solve a problem where I need to find the max distance between 2 points in a graph. I wrote this code for implementing Dijkstra's algorithm (obviously by changing the minimization to maximization), but it doesn't seem to work in some cases, and I am unable to figure out the unhandled case. Can anyone help me in pointing out what am I missing in my implementation or if something is inherently incorrect?\n```\npublic double maxDistance(int n, int start, int end) {\n    \n    Map<Integer, List<Integer>> adjacencyList = getAdjacencyList(); // Adj. list in form of HashMap \n    Map<String, Double> distanceMap = getDistanceMap(); // <Edge, Double> (value is distance)\n    Queue<Integer> bfsQueue = new LinkedList<>(); // queue to do a BFS\n    \n    boolean[] visited = new boolean[n];\n    double[] distance = new double[n];\n    \n    bfsQueue.add(start);\n    \n    while (!bfsQueue.isEmpty()) {\n        int node = bfsQueue.poll();\n        \n        List<Integer> neighbors = adjacencyList.getOrDefault(node, new ArrayList<>());\n        for (int neighbor: neighbors) {\n            if (visited[neighbor]) continue;\n            bfsQueue.add(neighbor);\n            double edgeLength = distanceMap.get(new Edge(node, neighbor));\n            double newLength = distance[node] + edgeLength;\n            if (newLength > distance[neighbor]) {\n                distance[neighbor] = newLength;\n            }\n        }\n        visited[node] = true;\n    }\n\n    return distance[end];\n}\n```\n\n    ", "Answer": "\r\nFirst, Dijkstra's algorithm finds the shortest path, thus it should be ```\nminDistance```\n, not ```\nmaxDistance```\n.\nNext, to implement a breadth-first search, you need a sorted data structure. Your ```\nbfsQueue```\n is currently just a ```\nLinkedList```\n. With a linked list, you iterate over the items in the order of insertion. But in Dijkstra's algorithm it is important to always handle the next nearest neighbor. It is thus usually implemented with a priority queue.\nAs example why this makes a difference: Image you want to go from A to B. There are two routes available, a long one consisting of two edges, and a shorter one consisting of 4 edges. In your case, you basically expand through the graph by the number of edges since the start, and not by the distance. So you would first find the route consisting of two edges, even if this is the slower one.\nIf you use a ```\nPriorityQueue```\n, be alerted that reducing the distance/priority of a neighbor as you do it currently (```\nif (newLength > distance[neighbor]) { distance[neighbor] = newLength; }```\n) will not work, as the priority queue will not automatically re-sort. You'll have to first remove the neighbor from the priority queue, update the distance, and then re-insert it into the priority queue so it gets sorted into the right place.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm - Infinite Loop\r\n                \r\nAs a homework assignment, I am to implement an adjacency list using an array of pointers to linked lists for each vertex. Each linked list has an element ```\n<destination>```\n that states the vertex neighbor of adjacency list vertex.\n\nThe adjacency list is undirected and unweighted, so I am treating all weights as 1.\n\n```\n /* Adjacency List Node data structure (edge)\n * Linked List data structure for storing linked vertices\n */\nstruct adjacencyListNode\n{\n    int destination;\n    struct adjacencyListNode *next;\n};\n\n/* Adjacency List Vertex data structure (vertex)\n * <AdjacencyList> consists of pointers to <n> adjacencyListVertex\n */\nstruct adjacencyListVertex\n{\n    struct adjacencyListNode *head;\n};\n```\n\n\nI am trying to perform Dijkstra's Algorithm on the adjacency list to find the minimum path from s to t.\n\nRight now I am implementing the following algorithm:\n\n```\n/* Prints the length and path taken of the shortest path in adjacency list between s and t.\n *  Uses Dijkstra’s algorithm to compute shortest path.\n *  S: source vertex\n *  V: destination vertex\n */\nvoid shortestPath(int s, int t) {\n    int known[size]; // shortest distance to vertex is know\n    int cost[size]; // distance from source <s> to each vertex\n    int path[size]; //path\n\n    // Initialization: Set all distances to infinity (represented by -1), since arrays have not been visited and graph is positively weighted\n    for (int index = 0; index<size; index++) {\n        cost[index] = INFINITY;\n        known[index] = 0;\n    }\n\n    // Set distance from source->source to 0\n    cost[s-1] = 0;\n\n    // Starting at s, traverse towards all reachable unvisited verticies, visit it and repeat\n    while (isFinished(known, size) == false) {\n        // Select a vertex from list of unvisited nodes which has the smallest cost\n        int cheapestVertex, cheapestValue = INFINITY+1;\n        for (int costCheck = 0; costCheck<size; costCheck++) {\n            if ((known[costCheck] == 0) && (cost[costCheck] < cheapestValue)) {\n                // We found a cheaper unvisited vertex\n                //                  cout << \"Cheapest vertex: \" << costCheck << endl;\n                cheapestVertex = costCheck;\n                cheapestValue = cost[cheapestVertex];\n            }\n            //              cout << \"found? \" << cheapestVertex << \" \" << cheapestValue << endl;\n        }\n\n\n        //          cout << \"Cheapest vertex: \" << cheapestVertex << endl;\n        // For each unvisited neighbor of our cheapest (unvisited) vertex\n        adjacencyListNode* iterator = A[cheapestVertex].head; // iterator is our first neighbor\n        while (iterator)\n        {\n            // Calculate the new cost from the current vertex <cheapestVertex>\n            if (cost[cheapestVertex]+1 < cost[iterator->destination] && known[iterator->destination] == 0) {\n                cost[iterator->destination] = cost[cheapestVertex]+1;\n            }\n            iterator = iterator->next; // move to next neighbor, repeat\n        }\n\n        //          cout << \"Cheapest vertex: \" << cheapestVertex  << \" known.\" << endl;\n        // Mark the current vertex <cheapestVertex> as visited\n        known[cheapestVertex] = 1;\n\n        // DEBUG: (REMOVE BEFORE SUBMISSION)\n        for (int i = 0; i<size; i++) {\n            cout << \"Vertex \" << i << \" : known? \" << known[i] << \", cost? \" << cost[i] << endl;\n        }\n        cout << endl;\n\n        if (cost[t-1] != INFINITY) break; // We already know shortest path, end.\n    }\n\n    // We know the shortest path cost to t\n    cout << \"Cost to t: \" << cost[t] << endl;\n}\n\nbool isFinished(int array[], int arraySize) {\n    bool finished = true;\n    for (int iterator=0; iterator < arraySize; iterator++) {\n        if (array[iterator] == 0) {\n            // vertex not known, we're not done.\n            finished = false;\n        }\n    }\n    return finished;\n}\n```\n\n\nI am passing the following input, which just adds the stated related vertices and calls my shortest-path algorithm.\n\n```\n0 1\n1 2\n1 3\n2 4\n3 5\n5 38\n6 7\n6 10\n8 9\n11 12\n12 13\n12 15\n12 21\n13 14\n14 15 \n16 17\n17 18\n18 19\n19 20\n20 39\n21 22\n22 23\n22 31\n23 24\n23 32\n24 25\n24 33\n25 26\n26 27\n27 28\n28 29\n29 30\n31 40\n34 35\n34 37\n35 36\n36 37\n1\nshortest-path\n```\n\n\nMy code traverses from 0->1->2->3->4->5->38 and then repeats 38 infinitely.\n\nDoes anyone see where my issue is?\n    ", "Answer": "\r\nYou have a few issues. As this is homework, I won't give you the full answers.\n\nIssue 1: What happens if there are nodes that are unreachable from s? This is what is happening in your example.\n\nHint: You need to work out when to stop the loop (other than the one you have already). Look at your cheapest selection - how would you determine that there isn't a valid one?\n\nHint #2 - You current loop won't set a value for ```\ncheapestVertex```\n if all remaining vertices have a cost of ```\nINFINITE```\n, so you will be using an uninitialized value. Maybe check what the cheapest cost you found was before proceeding.\n\nIssue 2: ```\ncost[iterator->destination] = cost[cheapestVertex]+1;```\n \n\nHint: are you sure this is correct to do on every occasion? What if the node already has a cheaper cost, or has already been visited?\n\nIssue 3: You can stop looking once you have ```\nt```\n known. No need to check the whole graph. Note: This is an change that you don't necessarily need as your code will work without it.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm and the greedy strategy\r\n                \r\nI seem to be having a bit of trouble understanding how the greedy strategy works and how Dijkstra's Algorithm keeps track of the shortest path. For reference, here is the pseudo code for Dijkstra's Algorithm\n\n```\nDijkstrasAlgorithm(G, w, s)\n    InitalizeSingleSource(G, s)\n    S = 0\n    Q = G.V\n    while Q != 0\n        u = ExtractMin(Q)\n        S = S∪{u}\n        for each vertex v ∈ G.Adj[u]\n            Relax(u, v, w)\n```\n\n\nPlease consider the following weight direction graph.\n\nThere are 5 vertices: s, t, x, y, z\nThere are 10 edges: \n\n```\ns->t = 3\ns->y = 5\nt->y = 2\nt->x = 6\ny->t = 1\ny->x = 4\ny->z = 6\nx->z = 2\nz->x = 7\nz->s = 3\n```\n\n\nOur goal is to find the shortest path from s to x. My answer was s->t->y->x with length 9, I assumed that \"S\" in the pseudo code was the shortest path and that each ExtractMin from minQ was added onto the path.\n\nMy teacher, however, has told me that this is wrong. The correct answer is s->t->x with length 9. The difference in our answer is whether to include y. My teacher says that since s->t->x is \"found first\", it is not updated to s->t->y->x, which is of equal length.\n\nThis confuses me. Dijkstra's Algorithm uses the greedy strategy, and I thought the greedy strategy was to always pick the shortest path available at the time. And when the the choice is between t->y and t->x, t->y is shorter and should therefore be picked.\n\nMy questions are:\n\n1) In what circumstances will the greedy strategy not pick the immediate shortest path for the end result?\n\n2) If using ExtractMin on minQ isn't how we keep track of the overall path from s to x, then how do we keep track of the full path?\n    ", "Answer": "\r\nYour teacher's answer assumes that we explore paths in the order, \"shortest first, broken by first seen first\".\n\nTo start with we explore ```\ns->t```\n we put ```\nx```\n at cost 9 from ```\ns->t->x```\n onto the list of things to explore 'some day'.  But we first explore ```\ns->t->y```\n because it is shorter.  At that point, we see that ```\ns->t->y->x```\n is an option, also of cost 9.  However because this is not an improvement we drop it.\n\nTherefore once we get to paths of length 9, we find ```\ns->t->x```\n out because it went on the queue first.\n\nYou would get your answer out if you modified ```\nRelax```\n to save a possible path if it is better than or equal to the best so far found.  This would get a correct answer.\n\nAs for how the path is extracted from the end, each node knows how you get to it.  So start from the end and follow the cookie trail backwards to find the path in reverse, then reverse it to get the actual path.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithms and Negative Weights and Cycle\r\n                \r\nI study on Greedy Algorithm. summarize some important aspects about Dijkstra's Algorithms, that will be TRUE. i suspect about (4)  and (1), anyone could help me?\n\nI) if all edges weight be negative, the Dijkstra's algorithm, works well.\n\nII) if in graph we have a negative cycle, Dijkstra's get into a infinite loop and never end.\n\nIII) if a graph has a one edge with negative weight, but hasn't a negative cycle, the algorithm doesn't works well.\n\nIV) if graph hasn't a negative cycle, the algorithms work well.\n    ", "Answer": "\r\nDijkstra's algorithm only works on graphs with non-negative edges.  This is because it assumes that the first time a node is popped off the queue we have found the shortest path to that node and this is not necessarily true as soon as you have even one negative weight. \n\nTherefore I is false, II is false (because the negative cycle may not necessarily be reachable), III is true, IV is false (it may still have a negative edge even without a negative cycle).\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm in Python plotting path\r\n                \r\nI need adapted Dijkstra's algorithm below to show coordinates of the shortest path.\n\nI need to also draw the path as well, but I'm having trouble getting the right coordinates to plot.\n\nI use the function mylabel2 assign the coordinates and I will like to plot the path as well. Please see from the comment #mydrawings...\n\n```\nimport sys\nimport matplotlib.pyplot as plt\nfrom pprint import pprint\n\n#Function to label points\n\ndef mylabel(x):\n    return {\n         1:'A',\n         2:'B',\n         3:'C',\n         4:'D',\n         5:'E',\n         6:'F',\n         7:'G',\n         8:'H',\n    }[x]\n\n#Function to derive coordinates\n\ndef mylabel2(x):\n    return {\n         'A':([0],[5]),\n         'B':([1],[0]),\n         'C':([5],[1]),\n         'D':([2],[4]),\n         'E':([3],[6]),\n         'F':([0],[7]),\n         'G':([4],[8]),\n         'H':([6],[2])\n    } [x]\n\n#Adjancency and State Matrix    \n\nAdj_Matrix = [[0, 20, 0, 0, 0, 0, 15, 0],\n             [20, 0, 8, 9, 0, 0, 0, 0],\n             [0,  8,  0,  6, 15, 0, 0, 10], \n             [0, 9, 6, 0, 7, 0, 0, 0],\n             [0, 0, 15, 7, 0, 22, 18, 0],\n             [0, 0, 0, 0, 22, 0, 0, 0],\n             [15, 0, 0, 0, 18, 0, 0, 0],\n             [0, 0, 10, 0, 0, 0, 0, 0]]\n\n\nCoord_Matrix_x=[0, 1, 5, 2, 3, 0, 4, 6]\nCoord_Matrix_y=[5, 0, 1, 4, 6, 7, 8, 2]\n\nplt.plot(Coord_Matrix_x, Coord_Matrix_y, 'bo')\nplt.axis([-1, 7, -1, 9])    \n\nfor i in xrange(8):\n        plt.text(Coord_Matrix_x[i]-0.5, Coord_Matrix_y[i], str(mylabel(i+1)))\n\n\nfor i in xrange(8):\n    for j in xrange(8):\n        if Adj_Matrix[i][j] != 0:\n            plt.plot([Coord_Matrix_x[i], Coord_Matrix_x[j]], [Coord_Matrix_y[i], Coord_Matrix_y[j]], 'b')\n\n\n#Collect Start and End Points\n#print 'Give the start point'\n\n#startPoint = int(raw_input()) - 1   \n#print 'Give the end point'\n#endPoint = int(raw_input()) - 1\n\n\n\n#Dijkstra Algorithm \n\ndef dijkstra(graph,start,target):\n    inf = 0\n    for u in graph:\n        for v ,w in graph[u]:\n           inf = inf + w\n    dist = dict([(u,inf) for u in graph])\n    prev = dict([(u,None) for u in graph])\n    q = graph.keys()\n    dist[start] = 0\n    #helper function\n    def x(v):\n        return dist[v]\n    #\n    while q != []:\n        u = min(q, key=x)\n        q.remove(u)\n        for v,w in graph[u]:\n            alt = dist[u] + w\n            if alt < dist[v]:\n                dist[v] = alt\n                prev[v] = u\n    #”way”\n    trav = []\n    temp = target\n    while temp != start:\n        trav.append(prev[temp])\n        temp = prev[temp]\n    trav.reverse()\n    trav.append(target)\n    return \" -> \".join(trav),dist[target]\ngraph = {\n    'A' : [('B',20), ('G', 15)],\n    'B' : [('A', 20),('C', 8), ('D', 9)],\n    'C' : [('B', 8),('D', 6), ('E', 15), ('H', 10)],\n    'D' : [('B', 9),('C', 6),('E', 7)],\n    'E' : [('C', 15),('D', 7),('F', 22),('G', 18)],\n    'F' : [('E', 22)],\n    'G' : [('A', 15),('E', 18)],\n    'H' : [('C', 10)]\n    }\n\n#pprint(graph)\nprint\ntraverse, dist = dijkstra(graph,'F','H')\nprint traverse\n\n\n\n\n#Drawing of coordinates\nmydrawing = traverse.split('-> ')\n\nfor i in mydrawing:\n    i = i.rstrip()\n    print i, '=>', mylabel2(i)\n    cc = []\n    mycoordinates = mylabel2(i)\n    for x in mycoordinates:\n        cc.append(x)\n        if len(mycoordinates)==2:\n            a1 = mycoordinates[0]\n            a2 = mycoordinates[1]\n            print a1, a2, 'node'\n            plt.plot(a1,a2, 'ro')\n            #plt.plot(a1,a2, 'b')\n            #plt.axis([-1, 7, -1, 9])\n    print cc, 'array'\n\n\n\nprint \"Distance:\",dist\n```\n\n    ", "Answer": "\r\n```\nimport sys\nimport matplotlib.pyplot as plt\nfrom pprint import pprint\n\n#dict to label points\nmylabel = {1:'A',2:'B',3:'C',4:'D',5:'E',6:'F',7:'G',8:'H'}\n\n#dict to derive coordinates\nmylabel2 = {\n         'A':(0,5),\n         'B':(1,0),\n         'C':(5,1),\n         'D':(2,4),\n         'E':(3,6),\n         'F':(0,7),\n         'G':(4,8),\n         'H':(6,2)\n           }\n#Adjancency and State Matrix\nAdj_Matrix = [[0, 20, 0, 0, 0, 0, 15, 0],\n             [20, 0, 8, 9, 0, 0, 0, 0],\n             [0,  8,  0,  6, 15, 0, 0, 10],\n             [0, 9, 6, 0, 7, 0, 0, 0],\n             [0, 0, 15, 7, 0, 22, 18, 0],\n             [0, 0, 0, 0, 22, 0, 0, 0],\n             [15, 0, 0, 0, 18, 0, 0, 0],\n             [0, 0, 10, 0, 0, 0, 0, 0]]\n\nxCoord=[mylabel2[k][0] for k in sorted(mylabel2)]\nyCoord=[mylabel2[k][1] for k in sorted(mylabel2)]\nplt.plot(xCoord, yCoord, 'bo')\nplt.axis([-1, 7, -1, 9])\nfor i in xrange(8):\n    plt.text(xCoord[i]-0.5, yCoord[i], mylabel[i+1])\nfor i in xrange(8):\n    for j in xrange(8):\n        if Adj_Matrix[i][j]:\n            plt.plot([xCoord[i], xCoord[j]],[yCoord[i], yCoord[j]], 'b')\n#Dijkstra Algorithm\ndef dijkstra(graph,start,target):\n    inf = reduce(lambda x,y: x+y,(i[1] for u in graph for i in graph[u]))\n    dist = dict.fromkeys(graph,inf)\n    prev = dict.fromkeys(graph)\n    q = graph.keys()\n    dist[start] = 0\n    while q:\n        u = min(q, key=lambda x: dist[x])\n        q.remove(u)\n        for v,w in graph[u]:\n            alt = dist[u] + w\n            if alt < dist[v]:\n                dist[v] = alt\n                prev[v] = u\n    #”way”\n    trav = []\n    temp = target\n    while temp != start:\n        trav.append(prev[temp])\n        temp = prev[temp]\n    trav.reverse()\n    trav.append(target)\n    return \" -> \".join(trav),dist[target]\n\ngraph = {\n    'A' : [('B',20), ('G', 15)],\n    'B' : [('A', 20),('C', 8), ('D', 9)],\n    'C' : [('B', 8),('D', 6), ('E', 15), ('H', 10)],\n    'D' : [('B', 9),('C', 6),('E', 7)],\n    'E' : [('C', 15),('D', 7),('F', 22),('G', 18)],\n    'F' : [('E', 22)],\n    'G' : [('A', 15),('E', 18)],\n    'H' : [('C', 10)]\n    }\ntraverse, dist = dijkstra(graph,'F','H')\nprint traverse\n#Drawing of coordinates\nmydrawing = traverse.split('-> ')\nplt.plot([ mylabel2[n.rstrip()][0] for n in mydrawing ],[ mylabel2[n.rstrip()][1] for n in mydrawing])\nprint \"Distance:\",dist\nplt.show()\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm openmp strange behavior\r\n                \r\nI'm trying to run an openmp realization of Dijkstra's algorithm which I downloaded here heather.cs.ucdavis.edu/~matloff/OpenMP/Dijkstra.c\n\nIf I add for example one more vertice from 5 to 6, so that the path from 0th goes through two vertices, my program fails to give me a correct result, saying that the distance between 0th and 6th is infinite :^(\nWhat can be the reason?\n\n```\n#define LARGEINT 2<<30-1  // \"infinity\"\n#define NV 6\n\n// global variables, all shared by all threads by default\n\nint ohd[NV][NV],  // 1-hop distances between vertices\nmind[NV],  // min distances found so far\nnotdone[NV], // vertices not checked yet\nnth,  // number of threads\nchunk,  // number of vertices handled by each thread\nmd,  // current min over all threads\nmv;  // vertex which achieves that min\n\nvoid init(int ac, char **av)\n{  int i,j;\nfor (i = 0; i < NV; i++)  \n  for (j = 0; j < NV; j++)  {\n     if (j == i) ohd[i][i] = 0;\n     else ohd[i][j] = LARGEINT;\n  }\nohd[0][1] = ohd[1][0] = 40;\nohd[0][2] = ohd[2][0] = 15;\nohd[1][2] = ohd[2][1] = 20;\nohd[1][3] = ohd[3][1] = 10;\nohd[1][4] = ohd[4][1] = 25;\nohd[2][3] = ohd[3][2] = 100;\nohd[1][5] = ohd[5][1] = 6;\nohd[4][5] = ohd[5][4] = 8;\nfor (i = 1; i < NV; i++)  {\n  notdone[i] = 1;\n  mind[i] = ohd[0][i];\n}\n}\n\n// finds closest to 0 among notdone, among s through e\nvoid findmymin(int s, int e, int *d, int *v)\n{  int i;\n  *d = LARGEINT; \n  for (i = s; i <= e; i++)\n     if (notdone[i] && mind[i] < *d)  {\n        *d = ohd[0][i];\n        *v = i;\n     }\n}\n\n// for each i in [s,e], ask whether a shorter path to i exists, through\n// mv\nvoid updateohd(int s, int e)\n{  int i;\n   for (i = s; i <= e; i++)\n      if (mind[mv] + ohd[mv][i] < mind[i])  \n     mind[i] = mind[mv] + ohd[mv][i];\n}\n\nvoid dowork()\n{  \n   #pragma omp parallel  // Note 1  \n   {  int startv,endv,  // start, end vertices for this thread\n      step,  // whole procedure goes NV steps\n      mymd,  // min value found by this thread\n      mymv,  // vertex which attains that value\n      me = omp_get_thread_num();  // my thread number\n      #pragma omp single   // Note 2\n      {  nth = omp_get_num_threads();  chunk = NV/nth;  \n     printf(\"there are %d threads\\n\",nth);  }\n      // Note 3\n      startv = me * chunk; \n      endv = startv + chunk - 1;\n      for (step = 0; step < NV; step++)  {\n     // find closest vertex to 0 among notdone; each thread finds\n     // closest in its group, then we find overall closest\n     #pragma omp single \n     {  md = LARGEINT; mv = 0;  }\n     findmymin(startv,endv,&mymd,&mymv);\n     // update overall min if mine is smaller\n     #pragma omp critical  // Note 4\n     {  if (mymd < md)  \n          {  md = mymd; mv = mymv;  }\n     }\n     // mark new vertex as done \n     #pragma omp single \n     {  notdone[mv] = 0;  }\n     // now update my section of ohd\n     updateohd(startv,endv);\n     #pragma omp barrier \n      }\n   }\n}\n\nint main(int argc, char **argv)\n{  int i;\n   init(argc,argv);\n   dowork();  \n   // back to single thread now\n   printf(\"minimum distances:\\n\");\n   for (i = 1; i < NV; i++)\n      printf(\"%d\\n\",mind[i]);\n}\n```\n\n    ", "Answer": "\r\nThere are two problems here:\n\nIf the number of threads doesn't evenly divide the number of values, then this division of work\n\n```\n  startv = me * chunk;\n  endv = startv + chunk - 1;\n```\n\n\nis going to leave the last ```\n(NV - nth*(NV/nth))```\n elements undone, which will mean the distances are left at ```\nLARGEINT```\n.   This can be fixed any number of ways; the easiest for now is to give all remaining work to the last thread\n\n```\n  if (me == (nth-1)) endv = NV-1;\n```\n\n\n(This leads to more load imbalance than is necessary, but is a reasonable start to get the code working.)\n\nThe other issue is that a barrier has been left out before setting ```\nnotdone[]```\n\n\n```\n #pragma omp barrier\n #pragma omp single \n {  notdone[mv] = 0;  }\n```\n\n\nThis makes sure ```\nnotdone```\n is updated and ```\nupdateohd()```\n is started only after everyone has finished their ```\nfindmymin()```\n and updated ```\nmd```\n and ```\nmv```\n.\n\nNote that it's very easy to introduce errors into the original code you started with; the global variables used make it very difficult to reason about.  John Burkardt has a nicer version of this same algorithm for teaching up on his website here, which is almost excessively well commented and easier to trace through.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "dijkstra's vs Bellman-Ford algorithm [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Why doesn't Dijkstra's algorithm work for negative weight edges?\r\n                            \r\n                                (13 answers)\r\n                            \r\n                    \r\n                Closed 3 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nmy current understanding is that dijkstra's algorithm is more efficient then bellman-ford, only it cannot handle negative edges. However say we have an edge weighted graph where there are negative-weight edges, there are no negative-weight cycles in the graph, can we still use dijkstra's algorithm? \n    ", "Answer": "\r\nThis question has already been answered well here.\nhttps://stackoverflow.com/a/13159425/12449779\n\nTo summarize, Dijkstra's algorithm in each iteration marks the vertices at minimum distances from \"marked\" vertices. Initially, the source vertex is the only marked vertex with distance 0. Suppose two marked vertices exists A and B who are at a certain finite distance from source and their paths do not overlap. Currently, the paths to A and B would be considered as the shortest possible paths from A to B. Since the paths do not overlap, any path from Source to A to B would be of length source to A + length of Path from A to B which is greater than path from source to B as paths from source to A and B do not overlap. But if negative weighted edges are allowed, this does NOT hold. As the length of path from A to B may be negative. Thus Dijkstra's Algorithm does not work. There is no simple way to convert a general graph with negative edges to one with non-negative edges either. Bellman Ford works for any graph which does not contain negative weighted cycles. \n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm on adjacency matrix in python\r\n                \r\nHow can I use Dijkstra's algorithm on an adjacency matrix with no costs for edges in Python? It has 1 if there is an edge between 2 vertices and 0 otherwise. The explanations that I've found on the internet are all for graphs with costs.\n    ", "Answer": "\r\nDijkstra's algorithm requires edge cost to work. If you want to run the algorithm on a graph with \"no costs\", I'll assume that you're trying to find the shortest path between 2 vertices in terms of number of edges in the path.\n\nIn that case, you can just assume that every edge has cost 1, and Dijkstra's algorithm will work as intended. Make also sure that you ignore non-existing edges in your search (you don't want the zeroes in the matrix to be counted as zero-cost edges).\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Netlogo Dijkstra algorithm\r\n                \r\n```\nto-report find-path [ init final ]\n  ask init [set dist_d 0]\n  let current init\n  let p_dij []\n  set p_dij insert-item 0 p_dij current \n  show \"dij\"\n  while [not (current = final)] \n  [\n    ask [neighbors with [pcolor = yellow and not (dist_d = -1)]] of current [set dist_d min (list dist_d (1 + [dist_d] of current))]\n    ask current [set dist_d -1]\n    let min_d min [dist_d] of neighbors\n    set current one-of neighbors with [dist_d = min_d and pcolor = yellow]\n    set p_dij insert-item (length p_dij - 1) p_dij current \n  ]\n  ask patches with [pcolor = yellow] [set plabel dist_d set plabel-color red]\n  report p_dij\nend\n```\n\nI'm trying to find the shortest path using Dijkstra's algorithm. There is a problem with the neighbors, every time the program tries to find the next current node, it comes back to init.\n    ", "Answer": "\r\nThis is not a direct answer to your question, and won't help you if you're trying to figure out how to code Dijkstra's algorithm as an exercise for yourself, but if you're just looking for a shortest path, you can always use the ```\nnw:path-to```\n from the network extension.\nThat primitive is actually using Dijkstra's algorithm under the hood.\nIn order to use it, however, you need an actual network, so you would have to use turtles instead of patches. That's easy to do, however. Supposing you have a turtle breed called ```\nnodes```\n, you can put a node on each patch by saying:\n```\nask patches [\n  sprout-nodes 1 [\n    set color pcolor ; give the node the same color as the patch\n    set hidden? true ; hide the node if you prefer not seeing it\n  ]\n]\n```\n\nThen you can create links between, say, yellow nodes:\n```\nask nodes with [ color = yellow ] [\n  create-links-with (nodes-on neighbors) with [ color = yellow ]\n]\n```\n\nThe path from one yellow node another is then just:\n```\nlet yellow-nodes nodes with [ color = yellow ]\nshow [ nw:path-to one-of other yellow-nodes ] of one-of yellow-nodes\n```\n\nIf all you want is the distance, you can use ```\nnw-distance-to```\n instead.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm, getting stuck\r\n                \r\nThis is the first time I've tried to implement Dijkstra's algorithm so maybe I am misunderstanding how it totally works. That said, I am able to get the algorithm to work when all the nodes have the same value 1, however if I change a node to a higher value such as 2 that is close to the start (for instance x=5, y=0) it seems to get stuck thinking there is no solution. If I place a high value further away it seems to work then. I've looked over it several times to see if I missed something, but I am at a loss. Any help on where I may be going wrong is appreciated!\n\n```\nimport sys\nimport copy\n\nclass Node:\n    def __init__(self, x, y, cost, goal, start):\n        self.x = x #pos X\n        self.y = y #pos Y\n        self.goal = goal #goal?\n        self.start = start #start?\n        self.cost = cost #cost of tile\n        self.nodeID = \"{}{}\".format(str(x), str(y)) #unique node identifier\n\nclass NodeRecord:\n    def __init__(self, x, y, cost, goal, start, connection, costSoFar):\n        self.node = Node(x, y, cost, goal, start) #create new node for record\n        self.connection = connection\n        self.costSoFar = costSoFar\n\ndef pathfind(graph, startX, startY, arr):\n    startRecord = NodeRecord(startX, startY, 0, False, True, None, 0)\n\n    openList = []\n    closedList = []\n    openList.append(startRecord)\n\n    while len(openList) > 0:\n        current = smallestElement(openList)\n\n        if current.node.goal == True:\n            break\n\n        connections = getConnections(current, arr) #gets adjacent nodes and stores in connections list\n\n        #search connections for new nodes\n        for connection in connections:\n            endNodeCost = current.costSoFar + connection.node.cost\n\n            if containsNode(connection.node.nodeID, closedList): #closed node, skip\n                continue\n\n            elif containsNode(connection.node.nodeID, openList): #worse route, skip\n                if connection.node.cost <= endNodeCost:\n                    continue\n\n            #new node record found add it to list\n            else:\n                connection.node.goal = goalNode(connection.node.x, connection.node.y, arr)\n\n                if containsNode(connection.node.nodeID, openList) == False:\n                    openList.append(connection)\n\n        #remove the connection from the open list and add it to the closed list\n        tmpNode = openList[0]\n        del openList[0]\n        closedList.append(tmpNode)\n\n    path = []\n    if current.node.goal == False: #there is no possible solution\n        print(\"No solution\\n\")\n\n    else: #compile list of connections\n        while current.node.start == False:\n            path.append(current)\n            current = current.connection\n\n    #for i in closedList:   \n    #   print(\"x: {} y: {} cost: {}\".format(i.node.x, i.node.y, i.node.cost))\n\n    return reversed(path)\n\ndef containsNode(nodeID, nodeList):\n    for record in nodeList:\n        if record.node.nodeID == nodeID:\n            return True\n\n    return False\n\ndef getConnections(current, arr):\n    connections = []\n    lastCost = current.costSoFar\n    x = current.node.x\n    y = current.node.y\n\n    #add any valid connecting nodes from current node\n    if outOfBounds(x + 1, y, arr) == False and arr[y][x + 1] != '#':\n        currCost = getCost(x + 1, y, arr)\n        node = NodeRecord(x + 1, y, currCost, goalNode(x + 1, y, arr), False, current, lastCost + currCost)\n        connections.append(node)\n\n    if outOfBounds(x - 1, y, arr) == False and arr[y][x - 1] != '#':\n        currCost = getCost(x - 1, y, arr)\n        node = NodeRecord(x - 1, y, currCost, goalNode(x - 1, y, arr), False, current, lastCost + currCost)\n        connections.append(node)\n\n    if outOfBounds(x, y + 1, arr) == False and arr[y + 1][x] != '#':\n        currCost = getCost(x, y + 1, arr)\n        node = NodeRecord(x, y + 1, currCost, goalNode(x, y + 1, arr), False, current, lastCost + currCost)\n        connections.append(node)\n\n    if outOfBounds(x, y - 1, arr) == False and arr[y - 1][x] != '#':\n        currCost = getCost(x, y - 1, arr)\n        node = NodeRecord(x, y - 1, currCost, goalNode(x, y - 1, arr), False, current, lastCost + currCost)\n        connections.append(node)\n\n    return connections\n\ndef getCost(x, y, arr):\n    if isNum(arr[y][x]):\n        return int(arr[y][x])\n\n    #no cost for goal\n    elif arr[y][x] == 'G':\n        return 0\n\n    #error\n    return -1\n\ndef isNum(n):\n    try:\n        int(n)\n        return True\n\n    except ValueError:\n        return False\n\ndef goalNode(x, y, arr):\n    if arr[y][x] == 'G':\n        return True\n\n    return False\n\ndef outOfBounds(x, y, arr):\n    if x >= len(arr[0]):\n        return True\n\n    elif x < 0:\n        return True\n\n    if y >= len(arr):\n        return True\n\n    elif y < 0:\n        return True\n\n    return False\n\ndef smallestElement(openList):\n    tmpNode = NodeRecord(None, None, None, None, None, None, None)\n    smallest = 99\n    for i in openList:\n        if i.node.cost < smallest:\n            smallest = i.node.cost\n            tmpNode = i\n\n    return tmpNode\n\ndef getStart(arr):\n    startX = 0\n    startY = 0\n\n    for j in range(0, 4):\n        for i in range(0, 5):\n            if arr[j][i] == 'S':\n                startX = i\n                startY = j\n\n    coords = (startX, startY)\n    return coords\n\ndef main():\n    arr = [[]]\n\n    tmp = ['S', '1', '1', '1', '1', '1', '1', '1', '1', '1']\n    arr[0] = tmp\n    tmp = ['1', '#', '#', '#', '#', '1', '1', '#', '1', '1']\n    arr.append(tmp)\n    tmp = ['1', '#', '1', '1', '1', '#', '1', '#', '1', '1']\n    arr.append(tmp)\n    tmp = ['1', '#', '1', '#', '1', '#', '1', '#', '1', '1']\n    arr.append(tmp)\n    tmp = ['1', '#', '1', '#', '1', '1', '1', '1', '1', '1']\n    arr.append(tmp)\n    tmp = ['1', '#', '1', '#', '#', '#', '#', '#', '#', '#']\n    arr.append(tmp)\n    tmp = ['1', '#', '1', '1', '1', '1', '1', '1', '1', 'G']\n    arr.append(tmp)\n\n    startCoord = getStart(arr)\n    path = pathfind(arr, startCoord[0], startCoord[1], arr)\n    for i in path:\n        arr[i.node.y][i.node.x] = '@'\n\n    for j in range(0, 7):\n        for i in range(0, 10):          \n            sys.stdout.write(arr[j][i])\n        sys.stdout.write(\"\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n    ", "Answer": "\r\nI discovered the problem and wanted to post it for anyone who may could make the same mistake in the future.\nThe issue was with this bit here.\n\n```\n    tmpNode = openList[0]\n    del openList[0]\n    closedList.append(tmpNode)\n```\n\n\nThe first node was being removed and added to the closed list rather than the current node. This is how I corrected it.\n\n```\n    removeNode(current, openList)\n    closedList.append(current)\n\n    ...\n\ndef removeNode(node, openList):\npos = 0\nfor i in openList:\n    if i.node.x == node.node.x and i.node.y == node.node.y:\n        del openList[pos]\n    pos += 1    \n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Will my dicts of dicts work for this Dijkstra's algorithm?\r\n                \r\nI'm pretty new to Python and I'm starting off by trying to implement Dijkstra's algorithm here: http://thomas.pelletier.im/2010/02/dijkstras-algorithm-python-implementation/. The issue is is my matrix looks like this:\n\n```\n    {\n      2845: {27026: {'weight': 0.05950338}, 83860: {'weight': 0.013386887}},\n     12422: {27023: {'weight': 0.0787193}, 27026: {'weight': 0.041424256}, 59721: {'weight': 0.11553069}},\n     27022: {27025: {'weight': 0.1283993}, 83860: {'weight': 0.11746721}},\n     27023: {12422: {'weight': 0.0787193}, 27025: {'weight': 0.22683257}},\n     27025: {27022: {'weight': 0.1283993}, 27023: {'weight': 0.22683257}, 27026: {'weight': 0.20290035}},\n     27026: {2845: {'weight': 0.05950338}, 12422: {'weight': 0.041424256}, 27025: {'weight': 0.20290035}},\n     59721: {12422: {'weight': 0.11553069}},\n     83860: {2845: {'weight': 0.013386887}, 27022: {'weight': 0.11746721}}\n}\n```\n\n\nWill this still work with the above algorithm or will I have to make a slight ajustment and if so, what?\n\nThanks\n\nEDIT:\n\nHere the algorithm I've implemented:\n\n```\ndef dijkstra(self, graph, start, end):\n        D = {} # Final distances dict\n        P = {} # Predecessor dict\n\n        for node in graph.keys():\n            D[node] = -1 # Vertices are unreachable\n            P[node] = \"\"\n        D[start] = 0 # The start vertex needs no move\n        unseen_nodes = graph.keys() # All nodes are unseen\n\n        while len(unseen_nodes) > 0:\n            shortest = None\n            node = ''\n            for temp_node in unseen_nodes:\n                if shortest == None:\n                    shortest = D[temp_node]\n                    node = temp_node\n                elif (D[temp_node] < shortest):\n                    shortest = D[temp_node]\n                    node = temp_node\n            unseen_nodes.remove(node)\n            for child_node, child_value in graph[node].items():\n                if D[child_node] < D[node] + child_value:\n                    D[child_node] = D[node] + child_value\n                    P[child_node] = node\n        path = []\n        node = end\n        while not (node == start):\n            if path.count(node) == 0:\n                path.insert(0, node) # Insert the predecessor of the current node\n                node = P[node] # The current node becomes its predecessor\n            else:\n                break\n        path.insert(0, start) # Finally, insert the start vertex\n        return path\n```\n\n\nThe matrix I'm using is as above, the matrix the algorithm wants is:\n\n```\n... graph = {\n...     'A': {'B': 10, 'D': 4, 'F': 10},\n...     'B': {'E': 5, 'J': 10, 'I': 17},\n...     'C': {'A': 4, 'D': 10, 'E': 16},\n...     'D': {'F': 12, 'G': 21},\n...     'E': {'G': 4},\n...     'F': {'H': 3},\n...     'G': {'J': 3},\n...     'H': {'G': 3, 'J': 5},\n...     'I': {},\n...     'J': {'I': 8},\n... }\n```\n\n    ", "Answer": "\r\nin the given source code example the weight was just an integer, not a dict. Since your graph has a dict with a \"weight\" key, you have to change the code according to that.\n\nhere is the correct version of your code:\n\n```\ndef dijkstra(self, graph, start, end):\n        D = {} # Final distances dict\n        P = {} # Predecessor dict\n\n        for node in graph.keys():\n            D[node] = -1 # Vertices are unreachable\n            P[node] = \"\"\n        D[start] = 0 # The start vertex needs no move\n        unseen_nodes = graph.keys() # All nodes are unseen\n\n        while len(unseen_nodes) > 0:\n            shortest = None\n            node = ''\n            for temp_node in unseen_nodes:\n                if shortest == None:\n                    shortest = D[temp_node]\n                    node = temp_node\n                elif (D[temp_node] < shortest):\n                    shortest = D[temp_node]\n                    node = temp_node\n            unseen_nodes.remove(node)\n            for child_node, child_value in graph[node].items():\n                if D[child_node] < D[node] + child_value['weight']:  # I changed the code here\n                    D[child_node] = D[node] + child_value['weight']   # I changed the code here\n                    P[child_node] = node\n        path = []\n        node = end\n        while not (node == start):\n            if path.count(node) == 0:\n                path.insert(0, node) # Insert the predecessor of the current node\n                node = P[node] # The current node becomes its predecessor\n            else:\n                break\n        path.insert(0, start) # Finally, insert the start vertex\n        return path\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Apply Dijkstra's algorithm in a undirected graph with negative weights\r\n                \r\nCan anyone apply Dijkstra's algorithm in the undirected graph with negative weights above? Even if the algorithm fails.\n\nAdjancency's list:\n\n```\nA -> (B, 3), (C, 2), (D, 4)\nB -> (A, 3), (C, -2), (F, 6)\nC -> (A, 2), (B, -2), (E, 5)\nD -> (A, 4), (E, 3), (F, 2)\nE -> (C, 5), (D, 3), (F, -2)\nF -> (B, 6), (D, 2), (E, -2)\n```\n\n    ", "Answer": "\r\nSeed the traversal list with source node A, and it's cost with 0.  Add an infinite cost for every other node:\n\n```\n{}, [A=0, B=inf, C=inf, D=inf, E=inf, F=inf]\n```\n\n\nThen take the lowest current cost item (I'll call it L) and \"accept\" it into the final cost set (the first pass case has L=source node (A), with a cost of 0).  Check each edge from L calculating the total cost to follow that edge.  If that total cost is less than the traversal list current cost, update the traversal list with the new lower cost.\n\n```\n{A=0}, [B=0+3, C=0+2, D=0+4, E=inf, F=inf]\n```\n\n\nC is now the lowest cost node in the traversal list, so accept C with a cost of 2:\n\n```\n{A=0, C=2}, [B=2-2=0, D=4, E=2+5=7, F=inf]\n```\n\n\nIt's really easy to detect the problem at this point because I just put a cost in the traversal list that is less less than the cost of the node I just accepted (C).  But, unencumbered by reason or logic we carry on:\n\n```\n{A=0, C=2, B=0}, [D=4, E=7, F=0+6]\n{A=0, C=2, B=0, D=4}, [E=7, F=6]\n{A=0, C=2, B=0, D=4, E=7}, [F=7-2=5]\n{A=0, C=2, B=0, D=4, E=7, F=5}\n```\n\n\nDue to the negative cost loops in the graph, the correct final cost array should be:\n\n```\n{A=-inf, B=-inf, C=-inf, D=-inf, E=-inf, F=-inf}\n```\n\n\nBut we already knew that Dijkstra's fails when the graph has negative cost loops...right?\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Unreachable Node in Dijkstra's Algorithm\r\n                \r\nSo I'm having trouble with Dijkstra's algorithm (src to dest). I looked at other answers and could not find the solution to my problem. I have used an adjacency list, thus I have a list for vertices, and each vertex has it's own edge list. My problem arises when I have a node that is unreachable. Specifically, it never gets visited thus I'm stuck in my allNotComp while loop. Can anyone help me with a solution? Code is below.\n\n```\n#include <stdlib.h>\n#include <stdio.h>\nint INFINITY = 9999;\n\nstruct edge\n{\n int vertexIndex;\n int vertexWeight;\n struct edge *edgePtr;\n} edge;\n\nstruct vertex\n{\n int vertexKey;\n struct edge *edgePtr;\n struct vertex *vertexPtr;\n}vertex;\n\nstruct vertex *Start = NULL;\n\nvoid insertEdge(int vertex, int vertex2, int vertexWeight);\n\nvoid insertVertex(int vertexKey);\n\nint allNotComp(int comp[], int size);\n\nvoid printPath(int prev[], int src, int dest, int size);\n\nvoid dijkstra(int src, int size, int dest);\n\nint cost(int curr, int i);\n\nint main(int argc, char * argv[]) {\n\nint k = 1;\nint numVertices = atoi(argv[2]);\nchar* source = argv[3];\nchar* destination = argv[4];\nint src = atoi(argv[3]);\nint dest = atoi(argv[4]);\nStart = &vertex;\nStart->vertexKey = 0;\nStart->vertexPtr = NULL;\nStart->edgePtr = NULL;\nint m = 0;\nint flag = 0;\nint flag2 = 0;\n\nfor(m = 0; m < numVertices; m++){\nif(src == m) {\nflag = 1;\n}\nif(dest == m) {\nflag2 = 1;\n}\n}\nif(!(flag && flag2)) {\nprintf(\"%s \", \"ERROR: Src and/or Dest not valid.\\n\");\nexit(0);\n}\n\nwhile(k < numVertices) {\ninsertVertex(k);\nk++;\n}\n\nFILE *f = fopen(argv[1], \"r\");\nint numbers[numVertices][numVertices];\nchar ch;\nint i = 0;\nint j = 0;\n\n for(m = 0; m < numVertices*numVertices; m++) {\n fscanf(f, \"%d\", &(numbers[i][j]));\n j=j+1;\nif(j == numVertices) {\ni=i+1;\nj=0;\n}\n}\n\n\n\nfor(i=0;i<numVertices;i++) {\nfor(j=0;j<numVertices;j++) {\nif(i == j && numbers[i][j] != 0) {\nprintf(\"%s\", \"ERROR: All diagonals must be zero.\\n\");\nexit(0);\n}\nif(i != j) {\ninsertEdge(i, j, numbers[i][j]);\n}\n}\n}\n\ndijkstra(src, numVertices, dest);\n}\n\nvoid insertEdge(int vertex, int vertex2, int vertexWeight)\n{\nif(vertexWeight == -1) return;\n\nstruct vertex *traverse;\nif(vertex == Start->vertexKey) {\ntraverse = Start;\n}\nelse {\nwhile(traverse->vertexKey != vertex) {\ntraverse = traverse->vertexPtr;\n}\n}\nstruct edge *e,*e1,*e2;\ne=traverse->edgePtr;\nwhile(e&& e->edgePtr)\n{\n    e=e->edgePtr;\n   }\n   e1=(struct edge *)malloc(sizeof(*e1));\n   e1->vertexIndex=vertex2;\n  e1->vertexWeight = vertexWeight;\n    e1->edgePtr=NULL;\n    if(e)\n    e->edgePtr=e1;\n    else\n     traverse->edgePtr=e1;\n}\n\nvoid insertVertex(int vertexKey) {\nstruct vertex *v, *v1, *v2;\nv = Start->vertexPtr;\nwhile(v && v->vertexPtr) {\nv=v->vertexPtr;\n}\nv1=(struct vertex *)malloc(sizeof(*v1));\nv1->vertexKey = vertexKey;\nv1->vertexPtr = NULL;\nv1->edgePtr = NULL;\nif(v) {\nv->vertexPtr = v1;\n}\nelse {\nStart->vertexPtr = v1;\n}\n}\n\nvoid dijkstra(int src, int size, int dest) {\n\nint comp[size];\nint dist[size];\nint prev[size];\nint i;\nfor(i = 0; i<size; i++) {\n    comp[i] = 0;\n    dist[i] = INFINITY;\n    prev[i] = -1;\n    }\ncomp[src] = 1;\ndist[src] = 0;\nprev[src] = src;\nint curr = src;\nint k;\nint minDist;\nint newDist;\nwhile(allNotComp(comp, size)) {\n    minDist = INFINITY;\n    for(i = 0; i<size;i++) {\n        if(comp[i] == 0) {\n            newDist = dist[curr] + cost(curr, i);\n            if(newDist < dist[i]) {\n                    dist[i] = newDist;\n                    prev[i] = curr; }\n                if(dist[i] < minDist) {\n                    minDist = dist[i];\n                    k=i; }\n            }\n        }\ncurr = k;\ncomp[curr] = 1;\n\n    }\n    if(dist[dest] < INFINITY) {\n         printPath(prev, src, dest, size);\n         printf(\":%d\\n\", dist[dest]);\n    } else {\n        printf(\"%s\\n\", \"NO PATH EXISTS BETWEEN THE TWO VERTICES!\");\n    }\n}\n\nint allNotComp(int comp[], int size) {\n    int i;\n    for(i = 0; i < size; i++) {\n        if(comp[i] == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint cost(int curr, int i) {\n    struct vertex *travel;\n    struct edge *traverse;\n\n    travel = Start;\n    while(travel->vertexPtr != NULL) {\n        if(travel->vertexKey != curr) {\n            travel = travel->vertexPtr;\n        }\n        else{\n            break;\n        }\n    }\n\n    traverse = travel->edgePtr;\n    while(traverse->edgePtr != NULL) {\n        if(traverse->vertexIndex != i) {\n            traverse = traverse->edgePtr;\n        }\n        else{\n            break;\n        }\n    }\n    if(traverse->vertexIndex != i) {\n        return INFINITY; \n    }\n\n    return traverse->vertexWeight;\n}\n\nvoid printPath(int prev[], int src, int dest, int size) {\nif(src == dest) {\nprintf(\"%d\", src);\n}\n\nelse {\nprintPath(prev, src, prev[dest], size);\nprintf(\"-%d\", dest);\n}\n\n}\n```\n\n    ", "Answer": "\r\nAlthough an unreachable node never gets visited, this situation can be detected. If the ```\ndist```\ns of all unvisited nodes are ```\nINFINITY```\n, this means all remaining nodes are unreachable, and you should end the loop.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm when all edges have same weight\r\n                \r\nIf all edges had the same weight in a given graph, will Dijkstra's algorithm still find the shortest path between 2 vertices?\nThanks!\n    ", "Answer": "\r\nYes dijkstra algorithm can find the shortest path even when all edges have the same weight. dijkstra has time complexity O((V+E)logV).Instead you should choose BFS algorithm to do the same thing,because BFS has time complexity O(V+E),so BFS is asymptotically faster than dijkstra.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Implementing dijkstra's algorithm in VBA\r\n                \r\nI have a spreadsheet set up with a bunch of distances to different restaurants. For simplicity, lets say all of column ```\nA```\n has the restaurant names / code (Say a code is a number, 2 through XXX). Then, in ```\nB```\n through ```\nXXX - 1```\n there is a number displaying the distance between the restaurant in ```\nA```\n, and the restaurant whose code is the column number.  \n\nHow would I go about implementing dijkstra's algorithm to find the shortest path given 2 user-entered inputs?\n\nSee below for a screenshot of the example spreadsheet:\n\n    ", "Answer": "\r\nWhat you would do is to write VBA code that loops over all the data that have distance information and store them in a proper graph data structure. I am not sure whether your data represent an undirected graph or whether it is just coincidence that you have a lower triangle matrix representation.\n\nAnyway, after having transformed the data in a proper VBA data structure you could take an existing solution and make it work with your data structure. Or, in the first place, you make sure that the data structure fits to an existing solution. You can find a VBA Dijkstra implementation here.\n\nIf you want to implement it yourself, you can find many illustrative examples on the net, like here, to help you understand the algorithm itself.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "What is INT_MAX in Dijkstra's Algorithm?\r\n                \r\nI'm trying to implement Dijkstra's, algorithm, and I have a pretty good grasp of how to do it on a fundamental level, but one thing that's confusing me is INT_MAX. Here's the algorithm I'm following:\n\n```\nDijkstra(start, end)\n     startV = search(start)\n     endV = search(end)\n     startV.solved = true\n     startV.distance = 0\n     solved = {startV} //list of solved vertices\n     while (!endV.solved)\n         minDistance = INT_MAX\n         solvedV = NULL\n         for s in solved\n            for y in s.adjacent\n              if(!y.solved)\n                  dist = s.distance + y.distance\n                  if(dist < minDistance)\n                      solvedV = y\n                      minDistance = dist\n                      parent = s\n     solvedV.distance = minDistance\n     solvedV.parent = parent\n     solvedV.solved = true\n\n     solved.add(solvedV)\n```\n\n\nWhy would something called the minDistance be calculated using something called INT_MAX if you're trying to find the shortest path? And how do you find INT_MAX? If it affects the answer at all, I'm using C++ and my vertices are structs. But it is for homework, so no code for answers, please.\n    ", "Answer": "\r\n```\nINT_MAX```\n is a constant that represents the highest possible value that an ```\nint```\n can store.\nIt is found in \"limits.h\"\nhttp://www.cplusplus.com/reference/climits/\n\nWhen you want to find the shortest distance of something, you want to compare the currently evaluated distance with the shortest distance you've found \"so far\", and see if you've found a shorter one.\nThis usually involves starting with the longest possible distance as a temporary starting point, so that any distance you find will automatically be shorter.\n\nAs you can see, further down, there is a statement, ```\nif (dist < minDistance)```\n, which will always be ```\ntrue```\n the first time, since any valid distance is effectively guaranteed to be shorter than the maximum possible distance value, ```\nINT_MAX```\n.\n\nThe same idea is used in many similar algorithms where you want to find the highest or lowest value: We initialize to the worst possible value (contextually), so that the first valid value found will be accepted.\n\nConsider what would happen if we didn't write ```\nINT_MAX```\n, but some other, lower number. The consequence is that you would have entered what amounts to a fake value that will effectively compete with the real values that you're testing for. Therefore, you always want the initial \"fake\" value to be guaranteed to fail a comparison with any real value.\n\nFurthermore, if at the end of the algorithm the shortest distance found is still equal to ```\nINT_MAX```\n, then you know that the function/algorithm found no valid distances at all. For example, the function might simply return ```\nminDistance```\n, and nothing else, and then the caller can check to see it if is equal to ```\nINT_MAX```\n to know whether the function succeeded or not. (I'm not implying that this would be the best design.)\n\n```\nconst int result(getMinDistance(whatever));\nif (result == INT_MAX) // no real \"minDistance\" was actually found.\nelse ... // found some real \"minDistance\" value.\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "CodeFights: Dijkstra's Algorithm implementation\r\n                \r\nConsidering this code fight problem:\n\nConsider a big city located on n islands. There are bridges connecting the islands, but they all have only one-way traffic. To make matters worse, most of the bridges are closed at night, so there is at most one bridge with traffic going from any island A to any other island B.\nThere is a programmer who turns a penny by working nights as an Uber driver. One night his phone dies right after he picks up a rider going from island 0 to island (n - 1). He has the map of the city bridges in his laptop though (stored as a matrix of distances), so he decides to implement an algorithm that calculates the shortest path between those two islands and evaluate the cost based on the distance of the path. Assume that each mile of the trip is 1$.\n\nI have decided to implement Dijkstra's algorithm to solve it:\n```\ndef nightRoute(city):\n    visited = [];\n    visited.append(0);\n    distance = [];\n    for x in range(0, len(city)):\n        distance.append(float(\"inf\"));\n    distance[0] = 0;\n    \n    while(len(visited) != len(city)):\n        for i in visited:\n            print visited;\n            min = float(\"inf\");\n            minNode = -1;\n            for j in range(0, len(city)):\n                if ( j not in visited and city[i][j] != -1):\n            if distance[j] > distance[i] + city[i][j]:\n            distance[j] = distance[i] + city[i][j]\n                    if distance[i] + city[i][j] <= min:\n                        min = distance[i] + city[i][j];\n                        minNode = j\n            if(min != float(\"inf\") and minNode != -1):\n                visited.append(minNode);\n    return distance[len(city)-1];\n```\n\nHowever when I run the code, it only passes 6/7 test cases (the last 3 test cases are hidden to me so i don't know what the inputs are).\nCan anyone tell me what is wrong with my implementation of dijkstra's? Am i missing something in how dijkstras work?\n    ", "Answer": "\r\nYou should find the visited node contains the minimum key (distance) in each iteration, instead of trying all visited nodes. Although the relaxation is still safe, you may put some of the nodes not having the optimal key to the visited set, hence compromises the result.\n\nFurthermore, although I don't think this will change the result, it would be better to avoid comparing two float numbers using ```\n==```\n or ```\n!=```\n.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How to adapt Dijkstra's algorithm to work with weighted graph\r\n                \r\nThis piece of code works to implement Dijkstra's algorithm for unweighted graph. What should I change to work with a weighted graph? The edges of my graph are double values, there's any chance to use generic types in shortestPath method?\n\n```\n   /**\n     * Determine the shortest path to all vertices from a vertex using Dijkstra's algorithm\n     * To be called by public short method\n     *\n     * @param graph Graph object\n     * @param sourceIdx Source vertex \n     * @param knownVertices previously discovered vertices\n     * @param verticesIndex index of vertices in the minimum path\n     * @param minDist minimum distances in the path\n     *\n     */\n    private static <V> void shortestPath(AdjacencyMatrixGraph<V,Double> graph, int sourceIdx, boolean[] knownVertices, int[] verticesIndex, double [] minDist)  {  \n        V vertexOrig = graph.vertices.get(sourceIdx);\n        Queue<V> qaux = new LinkedList<V>();\n        for(int i = 0; i < graph.numVertices; i++) {\n            minDist[i] = 0;\n            verticesIndex[i] = -1;\n        }\n        qaux.add(vertexOrig);\n        while(!qaux.isEmpty()) {\n            V vertex = qaux.remove();\n            for (V vertexAdj: graph.directConnections(vertex)) {\n                if(minDist[graph.toIndex(vertexAdj)] == 0) {\n                    minDist[graph.toIndex(vertexAdj)] = minDist[graph.toIndex(vertex)] \n                            + graph.getEdge(vertex, vertexAdj);\n                    verticesIndex[graph.toIndex(vertexAdj)] = graph.toIndex(vertex);\n                    qaux.add(vertexAdj);\n                } \n            }\n        }\n    }\n\n\n    /**\n     * Determine the shortest path between two vertices using Dijkstra's algorithm\n     *\n     * @param graph Graph object\n     * @param source Source vertex \n     * @param dest Destination vertices\n     * @param path Returns the vertices in the path (empty if no path)\n     * @return minimum distance, -1 if vertices not in graph or no path\n     *\n     */\n    public static <V> double shortestPath(AdjacencyMatrixGraph<V, Double> graph, V source, V dest, LinkedList<V> path){\n        path.clear();\n        if(!graph.checkVertex(source) || !graph.checkVertex(dest)) return -1;\n        else if(source.equals(dest)) {\n            path.add(dest);\n            return 0;\n        }\n        double minDist[] = new double[graph.numVertices];\n        int verticesIndex[] = new int[graph.numVertices];\n\n        shortestPath(graph, graph.toIndex(source), new boolean[graph.numVertices]\n        , verticesIndex, minDist);\n\n        if(verticesIndex[graph.toIndex(source)] == -1 || verticesIndex[graph.toIndex(dest)] == -1) return -1;\n\n        recreatePath(graph, graph.toIndex(source), graph.toIndex(dest), verticesIndex, path);\n        Collections.reverse(path);\n        System.out.println(path);\n        System.out.println(minDist[graph.toIndex(dest)]);\n        return minDist[graph.toIndex(dest)];\n    }\n\n\n    /**\n     * Recreates the minimum path between two vertex, from the result of Dikstra's algorithm\n     * \n     * @param graph Graph object\n     * @param sourceIdx Source vertex \n     * @param destIdx Destination vertices\n     * @param verticesIndex index of vertices in the minimum path\n     * @param Queue Vertices in the path (empty if no path)\n     */\n    private static <V> void recreatePath(AdjacencyMatrixGraph<V, Double> graph, int sourceIdx, int destIdx, int[] verticesIndex, LinkedList<V> path){\n\n        path.add(graph.vertices.get(destIdx));\n        if (sourceIdx != destIdx){\n            destIdx = verticesIndex[destIdx];        \n            recreatePath(graph, sourceIdx, destIdx, verticesIndex, path);\n        }\n    }\n```\n\n    ", "Answer": "\r\nDijkstra's algorithm works with weighted graphs to compute the shortest path from a vertex to all other vertices in a graph provided there are no negative edge lengths in the graph. So there is no need to change the implementation of Dijkstra's to make it work with weighted graph. If it doesn't work with weighted graph then the problem lies with the implementation of Dijkstra.\n\nIf the graph is unweighted you are better off using the Breadth first search which runs in linear time to compute the distance between nodes. \n\nDijkstra's algorithm is a greedy algorithm that works by keeping track of the vertices that has to be expanded ordered by it's cost. i.e. The next vertex that will get expanded is the vertex having the next minimum cost. \n\nThis is something we need not do with BFS as all the edge weights are the same. Why use Dijkstra's Algorithm if Breadth First Search (BFS) can do the same thing faster? shows the difference between the both \n\nWith your implementation I see you are using a ```\nQueue```\n to keep track of the vertices yet to be explored. This does not ensure that the next vertex that is expanded has the minimum cost and thus your algorithm will fail. \n\nSo every time you pick a vertex from the ```\nQueue```\n to expand it should be the one with the minimum cost. This can be achieved by iterating through the ```\nQueue```\n every time and picking up the vertext with minimum cost, although this might reduce it to a ```\nO(n^2)```\n algorithm or use heap data structure that ensures that the next picked vertex is always the one with the least weight. \n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm on directed acyclic graph with negative edges\r\n                \r\nWill Dijkstra's algorithm work on a graph with negative edges if it is acyclic (DAG)? I think it would because since there are no cycles there cannot be a negative loop. Is there any other reason why this algorithm would fail?\n\nThanks [midterm tomorrow]\n    ", "Answer": "\r\nConsider the graph (directed ```\n1 -> 2, 2-> 4, 4 -> 3, 1 -> 3, 3 -> 5```\n):\n\n```\n  1---(2)---3--(2)--5\n  |         |\n (3)      (2)\n  |         |  \n  2--(-10)--4\n```\n\n\nThe minimum path is ```\n1 - 2 - 4 - 3 - 5```\n, with cost ```\n-3```\n. However, Dijkstra will set ```\nd[3] = 2, d[2] = 3```\n in the first step, then extract node ```\n3```\n from its priority queue and set ```\nd[5] = 4```\n. Since node 3 was extracted from the priority queue, and Dijkstra does not push a given node to its priority queue more than once, it will never end up in it again, so the algorithm won't work.\n\nDijkstra's algorithm does not work with negative edges, period. The absence of a cycle changes nothing. Bellman-Ford is the one that can detect negative cost cycles and works with negative edges. Dijkstra will not work if you can have negative edges.\n\nIf you change Dijkstra's algorithm such that it can push a node to the priority queue more than once, then the algorithm will work with negative cost edges. But it is debatable if the new algorithm is still Dijkstra's: I would say you get Bellman-Ford that way, which is often implemented exactly like that (well, usually a FIFO queue is used and not a priority queue).\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Is this efficiency correct for Dijkstra's algorithm?\r\n                \r\nI have a version of Dijkstra's algorithm that I'm trying to determine the efficiency for. I'm not quite sure I have this correct and was wondering if I got it right.\n\nI know that the priority queue versions have better efficiency. I'll put down the pseudocode, and then the java code below in case I left something out.\n\nPlease see comments in pseudocode for where this is coming from:\n```\nO(E^2 * V^2)```\n\n\n```\nDijkstraAlgorithm Pseudocode class\n\n\nexecute method\n\nInput: Source vertex for graph\nOutput: None\n\nwhile (unvisited vertexes != 0) {    //----> O(V)\n    node := getMinimum unvisited\n    visitedNodes.add(node)\n    unvisitedNodes.remove(node)\n    findMinimalDistances(node) }\n\n\nfindMinimalDistances method\n\nInput: Vertex\nOutput: None\n\nadjacentNodes := getAdjacent(node)\nfor(target to adjacentNodes) {\n    if (getShortestDistance(target) > getShortestDistance(node) + getDistance(node,target)) {\n        distance.put(target, distance)\n        predecessors.put(target, node)\n        unvisitedNodes.add(target) }\n}\n\n\ngetDistance method\n\nInput: Vertex being evaluated and target vertex\nOutput: Integer distance\n\nfor (edge to edges) {                      //--------------> O(E)\n    if (edge.source(node) && edge.destination(target)) {\n        return edge.getWeight }\n}\n\n\ngetAdjacent method\n\nInput: Vertex to find ajacent vertexes\nOutput: ArrayList of adjacent vertexes\n\nfor (edge to edges) {         // -----------------> O(E)\n    if (edge.getSource.equals(node) && is not visited)\n        neighbors.add(node)\n}\n\n\ngetMinimum method\n\nInput: ArrayList of unvisited vertexes\nOutput: Minimum vertex\n\nfor (vertex to vertexes) {      //---------> O(V)\n    if (minimum = null)\n        minimum := vertex\n    else\n        if (getShortestDistance(vertex) < getShortestDistance(minimum))\n            minimum := vertex\n}\n\n\ngetShortestDistance method\n\nInput: Node to find shortest distance to source\nOutput: Integer distance\n\nd := distance.get(node)\nif (d = null)\n    return Infinity\nelse\n    return d\n```\n\n\nCode below:\n\n```\npackage shortestPath;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class DijkstraAlgorithm {\n\n    private final List<Vertex> nodes;\n    private final List<Edge> edges;\n    private Set<Vertex> visitedNodes;\n    private Set<Vertex> unvisitedNodes;\n    private Map<Vertex, Vertex> predecessors;\n    private Map<Vertex, Integer> distance;\n\n    public DijkstraAlgorithm(Graph graph) {\n\n        // create a copy of the array so that we can operate on this array\n        this.nodes = new ArrayList<Vertex>(graph.getVertexes());\n        this.edges = new ArrayList<Edge>(graph.getEdges());\n    }\n\n    public void execute(Vertex source) {\n        visitedNodes = new HashSet<Vertex>();\n        unvisitedNodes = new HashSet<Vertex>();\n\n        // Create hashmap for shortest distance to each node\n        distance = new HashMap<Vertex, Integer>();\n\n        predecessors = new HashMap<Vertex, Vertex>();\n\n        // Start with the source node\n        distance.put(source, 0);\n        unvisitedNodes.add(source);\n\n        // While there are still unvisited nodes\n        while (unvisitedNodes.size() > 0) { \n\n            // Hold minimum unvisited node\n            Vertex node = getMinimum(unvisitedNodes);\n\n            visitedNodes.add(node);\n            unvisitedNodes.remove(node);\n\n            // Put the node's distance in the distance map\n            findMinimalDistances(node);\n        }\n    }\n\n    // Find shortest distance from current minimum node to neighbors\n    private void findMinimalDistances(Vertex node) {\n\n        // Initialize list to find adjacent nodes\n        List<Vertex> adjacentNodes = getAdjacent(node);\n\n        // Cycle through neighbors\n        for (Vertex target : adjacentNodes) {\n\n            // If i is greater than the node current shortest distance + the distance from node to i\n            if (getShortestDistance(target) > getShortestDistance(node) + getDistance(node, target)) {\n\n                // Update i node to shorter distance in distance map\n                distance.put(target, getShortestDistance(node) + getDistance(node, target));\n                predecessors.put(target, node);\n                unvisitedNodes.add(target);\n            }\n        }\n    }\n\n    // Gets distance of node to target vertex\n    private int getDistance(Vertex node, Vertex target) {\n\n        // Cycle through all edges\n        for (Edge edge : edges) {\n\n            // If edge begins at node and ends at target get the distance\n            if (edge.getSource().equals(node) && edge.getDestination().equals(target)) {\n                return edge.getWeight();\n            }\n        }\n        throw new RuntimeException(\"Should not happen\");\n    }\n\n    // Find adjacent nodes to input node and return arraylist of neighbors\n    private List<Vertex> getAdjacent(Vertex node) {\n        List<Vertex> neighbors = new ArrayList<Vertex>();\n\n        // Cycle through all edges\n        for (Edge edge : edges) {\n\n            // If edge source is the input node and destination node of edge is not in visited list\n            //    add as neighbor\n            if (edge.getSource().equals(node) && !isVisited(edge.getDestination())) {\n                neighbors.add(edge.getDestination());\n            }\n        }\n        return neighbors;\n    }\n\n    // Returns minimum of unvisited nodes\n    private Vertex getMinimum(Set<Vertex> vertexes) {\n\n        // First pass initialize minimum node to null\n        Vertex minimum = null;\n\n        // Cycle through entire unvisited list for minimum unvisited node\n        //   --> Note: Minimum unvisited node on first iteration is (source node, 0 distance)\n        for (Vertex vertex : vertexes) {\n\n            // If minimum is set to null (first pass), set minimum to first unvisited node\n            if (minimum == null) {\n                minimum = vertex;\n\n            // Else if next node is less, set it to minimum\n            } else {\n                if (getShortestDistance(vertex) < getShortestDistance(minimum)) {\n                    minimum = vertex;\n                }\n            }\n        }\n        return minimum;\n    }\n\n    private boolean isVisited(Vertex vertex) {\n        return visitedNodes.contains(vertex);\n    }\n\n    // Get shortest distance of node from source\n    private int getShortestDistance(Vertex destination) {\n\n        // Set d equal to the distance assigned to the node currently in distance map, if available\n        Integer d = distance.get(destination);\n\n        // If node not yet added to distance map\n        if (d == null) {\n\n            // Return infinity\n            return Integer.MAX_VALUE;\n\n        // Else return distance assigned to that node\n        } else {\n            return d;\n        }\n    }\n\n    /*\n     * This method returns the path from the source to the selected target and\n     * NULL if no path exists\n     */\n    public LinkedList<Vertex> getPath(Vertex target) {\n\n        LinkedList<Vertex> path = new LinkedList<Vertex>();\n        Vertex step = target;\n\n        // check if a path exists\n        if (predecessors.get(step) == null) {\n            return null;\n        }\n        path.add(step);\n        while (predecessors.get(step) != null) {\n            step = predecessors.get(step);\n            path.add(step);\n        }\n        // Put it into the correct order\n        Collections.reverse(path);\n        return path;\n    }\n\n} \n```\n\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Can Dijkstra's algorithm be applicable to the Travelling Salesman Problem?\r\n                \r\nThis is a general query. Dijkstra's algorithm is able to find the shortest distances between each of the nodes while the TSP problem says to start and end on the same node by traveling each node at least once with the shortest path.\nIs there any way I can solve it using Dijkstra's algorithm approach because I am unable to implement the complex approach using dynamic programming?\n    ", "Answer": "\r\nDijkstra's algorithm can be used but it doesn't help (a lot).\nFirst you need to see that the graph you \"need to use\" to find a solution is not the input graph ```\nG=<V,E>```\n but a graph which is derived from the input graph. Which can be \n```\nGd=<Vd,Ed>```\n where ```\nVd```\n is a ordered subset of ```\nV```\n and ```\nEd```\n is a pair from ```\nVd```\n, where an edge '([v1,..,vn],[v1,..,vn,vm]) in ```\nEd```\n exists if ```\n(vn,vm)\\in E```\n.\nNow the cost of an edge in ```\nGd```\n correspond to the cost in ```\nG```\n. A node is a goal state when it contains all nodes from ```\nG```\n\n\nBrute-force Depth/Bredth/Iterative would work. How about dijkstra. You need to have \n\n\n  a consistent heuristic which estimate is always less than or equal to\n  the estimated distance from any neighboring vertex to the goal, plus\n  the step cost of reaching that neighbor.\n\n\nObviously, the constant zero is such a heuristic. Can you get a better heuristic?\nNot really due to the NP nature of TSP. Interestingly in real world problems you can sometimes find in-consistent heuristics, which still produce good results.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm With Large Weights\r\n                \r\nI am trying to solve a question on an online judge about calculating all shortest paths on a complete graph. Full problem specifications can be seen  here. However, I am exceeding the memory limit required. Here is the part of the code that does Dijkstra's algorithm:\n\n```\nn = int(raw_input())\ndict1 = [[\"\"for i in xrange(n+1)]for j in xrange(n+1)]\nedges = [0]\nfor i in xrange(n):\n    x,y = map(int, raw_input().split())\n    edges.append((x,y))\n\nfor i,coord1 in enumerate(edges):\n    for j,coord2 in enumerate(edges):\n        if i==j or i==0 or j==0:\n            continue\n\n        x1,y1 = coord1\n        x2,y2 = coord2\n        weight = (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2)\n        dict1[i][j] = weight\n        dict1[j][i] = weight\n\nx = int(raw_input())\ntimes = []\nvertices = {i:1e13 if i!= x else 0 for i in xrange(1,n+1)}\nwhile len(vertices)>0:\n    minimum = min(vertices.items(), key=lambda x: x[1])[0]\n    currentCost = vertices[minimum]\n    times.append(currentCost)\n    del vertices[minimum]\n\n    for neighbour,newWeight in enumerate(dict1[minimum]):\n        if neighbour in vertices and newWeight != \"\":\n            if currentCost + newWeight < vertices[neighbour]:\n                vertices[neighbour] = currentCost + newWeight\n```\n\n\nThe code uses the original algorithm without the priority queue because of the better time complexity. Even though this gives the right answer, I have a feeling the memory exceeding has something to do with the way I am storing the weights, considering they can be as large as 10^12. Is there another way I can store the weights that will use less memory, or is something else causing the problem?\n    ", "Answer": "\r\nYour problem has nothing to do with big weights (```\n10^12```\n is not a big number). If you want to see that this is the case (try dividing them by some number like ```\n1000```\n to see that it will fail as well).\n\nThe problem is that you do not use priority queue and this deteriorate the time complexity to ```\nO(V^2)```\n and if you will use a priority queue, you will get ```\nO(E + V log(V))```\n.\n\nSo implement a normal Dijkstra and will get your answer accepted.\n\n\n\nSorry, have not read that this is a planar graph and that it is dense. Knowing that your graph consists of 2d points, you can take advantage of the distance heuristics and use A* algorithm.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "implementing dijkstra's algorithm using a priority queue\r\n                \r\nSo I'm trying to implement Dijkstra's algorithm. I understand Dijkstra's works, but I struggle to turn the concept into code. I have what I thought would be the correct code, I'm getting an out-of-memory exception on the java heap space, and I'm not sure why. I also just lost all confidence in my implementation, so any feedback would be great\n```\n    protected Path dijkstrasShortestPath(T start, T end) {\n        if (start == null || end == null) {\n            throw new NoSuchElementException(\"Vertices cannot have null data\");\n        }\n        if (vertices.get(start) == null || vertices.get(end) == null) {\n            throw new NoSuchElementException(\"Vertices do not exist\");\n        }\n        PriorityQueue<Path> pq = new PriorityQueue<Path>();\n        LinkedList<Vertex> visited = new LinkedList<Vertex>();\n        Path startPath = new Path(vertices.get(start));\n        visited.add(startPath.start);\n        pq.add(startPath);\n        while (!pq.isEmpty()) {\n            Path front = pq.poll();\n            visited.add(front.end);\n            if (front.end.data.equals(end)) {\n                return front;\n            } else {\n                for (int i = 0; i < front.end.edgesLeaving.size(); i++) {\n                    if (!visited.contains(front.end.edgesLeaving.get(i).target)) {\n                        pq.add(new Path(front, front.end.edgesLeaving.get(i)));\n                    }\n                }\n            }\n        }\n\n        throw new NoSuchElementException(\"No such path from start to end exists\");\n    }\n```\n\nthese are some other classes and fields that I use\n```\n/**\n     * Vertex objects group a data field with an adjacency list of weighted\n     * directed edges that lead away from them.\n     */\n    protected class Vertex {\n        public T data; // vertex label or application specific data\n        public LinkedList<Edge> edgesLeaving;\n\n        public Vertex(T data) {\n            this.data = data;\n            this.edgesLeaving = new LinkedList<>();\n        }\n    }\n\n    /**\n     * Edge objects are stored within their source vertex, and group together\n     * their target destination vertex, along with an integer weight.\n     */\n    protected class Edge {\n        public Vertex target;\n        public int weight;\n\n        public Edge(Vertex target, int weight) {\n            this.target = target;\n            this.weight = weight;\n        }\n    }\n\n    protected Hashtable<T, Vertex> vertices; // holds graph verticies, key=data\n```\n\nand this is the path class\n```\n/**\n     * Path objects store a discovered path of vertices and the overall distance of cost\n     * of the weighted directed edges along this path. Path objects can be copied and extended\n     * to include new edges and vertices using the extend constructor. In comparison to a\n     * predecessor table which is sometimes used to implement Dijkstra's algorithm, this\n     * eliminates the need for tracing paths backward from the destination vertex to the\n     * starting vertex at the end of the algorithm.\n     */\n    protected class Path implements Comparable<Path> {\n        public Vertex start; // first vertex within path\n        public int distance; // sumed weight of all edges in path\n        public List<T> dataSequence; // ordered sequence of data from vertices in path\n        public Vertex end; // last vertex within path\n\n        /**\n         * Creates a new path containing a single vertex.  Since this vertex is both\n         * the start and end of the path, its initial distance is zero.\n         * @param start is the first vertex on this path\n         */\n        public Path(Vertex start) {\n            this.start = start;\n            this.distance = 0;\n            this.dataSequence = new LinkedList<>();\n            this.dataSequence.add(start.data);\n            this.end = start;\n        }\n\n        /**\n         * This extension constructor makes a copy of the path passed into it as an argument\n         * without affecting the original path object (copyPath). The path is then extended\n         * by the Edge object extendBy.\n         * @param copyPath is the path that is being copied\n         * @param extendBy is the edge the copied path is extended by\n         */\n        public Path(Path copyPath, Edge extendBy) {\n            this.start = copyPath.start;\n            this.start.edgesLeaving.add(extendBy);\n            this.distance = extendBy.weight + copyPath.distance;\n            this.dataSequence = new LinkedList<>();\n            for (int i = 0; i < copyPath.dataSequence.size(); i++) {\n                this.dataSequence.add(copyPath.dataSequence.get(i));\n            }\n            this.end = extendBy.target;\n            this.dataSequence.add(end.data);\n        }\n\n        /**\n         * Allows the natural ordering of paths to be increasing with path distance.\n         * When path distance is equal, the string comparison of end vertex data is used to break ties.\n         * @param other is the other path that is being compared to this one\n         * @return -1 when this path has a smaller distance than the other,\n         *         +1 when this path has a larger distance than the other,\n         *         and the comparison of end vertex data in string form when these distances are tied\n         */\n        public int compareTo(Path other) {\n            int cmp = this.distance - other.distance;\n            if(cmp != 0) return cmp; // use path distance as the natural ordering\n            // when path distances are equal, break ties by comparing the string\n            // representation of data in the end vertex of each path\n            return this.end.data.toString().compareTo(other.end.data.toString());\n        }\n    }\n```\n\n    ", "Answer": "\r\nI didn't look deeply into the code and I don't remember how ```\ndijkstra```\n works, but it seems to me very suspicious that you do not have ```\nequals```\n and ```\nhashCode```\n defined for your classes. I didn't find where you may use it but maybe I've overlooked.\nAlso you have this line: ```\nif (front.end.data.equals(end)) {```\n\n\nHere we may have a problem in case when ```\nT```\n does not have ```\nequals```\n overload. I'm not sure, which type you use for data, so it may or may not be a problem.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm implementation giving incorrect results\r\n                \r\nI need some help implementing Dijkstra's Algorithm and was hoping someone would be able to assist me. I have it so that it is printing some of routes but it isn't capturing the correct costs for the path.\n\nHere is my node structure:\n\n```\n   class Node\n    {\n        public enum Color {White, Gray, Black};\n        public string Name { get; set; } //city\n        public List<NeighborNode> Neighbors { get; set; } //Connected Edges\n        public Color nodeColor = Color.White;\n        public int timeDiscover { get; set; }//discover time\n        public int timeFinish { get; set; } // finish time\n\n        public Node() \n        { \n            Neighbors = new List<NeighborNode>();\n        }\n        public Node(string n, int discover)\n        {\n            Neighbors = new List<NeighborNode>();\n            this.Name = n;\n            timeDiscover = discover;\n        }\n\n\n        public Node(string n, NeighborNode e, decimal m)\n        {\n            Neighbors = new List<NeighborNode>();\n            this.Name = n;\n            this.Neighbors.Add(e);\n        }\n\n    }\n\n    class NeighborNode\n    {\n        public Node Name { get; set; }\n        public decimal Miles { get; set; } //Track the miles on the neighbor node\n\n        public NeighborNode() { }\n        public NeighborNode(Node n, decimal m)\n        {\n            Name = n;\n            Miles = m;\n        }\n\n    }\n```\n\n\nHere is my algorithm:\n\n```\n   public void DijkstraAlgorithm(List<Node> graph)\n    {\n\n        List<DA> _algorithmList = new List<DA>(); //track the node cost/positioning\n        Stack<Node> _allCities = new Stack<Node>(); // add all cities into this for examination\n        Node _nodeToExamine = new Node(); //this is the node we're currently looking at.\n        decimal _cost = 0;\n\n        foreach (var city in graph) // putting these onto a stack for easy manipulation. Probably could have just made this a stack to start\n        {\n            _allCities.Push(city);\n            _algorithmList.Add(new DA(city));\n        }\n\n        _nodeToExamine = _allCities.Pop(); //pop off the first node\n\n        while (_allCities.Count != 0) // loop through each city\n        {\n\n            foreach (var neighbor in _nodeToExamine.Neighbors) //loop through each neighbor of the node\n            {\n                for (int i = 0; i < _algorithmList.Count; i++) //search the alorithm list for the current neighbor node\n                {\n                    if (_algorithmList[i].Name.Name == neighbor.Name.Name) //found it\n                    {\n                        for (int j = 0; j < _algorithmList.Count; j++) //check for the cost of the parent node\n                        {\n                            if (_algorithmList[j].Name.Name == _nodeToExamine.Name) //looping through\n                            {\n                                if (_algorithmList[j].Cost != 100000000) //not infinity\n                                    _cost = _algorithmList[j].Cost; //set the cost to be the parent cost\n\n                                break;\n                            }\n                        }\n                        _cost = _cost + neighbor.Miles;\n\n                        if (_algorithmList[i].Cost > _cost) // check to make sure the miles are less (better path)\n                        {\n                            _algorithmList[i].Parent = _nodeToExamine; //set the parent to be the top node\n                            _algorithmList[i].Cost = _cost; // set the weight to be correct\n                            break;\n                        }\n                    }\n                }\n\n            }\n            _cost = 0;\n            _nodeToExamine = _allCities.Pop();\n        }\n    }\n```\n\n\nThis is what the graph looks like:\n\n\nThe graph list node is essentially \n\n\n  Node -- Neighbor Nodes\n\n\nSo for example:\n\n\n  Node = Olympia, Neighbor Nodes = Lacey and Tacoma\n\n    ", "Answer": "\r\nI think the problem is that\n\n```\n_cost = _algorithmList[j].Cost; //set the cost to be the parent cost```\n\n\nYou do a direct assignment of cost, instead of an addition of old and new cost.\n\nAlso, the fact that you do\n\n```\nif (_algorithmList[j].Cost != 100000000) //not infinity```\n\n\ndirectly before it means that if the cost of the path is infinity, you do the very opposite - you add zero to the cost of the path, making it the least expensive instead of most expensive path.\n\nIf you want to check for infinity properly, you have to outright skip taking that path when you inspect its cost, not just skip calculating the cost.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Difference between Dynamic programming and Dijkstra's Algorithm [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is off-topic. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it's on-topic for Stack Overflow.\r\n                \r\n                    \r\n                        Closed 10 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nCan any one please clarify does Dijkstra's Algorithm come under Dynamic Programming or not. Why do we call that Floyd warshall algorithm comes under Dynamic programming approach. I am not able to trace out the difference between them. When i tried doing this i actually encountered a doubt that what exactly Dynamic programming means? And also Dijkstra's is quoted as Greedy approach does that mean it is not always correct? Moreover does the result for this two algorithms differ? Can any one explain in detail please.\n    ", "Answer": "\r\nDynamic programming is where you inductively use sub-problems to solve the problem.\n\nOn the other hand, greedy algorithms try to solve a global optimization problem by making locally optimal steps. Sometimes these local steps take you to the global optimum (as in the case of Dijkstra's algorithm) and sometimes it may not (like in the change making problem).\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Error in the implementation of Dijkstra's algorithm\r\n                \r\nHelp with Dijkstra's algorithm. The essence of the task: it is necessary to find the most likely way. Probability multiplication is used here.\nInput:\n```\n100, 9900, 1, 100```\n (Number of vertices, number of arcs, start vertex and end vertex)\n```\n1, 2, 0.3```\n (start vertex, end vertex and probability of passing a path)\n...\n\nMy Result:\n\n```\n35, 35, 3, 54, 98, 100 (most likely successful path)\n0.9577 (probability of passage).\n```\n\n\nCorrect result:\n\n```\n1, 92, 35, 3, 54, 98, 100\n0.9577 \n```\n\n\nI think this part of the code is not working correctly (building the shortest path):\n\n```\n while (i!=0):\n            for j in range(end, -1, -1):\n                if (ves[i]!=0.0 and round(weight[i] / ves[i],6) == weight[j] and i<=test):\n                    result.append(j+1)\n                    test=j\n            i -= 1\n```\n\n\nWhole code:\n\n```\ndef Dijkstra(N, S, matrix, end):\n    valid = [True] * N\n    weight = [0.01] * N\n    weight[S] = 1.0\n    ves=[0.0]*N\n    result=[]\n    for i in range(N):\n        min_weight = 0.0\n        ID_min_weight = 0.0\n        for i in range(len(weight)):\n            if valid[i] and weight[i] > min_weight:\n                min_weight = weight[i]\n                ID_min_weight = i\n        for i in range(N):\n            if (round(weight[ID_min_weight] * matrix[ID_min_weight][i],6) > weight[i] and i<end+1):\n                weight[i] = round(weight[ID_min_weight] * matrix[ID_min_weight][i],6)\n                ves[i]=matrix[ID_min_weight][i]\n        valid[ID_min_weight] = False\n\n    result.append(end + 1)\n    i = end\n    test = end\n    while (i!=0):\n        for j in range(end, -1, -1):\n            if (ves[i]!=0.0 and round(weight[i] / ves[i],6) == weight[j] and i<=test):\n                result.append(j+1)\n                test=j\n        i -= 1\n\n\n    result.reverse()\n    print (*result)\n\n    return round(weight[end],4)\n\nstr=[]\nmatrix2=[]\nfor i in input().split():\n    str.append(int(i))\n\nN = str[0]   \nM = str[1]   \nbegin = str[2]  \nend = str[3]    \n\nmatrix = [[float (j) for j in input().split()] for i in range(M)]\n\nfor i in matrix:\n    if len(i)>3:\n        exit()\n\nfor i in range(N):\n    matrix2.append([])\n    for j in range(N):\n        matrix2[i].append(0.01)\n\nfor i in range(M):\n    matrix2[int(matrix[i][0]-1)][int(matrix[i][1]-1)] = matrix[i][2]\n\nprint(Dijkstra(N, begin-1, matrix2,end-1))\n```\n\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Why can't we apply Dijkstra's algorithm for a graph with negative weights?\r\n                \r\nWhy can't we apply Dijkstra's algorithm for a graph with negative weights?\n    ", "Answer": "\r\nWhat does it mean to find the least expensive path from A to B, if every time you travel from C to D you get paid?\n\nIf there is a negative weight between two nodes, the \"shortest path\" is to loop backwards and forwards between those two nodes forever. The more hops, the \"shorter\" the path gets.\n\nThis is nothing to do with the algorithm, and all to do with the impossibility of answering such a question.\n\nEdit:\n\nThe above claim assumes bidirectional links. If there is no cycles which have an overall negative weight, you do not have a way to loop around forever, being paid.\n\nIn such a case, Dijkstra's algorithm may still fail:\n\nConsider two paths: \n\n\nan optimal path that racks up a cost of 100, before crossing the final edge which has a -25 weight, giving a total of 75, and \na suboptimal path that has no negatively-weighted edges with a total cost of 90. \n\n\nDijkstra's algorithm will investigate the suboptimal path first, and will declare itself finished when it finds it. It will never follow up the subpath that is worse than the first solution found\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "cannot cast to java.lang.Comparable\r\n                \r\nAlthough this question has already been asked but I have an implementation specific doubt.\nI am trying to print the top view of the binary tree and following is the complete code for it:\n```\nimport java.util.*;\n\nclass Node{\n    int data;\n    Node right;\n    Node left;\n    Node(int data){\n        this.data = data;\n    }\n}\n\nclass Pair<F,S>{\n    private F first;\n    private S second;\n    public Pair(F first, S second){\n        this.first = first;\n        this.second = second;\n    }\n    \n    public F getFirst(){return first;}\n    public S getSecond(){return second;}\n}\n\nclass BinaryTreeTopView{\n\n    public static void printTopView(Node root){\n\n        if(root == null)\n            return;\n\n    Queue <Pair<Node,Integer>> q = new Queue<>();\n    Map <Integer,Node> map = new HashMap<>();\n    Pair<Node,Integer> p = new Pair<>(root, 0);\n    q.add(p);\n    \n    /*\n    I am storing nodes and the corresponding horizontal distances \n    in the form of a pair which then are being stored in the queue\n    to ensure level order traversal\n    */\n\n    while(!q.isEmpty()){\n        Pair<Node,Integer> temp = q.peek();\n        q.remove();\n\n        if(map.containsKey(temp.getSecond())==true){\n            map.put(temp.getSecond(),temp.getFirst());\n        } else {\n            System.out.println(temp.getFirst().data);\n            map.put(temp.getSecond(),temp.getFirst());                \n        }\n\n        if(temp.getFirst().left!=null){\n            Pair<Node,Integer> left = new Pair<>(temp.getFirst().left, temp.getSecond()-1);\n            q.add(left);\n        }\n        \n        if(temp.getFirst().right!=null){\n            Pair<Node,Integer> right = new Pair<> (temp.getFirst().right, temp.getSecond()+1);\n            q.add(right);\n        }\n        \n    }\n}\npublic static void main(String[] args) {\n    Node root = new Node(1);\n    root.left = new Node(2);\n    root.right = new Node(3);\n    root.left.right = new Node(5);\n    root.left.left = new Node(4);\n    root.right.left = new Node(6);\n    root.right.right = new Node(7);\n    root.right.left.right = new Node(8);\n    root.right.right.left = new Node(10);\n    root.right.right.right = new Node(9);\n    root.right.right.left.right = new Node(11);\n    root.right.right.left.right.right = new Node(12);\n    \n    printTopView(root);\n}\n}\n```\n\nIt compiles fine but an exception is being raised at the runtime.\nNow I have been getting the following exception and I am unable to figure out what the problem is:\n```\nException in thread \"main\" java.lang.ClassCastException: \nPair cannot be cast to java.lang.Comparable at  java.util.PriorityQueue.siftUpComparable(PriorityQueue.java:652)\nat java.util.PriorityQueue.siftUp(PriorityQueue.java:647)\nat java.util.PriorityQueue.offer(PriorityQueue.java:344)\nat java.util.PriorityQueue.add(PriorityQueue.java:321)\n```\n\n    ", "Answer": "\r\nIt's because Pair isn't implementing Comparable. Either implement it:\n\n```\npublic class Pair implements Comparable<Pair> {\n    public int compareTo(Pair o) {\n        // ...\n    }\n}\n```\n\n\nOr use Comparator in Your priority queue\n\nUsing Comparator ;\n\n```\nPriorityQueue<DummyObject> pq = new\n             PriorityQueue<DummyObject>(5, new DummyObjectComparator());\n```\n\n\nDefine your Comparator :\n\n```\nclass DummyObjectComparator implements Comparator<DummyObject>{\n\n      // Overriding compare()method of Comparator \n\n       public int compare(DummyObject s1, DummyObject s2) {\n                   //some code\n       }\n }\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Is Dijkstra's Algorithm symmetrical?\r\n                \r\nIn Dijkstra Algorithm to find the shortest path in a positively weighted graph, can there be a scenario in which the route A -> B does not equal the route B -> A? (A and B are vertexes on a graph). Can you provide an example?\n    ", "Answer": "\r\nIf the graph is not directional, the set of shortest paths from ```\nA```\n to ```\nB```\n (```\nS_{ab}```\n) is the same as set of shortest paths from ```\nB```\n to ```\nA```\n (```\nS_{ba}```\n). You can prove it by the contradiction.\n\nSuppose it is not. So there is at least one path ```\nP```\n from ```\nB```\n to ```\nA```\n which is not in the ```\nS_{ab}```\n. \nAs the graph is not directional, there is the same path from ```\nA```\n to ```\nB```\n. If the length of the path is greater than all path in ```\nS_{ab}```\n, so it is not shortest path from ```\nB```\n to ```\nA```\n, as you can return from ```\nB```\n to ```\nA```\n with one of path in shortest path in ```\nS_{ab}```\n.\n\nAlso, if the length of ```\nP```\n is less than length of paths in ```\nS_{ab}```\n, so we can go from ```\nA```\n to ```\nB```\n with less than the cost of all path in ```\nS_{ab}```\n. Hence, ```\nP```\n must be in ```\nS_{ab}```\n by the definition of the set. But, it is contradicted by the assumption. Hence, it is not possible.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "dijkstra's algorithm on iOS\r\n                \r\nI am tracking locations and their connections to other locations.\nI keep locations in an NSArray while each location is represented as a Dictionary.  Each location has Dictionary has the attributes (locationName, Connections, latitude, longitude) where Connections is an Array of other locations this location is connected TO (not from).  I use lat/lon and a Haversine algorithm to determine the distance between two points.\n\nNEXT, I would like to use dijkstra's shortest path algorithm to find the shortest path between a source and destination location (source and destination are selected by the user)\n\nThis is not for commercial use and does not need to support hundreds or thousands of locations.\n\nI am looking for some objective C code that will perform this search.\n    ", "Answer": "\r\nA quick google found some objective-c code at snyderp / PESGraph which says \n\n\n  PESGraph is a simple graph implementation for Foundation.kit that\n  allows for greating structures of nodes and paths, and then finding\n  the shortest path between them.  It includes unit tests that also\n  provide some examples of how to use the code.\n\n\nAlso this question was previously asked on SO theres-an-easy-way-to-apply-a-shortest-path-alghoritm-in-objective-c and the solution pointed to the same git repository that I found through google.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm implementation tracing in python\r\n                \r\nI'm trying to trace a python implementation of Dijkstra's algorithm using priority queue but I couldn't follow because I'm new to python\nhere's the implementation\n```\ndef dijkstra(edges, f, t):\n    g = defaultdict(set)\n    for l,r,c in edges:\n        g[l].add((c,r))\n        g[r].add((c, l))\n\n    q, seen,  = [(0,f,())], set(),\n    while q:\n        (weight, v1, path) = heappop(q)\n        if v1 not in seen:\n            seen.add(v1)\n            path += (v1,)\n            if v1 == t:\n                return weight, path\n            for k, v2 in g.get(v1, ()):\n                if v2 not in seen:\n                    heappush(q, (weight+ k, v2, path))\n\n\n    return float(\"inf\")\n```\n\n\nfirst why did it use ```\ng = defaultdict(set)```\n instead of ```\ng = defaultdict(list)```\n\nand used .add() instead of .append()\nI understand that in the beginning of Dijkstra algorithm you need to to set all weights for all nodes to infinity but I don't see it here.\nalso in which lines the node decides the path it's going through like in what line the decision of going left or right is made .\nin simple word where in the code the weighted line between the nodes is made.\n\na comment explaining what happened on each line of the code would be really helpful for me to understand it.\n    ", "Answer": "\r\nAs to your questions:\n\nfirst why did it use ```\ng = defaultdict(set)```\n instead of ```\ng = defaultdict(list)```\n and used ```\n.add()```\n instead of ```\n.append()```\n\n\nIt would work just as well with ```\nlist```\n. Of course, the method to be used (```\nadd```\n or ```\nappend```\n) follows from this choice. The only advantage I can see is that with ```\nset```\n you'll avoid adding the same edge twice. In general, a graph can have multiple edges between the same two vertices, and they could even have the same weight: when this occurs there is no reason to consider these duplicate edges separately, and the ```\nset```\n will make sure the duplicate edges are ignored.\n\nI understand that in the beginning of Dijkstra algorithm you need to to set all weights for all nodes to infinity but I don't see it here.\n\nThere are different ways to implement the algorithm. Indeed, you could add all vertices to the priority queue at the very start, where all of them except the source vertex start out with an infinity weight. But it is a bit more efficient to just exclude those \"infinity\" vertices from the queue: this way the queue size is smaller and the first vertices that are added to the queue will be added slightly faster. So any vertex that is not on the queue is in fact a vertex that has still a weight of infinity.\n\nalso in which lines the node decides the path it's going through like in what line the decision of going left or right is made . in simple word where in the code the weighted line between the nodes is made.\n\nThere is no decision visible in the code. All paths are potential winners until the moment the target node is found. Before that happens all partial paths that have been constructed are on the heap, and it is the characteristic of the heap that determines which path will be the next one that will be extended to neighboring nodes. And then those longer paths (with more vertices) will be thrown in the heap again, where the magic of the heap will do its work again. So if you look for \"decision\", there is only a decision made inside the heap: it tells us which is the path with the least weight that is present in the heap. And so the main loop may work a bit on one path (to extend it), but then in the next iteration it may work on an entirely different path. And so it continues until suddenly it finds that it has reached the target vertex. At that moment only, all other paths that were still candidates on the heap, are ignored.\nIf you want to know a bit more about this hidden magic of ```\nheappop```\n and ```\nheappush```\n, read the Wikipedia article on the subject.\nNot optimal\nAlthough the algorithm is correct, it is not an efficient implementation. The following statement cases a path to be copied, and that path might have up to n elements, so it has a worst-case time complexity of O(n) on one execution, giving the algorithm a worst-case time complexity of O(n²logn):\n```\npath += (v1,)\n```\n\nTo avoid this, it is common to not keep track of the paths as a whole, but to only store a backreference to the previous node where we came form. Then when the time comes that we hit the target node, we can walk back following these backreferences and build the path only once. As storing a backreference takes constant time, this improvement will give the algorithm a time complexity of O(nlogn).\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Running Time of Dijkstra's Algorithm - Priority Queue (Heap)\r\n                \r\nI'm having a hard time understanding why the complexity of Dijkstra's Algorithm with a Heap is  O( (m + n)*log(n) ) where m is the number of edges and n is the number of vertices. \n\nMy understanding is:\n\nNow I know one has to do n remove mins. (Each remove min takes log(n) from a heap).\n\nThen one has to do m update keys. (Each update key takes log(n)).\n\nHence the answer. Is my concept clear? Otherwise can you please explain how to get the time complexity of the Dijkstra's Algorithm.\n    ", "Answer": "\r\nThe complexity varies slightly depending on the way you implement Dijkstra using heap. For instance I am using the built-in priority queue in ```\nc++```\n and this heap does not support priority update. Thus each time I want to update the priority of a given element I simply push one more element in the heap. This may cause my heap to become of size ```\nm```\n(still each insert/pop has a complexity of ```\nO(log(m))```\n which is the same as ```\nO(log(n))```\n). \n\nIf you use Fibonacci heap you can reduce the complexity of the algorithm.\n\nIf you use a regular binary heap your analysis is pretty much correct - you need to push m elements in a heap that supports insert/pop in ```\nO(log(n))```\n. You also need to remove the minimum element at least ```\nn```\n times.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm for Negative Weights\r\n                \r\nOkay, first of all I know Dijkstra does not work for negative weights and we can use Bellman-ford instead of it. But in a problem I was given it states that all the edges have weights from 0 to 1 (0 and 1 are not included). And the cost of the path is actually the product.\n\nSo what I was thinking is just take the log. Now all the edges are negative. Now I know Dijkstra won't work for negative weights but in this case all the edges are negative so can't we do something so that Dijkstra would work.\n\nI though of multiplying all the weights by -1 but then the shortest path becomes the longest path.\n\nSo is there anyway I can avoid the Bellman-Ford algorithm in this case.\n\nThe exact question is: \"Suppose for some application, the cost of a path is equal to the product all the weights of the edges in the path. How would you use Dijkstra's algorithm in this case? All the weights of the edges are from 0 to 1 (0 and 1 are not inclusive).\"  \n    ", "Answer": "\r\nIf all the weights on the graph are in the range ```\n(0, 1)```\n, then there will always be a cycle whose weight is less that ```\n1```\n, and thus you will be stuck in this cycle for ever (every pass on the cycle reduces the total weight of the shortest path). Probably you have misunderstood the problem, and you either want to find the longest path, or you are not allowed to visit the same vertex twice. Anyway, in the first case dijkstra'a algorithm is definitely applicable, even without the ```\nlog```\n modification. And I am pretty sure the second case cannot be solved with polynomial complexity.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm simulation\r\n                \r\nI'm working on a implementation of Dijkstra's shortest path algorithm to simulate how multicast routing works but I'm getting an error on my simulation class and would appreciate if anyone could help me.\n\nSimulation class\n\n```\npublic class simulation\n{\n    private List<Vertex> nodes;\n    private List<Edge> edges;\n    public void testExcute()\n    {\n        nodes = new ArrayList<Vertex>();\n        edges = new ArrayList<Edge>();\n        for (int i = 0; i < 11; i++)\n        {\n            Vertex location = new Vertex(\"Node_\" + i, \"Node_\" + i);\n            nodes.add(location);\n        }\n    }\n    addLink(\"Edge_0\", 0, 1, ((int)Math.random()*101));\n    addLink(\"Edge_1\", 0, 2, ((int)Math.random()*101));\n    addLink(\"Edge_2\", 0, 4, ((int)Math.random()*101));\n    addLink(\"Edge_3\", 2, 6, ((int)Math.random()*101));\n    addLink(\"Edge_4\", 2, 7, ((int)Math.random()*101));\n    addLink(\"Edge_5\", 3, 7, ((int)Math.random()*101));\n    addLink(\"Edge_6\", 5, 8, ((int)Math.random()*101));\n    addLink(\"Edge_7\", 8, 9, ((int)Math.random()*101));\n    addLink(\"Edge_8\", 7, 9, ((int)Math.random()*101));\n    addLink(\"Edge_9\", 4, 9, ((int)Math.random()*101));\n    addLink(\"Edge_10\", 9,10,((int)Math.random()*101));\n    addLink(\"Edge_11\", 1,10,((int)Math.random()*101));\n\n    // Lets check from location Loc_1 to Loc_10\n    Graph graph = new Graph(nodes, edges);\n    DijkstraAlgorithm dijkstra = new DijkstraAlgorithm(graph);\n    dijkstra.execute(nodes.get(0));\n    LinkedList<Vertex> path = dijkstra.getPath(nodes.get(10));\n\n    for (Vertex vertex : path) \n    {\n      System.out.println(vertex);\n    }\n    public void addLink(String laneId, int outcomingPortLabel, int incomingPortLabel,int cost)\n    {\n    Edge link = new Edge(laneId,nodes.get(outcomingPortLabel), nodes.get(incomingPortLabel), cost);\n    edges.add(link);\n    }\n}\n```\n\n\nEdge class\n\n```\npackage multicastroutingproject;\npublic class Edge  \n{\n    private final String id; \n    private final Vertex source;\n    private final Vertex destination;\n    private final int weight; \n\n    public Edge(String id, Vertex source, Vertex destination, int weight) \n    {\n        this.id = id;\n        this.source = source;\n        this.destination = destination;\n        this.weight = weight;\n    }\n\n    public String getId() \n    {\n        return id;\n    }\n    public Vertex getDestination() \n    {\n        return destination;\n    }\n    public Vertex getSource() \n    {\n        return source;\n    }\n    public int getWeight() \n    {\n        return weight;\n    }\n    @Override\n    public String toString()\n    {\n    return source + \" \" + destination;\n    }\n} \n```\n\n\nGraph class\n\n```\npackage multicastroutingproject;\nimport java.util.List;\npublic class Graph \n{\n    private final List<Vertex> vertexes;\n    private final List<Edge> edges;\n    public Graph(List<Vertex> vertexes, List<Edge> edges) \n    {\n        this.vertexes = vertexes;\n        this.edges = edges;\n    }\n    public List<Vertex> getVertexes() \n    {\n        return vertexes;\n    }\n    public List<Edge> getEdges() \n    {\n        return edges;\n    }\n} \n```\n\n\nVertex class\n\n```\npackage multicastroutingproject;\npublic class Vertex \n{\n    final private String id;\n    final private String name;\n    public Vertex(String id, String name) \n    {\n        this.id = id;\n        this.name = name;\n    }\n    public String getId()\n    {\n        return id;\n    }\n\n    public String getName() \n    {\n        return name;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((id == null) ? 0 : id.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) \n    {\n        if (this == obj)\n          return true;\n        if (obj == null)\n          return false;\n        if (getClass() != obj.getClass())\n          return false;\n        Vertex other = (Vertex) obj;\n        if (id == null) {\n            if (other.id != null)\n                return false;\n        } \n        else if (!id.equals(other.id))\n            return false;\n    return true;\n    }\n\n    @Override\n    public String toString()\n    {\n        return name;\n    }\n} \n```\n\n\nand finally Dijkstra's class\n\n```\npackage multicastroutingproject;\nimport java.util.*;\npublic class DijkstraAlgorithm \n{\n  private final List<Vertex> nodes;\n  private final List<Edge> edges;\n  private Set<Vertex> settledNodes;\n  private Set<Vertex> unSettledNodes;\n  private Map<Vertex, Vertex> predecessors;\n  private Map<Vertex, Integer> distance;\n  public DijkstraAlgorithm(Graph graph) \n  {\n    // create a copy of the array so that we can operate on this array\n    this.nodes = new ArrayList<>(graph.getVertexes());\n    this.edges = new ArrayList<>(graph.getEdges());\n  }\n  public void execute(Vertex source) \n  {\n    settledNodes = new HashSet<Vertex>();\n    unSettledNodes = new HashSet<Vertex>();\n    distance = new HashMap<Vertex, Integer>();\n    predecessors = new HashMap<Vertex, Vertex>();\n    distance.put(source, 0);\n    unSettledNodes.add(source);\n    while (unSettledNodes.size() > 0) \n    {\n      Vertex node = getMinimum(unSettledNodes);\n      settledNodes.add(node);\n      unSettledNodes.remove(node);\n      findMinimalDistances(node);\n    }\n  }\n  private void findMinimalDistances(Vertex node)\n  {\n    List<Vertex> adjacentNodes = getNeighbors(node);\n    for (Vertex target : adjacentNodes)\n    {\n      if (getShortestDistance(target) > getShortestDistance(node)\n          + getDistance(node, target)) \n      {\n        distance.put(target, getShortestDistance(node)\n            + getDistance(node, target));\n        predecessors.put(target, node);\n        unSettledNodes.add(target);\n      }\n    }\n  }\n  private int getDistance(Vertex node, Vertex target) \n  {\n    for (Edge edge : edges) \n    {\n      if (edge.getSource().equals(node)\n          && edge.getDestination().equals(target)) \n      {\n        return edge.getWeight();\n      }\n    }\n    throw new RuntimeException(\"Should not happen\");\n  }\n  private List<Vertex> getNeighbors(Vertex node) \n  {\n    List<Vertex> neighbors = new ArrayList<Vertex>();\n    for (Edge edge : edges) \n    {\n      if (edge.getSource().equals(node)\n          && !isSettled(edge.getDestination())) \n      {\n        neighbors.add(edge.getDestination());\n      }\n    }\n    return neighbors;\n  }\n  private Vertex getMinimum(Set<Vertex> vertexes) \n  {\n    Vertex minimum = null;\n    for (Vertex vertex : vertexes) \n    {\n      if (minimum == null) \n      {\n        minimum = vertex;\n      } \n      else \n      {\n        if (getShortestDistance(vertex) < getShortestDistance(minimum)) \n        {\n          minimum = vertex;\n        }\n      }\n    }\n    return minimum;\n  }\n  private boolean isSettled(Vertex vertex) \n  {\n    return settledNodes.contains(vertex);\n  }\n  private int getShortestDistance(Vertex destination) \n  {\n    Integer d = distance.get(destination);\n    if (d == null) \n    {\n    return Integer.MAX_VALUE;\n    }\n    else\n    {\n      return d;\n    }\n}\npublic LinkedList<Vertex> getPath(Vertex target) \n{\n  LinkedList<Vertex> path = new LinkedList<Vertex>();\n  Vertex step = target;\n  // check if a path exists\n  if (predecessors.get(step) == null) \n  {\n    return null;\n  }\n  path.add(step);\n  while (predecessors.get(step) != null) \n  {\n    step = predecessors.get(step);\n    path.add(step);\n  }\n  // Put it into the correct order\n  Collections.reverse(path);\n  return path;\n  }\n}\n```\n\n\nWhen I try \n\n```\naddLink(\"Edge_9\", 4, 9, ((int)Math.random()*101));```\n\n\nIt gives me the following warning/error: \"Invalid method declaration;missing return type\", and it suggests that I rename addLink to simulation, which makes no sense.\n\nThe other warning/error I'm getting on the lines \n\n```\nDijkstraAlgorithm dijkstra = new DijkstraAlgorithm(graph);\ndijkstra.execute(nodes.get(0));\n```\n\n\nit says that package dijkstra does not exist, although I clearly instantiate the object on the obove line.\n\nAnd lastly,\n\n```\nLinkedList<Vertex> path = dijkstra.getPath(nodes.get(10));\n\nfor (Vertex vertex : path) \n{\n  System.out.println(vertex);\n}\n```\n\n\nThis time it says \"Illegal start of type\", and it suggests that I create a \"path\" class in my package, but again that makes no sense as I instantiate path right above the for each loop.\n\nI'm sorry for the long post, but does anyone know why I'm getting these errors\n?\n    ", "Answer": "\r\nSeveral issues there, but the most glaring is that your calls to ```\naddLink()```\n are in the middle of the class body, rather than in a method. The compiler expects a method declaration there and don't quite know what to do with those calls.\nIt seems that you are missing a ```\nmain()```\n. You should review some Java syntax.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Enhancing Dijkstra's Algorithm for Navigation\r\n                \r\nI have written an implementation for Dijkstra's algorithm that integrate with ArcGIS, the implementation is written in C#.net.\n\nI have reached a solving time of about 20 seconds for a graph with 80,000 nodes (worst case time), I have used a priority queue implementation from Alexey Kurakin (thanks a lot) and I think there is nothing I can do to enhance this time.\n\nI have several questions:\n\n\nIs this an acceptable time?\nHow can I improve it?\nIs writing the solution in another platform (I think of Delphi or C++) can enhance the time?\n\n\nBest Regards.\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm with 'must-pass' nodes\r\n                \r\nI am trying to implement Dijkstra's algorithm which can find the shortest path between the start node and the end node. Before reach the end node there are some 'must-pass' intermediate nodes (more than one) for example 2 or 3 must pass nodes which must pass before reach the end node. \n\nIf i have one must pass node the solution i found is find two different paths from the must pass node to destination and from must pass node to start node.\n\nI am out of ideas how i can implement such an algorithm.\nAny suggestions?\n\nThanks.\n\n```\nList<Node> closestPathFromOrigin = null;\n\ndouble maxD = Double.POSITIVE_INFINITY;\ndouble _distance = 0;\nint temp1 = 0;\nList<Node> referencePath = new ArrayList<>();\nboolean check = false;\nNode startNode = null;\n\npublic List<Node> recursion(ArrayList<Node> points, ArrayList<Node> intermediatePoints) {\n\n    if (!check) {\n        System.out.println(\"--- DATA ---\");\n        System.out.println(\"Intermediate points: \" + intermediatePoints);\n        System.out.println(\"points: \" + points.get(0).lat + \" \" + points.get(1).lat);\n        System.out.println(\"--Find the nearest intermediate point from the start point of driver--\");\n        startNode = points.get(0);\n        System.out.println(\"Start point of driver: \" + startNode.lat + \" \" + startNode.lon);\n        for (int i = 0; i < intermediatePoints.size(); i++) {\n            List<Node> _path = dijkstra(startNode, intermediatePoints.get(i));\n            _distance = 0;\n            for (int j = 0; j < _path.size() - 1; j++) {\n                _distance += calculateDistance(_path.get(j), _path.get(j + 1));\n            }\n            if (_distance < maxD) {\n                maxD = _distance;\n                closestPathFromOrigin = _path;\n                temp1 = i;\n            }\n        }\n        System.out.println(\"NearestPoint from driver's origin: \" + intermediatePoints.get(temp1));\n\n        referencePath.addAll(closestPathFromOrigin);\n        startNode = intermediatePoints.get(temp1);\n        System.out.println(\"New StartNode: the nearestPoint from driver's origin: \" + startNode.lat + \" \" + startNode.lon);\n        check = true;\n        intermediatePoints.remove(intermediatePoints.get(temp1));\n        System.out.println(\"New Intermediate points: \" + intermediatePoints);\n        System.out.println(\"Intermediate points empty? No -> recursion, Yes -> stop\");\n        if (!intermediatePoints.isEmpty()) {\n            System.out.println(\"Recursion!!! with new data of: intermediatePoints: \" + intermediatePoints);\n            recursion(points, intermediatePoints);\n        } else {\n            System.out.println(\"Stop\");\n            return referencePath;\n        }\n    } else {\n        System.out.println(\"Recursion: startNode: \" + startNode.lat + \" \" + startNode.lon);\n        for (int i = 0; i < intermediatePoints.size(); i++) {\n            if (intermediatePoints.size() > 1) {\n                System.out.println(\"From the new start point to the next nearest intermediate points if more than one points\");\n                List<Node> _path = dijkstra(startNode, intermediatePoints.get(i));\n                _distance = 0;\n                for (int j = 0; j < _path.size() - 1; j++) {\n                    _distance += calculateDistance(_path.get(j), _path.get(j + 1));\n                }\n                if (_distance < maxD) {\n                    maxD = _distance;\n                    closestPathFromOrigin = _path;\n                    temp1 = i;\n                }\n                referencePath.addAll(closestPathFromOrigin);\n                startNode = intermediatePoints.get(temp1);\n                check = true;\n                intermediatePoints.remove(intermediatePoints.get(temp1));\n                if (!intermediatePoints.isEmpty()) {\n                    recursion(points, intermediatePoints);\n                } else {\n                    return referencePath;\n                }\n            } else {\n                System.out.println(\"From the new start point to the next nearest intermediate points if just one point\");\n                List<Node> _path = dijkstra(startNode, intermediatePoints.get(i));\n                //Collections.reverse(_path);\n                referencePath.addAll(_path);\n            }\n            if (i == intermediatePoints.size() - 1) {\n                System.out.println(\"Last Entry in intermediate points - find path to destination: \" + points.get(1).lat + \" \" + intermediatePoints.get(i));\n                //List<Node> _path1 = dijkstra(points.get(1), intermediatePoints.get(i));\n                List<Node> _path1 = dijkstra(intermediatePoints.get(i), points.get(1));\n\n                Collections.reverse(_path1);\n                referencePath.addAll(_path1);\n               //  referencePath.addAll(_path2);\n            }\n        }\n    }\n    return referencePath;\n}\n```\n\n    ", "Answer": "\r\nThis is a generalisation of the travelling salesman problem.  The TSP comes up as the case where all vertices are \"must-pass\".\n\nFind shortest paths between each pair of must-pass vertices, from the source to each must-pass vertex, and from each must-pass vertex to the sink.  Then use the famous O(n 2^n) dynamic programming algorithm for TSP to find the shortest path from source to sink meeting your constraints; here n will be two plus the number of must-pass vertices.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Difference between the runtime of Dijkstra's Algorithm: Priority Queue vs. Doubly Linked List\r\n                \r\nWhat is the difference, regarding runtime complexity, between the following and why?:\n\n(1) DIJKSTRA's algorithm using regular Priority Queue (Heap)\n\n(2) DIJKSTRA's algorithm using a doubly linked list\n\n(Unless there isn't a difference) \n    ", "Answer": "\r\nThe most general version of Dijkstra's algorithm assumes that you have access to some sort of priority queue structure that supports the following operations:\n\n\nmake-heap(s, n): build a heap of n nodes at initial distance ∞, except for the start node s, which has distance 0.\ndequeue-min(): remove and return the element with the lowest priority.\ndecrease-key(obj, key): given an existing object obj in the priority queue, reduce its priority to the level given by key.\n\n\nDijkstra's algorithm's requires one call to make-heap, O(n) calls to dequeue-min, and O(m) calls to decrease-key, where n is the number of nodes and m is the number of edges. The overall runtime can actually be given as O(Tm-h + nTdeq + mTd-k), where Tm-h, Tdeq, and Td-k are the average (amortized) costs of doing an make-heap, a dequeue, and a decrease-key, respectively.\n\nNow, let's suppose that your priority queue is a doubly-linked list. There's actually several ways you could use a doubly-linked list as a priority queue: you could keep the nodes sorted by distance, or you could keep them in unsorted order. Let's consider each of these.\n\nIn a sorted doubly-linked list, the cost of doing a make-heap is O(n): just insert the start node followed by n - 1 other nodes at distance infinity. The cost of doing a dequeue-min is O(1): just delete the first element. However, the cost of doing a decrease-key is O(n), since if you need to change a node's priority, you may have to move it, and you can't find where to move it without (in the worst case) doing a linear scan over the nodes. This means that the runtime will be O(n + n + nm) = O(mn).\n\nIn an unsorted doubly-linked list, the cost of doing a make-heap is still O(n) because you need to create n different nodes. The cost of a dequeue-min is now O(n) because you have to do a linear scan over all the nodes in the list to find the minimum value. However, the cost of a decrease-key is now O(1), since you can just update the node's key in-place. This means that the runtime is O(n + n2 + m) = O(n2 + m) = O(n2), since the number of edges is never more than O(n2). This is an improvement from before.\n\nWith a binary heap, the cost of doing a make-heap is O(n) if you use the standard linear-time heapify algorithm. The cost of doing a dequeue is O(log n), and the cost of doing a decrease-key is O(log n) as well (just bubble the element up until it's in the right place). This means that the runtime of Dijkstra's algorithm with a binary heap is O(n + n log n + m log n) = O(m log n), since if the graph is connected we'll have that m ≥ n.\n\nYou can do even better with a Fibonacci heap, in an asymptotic sense. It's a specialized priority queue invented specifically to make Dijkstra's algorithm fast. It can do a make-heap in time O(n), a dequeue-min in time O(log n), and a decrease-key in (amortized) O(1) time. This makes the runtime of Dijkstra's algorithm O(n + n log n + m) = O(m + n log n), though in practice the constant factors make Fibonacci heaps slower than binary heaps.\n\nSo there you have it! The different priority queues really do make a difference. It's interesting to see how \"Dijkstra's algorithm\" is more of a family of algorithms than a single algorithm, since the choice of data structure is so critical to the algorithm running quickly.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm Adjacency List Java\r\n                \r\nPlease excuse me if I had made any errors, this is one of my first post, so take it with a grain of salt.  I am attempting to implement Dijkstra's algorithm with an adjacency list, but for some reason I am coming up with undesirable results, from the following code, you will see there is an obvious path from SFO->NYC with a weight of 232, but when you run the code, infinity is the output.\n\n```\nimport java.util.PriorityQueue;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\nclass Vertex implements Comparable<Vertex>\n{\n    public final String name;\n    public Edge[] adjacencies;\n    public double minDistance = Double.POSITIVE_INFINITY;\n    public Vertex previous;\n    public Vertex(String argName) { name = argName; }\n    public String toString() { return name; }\n    public int compareTo(Vertex other)\n    {\n        return Double.compare(minDistance, other.minDistance);\n    }\n\n}\n\n\nclass Edge\n{\n    public final Vertex target;\n    public final double weight;\n    public Edge(Vertex argTarget, double argWeight)\n    { target = argTarget; weight = argWeight; }\n}\n\npublic class Dijkstra\n{\n    public static void computePaths(Vertex source)\n    {\n        source.minDistance = 0.;\n        PriorityQueue<Vertex> vertexQueue = new PriorityQueue<Vertex>();\n    vertexQueue.add(source);\n\n    while (!vertexQueue.isEmpty()) {\n        Vertex u = vertexQueue.poll();\n\n            // Visit each edge exiting u\n            for (Edge e : u.adjacencies)\n            {\n                Vertex v = e.target;\n                double weight = e.weight;\n                double distanceThroughU = u.minDistance + weight;\n        if (distanceThroughU < v.minDistance) {\n            vertexQueue.remove(v);\n\n            v.minDistance = distanceThroughU ;\n            v.previous = u;\n            vertexQueue.add(v);\n        }\n            }\n        }\n    }\n\n    public static List<Vertex> getShortestPathTo(Vertex target)\n    {\n        List<Vertex> path = new ArrayList<Vertex>();\n        for (Vertex vertex = target; vertex != null; vertex = vertex.previous)\n            path.add(vertex);\n\n        Collections.reverse(path);\n        return path;\n    }\n\n    public static void main(String[] args)\n    {\n        // mark all the vertices\n        Vertex SFO = new Vertex(\"SFO\");\n        Vertex NYC = new Vertex(\"NYC\");\n        Vertex SEA = new Vertex(\"SEA\");\n        Vertex GDL = new Vertex(\"GDL\");\n        Vertex CUU = new Vertex(\"CUU\");\n        Vertex MEX = new Vertex(\"MEX\");\n        Vertex PAR = new Vertex(\"PAR\");\n        Vertex MRS = new Vertex(\"MRS\");\n        Vertex LYS = new Vertex(\"LYS\");\n        Vertex PVG = new Vertex(\"PVG\");\n        Vertex PEK = new Vertex(\"PEK\");\n        Vertex CAN = new Vertex(\"CAN\");\n        Vertex DEL = new Vertex(\"DEL\");\n        Vertex BOM = new Vertex(\"BOM\");\n        Vertex MAA = new Vertex(\"MAA\");\n        Vertex MEL = new Vertex(\"MEL\");\n        Vertex SYD = new Vertex(\"SYD\");\n        Vertex PER = new Vertex(\"PER\");\n        Vertex NBO = new Vertex(\"NBO\");\n        Vertex MBA = new Vertex(\"MBA\");\n        Vertex KIS = new Vertex(\"KIS\");\n        Vertex CGK = new Vertex(\"CGK\");\n        Vertex SUB = new Vertex(\"SUB\");\n        Vertex BDO = new Vertex(\"BDO\");\n        Vertex CGH = new Vertex(\"CGH\");\n        Vertex GIG = new Vertex(\"GIG\");\n        Vertex SSA = new Vertex(\"SSA\");\n        Vertex MOW = new Vertex(\"MOW\");\n        Vertex LED = new Vertex(\"LED\");\n        Vertex KZN = new Vertex(\"KZN\");\n\n        // set the edges and weight\n        SFO.adjacencies = new Edge[]{ new Edge(NYC, 232) };\n        SFO.adjacencies = new Edge[]{ new Edge(MEX, 226) };\n\n        NYC.adjacencies = new Edge[]{ new Edge(MEL, 942) };\n        NYC.adjacencies = new Edge[]{ new Edge(SYD, 930) };\n\n        SEA.adjacencies = new Edge[]{ new Edge(PEK, 667) };\n        SEA.adjacencies = new Edge[]{ new Edge(KIS, 4127) };\n\n\n        GDL.adjacencies = new Edge[]{ new Edge(KIS, 2294) };\n        GDL.adjacencies = new Edge[]{ new Edge(SUB, 1300) };\n\n        CUU.adjacencies = new Edge[]{ new Edge(SEA, 379) };\n        CUU.adjacencies = new Edge[]{ new Edge(GDL, 34) };\n\n        MEX.adjacencies = new Edge[]{ new Edge(PAR, 609) };\n        MEX.adjacencies = new Edge[]{ new Edge(KZN, 1302) };\n\n        PAR.adjacencies = new Edge[]{ new Edge(LYS, 65) };\n        PAR.adjacencies = new Edge[]{ new Edge(MBA, 462) };\n\n        MRS.adjacencies = new Edge[]{ new Edge(CUU, 1948) };\n        MRS.adjacencies = new Edge[]{ new Edge(PVG, 537) };\n\n        LYS.adjacencies = new Edge[]{ new Edge(SUB, 1073) };\n\n        PVG.adjacencies = new Edge[]{ new Edge(SEA, 373) };\n\n        PEK.adjacencies = new Edge[]{ new Edge(CAN, 254) };\n        PEK.adjacencies = new Edge[]{ new Edge(MAA, 345) };\n\n        CAN.adjacencies = new Edge[]{ new Edge(BOM, 363) };\n\n        DEL.adjacencies = new Edge[]{ new Edge(SEA, 667) };\n        DEL.adjacencies = new Edge[]{ new Edge(PEK, 263) };\n\n        BOM.adjacencies = new Edge[]{ new Edge(KZN, 539) };\n\n        MAA.adjacencies = new Edge[]{ new Edge(CAN, 201) };\n        MAA.adjacencies = new Edge[]{ new Edge(BOM, 29) };\n\n        MEL.adjacencies = new Edge[]{ new Edge(PER, 118) };\n        MEL.adjacencies = new Edge[]{ new Edge(LED, 810) };\n\n        SYD.adjacencies = new Edge[]{ new Edge(MEX, 1004) };\n\n        PER.adjacencies = new Edge[]{ new Edge(PAR, 729) };\n        PER.adjacencies = new Edge[]{ new Edge(NBO, 783) };\n\n        NBO.adjacencies = new Edge[]{ new Edge(CGH, 1140) };\n        NBO.adjacencies = new Edge[]{ new Edge(GIG, 899) };\n\n        MBA.adjacencies = new Edge[]{ new Edge(CGK, 611) };\n        MBA.adjacencies = new Edge[]{ new Edge(MOW, 786) };\n\n        KIS.adjacencies = new Edge[]{ new Edge(PEK, 809) };\n        KIS.adjacencies = new Edge[]{ new Edge(DEL, 972) };\n\n        CGK.adjacencies = new Edge[]{ new Edge(MRS, 651) };\n        CGK.adjacencies = new Edge[]{ new Edge(BDO, 85) };\n\n        SUB.adjacencies = new Edge[]{ new Edge(SEA, 1045) };\n        SUB.adjacencies = new Edge[]{ new Edge(PVG, 261) };\n\n        BDO.adjacencies = new Edge[]{ new Edge(NBO, 984) };\n        BDO.adjacencies = new Edge[]{ new Edge(SUB, 65) };\n\n        CGH.adjacencies = new Edge[]{ new Edge(LYS, 727) };\n        CGH.adjacencies = new Edge[]{ new Edge(CGK, 1794) };\n\n        GIG.adjacencies = new Edge[]{ new Edge(CUU, 595) };\n        GIG.adjacencies = new Edge[]{ new Edge(SSA, 90) };\n\n        SSA.adjacencies = new Edge[]{ new Edge(CGK, 1978) };\n        SSA.adjacencies = new Edge[]{ new Edge(BDO, 5634) };\n\n        MOW.adjacencies = new Edge[]{ new Edge(MAA, 381) };\n        MOW.adjacencies = new Edge[]{ new Edge(GIG, 759) };\n        MOW.adjacencies = new Edge[]{ new Edge(KZN, 52) };\n\n        LED.adjacencies = new Edge[]{ new Edge(PER, 825) };\n        LED.adjacencies = new Edge[]{ new Edge(MOW, 53) };\n\n        KZN.adjacencies = new Edge[]{ new Edge(MAA, 551) };\n        KZN.adjacencies = new Edge[]{ new Edge(LED, 96) };\n\n        computePaths(SFO); // run Dijkstra\n        System.out.println(\"Distance to \" + MAA + \": \" + MAA.minDistance);\n        List<Vertex> path = getShortestPathTo(MAA);\n        System.out.println(\"Path: \" + path);\n    }\n}\n```\n\n    ", "Answer": "\r\nYou have several problems:\n\n\nFirst, you are printing distance to ```\nMAA```\n not ```\nNYC```\n. This is a simple fix:\n\n```\nSystem.out.println(\"Distance to \" + NYC + \": \" + NYC.minDistance);\n```\n\nSecond, you are overwriting the adjacency list every time you add something to it:\n\n```\nSFO.adjacencies = new Edge[]{ new Edge(NYC, 232) };\nSFO.adjacencies = new Edge[]{ new Edge(MEX, 226) }; //This is a whole new list\n//SFO.adjacencies only contains edge MEX now, as the old list was overwritten\n```\n\n\nChange to:\n\n```\nSFO.adjacencies = new Edge[]{ new Edge(NYC, 232), new Edge(MEX, 226) };\n//Now list contains both edges as desired\n```\n\n\n\n\n\nThis will fix your current problem, however I also noticed several algorithm problems:\n\n\nYour ```\nvertexQueue```\n is supposed to start with all vertexes inside, you only add ```\nsource```\n. Thus, currently, you can only find things adjacent to your source.\nWhy do you remove ```\nv```\n from ```\nvertexQueue```\n in your inner ```\nif```\n only to re-add it at the end? This does nothing.\n\n\nLook at this pseudocode and make sure your algorithm is consistent with it.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Can Dijkstra's Algorithm work on a graph with weights of 0?\r\n                \r\nIf there exists a weighted graph ```\nG```\n, and all weights are ```\n0```\n, does Dijkstra's algorithm still find the shortest path? If so, why?\n\nAs per my understanding of the algorithm, Dijsktra's algorithm will run like a normal BFS if there are no edge weights, but I would appreciate some clarification.\n    ", "Answer": "\r\nExplanation\n\nDijkstra itself has no problem with ```\n0```\n weight, per definition of the algorithm. It only gets problematic with negative weights.\n\nSince in every round Dijkstra will settle a node. If you later find a negative weighted edge, this could lead to a shorter path to that settled node. The node would then need to be unsettled, which Dijkstras algorithm does not allow (and it would break the complexity of the algorithm). It gets clear if you take a look at the actual algorithm and some illustration.\n\nThe behavior of Dijkstra on such an all zero-graph is the same as if all edges would have a different, but same, value, like ```\n1```\n (except of the resulting shortest path length). Dijkstra will simply visit all nodes, in no particular order. Basically, like an ordinary Breadth-first search.\n\n\n\nDetails\n\nTake a look at the algorithm description from Wikipedia:\n\n```\n 1 function Dijkstra(Graph, source):\n 2\n 3     create vertex set Q\n 4\n 5     for each vertex v in Graph:           // Initialization\n 6         dist[v] ← INFINITY                // Unknown distance from source to v\n 7         prev[v] ← UNDEFINED               // Previous node in optimal path from source\n 8         add v to Q                        // All nodes initially in Q (unvisited nodes)\n 9\n10     dist[source] ← 0                      // Distance from source to source\n11      \n12     while Q is not empty:\n13         u ← vertex in Q with min dist[u]  // Node with the least distance\n14                                           // will be selected first\n15         remove u from Q \n16          \n17         for each neighbor v of u:         // where v is still in Q.\n18             alt ← dist[u] + length(u, v)\n19             if alt < dist[v]:             // A shorter path to v has been found\n20                 dist[v] ← alt \n21                 prev[v] ← u \n22\n23     return dist[], prev[]\n```\n\n\nThe problem with negative values lies in line ```\n15```\n and ```\n17```\n. When you remove node ```\nu```\n, you settle it. That is, you say that the shortest path to this node is now known. But that means you won't consider ```\nu```\n again in line ```\n17```\n as a neighbor of some other node (since it's not contained in ```\nQ```\n anymore).\n\nWith negative values it could happen that you later find a shorter path (due to negative weights) to that node. You would need to consider ```\nu```\n again in the algorithm and re-do all the computation that depended on the previous shortest path to ```\nu```\n. So you would need to add ```\nu```\n and every other node that was removed from ```\nQ```\n that had ```\nu```\n on its shortest path back to ```\nQ```\n.\n\nEspecially, you would need to consider all edges that could lead to your destination, since you never know where some nasty ```\n-1_000_000```\n weighted edge hides.\n\nThe following example illustrates the problem:\n\n\n\nDijkstra will declare the red way as shortest path from ```\nA```\n to ```\nC```\n, with length ```\n0```\n. However, there is a shorter path. It is marked blue and has a length of ```\n99 - 300 + 1 = -200```\n.\n\nWith negative weights you could even create a more dangerous scenario, negative cycles. That is a cycle in the graph with a negative total weight. You then need a way to stop moving along the cycle all the time, endlessly dropping your current weight.\n\n\n\nNotes\n\nIn an undirected graph edges with weight ```\n0```\n can be eliminated and the nodes be merged. A shortest path between them will always have length ```\n0```\n. If the whole graph only has ```\n0```\n weights, then the graph could just be merged to one node. The result to every shortest path query is simply ```\n0```\n.\n\nThe same holds for directed graphs if you have such an edge in both directions. If not, you can't do that optimization as you would change reach-ability of nodes.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm - Initializing Node Distances\r\n                \r\nI have an assignment to use Dijkstra's shortest path algorithm for a simple network simulation. There's one part of the coding implementation that I don't understand and it's giving me grief.\nI searched around on stack overflow and found many helpful questions about Dijkstra's, but none with my specific question. I apologize if I didn't research thoroughly enough.\n\nI'm using this pseudocode from Mark Allen Weiss's Data Structures and Algorithm Analysis in C++:\n\n```\nvoid Graph::dijkstra( Vertex s)\n{\n    for each Vertex v\n    {\n        v.dist = INFINITY;\n        v.known = false;\n    }\n\n    s.dist = 0;\n\n    while( there is an unknown distance vertex )\n    {\n         Vertex v = smallest unknown distance vertex;\n         v.known = true;\n\n         for each Vertex w adjacent to v\n         {\n             if (!w.known)\n             {\n                 int cvw = cost of edge from v to w;\n                 if(v.dist + cvw < w.dist)\n                 {\n                      //update w\n                      decrease(w.dist to v.dist + cvw);\n                      w.path = v;\n                 }\n             }\n\n     }\n}\n```\n\n\nand my implementation seems to work aside from the last ```\nif```\n statement.\n\n```\nif(v.dist + cvw < w.dist)\n```\n\n\nMy code will never go into what's underneath because the distance for every node is initialized to (essentially) infinity and the algorithm never seems to change the distance. Therefore the left side of the comparison is never smaller than the right side. How am I misunderstanding this?\n\nHere is my (messy) code:\n\n```\nclass Vertex\n{\nprivate:\n  int id;\n  unordered_map < Vertex*, int > edges;\n  int load_factor;\n  int distance;\n  bool known;\npublic:\n        //getters and setters\n};\n\nvoid dijkstra(Vertex starting_vertex)\n{\n  for (int i = 0; i < vertices.size(); i++)\n  {\n    //my program initially stores vertices in the vertex in spot (id - 1).\n\n    if (vertices[i].get_id() == starting_vertex.get_id())\n    {\n      vertices[i].set_distance(0);\n      vertices[i].set_known(true);\n    }\n    else\n    {\n      vertices[i].set_distance(10000000);\n      vertices[i].set_known(false);\n    }\n  }\n\n  for (int i = 0; i < vertices.size(); i++)\n  {\n    //while there is an unknown distance vertex\n    if (vertices[i].is_known() == false)\n    {\n      vertices[i].set_known(true);\n\n      //for every vertex adjacent to this vertex\n      for (pair<Vertex*, int> edge : vertices[i].get_edges())\n      {\n        //if the vertex isn't known\n        if (edge.first->is_known() == false)\n        {\n          //calculate the weight using Adam's note on dijkstra's algorithm\n          int weight = edge.second * edge.first->get_load_factor();\n\n          if (vertices[i].get_distance() + weight < edge.first->get_distance())\n          //this is my problem line. The left side is never smaller than the right.\n          {\n            edge.first->set_distance(vertices[i].get_distance() + weight);\n            path.add_vertex(edge.first);\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n\nThank you!\n    ", "Answer": "\r\nYou are missing out this step:\n\n```\nVertex v = smallest unknown distance vertex;\n```\n\n\nand instead looping through all vertices.\n\nThe distance to the starting vertex is initialized to ```\n0```\n so if you implement this part of the algorithm and pick the ```\nv```\n with the smallest distance that is not \"known\" you will start with the starting vertex and the ```\nif```\n should work.\n\nReplace:\n\n```\nfor (int i = 0; i < vertices.size(); i++)\n{\n  //while there is an unknown distance vertex\n  if (vertices[i].is_known() == false)\n  {\n    ...\n  }\n}\n```\n\n\nWith something like:\n\n```\nwhile(countNumberOfUnknownVertices(vertices) > 0)\n{\n  Vertex& v = findUnknownVertexWithSmallestDistance(vertices);\n  ...\n}\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Calculate number of jumps in Dijkstra's algorithm?\r\n                \r\nWhat is the fastest way in numpy to calculate the number of jumps that dijkstra's algorithm uses? I have a 10000x10000 element connectivity matrix and use scipy.sparse.csgraph.dijkstra to calculate the filled distance matrix and a predecessor matrix. My naive solution is as follows:\n\n```\nimport numpy as np\nfrom numpy.random import rand\nfrom scipy.sparse.csgraph import dijkstra\n\ndef dijkway(dijkpredmat, i, j):\n    \"\"\"calculate the path between two nodes in a dijkstra matrix\"\"\"\n    wayarr = []\n    while (i != j) & (j >= 0):\n        wayarr.append(j)\n        j = dijkpredmat[i,j]\n    return np.array(wayarr)\n\ndef jumpvec(pmat,node):\n    \"\"\"calculate number of jumps from one node to all others\"\"\"\n    jumps = np.zeros(len(pmat))\n    jumps[node] = -999\n    while 1:\n        try:\n            rvec = np.nonzero(jumps==0)[0]\n            r = rvec.min()\n            dway = dijkway(pmat, node, r)\n            jumps[dway] = np.arange(len(dway),0,-1)\n        except ValueError:\n            break\n    return jumps\n\n#Create a matrix\nmat = (rand(500,500)*20)\nmat[(rand(50000)*500).astype(int), (rand(50000)*500).astype(int)] = np.nan\ndmat,pmat = dijkstra(mat,return_predecessors=True)\n\ntimeit jumpvec(pmat,300)\nIn [25]: 10 loops, best of 3: 51.5 ms per loop\n```\n\n\n~50msek/node is OK but expanding the distance matrix to 10000 nodes increases the time to ~2sek/node. jumpvec has to be executed 10000 times then as well... \n    ", "Answer": "\r\nHere's an (asymptotically optimal) O(n) algorithm.\n\nCreate a set of unvisited vertices, initially all but the source vertex. Initialize to 0 the jump vector entry for the source to itself. While the set is not empty, pop an element v. Using the predecessor matrix, collect v and each successive ancestor in a list until you reach one already visited. Iterate through the list in reverse order, setting the jump vector entry of each node w to the entry for its parent plus 1, then removing w from the set.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Making Dijkstra's algorithm account for return travel time\r\n                \r\nso the question goes as follows: An unweighted tree is provided to me and allows me to start at any node, im expected to visit only certain nodes that ive been provided in an array. My goal is to find the amount of time it takes to travel to every node desired. Each edge takes a single minute to travel over.\n\nI have already attempted to implement Dijkstra's algorithm in order to begin at a node I want to visit and attempt to form a shortest path from there. \nbut my problem is that although a solution is provided it may not be the most efficient one as I do not know how to force Dijkstra's algorithm to account for traveling over the same edge twice.\n\n\nAn example of this problem being in the image above. Assuming that I desired to visit nodes[90,50,20,75] and I started at node 90 and traversed to node 50 then to node 20 how would i make Dijkstra's algorithm account for the return travel time to node 50 before reaching node 20?\n    ", "Answer": "\r\nLet me elaborate on my comments: First, we will fix an arbitrary root in the tree, such that the tree is rooted (maybe you already have a rooted tree). Then, the first step is finding a minimum length cycle that starts at the root and ends at the root and passes through all desired nodes.\n\nThis can be done in a divide-and-conquer approach. If you are at any node, you can check if you need to include that node in the path. If so, you do. Then, for every subtree, simply use the same approach and extend the path if necessary. Finally, make sure that the sub path returns to the current subtree's root (code follows).\n\nAfter you found the cycle, you need to remove the longest sub path such that you end up with a non cyclic path. This can be done in linear time by just walking through the cycle. In my implementation, I had the cycle extraction emit not only the sequence of nodes but also a flag that determines if the path simply passes through a node (and does not visit the node). Therefore, this step simply finds the path segment between any two nodes that are actually visited.\n\nThere is still one step missing that is necessary in order to assert optimality. But let me show you the code up to this point. I have implemented it in JavaScript because you can just run it on SO. The implementation is aimed at understandability and not efficiency.\n\n\r\n\r\n```\n//the tree from your example\r\nvar tree = { value: 90, children: [{ value: 50, children: [{ value: 20, children: [{ value: 5 }, { value: 25 }] }, { value: 75, children: [{ value: 66 }, { value: 80 }] }] }, { value: 150, children: [{ value: 95, children: [{ value: 92 }, { value: 111 }] }, { value: 175, children: [{ value: 166 }, { value: 200 }] }] }] };\r\n\r\nvar nodesToVisit = [90, 50, 20, 75];\r\n//var nodesToVisit = [92, 111, 166];\r\n\r\nfunction findCycle(treeNode, nodesToVisit) {\r\n\tvar subPath = [];\r\n\tvar currentNodeIncluded = false;\r\n\tif(nodesToVisit.indexOf(treeNode.value) != -1) {\r\n\t\t//this node should be visited\r\n\t\tsubPath.push({node: treeNode, passThrough: false});\r\n\t\tcurrentNodeIncluded = true;\r\n\t}\r\n\t\r\n\t//find the subpath for all subtrees\r\n\tif(treeNode.children) {\r\n\t\tfor(var i = 0; i < treeNode.children.length; ++i) {\r\n\t\t\tvar subTreePath = findCycle(treeNode.children[i], nodesToVisit);\r\n\t\t\tif(subTreePath.length > 0) {\r\n\t\t\t\tif(!currentNodeIncluded) {\r\n\t\t\t\t\tsubPath.push({node: treeNode, passThrough: true});\r\n\t\t\t\t\tcurrentNodeIncluded = true;\r\n\t\t\t\t}\t\t\t\r\n\t\t\t\t//if we need to visit this subtree, merge it to the current path\r\n\t\t\t\tsubPath = subPath.concat(subTreePath);\r\n\t\t\t\tsubPath.push({node: treeNode, passThrough: true}); //go back to the current node\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn subPath;\r\n}\r\n\r\nfunction removeLongestPassThroughSegment(cycle) {\r\n\tvar longestSegmentStart = -1;\r\n\tvar longestSegmentEnd = -1;\r\n\t\r\n\t//the start of the current pass-through segment between non-pass-through nodes\r\n\tvar currentStart = -1;\r\n\tvar segmentLengthAtStart = -1;\r\n\tfor(var i = 0; i < cycle.length; ++i) {\r\n\t\tif(!cycle[i].passThrough) {\r\n\t\t\t//we have found a node that we need to visit\r\n\t\t\tif(currentStart != -1) {\r\n\t\t\t\tvar length = i - currentStart;\r\n\t\t\t\tif(length > longestSegmentEnd - longestSegmentStart) {\r\n\t\t\t\t\tlongestSegmentStart = currentStart;\r\n\t\t\t\t\tlongestSegmentEnd = i;\r\n\t\t\t\t}\r\n\t\t\t} else\r\n\t\t\t\tsegmentLengthAtStart = i;\r\n\t\t\tcurrentStart = i;\r\n\t\t}\r\n\t}\r\n\t\r\n\t//check the path segment that wraps around\r\n\tif(cycle.length - currentStart + segmentLengthAtStart > longestSegmentEnd - longestSegmentStart) {\r\n\t\tlongestSegmentStart = currentStart;\r\n\t\tlongestSegmentEnd = segmentLengthAtStart;\r\n\t}\r\n\t\r\n\t//build the final path by cutting the longest segment\r\n\tvar path = [];\r\n\tvar i = longestSegmentEnd;\r\n\tdo {\r\n\t\tpath.push(cycle[i]);\r\n\t\ti++;\r\n\t\tif(i >= cycle.length)\r\n\t\t\ti = 0;\r\n\t} while(i != longestSegmentStart);\r\n\tpath.push(cycle[longestSegmentStart]);\r\n\treturn path;\r\n}\r\n\r\nfunction printPath(path) {\t\r\n\tfor(var i = 0; i < path.length; ++i)\r\n\t\tif(path[i].passThrough)\r\n\t\t\tconsole.log(\"Pass through \" + path[i].node.value);\r\n\t\telse\r\n\t\t\tconsole.log(\"Visit \" + path[i].node.value);\r\n}\r\n\r\nvar cycle = findCycle(tree, nodesToVisit);\r\nconsole.log(\"Cycle:\");\r\nprintPath(cycle);\r\n\r\nvar path = removeLongestPassThroughSegment(cycle);\r\nconsole.log(\"Final Path:\");\r\nprintPath(path);```\n\r\n\r\n\r\n\n\nYou will find that this code already finds the optimal solution and prints:\n\n```\nFinal Path:\nVisit 90\nVisit 50\nVisit 20\nPass through 50\nVisit 75\n```\n\n\nEven for a more challenging set of desired nodes, this gets to the optimal path (```\nvar nodesToVisit = [92, 111, 166];```\n):\n\n```\nFinal Path:\nVisit 92\nPath through 95\nVisit 111\nPass through 95\nPass through 150\nPass through 175\nVisit 166\n```\n\n\nNow the essential thing that makes this find the optimal solution is that the path segment that is cut in the end is actually the longest possible path segment. This is not necessarily the case in the above code because you are free to choose the order in which you process subtrees and if you are at a node that should be visited, you are free to put the actual visit (in contrast to pass-throughs) anywhere between the visited subtrees.\n\nIn order to do so, find the distance between all desired nodes (which can be done efficiently on a tree). The pair with the largest distance will be the start and end node. Hence, you need to make sure that their visits in the cycle occur subsequently (i.e. there is no other node visited between them). You can do this by enforcing specific visited nodes at the beginning and end of the path segments returned from your recursive calls. For example, let the recursive call also return if the sub path contains a start or end node. And in the calling function, put those sub paths in the correct order. This would also simplify the ```\nremoveLongestPassThroughSegment()```\n function since you already know what the longest path-through segment is.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm complexity vs BFS complexity\r\n                \r\nI've been practicing various algorithms and I just completed Dijkstra's algorithm to calculate the shortest distance between nodes on a graph. After completing the exercise leveraging an indexed minHeap, I also completed it leveraging BFS (solution attached). Which leads me to a couple of questions:\n\nIf my calculation for time complexity is correct - I've calculated the complexity of the attached solution to be O(v^2 + e) where V = the number of vertices and E = the number of edges. We iterate and touch each node once and only once, same for the edges. The v^2 comes from the shift operation since this happens on every iteration.\nThis BFS solution could be improved by leveraging something similar to an ArrayDeque in Java, this would give us O(1) operations everytime we pop off the front of the queue, and should reduce our time complexity down to O(v+e)\nIf the above is true, what are the advantages or use-cases for leveraging Dijkstra's algorithm as opposed to BFS. It seems that BFS would have a better time complexity (O(V+E)) than Dijkstra's O((V+E)*log(V)), and will protect against the case of negative cycles where as Dijkstra's will fall into an infinite loop in this case.\n\nSample input:\nedges = [[[1, 7]], [[2, 6], [3, 20], [4, 3]], [[3, 14]], [[4, 2]], [], []],\nstart = 0\n\n    ", "Answer": "\r\nBFS and Dijkstras algorithm compute two different things that are only in some cases the same.\nGiven a starting node ```\ns```\n\n\nBFS computes the shortest paths to all other nodes in terms of hops / the number of edges.\nDijkstras algorithm computes the shortest paths to all other nodes in terms of edge weights.\n\nThis are two different things but in some cases they are the same, e.g.\n\nthe graph is a tree (there is only one path between any given pair of nodes)\nall edge weights are equal (or the graph is unweighted).\n\nDijkstras algorithm has a time complexity of O(|V| log |V| + |E|) if implemented using Fibonacci-heaps, while BFS has a time complexity of O(|V| + |E|).\nSo you are correct that BFS might be a good choice if your input allows you to choose between them. However, in practice you might want to do some benchmarks first on real world data.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm with secondary cost limitation\r\n                \r\nAs part of a school assignment, I am required to implement Dijkstra's algorithm on a weighted, cyclic graph with a caveat - there exist a secondary weight/cost (henceforth referred to as B) on each edge, and the algorithm is to find the shortest path from a source node to a target node while keeping total B to be under a certain constant value.\nOn top of basic Dijkstra's, I have added an additional condition to the relaxation/update condition, which is that the current shortest path must be under the constant B value given.\n```\nif (no shortest path yet exists to neighbour node X or the current shortest path to the neighbour node is longer than the current shortest path to current node + current edge to neighbour node) and total **B** of current shortest path to current node + current edge to neighbour node is less than input **B** value:\n\n   update current shortest path to neighbour node\n```\n\nHowever, the result returned, is neither the shortest path or has the lowest B. In other words, there exists other paths with lower distance as well as cost B. May I ask what is the problem with my understanding?\nEdit: Current Code:\n```\nclass Node:\n    def __init__(self, node, p): \n        self.node = node\n        self.p = p\n\n    def __lt__(self, other):\n        return self.p < other.p\n    \n\ndef b_dijkstra(G, S, T, constraint):\n    start = [Node(S, 0.0)]                       # Creating initial start node using HeapQ and setting its value to 0.0\n    goal = set()\n    pred = dict()                                                         # Dictionary to store visited nodes in a graph\n    dist = dict()                                                     # Dictionary to store distance from point to point\n    b = dict()\n    pred[S] = None\n    dist[S] = 0.0\n    b[S] = 0.0\n    count = 0\n    while start:\n        count += 1\n        C = hq.heappop(start).node                   # Pop the smallest item off the heap, maintaining the heap invariant.\n        if C == T:\n            print('Nodes searched:',count)\n            print(' b:', b[C])\n            return traversal(T, pred)\n        goal.add(C)\n        #for each neighbour\n        for pointer in G[C]:\n            if pointer in goal:\n                continue\n            dist_temp = dist[C] + G[C][pointer]['weight']\n            b_temp =  b[C] + G[C][pointer]['b']\n            if (pointer not in dist or dist[pointer] > dist_temp) and constraint >= b_temp: #if stored distance is greater than the calculated distance\n                dist[pointer] = dist_temp\n                pred[pointer] = C\n                b[pointer] =  b_temp\n                hq.heappush(start, Node(pointer, dist[C] + G[C][pointer]['weight']))          # Adding vertex to queue\n    return []\n```\n\n    ", "Answer": "\r\nLet's assume you have this graph (weights given as weight/B) with a limit on B of 15. What will your algorithm do? If I understand you correctly, it will first find the shortest path to A costing 1/10 and then fail to find any path to End satisfying the condition on B. Is my understanding correct? If yes, it should be clear what is wrong with your algorithm.\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Implementing Dijkstra's Algorithm Using Directed Graphs\r\n                \r\nI am trying to implement Dijkstra's algorithm using a directed graph via an adjacency list. I found some sample code I have been using as an example. In that code, the graph is populated like this:\n\n```\nprivate static final Graph.Edge[] GRAPH = {\n    new Graph.Edge(\"a\", \"b\", 7),\n    new Graph.Edge(\"a\", \"c\", 9),\n    new Graph.Edge(\"a\", \"f\", 14),\n    new Graph.Edge(\"b\", \"c\", 10),\n    new Graph.Edge(\"b\", \"d\", 15),\n    new Graph.Edge(\"c\", \"d\", 11),\n    new Graph.Edge(\"c\", \"f\", 2),\n   new Graph.Edge(\"d\", \"e\", 6),\n    new Graph.Edge(\"e\", \"f\", 9),};\nprivate static final String START = \"a\";\nprivate static final String END = \"e\";\n```\n\n\nSince I need to populate from an adjacency list in a text file, I instead tried to do it in this manner:\n\n```\nList<Graph.Edge> list = new ArrayList<>();\n\n    try {\n        Scanner scanner = new Scanner(new File(filename));\n        while (scanner.hasNextLine()) {\n            String source = scanner.findInLine(NAME);\n            if (source != null) {\n                while (true) {\n                    String to = scanner.findInLine(NAME);\n                    if (to == null) {\n                        break;\n                    }\n                    int weight = Integer.valueOf(scanner.findInLine(WEIGHT));\n                    list.add(new Graph.Edge(source, to, weight));\n                }\n            }\n            scanner.nextLine();\n        }\n    } catch (FileNotFoundException | NumberFormatException e) {\n    }\n```\n\n\nwith \n\n```\nstatic final Pattern NAME = Pattern.compile(\"\\\\w+\");\nstatic final Pattern WEIGHT = Pattern.compile(\"\\\\d+\");\n```\n\n\nIn the sample code, they then run dijkstra's algorithm on the graph in the following way: \n\n```\nGraph g = new Graph(GRAPH);\n    g.dijkstra(START);\n    g.printPath(END);\n    g.printAllPaths();\n```\n\n\nI tried to update my code to work for this implementation of the algorithm. I came up with the following:\n\n```\ntry {\n        Scanner scanner = new Scanner(new File(filename));\n\n        while (scanner.hasNextLine()) {\n            String source = scanner.findInLine(NAME);\n            if (source != null) {\n                while (true) {\n                    String go = scanner.findInLine(NAME);\n                    if (go == null) {\n                        break;\n                    }\n                    int weight = Integer.valueOf(scanner.findInLine(WEIGHT));\n                    Graph.Edge edge = new Graph.Edge(source, go, weight);\n\n                    Graph g = new Graph(GRAPH);\n                    g.dijkstra(source);\n                    g.printPath(go);\n                }\n            }\n\n            scanner.nextLine();\n        }\n    } catch (FileNotFoundException | NumberFormatException e) {\n    }\n```\n\n\nWhen I try and run this, it seems to not correctly populate my graph. It produces the errors from the dijkstra and printPath method saying that \"Graph doesn't contain start/end vertex.\" How can I update my code so that the graph is correctly populated and able to implement the algorithm correctly? Thanks!\n\nEDIT: Here is a sample of my input file\n\n```\n1 2 1 3 1\n2 4 2\n3 2 2 5 4\n4 3 3 5 3\n5 1 4\n```\n\n\nIt follows the format source, adj. vertex, weight, adj. vertex, weight....\n\nEDIT 2: Use of Graph.Edge`\n\n```\nclass Graph {\n\nprivate final Map<String, Vertex> graph; // mapping of vertex names to Vertex objects, built from a set of Edges\n\n/**\n * One edge of the graph (only used by Graph constructor)\n */\npublic static class Edge {\n\n    public final String v1, v2;\n    public final int dist;\n\n    public Edge(String v1, String v2, int dist) {\n        this.v1 = v1;\n        this.v2 = v2;\n        this.dist = dist;\n    }\n}\n```\n\n\nand \n\n```\npublic Graph(Edge[] edges) {\n    graph = new HashMap<>(edges.length);\n\n    //one pass to find all vertices\n    for (Edge e : edges) {\n        if (!graph.containsKey(e.v1)) {\n            graph.put(e.v1, new Vertex(e.v1));\n        }\n        if (!graph.containsKey(e.v2)) {\n            graph.put(e.v2, new Vertex(e.v2));\n        }\n    }\n\n    //another pass to set neighbouring vertices\n    for (Edge e : edges) {\n        graph.get(e.v1).neighbours.put(graph.get(e.v2), e.dist);\n        //graph.get(e.v2).neighbours.put(graph.get(e.v1), e.dist); // also do this for an undirected graph\n    }\n}\n```\n\n\nEDIT: Here is where I found the original sample code from http://rosettacode.org/wiki/Dijkstra%27s_algorithm#Java\n    ", "Answer": "\r\nIn order to use the application with file input, use your first file input algorithm. Your second algorithm is useless unless you want to run each line of the file as a ```\nGraph```\n with only one ```\nVertex```\n.\n\nUse your code like this (I've put comments on the lines I've changed):\n\n```\nprivate static final Graph.Edge[] GRAPH = getEdges(\"input.txt\"); // <-- CHANGED THIS\nprivate static final String START = \"1\"; // <-- CHANGED THIS\nprivate static final String END = \"5\"; // <-- CHANGED THIS\n\nprivate static Graph.Edge[] getEdges(String fileName) { // <-- ADDED THIS\n    final Pattern NAME = Pattern.compile(\"\\\\w+\");\n    final Pattern WEIGHT = Pattern.compile(\"\\\\d+\");\n    List<Graph.Edge> list = new ArrayList<>();\n    try {\n        Scanner scanner = new Scanner(new File(fileName));\n        while (scanner.hasNextLine()) {\n            String source = scanner.findInLine(NAME);\n            if (source != null) {\n                while (true) {\n                    String to = scanner.findInLine(NAME);\n                    if (to == null) {\n                        break;\n                    }\n                    int weight = Integer.valueOf(scanner.findInLine(WEIGHT));\n                    list.add(new Graph.Edge(source, to, weight));\n                }\n            }\n            if (scanner.hasNextLine()) // <-- ADDED THIS\n                scanner.nextLine();\n        }\n    } catch (FileNotFoundException | NumberFormatException e) {\n    }\n    return list.toArray(new Graph.Edge[0]); // <-- ADDED THIS\n}\n```\n\n\nThen, run the application the same way:\n\n```\nGraph g = new Graph(GRAPH);\ng.dijkstra(START);\ng.printPath(END);\ng.printAllPaths();\n```\n\n\nI tested all of this, and also found that your algorithm for file input breaks on the last line of the file, so I added ```\nif (scanner.hasNextLine())```\n before ```\nscanner.nextLine();```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Does Dijkstra's algorithm apply even if there is only one negative weight edge?\r\n                \r\nWill Dijkstra's Algorithm work if the digraph has only one negative weight edge and does not contain negative weight cycles? \n    ", "Answer": "\r\nNo. Dijkstra's algorithm is greedy. It assumes path weights are strictly increasing.\n\nConsider the following graph. S→A→E is optimal, but the Dijkstra's will return S→B→E. \n\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "What is Dijkstra's algorithm supposed to return?\r\n                \r\nI'm a front-end Javascript developer but wanted to learn some graph theory to prepare for a Google interview, I looked up some implementations of Dijkstra's algorithm.\n\nThe example listed here \nhttps://github.com/mburst/dijkstras-algorithm/blob/master/dijkstras.js\nseems to be suited for finding the shortest path between two nodes and returns the shortest node path between them, but the pseudocode version on wikipedia seems to return both \"prev, and dist\"--- what are they supposed to be? \n\nI tried modifying the github example to match the wikipedia pseudocode and returning distances does seem to give the shortest numerical distances to each one from the startVertex... but prev is not returning the shortest paths\n\n```\nvar INFINITY = 1/0;\n\nfunction PriorityQueue () {\n  this._nodes = [];\n\n  this.enqueue = function (priority, key) {\n    this._nodes.push({key: key, priority: priority });\n    this.sort();\n  }\n  this.dequeue = function () {\n    return this._nodes.shift().key;\n  }\n  this.sort = function () {\n    this._nodes.sort(function (a, b) {\n      return a.priority - b.priority;\n    });\n  }\n  this.isEmpty = function () {\n    return !this._nodes.length;\n  }\n}\n\n\nfunction Graph(){\n  this.vertices = {};\n\n  this.addVertex = function(name, edges){\n    edges = edges || null;\n    this.vertices[name] = edges;\n  }\n}\n\n\nfunction djikstra(graph, startVertex) {\n  var nodes = new PriorityQueue();\n\n  var distances = {};\n  var previous = {};\n\n  for(vertex in graph.vertices) {\n    if (vertex === startVertex) {\n      distances[vertex] = 0;\n      nodes.enqueue(0, vertex);\n    } else {\n      distances[vertex] = INFINITY;\n      nodes.enqueue(INFINITY, vertex);\n    }\n\n    previous[vertex] = null;\n  }\n\n\n  while(!nodes.isEmpty()) {\n    var smallest = nodes.dequeue();\n\n    for(var neighbor in graph.vertices[smallest]) {\n      var alt = distances[smallest] + graph.vertices[smallest][neighbor];\n\n      if(alt < distances[neighbor]) {\n        distances[neighbor] = alt;\n        previous[neighbor] = smallest;\n      }\n    }\n  }\n\n  return distances;\n}\n\nvar graph = new Graph();\n\ngraph.addVertex('S', {V: 1, W: 4});\ngraph.addVertex('V', {W: 2, T: 6});\ngraph.addVertex('W', {T: 3});\ngraph.addVertex('T');\n\n\nconsole.log(djikstra(graph, 'S'));\n//\n{ S: 0, V: 1, W: 3, T: 6 }\n```\n\n    ", "Answer": "\r\nDijkstra algorithm is an algorithm which gives you the shortest distance from some point to all other points for a non-negative graph.\n\nThere are many different modifications. You can return distance between two nodes, distances between a node and all other nodes, distance and a path, distance and a previous node (which is enough to construct a path).\n\nSo in the case of wikipedia article - it returns you distances to all vertices and what is the previous vertex in the path to get your path.\n\nP.S. If you want to prepare for an interview, I suggest you to stop looking at random github repos (it may be really hard to understand the code of a particular person, which might be wrong/suboptimal), but instead open a book and try to understand the logic behind the algorithm. Especially if the algorithm can be written in < 50 lines.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Implementing Dijkstra's algorithm in Java\r\n                \r\nI've done a fair bit of reading around this, and know that discussions regarding this algorithm in Java have been semi-frequent. My issue with implementing Dijkstra's algorithm in Java is simply that I'm not sure how to prepare my data. \n\nI have a set of coordinates within an array, and a set of 1s and 0s in a matrix that represent whether there is a path between the points that the coordinates represent. My question is, how do I present this information so that I can search for the best path with Dijkstra? I have seen many people create a \"Node\" class, but they never seem to store the coordinates within that Node. Is there some standardized way of creating this kind of structure (I suppose it's a graph?) that I am simply missing? \n\nAny help would be appreciated.\n    ", "Answer": "\r\nThere are two main options:\n 1. You can use an adjacency matrix in which rows an columns represent your nodes. The value matrix[x, y] must be the weight(e.g. distance/cost etc.) to travel from x to y. You could use the Euclidian distance to calculate these values from your coordinate array;\n 2. You can implement a couple of classes (Node, Edge - or just Node with a internal Map to another node and the weight as a map value) - it is a graph indeed.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Python, Dijkstra's Algorithm visualization\r\n                \r\nI'm trying to visualize Dijkstra's Algorithm in python where each node is a square - see picture below. but something feels a bit off.\nI compared the result of the shortest path with standard A* and im not getting exactly the same path.\nI think my code is off but I don't realize how exactly.\nI'm using PriorityQueue\ngrid is a List of lists of objects -\neach object represents a cube on the screen-\ndraw - draws the grid onto screen\nthe code inside ** -code- ** is the part I edited after posting the question.\n```\n\ndef dijkstra_algorithm(grid, start, end):\n    # set up dist (distance to start) with infinity\n    dist = {elem: float(\"inf\") for row in grid for elem in row}\n\n    # distance from start to start is 0.\n    dist[start] = 0\n\n    # set up prev dict - prev[V] = U - represents that the shortest current path to X is through U\n    prev = {}\n\n    # create Priority Queue based on distance from origin and insert start to PQ\n    PQ = PriorityQueue()\n    counter = 0\n    # create hash table to check if element is inside PQ.\n    PQ.put((0, counter, start))\n    PQ_hash = {start}\n\n    # insert every elem except start into PQ with distance infinity\n    for row in grid:\n        for elem in row:\n            if elem != start:\n                PQ.put((dist[elem],**float(\"inf\")**, elem))\n                PQ_hash.add(elem)\n\n\n    # iterate untill PQ is empty\n    while not PQ.empty():\n        \n\n        current = PQ.get()[1]  # get element with min distance - index 1 in (dist[elem], elem)\n\n        # if what's left is infinitly far - there is no path from start to end\n        if dist[current] == float('inf'):\n            return False\n\n        PQ_hash.remove(current)  # remove element from Hash table (PQ.get removes elem from PQ)\n        current.set_closed() #(color - red)\n        draw_func() #(draw the grid)\n              \n        if current == end: #end node found\n\n            reconstruct_path(prev, current, draw_func) #draw path from end to start\n            end.set_end()\n            start.set_start()\n            return True # found\n\n        #iterate over all neighbors of current node\n\n        for neighbor in current.neighbors:\n            # if neighbor inside PQ\n\n            if neighbor in PQ_hash: \n                #calculate distance if we go to neighbor through current (+1 distance)\n                alt = dist[current] + 1\n\n                #if quicker - update\n                if alt < dist[neighbor]:\n                    dist[neighbor] = alt\n                    prev[neighbor] = current\n                  **counter += 1 **\n                    PQ.put((dist[neighbor],**counter**, neighbor))\n                    neighbor.set_open() #color green\n                    draw_func() #draw the grid\n    #path not found\n    return False\n```\n\nI think it has something to do with the fact that im Adding into PQ instead of editing, but I'm not sure.\nAlso, I'm sorry about the lack of PEP8, I've tried to comment my thoughts as I went I hope it's understandable.\n\n    ", "Answer": "\r\nAdding a counter to the elements that go into the PQ sorts everything out. PQ.put((0, counter, start)), the counter starts at zero at the beggining of the program, and each time we put an element into the PQ (the last if statement) we increment the counter, thus reducing the priority.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm for longest path\r\n                \r\nEDIT 2: This might be too late, but I figured out the problem, it was me. I misunderstood the project, it asked for the largest bandwidth path not the longest path. which is different but I didn't know until now. So basically in any bandwidth path problem (whether largest or smallest), the weights are not accumulated, the path value is determined by the smallest weight in the path. Think of it as a path of pipes and the water flow is determined by the thinest pipe along the path.\n\nEDIT 1: I fixed the PQ issue, but still not working.\n\nIt is an assignment (I admit), but I may fail the whole course if I don't submit it. We are supposed to modify Dijkstra's algorithm to calculate the longest SIMPLE path instead of the shortest path. I couldn't figure out a solution. I searched the Internet and found this (It is even the same problem).\n\nBut when I run it, it produces incorrect values. Is there any thing I'm missing ? Why even doesn't it sum the weight with the predecessor ? Why use min ?\n\nInfo about the graph:\n 1. We generate the graph randomly such that each node is connected to\n    about 25% of the other nodes.\n 2. Weights are positive.\n 3. There are 25 nodes in the graph.\n\nThe question says \"Routing Algorithm is the algorithm of finding maximum bandwidth path in a graph. It is based on modification of Dijkstra’s algorithm using a Max-Heap structure\". Is there any trick in it that may help ?\n\n```\npublic class MaxDijkstra {\n    Graph graph;\n    PriorityQueue<Node> queue;\n\n    public MaxDijkstra(Graph graph, Node s){\n        this.graph = graph;\n        s.addAttribute(\"ui.class\", \"start\");\n        queue = new PriorityQueue<>(new Comparator<Node>(){\n            @Override\n            public int compare(Node n1, Node n2) {\n                if(Utils.getNodeBW(n1) == Utils.getNodeBW(n2)){\n                    return 0;\n                }else if(Utils.getNodeBW(n1) < Utils.getNodeBW(n2)){\n                    return 1;\n                }else{\n                    return -1;\n                }\n            }\n        });\n\n        // init\n        for(Node n : graph){\n            Utils.setNodeBW(n, 0);\n        }\n        Utils.setNodeBW(s, Float.POSITIVE_INFINITY);\n\n        // add to Q\n        for(Node n : graph){\n            queue.add(n);\n        }\n\n        while(!queue.isEmpty()){\n            Node u = queue.remove();\n            Iterator<Node> iterator = u.getNeighborNodeIterator();\n            while(iterator.hasNext()){\n                Node v = iterator.next();\n                float min = Float.min(Utils.getNodeBW(u), Utils.getEdgeBW(u.getEdgeBetween(v)));\n                if(min > Utils.getNodeBW(v)){\n                    Utils.setNodeBW(v, min);\n                    Utils.setPreOfNode(v, u);\n                }\n            }\n\n            // validate PQ\n            // I know it is not good, just for debuggin now\n            // I will implemnt my own PQ later\n            List<Node> list = new ArrayList<>();\n            while(!queue.isEmpty()){\n                Node w = queue.remove();\n                list.add(w);\n            }\n            for(Node w : list){\n                queue.add(w);\n            }\n        }\n    }\n\n    public void printInfo(){\n        for(Node n : graph){\n            System.out.println(\"N=\"+n.getId()+\" D=\"+Utils.getNodeBW(n)+\" pre=\"+ (Utils.getPreOfNode(n) == null ? \"NIL\" : Utils.getPreOfNode(n).getId()) );\n        }\n    }\n\n    /**\n     * Just to colourise the path\n     * @param target \n     */\n    public void backtrack(Node target){\n        target.addAttribute(\"ui.class\", \"end\");\n        Node currunt = target;\n        Node pre = Utils.getPreOfNode(currunt);\n        while(pre != null){\n            currunt.getEdgeBetween(pre).addAttribute(\"ui.class\", \"route\");\n            currunt = pre;\n            pre = Utils.getPreOfNode(currunt);\n        }\n    }\n```\n\n\nSample output:\n\n\nThank you all in advance.\n    ", "Answer": "\r\nYou can't use Dijkstra's algorithm to find the longest simple path. This problem is NP-hard. In fact, there's no known polynomial solution to it. \n\nIf the graph is relatively small, you can use dynamic programming to get an ```\nO(2^n * poly(n))```\n solution, which is feasible for n ~ 20-30 (the state is mask of visited vertices and the last vertex. A transition is adding one vertex if it's possible).\n\nIf the graph is large, you can use different heuristics and approximations combined with local optimization techniques to get a good (but not necessarily an optimal) solution. \n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm for finding the shortest path?\r\n                \r\nSo I have been trying to implement the Dijkstra Algorithm to find the shortest path within a graph, but am running into several errors as I go along. First off, here's the actual question and the components I was given with it.\n\n\"Write a c++ function to implement Dijkstra's algorithm on a graph. The graph implementation is on Moodle, called IntroToGraphs.zip.The function takes two parameters: starting vertex and destination vertex. Print the shortest path and the shortest distance from the starting vertex to the destination vertex.\"\n\nvoid Graph::Dijkstra(string starting, string destination);\n\nThe vertex structure has been changed to include \"visited\", \"distance\" and \"previous\".\n\n```\nstruct adjVertex{\n    vertex *v;\n    int weight;\n};\nstruct vertex{\n    std::string name;\n    bool visited;\n    int distance;\n    vertex *previous;\n    std::vector<adjVertex> adj;\n};\n```\n\n\nHere is the definition of the Graph class:\n\n```\nclass Graph\n{\n    public:\n        Graph();\n        ~Graph();\n        void addEdge(std::string v1, std::string v2, int weight);\n        void addVertex(std::string name);\n        void displayEdges();\n    void Dijkstra(string sourceVertex, string destinationVertex);\n    protected:\n    private:\n        std::vector<vertex> vertices;\n\n};\n```\n\n\nHere's the code I've written:\n\n```\nvoid Graph::Dijkstra(string starting, string destination){\nvertex * start;\nvertex * ending;\nfor(int i=0;i<vertices.size();i++){\n    vertices[i].visited=false;\n    vertices[i].distance=INT_MAX;\n    vertices[i].previous=NULL;\n    if(vertices[i].name==starting){\n        start=&vertices[i];\n    }\n    if(vertices[i].name==destination){\n        ending=&vertices[i];\n    }\n}\nstart->visited=true;\nstart->distance=0;\nvector<vertex *> solved;\nvector<vertex *> path;\nvertex *tmp;\nvertex *parent;\nwhile(!ending->visited){ //pseudo territory\n    int minDistance=INT_MAX;\n    tmp=NULL;\n    for(int i=0;i<solved.size();i++){\n        vertex * s=solved[i];\n        for(int y=0;y<s->adj.size();y++){\n            if(!s->adj[y].v->visited){\n                s->distance=s->distance+s->adj[y].v->distance;\n                if(s->distance<minDistance){\n                    tmp=s->adj[y].v;\n                    minDistance=s->distance;\n                    parent=s->previous;\n                }\n            }\n        }\n    }\n}\ntmp->distance=minDistance;\ntmp->previous=parent;\ntmp->visited=true;}\n```\n\n\nThe error I'm hitting with this code is that minDistance is an unidentified variable at the very bottom, when I set tmp->distance to it. Any clues about what I need to fix?\n    ", "Answer": "\r\nAnything declared in the loop is scoped to that loop and cannot be accessed outside the curly braces. In fact, you don't even need a loop to create a new scope. More Info\n\nThe variable minDistance in declared inside the while loop.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "torch : Dijkstra's algorithm\r\n                \r\nI am working on 3D point clouds. I have the SPARSE MATRIX representation of the graph structure of the point cloud (like csr_matrix in scipy.sparse). I want to club together the points that are within certain threshold of the Geodesic distance (approximated by the path length in the graph) and process them together. TO FIND such points, I need to run some shortest path finding algorithm like Dijkstra's. In a nutshell, my idea is like this\n\nSample K points out of N points (that I could do using Furthest Point Sampling)\nFind the nearest Geodesic neighbours (using BackProp supported algorithm) for each of K points\nProcess the neighbours for each point using some Neural Network\n\nThis will go in my forward function.\nIs there a way to implement Dijkstra’s in my functionality?\nOr any other idea that I can implement?\nThank you very much!\n    ", "Answer": "\r\nI created my custom implementation for Dijkstra using priority queues as discussed here\nFor the same, I created a custom ```\nPriorityQ```\n class using torch function as below\n```\nclass priorityQ_torch(object):\n    \"\"\"Priority Q implelmentation in PyTorch\n\n    Args:\n        object ([torch.Tensor]): [The Queue to work on]\n    \"\"\"\n\n    def __init__(self, val):\n        self.q = torch.tensor([[val, 0]])\n        # self.top = self.q[0]\n        # self.isEmpty = self.q.shape[0] == 0\n\n    def push(self, x):\n        \"\"\"Pushes x to q based on weightvalue in x. Maintains ascending order\n\n        Args:\n            q ([torch.Tensor]): [The tensor queue arranged in ascending order of weight value]\n            x ([torch.Tensor]): [[index, weight] tensor to be inserted]\n\n        Returns:\n            [torch.Tensor]: [The queue tensor after correct insertion]\n        \"\"\"\n        if type(x) == np.ndarray:\n            x = torch.tensor(x)\n        if self.isEmpty():\n            self.q = x\n            self.q = torch.unsqueeze(self.q, dim=0)\n            return\n        idx = torch.searchsorted(self.q.T[1], x[1])\n        print(idx)\n        self.q = torch.vstack([self.q[0:idx], x, self.q[idx:]]).contiguous()\n\n    def top(self):\n        \"\"\"Returns the top element from the queue\n\n        Returns:\n            [torch.Tensor]: [top element]\n        \"\"\"\n        return self.q[0]\n\n    def pop(self):\n        \"\"\"pops(without return) the highest priority element with the minimum weight\n\n        Args:\n            q ([torch.Tensor]): [The tensor queue arranged in ascending order of weight value]\n\n        Returns:\n            [torch.Tensor]: [highest priority element]\n        \"\"\"\n        if self.isEmpty():\n            print(\"Can Not Pop\")\n        self.q = self.q[1:]\n\n    def isEmpty(self):\n        \"\"\"Checks is the priority queue is empty\n\n        Args:\n            q ([torch.Tensor]): [The tensor queue arranged in ascending order of weight value]\n\n        Returns:\n            [Bool] : [Returns True is empty]\n        \"\"\"\n        return self.q.shape[0] == 0\n\n```\n\nNow dijkstra, with adjacency matrix(with graph weights as input)\n```\ndef dijkstra(adj):\n    n = adj.shape[0]\n    distance_matrix = torch.zeros([n, n])\n    for i in range(n):\n        u = torch.zeros(n, dtype=torch.bool)\n        d = np.inf * torch.ones(n)\n        d[i] = 0\n        q = priorityQ_torch(i)\n        while not q.isEmpty():\n            v, d_v = q.top()  # point and distance\n            v = v.int()\n            q.pop()\n            if d_v != d[v]:\n                continue\n            for j, py in enumerate(adj[v]):\n                if py == 0 and j != v:\n                    continue\n                else:\n                    to = j\n                    weight = py\n                    if d[v] + py < d[to]:\n                        d[to] = d[v] + py\n                        q.push(torch.Tensor([to, d[to]]))\n        distance_matrix[i] = d\n    return distance_matrix\n```\n\nReturns shortest path distance matrix for the graph points!\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm Vs Uniform Cost Search (Time comlexity)\r\n                \r\nMy question is as follows: According to different sources, Dijkstra's algorithm is nothing but a variant of Uniform Cost Search. We know that Dijkstra's algorithm finds the shortest path between a source and all destinations ( single-source ). However, we can always modify Dijkstra to find the the shortest path between a START and a GOAL state ( when the goal is popped from the priority queue, we simply stop); but doing so, the worst case scenario will be still finding the shortest path from START to all other nodes ( suppose the goal is the furthest node in the graph).\n\nIf we implement Dijkstra's algorithm using a min-priority heap, the running time will be \n  O(V log V +E) , where E is the number of edges and V the number of vertices.\n\nSince Uniform Cost Search is the same as Dijkstra ( slightly different implementation), then the running time of UCS should be similar to Dijkstra, right? However, according to my AI class, Uniform Cost Search is exponential at the worst case, and it takes O(b1 + [C*/ε]), where C* is the cost of the optimal solution. ( b is the branching factor)\n\nHow can both algorithms be the same while they have different running times? Is the running time the same, but the way we look at it is different?\n\nI would appreciate your help :):) Thank you\n    ", "Answer": "\r\n\n  Is the running time the same, but the way we look at it is different?\n\n\nYes. Uniform cost search can be used on infinitely large graphs, on which Dijkstra's original algorithm would never terminate. In such situations, it's no use defining complexity in terms of V and E as both might be infinite and the resulting big-O figure meaningless.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Modifying Dijkstra's Algorithm to an A* implementation\r\n                \r\nI'm in the process of creating a maze simulation of a mouse running through a maze.  Dijkstra's algorithm is great and all but isn't particularly effected when cats are involved, which is why I'm trying to modify my existing Dijkstra implementation to an A* search with a heuristic for avoiding the cats which move throughout the maze.  \n\nThe problem I'm having while I look through some pseudocode is I am unsure of what structures are equivalent or what will I need to introduce to get this working. Can anyone provide any tips or nudges in the right direction?\n\n```\nstruct path_node *shortestPath(float A[GsizeSqr][GsizeSqr], int xi, int yi, int xf, int yf)\n{\n    /*\n    Solves for the shortest path between grid point (xi,yi) and (xf,yf)\n    on the graph encoded by A using Dijkstra's shortest path method.\n\n    The shortest path is returned as a linked list of nodes to be visited.\n\n    Keep track of visited nodes, and the predecessor\n    for each node that has been explored while computing the shortest path.*/\n\n    if (xi<0||xi>=Gsize&&yi<0&&yi>=Gsize||xf<0||xf>=Gsize||yf<0||yf>=Gsize)\n    {\n        fprintf(stderr,\"shortestPath(): Endpoint(s) outside of the graph!\\n\");\n        return(NULL);\n    }\n\n    int i, j, pCount, findN, row, col, icnt, stNode, finNode, xcnt, ycnt;\n    finNode = yf * ceil(sqrt(GsizeSqr)) + xf; //index of start node given its row and col value\n    stNode = yi * ceil(sqrt(GsizeSqr)) + xi; //index of finish node given its row and col value\n\n    int p[GsizeSqr]; //predecessors\n    int d[GsizeSqr]; //distance from source\n    int flags[GsizeSqr]; //(0, 1) for unvisited, visited)\n\n    int g_score[GsizeSqr];\n    int f_score[GsizeSqr];\n\n    PriorityQueue Q; //Initialize priority queue that stores (priority, key) values\n    Q = init_heap(GsizeSqr);    \n\n    path_node *start; //Maintain a pointer to the starting node\n    start = newPathNode(xi, yi);\n    start->next = NULL;\n\n    //Initialize p and d with infinity and NULL values (note: -1 means null and 1000000 means inf)\n    for(i=0; i < GsizeSqr; i++){\n        p[i] = -1;\n        d[i] = 10000000;\n        flags[i] = 0;\n    }\n\n    for(i=0; i < GsizeSqr; i++){\n        node in;\n        in = create_node(10000000, i);\n        enqueue(Q, in);\n    }\n\n    //(Note: PQ uses 0 as a sentinel node to make calculating left, right, and parents easier, elements begin at 1)\n    decrease_priority(Q, stNode+1, 0); //setting start node in PQ.\n    d[stNode] = 0;\n\n    g_score[stNode] = 0;\n    //For my heuristic, I'm thinking just using manhattan distances between mouse and cat agents\n    f_score[stNode] = g_score[stNode] + heuristic(xi, yi, xf, yf);\n\n    while(Q->heap_size != 1){ //while Q not empty\n        node u;\n        u = dequeue(Q);\n        flags[u.key] = 1;\n\n        //For each adjacent node A[u.key][i]\n        for(i=0; i < GsizeSqr; i++){\n            if(A[u.key][i] != 0){\n                findN = find_node(Q, i);\n                if(flags[i] == 0){ //If it is unvisited and new path distance is shorter\n                    if(findN != 0 && (d[i] >= A[u.key][i] + d[u.key])){ //reset values and update PQ and mark visited\n                        d[i] = A[u.key][i] + d[u.key];\n                        p[i] = u.key;                       \n                        flags[i] = 1;\n                        decrease_priority(Q, findN, d[i]);\n                    }\n                }\n            }\n        }\n    }\n\n    // Begin selectively filling our LL with values from p[]\n    icnt = finNode;\n    appendLL(start, xf, yf);\n    while(icnt != stNode){\n        icnt = p[icnt];\n        xcnt = icnt % (int)ceil(sqrt(GsizeSqr));\n        ycnt = icnt / (int)ceil(sqrt(GsizeSqr));\n        appendLL(start, xcnt, ycnt);\n    }\n\n    clean_heap(Q);\n    return reverseLL(start);\n}\n```\n\n    ", "Answer": "\r\nYou possibly already know this, but the only theoretical difference between A* and Dijkstra's algorithm in terms of best-first search is the cost function f(n).  Dijkstra's algorithm is ```\nf(n) = g(n)```\n whilst A* is ```\nf(n) = g(n) + h(n)```\n.  Read AIMA for details.\n\nIn terms of your code, it currently stores ```\ng(n) = A[u.key][i] + d[u.key]```\n in ```\nd[i]```\n, so you need to change it store g(n) + h(n).  You don't need those new ```\ng_score```\n and ```\nf_score```\n variables, just add the heuristic to the end of that line and the initialization of ```\nd[stNode]```\n.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm Does not generate Shortest Path?\r\n                \r\nI am working through a shortest path problem using Dijkstra's Algorithm. I am having trouble because the algorithm is supposed to provide the shortest path, but after running the algorithm I get a shorted path by hand. Is this just a by-product of this algorithm?\n\nThe path I am trying to generate is from a -> z\n\n\n\nHere is the path that I get from applying the algorithm, taking the shortest distance jump at each vertex I visit:\n\n```\n  2    4    2    2    1    2    1    1    8      = 23\na -> d -> g -> k -> r -> n -> q -> p -> t -> z\n```\n\n\n\n\nThis is confusing to me because if I take this path:\n\n```\n  4    2    2    2    2    2    2     = 16\na -> c -> f -> i -> m -> p -> s -> z\n```\n\n\nI get a distance that is 5 less than the distance generated from the algorithm.\n\nDid I misstep somewhere? \n    ", "Answer": "\r\nLooks like you misunderstand how Dijkstra's algorithm works. Instead of taking the edge with the smallest weight at each node, you always need to consider the total distance from the beginning (node $a$). You maintain a heap of all possible paths under consideration, which starts off as just the starting node with no edges and expands by adding all the paths with each outgoing edge of a node added to the path you're currently considering at each step.\n\nThat's a jumble of words trying to summarise where you went wrong. I suggest re-reading how Dijkstra's algorithm works: http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm to find shortest path\r\n                \r\nA particular state has a set of E roads among its set of V cities, where the time to traverse the road from city u to a neighbor city v is given by cuv. (Note that cuv need not equal cvu – in fact there may be no road from v to u.) After a snowstorm, some of the roads are impasable, but the governor needs to drive from city s to city t very soon, so soon that there is time to clear only one of the impassable roads. Give an O(E log V ) algorithm that determines which road to plow (one only) in order to achieve the minimum possible time path from a city s to city t. The input is a list of all the roads, the values cuv for each road, s, t, and the set of impassable roads. If road clearing is of no help, the algorithm should say so.\n\nI think the closest way to approach to this question is using Dijkstra's algorithm to find the shortest path, however, since we don't know which road is impassable and which road is passable, Dijkstra's algorithm seems inappropriate for this question. So, is there any other algorithm that able to check the condition of each edge and find the shortest path? Sorry about my logic, I don't understand this question very well, any response or hints will help, thanks.\n\nCould someone explain how my question is similar to Shortest path between two vertices when exactly one edge weight can be reduced by 50%?\n    ", "Answer": "\r\nLet's call the given graph G(V, E), where E can be split into D + F, where D represents the passable and F the impassible roads.\n\nAs suggested in comments, duplicate the graph, so you have G(V,D) and G'(V',D'). For any given vertex u ∈ V, there is a \"copy\" vertex u' ∈ V'. And so there is also an s' and a t'. We do not include F or F' at this point.\n\nThen define a set of edges F° as (u,v'), for each edge (u,v) ∈ F. So these edges in F° are passable connections from V to V' -- in that direction only. \n\nLet's call this new graph, G°(V°, E°), where V° = V + V', E° = D + D' + F°, and F° as defined in the previous paragraph.\n\nNow solve the problem of going from s to {t, t'} in G°. As there are no edges from V' to V, a solution path ending in t' will only use one edge (u,v') from F°. Note that if t is reached via a shorter path than t', this means that no edge from F° is used (no impassable road needs to be plowed).\n\nThe problem of finding the shortest path between s and {t, t'} in G° is now a standard problem that can be solved with Dijkstra's algorithm. One additional thing is needed: For each visited w' ∈ V', the edge (u,v') from F° -- that was crossed to get there -- needs to be logged. This information should just get passed on to the next vertex that the algorithm visits, so that when t' is finally found, the answer can be given immediately, i.e. that edge (u,v').\n\nThe number of edges visited in this algorithm is at most |E°| = |D + D' + F°| ≤ 2|E| = O(|E|). The algorithm visits every edge only once, so the time complexity is O(|E|).\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm Does not generate Shortest Path?\r\n                \r\nI am working through a shortest path problem using Dijkstra's Algorithm. I am having trouble because the algorithm is supposed to provide the shortest path, but after running the algorithm I get a shorted path by hand. Is this just a by-product of this algorithm?\n\nThe path I am trying to generate is from a -> z\n\n\n\nHere is the path that I get from applying the algorithm, taking the shortest distance jump at each vertex I visit:\n\n```\n  2    4    2    2    1    2    1    1    8      = 23\na -> d -> g -> k -> r -> n -> q -> p -> t -> z\n```\n\n\n\n\nThis is confusing to me because if I take this path:\n\n```\n  4    2    2    2    2    2    2     = 16\na -> c -> f -> i -> m -> p -> s -> z\n```\n\n\nI get a distance that is 5 less than the distance generated from the algorithm.\n\nDid I misstep somewhere? \n    ", "Answer": "\r\nLooks like you misunderstand how Dijkstra's algorithm works. Instead of taking the edge with the smallest weight at each node, you always need to consider the total distance from the beginning (node $a$). You maintain a heap of all possible paths under consideration, which starts off as just the starting node with no edges and expands by adding all the paths with each outgoing edge of a node added to the path you're currently considering at each step.\n\nThat's a jumble of words trying to summarise where you went wrong. I suggest re-reading how Dijkstra's algorithm works: http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Shortest Path and Dijkstra Algorithm\r\n                \r\nI cannot seem to find any indication to this question on the internet and as I am in exams I am running out of time, the question is pretty simple and any explanation would be welcoming(although a simple yes or no will do as well).\n\nFor Dijkstra's algorithm, must a graph be strongly connected? That is every vertice can be reached from any other vertice? Or is it possible to have vertices that are unreachable and thus you must start at another node using the algorithm?\n\nTo add to this question: Does Dijkstra's algorithm only apply to undirected graphs? as all the examples in my textbook relate to undirected edges.\n    ", "Answer": "\r\nAn undirected graph is basically just a directed graph, but with bidirectional connections. So no, Dijkstra's can also be applied to directed graphs.\n\nFor weakly connected graphs, it depends.\n\nSay you have graph section A and graph section B. You can go from A into B, but not from B into A. If you start at A and want to find a shortest path into B, Dijkstra's will work. But naturally, you can't start at B and try to find a path to a node at A. \n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Can I use Dijkstra's algorithm on DAG with negative weighted edges?\r\n                \r\nI understand that Dijkstra's algorithm cannot be used for negative weight edges since it could mess up distances for vertices already in the cloud.\n\nBut what if the directed graph doesn't contain a cycle i.e directed acyclic graph (DAG)? I think Dijkstra's algorithm can be used even with negative weighted edges to find the minimum cost path. \n    ", "Answer": "\r\nNo, it cannot be used when there are negative weights. The reason is that it is a greedy algorithm. Once it has chosen the minimum distance node it does not reconsider this choice. Negative weights would allow that some other node later in the algorithm becomes lower.\n\nHere is a simple counter example:\n\n```\nstart  -- 1 ----------> end\n    |                    ^\n    \\ -- 2 --> x -- -3 --/\n```\n\n\nIn this case the algorithm gives you the direct path of weight 1 instead of the shorter path via node x with weight -1.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm to calculate N shortest paths\r\n                \r\nIs it possible that ```\nDijkstra's Algorithm```\n can be used to calculate N shortest paths from single source to a single destination, where N is the number of nodes? I understand that Dijkstra outputs the shortest path from a single source to all nodes in the graph but while I was reading a research paper, the author mentioned the use of Dijkstra to calculate N shortest paths between ```\ns```\n and ```\nt```\n and that what confuses me a bit.\n\nThe following is a quote from the original paper:\nCapitalizing on SDN-Based SCADA Systems: An Anti-Eavesdropping Case-Study Found also here\n\n\n  Dijkstra’s algorithm [22] is used to calculate the N shortest routes (step 5), in N stages. Considering N = 2, in the first stage, Dijkstra’s algorithm identifies the shortest route between the two network devices, and subsequently all link costs have their weight increased by a tenfold factor. Immediately after, in the second stage (and with the link costs increased), Dijkstra’s algorithm is executed again to return the second shortest route. Finally, also in the second stage, the link costs of the first route are reestablished to the original values. As explained later, the N shortest routes will be used to deliver a communication flow using different paths and, for this reason, they are stored to be used afterwards\n\n    ", "Answer": "\r\nThe ```\nN```\n here appears to be a parameter the authors control, not specific to the graph traversal algorithm. They use the algorithm to find the shortest path between a source and target station.\n\n\n  Next, the algorithm\n  calculates the N shortest routes between the master station and\n  the specific substation, ...\n\n\n```\nN```\n is the number of stages. They do it once, find the shortest path, and bump the cost on the links (multiply it by 10). Then they run the algorithm again on the new updated link costs to find the second shortest (least cost) path, and so on, ```\nN```\n times. \n\nThen at the very end they reset the link costs to their original values.\n\nThey are not describing some fancy N-pairs shortest paths, but merely an application of the same classic shortest-path-between-```\ns```\n-and-```\nt```\n algorithm ```\nN```\n times (with different link costs at each run).\n\nother variants\n\nQuoting wikipedia on this:\n\n\n  The algorithm exists in many variants; Dijkstra's original variant found the shortest path between two nodes,[2] but a more common variant fixes a single node as the \"source\" node and finds shortest paths from the source to all other nodes in the graph, producing a shortest path tree.\n\n\nYou could use one run of Dijkstra's to compute from one selected source node the shortest path to all other nodes, but in the paper's case here, it's always between the same source (master station), and destination (substation).\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "dynamic graphic representation for extended dijkstra's algorithm\r\n                \r\nI am working on a project which requires to show the output of the extended Dijkstra's algorithm in a dynamic form. I tried and till now i am getting static graphs only. By dynamic I mean that I want to show nodes traveling through the relevant path according to the algorithm Using java language, as the Dijkstra is also in java. So how and which libraries can I be using? A detailed description would be nice. Thanks.\n    ", "Answer": "\r\nIn order to visualize the inner workings of an algorithm, you will have to implement the algorithm yourself. If you use a library, you will not have access to the internal variables (such as the \"nodes traveling through the relevant path\").\n\nBest advice: Find a visualization of some path algorithm written in Java. Study the code and see how it works. Then implement Dijkstra's algorithm in Java (make sure it is correct). Finally add the visualization code.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm returning incorrect values\r\n                \r\nI've hit a wall in attempting to understand Dijkstra's algorithm. The algorithm, in short, finds the shortest distances between A and B given distances between the two.\n\nI will post my version of the algorithm (I haven't had much success looking online thus far), followed by the distances between nodes.\n\n```\nvoid GraphM::findShortestPath()\n{\n    for (int i = 1; i <= nodeCount; i++)    // From Node i...\n    {\n        for (int v = 1; v <= nodeCount; v++) // ...through Node v...\n        {\n            for (int w = 1; w <= nodeCount; w++) // ...to Node w\n            {\n                if (!T[i][w].visited || !T[i][v].visited)\n                {\n                    T[i][w].dist = min(T[i][w].dist, T[i][v].dist + C[v][w]);\n                    T[i][v].visited = true;\n                    T[i][w].visited = true;\n                }           \n            }\n        }\n    }\n\n    cout << \"1 to 2 is \" << T[1][2].dist << endl; \n}\n```\n\n\nThis outputs the following:\n\n```\n1 to 2 is 48```\n\n\n...when it should be\n\n```\n1 to 2 is 40```\n\n\nThe values I'm working with are as follows:\n\n```\n1 2 50\n1 3 20\n1 5 30\n2 4 10\n3 2 20\n3 4 40\n5 2 20\n5 4 25\n```\n\n\n...where, in each line, the first token is the first node, the second token is the second node, and the third token is the distance between those nodes (in the algorithm's case, these tokens would be i, v, and T[i][v].dist). In the algorithm, nodeCount is the number of nodes in the grid (5), and w is a node that we are looking for the distance to, from i. C[v][w] returns the original distance between v and w. So, if v was 5 and w was 2, C[v][w] would return 20. This is constant, whereas T[v][w].dist (for instance) can be changed.\n\nAny nonexistant node relationships such as C[5][3] or T[1][4].dist (at least at the outset) return INT_MAX, which is equivalent to infinity. \n\nAlso, for anyone wondering; yes, this is a homework assignment. Unfortunately, my professor has necessitated some specific details (such as using a struct T), and she never went into much detail on how to write Dijkstra's algorithm into code, other than a somewhat vague outline. I am simply asking if someone can tell me what I am doing wrong and how to fix it, if possible. \n\nAny help is very much appreciated and would save me a lot of time from banging my head against a wall. \n    ", "Answer": "\r\nThis is not Dijkstra's algorithm. What you are trying to implement is Floyd-Warshall algorithm. This would find the minimum distance for all pair of vertices.\n\nhttp://en.wikipedia.org/wiki/Floyd–Warshall_algorithm\n\nNote that the first loop loops through the transfer node. With this implementation you don't need to remember which edge you already visited.\n\n```\nvoid GraphM::findShortestPath()\n{  \n    // Initialize T[i][j] to C[i][j] or MAX_INT here\n    for (int k = 1; k <= nodeCount; k++)    // Through Node k...\n    {\n        for (int u = 1; u <= nodeCount; u++) // ...From Node u...\n        {\n            for (int v = 1; v <= nodeCount; u++) // ...to Node v\n            {\n                // if going through k provides a cheaper path, update T[u][v]\n                T[u][v] = min(T[u][v], T[u][k] + T[k][v]);           \n            }\n        }\n    }\n\n    cout << \"1 to 2 is \" << T[1][2]<< endl; \n}\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm: adjacency matrix complexity issue\r\n                \r\nI have an assignment to implement Dijkstra's Algorithm. We're given skeleton code that inputs the graph as an adjacency matrix, but told our solution must run in O(MlogN) {M-edges, N-vertices}. I see how a PQ and list structure would accomplish this, but I don't see how I can avoid an O(N^2) solution in my case. The only way to get out of the matrix is to iterate through every row and column...right?\n    ", "Answer": "\r\nWrong. Your task isn't to perform manipulations on every value in the matrix but to find shortest path between 2 nodes. Matrix in your case is a medium to hold the data and it doesn't change the complexity of the algorithm. The ```\nO(MlogN)```\n algorithm is available freely, e.g. here: Dijkstra's algorithm.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "dijkstra's algorithm - from A to B\r\n                \r\nI know what dijkstra's algorithm is. And I know it is optimal when used for finding all the paths from A to all other possible nodes. However is it optimal if you are trying to find the path from A to B? In other words, should it be used when searching a path from A to B or are there other better algorithms for this use case.\n\nEDIT: If I break the loop exactly after I have found my destination node I think that it won't work. Let's say I have this graph https://i.stack.imgur.com/orp0N.png and I am trying to go from A to D. Since this algorithm is greedy it will first go A->B, B->F(dead end), B->E, E->D and the total weight will be 9. Although there is a shorter path. Which will be found eventually after this path.\n    ", "Answer": "\r\nYou don't need to find the distance to ALL nodes from A. You simply quit the loop after you put B into shortest-path tree.\nThere is no better algorithm from the point of view of performance. All algorithms finding shortest path from a specific node run with O(n^2) in the worst case. \n\nEDIT. However a slightly better performance could be achieved if we take into account some specific features of a processed graph (e.g. the ratio of the number of vertices and edges)\n\nEDIT2.  Regarding your sample graph. Here are the steps:\n1. A is added to shortest-path tree (SPT)\n2. Update its neighbors not in SPT. dist(B)=3\n3. Pick vertex with min.dist. not in SPT. that's B. add B to SPT.\n4. Update its neighbors not in SPT. dist(C)=6, dist(E)=5, dist(F)=4\n5. Pick vertex with min.dist. not in SPT. that's F. add F to SPT.\n6. F has no neighbors.\n7. Pick vertex with min.dist. not in SPT. that's E. add E to SPT.\n8. Update its neighbors not in SPT. dist(D)=9\n9. Pick vertex with min.dist. not in SPT. that's C. add C to SPT.\n10. Update its neighbors not in SPT. dist(D)=7.\n11. Pick vertex with min.dist. not in SPT. that's D. add D to SPT.\nDone\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra Algorithm Running Slowly\r\n                \r\nI made an implementation of Dijkstra's Algorithm and it does work. But when my graph (which is dense) has around 500000 vertices, the algorithm takes too long (more than a minute). It's also taking unusually long to read in the file containing the graph. I'm not sure what's the bottleneck in my program. Below is my code for the algorithm and the hashtable and heap implementations I made with it.\nDijkstra Implementation\n```\n#include \"heap.cpp\"\n#include <list>\n//#include <iostream>\n#include <fstream>\n//#include <string>\n#include <iostream>\n#include <sstream>\n#include <chrono>\nusing namespace std::chrono;\nusing namespace std;\n\n//Graph class\n//representation of the graph\nclass Graph\n{\npublic:\n    //maps vertex ids to pointers to them\n    hashTable* vertices;\n    //used to get the unknown vertex with the smallest dv in O(log|V|) time\n    //each node in the heap also stores a pointer to the vertex\n    heap* unknown;\n    //a list of the ids of the vectors\n    list<string> nodes;\n    Graph()\n    {\n        //simply creates the hashtable for vertices\n        vertices = new hashTable();\n    }\n\n    class Vertex;\n\n    //Edge Class\n    //representation of the directed edge between two vertices\n    //stores the weight of the edge and the vertex the edge points to\n    class Edge\n    {\n    public:\n        int weight;\n        Vertex* destination;\n        Edge(int cost, Vertex* to)\n        {\n            weight = cost;\n            destination = to;\n        }\n    };\n\n    //Vertex Class\n    //stores the id, the shortest known distance from source vertex to it\n    //the previous vector in that shortest known path\n    //and a list of pointers to outgoing edges from it\n    class Vertex\n    {\n    public:\n        string id;\n        int dv;\n        Vertex* prev;\n        list<Edge*> adjacent;\n        Vertex(string name, int distance, Vertex* previous, list<Edge*> adjacentList)\n        {\n            id = name;\n            dv = distance;\n            previous = prev;\n            adjacent = adjacentList;\n        }\n    };\n\n//insert function\n//returns false if the user is attempting to make a loop\n//or if the weights entered either aren't positive or are greater than 1 million\n//returns true on success\n//inserts vertex id and pointer into the hashtable if not already there\n//adds a pointer to the newly formed outgoing edge into v1's adjaency list\n\nbool insert(string id1, string id2, int weight)\n{\n    if(id1.compare(id2) == 0 or weight < 0 or weight > 1000000)\n    {\n        return false;\n    }\n\n    //if the vertex hasn't been seen before\n    if (not (vertices -> contains(id1)))\n    {\n        //create a pointer to the new vertex\n        Vertex* vert1 = new Vertex(id1, INT_MAX,  nullptr, list<Edge *>());\n        //insert it into the hashtable\n        vertices -> insert(id1, vert1);\n        //insert its id into nodes\n        nodes.push_back(id1);\n    }\n\n    if (not (vertices -> contains(id2)))\n    {\n        Vertex * vert2 = new Vertex(id2, INT_MAX,  nullptr, list<Edge *>());\n        vertices -> insert(id2, vert2);\n        nodes.push_back(id2);\n    }\n\n    //update v1's adjaency list\n    (((Vertex*)(vertices -> getPointer(id1))) -> adjacent).push_back(new Edge(weight, ((Vertex*)(vertices -> getPointer(id2)))));\n\n\n    return true;\n}\n\n\n//finds shortest path from source vertex\n//to every vertex in graph\n//returns false if vertex given isn't in the graph\n//true upon success\nbool Dijkstra(Vertex source)\n{\n    if(not(vertices -> contains(source.id)))\n    {\n        return false;\n    }\n\n    //initialize the heap\n    unknown = new heap(nodes.size());\n\n    //insert every vertex id into the heap and set their keys to INT_MAX\n    for (auto const& i: nodes)\n    {\n        unknown -> insert(i, INT_MAX, vertices ->getPointer(i));\n    }\n\n    //get the pointer for the source node from the hashtable\n    Vertex * start = (Vertex *) vertices -> getPointer(source.id);\n    //set its dv to 0\n    start -> dv = 0;\n    //fix the heap\n    unknown -> setKey(source.id, 0);\n\n    Vertex* chosen;\n    int iterations = 0;\n    string id;\n\n    for(int iterations = 0; iterations < nodes.size(); iterations ++)\n    {\n        //extract from heap unknown vertex with smallest dv\n        unknown -> deleteMin(nullptr, nullptr, &chosen);\n\n        //if the min dv in this heap is INT_MAX\n        //the rest of the unknown vertices don't have a path to the source vertex\n        //so we're done and we can break\n        if(chosen -> dv == INT_MAX)\n        {\n            //continue;\n            break;\n        }\n\n\n        //go through its adjaency list and update values\n        for (auto const& next : chosen -> adjacent)\n        {\n            //if chosen_dv + next -> weight < next_dv\n            //update dv value on the destination vertex and in the heap\n            //make prev of destination vertex chosen\n            //else do nothing\n            if(chosen -> dv + next -> weight < next -> destination -> dv)\n            {\n                next -> destination -> dv = chosen -> dv + next -> weight;\n                next -> destination -> prev = chosen;\n                unknown -> setKey(next -> destination -> id, next -> destination -> dv);\n            }\n        }\n    }\n    return true;\n}\n\n//gets shortest path from given vertex to source\nstring getPath(Vertex* source)\n{\n    //if we reached the source vertex\n    if(source -> dv == 0)\n    {\n        //return its id\n        return  source -> id + \", \";\n    }\n    //find the shortest path from the vertex before the given vertex in the path\n    return  getPath(source -> prev) + source -> id + \", \";\n}\n\n//returns shortest path from source vertex to every vertex in graph\nstring printSolution()\n{\n    string output = \"\";\n    Vertex* source;\n    string path = \"\";\n\n    //iterate through list of vertices\n    for(auto const& start: nodes)\n    {\n        //get the pointer to the vertex from the hashtable\n        source = (Vertex*)vertices -> getPointer(start);\n        output += start + \" : \";\n\n        //if the dv is still INT_MAX, there was no path from the source to it\n        if(source -> dv == INT_MAX)\n        {\n            path = \"NO PATH\\n\";\n        }\n        else\n        {\n            output += to_string(source -> dv) + \" \";\n            path = \"[\" + getPath(source);\n            path.erase(path.size() - 2);\n            path += \"]\\n\";\n        }\n        output += path;\n    }\n    return output.erase(output.size() - 1);\n}\n\n\n\n};\n\n//prompts user for input\n//processes and gives back the results\n//of Dijkstra's Algorithm\nvoid Processor()\n{\n    //variables that will store user input\n    string input, output, vertex;\n\n    //prompt user for graph file name\n    cout << \"Enter name of graph file: \";\n    //store it in input\n    cin >> input;\n\n    //make graph object\n    Graph* chart = new Graph();\n\n    //open input file\n    ifstream myfile;\n    myfile.open(input);\n    string line, arg;\n\n    //vector of arguments to be fed into insert\n    vector<string> arguments;\n    while(getline(myfile, line))\n    {\n        stringstream ss(line);\n        //parse each line by space to get arguments\n        while(getline(ss, arg, ' ' ))\n        {\n            arguments.push_back(arg);\n        }\n        //insert into the graph\n        chart -> insert(arguments[0], arguments[1], stoi(arguments[2]));\n        arguments.clear();\n    }\n    myfile.close();\n\n    while(true)\n    {\n        //prompt user for start vertex\n        cout<< \"Enter name of starting vertex: \";\n        cin >>  vertex;\n        //if the vertex isn't in the graph\n        //keep on prompting them until they give a valid one\n        if(chart -> vertices -> contains(vertex))\n        {\n            break;\n        }\n    }\n\n    //get the start vertex from the hashtable\n    Graph::Vertex source =  *(Graph::Vertex *)(chart -> vertices -> getPointer(vertex));\n\n    //time Dijkstra's algorithm\n    auto start = high_resolution_clock::now();\n    chart -> Dijkstra(source);\n    string result = chart -> printSolution();\n    auto stop = high_resolution_clock::now();\n\n    auto duration = duration_cast<milliseconds>(stop - start);\n\n    cout << \"Total time (in seconds) to apply Dijkstra's algorithm: \"\n         << float(duration.count())/1000<< endl;\n\n    //prompt user for output file\n    cout << \"Enter name of output file: \";\n    cin >> output;\n\n    //open output file\n    ofstream outfile;\n    outfile.open(output);\n    \n    //write the results of the algorithm to the file\n    outfile << result;\n    outfile.close();\n\n}\n\n//just calls on Processor\nint main()\n{\n    Processor();\n\n    return 0;\n}\n```\n\nHeap\n```\n#include \"heap.h\"\n\n//constructor for heap object\n//capacity: measure of how much space in heap is left\n//size: measure of how many elements (nodes) in heap\n//map is a hashTable that allows for constant time access to pointers to nodes from their ids\n//creates a hashTable\nheap::heap(int length)\n{\n    data.resize(length + 1);\n    capacity = length;\n    size = 0;\n    map = new hashTable(2*capacity);\n}\n\n//constructor for node object\n//has an id which is used by the hashTable\n//a key which is used to determine its position in the heap\nheap::node::node(std::string identi, int pass, void* pvData)\n{\n    id = identi;\n    key = pass;\n    pData = pvData;\n}\n\nint heap::insert(const std::string &id, int key, void *pv)\n{\n    //if the heap is almost full, return 1\n    if (size == capacity)\n    {\n        return 1;\n    }\n    //if the id is already in use, return 2\n    if(map -> contains(id))\n    {\n        return 2;\n    }\n    int index = size + 1;\n    node element(id, key, pv);\n    data[index] = element;\n    map -> insert(id, &data[index]);\n\n    percolateUp(index);\n    size += 1;\n    return 0;\n}\n\nvoid heap::percolateDown(int posCur)\n{\n    int index = posCur;\n    int child;\n    node element = data[index];\n\n    while(index*2 <= size)\n    {\n        child = index *2;\n        if(child != size and data[child + 1].key < (data[child].key))\n        {\n            child += 1;\n        }\n\n        if(data[child].key < element.key)\n        {\n            data[index] = data[child];\n            map -> setPointer(data[index].id, &data[index]);\n            index = child;\n        }\n        else\n        {\n            break;\n        }\n    }\n    data[index] = element;\n    map -> setPointer(data[index].id, &data[index]);\n}\n\n\nvoid heap::percolateUp(int posCur)\n{\n    int index = posCur;\n    node element = data[index];\n\n    while(index > 1 and element.key < data[index /2].key)\n    {\n        data[index] = data[index / 2];\n        map -> setPointer(data[index].id, &data[index]);\n        index = index / 2;\n    }\n    data[index] = element;\n    map -> setPointer(data[index].id, &data[index]);\n}\n\nint heap::setKey(const std::string &id, int key)\n{\n    if (not map -> contains(id))\n    {\n        return 1;\n    }\n\n    node *element = ((node*)(map -> getPointer(id)));\n    int index = getPos(element);\n    data[index].key = key;\n\n    percolateUp(index);\n\n    index = getPos(element);\n\n    percolateDown(index);\n\n    return 0;\n}\n\n\nint heap::remove(const std::string &id, int *pKey, void *ppData)\n{\n    if(size == 0 or not(map -> contains(id)))\n    {\n        return 1;\n    }\n    node * pv = ((node*)(map -> getPointer(id)));\n    int index = getPos(pv);\n    if(pKey != nullptr)\n    {\n        *pKey = data[index].key;\n    }\n    if(ppData != nullptr)\n    {\n        int *ppData = (int *)data[index].pData;\n    }\n    setKey(id, -INT_MAX);\n    deletion(id);\n    return 0;\n}\n\nint heap::deleteMin(std::string *pId, int *pKey, void *ppData)\n{\n    if(size == 0)\n    {\n        return 1;\n    }\n    if(pId != nullptr)\n    {\n        *pId = data[1].id;\n    }\n    if(pKey != nullptr)\n    {\n        *pKey = data[1].key;\n    }\n    if(ppData != nullptr)\n    {\n        *(static_cast<void **> (ppData)) = data[1].pData;\n    }\n    deletion(data[1].id);\n\n    return 0;\n}\n\nvoid heap::deletion(std::string id)\n{\n    node * pv = ((node*)(map -> getPointer(id)));\n    int index = getPos(pv);\n    node removed = data[index];\n    data[index] = data[size];\n\n    data[size] = removed;\n    map -> remove(data[size].id);\n    size -= 1;\n    percolateDown(index);\n    percolateUp(index);\n\n}\n\n\n\n```\n\nHashtable Implementation\n```\n#include \"hash.h\"\n#include <typeinfo>\n\n//returns a prime number depending on size required for hash table\n//supports a size of up to one million\nunsigned int hashTable::getPrime(int size)\n{\n    if (size <= 10000) { return 12373;}\n    if (size <= 20000) {return 25867;}\n    if (size <= 50000) {return 51479;}\n    if (size <= 100000) {return 109211;}\n    if (size <= 200000) {return 202717;}\n    if (size <= 400000) {return 410299;}\n    if (size <= 800000) {return 803549;}\n    if (size <= 1600000) {return 2001101;}\n    return 3200983;\n}\n\n// constructor for hashTable class\n//takes initial size input and makes size of table from getPrime\n//sets capacity to be initially the size of the hash table\nhashTable::hashTable(int size)\n{\n    int num = getPrime(size);\n    length = num;\n    data.resize(num);\n    capacity = length;\n    filled = 0;\n}\n\n\n\n//hash function\n//uses linear probing in the event of a collision\n//which is where the function goes from the index\n//where the initial hash sent the string to and \n//goes down the table until it either finds a free space\n//or it finds the hashitem with that key value\nint hashTable::hash(const std::string &key)\n{\n    int hashVal = 0;\n    for(char ch: key)\n    {\n        hashVal = 37*hashVal + ch;\n    }\n    int i = 0;\n\n    if (data[hashVal % length].isOccupied)\n    {\n        while( data[(hashVal + i) % length].isOccupied and \n            (data[(hashVal + i)% length].key).compare(key) != 0)\n        {\n            i += 1;\n        }\n    }\n    return (hashVal + i) % length;\n}\n\n//insert function inserts key into position given by hash function\n//changes filled and capacity number\n//returns 0 on success, 1 when the key has already been inserted\n//and 2 if there was a memory allocation error in the rehash function\n//if the loading size exceeds 0.5, it rehashes\n//this means that at any given time, the hashtable only uses a 1/3 of its actual size\n//which is necessary in order to decrease the likelihood of collisions\nint hashTable::insert(const std::string &key, void *pv)\n{\n    //if the key has already been inserted return 1\n    //but if the hash item has been deleted, we could insert this key in its place\n    //i didn't put this before, this could be what was missing from my code\n    int index = hash(key);\n    if (((data[index].key).compare(key) == 0) && not(data[index].isDeleted))\n    {\n        return 1;\n    }\n    data[index] = hashItem();\n    data[index].isOccupied = true;\n    data[index].isDeleted = false;\n    data[index].key = key;\n    data[index].pv = pv;\n    filled += 1;\n    capacity -= 1;\n    if (filled/length > 0.7)\n    {\n        if (not rehash())\n        {\n            return 2;\n        }\n    }\n    return 0;\n}\n\n//multiplies the size of the table by 2\n//resizes it based on getPrime of new size\n//uses a try catch block on the portion where\n//the table is resized\n//returns false if memory allocation error occurs\n//true if successful\nbool hashTable::rehash()\n{\n    int m = data.size();\n\n    std::vector<hashItem> temp(data);\n    //make temporary vector to contain key values\n    //temp.resize(m);\n    //temp = data;\n    //get new size of hashtable\n    int size = getPrime(m*2);\n    //clear the contents of the hashtable\n    data.clear();\n    //try to double the size of the hashtable\n    try\n    {\n        data.resize(size);\n    }\n    //catch any potential memory allocation error\n    catch (std::bad_alloc)\n    {\n        return false;\n    }\n    //set capacity to size and filled to 0\n    capacity = size;\n    filled = 0;\n    length = size;\n    //insert the key into the resized and empty hashtable\n    for(int i= 0; i < m; i++)\n    {\n        //only add in items that weren't deleted\n        if(not temp[i].isDeleted && temp[i].isOccupied)\n        {\n            insert(temp[i].key);\n            setPointer(temp[i].key, temp[i].pv);\n            filled += 1;\n            capacity -= 1;\n        }\n    }\n    //deallocate memory from the temporary vector\n    //std::vector<hashItem>().swap(temp);\n    return true;\n}\n\n//checks if key is in hash table\nbool hashTable::contains(const std::string &key)\n{\n    int index  = hash(key);\n    return (data[index]).isOccupied and not((data[index]).isDeleted);\n}\n\n\n//sets pointer of hashItem associated with the key\n//to input\nint hashTable::setPointer(const std::string &key, void *pv)\n{\n    if(not contains(key))\n    {\n        return 1;\n    }\n    data[hash(key)].pv = pv;\n    return 0;\n}\n\n//retrieves pointer in hashItem from hashtable\n//also writes to a boolean pointer whether or not key is in the table\n//returns nullptr if not in the table\nvoid* hashTable::getPointer(const std::string &key, bool *b)\n{\n    bool con = contains(key);\n    //bug\n    b = &con;\n    if(not con)\n    {\n        return nullptr;\n    }\n    return data[hash(key)].pv;\n}\n\n\n\n//removes an item from the hashtable\n //via lazy deletion\nbool hashTable::remove(const std::string &key)\n{\n    if(not contains(key))\n    {\n        return false;\n    }\n    data[hash(key)].isDeleted = true;\n    return true;\n}\n\n\n\n\n\n```\n\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Time complexity fro Dijkstra's algorithm\r\n                \r\nAs I read the time complexity for Dijkstra's algorithm on the unweighted graph using queue is O(n2) in the worst case. I assume this is because od bfs and dfs. BFS processes all the vertices during the marking phase and dfs is used for tracing back. They both have linear time complexity. But I'm not sure if this logic is correct. \n\nAlso for weighted graph, I know that the time complexity is O(EVlogV),where E is edges and V vertices. I think this is because of priority queue and I understand how priority queue works but still don't understand the O notation. \n    ", "Answer": "\r\nDijkstra's is not necessary for an unweighted graph. You can simply do a single BFS/DFS (Whichever you prefer, they're both O(E+V) anyway). \n\nBig-O notation denotes the \"Time complexity\" of an algorithm. In other words, as the parameters of the problem increase, how does the runtime of your algorithm increase? Let's look at a few examples:\n\n```\nint two_plus_n(int n){\n    return 2+n;\n}\n```\n\n\nThis algorithm is O(1), since no matter what N is, the algorithm will run in a constant amount of time.\n\n```\nint bad_2_times_n(int n){\n    int ans = 0;\n    for(int i=0;i<n;i++)\n        ans+=2\n    return ans;\n}\n```\n\n\nThis algorithm is O(n), since as you increase N, the number of steps increases at a linear rate with N. \nBig-O notation can get complicated with more complex algorithms. I suggest if you don't fully grasp the concept, you step back from an algorithm as complex as Dijkstra's and reinforce your understanding of runtime analysis.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Scaling a Dijkstra's Algorithm implementation\r\n                \r\nI have a Graph with each ```\nEdge```\n having some ```\nweight```\n.\n\nI have implemented dijkstra's Algorithm to find the shortest Path from ```\nVertex```\n A to B.\n\n```\nWeights```\n for the Graph are read from a Key/Value DB. [```\nredis.io```\n].\n\n\nEach ```\nWeights DB```\n is around 2 GBs.\nThere are 50 DBs for ```\nweights```\n. [Or 50 different files each  2 GB having weight values which I stored in the Redis.io].\nTo find the shortest Path, ```\nfunction FindPath(Start, End, DB_name)```\n is used.\n\n\nDijkstras reads the weight values from memory[Redio.io is an in-memory key value store]. But my RAM is only 6GBs. It is not possible to store 2GBs * 50 DBs into the memory at the same time.\n\nThe request for the Path can be Random and Concurrent. \n\nWhat is the best way to store the Weights DB?\n\nIs increasing the RAM only option to increase the speed of the program execution?\n\nEDIT\n\nNumber of Edges: 4,62,505\n    ", "Answer": "\r\nIf speed is concerned the main option is to increase ram. You cannot achieve similar perfomance with a nosql DB (eg. mongodb).  Another option would be to try to parallelize the algorithm on a multi core system.  But this is very tough as the final solution is global. \n\n[EDIT] \nThe fastest way to store the weights is a contiguous array of weights indexed by edge number. One array per DB. If all arrays cannot fit in your ram , you can design some basic caching mechanims ,  swaping DB from file to array (hoping not all db are accessed simultaneously).  \n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Cytoscape Dijkstra Algorithm off?\r\n                \r\nI'm trying to use Cytoscape to test Dijkstra's algorithm on various graphs. Using the graph below\n\n\n\nIt's easy to see that the shortest path from ```\nA```\n to ```\nC```\n would be ```\nA -> D -> E -> C```\n. \n\nWhen running Cytoscape's Djikstra's algorithm though\n\n```\nconst dijkstra = cy.elements().dijkstra('#A', function(){\n  const weight = this.data('weight');\n  return weight;\n}, false);\nconst pathToC = dijkstra.pathTo( cy.$('#C') );\nconst distToC = dijkstra.distanceTo( cy.$('#C') );\n```\n\n\nCytoscape gives the output\n\n```\nA -> B -> C\n```\n\n\nwhich is definitely wrong. \n\nAm I doing something wrong? Or is Cytoscape's algorithm off?\n\nPS Code to generate the graph in Cytoscape is\n\n```\n{\n  \"elements\": {\n    \"nodes\": [\n      {\n        \"data\": {\n          \"id\": \"A\"\n        },\n        \"position\": {\n          \"x\": 187,\n          \"y\": 135\n        },\n        \"group\": \"nodes\",\n        \"removed\": false,\n        \"selected\": false,\n        \"selectable\": true,\n        \"locked\": false,\n        \"grabbable\": true,\n        \"classes\": \"\"\n      },\n      {\n        \"data\": {\n          \"id\": \"B\"\n        },\n        \"position\": {\n          \"x\": 516,\n          \"y\": 128\n        },\n        \"group\": \"nodes\",\n        \"removed\": false,\n        \"selected\": false,\n        \"selectable\": true,\n        \"locked\": false,\n        \"grabbable\": true,\n        \"classes\": \"\"\n      },\n      {\n        \"data\": {\n          \"id\": \"C\"\n        },\n        \"position\": {\n          \"x\": 726,\n          \"y\": 302\n        },\n        \"group\": \"nodes\",\n        \"removed\": false,\n        \"selected\": false,\n        \"selectable\": true,\n        \"locked\": false,\n        \"grabbable\": true,\n        \"classes\": \"\"\n      },\n      {\n        \"data\": {\n          \"id\": \"D\"\n        },\n        \"position\": {\n          \"x\": 186,\n          \"y\": 447\n        },\n        \"group\": \"nodes\",\n        \"removed\": false,\n        \"selected\": false,\n        \"selectable\": true,\n        \"locked\": false,\n        \"grabbable\": true,\n        \"classes\": \"\"\n      },\n      {\n        \"data\": {\n          \"id\": \"E\"\n        },\n        \"position\": {\n          \"x\": 510,\n          \"y\": 445\n        },\n        \"group\": \"nodes\",\n        \"removed\": false,\n        \"selected\": false,\n        \"selectable\": true,\n        \"locked\": false,\n        \"grabbable\": true,\n        \"classes\": \"\"\n      }\n    ],\n    \"edges\": [\n      {\n        \"data\": {\n          \"id\": \"BA\",\n          \"source\": \"B\",\n          \"target\": \"A\",\n          \"weight\": \"100\"\n        },\n        \"position\": {\n          \"x\": 514,\n          \"y\": 127\n        },\n        \"group\": \"edges\",\n        \"removed\": false,\n        \"selected\": true,\n        \"selectable\": true,\n        \"locked\": false,\n        \"grabbable\": true,\n        \"classes\": \"\"\n      },\n      {\n        \"data\": {\n          \"id\": \"DA\",\n          \"source\": \"D\",\n          \"target\": \"A\",\n          \"weight\": \"1\"\n        },\n        \"position\": {\n          \"x\": 187,\n          \"y\": 446\n        },\n        \"group\": \"edges\",\n        \"removed\": false,\n        \"selected\": false,\n        \"selectable\": true,\n        \"locked\": false,\n        \"grabbable\": true,\n        \"classes\": \"\"\n      },\n      {\n        \"data\": {\n          \"id\": \"BD\",\n          \"source\": \"B\",\n          \"target\": \"D\",\n          \"weight\": \"100\"\n        },\n        \"position\": {\n          \"x\": 516,\n          \"y\": 127\n        },\n        \"group\": \"edges\",\n        \"removed\": false,\n        \"selected\": false,\n        \"selectable\": true,\n        \"locked\": false,\n        \"grabbable\": true,\n        \"classes\": \"\"\n      },\n      {\n        \"data\": {\n          \"id\": \"EB\",\n          \"source\": \"E\",\n          \"target\": \"B\",\n          \"weight\": \"100\"\n        },\n        \"position\": {\n          \"x\": 500,\n          \"y\": 442\n        },\n        \"group\": \"edges\",\n        \"removed\": false,\n        \"selected\": false,\n        \"selectable\": true,\n        \"locked\": false,\n        \"grabbable\": true,\n        \"classes\": \"\"\n      },\n      {\n        \"data\": {\n          \"id\": \"ED\",\n          \"source\": \"E\",\n          \"target\": \"D\",\n          \"weight\": \"1\"\n        },\n        \"position\": {\n          \"x\": 501,\n          \"y\": 443\n        },\n        \"group\": \"edges\",\n        \"removed\": false,\n        \"selected\": false,\n        \"selectable\": true,\n        \"locked\": false,\n        \"grabbable\": true,\n        \"classes\": \"\"\n      },\n      {\n        \"data\": {\n          \"id\": \"CE\",\n          \"source\": \"C\",\n          \"target\": \"E\",\n          \"weight\": \"5\"\n        },\n        \"position\": {\n          \"x\": 727,\n          \"y\": 304\n        },\n        \"group\": \"edges\",\n        \"removed\": false,\n        \"selected\": false,\n        \"selectable\": true,\n        \"locked\": false,\n        \"grabbable\": true,\n        \"classes\": \"\"\n      },\n      {\n        \"data\": {\n          \"id\": \"BC\",\n          \"source\": \"B\",\n          \"target\": \"C\",\n          \"weight\": \"5\"\n        },\n        \"position\": {\n          \"x\": 521,\n          \"y\": 132\n        },\n        \"group\": \"edges\",\n        \"removed\": false,\n        \"selected\": false,\n        \"selectable\": true,\n        \"locked\": false,\n        \"grabbable\": true,\n        \"classes\": \"\"\n      }\n    ]\n  },\n  \"style\": [\n    {\n      \"selector\": \"node\",\n      \"style\": {\n        \"background-color\": \"#666\",\n        \"label\": \"data(id)\"\n      }\n    },\n    {\n      \"selector\": \"edge\",\n      \"style\": {\n        \"width\": \"3px\",\n        \"label\": \"data(weight)\",\n        \"line-color\": \"#ccc\",\n        \"target-arrow-color\": \"#ccc\",\n        \"target-arrow-shape\": \"triangle\"\n      }\n    }\n  ],\n  \"zoomingEnabled\": true,\n  \"userZoomingEnabled\": true,\n  \"zoom\": 1,\n  \"minZoom\": 1.0e-50,\n  \"maxZoom\": 1.0e+50,\n  \"panningEnabled\": true,\n  \"userPanningEnabled\": true,\n  \"pan\": {\n    \"x\": 0,\n    \"y\": 0\n  },\n  \"boxSelectionEnabled\": true,\n  \"renderer\": {\n    \"name\": \"canvas\"\n  }\n}\n```\n\n    ", "Answer": "\r\nI'm having the same issue, pretty much same code.\n\nDone some debugging, looks like the dist object is concatenating strings rather than adding integers.\n\n```\ndist: Object\nAMS11: \"0474483\"  -> 0, 4, 74, 483 should really be 561\nBRU11: Infinity\nFRA11: Infinity\nGVA11: Infinity\nLON11: \"0474\"     -> 0, 4, 74 should really be 78\nLON21: 0\nLON22: \"04\"       -> 0, 4 should really be 4\nLON31: \"047415\"   -> 0, 4, 74, 15 should really be 93\nLUX21: Infinity\nLUX31: Infinity\nMOW11: Infinity\nMOW12: Infinity\nPAR11: \"049693\"\nPAR21: \"0474805\"\nSTO21: Infinity\nSTO31: Infinity\nTYO11: Infinity\nTYO12: Infinity\n```\n\n\nEdit: Answer is to change your weights to integers so use \"weight\": 1 instead of \"weight\": \"1\".\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Unsure with Dijkstra's algorithm\r\n                \r\nWith the help of so many people on this site, I have some brilliant code. Unfortunately, the Dijkstra Algorithm doesn't work. It is supposed to find the shortest distance between the AI and the player and move the AI closer to the player. I don't know how to get this to return a path and how to move the AI one step closer to the player or even if it works as I intended it to.\n\n```\ndef search(x, y):\n    if maze[x][y] == visblock():\n        return False\n    elif maze[x][y] == 3:\n        return False\n    elif maze[x][y] == player():\n        print(\"Found Player\")\n        return True\n\n    maze[x][y] = 3\n\n    if ((x < 5 - 1 and search(x+1, y))\n        or (y > 0 and search(x, y+1))\n        or (x > 0 and search(x-1, y))\n        or (y < 5-1 and search(x, y-1))):\n            return True\n\n    return False\n```\n\n    ", "Answer": "\r\nDijkstra's algorithm for shortest A to B path works, even if your code does not.   Wikipedia page has code that you should be able to translate.  \n\nSince you can compute a fairly accurate minimum distance from each point to the goal, you would probably do better with the A* improvement on Dijkstra.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Shortest Path Algorithms: Dynamic Programming vs Dijkstra's algorithm\r\n                \r\nRunning shortest path algorithm on a Directed Acyclic Graph (DAG) via dynamic programming which uses memoization has a runtime complexity of ```\nO(V + E)```\n which can be verified using the following equation:\n\n```\nd(s,v) = min{ d(s,u) + w(u,v) }, over all vertices u->v\n```\n\n\nNow, Dijkstra's algorithm also requires the graph to be directed. And the algorithm has a runtime complexity of ```\nO(E + V.log(V))```\n using min priority queues and this is clearly slower than the memoized version of DP.\n\nAccording to wiki:\n\n\n  This is asymptotically the fastest known single-source shortest-path algorithm for arbitrary directed graphs with unbounded non-negative weights.\n\n\nAm I missing something here? I am just not able to digest the contradiction here..\n    ", "Answer": "\r\nDijkstra's Algorithm is not restricted to DAGs; it can be run on any graphs with no negative path weights, cyclic or otherwise. Topological sorting, that you most likely are referring to, fails the \"arbitrary\" clause of your Wiki quote.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How to find multiple possible path using Dijkstra's algorithm in iOS/Swift\r\n                \r\nI am finding path between two nodes using Dijkstra's algorithm.\nI have successfully founded shortest path between two nodes but now i want all possible path between two node for some specific task.\nI am using Dijkstra's algorithm for now. How can I do this?\n    ", "Answer": "\r\nThis class will give you all possible routs between two nodes. Just Copy this class from here and at bottom i am providing how to use this algorithm.\n```\nclass Graph {\n\nprivate var v : Int\nprivate var adjList : [[Int]] = []\nprivate var allPossiblePath : [[Int]] = []\ninit(vertices : Int)\n{\n    v = vertices\n    initAdjList()\n}\nprivate func initAdjList()\n{\n    adjList = [[Int]](repeating: [0], count: v)\n    for i in 0..<v\n    {\n        adjList[i] = []\n    }\n}\n\npublic func addEdge(u : Int,v : Int)\n{\n    adjList[u].append(v)\n}\n\npublic func printAllPaths(s : Int,d : Int)\n{\n    var isVisited = [Bool](repeating: (0 != 0),count: v)\n    var pathList = [Int]()\n    pathList.append(s)\n    printAllPathsUtil(u: s, d: d, isVisited:&isVisited, localPathList:&pathList)\n}\n\nprivate func printAllPathsUtil(u: Int, d: Int, isVisited: inout [Bool], localPathList: inout [Int])\n{\n    if u == d\n    {\n        if (localPathList.count < 55)\n        {\n            allPossiblePath.append(localPathList)\n            //print(localPathList)\n        }\n        return\n    }\n    isVisited[u] = true\n    for i in adjList[u]\n    {\n        if !isVisited[i]\n        {\n            localPathList.append(i)\n            //print(i)\n            printAllPathsUtil(u: i, d: d, isVisited:&isVisited, localPathList:&localPathList)\n            localPathList.removeAll{$0 == i}\n        }\n    }\n    isVisited[u] = false\n}\npublic func getAllPossiblePath() -> [[Int]]\n{\n    return allPossiblePath\n}}\n```\n\nHere is code how to use it.\n```\n let g = Graph(vertices: data_Rout.count)\n    \n  for routData in data_Rout\n  {\n      g.addEdge(u: routData.route_source_id, v: routData.route_destination_id)\n  }\n g.printAllPaths(s: fetchSingleMyNodeFromList(station_code: \"\\(routsAndFilterDepartStation!.station_code)\")!.station_id,d: fetchSingleMyNodeFromList(station_code: \"\\(routsAndFilterDestinationStation!.station_code)\")!.station_id)\n let allPossiblePaths = g.getAllPossiblePath()\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "A spanning tree as a result of running Dijkstra's algorithm?\r\n                \r\nJust need to make sure about this:\nWhen I run Dijkstra's algorithm on a graph, at the end I will have a spanning tree right ? (Not necessarily Minimum spanning tree)\n\nSo the difference between Dijkstra and PRIM/Kruskal that the later two algorithms will return a minimum spanning tree?  \n\nThanks\n    ", "Answer": "\r\nYou are correct, with one condition - the graph should have a spanning tree from the source (i.e. - every vertex ```\nv```\n in the graph has a path from the given source).\nAlso, as commented by @Henry - you should continue the algorithm until you found path to all vertices, and do not 'stop' once a target is reached.\n\nAlso note that Dijkstra's algorithm (and in general - shortest path solver) is defined for directed graphs, and MST is usually for undirected graphs.\n(Note that it easy to define every undirected graph as a directed graph - by simply adding (u,v) and (v,u) for each edge {u,v} in the undirected graph)\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "A* / Dijkstra's algorithm simple implementation (Pascal)\r\n                \r\nI'm trying to implement A* path finding algorithm (now it's Dijkstra's algorithm i.e without heuristic) using this article Link. But I can't figure out what's wrong in my code (it finds incorrect path).\n\ninstead of the empty begin ... end; it should be this step:\n\nIf it is on the open list already, check to see if this path to that\nsquare is better, using G cost as the measure. A lower G cost means\nthat this is a better path. If so, change the parent of the square to\nthe current square, and recalculate the G and F scores of the square.\n\nbut I think it is not important because there is no diagonal movement.\n```\nuses\n    crt;\n\nconst\n    MAXX = 20;\n    MAXY = 25;\n\ntype\n    TArr = array [0..MAXY, 0..MAXX] of integer;\n    \n    TCell = record\n        x: integer;\n        y: integer;\n    end;\n    \n    TListCell = record\n        x: integer;\n        y: integer;\n        G: integer;\n        parent: TCell;\n    end;\n    \n    TListArr = array [1..10000] of TListCell;\n    \n    TList = record\n        arr: TListArr;\n        len: integer;\n    end;\n\nvar\n    i, j, minind, ind, c: integer;\n    start, finish: TCell;\n    current: TListCell;\n    field: TArr;\n    opened, closed: TList;\n\nprocedure ShowField;\nvar\n    i, j: integer;\nbegin\n    textcolor(15);\n    for i := 0 to MAXX do\n    begin\n        for j := 0 to MAXY do\n        begin\n            case field[j, i] of\n                99: textcolor(8);  // not walkable\n                71: textcolor(14); // walkable\n                11: textcolor(10); // start\n                21: textcolor(12); // finish\n                15: textcolor(2);  // path\n                14: textcolor(5);\n                16: textcolor(6);\n            end;\n            write(field[j, i], ' ');\n        end;\n        writeln;\n    end;\n    textcolor(15);\nend; \n\n\nprocedure AddClosed(a: TListCell);\nbegin\n    closed.arr[closed.len + 1] := a;\n    inc(closed.len);\nend;\n\n\nprocedure AddOpened(x, y, G: integer);\nbegin\n    opened.arr[opened.len + 1].x := x;\n    opened.arr[opened.len + 1].y := y;\n    opened.arr[opened.len + 1].G := G;\n    inc(opened.len);\nend;\n\nprocedure DelOpened(n: integer);\nvar\n    i: integer;\nbegin\n    AddClosed(opened.arr[n]);\n    for i := n to opened.len - 1 do\n        opened.arr[i] := opened.arr[i + 1];\n    dec(opened.len);\nend;\n\n\nprocedure SetParent(var a: TListCell; parx, pary: integer);\nbegin\n    a.parent.x := parx;\n    a.parent.y := pary;\nend;\n\n\nfunction GetMin(var a: TList): integer;\nvar\n    i, min, mini: integer;\nbegin\n    min := MaxInt;\n    mini := 0;\n    for i := 1 to a.len do\n        if a.arr[i].G < min then\n        begin\n            min := a.arr[i].G;\n            mini := i;\n        end;\n    \n    GetMin := mini;\nend;\n\n\nfunction FindCell(a: TList; x, y: integer): integer;\nvar\n    i: integer;\nbegin\n    FindCell := 0;\n    for i := 1 to a.len do\n        if (a.arr[i].x = x) and (a.arr[i].y = y) then\n        begin\n            FindCell := i;\n            break;\n        end;\nend;\n\n\nprocedure ProcessNeighbourCell(x, y: integer);\nbegin\n    if (field[current.x + x, current.y + y] <> 99) then    // if walkable\n        if (FindCell(closed, current.x + x, current.y + y) <= 0) then // and not visited before\n            if (FindCell(opened, current.x + x, current.y + y) <= 0) then // and not added to list already\n            begin\n                AddOpened(current.x + x, current.y + y, current.G + 10);\n                SetParent(opened.arr[opened.len], current.x, current.y);\n                //  field[opened.arr[opened.len].x, opened.arr[opened.len].y]:=16;\n            end\n                else\n            begin\n                \n            end;\nend;\n\n\nbegin\n    randomize;\n    for i := 0 to MAXX do\n        for j := 0 to MAXY do\n            field[j, i] := 99;\n    \n    for i := 1 to MAXX - 1 do\n        for j := 1 to MAXY - 1 do\n            if random(5) mod 5 = 0 then\n                field[j, i] := 99\n            else field[j, i] := 71;\n  \n    // start and finish positions coordinates\n    start.x := 5;\n    start.y := 3;\n    finish.x := 19;\n    finish.y := 16;\n    field[start.x, start.y] := 11;\n    field[finish.x, finish.y] := 21;\n    \n    ShowField;\n    \n    writeln;\n    \n    opened.len := 0;\n    closed.len := 0;\n    AddOpened(start.x, start.y, 0);\n    SetParent(opened.arr[opened.len], -1, -1);\n    current.x := start.x;\n    current.y := start.y;\n    \n    repeat\n        minind := GetMin(opened);\n        current.x := opened.arr[minind].x;\n        current.y := opened.arr[minind].y;\n        current.G := opened.arr[minind].G; \n        DelOpened(minind); \n        \n        ProcessNeighbourCell(1, 0);  // look at the cell to the right\n        ProcessNeighbourCell(-1, 0); // look at the cell to the left\n        ProcessNeighbourCell(0, 1);  // look at the cell above\n        ProcessNeighbourCell(0, -1); // look at the cell below\n      \n        if (FindCell(opened, finish.x, finish.y) > 0) then\n            break;\n    until opened.len = 0;\n    \n    // count and mark path\n    c := 0;\n    while ((current.x <> start.x) or (current.y <> start.y)) do\n    begin\n        field[current.x, current.y] := 15;\n        ind := FindCell(closed, current.x, current.y);\n        current.x := closed.arr[ind].parent.x;\n        current.y := closed.arr[ind].parent.y;\n        inc(c);\n    end;\n    \n    \n    ShowField;\n    writeln(c);\n    readln;\nend.\n```\n\nEdit Feb 1 '12: updated code, also fixed path marking (there should be or instead and), looks like it works now :)\n    ", "Answer": "\r\nYou should rewrite the program to use a loop instead of cut-and-paste to visit each neighbor. If you do that you will avoid bugs like the following:\n\n```\nif (field[current.x, current.y - 1] <> 99) then\n    if (FindCell(closed, current.x, current.y - 1) <= 0) then\n        if (FindCell(opened, current.x + 1, current.y) <= 0) then\n```\n\n\n(See the inconsistent ```\ncurrent.x + 1, current.y```\n in the last line.)\n\n\n\nWith respect to the loop, I was thinking of something like this (pseudo-Python):\n\n```\nneighbor_offsets = [(0, 1), (0, -1), (1, 0), (-1, 0)]\nfor offset in neighbor_offsets:\n    neighbor = current + offset\n    if is_walkable(neighbor) and not is_visited(neighbor):\n        # Open 'neighbor' with 'current' as parent:\n        open(neighbor, current)\n\n        # Perhaps check if the goal is reached:\n        if neighbor == finish:\n            goal_reached = True\n            break\n```\n\n\nIf you don't write a loop but just refactor to\n\n```\nProcessCell(x+1, y); \nProcessCell(x-1, y); \nProcessCell(x, y-1); \nProcessCell(x, y-1);\n```\n\n\nthen that's a great improvement too.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Getting actual path in Dijkstra's algorithm\r\n                \r\nI have a code that uses Dijkstra's algorithm to get the cost of the shortest path from one vertex to another. It reads a text file, which contains the number of vertices on the first line, and the the rest of the file is the cost adjacency matrix. I also need to get the actual path that is traveled between the vertices, but I couldn't figure that part out. My code is below. As you can see, I failed to create a proper predecessor data structure:\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nFILE *fp;\n\ntypedef enum { false, true } bool; //creating a \"bool\" data type\n\nvoid readFromFile(char *out){ //reading from file\n\n    fgets(out, 1000, fp);\n\n}\n\nvoid loadFile(){ //loading file\n    fp = fopen(\"graphmatrix.txt\",\"r\");\n    if(fp==NULL){\n        printf(\"graphmatrix.txt not found.\\n\");\n        exit(1);\n    }   \n} \n\nvoid convertToInt (char *arr, int *matrix) { //parsing lines from text file into int array\n    int num, i = 0, len;\n    while (sscanf(arr, \"%d%n\", &num, &len) == 1) {\n        matrix[i] = num;\n        arr += len;\n        i++;            \n    }\n}\n\nvoid dijkstra(int src, int vertices, int graph[vertices][vertices]) { //dijkstra's algo\n    int i;\n    int count;\n    int v;\n    int dist[vertices]; //will hold the shortest distances (so far) from source to vertex\n    int pred[vertices][vertices];\n    int predCount = 0;\n\n    bool sptSet[vertices]; //sptSet[i] will be true if vertex i is done processing (in class 1)\n\n    //initialize all distances as infinity (int_max) and stpSet[] as false (in class 2)\n    for (i = 0; i < vertices; i++){\n        dist[i] = INT_MAX;\n        sptSet[i] = false;\n        pred[i][i] = INT_MAX;\n    }\n\n    dist[src] = 0; //distance from source to itself is 0\n\n    for (count = 0; count < vertices - 1; count++) { //gets shortest distances\n        printf(\"**COUNT = %d**\\n\", count + 1);\n        int u = minDistance(dist, sptSet, vertices);\n        printf(\"u = %d\\n\", u);\n        sptSet[u] = true; //marks current vertex as done\n\n        for (v = 0; v < vertices; v++) { //updates distances\n            printf(\"in count %d, v = %d\\n\", count, v);\n            if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX && dist[u] + graph[u][v] < dist[v]){\n                dist[v] = dist[u] + graph[u][v];\n                printf(\"dist[%d] = %d\\n\", v, dist[v]);\n                pred[count][predCount] = u;\n                predCount++;\n                }\n        }\n    }\n\n    printSolution(dist, vertices, src, pred[src]);\n\n}\n\nint minDistance(int dist[], bool sptSet[], int vertices) { //checks if new distance is smaller than current distance\n    int min = INT_MAX, min_index;\n    int v;\n\n    printf(\"\\n---minDistance function---\\n\\n\");\n\n    for (v = 0; v < vertices; v++){\n        printf(\"v = %d\\n\", v);\n        if (sptSet[v] == false && dist[v] <= min){\n            min = dist[v], min_index = v;\n            printf(\"min: %d\\n\", min);\n            printf(\"min_index: %d\\n\", min_index);\n            }\n    }\n    printf(\"\\n---exit minDistance---\\n\\n\");\n    return min_index;\n}\n\nint printSolution(int dist[], int vertices, int src, int pred[]) { //prints distance and path to screen\n    int i, j;\n    for (i = 0; i < vertices; i++){\n        printf(\"vertex %d to vertex %d: %d\\n\", src + 1, i + 1, dist[i]);    \n        printf(\"path: \");\n        for (j = 0; j < vertices; j++){\n            printf(\"%d -> \", pred[j]);\n        }\n    }\n}\n\nint main(){\n\n    int i, j;\n    int vertices;\n    char tempvertices[10];\n    char temp;\n\n    loadFile();\n    readFromFile(tempvertices);\n\n    vertices = tempvertices[0] - '0';\n\n    char matrixLines[vertices][100];\n    int matrix[vertices][vertices];\n\n    for (i = 0; i < vertices; i++){\n        readFromFile(matrixLines[i]);\n        convertToInt(matrixLines[i], matrix[i]); \n    }\n\n    for (j = 0; j < vertices; j++){\n        printf(\"\\n-----------------DIJKSTRA number %d-------------------\\n\\n\", j + 1);\n        dijkstra(j, vertices, matrix);\n    }\n\n    return 0;\n}\n```\n\n\nSample text file (named graphmatrix.txt):\n\n```\n3\n0 3 1\n1 0 4\n1 2 0\n```\n\n\nHelp with getting the path, please?\n    ", "Answer": "\r\nIf I'm not mistaken, it seems that you would like to update ```\npred[v] = u```\n where ```\npred```\n is just one-dimensional. In the resulting tree of shortest paths, each vertex would have exactly one predecessor, namely the one which gets selected in the corresponding minimum operation. It would be easier to set ```\npred```\n in ```\nminDistance```\n, I guess.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Prims algorithm to Dijkstra algorithm\r\n                \r\nI am trying to make my existing implementation of Prim's algorithm to keep track distances from source . Since prim's and Dijkstra's algorithm are almost same. I can't figure out where am I missing something. \n\nI know what the problem is but cannot figure it out.\n\nHere is my code, how do I modify it to print the shortest distance from source to all other vertex. Shortest distance is stored in array  named : dist[]\n\nCode:\n\n```\npackage Graphs;\n\nimport java.util.ArrayList;\n\npublic class Prims {\n\n    static int no_of_vertices = 0;\n\n    public static void main(String[] args) {\n        int[][] graph = {{0, 2, 0, 6, 0},\n                {2, 0, 3, 8, 5},\n                {0, 3, 0, 0, 7},\n                {6, 8, 0, 0, 9},\n                {0, 5, 7, 9, 0},\n               };\n        no_of_vertices = graph.length;\n        int [][] result =  new int [no_of_vertices][no_of_vertices];\n        boolean[] visited = new boolean[no_of_vertices];\n        int dist[] = new int[no_of_vertices];\n        for (int i = 0; i < no_of_vertices; i++)\n            for (int j = 0; j < no_of_vertices; j++) {\n                result[i][j]= 0;\n                if (graph[i][j] == 0) {\n                    graph[i][j] = Integer.MAX_VALUE;\n                }\n            }\n\n        for (int i = 0; i < no_of_vertices; i++) {\n            visited[i] = false;\n            dist[i] = 0;\n\n        }\n        ArrayList<String> arr = new ArrayList<String>();\n        int min;\n        visited[0] = true;\n        int counter = 0;\n        while (counter < no_of_vertices - 1) {\n            min = 999;\n            for (int i = 0; i < no_of_vertices; i++) {\n                if (visited[i] == true) {\n                    for (int j = 0; j < no_of_vertices; j++) {\n                        if (!visited[j] && min > graph[i][j]) {\n                            min = graph[i][j];\n                            dist[i] += min; //  <------ Problem here\n                            visited[j] = true;\n                            arr.add(\"Src :\" + i + \" Destination : \" + j\n                                    + \" Weight : \" + min);\n                        }\n                    }\n                }\n            }\n            counter++;\n        }\n\n\n        for (int i = 0; i < no_of_vertices; i++) {\n            System.out.println(\"Source :  0\" + \" Destination : \" + i\n                    + \" distance : \" + dist[i]);\n        }\n\n        for (String str : arr) {\n            System.out.println(str);\n        }\n    }\n}\n```\n\n\nThere is a mistake in calculation of distance array as it forgets to add the distance of any intermediate nodes from source to destination.\n    ", "Answer": "\r\n```\nfor (int j = 0; j < no_of_vertices; j++) {\n    if (!visited[j] && min > graph[i][j]) {\n        min = graph[i][j];\n        dist[i] += min; //  <------ Problem here\n```\n\n\nOf course intermediate edges don't get added, because you only add the current edge. You probably want something like:\n\n```\nif (dist[i] + graph[i][j] < dist[j])\n    dist[j] = dist[i] + graph[i][j];\n```\n\n\nAnd get rid of the ```\nmin```\n variable.\n\nAlthough your algorithm does not look correct to me. You're supposed to pick the node with minimum ```\nd[]```\n at each step, and update that node's neighbors as I wrote above, then mark it as picked and never pick it again.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Python Using Dijkstra’s Algorithm To Find Possible Paths\r\n                \r\nI have some X and Y points that are output by another program and I am wondering if there is a way to use Dijkstra's algorithm to plan the most probable path for connecting all of the points?\n\nFor Example\n\n```\n                           ----4------5\n                           |\n8------7-----6----[0]------1-------2-----3\n       |\n    9---\n```\n\n\nThe ```\n[0]```\n in the example will be the starting point and the numbers will be the points from the imported file. Let's say those points are..\n\n```\npoint    X    Y\n  1      2    0\n  2      4    0\n  3      6    0\n  0      0    0\n  4      2.5  2.5\n  5      4.5  2.5\n  6      -2   0\n  7      -4   0\n  8      -6   0\n  9      -4.5 -2.5 \n```\n\n\nAfter those points are sent into the Dijkstra's algorithm I would like the output path to be something like...\n\n```\noutput= {\n            '0': ['1', '6'],\n            '1': ['2', '4'],\n            '2': ['3'],\n            '4': ['5'],\n            '6': ['7'],\n            '7': ['8','9']\n            }\n```\n\n\nIf you noticed the point ```\n0```\n might not be at the very beginning of the data but could be somewhere in the middle. Also, the output includes all of the points, none of them are left out. \n\nThe code that I have kinda working seems to leave points out when the numbers get big, which is why I would like to use Dijkstra's instead. Any help is greatly appreciated.\n\nSome what working code\n\n```\nimport math, collections\ndata = {0.0: [0.0, 0.0], 1.0: [1.0, 0.0], 2.0: [2.0, 0.0], 3.0: [3.0, 0.0], 4.0: [1.5, 0.5], 5.0: [2.5, 0.5], 6.0: [-1.0, 0.0], 7.0: [-2.0, 0.0], 8.0: [-3.0, 0.0], 9.0: [-2.5, -0.5]}\ndef group(d, start, seen = []):\n   x, y = d[start]\n   r = [a for a, [j, k] in d.items() if a != start and a not in seen and math.hypot(abs(x-j), abs(y-k)) <= 1]\n   if not r:\n     return {}\n   result = {start:r}\n   for i in r:\n     result.update(group(d, i, seen+[start, *r]))\n   return result\n\nresult = group(data, 0) \n```\n\n\nI found an example of Dijkstra's algorithm Here\n\nDijkstra's Algorithm\n\n```\nimport sys\n\nclass Graph():\n\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for column in range(vertices)]\n                      for row in range(vertices)]\n\n    def printSolution(self, dist):\n        print(\"Vertex tDistance from Source\")\n        for node in range(self.V):\n            print(node, \"t\", dist[node])\n\n    # A utility function to find the vertex with\n    # minimum distance value, from the set of vertices\n    # not yet included in shortest path tree\n    def minDistance(self, dist, sptSet):\n\n        # Initilaize minimum distance for next node\n        min = sys.maxsize\n\n        # Search not nearest vertex not in the\n        # shortest path tree\n        for v in range(self.V):\n            if dist[v] < min and sptSet[v] == False:\n                min = dist[v]\n                min_index = v\n\n        return min_index\n\n    # Funtion that implements Dijkstra's single source\n    # shortest path algorithm for a graph represented\n    # using adjacency matrix representation\n    def dijkstra(self, src):\n\n        dist = [sys.maxsize] * self.V\n        dist[src] = 0\n        sptSet = [False] * self.V\n\n        for cout in range(self.V):\n\n            # Pick the minimum distance vertex from\n            # the set of vertices not yet processed.\n            # u is always equal to src in first iteration\n            u = self.minDistance(dist, sptSet)\n\n            # Put the minimum distance vertex in the\n            # shotest path tree\n            sptSet[u] = True\n\n            # Update dist value of the adjacent vertices\n            # of the picked vertex only if the current\n            # distance is greater than new distance and\n            # the vertex in not in the shotest path tree\n            for v in range(self.V):\n                if self.graph[u][v] > 0 and sptSet[v] == False and \\\n                dist[v] > dist[u] + self.graph[u][v]:\n                        dist[v] = dist[u] + self.graph[u][v]\n\n        self.printSolution(dist)\n\n# Driver program\ng = Graph(9)\ng.graph = [[0, 4, 0, 0, 0, 0, 0, 8, 0],\n           [4, 0, 8, 0, 0, 0, 0, 11, 0],\n           [0, 8, 0, 7, 0, 4, 0, 0, 2],\n           [0, 0, 7, 0, 9, 14, 0, 0, 0],\n           [0, 0, 0, 9, 0, 10, 0, 0, 0],\n           [0, 0, 4, 14, 10, 0, 2, 0, 0],\n           [0, 0, 0, 0, 0, 2, 0, 1, 6],\n           [8, 11, 0, 0, 0, 0, 1, 0, 7],\n           [0, 0, 2, 0, 0, 0, 6, 7, 0]\n          ];\n\ng.dijkstra(0);\n# This code is contributed by Divyanshu Mehta \n```\n\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm which executes relaxation m times\r\n                \r\nIn Dijkstra's Algorithm a relaxation is called at most m times (where m = #edges). I'm trying to figure out some concrete graph example, which relaxation is indeed executed m times. I understand that a relaxation happens every time when a cheaper path to a given node is found, but I can't really \"visualize\" such a case.\n    ", "Answer": "\r\nAs stated in the comments, a tree is an example. An example with cycles is a graph on n vertices (where n is odd) that has the following edges:\n\n(1, 2) of cost 1\n\n(2, 3) of cost 1\n\n(1, 3) of cost 10\n\n,\n\n(3, 4) of cost 1\n\n(4, 5) of cost 1\n\n(3, 5) of cost 10\n\n...\n\n(n - 2, n - 1) of cost 1\n\n(n - 1, n) of cost 1\n\n(n - 2, n) of cost 10\n\nDijkstra's algorithm from vertex 1 will always relax the expensive 1->3, 3->5, 5->7, 7->9, ... (n - 2)->n edges first, and then will find the longer but cheaper paths.\n\nThe given graph is a good example of why you need a priority queue at all in Dijkstra's algorithm. On random graphs, using a simple queue and just pushing vertices back after every edge relaxation tends to work very fast, but such an algorithm would run in exponential time on this case.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Finding Hamiltonian paths with Dijkstra's algorithm?\r\n                \r\nCan Dijkstra algorithm find all shortest path from a single source vertex to all other vertices such that the path visits all the vertices in an undirected and symmetric graph once and exactly once? Is there a faster algorithm for the symmetric graph?\n    ", "Answer": "\r\nWhat you are asking for is an algorithm to find the shortest Hamiltonian paths from a single node to each other node in the graph (a Hamiltonian path is one that passes through every node in the graph exactly once).  Unfortunately, the problem of even determining whether or not there is a Hamiltonian path between a pair of nodes in an undirected graph is NP-complete, and so there are no known polynomial-time algorithms that solve this problem (and they don't exist unless P = NP).  Since Dijkstra's algorithm runs in polynomial time, there is no known modification to this algorithm that will find Hamiltonian paths to each other node in the graph.\n\nHope this helps!\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "why kruskal's algorithm and dijkstra's algorithm are so similar to each other? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is off-topic. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it's on-topic for Stack Overflow.\r\n                \r\n                    \r\n                        Closed 10 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI know that these two algorithms are used to solve different problems, dijkstra's algorithm is used to find shortest path in a graph while kruskal's algorithm is used to find the MST of a graph.But they are so similar to each other? what's the relationship between them? and what's the relationship between these two authors? why they are so similar?\n    ", "Answer": "\r\nThey are different algorithms. In Kruskal you pick the shortest edge in the entire graph (and remove it from further consideration). In Dijkstra you pick the vertex with the shortest tentative distance (and remove it from further consideration).\n\nNaturally, the problems solved are quite different too. The shortest path between two vertices may not be part of the minimum spanning tree.\n\nAn example is a square with sides 1, removing any one edge will give you a minimum spanning tree but the shortest path in the original square graph between the vertices of the edge you removed is not part of the minimum spanning tree.\n\n\n\nFrom the comment:\n\nWell, Prim's is closer to Dijkstra than Kruskaln. For completeness, Prim's always picks the closest vertex to the tree so far. In contrast, Dijkstra may not pick the closest vertex to the set of finalized vertices. For example, a hexagon with clockwise edge lengths 1, 2, 3, 1, 2, 4. Prim's could grow clockwise the whole time. Dijkstra would grow both ways.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm Concepts and Coding Problems\r\n                \r\nQuestion Updated\nI am currently working on implementing Dijkstra's Algorithm in Python, I have looked at other questions here regarding the algorithm and none seem to fit what I am looking for.\nCurrently my program reads two text files, one containing a network routing diagram network.txt (basically the route costs).\n```\n0,2,4,1,6,0,0\n2,0,0,0,5,0,0\n4,0,0,0,0,5,0\n1,0,0,0,1,1,0\n6,5,0,1,0,5,5\n0,0,5,1,5,0,0\n0,0,0,0,5,0,0\n```\n\nand one containing the desired route (route.txt)\n```\nB>F\n```\n\nThe Network Routing Table:\n(Each Line Is a Node and Its Links so node A is linked to B, C, D and E)\n```\n      A  B  C  D  E  F  G\n\nA    [0, 2, 4, 1, 6, 0, 0]\nB    [2, 0, 0, 0, 5, 0, 0]\nC    [4, 0, 0, 0, 0, 5, 0]\nD    [1, 0, 0, 0, 1, 1, 0]\nE    [6, 5, 0, 1, 0, 5, 5]\nF    [0, 0, 5, 1, 5, 0, 0]\nG    [0, 0, 0, 0, 5, 0, 0]\n```\n\nNodes On The Network:\n([Structure] PreviousNode, DistanceFromSource, Visited)\n```\nA    [-1, 1000000000, False]\nB    [-1, 1000000000, False]\nC    [-1, 1000000000, False]\nD    [-1, 1000000000, False]\nE    [-1, 1000000000, False]\nF    [-1, 1000000000, False]\nG    [-1, 1000000000, False]\n```\n\nI kind of understand Dijkstra's Algorithm but using the two data structures I have, combined with having to write it in Python I don't have a clue where to go from here because I am unable to get my head round how to do this not knowing the language.\nI have some very basic \"pseudocode\" to what I need to do next\n\n\n3 - Examine all the unvisited neighbours of the current node and calculate\ntheir tentative distances from the starting node, overwriting the\nexisting distance if the new value is lower\n\n4 - Mark current node as visited (will not be examined again)\n\n5 - If not at destination and unvisited node exists go to the unvisited node with the smallest > distance from initial node and make it the current node, otherwise end\n\n6 - Go back to 3\n\n\n\nIs anyone able to assist me with translating that \"pseudocode\" into code or even more meaningful pseudocode would be great as I am struggling with this\n    ", "Answer": "\r\nUse native python \"links\" between the objects, e.g.:\n\n```\nedges = {1: set([2,3,4]), 2: set([1,5]), ....}\ncosts = {(1, 2): 99.3, (1, 3): 127.77, ...}\n```\n\n\nThere's no need to create your own classes for such simple problem.\n\nWatch this for inspiration:\n\nhttp://python.mirocommunity.org/video/1530/pycon-2010-mastering-team-play\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Modifying Dijkstra's algorithm for least changes\r\n                \r\nI'm using a version of Dijkstra's algorithm written in Python which I found online, and it works great. But because this is for bus routes, changing 10 times might be the shortest route, but probably not the quickest and definitely not the easiest. I need to modify it somehow to return the path with the least number of changes, regardless of distance to be honest (obviously if 2 paths have equal number of changes, choose the shortest one). My current code is as follows:\n\n```\nfrom priodict import priorityDictionary\n\ndef Dijkstra(stops,start,end=None):\n    D = {}  # dictionary of final distances\n    P = {}  # dictionary of predecessors\n    Q = priorityDictionary()   # est.dist. of non-final vert.\n    Q[start] = 0\n\n    for v in Q:\n        D[v] = Q[v]\n        print v\n        if v == end: break\n\n        for w in stops[v]:\n            vwLength = D[v] + stops[v][w]\n            if w in D:\n                if vwLength < D[w]:\n                    raise ValueError, \"Dijkstra: found better path to already-final vertex\"\n            elif w not in Q or vwLength < Q[w]:\n                Q[w] = vwLength\n                P[w] = v\n    return (D,P)\n\ndef shortestPath(stops,start,end):\n    D,P = Dijkstra(stops,start,end)\n    Path = []\n    while 1:\n        Path.append(end)\n        if end == start: break\n        end = P[end]\n    Path.reverse()\n    return Path\n\nstops = MASSIVE DICTIONARY WITH VALUES (7800 lines)\nprint shortestPath(stops,'Airport-2001','Comrie-106')\n```\n\n\nI must be honest - I aint no mathematician so I don't quite understand the algorithm fully, despite all my research on it.\n\nI have tried changing a few things but I don't get even close.\n\nAny help? Thanks!\n    ", "Answer": "\r\nHere is a possible solution:\n\n1)Run breadth first search from the start vertex. It will find the path with the least number of changes, but not the shortest among them. Let's assume that after running breadth first search dist[i] is the distance between the start and the i vertex.\n\n2)Now one can run Djikstra algorithm on modified graph(add only those edges from the initial graph which satisfy this condition: dist[from] + 1 == dist[to]). The shortest path in this graph is the one you are looking for.\n\nP.S If you don't want to use breadth first search, you can use Djikstra algorithm after making all edges' weights equal to 1.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm with priority queue\r\n                \r\nIn my implementation of Dijkstra's algorithm I have 1 array with all nodes and 1 priority queue with all nodes. Whenever a node is dequeued I update all adjacent nodes with new distance and where it came from, so I can backtrack the path. \n\nThe node in the priority queue is updated with new distance and the node in the array is updated where it came from and with new distance. When a node is dequeued the final distance in the array is updated:\n\n```\n  PathInfo current = pq.remove();\n  path[current.pos].distance = current.distance;\n```\n\n\nIs it acceptable to update both the array with info about previous node and the priority queue with distance?\n\nThis happens whenever a better distance is found:\n\n```\n      PathInfo key(i, newDistance);\n      path[i].distance = newDistance;\n      path[i].previous = current.pos;\n      pq.decreaseKey(key);\n```\n\n\nIt seems a bit redundant to update my array and priority queue with basically the same info.\n\nI'm currently using a regular array as a data structure in the PQ. Updating the priority is done in linear time and dequeueing is also done in linear time. \n\nWhat data structure should I use in the priority queue and how should I change a nodes priority?\n\nI'm using C++\n    ", "Answer": "\r\nYou have two kinds of distances here:  your priority queue has \"tentative distances\" which are subject to update, while your array has \"final distances\", which are not (because Dijkstra's algorithm doesn't need to update nodes that have been removed from the priority queue).\n\nIt appears that you are unnecessarily updating the distances in your array.  Perhaps it would also be a good idea to change the field name in your array node to document this:  from ```\narrayNode.distance```\n to ```\narrayNode.finalDistance```\n.\n\nIn other words:  it appears you are using your array nodes to output the results from your Dijkstra's algorithm -- so you should only set the distance in each array node once, when it is removed from the priority queue.\n\n\n\nIf your priority-queue implementation doesn't provide the ability to query the current distance associated with a given key, please check the behavior of its ```\ndecreaseKey()```\n operation.  If the ```\ndecreaseKey()```\n operation rejects updates for which the new priority does not actually decrease, then you shouldn't need to perform that check yourself -- you can just call it for each neighbor of the current node.\n\nHowever, if the ```\ndecreaseKey()```\n function does not handle that case correctly, and there is no auxiliary query function that would let you perform that check manually, and there is no opportunity to fix either deficiency, then you'll need to maintain redundant information for that purpose....\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm- why every time extract the vertex with smallest priority?\r\n                \r\nI am learning Dijkstra's algorithm to find shortest path. And I noticed that there is a priority queue to help extract the vertex with lowest priority in the vertex set. Will the algorithm still work if I pick a vertex regardless of priority, instead of the one with lowest priority, from the vertex set? If yes, what about the time complexity?\n\nThe original Dijkstra's algorithm from Wikipedia is like:\n\n```\nfunction Dijkstra(Graph, source):\n    dist[source] ← 0                                \n\n    create vertex set Q\n\n    for each vertex v in Graph:           \n        if v ≠ source\n            dist[v] ← INFINITY                      \n            prev[v] ← UNDEFINED                     \n\n    Q.add_with_priority(v, dist[v])\n\n\n    while Q is not empty:                          \n        u ← Q.extract_min()                        \n        for each neighbor v of u:                  \n            alt ← dist[u] + length(u, v) \n            if alt < dist[v]\n                dist[v] ← alt\n                prev[v] ← u\n                Q.decrease_priority(v, alt)\n\n    return dist[], prev[]\n```\n\n\nAfter making modifications to pick a vertex regardless of priority(please note that there is an \"add\" after relaxation):\n\n```\nfunction DijkstraVariant(Graph, source):\n    dist[source] ← 0                                \n\n    create vertex set Q\n\n    for each vertex v in Graph:           \n        if v ≠ source\n            dist[v] ← INFINITY                      \n            prev[v] ← UNDEFINED                     \n\n    Q.just_add(v)                  // Don't care about the priority\n\n\n    while Q is not empty:                          \n        u ← Q.random_pick()         // Don't care about the priority        \n        for each neighbor v of u:                 \n            alt ← dist[u] + length(u, v) \n            if alt < dist[v]\n                dist[v] ← alt\n                prev[v] ← u\n                Q.just_add(v)  // Don't care about the priority\n\n    return dist[], prev[]\n```\n\n    ", "Answer": "\r\nNo, it will not work. It will yield a path, but it is no longer guaranteed to be the shortest.\n\nThe priority is required to account for non uniform weights, with a plain FIFO queue it will only work if all edge weights are equal. It becomes a plain broad first search.\n\nWith a random selection, instead of priority, the algorithm detoriates further, down to the level of a depth first search. That also removes all the guarantees the BFS provided, such as finding any existing path even in infinite graphs in finite time.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Does Dijkstra's algorithm always return the \"shortest\" (least number of edges) path?\r\n                \r\nThere are two functions that I wish to minimize:\na. the number of \"obstacles\" on the path (assume each obstacle increases the cost); and \nb. total number of edges between the source and the destination.\nIf I had to minimize just (a), I would have used Dijkstra's algorithm; if I had to minimize just (b), I would have used BFS.\nBut given that I have to minimize both, can I use Dijkstra's algorithm only?  In other words, if I find the path with the least cost from the obstacles, does Dijkstra's algorithm also guarantee that the path length thus obtained (between source and destination) would be the shortest?\n    ", "Answer": "\r\nWhen discussing paths on weighted graphs, the term \"shortest path\" means the path with the lowest total cost.  Think of the weights as distances.  This is the path that Dijkstra's algorithm will find.\nYou can use any cost function you like, as long as the cost to get from one vertex to another is always positive or zero.  As mentioned in comments, however, you can only minimize one function at a time.  This is a general fact that has nothing to do with Dijkstra's algorithm.\nThe cost function that you seem to suggesting is perfectly fine -- the cost to move to a normal vertex is 1, while the cost to move to an \"obstacle\" vertex is higher.  Dijkstra's algorithm is the appropriate way to find a path with lowest total cost.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Bidirectional Implementation of Dijkstra's Algorithm in C++\r\n                \r\nI recently just started to learn c++ and for my next homework assignment I have to implement a bidirectional version of dijkstra's algorithm. I'm supposed to build on my last assignment which makes a graph using vectors. I'm wondering what the best way to setup this assignment using my code. Here is the actual assignment:\n\n\n\nMachine Problem 3: Bidirectional shortest path algorithm : Ira Pohl Jan 24, 2014\n\nObjective : Improve your Graph Class and add Dijkstra and Bidirectional algorithm\n\nGraph algorithms and graph representation is a critical tool in CS. The basic problem will be to write Dijkstra’s algorithm as a class member function (method in OO speak). You should already know Dijkstra’s algorithm for the shortest path problem from prior experience, but it will be reviewed in class. It is the basis for many route calculations and optimizations programs.\n\nThere are 2 basic implementations used for graphs – one is edge lists, and the other is connectivity matrices. You can decide which to use, but comment on your choice.\n\nBasic problem: Write a set of constructors for declaring and initializing a graph or use your previous implementation of graph. An edge will have a positive cost that is its distance. Have a procedure that can for a graph of at least size 1000 produce a randomly generated set of edges with positive distances. Assume the graphs are undirected. The random graph procedure should have edge density as a parameter and distance range as a parameter. So a graph whose density is 0.1 would have 10% of its edges picked at random and its edge distance would be selected at random from the distance range. This of course was already developed in problem 2.\n\nThe Dijkstra bi-directional algorithm should re-use code from the Dijkstra unidirectional algorithm.\n\n\n\n```\n#include <iostream>\n#include <ctime>\n#include <cstdlib>\n#include <vector>\n#include <cmath>\n\ndouble probability(){ return 1.0*rand()/RAND_MAX;}\n\n\nusing namespace std;\n//class that has make_graph as constructor\nclass Graph{\n   public:\n      Graph(int s, double density);\n      void print_graph();\n   private:\n      int size;\n      vector<vector<bool> > g1; //A vector of vectors of bools\n      //Think of a vector as a first in, last out Data Structure\n};\n\n\n//make_graph altered to work in c++\nGraph::Graph(int s, double density){\n   this->size = s;\n   for (int i = 0; i < s; ++i){\n        // We push a new vector of bool onto the initial vector s times\n        // The * is there to dereference the new vector that we insert\n        this->g1.push_back( *( new vector<bool>() ) );\n        for (int j = 0; j < s; ++j){\n            //then, on each of those vectors, we push a default \"false\" s times\n            this->g1.at(i).push_back(false);\n        }\n   }\n   //Don't have to change this part much\n   for (int i = 0; i < s; ++i){\n      for (int j = 0; j < s; ++j){\n        if (probability()< density) this->g1[i][j] = true;\n      }\n   }\n}\n\n//simple conversion, just needed 'this'\nvoid Graph::print_graph(){\ncout << \"graph size \" << this->size << \"\\n\";\n   for(int i = 0; i < this->size; ++i){\n      for (int j = 0; j < this->size; ++j){\n         cout << this->g1[i][j] << \"\\t\";\n      }\n      cout << \"\\n\";\n   }\n}\n\nint main(){\n    srand(time(0));\n    cout << \"Test simple graph generation\\n\";\n    Graph* test1 = new Graph(10, 0.7);\n    test1->print_graph();\n    cout << \"\\nEND of TEST 1\\n\\n\";\n    Graph* test2 = new Graph(8, 0.5);\n    test2->print_graph();\n    cout << \"\\nEND of TEST 2\\n\\n\";\n    return 0;\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Coding Dijkstra's algorithm without modifying original Node\r\n                \r\nI have a working version of Dijkstra's algorithm in my language of choice - in this case Swift.\n\nAs you may know, the algorithm requires that you place temporary labels on nodes - but is it possible to implement WITHOUT changing the original class. For reference here is a cut down node class, but this question is not language dependent as I would just like to know how this can be implemented without changing the original class.\n\n```\nclass Node: Hashable {\n    var nodes = [Int:[Int]]()\n    var children = [Node]()\n}\n```\n\n    ", "Answer": "\r\nOne semi-hacky solution would be to use associated objects:\n\n```\nfileprivate var labelKey: UInt8 = 0\nextension Node {\n    var label: Int {\n        get {\n            return objc_getAssociatedObject(self, &labelKey) as? Int ?? 0\n        }\n        set {\n            objc_setAssociatedObject(self, &labelKey, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)\n        }\n    }\n}\n```\n\n\nThis way you don't alter the original class.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Difference between Prim's and Dijkstra's algorithms?\r\n                \r\nWhat  is the exact difference between Dijkstra's and Prim's algorithms? I know Prim's will give a MST but the tree generated by Dijkstra will also be a MST. Then what is the exact difference?\n    ", "Answer": "\r\nPrim's algorithm constructs a minimum spanning tree for the graph, which is a tree that connects all nodes in the graph and has the least total cost among all trees that connect all the nodes.  However, the length of a path between any two nodes in the MST might not be the shortest path between those two nodes in the original graph.  MSTs are useful, for example, if you wanted to physically wire up the nodes in the graph to provide electricity to them at the least total cost.  It doesn't matter that the path length between two nodes might not be optimal, since all you care about is the fact that they're connected.\nDijkstra's algorithm constructs a shortest path tree starting from some source node.  A shortest path tree is a tree that connects all nodes in the graph back to the source node and has the property that the length of any path from the source node to any other node in the graph is minimized.  This is useful, for example, if you wanted to build a road network that made it as efficient as possible for everyone to get to some major important landmark.  However, the shortest path tree is not guaranteed to be a minimum spanning tree, and the sum of the costs on the edges of a shortest-path tree can be much larger than the cost of an MST.\nAnother important difference concerns what types of graphs the algorithms work on.  Prim's algorithm works on undirected graphs only, since the concept of an MST assumes that graphs are inherently undirected.  (There is something called a \"minimum spanning arborescence\" for directed graphs, but algorithms to find them are much more complicated).  Dijkstra's algorithm will work fine on directed graphs, since shortest path trees can indeed be directed.  Additionally, Dijkstra's algorithm does not necessarily yield the correct solution in graphs containing negative edge weights, while Prim's algorithm can handle this.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm in String-type Graph\r\n                \r\nI am making an inter-city route planning program where the graph that is formed has string-type nodes (e.g. LHR, ISB, DXB). It's undirected but weighted, and is initialized as:\n```\nmap<pair<string, string>, int> city;\n```\n\nand then I can add edges by for example:\n```\nGraph g;\ng.addEdge(\"DXB\", \"LHR\", 305);\ng.addEdge(\"HTR\", \"LHR\", 267);\ng.addEdge(\"HTR\", \"ISB\", 543);\n```\n\nand the resultant output will be:\n```\n        ISB     LHR\nDXB     0       305\nHTR     543     267\n```\n\nNow, the question... I'm trying to implement Dijkstra's algorithm in this graph but so far have been unable to correctly run it on string-type nodes and opposed to learning and doing it on int-type nodes. Can someone guide me through the correct steps of implementing it in the most efficient way possible?\n    ", "Answer": "\r\nThe data structure used by a graph application has a big impact on the efficiency and ease of coding.\nMany designs start off with the nodes.  I guess the nodes, in the problems that are being modelled, often have a physical reality while the links can be abstract relationships.  So it is more natural to start writing a node class, and add on the links later.\nHowever, when coding algorithms that solve problems in graph theory, it becomes clear that the links are the real focus.  So, lets start with a link class.\n```\nclass cLink\n{\npublic:\n    cLink(int c = 1)\n        : myCost(c)\n    {\n    }\n    int myCost;         // a constraint e.g. distance of a road, max xapacity of a pipe\n    int myValue;        // a calculated value, e.g. actual flow through a pipe\n};\n```\n\nIf we store the out edges of node in a map keyed by the destination node index, then the map will be an attribute of the source node.\n```\nclass cNode\n{\npublic:\n    cNode(const std::string &name = \"???\")\n        : myName(name)\n    {\n    }\n    std::string myName;\n    std::map<int, cLink> myLink;    // out edges of node, keyed by destination\n};\n```\n\nWe have links and nodes, so we are ready to construct a class to store the graph\n```\nclass cGraph {\npublic:\nstd::map<int, cNode> myG; // the graph, keyed by internal node index\n};\n```\n\n Where did the node index come from?  Humans are terrible at counting, so better the computer generates the index when the node is added.\n```\ncGraph::createNode( const std::string& name )\n{\n    int n = myG.size();\n    myG.insert(std::make_pair(n, cNode(name)));\n}\n```\n\nDon't implement this! It has a snag - it can create two nodes with the same name.  We need to be able to check if node with a specified name exists.\n```\nint cGraph::find(const std::string &name)\n{\n    for (auto n : myG)\n    {\n        if (n.second.myName == name)\n        {\n            return n.first;\n        }\n    }\n    return -1;\n}\n```\n\nThis is inefficient.  However, it only needs to be done once when the node is added.  Then the algorithms that search through the graph can use fast lookup of nodes by index number.\nNow we can prevent two nodes being created with the same name\n```\n    int cGraph::findoradd(const std::string &name)\n    {\n        // search among the existing nodes\n        int n = find(name);\n        if (n < 0)\n        {\n            // node does not exist, create a new one\n            // with a new index and add it to the graph\n            n = myG.size();\n            myG.insert(std::make_pair(n, cNode(name)));\n        }\n        return n;\n    }\n```\n\nHumans, in addition to being terrible counters, are also over confident in their counting prowess.  When they specify a graph like this\n```\n1 -> 2\n1 -> 3\n```\n\nLet’s not be taken in.  Let’s regard these numbers as names and continue to use our own node index system.\n```\n/** Add costed link between two nodes\n *\n * If the nodes do not exist, they will be added.\n *\n */\n\n            void addLink(\n                const std::string & srcname,\n                const std::string & dstname,\n                double cost = 1)\n            {\n                int u = findoradd(srcname);\n                int v = findoradd(dstname);\n                myG.find(u)->second.myLink.insert(\n                           std::make_pair(v, cLink(cost)));\n                if (!myfDirected)\n                    myG.find(v)->second.myLink.insert(\n                           std::make_pair(u, cLink(cost)));\n            }\n```\n\nWith the addition of a few getters and setters, we are ready to start implementing graph algorithms!\nTo see an complete implementation, including Dijsktra, using these ideas, check out PathFinder.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm - priority queue issue\r\n                \r\nI have a Graph class with a bunch of nodes, edges, etc. and I'm trying to perform Dijkstra's algorithm. I start off adding all the nodes to a priority queue. Each node has a boolean flag for whether it is already 'known' or not, a reference to the node that comes before it, and an int dist field that stores its length from the source node. After adding all the nodes to the PQ and then flagging the source node appropriately, I've noticed that the wrong node is pulled off the PQ first. It should be that the node with the smallest dist field comes off first (since they are all initialized to a a very high number except for the source, the first node off the PQ should be the source... except it isn't for some reason).\nBelow is my code for the algorithm followed by my compare method within my Node class.\n\n```\n    public void dijkstra() throws IOException {\n    buildGraph_u();\n    PriorityQueue<Node> pq = new PriorityQueue<>(200, new Node());\n\n    for (int y = 0; y < input.size(); y++) {\n        Node v = input.get(array.get(y));\n        v.dist = 99999;\n        v.known = false;\n        v.prnode = null;\n        pq.add(v);\n    }\n\n    source.dist = 0;\n    source.known = true;\n    source.prnode = null;\n    int c=1;\n    while(c != input.size()) {\n        Node v = pq.remove();\n        //System.out.println(v.name);\n                    //^ Prints a node that isn't the source\n        v.known = true;\n        c++;\n        List<Edge> listOfEdges = getAdjacent(v);\n        for (int x = 0; x < listOfEdges.size(); x++) {\n            Edge edge = listOfEdges.get(x);\n            Node w = edge.to;\n            if (!w.known) {\n                int cvw = edge.weight;\n                if (v.dist + cvw < w.dist) {\n                    w.dist = v.dist + cvw;\n                    w.prnode = v;\n                }\n            }\n        }\n    }\n}\n```\n\n\n\n\n```\npublic int compare (Node d1, Node d2) {\n       int dist1 = d1.dist;\n       int dist2 = d2.dist;\n       if (dist1 > dist2) \n         return 1;\n       else if (dist1 < dist2) \n         return -1;\n       else \n         return 0;\n     }\n```\n\n\nCan anyone help me find the issue with my PQ?\n    ", "Answer": "\r\nThe priority queue uses assumption that order doesn't change after you will insert the element.\n\nSo instead of inserting all of the elements to priority queue you can:\n\n\nStart with just one node.\nLoop while priority queue is not empty.\nDo nothing, if element is \"known\".\nWhenever you find smaller distance add it to priority queue with \"right\" weight.\nSo you need to store a sth else in priority queue, a pair: distance at insertion time, node itself.\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Nodes in Dijkstra's algorithm are not being saved\r\n                \r\nI am having a problem with Dijkstra's algorithm in that I can access the next node in a list I created but I cannot save information to that \"next node\". The structure I am using is a vector that has nodes saved at each index. I am using the addresses of the vector indexes to gain access of the nodes at that index. \n\nI made the vector with nodes from this example: Linked list with multiple parent and child nodes\n\n```\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#define INFINITY 999\n\nusing namespace std;\n\nstruct node\n{\n\nint id;\nint edge_weight;\nint distance_to_source;\n//used for reverse iteration to find the path\nint previous;\n\n//pointing to children of parent node and the addresses are stored\n//in an array\nstruct node* next_node_list[3];\nstruct node* previous_node[3];\n\n};\n\n\n\nint Dijkstra(vector<node> sub,int source, int target)\n{\n//intializing for main while loops\nint best_path_weight =0;\nint end_of_loops= (sub.size());\nint child = 0;\n\n//intializing intial distances to INF to show that \nfor(int i=0; i < end_of_loops; i++)\n{\n\nsub[i].distance_to_source = INFINITY;\n\n}\n//source is set to be 0\nsub[source].distance_to_source=0;\n//copy of sub for later access \nvector<node> copy = sub;\n\nwhile(!sub.empty())\n{\n    cout << sub.size() << endl;\n\n    if(sub[0].distance_to_source == INFINITY)\n    {\n    cout << \"new node distance2source is INF\" << endl;\n    break;\n\n    }\n    for(int j = 0; (j < 1); j++)\n    {\n\n        if((sub[source].next_node_list[j] == NULL))\n        {\n        cout << \"null child \" <<endl;\n        break;\n        }\n\n        //nextnode = (sub[0]).next_node_list[j];\n\n        child = (sub[0].distance_to_source) + ((sub[0].next_node_list[j]->edge_weight));\n\n\n        if((child) < ((sub[0].next_node_list[j])->distance_to_source))\n        {\n\n            //this is where my problem lies I beleive\n            ((sub[0].next_node_list[j])->distance_to_source) = child;\n\n            //used for a reference to have access to final paths\n            copy[((sub[0].next_node_list[j])->id)].distance_to_source = child;\n\n            ((sub[0].next_node_list[j])->previous) = sub[0].id;       \n        }\n\n\n    best_path_weight = copy[target].distance_to_source;\n\n    }\n\n    sub.erase(sub.begin());\n\n\n}\n\n\nreturn best_path_weight;\n}\n\n\n\nint main() {\nvector<node> sub;\n\n// changing size of graph\nint number_of_vertices = 3;\nint source = 0;\nint target = 2;\nif(target > number_of_vertices)\ncout << \"ERROR! target cannot be greater than the number of vertices!\" << endl; \n\nfor(int i=0; i < number_of_vertices; i++)\n{\n    //Push new node onto a vector \n    sub.push_back(node());\n    //assigning information to nodes\n    sub[i].id = i;\n    sub[i].edge_weight = 2*i+1;\n\n    for(int j = 0; j < 3; j++)\n    {\n        sub[i].next_node_list[j]=NULL;\n        sub[i].previous_node[j]=NULL;\n    }\n\n}\n//node linking declaration\n//node 0\nsub[0].next_node_list[0]=(&sub[1]);\nsub[0].next_node_list[1]=(&sub[2]);\n\n//node 1\nsub[1].next_node_list[0]=(&sub[2]);\n//sub[1].next_node_list[1]=(&sub[4]);\nsub[1].previous_node[0]=(&sub[0]);\n\n//node3\nsub[2].previous_node[0]=(&sub[0]);\nsub[2].previous_node[1]=(&sub[1]);\n\ncout << \"distance \"<< Dijkstra(sub, source, target) << endl;\n\n}\n```\n\n    ", "Answer": "\r\nYou are storing pointers to other nodes in the vector. When you make a copy of it the new nodes still point to the nodes in the original vector. Specifically the pointers you have in ```\nnext_node_list```\n and ```\nprevious_node```\n.\n\nIf you pass sub by reference it might start working. However, it is generally unsafe to store pointers into dynamic containers. When elements get added and removed from vectors they can move from their original location in memory. If you remove from the front then all the remaining elements get shuffled forward. When using push_back there might not be enough space left so a new allocation might be made and the elements are copied/moved to an entirely new block of memory.\n\nOne thing you could try is to use a ```\nstd::vector<std::shared_ptr<node>>```\n and instead of using raw node pointers in ```\nnext_node_list```\n and ```\nprevious_node```\n, make them ```\nstd::weak_ptr<node>```\n. That will allow you to shuffle the vector around whilst maintaining the integrity of the connections.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm on a graph whose edge weights are limited\r\n                \r\nSuppose we want to run Dijkstra's algorithm on a graph whose edge weights are integers in the\nrange ```\n{1,2,...,W}```\n, where W is a relatively small number. How to find the shortest path from vertex ```\ns```\n to ```\nt```\n in ```\nO((|V|+|E|)logW)```\n?\n\nI encountered this problem from the book Algorithms by S. Dasgupta, C. Papadimitriou and U. Vazirani. I could prove that if we implement the Dijkstra's algorithm as before, at each iteration the range of the distances for nodes in the priority queue would be within ```\nW```\n. However, since priority queues do not have the property to put elements with same weights into the same bucket, this observation does not directly lead to a solution to the problem.\n\nCould anyone give me some hints on how to go one step further to make the bounded range ```\nW```\n work for me?\n\nThanks!\n    ", "Answer": "\r\nHow many different numbers you can have in your priority queue?\n\nSolution\nNote that after you extract the node with size X(and now you relax..)\nthe max size it can reach is X+W.\nall the other numbers are bigger then X (because you took the min from the queue)\nso you have only O(W) different numbers in the queue,so you can use it as a binary heap and then every step will took O(logW) and all together will be:\n(V+E)logW.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstras algorithm with priority_queue\r\n                \r\nI am trying to implement Dijkstra's algorithm. I am using this priority_queue\n\n```\npriority_queue<pair<PathInfo,string>,vector<pair<PathInfo,string> >,QueueComp> p;\n```\n\n\nwhere \n\n```\nclass QueueComp{\n    PathComp* pc;\npublic:\n    QueueComp(PathComp*);\n    bool operator ()(const pair<PathInfo,string>&,const pair<PathInfo,string>& );\n};\n```\n\n\nis my \"Compare\" function. The error is that QueueComp does not have a default constructor and I am not permitted to create one. What can I do to make my code compile? Btw this is the error\n\n```\nerror: no matching function for call to 'QueueComp::QueueComp()'\n```\n\n\nThis is the pathcomp.h\n\n```\nclass PathComp{\npublic:\n   virtual bool betterThan(const PathInfo& path1,const PathInfo& path2)=0;\n};\n```\n\n\nThis is the pathcomppl.h\n\n```\n#include \"pathcomp.h\"\n\nclass PathCompPL:public PathComp{\npublic:\nvirtual bool betterThan(const PathInfo& path1,const PathInfo& path2);\n};\n```\n\n\nThis is the pathcomppl.cpp\n\n```\n#include \"pathcomppl.h\"\n\nbool PathCompPL::betterThan(const PathInfo& path1,const PathInfo& path2){\n    if (path1.getTotalPrice()>path2.getTotalPrice())\n        return true;\n\n    if (path1.getTotalPrice()==path2.getTotalPrice() && path1.getTotalLength()>path2.getTotalLength())\n        return true;\n\n    return false;\n}\n```\n\n\nExpanded error message\n\n```\nmain.cpp: In constructor ‘std::priority_queue<_Tp, _Sequence, _Compare>::priority_queue(const _Compare&, const _Sequence&) [with _Tp = std::pair<PathInfo, std::basic_string<char> >; _Sequence = std::vector<std::pair<PathInfo, std::basic_string<char> > >; _Compare = QueueComp]’:\nmain.cpp:11:87: error: no matching function for call to ‘QueueComp::QueueComp()’\nmain.cpp:11:87: note: candidates are:\nIn file included from main.cpp:5:0:\nqueuecomp.h:14:5: note: QueueComp::QueueComp(PathComp*)\nqueuecomp.h:14:5: note:   candidate expects 1 argument, 0 provided\nqueuecomp.h:10:7: note: QueueComp::QueueComp(const QueueComp&)\nqueuecomp.h:10:7: note:   candidate expects 1 argument, 0 provided\n```\n\n    ", "Answer": "\r\nYou need to initialize your priority queue with additional parameter since you have non-default constructor.\n\n```\npriority_queue<pair<PathInfo,string>,vector<pair<PathInfo,string> >,QueueComp> p(QueueComp(ptrToPathCompObject));```\n \n\nThe additional parameter (```\nQueueComp(ptrToPathCompObject)```\n)  should fix your problem.\n\nI am assuming that you have already implemented the ```\noperator()```\n in QueueComp class.  \n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Using Dijkstra's Algorithm for pathfinding on a grid [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nOnce again having a problem with path finding this time The Dijkstra's\n\nI have read Dijkstra's and its application on a various number of sites.\nIt's mostly explained for a Graph and finding out the shortest path to all nodes from a source node.\n\nWhat I am unable to figure out is how to use Dijkstra's for path finding on a grid as explained on Wikipedia picture.\n\nsince on a grid we have a single destination and we have to figure out the shortest distance to it from the source. I am unable to relate it to the Dijkstra's on a graph.\nThere are no tiles to be marked as INFINITY or to compare the distance with other path's/Nodes.\n\nThe question in short is how do we proceed using Dijkstra's to find a path in grid using the actual graph algorithm for which this algorithm is defined.\nDo we proceed like BFS and call it Dijkstra's for a grid or is there a difference? because I am unable to figure out any :/ \n\nThank you :)\n    ", "Answer": "\r\nIn order to apply dijkstra's algorithm in a grid there is no need for any modifications, since a grid is  a graph in which a node (cell) has 4/8 children (depending on your connectivity) which are the neighbors. Therefore, all you have to do is: choose your root node (where to start), assign it value 0 and then evaluate the 4/8 neighbors, using as cost just 1 (or sqrt(2) if for the 4 diagonal neighbors if you are using 8-connectivity). This root node has to be labeled as visited and the neighbors evaluated are labeled as open. Then, you pick the node(cell) in evaluated that has a minimum value (in this case, all of them will have value 1) so you choose any of them. When adding the neighbors to the open list, it will happen that some of these neigbors are already visited, so you just ignore them. If the are already in the open list, you recompute their value and if they are unvisited, you compute their value and add them to open, and mark the current node as closed.\n\nIn fact, you will see that there is no difference at all with the generic Dijkstra's algorithm you have been reading for graphs.\n\nNOTE: in order to be efficient when getting the minimum of the open list, it is recommended to use a heap (usually a binary heap) instead of running the min function along all the open nodes at every iteration.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Implement Dijkstra's algorithm in C problems\r\n                \r\nWe've been doing a project with a robot driving in a room, and when we activate it, it returns to a choosen destination. Our task is to find the shortest path to that destination. \n\nWe've been coding in C, and trying to use Dijkstra's algorithm, but we are kinda stuck right now. We dont get the shortest route. \nThe first position in weights is the start coordinate, and end is the last.\n\n```\ndouble dijkstras(double weights[MAX_ARRAY_SIZE][MAX_ARRAY_SIZE], char output[], int     *output_number_of_waypoints, int number_of_waypoints){ \n\ndouble route_length[number_of_waypoints];\nint shortest_route_via[number_of_waypoints];\n\nint i, current_pos;\ndouble distance;\nfor (i = 0; i < number_of_waypoints; i++) {\n    route_length[i] = 0;\n    shortest_route_via[i] = -1;\n}\n\nint start = 0;                   /* first index in array */\nint end = number_of_waypoints-1; /* last index in array */\n\nfor (current_pos = start; current_pos <= end; current_pos++) {\n    for (i = 0; i < number_of_waypoints; i++) {\n        if (weights[current_pos][i] > 0) {\n            distance = route_length[current_pos] + weights[current_pos][i];\n            if (distance < route_length[i] || shortest_route_via[i] == -1) {\n                printf(\"shortest_route_via[%d] = current_pos = %d, length was %lf, shorted to %lf\\n\", i, current_pos, route_length[i], distance); /* debugging info */\n                route_length[i] = distance;\n                shortest_route_via[i] = current_pos;\n            }\n        }\n    }\n}\ncurrent_pos = end;\ni = 0;\nchar route[number_of_waypoints+1];\nwhile (current_pos != start && i < number_of_waypoints) {\n    route[i] = current_pos;\n    printf(\"currentpos = %d\\n\", current_pos); /* Debugging info - shortest path */\n    current_pos = shortest_route_via[current_pos];\n    i++;\n}\nroute[i] = '\\0';\n\nreturn route_length[end];\n```\n\n\n}\n\nWe want to get a array - shortest_route_via, which contains the shortest route via index - for example shortest_route_via[index] = waypoint. \nRoute_length contains the cost to travel to the index, for example route_length[index] = 100, means it costs 100 to travel to index.\n\nHope some1 out there can see what we are missing.\n    ", "Answer": "\r\nIf I interpret your code correctly, you're not really doing Dijkstra.\n\nDijkstra starts at a root node and then looks at all neighbors it can reach. The distance from the root to all the neighbors is then tentatively set. In the next iterations, the closest among the tentatively set nodes is made permanent and its neighbors are tentatively set.\n\nYour code doesn't select the closest node. You just iterate over all nodes in the order of their id's by incrementing ```\ncurrent_pos```\n. Unless the shortest path is strictly incremental in node order (the indices only increase like 1->4->10->14->...), you won't get the guaranteed shortest path.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm on three dimensional array\r\n                \r\nI really cannot figure out how to implement this even in psuedo-code. The user enters in something like this:\n\n```\n[\n  [\n     [0,1]\n  ],\n  [\n    [5,6],[7,8]\n  ],\n  [\n    [91,17],[18,42]\n  ],\n  [\n    [20,54]\n  ]\n]\n```\n\n\nBasically this is a path where [0,1] maps to ([5,6] and [7,8]) each of which maps to ([91,17] and [18,42]) and so on, the cost is the distance between the points. The starting point is [0, 1] and the ending point is [20,54]. There is always one starting point and one ending point, and all the points in the previous index map to the points in the next index.\n\nHow do I implement Dijkstra's algorithm for this kind of data structure?\n\nThis image may help (not to scale):\n\n\nGreen is the start and red is the end.\n    ", "Answer": "\r\nNotice that the given array is two dimensional if we considered the entry in the array as a pair ```\n(x, y)```\n.\n\nThe basic idea is build the graph, assign the cost of edges, and then apply the standard Dijkstra's algorithm.\n\nBuilding the graph:\n\nMake 2 hash tables ```\nH```\n and ```\nQ```\n where ```\nH([x,y])```\n maps a vertex ```\n(x,y)```\n to a number between ```\n0```\n and ```\nn - 1```\n, and ```\nQ```\n maps an integer between ```\n0```\n and ```\nn - 1```\n to a vertex ```\n(x, y)```\n. ```\nn```\n is the number of vertices in the graph. We can find ```\nn```\n easily by looping over all the vertices in the given ```\n2d```\n array. Let's call the given array ```\nA```\n\n\nPseudo-code of hashing: \n\n```\nn = 0\nfor(i = 0; i < length of A ; i++)\n    for(int j = 0; j < length of A[i]; j++)\n            H[A[i][j]] = n\n            Q[n] = A[i][j]\n            n++\n```\n\n\nNotice that ```\nA[i][j]```\n is actually a pair of integers, so the key of ```\nH```\n should be a pair of integers.\n\nNow we can build the graph considering vertices as numbers between ```\n0```\n and ```\nn - 1```\n. We can represent the graph as an adjacency list\n\nPsudo-code of constructing the graph:\n\n```\narray g[n][]                              //-- adjacency list of the graph\nfor(int i = 0; i < length of A - 1; i++)  //-- notice the \"-1\"\n    for(int j = 0; j < length of A[i]; j++)\n        for(int k = 0; k < length of A[i + 1]; k++)\n            g[ H[A[i][j]] ].insert (H[ A[i + 1][k] ])\n            g[ H[ A[i + 1][k] ].insert( H[A[i][j]] )     //-- assuming the graph is undirected\n```\n\n\nBy doing this, we have built the graph. Now we can apply the standard Dijkstra's algorithm on the graph ```\ng```\n. To find the cost of an edge between two vertices ```\nu```\n and ```\nv```\n we can use the hash table ```\nQ```\n in order to get the coordinates of ```\nu```\n and ```\nv```\n. Then the cost of the edge is the Euclidean distance between points ```\nQ[u]```\n and ```\nQ[v]```\n.\n\nPseudo-code for cost of an edge between two vertices ```\nu```\n and ```\nv```\n \n\n```\ncost(int u, int v)\n    return Euclidean_distance(Q[u], Q[v])\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Haskell: file to array for Dijkstra's Algorithm\r\n                \r\nI am building a graph to implement Dijkstra's algorithm and I am reading a file which contains\n\n1 3 5 \n1 2 6 \n\nHow would I read each line and store it as [(a,a,float)]. \nI need this to be able to use:\n\n```\nbuildGraph :: Ord a => [(a, a, Float)] -> Map a [(a, Float)]\n```\n\n\nHere is How I build my graph:\n\n```\nlet g =  buildGraph [('a','c',2), ('a','d',6), ('b','a',3)\n                         ,('b','d',8), ('c','d',7), ('c','e',5)\n                         ,('d','e',10)]\n```\n\n\nCurrently I can read the file and store everything in an array.\n\n```\nmain = do\n    contents <- readFile \"input.txt\"\n\n     print . map readInt . words $ contents\n\n\nreadInt :: String -> Int\nreadInt = read\n```\n\n\nI want to be able to reach each file and append to an array that will like this ('1','4',5),which is the same as(a,a,float). after the array will be ready to be sent to buildGraph\n\n```\nType Edge = (Char, Char, Float)\nreadGraphFile :: FilePath -> IO Edge\nreadGraphFile path = do\n                    alldata <- readFile path\n                    return (Char,Char,Float)\n```\n\n    ", "Answer": "\r\nHere's something based on the code you gave:\n\n```\nimport qualified Data.Char as Char -- good practice to import modules qualified\n\nmain = do contents <- readFile \"input.txt\"\n          print . map (f . words) $ lines contents\n        where\n          -- this will break if your input file is badly formed!\n          f [a,b,c] = (readChar a, readChar b, readFloat c)\n\nreadChar :: String -> Char\nreadChar c = Char.chr (64 + read c)\n\nreadFloat :: String -> Float\nreadFloat = read\n```\n\n\nThe ```\nreadChar```\n function reads a string like ```\n\"1\"```\n as an int, then adds 64 (to bring it into the ascii alphanumeric range) and uses the function ```\nChar.chr```\n to convert it to a character.\n\nYou could change the type of ```\nreadChar```\n to e.g. ```\nreadOrd :: (Read a, Ord a) => String -> a```\n to read something more generic.\n\nOf course, you'll have to do something with those values other than print them (e.g. send them to ```\nbuildGraph```\n) or the runtime won't be able to deduce which instance of the intersection ```\nRead ∩ Ord```\n you want.\n\nThis will read the file ```\ninput.txt```\n, which looks like this:\n\n```\n1 2 4.5\n1 3 6.0\n3 2 1.2\n```\n\n\nand output\n\n```\nghci> main\n[('A','B',4.5), ('A','C',6.0), ('C','B',1.2)]\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm with negative edges on a directed graph\r\n                \r\nWhat if the only negative edge costs are coming from the initial node? Will the algorithm still work?\n\nI feel like yes, because I can't think of a counter-example, but I'm having trouble proving it. Is there a counter-example?\n\nNegative edges are a problem for Dijkstra's because there's no guarantee that the edge you pick produces the shortest path if there is an edge you can pick later that is largely negatively weighted. But if the only negative edges are coming out of the initial node, I don't see the problem.\n\nI'm not looking for an algorithm. I'm looking for some insight into the Dijkstra's.\n\nI'm talking about a directed graph, if that makes a difference.\n    ", "Answer": "\r\nThe trouble with having a negative-cost edge is that you can go back and forth along it as many times as you like.\n\nIf you impose a rule that an edge may not be used more than once, you still have a problem. Dijkstra's algorithm involves marking a node as \"visited\", when it's distance from the initial node is considered know once and for all. This happens before all of the edges have been examined; the shortest path from the initial node to node X has been found, all other paths from the initial node are already longer than that, nothing that is discovered later can make those paths shorter. But if there are negative-cost edges somewhere, then a later discovery can make a path shorter, so it may be that a shorter path exists which Dijkstra will not discover.\n\nIf only the edges that connect to the initial node may have negative costs, then you still have problem, because the shortest path might involve revisiting the initial node to take advantage of the negative costs, something Dijkstra cannot do.\n\nIf you impose another rule that a node may not be visited more than once, then Dijkstra's algorithm works. Notice that in Dijkstra's algorithm, the initial node is given an initial distance of zero. If you give it some other initial distance, the algorithm will still find the shortest path-- but all of the distances will be off by that same amount. (If you want the real distance at the end, you must subtract the value you put in.)\n\n\nSo take your graph, call it A, find the smallest cost of any edge connected to the initial node, call it k which will be negative in this case).\nMake a new graph B which you get by subtracting k from the cost of each edge connected to the initial node. Note that all of these costs are now non-negative. So Dijkstra works on B. Also note that the shortest path in B is also the shortest path in A.\nAssign the initial node of B the distance k, then run Dijkstra (this will give the same path as running with an initial distance of zero). Compare this to running Dijkstra naively on A: once you leave the initial node everything's the same in the two graphs. The distances are the same, the decisions are the same, the two will produce the same path. And in the case of A the distace will be correct, since it started at zero.\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How to implement the priority queue in Dijkstra's algorithm\r\n                \r\nDijkstra's algorithm uses a priority queue which is ordered by the distances from the starting point, however the distances of the vertices are changeing during the algorithm. I am not sure when does the priority queue reorder itself but if I have the following comparator:\n\n```\nstruct compareByDistance\n{\nbool operator()(Vertex const &a, Vertex const &b)\n    {\n        return( getDistance(a) < getDistance(b) );\n    }  \n};\n```\n\n\nDuring the algorithm we only delete values from the queue, so I can't imagine that it will fully reorder itself. Therefore if a distance value changes than the queue won't be in the order of the distances.\n\nHow do you implement it similarly to this?\n    ", "Answer": "\r\nGoogle min-max(usually default) heap, it will work as a priority queue. Where you always pop the element at the top. Which will be the node with the smallest distance.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "timetable implementation with Dijkstra's Algorithm\r\n                \r\nI'm trying to implement a system of reading coach timetables to plan a journey.  \n\nHere's my scenario:\nI'd like to just enter a travel date, a start station and an end station, but to get from A to B, there could be 3 or 4 connecting journeys involved, and I'd like to return several options, ordered by total time required.  My database set up has a table for stations, a table for journeys and a table for journey instances (i.e. containing inclusive dates of operation of journeys).\n\nI've got a good implementation in c# of Dijkstra's algorithm, but I find it's limited as I can't figure out how to include time for waiting at bus stations for connecting journeys, and the fact that many journeys can go from one station to another at different times is adding to the confusion.  I also have to take into account if the journey takes a day or even 2 to complete, which has proved troublesome.  Is Dijkstra's worth persevering with here, or does anyone know of something else that might be better suited?\n\nI'm using asp.net MVC3, C# and EF4, but it's not so much code I'm after here - more just a point in the right direction of the process I'd be best using, as this is well beyond anything I've done before. (I possibly bit off more than I could chew when I volunteered for this project!) If anyone could offer some advice, or a link to some documentation that could help with this situation, that would help enormously.  Thanks\n    ", "Answer": "\r\nFirst off: good on you for volunteering on an ambitious project. Secondly: this may be a tad challenging, and judging from another StackOverflow post linked below: NP-Complete.\n\nDijkstra's algorithm finds single-source shortest paths on a static graph, but that's not what you're doing in this problem. Since the vertices in such a graph will probably exist in overlapping temporal spaces, the fastest bus from a1 to a2 may leave at 12:00 pm, but the fastest bus from a2 to a3 may leave at 11:59 am the same day. That's a non-starter.\n\nObviously, you've thought about this, but an abstract way of looking at the problem is that you're not trying to find the shortest path in a graph, but you're trying to find the shortest path in what is effectively three-dimensional space (time as the third dimension). A brute force approach (which is nonetheless fine for small graphs) could be implemented as a breadth first search, assuming you topologically order the nodes according to time.\n\nRelated link is here: Bus public transport algorithm\n\nSome reading on the topic:\n\n\nhttp://web.archive.org/web/20121224231948/http://www2.isye.gatech.edu/~mwps/publications/archetti-savelsbergh-revision.pdf\nhttp://digbib.ubka.uni-karlsruhe.de/volltexte/documents/2792\n\n\nMay the Force be with you.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How to \"decrease priority\" in a min-priority queue in Dijkstra's algorithm?\r\n                \r\nWikipedia of Dijkstra's algorithm has the following pseudocode, which uses a min-priority queue:\n```\n1  function Dijkstra(Graph, source):\n2      dist[source] ← 0                           // Initialization\n3\n4      create vertex priority queue Q\n5\n6      for each vertex v in Graph:          \n7          if v ≠ source\n8              dist[v] ← INFINITY                 // Unknown distance from source to v\n9              prev[v] ← UNDEFINED                // Predecessor of v\n10\n11         Q.add_with_priority(v, dist[v])\n12\n13\n14     while Q is not empty:                      // The main loop\n15         u ← Q.extract_min()                    // Remove and return best vertex\n16         for each neighbor v of u:              // only v that are still in Q\n17             alt ← dist[u] + length(u, v)\n18             if alt < dist[v]\n19                 dist[v] ← alt\n20                 prev[v] ← u\n21                 Q.decrease_priority(v, alt)\n22\n23     return dist, prev\n```\n\nHowever, it's unclear how ```\ndecrease_priority```\n can be implemented in logarithmic time. Would anyone care to help?\n    ", "Answer": "\r\nIt depends on which data structure you use, but ```\ndecrease_priority```\n can be implemented with O(log n) time complexity by using a min-heap. For example, I have the following heap:\n\nIf I want to decrease the priority of node i=8 from 25 to 1, I first change its priority value, but then I still need to re-heapify to maintain the heap property (root <= children). That can be done by swapping that node with its parent until the heap property is reached. This will take at most log n swaps.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra algorithm~\r\n                \r\n\n\nIf you apply the ijkstra algorithm several times, you can see the effect of the Floyd algorithm. We've created a program that uses the Dijkstra algorithm to get the shortest path from every vertex in the graph to every other vertex in the graph, and we've created a Dijkstra code.The values shown in the image are not shown. What is the reason?\n\n```\nenter code here\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define TRUE 1\n#define FALSE 0\n#define MAX_VERTICES 100    \n#define INF 1000000 \n\ntypedef struct GraphType {\n    int n;  \n    int weight[MAX_VERTICES][MAX_VERTICES];\n} GraphType;\n\nint distance[MAX_VERTICES];\nint found[MAX_VERTICES];\n\nint choose(int distance[], int n, int found[])\n\n{\n  int i, min, minpos;\n\n  min = INT_MAX;\n  minpos = -1;\n  for (i = 0; i < n; i++)\n    if (distance[i] < min && !found[i]) {\n        min = distance[i];\n        minpos = i;\n    }\n return minpos;\n}\n\nvoid print_status(GraphType* g)\n{\nstatic int step = 1;\nprintf(\"STEP %d: \", step++);\nprintf(\"distance: \");\nfor (int i = 0; i < g->n; i++) {\n    if (distance[i] == INF)\n        printf(\" * \");\n    else\n        printf(\"%2d \", distance[i]);\n\n}\nprintf(\"\\n\");\nprintf(\"        found:    \");\nfor (int i = 0; i < g->n; i++)\n\n    printf(\"%2d \", found[i]);\n\nprintf(\"\\n\\n\");\n}\nvoid shortest_path(GraphType * g, int start)\n\n{\nint i, u, w;\nfor (i = 0; i < g->n; i++) \n{\n    distance[i] = g->weight[start][i];\n    found[i] = FALSE;\n}\nfound[start] = TRUE; \ndistance[start] = 0;\nfor (i = 0; i < g->n - 1; i++) {\n    print_status(g);\n    u = choose(distance, g->n, found);\n    found[u] = TRUE;\n\n    for (w = 0; w < g->n; w++)\n        if (!found[w])\n\n            if (distance[u] + g->weight[u][w] < distance[w])\n                distance[w] = distance[u] + g->weight[u][w];\n\n  }\n}\n int main(void)\n{\nGraphType g = { 7,\n{{ 0,  7,  INF, INF,   3,  10, INF },\n{ 7,  0,    4,  10,   2,   6, INF },\n{ INF,  4,    0,   2, INF, INF, INF },\n{ INF, 10,    2,   0,  11,   9,   4 },\n{ 3,  2,  INF,  11,   0, INF,   5 },\n{ 10,  6,  INF,   9, INF,   0, INF },\n{ INF, INF, INF,   4,   5, INF,   0 } }\n};\nfor(int i=0; i<g.n; i++){\n    printf(\"from %d to other nodes>\\n\", i);\n    shortest_path(&g, i);\n}\nreturn  0;\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Initializing edges with dijkstra's algorithm\r\n                \r\nI am confused on how to initialize my Pointer (edge) class when implementing my Dijkstra's algorithm. The Node class holds an ArrayList of Pointer's called neighbors, which represent the 4 neighbors on any side of the Node. My Pointer class takes the target Node (where it's pointing) as an argument in the constructor. They are all added to a 36x25 2-dimmentional array of Nodes.\n\nAs of now I am using a setNeighbors() method ran through each node constructed on a 36x25 grid once all have been constructed, which searches through every possible Node as much as 4 times depending on its relevance in the grid (a corner has 2 neighbors), and breaks once the neighbor is found by comparing (x,y) coordinates. \n\nThis initialization process takes entirely too long for my purpose so I wanted to know if anyone can show me a way that would do this initialization if a more efficient manner.\n\nI have a class Node:\n\n```\nimport java.util.ArrayList;\n\npublic class Node implements Comparable<Node>\n{\n     public int x;\n     public int y;\n     public ArrayList<Pointer> neighbors = new ArrayList<Pointer>();\n     public double minDistance = Double.POSITIVE_INFINITY;\n     public Node previous;\n\n     public Node(int xPos, int yPos) \n     { \n        x = xPos;\n        y = yPos;\n     }\n\n     public int compareTo(Node other)\n     {\n        return Double.compare(minDistance, other.minDistance);\n     }\n}\n```\n\n\nAnd a class Pointer:\n\n```\npublic class Pointer\n{\n     public final Node target;\n     public final double weight = 1;\n     public Pointer(Node targ)       \n     { \n       target = targ;\n     }\n}\n```\n\n    ", "Answer": "\r\nWell you can let the grid represent something like a square grid with a lower and upper bound on both x and y, you could then create a recursive method where you initialize a node at (x,y) and that initialized node will initialize its north/west/south/east neighbors if those nodes x,y positions are still within the grid, else you have hit the wall and you cannot intialize any more in that direction. The problem here is what ```\nPointer```\n does, it seems like a class that complicates things. If the grid is square you can keep \n\n```\nNode north;\nNode west\nNode south\nNode east\n```\n\n\nfields in your Node class.\n\nIf the grid is not square you can still keep a\n\n```\nList<Node> connectedTo\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Does Dijkstra's algorithm with a priority queue handle destination not found?\r\n                \r\nI know how the algorithm works -- but it seems like it would just bounce around in a loop endlessly when using a priority queue trying to find the destination node that cannot be found.\n\nDoes Dijkstra's algorithm handle the case where the node is disconnected from the graph?\n    ", "Answer": "\r\nIn each iteration, exactly one node is extracted from the priority queue, and it will never be added again. Therefore, the priority queue will eventually become empty, and the algorithm stops when that happens. If there is no path to the target node, the unreachable node(s) will have their predecessor pointers set to nil (which was their initial value).\n\nThe algorithm is usually formulated in one of two ways:\n\n\nStart by adding only the start node to the priority queue. In this case, the algorithm will stop when all reachable nodes have been found.\nStart by adding all nodes to the priority queue. In this case, when there are only unreachable nodes left in the queue, you will start extracting unreachable nodes, but each of them has a distance of infinity, so they will never contribute a shorter path to any other node.\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "ArrayIndexOutOfBoundsException in Dijkstra's shortest path algorithm\r\n                \r\nI am trying to find out shortest path using Dijkstra's algorithm. but my code is showing \"Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index 2 out of bounds for length 1         at Main.main(Main.java:17)\n```\npublic static void main(String args[]) throws Exception {\n    Scanner scanner = new Scanner(System.in);\n    System.out.print(\"Enter input file name: \");\n    String file = scanner.nextLine();\n    BufferedReader br = new BufferedReader(new FileReader(file));\n    String s;\n    int array[] = new int[120];\n    int count = 0;\n    int i = 0;\n    while ((s = br.readLine()) != null) {\n        if (count > 0 && count < 121) {\n            String str[] = s.split(\" \");\n            array[i] = Integer.parseInt(str[2]) - Integer.parseInt(str[1]);\n            if (array[i] < 0) {\n                array[i] *= (-1);\n            }\n            i++;\n        }\n        count++;\n    }\n    int temp;\n    for (int j = 0; j < array.length; j++) {\n        System.out.println(array[j]);\n    }\n    for (int j = 0; j < array.length; j++) {\n        System.out.println(array[j]);\n        for (int k = j + 1; k < array.length; k++) {\n            if (array[j] > array[k]) {\n                temp = array[j];\n                array[j] = array[k];\n                array[k] = temp;\n            }\n        }\n    }\n    System.out.println(\"Shortest path: \" + array[0]);\n    System.out.println(\"Second Shortest path: \" + array[1]);\n}\n```\n\n    ", "Answer": "\r\nYou get a clue from the exception message,\n```\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index 2 out of bounds for length 1 at Main.main(Main.java:17)\n```\n\nSince the code was formatted earlier, am assuming ```\nline 17```\n is ```\narray[i] = Integer.parseInt(str[2]) - Integer.parseInt(str[1]);```\n. In which case ```\nstr[2]```\n has ```\nIndex 2```\n and is out of bounds. ```\nstr```\n is probably ```\nlength 1```\n depending on the input you gave. Arrays in Java start with ```\n0```\nindex. So you probably should use ```\narray[i] = Integer.parseInt(str[1]) - Integer.parseInt(str[0]);```\n instead.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Can we change Dijkstra's Algorithm to work with negative weights?\r\n                \r\nThe pseudocode  as taken from Wikipedia:  \n\n```\nfunction Dijkstra(Graph, source):\n 2      for each vertex v in Graph:                                // Initializations\n 3          dist[v] := infinity ;                                  // Unknown distance function from source to v\n 4          previous[v] := undefined ;                             // Previous node in optimal path from source\n 5      end for ;\n 6      dist[source] := 0 ;                                        // Distance from source to source\n 7      Q := the set of all nodes in Graph ;                       // All nodes in the graph are unoptimized - thus are in Q\n 8      while Q is not empty:                                      // The main loop\n 9          u := vertex in Q with smallest distance in dist[] ;    // Start node in first case\n10          if dist[u] = infinity:\n11              break ;                                            // all remaining vertices are inaccessible from source\n12          end if ;\n13          remove u from Q ;\n14          for each neighbor v of u:                              // where v has not yet been removed from Q.\n15              alt := dist[u] + dist_between(u, v) ;\n16              if alt < dist[v]:                                  // Relax (u,v,a)\n17                  dist[v] := alt ;\n18                  previous[v] := u ;\n19                  decrease-key v in Q;                           // Reorder v in the Queue\n20              end if ;\n21          end for ;\n22      end while ;\n23      return dist[] ;\n24  end Dijkstra.\n```\n\n\nNow, in line 14 we see that the relaxation is applied only on neighbors of ```\nu```\n that have not yet been removed from ```\nQ```\n. But if we take also neighbors of ```\nu```\n that have been removed from ```\nQ```\n, it seems to me that the algorithm does work with negative weights. I haven't found any instance that contradicts this claim.\n\nSo why Dijkstra's Algorithm isn't altered this way?\n    ", "Answer": "\r\nYou can certainly make Dijkstra's algorithm work with negative values, simply by making sure you don't traverse any node or edge twice. Here, by work, I mean terminate. The result however may not be optimal.\n\nDijkstra's algorithm has a greedy sense to it. Imagine the following graph:\n\n```\nA --- 1 --- B\n|           |\n3          -4\n|           |\nC -- -1 --- D\n```\n\n\nIf we want to go from A to B, the best path would be A-C-D-B, but Dijkstra's algorithm finds A-B. You cannot make Dijkstra's algorithm predict the future because it is a greedy algorithm. By predicting the future I mean knowing that later on, the cost of a path may be reduced. Note that this means your modification would work incorrectly if it is applied to a version of Dijkstra's algorithm that terminates as soon as the destination is seen. In the version you posted, your modification works except there are more efficient ways to handle negative edges (see comments).\n\nAs a side note, shortest path in undirected graphs with negative values or directed graphs with negative loops doesn't even make sense!\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "What algorithms compute directions from point A to point B on a map?\r\n                \r\nHow do map providers (such as Google or Yahoo! Maps) suggest directions?\n\nI mean, they probably have real-world data in some form, certainly including distances but also perhaps things like driving speeds, presence of sidewalks, train schedules, etc.  But suppose the data were in a simpler format, say a very large directed graph with edge weights reflecting distances.  I want to be able to quickly compute directions from one arbitrary point to another.  Sometimes these points will be close together (within one city) while sometimes they will be far apart (cross-country).\n\nGraph algorithms like Dijkstra's algorithm will not work because the graph is enormous.  Luckily, heuristic algorithms like A* will probably work.  However, our data is very structured, and perhaps some kind of tiered approach might work?  (For example, store precomputed directions between certain \"key\" points far apart, as well as some local directions.  Then directions for two far-away points will involve local directions to a key points, global directions to another key point, and then local directions again.)\n\nWhat algorithms are actually used in practice?\n\nPS.  This question was motivated by finding quirks in online mapping directions.  Contrary to the triangle inequality, sometimes Google Maps thinks that X-Z takes longer and is farther than using an intermediate point as in X-Y-Z.  But maybe their walking directions optimize for another parameter, too?\n\nPPS.  Here's another violation of the triangle inequality that suggests (to me) that they use some kind of tiered approach: X-Z versus X-Y-Z.  The former seems to use prominent Boulevard de Sebastopol even though it's slightly out of the way.\n\nEdit: Neither of these examples seem to work anymore, but both did at the time of the original post.\n    ", "Answer": "\r\nSpeaking as someone who spent 18 months working at a mapping company, which included working on the routing algorithm... yes, Dijkstra's does work, with a couple of modifications:\n\n\nInstead of doing Dijkstra's once from source to dest, you start at each end, and expand both sides until they meet in the middle. This eliminates roughly half the work (2*pi*(r/2)^2 vs pi*r^2).\nTo avoid exploring the back-alleys of every city between your source and destination, you can have several layers of map data: A 'highways' layer that contains only highways, a 'secondary' layer that contains only secondary streets, and so forth. Then, you explore only smaller sections of the more detailed layers, expanding as necessary. Obviously this description leaves out a lot of detail, but you get the idea.\n\n\nWith modifications along those lines, you can do even cross-country routing in a very reasonable timeframe.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Do we really need the \"visited or not\" info of a vertex in Dijkstra's algorithm?\r\n                \r\nIn  Dijkstra's algorithm on Wikipedia (older version, now corrected by me), the implementation with priority queue will check ```\nvertex```\n is visited or not before check the shorter path.\n\nIs it really necessary? or even correct?\n\n```\nfunction Dijkstra(Graph, source):\n      dist[source] ← 0                      // Initialization\n      for each vertex v in Graph:           \n          if v ≠ source\n              dist[v] ← infinity            // Unknown distance from source to v\n              prev[v] ← undefined           // Predecessor of v\n          end if\n          Q.add_with_priority(v,dist[v])\n      end for \n\n\n     while Q is not empty:               // The main loop\n         u ← Q.extract_min()               // Remove and return best vertex\n         mark u as scanned\n         for each neighbor v of u:\n             if v is not yet scanned: // **is this in need?**\n                 alt = dist[u] + length(u, v) \n                 if alt < dist[v]\n                     dist[v] ← alt\n                     prev[v] ← u\n                     Q.decrease_priority(v,alt)\n                 end if\n             end if\n         end for\n     end while\n     return prev[]\n```\n\n\nI think checking ```\nv is scanned already or not```\n will prevent any chances in the future if ```\nv```\n's path need to be updated.\n\n\n\nUpdate:\n\nI've edited the page and the current Dijkstra's algorithm wiki page is now correct.\n    ", "Answer": "\r\nThe flag is not needed. Just look at this section of pseudocode:\n\n```\nif v is not yet scanned:\n    alt = dist[u] + length(u, v) \n    if alt < dist[v]\n         dist[v] ← alt\n         prev[v] ← u\n         Q.decrease_priority(v,alt)\n    end if\nend if\n```\n\n\nIf you check the different parts:\n\n\n```\nalt```\n seems to be a local variable that is only used as temporary here, so writing to it doesn't make any difference anywhere else.\nIf ```\nv```\n was already removed from the queue, the path to it was at most as long as the path to ```\nu```\n, otherwise ```\nu```\n would have been extracted first.\nIf ```\nv```\n was visited, then ```\ndist[v] <= dist[u] <= alt```\n. In that case the comparison ```\nalt < dist[v]```\n is false and the rest of the code is skipped anyways.\n\n\nJust to explain a bit more, think about the role of the priority queue. It contains the nodes, ordered by the shortest known path to them. When extracting a node from the queue, all nodes before where at most as far away as that node and all nodes after will be at least as far away as that node. Since all nodes that were closer were already processed, any new path discovered to one of these nodes there will be via a node that is at least as far away. This means that there can't be any shorter route to an extracted node coming from a node that is still in the queue, so the mere check ```\nalt < dist[v]```\n will already exclude those nodes that were scanned.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm for a simple maze problem (Python Deque)\r\n                \r\nI am trying to use Dijkstra's algorithm to implement a person travelling across a matrix. However, my queue is not working as expected.\nIn my maze, traveller can either\n\nTravel 1 step at a time, or\nFlash a maximum of 'F' steps\nThe traveller can use flash as many times, but the total distance flashed should not exceed 'F'.\n\nSo, I implemented a Dijkstra's algorithm but I'm getting an unexpected result which I do not understand why.\nHere is my maze function\n```\ndef maze(graph: List[List[int]], start: List[int], end: List[int], F: int) -> int:\n    queue = deque()\n    # Queue design: [row, column, time taken, Flash count]\n    st = list(start)\n    st.append(0)\n    st.append(F)\n    queue.append(st)\n\n    # A graph to keep track of visit record\n    visited = [([False] * len(graph[0])) for i in range(len(graph))]\n\n    while queue:\n        current = queue.popleft()\n        row = current[0]\n        col = current[1]\n        flash_count = current[3]\n\n        if not visited[row][col] and not graph[row][col]:\n            # If current is visited or wall, skip\n            if [row, col] == list(end):\n                # If arrived at destination, return time taken\n                return current[2]\n            # General procedure: increment time taken, mark visited, add next destinations, use flash\n            current[2] += 1\n            visited[row][col] = True\n            if row < (len(graph) - 1):\n                queue.append([row + 1, col, current[2], flash_count])\n            if col < (len(graph[0]) - 1):\n                queue.append([row, col + 1, current[2], flash_count])\n            if row > 0:\n                queue.append([row - 1, col, current[2], flash_count])\n            if col > 0:\n                queue.append([row, col - 1, current[2], flash_count])\n            if flash_count > 0:\n                for flashRange in range(flash_count, 1, -1):\n                    # flashRange = Current flash count, ... ,2\n                    flash_count -= flashRange\n                    if row + flashRange < len(graph):\n                        queue.append([row + flashRange, col, current[2], flash_count])\n                    if col + flashRange < len(graph[0]):\n                        queue.append([row, col + flashRange, current[2], flash_count])\n                    if row - flashRange >= 0:\n                        queue.append([row - flashRange, col, current[2], flash_count])\n                    if col - flashRange >= 0:\n                        queue.append([row, col - flashRange, current[2], flash_count])\n                    flash_count += flashRange\n    return -1\n```\n\nI have tried testing with\n```\nmazeQ1c(\\[\\[0,1,0,0,1,0\\],\\[0,1,0,0,1,0\\],\\[0,1,0,0,1,0\\],\\[0,1,0,0,1,0\\],\\[0,1,0,0,1,0\\],\\[0,1,0,0,1,0\\]\\],\\[0,0\\],\\[5,5\\],4)```\n\nThe maze looks like this\n```\n[0,1,0,0,1,0]\n[0,1,0,0,1,0]\n[0,1,0,0,1,0]\n[0,1,0,0,1,0]\n[0,1,0,0,1,0]\n[0,1,0,0,1,0]\n```\n\nThis should be travle-able with 8 steps\n\nFlash to (0,2)\nWalk to (0,3)\nFlash to (0,5)\nWalk 5 steps to (5,5)\n\nbut I'm keep getting -1 returned instead.\nSo I tried debugging, and I found that at (0,3) it does not flash to (0,5), but I am not sure why.\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Tweaking Dijkstra's Algorithm to detect minimum length cycle in directed graph\r\n                \r\nI am trying to find the minimum length cycle in a directed graph but this time using a greedy algorithm.\nI think the smartest way to do it is using Dijkstra's Algorithm  using some kind of tweak. (I also know that the Graph has positive weights which makes it a bit obvious), but I can't seem to be able to find a nice way to do it.\nI thought of probably splitting a node into its ingoing and outgoing edges, and running Dijkstra's algorithm for every node like this, which ends up being O(V^3). Can I do better using another greedy algorithm maybe?\n    ", "Answer": "\r\n\nremove all leaf nodes ( nodes with only in edges ) since they cannot be part of a cycle\nremove all root nodes ( nodes with only out edges ) since they cannot be part of a cycle\nstart a breadth first search from every remaining node\nincrement depth of each search by one ( easy optimization using threads on a multi-processor machine )\nfirst search to revisit starting node is the minimum length cycle\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Why can Dijkstra's Algorithm be modified to find K shortest paths?\r\n                \r\nI am trying to find an intuitive explanation as to why we can generalize Dijkstra's Algorithm to find the K shortest (simple) paths from a single source in a directed, weighted graph with no negative edges. According to Wikipedia, the pseudocode for the modified Dijkstra is as follows:\n```\nDefinitions:\n  G(V, E): weighted directed graph, with set of vertices V and set of directed edges E,\n  w(u, v): cost of directed edge from node u to node v (costs are non-negative).\n  Links that do not satisfy constraints on the shortest path are removed from the graph\n  s: the source node\n  t: the destination node\n  K: the number of shortest paths to find\n  P[u]: a path from s to u\n  B: a heap data structure containing paths\n  P: set of shortest paths from s to t\n  count[u]: number of shortest paths found to node u\n\nAlgorithm:\n  P = empty\n  for all u in V:\n    count[u] = 0\n  insert path P[s] = {s} into B with cost 0\n\n  while B is not empty:\n    let P[u] be the shortest cost path in B with cost C\n    remove P[u] from B\n    count[u] = count[u] + 1\n    \n    if count[u] <= K then:\n      for each vertex v adjacent to u:\n        let P[v] be a new path with cost C + w(u, v) formed by concatenating edge (u, v) to path P[u]\n        insert P[v] into B\n  return P\n```\n\nI know that, for the original Dijkstra's Algorithm, one can prove by induction that when a node is added to the closed set (or popped from a heap if it's implemented in the form of BFS + heap), the cost to that node must be minimum from the source.\nThis algorithm here seems to be based on the fact that when a node is popped for the ith time from the heap, we have the ith smallest cost to it from the source. Why is this true?\n    ", "Answer": "\r\nThe Wiki article doesn't specify, but that code will only solve the 'loopy' version of k-shortest-paths, where paths are not required to be simple.\nThe simple path version of the problem is harder: you'll want to look at something like Yen's algorithm, which does clever filtering to avoid repeated points when generating paths. Yen's algorithm can use Dijkstra's algorithm as a subroutine, but any other shortest-path algorithm can also be used instead.\nThere is no obvious way to modify Dijkstra's algorithm to solve the k-shortest-simple-paths problem. You'd need to track the paths in the priority queue (which is already done in your posted code), but there's an exponential upper bound on the number of times each vertex can be explored.\nHere, ```\nif count[u] <= K```\n puts an upper bound of ```\nK+1```\n on the number of times a vertex can be explored, which works for the non-simple path case. On the other hand, a direct modification of Dijkstra's algorithm for simple paths would, in the worst case, require you to explore a node once for each of the ```\n2^(V-1)```\n possibilities of which nodes had been previously visited (or possibly a slightly smaller exponential).\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm with adjacency list graph\r\n                \r\nI have an undirected, weighted graph implemented as an adjacency list. There is a hashmap with Node objects as keys and lists of Edge objects as values. These Edge objects contain the weight the weight of the edges between two nodes. \n\nI'm trying to code a Dijkstra's shortest path algorithm; but I fear my graph structure is too complicated to make sense of all the example/pseudo code I can find for Dijkstra's. Can anyone offer any help. Thanks in advance.\n    ", "Answer": "\r\nHow about using Boost Graph Library ,there is also python binding for it. I thought Dijkstra Shortest path is one of its example.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm vs relaxing edges in topologically sorted graph for DAG\r\n                \r\nI was reading Introduction To Algorithms 3rd Edition. There are 3 methods given to solve the problem. My inquiry is about two of them.\n\nThe one with no name\n\n\n  The algorithm starts by topologically sorting the dag (see Section 22.4) to impose a linear ordering on the vertices. If the dag contains a path from vertex u to vertex v, then u precedes v in the topological sort. We make just one pass over the vertices in the topologically sorted order. As we process each vertex, we relax each edge that leaves the vertex.\n\n\nDijkstra's Algorithm\n\nThis is quite well known\n\nAs far as the book shows, time complexity of without name one is O(V+E) but of Dijstra's is O(ElogV). We cannot use Dijkstra's on negative weight but we can use the other. What are the advantages of using Dijkstra's Algorithm except it can be used in cyclic ones?\n    ", "Answer": "\r\nBecause the first algorithm you give only works on acyclic graphs, whereas Dijkstra runs on graph with non-negative weight.\nThe limitations are not the same.\n\nIn real-world, many applications can be modelled as graphs with non-negative weights, that's why Dijkstra is so used. Plus, it is very simple to implement. The complexity of Dijkstra is higher because it relies on priority queue, but this does not mean it takes necessarily more time to execute. (nlog(n) time is not that bad, because log(n) is a relatively small number: log(10^80) = 266)\n\nHowever, this stand for sparse graphs (low density of edges). For dense graphs, other algorithms may be more efficient.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "What kind of graph I need for Dijkstra's algorithm? C++\r\n                \r\nI am trying to learn some more stuff about graphs and Dijkstra's Algorithm, so I have a function that randomly generates a weighted undirected graph, saves in a file like this:\n```\nnumbers_of_vertices number_of_nodes\nnode_a node_b distance_from_a_to_b\netc.\n```\n\nAnd then I run Dijkstra's to output the distances from node 0 to all the other nodes, but sometimes the distance from node 0 to other nodes is 0, that means that there is no connection from node 0 to that node?\nAlso I have another question, with what kind of graphs Dijkstra's works?>br>\nThanks for the help!\n    ", "Answer": "\r\nDijkstra's algorithm is a variation of a BFS traversal. The difference is, it utilizes a min heap to traverse to the closest node every time.\nYour function that randomly generates a weighted undirected graph should not create a pair of nodes where node_a and node_b have a distance of 0. This means the node is in the same exact place - thus, no need to traverse.\nDijkstra's algorithm works on any weighted graphs (with positive only weights) where you have a starting and an end condition.\nHere's a 10 minute video explaining the algorithm:\nhttps://www.youtube.com/watch?v=pVfj6mxhdMw\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm implementation with binary heaps\r\n                \r\nI've been trying to implement Dijkstra's algorithm with binary heaps for my algorithms class.The goal is to find the length of the minimum spanning tree found through Dijkstra. I've worked with before, but using Priority queues. I find I'm getting tripped up with the heap management, and if anyone could spot errors. Main method is below:\n\n```\nimport java.io.File;\nimport java.util.regex.*;\nimport java.util.ArrayList;\npublic class main {\n\n    public static void main(String[] args) {\n        // TODO Auto-generated method stub\n        try {\n            File input = new File(\"filepath\\1000.txt\");\n            Scanner scanner = new Scanner(input);\n\n            //Regex patterns used to find input size, nodes, and edges\n            String size = \"n=([0-9]*)\";\n            String node = \"^[0-9]+\";\n            String edge = \"^[\\\\s]+([0-9]+)[\\\\s]+([0-9]+)\";\n\n            Pattern sizePattern = Pattern.compile(size);\n            Pattern edgePattern = Pattern.compile(edge);\n            Pattern nodePattern = Pattern.compile(node);\n\n\n            //Loop to fill nodeList\n            ArrayList <Integer> finalDistances = new ArrayList<>();\n            MinHeap list = null;\n            Node currentNode = null;\n            Edge currentEdge = null;\n            while(scanner.hasNextLine()) {\n\n                String line = scanner.nextLine();\n                Matcher match1 = sizePattern.matcher(line);\n                Matcher match2 = nodePattern.matcher(line);\n                Matcher match3 = edgePattern.matcher(line);\n                //catches size\n                if(match1.find()) {\n                    int numberOfNodes = Integer.parseInt(match1.group(1));\n                    //Holds all the nodes to process with Dijkstra's Algo\n                    list = new MinHeap(numberOfNodes);\n                }\n                //catches node\n                if (match2.find()) {\n                    if (!list.contains(Integer.parseInt(line))) {\n                        currentNode = new Node(Integer.parseInt(line));\n                        currentNode.seen = false;\n                        currentNode.distance = Integer.MAX_VALUE;\n                        list.insert(currentNode);\n                    }\n                    else {\n                        currentNode = list.getNode(Integer.parseInt(line));\n                    }\n                }\n                //catches edge\n                if(match3.find()) {\n                    if (!list.contains(Integer.parseInt(match3.group(1)))) {\n                        Node temp = new Node(Integer.parseInt(match3.group(1)));\n                        temp.seen = false;\n                        temp.distance = Integer.MAX_VALUE;\n                        list.insert(temp);\n                        currentEdge = new Edge(Integer.parseInt(match3.group(1)), Integer.parseInt(match3.group(2)));\n                        currentNode.add(currentEdge);\n                    } else {\n                        currentEdge = new Edge(Integer.parseInt(match3.group(1)), Integer.parseInt(match3.group(2)));\n                        currentNode.add(currentEdge);\n                    }\n                }\n            }\n            Node source = list.getNode(0);\n            source.distance=0;\n            list.updateNode(source);\n            int treeLength = 0;\n            while(!list.isEmpty()) {\n                currentNode = list.extractMin();\n                currentNode.seen = true;\n                ArrayList<Edge> edgeList = currentNode.edges;\n                for (int i = 0; i < edgeList.size(); i++) {\n                    currentEdge = edgeList.get(i);\n                    if (list.contains(currentEdge.end)) {\n                        int calcDist = currentNode.distance + currentEdge.weight;\n                        if (calcDist < list.getNode(currentEdge.end).distance) {\n                            list.decreaseKey(list.getNode(currentEdge.end), calcDist);\n                        }\n                    }\n                }\n                System.out.println(currentNode.toString() + \"with distance\" +currentNode.distance);\n                finalDistances.add(currentNode.distance);\n            }\n            for (int j = 0; j < finalDistances.size(); j++) treeLength+= finalDistances.get(j);\n            System.out.println(\"Tree length is: \"+treeLength);\n        }\n\n        //fail safe\n        catch (Exception ex){\n            System.out.println(\"Shit broke!\");\n        }\n    }\n\n}\n```\n\n\nThe input is just a txt file formated like: \n\n```\n0\n    25    244\n   108    275\n   140    273\n   159    313\n   219    199\n   254    392\n   369    171\n   518    271\n   538    250\n   568    253\n   603    307\n   613    196\n   638    314\n\n1\n    24    187\n    43    182\n    65    331\n   155    369\n   182    222\n   186    426\n   224    395\n   233     72\n   240    128\n   250    101\n   269    251\n   371     73\n   409    301\n   444     40\n   451    262\n   464    337\n   517    393\n   569    171\n   586    384\n   599    221\n   601    145\n   611    209\n   616    330\n   629    324\n   644    254\n   646    316\n   675    237\n   684    327\n   695    439\n   696    288\n```\n\n\nThe first line is the number of nodes and edges. A number by itself on a line is a Node and the numbers after are edges with weights. My Node class just has a int value, arraylist of edges, and a distance from source. My Edge class has a int value, and int weight.\n\n```\nimport java.util.ArrayList;\n\npublic class Node {\n    int value;\n    ArrayList<Edge> edges;\n    boolean seen;\n    int distance;\n    public Node(int value) {\n        edges = new ArrayList<>();\n        this.value = value;\n        seen = false;\n    }\n    public void add (Edge edge) {\n        edges.add(edge);\n    }\n    @Override\n    //debugging use\n    public String toString() {\n        String listOfEdges= \"\";\n        //for (int i = 0; i < edges.size(); i++) {\n        //  listOfEdges = listOfEdges + \" ,\" + Integer.toString(edges.get(i).end);\n        //}\n        return \"Node: \"+Integer.toString(value); //+\" Edges: \"+listOfEdges;\n    }\n}\n```\n\n\n```\npublic class Edge {\n    int end;\n    int weight;\n    public Edge(int end, int weight) {\n        this.end = end;\n        this.weight = weight;\n    }\n    @Override\n    //debugging use\n    public String toString() {\n        return \"Edge: \"+end+\" Weight: \"+weight;\n    }\n}\n```\n\n\nIt seems to be after a point running the algorithm, some vertices remain infinity, and others negative infinity. I'm using two arrays: first is the heap that stores the Nodes, and second is to store the indexes of Nodes in the heap. The full class is below: \n\n```\n    private int capacity;\n    private int currentSize;\n    private Node[] heap;\n    private int[] locations;\n    //private HashMap<Integer, Integer> locations = new HashMap<>();\n\n    public MinHeap(int capacity) {\n        this.capacity = capacity;\n        heap = new Node[capacity];\n        locations = new int[capacity];\n        //heap[0] = new Node(-1);\n        //heap[0].distance = Integer.MIN_VALUE;\n        currentSize = 0;\n    }\n    private int getParent(int index) {\n        return (index-1)/2;\n    }\n    private int getLeftChild(int index) {\n        return index*2+1;\n    }\n    private int getRightChild(int index) {\n        return index*2+2;\n    }\n    private void swap(int a, int b) {\n        Node temp = heap[a];\n        heap[a] = heap[b];\n        heap[b] = temp;\n        //maybe bug\n\n\n    }\n    Node extractMin() {\n        Node min = heap[0];\n        Node last = heap[currentSize-1];\n        swap (0,currentSize-1);\n        locations[last.value] = 0;\n        locations[min.value] = -1;\n        currentSize--;\n        heapifyDown(0);\n        System.out.println(\"heap size: \"+currentSize);\n        return min;\n    }\n    void heapifyDown(int index) {\n        int currentIndex = index;\n        int leftIndex = getLeftChild(currentIndex);\n        int rightIndex = getRightChild(currentIndex);\n        if (leftIndex < currentSize && heap[currentIndex].distance > heap[leftIndex].distance) {\n            currentIndex = leftIndex;\n        }\n        if (rightIndex < currentSize && heap[currentIndex].distance > heap[rightIndex].distance) {\n            currentIndex = rightIndex;\n        }\n        if (currentIndex != index) {\n            Node newTop = heap[currentIndex];\n            Node oldTop = heap[index];\n\n            locations[newTop.value] = index;\n            locations[oldTop.value] = currentIndex;\n            swap(index,currentIndex);\n            heapifyDown(currentIndex);\n        }\n    }\n    void heapifyUp(int index) {\n        int parentIndex = getParent(index);\n        int currentIndex = index;\n        Node currentNode = heap[currentIndex];\n        Node parentNode = heap[parentIndex];\n        while (currentIndex > 0 && heap[parentIndex].distance > heap[currentIndex].distance) {\n            System.out.println(\"Swapped: \"+heap[getParent(currentIndex)].toString()+\" That has a distance of: \"+heap[getParent(currentIndex)].distance+ \" With: \"+heap[currentIndex]+\" Which has a distance of: \"+heap[currentIndex].distance);\n            swap(parentIndex,currentIndex);\n            locations[currentNode.value] = parentIndex;\n            locations[parentNode.value] = currentIndex;\n            currentIndex = parentIndex;\n            parentIndex = getParent(parentIndex);\n\n            System.out.println(\"min: \"+heap[0].toString());\n        }\n    }\n    public void decreaseKey(Node node, int distance) {\n        int location = locations[node.value];\n        heap[location].distance = distance;\n        heapifyUp(location);\n    }\n    public void insert(Node node) {\n        //currentSize++;\n        int index = currentSize;\n        heap[currentSize] = node;\n        locations[node.value] = currentSize;\n        currentSize++;\n        heapifyUp(index);\n    }\n    public boolean contains(int node) {\n        return locations[node] != 0 && locations[node] != -1;\n    }\n    public boolean isEmpty() {\n        return currentSize==0;\n    }\n    public Node getNode(Node node) {\n        return heap[locations[node.value]];\n    }\n    public Node getNode(int nodeValue) {\n        return heap[locations[nodeValue]];\n    }\n    public void updateNode(Node node) {\n        heap[locations[node.value]] = node;\n    }\n    public void print() {\n        for (int i = 0; i < currentSize; i++) {\n            System.out.println(heap[i].toString());\n        }\n    }\n    public Node peek() {\n        return heap[0];\n    }\n    public int size() {\n        return currentSize;\n    }\n}\n```\n\n\nAny feedback is appreciated.\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm Letting All Vertices be Source\r\n                \r\nThere are [N] locations in a town labeled 1....N. You are provided a list of streets S (|S| = M) where a single street connects two locations in the town and has an associated distance. You also provided a list ```\nH```\n of houses in the town and a list C, all the COVID-19 testing centers in the town. For each house find the shortest distance to the closest testing center. Solve the problem in O(M * log N) time.\nI see that this is a graph problem and I can build an undirected graph from the list of streets because a street can be viewed as an edge where the edge-weight is the distance between the two locations.\nBecause the problem wanted to find the shortest distance to a testing center for all houses my thought was to run Dijkstra's algorithm for each house in H. However, this would give me a runtime of O(|H|*MlogN) and we want a runtime of O(MlognN). Are there any modifications that can be made to Dijkstra's algorithm to achieve this runtime? I have to treat each house as a source vertex to find the shortest distance and I don't see any way that can be done in the required time complexity.\n    ", "Answer": "\r\nUse Dijkstra initialized from each center, not house.\nMark all houses as unvisited, mark all centers with distance 0\nAdd all centers to PQ.\nContinue with dijkstra...\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Data Structures / undirected graphs and Dijkstra's algorithm\r\n                \r\nI am stuck on a two part practice problem regarding the subjects mentioned in the title.\n\nThe first part of the question asks:\nBy considering the complete graph with n verticies, show that the maximum number of simple paths between two verticies is O((n-1)!).  (I am assuming I am supposed to show this somehow with a formal definition)\n\nThe second portion of the questions asks:\nGive an example where Dijkstra's algorithm gives the wrong answer in the presence of a negative edge but no negative cost cycles.\n\nThanks for any help!\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Data Structures / undirected graphs and Dijkstra's algorithm\r\n                \r\nI am stuck on a two part practice problem regarding the subjects mentioned in the title.\n\nThe first part of the question asks:\nBy considering the complete graph with n verticies, show that the maximum number of simple paths between two verticies is O((n-1)!).  (I am assuming I am supposed to show this somehow with a formal definition)\n\nThe second portion of the questions asks:\nGive an example where Dijkstra's algorithm gives the wrong answer in the presence of a negative edge but no negative cost cycles.\n\nThanks for any help!\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm a greedy or dynamic programming algorithm?\r\n                \r\nIn this post it is described Dijkstras as a greedy algorithm, while here and here it is shown to have connections with dynamic programming algorithms. \n\nWhich one is it then?\n    ", "Answer": "\r\nIt's greedy because you always mark the closest vertex. It's dynamic because distances are updated using previously calculated values.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm using Priority Queue on Java\r\n                \r\nI need to implement Dijkstra's Algorithm using priority queue in Java. Here is my code so far:\n\n```\npublic class Node {\n        long idNum;\n        String label;\n        HashSet<Edge> outEdges;\n        HashSet<Edge> inEdges;\n        int indegree;\n        int outdegree; \n\n        int inNum, outNum;\n        HashMap<Node, Edge> incoming, outgoing;\n\n        Node(String label, Long idNum) {\n            this.label = label;\n            this.idNum = idNum;\n\n            inNum =0;\n            outNum=0; \n            incoming = new HashMap<Node, Edge>();\n            outgoing = new HashMap<Node, Edge>();\n\n        }\n        Node(String Label){\n            this.label=label;\n        }\n\n        public void addOutgoing(Node n, Edge e){\n            if(n==null) return;\n            outgoing.put(n,e);\n            outNum++;\n        }\n        public void addIncoming(Node n, Edge e){\n            if(n==null) return;\n            incoming.put(n, e);\n            inNum++;\n        }\n        public void delIn(Node n){\n            incoming.remove(n);\n            inNum--; \n        }\n        public void delOut(Node n){\n            outgoing.remove(n);\n            outNum--;\n        }\n\n        public int getinNum(){\n            return this.inNum; \n        }\n        public boolean containsEdge(Edge e){\n            if(incoming.containsValue(e) || outgoing.containsValue(e)){\n                return true;\n            }\n            return false;\n        }\n\n        String getLabel(){\n            return this.label;\n        }\n\n\n    }\n\n    public class Edge {\n\n        long idNum, weight;\n        String sLabel, dLabel, eLabel;\n        Node sNode, dNode;\n        Node from;\n        Node to;\n        int distance;\n\n        public Edge(long idNum, String sLabel, String dLabel, String eLabel) {\n            this.idNum = idNum;\n            // this.weight=weight;\n            this.sLabel = sLabel;\n            this.dLabel = dLabel;\n            this.eLabel = eLabel;\n        }\n\n        public Edge(Node from, Node to) {\n            this.from = from;\n            this.to = to;\n        }\n\n        long getidNum() {\n            return this.idNum;\n        }\n\n        public int getDistance() {\n            return this.distance;\n        }\n\n    }\n\n\npublic class DiGraph implements DiGraph_Interface {\n    // private Map<Node, Edge> digraph = new HashMap<Node, Edge>();\n    private Map<String, Long> nodes = new HashMap<String, Long>();\n    private Set<Node> nodes1 = new HashSet<Node>();\n    private Set<Edge> edges = new HashSet<Edge>();\n    private Map<Node, Node> edges1 = new HashMap<Node, Node>();\n    private Set<Long> edge_ids = new HashSet<Long>();\n\n    public long numEdges = 0;\n    public long numNodes = 0;\n\n    public DiGraph() { // default constructor\n        // explicitly include this\n        // we need to have the default constructor\n        // if you then write others, this one will still be there\n\n    }\n\n    @Override\n    public boolean addNode(long idNum, String label) {\n        Node node = new Node(label, idNum);\n        if(nodes.containsKey(label) || idNum <0 || label==null || nodes.containsValue(idNum)){\n            return false;\n        }\n        nodes.put(label, idNum);\n        nodes1.add(node);\n        numNodes++;\n        return true;\n\n    }\n\n    @Override\n    public boolean addEdge(long idNum, String sLabel, String dLabel, long weight, String eLabel) {\n        Edge e = new Edge(idNum, sLabel, dLabel, eLabel);\n        Node n1 = new Node(sLabel, idNum);\n        Node n2 = new Node(dLabel, idNum);\n        if(edge_ids.contains(idNum)){\n            return false;\n        }\n        for(Node n: nodes1){\n            if(n.containsEdge(e)){\n                return false;}\n        }\n        for(Edge edge: edges){\n            if(edge.dLabel == dLabel && edge.sLabel == sLabel){return false;}\n        }\n\n        boolean check1=false;\n        boolean check2=false;\n        for(Node n: nodes1){\n            if(n.label.equals(sLabel)){\n                e.sNode=n; \n                check1=true;\n            }\n            if(n.label.equals(dLabel)){\n                e.dNode=n;\n                check2=true;\n            }\n        }\n        if(!check1 || !check2){return false;}\n\n        e.sNode.addOutgoing(e.dNode, e);\n        e.dNode.addIncoming(e.sNode,e);\n\n        n1.addOutgoing(n2, e);\n        n2.addIncoming(n1, e);\n        edge_ids.add(idNum);\n        edges.add(e);\n        numEdges++;\n        return true; \n\n    }\n\n    @Override\n    public boolean delNode(String label) {\n        Node node = new Node(label);\n        if (!nodes.containsKey(label)) {\n            return false;\n        }\n        if (nodes.containsKey(label) || nodes1.contains(node)) {\n            nodes.remove(label, nodes.get(label));\n            nodes1.remove(node);\n            numNodes--;\n            return true;\n        }\n        Set<Edge> remainingEdges = new HashSet<Edge>();\n        for(Edge edge : edges){\n            if(!node.containsEdge(edge)){\n                remainingEdges.add(edge);\n            }\n        }   \n        edges =  remainingEdges;\n        numNodes--;\n        return true;\n    }\n\n    @Override\n    public boolean delEdge(String sLabel, String dLabel) {\n        if(!nodes.containsKey(dLabel)|| !nodes.containsKey(sLabel)){\n            return false;\n        }\n        for(Edge edge: edges){\n            if(edge.dLabel == dLabel && edge.sLabel == sLabel){\n                edge.sNode.delOut(edge.dNode);\n                edge.dNode.delIn(edge.sNode);\n                long idNum = edge.getidNum();\n                numEdges--;\n                edges.remove(edge);\n                edge_ids.remove(idNum);\n                return true;\n            }\n        }\n        return false; \n    }\n\n\n    @Override\n    public long numNodes() {\n        return this.numNodes;\n    }\n\n    @Override\n    public long numEdges() {\n        return this.numEdges;\n    }\n\n    @Override\n    public String[] topoSort() {\n\n\n        ArrayList<Node> nodeArray = new ArrayList<Node>();\n        Stack<Node> nodeStack = new Stack<Node>();\n        for(Node n: nodes1){\n            nodeArray.add(n);\n        }\n        String[] topoSort = new String[(int) numNodes]; \n        int counter=0;\n\n        int i=0;\n        //for(int i=0; i< numNodes; i++){\n            for(Node n: nodes1){\n\n                if(n.inNum==0){\n                    nodeStack.push(n);\n                }\n                if(nodeStack.isEmpty()){\n                    return null;\n                }\n                while(!nodeStack.isEmpty()){\n                    nodeStack.pop();\n                    nodeArray.remove(n);\n                if(n.incoming==null){\n                    topoSort[i]=n.getLabel();\n                    counter++;\n                    i++;\n                }\n                }\n            //}\n        }\n        if(counter != numNodes){\n            return null;\n        }\n        return topoSort;\n    }\n\n    @Override\n    public ShortestPathInfo[] shortestPath(String label) {\n        Node startNode = new Node(label);\n\n        return null;\n    }\n}\n```\n\n\nI need to fill in the shortestPath method and return an array of nodes. However, I am unsure as to how to go about this. I know I need to make a priority queue at some point, but can someone please explain to me how? I have already made the startNode and I know I need to assign to it a distance value of 0 and the rest of the nodes a distance value of infinity. Also where does a comparable come into this?\n    ", "Answer": "\r\nStarting with your ```\nNode```\n class:\n\n```\npublic class Node {\n    // add a parent attribute to the class\n    // this will be used in your shortestPath method\n    // i have explained it below\n    private Node parent;\n}\n```\n\n\nThe ```\nEdge```\n class:\n\n```\npublic class Edge {\n    // why do you have four of these? You only need two\n    private Node sNode, dNode;\n    private Node from;\n    private Node to;\n}\n```\n\n\nYour Directed Graph class looks too complicated to me. You can simplify it a little bit:\n\n```\npublic class DiGraph implements DiGraph_Interface {\n\n    private LinkedList<Node>[] adjList;\n    private HashSet<Edge> edges;\n\n    // implement the interface methods as you have done\n}\n```\n\n\nThe search method in ```\nDiGraph```\n:\n\n```\n@Override\npublic ShortestPathInfo[] shortestPath(String label) {\n    PriorityQueue<Node> queue = new PriorityQueue<>(new Comparator() {\n        @Override\n        public int compare(Object o1, Object o2) {\n            Node n1 = (Node) o1;\n            Node n2 = (Node) o2;\n            // this assumes that lower number is higher priority\n            // also, this compare method compares the two string values\n            // from the two nodes. If n1.label is lexicographically smaller\n            // then n1 will be added high up in the queue\n            // you can compare based on the node's idNum too\n            // you should implement it based on your requirements\n            return n1.label.compareTo(n2.label);\n        }\n    });\n\n    // create a method getScrNode()\n    // in that method, traverse the linkedList to find the srcNode\n    // You can do this easily if you keep Map of nodes, like you did in your code\n    // but that just takes too much memory\n    Node start = getSrcNode(label);\n    queue.add(start);\n    while (!queue.isEmpty()) {\n        /*This is your main exercise. You should solve it yourself.\n        Somewhere here you should set the parent of a node\n        */            \n    }\n\n    // print the path\n    if (done) {\n        while (current.getParent() != null)\n            System.out.println(current.getLabel());\n    }\n    return null;\n}\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Implementing Dijkstra's algorithm using BGL graph\r\n                \r\nI am trying to implement Dijkstra's shortest path algorithm using BGL libraries in OMNET++\n\nIn course of doing so, I came across we need Graphviz DOT file for the same. \n\nHow do I create DOT file for the algorithm using graphviz?\n    ", "Answer": "\r\nYou can create DOT files by hand pretty easily. The file format is fairly simple and documented on Wikipedia and on the graphviz website.\n\nHere's a sample of a simple acyclic directed graph.\n\n```\ndigraph graph-name {\n     a -> b -> c;\n     b -> d;\n }\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How can I print the steps the algorithm takes to find the result (dijkstra's algorithm)?\r\n                \r\nSo I have this dijkstra's algorithm code,that calculates the shortest distance between from the starting node to every other. Except for the result, I want the algorithm to also print the steps it made to find the solution. How can this be done?\n```\nnodes = ('1', '2', '3', '4', '5', '6')\n\ndistances = {\n '1': {'1': 0, '2': int(input('enter distance from 1 to 2')), '4': int(input('enter distance from 1 to 4'))},\n'2': {'2': 0, '1': int(input('enter distance from 2 to 1')), '3':  int(input('enter distance from 2 to 3')), '4' : int(input('enter distance from 2 to 4')), '5':  int(input('enter distance from 2 to 5'))},\n'3': {'3': 0, '2': int(input('enter distance from 3 to 2')), '4': int(input('enter distance from 3 to 4')), '5': int(input('enter distance from 3 to 5')), '6':int(input('enter distance from 3 to 6'))},\n'4': {'4': 0, '1': int(input('enter distance from 4 to 1')), '2':int(input('enter distance from 4 to 2')), '3':int(input('enter distance from 4 to 3')), '5':int(input('enter distance from 4 to 5'))},\n'5': {'5': 0, '3': int(input('enter distance from 5 to 3')), '4': int(input('enter distance from 5 to 4')), '2':int(input('enter distance from 5 to 2')), '6':int(input('enter distance from 5 to 6'))},\n'6': {'6': 0, '3': int(input('enter distance from 6 to 3')), '5': int(input('enter distance from 6 to 5')), }\n\n}\na=input('enter current')\nunvisited = {node: None for node in nodes} #using None as +inf\nvisited = {}\ncurrent = a\ncurrentDistance = 0\nunvisited[current] = currentDistance \n\nwhile True:\nfor neighbour, distance in distances[current].items():\n    if neighbour not in unvisited: continue\n    newDistance = currentDistance + distance\n    if unvisited[neighbour] is None or unvisited[neighbour] > newDistance:\n        unvisited[neighbour] = newDistance\nvisited[current] = currentDistance\ndel unvisited[current]\nif not unvisited: break\ncandidates = [node for node in unvisited.items() if node[1]]\ncurrent, currentDistance = sorted(candidates, key = lambda x: x[1])[0]\n\nprint(visited)\n```\n\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra algorithm with Python\r\n                \r\nHere is a part of a Dijkstra algorithm, i have some question  about some code, which I don't understand:\n\nhttp://geekly-yours.blogspot.co.at/2014/03/dijkstra-algorithm-python-example-source-code-shortest-path.html\n\nCan somebody tell me, what these tree line do?\n\n```\n...\npred=predecessors.get(pred,None)\n...\n\nif new_distance < distances.get(neighbor,float('inf')):\n...\n\nunvisited[k] = distances.get(k,float('inf')) #what does this .get(k,float('inf')) ??\n...\n```\n\n    ", "Answer": "\r\nThese all use ```\nget```\n.  \n\n```\nD.get(key,default)\n```\n\n\nwill look at the dict ```\nD```\n.  If it has key ```\nkey```\n it will return ```\nD[key]```\n.  If not it returns ```\ndefault```\n.\n\n```\nD={'a':0}\n\nD.get('a', 4)\n> 0\nD.get('b', 4)\n>4 \n```\n\n\nSo the second line \n\n```\nif new_distance < distances.get(neighbor,float('inf')):\n```\n\n\nchecks if the ```\nnew_distance```\n is less than the current best option, or if there is no a current best option, it will evaluate to ```\nTrue```\n (since it's going to be less than infinity).\n\nThe third line \n\n```\nunvisited[k] = distances.get(k,float('inf'))\n```\n\n\ngives ```\nunvisited[k]```\n whatever the current distance is to ```\nk```\n or else infinity if no distance is defined.\n\nBack to the first line\n\n```\npred=predecessors.get(pred,None)\n```\n\n\nIf ```\npredecessors[pred]```\n is defined, it gives ```\npred = predecessors[pred]```\n.  If not, it sets ```\npred=None```\n.  ```\nNone```\n is a standard value used in Python to signal that something doesn't have a value.  Any function that doesn't return anything explicitly will instead return ```\nNone```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Number of steps condition to dijkstra's algorithm\r\n                \r\nI'm currently a student and am working on a small project. My aim is to be able to determine the shortest path between two given cities, but with the condition that one needs to go through a specified number of other cities (or as you might have understood, a certain number of nodes as I'm working with a graph). I have already coded most of the program following the basic headlines of dijkstra's algorithm (which is the only one I am allowed to use), but find myself unable to specify the number of nodes that it needs to go through, does one of you have any idea of how I might do it?\n\n```\nimport sys\ndef shortestpath(graph,start,end,visited=[],distances={},predecessors={}):\n\"\"\"Find the shortest path between start and end nodes in a graph\"\"\"\n# we've found our end node, now find the path to it, and return\nif start==end:\n    path=[]\n    while end != None:\n        path.append(end)\n        end=predecessors.get(end,None)\n    return distances[start], path[::-1]\n# detect if it's the first time through, set current distance to zero\nif not visited: distances[start]=0\n# process neighbors as per algorithm, keep track of predecessors\nfor neighbor in graph[start]:\n    if neighbor not in visited:\n        neighbordist = distances.get(neighbor,sys.maxsize)\n        tentativedist = distances[start] + graph[start][neighbor]\n        if tentativedist < neighbordist:\n            distances[neighbor] = tentativedist\n            predecessors[neighbor]=start\n# neighbors processed, now mark the current node as visited\nvisited.append(start)\n# finds the closest unvisited node to the start\nunvisiteds = dict((k, distances.get(k,sys.maxsize)) for k in graph if k not in visited)\nclosestnode = min(unvisiteds, key=unvisiteds.get)\n# now we can take the closest node and recurse, making it current\nreturn shortestpath(graph,closestnode,end,visited,distances,predecessors)\n\nif __name__ == \"__main__\":\ngraph = {'Paris':       {               'Marseille': 773,   'Lyon': 464,    'Toulouse': 677,    'Nice': 930,    'Nantes': 383,  'Angers': 294,      'Strasbourg': 492},\n        'Marseille':    {'Paris': 773,                      'Lyon': 314,    'Toulouse': 403,    'Nice': 207,    'Nantes': 985,  'Angers': 905,      'Strasbourg': 802},\n        'Lyon':         {'Paris': 464,  'Marseille': 314,                   'Toulouse': 537,    'Nice': 471,    'Nantes': 685,  'Angers': 596,      'Strasbourg': 493},\n        'Toulouse':     {'Paris': 677,  'Marseille': 403,   'Lyon': 537,                        'Nice': 561,    'Nantes': 585,  'Angers': 642,      'Strasbourg': 969},\n        'Nice':         {'Paris': 930,  'Marseille': 207,   'Lyon': 471,    'Toulouse': 561,                    'Nantes': 1143, 'Angers': 1063,     'Strasbourg': 785},\n        'Nantes':       {'Paris': 383,  'Marseille': 985,   'Lyon': 685,    'Toulouse': 585,    'Nice': 1143,                   'Angers': 91,       'Strasbourg': 866},\n        'Angers':       {'Paris': 294,  'Marseille': 905,   'Lyon': 596,    'Toulouse': 642,    'Nice': 1063,   'Nantes': 91,                       'Strasbourg': 777},\n        'Strasbourg':   {'Paris': 492,  'Marseille': 802,   'Lyon': 493,    'Toulouse': 969,    'Nice': 785,    'Nantes': 866,  'Angers': 777}}\n```\n\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm: How to improve memory performance of my implementation\r\n                \r\nI have been struggling to improve the memory performance of this implementation of Dijkstra's algorithm. Do you have any tips on how to improve this while still using the same data structures and loops? \n\nI basically used an implementation from a Cornell Univ lecture:https://www.cs.cornell.edu/~wdtseng/icpc/notes/graph_part2.pdf\n\n```\n#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <limits.h>\n#include <utility> \n#include <list>\n#include <set>\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint graph[10000][10000];\n\nvoid dijkstra(int src_node, int num_nodes, int dist[], bool done[]) ;\n\nint main()\n{\nint num_nodes, num_edges;\ncin >> num_nodes >> num_edges;\n\nfor(int i = 1; i <= num_nodes; i++)\n{\n    int src, dest, weight;\n    cin >> src >> dest >> weight;\n\n    graph[src][dest] = weight;\n}\n\nint src_node = 1;\nint dist[num_nodes];\nbool done[num_nodes];\n\ndijkstra(src_node, num_nodes, dist,done);\n\nfor(int p = 2; p <= num_nodes; p++)\n{\n    cout << dist[p] << \" \" ;\n}\n\nreturn 0;\n}\n\nvoid dijkstra(int src_node, int num_nodes, int dist[], bool done[]) \n{\n// set all distances to infinity and set all visits to false\nfor( int i = 1; i <= num_nodes; i++ ) \n{\n    dist[i] = INT_MAX;\n    done[i] = false;\n}\n\ndist[src_node] = 0;\n\nwhile(true) \n{\n    // find the vertex with the smallest dist[] value\n    int cur_node = -1;\n    int bestDist = INT_MAX;\n\n    //\n    for( int i = 1; i <= num_nodes; i++ ) \n    {\n        if( !done[i] && dist[i] < bestDist ) \n        {\n            cur_node = i;\n            bestDist = dist[i];\n        }\n    }\n\n    // if the best distance is infinity, break out of the loop\n    if( bestDist == INT_MAX )\n    {\n        break;\n    }\n\n    // iterate through all the neighbors\n    for( int adj_node = 1; adj_node <= num_nodes; adj_node++ )\n    {\n        // if the adj node has not been visited and has a weight\n        if( !done[adj_node] && graph[cur_node][adj_node] != NULL ) \n        {\n            // if the distance of the adj node is greater\n            if( dist[adj_node] > dist[cur_node] + graph[cur_node][adj_node])\n            {\n                // make the dist = to curr node distance  + weight\n                dist[adj_node] = dist[cur_node] + graph[cur_node][adj_node];\n            }\n        }\n    }\n    // mark current node as done\n    done[cur_node] = true;\n}\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Maximum profit using Dijkstra Algorithm\r\n                \r\nDijkstra algorithm is one of the fastest algorithm for solving the shortest path problem. In my case network is made up of nodes where the weight of the edge is the profit that I get. I was wondering if I could reverse Dijkstra's algorithm to solve this problem, but I realized what if we run in a closed loop (because cost will increase more and more it will go on forever). I know how to solve it as an integer programing problem so I can verify the correctness of algorithm(and not correct unfortunately). Here is pseudo code for Dijkstra that I have been using. What is correct modification to be done?\n\n```\nln=∞ for all n∈N∖{s}, ls=0\n N′={s}, N′′=∅\n repeat\n     n=argminn′∈N′ln′ N′=N′∖{n}, N′′=N′′∪{n}\n     for all (n,m)∈A with m∈N∖N′′ do\n         if lm>ln+cn,m then\n               lm=ln+cn,m N′=N′∪{m}\n         end if \n     end for until (N′=∅ or t∈N′′)\n```\n\n    ", "Answer": "\r\nThis falls under the issue of the Longest Path Problem.  In other words, there is no efficient way to find max path (in your case, max profits) in an unweighted graph structure.  However, you mentioned that it was a weighted graph, so you might still be able to still do it efficiently if your graph is acyclic: \n\n\"A longest path between two given vertices s and t in a weighted graph G is the same thing as a shortest path in a graph −G derived from G by changing every weight to its negation. Therefore, if shortest paths can be found in −G, then longest paths can also be found in G. For most graphs, this transformation is not useful because it creates cycles of negative length in −G. But if G is a directed acyclic graph, then no negative cycles can be created, and longest paths in G can be found in linear time by applying a linear time algorithm for shortest paths in −G, which is also a directed acyclic graph.\" as seen in the wiki article.\n\nSo, if your graph is acyclic, you can indeed use an efficient algorithm to solve your problem. However, if your graph is not acyclic, then there is no known efficient algorithm.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Designing a mazebot with A*/Dijkstra's algorithm\r\n                \r\nProblem:\nI do not understand how to fully implement A* or Dijkstra's algorithm in a maze following robot. The robot is in a dynamically generated maze, and can only see ahead of itself (how far away an object in front of it is), and can move forward and backwards, and can rotate (\"tank drive\"). While only seeing forward, I cannot figure out how to accuratly judge the risk/value of the surrounding possibilities of movement.\nAditionally, I imagine storage might be a problem for memory of the board, but I will make another question for that after this one is answered.\nBackstory:\nI am mentoring a group of kids that is participating in FTC, and they are using block programming for their robot. I am challenging myself to understand and fully work with block programming in order to be able to help them to the fullest of my capability.\nThanks to anyone who can help, and have a great day;\n-Kai\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Issue regarding time complexity of Dijkstra's Algorithm\r\n                \r\nSo I tried writing Dijkstra's Algorithm for the following graph. I used Priority Queue so time complexity could be less than V^2 ( where 'V' is the total number of vertices)\n\nMy approach ->\n```\npublic static class Pair implements Comparator<Pair> {\n        int vertex;\n        int weight;\n\n        Pair(){}\n\n        Pair(int vertex,int weight){\n            this.vertex=vertex;\n            this.weight=weight;\n        }\n\n        @Override\n        public int compare(Pair pairOne, Pair pairTwo) {\n            return Integer.compare(pairOne.weight,pairTwo.weight);\n        }\n    }\n\npublic static void shortestPath(ArrayList<ArrayList<Pair>> adjList,int vertices,int source){\n        int count=0;\n        int[] distance=new int[vertices];\n        boolean[] spt=new boolean[vertices];\n        for(int i=0;i<vertices;i++){\n            distance[i]=Integer.MAX_VALUE;\n        }\n        distance[source]=0;\n        spt[source]=true;\n        PriorityQueue<Pair> ourPriorityQueue=new PriorityQueue<>(vertices,new Pair());\n        ourPriorityQueue.add(new Pair(source,distance[source]));\n\n        while(!ourPriorityQueue.isEmpty()){\n            Pair poppedElement=ourPriorityQueue.poll();\n            spt[poppedElement.vertex]=true;\n            count++;\n            for(Pair pair:adjList.get(poppedElement.vertex)){\n                if(!spt[pair.vertex] && distance[pair.vertex]>distance[poppedElement.vertex]+pair.weight){\n                    distance[pair.vertex]=distance[poppedElement.vertex]+pair.weight;\n                    ourPriorityQueue.add(new Pair(pair.vertex,distance[pair.vertex]));\n                }\n            }\n        }\n        for(int i=0;i<vertices;i++){\n            System.out.println(\"Distance of \" + i + \" from source is \" + distance[i]);\n        }\n        System.out.println(count);\n    }\n```\n\nThe one doubt I encountered was that my outer loop is running more than 'V' times as same vertices with different weights are being added more than once in the priority queue. Since the outer loop is running more than 'V' times. will the time complexity not become more than O(VLogV) ? Printing The count variable proves that the loop is running more than 'V' times\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Using Dijkstra's algorithm to find a path that can carry the most weight\r\n                \r\nI have a graph, with X nodes and Y edges. Weighted edges. The point is to start at one node, and stop at another node which is the last location. Now here comes the problem:\n\nVisualize the problem. The edges are roads, and the edge weights are the max weight limits for vehicles driving on the roads. We would like to drive the biggest truck possible from A to F. I want the largest maximum allowed weight for all paths from A to F.\n\nCan I use some sort of Dijkstra's algorithm for this problem? I'm not sure how to express this problem in the form of an algorithm that I can implement. Any help is much appreciated. I'm confused because Dijkstra's algorithm just only view on shortest path.\n    ", "Answer": "\r\nIf I understand correctly, you want to find the path between some nodes that has the maximum bottleneck edge.  That is, you want the path whose smallest edge is as large as possible.  If this is what you want to solve, then there is a very straightforward modification of Dijkstra's algorithm that can be used to solve the problem.\n\nThe idea behind the algorithm is to run Dijkstra's algorithm with a twist.  Normally, when running Dijkstra's algorithm, you keep track of the length of the shortest path to each node.  In the modified Dijkstra's algorithm, you instead store, for each node, the maximum possible value of a minimum-weight edge on any path that reaches the node.  In other words, normally in Dijkstra's algorithm you determine which edge to expand by finding the edge that maximizes the quantity\n\n\n  d(s, u) + l(u, v)\n\n\nWhere s is the start node, u is some node you've explored so far, and (u, v) is an edge.  In the modified Dijkstra's, you instead find the edge minimizing\n\n\n  min(bottleneck(s, u), l(u, v))\n\n\nThat is, you consider the bottleneck edge on the path from the source node to any node you've seen so far and consider what bottleneck path would be formed if you left that node and went some place else.  This is the best bottleneck path to the target node, and you can repeat this process.\n\nThis variant of Dijkstra's algorithm also runs in O(m + n log n) time using a good priority queue.  For more information, consider looking into these lecture slides that have a brief discussion of the algorithm.\n\nInterestingly, this is a well-known problem that's used as a subroutine in many algorithms.  For example, one of the early polynomial-time algorithms for solving the maximum flow problem uses this algorithm as a subroutine.  For details about how, check out these lecture notes.\n\nHope this helps!  And if I've misinterpreted your question, please let me know so I can delete/update this answer.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "alter Dijkstra's Algorithm to compute shortest second and third path between two nodes\r\n                \r\nhow to alter Dijkstra's Algorithm in link to calculate shortest second and third path between two nodes?\n    ", "Answer": "\r\nDijkstra’s shortest path algorithm is a greedy algorithm. This means that at any given point, Dijkstra has found the shortest path from its start up to the current vertex that it is at. Dijkstra’s shortest path algorithm has optimal substructure, because the optimal solution relies on the optimal solution of the subproblems.\n\nSay you are trying to find the shortest path from node A to node B. Dijkstra works by keeping track of the shortest path from A up to the current node that it is at, up until the algorithm completes the path to B. The algorithm does not keep track of the second or third best paths, as it is a greedy algorithm with optimal substructure. \n\nIf you want to find the second or third shortest path between A and B, you cannot just perform Dijkstra’s algorithm and rely on it only needing to make one different decision along the way. You may need to go through many, or even all, paths that connect A and B, to find the next shortest paths.\n\nIn a very large graph, we would need to keep track of many nodes and possible paths before finding the second or third shortest paths. Finding the nth shortest path does not follow the property of a greedy algorithm with optimal substructure. \n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm on a graph represented by adjacency list\r\n                \r\nI was implementing Dijkstra's algorithm on a weighted directed graph given by an adjacency list. While I get the distance being calculated correctly for nearly all vertices the very last vertex of the binary heap is causing some trouble. Another major issue is while I am making a node assign to an array of nodes the assignment isn't being executed, as when I printed the heap node values their distance were always INT_MAX. Please help me out!\n\n```\n#include <stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n\nlong long int m=0;\n\nlong long int parent(long long int i){\n    return i/2;\n} \nlong long int left(long long int i){\n    return (2*i);\n}\nlong long int right(long long int i){\n    return (2*i+1);\n}\n\ntypedef struct edge{\n    long long int src;\n    long long int dest;\n    long long int weight;\n}edge;\n\ntypedef struct vertex{\n    long long int id;\n    long long int d;\n    long long int pos;\n}node;\n\nvoid Decrease(node heap[],long long int i,node curr,node V[]){\n    if(curr.d>heap[i].d) return;\n    heap[i]=curr;\n    while(i>=1 && heap[parent(i)].d>heap[i].d){\n        V[i].pos=parent(i);\n        V[parent(i)].pos=i;\n        node temp=heap[parent(i)];\n        heap[parent(i)]=heap[i];\n        heap[i]=temp;\n        i=parent(i);\n    }\n}\n\nvoid heapify(node heap[],long long int i){\n    long long int l=left(i);\n    long long int r=right(i);\n    long long int lowest;\n    if(r<=m && heap[i].d<heap[r].d){\n        lowest=r;\n    }\n    else lowest=i;\n    if(l<=m && heap[l].d<heap[lowest].d){\n        lowest=l;\n    }\n\n    if(lowest!=i){\n        node temp=heap[lowest];\n        heap[lowest]=heap[i];\n        heap[i]=temp;\n    }\n}\n\nnode Extract(node heap[]){\n     node min=heap[1];\n     heap[1]=heap[m];\n     m=m-1;\n     heapify(heap,1);\n     return min;\n}\n\nvoid Insert(node heap[],node curr,node V[]){\n    m=m+1;  \n    heap[m].d=INT_MAX;\n    Decrease(heap,m,curr,V);\n}\n\nint main() {long long int N,S,D,C1,C2,D1,D2,W1,W2,W3,i,j;\n    scanf(\"%lld %lld %lld %lld %lld %lld %lld %lld %lld \n    %lld\",&N,&S,&D,&C1,&C2,&D1,&D2,&W1,&W2,&W3);\n    edge** adj;\n    adj=(edge**)malloc(sizeof(edge*)*N);\n\n    long long int* deg;\n    deg=(long long int*)malloc(sizeof(long long int)*(N+1));\n    deg[0]=0;\n\n    for(i=1;i<=N;i++){\n        deg[i]=(i*C2+i*i*D2)%(D);\n        adj[i]=(edge*)malloc(sizeof(edge)*(deg[i]+1));\n        for(j=1;j<=deg[i];j++){\n            edge temp;\n            temp.dest=(i*C1+j*D1)%(N);\n            temp.dest=temp.dest+1;\n            temp.weight=(i*W1+j*W2)%(W3);\n            temp.src=i;\n            adj[i][j]=temp;\n        }\n    }\n\n    node* V;\n    V=(node*)malloc(sizeof(node)*(N+1));\n    for(i=0;i<=N;i++){\n        V[i].d=INT_MAX;\n        V[i].id=i;\n    }\n    V[S].d=0;\n\n    node* heap;\n    heap=(node*)malloc(sizeof(node)*(N));\n\n    for(i=1;i<=N;i++){\n        Insert(heap,V[i],V);\n    }\n\n    while(m>-1){\n        node temp=Extract(heap);\n        int i=temp.id;\n        for(j=1;j<=deg[i];j++){\n            edge w=adj[i][j];\n            if(V[w.dest].d>V[i].d+w.weight){\n                V[w.dest].d=V[i].d+w.weight;\n                Decrease(heap,V[w.dest].pos,V[w.dest],V);\n            }\n        }\n        /*for(long long int z=1;z<=m;z++){\n           printf(\"%lld %lld   \",heap[z].id,heap[z].d);\n        }*/\n    }\n    /*for(i=1;i<=N;i++){\n        printf(\"%lld %lld\\n\",V[i].id,V[i].d);\n    }*/\n    return 0;\n```\n\n\n}\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Why doesn't Dijkstra's algorithm work as it should for given graph?\r\n                \r\nI have the following code, Dijkstra's algorithm, that I made using Wikipedia's article on the algorithm.\n\nFor the given graph (see image) and starting node (1), it returns 5 as distance to node (4), which is obviously false. However, when going from node (4), it returns 4 as distance to (1), which is correct. What is wrong in my code?\n\n\n\n```\n//source = starting point, adj[] = adjacency list\nprivate static int dijkstra (int source, ArrayList<Road>[] adj) {\n    HashSet<Integer> vertices = new HashSet<>();\n\n    int[] dist = new int[adj.length];\n    int[] prev = new int[adj.length];\n\n    for (int i = 0; i < adj.length; i++) {\n        dist[i] = Integer.MAX_VALUE;\n        prev[i] = Integer.MAX_VALUE;\n        vertices.add(i);\n    }\n\n    dist[source] = 0;\n\n    while (!vertices.isEmpty()) {\n        int current = Integer.MAX_VALUE;\n        for (int v: vertices) {\n            if (dist[v] < current) {\n                current = v;\n            }\n        }\n        vertices.remove(current);\n\n        for (Road v: adj[current]) {\n            int alt = dist[current] + v.distance;\n\n            if (alt < dist[v.end]) {\n                dist[v.end] = alt;\n                prev[v.end] = current;\n            }\n        }\n    }\n}\n\nclass Road {\n    int end;\n    int distance;\n}\n\n//This loop builds adjacency list from input such as \"1 3 2\", where 1 represents\n// starting node, 3 represents end node and 2 represents weight of that edge.\n//start and end values are decremented in order to be 0-indexed\n\nfor (int i = 0; i < M; i++) {\n    int start = in.nextInt() - 1;\n    int end = in.nextInt() - 1 ;\n    int dist = in.nextInt();\n\n    adj[start].add(new Road(end, dist));\n    adj[end].add(new Road(start, dist));\n}\n```\n\n    ", "Answer": "\r\nThis piece of code is causing the error:\n\n```\nint current = Integer.MAX_VALUE;\nfor (int v: vertices) {\n    if (dist[v] < current) {\n        current = v;\n    }\n}\n```\n\n\nI assume it's supposed to search the unvisited node that has the shortest path from the start-vertex. But this should look rather like this:\n\n```\nint currentPathLen = Integer.MAX_VALUE, current = -1;\nfor (int v: vertices) {\n    if (dist[v] < currentPathLen) {\n        current = v;\n        currentPathLen = dist[current];\n    }\n}\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "dijkstra's algorithm in time O(k|V|+|E|)\r\n                \r\nI have to calculate the minimum distance from a source node 's' for undirected and connected graphs G = (V, E) with weights on the arcs belonging to the set { 1, 2, . . . , K }, where k is a fixed integer . Implement Dijkstra's algorithm taking advantage of the peculiarity of these graphs so that the minimum distances to be calculated in O ( k | V | + | E |). I've no idea how to solve this problem....so i don't need the specific code , but I need an algorithmic idea.\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra algorithm React Native\r\n                \r\nI developed a react native application that implements dijkstra algorithm using Graphs, i want to now if is possible build dijkstra algorithm using matrix in React Native.\nThank you guys.\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Java Index out of bounds exception with dijkstra's algorithm\r\n                \r\nI keep getting this index out of bounds exception (at line 7 in code snippet) where I thought I clearly restrict the code from reaching out of bounds. If someone catches the flaw point it out please. (Note array is 2-dimmentional Object[36][25]). If needed I can post the rest of my implementation of dijkstra's algorithm, but this is where I believe the error is. All help is greatly appreciated.\n\n```\n    public void setNeighbors(Node N)    //adds neighbors to openNode and closedNode lists. if added to openNode calculate parent\n{\n    if(N.getX() < 36)   //keeps from checking out of bounds (Note isTilePassable() works properly)\n    {\n        if(!isTilePassable(nodeGrid[N.getX()+1][N.getY()].getX() * 32, nodeGrid[N.getX()+1][N.getY()].getY() * 32)) //east\n            closedNode.add(nodeGrid[N.getX()+1][N.getY()]);\n    }\n\n    if(N.getY() < 25)\n    {\n        if(!isTilePassable(nodeGrid[N.getX()][N.getY()+1].getX() * 32, nodeGrid[N.getX()][N.getY()+1].getY() * 32)) //south\n            closedNode.add(nodeGrid[N.getX()][N.getY()+1]);\n    }\n\n    if(N.getX() > 0)\n    {\n        if(!isTilePassable(nodeGrid[N.getX()-1][N.getY()].getX() * 32, nodeGrid[N.getX()-1][N.getY()].getY() * 32)) //west\n            closedNode.add(nodeGrid[N.getX()-1][N.getY()]);\n    }\n\n    if(N.getY() > 0)\n    {\n        if(!isTilePassable(nodeGrid[N.getX()][N.getY()-1].getX() * 32, nodeGrid[N.getX()][N.getY()-1].getY() * 32)) //north\n            closedNode.add(nodeGrid[N.getX()][N.getY()-1]);\n    }\n\n    boolean add;\n\n    if(N.getX() < 36)\n    {\n        add = true;\n        for(Node e : closedNode)\n        {\n            if(e.equals(nodeGrid[N.getX()+1][N.getY()]))\n                add = false;\n        }\n        for(Node e : openNode)\n        {\n            if(e.equals(nodeGrid[N.getX()+1][N.getY()]))\n                add = false;\n        }\n        if(add)\n        {\n            openNode.add(nodeGrid[N.getX()+1][N.getY()]);\n            openNode.get(openNode.size() - 1).setParent(N);\n        }\n    }\n\n    if(N.getY() < 25)\n    {\n        add = true;\n        for(Node e : closedNode)\n        {\n            if(e.equals(nodeGrid[N.getX()][N.getY()+1]))\n                add = false;\n        }\n        for(Node e : openNode)\n        {\n            if(e.equals(nodeGrid[N.getX()][N.getY()+1]))\n                add = false;\n        }\n        if(add)\n        {\n            openNode.add(nodeGrid[N.getX()][N.getY()+1]);\n            openNode.get(openNode.size() - 1).setParent(N);\n        }\n    }\n\n    if(N.getX() > 0)\n    {\n        add = true;\n        for(Node e : closedNode)\n        {\n            if(e.equals(nodeGrid[N.getX()-1][N.getY()]))\n                add = false;    \n        }\n        for(Node e : openNode)\n        {\n            if(e.equals(nodeGrid[N.getX()-1][N.getY()]))\n                add = false;    \n        }\n        if(add)\n        {\n            openNode.add(nodeGrid[N.getX()-1][N.getY()]);\n            openNode.get(openNode.size() - 1).setParent(N);\n        }\n    }\n\n    if(N.getY() > 0)\n    {\n        add = true;\n        for(Node e : closedNode)\n        {\n            if(e.equals(nodeGrid[N.getX()][N.getY()-1]))\n                add = false;\n        }\n        for(Node e : openNode)\n        {\n            if(e.equals(nodeGrid[N.getX()][N.getY()-1]))\n                add = false;\n        }\n        if(add)\n        {\n            openNode.add(nodeGrid[N.getX()][N.getY()-1]);\n            openNode.get(openNode.size() - 1).setParent(N);\n        }\n    }\n```\n\n    ", "Answer": "\r\nThat is not strange - arrays in java start at 0 - so an array of size 36 will go from index 0 to index 35. Trying to get index 36 will be getting the object's 37th item, which does not exist.\n\n```\nif(N.getX() < 36)\n```\n\n\nIn above line, x may be 35 (the max index) - and it will then try to get ```\nN.getX()+1```\n=36 which is out of bounds. Same goes for the Y later on.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm for doubly linked skip list?\r\n                \r\nSo I am having trouble implementing Dijkstra's for my specific program. Here is the current structure I am using as my \"nodes\":\n\n```\nstruct Ladders{\n    LONG x1;\n    LONG y1;\n    LONG y2;\n    struct Platforms *top;\n    struct Platforms *bottom;\n};\n\nstruct JumpPath{\n    double jumpCost;\n    int direction;\n    bool leftEdge;\n    struct Platforms *jumpStart;\n    struct Platforms *jumpEnd;\n};\n\nstruct Platforms{\n    LONG x1;\n    LONG y1;\n    LONG x2;\n    LONG y2;\n    int index;\n    int platNode;\n    int id;\n    struct Platforms *prev;\n    struct Platforms *next;\n    struct Ladders *rope;\n    std::vector<JumpPath*> jump;\n};\nstd::vector<Platforms*>P;\n```\n\n\nSo P is holding all of my platform data in the form of nodes. Each node contains platforms that are connected at the vertices. So in essence, just a doubly linked list. The jump paths and ladders represent a skip to another node, making this a doubly linked skip list. All in all, I am trying to figure out the best way to implement dijkstra's algorithm for my program because I need to save the path as well. The below image is the visualization of the platform data that I am saving into nodes: \n\n\nHow can I record the path the algorithm would take and should I use another vector to do this? I was also thinking of creating another struct called Edges and keeping all the information like whether it's a jump, cost, and vertices it came from and is going to. The only problem is, I wouldn't know how I would keep track of them in the order of the path. \n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "dijkstra's algorithm using matrix in c++. what's wrong in this code?\r\n                \r\n```\n#include <iostream>\n\n\n\nint n, m, v1, v2, weight;\n\ncin >> n >> m;\nint** graph = new int*[n];\nint* distance = new int[n];\nint* s = new int[n];\n\nfor (int i = 0; i < n; ++i)\n    graph[i] = new int[n];\n\nfor (int i = 0; i < n; ++i)\n    for (int j = 0; j < n; ++j)\n        graph[i][j] = INT_MAX;\n\nfor (int i = 0; i < m; ++i)\n{\n    cin >> v1 >> v2 >> weight;\n    graph[v1][v2] = weight;\n    graph[v2][v1] = weight;\n}\n\nfor (int i = 0; i < n; ++i)\n    distance[i] = INT_MAX;\n\n\nfor (int i = 0; i < n; ++i)\n    distance[i] = graph[0][i];\n\nfor (int i = 0; i < n; ++i)\n    s[i] = 0;\n\ndistance[0] = 0;\n\nint min = INT_MAX;\nint vertex = 0;\n\nfor (int j = 0; j < n-1; ++j){\n    min = INT_MAX;\n\n    for (int i = 0; i < n; ++i)\n        if (s[i] == 0 && min >= distance[i])\n        {\n            vertex = i;\n            min = distance[i];\n        }\n\n    s[vertex] = 1;\n    cout << vertex << \" \";\n    for (int i = 0; i < n; ++i)\n        if (distance[i]>distance[vertex] + graph[vertex][i])\n            distance[i] = distance[vertex] + graph[vertex][i];\n\n\n\n}\nfor (int i = 0; i < n; ++i)\n    cout << distance[i] << \" \";\n\ncout << endl;\n\n    return 0;\n```\n\n\n}\n\nHi. I'm making Dijkstra's algorithm using two-dimentional matrix..\nbut this code doesn't work. and i don't know why!  Can you fix my problem??\ni want to make output all distance of graph. but output is looks like array point garbage value like -2345...\nCan you help me??\n    ", "Answer": "\r\nThere are some problems in this loop:\n\n```\nfor (int i = 0; i < n; ++i)\n        if (distance[i]>distance[vertex] + graph[vertex][i])\n            distance[i] = distance[vertex] + graph[vertex][i];\n```\n\n\nshould change to the blew code:\n\n```\nfor (int i = 0; i < n; ++i)\n        if (s[i] == 0 && graph[vertex][i] != INT_MAX && distance[i]>distance[vertex] + graph[vertex][i])\n            distance[i] = distance[vertex] + graph[vertex][i];\n```\n\n\nbecause if the ```\ngraph[vertex][i] == INT_MAX```\n, the sum of ```\ndistance[vertex] + graph[vertex][i]```\n is overflow. Another problem is that the vertex i should not be marked before.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Does Dijkstra's algorithm not modify the distance of a marked vertex?\r\n                \r\nI recall reading that once Dijkstra's algorithm marks a node as visited, it does not update its distance again. Consider the following graph:\n\n```\nA-3-B-7-F\n|       |\n8     -3\n|    /\nC-3-E\n```\n\n\nThe algorithm would visit A → B → C, and E and F would be queued. But F will be picked first, since it has a smaller distance. Then E would be picked and a shorter distance to F will be found. In this case, shouldn't F's distance be modified even though it is already marked?\n    ", "Answer": "\r\nYour graph has a negative edge weight, -3.\n\nDijkstra's algorithm does not work when there are negative edge weights. The graph you give in your question is a sufficient example to demonstrate this fact.\n\nFrom Wikipedia:\n\n\n  Unlike Dijkstra's algorithm, the Bellman–Ford algorithm can be used on graphs with negative edge weights, as long as the graph contains no negative cycle reachable from the source vertex s.\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Does dijkstras algorithm relax the edges of the shortest path in order?\r\n                \r\nIn \"Introduction to algorithms, 3rd edition\" exercise 24.3-5 wants an example that this is wrong (not always true). Is that possible? In my mind this is impossible because every edge is relaxed at a time when the path to the current vertice is already decided.\n\nWord for word:\n\n\n  Professor N. claims to have a proof of correctness of Dijkstra's algorithm. He claims that Dijkstra's algorithm relaxes the edges of every shortest path in the graph in the order in which they appear on the path, and therefore the path-relaxation property applies to every vertex reachable from the source. Show the professor is mistaken by constructing a directed graph for which Dijkstra's algorithm could relax the edges of a shortest path out of order.\n\n    ", "Answer": "\r\nConsider the following directed graph :(A,B),(A,C),(B,D),(C,D), (D,E)with edge weights w(A,B)=1,w(A,C)=1,w(B,D)=0,w(C,D)=0, w(D,E)=1.The source vertex is A. A possible permutation of edges relaxed in the Dijkstra’s algorithm is (A,B), (A,C), (B,D), (D,E), (C,D). Besides, A.d=0, B.d=1, C.d=1, D.d=1, E.d=2 after performing the Dijkstra’s algorithm. There are two shortest paths from A to E, one is ABDE, and the other is ACDE. The contradiction is to the second path, edge (C,D) should be always relaxed before (D,E).\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm in Java for matrix with obstacles [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI'm trying to implement Dijkstra's algorithm in order to find the shortest path between 2 points in a grid (x,y) but the problem is that I can only move up, down, right and left. \n\nI have an ArrayList containing the x and ys of the points I need to pass on and another ArrayList of the points that are obstacles on the grid, I'm trying to write a function that returns an ArrayList of the movement needed in order to finish all the path.\n\nIn example: 1,1,1,2,3,4,1.. 1 being right 2 being left and 3 being up and finally 4 being down.\n\nCan you please provide me with some hints and/or examples.\n    ", "Answer": "\r\nFirst off, know that Dijkstra's algorithm is for weighted graphs traditionally. It could still work with unit edges (all weight 1) but it may not be your most efficient solution.\n\nEither way, whichever algorithm you use, you will need to treat your grid as a graph. To do this, make a set of edges. If there are no restrictions beyond \"no diagonals\" then your edges will be the connection between each point and its neighbors above, below, and next to it. You can then operate on the graph by iterating over the edges and points on the graph. \n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How does Dijkstra's Algorithm work if a max priority queue is used?\r\n                \r\nI was recently looking at some code for Dijkstra's algorithm. The goal of the code was to find the minimum cost path from vertex 1 to vertex N. I came across this working code when looking at the solution to the problem:\n\n```\nvoid dijkstra(int start, int n) {\n    for(int i = 0; i<n; i++) {\n        dist[i] = INF;\n        pred[i] = -1;\n    }\n    dist[start] = 0;  \n    priority_queue<ll> q;\n    q.push(0);\n    int u = 0;\n    while(q.size()) {\n        u = q.top();\n        q.pop();\n        for(int end : adj[u]) {\n            ll w = weight.at(mp(u, end));\n            if(dist[u] + w < dist[end]) {\n                dist[end] = dist[u] + w;\n                pred[end] = u;\n                q.push(end);\n            }\n        } \n    }\n}\n```\n\n\nThis program uses a priority queue in order to determine which vertices to traverse to next (starting from vertex 1). However, the priority queue implemented in this algorithm is the standard C++ Priority Queue which is a Max Priority Queue. This means that the largest elements have the highest priority. However, I thought that in Dijkstra's algorithm, we wanted to poll the smallest vertices first? I am unsure how using a Max Priority Queue works for this algorithm.  \n    ", "Answer": "\r\nEverything that you have mentioned is right. But, be careful! ```\nu```\n is the index of neighbors in this algorithm. And, if neighbors with a higher index have a smaller distance, it will work correctly.\n\nMoreover, you should notice that the priority queue can be implemented such that the top element will be the smallest value using ```\nstd::greater<T>```\n.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm: How do you choose the edge source and destination\r\n                \r\nI was reading Dijkstra's shortest path algorithm in Java\n\nI implemented my own version of Dijkstra's algorithm. I can post it if necessary.\n\nMy question is, does it matter how you define an edge? Is the order of the start and end nodes significant?\n\nFor example\n\n```\naddLane(\"Edge_0\", 0, 1, 85);\naddLane(\"Edge_1\", 0, 2, 217);\naddLane(\"Edge_2\", 0, 4, 173);\naddLane(\"Edge_3\", 2, 6, 186);\naddLane(\"Edge_4\", 2, 7, 103);\naddLane(\"Edge_5\", 3, 7, 183);\naddLane(\"Edge_6\", 5, 8, 250);\naddLane(\"Edge_7\", 8, 9, 84);\naddLane(\"Edge_8\", 7, 9, 167);\naddLane(\"Edge_9\", 4, 9, 502);\naddLane(\"Edge_10\", 9, 10, 40);\naddLane(\"Edge_11\", 1, 10, 600);\n```\n\n\nWhat if I changed the last line to:\n\n```\naddLane(\"Edge_11\", 10, 1, 600);\n```\n\n\n2nd 3rd and 4th argument is the node_source, node_end, and distance?\n\nIn my implementation I had to change the order around for one edge to get it to work? Is that a problem with my algorithm? \n    ", "Answer": "\r\nThere's no predefined rule.\n\nIt's either part of the statement/documentation or the graph can be bidirectional (you can go both from a to b and b to a on the same edge).\nIt usually clear from the context.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Shortest path algorithm using Dijkstra's Algorithm in C++\r\n                \r\nI'm trying to implement Dijkstra's algorithm to find the shortest path from a starting node to the last node of a 250px by 200px raw image file (e.g. starting node = [0][0], ending node = [250][200]). The raw file acts like a topographical map in that each byte represents an elevation and the distance cost from one node to its adjacent node(s) is the difference in elevations of the two nodes plus 1 for the energy to move from one node to its neighbor (movement can only happen horizontally and vertically). \n\nI have followed the pseudocode for the algorithm using a priority queue in C++, but am struggling to debug to see if I have successfully implemented the algorithm correctly as well as implementing the algorithm to accomplish this unique and relatively challenging situation. Also, my goal is to output the shortest path in a raw file and then view it in Photoshop to see if it is being displayed correctly, but have failed completely at this task.\n\nAfter all that, my question is...\n1. Are there any visible/blaring logical errors in my implementation of solving the above described problem?\n2. Could anyone suggest some ideas on how to try to output the shortest path in a raw file or something along similar lines?\n\nThank you for your help.\n\np.s. I know I've used file read and write operations with the C notation rather than the stream operations of C++ so there's no need of telling me how I can change that.\n\n```\n#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <queue>\n\n#define INFINITY 99999\n#define MAP_SIZE 50000  // 250px by 200px\n\n\nvoid dijkstra(int, int, unsigned int []);\n\n// The terminology 'Node' and 'Vertex' are used interchangeably\n// throughout the program.\nstruct Node\n{\n    int index;              // index of node in graph\n    unsigned int distance;  // distance from source (only allow positive distances)\n};\n\n// A simple class to compare the distances of two Node structures.\nclass CompareDist\n{\npublic:\n    bool operator()(Node& n1, Node& n2)\n    {\n        if (n1.distance < n2.distance)\n            return true;\n        else\n            return false;\n    }\n};\n\n\nint main()\n{\n    FILE *fr = fopen(\"map.raw\",\"rb\");\n    FILE *fw1 = fopen(\"path.raw\",\"w+\");\n\n    int i;\n    unsigned char read[MAP_SIZE];\n    unsigned int original[MAP_SIZE];    //2D array implemented in 1D array\n    unsigned char path[MAP_SIZE];\n\n\n    if(!fr){\n        std::cout<<\"Error: Can't open raw file!\"<<std::endl;\n        return 0;\n    }\n    fread(read, sizeof(char), MAP_SIZE, fr);\n    fclose(fr);\n\n    //convert to int for calculation\n    for (i = 0; i < MAP_SIZE; i++) {\n        original[i] = (int)((unsigned short)read[i]);\n    }\n\n\n    dijkstra(0, MAP_SIZE, original);\n\n\n    for (i = 0; i < MAP_SIZE; i++) {\n        path[i] = (unsigned char)original[i]; // output path array\n    }\n\n    fwrite(&path,sizeof(char),MAP_SIZE,fw1);\n\n    fclose(fw1);\n\n\n    return 0;\n}\n\n// Implementation of dijkstra's algorithm using a priority queue\n// Inputs: int s --> source node\n//         int size --> the total number of vertices in graph\n//         unsigned int graph[] --> your graph\n// Outputs: nothing\nvoid dijkstra(int source, int size, unsigned int graph[MAP_SIZE])\n{\n    bool *visited = new bool [size];                    // array to check which vertices have already been visited\n    unsigned int *distance = new unsigned int [size];   // table to hold the distances of each vertex from the source vertex\n\n    // initialize the distance of each node to infinity and visited as false\n    for (int i = 0; i < size; i++)\n    {\n        distance[i] = INFINITY;\n        visited[i] = false;\n    }\n\n    // the distance of the source to itself is obviously 0\n    distance[source] = 0;\n\n    // create priority queue structure\n    std::priority_queue< Node, std::vector< Node >, CompareDist> priorityQ;\n\n    // Create the first node as the source and put it into the queue\n    Node first = { source, 0 };\n    priorityQ.push(first);\n\n    // Pick the top node of priority queue.\n    // Update the queue with next visited vertex after checking\n    // which non-visited vertex has the minimum distance from\n    // the source vertex.\n    while(!priorityQ.empty())\n    {\n        Node tempNode = priorityQ.top();\n        priorityQ.pop();\n        int nodeIndex = tempNode.index;\n\n        visited[nodeIndex] = true;\n        for(int i = 0;i < size; i++)\n        {\n            if(graph[i] != 0 && !visited[i])\n            {\n                // Update the distance if it is smaller than the current distance\n                int tempDist = distance[nodeIndex] + graph[i] + 1;\n                if(distance[i] > tempDist)\n                {\n                    distance[i] = tempDist;\n                    Node newNode;\n                    newNode.index = i;\n                    newNode.distance = distance[i];\n                    priorityQ.push(newNode);\n                }\n            }\n        }\n    }\n\n    // DEBUG TEST FOR CORRECT OUTPUT\n    std::cout << \"The shortest distance from \" << source << \" to all other nodes is\" << std::endl;\n    for(int i = 0; i < size; i++)\n    {\n        std::cout << i << \" : \" << distance[i] << std::endl;\n        graph[i] = distance [i];\n    }\n    std::cout << std::endl << std::endl;\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm in Java - Multiple requests/threads\r\n                \r\nI am trying to implement Dijkstra’s algorithm in Java REST webservice, I used  this link for my help.\n\nIn this link, it is creating only one graph and calculating one route successfully. But in my program, I am creating multiple graphs and using different variables as cost for each graph. Then I use ExecutorService (total threads = total number of graphs) to find all paths in parallel. My program is working fine when I call it to test paths.\n\nThe problem is, when this algorithm receives multiple requests at the same time, it is returning “Unreached” message in printPath() function for some requests, and returning correct paths for other requests successfully. I tested each path one by one, and it is returning correct path each time without any error. Problem occurs only when webservice receives multiple requests at the same time. Below is my code, I only posted classes structure which I am using, rest of the code is same as in above mentioned link.\n\nThis is how I am using ExecutorService to find path:\n\n```\nList<RouteFutureResult> rfutureResult = new ArrayList();\n    executorService = Executors.newFixedThreadPool(graphs.size());//number of threads is equal to number of graphs\n    for (final Graph g : graphs) {\n        CalcRoutes calcRoutes = new CalcRoutes(g, other_parameters);\n        Future<String> submit = executorService.submit(calcRoutes);\n        rfutureResult.add(new RouteFutureResult(submit));\n    }\n    executorService.shutdown();\n    executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.MINUTES);\n    //reading response from future object\n    List<String> st = new ArrayList();\n    for (RouteFutureResult resQuery : rfutureResult) {\n        String path = resQuery.getFuture().get();\n        st.add(path);\n    }\n```\n\n\nThis is my CalcRoutes.java call function:\n\n```\n@Override\npublic String call() throws Exception {\n    List<Double> djst = new ArrayList();\n    g.dijkstra(s);\n    List<Double> st = g.printPath(d, djst);\n    //other processing and returning results\n}\n```\n\n\nHere is the Graph class which I used from mentioned link:\n\n```\n    class Graph {\n    private final Map<Double, Vertex> graph;\n    public class Edge {\n        public final double v1, v2;\n        public final double dist;\n    }\n    public class Vertex implements Comparable<Vertex> {\n        public final double name;\n        double gid;\n        public double dist = Double.MAX_VALUE;\n        public Vertex previous = null;\n        public final Map<Vertex, Double> neighbours = new HashMap<>();\n        private void printPath(List<Double> st) {\n            if (this == this.previous) {\n                st.add(this.name);\n            } else if (this.previous == null) {\n                System.out.printf(\"%s(unreached)\", this.name);//this is where I am getting a problem when service receives multiple requests at same time\n            } else {\n                this.previous.printPath(st);\n                st.add(this.name);\n            }\n        }\n    }\n    public Graph(HashMap<Double, RouteResult> edges) {\n    }\n    public void dijkstra(double startName) {\n        if (!graph.containsKey(startName)) {\n            System.err.printf(\"Graph doesn't contain start vertex \\\"%s\\\"\\n\", startName);\n            return;\n        }\n        final Vertex source = graph.get(startName);\n        NavigableSet<Vertex> q = new TreeSet<>();\n        for (Vertex v : graph.values()) {\n            v.previous = v == source ? source : null;\n            v.dist = v == source ? 0 : Double.MAX_VALUE;\n            q.add(v);\n        }\n        dijkstra(q);\n    }\n    private void dijkstra(final NavigableSet<Vertex> q) {\n        Vertex u, v;\n        while (!q.isEmpty()) {\n        }\n    }\n    public List<Double> printPath(double endName, List<Double> st) {\n        if (!graph.containsKey(endName)) {\n            System.err.printf(\"Graph doesn't contain end vertex \\\"%s\\\"\\n\", endName);\n        }\n        graph.get(endName).printPath(st);\n        return st;\n    }\n}\n```\n\n\nThis is how I am creating multiple graphs:\n\n```\nGraph cost = new Graph(MRoute); //MRoute is the hashmap\ngraphs.add(cost);//graphs is a list containing multiple graphs\n```\n\n\nI also checked already posted questions about Dijkstra's algorithm, but I couldn't find any relevant question to my problem. Somehow, this algorithm is unable to handle multiple requests, please guide me, any help would be highly appreciated.\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Implementing Dijkstra's algorithm with C++ STL\r\n                \r\nI have implemented the Dijkstra's algorithm as follows\n\n```\n#include <iostream>\n#include <bits/stdc++.h>\n#include<cstdio>\n#define ll long long int\n#define mod 1000000007\n#define pi 3.141592653589793\n#define f first\n#define s second\n#define pb push_back\n#define pf push_front\n#define pob pop_back\n#define pof pop_front\n#define vfor(e, a) for (vector<ll> :: iterator e = a.begin(); e != a.end(); e++)\n#define vfind(a, e) find(a.begin(), a.end(), e)\n#define forr(i, n) for (ll i = 0; i < n; i++)\n#define rfor(i, n) for (ll i = n - 1; i >= 0; i--)\n#define fors(i, b, e, steps) for(ll i = b; i < e; i += steps)\n#define rfors(i, e, b, steps) for(ll i = e; i > b; i -= steps)\n#define mp make_pair\nusing namespace std;\n\n\nvoid up(pair<ll, ll> a[], ll n, ll i, ll indArray[]) {\n    ll ind = (i - 1) / 2;\n    while (ind >= 0 && a[ind].s > a[i].s) {\n        swap(a[ind], a[i]);\n\n        indArray[a[ind].f] = ind;\n        indArray[a[i].f] = i;\n\n        i = ind;\n        ind = (i - 1) / 2;\n    }\n}\n\nvoid down(pair<ll, ll> a[], ll n, ll i, ll indArray[]) {\n    ll left = 2 * i + 1;\n    ll right = 2 * i + 2;\n    ll m = a[i].s;\n    ll ind = i;\n\n    if (left < n && a[left].s < m) {\n        ind = left;\n        m = a[left].s;\n    }\n\n    if (right < n && a[right].s < m) {\n        ind = right;\n    }\n\n    if (ind != i) {\n        swap(a[i], a[ind]);\n        indArray[a[i].f] = i;\n        indArray[a[ind].f] = ind;\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n//    cout << setprecision(10);\n\n\n    ll n, m;\n    cin >> n >> m;\n    vector<pair<ll, ll>> a[n];\n    forr(i, m) {\n        ll u, v, w;\n        cin >> u >> v >> w;\n        a[u].pb(mp(v, w));\n        a[v].pb(mp(u, w));\n\n    }\n\n    ll parent[n];\n    parent[0] = -1;\n\n    pair<ll, ll> dist[n];\n    forr(i, n) {\n        dist[i] = mp(i, INT_MAX);\n    }\n    dist[0].s = 0;\n\n    ll ind[n];\n    iota(ind, ind + n, 0);\n\n    ll ans[n];\n    ans[0] = 0;\n\n    bool visited[n];\n    fill(visited, visited + n, false);\n\n    ll size = n;\n    forr(i, n) {\n        ll u = dist[0].f;\n        visited[u] = true;\n        ll d1 = dist[0].s;\n        ans[u] = dist[0].s;\n        swap(dist[0], dist[size - 1]);\n        size--;\n        down(dist, size, 0, ind);\n\n        for (auto e : a[u]) {\n            if (visited[e.f]){\n                continue;\n            }\n\n            ll v = e.f;\n            ll j = ind[v];\n            if (dist[j].s > d1 + e.s) {\n                dist[j].s = d1 + e.s;\n                up(dist, size, j, ind);\n                parent[v] = u;\n            }\n        }\n    }\n\n    stack<ll> st;\n    forr(i, n) {\n        ll j = i;\n        while (j != -1) {\n            st.push(j);\n            j = parent[j];\n        }\n\n        while (!st.empty()) {\n            cout << st.top() << \"->\";\n            st.pop();\n        }\n        cout << \"   Path length is \" << ans[i];\n        cout << '\\n';\n    }\n}\n```\n\n\nThis implementation is correct and giving correct output.\n\nAs it can be seen every time I select the node with lowest key value(distance from source) and then I update the keys on all the adjacent nodes of the selected node. After updating the keys of the adjacent nodes I am calling the 'up' function as to maintain the min heap properties. But priority queue is present in the c++ stl. How can I use them to avoid the functions up and down.\n\nThe thing is I need to be able to find the index of the node-key pair in the mean heap whose key needs to be updated. Here in this code I have used a seperate ind array which is updated every time the min heap is updated.\nBut how to make use of c++ stl\n    ", "Answer": "\r\nLike you implied, we cannot random-access efficiently with ```\nstd::priority_queue```\n. For this case I would suggest that you use ```\nstd::set```\n. It is not actually a heap but a balanced binary search tree. However it works the desired way you wanted. ```\nfind```\n, ```\ninsert```\n and ```\nerase```\n methods are all ```\nO(log n)```\n so you can insert/erase/update a value with desired time since update can be done with erase-then-insert. And accessing minimum is ```\nO(1)```\n.\n\nYou may refer to this reference implementation like the exact way I mentioned. With your adjacency list, the time complexity is ```\nO(E log V)```\n where E is number of edges, V is number of vertices.\n\nAnd please note that\n\n\nWith default comparator, ```\nstd::set::begin()```\n method returns the min element if non-empty\nIn this code, it puts the distance as first and index as second. By doing so, the set elements are sorted with distance in ascending order\n\n\n% I did not look into the implementation of ```\nup```\n and ```\ndown```\n of your code in detail.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Complexity of Dijkstra's Algorithm for Heap Implementation\r\n                \r\nIn CRLS' book, the analysis of Dijkstra's algorithm is as follows:\n\nHow many times do you need to use the heap? One time for pulling off each node from the heap (i.e. Extract-Min in CRLS's book) --- O(N); and also every time when looking at the edge ---- O(E), you might need to change the distance (i.e., Decrease-Key in CRLS' book), which means to fix the heap order. And each heap operation needs O(logN) work. \n\nThus, total time complexity: O((N + E)logN), which is O(ElogN) if all vertices are reachable from the source.\n\nMy Question is:\nWhy the complexity becomes O(ElogN) if all vertices are reachable from the source? Why can we ignore the O(NlogN) part from O((N + E)logN)?\n    ", "Answer": "\r\nIf all vertices are reachable from the source, then there are at least ```\nN-1```\n edges in graph, therefore ```\nE >= N-1```\n, ```\nN = O(E)```\n and ```\nO((N + E) log N) = O((E + E) log N) = O(E log N)```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "priority queue for dijkstra algorithm [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nHow does priority queue works ? \nI started to study Dijkstra's algorithm, googled it and got a lot of code where different coders used different versions of priority queues. \nIn one code I have noticed that he uses this declaration \n\n```\npriority_queue <pii, vector <pii>, comp> Q;\n//pii means pair <int,int>\n// And comp is compare structure  which I also cannot understand \n```\n\n\nComp goes like this \n\n```\nstruct comp {\n  bool operator() (const pii &a, const pii &b) {\n    return a.second > b.second;\n  }\n};\n```\n\n\nCan anyone please explain me what is going on here? Also how many versions of ```\npriority_queue```\n declarations are there in c++?\n    ", "Answer": "\r\nThe C++ priority queue is:\n\n```\ntemplate <class T, class Container = vector<T>,\n  class Compare = less<typename Container::value_type> > class priority_queue;\n```\n\n\nIn this:\n\n```\nT```\n is the type to be stored in the queue; hopefully this is plain enough.\n\n```\nContainer```\n is the underlying storage within the queue. As the declaration shows, this defaults to the ```\nstd::vector<T>```\n, and normally one can ignore it.\n\n```\nCompare' is the method for determining the ordering in the queue. Again, it has a default and can often be ignored.```\nCompare` is a type supporting a function call which can compare two elements in the queue and determine their ordering.\n\n```\nless```\n is the default and simply applies the normal ```\n<```\n operator. \n\nWhen one wants an ordering other than that defined by ```\n<```\n, one defines a type which provides the needed comparison. As you have:\n\n```\nstruct comp {\n  bool operator() (const pii &a, const pii &b) {\n    return a.second > b.second;\n  }\n};\n```\n\n\nNote how this takes two ```\npii```\n and compares using the ```\n>```\n operator; this gives the reverse of the default ordering in the queue.\n\nThis ```\ncomp```\n type is then specified as the third parameter to the template.\n\nHaving specified a third parameter then, with templates as with functions, the second parameter must also be specified even though we only want the same as the default, ```\nstd::vector<pii>```\n.\n\nWhy the specification of the underlying container? This is the ```\ncontainer adaptor```\n pattern. The idea is that the semantics of Priority Queues do not necessarily imply the underlying way in which the data is to be stored. Also the standard provides a number if data structures specifically focused on storage. Therefore, why not have the priority_queue allow a choice of the underlying storage? This is the adaptor concept.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Is Dijkstra's Algorithm just BFS where you also tally node weights?\r\n                \r\nFor an online course I had the assignment to implement Dijkstra's Algorithm. I completed the algorithm as described, where you maintain lists of explored and unexplored nodes and update their unexplored neighbor's distance scores as you traverse the graph (and move nodes to the explored list). \n\nI noticed that this looks a lot like bread first search so I tried modifying BFS to update node scores as nodes are added to the queue. This seems to work exactly the same but without tracking what nodes are in the explored vs unexplored queues explicitly. \n\nIs this just a matter of implementation details? Are these both examples of Dijkstra's algorithm or is one different?\n\nDijkstra example:\n\n```\ndef dijkstra(graph, source):\n    explored_set = set()\n    all_nodes = set(graph.keys())\n    node_distances = create_distance_dict(graph)\n    node_distances[source] = 0\n    while explored_set != all_nodes:\n        current_node = min_distance(node_distances, explored_set)\n        explored_set.add(current_node)\n        update_distances(graph, node_distances, current_node)\n    return node_distances\n\ndef min_distance(distances_dict, explored_set):\n    \"\"\" Helper function returns lowest distance node not yet explored \"\"\"\n    minimum = float(\"infinity\")\n    for node in distances_dict.keys():\n        if node not in explored_set and distances_dict[node] <= minimum:\n            minimum, min_index = distances_dict[node], node\n    return min_index\n\n\ndef update_distances(graph, distances_dict, current_node):\n    \"\"\" Helper function updates neighbor's distances \"\"\"\n    for n in graph[current_node]:\n        if distances_dict[n[0]] > distances_dict[current_node] + n[1]:\n            distances_dict[n[0]] = distances_dict[current_node] + n[1]\n```\n\n\nbfs based search example\n\n```\ndef search(graph, source, nodeDistances):\n    nodeDistances[source] = 0\n    queue = deque([source])\n    while len(queue) != 0:\n        n = queue.popleft()\n        for m in graph[n]:\n        # Iterate each node connected to n\n            if m and nodeDistances[m[0]] > nodeDistances[n] + m[1] :\n            # Compare current m score and update if n + n-m edge is shorter\n                nodeDistances[m[0]] = nodeDistances[n] + m[1]\n                # add m to search queue\n                queue.extend([m[0]])\n\n    return nodeDistances\n```\n\n\nGraph and nodeDistances structure used for both examples:\n\n```\nnodeDistances = {\n    1: 0,\n    2: float(\"infinity\"),\n    3: float(\"infinity\"),\n    4: float(\"infinity\"),\n    5: float(\"infinity\"),\n    6: float(\"infinity\"),\n    7: float(\"infinity\"),\n    8: float(\"infinity\"),\n    }\ngraph = {\n    1: [(2,1),(8,2)],\n    2: [(1,1),(3,1)],\n    3: [(2,1),(4,1)],\n    4: [(3,1),(5,1)],\n    5: [(4,1),(6,1)],\n    6: [(5,1),(7,1)],\n    7: [(6,1),(8,1)],\n    8: [(7,1),(1,2)],\n}\n```\n\n    ", "Answer": "\r\nThe short answer is: no, Dijkstra's algorithm is not a Breadth First Search.\n\nAs explained in this Stack Overflow post: Why use Dijkstra's Algorithm if Breadth First Search (BFS) can do the same thing faster?,\n\nDijkstra's algorithm analyzes weighted edges of a graph, meanwhile a BFS analyzes the shortest distance one step at a time.\n\nTake for example the following graph (not to scale):\n\n```\n        10\n  A --------- B \n5  \\          |\n    C -- D    |\n       3  \\   | 10\n           \\  |\n         8  \\ |\n             E\n```\n\n\nIn the above, a BFS will find that the shortest path from ```\nA to E```\n is ```\nA -> B -> E```\n, which is true for the number of steps.\nHowever, Dijkstra's Algorithm will find that the shortest path from ```\nA to E```\n is ```\nA -> C -> D -> E```\n, because of the weight of the edges of the graph.\n\nThe distance for the BFS from ```\nA to E```\n is ```\n20```\n units, whereas the shortest distance via Dijkstra's Algorithm from ```\nA to E```\n is ```\n16```\n.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm in C, want the path\r\n                \r\nI'm trying to implement the Dijkstra algorithm in C, I understand the algorithm and know how it works, but I just don't know how I can catch the path it does. Do anyone have a clue?\n\n```\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define INF 1000\n#define NUM_OF_NODES 4\n#define MEMBER 1\n#define NOMEMBER 0\n\nvoid dijkstra(int weight[][NUM_OF_NODES],int s,int t,int *pd, int precede[])\n{\n    int distance[NUM_OF_NODES],perm[NUM_OF_NODES],prev[NUM_OF_NODES];\n    int current,i,j,k,dc;\n    int smalldist,newdist;\n    for (int i = 0; i < NUM_OF_NODES; i++)\n    {\n        perm[i] = NOMEMBER;\n        distance[i] = INF;\n        prev[i] = -1;\n    }\n\nperm[s] = MEMBER;\ndistance[s] = 0;\ncurrent = s;\n\nwhile(current != t)\n{\n    smalldist = INF;\n    dc = distance[current];\n    for (int i = 0; i < NUM_OF_NODES; i++)\n    {\n        if (perm[i] == NOMEMBER)\n        {\n            newdist = dc + weight[current][i];\n            if (newdist < distance[i])\n            {\n                distance[i] = newdist; // Count the updated distance\n                precede[i] = current;\n\n            }\n        if (distance[i] < smalldist)\n        {\n            smalldist = distance[i];\n            k = i;\n        }\n\n        }\n    }//end of for and if\n\n    current = k;\n    perm[current] = MEMBER;\n\n}//end while\n*pd = distance[t];\n} //end of function\n```\n\n\nThe output I want out from the program is 0 - > 3: 13 or something like that...\n    ", "Answer": "\r\nAs far as I can tell you have the array of preceding nodes right there.\n\nIn which case outputting your path should be as simple as going through that\n\n```\nvoid print_path(int s, int t, int precede[]) {\n    int current = t;\n\n    while (current != s) {\n        printf(\"%d -> \", current);\n        current = precede[current];\n    }\n\n    printf(\"%d\\n\",current);\n}\n```\n\n\nWIll print one shortest path from ```\nt```\n to ```\ns```\n.\n\nEdit\n\nRun as:\n\n```\nint precede[NUM_OF_NODES];\ndijkstra(weight,s,t,pd, precede);\nprint_path(s,t,precede); // will print shortest a path from t to s\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm with directed graph java\r\n                \r\nI am trying learn and implement Dijkstra's algorithm for directed graphs in JAVA, I found this piece of code through Stackoverflow.\n\nhttp://en.literateprograms.org/index.php?title=Special%3aDownloadCode/Dijkstra%27s_algorithm_%28Java%29&oldid=15444\n\nI understand some stuff, but I am having difficulty on figuring out which way to go for these two questions? \n\n1) The number of trips starting at A and ending at A with a maximum of 3 stops. (Does this mean I find the route from A - A ? Because that always comes to 0.\n\nAnd this: \nThe distance of the route A-E-B-C-D - (Should I call the compute for each node and then add them all up ? Is this the smartest way ? )\n\nHere is my code: \nAny Help would be appreciated. \n\nMy Output is: \n\nDistance to A: 0.0\nPath: [A]\nDistance to B: 5.0\nPath: [A, B]\nDistance to C: 9.0\nPath: [A, B, C]\nDistance to D: 5.0\nPath: [A, D]\nDistance to E: 7.0\nPath: [A, E]\n\npackage src.main.java;\n\n```\nimport java.util.PriorityQueue;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\nclass Vertex implements Comparable<Vertex>\n{\n    public final String name;\n    public Edge[] adjacencies;\n    public double minDistance = Double.POSITIVE_INFINITY;\n    public Vertex previous;\n    public Vertex(String argName) { name = argName; }\n    public String toString() { return name; }\n    public int compareTo(Vertex other)\n    {\n        return Double.compare(minDistance, other.minDistance);\n    }\n\n}\n\n\nclass Edge\n{\n    public final Vertex target;\n    public final double weight;\n    public Edge(Vertex argTarget, double argWeight)\n    { target = argTarget; weight = argWeight; }\n}\n\npublic class Main\n{\n    public static void computePaths(Vertex source)\n    {\n        source.minDistance = 0.;\n        PriorityQueue<Vertex> vertexQueue = new PriorityQueue<Vertex>();\n        vertexQueue.add(source);\n\n        while (!vertexQueue.isEmpty()) {\n            Vertex u = vertexQueue.poll();\n\n            // Visit each edge exiting u\n            for (Edge e : u.adjacencies)\n            {\n                Vertex v = e.target;\n                double weight = e.weight;\n                double distanceThroughU = u.minDistance + weight;\n                if (distanceThroughU < v.minDistance) {\n                    vertexQueue.remove(v);\n\n                    v.minDistance = distanceThroughU ;\n                    v.previous = u;\n                    vertexQueue.add(v);\n                }\n            }\n        }\n    }\n\n    public static List<Vertex> getShortestPathTo(Vertex target)\n    {\n        List<Vertex> path = new ArrayList<Vertex>();\n        for (Vertex vertex = target; vertex != null; vertex = vertex.previous)\n            path.add(vertex);\n\n        Collections.reverse(path);\n        return path;\n    }\n\n    public static void main(String[] args)\n    {\n        Vertex v0 = new Vertex(\"A\");\n        Vertex v1 = new Vertex(\"B\");\n        Vertex v2 = new Vertex(\"C\");\n        Vertex v3 = new Vertex(\"D\");\n        Vertex v4 = new Vertex(\"E\");\n        v0.adjacencies = new Edge[]{ new Edge(v1,  5),\n                new Edge(v3,  5), new Edge(v4, 7) };\n        v1.adjacencies = new Edge[]{ new Edge(v2,  4)};\n        v2.adjacencies = new Edge[]{ new Edge(v3,  8), new Edge(v4, 2) };\n        v3.adjacencies = new Edge[]{ new Edge(v2, 8),\n                new Edge(v4,  6) };\n        v4.adjacencies = new Edge[]{ new Edge(v1, 3) };\n\n        Vertex[] vertices = { v0, v1, v2, v3, v4};\n\n        computePaths(v0);\n        for (Vertex v : vertices)\n        {\n            System.out.println(\"Distance to \" + v + \": \" + v.minDistance);\n            List<Vertex> path = getShortestPathTo(v);\n            System.out.println(\"Path: \" + path);\n        }\n    }\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Is Dijkstra's algorithm most efficient for computing single-source shortest path?\r\n                \r\nIs Dijkstra's algorithm for finding single-source shortest path the most efficient one for an undirected graph? I am using this algorithm to compute the minimum fare for a bus route from station 1 (start node) to station N (destination node). The paths connecting intermediate stations have a fare assigned(edge weight).Note, the bus route network can have\n\n1<=Stations<=50000\n1<=Routes<=500000\n\nThe details of the problem can be found here -\nhttps://www.hackerrank.com/challenges/jack-goes-to-rapture\nNow,the logic of my code is sound as only 2 out of 16 test cases have failed.The reason for failure is that graph sizes in the test cases being huge, execution time is causing timeout.\nI could use some help in optimizing the code(Dijkstra's algorithm). if there are other algorithms that could be more efficient for graphs of large sizes, would like to know about it as well.Thanks.\n    ", "Answer": "\r\nYou can a queue to priority queue to optimize it.\n\nCheck the code below\n\n```\n#include<bits/stdc++.h>\n#define mod 1000000000000\nusing namespace std;\n\ntypedef long long int ll;\ntypedef long double ld;\n\nvector<ll> pred1,pred2;\nvector<ll> dist1,dist2;\nvector<ll> vis1,vis2;\nvector< pair<ll,ll> > v[100005];\n\nclass compare{\n\npublic:\n    bool operator()(pair<ll,ll> x,pair<ll,ll> y)\n    {\n        return x.second>y.second;\n    }\n};\n\nbool cmp(ll x,ll y)\n{\n    return x>y;\n}\n\nint main()\n{\n    ll n,k,x,y,d;\n    cin>>n>>k;\n    pred1.clear();\n    dist1.clear();\n    vis1.clear();\n    dist1.resize(n+5);\n    vis1.resize(n+5);\n    pred1.resize(n+5);\n    for(ll i=0;i<=n;i++)\n    {\n        dist1[i]=mod;\n        pred1[i]=0;\n        v[i].clear();\n    }\n    for(ll i=0;i<k;i++)\n    {\n        cin>>x>>y>>d;\n        v[x].push_back(make_pair(y,d));\n        v[y].push_back(make_pair(x,d));\n    }\n    ll a,b;\n    a=1;\n    b=n;\n    dist1[a]=0;\n    priority_queue< pair<ll,ll> , vector< pair<ll,ll> > , compare > q;\n    pair<ll,ll> p={a,0};\n    q.push(p);\n    while(q.size()!=0)\n    {\n        p=q.top();\n        q.pop();\n        if(vis1[p.first]==true)\n            continue;\n        vis1[p.first]=true;\n        ll idx=p.first;\n        for(ll i=0;i<v[idx].size();i++)\n        {\n            if(dist1[v[idx][i].first]>dist1[idx]+( (v[idx][i].second-dist1[idx]>=0) ? (v[idx][i].second-dist1[idx]) : 0 ) )\n            {\n                dist1[v[idx][i].first]=dist1[idx]+( (v[idx][i].second-dist1[idx]>=0) ? (v[idx][i].second-dist1[idx]) : 0 );\n                q.push(make_pair(v[idx][i].first,dist1[v[idx][i].first]));\n                pred1[v[idx][i].first]=idx;\n            }\n        }\n    }\n    if(dist1[b]==mod)\n    {\n        cout<<\"NO PATH EXISTS\\n\";\n        return 0;\n    }\n    cout<<dist1[b]<<\"\\n\";\n\nreturn 0;\n}\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Can you use Dijkstra's algorithm if there is a negative weight so long as there are no cycles?\r\n                \r\nUpdate:  I really botched the original question.  My original title was \"Why do we first do a topological sort for acyclic weighted digraph shortest path problems?\" but my question content was about Dijkstra's algorithm.  Hopefully since I've changed the title, the question is updated in such a way that it is useful to someone else. The answer to the updated question title is \"yes\".\n\nOriginal question:\n\nWhy do I need to do a topological sort first? (see code here)  Can't I just use Dijkstra's algorithm shown below and avoid the topological sort altogether (little messy syntax-wise but you get the idea)\n\n```\nMinIndexedPriorityQueue waitingEdges = new MinIndexedPriorityQueue\nGraph g //some weighted directed graph\ndouble[] distTo = new double[g.vertexCount]\nEdge[] edgeTo = new Edge[g.vertexCount]\nint source = //init to some value\n\nvoid minPathInit()\n    init distTo to double.MAX_VALUE\n    //init first node\n    distTo [source] = 0\n    visit(source)\n    while waitingEdges.count>0\n        int vertex = waitingEdges.dequeue()\n        relax(vertex )\n\nvoid relax(v) //note that visit has been renamed to relax\n    for each edge in graph.getEdgesFrom(v)\n        int to= edge.to\n        if edge.weight + distTo [edge.from]<  distTo [to]\n            distTo[to] = edge.weight + distTo [edge.from]\n            edgeTo[to] = edge\n            if waitingEdges.contains(to)\n                waitingEdges.change(to,  distTo[to] )\n            else\n                waitingEdges.enqueue(to,  distTo[to] )\n\n\n//after everything is initialized\ngetPathTo(v)\n    if not hasBeenVisited[v]\n        return null\n    Stack path = new Stack\n    while edgeTo[v] != source\n        path.push(edgeTo[v])\n        v = edgeTo[v].from\n    return path\n```\n\n\nI can understand why Dijkstra's algorithm can't handle negative cycles (because it would get stuck in an infinite loop) but if there are no negative cycles, why does it fail as shown (and require the topological sort first)\n\nUpdate: Ok, I can see that I've botched up this question so I will try to fix it up a bit with an update.  Thanks for taking the time to point the hole's out for me.  I mistakenly thought AcyclicSP becomes Dijkstra's algorithm when removing the topological sort which is not the case.\n\nHowever, my question about Dijkstra's algorithm (using the version shown above) remains.  Why can't it be used even if there is a negative weight so long as there are no cycles?  There is a java version of Dijkstra's algorithm here.  Mine is very similar to this (since this guy's book is where I learned about it) but his example is probably easier to read for some of you.\n    ", "Answer": "\r\nYou don't make any topological sort in the original algorithm. But in the case of an a-cyclic graph, then you can decrees the running time to O(V) (while the original running time is O(|V|*log(|V|)).\nThe reason is that you sort in O(|V|) time, and then you can use that order, and don't need any heap (or priority queue). So the over all time decreases to O(|V|).\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "dijkstra algorithm for big graphs\r\n                \r\nI am implementing Dijkstra's algorithm using standard Python libraries.\nmy implementation below is ok for test cases with little graphs.\nWhen I run it on a big one (more than 30k nodes), it is not great.\nWonder if anybody can help improving it.\nI do not understand if the stop checks are not correct of if there is something else missing\n```\nimport logging\nfrom collections import deque, namedtuple\n\nlogger = logging.getLogger(__name__)\n# use infinity as a default distance to nodes.\ninf = float(\"inf\")\nEdge = namedtuple(\"Edge\", \"start, end, cost\")\n\n\ndef make_edge(start, end, cost=1):\n    return Edge(start, end, cost)\n\n\nclass Graph:\n    def __init__(self, edges):\n        # check that the data is right\n        wrong_edges = [i for i in edges if len(i) not in [2, 3]]\n        if wrong_edges:\n            raise ValueError(\"Wrong edges data: {}\".format(wrong_edges))\n\n        self.edges = [make_edge(*edge) for edge in edges]\n\n    @property\n    def vertices(self):\n        return set(sum(([edge.start, edge.end] for edge in self.edges), []))\n\n    def get_node_pairs(self, n1, n2, both_ends=True):\n        if both_ends:\n            node_pairs = [[n1, n2], [n2, n1]]\n        else:\n            node_pairs = [[n1, n2]]\n        return node_pairs\n\n    def remove_edge(self, n1, n2, both_ends=True):\n        node_pairs = self.get_node_pairs(n1, n2, both_ends)\n        edges = self.edges[:]\n        for edge in edges:\n            if [edge.start, edge.end] in node_pairs:\n                self.edges.remove(edge)\n\n    def add_edge(self, n1, n2, cost=1, both_ends=True):\n        node_pairs = self.get_node_pairs(n1, n2, both_ends)\n        for edge in self.edges:\n            if [edge.start, edge.end] in node_pairs:\n                return ValueError(\"Edge {} {} already exists\".format(n1, n2))\n\n        self.edges.append(Edge(start=n1, end=n2, cost=cost))\n        if both_ends:\n            self.edges.append(Edge(start=n2, end=n1, cost=cost))\n\n    # @property\n    # def neighbours(self):\n    #     neighbours = {vertex: set() for vertex in self.vertices}\n    #     for edge in self.edges:\n    #         neighbours[edge.start].add((edge.end, edge.cost))\n\n    #     return neighbours\n\n    # use the following if the graph is undirected / bidirectional\n    @property\n    def neighbours(self):\n        neighbours = {vertex: set() for vertex in self.vertices}\n        for edge in self.edges:\n            neighbours[edge.start].add((edge.end, edge.cost))\n            neighbours[edge.end].add((edge.start, edge.cost))\n\n        return neighbours\n\n    def dijkstra(self, source, dest):\n        assert source in self.vertices, \"Such source node doesn't exist\"\n        distances = {vertex: inf for vertex in self.vertices}\n        previous_vertices = {vertex: None for vertex in self.vertices}\n        distances[source] = 0\n        vertices = self.vertices.copy()\n\n        while vertices:\n            current_vertex = min(vertices, key=lambda vertex: distances[vertex])\n            vertices.remove(current_vertex)\n            if distances[current_vertex] == inf:\n                break\n            for neighbour, cost in self.neighbours[current_vertex]:\n                alternative_route = distances[current_vertex] + cost\n                if alternative_route < distances[neighbour]:\n                    distances[neighbour] = alternative_route\n                    previous_vertices[neighbour] = current_vertex\n                    logger.debug(\"updating Graph distances\", format(distances))\n\n        path, current_vertex = deque(), dest\n        while previous_vertices[current_vertex] is not None:\n            path.appendleft(current_vertex)\n            current_vertex = previous_vertices[current_vertex]\n        if path:\n            path.appendleft(current_vertex)\n        logger.debug(\"path to destination is \\n\")\n\n        while path:\n            value = path.popleft()\n            logger.debug(\"{} \\n\".format(value))\n\n        return distances[dest]\n```\n\nand this is the test case:\n```\ngraph = Graph(\n    [\n        (\"a\", \"b\", 7),\n        (\"a\", \"c\", 9),\n        (\"a\", \"f\", 14),\n        (\"b\", \"c\", 10),\n        (\"b\", \"d\", 15),\n        (\"c\", \"d\", 11),\n        (\"c\", \"f\", 2),\n        (\"d\", \"e\", 6),\n        (\"e\", \"f\", 9),\n    ]\n)\n\n\nresult = graph.dijkstra(\"a\", \"e\")\nprint(result)\nassert result == 20\n```\n\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Running time measurements of Dijkstra's algorithm\r\n                \r\nI wrote an implementation of Dijkstra's algorithm based on the pseudocode for it on Wikipedia ( http://en.wikipedia.org/wiki/Dijkstra's_algorithm )  that used a priority queue with a min-heap. The graph was represented with an adjacency matrix (just like the pseudo code). And when I was gonna test it to see the running time, I thought I needed some large graphs to test on, so I randomly generated a few graphs of some size n (although the method I used to generate the graphs was probably quite bad). \n\nNow, the complexity for this implementation is according to Wikipedia: O((|V|+|E|) log |V|).\n\nWhen I ran the algorithm on V = 1000, e.g. a graph with 1000 nodes (I dont know how many edges though), on average it took about 800 ms. When I doubled the size of the graph with V = 2000, it took around 1700 ms, and when I doubled that (V = 4000), it took about twice as much. \n\nSo my question is (I know that my computer plays some part in the time measurements as well), shouldn't the running times be faster? Are these measurements reasonable? \n    ", "Answer": "\r\nThese measurements are reasonable; however, the runtime complexity is both worst-case and asymptotic. In fact, it would be most useful to evaluate the running times on instances where the worst-case is actually reached to experimentally estimate the runtime complexity.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "What is the difference between triangle inequality and path relaxation in Dijkstra's algorithm?\r\n                \r\nThe relaxation process in Dijkstra's algorithm refers to updating the cost of all vertices connected to a vertex v from source vertex V. \n\nI think the triangle inequality also refers the same.\n    ", "Answer": "\r\nPath relaxation is the process by which we arrive at the shortest paths from source to all vertices. Relaxation of an edge in Dijkstra's algorithm\n\nTriangle inequality refers to the lengths of the shortest paths between the vertices. For example the shortest distance between A and B D(A,B) is not greater than D(A,C) + D(C,B) for any other vertex C not lying in the shortest path from A to B.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Having difficulty figuring out why my implementation of the Dijkstra's algorithm is not working?\r\n                \r\nI am using Dijkstra's algorithm to solve the Leetcode Problem Network Delay Time (https://leetcode.com/problems/network-delay-time), where I try to find the minimum cost to propagate a signal from a starting vertex to every other vertex in a weighted graph. My code below passes 31/52 of the test cases, but fails the following test case.\nI am very confused as to why my code fails, as I believe I am implementing all components of Dijkstra's algorithm correctly. If someone could point me to a possible error point, that would be greatly appreciated:\n```\n[[15,8,1],[7,10,41],[7,9,34],[9,4,31],[12,13,50],[14,3,52],[4,11,99],[4,7,86],[10,13,57],[9,6,10],[1,7,51],[7,15,38],[1,9,11],[12,7,94],[9,13,34],[11,7,79],[7,6,28],[5,3,34],[2,6,97],[14,1,97],[6,10,90],[12,10,37],[13,3,73],[11,14,7],[15,1,39],[6,5,90],[13,6,43],[6,9,32],[4,6,45],[11,10,2],[2,13,4],[14,15,29],[1,14,88],[14,6,19],[6,2,29],[3,14,72],[1,15,4],[11,5,2],[6,7,56],[8,7,88],[13,14,70],[14,12,58],[14,2,86],[11,3,57],[5,2,56],[3,10,26],[2,11,21],[14,5,54],[5,12,40],[14,4,81],[15,2,99],[5,7,57],[13,12,5],[4,9,60],[12,15,48],[6,14,1],[9,7,44],[13,7,69],[5,13,42],[4,1,7],[11,9,76],[8,1,76],[5,14,29],[2,3,69],[7,3,23],[12,14,28],[11,4,85],[10,1,10],[15,12,36],[1,11,69],[15,10,96],[11,13,69],[7,12,49],[1,2,95],[6,4,46],[8,12,94],[12,4,93],[13,5,31],[12,2,60],[6,1,87],[4,14,20],[5,11,89],[4,15,88],[4,10,21],[1,6,5],[10,8,26],[8,2,51],[3,15,23],[7,2,12],[11,1,47],[2,1,75],[3,8,63],[8,10,19],[6,8,18],[4,2,55],[14,11,80],[10,3,73],[3,5,22],[12,3,61],[1,13,33],[9,3,98],[9,12,69],[15,9,6],[7,13,76],[11,12,22],[11,15,51],[13,15,46],[5,10,58],[1,10,26],[13,4,85],[7,14,58],[5,8,46],[11,6,32],[10,9,41],[9,14,35],[14,13,60],[3,9,97],[2,5,39],[7,11,19],[1,12,27],[7,5,13],[8,4,34],[9,15,25],[5,1,93],[15,13,97],[14,9,35],[8,6,67],[9,5,39],[13,11,35],[7,4,21],[12,9,64],[14,8,8],[10,12,94],[8,9,76],[8,5,71],[2,9,64],[10,14,59],[1,4,74],[7,1,69],[15,5,55],[6,15,80],[13,8,84],[8,13,63],[8,3,91],[10,4,87],[1,5,39],[8,11,0],[1,3,79],[4,5,82],[4,12,87],[3,11,29],[7,8,92],[10,7,77],[6,12,42],[13,2,40],[9,10,13],[4,13,65],[2,4,34],[3,13,44],[2,14,69],[3,4,42],[5,15,98],[14,7,6],[15,3,94],[10,2,37],[15,11,7],[9,2,15],[13,9,66],[4,8,83],[8,15,23],[13,1,50],[6,13,57],[2,10,37],[10,6,38],[2,7,45],[9,8,8],[3,12,28],[3,2,83],[2,12,75],[1,8,91],[4,3,70],[12,6,48],[3,1,13],[5,6,42],[6,11,96],[3,6,22],[15,6,34],[11,8,43],[15,7,40],[9,11,57],[11,2,11],[2,8,22],[9,1,73],[2,15,40],[12,11,10],[15,4,78],[12,8,75],[10,15,37],[13,10,44],[8,14,33],[3,7,82],[5,4,46],[12,5,79],[15,14,43],[10,5,65],[5,9,34],[12,1,54],[6,3,16],[14,10,83],[10,11,67]]\n15\n8\n```\n\nBelow is my Java code:\n```\nclass Solution {\n    // Dijkstra's Algorithm: \n    // Time: O(|V| + |E| log(|V|)), since I used a min-heap.\n    // Space: O(|V| + |E|)\n    public int networkDelayTime(int[][] times, int n, int k) {\n        // Represent the graph as an adjacency list.\n        // Source Node -> set of destination Pairs (Target Node, Travel Time).\n        HashMap<Integer, HashSet<Pair<Integer, Integer>>> adjacencyList = new HashMap<Integer, HashSet<Pair<Integer, Integer>>>();\n        for (int[] time : times) {\n            int source = time[0];\n            int target = time[1];\n            int travelTime = time[2];\n            \n            // Retrieve the existing set of destination.\n            HashSet<Pair<Integer, Integer>> destinationSet = adjacencyList.getOrDefault(source, new HashSet<Pair<Integer, Integer>>());\n            destinationSet.add(new Pair<Integer, Integer>(target, travelTime));\n            \n            // Update the set of destinations that can be reached from the current source.\n            adjacencyList.put(source, destinationSet);\n        }\n        \n        // Map the distance from source to vertex v.\n        HashMap<Integer, Integer> distFromSource = new HashMap<Integer, Integer>();\n        \n        // Backtracking purposes: map each vertex to the previous vertex along the shortest path.\n        HashMap<Integer, Integer> prevVertex = new HashMap<Integer, Integer>();\n        \n        // Min-heap which stores the vertexes, based on their distance\n        // from the source.\n        PriorityQueue<Integer> minHeap = new PriorityQueue<Integer>((v1, v2) -> distFromSource.get(v1) - distFromSource.get(v2));\n        \n        // Edge Case: distance from source to source is 0.\n        distFromSource.put(k, 0);\n        \n        // Initially, the distance from the source to each vertex is infinite (except for source itself).\n        // We also haven't figured out any of the previous vertexes.\n        for (int i = 1; i <= n; i++) {\n            if (i != k) {\n                distFromSource.put(i, Integer.MAX_VALUE);\n                prevVertex.put(i, -1);\n            }\n            minHeap.add(i);\n        }\n        \n        // Store the visited vertices so we don't visit them again.\n        HashSet<Integer> visited = new HashSet<Integer>();\n        \n        // While are min heap still isn't empty.\n        while (!minHeap.isEmpty()) {\n            // Retrieve the closest vertex to the source.\n            Integer closestVertex = minHeap.poll();\n            \n            // Check that the closest vertex hasn't already been visited.\n            if (!visited.contains(closestVertex)) {\n                // Mark the vertex as visited.\n                visited.add(closestVertex);\n                \n                // Retrieve the distance to the closest vertex.\n                int distToClosestVertex = distFromSource.get(closestVertex);\n\n                // Go through the edges to the closest vertex's neighbors.\n                for (Pair<Integer, Integer> edge : adjacencyList.getOrDefault(closestVertex, new HashSet<Pair<Integer, Integer>>())) {\n                    int destination = edge.getKey();\n                    int travelTime = edge.getValue();\n                    int alternativeDist = distToClosestVertex + travelTime;\n\n                    // If we have found a new shortest path to the destination.\n                    if (alternativeDist < distFromSource.get(destination)) {\n                        distFromSource.put(destination, alternativeDist);\n                        prevVertex.put(destination, closestVertex);\n                    }\n                }\n            }\n        }\n        \n        // Find the maximum distance to any one of the nodes.\n        int maxDistance = Integer.MIN_VALUE;\n        for (Integer dist : distFromSource.values()) {\n            // We are unable to send the singal to every vertex.\n            if (dist == Integer.MAX_VALUE) {\n                return -1;\n            }\n            \n            maxDistance = Math.max(maxDistance, dist);\n        }\n        \n        return maxDistance;\n    }\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How to create Dijkstra's algorithm GUI using python?\r\n                \r\nI need to do Dijkstra's GUI for my assignment. I stumbled upon a website explaining about the Dijkstra's algorithm link. I tried to build GUI based on the website, but I got stuck.\nThere are two things I want to do:\n\nThe user can freely choose the source and destination from the dropdown menus. (Note: As of now, I didn't know how to do it, so I just set the source and destination myself)\nThe program will find the shortest path based on the input and display the output (on GUI) when they pressed button 'Enter'. (Note: As of now, the output only shows on terminal not GUI)\n\nI'm still new to python and any help or ideas are much appreciated. Sorry for my broken English and messy python code.\n------My code------\n```\nfrom tkinter import *\n\nwin=Tk() #creating the main window and storing the window object in 'win'\nwin.title('KOE Navigation') #setting title of the window\nwin.geometry('500x400')\n\ndef initial_graph() :\n    \n    return {\n            \n        'A': {'B':1, 'C':4, 'D':2},\n        'B': {'A':9, 'E':5},\n        'C': {'A':4, 'F':15},\n        'D': {'A':10, 'F':7},\n        'E': {'B':3, 'J':7},\n        'F': {'C':11, 'D':14, 'K':3, 'G':9},\n        'G': {'F':12, 'I':4},\n        'H': {'J':13},\n        'I': {'G':6, 'J':7},\n        'J': {'H':2, 'I':4},\n        'K': {'F':6}\n                \n            }\n\ndef shortest_path(): \n\n    x = 'H'\n    print('The shortest path between A to H is: ')\n    print(x, end='<-')\n    while True:\n        x = adj_node[x]\n        if x is None:\n            print(\"\")\n            break\n        print(x, end='<-')\n\n#print(initial_graph())\ninitial =  'A'\n\npath = {}\n\nadj_node = {}\n\nqueue = []\n\ngraph = initial_graph()\n\nfor node in graph:\n    path[node] = float(\"inf\")\n    adj_node[node] = None\n    queue.append(node)\n    \npath[initial] = 0\n\nwhile queue:\n    # find min distance which wasn't marked as current\n    key_min = queue[0]\n    min_val = path[key_min]\n    for n in range(1, len(queue)):\n        if path[queue[n]] < min_val:\n            key_min = queue[n]  \n            min_val = path[key_min]\n    cur = key_min\n    queue.remove(cur)\n    print(cur)\n    \n\n    for i in graph[cur]:\n        alternate = graph[cur][i] + path[cur]\n        if path[i] > alternate:\n            path[i] = alternate\n            adj_node[i] = cur\n\n#GUI\nlab=Label(win,text='Please select the source and destination required below').pack()\n\n#creating dropdown list\noptions_source = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\"]\noptions_destination = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\"]\n\n#data type of the list\nclicked_source = StringVar()\nclicked_destination = StringVar()\n\n#Set initial label\nclicked_source.set(\"Source\")\nclicked_destination.set(\"Destination\")\n\n#create dropdown menu\ndrop_source = OptionMenu(win, clicked_source, *options_source).pack()\ndrop_destination = OptionMenu(win, clicked_destination, *options_destination).pack()\n\n#create enter button to continue the program\nmyButton = Button(win, text = 'Enter', command = shortest_path).pack()\n\nwin.mainloop() #running the loop that works as a trigger\n```\n\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Is this algorithm right and faster than Dijkstra's algorithm for directed graph?\r\n                \r\nFor the shortest path of directed graph, I got a solution:\n\n\nCompute the indegree of every vertex, and then construct an array Indegree[NumVertex].\nBeginning with the source point, update the Dist of adjacement vertices if the new computed Dist is smaller, and these vertices' indegree also minus 1.\nPush the adjacement points which indegree equals 0 into the quene.\nThen dequene one vertex, and deal with that vertex as above.\nIt will stop when the quene is empty.\n\n\nThis solution is similar to topological sort. \n\nI have tried some test cases and got the correct results. \n\nIs this algorithm correct?\n\nAlso this solution's time complexity is |E|+|V|. \n\nIs it really faster than Dijkstra's algorithm?\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Neo4j Dijkstra's algorithm not returning / crashing\r\n                \r\nRight now I am building a new routing engine. It exists of about 500 vertices and 30.000 edges. I've put these routes and airports in Neo4j and I've specified a distance attribute for every route (distance in KM between the two nodes).\n\nHowever when I ask the simple question using the Dijkstra's Algorithm implemented in Neo4j; it basically just crashes. Memory usage increases to 4GB and CPU usage increases to 150% (even when I give a max depth of 1). \n\nMy intuition says, this is because I have some cycles in my graph. If you imagine these routes between airports:\n\nA > B > C\n\nThere might also exist a route:\n\nC > A\n\nSo I think it keeps going back and forward between those C > A and then going back.\n\nIs there a way, to stop Neo4J from going up in the \"tree\"? So basically saying, \"Hey, I've already been there, no need to go back\". My knowledge of Neo4j is limited so maybe it is something very simple.\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Time Complexity of Straight Forward Dijkstra's Algorithm\r\n                \r\nI am having a hard time seeing the O(mn) bound for the straightforward implementation Dijkstra's algorithm (without a heap). In my implementation and others I have found the main loop iterates n-1 times (for each vertex that is not source, n-1), then in each iteration finding the minimum vertex is O(n) (examining each vertex in the queue and finding min distance to source) and then each discovered minimum vertex would have at most n-1 neighbors, so updating all neighbors is O(n). This would seem to me to lead to a bound of O(n^2). My implementation is provided below\n\n```\npublic int[] dijkstra(int s) {\n      int[] dist = new int[vNum];\n      LinkedList queue = new LinkedList<Integer>();\n      for (int i = 0; i < vNum; i++) {\n         queue.add(i); // add all vertices to the queue\n         dist[i] = Integer.MAX_VALUE; // set all initial shortest paths to max INT value\n      }\n      dist[s] = 0; // the source is 0 away from itself\n\n      while (!queue.isEmpty()) { // iterates over n - 1 vertices, O(n)\n\n         int minV = getMinDist(queue, dist); // get vertex with minimum distance from source, O(n)\n         queue.remove(Integer.valueOf(minV)); // remove Integer object, not position at integer\n\n         for (int neighbor : adjList[minV]) { // O(n), max n edges\n            int shortestPath = dist[minV] + edgeLenghts[minV][neighbor];\n            if (shortestPath < dist[neighbor]) {\n               dist[neighbor] = shortestPath; // a new shortest path have been found\n            }\n         }\n      }\n\n      return dist;\n\n   }\n```\n\n\nI don't think this is correct, but I am having trouble see where m factors in. \n    ", "Answer": "\r\nYour implementation indeed removes the M factor, at least if we consider only simple graphs (no multiple edges between two vertices). It is O(N^2)! The complexity would be O(N*M) if you would iterate through all the possible edges instead of vertices.\n\nEDIT: Well, it is actually O(M + N^2) to be more specific. Changing value in some vertex takes O(1) time in your algorithm and it might happen each time you consider an edge, in other words, M times. That's why there is M in the complexity.\n\nUnfortunately, if you want to use simple heap, the complexity is going to be O(M* log M) (or M log N). Why? You are not able to quickly change values in heap. So if dist[v] suddenly decreases, because you've found a new, better path to v, you can't just change it in the heap, because you don't really know it's location. You may put a duplicate of v in your heap, but the size of the heap would be then O(M). Even if you store the location and update it cleverly, you might have O(N) items in the heap, but you still have to update the heap after each change, which takes O(size of heap). You may change the value up to O(M) times, what gives you O(M* log M (or N)) complexity \n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Heap in Dijkstra algorithm\r\n                \r\ncan someone explain whats the importance of HeapDesc in ShaneSaunders Dijkstra algorithm and how it is used here? \nIn general i know how Dijkstra algorithm works. But, i din't get the heap part in implementation.\n\nIts a big code. hence am posting a link if u want to have a look at it. \n\nHere go's http://www.cosc.canterbury.ac.nz/research/RG/alg/dijkstra.cpp\n    ", "Answer": "\r\nIn Dijkstra you need an efficient data structure that provides you with the edge of minimum cost that allows you to reach another vertex.\n\nHeap is exactly a data structure that allows you to store the set of edges and efficiently retrieve the one with minimum cost.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Run Dijkstra's Algorithm on a List<Point> in C#\r\n                \r\nI have a list of Point types in C#. I want to run Dijkstra's algorithm on this list of points where the first entry in the list is the starting location.\n\nIs there a way of doing this using an existing library?\n\nIf such library doesn't exist, is there a way of calculating the distance between two points with x and y coordinates. For example, calculate the distance between point A (x coordinate =2, y coordinate = 4) and point B ((x coordinate =9, y coordinate = 7).\n\nI have used the ZedGraph library to build the graph.\n    ", "Answer": "\r\nI think you misunderstood, what the Dijkstra algorithm stands for.\n\n\n  For a given source vertex (node) in the graph, the algorithm finds the path with lowest cost (i.e. the shortest path) between that vertex and every other vertex.\n\n\nWhat you need (i think) the lowest distance between two points based on their coordinates.\n\nAnd the distance between two points can be counted using basic math:\n\n```\nPoint p = new Point(4, 5);\nPoint r = new Point(10, 2);\n\ndouble distance = Math.Sqrt(Math.Pow(p.X - r.X, 2) + Math.Pow(p.Y - r.Y, 2));\n```\n\n\nusing this knowledge the problem could be solved with two functions like this:\n\nReturns the distance between ```\np```\n and ```\nr```\n:\n\n```\nstatic double distance(Point p, Point r)\n{\n     return Math.Sqrt(Math.Pow(p.X - r.X, 2) + Math.Pow(p.Y - r.Y, 2));\n}\n```\n\n\nReturns the index of the closest point to the ```\nfromIndex```\n th element of the ```\npoints```\n list:\n\n```\nstatic int closestPoint(List<Point> points, int fromIndex)\n{\n    Point start = points[fromIndex];\n    int resultIndex = 0;\n\n    for (int i = 1; i < points.Count; i++)\n    {\n        if (fromIndex == i) \n            continue;\n\n        Point current = points[i];\n\n        if (distance(start, current) < distance(start, points[resultIndex]))\n            resultIndex = i;\n    }\n\n    return resultIndex;\n}\n```\n\n\nI'm really sorry, if i misunderstood you!\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Priority in Queue is behaving wierdly in Dijkstra's algorithm?\r\n                \r\nI implemented Dijkstra's algorithm with priority queue. Everything works perfectly except for this one special instance of the test case and I don't understand how the priority queue is not working. For some background, in my application I turn input in the form of (row, column) into a node and each row and column are nodes bi-directional. The main bug happens when i run this algorithm with an test input and the priority queue pick a node with a distance of 99999 instead of 4! What i mean by this is that when i compare nodes for the priority, they implement a comparable that looks at the distance (between current node and source node). All un-visited nodes are set to 999999(infinity). Therefore, nodes that are visited will be chosen to be the next current node instead of some random node in the graph.\n\nThe following code is Dijkstra's algorithm implemented by priority queue.\nThe project on github.\n\n```\npublic static void execute(int source){\n      PriorityQueue<Vertex> pQueue = new PriorityQueue<Vertex>();\n\n        // Set the first node as source node \n        int diameter =0;\n        existingVertex.get(source).setDistance(0);\n\n        // Add all nodes into a heap\n        pQueue.addAll(existingVertex);\n            while (!pQueue.isEmpty()){\n\n                    // Take out first node\n                    Vertex n = pQueue.remove();\n                    n.setVisited(true);\n                    System.out.println(\"current node=\" + n.id);\n\n                    for (Edge e: n.getOutgoingEdges()){\n                            Vertex adjNode = e.getDestination();\n                            System.out.println(\"adjNode id=\" +adjNode.id);\n                            Integer newPossiblePathCost = 1+ n.getDistance();\n                            if (Boolean.FALSE.equals(adjNode.isVisited())) {\n\n                            if (newPossiblePathCost<adjNode.getDistance()){\n                             adjNode.setDistance(newPossiblePathCost); \n                             System.out.println(\"Distance:\" + adjNode.distance);\n                                    // update\n                             pQueue.remove(adjNode);\n                             pQueue.add(adjNode);}}\n                    }\n\n                    // Save the diameter of the traversed graph\n                    if(n.getDistance() > diameter  && n.getDistance() != 999999)\n                    {\n                        diameter = n.getDistance();\n                    }\n            }       \n\n            diameterlist.add(diameter);\n\n    }\n```\n\n\nTest Case:\n\n\n1 14\n1 2\n2 15\n3 15\n4 15\n5 15\n6 15\n7 15\n8 15\n9 15\n10 15\n11 15\n12 15\n13 15\n\n\nOutput:\n\n\ncurrent node=14\nadjNode id=1\nDistance:1\ncurrent node=1\nadjNode id=14\nadjNode id=2\nDistance:2\n current node=2\nadjNode id=1\nadjNode id=15\nDistance:3\ncurrent node=13\nadjNode id=15\n current node=15\n\n\nCould anyone explain to me why this happens?\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Needing help writing Dijkstra's Algorithm\r\n                \r\nI am trying write Dijkstras Algorithm into the code I have written below. But I am unsure how to start doing this. I did review it a bit from online sources, but I am still unsure how to make it work really. I prefer to place it into the evaluate paths method. Then have the menu option call this method and it perform the sorting algorithm. \n\nFYI. I am sorting the shortest path from City A to City B by miles and price. \n\nBelow is the code I have.\n\n```\nimport java.io.*;\nimport java.util.*;\n\npublic class CityCalcultor { \n   static LinkedList<String> cities = new LinkedList<String>();\n   static LinkedList<Integer> distance = new LinkedList<Integer>();\n   static LinkedList<Integer> price = new LinkedList<Integer>();\n    public static void main(String[] args)throws IOException \n    {\n     Scanner input = new Scanner(System.in);\n     String text;\n     int option = 0;   \n      while (true)\n      {   \n       System.out.println(\"\\nWhat would you like to do:\\n\" +\n       \"1. Add a city to the system\\n\" +\n      \"2. Add a path to the system\\n\" +\n      \"3. Evalute paths\\n\" +\n       \"4. Exit\\n\" + \"Your option: \");\n       text = input.nextLine();\n       option = Integer.parseInt(text);\n\n        switch (option)\n        {\n         case 1: EnterCity(); break;\n         case 2: EnterPath(); break;\n         case 3: EvalutePaths(); break;\n         case 4: return;\n         default: System.out.println(\"ERROR INVALID INPUT\");\n        }\n       }\n      }\npublic static void EnterCity(){\n   String c = \"\";\n   LinkedList<String> cities = new LinkedList<String>(Arrays.asList(c));\n   Scanner City = new Scanner(System.in);\n   System.out.println(\"Please enter the city name \");\n   c = City.nextLine();\n   cities.add(c);\n   System.out.println(\"City \" + c + \" has been added \");\n\n}\npublic static void EnterPath(){\n   Scanner Path = new Scanner(System.in);\n   int d = 0; int p = 0;\n   System.out.println(\"Enter the starting city \");\n   System.out.println();\n   System.out.println(Path.nextLine());\n   System.out.println(\"Enter the ending city \");\n   System.out.println(Path.nextLine());\n   System.out.println(\"Enter the distance between the two cities \");\n   d= Path.nextInt();\n   distance.add(d);\n   System.out.println(\"Enter the price between the two cities \");\n   p = Path.nextInt();\n\n   price.add(p);\n   System.out.println(\"The route was sucessfully added \");\n\n\n}\nprivate static void EvalutePaths(){\n\n\n}\n}\n```\n\n\nOutput should look like:: \n\nShortest Route from Seattle to San Francisco is 1290 miles.\n    ", "Answer": "\r\nhere is some pseudo code for Dijkstra's algorithm, perhaps it will help..\n\nthis will set the shortest distance to each city from the starting city..\n\n```\nfor each city\n{\n    settled = false\n    distance = infinity\n}\n\nstartingCity.distance = 0\n\ncurrentCity = startingCity\n\nwhile not all cities are settled\n{\n    for each city adjacent to the current city\n    {\n        newDist = distance from adjacentCity to currentCity\n\n        if newDist < adjacentCity.distance\n        {\n            adjacentCity.distance = newDist\n        }  \n    }\n\n    currentCity.settled = true\n\n    currentCity = city closest to currentCity\n}\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm with Negative Weights Query\r\n                \r\nIn this scenario, the aim is to find a path with the smallest total weight. There are 5 sections with each section having different nodes. The nodes are only connected to nodes in adjacent sections and a path must consist of only a single node from each section.\nFor example, let:\n\nsection 1 has nodes [1, 2, 3].\nsection 2 has nodes [4, 5].\nsection 3 has nodes [6].\nsection 4 has nodes [7, 8, 9, 10, 11].\nsection 5 has nodes [12, 13, 14].\n\nA valid path through the sections is [1, 4, 6, 7 , 12] and also [1, 5, 6, 11, 14] etc...\nAll nodes have negative weights but negative cycles are impossible (due to the one node per section policy). Therefore, does the process of adding a constant to each node resolve the issue of negative weights? If it can fix the issue, are there any papers which show this? I know there are other algorithms to resolve negative weights but I'm interestted in Dijkstra's algorithm. Thanks.\n    ", "Answer": "\r\nNo, you can't do this. Let's have a look at the counter example. Suppose we have a graph with ```\nA```\n, ```\nB```\n, ```\nC```\n nodes and egdes:\n```\nA - B  -2 (negative)\nA - C   6\nB - C   7\n```\n\nwe are looking for the shortest path from ```\nA```\n to ```\nC```\n. In the original graph we have\n```\nA - B - C  => -2 + 7 = 5 (the shortest path, 5 < 6)\nA - C      => 6\n```\n\nThe best choice is ```\nA - B - C```\n. Now, let's get rid of negative edges by adding ```\n2```\n. We'll have now\n```\nA - B  0 \nA - C  8\nB - C  9\n\nA - B - C  => 0 + 9 = 9\nA - C      => 8         (the shortest path, 8 < 9) \n```\n\nPlease note, that now the shortest path is ```\nA - C```\n. Alas! While adding constant value to each edge we ruin the problem itself; and it doesn't matter now which algorithm we use.\nEdit: Counter example with all edges (arc to prevent negative loops) being negative:\n```\nA -> B -6\nB -> C -1\nA -> C -5\n```\n\nBefore adding ```\n6```\n we have\n```\nA -> B -> C = -6 - 1 = -7 (the shortest path)\nA -> C      = -5\n```\n\nAfter adding ```\n6```\n we get\n```\nA -> B  0\nB -> C  5\nA -> C  1\n\nA -> B -> C = 0 + 5 = 5 \nA -> C      = 1 (the shortest path)\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm in Multicast Routing\r\n                \r\nEDIT: I reconstructed the question\n\nI was assigned a project where I need to simulate multicast routing and put labels in the network. The teacher was very vague as to what kind of simulation we needed so that is where I got confused. I'll outline the requirement of the simulation.\n\nIn your simulation, you are required to run the \"reroute to source\" algorithm on a small and large scale network. You are required to randomly generate the cost on each link and randomly select one node as the source and several other nodes as the destinations. Each router should maintain a table to show the incoming label associated with incoming port and outgoing labels\n\n\n\nPicture above for reference. Each router at each node should maintain an MPLS table. Since the \"reroute to source\" algorithm is actually unicast, there is no need to extend the table.\n\nAll I need is ideas. I have a very good understanding of Dijkstra's shortest path algorithm but I feel like there's a gap in my understanding of how multicast incorporates such algorithm.\n\nSo, assuming my network is bidirectional, the algorithm will find the shortest path from each source to destination and assign labels along this path. Then, when all the shortest paths have been found, I just need to merge these paths and form a tree which would the be used for the multicast routing.\n\nDo you guys have anything I could look at to give me ideas for a simulation? Or any suggestions based on experience. I just want to understand what I have to do\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra algorithm with Adjacency lists\r\n                \r\nSo I have been trying to implement the Dijkstra Algorithm for shortest path in a directed graph using adjacency lists, but for I don't know what reason, it doesn't print out the results (prints the minimum distance as 0 to all nodes).\n\nThe code I wrote is:\n\n\n```\n#include <fstream>\n#include <functional>\n#include <climits>\n#include <vector>\n#include <queue>\n#include <list>\n\nusing namespace std;\n\nstruct node {\n    int vertex;\n    int weight;\n    node(int v, int w) : vertex(v), weight(w) { };\n    node() { }\n};\n\nclass CompareGreater {\n    public:\n        bool const operator()(node &nodeX, node &nodeY) {\n            return (nodeX.weight > nodeY.weight) ;\n        }\n};\n\nvector< list<node> > adj;\nvector<int> weights;\npriority_queue<node, vector<node>, CompareGreater> Q;\n\nint nrVertices, nrEdges;\n\nvoid readData();\nvoid Dijkstra(node);\nvoid writeData();\n\nint main(int argc, char *argv[]) {\n\n    readData();\n    Dijkstra(node(1, 0));\n    writeData();\n\n    return 0;\n}\n\nvoid readData() {\n    fstream in(\"dijkstra.in\", ios::in);\n\n    int nodeX, nodeY, weight;\n\n    in >> nrVertices >> nrEdges;\n\n    adj.resize(nrVertices+1);\n    weights.resize(nrVertices+1);\n\n    for (int i = 1; i <= nrVertices; ++i) {\n        weights.push_back(INT_MAX);\n    }\n\n    for (int i = 1; i <= nrEdges; ++i) {\n        in >> nodeX >> nodeY >> weight;\n        adj[nodeX].push_back(node(nodeY, weight));\n    }\n\n    in.close();\n}\n\nvoid Dijkstra(node startNode) {\n    node currentNode;\n\n    weights[startNode.vertex] = 0;\n    Q.push(startNode);\n\n    while (!Q.empty()) {\n        currentNode = Q.top();\n        Q.pop();\n\n        if (currentNode.weight <= weights[currentNode.vertex]) {\n            for (list<node>::iterator it = adj[currentNode.vertex].begin(); it != adj[currentNode.vertex].end(); ++it) {\n                if (weights[it->vertex] > weights[currentNode.vertex] + it->weight) {\n                    weights[it->vertex] = weights[currentNode.vertex] + it->weight;\n                    Q.push(node((it->vertex), weights[it->vertex]));\n                }\n            }\n        }\n    }\n}\n\nvoid writeData() {\n    fstream out(\"dijkstra.out\", ios::out);\n\n    weights.resize(nrVertices+1);\n    for (vector<int>::iterator it = weights.begin()+1; it != weights.end(); ++it) {\n        out << (*it) << \" \";\n    }\n\n    out.close();\n}\n```\n\n\nThe input data was:\n\n```\n5 7\n1 2 10\n1 3 2\n1 5 100\n2 4 3\n3 2 5\n4 3 15\n4 5 5\n```\n\n\nIt means there are 5 nodes, 7 arcs (directed edges), and the arcs exist from node 1 to 2 with the cost of 10, from 1 to 3 with the cost of 2, and so on.\n\nHowever, the output is wrong. I have no idea where the program might fail. I took the main idea from here: http://community.topcoder.com/tc?module=Static&d1=tutorials&d2=standardTemplateLibrary2#dijkstra1\n(At the end it gives the idea for Dijkstra's Algorithm using a priority_queue).\n\nThanks in advance.\n\nRaul\n    ", "Answer": "\r\nThe problem is in the line\n\n```\nweights.resize(nrVertices+1);\n```\n\n\nin ```\nreadData()```\n. This sets up a vector with ```\nnrVertices+1```\n elements of value 0. Later on, you append the actual values you want to this vector using ```\nweights.push_back(INT_MAX);```\n.\n\nIn the actual Dijkstra algorithm, all interesting ```\nweights```\n are thus 0, instead of the ```\nINT_MAX```\n you want.\n\nReplace the line with\n\n```\nweights.resize(1);\n```\n\n\n(just to make sure that the index 1 really refers to the first element - you seem to use 1 as the first index instead of 0), and it might work.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Why does decreasekey in Dijkstra's algorithm take O(logN) time?\r\n                \r\nfor the updating part,\n\n```\nfor all neighbors w of u:\n    if dist[w] > dist[u] + l(u,w)\n        dist[w] = dist[u] + l(u,w)\n        prev[w] = u\n        decreasekey(H,w)\n```\n\n\nHere, w is the ID of the node, I think it should be like pair(ID,key) which key is the dist[ID]. \nIf so, finding the node with ID w on a priority queue should cost O(N) time rather than O(logN) time. \nThen, why is decreasekey in Dijkstra's algorithm takes O(logN) time?\n    ", "Answer": "\r\nThe heap implementation used for Dijktra is different from conventional priority queue implementation so inbuilt libraries of priority queue would not help you. The only solution is to implement your heap and keep track of position of each vertex in heap in an array. You need to update the pointers to vertex when u do insert or delete into heap. When u have to do decreaseKey in heap you have the direct location of vertex in heap and u can update the value of Key at that location . Use Heapify to reorder the heap (which takes O(logn)).\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm w/ Adjacency List Map c++\r\n                \r\nCurrently trying to implement dijkstra's algorithm in C++ by the use of an adjacency list in a text file read into a map object. The map is initialized as:\n\n```\nmap<int, vector<pair<int, int>>> = adjList;\n```\n\n\nSample text file input:\n\n```\n1 2,1 8,2\n2 1,1 3,1\n3 2,1 4,1\n4 3,1 5,1\n5 4,1 6,1\n6 5,1 7,1\n7 6,1 8,1\n8 7,1 1,2\n```\n\n\nWhere the key is a vertex, and the x values of the pairs in the vector are connected to the key vertex. The y values are the path distances. I pass that map into my dijkstra function, where I initialize a vector for shortest distances and a vector for storing visited vertices. My loop is where things start going wrong, as I get outputs of zeroes and very large numbers. Here's my code:\n\n```\n//checks if vertex has been visited or not\nbool booler(int vertex, vector<int> visited){\n    bool booly;\n    if(find(visited.begin(), visited.end(), vertex) != visited.end()){\n            booly = true;\n        }\n        else{\n            booly = false;\n        }\n    return booly;\n}\n//checks vector for the shortest distance vertex\nint minDist(vector<int> distances, vector<int> visited){\n    int minDist = 1000000;\n    int index;\n    for(int v = 0; v < distances.size(); v++){\n        if(booler(v, visited) == false && distances[v] < minDist){\n            minDist = distances[v];\n            index = v;\n        }\n    }\n    return index;\n}\nvoid dijkstra(int source, map<int, vector<pair<int, int>>> adjList, int vSize){\n    vector<int> distances(vSize, 1000000);\n    vector<int> visited = {};\n    distances[source] = 0;\n\n    for(int c = 0; c < distances.size(); c++){\n        int u = minDist(distances, visited);\n        visited.push_back(u);\n        for(int v = 1; v < distances.size(); v++){\n            for(int s = 0; s < adjList[u].size(); s++){\n                //updates distances based on v connection to u\n                if(booler(v, visited) == false && distances[u] < 1000000 && adjList[u][s].second + distances[u] < distances[v]){\n                    distances[v] = distances[u] + adjList[u][v].second;\n                }\n            }\n        }\n    }\n    //prints out shortest path\n    for(int x = 0; x < distances.size(); x++){\n        cout << distances[x] << \" \" << endl;\n    }\n\n}\n```\n\n\nI haven't been able to fix this error, any help would be greatly appreciated!\n    ", "Answer": "\r\nHere is an implement how to use dijkstra.\n\nhttps://www.quora.com/What-is-the-most-simple-efficient-C++-code-for-Dijkstras-shortest-path-algorithm\n\nIt is my solution for your problem:\n\n```\n#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nmap<int, vector<pair<int, int> > > mp;\n\nvoid addEdge(int u, int v, int dist) {\n    mp[u].push_back(make_pair(v, dist));\n}\n\nvoid startDijkstra(int u) {\n    vector<int> dist(1e2 + 1, 1e9);\n\n    set<pair<int, int> > st;\n    st.insert(make_pair(0, u));\n    dist[u] = 0;\n\n    while (!st.empty()) {\n        pair<int, int> now = *st.begin();\n        st.erase(st.begin());\n\n        int v = now.second;\n        int w = now.first;\n\n        const vector<pair<int, int> > &edges = mp[v];\n        for (const pair<int, int> &to : edges) {\n            if (w + to.second < dist[to.first]) {\n                st.erase(make_pair(dist[to.first], to.first));\n                dist[to.first] = w + to.second;\n                st.insert(make_pair(dist[to.first], to.first));\n            }\n        }\n    }\n\n    for (int i = 1; i <= 8; i++) {\n        cout << i << ' ' << dist[i] << endl;\n    }\n}\n\nint main() {\n    addEdge(1, 2, 1);\n    addEdge(1, 8, 2);\n\n    addEdge(2, 1, 1);\n    addEdge(2, 3, 1);\n\n    addEdge(3, 2, 1);\n    addEdge(3, 4, 1);\n\n    addEdge(4, 3, 1);\n    addEdge(4, 5, 1);\n\n    addEdge(5, 4, 1);\n    addEdge(5, 6, 1);\n\n    addEdge(6, 5, 1);\n    addEdge(6, 7, 1);\n\n    addEdge(7, 6, 1);\n    addEdge(7, 8, 1);\n\n    addEdge(8, 9, 1);\n    addEdge(8, 1, 2);\n\n    startDijkstra(1);\n\n    return 0;\n}\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Shortest path in a 2d array using Dijkstra's algorithm?\r\n                \r\nThis is my first time implementing Dijkstra's algorithm. Okay so here I have a simple 2D 9 by 9 array:\n\n\n\nStarting point is 1 and we're trying to get to any green square. Red squares are walls or lava (whatever satisfies your imagination).\n\nHow do I implement this in Java?\n\nComputer science is not my field hence I'm not a seasoned programmer so I might not know how to do some stack pushing, only loops and recursion :( please keep it easy as possible and bear with me!\n    ", "Answer": "\r\nHere's something similiar that should get you started. However, the solution presented below attempts to get to the bottom right corner. You can relax that condition to find the bottom row. You will also need to change the encoding slightly to have a unique value that represents this row.\n\n```\npublic class MazeSolver {\n\n    final static int TRIED = 2;\n    final static int PATH = 3;\n\n    // @formatter:off\n    private static int[][] GRID = { \n        { 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1 },\n        { 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1 },\n        { 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0 },\n        { 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1 },\n        { 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1 },\n        { 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1 },\n        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 } \n    };\n    // @formatter:off\n\n    public static void main(String[] args) {\n        MazeSolver maze = new MazeSolver(GRID);\n        boolean solved = maze.solve();\n        System.out.println(\"Solved: \" + solved);\n        System.out.println(maze.toString());\n    }\n\n    private int[][] grid;\n    private int height;\n    private int width;\n\n    private int[][] map;\n\n    public MazeSolver(int[][] grid) {\n        this.grid = grid;\n        this.height = grid.length;\n        this.width = grid[0].length;\n\n        this.map = new int[height][width];\n    }\n\n    public boolean solve() {\n        return traverse(0,0);\n    }\n\n    private boolean traverse(int i, int j) {\n        if (!isValid(i,j)) {\n            return false;\n        }\n\n        if ( isEnd(i, j) ) {\n            map[i][j] = PATH;\n            return true;\n        } else {\n            map[i][j] = TRIED;\n        }\n\n        // North\n        if (traverse(i - 1, j)) {\n            map[i-1][j] = PATH;\n            return true;\n        }\n        // East\n        if (traverse(i, j + 1)) {\n            map[i][j + 1] = PATH;\n            return true;\n        }\n        // South\n        if (traverse(i + 1, j)) {\n            map[i + 1][j] = PATH;\n            return true;\n        }\n        // West\n        if (traverse(i, j - 1)) {\n            map[i][j - 1] = PATH;\n            return true;\n        }\n\n        return false;\n    }\n\n    private boolean isEnd(int i, int j) {\n        return i == height - 1 && j == width - 1;\n    }\n\n    private boolean isValid(int i, int j) {\n        if (inRange(i, j) && isOpen(i, j) && !isTried(i, j)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    private boolean isOpen(int i, int j) {\n        return grid[i][j] == 1;\n    }\n\n    private boolean isTried(int i, int j) {\n        return map[i][j] == TRIED;\n    }\n\n    private boolean inRange(int i, int j) {\n        return inHeight(i) && inWidth(j);\n    }\n\n    private boolean inHeight(int i) {\n        return i >= 0 && i < height;\n    }\n\n    private boolean inWidth(int j) {\n        return j >= 0 && j < width;\n    }\n\n    public String toString() {\n        String s = \"\";\n        for (int[] row : map) {\n            s += Arrays.toString(row) + \"\\n\";\n        }\n\n        return s;\n    }\n\n}\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Getting wrong results with implementation of Dijkstra's algorithm using PriorityQueue\r\n                \r\nI have implemented Dijkstra's algorithm using the ```\nPriorityQueue```\n class of the ```\nqueue```\n module in Python.\nBut I am not always getting the correct result according to the online judge. Something must be missing in the below-given code, but I have no idea what.\nWhat is wrong with my code?\n```\nfrom queue import PriorityQueue\n\nclass Solution:\n    #Function to find the shortest distance of all the vertices\n    #from the source vertex S.\n    def dijkstra(self, V, adj, S):\n        #code here\n        q=PriorityQueue()\n        distance=[-1]*V\n        distance[S]=0\n        visited=set()\n        visited.add(S)\n        for i in adj[S]:\n            distance[i[0]]=distance[S]+i[1]\n            q.put([i[1],i[0]])\n        while not q.empty():\n            w,s=q.get()\n            visited.add(s)\n            for i in adj[s]:\n                d=distance[s]+i[1]\n                if distance[i[0]]==-1:\n                    distance[i[0]]=d\n                elif distance[i[0]]>d:\n                    distance[i[0]]=d\n                if i[0] not in visited:\n                    q.put([i[1],i[0]])\n        return distance\n            \n\n#{ \n#  Driver Code Starts\n#Initial Template for Python 3\n\nimport atexit\nimport io\nimport sys\n    \nif __name__ == '__main__':\n    test_cases = int(input())\n    for cases in range(test_cases):\n        V,E = map(int,input().strip().split())\n        adj = [[] for i in range(V)]\n        for i in range(E):\n            u,v,w = map(int,input().strip().split())\n            adj[u].append([v,w])\n            adj[v].append([u,w])\n        S=int(input())\n        ob = Solution()\n        \n        res = ob.dijkstra(V,adj,S)\n        for i in res:\n            print(i,end=\" \")\n        print()\n\n# } Driver Code Ends\n```\n\nSample Input for one test case:\n```\n9 14\n0 1 4\n0 7 8 \n1 7 11\n1 2 8\n7 6 1\n7 8 7\n2 8 2    \n8 6 6\n2 5 4\n2 3 7\n6 5 2\n3 5 14 \n3 4 9\n5 4 10\n0\n```\n\nExpected Output:\n```\n0 4 12 19 21 11 9 8 14\n```\n\nProblem:\nMy code returns this instead:\n```\n0 4 12 19 26 16 18 8 14\n```\n\n    ", "Answer": "\r\nThe problem is that you are giving priority to the edges with the least weight, but you should give priority to paths with the least weight.\nSo near the end of your code change:\n```\nq.put([i[1],i[0]])\n```\n\nto:\n```\nq.put([d,i[0]])\n```\n\nThis will solve it.\nHowever, some comments:\nIf you use a priority queue it should not be necessary to compare a previously stored distance for a node with a new distance, as the priority queue's role is to make sure you visit a node via the shortest path upon its first visit. With a bit of code reorganisation, you can get rid of that minimal-distance test.\nOnce you have that in place, you also do not need to have ```\nvisited```\n, as it is enough to check that the node's distance is still at -1 (assuming weights are never negative). When that is the case, it means you haven't visited it yet.\nIt is also a bit more efficient if you store tuples on the queue instead of lists.\nAnd you can reorganise the code so that you only need to push the initial cell to the queue before starting the traversal loop.\nFinally, instead of one letter variables, it is more readable if you use descriptive names, like ```\nnode```\n and ```\nweight```\n:\n```\nclass Solution:\n    def dijkstra(self, V, adj, S):\n        queue = PriorityQueue()\n        distances = [-1] * V\n        queue.put((0, S))\n        while not queue.empty():\n            dist, node = queue.get()\n            if distances[node] == -1:\n                distances[node] = dist\n                for neighbor, weight in adj[node]:\n                    queue.put((dist + weight, neighbor))\n        return distances\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Programming Dijkstra's algorithm in C++\r\n                \r\nI have an assignment, where I am given a graph and must use a two-dimensional array and find the shortest path from \"Macomb\" to \"Chicago\".  I am having difficulty figuring out how I should begin.  \n\nI have watched a few videos, and I feel that I have a grasp on how Dijkstra's algorithm works, but turning it into code is giving me a tough time.  \n\nI've created an adjacency matrix for my graph, where I use \"99\" to represent non-existant edges, I have an array created for a list of predecessors, and I have an array created for the remaining vertices.  I am supposed to output each new addition to the optimal path, and the current cost of each addition to the optimal path.  In the end, it should look like this:\n\nPath:  Macomb \nCost: 0\nPath:  Macomb --> Hope \nCost: 2\nPath:  Macomb --> Hope --> Love \nCost: 4\nPath:  Macomb --> Hope --> Love --> Peace \nCost: 5\nPath:  Macomb --> Hope --> Love --> Peace --> Belief \nCost: 6\nPath:  Macomb --> Hope --> Love --> Peace --> Belief --> Chicago\nCost: 8\n\nand here is the code I have to start with:\n\n```\n#include <iostream>\n\nusing namespace std;\n\n\n\nint main()\n{\nint graph[6][6] = {{99,2,9,5,99,99},\n                   {2,99,4,2,99,99},\n                   {9,4,99,1,1,5},\n                   {5,2,1,99,4,99},\n                  {99,99,1,4,99,2},\n                  {99,99,99,99,2,99}};\nstring pred[6] = {\"Macomb\", \" \", \" \", \" \", \" \", \" \"};\nstring cities[5] = {\"hope\", \"peace\", \"love\", \"belief\", \"Chicago\"};\nint distance[6];\n\n}\n```\n\n\nI'm not looking for someone to code my homework, but I would appreciate any pushes towards the right direction as this has been a tough assignment.  This is for a basic data structures class, and the only #include we've been using is what's in the code, so the less complicated of an answer the better.\n\nThank you!\n    ", "Answer": "\r\nHere's my implementation of Dijkstra's algorithm.\n\nhttps://github.com/Jesusfer2575/Reference/blob/master/dijkstra.cpp\n\nEnjoy it!\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Is the visited array really needed in Dijkstra's Algorithm using Priority Queue?\r\n                \r\n```\nvector<int> dijkstra(vector<vector<int>> &vec, int vertices, int edges, int source) \n{\n    vector <pair<int,int>> adj[vertices];\n    for (int i=0;i<edges;i++)\n    {\n        int u = vec[i][0];\n        int v = vec[i][1];\n        int w = vec[i][2];\n        \n        adj[u].push_back(make_pair(v,w));\n        adj[v].push_back(make_pair(u,w));\n    }\n    \n    vector<int> distance(vertices,INT_MAX);\n    distance[source]= 0;\n    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int> > > pq;\n    pq.push(make_pair(0,source));\n    \n    while(!pq.empty())\n    {\n        int dis = pq.top().first;\n        int node = pq.top().second;\n        pq.pop();\n        \n        for (auto adjacentNode : adj[node])\n        {\n            int currNode = adjacentNode.first;\n            int dfn = adjacentNode.second;\n            \n            if (dfn+dis < distance[currNode])\n            {\n                distance[currNode]= dfn+dis;\n                pq.push(make_pair(distance[currNode], currNode));\n            }\n        }\n    }\n\n    return distance;\n}\n```\n\nI was writing code for Dijkstra's Algorithm using priority queue but forgot to initialize the visited array to keep track of visited vertices. I submitted the code and all the test cases passed. Is the visited array really needed, or am I missing something?\n    ", "Answer": "\r\nSince your algorithm keeps track of the (so far) shortest distance to a node, the ```\nif (dfn+dis < distance[currNode])```\n statement will prevent the algorithm from revisiting nodes it had already visited, because the loop it made to revisit a node would add to the distance it already had for that revisited node, and so this condition is false (assuming positive weights).\nSo indeed, you don't need the visited array in this variant of Dijkstra's algorithm. See also how it is not there in the pseudo code that Wikipedia offers.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm: What to do if there are two or more nodes with minimal weight?\r\n                \r\nIn Dijkstra's algorithm what should I do if there are two or more nodes with minimal weights at a point in the algorithm?\n\nIn wikipedia: http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm at step no. 6, it says\n\n\"Set the unvisited node marked with the smallest tentative distance as the next 'current node' and go back to step 3.\"\n\nWhat if there are two or more nodes with \"smallest tentative distance\".\n\nCan anyone help me with the algorithm?\n    ", "Answer": "\r\nShort Answer\n\nJust pick either. Unless you have another heuristic to work with, you can't tell which would be better to pick.\n\n\n\nBit More Explaination\n\nThink about sorting some elements into an array:\n\n```\n9 6 3 3 8\n```\n\n\nsorted with lowest first is\n\n```\n3 3 6 8 9\n```\n\n\nIf you were to query that array to determine the lowest, the answer is ```\n3```\n. Which ```\n3```\n doesn't matter.\n\n\n\nSimilarly if you were to have some more information. Say for example that those ints were actually floats and were sorted by their integer parts. You might end up with the array:\n\n```\n3.2  3.1  6.0  8.5  9.2\n```\n\n\nHere you have another heuristic to work with, you can check the decimal part too, and you can determine that ```\n3.1```\n is the lowest.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Speeding up Dijkstra's algorithm to solve a 3D Maze\r\n                \r\nI'm trying to write a Python script that can solve 3D mazes and I'm doing it using Dijkstra's algorithm with a priority queue(included in the module heapq). Here is my main function code:\n\n```\nfrom heapq import *\ndef dijkstra(start,end,vertices,obstacles):\n    covered=[]\n    s=vertices.index(s)\n    currentVertex=s\n    liveDistances={}\n    for i in range(len(vertices)):\n        liveDistances[i]=inf\n    liveDistances[s]=0\n    next=[[liveDistances[s],s]]\n    while next:\n        np,currentVertex=heappop(next)\n        covered.append(currentVertex)\n        for u in sons(vertices[currentVertex]):\n            v=vertices.index(u)\n            if v in covered:continue\n            if 1+liveDistances[currentVertex]<liveDistances[v]:\n                liveDistances[v]=1+liveDistances[currentVertex]\n                heappush(next,[liveDistances[v],v])\n    if liveDistances[vertices.index(e)]!=inf:\n        return liveDistances[vertices.index(e)]\n    else:\n        return \"No path!\"\n```\n\n\nSo basically it's just Dijkstra's applied to a 3D graph.\n\nThe program works well but I'm wondering if it's normal that it solves a 100x100 2D maze in 10 seconds or a 30x30x30 maze in 2 minutes ?\nAm I implementing something wrong here ? Or is it just the right execution time ? Can I enhance it ?\n\nThe reason I'm seeking an enhancement is because I'm asked to solve the problem (Finding the shortest path in a 3D maze up to 40x40x40) in less than 5 seconds (The time limit).\n    ", "Answer": "\r\nI suspect that a lot of time will be spent in these two lines:\n\n```\nv=vertices.index(u)\nif v in covered:continue\n```\n\n\nboth of these lines are O(n) operations where n is the number of vertices in your graph.\n\nI suggest you replace the first with a dictionary (that maps from your vertex names to vertex indices), and the second by changing ```\ncovered```\n from a list to a set. \n\nThis should make both operations O(1) and could give you several orders of magnitude speed improvement.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra algorithm\r\n                \r\nI'm trying to implement dijkstra algorithm in C using double arrays with memory allocation (to solve it ina big big graph), but I can't make it run yet. My code doesn't turn any error, only that all answers are 0. Here it is, if you can i'm also looking for a way to do it without using multiple arrays (dimension matrix). \n\nADDED TEXTFILE, i keep getting ```\n[warning] passing arg 3 of dijkstra from incompatible pointer type```\n\n\n```\n#include &lt;stdio.h&gt;\n#define MAX 1000\n\nvoid dijkstra(int n,int v,int cost[n][n],int dist[n]);\n\nint main()\n{\n    int n,v, aux, aux1, aux2;\n\n    int arc;\n    FILE *archive;\n    archive= fopen(\"TEXTFILE.txt\",\"r\");\n    fscanf(archive,\"%d %d\",&n,&arc );\n    printf(\"%d %d \\n\",n, arc);\n    int dist[n];\n    int k = 0;\n    int rows = n;\n    int cols = n;\n    int i = 0;\n    int j = 0;\n    int **cost;\n    cost = malloc(rows * sizeof(int));\n    for (i = 0; i < rows; i++){\n        cost[i] = malloc(cols * sizeof(int));\n    }\n\n    while (!feof(archive)){\n        fscanf (archivo,\"%d %d %d\", &aux, &aux1, &aux2);\n        cost[aux][aux1] = aux2;\n        printf(\"%d %d %d\\n\", aux, aux1, cost[aux][aux1]);\n        aux = 0 ;\n        aux1 = 0;\n        aux2 = 0;\n    }\n\n    printf(\"\\n Enter the Source Node:\");\n    scanf(\"%d\",&v);\n\n    int h,u,count,w,flag[n],min;\n\n    for(h=0;h < n;h++)\n    {\n        flag[h]=0;\n        dist[h]=cost[v][h];\n    }\n    count=1;\n    while(count&lt;n)\n    {\n        min=MAX;\n        for(w=0;w < n;w++)\n        {\n            if(dist[w] < min && !flag[w])\n            {\n                min=dist[w];\n                u=w;\n            }\n        }\n        flag[u]=1;\n        count++;\n        for(w=0; w < n;w++)\n        {\n            if((dist[u] + cost[u][w] < dist[w]) && !flag[w])\n            {\n                dist[w] = dist[u] + cost[u][w];\n            }\n        }\n    }\n\n    printf(\"\\n   Shortest Path from Node %d: \",v);\n    printf(\"\\n#################################\\n\\n\");\n\n    for(h=0;h < n;h++)\n    {\n\n        printf(\"Distance to Node:%d is %d\\n\",(h+1),dist[h]);\n    }\n\n    system (\"PAUSE\");\n    return 0;\n\n}\n```\n\n\nTEXTFILE\n\n```\n10 16\n1 2  2 \n1 4  8\n2 4  4\n3 4  3\n3 5  4\n3 8  8\n4 5  7\n5 6  2\n5 7  2\n5 8  4\n6 7  1\n6 9  2\n7 8  1\n7 10 4\n8 10 4\n9 10 1\n```\n\n    ", "Answer": "\r\nThe logical error in your code is that you have set the values of cost matrix by reading from the file. But other values are zero by default, so you are always getting min as zero. So the pair of of nodes which don't have path between them are considered as the shortest distance. You need to make these cost INFINITE i.e. some very large value.\n\n```\nfor(i = 0;i < n;i++)  \nfor(j = 0;j < n;j++)  \n{\n    if(i!=j)\n    {\n        if(cost[i][j]==0)\n        {\n            cost[i][j] = INF;\n        }\n    }\n}\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "My implementation of Dijkstra's algorithm keeps messing up\r\n                \r\nI'm implementing Dijkstra's algorithm for school and my code keeps messing up. I've followed the pseudo-code on Wikipedia very closely. I implement the graph with a weighted adjacency list in this form so I check neighbours by iterating through the corresponding row.\n\nHere's my graph class, along with my vertex struct. \n\n```\nstruct vertex\n{\n    //constructor\n    vertex(size_t d_arg, size_t n_arg)\n    {\n        n = n_arg;\n        d = d_arg;\n    }\n\n    //member variables, n is name and d is distance\n    size_t n;\n    size_t d;\n\n    //overloaded operator so I can use std::sort in my priority queue\n    bool operator<(const vertex& rhs) const\n    {\n        return  d<rhs.d;\n    }\n\n};\n\nclass graph\n{\npublic:\n    graph(vector<vector<size_t> > v){ ed = v;};\n    vector<size_t> dijkstra(size_t src);\n    bool dfs(size_t src);\nprivate:\n    //stores my matrix describing the graph\n    vector<vector<size_t> > ed;\n};\n```\n\n\nThe function dfs implements a Depth-first Search to check if the graph's joint. I've got no problems with it. But the function dijkstra, however, gives me the wrong values. This is how it's implemented.\n\n```\nvector<size_t> graph::dijkstra(size_t src)\n{\n    //a vector storing the distances to the vertices and a priority queue\n    vector<size_t> dist;\n    dist[src] = 0;\n    p_q<vertex> q;\n\n    //set the distance for the vertices to inphinity, since they're size_t and -1 is largest\n    for (size_t i = 0; i < ed.size(); i++) {\n        if(i!=src)\n        {\n            dist.push_back(-1);\n        }\n\n        //push the vertices to the priority queue\n        vertex node(dist[i], i);\n        q.push(node);\n    }\n\n    //while there's stuff in the queue\n    while(q.size())\n    {\n        //c, the current vertex, becomes the top\n        vertex c = q.pop();\n\n        //iterating through all the neighbours, listed in the adjacency matrix\n        for(int i = 0; i < ed[0].size(); i++)\n        {\n            //alternative distance to i is distance to current and distance between current and i\n            size_t alt = dist[c.n] + ed[c.n][i];\n\n            //if we've found a better distance\n            if(alt < dist[i])\n            {\n                //new distance is alternative distance, and it's pushed into the priority queue\n                dist[i] = alt;\n                vertex n(alt, i);\n                q.push(n);\n            }\n\n        }\n    }\n\n    return dist;\n}\n```\n\n\nI can't see why I'm having trouble. I've debugged with this matrix.           \n\n```\n 0  3 -1  1 \n 3  0  4  1 \n-1  4  0 -1 \n 1  1 -1  0\n```\n\n\nAnd it didn't visit anything other than vertex 0 and vertex 3.           \n    ", "Answer": "\r\nOne of the problems is right at the beginning of ```\ngraph::dijkstra```\n, when an element of zero-sized array is assigned:\n\n```\nvector<size_t> dist;\ndist[src] = 0;\n```\n\n\nIt is OK in pseudo-code, but not in C++. Perhaps you may change like this:\n\n```\nvector<size_t> dist;\nfor (size_t i = 0; i < ed.size(); i++) {\n    if(i!=src)\n    {\n        dist.push_back(-1);\n    }\n    else\n    {\n        dist.push_back(0);\n    }\n    ....\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Python - Dijkstra's algorithm in O(V+ElogV) time complexity\r\n                \r\nI would like to implement the above mentioned algorithm in Python. Time Complexity of Dijkstra's Algorithm is O(V2), but I would like to implement it using min-priority queue so it drops down to O(V+ElogV).\nHeres an example input:\nThe program should 2 problems, src: 0 dest: 2 and src: 1 dest: 2. 3 vertexes will be provided by the input and there will be 3 edges provided also, all of these are separated by an empty line.\n```\n2\n3\n3\n\n0   2\n1   2\n\n2   0\n-4  1\n6   3\n\n1   0\n1   2\n0   2\n```\n\nSolution:\n```\n5.0     10.2\n```\n\nHeres my current code:\n```\nimport math\nimport sys\n \ndef build_graph(edges, weights, e):\n    graph = edges\n\n    for i in range(e):\n        graph[i].append(weights[i])\n        \n    return graph\n\ndef debug():\n    print(pontparok)\n    print(csucsok)\n    print(utszakaszok)\n    print(hosszak)\n\ndef read(n, bemenet):\n    for i in range(n):\n        temp = input().split(\"\\t\")\n        bemenet[i] = temp\n        bemenet[i][0] = int(bemenet[i][0])\n        bemenet[i][1] = int(bemenet[i][1])\n\ndef dijkstra(edges, src, dest, n):\n    dist = [0] * n\n    current = src\n\n    for i in range(n):\n        dist[i] = sys.maxsize\n    dist[src] = 0\n\n    explored = [False] * n\n\n    q = 0\n    while not explored[dest] and q < 1000:\n        q += 1\n        min = sys.maxsize\n        minVertex = current\n        for edge in edges:\n            if edge[0] == current and not explored[edge[1]]:\n                if min > dist[edge[1]]:\n                    min = dist[edge[1]]\n                    minVertex = edge[1]\n            elif edge[1] == current and not explored[edge[0]]:\n                if min > dist[edge[0]]:\n                    min = dist[edge[0]]\n                    minVertex = edge[0]\n        \n        current = minVertex\n        explored[current] = True\n        for edge in edges:\n            if edge[0] == current:\n                if dist[current] + edge[2] < dist[edge[1]]:\n                    dist[edge[1]] = dist[current] + edge[2]\n            elif edge[1] == current:\n                if dist[current] + edge[2] < dist[edge[0]]:\n                    dist[edge[0]] = dist[current] + edge[2] \n    \n    return round(dist[dest], 2)\n\np = int(input())\nn = int(input())\ne = int(input())\ninput()\n\npontparok = [[0] * 2] * p\ncsucsok = [[0] * 2] * n\nutszakaszok = [[0] * 2] * e\nhosszak = [0] * e\n\nread(p, pontparok)\ninput()\nread(n, csucsok)\ninput()\nread(e, utszakaszok)\n\nfor i in range(e):\n    hosszak[i] = math.sqrt(pow((csucsok[utszakaszok[i][0]][0] - csucsok[utszakaszok[i][1]][0]), 2) + pow((csucsok[utszakaszok[i][0]][1] - csucsok[utszakaszok[i][1]][1]), 2))\n\n#debug()\n\ngraph = build_graph(utszakaszok, hosszak, e)\n#print(hosszak)\n\nfor i in range(p):\n    if i == p - 1:\n        print(dijkstra(graph, pontparok[i][0], pontparok[i][1], n))\n    else:\n        print(dijkstra(graph, pontparok[i][0], pontparok[i][1], n), end=\"\\t\")\n```\n\n    ", "Answer": "\r\n```\nimport heapq\nimport math\n\ndef read(n, bemenet):\n    for i in range(n):\n        temp = input().split(\"\\t\")\n        bemenet[i] = temp\n        bemenet[i][0] = int(bemenet[i][0])\n        bemenet[i][1] = int(bemenet[i][1])\n\n\ndef dijkstra(graph, starting_vertex, destination_vertex):\n    distances = {vertex: float('infinity') for vertex in graph}\n    distances[starting_vertex] = 0\n\n    pq = [(0, starting_vertex)]\n    while len(pq) > 0:\n        current_distance, current_vertex = heapq.heappop(pq)\n\n        for neighbor, weight in graph[current_vertex].items():\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return round(distances[destination_vertex], 2)\n\ndef build_graph(edges, weights, e):\n    graph = edges\n\n    for i in range(e):\n        graph[i].append(weights[i])\n        \n    return graph\n\n\np = int(input())\nn = int(input())\ne = int(input())\ninput()\n\npontparok = [[0] * 2] * p\ncsucsok = [[0] * 2] * n\nutszakaszok = [[0] * 2] * e\nhosszak = [0] * e\n\nread(p, pontparok)\ninput()\nread(n, csucsok)\ninput()\nread(e, utszakaszok)\n\nfor i in range(e):\n    hosszak[i] = math.sqrt(pow((csucsok[utszakaszok[i][0]][0] - csucsok[utszakaszok[i][1]][0]), 2) + pow((csucsok[utszakaszok[i][0]][1] - csucsok[utszakaszok[i][1]][1]), 2))\n\ngraph2 = build_graph(utszakaszok, hosszak, e)\ngraph = { }\n[graph.setdefault(i, []) for i in range(n)] \nfor i in range(n):\n    graph[i] = {}\nfor edge in graph2:\n    graph[edge[0]].update({edge[1]: edge[2]})\n    graph[edge[1]].update({edge[0]: edge[2]})\n\nfor i in range(p):\n    if i == p - 1:\n        print(dijkstra(graph, pontparok[i][0], pontparok[i][1]))\n    else:\n        print(dijkstra(graph, pontparok[i][0], pontparok[i][1]), end=\"\\t\")\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm with an 2d-array\r\n                \r\nFor the past few days I've tried to implement this algorithm. This far I've managed to make a dynamic 2d array and insert the distances between nodes, a function to remove a path between nodes and a function that tells me if there is a path between two nodes.\nNow I would like to implement a function that returns the shortest path from node A to node B. I know how dijkstras algorithm works and I've read the pseudo code on wiki without being able to write any code my self. I'm really stuck here.\n\nI've been thinking about how the code should look like and what should happen thats why I've made that function that tells me if theres a path between two nodes. Do I need any more help functions which would make implementing of dijkstras easier?\n\nFor now I have only 3 nodes but the code I would like to write needs to work in general for n nodes.\n\nAny kind of help is appreciated. \n    ", "Answer": "\r\nYou are probably thinking to much.  \n\nYou need 2 things. A clean graph structure you understand. A good description of the algorithm you understand.\nIf you have both. Just start writing some code. Helpers needed will become obvious on the way.\n\n-- edit --\nYou will probably need some of the following datastructures\n```\nstd::vector```\n\n```\nstd::list```\n\n```\nstd::priority_queue```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Q: Dijkstra's algorithm C++ Finding shortest path from distances?\r\n                \r\nAfter many hours of confusion with graphing and Dijkstra's algorithm I have found a reliable way to get the shortest distances for my use but, my question is since I know the shortest distance why can I not find the path it took to get the shortest path? It seems pretty simple and I think I am just overlooking where I would get the paths.\nThis currently works to find the distance:\n```\nfloat* Graphing::dijkstra(int src, int flag){\n    float *dist;\n    dist = new float[verticies+1];\n    \n    MinHeap *minh;\n    minh = new MinHeap(verticies+1, flag);\n    \n    \n    for(int i = 0; i <= verticies; i++){\n        dist[i] = FLT_MAX;\n        heapEntry temp;\n        temp.weight = dist[i];\n        temp.dest = i;\n        minh->insertVal(temp);\n    }\n    dist[src] = 0;\n    minh->decValAtIndex(src, dist[src]);\n    while(minh->curSize>0){\n        heapEntry minNode = minh->extractMin();\n        \n        int u = minNode.dest;\n        \n        AdjListNode *cur = graph->array[u].head;\n        //Check adjacency list of minimum node;\n        while(cur){\n            int v = cur->dest;\n            \n            if(minh->isInMinHeap(v) && dist[u] != FLT_MAX && cur->weight + dist[u] < dist[v]){\n                dist[v] = dist[u] + cur->weight;\n                \n                minh->decValAtIndex(v, dist[v]);\n            }\n            cur = cur->next;\n        }\n        \n        \n    }\n    \n    for(int i = 1; i <= verticies; i++){\n        if(dist[i]!=FLT_MAX){\n            cout << i << \"\\t\" << dist[i] << endl;\n        }else\n            cout << i << \"\\tNone\"<< endl;\n    }\n}\n```\n\nEverything works and is tested for being the shortest path weight, my question is how would I be able to get the path for each of the vertices?\n*Edit:\nI got it working,\nWhat I did was make a new function that would get every possible path for one of the vertices (useful for my assignment) and take in the result of Dijkstra's algorithm compute each paths weights and compare with the results of Dijkstra. Maybe not the most efficient of solutions in terms of run time and space (everything) but its what works in my limited time. Thanks for the help.\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm in Graphs.jl package of Julia\r\n                \r\nFrom the documentation of ```\nGraphs.jl```\n:\n\nDijkstra’s Algorithm\n\n```\ndijkstra_shortest_paths(graph, edge_dists, source[, visitor])\n\nPerforms Dijkstra’s algorithm to find shortest paths to all vertices from input sources.\n\nParameters: \ngraph – The input graph\nedge_dists – The vector of edge distances or an edge property inspector.\nsource – The source vertex (or vertices)\nvisitor – An visitor instance\n\nReturns:    \nAn instance of DijkstraStates that encapsulates the results.\n```\n\n\nIt says ```\nsource```\n is the source vertex, or vertices. Does it mean that this function can deal with multiple origins? \n\nI am interested in finding shortest paths from multiple origins to multiple destinations. Can I do it using this function? Then, what the structure of ```\nparents```\n array from the result will be?\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Memory Usage for Dijkstra's Algorithm in Haskell\r\n                \r\nI've been learning Haskell as I find the language to be expressive, and to practice it, a friend has been giving me problems from Codeforces to do. The current problem I've been working on is to implement Dijkstra's Algorithm.\nBelow is a snippet of the algorithm (and here is the full code):\n```\ntype Edge = (Node, Distance)\n\ntype Route = [Node]\n\ntype Graph = Map Node [Edge]\n\n-- tracking which nodes we've gotten to\ntype VisitedNodes = Set Node\n\n-- set will be used as a priority queue, along with prev/curr nodes\ntype PriorityQueue = Set (Distance, (Node, Maybe Node))\n\n-- on the optimal path from start to end, what's the preceding node for a given node?\ntype PreviousMap = Map Node Node\n\n-- to declutter the function types\ntype DijkstraStructs = (VisitedNodes, PriorityQueue, PreviousMap)\n\ndijkstra :: Graph -> Node -> DijkstraStructs -> Maybe PreviousMap\ndijkstra graph target (visitedNodes, pq, prev)\n  | emptyPrioQueue = Nothing\n  | alreadyVisited = dijkstra graph target (visitedNodes, nextPq, prev)\n  | reachedTarget = Just nextPrevMap\n  | otherwise = dijkstra graph target (updatedVisitedNodes, neighborPq, nextPrevMap)\n  where\n    -- we've exhausted the search along the nodes we can reach when this is true\n    emptyPrioQueue = Set.null pq\n\n    -- greedy: find the edge leading to the tentatively closest node, and remove it\n    ((distance, (nearestNode, maybePrevNode)), nextPq) = Set.deleteFindMin pq\n    updatedVisitedNodes = Set.insert nearestNode visitedNodes\n\n    -- if the current node has been visited already, we will skip\n    alreadyVisited = nearestNode `Set.member` visitedNodes\n\n    -- for path-tracking\n    nextPrevMap = case maybePrevNode of \n      Nothing -> prev\n      Just prevNode -> Map.insert nearestNode prevNode prev\n\n    -- if the nearest node is the target node, then we're done. the path is encoded in the PreviousMap\n    reachedTarget = nearestNode == target\n\n    -- otherwise, keep searching. add all outgoing edges from current node into priority queue\n    neighbors = (Map.!) graph nearestNode\n    neighborPq = foldr (\\(toNode, w) -> Set.insert (distance + w, (toNode, Just nearestNode))) nextPq neighbors\n```\n\nI believe my implementation of the algorithm is correct, but I suspect it's memory inefficient, as my submissions to Codeforces exceed the memory limit for large inputs (e.g., 50k nodes // 100k edges -- my algorithm uses more than 64MB on such a case).\nWhile my immediate goal is to iterate on my algorithm in order to successfully submit it, my longer term goal is to learn how to reason about the memory usage of Haskell code in general.\nI suspect a large portion of memory might be attributed to \"versioning\" of the intermediate Sets and Maps, but I am not sure how to think about the impact of \"mutating\" (i.e., creating new versions) of immutable data structures in Haskell.\nIn an attempt to profile my code, I followed a procedure I found on this site, which helped me detect and fix a stack overflow from using foldr for large inputs, but sadly I haven't been able to use this approach to measure the memory usage of the algorithm itself.\nI would love to learn how to optimize the memory usage of this code, as well as learn how to profile/measure and reason about memory usage in Haskell. Improvements to this code, as well as general stylistic feedback is welcome.\n    ", "Answer": "\r\nThe main problem to worry about is space leaks. When is each argument of your ```\ndijkstra```\n function forced?\n```\ngraph```\n and ```\ntarget```\n are constant. ```\nvisitedNodes```\n is forced by the ```\nalreadyVisited```\n guard. ```\npq```\n is forced by the ```\nemptyPrioQueue```\n guard. But there is nothing to force ```\nprev```\n, so it gets thunked: the ```\ncase```\n expression of ```\nnextPrevMap```\n is delayed until the very end of the whole execution, when the final ```\nPreviousMap```\n is evaluated. So you have a chain of thunks that is about as long as the number of visited nodes.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Modify Dijkstra's Algorithm to get the Shortest Path Between Two Nodes\r\n                \r\nSo I've seen similar questions to this but not quite exactly what I'm looking for.  I need to modify Dijkstra's Algorithm to return the shortest path between a vertex S (source) and a vertex X (destination).  I think I've figured out what to do, but I'd like some help.  Here is the pseudocode I have modified.\n\n```\n 1  function Dijkstra(Graph, source, destination):\n 2      for each vertex v in Graph:                                // Initializations\n 3          dist[v] := infinity ;                                  // Unknown distance function from \n 4                                                                 // source to v\n 5          previous[v] := undefined ;                             // Previous node in optimal path\n 6      end for                                                    // from source\n 7      \n 8      dist[source] := 0 ;                                        // Distance from source to source\n 9      Q := the set of all nodes in Graph ;                       // All nodes in the graph are\n10                                                                 // unoptimized - thus are in Q\n11      while Q is not empty:                                      // The main loop\n12          u := vertex in Q with smallest distance in dist[] ;    // Start node in first case\n13          remove u from Q ;\n14          if dist[u] = infinity:\n15              break ;                                            // all remaining vertices are\n16          end if                                                 // inaccessible from source\n17          \n18          for each neighbor v of u:                              // where v has not yet been \n19                                                                 // removed from Q.\n20              alt := dist[u] + dist_between(u, v) ;\n21              if alt < dist[v]:                                  // Relax (u,v,a)\n22                  dist[v] := alt ;\n23                  previous[v] := u ;\n24                  decrease-key v in Q;                           // Reorder v in the Queue\n25              end if\n26          end for\n27      end while\n28  return dist[destination];\n```\n\n\nThe code was taken from Wikipedia and modified: http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\n\nDoes this look correct?\n    ", "Answer": "\r\nDijkstra's algorithm does not need to be modified, it is an all-pairs shortest path algorithm. It seems like you are trying to find the shortest path between two specific nodes - Dijkstra handles this fine.\n\nIf you want something that's designed specifically for an unweighted, undirected graph, which is what it seems like you're doing, I would suggest doing a BFS.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "dijkstra algorithm incorrect conditional\r\n                \r\nI am working on a dijkstra algorithm using priority queues. I have been doing a lot of research, and I thought my code was following the algorithm, but I cannot get into the conditional when comparing for the shortest paths\n\n```\n    void dijkstra( int startingID ) {\n\n        priority_queue<Vertex*, vector<Vertex*>, PathWeightComparer> dijkstra_queue{};\n        vector<Vertex*> vert;\n        vert = _vertices;\n        int n = vert.size();\n        vector< double > dis(n);\n\n        for (int i = 0; i < n; i++)\n        {\n            dis[i] = std::numeric_limits< double >::infinity();\n        }\n        vert[startingID]->setPathWeight(startingID);\n        dis[startingID] = 0;\n        Vertex* temp = vert[startingID];\n        dijkstra_queue.push(temp);\n\n\n        while (!dijkstra_queue.empty())\n        {\n            double dist = dijkstra_queue.top()->getPathWeight();\n            double u = dijkstra_queue.top()->getId();\n            dijkstra_queue.pop();\n\n            for (auto i : vert)\n            {\n                double v = i->getId();\n                double weight = i->getPathWeight();\n                double distance_total = dist + weight;\n                cout << \"distance_total \" << distance_total << \" dis[v] \" << dis[v] << endl;\n                if (distance_total < dis[v]) //PROBLEM\n                {\n                    dis[v] = distance_total;\n                    Vertex* temp2 = i;\n                    temp2->setPathWeight(dis[v]);\n                    dijkstra_queue.push(temp2);\n                }\n            }\n        }\n    }\n};\n```\n\n\nHere is the graph class\n\n```\nclass Graph\n{\n    vector<Vertex*> _vertices;      // All vertices in the graph (vertex id == index)\n    int _last_startingID = -1;\n```\n\n\nAnd here is the vertex class\n\n```\nclass Vertex\n{\nprivate:\n    int _id;                    // ID (key) of given vertice\n    bool _known = false;        // Dijkstra's algorithm \"known\" flag\n    Vertex* _path = nullptr;    // Dijkstra's algorithm parent vertex pointer\n        // Weight of path through graph - starts at a true infinity (inf)\n    double _path_weight = std::numeric_limits<double>::infinity();\n```\n\n\nI tried to only include the code that was relavent to only the dijkstra function, but if anything is unclear I can add more. \n    ", "Answer": "\r\nYour implementation of the algorithm is incorrect.\n\nAfter you ```\npop()```\n vertex ```\nu```\n from the queue (because it's distance from the source is the lowest) you should ONLY inspect vertices that are directly reachable from ```\nu```\n (i.e. an edge exists from ```\nu```\n to that vertex).\n\nYour current implementation seems to be looping through ALL vertices regardless of whether they are directly reachable from ```\nu```\n or not, and perhaps as a result, you are doing something strange with the distance calculation that makes no sense. More specifically, ```\ndistance_total```\n in your implementation seems nonsensical.\n\nThe key idea behind Dijkstra's algorithm is:\n\n```\ndis[u] = must be shortest path from source to u since u was popped.\ndis[v] = current_known_distance_to_v\n\nThen, for all v where edge exists from u to v:\nIF dis[u] + weight(u, v) < dis[v]:\n    // going via u is better than the current best known distance to v\n    dis[v] = dis[u] + weight(u, v)\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra Algorithm infinite loop\r\n                \r\nI'm learning about shortest path algorithms, and I'm trying to implement A Dijkstra Algorithm that takes the input from a file like this:\n\n```\n    7\n    A\n    B\n    C\n    D\n    E\n    F\n    G\n    A B 21\n    A C 14\n    B E 5\n    B D 7\n    D F 3\n    E C 44\n    E G 53\n    E D 123\n    G F 51\n```\n\n\nThe problem is when i add an extra edge to some vertex like D B 12,:\n\nDIJKSTRA ALGORITHM:\n\n```\npublic Set<Vertex> dijkstraAlgo(Graph G, int s) {\n    initializeSingleSource(G, s);\n    Set<Vertex> set = new HashSet<Vertex>(); // intitially empty set of\n                                                // vertexes\n\n    Queue<Vertex> Q = new PriorityQueue<Vertex>(10, new VertexComparator()); // min\n                                                                                // priority\n                                                                                // queue\n\n    for (Vertex v : G.vertices) { // add source to priority queue\n        Q.add(G.vertices[s]);\n    }\n\n    while (Q.size() != 0) {\n        Vertex u = Q.poll(); // extract vertex which have min distance in\n                                // priority queue\n        set.add(u); // add that vertex to set\n        for (String vertexId : u.neighbours.keySet()) { // see neighbours of\n            // vertex extracted\n            int vertexNum = indexForName(G, vertexId);\n\n            Vertex v = G.vertices[vertexNum];\n            int w = weightFunc(G, u, v);\n\n            relax(u, v, w);\n            Q.add(v);\n        }\n    }\n\n    return set;\n\n}\n```\n\n\nREADING THE FILE:\n\n```\npublic class Graph {\n Vertex[] vertices;\n\n\npublic Graph(String file) throws FileNotFoundException{\n  Scanner sc = new Scanner(new File(file));\n  vertices=new Vertex[sc.nextInt()];\n\n  for (int v = 0; v < vertices.length; v++){\n    vertices[v] = new Vertex(sc.next());\n  }\n\n    while (sc.hasNext()) {\n    int v1= indexForName(sc.next());     //read source vertex\n    String destination=sc.next();        //read destination vertex \n\n    int w=sc.nextInt();                  //read weight of the edge\n\n\n    vertices[v1].neighbours.put(destination, w);   //put the edge adjacent to source vertex\n    }\n    sc.close();\n```\n\n\n}\n\nMAIN:\n\n```\npublic static void main(String[] args) throws FileNotFoundException {\n    String fileName = \"Dijikstra.txt\";\n    Dijkstra dijkstra = new Dijkstra(fileName);\n\n    Set<Vertex> vertexInfo = dijkstra.dijkstraAlgo(dijkstra.graph, 0);\n    System.out\n            .println(\"Printing min distance of all vertexes from source vertex A \");\n    for (Vertex v : vertexInfo) {\n        System.out.println(\"Id: \" + v.id + \" distance: \" + v.d + \" Comming From \" + v.p);\n    }\n}\n```\n\n\nVERTEX:\n\n```\nclass Vertex{\n   String id;    \n    int d;        //to store min distance from source\n    Vertex p;     //to store last vertex from which min distance is reached\nMap<String,Integer> neighbours;   //to store edges of adjacent to the vertex            \n\n    public Vertex(String id){\n    this.id=id;\n    neighbours=new HashMap<String,Integer>();\n   }\n }\n```\n\n    ", "Answer": "\r\n```\nfor (Vertex v : G.vertices) { // add source to priority queue\n        Q.add(G.vertices[s]);\n    }\n```\n\n\nWhy are you adding every Vertex to the Priority Queue instead of just the initial one? What does your Vertex class look like?\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "dijkstra's algorithm how do you set values to infinity? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        How can I represent an infinite number in Python?\r\n                            \r\n                                (13 answers)\r\n                            \r\n                    \r\n                Closed last year.\r\n        \r\n\r\n\r\n    \r\n\r\nHi im wroking on dijkstra's algorithm and the first hint in the comments is, '''For all the nodes in the graph, set distance equal to infinity and previous equal to none '''\nWhat does he mean by this how do you set the values equal to infinity?Also \nin the method there is not end so im guessing just to make the end the adjacent node ? Im saying this because there is a are_adjacent method\nThis is the little i have\n\n```\ndef are_adjacent(self, value1, value2):\n    return(self.find(value1).is_adjacent(self.find(value2)))\n\n\ndef dijkstra(self, start): \n```\n\n    ", "Answer": "\r\nYou can set a value as infinite:\n\n```\nvalue = float('inf')\n```\n\n\nOr in python 3.5:\n\n```\nimport math\nvalue = math.inf\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra Algorithm Time Complexity\r\n                \r\nI am new to Dijkstra Algorithm.\nMy question is that: for an undirected graph G with n nodes and m edges, the time complexity for Dijkstra Algorithm to find shortestst path is o((n+m)logn). However, if the G is connected, why this time complexity can be also expressed as o(mlogn)?\nCheers\n    ", "Answer": "\r\nIf it is not connected, say in the case where there is only one edge (m=1), then it can be it is o(nlgn). That is why in the general case it is o((m+n)lgn).\nIf it is connected, there should be a tree that connects the whole graph (length n-1), so m is at least n-1: (```\nm>=n-1```\n). So for purposes of small O notation (Small O:f is dominated by g asymptotically), I can replace n by m: o((m+1+m)lgn) \"=\" o(mlgn)\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Find the cost of all paths in a matrix using Dijkstra's Algorithm in Python\r\n                \r\nI'm trying to create a program that from a starting coordinate finds the lowest cost path of traveling to all of the other coordinates in a matrix using Dijkstra's Algorithm. Any coordinate that has an infinite value is avoided when traversing.\n    ", "Answer": "\r\nYou are confusing ```\nnode```\n and ```\ncurrent_node```\n:\n```\n        x_check = node[0] + move[0]\n        y_check = node[1] + move[1]\n```\n\nshould be\n```\n        x_check = current_node[0] + move[0]\n        y_check = current_node[1] + move[1]\n```\n\nBy the way, in Python, you are allowed to write\n```\n        if 0 <= x_check <= N-1 and 0 <= y_check <= N-1:\n```\n\nwhich is much more readable !\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Printing Dijkstra Algorithm from predecessors\r\n                \r\nI am attempting to print Dijkstra's algorithm, but currently only the destination ID is printing from my getPath() method. My idea was to work backwards from the destination vertex and print each predecessor, until the start vertex was printed. If there is another way to store/print the path I would be more than open to trying it a different way, I appreciate any ideas!\n\n```\nclass ShortestPathFinder {\n        private  Graph graph = new Graph();\n        private  Vertex source = new Vertex(0, null);\n        private Vertex destination = new Vertex(0,null);\n\n        private  Map<Vertex,Vertex> previousVertex = new HashMap();\n        private  Set<Vertex> visited =  new HashSet();\n\n    public Optional<Path> findShortestPath(Graph graph, Vertex source, Vertex destination, ReadInput graphReader) {\n\n        this.destination = destination;\n        this.source = source;\n        Optional<Path> pathFound = Optional.empty();\n        source.setDistanceFromSource(0);\n        PriorityQueue<Vertex> priorityQueue = new PriorityQueue<>();\n        priorityQueue.add(source);\n        source.setVisited(true);\n        boolean destinationFound = false;\n\n        while( !priorityQueue.isEmpty() && destinationFound == false){\n            // Getting the minimum distance vertex from priority queue\n            Vertex actualVertex = priorityQueue.poll();\n            System.out.println(\"working on: \" + actualVertex.getID());\n\n            actualVertex = graphReader.SetAdjList(actualVertex);\n\n            for(Edge edge : actualVertex.getAdjacenciesList()){\n                Vertex v = edge.getTargetVertex();\n                System.out.println(\"a Neighbor is: \" + v.getID());\n                if(!v.isVisited()) {\n                    if(v.getID() == destination.getID()) {\n                        System.out.println(\"Destination found\");\n                        Path path = new Path(previousVertex);\n                        pathFound = Optional.of(path);\n                        destinationFound = true;\n                        break;\n                    }\n                    double newDistance = actualVertex.getDistanceFromSource() + edge.getWeight();\n\n                    if( newDistance < v.getDistanceFromSource() ){\n                        priorityQueue.remove(v);\n                        v.setDistanceFromSource(newDistance);\n                        v.setPredecessor(actualVertex);\n                        priorityQueue.add(v);\n                        System.out.println(\"Added: \" + v.getID());\n                    }\n                }\n            }\n            actualVertex.setVisited(true);\n        }   \n        return pathFound;       \n    }\n\n    public List<Vertex> getPath() {\n        List<Vertex> path = new ArrayList<>();\n\n        for(Vertex vertex=destination;vertex!=null;vertex=vertex.getPredecessor()){\n            path.add(vertex);\n        }\n        Collections.reverse(path);\n        return path;\n\n    }       \n}\n```\n\n    ", "Answer": "\r\nThe following portion in your code is called when the destination is reached:\n\n```\n                    if(v.getID() == destination.getID()) {\n                        System.out.println(\"Destination found\");\n                        Path path = new Path(previousVertex);\n                        pathFound = Optional.of(path);\n                        destinationFound = true;\n                        break;\n                    }\n```\n\n\nThat respective v never has its predecessor set, which is what your ```\ngetPath()```\n method depends on. Consider setting it in the if-statement, as such:\n\n```\n                    if(v.getID() == destination.getID()) {\n                        System.out.println(\"Destination found\");\n                        destination.setPredecessor(actualVertex); // sets the predecessor for backwards traversal\n                        Path path = new Path(previousVertex);\n                        pathFound = Optional.of(path);\n                        destinationFound = true;\n                        break;\n                    }\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm , C++, Priority Queue, Adjacency List\r\n                \r\n```\n#include <iostream>\n#include <fstream>\n#include <functional>\n#include <climits>\n#include <vector>\n#include <queue>\n#include <list>\n\nusing namespace std;\n\nstruct Vertices {\n    int vertex;\n    int weight;\n    Vertices(int v, int w) : vertex(v), weight(w) { };\n    Vertices() { }\n};\n\nclass CompareGreater {\n    public:\n        bool const operator()(Vertices &nodeX, Vertices &nodeY) {\n            return (nodeX.weight > nodeY.weight) ;\n        }\n};\n\nvector< list<Vertices> > adj;\nvector<int> weights;\npriority_queue<Vertices, vector<Vertices>, CompareGreater> Q;\n\nint nrVertices, nrEdges;\n\n\nvoid Dijkstra(Vertices);\n\n\nvoid makeGraph() {\n\n    ifstream myFile;\n\n    myFile.open(\"graph.txt\");\n\n\n    myFile >> nrVertices >> nrEdges;\n\n    adj.resize(nrVertices+1);\n\n\n    int nodeX, nodeY, weight;\n\n\n    for (int i = 1; i <= nrVertices; ++i) {\n        weights.push_back(INT_MAX);\n    }\n\n    for (int i = 1; i <= nrEdges; ++i) {\n        myFile >> nodeX >> nodeY >> weight;\n        adj[nodeX].push_back(Vertices(nodeY, weight));\n    }\n}\n\nvoid printPath()\n{\n    for (vector<int>::iterator itr = weights.begin()+1; itr != weights.end(); ++itr) {\n        cout <<  (*itr) << \" \"<<endl;\n    }\n\n}\n\nvoid Dijkstra(Vertices startNode) {\n    Vertices currVertex;\n\n    weights[startNode.vertex] = 0;\n    Q.push(startNode);\n\n    while (!Q.empty()) {\n        currVertex = Q.top();\n        Q.pop();\n\n        cout<<\"Removed \"<<&currVertex<<\"from heap\"<<endl;\n\n        if (currVertex.weight <= weights[currVertex.vertex]) {\n            for (list<Vertices>::iterator it = adj[currVertex.vertex].begin(); it != adj[currVertex.vertex].end(); ++it)\n            {\n                if (weights[it->vertex] > weights[currVertex.vertex] + it->weight) {\n                    weights[it->vertex] = weights[currVertex.vertex] + it->weight;\n                    Q.push(Vertices((it->vertex), weights[it->vertex]));\n                }\n            }\n        }\n    }\n}\n\nint main() {\n\n    makeGraph();\n    Dijkstra(Vertices(1, 0));\n    printPath();\n\n    return 0;\n}\n```\n\n\nSo this is my code to implement Dijkstra's algorithm with an adjacency list. With input:\n\n```\n7\n2\n2  2\n4  1\n2\n4  3\n5  10\n2\n1  4\n6  5\n4\n3  2\n5  2\n6  8\n7  4\n1\n7  6\n0\n1\n6  1\n```\n\n\nThis means that there exists 7 vertices in order from vertex 1 to 7. Vertex 1 has 2 edges, one to vertex 2 with weight 2, the second to vertex 4 with weight 1. Vertex 2 has 2 edges, the first to vertex 4 with weight 3, the second to vertex 5 with weight 10. Vertex 3 has 2 edges, the first to vertex 1 with weight 4, the second to vertex 6 with weight 5. And so forth.\n\nHowever, it print out this:\n\n```\nRemoved 0xbfb9d7a8from heap\nRemoved 0xbfb9d7a8from heap\n0 \n4 \n2147483647 \n2147483647 \n2147483647 \n2147483647 \n```\n\n\nWhen I need it to print out this:\n\n```\nV1: V2, 2; V4, 1\nV2: v4, 3; V5, 10\nV3: V1, 4; V6, 5\nV4: V3, 2; V5, 2; V6, 8; V7, 4\nV5: V7, 6\nV6:\nV7: V6, 1\nRemoved minimum 1 from heap\nPrint heap: V2, d=inf V4., d=inf v3, d= inf v7, d=inf v5......\n```\n\n\nPlease help!!!!!\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Small Modification to Particular Implementation of Dijkstra's Algorithm\r\n                \r\nOver the past few weeks I've been playing with a variety of implementations of Dijkstra's algorithm as part of a personal project (mainly to test performance). I have recently come across this implementation of the algorithm, which I have tested and everything. However, I'm currently trying to modify that implementation so it takes an additional argument to represent the destination node, which means I want the algorithm to run only once from a specified source to a specified destination rather than to all other nodes in the graph.\n\nI tried adding a third ```\ntargetNode```\n parameter but the ```\ndest```\n variable found in the implementation is of type ```\nEntry<T>```\n and my parameter was of type ```\nNode```\n (a custom class I wrote), so I eventually got an incompatible types error message. \n\nIs it possible to somehow make this modification? I did it easily with another implementation but I can't seem to figure it out for this one mainly due to the different types ```\nNode```\n and ```\nEntry<T>```\n. It's not really a big deal but I would like to do it. \n\nThanks!\n\nEDIT: Here's what I did: \n\n```\npublic static <Node> Map<Node, Double> dijkstraFibonacciHeap(DirectedGraph<Node> graph, Node source, Node target) {\n    FibonacciHeap<Node> priorityQueue = new FibonacciHeap<>();  \n    Map<Node, FibonacciHeap.Entry<Node>> entries = new HashMap<>();\n    Map<Node, Double> result = new HashMap<>();\n\n    for (Node node : graph) {\n        entries.put(node, priorityQueue.enqueue(node, Double.POSITIVE_INFINITY));\n    }\n\n\n    priorityQueue.decreaseKey(entries.get(source), 0.0);\n\n    while (!priorityQueue.isEmpty()) {\n\n        FibonacciHeap.Entry<Node> curr = priorityQueue.dequeueMin();\n\n        result.put(curr.getValue(), curr.getPriority());\n\n        for (Map.Entry<Node, Double> arc : graph.edgesFrom(curr.getValue()).entrySet()) {\n\n            if (result.containsKey(arc.getKey())) {\n                continue;\n            }\n\n            double pathCost = curr.getPriority() + arc.getValue();\n\n            // Error occurrs here. \n             target = entries.get(arc.getKey());\n            if (pathCost < target.getPriority()) {\n                priorityQueue.decreaseKey(target, pathCost);\n            }\n        } \n    }\n    return result;\n}\n```\n\n    ", "Answer": "\r\nDijkstra's algorithm works by finding shortest paths from the source node to every other node in the graph.  You can terminate it early once it finds the shortest path to your target node, of course, but this doesn't necessarily lead to much of a speedup.\n\nThe \"meet-in-the-middle\" trick can be useful if you're really trying to speed up shortest-path finding, though.  You run shortest paths from the source simultaneously with shortest paths from the sink (treating every edge as its reverse); once both searches have reached the same node, you can reconstruct a shortest source-to-target path.\n\nA* is another way to go if you have a good guess as to what your graph looks like.\n\nI should also point out that another really, really easy optimisation to this code is to stop wrapping everything in objects.  You're paying a lot, both in space and in speed, for wrapping ```\ndouble```\ns in ```\nDouble```\n classes and whatever your ```\nNode```\ns are in classes as well.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm java implementation bug\r\n                \r\nSo first of all this is HW, so try not to just give me the answer right away, but I'm having trouble programming Dijstra's Algorithm. The lab has us build a priority Queue, which I have made and passes the given JUnit tests so I think it's correct. The second part of the lab had us use the queue in an implementation of dijstra's algorithm. Here is my code for Dijkstra's\n\n```\n/**\n * Compute shortest paths in a graph.\n *\n * Your constructor should compute the actual shortest paths and\n * maintain all the information needed to reconstruct them.  The\n * returnPath() function should use this information to return the\n * appropriate path of edge ID's from the start to the given end.\n *\n * Note that the start and end ID's should be mapped to vertices using\n * the graph's get() function.\n */\n\nclass ShortestPaths {\n\n    Multigraph graph;\n    final int INF = Integer.MAX_VALUE;\n    PriorityQueue<Integer> Q;\n    int n;\n    int dist[];\n    Handle handles[];\n    Edge edge[];\n\n    /**\n     * Constructor\n     */\n    public ShortestPaths(Multigraph G, int startId) {\n        Q = new PriorityQueue<Integer>();\n        graph = G;\n        n = graph.nVertices();\n        dist = new int [n];\n        edge = new Edge [n];\n        handles = new Handle[n];\n\n        for (int i = 0; i<n; i++){\n            dist[i] = INF;\n        }\n        dist[startId] = 0;\n\n        Handle h = Q.insert(startId, dist[startId]);\n        handles[startId] = h;   \n        Q = new PriorityQueue<Integer>();\n        while (!Q.isEmpty()){\n            Vertex v = graph.get(Q.min());\n            Q.extractMin();\n            while (v.adj().hasNext()){\n                relax(v.adj().next());  \n            }       \n        }   \n    }\n\n    private void relax(Edge e) {\n        Handle h;\n        int v = e.from().id();\n        int w = e.to().id();\n        if (dist[w] > dist[v] + e.weight()) {\n            dist[w] = dist[v] + e.weight();\n            edge[w] = e;\n            if (handles[w].getIndex() != -1){\n                Q.decreaseKey(handles[w], dist[w]);\n            }\n            else{\n                h = Q.insert(w, dist[w]);\n                handles[w] = h;\n            }\n        }\n    }\n\n    /**\n     * Calculates the list of edge ID's forming a shortest path from the start\n     * vertex to the specified end vertex.\n     *\n     * @return the array\n     */\n    public int[] returnPath(int endId) {\n        int c = 0;\n        int[] path = new int[edge.length];\n        for (Edge e = edge[endId]; e != null; e = edge[e.from().id()]) {\n            path[c] = e.id();\n            c++;\n        }\n        return path;\n    }\n\n\n}\n```\n\n\nJust so you know, a handle is simply an object which stores the index of the associated key-value pair, that way we can find it later. The handles update automatically, you can see this in the swap procedure in my priority queue. Anyway, The issue is that my edge[] array is populated with null for some reason, so I can't return any paths. How do I fix my algorithm to update edge[] correctly? Any help would be appreciated. Just tell me if you would like more information. Also I will post the Vertex and Edge classes in case you want to look at those.\n    ", "Answer": "\r\nI noticed one error:\n\n```\nQ = new PriorityQueue<Integer>();\nwhile (!Q.isEmpty()){ // <-- Q is always empty beсause of previous line\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm java implementation bug\r\n                \r\nSo first of all this is HW, so try not to just give me the answer right away, but I'm having trouble programming Dijstra's Algorithm. The lab has us build a priority Queue, which I have made and passes the given JUnit tests so I think it's correct. The second part of the lab had us use the queue in an implementation of dijstra's algorithm. Here is my code for Dijkstra's\n\n```\n/**\n * Compute shortest paths in a graph.\n *\n * Your constructor should compute the actual shortest paths and\n * maintain all the information needed to reconstruct them.  The\n * returnPath() function should use this information to return the\n * appropriate path of edge ID's from the start to the given end.\n *\n * Note that the start and end ID's should be mapped to vertices using\n * the graph's get() function.\n */\n\nclass ShortestPaths {\n\n    Multigraph graph;\n    final int INF = Integer.MAX_VALUE;\n    PriorityQueue<Integer> Q;\n    int n;\n    int dist[];\n    Handle handles[];\n    Edge edge[];\n\n    /**\n     * Constructor\n     */\n    public ShortestPaths(Multigraph G, int startId) {\n        Q = new PriorityQueue<Integer>();\n        graph = G;\n        n = graph.nVertices();\n        dist = new int [n];\n        edge = new Edge [n];\n        handles = new Handle[n];\n\n        for (int i = 0; i<n; i++){\n            dist[i] = INF;\n        }\n        dist[startId] = 0;\n\n        Handle h = Q.insert(startId, dist[startId]);\n        handles[startId] = h;   \n        Q = new PriorityQueue<Integer>();\n        while (!Q.isEmpty()){\n            Vertex v = graph.get(Q.min());\n            Q.extractMin();\n            while (v.adj().hasNext()){\n                relax(v.adj().next());  \n            }       \n        }   \n    }\n\n    private void relax(Edge e) {\n        Handle h;\n        int v = e.from().id();\n        int w = e.to().id();\n        if (dist[w] > dist[v] + e.weight()) {\n            dist[w] = dist[v] + e.weight();\n            edge[w] = e;\n            if (handles[w].getIndex() != -1){\n                Q.decreaseKey(handles[w], dist[w]);\n            }\n            else{\n                h = Q.insert(w, dist[w]);\n                handles[w] = h;\n            }\n        }\n    }\n\n    /**\n     * Calculates the list of edge ID's forming a shortest path from the start\n     * vertex to the specified end vertex.\n     *\n     * @return the array\n     */\n    public int[] returnPath(int endId) {\n        int c = 0;\n        int[] path = new int[edge.length];\n        for (Edge e = edge[endId]; e != null; e = edge[e.from().id()]) {\n            path[c] = e.id();\n            c++;\n        }\n        return path;\n    }\n\n\n}\n```\n\n\nJust so you know, a handle is simply an object which stores the index of the associated key-value pair, that way we can find it later. The handles update automatically, you can see this in the swap procedure in my priority queue. Anyway, The issue is that my edge[] array is populated with null for some reason, so I can't return any paths. How do I fix my algorithm to update edge[] correctly? Any help would be appreciated. Just tell me if you would like more information. Also I will post the Vertex and Edge classes in case you want to look at those.\n    ", "Answer": "\r\nI noticed one error:\n\n```\nQ = new PriorityQueue<Integer>();\nwhile (!Q.isEmpty()){ // <-- Q is always empty beсause of previous line\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Need help understanding Dijkstra's Algorithm\r\n                \r\nI'm trying to follow the pseudocode for Dijkstra's Algorithm but I'm not understanding how it gives me the shortest path. Following this pseudocode:\n\n```\nDijkstrasAlgorithm(G, w, s)\n    InitalizeSingleSource(G, s)\n    S = 0\n    Q = G.V\n    while Q != 0\n        u = ExtractMin(Q)\n        S = S∪{u}\n        for each vertex v ∈ G.Adj[u]\n            Relax(u, v, w)\n```\n\n\nThis is the code I end up with:\n\n```\nDijkstrasAlgorithm(string w, string s) {\n    string u;\n    string s;\n    InitalizeSingleSource(s);\n    for (map<string, Vertex*>::iterator it = vertices.begin(); \n    it!=vertices.end(); ++it) {\n        minQ.insert(it->first, it->second->key);\n    }\n    while (u != \"empty\") {\n        u = minQ.extractMin();\n        if (!s.empty()) {\n            s.append(\"->\");\n        }\n        s.append(u);\n        vector<Neighbor*>::iterator it = adjList[u].begin();\n        while (it != adjList[u].end()) {\n            relax(u, w, (*it)->weight);\n            it++;\n        }\n    }\n    return s;\n}\n```\n\n\nThe problem is, this code doesn't give me the shortest path. And looking at the pseudocode, I don't see how it would. If I had 5 vertices (a, b, c, d, and e) let's say I wanted to find the shortest path from a to c and this shortest path was a->b->c. All this code would do is give me is c->e->d->b->a.\n\nI'm just not understanding the logic here. We initialize all the key values of vertices to INT_MAX with InitalizeSingleSource(s) except for s, which is 0. From here, we find the min value of vertice's key values instead of using adjList.\n\nInstead of stopping once we've reached the end of the path, we stop when minQ is empty. All this does is print all the vertices instead of the shortest path. On top of this, we set most of the keys to INT_MAX, so finding the minimum value between them all feels redundant. \n\nOnce finished, we all the relax function with G.E/G.Adj[u] even though we haven't been using the edges in our measurement of the minimal path.\n\nThere's a lot that doesn't make sense to me, but I suppose the weirdest part is setting Q/minQ based on the vertices (G.V) instead of the edges (G.E). How is this supposed to find the minimum path? Could anyone explain what part of the algorithm pseudocode I'm not understanding? Thanks!\n\nEDIT: Including the \"relax\" function too.\n\n```\nrelax(string u, string v, int weight) {\n    if (vertices[v]->key > (vertices[u]->key + weight)) { \n        vertices[v]->key = (vertices[u]->key + weight);\n        vertices[v]->pi = new std::string(u);\n    }\n}\n```\n\n    ", "Answer": "\r\nRelax decreases the values in minQ.\n\nThe first extracted node is the source, since 0 < MAX_INT. Then, every adjacent node gets relaxed, which decreases its minQ value to 0+c, where c is the cost of the edge from source to the node, if it is lower than the current minQ value.\nThis is the case here, since the previous values are all INT_MAX.\n\nNow all of the Vertices adjacent to the source have been marked with the shortest already discovered path to reach them.\n\nThen one of the processed vertices will have the lowest minQ value, and it will be extracted and processed next.\n\nYou should now be able to see how this extracting->relaxing cycle results in a graph where each node is marked with the minimum cost to reach it.\n\nIf you update a pointer to the relaxed-from node each time a relaxation happens, you can just walk backwards from the desired target node to read the shortest path.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Modifying Dijkstra's Algorithm to find shortest path with largest weighting\r\n                \r\nI'm in need of a piece of code that finds the shortest path between nodes with the greatest weighting. For example, the quickest route from A to D, but with the greatest weighting:\n\n```\n  - B- --E\n     /  \\ /\n    A    D\n     \\  / \\\n      C - -F\n```\n\n\nSo right now the shortest would be ABD or ACD. Once the weighting is applied, the code should choose the longest path out of the two (counter-intuitive, huh?).\n\nI'm trying to modify an algorithm for Dijkstra's Algorithm, but ultimately I just end up traversing the entire graph. Would anyone know how to do this?\nEven just an algorithm so I can code it myself would help immensely.\n    ", "Answer": "\r\n\nRun BFS from the source (let it be ```\ns```\n) on the graph to find the\nlength of the shortest path from ```\ns```\n to the target ```\nt```\n, let it be ```\nd```\n. Also mark ```\nd(s,v)```\n - the distance from ```\ns```\n to any node ```\nv```\n.\nCreate a subgraph ```\nG'=(V',E')```\n of ```\nG```\n such that: ```\nv```\n is in ```\nV'```\n\nonly if its distance from the source (```\ns```\n) is at most ```\nd```\n - ```\nd(s,v) <= d```\n. ```\ne=(u,v)```\n is in ```\nE'```\n only if: both ```\nu```\n and ```\nv```\n are in ```\nV'```\n.\nCreate a new graph ```\nG*=(V*,E*)```\n, where ```\nV'=V*```\n, and an edge ```\n(u,v)```\n is in ```\nE*```\n if it is in ```\nE'```\n AND ```\nd(s,u) < d(s,v)```\n.\nSet a new weight function ```\nw*(u,v) = -w(u,v)```\n, and run Bellman Ford on ```\nG*```\n using ```\nw*```\n.\nThe heaviest shortest path in ```\nG```\n from ```\ns```\n to ```\nt```\n is of weight ```\n-d(t)```\n, and the path found by BF is the matching one.\n\n\nTime complexity of the algorithm is ```\nO(VE)```\n, since Bellman-Ford is the bottleneck.\n\n\n\nCorrectness Proof\n\nClaim 1: The shortest path from ```\ns```\n to ```\nt```\n does not contain any cycles.\nProof is simple by removing the cycle we get a shorter path.\n\nClaim 2: All shortest paths from ```\ns```\n to ```\nt```\n are in ```\nG'```\n\nProof: Since all shortest paths from ```\ns```\n to ```\nt```\n are of length ```\nd```\n, and we eliminated only nodes with distance from ```\ns```\n longer than ```\nd```\n, we remove only nodes not needed for shortest paths.\n\nClaim 3: All shortest paths from ```\ns```\n to ```\nt```\n are in ```\nG*```\n.\nProof:  Assume we removed some edge ```\n(u,v)```\n in a shortest path, and let that path be ```\ns->...->x->u->v->y->...->t```\n. Note that the path ```\nv->y->..->t```\n is of length ```\nd-d(s,u)-1```\n (assuming ```\nd(s,u)```\n is minimal)\nHowever, note that from construction of ```\nE*```\n, ```\nd(s,v) <= d(s,u)```\n (otherwise ```\n(u,v)```\n wouldn't have been removed). So, there is a path ```\ns->...->v->y->...->t```\n with distance from ```\ns```\n: ```\nd(s,v) + d-d(s,u)-1 <= d(s,u) + d - d(s,u) -1 <= d-1```\n - contradiction to minimality of ```\nd```\n.\n\nClaim 4: There are no cycles in ```\nG*```\n.\nProof: Assume there is a cycle in ```\nG*```\n: ```\nv1->v2->vk->v1```\n. By definition of G', all nodes are reachable from ```\ns```\n. Without loss of generality, let us assume ```\nd(s,v1)```\n is minimal for all other ```\nd(s,vi)```\n (otherwise rotate indices to match this assumption). But there is a path v1->v2->...->vk->v1, and ```\nd(s,v1)=d(s,v1)```\n. This means at least for one edge ```\n(vi,vi+1)```\n in this path, ```\nd(vi) >= d(vi+1)```\n - which is contradicting the construction of ```\nE*```\n, and the cycle does not exist in G*.\n\nClaim 5: The algorithm is correct.\n\nFrom correctness of Bellman-Ford, and since ```\nG*```\n does not contain negative cycles (no cycles at all), BF will find the path with minimal weight according to ```\nw*```\n in ```\nG*```\n. This path is the one with maximal weight according to ```\nw```\n, from the construction of ```\nw*```\n.\nsince all shortest paths in ```\nG```\n also exist in ```\nG*```\n (and only them), this path is also the shortest path in ```\nG```\n with maximal weight.\n\nQED\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Difference between branch & bound (+ extended list) and Dijkstra's Algorithm on Graphs\r\n                \r\nI was working through http://youtu.be/gGQ-vAmdAOI?t=23m14s when at 23:14 I felt that branch & bound with an \"extended list\" was very similar to Dijkstra's algorithm. Later on in the lecture when the algorithm is again extended with an admissable heuristic, we get A*. \n\nThat led me into thinking that Dijkstra's algorithm is this very subclass of branch & bound. Is that right?\n\n\n\nTo summarize the lecture:\n\nSearch algorithms are explored. In particular, they start from a simple branch & bound solution: \n\nUntil the destination node is visited (extended), visit the node with the shortest distance from the source and add its successors to the priority queue of nodes to visit (sorted by min distance). This doesn't yet detect cycles (e.g. visits nodes more than once) and is rather inefficient because of combinatorial explosion.\n\nA simple extension causes the algorithm to perform much better: Remembering which nodes were already visited (extended, hence extension list). No node is visited twice now and the algorithm performs considerably better.\n\nIn the last part, an admissable heuristic is added to the mix to get A*.\n\nI hope this is enough information and that I don't have to copy the examples from the lecture. If it isn't, let me know and I'll do though!\n    ", "Answer": "\r\nThe difference is only in implementation, the idea is the same. What makes Dijkstra's algorithm special is that it's branch & bound done with a heap (which gives you a big speedup).\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra’s algorithm\r\n                \r\nWhen reading about the Dijkstra’s algorithm, I found that you should implement a min heap. I tried implementing a min heap and the algorithm worked, but it also worked when I did not use min heap functions and instead just popped off the vertex at index 0.\nI am confused why we need to always choose the vertex with the min distance to explore next when we are going to explore all the vertices in the heap anyway.\nFor example:\n```\nfrom heapq import heappop, heappush\nfrom math import inf\n\ngraph = {\n        'A': [('B', 10), ('C', 3)],\n        'C': [('D', 2)],\n        'D': [('E', 10)],\n        'E': [('A', 7)],\n        'B': [('C', 3), ('D', 2)]\n    }\n\n\ndef dijkstras(graph, start):\n  distances = {}\n  \n  for vertex in graph:\n    distances[vertex] = inf\n    \n  distances[start] = 0\n  vertices_to_explore = [(0, start)]\n  while vertices_to_explore:\n    current_distance, current_vertex = heappop(vertices_to_explore) # this piece of code\n    #current_distance, current_vertex = vertices_to_explore.pop(0) # vs. this piece of code\n    for neighbor, edge_weight in graph[current_vertex]:\n      new_distance = current_distance + edge_weight\n      \n      if new_distance < distances[neighbor]:\n        distances[neighbor] = new_distance\n        heappush(vertices_to_explore, (new_distance, neighbor))\n        \n  return distances\n        \ndistances_from_d = dijkstras(graph, 'D')\nprint(\"\\n\\nShortest Distances: {0}\".format(distances_from_d))\n\n```\n\nWhy use heappop when pop(0) works the same... is it because of run time? If so why does it run faster?\nThanks\n    ", "Answer": "\r\nWe use min-heap and take the vertex with the minimal distance at each step as the Dijkstra algorithm works in a greedy manner; there is no shorter path than the path from the closest vertex at the current step. This is true due to the fact that all distances are positive.\nThe fact that in the code above regular unsorted list's ```\npop(0)```\n worked the same as heap's ```\nheappop()```\n has to do with a coincidence on the graph given as an input (and not with the algorithm).\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm team project not running because I named it Dijkstra(Project name)? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                This question is unlikely to help any future visitors; it is only relevant to a small geographic area, a specific moment in time,  or an extraordinarily narrow situation that is not generally applicable to the worldwide audience of the internet. For help making  this question more broadly applicable, visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nWas working on a team project in C#, I called it Dijkstra's Algorithm,  and when I was done writing my code down I went to debug using Visual Studio 2010 and I would keep getting an error like this:\n\n!https://lh5.googleusercontent.com/-M8DCWHZMhig/UXYtd_9z3OI/AAAAAAAAAJQ/njtUVLTHxq4/w497-h373/Error.png\n\nThis kept happening more and more when I re-did the project under a similar name. Only when I took out the name Dijkstra would it properly run and debug.\n\nWhy is that?\n    ", "Answer": "\r\nIt's because of the apostrophe, not Dijsktra. Name it DijkstrasAlgorithm or somesuch and you should be fine\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Modified Dijkstra's Algorithm\r\n                \r\nWe are given a directed graph with edge weights W lying between 0 and 1. Cost of a path from source to target node is the product of the weights of edges lying on the path from source to target node. I wanted to know of an algorithm which can find the minimum cost path in polynomial time or using any other heuristic.\n\nI thought along the lines of taking the log values of the edges weights (taking mod values) and then applying dijkstra for this graph but think there will be  precision problems which can't be calculated.\n\nIs there any other better way or can I improve upon the log approach.\n    ", "Answer": "\r\nIn Dijkstra's algorithm, when you visit a node you know that there is no shorter road to this node. This is not true if you multiply the edges with weights between 0..1 as if you visit more vertices you will get a smaller number. \n\nBasically this is equivalent of finding the longest path in a graph. This can be seen also by using your idea of taking logarithms, as the logarithm of a number between 0 and 1 is negative. If you take absolute values of the logarithms of the weights, the longest path corresponds to the shortest path in the multiplicative graph.\n\nIf your graph is acyclic there is a straightforward algorithm (modified from Longest path problem). \n\n\nFind a Topological ordering of the DAG.\nFor each vertex you need to store the cost of path. Initialize this to one at the beginning.\nTravel through the DAG in topological order starting from your start vertex. In each vertex check all the children and if the cost is smaller than previously, update it. Store also the vertex where you arrive at this vertex with the lowest cost.\n\n\nAfter you reach your final vertex, you can find the \"shortest\" path by travelling back from the end vertex using the stored vertices.\n\nOf course, if you graph is not acyclic you can always reach a zero end cost by repeating a loop infinitely.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra’s algorithm with a Fibonacci heap\r\n                \r\nI am trying to implement Dijkstra's algorithm for finding the shortest paths between nodes using Fibonacci Heap with Adjacency List representation for the graph. According to the algorithm I know, we have to find the minimum node in the Heap and then iterate through all its neighbours and update their distances. But to get the current distances of the neighbours(which is stored in each node in the heap), I have to find that particular node from the heap. 'Find' operation takes O(N) time where N is number of nodes in the Fibonacci Heap. So is my algorithm correct or am I missing something? Any help would be greatly appreciated.\n    ", "Answer": "\r\nAn implicit assumption in a Fibonacci heap is that when you enqueue an element into the heap, you can, in time O(1), pull up the resulting node in the Fibonacci heap. There are two common ways you'll see this done.\nFirst, you could use an invasive Fibonacci heap. In this approach, the actual node structures in the graph have extra fields stored in them corresponding to what the Fibonacci heap needs to keep things linked up the right order. If you set things up this way, then when you iterate over a node's neighbors, those neighbors already have the necessary fields built into them, which makes it easy to query the Fibonacci heap on those nodes without needing to do a search for them.\nSecond, you can have the enqueue operation on the Fibonacci heap return a pointer to the newly-created Fibonacci heap node, then somehow associate each node in the graph with that Fibonacci heap node (maybe store a pointer to it, or have a hash table, etc.). This is the approach I took when I coded up a version of Dijkstra's algorithm that uses Fibonacci heap many years back.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How to code Dijkstra's algorithm with a specefic visited node constraint in Matlab?\r\n                \r\nI'm trying to implement Dijkstra's algorithm for finding the shortest path with a node constraint in Matlab. Specifically, I want to force the path to go through a given set of nodes.\nI have an adjacency matrix as input and I need the function to take a start node, end node, and constraint as an array. The algorithm should also be able to handle multiple constraints and execute quickly.\nExemple for a graph\nHere the shortest path between A and E is 7 A⇒B⇒E, But i want to get the shortest path between A and E going through C. Ideadly i want an algorithm that can find the shortest path between two nodes and going through one or more nodes.\nCan anyone provide an explanation of how to modify Dijkstra's algorithm to handle these constraints and help me with the implementation in Matlab?\nThank you!\n    ", "Answer": "\r\nSince the path needs to go through C, find the shortest path between A and C, and then the shortest path between C and B, then combine them.\nYou can do that with any number of constraints by checking all the possibilities of the order in which you go through the nodes, which will take at least O(n!) for n constraints.\nFor a more general solution with any number of nodes as a constraint, create a new graph only with A,B and those nodes, then use an algorithm that visits all nodes in a graph.\nMore information about it here.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "finding the shortest path between source and destination in graph using dijkstra's algorithm\r\n                \r\nI would like to write an algorithm, which finds the shortest path between two specific vertices - source and destination - in a directed and undirected graph.\n\nI know dijkstra's algorithm, which is used to find all the shortest paths graph. But would you modify this algorithm to find the shortest path between two vertices only?\n    ", "Answer": "\r\nJust used the A* algorithm with no heuristic information. That would give you the same shortest path between the source and goal vertices that you would obtain from Dijkstra (Dijkstra is a specific case of A* when h = 0).\n\nRegarding the implementation of the algorithm in C, there are tons of implementations available online: one, two or three.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm termination\r\n                \r\nSomething must be wrong in my understanding of the algorithm. How is it supposed to work on the following graph.\nAs I understand it, if the starting vertex is (5) then the algorithm would go, 5->4->1 and then terminate. Vertex (2) would still have infinity as it's weight.\nfrom wikipedia:\nif the smallest tentative distance among the nodes in the unvisited set is infinity (when planning a complete traversal), then stop. The algorithm has finished.\n\n    ", "Answer": "\r\nNo, it would investigate ```\n3 -> 2```\n after it's done with the ```\n4 -> 1```\n branch. All children of the currently investigated node are added to the queue, and then from the queue the node with the smallest tentative distance is taken to be processed next.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Converting Dijkstra's Algorithm from Python3 to CircuitPython (TI-Python)\r\n                \r\nI'm writing Python code on one of the new TI-84 Python edition calculators. These use a version of CircuitPython with limited support for some quite basic features.\nThis includes missing dictionary methods such as ```\nitems()```\n and ```\nvalues()```\n.\nMy original version of Dijkstra's Algorithm is below, followed by a nearly complete version in TI-Python. I'm having trouble converting the final two ```\nitems()```\n instances with working alternatives.\n```\nnodes = ('A', 'B', 'C', 'D', 'E')\ndistances = {\n    'A': {'B': 6, 'D': 1},\n    'B': {'A': 6, 'C': 5, 'D': 2, 'E' :2},\n    'C': {'B': 5, 'E': 5},\n    'D': {'A': 1, 'B': 2, 'E': 1},\n    'E': {'B': 2, 'C': 5, 'D': 1}}\n\n\nunvisited = {node: None for node in nodes} #using None as +inf\nvisited = {}\ncurrent = 'A' # the start node\ncurrentDistance = 0\nunvisited[current] = currentDistance\n\nwhile True:\n    # for the nodes adjacent to the current node.\n    for neighbour, distance in distances[current].items():\n        # ignore if already visited\n        if neighbour not in unvisited:\n            continue\n        # calculate the total distance to this new node\n        newDistance = currentDistance + distance\n        # if this adjacent node has a lower distance\n        if unvisited[neighbour] is None or unvisited[neighbour] > newDistance:\n            # update distance to this new, lower distance\n            unvisited[neighbour] = newDistance\n    # add current node and distance from start to visited list\n    visited[current] = currentDistance\n    # Remove current node from unvisited list\n    del unvisited[current]\n    # if all nodes have been visited\n    if not unvisited:\n        # exit\n        break\n    # candidates for next node to visit\n    print(unvisited.items())\n        # print(node[1])\n    candidates = [node for node in unvisited.items() if node[1]]\n    print(candidates)\n    current, currentDistance = sorted(candidates, key = lambda x: x[1])[0]\n\n# print(visited)\n\nprint(dict(sorted(visited.items())))\n```\n\nTI-Python version:\n```\nns = (\"A\", \"B\", \"C\", \"D\", \"E\")\nds = {\n    \"A\": {\"B\": 6, \"D\": 1},\n    \"B\": {\"A\": 6, \"C\": 5, \"D\": 2, \"E\": 2},\n    \"C\": {\"B\": 5, \"E\": 5},\n    \"D\": {\"A\": 1, \"B\": 2, \"E\": 1},\n    \"E\": {\"B\": 2, \"C\": 5, \"D\": 1}\n}\n\nun = {no: None for no in ns}\nvi = {}\ncn = \"A\"\ncd = 0\nun[cn] = cd\n\nwhile True:\n    for ne in sorted(ds[cn]):\n        di = ds[cn][ne]\n        if ne not in un:\n            continue\n        nd = cd + di\n        if un[ne] is None or un[ne] > nd:\n            un[ne] = nd\n    vi[cn] = cd\n    del un[cn]\n    if not un:\n        break\n    cs = [no for no in un.items() if no[1]]\n    cn, cd = sorted(cs, key=lambda x: x[1])[0]\n\nprint(dict(sorted(vi.items())))\n```\n\nCould someone please explain how to refactor ```\ncs = [no for no in un.items() if no[1]]```\n and ```\nprint(dict(sorted(vi.items())))```\n so they don't need the ```\n.items()```\n or ```\n.values()```\n. methods?\n    ", "Answer": "\r\nWhilst ```\n.items()```\n is very useful, it is equivalent to iterating the keys and then looking up the value.\n```\nfor k in dict:\n    v = dict[k]\n```\n\nis equivalent to\n```\nfor k, v in dict.items():\n```\n\nThus a crude refactor of\n```\ncs = [no for no in un.items() if no[1]]\n```\n\nWould be:\n```\ncs = [[k, un[k]] for k in un if un[k]]\n```\n\nNote that the original could be better written as:\n```\ncs = [[k,v] for k, v in un.items() if v]\n```\n\nLikewise,\n```\nprint(dict(sorted(vi.items())))\n```\n\nis directly equivalent to:\n```\nprint(dict(sorted([k, vi[k] for k in vi]))\n```\n\nbut that's not very readable IMHO.  I would do:\n```\nprint({k: vi[k] for k in sorted(vi.keys()})\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra algorithm problem\r\n                \r\nHow to apply Dijkstra algorithm for a graph to find the MST in such a way that the resulting tree must have an edge between two given vertices? (ex: MST must include an edge between X and Y)\n\nThanks\n    ", "Answer": "\r\nDijkstra's algorithm is for shortest paths (not MST), but something similar to Dijkstra's algorithm, as modified to find a minimum spanning tree, is called Prim's algorithm. Prim's algorithm keeps a tree that grows until it spans the entire graph. The additional constraint introduced here does not pose much difficulty: you just start with X-Y as your tree.\n\nSpecifically, given that your MST must include the edge (X,Y) (if there are multiple such edges pick the one of smallest weight), start with your tree having two nodes X and Y and the edge between them. Now at each step pick the smallest edge (u,v) where u is in your tree and v outside, add node v and the edge (u,v) to your tree, and repeat.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Big-O of Dijkstra's Algorithm with D-Ary Heap\r\n                \r\nI'm looking for a complete walkthrough on the runtime of Dijkstra's algorithm when implemented with a D-Ary heap.\n\nMy best understanding as of now is that the depth of the tree is at most log_d(n), so the max time of insertion and bubbling up is log_d(n). Wouldn't bubble down be the same on deleting a node?\n\nI'm just having trouble piecing things together to find the total Big-O runtime here. My understanding is that it should be O(m logm/n n)), but I'd like to have a kind of walkthrough to understanding why that is the case.\n    ", "Answer": "\r\nIn a d-ary heap, up-heaps (e.g., insert, decrease-key if you track heap nodes as they move around) take time O(log_d n) and down-heaps (e.g., delete-min) take time O(d log_d n), where n is the number of nodes. The reason that down-heaps are more expensive is that we have to find the minimum child to promote, whereas up-heaps just compare with the parent.\n\nAssuming a connected graph, Dijkstra uses at most m - (n - 1) decrease-keys and at most n - 1 inserts/deletes (assuming that we never insert the root). The running time of Dijkstra using a d-ary heap as a priority queue is thus O((m + n d) log_d n), which is worth it for dense graphs.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra’s algorithm and functions\r\n                \r\nthe question is: suppose I have an input function like ```\nsin(2-cos(3*A/B)^2.5)+0.756*(C*D+3-B)```\n specified with a BNF, I will parse input using recursive descent algorithm, and then how can I use or change Dijkstra’s algorithm to handle this given function? I need to execute it with sin | cos | sqrt | ln, where Dijkstra’s algorithm should do the work. \n\nEDIT: May be I should ask also: What is the best practice or data structure to represent given function? \n\nEDIT: Input set can be acquired as:\n\n```\nC 0.01 .01 .02 .04 .08 .02 .02 .04 \nA .016 .008 .116 .124 .147 .155 .039 .023  \nD .012 .025 .05 .1 .1 .1 .025 .012000 .012\nB .007 .007 .015 .022 .029 .036 .044 .051 .058 .066 .073 .080 \n```\n\n\nEDIT: Shunting Yard is the algorithm to convert input function to RPN, but how can I extend it to accept another function like sin | cos | sqrt | ln? Does recursive descent provides required extension to Shunting Yard? \n    ", "Answer": "\r\nI presume you are talking about Dijkstra's Shunting Yard algorithm?\n\nTo evaluate the reverse polish notation (output of shunting yard), normally a stack is used.\n\nShunting Yard was devised to do the parsing in Algol I believe, and I believe it is supposed to work with any functions (either fixed or variable number of arguments).\n\nHere is a blog post which explains it in more detail: http://www.kallisti.net.nz/blog/2008/02/extension-to-the-shunting-yard-algorithm-to-allow-variable-numbers-of-arguments-to-functions/\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm - how could a priority queue or min-heap be used?\r\n                \r\nI've been struggling implementing Dijkstra's algorithm; more specifically the part with the priority queue. To add vertices into a data structure and use an iterator to go through all vertices and find the minimum distance; that would be easy, but n time.\n\nWhat I want is to:\n\n\nto be able to insert vertices into the data structure\nextract (return and remove) the vertex v with the lowest distance dist[v]\n\n\nI believe that for Dijkstra's algorithm to work properly, you should be able to insert vertices in constant time and extract them in log(n) time; and I've been suggested that priority queues and min-heaps could be used, but to me it doesn't seem realistic that we could keep the queue or min-heaps ordered, because the distances are getting constantly modified.\n\nSo how am I supposed to declare and use a priority queue, a min-heap or another data structure to do this?\n    ", "Answer": "\r\nYou can use a pair to store the node along with the value (the first element should be the value so that the priority queue compares with this value). Maintain a boolean array ```\nvisit [ ]```\n where you will indicate wheather you have visited or not a certain node (intially all false).\n\nEvery time you take the front element of the priority queue check if you have visited this node that is check if ```\nvisit[pq.front().second] == false```\n. Check for all its adjacent edges and add the nodes reached from this path. If it is true then you should ignore it, as you have already visited it with less length. You will not add more than E edges so the time complexity remains the same.\n\nYou can learn more about this approach in this link http://community.topcoder.com/tc?module=Static&d1=tutorials&d2=standardTemplateLibrary2#priority.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Can a graph with negative edges exist, for which Dijkstra's algorithm will work properly?\r\n                \r\nI know,that \"normal\" Dijkstra's algorithm won't work for graph with negative edge's since once it visits the edge and processes it,it's weight will not be revised.However,I have hard time proving this formally.I don't even know where to start.\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How to find Shortest Path in subway with transfer time using Dijkstra's Algorithm\r\n                \r\nI am facing a problem with a little trick. I need help!\n\nThe problem is to find the shortest path in a subway from the start point to the destination.\nSubway data provides time taken between each node and its lines. Every time you transfer(change line), it takes 5 minutes.\n\nI tried to code this algorithm using Dijkstra's algorithm. \nThe major difference between Dijkstra's and this problem is that this problem has the possibility of changing the shortest path among those nodes already calculated(put them in set S).\n\nFor instance, \nthere are A, B, C, D, E noded. I want to find the shortest path from A to E.\n\nLet's say \n    A: line 1, line 2\n    B: line 1\n    C: line 1, line 2\n    D: line 2\n    E: line 1\n\n```\nA -> B: 2 minutes\nB -> C: 2 minutes\nA -> D: 1 minutes\nD -> C: 2 minutes\nC -> E: 2 minutes\n```\n\n\nIn this case, the Dijkstra's algorithm will take in set S(calculated) node A first, and then node D, and then node B, and then node C, and then node E. \n\nThat is, the Dijkstra's algorithm will show A -> D -> C -> E as the shortest path with 10 minutes, since at node C, 5 minutes is required for transfer. \nHowever, the actual shortest path is A->B->C->E with 6 minutes, since it does not require transfer time!\n\nThat is, the Dijkstra's path A->D->C should be modified to A->B->C after E is taken in the set S. \n\nHowever, I don't know how to implement this idea to programming code.\nI'm using JAVA.\n\nPlease help anyone! Give me any ideas!!\n\nThank you\n    ", "Answer": "\r\nDijkstra works just fine, just modify edge weights a bit, when there's an edge from node ```\nu```\n to ```\nv```\n and ```\nline[u] != line[v]```\n we just need to increase edge length by ```\n5 (transfer time)```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "About Dijkstra’s algorithm\r\n                \r\nhere is my question.\nIf some edge weights are negative, the shortest paths from s can be obtained by adding a constant C to every edge weight, large enough to make all edge weights nonnegative, and running Dijkstra’s algorithm.\n\nit's true or false and why?\n    ", "Answer": "\r\nFalse : If some edge weights are negative, there might be no shortest path.\n\nIt would possible to loop into a negative-cost cycle to lower the cost as much as you want.\n\nThat's said, if you forbid to use twice the same point, I think that it becomes true.\n\nEven if you forbid using twice the same point, it still does not work as stated by MrSmith42 :\n\n\n  You might have two paths one with costs 0+0+0+0+0+0+0+0+0+0=0 and one with 10+(-4)=6. If you increase all weights by 4, the cost will be 4+4+4+4+4+4+4+4+4+4+4=40 and the other 14+0=10. This way the cheaper path becomes the more expensive ones by changing the weights.\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How to make Dijkstra's algorithm report the full final distance for that shortest route\r\n                \r\nI'm relatively new to python and have been reading on the internet on ways to implement Dijkstra's algorithm and I came across the code provided below on this page here.\n\nThe code is an implementation of Dijkstra's algorithm and it works perfectly fine. see code below:\n\n```\nfrom collections import namedtuple, deque\nfrom pprint import pprint as pp\n\n\ninf = float('inf')\nEdge = namedtuple('Edge', ['start', 'end', 'cost'])\n\nclass Graph():\n    def __init__(self, edges):\n        self.edges = [Edge(*edge) for edge in edges]\n        # print(dir(self.edges[0]))\n        self.vertices = {e.start for e in self.edges} | {e.end for e in self.edges}\n\n    def dijkstra(self, source, dest):\n        assert source in self.vertices\n        dist = {vertex: inf for vertex in self.vertices}\n        previous = {vertex: None for vertex in self.vertices}\n        dist[source] = 0\n        q = self.vertices.copy()\n        neighbours = {vertex: set() for vertex in self.vertices}\n        for start, end, cost in self.edges:\n        neighbours[start].add((end, cost))\n        #pp(neighbours)\n\n        while q:\n            # pp(q)\n            u = min(q, key=lambda vertex: dist[vertex])\n            q.remove(u)\n            if dist[u] == inf or u == dest:\n                break\n            for v, cost in neighbours[u]:\n                alt = dist[u] + cost\n                if alt < dist[v]:                                  # Relax (u,v,a)\n                dist[v] = alt\n                previous[v] = u\n        #pp(previous)\n        s, u = deque(), dest\n        while previous[u]:\n            s.appendleft(u)\n            u = previous[u]\n        s.appendleft(u)\n        return s\n```\n\n\nThis is the test data provided:\n\n```\ngraph = Graph([(\"a\", \"b\", 7),  (\"a\", \"c\", 9),  (\"a\", \"f\", 14), (\"b\", \"c\", 10),\n           (\"b\", \"d\", 15), (\"c\", \"d\", 11), (\"c\", \"f\", 2),  (\"d\", \"e\", 6),\n           (\"e\", \"f\", 9)])\n```\n\n\nTo run it for specific two points, say 'a' to 'e':\n\n```\npp(graph.dijkstra(\"a\", \"e\"))\n```\n\n\nOutput looks like this:\n\n```\ndeque(['a', 'c', 'd', 'e'])\n```\n\n\nMy question is this, how can I make this algorithm report the full final distance for that shortest route. i.e. desired output to look something like this:\n\n```\ndeque(['FullDistance', 'a', 'c', 'd', 'e'])\n```\n\n\nI've been trying adding 'dist' to the append at the end of function 'Dijkstra' but doesn't seem to work, I don't get anything different:\n\n```\ns.appendleft(dist)\n```\n\n\nIt's probably something simple somewhere to tweak but I can't seem to figure it out, any help is highly appreciated.\n\nThanks.\n    ", "Answer": "\r\ni think you need to add alt instead of dist.\n\ntry this at the end of your function\n\n```\ns.appendleft(alt)\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "dijkstra algorithm priority queue\r\n                \r\nWhen we are writing dijkstra algorithm with priority queue why we are not check about the visited node?\n```\nwhile (!pq.empty())\n    {\n        \n        int u = pq.top().second;\n        pq.pop();\n \n        // Get all adjacent of u.\n        for (auto x : adj[u])\n        {\n            int v = x.first;\n            int weight = x.second;\n \n            if (dist[v] > dist[u] + weight)\n            {\n                dist[v] = dist[u] + weight;\n                pq.push(make_pair(dist[v], v));\n            }\n        }\n```\n\n    ", "Answer": "\r\nIt does check the previous value of the node in ```\ndist[v]```\n, which I assume stores the current best distance from the root (or ```\nu```\n) to node ```\nv```\n. If a new path is found to ```\nv```\n which is shorter than the previous shortest one, it is reinserted into the priority queue because it may now provide shorter paths to other nodes. If this new distance to ```\nv```\n is longer than the previous, then it is left alone. This is why there is no ```\nelse```\n in the implementation.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "how to input this for Dijkstra algorithm question\r\n                \r\nI have an assignment on Dijkstra's algorithm, but the question has me confused about the input. It asks me to find shortest and second shortest paths, and that part I have figured out, but how do I even start with the graph has me troubled. \nThe question says the input has to be read from a file and the file contains the number of nodes and the weight between two nodes. Weight between two nodes should be 1 to 9, and can use 0 to indicate a path that doesn't exist.\nNow my question is what has to be the contents of the file? I was able to understand Dijkstra's algorithm where the input was a 2d array that represents the graph. Can someone clarify what is expected from this question? Like what the source file should contain. \n    ", "Answer": "\r\nYou are probably supposed to create file like this:\n(example - there are many ways to do it)\n\n```\n4   # number of nodes (from 1 to 4)\n1 2 3   # means edge from node 1 to node 2 with weight 3\n2 3 1   # means edge from node 2 to node 3 with weight 1\n...\n```\n\n\nthis would correspond to 2d matrix like this:\n\n```\n0 3 0 0\n0 0 1 0\n0 0 0 0\n0 0 0 0\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm not adding end node (C++)\r\n                \r\nI have been experimenting with implementing Dijkstra's algorithm in C++ and used this pseudocode from wikipedia as a start:\n```\n 1  function Dijkstra(Graph, source):\n 2      \n 3      for each vertex v in Graph.Vertices:\n 4          dist[v] ← INFINITY\n 5          prev[v] ← UNDEFINED\n 6          add v to Q\n 7      dist[source] ← 0\n 8      \n 9      while Q is not empty:\n10          u ← vertex in Q with min dist[u]\n11          remove u from Q\n12          \n13          for each neighbor v of u still in Q:\n14              alt ← dist[u] + Graph.Edges(u, v)\n15              if alt < dist[v] and dist[u] is not INFINITY:\n16                  dist[v] ← alt\n17                  prev[v] ← u\n18\n19      return dist[], prev[]\n```\n\nWhile also using this tutorial and the C++ code as a template/help: https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/.\nI have since then tried to expand the code to not just find the distance from source to each vertex, but instead just trying to find the shortest path from source to a target. Tried this by implementing pseudocode from wikipedia for that:\nIf we are only interested in a shortest path between vertices source and target, we can terminate the search after line 10 if u = target. Now we can read the shortest path from source to target by reverse iteration:\n```\n1  S ← empty sequence\n2  u ← target\n3  if prev[u] is defined or u = source:          // Do something only if the vertex is reachable\n4      while u is defined:                       // Construct the shortest path with a stack S\n5          insert u at the beginning of S        // Push the vertex onto the stack\n6          u ← prev[u]                           // Traverse from target to sourc\n```\n\nThis is my current code:\n```\n#include <iostream>\n#include <vector>\nusing namespace std;\n#include <limits.h>\n\n#define V 9\n\nint minDistance(int dist[], bool prev[])\n{\n    // Initialize min value\n    int min = INT_MAX, min_index;\n \n    for (int v = 0; v < V; v++)\n        if (prev[v] == false && dist[v] <= min)\n            min = dist[v], min_index = v;\n \n    return min_index;\n}\n\nvoid printSolution(int dist[])\n{\n    cout <<\"Vertex \\t Distance from Source\" << endl;\n    for (int i = 0; i < V; i++)\n        cout  << i << \" \\t\\t\"<<dist[i]<< endl;\n}\n\nvoid dijkstra(int graph[V][V], int src, int target) {\n    \n    int dist[V];\n    int prev[V];\n    bool Q[V];\n    //bool true_target = false;\n    int S[V];\n\n    for (int i=0; i < V; i++) {\n        dist[i] = INT_MAX;\n        prev[i] = INT_MAX;\n        // add v to Q\n        Q[i] = false;\n    }\n    dist[src] = 0;\n\n    //while Q is not empty:\n    for (int count = 0; count < V-1; count++) {\n        int u = minDistance(dist, Q);\n        cout << \"u: \" << u << endl;\n        vector<int> S;\n        //true_target = (u==target);\n        if (u == target) {\n            if ((prev[u] != INT_MAX) || (u = src)) {\n                while(u > 0) {\n                    cout << u << endl;\n                    S.push_back(u);\n                    u = prev[u];\n                }\n                cout << \"END\" << endl;\n                for (auto j = S.begin(); j != S.end(); ++j) {\n                    cout << *j << ' ';\n                }\n                return;\n            }\n        }\n        Q[u] = true;\n\n        for (int v = 0; v < V; v++) {\n            //cout << graph[u][v] << endl;\n            if (!Q[v] && graph[u][v] && dist[u] != INT_MAX && dist[u] + graph[u][v] < dist[v]) {\n                dist[v] = dist[u] + graph[u][v];\n                prev[v] = u;\n            }\n        }\n    }\n\n    printSolution(dist);\n}\n\nint main ()\n {\n\n     int graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n                        {4, 0, 8, 0, 0, 0, 0, 11, 0},\n                        {0, 8, 0, 7, 0, 4, 0, 0, 2},\n                        {0, 0, 7, 0, 9, 14, 0, 0, 0},\n                        {0, 0, 0, 9, 0, 10, 0, 0, 0},\n                        {0, 0, 4, 14, 10, 0, 2, 0, 0},\n                        {0, 0, 0, 0, 0, 2, 0, 1, 6},\n                        {8, 11, 0, 0, 0, 0, 1, 0, 7},\n                        {0, 0, 2, 0, 0, 0, 6, 7, 0}};\n\n     dijkstra(graph, 0, 4);\n\n     return 0;\n }\n```\n\nMy main problem is that vertex 4, the vertex farthest away from the source, is not a vertex my current code can find a path to. When trying to find a path to 4 the output is:\n```\nu: 0\nu: 1\nu: 7\nu: 6\nu: 5\nu: 2\nu: 8\nu: 3\nVertex   Distance from Source\n0               0\n1               4\n2               12\n3               19\n4               21\n5               11\n6               9\n7               8\n8               14\n```\n\nShowing that an u: 4 is never generated, unlike trying to find a path to 5:\n```\nu: 0\nu: 1\nu: 7\nu: 6\nu: 5\n5\n6\n7\nEND\n5 6 7\n```\n\nThat find u: 5 and shows a path back to source.\nAppreciate any help. Thanks ^^\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "An example of Dijkstra's algorithm to fail with one negative edge\r\n                \r\nI'm trying to think of a graph which all edges have positive weights, except of one edge such that Dijkstra's algorithm fails to produce the correct output.\n\nI'd be glad for an idea.\n\nEDIT:\nI've seen this graph as a counter-example but I don't understand why. \nThe vertex ```\nA```\n would be the last to pop-out from the queue and then we will ```\nRelax()```\n the edge ```\nA->E```\n. So the path ```\nS->A->E```\n will be chosen, which is the correct path (And not ```\nS->B->E```\n as was claimed)\n\n\n\nThanks\n    ", "Answer": "\r\nDijkstra terminates upon expanding the goal node. Also we use a priority queue in dijkstra (not a queue) so that we expand the node that has the least cost. So in your example A will never be expanded.\n\n```\n  open list = [ S cost:0 ] // priortiy queue\npop S out of open list\n  closed list = [ S cost:0 ]\n  open list = [ B cost:1 ; A cost:5 ]\npop B out of open list\n  closed list = [ S cost:0 ; B cost:1 ]\n  open list = [ E cost:2 ; A cost:5 ]\npop E out of open list\n// it's better to terminate when we reach the goal but if we don't\n// it doesn't make any difference we are going to find the shortest path\n// to other nodes\n   closed list = [ S cost:0 ; B cost:1 ; E cost:2 ]\n   open list = [ A cost:5 ]\npop A out of open list\n   // there isn't any nodes that we can push to open list\n   closed list = [ S cost:0 ; B cost:1 ; E cost:2 ; A cost:5 ]\n   open_list = []\n```\n\n\nDijkstra push a node to its closed list upon expanding it because it assumes it has find the shortest path to it. So even if we don't terminate upon reaching a goal we will never expand A because it is in our closed list.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How to implement Dijkstra's algorithm in Neo4j using Cypher\r\n                \r\nMy question is: is it possible to implement Dijkstra's algorithm using Cypher? the explanation on the neo4j website only talks about REST API and it is very difficult to understand for a beginner like me\n\nPlease note that I want to find the shortest path with the shortest distance between two nodes, and not the shortest path (involving least number of relationships) between two nodes. I am aware of the shortestPath algorithm that is very easy to implement using Cypher, but it does not serve my purpose.\n\nKindly guide me on how to proceed if I have a graph database with nodes, and relationships between the nodes having the property 'distance'. All I want is to write a code with the help of which we will be able to find out the shortest distance between two nodes in the database. Or any tips if I need to change my approach and use some other program for this? \n    ", "Answer": "\r\nIn this case you can implement the allShortestPaths, ordering the paths in an ascending order based on your distance property of the relationships and return only one, based on your last post it would be something like this :\n\n```\nMATCH (from: Location {LocationName:\"x\"}), (to: Location {LocationName:\"y\"}) , \npaths = allShortestPaths((from)-[:CONNECTED_TO*]->(to))\nWITH REDUCE(dist = 0, rel in rels(paths) | dist + rel.distance) AS distance, paths\nRETURN paths, distance\nORDER BY distance\nLIMIT 1\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Filtering the right path to implement dijkstra's algorithm\r\n                \r\nI have a goal and a starting point and a list of obstacles which are rectangles. My starting point is (0, 0) now I have perform dijkstra's algorithm to traverse from start to goal avoiding the obstacles. I can travel through the sides of the rectangle to reach the goal, but I cannot go through, basically all the points that form my rectangle are the vertices.\n\nMy input file is of this format\n    1.75 -0.25\n    -0.5   2.5  -1    1\n    0.75  1.31 -0.56 0.25\n    2     2.32  0.35 0.75\n\nsomething like this ..\n    (xgoal ygoal\n    xmin0 xmax0 ymin0 ymax0\n    xmin1 xmax1 ymin1 ymax1\n    ...\n    xminN xmaxN yminN ymaxN)\n\n(line 1 is goal\nline 2 is the boundary arena\nline 3, line4, and thereafter... Are a list of obstacles, I.e rectangles)\n\nHelp: I have parsed the file and extracted all the points, the rectangles (obstacles)\n           I have a list which stores all the edges from a given point to every other point and \n           and a EdgeList which has the list of all the edges.\n\nCan anyone tell me how to filter out the edges (obstacles) and generate a right path to implement dijkstra's.\n\n```\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.image.BufferedImage;\nimport java.io.BufferedReader;\nimport java.io.DataInputStream;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.EventQueue;\nimport java.awt.Graphics;\nimport java.awt.Point;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n//import DrawingRects;\n\n\n\n\n\nimport javax.swing.JPanel;\n\n\npublic class GlobalNav {\n\n//private static BufferedReader br;\n    public static final ArrayList<Float> storeCoordinateList = new ArrayList<Float>();\n    public static final ArrayList<Rectangle2D> rectangleList = new ArrayList<Rectangle2D>();\n    public static final ArrayList<Float> storeCoordinates = new ArrayList<Float>();\n    public static final ArrayList<Point2D> points = new ArrayList<Point2D>();\n\n    public static void main(String[] args) throws IOException {\n\n//ArrayList<Float> storeCoordinateList = new ArrayList<Float>();  \n        FileInputStream fstream = new FileInputStream(args[0]);  \n// Get the object of DataInputStream  \n        DataInputStream in = new DataInputStream(fstream);  \n        BufferedReader br = new BufferedReader(new InputStreamReader(in));  \n        String strLine;  \n//Read File Line By Line  \n        while ((strLine = br.readLine()) != null) {  \n            String[] nums = strLine.split(\" \");\n            for (String n : nums){\n                try {\n                    Float num = Float.parseFloat(n);\n                    storeCoordinateList.add(num);\n                }\n                catch(NumberFormatException e){\n\n                }\n            }    \n        }\n\n\n//Close the input stream \n        System.out.println(\"Co-ordinate List \" + storeCoordinateList);\n        in.close();  \n        System.out.println(\"Size of Coo \" + storeCoordinateList.size());\n\n        System.out.println(\"GlobalNav.main()4 \" + storeCoordinateList.size());\n        int x1 = 2, x2 = 3, y1 = 4, y2 = 5;\n//int xmin = 2, xmax = 3, ymin = 4, ymax =5;\n        System.out.println(\"GlobalNav.main()\" + storeCoordinateList.size());\n\n        int expansion = 210;\n        points.add(new Point2D.Float(0, 0));\n\n        while(y2 < storeCoordinateList.size()){\n//System.out.println(\"GlobalNav.main()\" + x1);\n            float height = (storeCoordinateList.get(y2)) - (storeCoordinateList.get(y1));\n            float width = (storeCoordinateList.get(x2)) - (storeCoordinateList.get(x1));\n//Rectangle rect = new Rectangle(Math.round(storeCoordinateList.get(x1)), Math.round(storeCoordinateList.get(y1)), Math.round(height), Math.round(width));\n            Rectangle2D.Float rect = new Rectangle2D.Float(storeCoordinateList.get(x1), storeCoordinateList.get(y1), height, width);\n            rectangleList.add(rect);\n\n\n            points.add(new Point2D.Float(storeCoordinateList.get(x1), storeCoordinateList.get(y1)));\n            points.add(new Point2D.Float(storeCoordinateList.get(x1), storeCoordinateList.get(y2)));\n            points.add(new Point2D.Float(storeCoordinateList.get(x2), storeCoordinateList.get(y1)));\n            points.add(new Point2D.Float(storeCoordinateList.get(x2), storeCoordinateList.get(y2)));\n\n            x1 += 4;\n            x2 += 4;\n            y1 += 4;\n            y2 += 4;\n\n        }\n        points.add(new Point2D.Float(storeCoordinateList.get(0), storeCoordinateList.get(1)));\n        System.out.println(\"List\" + rectangleList.toString());\n\n        System.out.println(\"List\" + points.toString());\n\n\n        filterIntersectionEdges(points);\n\n\n    }\n\n    private static void filterIntersectionEdges(ArrayList<Point2D> points2) {\n// TODO Auto-generated method stub\n        ArrayList<Edge> edge = new ArrayList<Edge>();\n//edge.add(Point(0, 0));\n        ArrayList<ArrayList<Edge>> listOfEdges = new ArrayList<ArrayList<Edge>>();\n        for (int i = 0; i < points2.size(); i++) {\n            for (int j = i + 1; j < points2.size(); j++) {\n                edge.add(new Edge(points2.get(i),points2.get(j)));\n\n                listOfEdges.add(edge);\n\n//              System.out.println(\"Edges\" + edge.toString());\n//              System.out.println(\"List of Edges\" + listOfEdges.toString());\n            }\n\n        }\n\n\n\n        Edge line1 = new Edge();\n        int i = 0;\n        for (ArrayList<Edge> newEdge : listOfEdges) {\n            line1 = newEdge.get(i);\n\n\n\n\n            for (Iterator iterator = newEdge.iterator(); iterator.hasNext();) {\n                Edge line2 = (Edge) iterator.next();\n//System.out.println(\" lIne 2 \" + line2);\n\n\n\n            }\n            i++;\n\n\n        } \n\n\n    }\n\n}\n\n\nclass Edge{\n\n    private Point2D pointA;\n    private Point2D pointB;\n\n    public Edge(Point2D pointA, Point2D pointB){\n        this.pointA = pointA;\n        this.pointB = pointB;\n    }\n\n    public String size() {\n// TODO Auto-generated method stub\n\n        return null;\n    }\n\n    public Edge() {\n// TODO Auto-generated constructor stub\n    }\n\n    public Point2D getPoint1(){\n        return this.pointA;\n    }\n\n    public Point2D getPoint2(){\n        return this.pointB;\n    }\n\n    @Override\n    public String toString(){\n        return \"Point 1:\" + pointA.toString() + \" Point 2:\" + pointB.toString();\n    }\n\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm: is my implementation flawed?\r\n                \r\nIn order to train myself both in Python and graph theory, I tried to implement the Dijkstra algo using Python 3, and submitted it against several online judges, to see if it was correct.\n\nIt works well in many cases, but not always.\n\nFor example, I am stuck with this one: the test case works fine and I also have tried custom test cases of my own, but when I submit the following solution, the judge keeps telling me \"wrong answer\", and the expected result is very different from my output, indeed.\n\nNotice that the judge tests it against quite a complex graph (10000 nodes with 100000 edges), while all the cases I tried before never exceeded 20 nodes and around 20-40 edges.\n\nHere is my code.\n\nGiven ```\nal```\n an adjacency list in the following form:\n\n```\nal[n] = [(a1, w1), (a2, w2), ...]\n```\n\n\nwhere\n\n\n```\nn```\n is the node id;\n```\na1, a2, etc.```\n are its adjacent nodes and ```\nw1, w2, etc.```\n the respective weights for the given edge;\n\n\nand supposing that maximum distance never exceeds 1 billion, I implemented Dijkstra's algorithm this way:\n\n```\nimport queue\n\ndistance = [1000000000] * (N+1) # this is the array where I store the shortest path between 1 and each other node\ndistance[1] = 0 # starting from node 1 with distance 0\n\npq = queue.PriorityQueue()\npq.put((0, 1)) # same as above\n\nvisited = [False] * (N+1) \n\nwhile not pq.empty():\n    n = pq.get()[1]\n    if visited[n]:\n        continue\n    visited[n] = True\n    for edge in al[n]:\n        if distance[edge[0]] > distance[n] + edge[1]:\n            distance[edge[0]] = distance[n] + edge[1]\n            pq.put((distance[edge[0]], edge[0]))\n```\n\n\nCould you please help me understand wether my implementation is flawed, or if I simply ran into some bugged online judge?\n\nThank you very much.\n\nUPDATE\n\nAs requested, I'm providing the snippet I use to populate the adjacency list ```\nal```\n for the linked problem.\n\n```\nN,M = input().split()\nN,M = int(N), int(M)\n\nal = [[] for n in range(N+1)]\n\nfor m in range(M):\n    try:\n        a,b,w = input().split()\n        a,b,w = int(a), int(b), int(w)\n        al[a].append((b, w))\n        al[b].append((a, w))\n    except:\n       pass\n```\n\n\n(Please don't mind the ugly \"except: pass\", I was using it just for debugging purposes... :P)\n    ", "Answer": "\r\nPrimary problem in interpreting the question:\n\nAccording to your parsing code, you are treating the input data as an undirected graph, i.e. each edge from A to B also is an edge from B to A. \nIs seems like this premise is not valid and it should instead be a directed graph, i.e. you have to remove this line:\n\n```\n    al[b].append((a, w))  # no back reference!\n```\n\n\n\n\nPrevious problem, now already fixed in the code:\n\nCurrently, you are using the never-changing weight of the edges in your queue:\n\n```\n        pq.put((edge[1], edge[0]))\n```\n\n\nThis way, the nodes always end up at the same position in the queue, no matter at what stage of the algorithm and how far the path to reach that node actually is.\nInstead, you should use the new distance to the target node ```\nedge[0]```\n, i.e. ```\ndistance[edge[0]]```\n as the priority in the queue:\n\n```\n        pq.put((distance[edge[0]], edge[0]))\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "What algorithms did Dijkstra develop?\r\n                \r\nI recently asked a question about one of the Dijkstra’s algorithms (shunting-yard). But almost everyone thought \"Dijkstra's algorithm\" meant his shortest path algorithm.\n\nWhat other algorithms has Dijkstra developed?\n    ", "Answer": "\r\nAlgorithms by Edsger W. Dijkstra\n\n\nDijkstra's algorithm\nShunting-yard algorithm\nBanker's algorithm\nSmooth Sort\nDijkstra-Scholten algorithm\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "dijkstra's shortest path algorithm backtracks?\r\n                \r\nI am trying to implement dijkstra's shortest path algorithm using map reduce.\n\nI have two questions:\n\n\nDoes this algorithms backtracks to re-evaluate the distances in case the distance turns out to be less for not selected path. For example-> 1->2->5 and 2->3->2 consider these values to be weights and possible 2 paths to a destination path 1 would be selected as 1<2 but overall sum of weights is less for path 2 that is 2->3->2 so want to know if dijkstra's algorithm takes care of backtracking.\nPlease give me a brief idea of how map and reduce function will be in this case. I am thinking of emitting in map function  as  and in reduce function  and in reduce function I iterate over associated weights to find the least weighted neighbour ..but after that how it function. Please give me a good idea of how it happens from scratch in a cluster and what happens internally.\n\n    ", "Answer": "\r\nDijkstra's does not perform backtracking to re-evaluate the distances.\n\nhttp://upload.wikimedia.org/wikipedia/commons/5/57/Dijkstra_Animation.gif\n\nthat gif should help you understand how Dijkstra's algorithm re-evaluate distances. It avoids the task of backtracking by storing the \"shortest path to node n\" inside node n. \n\nDuring traversal if the algorithm comes across node n again, it will simply compare the current \"distance\" it traversed to get to node n and compare it to the data stored in node n. If it is greater it ignores it and if it is lesser it keeps replaces the data in node n.\n\nDijkstra's however has a limitation when dealing with negative edges since you could end up with a negative cycle in some circumstances, so that is something you should be wary of.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "difference between Bellman Ford and Dijkstra's algorithm\r\n                \r\n```\n   2           1\n1----------2---------4\n|          |         |\n|3         |3        |1\n|    6     |         |\n3---------5 ---------\n```\n\n\nOk, so this is the graph.  My source node is ```\n1```\n and destination node is ```\n5```\n\n\nMy question is.\n\nAre both the algorithms going to give the same output or not?\nThat is, will both return ```\n1->2->4->5```\n?  (Except that negative weights are not allowed in dijkstra's)\n\nThanks in advance for help.\n    ", "Answer": "\r\nBellman-Ford algorithm is a single-source shortest path algorithm, which allows for negative edge weight and can detect negative cycles in a graph.\n\nDijkstra algorithm is also another single-source shortest path algorithm. However, the weight of all the edges must be non-negative.\n\nFor your case, as far as the total cost is concerned, there will be no difference, since the edges in the graph have non-negative weight. However, Dijkstra's algorithm is usually used, since the typical implementation with binary heap has ```\nTheta((|E|+|V|)log|V|)```\n time complexity, while Bellman-Ford algorithm has ```\nO(|V||E|)```\n complexity.\n\nIf there are more than 1 path that has minimum cost, the actual path returned is implementation dependent (even for the same algorithm).\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra Algorithm OpenMP Slower than Single Thread\r\n                \r\nI'm trying to parallelise Dijkstra's Algorithm using OpenMP but the serial version runs x40 times faster. I might be missing a concept or doing something wrong. I'm new to parallelism and OpenMP. Can you please help out? Thanks.\n\n```\nlong* prev; // array of pointers to preceding vertices\nlong* dist; // array of distances from the source to each vertex\nlong* visited; // visited vertices, 0 if not visited, 1 otherwise\nlong** vSetDistance; // distance between i and j\n\nvoid dijkstraAlgorithm(\n      long * prev, \n      long * dist, \n      long * visited, \n      long ** vSetDistance) \n   {\n   int i, j, min;\n\n   // Initialization: set every distance to INFINITY until we discover a path\n   for (i = 1; i <= numVertices; i++) \n      {\n      prev[i] = -1;\n      visited[i] = 0;\n      dist[i] = INFINITY;\n      }\n\n   // The distance from the source to the source is defined to be zero\n   dist[sourceVertex] = 0; \n\n      {\n      for (j = 1; j <= numVertices; j++)\n         {\n         min = -1;\n\n#pragma omp parallel default(none) private(i, j) \\\n   shared(min, visited, dist, prev, vSetDistance, numVertices)\n\n            {\n            /* This loop corresponds to sending out the explorers walking the paths,\n             * where the step of picking \"the vertex, v, with the shortest path to s\"\n             * corresponds to an explorer arriving at an unexplored vertex */\n\n#pragma omp for\n\n            for (i = 1; i <= numVertices; i++)\n#pragma omp critical\n               {\n               if (!visited[i] && ((min == -1) || (dist[i] <= dist[min])))\n                  min = i;\n               }\n\n            visited[min] = 1; // visited = true\n\n            // relaxation\n#pragma omp for\n            for (i = 1; i <= numVertices; i++) \n               {\n               if (vSetDistance[min][i]) \n                  {\n                  if ((dist[min] + vSetDistance[min][i]) < dist[i]) \n                     {\n                     dist[i] = dist[min] + vSetDistance[min][i];\n                     prev[i] = min;\n                     }\n                  }\n               }\n            }\n         }\n      }\n   }\n```\n\n    ", "Answer": "\r\nParallelization isn't always a free ticket to higher performance. I see two things that could be causing the slowdown.\n\n\nThe critical section is probably spending a lot of time dealing with synchronization. I'm not entirely familiar with how those sections are implemented in OpenMP but my first guess would be that they use mutexes to lock access to that section. Mutexes aren't super cheap to lock/unlock, and that operation is much more expensive than the operations you want to perform. In addition, since the loop is entirely in a critical section, all but one of the threads will just be waiting around for the thread in the critical section to finish. Essentially, that loop will still be done in a serial fashion with the added overhead of synchronization.\nThere may not be enough vertices to benefit from parallelization. Again, starting threads isn't free, and the overhead may be significantly larger than the time gained. This becomes more and more pronounced as the number of vertices becomes smaller.\n\n\nMy guess is that the first problem is where most of the slowdown occurs. The easiest way to mitigate this problem is to simply do it in a serial fashion. Second, you could try having each thread find the minimum only in its own section, and them compare those in serial after the parallel portion.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm: is my implementation flawed?\r\n                \r\nIn order to train myself both in Python and graph theory, I tried to implement the Dijkstra algo using Python 3, and submitted it against several online judges, to see if it was correct.\n\nIt works well in many cases, but not always.\n\nFor example, I am stuck with this one: the test case works fine and I also have tried custom test cases of my own, but when I submit the following solution, the judge keeps telling me \"wrong answer\", and the expected result is very different from my output, indeed.\n\nNotice that the judge tests it against quite a complex graph (10000 nodes with 100000 edges), while all the cases I tried before never exceeded 20 nodes and around 20-40 edges.\n\nHere is my code.\n\nGiven ```\nal```\n an adjacency list in the following form:\n\n```\nal[n] = [(a1, w1), (a2, w2), ...]\n```\n\n\nwhere\n\n\n```\nn```\n is the node id;\n```\na1, a2, etc.```\n are its adjacent nodes and ```\nw1, w2, etc.```\n the respective weights for the given edge;\n\n\nand supposing that maximum distance never exceeds 1 billion, I implemented Dijkstra's algorithm this way:\n\n```\nimport queue\n\ndistance = [1000000000] * (N+1) # this is the array where I store the shortest path between 1 and each other node\ndistance[1] = 0 # starting from node 1 with distance 0\n\npq = queue.PriorityQueue()\npq.put((0, 1)) # same as above\n\nvisited = [False] * (N+1) \n\nwhile not pq.empty():\n    n = pq.get()[1]\n    if visited[n]:\n        continue\n    visited[n] = True\n    for edge in al[n]:\n        if distance[edge[0]] > distance[n] + edge[1]:\n            distance[edge[0]] = distance[n] + edge[1]\n            pq.put((distance[edge[0]], edge[0]))\n```\n\n\nCould you please help me understand wether my implementation is flawed, or if I simply ran into some bugged online judge?\n\nThank you very much.\n\nUPDATE\n\nAs requested, I'm providing the snippet I use to populate the adjacency list ```\nal```\n for the linked problem.\n\n```\nN,M = input().split()\nN,M = int(N), int(M)\n\nal = [[] for n in range(N+1)]\n\nfor m in range(M):\n    try:\n        a,b,w = input().split()\n        a,b,w = int(a), int(b), int(w)\n        al[a].append((b, w))\n        al[b].append((a, w))\n    except:\n       pass\n```\n\n\n(Please don't mind the ugly \"except: pass\", I was using it just for debugging purposes... :P)\n    ", "Answer": "\r\nPrimary problem in interpreting the question:\n\nAccording to your parsing code, you are treating the input data as an undirected graph, i.e. each edge from A to B also is an edge from B to A. \nIs seems like this premise is not valid and it should instead be a directed graph, i.e. you have to remove this line:\n\n```\n    al[b].append((a, w))  # no back reference!\n```\n\n\n\n\nPrevious problem, now already fixed in the code:\n\nCurrently, you are using the never-changing weight of the edges in your queue:\n\n```\n        pq.put((edge[1], edge[0]))\n```\n\n\nThis way, the nodes always end up at the same position in the queue, no matter at what stage of the algorithm and how far the path to reach that node actually is.\nInstead, you should use the new distance to the target node ```\nedge[0]```\n, i.e. ```\ndistance[edge[0]]```\n as the priority in the queue:\n\n```\n        pq.put((distance[edge[0]], edge[0]))\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm - complexity\r\n                \r\nI have a certain problem understanding the complexity of the Djisktra algorithm and hope someone can correct me.\n\nFor my example I took a complete graph with n vertices. \n\nYou pick a starting vertex, lets say a1, mark it, and then compute all n-1 weights on the edges. O(n)\n\nYou pick the smallest one. Let's say vertex a2 and mark it. O(n)\n\nAfter that you compute n-2 new weights on the edges and look for the next yet unmarked vertex to add your set of marked vertices. \n\nAnd so on...\n\nThe algorithm runs til you could mark all vertices. Complexity: n-1 + n-2 + ... + n - (n - 1) = Binom(n,2) which is in O(n^2), not O(n*ln(n)) what I want. \n\nI read about many many times people use a heap for optimization, however I still don't see how to avoid Binom(n,2) computations. \n\nI have to be wrong at some point, but do not see where.   \n    ", "Answer": "\r\nIf you have a complete graph, then of course you can't do any better than O(n^2) -- because, that's the size of your input.\n\nIf you don't have a complete graph, and are storing your edges in an adjacency list, then you can do better.  You still need to look at all your edges, but with a priority queue you can manage O(e + n log n) where e is the number of edges in your adjacency list.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm Java, path error when use multiple source\r\n                \r\nI found Dijkstra's Algorithm from internet (here the original code) , and I try to use multiple source instead multiple destination. But when I run the code, output isn't right, it just shows first vertex for all output.\n\n```\nimport java.util.PriorityQueue;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\nclass Vertex implements Comparable<Vertex> {\n\n    public final String name;\n    public Edge[] adjacencies;\n    public double minDistance = Double.POSITIVE_INFINITY;\n    public Vertex previous;\n    public Vertex(String argName) { name = argName; }\n    public String toString() { return name; }\n    public int compareTo(Vertex other) {\n        return Double.compare(minDistance, other.minDistance);\n    }\n\n}\n\nclass Edge {\n\n    public final Vertex target;\n    public final double weight;\n\n    public Edge(Vertex argTarget, double argWeight) {\n        target = argTarget;\n        weight = argWeight;\n    }\n\n}\n\npublic class tes_dijkstra {\n\n    public static void computePaths(Vertex source) {\n        source.minDistance = 0.;\n        PriorityQueue<Vertex> vertexQueue = new PriorityQueue<Vertex>();\n        vertexQueue.add(source);\n\n        while (!vertexQueue.isEmpty()) {\n            Vertex u = vertexQueue.poll();\n            // Visit each edge exiting u\n            for (Edge e : u.adjacencies) {\n                Vertex v = e.target;\n                double weight = e.weight;\n                double distanceThroughU = u.minDistance + weight;\n                if (distanceThroughU < v.minDistance) {\n                    vertexQueue.remove(v);\n                    v.minDistance = distanceThroughU ;\n                    v.previous = u;\n                    vertexQueue.add(v);\n                }\n            }\n        }\n    }\n\n    public static List<Vertex> getShortestPathTo(Vertex target) {\n        List<Vertex> path = new ArrayList<Vertex>();\n        for (Vertex vertex = target; vertex != null; vertex = vertex.previous)\n            path.add(vertex);\n        Collections.reverse(path);\n        return path;\n    }\n\n    public static void main(String[] args) {\n        Vertex v0 = new Vertex(\"Redvile\");\n        Vertex v1 = new Vertex(\"Blueville\");\n        Vertex v2 = new Vertex(\"Greenville\");\n        Vertex v3 = new Vertex(\"Orangeville\");\n        Vertex v4 = new Vertex(\"Purpleville\");\n\n        v0.adjacencies = new Edge[]{ new Edge(v1, 5),\n                                     new Edge(v2, 10),\n                                     new Edge(v3, 8) };\n        v1.adjacencies = new Edge[]{ new Edge(v0, 5),\n                                     new Edge(v2, 3),\n                                     new Edge(v4, 7) };\n        v2.adjacencies = new Edge[]{ new Edge(v0, 10),\n                                     new Edge(v1, 3) };\n        v3.adjacencies = new Edge[]{ new Edge(v0, 8),\n                                     new Edge(v4, 2) };\n        v4.adjacencies = new Edge[]{ new Edge(v1, 7),\n                                 new Edge(v3, 2) };\n        Vertex[] start = { v1, v2, v3, v4 };\n        Vertex[] end ={v2};\n\n        for (int i = 0; i < start.length; i++){\n            for(int j = 0; j < end.length; j++){\n                computePaths(start[i]);\n                System.out.println(\"Distance to \" + end[j] + \": \" + end[j].minDistance);\n                List<Vertex> path = getShortestPathTo(end[j]);\n                System.out.println(\"Path: \" + path);\n            }\n        }\n    }\n}\n```\n\n\nand this is how the output looks like :\n\n```\nDistance to Greenville: 3.0\nPath: [Blueville, Greenville]\nDistance to Greenville: 0.0\nPath: [Blueville, Greenville]\nDistance to Greenville: 0.0\nPath: [Blueville, Greenville]\nDistance to Greenville: 0.0\nPath: [Blueville, Greenville]\n```\n\n\nThe output just shows first vertex from Vertex[] start (v1 = Blueville) for all output.\nI don't know where is wrong, is path stored somewhere? I kinda new in java and I want to learn this algorithm for my assignment, so please help. Thank you\n    ", "Answer": "\r\nYes the vertices store information about the cost and the path that is constructed. The problem is not that much that the path itself is constructed but the ```\nminDistance```\n is the distance from a given start vertex. You can implement a method ```\nreset```\n in the ```\nVertex```\n class\n\n```\nvoid reset () {\n    this.minDistance = Double.POSITIVE_INFINITY;\n}\n```\n\n\nAnd furthermore you need to reset all vertices of the graph when you want to perform the next Dijkstra's algorithm:\n\n```\npublic static List<Vertex> getShortestPathTo(Vertex target) {\n    List<Vertex> path = new ArrayList<Vertex>();\n    for (Vertex vertex = target; vertex != null; vertex = vertex.previous)\n        path.add(vertex);\n    Collections.reverse(path);\n    return path;\n}\n\npublic static void main(String[] args) {\n    Vertex v0 = new Vertex(\"Redvile\");\n    Vertex v1 = new Vertex(\"Blueville\");\n    Vertex v2 = new Vertex(\"Greenville\");\n    Vertex v3 = new Vertex(\"Orangeville\");\n    Vertex v4 = new Vertex(\"Purpleville\");\n\n    v0.adjacencies = new Edge[]{ new Edge(v1, 5),\n                                 new Edge(v2, 10),\n                                 new Edge(v3, 8) };\n    v1.adjacencies = new Edge[]{ new Edge(v0, 5),\n                                 new Edge(v2, 3),\n                                 new Edge(v4, 7) };\n    v2.adjacencies = new Edge[]{ new Edge(v0, 10),\n                                 new Edge(v1, 3) };\n    v3.adjacencies = new Edge[]{ new Edge(v0, 8),\n                                 new Edge(v4, 2) };\n    v4.adjacencies = new Edge[]{ new Edge(v1, 7),\n                             new Edge(v3, 2) };\n    Vertex[] start = { v1, v2, v3, v4 };\n    Vertex[] end = {v2};\n    Vertex[] all = {v0, v1, v2, v3, v4};\n\n    for (int i = 0; i < start.length; i++){\n        for(int j = 0; j < end.length; j++){\n            computePaths(start[i]);\n            System.out.println(\"Distance to \" + end[j] + \": \" + end[j].minDistance);\n            List<Vertex> path = getShortestPathTo(end[j]);\n            System.out.println(\"Path: \" + path);\n        }\n        //a new start vertex: reset the graph\n        for(Vertex v : all) {\n            v.reset();\n        }\n    }\n}\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "In Dijkstra's algorithm why must it first expand nodes with the current least cost?\r\n                \r\nI have read in other posts that Dijkstra's algorithm always expands the shortest path first. Why must it be implemented in such a way? Say we created a relaxed version of Dijkstra's that expands any unvisited paths/nodes as long as they have a cost (calculated on the previous iteration) that's less than infinity. \n\nI have worked through some examples and have yet to show an example that fails to calculate the correct shortest path using this relaxed version of the algorithm.\n    ", "Answer": "\r\nIf you expand any node, you would eventually find some path to the goal but you cannot guarantee that the path cost to the goal is optimal.\n\nIf you find a cheaper path to an already visited node, you would have to update all nodes from this visited node transitively, rendering your relaxed algorithm less efficient than the original one.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Shortest Path using Dijkstra's Algorithm Output Question\r\n                \r\n\n\nI was tasked to create a program that would output the shortest paths to all other nodes. So for example in this photo, with source A, ( https://www.includehelp.com/cpp-tutorial/Images/d0.jpg ) the output will be (unordered or ordered would be fine):\n\n\nA-B\nA-C\nA-B-G\nA-B-G-E-D\nA-B-G-E\nA-B-G-E-F\n..........\n\n\nCurrent Output:\n\n```\nAC ED BG E FD \n```\n\n\n*It shows the correct partial shortest paths but I just can't figure out how to somehow connect them.\n\nSo far, I have been able to compute the shortest path costs correctly from the source to each node using Dijkstra's Algorithm. However, I can't seem to figure out how to output the \"connected path directions\" as seen above.\n\nCode:\n\n```\n#include<iostream>\n#include<climits>    \n#include<vector> \n#include<string> \n\nusing namespace std;\nint src = 0;\nint vertex;\n\nstruct node {\n    string source;\n    vector<string> dest;\n    vector<int> cost;\n};\n\nint minimumcost(vector<int> cost, vector<bool> Cset, vector<node> Node);\nvoid dijkstra(vector<vector<int>> graph, vector<node> Node);\nvector<vector<int>> graph(vector<node> Node);\nstring delimiter(string temp);\nvoid Print(vector<vector<string>> listed);\n\nint main()\n{\n    vector<node> Node;\n    vector<string> _dest,_dest1;\n    string root;\n    string temp1;\n    string temp2;\n    int cost;\n    int i = 0;\n    int check = 0;\n\n        for(int i=0;i<i+1;){\n            cin>>temp1;\n            if(temp1 == \"root\"){\n                cin>>root;\n                break;\n            }\n            temp1 = delimiter(temp1);\n            for(int j=0; j<i; j++){\n                if(temp1 == Node[j].source){\n                        cin>>temp2;\n                        temp2 = delimiter(temp2);\n                        Node[j].dest.push_back(temp2);\n                        _dest.push_back(temp2);\n                        cin>>cost;\n                        Node[j].cost.push_back(cost);\n                        check = 1;\n                        break;\n                    }\n                }\n            if(check == 0){\n                Node.push_back(node());\n                Node[i].source = temp1;\n                cin>>temp2;\n                temp2 = delimiter(temp2);\n                Node[i].dest.push_back(temp2);\n                _dest.push_back(temp2);\n                cin>>cost;\n                Node[i].cost.push_back(cost);   \n                i++;\n                }\n            check = 0;\n\n        }\n\n\n    sort(_dest.begin(), _dest.end() );\n    _dest.erase( unique( _dest.begin(), _dest.end() ), _dest.end() );\n\n    for(int i=0; i<_dest.size(); i++){\n        for(int j=0; j<Node.size(); j++){\n            if(_dest[i] == Node[j].source){\n                _dest.erase(_dest.begin()+i);\n                i--;\n            }\n        }\n    }\n    for(int i=0; i<_dest.size(); i++){\n        Node.push_back(node());\n        Node[Node.size()-1].source = _dest[i];\n    }\n\n    vertex = Node.size();\n    cout<<'\\n';\n\n    dijkstra(graph(Node),Node);\n    cout<<'\\n';\n    return 0;                           \n}\n\n\nvector<vector<int>> graph(vector<node> Node){\nint V = Node.size();\nvector<int> temp(V, 0);\nvector<string> elements;\nvector<vector<int>> graph(V, temp);\n     cout<<\"  \";\n    for(int i=0; i<V;i++){\n        elements.push_back(Node[i].source);\n    }\n\n    cout<<'\\n';\n    for(int i=0; i<V;i++){\n        for(int j=0; j<V;j++){\n            for(int k=0; k<Node[i].dest.size();k++){\n                if(Node[i].dest[k] == elements[j])\n                   graph[i][j] = Node[i].cost[k];\n            }\n        }\n\n    }\n\nreturn graph;\n}\n\nstring delimiter(string temp){\n    if(temp != \"root\")\n            temp[temp.size()-1] = '\\0';\n    return temp;\n}\n\n\nint minimumcost(vector<int> cost, vector<bool> Cset, vector<node> Node)  {\n\n    int min = INT_MAX;                 \n    int index;\n\n    for(int v=0;v<vertex;v++)\n    {\n        if(Cset[v]==false && cost[v]<=min)      \n        {\n            min=cost[v];\n            index=v;\n\n        }\n    }\n\n    return index;\n}\n\nvoid dijkstra(vector<vector<int>> graph, vector<node> Node){\n    vector<int> Cost(vertex,0);                  \n    vector<bool> Cset(vertex,0);  \n    vector<string> elements;\n    vector<string> temp(1,\" \");\n    vector<vector<string>> listed(vertex, temp);\n\n    for(int i=0; i<vertex;i++){\n        elements.push_back(Node[i].source);\n    }\n\n    for(int i=0;i<vertex;i++)                    \n    {\n        Cost[i]=INT_MAX;\n        Cset[i]=false;  \n    }\n\n    Cost[src]=0;   \n\n    for(int i=0;i<vertex;i++){\n        int u=minimumcost(Cost,Cset,Node);\n        Cset[u]=true;                \n        for(int j=0;j<vertex;j++){\n            if(!Cset[j] && graph[u][j] && Cost[u]!=INT_MAX && Cost[u]+graph[u][j]<Cost[j]){\n                Cost[j]=Cost[u]+graph[u][j];\n                if(graph[u][j] < graph[u][j-1]){\n                    listed[i].push_back(elements[i]);\n                    listed[i][listed[i].size()-2] = elements[j];\n                }\n                else\n                    listed[i].push_back(elements[j]);\n            }\n        }\n\n    }\n\n\n    cout<<\"Vertex\\t\\tCost from source\"<<endl;\n    for(int i=0;i<vertex;i++)                       \n    {\n        cout<<elements[i]<<\"\\t\\t\"<<Cost[i]<<endl;\n    }\n    cout<<\"\\n\";     \n    Print(listed);\n    cout<<\"\\n\"; \n}\n\nvoid Print(vector<vector<string>> listed){\nvector<vector<string>> temp;\nfor(int i = 0; i<vertex; i++)\n    reverse(listed[i].begin(),listed[i].end());\n\n\n    for(int i=0;i<listed.size();i++)                       \n    {\n        for(int j=0;j<listed[i].size();j++)     \n            cout<<listed[i][j];\n    }\n\n    for(int i=0;i<listed.size();i++){\n        temp.push_back({{0}});\n        for(int j=0;j<i;j++){\n            for(int k=0;k<listed[j].size();k++){\n                temp[i].push_back(listed[j][k]);\n            }\n        } \n    }\n\n}\n```\n\n\n\nInput:\n\n```\nA, B, 5\nA, C, 3\nD, A, 2\nB, C, 2\nC, D, 7\nB, G, 1\nB, E, 3\nC, E, 7\nE, D, 2\nD, F, 6\nG, E, 1\nE, F, 1\nroot A\n```\n\n\nPlease help. I'm stuck. Thank you.\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How accurate is Dijkstra Algorithm?\r\n                \r\nIs it necessary that Dijkstra Algorithm always finds the shortest part between two veritices?\n    ", "Answer": "\r\nYes, it does.  It has been proven:\n\n\n  Proof of Dijkstra's algorithm is constructed by induction on the\n  number of visited nodes. \n  \n  Invariant hypothesis: For each visited node v, dist[v] is considered\n  the shortest distance from source to v; and for each unvisited node u,\n  dist[u] is assumed the shortest distance when traveling via visited\n  nodes only, from source to u. This assumption is only considered if a\n  path exists, otherwise the distance is set to infinity. (Note : we do\n  not assume dist[u] is the actual shortest distance for unvisited\n  nodes)\n  The base case is when there is just one visited node, namely\n  the initial node source, in which case the hypothesis is trivial. \n  \n  Otherwise, assume the hypothesis for n-1 visited nodes. In which case,\n  we choose an edge vu where u has the least dist[u] of any unvisited\n  nodes and the edge vu is such that dist[u] = dist[v] + length[v,u].\n  dist[u] is considered to be the shortest distance from source to u\n  because if there were a shorter path, and if w was the first unvisited\n  node on that path then by the original hypothesis dist[w] > dist[u]\n  which creates a contradiction. Similarly if there was a shorter path\n  to u without using unvisited nodes, and if the last but one node on\n  that path were w, then we would have had dist[u] = dist[w] +\n  length[w,u], also a contradiction.  \n  \n  After processing u it will still\n  be true that for each unvisited nodes w, dist[w] will be the shortest\n  distance from source to w using visited nodes only, because if there\n  were a shorter path that doesn't go by u we would have found it\n  previously, and if there were a shorter path using u we would have\n  updated it when processing u.\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Can we use dijkstra algorithm to find any cycles\r\n                \r\nCan we use Dijkstra's algorithm to find cycles??? \n\n\nNegative cycles\nPositive cycles\n\n\nIf we can what, are the changes we have to do?\n    ", "Answer": "\r\n1) Dijkstra's doesn't work on graphs with negative edges because you can (possibly) find a minimum distance of negative infinity.\n\n2) Um, you normally run it on graphs with cycles (otherwise, you might as well be traversing a tree), so it can handle them just fine.\n\nIf your real question is just about finding cycles, look at Finding all cycles in graph\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Cannot cast to java.lang.Comparable exception while trying to implement Dijkstra's Algorithm [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        MyClass cannot be cast to java.lang.Comparable: java.lang.ClassCastException\r\n                            \r\n                                (3 answers)\r\n                            \r\n                    \r\n                Closed 5 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI have implemented Dijkstra's Algorithm using PriorityQueue. However on running the code, I get the following exception :\n\n```\nException in thread \"main\" java.lang.ClassCastException: Dijkstra$Vertex cannot be cast to java.lang.Comparable\n    at java.util.PriorityQueue.siftUpComparable(Unknown Source)\n    at java.util.PriorityQueue.siftUp(Unknown Source)\n    at java.util.PriorityQueue.offer(Unknown Source)\n    at java.util.PriorityQueue.add(Unknown Source)\n    at Dijkstra.dijkstra(Dijkstra.java:55)\n    at Dijkstra.main(Dijkstra.java:89)\n```\n\n\nThe code used is :\n\n```\nimport java.util.HashSet;\nimport java.util.PriorityQueue;\n\n\npublic class Dijkstra {\n    static class Vertex{\n        private int vertexid;\n        private Double distance;\n\n        public Vertex(int vertexid, Double distance) {\n            this.vertexid = vertexid;\n            this.distance = distance;\n        }\n\n        public int getVertexid() {\n            return vertexid;\n        }\n\n        public Double getDistance() {\n            return distance;\n        }\n\n        public int compareTo(Vertex other) {\n            return this.getDistance().compareTo(other.getDistance());\n        }\n\n        public boolean equals(Object o) {\n            if (o instanceof Vertex) {\n                Vertex v = (Vertex) o;\n                return vertexid == v.vertexid && distance == v.distance;\n            }\n            return false;\n        }\n    }\n\n    public static void dijkstra(double g[][], int n, int m, int source) {\n        // g is the adjacency matrix\n        // n is the number of nodes\n        // m is the number of edges\n\n        // initialize shortest path\n\n        double d[] = new double[n];\n\n        d[source] = 0;\n        for (int i = 0; i < n; i++) {\n            d[i] = Double.POSITIVE_INFINITY;\n        }\n\n        HashSet<Integer> s = new HashSet<Integer>();\n        PriorityQueue<Vertex> q = new PriorityQueue<Vertex>();\n\n        // initialize q\n        for (int i = 0; i < n; i++) {\n            q.add(new Vertex(i, d[i]));\n        }\n\n        Vertex u;\n\n        while (!q.isEmpty()) {\n            u = q.remove();\n            System.out.println(u.getVertexid() + \"\\t\" + u.getDistance());\n            s.add(u.getVertexid());\n\n            for (int i = 0; i < n; i++) {\n                if (i != u.getVertexid() && g[u.getVertexid()][i] != Double.POSITIVE_INFINITY) {\n                    if (u.getDistance().doubleValue() + g[u.getVertexid()][i] < d[i]) {\n                        q.remove(new Vertex(i, d[i]));\n                        d[i] = u.getDistance().doubleValue() + g[u.getVertexid()][i];\n                        q.add(new Vertex(i, d[i]));\n                    }\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        double graph[][] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n                {4, 0, 8, 0, 0, 0, 0, 11, 0},\n                {0, 8, 0, 7, 0, 4, 0, 0, 2},\n                {0, 0, 7, 0, 9, 14, 0, 0, 0},\n                {0, 0, 0, 9, 0, 10, 0, 0, 0},\n                {0, 0, 4, 14, 10, 0, 2, 0, 0},\n                {0, 0, 0, 0, 0, 2, 0, 1, 6},\n                {8, 11, 0, 0, 0, 0, 1, 0, 7},\n                {0, 0, 2, 0, 0, 0, 6, 7, 0}\n               };\n\n        Dijkstra.dijkstra(graph, 8, 14, 0);\n    }\n}\n```\n\n\nThe Vertex class is used to create a structure that basically stores the vertex and its label distance. The priority queue will work on objects of this class, and will use the distance value as the ordering value for remove operations. How to rectify the exception?\n    ", "Answer": "\r\nTry this instead:\n\n```\nstatic class Vertex implements Comparable<Vertex> {\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Query regarding dijkstra algorithm\r\n                \r\nI am trying to find shortest path between two nodes in a dataset. I\nimplemented dijkstra algorithm and am using it to prove\ngiven two nodes (like: Andrew_Card\nand Dick_Cheney) there does not\nexist a path between the source and destination. However, I am finding\nthat my program is getting killed by the operating system.\n\nAfter debugging I found that the problem could be related to resource\nallocation in RAM. As for dijkstra algorithm, if the number of nodes,\nn=16,375,503, then the space requirement is\n\n```\n n*n = 16,375,503 * 16,375,503 > 10^{14}. \n```\n\n\nTo run this algorithm in memory we need at least\n\n```\n(10^{14} * 4) / (1024 * 1024 * 1024) = 10^5 GB  (approximately equal)\nof RAM.  \n```\n\n\nSo, it is not possible to find the shortest path using\ndijkstra if we intend to keep a large connected graph in-memory.\nPlease correct me if I am wrong as I am stuck on this since a long time? Or if there could be some other possible reason which I should check, then please point me to it too.\n\nI implemented the program in C++\n\nNo. of edges=25,908,132\n    ", "Answer": "\r\nIf the number of edges is relatively low(so that all edges can fit into main memory), you can just store the graph using adjacency list. It requires ```\nO(V + E)```\n memory, instead of ```\nO(V^2)```\n. Moreover, you can use Dijkstra's algorithm with a priority queue. It works well for sparse graphs(it has ```\nO(E log V)```\n time complexity). This approach should work fine for a graph with about ```\n2 * 10^7```\n vertices and edges(a good implementation can easily fit into main memory and run for no more than several minutes).\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm to find most weighted path\r\n                \r\nI just want to make sure this would work. Could you find the greatest path using Dijkstra's algorithm? Would you have to initialize the distance to something like -1 first and then change the relax subroutine to check if it's greater? \n\nThis is for a problem that will not have any negative weights.\n\nThis is actually the problem:\n\n\n  Suppose you are given a diagram of a telephone network, which is a graph\n      G whose vertices represent switches centers, and whose edges represent communication\n      lines between two centers. The edges are marked by their bandwidth of its lowest\n      bandwidth edge. Give an algorithm that, given a diagram and two switches centers a\n      and b, will output the maximum bandwidth of a path between a and b.\n\n\nWould this work?\n\n\n\nEDIT:\n\nI did find this:\n\n\n  Hint: The basic subroutine will be very similar to the subroutine Relax in Dijkstra.\n  Assume that we have an edge (u, v). If min{d[u],w(u, v)} > d[v] then we should update\n  d[v] to min{d[u],w(u, v)} (because the path from a to u and then to v has bandwidth\n  min{d[u],w(u, v)}, which is more than the one we have currently).\n\n\nNot exactly sure what that's suppose to mean though since all distance are infinity on initialization. So, i don't know how this would work. any clues?\n    ", "Answer": "\r\nI'm not sure Djikstra's is the way to go.  Negative weights do bad, bad things to Djikstra's.\n\nI'm thinking that you could sort by edge weight, and start removing the lowest weight edge (the worst bottleneck), and seeing if the graph is still connected (or at least your start and end points).  The point at which the graph is broken is when you know you took out the bottleneck, and you can look at that edge's value to get the bandwidth.  (If I'm not mistaken, each iteration takes O(E) time, and you will need O(E) iterations to find the bottleneck edge, so this is an O(E2) algorithm.\n\nEdit: you have to realize that the greatest path isn't necessarily the highest bandwidth: you're looking to maximize the value of ```\nmin({edges in path})```\n, not ```\nsum({edges in path})```\n.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra Algorithm: wrong path [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs debugging details. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Edit the question to include desired behavior, a specific problem or error, and the shortest code necessary to reproduce the problem. This will help others answer the question.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nWhen I compute paths again as vertex ```\nC to M```\n \n\nCorrect path should be \n\n```\nC -> B -> N -> M\n```\n\n\nBut it is \n\n```\nA -> B -> N -> M\n```\n\n\nI used this code Dijkstra Algorithm\n\nThis is the picture for my graph:\n\n    \n    ", "Answer": "\r\nIt is because you first call function compute for A then call it for C. some field like this :\n\n```\npublic double minDistance = Double.POSITIVE_INFINITY;\npublic Vertex previous;\n```\n\n\nare already have a value, so you need to delete pathcomputation for A or clear this values, you can do it with a function like :\n\n```\npublic void clear() {\n    minDistance = Double.POSITIVE_INFINITY;\n    previous = null;\n}\n```\n\n\ninside this Vertex Class, and call it like this :\n\n```\nfor (Vertex v : vertices) {\n    v.clear();\n}\n```\n\n\nbefore ```\ncomputePaths(v2);```\n\n\nhere is a online version of your code, you could see that the output is :\n\n```\nDistance to B: 1.0\nPath: [A, B]\nDistance to M: 5.0\nPath: [C, B, N, M]\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Using nw extensions in Dijkstra Algorithm\r\n                \r\nI'm now working on my undergraduate thesis about shortest path in Netlogo using Dijkstra algorithm\n\nHow nw extensions can be implemented in Dijkstra Algorithm coding?\n\nThank you. .\n    ", "Answer": "\r\nNot sure I understand your question, but the NW extension uses Dijsktra's algorithm to do its shortest path calculations. The algorithm has been modified so as to save as much information as possible while running. You can read more about that here: https://github.com/NetLogo/NW-Extension#performance\n\nIf you're asking about using NW in order to write your own implementation of Dijkstra's algorithm, NW doesn't really help you. It already has Dijkstra's built-in! You can implement Dijkstra's in NetLogo since all you really need is a way to get the links connected to a node and a data structure to store them in that makes it easy to grab the shortest one, called a heap. The connected link calculation is easy (just ```\nmy-links```\n or ```\nlink-neighbors```\n; ```\nother-end```\n is useful too). The heap is harder. NetLogo doesn't have a built-in heap, nor a good way of creating your own data structures, but you can build heaps just out of lists. You can also just use a list that remains sorted the whole time, but that will hurt the computational complexity.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Applying Dijkstra algorithm on a SQLite database\r\n                \r\nI am currently working on a project where I am using a database to store the connections between Wikipedia pages as a graph. I am trying to use Dijkstra's algorithm or another algorithm to find the shortest path between two pages using these connections. However, I am not sure how to properly implement this algorithm using my current database structure.\nMy database has two tables, one for nodes (representing the Wikipedia pages) and one for edges (representing the connections between the pages). Each edge has a start node and an end node, which are connected to the corresponding nodes in the nodes table.\nI have been researching how to use Dijkstra's algorithm in this context, but I am still not clear on how to properly use it with my specific database setup. Can anyone help me understand how to properly implement this algorithm with my current setup?This is the structure of Nodes This is the structure of Relations\nMaking a database with all the pages and their respective hyperlinks is a lot of data, and I assume that to apply the algorithm I need to load the database in memory, but I doubt that I can do this since there will be a huge amount of data with their relations\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Implementing Dijkstra's algorithm in Java?\r\n                \r\nSo I'm trying to implement Dijkstra's algorithm in Java. I know there are different ways to do it but here's the way that I've learned to do it. So I start with a single vertex and I find the shortest path from that vertex to every other vertex. I start with a single vertex (in my case it's zero) and then update my neighborhood by relaxing all the edges connected to that vertex. I then find out what's the smallest edge that connects to the current edge and then I add that vertex to my vertex storage. I keep doing that until all the vertices are in my vertex storage and then I should end up with a type of spanning tree that shows me all the shortest paths. \n\nSo in my code, I'm trying to find the shortest path from 0 to 1. I get the graphs from an adjacency matrix. So what I do is I start at the first row (or the 0th row) and traverse through the row and relax the vertices in a matrix called N. I then find the smallest edge coming out of whatever vertices I have stored in my vertex storage and then contnue adding vertices and relaxing the edges. So then I have two main arrays called N (where I store the weights of the shortest paths) and edgeStorage. Here's what it looks like:\n\n```\nstatic int ShortestPath(int[][] G){\n    int numVerts = G.length;\n    int totalWeight = 0;\n\n    int minWeight;\n    int count = 1;\n    int k = 0;\n    int l = 0;\n    int next = 1;\n    int i = 0;\n    int[] N = new int[numVerts];\n    int[] edgeStorage = new int[numVerts];\n    Arrays.fill(N, 2147483647); //2147483647 is my infinity to represent vertices that haven't yet been relaxed\n    N[0] = 0;\n\n    while (count != numVerts){\n        for (int j = 0; j < numVerts; j++){\n            if ((G[i][j] != 0) && (N[i] + G[i][j] < N[j])){\n                N[j] = N[i] + G[i][j];\n            }\n        }\n        minWeight = 2147483647;\n        for (int p = 0; p < count; p++){ //find min edge weight for vertices in storage\n            i = edgeStorage[p];\n            for (int j = 0; j < numVerts; j++){\n                if ((G[i][j] != 0) && (G[i][j] < minWeight)){\n                    minWeight = G[i][j];\n                    k = j;\n                    l = i;\n                }\n            }\n        }\n        G[l][k] = 0; //remove edge since we don't need it anymore\n        G[k][l] = 0;\n        edgeStorage[next] = k; //store vertex location in array\n        i = k;\n        count++;\n        next++;\n    }\n    totalWeight = N[1];\n    return totalWeight;\n}\n```\n\n\nThe problem is this code works for some graphs but for others it gives me a weight that's bigger than it's supposed to be. I tested it on a graph of 25 vertices which looked like this:\n\n```\n0 0 0 0 0 0 418 0 0 0 0 0 0 0 472 0 0 0 0 0 0 0 0 537 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 191 375 161 0\n0 0 0 0 0 0 0 0 0 0 0 0 108 0 0 0 512 0 311 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 612 0 0 0 0 0 0 0 0 0 0 0 583 0 0 0 0\n0 0 0 0 0 0 365 0 0 0 0 0 0 0 0 262 243 0 0 0 0 617 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 581 0 0 0 0 0 0 0 0 0 0 0\n418 0 0 0 365 0 0 0 0 0 0 338 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 320 0 517 0 0 0 0 0 0 0 524 0 314 0 0 0 0\n0 0 0 612 0 0 0 320 0 0 0 0 0 0 0 0 577 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 145 414 0 0 35 0 0 0 0 0 0 394 0 0\n0 0 0 0 0 0 0 517 0 0 0 0 0 0 0 0 0 353 0 0 0 0 0 0 0\n0 0 0 0 0 0 338 0 0 145 0 0 0 0 0 0 0 0 0 344 0 0 0 0 0\n0 0 108 0 0 0 0 0 0 414 0 0 0 0 0 0 0 607 0 0 0 0 0 0 0\n0 0 0 0 0 581 0 0 0 0 0 0 0 0 0 0 0 0 0 609 0 0 231 0 0\n472 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 478 0 0 0 0 0 0 0\n0 0 0 0 262 0 0 0 0 35 0 0 0 0 0 0 0 0 0 0 280 0 0 0 0\n0 0 512 0 243 0 0 0 577 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 353 0 607 0 478 0 0 0 0 0 0 0 0 594 0\n0 0 311 0 0 0 0 524 0 0 0 0 0 0 0 0 0 0 0 0 0 471 0 0 306\n0 0 0 0 0 0 0 0 0 0 0 344 0 609 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 583 0 0 0 314 0 0 0 0 0 0 0 280 0 0 0 0 0 0 0 0 214\n0 191 0 0 617 0 0 0 0 0 0 0 0 0 0 0 0 0 471 0 0 0 0 0 0\n0 375 0 0 0 0 0 0 0 394 0 0 0 231 0 0 0 0 0 0 0 0 0 0 0\n537 161 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 594 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 306 0 214 0 0 0 0\n```\n\n\nMy N array looked like this: \n\n```\n0 1670 1538 1799 783 2107 418 1530 1603 901 2047 756 1315 1526 472 936 1026 950 1736 1100 1216 1400 1295 537 1430```\n \n\nand my edgeStorage array looked like this:\n\n```\n0 6 11 9 15 4 16 20 24 18 2 12 7 8 19 4 22 13 1 23 21 12 21 14 17\n```\n\n\nSo therefore it returned 1670 as the path between 0 and 1 when it should've returned 698. I have no idea why it gives me the wrong weight for some graphs but the right weight for others. So does anyone know what's wrong with my code? \n\nP.S: I know my implementation is not the most efficient thing right now but I just want to get the basic implementation working and then I'll work on making it more efficient. \n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra’s Algorithm in python\r\n                \r\nI am trying to implement Dijkstra’s algorithm on my python code but I can't really get the algorithm right. The algorithm I am using is from this youtube link: https://www.youtube.com/watch?v=pVfj6mxhdMw\n\nSo basically my class has these 3 variables:\n\n```\nself.nodes = [] #a,b,c\nself.neighbours = {} # a:[b,c], b:[c], c:[a]\nself.weights = {} #[a,b] = 2, [a,c] = 5\n```\n\n\nHere is how I partially implemented my shortest path function using the algorithm provided in the video:\n\n```\ndef dijkstra(self, start, end):\n\n    nodes = {}\n\n    for n in self.nodes:\n        if n == start:\n                nodes[n] = 0\n        else:\n                nodes[n] = float('inf')\n\n    unvisited = self.neighbours\n    visited = []\n    current_node = start\n    current_distance = 0\n\n    while unvisited:\n        for n in unvisited[current_node]:\n            print(n)\n            #calc_weight = nodes[n] + self.weights[n, current_node]\n            #if (unvisited[n] is None or calc_weight > nodes[n]):\n                    #nodes[n] = calc_weight\n        visited.append(current_node)\n        del unvisited[current_node]\n\n        if not unvisited: break\n```\n\n\nI havent really completed because I know I missing something out somewhere. Can someone please help me with this. Thank you\n    ", "Answer": "\r\n```\ndef dijkstra(self, start, end):\n\n    nodes = self.neighbours #{'A': {'B':2}, 'B': {'C':4}, ... }\n\n    unvisited = {n: 1000 for n in self.nodes} #unvisited node & distance\n    unvisited[start] = 0 #set start vertex to 0\n    visited = {} #list of all visited nodes\n    parent = {} #predecessors\n\n    while unvisited:\n        min_node = min(unvisited, key=unvisited.get) #get smallest distance\n\n        for neighbour in nodes[min_node].items():\n            if neighbour not in visited:\n                new_distance = unvisited[min_node] + nodes[min_node][neighbour]\n                if new_distance < unvisited[neighbour]:\n                    unvisited[neighbour] = new_distance\n                    parent[neighbour] = min_node\n\n        visited[min_node] = unvisited[min_node]\n        unvisited.pop(min_node)\n\n    print(parent, visited)\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm for finding the midpoint with the shortest total route\r\n                \r\nI need an algorithm to select the midpoint that has the shortest route between the source node s and the destination node h. There are midpoints (intermediate vertices) b in the set of intermediate vertices B such that for every b there is a path s~b and b~h. My idea is that I'll run Dijkstra for every b starting on s and then reverse the graph to run it again starting on the destination for every b. Then find the minimal sum. However, the problem requires the algorithm to implement Dijkstra's algorithm only once and to define a new graph G' on 2|V| vertices and at most 2|E| + |V| edges. I am not sure how I can alter the graph to satisfy the condition but I think that I have to make a copy of the set of original vertices.\n    ", "Answer": "\r\nThe idea is that your new graph G' should include two copies of the original graph G.  Let's call the vertices in these two copies T and U.\nThe edges are almost the same in both copies, except that every edge into a midpoint vertex goes to the copy of that vertex in U.\nNow, you run Dijkstra's to find the shortest path from sT to hU.  Of course the path must get from T to U somehow, and it can only do that when it enters a midpoint vertex, so you have found the shortest path from s to h that passes through a midpoint.\nNote that when this kind of algorithm is implemented for real, we don't actually make two copies of the graph.  We just pretend we did and augment the vertex numbers in Dijkstra's algorithm with an extra Boolean to indicate whether it refers to T or U.  We are then operating on an implicit graph, as most real-life implementations of simple graph algorithms do.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Implementing Dijkstra's algorithm in Java using hash code\r\n                \r\nThe implementation for my graph is the following hash table: \n\n```\npublic class DiGraphHash{\n\nprivate int numNodos, numArcos;\nprivate TheList<Nodo> nodos[];\nprivate TheList<Arco> arcos[];\nprivate TheList<Arco> preds[];\n```\n\n\n}\n\nwhere TheList, is a list I made myself. \n\nFor Dijkstra's algorithm I need to map The cost of each node and the path to reach that node. \nI have the following two arrays:\n\n```\n   int[] cost = new cost[num_nodes];\n   Nodo[] path = new Nodo[num_nodes];\n```\n\n\nAnother important detail, is that my nodes are going to be the letters A, B, C, D. \n\nSo when I map my nodes, for example lets say I have to assign the cost the the Node A, how do I find the position in the array?\n\nI was thinking of using hashcode % array.length but I am not sure if I will get collisions (take into consideration that it will be only 1 char letters)\n\nI am not asking about the code, and need the idea. \n    ", "Answer": "\r\nTwo ideas:\n\n\nAdd a ```\ncost```\n field to your ```\nNodo```\n class.  This way, you'll only have to manage an array of nodes, rather than a separate array of costs as well.  You can assign the costs when you instantiate the nodes, and look them up easily later.\nA better data structure than two arrays might be a map, where the keys are the nodes themselves and the values are the nodes' costs.  Here's an example:\n\n\n\n```\nHashMap<Nodo, Integer> nodesToCosts = new HashMap<Nodo, Integer>();\n\nnodes.put(nodeA, new Integer(5));\nnodes.put(nodeB, new Integer(20));\nnodes.put(nodeC, new Integer(10));\nnodes.put(nodeD, new Integer(5));\n```\n\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "When is the shortest path to some vertex found in Dijkstra's algorithm?\r\n                \r\nI've tried to understand Dijkstra's algorithm and attempted to write my own implementation, and there are some things I don't understand:\n\nWhen can I mark some vertex as visited and be sure that there is no shorter path to it?\nWhen can I stop searching when looking for the shortest path between two vertices?\n\nWhat's more, some sources say to use ```\ndecrease-key```\n instead of adding adjacent vertices to a priority queue. What does that mean and how does it work?\n    ", "Answer": "\r\nDjikstra's algorithm:\n```\nInitialise all distances to \"infinity\".\n\nPush start onto a priority queue (front of queue will always holdest shortest distance from a finalised node)\n\nLoop:\n   Pop front of queue (effectively finalising it) - (desired end point is inaccessible if queue is empty here)\n   If it is the desired end point, then done.\n   Otherwise add to queue all nodes accessible from that finalised node whose distance could be improved.\n```\n\nConsider the following graph (@ravenspoint example with bottom line split)\n\nNote that, to get from A to B by the shortest path:\nB is only (explicitly) considered once.\nE is never visited - you do NOT need the distance to all nodes.\n```\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <limits>\nusing namespace std;\n\nusing NodeType = char;\n\nstruct Edge\n{\n   NodeType dest;\n   double wt;\n};\nbool operator < ( Edge a, Edge b ) { return a.dest < b.dest; }\n\nusing Graph  = map< NodeType, set<Edge> >;\n\n//======================================================================\n\nvoid read( istream &in, Graph &graph )\n{\n   graph.clear();\n   NodeType a, b;\n   double wt;\n   while( in >> a >> b >> wt )\n   {\n      graph[a].insert( Edge{ b, wt } );\n      graph[b].insert( Edge{ a, wt } );\n   }\n}\n\n//======================================================================\n\ndouble Dijkstra( Graph &graph, NodeType start, NodeType finish )\n{\n   const double LARGE = numeric_limits<double>::max();\n\n   // Set all distances from start to infinity\n   map<NodeType,double> dist;\n   for ( auto n : graph ) dist[n.first] = LARGE;\n   dist[start] = 0;\n\n   // Create a priority queue that will be sorted by distance from source\n   auto further = [&]( NodeType a, NodeType b ){ return dist[a] > dist[b]; };\n   priority_queue< NodeType, vector<NodeType>, decltype(further) > Q( further );\n\n   // Push all nodes accessible from the start onto the queue\n   cout << \"Finalised \" << start << '\\n';                  // Node with smallest currently-accessible distance\n   for ( const Edge &edge : graph[start] )\n   {\n      dist[edge.dest] = edge.wt;\n      Q.push( edge.dest );\n      cout << \"Queued \" << edge.dest << '\\n';\n   }   \n\n   // Dijkstra: take the smallest distance amongst those so far accessible and\n   // finalise it (i.e. pop it from the front of the queue).\n   while( !Q.empty() )\n   {\n      NodeType n = Q.top();\n      cout << \"Finalised \" << n << '\\n';                   // Smallest currently-accessible node\n      if ( n == finish ) return dist[n];                   // If at the target then stop\n\n      Q.pop();\n      for ( const Edge &edge : graph[n] )\n      {\n         double test = dist[n] + edge.wt;\n         if ( dist[edge.dest] > test )                     // If we improve a distance, then push onto queue\n         {\n            dist[edge.dest] = test;\n            Q.push(edge.dest);\n            cout << \"Queued \" << edge.dest << '\\n';\n         }\n      }\n   }\n\n   // If we get this far then the target is inaccessible\n   return -1.0;\n}\n\n//======================================================================\n\nint main()\n{\n   istringstream in( \"A C 1 \\n\"\n                     \"C B 2 \\n\"\n                     \"A D 10 \\n\"\n                     \"D E 10 \\n\"\n                     \"E B 80 \\n\" );\n// ifstream in( \"graph.in\" );\n// istream &in = cin;\n   char start = 'A', finish = 'B';\n\n   Graph G;\n   read( in, G );\n   double d = Dijkstra( G, start, finish );\n   cout << \"\\nShortest path from \" << start << \" to \" << finish << \" is \" << d << '\\n';\n}\n```\n\nOutput:\n```\nFinalised A\nQueued C\nQueued D\nFinalised C\nQueued B\nFinalised B\n\nShortest path from A to B is 3\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "GUI tkinter and dijkstra algorithm\r\n                \r\nI'm trying to hook up the Dijkstra algorithm i created to a gui, but i'm not too sure on how to go about it.\nthis first part is the Dijkstra algorithm i made using networkx.\n```\nimport pandas as pd\nimport networkx as nx\n\ndf = pd.read_excel(r'C:\\Users\\dell\\Downloads\\tubemap_London_Underground(2).xlsx')\nedgeList = df.values.tolist()\n\nG = nx.Graph()\nG.add_weighted_edges_from(edgeList)\n\nlst = list(G.edges(data=True))[:328]\n\n\n#print(lst)\nstationFrom = input(\"Enter your present station: \")\nstationTo = input(\"Enter where you are going: \")\nprint(\"The route: \",nx.dijkstra_path(G, stationFrom, stationTo)) # task 1a\nprint(nx.dijkstra_path_length(G, stationFrom, stationTo),\"minutes\") #task 1b\n# print(\"Bellmanford_algorithm: \",nx.bellman_ford_path(G, stationFrom,stationTo))\n\n\nprint(\"Other routes include:\\n \", [p for p in nx.all_shortest_paths(G, source=stationFrom, target=stationTo)]) # task 2\n\n```\n\nAnd this is the tkinter part that i'm supposed to hook up to the algorithm. I don't really have any idea on how to connect these two though so i tried watching some tutorials but i'm still not sure on what to do.\n```\nfrom tkinter import *\nfrom tkinter.scrolledtext import ScrolledText\nimport pandas as pd\nimport networkx as nx\n\n\n\ndf = pd.read_excel(r'C:\\Users\\dell\\Downloads\\tubemap_London_Underground(2).xlsx')\nedgeList = df.values.tolist()\n\nG = nx.Graph()\nG.add_weighted_edges_from(edgeList)\n\nlst = list(G.edges(data=True))[:328]\n\nmaster = Tk()\nmaster.title(\"Google maps pro\")\nmaster.configure(bg=\"#C292DE\")\nmaster.geometry(\"1000x600\")\n\n\ndef search(from_Entry, to_Entry):\n    q2 = q.get()\n    a = nx.dijkstra_path(G, from_Entry, to_Entry) # task 1\n    # while a\n\n    from_Entry(0, 'end')\n    to_Entry(0, 'end')\n\n\ndef time_taken(from_Entry, to_Entry):\n    b = nx.dijkstra_path_length(G, from_Entry, to_Entry)\n\ndef other_routes(from_Entry, to_Entry):\n    print([p for p in nx.all_shortest_paths(G, source=from_Entry, target=to_Entry)]) # task 2\n\nq = StringVar()\nr = IntVar()\ns = StringVar()\n# search function\n\nbig_Frame = Frame(master, bg='#95A3E0', bd=2)\nbig_Frame.pack()\n\nmainLabel = Label(big_Frame, text=\"Google maps pro\",font=('Lato', 12))\nmainLabel.pack()\n\notherLabel = Label(master, text=\"Where are you going bro?\", bg='#95A3E0', font=('Lato', 12))\notherLabel.pack(pady=5, padx=4, ipadx=10, ipady=10)\n\nfrom_Label = Label(master,text=\"FROM\",bg='#95A3E0', font=('Lato', 12))\nfrom_Label.pack()\n\nfrom_Entry = Entry(master, bg='#95A3E0', font=('Lato', 10), textvariable=q)\nfrom_Entry.pack(pady=5, padx=4, ipadx=5, ipady=5)\n\nto_Label = Label(master, text=\"TO\", bg='#95A3E0', font=('Lato', 12) )\nto_Label.pack()\n\nto_Entry = Entry(master, bg='#95A3E0', font=('Lato', 10), textvariable=q)\nto_Entry.pack(pady=5, padx=4, ipadx=5, ipady=5)\n\nsubmit_button = Button(master, text='SEARCH',bg='#95A3E0', font=('Lato', 10), command=search)\nsubmit_button.pack()\n\n\noptionList = [\n            \"Bakerloo\",\n            \"Central\",\n            \"Circle\",\n            \"District\",\n            \"Hammersmith & City\",\n            \"Jubilee\",\n            \"Metropolitan\",\n            \"Northern\",\n            \"Piccadilly\",\n            \"Victoria\",\n            \"Waterloo & City\"\n        ]\n\nline_Label = Label(master, text=\"What line are you travelling with? \", bg='#95A3E0', font=('Lato', 12))\nline_Label.pack()\n\nclicked = StringVar(master)\n\n# initial menu text\nclicked.set(\"Victoria\")\n\n# Create Dropdown menu\ndrop = OptionMenu(master, clicked, *optionList)\ndrop.pack()\n\ntime_arrived_label = Label(master, text=\"OVERALL JOURNEY TIME:\", bg='#95A3E0', font=('Lato', 12) )\ntime_arrived_label.pack(side=LEFT, ipadx=5, ipady=5 )\n\ntime_arrived_entry = Entry(master, bg='#95A3E0', font=('Lato', 10), textvariable=r)\ntime_arrived_entry.config(state='disabled')\ntime_arrived_entry.pack(side=LEFT, ipadx=5, ipady=5 )\n\njourney_summary_label = Label(master, text=\"JOURNEY SUMMARY & alternative routes:\", bg='#95A3E0',\n                                   font=('Lato', 12) )\njourney_summary_label.pack(side=LEFT, padx=50, pady=20 )\njourney_summary_entry = ScrolledText(master, bg='#95A3E0', font=('Lato', 10), width=20, height=10)\njourney_summary_entry.config(state='disabled')\njourney_summary_entry.pack(side=RIGHT, expand=True)\n\nmaster.mainloop()\n```\n\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstras Algorithm implementation\r\n                \r\nI tried Dijkstras algorithm and got confused between 2 implemntation, one keeps track of visited nodes (code1) and other don't keep the track (code2).\nCode1:\n```\n    dis[S] = 0;  //S is source\n    vis[S] = 1;\n    \n    PriorityQueue<Node> queue = new PriorityQueue<>();\n    queue.offer(new Node(S, 0));\n    \n    while(!queue.isEmpty()){\n        \n        Node node = queue.poll();\n        \n        int u = node.v;\n        vis[u] = 1;\n        \n        for(Node n: adj1.get(u)){\n            int v = n.v;\n            int w = n.w;\n            \n            if(vis[v] == 0){\n                if(dis[u]+w < dis[v]){\n                    dis[v] = dis[u]+w;\n                   \n                }\n                 queue.offer(n);\n                \n            }  \n        }\n        \n    }\n    `\n```\n\ncode2:\n```\n    dis[S] = 0;\n    //vis[S] = 1;\n    \n    PriorityQueue<Node> queue = new PriorityQueue<>();\n    queue.offer(new Node(S, 0));\n    \n    while(!queue.isEmpty()){\n        \n        Node node = queue.poll();\n        \n        int u = node.v;\n        // vis[u] = 1;\n        \n        for(Node n: adj1.get(u)){\n            int v = n.v;\n            int w = n.w;\n            \n            // if(vis[v] == 0){\n                if(dis[u]+w < dis[v]){\n                    dis[v] = dis[u]+w;\n                    queue.offer(n);\n                   \n                }\n                 \n                \n            // }  \n        }\n        \n    }\n```\n\nCode 1 fails some test cases code 2 passes all test cases. can anyone explain why code 1 fails like what are the edge cases i am missing.\n    ", "Answer": "\r\nBoth of your implementations are incorrect.  \"code 2\" might work, but it's probably slow.\nThe most obvious problem in both implementations is that your priority queue is full of edges.  In Dijkstra's algorithm, the queue orders vertices by their currently best discovered cost.  There is just no way that your priority queue could be doing this properly.\nI would guess that you're actually ordering edges by weight.  The will give you vertices in the wrong order, which could cause \"code 1\" to fail because of the visited check.\nThe next problem is the implementation of the visited check.  If you're not using a heap that supports a ```\ndecrease_key()```\n operation, then you have to add a vertex to the queue every time you decrease the weight, so it could end up in the queue multiple times.  When it comes out of the queue, you will know its best cost, so you can save time by ignoring the other instances in the queue when you see them.\nYou do not use the visited check to ensure that you only add the vertex once, because then keys can't be decreased and your implementation is broken.\nA proper implementation looks like this:\n```\n// initialize dis to max value\nfor (int i=0; i<dis.length; ++i) {\n    dis[i] = Integer.MAX_VALUE;\n}\ndis[S] = 0;  //S is source\n// Note that S isn't scanned yet, so vis[S] == 0\n\nPriorityQueue<PriorityNode> queue = new PriorityQueue<>();\nqueue.offer(new PriorityNode(S, 0));\n\nwhile(!queue.isEmpty()){\n    \n    PriorityNode node = queue.poll(); \n    int u = node.vertex;\n\n    if (vis[u] != 0) {\n        // already resolved this vertex\n        continue;\n    }\n\n    vis[u] = 1;\n    \n    for(Edge n: adj1.get(u)){\n        int v = n.v;\n        int w = n.w;\n        \n        if(dis[u]+w < dis[v]){\n            dis[v] = dis[u]+w;\n            // We found a better cost for v\n            queue.offer(new PriorityNode(v, dis[v]));\n        }\n    }        \n}\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Modification for Dijkstra Algorithm [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 6 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI want to know, when the start vertex s is given, the shortest path is computed only if a vertex is no more than three edges away from the start vertex.\n\nI thought of doing this by counting the number of parents, and if number_of_parents<=3 then it is a valid path.\n\nPlease can someone clarify this for me using the algorithm?\n\nBelow is the standard Dijkstra Algorithm.\n\n```\nDijkstra(G,W,s)\n   Initialize_Single_Source(G,s)\n   S= {}\n   Q = V[G]\n   while Q != {} do\n      u = extract_min(Q)\n      S = S U {u}\n      for each vertex v element of Adj[u] do\n                 relax(u,v,w)\n```\n\n    ", "Answer": "\r\nInstead of a vertex we use array L to determine levels, i.e., how far a node is from the source\n\n```\nDijkstra(G,W, s)\n   Initialize_Single_Source(G,s)\n   S= {}\n   Q = V[G]\n   L = {an array to determine levels of each node, \n    initially all nodes have level \"infinite\" except for s who has level 0}\n   while Q != {} do\n      u = extract_min(Q)\n      u_level = L[u]\n      if(u_level > 3){\n        ignore u and don't add it to S;\n        continue;\n      }\n      S = S U {u}\n      for each vertex v element of Adj[u] do\n                 relax(u,v,w)\n                 in relax function you put L[v] = min(L[v], u_level + 1);\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Modified Shortest Path Algorithm (Dijkstra's)\r\n                \r\nSo my problem is that I have a directed graph G with non-negative edge lengths and I wish to find the shortest path between two nodes u and v such that they only pass through one marked node in the graph.\n\nIf we did not have the condition involving the marked nodes this problem could easily be solved using Dijkstra's algorithm.\n\n```\nprocedure dijkstra(G, l, s)\nInput: Graph G = (V, E), directed or undirected;\npositive edge lengths {le : e ∈ E}; vertex s ∈ V\nOutput: For all vertices u reachable from s, dist(u) is set to the distance from s to u.\n\nfor all u ∈ V :\n    dist(u) = ∞\n    prev(u) = nil\ndist(s) = 0\nH = makequeue(V ) (using dist-values as keys)\nwhile H is not empty:\n    u = deletemin(H)\n    for all edges (u, v) ∈ E:\n        if dist(v) > dist(u) + l(u, v):\n            dist(v) = dist(u) + l(u, v)\n            prev(v) = u\n            decreasekey(H, v)\n```\n\n\nAdditionally, to handle the condition I was considering adding a value which gave the current number of nodes in the current best path from s to u (this would be updated whenever dist(u) was updated). But this doesn't seem to work since the algorithm is not keeping track of all possible paths that we've seen with one or less nodes , but rather just the lowest distance path.\n\nMy question is am I on the right track and just need to modify the algorithm additonally? Or is there another algorithm that would accomplish this easier?\n\nAlso, this is for a homework problem so please do not post an entire solution, I'm just looking for guidance.\n    ", "Answer": "\r\nAs you don't want the entire solution, I will give you some hints. Stop reading each paragraph and then try to solve the problem, I'll try to go from more general hints to more specific ones.\n\nFirst, I don't think your current idea can solve the problem. So I will try to guide you to a different approach. It is a good idea to think of Dijkstra, but instead of modifying Dijkstra, consider transforming the graph so to achieve that running Dijkstra in your new graph solves the original problem.\n\nHow to remove the original restriction of the set P? Well, it is important that the graph is directed (or at least for my idea). Think of a way of transforming the graph so as to force that if you enter one node of P, you cannot enter another one of P again.\n\nLast idea, without still giving the solution. Consider replicating the graph, maybe deleting some edges and connecting the nodes from the two copies in some way.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "why this Dijkstra algorithm not working for this particular input?\r\n                \r\nI have implemented Dijkstra's algorithm. \nBut it does not work when input is the following:\n\n```\n1\n6 7\n1 2 5\n2 3 2\n3 4 3\n1 4 9\n4 5 2\n5 6 3\n1 6 2\n1\n```\n\n\nI ran it in debug mode, to understand what was wrong.  It appeared that the node 5 was not inserted in cell. I can't find out why. \n\nHere the code:\n\n```\n#include<iostream>\n#include<vector>\n#include<list>\n#include <limits>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <stack>\nusing namespace std;\n\nstruct compare\n{\n    bool operator()(pair<int, int> a, pair<int, int> b) const\n    {\n        return a.second < b.second;\n    }\n\n};\n\nvoid printResults(vector<int> vec, int starting)\n{\n    for (int i = 1; i < vec.size(); i++)\n    {\n        if (vec[i] == numeric_limits<int>::max() && i != starting)\n        {\n            cout << -1 << \" \";\n        }\n        else if (i != starting)\n        {\n            cout << vec[i] << \" \";\n        }\n    }\n\n}\nvoid djkstra(vector<vector<pair<int, int>>>&vec, int starting, int number_of_vertices)\n{\n    int max = numeric_limits<int>::max();\n    set <pair<int, int>,compare> queue;\n    vector<bool> visited(number_of_vertices + 1, false);\n    vector<int> distances(number_of_vertices + 1, max);\n    vector<int> parents(number_of_vertices + 1, -1);\n    queue.insert(make_pair(starting, 0));\n    distances[starting] = 0;\n    for (int i = 0; i<number_of_vertices-1; i++)\n    {\n        pair<int, int> minElem = *queue.begin(); //take min elem\n        queue.erase(minElem);\n        vector<pair<int, int>> adjacents = vec[minElem.first];//take neighbours\n        for (int j = 0; j<adjacents.size(); j++)\n        {\n            pair<int, int> node = adjacents[j];\n            if (!visited[node.first])\n            {\n                if (distances[node.first]> distances[minElem.first] + node.second) //if we have found smaller distance\n                {\n\n                    if (queue.find(make_pair(node.first, distances[node.first])) != queue.end())\n                    {\n                        queue.erase(make_pair(node.first, distances[node.first]));\n                        queue.insert(make_pair(node.first, distances[minElem.first] + node.second));\n\n                    }\n                    else\n                    {\n                        queue.insert(make_pair(node.first, distances[minElem.first] + node.second));\n                        cout<<distances[minElem.first] + node.second<<endl;\n\n                    }\n\n                    distances[node.first] = distances[minElem.first] + node.second;\n                }\n\n            }\n\n        }\n        visited[minElem.first] = true;\n\n    }\n    printResults(distances,starting);\n\n}\n\nint main()\n{\n    int test;\n    cin >> test;\n    for (int i = 0; i < test; i++)\n    {\n        int nodes, edges;\n        cin >> nodes >> edges;\n        vector<vector<pair<int, int>>> vec(nodes + 1);\n        for (int j = 0; j < edges; j++)\n        {\n            int src, des, weight;\n            cin >> src >> des >> weight;\n            vec[src].push_back(make_pair(des, weight));\n            vec[des].push_back(make_pair(src, weight));\n\n        }\n\n        int starting;\n        cin >> starting;\n        djkstra(vec, starting, nodes);\n\n    }\n\n    system(\"pause\");\n\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nSo, after trying to make sense of your question code, I arrived upon a clean re-write according to the Wikipedia Pseudo-code\n\nI think (because you still never showed the output you get which is supposedly wrong), your cardinal error is just using ```\nset<>```\n:\n\nBugged Version\n\n```\n#include <algorithm>\n#include <iostream>\n#include <limits>\n#include <list>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <cassert>\n\nusing Vertex  = unsigned;\nusing Weight  = double;\n\nstruct OutEdge {\n    Vertex node;\n    Weight weight;\n    bool operator<(OutEdge const& o) const { return weight < o.weight; }\n};\n\nusing OutEdges     = std::vector<OutEdge>;\nusing AdjList      = std::vector<OutEdges>;\nusing Distances    = std::vector<Weight>;\nusing Predecessors = std::vector<Vertex>;\n\nstatic Weight const INFINITY = std::numeric_limits<Weight>::max();\nstatic Vertex const UNDEFINED {-1u};\n\nusing namespace std;\n\nvoid print_graph(AdjList const& graph) {\n    for (Vertex v = 1; v < graph.size(); v++) {\n        std::cout << v << \" -\";\n        for (auto& adj : graph[v])\n            std::cout << \" \" << adj.node << \"(\" << adj.weight << \")\";\n        std::cout << \"\\n\";\n    }\n}\n\nvoid printResults(Distances const& dist, Vertex starting) {\n    for (Vertex v = 0; v < dist.size(); v++) {\n        std::cout << starting << \" -> \" << v << \": \";\n        if (dist[v] == INFINITY && v != starting) {\n            cout << -1 << \" \";\n        } else { // if (v != starting) {\n            cout << dist[v] << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n}\n\nDistances dijkstra(AdjList const& graph, Vertex source) {\n    std::set<OutEdge> Q;\n\n    vector<bool> visited(graph.size(), false);\n    Distances    dist(graph.size(), INFINITY);  // Unkown distance from source\n    Predecessors prev(graph.size(), UNDEFINED); // Previous node in optimal path from source\n\n    dist[source] = 0; // Distance from source to source\n\n    for (Vertex v = 1; v < graph.size(); v++)\n        Q.insert({v, dist[v]});\n\n    while (!Q.empty()) {\n        Vertex u = Q.begin()->node;\n        visited[u] = true;\n        Q.erase(Q.begin());\n\n        for (auto& v : graph[u]) { // for each neighbour\n            if (visited[v.node]) // where v is still in Q.\n                continue;\n\n            Weight alt = dist[u] + v.weight;\n\n            if (alt < dist[v.node]) // A short path to v has been found\n            {\n                dist[v.node] = alt;\n                prev[v.node] = u;\n\n                // update prio\n                auto it = std::find_if(Q.begin(), Q.end(), [&](auto& oe) { return oe.node == v.node; });\n                if (it != Q.end()) {\n                    Q.erase(it);\n                    Q.insert({v.node, alt});\n                }\n            }\n        }\n    }\n\n    return dist;\n}\n\nint main() {\n    size_t test;\n    cin >> test;\n    for (size_t i = 0; i < test; i++) {\n        size_t nodes, edges;\n        cin >> nodes >> edges;\n        nodes += 1; // hack to avoid converting ids to base-0\n\n        AdjList adj(nodes);\n        for (size_t j = 0; j < edges; j++) {\n            Vertex src, des;\n            Weight weight;\n\n            cin >> src >> des >> weight;\n            assert(weight>=0);\n\n            adj[src].push_back({des, weight});\n            adj[des].push_back({src, weight});\n        }\n\n        print_graph(adj);\n\n        Vertex starting;\n        cin >> starting;\n        auto d = dijkstra(adj, starting);\n        printResults(d, starting);\n    }\n}\n```\n\n\nWhich prints the result as:\n\n```\n1 -> 0: -1 \n1 -> 1: 0 \n1 -> 2: 5 \n1 -> 3: 7 \n1 -> 4: 9 \n1 -> 5: -1 \n1 -> 6: 2 \n```\n\n\n\n  NOTE You had at least one more bug in ```\ndjkstra```\n [sic] where you did \n\n```\nfor (int i = 0; i<number_of_vertices-1; i++)\n```\n\n  \n  That ```\n-1```\n seems to be completely wrong (if anything, it \"should\" have been ```\n+1```\n although it was a ginormous code smell to have ```\n+1```\n strewn about all of the code. See how I solved that in my version.\n\n\nExplanation\n\n```\nstd::set<>```\n models a container with unique elements. In this case the weight is the equivalence property and as such, all elements having identical weight are equivalent. At the very start the queue will contain at most 2 elements: 1 starting vertex (distance 0) and 1 of the other vertices that have all been seeded with the same distance (```\nINFINITY```\n; or ```\nmax```\n in your version).\n\nThis is going to sink your algorithm since many nodes are never visited (the algorithms stops as soon the queue is empty).\n\nThe fix is 5 letters: ```\ns/set/multiset/```\n:\n\nFixed Version\n\nPrints:\n\n```\n1 -> 0: -1 \n1 -> 1: 0 \n1 -> 2: 5 \n1 -> 3: 7 \n1 -> 4: 7 \n1 -> 5: 5 \n1 -> 6: 2 \n```\n\n\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Java: Dijkstra's Algorithm - change number of edges using random edges\r\n                \r\nI have a program that implements Dijkstra's algorithm for graphs. I am to create a graph with 10 vertices and 30 random edges. However, I do not know how to get exactly 30 edges. I have the code, but I just can't seem to find where I need to change so that I get 30 edges each time I run the code. I know this is simple, but I had to change the code from reading in a file with the edges to randomly assigning them. Right now I am getting 16 edges. Any assistance in creating my graph with exactly 30 edges would be great!\n\nHere is the code:\n\nGraph class:\n\n```\npackage TestGraphs;\n\nimport TestGraphs.Vertex;\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\npublic class Graph {\n\npublic Vertex[] vertex;\npublic double[] centerVert;\npublic double[][] weight; // weight[i][j] >= 0.0 indicates an edge\npublic double center;\npublic int centerV;\n\npublic Graph(int numVertices) {\n    vertex = new Vertex[numVertices];\n    weight = new double[numVertices][numVertices];\n    centerVert = new double[numVertices];\n    for (int i = 0; i < numVertices; i++) {\n        for (int j = 0; j < numVertices; j++) {\n            weight[i][j] = -1.0; // no edge\n        }\n    }\n}\n\npublic void createAdjacencyLists() {\n    for (int i = 0; i < vertex.length; i++) {\n        vertex[i].neighbors = new ArrayList<Vertex>();\n        for (int j = 0; j < vertex.length; j++) {\n            if (j != i && weight[i][j] > 0.0) {\n                vertex[i].neighbors.add(vertex[j]);\n            }\n        }\n\n    }\n}\n\npublic void printGraph() {\n    System.out.println(\"Vertices:\");\n    for (int i = 0; i < vertex.length; i++) {\n        System.out.println(i + \": \" + vertex[i]);\n    }\n    System.out.println(\"Edges:\");\n    for (int i = 0; i < vertex.length; i++) {\n        System.out.print(vertex[i] + \" neighbors:\");\n        for (int j = 0; j < vertex.length; j++) {\n            if (j != i && weight[i][j] > 0.0) {\n                System.out.print(\" \" + vertex[j] + \"w:\" + String.format(\"%.2f\", weight[i][j]));\n                centerVert[i] = weight[i][j] + centerVert[j];\n            }\n        }\n        System.out.println();\n    }\n    for (int k = 1; k < vertex.length; k++) {\n        center = centerVert[0];\n        if (center > centerVert[k]) {\n            centerV = k;\n        }\n    }\n    System.out.println(\"The center vertex is \" + vertex[centerV]);\n}\n\nArrayList<Vertex> breadthFirstSearch(Vertex source) {\n\n    ArrayList<Vertex> queue = new ArrayList<Vertex>();\n    ArrayList<Vertex> visited = new ArrayList<Vertex>();\n\n    // mark all vertices as not visited:\n    for (int i = 0; i < vertex.length; i++) {\n        vertex[i].visited = false;\n    }\n    source.visited = true;\n    queue.add(source);\n    while (!queue.isEmpty()) {\n        Vertex head = queue.remove(0);\n        visited.add(head);\n        for (Iterator<Vertex> iter = head.neighbors.iterator(); iter.hasNext();) {\n            Vertex neighbor = iter.next();\n            if (!neighbor.visited) {\n                neighbor.visited = true;\n                queue.add(neighbor);\n            }\n        }\n    }\n\n    return visited;\n}\n\n// Dijkstra's algorithm:\npublic void dijkstra(Vertex source) {\n    ArrayList<Vertex> VminusS = new ArrayList<Vertex>();\n    for (int i = 0; i < vertex.length; i++) {\n        vertex[i].d = Double.MAX_VALUE; // + infinity\n        vertex[i].pred = null;\n        VminusS.add(vertex[i]);\n    }\n    source.d = 0.0;\n    while (!VminusS.isEmpty()) {\n        Vertex smallestDVertex = null;\n        for (Iterator<Vertex> iter = VminusS.iterator(); iter.hasNext();) {\n            Vertex current = iter.next();\n            if (smallestDVertex == null || current.d < smallestDVertex.d) {\n                smallestDVertex = current;\n            }\n        }\n        for (Iterator<Vertex> iter = smallestDVertex.neighbors.iterator(); iter.hasNext();) {\n            Vertex neighbor = iter.next();\n            double edgeWt = weight[smallestDVertex.index][neighbor.index];\n            if (smallestDVertex.d + edgeWt < neighbor.d) {\n                neighbor.d = smallestDVertex.d + edgeWt;\n                neighbor.pred = smallestDVertex;\n            }\n        }\n        VminusS.remove(smallestDVertex);\n    }\n    System.out.println(\"Dijsktra's algorithm finished for source vertex \" + source);\n}\n\npublic void printShortestPath(Vertex destination, Vertex source) {\n    //ArrayList<Vertex> path = new ArrayList<Vertex>();\n    System.out.print(\"The shortest path from \" + source + \" to \" + destination + \" is: \");\n    Vertex cur = destination;\n    while (cur != null) {\n        System.out.print(cur + \" -> \");\n        //path.add(0, cur);\n        cur = cur.pred;\n    }\n    //System.out.println();\n}\n}\n```\n\n\nVertex Class:\n\n```\npackage TestGraphs;\n\nimport java.util.ArrayList;\n\npublic class Vertex {\npublic String name;\npublic int x, y;\npublic boolean visited;\npublic double d; // used by Dijkstra's alg\npublic Vertex pred; // used by Dijkstra's alg\npublic int index;\n\n// used for adjacency list representation:\nArrayList<Vertex> neighbors;\n\npublic Vertex(String name) {\n    this.name = name;\n}\n\npublic String toString() {\n    return \"(\" + x + \",\" + y + \")\";\n}\n}\n```\n\n\nTest Class:\n    package TestGraphs;\n\n```\nimport TestGraphs.Vertex;\nimport java.util.Random;\n\npublic class TestGraphs {\n\n/**\n * @param args the command line arguments\n */\npublic static double distance(double x0, double y0, double x1, double y1) {\n    return Math.sqrt((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0));\n}\n\npublic static void main(String[] args) {\n    // TODO code application logic here\n\n    Random r = new Random();\n    int source;\n    int numVertices = 10;\n\n    Graph g = new Graph(numVertices);\n    for (int i = 0; i < numVertices; i++) {\n        g.vertex[i] = new Vertex(\"Vertex \" + i);\n        g.vertex[i].x = r.nextInt(10);\n        g.vertex[i].y = r.nextInt(10);\n        g.vertex[i].index = i;\n    }\n\n    for (int i = 0; i < numVertices; i++) {\n        for (int s = 0; s < 2; s++) {\n            int n = r.nextInt(numVertices);\n            while (n == i) {\n                n = r.nextInt(numVertices);\n            }\n            g.weight[i][n] = g.weight[n][i]\n                    = distance(g.vertex[i].x, g.vertex[i].y, g.vertex[n].x, g.vertex[n].y);\n        }\n    }\n\n//        // find nearest neighbors:\n//        for (int i = 0; i < numVertices; i++) {\n//            double lowestD = Double.MAX_VALUE;\n//            int nearestNeighbor = 0;\n//            for (int j = 0; j < numVertices; j++) {\n//                if (i != j) {\n//                    double d = distance(g.vertex[i].x, g.vertex[i].y,\n//                            g.vertex[j].x, g.vertex[j].y);\n//                    if (d < lowestD) {\n//                        nearestNeighbor = j;\n//                        lowestD = d;\n//                    }\n//                }\n//            }\n//            // add edge between i and nearestneighbor;\n//            System.out.println(g.vertex[i] + \" has nearest neighbor \" + g.vertex[nearestNeighbor]);\n//            g.weight[i][nearestNeighbor] = lowestD;\n//        }\n    g.createAdjacencyLists();\n    g.printGraph();\n    g.dijkstra(g.vertex[0]);\n    System.out.println(\"vertex d values (after running Dijsktra's algorithm):\");\n    for (int i = 0; i < g.vertex.length; i++) {\n        System.out.println(g.vertex[i] + \" d: \" + String.format(\"%.2f\", g.vertex[i].d));\n    }\n    System.out.println();\n\n    // test some shortest paths:\n    source = 0;\n    for (int i = 0; i < numVertices; i++) {\n        g.printShortestPath(g.vertex[i], g.vertex[source]);\n        System.out.println(\"(distance = \" + String.format(\"%.2f\", g.vertex[i].d) + \")\");\n    }\n\n\n    source = 5;\n    //System.out.println(\"BFS returns: \" + g.breadthFirstSearch(g.vertex[0]));\n}\n\n}\n```\n\n    ", "Answer": "\r\nTry something like this:\n\n```\nfor (int i = 0; i < 30; ++i) {\n    int startVertex, endVertex;\n    do {\n        startVertex = random.nextInt(graphSize);\n        endVertex = random.nextInt(graphSize);\n    while (startVertex == endVertex) || graph.containsEdge(startVertex, endVertex);\n    graph.addEdge(startVertex, endVertex);\n}\n```\n\n\nThis sample contains some pseudocode, but the idea should be clear.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How can I modify Dijkstra's algorithm to get the longest path most of the time?\r\n                \r\nI know that finding the longest path is an NP Hard problem.\n\nWhat was asked from us was to change Dijkstra's algorithm to find the longest path by adding another parameter to the algorithm. A parameter like the distance from the source to the given vertex, the vertex predecessors, successors, number of edges...For example, we could extract the vertex from the queue depending on a parameter other than the max distance or we could another queue...\n\nWhat we did first was to change the initialization so that all vertices distances = 0 except the source node, that = infinity. Then we extracted from the queue of vertices the one with the biggest distance. Then, we inverted the relaxation sign, so that the vertex saves the distance if it is bigger that its current distance.\n\nWhat parameter could I add that would improve Dijkstra's performance in finding a longest path? It doesn't have to work 100% of the time.\n\nThis is Dijkstra's algorithm:\n\n```\nShortestPath(G, v)\n  init D array entries to infinity\n  D[v]=0\n  add all vertices to priority queue Q\n  while Q not empty do\n     u = Q.removeMin()\n     for each neighbor, z, of u in Q do\n       if D[u] + w(u,z) < D[z] then\n          D[z] = D[u] + w(u,z)\n          Change key of z in Q to D[z]\n return D as shortest path lengths\n```\n\n\nThis is our modified version:\n\n```\n ShortestPath(G, v)\n   init D array entries to 0\n   D[v]=infinity //source vertex\n   add all vertices to priority queue Q\n   while Q not empty do\n     u = Q.removeMax()\n     for each neighbor, z, of u in Q do\n        if D[u] + w(u,z) > D[z] then\n          D[z] = D[u] + w(u,z)\n          Change key of z in Q to D[z]\n   return D as shortest path lengths\n```\n\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Does Dijkstra's algorithm work with negative edges if there is no \"processed\" check?\r\n                \r\nTypically, in Dijkstra's algorithm, for each encountered node, we check whether that node was processed before attempting to update the distances of its neighbors and adding them to the queue. This method is under the assumption that if a distance to a node is set once then the distance to that node cannot improve for the rest of the algorithm, and so if the node was processed once already, then the distances to its neighbors cannot improve. However, this is not true for graphs with negative edges.\n\nIf there are no negatives cycles then if we remove that \"processed\" check, then will the algorithm always work for graphs with negative edges?\n\nEdit: an example of a graph where the algorithm would fail would be nice\n\nEdit 2: Java code https://pastebin.com/LSnfzBW4\n\nExample usage:\n\n```\n3 3 1 <-- 3 nodes, 3 edges, starting point at node 1\n1 2 5 <-- edge of node 1 and node 2 with a weight of 5 (unidirectional) \n2 3 -20 <-- more edges\n1 3 2\n```\n\n    ", "Answer": "\r\nThe algorithm will produce the correct answer, but since nodes can now be visited multiple times the time complexity will be exponential.\n\nHere's an example demonstrating the exponential complexity:\n\n```\nw(1, 3) = 4\nw(1, 2) = 100\nw(2, 3) = -100\nw(3, 5) = 2\nw(3, 4) = 50\nw(4, 5) = -50\nw(5, 7) = 1\nw(5, 6) = 25\nw(6, 7) = -25\n```\n\n\nIf the algorithm is trying to find the shortest path from node 1 to node 7, it will first reach node 3 via the edge with weight 4 and then explore the rest of the graph. Then, it will find a shorter path to node 3 by going to node 2 first, and then it will explore the rest of the graph again.\n\nEvery time the algorithm reaches one of the odd indexed nodes, it will first go to the next odd indexed node via the direct edge and explore the rest of the graph. Then it will find a shorter path to the next odd indexed node via the even indexed node and explore the rest of the graph again. This means that every time one of the odd indexed nodes is reached, the rest of the graph will be explored twice, leading to a complexity of at least ```\nO(2^(|V|/2))```\n.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm with Turn Penalty Giving Sub-Optimal Path\r\n                \r\nI'm having a problem returning the optimal path from A to E using Dijkstra's algorithm with a turn penalty of 0.25 in the following figure:\n\n\n\nMy implementation returns path ABDE (since the shortest distance to D is calculated as 3.05 along the curve instead of 3.25 along the straight lines), which has total cost 1 + 0.25 + 1.8 + 0.25 + 1 = 4.3.\n\nHowever, path ABCDE is the optimal path with total cost 1 + 1 + 0.25 + 1 + 1 = 4.25. How do I modify my implementation to account for this? Right now, all I'm doing is,\nif d[u] + w(u, v) + 0.25 < d[v], then d[v] = d[u] + w(u, v) + 0.25.\n    ", "Answer": "\r\nDijkstra's algorithm does not work with a turn penalty. If you want to use Dijkstra's algorithm, you will have to eliminate the turn penalty, for example by transforming the graph into a graph of original-node/arrival-direction pairs with edges and edge costs that incorporate the original problem's turn penalty.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Keeping track of the shortest path between two nodes using Dijkstra's algorithm\r\n                \r\nI am quite new to c++ and have been having trouble modifying Dijkstra's algorithm to keep track of the shortest path between two nodes, not just the shortest distance. I have it computing the shortest distance correctly. This is the function that calculates the shortest distance:   \n\n```\n  vector<vertex<T>> shortest_path(directed_graph<T> g, int u_id, int v_id) {\n  vector<vertex<T>> shortest;\n  vector<vector<T>> graph = g.get_adjacency_matrix();\n\n  if (!g.contains(u_id) && !g.contains(v_id)) {\n    return shortest;\n  }\n\n  shortest.push_back(vertex<T>(u_id, g.get_vert_weight(u_id)));\n\n  int *dist = new int[g.num_vertices()]; // Will hold the shortest distance from u_id to i\n  bool *sptSet = new bool[g.num_vertices()]; // Will be true if vertex i is including in shortest path tree from u_id to i\n\n  int parent[g.num_vertices()]; // parent to store the shortest path tree\n\n  // initialise all distances as INFINITE and set stpset as false\n  for (int i = 0; i < g.num_vertices(); i++) {\n    parent[u_id] = -1;\n    dist[i] = INT_MAX;\n    sptSet[i] = false;\n  }\n\n  dist[u_id] = 0; // Distance of source vertex to itself is always 0\n\n  for (int count = 0; count < (g.num_vertices() - 1); count++) { // find shortest path for all vertices\n    int u = min_distance(dist, sptSet, g.num_vertices()); // pick the min distance vertex from the set of vertices not yet processed\n    sptSet[u] = true; // mark the picked vertex as processed\n\n    for (int v = 0; v < g.num_vertices(); v++) { // update dist value of the adjacent vertices of the picked vertex\n      // update dist[v] only if its not in sptset, there is an edge from u to v, and total weight of path from u_id to v\n      // through u is smaller than current distance value of dist[v]\n      if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX && dist[u] + graph[u][v] < dist[v]) {\n        parent[v] = u;\n        dist[v] = dist[u] + graph[u][v];\n      }\n    }\n  }\n\n  for (int i = 0; i < g.num_vertices(); i++) {\n    if (dist[i] != INT_MAX) {\n      cout << u_id << \" -> \" << i << \" : \" << dist[i] << endl;\n    } else {\n      cout << u_id << \" -> \" << i << \" : n/a\" << endl;\n    }\n  }\n\n  return shortest;\n\n}\n```\n\n\nand here is the graph I've been using for testing:\n\n```\n    g1.add_edge(0, 1, 4);\n    g1.add_edge(7, 0, 8);\n    g1.add_edge(1, 7, 11);\n    g1.add_edge(7, 8, 7);\n    g1.add_edge(1, 2, 8);\n    g1.add_edge(8, 2, 2);\n    g1.add_edge(7, 6, 1);\n    g1.add_edge(8, 6, 6);\n    g1.add_edge(6, 5, 2);\n    g1.add_edge(5, 2, 4);\n    g1.add_edge(2, 3, 7);\n    g1.add_edge(3, 5, 14);\n    g1.add_edge(4, 3, 9);\n    g1.add_edge(5, 4, 10);\n```\n\n\nCould someone please help me with the shortest path bit?\n    ", "Answer": "\r\nYou could make use of ```\nparent```\n array to reconstruct the path starting from target node to source node, for example:\n\n```\nvector<int> path;\nint idx = v_id;\nwhile (idx != u_id) {\n    path.emplace_back(idx);\n    idx = parent[idx];\n}\npath.emplace_back(idx);\nreverse(path.begin, path.end());\ncout << \"PATH: \";\nfor (int x : path) {\n    cout << x << \" \";\n}\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra algorithm on a matrix\r\n                \r\nI have to create an N * M matrix and fill it up with values between 0 and 9. One of the values should be \"A\" which is the starting point of the graph, and I should find the shortest path to the value \"B\" (both of these are generated at a random position of the matrix). If the value is 0 it counts as an obstacle, and 2 < N, M < 100.\nI have to print out the exact route of the shortest graph and the total cost of it. Also, the problem has to be solved by Dijkstra's algorithm.\nI've haven't gotten past filling up the Matrix. I store the values in a 2D String array, but I think I should use different arrays or maybe Maps for storing the positions of key values such as the start and endpoint. I've been thinking on this for 2 days now because I'm a total noob in Java and not much better at programming in general. I'm mainly looking for guidance on how to store the datas and what should I actually store in order to get to the end because I think I overcomplicate the problem.\nThis is the matrix generating part of the code.\n```\nint N = ThreadLocalRandom.current().nextInt(3,7);\nint M = ThreadLocalRandom.current().nextInt(3,7);\nint J = ThreadLocalRandom.current().nextInt(0,(Math.min(N, M))/2);\nint K = 0;\nint aPosX = ThreadLocalRandom.current().nextInt(0,N);\nint aPosY = ThreadLocalRandom.current().nextInt(0,M);\nint bPosX = ThreadLocalRandom.current().nextInt(0,N);\nint bPosY = ThreadLocalRandom.current().nextInt(0,M);\nString[][] matrix = new String[N][M];\nint[][] map = new int[N][M];\nint shortestPath = 10;\nint currentPosX,currentPosY;\nint shortestPosX, shortestPosY;\n\npublic void generateMatrix(){\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            K = ThreadLocalRandom.current().nextInt(0,10);\n            matrix[i][j] = String.valueOf(K);\n        }\n    }\n}\n\npublic void createStartAndFinish(){        \n    matrix[aPosX][aPosY] = \"A\";\n    matrix[bPosX][bPosY] = \"B\";\n}\n\n   \n}\n```\n\nThis part finds the lowest cost adjacent tiles and steps on them but id does generate an out of bounds exception. I'm also aware that it has nothing to do with Dijkstra algorithm but this is my starting point.\n```\npublic void solveMatrix(){\n    visited[aPosX][aPosY] = true;\n    currentPosX = aPosX;\n    currentPosY = aPosY;\n    \n    while (!matrix[currentPosX - 1][currentPosY].equals(\"B\") || \n            !matrix[currentPosX + 1][currentPosY].equals(\"B\") || \n            !matrix[currentPosX][currentPosY - 1].equals(\"B\") ||\n            !matrix[currentPosX][currentPosY + 1].equals(\"B\")) {\n        \n        if(currentPosX > 0) {\n            if(!visited[currentPosX - 1][currentPosY] && Integer.parseInt(matrix[currentPosX - 1][currentPosY]) < shortestPath) {\n                shortestPath = Integer.parseInt(matrix[currentPosX - 1][currentPosY]);\n                shortestPosX = currentPosX - 1;\n                shortestPosY = currentPosY;\n            }\n        }\n        if(currentPosX + 1 < N){\n            if(!visited[currentPosX + 1][currentPosY] && Integer.parseInt(matrix[currentPosX + 1][currentPosY]) < shortestPath) {\n                shortestPath = Integer.parseInt(matrix[currentPosX + 1][currentPosY]);\n                shortestPosX = currentPosX + 1;\n                shortestPosY = currentPosY;\n            }\n        }\n        if(currentPosY > 0){\n            if(!visited[currentPosX][currentPosY - 1] && Integer.parseInt(matrix[currentPosX][currentPosY - 1]) < shortestPath) {\n                shortestPath = Integer.parseInt(matrix[currentPosX][currentPosY - 1]);\n                shortestPosX = currentPosX;\n                shortestPosY = currentPosY - 1;\n            }\n        }\n        if(currentPosY - 1 < M){\n            if(!visited[currentPosX][currentPosY + 1] && Integer.parseInt(matrix[currentPosX][currentPosY + 1]) < shortestPath) {\n                shortestPath = Integer.parseInt(matrix[currentPosX][currentPosY + 1]);\n                shortestPosX = currentPosX;\n                shortestPosY = currentPosY + 1;\n            }\n        }\n        \n        visited[shortestPosX][shortestPosY] = true;\n        currentPosX = shortestPosX;\n        currentPosY = shortestPosY;\n        \n        System.out.println(shortestPosX + \" \" + shortestPosY + \" \" + shortestPath);\n        shortestPath = 10;\n    } \n    \n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Keeping track of the shortest path between two nodes using Dijkstra's algorithm\r\n                \r\nI am quite new to c++ and have been having trouble modifying Dijkstra's algorithm to keep track of the shortest path between two nodes, not just the shortest distance. I have it computing the shortest distance correctly. This is the function that calculates the shortest distance:   \n\n```\n  vector<vertex<T>> shortest_path(directed_graph<T> g, int u_id, int v_id) {\n  vector<vertex<T>> shortest;\n  vector<vector<T>> graph = g.get_adjacency_matrix();\n\n  if (!g.contains(u_id) && !g.contains(v_id)) {\n    return shortest;\n  }\n\n  shortest.push_back(vertex<T>(u_id, g.get_vert_weight(u_id)));\n\n  int *dist = new int[g.num_vertices()]; // Will hold the shortest distance from u_id to i\n  bool *sptSet = new bool[g.num_vertices()]; // Will be true if vertex i is including in shortest path tree from u_id to i\n\n  int parent[g.num_vertices()]; // parent to store the shortest path tree\n\n  // initialise all distances as INFINITE and set stpset as false\n  for (int i = 0; i < g.num_vertices(); i++) {\n    parent[u_id] = -1;\n    dist[i] = INT_MAX;\n    sptSet[i] = false;\n  }\n\n  dist[u_id] = 0; // Distance of source vertex to itself is always 0\n\n  for (int count = 0; count < (g.num_vertices() - 1); count++) { // find shortest path for all vertices\n    int u = min_distance(dist, sptSet, g.num_vertices()); // pick the min distance vertex from the set of vertices not yet processed\n    sptSet[u] = true; // mark the picked vertex as processed\n\n    for (int v = 0; v < g.num_vertices(); v++) { // update dist value of the adjacent vertices of the picked vertex\n      // update dist[v] only if its not in sptset, there is an edge from u to v, and total weight of path from u_id to v\n      // through u is smaller than current distance value of dist[v]\n      if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX && dist[u] + graph[u][v] < dist[v]) {\n        parent[v] = u;\n        dist[v] = dist[u] + graph[u][v];\n      }\n    }\n  }\n\n  for (int i = 0; i < g.num_vertices(); i++) {\n    if (dist[i] != INT_MAX) {\n      cout << u_id << \" -> \" << i << \" : \" << dist[i] << endl;\n    } else {\n      cout << u_id << \" -> \" << i << \" : n/a\" << endl;\n    }\n  }\n\n  return shortest;\n\n}\n```\n\n\nand here is the graph I've been using for testing:\n\n```\n    g1.add_edge(0, 1, 4);\n    g1.add_edge(7, 0, 8);\n    g1.add_edge(1, 7, 11);\n    g1.add_edge(7, 8, 7);\n    g1.add_edge(1, 2, 8);\n    g1.add_edge(8, 2, 2);\n    g1.add_edge(7, 6, 1);\n    g1.add_edge(8, 6, 6);\n    g1.add_edge(6, 5, 2);\n    g1.add_edge(5, 2, 4);\n    g1.add_edge(2, 3, 7);\n    g1.add_edge(3, 5, 14);\n    g1.add_edge(4, 3, 9);\n    g1.add_edge(5, 4, 10);\n```\n\n\nCould someone please help me with the shortest path bit?\n    ", "Answer": "\r\nYou could make use of ```\nparent```\n array to reconstruct the path starting from target node to source node, for example:\n\n```\nvector<int> path;\nint idx = v_id;\nwhile (idx != u_id) {\n    path.emplace_back(idx);\n    idx = parent[idx];\n}\npath.emplace_back(idx);\nreverse(path.begin, path.end());\ncout << \"PATH: \";\nfor (int x : path) {\n    cout << x << \" \";\n}\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm Implementation in Python - How Does it Work?\r\n                \r\nI can use the following English algorithm to find shortest paths using Dijkstra's Algorithm on paper:\n\n\nStep 1:    Assign permanent label and order to starting node\nStep 2:    Assign temporary labels to all nodes directly reached by starting node\nStep 3:    Select the lowest temporary label and make it permanent\nStep 4:    Assign an order to the node\nStep 5:    Update and assign temporary labels for nodes directly reached from the new permanent node\nStep 6:    Repeat steps 3, 4 & 5 until the destination node is made permanent\n\n\nI have searched for a Python implementation and many are quite complex or use data structures I'm not familiar with. Eventually I found the one below. I have spent quite some time tracing it's execution in a Python visualizer, and I can get a sense of how it works but it has not yet clicked for me.\n\nCould someone please explain how the code relates to the English algorithm? For example, how does the notion of \"predecessors\" relate to the \"permanent labels\" in the English version?\n\n```\nfrom math import inf\n\ngraph = {'a':{'b':10,'c':3},'b':{'c':1,'d':2},'c':{'b':4,'d':8,'e':2},'d':{'e':7},'e':{'d':9}}\n\n\ndef dijkstra(graph,start,goal):\n    shortest_distance = {}\n    predecessor = {}\n    unseenNodes = graph\n    infinity = inf\n    path = []\n    for node in unseenNodes:\n        shortest_distance[node] = infinity\n    shortest_distance[start] = 0\n\n    # Determine which is minimum node. What does that mean?\n    while unseenNodes:\n        minNode = None\n        for node in unseenNodes:\n            if minNode is None:\n                minNode = node\n            elif shortest_distance[node] < shortest_distance[minNode]:\n                minNode = node\n\n        for edge, weight in graph[minNode].items():\n            if weight + shortest_distance[minNode] < shortest_distance[edge]:\n                shortest_distance[edge] = weight + shortest_distance[minNode]\n                predecessor[edge] = minNode\n        unseenNodes.pop(minNode)\n\n    currentNode = goal\n    while currentNode != start:\n        try:\n            path.insert(0,currentNode)\n            currentNode = predecessor[currentNode]\n        except KeyError:\n            print('Path not reachable')\n            break\n    path.insert(0,start)\n    if shortest_distance[goal] != infinity:\n        print('Shortest distance is ' + str(shortest_distance[goal]))\n        print('And the path is ' + str(path))\n\n\ndijkstra(graph, 'a', 'b')\n```\n\n    ", "Answer": "\r\nDijkstra’s algorithm same to prim’s algorithm for minimum spanning tree. Like Prim’s MST, we generate a shortest path tree with given source as root. We maintain two sets, one set contains vertices included in shortest path tree, other set includes vertices not yet included in shortest path tree. At every step of the algorithm, we find a vertex which is in the other set (set of not yet included) and has a minimum distance from the source.\n\n```\nimport sys\n\nclass Graph():\n\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for column in range(vertices)]\n                  for row in range(vertices)]\n\n    def printSolution(self, dist):\n        print(\"Vertex tDistance from Source\")\n        for node in range(self.V):\n            print(node, \"t\", dist[node])\n\n    def minDistance(self, dist, sptSet):\n\n        min = sys.maxint\n\n        for v in range(self.V):\n            if dist[v] < min and sptSet[v] == False:\n                min = dist[v]\n                min_index = v\n\n        return min_index\n\n    def dijkstra(self, src):\n\n        dist = [sys.maxint] * self.V\n        dist[src] = 0\n        sptSet = [False] * self.V\n\n        for cout in range(self.V):\n\n            u = self.minDistance(dist, sptSet)\n\n            sptSet[u] = True\n\n            for v in range(self.V):\n                if self.graph[u][v] > 0 and sptSet[v] == False and \\\n                    dist[v] > dist[u] + self.graph[u][v]:\n                    dist[v] = dist[u] + self.graph[u][v]\n\n        self.printSolution(dist)\n\ng = Graph(9)\ng.graph = [[0, 4, 0, 0, 0, 0, 0, 8, 0],\n           [4, 0, 8, 0, 0, 0, 0, 11, 0],\n           [0, 8, 0, 7, 0, 4, 0, 0, 2],\n           [0, 0, 7, 0, 9, 14, 0, 0, 0],\n           [0, 0, 0, 9, 0, 10, 0, 0, 0],\n           [0, 0, 4, 14, 10, 0, 2, 0, 0],\n           [0, 0, 0, 0, 0, 2, 0, 1, 6],\n           [8, 11, 0, 0, 0, 0, 1, 0, 7],\n           [0, 0, 2, 0, 0, 0, 6, 7, 0]]\ng.dijkstra(0)\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How to get the real shortest path using Dijkstra's algorithm\r\n                \r\nI want to find the shortest path between two pixels of a binary matrix. The elements which are equal to 0 indicate a passable node, while 1s indicate an obstacle.\nI tried to solve the problem by implementing a C version of the Dijkstra's algorithm, but the path I obtained is not what I expected. Instead of having a straight line between the two pixels, I got several segments. The following images show some examples:\n\n\nThis is the pseudocode of the algorithm I implemented: (I took it from Wikipedia):\n```\nfunction Dijkstra(Graph, source):\n\n    create a empty list of nodes L          // the list will contains all the element of the matrix qual to 0. (1s are bostavles)\n\n    for each node n:            \n        weights[n] ← INFINITY                 \n        prev[n] ← UNDEFINED                \n        add n to L\n\n    weights[source] ← 0\n  \n    while L is not empty:\n        c ← node in L with min weights[c]\n                                       \n        remove c from L                     // the current node will be removed from the L list\n        \n        for each neighbor v of c:           // only v that are still in L\n            alt ← weights[c] + length(c, v)  // calculate the new weights for the neighbor \n                if alt < dist[v]:              \n                    weights[v] ← alt\n                    prev[v] ← c\n\nreturn weights[], prev[]\n```\n\nIn my case ```\nlength(c, v)```\n is equal to ```\nsqrt(2)```\n for the neighbor along the diagonals ```\n1```\n otherwise as shown in the picture.\n\nHow can I obtain the real shortest path and not an approximation of it?\nThanks!\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstras Algorithm Sets\r\n                \r\nI am currently revising for one of my exams and have come accross this question, \n\"Show, step by step, the use of Dijkstra’s algorithm to find the shortest path from the vertex A to each other vertex in the graph.  At each step the known and frontier sets should be clearly indicated.\"\nI understand how to find the shortest path but I am usnsure of what a frontier set is? \nThank you!\n    ", "Answer": "\r\nThere are many ways to formulate Dijkstra's algorithm, but the core idea behind most versions is to split the nodes into three groups:\n\n\nNodes where you already know the shortest path from the start point. This is initiallt just the start node and grows as the algorithm runs for longer and longer periods of time.\nNodes in the frontier. These are nodes adjacent to nodes in the first group, where you have a guess of the distance to the node but can't necessarily be sure that guess is correct. At each step in the algorithm, you choose the lowest-cost node in the frontier and move it to the group of nodes where you know the shortest path.\nUnexplored nodes. These are all the remaining nodes.\n\n\nIf you implement Dijkstra's algorithm with a priority queue, then the frontier nodes are typically the ones in the priority queue. If you maintain a list of candidate distances to nodes and instead pick the cheapest one at each point, the frontier consists of all the nodes whose candidate distance isn't infinity.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm in c++ infinite loop\r\n                \r\nI was trying to implement Dijkstras's algorithm in c++. Now i have trouble debugging. Somewhere in my code there is an infinite loop. And my graph implementation sucks. if you have any ideas what is wrong with my code even if it is not about the main problem tell me. \n\nI don't need somebody elses code i need it to be my code but fixed so i can find my mistakes in code and better understand it (i only understand my codes sadly c++ compiler doesn't). \n\nHere is my code: \n\n```\n#include <iostream>\n#include <vector>\n#include <limits.h>\n#include <queue>\nusing namespace std;\n\nvector < vector<int> > graf;\nint fromnode, tonode;\n\nstruct nodeinfo\n{\n    //this contains info about a node\n    bool visited = 0;\n    int dis = INT_MAX/2;\n};\nnodeinfo sample;\nvector<nodeinfo> info; // if visited\nqueue<int> togo;\n\n// dijkstra algorithm\nvoid dijkstra(int currnode)\n{\n    //visited current node\n    info[currnode].visited = 1;\n    //go see every node connected to the current one\n    for(int i = 0; i < graf[currnode].size(); i ++){\n        if (graf[currnode][i] != INT_MAX/2 ) {\n            // if visited push to queue and check distance\n            if(info[i].visited== 0)\n                togo.push(i);\n            info[i].dis = max(info[i].dis,info[currnode].dis + graf[currnode][i]);\n        }\n    }\n}\n\n\nint main()\n{\n    //input n\n    int n;\n    cin >> n;\n\n    //declaring variables\n    graf.resize(n*2);\n    info.resize(n*2);\n    vector<int> fillin (100,INT_MAX/2);\n    graf.insert(graf.begin(),100,fillin);\n    int a,b,c;\n\n    //input in graphinfo[graf[currnode][i\n    for(int i = 0; i < n; i ++){\n        cin >> a >> b >> c;\n        if (graf[a][b] > c)\n            graf[a][b] = graf[b][a] = c;\n        cout << i << endl;\n    }\n    // input from witch node to go and where to go and\n    cin >> fromnode >> tonode;\n    info[fromnode].dis = 0;\n    togo.push(fromnode);\n    //dijkstra start\n    while(!togo.empty()){\n        dijkstra(togo.front());\n    }\n    // output\n    cout << info[tonode].dis << endl;\n    return 0;\n}\n```\n\n\nafter i had put   ```\ncout << \"at node \" << currnode << endl;```\n at the beginning of dijskstra function using this input:\n\n\n\nIt was stuck on node 1:\n\n\n    ", "Answer": "\r\nYour loop says\n\n```\nwhile(!togo.empty())\n```\n\n\nbut you never remove anything from ```\ntogo```\n.\nYou'll want to ```\npop```\n at a suitable place.\n(Finding a suitable place left as an exercise.)\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Time complexity for Dijkstra's algorithm with min heap and optimizations\r\n                \r\nWhat is the time complexity of this particular implementation of Dijkstra's algorithm?\nI know several answers to this question say O(E log V) when you use a min heap, and so does this article and this article. However, the article here says O(V+ElogE) and it has similar (but not exactly the same) logic as the code below.\nDifferent implementations of the algorithm can change the time complexity. I'm trying to analyze the complexity of the implementation below, but the optimizations like checking ```\nvisitedSet```\n and ignoring repeated vertices in ```\nminHeap```\n is making me doubt myself.\nHere is the pseudo code:\n```\n// this part is O(V)\nfor each vertex in graph {\n  distanceMap[vertex] = infinity\n}\n\n// initialize source vertex\nminHeap.add(source vertex and 0 distance)\ndistanceMap[source] = 0\nvisitedSet.add(source vertex)\n\n// loop through vertices: O(V)?\nwhile (minHeap is not empty) {\n\n  // Removing from heap is O(log n) but is n the V or E?\n  vertex and distance = minHeap.removeMin\n  if (distance > saved distance in distanceMap) continue while loop\n\n  visitedSet.add(vertex)\n\n  // looping through edges: O(E) ?\n  for (each neighbor of vertex) {\n    if (visitedSet contains neighbor) continue for loop\n\n    totalDistance = distance + weight to neighbor\n    if (totalDistance < saved distance in vertexMap) {\n\n      // Adding to heap is O(log n) but is n the V or E?\n      minHeap.add(neighbor and totalDistance)\n      distanceMap[neighbor] = totalDistance\n    }\n  }\n}\n```\n\nNotes:\n\nEach vertex that is reachable from the source vertex will be visited at least once.\nEach edge (neighbor) of each vertex is checked but ignored if in ```\nvisitedSet```\n\nA neighbor is added to the heap only if it has a shorter distance that the currently known distance. (Unknown distances are assumed to have a default length of infinity.)\n\nWhat is the actual time complexity of this implementation and why?\n    ", "Answer": "\r\n\nDespite the test, this implementation of Dijkstra may put Ω(E) items in the priority queue. This will cost Ω(E log E) with every comparison-based priority queue.\n\nWhy not E log V? Well, assuming a connected, simple, nontrivial graph, we have Θ(E log V) = Θ(E log E) since log (V−1) ≤ log E < log V² = 2 log V.\n\nThe O(E + V log V)-time implementations of Dijkstra's algorithm depend on a(n amortized) constant-time DecreaseKey operation, avoiding multiple entries for an individual vertex. The implementation in this question will likely be faster in practice on sparse graphs, however.\n\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm for bus route (prioritise on fare price)\r\n                \r\nI am struggling with a Dijkstra's algorithm problem with two costs: time and fare price. Assume there are flat ticket rate for each bus route(could differ between different routes) and between two consecutive bus stops, every bus takes the same time to travel. I am wondering if there's an algorithm might be suited to this problem? It needs to be polynomial time in regards to total bus line counts n, k instances and p stops. The bus timetables are made of tuples (bus stop, time arrives, and potentially time it departs(doesn't matter too much)).\nI forgot to mention that since I only need to arrive the place on time(to say arrive the office just before the time to commence my work), I could probably just filter the ones within the timeframe...\nSorry for the vague post anyways.\nI am thinking of DFS but DFS is just not effective... Any better ways?\n    ", "Answer": "\r\n\"Time is money!\"\nHow much does time cost?  Determine that and you have your answer.\nIf you are willing to pay $1 to arrive 1 min faster, then you set the cost of each edge as the sum of the cost in dollars and the time in minutes.\nI general, any optimization is done by minimizing or maximizing a function of all the different factors.  The function is usually and most simply a linear function, but optimizing algorithms such as Dijkstra will work on any sort of defined single valued function.\n```\nmin| max f( f1, f2,...)\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm Assistance\r\n                \r\nGiven an adjacency matrix, I need to compute the shortest path between the first vertex and the last vertex (generally, vertex i and j, but we can ignore that for the time being). I've written an algorithm that really only correctly computes the distance between the first and second node (a step in the right direction, I guess). \n\n```\nstatic int dijkstra(int[][] G, int i, int j) {\n    //Get the number of vertices in G\n    int n = G.length;\n    int[] bestpath = new int[n];\n    int max = Integer.MAX_VALUE;\n    boolean[] visited = new boolean[n];\n\n    for (int x = 0; x < n; x++) {\n        visited[x] = false;\n        bestpath[x] = max;\n    }\n\n    bestpath[i] = 0;\n\n    for (int x = 0; x < n; x++) {\n        int min = max;\n        int currentNode = i;\n        for (int y = 0; y < n; y++) {\n            if (!visited[y] && bestpath[y] < min) {\n                System.out.println(G[y][x]);\n                currentNode = y;\n                min = bestpath[y];\n            }\n        }\n        visited[currentNode] = true;\n        for (int y = 0; y < n; y++) {\n            if (G[currentNode][y] < max && bestpath[currentNode] + G[currentNode][y] < bestpath[y]) {\n                bestpath[y] = bestpath[currentNode] + G[currentNode][y];\n            }\n        }\n    }\n\n    return bestpath[j];\n}\n```\n\n\nIf I were to guess, I'd say my logic is flawed in this section: \n\n```\n for (int y = 0; y < n; y++) {\n            if (!visited[y] && bestpath[y] < min) {\n                System.out.println(G[y][x]);\n                currentNode = y;\n                min = bestpath[y];\n            }\n }\n```\n\n\nAn example would be the matrix \n\n```\n0 1 0 \n1 0 1\n0 1 0 \n```\n\n\nwhich would return 2 (one path between vertex one and two of weight 1 and another between 2 and 3 with weight 1).\n    ", "Answer": "\r\nIf the matrix is not just storing 1s and 0s, but the distance from i to j, then you really need to keep track of the best distance from any node i to j. In other words, your working array should be a working matrix instead. Even if you are just doing a non - weighted graph, I think this approach is better. \n\nThere are different versions of the SPF algorithm. Post pseudocode for what you are trying to translate into java. \n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "JAVA - Finding shortest path between 2 vertex using Dijkstra's Algorithm\r\n                \r\nSo I am doing a math project, not a computer science one, but I want to use code to help collect my data. To this I want to use Dijkstra's Algorithm and count how many edges it has to go to before it can get an answer. However I cannot find any pre existing code that works for my graph.\n\n```\npackage mathematicsia;\n\nimport java.util.PriorityQueue;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\nclass Vertex implements Comparable<Vertex>\n{\n    public final String name;\n    public Edge[] adjacencies;\n    public double minDistance = Double.POSITIVE_INFINITY;\n    public Vertex previous;\n    public Vertex(String argName) { name = argName; }\n    public String toString() { return name; }\n    public int compareTo(Vertex other)\n    {\n        return Double.compare(minDistance, other.minDistance);\n    }\n\n}\n\n\nclass Edge\n{\n    public final Vertex target;\n    public final double weight;\n    public Edge(Vertex argTarget, double argWeight)\n    { target = argTarget; weight = argWeight; }\n}\n\npublic class DijkstrasAlgorithm\n{\n    public static void computePaths(Vertex source)\n    {\n        source.minDistance = 0.;\n        PriorityQueue<Vertex> vertexQueue = new PriorityQueue<Vertex>();\n        vertexQueue.add(source);\n\n        while (!vertexQueue.isEmpty()) {\n            Vertex u = vertexQueue.poll();\n\n            // Visit each edge exiting u\n            for (Edge e : u.adjacencies)\n            {\n                Vertex v = e.target;\n                double weight = e.weight;\n                double distanceThroughU = u.minDistance + weight;\n                if (distanceThroughU < v.minDistance) {\n                    vertexQueue.remove(v);\n\n                    v.minDistance = distanceThroughU ;\n                    v.previous = u;\n                    vertexQueue.add(v);\n                }\n            }\n        }\n    }\n\n    public static List<Vertex> getShortestPathTo(Vertex target)\n    {\n        List<Vertex> path = new ArrayList<Vertex>();\n        for (Vertex vertex = target; vertex != null; vertex = vertex.previous)\n            path.add(vertex);\n\n        Collections.reverse(path);\n        return path;\n    }\n\n    public static void main(String[] args)\n    {\n        // mark all the vertices \n        Vertex P = new Vertex(\"P\");\n        Vertex L = new Vertex(\"L\");\n        Vertex E = new Vertex(\"E\");\n\n        Vertex B4 = new Vertex(\"B4\"); //Bridge Level 4\n        Vertex B5 = new Vertex(\"B5\"); //Bridge Level 5\n\n        Vertex A2 = new Vertex(\"A2\"); //Stairs A\n        Vertex A3 = new Vertex(\"A3\");\n        Vertex A4 = new Vertex(\"A4\");\n        Vertex A5 = new Vertex(\"A5\");\n        Vertex A6 = new Vertex(\"A6\");\n\n        Vertex C2 = new Vertex(\"C2\"); //Stairs C\n        Vertex C3 = new Vertex(\"C3\");\n        Vertex C4 = new Vertex(\"C4\");\n        Vertex C5 = new Vertex(\"C5\");\n        Vertex C6 = new Vertex(\"C6\");\n\n        // set the edges and weight\n        L.adjacencies = new Edge[]{ new Edge(A2, 83) }; //A\n        L.adjacencies = new Edge[]{ new Edge(B4, 90) }; //B\n        L.adjacencies = new Edge[]{ new Edge(B5, 130) }; //C\n        L.adjacencies = new Edge[]{ new Edge(C2,86 ) }; //D\n\n        B4.adjacencies = new Edge[]{ new Edge(C4, 33) }; //E\n        B4.adjacencies = new Edge[]{ new Edge(A4,59 ) }; //F\n\n        A2.adjacencies = new Edge[]{ new Edge(C2, 97) }; //G\n        A3.adjacencies = new Edge[]{ new Edge(C3,70 ) }; //H\n        A4.adjacencies = new Edge[]{ new Edge(C4,71 ) }; //I\n\n        A2.adjacencies = new Edge[]{ new Edge(A3,15 ) }; //J\n        A3.adjacencies = new Edge[]{ new Edge(A4,15 ) }; //K\n        A4.adjacencies = new Edge[]{ new Edge(A5,15 ) }; //L\n        A5.adjacencies = new Edge[]{ new Edge(A6, 15) }; //M\n        A6.adjacencies = new Edge[]{ new Edge(C6, 75) }; //N\n\n        P.adjacencies = new Edge[]{ new Edge(A6, 27) }; //O\n        E.adjacencies = new Edge[]{ new Edge(A3,85 ) }; //P\n        P.adjacencies = new Edge[]{ new Edge(C6, 97) }; //Q\n        E.adjacencies = new Edge[]{ new Edge(C3, 25) }; //R\n\n        B5.adjacencies = new Edge[]{ new Edge(C5,33 ) }; //S\n        B5.adjacencies = new Edge[]{ new Edge(A5, 59) }; //T\n\n        C5.adjacencies = new Edge[]{ new Edge(C4, 15) }; //U\n        C4.adjacencies = new Edge[]{ new Edge(C3, 15) }; //V\n        C3.adjacencies = new Edge[]{ new Edge(C2,24 ) }; //W\n        C6.adjacencies = new Edge[]{ new Edge(C5, 15) }; //X\n\n        P.adjacencies = new Edge[]{ new Edge(C6,73 ) }; //Y \n        A5.adjacencies = new Edge[]{ new Edge(C5, 75) }; //Z\n\n\n\n        computePaths(L); // run Dijkstra\n        System.out.println(\"Distance to \" + P + \": \" + P.minDistance);\n        List<Vertex> path = getShortestPathTo(P);\n        System.out.println(\"Path: \" + path);\n    }\n}\n```\n\n\nThis does not work as it gives me an error when I try running, please help!\n    ", "Answer": "\r\nLets start with your Vertex class. You have a non-optimal design of storing both the topographical information:\n\n\nname\nadjacencies\n\n\nAnd mutable information about some traversal:\n\n\nminDistance\nprevious\n\n\nLets start by \"pureifying\" your Vertex to only represent the topographical information. In additional lets implement hashCode() and equals() so we can use it in a dictionary.\n\n```\nclass Vertex\n{\n    public final String name;\n    public Edge[] adjacencies;\n\n    public Vertex(String argName) { name = argName; }\n    public String toString() { return name; }\n    public int equals(Vertex other) {\n        return this.name.compareTo(other.name);\n    }\n    public int hashCode() {\n        return this.name.hashCode();\n    }\n}\n```\n\n\nThen lets make a result class to hold the path set:\n\n```\nclass Path {\n    HashMap<Vertex, Integer> distances = new HashMap<>();\n    HashMap<Vertex, Vertex> backtrack = new HashMap<>(); \n}\n```\n\n\nNow, we can implement Dijkstras. I modified your implementation a little bit so that it functionally matches the wikipedia entry. That way you can follow along with their animations.\n\n```\npublic Path computePaths(Vertex source)\n{\n    Path p = new Path();\n    Set<Vertex> visited = new HashSet<>();\n    distances.put(source, 0); // Distance from source to source\n\n    Queue<Vertex> vertexQueue = new LinkedList<Vertex>();\n    vertexQueue.add(source);\n    visited.add(source);\n\n    while (!vertexQueue.isEmpty()) {\n        Vertex u = vertexQueue.remove();\n\n        // Visit each edge exiting u\n        for (Edge e : u.adjacencies)\n        {\n            Vertex v = e.target;\n            double distanceThroughU = p.distances.get(u) + e.weight;\n            if (!p.distances.contains(v) || distanceThroughU < p.distances.get(v)) {\n                p.distances.put(v, distance);\n                p.backtrack.put(v, u);\n            }\n            // We didn't prime the queue but we need to make sure we visit everyone\n            // at least once.\n            if (!visited.contains(v)) {\n                vertexQueue.add(v);\n                visited.add(v);\n            }\n        }\n    }\n    return p;\n}\n```\n\n\nFinally, we can use that Path to create paths:\n\n```\npublic static List<Vertex> getShortestPathTo(Path p, Vertex target)\n{\n    List<Vertex> path = new List<Vertex>();\n      for (Vertex vertex = target; vertex != null; vertex = p.backtrack.get(vertex))\n        path.add(vertex);\n\n    Collections.reverse(path);\n    return path;\n}\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Implementing Dijkstra's shortest path algorithm using a red/black tree?\r\n                \r\nI know that Dijkstra's algorithm in reality is implemented using a Fibonacci heap. But can it also be implemented using a red black tree and still have a worst-case running time of O(m log n)?\n    ", "Answer": "\r\nFor starters, it's rare to actually see Dijkstra's algorithm implemented with a Fibonacci heap.  Although the Fibonacci heap gives great asymptotic performance (O(m + n log n)), in practice it has such high constant factors that other types of heaps are more efficient.\n\nAs to your question - yes, you could use a red-black tree as a priority queue to get O(m log n) performance.  This works because you can find the minimum element in a red-black tree in O(log n) time and simulate a decrease-key operation on the tree in time O(log n) by doing a deletion followed by an insertion.  However, this is probably not as efficient as using a standard binary heap, since the red-black tree has worse locality of reference and more memory overhead.  More generally, you always can use a balanced binary search tree whenever you need a priority queue, though usually doing so is overkill.\n\nHope this helps!\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "dijkstra algorithm using Matlab\r\n                \r\nI am doing dijkstra algorithm using Matlab . Here is my code \n\n```\nW = [10 8 5 3 7 2 4 6 21];\nDG = sparse([1 1 1 2 2 3 4 5 6],[2 4 3 4 5 6 6 6 1],W)\n\nh = view(biograph(DG,[],'ShowWeights','on'))\n\n[dist,path,pred] = graphshortestpath(DG,1,6)\n\nset(h.Nodes(path),'Color',[1 0.4 0.4])\nedges = getedgesbynodeid(h,get(h.Nodes(path),'ID'));\nset(edges,'LineColor',[1 0 0])\nset(edges,'LineWidth',1.5)\n```\n\n\nThe problem is how do i get the red color lines nodes and edges of the shortest path \"reset\". for example I want it to be ```\n[dist,path,pred] = graphshortestpath(DG,2,3)```\n but the graph still shows the \n\n```\n[dist,path,pred] = graphshortestpath(DG,1,6). \n```\n\n    ", "Answer": "\r\nThis will do it:\n\n```\nset(h.edges, 'LineColor', [0.5 0.5 0.5])\nset(h.edges, 'LineWidth', 0.5)\nset(h.nodes, 'Color', [1 1 0.7])\n```\n\n\nYou can inspect all the other properties you can change by simply doing ```\nget(h)```\n.\n\nThere is also some good online info about setting properties of biograph objects:\n\nhttp://www.mathworks.com/help/toolbox/bioinfo/ref/setbiograph.html\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra Algorithm method returning empty path\r\n                \r\nI have attempted to implement Dijkstra's algorithm from the Pseudocode on the Wikipedia page. I have set a condition after the Queue is polled that tests if the current node is the target node, b. If so, then the Algorithm is to break and return the path from a to b.\n\nThis condition will always be satisfied as I know that all nodes within the range of the Adjacency Matrix do indeed exist. The program is to model the connections of the London Underground map.\n\nAnyway, I have been trying to figure this out for a while now, and thus far it eludes me. Maybe somebody can spot the issue. Oh, ```\nadj```\n is just the adjacency matrix for my graph.\n\n```\n    /**\n   Implementation of Dijkstra's Algorithm taken from \"Introduction to \n   Algorithms\" by Cormen, Leiserson, Rivest and Stein. Third edition.\n\n   d = Array of all distances.\n   pi = Previous vertices.\n   S = Set of vertices whose final shortest path weights have been\n   determined.\n   Q = Priority queue of vertices.\n**/\npublic ArrayList<Integer> dijkstra(Integer a, Integer b){\n    final double[] d = new double[adj.length];\n    int[] pi = new int[adj.length];\n    HashSet<Integer> S = new HashSet<Integer>();\n    PriorityQueue<Integer> Q = new PriorityQueue<Integer>(d.length, new Comparator<Integer>(){\n            public int compare(Integer a, Integer b){\n                Double dblA = d[a-1];\n                Double dblB = d[b-1];\n                return dblA.compareTo(dblB);\n            }\n        });\n\n    for(int i=0; i<d.length; i++){\n        d[i] = Double.POSITIVE_INFINITY;\n    }\n    d[a] = 0f;\n    for(int i=0; i<d.length; i++){\n        Q.add(i+1);\n    }\n\n    while(Q.size() > 0){\n        int u = Q.poll();\n        if(u == b){\n            System.out.println(\"jjd\");\n            ArrayList<Integer> path = new ArrayList<Integer>();\n            for(int i=pi.length-1; i>=0; i--){\n                path.add(pi[i]);\n            }\n            return path;\n        }\n        S.add(u);\n\n        if(d[u] == Double.POSITIVE_INFINITY){\n            break;\n        }\n\n        for(int v=0; v<adj.length; v++){\n            double tmp = d[u] + adj[u][v];\n            if(tmp < d[v]){\n                d[v] = tmp;\n                pi[v] = u;\n            }\n        }\n    }\n    return new ArrayList<Integer>();\n}\n```\n\n\n}\n\nEDIT:- After doing some debugging, it seems that the body of the while loop is being executed only once.\n    ", "Answer": "\r\n```\n    if(d[u] == Double.POSITIVE_INFINITY){\n        break;\n    }\n\n    for(int v=0; v<adj.length; v++){\n        double tmp = d[u] + adj[u][v];\n        if(tmp < d[v]){\n            d[v] = tmp;\n            pi[v] = u;\n        }\n    }\n```\n\n\nThe changing of the ```\nd```\n values in the loop body doesn't rearrange the priority queue, so unless the element that happened to be at the top of the queue after popping the initial node is one of its neighbours, you will have ```\nd[u] == Double.POSITIVE_INFINITY```\n in the next iteration and break then.\n\nIn Dijkstra's algorithm, it is important that the queue be updated when the distance of a node changes. ```\njava.util.PriorityQueue<E>```\n doesn't offer that functionality, so using that is non-trivial, I see no way to use it other than removing and re-adding the updated nodes on every update. That is of course not very efficient, since removal is ```\nO(size)```\n.\n\nThe inefficiency can be mitigated by not having all nodes in the queue. Star with adding only the initial node, and in the loop, insert only the neighbours not yet seen, remove and reinsert the neighbours that already are in the queue. That keeps the queue shorter, and makes removal cheaper on average.\n\nFor an efficient implementation, you would need a custom priority queue that allows faster (```\nO(log size)```\n?) update of priorities.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Java: Using a Fibonacci Heap for Implementing Dijkstra's Algorithm\r\n                \r\nNew here, but have been lurking as a guest for quite some time :)\n\nOkay, so I've been trying to do Dijkstra's shortest path algorithm using a Fibonacci heap (in Java). After some search, I managed to stumble across two ready-made implementations representing a Fibonacci heap. The first implementation is rather beautifully well done and can be found here. The second implementation, seemingly less elegant, is here. \n\nNow, this all looks nice and well. However, I want to use one of those implementations for my version of Dijkstra's algorithm but I have yet to have any luck with that. The implementation of Dijkstra's in use is as follows:\n\n```\npublic void dijkstra(Vertex source) {\n    {\n        source.minDistance = 0.;\n        PriorityQueue<Vertex> vertexQueue = new PriorityQueue<>();\n        vertexQueue.add(source);\n\n        while (!vertexQueue.isEmpty()) {\n            Vertex u = vertexQueue.poll();\n\n            // Visit each edge exiting u\n            for (Edge e : u.adjacencies) {\n                Vertex v = e.target;\n                double weight = e.weight;\n                double distanceThroughU = u.minDistance + weight;\n                if (distanceThroughU < v.minDistance) {\n                    vertexQueue.remove(v);\n                    v.minDistance = distanceThroughU;\n                    v.previous = u;\n                    vertexQueue.add(v);\n                }\n            }\n        }\n    }\n}\n```\n\n\nAs is clear, this implementation uses the Java-based PriorityQueue class (which I believe is based on a binary heap itself). I wish to modify the above code so it uses either of the aforementioned Fibonacci heap implementations instead of Java's PriorityQueue. \n\nI have tried a lot but I just can't figure out how to do it, although I'm sure it's as simple as replacing a few lines of code.\n\nI hope I'm clear enough. This is literally my first post on these boards.  \n\nAny help would be greatly appreciated.\n\nEDIT: In response to comments, I figured I would expand my post with one of my attempt scenarios. \n\nHere is a modified version of the above Dijkstra method using the second Fibonacci heap implementation linked earlier:\n\n```\npublic static void computePathsFibonacciHeap(Node source) {\n    {\n        source.minDistance = 0.;\n        FibonacciHeap myHeap = new FibonacciHeap();\n        myHeap.insert(source, source.minDistance);\n\n        while (!myHeap.isEmpty()) {\n            Node u = myHeap.min();\n\n            // Visit each edge exiting u\n            for (Edge e : u.adjacencies) {\n                Node v = e.target;\n                double weight = e.weight;\n                double distanceThroughU = u.minDistance + weight;\n                if (distanceThroughU < v.minDistance) {\n                    v.minDistance = distanceThroughU;\n                    myHeap.decreaseKey(v, v.minDistance);\n                    v.previous = u;\n                }\n            }\n        }\n    }\n}\n```\n\n\nThis is pretty much converted directly from pseudocode (thus it's entirely possible that I just didn't translate it right). The error I get says \"decreaseKey() got a larger value\". If I try to remove the minimum, I get a NullPointerException.\n\nI'm sure I'm doing something wrong, and I'd love to know what it is. Once again, this is using the second FHeap implementation. I would have preferred to do it using the first implementation (it just looks a lot more thorough/professional) but I unfortunately couldn't figure out how to. \n    ", "Answer": "\r\nIt seems you are missing to add all the nodes the your heap with Double.POSITIVE_INFINITY (except the source node with 0.0 distance). That's why you are having NullPointerExceptions, they are simply not in the heap.\n\nI made some test on several open-source Fibonacci Heap implementation. You can find the test itself here: Experimenting-with-dijkstras-algorithm. Also this is my Priority Queue version of the Dijsktra's algorithm: PriorityQueueDijkstra.java\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "C++ Dijkstra's algorithm program with initial vertices problem and resulting one less vertex\r\n                \r\nI'm working on C++ representation/implementation of Dijkstra's algorithm and I found this program online which fails to execute properly on TurboC++.\nAny one know the solution? I also want to know why there is a minimum value of 31999 and the coding runs on a mobile emulator but refuses to run on PC TurboC++\n\n```\n#include<iostream.h>\n#include<conio.h>\n#include<stdio.h>\n//using namespace std;\nint shortest(int, int);\nint cost[10][10], dist[20], i, j, n, k, m, S[20], v, totcost, path[20], p;\nint main()\n{\n    int c;\n    cout << \"enter no of vertices\";\n    cin >> n;\n    cout << \"enter no of edges\";\n    cin >> m;\n\n    cout << \"\\nenter\\nEDGE Cost\\n\";\n    for (k = 1; k <= m; k++)\n    {\n        cin >> i >> j >> c;\n        cost[i][j] = c;\n    }\n\n    for (i = 1; i <= n; i++)\n        for (j = 1; j <= n; j++)\n            if (cost[i][j] == 0)\n                cost[i][j] = 31999;\n\n    cout << \"enter initial vertex\";\n    cin >> v;\n    cout << v << \"\\n\";\n    shortest(v, n);\n}\n\nint shortest(int v, int n)\n{\n    int min;\n    for (i = 1; i <= n; i++)\n    {\n        S[i] = 0;\n        dist[i] = cost[v][i];\n    }\n    path[++p] = v;\n    S[v] = 1;\n    dist[v] = 0;\n    for (i = 2; i <= n - 1; i++)\n    {\n        k = -1;\n        min = 31999;\n        for (j = 1; j <= n; j++)\n        {\n            if (dist[j] < min && S[j] != 1)\n            {\n                min = dist[j];\n                k = j;\n            }\n        }\n\n        if (cost[v][k] <= dist[k])\n            p = 1;\n        path[++p] = k;\n\n        for (j = 1; j <= p; j++)\n            cout << path[j];\n        cout << \"\\n\";\n        //cout <<k;\n        S[k] = 1;\n        for (j = 1; j <= n; j++)\n            if (cost[k][j] != 31999 && dist[j] >= dist[k] + cost[k][j] && S[j] != 1)\n                dist[j] = dist[k] + cost[k][j];\n    }\n}\n```\n\n    ", "Answer": "\r\nArrays are 0 based so all the loops from 1 to <= n are suspect.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How can Dijkstra's algorithm apply to both undirected and directed algorithm in one program?\r\n                \r\nThe graph is represented in the format as below:\n\n```\nMAX 12\nNODE 1 1\nNODE 2 2 \nNODE 3 3\nNODE 4 4\nNODE 5 5\nNODE 6 6\nNODE 7 7\nNODE 9 9\nNODE 8 8\nNODE 10 10\nNODE 11 11\nNODE 12 12\nEDGE 1 2\nEDGE 2 3\nEDGE 3 4\nEDGE 4 5\nEDGE 5 6\nEDGE 6 7\nEDGE 7 8\nEDGE 8 9\nEDGE 9 10\nEDGE 10 11\nEDGE 11 12\nEDGE 1 12\nEDGE 1 3\nEDGE 1 4\nEDGE 1 6\nEDGE 1 8\nEDGE 1 11\nEDGE 1 10\nEDGE 6 10\nEDGE 3 6\nEDGE 4 6\nEDGE 5 7\nEDGE 9 11\n```\n\n\nI need to use the adjacent list to read in those edges. But if I want to use it as an undirected graph, that is , ignore all the directness of all edges. How could I know the connectivity of each pair of nodes? \n\nFor example, the shortest distance between (NODE 2, NODE 8) is 2 (2->1>8) in the undirected graph, but using the Dijkstra's algorithm to this graph gets 4 (2->3->6->7->8). How could I represent the undirected graph while still using the same technique to read in edges? \n    ", "Answer": "\r\nIf you really don't want to change the technique of reading in the edges you'd have to iterate over all the other nodes to see if your node is in their adjacency-list instead of the other way around.\n\nThis will increase your running time by quite a bit while not saving you much storage so I'd advise to just change the technique of reading in the edges.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra algorithm with min-priority queue\r\n                \r\nI'm trying to implement the dijkstra algorithm with priority queue, but I can't understand how  it works. I read many guide on the web but I can't understand this algorithm at all.\nMy questions are: What is the priority for each node? I think that it is the weight of the incoming edge with the minimum value, but I'm not sure. Is this true?\nSecond question, when I extract the root of the queue, how does it work if this node is not adjacency with no one of the visited nodes?\n    ", "Answer": "\r\nYou should use ```\npriority queue```\n where the ```\nvertex```\n with the shortest distance from the starting ```\nvertex```\n will get the highest priority. Initially, all ```\nvertices```\n will have the shortest distance of infinity and the starting ```\nvertex```\n will have the shortest distance 0. \n\nStart by inserting of all ```\nvertices```\n (with its ```\nedges```\n) from the graph inside the ```\nPQ```\n. Remove ```\nvertex```\n from the ```\nPQ```\n and explore all its ```\nedges```\n. Compare the shortest distances with all adjacent ```\nvertices```\n and if any distance is less than the shortest distance on the current ```\nvertex```\n, update adjacent ```\nvertex```\n shortest distance inside the ```\nPQ```\n. Continue while ```\nPQ```\n is not empty. ```\nVertices```\n which got no ```\nedges```\n will finish with the shortest distance of infinity because it is not possible 'get to them' from the starting  ```\nvertex```\n. However, they will be still removed from the ```\nPQ```\n.\n\nPseudocode\n\n```\ninitialize graph\ninitialize pq\npq.insertAll(graph.getVertices())\n\nwhile (pq is not empty) {\n  vertex = pq.remove()\n  edges = vertex.getEdges()\n\n  for all edges {\n    destination = edge.getDestination()\n    newDistance = edge.getLength() + vertex.getDistance()\n    if (newDistance < destination.getDistance()) {\n      destination.setShortestDistance(newDistance)\n      pq.update(destination)\n    }\n  }\n}\n```\n\n\nMIT OpenCourseWare Links:\nPath problems overview\nDijkstra\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Logical error in my implementation of Dijkstra's algorithm\r\n                \r\nI've been working on Dijkstra's algorithm for quite some time, trying to figure out the shortest distance between to vertices by using an adjacency matrix. It seems that most of the algorithm works fine, but I get some problem when it's time to move on tho the next vertex. Here's my code:\n\n```\n/*Declarations and initialization*/\nint* result;\nint dist[this->nr_airport];\nint unvisited[this->nr_airport];\nint cur_vertex = source;\nint check_dist = 0;\nbool check_val_found = false;\nfor(int i=0 ; i<this->nr_airport ; i++)\n{\n     dist[i] = -1;      //-1 represents infinity\n     unvisited[i] = i;  //the set of all unvisited nodes\n}\ndist[source] = 0;\n\n/*Determining distances*/\nfor(int i=0 ; i<this->nr_airport ; i++)\n{\n    if(unvisited[i]!=-1 && this->matrix[cur_vertex][i]>0)   //Check if node is unvisited and neighbour to cur_vertex\n    {\n        if(dist[i]>=dist[cur_vertex]+this->matrix[cur_vertex][i] || dist[i]==-1)    //Check distance\n        {\n            dist[i] = dist[cur_vertex]+this->matrix[cur_vertex][i]; //Assign new distance\n        }\n    }\n}\n\n/*Setting the new vertex*/\nfor(int i=0 ; i<this->nr_airport ; i++)\n{\n    if(this->matrix[cur_vertex][i]>0 && unvisited[i]!=-1 && dist[i]>0)\n    {\n        if(!check_val_found)\n        {\n            check_dist = dist[i];\n            cur_vertex = i;\n            check_val_found = true;\n        }\n        if(dist[i]<check_dist)\n        {\n            check_dist = dist[i];\n            cur_vertex = i;\n        }\n    }\n}\n```\n\n\nFirstly I loop through the matrix to determine the shortest distances of the current vertex' neighbors and assign that value to dist[]. I do this if the vertex is unvisited (unvisited[]!=-1) and if the matrix value indicates that it's a neighbor.\n\nThen, to check which vertex is next, I loop through all the vertices and check their distance from the start node, which is held by dist[]. If a vertex is already visited (unvisited[]==-1) or if the vertex is the current vertex or not a neighbor to the current vertex (this->matrix[][]==0 or this->matrix[][]==-1), then it won't check since that vertex can't be the next one to examine.\n\nSomething goes wrong here, because when I run the program, it seems that firstly, it doesn't check with all the vertices it should, and secondly, it checks with some vertices it shouldn't; i've had the problem that I go from one vertex to another vertex which is in fact not a neighbor of the current vertex. I have checked the matrix, and it's correct.\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Exception in thread \"main\" java.lang.StackOverflowError after running Dijkstra's algorithm in an adjacency matrix\r\n                \r\nI am trying to print the shortest path after running Dijkstra's algorithm in a weighted adjacency matrix. I am getting a stackoverflow error when trying to printout the path.  \n\nI have tried changing the start node into a type long and BigInteger as advised by previous answers on this platform also I am aware that I am using a recursive method whereby that problem lies.\n\n```\nimport java.util.*;\n\npublic class djikstra {\n\nprivate static final int invalid = -1;\n\npublic djikstra(int matrix[][],int start) {\n\n    int numVertices = matrix[0].length;\n    int [] distances = new int [numVertices];\n    boolean [] isAdded = new boolean[numVertices];\n\n    for (int i=0;i<numVertices;i++) {\n        distances[i]= Integer.MAX_VALUE;\n        isAdded[i] = false;\n    }\n\n    distances[(int) start]=0;\n    int [] parents = new int [numVertices];\n    parents[start] = invalid;\n\n    for(int i=1;i<numVertices;i++) {\n        int closestNeighbour = -1;\n        int shortDist = Integer.MAX_VALUE;\n\n    for(int j=0; j <numVertices;j++) {\n        if(!isAdded[j] && distances[j]<shortDist) {\n            closestNeighbour = j;\n            shortDist = distances[j];\n        }\n    }\n    isAdded[closestNeighbour]=true;\n\n    for(int j = 0; j <numVertices;j++) {\n        int edgeDist = matrix[closestNeighbour][j];\n        if(edgeDist > 0 && ((closestNeighbour+edgeDist)<distances[j])) {\n            parents[j] = closestNeighbour;\n            distances[j] = shortDist + edgeDist;\n        }\n    }\n}\n    printSol(start,distances,parents);\n }\n\nprivate static void printSol(int start,int[] distances,int[] parents) {\n    int numVertices=distances.length;\n    for(int i=0;i<numVertices;i++) {\n        if(i !=start) {\n            path(i,parents);\n        }\n }\n}\n\nprivate static void path(int curr,int[]parents) {\n    if(curr== -1) {\n        return;\n    }\n\n    path(parents[curr],parents);\n\n}\n}\n\npublic static void Main(String args[]){\n       int matrix2[][]= {{0, 0, 0, 4, 12, 14, 0, 0, 0, 0, 0 ,0, 0, 0}, \n           {0, 0, 0, 0, 0, 0, 0, 12, 0, 8, 0, 18, 15, 7},\n           {0, 0, 0, 11, 3, 3, 0, 0, 0, 0, 0, 13, 8, 10}, \n           {4, 0, 0, 0, 10, 12, 0, 0, 0, 0, 10, 10, 13, 0}, \n           {0, 0, 3, 10, 0, 2, 0, 0, 0, 0, 0, 10, 5, 11}, \n           {0, 0, 3, 12, 2, 0, 0, 0, 0, 0, 0, 10, 5, 9 },\n           {20, 0, 0, 0, 0, 0, 0, 14, 10, 20, 16, 22, 0, 0}, \n           {0, 12, 0, 0, 0 ,0 ,14, 0, 4, 6, 12, 0,0, 0 },\n           {0, 16, 0, 0, 0, 0, 10, 4, 0, 10, 14, 20, 0, 0}, \n           {0, 8, 0, 0, 0, 0, 0, 6, 10, 0, 18, 0, 0, 15 },\n           {0, 0, 0, 10, 0, 0, 0, 12, 0, 0, 0, 6, 11, 11}, \n           {0, 0, 0, 10, 10, 10, 0, 0, 0, 0, 6, 0, 5, 11}, \n           {0, 0, 8, 0, 5, 5, 0, 0, 0, 0, 11, 5, 0, 8}, \n           {0, 7, 10, 0, 11, 9, 0, 0, 0, 0, 0, 11, 8, 0}};\n\n    djikstra doDjikstra = new djikstra(matrix2,0);\n}   \n\n\n\nExpected results:\n0 4 13 1\nActual results:\nException in thread \"main\" java.lang.StackOverflowError\nat helperclasses.djikstra.path(djikstra.java:61)\n```\n\n    ", "Answer": "\r\nThe ```\nStackOverflowError```\n is triggered by an infinite recursion in the ```\npath```\n method.\n```\nparents[curr]```\n never holds -1 (the base case), therefore the recursion never stops.\nYou will need to ensure that ```\npath```\n is called with -1 for ```\ncurr```\n eventually.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Strategy to build test graphs for Dijkstra's algorithm?\r\n                \r\nI recently implemented Dijkstra's algorithm to practice Java. I'm now considering how to build random test graphs (with unidirectional edges).\n\nCurrently, I use a naive method. Nodes are created at random locations in 2d space (where x and y are unsigned integers between 0 and some MAX_SPACE constant). Edges are randomly created to connect the nodes, so that each node has an outdegree of at least 1 (and at most MAX_DEGREE). Indegree is not enforced. Then I search for a path between the first and last Nodes in the set, which may or may not be connected.\n\nIn a more realistic situation, nodes would have a probability of being connected proportional to their proximity in 2d space. What is a good strategy to build random test graphs with that property?\n\nNOTES\n\nI will primarily use this to build graphs that can be drawn and verified by hand, but scaling to larger graphs is a consideration.\n\nThe strategy should be easily modified to support the following constants (and maybe others -- let me know if you think of any interesting ones):\n\n\nMIN_NODES, MAX_NODES: a range of sizes for the graph\nCONNECTEDNESS: average out-degree\nPROXIMITY: weight given to preferring to connect proximal nodes\n\n    ", "Answer": "\r\nYou could start by looking at the different random graph generators available in JUNG (Java library):\n\n\nBarabasi Albert Generator - Simple evolving scale-free random graph generator. At each time step, a new vertex is created and is connected to existing vertices according to the principle of \"preferential attachment\", whereby vertices with higher degree have a higher probability of being selected for attachment.\nEppstein Power Law Generator - Graph generator that generates undirected graphs with power-law degree distributions.\n\n\nThere are various other generators available to - See Listing Here\n\nFor python there is the NetworkX library that also provides many graph generators - Listed Here\n\nWith many of these generators you can specify the size, so you can start small and go from there.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Shortest Path with Dijkstra’s Algorithm from a dataframe\r\n                \r\nI am trying to find shortest path between graph nodes using Dijkstra's Algorithm, by using the code enclosed in the following article:\nhttps://www.r-bloggers.com/2020/10/finding-the-shortest-path-with-dijkstras-algorithm/\nBut this code creates the graph from an edgelist. Instead I would like to create the graph from a dataframe like this:\n```\nactors <- data.frame(name=c(\"Alice\", \"Bob\", \"Cecil\", \"David\",\n                            \"Esmeralda\"))\nrelations <- data.frame(from=c(\"Bob\", \"Cecil\", \"Cecil\", \"David\",\n                               \"David\", \"Esmeralda\"),\n                        to=c(\"Alice\", \"Bob\", \"Alice\", \"Alice\", \"Bob\", \"Alice\"),\n                        weights=c(4,5,5,2,1,1))\ng <- graph_from_data_frame(relations, directed=TRUE, vertices=actors)\n```\n\nHow could I modify the code of the article in such a way the code works on a graph defined starting from a dataframe (and not from an edgelist)?\nI know there are features of the igraph package that would be able to calculate shortest paths, but I would like to try to write some code outside the package.\nThank you!\nEdit\nThese are my dataframes:\n```\n>dput(relations)\nstructure(list(From = c(\"France\", \"Italy\", \"Malta\", \"Spain\", \n\"Germany\", \"Austria\", \"Luxembourg\", \"Luxembourg\", \"Luxembourg\", \n\"Greece\", \"Slovakia\", \"Belgium\", \"Luxembourg\", \"Estonia\", \"Germany\", \n\"Netherlands\", \"Netherlands\", \"Cyprus\", \"Greece\", \"Lithuania\", \n\"Estonia\", \"Greece\", \"Lithuania\", \"Slovakia\", \"Netherlands\", \n\"Luxembourg\", \"Estonia\", \"Malta\", \"Belgium\", \"Cyprus\", \"Austria\", \n\"Estonia\", \"Austria\", \"Germany\", \"Austria\", \"Netherlands\", \"Portugal\", \n\"Portugal\", \"Estonia\", \"Italy\", \"Spain\", \"Finland\", \"Belgium\", \n\"Spain\", \"Estonia\", \"Latvia\", \"Luxembourg\", \"Luxembourg\", \"Netherlands\", \n\"Italy\", \"Lithuania\", \"Cyprus\", \"Ireland\", \"Luxembourg\", \"Ireland\", \n\"Spain\", \"Belgium\", \"Latvia\", \"Netherlands\", \"Italy\", \"Slovenia\", \n\"Netherlands\", \"Greece\", \"Spain\", \"Austria\", \"Finland\", \"Malta\", \n\"Spain\", \"Austria\", \"Lithuania\", \"France\", \"Portugal\", \"Cyprus\", \n\"Finland\", \"Spain\", \"Spain\", \"Belgium\", \"Germany\", \"Germany\", \n\"Greece\", \"Netherlands\", \"Luxembourg\", \"Estonia\", \"Ireland\", \n\"Italy\", \"Portugal\", \"Greece\", \"Estonia\", \"Belgium\", \"Germany\", \n\"Slovenia\", \"Slovakia\", \"Lithuania\", \"Slovenia\", \"Portugal\", \n\"Portugal\", \"Slovakia\", \"France\", \"Portugal\", \"Netherlands\"), \n    To = c(\"Slovakia\", \"Germany\", \"Portugal\", \"Austria\", \"Latvia\", \n    \"Cyprus\", \"Portugal\", \"Greece\", \"Italy\", \"Slovenia\", \"Ireland\", \n    \"Malta\", \"Ireland\", \"Germany\", \"Cyprus\", \"Portugal\", \"Slovenia\", \n    \"Italy\", \"Luxembourg\", \"France\", \"Slovakia\", \"Netherlands\", \n    \"Greece\", \"France\", \"Ireland\", \"Netherlands\", \"Cyprus\", \"Germany\", \n    \"Portugal\", \"Austria\", \"Luxembourg\", \"Austria\", \"Spain\", \n    \"Netherlands\", \"Belgium\", \"Cyprus\", \"Cyprus\", \"Luxembourg\", \n    \"Finland\", \"Belgium\", \"Lithuania\", \"Austria\", \"Spain\", \"Slovenia\", \n    \"Luxembourg\", \"Finland\", \"Slovenia\", \"Germany\", \"Austria\", \n    \"Slovenia\", \"Slovenia\", \"Portugal\", \"Finland\", \"Lithuania\", \n    \"Latvia\", \"France\", \"Netherlands\", \"Cyprus\", \"Spain\", \"Malta\", \n    \"France\", \"Finland\", \"Belgium\", \"Latvia\", \"Slovenia\", \"Slovenia\", \n    \"Cyprus\", \"Slovakia\", \"Slovakia\", \"Latvia\", \"Austria\", \"Ireland\", \n    \"Luxembourg\", \"Belgium\", \"Italy\", \"Estonia\", \"Greece\", \"Slovakia\", \n    \"Belgium\", \"Italy\", \"Latvia\", \"Malta\", \"Greece\", \"France\", \n    \"Greece\", \"Netherlands\", \"France\", \"Slovenia\", \"Latvia\", \n    \"Finland\", \"Austria\", \"Slovenia\", \"Belgium\", \"Cyprus\", \"Greece\", \n    \"Slovenia\", \"Cyprus\", \"Finland\", \"Malta\", \"Germany\"), `1995` = c(274959716, \n    42345007970, 52361033, 784003104, 363593773, 26339142, 70240364.9716237, \n    66160839.8751728, 570402199.020507, 48087089, 7213761, 51841984.7433951, \n    17654753.3588222, 172147969, 510653861, 1490942352, 236034017, \n    21599848, 8237002.21796104, 78753113, 1785782, 317673116, \n    1997651, 191502494, 1085060805, 397894640.417207, 3278854, \n    311533699, 1120849630.02838, 16319437, 83172852.11371, 7429991, \n    1130916439, 37969299820, 893625108.88629, 85666548, 20013832, \n    34463454.0875298, 391203046, 6317180664.31942, 19705368, \n    392268361, 4455785372.87273, 222358956, 411505.596673383, \n    52421883, 15725678.4821813, 1822047157.86885, 2459346931, \n    1876562166, 808113, 1124090, 266044676, 2248412.10389544, \n    7378082, 18441136707, 20732500726.5828, 2916590, 4946996508, \n    1165517054, 737293168, 1253219429, 234340068.782039, 10770159, \n    966929910, 40043392, 1231347, 76204779, 564056237, 152914849, \n    3269662990, 108614454, 2313081.15506869, 1189550231.54615, \n    8097112911, 15174304, 877483944.124827, 2135381409, 28188202490.5877, \n    1524668022, 84865417, 1965397.25660491, 1384674, 3699841535, \n    4383865473, 1233064242, 664865392, 183091, 42970685.557638, \n    4742184966, 550250520, 102947427, 49519226.4265594, 5273729, \n    105863344, 5888705, 10907803, 1170153350, 20869834, 43104477514\n    )), row.names = c(NA, -100L), class = c(\"tbl_df\", \"tbl\", \n\"data.frame\"))\n```\n\nand\n```\n> dput(actors)\nc(\"Slovakia\", \"Germany\", \"Portugal\", \"Austria\", \"Latvia\", \"Cyprus\", \n\"Greece\", \"Italy\", \"Slovenia\", \"Ireland\", \"Malta\", \"Luxembourg\", \n\"France\", \"Netherlands\", \"Spain\", \"Belgium\", \"Finland\", \"Lithuania\", \n\"Estonia\")\n```\n\n    ", "Answer": "\r\nPerhaps you can try this\n```\ngraph_from_data_frame(relations, vertices = data.frame(name = actors))\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm Modified - Iterating on Edges?\r\n                \r\nI have been considering a modification to the Dijkstra algorithm that would negate the need for a relaxation step. Can I get people's opinions or a reason why this would not work? My implementation centers around a priority queue of edges rather than nodes. Here is a description of my implementation:\nWe have a directed ```\nGraph```\n class with ```\nNode```\n, and ```\nEdge```\n subclasses.\n```\nEdges```\n have a \"weight\", a \"start\" node, and an \"end\" node.\n```\nNodes```\n have a \"dist\" value (updated with the optimal distance to reach them),\nas well as a \"bestPath\" value (updated with the optimal path to reach them),\nand finally an \"edges\" list.\n```\nDikstra (Node origin, Node goal):\n    Set settledNodes = {}\n    origin.dist = 0\n    settledNodes.add(origin)\n\n    Comparator<Edge, Edge> comparator = (edge1, edge2) -> \n        compareDoubles(edge1.weight + edge1.start.dist, edge2.weight + edge2.start.dist)\n\n    PriorityQueue<Edge> queue = new PriorityQueue<>(comparator)\n    queue.addAll(origin.edges)\n\n    while (!queue.Empty || settledNodes.size < Graph.size):\n        currEdge = queue.pop()\n\n        if (!settledNodes.contains(currEdge.end)):\n            currEdge.end.bestPath = currEdge\n\n            if (currEdge.end == goal):\n               return\n\n            currEdge.end.dist = currEdge.weight + currEdge.start.dist\n            queue.add(currEdge.end.edges)\n            settledNodes.add(currEdge.end)\n\n```\n\nOnce the algorithm finishes, each node will have its \"bestPath\" field populated, containing the optimal edge to follow to reach that node. These edges can be back-traced in order to recreate the entire path.\nI realize that my pseudocode is an unholy amalgamation of python and java - Sorry for that.\nThe approach here centers around iterating over a priority-queue of edges rather than a list/priority queue of nodes. What do people think? As far as I can tell it is still optimal,  and it seems to me like this algorithm is better in some ways. For instance, it does not necessarily iterate over all the edges of a node it encounters (unlike Dijkstra). It ignores long edges by throwing them to the bottom of the priority queue, and it may find an optimal route without ever processing such nodes, thus saving a few (or many!) iterations.\nI am pretty excited about this algorithm, but I can't find anything like this anywhere online, which makes me think there is some deep flaw that I am overlooking. I would love to hear feedback from people.\n    ", "Answer": "\r\nYou're suggesting running Dijkstra's on the line graph. I believe this would work; however note that the asymptotic running time of Dijkstra's is O((|E| + |V|) log|V|).  By using the line graph, you're essentially swapping E and V there, making the running time worse.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How to go about implementing a parallelized Dijkstra's algorithm using OpenMP/MPI\r\n                \r\nI'm trying to implement a parallelized version of Dijkstra's algorithm (my very first parallel algorithm) for a course project. I got the sequential part down using a priority queue with no problem, but I'm having trouble figuring out how to go about designing a parallel version. I've been using this as a reference so far. I'm not asking anyone to design the whole thing for me, just offer me some insights or good advice about how to go about the implementation. I've been considering these things so far:\n\n\nOpenMP, MPI or both?\nPCAM? (e.g. graph partitioning)\nShared memory?\n\n    ", "Answer": "\r\nTry this presentation for ideas:\n\nhttp://www.cse.buffalo.edu/faculty/miller/Courses/CSE633/Ye-Fall-2012-CSE633.pdf\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Why this Dijkstra algorithm is working without using min heap?\r\n                \r\nI implemented Dijkstra's algorithm using only a FIFO queue, still it passes all test cases in GFG. When will this code fail or if it works then why do we need to use a min heap?\n```\nvector <int> dijkstra(int V, vector<vector<int>> adj[], int S)\n    {\n        // adj [] = {{{1, 9}}, {{0, 9}}}\n\n        vector<int> dist(V, INT_MAX);\n        queue<pair<int, int>> pq;\n        pq.push({0, S});\n        while(!pq.empty()) {\n            auto f = pq.front();\n            pq.pop();\n            int node = f.second;\n            int d = f.first;\n            if (d < dist[node]) \n            {\n                dist[node] = d;\n                for(auto i: adj[node]) {\n                    pq.push({d + i[1], i[0]});\n                }\n            }\n        }\n        return dist;\n    }\n```\n\n    ", "Answer": "\r\nUsing a FIFO instead of a min-heap will still give you the correct answer, but the time that your program will take to find that answer will be longer.\nTo be noticeable, you would need to provide a large graph as input.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How to overcome segmentation fault while implementing dijkstra's algorithm?\r\n                \r\nI am making a ros node to implement dijkstra's algorithm on a 1000x1000 pixel map. \n\nThe map is in the form of a row dominant matrix and I have declared visited, distance and prev in the same form. Distance stores the distance of each index and is initially declared with a huge number. visited is a bool array storing whether that index has been visited or not. prev stores the shortest path followed.\n\nstruct node is initialised to make a priority queue storing node and distance in increasing order.\n\nvoid dijkstra is the function that does the heavy loading in this program. Using gdb, it seems that segmentation fault occurs in this function, however I can not trace it any further. \n\nSo, I need help in making sense of this runtime error and any bad practices I may have followed.  \n\n```\n#include <ros/ros.h>\n#include <math.h>\n#include <queue>\n#include <vector>\n#include <std_msgs/String.h>\n#include <geometry_msgs/Pose.h>\n#include <geometry_msgs/PoseArray.h>\n#include <nav_msgs/OccupancyGrid.h>\n#define FMAX 999999999.99\n\n\n    int rows = 1000, columns = 1000, size = rows * columns;\n    bool visited[1000000];\n    float distance[1000000];\n    int prev[1000000];\n    int source = 15100, destination = 990500; // Random source and destination\n    int dr[] = {1, -1, 0, 0, 1, 1, -1, -1}; // Direction vectors\n    int dc[] = {0, 0, 1, -1, 1, -1, 1, -1};\n    struct node\n    {\n        int index;\n        float dist;\n        node(int index, float dist)\n            : index(index), dist(dist)\n        {\n        } \n    };\n    struct compareDist\n    {\n        bool operator()(node const& n1, node const& n2)\n        {\n            return n1.dist > n2.dist;\n        }\n    };\n\n    // Priority queue\n    std::priority_queue <node, std::vector<node>, compareDist> pq;\n\n    int index(int r, int c)\n    {\n        return (r * 1000) + c;\n    }\n\n    void init()\n    {\n        for(int i = 0; i < size; i++)\n        {\n            distance[i] = FMAX;\n            visited[i] = false;\n            prev[i] = 9999999;\n        }   \n    }\n\n    float dist_(int index1, int index2)\n    {\n        int r1, c1, r2, c2;\n        r1 = index1 / columns; r2 = index2 / columns;\n        c1 = index1 - (r1 * 1000); c2 = index2 - (r2 * 1000);\n        return sqrt(pow(r1 - r2, 2) + pow(c1 - c2, 2));\n    }\n\n    void dijkstra(const nav_msgs::OccupancyGrid& map)\n    {\n        prev[source] = 0;\n        node first = {source, 0.0}; \n        pq.push(first);\n        while(!pq.empty())\n        {\n\n            node temp = pq.top();\n            pq.pop();\n            int nodeIndex = temp.index;\n            float nodeDist = temp.dist;\n\n            visited[nodeIndex] = true;\n            int r = nodeIndex / columns;\n            int c = nodeIndex - (r * columns);\n            int rr, cc;\n            for(int i = 0; i < 8; i++) // to calculate neighbours\n            {\n                rr = r + dr[i];\n                cc = c + dc[i];\n\n                if(map.data[index(rr, cc)] == 100)\n                    visited[index(rr, cc)] = true; // Marking blocked paths as visited\n\n                if(rr < 0 || rr >= 1000 || cc < 0 || cc >= 1000 || visited[index(rr, cc)] == true)\n                    continue;\n\n\n                else\n                {\n                    node neighbour(index(rr, cc), dist_(nodeIndex, index(rr, cc)));\n                    float alt = nodeDist + neighbour.dist;\n                    if(alt < distance[index(rr, cc)])\n                    {\n                        visited[index(rr, cc)] = true;\n                        distance[index(rr, cc)] = alt;\n                        prev[index(rr, cc)] = nodeIndex;\n                        node next(index(rr, cc), alt);\n\n                        pq.push(next);\n                    }\n                    if(visited[destination] == true)\n                        break;\n                }\n            }\n            if(visited[destination] == true)\n                break;\n        }\n        std::vector <int> path;\n        // prev contains the path. Trace it back to get the path.\n        path.push_back(destination);\n        while(true)\n        {\n            path.push_back(prev[path.back()]);\n            if(path.back() == 0)\n                break;\n        }\n\n        geometry_msgs::PoseArray poseArray;\n        poseArray.header.frame_id = \"map\"; // or other frame you wish to publish relative to.\n        std::vector<geometry_msgs::Pose> pose_vector;\n        // push or insert to your vector\n        for(int i = 0; i < path.size(); i++)\n        {\n            geometry_msgs::Pose p;\n            p.position.x = path.back();\n            pose_vector.push_back(p);\n        }\n        poseArray.poses = pose_vector;\n        ros::NodeHandle n(\"~\");\n        ros::Publisher pose_array_pub = n.advertise<geometry_msgs::PoseArray>(\"/poseArray\", 1);\n        pose_array_pub.publish(poseArray);\n\n    }\n\n\n\n    int main(int argc, char **argv)\n    {\n        ros::init(argc, argv, \"dijkstra\");\n        ros::NodeHandle n(\"~\");\n        ros::Subscriber sub = n.subscribe(\"/map\", 1000, dijkstra);\n\n        init();\n        distance[source] = 0;\n        visited[source] = true;\n        ros::spin();    \n    }\n```\n\n    ", "Answer": "\r\nCompile your code with debugging symbols and then run it in the debugger.\nThis will should you exactly where the error occurs and allow you to examine the state of the program at the point of the crash.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Is connected graph a requirement for Dijkstra algorithm?\r\n                \r\nApart from the graph having non-negative weights, does Dijkstra algorithm require connectedness? E.g. Would dijkstra algorithm work for a graph that is disconnected, where 3 vertices are connected in a component and 2 other vertices are in another component?\n    ", "Answer": "\r\nHere is Dijkstra's algorithm from Wikipedia:\n\n\nMark all nodes unvisited. Create a set of all the unvisited nodes called the unvisited set.\nAssign to every node a tentative distance value: set it to zero for our initial node and to infinity for all other nodes. During the run of the algorithm, the tentative distance of a node v is the length of the shortest path discovered so far between the node v and the starting node. Since initially no path is known to any other vertex than the source itself (which is a path of length zero), all other tentative distances are initially set to infinity. Set the initial node as current.[15]\nFor the current node, consider all of its unvisited neighbors and calculate their tentative distances through the current node. Compare the newly calculated tentative distance to the one currently assigned to the neighbor and assign it the smaller one. For example, if the current node A is marked with a distance of 6, and the edge connecting it with a neighbor B has length 2, then the distance to B through A will be 6 + 2 = 8. If B was previously marked with a distance greater than 8 then change it to 8. Otherwise, the current value will be kept.\nWhen we are done considering all of the unvisited neighbors of the current node, mark the current node as visited and remove it from the unvisited set. A visited node will never be checked again (this is valid and optimal in connection with the behavior in step 6.: that the next nodes to visit will always be in the order of 'smallest distance from initial node first' so any visits after would have a greater distance).\nIf the destination node has been marked visited (when planning a route between two specific nodes) or if the smallest tentative distance among the nodes in the unvisited set is infinity (when planning a complete traversal; occurs when there is no connection between the initial node and remaining unvisited nodes), then stop. The algorithm has finished.\nOtherwise, select the unvisited node that is marked with the smallest tentative distance, set it as the new current node, and go back to step 3.\n\n\nNote the part I emphasized. Laid out this way, if there is no path between the initial node and the destination node, the algorithm still stops once all nodes in the component of the initial node are visited.\nSo no, the graph being connected is not a requirement. The algorithm will tell you whether the path exists.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Can we add a turning penalty in Dijkstra's algorithm\r\n                \r\nI am trying to code Dijkstra algorithm to find the shortest paths between nodes of some electrical cable trays (given as directed graph). My question is; if we have turns (i.e. not a straight path as the company wish to have) how we can handle this problem ?\n    ", "Answer": "\r\nDijkstra cannot incorporate a turn-penalty directly, since it is built around the assumption that the cost to reach a node is independent of its \"context\".\n\nIt is possible to rewrite your graph so that every turn is associated with taking an edge, so turn costs become normal costs. Dijkstra can then be applied to that graph. A full explanation can be found in \"Modeling Costs of Turns in Route Planning\" (Stephan Winter). The graph used for this (line graph) is sometimes called the dual graph, though that term traditionally had a different meaning. Roughly, you introduce a node for every original edge, and an edge between two of the new nodes if the corresponding edges are both adjacent to the same original node (every tiny path of 2 steps is represented by an edge in the new graph). All edges leading out of the source and into the target correspond to separate nodes in the new graph, to avoid turning the problem into multi-source/multi-target shortest path, you may add an additional source node and target node that \"tie the edges together\" (with zero cost).\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Implementing Dijkstra's algorithm in Python but a Key Error is received when using a different graph\r\n                \r\nI'm a university student and we were tasked to implement Dijkstra's algorithm on the given graph below.\nGraph to implement Dijkstra's algorithm on\nWe were given a code to use and/or modify and help answer the question given.\n```\nimport heapq\nimport math\n\ndef dijkstra(G, S):\n    pq = []\n    entry_finder = {}\n    costs = {}\n    pred = {S: None}\n    REMOVED = 'removed'\n\n    def add_entry(label, priority):\n        if label in entry_finder:\n            remove_entry(label)\n        entry = [priority, label]\n        entry_finder[label] = entry\n        heapq.heappush(pq, entry)\n\n    def remove_entry(label):\n        entry = entry_finder.pop(label)\n        entry[-1] = REMOVED\n\n    def pop_entry():\n        while pq:\n            priority, label = heapq.heappop(pq)\n            if label != REMOVED:\n                del entry_finder[label]\n                return priority, label\n        return None, None\n\n    for v in G:\n        if v == S:\n            add_entry(S, 0)\n        else:\n            add_entry(v, math.inf)\n    while pq:\n        d_u, u = pop_entry()\n        if u is not None and u != REMOVED:\n            costs[u] = d_u\n            for e in G[u]:\n                v, w = e\n                entry_v = entry_finder[v]\n                d_v = entry_v[0]\n                if d_v > d_u + w:\n                    add_entry(v, d_u + w)\n                    pred[v] = u\nreturn costs, pred\n```\n\nThis code was shown to work for a separate graph that was used in an example from our lectures. The graph was converted into code as such.\n```\nG = {\n    '0': [('1', 2), ('2', 6), ('3', 7)],\n    '1': [('3', 3), ('4', 6)],\n    '2': [('4', 1)],\n    '3': [('4', 5)],\n    '4': []\n}\n\ncosts, pred = dijkstra(G, '0')\nprint(costs, pred)\n```\n\nSo I know for a fact that the given code works. The problem arose when I tried to implement the graph into code and it gave me a KeyError: 'D'. My implementation of the graph is as follows.\n```\nG = {\n    'A': [('B', 56), ('C', 96), ('D', 78)],\n    'B': [('D', 18), ('F', 208), ('E', 110)],\n    'C': [('D', 20), ('F', 90)],\n    'D': [('F', 112)],\n    'E': [('F', 16), ('G', 46), ('I', 108)],\n    'F': [('G', 20), ('H', 62)],\n    'G': [('H', 40)],\n    'H': [('I', 29), ('J', 56)],\n    'I': [('J', 21)],\n    'J': []\n}\ncosts, pred = dijkstra(G, 'A')\nprint(costs, pred)\n```\n\nThe error also comes with:\nline 41, in dijkstra\nentry_v = entry_finder[v]. I'd like to know if the error came from my wrong implementation of the graph or if the given sample code itself had errors.\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Is Dijkstra algorithm faster than DFS?\r\n                \r\nMaybe it is a silly question, but I have been using Dijkstra algorithm for some implementations related with graphs. Now I have to implement a script in which I need to find distances between nodes. Whick one would be a better option, using a Dijkstra algorithm with weights equal to one or implementing the DFS?\n    ", "Answer": "\r\nDijkstra's algorithm with all weights equal is exactly equivalent to BFS (not DFS). DFS isn't appropriate for finding shortest paths, since it explores longest paths first, but BFS is.\nIf you know in advance that all weights are equal, there's no sense in using a priority queue and implementing full Dijkstra's; you can use a plain queue and get BFS with less code and slightly less overhead.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Neo4j - Dijkstra Algorithm with weights shown in path results\r\n                \r\nSo far I am getting all paths from Dijkstra's Algorithm as shown below:\n\n```\n        for(Node node_a: GlobalGraphOperations.at(graphDB).getAllNodes()){\n            for(Node node_b: GlobalGraphOperations.at(graphDB).getAllNodes()){\n                if(node_a.getId() != node_b.getId()){\n                    Iterator<WeightedPath> paths = dijkstra.findAllPaths(node_a, node_b ).iterator();\n\n                    while (paths.hasNext()){\n                        WeightedPath path = paths.next();\n                        Iterable<Relationship> relationships = path.relationships();\n                        String pathString = \"\";\n                        for(Node node :path.nodes()){\n                            pathString +=  node.getProperty(\"company_name\") + \" ->\";\n\n                        }\n\n                        System.out.println(pathString);\n                        System.out.println(path);\n                    }\n                }\n\n            }\n\n        }\n```\n\n\nHowever I want to get the independent lengths of each relationship. For example, I have a path as follows:\n\n```\n(3)--[PROGRESSED_TO,3800]-->(7)--[PROGRESSED_TO,4350]-->(894) weight:0.088345867\n3Com ->Nortel ->Bay Networks\n```\n\n\nBut I want to also, be able to see  ```\n3Com -(length:24)->Nortel -(length:10)->Bay Networks```\n\n\nIs there any way to do this?\n    ", "Answer": "\r\nYou can also iterate over the path's relationships:\n\n```\nfor(Relationship rel :path.relationships()){\n  pathString +=  \"(length:\" + rel.getProperty(\"length\") + \")\";\n}\n```\n\n\nor over all elements\n\n```\nfor(PropertyContainer pc :path){\n  ... pc.getProperty(\"foobar\")...\n}\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm finding the shortest distance between two vertices c++\r\n                \r\nI've been working on a program to get some basic knowledge on how path-finding works and decided to use Dijkstra's Algorithm to find the shortest distance between two points of a 2D array which the user chooses. I have used a Graph class with three methods, one for read, print and shortest. However I do not know how to go about making the algorithm for the program I have made. Any help would be appreciated!\n\nThe program reads in these values with the first one being set to a variable called size and the rest being input into the 2D array called distance.\n\n```\n4\n0     1.7   0.3   0 \n1.7   0     0.1   3.6 \n0.3   0.1   0     0 \n0     3.6   0     0\n```\n\n\nThis is my Graph.h file:\n\n```\nclass Graph\n{\n public:\n  void read(const char* filename);\n  void print(ostream& out);\n  float shortest(int v1, int v2);\n private:\n  int size;\n  float max_edge_length;\n  float distance[MAX_VERTICES][MAX_VERTICES];\n};\n```\n\n\nBelow is my start on creating the read and print methods.\n\n```\nvoid Graph::read(const char* filename){\n    int x, y;\n    ifstream myfile(filename);\n\n    if (myfile.good()){\n        myfile >> size;\n        for (y = 0; y < size; y++){\n            for (x = 0; x < size; x++){\n                myfile >> distance[x][y];\n            }\n        }\n    }\n} \n\nvoid Graph::print(ostream& out){\n\n    out << size << endl;\n    for (int y = 0; y < size; y++){\n        for (int x = 0; x < size; x++){\n            out << distance[x][y] << \" \";\n        }   \n        out << endl;\n    }\n}\n\nfloat Graph::shortest(int v1, int v2){\n\n\n}\n```\n\n    ", "Answer": "\r\nif your graph is sure by after read from file and shortest is often use.\n\nyou can use Floyd's Algorithm. it's simple than Dijkstra\n\ntake O(n^3) (n is your graph point number) build once and query shortest everyTime use O(1)\n\nhttps://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm\n\nbut if your graph's point number large(like 100000). 2D array isn't good at store graph.  it's will cost 100000*100000*sizeof(float) memory\n\nyour can store graph by side\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Assertion error on Dijkstra algorithm implementation on python\r\n                \r\nI have this python file in which I implemented dijkstra's algorithm iteratively. Graphs are given in adjacency matrix format.\nThe thing is that in the last case of the test block this is the expected result: [13.0, 10.0, 14.0, 0.0, 6.0, 7.0, 8.0]\nand this is the result I'm getting: [13.0, 10.0, 18.0, 0.0, 6.0, 7.0, 8.0]\nI don't have any errors in the rest of the cases, that's the only weird case I get.\nAny ideas on why is this?\nHere's the code:\n```\nfrom time import time\nfrom math import inf\nimport math\n\n\n# function to get the node with the minimum distance in shortest_path_list\n# that hasn't been visited\ndef min_dist_node(graph, visited, sp_list, current_node):\n    dist = inf\n    node = 0\n    for i in range(0, len(graph)):\n        if i != current_node and not math.isinf(graph[current_node][i]) and dist > graph[current_node][i] and not visited[i]:\n            dist = graph[current_node][i]\n            node = i\n    return node\n\n\n\n# Dijkstra's algorithm\ndef Dijkstra (graph, initial):\n    sp_list = []\n    visited = [False]*len(graph)\n    \n    for node in range(0, len(graph)):\n        sp_list.append(graph[initial][node])\n        \n    sp_list[initial] = 0.0\n    visited[initial] = True\n    current_node = initial\n    \n    while False in visited:\n        current_node = min_dist_node(graph, visited, sp_list, current_node)\n        visited[current_node] = True\n        \n        for node in range(0, len(graph)):\n            if sp_list[node] > sp_list[current_node] + graph[current_node][node]:\n                sp_list[node] = sp_list[current_node] + graph[current_node][node]\n    return sp_list\n\n\n    \n    \n\n\ndef test():\n   \n    g0 =  [[0.0, 5.0, 1.0, inf],\n          [5.0, 0.0, 1.0, 2.0],\n          [1.0, 1.0, 0.0, 10.0],\n          [inf, 2.0, 10.0, 0.0]]\n    \n    assert Dijkstra(g0, 3) == [4.0, 2.0, 3.0, 0.0]\n \n    \n    g1 =  [[0.0, 2.0],\n           [2.0, 0.0]]\n    \n    assert Dijkstra(g1,0) == [0.0,2.0]\n\n    \n    g2 = [[0.0, 5.0, 3.0],\n          [5.0, 0.0, inf],\n          [3.0, inf, 0.0]]\n    \n    assert Dijkstra(g2, 1) == [5.0, 0.0, 8.0]\n\n        \n     \n    g3 = [[0.0, 1.0, 2.0, 3.0, 4.0],\n          [1.0, 0.0, inf, inf, 8.0],\n          [2.0, inf, 0.0, 2.0, 2.0],\n          [3.0, inf, 2.0, 0.0, 5.0],\n          [4.0, 8.0, 2.0, 5.0, 0.0]]\n    \n    assert Dijkstra(g3, 3) == [3.0, 4.0, 2.0, 0.0, 4.0]\n\n        \n    g4 = [[0.0, 6.0, 2.0, 5.0],\n          [6.0, 0.0, 4.0, inf],\n          [2.0, 4.0, 0.0, 2.0],\n          [5.0, inf, 2.0, 0.0]]\n    \n    assert Dijkstra(g4, 3) == [4.0, 6.0, 2.0, 0.0]\n   \n    \n    g5 = [[0.0, 10.0, 1.0, inf, inf, inf],\n          [10.0, 0.0, inf, 5.0, 4.0, inf],\n          [1.0, inf, 0.0, 8.0, 2.0, 3.0],\n          [inf, 5.0, 8.0, 0.0, inf, 2.0],\n          [inf, 4.0, 2.0, inf, 0.0, inf],\n          [inf, inf, 3.0, 2.0, inf, 0.0]]\n    \n    assert Dijkstra(g5, 0) == [0.0, 7.0, 1.0, 6.0, 3.0, 4.0]\n\n    \n    \n    g6 = [[0.0, 3.0, 1.0, inf, inf, inf, inf],\n          [3.0, 0.0, 8.0, 10.0, 5.0, inf, inf],\n          [1.0, 8.0, 0.0, inf, inf, inf, inf],\n          [inf, 10.0, inf, 0.0, 6.0, inf, 9.0],\n          [inf, 5.0, inf, 6.0, 0.0, 1.0, 2.0],\n          [inf, inf, inf, inf, 1.0, 0.0, 4.0],\n          [inf,inf,inf, 9.0, 2.0, 4.0, 0.0]]\n    \n    print(Dijkstra(g6, 3))\n    assert Dijkstra(g6, 3)  == [13.0, 10.0, 14.0, 0.0, 6.0, 7.0, 8.0]\n\nstart_time = time()\ntest()\nelapsed_time = time() - start_time   \nprint(\"Elapsed time: %0.10f seconds.\" % elapsed_time)       \n\n```\n\n    ", "Answer": "\r\nThere seems to be a flaw in the logic.\nIn each iteration, instead of picking up the node which is currently unvisited and at least distance to the source node (initial), you are picking the node which is unvisited and nearest to the current_node (which gets updated in every iteration).\nDue to this, 0th index node is getting visited but it's distances are not getting updated, and thus the shortest paths going through that nodes are also not getting updated.\nLet's do a dry run of your code with the failing test case:\nInitial variables:\n```\ngraph:[[0.0, 3.0, 1.0, inf, inf, inf, inf],\n      [3.0, 0.0, 8.0, 10.0, 5.0, inf, inf],\n      [1.0, 8.0, 0.0, inf, inf, inf, inf],\n      [inf, 10.0, inf, 0.0, 6.0, inf, 9.0],\n      [inf, 5.0, inf, 6.0, 0.0, 1.0, 2.0],\n      [inf, inf, inf, inf, 1.0, 0.0, 4.0],\n      [inf,inf,inf, 9.0, 2.0, 4.0, 0.0]]\nvisited: [False, False, False, True, False, False, False]\nsp_list: [inf, 10, inf, 0, 6, inf, 9]\ncurrent_node: 3 (zero indexing)\n```\n\n1st Iteration:\n```\ncurrent_node: 4\nsp_list: [inf, 10, inf, 0, 6, 7, 8]\nvisited: [False, False, False, True, True, False, False]\n```\n\n2nd Iteration:\n```\ncurrent_node: 5 // Node with shortest distance from node 4 instead of node 3.\nsp_list: [inf, 10, inf, 0, 6, 7, 8]\nvisited: [False, False, False, True, True, True, False]\n```\n\n3rd Iteration:\n```\ncurrent_node: 6 // node closest to node 5 which is unvisited\nsp_list: [inf, 10, inf, 0, 6, 7, 8]\nvisited: [False, False, False, True, True, True, True]\n```\n\n4th Iteration:\n\nHere is where the problem occurs. If you observe, all the neighbors of\nnode 6 are visited (node 3, node 4 and node 5). So, in this case, the\nfunction min_dist_node will return the default value of node, which is\n0. But sp_list[0] = inf!, so, the sp_list entries for nodes connected to 0th node will not be updated.\n\nThus:\n```\ncurrent_node: 0\nsp_list: [inf, 10, inf, 0, 6, 7, 8]\nvisited: [True, False,False, True, True, True, True]\n```\n\n5th Iteration:\n```\ncurrent_node: 2 // node unvisited and closest to 0th node\nsp_list: [inf, 10, inf, 0, 6, 7, 8] // same issue as in iteration 4\nvisited: [True, False,True, True, True, True, True]\n```\n\n6th Iteration:\n```\ncurrent_node: 1\nsp_list: [13, 10, 18, 0, 6,7,8] // The edge 1 -> 2 will be considered\nvisited: [True, True ,True, True, True, True, True]\n```\n\nThus the loop will end as all nodes have been visited.\nSo, the solution lies in choosing the next closest node to the initial node instead of the current node. This can be done by storing the node distances in a priority queue.\nFor implementation of the algorithm, you can refer to this\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Parsing a graph from a dot notation input for Dijkstra's Algorithm C#\r\n                \r\nI am trying to read a graph from a text file and parse it to be able to extract the vertices, edges and weight to use for a Dijkstra's Algorithm implementation.\n\nThe text file contains the following structure:\n\n```\ngraph {\n    a -- b[label=\"5\",weight=\"5\"];\n    a -- c[label=\"1\",weight=\"1\"];\n    c -- b[label=\"3\",weight=\"3\"];\n    c -- e[label=\"1\",weight=\"1\"];\n    e -- b[label=\"1\",weight=\"1\"];\n}\n```\n\n\nFinding it difficult to use the .split since the data is not seperated by the same delimeter.\n\nI need to extract for example from the first line:\na needs to be set as from.\nb needs to be set as to\nand 5 needs to set as weight\n\nAny ideas on how I can approach this please?\n    ", "Answer": "\r\nWe can extract the values easily using this regular expression:\n\n```\n(\\w+) -- (\\w+)\\[label=\"(\\w+)\",weight=\"([0-9]*\\.?[0-9]+)\"\\];\n```\n\n\nFull Code: \n\n```\nstring rawData = File.ReadAllText(\"H:\\\\data.txt\");\nstring pattern = \"(\\\\w+) -- (\\\\w+)\\\\[label=\\\"(\\\\w+)\\\",weight=\\\"([0-9]*\\\\.?[0-9]+)\\\"\\\\];\";\nvar matches = Regex.Matches(rawData, pattern);\n```\n\n\nEdit: \nHere's how we can get the different values from each match object\n\nDefine an ```\nEdge```\n class just for holding data \n\n```\nclass Edge {\n    public string NodeALabel;\n    public string NodeBLabel;\n    public double Weight;\n    public string EdgeLabel;\n}\n```\n\n\nGet the group values from each match. The group number is determined by how many opening parenthesis there are on the left side of the group.\n\n```\nvar edgeList = matches.Select(match => new Edge() {\n    NodeALabel= match.Groups[1].Value,\n    NodeBLabel= match.Groups[2].Value,\n    Weight= double.Parse(match.Groups[4].Value),\n    EdgeLabel= match.Groups[3].Value\n}).ToList();\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Trying to write Dijkstra's algorithm in C and the program crashes\r\n                \r\nSo I have just come across Dijkstra's algorithm for path finding and decided to try it out in C. I wrote the code to take the data of a Dijkstra diagram and find the shortest path. The data I used was:\n\nNumber of nodes: 5\n\nCost matrix\n\n0 4 0 8 0\n\n4 0 3 0 0\n\n0 3 0 4 0\n\n8 0 4 0 7\n\n0 0 0 7 0\n\nNode to visit: 5\n\nNumber of paths: 2\n\nPath matrix\n\n1 2 3 4 5\n\n1 4 5 0 0\n\nIt should output:\n\nMinimum distance is 15\n\nMinimum distance path: ->1 ->4 ->5\n\nHere is the code:\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <conio.h>\n#include <process.h>\n\nint main(){\n    int cost[10][10], path[10][10], distance[10], column, index = 1, row, min, n, i, j, v, p;\n\n    printf(\"Enter number of nodes: \");\n    scanf(\" %d\", &n);\n\n    printf(\"\\n\\nEnter cost matrix: \");\n\n    for(i = 1; i <= n; i++){\n        for(j = 1; j <= n; j++){\n            scanf(\" %d\", &cost[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    printf(\"\\n\\nEnter the node to visit: \");\n    scanf(\" %d\", &v);\n    printf(\"\\nEnter the number of paths for the node: \");\n    scanf(\" %d\", &p);\n\n    printf(\"\\n\\nEnter path matrix: \");\n\n    for(i = 1; i <= p; i++){\n        for(j = 1; j <= n; j++){\n            scanf(\" %d\", &path[i][j]);\n        }\n        printf(\"\\n\");\n    }                                  // program crashes here\n\n    for(i = 1; i <= p; i++){\n        distance[i] = 0;\n        row = 1;\n        for(j = 1; j <=n; j++){\n            if(row != v){\n                column = path[i][j + 1];\n                distance[i] = distance[i] + cost[row][column];\n            }\n        }\n        row = column;\n    }\n\n    min = distance[1];\n    for(i = 1; i <= p; i++){\n        if(distance[i] <= min   ){\n            min = distance[i];\n            index = i;\n        }\n    }\n\n    printf(\"Minimum distance is %d\\n\\n\", min);\n    printf(\"Minimum distance path:\");\n    for(i = 1; i <= n; i++){\n        if(path[index][i] != 0){\n            printf(\" ->%d\", path[index][i]);\n        }\n    }\n\n    return 0;\n}\n```\n\n\nI have been over the code many times wondering why it would crash. Any help would be much appreciated. Thanks.\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Recursion and Dijkstra's Algorithm\r\n                \r\nMy recursive algorithm to navigate a maze takes way too long. Any suggestions on how to speed it up to be more efficient? Right now, it goes through every possible solution. When I tried to cut that down, it would then skip over many of the solutions, including the shortest. How do I cut down the number of solutions, or end some solutions early, while not skipping the shortest?\n\n```\n private static void turnsforshortestmove(Vector2 location, int[,] board, int endrow, ref Boolean done, ref int[,] BOARDCHANGE, ref HashSet<int> h)\n //location is current location. board is the maze, endrow is the end y value to get to. it doesn't matter which x value, but as long as they get to the y value it's considered finishing.\n // done is a mistake, ignore it. BOARDCHANGE stores \n{\n    //i need to compare all results for shortest\n    //i need to cut off those that cant move\n    if (location.Y == endrow)\n    {\n        h.Add(parseInt(board)); //counts how long the path is\n        for (int r = 0; r < 19; r++)\n            for (int c = 0; c < 19; c++)\n                BOARDCHANGE[r, c] = board[r, c]; //sets the \"real\" board to have the path shown\n    }\n    else\n    {\n\n        int[,] boardCopy = new int[19, 19];\n        for (int r = 0; r < 19; r++)\n            for (int c = 0; c < 19; c++)\n                boardCopy[r, c] = board[r, c];\n\n        boardCopy[(int)location.X, (int)location.Y] = 8;\n\n\n //this part is saying if the square above isnt a wall, and two squares above isn't occupied, then do this function again\n\n        if (boardCopy[(int)location.X, (int)location.Y - 1] == 1)\n        {\n            if (boardCopy[(int)location.X, (int)location.Y - 2] == 0)\n            {\n                turnsforshortestmove(new Vector2(location.X, location.Y - 2), boardCopy, endrow, ref done, ref BOARDCHANGE, ref h);\n            }\n        }    \n        if (boardCopy[(int)location.X - 1, (int)location.Y] == 1)\n        {\n            if (boardCopy[(int)location.X - 2, (int)location.Y] == 0)\n            {\n                turnsforshortestmove(new Vector2(location.X - 2, location.Y), boardCopy, endrow, ref done, ref BOARDCHANGE, ref h);\n            }\n        }\n        if (boardCopy[(int)location.X + 1, (int)location.Y] == 1)\n        {\n            if (boardCopy[(int)location.X + 2, (int)location.Y] == 0)\n            {\n                turnsforshortestmove(new Vector2(location.X + 2, location.Y), boardCopy, endrow, ref done, ref BOARDCHANGE, ref h);\n            }\n        }\n        if (boardCopy[(int)location.X, (int)location.Y + 1] == 1)\n        {\n            if (boardCopy[(int)location.X, (int)location.Y + 2] == 0)\n            {\n                turnsforshortestmove(new Vector2(location.X, location.Y + 2), boardCopy, endrow, ref done, ref BOARDCHANGE, ref h);\n            }\n        }\n    }\n}\n```\n\n\nAt the end, it looks through the Hashset to find the shortest path (number).\n    ", "Answer": "\r\nSet up a matrix M with 0 at the initial location (\"start\") and max int everywhere else. Also create a queue of positions.\n\nThen:\n\n```\nend = null\nenqueue start\nwhile queue is not empty\n    p = dequeue\n    if p.Y == desired_y\n        end = p\n        break\n    for each neighbour of p // up, down, left, right\n        if neighbour is not a wall and M[neighbour.X, neighbour.Y] > M[p.X, p.Y] + 1\n            M[neighbour.X, neighbour.Y] = M[p.X, p.Y] + 1\n            enqueue neighbour\n\n\nif end == null\n    return // no path exists\n\n// now let's get the actual path, in reverse - from end to start\npos = end\npath.add(pos)\nwhile pos != start\n    for each neighbour of pos\n        if M[neighbour.X, neighbour.Y] == M[pos.X, pos.Y] - 1\n            pos = neighbour\n            path.add(pos)\n            break\n\n\npath.reverse // this is now your shortest path\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra Algorithm with Chebyshev Distance\r\n                \r\nI have been using Dijkstra Algorithm to find the shortest path in the Graph API which is given by the Princeton University Algorithm Part 2, and I have figured out how to find the path with Chebyshev Distance.\n\nEven though Chebyshev can move to any side of the node with the cost of only 1, there is no impact on the Total Cost, but according to the graph, the red circle, why does the path finding line moves zigzag without moving straight? \n\nWill the same thing will repeat if I use A* Algorithm? \n\n\n    ", "Answer": "\r\nIf you want to prioritize \"straight lines\" you should take the direction of previous step into account. One possible way is to create a graph ```\nG'(V', E')```\n where ```\nV'```\n consists of all neighbour pairs of vertices. For example, vertex ```\nv = (v_prev, v_cur)```\n would define a vertex in the path where ```\nv_cur```\n is the last vertex of the path and ```\nv_prev```\n is the previous vertex. Then on \"updating distances\" step of the shortest path algorithm you could choose the best distance with the best (non-changing) direction. \n\nAlso we can add additional property to the distance equal to the number of changing a direction and find the minimal distance way with minimal number of direction changes.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Can someone detect error in this code to implement dijkstra's algorithm using python?\r\n                \r\nI am trying to implement dijkstra's algorithm (on an undirected graph) to find the shortest path and my code is this.\n\nNote: I am not using heap/priority queue or anything but an adjacency list, a dictionary to store weights and a bool list to avoid cycling in the loops/recursion forever. Also, the algorithm works for most test cases but fails for this particular one here: https://ideone.com/iBAT0q\n\nImportant : Graph can have multiple edges from v1 to v2 (or vice versa), you have to use the minimum weight.\n\n```\nimport sys\n\nsys.setrecursionlimit(10000)\n\ndef findMin(n):\n    for i in x[n]:\n        cost[n] = min(cost[n],cost[i]+w[(n,i)])\ndef dik(s):\n    for i in x[s]:\n        if done[i]:\n            findMin(i)\n            done[i] = False\n            dik(i)\n    return\nq = int(input())\nfor _ in range(q):\n    n,e = map(int,input().split())\n    x = [[] for _ in range(n)]\n    done =  [True]*n\n    w = {}\n    cost = [1000000000000000000]*n\n    for k in range(e):\n        i,j,c = map(int,input().split())\n        x[i-1].append(j-1)\n        x[j-1].append(i-1)\n        try:                                       #Avoiding multiple edges\n            w[(i-1,j-1)] = min(c,w[(i-1,j-1)])\n            w[(j-1,i-1)] = w[(i-1,j-1)]\n        except:\n            try:\n                w[(i-1,j-1)] = min(c,w[(j-1,i-1)])\n                w[(j-1,i-1)] = w[(i-1,j-1)]\n            except:\n                w[(j-1,i-1)] = c\n                w[(i-1,j-1)] = c\n    src = int(input())-1\n    #for i in sorted(w.keys()):\n    #   print(i,w[i])\n    done[src] = False\n    cost[src] = 0\n    dik(src)          #First iteration assigns possible minimum to all nodes\n    done = [True]*n     \n    dik(src)          #Second iteration to ensure they are minimum\n    for val in cost:\n        if val == 1000000000000000000:\n            print(-1,end=' ')\n            continue\n        if val!=0:\n            print(val,end=' ')\n    print()\n```\n\n    ", "Answer": "\r\nThe optimum isn't always found in the second pass. If you add a third pass to your example, you get closer to the expected result and after the fourth iteration, you're there.\n\nYou could iterate until no more changes are made to the cost array:\n\n```\ndone[src] = False\ncost[src] = 0\ndik(src)\n\nwhile True:\n    ocost = list(cost)          # copy for comparison\n    done = [True]*n     \n    dik(src)\n    if cost == ocost:\n        break\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm with Time Tables and varying missing edges\r\n                \r\nI know Dijkstra's algorithm is a popular solution for the \"shortest path\" problem, however it seems to be backfiring when implementing time tables.\n\nSay I have this graph with the following weights (time to get from one point to another):\n\n```\nA-----C     A->C: 10\n\\--B--/     A->B: 5\n            B->C: 5\n```\n\n\nIf you throw it into Dijkstra, it'll  return route A->C. That's fine until you refer to a timetable that says route A->C only exists within a certain time frame. You could easily remove the A->C edge if the requested time frame falls outside the range when that edge is used. But obviously the data set I'm working with has a bunch of other ways to get from A->C with other, higher, costs. Not to mention what if you want to get from Z->Y which requires going from A->C in the middle. It doesn't seem like an ideal solution.\n\nIs there a better way, other than Dijkstra, to create a shortest path while also keeping a timetable in mind? Or should the algorithm be modified to consider two weights when finding the optimal path?\n\nIf it matters, I'm using python.\n\n[edit]\n\nThe time table is a basic table that says a train (in my case) leaves from point A at (say) 12:00 and leaves from station B at 12:05 then leaves from C at 12:10. When it doesn't stop at B, its column is empty and A will have 08:00 and C will have 08:10 \n\n```\nA       B        C\n800            8:10\n12:00  12:05  12:10 \n```\n\n    ", "Answer": "\r\nOne way could be creating a set of trees that denotes all simple paths between to given nodes and just selecting the shortest one among those that are not contain a deprecated edge. You can find all paths by adapting Dijkstra's algorithm or another algorithm like DFS or BFS. Also finding all paths between two nodes is considered to be a hard problem but based on your need and the type of graphs that you're dealing with you can create what you want. You can also read this post regarding this matter. -> Find all paths between two graph nodes. i.e you can have a limited set of paths (if using Dijkstra top N shortest).\n\nNow for Optimizing this step so that find out if an edge is deprecated or not I suggest to have a dictionary of all edge ids or names as keys and their deprecation timestamp as value then filter the dictionary by comparing the values with ```\nnow().timestamp()```\n and after each find just remove the items from dictionary. Also note that before you start filtering you should check if the edge exist in dictionary or not (in order to prevent the lagorithm to run the filtering multiple times for duplicate edges).\n\nThe code should be like following:\n\n```\ndef filter_edge(u_id):\n    if edge in deprecation:\n        time_stamp = deprecation[u_id]\n        if time_stamp > datetime.now().timestamp():\n            return True\n    return False\n```\n\n\nAnd the path validation is something like following:\n\n```\ndef validate_path(path):\n    return not any(filter_edge(edge.id) for edge in path)\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Difference between DIjkstra and BellmanFord algorithm [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is off-topic. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it's on-topic for Stack Overflow.\r\n                \r\n                    \r\n                        Closed 10 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI am wring thesis about shortest path algorithms.\nAnd i don't understand one thing...\n\nI have made visualisation of dijkstras algorithm.\n1) Is it correct ? Or am i doing something wrong?\n2) How would look Bellman-Ford algorithm? As fas as i have looked for difference, i found \"Bellman-ford: the basic idea is very similar to Dijkstra's, but instead of selecting the shortest distance neighbour edges, it select all the neighbour edges.\" But also dijkstra checks all vertexes and all edges, isnt it? \n    ", "Answer": "\r\ndijkstra assumes that the cost of paths is montonically increasing.  that plus the ordered search (using the priority queue) mans that when you first reach a node, you have arrived via the shortest path.\n\nthis is not true with negative weights.  if you use dijkstra with negative weights then you may find a later path is better than an earlier one (because a negative weight improved the path on a later step).\n\nso in bellman-ford, when you arrive at a node you test to see if the new path is shorter.  in contrast, with dijkstra, you can cull nodes \n\nin some (most) cases dijkstra will not explore all complete paths.  for example, if G linked only back to C then any path through G would be higher cost that any through C.  bellman-ford would still consider all paths through G to F (dijkstra would never look at those because they are of higher cost that going through C).  if it does not do this it can't guarantee finding negative loops.\n\nhere's an example: the above never calculates the path AGEF.  E has already been marked as visited by the time you arrive from G.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How do I implement PriorityQueue for Dijkstra's algorithm?\r\n                \r\nI have a question regarding implementing priority queue for Dijkstra's algorithm, because this is a hw so I couldn't create another class, so I'm trying to find a way to add nodes(integer)in priority queue but I want the queue to sort the weight inside the node, but not the node itself.\n\nFor example,I have 3 nodes(0,1,2) and node 0 has a weight of 10, node 1 has 15, and node 2 has 5.\n\n```\nQueue<Integer> queue = new PriorityQueue<Integer>();\nqueue.add(0);\nqueue.add(1);\nqueue.add(2);\n\nwhile(!queue.isEmpty()){\n    System.out.println(queue.poll());\n}\n```\n\n\nThis should give me a output of 2,0,1.\nIs this possible without creating another class? Or is there a different approach I could use besides priority queue?\n\nThanks in advance!!!!!! any help would be much appreciated!\n\nOne solution I could think of is sorting a normal queue every time I add a node into it, so if I have node 2,0,1 in the queue and I want to add node 3 which has a weight of 8, I would need to compare the weight with the top element of queue until it fits into the queue, so it would be 2,3,0,1 in queue, but this is kindda inefficient tho.\n    ", "Answer": "\r\nYou have two options:\n\n\nCreate your own ```\nNode```\n class, and make it implement the ```\nComparable<Node>```\n interface. The class will have a ```\nweight```\n attribute, and it could compare ```\nNode```\ns based on their weight. This will create a natural ordering of ```\nNodes```\n that ```\nPriorityQueue```\n will use.\nCreate the priority queue with the ```\nPriorityQueue(Comparator<? super E> comparator)```\n constructor. It takes a comparison function (```\nComparator```\n) for comparing two items. You can therefore have that function compare using the node's weights (which don't have to be kept in the same queue - the might be calculated dynamically or be kept in some separate data structure).\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How to obtain and save \"for\" loop results as list after running Dijkstra's algorithm?\r\n                \r\nI am trying to solve a problem with Dijkstra's algorithm. Basically, I want to randomly select start and end nodes and find the distances along each path after pairing the nodes and running the algorithm. Finally, I want to save the result as a list. So far, the code works well, however, I am having a challenge saving the result as a list.\nHere is the code I have used. \n\n```\nimport random\nfrom random import seed\nfrom random import random\nfrom random import randint\nimport pandas as pd\nimport numpy as np\nimport statistics \n```\n\n\n```\ndistance = [(0,7,3,0,0),(7,0,1,2,6),(3,1,0,2,0),(0,2,2,0,4),(0,6,0,4,0)]\ndist = np.array(distance)\ngraph = dist\n```\n\n\n```\n# Python program for Dijkstra's  \n\nfrom collections import defaultdict \nclass Graph:   \n    def minDistance(self,dist,queue): \n        minimum = float(\"Inf\") \n        min_index = -1\n        for i in range(len(dist)): \n            if dist[i] < minimum and i in queue: \n                minimum = dist[i] \n                min_index = i \n        return min_index  \n    def printPath(self, parent, end): \n        if parent[end] == -1 :  \n            #print (end), \n            return\n        self.printPath(parent , parent[end]) \n        #print (end),     \n    def printSolution(self, dist, parent): \n        #print(\"Vertex and Path \\t\\tDistance from Source\") \n        #print((start, end, dist[end])), self.printPath(parent,end)  #if you want to see start and end nodes\n\n        print(dist[end]), self.printPath(parent,end)  #if you do not want to see start and end nodes\n\n    '''Function that implements Dijkstra's single source shortest path \n    algorithm for a graph represented using adjacency matrix \n    representation'''\n    def dijkstra(self, graph, start): \n        row = len(graph) \n        col = len(graph[0]) \n        dist = [float(\"Inf\")] * row \n        parent = [-1] * row \n        dist[start] = 0\n        queue = [] \n        for i in range(row): \n            queue.append(i) \n        while queue: \n            u = self.minDistance(dist,queue)  \n            queue.remove(u) \n            for i in range(col): \n                '''Update dist[i] only if it is in queue, there is \n                an edge from u to i, and total weight of path from \n                start to i through u is smaller than current value of \n                dist[i]'''\n                if graph[u][i] and i in queue: \n                    if dist[u] + graph[u][i] < dist[i]: \n                        dist[i] = dist[u] + graph[u][i] \n                        parent[i] = u   \n        self.printSolution(dist,parent)   \ng= Graph() \n```\n\n\n```\nseed(1)\nstart1 = []\nfor x in range(3):\n    start = randint(0, 3)\n    start1.append(start)\n```\n\n\n```\nseed(3)\nend1 = []\nfor x in range(3):\n    end = randint(2,4)\n    end1.append(end)\n```\n\n\n```\nstart = start1\nend = end1\n```\n\n\n```\nresults = []\nfor i in start1:\n    for q in end1:\n        start = i\n        end = q\n        if i != q:\n            results.append(g.dijkstra(graph,i))\n```\n\n\nThe above code produces this result ...\n\n```\n1\n6\n6\n3\n9\n9\n6\n6\n```\n\n\nWhen I call for the saved list, I get \"none\" values.\n\n```\nresults\n```\n\n\n```\n[None, None, None, None, None, None, None, None]\n```\n\n\nI wish to get the results as follows:\n\n```\n[1,6,6,3,9,9,6,6,]\n```\n\n\nAs I am a beginner at using python, I would be exceedingly grateful if someone can help me to save the result as a list.\n    ", "Answer": "\r\nin ```\nresults```\n you append return value from ```\ng.dijkstra(graph,i)```\n. And b/c there is no return command, it returns ```\nNone```\n. Hence you append only ```\nNone```\n.\nAdd ```\nreturn some-value```\n at the end of ```\ndijkstra()```\n and it should work.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "A modification of the Dijkstra algorithm\r\n                \r\nI need help.\nIs there a way to modify this Dijkstra algorithm I found on the internet so that it also prints the number of branches between the source node and the other nodes that are reachable?\nI tried to introduce some counter in the code when checking the connectivity between the nodes but without success.\n```\nint minDistance(Graph g,double dist[], bool sptSet[])\n{\n// Initialize min value\nint min = INT_MAX, min_index;\nfor (int v = 0; v < g.n ; v++)\n    if (sptSet[v] == false && dist[v] <= min)\n        min = dist[v], min_index = v;\n    return min_index;\n}\nvoid printSolution(Graph g,double dist[])\n{\n    cout<<\"Vertex Distance from Source\\n\";\n    for (int i = 0; i < g.n; i++)\n    if (dist[i] < g.n)\n    {\n        cout<< i+1 << \"         \" << dist[i] << endl;\n    }\n}\nvoid dijkstra(GRAPH g, int src)\n{\n    double dist[MAX];\n    bool sptSet[MAX];\n    for (int i = 0; i < g.n; i++)\n        dist[i] = INT_MAX, sptSet[i] = false;\n    dist[src] = 0;\n    for (int count = 0; count < g.n - 1; count++) \n    {\n        int u = minDistance(g, dist, sptSet);\n        sptSet[u] = true;\n        for (int v = 0; v < g.n; v++) {\n            int c = 0; //Here I tried to introduce a counter!\n            if (!sptSet[v] && g.ms[u][v] && dist[u] != INT_MAX && \n                    dist[u] + g.ms[u][v] < dist[v])\n            {\n                c++; //Here I tried to introduce a counter!\n                dist[v] = dist[u] + g.ms[u][v];\n            }\n             cout << c; //Here I tried to introduce a counter!\n        }\n    }\n    printSolution(g, dist);\n}\n```\n\nThanks in advance!\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm to prevent any vertex on re on fire paths\r\n                \r\nLet G = (V;E) be a directed graph with two weights we and re on each edge e. There\nare two special vertices in this graph: c, the chemical plant, and a, the amphitheater. The\ntask is to create an evacuation plan from a to v for every vertex w in V in the event that\nthe chemical plant catches re. The time it takes the re to spread along an edge e is re.\nThe time to travel along an edge is we.\nI have to write an algorithm to find the shortest safe path from a to\nv for each v in V : a path is safe if it does not include any vertex on re at the time that vertex is traversed.\nMy trying:\ni. I have first computed the time at which each vertex catches re , assuming the chemical plant catches re at time 0.\nii. Then I have modified Dijkstra's algorithm so that it does not use any vertex on re on the paths\nit computes.\nMy Algorithm:\n```\nDijkstraShortestPath:\n       1. graph[][] --> read the graph\n       2. c <-- chemical plant\n       3. a <-- amphitheater  \n       4. for i --> 0 to V   \n            queuePriority.add(i);\n            distance[i] = Integer.MAX_VALUE;\n            prev[i] = -1;\n            visitedVertex[i] = false;\n        }\n        5. Q <-- queue(c), level[]--> inifinity\n        6. while Q is not empty:\n              U <-- Q.pop() \n   for all edges from u to v in G.adjacentEdges(c)\n           If level[v] --> inifinity:\n            level[v] <-- level[u] + re\n            Q.enqueu(v)       \n        7. distance[a] = 0;\n        while (!queuePriority.isEmpty()) {\n\n            int u = minDistance();\n            if (u == -1) {\n                break;\n            }\n\n            queuePriority.remove(u);\n            visitedVertex[u] = true;\n\n            for (int i = 0; i < nodeNumber; i++) {\n                if (graph[u][i] != 0 && graph[u][i]%re ==0 && graph[u][i] + distance[u] < distance[i]) {\n                    distance[i] = graph[u][i] + distance[u];\n                    prev[i] = u;\n                }\n            }\n        }\n        printShortestPath(distination);\n        return distance[distination];\n    }\n```\n\nDoes my algorithm solve the problem ? If not, how can I modify my algorithm to solve the problem ?\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm average runtime change based on complexity\r\n                \r\nDijkstra algorithm with a self-balancing binary search tree has a complexity of O(e * log(n)). Does this mean that in a statistical middle, pathfinding queries for e=100 and n=25 take double the time than pathfinding queries for e=50 and n=25.\n\nThe question is kind of pumpy, my point is about a relative comparison of statistically average runtime changes.\n    ", "Answer": "\r\nI think math is simple here, with ```\nO(E * log(N))```\n average running time is proportional to E. O(n) can in reality be ```\nO(n) + C```\n, so with small ```\nn```\n and significant ```\nC```\n the ```\nn*2```\n will be not two times slower but less: ```\n(2n + C) / (n + C)```\n.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How is Dijkstra algorithm better tham A* algorithm for finding shortest path?\r\n                \r\nHow is Dijkstra algorithm better tham A* algorithm for finding shortest path?\n    ", "Answer": "\r\nIt is not better at finding the shortest path. As long as you have an admissible heuristic for A* it will find the shorted path quicker than Dijkstra's would.  \n\nAnd as Mehrad pointed out in the comments, A* degrades into Dijktras if you give it a heuristic function that returns 0.\n\nThe wikipedia article for A* has a ton of good information on all of this.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Measure time Dijkstra's algorithm takes between nodes\r\n                \r\nI'm doing a graph program in C# which uses the Dijkstra algorithm to find the shortest path between nodes but I need to export the time it takes between each node to an excel file. I really haven't been able to come up with something or find any information about it. Any ideas on how to do this?Here's the code for it.(verticesCount is a vertex count used in other parts of the program)\n\n```\n    public static void Dijkstra(int[,] graph, int source, int verticesCount)\n            {\n                int[] distance = new int[verticesCount];\n                bool[] shortestPathTreeSet = new bool[verticesCount];\n\n                for (int i = 0; i < verticesCount; ++i)\n                {\n                    distance[i] = int.MaxValue;\n                    shortestPathTreeSet[i] = false;\n                }\n\n        distance[source] = 0;\n\n        for (int count = 0; count < verticesCount - 1; ++count)\n        {\n            int u = MinimumDistance(distance, shortestPathTreeSet, verticesCount);\n            shortestPathTreeSet[u] = true;\n\n            for (int v = 0; v < verticesCount; ++v)\n                if (!shortestPathTreeSet[v] && Convert.ToBoolean(graph[u, v]) && distance[u] != int.MaxValue && distance[u] + graph[u, v] < distance[v])\n                    distance[v] = distance[u] + graph[u, v];\n        }\n\n        Print(distance, verticesCount);\n    }\n```\n\n    ", "Answer": "\r\nYou can use the Stopwatch class to count the elapsed time between two or more desired parts. See Stopwatch class\nAlso, you can write to a CSV file to open it with excel. See an example: Write to a CSV file\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "A modification of the Dijkstra algorithm\r\n                \r\nI need help.\nIs there a way to modify this Dijkstra algorithm I found on the internet so that it also prints the number of branches between the source node and the other nodes that are reachable?\nI tried to introduce some counter in the code when checking the connectivity between the nodes but without success.\n```\nint minDistance(Graph g,double dist[], bool sptSet[])\n{\n// Initialize min value\nint min = INT_MAX, min_index;\nfor (int v = 0; v < g.n ; v++)\n    if (sptSet[v] == false && dist[v] <= min)\n        min = dist[v], min_index = v;\n    return min_index;\n}\nvoid printSolution(Graph g,double dist[])\n{\n    cout<<\"Vertex Distance from Source\\n\";\n    for (int i = 0; i < g.n; i++)\n    if (dist[i] < g.n)\n    {\n        cout<< i+1 << \"         \" << dist[i] << endl;\n    }\n}\nvoid dijkstra(GRAPH g, int src)\n{\n    double dist[MAX];\n    bool sptSet[MAX];\n    for (int i = 0; i < g.n; i++)\n        dist[i] = INT_MAX, sptSet[i] = false;\n    dist[src] = 0;\n    for (int count = 0; count < g.n - 1; count++) \n    {\n        int u = minDistance(g, dist, sptSet);\n        sptSet[u] = true;\n        for (int v = 0; v < g.n; v++) {\n            int c = 0; //Here I tried to introduce a counter!\n            if (!sptSet[v] && g.ms[u][v] && dist[u] != INT_MAX && \n                    dist[u] + g.ms[u][v] < dist[v])\n            {\n                c++; //Here I tried to introduce a counter!\n                dist[v] = dist[u] + g.ms[u][v];\n            }\n             cout << c; //Here I tried to introduce a counter!\n        }\n    }\n    printSolution(g, dist);\n}\n```\n\nThanks in advance!\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "dijkstra algorithm failing on multiple calls\r\n                \r\nSo I'm writing a simulator for a package delivery business and I'm running into a snag with my implementation of dijkstra's algorithm that I cannot seem to pinpoint. \n\nThe main goal with the below code is to build a 2d array of shortest distances in order to have a quick lookup while driving in case of possible changes in destination.\n\nThe distances array returned after a call to my find_shortest path leaves the maximum integer value even though the graph is fully connected. This problem occurs when I attempt to run it from a starting position > 0.\n\n```\n#\n# Used to define/process adjency matrices for the simulation\nimport sys\n\n\nclass DistanceTable:\n    def __init__(self, size, labels):\n        self.table = [[0 for column in range(size)]\n                      for row in range(size)]\n        self.labels = labels\n        self.size = size\n\n    def get_minimum_distance(self, distances, visited):\n        prev_min = sys.maxsize\n        min_distance_idx = -1\n        for i in range(self.size):\n            if distances[i] <= prev_min and visited[i] is False:\n                prev_min = distances[i]\n                min_distance_idx = i\n\n        return min_distance_idx\n\n    def find_shortest(self, start_val):\n        visited = [False] * self.size\n        distances = [sys.maxsize] * self.size\n        distances[start_val] = 0\n\n        for i in range(self.size):\n            min_distance_idx = self.get_minimum_distance(distances, visited)\n            visited[min_distance_idx] = True\n\n            for y in range(self.size):\n                if visited[y] is False and self.table[i][y] > 0 and distances[y] > distances[i] + self.table[i][y]:\n                    distances[y] = distances[i] + self.table[i][y]\n\n        return distances\n\n\nlabels = [''] * 3\nsize = len(labels)\ndistance = [[0, 2, 18],\n            [1, 0, 4],\n            [5, 13, 0]]\n\ngraph = DistanceTable(size, labels)\ngraph.table = distance\n\ndist = [[0 for column in range(size)]\n        for row in range(size)]\n\nfor i in range(3):\n    dist[i] = graph.find_shortest(i)\n    print(dist[i])\n```\n\n\nThis is the smallest I could make this example and the output of the prints above is:\n\n```\n[0, 2, 6]\n[1, 0, 9223372036854775807]\n[9223372036854775807, 9223372036854775807, 0]\n```\n\n\nOr for easier reading\n\n```\n[0,         2,           6         ]\n[1,         0,           sys.maxint]\n[sys.maxint, sys.maxint, 0         ]\n```\n\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How to return the n best shortest path (dijkstra algorithm)\r\n                \r\nHello I have implemented in C Dijkstra's algorithm to find the shortest path, but I need to return the n shortest paths, anyone have an idea how can I do.\n\nMy dijkstra function:\n\n```\nint * Dijkstra(graph **g, int totalVertex, int vStart) {\n  int i;\n  int *distance = (int*) malloc(totalVertex * sizeof (int));\n  int *last = (int*) malloc(totalVertex * sizeof (int));\n  int *visited = (int*) calloc(totalVertex, sizeof (int));\n  int maxDistance, m;\n  graph *vertex;\n\n  for (i = 0; i < totalVertex; i++) {\n    distance[i] = MAXINT;\n    last[i] = -1;\n  }\n\n  distance[vOrigem] = 0;\n\n  while (sum(visited, totalVertex) < totalVertex) {\n\n    maxDistance = MAXINT;\n\n      for (i = 0; i < totalVertex; i++) {\n        if ((distance[i] < maxDistance) && (visited[i] == 0)) {\n          maxDistance = distance[i];\n          m = i;\n        }\n       }\n\n    vertex = g[m];\n    while (vertex != NULL) {\n      if ((vertex->distance + distance[m]) < (distance[vertex-> destination])) {\n        distance[vertex->destination] = vertex->distance + distance[m];\n        last[vertex->destination] = m;\n      }\n    vertex = vertice->next;\n    }\n  visited[m] = 1;\n  }\n  free(distance);\n  free(visited);\n  return last;\n}\n```\n\n\nI need to call eg 2 times this function and it returns, the two shortest paths in the graph.\n\nThank you.\n    ", "Answer": "\r\nLets start by calling the actual shortest path S and n is the total number of links in S.\n\nThis is going to be tough because you could have a ton of permutations of the paths depending on the network configuration and in order to create the next shortest path, you will have to run the algorithm n more times, setting each of the vertices in the shortest path to Visited[m] = 1 for each run in case the next shortest path uses most, but not all of the same vertices from S.\n\nIf you really want to only run this for the two shortest paths, then this will be straightforward.  If you want to be able to run this to get an arbitrary number of shortest paths, you are exponentially increase your computation time as you go back and set each of the original path links to Visited.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How is Dijkstra algorithm better tham A* algorithm for finding shortest path?\r\n                \r\nHow is Dijkstra algorithm better tham A* algorithm for finding shortest path?\n    ", "Answer": "\r\nIt is not better at finding the shortest path. As long as you have an admissible heuristic for A* it will find the shorted path quicker than Dijkstra's would.  \n\nAnd as Mehrad pointed out in the comments, A* degrades into Dijktras if you give it a heuristic function that returns 0.\n\nThe wikipedia article for A* has a ton of good information on all of this.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Running time analysis of Dijkstra's for shortest path algorithm but with a maximum K stops\r\n                \r\nFor a problem like this (https://leetcode.com/problems/cheapest-flights-within-k-stops/), I can solve this problem with Dijkstra's algorithm with an upper bound of O(|E| + |V|log|V|).\n\nHowever, since there is an additional stopping criteria of max of K stops. My upper bound should be less if K < V.\n\nQ: How do I incorporate the K stops into my analysis of Dijkstra's algorithm?\n\nQ2: What if we assume the graph is fully connected (Each vertex is connected every other vertices. So E = V^2)? Does this change the analysis?\n    ", "Answer": "\r\nDijkstra's algorithm doesn't work for this problem.  Once it finds the cheapest path to a vertex, it won't look for any other paths... but the cheapest path to a vertex may use up too many slots to allow the cheapest path from there to the target.  It could be that a more expensive path to an intermediate vertex is the best one if it leaves more stops available to reach the target.\n\nFor example:\n\n```\nS--1--A--1--B--1--C--1--T\n \\         / \\         /\n  `---4---'   `---9---'\n```\n\n\nIn this example, the cheapest path from S to T with 2 stops is ```\nS-B-C-T```\n with cost 6.  But Dijkstra's algorithm with limited stops will only find ```\nS-A-B-T```\n with cost 11.\n\nOff the top of my head, the best algorithm I know for this problem takes O(KE) time.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Understanding Dijkstra Algorithm\r\n                \r\nI'm trying to understand the Dijkstra Algorithm for finding the shortest path.\n\nI've came up to this example, where the top table corresponds to the image in the bottom left corner.\n\n\n\nNow, my problem is that I don't understand the transition from step 1 to step 2:\n\nWhen we are in UX we can travel to UXV by adding the cost of X to V (which is 2) to our current cost (which is 1; the cost of UX). So the sum would be 3, but since this I bigger then the 2 we already found we don't change it. In step 1 we have two options which both have the same cost; UXY and UXV, but why does the algorithm choose to go to UXY instead of UXV?\n\nThanks in advance! \n    ", "Answer": "\r\nWhen you have two or more options with the same cost, it does not make any difference with which option you proceed.\n\nIn the Dijkstra's algorithm Wikipedia article there is a section with a pseudocode for implementing the algorithm. You can see that in the pseudocode there is a line ```\nu ← vertex in Q with min dist[u]```\n, which means that you choose one option with the lowest costs. When you have more options with the same cost, you just take any of those.\n\nFor your concrete example, this means that you could also go to UXV instead of UXY. This might lead to more steps, but the end result is the same when the algorithm finishes.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Java Graph Dijkstras Algorithm\r\n                \r\nSo I am trying to implement a graph in Java and I can do BFS and DFS but I am having some issues with my Dijkstras algorithm. Basically here's my graph...\n\nGraph\n\nSo when I run the Dijkstras algorithm, I get the following results\n\n```\nShortest path cost between ST A: -1, Path: [ST, B, A]\nShortest path cost between ST B: -1, Path: [ST, B]\nShortest path cost between ST C: -1, Path: [ST, B, D, C]\nShortest path cost between ST D: -1, Path: [ST, B, D]\nShortest path cost between ST M: -1, Path: [None]\nShortest path cost between ST ST: 0, Path: []\n```\n\n\nThe results should be...\n\n```\nShortest path cost between ST A: 10, Path: [ST, B, A]\nShortest path cost between ST B: 6, Path: [ST, B]\nShortest path cost between ST C: 12, Path: [ST, B, A, C]\nShortest path cost between ST D: 9, Path: [ST, B, D]\nShortest path cost between ST M: -1, Path: [None]\nShortest path cost between ST ST: 0, Path: [ST]\n```\n\n\nAs you can see, I am unable to get the path cost and for ST to C I'm getting ST, B, D, C instead of ST, B, A, C which is the shorter path. \n\nMy method takes in a start node, end node and an arraylist for shortest path. Attached below...\n\n```\nprivate boolean alpha;\nprivate int temp;\n\npublic int doDijkstras(String startVertex, String endVertex,\n        ArrayList<String> shortestPath) {\n\n    if (!dataMap.containsKey(startVertex) || !dataMap.containsKey(endVertex)\n            || getAdjacentVertices(startVertex) == null\n            || getAdjacentVertices(endVertex) == null) {\n        shortestPath.add(\"None\");\n        return -1;\n    }\n    if (startVertex.equals(endVertex)) {\n        return 0;\n    }\n\n    ArrayList<String> currentPath = new ArrayList<String>();\n    Stack<Node> visited = new Stack<Node>();\n\n    Node currentNode;\n    Node previousNode = new Node();\n\n    int lowestPath = -1;\n\n    currentNode = new Node(startVertex);\n    visited.push(currentNode);\n    currentPath.add(currentNode.name);\n\n    while (visited.size() != 0) {\n        alpha = false;\n        djAux(startVertex, endVertex, previousNode, currentNode, visited,\n                shortestPath, currentPath, lowestPath);\n        previousNode = visited.peek();\n        visited.pop();\n        currentPath.clear();\n        if (visited.size() != 0) {\n            visited.peek().previous.add(previousNode.name);\n            currentNode = visited.peek();\n\n            for (Node n : visited) {\n                currentPath.add(n.name);\n            }\n            temp = 0;\n            for (int i = 0; i < currentPath.size() - 2; i++) {\n                for (int j = i + 1; j < currentPath.size() - 1; j++) {\n                    temp += getCost(currentPath.get(i), currentPath.get(j));\n                }\n            }\n        }\n    }\n            Object[] shortPath = shortestPath.toArray();\n    int totalDistance = 0;\n    for (int i = 0; i < shortPath.length; i++) {\n        if (i + 1 == shortPath.length) {\n            break;\n        }\n        totalDistance += getCost((String) shortPath[i],\n                (String) shortPath[i + 1]);\n    }\n\n    return totalDistance;\n}\n```\n\n\nI also have a helper method...\n\n```\n    private void djAux(String startVertex, String endVertex, Node previousNode,\n        Node currentNode, Stack<Node> visited,\n        ArrayList<String> shortestPath, ArrayList<String> currentPath,\n        int lowestPath) {\n\n    Object[] map = getAdjacentVertices(currentNode.name).keySet().toArray();\n    for (int i = 0; i < map.length; i++) {\n        if (!currentPath.contains(map[i])\n                && !currentNode.previous.contains(map[i])) {\n            currentNode = new Node((String) map[i]);\n            temp += getCost(visited.peek().name, currentNode.name);\n            visited.push(currentNode);\n            currentPath.add(currentNode.name);\n            djAux(startVertex, endVertex, previousNode, currentNode,\n                    visited, shortestPath, currentPath, lowestPath);\n        } else if (i == map.length - 1) {\n            if (shortestPath.size() == 0) {\n                shortestPath.add(\"None\");\n                temp = -1;\n            }\n        }\n\n    }\n\n    if (currentNode.name.equals(endVertex)) {\n        if ((lowestPath > 0 && temp < lowestPath && temp != -1)\n                || lowestPath < 0) {\n            shortestPath.clear();\n            lowestPath = new Integer(temp);\n            alpha = true;\n            for (String s : currentPath) {\n                shortestPath.add(s);\n            }\n        }\n    }\n}\n```\n\n\nAnd the node class\n\n```\n    public static class Node {\n    ArrayList<String> previous;\n    String name;\n\n    public Node() {\n        name = null;\n        previous = new ArrayList<String>();\n    }\n\n    public Node(String name) {\n        this.name = name;\n        previous = new ArrayList<String>();\n    }\n}\n```\n\n\nHere is the getCost() method\n\n```\n    public int getCost(String startVertexName, String endVertexName) {\n    if (!getAdjacentVertices(startVertexName).containsKey(endVertexName)) {\n        return 0;\n    }\n    return getAdjacentVertices(startVertexName).get(endVertexName);\n\n}\n```\n\n\nI tried debugging this but could not find why some values weren't printing out.\n\nCan someone help?\n\nThank you in advance.\n\nEdits: I figured out how to update the cost. see above. \n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Error in Dijkstra's shortest path algorithm implementation (using C++ STL)\r\n                \r\nI have tried to implement Dijkstra's algorithm in C++ using std::priority_queue.The function \"dijsktra\"  will take input as 2 nodes, the source vertex and the destination vertex. However, I am getting incorrect answers every time. Kindly help me out and tell me where I have erred. My code-\n```\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <stdio.h>\n#include <vector>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#define inf 9999999\nusing namespace std;\n\nmap <int,int> vis;\nvector <vector <pair <int,int> > > adj(100);\nvector <int> dist(100);\n\nvoid dijkstra(int u,int t)\n{\n    priority_queue <pair <int,int> > q;\n    int b,w,i;\n    q.push({0,u});\n    vis[u]=1;\n    \n    while(!q.empty())\n    {\n        u = q.top().second; q.pop();\n        \n        if(!vis[u])\n        {\n            vis[u]=1;\n            for(i=0;i<adj[u].size();i++)\n            {\n                b = adj[u][i].first; w = adj[u][i].second;\n                if(dist[b]>dist[u]+w)\n                {\n                    dist[b] = dist[u] + w;\n                    q.push({-dist[b],b});\n                }\n            }\n        }\n    }\n    \n    cout << dist[t];\n}\n\n\nint main()\n{\n    int i,j,k,n,m,x,y,w,t;\n    \n    cin >> n >> m;\n    for(i=0;i<m;i++)\n    {\n        cin >> x >> y >> w;\n        adj[x].push_back({y,w});\n        adj[y].push_back({x,w});\n    }\n    \n    cin >> t;\n    \n    for(i=1;i<=n;i++)\n    {\n        dist[i]=inf;\n    }\n    \n    dijkstra(1,t);\n}\n```\n\n    ", "Answer": "\r\nMistake:\nYour code is not working due to ```\nvis[u] = 1```\n which never lets you enter the for loop.\nActually there is no need of having a ```\nvisited array```\n in ```\nDijkstra algorithm```\n (atleast for this case). But using ```\nvisited array```\n here will decrease the time complexity and when there are negative edges it will be tricky, so be careful there.\n```\n#include <iostream>\n#include <vector>\n#include <queue>\n#define inf 9999999\n\nstd::vector <std::vector <std::pair <int,int> > > adj(100);\nstd::vector <int> dist(100);\n\nvoid dijkstra(int u,int t)\n{\n    std::priority_queue <std::pair<int, int>> q;\n    int b, w, i;\n\n    q.push({0, u});\n    while(!q.empty()) {\n        u = q.top().second; \n        q.pop();\n        for(i = 0; i < adj[u].size(); i++) {\n            b = adj[u][i].first; w = adj[u][i].second;\n            if(dist[b] > dist[u] + w) {\n                dist[b] = dist[u] + w;\n                q.push({-dist[b], b});\n            }\n        }\n    }\n    \n    std::cout << dist[t];\n}\n\n\nint main()\n{\n    int i, n, m, x, y, w, t;\n    \n    std::cin >> n >> m;\n    for(i = 0;i < m; i++) {\n        std::cin >> x >> y >> w;\n        adj[x].push_back({y, w});\n        adj[y].push_back({x, w});\n    }\n    \n    std::cin >> t;\n    \n    for(i = 0; i < n; i++) {\n        dist[i] = inf;\n    }\n     \n    // making the source distance to 0\n    dist[0] = 0;\n    \n    dijkstra(0,t);\n}\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Error in Implementation of Dijkstra's Algorithm\r\n                \r\nI am trying to attempt Dijkstra's with an Adjacency list, I can't figure out why I'm failing the test cases.\n\n```\nNode * n = list[source].head;\nwhile(n)\n{\n    q.push(n);\n    v[n->b] = n->w;\n    n = n->next;\n}\n\nwhile(!q.empty())\n{\n    n = q.front();\n    i = n->b;\n    o = list[i].head;\n    q.pop();\n\n    while(o)\n    {\n        if(!v[o->b]) \n        {\n            q.push(o);\n            v[o->b] = v[i] + o->w;\n        } \n        else if(v[o->b] > v[i] + o->w)\n        {\n            v[o->b] = v[i] + o->w;   \n        }\n        o = o->next;\n    }\n}\n\ni = 0;\nwhile(i < vertices)\n{\n    if(i != node)\n        printf(\"%d \", v[i] ? v[i] : -1);\n    i++;\n}\ncout<<\"\\n\";\n```\n\n\nI am passing trivial test cases.\n\nExample Input: (x y w),\n1 2 3,\n1 3 4,\n1 4 5,\n3 5 101,\n\nSource is 1.\n\nOutput:\n3 4 5 5 \n\nExample 2:\n1 2 24\n1 4 20\n3 1 3\n4 3 12\n\nSource is 1.\n\nOutput: 24 3 15\n\nHowever, I am failing the more sophisticated test cases.\n    ", "Answer": "\r\nIt seems you are confusing the two arrays - one for which vertex is already visited, and one for the optimal special distances(i.e. optimal distance to the vertices found so far). Let's denote the visited array with ```\nv```\n and the optimal distance array with ```\ndist```\n.\n\nIn this statement: \n\n```\nif(v[o->b] > v[i] + o->w)\n```\n\n\nYou need to be using ```\ndist```\n instead of ```\nv```\n.\n\nAfter you pop a node you need to check if it is visited. If it is visited, continue on to the next node. Otherwise mark it as visited and execute the remaining logic.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "What is wrong with my dijkstras algorithm\r\n                \r\nSo I've been working on this for hours and I'm extremely frustrated. I don't understand what I'm doing wrong. \n\nI'm using Dijkstra's Algorithm to find the shortest paths between a source vertex, and 4 other vertices using an adjacency matrix. The idea behind this is that there are 5 cities and flights going to and from them, and I need to find the cheapest ticket price, taking into account layovers. \nI'm following the algorithm out of my book, which is in pseudocode, and the code on the following website: http://vinodcse.wordpress.com/2006/05/19/code-for-dijkstras-algorithm-in-c-2/\nThe problem I'm having is that in the nested for loop on the website, the counter i starts at 1, and I believe this is the reason why the distances from the source vertex to all the vertices are correct, except the first one which is unchanged at 999. \n\nExample:\n\n\n  Current Distance: 999 220 0 115 130 \n  \n  Predecessors: 0 3 0 2 2 \n\n\nAll of those distances are correct--even if I change the source vertex--except for the first one which remains unchanged.\n\nIf I change the counter i to 0, it messes up every distance, i.e.\n\n\n  Current Distance: 0 105 0 0 0 \n\n\nAnyway, Please help. Here is the relevant code.\n\n```\nvoid Graph::findDistance(int startingVertex)\n{\n  for(int i=0; i<MAX;i++)\n  {\n    currentDistance[i] = 999;\n    toBeChecked[i] = 1;\n    predecessor[i] = 0; \n  }\n\n  currentDistance[startingVertex]=0;\n  bool flag=true;\n  int v;\n  while(flag)\n  {\n    v=minimum();\n\n    toBeChecked[v]=0;\n\n    for(int i=1; i<MAX;i++) //here is where i think im going wrong\n    {\n      if(adjecencyMatrix[v][i]>0)   \n      {\n        if(toBeChecked[i]!=0)\n        {\n          if(currentDistance[i] > currentDistance[v]+adjecencyMatrix[v][i][0].ticketPrice)\n          {\n            currentDistance[i] = currentDistance[v]+adjecencyMatrix[v][i][0].ticketPrice;\n            predecessor[i]=v;\n          }\n        }\n      }\n    }\n\n    flag = false;\n    for(int i=1; i<MAX;i++)\n    {\n      if(toBeChecked[i]==1)\n      flag=true;\n    }\n  }\n}\n\nint Graph::minimum()\n{\n  int min=999;\n  int i,t;\n  for(i=0;i<MAX;i++)\n  {\n    if(toBeChecked[i]!=0)\n    {\n      if(min>=currentDistance[i])\n      {\n        min=currentDistance[i];\n        t=i;\n      }\n    }\n  }\n  return t;\n}\n```\n\n    ", "Answer": "\r\nShouldn't this check\n\n```\n  if(adjecencyMatrix[v][i]>0)   \n```\n\n\nbe done with ```\nadjecencyMatrix[v][i][0].ticketPrice```\n, like the rest of the comparisons?\n\nIf ```\nadjecencyMatrix[v][i]```\n is an array, it is getting converted to a pointer, and that pointer will always compare greater than 0. Array-to-pointer decay strikes again :)\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra Algorithm in Java\r\n                \r\nI have some troubles implementing Dijkstra algorithm in Java.\nI use this (first) pseudocode: http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\nLine 15 you need to get the vertex with the lowest distance.\nBut how can I save the distance with the according distance.\nNote: vertex is defined as an Integer.  \n\nMy solutions that didn't work properly:\n\n\nMap with K = vertex, V = distance, Problem: long searching to get min dist\nSortedMap with K = distance, V = vertex, Problem: almost every distance is defined as Integer.MAX_VALUE\n\n\nSo I am looking for a fast way to save a vertex to a distance and it should be easy to get the vertex with min dist.\n    ", "Answer": "\r\nTry using a PriorityQueue. That way, you can simply remove the head, as it would have the minimum distance of all vertices.\n\nSee more information about PriorityQueue here:\nhttp://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm question\r\n                \r\nIn the code below:\n\n```\n#define MAX_VERTICES 260000\n\n#include <fstream>\n#include <vector>\n#include <queue>\n#define endl '\\n'\nusing namespace std;\n\nstruct edge {\n    int dest;\n    int length;\n};\n\nbool operator< (edge e1, edge e2) {\n    return e1.length > e2.length;\n}\n\nint C, P, P0, P1, P2;\nvector<edge> edges[MAX_VERTICES];\nint best1[MAX_VERTICES];\nint best2[MAX_VERTICES];\n\nvoid dijkstra (int start, int* best) {\n    for (int i = 0; i < P; i++) best[i] = -1;\n    best[start] = 0;\n    priority_queue<edge> pq;\n    edge first = { start, 0 };\n    pq.push(first);\n    while (!pq.empty()) {\n        edge next = pq.top();\n        pq.pop();\n        if (next.length != best[next.dest]) continue;\n        for (vector<edge>::iterator i = edges[next.dest].begin(); i != edges[next.dest].end(); i++) {\n            if (best[i->dest] == -1 || next.length + i->length < best[i->dest]) {\n                best[i->dest] = next.length + i->length;\n                edge e = { i->dest, next.length+i->length };\n                pq.push(e);\n            }\n        }\n    }\n}\n\nint main () {\n    ifstream inp(\"apple.in\");\n    ofstream outp(\"apple.out\");\n\n    inp >> C >> P >> P0 >> P1 >> P2;\n    P0--, P1--, P2--;\n    for (int i = 0; i < C; i++) {\n        int a, b;\n        int l;\n        inp >> a >> b >> l;\n        a--, b--;\n        edge e = { b, l };\n        edges[a].push_back(e);\n        e.dest = a;\n        edges[b].push_back(e);\n    }\n\n    dijkstra (P1, best1);           // find shortest distances from P1 to other nodes\n    dijkstra (P2, best2);           // find shortest distances from P2 to other nodes\n\n    int ans = best1[P0]+best1[P2];  // path: PB->...->PA1->...->PA2\n    if (best2[P0]+best2[P1] < ans) \n        ans = best2[P0]+best2[P1];  // path: PB->...->PA2->...->PA1\n    outp << ans << endl;\n    return 0;\n}\n```\n\n\nWhat is this: ```\nif (next.length != best[next.dest]) continue;```\n used for?  Is it to avoid us situations where going through the loop will give us the same answer that we already have?\n\nThanks!\n    ", "Answer": "\r\nThat line is a way to handle the fact that c++'s priority_queue does not have a decrease_key function. \n\nThat is, when you do ```\npq.push(e)```\n and there is already an edge with the same destination in the heap you would prefer to decrease the key of the edge already in the heap. This is not easily done with c++'s priority_queue and so a simple way to handle it is to allow multiple edges in the heap corresponding to the same destination and ignoring all but the first (for each dest) that you pop from the heap.\n\nNote that this changes the complexity from ```\nO(ElogV)```\n to ```\nO(ElogE)```\n.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How to modify Dijkstra algorithm to fit A* search algorithm in C++\r\n                \r\nI'm trying to implement A* Search Algorithm in my Dijkstra algorithm. (Preferably, without the use of STL)\nFor each vertex I have an X and Y value, for example\n```\nVERTEX | X-VALUE | Y-VALUE\n1        13        42\n2        22        25\n3        73        98\n```\n\nI've looked at a few A* Search algorithms, and some such as GeeksForGeeks has a 600+ line implementation of the A* search algorithm, whereas I've discovered that all that needs to be changed is the cost function of an Dijkstra algorithm. However, I am unsure how to calculate the cost function for the A* search algorithm.\nI have the following Dijkstra algorithm.\n```\n#include<iostream>\n#include<stdio.h>\nusing namespace std;\n#define INFINITY 9999\n#define max 5\nvoid dijkstra(int G[max][max],int n,int startnode);\n\nint main()\n{\n    int G[max][max]= {{0,1,0,3,10},{1,0,5,0,0},{0,5,0,2,1},{3,0,2,0,6},{10,0,1,6,0}};\n    int n=5;\n    int u=0;\n    dijkstra(G,n,u);\n    return 0;\n}\n\nvoid dijkstra(int G[max][max],int n,int startnode)\n{\n    int cost[max][max],distance[max],pred[max];\n    int visited[max],count,mindistance,nextnode,i,j;\n\n    for(i=0; i<n; i++)\n        for(j=0; j<n; j++)\n            if(G[i][j]==0)\n                cost[i][j]=INFINITY;\n            else\n                cost[i][j]=G[i][j];\n\n    for(i=0; i<n; i++)\n    {\n        distance[i]=cost[startnode][i];\n        pred[i]=startnode;\n        visited[i]=0;\n    }\n\n    distance[startnode]=0;\n    visited[startnode]=1;\n    count=1;\n    while(count<n-1)\n    {\n        mindistance=INFINITY;\n        for(i=0; i<n; i++)\n            if(distance[i]<mindistance&&!visited[i])\n            {\n                mindistance=distance[i];\n                nextnode=i;\n            }\n        visited[nextnode]=1;\n        for(i=0; i<n; i++)\n            if(!visited[i])\n                if(mindistance+cost[nextnode][i]<distance[i])\n                {\n                    distance[i]=mindistance+cost[nextnode][i];\n                    pred[i]=nextnode;\n                }\n        count++;\n    }\n    for(i=0; i<n; i++)\n        if(i!=startnode)\n        {\n            cout<<\"\\nDistance of node\"<<i<<\"=\"<<distance[i];\n            cout<<\"\\nPath=\"<<i;\n            j=i;\n            do\n            {\n                j=pred[j];\n                cout<<\"<-\"<<j;\n            }\n            while(j!=startnode);\n        }\n}\n\n```\n\nAny help would be appreciated, thanks.\n    ", "Answer": "\r\nI would suggest to have structs in your code.\nYou need to have another A* Node structure(make in inner struct of vertex node) which will hold \"f,g,h\" values.\nAnd each vertex of the graph will have this A* node struct.\nI have done a similar task where I had to find shortest and second shortest path but in JAVA.\n```\nimport java.util.*;\n\n// Class to hold each vertex in our graph\nclass Vertex {\n\n    private String label;\n    private int xCoordinate;\n    private int yCoordinate;\n\n    private AStarNode aStarNode;\n\n    AStarNode getAStarNode() {\n        return aStarNode;\n    }\n\n    class AStarNode{\n\n        double f,g,h;\n\n        AStarNode() {\n            f= g=h = Double.MAX_VALUE;\n        }\n    }\n\n    private AdjacencyList adjacencyList;\n\n    public String getLabel() {\n        return label;\n    }\n\n    public void setLabel(String label) {\n        this.label = label;\n    }\n\n    public int getxCoordinate() {\n        return xCoordinate;\n    }\n\n    public void setxCoordinate(int xCoordinate) {\n        this.xCoordinate = xCoordinate;\n    }\n\n    public int getyCoordinate() {\n        return yCoordinate;\n    }\n\n    public void setyCoordinate(int yCoordinate) {\n        this.yCoordinate = yCoordinate;\n    }\n\n    public AdjacencyList getAdjacencyList() {\n        return adjacencyList;\n    }\n\n    public Vertex(String label, int xCoordinate, int yCoordinate) {\n        this.label = label;\n        this.xCoordinate = xCoordinate;\n        this.yCoordinate = yCoordinate;\n        adjacencyList = new AdjacencyList();\n        aStarNode = new AStarNode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Vertex vertex = (Vertex) o;\n        return label.equals(vertex.label);\n    }\n\n    @Override\n    public int hashCode() {\n        return label.length();\n    }\n}\n\n// Class to hold the final result of each algorithm\nclass Result {\n    private String shortestPath;\n    private int distance;\n    private int numberOfNodesTraversed;\n\n    public Result(String shortestPath, int distance, int numberOfNodesTravesed) {\n        this.shortestPath = shortestPath;\n        this.distance = distance;\n        this.numberOfNodesTraversed = numberOfNodesTravesed;\n    }\n\n    public String getShortestPath() {\n        return shortestPath;\n    }\n\n    public int getDistance() {\n        return distance;\n    }\n\n    public int getNumberOfNodesTraversed() {\n        return numberOfNodesTraversed;\n    }\n}\n\n// An edge having the destination label and the weight associated\nclass Edge {\n    private String vertexLabel;\n    private int weight;\n\n    private boolean isActive;\n\n    public String getVertexLabel() {\n        return vertexLabel;\n    }\n\n    public void setVertexLabel(String vertexLabel) {\n        this.vertexLabel = vertexLabel;\n    }\n\n    public int getWeight() {\n        return weight;\n    }\n\n    public void setWeight(int weight) {\n        this.weight = weight;\n    }\n\n    public boolean isActive() {\n        return isActive;\n    }\n\n    public void setActive(boolean active) {\n        isActive = active;\n    }\n\n    public Edge(String vertexLabel, int weight) {\n        this.vertexLabel = vertexLabel;\n        this.weight = weight;\n        isActive = true;\n    }\n}\n\n// List of edges for a particular vertex\nclass AdjacencyList {\n\n    private Node first,last;\n\n    AdjacencyList() {\n        first = last = null;\n    }\n    public void addNode(Edge edge) {\n        Node newNode = new Node(edge);\n        if(first == null) {\n            first = last = newNode;\n        } else {\n            last.next = newNode;\n            last = newNode;\n        }\n    }\n\n\n    public void printAdjacencyLabels() {\n        Node start = first;\n        while(start!=null) {\n            System.out.print(start.edge.getVertexLabel()+\"(\"+start.edge.getWeight()+\")  \");\n            start = start.next;\n        }\n    }\n\n    Node getFirst() {\n        return first;\n    }\n\n    Edge getParticularEdge(String label) {\n        Node start = first;\n        while(start!=null) {\n            if(start.getEdge().getVertexLabel().equals(label)) {\n                return start.getEdge();\n            }\n            start = start.next;\n        }\n        return null;\n    }\n}\n\n// Class representing each node in adjancy list\n// List will hold each edge details\nclass Node {\n    Edge edge;\n    Node next;\n    Node(Edge edge) {\n        this.edge = edge;\n        next = null;\n    }\n    Edge getEdge() {\n        return edge;\n    }\n    Node getNext() {\n        return next;\n    }\n}\n\npublic class Main {\n\n    // Data structure that will hold all the vertices details and there edges\n    static Vertex[] graph;\n\n    static String startLabel,goalLabel;\n\n    // Function to get the index of a vertex based on the label\n    private static int getVertexNo(String label) {\n        for(int i=0;i<graph.length;i++) {\n            if(graph[i].getLabel().equals(label)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    // Function to add an edge to a vertex\n    private static void addEdge(String sourceLabel, Edge edge) {\n        graph[getVertexNo(sourceLabel)].getAdjacencyList().addNode(edge);\n    }\n\n\n    // Function to print the result of shortest path algos\n    private static void printResult(Result result) {\n        System.out.println(\"Vertices on path : \"+result.getShortestPath());\n        System.out.println(\"Length of this path : \"+result.getDistance());\n    }\n\n    // Function to find minimum f value of unvisited vertex\n    static int findMinVertexAStar(boolean[] visited) {\n\n        double minDistance = Double.MAX_VALUE;\n        int minIndex =-1;\n\n        for(int i=0;i<graph.length;i++) {\n            if(!visited[i] && minDistance > graph[i].getAStarNode().f) {\n                minDistance = graph[i].getAStarNode().f;\n                minIndex = i;\n            }\n        }\n        return minIndex;\n    }\n\n    // Function to compute eucledian distance between 2 vertices\n    static double getEucledianDistance(Vertex first, Vertex second) {\n        return Math.sqrt(Math.pow(first.getxCoordinate() - second.getxCoordinate(),2)\n                + Math.pow(first.getyCoordinate() - second.getyCoordinate(),2));\n    }\n\n    // Function to get shortest path based on A star Algo\n    static Result shortestPath() {\n\n        int startVertex = getVertexNo(startLabel);\n        int goalVertex = getVertexNo(goalLabel);\n        Vertex finalVertex = graph[goalVertex];\n\n        int[] parentArray = new int[graph.length];\n\n        boolean[] visitedVertices = new boolean[graph.length];\n\n        int totalNumberOfNodesVisited =0;\n\n        // Initialise data structures\n        for(int i=0;i<graph.length;i++) {\n            visitedVertices[i] = false;\n            parentArray[i] = -1;\n            graph[i].getAStarNode().f = Double.MAX_VALUE;\n        }\n\n        graph[startVertex].getAStarNode().f =0;\n        graph[startVertex].getAStarNode().g =0;\n        graph[startVertex].getAStarNode().h =0;\n\n        // Lopp over until goal vertex is found\n        while(true) {\n\n            totalNumberOfNodesVisited++;\n            int currIndex = findMinVertexAStar(visitedVertices);\n            visitedVertices[currIndex] = true;\n\n            if(currIndex==goalVertex) {\n                break;\n            }\n\n            Node startNode= graph[currIndex].getAdjacencyList().getFirst();\n\n            // Traverse each edge of current vertex\n            while (startNode!=null && startNode.getEdge().isActive()) {\n\n\n                int edgeVertexIndex= getVertexNo(startNode.getEdge().getVertexLabel());\n\n                if(!visitedVertices[edgeVertexIndex]) {\n\n                    double parentG = graph[currIndex].getAStarNode().g;\n                    double newG = parentG+startNode.getEdge().getWeight();\n                    double newH =   getEucledianDistance(graph[edgeVertexIndex],finalVertex);\n\n                    if((newG + newH) < graph[edgeVertexIndex].getAStarNode().f) {\n                        graph[edgeVertexIndex].getAStarNode().f = newG + newH;\n                        graph[edgeVertexIndex].getAStarNode().g = newG ;\n                        graph[edgeVertexIndex].getAStarNode().h = newH;\n                        parentArray[edgeVertexIndex] = currIndex;\n                    }\n                }\n                startNode = startNode.getNext();\n            }\n\n        }\n        String shortestPath =\"\";\n        int currIndex = goalVertex;\n        int distance = (int)graph[goalVertex].getAStarNode().g;\n\n        // Computing the shortest path from parent array\n        while(true) {\n            int nextIndex = parentArray[currIndex];\n            shortestPath = graph[currIndex].getLabel()+\" \"+shortestPath;\n            if(nextIndex == -1) {\n                break;\n            }\n            currIndex = nextIndex;\n        }\n\n        return new Result(shortestPath,distance,totalNumberOfNodesVisited);\n\n    }\n\n    // Function to get second shortest path based on A star Algo\n    static Result secondShortestPath(String shortestPathStr) {\n\n        String[] vertices = shortestPathStr.split(\"\\\\s+\");\n        Edge[] edgesOnShrtestPath = new Edge[vertices.length-1];\n\n        // Fill up array of edges in shortest path\n        for(int i=0;i<vertices.length-1;i++) {\n            String startLabel = vertices[i];\n            String endLabel = vertices[i+1];\n            int startVertexNo = getVertexNo(startLabel);\n            edgesOnShrtestPath[i] = graph[startVertexNo].getAdjacencyList().getParticularEdge(endLabel);\n        }\n\n        Result shortestAStarResult =null;\n        // Lopp over each edge in shortest path\n        for(int edge=0;edge<edgesOnShrtestPath.length;edge++) {\n\n            edgesOnShrtestPath[edge].setActive(false);\n\n            Result currResult = shortestPath();\n            // Compute again shortest path with given edge inactive\n            if(shortestAStarResult ==null || shortestAStarResult.getDistance() > currResult.getDistance()) {\n                shortestAStarResult = currResult;\n            }\n            // Make edge active again\n            edgesOnShrtestPath[edge].setActive(true);\n\n        }\n        return shortestAStarResult;\n    }\n}\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "modifying Dijkstra’s algorithm to undirected graph\r\n                \r\nQuestion: Adapt Dijkstra’s algorithm to solve the SSSP problem on a weighted undirected\ngraph.\n\nsurely there's no need to modify the algorithm? if the graph is undirected then its just a directed graph with edges both ways, right?\n    ", "Answer": "\r\nYes, Dijkstra's algorithm works for both types of graphs, and in the undirected case you just allow to use an edge from both end points. \n\nIf your implementation works with graphs given by an adjacency list, then this information is already implicitly given by this data structure: in the undirected case you list, for an edge (u,v), u in the adjacency of v and v in the adjacency of u, which gives you both directions. So you can use the same implementation for both types of graphs. \n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "modifying Dijkstra’s algorithm to undirected graph\r\n                \r\nQuestion: Adapt Dijkstra’s algorithm to solve the SSSP problem on a weighted undirected\ngraph.\n\nsurely there's no need to modify the algorithm? if the graph is undirected then its just a directed graph with edges both ways, right?\n    ", "Answer": "\r\nYes, Dijkstra's algorithm works for both types of graphs, and in the undirected case you just allow to use an edge from both end points. \n\nIf your implementation works with graphs given by an adjacency list, then this information is already implicitly given by this data structure: in the undirected case you list, for an edge (u,v), u in the adjacency of v and v in the adjacency of u, which gives you both directions. So you can use the same implementation for both types of graphs. \n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "File input for Dijkstra's algorithm\r\n                \r\nI am having trouble figuring out how to read an input file with java. The file has the following format:\n\n```\nu1 v1 w1\nu2 v2 w2\n...\num vm wm\n-1\nsource\n```\n\n\nEach 3-tuple denotes an edge, which is specified by its source-vertex, its destination-vertex, and its weight (example: newyork boston 30). The description of the graph is terminated by a “flag”, the integer -1. A string follows this flag; this string is the name of the source vertex for the Dijkstra shortest-path algorithm. That is, you are to determine and print out the shortest path from this source vertex to every other vertex in the graph.\nHere is my current work.\n\n```\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.PriorityQueue;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\nclass Vertex implements Comparable<Vertex> {\n\n    public final String name;\n    public Edge[] adjacencies;\n    public double minDistance = Double.POSITIVE_INFINITY;\n    public Vertex previous;\n\n    public Vertex(String argName) {\n        name = argName;\n    }\n\n    public String toString() {\n        return name;\n    }\n\n    public int compareTo(Vertex other) {\n        return Double.compare(minDistance, other.minDistance);\n    }\n\n}\n\nclass Edge {\n    public final Vertex target;\n    public final double weight;\n\n    public Edge(Vertex argTarget, double argWeight) {\n        target = argTarget;\n        weight = argWeight;\n    }\n}\n\npublic class Dijkstra {\n    public static void computePaths(Vertex source) {\n        source.minDistance = 0.;\n        PriorityQueue<Vertex> vertexQueue = new PriorityQueue<Vertex>();\n        vertexQueue.add(source);\n\n        while (!vertexQueue.isEmpty()) {\n            Vertex u = vertexQueue.poll();\n\n            // Visit each edge exiting u\n            for (Edge e : u.adjacencies) {\n                Vertex v = e.target;\n                double weight = e.weight;\n                double distanceThroughU = u.minDistance + weight;\n                if (distanceThroughU < v.minDistance) {\n                    vertexQueue.remove(v);\n\n                    v.minDistance = distanceThroughU;\n                    v.previous = u;\n                    vertexQueue.add(v);\n\n                }\n\n            }\n        }\n    }\n\n    public static ArrayList<Vertex> getShortestPathTo(Vertex target) {\n        ArrayList<Vertex> path = new ArrayList<Vertex>();\n        for (Vertex vertex = target; vertex != null; vertex = vertex.previous)\n            path.add(vertex);\n\n        Collections.reverse(path);\n        return path;\n    }\n\n    public String[] readFile(String fileName) throws FileNotFoundException {\n        Scanner input = new Scanner(new File(fileName));\n        String line = \"\";\n        while (input.hasNext()) {\n            line = line.concat(input.nextLine());\n        }\n        String[] graph = line.split(\"\");\n        return graph;\n\n    }\n\n    public static void main(String[] args) throws FileNotFoundException {\n\n        final String TEST = \"/TestInput.txt\";\n        Scanner input = new Scanner(new File(TEST));\n        String line = \"\";\n        while (input.hasNext()) {\n            line = line.concat(input.nextLine());\n        }\n        String[] graph = line.split(\" \");\n\n        for (int i = 0; i < graph.length; i++) {\n            System.out.println(graph[i]);\n        }\n\n        Vertex[] verts = new Vertex[graph.length];\n        Edge[] edges = new Edge[graph.length];\n        Vertex v1 = new Vertex(\"\");\n        Vertex v2 = new Vertex(\"\");\n        Vertex source = new Vertex(\"\");\n        int count = 0;\n\n        outerloop: for (int i = 0; i < (graph.length); i++) {\n\n            if (graph[i].equals(\"-1\")) {\n                // do algorithm initialization here w/ source\n            }\n            if (i == 0) {\n                verts[i] = new Vertex(graph[i]);\n                count++;\n            } else {\n                innerloop: for (int j = count; j >= 0; j--) {\n                    if (i / 3 == 0) {\n\n                        if (graph[i].equals(verts[j].toString())) {\n                            break innerloop;\n                        } else if (j == 0) {\n                            verts[count] = new Vertex(graph[i]);\n                            v1 = verts[count];\n                            count++;\n                        }\n                    }\n\n                    if (i / 3 == 1) {\n\n                        if (graph[i].equals(verts[j])) {\n                            break innerloop;\n                        } else if (j == 0) {\n                            verts[count] = new Vertex(graph[i]);\n                            v2 = verts[count];\n                            count++;\n                        }\n                    }\n                    if (i / 3 == 2) {\n\n                    }\n                }\n            }\n\n        }\n\n        for (int i = 0; i < verts.length; i++) {\n            System.out.println(verts[i]);\n        }\n    }\n}\n```\n\n\nSo my only problem is how to get from the given .txt file format to a graph. Any suggestions are welcome.\n    ", "Answer": "\r\nUse a Scanner to parse the file data. For each tuple, if the source vertex hasn't been created, create it, otherwise find it in the pre-existing graph -- create a search function. Do the same for the target vertex. Next, create an edge with a weight equal to the third token in the tuple, and add the target vertex to the edge. Finally, add the edge to the adjacency list of the source vertex.\n\nFor the previously mentioned search function, you can implement something that can search through each vertex of the graph starting from any vertex. Recursion will be necessary.\n\n```\npublic static Vertex search(Vertex src, String name);\n```\n\n\nA simpler solution is to keep a list of all the vertices you create as your constructing the graph and search through that.\n\n```\npublic static Vertex search(List<Vertex> vertices, String name);\n```\n\n\nWhen your done constructing the graph and you have the name of the vertex where Dijkstra's algorithm will begin, you can use the search function to get a reference to the vertex.\n\n```\nDijkstra.computePath(search(vertices, startVertexName));\n```\n\n\nAnd, that's it. Here's an example of how to parse your file data:\n\n```\nList<Vertex> vertices = new ArrayList<Vertex>();\nString src = \n    \"Pittsburgh Philadelphia 323 \"+\n    \"Pittsburgh Ohio 125 \"+\n    \"Ohio Philadelphia 400 \"+\n    \"-1 Ohio\";\n            //new Scanner(new File(fileName));\nScanner scnr = new Scanner(src); \nString src, target;\nint weight;\nwhile(scnr.hasNext())\n{\n    src = scnr.next();\n    if(src.equals(\"-1\"))\n        break;\n    else {\n        target = scnr.next();\n        weight = scnr.nextInt();\n    }\n    //call search(), implement logic in addToGraph()\n    addVertexToGraph(src, target, weight, vertices);    \n}   \nString startVertexName = scnr.next();\nscnr.close();\n```\n\n\nNote that Scanner.next returns the next token separated by white space (the default delimiter), so your file data must be formatted that way.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra algorithm not working even though passes the sample test cases\r\n                \r\nSo I have followed Wikipedia's pseudocode for Dijkstra's algorithm as well as Brilliants. https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Pseudocode https://brilliant.org/wiki/dijkstras-short-path-finder/. Here is my code which doesn't work. Can anyone point in the flaw in my code?\n```\n# Uses python3\n\nfrom queue import Queue\n\nn, m = map(int, input().split())\nadj = [[] for i in range(n)]\n\nfor i in range(m):\n    u, v, w = map(int, input().split())\n    adj[u-1].append([v, w])\n    adj[v-1].append([u, w])\n\nx, y = map(int, input().split())\nx, y = x-1, y-1\nq = [i for i in range(n, 0, -1)]\n#visited = set()\n# visited.add(x+1)\ndist = [float('inf') for i in range(len(adj))]\ndist[x] = 0\n# print(adj[visiting])\nwhile len(q) != 0:\n\n    visiting = q.pop()-1\n    for i in adj[visiting]:\n        u, v = i\n        dist[u-1] = dist[visiting]+v if dist[visiting] + \\\n            v < dist[u-1] else dist[u-1]\n# print(dist)\nif dist[y] != float('inf'):\n    print(dist[y])\nelse:\n    print(-1)\n\n\n\n```\n\n    ", "Answer": "\r\nYour algorithm is not implementing Dijkstra's algorithm correctly. You are just iterating over all nodes in their input order and updating the distance to the neighbors based on the node's current distance. But that latter distance is not guaranteed to be the shortest distance, because you iterate some nodes before their \"turn\". Dijkstra's algorithm specifies a particular order of processing nodes, which is not necessarily the input order.\nThe main ingredient that is missing from your algorithm, is a priority queue. You did import from ```\nQueue```\n, but never use it. Also, it lacks the marking of nodes as visited, a concept which you seemed to have implemented a bit, but which you commented out.\nThe outline of the algorithm on Wikipedia explains the use of this priority queue in the last step of each iteration:\n\n\nOtherwise, select the unvisited node that is marked with the smallest tentative distance, set it as the new \"current node\", and go back to step 3.\n\n\nThere is currently no mechanism in your code that selects the visited node with smallest distance. Instead it picks the next node based on the order in the input.\nTo correct your code, please consult the pseudo code that is available on that same Wikipedia page, and I would advise to go for the variant with priority queue.\nIn Python you can use ```\nheapq```\n for performing the actions on the priority queue (```\nheappush```\n, ```\nheappop```\n).\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Error in Dijkstra algorithm in android\r\n                \r\nI am implementing the 'Dijkstra algorithm' in Android for making an app for Metro Network.\nWhen I click on the button to show the path, it stops the app.\nI have explicitly defined the graph to store in array adj[][].\n\nMetroRoute class\n\n```\npublic class MetroRoute extends Activity implements OnClickListener{\n\nEditText source, destination;\nTextView Route;\nButton button;\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    // TODO Auto-generated method stub\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.metroroute);\n    source = (EditText) findViewById(R.id.etSource);\n    destination = (EditText) findViewById(R.id.etDest);\n    button = (Button) findViewById(R.id.bGetroute);\n    Route = (TextView) findViewById(R.id.tvRoute);\n    button.setOnClickListener(this);\n}\n\n@Override\npublic void onClick(View v) {\n    // TODO Auto-generated method stub\n    int count, i;\n    count = findpath(Integer.parseInt(source.getText().toString()), Integer.parseInt(destination.getText().toString()), path, sdist );\n    if(sdist!=0)\n      {\n       Route.setText(\"Shortest distance is : \\n\" + sdist);\n       Route.setText(\"Shortest Path is : \");\n       for( i=count;i>1;i--)\n         Route.setText(path[i] + \" -> \");\n       Route.setText(path[i]);\n      }\n\n      else\n       Route.setText(\"There is no path from source to destination node\\n\");\n }\n\nint adj[][] = {{3,2,3,0,5},{1,2,3,4,5},{1,2,3,4,5},{1,2,3,4,5},{1,2,3,4,5}}; \nint MAX = 10, TEMP = 0, PERM =1, INFINITY = 9999, path[], sdist=0, n=5 ;\n\nprivate class Node {\n    int predecessor[];\n    int dist[];            /*minimum distance of node from source*/\n    int status[];\n}\n\nint findpath(int s,int d,int path[],int sdist)\n{\n Node state = new Node();\n int i, min=0, count=0, current, newdist, u, v ;\n sdist=0;\n\n /* Make all nodes temporary */\n\n for(i=1;i<=n;i++)\n {\n  state.predecessor[i]=0;\n  state.dist[i] = INFINITY;\n  state.status[i] = TEMP;\n }\n\n /*Source node should be permanent*/\n\n state.predecessor[s]=0;\n state.dist[s] = 0;\n state.status[s] = PERM;\n\n /*Starting from source node until destination is found*/\n\n current=s;\n\n while(current!=d)\n {\n  for(i=1;i<=n;i++)\n  {\n   /*Checks for adjacent temporary nodes */\n   if ( adj[current][i] > 0 && state.status[i] == TEMP )\n   {\n    newdist=state.dist[current] + adj[current][i];\n    /*Checks for Relabeling*/\n    if( newdist < state.dist[i] )\n     {\n      state.predecessor[i] = current;\n      state.dist[i] = newdist;\n     }\n    }\n   }\n\n   /*Search for temporary node with minimum distance make it current node*/\n\n   min=INFINITY;\n   current=0;\n\n   for(i=1;i<=n;i++)\n   {\n    if(state.status[i] == TEMP && state.dist[i] < min)  \n    {\n     min = state.dist[i];\n     current=i;\n    }\n   }\n\n   if(current==0)                       /*If Source or Sink node is isolated*/\n    return 0;\n   state.status[current]=PERM;\n  }\n\n /* Getting full path in array from destination to source   */\n\n while( current!=0 )\n {\n  count++;\n  path[count]=current;\n  current=state.predecessor[current];\n }\n\n /*Getting distance from source to destination*/\n\n for(i=count;i>1;i--)\n {\n  u=path[i];\n  v=path[i-1];\n  sdist+= adj[u][v];\n }\n\n return (count) ;\n }\n\n}\n```\n\n    ", "Answer": "\r\nThe easiest way to find the problem is to use the console of the adk to see the exceptions thrown by the device. When you start your app from your IDE (Eclipse, Android Studio) in a virtual device, or even your smartphone, you will get logcat-messages, which will contain the exceptions like for example the NullPointerException. You will then find the lines where the exception is thrown and then you can do some further testing (like writing some values to the console (System.Out.println(...) or System.err.println(...)). \n\nYou can post your log so we can take a look at it.\n\nYou may want to use my Dijkstra-implementation, too:\n\n```\npublic static ArrayList<Integer> dijkstra(Graph graph, Integer orig,\n        Integer dest, TreeMap<Integer, Integer> distance,\n        ArrayList<Integer> nodesLeft) throws Exception \n{\n    Iterator<Integer> iterator = graph.getNodes().iterator();\n    Integer next;\n\n\n    TreeMap<Integer, ArrayList<Integer>> paths = new TreeMap<Integer, ArrayList<Integer>>();\n\n\n    while (iterator.hasNext()) {\n        next = iterator.next();\n\n        distance.put(next, -1);\n\n        paths.put(next, new ArrayList<Integer>());\n\n    }\n    distance.put(orig, 0);\n    nodesLeft.addAll(Collections.unmodifiableCollection(graph.getNodes()));\n\n    while (!nodesLeft.isEmpty()) {\n        int u = nodesLeft.get(0);\n\n        Collection<Integer> edgesOfU = graph.getEdges(u);\n        Iterator<Integer> itEdgesOfU = edgesOfU.iterator();\n        int nextEdge;\n        while (itEdgesOfU.hasNext()) {\n            nextEdge = itEdgesOfU.next();\n            if (nodesLeft.contains(nextEdge)) {\n\n\n                int distU = distance.get(u);\n                if ((distance.get(nextEdge) == -1)\n                        || (distU + 1) < distance.get(nextEdge)) {\n                    distance.put(nextEdge, distU + 1);\n\n\n                    ArrayList<Integer> tmpList = paths.get(nextEdge);\n\n\n                    for (int a : paths.get(u)) {\n                        tmpList.add(a);\n                    }\n\n                    tmpList.add(nextEdge);\n                }\n            }\n        }\n        nodesLeft.remove(0);\n    }\n    return paths.get(dest);\n}\n```\n\n\nI used some self-defined Graphs with the following Interface:\n\n```\nimport java.util.Collection;\n\npublic interface Graph {\n\n\n    public Integer addNode();\n\n\n    public void removeNode(Integer id) throws Exception,\n        UnsupportedOperationException;\n\n\n    public Collection<Integer> getNodes();\n\n\n    public boolean addEdge(Integer orig, Integer dest) throws Exception;\n\n\n    public boolean removeEdge(Integer orig, Integer dest) throws Exception,\n        UnsupportedOperationException;\n\n    public Collection<Integer> getEdges(Integer orig) throws Exception;\n}\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra algorithm. Min heap as a min-priority queue\r\n                \r\nI'm reading about Dijkstra's algorithm in CLRS, Third Edition (p. 662). Here is a part from the book I don't understand:\n\n\n  If the graph is sufficiently sparse — in particular, ```\nE = o(V^2/lg V)```\n — we can improve the algorithm by implementing the min-priority queue with a binary min-heap.\n\n\nWhy should the graph be sparse?\n\n\n\nHere is another part:\n\n\n  Each DECREASE-KEY operation takes time ```\nO(log V)```\n, and there are still\n  at most E such operations.\n\n\nSuppose my graph looks like this:\n\n\n\nI'd like to calculate the shortest path from 1 to 6 and use the min-heap approach. So first off, I add all my nodes to a min priority queue. After building a min heap, the min node is the source node (since its distance to itself is 0). I extract it and update distances of all its neighbors. \n\nThen I need to call ```\ndecreaseKey```\n on the node with the lowest distance to make a new minimum of the heap. But how do I know its index in constant time? \n\nNode\n\n```\nprivate static class Node implements Comparable<Node> {\n\n    final int key;\n    int distance = Integer.MAX_VALUE;\n    Node prev = null;\n\n    public Node(int key) {\n        this.key = key;\n    }\n\n    @Override\n    public int compareTo(Node o) {\n        if (distance < o.distance) {\n            return -1;\n        } else if (distance > o.distance) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n\n    @Override\n    public String toString() {\n        return \"key=\" + key + \" distance=\" + distance;\n    }\n\n    @Override\n    public int hashCode() {\n        return key;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof Node)) {\n            return false;\n        }\n        Node other = (Node) obj;\n        return key == other.key;\n    }\n}\n```\n\n\nMinPriorityQueue\n\n```\npublic static class MinPriorityQueue {\n\n    private Node[] array;\n    private int heapSize;\n\n    public MinPriorityQueue(Node[] array) {\n        this.array = array;\n        this.heapSize = this.array.length;\n    }\n\n    public Node extractMin() {\n        Node temp = array[0];\n        swap(0, heapSize - 1, array);\n        heapSize--;\n        sink(0);\n        return temp;\n    }\n\n    public boolean isEmpty() {\n        return heapSize == 0;\n    }\n\n    public void buildMinHeap() {\n        for (int i = heapSize / 2 - 1; i >= 0; i--) {\n            sink(i);\n        }\n    }\n\n    public void decreaseKey(int index, Node key) {\n        if (key.compareTo(array[index]) >= 0) {\n            throw new IllegalArgumentException(\"the new key must be greater than the current key\");\n        }\n        array[index] = key;\n        while (index > 0 && array[index].compareTo(array[parentIndex(index)]) < 0) {\n            swap(index, parentIndex(index), array);\n            index = parentIndex(index);\n        }\n    }\n\n    private int parentIndex(int index) {\n        return (index - 1) / 2;\n    }\n\n    private int left(int index) {\n        return 2 * index + 1;\n    }\n\n    private int right(int index) {\n        return 2 * index + 2;\n    }\n\n    private void sink(int index) {\n        int smallestIndex = index;\n        int left = left(index);\n        int right = right(index);\n        if (left < heapSize && array[left].compareTo(array[smallestIndex]) < 0) {\n            smallestIndex = left;\n        }\n        if (right < heapSize && array[right].compareTo(array[smallestIndex]) < 0) {\n            smallestIndex = right;\n        }\n        if (index != smallestIndex) {\n            swap(smallestIndex, index, array);\n            sink(smallestIndex);\n        }\n    }\n\n    public Node min() {\n        return array[0];\n    }\n\n    private void swap(int i, int j, Node[] array) {\n        Node temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n\n}\n```\n\n    ", "Answer": "\r\n\n  Why should the graph be sparse?\n\n\nThe running time of Dijkstra's algorithm depends on the combination of the underlying data structure and the graph shape (edges and vertices).\n\nFor example, using a linked list would require ```\nO(V²)```\n time, i.e. it only depends on the number of vertices.\nUsing a heap would require ```\nO((V + E) log V)```\n, i.e. it depends on both the number of vertices and the number of edges.\n\nIf your E is sufficiently smaller compared to V (as in ```\nE << V² / logV```\n), then using heap becomes more efficient.\n\n\n  Then I need to call ```\ndecreaseKey```\n on the node with the lowest distance to make a new minimum of the heap. But how do I know its index in constant time?\n\n\nIf you're using a binary heap, then ```\nextractMin```\n always runs in ```\nO(log V)```\n time and gives you the node with the lowest distance (a.k.a. key).\n\nFor example, if you're implementing the binary min-heap as an array ```\nH```\n, then the first element of the array ```\nH[1]```\n (by convention we count from ```\n1```\n) will always be the element with the lowest distance, so finding it only takes ```\nO(1)```\n.\n\nHowever, after each ```\nextractMin```\n, ```\ninsert```\n or ```\ndecreaseKey```\n you have to run ```\nswim```\n or ```\nsink```\n to restore the heap condition, consequently moving the lowest-distance node to the top. This takes ```\nO(log V)```\n.\n\nWhat you also want to do is maintain a mapping between keys in the heap and vertices, as mentioned in the book: \"make sure that\nvertices and corresponding heap elements maintain handles to each other\" (briefly discussed in section 6.5).\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Complexity in Dijkstras algorithm\r\n                \r\nSo I've been attempting to analyze a specialized variant of Dijkstras algorithm that I've been working on. I'm after the worst case complexity.\n\nThe algorithm uses a Fibonacci Heap which in the case of the normal Dijkstra would run in O(E + V log V).\n\nHowever this implementation needs to do a lookup in the inner loop where we update neighbours. This lookup will execute for every edge and will be in logarithmic time, where the lookup is in a datastructure that contains all edges. Also the graph has the restriction that no node will have more than 4 neighbours.\n\nO(Vlog V) is the complexity for the outer loop but I'm not sure what the worst case will be for the inner loop. I'm thinking that since that each edge in the graph will be checked O(E) times and each edge will take logarithmic time it should be Elog E which should exceed Vlog V and result in O(Elog E) complexity for the algorithm.\n\nAny insight would be awesome!\n    ", "Answer": "\r\nThe amortized complexity of Decrease-Key on Fibonacci Heap is O(1), that is to say you have |E| such operations on the Fibonacci Heap, the total cost will be O(E). Also you have |V| Extract-Min operations, which cost O(lnV) each. So the total cost is O(E+VlnV).\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "AFP Dijkstra's Shortest Path Algorithm\r\n                \r\nFor the AFP entry Dijkstra's Shortest Path Algorithm, both the proof outline and proof document were nonexistent *. Unfortunately, I did not find an ```\nIsaMakefile```\n either to build those documents locally. What is the best way to get those documents?\n\nAnother question, as the ```\nDijkstra.thy```\n depends on a lot of other theories, is there a way to load everything faster?\n\n*) It is fixed now.\n    ", "Answer": "\r\n(There seems to be something broken at AFP right now, please tell the editors about it.)\n\nIn general, you can download the sources of AFP entries and produce the documents yourself like this:\n\n\nGet and unpack all AFP sources -- downloading separate entries is offered as well, but then you have to disentangle dependencies manually.\nInvoke ```\nisabelle build```\n like this:\n\n```\nisabelle build -d afp-2013-03-02 -o document=pdf -v Dijkstra_Shortest_Path\n```\n\n\nHere ```\nafp-2013-03-02```\n is the directory that was obtained by unpacking the current AFP sources.\n\n\nSee also the Isabelle System manual about \"Isabelle sessions and build management\", which is all new in Isabelle2013.\n\nSee ```\nisabelle build -b```\n there to make things load faster, by producing persistent heap images from sessions.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "define dijkstra algorithm by STL library\r\n                \r\nhere  code for dijkstra algorithm by using macros and STL library\n\n```\n#include<iostream>\n#include<vector>\n#include<set>\n#include<list>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<utility>\nusing namespace std;\nvector<vector<pair<int,int> > >G;\n/*\n  definitions:\n  G.size-number of vertices\n  G[i].size() is number of vertices directly reachable from vertex with index i\n  G[i][j].first  is index of j-th vertex reachable from vertex i\n  G[i][j].second  is length of edge heading  from vertex to vertex G[i][j].first\n*/\n\n#define N 6\ntypedef pair<int,int> ii;\ntypedef vector<ii> vii;\ntypedef vector<vii>vvii;\n#define size(a) int ((a).size())\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define tr(c,it) for(typeof((c).begin() it=(c).begin();it!=(c).end();it++));\n#define present(c,x) ( (c).find(x)!=(c).end())\n#define cpresent(c,x) (find(all(c),x)! =(c).end())\ntypedef vector<int>vi;\npriority_queue<ii,vector<ii>,greater<ii> >Q;\nvi D(N,987654321);\n\nvoid dijkastra(){\n    D[0]=0;\n    Q.push(ii(0,0));\n    while(!Q.empty()){\n        ii top=Q.top();\n        Q.pop();\n        int v=top.second,d=top.first;\n        /*\n         // this check is very important\n        // we analyze each vertex only once\n        // the other occurrences of it on queue (added earlier) \n        // will have greater distance\n                            */\n        if(d<=D[v]){\n            //iterate through all outcoming edge from v\n            tr(G[v],it){\n            }\n        }\n    }\n}\n\nint main(){\n    return 0;\n}\n```\n\n\nWhen I compile it, it gives me the following errors:\n\n```\nmacros_disktra\\allmacros_disktra\\allmacros_disktra.cpp(49): error C2146: syntax error : missing ')' before identifier 'it'\n>c:\\users\\dato\\documents\\visual studio 2010\\projects\\allmacros_disktra\\allmacros_disktra\\allmacros_disktra.cpp(49): error C3861: 'typeof': identifier not found\n>c:\\users\\dato\\documents\\visual studio 2010\\projects\\allmacros_disktra\\allmacros_disktra\\allmacros_disktra.cpp(49): error C2065: 'it' : undeclared identifier\n>c:\\users\\dato\\documents\\visual studio 2010\\projects\\allmacros_disktra\\allmacros_disktra\\allmacros_disktra.cpp(49): error C2065: 'it' : undeclared identifier\n>c:\\users\\dato\\documents\\visual studio 2010\\projects\\allmacros_disktra\\allmacros_disktra\\allmacros_disktra.cpp(49): error C2143: syntax error : missing ';' before ')'\n>c:\\users\\dato\\documents\\visual studio 2010\\projects\\allmacros_disktra\\allmacros_disktra\\allmacros_disktra.cpp(49): error C2143: syntax error : missing ';' before ')'\n>c:\\users\\dato\\documents\\visual studio 2010\\projects\\allmacros_disktra\\allmacros_disktra\\allmacros_disktra.cpp(49): error C2059: syntax error : ')'\n========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========\n```\n\n\nI don't understand where error is.\n    ", "Answer": "\r\nThe problem is at:\n\n```\n#define tr(c,it) for(typeof((c).begin() it=(c).begin();it!=(c).end();it++));\n```\n\n\n```\ntypeof(```\n does not have a matching ```\n)```\n\n\nYou might also want to consider using typedef for things like iterators and complex STL types i.e.\n\n```\ntypedef vector<pair<int,int> > vpairs;\ntypedef vector<vpairs > vvpairs;\ntypedef vpairs::iterator vp_iter;\ntypedef vvpairs::iterator vvp_iter;\nvvpairs G;\n```\n\n\nAnd if you really want to use macros then:\n\n```\n#define tr_vp(c,it) for(vp_iter it=(c).begin();it!=(c).end();it++)\n#define tr_vvp(c,it) for(vvp_iter it=(c).begin();it!=(c).end();it++)\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Python - Dijkstra's algorithm on a large scale\r\n                \r\nI have a large network, about 400 nodes, and what I'm trying to do is calculate every possible route you can make on the network. That means, the nodes traversed and the total weighting of the route from Node 1 to Node 2, Node 1 to Node 3 up to Node 1 to Node 400. \n\nThen, from Node 2 to Node 3, Node 2 to Node 4 up to Node 2 to Node 400.\n\n(Just FYI, I have very limited knowledge of python, day to day I work with HTML/CSS)\n\nI've been using this code that I discovered: http://bytes.com/topic/python/insights/877227-dijkstras-algorithm-finding-shortest-route\n\nWhich is great, however, due to the size of my network, calculating every possible way to go from any node to any node takes a very, very long time. \n\nFrom what I understand of the algorithm I linked to, it visits each node in turn from the start node, and gives it a value which is the weighting required to get to that node from the start (I imagine it also records the route required to get to each specific node?). If it finds a shorter route to get to that node it overwrites what it had before. Once it gets to the destination it stops and returns the result. \n\nI figure, if the script can be edited slightly, can it instead of stopping at a specific destination, just visit all the nodes as it usually would and print out a report of the shortest route and weighting to each one? That way, the algorithm would only have to be run a total of 400 times, once for each possible starting position.\n\nThanks for any advice you can give and I hope that was clear!\n    ", "Answer": "\r\nYou can use the Python graph module NetworkX which has methods for all pairs shortest paths (weighted and unweighted). And they are optimized in the sense that they use the best known algorithms for such tasks.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra algorithm on scheme\r\n                \r\nI have created pretty much every procedure needed for my Dijkstra algorithm to work but I am having some problems with the shortestpath procedure, I wrote it on paper but can't get it to work on scheme\n\n```\n(define (shortestpath origin destiny graph)\n  (define (update x)\n    (begin\n      (set! new-dist (+ (dist-between n x graph)\n                         (dist-info-node (get-info-node i n))))\n      (when (< new-dist (dist-info-node (get-info-node i v)))\n        (update-previous-dist-node i v new-dist n))))\n```\n\n\nAbove is the main procedure which is giving me an error on the 4th line\n\n```\n(define (get-info-node i n)\n  (define (get-info-node-aux i n cont)\n    (if (equal? n (vector-ref (no-info-no i) cont))\n        (vector-ref i cont)\n        (get-info-node-aux i n (+ cont 1))))\n  (get-info-node-aux i n 0))\n\n\n(define (dist-info-node i)\n  (vector-ref i 1))\n\n   (define new-dist 0)\n```\n\n\nThe error I'm getting is \"expand: unbound identifier in module in: i\" on the 4th line\n\n```\n(define (update-previous-dist-node! i n d a)\n  (define (update-previous-dist-node!-aux i n d a cont)\n    (if (equal? n (vector-ref (no-info-no i) cont))\n        (begin\n          (modify-dist! (vector-ref i cont) d)\n          (modify-previous! (vector-ref i cont) a))\n        (update-previous-dist-node!-aux i n d a (+ cont 1))))\n  (update-previous-dist-node!-aux i n d a 0))\n```\n\n\nAll procedures are defined as they should but the main one is not working properly. This was wrote on paper first, I have tried everything and I must be missing something\n    ", "Answer": "\r\nIt looks to me as though you've structured your program as a number of small functions defined inside of a larger one.  This is a bad idea.  The advantage (inner procedures can refer to origin, destination and graph) is outweighed by the inability to test the helper functions independently. If I were debugging this function, I would:\n\n\npull the inner functions up to the top level,\ncreate purpose statements for each one, and\nwrite a few test cases for each one.\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra algorithm for iPhone\r\n                \r\nIt is possible to easily use the GPS functionality in the iPhone since sdk 3.0, but it is explicitly forbidden to use Google's Maps.\nThis has two implications, I think:\n\n\nYou will have to provide maps yourself  \nYou will have to calculate the shortest routes yourself.\n\n\nI know that calculating the shortest route has puzzled mathematicians for ages, but both Tom Tom and Google are doing a great job, so that issue seems to have been solved.\nSearching on the 'net, not being a mathematician myself, I came across the Dijkstra Algorithm. Is there anyone of you who has successfully used this algorithm in a Maps-like app in the iPhone?\nWould you be willing to share it with me/the community?\nWould this be the right approach, or are the other options?\nThank you so much for your consideration.\n    ", "Answer": "\r\nI do not believe Dijkstra's algorithm would be useful for real-world mapping because, as Tom Leys said (I would comment on his post, but lack the rep to do so), it requires a single starting point.  If the starting point changes, everything must be recalculated, and I would imagine this would be quite slow on a device like the iPhone for a significantly large data set.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How to implement Dijkstras Algorithm with Adjacency lists\r\n                \r\nMy program is reading input from a text file in the order of \n\n```\nA\nB \nC\n\nA B 10\nA C 5\nB A 3\nB C 2\nC A 4\nC B 1\n```\n\n\nand stores the data into a graph which is represented by an adjacency list. I want to write a program that finds the shortest path from A to all other nodes using Dijkstra's Algorithm. \n\nI have watched several videos but still couldn't quite get how to implement the algorithm as the examples use graphs which are represented as adjacency matrices. Below is the program:\n\n```\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <locale>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INFINITE -1\n\n/* node */\nstruct Node\n{\n    char key;\n    int distance;\n    Node *next;\n};\n\n/* GraphNode */\nstruct GraphNode\n{\n    char key;\n    Node *listpointer;\n};\n\n/* Add nodes to the front of the list */\nvoid AddNodeToFront(Node*& listpointer, char newkey, int newdistance)\n{\n   Node *temp;\n   temp = new Node;\n   temp->key = newkey;\n   temp->distance=newdistance;\n   temp->next = listpointer;\n   listpointer = temp;\n}\n\n/* printf LLnodes */\nvoid PrintLLnodes(Node*& listpointer)\n{\n    Node *temp;\n    temp = listpointer;\n    while(temp!=NULL)\n    {\n        printf(\"to node %c dist: %d \\n\", temp->key, temp->distance);\n        temp=temp->next;\n    }\n }\n\n/* Implement the Graph class  */\nclass Graph\n{\n    private:\n        vector<GraphNode> adjlist;\n        int totalgraphnodes;\n    public:\n        Graph(){totalgraphnodes = 0;}\n        ~Graph(){}\n        void AddNewGraphNode(char newgraphnode);\n        void AddNewEdgeBetweenGraphNodes(char A, char B, int distance);\n        void PrintAllGraphNodesWithCosts();\n        void DijkstrasAlgorithm(char sourcenode);\n        int GetTotalNodes() { return totalgraphnodes; }\n};\n\n/* graph class functions */\nvoid Graph::AddNewGraphNode(char newgraphnode){\n    totalgraphnodes++;\n    GraphNode temp;\n    temp.key=newgraphnode;\n    temp.listpointer = NULL;//important\n    adjlist.push_back(temp);\n}\n\nvoid Graph::AddNewEdgeBetweenGraphNodes(char A, char B, int distance)\n{\n     //find which node A is\n     int a;\n     for (a = 0;adjlist.size();a++)\n     {\n         if (A == adjlist[a].key) break;\n     }\n     AddNodeToFront(adjlist[a].listpointer, B, distance);\n}\n\nvoid Graph::PrintAllGraphNodesWithCosts()\n{\n     for (unsigned int a = 0;a < adjlist.size();a++){\n         printf(\"From Node %c: \\n\", adjlist[a].key);\n         PrintLLnodes(adjlist[a].listpointer);\n     }  \n}\n\n**// implement Dijkstra's Algorithm\nvoid Graph::DijkstrasAlgorithm(char sourcenode)**\n{\n    int distance[adjlist.size()];\n    char state[adjlist.size()];\n\n    // setting the initial distance and state of the first node\n    distance[0] = 0;\n    state[0] = 'p';\n\n    // assigning all distance and state to temp and infinite\n    for(int i = 1; i <= adjlist.size(); i++)\n    {\n        distance[i] = INFINITE;\n        state[i] = 't';\n    }\n\n    // get the sourcenode from the adjlist in Graph\n    unsigned int a;\n    for(a = 0; a <= adjlist.size(); a++)\n    {\n        if(sourcenode == adjlist[a].key) { break; } // break when found 'A'\n    }\n\n    // assign sourcenode listpointer to current\n    Node *current;\n    current = adjlist[a].listpointer;\n\n    bool stilltempvertex = true;\n    while(stilltempvertex) {}   \n}\n\n/* declare a new Graph */\nGraph mygraph;\nmain( /*int argc, char** argv */)\n{ \n\n    /* call Dijkstra  */\n    mygraph.DijkstrasAlgorithm('A'); //always from A in this program\n\n    /* Print answer in the required format */\n}\n```\n\n\nAs far as implementation is concerned, all the nodes and edges are read correctly (I have ommited some code to allow for readability, but mygraph has nodes A, B, C and the corresponding edges.), its just that I cant seem to figure out how to properly implement the algorithm for this one.\n\nThe nodes are readfrom the file and stored in a vector ajdlist. Each graphnode then has its own linked list which points to adjacent nodes in the graph.\n\nAnyone could take me step by step through with the algorithm implementation on this? Thanks in advance.\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra Algorithm with all negative weights\r\n                \r\nLet's assume that I have a graph G and all of the edges in G have negative weights without negative cycle.\n\nIf I run this by Dijkstra Algorithm, will it find a shortest path?\n\nThanks\n    ", "Answer": "\r\nIf the graph is undirected, with only negative edge weights and without cycles, then the graph is a tree and there it should work. At least as long as you look for simple paths, without going back and forth over and over again.\nE.g. ```\nA---B---C```\n all weights are -1. Then the shortest simple path from A to C would be A,B,C, but if you drop the simple restriction, then there is no shortest path anymore. Instead it would look like this A,B,A,B,A,B, ... ,C.\n\nIf your graph is directed, the example from @h3yduck can be made directed and is a counterexample that shows that Dijkstras Algorithm does not work in this case.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Shortest path of Dijkstra algorithm\r\n                \r\nI want to implement an iterator for the shortest path in my edge weighted graph.\n\n```\npublic class Graph<T> implements GraphADT<T> {\n\n    protected final int DEFAULT_CAPACITY = 10;\n    protected int numVertices; // number of vertices in the graph\n    protected boolean[][] adjMatrix; // adjacency matrix\n    protected T[] vertices; // values of vertices\n    protected double weight[][];\n```\n\n\nI tried many implementation and even try my own, but I think I don't understand the logic off Dijkstra algorithm yet, can anyone explain to me or give their implemention on Java\n\nHere is my attempt to make an in implementation\n\n```\npublic Iterator<T> iteratorShortestPathW1(int startIndex, int targetIndex) {\n    ArrayUnorderedList<T> resultList = new ArrayUnorderedList<T>();\n    if (!indexIsValid(startIndex) || !indexIsValid(targetIndex)) {\n        return resultList.iterator();\n    }\n\n    Iterator<T> it = iteratorShortestPathW2(startIndex,\n            targetIndex);\n    while (it.hasNext()) {\n        resultList.addToRear(vertices[((Integer) it.next()).intValue()]);\n    }\n    return resultList.iterator();\n}\n\npublic Iterator<T> iteratorShortestPathW(T startVertex, T targetVertex) {\n    return iteratorShortestPathW1(getIndex(startVertex),\n            getIndex(targetVertex));\n}\n\nprotected Iterator<T> iteratorShortestPathW2(int startIndex, int targetIndex) {\n    int index = startIndex;\n    int[] tamcaminho = new int[numVertices];\n    int[] predecessor = new int[numVertices];\n    LinkedQueue<Integer> traversalQueue = new LinkedQueue<Integer>();\n    ArrayUnorderedList<Integer> resultList = new ArrayUnorderedList<Integer>();\n\n    if (!indexIsValid(startIndex) || !indexIsValid(targetIndex) || (startIndex == targetIndex)) {\n        return (Iterator<T>) resultList.iterator();\n    }\n\n    boolean[] visited = new boolean[numVertices];\n    for (int i = 0; i < numVertices; i++) {\n        visited[i] = false;\n    }\n\n    traversalQueue.enqueue(startIndex);\n    visited[startIndex] = true;\n    tamcaminho[startIndex] = 0;\n    predecessor[startIndex] = -1;\n\n    while (!traversalQueue.isEmpty() && (index != targetIndex)) {\n        System.out.print(\"acima\");\n        index = traversalQueue.dequeue();\n        int menor = 999;\n        for (int i = 0; i < numVertices; i++) {\n            if (adjMatrix[index][i] && !visited[i]) {\n                tamcaminho[i] = (int) weight[index][i];\n\n                if (menor > tamcaminho[i]) {\n                    menor = tamcaminho[i];\n                }\n            }\n        }\n\n        for (int i = 0; i < numVertices ; i++) {\n            if (tamcaminho[i] == menor) {                  \n                System.out.print(\"abaixo\");\n                visited[index] = true;\n                traversalQueue.enqueue(i);\n                predecessor[i] = index;\n\n            }\n        }\n    }\n    if (index != targetIndex) {\n        return (Iterator<T>) resultList.iterator();\n    }\n\n    LinkedStack<Integer> stack = new LinkedStack<Integer>();\n    index = targetIndex;\n    stack.push(new Integer(index));\n    do {\n        index = predecessor[index];\n        stack.push(new Integer(index));\n    } while (index != startIndex);\n\n    while (!stack.isEmpty()) {\n        resultList.addToRear(((Integer) stack.pop()));\n    }\n\n    return (Iterator<T>) resultList.iterator();\n}\n```\n\n    ", "Answer": "\r\nFrom Cormen Introduction to algorithm.\nDijkstra’s algorithm maintains a set S of vertices whose final shortest-path\nweights from the source s have already been determined. The algorithm repeatedly\nselects the vertex u 2 V S with the minimum shortest-path estimate, adds u\nto S, and relaxes all edges leaving u. In the following implementation, we use a\nmin-priority queue Q of vertices, keyed by their d values.\n\n```\nDIJKSTRA.G;w; s/\n1 INITIALIZE-SINGLE-SOURCE.G; s/\n2 S D ;\n3 Q D G:V\n4 while Q ¤ ;\n5 u D EXTRACT-MIN.Q/\n6 S D S [ fug\n7 for each vertex  2 G:AdjOEu\n8 RELAX.u; ;w/DIJKSTRA.G;w; s/\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Shortest Path Algorithm issue\r\n                \r\nSo I'm trying to code Dijkstra's shortest path algorithm in C++.  For some reason, it's not adding up the distances correctly...\n\nHere is what I have so far for code.  You can ignore the section where I am copying the path to the stack because I know it's not complete yet. Any ideas where I'm going wrong?\n\n```\n#include <fstream>\n#include \"matrix.h\"\n#include <list>     // STL container\nusing namespace std;\n//---------------------------------------------------------------------------\n\nconst int INFIN = 100000;\nconst int size = 8;\n\ndouble a[] = {\n        0, 0, 5, 0, 0, 2, 3, 0,     //length matrix ( #9, page 276)\n        4, 0, 6, 0, 7, 0, 5, 0,\n        0, 3, 0, 9, 2, 6, 0, 7,\n        3, 0, 2, 0, 1, 0, 7, 6,\n        0, 5, 0, 1, 0, 0, 4, 0,\n        0, 0, 2, 0, 8, 0, 9, 0,\n        1, 2, 3, 0, 0, 6, 0, 0,\n        5, 0, 8, 0, 2, 0, 9, 0\n    };\n\n        //  Global declarations for L Matrix and begin and end node\n\nMatrix L(size,size,a);          //length matrix\nint begin, end;\n\nvoid path(long* D, int* P);     //function prototype for shortest path algorithm\n\nMatrix Warshall(Matrix M);\n\nvoid main()\n{\n    int i, u;\n    long D [size+1];            //distance functions\n    int P [size+1];             //prior vertices in path\n\n    cout << \"\\nLength Matrix: \" << L;\n    cout << \"\\nPaths that exist:\" << Warshall(L);\n\n    for (i=1; i <= size; i++)  {\n        D[i] = INFIN;           //initialize distance functions\n        P[i] = 0;\n}\n\n\ncout << \"\\nFind distance from vertex #\";\ncin >> begin;\ncout <<   \"                to vertex #\";\ncin >> end;\n\nif (begin == end) exit(1);\nif (begin < 0 || end < 0) exit(1);\nif (begin > size || end > size) exit(1);\n\npath(D,P);\n\ncout  << \"\\nShortest distance from \\nvertex #\"\n     << begin << \" to vertex #\"\n     << end << \" is \" << D[end];\n\n// u = end;\nlist<int> stack;            // work path backwards\nwhile (1) {\n    stack.push_front(end);\n    stack.push_front(begin);\n    break;\n    }\n\n    cout    << \"\\nusing path:\\n\";\n    cout << \"\\t\" << stack.front();\n    stack.pop_front();\n    while (stack.size()) {\n        cout << \" -> \" << stack.front();\n        stack.pop_front();\n    }\n    getch();\n}\n\nvoid path(long* D, int* P) {\n    int i, u, dist;\n    int U[size+1];\n    for (i=1; i <= size; i++)\n    U[i] = 0;\n    U[begin] = 1;                                       // add first vertex;\n    D[begin] = 0;\n    u = begin;\n    do {                            // until find end vertex\n        for (i = 1; i <= size; i++)  {\n        dist = L.element(u,i);          // distance from u to i\n        if( D[u] + dist < D[i]) {\n            D[i] = D[u] + dist;\n            P[i] = u;\n            }\n   }\n        dist = 38000;           // reset distance value to large value\n        int min;\n        for(i = 1; i <= size; i++) {\n    if(L.element(u,i) != 0) {\n            if(L.element(u,i) < dist && U[i] != 1) {\n                dist = L.element(u,i);\n                min = i;\n            }\n        }\n    }\n    u = min;\n    U[u] = 1;\n    cout << \"Min is \" << min << endl;\n    } while (u != end);\n}            \n```\n\n    ", "Answer": "\r\n```\nif( D[u] + dist < D[i]) {\n            D[i] = D[u] + dist;\n            P[i] = u;\n\n\n}\n```\n\n\nshould be\n\n```\nif( D[u] + dist < D[i] && dist != 0) {\n            D[i] = D[u] + dist;\n            P[i] = u;\n\n\n}\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm Runtime\r\n                \r\nI know that this might not be a good question, but I was wondering how it's runtime is O(ElogV).\n\nHere's the Algo\n\n```\nDIJKSTRA(G,w,s)\nS=null\nPQ=G.V\nwhile (PQ!=null)\n    u=Extract-Min(PQ)\n    S=S+u \\\\Add node u to set S(explored vertices)\n    foreach (v in adj(u))\n        if(d(v) > d(u) + w(u,v) )\n            d(v) = d(u) + w(u,v)  \\\\at this step, we need to update the priority d(v) of vertex (v) in the Priority Queue. \n```\n\n\nTime complexity is given by O(E logV), as the inner loop runs at most E times, and for each loop iteration, it take O(logV) time to update the priority d(v) of vertex (v) in Priority Queue PQ. But this operation requires us to search for the vertex (v) in Priority Queue PQ, which takes O(v) time. So how is the Time complexity O(E logV). \n\n--Edit--\nIf fact the while loop is executed V times and each time an element is extracted from PQ, which means that running time is O(V logV), right?             \n    ", "Answer": "\r\nYou don't need to search for ```\nv```\n in the priority queue. When you insert in the priority queue, you can keep a reference to the inserted node in an array indexed by ```\nv```\n, and look it up instantly.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm Python\r\n                \r\nGiven a graph and a source vertex in the graph, find the shortest paths from source to all vertices in the given graph.\nRead more here -> Link\nPlease go through my code and help me out by pointing what's wrong with my logic.\nMy code:\n```\nfrom collections import defaultdict\n\nglobal INT_MAX\nINT_MAX = 3 ** 38\n\n\nclass Graph:\n    def __init__(self, numofVertices):\n        self.vertList = defaultdict(list)\n        self.numofVertices = numofVertices\n\n    def addEdge(self, u, v, cost):\n        self.vertList[u].append((v, cost))\n        self.vertList[v].append((u, cost))\n\n    def minDist(self, dist, visited):\n        \n        for v in range(self.numofVertices):\n            if dist[v] < INT_MAX and v not in visited:\n                minIndex = v\n        return minIndex\n\n    def dijsktra(self, src):\n        dist = [INT_MAX] * self.numofVertices\n        dist[src] = 0\n        visited = set()\n\n        for _ in range(self.numofVertices):\n            minVertex = self.minDist(dist, visited)\n\n            visited.add(minVertex)\n\n            for nbr, edgeCost in self.vertList[minVertex]:\n                if dist[nbr] > dist[minVertex] + edgeCost and nbr not in visited:\n                    dist[nbr] = dist[minVertex] + edgeCost\n        return dist\n\n\ng = Graph(9)\ng.addEdge(0, 1, 4)\ng.addEdge(0, 7, 8)\ng.addEdge(1, 7, 11)\ng.addEdge(7, 8, 7)\ng.addEdge(7, 6, 1)\ng.addEdge(7, 1, 11)\ng.addEdge(1, 2, 8)\ng.addEdge(2, 3, 7)\ng.addEdge(2, 5, 4)\ng.addEdge(2, 8, 2)\ng.addEdge(6, 8, 6)\ng.addEdge(6, 5, 2)\ng.addEdge(5, 2, 4)\ng.addEdge(5, 3, 14)\ng.addEdge(5, 4, 10)\ng.addEdge(3, 4, 9)\nprint(g.dijsktra(0))\n```\n\nCurrent Output:\n```\n[0, 4, 15, 25, 21, 11, 9, 8, 15] # Index represents the vertex\n```\n\nExpected Output\n```\n[0, 4, 12, 19, 21, 11, 9, 8 ,14]\n```\n\nHere's the graph we are solving:\n\n    ", "Answer": "\r\nThe problem was with the function that checks the min distance, We need to update the current max so that we can compare it with other unvisited vertices and see if another vertex exists with a lesser value.\n```\ndef minDist(self, dist, visited):\n    max1 = 3 ** 38\n    minIndex = 0\n    for v in range(self.numofVertices):\n        if dist[v] < max1 and v not in visited:\n            max1 = dist[v]\n            minIndex = v\n    return minIndex\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "It's obligatory to check more than one time visited nodes when using Dijkstra's algorithm?\r\n                \r\nMe and my colleague are discussing a implementation of Dijkstra's algorithm. Here is the implementation using Python: \n\n```\ndef dijkstra(self, origin, destination):\n        \"\"\"Use Dijkstra's algorithm to find the cheapest path.\"\"\"\n\n        routes = Heap()\n        for neighbor in self.neighbors(origin):\n            price = self.get_price(origin, neighbor)\n            routes.push(Route(price=price, path=[origin, neighbor]))\n\n        visited = set()\n        visited.add(origin)\n\n        while routes:\n\n            # Find the nearest yet-to-visit airport\n            price, path = routes.pop()\n            airport = path[-1]\n            if airport in visited:\n                continue\n\n            # We have arrived! Wo-hoo!\n            if airport is destination:\n                return price, path\n\n            # Tentative distances to all the unvisited neighbors\n            for neighbor in self.neighbors(airport):\n                if neighbor not in visited:\n                    # Total spent so far plus the price of getting there\n                    new_price = price + self.get_price(airport, neighbor)\n                    new_path  = path  + [neighbor]\n                    routes.push(Route(new_price, new_path))\n\n            visited.add(airport)\n\n        return float('infinity')\n```\n\n\nThe controversial line here is:\n\n```\nif neighbor not in visited:\n```\n\n\nMy point is that this line must be replaced with something like\n\n```\nif neighbor not in visited or new_price < cost_so_far[neighbor]\n```\n\n\nIn all the implementations that I found of the algorithm says that you must check for the case when you reach a node with a cost lower than the current cost of the node. For example, the lines 17 and 18 of this pseudocode from Wikipedia:\n\n```\n1  function Dijkstra(Graph, source):\n2      dist[source] ← 0                                    // Initialization\n3\n4      create vertex set Q\n5\n6      for each vertex v in Graph:           \n7          if v ≠ source\n8              dist[v] ← INFINITY                          // Unknown distance from source to v\n9              prev[v] ← UNDEFINED                         // Predecessor of v\n10\n11         Q.add_with_priority(v, dist[v])\n12\n13\n14     while Q is not empty:                              // The main loop\n15         u ← Q.extract_min()                            // Remove and return best vertex\n16         for each neighbor v of u:                       // only v that is still in Q\n17             alt = dist[u] + length(u, v) \n18             if alt < dist[v]\n19                 dist[v] ← alt\n20                 prev[v] ← u\n21                 Q.decrease_priority(v, alt)\n22\n23     return dist[], prev[]\n```\n\n\nThe question is: Is my colleague's implementation correct or the code should be modified in order to check if you reach some neighbour with a price lower than the current one?\n\nNote: Here is the source code of my colleague's implementation.\n    ", "Answer": "\r\nSo, the question is whether the line in your code\n\n```\nif neighbor not in visited:\n```\n\n\ncan or must be replaced by\n\n```\nif neighbor not in visited or new_price < cost_so_far[neighbor]:\n```\n\n\nThe answer is: can, yes; must, no.\nAdding ```\nnew_price < cost_so_far[neighbor]```\n will not change anything in the flow of the algorithm, it will be false every time ```\nneighbor not in visited```\n is false.\n\nThe reason is how Dijkstra's algorithm works.\nEssentially, it builds a tree of shortest paths.\nWhenever an ```\nairport```\n is added to ```\nvisited```\n, it is considered to be in the tree: by this time, the algorithm has already found the shortest path to this ```\nairport```\n.\n\nAssume that at step ```\nx```\n, we add a certain airport ```\nA```\n to ```\nvisited```\n.\nFurther assume that at step ```\ny > x```\n, ```\ncost_so_far```\n to airport ```\nA```\n decreased.\nHow could it decrease?\nIt would require that some ```\nnew_price = price + self.get_price(airport, neighbor)```\n is less than the ```\nprice```\n at step ```\ny```\n.\nRecall now that ```\nroutes```\n is a priority queue, so it supplies ```\nprice```\ns in non-decreasing order.\nThe edges of the graph are also non-negative (otherwise, Dijkstra's algorithm indeed produces a wrong result and is not applicable).\nSo, we arrive at a contradiction: the new ```\nnew_price```\n is at least the old price, but turned out to be less than that.\n\nThe source of confusion is perhaps that the main loop of the implementation considers some routes one-by-one.\nEssentially, these routes correspond to edges of the graph.\nSo, there can be |E| routes, but only |V| of them will get accepted, all others will fail the condition ```\nif airport in visited:  continue```\n.\nIf we implement the algorithm so that each iteration of the main loop adds exactly one ```\nairport```\n to ```\nvisited```\n (exactly one vertex to the tree of shortest paths), the whole matter may become clearer.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm using Adjacency Matrix not finding correct distance/path from each node to every other node\r\n                \r\nI'm trying to write a program that builds a graph using an Adjacency Matrix and then finds the shortest path from each node to every other node using Dijkstra's Algorithm. My program is current not capable of finding the correct shortest paths every time. I also need to track the path, but I am unsure where to even start.\n\n```\nclass GraphD\n{\n\npublic:\n    GraphD();\n    void buildGraph(ifstream &infile);\n\n    void insertEdge(int from, int to, int distance);\n\n    void findShortestPath();\n\nprivate:\n    static const int MAXNODES = 101;\n    static const int infinity = 2147483647;\n    struct TableType\n    {\n         bool visited;\n         int dist;\n         int path;\n    };\n    int C[MAXNODES][MAXNODES]; // holds adjacency matrix\n    int size;\n    TableType T[MAXNODES][MAXNODES]; // for dijkstra's algorithm\n};\n\n\n#include \"GraphD.h\"\n\nGraphD::GraphD()\n{\n    size = 0;\n    for(int i = 1; i < MAXNODES; i++)\n    {\n        for(int j = 1; j < MAXNODES; j++)\n        {\n            C[i][j] = infinity;\n            T[i][j].dist = infinity;\n            T[i][j].visited = false;\n            T[i][j].path = 0;\n        }\n    }\n}\n\nvoid GraphD::buildGraph(ifstream &infile)\n{\n    string line;\n    if(getline(infile, line))\n    {\n        size = atoi(line.c_str());\n        for(int i = 1; i <= size; i++)\n        {\n            getline(infile, line);\n            data[i] = line;\n        }\n\n        int vertex1, vertex2, distance;\n        while(getline(infile, line))\n        {\n            stringstream edge(line);\n            edge >> vertex1 >> vertex2 >> distance;\n            if(vertex1 == 0)\n                break;\n            insertEdge(vertex1, vertex2, distance);\n        }\n        for(int i = 1; i <= size; i++)\n        {\n            C[i][i] = 0;\n        }\n    }\n}\n\nvoid GraphD::insertEdge(int from, int to, int distance)\n{\n    C[from][to] = distance;\n} \n\nvoid GraphM::findShortestPath()\n{\n    for(int source = 1; source <= size; source++)\n    {\n        T[source][source].dist = 0;\n        for(int i = 1; i <= size; i++)\n        {\n            int v = 0;\n            int shortestDistance = infinity;\n            for(int j = 1; j <= size; j++)\n            {\n                if((C[source][j] < shortestDistance) && !T[source][j].visited)\n                {\n                    shortestDistance = C[source][j];\n                    v = j;\n                }\n            }\n            T[source][v].visited = true;\n            for(int w = 1; w <= size; w++)\n            {\n                if(!T[v][w].visited)\n                {\n                    T[v][w].dist = min(T[v][w].dist, T[source][v].dist + C[v][w]);\n                }\n            }\n        }\n    }\n}\n```\n\n    ", "Answer": "\r\nSet infinity value equal to 1'000'000'000 (or smth like this), because when you use MAX_INT value you get integer overflow here \n\n```\nT[v][w].dist = min(T[v][w].dist, T[source][v].dist + C[v][w]);\n```\n\n\n\n\nAlso, I think you should replace following part of code\n\n```\nif(!T[v][w].visited)\n{\n    T[v][w].dist = min(T[v][w].dist, T[source][v].dist + C[v][w]);\n}\n```\n\n\nto the next one\n\n```\nif(!T[source][w].visited)\n{\n    T[source][w].dist = min(T[source][w].dist, T[source][v].dist + C[v][w]);\n}\n```\n\n\nbecause you need to find distance to vertex W from vertex Source, not V.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How to apply Dijkstra algorithm to my adjacency graph?\r\n                \r\ni have a programming assignment that require me to build an adjacency graph and applied Dijkstra algorithm to find a MST. I have build my adjacency graph, but i dont know how to apply the Pseudo-code for the Dijkstra algorithm. \nThe link had the code for adjacency list, http://www.cs.utsa.edu/~wagner/CS3343/newgraph/graphrep.html\n\nThe Pseudo-code for the Dijkstra algorithm:\nhttps://i.stack.imgur.com/PcOs8.png \n\nIs there anyway to applied the Dijkstra algorithm for this graph?\nThank you very much!!\n    ", "Answer": "\r\nTo apply pseudo code you typically code it up in some language and then run the code.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "JGraphT Dijkstra's algorithm has different inclusivity rules for directed and undirected graph\r\n                \r\nI'm using JGraphT library with a fairly large graph and I'm converting my code from ```\nDefaultUndirectedWeightedGraph```\n to ```\nDefaultDirectedWeightedGraph```\n (I have generated dual edges for starters for every undirected edge). I use Dijkstra's algorithm to find shortest paths in my graph and I have encountered strange behavior - my tests blew up due to paths found being off by one node. \n\nAfter a bit of research it turned out that JGraphT's Dijkstra drops source node and includes sink node for traversals of undirected graphs and contrarywise - it includes source node and drops sink node for traversals of directed graphs.\n\nHere's an example:\n\n```\ngiven:\nDirected:   A --> B --> C --> D --> E --> F\nUndirected: A <-> B <-> C <-> D <-> E <-> F\nand:\nsource: A\nsink:   E\nDijkstra's will yield:\nfor directed graph:   A, B, C, D\nfor undirected graph: B, C, D, E\n```\n\n\nDoes anyone understand why does this happen?\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Understanding this explanation on why Dijkstra's algorithm fails on graphs with negative edges?\r\n                \r\nI am reading about  Shortest paths in the presence of negative edges in book titled algorithms by Sanjoy DasGupta (page 122)\n\nhttp://beust.com/algorithms.pdf\n\n\n  Dijkstra's algorithm works in part because the shortest path from the\n  starting point s to any node v must pass exclusively through nodes\n  that are closer than v. This no longer holds when edge lengths can be\n  negative. In Figure 4.12, the shortest path from S to A passes through\n  B,a node that is further away.\n\n\n```\n    (S,A) = 3, (S,B)=4, (B,A)= =2\n\n\n\nS-----3--------A\n   |           ^\n   |           |\n   4          -2\n   |           |\n   |           |\n   B----------->\n```\n\n\n\n  What needs to be changed in order to accommodate this new\n  complication? To answer this, let's take a particular high-level view\n  of Dijkstra's algorithm. A crucial invariant is that the dist values\n  it maintains are always either overestimates or exactly correct. They\n  start off at infinity, and the only way they ever change is by\n  updating along an edge\n\n\n:\n\n```\nprocedure update((u; v) belongsto E)\ndist(v) = min{dist(v), dist(u) + l(u,v)}\n```\n\n\n\n  This update operation is simply an expression of the fact that the\n  distance to v cannot possibly be more than the distance to u, plus\n  l(u, v). It has the following properties.\n  1. It gives the correct distance to v in the particular case where u is the second-last node in the shortest path to v, and dist(u) is\n  correctly set.\n  2. It will never make dist(v) too small, and in this sense it is safe. For instance, a slew of extraneous update's can't hurt.\n  \n  This operation is extremely useful: it is harmless, and if used\n  carefully, will correctly set distances. In fact, Dijkstra's algorithm\n  can be thought of simply as a sequence of update's. We know this\n  particular sequence doesn't work with negative edges, but is there\n  some other sequence that does? To get a sense of the properties this\n  sequence must possess, let's pick a node t and look at the shortest\n  path to it from s.\n\n\nMy questions on above text is\n\n\nWhat does author mean by second property? \"It will never make dist(v) too small, and in this sense it is safe. For instance, a slew of extraneous update's can't hurt.\" I am not able to understand this\nWhat does author mean by \"We know this particular sequence doesn't work with negative edges, but is there some other sequence that does?\" I am not native english speaker so difficult in understanding this statement?\n\n    ", "Answer": "\r\nFor your first question - what does the statement \"it will never make dist(v) too small\" mean? - I think the author is referring to a particular property of Dijkstra's algorithm: if you look at the distances that Dijkstra's algorithm stores to each node in the graph, the distance stored to a particular node is never less than the actual distance. In fact, if you have nonnegative edge weights and look at the distances as you run Dijkstra's algorithm, the distances will keep decreasing and decreasing until they eventually converge on the true distances. In that sense, Dijkstra's algorithm continuously gets better and better approximations of the true distance, but at no point ever has a distance to a node that's too short.\n\nFor your second question, I think the author is asking you to think about what would happen if you were to run Dijkstra's algorithm on any input graph. As the algorithm runs, it keeps making updates to its guesses of the distances between the start node and each other node in the graph. The author is saying that if you run Dijkstra's algorithm and watch how it works, what you'll see is a series of calls to some subroutine ```\nupdate```\n that changes those distances. Even if the algorithm gives the wrong final answer, it still works by calling ```\nupdate```\n repeatedly.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm with Adjacency Lists and Priority Queue\r\n                \r\n```\n#include <iostream>\n#include <fstream>\n#include <functional>\n#include <climits>\n#include <vector>\n#include <queue>\n#include <list>\n\n\nusing namespace std;\n\nstruct Vertices {\n    int vertex;\n    int weight;\n    Vertices(int v, int w) : vertex(v), weight(w) { };\n    Vertices() { }\n};\n\nclass CompareGreater {\n    public:\n        bool const operator()(Vertices &nodeX, Vertices &nodeY) {\n            return (nodeX.weight > nodeY.weight) ;\n        }\n};\n\nvector< list<Vertices> > adj;\nvector<int> weights;\npriority_queue<Vertices, vector<Vertices>, CompareGreater> Q;\n\nint nrVertices, nrEdges;\n\nvoid readData();\nvoid Dijkstra(Vertices);\nvoid writeData();\n\nvoid writeData() {\n    ifstream out;\n    out.open(\"graph.txt\");\n\n    weights.resize(1);\n    for (vector<int>::iterator it = weights.begin()+1; it != weights.end(); ++it) {\n        cout << (*it) << \" \";\n    }\n\n    out.close();\n}\n\nvoid readData() {\n    ifstream myFile;\n    myFile.open(\"graph.txt\");\n\n    int nodeX, nodeY, weight;\n\n    myFile >> nrVertices >> nrEdges;\n\n    adj.resize(nrVertices+1);\n    weights.resize(1);\n\n    for (int i = 1; i <= nrVertices; ++i) {\n        weights.push_back(INT_MAX);\n    }\n\n    for (int i = 1; i <= nrEdges; ++i) {\n        myFile >> nodeX >> nodeY >> weight;\n        adj[nodeX].push_back(Vertices(nodeY, weight));\n    }\n\n    myFile.close();\n}\n\nvoid Dijkstra(Vertices startNode) {\n    Vertices currVertex;\n\n    weights[startNode.vertex] = 0;\n    Q.push(startNode);\n\n    while (!Q.empty()) {\n        currVertex = Q.top();\n        Q.pop();\n\n        if (currVertex.weight <= weights[currVertex.vertex]) {\n            for (list<Vertices>::iterator it = adj[currVertex.vertex].begin(); it != adj[currVertex.vertex].end(); ++it) {\n                if (weights[it->vertex] > weights[currVertex.vertex] + it->weight) {\n                    weights[it->vertex] = weights[currVertex.vertex] + it->weight;\n                    Q.push(Vertices((it->vertex), weights[it->vertex]));\n                }\n            }\n        }\n    }\n}\n\nint main() {\n\n    readData();\n    Dijkstra(Vertices(1, 0));\n    writeData();\n\n    return 0;\n}\n```\n\n\nSo this is what I have so far in order to implement a Dijkstra algorithm with adjacency lists. However, my code will not print anything. Any help?\n\nGraph.txt looks like this:\n\n```\n7\n2\n2  2\n4  1\n2\n4  3\n5  10\n2\n1  4\n6  5\n4\n3  2\n5  2\n6  8\n7  4\n1\n7  6\n0\n1\n6  1\n```\n\n\nThis means that there exists 7 vertices in order from vertex 1 to 7.\nVertex 1 has 2 edges, one to vertex 2 with weight 2, the second to vertex 4 with weight 1.\nVertex 2 has 2 edges, the first to vertex 4 with weight 3, the second to vertex 5 with weight 10.\nVertex 3 has 2 edges, the first to vertex 1 with weight 4, the second to vertex 6 with weight 5. \nAnd so forth. \n    ", "Answer": "\r\nThis code: \n\n```\nweights.resize(1);\nfor (vector<int>::iterator it = weights.begin()+1; it != weights.end(); ++it) {\n```\n\n\nwill resize the ```\nweights```\n vector to a length of 1 and then try to print out the second element of the vector. As there is no longer a second element, it won't print anything.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How to test efficiently Dijkstra algorithm [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 6 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI am working on an existing implementation of Dijkstra and one of my deliverable is to test whether this implementation is an efficient solution to the issue at hand or to recommend an alternate algorithm.\nThe question is... How should I baseline the existing Dijkstra algorithm so I could compare it to alternate?\nTo narrow the scope, my client is using Dijkstra to dynamically chose the best tariffs plan for b2b consumers. Does it make any sense?\n    ", "Answer": "\r\nDijkstra is an algorithm to find the shortest path in a graph. To test and see how effective is that, you need to compare it with other algorithms. like Bellman–Ford algorithm, A* search algorithm , etc.\n\nimportant notes\n\nOther than performance, there are other important issues like Dijkstra doesn't work with negative values. That is why Bellman-Ford has been used instead in many problems. \n\nAlso, Dijkstra has different implementations.\n\nDijkstra's algorithm with list is from O(V 2) while Dijkstra's algorithm with modified binary heap is from O((E + V) log V) and Dijkstra's algorithm with Fibonacci heap is from O(E + V log V). Bellman–Ford algorithm is from O(VE).\n\nConclusion\n\nIf you need to see which one is better for your work, first see which parameters matters for you and then compare the ones that can be suitable. If you want, you can even test them since they all have been implemented by other people before. You just need to give them a graph \n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra Algorithm with Adjaceny matrix [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                This question is unlikely to help any future visitors; it is only relevant to a small geographic area, a specific moment in time,  or an extraordinarily narrow situation that is not generally applicable to the worldwide audience of the internet. For help making  this question more broadly applicable, visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI am trying to implement Dijkstra Algorithm using priority queue given an adjaceny matrix.\nI know the problem is probably at where I add vertices to the priority queue but I can't figure out how to fix it! \n\n```\nstatic int dijkstra(int[][] g, int i, int j) {\n    // Get the number of vertices in G\n    int n = g.length;\n    int counter = 0;\n\n    PriorityQueue<Vertex> q = new PriorityQueue<Vertex>(n, new Comparator<Vertex>() {       \n        public int compare(Vertex a, Vertex b) {\n            Vertex v1 = (Vertex) a;\n            Vertex v2 = (Vertex) b;\n            if (v1.getD() > v2.getD()) {\n                return 1;\n            } else if (v1.getD() < v2.getD()) {\n                return -1;\n            } else {\n                return 0;\n            }\n        }\n    });\n    int[] distance = new int[n];\n    for (int l = 0; l < n; l++) {\n        distance[l] = 99999;\n    }\n    distance[i] = 0;\n\n    for (int l = 0; l < n/2; l++) {\n        for (int m = 0; m < n; m++) {\n            if (g[l][m] > 1) {\n                System.out.printf(\"%d was added \\n\", g[l][m]);\n                q.add(new Vertex(l, g[l][m]));\n            }\n        }\n    }\n    while (!q.isEmpty()) {\n        int u = 0;\n        for (int z = 0; z < n; z++) {\n            if (distance[z] < distance[u]) {\n                u = z;\n            }\n        }\n        if (distance[u] == 99999) { break; }\n        q.remove();\n        for (int l = 0; l < n; l++) {\n            if (g[u][l] > 1) {\n                int alt = distance[u] + g[u][l];\n                if (alt < distance[l]) {\n                    distance[l] = alt;\n                    q.remove();\n                    q.add(new Vertex(u, distance[l]));\n                }\n            }\n        }\n    }\n\n    for (int k = 0; k < n; k++) {\n        System.out.printf(\"==>%d\", distance[j]);\n    }\n    return distance[j];\n}\n```\n\n\nAnd:\n\n```\nclass Vertex {\n    int v,d;\n    public Vertex(int num, int dis) {\n        v = num;\n        d = dis;\n    }\n    public int getV() {\n        return v;\n    }\n    public int getD() {\n        return d;\n    }\n}\n```\n\n\nI am testing with the following matrix:\n\n```\n 0  0  0  0  0  0  0 38  0  0  0  0  0  0  0  0\n 0  0  0  0 65  0 64  0  6  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  6  8  0  0  0 62\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0 65  0  0  0  0  0  0  0  6  0  0  0  0 55  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0 64  0  0  0  0  0 53  0  0 36  0 45  0  0  0\n38  0  0  0  0  0 53  0  0  0  0 91  0 29  0  0\n 0  6  0  0  0  0  0  0  0  0  0 95 55  0  0  0\n 0  0  0  0  6  0  0  0  0  0  0  0  0  0  0  0\n 0  0  6  0  0  0 36  0  0  0  0  0  0  0  0  0\n 0  0  8  0  0  0  0 91 95  0  0  0 60  0  0  0\n 0  0  0  0  0  0 45  0 55  0  0 60  0  0  0  0\n 0  0  0  0  0  0  0 29  0  0  0  0  0  0  0  0\n 0  0  0  0 55  0  0  0  0  0  0  0  0  0  0  0\n 0  0 62  0  0  0  0  0  0  0  0  0  0  0  0  0\n```\n\n\nAnd start is ```\n0```\n, end is ```\nn - 1```\n. I should be getting ```\n195```\n but it seems like none of the distances are being changed!\n    ", "Answer": "\r\nWhen you're printing the distances you print the array at ```\nj```\n all the time while ```\nk```\n is the iterator. The distances appear constant but they are changing.\n\n```\nfor (int k = 0; k < n; k++) {\n    System.out.printf(\"==>%d\", distance[k]);\n}\n```\n\n\nAlso, in your algorithm you're removing the top vertex twice which isn't plausible. The algorithm should be something like this instead:\n\n```\nwhile (!q.isEmpty()) {\n    int u = q.peek().v;\n    q.remove();\n    for (int l = 0; l < n; l++) {\n        if (g[u][l] > 1) {\n            int alt = distance[u] + g[u][l];\n            if (alt < distance[l]) {\n                distance[l] = alt;\n                q.add(new Vertex(u, distance[l]));\n            }\n        }\n    }\n}\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra algorithm optimization/caching\r\n                \r\nI have the following Dijkstra algorithm with 3 input variables (start, stop and time). It takes about 0.5-1s to complete. My hosting provider says it's using too much resources and I should implement some caching mechanism. My question is, how?\n\nBecause I have 3 variables, if only one of them changes - the whole result is different (because I have some additional statements with time, nevermind). So how to implement some caching mechanism or do some optimisation?\n\nI have 1700 nodes.\n\n```\n<?php require_once(\"../includes/db_connection.php\"); ?>\n<?php require(\"../includes/functions.php\"); ?>\n<?php require(\"../includes/global_variables.php\"); ?>\n<?php\n    // Function to put \"maxValues\" into time (in my case 10 000 because I know it can't take longer than that from source to end node)\n    function array_push_key(&$array, $key, $value) {\n        $array[$key] = $value;\n    }\n\n    // Start the counter\n    $timeM = microtime(); $timeM = explode(' ', $timeM); $timeM = $timeM[1] + $timeM[0]; $start = $timeM;\n\n    // Get provided values\n    $startStop = $_GET[\"start\"];\n    $endStop = $_GET[\"end\"];\n    $startTime = $_GET[\"time\"];\n\n    // Initialize arrays\n    $time = array();\n    $previousNode = array();\n    $allStops = array();\n\n    // [5] = 119 --> You can get to stop no. 5 by line no. 119\n    // line to source node is 0\n    $lineToThisStop = array();\n    $lineToThisStop[$startStop] = 0;\n\n    // Populate arrays\n    $result=mysql_query(\"SELECT stop_id FROM db_stops\", $connection);\n    potvrdi_unos($result);\n    $counter = 0;\n    while($rows = mysql_fetch_array($result)){\n        array_push_key($time, $rows[\"stop_id\"], 10000);\n        array_push($allStops, $rows[\"stop_id\"]);\n        // Locate startStop in the allStops array to unset it few lines later\n        if ($rows[\"id\"] == $startStop) {\n            $poz = $brojac;\n        }\n        $counter++;\n    }\n\n    // Set starting time to starting stop\n    $time[$startStop] = $startTime;\n    // Set it activeNode\n    $activeNode = $startStop;\n\n    // Unset it in allStops array (so it doens't have to be checked later)\n    unset($allStops[$poz]);\n    $allStops = array_values($allStops);\n\n    // I can put \"while (true)\" because all nodes are connected in \"one piece\", there is NO UNCONNECTED nodes\n    while (true) {       \n        $result=mysql_query(\"SELECT route_id, next_stop FROM db_stop_times WHERE stop_id = $activeNode\", $connection);\n        potvrdi_unos($result);\n\n        while($rows = mysql_fetch_array($result)) {         \n            // Draw paths from active node to all other (connected) stops\n            $nextStopArray = $rows[\"next_stop\"];\n\n            // nextStopArray is something like \"0,34,123,3123,213\" - those are all stops from current, active node/stop\n            $nextStopArray = explode(\",\", $nextStopArray);\n\n            // sometimes it's just \"4\" to convert it into array\n            if (!is_array($nextStopArray)) {\n                $nextStopArray[0] = $nextStopArray;\n            }\n\n            for ($p = 0; $p < sizeof($nextStopArray); $p++) {\n                $nextStop = $nextStopArray[$p];\n\n                $walkToTheStop = false;\n\n                // Few checks                   \n                if ($p == 0) {\n                    if ($nextStop != 0) {\n                        $pathDuration = 2;                          \n\n                        if ($lineToThisStop[$activeNode] != $rows[\"route_id\"]) {\n                            $pathDuration = $pathDuration * 2;\n                        }\n                    }\n                } else {\n                    $walkToTheStop = true;\n\n                    $pathDuration = 1;                          \n                }\n\n                // If that's shortest path from ActiveNode to nextStop insert it into it's time array (time to get to that stop)\n                if (($pathDuration + $time[$activeNode]) < $time[$nextStop]) {\n                    $time[$nextStop] = $pathDuration + $time[$activeNode];\n\n                    array_push_key($previousNode, $nextStop, $activeNode);\n\n                    // Some aditional records (5000 means \"you must walk to that stop\")\n                    if ($walkToTheStop) {\n                        $lineToThisStop[$nextStop] = 5000;\n                    } else {\n                        $lineToThisStop[$nextStop] = $rows[\"route_id\"];\n                    }\n                }\n            }           \n        }\n\n        // Traži slijedeću stanicu (vrh) s najmanjom vrijednosti        \n        $lowestValue = 10000 + 1;\n        for ($j = 0; $j < sizeof($allStops); $j++) {\n            if ($time[$allStops[$j]] < $lowestValue) {\n                $lowestValue = $time[$allStops[$j]];                        \n                $activeNode = $allStops[$j];\n\n                // Record it's position so I can unset it later\n                $activeNodePosition = $j;\n            }\n        }\n\n        // Unset the active node from the array - so loop before will be shorter every time for one node/stop\n        unset($allStops[$activeNodePosition]);\n        $allStops = array_values($allStops);\n\n        // If you get to the end stop, feel free to break out of the loop\n        if ($activeNode == $endStop) {\n            break;\n        }\n    }\n\n    // How long did it take?\n    $timeM = microtime(); $timeM = explode(' ', $timeM); $timeM = $timeM[1] + $timeM[0]; $finish = $timeM;\n\n    $total_time = round(($finish - $start), 4);\n    echo 'Total time '.$total_time.' seconds.'.\"<br />\";\n?>\n\n<?php require_once(\"../includes/close_connection.php\"); ?>\n```\n\n    ", "Answer": "\r\nMicro-optimisations, but don't do:\n\n```\nfor ($p = 0; $p < sizeof($nextStopArray); $p++) { \n   ...\n}\n```\n\n\ncalculate the sizeof($nextStopArray) before the loop, otherwise you're doing the count every iteration (and this value isn't being changed)\n\n```\n$nextStopArraySize = sizeof($nextStopArray);\nfor ($p = 0; $p < $nextStopArraySize; ++$p) { \n   ...\n}\n```\n\n\nThere's a couple of places where this should be changed.\n\nAnd if you're iterating several thousand times, ++$p is faster than $p++\n\nBut profile the function... find out which parts are taking the longest to execute, and look to optimise those.\n\nEDIT\n\nGet rid of array_push_key as a function, simply execute it inline... it's costing you an unnecessary function call otherwise\n\nBuild an array of all nodes from your database outside of the while(true) loop... retrieve all the data in a single SQL query and build a lookup array.\n\nReplacing\n\n```\nfor ($p = 0; $p < sizeof($nextStopArray); $p++) { \n```\n\n\nwith \n\n```\n$nextStopArraySize = sizeof($nextStopArray);\n$p = -1\nwhile (++$p < $nextStopArraySize) { \n   ...\n}\n```\n\n\nmay also prove faster still (just check that the logic does loop through the correct number of times).\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How would increasing the edge weight on a graph affect the Dijkstra's algorithm?\r\n                \r\nThe question is: Consider the directed graph with 5 vertices. Let the Dijkstra’s\nalgorithm yield shortest paths from node s to all the other nodes, as shown\nin Fig. 1. Let the weight of the edge (x, t), increase and assume all nodes\nsomehow obtain this information. How does node s modify Dijkstra’s algorithm\nto make minimum recomputations? Provide the final solution in the\nform “Node s runs Dijkstra’s algorithm by initializing S as  and maintaining the list (< each node >) as .”\n\nMy question is... Isn't that a trick question because all it would do is increase the shortest path from s to t right?\n\nalright so my picture isnt working\n\nbut it works something like this:\n\ns->y->x->t\n\ny also points to z.\ny->z\n\nthese are one way directional arrows.\n    ", "Answer": "\r\nIf (s,y), (y, z), (y, x), (x, t) are the only edges in this graph, then yes: this only increases the weight (or distance) of the shortest path of s to t, since there is only one such path.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm issue [repost]\r\n                \r\nI realized I can't post answers to my own questions because of my low rep or whatever so i deleted my old question and am reasking it. i changed some things and still can't get what i'm looking for. \n\nHere is most of the code\nI left out some of the simpler implementations such as parts of the pathFinder class because I know for sure they work, which is why you'll see playerVertex and time just randomly there. \nIn the example they used a decreaseKey function, I'm not sure if THAT'S what I'm missing? I'm a beginner here, so constructive criticism is welcome. (hopefully as polite as possible) lol. My problem is printing the path, I get a looop of the same two values over and over again.\n\n```\nclass Heap \n{\npublic: Heap();\n    ~Heap();\n    void insert(double element);\n    double  deletemin();\n    void print();\n    int size(){return heap.size();}\n\n\nprivate:\n int currentIndex;\n int left(int parent);\n int right(int parent);\n int parent(int child);\n void heapifyup(int index);\n void heapifydown(int index);\nprivate:\n vector<double> heap;\n};\n\nHeap::Heap()\n{\n currentIndex = 0;\n}\nHeap::~Heap()\n{}\n\nvoid Heap::insert(double element)\n{\nheap.push_back(element);\ncurrentIndex++;\nheapifyup(heap.size() - 1);\n}\n\ndouble Heap::deletemin()\n{\ndouble min = heap.front();\nheap[0] = heap.at(heap.size()-1);\nheap.pop_back();\nheapifydown(0);\ncurrentIndex--;\nreturn min;\n}\nvoid Heap::print()\n{\nvector<double>::iterator pos = heap.begin();\ncout << \"Heap = \";\nwhile ( pos != heap.end() ) \n{\n    cout << *pos;\n    ++pos;\n    cout << endl;\n }\n}\nvoid Heap::heapifyup(int index)\n{\n\n\nwhile((index>0) && (parent(index) >=0) && (heap[parent(index)] > heap[index]))\n{\n double tmp = heap[parent(index)];\n heap[parent(index)] = heap[index];\n heap[index] = tmp;\n index = parent(index);\n\n\n}\n}\n\nvoid Heap::heapifydown(int index)\n{\n\n\n\nint child = left(index);\n\nif((child > 0) && (right(index) > 0) && (heap[child]>heap[right(index)]))\n{\n child = right(index);\n\n}\nif(child > 0)\n{\ndouble tmp = heap[index];\nheap[index] = heap[child];\nheap[child] = tmp;\nheapifydown(child);\n}\n}\n\nint Heap::left(int parent)\n{\nint i = ( parent <<1) + 1; \nreturn(i<heap.size()) ? i : - 1;\n}\n\nint Heap::right(int parent)\n{\nint i = ( parent <<1) + 2; \nreturn(i<heap.size()) ? i : - 1;\n}\n\nint Heap::parent(int child)\n{\nif(child != 0)\n{\n int i = (child - 1) >>1;\n return i;\n}\nreturn -1;\n}\n\n\n\nclass pathFinder : public weightedGraph\n{\n\nprivate:\n\nvertex* playerVertex;\ndouble time;\n\n\npublic:\nstring source;\npathFinder()\n{\n    playerVertex = NULL;\n    time = 0;\n\n}\n\n\n  void Dijkstra(int s,int t)\n{\n    vertex *verts = findVertex(grid[s][t]);\n    Heap H;\n    for each(vertex *v in vertexList)\n    {\n\n        if(v->data == verts->data)\n        {\n            verts->distance = 0;\n            verts->pred = NULL;\n        }\n        v->distance = INFINITY;\n        v->pred = NULL;\n        H.insert(v->data);\n    }\n    while(H.size() != 0)\n    {\n\n        vertex *x = findVertex(H.deletemin());\n\n        for each(edge *v in x->adjacencyList)\n        {\n\n            if(v->end->visited != true)\n            {    \n            relax(x,v->end);\n            v->end->visited = true;\n            }\n            else\n                break;\n\n        }\n\n    }\n}\n\n\n\n\n\n\n\n\nvoid relax(vertex *a, vertex *b)\n{\n\n    if(a->distance + weightFrom(a,b) > b->distance)\n        {\n            b->distance = a->distance + weightFrom(a,b);\n            b->pred = a;\n        }\n\n\n}\n\n\nvoid printPath(double dest,double dest1)\n{\n    vertex *verta = findVertex(dest);\n    while(verta->pred->data != dest1)\n    {\n    cout<<verta->data<<endl;\n    verta = verta->pred;\n    }\n}\n```\n\n\nand i'm not sure about the print path being that. i just used the print path from the BFS algorithm i've implemented before. \n    ", "Answer": "\r\nWhere in your ```\nprintPath```\n function are you looking for the end of the list?  \n\nYou keep going ```\nverta = verta->pred```\n until the data is not equal to some value.  \n\nBy the way, don't compare doubles for equality, as it ain't going to happen.  See What Every Computer Scientist Should Know About Floating Point.  \n\nWhat happens when you single step with your debugger?\n(Try drawing the links and how you traverse them.)\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm length\r\n                \r\nfrom this website's pseudocode: \n\n\r\n\r\n```\nGiven a graph, G, with edges E of the form (v1, v2) and vertices V, and a\r\nsource vertex, s\r\n\r\ndist : array of distances from the source to each vertex\r\nprev : array of pointers to preceding vertices\r\ni    : loop index\r\nF    : list of finished vertices\r\nU    : list or heap unfinished vertices\r\n\r\n/* Initialization: set every distance to INFINITY until we discover a path */\r\nfor i = 0 to |V| - 1\r\n    dist[i] = INFINITY\r\n    prev[i] = NULL\r\nend\r\n\r\n/* The distance from the source to the source is defined to be zero */\r\ndist[s] = 0\r\n\r\n/* This loop corresponds to sending out the explorers walking the paths, where\r\n * the step of picking \"the vertex, v, with the shortest path to s\" corresponds\r\n * to an explorer arriving at an unexplored vertex */\r\n\r\nwhile(F is missing a vertex)\r\n   pick the vertex, v, in U with the shortest path to s\r\n   add v to F\r\n   for each edge of v, (v1, v2)\r\n        /* The next step is sometimes given the confusing name \"relaxation\"\r\n        if(dist[v1] + length(v1, v2) < dist[v2])\r\n            dist[v2] = dist[v1] + length(v1, v2)\r\n            prev[v2] = v1\r\n            possibly update U, depending on implementation\r\n        end if\r\n    end for\r\nend while```\n\r\n\r\n\r\n\n\nwhat is meant by: if(dist[v1] + length(v1, v2) < dist[v2])?\n\nparticularly: length(v1, v2).\n\nshouldn't: dist[v1] < dist[v2] enough?\n    ", "Answer": "\r\n```\nlength(v1, v2)```\n is the weight of the edge from node v1 to v2.\n\nThis condition checks whatever the path to v2 can be improved by going to v1 and then through edge (v1,v2). \n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Why does my implementation of Dijkstra's algorithm fail under this undefined case?\r\n                \r\nI am trying to write an implementation of Dijkstra's Algorithm in Prolog (specifically, GNU Prolog). To begin, I made a fact ```\nconnection```\n that describes the connected vertices of the graph below.\n\nIt now seems like my implementation works for around half of my test cases, namely these:\n```\ns, k\ng, h\ne, c\n```\n\nBut for these,\n```\nh, g (this one has an empty Tentative_Connections)\nc, e (this one too)\ni, j (this one finds the incorrect path of [i, k, j])\n```\n\nit fails.\nI based my program on the description given on the algorithm's wikipedia page. Here is some rough psuedocode:\n```\nfor a current node, find its connecting nodes\nremove the ones that are visited\nmake a new list of nodes that factors in a tentative distance\ndelete the current node from the list of unvisited nodes\nif the destination node is not in the unvisited list, the current built-up path is final\notherwise, recur on the node that is the closest regarding the tentative distance\n```\n\nBut no matter what, my code keeps failing (with the errors above). To elaborate on that, here is the failure for the ```\nh, g```\n case:\n```\nUnchartered = []\nTentative = []\nDestination not reached\nNo tentative connections!\nClosest = _1232\nClosest = _1232\nNext_Path = [h,b,s,c,l,i,k,j]\nuncaught exception: error(instantiation_error,(is)/2)\n| ?- \n```\n\nIt seems like at one point, there are no tentative points left to search. I do not know what to do from here, as Wikipedia does not elaborate on this issue. Does anyone who knows this algorithm well know what I can do to fix my code?\n```\n% https://www.youtube.com/watch?v=GazC3A4OQTE\n% example graph\n% cl; gprolog --consult-file dijkstra.pl --entry-goal main\n\nconnection(s, c, 3).\nconnection(c, l, 2).\nconnection(l, i, 4).\nconnection(l, j, 4).\nconnection(i, j, 6).\nconnection(i, k, 4).\nconnection(j, k, 4).\nconnection(k, e, 5).\nconnection(e, g, 2).\nconnection(g, h, 2).\nconnection(h, f, 3).\nconnection(f, d, 5).\nconnection(d, a, 4).\nconnection(b, d, 4).\nconnection(b, a, 3).\nconnection(b, s, 2).\nconnection(b, h, 1).\nconnection(a, s, 7).\n\nget_vertices(_, Vertex_Count, Traversed, Traversed) :-\n    length(Traversed, Vertex_Count).\n\nget_vertices([], _, Traversed, Traversed).\n\nget_vertices([Vertex | Vertices], Vertex_Count, Traversed, Result) :-\n    get_vertices(Vertex, Vertex_Count, Traversed, More_Traversed),\n    get_vertices(Vertices, Vertex_Count, More_Traversed, Result).\n\nget_vertices(Vertex, _, Traversed, Traversed) :-\n    atom(Vertex), member(Vertex, Traversed).\n\nget_vertices(Vertex, Vertex_Count, Traversed, Result) :-\n    atom(Vertex),\n    findall(Connected, are_connected(Vertex, Connected, _), Vertices),\n    get_vertices(Vertices, Vertex_Count, [Vertex | Traversed], Result).\n\nare_connected(A, B, S) :- connection(A, B, S) ; connection(B, A, S).\n\nkeep_unvisited([], _, []).\nkeep_unvisited([Connection | Connections], Unvisited, Result) :-\n    keep_unvisited(Connections, Unvisited, Tail_Result),\n    [Connection_Name, _] = Connection,\n    (member(Connection_Name, Unvisited) ->\n        Result = [Connection | Tail_Result];\n    Result = Tail_Result).\n\nw_tentative_distances([], _, []).\nw_tentative_distances([Connection | Connections], Node_Val, Result) :-\n    w_tentative_distances(Connections, Node_Val, Tail_Result),\n    [Connection_Name, Connection_Val] = Connection,\n\n    Tentative_Distance is Connection_Val + Node_Val,\n    (Connection_Val > Tentative_Distance ->\n        New_Distance = Tentative_Distance; New_Distance = Connection_Val),\n\n    Result = [[Connection_Name, New_Distance] | Tail_Result].\n\nclosest_node_([], Closest, Closest).\nclosest_node_([Node | Rest], Closest, Result) :-\n    [_, Node_Val] = Node,\n    [_, Closest_Val] = Closest,\n    (Node_Val < Closest_Val ->\n        closest_node_(Rest, Node, Result)\n        ;\n    closest_node_(Rest, Closest, Result)).\n\nclosest_node([Node | Rest], Result) :-\n    closest_node_(Rest, Node, Result).\n\ndijkstra([Node_Name, Node_Val], Unvisited, Dest_Node, Path, Final_Path) :-\n    findall([Connected, Dist], are_connected(Node_Name, Connected, Dist), Connections),\n    keep_unvisited(Connections, Unvisited, Unchartered_Connections),\n    w_tentative_distances(Unchartered_Connections, Node_Val, Tentative_Connections),\n\n    % trace,\n    delete(Unvisited, Node_Name, New_Unvisited),\n    format('Path = ~w\\nNode_Name = ~w\\nNode_Val = ~w\\n', [Path, Node_Name, Node_Val]),\n    format('Unvisited = ~w\\nNew_Unvisited = ~w\\n', [Unvisited, New_Unvisited]),\n    % notrace,\n\n    format('Connections = ~w\\n', [Connections]),\n    format('Unchartered = ~w\\n', [Unchartered_Connections]),\n    format('Tentative = ~w\\n', [Tentative_Connections]),\n\n    (member(Dest_Node, Unvisited) -> % destination has not been reached\n        write('Destination not reached\\n'),\n        (closest_node(Tentative_Connections, Closest); write('No tentative connections!\\n')),\n        format('Closest = ~w\\n', [Closest]),\n        append(Path, [Node_Name], Next_Path),\n        format('Closest = ~w\\nNext_Path = ~w\\n', [Closest, Next_Path]),\n        dijkstra(Closest, New_Unvisited, Dest_Node, Next_Path, Final_Path);\n    write('The end was reached!\\n'),\n    Final_Path = Path).\n\ndijkstra_wrapper(Start, End, Vertex_Count, Path) :-\n    get_vertices(Start, Vertex_Count, [], Unvisited),\n    dijkstra([Start, 0], Unvisited, End, [], Path).\n\nmain :-\n    dijkstra_wrapper(h, g, 13, Path),\n    write(Path), nl.\n```\n\nThe non-working examples have an ever-growing Unvisited list (for some recursive cases)\n```\nPath = [h,b,s,c,l,i,k]\nNode_Name = j\nNode_Val = 4\nUnvisited = [g,e,j,a,d,f]\nNew_Unvisited = [g,e,a,d,f]\nConnections = [[k,4],[l,4],[i,6]]\nUnchartered = []\nTentative = []\nDestination not reached\n```\n\nWhat do I do if there are no paths to travel down?\n    ", "Answer": "\r\nAnother one.\nIt uses ```\nlibrary(assoc)```\n association lists to store the path associated to each vertex. This avoids having to code a list scan. The list of \"vertex that shall be visited next\" is still a vanilla list, but we need to eliminate duplicated vertex and retain those vertexes with minimal distances only after each visit, then sort the list by vertex distance so that the next vertex that shall be visitited is at the head.\n(SWI-Prolog has a built-in associative data structure, the SWI-Prolog ```\ndict```\n, which I'm not using here. Does ```\nlibrary(assoc)```\n exist in GNU Prolog? It should...)\n```\n\n?- main.\n\nVisitThese is currently: [0-a] \nNeighbors of vertex a : [s-7,d-4,b-3] \nDirty visitations : [7-s,4-d,3-b], Clean visitations : [3-b,4-d,7-s]\nVisitThese is currently: [3-b,4-d,7-s] \nNeighbors of vertex b : [d-4,a-3,s-2,h-1] \nDirty visitations : [5-s,4-h,4-d,7-s], Clean visitations : [4-d,4-h,5-s]\nVisitThese is currently: [4-d,4-h,5-s] \nNeighbors of vertex d : [a-4,f-5,b-4] \nDirty visitations : [9-f,4-h,5-s], Clean visitations : [4-h,5-s,9-f]\nVisitThese is currently: [4-h,5-s,9-f] \nNeighbors of vertex h : [f-3,g-2,b-1] \nDirty visitations : [7-f,6-g,5-s,9-f], Clean visitations : [5-s,6-g,7-f]\nVisitThese is currently: [5-s,6-g,7-f] \nNeighbors of vertex s : [c-3,b-2,a-7] \nDirty visitations : [8-c,6-g,7-f], Clean visitations : [6-g,7-f,8-c]\nVisitThese is currently: [6-g,7-f,8-c] \nNeighbors of vertex g : [h-2,e-2] \nDirty visitations : [8-e,7-f,8-c], Clean visitations : [7-f,8-c,8-e]\nVisitThese is currently: [7-f,8-c,8-e] \nNeighbors of vertex f : [d-5,h-3] \nDirty visitations : [8-c,8-e], Clean visitations : [8-c,8-e]\nVisitThese is currently: [8-c,8-e] \nNeighbors of vertex c : [l-2,s-3] \nDirty visitations : [10-l,8-e], Clean visitations : [8-e,10-l]\nVisitThese is currently: [8-e,10-l] \nNeighbors of vertex e : [g-2,k-5] \nDirty visitations : [13-k,10-l], Clean visitations : [10-l,13-k]\nVisitThese is currently: [10-l,13-k] \nNeighbors of vertex l : [i-4,j-4,c-2] \nDirty visitations : [14-i,14-j,13-k], Clean visitations : [13-k,14-i,14-j]\nVisitThese is currently: [13-k,14-i,14-j] \nNeighbors of vertex k : [e-5,i-4,j-4] \nDirty visitations : [14-i,14-j], Clean visitations : [14-i,14-j]\nVisitThese is currently: [14-i,14-j] \nNeighbors of vertex i : [j-6,k-4,l-4] \nDirty visitations : [14-j], Clean visitations : [14-j]\nVisitThese is currently: [14-j] \nNeighbors of vertex j : [k-4,l-4,i-6] \nDirty visitations : [], Clean visitations : []\n\nVertex a is at distance 0 via [a-0]\nVertex b is at distance 3 via [a-0,b-3]\nVertex c is at distance 8 via [a-0,b-3,s-5,c-8]\nVertex d is at distance 4 via [a-0,d-4]\nVertex e is at distance 8 via [a-0,b-3,h-4,g-6,e-8]\nVertex f is at distance 7 via [a-0,b-3,h-4,f-7]\nVertex g is at distance 6 via [a-0,b-3,h-4,g-6]\nVertex h is at distance 4 via [a-0,b-3,h-4]\nVertex i is at distance 14 via [a-0,b-3,s-5,c-8,l-10,i-14]\nVertex j is at distance 14 via [a-0,b-3,s-5,c-8,l-10,j-14]\nVertex k is at distance 13 via [a-0,b-3,h-4,g-6,e-8,k-13]\nVertex l is at distance 10 via [a-0,b-3,s-5,c-8,l-10]\nVertex s is at distance 5 via [a-0,b-3,s-5]\n```\n\nAs computed by:\n```\n% =========\n% Graph definition\n% =========\n\n% ---------\n% \"Asymmetric connection relation\"\n% ---------\n\n% \"Connection relation\" between vertices. Each edge is labeled with\n% a \"distance\" (cost)\n%\n% connection(?VertexName1,?VertexName2,?Cost).\n%\n% This also indirectly defines the set of vertices which are simply\n% given by their names, which are atoms. \n%\n% This relation is not symmetric. We make it symmetric by defining\n% a symmetric relations \"on top\". Improvement: This relation could\n% be made \"canonical\" in that a unique representation would be\n% enforced by demanding that VertexName1 @=< VertexName (i.e. the\n% vertex names would appear sorted by the standard order of terms). \n\nconnection(s, c, 3).\nconnection(c, l, 2).\nconnection(l, i, 4).\nconnection(l, j, 4).\nconnection(i, j, 6).\nconnection(i, k, 4).\nconnection(j, k, 4).\nconnection(k, e, 5).\nconnection(e, g, 2).\nconnection(g, h, 2).\nconnection(h, f, 3).\nconnection(f, d, 5).\nconnection(d, a, 4).\nconnection(b, d, 4).\nconnection(b, a, 3).\nconnection(b, s, 2).\nconnection(b, h, 1).\nconnection(a, s, 7).\n\n% ---------\n% \"Symmetric connection relation\"\n% ---------\n\nsym_connection(Vertex1,Vertex2,Cost) :- connection(Vertex1,Vertex2,Cost).\nsym_connection(Vertex1,Vertex2,Cost) :- connection(Vertex2,Vertex1,Cost).\n\n% =========\n% Start measuring paths and their cost from vertex 'a'.\n%\n% Initially we only know about vertex 'a' itself\n%\n% - It is the only member in the list of vertices to be visited next,\n%   at  distance/cost 0. This is represented by a single pair in list\n%   VisitThese: it is a list containing only [0-a].\n% - We have a path to 'a' with overall distance/cost 0, containing only\n%   vertex 'a' found at cost 0: the path is [a-0].\n%   PathContainerIn maps 'a', the destination vertex, to that path\n%   [[a-0]]. \n%   The container is implemented by an \"association list\" (a \"map\") \n%   from library(assoc); other abstract data types are possible, in\n%   particular SWI-Prolog's \"dict\" if this were running in SWI-Prolog.\n% =========\n\nmain :-\n   list_to_assoc([a-[a-0]],PathContainerIn),\n   VisitThese=[0-a], \n   % Do it!\n   dijsktra(VisitThese,PathContainerIn,PathContainerOut),\n   % We are done! we just need to print out...\n   assoc_to_list(PathContainerOut,Pairs),\n   print_list(Pairs).\n\nprint_list([]).\nprint_list([Vertex-Path|More]) :-\n   reverse(Path,ReversedPath),\n   Path=[_-Dist|_],\n   format(\"Vertex ~q is at distance ~d via ~q~n\",[Vertex,Dist,ReversedPath]),\n   print_list(More).\n   \n% =========\n% dijsktra([CurCost-CurVertex|More],PathContainerIn,PathContainerOut).\n% \n% - The first argument is the \"list of vertexes to be visited next\", named \n%   \"VisitThese\" (i.e. the \"boundary\" of the search), sorted by the distance/cost\n%   of their path from the initial vertex, ascending (so we always need\n%   to just grab the head of \"VisitThese\" to find the vertex which is guaranteed \n%   nearest the start vertex on visit).\n% - The second argument is the \"container of the best-path-known-so-far to \n%   vertexes already seen (all of those visited or tentatively visited in \n%   handle_neighbors/7, for which a best-path-known-so-far could be determined)\n%   Note that a cheaper representation than keeping the full path would be \n%   to just keep the last edge of the path.\n%   The container is used to create a new container, accumulator-style, which \n%   is the third argument, which contains all the best paths to all the vertices\n%   at success-time.\n% =========\n\ndijsktra([],PathContainer,PathContainer) :- !.\n\ndijsktra(VisitThese,PathContainerIn,PathContainerOut) :-\n   VisitThese = [CurCost-CurVertex|MoreToVisit],\n   format(\"VisitThese is currently: ~q ~n\",[VisitThese]),   \n   % bagof/3 fails if no neighbors, but that's only the case if the initial vertex is unconnected\n   bagof(LocalNeighbor-LocalCost,\n         sym_connection(CurVertex,LocalNeighbor,LocalCost),\n         Neighbors),  \n   format(\"Neighbors of vertex ~q : ~q ~n\",[CurVertex,Neighbors]),\n   get_assoc(CurVertex,PathContainerIn,CurPath),  \n   % format(\"Found path for current vertex ~q: ~q~n\",[CurVertex,CurPath]),\n   handle_neighbors(CurVertex,CurPath,CurCost,Neighbors,PathContainerIn,PathContainer2,VisitTheseToo),\n   append(VisitTheseToo,MoreToVisit,Dirty),\n   clean_visit_these_list(Dirty,Clean),\n   format(\"Dirty visitations : ~q, Clean visitations : ~q~n\",[Dirty,Clean]),\n   dijsktra(Clean,PathContainer2,PathContainerOut).\n    \n% =========\n% \"Tentatively visit\" all the neighbors of \"CurVertex\" (\"CurVertex\" can be reached through\n% \"CurPath\" at cost \"CurCost\"), determining for each a path and overall cost\n%\n% We may reach a neighbor of \"CurVertex\":\n%\n% - for the first time if no path to it is stored in PathContainer yet. \n%   Then a new path is stored in PathContainer and the vertex is added to\n%   the list of vertexes-to-be-visted-next, \"VisitThese\" (which will have\n%   to be sorted by overall path cost before the recursive call to dijkstar/3)\n% - for a not-the-first time if a path to it is stored in PathContainer yet\n%   (so the neighbor has been visited (and its old path is - by construction - \n%    cheaper and it shall not be visited again) or it has been only \n%    tentatively visited (and its old path *may* be costlier and thus demand\n%    replacement by the new path as well as addition of a cheaper \n%    entry in the list of vertexes to be visited next)\n% \n% Note that the list \"Neighbors\" also contains the neighboring vertex on\n% the path \"CurPath\" through which \"CurVertex\" was reached in the first place.\n% But there is no need to handle that case in a special way. This is just a\n% vertex that has been visited previously and the old path is cheaper.\n%\n% handle_neighbors(+CurVertex,+CurPath,+CurCost,\n%                  +Neighbors,\n%                  +PathContainerIn,-PathContainerOut,\n%                  -VisitThese)\n%\n% =========\n\n% case of \"all neighbor vertices handled, we are done\"\n\nhandle_neighbors(_CurVertex,_CurPath,_CurCost,[],PathContainer,PathContainer,[]).\n\n% case of \"neighbor vertex already has a path but the new path is costlier\n\nhandle_neighbors(CurVertex,CurPath,CurCost,Neighbors,PathContainerIn,PathContainerOut,VisitThese) :-\n   Neighbors=[Vertex-LocalCost|More],                           % grab the next neighbor\n   get_assoc(Vertex,PathContainerIn,[Vertex-BestCostSoFar|_]),  % grab its known path, if it exists (fails if not)\n   NewCost is CurCost+LocalCost, \n   NewCost >= BestCostSoFar,                                    % the new path is costlier\n   !,                                                           % do nothing, move to next neighbor\n   handle_neighbors(CurVertex,CurPath,CurCost,More,PathContainerIn,PathContainerOut,VisitThese).\n\n% case of \"neighbor vertex already has a path but the new path is cheaper; note that it is added to the \"VisitThese\" list\n\nhandle_neighbors(CurVertex,CurPath,CurCost,Neighbors,PathContainerIn,PathContainerOut,[NewCost-Vertex|VisitThese]) :-\n   Neighbors=[Vertex-LocalCost|More],                           % grab the next neighbor\n   get_assoc(Vertex,PathContainerIn,[Vertex-BestCostSoFar|_]),  % grab its known path, if it exists (fails if not)\n   NewCost is CurCost+LocalCost,\n   NewCost < BestCostSoFar,                                     % new path is cheaper\n   !,                                                           % replace path, retain neighbor as \"to be visited\"\n   put_assoc(Vertex,PathContainerIn,[Vertex-NewCost|CurPath],PathContainer2),\n   handle_neighbors(CurVertex,CurPath,CurCost,More,PathContainer2,PathContainerOut,VisitThese).\n\n% case of \"neighbor vertex has no path yet\"; note that it is added to the \"VisitThese\" list\n\nhandle_neighbors(CurVertex,CurPath,CurCost,Neighbors,PathContainerIn,PathContainerOut,[NewCost-Vertex|VisitThese]) :-\n   Neighbors=[Vertex-LocalCost|More],                   % grab the next neighbor\n   \\+ get_assoc(Vertex,PathContainerIn,_),              % vertex has no path yet\n   !,                                                   % the cut is not really needed\n   NewCost is CurCost+LocalCost,\n   put_assoc(Vertex,PathContainerIn,[Vertex-NewCost|CurPath],PathContainer2),\n   handle_neighbors(CurVertex,CurPath,CurCost,More,PathContainer2,PathContainerOut,VisitThese).\n   \n% ---\n% Transfrom list of elements \"Cost-Vertex\" \n%\n% ... which is the list of vertexes and their \"best cost yet\" that \n%     shall be expanded by the Dijkstra algorithm, but in which several\n%     entries for the same \"Vertex\" may appear\n% ... into a new list where there is always only exactly one entry for\n%     any \"Vertex\" appaearing in the original list, and the \"Cost\"\n%     associated to it is the minimum cost for that \"Vertex\".\n% ---\n\nclean_visit_these_list(Dirty,SortedByCostAsc) :-\n   predsort(sort_pairs,Dirty,SortedByVertexFirstCostSecond),\n   keep_best(SortedByVertexFirstCostSecond,DuplicatesRemovedMinCostRetained),\n   keysort(DuplicatesRemovedMinCostRetained,SortedByCostAsc).\n   \nsort_pairs(Order,Cost1-Vertex,Cost2-Vertex) :- \n   !,                                   % Same vertex - order depends on associated cost\n   compare(Order,Cost1,Cost2). \n   \nsort_pairs(Order,_-Vertex1,_-Vertex2) :-\n   Vertex1 \\== Vertex2,         \n   !,                                   % Different vertex - Sort lexicographically (cut is not needed actually)\n   compare(Order,Vertex1,Vertex2). \n   \nkeep_best([Cost-Vertex,_-Vertex|More],Out) :-  \n   !,                                   % Vertex appears twice - retain only first entry (with smallest cost)\n   keep_best([Cost-Vertex|More],Out).\n\nkeep_best([Cost1-Vertex1,Cost2-Vertex2|More],[Cost1-Vertex1|Out]) :-\n   Vertex1 \\== Vertex2,\n   !,                                   % Different vertex - Retain first vertex and its cost, move on\n   keep_best([Cost2-Vertex2|More],Out).\n   \nkeep_best([X],[X]).  % Termination case #1\nkeep_best([],[]).    % Termination case #2\n\n% ---\n% Test clean_visit_these_list/2\n% ---\n\n:- begin_tests(clean_visit_these_list).\n\ntest(1,true(Result == [])) :- clean_visit_these_list([],Result).\ntest(2,true(Result == [3-b])) :- clean_visit_these_list([3-b],Result).\ntest(2,true(Result == [3-b])) :- clean_visit_these_list([4-b,3-b,5-b],Result).\ntest(3,true(Result == [3-b,8-v,9-a,10-w])) :- clean_visit_these_list([8-v,10-w,9-a,3-b],Result).\ntest(4,true(Result == [2-w,3-b,8-v,9-a]))  :- clean_visit_these_list([8-v,10-w,9-a,4-w,3-b,2-w,12-v],Result).\n\n:- end_tests(clean_visit_these_list).\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How would increasing the edge weight on a graph affect the Dijkstra's algorithm?\r\n                \r\nThe question is: Consider the directed graph with 5 vertices. Let the Dijkstra’s\nalgorithm yield shortest paths from node s to all the other nodes, as shown\nin Fig. 1. Let the weight of the edge (x, t), increase and assume all nodes\nsomehow obtain this information. How does node s modify Dijkstra’s algorithm\nto make minimum recomputations? Provide the final solution in the\nform “Node s runs Dijkstra’s algorithm by initializing S as  and maintaining the list (< each node >) as .”\n\nMy question is... Isn't that a trick question because all it would do is increase the shortest path from s to t right?\n\nalright so my picture isnt working\n\nbut it works something like this:\n\ns->y->x->t\n\ny also points to z.\ny->z\n\nthese are one way directional arrows.\n    ", "Answer": "\r\nIf (s,y), (y, z), (y, x), (x, t) are the only edges in this graph, then yes: this only increases the weight (or distance) of the shortest path of s to t, since there is only one such path.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Parallelization of Dijkstra algorithm\r\n                \r\nI'm trying to write concurrent solution for Dijkstra algorithm. My approach is to break the set of vertices into continuous blocks and each block is processed by another thread. In general the algorithm for each block is: \n\n\nFind vertice with minimum weight of path to current global minimum among thread's vertices. \nSent local min verticle to main thread and wait for response.\nAfter all threads sent their local minimums the main thread wakes up, finds new global minimum among locals, marks it as visited, broadcast it to all threads and starts to wait for a new local minimums.\nThreads update weights from their verticles to global minimum and go to (1). \n\n\nThis algorithm repeats untill all local variables of thread are visited. Main threads exits when all working threads finished their work.\n\nTo implement this flow I use ManulaResetEvent objects.\nHowever sometimes(like 1 of 20 runs) I've got wrong results and I cannot figure out why.\n\n```\nclass Program\n{\n    private const int Size = 6;\n    private const int FirstVertexIndex = 0;\n    private const int MaxThreadsCount = 10;\n\n    private static int[,] _graphMatrix = new int[Size, Size];\n\n    private static ManualResetEvent _manualReset = new ManualResetEvent(false);\n    private static int _currentSource = FirstVertexIndex;\n\n    static Program()\n    {\n        //INIT ADJACENCY MATRIX\n    }\n\n\n    public static void Main()\n    {\n\n            for (var t = 1; t < MaxThreadsCount; t++)\n            {\n                //GC.Collect();\n\n                var sw = new Stopwatch();\n                sw.Start();\n\n                Dijkstra(t);\n\n                sw.Stop();\n                Console.WriteLine($\"Threads count: {t}; Average time: {sw.ElapsedMilliseconds} ms\");\n                sw.Reset();\n            }\n\n\n        Console.WriteLine();\n        Console.ReadLine();\n    }\n\n    private static void Dijkstra(int threadsCount)\n    {\n        var visited = new bool[Size];\n        var weights = new int[Size];\n\n        for(var i = 0; i < Size; i++)\n        {\n            weights[i] = int.MaxValue;\n        }\n\n        weights[FirstVertexIndex] = 0;\n\n        var values = new List<(int Index, int Weight)>();\n        var threadReseters = new List<ManualResetEvent>();\n        var threads = new List<Thread>();\n\n        var step = (int)Math.Ceiling((double)Size / threadsCount);\n\n        for(var t = 0; t < threadsCount; t++)\n        {\n            var start = t * step;\n\n            if(start >= Size)\n            {\n                break;\n            }\n\n            var end = start + step;\n            end = end >= Size ? Size : end;\n\n            values.Add((0, 0));\n            threadReseters.Add(new ManualResetEvent(false));\n            var index = t;\n            threads.Add(\n                new Thread(\n                    () => DoWork(\n                        weights,\n                        visited,\n                        start,\n                        end,\n                        index,\n                        threadReseters,\n                        values)));\n        }\n\n        threads.ForEach(t => t.Start());\n\n        while(threads.Any(t=> t.IsAlive || t.ThreadState == ThreadState.Running || t.ThreadState == ThreadState.WaitSleepJoin))\n        {\n            WaitHandle.WaitAll(threadReseters.ToArray());\n\n            var globalMin = FindMin(values);\n\n            if(_currentSource != -1)\n                visited[_currentSource] = true;\n\n            _currentSource = globalMin.Index;\n            _manualReset.Set();\n            _manualReset.Reset();\n\n        }\n\n        Console.WriteLine(PrintSolution(weights));\n    }\n\n    private static void DoWork(\n        int[] weights,\n        bool[] visited,\n        int start,\n        int end,\n        int index,\n        List<ManualResetEvent> threadReseters,\n        List<(int Index, int Weight)> results)\n    {\n\n        while(true)\n        {\n\n                var min = MinNonVisitedIndex(\n                    weights,\n                    visited,\n                    start,\n                    end);\n\n                results[index] = min;\n\n                var visitedCount = 0;\n\n                for (var i = start; i < end; i++)\n                {\n                    if (visited[i])\n                    {\n                        visitedCount++;\n                    }\n                }\n\n\n                if (visitedCount == end - start)\n                {\n                    threadReseters[index]\n                        .Set();\n\n                    break;\n                }\n\n                threadReseters[index]\n                    .Set();\n\n                _manualReset.WaitOne();\n\n                var localCurrentSource = _currentSource;\n\n                threadReseters[index]\n                    .Reset();\n\n\n                ReweightPaths(\n                    weights,\n                    visited,\n                    localCurrentSource,\n                    start,\n                    end);\n\n            }\n\n    }\n\n    private static void ReweightPaths(\n        int[] weights,\n        bool[] visited,\n        int current,\n        int start,\n        int end)\n    {\n        for(var i = start; i < end; i++)\n        {\n            if(!visited[i]\n               && _graphMatrix[current, i] != 0\n               && weights[current] != int.MaxValue\n               && weights[current] + _graphMatrix[current, i] < weights[i])\n            {\n                weights[i] = weights[current] + _graphMatrix[current, i];\n            }\n        }\n    }\n\n    private static (int Index, int Weight) MinNonVisitedIndex(\n        int[] weights,\n        bool[] visited,\n        int from,\n        int to)\n    {\n        var min = int.MaxValue;\n        var minIndex = -1;\n\n        for(var i = from; i < to; i++)\n        {\n            if(!visited[i] && weights[i] < min)\n            {\n                min = weights[i];\n                minIndex = i;\n            }\n        }\n\n        return (minIndex, minIndex != -1 ? weights[minIndex] : Int32.MaxValue);\n    }\n\n    private static (int Index, int Weight) FindMin(List<(int Index, int Weight)> values)\n    {\n        lock (o)\n        {\n            var min = (Index: -1, Weight: int.MaxValue);\n\n            for(int i = 0; i<values.Count; i++)\n            {\n                if(min.Weight > values[i].Weight)\n                {\n                    min.Weight = values[i].Weight;\n                    min.Index = values[i].Index;\n                }\n            }\n\n            return min;\n        }\n    }\n\n    private static string PrintSolution(int[] weights)\n    {\n        var sb = new StringBuilder();\n\n        for(var i = 0; i < Size; i++)\n        {\n            sb.Append($\"{i + 1}\\t\\t{weights[i]}\");\n            sb.AppendLine();\n        }\n\n        return sb.ToString();\n    }\n}\n\nstatic class MatrixExtensions\n{\n    public static string Print<T>(this T[,] seq)\n    {\n        var sb = new StringBuilder();\n\n        for(var i = 0; i < seq.GetLength(0); i++)\n        {\n            for(var j = 0; j < seq.GetLength(1); j++)\n            {\n                sb.Append($\"{seq[i, j].ToString()} \");\n            }\n\n            sb.Append(Environment.NewLine);\n        }\n\n        return sb.ToString();\n    }\n}\n```\n\n\nPlease, check http://parallelcomp.uw.hu/ch10lev1sec3.html . That's what I'm trying to implement, but in this code I have something like race condition somewhere and I cannot figure out where and why\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How to find the shortest diagonal path of in a squared grid using Dijkstra's algorithm in Java?\r\n                \r\nI am developing a system using Dijkstra's algorithm to display the shortest path in a squared grid using Java. When the path goes to a diagonal, vertical or horizontal cell near by, the path cost increases by 1. But the path's priority should be given to go through diagonal cells. Only when there is no possible diagonal cell near by, the path can go through a vertical or a horizontal cell. What is the most convenient method to do that?\n    ", "Answer": "\r\nIn Dijkstra's algorithm we keep selecting vertices which have not yet been selected and which have minimum distance from source. Here every next vertex or next square is equally far with a distance of one. Among the squares with minimum distance,if the diagonal square has not yet been included then include it, otherwise select either horizontal sidewise or vertical sidewise square. From implementation point of view it is just using if.. else construct. You can maintain some field for priority of node. Keep priority one for diagonal square and zero otherwise.\n\nMoreover Dijkstra's algorithm is not a well suit for this problem as Dijkstra's algorithm is used to find the shortest path from a single source vertex to all other vertices in the given graph. Though you have not mentioned in the question it looks like you intend to find shortest path from specific source square to specific destination square. \n\nAlso, all the reachable squares are equidistant so there is no fun in using Dijkstra'a algorithm here. Alternatively, You can use DFS or BFS treating the grid as a graph. For yet another alternative you might also have a look at Dynamic Programming style on this problem for which you can find some examples here.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra algorithm: should it work if there are 2 graphs that are not connected?\r\n                \r\nI have currently implemented Dijkstra's algorithm but the problem comes when I test my algorithm with a graph like this:\n\n\nand try to go from C to B. And I know why it doesn't work. But I wonder if the normal implementation would work if there is a graph like this given?\n\n```\n  internal static Stack<string> Dijkstra(string sourcePoint, string targetPoint, Graph graph)\n    {\n        List<string> verticesStringList = graph.GetAllVertices();\n        Dictionary<string, Vertex> verticesDictionary = new Dictionary<string, Vertex>();\n        InitializeVerticesDictionary(sourcePoint, verticesStringList, verticesDictionary);\n\n        while (verticesDictionary.Values.ToList().Any(x => x.IsVisited == false))\n        {\n            KeyValuePair<string, Vertex> keyValuePair = verticesDictionary.Where(x => x.Value.IsVisited == false).ToList().Min();\n            string vertexKey = keyValuePair.Key;\n            Vertex currentVertex = keyValuePair.Value;\n            List<string> neighbourVertices = graph.GetNeighbourVerticesSorted(keyValuePair.Key);\n            foreach (string neighbourVertexString in neighbourVertices)\n            {\n                Vertex neighbourVertex = verticesDictionary[neighbourVertexString];\n                int newDistanceFromStartVertex = currentVertex.ShortestDistanceFromTarget + graph.GetEdgeWeight(keyValuePair.Key, neighbourVertexString);\n                if (newDistanceFromStartVertex < neighbourVertex.ShortestDistanceFromTarget)\n                {\n                    verticesDictionary[neighbourVertexString].ShortestDistanceFromTarget = newDistanceFromStartVertex;\n                    verticesDictionary[neighbourVertexString].PreviousVertex = keyValuePair.Key;\n                }\n            }\n            verticesDictionary[vertexKey].IsVisited = true;\n        }\n\n        return FormShortestPath(targetPoint, verticesDictionary);\n\n    }\n\n    private static Stack<string> FormShortestPath(string targetPoint, Dictionary<string, Vertex> verticesDictionary)\n    {\n        Stack<string> traverseStack = new Stack<string>();\n        KeyValuePair<string, Vertex> vertex = verticesDictionary.Where(x => x.Key == targetPoint).FirstOrDefault();\n        while (vertex.Value.PreviousVertex != null)\n        {\n            traverseStack.Push(vertex.Value.PreviousVertex + \" Goes To \" + vertex.Key); //the end edge\n            vertex = verticesDictionary.Where(x => x.Key == vertex.Value.PreviousVertex).FirstOrDefault();\n        }\n        return traverseStack;\n    }\n\n\n\nprivate static void InitializeVerticesDictionary(string sourcePoint, List<string> verticesStringList, Dictionary<string, Vertex> verticesDictionary)\n    {\n        foreach (string vertexString in verticesStringList)\n        {\n            Vertex vertex = new Vertex\n            {\n                ShortestDistanceFromTarget = int.MaxValue\n            };\n\n            if (vertexString == sourcePoint)\n            {\n                vertex.ShortestDistanceFromTarget = 0;\n            }\n\n            verticesDictionary.Add(vertexString, vertex);\n        }\n    }\n```\n\n\nUPDATE: I changed my condition to ```\nverticesDictionary.Values.ToList().Any(x => x.IsVisited == false && x.ShortestDistanceFromTarget != int.MaxValue)```\n and now I am not getting an overflow that I mentioned in the comments.\n    ", "Answer": "\r\n```\nIsVisited```\n here is a bit misleading, as you can actually visit nodes that you can not reach from the source node. I would rename it to ```\nisProcessed```\n. To check if you can reach from source node to another node you will need to check if its distance is ```\nint.maxVal```\n.\n\nTo avoid overflow, do not iterate neighbors when currentVertex.ShortestDistanceFromTarget is ```\nint.maxVal```\n, as it is already an unreachable node from source node.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Swift Dijkstra Algorithm Error (EXC_BAD_INSTRUCTION)\r\n                \r\nSo I've built a swift playground that uses Dijkstra's algorithm to find the shortest route. However, I can't seem to manipulate my txt file so that my function will work in every case. It only works for a select few pathways. Whenever I map out a pathway I believe should work, it responds with: ```\nExecution was interrupted, reason: EXC_BAD_INSTRUCTION(code=EXC_I386_INVOP, subcode=0x0)```\n. \n\nHow can I manipulate my txt file or my function/file manipulation to take my txt file input? (Where error occurred is marked -- near the bottom)\n\nUsually the error occurs when trying to build a route backwards.\nEx: a1 to a3 works\nEx: a3 to a1 does not work\n\nCode:\n\n```\nimport Foundation\n\n// Extensions\n\nextension Array {\n    func each<U>(closure:(Element)->U?)->U? {\n        for i in self {\n            let returnVal = closure(i)\n            if (returnVal != nil) { return returnVal }\n        }\n        return nil\n    }\n}\n\nextension Int {\n    func times(closure:(Int)->Void) {\n        for i in 0..<self { closure(i) }\n    }\n}\n\n// Structs\n\nstruct Edge {\n    var wt: Double\n    var desV: Room\n}\n\nstruct Graph { var vertices:[Room] }\n\n// Room Class\n\nclass Room: Hashable {\n\n    var name: String?\n    var neighbors: [Edge] = []\n    var hashValue: Int {\n        get { return name!.hashValue }\n    }\n\n    init(){}\n\n    convenience init(name:String) {\n        self.init()\n        self.name = name\n    }\n\n    func distanceToRoom(targetRoom:Room) -> Edge? {\n        return self.neighbors.each({ (edge:Edge) -> Edge? in\n            if (edge.desV == targetRoom) {\n                return edge\n            }\n            return nil\n        })\n    }\n}\n\n// Functions\n\nfunc == (lhs:Room, rhs:Room) -> Bool { return lhs.hashValue == rhs.hashValue }\n\nfunc say( a:String ) { print( a, terminator:\"\") }\n\nfunc dijkstra(graph:Graph, target:Room) -> [Room:Room] {\n\n    var queue = graph.vertices\n    var distances:[Room:Double] = [:]\n    var previousPaths:[Room:Room] = [:]\n    let currentRoom:Room = queue[0]\n\n    queue.each {(element:Room) -> Void? in\n        distances[element] = Double.infinity\n        previousPaths[element] = nil\n        return nil\n    }\n\n    distances[currentRoom] = 0\n\n    while (queue.count > 0) {\n\n        var closestNode:Room? = nil\n        let wt:Double = Double.infinity\n        queue.each({ (Room:Room) -> Void? in\n            if (closestNode == nil || wt < distances[Room]!) {\n                closestNode = Room\n            }\n            return nil\n        })\n        if (closestNode! == target) {\n            return previousPaths\n        }\n\n        let nodeIndex:Int? = queue.indexOf(closestNode!)\n        queue.removeAtIndex(nodeIndex!)\n        if (closestNode?.neighbors != nil && closestNode?.neighbors.count > 0) {\n            closestNode?.neighbors.each({(neighbor:Edge) -> Void? in\n\n                let wt = distances[closestNode!]! + closestNode!.distanceToRoom(neighbor.desV)!.wt\n                if wt < distances[neighbor.desV] {\n                    distances[neighbor.desV] = wt\n                    previousPaths[neighbor.desV] = closestNode!\n                }\n                return nil\n            })\n        }\n    }\n    return previousPaths\n}\n\n// File Management\n\n//let url = NSURL(string:\"file:///Users/caleb/Documents/Xcode/CRHS/CRHS/dtb.txt\")!\nlet url = NSURL(string: \"file:///Users/caleb/Desktop/rooms.txt\")!\nlet data = NSData(contentsOfURL: url)\nlet sdata = String(data: data!, encoding: NSUTF8StringEncoding)\nlet dataArray = sdata!.characters.split{$0 == \"\\n\"}.map(String.init)\nvar rooms = [String:Room]()\n\nprint(\"data:\\n-------\")\n\nfor i in 0 ..< dataArray.count {\n    let conn = dataArray[i].characters.split{$0 == \"\\t\"}.map(String.init)\n    var room1: Room\n    if ( rooms[conn[0]] == nil ) {\n        room1 = Room(name: conn[0])\n    } else {\n        room1 = rooms[conn[0]]!\n    }\n\n    let room2 = Room(name: conn[2])\n    let edwt = (conn[1] as NSString).doubleValue\n    var edge = Edge(wt: edwt, desV: room2)\n\n    if room1.neighbors.count == 0 {\n        room1.neighbors = [ edge ]\n    } else {\n        var found: Bool = false\n        for e in room1.neighbors {\n            if ( e.desV.name == edge.desV.name ) {\n                found = true\n            }\n        }\n        if ( found == false ) {\n            room1.neighbors.append(edge)\n        }\n    }\n    rooms[conn[0]] = room1\n}\n\nfor (nam,room) in rooms {\n    print(nam)\n    print(\"----\")\n    for n in room.neighbors {\n        if let un = n.desV.name {\n            print( un, terminator: \"  weight: \")\n        }\n        print( n.wt )\n    }\n    print(\"\\n\")\n}\nvar namessofrooms = rooms.map { $0.0 }\nvar roomsofrooms = rooms.map { $0.1 }\n\nprint(\"Rooms:\")\nprint(rooms)\nprint(\"-------\\n\")\n\n// Calculating\n\nvar source = rooms[\"a1\"]!\nvar target = rooms[\"a4\"]!\n\nroomsofrooms.append(source)\nvar reversedRooms: Array = roomsofrooms.reverse()\nreversedRooms.append(target)\n\nvar graph = Graph(vertices: reversedRooms)\nvar paths = dijkstra(graph, target: target)\nvar pathVertices:[Room] = [target]\n\nvar child = target\n\nwhile (child != source) {\n    print(child.name)\n    print(\":::::\")\n    child = paths[child]! //Error occurs here\n    print(child.name)\n    pathVertices.append(child)\n}\n\nvar pathString:[String] = pathVertices.reverse().map { (Room:Room) -> String in\n    return Room.name!\n}\nprint(\"solution:\\n-------\")\nprint(pathString)\n```\n\n\nBelow is the file I input:\n\n```\na1  1   a2\na2  1   a3\na3  1   a4\n```\n\n\nIf I input the following file the code above will not work:\n\n```\na1  1   a2\na2  1   a3\na3  1   a4\na4  1   a5\n```\n\n\n(Update: File Map Clarification)\nFirst column is the first room, second is the weight between the rooms, third is the room connected to the first.\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How to modify the Dijkstra's algorithm so that it passes through given multiple edges in python?\r\n                \r\n```\ndef dijikstra(start,goal):\n    graph = {\n\n        'a': {'b': 15, 'c': 13},\n        'b': {'c': 12, 'd': 16},\n        'c': {'d': 19, 'e': 21, 'b': 12},\n        'd': {'e': 13, 'z': 17},\n        'e': {'z': 16, 'd': 13},\n        'z': {'d': 17}\n\n    }\n    shortest_distance = {}\n    track_predecessor = {}\n    unseen_nodes = graph\n    infinity = 999999\n    track_path = []\n\n\n    for node in unseen_nodes:\n        shortest_distance[node] = infinity\n\n    shortest_distance[start] = 0\n\n    while unseen_nodes:\n        min_distance_node = None\n        for node in unseen_nodes:\n            if min_distance_node is None:\n                min_distance_node = node\n            elif shortest_distance[node] < shortest_distance[min_distance_node]:\n                min_distance_node = node\n\n        path_options = graph[min_distance_node].items()\n        for child_node, weight in path_options:\n\n            if weight+shortest_distance[min_distance_node]<shortest_distance[child_node]:\n                shortest_distance[child_node] = weight+shortest_distance[min_distance_node]\n                track_predecessor[child_node] = min_distance_node\n        unseen_nodes.pop(min_distance_node)\n\n\n    currentNode = goal\n\n    while currentNode != start:\n        try:\n            track_path.insert(0,currentNode)\n            currentNode = track_predecessor[currentNode]\n        except KeyError:\n            print('path is not reachable')\n            break\n    track_path.insert(0,start)\n\n    if shortest_distance[goal] != infinity:\n        print('For path ' + str(track_path))\n        print(\"shortest distance is :\" + str(shortest_distance[goal]))\n\n\ndijikstra('a','z')\n```\n\nHere you can see the basic implementation of the Dijkstra's algorithm in python. By this we can get the shortest path. What I want to do here is finding the shortest path from source to end destination And also that path should go through given edges. as an example, going from a to z covering b and c so that it can achieve shortest path.\nHow to achieve this scenario by modifying this code\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "DAG-shortest path vs Dijkstra algorithm\r\n                \r\nI have implemented the Dijkstra algorithm from the pseudocode found in the reference \"Introduction to Algorithms\", 3rd edition by Cormen, for the single-source shortest path problem.\n\nMy implementation was made on python using linked lists to represent graphs in an adjacency list representation. This means that the list of nodes is a linked list and each node has a linked list to represent the edges of each node. Furthermore, I didn't implement or use any binary heap or fibonacci heap for the minimum priority queue that the algorithm needs, so I search for each node in O(V) time inside the linked list of nodes when the procedure needs to extract the next node with the smallest distance from the source.\n\nOn the other hand, the reference also provides an algorithm for DAG's (which I have implemented) using a topological sort before applying the relaxation procedure to all the edges. \n\nWith all these context, I have a Dijkstra algorithm with a complexity of\n\n\n  O(V^2)\n\n\nAnd a DAG-shortest path algorithm with a complexity of \n\n\n  O(V+E) \n\n\nBy using the ```\ntimeit.default_timer()```\n function to calculate the running times of the algorithms, I have found that the Dijkstra algorithm is faster that the DAG algorithm when applied to DAGs with positive edge weights and different graph densities, all for 100 and 1000 nodes. \n\nShouldn't the DAG-shortest path algorithm be faster than Dijkstra for DAGs? \n    ", "Answer": "\r\nYour running time analysis for both algorithms is correct and it's true that DAG shortest path algorithm is faster than Dijkstra's algorithm for DAGs.\n\nHowever, there are 3 possible reasons for your testing results:\n\n\nThe graph you used for testing is very dense. When the graph is very dense, E ≈ V^2, so the running time for both algorithms approach O(V^2).\nThe number of vertices is still not large enough. To solve this, you can use a much larger graph for further testing.\nThe initialization of the DAG costs a lot of running time.\n\n\nAnyway, DAG shortest path algorithm should be faster than Dijkstra's algorithm theoretically.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How to refine Dijkstra's Algorithm, Not Finding Optimal Path\r\n                \r\nHere is my implementation of the well known Dijkstra algorithm:\n\n```\nstd::vector<unsigned> RouteFinder::findPathBetweenIntersections(unsigned intersect_id_start, unsigned intersect_id_end) {\n\n    //Get number of intersections and reference graph from streetGraph class\n    StreetGraph* streetGraph = StreetGraph::getGraphPointer();\n    unsigned intersectionCount = streetGraph->getIntersectioncount();\n    std::vector<attachedSegments> referenceGraph = streetGraph->getStreetGraph();\n\n    /*Initialize:\n     * min_distance: Min Distance to get to index node\n     * active_vertices: The nodes to check next\n     * cameAlong: Street Segments used to get to the node\n     * cameFrom: Intersections taken to get to a node\n     */\n    vector<double> min_distance( intersectionCount, DBL_MAX );\n    min_distance[ intersect_id_start ] = 0.0;\n\n    set< pair<double,unsigned> > active_vertices;\n    active_vertices.insert( {0.0,intersect_id_start} );\n\n    vector<unsigned> cameAlong(intersectionCount,UINT_MAX);\n\n    vector<unsigned> cameFrom(intersectionCount,0);\n\n    //For each node in active_vertices\n    while (!active_vertices.empty()) {\n        unsigned currentNode = active_vertices.begin()->second;\n        if (currentNode == intersect_id_end) return buildPath(cameFrom, cameAlong, currentNode, intersect_id_start);\n        active_vertices.erase( active_vertices.begin() );\n        for (auto edge : referenceGraph[currentNode].streetSegments) \n            if (min_distance[get<2>(edge)] > min_distance[currentNode] + get<0>(edge)) {\n\n                //If the new distance is better than the one that is there\n                //Remove the previous data\n                active_vertices.erase( { min_distance[get<2>(edge)], get<2>(edge) } );\n                //Calculate the better distance and replace it\n                min_distance[get<2>(edge)] = min_distance[currentNode] + get<0>(edge);\n\n                //Add 15 seconds if the street has changed\n                if ((cameAlong[currentNode] != UINT_MAX\n                        && getStreetSegmentInfo(cameAlong[currentNode]).streetID != getStreetSegmentInfo(get<1>(edge)).streetID)\n                        ) {\n                    min_distance[get<2>(edge)] = min_distance[get<2>(edge)] + .25;\n                }\n\n                active_vertices.insert( { min_distance[get<2>(edge)], get<2>(edge) } );\n\n                //Record where you came from\n                cameAlong[get<2>(edge)] = get<1>(edge);\n                cameFrom[get<2>(edge)] = currentNode;\n            }\n    }\n\n    //Return nothing if nothing found\n    vector<unsigned> nothing;\n    return nothing;\n}\n```\n\n\nMy graph is a vector of structures called \"intersectionNode\". Each \"intersectionNode\" has a vector (among other useful info) of ```\ntuple<double weight,int streetSegment,int nextIntersection>```\n.\n\nI adapted my implementation from examples I found online and from friends, it is pretty fast. But it does not seem to return the fastest path. Does anything jump out to you as wrong, any hints for debugging?\n\nAlso, I have incorporated a run penalty of .25 minutes (15 seconds).\n\nThanks for the help!\n    ", "Answer": "\r\nI found the answer! When comparing new paths against old paths. I did not take into account the turning costs. Thanks guys...\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "What is the space complexity of Dijkstra Algorithm?\r\n                \r\nThe time complexity for Dijkstra Algorithm using an array is O(V^2) and if priority queue is implemented, we can further improve the complexity to O(E log V). But what about its space complexity? Is it O(V) in both cases?\n    ", "Answer": "\r\nTime and Space for Dijkstra Algorithm:\n\nTime: O((|V| + |E|) log V)\nSpace: O(|V| + |E|)\n\nHowever, (E >= V - 1) so |V| + |E| ==> |E|. But usually we use both V and E\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "What data structures to use for Dijkstra's algorithm in Erlang?\r\n                \r\nDisclaimer: The author is a newbie in Erlang.\n\nImagine, we have a graph consisting of 1M nodes, and each node has 0-4 neighbours (the edges are emanating from each node to those neighbours, so the graph is directed and connected).\n\nHere is my choice of data structures:\n\nTo store the graph I use digraph, which is based on ETS tables. This allows fast (O(1)) access to the neighbours of a node.\n\nFor the list of unvisited nodes, I use gb_sets:take_smallest (the node is already sorted, and it is simultaneously deleted after fetching).\n\nFor the list of predecessors I use the dict structure, which allows to store the predecessors in the following way: {Node1,Node1_predecessor},{Node2,Node2_predecessor}.\n\nFor the list of visited nodes I use a simple list.\n\nProblems:\n\n\nThe code becomes very hard to read and maintain when I try to update the weight of a node both in the digraph structure and in the Unvisited_nodes structure. It doesn't seem the right way to keep one 'object' with the 'fields' that need to be updated in two data structures simultaneously. What is the right way to do that?\nThe same question is about predecessors list. Where should I store the predecessor 'field' of a node 'object'? Maybe in the Graph (digraph structure)?\nMaybe I should rethink the whole Dijkstra's algorithm in terms of processes and messages instead of objects (nodes and edges) and their fields(weights)?\n\n\nUPD:\n\nHere is the code based on the recommendations of Antonakos:\n\n```\ndijkstra(Graph,Start_node_name) ->\n\n    io:format(\"dijkstra/2: start~n\"),\n\n    Paths = dict:new(),\n    io:format(\"dijkstra/2: initialized empty Paths~n\"),\n\n    Unvisited = gb_sets:new(),\n    io:format(\"dijkstra/2: initialized empty Unvisited nodes priority queue~n\"),\n\n    Unvisited_nodes = gb_sets:insert({0,Start_node_name,root},Unvisited),\n    io:format(\"dijkstra/2: Added start node ~w with the weight 0 to the Unvisited nodes: ~w~n\", [Start_node_name, Unvisited_nodes]),\n\n    Paths_updated = loop_through_nodes(Graph,Paths,Unvisited_nodes),\n    io:format(\"dijkstra/2: Finished searching for shortest paths: ~w~n\", [Paths_updated]).\n\n\n\n\nloop_through_nodes(Graph,Paths,Unvisited_nodes) ->\n    %% We need this condition to stop looping through the Unvisited nodes if it is empty\n    case gb_sets:is_empty(Unvisited_nodes) of\n        false -> \n            {{Current_weight,Current_name,Previous_node}, Unvisited_nodes_updated} = gb_sets:take_smallest(Unvisited_nodes),\n            case dict:is_key(Current_name,Paths) of\n                false ->\n                    io:format(\"loop_through_nodes: Found a new smallest unvisited node ~w~n\",[Current_name]),\n\n                    Paths_updated = dict:store(Current_name,{Previous_node,Current_weight},Paths),\n                    io:format(\"loop_through_nodes: Updated Paths: ~w~n\",[Paths_updated]),\n\n                    Out_edges = digraph:out_edges(Graph,Current_name),\n                    io:format(\"loop_through_nodes: Ready to iterate through the out edges of node ~w: ~w~n\",[Current_name,Out_edges]),\n\n                    Unvisited_nodes_updated_2 = loop_through_edges(Graph,Out_edges,Paths_updated,Unvisited_nodes_updated,Current_weight),\n                    io:format(\"loop_through_nodes: Looped through out edges of the node ~w and updated Unvisited nodes: ~w~n\",[Current_name,Unvisited_nodes_updated_2]),\n\n                    loop_through_nodes(Graph,Paths_updated,Unvisited_nodes_updated_2);\n                    true ->\n                    loop_through_nodes(Graph,Paths,Unvisited_nodes_updated)\n            end;\n        true -> \n            Paths\n    end.\n\nloop_through_edges(Graph,[],Paths,Unvisited_nodes,Current_weight) ->\n                    io:format(\"loop_through_edges: No more out edges ~n\"),\n    Unvisited_nodes;\n\nloop_through_edges(Graph,Edges,Paths,Unvisited_nodes,Current_weight) ->\n                    io:format(\"loop_through_edges: Start ~n\"),\n    [Current_edge|Rest_edges] = Edges,\n    {Current_edge,Current_node,Neighbour_node,Edge_weight} = digraph:edge(Graph,Current_edge),\n    case dict:is_key(Neighbour_node,Paths) of\n        false ->\n                    io:format(\"loop_through_edges: Inserting new neighbour node ~w into Unvisited nodes~n\",[Current_node]),\n            Unvisited_nodes_updated = gb_sets:insert({Current_weight+Edge_weight,Neighbour_node,Current_node},Unvisited_nodes),\n                    io:format(\"loop_through_edges: The unvisited nodes are: ~w~n\",[Unvisited_nodes_updated]),\n            loop_through_edges(Graph,Rest_edges,Paths,Unvisited_nodes_updated,Current_weight);\n        true ->\n            loop_through_edges(Graph,Rest_edges,Paths,Unvisited_nodes,Current_weight)\n    end.\n```\n\n    ", "Answer": "\r\nYour choice of data structures looks OK, so it is mostly a question of what to insert in them and how to keep them up to date. I'd suggest the following (I have changed the names a bit):\n\n\n```\nResult```\n: A ```\ndict```\n mapping ```\nNode```\n to ```\n{Cost, Prev}```\n, where ```\nCost```\n is the total cost of the path to ```\nNode```\n and ```\nPrev```\n is its predecessor on the path.\n```\nOpen```\n: A ```\ngb_sets```\n structure of ```\n{Cost, Node, Prev}```\n.\nA graph with edges of the form ```\n{EdgeCost, NextNode}```\n.\n\n\nThe result of the search is represented by ```\nResult```\n and the graph isn't updated at all. There is no multiprocessing or message passing.\n\nThe algorithm goes as follows:\n\n\nInsert ```\n{0, StartNode, Nil}```\n in ```\nOpen```\n, where ```\nNil```\n is something that marks the end of the path.\nLet ```\n{{Cost, Node, Prev}, Open1} = gb_sets:take_smallest(Open)```\n. If ```\nNode```\n is already in ```\nResult```\n then do nothing; otherwise add ```\n{Cost, Node, Prev}```\n to ```\nResult```\n, and for every edge ```\n{EdgeCost, NextNode}```\n of ```\nNode```\n add ```\n{Cost + EdgeCost, NextNode, Node}```\n to ```\nOpen1```\n, but only if ```\nNextNode```\n isn't already in ```\nResult```\n. Continue with ```\nOpen1```\n until the set is empty.\n\n\nDijkstra's algorithm asks for a ```\ndecrease_key()```\n operation on the ```\nOpen```\n set. Since this isn't readily supported by ```\ngb_sets```\n we have used the workaround of inserting a tuple for ```\nNextNode```\n even if ```\nNextNode```\n might be present in ```\nOpen```\n already. That's why we check if the node extracted from ```\nOpen```\n is already in ```\nResult```\n.\n\n\n\nExtended discussion of the use of the priority queue\n\nThere are several ways of using a priority queue with Dijkstra's algorithm.\n\nIn the standard version of Wikipedia a node ```\nv```\n is inserted only once but the position of ```\nv```\n is updated when the cost and predecessor of ```\nv```\n is changed.\n\n```\nalt := dist[u] + dist_between(u, v)\nif alt < dist[v]:\n    dist[v] := alt\n    previous[v] := u\n    decrease-key v in Q\n```\n\n\nImplementations often simplify by replacing ```\ndecrease-key v in Q```\n with ```\nadd v to Q```\n. This means that ```\nv```\n can be added more than once, and the algorithm must therefore check that an ```\nu```\n extracted from the queue hasn't already been added to the result.\n\nIn my version I am replacing the entire block above with ```\nadd v to Q```\n. The queue will therefore contain even more entries, but since they are always extracted in order it doesn't affect the correctness of the algorithm. If you don't want these extra entries, you can use a dictionary to keep track of the minimum cost for each node.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Faster alternatives to Dijkstra's algorithm for GPS system\r\n                \r\nI'm a real speed freak if it gets to algorithms, and in the plugins I made for a game.\n\nThe speed is.. a bit.. not satisfying. Especially while driving around with a car and you do not follow your path, the path has to be recalculated.. and it takes some time, So the in-game GPS is stacking up many \"wrong way\" signals (and stacking up the signals means more calculations afterward, for each wrong way move) because I want a fast, live-gps system which updates constantly.\n\nI changed the old algorithm (some simple dijkstra implementation) to boost::dijkstra's to calculate a path from node A to node B \n\n(total node list is around ~15k nodes with ~40k connections, for curious people here is the map: http://gz.pxf24.pl/downloads/prv2.jpg (12 MB), edges in the red lines are the nodes),\n\nbut it didn't really increase in speed. (At least not noticeably, maybe 50 ms).\n\nThe information that is stored in the Node array is:\n\n```\nThe ID of the Node,\nThe position of the node,\nAll the connections to the node (and which way it is connected to the other nodes, TO, FROM, or BOTH)\nDistance to the connected nodes.\n```\n\n\nI'm curious if anybody knows some faster alternatives in C/C++?\nAny suggestions (+ code examples?) are appreciated!\n\n\n\nIf anyone is interested in the project, here it is (source+binaries):\n\nhttps://gpb.googlecode.com/files/RouteConnector_177.zip\n\nIn this video you can see what the gps-system is like:\n\nhttp://www.youtu.be/xsIhArstyU8\n\nas you can see the red route is updating slowly (well, for us - gamers - it is slow).\n\n( ByTheWay: the gaps between the red lines have been fixed a long time ago :p )\n    ", "Answer": "\r\nSince this is a GPS, it must have a fixed destination. Instead of computing the path from your current node to the destination each time you change the current node, you can instead find the shortest paths from your destination to all the nodes: just run Dijkstra once starting from the destination. This will take about as long as an update takes right now.\n\nThen, in each node, keep ```\nprev = the node previous to this on the shortest path to this node```\n (from your destination). You update this as you compute the shortest paths. Or you can use a ```\nprev[]```\n array outside of the nodes - basically whatever method you are using to reconstruct the path now should still work.\n\nWhen moving your car, your path is given by ```\ncurrentNode.prev -> currentNode.prev.prev -> ...```\n.\n\nThis will solve the update lag and keep your path optimal, but you'll still have a slight lag when entering your destination. \n\nYou should consider this approach even if you plan on using A* or other heuristics that do not always give the optimal answer, at least if you still get lag with those approaches.\n\nFor example, if you have this graph:\n\n```\n1 - 2 cost 3\n1 - 3 cost 4\n2 - 4 cost 1\n3 - 4 cost 2\n3 - 5 cost 5\n```\n\n\nThe ```\nprev```\n array would look like this (computed when you compute the distances ```\nd[]```\n):\n\n```\n       1 2 3 4 5\nprev = 1 1 1 2 3\n```\n\n\nMeaning:\n\n```\nshortest path FROM TO \n                 1  2 = prev[2], 2 = 1, 3\n                 1  3 = prev[3], 3 = 1, 3\n                 1  4 = prev[ prev[4] ], prev[4], 4 = 1, 2, 4 (fill in right to left)\n                 1  5 = prev[ prev[5] ], prev[5], 5 = 1, 3, 5 \n                 etc.\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Spring MVC: Dijkstra's algorithm how to create a bean for graph on startup\r\n                \r\nAt the moment whenever I am solving Dijkstra's algorithm between two points, I have to create the graph object again when I run it. I want to create a spring MVC application where that graph is loaded just once on startup as a bean.\n\nAt the moment these are what my classes look like:\n\n```\npublic class Graph {\nprivate final List<Vertex> vertexes;\n\npublic Graph(List<Vertex> vertexes) {\n                this.vertexes = vertexes;\n\n\npublic List<Vertex> getVertexes() {\n                return vertexes;\n}    \n}\n```\n\n\nVertex Class:\n\n```\npublic class Vertex implements Comparable<Vertex> {\n\nfinal private Integer id;\nfinal private String name;\npublic List<Edge> adjacencies;\npublic double minDistance = Double.POSITIVE_INFINITY;\npublic Vertex previous;\n\npublic Vertex(Integer id, String name) {\n           this.id = id;\n           this.name = name;\n           adjacencies = new LinkedList<Edge>();\n         }\n\npublic Integer getId() {\n       return id;\n}\n\npublic String getName() {\n       return name;\n}\n\n@Override\npublic String toString() {\n   return id+name;\n}\n\npublic int compareTo(Vertex other) {\n    return Double.compare(minDistance, other.minDistance);\n}\n```\n\n\n}\n\nEdge Class:\n\n```\npublic class Edge {\nprivate final String id;\nprivate final Vertex destination;\nprivate final double weight;\n\npublic Edge(String id, Vertex destination, double weight) {\n       this.id = id;\n       this.destination = destination;\n       this.weight = weight;\n}\n\npublic String getId() {\n       return id;\n}\n\n\npublic Vertex getDestination() {\n       return destination;\n}\n\npublic double getWeight() {\n       return weight;\n}\n\n}\n```\n\n\nIn my main method, I populate the Vertexes list with 274 Vertex elements. The Graph class then takes this list in its constructor. How can I create this single graph object as a bean? This is a far as I got.\n\n```\n<bean id=\"graph\" class=\"com.fdm.model.Graph\" >\n<constructor-arg ref=\"list\"/>\n</bean>\n\n<util:list id=\"list\" list-class=\"java.util.ArrayList\" />\n```\n\n\nBut I am unsure how to proceed further. The list above is not of type vertex?\n    ", "Answer": "\r\nHere you have created a bean with singleton scope in application context.\nAnd also you have wired as a constructor argument refering the list of Vertexes bean.\n\n```\n<bean id=\"graph\" class=\"com.fdm.model.Graph\" > \n <constructor-arg ref=\"list\"/> \n</bean>\n```\n\n\nbeans in spring by default are singletons.\n\nHere you have created a list bean with id list and here u can define the value-type of vertex. Also in this case the scope of this list is singleton\nIf you want to define the type\n\n```\n<util:list id=\"list\" value-type=\"com.springapp.mvc.Vertex\" list-class=\"java.util.ArrayList\" />\n```\n\n\nYou can also see the following examples\nHow to define a List bean in Spring?\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Finding Shortest Path in Java - Dijkstra Algorithm\r\n                \r\nIm working on a Dijkstra algorithm. I wrote this code but the ```\ncomputePath()```\n method has a error in\n\n```\nfor(Edge e:u.adjacencies){ \n```\n\n\nI don't know what should I do.\n\n```\n        import java.util.PriorityQueue;\n        import java.util.List;\n        import java.util.ArrayList;\n        import java.util.Collections;\n\n\n\npublic class DijkstraAlgo{\n\n    public static void computePaths(Node source){\n        source.shortestDistance=0;\n\n        //implement a priority queue\n        PriorityQueue<Node> queue = new PriorityQueue<Node>();\n        queue.add(source);\n\n        while(!queue.isEmpty()){\n            Node u = queue.poll();\n\n            /*visit the adjacencies, starting from \n            the nearest node(smallest shortestDistance)*/\n\n        //First Error\nfor(Edge e:u.adjacencies){\n\n\n\n                Node v = e.target;\n                double weight = e.weight;\n\n                //relax(u,v,weight)\n                double distanceFromU = u.shortestDistance+weight;\n                if(distanceFromU<v.shortestDistance){\n\n                    /*remove v from queue for updating \n                    the shortestDistance value*/\n                    queue.remove(v);\n                    v.shortestDistance = distanceFromU;\n                    v.parent = u;\n                    queue.add(v);\n\n                }\n            }\n        }\n    }\n\n    public static List<Node> getShortestPathTo(Node target){\n\n        //trace path from target to source\n        List<Node> path = new ArrayList<Node>();\n        for(Node node = target; node!=null; node = node.parent){\n            path.add(node);\n        }\n\n\n        //reverse the order such that it will be from source to target\n        Collections.reverse(path);\n\n        return path;\n    }\n\n\n\n    public static void main(String[] args){\n\n        //initialize the graph base on the Romania map\n        Node n1 = new Node(\"VertexA\");\n        Node n2 = new Node(\"VertexB\");\n        Node n3 = new Node(\"VertexC\");\n        Node n4 = new Node(\"VertexD\");\n        Node n5 = new Node(\"VertexE\");\n\n\n        //initialize the edges\n        n1.adjacencies = new Edge[]{\n                new Edge(n2,8),\n                new Edge(n3,2),\n\n        };\n\n        n2.adjacencies = new Edge[]{\n                new Edge(n4,3),\n                new Edge(n5,5)\n        };\n\n        n3.adjacencies = new Edge[]{\n                new Edge(n4,4),\n\n        };\n\n        n4.adjacencies = new Edge[]{\n                new Edge(n5,1),\n\n        };\n\n\n\n        Node[] nodes = {n1,n2,n3,n4,n5};\n\n        //compute paths SECOND ERROR PART\n        computePaths(n1);\n        computePaths(n2);\n        computePaths(n3);\n        computePaths(n4);\n        computePaths(n5);\n\n\n        for(Node n: nodes){\n            System.out.println(\"Distance to \" + \n                n + \": \" + n.shortestDistance);\n            List<Node> path = getShortestPathTo(n);\n            System.out.println(\"Path: \" + path);\n        }\n\n        List<Node> path = getShortestPathTo(n3);\n        System.out.println(\"Path: \" + path);\n\n    }\n\n\n}\n\n\n//define Node\nclass Node implements Comparable<Node>{\n\n    public final String value;\n    public Edge[] adjacencies;\n    public double shortestDistance = Double.POSITIVE_INFINITY;\n    public Node parent;\n\n    public Node(String val){\n        value = val;\n    }\n\n    public String toString(){\n        return value;\n    }\n\n    public int compareTo(Node other){\n        return Double.compare(shortestDistance, other.shortestDistance);\n    }\n\n}\n\n//define Edge\nclass Edge{\n    public final Node target;\n    public final double weight;\n    public Edge(Node targetNode, double weightVal){\n        target = targetNode;\n        weight = weightVal;\n    }\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Boost graph library causing errors when applying dijkstra's algorithm\r\n                \r\nI have been loosely following this example, this one, and this stack overflow post to try to apply Dijkstra's algorithm to find the cost of the shortest path between two nodes.\n\nIf I try to follow the first example, I get an error with the typedef statement for NameMap. This error is cryptic, verbose, and I don't quite know what to do with it.\n\nIf I try to follow the second example (copy-pasted from the Boost documentation!!) it does not compile. The error is even more cryptic and verbose.\n\nThe third one (the stack overflow post) relies on the same typedef as the first one.\n\nIs this user error? It probably is, but how should I interpret an error message that spawns from the library code?\n\nUpdate 1\n\nI am using g++ (Debian 4.8.2-21) 4.8.2  from debian testing.\n\nUpdate 2\n\nHere is a condensed version of the source code that doesn't work. There are two lines prefaced by \"// The following line causes an error\" are the ones in question.\n\nUpdate 3\nI have changed\n\n```\ntypedef adjacency_list<listS, vecS, directedS, allow_parallel_edge_tag, EdgeWeightProperty> Graph;\n\ntypedef adjacency_list<listS, vecS, directedS, no_property            , EdgeWeightProperty> Graph;\n```\n\n    ", "Answer": "\r\nYour first attempt didn't define a property with the ```\nvertex_name_t```\n tag (or pass it as a ```\nadjacency_list```\n template parameter), so when you try to create a ```\nproperty_map```\n with that tag the compiler emits an error.\n\nYour code:\n\n```\ntypedef property<edge_weight_t, Weight> EdgeWeightProperty;\ntypedef boost::adjacency_list<listS, vecS, directedS, allow_parallel_edge_tag, EdgeWeightProperty> Graph;\n                                                  //  ^ What's this?\n```\n\n\nThe example code you cited:\n\n```\ntypedef boost::property<boost::edge_weight_t, Weight> WeightProperty;\ntypedef boost::property<boost::vertex_name_t, std::string> NameProperty;  // <-- not in your code\ntypedef boost::adjacency_list < boost::listS, boost::vecS, boost::directedS, NameProperty, WeightProperty > Graph;\n                                                                         //  ^ Used here\n```\n\n\nI have no idea why you are passing ```\nallow_parallel_edge_tag```\n as a template parameter. If I'm reading the documentation correctly, that struct is designed for ```\nparallel_edge_traits```\n specializations when you are using custom container types.\n\nEdit: The second case is actually easy to diagnose once you have the code. Going through the error messages emitted by the compiler, we look for reasons why the compiler didn't select the 3-parameter overload for ```\ndijkstra_shortest_paths```\n. A lot of the messages merely tells you that it rejected overloads with about a dozen parameters - as it should!\n\nNow, this error message (emitted by g++ using Coliru) is pertinent, because it tells you why compiler rejected the three-parameter version:\n\n```\nIn file included from main.cpp:5:0:\n/usr/local/include/boost/graph/dijkstra_shortest_paths.hpp:602:3: note: void boost::\ndijkstra_shortest_paths(const VertexListGraph&, typename boost::graph_traits<Graph>::\nvertex_descriptor, const boost::bgl_named_params<T, Tag, Base>&) [ /* irrelevant stuff\ntelling you how it deduced the template parameters here */ ] <near match>\n   dijkstra_shortest_paths\n   ^\n/usr/local/include/boost/graph/dijkstra_shortest_paths.hpp:602:3: note:   no known conversion for\n argument 2 from 'long int [6]' to 'boost::graph_traits<boost::adjacency_list<boost::listS, \nboost::vecS, boost::directedS, boost::no_property, boost::property<boost::edge_weight_t, long int> > \n>::vertex_descriptor {aka long unsigned int}'\n```\n\n\nYou passed ```\ns```\n, the array containing source vertices, as the second parameter designating the starting vertex, when you should have passed ```\nv0```\n, and the compiler is rightfully complaining that it cannot convert an array of longs to a single vertex.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Infinite loop in Dijkstra algorithm?\r\n                \r\nI'm trying to implement the Dijkstra algorithm to find the shortest path between two intersections (vertices) in a graph. Unfortunately, I am getting an infinite loop in the while loop and I can't really figure out why. \n\nNodeDist is a hashmap between intersections and doubles, and finds the distance between nodes in the graph. Distance is determined by the length of the 'street' (edges) in the graph. Previous is a hashmap that keeps track of intersections to intersections, namely, the intersection that was looked at before the intersection we are looking at now. \n\n```\npublic List<IntersectionI> dijkstraPath(IntersectionI start, IntersectionI end){\n    ArrayList<IntersectionI> path = new ArrayList<IntersectionI>();\n    Iterator<IntersectionI> it = graph.myGraph.keySet().iterator();\n    //Initializing all unvisited node distances as infinity.\n    while (it.hasNext()){\n        IntersectionI next = it.next();\n        nodeDist.put(next, INFINITY);\n    }\n    //Remove the start node, put in 0 distance. \n    nodeDist.remove(start);\n    nodeDist.put(start, (double) 0);\n    queue.add(start);\n    //computes paths\n    while (!queue.isEmpty()){\n        IntersectionI head = queue.poll();\n        if (nodeDist.get(head) == INFINITY)\n            break;\n        visited.put(head, true);\n        List<StreetI> str = head.getStreetList();\n        for (StreetI e : str){\n            Point pt1 = e.getFirstPoint();\n            Point pt2 = e.getSecondPoint();\n            IntersectionI p1 = graph.pointGraph.get(pt1);\n            IntersectionI p2 = graph.pointGraph.get(pt2);\n            if (head.getLocation().equals(p1)){\n                double dist = e.getDistance();\n                double addedDist = nodeDist.get(start)+dist;\n                double p2Dist = nodeDist.get(p2);\n                if (addedDist < p2Dist){\n                    previous.put(p2, head);\n                    Point p22 = p2.getLocation();\n                    p22.setCost(addedDist);\n                    nodeDist.put(p2, addedDist);\n                    queue.add(p2);\n                }\n\n            }\n            else {\n                double dist = e.getDistance();\n                double addedDist = nodeDist.get(start)+dist;\n                if (addedDist < nodeDist.get(p1)){\n                    previous.put(p1, head);\n                    Point p11 = p1.getLocation();\n                    p11.setCost(addedDist);\n                    nodeDist.put(p1, addedDist);\n                    queue.add(p1);\n                }\n            }\n        }\n    }\n    //gets shortest path\n    for (IntersectionI vertex = end; vertex != null; vertex = previous.get(vertex))\n        path.add(vertex);\n    System.out.println(\"ya\");\n    Collections.reverse(path);\n    return path;\n}\n\n//The comparator that sorts by intersection distance.\npublic class distCompare implements Comparator<IntersectionI> {\n    @Override\n    public int compare(IntersectionI x, IntersectionI y) {\n        Point xPo = x.getLocation();\n        Point yPo = y.getLocation();\n        if (xPo.getCost() < yPo.getCost())\n            return 1;\n        else if (yPo.getCost() < xPo.getCost())\n            return -1;\n        else return 0;\n\n    }\n}\n```\n\n    ", "Answer": "\r\nSo, this ended up solving the problem in the comments:\n\n```\ndouble addedDist = nodeDist.get(start)+dist;\n```\n\n\nshould be\n\n```\ndouble addedDist = nodeDist.get(head)+dist;\n```\n\n\nboth times.\n\nThe added distance should come from the current vertex, not the start vertex (the distance to which is 0).\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra algorithm for 2D array in Java\r\n                \r\nThis is for a school project; I'm running into a huge amount of trouble, and I can't seem to find a understandable solution.\n\n```\n   a b c d e z\n a - 2 3 - - -\n b 2 - - 5 2 -\n c 3 - - - 5 -\n d - 5 - - 1 2\n e - 2 5 1 - 4\n z - - - 2 4 -\n```\n\n\nThat's the two dimensional array. So if you want to find the shortest path, its from a,b,e,d,z = 7, and (a,b) = (b,a) -- it takes you to the new row to for the row's adjacent paths\n\nIs there anyone that can help me implement Dijkstra's algorithm for this example? I'd really appreciate it. (I seem to like arrays best, maps and sets confuse me a bit, lists are manageable -though I'm willing to look into any sort of solution at this point)\n\n[At least I'm not just ripping off a source from the net. I actually wanna learn these things... It's just really hard (>.<)]\n\nOh, start point is A and end point is Z\n\n\n\nAs most people, I don't find the concept of the algorithm difficult -- I just can see to get the coding right... Help please?\n\nSample code-- a friend helped me with this a lot (though its filled with data structures that I find difficult to follow) I\"ve also tried adapting the C++ code from dreamincode.net/forums/blog/martyr2/index.php?showentry=578 into java, but that didn't go so well ...\n\n```\nimport java.util.*;\n\npublic class Pathy{\n\n    private static class pathyNode{\n        public final String name;\n        public Map<pathyNode, Integer> adjacentNodes;\n\n        public pathyNode(String n){\n            name = n;\n            adjacentNodes = new HashMap<pathyNode, Integer>();\n        }\n\n    }\n\n    //instance variables\n\n    //constructors\n\n    //accessors\n\n    //methods\n    public static ArrayList<pathyNode> convert(int[][] inMatrix){\n        ArrayList<pathyNode> nodeList = new ArrayList<pathyNode>();\n        for(int i = 0; i < inMatrix.length; i++){\n            nodeList.add(new pathyNode(\"\" + i));\n        }\n        for(int i = 0; i < inMatrix.length; i++){\n            for(int j = 0; j < inMatrix[i].length; j++){\n                if(inMatrix[i][j] != -1){\n                    nodeList.get(i).adjacentNodes.put(nodeList.get(j),\n                            new Integer(inMatrix[i][j]));\n                }\n            }\n        }\n        return nodeList;\n    }\n\n    public static Map<pathyNode, Integer> Dijkstra(ArrayList<pathyNode> inGraph){\n        Set<pathyNode> visited = new HashSet<pathyNode>();\n        visited.add(inGraph.get(0));\n        pathyNode source = inGraph.get(0);\n        Map answer = new TreeMap<pathyNode, Integer>();\n        for(pathyNode node : inGraph){\n            dijkstraHelper(visited, 0, source, node);\n            answer.put(node, dijkstraHelper(visited, 0, source, node));\n        }\n        return answer;\n    }\n\n    private static int dijkstraHelper(Set<pathyNode> visited, int sum, pathyNode start, pathyNode destination){\n        Map<pathyNode, Integer> adjacent = new HashMap<pathyNode, Integer>();\n\n        for(pathyNode n : visited){\n            for(pathyNode m: n.adjacentNodes.keySet()){\n                if(adjacent.containsKey(m)){\n                    Integer temp = n.adjacentNodes.get(m);\n                    if(temp < adjacent.get(m)){\n                        adjacent.put(m, temp);\n                    }\n                }\n                else{\n                    adjacent.put(m, n.adjacentNodes.get(m));\n                }\n            }\n        }\n\n        Map<pathyNode, Integer> adjacent2 = new HashMap<pathyNode, Integer>();\n        Set<pathyNode> tempSet = adjacent.keySet();\n        tempSet.removeAll(visited);\n        for(pathyNode n: tempSet){\n            adjacent2.put(n, adjacent.get(n));\n        }\n        adjacent = adjacent2;\n        Integer min = new Integer(java.lang.Integer.MAX_VALUE);\n        pathyNode minNode = null;\n\n        for(pathyNode n: adjacent.keySet()){\n            Integer temp = adjacent.get(n);\n            if(temp < min){\n                min = temp;\n                minNode = n;\n            }\n        }\n        visited.add(minNode);\n        sum += min.intValue();\n        sum = dijkstraHelper(visited, sum, start, destination);\n        return sum;\n    }\n\n    //main\n    public static void main(String[] args){\n\n        int[][] input = new int[][] { {-1, 2, 3, -1, -1, -1},\n                          {2, -1, -1, 5, 2, -1},\n                          {3, -1, -1, -1, 5, -1},\n                          {-1, 5, -1, -1, 1, 2},\n                          {-1, 2, 5, 1, -1, 4},\n                          {-1, -1, -1, 2, 4, -1},\n                        };\n                        //-1 represents an non-existant path\n\n        System.out.println(Dijkstra(convert(input)));\n    }\n}\n```\n\n    ", "Answer": "\r\nThe representation that you are calling 2D array, is the Adjacency matrix representation of a graph and the problem you are trying to solve is an instance of 'Single-Source Shortest Paths' problem. Dijkstra's algorithm is designed to solve this type of problem. This might be helpful http://renaud.waldura.com/doc/java/dijkstra/. Download the code from the site and read the documentation. Basically you will need to write code similar to following\n\n```\n    RoutesMap map = map =  new DenseRoutesMap(5);\n    map.addDirectRoute(City.A, City.B, 2);\n    map.addDirectRoute(City.A, City.C, 3);\n    map.addDirectRoute(City.B, City.A, 2);\n    map.addDirectRoute(City.B, City.D, 5);\n    map.addDirectRoute(City.B, City.D, 2);\n    ...\n    DijkstraEngine engine = new DijkstraEngine(map);\n    int distance = engine.getShortestDistance(City.F);\n```\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "using Dijkstra algorithm to find shortest path in an adjacency matrix\r\n                \r\nI have a homework assignment where I'm supposed to find the cheapest airfares between two cities, taking into account layovers. \n\nWe are required to use an adjacency matrix along with Dijkstra's algorithm. I'm looking at the algorithm in my book, as well as wikipedia (among other sites). I'm confused because in the parameter for the algorithm it has:\n\n```\nDijkstraAlgorithm(weighted simple digraph, vertex first)\n```\n\n\nWhat I'm having a hard time understanding- especially when looking at the entire pseudocode- is why it only takes one vertex as an argument? I need to find the cheapest airfare(shortest path) between two vertices. Why does the algorithm only require one?\n    ", "Answer": "\r\nDijkstra's will find the shortest path from the provided vertex (```\nfirst```\n in your example) to every vertex in your graph. That's why it only takes one vertex as input.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Is Dijkstra algorithm informed or uninformed search strategies?\r\n                \r\ni need an explanation about Dijkstra algorithm since it is used for find shortest path by using value so it is informed search but in some references is uninformed search algorithm, so please clarify why it is uninformed search?\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "My Dijkstra's algorithm implementation does not return shortest path\r\n                \r\nI tried to implement the Dijkstra's shortest path algorithm in JavaScript, and tested it with multiple examples.\nI am using this graph to see how it would behave:\n\nIf I want to find the shortest path from A to I, the result should be [A, D, C, F, G, H, I] with distance equal to 10.\nBut my implementation returns the path as [A, B, E, J, F, G, H, I] with distance of 14.\nHere is my JavaScript code:\n\r\n\r\n```\nconst graph = {\n    A: {B: 3, C: 4, D: 2},\n    B: {A: 3, D: 6, E: 1},\n    C: {A: 4, D: 1, F: 3},\n    D: {A: 2, B: 6, C: 1, E: 5},\n    E: {B: 1, D: 5, J: 1},\n    F: {C: 3, G: 2, J: 5},\n    G: {F: 2, H: 1, I: 3},\n    H: {G: 1, I: 1, X: 2},\n    I: {G: 3, H: 1, X: 8},\n    J: {E: 1, F: 5, X: 6},\n    X: {H: 2, I: 8, J: 6},\n};\n\n// The class Dsp:\n\nclass Dsp {\n  constructor() {\n    //Previous node after update of distance\n    this.prev = {};\n    //Distances of each node\n    this.distances = {};\n    //Array of unvisited neighbors\n    this.unvisitedn = [];\n    //Path of visited nodes from first to final node\n    this.path = [];\n  }\n\n  findsp(graph, start, end) {\n\n    //Register graph data \n    this.registerGraphData(graph, start);\n\n    //Set the starting node as the current node\n    let cn = start;\n\n    //While there are unvisited nodes\n    while (this.unvisitedn.length > 0) {\n      //Mark the currentNode as visited\n      this.markAsVisited(cn);\n\n      //Compare distance from current node to unvisited neighbors\n      let nodes = this.compareNodeDistances(graph, cn);\n\n      //Update neighbor distance\n      this.updateNodeDistances(nodes, cn);\n\n      //Compare each unvisited neighbor and choose the one with the lowest distances\n      //Set the choosed node as the new current node\n      cn = this.selectNextNode(graph, cn);\n    }\n\n    return this.generatePath(start, end);\n  }\n\n  registerGraphData(graph, start) {\n\n    //Set starting weight for all nodes\n    const higherWeight = 10000;\n\n    //For each node in the graph\n    for (let node in graph) {\n      //If the node is the starting node \n      if (node == start)\n        //Set starting weight as 0\n        this.distances[node] = 0;\n      //else set the higherWeight\n      else\n        this.distances[node] = higherWeight;\n\n      //Add to the unvisited nodes\n      this.unvisitedn.push(node);\n    }\n\n    console.log(this.distances);\n    console.log(this.unvisitedn);\n  }\n\n  markAsVisited(cn) {\n\n    console.log('Visiting', cn);\n\n    let index = this.unvisitedn.indexOf(cn);\n    this.unvisitedn.splice(index, 1);\n  }\n\n  getUnvisitedNeighbors(graph, cn) {\n\n    //All current node neighbors\n    let nbs = graph[cn];\n    let unbs = [];\n\n    for (let nb in nbs) {\n      if (this.unvisitedn.includes(nb))\n        unbs.push(nb);\n    }\n\n    console.log(cn, 'Unvisited neighbors:', unbs);\n\n    return unbs;\n  }\n\n  compareNodeDistances(graph, cn) {\n\n    let unbs = this.getUnvisitedNeighbors(graph, cn);\n\n    //new distances\n    let newDistances = {};\n\n    //For all currentNode neighbors\n    for (let nb of unbs) { //Substituted unbs\n\n      //Neighbor Weight\n      let nbw = graph[cn][nb];\n      //console.log('Neighbor weight', nbw);\n\n      //neighbor distance\n      let nbd = this.distances[nb];\n      //console.log('Neighbor distance', nbd);\n\n      //current node distance\n      let cnd = this.distances[cn];\n      //console.log('Current node distance', cnd);\n\n      //If the neighbor distance > current node distance + neighbor weight\n      if (nbd > cnd + nbw)\n        newDistances[nb] = cnd + nbw;\n    }\n\n    console.log('new distances:', newDistances);\n\n    return newDistances;\n  }\n\n  updateNodeDistances(nodes, cn) {\n\n    //Update distances for each neighbor that was compared\n    for (let node in nodes) {\n      console.log(nodes);\n\n\n      this.distances[node] = nodes[node];\n      this.prev[node] = cn;\n    }\n\n    console.log(\"Node distances after update\", this.distances);\n    console.log(\"Node previous nodes after update\", this.prev);\n  }\n\n  selectNextNode(graph, cn) {\n    let unbs = this.getUnvisitedNeighbors(graph, cn);\n    let mind = 100000;\n    let nextn = null;\n\n    //If there are unvisited neighbors\n    if (unbs.length > 0) {\n      for (let nb of unbs) {\n        if (this.distances[nb] < mind) {\n          mind = this.distances[nb];\n          nextn = nb;\n        }\n      }\n    } else {\n      nextn = this.unvisitedn[0];\n    }\n\n    return nextn;\n  }\n\n  generatePath(start, end) {\n\n    let cn = end;\n    let path = {};\n    let nodes = [];\n\n    while (cn !== start) {\n      nodes.push(cn);\n      cn = this.prev[cn];\n    }\n\n    nodes.push(start);\n    nodes.reverse();\n\n    path['nodes'] = nodes;\n    path['distance'] = this.distances[end];\n\n    return path;\n  }\n}\n\nlet shp = new Dsp();\n\nconsole.log(shp.findsp(graph, 'A', 'I'));```\n\r\n\r\n\r\n\nI would like to understand what´s wrong with the steps I programmed.\nWhat am I doing wrong? Is there some additional step, or consideration?\n    ", "Answer": "\r\nThe problem is that you are not performing a best-first search. Your code really performs a depth-first search, where you just optimise which unvisited neighbor you will choose from the current node. But you should take the node with the minimum distance from among all unvisited nodes, not just among the neighbors of the current node.\nSee also step 6 of the algorithm description on Wikipedia:\n\n\nOtherwise, select the unvisited node that is marked with the smallest tentative distance, set it as the new \"current node\"\n\n\nSo the problem is in ```\nselectNextNode```\n. It could be corrected to this:\n```\nselectNextNode(graph, cn) {\n    let mindist = Infinity;\n    let best;\n    for (let node of this.unvisitedn) {\n        if (this.distances[node] < mindist) {\n            mindist = this.distances[node];\n            best = node;\n        }\n    }\n    return best;\n}\n```\n\nHowever, this is a naive implementation, as in each round you have to find the minimum again: this makes the algorithm non-optimal. A true Dijkstra algorithm will use a priority queue, such as a heap, which makes this lookup more efficient.\nImplementation with Heap\nUnfortunately JavaScript does not (yet) provide a native heap implementation, so we have to throw our own or reference a library. I took the implementation from my answer to Efficient way to implement Priority Queue in Javascript?. See there for more details on that implementation.\nI think the implementation of the shortest path algorithm does not warrant the use of a class. A function like your ```\nfindsp```\n should be enough.\nSo here it is:\n\r\n\r\n```\n/* MinHeap minimised - taken from https://stackoverflow.com/a/66511107/5459839 */\nconst MinHeap={siftDown(h,i=0,v=h[i]){if(i<h.length){let k=v[0];while(1){let j=i*2+1;if(j+1<h.length&&h[j][0]>h[j+1][0])j++;if(j>=h.length||k<=h[j][0])break;h[i]=h[j];i=j;}h[i]=v}},heapify(h){for(let i=h.length>>1;i--;)this.siftDown(h,i);return h},pop(h){return this.exchange(h,h.pop())},exchange(h,v){if(!h.length)return v;let w=h[0];this.siftDown(h,0,v);return w},push(h,v){let k=v[0],i=h.length,j;while((j=(i-1)>>1)>=0&&k<h[j][0]){h[i]=h[j];i=j}h[i]=v;return h}};\n\nfunction DijkstraShortestPath(graph, start, end) {\n    // Heap with one entry: distance is 0 at start, and there is no previous.\n    let heap = [[0, start, null]]; \n    let prev = {};\n    \n    while (heap.length) {\n        let [distance, current, cameFrom] = MinHeap.pop(heap);\n        if (current in prev) continue; // Already visited\n        prev[current] = cameFrom; // Mark as visited\n        if (current == end) { // Found!\n            // Reconstruct path\n            let path = [];\n            while (current) {\n                path.push(current);\n                current = prev[current];\n            }\n            path.reverse();\n            return { path, distance };\n        }\n        // Push unvisited neighbors on the heap\n        for (let [neighbor, edge] of Object.entries(graph[current])) {\n            if (!(neighbor in prev)) MinHeap.push(heap, [distance + edge, neighbor, current]);\n        }\n    }\n}\n\n// Demo:\nconst graph = {\n    A: {B: 3, C: 4, D: 2},\n    B: {A: 3, D: 6, E: 1},\n    C: {A: 4, D: 1, F: 3},\n    D: {A: 2, B: 6, C: 1, E: 5},\n    E: {B: 1, D: 5, J: 1},\n    F: {C: 3, G: 2, J: 5},\n    G: {F: 2, H: 1, I: 3},\n    H: {G: 1, I: 1, X: 2},\n    I: {G: 3, H: 1, X: 8},\n    J: {E: 1, F: 5, X: 6},\n    X: {H: 2, I: 8, J: 6},\n}\n\nconsole.log(DijkstraShortestPath(graph, 'A', 'I'));```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm in C\r\n                \r\nI am able to compile the code in g++ but for some reason when I run the program, it crashes after a few seconds.\n\nI also realized the assignment was suppose to b in C but I don't know much about that language and I don't know where the issues are. If anyone can give me tips on that it would be great but it isn't a big deal.\n\nI just want to know where the error is since the program compiles without any issues\n\nHere is the code and the main function is the professor's test code.\n\n```\n#include <cstdlib>\n#include <iostream>\n#include <stdio.h>\nusing namespace std;\n\nstruct listnode {\nstruct listnode * next;\nint vertexnumber;\n};\n\nstruct listnode * shortest_path(int n, int s, int t, int * dist) {\n\nstruct listnode * pathlist = NULL;\n    struct listnode * temp = NULL;\n    struct listnode * pathlisthead = NULL;\n\n    int i, j, k, S[9999], cost[9999], path[9999], p, min;\n\n    for (i = 0; i < n; i++) {\n        S[i] = 0;\n        cost[i] = 9999;\n    }\n\n    p = 0;\n    path[++p] = s;\n    pathlist = new struct listnode;\n    pathlisthead = pathlist;\n    pathlist->vertexnumber = s;\n    S[s] = 1;\n    cost[s] = 0;\n    for (i = 1; i < n - 1; i++) {\n        k = -1;\n        min = 9999;\n        for (j = 0; j < n; j++) {\n            if (cost[j] < min && S[j] != 1) {\n                min = cost[j];\n                k = j;\n            }\n        }\n        if (*(dist + i*n + j) <= cost[k]) {\n            p = 1;\n            pathlist = pathlisthead;\n        }\n        path[++p] = k;\n        pathlist->next = new struct listnode;\n        pathlist = pathlist->next;\n        pathlist->vertexnumber = k;\n        struct listnode * tmp = pathlisthead;\n        while (tmp != NULL) {\n            tmp = tmp->next;\n        }\n        S[k] = 1;\n        for (j = 0; j < n; j++)\n            if (*(dist + i*n + j) != 9999 && cost[j] >= cost[k] + *(dist + i*n + j) && S[j] != 1)\n                cost[j] = cost[k] + *(dist + i*n + j);\n        if (k == t)\n            break;\n    }\n    return pathlisthead;\n}\n\nint main(void)\n{  int dist[1000][1000];\n   int i,j;\n   struct listnode *tmp;\n   for(i=0; i< 1000; i++)\n     for( j =0; j< 1000; j++ )\n     {  if( i<500 && j<500 )\n           dist[i][j] = 110 + ((i*i +j*j + 13*(i+j) )%20);\n        else\n           dist[i][j] = 200 + ((i*i +j*j + 13*(i+j) )%20);\n     }\n\n\n   for(i=0; i< 1000; i++)\n     dist[i][i]=0;\n   for(i=0; i< 100; i++)\n   {  dist[i][2*i+1] = 15; dist[2*i+1][i] = 15;\n      dist[i][2*i+2] = 15; dist[2*i+2][i] = 15;\n   }\n   dist[0][128] = 100; dist[128][0]=100;\n   dist[128][500] = 1; dist[500][128]= 1;\n   for( i = 0; i< 100; i++)\n   {  dist[300+ (7*i)%100][300+(7*i+7)%100] = 1; \n      dist[300+ (7*i+7)%100][300+(7*i)%100] = 1; \n      dist[300+i][450] = 2; dist[450][300+1] = 2;\n   }\n   for(i=502; i<900; i++)\n   { dist[450][i] = 3; dist[i][450]=3;\n     dist[500][i] = 2;   dist[i][500]=2;\n     dist[501][i] = 10; dist [i][501] = 10;\n   }\n   dist [500][900] = 50; dist[900][500]=50;\n   dist [899][900] = 49; dist[899][900]=49;\n   dist [900][999] = 1; dist [999][900] = 1;\n   printf(\"constructed distance matrix for graph with 1000 vertices\\n\");\n   tmp =  shortest_path(1000, 0, 999, &(dist[0][0]));\n   printf(\"The shortest path from 0 to 999 uses the vertices\\n\");\n   while( tmp != NULL )\n   {  printf(\"%d, \", tmp->vertexnumber);\n      tmp = tmp->next;\n   }\n   printf(\"End test\\n\");\n   exit(0);\n}\n```\n\n\nThe professor said the result should show:\n\nconstructed distance matrix for graph with 1000 vertices\n\nThe shortest path from 0 to 999 uses the vertices\n\n0, 128, 500, 900, 999, End test\n    ", "Answer": "\r\nI can see at least one place that will cause it to crash. When you create a new ```\nlistnode```\n here:\n\n```\n    pathlist->next = new struct listnode;\n    pathlist = pathlist->next;\n    pathlist->vertexnumber = k;\n```\n\n\nyou don't initialise the ```\nnext```\n pointer to ```\nNULL```\n. So when you start iterating through the list here:\n\n```\n    struct listnode * tmp = pathlisthead;\n    while (tmp != NULL) {\n        tmp = tmp->next;\n    }\n```\n\n\n```\npathlisthead```\n starts off pointing to the initial value of ```\npathlist```\n, which has a ```\nnext```\n pointing to the new ```\nlistnode```\n you've just constructed, which has a ```\nnext```\n pointing to a random location in memory.\n\nThe result is that the while loop eventually explodes.\n\nIt also wouldn't surprise me if that 1000 x 1000 array at the start of ```\nmain```\n causes a stack overflow, but that may depend on your system settings.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "What is the most efficient way to represent edge weights for Dijkstra's algorithm\r\n                \r\nI'm making a little game where I'm going to have a character on a grid that moves around. I was going to use Dijkstra's algorithm for the pathing as they move around. Only problem being is I want to make thin walls(instead of just removing nodes) like so: http://i.gyazo.com/85d110c17cf027d3ad0219fa26938305.png\n\nI was thinking the best way to do it was just edit the edge weights between 2 squares to be so high that it would never be crossed. Anyway, onto the question:\n\nWhat is the most efficient way to assign edge weights to each connection in the grid?\n\nI've thought about using an adjacency matrix, but for a 15x6 grid, that's a 90x90 matrix which seems... excessive. Any help would be nice, thanks (:\n    ", "Answer": "\r\nYou only need to store edges between the rectilinear squares and a square can have at most 4 neighbors, once for each direction. Store the edge accessed by node as up to 4 entries of the enumeration {up, down, left, right}. That's is less than 90 x 4.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Displaying the path for Dijkstra algorithm\r\n                \r\nWhats up guys, I have a question regarding the Dijkstra algorithm. I have made it so that a user enter a graph file, and then the user enters the source node and destination node. And my code so far calculates the shortest distance between them, like it's supposed to. However I do not know to print the path of nodes it goes through in order to get to the destination node. Please help this is a homework assignment due today. Here is my code:\n\n```\npackage minheap;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.Scanner;\n\npublic class MinHeap {\n\n\nprivate int veNum;\nprivate int x;\nprivate int y;\nprivate Vertex[] vertices;\nprivate int size;\n\n\n\npublic static void main(String[] args) throws FileNotFoundException{\n\n\n    Scanner input = new Scanner(System.in);\n    System.out.println(\"%%%%%%Enter the name of the file that contains the graph\");\n    String file = input.nextLine();\n\n    MinHeap minHeap = new MinHeap(file);\n    System.out.println(\"What city would you like to start from?(Please enter a number \"\n            + \"from 0 to 87574)\");\n    int start = Integer.parseInt(input.nextLine());\n    System.out.println(\"What city would you like to get to?(Please enter a number \"\n            + \"from 0 to 87574)\");\n    int end = Integer.parseInt(input.nextLine());\n\n    minHeap.findShortestPaths(start, end);\n\n}\n\n\n\n    public MinHeap(String file) throws FileNotFoundException {\n\n    Scanner input = new Scanner(new File(file));\n    String sizeString = input.next();       //get the size as a string\n    size = Integer.parseInt(sizeString);\n\n    System.out.println(\"======The size is: \" + size);\n    vertices = new Vertex[size];\n   // addNodes();\n\n    input.next();\n\n    /*Now read the vertices*/\n    for(int i = 0; i < vertices.length; i++){\n\n\n        veNum = Integer.parseInt(input.next());\n        x = Integer.parseInt(input.next());\n        y = Integer.parseInt(input.next());\n\n        vertices[i] = new Vertex(veNum, x, y);\n\n    }\n\n\n    /*Now read the edges */\n    while(input.hasNext()){\n\n\n        int vertex1 = indexForName(input.next());\n        int vertex2 = indexForName(input.next());\n\n        //System.out.println(\"====\" + vertex1 + \"====\" + vertex2);\n\n        /*Formula to calculate the distance(weight)*/\n        int distance = (int) Math.sqrt(Math.pow(vertices[vertex1].xCord - vertices[vertex2].xCord, 2) \n                + Math.pow(vertices[vertex1].yCord - vertices[vertex2].yCord, 2));\n\n\n\n        /*Pass the 2 vertexes that make an edge, and their distance to addEdge method*/\n        addEdge(vertex1, vertex2, distance);  \n\n        /*System.out.println(\"X cord: \" + vertices[vertex1].xCord + \"|  Y cord: \" + vertices[vertex1].yCord + \n                \"|  X cord2: \" + vertices[vertex2].xCord + \"|  Y cord2: \" + vertices[vertex2].yCord);\n        */\n\n    }\n    }\n\n\n    //======================================================================================================\n int indexForName(String name){\n\n    for(int i = 0; i < vertices.length; i++){\n    /*Look for the vertex name in the array to see if they match with the one the one from\n    the file */\n        if(vertices[i].name == Integer.parseInt(name)){\n\n            return i;\n        }\n\n    }\n\n    return -1;\n\n\n}\n\n //===============================================================================================================\n\n\n    public void addEdge(int sourceName, int destinationName, int weight) {\n        int srcIndex = sourceName;\n        int destiIndex = destinationName;\n        vertices[srcIndex].adj = new Neighbour(destiIndex, weight, vertices[srcIndex].adj);\n        vertices[destiIndex].indegree++;\n    }\n\n    public void findShortestPaths(int sourceName, int end){\n\n\n        for (int i = 0; i < size; i++) {\n            if (vertices[i].name == sourceName) {\n                applyDikjstraAlgorith(vertices[i], vertices[end]);\n                break;// in this case we need not traverse the nodes which are\n                // not reachable from the source Node\n            }\n        }\n        //applyDikjstraAlgorith(vertices[sourceName], vertices[end]);\n        // for(int i = 0; i < size; i++){\n        //   System.out.println(\"Distance of \"+vertices[i].name+\" from Source: \"+ vertices[i].cost);\n        //}\n    }\n\n    public class Vertex {\n        int cost;\n        int name;\n        Neighbour adj;\n        int indegree;\n        State state;\n        int xCord;\n        int yCord;\n\n        public Vertex(int name, int xCord, int yCord) {\n            this.name = name;\n            cost = Integer.MAX_VALUE;\n            state = State.NEW;\n            this.xCord = xCord;\n            this.yCord = yCord;\n\n\n        }\n\n        public int compareTo(Vertex v) {\n            if (this.cost == v.cost) {\n                return 0;\n            }\n            if (this.cost < v.cost) {\n                return -1;\n            }\n            return 1;\n        }\n    }\n\n    public enum State {\n        NEW, IN_Q, VISITED\n    }\n\n    public class Neighbour {\n        int index;\n        Neighbour next;\n        int weight;\n\n        Neighbour(int index, int weight, Neighbour next) {\n            this.index = index;\n            this.next = next;\n            this.weight = weight;\n        }\n    }\n\n    public void applyDikjstraAlgorith(Vertex src, Vertex end) {\n\n\n        Heap heap = new Heap(size);\n        heap.add(src);\n        src.state = State.IN_Q;\n        src.cost = 0;\n        while (!heap.isEmpty()) {\n            Vertex u = heap.remove();\n            u.state = State.VISITED;\n            Neighbour temp = u.adj;    //the neighbor of the vertex being removed. it accesses it adj neighbor list\n            System.out.println(\"=======Edge weights\");\n            while (temp != null) {    //while it has a neighbor\n                if (vertices[temp.index].state == State.NEW) {  //if that neighbor is unvisited\n                    heap.add(vertices[temp.index]);             //add the unvisited vertices to the heap\n                    vertices[temp.index].state = State.IN_Q;    //make the state indicating its in the heap\n                }\n                System.out.println(\"Weight from \"+ vertices[u.name].name + \" to \" + vertices[temp.index].name +\" is \"+ temp.weight);\n                if (vertices[temp.index].cost > u.cost + temp.weight) {  //if the neighbors weight is less than\n                    vertices[temp.index].cost = u.cost + temp.weight;\n\n\n                    heap.heapifyUP(vertices[temp.index]);\n\n\n\n                }\n                temp = temp.next;\n\n            }\n        }\n\n        System.out.println();\n            System.out.println(\"The shortest distance from \"+src.name +\" to \"+end.name+\" is \" \n                    + end.cost);\n\n    }\n\n    public static class Heap {\n        private Vertex[] heap;\n        private int maxSize;\n        private int size; //starts off as 0\n\n\n        public Heap(int maxSize) {\n            this.maxSize = maxSize;\n            heap = new Vertex[maxSize];  //make the max size for the heap array made of vertices \n\n        }\n\n        public void add(Vertex u) {\n\n            heap[size++] = u;       //fill the heap array with the vertices, starting at position 0\n            //\n            heapifyUP(size - 1);      //pass each vertext ino heapifyUP (vertex type)\n        }\n\n        public void heapifyUP(Vertex u) {\n            for (int i = 0; i < maxSize; i++) {  //look for vertex in the heap array \n                if (u == heap[i]) { \n\n                    heapifyUP(i);  //if its found, go to heapifyUp method (int type) and pass in the vertex num\n                    break;\n                }\n            }\n        }\n\n        public void heapifyUP(int position) {\n\n            int currentIndex = position;\n            Vertex currentItem = heap[currentIndex];\n\n            int parentIndex = (currentIndex - 1) / 2;\n            Vertex parentItem = heap[parentIndex];\n\n\n\n\n\n            while (currentItem.compareTo(parentItem) == -1) {\n                swap(currentIndex, parentIndex);\n                currentIndex = parentIndex;\n\n                if (currentIndex == 0) {\n                    break;\n                }\n                currentItem = heap[currentIndex];\n                parentIndex = (currentIndex - 1) / 2;\n                parentItem = heap[parentIndex];\n\n\n            }\n        }\n\n        public Vertex remove() {\n            Vertex v = heap[0];\n            swap(0, size - 1);\n            heap[size - 1] = null;\n            size--;\n            heapifyDown(0);\n            return v;\n        }\n\n        public void heapifyDown(int postion) {\n            if (size == 1) {\n                return;\n            }\n\n            int currentIndex = postion;\n            Vertex currentItem = heap[currentIndex];\n            int leftChildIndex = 2 * currentIndex + 1;\n            int rightChildIndex = 2 * currentIndex + 2;\n            int childIndex;\n            if (heap[leftChildIndex] == null) {\n                return;\n            }\n            if (heap[rightChildIndex] == null) {\n                childIndex = leftChildIndex;\n            } else if (heap[rightChildIndex].compareTo(heap[leftChildIndex]) == -1) {\n                childIndex = rightChildIndex;\n            } else {\n                childIndex = leftChildIndex;\n            }\n            Vertex childItem = heap[childIndex];\n            while (currentItem.compareTo(childItem) == 1) {\n                swap(currentIndex, childIndex);\n                currentIndex = childIndex;\n                currentItem = heap[currentIndex];\n                leftChildIndex = 2 * currentIndex + 1;\n                rightChildIndex = 2 * currentIndex + 2;\n                if (heap[leftChildIndex] == null) {\n                    return;\n                }\n                if (heap[rightChildIndex] == null) {\n                    childIndex = leftChildIndex;\n                } else if (heap[rightChildIndex].compareTo(heap[leftChildIndex]) == -1) {\n                    childIndex = rightChildIndex;\n\n                } else {\n                    childIndex = leftChildIndex;\n                }\n\n            }\n\n        }\n\n        public void swap(int index1, int index2) {\n            Vertex temp = heap[index1];\n            heap[index1] = heap[index2];\n            heap[index2] = temp;\n\n\n        }\n\n        public boolean isEmpty() {\n\n            return size == 0;\n        }\n    }\n}\n```\n\n\nThe sample.txt file is as follows: \n\n```\n6 9\n\n0 1000 2400\n\n1 2800 3000\n\n2 2400 2500\n\n3 4000 0\n\n4 4500 3800\n\n5 6000 1500\n\n0 1\n\n0 3\n\n1 2\n\n1 4\n\n2 4\n\n2 3\n\n2 5\n\n3 5\n```\n\n\nAgain, the actual algorithm works, I just need help printing the path. Thanks in advance\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "A variant of Dijkstra algorithm\r\n                \r\nI found this algorithm from CP3 book for ICPC, it is a variant of Dijkstra but it gives TLE in some cases (hidden tests). Although it seems that the running time of this algorithm is same as Dijkstra but I think it is different. Can anyone help me with the time complexity of this algorithm.\n```\n vector<int> visited(N,0),dis(N,0);\n vector<pair<int,int> > adj[N];        // value, node\n void dijkstra()                    \n {\n     for(int i=2;i<=N;i++)\n        dis[i]=N;\n     priority_queue<pair<int,int> ,vector<pair<int,int> >,greater<pair<int,int> > > pq;\n     pq.push(make_pair(0,1));\n     while(!pq.empty())\n     {\n         pair<int,int> p=pq.top();\n         ll x=p.second;\n         pq.pop();\n         if(p.first>dis[x])\n             continue;\n         for(int i=0;i<adj[x].size();i++)\n         {\n             if(dis[adj[x][i].ss]>dis[x]+adj[x][i].first)\n             {\n                 dis[adj[x][i].second]=dis[x]+adj[x][i].first;\n                 pq.push(make_pair(dis[adj[x][i].second],adj[x][i].second));\n             }\n         }\n     }\n }\n```\n\n    ", "Answer": "\r\nArrays in C++ are zero based, that is the first index is 0 and the last is size()-1.\n```\n vector<int> visited(N,0),dis(N,0); <--- dis is initialized with N zero's\n vector<pair<int,int> > adj[N];        // value, node\n void dijkstra()                    \n {\n     for(int i=2;i<=N;i++)\n        dis[i]=N; <---- initializing i=N or dis[N] is undefined behaviour\n```\n\nYou write beyond the end of the array with possible disastrous results.\nYour real error might be that that\n```\ndis[1] = 0 \n```\n\nWhere it should have been N or MAX_INT.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Print Dijkstra's Algorithm as a tree\r\n                \r\nI have the algorithm recording the shortest path of each node and need to print it out as a tree structure... for example:\n\nVancouver\n   - Olympia\n       -Lacey\n       -Tacoma\n          -Seattle\n\netc... Here is what my node structure is:\n\n```\nclass DA\n{\n    public Node Name { get; set; }\n    public Node Parent { get; set; }\n    public decimal Cost { get; set; }\n    public bool Complete { get; set; }\n\n    public DA(Node n)\n    {\n        Name = n;\n        Cost = 100000000;\n    }\n\n    public DA() { }\n}\n```\n\n\nHere's what I currently print out on the console (format of Parent --> Child Weight\n\n\nAny advise on printing this out would be much appreciated. \n    ", "Answer": "\r\nPseudocode:\n\n```\nprint start.name;\nvar next = start.next;\n\nwhile (next) {\n  print next.name;\n  next = next.next;\n}\n```\n\n\nBasically the general idea is to print out the starting location, then keep printing out all of the destination locations, up until you hit the finish.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Is my understanding of Dijkstra algorithm correct?\r\n                \r\nConsider the following weighted directed graph:\n\n\n\nLet's consider node 1 as a starting node, according to the Dijkstra algorithm we have the following steps:\n\n\nnode 1 marked visited.\nthe shortest path to node 2 has weight 1. Mark node 2 visited.\nthe shortest path to node 3 has weight 30. Mark node 3 visited.\nAfter that, according to algorithm node 3 has minimal path weight as 30, and cannot be changed.\nBut, evidently, the shortest path to node3 is 4.\n\n\nCan you, please point out any flaw in my interpretation of the algorithm?   \n    ", "Answer": "\r\nThe short answer is no, your understanding is incorrect.\n\nHere is the correct algorithm:\n\n\n  Dijkstra's algorithm picks the unvisited vertex with the lowest distance, calculates the distance through it to each unvisited neighbor, and updates the neighbor's distance if smaller. Mark visited (set to red) when done with neighbors.\n\n\nSource: https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\n\nYour flaw is that we pick an unvisited vertex with lowest cost.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "dijkstra algorithm in PHP issue\r\n                \r\nI need some help, with a dijkstra algorithm in PHP.\n\nThe idea is develop a shortest path way inside a building. Entrance by a main entrance to a Hall and then 2 buildings, left (VB) and right (PS).\n\nAll names are VB-0-LIFT (building-floor-place).\n\nhttps://github.com/phpmasterdotcom/DataStructuresForPHPDevs/blob/master/Graphs/graph-dijkstra.php\n\n```\nArray\n(\n    [ENTRANCE] => Array\n    (\n        [VB-0-HALL-CROSS] => 1\n        [PS-0-HALL-CROSS] => 1\n    )\n    [VB-0-HALL-CROSS] => Array\n    (\n        [ENTRANCE] => 1\n    )\n    [PS-0-HALL-CROSS] => Array\n    (\n        [ENTRANCE] => 1\n    )\n)\n```\n\n\nMy headache begins when I start try the routes:\n\nA ) OK.     ```\n$r->route('VB-0-HALL-CROSS', 'PS-0-HALL-CROSS')```\n\n\n\nVB-0-HALL-CROSS\nENTRANCE\nPS-0-HALL-CROSS\n\n\n\n\nB) FAIL. ```\n$r->route('PS-0-HALL-CROSS', 'VB-0-HALL-CROSS')```\n\n\n\nError: There's no route from PS-0-HALL-CROSS to VB-0-HALL-CROSS\n\n\n\n\nC)  OK. ```\n$r->route('ENTRANCE', 'PS-0-HALL-CROSS')```\n\n\n\nENTRANCE \nPS-0-HALL-CROSS\n\n\n\n\nI don't know if I don't understand dijkstra but when I connect VB-0-HALL-CROSS and PS-0-HALL-CROSS with lift combinations, such as\nVB-0-HALL-CROSS -> VB lift 0 floor\n\n\nVB floor 0 -> VB floor 1, VB floor 2...\nVB floor 1 -> VB floor 0, VB floor 2... \nVB floor 2 -> VB floor 0, VB floor 1...\n\n\nAnd this with 12 floors.\n\nIn case of floors, only works with some, others doesn't work.\n\nIs there any problem with final vertex in dijkstra algorithm? Or any idea of why does it goes wrong?\n\n```\nwhile (!isEnded()) echo \"thank you Colleagues\";\n```\n\n\n(I can attach the code in github fully commented).\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Implementing Dijkstra's algorithm using CUDA in c\r\n                \r\nI am trying to implement Dijsktra's algorithm using cuda.I got a code that does the same using map reduce this is the link http://famousphil.com/blog/2011/06/a-hadoop-mapreduce-solution-to-dijkstra%E2%80%99s-algorithm/ but i want to implement something similar as given in the link using cuda using shared and global memory..Please tell me how to proceed as i am new to cuda ..i dont know if it is necessary that i provide the input on host and device both in the form of matrix and also what operation should i perform in the kernel function\n    ", "Answer": "\r\nWhat about something like this(Dislaimer this is not a map-reduce solution).\n\nLets say you have a Graph ```\nG```\n with ```\nN```\n states an adjacency matrix ```\nA```\n with entries A[i,j] for the cost of going from node i to node j in the graph. \n\nThis Dijkstras algorithm consists of having a vector denoting a front 'V' where V[i] is the current minimum distance from the origin to node i - in Dijkstras algorithm this information would be stored in a heap and loaded poped of the top of the heap on every loop.\n\nRunning the algorithm now starts to look a lot like matrix algebra in that one simply takes the Vector and applyes the adjancicy matrix to it using the following command: \n\n```\nV[i] <- min{V[j] + A[j,i] | j in Nodes}\n```\n\n\nfor all values of i in V. This is run as long as there are updates to V (can be checked on the device, no need to load V back and forth to check!), also store the transposed version of the adjacency matrix to allow sequential reads.\n\nAt most this will have a running time corresponding to the longest non-looping path through the graph.\n\nThe interesting question now becomes how to distribute this across compute blocks, but it seems obvious to shard based on row indexes.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Seam Carving an image using Dijkstra algorithm in C++\r\n                \r\nI am trying to implement Seam carving using Dijkstra's algorithm. \n\nSo far, I have converted the image to grayscale and using a 2D array, I've found out the energy function of the image. Now, to implement Dijkstra, I need to convert this 2D array into a graph and give a source and sink to the Dijsktra function.\n\nI would like to know how to change this 2D array into a graph, as the 2D array, being a matrix of MxN, where M,N both can be very huge numbers, could give rise to possibly a huge number of graphs possible, and decide the sink for it. \n    ", "Answer": "\r\nYou don't have to convert the image into a graph. All you have to do is use dynamic programming for computing seams and then finding the the seam with the minimum energy. To be more precise, to calculate S[i,j] (seam for pixel (i,j)):\n\n\nFor the first row, assign the energy value as seam value of the pixels S[1,j] = E[1,j]\nFor the next rows, propagate the minimum seam from the neighbors of the pixel downwards: S[i,j] = E[i,j] + min( S[i-1,j-1], S[i-1,j], S[i-1,j+1] )\nStart from the element with minimum value in the last row of S and climb up by choosing neighbors with minimum seam values. Store each step.\nThe path you have stored is the seam with minimum energy.\n\n\nI've also find a nice article with explains thoroughly the algorithm with MATLAB source code:\n\nhttps://kirilllykov.github.io/blog/2013/06/06/seam-carving-algorithm/\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "If the weights of all branches in the graph were equal to 1, what would Dijkstra's algorithm return as the shortest paths from a given node?\r\n                \r\nIf there exists a weighted graph G, and all weights are 1, what would Dijkstra's algorithm return as the shortest paths from a given node?\n    ", "Answer": "\r\nA correct implementation of Dijkstra's algorithm will return, for every node, the 'predecessor' node.  If you follow the predecessor nodes in sequence you will get back to the given node on a path that goes over the fewest number of connections.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Equal cost multipath Dijkstra's Algorithm in python\r\n                \r\nUsing python recipes proposed here: \n\nhttp://code.activestate.com/recipes/119466-dijkstras-algorithm-for-shortest-paths/\n\nand\n\nhttp://code.activestate.com/recipes/117228-priority-dictionary/\n\nand using as input the following graph:\n\n```\n graph_2  = {\n    'R1':{'R2':5,'R3':5},\n    'R2':{'R1':5,'R4':5},\n    'R3':{'R1':5,'R4':5},\n    'R4':{'R2':5,'R3':5},\n}\n```\n\n\nI'm trying to get ALL shortest paths between R1 and R4.  However, I'm only getting one shortest path (R1-R2-R4), and not (R1-R3-R4).  I need to simulate ECMP (such as OSPF does).  What I need is that function shortestPath returns all shortest path (i.e [[R1-R2-R4],[R1-R3-R4]]) in case of Equal Cost Multipath (like graph_2 on top) and only the shortest path in case of Single Path like for example:\n\n```\n  graph_3  = {\n    'R1':{'R2':5,'R3':5},\n    'R2':{'R1':5,'R4':5},\n    'R3':{'R1':5,'R4':10},\n    'R4':{'R2':5,'R3':5},\n}\n```\n\n\nI've modified the code in the Dijkstra function like that:\n\n```\nfrom priodict import priorityDictionary\n\ngraph_2  = {\n\n'R1':{'R2':5,'R3':5},\n'R2':{'R1':5,'R4':5},\n'R3':{'R1':5,'R4':5},\n'R4':{'R2':5,'R3':5},\n}\n\n\n\ndef Dijkstra(G,start,end=None):\n\n    D = {}  # dictionary of final distances\n    P = {}  # dictionary of predecessors\n    Q = priorityDictionary()   # est.dist. of non-final vert.\n    Q[start] = 0\n    for v in Q:\n        D[v] = Q[v]\n        if v == end: break\n\n        for w in G[v]:\n            vwLength = D[v] + G[v][w]\n\n            if w in D:\n                if vwLength < D[w]:\n                    raise ValueError, \\\n            elif w not in Q or vwLength < Q[w]:\n                Q[w] = vwLength\n                P[w] = [v]\n            elif  w not in Q or vwLength == Q[w]: <---adding this part\n                Q[w] = vwLength\n                P[w] += [v]\n\n    return (D,P)\n\ndef shortestPath(G,start,end):\n    D,P = Dijkstra(G,start,end)\n    print D,P\n    Path = []\n    while 1:\n        Path.append(end)\n        print end\n        if end == start: break\n        end = P[end]\n    Path.reverse()\n    return Path\n\nprint shortestPath(graph_2,'R1','R4')\n```\n\n\nand I'm getting the following output and error:\n\n```\n{'R4': 10, 'R1': 0, 'R2': 5, 'R3': 5} {'R4': ['R2', 'R3'], 'R2': ['R1'], 'R3': ['R1']}\n\nTraceback (most recent call last):\nFile \"next-hop-resolver.py\", line 194, in <module>\nprint shortestPath(graph_2,'R1','R4')\nFile \"next-hop-resolver.py\", line 172, in shortestPath\nend = P[end]\nTypeError: unhashable type: 'list'\n```\n\n\nWhat I would like to get using graph_2 is :\n\n[['R1', 'R2', 'R4'], ['R1', 'R3', 'R4']]\n\nand using graph_3:\n\n[['R1', 'R2', 'R4']]\n\nIf I execute the code as is, i.e without any kind of code modification I get the following result, no matter if I use graph_2 or graph_3:\n\n[['R1', 'R2', 'R4']]\n\ni.e always the shortest path, even if there is more than one path.\n\nI know that a list can't be a key in a dictionary, but to be honest I'm stuck with that, so any help is more than welcome\n    ", "Answer": "\r\nANALYSIS\n\nThanks for providing runnable code.  You haven't explained your design, but the functional problem is clear enough: P is responsible for returning the predecessor of any given node along the present path.  Since a path is strictly linear, there can be only one predecessor.  The while loop in shortestPath depends on this.\n\nHowever, the P you returned lists two predecessors for R4 along the present path, and you immediately try to index P with both of them at once.  You can't do that; you have to handle each path individually.\n\nSOLUTION\n\nSimply fixing your code is tantamount to doing your homework for you; i.e. not cool.  Since you're already this far, I suggest that you alter the loop in shortestPath to work through multiple paths.  Start with the idea of working on each of the returned values, in turn, one at a time:\n\n```\nwhile True:\n    for node in end:\n        # continue with single-path code\n```\n\n\nCODING NOTE\n\nYes, I changed the loop condition form 1 to True.\nThe recipes you're using appear to be written by someone who translated from C or other early 3rd-generation language, without learning present-day coding improvements.  One-letter variable names, capital letters, etc. are sub-standard habits for today's programmers.  (I've had to re-learn a few, myself.)\n\nTo get an idea of what you can work toward, see PEP-8.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "A better algorithm than Dijkstra's?\r\n                \r\n\n  Let ```\nG(V,E)```\n, a directed and strongly connected graph with weighted edges (can be negative). There're no negative cycles in ```\nG```\n. Find an algorithm which gets a parameter ```\nk```\n where ```\nk```\n is between ```\n2```\n and ```\n|V|-1```\n and returns the weight of the lightest path from ```\nx```\n to ```\ny```\n which uses at most ```\nk```\n edges.\n\n\nNow, the solution is creating another graph, with ```\n|V|```\n layers. The first layer is ```\nx```\n. Each other layer contains all vertices of ```\nV```\n. We define edges as follows:\n\n\nFrom the first layer: we connect ```\nx```\n to some ```\nv```\n iff there's an edge between them in the original graph (with the same weight)\nFrom any other layer to the next one: we connect ```\nu```\n to ```\nv```\n (different from ```\nu```\n) iff there's an edge between them in the original graph (With the same weight)\nFrom ```\nu```\n of some layer to ```\nu```\n of the next one, we connect an edge with weight ```\n0```\n.\n\n\nNow, we just need to evaluate each layer, inductively (Calculating the shortest path based on the previous one, for each vertex)\n\nThe time complexity is ```\nO(|V||E|)```\n.\n\nDidn't we get an improved algorithm of Dijkstra's? Since we can now use negative edges (even though we cannot deal with negative cycles)\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra Algorithm, trying to find first node in shortest path\r\n                \r\nI have been stuck on this issue and have made no progress. I want to find and print out the FIRST node in a successful \"shortest path\" traversal (ala Dijkstra's algorithm). As in the first node chosen to visit in the specified path. I feel like I need a data structure, maybe an ArrayList? I've tried this, but I can't seem to get it to be a concise list of the nodes traveled.\n\nMy code:\n\n```\n    public static ShortestPaths runDijkstra(Map<String,Node> graph, Node startNode) {\n    //Queue for visited nodes\n    Queue<Node> unvisitedNodes = new LinkedList<>();\n\n    //Distance of node from source\n    Map<Node,Integer> distances = new HashMap<>();\n    //Current node w/previous node in optimal path\n    Map<Node,Node> previousNode = new HashMap<>();\n\n    for(Node n : graph.values()) {\n        //Fill collections\n        distances.put(n, Integer.MAX_VALUE);\n        previousNode.put(n, null);\n        unvisitedNodes.add(n);\n    }\n    //Set source node distance to 0\n    distances.put(startNode, 0);\n\n    while(!unvisitedNodes.isEmpty()) {\n        int lowestDistance = Integer.MAX_VALUE;\n        Node current = null;\n        for(Node n : unvisitedNodes) {\n            if(distances.get(n) < lowestDistance) {\n                lowestDistance = distances.get(n);\n                current = n;\n            }\n        }\n\n        unvisitedNodes.remove(current);\n\n        for(Entry<Node,Integer> neighborEntry : current.adjacentNodes.entrySet()) {\n            int distanceFromNeighborToSource = (distances.get(current) + neighborEntry.getValue());\n            Node neighbor = neighborEntry.getKey();\n            if(distanceFromNeighborToSource < distances.get(neighborEntry.getKey())) {\n                distances.put(neighbor, distanceFromNeighborToSource);\n                previousNode.put(neighbor, current);\n            }\n        }\n\n    }\n\n    previousNode.put(startNode, new Node(\"-\"));\n\n    return new ShortestPaths(distances, previousNode);\n\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Can I use Prim's algorithm instead of Dijkstra's to find shortest path?\r\n                \r\nI have been fighting all day in understanding Dijkstra's algorithm and implementing with no significant results. I have a matrix of cities and their distances. What I want to do is to given an origin point and a destination point, to find the shortest path between the cities.\n\nExample:\n\n```\n     __0__ __1__ __2__ \n 0  |  0  | 34  |  0  |\n    |-----|-----|-----|\n 1  | 34  |  0  | 23  |\n    |-----|-----|-----|\n 2  |  0  | 23  |  0  |\n     ----- ----- -----\n```\n\n\nI started wondering if there is an other way to solve this. What if I apply Prim's algorithm from the origin's point and then I loop through the whole tree created until I find the destination point?\n    ", "Answer": "\r\nYou could apply Prim's algorithm and then walk the resulting tree, but you answer may be wrong. Assume that you have a graph where each edge has the same weight. Prim's algorithm simply chooses a minimal weight edge in the set of edges that could be added to the tree. It is possible that you will not choose an edge that will lead to a shortest path between two nodes.\nAssume:\n\n```\n     __0__ __1__ __2__ \n 0  |  0  |  1  |  1  |\n    |-----|-----|-----|\n 1  |  1  |  0  |  1  |\n    |-----|-----|-----|\n 2  |  1  |  1  |  0  |\n     ----- ----- -----\n```\n\n\nStarting from node 0 you could, via Prim's, choose the edges 0-1 and 0-2 to make your tree. Alternately, you could pick edges 0-1 and 1-2 to make your tree. Under the first edge set, you could find the minimum length path from 0 to 2, but under the second edge set you would not find the minimal path. Since you can't a-priori determine which edges get added in the Prim algorithm, you can't use it to find a shortest path.\n\nYou could consider the Bellman-Ford algorithm, but unless you're dealing with negative edge weights I find Dijkstra's algorithm preferable.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "What edge case am I missing for Dijkstra's algorithm?\r\n                \r\nThis is my Dijkstra's implementation. It's passing all cases in the pytest ```\ninput.n.txt```\n files but when I submit to the grading software (that doesn't provide the test or any output) I get an invalid result.\n\nHere's my solution (passes all provided test cases, but not hidden ones).\n```\n# Uses python3\n\nimport queue\nimport sys\nfrom math import inf\n\n\ndef dijkstra(adj, cost, s, t):\n\n    seen = set([s])\n\n    dist = [inf] * len(adj)\n    dist[s] = 0\n\n    prev = [None] * len(adj)\n    prev[s] = s\n\n    q = queue.Queue()\n    q.put(s)\n\n    while not q.empty():\n\n        n = q.get()\n        # print(n)\n\n        edges = []\n        for i, adjacent in enumerate(adj[n]):\n            edges.append([adjacent, cost[n][i]])\n\n        for i, edge in enumerate(edges):\n            d = dist[n] + edge[1]\n            if d < dist[edge[0]]:\n                dist[edge[0]] = d\n                edge[1] = d\n                prev[edge[0]] = n\n\n        edges = sorted(edges, key=lambda x: x[1])\n        for (e, w) in edges:\n            if not e in seen:\n                seen.add(e)\n                q.put(e)\n\n        # print(dist)\n\n    # print(prev)\n\n    return dist[t] if dist[t] is not inf else -1\n\n\ndef parse(input):\n    data = list(map(int, input.split()))\n    n, m = data[0:2]\n    data = data[2:]\n    edges = list(zip(zip(data[0 : (3 * m) : 3], data[1 : (3 * m) : 3]), data[2 : (3 * m) : 3]))\n    data = data[3 * m :]\n    adj = [[] for _ in range(n)]\n    cost = [[] for _ in range(n)]\n    for ((a, b), w) in edges:\n        adj[a - 1].append(b - 1)\n        cost[a - 1].append(w)\n    s, t = data[0] - 1, data[1] - 1\n    return dijkstra(adj, cost, s, t)\n\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read()\n    print(parse(input))\n\n\ndef test_parse():\n    assert 3 == parse(open(\"input.txt\").read())\n    assert 6 == parse(open(\"input.1.txt\").read())\n    assert -1 == parse(open(\"input.2.txt\").read())\n    assert 3 == parse(open(\"input.3.txt\").read())\n    assert 0 == parse(open(\"input.4.txt\").read())\n    assert 0 == parse(open(\"input.5.txt\").read())\n```\n\nThe format of the input is as follows...\n```\nnumber_of_vertices number_of_edges\nfrom to weight\nfrom to weight\nstart end\n```\n\ninput.txt\n```\n4 4\n1 2 1\n4 1 2\n2 3 2\n1 3 5\n1 3\n```\n\ninput.1.txt\n```\n5 9\n1 2 4\n1 3 2\n2 3 2\n3 2 1\n2 4 2\n3 5 4\n5 4 1\n2 5 3\n3 4 4\n1 5\n```\n\ninput.2.txt\n```\n3 3\n1 2 7\n1 3 5\n2 3 2\n3 2\n```\n\ninput.3.txt\n```\n5 5\n1 2 1\n1 3 2\n2 3 1\n2 4 6\n3 4 1\n1 4\n```\n\ninput.4.txt\n```\n5 6\n1 2 1\n1 3 2\n2 3 1\n2 4 6\n3 4 1\n1 1 2\n1 1\n```\n\ninput.5.txt\n```\n4 4\n1 2 1\n2 3 1\n3 4 1\n4 1 1\n1 1\n```\n\nMy program passes ALL of these. And I've tried messing around with all the edge cases I can think of testing but still it fails with a \"Wrong answer\" error in the testing software.\nOne of the comments of the thread of somebody who DID solve it:\n\nWow! I really struggled to put this one together, not because I didn't\nunderstand the Dijkstra algorithm but because of the difficulty in\nadjusting the priority of an item already added to a Python\nPriorityQueue class (whose use was implied by importing queue in the\nstart code) or by keeping track of its position in the priority queue,\nwhich made translating the algorithm, as presented in the lectures,\nverbatim difficult.\nIn case it is helpful to others, the way I got around this was to move\nfrom thinking in terms of inserting vertices to the priority queue to\ninserting references to the vertices, with most updated distance at\nthe time of insertion as the priority, instead. That way we don't need\nto adjust the priority of an item already added to the queue at a\nlater time.\nWe may end up inserting several references to the same vertex to the\nqueue, but we will, of course, encounter the reference with the least\ndistance first, and we can ignore any future references to the same\nvertex that we might encounter afterwards. Further, we can abort the\nalgorithm as soon as we've popped a reference to the destination\nvertex.\nThis still runs pretty efficiently (for me, a maximum time of about a\ntwentieth of that allowed), and is, in retrospect, a small adjustment\nin viewing the problem.\n\n    ", "Answer": "\r\nYour algorithm uses a queue; Dijkstra's algorithm does not use a queue.\nAt each iteration you must select the unconfirmed vertex with the shortest path distance. This can be done using a min-priority queue, where the path distance is the priority, but note also that each vertex may have to be added to the priority queue more than once if it is discovered via different paths of different distances. (Your classmate initially tried to do this the hard way - by updating the priority of a vertex already in the priority queue, instead of just allowing each vertex to be present in the priority queue multiple times.)\nSo your algorithm is not a proper implementation of Dijkstra's algorithm, because it confirms the vertices in the order they are discovered, rather than in order of path distance from the source vertex.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "dijkstra's shortest path algorithm with constant weight\r\n                \r\nhow can I apply the Dijkstra algorithm to find the minimum path considering only nodes that have a certain weight value?\n\n```\ntypedef property < vertex_index1_t, int > VertexProperty; \n    typedef property < edge_weight_t, float > EdgeProperty; \n\n    typedef adjacency_list < listS, vecS, undirectedS,\n        VertexProperty, EdgeProperty > graph_t;\n    typedef graph_traits < graph_t >::vertex_descriptor vertex;\n    typedef graph_traits < graph_t >::edge_descriptor edge_descriptor;\n    typedef std::pair<int, int> Edge;\n```\n\n\nI take into consideration an image with the starting and arrival pixels\n\n```\n    // load image\n    cv::Mat image = cv::imread(\"/Images/image_crop.tif\", CV_LOAD_IMAGE_GRAYSCALE); \n    // start\n    pos_x[0] = 26;\n    pos_y[0] = 45;\n    // finish\n    pos_x[1] = 15;\n    pos_y[1] = 60;\n```\n\n\nI enter the parameters of interest\n\n```\n    float c = 0.5; // constant to move\n    std::list<float> weights; // list of weights of an image\n    std::list<Edge> edge_array; // list of edge of an image\n    std::vector<float> vertici; // vector of vertex of an image \n```\n\n\nI go to insert vertices, weights and make pixel connections\n\n```\n    for(int x=0; x<width; x++)\n        for(int y=0; y<height; y++)\n            vertici.push_back( float(y*width+x) );\n\n    for(int x=0; x<width; x++)\n    {\n        for(int y=0; y<height; y++)\n        {\n            for(int i=-1; i<2; i++)\n            {\n                for(int j=-1; j<2; j++)\n                {\n                    // color difference\n                    weights.push_back(std::fabs(image.at<unsigned char>(y,x)/255.0f - image.at<unsigned char>(y+i, x+j)/255.0f) + c); \n\n                    // connections between adjacent pixels\n                    edge_array.push_back( Edge( (y*width+x), ((y+i)*width+x+j)) ); \n                }\n            }\n        }\n    }\n```\n\n\nI create the related graph\n\n```\n    graph_t g(edge_array.begin(), edge_array.end(), weights.begin(), num_nodes); // create the graph\n    property_map<graph_t, edge_weight_t>::type weightmap = get(edge_weight, g);\n    std::vector<vertex> p(num_vertices(g)); // to store parents\n    std::vector<float> d(num_vertices(g)); // to store distance\n```\n\n\nFrom here starts Dijkstra\n\n```\n    dijkstra_shortest_paths(g, (pos_y[0]*width+pos_x[0]), \n    predecessor_map(&p[0]).distance_map(&d[0]).weight_map(get(edge_weight, g))); // I have to be able to consider only weights = 0.5\n\n    typedef std::vector<graph_t::edge_descriptor> PathType;\n    PathType percorso;\n    vertex v = (pos_y[1]*width+pos_x[1]); // point of arrival\n\n    for(vertex u = p[v]; u != v; v = u, u = p[v])\n    {\n        std::pair<graph_t::edge_descriptor, bool> edgePair = edge(u, v, g);\n        graph_t::edge_descriptor edge = edgePair.first;\n        percorso.push_back( edge );\n    }\n\n    std::cout << \"Shortest path from starting position to arrival position:\" << std::endl;\n    for(PathType::reverse_iterator pathIterator = percorso.rbegin(); pathIterator != percorso.rend(); ++pathIterator)\n    {\n        std::cout << vertici[source(*pathIterator, g)] << \" -> \" << vertici[target(*pathIterator, g)]\n        << \" = \" << get( edge_weight, g, *pathIterator ) << std::endl;      \n    }\n```\n\n    ", "Answer": "\r\nUse breadth-first-search instead.\n\nOr use a constant weight map if you insist.\n\n```\nauto weight_map = boost::make_constant_property<EdgeDesc>(1.0);\n```\n\n\nSee Boost graph: dijkstra_shortest_paths: cannot form a reference to 'void'\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Randomizing Dijkstra algorithm input\r\n                \r\nI've been studying the Dijkstra algorithm for a while now and i'm trying to randomize it's inputs to get some data about it's runtime. The thing that is bothering me is when the input is created (randomized using rand() and srand() on C++) there is a chance that many of the edges created will be the same, thus creating a smaller graph than i previously stated and wanted, making my results less reliable in a way. I've been trying this for the past 2 days and so far have made zero progress towards a solution, or at least one that won't mess with the O(mlogn) complexity of the algorithm.\n\nI have created a minimum spanning tree already but creating the remaining edges without passing through the same one twice is what i'm not being able to do.\n\nI've been using an implementation i found on a quora post by Avinash Kumar:\n\n```\n// Time complexity : O(ElogV)\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector< pii > vii;\n#define INF 0x3f3f3f3f\nvii *G;   // Graph\nvi Dist;  // for storing the distance of every other node from source.\n/*==========================================*/\nvoid Dijkstra(int source, int N) {\n    priority_queue<pii> Q;\n    Dist.assign(N,INF);\n    Dist[source] = 0;\n    Q.push({0,source});\n    while(!Q.empty()){\n        int u = Q.top().second;\n        Q.pop();\n        for(auto &c : G[u]){\n            int v = c.first;\n            int w = c.second;\n            if(Dist[v] > Dist[u]+w){\n                Dist[v] = Dist[u]+w;\n                Q.push({Dist[v],v});\n            }\n        }\n    }\n}\n/*===========================================*/\nint main() {\n    int N, M, u, v, w, source;  // N-total no of nodes, M-no. of edges, \n    cin >> N >> M;              // u,v and w are the end vertices and the weight associated with an edge\n    G = new vii[N+1];\n\n    for(int i=0;i<M;++i){\n        cin >> u >> v >> w;\n        G[u].push_back({v,w});\n        G[v].push_back({u,w});\n    }\n    cin >> source;\n    Dijkstra(source,N);\n\n    for(int i=0;i<N;i++)\n        cout<<Dist[i]<<\" \";\n    cout<<endl;\n\n    return 0;\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "(C++) Dijkstra's Algorithm Backtracking issues\r\n                \r\nI'm programming Djikstra's algorithm in C++ and I'm getting the correct distances from the source node to the end node but i'm having trouble backtracking the previous nodes visited. It's giving me sort of the correct answer but not the correct answer. Also I noticed with different input data of 1 as the start node and 16 as the finish node that my algorithm is using path's that aren't allowed (it goes from 1 -> 10 -> 8 when 8 isn't allowed) but that could just be me getting path backtracking wrong.\n\nhttp://pastebin.ca/3188762  - Input data (1st = max nodes and then nodes(node num, x,y) then max edges then all edges with the last line being the start and finish node)\n\nhttp://textuploader.com/awp89   - Output in console\n\nCode:\n\n```\n#include<iostream>\n#include<fstream>\n\nusing namespace std;\n\nstruct Node\n{\n    int nodeNum;\n    double x, y;\n};\n\nvoid dji(double map[50][50],int startNode,int endNode,int maxNodes);\n\nint main()\n{\n    int tempA, tempB, maxNodes, maxEdges, startNode, endNode;\n    double tempD;\n    double map[50][50];\n\n    ifstream fin;\n    fin.open(\"ass03.txt\");\n    if(fin.good())\n    {\n        fin >> maxNodes;\n\n        Node allNodes[maxNodes];\n        for(int i = 0; i < maxNodes; i++)\n        {\n            for(int k = 0; k < maxNodes; k++)\n            {\n                map[i][k] = -1;\n            }\n            map[i][i] = 0;\n        }\n\n        for(int i = 0; i < maxNodes; i++)\n        {\n            fin >> allNodes[i].nodeNum >> allNodes[i].x >> allNodes[i].y;\n        }\n        fin >> maxEdges;\n\n        for(int i = 0; i < maxEdges; i++)\n        {\n            fin >> tempA >> tempB >> tempD;\n            map[tempA-1][tempB-1] = tempD;\n            map[tempB-1][tempA-1] = tempD;\n        }\n\n        fin >> startNode >> endNode;\n\n\n        cout << \"\\t\";\n\n        for(int i = 0; i < maxNodes; i++)\n        {\n            cout << i+1 << \"\\t\";\n        }\n        cout << endl;\n        for(int i = 0; i < maxNodes; i++)\n        {\n            cout << i+1 << \"\\t\";\n            for(int k = 0; k < maxNodes; k++)\n            {\n                cout << map[i][k] << \"\\t\";\n            }\n            cout << endl;\n        }\n\n\n        dji(map, startNode-1, endNode-1, maxNodes);\n\n    }\n    else\n    {\n        cout << \"Incorrect filename\" << endl;\n    }\n\n\n    return 0;\n}\n\n\n\n\n void dji(double map[50][50], int startNode,int endNode,int maxNodes)\n{\n    int Intersections[maxNodes], path[maxNodes], temp; // equate for actual endNode\n    double Distances[maxNodes];\n\n    for(int a = 0; a < maxNodes; a++)\n    {\n        Intersections[a] = a;\n        Distances[a] = map[startNode][a];\n\n        if(map[startNode][a] != -1)\n        {\n            path[a] = startNode;\n        }\n        else\n        {\n            path[a] = -1;\n        }\n    }\n    Intersections[startNode] = -1;\n    Distances[startNode] = 0;\n\n    double minValue = 99999;\n    int minNode = 0;\n\n    for(int l = 0; l < maxNodes; l++)//loop max amount of times to avoid having to function loop (disconsider l = startNode)?\n    {\n        for (int i = 0; i < maxNodes; i++)\n        {\n                if(Intersections[i] == -1)\n                {\n                    continue;\n                }\n\n                if(Distances[i] > 0 && Distances[i] < minValue)\n                {\n                minValue = Distances[i];\n                minNode = i;\n                }\n        }\n\n\n        if(Intersections[minNode] == endNode)\n        {\n            temp = l;\n        }\n\n        Intersections[minNode] = -1;\n\n        cout << \" --- Used Node - \" << minNode+1 << endl;\n\n        for(int i = 0; i < maxNodes; i++)\n        {\n            cout << Intersections[i] << \" \";\n\n        }\n        cout << endl;\n\n        for(int i = 0; i < maxNodes; i++) \n        {\n            if(map[minNode][i] < 0)\n            {\n                continue;\n            }\n\n            if(Distances[i] < 0) \n            {\n                Distances[i] = minValue + map[minNode][i];\n                path[i] = minNode;\n                continue;\n            }\n\n            if((Distances[minNode] + map[minNode][i]) < Distances[i]) \n            {\n                Distances[i] = minValue + map[minNode][i];\n                path[i] = minNode;\n            }\n        }\n\n        minValue = 99999;\n    }\n\n    for(int i = 0; i < maxNodes; i++)\n    {\n        cout << \"Node:\"  << i+1 << \" - PATH= \" << path[i] << \"     distance = \" << Distances[i]  << endl;\n    }\n\n    cout << \"Additional nodes used: \" << temp << endl;\n\n    temp = path[endNode];\n    for(int i = 0; i < 4; i++)\n    {\n        cout << temp << \" \";\n        temp = path[temp];\n    }\n\n    /*temp = path[endNode];\n\n    int temp2 = path[endNode];\n\n    for(int i = 0; i < maxNodes; i++)\n    {\n        if(i == 0)\n        {\n            cout << endNode << \" \";\n            cout << temp << \" \";\n        }\n        if(i%2 == 0)\n        {\n            if(temp != endNode)\n            {\n                temp = path[temp2];\n                cout << temp << \" \";\n            }\n            else\n            {\n                cout << temp << \" \";\n                i = maxNodes;\n            }\n        }\n        else\n        {\n            if(temp2 != endNode)\n            {\n                temp2 = path[temp]-1;\n                cout << temp2 << \" \";\n            }\n            else\n            {\n                cout << temp2 << \" \";\n                i = maxNodes;\n            }\n        }\n    }*/\n\n    //cout << \"PATH = \" << endNode << \" < - \" << path[endNode] << \" < - \" << path[path[endNode]-1] << \" < - \" << path[path[path[endNode]-1]-1] <<  endl;\n\n    //cout << \"TEST\" << path[4] << \" \" << path[8] << \" \" << path[16] << \" \" << endl;\n}\n```\n\n\nThank you for any help\n    ", "Answer": "\r\nThe problem is you're mixing zero-based and one-based indexing. Your vertices are numbered 1-20, and those are the numbers that end up in your ```\npath```\n array with valid indices 0-19. You then use the vertex number as the index into the array.\n\nChange your code to either consistently use the vertex number, or consistently use the array index.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra algorithm fails when calculating multiple paths\r\n                \r\nI'm trying to implement Dijkstra's algorithm for multiple nodes. For example i have x amount of nodes to be visited and i need to make a route to visit each one without changing their order, it doesnt matter if there's shorter path than that. Everything seemed to work at first but after more than 2 nodes it fails at calculating route and goes out of memory. I'm assuming I did something terrible here.\n\nI'm sorry for this unclear question, but I'm not really sure how to make it shorter.\n\nEdit: The problem is that when there are added 3 or more Vertices in 'verticesToVisit' list, Java throws out out of memory in Java heap space exception at 'getShortestPath method, exact line is marked with comment below.\n\nAnyways here's my classes:\n\n```\nVertice\n\nprivate List<Edge> adjencies;\nprivate double minDistance = Double.POSITIVE_INFINITY;\nprivate Vertice previous;\n\npublic Domicile() {\n    adjencies = new ArrayList<Edge>();\n    previous = null;\n}\npublic void reset() {\n    this.minDistance = Double.POSITIVE_INFINITY;\n}\n// sets and gets..\n```\n\n\nEdge\n\n```\nprivate Vertice target;\nprivate Vertice source; // Not used in algorithm, just for debugging\nprivate double weight;\n\npublic Edge(Vertice argSource, Vertice argTarget, double argWeight) {\n    source = argSource;\n    target = argTarget;\n    weight = argWeight;\n}\npublic Edge(){}\n// sets and gets\n```\n\n\nAlgorithm:\n\n```\npublic void computePaths(Vertice source) {\n    source.setMinDistance(0.);\n    PriorityQueue<Vertice> vertexQueue = new PriorityQueue<Vertice>();\n    vertexQueue.add(source);\n    while(!vertexQueue.isEmpty()) {\n        Vertice u = vertexQueue.poll();\n\n        for(Edge e : u.getAdjencies()) {\n            Vertice v = e.getTarget();\n            double weight = e.getWeight();\n            double distanceThroughU = u.getMinDistance() + weight;\n            if(distanceThroughU < v.getMinDistance()) {\n                vertexQueue.remove(v);\n                v.setMinDistance(distanceThroughU);\n                v.setPrevious(u);\n                vertexQueue.add(v);\n            }\n        }\n    }\n}\n///////////////////////\n// This method fails //\n///////////////////////\npublic List<Vertice> getShortestPathTo(Vertice target) {\n    List<Vertice> path = new ArrayList<Vertice>();\n    for(Vertice vertex = target; vertex != null; vertex = vertex.getPrevious()) {\n        path.add(vertex);   // Java runs out of memory \"Java heap size\" here\n    }\n    Collections.reverse(path);\n    return path;\n}\n\npublic void resetAllVertices() {\n    for(Vertice dom : graph) {\n        dom.reset();\n    }\n}\n\n\npublic List<String> getRoute() {\n    List<Vertice> verticesToVisit = dbd.getAllVertice(); // Gets them from database. This part is working.\n    Collections.sort(verticesToVisit);\n    List<String> result = new ArrayList<String>();\n    if(verticesToVisit.isEmpty()) {\n        return null;\n    }\n    else if(patients.size() < 2) {\n        result.add(verticestoVisit.get(0).getName());\n    } else {\n\n        for(int i = 0; i < verticesToVisit.size()-1; i++) {\n            Vertices graphDomStart = findFromGraph(verticesToVisit.get(i).getLocationId()); // finds vertice in graph (in db they dont have edges)\n            Vertice graphDomGoal = findFromGraph(verticesToVisit.get(i+1).getLocationId()); // finds vertice in graph (in db they dont have edges)\n\n            computePaths(graphDomStart); // exception is tracked from here\n            result.add(formatAddress(getShortestPathTo(graphDomGoal)));\n\n            resetAllVertices();\n        }\n    }\n    return result;\n}\n\nprivate Domicile findFromGraph(int locationId) {\n    for(Domicile dom : graph) {\n        if(dom.getLocationId() == locationId) {\n            return dom;\n        }\n    }\n    return null;\n}\n```\n\n\nThank you and sorry for big wall of code.\n    ", "Answer": "\r\nIn your reset function:\n\n```\npublic void reset() {\n    this.minDistance = Double.POSITIVE_INFINITY;\n}\n```\n\n\nI recommend you also reset previous\n\n```\npublic void reset() {\n    this.minDistance = Double.POSITIVE_INFINITY;\n    this.previous = null;\n}\n```\n\n\nor you will get an infinite loop when tracing the path backwards.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "dijkstra algorithm return path of vertices\r\n                \r\nI have an assignment that I am doing for college that requires me to implement dijkstra algorithm in c++ for simulating a network sending packets. My dijkstra algorithm needs to be implemented so that I can return a valid path to the each node in the tree, I have this:\n\n```\nunordered_map<Vertex*, Path> computeShortestPath(Vertex *start)\n{\n    //holds known distances\n    unordered_map<Vertex*, Path> distances;\n\n    //underlying heap\n    priority_queue<Vertex*, vector<Vertex*>, PathWeightComparer> dijkstra_queue{};\n\n    //reset start's path weight\n    start->setPathWeight(0);\n\n    //make sure that the starting vertex is in the graph\n    if (_vertices.find(start->getId()) != _vertices.end())\n    {\n        //push on starting vertex\n        dijkstra_queue.push(_vertices.at(start->getId()));\n\n\n\n    while (dijkstra_queue.size() > 0)\n        {\n\n            Vertex *t = dijkstra_queue.top();\n\n            dijkstra_queue.pop();\n            distances[t];\n\n            unordered_map<Vertex*, int> edges = t->getEdges();\n\n\n            for (auto it = edges.begin(); it != edges.end(); ++it)\n            {\n\n                int newDistance = (it->second + distances[t].getPathWeight());\n\n\n                if (newDistance < distances[it->first].getPathWeight() || (distances[it->first].getPathWeight() == 0 ))\n                {\n\n                    queue<Vertex*>verts = distances[t].getVertices();\n\n                    verts.push(it->first);\n\n                    distances[it->first].setVertices(verts);\n\n                    distances[it->first].setPathWeight(newDistance);\n\n\n                    dijkstra_queue.push(it->first);\n                }\n            }\n\n        }\n\n    }\n\n\n    return distances;\n}\n```\n\n\nWith sample data given to me by an instructor:\n\nVertices: {v1, v2, v3}, Links(one way): { (v1,v2,5), (v1,v3,10), (v2,v3,4) }\n\nNow when I call this function one vertex 1 I should receive an unordered map in memory as follows:\n\nVertex:Path\n\n```\n1:{Null} (indicating this is source node)\n2:{v2}\n3:{v2,v3}\n```\n\n\nHowever on vertex 3 I receive:\n\n```\n3:{v3,v2,v3}\n```\n\n\nI've been working on the overall project for a while and this is the last little issue I need to work out for the assignment to be completed. Any help is appreciated. \n\nEverything else has been tested and working 100% I need to just spot my logic flaw, Thanks.\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Unity crashes when using dijkstra's algorithm with different starting points\r\n                \r\nThis is my first time asking a question here, so please forgive me if I make any mistakes.\n\nI'm currently using Unity 2019.1.14f1 on Windows 10 Enterprise with an Intel Xeon E5-1650 v4 with 32.0 GB RAM, GeForce GTX 1080 with the latest drivers.\n\nTo give a little context to the problem, I have a unity scene set up which has a bunch of objects with the NavLinkProxy class and NavNodeProxy class that store some data. These are used for generating routes, specifically using Dijkstra's algorithm. Below is the code I used:\n\n```\nprivate static void DijkstraSearch(VenueManager venueManager, NavNodeProxy start, NavNodeProxy end)\n{\n    // Priority queue\n    var pQueue = new BinaryHeap<NavNodeProxy>();\n\n    // Set cost of start node to 0\n    start._NavNodeInfo.MinCostToStart = 0;\n\n    // Add start node to priority queue\n    pQueue.Add(start);\n\n    do\n    {\n        // Remove node on top of heap and set it as node value\n        var node = pQueue.Remove();\n\n        List<NavLinkProxy> nodeLinks = venueManager._ActiveNavLinks.FindAll(result => (result._NavLinkInfo.n1 == node) || (result._NavLinkInfo.n2 == node));\n\n        for (int i = 0; i < nodeLinks.Count; i++)\n        {\n            NavNodeProxy connectingNode;\n\n            if (nodeLinks[i]._NavLinkInfo.n1._NavNodeInfo.id == node._NavNodeInfo.id)\n                connectingNode = nodeLinks[i]._NavLinkInfo.n2;\n            else\n                connectingNode = nodeLinks[i]._NavLinkInfo.n1;\n\n            if (connectingNode._NavNodeInfo.Visited)\n                continue;\n\n            if (connectingNode._NavNodeInfo.MinCostToStart == Mathf.Infinity || node._NavNodeInfo.MinCostToStart + nodeLinks[i]._NavLinkInfo.horizontalLength < connectingNode._NavNodeInfo.MinCostToStart)\n            {\n                connectingNode._NavNodeInfo.MinCostToStart = node._NavNodeInfo.MinCostToStart + nodeLinks[i]._NavLinkInfo.horizontalLength;\n                connectingNode._NavNodeInfo.NearestToStart = node;\n                if (!pQueue.heapList.Contains(connectingNode))\n                    pQueue.Add(connectingNode);\n            }\n        }\n        node._NavNodeInfo.Visited = true;\n\n        if (node == end)\n            return;\n    } while (pQueue.heapList.Any());\n}\n```\n\n\nThe route is generated normally at first and works perfectly fine if I change the position of the end as well.\n\nHowever, when I change the position of the start and try to generate a route, Unity hangs up, usually remaining completely non-responsive and forcing me to force close it.\n\nI have tried swapping the start and end node objects in the scene and repeated the above steps to get the exact same results. Besides this I'm not very sure what could be happening to give me this result.\n\nEdit: Edited the post with the correct code.\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Implementing Dijkstra algorithm in Java\r\n                \r\nI'm trying to make a program that supports multiple operations on automata (graphs). \nThis is what my datasctructures look like: \n\n```\npublic class Automaton {\nprivate ArrayList<Node> $Q; /* All the nodes */\nprivate Node $startingNode; /* The startingNode */\nprivate ArrayList<Connection> $delta; /* All the connections */\nprivate ArrayList<Node> $F; /* All the end nodes */\nprivate ArrayList<Character> $E; \n\n\npublic class Connection { \nprivate Node $start; \nprivate Node $end; \nprivate char $condition; }\n\n\npublic class Node { \nprivate boolean $startingNode; \nprivate boolean $endNode; \nprivate String $name; }\n```\n\n\nOne of the operations is the Dijkstra algorithm, here is my code so far, the problem is that it never goes into this if (D[v] >= (D[w] + value)), because 1 will never be smaller than 1, im looking for a way how i can count the length of my path so it's higher than 1. Eg : from A->D is length 3, since you go from A to B, from B to C, from C to D.\n\n```\npublic String[] shortestPath() {\n    boolean[] visited = new boolean[$Q.size()];\n    String[] P = new String[$Q.size()];\n    int[] D = new int[$Q.size()];\n    char c;\n    int w;\n    int value = 0;\n    Node source = null;\n    boolean found = false;\n\n    for (int i = 0; i < visited.length; i++) {\n        if ($Q.get(i).getStartingNode()) {\n            visited[i] = true;\n            source = $Q.get(i);\n        } else\n            visited[i] = false;\n    }\n\n    for (int i = 0; i < $Q.size(); i++) {\n        /* If the source and the node are not the same */\n        if (!($Q.get(i).getName().equals(source.getName()))) {\n            P[i] = source.getName();\n            /* If there is a connection */\n            c = checkConnection(source, $Q.get(i));\n            if (c != '\\u0000') {/* There is a connection */\n                if (c == '$')/* Epsilon transition */\n                    D[i] = 0;\n                else\n                    D[i] = 1;\n            } else\n                /* There isnt a connection, put it on -1 */\n                D[i] = -1;\n        }\n\n    }\n    for(int i = 0; i < visited.length; i++)\n        System.out.println(visited[i]);\n\n    for (int i = 1; i < $Q.size() && !found; i++) {\n        w = findMinimum(D, visited);\n        visited[w] = true;\n\n        System.out.println(w);\n\n        for (int v = 0; v < $Q.size() && !found; v++) {\n            if (!(visited[v])) {\n                c = checkConnection($Q.get(w), $Q.get(v));\n                if (c != '\\u0000') {/* There is a connection */\n                    if (c == '$')/* Epsilon transition */\n                        value = 0;\n                    else\n                        value = 1;\n                    /*Check if from source to v is shorter if you go via w*/\n                    if (D[v] >= (D[w] + value)) {\n                        D[v] = D[w] + value;\n                        P[v] = $Q.get(w).getName();\n\n                        if ($Q.get(w).getEndNode())\n                            found = true;\n                    }\n                }/*Connection if*/\n            }\n        }\n    }\n    return P;\n\n}\n\n/** Returns the minimum cost of the connections from the source\n * @param d the array with the costs from the source to the other nodes\n * @param visited an array that remembers which node is already visited\n * @return returns the index of the position with the minimum cost\n */\nprivate int findMinimum(int[] d, boolean[] visited) {\n    // TODO Auto-generated method stub\n    int min = 2; /* Since the cost will be 0 of 1 we can use 2 as a higher number */\n    int index = 0;\n\n    for (int i = 0; i < d.length; i++) {\n        /* If we didnt visit the node yet, so a node outside s */\n        if (!(visited[i])) {\n            /* If there really is a connection */\n            if (d[i] != -1) {\n                /* If the cost is lower than our current minimum */\n                if (d[i] <= min){\n                    index = i;\n                    min = d[i];\n                }\n\n            }\n        }\n    }\n\n    /**\n * Checks if there is a connection between 2 nodes\n * @param start the startnode of the connection\n * @param end the endnode of the connection\n * @return returns the cost of the edge between the 2 nodes, else return null\n */\nprivate char checkConnection(Node start, Node end){\n    for(int i = 0; i < $delta.size(); i++){\n        /*If the start node and the end node are the same*/\n        if(($delta.get(i).getStart().getName().equals(start.getName())) && $delta.get(i).getEnd().getName().equals(end.getName())){\n            return $delta.get(i).getCondition();\n        }\n    }\n    return '\\u0000'; /*Empty char*/\n}\n    return index;\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Dijkstra Algorithm in C# error\r\n                \r\nI am new to C# programming and I was trying to implement Dijkstra algorithm in C# to get the shortest distance between two nodes but I am getting following error-\n\nerror CS1525: Unexpected symbol ```\nvoid', expecting ```\nclass', ```\ndelegate', ```\nenum', ```\ninterface', ```\npartial', or `struct'\nprog.cs(54,16): error CS1525: Unexpected symbol ```\nint', expecting ```\nclass', ```\ndelegate', ```\nenum', ```\ninterface', ```\npartial', or `struct'\nprog.cs(54,21): error CS1514: Unexpected symbol ```\n[', expecting ```\n.' or `{'\nprog.cs(54,21): warning CS0658: `,' is invalid attribute target. All attributes in this attribute section will be ignored\n\nThis is my code:\n```\nusing System;\nusing System.Collections.Generic;\n\nnamespace Dijkstras\n{\n    class Graph\n    {\n        int V = 9;\n        int minDistance(int[] dist, bool[] sptSet)\n        {\n \n            int min = 100; int min_index=0;\n\n            for (int v = 0; v < V; v++)\n                if (sptSet[v] == false && dist[v] <= min)\n                   { min = dist[v]; min_index = v;}\n\n            return min_index;\n        }\n\n        int printSolution(int[] dist, int n)\n         {\n            Console.WriteLine(\"Vertex   Distance from Source\");\n            for (int i = 0; i < V; i++)\n            {\n                Console.Write(i); Console.Write(\"      \");\n                Console.WriteLine(dist[i]);\n            }return 0;\n         }\n        void dijkstra(int [,] graph , int src)\n          {    //graph=new int[V,V];\n                int [] dist=new int[V];    \n                bool [] sptSet=new bool[V];\n                for (int i = 0; i < V; i++)\n                 {  dist[i] = 100;\n                    sptSet[i] = false;\n                 }\n                dist[src] = 0;\n                for (int count = 0; count < V-1; count++)\n                     {\n                        int u = minDistance(dist, sptSet);\n                        sptSet[u] = true;\n                        for (int v = 0; v < V; v++)\n                         {  if (sptSet[v]==false && dist[u] != 100 && dist[u]+graph[u,v] < dist[v])\n                                dist[v] = dist[u] + graph[u,v];\n                         }\n                     }\n                printSolution(dist, V);\n          }\n    }\n       \n     public static void Main()\n      {\n                int [,] graph =new int[,] {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n                      {4, 0, 8, 0, 0, 0, 0, 11, 0},\n                      {0, 8, 0, 7, 0, 4, 0, 0, 2},\n                      {0, 0, 7, 0, 9, 14, 0, 0, 0},\n                      {0, 0, 0, 9, 0, 10, 0, 0, 0},\n                      {0, 0, 4, 0, 10, 0, 2, 0, 0},\n                      {0, 0, 0, 14, 0, 2, 0, 1, 6},\n                      {8, 11, 0, 0, 0, 0, 1, 0, 7},\n                      {0, 0, 2, 0, 0, 0, 6, 7, 0}\n                     };\n                dijkstra(graph, 0);\n     }\n        \n }\n```\n\nCan someone please tell me what is wrong with my code?\n    ", "Answer": "\r\nYou've got several problems here.\n\n\nYour Main function isn't inside of a class. In C# all methods must be inside a class. Move Main inside the Graph class.\nYour functions need to be static so they can be referenced from your Main method.\nYour variables need to be static so they can be referenced from your now-static functions.\n\n\nAlternatively to 2 & 3, you could use object oriented programming and make an object out of the Graph class instead of doing all static functions. This could be done by changing the last line of your Main function to something like\n\n```\nGraph graphObject = new Graph();\ngraphObject.dijkstra(graph, 0);\n```\n\n\nand then you can leave everything not static.\n\nDo all three of those steps and it will compile. I didn't check for correctness though.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How to handle \"composed nodes\" in a graph traversed via Dijkstra's algorithm?\r\n                \r\nI'm dealing with a state machine that is currently traversed via Dijkstra's algorithm. However, now I need to enhance that state machine to be \"smarter\" in how it figures out routes to account for some side-effects. Basically some paths are not traversable if certain requirements aren't met, even if you're in the correct starting state for that path. These requirements can be satisfied by traversing other paths first. A simplified example of what I'm trying to address is traveling between cities:\n\n\nYou can travel domestically without your passport (just a basic ID) (i.e. Philly -> NYC)\nAs soon as you need to travel internationally, you need your passport (NYC -> Paris)\nIf you already have your passport, you can travel internationally (NYC -> Paris)\nIf you don't, you need to travel home first to take it (NYC -> Philly -> NYC -> Paris)\n\n\nAn alternative example (that I'm actually dealing with) is website states and the concept of being logged in and logged out).\n\nThere are 2 approaches I'm thinking of:\n\n\nComposing states (i.e. having passport is itself a secondary state that can be combined with \"location\" states), this sounds like it would add a whole other dimension to my state machine and I'm not sure whether it would make the algorithm a mess.\nConditional paths that are only available if certain property is set while being in a state (a somewhat Bayesian approach), this would effectively make my states \"impure\", where transition taken would depend on internal state properties, so I prefer the composing states approach instead.\n\n\nIs there a clean way to represent this via graph theory? Is there a general case algorithm that can deal with this preliminary requirement for being able to traverse a path? This problem is basically a 2-stage Dijkstra's search where you must visit a certain node first, but that node doesn't need to be visited if you already satisfy the \"has passport\" condition.\n    ", "Answer": "\r\nOne can solve it with Astar by indeed \"dupplicating\" cities in a seemingly 2^n fashion (in practice this is less since not all the states will be explored).\n\nA node is now a tuple ```\n<city, ...flags>```\n where in this case, flags is the simple boolean to represent whether we are in possession of the passport or not.\n\nInstead of basically considering the neighbours of some city ```\nC```\n, we now consider the neighbours of the tuple ```\nT```\n, which are the neighbours of ```\nT.city```\n restricted to some rule:\n\n\n  If the neighbouring city requires a pass, ```\nT```\n must have the pass in its flags\n\n\nBelow Astar, copy pasted from wiki. The only adaptation, is: \n\n\n  while generating the neighbours from some node, if node has pass, so have the neighbours.\n\n\nNotice in tests (copied more or less from Guy Coder), two tests commented (which fail).\n\n\nThe first one, because harrisburg having the passport overrides in my case the absence of password specified as argument\nThe second one, because as commented, I am not expecting to come \"back & forth\" if not needed.\n\n\nNote that the edges are not weighted ```\nd(a,b) = 1```\n forall existing ```\n(a,b)```\n but they could/should be.\n\n\r\n\r\n```\nfunction h (node) { return 0 }\r\nfunction d (a, b) { return 1 } // no weight but could be\r\nconst M = {\r\n    harrisburg: [\r\n      { c: 'philly', passRequired: false }\r\n    ],\r\n    nyc: [\r\n      { c: 'philly', passRequired: false },\r\n      { c: 'paris', passRequired: true }\r\n    ],\r\n    paris: [\r\n      { c: 'nyc', passRequired: true }\r\n    ],\r\n    philly: [\r\n      { c: 'harrisburg', passRequired: false },\r\n      { c: 'nyc', passRequired: false }\r\n    ]\r\n}\r\n\r\nconst neighbours = node => {\r\n    if (node.c === 'harrisburg') {\r\n        return M[node.c].map(x => {\r\n            return { c: x.c, hasPass: true }\r\n        })\r\n    }\r\n    if (node.hasPass) {\r\n        return M[node.c].map(x => Object.assign({ hasPass: true }, x))\r\n    }\r\n    return M[node.c].filter(x => !x.passRequired)\r\n}\r\nfunction id (node) { return node.c + !!node.hasPass }\r\n\r\n//https://en.wikipedia.org/wiki/A*_search_algorithm\r\nfunction reconstruct_path (cameFrom, current) {\r\n  const total_path = [current]\r\n  while(cameFrom.has(id(current))) {\r\n    current = cameFrom.get(id(current))\r\n    total_path.unshift(current)\r\n  }\r\n  return total_path\r\n}\r\n\r\n\r\n// A* finds a path from start to goal.\r\n// h is the heuristic function. h(n) estimates the cost to reach goal from node n.\r\nfunction A_Star(start, goal, h) {\r\n  // The set of discovered nodes that may need to be (re-)expanded.\r\n  // Initially, only the start node is known.\r\n  const openSet = new Map([[id(start), start]])\r\n\r\n  // For node n, cameFrom[n] is the node immediately preceding it on the cheapest path from start to n currently known.\r\n  const cameFrom = new Map()\r\n\r\n  // For node n, gScore[n] is the cost of the cheapest path from start to n currently known.\r\n  const gScore = new Map()\r\n  gScore.set(id(start), 0)\r\n\r\n  // For node n, fScore[n] := gScore[n] + h(n).\r\n  const fScore = new Map()\r\n  fScore.set(id(start), h(start))\r\n\r\n  while (openSet.size) {\r\n    //current := the node in openSet having the lowest fScore[] value\r\n    let current\r\n    let bestScore = Number.MAX_SAFE_INTEGER\r\n    for (let [nodeId, node] of openSet) {\r\n      const score = fScore.get(nodeId)\r\n      if (score < bestScore) {\r\n        bestScore = score\r\n        current = node\r\n      }\r\n    }\r\n    \r\n    if (current.c == goal.c) {\r\n      return reconstruct_path(cameFrom, current)\r\n    }\r\n    openSet.delete(id(current))\r\n    neighbours(current).forEach(neighbor => {\r\n      const neighborId = id(neighbor)\r\n      // d(current,neighbor) is the weight of the edge from current to neighbor\r\n      // tentative_gScore is the distance from start to the neighbor through current\r\n      const tentative_gScore = gScore.get(id(current)) + d(current, neighbor)\r\n      if (!gScore.has(neighborId) || tentative_gScore < gScore.get(neighborId)) {\r\n        // This path to neighbor is better than any previous one. Record it!\r\n        cameFrom.set(neighborId, current)\r\n        gScore.set(neighborId, tentative_gScore)\r\n        fScore.set(neighborId, gScore.get(neighborId) + h(neighbor))\r\n        if (!openSet.has(neighborId)){\r\n          openSet.set(neighborId, neighbor)\r\n        }\r\n      }\r\n    })\r\n  }\r\n  // Open set is empty but goal was never reached\r\n  return false\r\n}\r\n\r\nfunction tests() {\r\n  const assert = x => {\r\n    if(!x){\r\n      throw new Error(x)\r\n    }\r\n  }\r\n  function travel_test_case_generator(from, to, initialPass, expect) {\r\n    const res = A_Star({ c: from, hasPass: initialPass === 'yes'}, {c: to}, h).map(x => x.c)\r\n    try {\r\n    assert(res.length === expect.length)\r\n    assert(res.every((x, i) => x === expect[i]))\r\n    } catch (e) {\r\n      console.log('failed', from, to, initialPass, res, expect)\r\n      throw e\r\n    }\r\n    console.log('ok', `from ${from} to ${to} ${initialPass==='yes' ? 'with': 'without'} pass:`, res)\r\n  }\r\n  travel_test_case_generator( 'harrisburg' ,'harrisburg' ,'no'  ,['harrisburg'])\r\n  travel_test_case_generator( 'harrisburg' ,'harrisburg' ,'yes' ,['harrisburg'])\r\n  travel_test_case_generator( 'harrisburg' ,'philly'     ,'no'  ,['harrisburg', 'philly'])\r\n  travel_test_case_generator( 'harrisburg' ,'philly'     ,'yes' ,['harrisburg', 'philly'])\r\n  travel_test_case_generator( 'harrisburg' ,'nyc'        ,'no'  ,['harrisburg', 'philly', 'nyc'])\r\n  travel_test_case_generator( 'harrisburg' ,'nyc'        ,'yes' ,['harrisburg', 'philly', 'nyc'])\r\n  travel_test_case_generator( 'harrisburg' ,'paris'      ,'yes' ,['harrisburg', 'philly', 'nyc', 'paris'])\r\n  // travel_test_case_generator( 'harrisburg' ,'paris'      ,'no'  ,['harrisburg', 'philly', 'nyc', 'philly', 'harrisburg', 'passport', 'philly', 'nyc', 'paris'])\r\n  travel_test_case_generator( 'philly'     ,'philly'     ,'no'  ,['philly'])\r\n  travel_test_case_generator( 'philly'     ,'philly'     ,'yes' ,['philly'])\r\n  travel_test_case_generator( 'philly'     ,'nyc'        ,'no'  ,['philly', 'nyc'])\r\n  travel_test_case_generator( 'philly'     ,'nyc'        ,'yes' ,['philly', 'nyc'])\r\n  travel_test_case_generator( 'philly'     ,'paris'      ,'yes' ,['philly', 'nyc', 'paris'])\r\n  // travel_test_case_generator( 'philly'     ,'paris'      ,'no'  ,['philly', 'nyc', 'philly', 'harrisburg', 'philly', 'nyc', 'paris'])\r\n  travel_test_case_generator( 'nyc'        ,'paris'      ,'yes' ,['nyc', 'paris'])\r\n  travel_test_case_generator( 'nyc'        ,'paris'      ,'no'  ,['nyc', 'philly', 'harrisburg', 'philly', 'nyc', 'paris'])\r\n}\r\ntests()```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "How to start Dijkstra's algorithm on a graph stored in a dictionary\r\n                \r\nI want to implement Dijkstra's shortest-path algorithm, and I'm using a multi-level dictionary to represent my graph. For example:\n\n```\ng = {'A': {'C': 2}, 'B': {'B': 4, 'A': 2}}\n```\n\n\nI know how to access the inner dictionary using double ```\nfor```\n loops. But if the user inputs a starting point and an ending point, I face a problem searching for my starting point inside the dictionary using this ```\nfor```\n loop:\n\n```\nstart = input(\"Starting point : \")\nfor start in g:\n    print start\n```\n\n\nThis will instead print the the keys inside and it will always start from the first key and go through the graph. That's the opposite of what the algorithm says, which is to compare the source point with all the other nodes, and then the point after based on the weight with all the other nodes, and so on.\n\nCan you suggest a way to go about this? How can I start from node B instead of A for example instead of starting from the first key? \n\nAlso, do you recommend this dictionary method or is there a better way to it?\n    ", "Answer": "\r\nThe starting node should be a parameter of your dijkstra function. The function signature should be something like ```\ndef dijkstra(graph, start):```\n.\n\nTo iterate over the connected nodes, I'd use:\n\n```\nfor node, cost in graph[start].items():\n    print node, cost\n```\n\n\nAlso in dijkstra you should have a data structure to hold the nodes not yet explored decreasingly ordered by cost. Usually a priority queue is used.\n\nHere's a tip: The main loop inside the dijkstra function won't be a for loop, but a while loop checking there's still nodes to explore.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
{"Question": "Why isnt Dijkstra's algorithm's (for shortest path) time complexity the same as DFS?\r\n                \r\nCan't Dijkstra's algorithm be implemented using a DFS that keeps track of the length of the current path traveled and every time it arrives in an unvisited node it updates the length of the shortest path to that node, and if the node arrived at is already visited, update the length if the current length is smaller than the length in the node?\n\nWhich is just DFS, meaning the run time should be linear ( O(|V| + |E|) ).\n    ", "Answer": "\r\nLet's take this graph as example, where the search should start in a, and the target node is c:\n\n\n\nDFS\n\nAssuming children of a node are traversed in their lexical order, a DFS will visit the nodes in the order a, b, c, d, e\n\nIt will find these distances:\n\n```\n a: 0\n b: 5\n c: 13\n d: 8\n```\n\n\nThen from d it will see c again, and update it to 12\n\nNext is:\n\n```\n e: 1\n```\n\n\nFrom e it will see b again, and update it to 3. But then a DFS falls short of also seeing the impact this change has on nodes c and d.\n\nDijkstra's\n\nDijkstra's algorithm, on the other hand, will visit nodes in this order:\n\n```\n a: 0\n e: 1\n b: 3\n```\n\n\nThen it will take the edge with weight 5, but see that b was already visited, and ignore it. Then:\n\n```\n d: 6\n c: 10\n```\n\n\n... and the target was found with the correct distance.\n\nBFS\n\nJust to answer to your comment below: BFS will also not find the correct path, because BFS does not take the (total) weights into consideration; it just minimises the number of edges on a path.\n\nBFS will visit the nodes like this:\n\n```\na: 0\n\nb: 5\ne: 1\n\nc: 13\n```\n\n\n... and it will stop there. If you would not stop, but continue (with potential overwriting), then the process continues:\n\n```\nd: 8\n```\n\n\nThen it sees b from e, and updates:\n\n```\nb: 3\n```\n\n\nHowever, as b was already visited, BFS will not see the impact this change has on c and d.\n\nIt also sees c from d and updates c to 12. Then there is nothing more to do for BFS, and clearly the result is wrong.\n    ", "Knowledge_point": "Dijkstra's Algorithm", "Tag": "算法分析"}
