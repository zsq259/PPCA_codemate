{"Question": "DIrected Acyclic Graph shortest path within N steps\r\n                \r\nI have a problem of finding a shortest path in positively weighted Directed Acyclic Graph, but with the restriction of maximum number of N steps(edges in the path). It is assumed that the path exists. Additional property of the graph is that if the edge (i, j) is in the graph, then any edge (i, k) is also in the graph for i < k < j. I'm only interested in shortest path between start and end of the graph (after topological sorting).\n\nI know that there is an efficient algorithm for the shortest path in Directed Acyclic Graph in O(V+E) but it doesn't account for the steps limit. I can't think of any way to make it O((V+E)*N), but this would be ideal performance, as it should be good enough to handle graphs of 1000 nodes and 100 steps.\n\nFor example consider the following\ngraph.\n\nThe problem is to find the shortest path using at most k=3 steps (edges). The answer is 6 (path 1->4->5->6).\n    ", "Answer": "\r\nIt is actually ```\nO(N + M)```\n where ```\nN```\n is the number of vertices and ```\nM```\n is the number of edges.\nYou can find more information here: http://www.geeksforgeeks.org/shortest-path-for-directed-acyclic-graphs/\n\nFinding the path (I'm using the code from geeksforgeeks):\nInstead of ```\nint dist[V]```\n use ```\npair<int, int> dist[V]```\n. Initially ```\ndist[S] = {0, -1}```\n. So in this condition ```\nif (dist[i->getV()].first > dist[u].first + i->getWeight())```\n you need to set parent as ```\ndist[i->getV()] = {dist[u].first + i->getWeight(), u}```\n.\n\nThen use this recursive code to restore the path:\n\n```\nvoid restore(int v) { \n   if(dist[v].second == -1) return;\n   else answer.push_back(v);\n   if(v == START_POINT) return;\n   restore(dist[v].second);\n}\n```\n\n\nCall it with ```\nrestore(FINAL_POINT)```\n\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "Shortest path in Directed Acyclic Graph with small degree\r\n                \r\nGiven a weighted directed acyclic graph on ```\nn```\n vertices such that each vertex has indegree at most ```\n5```\n and outdegree at most ```\n5```\n. The nodes ```\n0, 1, ..., n - 1```\n are oriented like this \n\n```\n0   1   2   3   4```\n\n\n```\n5   6   7   8   9```\n\n\n```\n10  11  12  13  14```\n\n\n```\n...```\n\n\n```\nn-5 n-4 n-3 n-2 n-1```\n\n\nEdges can only be from a node in a row to some node in the next row. \n\nWe'll be given ```\nq```\n queries, asking the shortest path length from ```\nu```\n to ```\nv```\n. Here ```\nn```\n can be upto ```\n10^5```\n and ```\nq```\n upto ```\n10^4```\n. Weights are all positive integers. \n\nCan we do better than ```\nO(nq)```\n dynamic programming (which clearly doesn't work here)?  \n    ", "Answer": "\r\nThis seems too good to be true, sorry if it's not... You can get ```\nO(n)```\n (EDIT: ```\nO(n^(4/3))```\n) preprocessing and O(1) query.\n\nI'm considering that you know how to compute all the shortest distances between all the nodes in the graph in time ```\nO(n^2)```\n. (which is indeed possible, you seem to know that)\n\nDivide your graph in ```\nk```\n blocks, each containing ```\nn/(5*k)```\n rows. (the blocks should start and finish on complete rows, and two consecutive ones overlap on their respective first and last row)\n\nCompute the shortest path between all nodes (and in particular the first and last row) in each block: ```\nO((n/k)^2)```\n.\n\nThen you can consider the reduced graph containing only the nodes at the boundary between two blocks, with edges value equal to the shortest path between them that you've just computed.This reduced graph is of size ```\nO(k)```\n.\nCompute all the shortest paths in that graph in time ```\nO(k^2)```\n.\n\nTotal preprocessing time: ```\nO((n/k)^2 + k^2)```\n. Take ```\nk=sqrt(n)```\n, you get ```\nO(n)```\n preprocessing.\n\nThe query time is then ```\nO(1)```\n: take the 5 nodes at the end of u's block, the 5 at the start of v's block (if the blocks are different), you just need to compare the 25 possibilities for u->v \n\nEDIT\n\nOf course it's false. You actually have k blocks for which to compute the shortest paths, so the total complexity for that step is ```\nO(k*(n/k)^2)```\n. so the total is ```\nO(n^2/k + k^2)```\n, and the best choice for k is ```\nk=n^(2/3)```\n, which gives a total complexity of preprocessing of ```\nO(n^(4/3))```\n and total queries ```\nO(q)```\n\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "How to generate directed acyclic graph with long shortest path between two nodes in python\r\n                \r\nI want to compare several routing algorithms in terms of time needed to find the shortest path between two nodes in directed acyclic graph (DAG). \n\nI wrote code for the algorithms, but I am having problem to generate DAG for which it is computationally complex to find the shortest path. For example, when I generated 100-node DAG by following this approach, the graph was very connected and for any combination of source and destination nodes I got three-hop long route in the \"best\" case.\n\nAny idea how to overcome this problem?\n    ", "Answer": "\r\nLet your graph be a union of a path and a \"half complete graph\". A \"half complete graph\" (sorry for the silly name) is a graph, where you connect each node to all other nodes with higher id (eg. ```\n1 -> 2, 1 -> 3, 2 -> 3```\n). This guarantees a big number of edges (due to the \"half complete graph\") and a long shortest path because of the path. You can connect some of the nodes in the path to nodes in the \"half complete graph\".\n\nExample\n\nGraph with 14 nodes:\n\n```\n1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10\n11 - 12\n11 - 13\n11 - 14\n12 - 13\n12 - 14\n13 - 14\n2 - 13\n4 - 14\nYou can continue adding edges from nodes 1-9 to nodes 11-14\n```\n\n\nFind a path between 1 and 10.\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "Shortest paths for directed acyclic graphs\r\n                \r\nSo basically, I have an n by m array of float values and I'm trying to find the shortest path between the any of the 1st row of values, and any of the mth row of values. Node ```\n(i, j)```\n in the graph has children ```\n{(i, j+1), (i-1, j+1), i+1, j+1)}```\n for any node that is not on the edge ```\n(0 < i < n-1)```\n and is not in the bottom row ```\n(j < m-1)```\n. I'm looking for an algorithm to solve this specific problem in good time. My current line of thought revolves around an A* search, but let me know what you think.\n    ", "Answer": "\r\n\nList item\n\n\nThe dynamic solutions are O(NM) or O(M^2). And it can't go under that - here's a counterexample for any better solution. Let's say you want to find a path between the leftmost element of the first row and the leftmost element of the last row. Let's look at a matrix of this form:\n\n```\n10000000000000\n11000000000000\n11100000000000\n11110000000000\n11111000000000\n11111100000000\n11111110000000\n11111111000000\n11111110000000\n11111100000000\n11111000000000\n11110000000000\n11100000000000\n11000000000000\n10000000000000\n```\n\n\n\"1s\" are the elements you could potentially go through on the path from the source to the destination element. \"0s\" are the elements you can't pass through.\n\nThe number of \"1s\" is of NM/4 order, so O(NM) (actually, Min(NM, M^2), see below). So, an algorithm which reads each of the 1s in this matrix will be of >=O(NM) complexity.\n\nAn algorithm which doesn't read all the \"1s\" will on the other hand be incorrect.\n\nProof: Let the numbers in the matrix be weights. Pick a \"1\" the algorithm doesn't read. Change that 1 to 0.5. The algorithm fails for this input as the optimal path now goes through an element it never reads (as none of the elements it read the first time changed, it will read the same elements this time too, unless it's nondeterministic, in which case it's a random chance whether it will work, which makes it incorrect too).\n\nHowever, good O(NM) solutions should work just fine for 1000x1000 matrices (under a second). You can optimize it to Min(M^2, MN) if you only ever hit the elements you have to hit (for example, in my example matrix if the width is increased to 10000000, you don't have to read the added elements). Similarly, if the height is increased to 10000000, you don't have M^2 order reads because you don't go beyond the borders of the matrix. However, as you say both dimensions are very large, this is of little help I guess.\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "Shortest Path in a Directed Acyclic Graph with two types of costs\r\n                \r\nI am given a directed acyclic graph G = (V,E), which can be assumed to be topologically ordered (if needed). The edges in G have two types of costs - a nominal cost w(e) and a spiked cost p(e).\nThe goal is to find the shortest path from a node s to a node t which minimizes the following cost:\nsum_e (w(e)) + max_e (p(e)), where the sum and maximum are taken over all edges in the path.\nStandard dynamic programming methods show that this problem is solvable in O(E^2) time. Is there a more efficient way to solve it? Ideally, an O(E*polylog(E,V)) algorithm would be nice.\n---- EDIT -----\nThis is the O(E^2) solution I found using dynamic programming.\nFirst, order all costs p(e) in an ascending order. This takes O(Elog(E)) time.\nSecond, define the state space consisting of states (x,i) where x is a node in the graph and i is in 1,2,...,|E|. It represents \"We are in node x, and the highest edge weight p(e) we have seen so far is the i-th largest\".\nLet V(x,i) be the length of the shortest path (in the classical sense) from s to x, where the highest p(e) encountered was the i-th largest. It's easy to compute V(x,i) given V(y,j) for any predecessor y of x and any j in 1,...,|E| (there are two cases to consider - the edge y->x is has the j-th largest weight, or it does not).\nAt every state (x,i), this computation finds the minimum of about deg(x) values. Thus the complexity is O(|E| * sum_(x\\in V) deg(x)) = O(|E|^2), as each node is associated to |E| different states.\n    ", "Answer": "\r\nI don't see any way to get the complexity you want.  Here's an algorithm that I think would be practical in real life.\nFirst, reduce the graph to only vertices and edges between s and t, and do a topological sort so that you can easily find shortest paths in O(E) time.\nLet W(m) be the minimum sum(w(e)) cost of paths max(p(e)) <= m, and let P(m) be the smallest max(p(e)) among those shortest paths.  The problem solution corresponds to W(m)+P(m) for some cost m.  Note that we can find W(m) and P(m) simultaneously in O(E) time by finding a shortest W-cost path, using P-cost to break ties.\nThe relevant values for m are the p(e) costs that actually occur, so make a sorted list of those.  Then use a Kruskal's algorithm variant to find the smallest m that connects s to t, and calculate P(infinity) to find the largest relevant m.\nNow we have an interval [l,h] of m-values that might be the best.  The best possible result in the interval is W(h)+P(l).  Make a priority queue of intervals ordered by best possible result, and repeatedly remove the interval with the best possible result, and:\n\nstop if the best possible result = an actual result W(l)+P(l) or W(h)+P(h)\nstop if there are no p(e) costs between l and P(h)\nstop if the difference between the best possible result and an actual result is within some acceptable tolerance; or\nstop if you have exceeded some computation budget\notherwise, pick a p(e) cost t between l and P(h), find a shortest path to get W(t) and P(t), split the interval into [l,t] and [t,h], and put them back in the priority queue and repeat.\n\nThe worst case complexity to get an exact result is still O(E2), but there are many economies and a lot of flexibility in how to stop.\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "k-Edge Shortest Path in Positive Weighted Directed Acyclic Graph\r\n                \r\nI am given a graph, G = (V, E), that is positive weighted, directed, and acyclic.  I am to design an algorithm that runs in O(k(m + n)) for reporting a k-edge shortest path from s to t.  A k-edge shortest path is defined as a path from s to t with k edges and the total weight of the path must also be minimum for all paths from s to t.\n\nSince BFS can't be used alone to find shortest paths (unless the weights are equal), I think that the running time implies using BFS to find paths with k edges.  What's throwing me off is the k, as I think it implies performing BFS k times.  \n\nMy possible idea would be to run a BFS from the source to find all possible k-link paths.  By keeping track of the level along the way and storing the total path weight to each node when I add it to my queue, I can find all possible k-link paths and their weights. Obviously, if I encounter the destination at a lower level with lower path weight, there is no k-edge shortest path by definition.  What about cases where there are paths with more than k edges that are less total weight?  It also is not O(k(m + n)). Any helpful hints would be appreciated.\n    ", "Answer": "\r\nLet ```\nf[i][j]```\n be the i-link shortest path from ```\ns```\n to ```\nj```\n, initially we have\n\n```\nf[1][x] = e(s, x);\n```\n\n\nThen iterate ```\nK - 1```\n times, each round we use ```\nf[i][]```\n to compute ```\nf[i + 1][]```\n, which can be done by\n\n```\nfor each node v:\n    f[i + 1][v] = INF;\nfor each edge e[u][v]:\n    f[i + 1][v] = min(f[i + 1][v], f[i][u] + e[u][v]);\n```\n\n\nthus takes ```\nO(k(n + m))```\n.\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "Why doesn't the linear shortest path algorithm work for non-directed cyclic graphs?\r\n                \r\nI have the basic linear shortest path algorithm implemented in Python. According to various sites I've come across, this only works for directed acyclic graphs, including this, this, and this. However, I don't see why this is the case.\n\nI've even tested the algorithm against graphs with cycles and un-directed edges, and it worked fine.\n\nSo the question is, why doesn't the linear shortest path algorithm work for non-directed cyclic graphs? Side question, what is the name of this algorithm?\n\nFor reference, here is the code I wrote for the algorithm:\n\n```\ndef shortestPath(start, end, graph):\n    # First, topologically sort the graph, to determine which order to traverse it in\n    sorted = toplogicalSort(start, graph)\n\n    # Get ready to store the current weight of each node's path, and their predecessor\n    weights = [0] + [float('inf')] * (len(graph) - 1)\n    predecessor = [0] * len(graph)\n\n    # Next, relaxes all edges in the order of sorted nodes\n    for node in sorted:\n        for neighbour in graph[node]:\n\n            # Checks if it would be cheaper to take this path, as opposed to the last path\n            if weights[neighbour[0]] > weights[node] + neighbour[1]:\n\n                # If it is, then adjust the weight and predecessor\n                weights[neighbour[0]] = weights[node] + neighbour[1]\n                predecessor[neighbour[0]] = node\n\n    # Returns the shortest path to the end\n    path = [end]\n    while path[len(path) - 1] != start:\n        path.append(predecessor[path[len(path) - 1]])\n    return path[::-1]\n```\n\n\nEdit: As asked by Beta, here is the topological sort:\n\n```\n# Toplogically sorts the graph given, starting from the start point given.\ndef toplogicalSort(start, graph):\n    # Runs a DFS on all nodes connected to the starting node in the graph\n    def DFS(start):\n        for node in graph[start]:\n            if not node[0] in checked:\n                checked[node[0]] = True\n                DFS(node[0])\n        finish.append(start)\n\n    # Stores the finish point of all nodes in the graph, and a boolean stating if they have been checked\n    finish, checked = [], {}\n    DFS(start)\n\n    # Reverses the order of the sort, to get a proper topology; then returns\n    return finish[::-1]\n```\n\n    ", "Answer": "\r\nBecause you cannot topologically sort a graph with cycles (therefore undirected graphs are also out of the question as you can't tell which node should come before another).\n\nEdit: After reading the comments, I think that's actually what @Beta meant.\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "How to design linear dynamic programming algorithm for shortest path?\r\n                \r\nGiven a weighed directed acyclic graph (G) and a vertex S of G. I want to design a linear time dynamic programming algorithm to find the length of the shortest path between S and every other vertex of G.\n    ", "Answer": "", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "Time Complexity in a Given graph\r\n                \r\nGiven a directed acyclic graph with degree 'd' and length of shortest path between any 2 nodes is 'n', how much time is needed to find this path in terms of d and n?\n    ", "Answer": "\r\nIf you are talking about a specific path between two node x and y:\nit's O(d^n), as in any node, in the path, you have to 'take' up until d different pathes.\nAnd you have to repeat this process up until n times.\nSince it's exponential in n, this time analysis is only useful for very small n.\nMostly, you will prefer to look at this as running DFS on your graph, resulting in O(E+V) (this size of your graph)\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "What is the intuition behind topological sort to find the shortest distance in weighted DAG?\r\n                \r\n```\n#include<iostream>\n#include <list>\n#include <stack>\n#include <limits.h>\n#define INF INT_MAX\nusing namespace std;\n \nclass AdjListNode\n{\n        int v;\n        int weight;\n    public:\n        AdjListNode(int _v, int _w)\n        {\n            v = _v;\n            weight = _w;\n        }\n        int getV()\n        {\n            return v;\n        }\n        int getWeight()\n        {\n            return weight;\n        }\n};\n \n// Class to represent a graph using adjacency list representation\nclass Graph\n{\n        int V; // No. of vertices'\n \n        // Pointer to an array containing adjacency lists\n        list<AdjListNode> *adj;\n \n        // A function used by shortestPath\n        void topologicalSortUtil(int v, bool visited[], stack<int> &Stack);\n    public:\n        Graph(int V); // Constructor\n \n        // function to add an edge to graph\n        void addEdge(int u, int v, int weight);\n \n        // Finds shortest paths from given source vertex\n        void shortestPath(int s);\n};\n \nGraph::Graph(int V)\n{\n    this->V = V;\n    adj = new list<AdjListNode> [V];\n}\n \nvoid Graph::addEdge(int u, int v, int weight)\n{\n    AdjListNode node(v, weight);\n    adj[u].push_back(node); // Add v to u's list\n}\n \nvoid Graph::topologicalSortUtil(int v, bool visited[], stack<int> &Stack)\n{\n    // Mark the current node as visited\n    visited[v] = true;\n \n    // Recur for all the vertices adjacent to this vertex\n    list<AdjListNode>::iterator i;\n    for (i = adj[v].begin(); i != adj[v].end(); ++i)\n    {\n        AdjListNode node = *i;\n        if (!visited[node.getV()])\n            topologicalSortUtil(node.getV(), visited, Stack);\n    }\n \n    // Push current vertex to stack which stores topological sort\n    Stack.push(v);\n}\n \nvoid Graph::shortestPath(int s)\n{\n    stack<int> Stack;\n    int dist[V];\n \n    // Mark all the vertices as not visited\n    bool *visited = new bool[V];\n    for (int i = 0; i < V; i++)\n        visited[i] = false;\n \n    // Call the recursive helper function to store Topological Sort\n    // starting from all vertices one by one\n    for (int i = 0; i < V; i++)\n        if (visited[i] == false)\n            topologicalSortUtil(i, visited, Stack);\n \n    // Initialize distances to all vertices as infinite and distance\n    // to source as 0\n    for (int i = 0; i < V; i++)\n        dist[i] = INF;\n    dist[s] = 0;\n \n    // Process vertices in topological order\n    while (Stack.empty() == false)\n    {\n        // Get the next vertex from topological order\n        int u = Stack.top();\n        Stack.pop();\n \n        // Update distances of all adjacent vertices\n        list<AdjListNode>::iterator i;\n        if (dist[u] != INF)\n        {\n            for (i = adj[u].begin(); i != adj[u].end(); ++i)\n                if (dist[i->getV()] > dist[u] + i->getWeight())\n                    dist[i->getV()] = dist[u] + i->getWeight();\n        }\n    }\n \n    // Print the calculated shortest distances\n    for (int i = 0; i < V; i++)\n        (dist[i] == INF) ? cout << \"INF \" : cout << dist[i] << \" \";\n}\n \n// Driver program to test above functions\nint main()\n{\n    // Create a graph given in the above diagram.  Here vertex numbers are\n    // 0, 1, 2, 3, 4, 5 with following mappings:\n    // 0=r, 1=s, 2=t, 3=x, 4=y, 5=z\n    Graph g(6);\n    g.addEdge(0, 1, 5);\n    g.addEdge(0, 2, 3);\n    g.addEdge(1, 3, 6);\n    g.addEdge(1, 2, 2);\n    g.addEdge(2, 4, 4);\n    g.addEdge(2, 5, 2);\n    g.addEdge(2, 3, 7);\n    g.addEdge(3, 4, -1);\n    g.addEdge(4, 5, -2);\n \n    int s = 1;\n    cout << \"Following are shortest distances from source \" << s << \" \\n\";\n    g.shortestPath(s);\n \n    return 0;\n}\n```\n\nWhat is the intuition behind the topological sort to find the shortest path from a source vertex to all other vertices in a weighted directed acyclic graph?\nI know the topological sort returns the ordering of vertices in increasing order of their in-degree but unable to figure out how it is helping to find the shortest path.\n    ", "Answer": "", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "Shortest Path For A Dag\r\n                \r\nI have a graph with an s and t vertex that I need to find the shortest path between. The graph has a lot of special properties that I would like to capitalize on:\n\n\nThe graph is a DAG (directed acyclic graph).\nI can create a topological sort in O(|V|) time, faster than the traditional O(|V + E|).\nWithin the topological sort, s is the first item in the list and t is the last.\n\n\nI was told that once I have a topological sort of the vertices I could find the shortest path faster than my current standard of Dijkstra's Uniform Cost, but I cannot seem to find the algorithm for it.\n\nPseudo code would be greatly appreciated.\n\nEDITS:\nAll paths from s to t have the same number of edges.\nEdges have weights.\nI am searching for lowest cost path.\n    ", "Answer": "\r\nI'm going to go against my intuition and assume this isn't homework. You have to take advantage of the information that a topological ordering gives you. Whenever you examine the node n in a topological ordering, you have the guarantee that you've already traversed every possible path to n. Using this it's clear to see that you can generate the shortest path with one linear scan of a topological ordering (pseudocode):\n\n```\nGraph g\nSource s\ntop_sorted_list = top_sort(g)\n\ncost = {} // A mapping between a node, the cost of its shortest path, and \n          //its parent in the shortest path\n\nfor each vertex v in top_sorted_list:\n  cost[vertex].cost = inf\n  cost[vertex].parent = None\n\ncost[s] = 0\n\nfor each vertex v in top_sorted_list:\n   for each edge e in adjacensies of v:\n      if cost[e.dest].cost > cost[v].cost + e.weight:\n        cost[e.dest].cost =  cost[v].cost + e.weight\n        e.dest.parent = v\n```\n\n\nNow you can look up any shortest path from s to a destination. You'd just need to look up the destination in the cost mapping, get it's parent,  and repeat this process until you get a node whose parent is s, then you have the shortest path.\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "How to find the shortest directed cycle in a directed graph?\r\n                \r\nFrom https://algs4.cs.princeton.edu/42digraph/\n\n\n  \n  Shortest directed cycle. Given a digraph, design an algorithm to find a directed cycle with the minimum number of edges (or report that\n  the graph is acyclic). The running time of your algorithm should be\n  proportional to E V in the worst case.\n  \n\n\nThe solution is found here: https://algs4.cs.princeton.edu/42digraph/ShortestDirectedCycle.java.html\n\n```\npublic ShortestDirectedCycle(Digraph G) {\n    Digraph R = G.reverse();\n    length = G.V() + 1;\n    for (int v = 0; v < G.V(); v++) {\n        BreadthFirstDirectedPaths bfs = new BreadthFirstDirectedPaths(R, v);\n        for (int w : G.adj(v)) {\n            if (bfs.hasPathTo(w) && (bfs.distTo(w) + 1) < length) {\n                length = bfs.distTo(w) + 1;\n                cycle = new Stack<Integer>();\n                for (int x : bfs.pathTo(w))\n                    cycle.push(x);\n                cycle.push(v);\n            }\n        }\n    }\n}\n```\n\n\nThe solution makes sense to me, except for the first line ```\nG.reverse()```\n. Why? Does it have anything to do with Topological sort?\n\nThere are quite a few questions on SO regarding finding all cycles in a Digraph, but I'm assuming there's a better way than finding all cycles and comparing their lengths. There are some questions regarding finding the shortest directed cycle, but none has an acceptable answer.\n\nHow can I find the shortest cycle in a Directed, Weighted Graph?\n\nFind the Shortest Cycle in Graph\n\nFinding shortest cycles in directed or undirected graph (this one is for undirected graph)\n\nI also found a paper that uses BFS, but the pseudocode presented can't be used to reconstruct the path, only to find the length of the shortest cycle.\n    ", "Answer": "\r\n```\nG.reverse()```\n is a digraph that's the same as ```\nG```\n except that each edge is reversed; so, for example, if ```\nG```\n has an edge from ```\nv```\n to ```\nw```\n, then ```\nG.reverse()```\n has an edge from ```\nw```\n to ```\nv```\n.\n\nSince ```\nbfs```\n is taken from ```\nG.reverse()```\n and ```\nv```\n, ```\nbfs.hasPathTo(w)```\n means \"whether ```\nG```\n has a path from ```\nw```\n to ```\nv```\n\", and ```\nbfs.distTo(w)```\n means \"the length of ```\nG```\n's path from ```\nw```\n to ```\nv```\n\". (If ```\nbfs```\n were taken from ```\nG```\n instead of ```\nG.reverse()```\n, it would detect paths going the other way.)\n\nSo the cycle-finding algorithm it's using is: for each edge (```\nv```\n,```\nw```\n) in ```\nG```\n, test whether ```\nG```\n has a path from ```\nw```\n back to ```\nv```\n.\n\nTopological sorting is not involved.\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "Weighted Directed Acyclic Graphs: algorithm to find edge weights such that they define a distance function?\r\n                \r\nI have this technical problem that can be formuated with a Directed Acyclic Graph (DAG).\nNodes represent events (with unknown timing), with directed edges encoding the relation ship: \"I'm younger than you/I happened before you\".\n\nI need to estimate edge weights (i.e. \"dynamic weights\") such that the Weighted DAG (WDAG) implies a distance function on the DAG. In other words the sum of weights for paths between nodes A and B should be equal for all paths.\n\nThis is an undetermined problem, even if the weights are integers (same underlying reason that topological sorting is not unique, I suppose). In all generality, the edge weights, which represent timeintervals between nodes/events, are real numbers. Therefore I'm introducing some preset objective function C=J(WDAG) on the weighted DAG, here unspecified.\n\nMy question is: is there an algorithm that distributes positive definite weights on the WDAG, subject to the constraint 1) that the weights form a distance function of the DAG and 2) minimizing the objective function cost C.\n\nThis seems unrelated to the shortest-path or minimum-spanning-tree problems classically associated to WDAG's. Any ideas to a formal or heuristic solution to the above problem?\n\nRegards,\n\nStephane\n    ", "Answer": "\r\nI think all you need is topological sorting.\n\n\nSort the nodes according to a topological sort.  \nDistribute them in the [0,1] interval in the order you got.  \nNow the distance of node-pairs on the [0,1] line will give you the weight of the edge connecting them.\n\n\nThis is one possible solution.  If you have more constraints on the weights than what you describe in the question, the problem might be more difficult.\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "Shortest acyclic path on directed cyclic graph with negative weights/cycles\r\n                \r\nI have a directed graph which has cycles.\nAll edges are weighted, and the weights can be negative.\nThere can be negative cycles.\n\nI want to find a path from s to t, which minimizes the total weight on the path.\nSure, it can go to negative infinity when negative cycles exist.\nBut what if I disallow cycles in the path (not in the original graph)?\nThat is, once the path leaves a node, it can not enter the node again.\n\nThis surely avoids the negative infinity problem,\nbut surprisingly no known algorithm is found by a search on Google.\nThe closest is Floyd–Warshall algorithm, but it does not allow negative cycles.\n\nThanks a lot in advance.\n\nEdit: I may have generalized my original problem too much. Indeed, I am given a cyclic directed graph with nonnegative edge weights. But in addition, each node has a positive reward too. I want to find a simple path which minimizes (sum of edge weights on the path) - (sum of node rewards covered by the path). This can be surely converted to the question that I posted, but some structure is lost. And some hint from submodular analysis suggests this motivating problem is not NP-hard. Thanks a lot\n    ", "Answer": "\r\nI will copy my answer from this question on the CS-theory Stackexchange:\n\nPaths with no repeated vertices are called simple-paths, so you are looking for the shortest simple-path in a graph with negative-cycles.\nThis can be reduced from the longest-path problem.  If there were a fast solver for your problem, then given a graph with only positive edge-weights, negating all the edge-weights and running your solver would give the longest path in the original graph.\nThus your problem is NP-Hard.\n\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "Shortest Paths with Resource Constraints\r\n                \r\nI have a directed acyclic graph and need to find the shortest paths with resource constraints. My constraint is that the paths selected must have a minimum number of a set resource consumed.\n\nCurrently I am using Yen's K Shortest Path algorithm to calculate K shortest paths and then only accept those that satisfy my constraint. The issue here is in guessing K, as if it is incorrectly chosen, it is possible that no feasible paths will be found.\n\nI have found quite a lot of literature on this topic, this provides a good overview I think. However, I am struggling to make sense of it and find a concise algorithm that is able to be implemented (I am using Python, however any clear algorithmic ideas would be great). \n\nI understand that this problem is NP-Complete, and as such I am interested in any good approximation algorithms as well as exact approaches.\n\nAnyone have any good recommendations?\n    ", "Answer": "\r\nWhat you can do is to transform your graph ```\n(V,E)```\n into ```\n(V',E')```\n where \n\n\n```\nP(v)```\n is the price of the original node ```\nv```\n\n```\nR```\n is the maximum resource use.\n```\nV' = {(v,k) | v in V and k in [0..R]}```\n\n```\nE'((v,k),(w,l)) = E(v,w) and k+P(w)=l```\n\n\n\nThen you do a dijkstra search from ```\n(v0,P(v0))```\n. If it was possible to find a path to ```\nv1```\n, given the limit, the shortest distance to it, will be the shortest among the ```\n(v1,k)```\n vertices.\n\nYou obviously don't create the actual expanded graph. What would be going on in your modified dijkstra is that in addition to the distance so far, you would keep the resource use so far as well. You would only follow a path if it didn't exceed the limit. And instead of keeping a ```\ndist[v]```\n you would keep ```\ndist[v,k]```\n representing the shortest path to v so far, using exactly ```\nk```\n resources.\n\nIf your resource bound is very large, this can potentially grow as big. Hence the NP completeness. However if your resource bound is small, or you don't mind rounding of to nearest 10, 100 or 1000, it will run in fast polynomial time.\nEspecially if you implement the optimization of stopping once you've reached a useable ```\n(v1,k)```\n.\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "Efficient shortest path in DAG with Python's graph-tool\r\n                \r\nTask: I want to compute a shortest path between a source and target node in a DAG (directed acyclic graph) using Python's ```\ngraph-tool```\n efficiently. My DAG has negative weights.\n\nIn theory, this is a computationally \"easy\" problem (i.e., O(V + E)) by first computing a topological sorting of the graph and then visiting and updating parent nodes and distances (e.g. as discussed here).\n\nHow can I implement this efficiently using ```\ngraph-tool```\n? \n\nMy failed attempts so far:\n\n\nmanually implementing the theoretically efficient algorithm in Python. Since I have to loop over each vertex in the graph, however, this becomes unacceptably slow\nusing ```\nshortest_path```\n function from ```\ngraph-tool```\n to call the Dijkstra routine from ```\nBoost Graph Library```\n would have an acceptable running time, but doesn't fully exploit the DAG structure and doesn't work for negative weights anyways \nusing ```\nshortest_path```\n  to call ```\nBellman-Ford```\n returns a correct shortest path, but doesn't exploit the DAG structure and is too slow (O(VE)).\n\n\nThe efficient DAG shortest path algorithm is implemented as ```\ndag_shortest_paths```\n in the underlying Boost Graph Library. Is there any way of accessing this function through ```\ngraph-tool```\n or any other way of computing this efficiently with ```\ngraph-tool```\n?\n    ", "Answer": "\r\nThis functionality has been added to the git version of graph-tool:\n\nhttps://git.skewed.de/count0/graph-tool/commit/012787ecde818efc2b893ad0d8aff819b8deb6ca\n\nAn optional parameter ```\ndag=True```\n can now  be passed to ```\nshortest_path()```\n that achieves what you want.\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "DAG shortest path\r\n                \r\nGiven a directed acyclic graph ```\nG = (V,E)```\n and two distinguished vertices ```\ns```\n and ```\nt```\n. Both the edges and vertices are assigned real-valued weights. The weight of a path is defined as the sum of all the edges and vertices on the path. The problem is to find a shortest weighted simple path from ```\ns```\n to ```\nt```\n.\n\n(a)  Design a dynamic programming algorithm and briefly describe it.\n\n(b)  Design a greedy algorithm and briefly describe it.\n\n(c)  Provide upper and lower bounds of one of your algorithms as tight as possible.\n\nHow do I do this? Can Dijkstra be used?\n    ", "Answer": "\r\nI think for greedy algorithm Dijkstra's can be used. I dont know about the rest, sorry mate.\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "convert cyclic to acyclic graph\r\n                \r\nI want to convert a cyclic graph into an acyclic graph. Is there an pseudocode that can do this? I did try to search but most of them returned where mathematical based on markov chain or research articles.\nI want to write a program to do it and any directions will be useful. for example consider this below graph.\n```\nA->B\nB->C\nC->A\n```\n\nI saw a solution in an MIT lecture but the lecture skimmed over it with reference to something taught earlier and couldn't catch it. In short it kind of replicates the nodes in layers in a way that the end graph denotes a DAG but conveys the same path information.\n[See 46:59]\nhttps://www.youtube.com/watch?v=OQ5jsbhAv_M\nEdit:\nThere is an explanation of turning cyclic graphs into dags in this MIT recitation at 36:57\nhttps://youtu.be/IFrvgSvZA0I\nSe also Wikipedia : cycle and forest\nEdit:\nI want to apply dynamic programming over a problem which is a cyclic graph e.g) say shortest path problem ```\nDelta(S,D) where S-> Source node and D->Destination node```\n. Since DP over cyclic graph is infinite algorithm, we first need to convert the cyclic graph into acyclic graph and then apply the dynamic programming technique over it.\n    ", "Answer": "\r\nI believe you pointed out the wrong video, here it is (46:59): https://www.youtube.com/watch?v=OQ5jsbhAv_M\n\nThe idea exposed here, is to make several copies of the graph and to arrange them into layers. Each one represents the state of the graph at a given time, and for every edge traversed you go down by one layer.\nI did not find pseudo-code for this, but the way of doing this is detailed here: https://cstheory.stackexchange.com/questions/14591/combinatorics-of-bellman-ford-or-how-to-make-cyclic-graphs-acyclic\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "How to minimize total cost of shortest path tree\r\n                \r\nI have a directed acyclic graph with positive edge-weights. It has a single source and a set of targets (vertices furthest from the source). I find the shortest paths from the source to each target. Some of these paths overlap. What I want is a shortest path tree which minimizes the total sum of weights over all edges. \n\nFor example, consider two of the targets. Given all edge weights equal, if they share a single shortest path for most of their length, then that is preferable to two mostly non-overlapping shortest paths (fewer edges in the tree equals lower overall cost).\n\nAnother example: two paths are non-overlapping for a small part of their length, with high cost for the non-overlapping paths, but low cost for the long shared path (low combined cost). On the other hand, two paths are non-overlapping for most of their length, with low costs for the non-overlapping paths, but high cost for the short shared path (also, low combined cost). There are many combinations. I want to find solutions with the lowest overall cost, given all the shortest paths from source to target.\n\nIn other words, I want the shortest, shortest-path-trees.\n\nDoes this ring any bells with anyone? Can anyone point me to relevant algorithms or analogous applications?\n\nCheers!\n    ", "Answer": "\r\nThis problem (Steiner Tree) is NP-hard and max SNP-complete, so there are neither polynomial-time algorithms nor PTAS (arbitrarily close approximations) unless P = NP.\n\nThe MST can give a weight arbitrarily worse than optimal, unless you know some special feature of your graph (e.g. the graph is planar, or at least that the weights obey the triangle inequality).  For example, if you have K_1,000,000,001 with all edge weights 1 and only one target, the optimal solution has weight 1 and the MST has weight 1,000,000,000.\n\nIf you assume that all edges between targets and all edges between the source and each target exist, you can still overshoot by an arbitrary factor.  Consider the above example, but change the edge weight between the target and source to 2,000,000,000,000,000,000 (you're still off by a factor of a billion from optimal).\n\nOf course you can transform the graph to 'remove' edge weights that are high in time O(E) or so by traversing the graph.  This plus a MST of the set of targets and source gives an approximation ratio of 2.\n\nBetter approximation ratios exist.  Robins & Zelikovsky have a polynomial-time algorithm that is never more than 54.94% worse than optimal:\nhttp://www.cs.virginia.edu/~robins/papers/soda2000_camera.pdf\n\nChlebik & Chlebikova show that approximating closer than 1.05% is NP-hard: The Steiner tree problem on graphs: Inapproximability results\n(doi 10.1.1.4.1339)\n\nIf your graph is planar, the situation is better.  There's a fast algorithm that gives an arbitrarily-close approximation due to Borradaile, Kenyon-Mathieu & Klein (building on Erickson, Monma, & Veinott): An O(nlogn) approximation scheme for Steiner tree in planar graphs\n(doi 10.1.1.133.4154)\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "Recursive & dynamic programming algorithm to find shortest path (length and actual path) from an arbitrary node to another\r\n                \r\nI was hoping for some help / direction on the following question, on which I am struggling. \nIf you have any suggestions in re-wording the question, just leave a comment and I'll go ahead and change it.\n\nTake a weighted directed acyclic graph.\n\n(a) Recursive algorithm that finds shortest path from node x to node t (algorithm should try all outgoing edges and determine which to proceed on).\n\n```\nI was thinking something along the lines of breadth first search?\nMaybe, another way, a recursive form of dijkstras? However, I'm having \ndifficulty thinking of a recursive way to do this.\n```\n\n\n(b) Make an iterative dynamic programming version of the recursive algorithm and indicate how you find the actual path (rather than just the length of the path).\n\n```\nThe difference here would obviously be that it is iterative. I'm also  \n guessing we would have to keep track of the length of the path / the \n path itself (the nodes) in an array, and refer to it as we iterate.\n```\n\n    ", "Answer": "\r\nLet ```\nw(i,j)```\n be the weight of the edge between ```\ni```\n to ```\nj```\n, for any given edge ```\n(i,j)```\n.\n\nThe recursive relation that can find the shortest path can be denoted as:\n\n```\nD(u,u) = 0\nD(u,v) = min{ D(u,i) + w(i,v) | for each node i such that the edge (i,v) exists } \n```\n\n\nThe shortest path is then denoted by ```\nD(x,t)```\n.\n\nNote that if there is a negative cycle - the algorithm will be stuck in an infinite loop (since ```\nD(u,i) = -infinity```\n for this cycle), so for correctness of it, we have to assume no such cycle exists.\n\nAn iterative Dynamic Programming implementation to this relation is basically the Bellman-Ford algorithm.\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "Find all paths without specifing end node?\r\n                \r\nI'm trying to do a Depth First search to find a list of all paths and then identify the shortest and longest paths.\n\nThe python documentation (https://www.python.org/doc/essays/graphs/)  has the following, which requires an end node:\n\n```\ndef find_all_paths(graph, start, end, path=[]):\n    path = path + [start]\n    if start == end:\n        return [path]\n    if not graph.has_key(start):\n        return []\n    paths = []\n    for node in graph[start]:\n        if node not in path:\n            newpaths = find_all_paths(graph, node, end, path)\n            for newpath in newpaths:\n                paths.append(newpath)\n    return paths \n```\n\n\nMy question is how can I find all paths in a (directed acyclic) graph without specifying the end node? My start node would remain the same at all times.\n\nI could use a for loop at the start and iterate through the nodes. but this doesn't feel like the most efficient way of doing so because if I could be using the same path to revisit a node which would be a waste of compute time. \n\n```\nfor node in nodeList:\n    find_all_paths(graph, 0, node) \n```\n\n    ", "Answer": "\r\nYour depth-first search code can be modified to find all paths to all end nodes with just a few tweaks.\n\nFirst, drop the ```\nend```\n parameter, and the base case where ```\nstart == end```\n. Then, simply add ```\npath```\n to ```\npaths```\n before starting the recursive steps. In the recursive call, don't try to pass ```\nend```\n any more.\n\nThat's it:\n\n```\ndef find_all_paths(graph, start, path=[]):\n    path = path + [start]\n    if not graph.has_key(start):\n        return [path]\n    paths = [path]\n    for node in graph[start]:\n        if node not in path:\n            newpaths = find_all_paths(graph, node, path)\n            for newpath in newpaths:\n                paths.append(newpath)\n    return paths\n```\n\n\nNote that you can do this a bit more efficiently as a recursive generator, rather than building up a big list of paths (I've also modified the special check for a node not in the graph: using the ```\nnot in```\n operator is better than using ```\ndict.has_key```\n):\n\n```\ndef find_all_paths(graph, start, path=[]):\n    path = path + [start]\n    yield path\n    if start not in graph:\n        return\n    for node in graph[start]:\n        if node not in path:\n            yield from find_all_paths(graph, node, path)\n```\n\n\nNote that ```\nyield from```\n is only available in Python 3.3 and later. If you're using an earlier version, use an explicit loop:\n\n```\nfor newpath in find_all_paths(graph, node, path):\n    yield newpath\n```\n\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "Shortest path in a dag but must go through m type-A edges and n type-B edges\r\n                \r\nThere is a dag (directed acyclic graph) with a weight on each edge, and each edge has a type, either type-A or type-B\n\nFor example:\n\n\n\n(red edges mean type-A, and black edges mean type-B edges)\n\nThe problem is defined as following:\n\n```\ngiven two vertices s, t, find a shortest path between these two vertices\nsubject to the usage of m type-A edges and n type-B edges,\nor report no such path exists\n```\n\n\ne.g., Given A, D and m = 1, n = 2, find the shortest path between A and D and meanwhile meet the constraint\n\nin this case, the shortest path is A, B, C, D and the shortest path length is 7\n\nOne idea had popped on my head, first, we do the topological sort, \nthen using the topological order as a examination sequence, keep tracking the shortest path length and the traversed edges starting from A\n\nThe bookkeeping record will look like this,\n\n[Number_of_Type_A, Number_of_Type_B, Shortest_length, Predecessor]\n\nand keep considering the incoming edge just like the usual way to find a shortest path in a dag\n\ne.g.\n\n\n\n(I missed a 3 on the edge (B,D) )\n\nconsider A:\n\n```\n[0, 0, 0, NIL]\n```\n\n\nconsider B: (1 incoming edge)\n\n```\n[1, 0, 1, A]\n```\n\n\nconsider C: (2 incoming edge)\n\n```\n[1, 1, 3, B] and \n[1, 0, 1, A]\n```\n\n\nconsider D: (2 incoming edge)\n\n```\n[1, 2, 7, C] and\n[1, 1, 5, C] and \n[2, 0, 4, B]\n```\n\n\nSince there is a path using 1 type-A and 2 type-B edges, and the shortest path and length can be found on the record and tracking back the predecessors\n\nso this is it.\n\n( The time complexity is...O(V+E)? I think maybe bigger than this, but I have no idea how to analyse it)\n\nI am not sure this is a right way to solve this problem.\n\nIs there any other way to solve this problem? and what is this problem called in general?\n\nThanks for the help!\n    ", "Answer": "", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "A* search in neo4j\r\n                \r\nI want to search for shortest path in the directed acyclic graph with neo4j. I have graph that looks similar to this:\n\n\nI want to find path starting from ```\nRoot```\n down to ```\nLayer 3```\n. At each layer I have different set of properties and I can calculate weight using this properties and user input. I need to find all shortest paths with minimal dynamic weight using A* or another search algorithm (it is possible to have several paths with equal weights). Is it possible with neo4j and cypher or gremlin? \n\nI don't want to use embedded version because my project is written in python, so I can't use java library that as I know can do this.\n    ", "Answer": "\r\nAs of now, Cypher does not allow you to pass in function e.g. your cost function. Adding this as feature must be decided very carefully as injecting runnable code by a query language has some security concerns.\n\nThat said what you can do now: create a unmanaged extension to the Neo4j server. Inside your unmanaged extension you make use of the the provided graph algorithms. Using JAX-RS parameter you provide data to identify the start and end node of your traversal and let graph algos do the dirty work.\n\nYou might want to take a look at https://github.com/sarmbruster/unmanaged-extension-archetype, this is a minimalistic sample project using ```\ngradle```\n as a build system.\n\nHowever, the sketched idea involved Java coding for the server side part. Client side you can use whatever stack you like.\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "How to load a TIFF image like a graph in C++ BOOST\r\n                \r\nI want do load a tiff image (GEOTIFF with pixels with float values) like graph in boost C++ (i'm a newbie in C++). My goal is use the bidirectional Dijkstra from source A to target B to get more performance.\n\n```\nBoost:GIL load tiif images:\nstd::string filename( \"raster_clip.tif\" );\nrgb8_image_t img;\nread_image( filename, img, tiff_tag() ); \n```\n\n\nBut how convert to Boost graph? I am reading the documentation and looking for examples but I have not yet been able to implement it.\n\nSimilar questions and examples that i found:\n\nShortest path graph algorithm help Boost;\n\nhttp://www.geeksforgeeks.org/shortest-path-for-directed-acyclic-graphs/\n\nI am currently using the scikit-image library and use skimage.graph.route_through_array function to load graph with array in python. I use GDAL to get an array by load image as suggested by @ustroetz in this example Here:\n\n```\n    raster = gdal.Open(\"raster.tiff\")\n    band = raster.GetRasterBand(1)\n    array = band.ReadAsArray()\n```\n\n\nExample of TIFF (was converted to PNG after upload) is: \n  \n    ", "Answer": "\r\nOk, so read the PNG:\n\n\n  I've cropped the whitespace border since it wasn't consistent anyways\n\n\nReading And Sampling The Image\n\n```\nusing Img = boost::gil::rgb8_image_t; // gray8_image_t;\nusing Px  = Img::value_type;\n\nImg img;\n//boost::gil::png_read_image(\"graph.png\", img);\nboost::gil::png_read_and_convert_image(\"graph.png\", img);\nauto vw = view(img);\n```\n\n\nNext up, make sure we know the dimensions and how to address the center pixels for each cell:\n\n```\ndouble constexpr cell_w = 30.409;\ndouble constexpr cell_h = 30.375;\n\nauto pixel_sample = [=](boost::array<size_t, 2> xy) -> auto& {\n    return vw((xy[0]+.5)*cell_w, (xy[1]+.5)*cell_h);\n};\n\nauto const w= static_cast<size_t>(img.dimensions()[0] / cell_w);\nauto const h= static_cast<size_t>(img.dimensions()[1] / cell_h);\n```\n\n\nConstructing The Graph\n\nNow let's make the graph. For this task a grid-graph seems in order. It should be ```\nw×h```\n and not wrap around at the edges (if it should, change ```\nfalse```\n to ```\ntrue```\n):\n\n```\nusing Graph = boost::grid_graph<2>;\nGraph graph({{w,h}}, false);\n```\n\n\nWe want to attach weights at each edge. We can either use an old-fashioned external property map that's sized up-front:\n\n```\nstd::vector<double> weight_v(num_edges(graph));\nauto weights = boost::make_safe_iterator_property_map(weight_v.begin(), weight_v.size(), get(boost::edge_index, graph));\n```\n\n\nAlternatively, we can use a dynamically allocating and growing property-map:\n\n```\nauto weights = boost::make_vector_property_map<float>(get(boost::edge_index, graph));\n```\n\n\nAs a bonus, here's the equivalent approach using an associative property-map:\n\n```\nstd::map<Graph::edge_descriptor, double> weight_m;\nauto weights = boost::make_assoc_property_map(weight_m);\n```\n\n\nEach of these are drop-in compatible and the choice is yours.\n\nFilling The Graph\n\nWe simply iterate all edges, setting the cost from the colour difference:\n\n```\nBGL_FORALL_EDGES(e, graph, Graph) {\n    auto& from = pixel_sample(e.first);\n    auto& to   = pixel_sample(e.second);\n\n    // compare RED channels only\n    auto cost = std::abs(from[0] - to[0]);\n    put(weights, e, cost);\n}\n```\n\n\n\n  Note Consider normalizing weight to e.g. ```\n[0.0, 1.0)```\n using the actual bit-depth of the source image\n\n\nLet's create a verification TIF so we can actually see where the samples were taken in the image:\n\n```\n{\n    BGL_FORALL_VERTICES(v, graph, Graph) {\n        pixel_sample(v) = Px(255, 0, 123); // mark the center pixels so we can verify the sampling\n    }\n\n    boost::gil::tiff_write_view(\"/tmp/verification.tif\", const_view(img));\n}\n```\n\n\nThe ```\nverification.tif```\n ends up like (note the center pixel for each cell):\n\n\n\nBonus: Visualize The Grid Graph\n\nLet's write it to a Graphviz file:\n\n```\n{\n    auto calc_color = [&](size_t v) {\n        std::ostringstream oss;\n        oss << std::hex << std::noshowbase << std::setfill('0');\n\n        auto const& from = pixel_sample(vertex(v, graph));\n        oss << \"#\" << std::setw(2) << static_cast<int>(from[0])\n            << std::setw(2) << static_cast<int>(from[1])\n            << std::setw(2) << static_cast<int>(from[2]);\n\n        return oss.str();\n    };\n\n    write_dot_file(graph, weights, calc_color);\n}\n```\n\n\nThis calculates the color from the same sample pixel and uses some Graphviz-specific magic to write to a file:\n\n```\ntemplate <typename Graph, typename Weights, typename ColorFunction>\nvoid write_dot_file(Graph const& graph, Weights const& weights, ColorFunction calc_color) {\n    boost::dynamic_properties dp;\n    dp.property(\"node_id\",   get(boost::vertex_index, graph));\n    dp.property(\"fillcolor\", boost::make_transform_value_property_map(calc_color, get(boost::vertex_index, graph)));\n    dp.property(\"style\", boost::make_static_property_map<typename Graph::vertex_descriptor>(std::string(\"filled\")));\n    std::ofstream ofs(\"grid.dot\");\n\n    auto vpw = boost::dynamic_vertex_properties_writer { dp, \"node_id\" };\n    auto epw = boost::make_label_writer(weights);\n    auto gpw = boost::make_graph_attributes_writer(\n            std::map<std::string, std::string> { },\n            std::map<std::string, std::string> { {\"shape\", \"rect\"} },\n            std::map<std::string, std::string> { }\n        );\n\n    boost::write_graphviz(ofs, graph, vpw, epw, gpw);\n}\n```\n\n\nWhich results in a ```\ngrid.dot```\n file like this.\n\nNext, let's layout using ```\nneato```\n:\n\n```\nneato -T png grid.dot -o grid.png\n```\n\n\nAnd the result is:\n\nFULL CODE LISTING\n\n```\n#include <boost/gil/extension/io/png_dynamic_io.hpp>\n#include <boost/gil/extension/io/tiff_dynamic_io.hpp>\n#include <boost/graph/grid_graph.hpp>\n#include <boost/graph/iteration_macros.hpp>\n#include <boost/graph/graphviz.hpp>\n#include <iostream>\n\ntemplate <typename Graph, typename Weights, typename ColorFunction>\nvoid write_dot_file(Graph const& graph, Weights const& weights, ColorFunction);\n\nint main() try {\n    using Img = boost::gil::rgb8_image_t; // gray8_image_t;\n    using Px  = Img::value_type;\n\n    Img img;\n    //boost::gil::png_read_image(\"/home/sehe/graph.png\", img);\n    boost::gil::png_read_and_convert_image(\"/home/sehe/graph.png\", img);\n    auto vw = view(img);\n\n    double constexpr cell_w = 30.409;\n    double constexpr cell_h = 30.375;\n\n    auto pixel_sample = [=](boost::array<size_t, 2> xy) -> auto& {\n        return vw((xy[0]+.5)*cell_w, (xy[1]+.5)*cell_h);\n    };\n\n    auto const w= static_cast<size_t>(img.dimensions()[0] / cell_w);\n    auto const h= static_cast<size_t>(img.dimensions()[1] / cell_h);\n\n    using Graph = boost::grid_graph<2>;\n    Graph graph({{w,h}}, false);\n\n#if 0 // dynamic weight map\n    auto weights = boost::make_vector_property_map<float>(get(boost::edge_index, graph));\n    std::cout << \"Edges: \" << (weights.storage_end() - weights.storage_begin()) << \"\\n\";\n\n#elif 1 // fixed vector weight map\n    std::vector<double> weight_v(num_edges(graph));\n    auto weights = boost::make_safe_iterator_property_map(weight_v.begin(), weight_v.size(), get(boost::edge_index, graph));\n\n#else // associative weight map\n    std::map<Graph::edge_descriptor, double> weight_m;\n    auto weights = boost::make_assoc_property_map(weight_m);\n#endif\n\n    auto debug_vertex = [] (auto& v) -> auto& { return std::cout << \"{\" << v[0] << \",\" << v[1] << \"}\"; };\n    auto debug_edge   = [&](auto& e) -> auto& { debug_vertex(e.first) << \" -> \"; return debug_vertex(e.second); };\n\n    BGL_FORALL_EDGES(e, graph, Graph) {\n        //debug_edge(e) << \"\\n\";\n        auto& from = pixel_sample(e.first);\n        auto& to   = pixel_sample(e.second);\n\n        // compare RED channels only\n        auto cost = std::abs(from[0] - to[0]);\n        put(weights, e, cost);\n    }\n\n    {\n        auto calc_color = [&](size_t v) {\n            std::ostringstream oss;\n            oss << std::hex << std::noshowbase << std::setfill('0');\n\n            auto const& from = pixel_sample(vertex(v, graph));\n            oss << \"#\" << std::setw(2) << static_cast<int>(from[0])\n                << std::setw(2) << static_cast<int>(from[1])\n                << std::setw(2) << static_cast<int>(from[2]);\n\n            return oss.str();\n        };\n\n        write_dot_file(graph, weights, calc_color);\n    }\n\n    {\n        BGL_FORALL_VERTICES(v, graph, Graph) {\n            pixel_sample(v) = Px(255, 0, 123); // mark the center pixels so we can verify the sampling\n        }\n\n        boost::gil::tiff_write_view(\"/tmp/verification.tif\", const_view(img));\n    }\n\n} catch(std::exception const& e) {\n    std::cout << \"Exception occured: \" << e.what() << \"\\n\";\n}\n\ntemplate <typename Graph, typename Weights, typename ColorFunction>\nvoid write_dot_file(Graph const& graph, Weights const& weights, ColorFunction calc_color) {\n    boost::dynamic_properties dp;\n    dp.property(\"node_id\",   get(boost::vertex_index, graph));\n    dp.property(\"fillcolor\", boost::make_transform_value_property_map(calc_color, get(boost::vertex_index, graph)));\n    dp.property(\"style\", boost::make_static_property_map<typename Graph::vertex_descriptor>(std::string(\"filled\")));\n    std::ofstream ofs(\"grid.dot\");\n\n    auto vpw = boost::dynamic_vertex_properties_writer { dp, \"node_id\" };\n    auto epw = boost::make_label_writer(weights);\n    auto gpw = boost::make_graph_attributes_writer(\n            std::map<std::string, std::string> { },\n            std::map<std::string, std::string> { {\"shape\", \"rect\"} },\n            std::map<std::string, std::string> { }\n        );\n\n    boost::write_graphviz(ofs, graph, vpw, epw, gpw);\n}\n```\n\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "How to calculate overall distances from lowest root(s) of a directed graph with networkx\r\n                \r\nIf you look at this DAG (directed acyclic graph):\n\nI want to create a dict which maps the distance from the lowest node(s) to all others nodes which is similar to the x position (height) of each node from the bottom in the rendered graph.\nFor that given graph it would be:\n```\ndistance_nodes_map: {\n  0: {'base-zero', 'base-one'}, \n  1: {'low-b', 'low-a', 'low-c'}, \n  3: {'high-x', 'high-z', 'high-y'}, \n  2: {'mid-r', 'mid-q', 'mid-p'}, \n  4: {'super'}\n}\n```\n\nI wrote an algorithm which worked for that graph above but then I've tested another graph and it didn't work anymore. I tried some algorithms and functions like shortest path or descendants_at_distance but I don't think they are really helpful as an input to calculate the distances.\nMy algorithm doesn't work for instance for this graph:\n\nhttps://gist.github.com/timaschew/3b08a07243fa6f43773014ef5e705c96\nHere is gist which contains:\n\na python script which reads a YAML file, the dependency/graph structure and generates a HTML with a rendered mermaid graph (I've removed my algorithm to calculate the distances in a wrong way)\nboth graphs which are shown here, as a YAML file\n\n    ", "Answer": "\r\nYou are looking for an algorithm that draws a layered graph. There are many different algorithms, and you should choose the one that best fit your needs (for example, have a look at the following paper A Technique for Drawing Directed Graphs by Gansner et al.).\nMany of those algorithms are already implemented in Graphviz (a very famous and powerful graph visualization software). Once you have installed it, it's pretty straightforward to compute the result you are looking for (```\nG```\n is your directed acyclic graph built using ```\nnetworkx.DiGraph```\n):\n```\nfrom networkx.drawing.nx_agraph import graphviz_layout\n\ndef get_distance_nodes_map(G):\n    pos = graphviz_layout(G, prog='dot')\n    coor = sorted({y for k, (x, y) in pos.items()})\n    kmap = dict(zip(coor, range(len(coor))))\n    distance_nodes_map = {level: set() for level in kmap.values()}\n    for k, (x, y) in pos.items():\n        distance_nodes_map[kmap[y]].add(k)\n    return distance_nodes_map\n```\n\nHere are a couple of examples using data that you provided:\n```\n>>> from networkx import DiGraph\n>>> from pprint import PrettyPrinter\n>>> pp = PrettyPrinter()\n>>> G1 = DiGraph()\n>>> G1.add_edges_from([('super', 'high-x'), ('high-x', 'mid-p'),\n...                    ('mid-p', 'low-b'), ('mid-p', 'low-c'),\n...                    ('low-c', 'base-zero'), ('low-c', 'base-one'),\n...                    ('high-y', 'mid-p'), ('high-y', 'base-zero'),\n...                    ('high-z', 'base-one'), ('high-z', 'mid-r'),\n...                    ('high-z', 'mid-q'), ('mid-q', 'low-a'),\n...                    ('low-a', 'base-one')])\n>>> pp.pprint(get_distance_nodes_map(G1))\n{0: {'base-one', 'base-zero'},\n 1: {'low-a', 'low-b', 'low-c'},\n 2: {'mid-p', 'mid-r', 'mid-q'},\n 3: {'high-y', 'high-x', 'high-z'},\n 4: {'super'}}\n>>> G2 = DiGraph()\n>>> G2.add_edges_from([('n10', 'n11'), ('n11', 'n12'), ('n12', 'n13'),\n...                    ('n13', 'n14'), ('n20', 'n14'), ('n20', 'n21'),\n...                    ('n21', 'n22'), ('n22', 'n23'), ('n30', 'n23'),\n...                    ('n30', 'n31'), ('n31', 'n32')])\n>>> pp.pprint(get_distance_nodes_map(G2))\n{0: {'n32'},\n 1: {'n31', 'n23'},\n 2: {'n30', 'n22'},\n 3: {'n21', 'n14'},\n 4: {'n13', 'n20'},\n 5: {'n12'},\n 6: {'n11'},\n 7: {'n10'}}\n```\n\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "graph algorithm question\r\n                \r\nHow can I find all available path for each Vertices which won't cause a cycle? What algorithm to use? Please be brief and provide links if possible, and ask questions if something is not clear from the wonderful diagram below :)\n\n\nI am not looking for a shortest path or anything like that. Instead I just want to know which paths I can still draw on my graph without causing a loop/cycle. For example ```\nL4```\n can goto ```\nL1, L2, L5```\n AND ```\nL2```\n can goto ```\nL5```\n...and so on....\n\nI guess I want a Directed acyclic graph and need help finding out which algorithm to use and how?\n    ", "Answer": "\r\nA shortest-path algorithm like Bellman-Ford or Dijkstra has the side effect of telling you which nodes you can reach from a given node \"A\" -- which is exactly the list of nodes from which edges to \"A\" would form a loop.\n\nI suspect there is a way to modify Bellman-Ford to generate all these lists in one go, instead of running the algorithm separately for every node, but I'll leave that as an exercise for the reader.  :)\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "Do Yen's modifications of Bellman-Ford algorithm work for DAGs?\r\n                \r\nBellman-Ford algorithm is useful to solving the single source shortest path problem and has a unique and interesting property of k-hops optimality for every vertex, at kth iteration, which is required for my application. (basically, I want a shortest path of at most k-hops between a pair of vertices)\n\nThere are two wellknown improvements for Bellman-Ford due to J. Yen, which supposedly reduce the complexity from O(|V|^3) to O(|V|^3 /4).. i.e. a good savings in computations by a constant factor equal to 1/4  (a factor of 1/2 from each improvement).\n\nHowever, it appears that at least one of the modifications is not useful for directed acyclic graphs (DAG) since Yen's method essentially depends on dividing the graph into two DAGs, then altering the iterations between the two DAGs, and thereby obtaining an advantage of a factor of 1/2. Is it correct?\n\nOn the same lines, it would be greatly appreciated if you can tell whether there are there  any other improvements/alternatives to Bellman-Ford which can find k-hop optimal shortest paths?? \n    ", "Answer": "\r\nYen's modification works fine on DAGs. In fact, if you choose the linear order to be a topological order of the DAG, then it converges in just one iteration. The problem for you is that Yen's modification won't solve your problem, since it requires that edges be relaxed in a particular order rather than simultaneously, which is what you need to find shortest paths with at most k edges.\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "networkx: efficiently find absolute longest path in digraph\r\n                \r\nI want networkx to find the absolute longest path in my directed, \nacyclic graph.    \n\nI know about Bellman-Ford, so I negated my graph lengths. The problem: \nnetworkx's bellman_ford() requires a source node. I want to find the \nabsolute longest path (or the shortest path after negation), not the \nlongest path from a given node. \n\nOf course, I could run bellman_ford() on each node in the graph and \nsort, but is there a more efficient method? \n\nFrom what I've read (eg, \nhttp://en.wikipedia.org/wiki/Longest_path_problem) I realize there \nactually may not be a more efficient method, but was wondering if \nanyone had any ideas (and/or had proved P=NP (grin)).\n\nEDIT: all the edge lengths in my graph are +1 (or -1 after negation), so a method that simply visits the most nodes would also work. In general, it won't be possible to visit ALL nodes of course.\n\nEDIT: OK, I just realized I could add an additional node that simply connects to every other node in the graph, and then run bellman_ford from that node. Any other suggestions?\n    ", "Answer": "\r\nThere is a linear-time algorithm mentioned at http://en.wikipedia.org/wiki/Longest_path_problem\n\nHere is a (very lightly tested) implementation\n\nEDIT, this is clearly wrong, see below.  +1 for future testing more than lightly before posting\n\n```\nimport networkx as nx\n\ndef longest_path(G):\n    dist = {} # stores [node, distance] pair\n    for node in nx.topological_sort(G):\n        pairs = [[dist[v][0]+1,v] for v in G.pred[node]] # incoming pairs\n        if pairs:\n            dist[node] = max(pairs)\n        else:\n            dist[node] = (0, node)\n    node, max_dist  = max(dist.items())\n    path = [node]\n    while node in dist:\n        node, length = dist[node]\n        path.append(node)\n    return list(reversed(path))\n\nif __name__=='__main__':\n    G = nx.DiGraph()\n    G.add_path([1,2,3,4])\n    print longest_path(G)\n```\n\n\nEDIT:  Corrected version (use at your own risk and please report bugs)\n\n```\ndef longest_path(G):\n    dist = {} # stores [node, distance] pair\n    for node in nx.topological_sort(G):\n        # pairs of dist,node for all incoming edges\n        pairs = [(dist[v][0]+1,v) for v in G.pred[node]] \n        if pairs:\n            dist[node] = max(pairs)\n        else:\n            dist[node] = (0, node)\n    node,(length,_)  = max(dist.items(), key=lambda x:x[1])\n    path = []\n    while length > 0:\n        path.append(node)\n        length,node = dist[node]\n    return list(reversed(path))\n\nif __name__=='__main__':\n    G = nx.DiGraph()\n    G.add_path([1,2,3,4])\n    G.add_path([1,20,30,31,32,4])\n#    G.add_path([20,2,200,31])\n    print longest_path(G)\n```\n\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "Can we use BFS (in the most optimal way) to find the shortest paths from a source node to all other nodes in a weighted directed acyclic graph?\r\n                \r\nI know that it can be done in O(V+E) using topological sorting. But I think it can also be done in the same complexity using BFS.\n    ", "Answer": "\r\nThe topological sort is nothing except that it is one DFS run. Then as each vertex is finished you put it onto the front of a linked list. It has a running time of O(V+E). As I said before, I think it is more natural here to ask \"can we do a topological sort using BFS?\". This has already been asked and answered.\nIf what you mean is mere BFS, then I would say no. Have a look to this example. A topological sort is a linear ordering of all its vertices such that if graph G contains an edge (u, v), then u appears before v in the ordering. You can see in that example there is an edge from c to d but d appears before c. I think you can update BFS to find the topological sort but again it has the same complexity as running DFS. I would recommend you to have a look at this post Using BFS for topological sort\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "Finding all shortest paths from source to all vertices in a digraph\r\n                \r\nWe are given a directed graph G (possibly with cycles) with positive edge weights, and the minimum distance ```\nD[v]```\n to every vertex ```\nv```\n from a source s is also given (D is an array this way).\nThe problem is to find the array ```\nN[v] = number```\n of paths of length ```\nD[v]```\n from s to v,\nin linear time.\n\nNow this is a homework problem that I've been struggling with for quite long. I was working along the following thought : I'm trying to remove the cycles by suitably choosing an acyclic subgraph of G, and then try to find shortest paths from s to v in the subgraph.\n\nBut I cannot figure out explicitly what to do, so I'd appreciate any help, as in a qualitative idea on what to do.\n    ", "Answer": "\r\nYou can use dynamic programming approach in here, and fill up the number of paths as you go, if ```\nD[u] + w(u,v) = D[v]```\n, something like:\n\n```\nN = [0,...,0]\nN[s] = 1 //empty path\nFor each vertex v, in *ascending* order of `D[v]`:\n   for each edge (u,v) such that D[u] < D[v]:\n       if D[u] + w(u,v) = D[v]: //just found new shortest paths, using (u,v)!\n           N[v] += N[u]\n```\n\n\nComplexity is ```\nO(VlogV + E)```\n, assuming the graph is not sparsed, ```\nO(E)```\n is dominanting.\n\n\n\nExplanation:\n\nIf there is a shortest path ```\nv0->v1->...->v_(k-1)->v_k```\n from ```\nv0```\n to ```\nv_k```\n, then ```\nv0->...->v_(k-1)```\n is a shortest path from ```\nv0```\n to ```\nv_k-1```\n, thus - when iterating ```\nv_k```\n - ```\nN[v_(k-1)]```\n was already computed fully (remember, all edges have positive weights, and ```\nD[V_k-1] < D[v_k]```\n, and we are iterating by increasing value of ```\nD[v]```\n).\nTherefor, the path ```\nv0->...->v_(k-1)```\n is counted in the number ```\nN[V_(k-1)]```\n at this point.\nSince ```\nv0->...->v_(k-1)-v_k```\n is a shortest path - it means ```\nD[v_(k-1)] + w(v_k-1,v_k) = D[v_k]```\n - thus the condition will hold, and we will add the count of this path to ```\nN[v_k]```\n.\n\nNote that the proof for this algorithm will basically be induction that will follow the guidelines from this explanation more formally.\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "Describing an algorithm at most O(nm log n) run time\r\n                \r\nIf I had to give an algorithm in O|V|3| that takes as input a directed graph with positive edge lengths and returns the length of the shortest cycle in the graph (if the graph is acyclic, it should say so). I know that it will be:\nLet G be a graph, define a matrix Dij which stores the shortest path from vertex i to j for any pair of vertices u,v. There can be two shortest paths between u and v. The length of the cycle is Duv+ Dvu. This then is enough to compote the minimum of the Duv+Dvu for any given pair of vertices u and v.\n\nCould I write this in a way to make it at most O(nm log n) (where n is the number of vertices and m is the number of edges) instead of O|V|3|?\n    ", "Answer": "\r\nYes, in fact this problem can be solved in O(nm) according to a conference paper by Orlin and Sedeño-Noda (2017), titled An O(nm) time algorithm for finding the min length directed cycle in a graph:\n\n\n  In this paper, we introduce an O(nm) time algorithm to determine the minimum length directed cycle (also called the \"minimum weight directed cycle\") in a directed network with n nodes and m arcs and with no negative length directed cycles.\n\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "On a weighted directed graph of unknown size, how can one iterate over all possible acyclic paths between two vertices from shortest to longest?\r\n                \r\nWe can assume that all edge weights are positive, and that you can enumerate the edges leading outwards from a vertex, and likewise the edges leading inward, in O(1) time.\n\nFor example, you can perform Dijkstra traversal (or A*, with an admissible heuristic) and mark each vertex's distance from the start until you locate the end vertex, then recurse over these markings in reverse as they describe the possible predecessors on an optimal path. That is, for each possible predecessor, you can determine if it was found on the greedy optimal path if the difference between marked distances is equal to the weight of the edge that connects them.\n\nWhen looking at possible predecessors, the cost of the incoming edge plus the difference between the optimal distance to each vertex is equal to the loss of optimality incurred by including this edge in a solution (zero for edges on optimal paths). So perhaps the question becomes: How can this best be extended to yield all possible paths ranked by decreasing optimality? Is there a clean way to perform a best-first traversal over this kind of meta-graph?\n\nThis seems like the right direction to go for a useful solution. Perhaps a useful thing to keep in mind is that if the part of the path you have explored so far is potentially part of a solution that is suboptimal by at least x, checking for cycles need only be done along the last x distance visited (any path suboptimal by x cannot possibly contain a cycle longer than x).\n\nIs there a more efficient approach?\n\nAs a bonus question, is it also possible to do this on a graph (of known size) with negative edge weights? Does it become more difficult if negative cycles are introduced? (Remember, as we are looking only for acyclic paths this does not necessarily mean that the optimal solution runs away.)\n    ", "Answer": "\r\nFor full graph of N nodes there are magnitude of (N-2)! possible acyclic pathes from node A to node B. Think about it... This should be huge huge number and if you only need K (big enough, but reasonable number) pathes, you better got K-shortest_path mentioned in comments.\n\nIf you can manage enough memory to hold all possible ways in it, there is obvious solution - generate all possible ways and sort them by weight. If not, you'll have to dump answers to disk and then collect them.\n\nYou can enumerate all possible ways with modified BFS - \"visited\" array is passed to recursive call instead of being global boolean array. When you visit destination, add it to global solutions map (key - weight, value - list of pathes with this weight).\n\nIf you cannot afford holding all pathes in memory, you can dump them to temporaty files. Naive solution for this: open file with name 0-padded up to 10 digits - or whatever fits your needs - weight, and add one line for path. After all pathes are collected, read files in appropriate order and form final result.\n\nNB It's better not to open/append/close files if you can. You can collect pathes in map and dump only longest list when total number of pathes exceeds some limit, for example.\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "Is there always some MST that is a shortest path tree?\r\n                \r\nIn my computer science course our professor gave us this final exam problem, and I'm having trouble:  \n\nMarissa and Joel are going on a road trip and they want to make sure they stop in each city (think of the streets as the edges of the graph and the cities as the vertices). They want to reach each city, and they will be starting in their hometown city, Vertexville, NY. They want to be as fuel efficient as possible, and don’t like seeing the same scenery twice, so they require that the highways/roads traversed in their possible road trip routes be a concept called a shortest path tree (in other words, the roads traversed in their possible routes be acyclic).\n\nYou are helping Marissa and Joel plan their trip,  and they have are testing you for your computer science final in doing so, so they ask you: \n\nIs it possible to have a minimum spanning tree and a shortest path tree such that the MST and the SP tree are completely edge-disjoint?\n\nYou found an MST for their road trip. They want to know if for every graph, there always exists an MST that is an SP tree?  \n\n-Roads/highways are bi-directional (graph is undirected) \n\n-All edge lengths are positive and distinct\n\nIs there a proof to show this that isn't just constructing a counterexample??\n    ", "Answer": "\r\n\n  Is it possible to have a minimum spanning tree and a shortest path\n  tree such that the MST and the SP tree are completely edge-disjoint?\n\n\nNo. Construct any SP tree. The shortest edge from the SP root will always be in both the SP tree and the MST.  Proof:\n\nLet the SP root be A and let AC be the shortest adjacent edge.  Obviously AC is the shortest path to C, so it will be in the SP tree.\n\nThere is exactly one MST. [proof]   If we build it with Kruskal's algorithm, then AC is the first visited edge that can connect A to anything else.  Therefore it will be in the MST as well.\n\n\n  They want to know if for every graph, there always exists an MST that\n  is an SP tree?\n\n\nNo.  For example, a ring of more than 5 vertices connected with edges of length 1, and all other pairs of vertices connected with edges of length 2.  Every MST will contain only edges of length 1 (all but one ring edges), while every SP tree will contain at least one edge of length 2 (a shortcut).\n\nNote that this construction works just as well for distinct weights (as specified in the question) that differ from the above proportions by relatively insignificant amounts -- weights 1000, 1001, 1002, ... and 2000, 2001, 2002... etc.\n\n\n  Is there a proof to show this that isn't just constructing a counterexample??\n\n\nMaybe, but counterexamples are the best way to prove a negation, because they don't require any fancy reasoning.\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "Find the most advantageous sequence of currency exchange\r\n                \r\nI am working with the following exercise from my book:\n\nShortest path algorithms can be applied in currency trading. Let c1 , c2 , . . . , cn be various currencies; for instance, c1 might be dollars, c2 pounds, and c3 lire. For any two currencies ci and\ncj, there is an exchange rate ri,j; this means that you can purchase ri,j units of currency cj in\nexchange for one unit of ci. These exchange rates satisfy the condition that ri,j · rj,i < 1, so that if\nyou start with a unit of currency ci, change it into currency cj and then convert back to currency\nci, you end up with less than one unit of currency ci (the difference is the cost of the transaction).\n(a) Give an efficient algorithm for the following problem: Given a set of exchange rates ri,j,\nand two currencies s and t, find the most advantageous sequence of currency exchanges for\nconverting currency s into currency t. Toward this goal, you should represent the currencies\nand rates by a graph whose edge lengths are real numbers.\n\n\n\nSo what basically we want to do is instead of minimizing, we need to maximize the profit. Therefore we need to find the longest path from s to t. We are asserted of the existence of the shortest path from s to t.\n\nThe way I thought to solve this problem is following this algorithm:\n\n\nNegate all the edges of the graph\nRun the shortest path algorithm for directed acyclic graphs.\n\n\nI believe this would work but I am not sure. On google I found some solutions that include another step: converting the multiplication of the rates to additions using logarithms. I think this step is not necessary her e but still I am not sure.\n    ", "Answer": "", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "Why don't the mainstream DBMSs have graph functionality?\r\n                \r\nRelational databases are frequently used to store graphs in all their many flavors (trees, directed graphs, undirected graphs, ...).\n\nWhy then do none of the major DBMSs (Microsoft, MySql, Oracle, PostgreSQL, SqlLite, just to name a few in alphabetical order) include library support for treating relations as graphs?\n\nSome desirable features, by way of example:\n\n\nConstraint checking (connectedness, acyclicity, planarity, ...)\nCommonly needed functions (shortest path, minimum spanning tree, transitive closure, max flow/min cut, clique detection, Hamiltonian/Eulerian cycles ...)\nAuxiliary data structures needed to improve performance for any of the above\n\n\nBuilding support for some of these things outside the database is complicated because (among other reasons):\n\n\nIt's inherently complicated (libraries help here)\nShort answers are often supported by lots of data: an external client running a shortest path algorithm would need to either be very \"chatty\" with the database or would need to retrieve a much-larger-than-needed amount of data; either choice is bad for the network\nMaintaining integrity when integrity depends on a graph-theoretic constraint requires access to all proposed updates, hence a trigger, and access to existing graph libraries from triggers is complicated in many systems\nThe DBMS storage manager and optimizer are uniquely positioned to address the question of auxiliary data structures, as they do with indexes\n\n\nThis isn't a rhetorical question, I actually want to know if there are interesting technical (or historical) reasons.\n    ", "Answer": "\r\nI've worked in a research group, interested among others in delevoping a database for RDF(S) data, which is basically labeled graphs, or triples [subject, predicate, object], which are basically graph edges: [sourceNode, edgeLabel, targetNode].\n\nThe question to ask, to appreciate the hardness of the problem: What kind of indices are you going to build for a labeled graph? You have to take advantage of common \"properties\" (each \"predicate\" is a property of the subject, with the value of object), and index edges accordingly, so you can quickly find if \"there is an edge called 'hasAge' on a Person with value greater than 18\".\n\nFor illustration, here is a simple approach, which is schema-oblivious (and goes quite to the opposite direction of traditional database research which quite unanimously agrees that schemata are good to have). It completely ignores any schema information (this paper provides useful context). Just store everything in three big tables (s: subject, p: predicate, o: object):\n\n\n[s, p, o]\n[p, o, s]\n[o, s, p]\n\n\nThese three suffice to answer any efficiently evaluate any query with (at most) a subject, (at most) a predicate, and (at most) an object (i.e. queries of the form ```\n(s, *, *)```\n, ```\n(*, p, *)```\n, ```\n(*, *, o)```\n, ```\n(s, p, *)```\n, ```\n(s, *, o)```\n, ```\n(*, p, o)```\n, ```\n(s, p, o)```\n). Complex queries though consist of many \"path expressions\" (i.e. you describe data for which you can find certain paths satisfying some criteria), each of which is translated to a self-join on one of these (big!) tables, which is not all that efficient, which is a problem.\n\nThere, that's a simple graph database in a pocket. :)\n\nConcluding, this is the field of active research. I'm not up to date with the current state of art, but I've seen products like AllegroGraph and others that claim very good results.\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "Shortest route from one source to multiple destinations (simpler variation of the \"Traveling salesman\")\r\n                \r\nI'm trying to implement a solution for the following problem:\n\nGiven a source vertex and a list of destination vertices in a directed acyclic graph, compute the list of paths that would visit all the vertices in an optimal way (minimum number of distinct vertices visited), given there's no \"travel cost\" in going back to the source vertex, or to a previously visited vertex.\n\nThe resulting paths must be given in an order such as the first vertex of each path must be the source vertex or a vertex visited before in a previous path. So a path can restart from any visited vertex, or from the source vertex if nothing was visited before.\n\n(Not a homework assignment, I just wrote the problem definition to make the question clearer. The problem I'm trying to solve is dynamically joining tables on a database, given I know the tables relationship graph, and I'll be joining one table to many others. In this simplification of my actual problem, the source is in the \"root\" of the graph.)\n\nSo given this graph:\n\n```\n  source = 1\n         /   \\\n        2     3\n        |     |\ndest1 = 4     /\n         \\   /\n   dest2 = 5\n```\n\n\nSo children are below parents. The expected result, given source ```\n1```\n and destinations ```\n4```\n and ```\n5```\n, would be:\n\n```\nPath 1 = 1 -> 2 -> 4\nPath 2 = 4 -> 5\n```\n\n\nNote that a naive implementation that would get the individual shortest paths from source to each destination would result in a non-optimal solution is this case:\n\n```\nPath 1 = 1 -> 2 -> 4\nPath 2 = 1 -> 3 -> 5\n```\n\n\nMaking an \"extra\" visit to the vertex ```\n3```\n.\n\nI've managed to solve the first requirement, namely computing the list of optimal paths. BUT I could not manage to guarantee the required result order for all different permutations of given destinations.\n\nSo in some cases I would compute something like:\n\n```\nPath 1 = 4 -> 5\nPath 2 = 1 -> 2 -> 4\n```\n\n\nThis is my code so far:\n\n```\npublic class ShortestPath {\n\n  public ShortestPath(Vertex source) {\n    // build shortest path from source to all children\n  }\n\n  public boolean hasPathTo(Vertex dest) {\n    // returns true if there's a path to dest, false otherwise\n  }\n\n  public int distTo(Vertex dest) {\n    // returns the distance to dest, or Integer.MAX_VALUE if there's no path\n    // to dest\n  }\n\n  public Deque<Vertex> to(Vertex dest) {\n    // returns path to dest, including source as the first element in the\n    // path, or throws IllegalArgumentException if there's no path to dest\n  }\n\n  public Collection<Deque<Vertex>> to(List<Vertex> destinations) {\n    Map<Vertex, Deque<Vertex>> destToPath = new HashMap<>();\n    for (Vertex dest : destinations) {\n      Deque<Vertex> path = to(dest);\n      for (Map.Entry<Vertex, Deque<Vertex>> entry : destToPath.entrySet()) {\n        Vertex source2 = entry.getKey();\n        Deque<Vertex> path2 = entry.getValue();\n        if (source2.shortestPath().distTo(dest) < path.size() - 1) {\n          // If there's a shorter path from source2 to dest\n          path = source2.shortestPath().to(dest);\n        } else if (dest.shortestPath().distTo(source2) < path2.size() - 1) {\n          // If there's a shorter path from dest to source2\n          entry.setValue(dest.shortestPath().to(source2));\n        }\n      }\n      destToPath.put(dest, path);\n    }\n    return destToPath.values();\n  }\n}\n```\n\n\nI've tried sorting the destinations in hierarchical order, but that did not solve the result order. I've also tried to create a ```\nComparator```\n that would sort the result, but I could not figure out a proper algorithm for it.\n\nAlso, I've tried to improve the code above so it would use a separate ```\nList```\n structure and do ```\nadd(i, path)```\n to add the path to specific indexes in the ```\nList```\n, but what I've done also failed for some inputs used in my tests.\n\nIs there an algorithm already written to solve this specific problem? If not, any ideia on an approach that would guarantee the result order specified above?\n\nEDIT: Sorting the result is not so straightforward. For a little bit more complex result like:\n\n```\nPath 1 = 1 -> 2 \nPath 2 = 2 -> 4\nPath 3 = 4 -> 5\n```\n\n\nHow would the ```\nComparator```\n compute ```\nint compare(Deque<Vertex> o1, Deque<Vertex> o2)```\n given Path 1 and Path 3 above?\n    ", "Answer": "", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "Pathfinding while forcing unique node attributes -- which algorithm should I use?\r\n                \r\nUpdate 2011-12-28: Here's a blog post with a less vague description of the problem I was trying to solve, my work on it, and my current solution: Watching Every MLB Team Play A Game\n\n\n\nI'm trying to solve a kind of strange pathfinding challenge. I have an acyclic directional graph, and every edge has a distance value. And I want to find a shortest path. Simple, right? Well, there are a couple of reasons I can't just use Dijkstra's or A*.\n\n\nI don't care at all what the starting node of my path is, nor the ending node. I just need a path that includes exactly 10 nodes. But:\nEach node has an attribute, let's say it's color. Each node has one of 20 different possible colors.\nThe path I'm trying to find is the shortest path with exactly 10 nodes, where each node is a different color. I don't want any of the nodes in my path to have the same color as any other node.\nIt'd be nice to be able to force my path to have one value for one of the attributes (\"at least one node must be blue\", for instance), but that's not really necessary.\n\n\nThis is a simplified example. My full data set actually has three different attributes for each node that must all be unique, and I have 2k+ nodes each with an average of 35 outgoing edges. Since getting a perfect \"shortest path\" may be exponential or factorial time, an exhaustive search is really not an option. What I'm really looking for is some approximation of a \"good path\" that meets the criterion under #3.\n\nCan anyone point me towards an algorithm that I might be able to use (even modified)?\n\n\n\nSome stats on my full data set:\n\n\nTotal nodes: 2430\nTotal edges: 86524\nNodes with no incoming edges: 19\nNodes with no outgoing edges: 32\nMost outgoing edges: 42\nAverage edges per node: 35.6 (in each direction)\nDue to the nature of the data, I know that the graph is acyclic\nAnd in the full data set, I'm looking for a path of length 15, not 10\n\n    ", "Answer": "\r\nIt is the case when the question actually contains most of the answer.\n\nDo a breadth-first search starting from all root nodes. When the number of parallelly searched paths exceeds some limit, drop the longest paths. Path length may be weighed: last edges may have weight 10, edges passed 9 hops ago - weight 1. Also it is possible to assign lesser weight to all paths having the preferred attribute or paths going through the weakly connected nodes. Store last 10 nodes in the path to the hash table to avoid duplication. And keep somewhere the minimum sum of the last 9 edge lengths along with the shortest path.\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "Finding the shortest path to solve colored water sorting games\r\n                \r\nSo my aunt plays this now popular mobile game, shown in the picture below. She got stuck on a certain level and asked me if I can solve it. Knowing that I'm not smart enough to find patterns or a strategy to solve it, and knowing only the basics in Python, I thought I should try to solve it by writing a script, and that it's the perfect opportunity to learn new stuff, I started my journey of 2 weeks.\n\nThe game consists of a number of bottles, full with layers of different colored bottles, and generally one or two empty bottles, and the goal is to make all bottles uniformly colored. A move consists of taking a bottle full of at least on layer and pouring it in another bottle. Main rules are you can pour any color in an empty bottle, and you only can pour a layer on another layer if they are the same color.\nMy first approach to solving it, was by creating a new ```\nclass bottle```\n, implemented all the rules in it, which means because I knew only the basics, it took me a lot of time and it was really not optimized (I didn't know about stacks and had to write down so many ```\nif.. elif.. else```\n statements to specify when a bottle can pour in another bottle). After I finished that I tried to write some code that can solve it. I didn't have many ideas on how the code would know which bottle to pick and where to pour it, so I went for the easy solution: pick them randomly. And it solved it instantly (kinda) for a small number of bottles, last one I tried was with 10 bottles, but with 15 bottles or more, it couldn't.\nSo then my second thought was maybe calculating every single possibility and move, i.e. make the game tree, and then use a search algorithm to find the shortest path, i read a bit about game trees and graph's searching algorithms and decided to use a breadth-first search(afterwards I learned that the graph I work with is a directed acyclic graph, so it's better to work with topological sorting, I'm not sure tho). The nodes in the game tree are the different states the bottles are in after pouring them in each other, and the edges are the moves that get you from one state to another. Here is how I generated the game tree in somewhat of a pseudocode:\n```\ntake the first bottle A\ncreate a list of bottles, list A, that bottle A can pour in\nfor each bottle B in list A, we pour bottle A in bottle B, and get a new state of bottles C\ncheck if state C is already a node in the graph, or a permutation of a node(see explanation after the code) and add it to the graph if not\ndo what we did to bottle A, to all other bottles in the current node\nthen move to the children nodes and do the same\n```\n\nWhat I meant by checking permutations of a node is, for example, (bottle(1,2,1), bottle(0,0,0), bottle(2,1,2)) would be different from (bottle(1,2,1), bottle(2,1,2), bottle(0,0,0)), so when I left the permutations in, graphs that would have just 3000 nodes get as big as 200000 nodes.\nThe problem with the code I wrote was that it takes too much time to generate the game tree, last time I tried, it took 5 hours to generate the game tree for a 16 bottles level, which I think is a lot, and it can be done much much faster. A friend of mine suggested using Numpy, so each state or node in the graph would be a single matrix, and because Numpy can do things much much faster, it might be the way to do it, but me not being savvy at Numpy, I thought I can ask here for general good practices that can help me solve my problem, e.g. how to make checking if the node is already on the graph, or if a permutation of it, in this case, it would be checking if two matrices are equivalent up to permutation of columns or something like that.\nSo my question would be: how would you solve this if you were on my shoes, and how do you think I can get my code better optimized? Any advice would be much appreciated.\n    ", "Answer": "\r\nVery interesting problem! I do have some suggestions\n\nFirstly in my opinion searching a huge configuration tree like this without a clear idea where you're going is at best inefficient. Why not prefer \"directions\" that lead to more bottles being filled or filled more highly in the same color. See my ```\n__iter__```\n below.\n\nI think it could be worthwhile to recognize two states of the puzzle to be the same if the bottles only vary in order. You could do that by having the colors in the bottles represented by tuples of integers and saving a set of those (since the set does not safe the order).  See ```\nset_rep```\n below.\n\n\nI couldn't resist to code this up. As a basis I have used Raymond Hettinger's Generic Puzzle Solver.\n Especially my ```\nsolve```\n method is strongly influenced by his.\nThe actual code\n```\nimport numpy as np\nfrom collections import deque\n\n\nclass ColoredWater:\n    def __init__(self, pos):\n        self.pos = pos\n\n    @staticmethod\n    def get_first_non_zero(arr):\n        try:\n            return arr[arr != 0][0]\n        except IndexError:\n            return 0\n\n    @staticmethod\n    def get_first_non_zero_index(arr):\n        try:\n            return np.where(arr != 0)[0][0]\n        except IndexError:\n            return 3\n\n    @staticmethod\n    def get_last_zero_index(arr):\n        try:\n            return np.where(arr == 0)[0][-1]\n        except IndexError:\n            return 3\n\n    def get_legal_moves_to(self, moveable_to):\n        first_non_zero = self.first_non_zero\n        n = first_non_zero.shape[0]\n        if first_non_zero[moveable_to] == 0:\n            return np.where((first_non_zero != 0) & (np.arange(n) != moveable_to))[0], moveable_to\n        else:\n            return np.where((first_non_zero == first_non_zero[moveable_to]) & (np.arange(n) != moveable_to))[0], moveable_to\n\n    def swap(self, i, j):\n        out = self.pos.copy()\n        idx_from = (self.get_first_non_zero_index(self.pos[:, i]), i)\n        idx_to = (self.get_last_zero_index(self.pos[:, j]), j)\n        out[idx_from], out[idx_to] = out[idx_to], out[idx_from]\n        return ColoredWater(out)\n\n    def isgoal(self):\n        return np.array_equiv(self.pos, self.pos[0])\n\n    def __iter__(self):\n        self.first_non_zero = np.apply_along_axis(self.get_first_non_zero, 0, self.pos)\n        moveable_to = np.where(self.pos[0] == 0)[0]\n        legal_moves = tuple(map(self.get_legal_moves_to, moveable_to))\n\n        out = [self.swap(origin, target)\n               for origins, target in legal_moves\n               for origin in origins]   \n\n        def number_of_full_stacks(pos):\n            return np.sum(np.all((pos == [pos[0]]), axis=0))\n\n        def fillings_of_stacks(game):\n            pos = game.pos\n            return number_of_full_stacks(pos), number_of_full_stacks(pos[1:]), number_of_full_stacks(pos[2:])\n\n        return iter(sorted(out, key=fillings_of_stacks, reverse=True))\n\n    def set_rep(self):\n        return frozenset(map(tuple, self.pos.T))\n\n    def __repr__(self):\n        return repr(self.pos)\n\n    def solve(pos, depthFirst=False):\n        queue = deque([pos])\n        trail = {pos.set_rep(): None}\n        solution = deque()\n        load = queue.append if depthFirst else queue.appendleft\n\n        while not pos.isgoal():\n            for m in pos:\n                if m.set_rep() in trail:\n                    continue\n                trail[m.set_rep()] = pos\n                load(m)\n            pos = queue.pop()\n\n        while pos:\n            solution.appendleft(pos)\n            pos = trail[pos.set_rep()]\n\n        return list(solution)\n```\n\nHow to run it\nFirst I run it on your example. In run with ```\ndepthFirst=True```\n it gives a solution in 117 moves in 376 ms. When I run it with ```\ndepthFirst=False```\n it gives an optimal solution in 55 moves in 9.42 s.\n```\nfrom ColoredWater import ColoredWater\nimport numpy as np\n\nColoredWater(np.array([[ 0,  1,  0,  5,  8,  9,  7,  4,  2,  8,  2,  5,  5, 10, 12],\n                       [ 0,  2,  0,  6,  3, 10,  9,  7, 11,  3, 11, 12,  3,  6, 13],\n                       [ 0,  3,  0,  7,  4,  2, 11, 11,  6, 12, 12, 13,  1, 13,  1],\n                       [ 0,  4,  0,  5,  9,  9,  7,  6,  8,  8, 13,  1,  4, 10, 10]]))\\\n.solve(depthFirst=True) \n```\n\nI have also tested it on a \"random\" example:\n```\ndef sort_zeros(x):\n    return sorted(x, key=lambda x:x != 0)\n\n\nn = 15\n\narr = np.broadcast_to(np.array([0,0,*range(n)]),(4,n+2)).copy()\nnp.random.shuffle(arr.reshape(-1))\narr = np.apply_along_axis(sort_zeros,0,arr)\nprint(ColoredWater(arr).solve(depthFirst=True))\n```\n\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "Graph theory - learn cost function to find optimal path\r\n                \r\nThis is a supervised learning problem.\n\nI have a directed acyclic graph (DAG). Each edge has a vector of features X, and each node (vertex) has a label 0 or 1. The task is to find a cost function w(X), so that the shortest path between any pair of nodes has the highest ratio of 1s to 0s (minimum classification error).\n\nThe solution must generalize well. I tried logistic regression, and the learned logistic function predicts fairly well the label of a node giving the features of a incoming edge. However, the graph's topology is not taken into account by that approach, so the solution in the whole graph is non-optimal. In other words, the logistic function is not a good weight function given the problem setup above.\n\nAlthough my problem setup is not the typical binary classification problem setup, here is a good intro to it:\nhttp://en.wikipedia.org/wiki/Supervised_learning#How_supervised_learning_algorithms_work\n\nHere are some more details:\n\n\nEach feature vector X is a d-dimensional list of real numbers. \nEach edge has a vector of features. That is, given the set of edges E = {e1, e2, .. en} and set of feature vectors F = {X1, X2 ... Xn}, then edge ei is associated to vector Xi.\nIt is possible to come up with a function f(X), so that f(Xi)\ngives the likelihood that edge ei points to a node labeled with a 1.\nAn example of such function is the one I mentioned above, found through logistic\nregression. However, as I mentioned above, such function is non-optimal. \n\n\nSO THE QUESTION IS:\nGiven the graph, a starting node and an finish node, how do I learn the optimal cost function w(X), so that the ratio of nodes 1s to 0s is maximized (minimum classification error)?\n    ", "Answer": "\r\nThis is not really an answer, but we need to clarify the question. I might come back later for a possible answer though.\n\nBelow is an example DAG. \n\n\n\nSuppose the red node is the starting node, and the yellow one is the end node. How do you define the shortest path in terms of \n\n\n  the highest ratio of 1s to 0s (minimum classification error) ?\n\n\nEdit: I add names for each node and two example names for the top two edges. \n\nIt seems to me you cannot learn such a cost function that takes feature vectors as inputs and whose output (edge weights? or whatever) can guide you to take a shortest path toward any node considering the graph topology. The reason is stated below:\n\n\nLet's assume you don't have the feature vectors you stated. Given a graph as above, if you want to find all-pair-shortest-path with respective to the ratio of ```\n1```\ns to ```\n0```\ns, it's perfect to use Bellman equation or more specifically Dijkastra plus a proper heuristic function (e.g., percentage of ```\n1```\ns in the path). Another possible model-free approach is to use q-learning in which we get reward +1 for visiting a ```\n1```\n node and -1 for visiting a ```\n0```\n node. We learn a lookup q-table for each target node one at a time. Finally we have the all-pair-shortest-path when all nodes are treated as target nodes. \nNow suppose, you magically obtained the feature vectors. Since you are able to find the optimal solution without those vectors, how come they will help when they exist?\nThere is one possible condition that you can use the feature vector to learn a cost function which optimize edge weights, that is, the feature vectors are dependent on the graph topology (the links between nodes and the position of ```\n1```\ns and ```\n0```\ns). But I did not see this dependency in your description at all. So I guess it does not exist.\n\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "How do I find all paths through a set of given nodes in a DAG?\r\n                \r\nI have a list of items (blue nodes below) which are categorized by the users of my application. The categories themselves can be grouped and categorized themselves.\n\nThe resulting structure can be represented as a Directed Acyclic Graph (DAG) where the items are sinks at the bottom of the graph's topology and the top categories are sources. Note that while some of the categories might be well defined, a lot is going to be user defined and might be very messy.\n\nExample:\n\n\n(source: theuprightape.net)  \n\nOn that structure, I want to perform the following operations:\n\n\nfind all items (sinks) below a particular node (all items in Europe)\nfind all paths (if any) that pass through all of a set of n nodes (all items sent via SMTP from example.com)\nfind all nodes that lie below all of a set of nodes (intersection: goyish brown foods)\n\n\nThe first seems quite straightforward: start at the node, follow all possible paths to the bottom and collect the items there. However, is there a faster approach? Remembering the nodes I already passed through probably helps avoiding unnecessary repetition, but are there more optimizations?\n\nHow do I go about the second one? It seems that the first step would be to determine the height of each node in the set, as to determine at which one(s) to start and then find all paths below that which include the rest of the set. But is this the best (or even a good) approach?\n\nThe graph traversal algorithms listed at Wikipedia all seem to be concerned with either finding a particular node or the shortest or otherwise most effective route between two nodes. I think both is not what I want, or did I just fail to see how this applies to my problem? Where else should I read?\n    ", "Answer": "\r\nIt seems to me that its essentially the same operation for all 3 questions.  You're always asking \"Find all X below node(s) Y, where X is of type Z\".  All you need is a generic mechanism for 'locate all nodes below node', (solves Q3) and then you can filter the results for 'nodetype=sink' (solves Q1).  For Q2, you have the starting-point (your node set) and your ending point (any sink below the starting point) so your solution set is all paths from starting node specified to the sink.  So I would suggest that what you basically have a is a tree, and basic tree-traversal algorithms would be the way to go.\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "What algorithm should I use to find the minimum flow on a digraph where there are lower bounds but not upper bounds on flow?\r\n                \r\nWhat algorithm should I use to find the minimum flow on a digraph where there are lower bounds, but not upper bounds on flow? Such as this simple example:\n\n\n\nIn the literature this is a minimum cost flow problem. In my case however the cost is the same as a nonzero lower bound on the flow required on each edge so I worded the question as above. In the literature the question would be: what is the best algorithm for finding the minimum cost flow of a single-source/single-sink directed acyclic graph in which each edge has infinite capacity, a non-zero lower bound on flow, and a cost equal to the lower bound on flow.\n\nFrom my research it seems that the main way people deal with any kind of minimum cost of any kind of network is to set the problem up as a LP-type problem and solve that way. My intuition, however, is that not having upper bounds on flow ,i.e. having edges with infinite capacites, makes the problem easier, so I was wondering if there is an algorithm specifically targeting this case using more \"graphy\" techniques than the simplex method et. al. \n\nI mean, if all the costs and lower bounds are 1 as in the above... we are then looking for a flow that covers all edges, obeys flow rules, and isn't pushing too much flow through any path from s to t. This just feels like it shouldn't require an LP solver to me and indeed the Wikipedia article on min cost flows states that \"if the capacity constraint is removed, the problem is reduced to the shortest path problem\" but I think they are talking about the case in which the lower bounds are all zero.\n\nAlso is there open source C/C++ code for minimum cost flow anywhere? From googling what is available I find that I can either set the problem up as an LP problem myself and solve with an open source LP solver, or I could use LEMON which provides several algorithms for min-cost flow. The boost graph library does not include an implementation as far as I can tell.\n\nIs there anything else?\n    ", "Answer": "\r\nIn the absence of upper-bounds, the easiest way -- easiest to implement, understand, and that is reasonably efficient -- to find the minimum flow of a graph is the following:\n\n\nFind a feasible flow, i.e. a flow that satisfies flow rules and lower-bounds on flow but isn't necessarily a minimum flow. This can be accomplished by doing a depth-first traversal of the graph, keeping track of the current path as we traverse, and upon visiting a previously discovered node or t, the target node, augmenting the flow on the current path with the maximum lower-bound of the unsatisfied edges on the current path all the way to t.\nTurn the feasible flow into a minimum flow by solving a max flow problem. You need to find the maximum flow on the graph that has capacities equal to flow(e) - lower-bound(e), where flow(e) means flow from the feasible flow. This maximum flow subtracted from the feasible flow will be a minimum flow.\n\n\nA version of the above can also be performed in the case in which the graph also has upper-bounds on flow. In that case step 1. is more complicated but can be solved by performing an initial max flow computation on a specially constructed graph.\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "combinatorial optimization: multiple upgrade paths with inventory constraints\r\n                \r\nI'm playing a video game, and i want to make a program that calculates the globally optimal build/upgrade path towards a fixed 6 item goal. \n\nTime, Cost, Inventory constraints, and effectiveness (short/mid/long-term) ratings are to be considered. Identifying local spikes in effectiveness are also welcomed, but optional. I don't know how to classify this problem, but i'm guessing its a type of graph search. The fact that multiple criteria are being optimized is making things confusing for me.\n\nProblem details:\n\n\nThere are 6 free slots in your bag to hold items. \nThere are 2 classes of items: basic items, and composite items. \nComposite items are built/merged from basic items, and other composite items. \nIf you have enough gold, you can buy a composite item, and its missing sub components, all at once, using only 1 inventory slot.\nThe build path for various composite items are fixed, and many basic components are featured in more than one recipe.\nGold is earned at a fixed rate over time, as well as in small non-deterministic bursts.\nTime is bounded: it increments in fixed ticks (seconds) and has a max value: 2400.\nThere exists no more than 50 items, maybe less.\n\n\nSo, thinking about the problem...\n\nTackling the gold/time issue first\n\nWe can either ignore the non-deterministic aspect, or use some statistical averages. Let's make life easy, and ignore it for now. Since gold, and time, are now directly related in our simplified version, they can be logically merged. \n\nCombinatorial expansion of feasible paths\n\nA graph could be built, top down, from each of the 6 goal items, indicating their individual upgrade hierarchies. Components that are shared between the various hierarchies can be connected, giving branch decisions. The edges between components can be weighted by their cost. At this point, it sounds like a shortest path problem, except with multiple parallel and overlapping goals.\n\nNow the question is: how do inventory constraints play into this?\n\nThe inventory/cost constraints, add a context, that both disables (no free slots; not enough gold), and enables (two items merged freeing a slot) various branch decisions, based upon previous choices and elapsed time. Also, the possibility of saving up gold and doing nothing for a non fixed period, can be optimal in certain situations. \n\nHow does one expand all the feasible possibilities? Does it have to be done at every given step? How many total combinations are there? Does this fall under topological combinatorics?\n\nUpdate:\n\nQ: How does one expand all the feasible possibilities?\n\n\nThe item build path is a dependency graph. A correct evaluation order of the dependencies is given by the topological ordering of the graph. A graph may have more than one valid evaluation order.\nhttp://en.wikipedia.org/wiki/Dependency_graph\nhttp://en.wikipedia.org/wiki/Topological_sort\nhttps://mathematica.stackexchange.com/questions/32400/all-possible-topological-orderings-of-a-graph/32417#32417\n\n\nUpdate 2:\n\nQ: How many total combinations are there?\n\n\nSeems that it has to be counted, and there is no numerical formula. \nAlgorithim 3.2, Page 150, \"On Computing the Number of Topological Orderings of a Directed Acyclic Graph\" by Wing-Nig Li, Zhichun Xiao, Gordon Beavers\n\n\nPseudo-Code:\n\n```\nf(g) | vertex_count(g) == 1 = 1\nf(g)                        = ∑ {f(g \\ {v}) for all v ∈ deg0set}\n\ndeg0set = {vertex_in_degree(g,x) == 0 for all x ∈ vertices(g)} \n```\n\n\nMathematica-Code:\n\n```\nf[g_/; Length[VertexList[g]] == 1] := 1\nf[g_] := With[\n    {deg0set = Select[VertexList[g], VertexInDegree[g,#] == 0&]},\n    Sum[f[VertexDelete[g,v]], {v,deg0set}]\n]\n```\n\n\n\n\nRating Effectiveness\n\nIf the above expansion produces less than a few billion possibilities, we can just exhaustive search using OpenCL/CUDA. I'm not sure what other options are available, since most graph search stuff seems to just solve for one criteria.\n    ", "Answer": "\r\nYou need to walk down to establish max values at each end stage and element, (ie add your metric (dps or whatever) up as you walk down, Pruning any combinations that require you to have more slots then possible. Then walk backwards from the best sets of possible end options, (which should be fairly sparse), you should be able to limit it to only the best composite options), and always move in a way that takes you to the max. Then set a value equal to damage on each option,   \n\nGiven that dps or whatever of basic and preliminary composite items is probably less then the final possible composite items, this will be naturally weighted towards effectiveness at the end stage, so you may want to adjust, or set a minimum.\n\nOnce you have that, you can figure out the gold costs for your options, and decide how to weight getting to things faster.\n\nThen you can go through and establish gold costs. You need to decide if you want to wait and earn or not.  If not, then you want to measure the rate of dps increase as a function of time.  If so, I expect it's cheaper to buy the items after not playing, over all.   \n\nYou are going to have to use your data and make some value judgements.  \n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
{"Question": "List of environment variables used by msbuild, dotnet sdks, azure, kudu, etc\r\n                \r\nSo, this mostly came up for me while I've been fiddling with CI builds in VSTS and azure deployment.  Through various github issues, docs, stack questions, random blog posts, reading the source, etc. I run across different environment variables used by the tooling.  Recently, ```\nDOTNET_*```\n ones like:\n\n\n```\nDOTNET_SKIP_FIRST_TIME_EXPERIENCE```\n - which tells the build agent not to cache packages.  Since hosted agents dump the cache anyway, this is suggested in a note in the docs as a performance boost.\n```\nDOTNET_CONFIGURE_AZURE```\n - which tells the ```\n_WebConfigTransform```\n target to set the ```\nweb.config```\n's ```\nstdoutlogfile```\n to ```\n\\\\?\\%home%\\LogFiles\\stdout```\n\n\n\nothers come up through azure web apps and configuration there:\n\n\n```\nWEBSITE_NODE_DEFAULT_VERSION```\n\n```\nWEBSITE_SITE_NAME```\n\nThere are other ```\nWEBSITE_*```\n\n```\nDIAGNOSTICS_AZUREBLOBCONTAINERSASURL```\n\nThere are other ```\nDIAGNOSTICS_*```\n\n```\nKUDU_*```\n and ```\nSCM_*```\n I've seen for manipulating aspects of the hosting environment and kudu environment underneath the web app\nWhen I go to KUDU console and check the environment variables there, I also see ```\nAZURE_*```\n, more ```\nDOTNET_*```\n, and a bunch of others\n\n\nI recognize that each prefix is designating a 'namespace' of sorts that describe related sets of environment variables, so I'm unlikely to find a master location with info about all of them. \n\nBut my question is for each of these domains, where can one find some sort of definitive list or even a general list of important environment variables and their functions?  \n\nI feel like my path to understanding these settings and flags is very much random collision based, generating lots of heat with little real work accomplished. I'd rather be on an acyclic, weighted, directed graph to the answers, know what I mean? Even if I'm just greedily looking for the shortest path, it seems better than googling around for different issues and just stumbling upon things buried deep in the github repos or blog posts.  Can someone give me an edge here?  \n\nThe context for this is that after I upgraded to netcore1.1/vs2017/csproj and my CI builds stopped transforming my web.config ```\nstdoutlogfile```\n path correctly for azure web app deployment, I ended up having to dig down into the websdk source and back track through a few variable substitutions to find where the target was determining what environment variable to use when configuring a publish for Azure.  I was hoping to find some page in the docs for ```\ndotnet publish```\n with a \"here are the environment variables which can affect the output of the publish command\" section, but came up empty handed.\n    ", "Answer": "\r\nAt least for App Service, here's a pretty good list - has ```\nSCM-*```\n and some other , more deployment focused variables as well.\nhttps://learn.microsoft.com/en-us/azure/app-service/reference-app-settings\nA few more Kudu specific ones can be found here\nhttps://github.com/projectkudu/kudu/wiki/Configurable-settings\nThere's also this little list of ```\nAZURE_```\n variables in the SDK design guide:\nhttps://azure.github.io/azure-sdk/general_azurecore.html#environment-variables\n    ", "Knowledge_point": "Shortest Paths in Directed Acyclic Graphs", "Tag": "算法分析"}
