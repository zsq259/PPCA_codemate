{"Question": "How is a minimum bottleneck spanning tree different from a minimum spanning tree?\r\n                \r\nA minimum bottleneck spanning tree of a weighted graph G is a spanning tree of G such that minimizes the maximum weight of any edge in the spanning tree. A MBST is not necessarily a MST (minimum spanning tree).\n\nPlease give an example where these statements make sense.\n    ", "Answer": "\r\nLook at the MST example on Wikipedia for reference:\n\n\n\nA bottleneck in a spanning tree is a maximum-weight edge in that tree. There may be several bottlenecks (all of the same weight of course) in a spanning tree. In the Wikipedia MST there are two bottlenecks of weight 8.\n\nNow, take a minimum spanning tree of a given graph (there may be several MSTs, all with the same total edge weight of course) and call the maximum edge weight B. In our example B = 8.\n\nAny spanning tree that also has a bottleneck of B = 8 is an MBST. But it may not be an MST (because the total edge weight is bigger than the best possible).\n\nSo, take the Wikipedia MST and modify it (add / remove some edges) so that\n\n\nit remains a spanning tree, and\nit still doesn't use any weight > 8, yet\nyou increase the total edge weight\n\n\nFor example change just the sub-tree \"on the left\" of the Wikipedia MST (consisting of weights {2, 2, 3}) to {2, 3, 6}, thus increasing total edge weight by 4 without changing the bottleneck of 8. Bingo, you've created an MBST which is not an MST.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Generic minimum spanning tree\r\n                \r\nI am reading myself about Minimum Spanning trees in Cormen,etc. Following is the\ngeneric minimum spanning tree.\n\n\n  Assume we have a connected, undirected graph G = (V, E) witha a weight\n  function w:E->R and we wish to find a minimum spanning tree for G.\n  Here we use greedy approach. This greedy strategy is captured by the\n  following \"generic\" algorithm, which grows the minimum spanning tree\n  one edge at a time. The algorithm manages a set of edges A,\n  maintaining the following loop invariant.\n  \n  Prior to each iteration, A is subset of some minimum spanning tree.\n\n\n```\nGENERIC-MST(G,w) \nA = NULL\nwhile A is not a spanning tree \n  do find an edge (u, v) that is safe for A \n  A = A ∪ {(u, v)}\nend while\n\nreturn A\n```\n\n\nQuestions\n\n\nWhat does authore mean in invariant that \"A\" is subset of some minimum\nspanning tree?  What is \"some\" in this statement? i taught there is only one MST.\nIn above pseudocode what does author mean by \"A is not a spanning tree\"?\ni.e., how and when while loop exits? \nIn pseudo code where \"some\" minimum spanning tree, here my understading is only one.\nam i right?\n\n\nCan any one pls explain with small example? \n\nThanks!\n    ", "Answer": "\r\n1. Absolutely not. MST are not necessarily unique. For example:\n\nAll edges are of equal weight.\n\n```\nu --- v\n|     |\n|     |\nw --- x\n```\n\n\nThe above graph has 4 MSTs, by removing any edge.\n\n2. A spanning tree ```\nT = (V,e)```\n in ```\nG = (V,E)```\n is such that ```\n|e| = |V|-1```\n\n\n3. No.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum Spanning tree subgraph\r\n                \r\nI am going through all the exercises in my book for revision of a class test next week, and i am really confused about this sub-graph question. \n\nCurrently my thinking leads me to believe that since we already have a minimum spanning tree G therefore since we have sub-nodes present in that minimum spanning tree, a G' has to exist. As far as the condition goes, i'm at a bit of a loss.\n\n\n  A graph X′ is a sub-graph of graph X if the node and edge sets of X′\n  are subsets of the node and edge sets of X respectively. Let us have\n  (V,T) as a minimum spanning tree of G and  G′=(V′,E′) be a connected\n  sub-graph of G.\n  \n  (a)  Prove that (V′,E′∩T) is a sub-graph of a minimum spanning tree of G′.\n  \n  (b) Under what condition is (V′,E′∩T) a minimum spanning tree of G′?\n  Prove your claim.\n\n\nthanks in advance!\n    ", "Answer": "\r\nfor (a) \n\nI don't really get the question ... can you explain ?\n\nfor (b)\n\nI think it's if\n\nfor every ```\ne=(u,v)```\n in ```\nT```\n  if ```\nu in V'```\n and ```\nv in V'```\n then ```\ne in E```\n\n\nthen we have ```\n(V′,E′∩T)```\n is a minimum spanning tree of ```\nG'```\n.\n\nCoz :\n\n\nIf some ```\ne```\n that has ```\ne=(u,v)```\n in ```\nT```\n  if ```\nu in V'```\n and ```\nv in V'```\n but not ```\nin E'```\n, then\n```\n(V′,E′∩T)```\n is not connected at all. It certainly can't be a spanning tree of ```\nG'```\n\nIf the condition stands, but ```\n(V′,E′∩T)```\n is not a spanning tree of ```\nG'```\n, then ```\nG'```\n has a spanning tree with less cost, let's say it's ```\nTg```\n. We can construct a spanning tree ```\nT'```\n of ```\nG```\n with less cost than ```\nT```\n, by: (i) remove every ```\ne=(u,v) , u in V' and v in V' and e in T```\n from ```\nT```\n (ii) add every ```\ne=(u,v) , u in V' and v in V' and e in Tg```\n  . The resulting graph is a spanning tree of ```\nG```\n (because it's connected while having the same number of edges of ```\nT```\n) and has less cost than ```\nT```\n. So it can never happen since we already know ```\nT```\n is a minimul spanning tree of ```\nT```\n. \n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum spanning tree and cycles\r\n                \r\nCan a minimum spanning tree have a cycle IF the weighted cost of the edge which makes the cycle is 0? Since this would not change the weight could it still be considered a minimum spanning tree?\n    ", "Answer": "\r\nThis question can be answered by properly considering the definitions of a MST. Trees, by definition contain no cycles. Therefore, even a cycle that is created with a zero weighted edge could not be part of the tree. We could remove this zero-weighted edge to make it a tree again. However, to make it a MST, we would have to remove the highest-weighted edge that's part of the cycle (note that I'm assuming that the premise of your question assumes that the only thing making the spanning graph not minimal and not a tree is the cycle). \n\nYou mentioned the idea of a minimum spanning graph (MSG - that's not a real acronym because, for reasons explained, this isn't really a thing). This isn't really a useful concept because in every case except a zero-weighted edge, the MST is the MSG. All trees can be disconnected by removing just one edge. Therefore, they have no extraneous edges - so adding another edge to make it a graph will just increase the weight. The exception to this is the zero-weighted edge - adding it wouldn't add any weight. Theoretically, you could add as many zero weighted edges as you wanted to an MST to make any number of MSGs. However, this isn't a very interesting property for two reasons:\n\n\nthe MST will always be a subgraph of any MSG so most any analysis can be done of the MST - with less complexity since there's fewer edges. \nThere's basically no real world situation that's modeled by a graph where a 0-weighted edge makes sense. In a highway system, every road segment has some length. In every circuit, every wire has some resistance. Even if you discovered a zero weighted edge for any of these examples (like a wire with 0 Ohms of resistance, setting aside the physical impossibility of such a thing), you would still want the MST because the monetary cost of your zero-weighted edge is assuredly non-zero. \n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Finding a minimum spanning tree on a directed graph\r\n                \r\nWhat algorithm can I use to find a minimum spanning tree on a directed graph? I tried using a modification of Prim's algorithm, but wasn't able to make it work.\n    ", "Answer": "\r\nThe equivalent of a minimum spanning tree in a directed graph is called an optimum branching or a minimum-cost arborescence. The classical algorithm for solving this problem is the Chu-Liu/Edmonds algorithm. There have been several optimized implementations of this algorithm over the years using better data structures; the best one that I know of uses a Fibonacci heap and runs in time O(m + n log n) and is due to Galil et al.\n\nHope this helps!\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Difference between Spanning tree & Minimum spanning tree\r\n                \r\nI have been reading the concept of spanning trees & its types. This is what I have understood:\n\nSpanning tree: a subset of Graph G with the minimum number of edges connecting all vertices\n\nMinimum Spanning tree: It is a spanning tree where the summation of edge weights is minimum.\n\nNow, does this mean, while retrieving an MST, \n\n\nif we come across a path in G which has more edges (as compared to some other path) but least weight on the summation of edge weights(as compared to all other paths possible), we won't be considering it as an MST? \nDoes the concept of MST comes into play only if we have multiple Spanning trees for G? else Spanning tree=MST?\n\n\nThanks for the help!!\n    ", "Answer": "\r\n\n  \n  if we come across a path in G which has more edges (as compared to some other path) but least weight on the summation of edge weights(as compared to all other paths possible), we won't be considering it as an MST?\n  \n\n\nI assume that by \"path\", you meant to write \"tree\"? (A \"path\" is a completely different concept: it has just two endpoints, with no branching structure.)\n\nA tree is a connected graph with no cycles, so every tree with n vertices has exactly n−1 edges. So if a graph has n vertices, then every spanning tree of that graph must have exactly n−1 edges. So if you have a subgraph with more than n−1 edges, then it's not a tree, so it's not a spanning tree, so — as you've surmised — it's not a minimum spanning tree.\n\nBut note that if a subgraph connects all the vertices, that subgraph will necessarily contain at least one spanning tree; and unless there are negative-weight edges, those spanning trees will have a weight less than or equal to that of the subgraph. So although your example isn't a minimum spanning tree, it may well contain a minimum spanning tree.\n\n\n\n\n  \n  Does the concept of MST comes into play only if we have multiple Spanning trees for G? else Spanning tree=MST?\n  \n\n\nIf a graph has only one spanning tree, then that spanning tree is a minimum spanning tree, yes. But note that this only happens if the graph itself is a tree (in which case it's its own minimum spanning tree); otherwise it will certainly have multiple spanning trees.\n\nOf course, even if it has multiple spanning trees, it's possible that they all have the same weight anyway, in which case they'll all be minimum spanning trees.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Geotools minimum spanning tree\r\n                \r\nIs there an implementation of prim's algorithm or any other algorithm in geotools graph package for solving the minimum spanning tree problem?\n    ", "Answer": "\r\nThe short answer is no, it is not implemented. But from a quick look at the algorithm it should be possible to implement in GeoTools' graph module. Check out the code in ```\norg.geotools.graph.traverse```\n and ```\norg.geotools.graph.traverse.standard```\n. \n\nIf you get one working the PR's are always welcome.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum spanning tree algorithm in parallel\r\n                \r\nI know some minimum spanning tree algorithms: Boruvka, Prim and Kruskal. Which of them can be implemented in parallel fashion?\n\nThanks!\n    ", "Answer": "\r\nOut of these 3 algorithms, only Boruvka algorithm might be easily parallelized.\n\nQuotation from the description of Boruvka algorithm on algoritmy.net:\n\n\n  A significant advantage of the Borůvka's algorithm is that is might be easily parallelized, because the choice of the cheapest outgoing edge for each component is completely independent of the choices made by other components.\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum spanning tree in python\r\n                \r\nI'm having problems calculating the minimum spanning tree of a simple graph using the following python snippet. It is trivial to do it by hand and I've included an image of the graph and the minimum spanning tree from the textbook.\n\n```\nimport numpy as np\nimport pandas as pd\nimport scipy as sp\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import minimum_spanning_tree\n\nimport networkx as nx\nimport matplotlib.pyplot as plt\n%matplotlib inline\nfriendships = [\n    ('A', 'B',{'weight':2}),\n    ('A', 'E',{'weight':10}),\n    ('A', 'D',{'weight':1}),\n    ('A', 'C',{'weight':4}),\n    ('B', 'D',{'weight':1}),\n    ('C', 'D',{'weight':4}),\n    ('D', 'E',{'weight':7}),\n    ('D', 'F',{'weight':10}),\n    ('E', 'F',{'weight':8}),\n    ('D', 'G',{'weight':7}),\n    ('C', 'G',{'weight':3}),\n    ('E', 'G',{'weight':5}),\n\n]\n\nG = nx.MultiGraph()\nG.add_edges_from(friendships)\nX = nx.to_numpy_matrix(G)\nnx.draw(G, with_labels=True, font_weight='bold')\n\nX = csr_matrix(X)\nTcsr = minimum_spanning_tree(X)\nTcsr.toarray().astype(int)\n```\n\n\nIf you run the code, you get \"A-B-G-F-E-C-D\". More like a list.\n\nVisually, the graph and the answer from the book are the following:\n\n\n\n\n    ", "Answer": "\r\nA minimum spanning tree is a subset of the edges of the original graph, so \"A-B-G-F-E-C-D\" cannot be a solution (unless the solution is a path).\nYou are missing the edge (F, G) in the friendships list. Now you will obtain:\n```\n  (0, 3)    1.0\n  (0, 4)    4.0\n  (1, 3)    1.0\n  (2, 6)    5.0\n  (4, 6)    3.0\n  (5, 6)    3.0\n```\n\nand following the order of the nodes in the friendships adjacency list, this is equivalent to:\n```\n  (A, D)    1.0\n  (A, C)    4.0\n  (B, D)    1.0\n  (E, G)    5.0\n  (C, G)    3.0\n  (F, G)    3.0\n```\n\nNote that, the minimum spanning tree of a graph is not unique. Rather than checking the edges of the obtained tree, you need to check that the weight of the tree is the same as in the example of the book, i.e., 17.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum spanning tree\r\n                \r\nI have searched a lot for an answer to the following question:\n\nGiven is a connected undirect graph G = (V, E) with weight function w: E->R.\n\nT1 is a minimum spanning tree of G with a weight of W1. \n\nAdd to the graph G a new edge with a weight of w(e) (the vertex connects two existing vertices in G).\n\nT2 is a minimum spanning tree of the updated graph with a weight of W2. \n\nProve or disprove each statement:\n\n\nIf W1 = W2, the edge e is on a cycle with the weight of each edge on that cycle at most w(e).\nW2 >= W1 - w(e)\nIf W2 < W1, the new edge e is on cycle with the weight of each edge on that cycle (except for e) larger than w(e).\n\n    ", "Answer": "\r\nFirst, note the following:\n\nSince ```\nG```\n is a connected graph, adding an edge ```\ne```\n between two existing vertices will create a cycle in ```\nG```\n.\n\nStatement 1: We have that W1 = W2. By contradiction. Assume that there is a cycle in G with both ```\ne```\n and an edge ```\ne'```\n with ```\nw(e') > w(e)```\n. Since both edges ```\ne```\n and ```\ne'```\n are on the same cycle, we can remove one of them and still get a spanning tree. If we remove ```\ne'```\n, we get that ```\nW2 = W1 - w(e') + w(e)```\n. Since ```\nw(e') > w(e)```\n, this implies ```\nW2 < W1```\n, which contradicts the premis. It follows that the statement is true.\n\nStatement 3 follows directly from the above.\n\nStatement 2 is false, since we can give a counter example. Assume a graph ```\nG = (V, E, w)```\nwith ```\nV = {A, B, C}```\n and edges ```\nE = {e1 = (A, B), e2 = (A, C)}```\n with ```\nw(e1) = 10```\nand ```\nw(e2) = 11```\n. ```\nG```\n is a minimum spanning tree with weight ```\nW1 = 21```\n. Now add the edge ```\ne = (B, C)```\n with weight ```\nw(e) = 1```\n. The minimum spanning tree now consists of the edges ```\ne1```\n and ```\ne```\n and has a weight of ```\nW2 = 11```\n. Plug those values into the equation ```\nW2 >= W1 -w(e)```\n: ```\n11 >= 21 - 1```\n, which is obviously not true, thus providing a counterexample to the claim. \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Use Dijkstra's to find a Minimum Spanning Tree?\r\n                \r\nDijkstra's is typically used to find the shortest distance between two nodes in a graph. Can it be used to find a minimum spanning tree? If so, how?\n\nEdit: This isn't homework, but I am trying to understand a question on an old practice exam.\n    ", "Answer": "\r\nThe answer is no.  To see why, let's first articulate the question like so:\n\nQ: For a connected, undirected, weighted graph ```\nG = (V, E, w)```\n with only nonnegative edge weights, does the predecessor subgraph produced by Dijkstra's Algorithm form a minimum spanning tree of G?\n\n(Note that undirected graphs are a special class of directed graphs, so it is perfectly ok to use Dijkstra's Algorithm on undirected graphs.  Furthermore, MST's are defined only for connected, undirected graphs, and are trivial if the graph is not weighted, so we must restrict our inquiry to these graphs.)\n\nA: Dijkstra's Algorithm at every step greedily selects the next edge that is closest to some source vertex s.  It does this until s is connected to every other vertex in the graph.  Clearly, the predecessor subgraph that is produced is a spanning tree of ```\nG```\n, but is the sum of edge weights minimized?\n\nPrim's Algorithm, which is known to produce a minimum spanning tree, is highly similar to Dijkstra's Algorithm, but at each stage it greedily selects the next edge that is closest to any vertex currently in the working MST at that stage.  Let's use this observation to produce a counterexample.\n\nCounterexample:  Consider the undirected graph ```\nG = (V, E, w)```\n where\n\n```\nV = { a, b, c, d }```\n\n\n```\nE = { (a,b), (a,c), (a,d), (b,d), (c,d) }```\n\n\n```\nw = {\n    ( (a,b) , 5 )\n    ( (a,c) , 5 )\n    ( (a,d) , 5 )\n    ( (b,d) , 1 )\n    ( (c,d) , 1 ) \n}```\n\n\nTake ```\na```\n as the source vertex.\n\n\n\nDijkstra's Algorithm takes edges ```\n{ (a,b), (a,c), (a,d) }```\n.\nThus, the total weight of this spanning tree is 5 + 5 + 5 = 15.\n\nPrim's Algorithm takes edges ```\n{ (a,d), (b,d), (c,d) }```\n.\nThus, the total weight of this spanning tree is 5 + 1 + 1 = 7.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "dynamic minimum spanning tree\r\n                \r\nI want to make a dynamic minimum spanning tree. I have an existing MS tree over n vertices and I add one more vertex and edges to all the existing vertices from this new vertex. How can I update the MST for the new graph efficiently? O(n) would be optimal. Can I also make delete vertex operation efficient?\n    ", "Answer": "\r\n```\nO(n log n)```\n using Kruskal's algorithm. The key idea is any edges not used in the original MST will not be used in the new MST either. So just sort the ```\nn```\n new edges ```\nO(n log n)```\n, merge this sorted list with the list of edges of the old MST (which you kept in sorted order, right?) ```\nO(n)```\n, then run Kruskal's algorithm anew on the resulting sorted list of edges ```\nO(n)-ish```\n.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "regenerating Minimum Spanning Tree in linear time?\r\n                \r\nIf there is a graph G with V vertices and E edges and I already know its minimum spanning tree T of G, and then if some of the edges from E are taken and their weights are increased by say 50, these edges may or may not be in the minimum spanning tree. Keeping the above scenario in mind is there a way to regenerate a new minimum spanning tree in linear time ?\nnote: the number of edges whose weights have been modified are only 5.\n    ", "Answer": "\r\nYou may want to take a look at the SO question  here . I believe this is directly addressed in this paper by Szpira & Pan and can be done in O(n) time .\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Julia - Plotting minimum spanning tree with GraphPlots\r\n                \r\nI'm using the package LightGraphs.jl to generate a minimum spanning tree:\n```\nLightGraphs.kruskal_mst(g)\n```\n\nThe output is an array of edges:\n```\n4-element Array{SimpleWeightedEdge{Int64,Float64},1}:\nEdge 6 => 9 with weight 1.0\nEdge 8 => 9 with weight 1.\nEdge 9 => 10 with weight 1.0\nEdge 6 => 11 with weight 1.0\n```\n\nMy question is then how to plot this spanning tree?\n    ", "Answer": "\r\nI was able to figure it out. The best way to do this is to create a new graph, and\nthen use the output from ```\nkruskal_mst()```\n to populate the new graph. Here is an example:\n```\ng_mst = SimpleWeightedGraph(size(g)[1]) #Create a new graph\nfor ew in kruskal_mst(g)\n   add_edge!(g_mst,ew.src,ew.dst,ew.weight)\nend\ngplot(g_mst)\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "All minimum spanning trees implementation\r\n                \r\nI've been looking for an implementation (I'm using networkx library.) that will find all the minimum spanning trees (MST) of an undirected weighted graph.\n\nI can only find implementations for Kruskal's Algorithm and Prim's Algorithm both of which will only return a single MST.\n\nI've seen papers that address this problem (such as Representing all minimum spanning trees with applications to counting and generation) but my head tends to explode someway through trying to think how to translate it to code.\n\nIn fact i've not been able to find an implementation in any language!\n    ", "Answer": "\r\nI don't know if this is the solution, but it's a solution (it's the graph version of a brute force, I would say):  \n\n\nFind the MST of the graph using kruskal's or prim's algorithm. This should be O(E log V).\nGenerate all spanning trees. This can be done in ```\nO(Elog(V) + V + n) for n = number of spanning trees```\n, as I understand from 2 minutes's worth of google, can possibly be improved.\nFilter the list generated in step #2 by the tree's weight being equal to the MST's weight. This should be O(n) for n as the number of trees generated in step #2.\n\n\nNote: Do this lazily! Generating all possible trees and then filtering the results will take O(V^2) memory, and polynomial space requirements are evil - Generate a tree, examine it's weight, if it's an MST add it to a result list, if not - discard it.\nOverall time complexity: ```\nO(Elog(V) + V + n) for G(V,E) with n spanning trees```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Differences between Minimum Spanning Tree and Shortest Path Tree\r\n                \r\nHere is an exercise:\n\n\n  Either prove the following or give a counterexample:\n  \n  (a)  Is the path between a pair of vertices in a minimum spanning tree\n  of an undirected graph necessarily the shortest (minimum weight) path?\n  \n  (b)  Suppose that the minimum spanning tree of the graph is unique. Is\n  the path between a pair of vertices in a minimum spanning tree of an\n  undirected graph necessarily the shortest (minimum weight) path?\n\n\nMy Answer is\n\n(a)\n\nNo, for example, for graph 0, 1, 2,  0-1 is 4, 1-2 is 2, 2-0 is 5, then 0-2’s true shortest path is 5, but the mst is 0-1-2, in mst, 0-2 is 6\n\n(b)\n\nMy problem comes into this (b). \n\nI don't understand how ```\nwhether the MST is unique```\n can affect the shortest path.\n\nFirst, my understanding is that when the weights of edges are not distinct, multiple MST may exist at the same time, right?\n\nSecond, even if MST is unique, the answer of (a) above still applies for (b), right?\n    ", "Answer": "\r\nSo lets take a look at a very simple graph:\n\n```\n(A)---2----(B)----2---(C)\n \\                    /\n  ---------3----------\n```\n\n\nThe minimum spanning tree for this graph consists of the two edges ```\nA-B```\n and ```\nB-C```\n. No other set of edges form a minimum spanning tree.\n\nBut of course, the shortest path from ```\nA```\n to ```\nC```\n is ```\nA-C```\n, which does not exist in the MST.\n\nEDIT\n\nSo to answer part (b) the answer is no, because there is a shorter path that exists that is not in the MST.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Add edges to nodes using Minimum Spanning Tree\r\n                \r\nhelp me i want to add edges to nodes using minimum spanning tree\n\n```\n   %clc;\n%clear all;\nclose all;\nX=imread('d3.jpg');\nimfinfo('d3.jpg')\nfigure,imshow(X)\n\nb = imresize(X,[100,100]);\nsi = size(b,1);\nsj = size(b,2);\nfigure;imshow(b);\n\n% Binarization\nth = graythresh(b);\nI = im2bw(b,th);\n\nw = 5;\nh = 5;\nc=si/w;\nr=sj/h;\nkl=bwmorph(~I,'thin',inf);\nfigure,imshow(kl)\n\nR(:,:)=kl(:,:);\nI=1;\nU1=w;\nJ=1;\nU2=h;\nE=1;\nfor i=1:r\n  for j=1:c\nB(I:U1,J:U2)=R(I:U1,J:U2);\n[x,y]=find(B==1);\nCX=mean(x);\nCY=mean(y);\nCXX(E)=CX;\nCYY(E)=CY;\nT(I:U1,J:U2)=B(I:U1,J:U2);\nJ=J+w;\nU2=U2+h;\nE=E+1;\nclear B x y\n %CYY(isnan(CYY)) = [];\n %CXX(isnan(CXX)) = [];\n  end\n\nI=I+w;\nU1=U1+h;\nJ=1;\nU2=h;\n\nend\n%kl(isnan(kl(:,1)),:) = [];\nimshow(R)\nhold on\n\nhold on\nplot(CYY,CXX,'.c')\nhold off\nr = imread('empty.jpg');\nre = imresize(r,[100,100]);\nfigure,imshow(re)\nhold on\nhold on\nplot(CYY,CXX,'.k','Markersize',8);\nhold off\n```\n\n\nthis my code i am getting nodes but i want to connect to nodes using minimum spanning\nthis is my output image i want to add edges to this image using minimum spanning tree\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Kruskal Minimum Spanning Tree\r\n                \r\nI'm using Ubuntu 14.04. I'm trying to run CGAL (version 4.5 beta1) with Boost Graph Library (version 1.54) Kruskal Minimum Spanning Tree with my input. The code is exactly in this url: https://doc.cgal.org/4.2/CGAL.CGAL.CGAL-and-the-Boost-Graph-Library/html/BGL_triangulation_2_2emst_8cpp-example.html\n\nMy input is \n\n```\n0. 0.\n1. 1.\n0. 2.\n1. 0.\n```\n\n\nBut when I run it, the output is not nice. This is the output of edges in minimum spanning tree (EMST). Each line is an edge which is a pair of points.\n\n```\n(0 6.95331e-310) - (0 0)\n(1 1) - (1 0)\n(1 1) - (0 2)\n```\n\n\nHowever, when I print the Delaunay Triangulation, the output is as expected.\n\n```\n(0 0) - (0 2)\n(0 0) - (1 1)\n(1 1) - (0 2)\n(1 1) - (1 0)\n(0 0) - (1 0)\n```\n\n\nI think it should be (0,0) in the first line in output of EMST. Moreover, I think the EMST should contain ```\n(0 0) - (1 0)```\n rather than ```\n(0 0) - (0 0)```\n. I don't know the root cause and how to fix this problem.\n    ", "Answer": "\r\nI quote the answer to another question:\n\n\n  This was a Boost bug, and is already fixed: if anyone else sees\n  this behavior from 1.54, just update to 1.55 or newer.\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Fast question about minimum spanning trees\r\n                \r\nIf any edge from a spanning tree T0 is contained in some minimum spanning tree T*, does this imply that T0 is also a minimum spanning tree ?\n\nRight now, I'm trying to draw on paper some graphs to prove that it doesn't. Please correct me if it does, or help me find an example if it doesn't.\n\nThanks in advance.\n    ", "Answer": "\r\nA triangle with edge weights 2,2,1.\n\nEDIT:\n\nThere are three different spanning trees with costs 3 (1+2),3 (2+1) and 4 (2+2) in this graph. all the edges from the spanning tree with cost 4 are contained in one of the minimum spanning trees with cost 3, and it is NOT minimal.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Multiple minimum spanning tree graph\r\n                \r\nI am stuck over a condition. I want to know what are the cases where a graph can have multiple minimum spanning tree?\nCan anyone help me with this?\n    ", "Answer": "\r\nA graph can have more than one MST in the case where both trees have the same overall weight but different paths to complete the tree. \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum Spanning Tree quick graph\r\n                \r\nI want to find the minimum spanning tree of the following graph using quick graph. I Went through the manual provided but I don't really understand how to do it.\nHere is my code:\n\n```\n static void Main(string[] args)\n        {\n\n        var g = new UndirectedGraph<int, TaggedUndirectedEdge<int,int>>();\n\n        var e1 = new TaggedUndirectedEdge<int, int>(1, 2, 57);\n        var e2 = new TaggedUndirectedEdge<int, int>(1, 4, 65);\n        var e3 = new TaggedUndirectedEdge<int, int>(2, 3, 500);\n        var e4 = new TaggedUndirectedEdge<int, int>(2, 4, 1);\n        var e5 = new TaggedUndirectedEdge<int, int>(3, 4, 78);\n        var e6 = new TaggedUndirectedEdge<int, int>(3, 5, 200);\n\n        g.AddVerticesAndEdge(e1);\n        g.AddVerticesAndEdge(e2);\n        g.AddVerticesAndEdge(e3);\n        g.AddVerticesAndEdge(e4);\n        g.AddVerticesAndEdge(e5);\n        g.AddVerticesAndEdge(e6);\n\n        foreach (var v in g.Edges)\n            Console.WriteLine(v);\n}\n```\n\n\nThank you for your help.\n    ", "Answer": "\r\n@daryal beat me to it - my version is:\n\n```\nvar mst = g.MinimumSpanningTreePrim(e => e.Tag).ToList();  \n```\n\n\n\n\n\"Use the source Luke\" - I looked at MinimumSpanningTreeTest.cs, test Prim12273\n\n(Also you could look at this question on Lambda's / Delegates for a better understanding of basic function pointers)\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum Spanning Tree Algorithm\r\n                \r\nHello I am new to the Algorithms and trying to understand the Minimum Spanning Trees.\n\nI study the \"Introduction to Algorithms\" book by Cormen,Leiserson,Rivest and Stein. I have had a hard problem in understanding the sentence \".. a cut respects a set A of edges if no edge in A crosses the cut.\"\n\nLet me clear my understanding by putting the pictures from the given example.\nA minimum spanning tree for a connected graph.\n\n1 way of viewing a cut (S,V-S) of the previous graph.\n\nSo my question is when we cut the graph as shown by the second figure shouldn't we also shade the edge (d,e) since it does not cross the cut ?\n\nI would appreciate if you clarify this for me.\n    ", "Answer": "\r\nThis is kruskal's MST algorithm i think. Cut just partitions every subtree from the rest of the subtrees. We need to use the idea of the cut because when we join two subtrees we want no cycle and also the edge with minimum cost between those two subtrees.\n\nIn you image the cost of (d,e) is 9 so it's not a subtree. You can think of it as a not evaluated edge.  Your subtrees are (a,b) and (i,c,f,g,h) so a cut must differentiate these subtrees from other edges.\n\nThe shaded edges means that they are for sure in MST because they have minimum cost. \n\nHere is just painted picture of your algorithm:\n\nIn the first iteration you get first cut black because the edge (g,h) has the minimum cost. Then you get red cut because after (g,h) gf has the minimum cost and because these two subtrees are attached to each other we use one cut. and so on ... I hope you can execute it further.You can see here visualization how Kruskal's algorithm works.\n\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum product spanning tree\r\n                \r\nIn the ```\nminimum product spanning tree```\n problem, the cost of a tree is the product of all the edge weights in the tree, instead of the sum of the weights. \nYou may assume that all edges have positive weight. I would like to get answers for the following problems.\n\n(1) Give a graph whose minimum product spanning tree is different than the minimum weight spanning tree.\n\n(2) Give an efficient algorithm to compute the minimum product spanning tree. (Hint: think logarithms).\n    ", "Answer": "\r\nThe problem of Minimum Product Spanning tree can be solved by converting the tree by taking the logarithm of edge weights and then finding the MST of this modified tree. \n\nRemember the property of Logarithms, ```\nlog(ab) = log(a) + log(b)```\n. Thus the Minimum product spanning tree can be converted to an Minimum Cost Spanning Tree problem. \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Cutting the minimum spanning tree\r\n                \r\nI'm doing a Java project that requires the following : \n\nInput: A gray-scale image with P pixels, and a number R\n\nOutput: An image segmented into R regions \n\n\nMap the image onto a primal weighted graph.\nFind a minimum spanning tree of the graph.\nCut the minimum spanning tree at the R – 1 most costly edges.\nAssign the average tree vertex weight to each vertex in each tree in the forest\nMap the partition onto a segmentation image\n\n\nI did the first two steps:\n\n\nI mapped the image onto a weighted graph by ```\nJGraphT```\n.\nI mapped each pixel onto a vertex of the graph in a one-to-one relationship with the pixel intensity assigned to the vertex weight, and the edges are the nearest neighbors of each vertex with weights of the absolute value of the difference between the weights of the vertices.\nThen I found the minimun spanning trees by ```\nKruskalMinimumSpanningTree```\n.\n\n\nBut I am stuck in steps 3 and 4. \nWhat does it mean to cut the MST that I found at the ```\nR – 1```\n most costly edges and then assign the average tree vertex weight?\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum Spanning Tree with leaves only?\r\n                \r\nI am asked to write an algorithm that finds the Minimum Spanning Tree in a graph G, but with the condition that each vertex of G be a leave in the spanning Tree T.\nHow can this be possible if the graph has more than 2 elements? Suppose G contains the vertices a,b and c, the Spanning tree will might something like a--b--c, so in this case b is not a leaf.\n\nI am not looking for a solution to the algorithm, I only want to understand how a Spanning Tree can be composed exclusively of leaves.\n\nHere is the exact wording of the question\n\n\nThanks for the help\n    ", "Answer": "\r\nThe question states that S is a subset of the vertices V in the graph. There may be non-leaf nodes. However, you have to make sure that these internal nodes are not in S. If S would be equal to V you'd be right.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "KRUSKAL MINIMUM-SPANNING-TREE\r\n                \r\nI have a graph G(V,E), and i have to computes a MST (minimum spanning tree) containing e (edge belong E), if one exists.\nI was thinking that I could use Kruskal algorithm inserting the arc e at the top of the list in order to make the algorithm choose this arc first and build the tree that includes e.\nIs it the right way of reasoning?\nIf a MST including e doesn't exist is the arc ignored?\n\nthis is the java code I want to change:\n\n\n```\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\n\npublic class KrushkalMST {\n    static class Edge {\n        int source;\n        int destination;\n        int weight;\n\n        public Edge(int source, int destination, int weight) {\n            this.source = source;\n            this.destination = destination;\n            this.weight = weight;\n        }\n    }\n\n    static class Graph {\n        int vertices;\n        ArrayList<Edge> allEdges = new ArrayList<>();\n\n        Graph(int vertices) {\n            this.vertices = vertices;\n        }\n\n        public void addEgde(int source, int destination, int weight) {\n            Edge edge = new Edge(source, destination, weight);\n            allEdges.add(edge); //add to total edges\n        }\n\n        public void kruskalMST(){\n            PriorityQueue<Edge> pq = new PriorityQueue<>(allEdges.size(), Comparator.comparingInt(o -> o.weight));\n\n            //add all the edges to priority queue, //sort the edges on weights\n            for (int i = 0; i <allEdges.size() ; i++) {\n                pq.add(allEdges.get(i));\n            }\n\n            //create a parent []\n            int [] parent = new int[vertices];\n\n            //makeset\n            makeSet(parent);\n\n            ArrayList<Edge> mst = new ArrayList<>();\n\n            //process vertices - 1 edges\n            int index = 0;\n            while(index<vertices-1){\n                Edge edge = pq.remove();\n                //check if adding this edge creates a cycle\n                int x_set = find(parent, edge.source);\n                int y_set = find(parent, edge.destination);\n\n                if(x_set==y_set){\n                    //ignore, will create cycle\n                }else {\n                    //add it to our final result\n                    mst.add(edge);\n                    index++;\n                    union(parent,x_set,y_set);\n                }\n            }\n            //print MST\n            System.out.println(\"Minimum Spanning Tree: \");\n            printGraph(mst);\n        }\n\n        public void makeSet(int [] parent){\n            //Make set- creating a new element with a parent pointer to itself.\n            for (int i = 0; i <vertices ; i++) {\n                parent[i] = i;\n            }\n        }\n\n        public int find(int [] parent, int vertex){\n            //chain of parent pointers from x upwards through the tree\n            // until an element is reached whose parent is itself\n            if(parent[vertex]!=vertex)\n                return find(parent, parent[vertex]);;\n            return vertex;\n        }\n\n        public void union(int [] parent, int x, int y){\n            int x_set_parent = find(parent, x);\n            int y_set_parent = find(parent, y);\n            //make x as parent of y\n            parent[y_set_parent] = x_set_parent;\n        }\n\n        public void printGraph(ArrayList<Edge> edgeList){\n            for (int i = 0; i <edgeList.size() ; i++) {\n                Edge edge = edgeList.get(i);\n                System.out.println(\"Edge-\" + i + \" source: \" + edge.source +\n                        \" destination: \" + edge.destination +\n                        \" weight: \" + edge.weight);\n            }\n        }\n    }\n    public static void main(String[] args) {\n            int vertices = 6;\n            Graph graph = new Graph(vertices);\n            graph.addEgde(0, 1, 4);\n            graph.addEgde(0, 2, 3);\n            graph.addEgde(1, 2, 1);\n            graph.addEgde(1, 3, 2);\n            graph.addEgde(2, 3, 4);\n            graph.addEgde(3, 4, 2);\n            graph.addEgde(4, 5, 6);\n            graph.kruskalMST();\n    }\n}\n```\n\n    ", "Answer": "\r\nIf you are planning on implementing Kruskal algorithm you are going to have to implement methods union and find. These methods are creating trees structure. First you initialize every node as root of its tree and than you are using union to merge them if it doesnt create a cycle.\n\nSo to answer your question just create your desired set by union find, before running the algorithm.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Construct a minimum spanning tree covering a specific subset of the vertices\r\n                \r\nI have an undirected, positive-edge-weight graph (V,E) for which I want a minimum spanning tree covering a subset k of vertices V (the Steiner tree problem).\n\nI'm not limiting the size of the spanning tree to k vertices; rather I know exactly which k vertices must be included in the MST.\n\nStarting from the entire MST I could pare down edges/nodes until I get the smallest MST that contains all k.\n\nI can use Prim's algorithm to get the entire MST, and start deleting edges/nodes while the MST of subset k is not destroyed; alternatively I can use Floyd-Warshall to get all-pairs shortest paths and somehow union the paths. Are there better ways to approach this?\n    ", "Answer": "\r\nThere's a lot of confusion going on here. Based on what the OP says:\n\n\n  I'm not limiting the size of the spanning tree to k vertices; rather I know exactly which k vertices must be included in the MST.\n\n\nThis is the Steiner tree problem on graphs. This is not the k-MST problem. The Steiner tree problem is defined as such:\n\n\n  Given a weighted graph G = (V, E), a subset S ⊆ V of the vertices,\n  and a root r ∈ V , we want to find a minimum weight tree which connects all the vertices in S to\n  r. 1 \n\n\nAs others have mentionned, this problem is NP-hard. Therefore, you can use an approximation algorithm.\n\nEarly/Simple Approximation Algorithms\n\nTwo famous methods are Takahashi's method and Kruskal's method (both of which have been extended/improved by Rayward-Smith):\n\n\nTakahashi H, Matsuyama A: An approximate solution for the Steiner problem in graphs. Math. Jap 1980, 24:573–577.\nKruskal JB: On the Shortest Spanning Subtree of a Graph and the Traveling Salesman Problem. In Proceedings of the American Mathematical Society, Volume 7. ; 1956:48–50.\nRayward-Smith VJ, Clare A: On finding Steiner vertices. Networks 1986, 16:283–294.\n\n\n\n\nShortest path approximation by Takahashi (with modification by Rayward-Smith)\n\n\n\n\n\nKruskal's approximation algorithm (with modification by Rayward-Smith)\n\n\n\n\n\nModern/More Advanced Approximation Algorithms\n\nIn biology, more recent approaches have treated the problem using the cavity method, which has led to a \"modified belief propagation\" method that has shown good accuracy on large data sets:\n\n\nBayati, M., Borgs, C., Braunstein, A., Chayes, J., Ramezanpour, A., Zecchina, R.: Statistical mechanics of steiner trees. Phys. Rev. Lett. 101(3), 037208 (2008) 15.\nFor an application: Steiner tree methods for optimal sub-network identification: an empirical study. BMC Bioinformatics. BMC Bioinformatics 2013 30;14:144. Epub 2013 Apr 30.\n\n\nIn the context of search engine problems, approaches have focused on efficiency for very large data sets that can be pre-processed to some degree.\n\n\nG. Bhalotia, A. Hulgeri, C. Nakhe, S. Chakrabarti, and S. Sudarshan. Keyword Searching and Browsing in Databases using BANKS. In ICDE, pages 431–440.\nG. Kasneci, M. Ramanath, M. Sozio, F. M. Suchanek, and G. Weikum. STAR: Steiner-tree approximation in relationship graphs. In ICDE’09, pages 868–879, 2009\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to find maximum spanning tree?\r\n                \r\nDoes the opposite of Kruskal's algorithm for minimum spanning tree work for it? I mean, choosing the max weight (edge) every step?\n\nAny other idea to find maximum spanning tree?\n    ", "Answer": "\r\nYes, it does.\n\n\n  One method for computing the maximum weight spanning tree of a network G –\n  due to Kruskal – can be summarized as follows.\n  \n  \n  Sort the edges of G into decreasing order by weight. Let T be the set of edges comprising the maximum weight spanning tree. Set T = ∅.\n  Add the first edge to T.\n  Add the next edge to T if and only if it does not form a cycle in T. If\n  there are no remaining edges exit and report G to be disconnected.\n  If T has n−1 edges (where n is the number of vertices in G) stop and\n  output T . Otherwise go to step 3.\n  \n\n\nSource: https://web.archive.org/web/20141114045919/http://www.stats.ox.ac.uk/~konis/Rcourse/exercise1.pdf.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Sollin's Minimum Spanning Tree Algorithm\r\n                \r\nYes this is homework. I was wondering if someone could explain the process of Sollin's (or Borůvka's) algorithm for determining a minimum spanning tree. Also if you could explain how to determine the number of iterations in the worst case, that would be great.\n    ", "Answer": "\r\nOn a top level, the algorithm works as follows:\n\n\nMaintain that you have a number of spanning trees for some subgraphs. Initially, every vertex of the graph is a m.s.t. with no edges.\nIn each iteration, for each of your spanning trees, find a cheapest edge connecting it to another spanning tree. (This is a simplification.)\n\n\nThe worst case in terms of iterations is that you always merge pairs of trees. In that case, the number of trees you have will halve in each iteration, so the number of iterations is logarithmic in the number of nodes.\n\nAlso note that there is a special trick involved in choosing the edges to add: if you were not careful, you might introduce a circle when tree A connects to tree B, tree B connects to tree C and tree C connects to tree A. (This can only happen if all three edges chosen have the same weight. The trick is to have an arbitrary but fixed tie-breaker, like a fixed order of the edges.)\n\nSo there, that's my back-of-index-card overview.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Neo4j Minimum Spanning Tree not working properly\r\n                \r\nI have 5 nodes link to each other with bi-direction. I'm trying to find minimum cost to traverse all the nodes. But the result seems quite confusing:\nPlease refer to below [Nodes linkage][1] diagram.\n[1]: https://i.stack.imgur.com/hzCbH.png\nAfter running minimum spanning tree algorithm\n```\nMATCH (n:Test {eqpId: 'EqpId001'})\nCALL gds.alpha.spanningTree.minimum.write({\n  nodeProjection: 'Test',\n  relationshipProjection: {\n                    LINK: {\n                            type: 'LINK',\n                            properties: 'cost',\n                            orientation: 'UNDIRECTED'\n                          }\n                  },\n  startNodeId: id(n),\n  relationshipWeightProperty: 'cost',\n  writeProperty: 'MINST',\n  weightWriteProperty: 'writeCost'\n})\nYIELD createMillis, computeMillis, writeMillis, effectiveNodeCount\nRETURN createMillis, computeMillis, writeMillis, effectiveNodeCount;\n```\n\nBelow is the result:\n[Minimum spanning tree result][2]\n[2]: https://i.stack.imgur.com/oBLq7.png\n```\n\"EqpId001\"  \"EqpId003\"  30.0\n\"EqpId003\"  \"EqpId002\"  25.0\n\"EqpId001\"  \"EqpId004\"  30.0\n\"EqpId004\"  \"EqpId005\"  32.0\n```\n\nThe starting node is EqpId001, how come it jump to EqpId001 out of blue?\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "The fastest minimum spanning tree algorithm\r\n                \r\nhttp://en.wikipedia.org/wiki/Minimum_spanning_tree\n\nI'm looking to benchmark my minimum spanning tree algorithm against the best of the best.\nDoes someone know where I can find a C++ implementation of these algorithms? I binged and googled the and didn't find anything. If these algorithms are the best, surely there must be a C++ implementation somewhere?\n\n\n  The fastest minimum spanning tree\n  algorithm to date was developed by\n  David Karger, Philip Klein, and Robert\n  Tarjan, who found a linear time\n  randomized algorithm based on a\n  combination of Borůvka's algorithm and\n  the reverse-delete algorithm.[2][3]\n  The fastest non-randomized algorithm,\n  by Bernard Chazelle, is based on the\n  soft heap, an approximate priority\n  queue.[4][5] Its running time is O(m\n  α(m,n)), where m is the number of\n  edges, n is the number of vertices and\n  α is the classical functional inverse\n  of the Ackermann function. The\n  function α grows extremely slowly, so\n  that for all practical purposes it may\n  be considered a constant no greater\n  than 4; thus Chazelle's algorithm\n  takes very close to linear time. If\n  the edge weights are integers with a\n  bounded bit length, then deterministic\n  algorithms are known with linear\n  running time.[6] Whether there exists\n  a deterministic algorithm with linear\n  running time for general weights is\n  still an open question. However, Seth\n  Petie and Vijaya Ramachandran have\n  found a provably optimal deterministic\n  minimum spanning tree algorithm, the\n  computational complexity of which is\n  unknown.[7]\n\n\nI already test against Boost C++'s graph algorithms.\n    ", "Answer": "\r\nWhen the Wikipedia page says \"the fastest minimum spanning tree algorithm,\" what they mean is the algorithm with the lowest asymptotic bounds -- in this case, O(m α(m,n)), with m, n, and α defined as in the quote you pasted.  Put simply, this means that for very large input values, the amount of time taken will always be bounded by C*m*α(m,n), for some value of C.  But note that C might be very large -- i.e., this algorithm might be slower than others when applied to smaller input values, even though it's faster than others for very large input values.\n\nWhen comparing the asymptotic bounds of two algorithms, there's no \"testing\" to see which is faster -- you just prove the asymptotic bounds of each algorithm, and see which one is lower.  (\"Asymptotic\" refers to the behavior as the input size goes to infinity -- and it's hard to run tests with infinite-sized input values.)\n\nBut note that there are cases where you should not use the asymptotically fastest algorithm.  If the \"C\" is very large, then you might be better off using a simpler algorithm for smaller data values.\n\nMy guess is that your algorithm may improve on the C, but not on the asymptotic bounds.  But if I'm wrong on that, then you should submit it to ACM!\n\nFor more info, see: http://en.wikipedia.org/wiki/Big_O_notation\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Java: Minimum spanning tree with JGraphT?\r\n                \r\nI have a problem that can essentially be viewed as a graph. I'm considering using JGraphT to implement it instead of rolling my own. What would be the best way to get a minimum spanning tree out of a graph using JGraphT?\n    ", "Answer": "\r\nUnfortunately, I don't know enough graph theory to give you a complete, direct answer, but I have used jgrapht in a few projects, so maybe this will help.\n\nThe list of algorithms included with jgrapht is here: http://www.jgrapht.org/javadoc/org/jgrapht/alg/package-summary.html, and you can also find graph traversals implemented as iterators (if that is any help) here: http://www.jgrapht.org/javadoc/org/jgrapht/traverse/package-summary.html\n\nI'm pretty sure none of those algorithms will get you want you want out of the box, so you'd have to code it yourself, but I can tell you from experience that coding on top of jgrapht as opposed to starting from scratch is A LOT easier.  There is also a FibonacciHeap class that would presumably help with implementing Prim's algorithm.\n\nIf you need help with the algorithm itself, there are a number of algorithms with Wikipedia entries, with detailed descriptions and pseudocode.  The Minimum spanning tree article links to them.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "how to prove number of edges in a minimum spanning tree\r\n                \r\nFix T to be the minimum spanning tree of G(V,E), G is an undirected graph with n vertices. why is there n-1 edges in the minimum spanning tree?\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "What is Dijkstra's Minimum Spanning Tree?\r\n                \r\nI'm having trouble finding an example algorithm for Dijkstra's Minimum Spanning tree. I already know about Dijkstra's Single Shortest Path algorithm, but not the spanning tree. I have the simple explanation from class which is this:\n\n\n  For each edge, add it to the tree. If a cycle is detected, remove the heaviest edge.\n\n\nI've scoured the Internet and I couldn't find an algorithm for it. \n\nI might need to just code it for myself, but I thought I would ask if anyone has a good example.\n\nCan anyone help?\n    ", "Answer": "\r\nHere is a simple example:\n\n\n\nThe algorithm works as follows:\n\n\nThe graph has gray edges. \nAdding some edges without detecting a circle. \nAfter adding the vertical edge, the algorithm detects a circle. It removes the last edge (red) because it has the heaviest weight.\nAdding the horizontal edge produces a circle, too. Since it has the heaviest weight it is removed.\nAdding the last edge will also produce a circle, but the last edge added hasn't the heaviest weight. Instead the edge with weight 3 must be removed. The Minimal Spanning Tree consists of the black coloured edges in picture (5).\n\n\nIf you are marking the visiting nodes, circle detection is easy. To find the heaviest edge of a detected circle, you use a common search algorithm for circles.\n\nNote: Picture (5) demonstrates why it is necessary to visit all edges, because (3) already contains a Spanning Tree. But it is not minimal.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Validating Minimum Spanning tree in Graph\r\n                \r\nI am trying to validate Minimum spanning tree (T = V,ET) of a Graph (G= V, E). Is there a way to Verify it like return true is its a MST other wise return False? Thanks\n    ", "Answer": "\r\nProbably the easiest way is to use Kruskal's algorithm to generate a MST.  When you sort the edges, sort edges from the given tree before all others of the same weight.\nIf the given tree is a MST, then Kruskal's algorithm will then generate exactly the same tree.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Update minimum spanning tree if edge is removed\r\n                \r\nI am having trouble with the following question:\n\nAssume we have already found a minimum spanning tree ```\nT```\n for a weighted, undirected graph ```\nG = (V,E)```\n. We would like to be able to efficiently update ```\nT```\n should ```\nG```\n be altered slightly.\n\nAn edge is removed from ```\nG```\n to produce a new graph such that the new graph is still connected. Give an algorithm that uses ```\nT```\n to find a minimum spanning tree for the new graph in ```\nO(|E|)```\n time.\n    ", "Answer": "\r\nSince everything is still connected and only one edge has been removed, then most (and maybe all) of the spanning tree remains the same.  Attempt to construct the same minimum spanning tree, and if the edge that was removed was part of the spanning tree, grab the next smallest edge that completes the minimum spanning tree.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Finding the minimum spanning tree of a graph using Kruskal's Algorithm\r\n                \r\nHere is a Graph where I need to find the minimum spanning tree of G using Prim's and Kruskal's algorithms.\n\nI found the minimum spanning tree using Prim's algorithm. Here is my attempt.\n\nI am having difficulty in finding the minimum spanning tree using Kruskal's algorithm. I have seen many videos related to Kruskal's graph algorithm but I ended up getting the same graph as Prim's algorithm.\n\nCan anyone please show me how to find the minimum spanning tree of the graph using Kruskal's algorithm?\n    ", "Answer": "\r\n\n  Prims and Kruskals will always give you the same answer if all the\n  edges of the graph have distinct weights, as there is only a single min-spanning tree that exists. For graph having many edges with\n  same weights, the algorithms could give you a different answer but not\n  always. Depends on the way the nodes are explored in the\n  implementation. This graph can have many different min-spanning trees.\n\n\nAs your graph has all distinct edge weights, you will always get the same answer.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum spanning tree with HashMap java\r\n                \r\nGiven the output of ascending of edges weight from HashMap \"mMap\"\n\n```\nv6_v5 : 3\nv5_v4 : 4\nv4_v6 : 5\nv5_v3 : 5\nv4_v2 : 6\nv1_v2 : 6\nv5_v1 : 7\nv2_v5 : 8\nv1_v4 : 9\n```\n\n\nusing:\n\n```\nprivate Map<String, Integer> mMap = new HashMap<String, Integer>();\n\npublic void addKeysAndValue(String from, int value) {    \n            mMap.put(from, value);\n}\n\nfor (int i = 0; i < list_from.size() - 1; i++) {\n    if (list_dest.get(i + 1).equals(list_from.get(i))) {\n        addKeysAndValue(list_from.get(i) + \"_\" + list_dest.get(i), w_arc.get(i));\n    }\n}\n\nsorted_map.putAll(mMap);    \nIterator iter = sorted_map.entrySet().iterator();\nwhile (iter.hasNext()) {\n\n            Map.Entry me = (Map.Entry) iter.next();    \n            System.out.println(me.getKey() + \" : \" + me.getValue());    \n}\n```\n\n\nNow I need to find the list of form \"mMap\" with no loop from ascending of edges weight above as a minimum spanning tree.\n\nResult:\n\n```\nv6_v5 : 3\nv5_v4 : 4\nv5_v3 : 5\nv4_v2 : 6\nv1_v2 : 6\n```\n\n\nI really appreciate for your help!\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Update minimum spanning tree if edge is added\r\n                \r\nI have a possible solution for the following question, but not sure if correct:\n\nAssume we have already found a minimum spanning tree ```\nT```\n for a weighted, undirected graph ```\nG = (V,E)```\n. We would like to be able to efficiently update ```\nT```\n should ```\nG```\n be altered slightly.\n\nAn edge is added to ```\nG```\n to produce a new graph. Give an algorithm that uses ```\nT```\n to find a minimum spanning tree for the new graph in ```\nO(|V|)```\n time.\n\nMy algorithm:\n\n```\nfor each vertex do\n   if smallest edge not in T then\n      replace this edge with existing edge in T\n      break\n   end if\nend for\n```\n\n\nI do not have much experience in writing pseudocode, so my algorithm might be over-simplified or incorrect. Please correct me if I am wrong. Thanks!\n    ", "Answer": "\r\nDon't know if your algorithm is correct, but it doesn't seem ```\nO(|V|)```\n at least, because getting the \"smallest edge not in T\" of a vertex cannot be done in ```\nO(1)```\n.\n\nThe most usual way to add an edge ```\ne=(u, v)```\n into a MST ```\nT```\n is:\n\n\nRun a BFS in ```\nT```\n from ```\nu```\n to ```\nv```\n to detect the edge with maximum value in that path. (```\nO(|V|)```\n)\nIf that edge's weight is greater than the weight of the edge you're trying to add, remove that old edge and add the new one. Otherwise, do nothing, because the new edge would not improve the MST. (```\nO(1)```\n).\n\n\nThe rationale behind this solution is that simply adding the edge into ```\nT```\n would create exactly one cycle, and to restore the MST property you have to remove the edge with maximum value from that cycle.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum Spanning Tree Graph\r\n                \r\nI have a connected graph G=(V,E) V={1,2,...,n}  and a cost function c:E->R\nand a second partial  graph G'=(V,T) where T={ for every vertex v∈ V find the neighbor with the minimum cost and add the new edge to T}\n\n\n\n\nIf G' graph has at least 2 connected components with the set of vertices  we consider the graph H where \n iff the set of edges (from the initial graph G)  is not null.We define over the edges of H a cost function.\n\nLet's say I choose V(H)={a,e,f} and E(H)={ae,af,fe}  and    \n\n```\nE12={ab,bc,bd,ed} \nE23={eg,ef} E31={fc,fd}                            \nc'(ae)=min{c(ab),c(bc),c(bd),c(ed)}=4\nc'(af)=min{c(fc),c(fd)}=9\nc'(fe)=min{c(eg),c(ef)}=8\n```\n\n\nNow for every edge e ∈ E(H) we note with e' the edge (from the original graph G)\nfor which this minimum is attained.\nSo e'={bc,df,eg} because bc=4 , df=9 and eg=8 and are the min edges that connect my components.\nAnd I have a minimum spanning tree in H relative to the cost function c' and A' is the set of edges for this tree. \n\nSo A'={ae,fe} (I deleted the edge with the maximum cost=af from my graph H to create a min spanning tree)\nand I have another set of edges A'={e'|e∈A'} and \n is a min spanning tree in G relative to the function cost c.\n\nBut none of my edges from A' are the same with the ones from e'.\n\nWhat I'm I doing wrong?\n    ", "Answer": "\r\nLooks like you're implementing Boruvka's algorithm. If you look at the notation, it says there's an edge from one new node vC1 to a new node vC2 if there are a pair of nodes x &in; C1 and y &in; C2 that are adjacentnin the original graph G. In other words, there's an edge between two new nodes if the connected components they correspond to in G' are adjacent in G. The cost of the edge running between them is then the lowest of the costs of any of the edges running between those CC's in the original graph G.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "design a graph where shortest path tree is longer than minimum spanning tree\r\n                \r\nDesign an example of a graph where the shortest path tree is longer than the minimum spanning tree.\n\nIn the worst case, how much longer can the shortest path tree be than the\nminimum spanning tree? \n    ", "Answer": "\r\nConsider the following graph, where the cost of an edge is written between braces:\n\n```\n1\n|\n|(1)\n|\n2\n| \\\n|  \\\n|   \\\n|    \\\n|(25) \\ (10)\n|      \\\n3-------4     \n   (20)\n```\n\n\nThen the shortest path tree rooted at vertex 1 is:\n\n```\n1\n|\n|(1)\n|\n2\n| \\\n|  \\\n|   \\\n|    \\\n|(25) \\ (10)\n|      \\\n3       4    \n```\n\n\nwhile the minimum spanning tree of the graph is:\n\n```\n1\n|\n|(1)\n|\n2\n  \\\n   \\\n    \\\n     \\\n      \\ (10)\n       \\\n3-------4     \n   (20)\n```\n\n\nAs for your second question, I could not think of an answer.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "When should I use Kruskal as opposed to Prim (and vice versa)?\r\n                \r\nI was wondering when one should use Prim's algorithm and when Kruskal's to find the minimum spanning tree? They both have easy logics, same worst cases, and only difference is implementation which might involve a bit different data structures. So what is the deciding factor?\n    ", "Answer": "\r\nUse Prim's algorithm when you have a graph with lots of edges.\n\nFor a graph with V vertices E edges, Kruskal's algorithm runs in O(E log V) time and Prim's algorithm can run in O(E + V log V) amortized time, if you use a Fibonacci Heap.\n\nPrim's algorithm is significantly faster in the limit when you've got a really dense graph with many more edges than vertices.  Kruskal performs better in typical situations (sparse graphs) because it uses simpler data structures.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum Spanning Tree of set of nodes in a complete graph\r\n                \r\n\n\nI am trying to find the minimum spanning tree connecting the dots but by respecting the existing layout of the network. I am having difficulty formulating the network in python's tool networkx to find the minimum spanning tree.\n\nI need to find the minimum spanning tree covering only the dots, Considering that I have the coordinates of those points and I can find the length of the lines that connect them.\n\nAny pointers or ideas on how to do this?\n    ", "Answer": "\r\nYou are solving the Steiner tree problem, which is NP-hard. ```\nnetworkx```\n provides an approximation algorithm to solve this problem: networkx.algorithms.approximation.steinertree.steiner_tree.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum Spanning Tree in Java\r\n                \r\nThis is a ACM-ICPC practicing problem: http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=975. And the basic idea is to find the shortest weight of a minimum spanning tree. And I tried to solve it with Kruskal algorithm. I tested it myself and it seems to be working fine. However, when I submit it onto the uva online judge, the result is \"wrong answer\". Could any body see where is not correct? Thanks!\n\n```\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.text.DecimalFormat;\nimport java.util.ArrayList;\nimport java.util.Collections;\n//import java.util.Comparator;\nimport java.util.List;\n//import java.math.*;\n\npublic class Main  {\n\n    public static void main(String[] args) throws Exception, IOException {\n\n        BufferedReader cin = new BufferedReader(new InputStreamReader(System.in));  \n        int numOfCases = Integer.parseInt(cin.readLine());\n\n        while (numOfCases > 0) {\n            cin.readLine();\n            int numOfPoints = Integer.parseInt(cin.readLine());\n            List<Points> listOfPoints = new ArrayList<Points>();\n            List<Edge> listOfEdges = new ArrayList<Edge>();\n\n            double inkUsed = 0;\n\n            for (int i = 0; i < numOfPoints; i++) {\n                String[] tokens = cin.readLine().split(\" \");\n                Points point = new Points(Double.parseDouble(tokens[0]),Double.parseDouble(tokens[1]));\n                listOfPoints.add(point);\n            }\n\n            for (int i = 0; i < listOfPoints.size(); i++) {\n                for (int j = i+1; j < listOfPoints.size(); j++) {\n                    Edge edge = new Edge(listOfPoints.get(i), listOfPoints.get(j));\n                    listOfEdges.add(edge);\n                }\n            }\n\n            Collections.sort(listOfEdges);\n\n            for (Edge e: listOfEdges) {\n\n                Points pointA = null;\n                Points pointB = null;\n\n                // Find pointA and pointB in the list \"listOfPoints\"\n                for (int i = 0; i < listOfPoints.size(); i++) {\n                    if (listOfPoints.get(i).x == e.A.x && listOfPoints.get(i).y == e.A.y) {\n                        pointA = listOfPoints.get(i);\n                    }\n                    if (listOfPoints.get(i).x == e.B.x && listOfPoints.get(i).y == e.B.y) {\n                        pointB = listOfPoints.get(i);\n                    }\n                }\n\n                Points rootOfA = findSet(pointA);\n                Points rootOfB = findSet(pointB);\n\n                if (rootOfA.x != rootOfB.x || rootOfA.y != rootOfB.y){  //add this edge\n                    //System.out.println( \"[\" + \"(\" + pointA.x +\",\" + pointA.y+\"); (\" + pointB.x +\",\" + pointB.y+\")\"+ \"]\");\n                    inkUsed += e.weight;\n                    rootOfA.parent = rootOfB;\n                }\n            }\n\n            DecimalFormat df = new DecimalFormat(\"#.00\"); \n            System.out.println(df.format(inkUsed));\n            numOfCases--;\n        }\n    }\n\n    public static Points findSet(Points A) {\n        Points rootOfA = A;\n\n        while (rootOfA.parent != null) {\n            rootOfA = rootOfA.parent;\n        }\n        return rootOfA;\n    }\n}\n\nclass Points {  \n\n    public double x;\n    public double y;\n    public Points parent = null;\n\n    Points (double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass Edge implements Comparable<Edge> {\n\n    Points A;\n    Points B;\n    double weight;\n\n    Edge (Points var1, Points var2) {\n        A = var1;\n        B = var2;\n        weight = Math.sqrt(Math.pow((A.x-B.x), 2) + Math.pow((A.y-B.y), 2));\n    }\n\n    public String toString() {\n        return Double.toString(weight);\n    }\n\n    public int compareTo(Edge anotherEdge) {\n        if (this.weight < anotherEdge.weight) {\n            return -1;\n        } else if (this.weight == anotherEdge.weight) {\n            return 0;\n        } else {\n            return 1;\n        }\n    }\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum Spanning Tree with only 2 equal edges\r\n                \r\nAssume you have an undirected-weighted graph G, with different edges weighs but for only two edges: ```\nw(e1)=w(e2)```\n\n\nI have to prove that G has at most one minimum spanning tree which includes e1.\nAlso I have to prove that G has at most one minimum spanning tree which doesnt include e1.\n\nI only need a solution for the first one and will solve the second one alone.\n\nThanks\n    ", "Answer": "\r\nFor solving part 1:\n\nConsider the graph you get by removing ```\ne1```\n from G (and possibly one of it's vertices, if it's now not connected to the rest of the graph), let's call it G'.\n\nIn this graph (G') , all the edge weights are different.\n\nNow suppose G has more than 1 MST which includes ```\ne1```\n - they would both be different MSTs for G'.\n\nNow the trick is that there's a theorem that in this kind of graph (all edges are different), the MST is unique. see the proof(s) here.\n\nedit: You can probably just take the proof from the link and edit it slightly for your case.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum Spanning tree from array list\r\n                \r\nI'm wondering if it's possible to find the minimum spanning tree from an ArrayList.\n\nThis is what I currently have:\n\n```\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\n\npublic class GraphReading \n{\npublic static void main(String[] args) throws FileNotFoundException \n{\n    File f= new File(\"Bridges.txt\");\n    Scanner sc= new Scanner(f);\n\n    ArrayList < ArrayList<Integer>  >   Vertices = new ArrayList<>();\n\n    while(sc.hasNext())\n    {\n        String Line =     sc.nextLine();\n        String numbers[] = Line.split(\" \");\n\n        ArrayList<Integer>  List = new ArrayList<>();\n        for(int i=0;i <  numbers.length ;i++)\n        {\n                if(numbers[i].equals(\"\")==false)\n                    List.add(  Integer.parseInt( numbers [i]));\n        }\n        Vertices.add(List);\n    }\n    printAllvertices(Vertices);\n}\npublic static  void printAllvertices(  ArrayList < ArrayList<Integer>  >   Vertices  )\n{\n    for(int i=0;i<  Vertices .size();i++)\n    {\n        System.out.print(\"Vertice \"+i+ \" has \");\n             ArrayList<Integer>  List =  Vertices.get(i);\n             for(int j=0;j<List.size();j++)\n             {\n                 System.out.print(List.get(j)+\" \");\n             }\n             System.out.println();\n\n\n\n\n    }\n\n}\n\n}\n```\n\n\nI was thinking about just finding the minimum number from each of the vertices but I wasn't too sure that would necessarily work the way I wanted it too. \n    ", "Answer": "\r\nSure you can! I found this site that has some nice documentation on how to do it using PRIM's algorithm.\n\nhttp://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/\n\nYou might need to convert a bit of code around, but that should be trivial. Looking for just the cheapest edges is a solution, but may not always result in the minimum spanning tree. This way you might accidentally make \"detours\" in your graph, making your tree larger than intended.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Error with getting the Minimum Spanning Tree from a Graph? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs debugging details. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Edit the question to include desired behavior, a specific problem or error, and the shortest code necessary to reproduce the problem. This will help others answer the question.\r\n                \r\n                    \r\n                        Closed 4 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI am trying to get the Minimum Spanning Tree of an undirected weighted graph, which should return the weight of the minimum spanning tree, or -1 if no minimum spanning tree can be found using a package called CITS2200, below is the link to the CITS2200.jar:\n\nCITS2200.jar\n\nI was wondering if anybody could see why my getMinSpanningTree method in the following code is not passing the test, any help would be appreciated. Cheers, Ben. c\",)\n\n```\nimport CITS2200.*;\npublic class PathImp implements Path {  \n\n public int getMinSpanningTree(Graph g) {\n    int parent[] = new int[g.getNumberOfVertices()];\n    int key[] = new int [g.getNumberOfVertices()];\n    Boolean mstSet[] = new Boolean[g.getNumberOfVertices()];\n    for (int i = 0; i < g.getNumberOfVertices(); i++)\n    {\n        key[i] = Integer.MAX_VALUE;\n        mstSet[i] = false;\n    }\n    key[0] = 0;     \n    parent[0] = -1;\n    int sum = -1;\n    for (int count = 0; count < g.getNumberOfVertices()-1; count++)\n    {\n        int u = minKey(key, mstSet);\n        mstSet[u] = true;\n        for (int v = 0; v < g.getNumberOfVertices(); v++){\n            if (g.getWeight(u,v)!=0 && mstSet[v] == false &&\n                g.getWeight(u,v) <  key[v])\n            {\n                parent[v]  = u;\n                key[v] = g.getWeight(u,v);\n                sum += g.getWeight(u,v);\n            }\n         }\n    }\n    return sum;\n}\npublic int minKey(int key[], Boolean mstSet[])\n{\n    int min = Integer.MAX_VALUE, min_index=-1;\n    for (int v = 0; v < key.length; v++)\n        if (mstSet[v] == false && key[v] < min)\n        {\n            min = key[v];\n            min_index = v;\n        }\n    return min_index;\n}\n public int minDistance(int dist[], Boolean sptSet[])\n    {\n        int min = Integer.MAX_VALUE, min_index=-1;\n        for (int v = 0; v < dist.length; v++)\n            if (sptSet[v] == false && dist[v] <= min)\n            {\n                min = dist[v];\n                min_index = v;\n            }\n        return min_index;\n    }\n public int[] getShortestPaths(Graph g, int src)\n{\n    int dist[] = new int[g.getNumberOfVertices()]; \n    int graph[][] = g.getEdgeMatrix();                         \n    Boolean sptSet[] = new Boolean[g.getNumberOfVertices()];\n    for (int i = 0; i < g.getNumberOfVertices(); i++)\n    {\n        dist[i] = Integer.MAX_VALUE;\n        sptSet[i] = false;\n    }\n    dist[src] = 0;\n    for (int count = 0; count < g.getNumberOfVertices()-1; count++)\n    {\n        int u = minDistance(dist, sptSet);\n        sptSet[u] = true;\n        for (int v = 0; v < g.getNumberOfVertices(); v++)\n            if (!sptSet[v] && graph[u][v]!=0 &&\n                    dist[u] != Integer.MAX_VALUE &&\n                    dist[u]+graph[u][v] < dist[v])\n                dist[v] = dist[u] + graph[u][v];\n    }\n    return dist;\n}\n}\n```\n\n\nThe getShortestPath(G, v) method works fine, however, below is the error message I am getting when I test my code against the test class:\n\n```\n Checking files:\n PathImp.java\n Files exist and are readable.\n\n Compiling Files:\n PathImp\n Compilation complete.\n\n Loading Files:\n PathImp\n Loading complete.\n\n Implements CITS2200.Path\n\nConstructing instance...\nConstructed PathImp\n\n Analysing PathImp...\nMST:\n1\nMST incorrect for 500 vertices at 0.03 density.\n2\nMST incorrect for 1000 vertices at 0.02 density.\n3\nMST incorrect for 1500 vertices at 0.01 density.\nSSSP:\n1\nShortest paths correct for 500 vertices at 0.03 density.\n2\nShortest paths correct for 1000 vertices at 0.02 density.\n3\nShortest paths correct for 1500 vertices at 0.01 density.\n\n\n!Analysis halted: Your code has produced an incorrect output. \n\nYour submission was not successful on this occasion.\nPlease try again when you've addressed this problem.\nExecution stack trace (if any) follows.\n\njava.lang.Exception: Your code has produced an incorrect output. \n    at Lab8.main(Lab8.java:86)\n```\n\n    ", "Answer": "\r\nI think the issue is with this line:\n\n```\nsum += g.getWeight(u,v);\n```\n\n\nYou are adding the weight to your total cost whenever you consider adding an edge to the spanning tree.  This will over-estimate the true cost of the spanning tree.\n\nInstead, you should only add the weight when you are certain the edge is being added to the spanning tree (i.e. immediately after ```\nint u = minKey(key, mstSet);```\n)\n\ne.g. something like:\n\n```\nint u = minKey(key, mstSet);\nif (parent[u] != -1)\n    sum += g.getWeight(parent[u],u);\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum spanning tree : distance and graph\r\n                \r\ni'm stuck in a minimum spanning tree problem.\nI've found a code that resolve the problem and return a graph of the solution, I've edited it a bit but I don't find a way to return the distance along to the graphic, as I don't have much python experience.\nCan you help me ? Thanks\n\n```\n    import numpy as np\n    from scipy.spatial.distance import pdist, squareform\n    import matplotlib.pyplot as plt\n\n\ndef minimum_spanning_tree(X, copy_X=True):\n    if copy_X:\n        X = X.copy()\n\n    if X.shape[0] != X.shape[1]:\n        raise ValueError(\"X needs to be square matrix of edge weights\")\n    n_vertices = X.shape[0]\n    spanning_edges = []\n\n    visited_vertices = [0]\n    num_visited = 1\n\n    diag_indices = np.arange(n_vertices)\n    X[diag_indices, diag_indices] = np.inf\n\n    while num_visited != n_vertices:\n        new_edge = np.argmin(X[visited_vertices], axis=None)\n        new_edge = divmod(new_edge, n_vertices)\n        new_edge = [visited_vertices[new_edge[0]], new_edge[1]]\n        spanning_edges.append(new_edge)\n        visited_vertices.append(new_edge[1])\n        X[visited_vertices, new_edge[1]] = np.inf\n        X[new_edge[1], visited_vertices] = np.inf\n        num_visited += 1\n    return np.vstack(spanning_edges)\n\n\ndef test_mst():\n    n = int(input())\n    P = np.array([], int)\n    for i in range(0,n):\n        y = list(map(int,input().split()))\n        P = np.append(P,[y[0],y[1]], axis=0)\n    P = P.reshape(n,2)\n    X = squareform(pdist(P))\n    edge_list = minimum_spanning_tree(X)\n    plt.scatter(P[:, 0], P[:, 1])\n\n    for edge in edge_list:\n        i, j = edge\n        plt.plot([P[i, 0], P[j, 0]], [P[i, 1], P[j, 1]], c='r')\n    plt.show()\n\nif __name__ == \"__main__\":\n    test_mst()\n```\n\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Finding minimum spanning tree with Kruskal's, but there are overlap vertex\r\n                \r\nI tried to find minimum spanning tree with given graph (as adjacency list), priority queue and union-find method (with kruskal).\nBut there are two differences with my desired output :\nFirst, The output contains Edges which didn't sort.\nSince Kruskal sort Edges and pick one of them, the output must be sorted, but my output didn't.\nHere is my output :\n```\n1 - 2 : 35\n3 - 2 : 126\n8 - 6 : 120\n5 - 1 : 247\n2 - 6 : 150\n.\n.\n.\n.\n```\n\nSecond problem is generated Minimum Spanning Tree have redundancy nodes, Here is my output :\n```\n1 : 2[35] 5[247] 5[247] 2[35]\n2 : 1[35] 3[126] 6[150] 6[150] 3[126] 1[35]\n.\n.\n.\n```\n\nThere are two '2' and two '5' in 'Node 1' and similar problem for 'Node 2'.\nIn fact, the 'Node 1' of Minimum spanning tree should not have '5' but it does.\nI think there are problems in priority queue but I can't find it.\nHere is my full-code about finding minimum spanning tree with adjacency list as below :\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <memory.h>\n\ntypedef struct DisjointSet\n{\n    struct DisjointSet* Parent;\n    void* data;\n} DisjointSet;\n\ntypedef struct PQNode\n{\n    int priority;\n    void* data;\n}PQNode;\n\ntypedef struct PQ\n{\n    PQNode* Node;\n    int capacity;\n    int using;\n}PQ;\n\ntypedef struct Vertex\n{\n    int data;\n    int isVisited;\n    int index;\n\n    struct Vertex* Next;\n    struct Edge* AdjList;\n} Vertex;\n\ntypedef struct Edge\n{\n    int Weight;\n    struct Edge* Next;\n    Vertex* From;\n    Vertex* Target;\n} Edge;\n\ntypedef struct Graph\n{\n    Vertex* Vt;\n    int cnt;\n} Graph;\n\n// ----------------- Priority Q ---------------------\n\nPQ* NewQ(int size)\n{\n    PQ* q = (PQ*)malloc(sizeof(PQ));\n    q->capacity = size;\n    q->using = 0;\n    q->Node = (PQNode*)malloc(sizeof(PQNode) * q->capacity);\n\n    return q;\n}\n\nvoid Swap(PQ* q, int idx1, int idx2)\n{\n    int CopySize = sizeof(PQNode);\n    PQNode* TempNode = (PQNode*)malloc(CopySize);\n\n    memcpy(TempNode, &q->Node[idx1], CopySize);\n    memcpy(&q->Node[idx1], &q->Node[idx2], CopySize);\n    memcpy(&q->Node[idx2], TempNode, CopySize);\n\n    free(TempNode);\n}\n\nint isEmpty(PQ* q)\n{\n    return (q->using == 0);\n}\n\nint GetParent(int i)\n{\n    return (int)((i - 1) / 2);\n}\n\nint GetChild(int i)\n{\n    return (2 * i) - 1;\n}\n\nvoid DestroyQ(PQ* q)\n{\n    free(q->Node);\n    free(q);\n}\n\nvoid Enqueue(PQ* q, PQNode Node)\n{\n    int Current = q->using;\n    int Parent = GetParent(Current);\n\n    if (q->using == q->capacity)\n    {\n        if (q->capacity == 0)\n        {\n            q->capacity = 1;\n        }\n\n        q->capacity = 2;\n        q->Node = (PQNode*)realloc(q->Node, sizeof(PQNode) * q->capacity);\n    }\n\n    q->Node[Current] = Node;\n\n    while (Current > 0 && q->Node[Current].priority < q->Node[Parent].priority)\n    {\n        Swap(q, Current, Parent);\n\n        Current = Parent;\n        Parent = GetParent(Current);\n    }\n    q->using++;\n}\n\nvoid Dequeue(PQ* q, PQNode* RootNode)\n{\n    int Left = 0;\n    int Right = 0;\n    int Parent = 0;\n\n    memcpy(RootNode, &q->Node[0], sizeof(PQNode));\n    memset(&q->Node[0], 0, sizeof(PQNode));\n\n    q->using--;\n    Swap(q, 0, q->using);\n\n    Left = GetChild(0);\n    Right = Left + 1;\n\n    while (1)\n    {\n        int Select = 0;\n\n        if (Left >= q->using)\n        {\n            break;\n        }\n        if (Right >= q->using)\n        {\n            Select = Left;\n        }\n        else\n        {\n            if (q->Node[Left].priority > q->Node[Right].priority)\n            {\n                Select = Right;\n            }\n            else\n            {\n                Select = Left;\n            }\n        }\n\n        if (q->Node[Select].priority < q->Node[Parent].priority)\n        {\n            Swap(q, Parent, Select);\n            Parent = Select;\n        }\n        else\n        {\n            break;\n        }\n\n        Left = GetChild(Parent);\n        Right = Left + 1;\n    }\n\n}\n\n// ----------------- Priority Q ---------------------\n\n// -------------- Union and find --------------------\n\nDisjointSet* Find(DisjointSet* Set)\n{\n    while (Set->Parent != NULL)\n    {\n        Set = Set->Parent;\n    }\n    return Set;\n}\n\nvoid Union(DisjointSet* S1, DisjointSet* S2)\n{\n    S2 = Find(S2);\n    S2->Parent = NULL;\n}\n\nDisjointSet* NewSet(void* data)\n{\n    DisjointSet* Set = (DisjointSet*)malloc(sizeof(DisjointSet));\n    Set->Parent = NULL;\n    Set->data = data;\n\n    return Set;\n}\n\nvoid DestroySet(DisjointSet* Set)\n{\n    free(Set);\n}\n\n// -------------- Union and find --------------------\n\n// ------------------- Graph ------------------------\n\nGraph* NewGraph()\n{\n    Graph* g = (Graph*)malloc(sizeof(Graph));\n    g->Vt = NULL;\n    g->cnt = 0;\n\n    return g;\n}\n\nvoid DestroyEdge(Edge* e)\n{\n    free(e);\n}\n\nvoid DestroyVertex(Vertex* v)\n{\n    while (v->AdjList != NULL)\n    {\n        Edge* e = v->AdjList->Next;\n        DestroyEdge(v->AdjList);\n        v->AdjList = e;\n    }\n\n    free(v);\n}\n\nvoid DestroyGraph(Graph* g)\n{\n    while (g->Vt != NULL)\n    {\n        Vertex* v = g->Vt->Next;\n        DestroyVertex(g->Vt);\n        g->Vt = v;\n    }\n\n    free(g);\n}\n\nVertex* NewVertex(int data)\n{\n    Vertex* v = (Vertex*)malloc(sizeof(Vertex));\n\n    v->data = data;\n    v->Next = NULL;\n    v->AdjList = NULL;\n    v->isVisited = 0;\n    v->index = -1;\n\n    return v;\n}\n\nEdge* NewEdge(Vertex* From, Vertex* Target, int weight)\n{\n    Edge* e = (Edge*)malloc(sizeof(Edge));\n    e->From = From;\n    e->Target = Target;\n    e->Next = NULL;\n    e->Weight = weight;\n\n    return e;\n}\n\nvoid AddVertex(Graph* g, Vertex* v)\n{\n    Vertex* vList = g->Vt;\n\n    if (vList == NULL)\n    {\n        g->Vt = v;\n    }\n    else\n    {\n        while (vList->Next != NULL)\n        {\n            vList = vList->Next;\n        }\n        vList->Next = v;\n    }\n    v->index = g->cnt++;\n}\n\nvoid AddEdge(Vertex* v, Edge* e)\n{\n    if (v->AdjList == NULL)\n    {\n        v->AdjList = e;\n    }\n    else\n    {\n        Edge* AdjList = v->AdjList;\n        while (AdjList->Next != NULL)\n        {\n            AdjList = AdjList->Next;\n        }\n        AdjList->Next = e;\n    }\n}\n\nvoid printG(Graph* g)\n{\n    Vertex* v = NULL;\n    Edge* e = NULL;\n\n    if ((v = g->Vt) == NULL)\n    {\n        return;\n    }\n    while (v != NULL)\n    {\n        printf(\"%d : \", v->data);\n        if ((e = v->AdjList) == NULL)\n        {\n            v = v->Next;\n            printf(\"\\n\");\n            continue;\n        }\n\n        while (e != NULL)\n        {\n            printf(\"%d[%d] \", e->Target->data, e->Weight);\n            e = e->Next;\n        }\n\n        printf(\"\\n\");\n\n        v = v->Next;\n    }\n    printf(\"\\n\");\n}\n\nvoid Kruskal(Graph* g, Graph* MSTree)\n{\n    Vertex* CurrentV = NULL;\n    Vertex** MSTreeV = (Vertex**)malloc(sizeof(Vertex*) * (g->cnt));\n\n    DisjointSet** VertexSet = (DisjointSet**)malloc(sizeof(DisjointSet*) * g->cnt);\n\n    PQ* q = NewQ(200);\n\n    int i = 0;\n    CurrentV = g->Vt;\n    while (CurrentV != NULL)\n    {\n        Edge* CurrentE;\n        VertexSet[i] = NewSet(CurrentV);\n        MSTreeV[i] = NewVertex(CurrentV->data);\n        AddVertex(MSTree, MSTreeV[i]);\n\n        CurrentE = CurrentV->AdjList;\n        while (CurrentE != NULL)\n        {\n            PQNode Node = { CurrentE->Weight, CurrentE };\n            Enqueue(q, Node);\n            CurrentE = CurrentE->Next;\n        }\n        CurrentV = CurrentV->Next;\n        i++;\n    }\n\n\n    while (!isEmpty(q))\n    {\n        Edge* CurrentEdge;\n        int from;\n        int to;\n        PQNode Pop;\n\n        Dequeue(q, &Pop);\n        CurrentEdge = (Edge*)Pop.data;\n\n        printf(\"%d - %d : %d\\n\", CurrentEdge->From->data, CurrentEdge->Target->data, CurrentEdge->Weight);\n\n        from = CurrentEdge->From->index;\n        to = CurrentEdge->Target->index;\n\n        if (Find(VertexSet[from]) != Find(VertexSet[to]))\n        {\n            AddEdge(MSTreeV[from], NewEdge(MSTreeV[from], MSTreeV[to], CurrentEdge->Weight));\n            AddEdge(MSTreeV[to], NewEdge(MSTreeV[to], MSTreeV[from], CurrentEdge->Weight));\n            Union(VertexSet[from], VertexSet[to]);\n        }\n    }\n\n    for (i = 0; i < g->cnt; i++)\n    {\n        DestroySet(VertexSet[i]);\n    }\n    free(VertexSet);\n    free(MSTreeV);\n}\n\n// ------------------- Graph ------------------------\n\nint main()\n{\n    Graph* g = NewGraph();\n    Graph* k = NewGraph();\n\n    Vertex* v1 = NewVertex(1);\n    Vertex* v2 = NewVertex(2);\n    Vertex* v3 = NewVertex(3);\n    Vertex* v4 = NewVertex(4);\n    Vertex* v5 = NewVertex(5);\n    Vertex* v6 = NewVertex(6);\n    Vertex* v7 = NewVertex(7);\n    Vertex* v8 = NewVertex(8);\n    Vertex* v9 = NewVertex(9);\n    \n\n    AddVertex(g, v1); // a\n    AddVertex(g, v2); // b\n    AddVertex(g, v3); // c\n    AddVertex(g, v4); // d\n    AddVertex(g, v5); // e\n    AddVertex(g, v6); // f\n    AddVertex(g, v7); // g\n    AddVertex(g, v8); // h\n    AddVertex(g, v9); // i\n    \n\n    AddEdge(v1, NewEdge(v1, v2, 35));\n    AddEdge(v1, NewEdge(v1, v5, 247));\n\n    AddEdge(v2, NewEdge(v2, v1, 35));\n    AddEdge(v2, NewEdge(v2, v3, 126));\n    AddEdge(v2, NewEdge(v2, v6, 150));\n\n    AddEdge(v3, NewEdge(v3, v2, 126));\n    AddEdge(v3, NewEdge(v3, v4, 117));\n    AddEdge(v3, NewEdge(v3, v6, 162));\n    AddEdge(v3, NewEdge(v3, v7, 220));\n\n    AddEdge(v4, NewEdge(v4, v3, 117));\n\n    AddEdge(v5, NewEdge(v5, v1, 247));\n    AddEdge(v5, NewEdge(v5, v6, 82));\n    AddEdge(v5, NewEdge(v5, v8, 98));\n\n    AddEdge(v6, NewEdge(v6, v2, 150));\n    AddEdge(v6, NewEdge(v6, v3, 162));\n    AddEdge(v6, NewEdge(v6, v5, 82));\n    AddEdge(v6, NewEdge(v6, v7, 154));\n    AddEdge(v6, NewEdge(v6, v8, 120));\n\n    AddEdge(v7, NewEdge(v7, v3, 220));\n    AddEdge(v7, NewEdge(v7, v6, 154));\n    AddEdge(v7, NewEdge(v7, v9, 106));\n\n    AddEdge(v8, NewEdge(v8, v5, 98));\n    AddEdge(v8, NewEdge(v8, v6, 120));\n\n    AddEdge(v9, NewEdge(v9, v7, 106));\n\n\n    printG(g);\n    printf(\"Kruskal\");\n    Kruskal(g, k);\n    printG(k);\n\n    DestroyGraph(g);\n\n    return 0;\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Python: how to visualize the Minimum Spanning Tree of a network?\r\n                \r\nI have a regular grid network made of ```\nNxN```\n nodes. I am able to plot it, but I would also like to plot its minimum spanning tree, which is a \"subgraph that contains all the vertices and is a tree\".\n\nThis is how I create the network:\n\n```\nfrom __future__ import print_function, division\nimport numpy\nfrom numpy import *\nimport networkx as nx\nfrom networkx import *\nimport matplotlib.pyplot as plt\n\nN=30\nG=nx.grid_2d_graph(N,N)\npos = dict( (n, n) for n in G.nodes() )\nlabels = dict( ((i, j), i + (N-1-j) * N ) for i, j in G.nodes() )\nnx.relabel_nodes(G,labels,False)\ninds=labels.keys()\nvals=labels.values()\ninds.sort()\nvals.sort()\npos2=dict(zip(vals,inds))\nnx.draw_networkx(G, pos=pos2, with_labels=False, node_size = 15)\n```\n\n\n\n\nThis is how I compute the Minimum Spanning Tree:\n\n```\nT=nx.minimum_spanning_tree(G)\n```\n\n\nThis generates a graph just like ```\nG```\n, with the difference that ```\nT```\n has the same nodes as ```\nG```\n and a selection of its edges. Therefore, I would like to plot ```\nT```\n, and this is what I did:\n\n```\nplt.figure()\nnx.draw_networkx(G, pos=pos2, with_labels=False, node_size = 15)\nplt.show()\n```\n\n\nBut I simply get the network plotted again. How can I amend the last lines to make sure my Minimum Spanning Tree is plotted?\n    ", "Answer": "\r\n```\nplt.figure()\nnx.draw_networkx(G, pos=pos2, with_labels=False, node_size = 15)\nplt.show()\n```\n\n\nshould be\n\n```\nplt.figure()\nnx.draw_networkx(T, pos=pos2, with_labels=False, node_size = 15)\nplt.show()\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum Spanning Tree of weighted graph\r\n                \r\nI need to write a predicate that creates a minimum spanning tree of a weighted undirected graph, using Prim's Algorithm. This is what I have so far:\n\n```\n% call the recursive predicate with the list of all nodes and\n%    one element (in this case the last one).\nmst(T) :- nodes(N), last(N,E), mst(T,N,E).\n\n% The element E is added to the visited list and removed from the toVisit list.\nmst(T,N,E) :- append(T,E,S), delete(R,E,L)...\n```\n\n\nThen the ```\ntoVisit```\n list should be sorted according to the distance of the edges connected to any of the nodes in the visited list. Any suggestions on how to do this?\n    ", "Answer": "\r\nSo, first of all let's try to create a solution to find a spanning tree, not minimum, from wikipedia: \"spanning tree ```\nT```\n of an undirected graph ```\nG```\n is a subgraph that is a tree which includes all of the vertices of ```\nG```\n, with minimum possible number of edges\" and \"A tree is a connected undirected graph with no cycles. It is a spanning tree of a graph ```\nG```\n if it spans ```\nG```\n (that is, it includes every vertex of ```\nG```\n) and is a subgraph of ```\nG```\n (every edge in the tree belongs to ```\nG```\n)\". In this example, i consider a graph built in this way:\n\n```\ngraph(ListOfVertices,ListOfEdges)\n```\n\n\nand each element of ListOfEdges is ```\nedge(X,Y,Cost)```\n.\n\nLet's build a predicate that creates a tree (in this case a fully connected graph). ```\nmake_kn_weighted/4```\n has as input the degree of each node (```\nSize```\n), the ```\nMinValue```\n and ```\nMaxValue```\n of edges's cost and creates the Graph in ```\ngraph(LV,Comb)```\n.\n\n```\nmake_kn_weighted(Size,MinValue,MaxValue,graph(LV,Comb)):-\n    Size1 is Size+1,\n    make_ordered_list(1,Size1,LV),\n    find_all_combinations_weighted(LV,MinValue,MaxValue,[],Comb).\n\nmake_ordered_list(Max,Max,[]):- !.\nmake_ordered_list(I,Max,[I|T]):-\n    I < Max,\n    I1 is I+1,\n    make_ordered_list(I1,Max,T).\n\nfind_all_combinations_weighted([_],_,_,C,C):- !.\nfind_all_combinations_weighted([H|T],Min,Max,CT,CO):-\n    find_combinations_weighted(H,T,Min,Max,C),\n    append(CT,C,C1),\n    find_all_combinations_weighted(T,Min,Max,C1,CO).\n\nfind_combinations_weighted(_,[],_,_,[]):- !.\nfind_combinations_weighted(E,[H|T],Min,Max,[edge(E,H,V)|TE]):-\n    random(Min,Max,V),\n    find_combinations_weighted(E,T,Min,Max,TE).\n\n?- make_kn_weighted(4,2,7,G).\nG = graph([1, 2, 3, 4], [edge(1, 2, 6), edge(1, 3, 6), edge(1, 4, 5), edge(2, 3, 4), edge(2, 4, 5), edge(3, 4, 5)]).\n```\n\n\nThen we crate a predicate that generates a spanning tree:\n\n```\nspanning_tree(graph([N|T],Edges),graph([N|T],TreeEdges)) :- \n   generate_spanning_tree(T,Edges,TreeEdgesUnsorted),\n   sort(TreeEdgesUnsorted,TreeEdges).\n\ngenerate_spanning_tree([],_,[]).\ngenerate_spanning_tree(Curr,Edges,[Edge|T]) :- \n    select(Edge,Edges,Edges1),\n    get_vertices(Edge,X,Y),\n    is_connected_to_tree(X,Y,Curr),\n    delete(Curr,X,Curr1),\n    delete(Curr1,Y,Curr2),\n    generate_spanning_tree(Curr2,Edges1,T).\n\nget_vertices(edge(X,Y),X,Y).\nget_vertices(edge(X,Y,_),X,Y).\n\nis_connected_to_tree(X,Y,Ns):- \n    memberchk(X,Ns), \n    \\+ memberchk(Y,Ns), !.\nis_connected_to_tree(X,Y,Ns):- \n    memberchk(Y,Ns), \n    \\+ memberchk(X,Ns).\n```\n\n\nSo, obviously, both the spanning tree and the graph have the same vertices, and this is why i wrote ```\ngraph([N|T],Edges),graph([N|T],TreeEdges)```\n. To generate the actual tree, firs we select a node from the list, with ```\nselect/3```\n (in ```\nEdges1```\n we have all the elements from ```\nEdges```\n without ```\nEdge```\n. Then with ```\nget_vertices/3```\n we foud the two vertices connected by an edge. With ```\nis_connected_to_tree/3```\n we check if the two vertices are not already connected (in the list or remaining verices). Then we delete the two selected edges to the list of unconnected vertices (```\nCurr```\n) using two times ```\ndelete/3```\n applied to ```\nCurr```\n. Last call, the recursive call with parameters updated. Test:\n\n```\n?- make_kn(4,G), spanning_tree(G,T).\nG = graph([1, 2, 3, 4], [edge(1, 2), edge(1, 3), edge(1, 4), edge(2, 3), edge(2, 4), edge(3, 4)]),\nT = graph([1, 2, 3, 4], [edge(1, 2), edge(1, 3), edge(1, 4)]) ;\nG = graph([1, 2, 3, 4], [edge(1, 2), edge(1, 3), edge(1, 4), edge(2, 3), edge(2, 4), edge(3, 4)]),\nT = graph([1, 2, 3, 4], [edge(1, 2), edge(1, 3), edge(2, 4)])\nand so on...\n```\n\n\nNow let's focus to Primm's algorthm: to adapt our predicate to generate the tree with minimum cost, we have, first of all sort the edges considering the cost of each edge, then we can call, as above, ```\ngenerate_spanning_tree/3```\n. So, in prolog code:\n\n```\nmst_prim(graph([H|T],Edges),graph([H|T],TreeEdges),Cost):-\n    predsort(compare_edges_value,Edges,SortedEdges),\n    generate_spanning_tree(T,SortedEdges,TreeEdgesUnsorted),\n    sort(TreeEdgesUnsorted,TreeEdges),\n    sum_cost(TreeEdges,0,Cost).\n\ncompare_edges_value(O,edge(X1,Y1,C1),edge(X2,Y2,C2)):-\n    compare(O,C1+X1+Y1,C2+X2+Y2).\n\nsum_cost([],C,C).\nsum_cost([edge(_,_,C)|T],CT,Tot):-\n    CT1 is CT+C,\n    sum_cost(T,CT1,Tot).\n```\n\n\n```\npredsort/3```\n sorts using ```\ncompare_edge/3```\n to determine the order. ```\nsum_cost/3```\n simply sums the cost of every selected edge. Query:\n\n```\nmake_kn_weighted(4,2,7,G), mst_prim(G,T,C).\nG = graph([1, 2, 3, 4], [edge(1, 2, 3), edge(1, 3, 6), edge(1, 4, 6), edge(2, 3, 5), edge(2, 4, 2), edge(3, 4, 2)]),\nT = graph([1, 2, 3, 4], [edge(1, 2, 3), edge(2, 4, 2), edge(3, 4, 2)]),\nC = 7 ;\n```\n\n\nIn backtracking, it generates all the spanning trees (if you don't want this behaviour, you can add a cut after calling ```\ngenerate_spanning_tree/2```\n). \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "A minimum spanning tree that minimizes the degree of a specific node\r\n                \r\nHow can we find the minimum spanning tree that minimizes the degree of a node ```\nv```\n (among all minimum spanning trees)?\n\nWould modifying Kruskal algorithm such that if there are several edges with the same weight we choose the one that doesn't touch ```\nv```\n solve the problem?\n    ", "Answer": "\r\nTo answer the question in part, modifiying Kruskal's algorithm as sketched in the question does not solve the problem. Consider the graph ```\nG=(V,E,w)```\n where\n\n```\nV = {1,2,3},\nE = {{1,2}, {2,3}, {3,1}},\nw({1,2}) = 1,\nw({1,3}) = 1,\nw({2,3}) = 2\n```\n\n\nand ```\n1```\n is the node of which the degree in the minimum spanning tree is to be minimized. Then, the edge set\n\n```\nS1={{1,2},{1,3}}\n```\n\n\nconstitutes a minimum spanning tree of weight ```\n2```\n. However, the modified version of Kruskal's algorithm would without loss of generality select edge ```\n{1,2}```\n which would result in ```\n{1,3}```\n being forbidden, such that ```\n{2,3}```\n is selected. In total, in the selected edge set\n\n```\nS2={{1,2},{2,3}}\n```\n\n\nthe node ```\n1```\n has lesser degree than in ```\nS2```\n, but the total weight of ```\nS2```\n is ```\n3```\n, which means that it does not constitute a minimum spanning tree.\n\nFurthermore, note that the degree of the node ```\nv```\n which is to be minimized has to be at least ```\n3```\n to have the possibility of more than one neighbourhood of ```\nv```\n in minimum spanning trees.\n\nIn an exhaustive search, select any possible neighbourhood of ```\nv```\n. As ```\nv```\n has at most ```\nn```\n neighbors, there are at most ```\n2^n```\n such neighbourhoods. Using the algorithm by Prim, expand each of these to a spanning tree which is cost-minimal with respect to containing the selected neighborhood of ```\nv```\n; in all these solutions which are cost-minimal, select one in which the degree of ```\nv```\n is minimized. However, the approach does not yield a polynomial-time algorithm.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Boost depth first visitor minimum spanning tree with graph weights\r\n                \r\nI want to create a minimum spanning tree from vertices with edge weights and traverse the graph in depth-first order. I can build the graph and the minimum spanning tree but I am failing at writing the custom visitor.\n\n```\n#include <iostream>\n#include <boost/graph/adjacency_list.hpp>\n#include <boost/graph/kruskal_min_spanning_tree.hpp>\n#include <boost/graph/depth_first_search.hpp>\n#include <boost/graph/graph_traits.hpp>\n\n#include <vector>\n#include <string>\n\ntypedef boost::property<boost::edge_weight_t, double> EdgeWeightProperty;\ntypedef boost::adjacency_list <\n    boost::listS,\n    boost::vecS,\n    boost::undirectedS,\n    boost::no_property,\n    EdgeWeightProperty> MyGraph;\n\ntypedef MyGraph::edge_descriptor Edge;\n\nclass MyVisitor : public boost::default_dfs_visitor\n{\n    public:\n    void tree_edge(Edge e, const MyGraph& g) const {\n\n    }\n};\n\nvoid mst() {\n    MyGraph g;\n    boost::add_edge(0, 1, 0.7, g);\n    boost::add_edge(0, 2, 0.1, g);\n\n    boost::add_edge(1, 2, 0.3, g);\n    boost::add_edge(1, 0, 0.7, g);\n    boost::add_edge(1, 3, 0.8, g);\n    boost::add_edge(1, 4, 0.2, g);\n\n    boost::add_edge(2, 1, 0.3, g);\n    boost::add_edge(2, 0, 0.1, g);\n    boost::add_edge(2, 5, 0.1, g);\n    boost::add_edge(2, 4, 0.5, g);\n\n    boost::add_edge(3, 1, 0.8, g);\n\n    boost::add_edge(4, 1, 0.2, g);\n    boost::add_edge(4, 2, 0.5, g);\n\n    boost::add_edge(5, 2, 0.1, g);\n\n    std::list <Edge> spanning_tree;\n    boost::kruskal_minimum_spanning_tree(g, std::back_inserter(spanning_tree));\n\n    // the following two lines are failing\n    MyVisitor vis();\n    boost::depth_first_search(spanning_tree, visitor(vis));\n}\n\nint main(int argc, char** argv)\n{\n    mst();\n    std::cin.get();\n    return (0);\n}\n```\n\n\nI would like to access the vertices and edge weights in the custom visitor. Is this possible? I saw this post: boost minimum spanning tree, how to do depth first? but I would prefer to not build a separate weight map.\n\nAdditionally, is it possible to iterate in depth-first order through the tree with boost tools without writing a custom visitor?\n    ", "Answer": "\r\n```\nMyVisitor vis();\n```\n\n\nThat is a function declaration. See Most Vexing Parse\n\n```\nboost::depth_first_search(spanning_tree, visitor(vis));\n```\n\n\nThat calls the graph algorithm on a ```\nstd::list<Edge>```\n. ```\ndepth_first_search```\n requires a graph that models the right graph concepts:\n\n\n  \n\n\nThe std::list models neither.\n\nSuggestion\n\nYou could build a graph including just the edges from the MST set. The answer to the question you linked to tries that.\n\nHowever, it seems easier and more efficient to create a ```\nfiltered_graph<>```\n view of the same graph, so that the edge properties are simply available through the same mechanism.\n\nFirst, let's prefer to get the MST edges in a ```\nset<>```\n instead of a ```\nlist<>```\n:\n\n```\nstruct InSpanning {\n    std::set<Edge> edges;\n    bool operator()(Edge e) const { return edges.count(e); }\n} spanning;\n\nboost::kruskal_minimum_spanning_tree(g, std::inserter(spanning.edges, spanning.edges.end()));\n```\n\n\nThe interesting thing you'll note is that ```\nInSpanning```\n is also a function object that be used as a filtering predicate for ```\nfiltering_graph```\n:\n\n```\nboost::filtered_graph<MyGraph, InSpanning, boost::keep_all> mst(g, spanning, {});\n```\n\n\nNow you can call de DFS:\n\n```\nboost::depth_first_search(mst, visitor(vis));\n```\n\n\nI've tweaked the visitor slightly:\n\n```\nstruct MyVisitor : boost::default_dfs_visitor {\n    template <typename Graph>\n    void tree_edge(Edge e, const Graph& g) {\n        std::cout << \"Visiting: \" << e << \" with weight \" << get(boost::edge_weight, g, e) << \"\\n\";\n    }\n};\n```\n\n\nNote:\n\n\nIt doesn't hardcode the ```\nMyGraph```\n type anymore (because the filtered_graph has a different type).\nIt prints the information you wanted to see.\n\n\nLive Demo\n\nLive On Coliru\n\n```\n#include <boost/graph/adjacency_list.hpp>\n#include <boost/graph/filtered_graph.hpp>\n#include <boost/graph/depth_first_search.hpp>\n#include <boost/graph/kruskal_min_spanning_tree.hpp>\n#include <iostream>\n\n#include <string>\n#include <vector>\n\ntypedef boost::property<boost::edge_weight_t, double> EdgeWeightProperty;\ntypedef boost::adjacency_list<boost::listS, boost::vecS, boost::undirectedS, boost::no_property, EdgeWeightProperty>\n    MyGraph;\n\ntypedef MyGraph::edge_descriptor Edge;\n\nstruct MyVisitor : boost::default_dfs_visitor {\n    template <typename Graph>\n    void tree_edge(Edge e, const Graph& g) {\n        std::cout << \"Visiting: \" << e << \" with weight \" << get(boost::edge_weight, g, e) << \"\\n\";\n    }\n};\n\nvoid run_mst_test() {\n    MyGraph g;\n    boost::add_edge(0, 1, 0.7, g);\n    boost::add_edge(0, 2, 0.1, g);\n\n    boost::add_edge(1, 2, 0.3, g);\n    boost::add_edge(1, 0, 0.7, g);\n    boost::add_edge(1, 3, 0.8, g);\n    boost::add_edge(1, 4, 0.2, g);\n\n    boost::add_edge(2, 1, 0.3, g);\n    boost::add_edge(2, 0, 0.1, g);\n    boost::add_edge(2, 5, 0.1, g);\n    boost::add_edge(2, 4, 0.5, g);\n\n    boost::add_edge(3, 1, 0.8, g);\n\n    boost::add_edge(4, 1, 0.2, g);\n    boost::add_edge(4, 2, 0.5, g);\n\n    boost::add_edge(5, 2, 0.1, g);\n\n    struct InSpanning {\n        std::set<Edge> edges;\n        bool operator()(Edge e) const { return edges.count(e); }\n    } spanning;\n\n    boost::kruskal_minimum_spanning_tree(g, std::inserter(spanning.edges, spanning.edges.end()));\n\n    MyVisitor vis;\n    boost::filtered_graph<MyGraph, InSpanning, boost::keep_all> mst(g, spanning, {});\n    boost::depth_first_search(mst, visitor(vis));\n}\n\nint main() {\n    run_mst_test();\n}\n```\n\n\nPrints\n\n```\nVisiting: (0,2) with weight 0.1\nVisiting: (2,1) with weight 0.3\nVisiting: (1,3) with weight 0.8\nVisiting: (1,4) with weight 0.2\nVisiting: (2,5) with weight 0.1\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Is the Minimum Product Spanning Tree different from a Minimum Sum Spanning Tree?\r\n                \r\nIs the Minimum Product Spanning Tree different from a Minimum Sum Spanning Tree? plz explain (with examples ,if possible).I mean,edges that add to the minimum should(?) also have the minimum product. \n    ", "Answer": "\r\nWith all edge weights (positive, negative and zero):\n\nThey may not be the same.\n\nTake this for example:\n\n```\n       -10\n    □______□\n   / \\\n1 |   | 0\n   \\ /\n    □\n```\n\n\nHere we have:\n\n```\nMinimum product spanning tree:         Minimum sum spanning tree:\n       -10                                -10\n    □______□                           □______□\n   /                                    \\\n1 |                                      | 0\n   \\                                    /\n    □                                  □\n```\n\n\nWith non-zero edge weights (positive and negative):\n\nThey may not be the same.\n\nThe product of an even number of negative values results in a positive value, so it would be better to pick a positive value in this case for the minimum product spanning tree.\n\nTake this for example:\n\n```\n       -5\n    □______□\n   / \\\n5 |   | -5\n   \\ /\n    □\n```\n\n\nHere we have:\n\n```\nMinimum product spanning tree:         Minimum sum spanning tree:\n       -5                                 -5\n    □______□                           □______□\n   /                                    \\\n5 |                                      | -5\n   \\                                    /\n    □                                  □\n```\n\n\nIt would also be better to pick higher positive values, as opposed to small negative values, as long we end up with an odd number of negative values.\n\nWith non-negative edge weights (positive and zero):\n\nThere may multiple minimum product spanning trees, some of which may not be the minimum sum spanning tree (I am yet to find a proof / counter example, but currently it looks like at least one of the minimum product spanning trees will have the minimum sum).\n\nTake this for example:\n\n```\n       0\n    □______□\n   / \\\n1 |   | 10\n   \\ /\n    □\n```\n\n\nHere both ```\n10-0```\n and ```\n1-0```\n are minimum product spanning trees, but only ```\n1-0```\n is a minimum sum spanning tree.\n\nWith positive edge weights only and distinct edge weights:\n\nThey will be the same.\n\nProof:\n\nConsider picking between ```\na```\n and ```\nb```\n with a sum of ```\nc```\n in the rest of the tree.\n\nAssuming a,b,c > 0...\n\n```\nAssume ca    < cb\nthen   a     < b      (since c > 0)\nthen   a + c < b + c\n```\n\n\nThus if picking ```\na```\n leads to the smallest product, it will also lead to the smallest sum.\n\nThus getting to the smallest product and the smallest sum will consist of picking all the same edges.\n\nThus they will have the same spanning trees.\n\nWith positive edge weights only and non-distinct edge weights:\n\nThe above assumes distinct edge weights, if this is not the case, there may be multiple spanning trees for either, and they obviously won't necessarily be the same, but the choice of spanning trees for both will be identical because they will all have the same product and the same sum, since the only difference is picking between 2 edges with the same weight.\n\nConsider:\n\n```\n       10\n    □______□\n   / \\\n5 |   | 5\n   \\ /\n    □\n```\n\n\nThe two possible spanning trees are:\n\n```\n       10              10\n    □______□        □______□\n   /                 \\\n5 |                   | 5\n   \\                 /\n    □               □\n```\n\n\nBoth are the minimum product and sum spanning trees (the only difference is which 5 we pick, but 5 = 5, so it doesn't change the sum or product).\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Updating a Prims algorithm for Minimum spanning trees\r\n                \r\nI need help doing a c++ or java method that prints a minimum spanning tree but also prints the minimum spanning tree without all of the vertices that are in the graph. So basically if the min span tree has weight 37 then the min span tree without some edge a to b has weight 49, and  next tree with out edge b to c has  weight 50. \n\nSo the question is, how can i take out arbitrary edges of the MST and calculate a new one without that edge with minimal time complexity.\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum Spanning Tree: What exactly is the Cut Property?\r\n                \r\nI've been spending a lot of time reading online presentations and textbooks about the cut property of a minimum spanning tree. I don't really get what it's suppose to illustrate or even why it's practical. Supposedly it helps determine what edges to add to a MST, but I fail to see how it accomplishes that. My understanding of the cut property so far is that you split a MST into two arbitrary subsets. Any help here? Thanks!\n    ", "Answer": "\r\nA cut of a connected graph is a minimal set of edges whose removal separate the graph into two components (pieces).  The minimal cut property says that if one of the edges of the cut has weight smaller than any other edge in the cut then it is in the MST.  To see this, assume that there is an MST not containing the edge.  If we add the edge to the MST we get a cycle that crosses the cut at least twice, so we can break the cycle by removing the other edge from the MST, thereby making a new tree with smaller weight, thereby contradicting the minimality of the MST.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Dijkstra/Prim Minimum Spanning Tree\r\n                \r\n\n\nApply the Dijkstra/Prim Minimum Spanning Tree algorithm (not Shortest Paths) on the following graph starting at vertex a.\n\n\n\n\nI'm not too sure how I would get started with filling in those charts. This is a question for an exam practice so I want to work on it and understand it. Can someone please help me on how to get started with filling in the charts please?\n\nI would appreciate any informative help. Thanks everyone.\n    ", "Answer": "\r\nSince there are 7 vertices (you could also infer this from the chart), there will be 7 iterations.  Start with phase 0 and fill in the distance of all immediate neighbors adjacent to your starting point.  All those not directly connected to your starting point will be 'infinity' distance.  From there, you should just be able to follow the algorithm.    \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "traveling salesman minimum spanning tree variant\r\n                \r\nI'm trying to solve the following graph exercise:\n\nIn an undirected weighted graph, there are V vertices and E edges. Find the minimum weight needed to visit T(T<=V) vertices, starting from the vertex labeled as 0. Additionally, if there is an edge between two visited vertices, its weight is set to 0.\n\nThis isn't a classic traveling salesman problem, because of the added condition that if you visit two vertices, the weight of the edge between them is reduced to 0.\n\nApproaching it with Prim's minimum spanning tree algorithm solves the problem if T == V, but since you don't necessarily have to visit all vertices, this will not always return the minimum weight.\n\nI thought about finding the minimum spanning tree and then cutting every edge that wouldn't hinder my ability to reach all of my 'target' vertices, but that seems excessive and possibly incorrect.\n\nAny thoughts?\n\nEDIT:\nI'll give you an example. Suppose we have a graph with 4 vertices labeled 0,1,2 and 3. We have the following edges(from,to,weight):\n(0,1,1)\n(0,2,2)\n(1,3,4)\n(2,3,1)\nThe minimum spanning tree would contain edges: (0,1,1), (0,2,2) and (2,3,1). With it, every vertex is reachable starting from 0. However, the goal of the exercise is to reach a T number of those vertices. That being said, we might, for example, only need to reach vertices 2 and 3, making the edge (0,1,1) unnecessary, and thus the total weight needed to reach our target vertices is 2+1, instead of 1+2+1. \n    ", "Answer": "\r\nLooks like your problem is essentially the Steiner tree problem, which is known to be NP-hard.\n\nIndeed, you have an undirected weighted graph (V, E).\nGiven T, a subset of V, you want to find a tree with minimum total weight which covers all vertices of T.\n\nHere is an example where most obvious greedy ideas won't work.\nSuppose our graph is the vertices and edges of a non-regular tetrahedron ```\nABCD```\n where ```\nAB=BC=CA=5```\n and ```\nAD=BD=CD=3```\n.\nIf we want to connect A, B and C together, the best we can do is to use edges ```\nAD```\n, ```\nBD```\n and ```\nCD```\n for a total weight of ```\n9```\n.\nIf we decide not to use ```\nD```\n, we have to take at two edges each of length ```\n5```\n instead, for a total weight of ```\n10```\n.\nHowever, each two-vertex subset of the set ```\nABC```\n uses one direct edge of weight ```\n5```\n (```\nAB```\n, ```\nBC```\n or ```\nCA```\n) and no edges to vertex ```\nD```\n in the optimal solution.\n\n(Ouch! The exact lengths are not possible in three-dimensional Euclidean geometry. Still, it will serve as an example.)\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum spanning tree of graph obtained by Prim's algorithm\r\n                \r\nI need some assistance on a Prim's algorithm problem:\n\nLet T be a minimum spanning tree of graph G obtained by Prim's algorithm. Let Gnew be a graph obtained by adding to G a new vertex and some edges with weights, connecting the new vertex to some vertices in G. Can we construct a minimum spanning tree of Gnew by adding one of the new edges to T? If you answer yes, explain how; if no, explain why. \n\nThank you in advance!!\n    ", "Answer": "\r\n\n  Can we construct a minimum spanning tree of Gnew by adding one of the\n  new edges to T?\n\n\nNo. Not in general. \nAssume ```\nT```\n has been generated by considering verteices in order ```\nv1,v2,...,vn-1```\n\n\nLet ```\nvn```\n be the new vertex and ```\n(v1,vn)```\n be a weighted edge (v1 is the root of T), if the weight of ```\n(v1,vn)```\n is smaller than the weight of ```\n(v1,v2)```\n in T, this would not be MST anymore. \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum spanning trees with weight\r\n                \r\nAt first I wanted to make a maximum spanning tree for my research, but I saw that it was going to be too complex given the time and the knowledge I had in R to do it properly.\nSo my option was to create a minimum spanning tree by reversing the order of the data.\nIndeed, working on ordinal data going from 1 to 3, I just had to reverse the order in the database.\nI managed to find a syntax that helped me a lot here: https://web.stanford.edu/class/bios221/book/Chap-Graphs.html#minimum-spanning-trees\nI made the necessary adjustments to get a graph. However I can't put the weight on this graph...\nHere is the goal I want to reach: to get a minimum spanning tree with the weight between each point without the titles of the nodes overlapping and with the nodes fitting correctly in the plot.\nHere is what I can't do and what I don't understand:\nThe repel command doesn't work and I can't figure out why. R tells me that this command is unknown. I insert: geom_node_text(aes(label = name), repel = TRUE. It doesn't make the command buggy. I don't really understand why\nPut the weight : I tried : graph.adjacency(mstree, mode = \"undirected\",weight=TRUE) visibly that I put weight true or false it does not change anything. Again, I must have missed something\nI tried to make an example that is as close as possible to my problem. (This is the first time I publish an example, I hope I did it correctly) :\n```\nlibrary(dplyr)\nlibrary(igraph)\nlibrary(ape)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(ggnetwork)\nlibrary(ggraph)\n\nM1 <- as_tibble(replicate(21,sample(1:3,100,rep=TRUE)))\ncolnames(M1) <- c(\"1st\", \"2nd\", \"3th\", \"4th\", \"5th\", \"6th\",\"7th\",\"8th\",\"9th\",\"10th\",\n                          \"11th\",\"12th\",\"13th\",\"14th\",\"15th\",\"16th\",\"17th\",\"18th\",\"19th\",\n                          \"20th\",\"21th\")\n\nM2 <- as.matrix(round(cor(M1[,],method =\"kendall\"),2))\n\nmstree <- ape::mst(M2)\ngr4ph <-  graph.adjacency(mstree, mode = \"undirected\",weight=TRUE)\ngg <-  ggnetwork(gr4ph, arrow.gap = 0, layout = layout_with_fr(gr4ph))\nggplot(gg, aes(x = x, y = y, xend = xend, yend = yend)) +\n  geom_edges(color = \"black\", alpha = 1, curvature = 0.1) +\n  geom_nodes(aes(color = name), size = 6) +  theme_blank() +\n  geom_nodetext(aes(label = name), color = \"black\", size = 3.5) +\n  theme(plot.margin = unit(c(0, 1, 2, 4), \"cm\"))+\n  guides(color = guide_legend(keyheight = 0.09, keywidth = 0.09,\n                              title = \"Mots\")) + theme(legend.position = c(-0.05, 0.14),\n                                                       legend.background = element_blank(),\n                                                       legend.text = element_text(size = 7))\n```\n\nThank you for your help\n    ", "Answer": "\r\nThe ```\nigraph```\n doc page has an argument called ```\nweighted```\n, which works.\n```\n# weighted\nn1 <- igraph::graph.adjacency(mstree, mode = \"undirected\", weighted = TRUE)\nE(n1)$weight # 1 1 1 1 etc.\n\n# unweighted\nn2 <- igraph::graph.adjacency(mstree, mode = \"undirected\", weighted = NULL)\nE(n2)$weight # NULL\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Proving the following claim for MST (Minimum Spanning Trees)?\r\n                \r\nI want to prove the following claim for undirected and connected graph, Spanning Tree (T) and weight function with real numbers:\n\n$T$ is a minimum spanning tree in $G=(V,E)$ iff for every edge\n$e=u-v$ in $E$ the weight of it is bigger or equal to the heaviest\nedge in the only (simple) path between $u$ and $v$ in $T$\n\nIf $T$ is a minimum spanning tree in $G=(V,E)$ it's easy to prove the claim, but what about the other direction?\nI've no clue, plus I tried to assume that $T$ is NOT a minimum spanning tree in $G=(V,E)$ and try to reach a contradiction, but that assumption doesn't seem to add much of information (if a spanning tree isn't MST then what can I see more than that)?\n    ", "Answer": "\r\nLet T satisfy the condition, let us prove that it is a MST.\nBy contradiction, if it is not there is a different MST S. Let (u,v) be in S and not in T, if we remove it from S we are left with a graph S' with exactly two connected components. Now observe (hint : T is spanning) there is at least one edge (a,b) != (u,v) in T that connects them. By the condition, (a,b) has a smaller weight than (u,v), so if we add it to S' we obtain a spanning tree with smaller weight than S, which is absurd since S was supposed to be a MST.\nConclusion : T is a MST.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Understanding a part of minimum spanning tree in java code [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 3 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nCan any one explain this two parts of this code to me which is a part of a java code as an application for data structures for Dijkstra shortest path minimum spanning tree\n\nThe first One:-\n\n```\nPriorityQueue<Edge> pq = new PriorityQueue<>(allEdges.size(), Comparator.comparingInt(o -> o.weight));\n```\n\n\nThe second one:-\n\n```\nmakeSet(parent);\n```\n\n\nThe Code :-\n\n```\n public String MST(){\n\n    PriorityQueue<Edge> pq = new PriorityQueue<>(allEdges.size(), Comparator.comparingInt(o -> o.weight));\n\n    for (int i = 0; i <allEdges.size() ; i++) {\n        pq.add(allEdges.get(i));\n    }\n\n    int [] parent = new int[vertices];\n    makeSet(parent);\n\n    ArrayList<Edge> mst = new ArrayList<>();\n    int index = 0;\n\n    while(index<vertices-1){\n        Edge edge = pq.remove();\n        System.out.println(\"Source : \"+edge.source+\", Dest : \"+edge.destination+\", Weight : \"+edge.weight);\n        int x_set = find(parent, edge.source);\n        int y_set = find(parent, edge.destination);\n\n        if(x_set==y_set){}\n\n        else {\n            mst.add(edge);\n            index++;\n            union(parent,x_set,y_set);\n        }\n    }\n    String str = \"\";\n    str+=\"Minimum Spanning Tree :-\\n\";\n    str+=printMST(mst);\n    return str;\n}\n\npublic void makeSet(int [] parent){\n    for (int i = 0; i <vertices ; i++) {\n        parent[i] = i;\n    }\n}\n\npublic int find(int [] parent, int vertex){\n    if(parent[vertex]!=vertex)\n        return find(parent, parent[vertex]);;\n    return vertex;\n}\n\npublic void union(int [] parent, int x, int y){\n    int x_set_parent = find(parent, x);\n    int y_set_parent = find(parent, y);\n    parent[y_set_parent] = x_set_parent;\n}\n```\n\n    ", "Answer": "\r\nFor First Part, It is a property of Priority Queue or Heap, that it can sort \nas per our need and either max or min will always be at top. \n\nNow here, There would be custom class named Edge. It is not there in your code, but it will be there. First part is to sort the priority queue in such a way that edge with minimum weight should come at the top. This is the reason we have used custom comparator.\n\n```\nPriorityQueue<Edge> pq = new PriorityQueue<>(allEdges.size(), Comparator.comparingInt(o -> o.weight));\n```\n\n\nAs when we find minimum spanning tree, we need edge with minimum weight, so this is done. I have a similar code for Minimum Spanning Tree in Java, let me know if you need it.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Is there a minimum spanning tree in a non-planar graph?\r\n                \r\nIs there a minimum spanning tree in a non-planar graph? I have read about prim algorithm and triangle inequality and my graph doesn't satisfy the triangle inequality? \n    ", "Answer": "\r\nIn the proof of correctness I read of prim's algorithm here, triangle inequality was not used once. So prim's algorithm should be valid for non-metric graphs(those that do not satisfy triangle inequality) too. So you can apply prim's algorithm to find the MST for a connected weighted undirected graph.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum Spanning Tree count given an edge that must be included\r\n                \r\nI am confused about the general form of a minimum spanning tree that includes an edge e that is not part of the minimum spanning tree. My question is:\n\nLet G be a weighted graph with all the edges weight equal to 1. The MST of G does not include an edge e. How many MSTs can be made with the constraint that they include edge e ?\n    ", "Answer": "\r\n\n  When a graph is unweighted, any spanning tree is a Minimum Spanning Tree.\n\n\nIdentical weight of 1 can be considered the same as unweighted.\n\n\n  In the mathematical field of graph theory Kirchhoff's theorem or Kirchhoff's matrix tree theorem named after Gustav Kirchhoff is a theorem about the number of spanning trees in a graph.\n\n\nNumber (MST including e) = Number (All MST)<1> - Number (MST without e)<2>\n\n<1> can be derived by Kirchhoff's theorem, and\n\n<2> can be derived by Kirchhoff's theorem after removing e from the graph.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "a new edge is insert to a Minimum spanning tree\r\n                \r\nI trying to find an algorithm to the following question with one different : \nthe edge are not distinct. \n\nGive an efficient algorithm to test if T remains the minimum-cost spanning tree with the new edge added to G.\n\nin this link- there is a solution but it is not for the different I wrote up: \nthe edges are not nessecerliy distinct.\n\nUpdating a Minimum spanning tree when a new edge is inserted\n\nsomeone has an idea? \n    ", "Answer": "\r\nWell, the naive approach of just using Prim or Kruskal to find the min cost spanning tree of the new graph and then see which one has a lower total cost isn't too bad at O(|E|log|E|).\n\nBut we don't need to look at the whole graph.\n\nSuppose your new edge connects vertices A and B. Let C be the parent of A. If B is not a descendent of A, then if A-B is lower cost than A-C, then T is no longer the MST and B should be the new parent of the subtree rooted at A.\n\nIf B is a descendant of A, then if A-B is shorter than any of the branches in T along the path from A to B, then T is no longer the MST, and the highest cost edge along that path should be removed, B is the root of the newly disconnected component, and should be added as a child of A.\n\nI believe you may need to check these things a second time, reversing which vertices are A and B. The complexity of this is log|V| where the base of the log is the average number of children per node of T. In the case of T being a straight line, it's O(|V|), but otherwise, I think you could say it is O(log|V|).\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Euclidean Minimum Spanning Tree in pandas python\r\n                \r\nI have a data frame which consists:\n\n```\nsource  dest  euclidean\n A       B       0.5\n A       C       1.5\n A       D       0.5\n A       E       0.8\n B       C       0.5\n B       D       6.5\n B       E       5.4\n B       A       4.8\n C       B       4.3\n C       D       3.6\n C       E       2.6\n C       A       3.5\n D       B       8.0\n D       C       2.7\n D       E       7.7\n D       A       7.3\n```\n\n\nI want to find Minimum Spanning Tree Which connects these points, where the weights edges are euclidean distance.\n\nI tried using a method shown in Geeks for geeks EMST :\n\n```\ng = Graph(4)\nfor index,row in df.iterrows():\n  g.addEdge(row['source'],row['dest'],row['euclidean'])\n\ng.KruskalMST()\n```\n\n\nBut it gave an error.\n\nIs there any other way I Can find this? Any leads will be helpful\n    ", "Answer": "\r\nUsing networkx, you can use\n\n```\nfrom networkx import *\n\ng = Graph()\nfor index,row in df.iterrows():\n  g.add_edge(row['source'],row['dest'],weight=row['euclidean'])\n\n>>> list(minimum_spanning_edges(g))\n[('A', 'E', {'weight': 0.8}),\n ('C', 'E', {'weight': 2.6}),\n ('C', 'D', {'weight': 2.7}),\n ('B', 'C', {'weight': 4.3})]\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum Spanning tree different from another\r\n                \r\nAssume we are given\n\nan undirected  graph ```\ng```\n where every node i,1 <= i < n is connected to all j,i < j <=n \n\nand a source ```\ns```\n.\n\nWe want to find the total costs (defined as the sum of all edges' weights) of the cheapest minimum spanning tree that differs from the minimum distance tree of ```\ns```\n (i.e. from the MST obtained by running prim/dijkstra on ```\ns```\n) by at least one edge.\n\nWhat would be the best way to tackle this? Because currently, I can only think of some kind of fixed-point iteration \n\n\nrun dijkstra on ```\n(g,s)```\n to obtain reference graph ```\nr```\n that we need to differ from\n```\ncosts := sum(edge_weights_of(r))```\n\n```\nchange := 0```\n\nfor each vertex ```\nu```\n in ```\nr```\n, run a bfs and note for each reached vertex ```\nv```\n the longest edge on the path from ```\nu```\n to ```\nv```\n.\niterate through all edges ```\ne = (a,b)```\n in ```\ng```\n: and find ```\ne'=(a',b')```\n that is NOT in ```\nr```\n and minimizes ```\nnewchange := weight(e') - weight(longest_edge(a',b'))```\n\nif(first_time_here OR ```\nnewchange < 0```\n) then ```\nchange += newchange```\n\nif(newchange < 0) ```\ngoto 4```\n\n```\nresult := costs + change```\n\n\n\nThat seems to waste a lot of time... It relies on the fact that adding an edge to a spanning tree creates a cycle from which we can remove the longest edge.\n\nI also thought about using Kruskal to get an overall minimum spanning tree and only using the above algorithm to replace a single edge when the trees from both, prim and kruskal, happen to be the same, but that doesn't seem to work as the result would be highly dependent on the edges selected during a run of kruskal.\n\nAny suggestions/hints?\n    ", "Answer": "\r\nYou can do it using Prim`s algorithm\n\n```\nPrim's algorithm:\nlet T be a single vertex x\nwhile (T has fewer than n vertices)\n{\n    1.find the smallest edge connecting T to G-T\n    2.add it to T\n}\n```\n\n\nNow lets modify it.\n\nLet you have one minimum spanning tree. Say Tree(E,V)\nUsing this algorithm\n\n```\nPrim's algorithm (Modified):\nlet T be a single vertex \nlet isOther = false\nwhile (T has fewer than n vertices)\n{\n    1.find the smallest edge (say e) connecting T to G-T\n    2.If more than one edge is found, {\n        check which one you have in E(Tree)\n        choose one different from this \n        add it to T\n        set isOther = true\n      }\n      else if one vertex is found {\n        add it to T\n        If E(Tree) doesn`t contain this edge, set isOther = true\n        Else don`t touch isOther ( keep value ).\n      }\n}\nIf isOther = true, it means you have found another tree different from Tree(E,V) and it is T, \nElse graph have single minimum spanning tree\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum Spanning Tree using Dijkstra algorithm\r\n                \r\nI got a graph with costs and letters on it. My task is not to find the best path from one node to another- this is finding a minimum spanning tree. \n\nI did some table for that purpose and marked the best path for that tree.\n\n\n\n\n\nbut I do not know if I should go further from K node to another nodes or not. Still, the purpose is not finding the best path from A to K but MST.\n    ", "Answer": "\r\nDijkstra's cannot be used to find the MST for a graph. It is a greedy algorithm which finds the shortest path between nodes. So, while it minimizes the cost of getting from one node to the others, it will not always produce the MST for the entire graph. The total weight of the edges from Dijkstra's may not equal the total weight of the MST.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to calculate minimum spanning tree in R\r\n                \r\nGiven a graph of N vertices and the distance between the edges of the vertices stored in tuple ```\nT1 = (d11, d12, …, d1n) to Tn = (dn1, dn2, …, dnn)```\n. Find out a minimum spanning tree of this graph starting from the vertex V1. Also, print the total distance travel needed to travel this generated tree.\n\n```\nExample:\nFor N =5 \nT1 = (0, 4, 5, 7, 5)\nT2 = (4, 0, 6, 2, 5)\nT3 = (5, 6, 0, 2, 1)\nT4 = (7, 2, 2, 0, 5)\nT5 = (5, 5, 1, 5, 0)\n\nSelection of edges according to minimum distance are:\nV1 -> V2 = 4\nV2 -> V4 = 2\nV4 -> V3 = 2\nV3 -> V5 = 1\n\nThus, MST is V1 -> V2 -> V4 -> V3 -> V5 and the distance travelled is 9 (4+2+2+1)\n```\n\n\nLiterally,I don't have idea about how to create a graph of n vertices in R.\n\nI searched in google but i didn't understand how to approach above problem.\n\nPlease,help me.\n    ", "Answer": "\r\nYour question doesn't seem to match the title - you're after the graph creation not the MST? Once you've got a graph, as @user20650 says, the MST itself is easy. \n\nIt is easy to create a graph of size n, but there is a whole lot of complexity about which nodes are connected and their weights (distances) that you don't tell us about, so this is a really basic illustration.\n\nIf we assume that all nodes are connected to all other nodes (full graph), we can use ```\nmake_full_graph```\n. If that isn't the case, you either need data to say which nodes are connected or use a random graph.\n\n```\n# create graph\nn <- 5\ng <- make_full_graph(n)\n```\n\n\nThe next issue is the distances. You haven't given us any information on how those distances are distributed, but we can demonstrate assigning them to the graph. Here, I'll just use random uniform [0-1] numbers:\n\n```\n# number of edges in an (undirected) full graph is (n2 - n) /2 but\n# it is easier to just ask the graph how many edges it has - this\n# is more portable if you change from make_full_graph\nn_edge <- gsize(g)\ng <- set_edge_attr(g, 'weight', value=runif(n_edge))\nplot(g)\n```\n\n\n\n\nThe next bit is just the MST itself, using ```\nminimum.spanning.tree```\n:\n\n```\nmst <-  minimum.spanning.tree(g)\n```\n\n\nThe output ```\nmst```\n looks like this:\n\n```\nIGRAPH dc21276 U-W- 5 4 -- Full graph\n+ attr: name (g/c), loops (g/l), weight (e/n)\n+ edges from dc21276:\n[1] 1--4 1--5 2--3 2--5\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Given an edge, find a minimum spanning tree if exist\r\n                \r\nI have a weighted undirected graph G and an edge e. I need to find a minimum spanning tree containing e, if and only if it exists.\n    ", "Answer": "\r\nI can interpret your question 2 different ways:\n\n\nfind all minimum spanning trees. If any contains e, return it. Otherwise return null.\nUse Kruskals algorithm, add e to the spanning tree before doing anything else. Build the remaining tree. If you are able to create a minimum spanning return it.\n\n\nThere are two potential points of failure:\n\nA. the graph contains components not connected by an edge (no spanning tree exists)\n B. the minimal spanning tree does not contain e\n\nApproach (1) fails on condition A and B. Approach (2) fails only under condition A.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "how to represent being minimum spanning tree in linear programming constrains?\r\n                \r\nsuppose we are given a weighted graph G and a spanning tree T of it.we want to change weights of edges so that T be a minimum spanning tree and sum of all |w_i - w'_i| be minimum where w_i is the weight of edge i_th and w'_i is the weight of edge i_th after changing it.\n\nI think it's obvious our goal is to minimize sum of |w_i - w'_i| for all i and our variables are w'_i but i can't find how to represent T is minimum spanning tree in constrains.\n    ", "Answer": "\r\nFor each i such that the ith edge is not in T, for each j such that the jth edge lies on the unique path in T from one endpoint of the ith edge to the other, there is a constraint wi' - wj' ≥ 0.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum spanning tree 2- dimensional graph\r\n                \r\nThis is my home work problem but i dont have any clue how to proceed with this \nA “geometric graph” is a special type of graph where the nodes are points on a 2- dimensional\nsurface and edges are straight lines joining pairs of nodes. Show that the minimum spanning tree of\nsuch graphs cannot have edges that cross each other (other than at their endpoints). \n    ", "Answer": "\r\nI have this answer from my algorithm's TA for the same question, let me know if it helps:\n\n\nThe idea is that, if a path contains two edges that cross each other, we can replace those crossing edge with some other edge to get a smaller path.\nFor example, if there are two edges ac and bd that cross each other, we can replace them with edge ab and cd and get smaller path length.\nIn geometric graph there is an edge between every pair of vertexes, they also follow triangle inequality.\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Calculate number of Minimum Spanning Trees\r\n                \r\nI'd like to know how can I calculate the total number of MST (minimum spanning trees), given a Graph.\nI don't need the code, just the explanation of the procedure\n    ", "Answer": "\r\nWell, you can have a look at these two papers. If you still need clarification, let me know:\n\n\nThe Number of Spanning Trees in a Graph by Konstantin Pieper\nCounting Minimum Weight Spanning Trees by Andrei J.Broder\n\n\nYou can use Scihub or Sciencedirect membership to access 2.\n\nYou can also test your code by solving this problem on SPOJ.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Finding a minimum-bottle neck spanning tree\r\n                \r\nHi so i'm doing some test prep and i need to figure out parts b and c. I know part a is true and i can prove it, but finding the algorithms for part b and c is currently eluding me.\n\n\n  Solve the following for a minimum bottleneck tree where the edge with the maximum cost is referred to as the bottleneck. \n  (a) Is every minimum-bottleneck\n  spanning tree of G a minimum-spanning tree of G? Prove your claim.\n  \n  (b) For a given cost c, give an O(n+m)-time algorithm to\n  find if the bottleneck cost of a minimum-bottleneck spanning tree\n  of G is not more than c.\n  \n  (c) Find an algorithm to find a minimum-bottleneck\n  spanning tree of G.\n\n\nthanks in advance to anyone who can help me out\n    ", "Answer": "\r\nFor (b):\n\nErase every edge in G that costs more than c, then check if the left graph is still connected.\n\nFor (c):\n\nDo a binary search on c, using the algorithm that solved (b) as the dividing condition.\n\nProof of (b):\n\nLet's say the graph we got after deleting edges cost more than c from G is G' .\nThen:\n\n\nIf G' is connected, then there must be a spanning tree T in G'. Since no edge in G' costs more than c, we can tell for sure that no edge in T costs more than c. Therefore T is a spanning tree for G' and also G whose bottle neck is at most c\nIf G' is not connected, then there's no spanning tree in G' at all. Since we know every edge in G- G' costs more than c, and we know that any spanning tree of G will contains at least one edge of G- G', therefore we know there's no edge spanning tree of G whose bottle neck <= c\n\n\nAnd of course detecting if a graph is connected costs O(n+m)\n\nProof of (c):\n\nSay, the algorithm we used in (b) is F(G,c) . \n\nThen we have \n\nIf F(G,c) = True for some c, then F(G,c') = True for all c' that have c'>=c\n\nIf F(G,c) = False for some c, then F(G,c') = False for all c' that have c'<=c\n\nSo we can binary search on c :)\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum of number of minimum spanning trees(MST) of complete graph\r\n                \r\nWhat's minimum number of minimum spanning trees(MST) of complete graph with N vertex?\n    ", "Answer": "\r\nI believe that the answer is 1.\n\nIt is possible to construct a complete graph with n nodes that has exactly one MST.  To do this, construct a graph with n nodes labeled 1, 2, 3, ..., n.  Then, add an edge of cost 0 from 1 to 2, from 2 to 3, from 3 to 4, ..., from n - 1 to n, and add edges connecting every other pair of nodes that has cost 1.  Clearly, picking all the zero-cost edges gives one possible spanning tree of this graph, and it's the minimum spanning tree because if any other choice of edges were picked, the cost would be at least 1.  Moreover, this is the only MST in the graph that has cost 0, since if another set of edges were picked, that set would have to include at least one edge of cost at least 1, so the total MST would have cost at least 1.\n\nHope this helps!\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Is there any minimum spanning tree that contains the maximum-weight edge on some cycle?\r\n                \r\nThe origin problem is from the exercise of Introduction of Algorithm.\n\n23.1-5 Let ```\ne```\n be a maximum-weight edge on some cycle of connected graph ```\nG=(V, E)```\n. Prove that there is a minimum spanning tree of ```\nG'=(V, E - {e})```\n that is also a minimum spanning tree of ```\nG```\n. That is, there is a minimum spanning tree of ```\nG```\n that does not include ```\ne```\n.\n\nThe question is that: I think the proposition that all the minimum spanning tree of ```\nG```\n do not include ```\ne```\n is right. The ```\ne```\n is the only one maximum-weight edge on some cycle. Is it ?\n\nUpdate: 2016-10-28 20:21\n\nAdd the restriction that ```\ne```\n is the only one maximum-weight edge on some cycle.\n    ", "Answer": "\r\nOne test case is when there are nodes labeled 0..n-1 and there are links only between node i and node (i + 1) mod n (that is, a ring). In this case the minimum spanning tree is created by leaving out just one of the links. If e is the unique maximum weight edge it is not in the unique spanning tree, which is all the other links. If there is more than one edge of maximum weight then there are as many different minimum spanning trees as there are edges of maximum weight, each one of them leaving out a different edge of maximum weight and keeping the other ones in.\n\nConsider the case when there is just one edge of maximum weight. Supposing somebody hands you a minimum spanning tree that uses this edge. Delete it from the tree, giving you two disconnected components. Now try adding each of the other edges in the cycle, one at a time. If the edge doesn't connect the two components, delete it again. If any of the edges connect the two components, you have a spanning tree of smaller weight than before, so it can't have been a minimum spanning tree. Can it be the case that none of the edges connect the two components? Adding an edge that doesn't connect the two components doesn't increase the set of nodes reachable from either component, so if no single edge connected the two components, adding all of them at the same time won't. But we know that adding all of these edges adds a path that connects the two nodes connected by the previous maximum weight edge, so one of the edges must connect the components. So our original so-called minimum spanning tree wasn't, and an edge which is of unique maximum weight in a cycle can't be part of a minimum spanning tree.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Weighted minimum spanning tree of nbunch of Graph in networkx\r\n                \r\nI have lists of starting and nodes and the distance between them which I input into networkx as follows:\n\n```\nimport networkx as nx\n\ns, t = [], [] # int lists assuming long lists of starting and ending nodes forming a meshed network\nd = [] # float list of  distance between each starting and ending node\nG = nx.Graph()\n\nfor i, j, k in zip(s,t,d):\n    G.add_edge(s,t, weight=d)\n```\n\n\nc is a list that is a subset of G.nodes(), I want to find the minimum spanning tree of only the c nodes but respecting the weight and topology of the network. Therefore I started by finding the shortest path as follows:\n\n```\nfor i in range(len(c)):\n    for j in range(len(c)):\n        for i != j\n            path.append(nx.dijkstra_path(G, source=c[i], target=c[j])\n```\n\n\nor:\n                path.append(nx.shortest_path(G, source=c[i], target=c[j])\n\nFrom that I would take the length of the shortest paths to produce a simplified graph between only the c nodes but with the shortest path lengths as the weights between the c nodes and then I find the minimum spanning tree of that simplified graph.\n\nHowever, when I try dijkstra I get the error\n\n```\nTypeError: unsupported operand type(s) for +: 'int' and 'list'\n```\n\n\nWhen I try, shortest_path I don't get the weights\n\nAny thoughts on finding the weighted shortest path?\n\nOverall is there a better strategy to finding a weighted minimum spanning tree of nbunch nodes in the a Graph?\n\nAny help is appreciated!\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to create a minimum spanning tree with R\r\n                \r\nI'm trying to create a minimum spanning tree with R.\nMy problem is that I have my distances stored in a txt as follow:\n\n```\nPID1  PID2 distance\n1      4     0.002\n2      5     0.004\n3      6     0.003\n```\n\n\nDoes exist anyway in which I can use my txt as matrix? I tried to transform it but I couldn't.\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Updating a Minimum spanning tree when a new edge is inserted\r\n                \r\nI've been presented the following problem in University:\n\nLet G = (V, E) be an (undirected) graph with costs ce >= 0 on the edges e ∈ E. Assume you are given a minimum-cost spanning tree T in G. Now assume that a new edge is added to G, connecting two nodes v, tv ∈ V with cost c.\n\n\nGive an efficient algorithm to test if T remains the minimum-cost spanning tree with the new edge added to G (but not to the tree T). Make your algorithm run in time O(|E|). Can you do it in O(|V|) time? Please note any assumptions you make about what data structure is used to represent the tree T and the graph G.\nSuppose T is no longer the minimum-cost spanning tree. Give a linear-time algorithm (time O(|E|)) to update the tree T to the new minimum-cost spanning tree.\n\n\nThis is the solution I found:\n\n```\nLet e1=(a,b) the new edge added\nFind in T the shortest path from a to b (BFS)\nif e1 is the most expensive edge in the cycle then T remains the MST\nelse T is not the MST\n```\n\n\nIt seems to work but I can easily make this run in O(|V|) time, while the problem asks O(|E|) time. Am I missing something?\n\nBy the way we are authorized to ask for help from anyone so I'm not cheating :D\n    ", "Answer": "\r\nYou've got the right idea, though you can do better than BFS for the shortest-path search if you store the tree the right way.\n\nSay one node r in T is the root (you can pick any node and BFS from there to generate this structure if you have marked the tree edges in a matrix or adjacency-list graph structure), and each other node has a parent pointer and a depth count.  To find the shortest path between a and b in T:\n\n\nLet a be the 'deeper' node; swap if needed.\nTraverse the parent links from a until either b or r is reached, storing the path traversed, marking the nodes visited.\nIf you reach b, the shortest path is as traversed.\nIf you reach r, then also traverse from b to the root; if you reach node reached in the traversal from a to r, stop.  Join the two where they meet and you have the shortest path in T.\n\n\nProof of the validity of this algorithm is left as an exercise to the reader.  This is O(|V|) like BFS, but will also generally be faster.  Only a few MST configurations would actually require O(|V|) time in practice.  Of course, generating the parent-link tree takes O(|V|) time to begin with, so this only help in some circumstances, such as if you use an MST-building algorithm that naturally creates this structure in the process of determining the MST.\n\nAs another commenter said, note that if there is a MST for a graph it is connected, so |V| <= |E| and thus O(|V|) < O(|E|).\n\nAlso, to fix the tree in O(|V|) time, if needed, simply find the longest edge on the cycle and remove it, replacing it with the new edge.  Doing this efficiently with a parent-link MST is also an exercise for the reader.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Speeding up random minimum spanning tree in networkx?\r\n                \r\nHere's a bit of code whose goal is to build a random spanning tree using greedy and random edge weights. It runs much slower than I would like it to. Any tips for ways to speed it up?\n\nBoth the randomly generating weights and the sampling of a minimum spanning tree are slow... the first is especially weird to me, because there are only 179400 edges and np.random.uniform(0,1,179400) executes very quickly.\n\n(Here slow means on the order of seconds.)\n\n(I'm happy to use something other than networkx,but it's not preferable.)\n\n```\nimport numpy as np\nimport networkx as nx\n\ngraph = nx.grid_graph([300, 300])\n\nfor edge in graph.edges():\n    graph.edges[edge][\"weight\"] = np.random.uniform(0, 1)\n\ntree = nx.minimum_spanning_tree(graph)\n```\n\n    ", "Answer": "\r\nIf bulk production of random numbers is quicker in your tests, then just do that.\n\n```\nrand = np.random.uniform(0, 1, graph.edges.size())\ni = 0\nfor edge in graph.edges():\n    graph.edges[edge][\"weight\"] = rand[i]\n    i += 1\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Split an undirected graph by multiple minimum spanning trees\r\n                \r\nI want to split an undirected graph by multiple minimum spanning trees. There are some special (root) nodes from which I want to start constructing a minimum spanning tree and I know every weight between nodes.\nIs there any algorithm to solve this problem?\nIf there are no strict methods, any approximate methods are fine for me.\nI attach two output examples. I will be glad if you help me.\nThank you.\n\n\n    ", "Answer": "\r\nThe problem can be solved by creating another special node (lets call red node). Connect red node with every special node (black nodes in initial graph) with zero weight edge. Then search MST from red node. At the end remove red node and all corresponding edges from node, this will split graph into several graphs (same number of special nodes). \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "compute the minimum spanning tree of undirected graph\r\n                \r\nConsider an undirected graph with n vertices, and m edges. Assume that the edges are of two types: m1 red edges and m2 green edges. Thus m = m1 + m2. The red edges have weight 1, and the green edges have weight 2. Design and analyze an efficient algorithm to compute the minimum spanning tree of such a graph\n    ", "Answer": "\r\nArbitrarily pick a node in the undirected graph to begin with.\n\nCreate a hashtable with a key for every node in the graph. For the values of each node in the hastable, initialize the value to be -1 except for the node that you are beginning with, in which you initialize it to -100. These values will represent the cost to get to that node. \"Special numbers\" are -1 which signifies that the cost to get to that node is currently unknown and -100 which signifies that the node is already in the MST.\n\nNow for each of the adjacent nodes to the node that you started with, update those nodes in the hashtable to be either 1 or 2 (depending on whether the edge between them is red or green). \n\nNow look through the hashtable and determine which node has the lowest value that is not -1 or -100. If there are multiple ones with the same lowest cost, just randomly pick one of them. Add that node to the MST and set the value of that node to -100.\n\nUpdate the hashtable with the newly included node included in the tree. It could be possible that a node was initially a cost of 2 away but is now a cost of 1 away with the added node. In that case, update the cost of those nodes from 2 to 1.\n\nKeep repeating the above steps until all nodes have been covered. You now have your Minimum Spanning Tree!\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "about cut in minimum spanning tree\r\n                \r\nI am reading about minimum spanning trees algorithms. It is mentioned about cut. \nA cut (S, V-S) of an undirected graph G = (V, E) is a parition of V.\nAn edge is a light edge crossing a cut if its weight is the minimum of any edge crossing\nthe cut.\n\nHow above definitions is used in Kruskal's and Prims algorithms?\n\nI am not getting how cut is used in Kruskals and Prim's algorithms\n\nThanks\n    ", "Answer": "\r\nIn Prim's algorithm, first a vertex(any) is chosen. Now, cut such that, that the chosen vertex belongs to ```\nS```\n and rest are ```\nV-S```\n. Now, you chose the lightest weight edge and add the connecting vertex to ```\nS```\n. And, you continue doing it till all the vertices are in ```\nS```\n. \n\nIn Kruskal's algorithm, you keep adding the minimum weight edge in the graph to the set ```\nS```\n.\nYou can cut the graph in any manner, but if that cut passes through the minimum weight edge, then that edge will be the lightest edge. And, it has to be added to the minimum spanning tree (provided that it connects two different trees).\n\nI hope that helps.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum Spanning Tree with Additional Vertex\r\n                \r\nDoes minimum spanning tree works for situation like this: If I want to go from A to B and I do not have to go to E, but the direct distance between A and B is larger than distance_AE + distanceEB, so I can go E first and then go to B. I'm not sure if the normal implementation of mst also works for this kind of graph. So if I want to find the mst of ABCD, but E is not included in this graph, how can I solve this?\n    ", "Answer": "\r\nI believe that you're confused about the basic problem: what you've posted is a contradiction.  If ```\nE```\n is not in the graph, then by definition dist(A, E) is undefined; for algorithmic purposes, it's ```\nInf```\n (infinity).\n\nYes, the MST algorithms work fine for this: the entire universe consists of (A, B, C, D).\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "What is a minimum leaf spanning tree?\r\n                \r\nCould someone explain to be what a minimum leaf spanning tree is? I am confused to what exactly is a leaf in a spanning tree. I understand a spanning tree contains simple paths with no cycles and it spans all vertices in a graph G, but what is a minimum leaf one?\n    ", "Answer": "\r\nA leaf is a vertex of degree one in a tree. The degree of a vertex is equal to the number of edges that contain the vertex. A minimum leaf spanning tree is a problem that given a graph G = (V, E) and an integer i, is there a spanning tree T in G that contains at most i leaves?\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Representing a minimum spanning tree using an adjacency list\r\n                \r\nI have been attempting to solve a problem for class. The problem is:\n\n\n  Given an undirected graph G, find the minimum spanning tree within G.\n\n\nIn order to pass this question my function must take in, and return, an adjacency list. However, I'm not sure how to go about representing the input and output as an adjacency list.\n\n```\nfrom collections import defaultdict\n\nclass Graph:\n\n    def __init__(self,vertices):\n        self.V= vertices\n        self.graph = []\n\n    def Edge(self,u,v,w):\n        self.graph.append([u,v,w])\n\n    # A utility function to find set of an element i\n    def find(self, parent, i):\n        if parent[i] == i:\n            return i\n        return self.find(parent, parent[i])\n\n    # A function that does union of two sets of x and y\n    def union(self, parent, rank, x, y):\n        xroot = self.find(parent, x)\n        yroot = self.find(parent, y)\n\n        # Attach smaller rank tree under root of high rank tree\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        # If ranks are same, then make one as root and increment rank by one\n        else :\n            parent[yroot] = xroot\n            rank[xroot] += 1\n\n    # The main function to build the MST\n    def Question3(G):\n\n        MST =[] # This will store the MST\n        e = 0 # An index variable used for MST[]\n        i = 0 # An index variable for sorted edges\n        G.graph =  sorted(G.graph,key=lambda item: item[2])\n\n        parent = [] ; rank = []\n\n        # Create V subsets with single elements\n        for node in range(G.V):\n            parent.append(node)\n            rank.append(0)\n\n        # Edges to be taken is equal to V-1\n        while e < G.V -1 :\n\n            # Take smallest edge and increment the index\n            u,v,w =  G.graph[i]\n            i = i + 1\n            x = G.find(parent, u)\n            y = G.find(parent ,v)\n\n            # If including this edge does't cause cycle, include it\n            # in result and increment the index of result for next edge\n            if x != y:\n                e = e + 1\n                MST.append([u,v,w])\n                G.union(parent, rank, x, y)\n            # Else discard the edge\n        print \"Minimum Spanning Tree\"\n        for u,v,weight  in MST:\n            print (\"%d -- %d == %d\" % (u,v,weight))\n\ng = Graph(4)\ng.Edge(0, 1, 9)\ng.Edge(0, 2, 6)\ng.Edge(0, 3, 5)\ng.Edge(1, 3, 12)\ng.Edge(2, 3, 4)\ng.Question3()\nprint \"\"\"---End Question 3---\n\"\"\"\n```\n\n    ", "Answer": "\r\nLet's say that you compute the minimum spanning tree as the list of edges called MST. Now, MST contains triples ```\n(u, v, weight)```\n. What you can do is to iterate over edges in MST and for each such edge ```\n(u, v, weight)```\n append a tuple ```\n(v, weight)```\n to the adjacency list of ```\nu```\n, and also append a tuple ```\n(u, weight)```\n to the adjacency list of ```\nv```\n.  In pseudo-code it may look like that:\n\n```\nadj = {} # your resulting adjacency lists, one for each vertex in the graph\nfor u, v, weight in MST:\n   if u not in adj:\n      adj[u] = []\n   adj[u].append((v, weight))\n   if v not in adj:\n      adj[v] = []\n   adj[v].append((u, weight))\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Representing a minimum spanning tree using an adjacency list\r\n                \r\nI have been attempting to solve a problem for class. The problem is:\n\n\n  Given an undirected graph G, find the minimum spanning tree within G.\n\n\nIn order to pass this question my function must take in, and return, an adjacency list. However, I'm not sure how to go about representing the input and output as an adjacency list.\n\n```\nfrom collections import defaultdict\n\nclass Graph:\n\n    def __init__(self,vertices):\n        self.V= vertices\n        self.graph = []\n\n    def Edge(self,u,v,w):\n        self.graph.append([u,v,w])\n\n    # A utility function to find set of an element i\n    def find(self, parent, i):\n        if parent[i] == i:\n            return i\n        return self.find(parent, parent[i])\n\n    # A function that does union of two sets of x and y\n    def union(self, parent, rank, x, y):\n        xroot = self.find(parent, x)\n        yroot = self.find(parent, y)\n\n        # Attach smaller rank tree under root of high rank tree\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        # If ranks are same, then make one as root and increment rank by one\n        else :\n            parent[yroot] = xroot\n            rank[xroot] += 1\n\n    # The main function to build the MST\n    def Question3(G):\n\n        MST =[] # This will store the MST\n        e = 0 # An index variable used for MST[]\n        i = 0 # An index variable for sorted edges\n        G.graph =  sorted(G.graph,key=lambda item: item[2])\n\n        parent = [] ; rank = []\n\n        # Create V subsets with single elements\n        for node in range(G.V):\n            parent.append(node)\n            rank.append(0)\n\n        # Edges to be taken is equal to V-1\n        while e < G.V -1 :\n\n            # Take smallest edge and increment the index\n            u,v,w =  G.graph[i]\n            i = i + 1\n            x = G.find(parent, u)\n            y = G.find(parent ,v)\n\n            # If including this edge does't cause cycle, include it\n            # in result and increment the index of result for next edge\n            if x != y:\n                e = e + 1\n                MST.append([u,v,w])\n                G.union(parent, rank, x, y)\n            # Else discard the edge\n        print \"Minimum Spanning Tree\"\n        for u,v,weight  in MST:\n            print (\"%d -- %d == %d\" % (u,v,weight))\n\ng = Graph(4)\ng.Edge(0, 1, 9)\ng.Edge(0, 2, 6)\ng.Edge(0, 3, 5)\ng.Edge(1, 3, 12)\ng.Edge(2, 3, 4)\ng.Question3()\nprint \"\"\"---End Question 3---\n\"\"\"\n```\n\n    ", "Answer": "\r\nLet's say that you compute the minimum spanning tree as the list of edges called MST. Now, MST contains triples ```\n(u, v, weight)```\n. What you can do is to iterate over edges in MST and for each such edge ```\n(u, v, weight)```\n append a tuple ```\n(v, weight)```\n to the adjacency list of ```\nu```\n, and also append a tuple ```\n(u, weight)```\n to the adjacency list of ```\nv```\n.  In pseudo-code it may look like that:\n\n```\nadj = {} # your resulting adjacency lists, one for each vertex in the graph\nfor u, v, weight in MST:\n   if u not in adj:\n      adj[u] = []\n   adj[u].append((v, weight))\n   if v not in adj:\n      adj[v] = []\n   adj[v].append((u, weight))\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to compute a minimum bottleneck spanning tree in linear time?\r\n                \r\nWe can find a minimum bottleneck spanning tree in O(E log*V) in the worst case by using Kruskal's algorithm. This is because every minimum spanning tree is a minimum bottleneck spanning tree. \n\nBut I got stuck on this job-interview question from this course.\n\n\n  How can we find a minimum bottleneck spanning tree in linear time even in the worst case. Note that we can assume that we can compute the median of n keys in linear time in the worst case.\n\n    ", "Answer": "\r\nThe standard algorithm for finding Minimum Bottleneck Spanning Tree (MBST) is known as Camerini’s algorithm. It runs in linear time and is as follows:\n\n```\n 1. Find a median edge weight in graph and partition all edges in to two\n    partitions A and B around it. Let A have all edges greater than\n    pivot and B has all edges less than or equal to pivot.                \n 2. Run DFS or BFS on partition B. If it connected graph then again run\n    step 1 on it.        \n 3. If partition B wasn't a connected graph then we must have more than\n    1 connected components in it. Create a new graph by contracting each\n    of these connected components as a single vertex and select edges\n    from partition A that connects these components. MBST is given by\n    edges in connected components + MBST of new graph.\n```\n\n\nIn pseudo-code:\n\n```\n1:  procedure MBST(V, E)\n2:      if |E| = 1 then\n3:          Return E \n4:      else\n5:          A, B ←  Partition E in two halves around median\n6:                  A is higher half, B is lower half\n7:          F ← Connected components of B\n8:          if |F| = 1 and spans all vertices then\n9:              Return MBST(V, B)\n10:         else\n11:             V' ← create one vertex for each connected component in F\n12:                     plus vertices missing from F\n13:             B' ← Edges from A that connects components in F\n14:                     and edges to vertices not in F\n15:             Return F ∪ MBST(V', B') \n16:         end if\n17:     end if\n18: end procedure\n```\n\n\nImplementation notes:\n\n\nMedian can be found in O(n).\nLine 7 can generate disjoint-set data structure using BFS or DFS.\nLine 13 involves filtering out edges in A where each edge has endpoints that are either in two different connected components in F or one endpoint is vertex not in F and other is in F or both are not in F. This tests can be done using efficient disjoint-set data structure in O(1) amortized time for each edge.\n\n\nUpdate: I've now also created Wikipedia page on this topic.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Datasets for clustering minimum spanning tree\r\n                \r\nI have came across the idea of Minimum Spanning Tree recently and found out that it has an application in clustering. I'm looking for a real-world dataset (preferably clean) that can be used as data source for various clustering algorithms. There's an information that MST clustering works good enough on spherical and non-spherical data. This is why non-spherical datasets are sought after as well.\n\nDatasets that I have in mind should contain ground truth info (labels) so the effectiveness of various algos can be measured by something different than WSS.\n    ", "Answer": "\r\nMinimum spanning tree clustering is standard and well studied.\n\nIt's just called differently.\n\nSingle-link hierarchical clustering is exactly the minimum spanning tree, and the fast SLINK algorithm is closely related to Prim's.\n\nThe weaknesses are also well understood. And you can use almost any data set. For example the common Iris data set.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Prim's and Boruvka's algorithm for minimum spanning tree\r\n                \r\nI have to find the minimum spanning tree in a undirected graph, I want to parallelize the code. I read that Boruvka's algorithm is easier to parallelize than Kruskal's or Prim's algorithm. Nevertheless, fast parallel algorithms can be obtained by combining Prim's algorithm with Borůvka's.\nI don't understand how to combine Prim's algorithm with Boruvka's, could somebody help me? \nThank you \n    ", "Answer": "\r\nIf you follow wikipedia's link to that claim, you can get to the paper describing it - http://www-static.cc.gatech.edu/~bader/papers/MST-JPDC.pdf\n\nSection 4 described their process, they seem to basically run Prim in parallel from different starting vertices, \"compact\" each subtree into super-vertices, and rerun recursively until these can no longer be connected. \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Duplicate Edge in Prim's Minimum Spanning tree\r\n                \r\nI've created a generic data structures and algorithm library written in C.\nI've tried to implement Minimum Spanning tree using the Prim's Algorithm\nWhen I run the code for a bi directional graph, I see that the reverse edge also gets added as part of the MST() creating a duplicate edge and increasing the overall MST tree cost.\nThe Code implementation is as given below,\ngraph.h\n```\n/*! @file graph.h\n    @brief \n    Contains declations of graph types, operations and structure\n*/\n#pragma once\n#include \"common.h\"\n#include \"link_list.h\"\n\n/// graph Vertex\ntypedef struct gnode {\n    t_gen id;           ///< Pointer to store Data\n    int idx;            ///< Index of vertex in adaceny list\n    t_linklist *neigh;      ///< Link List to neighbor vertices(nodes)\n} t_gnode;\n\n/// graph neighbor edges represented in neigh list\ntypedef struct gedge {\n    t_gnode *node;          ///< Pointer to neighbor vertex\n    int weight;         ///< Cost of the edge\n} t_gedge;\n\n// fn ptr for adding weighted edge\ntypedef t_gen (*f_wedge)(t_gen, t_gen, t_gen, int); \n\n/// graph struct defn\ntypedef struct graph {\n    // graph info params\n    char *name;         ///< Graph Instance Name\n    int count;          ///< Vertex Count of graph\n    int max_size;           ///< Max Vertex count of graph\n    int total_edges;        ///< Edge count of graph\n\n    // graph nodes\n    t_gnode *nodes;         ///< Adaceny List Representation of graph vertices\n\n    // graph routines\n    f_gen2 add_vertex;      ///< routine to add a vertex in graph\n    f_gen2 del_vertex;      ///< routine to del a vertex in graph\n    f_gen3 add_edge;        ///< routine to add an edge in graph\n    f_gen3 del_edge;        ///< routine to del an edge in graph\n    f_gen3 add_edge_sym;        ///< routine to add a symmetric edge in graph\n    f_gen3 del_edge_sym;        ///< routine to del a symmetric edge in graph\n    f_wedge add_wedge;      ///< routine to add a weighted edge in graph\n    f_wedge add_wedge_sym;      ///< routine to add a weighted symmetric \n    f_find find;            ///< routine to find a vertex in graph\n    f_len len;          ///< routine to get vertex count in graph\n    \n} t_graph;\n\n\n/// Dist info\ntypedef struct dist_info {\n    t_gedge edge;           ///< Pointer to edge\n    t_gnode *parent;        ///< Pointer to Vertex vertex\n} t_distinfo;\n\n```\n\ngraph.c\n```\n\n/*! @brief  \n *  Find the Minimum Spanning for weighted undirected graph\n *  Using Prim's Algorithm\n *  @see https://en.wikipedia.org/wiki/Prim%27s_algorithm\n *  @param d     - Pointer instance of graph\n *  @return      - Pointer to dist array to all nodes in graph\n */\nt_gen prims_mst(t_gen d)\n{\n    t_graph *g = (t_graph*)d;\n    t_gedge *v, *u;\n    t_llnode *cur, *end;\n    t_linklist *neigh_list;\n    t_distinfo *dist, *tmp;\n    t_heap *h;\n    t_dparams dp;\n    t_gen *pq;\n\n    // Data specific operation for generic min heap\n    init_data_params(&dp, eUSER);\n    dp.free     = dummy_free;\n    dp.cmpr     = graph_wedge_cmpr; \n    dp.cmpr_idx = graph_wedge_cmpr_idx;\n    dp.swap_idx = gen_swp_idx;\n    dp.copy_idx = gen_cpy_idx;\n    dp.get_idx  = gen_get_idx;\n\n    // Creating a generic min heap to store edges\n    pq   = get_mem(g->count, sizeof(t_gen));    \n    h    = create_heap(\"Dijkstra's Heap\", pq, g->count, eMIN_HEAP, &dp);\n    \n    // Initalize all dist to all nodes as infinite \n    dist = get_mem(g->count, sizeof(t_distinfo));   \n    for (int i = 0; i < g->count; i++) {\n        dist[i].edge.node   = &g->nodes[i];\n        dist[i].edge.weight = INT_MAX; \n        dist[i].parent      = NULL;\n    }\n    \n    \n    // Set 0 as start vertex\n    h->insert(h, &dist[0].edge);\n    while (h->empty(h) != true) {\n        // Of the edges that connect the tree to vertices not yet in the tree,\n        // Find the minimum-weight edge, and transfer it to the tree\n        u = h->extract(h);\n\n        neigh_list = (t_linklist*)u->node->neigh;\n        cur = neigh_list->head_node(neigh_list);\n        end = neigh_list->end_node(neigh_list);\n        while (cur) {\n            v = (t_gedge*)cur->data;\n            \n            // If cur edge weight is greater than new edge\n            // and the end vertex is not visited\n            if (dist[v->node->idx].edge.weight > v->weight) {\n                // Set new edge as part of MST, update parent\n                // and add edge to heap\n                dist[v->node->idx].edge.weight = v->weight;\n                dist[v->node->idx].parent = u->node;\n                h->insert(h, &dist[v->node->idx].edge);\n            }\n            \n            // Exit after neigh list traversal complete\n            cur = neigh_list->next_node(neigh_list, cur);\n            if (cur == end) {\n                break;\n            }\n        }\n    }\n    \n    // Destroy heap and destroy the array used for storing heap\n    h->destroy(h);\n    free_mem(pq);\n\n    return dist;\n}\n\n```\n\nCan somebody help me figure out how to remove the reverse(duplicate) edge from the MST.\nHeap implementationhere.\nComplete Graph implementation here.\nLink  list implementation that forms the adjacency list here.\nLink to Github repo here\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "best way to find Minimum spanning tree cost [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 2 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI have n points on coordinate plane forming a complete graph weight of an edge is abs(x1-x2)+ abs(y1-y2). I have to find the cost of minimum spanning tree I have done it using Prim's algorithm with time complexity O(n^2) is there a better way to do this.\n    ", "Answer": "\r\nI have an idea that will require a proof but I am fairly confident about it.\nFirst off, let's assume the 2D points can be indexed by an R-Tree in O(n log n) and you can search for a nearest-neighbour in O(log n) in average.\nThen (I am fairly certain) it can be shown that each point on the plane will in the resulting minimum spanning tree only be connected to one or more of its 60° sector-nearest neighbours. There exist only 6 of these neighbours which can be found in O(log n) for each point (by adapting the R-Tree search a little). You will thus end up with a reduced graph of 6n edges on which you can run Prim's algorithm in O(6n).\nOk, so what are the 60° sector-nearest neighbours? - If you divide the space around a point in 6 sectors each with 60° (like a pizza with 6 slices) and search for the nearest neighbour in each sector.\nProof idea: If in the resulting spanning tree a point p would be connected to another point q that is not among its 60° sector-nearest neighbours then the spanning tree could be shortened by connecting q to an adequate 60° sector-nearest neighbour of p.\nTotal runtime would be dominated by building and querying the R-Tree O(n log n).\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to find total number of minimum spanning trees in a graph?\r\n                \r\nI don't want to find all the minimum spanning trees but I want to know how many of them are there, here is the method I considered:\n\n\nFind one minimum spanning tree using prim's or kruskal's  algorithm and then find the weights of all the spanning trees and increment the running counter when it is equal to the weight of minimum spanning tree. \n\n\nI couldn't find any method to find the weights of all the spanning trees and also the number of spanning trees might be very large, so this method might not be suitable for the problem.\nAs the number of minimum spanning trees is exponential, counting them up wont be a good idea.\n\n\nAll the weights will be positive.\nWe may also assume that no weight will appear more than three times in the graph.\nThe number of vertices will be less than or equal to 40,000.\nThe number of edges will be less than or equal to 100,000.\n\n\nThere is only one minimum spanning tree in the graph where the weights of vertices are different. I think the best way of finding the number of minimum spanning tree must be something using this property.  \n\nEDIT: \n\nI found a solution to this problem, but I am not sure, why it works. Can anyone please explain it.\n\nSolution: The problem of finding the length of a minimal spanning tree is fairly well-known; two simplest algorithms for finding a minimum spanning tree are Prim's algorithm and Kruskal's algorithm. Of these two, Kruskal's algorithm processes edges in increasing order of their weights. There is an important key point of Kruskal's algorithm to consider, though: when considering a list of edges sorted by weight, edges can be greedily added into the spanning tree (as long as they do not connect two vertices that are already connected in some way).\n\nNow consider a partially-formed spanning tree using Kruskal's algorithm. We have inserted some number of edges with lengths less than N, and now have to choose several edges of length N. The algorithm states that we must insert these edges, if possible, before any edges with length greater than N. However, we can insert these edges in any order that we want. Also note that, no matter which edges we insert, it does not change the connectivity of the graph at all. (Let us consider two possible graphs, one with an edge from vertex A to vertex B and one without. The second graph must have A and B as part of the same connected component; otherwise the edge from A to B would have been inserted at one point.)\n\nThese two facts together imply that our answer will be the product of the number of ways, using Kruskal's algorithm, to insert the edges of length K (for each possible value of K). Since there are at most three edges of any length, the different cases can be brute-forced, and the connected components can be determined after each step as they would be normally.\n    ", "Answer": "\r\nLooking at Prim's algorithm, it says to repeatedly add the edge with the lowest weight. What happens if there is more than one edge with the lowest weight that can be added? Possibly choosing one may yield a different tree than when choosing another.\n\nIf you use prim's algorithm, and run it for every edge as a starting edge, and also exercise all ties you encounter. Then you'll have a Forest containing all minimum spanning trees Prim's algorithm is able to find. I don't know if that equals the forest containing all possible minimum spanning trees.\n\nThis does still come down to finding all minimum spanning trees, but I can see no simple way to determine whether a different choice would yield the same tree or not.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Euclidean Minimum Spanning Tree Without Triangulation\r\n                \r\nI was looking through some text about finding the EMST (Euclidean MST) using Delaunay triangulation technique, but also read somewhere that the EMST can be found through a sweep line algorithm. Since this would easier implementing, I would like to implement this rather than using a existing library.\nCan anyone guide me/ direct me to a link to a (possibly free) paper/source that has this algorithm explained? \n    ", "Answer": "\r\nFrom this and going by the abstracts, this and this should get you started. They both use sweepline algorithms to obtain MST's\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to find the minimum spanning tree by cycle finding?\r\n                \r\nBy searching the web I can find 2(kruskal and prims) algorithm for finding minimum spanning tree. But this algorithm\n\n```\n   *let T be initially the set of all edges\n       *while there is some cycle C in T\n         remove edge e from T where e has the heaviest weight in C \n```\n\n\nI can't find by searching the web. How do I implement this algorithm. How can I find every possible cycle?\n    ", "Answer": "\r\nSort the edges by decreasing order, then try to delete an edge each time. Check whether the graph is connected or not. If the graph is still connected after deleting an edges, it will guarantee that the edge is in a cycle.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum Spanning Tree using Kruskal's Algorithm\r\n                \r\nI'm using kruskal's algorithm to complete the assignment of determining the minimum spanning tree of the following problem:\n\nI have cities, which all have to be connected. I can connect them by building roads between them or by building an airport. When I build an airport in a city, it becomes connected to all other cities which have airports. \n\nMy doubt is in the next requirement:\n\nIn the case of more than one optimal solution, I have to choose the one with fewer airports. How can I guarantee this, in the most efficient way?\n    ", "Answer": "\r\nIn kruskal's algorithm, we sort and select the edges in non-decreasing order of their weights. \n\nLet us say we use a data-structure(something like tuple) to store edges as ```\n<source vertex,destination vertex, weight of edge between them>```\n. We sort and choose edges in non-decreasing order of their weights. \n\nNow in case of more than one optimal solution you favour the one with fewer airports. So add one more field(say of type ```\nboolean```\n) in you data-structure to store if destination vertex(city) has an airport. This should look something like ```\n<source vertex,destination vertex, weight of edge between them, has_destination_an_airport>```\n. ```\nhas_destination_an_airport```\n is ```\ntrue```\n if destination vertex(city) has an airport, else ```\nfalse```\n.\n\nNow when we sort the edges in non-decreasing order of their weights, if the weights are same, then prefer the one which does not have an airport,i.e. ```\nhas_destination_an_airport```\n is ```\nfalse```\n, if possible.\n\nTo sum up, proper implementation of ```\ncomparator```\n to sort the edges will do the magic.\n\nAs far as asymptotic time and space complexity is concerned, it is the same as that of Kruskal's algorithm. Only overhead is that of extra field to remember if the destination vertex has an airport, which is trivial.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "minimum spanning tree out of adjacency matrix\r\n                \r\nI have a problem that I am really struggling with.  I have a set of points with weighed edges and I need to create a minimum spanning tree to find the shortest amount of edges needed.  I need to do it in java.  Right now I have it creating an adjacency matrix and thats the point im stuck.  I really have no idea where to go next.  Any help would be awesome.\n    ", "Answer": "\r\nTake a look on Kruskal and Prim algorithms,\nI really like Prim because it is very simple to implement and understand: http://en.wikipedia.org/wiki/Prim%27s_algorithm\n\nAbout your question, what do next (Resumed Prim's algorithm):\n Choose one random vertex and get the edge with smaller cost, insert it into your MST.\n While you do not have all vertex at your MST:\n   Choose the edge with smaller cost frm the edges of your MST and insert it at your MST.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Algorithm for minimum diameter spanning tree\r\n                \r\nGiven a undirected and connected graph G, find a spanning tree whose diameter is the minimum.\n    ", "Answer": "\r\nsinghsumit linked the relevant paper by Hassin and Tamir, entitled \"On the minimum diameter spanning tree problem\", but his answer is currently deleted. The main idea from the paper is that finding a minimum diameter spanning tree in an undirected graph can be accomplished by finding the \"absolute 1-center\" of the graph and returning a shortest path tree rooted there.\n\nThe absolute 1-center is the point, either on a vertex or an edge, from which the distance to the furthest vertex is minimum. This can be found via an algorithm of Kariv and Hakimi (An Algorithmic Approach to Network Location Problems. I: the p-Centers) or an earlier algorithm of Hakimi, Schmeichel, and Pierce (On p-Centers in Networks), which I will attempt to reconstruct from just the running time and decades of hindsight. (Stupid pay walls.)\n\nUse Floyd--Warshall or Johnson's algorithm to compute all-pairs distances. For each edge u--v, find the best candidate for a 1-center on that edge as follows.\n\nLet the points on the edge u--v be indexed by µ ranging from 0 (u itself) to len(u--v) (v itself). The distance from the point at index µ to a vertex w is\n\n\n  min(µ + d(u, w), len(u--v) - µ + d(v, w)).\n\n\nAs a function of µ, this quantity is increasing and then decreasing, with the maximum at\n\n\n  µ = (len(u--v) + d(v, w) - d(u, w))/2.\n\n\nSort the vertices by this argmax. For each partition of the array into a left subarray and a right subarray, compute the interval [a, b] of µ that induce the same argmax partition. Intersect this interval to [0, len(u--v)]; if the intersection is empty, then move on. Otherwise, find the maximum distance L in the left subarray from the point on u--v indexed by a, and the maximum distance R in the right subarray from the point on u--v indexed by b. (The cost of computing these maximums can be amortized to O(1) for each partition, by scanning left-to-right and right-to-left at the beginning.) The best choice is the µ in [a, b] that minimizes max(L - (µ - a), R + (b - µ)).\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum spanning trees of sub-graphs?\r\n                \r\nAny hint please if I should prove or search for counterexample, at least to know which direction to go...\nConsider the following 2 graphs:\n```\nG1 (V, E1)\nG2 (V, E2)\n```\n\nand a weight function for the vertices ```\nw: (E1 \\untion E2) -> R```\n\nand 2 minimum spanning trees ```\nT1, T2```\n of ```\nG1```\n and ```\nG1```\n.\nWe define a new graph: ```\nG(V, E1 \\untion E2)```\n\nIs it true to say that there is always a minimum spanning tree ```\nT```\n in the new graph ```\nG```\n (using same ```\nw```\n function) such that all edges of T are from ```\nT1```\n or ```\nT2```\n?\n\nThe claim is wrong in case for every T it has an edge e which isn't included in T1 or T2, Now in G1 we can remove this edge (e) and the problem is solved for T1. But I can't remove edge e from G2 too, which means I must take it and the claim is right, am I wrong?\nNote: no need for detailed answer, only looking to know what is correct and giving it myself a deep prove and thinking.\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Proving that no minimum spanning tree contains the maximum weighted edge\r\n                \r\nLet's say there's Graph G such that it all its edges have weights that correspond to distinct integers. So no two edge has the same weight.\nLet E be all the edges of G. Let emax be an edge in E with the maximum weight.\nAnother property of  Graph G is that every edge e belongs to some cycle in G.\n\nI have to prove that no minimum spanning tree of G contains the edge emax.\n\nI can see why this is true, since all edges are distinct and every edge belongs to a cycle, the minimum spanning tree algorithm can simply choose the edge with lower weight in the cycle that contains emax.\nBut I'm not sure how to concretely prove it.\n    ", "Answer": "\r\nThis is related to the Cycle Property of the Minimum Spanning Tree, which is basically saying that given a cycle in a graph the edge with the greatest weight does not belong in the MST (easily proven by contradiction in the link above). Thus since the edge ```\nemax```\n belongs to a cycle it must not be in the MST.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "boost minimum spanning tree, how to do depth first?\r\n                \r\nI would like to construct a minimum spanning tree using the kruskal_minimum_spanning_tree algorithm available in the boost graph library.\n\nThe output of the \n\n```\nkruskal_minimum_spanning_tree(g, std::back_inserter(spanning_tree));```\n\n\nfrom the BGL example is a simple list of edges. However, I would like to process the tree with a depth first algorithm and do not know how to do that.\n\nCould someone give me a hint on this?\n    ", "Answer": "\r\nUpdate:\nsehe gives an updated and more efficient solution here:\nhttps://stackoverflow.com/a/49429372/85371\n\nHere is a solution to the problem and good example of Kruskal and writing a custom DFS visitors. It should run as is. Example output in shown in the code below as to be self contained. As I mentioned in the comment the output of the MST algorithm is a set of edges. This shows you how to construct a new graph using that data.\n\nExample take from http://en.wikipedia.org/wiki/Kruskals_algorithm.\n\nAny suggestions for improvement would be appreciated. Thanks.\n\n```\n/**\n\nKruskal example from http://en.wikipedia.org/wiki/Kruskal's_algorithm\n\nMST followed by DFS\n\nWritten by Paul W. Bible\n\n*/\n#include <iostream>\n#include <vector>\n\n#include <boost/graph/adjacency_list.hpp>\n#include <boost/graph/graph_traits.hpp>\n#include <boost/graph/depth_first_search.hpp>\n#include <boost/graph/kruskal_min_spanning_tree.hpp>\n\nusing namespace std;\nusing namespace boost;\n\ntypedef adjacency_list < vecS, vecS, undirectedS,\n                    property< vertex_index_t, size_t> ,\n                    property< edge_index_t, size_t, property<edge_weight_t,double> > > Graph;\n\ntypedef graph_traits<Graph>::vertex_descriptor Vertex;\ntypedef graph_traits<Graph>::edge_descriptor Edge;\n\ntypedef boost::property_map< Graph, boost::vertex_index_t>::type VertexIndexMap;\ntypedef boost::property_map< Graph, boost::edge_weight_t>::type WeightMap;\n\n\n//DFS visitor, got help from http://stackoverflow.com/questions/14126/how-to-create-a-c-boost-undirected-graph-and-traverse-it-in-depth-first-search\n// and http://www.boost.org/doc/libs/1_55_0/libs/graph/example/dfs-example.cpp\nstruct MyVis:default_dfs_visitor{\n    //Default dfs is templeted to work with any Edge or Graph class\n    // you will need to pass external graph info to the class\n    MyVis(vector<string> vNames):vertNames(vNames){}\n\n    template < typename Edge, typename Graph >\n    void tree_edge(Edge e, const Graph& g) const {\n        //This works since all graph verts will have an index\n        VertexIndexMap vMap = get(boost::vertex_index,g);\n        //print output message, source and target get the edge vertices\n        cout << \"Edge \" << vertNames.at(vMap[source(e,g)]) <<  \" \" << vertNames.at(vMap[target(e,g)]) << endl;\n        //cout << vertNames.size() << endl;\n    }\n\nprivate:\n    vector<string> vertNames;\n};\n\n\n\nint main(int argc, char* argv[]){\n\n    Graph G;\n\n    vector<Vertex> verts;\n    vector<Edge> edges;\n\n    /* Vertices\n    0   A\n    1   B\n    2   C\n    3   D\n    4   E\n    5   F\n    6   G\n    */\n\n    //add 7 vertices\n    for(size_t i = 0; i < 7; ++i){\n        Vertex v = add_vertex(G);\n        verts.push_back(v);\n    }\n\n    //vertex to index map, typdef above\n    VertexIndexMap vertexIndexMap = get(boost::vertex_index, G);\n\n    vector<string> vertexNames(num_vertices(G));\n    // Create the external property map, this map wraps the storage vector vertexNames\n    boost::iterator_property_map< std::vector< string >::iterator, VertexIndexMap >\n        vertexNameMap(vertexNames.begin(), vertexIndexMap);\n\n    //set names\n    vertexNames.at(0) = \"A\";\n    vertexNames.at(1) = \"B\";\n    vertexNames.at(2) = \"C\";\n    vertexNames.at(3) = \"D\";\n    vertexNames.at(4) = \"E\";\n    vertexNames.at(5) = \"F\";\n    vertexNames.at(6) = \"G\";\n\n\n    //get internal weight map\n    WeightMap weightMap = get(edge_weight,G);\n\n    //Edge 1 A -> B, weight 7\n    pair<Edge,bool> myPair = add_edge(verts.at(0),verts.at(1),G);\n    edges.push_back(myPair.first);\n\n    weightMap[myPair.first] = 7.0;\n    //Edge 2 A -> D, weight 5\n    myPair = add_edge(verts.at(0),verts.at(3),G);\n    edges.push_back(myPair.first);\n    weightMap[myPair.first] = 5.0;\n\n\n    //Edge 3 B -> C, weight 8\n    myPair = add_edge(verts.at(1),verts.at(2),G);\n    edges.push_back(myPair.first);\n    weightMap[myPair.first] = 8.0;\n    //Edge 4 B -> D, weight 9\n    myPair = add_edge(verts.at(1),verts.at(3),G);\n    edges.push_back(myPair.first);\n    weightMap[myPair.first] = 9.0;\n    //Edge 5 B -> E, weight 7\n    myPair = add_edge(verts.at(1),verts.at(4),G);\n    edges.push_back(myPair.first);\n    weightMap[myPair.first] = 7.0;\n\n    //Edge 6 C -> E, weight 5\n    myPair = add_edge(verts.at(2),verts.at(4),G);\n    edges.push_back(myPair.first);\n    weightMap[myPair.first] = 5.0;\n\n    //Edge 7 D -> E, weight 15\n    myPair = add_edge(verts.at(3),verts.at(4),G);\n    edges.push_back(myPair.first);\n    weightMap[myPair.first] = 15.0;\n    //Edge 8 D -> F, weight 6\n    myPair = add_edge(verts.at(3),verts.at(5),G);\n    edges.push_back(myPair.first);\n    weightMap[myPair.first] = 6.0;\n\n    //Edge 9 E -> F, weight 8\n    myPair = add_edge(verts.at(4),verts.at(5),G);\n    edges.push_back(myPair.first);\n    weightMap[myPair.first] = 8.0;\n    //Edge 10 E -> G, weight 9\n    myPair = add_edge(verts.at(4),verts.at(6),G);\n    edges.push_back(myPair.first);\n    weightMap[myPair.first] = 9.0;\n\n    //Edge 11 F -> G, weight 11\n    myPair = add_edge(verts.at(5),verts.at(6),G);\n    edges.push_back(myPair.first);\n    weightMap[myPair.first] = 11.0;\n\n\n    //output\n    cout << \"vertices \" << num_vertices(G) << endl;\n    cout << \"edges    \" << num_edges(G) << endl;\n\n    //create a stoage vector for MST edges\n    vector<Edge> spanning_tree_edges;\n    kruskal_minimum_spanning_tree(G, std::back_inserter(spanning_tree_edges));\n\n    cout << \"num MST edges \" << spanning_tree_edges.size() << endl;\n\n\n    //create a graph for the MST\n    Graph MST;\n\n    //get a weight map for the MST, may be used later\n    WeightMap mstWeightMap = get(edge_weight,MST);\n\n    //create a list of original names for the MST graph.\n    vector<string> mstNames(num_vertices(G)); //the MST must span all verts in G\n    //Index map for verts in MST, all graphs use an indepenent index system.\n    VertexIndexMap mstIndexMap = get(boost::vertex_index, MST);\n\n    cout << \"MST Edges\" << endl;\n    for(size_t i = 0; i < spanning_tree_edges.size(); ++i){\n        //get the edge\n        Edge e = spanning_tree_edges.at(i);\n        //get the vertices\n        Vertex v1 = source(e,G);\n        Vertex v2 = target(e,G);\n\n        // output edge information\n        cout << \"edge weight \" << weightMap[e] << \" v1 \" << vertexNameMap[v1] << \" v2 \" << vertexNameMap[v2] << endl;\n\n        //insert the edge to the MST graph\n        // Both graphs will share the vertices in verts list.\n        myPair = add_edge(v1,v2,MST);\n\n        //set the correct weights\n        // may be needed at some point\n        Edge mstE = myPair.first;\n        mstWeightMap[mstE] = weightMap[e];\n\n\n        //get the vertex index in the MST and set the name to that of original graph\n        // mstNames will be used by the visitor\n        mstNames.at(mstIndexMap[v1]) = vertexNameMap[v1];\n        mstNames.at(mstIndexMap[v2]) = vertexNameMap[v2];\n\n\n    }\n\n    //Create your custom visitor and pass names to the visitor\n    MyVis vis(mstNames);\n\n    cout << \"DFS on MST: start node E\" << endl;\n    //call dfs, see visitor implimentation above.\n    boost::depth_first_search(MST, visitor(vis).root_vertex(verts.at(4)));\n\n    cout << \"DFS on MST: start node B\" << endl;\n    //call dfs, see visitor implimentation above.\n    boost::depth_first_search(MST, visitor(vis).root_vertex(verts.at(1)));\n\n    /* output\n    vertices 7\n    edges    11\n    num MST edges 6\n    MST Edges\n    edge weight 5 v1 A v2 D\n    edge weight 5 v1 C v2 E\n    edge weight 6 v1 D v2 F\n    edge weight 7 v1 B v2 E\n    edge weight 7 v1 A v2 B\n    edge weight 9 v1 E v2 G\n    DFS on MST: start node E\n    Edge E C\n    Edge E B\n    Edge B A\n    Edge A D\n    Edge D F\n    Edge E G\n    DFS on MST: start node B\n    Edge B E\n    Edge E C\n    Edge E G\n    Edge B A\n    Edge A D\n    Edge D F\n\n    */\n\n    //hold for output\n    cin.get();\n}\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "constructing a minimum spanning tree using java's TreeMap\r\n                \r\nI'm working on a project that requires me to keep track of a number of points on a 2d plane. I need to add functionality that allows for certain points to detect the proximity of other points. I immediately thought of the closest pair problem and thought that maybe I should construct a minimum spanning tree.\n\nThe first issue is, these points constantly update their coordinates and I was wondering if it would even be plausible to do this.\n\nThe other issue is, I can't use 3rd party libraries for this so no jgraph or jung. I was wondering if there is a way to construct a minimum spanning using just the libraries I've been given. Can TreeMap be used or would I have to do this from scratch?\n    ", "Answer": "\r\nIt sounds like you are trying to do Nearest Neighbor queries.  That is where you try to find a point (or points) closest to another point. For a naive solution, you can just store a list of points and iterate through them using the distance formula to figure out which ones are closest.  But if you want to do queries more quickly, you will want to use a spatial data structure that enables these kinds of queries.  I would suggest a KD Tree.  Java does not come with a KD Tree implementation in its standard library so you'll need to implement that yourself.\n\nA TreeMap is just an implementation of the ```\nMap```\n interface that lets you put and retrieve values by their keys.  If you want to write something to generate a minimum spanning tree, you'll need to do that yourself.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Algorithm for minimum diameter spanning tree\r\n                \r\nGiven a undirected and connected graph G, find a spanning tree whose diameter is the minimum.\n    ", "Answer": "\r\nsinghsumit linked the relevant paper by Hassin and Tamir, entitled \"On the minimum diameter spanning tree problem\", but his answer is currently deleted. The main idea from the paper is that finding a minimum diameter spanning tree in an undirected graph can be accomplished by finding the \"absolute 1-center\" of the graph and returning a shortest path tree rooted there.\n\nThe absolute 1-center is the point, either on a vertex or an edge, from which the distance to the furthest vertex is minimum. This can be found via an algorithm of Kariv and Hakimi (An Algorithmic Approach to Network Location Problems. I: the p-Centers) or an earlier algorithm of Hakimi, Schmeichel, and Pierce (On p-Centers in Networks), which I will attempt to reconstruct from just the running time and decades of hindsight. (Stupid pay walls.)\n\nUse Floyd--Warshall or Johnson's algorithm to compute all-pairs distances. For each edge u--v, find the best candidate for a 1-center on that edge as follows.\n\nLet the points on the edge u--v be indexed by µ ranging from 0 (u itself) to len(u--v) (v itself). The distance from the point at index µ to a vertex w is\n\n\n  min(µ + d(u, w), len(u--v) - µ + d(v, w)).\n\n\nAs a function of µ, this quantity is increasing and then decreasing, with the maximum at\n\n\n  µ = (len(u--v) + d(v, w) - d(u, w))/2.\n\n\nSort the vertices by this argmax. For each partition of the array into a left subarray and a right subarray, compute the interval [a, b] of µ that induce the same argmax partition. Intersect this interval to [0, len(u--v)]; if the intersection is empty, then move on. Otherwise, find the maximum distance L in the left subarray from the point on u--v indexed by a, and the maximum distance R in the right subarray from the point on u--v indexed by b. (The cost of computing these maximums can be amortized to O(1) for each partition, by scanning left-to-right and right-to-left at the beginning.) The best choice is the µ in [a, b] that minimizes max(L - (µ - a), R + (b - µ)).\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "krukshal's algorithm or Prims Algorithm which one is better in finding minimum spanning tree? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 12 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n\n  Possible Duplicate:\n  Kruskal vs Prim  \n\n\n\n\nkrukshal's algorithm or Prims Algorithm which one is better in finding minimum spanning tree?\n    ", "Answer": "\r\nI'll add one point in favour of Prim's algorithm I haven't seen mentioned. If you are given N points and a distance function d(x,y) for the distance between x and y, it is easy to implement Prim's algorithm using space O(N) (but time N^2). \n\nStart off with an arbitrary point A and create an array of size N-1 giving you the distances from A to all other points. Pick the point, B, associated with the shortest distance, link A and B in the spanning tree and then update the distances in the array to be the minimum of the distance already noted down to that other point and the distance from B ot that other point, noting down where the shortest link is from B and where from A. Carry on.\n\nI don't know a similar way of handling Kruskal's algorithm for a dense graph specified by a distance function, and for large N you can run out of space O(N^2) before you run out of patience for time O(N^2).\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How can I find a Minimum spanning tree containing a given edge?\r\n                \r\nIn a weighted undirected graph I need to find a minimum spanning tree containing a given edge 'e', if it's possible. How can I do it? Kruskal starting from 'e' ?\n    ", "Answer": "\r\nI would not use Kruskal algorithm because if the edge e is part of cycle and e has maximum weight in that cycle, then the algorithm will not include 'e'. I believe with modification it could work. But with Prim's algorithm modification required is minimal.\n\nPrim's algorithm is best suited for this problem, if we recall Prim algorithm goes like this:\n\nSTEP 1: Begin with set S containing a vertex picked randomly.\n\nSTEP 2: From all the edges with one vertex in set S and other vertex in set V - S,pick the one with minimum weight. Let it be (x,y), x belongs to S and y belongs to V - S.\n\nSTEP 3: Add y to set S.\n\nSTEP 4: Repeat step 2 and 3 till S contains all vertices.\n\nModification required:\n\nFor your problem just change step 1 to:\n\nSTEP 1: Begin with set S containing a vertex u and v where edge 'e' = (u,v).\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Improving Implementation of Finding a Minimum Spanning Tree\r\n                \r\nI am trying to implement Kruskal's algorithm to find a minimum spanning tree in Python to solve a question on an online judge, but I am running into time limit problems. The question gives a series of edges in increasing order and asks if a minimum spanning tree is possible. Full problem specifications can be seen here. \n\nHere is my code for the problem:\n\n```\nimport sys\nraw_input = sys.stdin.readline\nline = map(int, raw_input().split())\nn = line[0]\nm = line[1]\ndict1 = {}\nlists = []\n\nfor i in xrange(1, n + 1):\n    dict1[i] = set([i])\n\nfor i in xrange(m):\n    edge = map(int, raw_input().split())\n    a = edge[0]\n    b = edge[1]\n    if dict1[a] != dict1[b]:\n        newSet = dict1[a].union(dict1[b])\n        for vertice in newSet:\n            dict1[num] = newSet\n        lists.append(i + 1)\n\ncheck = all(dict1[x] == dict1[1] for x in dict1.keys())\n\nif check:\n    for i in lists:\n        print i\nelse:\n    print \"Disconnected Graph\"\n```\n\n\nThe code first creates disjoint sets for all possible vertices. Then for each edge, it checks if the sets where each of the two vertices lie are different. If they are, then the two sets are combined with a union operation. Each vertex in the combined set is a member of the newly created combined set. If the vertices are already connected, then they are skipped. I think the problem with my code is the number of times the sets have to be updated in the lines: \n\n```\nfor vertice in newSet:\n    dict1[num] = newSet\n```\n\n\nIs there a faster way to update the sets to check if they are equal? This operation is taking approximately O(vertices^2) time, and it takes too long when there are up to 100,000 vertices.\n    ", "Answer": "\r\nThe key is to use the appropriate data structure for your sets.  Merging sets of nodes and testing to see if any two nodes are in the same set is a classic computer science problem called \"union-find\".\n\nThe best data structure for this is easy and is described here:\n\nhttp://www.algorithmist.com/index.php/Union_Find\n\nUsing this structure, you can merge sets and test for equality in pretty much constant time, which makes your implementation of Kruskal's algorithm (where you're provided with a pre-sorted list of edges) pretty much linear.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Modified Minimum Spanning Tree\r\n                \r\nI have to implement an algorithm where we have an existing road network (nodes connected by path ie., undirected graph). We have to connect all the cities together, and normally I would use something like Kruskal's algorithm to get a minimum spanning tree.\nHowever, we do not care how long it takes to go between cities (can assume the edge weights are all 0 or 1 or something), rather there is a cost associated with building a road (adding an edge between 2 vertices) or destroying a road (deleting an edge between 2 vertices). This is the only cost we have to consider. Our goal is to ONLY have 1 path connecting each pair of cities. All costs are non-negative integers.\nI have 3x 2d arrays (I have represented them as a matrix below, with the row and columns being the cities numbered from 0,1,2...,etc.)\nCountry[i][j]=1 or 0: there is an existing road between city i and j if and only if country[i][j]=1.\n```\n  0 1 2\n0 0 1 1\n1 1 0 1\n2 1 1 0\n```\n\nBuild[i][j]: the cost for building a road between i and j\n```\n  0 1 2\n0 0 1 3\n1 1 0 2\n2 3 2 1\n```\n\nDestroy[i][j]: the cost for destroying a road between i and j.\n```\n  0 1 2\n0 0 1 3\n1 1 0 2\n2 3 2 1\n```\n\nI'm not sure how to go about this, any sort of guidance would be appreciated\n    ", "Answer": "\r\nYou can solve it with two observations:\n\nIt's kind of obvious that the optimal solution is a tree and if an edge is destroyed, then that edge was part of the initial graph. So in an optimal solution, let's add the destroyed edges one by one.\nLet's say we are adding the destroyed edge e1, then a cycle is formed and if there exists an edge e2 that was previously built and belongs to that cycle, then an alternative optimal solution can be created by not destroying the edge e1 and not building the edge e2. If no cycle was formed with that property the edge e1 is skipped and an alternative optimal solution will be tested with the next destroyed edge. This procedure is repeated until every destroyed edge is tested\n\nLet's focus on an initially connected component C, if the problem were only that component C then we can get an optimal solution by running Kruskal to get the heaviest spanning tree, having as weight function the destroying-edge cost matrix. Moreover, we can say that any optimal solution for C belongs to some general optimal solution for the initial graph. Why?, well, after applying step 1, two nodes of C can't be connected with a path that have built edges.\n\n\nSo the algorithm is:\n\nFind the total cost to get the heaviest spanning tree in each connected component\nas was mentioned in step 2.\n\nCreate a new graph by compressing connected components and find the cheapest cost\nof building new edges to connect all these nodes (Hi classic Kruskal!).\n*For implementation you can ommit create that graph, just run classic Kruskal after having created your spanning trees for each connected component.\n\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum Spanning Tree Which Edges are Required/Unnecessary\r\n                \r\nIn a graph, for every edge, how do you determine whether or not it is in all minimum spanning trees, or just some of them, or none of them?\n\nAssume there are < 1000 vertices and < 100000 edges, and we need to classify all edges.\n    ", "Answer": "\r\nWe can do the following to determine whether an edge appears in any of the MSTs or not. Let's say we have an undirected graph, we can determine if an edge appears in all Minimum Spanning Tree (MST). For every edge, do the following: let u and v be the two vertices of edge e. Run a standard DFS from u along edges that are not heavier than e to see whether we can reach v. If we can reach v, then some MST does not contain e. If we cannot reach v, then every MST contains e. This is because an edge appears in all MSTs if and only if the edge is not the heaviest edge in any cycle. \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Adding the lightest possible edges without affecting the graph's minimum spanning tree?\r\n                \r\nWe have a graph G and wish to add edges between every vertex pair, that are as light as possible without affecting the minimum spanning tree.\nGiven the minimum spanning tree and a pair of vertices, how would one compute the weight of the lightest edge that can be added between them without affecting the MST?\n\nThought adding an edge that is heavier than every other edge the two vertices have would work but it appears to be erroneous in trials I've conducted.\n    ", "Answer": "\r\nThe number of edges of a spanning tree is determined by the number of vertices. Hence, if you add an edge to the MST, you need to remove another in order to get a spanning tree. However, you cannot remove any edge. Obviously, removing an edge that is not on the path between the two vertices disconnects the graph. Therefore, you can only remove an edge on this path. If you want to find the minimum spanning tree, you would remove the heaviest edge, of course.\n\nThis new spanning tree is heavier than the original one iff the new edge's weight is greater than the heaviest edge weight on the old path. Therefore, the new edge must be heavier than this edge in order to keep the original MST.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to generate all spanning tree of a graph\r\n                \r\nGiven a connected graph with N nodes and their (x,y) coordinates. I have been able to generate the minimum spanning tree and its cost. I need help on how to generate all the spanning trees and their cost. Below is the implementation of the minimum spanning tree.\n\n```\nimport networkx as nx                 \nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.spatial.distance import pdist, squareform\nimport seaborn as sns\nsns.set()\n\n\nG = nx.Graph()                     \n\n# Initializing an arbitrary unweighted edges of the graph\nlist_unweighted_edges = [(0, 1), (0, 2), (1, 3), (2, 4), (3, 5), (3, 6), (3, 7), (4, 8),\n                         (4, 9), (4, 10), (7, 8), (5, 6), (6, 7), (8, 9), (9, 10)]\n\n# Initializing an arbitrary (x,y) coordinate of each node in the graph\nG.add_node(0, pos=(8.5, 10.5))\nG.add_node(1, pos=(5, 9))\nG.add_node(2, pos=(11.5, 8.5))\nG.add_node(3, pos=(5, 6.5))\nG.add_node(4, pos=(11.5, 5))\nG.add_node(5, pos=(1.5, 3.5))\nG.add_node(6, pos=(4.5, 2.5))\nG.add_node(7, pos=(7, 4.5))\nG.add_node(8, pos=(9, 3.5))\nG.add_node(9, pos=(12.5, 2.5))\nG.add_node(10, pos=(15.5, 4))\n\n# Extracting the (x,y) coordinate of each node to enable the calculation of the Euclidean distances of the graph edges\nposition_array = []\nfor node in sorted(G):\n    position_array.append(G.nodes[node][\"pos\"])\n\nprint(\"Sorted Nodes of the Graph is:\", sorted(G))\nprint(\"Position_Array_Nodes is:\", position_array)\ndistances = squareform(pdist(np.array(position_array)))\nfor u, v in list_unweighted_edges:\n    G.add_edge(u, v, weight=np.round(distances[u][v], decimals=1))\n\n# Building a minimum spanning tree sub-graph, T of the main graph, G\nT = nx.minimum_spanning_tree(G, algorithm='kruskal')\nnode_pos = nx.get_node_attributes(G, 'pos')\nedge_weight = nx.get_edge_attributes(G, 'weight')\nred_edges = T.edges()              # Extracting the minimum spanning tree graph edges\nprint(\"Minimum Spanning Tree Edges is:\", red_edges)\n\n# Extracting the neighbours of each node in the minimum spanning tree, T for the purpose of routing using minimum distance between two nodes\nneigh_list=[]\nfor n in T.nodes:\n    neigh_list.append(list(T.neighbors(n)))\nprint(\"List of Neighbors of Nodes in Minimum Spanning is:\", neigh_list)\nprint(\"Minimum_Spanning_Tree_Nodes:\", T.nodes)\n\n# Calculating the minimum spanning tree cost (distance) of the minimum spanning tree, T\nspan_ed_distance = []\nfor u , v in red_edges:\n    distance_edge = np.round(distances[u][v], decimals=1)\n    span_ed_distance.append(distance_edge)\nprint(\"Edge_Distance_In_Minimum_Spanning_Tree:\", span_ed_distance)\ncost_span_tree = sum(span_ed_distance)\nprint(\"minimum spanning tree cost is:\", cost_span_tree)\n\nnode_col = ['white']\n# If the edge is in the shortest path set it to red, else set it to white color\nedge_col = ['black' if not edge in red_edges else 'red' for edge in G.edges()]\n# Draw the nodes\nnx.draw_networkx(G, node_pos, node_color=node_col, node_size=450)\n# Draw the node labels\nnx.draw_networkx_labels(G, node_pos, node_color=node_col)\n# Draw the edges\nnx.draw_networkx_edges(G, node_pos, edge_color=edge_col)\n# Draw the edge labels\nnx.draw_networkx_edge_labels(G, node_pos, edge_color=edge_col, edge_labels=edge_weight)\n# Show the axis\nplt.axis('on')\n# Show the plot\nplt.show()\n```\n\n\nGiven a connected graph with N nodes and their (x,y) coordinates. I have been able to generate the minimum spanning tree and its cost. I need help on how to generate all the spanning trees and their cost. Below is the implementation of the minimum spanning tree.\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum Spanning tree variation algorithm\r\n                \r\nI was asked the following question in an interview and I am unable to find an efficient solution.\n\nHere is the problem:\n\n\n  We want to build a network and we are given n nodes and m edges. Edges\n  are bidirectional and we know the cost of the edge. All the costs of\n  the edges are hold in an array C, so C[i,j] which denotes the cost of\n  the edge i-j. If nodes i,j are not connected then C[i,j] is infinite.\n  \n  Now we also know that exactly K of the nodes are able to communicate\n  wireless to other nodes which have also this property (for wireless\n  transmission). To set up wireless technology to node i costs B[i]. So\n  node i in order to use the ability of wireless transmission to node j\n  this will costs B[i] to set up the wireless technology to node i and\n  B[j] for j.\n  \n  So the question is to find the minimum cost required to build the\n  network where any two nodes i,j could communicate (there will be a\n  path connecting them).\n  \n  As path we mean that either there are edges that lead from node i to j\n  or we can also use wireless transmission between nodes that support\n  it.\n\n\nIt clear that it is asked for minimum spanning tree but the difficulty is that for example if we use wireless technology for node i,j and k then we add possible edges i-j,i-k,j-k but if we use only in i,j then we have only extra edge i-j so the edges depend on what node we choose to use for wireless transmission.\n\nA simple example:\n\nLet say we have ```\n4 nodes```\n and ```\n3 edges```\n  ```\nC[1,2]=9 , C[1,3]=3 , C[3,4]=5```\n (other ```\nC[i,j] are infinite```\n).                   \n\nNodes 2 and 3 support wireless technology with set up costs B[2]=2 and B[3]=1.\n\nIn this example the minimum cost would be: ```\n16 = 8 (for edge 1-3) + 5 (for edge 3-4) + 2 (for set up cost 2) + 1 (for set up cost in node 3).```\n\n\nIf we didn't use wireless technology in edge 2-3 then to make the network we should include ```\nedge 1-2```\n with cost 9 so total cost would be ```\n9+8+5 = 22.```\n\n\nI am looking for an efficient algorithm for this kind of minimum spanning tree problem. Any help would be appreciated, thank you for your time!!\n    ", "Answer": "\r\nSolve the minimum spanning tree problem first, that gives you an incumbent answer to try beat.\n\nNow, create another graph the same as the original graph, add a new node to this network. Connect all of the K nodes to this new node with edge weight equal to B[i]. This edge represents the cost of adding wireless to node i. Now find the minimum spanning tree of the new graph. Nodes can now connect through this node as \"wifi\".\n\n(I'm assuming that they tell you which K nodes support wifi, and not that you must choose K of the N nodes, otherwise you will have problems if this new minimum spanning tree has more than K connections to the new node)).\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Update minimum spanning tree after a new vertex is added\r\n                \r\nSuppose that a graph G has a minimum spanning tree already computed. How can we quickly update the minimum tree if we add a new vertex and incident edges to G.\n\nMy initial solution is to choose the new added edge who has least weight and then add this edge to the tree already computed. But it seems this solution is wrong. Can someone give me some tips on this question? Thanks\n    ", "Answer": "\r\nAdding the minimum weight edge will give wrong results because now you have extra edges and more than one edge out of them can be a part of the new MST. See the image for example.\n\n\n\nYou can use Prim's algorithm. Just take into account the previous MST edges and the new edges while running the algorithm.\nThis will work because if you run ```\nPrims```\n on the whole new graph then also all the edges that it will add will be from old MST or new edges.  You can use any other ```\nMST```\n finding algorithm as well like ```\nKruskal```\n considering the above said edges.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Multiple Minimum Spanning Trees in a Single Graph\r\n                \r\nI am looking for an algorithm that I am not sure how to define, but the idea is to have multiple disjoint minimum spanning Trees in a single Graph.\n\nConsider this undirected Graph, where all nodes are every node is connected to every other node in the Graph. (Too Lazy to Draw, but imagine 9 vertexes exiting/entering every node)\n\n\n\nA minimum spanning tree for this Graph may appear as follows:\n\n\nI am searching for an algorithm which can be fed with parameters such as: \nMaximum Vertexes pr. Node and Maximum Tree Span.\n\nSo that I for instance I tell the Algorithm: No Node may be directly connected to more than 2 other nodes, and no tree in the graph may consist of more than 3 vertexes (4 nodes) a result like this a solution.\n\n\nIt's eventually going to be written in Python 3.0, but for now I'm just looking for some input as to how I approach this. \n    ", "Answer": "\r\nFirst, please note that this is not a trivial problem.  There are plenty of algorithms out there to find all minimal spanning trees -- but your inclusion of disjoint graphs turns this into more of a partitioning problem.\n\n\nThis will involve dynamic programming to reduce your path explosion.\nStart with partitioning.  For each partition, collect the possible spanning trees.\nThe product of these lists is your solution set for that partition.\nWrite a function to return all spanning trees for a given set of nodes -- memoize the result, so you don't have to regenerate the list of trees every time you change a node number.\n\n\nNow for the partitions.  You're getting into Grundy numbers here: all the possible ways to express a target value as the sum of possible integers.  This is a well-documented DP algorithm, easy to find on Stack Overflow with \"algorithm Python ...\"  For illustration, I'll work with only 4 nodes: ```\nQWER```\n.\nThe possible partitions of 4 items, with at least 2 nodes in each partition, are\n\n```\n4\n2 2\n```\n\n\nA critical question here is whether your nodes are interchangeable -- for instance, are\n\n```\nQW  ER\nQE  WR\nQR  WE\n```\n\n\n... distinct solutions for you?  If so, you now have four partitions to handle; if not, you have only two.\n\nFor each partition, generate all legal spanning trees.  The 2-node solutions are trivial; the 4-node solution includes configurations (using parameter nodes abcd):\n\na-b-c-d  (linear)\n   a-b + c-a-d  (star, with a in the center)\n\nAgain, if your nodes are interchangeable, you have only two solutions.\n\n[(ab, bc, cd), (ab, ac, ad)]\n\nFinally, use ```\nitertools.product```\n to form all combinations of your partition solutions.\n\nDoes that get you moving?\n\n\n\nUpdate per OP's comment\n\nNodes and edges are not interchangeable.  Let's consider, then a 5-node system, QWERT.  This has 10 distinct partitions -- each must be a 3-2 split.\n\nQW ERT    WE QRT\n  QE WRT    WR QET\n  QR WET    WT QER\n  QT WER    ER QWT\n  RT QWE    ET QWR\n\nEach of these will follow the same configuration of solutions.  For illustration, consider the first: QW | ERT.  QW has only one spanner: the list of edges (one) ```\n[(Q,W)]```\n.  ERT has three: ```\n[(E,R), (R,T)], [(E,R), (E,T)], [(E,T), (R,T)]```\n.  Your collection of spanning trees is the ```\nitertools.product```\n of these two lists.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Why is a minimum spanning tree also a minimum bottleneck tree always?\r\n                \r\nI came across this problem in Introduction to algorithms Third Edition exercise.\n\nSo, how I proceeded was trying to contradict the situation when A minimum spanning tree has the largest edge greater than the largest edge of a bottleneck tree by cut and paste argument.\n\nBut it is not necessary that if I remove the largest Edge there exists an edge which connects this disconnected pieces into one!\n\nThen, I tried proving it using Kruksal's Algorithm as basis as the maximum edge limits all other edges to be lesser than or equal to this maximum edge, but couldn't succeed.\n\nAny help?\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "A fast algorithm for minimum spanning trees when edge lengths are constrained?\r\n                \r\nSuppose that you have a directed graph with nonnegative, integer edge lengths that are in the range 0 to U - 1, inclusive.  What is the fastest algorithm for computing a minimum spanning tree of this graph?  We can still use existing minimum spanning tree algorithms, such as Kruskal's algorithm O(m log n)) or Prim's algorithm (O(m + n log n)).  However, for cases where U is small, I think it should be possible to do much better this.\n\nAre there any algorithms that are competitive with more traditional MST algorithms that are able to exploit the fact that the edge lengths are constrained to be in some range?\n\nThanks!\n    ", "Answer": "\r\nFredman–Willard gave an O(m + n) algorithm for integer edge lengths on the unit-cost RAM.\n\nThat's arguably not much of an improvement: without the restriction on edge lengths (i.e., the lengths are an opaque data type that supports only comparisons), Chazelle gave an O(m alpha(m, n) + n) algorithm (alpha is the inverse Ackermann function) and Karger–Klein–Tarjan gave a randomized O(m + n) algorithm.\n\nI don't think Darren's idea leads to a O(m + n + U)-time algorithm. Jarnik (\"Prim\") does not use its priority queue monotonically, so buckets may be scanned multiple times; Kruskal requires a disjoint-set data structure, which cannot be O(m + n).\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum bottleneck spanning tree vs MST\r\n                \r\nA MST(minimum spanning tree) is necessarily a MBST(minimum bottleneck spanning tree).\n\nGiven a set of points in a 2D plane with the edges of the weight of the Euclidean distance between each pair of point, I want to find the minimum bottleneck edge in the spanning tree (the maximum-weighted edge). \n\nAccording to my limited knowledge in this field and research on the internet, the best way to calculate this using the MST approach is to do a Delaunay triangulation of the given points, and use the fact that the MST of these points is a subset of the triangulation and then run Kruskal's or Prim's algorithm. Then all I need to do is to find the maximum weight in the MST.\n\nI am wondering if I can do this more efficiently by building a MBST, as I am only looking for the bottleneck edge.\n\nThanks in advance.\n\nEdit: my current way to find it, both using MST or MBST calculates the weight of all ```\nV * (V-1) / 2```\n edges first, which I consider quite inefficient. I'd like to know if there's an alternative around this.\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Method to split a SciPy minimum spanning tree based on greatest edge weight?\r\n                \r\nIs there a way to split the output of a scipy.sparse.csgraph.minimum_spanning_tree operation by dropping the greatest edge weight value in the tree? I am trying to get access to each of the subtrees that would result by dropping the greatest edge weight if that edge was not an outer edge of the minimum spanning tree.\n\nUsing the SciPy docs example:\n\n```\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import minimum_spanning_tree\nX = csr_matrix([[0, 8, 0, 3],\n                [0, 0, 2, 5],\n                [0, 0, 0, 6],\n                [0, 0, 0, 0]])\nTcsr = minimum_spanning_tree(X)\n# print(Tcsr)\n# (0,3) 3.0\n# (3,1) 5.0\n# (1,2) 2.0\n```\n\n\nWhat is the best way to drop the middle value in the minimum spanning tree above and have access to the other two edges separately? I am trying to do this on large graphs and trying to avoid large Python loops where possible. Thanks.\n    ", "Answer": "\r\nI had the same problem and managed to figure out a solution using only ```\nscipy```\n. All this does is take the MST, locate the maximum weighted edge, delete it (i.e. zero it out), and then use the ```\nconnected_components```\n method to figure out which nodes remain connected.\n\nHere is the complete script with comments:\n\n```\nimport numpy as np\nfrom scipy.sparse.csgraph import minimum_spanning_tree, connected_components\nfrom scipy.sparse import csr_matrix\n\n# Create a random \"distance\" matrix.\n# Select only the upper triangle since the distance matrix array would be symmetrical.\na = np.random.rand(5,5)\na = np.triu(a)\n\n# Create the minimum spanning tree.\nmst = minimum_spanning_tree(csr_matrix(a))\nmst = mst.toarray()\n\n# Get the index of the maximum value.\n# `argmax` returns the index of the _flattened_ array;\n# `unravel_index` converts it back.\nidx = np.unravel_index(mst.argmax(), mst.shape)\n\n# Clear out the maximum value to split the tree.\nmst[idx] = 0\n\n# Label connected components.\nnum_graphs, labels = connected_components(mst, directed=False)\n\n# We should have two trees.\nassert(num_graphs == 2)\n\n# Use indices as node ids and group them according to their graph.\nresults = [[] for i in range(max(labels) + 1)]\nfor idx, label in enumerate(labels):\n    results[label].append(idx)\n\nprint(results)\n```\n\n\nThis will yield something like:\n\n```\n[[0, 1, 4], [2, 3]]\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "unique minimum spanning tree sufficient and necessary conditions\r\n                \r\nGiven a graph G,which are the sufficient and necessary conditions , so that this graph has a unique minimum spanning tree?In addition , how can I proove these conditions?\n\nSo far , I  had found that those conditions are :\n\n1)For every partition of V(G) into two subsets, the minimum weight edge with one endpoint in each subset is unique.\n\n2)The maximum-weight edge in any cycle of G is unique.\n\nBut I am not sure if this is correct.Even in case this is correct,I cannot prove its correctness.\n    ", "Answer": "\r\nActually, there is a necessary and sufficient condition for unique MST. In the book A First Course In Graph Theory, it is given as an exercise:\n\nExercise 4.30\nLet G be a connected weighted graph and T a minimal spanning tree of G. Show that T is a unique minimal spanning tree of G if and only if the weight of each edge e of G that is not in T exceeds the weight of every other edge on the cycle in T+e.\n\nI write my proof here.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Bug in my Minimum Spanning Tree implementation [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                This question is unlikely to help any future visitors; it is only relevant to a small geographic area, a specific moment in time,  or an extraordinarily narrow situation that is not generally applicable to the worldwide audience of the internet. For help making  this question more broadly applicable, visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 11 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI'm trying to implement the kruskal's algorithm which finds the minimum spanning tree at a undirected, weighted graph G(V,E). My implementation uses disjoint sets to make the algorithm faster. Here is the code:\n\n```\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing std::sort;\nusing std::vector;\n\nconst int MAXV =  1000;\n\nstruct set_union {\n  set_union *parent;\n  int rank;\n} *array[MAXV];\n\nset_union* make_set() {\n  set_union *ret = new set_union();\n  ret->parent = NULL;\n  ret->rank = 1;\n  return ret;\n}\n\nset_union* find_root(set_union *u) {\n  set_union *temp = u;\n  while(temp->parent != NULL) {\n    temp = temp->parent;\n  }\n  return temp;\n}\n\nvoid union_sets(set_union *&pa, set_union *&pb) {\n  set_union *a = find_root(pa), *b = find_root(pb);\n  if(a->rank > b->rank) {\n    b->parent = a;\n  } else if(a->rank < b->rank) {\n    a->parent = b;\n  } else {\n    a->parent = b;\n    a->rank++;\n  }\n}\n\nbool same_component(set_union *a, set_union *b) {\n  return find_root(a) == find_root(b);\n}\n\nstruct link {\n  int v;\n  int w;\n};\n\nstruct edge {\n  int v,u;\n  int w;\n};\n\nbool operator < (const edge& a, const edge& b) {\n  if(a.w < b.w) { return true; }\n  else { return false; }\n}\n\nstruct graph {\n  vector<vector<link> > adj;\n  vector<edge> edges;\n  int V,E;\n  graph(int v) : adj(v), edges(0), V(v), E(0) {}\n};\n\nvoid insert(graph &g, int a, int b, int c = 1) {\n  g.edges.push_back((edge) {a,b,c});\n  g.adj[a].push_back((link) {b,c});\n  g.adj[b].push_back((link) {a,c});\n}\n\nvoid kruskal(graph g, vector<edge> &tree) {\n  printf(\"Entering kruskal\\n\");\n  tree.clear();\n  for(int i = 0; i < g.V; i++) {\n    array[i] = make_set();\n  }\n\n  printf(\"sorting edges by weight\\n\");\n  sort(g.edges.begin(), g.edges.end());\n  int i;\n\n  printf(\"Entering while\\n\");\n  while(tree.size() < g.V-1 && i < g.E) {\n    if(!same_component(array[g.edges[i].v], array[g.edges[i].u])) { /* Here is the error */\n      tree.push_back(g.edges[i]);\n      union_sets(array[g.edges[i].v], array[g.edges[i].u]);\n     }\n    i++;\n  }\n  printf(\"Exiting kruskal\\n\");\n}\n\n\nint main(void) {\n  int v,e;\n  scanf(\"%d %d\", &v, &e);\n\n  graph g(v);\n\n  for (int i = 0; i < e; ++i) {\n    int a,b,c;\n    scanf(\"%d %d %d\", &a, &b, &c);\n    insert(g,a,b,c);\n  }\n\n  vector<edge> tree;\n  kruskal(g,tree);\n\n  for ( vector<edge >::iterator it = tree.begin(); it < tree.end(); ++it ) {\n    printf(\"%d %d w = %d\\n\", it->v, it->u, it->w);\n  }\n\n  return 0;\n}\n```\n\n\nIt compiles without errors, but it gives me no results. For example when I give it this input:\n\n```\n3 3\n0 1 1\n1 2 1\n2 0 2\n```\n\n\nit doesn't produce any output at all. Can anyone help me? Thanks in advance.\n\nEdit: I have spotted where I think the error is with a comment. As the ```\ntree```\n is empty, I conclude that ```\nif(!same_component(array[g.edges[i].v], array[g.edges[i].u]))```\n is always ```\nfalse```\n. So the mistake must be at the ```\nsame_component```\n function, but I cannot spot it. \n    ", "Answer": "\r\nIn the ```\nkruskal()```\n function, you aren't initialising ```\ni```\n before testing its value with ```\nwhile(tree.size() < g.V-1 && i < g.E)```\n.  It will contain rubbish (whatever was in already memory), which will probably cause the loop not to execute even once.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Boost Graph Library - Minimum Spanning Tree of a Directed Graph\r\n                \r\nI have a problem that requires me to find the minimum spanning tree of a directed graph in Boost Graph Library.\n\nMy first try was to use the depth first search and DFS-visitor. My plan was to ignore all the edges except the tree edges callback. This doesn't work and I give the example below on why.\n\nMy question is if I can make my dfs-visitor create a minimum spanning tree of a directed graph in BGL.\n\nThere are algorithms for it and has been discussed here (Finding a minimum spanning tree on a directed graph) and I can't tell if it's been implemented for BGL or not or it's just a simple modification of something that's already in BGL.\n\n```\n#include <iostream>\n#include <boost/graph/adjacency_list.hpp>\n#include <boost/graph/graphviz.hpp>\n#include <boost/graph/depth_first_search.hpp>\n\n\nstruct my_visitor : public boost::dfs_visitor<>\n{\n    template <class Edge, class Graph>\n    void back_edge(Edge e, const Graph&) \n    {\n        std::cout << \"Back edge: \" << e << std::endl;\n    }\n\n    template <class Edge, class Graph>\n    void forward_or_cross_edge(Edge u, const Graph& g)\n    {\n        std::cout << \"Forward or cross edge: \" << u << std::endl;\n    }\n\n    template <class Edge, class Graph>\n    void tree_edge(Edge u, const Graph& g)\n    {\n        std::cout << \"Tree Edge: \" << u << std::endl;\n    }\n};\n\n\nint main()\n{\n    using namespace boost;\n\n    typedef boost::adjacency_list< listS, vecS, bidirectionalS > digraph;\n\n    // Construct the directed graph\n    digraph g(2);\n\n    add_edge(1, 0, g);\n    //add_edge(0, 1, g);\n\n    my_visitor vis2;\n    boost::depth_first_search(g, visitor(vis2));\n\n    return 0;\n}\n```\n\n\nHere is the example that fails. If I have the following directed graph\n\n```\ndigraph G {\n0;\n1;\n1->0 ;\n}\n```\n\n\nIn depth first search dfs-visitor, 1->0 is classified as a forward edge. \n\nIf the graph was changed so that the edge is 0->1, then it is a tree edge.\n\nFrom the strict definition of the forward edge and the source code of DFS, since vertex 0 is visited before vertex 1, it is a forward edge. \n\nHowever, the edge 1->0 is still a tree edge in a technical sense and from the definition given in their page as http://www.boost.org/doc/libs/1_59_0/libs/graph/doc/graph_theory_review.html.\n\n\n  Forward edges are non-tree edges (u,v) that connect a vertex u to a\n  descendant v in a search tree.\n\n\nSo, is there a simple solution in BGL or do I have to implement one of the algorithms in BGL for it?\n    ", "Answer": "\r\nThe problem you are dealing with is, as you may already know, the search for a spanning arborescence of minimum weight as we are dealing with directed graphs. An arborescence is a graph with a designated root vertex ```\nr```\n such that all other vertices are reachable from ```\nr```\n, i.e. there exists a path from ```\nr```\n to all other vertices in the graph.\n\nUnfortunately there is no algorithm in the Boost Graph Library which solves this problem, so you need to use either a 3rd party implementation like this one or implement one yourself. The implementation (by atofigh on github.com) given above uses Edmond's algorithm, which is a popular algorithm for solving the spanning arborescence problem.\n\nKeep in mind that algorithms like Kruskal's algorithm or Prim's algorithm do not work on directed graphs due to the cut property not working on directed graphs.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Find a minimum spanning tree in different sets\r\n                \r\nHere I have two connected undirected graphs\n ```\nG1 = [V ; E1] and G2 =[V ; E2]```\n on the same set of vertices V . And assume edges in E1 and E2 have different colors. \n\nLet w(e) be the weight of edge ```\ne ∈ E1 ∪ E2```\n.\n\nI want to find a minimum weight spanning tree (MSF) among those spanning trees which have at least one edge in each set E1 and E2. In this condition, How to find a proper algorithm for this? I got stuck here a whole night. \n    ", "Answer": "\r\nConsider two edges e1 &in; E1, e2 &in; E2. They connect between 2 and 4 different vertices in V. If they connect 3 or 4 vertices, suppose you first contract the vertices which e1 connects (same as each step in Kruskal's algorithm), then the ones which e2 connects, and then run any minimum spanning tree algorithm on the resulting graph. Then the result is the MST containing e1 and e2.\n\nIt follows that you can find the total MST by looping over all e1 &in; E1, e2 &in; E2 (which don't connect exactly the same two vertices), and finding the lightest solution. The proof of correctness can be easily modified from that of Kruskal's algorithm.\n\nIn fact, though, you can make this more efficient, since either the lightest edge in E1 or the lightest edge in E2 must be used in some MST. Suppose that the lightest edge in E1, say e'1, is not used, and consider a cut agreeing with e'1. The MST must contain some e ≠ e'1 connecting the cut. Clearly, if e &in; E1, then e'1 can be used instead of e. If e &in; E2, though, and e can't be used, then e is lighter than e'1. In this case, though, repeating the argument for E2, yields that the lightest edge in E2 can be part of the MST.\n\nConsequently, only the lightest edge of E1 along with any edge in E2, or the lightest edge in E2 along with any edge in E1 must be considered for the first two contractions mention above.\n\nThe complexity is Θ(|E1 + E2| f(V, E1 + E2)), where f is the complexity of the MST algorithm. \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum spanning tree containing a given edge after removing edges\r\n                \r\nThis is a part of an exam preparation. I know it has something to do with max-flow algorithm, but I'd be happy for a hint:\n\nLet ```\nG=(V,E)```\n an undirected connected graph, and let ```\nw:E->R```\n a weight function, ```\ne```\n an edge and ```\nk > 0```\n. Describe an algorithm that determines whether we can remove at most ```\nk```\n edges from the graph, so that ```\ne```\n would belong to a minimum spanning tree of the new graph.\n\nI think that a spanning tree is kind of a perfect matching. But how do I make it minimal that contains e and the right amount of other edges?\n    ", "Answer": "\r\nHint: for every edge e, there exists a minimum-weight spanning forest containing e if and only if there exists no path between e's endpoints comprised of edges (strictly) lighter than e.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to build a Minimum Spanning Tree given a list of 200 000 nodes?\r\n                \r\nProblem\nI have a list of approximatly 200000 nodes that represent lat/lon position in a city and I have to compute the Minimum Spanning Tree. I know that I need to use Prim algorithm but first of all I need a connected graph. (We can assume that those nodes are in a Euclidian plan)\nTo build this connected graph I thought firstly to compute the complete graph but (205000*(205000-1)/2 is around 19 billions edges and I can't handle that.\nOptions\nThen I came across to Delaunay triangulation: with the fact that if I build this \"Delauney graph\", it contains a sub graph that is the Minimum Spanning Tree according and I have a total of around 600000 edges according to Wikipedia [..]it has at most 3n-6 edges. So it may be a good starting point for a Minimum Spanning Tree algorithm.\nAnother options is to build an approximately connected graph but with that I will maybe miss important edges that will influence my Minimum Spanning Tree.\nMy question\nIs Delaunay a reliable solution in this case? If so, is there any other reliable solution than delaunay triangulation to this problem ?\nFurther information: this problem has to be solved in C.\n    ", "Answer": "\r\nThe Delaunay triangulation of a point set is always a superset of the EMST of these points. So it is absolutely \"reliable\"*. And recommended, as it has a size linear in the number of points and can be efficiently built.\n*When there are cocircular point quadruples, neither the triangulation nor the EMST are uniquely defined, but this is usually harmless.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Is this minimum spanning tree algorithm correct?\r\n                \r\nThe minimum spanning tree problem is to take a connected weighted graph and find the subset of its edges with the lowest total weight while keeping the graph connected (and as a consequence resulting in an acyclic graph).\n\nThe algorithm I am considering is:\n\n\nFind all cycles.\nremove the largest edge from each cycle.\n\n\nThe impetus for this version is an environment that is restricted to \"rule satisfaction\" without any iterative constructs. It might also be applicable to insanely parallel hardware (i.e. a system where you expect to have several times more degrees of parallelism then cycles).\n\nEdits:\n\nThe above is done in a stateless manner (all edges that are not the largest edge in any cycle are selected/kept/ignored, all others are removed).\n    ", "Answer": "\r\nWhat happens if two cycles overlap?  Which one has its longest edge removed first?  Does it matter if the longest edge of each is shared between the two cycles or not?\n\nFor example:\n\n```\nV = { a, b, c, d }\nE = { (a,b,1), (b,c,2), (c,a,4), (b,d,9), (d,a,3) }\n```\n\n\nThere's an a -> b -> c -> a cycle, and an a -> b -> d -> a\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Boost minimum spanning tree with some edges included/excluded\r\n                \r\nI'm trying to implement the list of all possible spanning trees of a graph in order of increasing cost. I'm using the algorithm by Sorensen and Janssens (2005). The graph is initialized as follows:\n\n```\ntypedef property<edge_weight_t, int> EdgeWeightProperty;\ntypedef adjacency_list<vecS, vecS, undirectedS, no_property, EdgeWeightProperty> Graph;\ntypedef Graph::edge_descriptor Edge;\ntypedef Graph::vertex_descriptor Vertex;\ntypedef boost::graph_traits<Graph>::edge_iterator EdgeIterator;\ntypedef std::pair<EdgeIterator, EdgeIterator> EdgePair;\nGraph g;\n\nadd_edge(1, 2, 3, g);\nadd_edge(1, 3, 1, g);\nadd_edge(1, 4, 2, g);\nadd_edge(2, 3, 3, g);\nadd_edge(2, 4, 1, g);\n```\n\n\nAfter this it's necessary to find the minimum spanning tree of a graph with some limitations, for instance Edge(2)-(4) shouldn't be in MST and Edge(1)-(2) should be there.\n\nFor the edge exclusion it's possible to use remove_edge_if(..) to delete the edge from the graph.\n\n```\ntemplate<typename WMap>\nclass Remover\n{\npublic:\n    Remover(const WMap& weights, int threshold)\n        : m_weights(weights), m_threshold(threshold) {}\n\n    template<typename ED>\n    bool operator()(ED w) const { return m_weights[w] <= m_threshold; }\n\nprivate:\n    const WMap& m_weights;\n    int         m_threshold;\n};\n\n....\n// remove edges of weight < 1\nRemover< property_map<Graph, edge_weight_t>::type> r(get(edge_weight, g), 1);\nremove_edge_if(r, g);\n....\nstd::list < Edge > spanning_treeT;\nkruskal_minimum_spanning_tree(g, std::back_inserter(spanning_treeT));\n```\n\n\nBut how should I ensure that one of the edges is always in the spanning tree? I was trying just to add some Edge into output of the Kruskal function, but it didn't work apparently. It yields MST of the graph + added edge:\n\n```\nstd::list < Edge > spanning_tree_g2;\nVertex u, v;\nEdgePair ep = edges(g2);\nu = source(*ep.first, g2);\nv = target(*ep.first, g2);\nEdge ed = edge(u, v, g2).first;\nspanning_tree_g2.push_front(ed);\nkruskal_minimum_spanning_tree(g2, std::back_inserter(spanning_tree_g2));\n```\n\n\nIs it possible to mark the edges in a way that Kruskal algorithm knows what to include and what not to?\n    ", "Answer": "\r\nI seems you could force the inclusion of a certain edge by splitting this edge and inserting two \"artificial\" vertices in the middle.\n\nThe MST algorithm is already required to produce a tree of edges that covers all vertices.\n\nBecause the artifical vertices have been purposely added by you, it's easy to make sure it's never reachable using any other edges.\n\nBefore:\n\n```\n   ------------------[e:w1+w2]------------------\n```\n\n\nAfter:\n\n```\n   ----[e1:w1]---(v1)---[em:0]---(v2)---[e2:w2]----\n```\n\n\n(where ```\nv1```\n and ```\nv2```\n are the vertices inserted).\n\nAfter the fact you \"collapse\" any sequence of ```\n(e1,em,e2)```\n or ```\n(e2,em,e1)```\n into ```\n(e)```\n.\n\nYou might end up with a tree that reaches v1 and v2 but never traverses ```\nem```\n. In that case you can simply drop one of ```\ne1```\n and ```\ne2```\n and replace it with ```\ne```\n unconditionally.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How does Minimum spanning tree displays the overlapping subproblem property\r\n                \r\n\n  The minimum spanning tree problem has both overlapping sub-problems\n  and optimal substructure.\n\n\nI understood the second part of the statement , because if we consider two subtree's of MST , then the edge having the minimum weight which connects them is also in the MST.\n\nBut I didn't understand how it displays the overlapping - subproblems property , please somebody explain it ? \n    ", "Answer": "\r\nTo look at subproblems - that is, subgraphs - for the MST problem, you have to partition your graph by removing edges.\n\nAlong all the possible ways of taking out edges, you will encounter similar (nay, identical !) problems (i.e. sets of subgraphs), e.g. you get the same graph if you reverse the order in which you remove a couple of edges. Hence, if you explore all the ways to subdivide your problem, you will encounter overlapping subproblems.\n\n(Naturally, I hope we agree this is not the way to go about finding a minimum spanning tree. I'm strictly describing the overlap in subdivisions.)\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Kruskal’s Minimum Spanning Tree Algorithm (C++)\r\n                \r\nI'm working though an assignment on the Stanford CS106B C++ course, but I'm massively stuck implementing Kruskal's algorithm to find a minimum spanning tree.\n\nTo be more specific, I can't figure out the logic to determine whether to add an arc/ vertex to the tree.  These are the instructions I've been given:\n\n\"The strategy you will use is based on tracking connected sets. For each node, maintain the set of the nodes that are connected to it. At\nthe start, each node is connected only to itself. When a new arc is\nadded, you merge the sets of the two endpoints into one larger combined set that both nodes are now connected to. When considering an\narc, if its two endpoints already belong to the same connected set,\nthere is no point in adding that arc and thus you skip it.\"\n\n```\nvoid getMinSpanTree(graphT *&graph)\n{\nMap<Set <nodeT *> > connections;\n\n// Create set of arcs in decreasing order\nSet<arcT *> arcs(costCmp);\nSet<arcT *>::Iterator gItr = graph->arcs.iterator();\nwhile (gItr.hasNext()) {\n    arcT *arc = gItr.next();\n    arcs.add(arc);\n}\n\n// Initialise map with initial node connections\nSet<nodeT *>::Iterator nItr = graph->nodes.iterator();\nwhile (nItr.hasNext()) {\n    nodeT *node = nItr.next();\n    Set<nodeT *> nodes;\n    nodes.add(node);\n    connections.add(node->name, nodes);\n}\n\n// Iterate through arcs\nSet<arcT *>::Iterator aItr = arcs.iterator();\nwhile (aItr.hasNext()) {\n    arcT *arc = aItr.next();\n\n    if (connections[arc->start->name].equals(connections[arc->finish->name])) {\n        Set<nodeT *> nodes = connections[arc->start->name];\n        nodes.unionWith(connections[arc->finish->name]);\n        connections[arc->start->name] = nodes;\n        connections[arc->finish->name] = nodes;\n\n        // Update display with arc\n        coordT start = {arc->start->x, arc->start->y};\n        coordT finish = {arc->finish->x, arc->finish->y};\n        DrawLineBetween(start, finish, HIGHLIGHT_COLOR);\n    }\n}\n}\n```\n\n\nI know the line:\n\n```\nif (connections[arc->start->name].equals(connections[arc->finish->name])) { \n```\n\n\nneeds to be changed.  Does anyone know what it should be? :)\n    ", "Answer": "\r\nOne simple solution would be to iterate over nodes in\n\n```\nconnections[arc->start->name]\n```\n\n\nand see if they match \n\n```\narc->finish->name\n```\n\n\nIf so, arc->start->name and arc->finish->name are connected and there's no point in merging the two sets.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to get Minimum Spanning Tree Matrix in python\r\n                \r\nInitially, i have 2d array. By using this array i have created a graph with weight on its edges. Now i am trying to use this Graph to make Minimum Spanning Tree matrix but i cant make it as desire. I am using the following code to make graph.\n```\n G = nx.from_numpy_matrix(ED_Matrix, create_using=nx.DiGraph)\n layout = nx.spring_layout(G)\n sizes = len(ED_Matrix)\n nx.draw(G, layout, with_labels=True, node_size=sizes)\n labels = nx.get_edge_attributes(G, \"weight\")\n output = nx.draw_networkx_edge_labels(G, pos=layout, edge_labels=labels)\n plt.show()\n```\n\nAnd its gives the output like this\n\nNow i am using MST code, to get the its MST matrix but its gives error like this.\n```\n from scipy.sparse import csr_matrix\n from scipy.sparse.csgraph import minimum_spanning_tree\n Tcsr = minimum_spanning_tree(G)\n Tcsr.toarray().astype(int)\n```\n\n\n    ", "Answer": "\r\nTaking into account example from docs of scipy, it should be constructed from adjacency matrix of G, not from G.\nYou might want to replace ```\nG```\n with ```\nnx.adjacency_matrix(G)```\n or ```\ncsr_matrix(nx.adjacency_matrix(G))```\n or ```\nED_Matrix```\n itself in calculation (assignment) of ```\nTcsr```\n:\n```\nTcsr = minimum_spanning_tree(nx.adjacency_matrix(G)) #or\nTcsr = minimum_spanning_tree(csr_matrix(nx.adjacency_matrix(G))) #or\nTcsr = minimum_spanning_tree(ED_Matrix)\n```\n\n```\nTcsr```\n is a sparse matrix which is later converted to ```\nnumpy```\n array.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Clustering From Minimum Spanning tree java\r\n                \r\ni have to compare words according to their cosine similarity and produce k clusters from them with the similarity in terms of meaning. Basically i have a words like below:\n\n```\n[directors, producers, film, movie, black, white, man, woman, person, man, young, woman, science, fiction, thrilling, realistic, lovely, stunning, criminals, zombies, father, son, girlfriend, boyfriend, nurse, soldier, professor, college]\n```\n\n\nI have calculated their cosine similarity with each other in a complete weighted graph in which the cosine similarity is the edge weight and found the MST of this graph like below:\n\n```\nson criminals 7.622005318852533E-5\ndirectors film 0.00269683524940825\ncollege thrilling 0.004318332211016577\nlovely girlfriend 0.011496356899859533\nproducers science 0.011946913151506599\nnurse person 0.01222182619788835\nfiction criminals 0.019032592497457333\nfilm producers 0.021182908439749612\ncollege fiction 0.02777607695416014\nwoman criminals 0.028081533433767823\nrealistic producers 0.028614429314768274\nfiction film 0.031228743740582716\nwoman stunning 0.034664134514120794\ncollege zombies 0.04113726420938837\ncriminals black 0.0442203277881683\nprofessor science 0.04546819590424154\nzombies soldier 0.04787773897201146\nboyfriend stunning 0.04931897200102598\nwhite producers 0.04969833492364299\nnurse girlfriend 0.0498423837867863\nthrilling nurse 0.05126380652206475\nmovie science 0.05220609189928112\nnurse man 0.05229834114709604\nmovie young 0.07777548636454826\nfather nurse 0.13334569901132612\n```\n\n\nI need to get result similar to that(lets say for 2 clusters):\n\n```\nboyfriend,college,father,girlfriend,man,nurse,person,professor,son,woman,young\n\ncriminals,directors,fiction,film,lovely,movie,producers,science,stunning,thrilling,zombies\n```\n\n\nIn my assigment it says that, \"Once you have a weighted graph, you can find the\nminimum spanning tree and cut k-1 edges that have the minimum weights on the graph to obtain\nk clusters.\"\nThe problem is that i am kind of confused and stucked what to do now? How should i obtain the resulting 2 clusters for instance that contains similar words in each cluster?  Any idea or hint is appreciated.Thanks in advance.\n    ", "Answer": "\r\nWith cosine, make sure to not mix up signs.\n\nIf you use cosine similarity, you'll need the maximum spanning tree instead (highest similarities). With cosine distance, the minimum is fine. You probably have this wrong right now.\n\nOne way to extract partitions out of a minimum spanning tree is to remove the longest edges (largest distance, remove the smallest similarities on a maximum spanning tree).\n\nBut there are many more to be found in clustering. This approach is essentially Single-Link hierarchical clustering. The MST can be visualized as a dendrogram, and there are probably a dozen ways to 'cut' this dendrogram into clusters.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Algorithm to find minimum spanning tree for graph with edge weights in {1,2,3} [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        A fast algorithm for minimum spanning trees when edge lengths are constrained?\r\n                            \r\n                                (2 answers)\r\n                            \r\n                    \r\n                Closed 7 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI have recently been doing some research into Prims/Kruskals algorithms for finding minimum spanning trees in graphs, and I am interested in the following problem:\n\nLet G be an undirected graph on n vertices with m edges, such that each edge has a weight w(e) ∈ {1, 2, 3}. Is there an algorithm which finds a minimum spanning tree of G in time O(n+m)?\n\nObviously, you could just run Prims on the graph, and you would get a minimum spanning tree, but not in the required time.\n\nI was thinking that we could start by adding every edge with weight 1 to the tree, provided it creates no cycles, as if there is an edge of weight 1 that creates no cycles, then it is preferable to an edge of weight 2 say, and do this in increasing order.\n\nAny help on possible ways to design an algorithm to do this would be appreciated and any implementations (java preferable but any language welcome) would be super helpful.\n    ", "Answer": "\r\nYou're describing a minor variation of Kruskal's algorithm that makes the cost of sorting by weight O(m) for m edges because you only need to put the edges in 3 buckets.  \n\nSince the rest of Kruskal's is very nearly O(m) due to the amazing properties of the disjoint set data structure, you should be in good shape. \n\nBuilding the tree itself ought to be O(m) rather than O(n + m) as was your goal because there's no need to process the vertices.  E.g. if you have a few edges on a gazillion vertices, most with no connection, the latter don't need to increase algorithm cost if you're careful about data structure design.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Intersections in Kruskal's Minimum spanning tree\r\n                \r\nI find that some edges of Minimum Spanning Tree (MST) overlap using the union find method detailed here, with modifications - using ```\nfloat```\n instead of ```\ninteger```\n weights, using ```\ninteger```\n values instead of ```\nstring```\n IDs. The grey lines in image below are the MST edges and green / blue edges are shape boundaries.\n\nThe edge cost is the euclidean distance between the nodes.\n\nExample showing vertex IDs. Edge weight is added below:\n\nInstead of node 87 -> 138 (weight = 17.7) and 55 -> 134 (weight = 9.49), should it not be 55 -> 138 and 87 -> 134? Is the implementation wrong or can this happen with the algorithm itself?\n\nPlease ignore the numbers in brackets besides the vertex numbers (they are the combined weight of edges which connect to each node).\n\nSame example, zoomed out to show other edge weights (removed vertex numbers to remove clutter):\n\n\nP.S. I found that the distance between 55 -> 138 and 87 -> 134 are exactly the same (12.20656).\n    ", "Answer": "\r\nAnswering my own question, based on the questions asked by AakashM.\n\nSpecifically, this happened because the edge cost between 55 -> 138 and 87 -> 134 are exactly the same. This happened in my case since I'm generating a shape using an image, hence the distance between points is quantized.\n\nInspired by this, I added very small random weights (less than the least distance distance between pixels) to the edges which (edit: has not) solved the issue!\n\nSo, the algorithm remains good for euclidean MST, and my specific implementation contains a caveat.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Graph change - in order to have only one minimum spanning tree\r\n                \r\nI am a computer science student, during my studies I was exposed to this question:\n\nI am given a graph that has a number of minimal spanning trees. I need to change the edge weights linearly - in order to have only one spanning tree. This tree should be minimal - even in the original graph.\n\nI tried to go over all the edges- and make sure there was no edge - with the same weight.\n\nBut this solution did not work properly for me - when there is a graph that is circular - deleting a certain edge - or changing the weight of a certain edge would not give the minimum spanning tree that was at first.\n\nThanks for the help.\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Finding a New Minimum Spanning Tree After a New Edge Was Added to The Graph\r\n                \r\nLet G = (V, E) be a weighted, connected and undirected graph and let T be a minimum spanning tree. Let e be any edge not in E (and has a weight W(e)).\nProve or disprove:\nT U {e} is an edge set that contains a minimum spanning tree of G' = (V, E U {e}).\n\nWell, it sounds true to me, so I decided to prove it but I just get stuck every time...\n\nFor example, if e is the new edge with minimum weight, who can promise us that the edges in T weren't chosen in a bad way that would prevent us from obtaining a new minimum weight without the 'help' of other edges in E - T ? \n\nI would appreciate any help,\nThanks in advance.\n    ", "Answer": "\r\nLet [a(1), a(2), ..., a(n-1)] be a sequence of edges selected from E to construct MST of G by Kruskal's algorithm (in the order they were selected - weight(a(i)) <= weight(a(i + 1))).\n\nLet's now consider how Kruskal's Algorithm behaves being given as input E' = E U {e}.\nLet i = min{i: weight(e) < weight(a(i))}. Firstly algorithm decides to choose edges [a(1), ..., a(i - 1)] (e hasn't been processed yet, so it behaves the same). Then it need to decide on e - if e is dropped, solution for E' will be the same as for E. So let's suppose that first i edges selected by algorithm are [a(1), ..., a(i - 1), e] - I will call this new sequence a'. Algorithm continues - as long as its following selections (for j > i) satisfy a'(j) = a(j - 1) we are cool. There are two scenarios that break such great streak (let's say streak breaks at index k + 1):\n\n1) Algorithm selects some edge e' that is not in T, and weight(e') < weight(a(k+1)). By now a' sequence is:\n\n[a(1), ..., a(i-1), e, a(i), a(i+1), ..., a(k-1), a(k), e']\n\nBut if it was possible to append e' to this list it would be also possible to append it to [a(1),  ..., a(k-1), a(k)]. But Kruskal's algorithm didn't do it when looking for MST for G. That leads to contradiction.\n\n2) Algorithm politely selected:\n\n[a(1), ..., a(i-1), e, a(i), a(i+1), ..., a(k-1), a(k)]\n\nbut decided to drop edge a(k+1). But if e was not present in the list algorithm would decide to append a(k+1). That means that in graph (V, {a(1), ..., a(k)}) edge a(k+1) would connect the same components as edge e. And that means that after considering by algorithm edge a(k + 1) in case of both G and G' the division into connected components (determined by set of selected edges) is the same. So after processing a(k+1) algorithm will proceed in the same way in both cases.          \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Which Minimum Spanning tree algorithm to use in which situation\r\n                \r\nI am newbie to Minimum spanning trees and trying to figure out which MST algorithm to use in any particular situation. Can anybody provide some examples with any particular situation where one of the MST algorithm is more suitable than others\n    ", "Answer": "\r\nCheck out this pdf\n\nQuick Summery (quoting the page): \n\n\"Boruvka’s and Kruskal’s algorithms are clearly\nmore useful if applied to the real world, while Prim’s runtime grows far too quickly with the order\nof the graph to be of use in a serial processing environment.\"\n\n\"Out of the three algorithms, Boruvka’s holds most promise when parallel computing is considered.\nIt is parallelizable by design and involves searching locally for the smallest edge and then\ncombining the resulting trees after each step. Division of tasks between multiple computer\nprocessing nodes would be the logical extension of Boruvka’s algorithm. However, as can be seen\nfrom this paper, Kruskal’s algorithm is much more efficient in a serial environment.\"\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum spanning tree between a start location and a set of required nodes\r\n                \r\nI'm trying to determine the optimal search case to compare to a search algorithm I have written.  \n\nI have a set of nodes marked \"required\" and a node marked \"start\", the rest are marked \"optional\".  I want to find the optimal number of nodes I would need to expand to discover all of the required nodes given that I my first expand is the \"start\" node.\n\n\nI believe what I am looking for is the minimum spanning tree, but pruned of all branches that do not end in a \"required\" node.  Is this the Steiner tree problem?\nIf my graph is unweighted, is the size of the Steiner tree and the\nMinimum Spanning Tree the same?\nWhat if anything can I say about the size of the tree?  i.e. something like (size of minimum spanning tree size = average shortest path * # required nodes...I don't think this is true, but it would be nice to be able to calculate an average based on connectedness or something).\n\n\nA few notes:  \n\n\nThis is not traveling sales problem because I don't need a path\nto exist between each required node, I just want to discover each\nrequired node.\nMy graph is undirected and unweighted (or equally weighted for that matter)\nMy graph has an average of about 100 required nodes, and possibly thousands of optional nodes\n\n    ", "Answer": "\r\n\n  I have a set of nodes marked \"required\" and a node marked \"start\", the\n  rest are marked \"optional\". I want to find the optimal number of nodes\n  I would need to expand to discover all of the required nodes given\n  that I my first expand is the \"start\" node.\n\n\nIf the cost of expanding a node can be arbitrary, then this is the node-weighted Steiner tree problem, which, under a plausible complexity-theoretic assumption, has no polynomial-time approximation algorithm with a ratio that's o(log n).\n\n\n  I believe what I am looking for is the minimum spanning tree, but\n  pruned of all branches that do not end in a \"required\" node.\n\n\nNo, this is in general not optimal. For example, with the graph\n\n```\n       s\n      /|\\\n     / | \\\n    *  |  *\n   /   |   \\\n  /    |    \\\n r1----*----r2,\n```\n\n\none possible MST looks like ```\n/|\\```\n or ```\n/\\```\n when pruned, but the optimal solution looks like ```\n_|_```\n.\n\n\n  What if anything can I say about the size of the tree?\n\n\nTheoretically speaking, you could get a lower bound by solving the dual of the LP relaxation of the integer program for Steiner tree (actually with a graph of a the size you're thinking about, it wouldn't surprise me if a solver could determine the optimal Steiner tree straight up).\n\nPractically speaking, however, this is not how people evaluate search algorithms.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minumum Spanning Tree\r\n                \r\nI have a homework about graph and minimum spanning tree\n\nSuppose for a given graph G1, we have computed a minimum spanning tree T1. Now ,a new edge to G1 is added.We call this new graph with the added edge G2. Describe an algorithm to compute the minimum spanning tree T2 OF G2 efficiently by jut adjusting T1.\n    ", "Answer": "\r\nTry adding that new edge, say e', to T1, this will form a cycle in T1. Your problem have been reduced to finding the maximum weighted edge in the unique cycle of T1 + e'.\n\nIf you remove the edge that you found by the previous procedure from T1 + e', you will obtain T2.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "could someone help clarify this implementation of a Minimum Spanning Tree?\r\n                \r\nI am currently working on a project for data structures due in a couple days and I do not understand the instructions. We are to make a minimum spanning tree via kruskal's algorithm but also need to implement it using an ArrayBasedList, a heap, up trees, and an adjacency list.\n1. These things are very confusing to me, would the heap and the up trees just be an array-based list with the things entered in a different order? or do they need their own classes?\n2. What is an adjacency list? I have to return a string version of my heap, my adjacency list, and my mst. I am very nervous/confused, any help understanding how to start this is GREATLY appreciated.\n\nthe project is basically to find the minimum spanning tree of lowest cost bridges (edges) between islands (vertexes) so its a weighted graph.\n    ", "Answer": "\r\nYou should first distinguish between the purpose of these data-structures. For example, you would use a ```\nadjacency list```\n to store the graph information. Where would you use a ```\nheap```\n? To process the edges in order. Then find out the different variations you can do with the different data-structures. The data-structures process the information differently so they may have different final time complexities. Once you manage to understand the pieces see how they fit in together and implement the algorithm. \n\nConsult this link for a step-by-step demonstration.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "R Plotting of a non-overlapping minimum spanning tree\r\n                \r\nI have created a minimum spanning tree in which communities have been found using the Louvain method. I would now like to display the tree clearly, i.e., it would be great to have an overlap-free representation.\nOn the left is my current plot and on the right is a very nice example from Wang et al. (2017, JEIC), which is much clearer and mostly non-overlapping.\nI wonder how it can be achieved to represent this tree more clearly, in particular it must be noted that this representation is only an MWE and the actual representation has much more observations.\n\n\nMWE:\n```\nlibrary(igraph)\nlstat <- c(4.98,9.14,4.03,2.94,5.33,5.21,12.43,19.15,29.93,17.1,20.45,13.27,15.71,8.26,10.26,8.47,6.58,14.67,11.69,11.28,21.02,13.83,18.72,19.88,16.3,16.51,14.81,17.28,12.8,11.98,22.6,13.04,27.71,18.35,20.34,9.68,11.41,8.77,10.13,4.32,1.98,4.84,5.81,7.44,9.55,10.21,14.15,18.8,30.81,16.2,13.45,9.43,5.28,8.43,14.8,4.81,5.77,3.95,6.86,9.22,13.15,14.44,6.73,9.5,8.05,4.67,10.24,8.1,13.09,8.79,6.72,9.88,5.52,7.54,6.78,8.94,11.97,10.27,12.34,9.1,5.29,7.22,6.72,7.51,9.62,6.53,12.86,8.44,5.5,5.7,8.81,8.2,8.16,6.21,10.59,6.65,11.34,4.21,3.57,6.19,9.42,7.67,10.63,13.44,12.33,16.47,18.66,14.09,12.27,15.55,13,10.16,16.21,17.09,10.45,15.76,12.04,10.3,15.37,13.61,14.37,14.27,17.93,25.41,17.58,14.81,27.26,17.19,15.39,18.34,12.6,12.26,11.12,15.03,17.31,16.96,16.9,14.59,21.32,18.46,24.16,34.41,26.82,26.42,29.29,27.8,16.65,29.53,28.32,21.45,14.1,13.28,12.12,15.79,15.12,15.02,16.14,4.59,6.43,7.39,5.5,1.73,1.92,3.32,11.64,9.81,3.7,12.14,11.1,11.32,14.43,12.03,14.69,9.04,9.64,5.33,10.11,6.29,6.92,5.04,7.56,9.45,4.82,5.68,13.98,13.15,4.45,6.68,4.56,5.39,5.1,4.69,2.87,5.03,4.38,2.97,4.08,8.61,6.62,4.56,4.45,7.43,3.11,3.81,2.88,10.87,10.97,18.06,14.66,23.09,17.27,23.98,16.03,9.38,29.55,9.47,13.51,9.69,17.92,10.5,9.71,21.46,9.93,7.6,4.14,4.63,3.13,6.36,3.92,3.76,11.65,5.25,2.47,3.95,8.05,10.88,9.54,4.73,6.36,7.37,11.38,12.4,11.22,5.19,12.5,18.46,9.16,10.15,9.52,6.56,5.9,3.59,3.53,3.54,6.57,9.25,3.11,5.12,7.79,6.9,9.59,7.26,5.91,11.25,8.1,10.45,14.79,7.44,3.16,13.65,13,6.59,7.73,6.58,3.53,2.98,6.05,4.16,7.19,4.85,3.76,4.59,3.01,3.16,7.85,8.23,12.93,7.14,7.6,9.51,3.33,3.56,4.7,8.58,10.4,6.27,7.39,15.84,4.97,4.74,6.07,9.5,8.67,4.86,6.93,8.93,6.47,7.53,4.54,9.97,12.64,5.98,11.72,7.9,9.28,11.5,18.33,15.94,10.36,12.73,7.2,6.87,7.7,11.74,6.12,5.08,6.15,12.79,9.97,7.34,9.09,12.43,7.83,5.68,6.75,8.01,9.8,10.56,8.51,9.74,9.29,5.49,8.65,7.18,4.61,10.53,12.67,6.36,5.99,5.89,5.98,5.49,7.79,4.5,8.05,5.57,17.6,13.27,11.48,12.67,7.79,14.19,10.19,14.64,5.29,7.12,14,13.33,3.26,3.73,2.96,9.53,8.88,34.77,37.97,13.44,23.24,21.24,23.69,21.78,17.21,21.08,23.6,24.56,30.63,30.81,28.28,31.99,30.62,20.85,17.11,18.76,25.68,15.17,16.35,17.12,19.37,19.92,30.59,29.97,26.77,20.32,20.31,19.77,27.38,22.98,23.34,12.13,26.4,19.78,10.11,21.22,34.37,20.08,36.98,29.05,25.79,26.64,20.62,22.74,15.02,15.7,14.1,23.29,17.16,24.39,15.69,14.52,21.52,24.08,17.64,19.69,12.03,16.22,15.17,23.27,18.05,26.45,34.02,22.88,22.11,19.52,16.59,18.85,23.79,23.98,17.79,16.44,18.13,19.31,17.44,17.73,17.27,16.74,18.71,18.13,19.01,16.94,16.23,14.7,16.42,14.65,13.99,10.29,13.22,14.13,17.15,21.32,18.13,14.76,16.29,12.87,14.36,11.66,18.14,24.1,18.68,24.91,18.03,13.11,10.74,7.74,7.01,10.42,13.34,10.58,14.98,11.45,18.06,23.97,29.68,18.07,13.35,12.01,13.59,17.6,21.14,14.1,12.92,15.1)\nrm <- c(6.575,6.421,7.185,6.998,7.147,6.43,6.012,6.172,5.631,6.004,6.377,6.009,5.889,5.949,6.096,5.834,5.935,5.99,5.456,5.727,5.57,5.965,6.142,5.813,5.924,5.599,5.813,6.047,6.495,6.674,5.713,6.072,5.95,5.701,6.096,5.933,5.841,5.85,5.966,6.595,7.024,6.77,6.169,6.211,6.069,5.682,5.786,6.03,5.399,5.602,5.963,6.115,6.511,5.998,5.888,7.249,6.383,6.816,6.145,5.927,5.741,5.966,6.456,6.762,7.104,6.29,5.787,5.878,5.594,5.885,6.417,5.961,6.065,6.245,6.273,6.286,6.279,6.14,6.232,5.874,6.727,6.619,6.302,6.167,6.389,6.63,6.015,6.121,7.007,7.079,6.417,6.405,6.442,6.211,6.249,6.625,6.163,8.069,7.82,7.416,6.727,6.781,6.405,6.137,6.167,5.851,5.836,6.127,6.474,6.229,6.195,6.715,5.913,6.092,6.254,5.928,6.176,6.021,5.872,5.731,5.87,6.004,5.961,5.856,5.879,5.986,5.613,5.693,6.431,5.637,6.458,6.326,6.372,5.822,5.757,6.335,5.942,6.454,5.857,6.151,6.174,5.019,5.403,5.468,4.903,6.13,5.628,4.926,5.186,5.597,6.122,5.404,5.012,5.709,6.129,6.152,5.272,6.943,6.066,6.51,6.25,7.489,7.802,8.375,5.854,6.101,7.929,5.877,6.319,6.402,5.875,5.88,5.572,6.416,5.859,6.546,6.02,6.315,6.86,6.98,7.765,6.144,7.155,6.563,5.604,6.153,7.831,6.782,6.556,7.185,6.951,6.739,7.178,6.8,6.604,7.875,7.287,7.107,7.274,6.975,7.135,6.162,7.61,7.853,8.034,5.891,6.326,5.783,6.064,5.344,5.96,5.404,5.807,6.375,5.412,6.182,5.888,6.642,5.951,6.373,6.951,6.164,6.879,6.618,8.266,8.725,8.04,7.163,7.686,6.552,5.981,7.412,8.337,8.247,6.726,6.086,6.631,7.358,6.481,6.606,6.897,6.095,6.358,6.393,5.593,5.605,6.108,6.226,6.433,6.718,6.487,6.438,6.957,8.259,6.108,5.876,7.454,8.704,7.333,6.842,7.203,7.52,8.398,7.327,7.206,5.56,7.014,8.297,7.47,5.92,5.856,6.24,6.538,7.691,6.758,6.854,7.267,6.826,6.482,6.812,7.82,6.968,7.645,7.923,7.088,6.453,6.23,6.209,6.315,6.565,6.861,7.148,6.63,6.127,6.009,6.678,6.549,5.79,6.345,7.041,6.871,6.59,6.495,6.982,7.236,6.616,7.42,6.849,6.635,5.972,4.973,6.122,6.023,6.266,6.567,5.705,5.914,5.782,6.382,6.113,6.426,6.376,6.041,5.708,6.415,6.431,6.312,6.083,5.868,6.333,6.144,5.706,6.031,6.316,6.31,6.037,5.869,5.895,6.059,5.985,5.968,7.241,6.54,6.696,6.874,6.014,5.898,6.516,6.635,6.939,6.49,6.579,5.884,6.728,5.663,5.936,6.212,6.395,6.127,6.112,6.398,6.251,5.362,5.803,8.78,3.561,4.963,3.863,4.97,6.683,7.016,6.216,5.875,4.906,4.138,7.313,6.649,6.794,6.38,6.223,6.968,6.545,5.536,5.52,4.368,5.277,4.652,5,4.88,5.39,5.713,6.051,5.036,6.193,5.887,6.471,6.405,5.747,5.453,5.852,5.987,6.343,6.404,5.349,5.531,5.683,4.138,5.608,5.617,6.852,5.757,6.657,4.628,5.155,4.519,6.434,6.782,5.304,5.957,6.824,6.411,6.006,5.648,6.103,5.565,5.896,5.837,6.202,6.193,6.38,6.348,6.833,6.425,6.436,6.208,6.629,6.461,6.152,5.935,5.627,5.818,6.406,6.219,6.485,5.854,6.459,6.341,6.251,6.185,6.417,6.749,6.655,6.297,7.393,6.728,6.525,5.976,5.936,6.301,6.081,6.701,6.376,6.317,6.513,6.209,5.759,5.952,6.003,5.926,5.713,6.167,6.229,6.437,6.98,5.427,6.162,6.484,5.304,6.185,6.229,6.242,6.75,7.061,5.762,5.871,6.312,6.114,5.905,5.454,5.414,5.093,5.983,5.983,5.707,5.926,5.67,5.39,5.794,6.019,5.569)\ndis <- c(4.09,4.9671,4.9671,6.0622,6.0622,6.0622,5.5605,5.9505,6.0821,6.5921,6.3467,6.2267,5.4509,4.7075,4.4619,4.4986,4.4986,4.2579,3.7965,3.7965,3.7979,4.0123,3.9769,4.0952,4.3996,4.4546,4.682,4.4534,4.4547,4.239,4.233,4.175,3.99,3.7872,3.7598,3.3603,3.3779,3.9342,3.8473,5.4011,5.4011,5.7209,5.7209,5.7209,5.7209,5.1004,5.1004,5.6894,5.87,6.0877,6.8147,6.8147,6.8147,6.8147,7.3197,8.6966,9.1876,8.3248,7.8148,6.932,7.2254,6.8185,7.2255,7.9809,9.2229,6.6115,6.6115,6.498,6.498,6.498,5.2873,5.2873,5.2873,5.2873,4.2515,4.5026,4.0522,4.0905,5.0141,4.5026,5.4007,5.4007,5.4007,5.4007,4.7794,4.4377,4.4272,3.7476,3.4217,3.4145,3.0923,3.0921,3.6659,3.6659,3.615,3.4952,3.4952,3.4952,3.4952,3.4952,2.7778,2.8561,2.7147,2.7147,2.421,2.1069,2.211,2.1224,2.4329,2.5451,2.7778,2.6775,2.3534,2.548,2.2565,2.4631,2.7301,2.7474,2.4775,2.7592,2.2577,2.1974,2.0869,1.9444,2.0063,1.9929,1.7572,1.7883,1.8125,1.9799,2.1185,2.271,2.3274,2.4699,2.346,2.1107,1.9669,1.8498,1.6686,1.6687,1.6119,1.4394,1.3216,1.4118,1.3459,1.4191,1.5166,1.4608,1.5296,1.5257,1.618,1.5916,1.6102,1.6232,1.7494,1.7455,1.7364,1.8773,1.7573,1.7659,1.7984,1.9709,2.0407,2.162,2.422,2.2834,2.0459,2.4259,2.1,2.2625,2.4259,2.3887,2.5961,2.6463,2.7019,3.1323,3.5549,3.3175,2.9153,2.829,2.741,2.5979,2.7006,2.847,2.9879,3.2797,3.1992,3.7886,4.5667,4.5667,6.4798,6.4798,6.4798,6.2196,6.2196,5.6484,7.309,7.309,7.309,7.6534,7.6534,6.27,6.27,5.118,5.118,3.9454,4.3549,4.3549,4.2392,3.875,3.8771,3.665,3.6526,3.9454,3.5875,3.9454,3.1121,3.4211,2.8893,3.3633,2.8617,3.048,3.2721,3.2721,2.8944,2.8944,3.2157,3.2157,3.3751,3.3751,3.6715,3.6715,3.8384,3.6519,3.6519,3.6519,4.148,4.148,6.1899,6.1899,6.3361,6.3361,7.0355,7.0355,7.9549,7.9549,8.0555,8.0555,7.8265,7.8265,7.3967,7.3967,8.9067,8.9067,9.2203,9.2203,6.3361,1.801,1.8946,2.0107,2.1121,2.1398,2.2885,2.0788,1.9301,1.9865,2.1329,2.4216,2.872,3.9175,4.429,4.429,3.9175,4.3665,4.0776,4.2673,4.7872,4.8628,4.1403,4.1007,4.6947,5.2447,5.2119,5.885,7.3073,7.3073,9.0892,7.3172,7.3172,7.3172,5.1167,5.1167,5.1167,5.5027,5.5027,5.9604,5.9604,6.32,7.8278,7.8278,7.8278,5.4917,5.4917,5.4917,4.022,3.37,3.0992,3.1827,3.3175,3.1025,2.5194,2.6403,2.834,3.2628,3.6023,3.945,3.9986,4.0317,3.5325,4.0019,4.5404,4.5404,4.7211,4.7211,4.7211,5.4159,5.4159,5.4159,5.2146,5.2146,5.8736,6.6407,6.6407,6.4584,6.4584,5.9853,5.2311,5.615,4.8122,4.8122,4.8122,7.0379,6.2669,5.7321,6.4654,8.0136,8.0136,8.5353,8.344,8.7921,8.7921,10.7103,10.7103,12.1265,10.5857,10.5857,2.1222,2.5052,2.7227,2.5091,2.5182,2.2955,2.1036,1.9047,1.9047,1.6132,1.7523,1.5106,1.3325,1.3567,1.2024,1.1691,1.1296,1.1742,1.137,1.3163,1.3449,1.358,1.3861,1.3861,1.4165,1.5192,1.5804,1.5331,1.4395,1.4261,1.4672,1.5184,1.5895,1.7281,1.9265,2.1678,1.77,1.7912,1.7821,1.7257,1.6768,1.6334,1.4896,1.5004,1.5888,1.5741,1.639,1.7028,1.6074,1.4254,1.1781,1.2852,1.4547,1.4655,1.413,1.5275,1.5539,1.5894,1.6582,1.8347,1.8195,1.6475,1.8026,1.794,1.8589,1.8746,1.9512,2.0218,2.0635,1.9096,1.9976,1.8629,1.9356,1.9682,2.0527,2.0882,2.2004,2.3158,2.2222,2.1247,2.0026,1.9142,1.8206,1.8172,1.8662,2.0651,2.0048,1.9784,1.8956,1.9879,2.072,2.198,2.2616,2.185,2.3236,2.3552,2.3682,2.4527,2.4961,2.4358,2.5806,2.7792,2.7831,2.7175,2.5975,2.5671,2.7344,2.8016,2.9634,3.0665,2.8715,2.5403,2.9084,2.8237,3.0334,3.0993,2.8965,2.5329,2.4298,2.206,2.3053,2.1007,2.1705,1.9512,3.4242,3.3317,3.4106,4.0983,3.724,3.9917,3.5459,3.1523,1.8209,1.7554,1.8226,1.8681,2.1099,2.3817,2.3817,2.7986,2.7986,2.8927,2.4091,2.3999)\nindus <- c(2.31,7.07,7.07,2.18,2.18,2.18,7.87,7.87,7.87,7.87,7.87,7.87,7.87,8.14,8.14,8.14,8.14,8.14,8.14,8.14,8.14,8.14,8.14,8.14,8.14,8.14,8.14,8.14,8.14,8.14,8.14,8.14,8.14,8.14,8.14,5.96,5.96,5.96,5.96,2.95,2.95,6.91,6.91,6.91,6.91,6.91,6.91,6.91,6.91,6.91,5.64,5.64,5.64,5.64,4,1.22,0.74,1.32,5.13,5.13,5.13,5.13,5.13,5.13,1.38,3.37,3.37,6.07,6.07,6.07,10.81,10.81,10.81,10.81,12.83,12.83,12.83,12.83,12.83,12.83,4.86,4.86,4.86,4.86,4.49,4.49,4.49,4.49,3.41,3.41,3.41,3.41,15.04,15.04,15.04,2.89,2.89,2.89,2.89,2.89,8.56,8.56,8.56,8.56,8.56,8.56,8.56,8.56,8.56,8.56,8.56,10.01,10.01,10.01,10.01,10.01,10.01,10.01,10.01,10.01,25.65,25.65,25.65,25.65,25.65,25.65,25.65,21.89,21.89,21.89,21.89,21.89,21.89,21.89,21.89,21.89,21.89,21.89,21.89,21.89,21.89,21.89,19.58,19.58,19.58,19.58,19.58,19.58,19.58,19.58,19.58,19.58,19.58,19.58,19.58,19.58,19.58,19.58,19.58,19.58,19.58,19.58,19.58,19.58,19.58,19.58,19.58,19.58,19.58,19.58,19.58,19.58,4.05,4.05,4.05,4.05,4.05,4.05,4.05,2.46,2.46,2.46,2.46,2.46,2.46,2.46,2.46,3.44,3.44,3.44,3.44,3.44,3.44,2.93,2.93,0.46,1.52,1.52,1.52,1.47,1.47,2.03,2.03,2.68,2.68,10.59,10.59,10.59,10.59,10.59,10.59,10.59,10.59,10.59,10.59,10.59,13.89,13.89,13.89,13.89,6.2,6.2,6.2,6.2,6.2,6.2,6.2,6.2,6.2,6.2,6.2,6.2,6.2,6.2,6.2,6.2,6.2,6.2,4.93,4.93,4.93,4.93,4.93,4.93,5.86,5.86,5.86,5.86,5.86,5.86,5.86,5.86,5.86,5.86,3.64,3.64,3.75,3.97,3.97,3.97,3.97,3.97,3.97,3.97,3.97,3.97,3.97,3.97,3.97,6.96,6.96,6.96,6.96,6.96,6.41,6.41,6.41,6.41,6.41,3.33,3.33,3.33,3.33,1.21,2.97,2.25,1.76,5.32,5.32,5.32,4.95,4.95,4.95,13.92,13.92,13.92,13.92,13.92,2.24,2.24,2.24,6.09,6.09,6.09,2.18,2.18,2.18,2.18,9.9,9.9,9.9,9.9,9.9,9.9,9.9,9.9,9.9,9.9,9.9,9.9,7.38,7.38,7.38,7.38,7.38,7.38,7.38,7.38,3.24,3.24,3.24,6.06,6.06,5.19,5.19,5.19,5.19,5.19,5.19,5.19,5.19,1.52,1.89,3.78,3.78,4.39,4.39,4.15,2.01,1.25,1.25,1.69,1.69,2.02,1.91,1.91,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,18.1,27.74,27.74,27.74,27.74,27.74,9.69,9.69,9.69,9.69,9.69,9.69,9.69)\nfrom <- c(402,155,168,430,449,431,357,121,382,200,391,422,89,214,378,458,442,443,145,394,169,386,459,437,447,451,180,434,455,105,14,430,321,460,259,68,291,123,444,162,192,465,449,404,117,460,25,165,116,131,406,143,397,364,357,463,128,136,353,447,398,394,434,337,409,76,462,104,340,350,432,392,191,113,395,386,37,221,288,66,459,18,359,401,383,362,392,19,426,358,118,193,444,119,63,377,121,197,489,120,385,272,445,424,247,82,402,401,421,362,384,29,115,364,239,456,394,154,424,128,484,275,82,381,481,52,191,164,224,358,120,59,206,23,380,91,130,259,189,390,40,374,301,453,98,229,396,7,410,360,24,54,96,396,54,165,420,383,321,313,147,36,463,429,192,395,81,43,225,379,495,69,4,98,412,57,37,112,469,352,449,42,384,248,429,325,232,310,403,272,64,398,367,357,53,5,299,372,399,51,433,52,51,249,53,105,358,401,180,3,205,454,360,114,204,260,372,225,240,63,339,382,213,239,90,440,230,482,363,214,154,129,189,273,82,196,190,200,91,22,464,359,85,39,174,250,40,270,481,208,302,71,465,262,330,84,337,370,470,218,89,100,21,52,29,6,18,42,53,104,393,227,235,361,26,349,272,241,151,58,179,96,210,417,183,113,178,17,281,151,208,2,14,159,206,227,43,203,494,89,129,39,255,274,393,258,178,45,175,223,311,45,278,275,145,77,285,54,56,185,310,305,198,181,1,159,8,12,206,238,36,182,146,106,151,83,130,174,305,51,271,199,175,296,56,82,329,498,400,132,229,158,200,44,153,313,286,375,70,95,5,38,61,22,111,89,84,23,38,386,13,257,143,19,152,228,61,7,408,61,13,81,71,292,86,101,387,78,211,15,41,91,88,13,202,55,99,47,277,316,241,376,253,28,367,88,166,78,158,9,4,294,363,116,243,99,59,8,413,110,67,22,72,15,314,85,10,64,383,155,144,20,209,102,163,173,331,76,263,129,252,150,21,261,107,309,97,77,160,352,369,173,78,148,53,158,57,361,21,97,124,256,93,93,65,65,131,87,312,8,123,77,75,21,74,388,71,122,374,133,139,167,210,48,124,125,139,287,366,95,9,33,127,211,125,142,79,124,33,1)\nto <- c(403,156,172,446,479,447,431,122,412,201,425,427,90,216,412,467,450,448,148,421,170,399,471,447,479,452,183,448,477,109,16,476,322,462,265,333,292,125,477,163,345,472,456,414,313,470,26,172,119,132,440,144,442,428,453,473,137,137,355,452,404,435,461,340,418,80,473,111,341,351,442,477,192,116,443,389,231,223,289,192,461,27,488,438,445,463,457,20,476,465,310,257,450,500,288,379,126,201,492,495,389,322,476,436,249,84,419,409,428,428,426,32,118,423,335,477,422,157,445,135,486,276,83,396,486,60,194,167,235,480,498,288,207,34,429,92,140,262,280,419,282,413,349,467,187,234,431,328,432,472,35,68,188,443,70,170,436,406,323,494,157,39,466,468,195,422,293,327,226,446,499,332,203,99,429,351,236,115,475,356,469,326,478,249,441,327,238,319,410,325,290,402,423,391,334,6,300,373,400,69,474,290,61,290,244,111,463,405,184,278,283,461,433,496,281,262,411,234,335,335,341,402,318,334,100,441,275,483,411,315,155,138,282,279,240,284,280,300,174,32,481,433,340,236,175,251,195,271,488,317,303,74,485,268,344,336,338,371,487,220,176,307,35,70,30,194,22,304,251,108,478,229,273,482,28,351,279,243,171,201,260,100,212,438,187,114,179,322,283,156,211,45,323,161,316,233,326,284,499,280,134,237,348,277,409,263,188,46,177,237,494,302,304,278,149,79,286,336,58,186,315,307,286,308,280,160,48,328,319,278,38,306,149,110,152,86,135,261,308,62,328,301,266,297,350,344,331,500,416,133,230,161,342,323,172,316,343,415,303,220,342,235,347,270,499,184,339,24,339,388,27,283,146,324,153,232,245,324,433,242,25,334,73,293,188,103,405,80,213,20,283,182,339,50,343,62,281,270,325,320,242,480,254,34,368,92,169,220,167,49,193,297,464,213,346,269,348,11,439,500,331,104,216,46,315,329,50,346,407,394,409,103,318,314,164,267,343,294,268,137,253,390,31,264,496,312,177,78,361,354,370,185,295,400,252,370,352,373,497,186,127,346,218,94,353,198,138,242,314,23,492,217,296,222,314,439,75,493,415,170,150,365,497,246,490,126,141,347,373,481,33,215,491,219,135,413,298,141,212,1)\ndistance <- c(0.0896270606457671,0.102685003773676,0.116158684565556,0.128953828946641,0.135274572629151,0.151398447812385,0.157880492778557,0.177741638340598,0.179479497436337,0.194164878389476,0.207781134851073,0.209260603076643,0.212687188142587,0.212953046467995,0.218858972856952,0.229946276334275,0.242068192871348,0.246678414134678,0.26707865882545,0.273143350642113,0.285823809365141,0.288804864917473,0.29018285614419,0.294646160674123,0.302718103191734,0.306487454881924,0.309049445882046,0.310647452910853,0.311192287822176,0.313034518863336,0.317748658533754,0.323222585844492,0.333766385365573,0.334880814619171,0.336881655778405,0.341719607280588,0.367789341879288,0.368402442988644,0.368462494699258,0.372747957740884,0.374743058641518,0.375990438708222,0.382028323557299,0.382877996233786,0.385621848447412,0.387688586367977,0.390832444917257,0.392281646269615,0.394263059390555,0.395322969228958,0.408219597765713,0.415163871260493,0.416266609278236,0.418746032817029,0.420286806835524,0.42139816088825,0.421899229674577,0.422761682275014,0.424695373179413,0.427081069587496,0.430952851249415,0.431260941890174,0.435407728456904,0.438786064044883,0.439022596229398,0.441977374986548,0.443086176719609,0.448269572913442,0.450320996623521,0.457931217542548,0.460176716055909,0.461297355292657,0.461566896559967,0.463421072028453,0.466282414422847,0.46947690039021,0.470107391986129,0.471181663480233,0.472055081531806,0.473546080123149,0.480153475463835,0.480405880480246,0.484499907120734,0.485293890338628,0.486389802524682,0.486815375681582,0.488394144109038,0.491468208534387,0.492655011138626,0.497034445486427,0.499496756746228,0.500525413940191,0.5088295981957,0.522619134743457,0.523084973976504,0.52588823907747,0.526474158910009,0.530203130884758,0.531195670163076,0.53228869046787,0.533614092767423,0.534514695775523,0.536015074414891,0.536343555941525,0.53634503819836,0.537032587465602,0.539637146608719,0.540169241997358,0.541938188357307,0.546300064067359,0.558594888984852,0.561035729699989,0.563712524253275,0.563726219010612,0.566597961521219,0.566755017622253,0.568176521866223,0.571212079704203,0.572649491399407,0.574042933934387,0.582635014395806,0.589662691714509,0.592021114488326,0.592210807061134,0.593764473507804,0.594393211603228,0.596242433914259,0.597323371382704,0.598675237503608,0.6000599970003,0.603565447983895,0.605146065012407,0.605735296973851,0.606108150415418,0.608646243724547,0.61011805415018,0.61273276393547,0.613181897971556,0.615542037557144,0.616392123570703,0.617162831025978,0.617621316018161,0.617623218475472,0.621880929117464,0.621900313555155,0.626290060594929,0.626464683761184,0.629007281356901,0.62945713912863,0.634054445611731,0.635753222563599,0.639139178896115,0.643531320139121,0.649846758859349,0.653886756250652,0.654327326343628,0.654436773111048,0.655769776674712,0.656412591286913,0.657747132262848,0.659657517201159,0.663896076204703,0.664269832221816,0.664651856237534,0.664927845709593,0.667246019096407,0.668030687917853,0.670801013714202,0.671402263922308,0.672684353913482,0.676978404382296,0.684548968299566,0.684926886609075,\n              0.686732116621904,0.686907279041357,0.687072958280269,0.688186747910768,0.688376350552516,0.69149039038876,0.695538755210664,0.69672895734281,0.697456808698575,0.700946331754437,0.701562541759465,0.702524988879399,0.703033455818427,0.707367125331676,0.710703876449255,0.7153364592973,0.716412876768696,0.717987945581261,0.720230858822363,0.72026815145472,0.726222755082765,0.726274527985113,0.726972489163105,0.733018417231109,0.735079077378753,0.737372117726187,0.742266724297944,0.745306145151105,0.750870328352372,0.753696550343704,0.753996346144993,0.758206198866773,0.759598736175884,0.759616113573166,0.761828038339362,0.764076566843926,0.769583972026445,0.774298527701042,0.776035463107195,0.776443616755267,0.776778192278852,0.777992217184722,0.778428423170685,0.77882489045998,0.781196038136395,0.782117798033008,0.783427348258918,0.785290392148025,0.788300710389124,0.79280628781563,0.793295184657011,0.79409161310267,0.794847155118517,0.795576677637046,0.797399655129095,0.799595747862631,0.800425892884531,0.800766158126079,0.80119928232619,0.801516063469722,0.804285919309794,0.80647730284243,0.810483534687781,0.812394608549318,0.812447758320497,0.81327547608421,0.813646292930781,0.814599140682091,0.814924100760309,0.81773580085502,0.820171421106588,0.820573189910566,0.820785623655775,0.820989189941013,0.82959523262854,0.831624079737954,0.832532696054635,0.835419056521935,0.83784485437341,0.840925894475845,0.845896116553328,0.84662580281964,0.847087457114081,0.851853983966736,0.852993253197234,0.854853110189113,0.855454171770762,0.857189220650843,0.859844171928844,0.860539139144757,0.86469583669635,0.866583804372088,0.869813060375619,0.875525190956834,0.87765405485305,0.878692210048547,0.879442601879168,0.879821851285815,0.880241080613714,0.886502882116014,0.887798541336941,0.890845351337705,0.894158045314138,0.896890009978928,0.897374704345961,0.906979277602305,0.908316552750196,0.908529118960972,0.915030600581205,0.916406023550697,0.917315698110525,0.917865981502746,0.918863515436323,0.92503504798467,0.926244157876314,0.927696523654153,0.929277272938492,0.940064806276673,0.94117928153992,0.948603689640727,0.948917915311962,0.952678413736766,0.954758760106447,0.956801442306605,0.959736422149331,0.962390128793932,0.963309918977273,0.965741041894773,0.968682347315157,0.969478725914087,0.969620797012935,0.977432908183472,0.977441686240157,0.981949189113164,0.985083372106138,0.98713220999013,0.990355900674096,0.999358439199871,0.999436661324769,1.00610695753483,1.00899110005986,1.02700277020074,\n              1.03167854005015,1.03248486671718,1.03359825851247,1.03697841829037,1.03703820566072,1.03919441876869,1.04738523953701,1.05119878709976,1.05520371966744,1.05526465400865,1.05773813394431,1.06416033096522,1.06459975577679,1.07133907330966,1.07840764092249,1.07905060585683,1.08061205342158,1.08339570333281,1.08687774841515,1.09023894628655,1.09906915160057,1.0996950531852,1.10165268574084,1.10190448315632,1.11365319556853,1.11624397422786,1.11913468358371,1.12414330047374,1.1274045414136,1.12806039288683,1.13302910818743,1.1335153285245,1.13731123268875,1.13880660781363,1.14232086560651,1.14523185425485,1.1465488258247,1.14760457039871,1.14760622166316,1.1694384336082,1.17636941476732,1.18152492991049,1.18190965813805,1.18302142415089,1.18715158678241,1.19248752194729,1.19292467909755,1.19327626306736,1.19825374608219,1.20424901494666,1.2092626224274,1.21115492402913,1.21154277266632,1.21452253993082,1.21558557493909,1.21650450471833,1.21930580249583,1.22410589819672,1.22412791815235,1.22458562787581,1.22550179110436,1.2286066294791,1.23012534320694,1.23088587610712,1.23234349513437,1.23590318795608,1.24444778516417,1.25056147389882,1.25216772039532,1.25277085294957,1.2537007657332,1.26581872319855,1.26865377861732,1.26941295487323,1.27252432589715,1.27543625477716,1.27712973499171,1.27754340826447,1.28436102401155,1.28487104800443,1.28987807175717,1.29170439729839,1.29217197384868,1.29463246135728,1.29715134429256,1.29753766804667,1.29886643270199,1.30203840189143,1.30707246929924,1.31046514261158,1.31694200707548,1.32108272261808,1.32650248397807,1.33892567381464,1.33970534446945,1.34137606956439,1.34300904315645,1.34981665421642,1.3560424956468,1.35746661469076,1.35844699565349,1.36644108910703,1.37440876015835,1.37908588927593,1.39143201055603,1.418219098024,1.42893308450746,1.43737142381501,1.44723123584312,1.45267382780857,1.46486860844241,1.4654771782597,1.47277740680661,1.47778526518571,1.48281598318874,1.48823432630752,1.49294180730529,1.49568721663321,1.50967873734778,1.5175779024485,1.51997310502522,1.52564769524291,1.53074524660376,1.53909603663969,1.5946975763448,1.59783009109229,1.62302641999445,1.64504133990608,1.66495792439329,1.66533172671393,1.67193565665668,1.69779653963601,1.70610312994262,1.71140272583632,1.76545275779331,1.77647252722917,1.78514179828942,1.79345193412034,1.80084540147121,1.80237426745945,1.80793372666146,1.82700062671035,1.84115153097185,1.85685230699698,1.87284282575981,1.87525807290623,1.9173077191729,1.93992964820892,1.96363464015076,1.96582266748555,1.99905532939936,2.00806267083475,2.01382700597643,2.02352223857313,2.03808659286106,2.10619501471255,2.1288186888507,2.12898196563522,2.20734818504014,2.24871991363976,2.25531590691859,2.27543790071274,2.28530025379599,2.29523963890483,2.31974395354315,2.3325994962702,2.3372287949621,2.40275944696925,2.55562423881133,2.58317343591173,2.77209822336799,2.85819941396677,2.8725666850397,2.94721308357574,3.0696178328906,3.07895167386563,3.13680573992079,3.24024337974788,3.50547141480287,3.7869222450428,3.81204554668488,3.91648296434441,3.98895728856552,4.50767578692168,0)\n\ndf <- cbind.data.frame(lstat, rm, dis, indus, from, to, distance)\nDistMat <- as.matrix(dist(df[ ,1:4], diag = T, upper = T))\n\ng <- graph.data.frame(df[, 5:6], directed = FALSE)\nlou <- cluster_louvain(g)\nset.seed(0)\nplot(lou, g, vertex.label = NA, vertex.size = 5, mark.groups = NULL)\n```\n\n    ", "Answer": "\r\nFirst of all,  your vertices are much larger than in the \"nice\" graph.  I will use a smaller node size.  But the main point is that you should specify the layout.  A couple of options worth trying are ```\nlayout_as_tree```\n and ```\nlayout_with_gem```\n.   Here is what I got.\n```\npar(mfrow=c(1,2))\nset.seed(20210401)\nLOWG = layout_with_gem(g)\nplot(lou, g, layout = LOWG, vertex.label = NA, \n    vertex.size = 2.5, mark.groups = NULL, main=\"GEM\")\nLOAT = layout_as_tree(g)\nplot(lou, g, layout = LOAT, vertex.label = NA, \n    vertex.size = 2.5, mark.groups = NULL, main=\"TREE\")\n```\n\n\nAddition based on OP comment:\nOP noted that distance is not being used in creating the graph. Using the distance depends on your application, but the most obvious way to use it in the display of the graph is in the layout of the vertices. You might want the layout to reflect those distances.  Here is one way to do that.\nYou only provide edge lengths, so we do not have a full distance matrix between all vertices, but we can compute the length of the shortest weighted path between any two nodes and use that as distance between them. Then we can use multi-dimensional scaling to layout the vertices in a way that approximates those distances.   Here is the result on your example graph.\n```\nDistMat = distances(g, weights=distance)\nset.seed(0)\nLOMDS = layout_with_mds(g, dist=DistMat)\nplot(lou, g, layout=LOMDS, vertex.label = NA, \n    vertex.size = 2.5, mark.groups = NULL, main=\"MDS\")\n```\n\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "how to connect edges to nodes in a image using minimum spanning tree approach\r\n                \r\nI am doing my project on graph matching in hand written image, i want to represent a given word image in graph, am using the below algorithm\n\n```\nAlgorithm:\n\ninput: Binary image B, Grid width w, Grid height h\nOutput: Graph g = (V, E) with nodes V and edges E\n1: function Grid(B,w,h)\n2: for i ← 1 to number of columns C = Width of B/w do\n3: for j ← 1 to number of rows R = Height of B/h do\n4: V = V ∪ {(xm, ym) | (xm, ym) is the centre of mass of segment sij}\n5: for Each pair of nodes (u, v) ∈ V × V do\n6: E = E ∪ (u, v) if associated segments are connected by NNA, MST, or DEL\n7: return g\n```\n\n\nam already  find the center of mass using this am plotting the points after plotting the points i do not know how to add the edges to using minimum spanning tree approch\n\nthis my code \n\n```\nclc;\nclear all;\nclose all;\nX=imread('i2.jpg');\nimfinfo('i2.jpg')\nfigure,imshow(X)\n\nb = imresize(X,[100,100]);\nsi = size(b,1);\nsj = size(b,2);\nfigure;imshow(b);\n\n% Binarization\nth = graythresh(b);\nI = im2bw(b,th);\n\nw = 10;\nh = 10;\nc=si/w;\nr=sj/h;\nkl=bwmorph(~I,'thin',inf);\nfigure,imshow(kl)\n\nR(:,:)=kl(:,:);\nI=1;\nU1=w;\nJ=1;\nU2=h;\nE=1;\nfor i=1:r\n  for j=1:c\nB(I:U1,J:U2)=R(I:U1,J:U2);\n[x,y]=find(B==1);\nCX=mean(x);\nCY=mean(y);\nCXX(E)=CX\nCYY(E)=CY\nT(I:U1,J:U2)=B(I:U1,J:U2);\nJ=J+w;\nU2=U2+h;\nE=E+1;\nclear B x y    \n    end\n\nI=I+w;\nU1=U1+h;\nJ=1;\nU2=h;\n\nend\nimshow(R)\nhold on\n\nhold on\nplot(CYY,CXX,'.c')\nhold off\n% CXX(isnan(CXX)) = [];\n% CYY(isnan(CYY)) = [];\n\nr = imread('empty.jpg');\nn = imresize(r,[100,100]);\nfigure,imshow(n);\nhold on\n\nhold on\nplot(CYY,CXX,'.k')\nhold off\n```\n\n\ninput image\nexpected output\n\nam plotting using the ```\nCXX```\n and ```\nCYY```\n values i do not know how to add the edges to plotted points using minimum spanning tree approach please give me some code it will help me to complete my project\n    ", "Answer": "\r\nHard to tell from your question, but I'm assuming you want to represent a graph where all nodes are at coordinates ```\n[CXX,CYY]```\n and the weight matrix is the distance between node ```\ni```\n and node ```\nj```\n\n\nYou can generate an adjacency matrix with ```\npdist2()```\n\n\n```\nA = pdist2([CXX,CYY],[CXX,CYY]);\n```\n\n\nBuild a graph based ```\nA```\n (note that this graph carries no information about original location, only distances)\n\n```\nG = graph(A,...);\n```\n\n\nDetermine the MST for ```\nG```\n\n\n```\nT = minspantree(G); \n```\n\n\n```\nT.Edges```\n will be a table of nodes ```\ni```\n and ```\nk```\n that are included in the MST, as well as their distance weight. You can use graph functions to visualize this, although it will only factor distance vectors, not original coordinate locations\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Java: Data structure for minimum spanning tree\r\n                \r\nMy project is to implement minimum spanning tree using java. I aim to use Prim's algorithm to do the task. \n\nThe definition of the graph is G = (V, E) where V is the set of pins, E is the set of possible interconnections between pairs of pins, and for each edge (u,v) in E we have a weigh w(u,v) specifying the cost to connect u and v. \n\nMy idea is to use two hashmaps. First would have pin as a key and a list of neighbours as value. The second hashmap would take list of edge (u,v) as a key and the value would be its weight. \n\nWhat do you think is the best way to store the graph?\n    ", "Answer": "\r\nGraphs are generally (without regard to the algorithm used with those graphs) stored as either : \n\n\nadjacency lists,\nadjacency matrices,\nincidence lists,\nincidence matrices.\n\n\nAll have their advantages and disadvantages concerning memory usage and time required to traverse them. Wikipedia has a great write-up on graph representations in computers.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Prove a property of Minimum Spanning Tree\r\n                \r\nI need your help proving the following:\n```\nG=(V,E)```\n is an undirected connected graph with non-negative weights on the edges.\nLet ```\nT```\n be a MST of ```\nG```\n and ```\nT'```\n be a spanning tree of ```\nG```\n (not a minimum one) so it holds that ```\nWeight(T') > Weight(T)```\n. Prove that the weight of the haviest edge in ```\nT'```\n isn't smaller than the weight of heaviest edge in ```\nT```\n.\n\nI'm not sure how to approch this, may if we let ```\ne(u,v) - heaviest edge on T```\n and ```\ne'(u',v') - heaviest edge on T'```\n and then if we look at the cut defined by ```\n(u,u')```\n we can use Kruskal algorithem and show that ```\ne'```\n isn't chosen to be in ```\nT```\n or something in this direction...\n\nThank you,\n    ", "Answer": "\r\nAssume the contrary -- there exists a weighted undirected graph with a minimum spanning tree T and a spanning tree T' such that the heaviest edge of T is heavier than the heaviest edge of T', i.e., the heaviest edge of T is heavier than every edge in T'. Consider the cut induced by deleting the heaviest edge h of T. Since T' is connected, some edge in T' crosses this cut. If we add this edge to T - h, we get a spanning tree that is lighter than T, which is a minimum spanning tree. Contradiction.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to find the amount of minimum spanning trees in a graph? Using kruskal's algorithm\r\n                \r\nI am trying to find the all the minimum spanning trees in the graph using kruskal's algorithm.\n\nI know that if all the weight of the edges that is distinct from each other, there will only be one minimum spanning tree in the graph. So, for more than two minimum spanning tree in the graph, there must be at least two edges that has the same weight. Therefore, I am thinking I should start cutting the edges with the same amount of weight. \n\nHowever, I am wondering will it make a difference if I cut different amount of edges at a time? \n\nThank you!!\n    ", "Answer": "\r\nIf your graph has different edges with the same weight then you will have a choice on which edge to cut first, whichever ones you choose to cut first will give still give you a minimum spanning tree, but cutting in different order may give you different minimum spanning tree (though they'll all still have the same total weight).\n\n\n  However, I am wondering will it make a difference if I cut different amount of edges at a time?\n\n\nYou're not making sense, you can only cut one edge at a time with Kruskall.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Proving optimality for a new algorithm that finds minimum spanning tree\r\n                \r\nBelow is an algorithm that finds the minimum spanning tree:\n\n```\nMSTNew(G, w)\n   Z ← empty array\n   for each edge e in E, taken in random order do\n       Z ← Z ∪ e\n       if Z has a cycle c then\n           let e be a maximum-weight edge on c\n           Z ← Z − e\n   return (Z)\n```\n\n\nDoes this algorithm always return the optimal MST solution?\n\n\n\nI would say yes. It sort of looks like Kruskals algorithm in disguise - sort-of.\n\nBeing fairly new to graph theory, I really don't have much of an idea other than that. Would someone have any ideas or advice?\n    ", "Answer": "\r\nYes, IMO the algorithm outputs a Minimum Spanning Tree.\n\nInformal Proof:\n\nAt every iteration, we remove only that edge which is the most expensive edge on a cycle. Such an edge can never be included in a MST (by exchange argument). Thus we always exclude those edges which can never be a part of the MST.\n\nAlso, the output of the algorithm is always a spanning tree because we are deleting edges only when the new edge results in a cycle.\n\nHowever, note that this algorithm will be highly inefficient since at each iteration you are not only checking for cycles (as in Kruskal's) but also searching for the maximum cost edge on the cycle.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Finding Minimum Spanning Tree in O(V+E) when edges have limited values\r\n                \r\nIf I have an undirected graph with the edges being only values of 1 or 2, could I find the minimum spanning tree in O(V+E) complexity?\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Given a graph G, does a divide-and-conquer approach work to finding minimum spanning trees?\r\n                \r\nIf given a connected graph G, split the graph into Ga and Gb. If you find a minimum spanning tree for Ga and Gb (called Xa and Xb, respectively), does connecting Xa to Xb with a minimal weighted edge still form a spanning tree? Is that spanning tree a minimum spanning tree?\n\nThis is my logic so far. I believe that connecting Xa to Xb would form at least a spanning tree almost by definition. (If there is a counterxample though that'd be helpful) However, I don't think it would always form a minimum spanning tree because depending on the structure of the graph, you may be able to remove an edge from Xa or Xb, then add the edge connecting them, and still have a tree. This may be the case in a situation where multiple edges of the same weight connect Xa and Xb at different vertexes. \n\nIs my logic correct so far?\n    ", "Answer": "\r\nIt's correct, that you don't always get a minimal spanning tree by just connecting Xa and Xb. But it is not necessary, that the edges connecting Xa and Xb have the same weight. See the following example:\n\nAssume you have the following Graph G:\n\n```\nA-B-C-D \n| | | | \nE-F-G-H\n```\n\n\nEdge (B,C) hast cost 1 and (F,G) has cost 2, all other edges have cost 10.\n\nThen you divide it in Ga and Gb:\n\n```\nA-B   C-D \n| |   | | \nE-F   G-H\n```\n\n\nMinimum spanning trees Xa and Xb are:\n\n```\nA-B   C-D \n|       | \nE-F   G-H\n```\n\n\nIf you now connect them with the minimal possible edge you get a spanning tree with cost 61:\n\n```\nA-B-C-D \n|     | \nE-F G-H\n```\n\n\nBut that's not a minimal spanning tree. A minimal spanning tree (with costs 53) would be\n\n```\nA-B-C-D \n|       \nE-F-G-H\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How does the Minimum spanning tree in neo4j work\r\n                \r\nI am playing around with some graph theory algorithms in neo4j. I am trying to find the minimum spanning tree (mst) within my network. I synthetically created a network of 10 000 people. Each person has 12 relationship types each one linking him back to the other 9999 and each relationship with its own weight assigned.\n\nThe problem I have however is the fact that according to the definition the results must be a tree spanning over the ENTIRE network. The neo4j function however only returns a very small sub-graph (only about 12 nodes) of the entire network.\n\nThe code I am using looks like this:\n\n```\nMATCH (a:Name {Name:\"Dillon Snow\"})\nCALL algo.mst(a,\"Weight\",{stats:true})\nYIELD loadMillis, computeMillis, writeMillis, weightSum, weightMin, weightMax, relationshipCount\nRETURN loadMillis, computeMillis, writeMillis, weightSum, weightMin, weightMax, relationshipCount\n```\n\n\nWhat can I change to get the function to return the mst spreading through the entire network\n    ", "Answer": "\r\n```\nalgo.mst.*```\n has not been adapted to the matured Neo4j-Graph-Algorithms-CoreAPI in its current release (3.2.5.2/3.3.0.0 @ Dec 2017) which might lead to unexpected results. But there is a pull request in the pipe, you can expect some changes in the next release.\n\nAnyway.. The procedure should add a new relationship-type (default ```\nmst```\n) to your nodes. In a connected graph each node should be connected as well while a disconnected graph leads to connections only between the nodes of this particular connected component (from your startNode).\n\nIf i understand you right you have multiple relationship types and more then one of them between a pair of nodes? E.g. Node A is connected to Node B with several relations, each of them with a different type and property value. This is a problem. In general the Graph-Algorithms-API does not support multible releationships. Each pair of nodes can only have one connection per direction. Although you can import multible types the core-api itself has no idea of the underlying type. If multible relationships between a pair of nodes get imported usualy the last one wins. This has been mentioned in the documentation ;)\n\nTo overcome this limitation you could replace your relationship types with some kind of artificial nodes. When traversing over the result tree the occurence of one of those nodes would indicate the original relationship.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Algorithm to find minimum spanning tree of chosen vertices\r\n                \r\nOne can use Prim's algorithm or Kruskal's algorithm to find the minimum spanning tree/graph of a collection of vertices/nodes and edges/links. What I want though, is an algorithm that finds the minimum spanning graph of this collection, but the resulting graph needs to include only arbitrarily chosen nodes, instead of all nodes. It's okay if the resulting graph includes more nodes than just those needed.\n\nDoes such an algorithm exist? Perhaps one could just use Prim's (or Kruskal's) algorithm after modifying the graph to include only the needed nodes? But, I'm not sure how to modify the graph to do so while maintaining its connectedness.\n\nFor example, say we have a diamond shaped starting graph (with costs of links in brackets):\n\n```\n    A\n(2)/ \\(1)\n  B   C\n(2)\\ /(5)\n    D\n```\n\n\nNow, we arbitrarily decide that only nodes A and D are needed. If we started at A, we'd still want it to take the left path, because ((2 + 2) < (1 + 5)).\n\nSay we modify the graph slightly:\n\n```\n    A\n(2)/ \\(1) (2)\n  B   C ------E\n(2)\\ /(5)\n    D\n```\n\n\nIf we decide that only nodes A, D, and E are needed, we realize that the path with the minimum cost is not necessarily the one with the fewest links. Taking A--B--D and A--C--E costs 7, but A--C--D and C--E costs 8.\n    ", "Answer": "\r\nWhat you want to find is a discrete Steiner tree. When not all vertices in the graph are mandatory but the tree is allowed to split at the optional vertices, the problem is NP-hard.\n\nWikipedia says (linked above) of this problem: it is believed that arbitrarily good approximation ratios cannot in general be achieved in polynomial time. There is a polynomial-time algorithm that finds a factor 1.39 approximation of a minimum Steiner tree.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Do I need a delauny triangulation to find the minimum spanning tree?\r\n                \r\nI understand that the MST is a subset of the delauny triangulation but how can it help to find a minimum spanning tree? What is the meaning when I use an edge of a delauny triangulation for the MST? How is this different from not triangulate a set of points before finding a MST?\n    ", "Answer": "\r\nthe standard mst algorithms operate on an graph. if you start with a set of vertices without any other information but the pairwise (abstract) distances between the vertices, your standard approach would require you to run a mst algorithm on the complete graph with ```\nO(n^2)```\n edges. as the complexity of the standard mst algorithms depend on the number of edges (eg. ```\nO(e log e)```\n for Kruskal), it would be more efficient if you could curtail the number of edges in the graph to start with - which applies to the delaunay triangulation regarded as a graph since it sports ```\nO(n)```\n edges (i will not discuss that there is a mst of the original point set being a subset of the delaunay graph, as you acknowledge that).  \n\nyour original point set might be subject to other constraints that either prevent a delaunay triangulation (eg. collinear points) or allow for a even sparser graph to start with ( eg. a convex hull with a minimum diameter less than the minimum distance between two points in your point set ).\n\nregards, carsten\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Undirected Graph: Minimum Spanning Tree with few red edges as possible\r\n                \r\nI am not sure how to proceed with this problem.\n\nGiven an undirected graph, with each edge having color either red or blue. How can I find the minimum spanning tree which contains few red edges as possible, in time complexity (O(m + n) log n). Where m vertices and n are edges.\n\nAny help will be greatly appreciated. \n    ", "Answer": "\r\nAs far as I can see, I think you have answered your own question. By assigning weight to the edges, red weights 1 and blue weights 0, the problem become the classical finding minimum spanning tree, which has time complexity ```\nO((m + n) log n)```\n.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Finding spanning tree with maximum minimum degree\r\n                \r\nGiven a connected undirected graph, the problem of finding the spanning tree with the minimum max degree has been well-studied (M. F¨urer, B. Raghvachari, \"Approximating the minimum degree spanning tree to within one from the optimal degree\", ACM-SIAM Symposium on Discrete Algorithms (SODA), 1992). The problem is NP-hard and an approximation algorithm has been described in the reference.\n\nI am interested in the following problem - given a connected undirected graph G = (V1,V2,E), find the spanning tree with the maximum min degree over all internal nodes (non-leaf nodes). Can someone please tell me if this problem has been studied; is it NP-hard or does there exist a polynomial-time algorithm for solving it? Also, the graph can be considered to be bipartite for convenience.\n    ", "Answer": "\r\nAs noted in  Evgeny Kluev's comment, the leaves of a (finite) tree have degree 1.  (Else, cycles would exist and the structure would not be a tree.)\n\nIf instead you mean to find a spanning tree with a node of maximum degree, from among all possible spanning trees on a connected undirected graph G, then just form a spanning tree whose root R is a node M of G with maximal degree among all the nodes of G, and all neighbors of M are children of R.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Spanning Trees with minimum number of leaves\r\n                \r\nSo my problem is the following: \n\nI have an undirected (complete) weighted graph G=(V,E), and I would like to generate all the possible spanning trees with minimum number of leaves, i.e. with minimum number of vertices of degree 1. Let's call this kind of trees MIN_LEAF.\n\nPossibly, I would like to directly generate, among all trees with minimum number of leaves, the one which has also the minimum total weight (please note that this is not necessarily a minimum spanning tree).\nIs the problem of deciding if a tree T is a MIN_LEAF for a given graph G NP-complete? \n\nIf so, I wonder if some kind of heuristic algorithm exists (greedy or local search) which can at least give an approximate solution for this problem. \n\nThanks in advance.\n    ", "Answer": "\r\nThe first problem you described - finding a spanning tree with the fewest number of leaves possible - is NP-hard. You can see this by reducing the Hamiltonian path problem to this problem: notice that a Hamiltonian path is a spanning tree of a graph and only has two leaf nodes, and that any spanning tree of a graph with exactly two leaf nodes must be a Hamiltonian path. That means that the NP-hard problem of determining whether a Hamiltonian path exists in a graph can be solved by finding the minimum-leaf spanning tree of the graph: the path exists if and only if the minimum-leaf spanning tree has exactly two leaves. The second problem you've described contains that first problem as a special case and therefore is going to also be NP-hard.\n\nA quick Google search turned up the paper \"On finding spanning trees with few leaves\", which seems like it might be a good starting point for approximation algorithms (they have a 2-approximation for arbitrary graphs) and further reading on the subject.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Prim's Minimum Spanning Tree\r\n                \r\nI am trying to optimize a graph using Prim's Min Spanning Tree algorithm. But I am not getting desired answer.\n\nAlgorithm:\n\n```\n1. Construct min heap array. The array consists of nodes which have a vertex value \nand a key value. The key values are initialized to INT_MAX initially.\n\n2. Make the zeroth node's key 0, as this is the starting node.\n\n3. I iterate over the heap, till it becomes empty, and in every step following is done:\n     - Extract the minimum element out of the min heap. This is done by extractMin()\n       function in the class MinHeap. \n\n4. Look for this extracted element's neighbors and update their keys based on the weight of \nthe corresponding edge.\n\n5. Then decrease the key value in the minHeap by using decreaseKey() function in \nclass MinHeap.\n\n6. Store the parent and child for which the condition satisfies in a map called parent.\n```\n\n\nThis is the code description:\n\n```\n1. The code contains two header files, Graph.h and MinHeap.h. The functions are all std f\nfunctions in these files. So there won't be any problem in understanding them.\n\n2. The Graph.cpp file contains the PrimMST() function which does all the job and performs \nthe entire algorithm.\n```\n\n\nHere's the problem:\n\n```\n1. When I extract a node from heap in PrimMST() function, I call extractMin() function \ndefined in MinHeap.cpp file. This function swaps the top most node in the heap with the \nbottom most node. And then performs the heapify operation.\n\n\nBut, it is not performing this operation though I have called it in extractMin(). There's\nno problem with minHeapify function which does the heapify operation as it does \nperform its job else where is the program.\n```\n\n\nThis is the graph which I am trying to optimize:\n\nThis is the program:\nP.S.: I am posting the entire code with all the header files, so that it can be understood easily. But skip the code and please observe the PrimMST() function in the Graph.cpp file.\n\n```\n/***************GRAPH.H*******************************/\n\n#ifndef GRAPH_H_\n#define GRAPH_H_\n#include <list>\n#include <map>\n\nusing namespace std;\n\nclass AdjListNode{\n    int v;\n    int weight;\npublic:\n    AdjListNode(int _v, int _w){ v = _v; weight = _w; }\n    int getV()      { return v;  }\n    int getWeight() { return weight;  }\n};\n\nclass Graph{\n    int V;                          // To store number of vertices in the graph\n    list<AdjListNode> *adj; // This is a map for storing the adjacency list\n    map<int,int> mapping;           // A map to form a dictionary of vertex values to their array indexes for look ups.\n    map<int,int> parent;            // A map to store the parent child for a given edge in the graph\npublic:\n    Graph(int);                     // Class constructor\n    void HashTable(int *, int);     // This method uses the map library in STL to create a mappinh\n                                    // of arbitrary integers to zero based array indexes\n    int getHashedElt(int);          // This method returns the value corresponding to a given \n                                    // key in a hash table\n    void addEdge(int, int, int);    // This method adds the second arg to the adj list of first arg.\n    void printGraph();              // This method prints the adjacency list of all the vertices\n\n    void PrimMST(int *, int);       // This function will perform the Prim's MST algorithm and optimize \n                                    // the number of nodes in the graph\n\n};\n#endif\n\n/****************GRAPH.CPP*************************/\n#include <iostream>\n#include <climits>\n#include <list>\n#include <map>\n#include \"Graph.h\"\n#include \"MinHeap.h\"\n\n#define INF 9999\n\nusing namespace std;\n\nGraph::Graph(int v){\n    V = v;\n    adj = new list<AdjListNode>[V];\n}\n\n // This function takes in a pointer to array and its size as its arguments to create a hashtable.\n// So. if you have 10,11,12,13,14,15 as the nodes.\n// Create an array int arr[] {10,11,12,13,14,15}, and int size = sizeof(arr)/sizeof(arr[0])\n// And pass it to this function this creates a dictionary named mapping for O(1) look up of \n// index by other functions.\nvoid Graph::HashTable(int *nodeData, int size){\n    for (int i = 0; i < size; i++){\n            mapping[nodeData[i]] = i;\n    }\n    return;\n}\n\n\n// This method returns the value corresponding to a particular node in constant time.\nint Graph::getHashedElt(int data){\n    return mapping[data];\n}\n\n// This function creates an adjacency list for every vertex in the graph\nvoid Graph::addEdge(int node1, int node2, int weight){\n    AdjListNode node(node2, weight);\n    int index = getHashedElt(node1);\n    adj[index].push_back(node);\n}\n\n\nvoid Graph::printGraph(){\n    list<AdjListNode>::iterator j;\n    int i = 0;\n    while (i<V){\n            for (j = adj[i].begin(); j != adj[i].end(); j++){\n                    cout <<\"(\" << j->getV() << \",\" << j->getWeight() << \")->\";\n            }\n            if (!adj[i].empty())\n                    cout << \"NULL\\n\";\n            i++;\n    }\n}\n\nvoid Graph::PrimMST(int *arr, int size){\n    MinHeap minHeap(arr,size);\n    size_t key[V];  // Key values to pick minimum weight edge in cut\n\n    for (int i = 1; i < V; i++){\n            parent[arr[i]] = -1;    // All the parents are -1 initially\n            key[i] = INT_MAX;       // Initially all the keys are initialised to positive infinity\n            MinHeapNode *newNode = minHeap.newMinHeapNode(arr[i],key[i]);\n            //cout << \"(\"<< arr[i] << \", \" << key[i] << \")\\n\";\n            minHeap.insertNode(i, newNode);\n    }\n\n    // Make key value of 0th vertex as 0 so that it is extracted first.\n    key[0] = 0;\n\n    // This function insertNode creates a newNode with vertex number and associated key value.\n    MinHeapNode *newNode = minHeap.newMinHeapNode(arr[0],key[0]);\n    minHeap.insertNode(0, newNode);\n\n    //minHeap.printHeap();  \n\n while (!minHeap.isEmpty()){\n            // Extract the vertex with minimum key value\n            minHeap.printHeap();\n            MinHeapNode *minNode = minHeap.extractMin();\n            // Get the vertex of this minNode.\n            int u = minNode->v;\n            cout << \"\\n\";\n            minHeap.printHeap();\n            cout << \"\\n\\n\\n\";\n            //cout << u << \"\\n\";\n            // Traverse through all the adjacent vertices of u (extended vertex)\n            // and update their key values\n            list<AdjListNode>::iterator j;\n            for (j = adj[mapping[u]].begin(); j != adj[mapping[u]].end(); j++)  {\n                    int v = j->getV();\n                    // If v is not yet included in the MST and weight of u-v\n                    // is less than key value of v, then update key value\n                    // and parent of v\n                    if (minHeap.isInMinHeap(v) && j->getWeight() < key[mapping[v]]){\n                            key[mapping[v]] = j->getWeight();\n    //                      cout << key[mapping[v]] << \"\\n\";\n                            parent[v] = u;\n                            minHeap.decreaseKey(v,key[mapping[v]]);\n                    }\n            }\n    }\n    for (int k = 1; k < size; k++){\n            //cout <<parent[arr[k]]<<\"---\"<<arr[k]<< \"\\n\";\n    }\n    return;\n}\n\n\n/*************MINHEAP.H**************************/\n#ifndef MINHEAP_H_\n#define MINHEAP_H_\n#include <map>\n\nusing namespace std;\n\nstruct MinHeapNode{\n    int v;\n    size_t key;\n};\n\nclass MinHeap{\n    int size;               // Number of heap nodes present in the heap at any given time\n    int capacity;           // Capacity of min heap\n    map<int,int> pos;       // This is map which stores the array index of a given vertex, for O(1) look up\n    MinHeapNode **MinHeapArray;     // This array containe pointers to all the heap nodes.\n\npublic:\n    MinHeap(int*,int);      // Class constructor, it will allocate space to minHeap and initialise all the variables.\n                            // It also creates the map of every vertex to an index, so that there is O(1) look up.\n    MinHeapNode *newMinHeapNode(int,size_t);   // This function creates a new min heap node with a given value of vertex and weight\n    int getIndex(int);                      // This function returns the index of a given vertex in pos map.\n    void insertNode(int,MinHeapNode *);             // This function inserts a node into the MinHeapArray.\n    void printHeap();\n    void swapMinHeapNode(MinHeapNode **, MinHeapNode **); // It will perform swap operation in the heap.\n    void minHeapify(int);      // Standard function to heapify at given idx.\n    bool isEmpty();         // A utility function to check whether given heap is empty or not.\n    bool isInMinHeap(int);  // Checks whether given vertex in the heap or not\n    MinHeapNode *extractMin();      // Std func to extract to minimum node from the heap.\n    void decreaseKey(int,int);      // This func performs the decreaseKey op by making use of pos map.\n\n};\n\n#endif\n\n\n/***************MINHEAP.CPP***************************/\n#include <iostream>\n#include <cstdlib>\n#include <climits>\n#include <map>\n#include \"MinHeap.h\"\n\nusing namespace std;\n\nMinHeap::MinHeap(int *arr,int s){\n    size = 0;\n    capacity = s;\n    MinHeapArray = (MinHeapNode **)malloc(sizeof(MinHeapNode *)*s);\n    for (int i = 0; i < s; i++){\n            pos[arr[i]] = i;        // This is a mapping from vertex to array index i. This will enable O(1) access of any var in heap.\n    }\n}\n\nMinHeapNode *MinHeap::newMinHeapNode(int v, size_t key){\n    MinHeapNode *node = new MinHeapNode;\n    node->v = v;\n    node->key = key;\n    return node;\n}\n\nint MinHeap::getIndex(int v){\n    return pos[v];\n}\n\nvoid MinHeap::insertNode(int idx, MinHeapNode *node){\n    MinHeapArray[idx] = node;\n    size++;\n}\n\nbool MinHeap::isEmpty(){\n    return size == 0;\n}\n\nbool MinHeap::isInMinHeap(int v){\n    if (pos[v] < size)\n            return true;\n    return false;\n}\n\n\nvoid MinHeap::printHeap(){\n    for (int i = 0; i < size; i++){\n            cout << MinHeapArray[i]->v << \", \"<< MinHeapArray[i]->key << \"\\n\";\n    }\n}\n\nvoid MinHeap::swapMinHeapNode(MinHeapNode **a, MinHeapNode **b){\n    MinHeapNode *t = *a;\n    *a = *b;\n    *b = t;\n}\n\n// A standard function to heapify at given index idx\n// This function also updates position of nodes when they are swapped.\nvoid MinHeap::minHeapify(int idx){\n    int smallest, left, right;\n    left = (2*idx + 1);\n    right = (2*idx + 2);\n    smallest = idx;\n\n    if (left < size && MinHeapArray[left]->key < MinHeapArray[smallest]->key)\n            smallest = left;\n    if (right < size && MinHeapArray[right]->key < MinHeapArray[smallest]->key)\n            smallest = right;\n    if (smallest != idx){\n            // To nodes to be swapped in min heap\n            MinHeapNode *smallestNode = MinHeapArray[smallest];\n            MinHeapNode *idxNode = MinHeapArray[idx];\n\n            // Change the mapping of vertices in pos map.\n            pos[smallestNode->v] = idx;\n            pos[idxNode->v] = smallest;\n\n            // Swap Nodes using swapMinHeapNode utility function\n            MinHeap::swapMinHeapNode(&smallestNode, &idxNode);\n            minHeapify(smallest);\n    }\n    return;\n}\n\n MinHeapNode *MinHeap::extractMin(){\n    if (isEmpty())\n            return NULL;\n\n    // Store the root node\n    MinHeapNode *root = MinHeapArray[0];\n\n    // Replace the root with last node\n    MinHeapNode *lastNode = MinHeapArray[size-1];\n    MinHeapArray[0] = lastNode;\n\n    // Update position of last node\n    pos[root->v] = size - 1;\n    pos[lastNode->v] = 0;\n\n    // Reduce heap size and heapify root\n    size--;\n    MinHeap::minHeapify(0);\n\n    return root;\n}\n\nvoid MinHeap::decreaseKey(int v, int key){\n    // Get the index of v in heap array\n    int i = pos[v];\n\n    // Get the node and update its key value\n    MinHeapArray[i]->key = key;\n\n    // Travel up till the complete tree is not heapified.\n    // This is O(logn) loop\n    while (i && MinHeapArray[i]->key < MinHeapArray[(i-1)/2]->key){\n            // Swap this node with its parent\n\n            // First update the pos matrix\n            pos[MinHeapArray[i]->v] = (i-1)/2;\n            pos[MinHeapArray[(i-1)/2]->v] = i;\n\n            // Do the swapping now.\n            MinHeap::swapMinHeapNode(&MinHeapArray[i], &MinHeapArray[(i-1)/2]);\n\n            // move to the parent index in the next iteration\n            i = (i - 1)/2;\n    }\n    return;\n}\n\n\n\n/**********************MAIN FUNCTION CALL***************/\n#include <iostream>\n#include \"Graph.h\"\n#include \"MinHeap.h\"\n\nusing namespace std;\n\nint main(){\n    int arr[] = {0,1,2,3,4,5,6,7,8};        // An array with all the vertices\n    int size = sizeof(arr)/sizeof(arr[0]);\n\n    Graph g(size);\n    g.HashTable(arr,size);\n    g.addEdge(0, 1, 4);\n    g.addEdge(0, 7, 8);\n    g.addEdge(1, 2, 8);\n    g.addEdge(1, 7, 11);\n    g.addEdge(2, 3, 7);\n    g.addEdge(2, 8, 2);\n    g.addEdge(2, 5, 4);\n    g.addEdge(3, 4, 9);\n    g.addEdge(3, 5, 14);\n    g.addEdge(4, 5, 10);\n    g.addEdge(5, 6, 2);\n    g.addEdge(6, 7, 1);\n    g.addEdge(6, 8, 6);\n    g.addEdge(7, 8, 7);\n    //g.printGraph();\n    g.PrimMST(arr,size);\n    return 0;\n}\n```\n\n\nWith this input I am getting erroneous output. Please, observe that this output is obtained by calling printHeap before and after call to extractMin(). And as can be seen even though minHeapify(0) is called in extractMin() everytime a node is extracted. It is somehow not performing the operation and hence the heap is not heapified, leading to erroneous result\n    Sample output, for first 3 iterations:\n\n```\nFirst Iteration:\n\n0, 0\n1, 2147483647\n2, 2147483647\n3, 2147483647\n4, 2147483647\n5, 2147483647\n6, 2147483647\n7, 2147483647\n8, 2147483647\n\n8, 2147483647\n1, 2147483647\n2, 2147483647\n3, 2147483647\n4, 2147483647\n5, 2147483647\n6, 2147483647\n7, 214748364\n\n\nSecond Iteration:\n1, 4\n7, 8\n2, 2147483647\n8, 2147483647\n4, 2147483647\n5, 2147483647\n6, 2147483647\n3, 2147483647\n\n3, 2147483647\n7, 8\n2, 2147483647\n8, 2147483647\n4, 2147483647\n5, 2147483647\n6, 2147483647 \n\nThird Iteration:\n2, 8\n7, 8\n3, 2147483647\n8, 2147483647\n4, 2147483647\n5, 2147483647\n6, 2147483647\n\n6, 2147483647\n7, 8\n3, 2147483647\n8, 2147483647\n4, 2147483647\n5, 2147483647\n```\n\n\nPlease observe the second and third iteration, these are not heapified at all, even though I have called minHeapify function in extractMin() function at the end.\n\nI desperately need help on this.\n    ", "Answer": "\r\nyour problem is in this line ```\nMinHeap::swapMinHeapNode(&smallestNode, &idxNode);```\n in ```\nminHeapify(int idx)```\n you are swapping the pointers to the nodes which doesn't swap the values in ```\nMinHeapArray```\n you should be swapping the array elements instead so this line should be replaced by ```\nMinHeap::swapMinHeapNode(&MinHeapArray[idx], &MinHeapArray[smallest]);```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Boruvka algorithm Minimum Spanning Tree for Directed Graphs\r\n                \r\nDoes the Boruvka algorithm (http://en.wikipedia.org/wiki/Bor%C5%AFvka's_algorithm) only work for undirected graphs?\n\nFor example, if we have a graph structure that looks like:\n\n```\nnode 1 -> node 2 (weight 1), node 3 (weight 1), node 4 (weight 1)\n\nnode 2 -> node 3 (weight 2)\n\nnode 3 -> node 4 (weight 2)\n\nnode 4 -> node 2 (weight 2)\n```\n\n\nThen the minimum spanning tree should include the edges:\n\n```\n1 -> 2\n\n1 -> 3\n\n1 -> 4\n```\n\n\nHowever, Boruvka's algorithm will spit out \n\n```\n1 -> 2\n\n2 -> 3\n\n3 -> 4\n```\n\n\nBecause, Boruvka first looks at each individual node and adds the shortest edge outgoing from that node to the MST.\n\nI know in the wikipedia article it says that edge weights have to be distinct but as long as all of the edge weights coming out of node 1 are less than the \"outer\" edge weights (from nodes 2-4) then it seems like Boruvka's algorithm fails. Is this because it is a directed graph not undirected?\n    ", "Answer": "\r\n\n  Is this because it is a directed graph not undirected?\n\n\nYes. For a directed graph, you would have to consider incoming as well as outgoing edges, then the algorithm would work in the same manner. The easiest way to do this is to consider the underlying undirected graph.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "What is the difference between Minimum Spanning Tree (MST) and All Pairs Shortest Path (APSP)?\r\n                \r\nWhat is the difference between Minimum Spanning Tree (MST) and All Pairs Shortest Path (APSP)? Also is there any real world problem using which the difference between them clearly visible?\n    ", "Answer": "\r\nMinimum spanning tree (MST) is a tree that connects all nodes of the graph, with the smallest sum of edge weights. The shortest path between two nodes need not be through edges of the MST. For example in this graph:\n```\n   4\nA ——— B\n \\   /\n3 \\ / 3\n   C\n```\n\nthe MST would be the edges AC and BC, but the shortest path from A to B is simply the edge AB.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Converting List of words to Problem Graph For Minimum Spanning Tree Algorithm\r\n                \r\nI have been trying to construct a problem weighted Graph for Minimum Spanning Tree from a list or string of words as, given a string of words to list of named-tuple with every possible combinations of words as head and tail with additional head \"root\" \n\nInput:\n\n```\n['john', 'saw', 'mary', 'root']\n```\n\n\nRequired Output:\n\n```\n[Arc('root',weight,'saw'),Arc('root',weight,'john'),Arc('root', weight,'mary'),\n Arc('saw', weight,'john'), Arc('john', weight, 'saw'), Arc('saw', weight,'mary'),Arc('john', weight,'mary'),\n Arc('mary', weight,'john'),Arc('saw', weight,'mary'),Arc('mary', weight,'saw')]\n```\n\n\nCode:    \n\n```\nfrom collections import defaultdict, namedtuple \n\nArc = namedtuple('Arc', ('head', 'weight', 'tail'))\n\ndef Constrain_graph(sentence):\n    Arc = namedtuple('Arc', ('head', 'weight', 'tail'))\n    C_graph=[]\n    for wordindex in range(1, len(sentence)):\n        G = nx.DiGraph()\n        G.nodes(sentence[wordindex])\n\n        #G.add_node(nod)\n        G.add_nodes_from(range(1,len(sentence)))\n        C_graph=nx.Graph()\n    return C_graph\n```\n\n\nI need the output to be like mentioned above\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Will a minimum spanning tree and shortest path tree always share at least one edge?\r\n                \r\nI'm studying graph theory and I have a question about the connection between minimum spanning trees and shortest path trees.\n\nLet G be an undirected, connected graph where all edges are weighted with different costs.  Let T be an MST of G and let Ts be a shortest-path tree for some node s.  Are T and Ts guaranteed to share at least one edge?\n\nI believe this is not always true, but I can't find a counterexample.  Does anyone have a suggestion on how to find a counterexample?\n    ", "Answer": "\r\nI think that this statement is actually true, so I doubt you can find a counterexample.\n\nHere's a hint - take any node in the graph and find a shortest path tree for that node.  Now consider what would happen if you were to run Prim's algorithm starting from that node - can you guarantee that at least one edge from the MST will find its way into the shortest path tree?\n\nHope this helps!\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum Spanning Tree (MST) algorithm variation\r\n                \r\nI was asked the following question in an interview and I am unable to find an efficient solution.\n\nHere is the problem:\n\n\nWe want to build a network and we are given c nodes/cities and D possible edges/connections made by roads. Edges are bidirectional and we know the cost of the edge. The costs of the edges can be represented as d[i,j] which denotes the cost of the edge i-j. Note not all c nodes can be directly connected to each other (D is the set of possible edges).\nNow we are given a list of k potential edges/connections that have no cost. However, you can only choose one edge in the list of k edges to use (like getting free funding to build an airport between two cities).\n\n\nSo the question is... find the set of roads (and the one free airport) that minimizes total cost required to build the network connecting all cities in an efficient runtime.\n\nSo in short, solve a minimum spanning tree problem but where you can choose 1 edge in a list of k potential edges to be free of cost. I'm unsure how to solve... I've tried finding all the spanning trees in order of increasing cost and choosing the lowest cost, but I'm still challenged on how to consider the one free edge from the list of k potential free edges. I've also tried finding the MST of the D potential connections and then adjusting it according the the options in k to get a result.\n\nThank you for any help!\n    ", "Answer": "\r\nOne idea would be to treat your favorite MST algorithm as a black box and to think about changing the edges in the graph before asking for the MST. For example, you could try something like this:\n\n```\nfor each edge in the list of possible free edges:\n    make the graph G' formed by setting that edge cost to 0.\n    compute the MST of G'\n\nreturn the cheapest MST out of all the ones generated this way\n```\n\n\nThe runtime of this approach is O(kT(m, n)), where k is the number of edges to test and T(m, n) is the cost of computing an MST using your favorite black-box algorithm.\n\nWe can do better than this. There's a well-known problem of the following form:\n\n\n  Suppose you have an MST T for a graph G. You then reduce the cost of some edge {u, v}. Find an MST T' in the new graph G'.\n\n\nThere are many algorithms for solving this problem efficiently. Here's one:\n\n```\nRun a DFS in T starting at u until you find v.\nIf the heaviest edge on the path found this way costs more than {u, v}:\n   Delete that edge.\n   Add {u, v} to the spanning tree.\nReturn the resulting tree T'.\n```\n\n\n(Proving that this works is tedious but doable.) This would give an algorithm of cost O(T(m, n) + kn), since you would be building an initial MST (time T(m, n)), then doing k runs of DFS in a tree with n nodes.\n\nHowever, this can potentially be improved even further if you're okay using some more advanced algorithms. The paper \"On Cartesian Trees and Range Minimum Queries\" by Demaine et al shows that in O(n) time, it is possible to preprocess a minimum spanning tree so that, in time O(1), queries of the form \"what is the lowest-cost edge on the path in this tree between nodes u and v?\" in time O(1). You could therefore build this structure instead of doing a DFS to find the bottleneck edge between u and v, reducing the overall runtime to O(T(m, n) + n + k). Given that T(m, n) is very low (the best known bound is O(m α(m)), where α(m) is the Ackermann inverse function and is less than five for all inputs in the feasible univers), this is asymptotically a very quick algorithm!\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to export a minimum spanning tree created with R ape package in newick format?\r\n                \r\nI have been using the R ape package to create a minimum spanning tree from a distance matrix.\nif my distance matrix is, for example:\n\ndistmat\nsample1 sample2 sample3 sample4 sample5\nsample1       0       5       4       4       6\nsample2       5       0       1       1       3\nsample3       4       1       0       0       2\nsample4       4       1       0       0       2\nsample5       6       3       2       2       0\n\nI'm using ape package mst function to calculate a minimum spanning tree:\n\nMST = ape::mst(distmat)\n\nTo get branch lengths, I'm using:\n\nMSTwlength = MST\nMSTwlength [MST >0] <- distmat[MST >0]\nMSTwlength\nsample1 sample2 sample3 sample4 sample5\nsample1       0       0       4       0       0\nsample2       0       0       1       0       0\nsample3       4       1       0       0       2\nsample4       0       0       0       0       0\nsample5       0       0       2       0       0\nattr(,\"class\")\n[1] \"mst\"\n\nNow I want to export this minimum spanning tree to a Newick format. Any ideas how to do that?\nI have searched APE and TreeTools manuals and tutorials and found nothing.\nThank you,\nMor\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Constrained minimum not-quite spanning tree?\r\n                \r\nI'm looking for some search terms/papers that I can read for a problem like the following.\nI have some undirected graph, G, where there are non-negative weights between nodes. However, each node has an associated \"state\"/\"colour\". Changing any node's state/colour changes the weights between adjacent nodes.\nI need find the set of colours that minimises the total weight of the tree, but I'm having trouble matching this to an existing known problem. I've considered duplicating the nodes,once for each state - but its not quite a minimum spanning tree problem, as not all nodes then need to (or indeed can) be visited.\nAny ideas as to existing algorithms or papers for this problem?  I'm having trouble coming up with good search terms.\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "What is a minimum spanning forest? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is off-topic. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it's on-topic for Stack Overflow.\r\n                \r\n                    \r\n                        Closed 10 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nA minimum spanning tree gives the cheapest way an undirected graph. But what is a minimum spanning forest? Is it defined for connected graphs or unconnected graphs? \n    ", "Answer": "\r\nMinimum spanning forest is a generalization of minimum spanning tree for unconnected graphs. For every component of the graph, take its MST and the resulting collection is a minimum spanning forest.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Exporting Coordinates of Nodes for a Minimum Spanning Tree in Networkx\r\n                \r\nI use Networkx in Python to generate the minimum spanning tree of the correlation in my data, and I want to find the (x,y) coordinates of the nodes. I read this question : Exporting Layout Positions for a Graph Using NetworkX and tried to apply it, but I don't really understand why I don't get the expected result.\n\nHere is the code I use :  \n\n```\nimport networkx as nx\nimport random as rn\nimport pylab as pl\ndef create_tree(data):\n    corr_matrix = define_correlation_matrix(data)\n    G = nx.Graph(corr_matrix)\n    pos = nx.minimum_spanning_tree(G)\n    rn.seed = 5\n    colors = 'bcgmry'\n    components = nx.connected_components(pos)\n    for i in components:\n        component = pos.subgraph(i)\n        nx.draw_graphviz(component,\n                         node_color = colors[rn.randint(0,   len(colors)-1)], \n                         node_size = 15,\n                         edge_color = [corr_matrix[i][j]*0.5 for (i,j) in component.edges()],\n                         with_labels = True,\n                         labels = dict([(x,data[x]) for x in component.nodes()]))\n    nx.set_node_attributes(G,'pos',pos)\n    print G.node\n    pl.show()\n```\n\n\nBut instead of having the coordinates I get this :\n\n```\n{0: {'pos': <networkx.classes.graph.Graph object at 0x10513ea50>}, 1: {'pos': <networkx.classes.graph.Graph object at 0x10513ea50>}, 2: {'pos': <networkx.classes.graph.Graph object at 0x10513ea50>}, 3: {'pos': <networkx.classes.graph.Graph object at 0x10513ea50>}, 4: {'pos': <networkx.classes.graph.Graph object at 0x10513ea50>}, 5: {'pos': <networkx.classes.graph.Graph object at 0x10513ea50>}}```\n\n\nDo you know how I can change the code to have the coordinates ?\n\nThank you.\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Python package implementing Ant Colony Optimization for Minimum Steiner Tree or Minimum-Spanning-Tree in graphs\r\n                \r\nAs mentioned in the title I am looking for a python implementation of the Ant Colony Optimization (ACO) algorithm to solve the Minimum Steiner Tree problem in graphs or the minimum-spanning-tree problem. I can't seem to find any publicly available packages for minimum trees, let alone minimum steiner trees on GitHub, PyPI, etc. as most ACO packages only solve the Traveling Salesman problem (e.g ACOpy, scikit-opt, swarmlib, and PyGMO). Can anyone give a recommendation?\nI have a cost matrix of a connected but not complete graph as input as well as a 1D-array defining which of the nodes are terminals. Best case would be a package that uses networkx for graph representation.\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Prims Algorithm for Minimum Spanning Tree Analysis\r\n                \r\nAlgorithm:\n\n\nGraph:\n\n\n(Note: Missing edge weight, (T, Y, 8))\n\nBefore the first iteration:\n\nThe min priority Queue(min key at start)\n\nQ = [(S, 0), (T, ∞), (X, ∞), (Y, ∞), (Z, ∞)]\n\nIteration 1:\n\nU = S\n\nQ = [(T, 6), (Y, 7), (X, ∞), (Z, ∞)]\n\nUpdates Keys of T and Y\n\nIteration 2:\n\nU = T\n\nQ = [(Z, -4), (X, 5), (Y, 7)]\n\nUpdates Keys of X, Y, Z\n\nIteration 3:\n\nU = Z\n\nQ = [(X, 5), (Y, 7)]\n\nNo updates\n\nIteration 4:\n\nU = X\n\nQ = [(Y, 7)]\n\nNo updates\n\nIteration 5:\n\nU = Y\n\nQ = []\n\nNo updates\n\nQueue empty, loop terminates\n\nWe have the following edges in our minimum spanning tree:\n\n(S, T, 6), (T, Z, 5), (T, Z, -4), (S, Y, 7)\n\nCost = 6 + 5 - 4 + 7 = 14\n\nThis is obviously not a MST because we have other trees with lesser cost,\n\n(S, Y, 7), (Y, X, -3), (X, T -2), (T, Z, -4)\n\nCost = 7 - 3 - 2 - 4 = -2\n\nPlease help me identify where I have gone wrong.\n\nFor reference:\n(Please ignore the red edges)\n\nIteration 1:\n\n\nIteration 2:\n\n\nIteration 3:\n\n\nIteration 4:\n\n\nIteration 5:\n\n    ", "Answer": "\r\nIn computer science, Prim's algorithm is a greedy algorithm that finds a minimum \nspanning tree for a weighted undirected graph.\n\nSource: https://en.wikipedia.org/wiki/Minimum_spanning_tree\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Finding Minimum Spanning Tree (MST) in graph?\r\n                \r\nGiven an Undirected graph ```\nG```\n with with weight on its edges and 2 ```\ndifferent```\n minimal spanning trees: T, T'\nThen I want to prove the following:\n\nFor every edge ```\ne```\n in T that's not in T', there is an edge ```\ne'```\n in T'\nthat's not in T such that if we replace ```\ne```\n with ```\ne'```\n in T (let's call\nit T_new) then it's still a minimal spanning tree of ```\nG```\n.\n\nI think I am too close for finding the right algorithm but stuck a little:\n\nI have proved that ```\nweight(e)```\n must be exactly equal to ```\nweight(e')```\n.\n\nSince T is a tree, deleting e will result in 2 separated components, then for T_new to be a tree it must use one of the edges connecting two vertices from those different components.\n\n\nBut, I wasn't able to know which edge ```\ne'```\n exactly will work. Plus I wasn't able to prove that always there is such an edge (I just found some requirements for ```\ne'```\n that is must satisfy).\nSome notes: I know Kruskal algorithm, and familiar with an algorithm in which we can paint some edges in yellow and request it to generate minimal spanning trees with maximum yellow edges (In other words from all found minimal spanning trees return the one with maximum number of yellow edges)\n    ", "Answer": "\r\nLet ```\nT1```\n and ```\nT2```\n be the two connected components of ```\nT \\ {e}```\n. Consider the path ```\nP```\n joining the endpoints of ```\ne```\n in ```\nT'```\n. Since ```\ne```\n connects ```\nT1```\n and ```\nT2```\n, so does ```\nP```\n, and therefore there exists an edge ```\ne'```\n in ```\nP```\n that connects ```\nT1```\n and ```\nT2```\n. The edge ```\ne'```\n cannot be lighter than ```\ne```\n, or else ```\nT```\n would not be minimum (```\nT \\ {e} U {e'}```\n). The edge ```\ne'```\n cannot be heavier than ```\ne```\n, or else ```\nT'```\n would not be minimum (```\nT' \\ {e'} U {e}```\n).\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum spanning tree for pairs of adjacent edges\r\n                \r\nFor some graph, there is a cost associated with each pair of adjacent edges. I hope to find a subgraph such that every point is connected and the cost is minimised (a minimum spanning tree).\n\nFor the above example, the solution will include the edges AB, BC and CD, but not DA, avoiding the expensive CDA and DAB triplets, and getting a score of 28 (weight of ABC + BCD).\nTo motivate this question, let's imagine that we're designing a road network between places, and whenever a car turns around a sharp bend it slows down. Creating the ideal network, one with a small number of sharp bends, may benefit from us taking node triplets into account.\nThe graphs I intend to apply this algorithm to will have 5,000 to 20,000 nodes, and 15,000 to 80,000 edges. Presumably, the function will be of this type or similar:\n```\n(\n  nodes: [T],\n  edges: [(int, int)],\n  distance: (a: T, b: T, c: T) => float\n) => [(int, int)]\n```\n\nWhere ```\nb```\n is connected to both ```\na```\n and ```\nc```\n, but ```\na```\n and ```\nc```\n are not necessarily connected.\nWhat algorithm solves this problem?\nThank you for any help you may give.\n    ", "Answer": "\r\nThe quadratic objective feels like enough leeway to construct gadgets for an NP-hardness reduction, though I have no proof at this time.\nSince your graph is sparse, I’m hoping that the max degree is small, especially given your comment about road networks. I’d suggest the following integer programming formulation:\n\nVariables: for each edge {v, w}, let there be a 0-1 variable x(v, w) that is 1 if {v, w} belongs to the spanning tree and 0 otherwise. Also, for each vertex v and each nonempty subset S of edges incident to e, let there be a 0-1 variable y(v, S) that is 1 if the subset of edges incident to e in the tree is S and 0 otherwise.\n\nObjective: minimize ∑v,S ∑{u,w}⊆S distance(u, v, w) y(v, S).\n\nInitial constraints: we require that ∑v,S y(v, S) = 1, that is, each vertex has to choose exactly one neighborhood in the tree. We also require for each edge {v, w} that ∑v,S∋w y(v, S) = x(v, w), that is, the neighborhood that v chooses has to be consistent with whether the edge exists.\n\nConnectivity constraints: right now nothing forces the solver to choose any edges at all. It’s possible to formulate connectivity constraints statically, but instead I’d recommend the following approach. Run the solver with the constraints so far and compute its connected components. If there’s exactly one component, great, it’s the optimal solution. Otherwise, for each component C, require that ∑{v,w}∈E(C,V∖C) x(v, w) ≥ 1 – that is, the tree contains at least one edge with one endpoint in C and one endpoint not in C – and try again.\n\n\nI usually use OR-Tools because it’s the preferred library where I work, but you have many options.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Loop for minimum spanning tree does not work\r\n                \r\nwe as 3 friends try to solve minimum spanning tree with coflicts problem using r. In solving this question, we read files in .txt format that contain for ex.\n\"1 2 5\n2 4 6\" etc. which indicates from node 1 to 2, there exists an edge with weight 5 and\n\"1 2 2 4\" etc. which indicates there's a conflict relationship between the edges 1-2 and 2-4. To continue, we have to form an nxn conflict matrix in which we will store 0's if there exist no conflict relation between the edges or 1 if there exist a conflict relation. For this purpose, we developed a 3-for loop for(i in 1:dim(edges_read)[1]){\n```\nfor(i in 1:dim(edges_read)[1]){\n  for(k in 1:dim(edges_read)[1]){\n    for(t in 1:dim(conflicts)[1]){\n      if(all(conflicts[t,] == c(edges_read[i,1], edges_read[i,2],\n                                  edges_read[k,1], edges_read[k,2]) )){\n        conflictmatrix[i,k] <- 1\n      }\n    }\n  }\n}\n```\n\nHowever, R cannot get us a solution and this for loops take very long times. How can we solve this situation? Thanks for further assistance\n    ", "Answer": "\r\nAs you have discovered, ```\nfor()```\n loops are not fast in R. There are faster approaches, but it's hard to provide examples without data. Please use something like ```\ndput(edges_read)```\n and ```\ndput(conflicts)```\n to provide a small example of the data.\nAs one example, you could implement the for loops in the Rcpp package for speed improvement. Based on the code in your question, you could re-implement the 3-loop code sort of like this:\n```\nRcpp::cppFunction('NumericVector MSTC_nxn_Cpp(NumericMatrix edges_read, NumericMatrix conflicts){\nint n = edges_read.nrow(); //output matrix size (adjust to what you need)\nint m = conflicts.nrow();  //output matrix size (adjust to what you need)\nNumericMatrix conflictmatrix( n , m ); //the output matrix \nfor(int i=0;i<n;i++){ //your i loop\n  for(int k=0;k<n;k++){ // your k loop\n  double te = edges_read( i, 0 ); //same as edges_read[i,1]\n  double tf = edges_read( i, 1 ); //same as edges_read[i,2]\n  double tg = edges_read( k, 0 ); //same as edges_read[k,1]\n  double th = edges_read( k, 1 ); //same as edges_read[k,2]\n  NumericVector w =  NumericVector::create(te,tf,tg,th); //this could probably be more simple\n    for(int t=0;t<m;t++){   //your t loop\n        NumericVector v = conflicts( t , _ ); // same as conflicts[t,]\n        LogicalVector r;   //vector for checking if conflicts and edges are the same\n        for(int p=0; p<4; p++){  //loop to check logic \n          r[p]=v[p]==w[p];  //True / False stored\n        };\n        int q = r.size();\n  for (int ii = 0; ii < q; ++ii) {  //similar to all() This code could be simplified!\n    if (!r[ii]) {false;}\n  else{conflictmatrix[i,k] = 1;}}\n  }}}\n  return conflictmatrix;  //your output\n}')\n\n#Then run the function\nMSTC_nxn_Cpp(edges_read, conflicts )\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Using a minimum spanning tree algorithm\r\n                \r\nSuppose I have a weighted non-directed graph G = (V,E). Each vertex has a list of elements.\n\nWe start in a vertex root and start looking for all occurances of elements with a value x. We wish to travel the least amount of distance (in terms of edge weight) to uncover all occurances of elements with value x. \n\nThe way I think of it, a MST will contain all vertices (and hence all vertices that satisfy our condition). Therefore the algorithm to uncover all occurances can just be done by finding the shortest path from root to all other vertices (this will be done on the MST of course).\n\nEdit : \nAs Louis pointed out, the MST will not work in all cases if the root is chosen arbitrarily. However, to make things clear, the root is part of the input and therefore there will be one and only one MST possible (given that the edges have distinct weights). This spanning tree will indeed have all minimum-cost paths to all other vertices in the graph starting from the root.\n    ", "Answer": "\r\nI don't think this will work.  Consider the following example:\n\n```\n x\n |\n 3\n |\n y--3--root\n |     /\n 5    3\n |   /\n |  /\n  x\n```\n\n\nThe minimum spanning tree contains all three edges with weight 3, but this is clearly not the optimum solution.\n\nIf I understand the problem correctly, you want to find the minimum-weight tree in the graph which includes all vertices labeled x.  (That is, the correct answer would have total weight 8, and would be the two edges drawn vertically in this drawing.)  But this does not include your arbitrarily selected root at all.\n\nI am pretty confident that the following variation on Prim's algorithm would work.  Not sure if it's optimal, though.\n\nLet's say the label we are looking for is called L.\n\n\nUse an all-pairs shortest path algorithm to compute d(v, w) for all v, w.\nPick some node labeled L; call this the root.  (We can be sure that this will be in the result tree, since we are including all nodes labeled L.)\nInitialize a priority queue with the root initialized to 0.  (The priority queue will consist of vertices labeled L, and their minimum distance from any node in the tree, including vertices not labeled L.)\nWhile the priority queue is nonempty, do the following:\n\nPick out the top vertex in the queue; call it v, and its distance from the tree d.\nFor each vertex w on the path from v to the tree, v inclusive, find the nearest L-labeled node x to w, and add x to the priority queue, or update its priority.  Add w to the tree.\n\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Algorithms proof regarding minimum spanning tree, Is my answer correct?\r\n                \r\nThis is the questions, i admit this is a homework questions, i am not looking for answers, but rather i want to just know if i am going in the correct direction, and if i am not kindly point me in the correct direction.\n\nQuestion:\nShow that if no two edges in a weighted graph have the same\nweight, then the edge with least weight incident to a vertex v is included in every minimum spanning tree (MST).\n\nMy answer:\nGiven a vertex (V) and a weighted graph (G), we note that ∃ (there exists) and edge (E) associated with V, that is the least weighted edge. Note that we will have two distinct vertices that will have the same least weighted edge. This does not represent a problem for us, if one of the vertice is included in the minimum spanning tree, the other will be to. If we started to build a MST, at one instance the least weighted edge has to be included in the MST, since one (or both) of the vertex that has the least edge must be included to obtain a MST ( since the definition of a MST states that we must find the minimum path from a root to all verticies) \n\nI am not so sure if my answer is valid, do you think how i prove it is enough?\n    ", "Answer": "\r\nYour proof isn't valid, and the reason for that is that there are many imprecise statements in your proof, and some falsehoods. For example you say that \"the definition of a MST states that we must find the minimum path from a root to all verticies\", whereas the definition of an MST is that it is the spanning tree of minimum weight.\n\nYou use the fact that a \"vertex that has the least edge\" must be in the MST, but it's hard to see the relevance because every vertex appears in the MST (from the definition of spanning tree).\n\nThe skill in writing proofs is to be extremely precise in your language, and to make logical steps that follow from things you prove (or if you're applying a well-known theorem, then a good citation). It's extremely important that you know and use the exact definitions of jargon you are using (here, perhaps, \"minimal\" and \"spanning\" and \"tree\").\n\nFor this proof, as Keith says, you want to try a proof by contradiction. That is that if there is a spanning tree that doesn't contain the edge of minimal weight then you can find a spanning tree with a lower weight. Perhaps it would help to prove first how many edges a spanning tree must have, and whether every tree in the graph with that number of edges has to be a spanning tree. You should be clear what the definition of a tree is too as it will be needed in the proof: you'll take the spanning tree that doesn't contain the edge, modify it somehow, and show that it has lower weight and is still a spanning tree.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Preorder tree walk of a minimum spanning tree generated by Prim's algorithm\r\n                \r\nI'm trying to implement an approximate algorithm to solve the traveling salesman problem (TSP), which can be used when the triangle inequality holds for the edge weights. As described in Cormen et al., Introduction to Algorithms (3rd 3d.), the pseudocode is:\n\n\n\nand here is an example:\n\n\n\nWhat I'm struggling with is how to implement the preorder tree walk on the tree generated by Prim's algorithm. Since this is not a binary search tree, the pseudocode given at https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_2 seems not to apply.\n\nRather, instead of having ```\nleft```\n and ```\nright```\n attributes, the nodes have ```\nkey```\n and ```\nparent```\n attributes. Here is how they are generated in my implementation of Prim's algorithm (with a small test case):\n\n```\nimport math\nimport copy\nimport pytest\nimport pandas as pd\nfrom cached_property import cached_property\n\n\nclass Node(object):\n    def __init__(self, key=math.inf, parent=None):\n        self.key = key\n        self.parent = parent\n\n    def __lt__(self, other):\n        return self.key < other.key\n\n\nclass Graph(object):\n    def __init__(self, edges):\n        self.edges = edges\n\n    @cached_property\n    def nodes(self):\n        _nodes = set()\n        for edge in self.edges:\n            _nodes.add(edge[0])\n            _nodes.add(edge[1])\n        return {node: Node() for node in list(_nodes)}\n\n    @cached_property\n    def adj(self):\n        A = {node: [] for node in self.nodes}\n        for edge in self.edges:\n            u, v, _ = edge\n            A[u].append(v)\n            A[v].append(u)\n        return A\n\n    @cached_property\n    def w(self):\n        N = len(self.nodes)\n        none_array = [[None for _ in range(N)] for _ in range(N)]\n        df = pd.DataFrame(none_array, index=sorted(self.nodes), columns=sorted(self.nodes))\n        for edge in self.edges:\n            u, v, weight = edge\n            df.set_value(u, v, weight)\n            df.set_value(v, u, weight)\n        return df\n\n    def mst_prim(self, root):\n        r = self.nodes[root]\n        r.key = 0\n        Q = copy.copy(self.nodes)\n        while Q:\n            u = min(Q, key=Q.get)\n            u_node = Q.pop(u)\n            for v in self.adj[u]:\n                if v in Q and self.w[u][v] < self.nodes[v].key:\n                    self.nodes[v].parent = u\n                    self.nodes[v].key = self.w[u][v]\n\n\n@pytest.fixture\ndef edges_simple():\n    return [('a', 'b', 4),\n            ('a', 'h', 8),\n            ('b', 'h', 11),\n            ('h', 'i', 7),\n            ('b', 'c', 8),\n            ('h', 'g', 1),\n            ('i', 'c', 2),\n            ('i', 'g', 6),\n            ('c', 'd', 7),\n            ('g', 'f', 2),\n            ('c', 'f', 4),\n            ('d', 'f', 14),\n            ('d', 'e', 9),\n            ('f', 'e', 10)\n            ]\n\ndef test_mst_prim(edges_simple):\n    graph = Graph(edges_simple)\n    graph.mst_prim(root='a')\n    # print(\"\\n\")\n    # for u, node in graph.nodes.items():\n    #   print(u, node.__dict__)\n    assert graph.nodes['a'].parent is None\n    assert graph.nodes['i'].parent == 'c'\n    assert graph.nodes['d'].parent == 'c'\n\n\n\nif __name__ == \"__main__\":\n    # pytest.main([__file__+\"::test_mst_prim\", \"-s\"])\n    pytest.main([__file__, \"-s\"])\n```\n\n\nHow could I perform preorder tree traversal on this graph? (Note that this question is similar to pre-order traversal of a Minimum spanning tree, but I found the answer given there rather high-level).\n    ", "Answer": "\r\nI suggest you to add a new list in your ```\nNode```\n class named ```\nchildren```\n for example.\n\nAfter your ```\nPrim's```\n algorithm you can run through your obtained nodes and add them to their parent's ```\nchildren```\n. The complexity is ```\nO(n)```\n, so not a big deal. After that the ```\nDFS```\n traversal will be easy.\n\nBut again, as in the post you mentioned, you have to pick a order for your children for a ```\npreorder```\n traversal. In your case when you only have reference to your ```\nparent```\n, there's no way of knowing what is the ```\nleft-most```\n child for example.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum to Maximum spanning trees?\r\n                \r\nI have seen where one can modify classic Mininum spanning tree algorithms to find the Maximum spanning tree instead. \n\nCan an algorithm such as Kruskal's be modified to return a spanning tree that is strictly more costly than an MST, but is the next cheapest. So you can switch one of the edges in this spanning tree, you end up with an MST and vice versa.\n\nI would assume then, that there is a range of spanning trees in terms of their overall cost.\n\nMy question is simply how can I find the next cheapest spanning tree, given a graph with an MST.\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum product spanning tree with negative weights\r\n                \r\nSuppose if all the edges have positive Weights the minimum product spanning tree can be obtained by taking the ```\nlog```\n of every edge and then apply Kruskal or Prim. But if some weights are negative, we can't apply this procedure. since we need to include odd number of negative edges, and those edges must be of the maximum weight. How to do in such case?\n    ", "Answer": "\r\nI highly doubt you can modify Prims algorithm to work for this problem because negative numbers completely change it. If you manage to get a negative result then the absolute value has to be maximized which means the edges with the highest absolute values have to be used, hence trying to optimize a result found by Prims algo and taking the log(abs()) will not work, unless it is impossible to get a negative result, then this will actually return the best solution.\n\nThis makes the problem a little simpler, because we only have to look for the best negative solution and if we don't find any we use Prims with log(abs()).\n\nIf we assign each vertice a value of 1, then two vertices can be merged by creating a new vertice with all the edges of both vertices except the one connecting them and the value is the product of the values of the removed vertices and edge.\n\nBased on this we can start to simplify by merging all nodes with only one edge. Parallel to each merge step the removed edge has to be marked as used in the original graph, so that the tree can be reconstructed from the marked edges in the end.\n\nAdditionally we can merge all nodes with only positive or only negative edges removing the edge with the highest absolute value. After merging the new node can have several connections to the same node, you can discard all but the negative and positive edge with the highest absolute value (so max 2 edges to the same node). Btw. as soon as we have 2 edges to the same node (following the removal conditions above) we know a solution <= 0 has to exist.\n\nIf you end up with one node and it is negative then the problem was solved successfully, if it is positive there is no negative solution. If we have a 0 vertice we can merge the rest of the nodes in any order. More likely we end up with a highly connected graph where each node has at least one negative and one positive edge. If we have an odd number of negative vertices then we want to merge the nodes with an even number of negative edges and vice versa.\n\nAlways merge by the edge with the highest absolute value. If the resulting vertice is <= 0 then you found the best solution. Otherwise it gets complicated. You could look at all the unused edges, try to add it, see which edges can be removed to make it a tree again, only look at those with different sign and build the ratio abs(added_edge/removed_edge). Then finally do the change with the best ratio (if you found any combination with opposite signs otherwise there is no negative solution). But I am not 100% sure if this would always give the best result.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Algorithm to find minimum spanning tree when cost is given by multiplying edge weights\r\n                \r\nI was recently asked if I could find an algorithm to compute the minimum cost spanning tree of a given graph, where the total cost of the spanning tree is given by the product of the edge costs rather than by their sum. \n\nThere are several algorihms to compute the regular minium spanning tree, but I am unsure of how to tweak them for the case mentioned above. Any ideas?\n\nThank you.\n    ", "Answer": "\r\nSince log(product of edge costs) = sum (log(edge costs)), just log-transform the edge-weights, and find the minimum cost spanning tree for these weights.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Igraph calculating minimum spanning tree with weights C interface\r\n                \r\nI have been trying to calculate a minimum spanning tree using the prim method, but I have got rather confused about the way that weights are used in this context.  The suggested example program in the source documents does not appear to be correct, I don't understand why the edge betweenness needs to be calculated.\nPlease see the following program, it's designed to make a simple undirected graph.\n```\n#include <igraph.h>\nint main()\n{\n    igraph_vector_t eb, edges;\n    igraph_vector_t weights;\n    long int i;\n    igraph_t theGraph, tree;\n    struct arg {\n    int index;\n    int source;\n    int target;\n    float weight;\n    };\n    struct arg data[] = {\n    {0, 0, 1, 2.0},\n    {1, 1, 2, 3.0},\n    {2, 2, 3, 44.0},\n    {3, 3, 4, 3.0},\n    {4, 4, 1, 2.0},\n    {5, 4, 5, 9.0},\n    {6, 4, 6, 3.0},\n    {6, 6, 5, 7.0}\n    };\n\n    int nargs = sizeof(data) / sizeof(struct arg);\n    igraph_empty(&theGraph, nargs, IGRAPH_UNDIRECTED);\n\n    igraph_vector_init(&weights, nargs);\n    // create graph\n    for (i = 0; i < nargs; i++) {\n    igraph_add_edge(&theGraph, data[i].source, data[i].target);\n    // Add an weight per entry\n    igraph_vector_set(&weights, i, data[i].weight);\n    }\n\n    igraph_vector_init(&eb, igraph_ecount(&theGraph));\n    igraph_edge_betweenness(&theGraph, &eb, IGRAPH_UNDIRECTED, &weights);\n    for (i = 0; i < igraph_vector_size(&eb); i++) {\n    VECTOR(eb)[i] = -VECTOR(eb)[i];\n    }\n\n    igraph_minimum_spanning_tree_prim(&theGraph, &tree, &eb);\n    igraph_write_graph_edgelist(&tree, stdout);\n\n    igraph_vector_init(&edges, 0);\n    igraph_minimum_spanning_tree(&theGraph, &edges, &eb);\n    igraph_vector_print(&edges);\n    igraph_vector_destroy(&edges);\n\n    igraph_destroy(&tree);\n    igraph_destroy(&theGraph);\n    igraph_vector_destroy(&eb);\n    return 0;\n}\n```\n\nCan anybody see anything that is wrong with this program it's designed to build a simple graph with what I hope is the correct way to use a weight argument.  One value per edge between a source and a target.\n    ", "Answer": "\r\nThe section about adding an edge betweenness comes from the original code example for the use of prim. It just needs to be removed for the program to work correctly using a user supply value of weight.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "What algorithms are used to find a minimum spanning forest?\r\n                \r\nAs Wikipedia says:\n\n\n  Minimum spanning forest is a union of the minimum spanning trees for\n  its connected components.\n\n\nFor finding minimum spanning tree we can use for example Prim's algorithm, Kruskal's algorithm, or Borůvka's algorithm.\n\nWhat algorithm can we use to find minimum spanning forest?\n    ", "Answer": "\r\nI don't see how you need any other algorithm than you use for trees - you may need to adapt them a bit.\nIf you use for example Kruskal's algorithm you get all cheapest edges in every sub graph/minimum spanning tree of your (now also minimum spanning) forest. Or you can use Prim's algorithm and if your iteration stops, restart it with a node that is not connected yet (i.e. with another tree).\n\nSo my answer in one sentence: \"The algorithms used to find a minimum spanning forest are the same ones that are used to find a minimum spanning tree - in some cases with adaptions and in some cases without them.\"\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "R iGraph - how to color edges used in minimum spanning tree\r\n                \r\nI would like to plot the solution of the minimum spanning tree(MST) by coloring the edges used in the solution.\n```\nlibrary(\"igraph\")\nA = matrix(c(0, 23, 11, 5, 26, 22,23, 0, 9, 13, 30, 18,11, 9, 0, 9, 7, 29,5, 13, 9, 0, 15, 5,26, 30, 7, 15, 0, 9,22, 18, 29, 5, 9, 0), \n           nrow= 6 , ncol= 6  ,byrow = TRUE)  \ng  <- graph.adjacency(A,weighted=TRUE, mode = c(\"undirected\"))\nplot(g,edge.label=round(E(g)$weight, 3))\n```\n\n\nIf I use ```\nmst()```\n package, I get the following solution\n```\nmst(g)\nIGRAPH ac800ea U-W- 6 5 -- \n+ attr: weight (e/n)\n+ edges from ac800ea:\n[1] 1--4 2--3 3--5 4--6 5--6\n```\n\nI would like to plot ```\ng```\n and color the edges used in the solution provided above. For instance, I can use the following code, however, it only prints the edges used. I would like to print all edges while distinguishing the edges used in the MST.\n```\nplot(mst(g),layout=layout.reingold.tilford,edge.label=E(mst(g))$weight)\n```\n\n\nI tried ```\nE(g)$color <- ifelse(E(g) %in% mst(g), \"black\", \"red\")```\n however it did not work properly.\n    ", "Answer": "\r\nYou can try the code below\n```\nleft_join(\n  get.data.frame(g),\n  cbind(get.data.frame(mst(g)), color = \"black\")\n) %>%\n  mutate(color = replace_na(color, \"red\")) %>%\n  graph_from_data_frame(directed = FALSE) %>%\n  plot(\n    edge.label = E(.)$weight,\n    edge.color = E(.)$color\n  )\n```\n\nwhich gives\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "R iGraph - how to color edges used in minimum spanning tree\r\n                \r\nI would like to plot the solution of the minimum spanning tree(MST) by coloring the edges used in the solution.\n```\nlibrary(\"igraph\")\nA = matrix(c(0, 23, 11, 5, 26, 22,23, 0, 9, 13, 30, 18,11, 9, 0, 9, 7, 29,5, 13, 9, 0, 15, 5,26, 30, 7, 15, 0, 9,22, 18, 29, 5, 9, 0), \n           nrow= 6 , ncol= 6  ,byrow = TRUE)  \ng  <- graph.adjacency(A,weighted=TRUE, mode = c(\"undirected\"))\nplot(g,edge.label=round(E(g)$weight, 3))\n```\n\n\nIf I use ```\nmst()```\n package, I get the following solution\n```\nmst(g)\nIGRAPH ac800ea U-W- 6 5 -- \n+ attr: weight (e/n)\n+ edges from ac800ea:\n[1] 1--4 2--3 3--5 4--6 5--6\n```\n\nI would like to plot ```\ng```\n and color the edges used in the solution provided above. For instance, I can use the following code, however, it only prints the edges used. I would like to print all edges while distinguishing the edges used in the MST.\n```\nplot(mst(g),layout=layout.reingold.tilford,edge.label=E(mst(g))$weight)\n```\n\n\nI tried ```\nE(g)$color <- ifelse(E(g) %in% mst(g), \"black\", \"red\")```\n however it did not work properly.\n    ", "Answer": "\r\nYou can try the code below\n```\nleft_join(\n  get.data.frame(g),\n  cbind(get.data.frame(mst(g)), color = \"black\")\n) %>%\n  mutate(color = replace_na(color, \"red\")) %>%\n  graph_from_data_frame(directed = FALSE) %>%\n  plot(\n    edge.label = E(.)$weight,\n    edge.color = E(.)$color\n  )\n```\n\nwhich gives\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Given a graph find a spanning tree which is not minimum\r\n                \r\nHow to find a spanning tree which is not minimum in a graph(if possiblr)\n    ", "Answer": "\r\nKruskal algorithm finds the minimum spanning tree ordering all the edges by weight, choosing them from the lightest to the heaviest and adding them to the solution only if they don't form a cycle. When you reach a number of edges equal to the number of vertexes minus one, you have the minimum spanning tree.\n\nTo obtain a spanning tree that is not minimum you can just apply the same algorithm without pre-ordering the edges' list, or shuffling randomly the list before starting. \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to find path between two nodes on a minimum spanning tree\r\n                \r\nI have minimum spanning tree and I have created list of adjacency. With help of this list of adjacency I run DFS algorithm and it works correctly.\nProblem is that I want to get path between two nodes.\nExample Tree:\n\nFor example I want to get path from 4 to 6\nCurrent output: 4-3-1-7-2-5-6\nWanted output: 4-3-5-6\nCode:\n```\nvoid Graph::DFS(int source, int destination)\n{\n    Visited[source - 1] = true;\n\n    vector<pair<int,int>> adjList = MSTAdjacencyLists[source - 1]; //first is vertice, second is weight\n\n    cout << source << \"-\";\n   \n    for (int i = 0; i < adjList.size(); i++)\n    {\n        if (adjList[i].first == destination)\n        {\n            cout << adjList[i].first <<\"\\nFound!!\" << endl;\n            break;\n        }\n\n        if (Visited[adjList[i].first-1] == false)\n        {\n            DFS(adjList[i].first, destination);\n        }\n    }\n}\n```\n\nI have read that DFS can be helpful but maybe there are better methods?\n    ", "Answer": "\r\nNot tested cos no small test availble\n```\nbool Graph::DFS(int source, int destination) <<<<====== bool return\n{\n    Visited[source - 1] = true;\n\n    vector<pair<int,int>> adjList = MSTAdjacencyLists[source - 1]; //first is vertice, second is weight\n\n    \n   \n    for (int i = 0; i < adjList.size(); i++)\n    {\n        if (adjList[i].first == destination)\n        {\n            cout << adjList[i].first <<\"\\nFound!!\" << endl;\n            return true;\n        }\n\n        if (Visited[adjList[i].first-1] == false)\n        {\n            if(DFS(adjList[i].first, destination))\n            {\n                cout << source << \"-\";\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```\n\nie DFS indicates whether it found the destination or not, when unwinding the recursion print the path that returned true\nNot sure if we need the first 'cout << source' that I moved.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to find a minimum weight spanning tree for the following graph using prims algorithm\r\n                \r\n\n\nPrim’s Algorithm\n\nAn algorithm for finding a minimum spanning tree.\n\n\nBegin by choosing any edge with smallest weight, putting it into the spanning tree.\nSuccessively add to the tree edges of minimum weight that are incident to a vertex already in the tree, never forming a simple circuit with those edges already in the tree.\nStop when n − 1 edges have been added.\n\n\nI know that you must start at node A. Also by giving a list of the\norder in which nodes and/or edges are added.\n\nBut im not sure on the exact steps to find the minimum weight spanning tree.\n    ", "Answer": "\r\nSelect all unvisited edges from A\n\nA - B = 2\n\nA - E = 2\n\nA - F = 5\n\nFind cheapest : A - B\n\nSelect all unvisited edges from A and B\n\nA - E = 2\n\nA - F = 5\n\nB - C = 1\n\nB - E = 2\n\nB - F = 4\n\nFind cheapest : B - C\n\nSelect all unvisited edges from A, B and C\n\nA - E = 2\n\nA - F = 5\n\nB - E = 2\n\nB - F = 4\n\nC - D = 4\n\nC - E = 1\n\nFind cheapest : C - E\n\nSelect all unvisited edges from A, B, C and E\n\nA - E = 2\n\nA - F = 5\n\nB - E = 2\n\nB - F = 4\n\nC - D = 4\n\nE - D = 3\n\nE - F = 1\n\nFind cheapest : E - F\n\nNode D is the only unvisited node, so it can either be; D -E OR C - D.\n\nCheapest = E - D : 3\n\nNow all nodes have been visited, remove unused edges \n\nMinimum weight spanning tree would look like this\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Good Java graph algorithm library? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Questions asking us to recommend or find a tool, library or favorite off-site resource are off-topic for Stack Overflow as they tend to attract opinionated answers and spam. Instead, describe the problem and what has been done so far to solve it.\r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n\r\n\r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                This question's answers are a community effort. Edit existing answers to improve this post. It is not currently accepting new answers or interactions.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n\r\n\r\n    \r\n\r\nHas anyone had good experiences with any Java libraries for Graph algorithms. I've tried JGraph and found it ok, and there are a lot of different ones in google. Are there any that people are actually using successfully in production code or would recommend?\n\nTo clarify, I'm not looking for a library that produces graphs/charts, I'm looking for one that helps with Graph algorithms, eg minimum spanning tree, Kruskal's algorithm Nodes, Edges, etc. Ideally one with some good algorithms/data structures in a nice Java OO API.\n    ", "Answer": "\r\nIf you were using JGraph, you should give a try to JGraphT which is designed for algorithms.  One of its features is visualization using the JGraph library. It's still developed, but pretty stable. I analyzed the complexity of JGraphT algorithms some time ago.  Some of them aren't the quickest, but if you're going to implement them on your own and need to display your graph, then it might be the best choice.  I really liked using its API, when I quickly had to write an app that was working on graph and displaying it later.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Network Design: Why is Minimum Spanning Tree so widely used in Network Design\r\n                \r\nRecently I am really interested in Network Design. Right now I am reading about Minimum Spanning Tree. However I cannot find more than two reasons to use it:\n- minimize total cost of cable used to connect all network utilities,\n- minimize total latency.\n\nAre there any more reasons to use it? What else can we minimize (optimize).\n\nThx in advance for all answers.\n    ", "Answer": "\r\napart from network design and analysis, mst feature most prominently in following application domains:\n\n\nclustering ( statistics; specifically taxonomy, genetics, linguistics, machine learning )\nrouting ( approximating shortest tours )\nsparse representations ( image recognition, handwriting analysis )\n\n\nfor more concrete sample applications consult google.\n\nsome arbitrary references:\n\n\nMurali\ng4g survey\nan application in genetics\n\n\nand some related discussion on so:\n\n\nPractical uses of different data structures\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum Spanning Tree given that a specific vertex v should have a degree(v)=k\r\n                \r\nLet's say we have an undirected graph G(E,V) and a given vertex v . I want to find a Minimum Spanning Tree T  , so that degree(v)=k in T.\n\n\nI have considered finding all the adjacent vertices of v in G.\nfind q (q=degree(v))  Minimum Spanning Trees  (1 starting from every vertex adjacent to v) using a modified Kruskal . \nConvert those MSTs into supervertices ,and now I have v and degree(v) MSTs\nNow connect all the above ,using a modified kruskal in order to make sure that degree(v)=k\n\n\nCan someone confirm that my algorithm is going to find the right result? maybe suggest a different approach ?\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum spanning tree with two edges tied\r\n                \r\nI'd like to solve a harder version of the minimum spanning tree problem.\n\nThere are ```\nN```\n vertices. Also there are ```\n2M```\n edges numbered by 1, 2, .., ```\n2M```\n. The graph is connected, undirected, and weighted. I'd like to choose some edges to make the graph still connected and make the total cost as small as possible. There is one restriction: an edge numbered by ```\n2k```\n and an edge numbered by ```\n2k-1```\n are tied, so both should be chosen or both should not be chosen. So, if I want to choose edge 3, I must choose edge 4 too.\n\nSo, what is the minimum total cost to make the graph connected?\n\nMy thoughts:\n\n\nLet's call two edges ```\n2k```\n and ```\n2k+1```\n a edge set.\nLet's call an edge valid if it merges two different components.\nLet's call an edge set good if both of the edges are valid.\n\n\nFirst add exactly ```\nm```\n edge sets which are good in increasing order of cost. Then iterate all the edge sets in increasing order of cost, and add the set if at least one edge is valid. ```\nm```\n should be iterated from 0 to ```\nM```\n.\nRun an kruskal algorithm with some variation: The cost of an edge ```\ne```\n varies.\n\n\nIf an edge set which contains ```\ne```\n is good, the cost is: (the cost of the edge set) / 2.\nOtherwise, the cost is: (the cost of the edge set).\nI cannot prove whether kruskal algorithm is correct even if the cost changes.\n\n\n\n\nSorry for the poor English, but I'd like to solve this problem. Is it NP-hard or something, or is there a good solution? :D Thanks to you in advance!\n    ", "Answer": "\r\nAs I speculated earlier, this problem is NP-hard. I'm not sure about inapproximability; there's a very simple 2-approximation (split each pair in half, retaining the whole cost for both halves, and run your favorite vanilla MST algorithm).\n\nGiven an algorithm for this problem, we can solve the NP-hard Hamilton cycle problem as follows.\n\nLet G = (V, E) be the instance of Hamilton cycle. Clone all of the other vertices, denoting the clone of vi by vi'. We duplicate each edge e = {vi, vj} (making a multigraph; we can do this reduction with simple graphs at the cost of clarity), and, letting v0 be an arbitrary original vertex, we pair one copy with {v0, vi'} and the other with {v0, vj'}.\n\nNo MST can use fewer than n pairs, one to connect each cloned vertex to v0. The interesting thing is that the other halves of the pairs of a candidate with n pairs like this can be interpreted as an oriented subgraph of G where each vertex has out-degree 1 (use the index in the cloned bit as the tail). This graph connects the original vertices if and only if it's a Hamilton cycle on them.\n\n\n\nThere are various ways to apply integer programming. Here's a simple one and a more complicated one. First we formulate a binary variable ```\nx_i```\n for each ```\ni```\n that is ```\n1```\n if edge pair ```\n2i-1, 2i```\n is chosen. The problem template looks like\n\n```\nminimize sum_i w_i x_i (drop the w_i if the problem is unweighted)\nsubject to\n<connectivity>\nfor all i, x_i in {0, 1}.\n```\n\n\nOf course I have left out the interesting constraints :). One way to enforce connectivity is to solve this formulation with no constraints at first, then examine the solution. If it's connected, then great -- we're done. Otherwise, find a set of vertices ```\nS```\n such that there are no edges between ```\nS```\n and its complement, and add a constraint\n\n```\nsum_{i such that x_i connects S with its complement} x_i >= 1\n```\n\n\nand repeat.\n\nAnother way is to generate constraints like this inside of the solver working on the linear relaxation of the integer program. Usually MIP libraries have a feature that allows this. The fractional problem has fractional connectivity, however, which means finding min cuts to check feasibility. I would expect this approach to be faster, but I must apologize as I don't have the energy to describe it detail.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "What's the difference between Minimmum Spanning Tree and Travelling Salesman Problems\r\n                \r\nCan we solve the Traveling Salesman Problem by finding the Minimum Spanning Tree?\n    ", "Answer": "\r\nThe Minimum Spanning Tree problem asks you to build a tree that connects all cities and has minimum total weight, while the Travelling Salesman Problem asks you to find a trip that visits all cities with minimum total weight (and possibly coming back to your starting point). \n\nIf you're having trouble seeing the difference, in MST, you need to find a minimum weight tree in a weighted graph, while in TSP you need to find a minimum weight path (or cycle / circuit). Does that help?\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Bug in finding minimum spanning tree using Kruskal's algorithm\r\n                \r\nI write the code from adding vertex into a graph and update the weight of edge and then find the minimum spanning tree. I think that I have done it but there seems to be some error in it but I cannot find it out.The  system using Valgrind and indicate that \"invalid write of size 4\" and \"invalid read of size 4 \" in the call of MST, but I think it work fine.The whole error of Valgrind is https://docs.google.com/document/d/1_AhOdDkyZGNTBVHspyGtnSQoU1tYkm0nVA5UABmKljI/edit?usp=sharing\n\nThe following code is called by like \n\n```\nCreateNewGraph();\nAddEdge(1, 2, 10);\nAddEdge(2, 4, 10);\nAddEdge(1, 3, 100);\nAddEdge(3, 4, 10);\nGetMST(mst_edges);\n```\n\n\nand the result will be (1,2) (2,4) (3,4).\n\nand call\n\n```\nUpdateEdge(1, 3, 0.1);\nGetMST(mst_edges);\n```\n\n\nand the result will be (1,2) (1,3) (2,4).\n\nIt is sent to a system to execute and it will be called like above but in a lot of time cycle above.\n\n```\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\nnamespace HOMEWORK{\n    class Edge{\n        public:\n            Edge(unsigned int, unsigned int, double);\n            unsigned int u;\n            unsigned int v;\n            double w;\n        friend bool operator<(const Edge& a, const Edge& b){\n         return a.w < b.w;\n        }\n    };\n    Edge::Edge(unsigned int source = 0, unsigned int destination = 0, double weight = 0.0){\n        u = source;\n        v = destination;\n        w = weight;\n    }\n\n    vector<Edge> graph(0);\n    vector<int> parent(0);\n\n    int findset(int x){\n        if(x != parent[x])parent[x] = findset(parent[x]);\n        return parent[x];\n    }\n\n    void CreateNewGraph(){\n        graph.clear();\n        parent.clear();\n    }\n\n    void AddEdge(unsigned int u, unsigned int v, double w){\n        graph.push_back(Edge(u,v,w));\n    }\n\n    void UpdateEdge(unsigned int u, unsigned int v, double w){\n        for(int i = 0; i < graph.size(); i ++){\n            if(graph[i].u == u && graph[i].v == v)graph[i] = Edge(u,v,w);\n        }\n    }\n\n    void GetMST(vector<pair<unsigned int, unsigned int> >& mst_edges){\n        mst_edges.clear();\n        parent.clear();\n        int e = graph.size();\n        for(int i = 0; i <= e + 1; i ++)parent.push_back(i);\n        stable_sort(graph.begin(), graph.end());\n        for(int i = 0; i < e; i ++){\n            //cout << graph[i].u << \":\" << graph[i].v << \":\" << graph[i].w << \":\" << parent[i + 1] << endl;\n            int pu = findset(graph[i].u);\n            int pv = findset(graph[i].v);\n            if(pu != pv){\n                parent[pu] = parent[pv];\n                mst_edges.push_back(make_pair(graph[i].u, graph[i].v));\n            }\n        }\n    }\n\n    void Init(){\n    }\n\n    void Cleanup(){\n    }\n}\n```\n\n    ", "Answer": "\r\nI think the issue is how you're setting up parent pointers.  Note that you've set up ```\nparents```\n as \n\n```\nfor(int i = 0; i <= e + 1; i ++) parent.push_back(i);\n```\n\n\nThis creates one entry in the ```\nparent```\n array for each edge in the graph, plus one extra one.  However, each node has a parent, not each edge, and the number of nodes in a graph can be bigger than the number of edges plus one.  For example, suppose you're given this set of edges:\n\n```\n1  2\n3  4\n5  6\n```\n\n\nThis graph clearly has six nodes in it (numbered 1 ... 6), but your code would only make space for 4 entries in ```\nparents```\n.\n\nTry changing your code so that you set ```\nparents```\n to be the proper size, probably by finding the maximum and minimum numbered node in the list of edges and sizing the array appropriately.  Alternatively, consider using a ```\nstd::unordered_map<int, int>```\n, which is more flexible if the vertex numbers don't contiguously begin at 0.\n\nHope this helps!\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "R: depth minimum spanning tree\r\n                \r\nIn question R: tree with overlapping strings I've asked to make a tree that looks like:    \n\n```\nV621   --> V62123  --> V6212355\n    --> V621335 --> V62133526\n    --> V6216 --> V62162\n    --> V621213452\n    --> V62126324\n```\n\n\nIt works with the ```\nminimum spanning tree```\n from the package ```\nigraph```\n, But now I want to determine the depth of each element of that tree. How coudl I do this?\n    ", "Answer": "\r\nIf we borrow all the relevant code from the previous answer...\n\n```\ndf <- read.table(text='verkoop          V621  \nverkoopcode      V62123  \nverkoopcodenaam  V6212355  \nverkoopdatum     V621335  \nverkoopdatumchar V62133526  \nverkooppr        V6216  \nverkoopprijs     V62162  \nverkoopsafdeling V621213452  \nverkoopsartikel  V62126324')\n# use igraph package\nrequire(igraph)\n# create adjacency matrix \nadj <- nchar(sapply(df$V1, gsub, x=df$V1, replacement=''))\nadj[!sapply(df$V1, grepl, x=df$V1)] <- 0\n# name adjecency matrix \ncolnames(adj) <- df$V2\n# original graph\ngr <- graph.adjacency(adj, mode='directed', weighted=TRUE)\nlayout(matrix(1:2, ncol=2))\nplot(gr)\n# minimum spanning tree \nmst <- minimum.spanning.tree(gr)\n```\n\n\nYou can get the depth with\n\n```\nshortest.paths(mst, to=\"V621\", weights=rep(1, ecount(mst)))\n#            V621\n# V621          0\n# V62123        1\n# V6212355      2\n# V621335       1\n# V62133526     2\n# V6216         1\n# V62162        2\n# V621213452    1\n# V62126324     1\n```\n\n\nNote that we have to adjust the weights because by default ```\ngraph.adjacency```\n used the values in ```\nadj```\n as weights for the edges and really we only want to count each edge as one. You could have also done\n\n```\ngr <- graph.adjacency(adj>0, mode='directed', weighted=TRUE)\nmst <- minimum.spanning.tree(gr)\nshortest.paths(mst, to=\"V621\")\n```\n\n\nto set all the default weights to 1.\n\nThis assumes you know taht \"V621\" is the root node. If you didn't know which was the root node, you could find it with\n\n```\ndx <-degree(mst, mode=\"out\")\nroot <- names(dx)[dx==0]\nshortest.paths(mst, to=root, weights=rep(1, ecount(mst)))\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to rewire edges in minimum spanning tree (R)?\r\n                \r\nI have coordinates of points (file .csv). I have read the data and calculated distances between all pairs of points, then based on the adjacency matrix the spatialize graph was created.\nIt is the undirected, positive-edge-weight full graph.\n\n```\nlibrary(igraph)\n\ndf0 <- read.csv(file=\"vpoints.csv\", header=TRUE, sep=\",\")\nn <- nrow(df0)\nd <- matrix(0, n, n) \n## Find a distance between all nodes\nfor (i in 1:n) {\n for (j in 1:n) {\n        d[i,j] = ((df0$cx[i] - df0$cx[j])^2 + \n             (df0$cy[i] - df0$cy[j])^2 )^(1/2) \n   }# forj \n} #for_i\n\ng1 <- graph.adjacency(d, weighted=TRUE, mode=\"undirected\")\nV(g1)$name <- gsub(\"path\",\"\", df0$from)\n\n## Find a minimum spanning tree\nmst <- minimum.spanning.tree(g1)\n\nmylayout<-as.matrix(cbind(df0$cx,df0$cy))\nplot(mst, layout=mylayout, \n           vertex.label.cex=.5, \n           edge.label=round(E(g1)$weight,0),\n           edge.label.cex=.5)\n```\n\n\nI need to build a table of shortest paths between the specific pairs of nodes. Most of edges are imposible.\n\n\n\nI have found a minimum spanning tree (MST) covering all vertices of graph. But this tree includes some of imposible edges and some posible edges are ommitted. \n\nCould some one please help me how to rewire edges? \n\nIn the 1st case I need to rewire one end of edge (form the node \"4048\" to the node \"4016\"). In the 2nd case I need to delete the egde between the node \"4020\" and the node \"4024\", and add the edge between the node \"4018\" and the node \"4022\".\n\nUpdate: 1) I think in my local task I can split the set of nodes into two separated sets before creation the graph model. Then I can apply an algorithm (Prim's algorithm as default algorithm) in order to find the MST on the first set of nodes. Finally I can connect the nodes from the second set to the MST with the for-loop. I such approach I need assign a new binary attribute to the node (for example, \"0\" -- first set, \"1\" -- second set). First set is the set of intermediate nodes, second one includes the end-point nodes. The connection criteria of a end-point node to MST is minimum of the Euclid distance from a end-point node to a node in the tree.\n\n2) Another idea is: to analyse the opportunity to move from node \"А\" to node \"В\", and set distance d[i,j]=0, else calculate d[i, j]\n\n```\n## Find a distance between nodes\nfor (i in 1:n) {\n for (j in 1:n) {\n # if (impossible) then d[i,j]=0  else\n        d[i,j] = ((df0$cx[i] - df0$cx[j])^2 + \n             (df0$cy[i] - df0$cy[j])^2 )^(1/2) \n  }# forj \n} #for_i\n```\n\n\nThanks. \n    ", "Answer": "\r\nI have applied the mix of 1st and 2nd idea. The binary category (0/1) was added for each node: 0 -- intermediate node, 1 -- end-point node. Then the distance d[i,j] was put on the maximum value. \n\n```\nmax_distance <- max(w, h) # (w)width, (h)eight of image\nfor (i in 1:n) {\n for (j in 1:n) {\n     # the edge between node (i) and (j) is impossible\n     if (df0$category[i] == 1 & df0$category[j] == 1) {\n             d[i,j]= max_distance\n     }\n     else {\n               d[i,j] = ((df0$cx[i] - df0$cx[j])^2 + \n                       (df0$cy[i] - df0$cy[j])^2 )^(1/2) \n     }\n  }# forj \n} #for_i\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Select head node after minimum-weight spanning tree algorithm\r\n                \r\nI've implemented Prim's algorithm to find the minimum-weight spanning tree of my graph, and it works fine.\n\nNow I'd like to select the \"best\" head in the spanning tree. By \"best\" I mean the more balanced head, should I display the tree in a treeView UI for instance. I'm sure there are plenty of algorithms for that, but I don't know how to name the problem !\n    ", "Answer": "\r\nOne criteria you can use is the average distance from node to all the other nodes. Choose the node with minimum average distance. You can also probably try average square distance etc.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "prims algorithms, I am trying to find the minimum spanning tree for the following graph\r\n                \r\nhi i am doing the following algorithm. here is the question's picture \nhttps://i.stack.imgur.com/qLyBC.png\nand my answer for the following question is\nI-f\nf-g\nf-g\ng-d\nd-a\ng-c\na-h\na-b\nis this path the right way for the minimum spanning tree? if not which other vt do i have to take?\n    ", "Answer": "\r\nYour final answer seems to be correct. (Aside from that you wrote f-g twice instead of f-e, f-g).\n\nYou can verify that its a spanning tree by running some other algorithm to find a spanning tree (such as Kruscal's).\n\nNote: any two spanning trees have the same weight, and in particular they shpuld have the same number of edges for each weight (allowing you to verify your solution by running another spanning tree algorithm you might be more familiar with, and checking if the weights are similar)\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to convert a minimum spanning tree to a path/route in Java?\r\n                \r\nI have a minimum spanning tree in Java.\nThis is in a ```\nGraph```\n class which has a list of ```\nNode```\ns, those ```\nNode```\n classes have a list of ```\nEdge```\n classes which have a boolean if they are in the MST or not.\nExample:\n\nIn this example a human can see that a path/route to go to all the places and back from the start is: (Start-A --> A-Start --> Start-B --> B-C --> C-B --> B-D --> D-B --> B-Start), how can I code this route to a String, only knowing which connections to use and the start?\n    ", "Answer": "\r\nThis problem can be solved using DFS for trees.\nIt could be useful to look at the tree by using ```\nStart```\n as a root.\nImagine that from node ```\nStart```\n we go to node ```\nA```\n. We add this movement to our ```\npath```\n string. Now two possibilities can materialize: the first is that ```\nA```\n has no child, so we go back to ```\nStart```\n and we have to print the inverse of the movement done before; the second is that ```\nA```\n has one or more children, in which case we do a movement to reach the first child (update the string). When we have finished exploring the \"depth\" of this child we'll go back to ```\nA```\n and start with another child (if it's present).\n\nProbably, it's more difficult to explain this in words than seeing this in code: the key concept here is that when we finish exploring the depth of a possible path we have to get back to the node from which it started (which corresponds only to adding the inverse of the movement string in the parent).\n```\npublic void dfs(Node u, Node previous, StringBuilder path) {\n        for(Edge e: u.edges) {\n            // an edge is a pair (e.a, e.b)\n            if(!e.mst || e.b.equals(previous)) {\n                continue;\n            }\n            path.append(u + \"->\" + e.b + \"\\n\");\n            dfs(e.b, u, path);\n            path.append(e.b + \"->\" + u + \"\\n\"); // after exploring a child we must get back\n        }\n    }\n```\n\nThis is the code example that you can adapt to your use case.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Retrieving MST for geographic coordinates using scipy minimum spanning tree\r\n                \r\nI am trying to create a minimum spanning tree (MST) from geographical coordinates using scipy, but for the life of me I cannot understand how to extract information to it . The scipy documentation is not very clear and multiple searches have not provided results.\nFor context in total I have around 200k datapoints per set and they look like this\n\nMy final objective is to create a line vector that connects these points through the MST, more or less as they appear in the image above. But for that I need an ordered list of point indices (or coordinates) I can work with.\nMost of all I would need help understanding how to use the output of minimum_spanning_tree but it might be that I am making mistakes along the path\nOverall steps\nThe steps I take are:\n\nCreate the sparse matrix with coordinate info\nprovide the matrix to ```\nscipy.sparse.csgraph.minimum_spanning_tree```\n\nDo some magic to extract column values\n\nThis is the small sample test data:\n```\ntest_data = {\n    \"index\": [0,1,2,3,4],\n    \"X\": [35,36,37,38,38],\n    \"Y\": [2113,2113,2112,2101,2102]\n}\ndf= pd.DataFrame(test_data)\n```\n\nStep 1, create the sparse matrix\n```\nxs = df[[\"X\"]].values.squeeze().astype(int)\nys = df[[\"Y\"]].values.squeeze().astype(int)\ndata= np.array(df.index).squeeze().astype(int)\n\nmax_dim =max(np.max(xs), np.max(ys)) +1\nmax_dim\n\n\ndist_matr=csr_matrix((data, (xs,ys)),shape=(max_dim, max_dim))\n```\n\nQ1:I couldn't understand what data is in this context as scipy docs do not explain that in detail. should {data} be the labels of the points or are they the edge weights?\nStep2: calculate the minimum spanning tree\n```\nmst = minimum_spanning_tree(dist_matr)\n```\n\nStep3: get an ordered list of indices (or coordinates)\nAs I understand it the output of MST is a sparse graph that should look something like this (source)\n\nQ2: However, my matrix is not 5X5, but max_value*max_value (2113 in this case). And it seems like the content of the matrix is not the edge weight. Am I getting this wrong?\nI have tried to extract the connected components, but the labels don't make sense to me\n```\n# Label connected components.\nnum_graphs, labels = connected_components(mst, directed=False)\n\n\n\n# This is a snippet I found somewhere but I have difficulties following the logic of it\nresults = [[] for i in range(max(labels) + 1)]\nfor idx, label in enumerate(labels):\n    results[label].append(idx)\n```\n\nportion of the results:\n\nAs you can see point coordinates are grouped in an odd way, without a relationship between x and y. I have also tried 'depth_first_order' but aside for asking a starting point (that I wouldn't know how to choose) it provides me with equally confusing outputs\nQ4: How do I \"read\" the MST matrix and extract the minimum spanning tree for all points?\nI am happy to explore other solutions as long as they provide a similar result and are scalable, however I have seen concerns about NetworkX for lots of data and MisTree doesn't install on my setup\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "What is the logical error in my implementation of Prim's algorithm for minimum spanning tree?\r\n                \r\n```\n#define ll long long\nll prims(int n)\n{\n     ll ans;\n    vector<bool> used (n); \n\n    #define INF 1000000000000LL\n\n\n    vector<ll> min_e (n, INF), sel_e (n, -1);\n\n     min_e[0]=-1*INF;\n\n     ll dis=1;\n    for(int i=0;i<n;i++)\n    {\n        int v=-1;\n        for(int j=0;j<n;j++)\n        {\n             if (!used[j] && (v == -1 || min_e[j] < min_e[v]))\n            v = j;\n        }\n        used[v] = true;\n        if(sel_e[v]!=-1)\n        cout << v << \" \" << sel_e[v] << endl;\n\n    for (int to=0; to<n; ++to)\n        if (g[v][to] < min_e[to]) {\n            min_e[to] = g[v][to];\n            sel_e[to] = v;\n        }\n\n    }\n     for(int i=0;i<n;i++) cout<<i<<\" \"<<sel_e[i]<<\" \"<<g[i][sel_e[i]]<<endl;\n\n\n    return dis;\n}\n```\n\n\nI am trying to apply Prim's algorithm for a dense undirected graph for negative edge weights but I am unable to understand why it is producing wrong outputs for nearly all cases.\nI am using an adjacency matrix g[N][N] for storing the edges.\n\nActually the output for my current code is a minimum spanning tree with cycles. Why is the cycle checking mechanism not working?\n    ", "Answer": "\r\nActually, the problem is here:\n\n```\nfor (int to=0; to<n; ++to)\n    if (g[v][to] < min_e[to]) {\n        min_e[to] = g[v][to];\n        sel_e[to] = v;\n    }\n}\n```\n\n\nYou should only update ```\nsel_e```\n and ```\nmin_e```\n if ```\nto```\n hasn't been visited yet.\n\nOtherwise, consider this case:\n\n```\n0 -- 1 -- 2```\n\n\nwhere ```\nw({0, 1}) = 10```\n, and ```\nw({1, 2} = 1)```\n. You would set ```\nsel_e[1] = 2```\n, even though you need ```\nsel_e[1] = 0```\n.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Find minimum-weight complete graph that spans a given minimum spanning tree\r\n                \r\nLet T = (V, E) be a tree of ```\n|V|```\n vertices and ```\n|E| = |V-1|```\n edges, with known costs. We want to construct a minimum-weight complete Graph G = (V, E') that spans T as its unique minimum spanning tree.\n\nExample: consider the following tree T. Edges in red have a given cost. Dotted edges will be added to construct a complete graph from this tree.\n\n\n\nThe minimum-weight complete graph G that spans T as its unique MST is the following:\n\n\n\n\n\nI am trying to find a (polynomial-time) algorithm that generates this graph. I am looking mostly for a tip, not the complete solution. So far, I have devised the following algorithm:\n\n1) Find a cut of the graph that includes the heaviest MST edge of weight ```\nw_max```\n and no other MST edges. All other edges have to be ```\nw_max + 1```\n. The following pictures illustrates my idea:\n\n\n\nEdges (1--2), (1--4), (4--5), (2--3) and (2--5) are included in this cut C. The only edge that is included in the MST is edge (2--3) and it's the heaviest edge in the MST, with ```\nw=56```\n. Thus, all other edges should have ```\nw=57```\n. Proof: assume the contrary; we can replace (2--3) with another edge and still keep the tree connected. Now the tree's weight is lighter, thus (2--3) doesn't belong to the MST. Contradiction.\n\n2) Repeat for all other edges ```\ne_i```\n of the MST, of weight ```\nw_i```\n, in decreasing weight order. Take a cut that includes only ```\ne_i```\n and no other MST edges. Any unknown non-MST edge of this cut, should have a weight of ```\nw_i + 1```\n.\n\n\n\nQuestions:\n\n1) Is the above algorithm correct? According to the Cut property, it should be.\n\n2) Could I do it more efficiently? I don't have an algorithm to find cuts on the top of my head, but I don't feel this approach could be efficient.\n\n\n\nedit: Another approach that I had in my mind was an approach based on Kruskal's algorithm:\n\n1) Using a Union-Find, I iterate all MST edges, by ascending cost, and unify the corresponding vertices under the same component.\n\n2) In each step, two different components are unified through an edge of cost ```\nw```\n. Any other edges that form a cycle within the same (new) component should have a cost of ```\nw+1```\n.\n    ", "Answer": "\r\nAnswering my own question\n\nHere's an efficient answer I've come up with, following also the feedback from @sasha .\nSuppose we would like to calculate the total weight of the complete graph G, i.e;\n\n\n  Let T = (V, E) be a tree of |V| vertices and |E| = |V|-1 edges, with known weights. Calculate the total weight ```\nw_total```\n of the minimum-weight complete Graph G = (V, E') that spans T as its unique minimum spanning tree.\n  NB: edge weights are natural numbers.\n\n\nAlgorithm:\n\n\nInitialize a Union-Find with ```\n|V|```\n singleton components.\nSort all edges of ```\nT```\n by ascending weight. Running time: O(|V| * log|V|).\nIterate next edge ```\ne = (v1,v2)```\n of ```\nT```\n. Add its weight ```\nw_e```\n to ```\nw_total```\n.\nFind ```\nv1```\n's and```\nv2```\n's components in the Union-Find: ```\nset1```\n,```\nset2```\n, containing ```\nsize1```\n and ```\nsize2```\n vertices, respectively.\nThese components will be unified. Since ```\nG```\n is a complete graph, ```\nsize1 × size2```\n edges will be added: one edge is the MST ```\ne```\n edge, all others have to be heavier than ```\ne```\n, so that Kruskal's algorithm will ignore them. Thus, their minimum weight should be at least ```\nw_e + 1```\n.\n```\nw_total += (size1 × size2 - 1) × (w_e + 1)```\n.\nUnify the two components ```\nset1```\n and ```\nset2```\n.\nRepeat from step ```\n2```\n for the next MST edge ```\ne```\n.\n\n\nRunning time: O(|V| * log|V|).\n\n\n\nIf the problem becomes: list in detail all edges ```\ne = (v1, v2)```\n of the complete graph and their weight ```\nw```\n, we just have to do, between steps ```\n6```\n and ```\n7```\n:\n\n```\nfor all vertices v1 in set1\n  for all vertices v2 in set2\n    create edge e = (v1, v2); ignore if edge is the MST edge\n    w_e = w_mst_edge + 1\n```\n\n\nSo the running time becomes O(|E| + |V| * log|V|) = O(|V|^2), since we have |E| = |V|*(|V|-1)/2 edges in the complete graph ```\nG```\n.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Boost Kruskal minimum spanning tree algorithm -- undirected vs directed graph documentation\r\n                \r\nPer the documentation, the minimum spanning tree algorithm implemented in boost should work only on undirected graphs. Yet, the following code that provides a directed graph as input to the algorithm seems to work just fine: (while building on MSVC Visual Studio 2019, there are no warnings related to boost)\n```\n#include <boost/property_map/property_map.hpp>\n#include <boost/config.hpp>\n#include <boost/graph/adjacency_list.hpp>\n#include <boost/graph/kruskal_min_spanning_tree.hpp>\n#include <boost/graph/graph_utility.hpp>\nusing namespace boost;\ntypedef adjacency_list <vecS, vecS, directedS, no_property,\n    property<edge_weight_t, double>>\n    Graph_vvd_MST;\ntypedef adjacency_list_traits<vecS, vecS, directedS> Traits_vvd;\nproperty_map<Graph_vvd_MST, edge_weight_t>::type cost;\ntypedef Traits_vvd::edge_descriptor Edge;\nstd::vector < Edge > spanning_tree;\nint main() {\n    Graph_vvd_MST g;\n    add_vertex(g);//0 th index vertex\n    add_vertex(g);// 1 index vertex\n    add_vertex(g);// 2 index vertex\n    cost = get(edge_weight, g);\n    //Add directed arcs\n    for(int i = 0; i < 3; i++)\n        for (int j = 0; j < 3; j++) {\n            if (i == j)\n                continue;\n            std::pair<Traits_vvd::edge_descriptor, bool> AE = add_edge(i, j, g);\n            assert(AE.second);\n            if (i == 0 && j == 1)               cost[AE.first] = 1;\n            if (i == 0 && j == 2)               cost[AE.first] = 2;\n            if (i == 1 && j == 0)               cost[AE.first] = 1;\n            if (i == 1 && j == 2)               cost[AE.first] = 2;\n            if (i == 2 && j == 0)               cost[AE.first] = 1;\n            if (i == 2 && j == 1)               cost[AE.first] = 2;\n        }\n    kruskal_minimum_spanning_tree(g, std::back_inserter(spanning_tree));\n    printf(\"MST Solution:\\n\");\n    for (std::vector < Edge >::iterator ei = spanning_tree.begin();\n        ei != spanning_tree.end(); ++ei) {\n        int fr = source(*ei, g);\n        int to = target(*ei, g);\n        double cst = cost[*ei];\n        printf(\"[%d %d]: %f \\n\", fr, to, cst);\n    }\n    getchar();\n}\n```\n\nThe code above generates the following bidirectional graph:\n\nThe output of the code is correctly:\n```\nMST Solution:\n[0 1]: 1.000000\n[2 0]: 1.000000\n```\n\nIs it the case that the document is not updated and in recent boost versions, the algorithm can actually work with directed graphs?\n    ", "Answer": "\r\nI'd simplify the code Live\n```\n#include <boost/graph/adjacency_list.hpp>\n#include <boost/graph/kruskal_min_spanning_tree.hpp>\n#include <iostream>\n\nusing Graph =\n    boost::adjacency_list<boost::vecS, boost::vecS, boost::directedS,\n                        boost::no_property,\n                        boost::property<boost::edge_weight_t, double>>;\n\nusing Edge = Graph::edge_descriptor;\n\nint main()\n{\n    Graph g(3); // 0..2\n\n    /*auto [it, ok] =*/ add_edge(0, 1, {1}, g);\n    add_edge(0, 2, {2}, g);\n    add_edge(1, 0, {1}, g);\n    add_edge(1, 2, {2}, g);\n    add_edge(2, 0, {1}, g);\n    add_edge(2, 1, {2}, g);\n\n    auto cost = get(boost::edge_weight, g);\n    std::vector<Edge> spanning_tree;\n    kruskal_minimum_spanning_tree(g, std::back_inserter(spanning_tree));\n\n    std::cout << \"MST Solution:\\n\";\n    for (auto e : spanning_tree) {\n        std::cout << e << \": \" << cost[e] << \"\\n\";\n    }\n}\n```\n\nIf you insist on a loop to insert edges: Live\n```\nfor (auto [i, j, c] : { std::tuple //\n         {0, 1, 1.},\n         {0, 2, 2.},\n         {1, 0, 1.},\n         {1, 2, 2.},\n         {2, 0, 1.},\n         {2, 1, 2.},\n     })\n{\n    if (!add_edge(i, j, {c}, g).second)\n        return 255;\n}\n```\n\nThe Question\nIf you don't meet the documented pre-conditions the output is unspecified. Unspecified doesn't mean it throws an exception (that would be specified). It might even accidentally (seem to) do the right thing.\nThe point is that the algorithm operates under the assumption that edges are - by definition - traversable in the reverse direction at the same cost. As soon as you deviate from that, the algorithm may give incorrect results. In fact, some algorithms might exhibit undefined behaviour (like, a Dijkstra with some weights negative might never complete).\nYou'd do better to\n\nEither convert your graph to be undirected\nsatisfy the invariants of undirected graphs and verify that the algorithm works correctly for it\nUse an algorithm for MDST (Minimum Directed Spanning Tree), see e.g. Finding a minimum spanning tree on a directed graph\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Show that there exists a minimum spanning tree from a vertex always containing the shortest edge from that vertex\r\n                \r\nSuppose that e is an edge in a weighted graph that is incident to a vertex v such that the weight of e does not exceed the weight of any other edge incident to v. Show that there exists a minimum spanning tree containing this edge.\n    ", "Answer": "\r\nProof by Contradiction\n\nAssume that there exists a vertex v such that the MST does not use its smallest weight edge, e and instead uses another incident edge, let's call this x. Now, assume that we add the edge e back to the MST so that a cycle forms. We can now remove the previous edge used, x, on that cycle. At this point, we have another MST with a lower overall cost than the previously found spanning tree. This is a contradiction because the spanning tree with edge x was not actually an MST if it had a higher cost than the spanning tree with edge e. \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to compare nodes in minHeapify for minimum spanning tree?\r\n                \r\nI am trying to create a minimum spanning tree using prim's algorithm and I have a major question about the actual heap. I structured my graphs adjacency list to be a vector of vertexes, and each vertex has a vector of edges. The edges contain a weight, a connecting vertex, and a key. I am not sure whether my heap should be a heap of vertexes or edges. If I make it a heap of vertexes then there is no way to determine whether the weights are going from the same parent and destination vertexes, which makes me think that I should be making a heap for each vertexes list of edges. So my final question is should I be creating a heap of edges, or a heap of vertexes? If its a list of edges, should I be using the weight on the edges as the key, or should I have a separate data member called key that I can actually use for the priority queue? Thanks!\n    ", "Answer": "\r\nYou should make a minHeap of edges since you are going to sort edges by their weight but the edges should contain two vertexes: representing one vertex on each end. Otherwise, as you suggested: there is no way to determine whether the weights are going from the same parent and destination vertexes. Therefore you should re-structure your edge class and make a minHeap of them.\n\nConsider the algorithm from Wiki as well.\n\n\n  Initialize a tree with a single vertex, chosen\n  arbitrarily from the graph. \n  \n  Grow the tree by one edge: Of the edges\n  that connect the tree to vertices not yet in the tree, find the\n  minimum-weight edge, and transfer it to the tree. \n  \n  Repeat step 2 (until all vertices are in the tree).\n\n\nI don't fully understand the key field in the edge class. I assume it's like an Id to the edge. So you should make a heap of them but since you are providing user-defined data structure to the heap, you should also provide a comparison function for the edge class, i.e. define the ```\nbool operator<(const Edge&)```\n method.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Remove all symmetrical relations in an adjacency list based on a minimum spanning tree set\r\n                \r\nSo say I have an undirected, weighted graph represented using an adjacency list:\n```\n# Dict with key being source and value being list of connections made up of tuple of destination and cost\nadjacency_list: dict[int, set[tuple[int, int]]] = {\n    1: {(2, 5), (3, 11), (4, 7)},\n    2: {(1, 5), (3, 1)},\n    3: {(1, 11), (2, 1), (4, 11)},\n    4: {(1, 7), (3, 11)},\n}\n```\n\nThen an mst set to store the minimum spanning tree:\n```\n# Set made up of tuples of source, destination and cost\nmst: set[tuple[int, int, int]] = {\n    (1, 2, 5),\n    (1, 4, 7),\n    (2, 3, 1),\n}\n```\n\nIs there a way I can remove all symmetrical and equal connections in the mst compared to the adjacency list. For example, remove the connection from 1 to 2 and the one from 2 to 1 in the adjacency list since the connection exists in the mst?\n\n    ", "Answer": "\r\nI think first you would need to decide which connection you want to delete.\nI guess it's the 2 to 1, leaving only 1 to 2 left.\nThen iterate over your mst set.\nFind symetry.\nDelete it.\n```\n\nfor tree_path in mst:\n    to_delete = tree_path[1]\n    dest, weight = tree_path[0], tree_path[2]\n\n    for al_tree_path in adjacency_list[to_delete]:\n        # we've found symetry in adjacency list for a given node\n        if al_tree_path == (dest, weight):\n            adjacency_list[to_delete].remove(al_tree_path)\n\n\n```\n\nThat should leave you without symetry in adjacency_list given what was in the mst set.\noutput for the case you've specified\nhere's the way to store it as a set of tuples\n```\n\nresult = set()\nfor key, value in adjacency_list.items():\n    for tree_path in adjacency_list[key]:\n        result.add((key, *tree_path))\n\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum spanning tree in a graph with multiple root vertices\r\n                \r\nI would like to know if there is an algorithm which computes a minimum spanning tree (optimum branching) in a directed graph given a set of root vertices between all of these root vertices, but not only one root vertex and all other vertices in a graph.\n\nGiven a set of root vertices [1,4,6] and a graph G like the one on the following picture:\n\n\n\n...the algorighm should return something like a green sub-graph on the same picture.\n\nI would like to get such an MST that connects all the root vertices provided to the algorithm. I tend to think that the result of the would-be algorithm is a sub-graph of the graph G which contains all root vertices and some other vertices from G.\n\nNotes:\n\n\nI know that there is no MST for a directed graph, but there is Chu–Liu/Edmonds algorithm.\nI guess that a result of such an algorithm (if it is actually possible) will return an optimum branching, which includes some vertices of a graph along with all root vertices. \n\n    ", "Answer": "\r\nMinimum Spanning Trees are supposed to span all the vertices. I think you might be actually dealing with a Steiner Tree problem, given that you only need to connect a subset of them. Unfortunately, the traditional Steiner tree problem with undirected edges is already NP complete so you have a tough road ahead of you.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum Spanning Tree of Max Cost Complexity Class Problem\r\n                \r\n\"Decide whether a given undirected graph G=(V,E) with positive edge costs has a minimum spanning tree of cost at most K\".\nIs this a problem of P, NP, CoNP, RP or BPP? \nI am fair sure that it is in NP, as there is a way to 'guess' and verify that guess in polynomial time.\nBut I am thinking that it is in P as well, as well use the Prim Algorithm within polynomial time as well. \nIf it is in both P & NP. Is it fair to say that it is in CoNP, RP & BPP as well? As P is a subset of CoNP, whereas RP is a subset of NP, & RP is also a subset of BPP. Is it fair to say that the problem above is in all of the 5 complexity classes - P, NP, CoNP, RP or BPP? I am unsure if I misunderstood any of the concepts here. But please let me know if what I understand is correct. Thank you.\n    ", "Answer": "\r\nYes, your understanding is exactly right. You can answer this question in polynomial time by using Prim's algorithm to find a minimum spanning tree for G, and then comparing the cost of that tree to K. (By the definition of \"minimum spanning tree\", all minimum spanning trees for a given graph have the same cost, so you only need to check one of them.) Therefore, the problem is in P; and since P is a subset of each of NP, co-NP, RP and BPP, that means that the problem is in each of those complexity classes as well.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Calculate sub-paths between two vertices from minimum spanning trees\r\n                \r\nI have a minimum spanning tree (MST) from a given graph. I am trying to compute the unique sub-path (which should be part of the MST, not the graph) for any two vertices but I am having trouble finding an efficient way of doing it.  \n\nSo far, I have used Kruskal's algorithm (using Disjoint Data structure) to calculate the MST (for example: 10 vertices A to J).. But now I want to calculate the sub-path between C to E.. or J to C (assuming the graph is undirected). \n\nAny suggestions would be appreciated. \n    ", "Answer": "\r\nIf you want just one of these paths, doing a DFS on your tree is probably the easiest solution, depending on how you store your tree. If it's a proper graph, then doing a DFS is easy, however, if you only store parent pointers, it might be easier to find the least common ancestor of the two nodes.\n\nTo do so you can walk from both nodes u,v to the root r and then compare the r->u and r->v paths. The first node where they differ is the least common ancestor.\n\nWith linear preprocessing you can answer least common ancestor queries in constant time. If you want to find the paths between pairs of nodes often, you might want to consider implementing that data structure. This paper explains it quite nicely, I think.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Do minimum depth, spanning trees algorithms exist?\r\n                \r\nI'm currently optimizing electrical grid planning and the ```\nMST```\n doesn't solve the problem well, because if the connection to the main grid is in a radial point all the power has to flow through one edge and will travel a long \"electrical distance\" to every consumption point.\n\nThe problem I'm looking at could be minimizing the ```\nMW*distance```\n or active power moment, but that creates a non-linear problem.\n\nSo what I want to find is a minimum spanning tree (not the optimal, just most efficient) that  minimizes the maximum electrical distance (distance through the graph) to the tree root.\n\nIn this way I just buy longer thinner cables that is a cheaper solution to shorter thicker cables.\n    ", "Answer": "\r\nIn this case, you don't want a minimum spanning tree.  You want a shortest path tree, which is a spanning tree minimizing the distance from each point in the graph back to the source node.  Any standard shortest-path algorithm can be modified to produce a shortest-path tree.  For example, a standard implementation of Dijkstra's algorithm can produce such a tree.\n\nThat said... shortest path trees are not guaranteed to be cheap, and it's possible to construct graphs where shortest path trees are significantly more expensive than the corresponding minimum spanning tree.  In other words, you might have to pay significantly more money to build a shortest path tree than a minimum-spanning tree.\n\nThere has been some research into algorithms for finding spanning trees that are good compromises between an MST (minimum total weight) and shortest-path trees (minimum distances to each node), though unfortunately I can't remember off the top of my head where to look to find this.\n\nHope this helps!\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Finding maximal spanning tree using Prim's algorithm\r\n                \r\nCan we compute the maximal spanning tree by changing the algorithm to choosing the maximum vertex instead of choosing the minimum one?\n\nI have come across the solution by negating the edges and applying the normal Prim's Minimum Spanning Tree algorithm.\n    ", "Answer": "\r\nFeed in to the algorithm the input graph, but with the weights negated. Nothing in Prim assumes the weights are positive. The minimum of the weights negated, is achieved by the maximum of the original weights. \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "finding all minimal spanning trees [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 11 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n\n  Possible Duplicate:\n  All minimum spanning trees implementation  \n\n\n\n\nHow can I find all minimum spanning trees in an undirected graph in an efficient way?\n    ", "Answer": "\r\nApologies for the academic answer... but algorithm ```\nS```\n in Knuth's TAOCP, Volume 4, Fascicle 4 is exactly about generating all spanning trees (pp. 26ff). There are a few musings when he talks about generating (spanning) trees, but your best bet in TAOCP.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to analyze all traces in a graph analyzed with minimum spanning trees?\r\n                \r\nThe Minimum Spanning Tree algorithm (MST) allows to find the shortest possible connexion for all nodes. In Python, Scipy provides a package to analyze MST. I want to find a way to get the main traces based on the connexions. In the example underneath, there is a trace at dest2-dest4-dest1 and another one at source-dest4-dest3 (other combination of traces are possible as well).\n\n```\nfrom scipy.sparse.csgraph import minimum_spanning_tree\nimport pandas as pd\nimport numpy as np\n```\n\nThe example has the following coordinate points for source and destinations\n```\ndf = pd.DataFrame([[2, 2], [30, 2], [2, 30], [25, 25], [14,10]], columns=['xcord', 'ycord'], index=['source', 'dest1', 'dest2', 'dest3', 'dest4'])\n```\n\nA distance matrix and minimum spanning tree with resulting distances can be computed.\n```\ndm = pd.DataFrame(distance_matrix(df.values, df.values), index=df.index, columns=df.index)\n\nmst = minimum_spanning_tree(dm)\n\narr_distances = mst.toarray()\n```\n\nThis gives the following array.\n```\narray([[ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ],\n       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ],\n       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ],\n       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ],\n       [14.4222051 , 17.88854382, 23.32380758, 18.60107524,  0.        ]])\n```\n\nWhich means, distance source-dest4 = 14.42, dest1-dest4 = 17.89, dest2-dest4 = 23.32 and dest3-dest4 = 18.60.\nHow can one capture the available main trace(s) expressed in a list or numpy.array like ['source', 'dest4', 'dest3'] and ['dest2', 'dest4', 'dest1'] ? This should work for any configuration of input coordinates.\nSo far I have tried to get the main connexions using ```\nnp.argwhere(arr_distances > 0)```\n, but somehow it is difficult to get them as aforementioned traces in different lists or sublists.\nIt would be good if the solution were in Python, but any other package than Scipy is welcome. Thank you very much in advance for your help!\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Distinct minimum spanning tree\r\n                \r\nFor a connected, weighed, undirected graph G:\nG has a unique MST, if for every cut of G there is a unique minimum weight edge crossing the cut.\n\nIs this statement true?\n\nI think false because for the following graph in the given link there can be multiple MSTs. \n\nhttps://drive.google.com/file/d/1yDK3juPxeDBdS-aEOx0aAsphy4odZ55l/view?usp=drivesdk\n    ", "Answer": "\r\nIf you mean a connected graph G, with edge costs that are all distinct. Then G has a unique minimum spanning tree.\n\nproof:\nSuppose there are two different MSTs, call them T1 and T2, who have different sets of edges--{t11, t12, … t1n-1} for T1 and {t21, t22, … t2n-1} for T2. So, let ti be the edge with the smallest weight only in T1 (not in T2). Since it is the smallest,  ti must be included in \"every choice\" of MST. That is, both MST of T1 and T2 would have it. But this contradicts the definition of ti. \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "how to calculate totals and minimum spanning trees using arrays\r\n                \r\nI'm working on a C# assignment in which i have to create a minimum spanning tree through the use of arrays. My code is made up of three arrays which track the nodes and whether or not they have been reached. I have to find the smallest total for all of the randomly generated links to be added up to visit all of the nodes. However, for some reason it is not quite working. The totals being produced are not correct and just wondered if anyone could help me work out why.I believe the error must be between the calculating of the total or how the minimum value is being decided or possible both however i am unsure.\n\nSo far i have tried changing the way it is calculated to involve a sum variable to store the values seperately. Ive attempted to add another if statement that would stop the min value from being anything above 98 ( the void value is 99) i have also tried to alter the earlier code to see if how i am testing the values in the SP array are the desired ones. still no results\n\n```\n            int n = 5;              //n = number of values\n        int m = 50;             //m = max value in arra\n        int VoidValue = 99;     // if i = j value = void value\n        int Total = 0;          //Total value for spanning tree\n        int sum = 0;        //Sum for total value for spanning tree\n\n        Random Rand = new Random(); //Create randomise value\n\n\n        int[,] c = new int[n + 1, n + 1]; //Cost array\n\n        int[] SP = new int[n + 1];      //Spanned array\n\n        int[,] AD = new int[n + 1, n + 1];  //Adjacency array\n\n        for (int i = 1; i <= n; i++)\n        {\n            SP[i] = 0;\n            for (int j = 1; j <= n; j++)\n            {\n\n                if (i == j)\n                {\n                    c[i, j] = VoidValue;               // give void spaces the value of 99\n                    AD[i, j] = 0;\n                }\n                else\n                {\n                    c[i, j] = Rand.Next(1, m);    // Populate the array with randomised values\n                    AD[i, j] = 0;\n                }\n            }\n        }\n\n        //Output all arrays to screen\n\n        Console.WriteLine(\"Cost Array: At the beginning\");\n        Console.WriteLine(\"\");\n        for (int i = 1; i <= n; i++)\n        {\n            for (int j = 1; j <= n; j++)\n            {\n                if (i == j)\n                {\n                    Console.Write(\"c[\" + i + \",\" + j + \"] = \" + \"- \" + \" \");\n                }\n                else\n                {\n                    Console.Write(\"c[\" + i + \",\" + j + \"] = \" + c[i, j].ToString(\"00\") + \" \");\n                }\n            }\n            Console.WriteLine();\n        }\n        Console.ReadLine();\n\n        Console.WriteLine(\"\");\n        Console.WriteLine(\"Spanned Array : At the beginning\");\n        Console.WriteLine(\"\");\n        for (int i = 1; i <= n; i++)\n        {\n            Console.Write(\"S[\" + i + \"] = \" + SP[i].ToString(\"00\") + \" \");\n            Console.WriteLine();\n        }\n        Console.ReadLine();\n\n        Console.WriteLine(\"\");\n        Console.WriteLine(\"Adjacency Array : At the beginning\");\n        Console.WriteLine(\"\");\n        for (int i = 1; i <= n; i++)\n        {\n            for (int j = 1; j <= n; j++)\n            {\n                if (i == j)\n                {\n                    Console.Write(\"A[\" + i + \",\" + j + \"] = \" + \"- \" + \" \");\n                }\n                else\n                {\n                    Console.Write(\"A[\" + i + \",\" + j + \"] = \" + AD[i, j].ToString(\"00\") + \" \");\n                }\n            }\n            Console.WriteLine();\n        }\n        Console.ReadLine();\n\n        // Random Starting Point\n\n        int startPoint = Rand.Next(1, n + 1);\n        Console.WriteLine(\"Start at node \" + startPoint);\n        SP[startPoint] = 1;\n\n        //Check the spanned array \n        Console.WriteLine(\"\");\n        Console.WriteLine(\"Spanned Array : After the starting point has been chosen \");\n        Console.WriteLine(\"\");\n        for (int i = 1; i <= n; i++)\n        {\n            Console.Write(\"S[\" + i + \"] = \" + SP[i].ToString(\"00\") + \" \");\n            Console.WriteLine();\n        }\n        Console.ReadLine();\n\n        // Find minimum vallue link, repeatedly follow these links until spanned array is full\n\n        for (int p = 1; p < n; p++) // For every value of the spanned array \n        {\n            int MinValue = VoidValue, MinValuei = 0, MinValuej = 0; // declare variables\n            for (int i = 1; i <= n; i++)\n            {\n                for (int j = 1; j <= n; j++)        // I and J are for both variables of the cost and adjacent array\n                    if (i != j)\n                    {\n                        if (SP[i] == 1)             //Spanned node\n                        {\n                            if (SP[j] == 0)         //Unspanned node\n                            {\n                                if (c[i, j] < MinValue)\n                                {\n\n                                  MinValue = c[i, j];\n                                  MinValuei = i;\n                                  MinValuej = j;\n\n                                }\n                            }\n                        }\n                    }\n                AD[MinValuei, MinValuej] = 1;\n                SP[MinValuej] = 1;\n            }\n\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"The min value is: \" + MinValue);\n            Total = Total + MinValue;\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"The total is: \" + Total);\n        }\n        //Finally output spanned and adjacent arrays \n\n        Console.WriteLine(\"\");\n        Console.WriteLine(\"Spanned Array: After spanning tree\");\n        Console.WriteLine(\"\");\n        for (int i = 1; i <= n; i++)\n        {\n            Console.Write(\"S[\" + i + \"] = \" + SP[i].ToString(\"00\") + \" \");\n            Console.WriteLine();\n        }\n        Console.ReadLine();\n\n        Console.WriteLine(\"\");\n        Console.WriteLine(\"Adjacency Array : After spanning tree\");\n        Console.WriteLine(\"\");\n        for (int i = 1; i <= n; i++)\n        {\n            for (int j = 1; j <= n; j++)\n            {\n                if (i == j)\n                {\n                    Console.Write(\"A[\" + i + \",\" + j + \"] = \" + \"- \" + \" \");\n                }\n                else\n                {\n                    Console.Write(\"A[\" + i + \",\" + j + \"] = \" + AD[i, j].ToString(\"00\") + \" \");\n                }\n\n            }\n            Console.WriteLine();\n        }\n        Console.ReadLine();\n\n        //Output total value for the spanning tree\n\n        Console.WriteLine(\"\");\n        Console.WriteLine(\"The total value for the spanning tree: \" + Total);\n        Console.WriteLine(\"\");\n        Console.ReadLine();\n```\n\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum weight spanning tree for Directed graph with parallel edges\r\n                \r\nI would like to have the name of algorithms can be used to find Minimum weight spanning tree from a Directed cyclic graph with parallel edges. Information on any c++ libraries that can be used to obtain the same with their analysis on runtime and efficiency.\n    ", "Answer": "\r\nThere's no such thing as minimum spanning tree for directed graphs. You probably have in mind minimum spanning aborescence (https://en.wikipedia.org/wiki/Arborescence_(graph_theory)).\n\nFor finding min cost aborescence there's an algorithm called Chu–Liu/Edmonds' algorithm. (https://en.wikipedia.org/wiki/Edmonds%27_algorithm) It can find the aborescne of minimum cost in O(VE) or O(E log V) or O(E + V log V) depending on implementation. \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Return the path between two nodes in a minimum spanning tree\r\n                \r\nI have a minimum spanning tree created using Kruskal's algorithmstored in a map of key:string and data:set(string)\n\n```\nmst = { \"A\" : [\"B\"]\n        \"B\" : [\"A\", \"C\", \"D\"]\n        \"C\" : [\"B\"]\n        \"D\" : [\"B\", \"E\"]\n        \"E\" : [\"D\", \"F\"] }\n```\n\n\nI am trying to write an algorithm that will return the path between a specified start and end node\n\n```\n$ findPath A F\n> A B D E F\n\n$ findPath F C\n> F E D B C\n```\n\n\nI think I should use some kind of modified depth first search but I am not sure how to implement the algorithm or how to store the nodes that form the path. I don't believe I have to worry about marking nodes as \"visited\" since there are no cycles in a MST.\n\nThere are some similar questions but I haven't been able to find any that can be applied to my specific scenario, they seem to only deal with a non-MST and only return if a path can be found between two nodes, which in my case I already know that there is a path between every node and I also require a list of nodes on the path. \n\nEDIT\nThe answer converted to c++, probably not the cleanest code but it works\n\n```\nvector<string> findPath(map<string, set<string>> mst, string src, string dest, vector<string> path) {\n    if(src == dest) {\n        return path;\n    }\n    set<string> possible = mst[src];\n    for(vector<string>::iterator it = path.begin(); it != path.end(); it++) {\n        if(possible.find(*it) != possible.end())\n            possible.erase(*it);\n    }\n    for(set<string>::iterator it = possible.begin(); it != possible.end(); it++) {\n        vector<string> a = path;\n        if(find(a.begin(), a.end(), src) == a.end())\n                a.push_back(src);\n        vector<string> p = findPath(mst, *it, dest, a);\n        if(p[0] != \"FALSEBEGINNING\") {\n            return p;\n        }\n    }\n    vector<string> p = path;\n    p[0] = \"FALSEBEGINNING\";\n    return p;\n}\n```\n\n    ", "Answer": "\r\n\r\n\r\n```\nconst mst = {\r\n  A: ['B'],\r\n  B: ['A', 'C', 'D'],\r\n  C: ['B'],\r\n  D: ['B', 'E'],\r\n  E: ['D', 'F']\r\n}\r\n\r\nconst findPathTraversal = (mst, src, dest, path) => {\r\n  const findPath = (mst, src, dest, path) => {\r\n    if (src === dest) return path\r\n    let possible = mst[src]\r\n    possible = possible.filter(v => !path.includes(v))\r\n    for (let i = 0; i < possible.length; i++) {\r\n      let a = path\r\n      if (!a.includes(src)) a.push(src)\r\n      let p = findPath(mst, possible[i], dest, a)\r\n      if (p != -1) return path\r\n    }\r\n    return -1\r\n  }\r\n  let ans = findPath(mst, src, dest, path)\r\n  ans.push(dest)\r\n  return ans\r\n}\r\n\r\nconsole.log(findPathTraversal(mst, 'A', 'F', []))```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Design an algorithm which finds a minimum spanning tree of this graph in linear time\r\n                \r\nI am working on a problem in which I am given an undirected graph G on n vertices and with m edges, such that each edge e has a weight w(e)  ∈ {1, 2, 3}.  The task is to design an algorithm which finds a minimum spanning tree of G in linear time (O(n + m)).\n\nThese are my thoughts so far:\n\n\nIn the Algorithmic Graph Theory course which I am currently studying, we have covered Kruskal's and Prim's MST Algorithms.  Perhaps I can modify these in some way, in order to gain linear time.  \nSorting of edges generally takes log-linear (O(mlog(m))) time; however, since all edge weights are either 1, 2 or 3, Bucket Sort can be used to sort the edges in time linear in the number of edges (O(m)). \n\n\nI am using the following version of Kruskal's algorithm:\n\n```\nKruskal(G)\n  for each vertex 𝑣 ∈ 𝑉 do MAKE−SET(𝑣)\n  sort all edges in non-decreasing order\n  for edge 𝑢, 𝑣 ∈ 𝐸 (in the non-decreasing order) do\n    if FIND 𝑢 ≠ FIND(𝑣) then \n      colour (𝑢, 𝑣) blue\n      UNION(𝑢, 𝑣)\n  od\n  return the tree formed by blue edges\n```\n\n\nAlso, MAKE-SET(x), UNION(x, y) and FIND(x) are defined as follows:\n\n```\nMAKE-SET(𝒙)\n  Create a new tree rooted at 𝑥\n  PARENT(𝑥)=x\n\nUNION(𝒙, 𝒚)\n  PARENT FIND(𝑥) ≔ 𝐹𝐼𝑁𝐷(𝑦)\n\nFIND(𝒙)\n  𝑦 ≔ 𝑥\n  while 𝑦 ≠ PARENT(𝑦) do\n    𝑦 ≔ PARENT(𝑦)\n  return y\n```\n\n\nThe issue I have at the moment is that, although I can implement the first two lines of Kruskal's in linear time, I have not managed to do the same for the next four lines of the algorithm (from 'for edge u, ...' until 'UNION (u, v)').\n\nI would appreciate hints as to how to implement the rest of the algorithm in linear time, or how to find a modification of Kruskal's (or some other minimum spanning tree algorithm) in linear time.\n\nThank you.\n    ", "Answer": "\r\nIf you use the Disjoint Sets data structure with both path compression and union by rank, you get a data structure whose each operation's complexity grows extremely slowly - it is something like the inverse of the Ackermann function, and is not that large for sizes such as the estimated number of atoms in the universe. Effectively, then, each operation is considered constant time, and so the rest of the algorithm is considered linear time as well. \n\nFrom the same wikipedia article\n\n\n  Since α(n) is the inverse of this function, α(n) is less than 5 for all remotely practical values of n. Thus, the amortized running time per operation is effectively a small constant.\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "igraph (maximum) spanning tree is disconnected\r\n                \r\nI have a graph and want to obtain the maximum spanning tree, therefore I obtain the minimum spanning tree of the graph with inverse weights. However the results gives a disconnected graph.\n\nBelow an example of my problem:\n\n```\nimport igraph\nimport numpy as np\nAM = ([[0, 2, 1], [1, 0, 1], [2, 1, 0]])\n\ng = igraph.Graph.Weighted_Adjacency(AM)\nprint g.is_connected()\ninv_weight = [1./w for w in g.es[\"weight\"]]\nprint g.spanning_tree(weights=inv_weight).is_connected()\n```\n\n\nthe results is:\n\n```\nTrue\nFalse\n```\n\n\nhow is this possible?\n    ", "Answer": "\r\nTurns out the spanning tree is directed and only weakly connected. Therefore\n\n```\ng.spanning_tree(weights=inv_weight).is_connected(mode=\"weak\")\n```\n\n\nreturns: \n\n```\nTrue\n```\n\n\nTo get a strongly connected tree either of the following lines would work:\n\n```\ng = igraph.Graph.Weighted_Adjacency(AM, mode=\"undirected\")\n```\n\n\nor\n\n```\nT = g.spanning_tree(weights=inv_weight)\nT = T.to_undirected()\nprint T.is_connected()\n```\n\n\nresult is:\n\n```\nTrue\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "What data structure would I need to use to construct a minimum spanning tree in Java?\r\n                \r\nI have a class ```\nNode```\n similar to Java's class ```\nPoint```\n with ```\nx```\n and ```\ny```\n coordinates, which I paint onto a ```\nJPanel```\n. I'm trying to create a minimum spanning tree for a set of such nodes on a Euclidean graph, which I would then paint onto the panel as well. But I can't really figure out the data structure I'd need to do create the tree efficiently in the first place.\n\nI've tried using ```\nLinkedLists```\n and ```\nArrayLists```\n to implement Prim's algorithm, but they seem to make things overly complicated. What data structure should I be looking into for this instead?\n    ", "Answer": "\r\nGraph can be represented by adjacency list. I generally use ```\nVector```\n to create adjacency lists. They are very convenient to handle. Also use ```\nPriorityQueue```\n to get minimum path cost.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "graph - The implementation of updating Minimum Spanning Tree after adding a new edge\r\n                \r\nHere is an excise\n\n\n  Suppose we are given the minimum spanning tree T of a given graph G\n  (with n vertices and m edges) and a new edge e = (u, v) of weight w\n  that we will add to G. Give an efficient algorithm to find the minimum\n  spanning tree of the graph G + e. Your algorithm should run in O(n)\n  time to receive full credit.\n\n\nI have this idea:\n\n```\nIn the MST, just find out the path between u and v. Then find the edge (along the path) with maximum weight; if the maximum weight is bigger than w, then remove that edge from the MST and add the new edge to the MST.```\n\n\n\n\nThe tricky part is how to do this in O(n) time and it is also I get stuck.\n\nThe question is that how the MST is stored. In normal Prim's algorithm, the MST is stored as a parent array, i.e., each element is the parent of the according vertex.\n\nSo suppose the excise give me a parent array indicating the MST, how can I release the above algorithm in O(n)?\n\nFirst, how can I identify the path between u and v from the parent array? I can have two ancestor arrays for u and v, then check on the common ancestor, then I can get the path, although in backwards. I think for this part, to find the common ancestor, at least I have to do it in O(n^2), right?\n\nThen, we have the path. But we still need to find the weight of each edge along the path. Since I suppose the graph will use adjacency-list for Prim's algorithm, we have to do O(m) (m is the number of edges) to locate each weight of the edge.\n\n...\n\nSo I don't see it is possible to do the algorithm in O(n). Am I wrong?\n    ", "Answer": "\r\nThe idea you have is right. Note that, finding the path between ```\nu```\n and ```\nv```\n is ```\nO(n)```\n. I'll assume you have a ```\nparent array```\n identifying the MST. tracking the path (for max edge) from ```\nu```\n to ```\nv```\n or ```\nu```\n to ```\nroot vertex```\n should take only ```\nO(n)```\n. If you reach ```\nroot vertex```\n, just track the path from ```\nv```\n to ```\nu```\n or ```\nroot vertex```\n. \n\nNow that you have the path from ```\nu -> u1 ... -> max_path_vert1 -> max_path_vert2 -> ... -> v```\n, remove the edge ```\nmax_path_vert1->max_path_vert2```\n (assuming this is greater than the added edge) and reverse the parents for ```\nu->...->max_path_vert1```\n and mark ```\nparent[u] = v```\n. \n\nEdit: More explanation for clarity\n\nNote that, in MST there will be exactly one path between any pair of vertices. So, if you can trace from ```\nu->y```\n and ```\nv->y```\n, you have only traced through atmost ```\nn```\n vertices. If you traced more than ```\nn```\n vertices that means you visited a vertex twice, which will not happen in an MST. Ok, now hopefully you're convinced it's O(n) to track from ```\nu->y```\n and ```\nv->y```\n. Once you have these paths, you have established a path from ```\nu->v```\n. Do you see how? I'm assuming this is an undirected graph, since finding MST for directed graph is a different concept in itself. For undirected graph, when you have a path from ```\nx->y```\n you have a path from ```\ny-x```\n. So, ```\nu->y->v```\n exist. You don't even need to trace back from ```\ny->v```\n, since weights for ```\nv->y```\n will be same as that of ```\ny->v```\n. Just find the edge with the maximum weight when you trace from ```\nu->y```\n and ```\nv->y```\n.\n\nNow for finding edge weights in O(1); how are you storing your current weights? Adjacency list or adjacency matrix? For O(1) access, store it the way parent vertex array is stored. So, ```\nweight[v] = weight(v, parent[v])```\n. So, you'll have O(1) access. Hope this helps.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Algorithm(s) for the constrained degree + bounded diameter minimum spanning tree?\r\n                \r\nSuppose I have 3 kinds of restrictions to computing a spanning tree: \n\n\nConstrained degree (eg: a node in\na spanning tree may only be\nconnected up to 3 other nodes)\nBounded diameter (eg: all edges'\nweights, once summed, cannot exceed\n100).\n2.1. If possible, show all subtrees that meet this criteria.\nBoth\n\n\nAre there any good algorithms to solve this that aren't gonna drive me insane? I'm gonna have to run this with rather large inpputs (1000+ nodes), so its complexity can't be too high either.\n    ", "Answer": "\r\nThe degree-constrained spanning tree problem is NP-complete. See http://en.wikipedia.org/wiki/Degree-constrained_spanning_tree .\nSo, no good (i.e., polynomial) algorithms. There are approximation algorithms, though.\n\nA Google search seems to indicate that the bounded diameter spanning tree problem is equally hard.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Adjacent spanning trees property\r\n                \r\nI need to show that, given a connected graph with distinct weights for every edge, every spanning tree (except from the minimum spanning tree) has an adjacent spanning tree with a smaller weight.\nw(T') < w (T), where T' is adjacent to the spanning tree T.\n\nI'm stuck at proving that every single ST that is adjacent to the MST has an adjacent spanning tree (the MST, indeed).\nHow can I show this with whatever non-MST adjacent spanning tree?\n    ", "Answer": "\r\nThe proof of the Kruskals algorithm answers your question.\nhttp://people.qc.cuny.edu/faculty/christopher.hanusa/courses/634sp12/Documents/KruskalProof.pdf \n\nLet T be your MST and N be your non spanning tree. Since N!=T, find an edge e in T of minimum weight that is not in N. \n\nN+e has a cycle where e is part of the cycle and there has to be a e' on the cycle such that wt(e)\n\nSo construct N'=N-e'+e. Obviously wt(N1)\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Polynomial time algorithm for minimum variance spanning tree\r\n                \r\nLets define the variance of a graph as the variance of its edges' weights. The task I am trying to solve is designing an algorithm which given a graph G will construct a spanning tree T with minimum variance. \n\nI am having a hard time getting the ball rolling on this. So far I've noticed that if the average edge weight in such a spanning tree was known then the problem could be solved by replacing the weight of every edge with the square of its deviation the the average weight and feeding the graph into any MST finding algorithm.\n\nObviously, I do not know anything about the average edge weight in the tree I am trying to construct, however it occured to me that the average must fall between 2 edges of G and perhaps this information could be exploited.\n\nI'm trying to reduce the problem to finding the MST of G with modified edge weights. I thought about running an algorithm for each edge of G, each time assuming that the initial edge is the closest to average in T and given weight 0 while the other edges get weights equal to the square of their deviation from the weight of the initial edge. This approach went nowhere because if the average isn't equal to the weight of one of the edges, then depending on where it falls between the weights of 2 closest edges the ordering of edges based on their weight would be different and would produce different spanning trees when fed into an MST finding algorithm. This is something I don't know how to handle (or if it even can be handled).\n\nThis is homework, so I'd prefer a small hint to send me in the right direction rather than a solution.\n    ", "Answer": "\r\nIdea 1: You only need to be able to compare edges pairwise when you build a minimum weight spanning tree. \n\nIdea 2:\n\n\n   The pairwise comparison of an edge of weight x and an edge of weight y, when you square the difference between the weights and the guess g, only changes at g=(x+y)/2. \n\n\nIdea 3:\n\n\n  If there are |E| edges, there are at most (|E| choose 2)+1 essentially  different guesses g for the average weight. Compute a minimum weight spanning tree for each of these. Compare the variances of these trees.\n\n\nThere should be much faster ways, but this is a polynomial time algorithm.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Distance of every possible path between all nodes in minimum spanning tree\r\n                \r\nI want to get distance of all nodes from all nodes. There are a few questions regarding this but none solves my problem.\nWhat my appoach is that I am implementing recursive DFS and storing the result of each path while backtracking but the problem is I am having high running time and I a going through a path N number of times (N being the number of edges).\n\nAs you can see in my code I am running dfs for every possible node as a root. I dont know how to reuse the path to know the answer just in One Iteration of DFS search. \n\nI think it could be done in O(n) as its a minimum spanning tree and there is only one path between a pair of nodes.\n\nmy code :\n\n```\nvector<int> visited(50001);\nmap< pair<ll,ll> , ll> mymap;\nmap<ll, vector<ll> > graph;\n\nvoid calc(ll start,ll node)\n{\n    visited[node]=1;\n    vector<ll>::iterator it;\n    for (it = graph[node].begin(); it != graph[node].end(); ++it)\n    {\n        if (!visited[*it])\n        {\n            ans+=mymap[make_pair(node,*it)];\n            mymap[make_pair(start,*it)]=ans;\n            calc(start, *it);\n            ans-=mymap[make_pair(node,*it)];\n        }\n    }\n}\n```\n\n\nIn main :\n\n```\nfor(i=1;i<=n;i++)\n    {\n        fill(visited.begin(),visited.end(),0);\n        ans=0;\n        calc(i,i);\n    }\n```\n\n    ", "Answer": "\r\nI can think of a solution of complexity O(n * logn) using divide and conquer. Let me share it.\n\nLet's choose an edge e of distance d which is connecting node a and b. Let's cut it. Now we have two tree with root a and b. Let's assume,\n\n\nnumber of nodes in tree a = na\nsum of distance between every node in tree a is = ca\nsum of distance of every node to root in tree a is = ra\nnumber of nodes in tree b = nb\nsum of distance between every node in tree b is = cb\nsum of distance of every node to root in tree b is = rb\n\n\nSo the distance between every node in the original tree is:\n ca + cb + (nb * ra + na * d * nb + na * rb))\n\nNow, we can calculate the sum of distance of every node in tree a or b using same approach. One thing to be careful is that, we have to choose such edge e such that the difference between the number of components isn't much. You can always find an edge in a tree that if you cut that edge, the difference between the number of nodes in resulting two trees won't be more than 1.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How can I add resilience to a minimum spanning tree?\r\n                \r\nI have a complete, weighted, undirected graph. The edge weights are the cost of a connection between two nodes, so the minimum spanning tree is the subset of the edges with the lowest total cost such that the graph remains connected.\n\nThe MST must be connected at all times, but unfortunately the connections aren't very reliable, so I would like to add redundancy to this graph/network.\n\nIs it possible to compute a subset of edges such that the total edge cost is minimised and edge-connectivity is over a certain minimum?\n\nI can see how it would be possible by bruteforcing, but I was looking for something more practical. I haven't been able to find much about this problem, I think mainly because I don't posses the vocabulary necessary to search.\n\nMy current idea is:\n\n\nCompute the MST\nWhile the it is still below a certain connectivity\n\n\nFind a node most below that connectivity\nActivate that node's edge with the lowest weight\n\n\n\nThe reason I don't find all the nodes below a certain connectivity all at once is because activating an edge may give another one enough connectivity.\n\nI'm pretty sure this does not yield 100% provably optimal networks, because with this method, it is possible to over-connect nodes (e.g. you activate k edges for a node, then another node activates more shared edges, making some of those k redundant). I hope that makes sense. \n\nAny tips would be much appreciated!\n    ", "Answer": "\r\nThe Wikipedia article on edge connected graphs ends with, A related problem: finding the minimum k-edge-connected spanning subgraph of G (that is: select as few as possible edges in G that your selection is k-edge-connected) is NP-hard for k >= 2.  They then cite a 1979 paper that shows it.\n\nTherefore I'd suggest taking a greedy approach, and tip-toeing away.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Give minimum permutation weight for edges such that a given set of edge is the Minimum Spanning Tree\r\n                \r\nQuestion:\nGiven a graph of N nodes and M edges, the edges are indexed from 1 -> M. It is guaranteed that there's a path between any 2 nodes.\nYou need to assign weights for M edges. The weights are in the range of [1...M], and each number can only occur once.\nTo be shorted, the answer should be a permutation array of [1...M], in which arr[i] = x means edge[i] has the weight of x.\nYou are given a set R of n-1 edges. R is guaranteed to be a Spanning Tree of the graph.\nFind a way to assign weights so that R is the Minimum Spanning Tree of the graph, if there are multiple answers, print the one with minimum lexicographical order.\nContraints:\n```\nN, M <= 10^6\n```\n\nExample:\nEdges:\n```\n3 4\n1 2\n2 3\n1 3\n1 4\n\nR = [2, 4, 5]\n```\n\n\n```\nAnswer: 3 4 5 1 2\n```\n\nExplaination:\nIf you assign weights for the graph like the above image, the MST would be the set R, and it has the smallest lexicographical order.\nMy take with O(N^2):\nSince it asks for the minimum lexicographical order, I traverse through the list of edges, assigning the weights in an increasing order. Intially, w = 1. There can be 3 situations:\n\nIf edge[i] is in R, assign weight[i] = w, increase w by 1\nIf edge[i] is not in R: say edge[i] connect nodes u and v. assign weight and increase w for each edge in the path from u to v in R (if that edge is not assigned yet). Then assign weight and increase w for edge[i]\nIf edge[i] is assigned, skip it\n\nIs there any way to improve my solution so that it can work in O(N.logN) or less?\n    ", "Answer": "\r\nYes, there's an O(m log m)-time algorithm.\nThe fundamental cycle of a non-tree edge e is comprised of e and the path in the tree between the endpoints of e. Given weights, the spanning tree is minimum if and only if, for every non-tree edge e, the heaviest edge in the fundamental cycle of e is e itself.\nThe lexicographic objective lends itself to a greedy algorithm, where we find the least valid assignment for edge 1, then edge 2 given edge 1, then edge 3 given the previous edges, etc. Here's the core idea: if the next unassigned edge is a non-tree edge, assign the next numbers to the unassigned tree edges in its fundamental cycle; then assign the next number.\nIn the example, edge 3-4 is first, and edges 1-3 and 1-4 complete its fundamental cycle. Therefore we assign 1-3 → 1 and 1-4 → 2 and then 3-4 → 3. Next is 1-2, a tree edge, so 1-2 → 4. Finally, 2-3 → 5 (1-2 and 1-3 are already assigned).\nTo implement this efficiently, we need two ingredients: a way to enumerate the unassigned edges in a fundamental cycle, and a way to assign numbers. My proposal for the former would be to store the spanning tree with the assigned edges contracted. We don't need anything fancy; start by rooting the spanning tree somewhere and running depth-first search to record parent pointers and depths. The fundamental cycle of e will be given by the paths to the least common ancestor of the endpoints of e. To do the contraction, we add a Boolean field indicating whether the parent edge is contracted, then use the path compression trick from disjoint-set forests. The work will be O(m log m) worst case, but O(m) average case. I think there's a strong possibility that the offline least common ancestor algorithms can be plugged in here to get the worst case down to O(m).\nAs for number assignment, we can handle this in linear time. For each edge, record the index of the edge that caused it to be assigned. At the end, stably bucket sort by this index, breaking ties by putting tree edges before non-tree. This can be done in O(m) time.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Give minimum permutation weight for edges such that a given set of edge is the Minimum Spanning Tree\r\n                \r\nQuestion:\nGiven a graph of N nodes and M edges, the edges are indexed from 1 -> M. It is guaranteed that there's a path between any 2 nodes.\nYou need to assign weights for M edges. The weights are in the range of [1...M], and each number can only occur once.\nTo be shorted, the answer should be a permutation array of [1...M], in which arr[i] = x means edge[i] has the weight of x.\nYou are given a set R of n-1 edges. R is guaranteed to be a Spanning Tree of the graph.\nFind a way to assign weights so that R is the Minimum Spanning Tree of the graph, if there are multiple answers, print the one with minimum lexicographical order.\nContraints:\n```\nN, M <= 10^6\n```\n\nExample:\nEdges:\n```\n3 4\n1 2\n2 3\n1 3\n1 4\n\nR = [2, 4, 5]\n```\n\n\n```\nAnswer: 3 4 5 1 2\n```\n\nExplaination:\nIf you assign weights for the graph like the above image, the MST would be the set R, and it has the smallest lexicographical order.\nMy take with O(N^2):\nSince it asks for the minimum lexicographical order, I traverse through the list of edges, assigning the weights in an increasing order. Intially, w = 1. There can be 3 situations:\n\nIf edge[i] is in R, assign weight[i] = w, increase w by 1\nIf edge[i] is not in R: say edge[i] connect nodes u and v. assign weight and increase w for each edge in the path from u to v in R (if that edge is not assigned yet). Then assign weight and increase w for edge[i]\nIf edge[i] is assigned, skip it\n\nIs there any way to improve my solution so that it can work in O(N.logN) or less?\n    ", "Answer": "\r\nYes, there's an O(m log m)-time algorithm.\nThe fundamental cycle of a non-tree edge e is comprised of e and the path in the tree between the endpoints of e. Given weights, the spanning tree is minimum if and only if, for every non-tree edge e, the heaviest edge in the fundamental cycle of e is e itself.\nThe lexicographic objective lends itself to a greedy algorithm, where we find the least valid assignment for edge 1, then edge 2 given edge 1, then edge 3 given the previous edges, etc. Here's the core idea: if the next unassigned edge is a non-tree edge, assign the next numbers to the unassigned tree edges in its fundamental cycle; then assign the next number.\nIn the example, edge 3-4 is first, and edges 1-3 and 1-4 complete its fundamental cycle. Therefore we assign 1-3 → 1 and 1-4 → 2 and then 3-4 → 3. Next is 1-2, a tree edge, so 1-2 → 4. Finally, 2-3 → 5 (1-2 and 1-3 are already assigned).\nTo implement this efficiently, we need two ingredients: a way to enumerate the unassigned edges in a fundamental cycle, and a way to assign numbers. My proposal for the former would be to store the spanning tree with the assigned edges contracted. We don't need anything fancy; start by rooting the spanning tree somewhere and running depth-first search to record parent pointers and depths. The fundamental cycle of e will be given by the paths to the least common ancestor of the endpoints of e. To do the contraction, we add a Boolean field indicating whether the parent edge is contracted, then use the path compression trick from disjoint-set forests. The work will be O(m log m) worst case, but O(m) average case. I think there's a strong possibility that the offline least common ancestor algorithms can be plugged in here to get the worst case down to O(m).\nAs for number assignment, we can handle this in linear time. For each edge, record the index of the edge that caused it to be assigned. At the end, stably bucket sort by this index, breaking ties by putting tree edges before non-tree. This can be done in O(m) time.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Combination of shortest path and minumum spanning tree\r\n                \r\nI've tried to do get minimum spanning tree of a undirected weighted graph.However, I need to find the shortest path between one or more pair of nodes.After that, I have to find minimum spanning tree of a graph. I've already found the shortest path between necessary nodes but I don't know how to find minimum spanning tree including these shortest paths. Let me give an example.\n\n```\n G\n |2 \n H      A\n |1     |6      \n F      ------B\n |1           | 7\n E -----D-----C\n    2      8    \n```\n\n\nThere is also an edge between A and E with 2 weight but I couldn't show it.\n\nNow, First of all I need to find shortest path between A and E(I have to do it because of my application) which is A-E-D-C and then, connect all graph with minimum spanning. Is there anyone to help me give some clue ? Sorry for bad English its not my native language  \n    ", "Answer": "\r\nJust an MST\n\nIf you just want the MST, this just involves running Kruskal's algorithm (see below) or Prim's algorithm:\n\n\n  \n  Initialize a tree with a single vertex, chosen arbitrarily from the graph.\n  Grow the tree by one edge: Of the edges that connect the tree to vertices not yet in the tree, find the minimum-weight edge, and transfer it to the tree.\n  Repeat step 2 (until all vertices are in the tree).\n  \n\n\nThis does not involve getting the shortest paths between vertices. In fact, it won't necessarily include some shortest paths. Consider:\n\n```\n  A\n1 |\\\n  B \\\n1 |  \\ 2\n  C   \\\n1 |    \\\n  D-----E\n     1\n```\n\n\nThe shortest path between A and E is 2 (just directly from A to E), but the MST (A-B-C-D-E) doesn't include that edge.\n\n'MST' including some shortest path\n\nIf you want to find the MST including some shortest path, this is a most interesting problem.\n\nThis can be solved by running Kruskal's algorithm with a minor variation.\n\nDerived from Wikipedia:\n\n\nCreate a forest F (a set of trees), where each vertex in the graph is a separate tree, excluding the vertices from the shortest path.\nAdd the shortest path as a single tree to the forest\nCreate a set S containing all the edges in the graph excluding the edges from the shortest path\nWhile S is nonempty and F is not yet spanning\n\nRemove an edge with minimum weight from S\nIf that edge connects two different trees, then add it to the forest, combining two trees into a single tree\nOtherwise discard that edge\n\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Add new edge to graph and find new spanning tree in O(n)\r\n                \r\nSuppose we are given the minimum spanning tree T of a given graph G (with n\nvertices and m edges) and a new edge e = (u, v) of weight w that we will add to G.\nGive an efficient algorithm to find the minimum spanning tree of the graph G + e.\nYour algorithm should run in O(n) time to receive full credit.\n\n(c) from Skiena manual\n\nStart Prim or Kruskal alg from u or v until we reach a fragment of the given spanning tree path?  Seems the new spanning tree won't change a lot from one new edge.\n    ", "Answer": "\r\nDetermine the path between the endpoints of the new edge in G. If the maximum length edge in that path is greater than that of the new edge, replace it with the new edge. This runs in O(N) time.\n\nSource: Trail Maintenance IOI 2003\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to add a new node to a Minimum Spanning Tree created via Kruskal Algorithm?\r\n                \r\nWe have a Minimum Spanning Tree of a graph that was created using the Kruskal Algorithm. We are supposed to add a new node to this graph. The connections and their values of this node are also known to us. We're asked to provide an algorithm that adds this new node to the MST too.\n\nMy first thought were: \"Isn't the answer simply \"Connect the new node to the nearest (the one it is connected to with the lightest connection) node available?\"\".\n\nBut then I realised that this wouldn't work in a situation like this one:\nA graph has nodes A and B connected by an edge with weight 100. The MST of this graph just contains this singular edge. Node C is added with an edge to A with weight 1 and an edge to B with weight 2.\nSimply adding the smallest edge adjacent to C to the the MST gives you a spanning tree with weight 101, where it is evident that the MST of this new graph should have weight 3.\n\nSo, what is the required algorithm here?\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum spanning trees on two graphs with some common edges\r\n                \r\nGiven two complete graphs with weighted edges, I would like to find two minimum spanning trees (MST) on the two graphs, respectively, under the constraint that the two learned MSTs have common edges on a given subset of edges. Note that the two graphs has same number of vertices but the edge weights are all different.\n\nFor example, if the two graphs are complete edge-weighted graphs with vertices {1,...,d}. We require the two learned MSTs has same edges on the complete subgraphs with vertices {1,...,d/2}.\n\nWhat algorithm can I use to find such MSTs? I tried using a modification of Kruskal's algorithm, but wasn't able to make it work.\n    ", "Answer": "\r\nNot sure I got the problem because the description lacks some important details.\nAnyway, here is a possible approach with the given constraints for it to be applayable.\n\nAs long as two graphs have the same number of edges and you can represent those graphs as lists of edges, the MRT algorithm can be used to find all their common spanning trees.\nIt is commonly referred to as the Two Graphs Common Spanning Trees Algorithm and it's described in an academic article of Mint, Read and Tarjan.\nNote that the Boost Graph Library already contains a proper implementation.\n\nOnce you have found those trees, you can iterate over them to drop the ones that are not minimum spanning trees for their respective graphs. Note that if you drop the i-th common spanning tree for the first graph, you should as well drop the i-th tree of the second graph.\nAfter that, in case the set is not empty, you can drop all those trees that don't contain the given subset of edges that are part of your problem (I didn't fully understand what you mean saying that an edge is in common to two graphs, but if it's a constraint you can enforce it on the resulting set).\nThe remaining trees are the ones you are looking for.\n\nIf the two graphs haven't the same number of edges, you can add fake nodes and edges to the smaller one.\nIn other terms, create a fake node nf-i and add an edge nf-i -> n-i, where n-i is a real node. Give to the edge a null weight.\nAt the end of the process, you can easily remove those nodes and edges and get back the original spanning trees.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Add new edge to graph and find new spanning tree\r\n                \r\nSuppose we are given the minimum spanning tree T of a given graph G (with n vertices and m edges) and a new edge e = (u, v) of weight w that we will add to G. \n\nI) Check if T remains a MST or not.\nII) If not, give an efficient algorithm to find the minimum spanning tree of the graph G + e.\n    ", "Answer": "\r\nYour current MST ```\nT```\n contains ```\nn-1```\n edges. The addition to your graph of the new edge ```\ne = (u,v)```\n with weight ```\nw```\n creates exactly one cycle ```\nC```\n in the graph ```\nT + e```\n (```\nT```\n with edge ```\ne```\n added). If the new edge weight (```\nw```\n) is less than the weight of the highest-weight edge in this cycle ```\nC```\n, then you can create a lower weight MST by replacing that higher-weight edge with ```\ne```\n. Otherwise, your current MST remains optimal.\n\nThe algorithm is basically this:\n\n\nFind the unique path ```\nP```\n from ```\nu```\n to ```\nv```\n in ```\nT```\n\nFind the edge ```\ne*```\n in ```\nP```\n that has maximum weight ```\nw*```\n\nIs ```\nw < w*```\n?\n\nIf so, then ```\nT' = T - e* + e```\n is the MST for ```\nG + e```\n,with ```\nweight(T') = weight(T) - w* + w```\n\nIf not, then ```\nT' = T```\n is the MST of ```\nG + e```\n\n\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Can two Minimum Spanning Trees for the same graph have different edge weights?\r\n                \r\nA graph can have many different Minimum Spanning Trees (MSTs), but can different MSTs have different sets of edge weights? For example, if an MST uses edge weights {2,3,4,5}, must every other MST have edge weights {2,3,4,5}, or can some other MST use a different collection of weights?\n\nWhat gave me the idea is property that a graph has no unique MST only if its edge weights are different.\n    ", "Answer": "\r\nThe sets must have the same weight. Here's a simple proof: suppose they don't. Let's let T1 and T2 be MSTs for some graph G with different multisets of edge weights.\n\nSort those edges into ascending order of weight. Since the two multisets of weights aren't the same, look at where the weights first diverge. There will end up being some smallest weight w* in either T1 or T2 (assume WLOG, that it's in T1) where T1 and T2 have the same number of edges of all weights less than w*, but T1 has more edges of weight w* than T2. Intuitively, edges of weight w* is where T1 \"gets ahead\" of T2.\n\nNow, consider the set of edges of weight w* in T1; let's call them W*. Consider what happens when you add any of those edges into T2. Every time we do this, it will close a cycle in T2. Note that the newly-added edge e can't be the maximum-weight edge on that cycle; if it were, then by the cycle property we'd be guaranteed that e can't appear in any MST, but we know for a fact that it is in one (namely, T1). Therefore, there must be some edge on the cycle whose weight is greater than or equal to w*.\n\nIf one of those edges has weight strictly greater than w*, then we can decrease the cost of T2 by deleting that edge. That would be impossible, though, because we know that T2 is an MST.\n\nTherefore, we know that there is some other edge in the cycle whose weight is equal to w*. If any of those edges are not in T1, then choose any one and remove it. Notice that we've just swapped an edge in T2 for an equal-weight edge in T1. Because there are more edges of weight w* in T1 than in T2, we can't do this forever and eventually we'll run into the case where the cycle was closed and all the max-weight edges are of weight w* and come from T1.\n\nSo what happens in this case? Well, think about the cycle C that was closed when we added the edge that triggered this. We're going to show that in this case, T1 can't be an MST, contradicting our initial assumption and giving us the result we want.\n\nLet C* be the set of edges in C that have cost less than w*. Process those edges in order of weight, adding them to T1 one at a time. Each time we do so, we close a cycle. The max-weight edge in that cycle can't be the edge we added from T2 (because otherwise by the cycle property that edge shouldn't have been in T2 in the first place). Therefore, either the max-weight edge either has weight greater than the edge from T2 (in which case we delete it, contradicting that T1 was an MST) or it has the same weight. Eventually, we end up transforming T1 so that it has the same set of edges of cost less than w* that T2 does. But that's a problem, because at that point we know that we would have the cycle C arising in T1, meaning that T1 isn't an MST. This gives us the contradiction we need.\n\nHope this helps!\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Finding Minimum spanning tree with an adjacency matrix with more than 1 connected component\r\n                \r\nI have an adjacency matrix built for one of my projects, and I need to be able to construct a minimum spanning tree out of that matrix. From reading around, it looks like Prim's algorithm is best for this case, however we cannot assume that the graph is one big connected component, since I know for a fact that at least one of the graphs we have to work on has about several thousand connected components. Is Prim's algorithm still viable here, and if it is, is there anything extra I need to do?\n\nI'm coding in Java here, and I can construct the adjacency matrix fine, it's just that I'm stuck on this part.\n    ", "Answer": "\r\nSo you mean there is a possibility there is no spanning tree? In which case prims is fine, you just need to add a check that there is a possible path in the selected columns. In the case that there is no spanning tree it will be complicated to try and do anything with it though, you'd have to delete all the vertices you've added to the tree and treat the remainder as a new graph.\n\nEdit: If you carry out prims by hand on a matrix (google 'D1 prims matrix') then it's easy to visualise what I mean by no arcs in the selected columns.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Spanning tree on grid with minimum number of turns\r\n                \r\nIs there a polynomial algorithm to find a spanning tree of an undirected grid graph which minimizes the number of turns in tree?\nA turn is when there are two edges connected to one vertex which have perpendicular directions.\n\nIn this problem we have arbitrary set of cells in grid which form a connected graph (not only rectangles are considered).\n\nFor example, given a 4 x 4 grid graph (see image below), we want to find a spanning tree like that on the right (which has 6 turns) rather than that on the left (which has 14):\n\n\n\nIdeas about approximate algorithms may be useful too.\n    ", "Answer": "\r\nI would try integer programming (translate the constraints and objective below to a format accepted by a solver like GLPK and let GLPK figure out the optimal solution).\n\nFor each vertex ```\nv```\n of the graph, there are up to 15 0-1 variables\n\n```\n         x(v, ╵), x(v, ╶), x(v, └),\n\nx(v, ╷), x(v, │), x(v, ┌), x(v, ├),\n\nx(v, ╴), x(v, ┘), x(v, ─), x(v, ┴),\n\nx(v, ┐), x(v, ┤), x(v, ┬), x(v, ┼),\n```\n\n\nwhere each variable is 1 if it describes the connections of ```\nv```\n in the spanning tree and zero otherwise. For each edge ```\nvw```\n, we have a 0-1 variable ```\ny(vw)```\n that is 1 if the edge is present.\n\nThe objective is to minimize\n\n```\nsum_{vertices v} (  x(v, └) +   x(v, ┌) +   x(v, ┘) +   x(v, ┐) +\n                  2 x(v, ├) + 2 x(v, ┴) + 2 x(v, ┤) + 2 x(v, ┬) +\n                  4 x(v, ┼)).\n```\n\n\nFor each vertex ```\nv```\n, we have a constraint\n\n```\nsum_{connections c} x(v, c) = 1,\n```\n\n\nbecause there is exactly one set of connections. For each edge ```\nvw```\n, we have constraints\n\n```\nsum_{connections c around v with vw} x(v, c) = y(vw),\nsum_{connections c around w with vw} x(w, c) = y(vw),\n```\n\n\nencoding the correspondence between the two sets of variables.\n\nThe difficult constraint is the connectivity constraint. In theory, we write this as\n\n```\nfor every subset S of vertices,\n    sum_{edges vw such that v in S and w not in S} y(vw) >= 1,\n```\n\n\ni.e., every cut has at least one edge crossing it, but in practice there are exponentially many of these, which is not good. I can think of three ways around this problem. From easiest to hardest,\n\n\nStarting with just the constraints above, solve the instance to optimality. Check whether the solution is connected with depth-first search. If not, add the corresponding constraint (e.g., ```\nS```\n is the set of visited vertices), and resolve.\nFormulate the connectivity constraint by adding variable that express the existence of ```\nn - 1```\n capacity-respecting unit flows between the endpoints of each edge of an arbitrary spanning tree of vertices. I can elaborate if you want to try this.\nLike Solution 1, but we find the cut inside the solver for the linear programming relaxation. This requires an implementation of max flow (since the edge variables can have any floating point value between 0 and 1) to find capacity of the min cut as well as hooks into the IP solver.\n\n\nWe don't need a no-cycles constraint. If a solution contains a cycle, then we can always eliminate a corner by deleting a cycle edge, so the optimal solution has no cycle.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to draw a dendrogram from a NetworkX minimum spanning tree?\r\n                \r\nI've computed a minimum spanning tree from a distance matrix, using NetworkX. I want now to build a dendrogram from it.\n\nMy MST :\n\n\nI've tried using the adjacency matrix (using NetworkX's to_pandas_adjacency)\n\n(T is my MST)\n\n```\ndf = nx.to_pandas_adjacency(T)\n\nfrom scipy.spatial.distance import squareform\ndist_array = squareform(df) #https://stackoverflow.com/questions/18952587/use-distance-matrix-in-scipy-cluster-hierarchy-linkage\n\nplt.figure(figsize=(10,10)) \nmergings = linkage(dist_array, method='complete', metric='euclidean')\ndendrogram(mergings, labels = distances.index, leaf_rotation=90, leaf_font_size=14)\nplt.show()\n```\n\n\nNow, as the adjacency matrix is filled with 0's for non-edges, I guess linkage compute Euclidean distance and end up with a 3 clusters dendrogram (where all the cluster's points are at 0 distance), while I'm expecting to get the same linkage as in my original MST !\n\n\n\nI tried using inf or large value for the nonedge default value to to_pandas_adjacency, but end up with invalid matrix...\n\nHelp anyone ? My best guess is that I'm not understanding and using linkage as I should...\n\nEdit\nI know, doing it the other way around (DT and then build the MST) might probably be easier, but I need to reproduce the order of operations in order to recreate the results of an original study...\n\nEdit 2\nSince the scipy's linkage function compute Euclidean distance between each point (or node here), I guess (but without any certainty) I need to find a way to convert my adjacency matrix to an array similar to what's linkage function output, ie weighted edge list, but with sub clusters size as fourth column.\n    ", "Answer": "\r\nI have a similar question and am trying to find a solution. It's the first time I've posted an answer, so please let me know if there is any issue.\nI suggest you use ```\nlinkage```\n and ```\ndendrogram```\n directly from ```\nscipy.cluster.hierarchy```\n rather than using the networkx package.\nYou first convert the distance matrix to a condensed distance matrix by ```\nscipy.spatial.distance.squareform```\n and then you use ```\nscipy.cluster.hierarchy.linkage```\n to obtain the clustering.\nThere are different distance functions you can use in ```\nlinkage```\n\nFinally you plot the clustering using ```\ndendrogram```\n.\nThe results shall be consistent with the minimum spanning tree in networkx.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Output a spanning tree given a directed graph\r\n                \r\nOnline resources say: a spanning tree of a directed graph can be found in O(|V|+|E|) time. Note that I'm not talking about the minimum spanning tree.\nI am looking for an algorithm that can find any one spanning tree given a digraph  D whose edges don't have any weights associated to them.\nI can't find any algorithms online. Please help.\n    ", "Answer": "\r\nPick any vertex as root, then proceed using a simple breadth-first search or depth-first Search to add adjacent vertices to your tree until every vertex has been visited once. Enforce visiting every vertex exactly once using a hash table (O(1) insert and lookup) to check previously visited vertices. That way you will achieve O(|V| + |E|) time complexity.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Implementing Union-Find Algorithm for Kruskal's Algorithm to find Minimum Spanning Tree in Java\r\n                \r\nI am trying to solve the following Leetcode problem (https://leetcode.com/problems/connecting-cities-with-minimum-cost), and my approach is to figure out the total weight of the minimum spanning tree (MST) from the input graph using Kruskal's Algorithm using the Union-Find data structure. However, my code online passes 51/63 of the test cases, returning the incorrect result on the following test case, which is too hard to debug, since the input graph is too large.\n```\n50\n[[2,1,22135],[3,1,13746],[4,3,37060],[5,2,48513],[6,3,49607],[7,1,97197],[8,2,95909],[9,2,82668],[10,2,48372],[11,4,17775],[12,2,6017],[13,1,51409],[14,2,12884],[15,7,98902],[16,14,52361],[17,8,11588],[18,12,86814],[19,17,49581],[20,4,41808],[21,11,77039],[22,10,80279],[23,16,61659],[24,12,89390],[25,24,10042],[26,12,78278],[27,15,30756],[28,6,2883],[29,8,3478],[30,7,29321],[31,12,47542],[32,20,35806],[33,3,26531],[34,12,16321],[35,27,82484],[36,7,55920],[37,24,21253],[38,23,90537],[39,7,83795],[40,36,70353],[41,34,76983],[42,14,63416],[43,15,39590],[44,9,86794],[45,3,31968],[46,19,32695],[47,17,40287],[48,1,27993],[49,12,86349],[50,11,52080],[17,27,65829],[42,45,87517],[14,23,96130],[5,50,3601],[10,17,2017],[26,44,4118],[26,29,93146],[1,9,56934],[22,43,5984],[3,22,13404],[13,28,66475],[11,14,93296],[16,44,71637],[7,37,88398],[7,29,56056],[2,34,79170],[40,44,55496],[35,46,14494],[32,34,25143],[28,36,59961],[10,49,58317],[8,38,33783],[8,28,19762],[34,41,69590],[27,37,26831],[15,23,53060],[5,11,7570],[20,42,98814],[18,34,96014],[13,43,94702],[1,46,18873],[44,45,43666],[22,40,69729],[4,25,28548],[8,46,19305],[15,22,39749],[33,48,43826],[14,15,38867],[13,22,56073],[3,46,51377],[13,15,73530],[6,36,67511],[27,38,76774],[6,21,21673],[28,49,72219],[40,50,9568],[31,37,66173],[14,29,93641],[4,40,87301],[18,46,41318],[2,8,25717],[1,7,3006],[9,22,85003],[14,45,33961],[18,28,56248],[1,31,10007],[3,24,23971],[6,28,24448],[35,39,87474],[10,50,3371],[7,18,26351],[19,41,86238],[3,8,73207],[11,34,75438],[3,47,35394],[27,32,69991],[6,40,87955],[2,18,85693],[5,37,50456],[8,20,59182],[16,38,58363],[9,39,58494],[39,43,73017],[10,15,88526],[16,23,48361],[4,28,59995],[2,3,66426],[6,17,29387],[15,38,80738],[12,43,63014],[9,11,90635],[12,20,36051],[13,25,1515],[32,40,72665],[10,40,85644],[13,40,70642],[12,24,88771],[14,46,79583],[30,49,45432],[21,34,95097],[25,48,96934],[2,35,79611],[9,26,71147],[11,37,57109],[35,36,67266],[42,43,15913],[3,30,44704],[4,32,46266],[5,10,94508],[31,39,45742],[12,25,56618],[10,45,79396],[15,28,78005],[19,32,94010],[36,46,4417],[6,35,7762],[10,13,12161],[49,50,60013],[20,23,6891],[9,50,63893],[35,43,74832],[10,24,3562],[6,8,47831],[29,32,82689],[7,47,71961],[14,41,82402],[20,33,38732],[16,26,24131],[17,34,96267],[21,46,81067],[19,47,41426],[13,24,68768],[1,25,78243],[2,27,77645],[11,25,96335],[31,45,30726],[43,44,34801],[3,42,22953],[12,23,34898],[37,43,32324],[18,44,18539],[8,13,59737],[28,37,67994],[13,14,25013],[22,41,25671],[1,6,57657],[8,11,83932],[42,48,24122],[4,15,851],[9,29,70508],[7,32,53629],[3,4,34945],[2,32,64478],[7,30,75022],[14,19,55721],[20,22,84838],[22,25,6103],[8,49,11497],[11,32,22278],[35,44,56616],[12,49,18681],[18,43,56358],[24,43,13360],[24,47,59846],[28,43,36311],[17,25,63309],[1,14,30207],[39,48,22241],[13,26,94146],[4,33,62994],[40,48,32450],[8,19,8063],[20,29,56772],[10,27,21224],[24,30,40328],[44,46,48426],[22,45,39752],[6,43,96892],[2,30,73566],[26,36,43360],[34,36,51956],[18,20,5710],[7,22,72496],[3,39,9207],[15,30,39474],[11,35,82661],[12,50,84860],[14,26,25992],[16,39,33166],[25,41,11721],[19,40,68623],[27,28,98119],[19,43,3644],[8,16,84611],[33,42,52972],[29,36,60307],[9,36,44224],[9,48,89857],[25,26,21705],[29,33,12562],[5,34,32209],[9,16,26285],[22,37,80956],[18,35,51968],[37,49,36399],[18,42,37774],[1,30,24687],[23,43,55470],[6,47,69677],[21,39,6826],[15,24,38561]]\n```\n\nI'm having trouble understanding why my code will fail a test case, since I believe I am implementing the steps of Kruskal's Algorithm propertly:\n\nSorting the connections in increasing order of weight.\nBuilding the MST by going through each connection in the sorted list and selecting that connection if it does not result in a cycle in the MST.\n\nBelow is my Java code:\n```\nclass UnionFind {\n    // parents[i] = parent node of node i.\n    // If a node is the root node of a component, we define its parent\n    // to be itself.\n    int[] parents;\n    \n    public UnionFind(int n) {\n        this.parents = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            this.parents[i] = i;\n        }\n    }\n    \n    // Merges two nodes into the same component.\n    public void union(int node1, int node2) {\n        int node1Component = find(node1);\n        int node2Component = find(node2);\n        \n        this.parents[node1Component] = node2Component;\n    }\n    \n    // Returns the component that a node is in.\n    public int find(int node) {\n        while (this.parents[node] != node) {\n            node = this.parents[node];\n        }\n        \n        return node;\n    }\n}\n\nclass Solution {\n    public int minimumCost(int n, int[][] connections) {\n        UnionFind uf = new UnionFind(n + 1);\n        \n        // Sort edges by increasing cost.\n        Arrays.sort(connections, new Comparator<int[]>() {\n            @Override\n            public int compare(final int[] a1, final int[] a2) {\n                return a1[2] - a2[2];\n            }\n        });\n        \n        int edgeCount = 0;\n        int connectionIndex = 0;\n        int weight = 0;\n        \n        // Greedy algorithm: Choose the edge with the smallest weight \n        // which does not form a cycle. We know that an edge between \n        // two nodes will result in a cycle if those nodes are already \n        // in the same component.\n        for (int i = 0; i < connections.length; i++) {\n            int[] connection = connections[i];\n            int nodeAComponent = uf.find(connection[0]);\n            int nodeBComponent = uf.find(connection[1]);\n            \n            if (nodeAComponent != nodeBComponent) {\n                weight += connection[2];\n                edgeCount++;\n            }\n            \n            if (edgeCount == n - 1) {\n                break;\n            }\n        }\n        \n        // MST, by definition, must have (n - 1) edges.\n        if (edgeCount == n - 1) {\n            return weight;\n        }\n        return -1;\n    }\n}\n```\n\n    ", "Answer": "\r\nAs @geobreze stated, I forgot to unite the components (disjoint sets) of node A and node B. Below is the corrected code:\n```\nif (nodeAComponent != nodeBComponent) {\n    uf.union(nodeAComponent, nodeBComponent);\n    weight += connection[2];\n    edgeCount++;\n}\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How can a heap be used to optimizie Prim's minimum spanning tree algorithm?\r\n                \r\nI have to solve a question that is something like this:\nI am given a number N which represents the number of points I have. Each point has two coordinates: X and Y. \n\nI can find the distance between two points with the following formula:\nabs(x2-x1)+abs(y2-y1),\n(x1,y1) being the coordinates of the first point, (x2,y2) the coordinates of the second point and ```\nabs()```\n being the absolute value.  \n\nI have to find the minimum spanning tree, meaning I must have all my points connected with the sum of the edges being minimal. Prim's algorithm is good, but it is too slow. I read that I can make it faster using a heap but I didn't find any article that explains how to do that. \n\nCan anyone explain me how Prim's algorithm works with a heap(some sample code would be good but not neccesarily), please?\n    ", "Answer": "\r\nIt is possible to solve this problem efficiently(in ```\nO(n log n)```\n time), but it is not that easy. Just using the Prim's algorithm with a heap does not help(it actually makes it even slower), because its time complexity is ```\nO(E log V)```\n, which is ```\nO(n^2 * log n)```\n in this case.\n\nHowever, you can use the Delaunay triangulation to reduce the number of edges in the graph. The Delaunay triangulation graph is planar, so it has linear number of edges. That's why running the Prim's algorithm with a heap on it gives ```\nO(n log n)```\n time complexity(there are ```\nO(n)```\n edges and ```\nn```\n vertices).  You can read more about it here(covering this algorithm in details and proving its correctness would make my answer way too long): http://en.wikipedia.org/wiki/Euclidean_minimum_spanning_tree. Note that even though the article is about the Euclidian mst, the approach for your case is essentially the same(it is possible to build the Delaunay triangulation for manhattan distance efficiently, too).\n\nA description of the Prim's algorithm with a heap itself is already present in two other answers to your question.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Find a minimum spanning tree\r\n                \r\nCould you please tell me why this MATLAB code is wrong? I don't understand why. Thank you so much in advance.\n\n```\nfunction [mst, cost] = prim(A)\n[n,n] = size(A);                           \nA, n, pause,\n\nif norm(A-A','fro') ~= 0 ,                 \n  disp(' Error:  Adjacency matrix must be symmetric ') \n  return,\nend;\n\nintree = [1];  number_in_tree = 1;  \nnumber_of_edges = 0;\nnotintree = [2:n]';  number_notin_tree= n-1;\n\nin = intree(1:number_in_tree),                \nout = notintree(1:number_notin_tree),\npause, \n\nwhile number_in_tree < n,\n  mincost = Inf;                             \n  for i=1:number_in_tree,               \n    for j=1:number_notin_tree,\n      ii = intree(i);  jj = \n      notintree(j);\n      if A(ii,jj) < mincost, \n        mincost = A(ii,jj); jsave = j; \n        iisave = ii; jjsave = jj;   \n      end;\n    end;\n  end;\n\n  number_of_edges = number_of_edges +1;      \n  mst(number_of_edges,1) = iisave;            \n  mst(number_of_edges,2) = jjsave;\n  costs(number_of_edges,1) = mincost;\n\n  number_in_tree = number_in_tree + 1;        \n  intree = [intree; jjsave];                  \n  for j=jsave+1:number_notin_tree,            \n    notintree(j-1) = notintree(j);\n  end;\n  number_notin_tree = number_notin_tree - 1;  \n\n  in = intree(1:number_in_tree),              \n  out = notintree(1:number_notin_tree), \n  pause,\nend;\n\ndisp(' Edges in minimum spanning tree and their costs: ')\n[mst  costs]                                 \ncost = sum(costs)\n```\n\n\nWhen I click the run button  says:\n\n```\nNot enough input arguments.\n\nError in prim (line 10)\n[n,n] = size(A);\n% The matrix is n by n, where n = # nodes.\n```\n\n\nHowever when I call the function in the Command window with\n\n```\ns=[1 1 2 2 2 3 3 4 4 4 5 5 6 7];\nt=[2 3 4 5 3 5 6 5 7 8 6 8 7 8];\nw=[3 5 4 7 4 9 8 3 11 8 3 9 8 7];\nG = graph(s,t,w);\nA = adjacency(G);\nprim(A)\n```\n\n\nThe code works 'correctly'\n\nAs a final answer returns\n\nmst =\n\n```\ncost=```\n\n\n```\nAll zero sparse: 1-by-1```\n\n\n\n  It should have returned\n  \n  mst=\n  \n  1   2\n  \n  2   3\n  \n  2   4\n  \n  4   5\n  \n  5   6\n  \n  6   7\n  \n  7   8\n  \n  costs=32\n\n\n\n\nWhy did not returned that?\n\nWhilst running the program went from 1 to 4 though it should have gone to 2. Then from 4  to 5, that was correct but I don't know why skipped 2 and 3 and went directly to 4,5,6,7,8.\n\nHelp me please.\n\n\n\nIf there is an alternative code that you know please provide it, perhaps an easier one.\n    ", "Answer": "\r\nThe main problem with your function is that when you check to see if the current edge has lower cost than ```\nmincost```\n, you don't verify that there's actually an edge there. If there's no edge, then the cost will be ```\n0```\n, which is naturally lower than any positive cost value. You need to change the line:\n\n```\nif A(ii,jj) < mincost, \n```\n\n\nto\n\n```\nif (A(ii,jj) > 0) && (A(ii,jj) < mincost), % A(ii,jj) is edge and lower cost than mincost\n```\n\n\nAdjacency matrix used as input:\n\n```\nA =\n\n    0    3    5    0    0    0    0    0\n    3    0    4    4    7    0    0    0\n    5    4    0    0    9    8    0    0\n    0    4    0    0    3    0   11    8\n    0    7    9    3    0    3    0    9\n    0    0    8    0    3    0    8    0\n    0    0    0   11    0    8    0    7\n    0    0    0    8    9    0    7    0\n```\n\n\nThe output after this change is:\n\n```\nmst =\n\n   1   2\n   2   3\n   2   4\n   4   5\n   5   6\n   4   8\n   8   7\n\ncost =  32\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Special minimum spanning tree\r\n                \r\nThere is a node that can only get one line, I use both kruskal and prim, but the judger said TLE(Time Limit Exceed).\nThen I will describe the question. There are many computers, we need to connect all of them, we give the cost of connection between different computers, also we give the special number of computer which can be only connected by one line. Finally, we guarantee there is a answer and there is no Self-Loop, but there may have multiple edge which have different weight between same node.\nHere is my kruskal code, it's TLE.\n\n```\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef struct edge{\n    int start;\n    int end;\n    int weight;\n}Edge;\n\nint special = 0;\nint edgenum;\nEdge _edge[600005];\nint i, j, k;\nint counter = 0;\n\nbool Cmp(const edge &a, const edge &b){\n    return a.weight < b.weight;\n}\n\nint getEnd(int vends[], int i){\n    while(vends[i] != 0)\n        i = vends[i];\n    return i;\n}\n\nvoid kruskal(){\n    int p1, p2, m, n, ans = 0;\n    int vends[10005] = {0};\n    sort(_edge, _edge+counter, Cmp);\n    for(i = 0; i < edgenum; ++i){\n        p1 = _edge[i].start;\n        p2 = _edge[i].end;\n        if ((p1 == k || p2 == k) && special)\n            continue;\n\n        m = getEnd(vends, p1);\n        n = getEnd(vends, p2);\n\n        if(m != n){\n            if (p1 == k || p2 == k)\n                special = 1;\n            vends[m] = n;\n            ans += _edge[i].weight;\n        }\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    int n, m;\n    cin >> n >> m >> k;\n    edgenum = m;\n    while(m--){\n        int a, b, c;\n        cin >> a >> b >> c;\n        _edge[counter].start = a;   //Get the Edge\n        _edge[counter].weight = c;\n        _edge[counter++].end = b;\n//        _edge[counter].start = b;\n//        _edge[counter].weight = c;\n//        _edge[counter++].end = a;\n    }\n    kruskal();\n}\n```\n\n\nHere is my Prim, but also TLE:\n\n```\n#include <iostream>\n\nusing namespace std;\n\ntypedef char VertexType;\n\ntypedef struct node{\n    int adjvex = 0;\n    int weight = INT32_MAX;\n    struct node *next = NULL;\n}Node;\n\ntypedef struct vnode{\n    VertexType data;\n    Node *firstnode = NULL;\n}Vnode;\n\nVnode node[10005];\nint VNUM;\nint n, m, k;\nint lowcost[10005] = {0};\nint addvnew[10005];  //未加入最小生成树表示为-1，加入则为0\nint adjecent[10005] = {0};\nbool is_special = false;\nint flag;\n\nvoid prim(int start){\n    long long sumweight = 0;\n    int i, j;\n    Node *p = node[start].firstnode;\n\n    for (i = 1; i <= VNUM; ++i) {   //重置\n        addvnew[i] = -1;\n    }\n\n    while (p->next != NULL){\n        if (lowcost[p->adjvex] == 0 || p->weight < lowcost[p->adjvex])\n            lowcost[p->adjvex] = p->weight;\n        p = p->next;\n    }\n    if (lowcost[p->adjvex] == 0 || p->weight < lowcost[p->adjvex])\n        lowcost[p->adjvex] = p->weight;\n\n    addvnew[start] = 0;\n//    adjecent[start] = start;\n    if (start == k) {\n        is_special = true;\n        flag = 1;\n    }\n\n    for (i = 1; i < VNUM; ++i) {\n        int min = INT32_MAX;\n        int v=-1;\n        for (j = 1; j <= VNUM; ++j) {   //Find the min\n            if (addvnew[j] == -1 && lowcost[j] < min && lowcost[j] != 0){\n                min = lowcost[j];\n                v = j;\n            }\n        }\n        if (v != -1){   //if min is found\n            if (flag == 1){\n                for (int l = 0; l < 10005; ++l) {\n                    lowcost[l] = 0;\n                }\n                flag = 0;\n            }\n\n            addvnew[v] = 0;\n\n            sumweight += min;\n\n            p = node[v].firstnode;\n            while(p->next != NULL){\n                if (is_special && p->adjvex == k){  //If find the special node\n                    p = p->next;\n                    continue;\n                }\n                if(addvnew[p->adjvex] == -1 && (lowcost[p->adjvex] == 0 || p->weight < lowcost[p->adjvex])){    //如果该点未连接\n                    lowcost[p->adjvex] = p->weight;\n                }\n                p = p->next;\n            }\n            if (!(is_special && p->adjvex == k))\n                if(addvnew[p->adjvex] == -1 && (lowcost[p->adjvex] == 0 || p->weight < lowcost[p->adjvex])){\n                    lowcost[p->adjvex] = p->weight;\n                }\n        }\n    }\n    cout << sumweight << endl;\n}\n\nint main(){\n    cin >> n >> m >> k;\n    VNUM = n;\n    while (m--){\n        int a, b, c;\n        cin >> a >> b >> c;\n        Node *p = (Node*)malloc(sizeof(Node));\n        p->adjvex = b;\n        p->weight = c;\n        p->next = node[a].firstnode;\n        node[a].firstnode = p;\n        Node *q = (Node*)malloc(sizeof(Node));\n        q->adjvex = a;\n        q->weight = c;\n        q->next = node[b].firstnode;\n        node[b].firstnode = q;\n    }\n    prim(k);\n}\n```\n\n\nI don't know how to modify the both code, I try my best, thank you\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Construct an efficient, minimum spanning tree such that given subset of vertices in G are leaves + proof\r\n                \r\nI am trying to design an algorithm where, given a connected weighted graph G = (V, E) and a subset of vertices U that is in V, will construct a minimum spanning tree such that all vertices in U are leaves (other vertices may also be leaves), or returns that no such tree exists (False).\nThis is all I got, adapting Prim's algorithm (fair warning, its really bad; don't even know if it works/is efficient or what data structures to use, I will accept literally any other correct algorithm instead):\n```\nLet x be an arbitrary node in G\nSet S = {x}\nWhile S != V:\n    Let (u,v) be the cheapest edge with u in S and v not in S\n    Add (u,v) to tree T if u is not in U, add v to S\n\nIf all u in U is in the tree T:\n    return T\nElse:\n    return False\n```\n\nI also have a picture of what I think it would do to this graph I drew:\npic here\nA proof that the algorithm is correct would also give me some peace of mind.\n    ", "Answer": "\r\nIf all vertices ```\nu ∈ U```\n are to be leaves in a solution, no ```\nu```\n can be used in that solution to connect two other vertices. All vertices not in ```\nU```\n must be connected by edges not incident to any ```\nu```\n.\nRemove ```\nU```\n and all edges incident to ```\nU```\n. Find the minimum spanning tree, then connect each ```\nu```\n to the tree by the smallest-weighted edge available from those we removed.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum Spanning Tree issue\r\n                \r\nI found this code online but some parts were missing. I have added statsmodels.api\n\n```\nimport requests        # for making http requests to binance\nimport json            # for parsing what binance sends back to us\nimport pandas as pd    # for storing and manipulating the data we get back\nimport numpy as np     # numerical python, i usually need this somewhere \n                   # and so i import by habit nowadays\n\nimport statsmodels.api as sm\n\nimport matplotlib.pyplot as plt # for charts and such\n\nimport datetime as dt  # for dealing with times\n\ndef get_bars(symbol, interval = '1h'):\n   root_url = 'https://api.binance.com/api/v1/klines'\n   url = root_url + '?symbol=' + symbol + '&interval=' + interval\n   data = json.loads(requests.get(url).text)\n   df = pd.DataFrame(data)\n   df.columns = ['open_time',\n             'o', 'h', 'l', 'c', 'v',\n             'close_time', 'qav', 'num_trades',\n             'taker_base_vol', 'taker_quote_vol', 'ignore']\n   df.index = [dt.datetime.fromtimestamp(x/1000.0) for x in df.close_time]\n   return df\n\nsymbols = \njson.loads(requests.get(\"https://api.binance.com/api/v1/exchangeInfo\").text)\nsymbols = [symbol['symbol'] for symbol in symbols['symbols'] if \nsymbol['quoteAsset'] == 'ETH']\n\nethusdt = get_bars('ETHUSDT')\n\nprice_data = []\nnew_symbols = []\nfor symbol in symbols:\n    print(symbol)\n    data = get_bars(symbol)\n    new_symbols.append(symbol.replace('ETH','USDT'))\n    price_data.append(data['c'].astype('float') * \nethusdt['c'].astype('float'))\n\ncombo = pd.concat(price_data, axis = 1)\ncombo.columns = new_symbols\n\nmst = sm.MinimumSpanningTree(dataset = np.log(combo).diff().T)\n```\n\n\nWhen running the code I'm getting this error. What's the issue here?\n\n```\nmst = sm.MinimumSpanningTree(dataset = np.log(combo).diff().T)\nAttributeError: module 'statsmodels.api' has no attribute 'MinimumSpanningTree'\n```\n\n    ", "Answer": "\r\nI installed statsmodels and ran solutions from here to look for the tree.  I also did a directory search for the package in my installation area and followed with a listing of all contained files; the only file with \"tree\" in the file name or contents is ```\nsandbox/regression/treewalkerclass.py```\n.\n\nI tentatively conclude that there is, indeed, no such attribute in the current release (0.9.0) of ```\nstatsmodels```\n.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Does Kruskal's algorithm find the minimum bottleneck spanning tree? if so how do we prove correctness?\r\n                \r\nHow would you prove Kruskal's algorithm always produces a minimum bottleneck spanning tree?\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Create Minimum Spanning Tree from Adjacency Matrix using Prims Algorithm\r\n                \r\nI want to implement Prims algorithm to find the minimal spanning tree of a graph. I have written some code to start with what I think is the way to do it, but Im kind of stuck on how to complete this. \n\nRight now, I have a matrix stored in matrix[i][j], which is stored as a vector>. I have also a list of IP address stored in the variable ip. (This becomes the labels of each column/row in the graph) \n\n```\nint n = 0;\nfor(int i = 0; i<ip.size();i++) // column\n{\n    for(int j = ip.size()-1; j>n;j--)\n    {\n        if(matrix[i][j] > 0)\n        {\n            edgef test;\n            test.ip1 = ip[i];\n            test.ip2 = ip[j];\n            test.w = matrix[i][j];\n            add(test);\n        }\n    }\n    n++;\n\n\n}\n```\n\n\nAt the moment, this code will look into one column, and add all the weights associated with that column to a binary min heap. What I want to do is, dequeue an item from the heap and store it somewhere if it is the minimum edge weight. \n\n```\nvoid entry::add(edgef x)\n{\nint current, temp;\ncurrent = heap.size();\nheap.push_back(x);\nif(heap.size() > 1)\n{\n    while(heap[current].w < heap[current/2].w) // if child is less than parent, min heap style\n    {\n        edgef temp = heap[current/2]; // swap\n        heap[current/2] = heap[current];\n        heap[current] = temp;\n\n        current = current/2;  \n    }\n}\n\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Find solution minimum spanning tree (with conditions) when extending graph\r\n                \r\nI have a logic question, therefore chose from two explanations:\n\nMathematical: \nI have a undirected weighted complete graph over 2-14 nodes. The nodes always come in pairs (startpoint to endpoint). For this I already have the minimum spanning tree, which considers that the pairs startpoint always comes before his endpoint. Now I want to add another pair of nodes.\n\nReal life explanation:\nI already have a optimal taxi route for 1-7 people. Each joins (startpoint) and leaves (endpoint) at different places. Now I want to find the optimal route when I add another person to the taxi. I have already the calculated subpaths from each point to each point in my database (therefore this is a weighted graph). All calculated paths are real value, not heuristics.\n\n\n\nNow I try to find the most performant solution to solve this. My current idea:\n\n\nFind the point nearest to the new startpoint. Add it a) before and b) after this point. Choose the faster one.\nFind the point nearest to the new endpoint. Add it a) before and b) after this point. Choose the faster one.\n\n\nIgnoring the case that the new endpoint comes before the new start point, this seams feasible.\nI expect that the general direction of the taxi is one direction, this eliminates the following edge case.\n\n\nIs there any case I'm missing in which this algorithm wouldn't calculate the optimal solution?\n    ", "Answer": "\r\nThere are definitely many cases were this algorithm (which is a First Fit construction heuristic) won't find the optimal solution. Given a reasonable sized dataset, in my experience, I would guess to get improvements of 10-20% by simply taking that result and adding metaheuristics (or other optimization algo's).\n\nExplanation:\n\nIf you have multiple taxis with a limited person capacity, it has an inherit bin packing problem, which is NP-complete (which is proven to be suboptimally solved by all known construction heuristics in P).\n\nBut even if you have just 1 taxi, it is similar to TSP: if you have the optimal solution for 10 locations and add 1 location, it can create a snowball effect in the optimal solution to make the optimal solution look completely different. (sorry, no visual image of this yet)\n\nAnd if you need to any additional constraints on top of that later on, you need to be aware of these false assumptions.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Is it right : all edge weights are positive, then any that connects all vertices and has minimum total weight must be a minimum spanning tree?\r\n                \r\nThis problem is evolved from the exercise 23.1-7 of introduction to algorithms.\n\nThe original problem is:\n\n23.1-7\nArgue that if all edge weights of a graph are positive, then any subset of edges that connects all vertices and has minimum total weight must be a tree. Give an example to show that the same conclusion does not follow if we allow some weights to be nonpositive.\n\nBut I think if all edges weights of a graph are positive, then any subset of edges that connects all vertices and has a minimum total weight must be a minimum spanning tree. \n\nIs my corollary right ? If not, please give me a counterexample.\n    ", "Answer": "\r\nI think your corollary is equivalent to the statement that you are asked to prove. A spanning tree is a subset of edges such that all vertices are connected without any cycles (so it's a tree). If it's a minimum spanning tree, then the total weight of the edges is minimized. \n\nSo yes, your corollary is correct, but you haven't proved the statement. Hint: a tree doesn't contain any cycles, so try to make a proof by contradiction by assuming that you have a subset connecting all vertices with minimum total weight that has a cycle. \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "c++ Prim minimum spanning tree using Boost Library\r\n                \r\nI am working on a project where I need to implement Dijkstra's, Prim's and A* algorithms on an input file my professor will provide.  I have successfully written working code for Dijkstra's but I am hitting a wall trying to get my same graph to work for Prim's as well.  I feel like my problem is not properly having a min spanning tree map to pull my info from but I cant really wrap my head around what the problem is, any help would be greatly appreciated.\n\nstructs and graph traits for edges and verts:\n\n```\ntypedef boost::adjacency_list_traits<vecS, vecS, undirectedS, listS> GraphTraits;\n// type 'Vertex' identifies each vertex uniquely:\ntypedef GraphTraits::vertex_descriptor Vertex;\n// Property type associated to each vertex:\nstruct VertexProperty {\n    string name;  // Name of vertex (i.e., \"location\")\n    Vertex predecessor; // Predecessor along optimal path.\n    double distance; // Distance to the goal, along shortest path.\n    default_color_type color; // for use by dijkstra.\n    VertexProperty(const string& aName = \"\") : name(aName) { };\n};\n// Property type associated to each edge:\nstruct EdgeProperty {\n    double weight; // distance to travel along this edge.\n    EdgeProperty(double aWeight = 0.0) : weight(aWeight) { };\n};\n// Type of the graph used:\ntypedef adjacency_list<vecS, vecS, undirectedS, VertexProperty, EdgeProperty> Graph;\n// Create a global graph object 'g'\nGraph g;\n// This is a visitor for the dijkstra algorithm. This visitor does nothing special.\nstruct do_nothing_dijkstra_visitor {\n    template <typename Vertex, typename Graph>\n    void initialize_vertex(Vertex u, const Graph& g) const { };\n    template <typename Vertex, typename Graph>\n    void examine_vertex(Vertex u, const Graph& g) const { };\n    template <typename Edge, typename Graph>\n    void examine_edge(Edge e, const Graph& g) const { };\n    template <typename Vertex, typename Graph>\n    void discover_vertex(Vertex u, const Graph& g) const { };\n    template <typename Edge, typename Graph>\n    void edge_relaxed(Edge e, const Graph& g) const { };\n    template <typename Edge, typename Graph>\n    void edge_not_relaxed(Edge e, const Graph& g) const { };\n    template <typename Vertex, typename Graph>\n    void finish_vertex(Vertex u, const Graph& g) const { };\n};\n```\n\n\nVariables:\n\n```\nstring tempName1, tempName2, tempString, data2;\nint weight;\nstring inputFile;\nint choice;\nVertex cur_v, start_v, goal_v;\nmap<string, Vertex> name2v, name1v;\ndouble totalDist, tempDist;\nint numVert = 0;\n```\n\n\nGraph constructions based on file uploaded:\n\n```\n            //build graph based on file loaded\n            getline(fin, tempString); \n            getline(fin, tempString);\n            stringstream tempSS(tempString);\n            while (getline(tempSS, tempName1, ',')) {\n                name2v[tempName1] = add_vertex(VertexProperty(tempName1), g);\n                numVert++;\n            }\n            getline(fin, tempString);\n            while (getline(fin, tempString)) {\n                tempString.erase(tempString.begin(), tempString.begin() + tempString.find('(') + 1);\n                tempString.erase(tempString.begin() + tempString.find(')'), tempString.end());\n                stringstream temp_ss(tempString);\n                getline(temp_ss, tempName1, ',');\n                getline(temp_ss, tempName2, ',');\n                temp_ss >> weight;\n                add_edge(name2v[tempName1], name2v[tempName2], EdgeProperty(weight), g);\n            }\n            name1v = name2v;\n```\n\n\nPrim's call:\n\n```\ncout << \"Please enter the Vertex you would like to start at: \";\n            cin >> tempName1;\n            transform(tempName1.begin(), tempName1.end(), tempName1.begin(), ::toupper);\n            start_v = name1v[tempName1];\n            prim_minimum_spanning_tree(g, start_v, \n                get(&VertexProperty::predecessor, g), \n                get(&VertexProperty::distance, g),\n                get(&EdgeProperty::weight, g), \n                identity_property_map(), \n                do_nothing_dijkstra_visitor());\n```\n\n\nI tried to just include the code that matters.  Like I said this code will work for Dijkstra but I am not sure how to make it work for Prim's.  I am thinking I need to add more to the struct for the VertexProperty or have a map to store the min spannning tree.  Thanks in advance.\n    ", "Answer": "\r\nI don't see what exactly you are asking (aside from code style and quality issues).\n\nHere it is, note\n\n\nthe reduced visitor\nremoved confusing comments\nand of course that I'm generating a random graph here because we don't have your input\n\n\nLive On Coliru\n\n```\n#include <boost/graph/adjacency_list.hpp>\n#include <boost/graph/graph_utility.hpp>\n#include <boost/graph/prim_minimum_spanning_tree.hpp>\n#include <boost/graph/random.hpp>\n#include <fstream>\n#include <map>\n#include <random>\n#include <sstream>\n\ntypedef boost::adjacency_list_traits<boost::vecS, boost::vecS, boost::undirectedS> GraphTraits;\ntypedef GraphTraits::vertex_descriptor Vertex;\n\nstruct DijkstraStuff {\n    Vertex predecessor;\n    double distance;\n    boost::default_color_type color; // for use by dijkstra.\n};\n\nstruct VertexProperty : DijkstraStuff {\n    std::string name;\n    VertexProperty(const std::string &aName = \"\") : name(aName){};\n};\n\nstruct EdgeProperty {\n    double weight; // distance to travel along this edge.\n    EdgeProperty(double aWeight = 0.0) : weight(aWeight){};\n};\n\ntypedef boost::adjacency_list<boost::vecS, boost::vecS, boost::undirectedS, VertexProperty, EdgeProperty> Graph;\n\nstruct do_nothing_dijkstra_visitor : boost::default_dijkstra_visitor {};\n\nint main() {\n    Graph g;\n    std::map<std::string, Vertex> name_map;\n\n    // read graph (random for now)\n    {\n        std::mt19937 prng{ 42 };\n        generate_random_graph(g, 10, 20, prng);\n\n        for (auto vd : boost::make_iterator_range(vertices(g))) {\n            name_map[g[vd].name = \"NAME\" + std::to_string(vd)] = vd;\n        }\n\n        std::uniform_real_distribution<double> weight_dist(0, 1);\n        for (auto ed : boost::make_iterator_range(edges(g))) {\n            g[ed].weight = weight_dist(prng);\n        }\n    }\n\n    print_graph(g, get(&VertexProperty::name, g));\n\n    Graph::vertex_descriptor start_v;\n\n    std::cout << \"Please enter the Vertex you would like to start at: \";\n    {\n        std::string startName;\n        std::cin >> startName;\n        std::transform(startName.begin(), startName.end(), startName.begin(),\n                       [](uint8_t ch) { return std::toupper(ch); });\n        start_v = name_map.at(startName);\n    }\n\n    boost::prim_minimum_spanning_tree(g, start_v, get(&VertexProperty::predecessor, g),\n          get(&VertexProperty::distance, g), get(&EdgeProperty::weight, g),\n          boost::identity_property_map(), do_nothing_dijkstra_visitor());\n\n\n}\n```\n\n\nPrinting the result\n\nThe resulting MST is encoded as the predecessor map. Print it as follows:\n\n```\nfor (auto vd : boost::make_iterator_range(vertices(g))) {\n    auto p = g[vd].predecessor;\n    std::cout << \"Pred of \" << g[vd].name << \" is \" << g[p].name << \"\\n\";\n}\n```\n\n\n(This assumes all vertices are in the MST, for simplicity. This is the same as assuming you didn't have unconnected vertices in the input)\n\nPrints (for the given random seed and starting vertex):\n\n```\nPred of NAME1 is NAME9\nPred of NAME2 is NAME2\nPred of NAME3 is NAME6\nPred of NAME4 is NAME1\nPred of NAME5 is NAME6\nPred of NAME6 is NAME1\nPred of NAME7 is NAME3\nPred of NAME8 is NAME7\nPred of NAME9 is NAME0\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "include an edge and produce spanning tree with least weight among those having edge\r\n                \r\nI wish to find minimum spanning tree of graph G such that it includes and edge e and its weight is minimum of all those spanning trees which have edge e.If i include edge e and then run prime or kruskals will it work?\n    ", "Answer": "\r\nYou can just set the edge weight of that edge (and any other edge you want to include in the spanning tree that would keep it a tree) by setting its weight to 0 and run your favorite MST algorithm.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Basic Questions about Minimum Spanning Tree\r\n                \r\nThis is not a homework. I am trying to do exercises from a textbook to understand ```\nMST (minimum spanning tree)```\n.\n\nSuppose I have a cycle ```\nC```\n in a weighted undirected graph ```\nG```\n. As I understand, the following is correct:\n\n\nThe heaviest edge in ```\nC```\n belongs to no MST of ```\nG```\n. That is, there is no MST of ```\nG```\n, which contains that edge.\nThe lightest edge in ```\nC```\n belongs to some MST of ```\nG```\n. That is, there is an MST of ```\nG```\n, which contains that edge. \n\n\nNow I wonder if the followings claims are correct too.\n\n\nThe lightest edge in ```\nC```\n belongs to all MST of ```\nG```\n. That is, there is no MST of ```\nG```\n, which does not contain that edge. \nAny edge in ```\nC```\n except the heaviest one belongs to some MST. That is, for each edge in ```\nC```\n except the heaviest one there is an MST, which contains that edge.\n\n\nCould you prove the last claim?\n    ", "Answer": "\r\nEven for the first claim if there are multiple edges which are lightest, all need not be included in the MST.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum Spanning Tree with Boost\r\n                \r\nI have the following code that generates an undirected graph:\n\n```\n// --- Header File ---\nclass Node { ... };\nstruct Edge { float weight; };\ntypedef adjacency_list<vecS, vecS, undirectedS, Node, Edge> Grafo;\n\nclass MST\n{\n    public:\n        MST(std::vector<Node> nodes);\n        Grafo g;\n        vector<edge_t> build();\n};\n\n// --- cpp File ---\nMST::MST(std::vector<Node> nodes) {  // build the graph by setting vertices and edges...  }\n\nvector<edge_t> MST::build()\n{\n    vector<edge_t> mst;\n    kruskal_minimum_spanning_tree(g, std::back_inserter(mst));\n    return mst;\n}\n```\n\n\nThe problem is in the line that I call Kruskal: ```\nkruskal_minimum_spanning_tree()```\n. If I comment this line it will compile fine, and I can export the graph with graphviz (you can see the graph at webgraphviz.com):\n\n```\ngraph G {\n0[label=\"a\"];\n1[label=\"b\"];\n2[label=\"c\"];\n3[label=\"d\"];\n4[label=\"e\"];\n0--1 [label=80.4487381];\n0--2 [label=406.060333];\n0--3 [label=405.738831];\n0--4 [label=434.203857];\n1--2 [label=25.9422436];\n1--3 [label=210.344955];\n1--4 [label=246.965591];\n2--3 [label=35.805027];\n2--4 [label=35.1283379];\n3--4 [label=167.5858];\n}\n```\n\n\nBut if I try to compile with that line I get A LOT of errors from Boost (I'm using g++ 4.9.2). The first error is: ```\nerror: forming reference to void typedef value_type& reference;```\n, this error repeats several times. Other error that appears:\n\n```\nerror: no matching function for call to 'get(boost::edge_weight_t, const boost::adjacency_list<boost::vecS, boost::vecS, boost::undirectedS, Symbol, Edge>&)'\n        get(edge_weight, g));\n```\n\n\nSo I've tried to add ```\nget(edge_weight, g);```\n before call the Kruskal method, but I got notes saying:\n\n```\nnote:   types 'boost::subgraph<Graph>' and 'const boost::adjacency_list<boost::vecS, boost::vecS, boost::undirectedS, Symbol, Edge>' have incompatible cv-qualifiers\n        get(edge_weight, g));\n```\n\n\nand \n\n```\nnote:   mismatched types 'const boost::two_bit_color_map<IndexMap>' and 'boost::edge_weight_t'\n        get(edge_weight, g));\n```\n\n\nI don't know what to do. This is the first time I'm using Boost Graph Library. It is very powerful but not easy to understand.\n    ", "Answer": "\r\nTLDR: use \n\n```\nkruskal_minimum_spanning_tree(g, std::back_inserter(mst), \n                        weight_map( get(&Edge::weight, g) );\n```\n\n\nOriginal answer:\n\nThe problem you are facing is that the algorithm needs to access a graph's weight map and yours doesn't have one by default. If you look at the signature of the algorithm in the documentation you can see that it is:\n\n```\ntemplate <class Graph, class OutputIterator, class P, class T, class R>\nOutputIterator kruskal_minimum_spanning_tree(Graph& g, OutputIterator tree_edges, \n                                   const bgl_named_params<P, T, R>& params = all defaults);\n```\n\n\nIt has two \"normal\" parameters (the ones you used) and then a strange looking ```\nbgl_named_params<P, T, R>& params```\n. This last parameter allows you to use the four parameters listed later in that page: ```\nweight_map```\n, ```\nrank_map```\n, ```\npredecessor_map```\n and ```\nvertex_index_map```\n. If you don't use any of these parameters its default value is used and in the case of ```\nweight_map```\n this default is ```\nget(edge_weight,g)```\n. That only works if you have an interior edge_weight property in your graph, meaning your graph is defined like this:\n\n```\ntypedef adjacency_list<vecS, vecS, undirectedS, \n                    property<vertex_name_t,char>,//Could also be `Node` unless you use another algorithm with requirements on the vertices\n                    property<edge_weight_t,float> \n                  > InternalPropGraph;\n```\n\n\nBut if that definition was required to use ```\nkruskal_minimum_spanning_tree```\n (or any other algorithm) then bundled properties wouldn't be useful at all. You just need to override the default ```\nweight_map```\n using the named parameters:\n\n```\n//typedef adjacency_list<vecS, vecS, undirectedS, Node, Edge> Grafo;\n...\nkruskal_minimum_spanning_tree(g, std::back_inserter(mst), \n                        weight_map( get(&Edge::weight, g) );\n```\n\n\nIn order to access a property map that relates a vertex/edge descriptor with a member of your structs you can simply use ```\nget(&Struct::member, g)```\n.\n\nA final note about Named Parameters, if in your invocation of the algorithm you need to use more than one of these parameters, you need to concatenate them with ```\n.```\n instead of the usual ```\n,```\n since in the signature ```\nparams```\n despite its name is a single parameter.\n\n```\n//the order of the named params is irrelevant\nkruskal_minimum_spanning_tree(g, std::back_inserter(mst), \n                                 weight_map(my_weights)\n                                .vertex_index_map(my_indices)\n                                .predecessor_map(my_predecessors));\n```\n\n\nHere is an example that shows something similar to what you want using both internal properties and bundled properties. It deliberately uses different ways to set/access properties to show what you can do.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Creating a \"satisfactory\" Minimum Spanning Tree (MST) given only vertices\r\n                \r\nClassic MST Problems\n\nIn the classic formulation of the Minimum Spanning Tree (MST) problem, we are given a set V of vertices and a set E of edges.  Although there are\n\n\n\npossible edges given V vertices, the number of edges is usually much smaller than M.\n\nMy Problem: Set of edges is implied, not given\n\nIn my case I have a set of V vertices, where each vertex is a coordinate (x,y) on a 2-D plane.  I am not given any edges at all, i.e., the set E is empty.  In actual fact, I know all M edges and their distances: it is the distance between every possible pair of vertices.  Thus, the size of the known edges is maximal, i.e., |E|=M.\n\nHere's my dilemma: if the size of V, |V|, is very large (e.g., 10,000), the value of M grows very quickly.  Attempting to use an MST algorithm with |V| = 10,000 and |E| = M = 50,000,000 can cause serious algorithmic efficiency issues.\n\nIs there a method for removing / pruning / removing edges from the maximal edge set E before running the MST algorithm, reducing the time needed to find a \"satisfactory\" (i.e., not necessarily optimal) MST?\n\nPossible Heuristic\n\nHere's one possibility:\n\n\nGiven the set V of vertices, compute the bounding rectangle\nPartition the rectangle into R smaller rectangles\n\n\nFor example, divide the rectangle both vertically and horizontally into four (4) ranges, producing sixteen (16) smaller rectangles\n\nFor each sub-rectangle, compute an MST from all vertices located in the sub-rectangle.\nConnect the resulting MSTs to produce one large MST.\n\n\nCan anyone suggest an efficient algorithm to generate a satisfactory MST given only the set of vertices?\n    ", "Answer": "\r\nIt sounds like you are trying to compute a Euclidean minimum spanning tree.\n\nWikipedia contains more efficient O(nlogn) algorithms for this based on the key idea:\n\n\n  A better approach to finding the EMST in a plane is to note that it is a subgraph of every Delaunay triangulation of the n points, a much-reduced set of edges:\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Chu-Liu Edmond's algorithm for Minimum Spanning Tree on Directed Graphs\r\n                \r\nI would like to find a minimum spanning tree (MST) on a weighted directed graph.  I have been trying to use Chu-Liu/Edmond's algorithm, which I have implemented in Python (code below).  A simple, clear description of the algorithm can be found here.  I have two questions.\n\n\nIs Edmond's algorithm guaranteed to converge on a solution?\n\nI am concerned that removing a cycle will add another cycle. If this happens, the algorithm will continue trying to remove cycles forever.\n\nI seem to have found an example where this happens.  The input graph is shown below (in the code).  The algorithm never finishes because it switches between cycles [1,2] and [1,3], and [5,4] and [5,6].  The edge added to the graph to resolve the cycle [5,4] creates cycle [5,6] and vice versa, and similarly for [1,2] and [1,3].\n\nI should note that I am not certain that my implementation is correct.\nTo resolve this issue, I introduced an ad hoc patch.  When an edge is removed to remove a cycle, I permanently remove that edge from the underlying graph G on which we are searching for an MST.  Consequently, that edge cannot be added again and this should prevent the algorithm from getting stuck.  With this change, am I guaranteed to find an MST?\n\nI suspect that one can find a pathological case where this step will lead to a result that is not an MST, but I have not been able to think of one.  It seems to work on all the simple test cases that I have tried.\n\n\nCode:\n\n```\nimport sys\n\n# --------------------------------------------------------------------------------- #\n\ndef _reverse(graph):\n    r = {}\n    for src in graph:\n        for (dst,c) in graph[src].items():\n            if dst in r:\n                r[dst][src] = c\n            else:\n                r[dst] = { src : c }\n    return r\n\n# Finds all cycles in graph using Tarjan's algorithm\ndef strongly_connected_components(graph):\n    \"\"\"\n    Tarjan's Algorithm (named for its discoverer, Robert Tarjan) is a graph theory algorithm\n    for finding the strongly connected components of a graph.\n\n    Based on: http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n    \"\"\"\n\n    index_counter = [0]\n    stack = []\n    lowlinks = {}\n    index = {}\n    result = []\n\n    def strongconnect(node):\n        # set the depth index for this node to the smallest unused index\n        index[node] = index_counter[0]\n        lowlinks[node] = index_counter[0]\n        index_counter[0] += 1\n        stack.append(node)\n\n        # Consider successors of `node`\n        try:\n            successors = graph[node]\n        except:\n            successors = []\n        for successor in successors:\n            if successor not in lowlinks:\n                # Successor has not yet been visited; recurse on it\n                strongconnect(successor)\n                lowlinks[node] = min(lowlinks[node],lowlinks[successor])\n            elif successor in stack:\n                # the successor is in the stack and hence in the current strongly connected component (SCC)\n                lowlinks[node] = min(lowlinks[node],index[successor])\n\n        # If `node` is a root node, pop the stack and generate an SCC\n        if lowlinks[node] == index[node]:\n            connected_component = []\n\n            while True:\n                successor = stack.pop()\n                connected_component.append(successor)\n                if successor == node: break\n            component = tuple(connected_component)\n            # storing the result\n            result.append(component)\n\n    for node in graph:\n        if node not in lowlinks:\n            strongconnect(node)\n\n    return result\n\ndef _mergeCycles(cycle,G,RG,g,rg):\n    allInEdges = [] # all edges entering cycle from outside cycle\n    minInternal = None\n    minInternalWeight = sys.maxint\n\n    # Find minimal internal edge weight\n    for n in cycle:\n        for e in RG[n]:\n            if e in cycle:\n                if minInternal is None or RG[n][e] < minInternalWeight:\n                    minInternal = (n,e)\n                    minInternalWeight = RG[n][e]\n                    continue\n            else:\n                allInEdges.append((n,e)) # edge enters cycle\n\n    # Find the incoming edge with minimum modified cost\n    # modified cost c(i,k) = c(i,j) - (c(x_j, j) - min{j}(c(x_j, j)))\n    minExternal = None\n    minModifiedWeight = 0\n    for j,i in allInEdges: # j is vertex in cycle, i is candidate vertex outside cycle\n        xj, weight_xj_j = rg[j].popitem() # xj is vertex in cycle that currently goes to j\n        rg[j][xj] = weight_xj_j # put item back in dictionary\n        w = RG[j][i] - (weight_xj_j - minInternalWeight) # c(i,k) = c(i,j) - (c(x_j, j) - min{j}(c(x_j, j)))\n        if minExternal is None or w <= minModifiedWeight:\n            minExternal = (j,i)\n            minModifiedWeight = w\n\n    w = RG[minExternal[0]][minExternal[1]] # weight of edge entering cycle\n    xj,_ = rg[minExternal[0]].popitem() # xj is vertex in cycle that currently goes to j\n    rem = (minExternal[0], xj) # edge to remove\n    rg[minExternal[0]].clear() # popitem() should delete the one edge into j, but we ensure that\n\n    # Remove offending edge from RG\n    # RG[minExternal[0]].pop(xj, None) #highly experimental. throw away the offending edge, so we never get it again\n\n    if rem[1] in g:\n        if rem[0] in g[rem[1]]:\n            del g[rem[1]][rem[0]]\n    if minExternal[1] in g:\n        g[minExternal[1]][minExternal[0]] = w\n    else:\n        g[minExternal[1]] = { minExternal[0] : w }\n\n    rg = _reverse(g)\n\n# --------------------------------------------------------------------------------- #\n\ndef mst(root,G):\n    \"\"\" The Chu-Liu/Edmond's algorithm\n\n    arguments:\n\n    root - the root of the MST\n    G - the graph in which the MST lies\n\n    returns: a graph representation of the MST\n\n    Graph representation is the same as the one found at:\n    http://code.activestate.com/recipes/119466/\n\n    Explanation is copied verbatim here:\n\n    The input graph G is assumed to have the following\n    representation: A vertex can be any object that can\n    be used as an index into a dictionary.  G is a\n    dictionary, indexed by vertices.  For any vertex v,\n    G[v] is itself a dictionary, indexed by the neighbors\n    of v.  For any edge v->w, G[v][w] is the length of\n    the edge.\n    \"\"\"\n\n    RG = _reverse(G)\n\n    g = {}\n    for n in RG:\n        if len(RG[n]) == 0:\n            continue\n        minimum = sys.maxint\n        s,d = None,None\n\n        for e in RG[n]:\n            if RG[n][e] < minimum:\n                minimum = RG[n][e]\n                s,d = n,e\n\n        if d in g:\n            g[d][s] = RG[s][d]\n        else:\n            g[d] = { s : RG[s][d] }\n\n    cycles = [list(c) for c in strongly_connected_components(g)]\n\n    cycles_exist = True\n    while cycles_exist:\n\n        cycles_exist = False\n        cycles = [list(c) for c in strongly_connected_components(g)]\n        rg = _reverse(g)\n\n        for cycle in cycles:\n\n            if root in cycle:\n                continue\n\n            if len(cycle) == 1:\n                continue\n\n            _mergeCycles(cycle, G, RG, g, rg)\n            cycles_exist = True\n\n    return g\n\n# --------------------------------------------------------------------------------- #\n\nif __name__ == \"__main__\":\n\n    # an example of an input that works\n    root = 0\n    g = {0: {1: 23, 2: 22, 3: 22}, 1: {2: 1, 3: 1}, 3: {1: 1, 2: 0}}\n\n    # an example of an input that causes infinite cycle\n    root = 0\n    g = {0: {1: 17, 2: 16, 3: 19, 4: 16, 5: 16, 6: 18}, 1: {2: 3, 3: 3, 4: 11, 5: 10, 6: 12}, 2: {1: 3, 3: 4, 4: 8, 5: 8, 6: 11}, 3: {1: 3, 2: 4, 4: 12, 5: 11, 6: 14}, 4: {1: 11, 2: 8, 3: 12, 5: 6, 6: 10}, 5: {1: 10, 2: 8, 3: 11, 4: 6, 6: 4}, 6: {1: 12, 2: 11, 3: 14, 4: 10, 5: 4}}\n\n    h = mst(int(root),g)\n\n    print h\n\n    for s in h:\n        for t in h[s]:\n            print \"%d-%d\" % (s,t)\n```\n\n    ", "Answer": "\r\nDon't do ad hoc patches. I concede that implementing the contraction/uncontraction logic is not intuitive, and recursion is undesirable in some contexts, so here's a proper Python implementation that could be made production quality. Rather than perform the uncontraction step at each recursive level, we defer it to the end and use depth-first search, thereby avoiding recursion. (The correctness of this modification follows ultimately from complementary slackness, part of the theory of linear programming.)\n\nThe naming convention below is that ```\n_rep```\n signifies a supernode (i.e., a block of one or more contracted nodes).\n\n```\n#!/usr/bin/env python3\nfrom collections import defaultdict, namedtuple\n\n\nArc = namedtuple('Arc', ('tail', 'weight', 'head'))\n\n\ndef min_spanning_arborescence(arcs, sink):\n    good_arcs = []\n    quotient_map = {arc.tail: arc.tail for arc in arcs}\n    quotient_map[sink] = sink\n    while True:\n        min_arc_by_tail_rep = {}\n        successor_rep = {}\n        for arc in arcs:\n            if arc.tail == sink:\n                continue\n            tail_rep = quotient_map[arc.tail]\n            head_rep = quotient_map[arc.head]\n            if tail_rep == head_rep:\n                continue\n            if tail_rep not in min_arc_by_tail_rep or min_arc_by_tail_rep[tail_rep].weight > arc.weight:\n                min_arc_by_tail_rep[tail_rep] = arc\n                successor_rep[tail_rep] = head_rep\n        cycle_reps = find_cycle(successor_rep, sink)\n        if cycle_reps is None:\n            good_arcs.extend(min_arc_by_tail_rep.values())\n            return spanning_arborescence(good_arcs, sink)\n        good_arcs.extend(min_arc_by_tail_rep[cycle_rep] for cycle_rep in cycle_reps)\n        cycle_rep_set = set(cycle_reps)\n        cycle_rep = cycle_rep_set.pop()\n        quotient_map = {node: cycle_rep if node_rep in cycle_rep_set else node_rep for node, node_rep in quotient_map.items()}\n\n\ndef find_cycle(successor, sink):\n    visited = {sink}\n    for node in successor:\n        cycle = []\n        while node not in visited:\n            visited.add(node)\n            cycle.append(node)\n            node = successor[node]\n        if node in cycle:\n            return cycle[cycle.index(node):]\n    return None\n\n\ndef spanning_arborescence(arcs, sink):\n    arcs_by_head = defaultdict(list)\n    for arc in arcs:\n        if arc.tail == sink:\n            continue\n        arcs_by_head[arc.head].append(arc)\n    solution_arc_by_tail = {}\n    stack = arcs_by_head[sink]\n    while stack:\n        arc = stack.pop()\n        if arc.tail in solution_arc_by_tail:\n            continue\n        solution_arc_by_tail[arc.tail] = arc\n        stack.extend(arcs_by_head[arc.tail])\n    return solution_arc_by_tail\n\n\nprint(min_spanning_arborescence([Arc(1, 17, 0), Arc(2, 16, 0), Arc(3, 19, 0), Arc(4, 16, 0), Arc(5, 16, 0), Arc(6, 18, 0), Arc(2, 3, 1), Arc(3, 3, 1), Arc(4, 11, 1), Arc(5, 10, 1), Arc(6, 12, 1), Arc(1, 3, 2), Arc(3, 4, 2), Arc(4, 8, 2), Arc(5, 8, 2), Arc(6, 11, 2), Arc(1, 3, 3), Arc(2, 4, 3), Arc(4, 12, 3), Arc(5, 11, 3), Arc(6, 14, 3), Arc(1, 11, 4), Arc(2, 8, 4), Arc(3, 12, 4), Arc(5, 6, 4), Arc(6, 10, 4), Arc(1, 10, 5), Arc(2, 8, 5), Arc(3, 11, 5), Arc(4, 6, 5), Arc(6, 4, 5), Arc(1, 12, 6), Arc(2, 11, 6), Arc(3, 14, 6), Arc(4, 10, 6), Arc(5, 4, 6)], 0))\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Is it right solution for minimum spanning tree question?\r\n                \r\nI have a question from an exam and I wanna know if my approach is right for this question.\n\n```\nInput: graph G(V,E),weight function f:E->R and edge e=(u,v).\noutput: algorithm that finds a minimum spanning tree with edge e in it.\n```\n\n\nMy solution is to run kruskal's algorithm and then add edge e if it does not exist, it should make a circle because the tree is n-1 edges so we go through the circle and remove the biggest edge(not e) that exists in that circle.\n\nis my solution right? how to prove it if it is and if not can u someone tell me why?\n\n(P.S I have the solution for this question just want to know if my approach is right)\n    ", "Answer": "\r\nOr may be the other way, use ```\nPrim```\n or ```\nKruskal```\n's algorithm, but first add the ```\nedge e```\n to the graph (because it must be there in the tree) and then continue adding edges in the increasing order of weight values by popping from the priority queue (e.g., ```\nfibonacci heap```\n) with the regular algorithm steps, the algorithm itself will ensure that there is no cycle and the tree spans the graph (then you don't need the extra step to traverse the cycle and remove the max-weight edge different from ```\ne```\n).\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum Spanning Tree vs Shortest Path Tree\r\n                \r\nIs it possible to have an MST that has no common edges with the shortest path tree in an undirected graph with distinct positive edges?\n\nI've been trying to draw out different examples, but it seems like it is impossible. The shortest path edge in the shortest path tree should also be included in an MST it seems.\n    ", "Answer": "\r\nConsidering Prim's algorithm, you start from a vertex v and start connecting the other vertices to it in a manner which costs the least. So, for any other vertex u you connect to the connected component you are growing with Prim's algorithm(i.e. the one that includes vertex v), although there may exist(I think) a vertex w that can reach u in a shorter distance, there is no shorter way of reaching to u from v, as Prim's algorithm dictate that you extend the connected component you start from by going to whichever node is the cheapest to add.\n\nConsequently, as there is no shorter way of reaching from v to u, there must be at least 1 edge common in MST generated by starting from v and the shortest path tree of v.\n\nEven if the roots of the node of MST(say, rootA) and shortest path tree(say, rootB) differ, while building MST, Prim's algorithm should reach rootB using an edge that is on the shortest path from rootB to rootA on the shortest path tree, as by its definition the shortest path tree should help rootB reach rootA in the shortest way possible.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How do I construct a Minimum Spanning Tree from a list of vertexes, using QuikGraph C#?\r\n                \r\nHow do I get from a list of vertexes/nodes to a graph that I can use with QuikGraph to e.g. produce a Minimum Spanning Tree?\nEDIT:(\nI've been forward and backward over the QuikGraph wiki https://github.com/KeRNeLith/QuikGraph and every example I can find glosses over graph creation\n)\nBackground\nMy program procedurally generates game levels. My plan is to use an ```\nUndirectedGraph```\n from QuikGraph to store the level information, so I can use library functions to semi-intelligently lay out level content, set up patrols, etc.\nMy first stage packs the level with rooms based on configurable parameters.\nMy second stage seeks to connect the rooms with the minimum amount of nonsense hallways - ie, connecting adjacent rooms with a single direct hallway. I will break some connections and add other connections later. This seems like a simple case of building a minimum spanning tree.\nI expected to find some sort of algorithm that takes a list of graph nodes (and some method of determining the weight/distance between any two graph nodes), and return a list of edges or something. I can't seem to find that - everything seems to assume you already have a list of edges, ie an existing graph.\nWhat's the best way to set this up? \"A list of all possible combination of edges between nodes\" seems crazy, but I can't think of anything else.\nNote\nI'm not working with a game engine. The output is intended to be a static text description suitable for use by a human when setting up a pen-and-paper roleplaying game. All the graphics and input handling and physics and sound and network and etc are overkill...\n    ", "Answer": "\r\nI've received some good advice on how to prepare my graph - using a Delaunay triangulation routine will set up a graph connected by proximity, and efficiently. I found the Delaunator library on NuGet, which seems to be doing the job well.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum Spanning Tree of Subgraph\r\n                \r\nSuppose you have a graph ```\nG```\n = (```\nV```\n, ```\nE```\n). You can do whatever you want in terms of preprocessing on this graph ```\nG```\n (within reasonable time and space constraints for a graph with a few thousands vertices, so you couldn't just store every possible answer for example).\n\nNow suppose I select a subset ```\nV'```\n of ```\nV```\n. I want the MST over just these vertices ```\nV'```\n. How do you do this quickly and efficiently?\n    ", "Answer": "\r\nThere are two ways to solve the problem. Their performance is dependent to different states of the problem.\n\n\nApplying MST algorithms on sub-graph(solve from scratch).\nUsing dynamic algorithms to update tree after changes in the problem.\nThere are two types of dynamic algorithms:\nI) Edge insertion and deletion**\nG. Ramalingam and T. Reps, “On the computational complexity of\ndynamic graph problems,” Theoret. Comput. Sci., vol. 158, no. 1, pp.\n233–277, 1996.\nII) Edge weight decreasing and increasing**\nD. Frigioni, A. Marchetti-Spaccamela, and U. Nanni, “Fully dynamic\noutput bounded single source shortest path problem,” in ACM-SIAM\nSymp. Discrete Algorithms, 1996, pp. 212–221.\n“Fully dynamic algorithms for maintaining shortest paths trees,”\nJ. Algorithms, vol. 34, pp. 251–281, 2000.\nYou can use them directly or change them with respect to the problem and consider node insertion and deletion.\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Kruskal’s Minimum Spanning Tree programm(C) getting segmentation fault (core dumped) error when i try to run it on machine other than my own\r\n                \r\nI have an issue with program to find minimum-spanning-tree it works properly without any issues on my own machine but when I tried to run it on another computers  i got segmentation fault (core dumped) error.I cant no find reason why it happens. \n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// struktura wierzcholka\n\nstruct Edge\n\n{\n\n    int src;\n    int dest;\n    int weight;\n\n};\n\n// struktura wazonego grafu nieskierowanego\n\nstruct Graph\n{\n\n    int V; //liczba wierzcholkow\n    int E; //liczba krawedzi\n\n    struct Edge* edge; //tablica wierzcholkow\n\n};\n\nstruct Graph* createGraph(int V, int E)\n\n{\n\n    struct Graph* graph = (struct Graph*) malloc(sizeof(struct Graph));\n\n    graph->V = V;\n    graph->E = E;\n\n    graph->edge = (struct Edge*) malloc(graph->E * sizeof(struct Edge));\n\n    return graph;\n\n}\n\nstruct subset //struktura podzbioru wierzcholka\n\n{\n\n    int p; //parent\n    int rank;\n\n};\n\nint FindSet(struct subset array[], int i) //znajdz zbioru elemntu i korzystajac z kompresji sciezek\n{\n\n    //  znajdz korzen i uczyn go ojcem i  \n\n    if (array[i].p != i)\n    {\n\n        array[i].p = FindSet(array, array[i].p);\n\n    }\n\n    return array[i].p;\n\n}\n\nvoid Union(struct subset arrayofsubsets[], int x, int y)\n\n{\n\n    int x1 = FindSet(arrayofsubsets, x);\n    int y1 = FindSet(arrayofsubsets, y);\n\n    //przylacz drzewo mniejszej randze do pod korzen drzewa o wyzszej randze\n\n    if (arrayofsubsets[x1].rank < arrayofsubsets[y1].rank)\n    {\n\n        arrayofsubsets[x1].p = y1;\n\n    }\n    else if (arrayofsubsets[x1].rank > arrayofsubsets[y1].rank)\n    {\n\n        arrayofsubsets[y1].p = x1;\n    }\n\n    //jesli rangi takie same jedno staje się korzeniem i zwieksza //range  \n\n    else\n    {\n\n        arrayofsubsets[y1].p = x1;\n        arrayofsubsets[x1].rank++;\n\n    }\n\n}\n\nint Compare(const void* a, const void* b)\n\n{\n    struct Edge* Edge1 = (struct Edge*) a;\n    struct Edge* Edge2 = (struct Edge*) b;\n    return Edge1->weight > Edge2->weight;\n}\n\nstruct Graph* AddEdge(struct Graph* graph, int index, int src, int dest, int weight)\n{\n\n    graph->edge[index].src = src;\n    graph->edge[index].dest = dest;\n    graph->edge[index].weight = weight;\n\n    return graph;\n}\n\nvoid Kruskal(struct Graph* graph)\n\n{\n\n    int V = graph->V;\n\n    struct Edge MST[V];  // minimalne dzewo rozpinajace\n\n    int e, i, v;\n\n    qsort(graph->edge, graph->E, sizeof(graph->edge[0]), Compare);\n\n    struct subset *arrayofsubsets = (struct subset*) malloc(V * sizeof(struct subset));\n\n    //  stworz podzbiory jednoelementowe (podzbior wskazuje sam siebie )\n\n    for (v = 0; v < V; ++v)\n    {\n\n        arrayofsubsets[v].p = v;\n        arrayofsubsets[v].rank = 0;\n\n    }\ne=0;\n    while (e < (V - 1))\n    {\n\n        //wybierz najmniejszy wierzcholek\n\n        struct Edge nextedge = graph->edge[i++];\n\n        int ru = FindSet(arrayofsubsets, nextedge.src);\n\n        int rv = FindSet(arrayofsubsets, nextedge.dest);\n\n        if (ru != rv)\n        {\n\n            MST[e++] = nextedge;\n            Union(arrayofsubsets, ru, rv);\n\n        }\n    }\n\n\n\n    printf(\"MST edges\\n\");\n\n    for (i = 0; i < e; ++i)\n    {\n\n        printf(\"V1 %d V2 %d weight %d\\n\", MST[i].src, MST[i].dest, MST[i].weight);\n    }\n\n    return;\n\n}\n\nint main()\n\n{\n\n    int V = 6;\n    int E = 9;\n\n    struct Graph* graph = createGraph(V, E);\n\n    //boki kwadratu\n    graph = AddEdge(graph, 0, 0, 1, 5);\n    graph = AddEdge(graph, 1, 0, 2, 3);\n    graph = AddEdge(graph, 2, 1, 3, 2);\n    graph = AddEdge(graph, 3, 2, 3, 8);\n\n    //przekątne kwadratu\n    graph = AddEdge(graph, 4, 0, 3, 4);\n    graph = AddEdge(graph, 5, 1, 2, 20);\n\n    //boki kwadratu przyleglego do pierwszego kwadratu  \n    //graph=AddEdge(graph,2,1,3,2);\n    graph = AddEdge(graph, 6, 1, 4, 1);\n    graph = AddEdge(graph, 7, 4, 5, 0);\n    graph = AddEdge(graph, 8, 5, 3, 21);\n\n    Kruskal(graph);\n\n    return 0;\n\n}\n```\n\n    ", "Answer": "\r\nThe program crash at line 188: \n\n```\nprintf(\"V1 %d V2 %d weight %d\\n\", MST[i].src, MST[i].dest,MST[i].weight);\n```\n\n\nand at this line \n\n```\nint e,i,v,ru,rv; \n```\n\n\nyou didn't inizialize vars e and i. To fix:\n\n```\nint e=0,i=0, [..]\n```\n\n\nand the program will work\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to check a Minimum spanning tree\r\n                \r\nHow can I check in linear time O(n) if the given tree is a MST?\n    ", "Answer": "\r\nAre you familiar with the process Union-Find?\nIf you are just given a tree you will just need to check whether its connected graph or not. I mean just query if it has only one component.\nElse maintain a map[ ```\npair<int,int>```\n , int] or similar hashing library to store the minimum weight between two nodes and compare the given tree has each edge with minimum wights or not.\nIf not then you are sure its not MST, else you have look up for if its connected. If yes, then its MST.\n\nUse tree shorting in Union Find. And to query if the tree is connected or not, you can easily check for each edge before union, if its already unioned cause then you are sure there is a cycle and its not tree at all, so not MST.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Creating a network undirected weighted graph from a binary image for a minimum spanning tree\r\n                \r\nI'm trying to create a minimum spanning tree between pixels in a thresholded image of a crack.  The pixels do not always touch when I remove noise so I am trying to connect them in a graph.\n\nPython 2.7 I have thresholded an image so everything that is below a threshold shows up white, all else is black.  I thresholded a 65x65 window at a time and set any window with less than 10 pixels to white.  \n\n```\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\nimport numpy as np\nimport Image\nimport matplotlib\nfrom cv2 import *\n\nimg=imread(\"IMG_1188.jpg\")\ngray = cvtColor(img, COLOR_BGR2GRAY)\n\nthreshold=35\n\nwidth,height = gray.shape\n\nfor j in range( 0, height,65 ):\n    for i in range( 0, width,65 ):\n\n    gray[i:i+65,j:j+65]=inRange(gray[i:i+65,j:j+65],np.array([0]), np.array([35]))\n\n    if np.sum(gray[i:i+65,j:j+65])<(2550):\n\n        gray[i:i+65,j:j+65]=[0]\n```\n\n\nI created a dict to hold all the x,y pos of the white pixels and created nodes in networkx.\n\n```\npos={}\nk=int(0)\nG =nx.Graph()\nfor j in range( 0, height):\n    for i in range( 0, width):\n        if np.array(gray[i,j])>np.array(0):\n            gray[i,j]=255\n            pos[k]=(int(i),int(j))\n            G.add_node(pos[k])          \n            k=k+1\n```\n\n\nI then checked every euclidean distance between each node and draw an edge if it is below a certain pixel distance (say 40).  \n\n```\nk=1\nfor j in range (0,pos.len()):\n\n    for i in range (k,pos.len()):   \n\n        if np.sqrt(np.square(pos[i][0]-pos[j][0])+np.square(pos[i][1]-pos[j][1]))<=40:  \n            G.add_edge(pos[i],pos[j],weight=(np.sqrt(np.square(pos[i][0]-pos[j][0])+np.square(pos[i][1]-pos[j][1]))))\n\n    k=k+1\n```\n\n\nWhen I run the program it tells me there is no position for the node. (I've run it with different parameters and received different error nodes)\n\n```\nnetworkx.exception.NetworkXError: Node (814, 700) has no position.\n```\n\n\nAny help would be appreciated.\n    ", "Answer": "\r\nThe issue was I was referencing the x position of the nodes that were within 40 as the start of the edge\n\n```\nG.add_edge(pos[i],pos[j],weight=(np.sqrt(np.square(pos[i][0]-pos[j][0])+np.square(pos[i][1]-pos[j][1]))))\n```\n\n\nInstead I needed to reference the actual node identifier (I also used absolute value since it is one operation vs the squaring and square root)\n\n```\nG.add_edge(i,j,weight=(np.fabs(window1[i][0]-window1[j][0])+np.fabs(window1[i][1]-window1[j][1])))\n```\n\n\nAlso I have found that I should use a K-D tree to speed up my code, as this code for 15000 points took 50 min or so.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Adding weights to all edges of graph - change in spanning tree and shortest paths [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                This question is unlikely to help any future visitors; it is only relevant to a small geographic area, a specific moment in time,  or an extraordinarily narrow situation that is not generally applicable to the worldwide audience of the internet. For help making  this question more broadly applicable, visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n\n  (a) Let T be a minimum spanning tree of a weighted graph G. Construct\n  a new graph G by adding a weight of k to every edge of G. Do the edges\n  of T form a minimum spanning tree of G. Prove the statement or give a\n  counterexample.\n  \n  (b) Let P = {s, . . . , t} describe a shortest weighted path between\n  vertices s and t of a weighted graph G. Construct a new graph G by\n  adding a weight of k to every edge of G. Does P describe a shortest\n  path from s to t in G. Prove the statement or give a counterexample.\n\n\nMy solution:\n\na) Edges of T still form minimum spanning tree of G, since all edge weights are increased by same amount.\n\nb) P still describes shortest path from s to t in G (same reason)\n\nCan someone please verify the answers?\n    ", "Answer": "\r\nAlthough I don't think SO is the best place for your question, your answer to question B is definitely wrong.\n\nConsider a graph with 3 vertices (A,B,C), with the following edges:\n\n```\nA-B = 1\nA-C = 0\nC-B = 0\n```\n\n\nThe shortest weighted path between A and B is A-C-B. If you add 2 to all the weights, your shortest path becomes A-B.\n\n(Sorry, missed the first part of the question, there is an answer for that already by now. The reason why ```\na```\n is correct but ```\nb```\n is wrong is that spanning trees always contain exactly ```\nn-1```\n edges, while the number of edges in a shortest weighted path may vary.)\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Update minimum spanning tree with modification of edge\r\n                \r\nA graph (positive weight edges) with a MST\nIf some edge, e is modified to a new value, what is the best way to update the MST without completely remaking it. I think this can be done in linear time. Also, it seems that I would need a different algorithm based on whether 1) e is already a part of the MST and 2) whether the new edge, e is larger or smaller than the original\n    ", "Answer": "\r\nThere are 4 cases:\n\n\nEdge is in MST and you decreasing value of edge:\nCurrent MST is still MST\nEdge is not in MST and you decreasing value of edge:\nAdd this edge to the MST. Now you've got exactly 1 cycle.\nBased on cycle property in MST you need to find and remove edge with highest value that is on that cycle. You can do it using dfs or bfs. Complexity O(n).\nEdge is in MST and you increasing its value of edge:\nRemove this edge from MST. Now you have 2 connected components that should be connected. You can calculate both components in O(n) (bfs or dfs). You need to find edge with smallest value that connects these components. Iterate over edges in ascending order by their value. Complexity O(n).\nEdge is not in MST and you increasing its value of edge:\nCurrent MST is still MST\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Space efficient minimum spanning tree\r\n                \r\nI've come across a task that basically asks you to find MST of the given graph in which all the vertices are connected. I tried using Kruskal's algorithm but I soon figured out that the space bound is too tight for one to store all the edges by a mebibyte, so I also gave up on Prim's and Boruvka's algorithm. Is there a way to implement any of these algorithms (or any other MST algorithm) with space complexity better than O(E) which is in this case O(V^2)?\n    ", "Answer": "\r\nFor the case where you can compute the weights using a function w(i,j) you can compute a minimum spanning tree in space O(n) instead of O(n^2) using Prim's algorithm (https://en.wikipedia.org/wiki/Minimum_spanning_tree#Classic_algorithms).\n\nAt each stage maintain the set T of nodes in the tree, and for each node not in the tree maintain the least distance from that node to any node in the tree.\n\nAt the start T is node 0 and for each other node you compute the least distance from node 0 to that node.\n\nAt each stage pick the node not in the tree with least distance. Now compute the distance from that node to all other nodes not in the tree. If that is less than their current least distance update that least distance.\n\nStorage cost is O(n) to maintain T and O(n) to maintain for each node not in the tree a note of the least distance from the tree to that node. \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Trying to use Minimum Spanning Tree example from the book but It doesn't work with large data\r\n                \r\nNote: This is not my code\n\nI am trying to use the data structures with C++ textbook's Minimum Spanning Tree Algorithm but as you can see I made a edges[] array of edges and commented out the old edges[] array but It looks like it doesn't work for larger amount of edge or something. (I am just using chars as ints by the way)\n\nDoes anyone know why? I didn't change a lot, I just changed the edges array.\nIt compiles just fine but If you run it you will see that it won't work with my data but It will with the original data.\n\nThe arrays are right over the main (last thing)\n\nAlso if you don't want to open up your ide, here is my code on an online IDE: http://goo.gl/35KMcK\n\nHere is the code:\n\n```\n#include <iostream>\n\nusing namespace std;\n\nclass MSTEdge\n{\n    char src;\n    char dest;\n    int weight;\npublic:\n    MSTEdge(char s = 0, char d = 0, int w = 0) : src(s), dest(d), weight(w) { }\n    char& getSrc() { return src; }\n    char& getDest() { return dest; }\n    int& getWeight() { return weight; }\n    int& get() { return getWeight(); }\n};\n\n// undirected and weighted graph\nclass Graph\n{\n    int V, E;\n    MSTEdge* edge;\n    int icount;\npublic:\n    Graph(int v, int e) : V(v), E(e), icount(0)\n    {\n        edge = new MSTEdge[e];\n    }\n    int& getVertexAmount() { return V; }\n    int& getEdgeAmount() { return E; }\n    MSTEdge*& getEdges() { return edge; }\n    MSTEdge& operator [](int x) { return edge[x]; }\n    void insert(MSTEdge& e)\n    {\n        edge[icount++] = e;\n    }\n};\n\n// subset for union-find\nclass subset\n{\n    int parent;\n    int rank;\npublic:\n    subset(int p = 0, int r = 0) : parent(p), rank(r) {}\n    int& getTheParent() { return parent; }\n    int& getTheRank() { return rank; }\n};\n\n// find set of an element i\nint find(subset* subsets, int i)\n{\n    // find root and make root as parent of i (path compression)\n    if (subsets[i].getTheParent() != i)\n        subsets[i].getTheParent() = find(subsets, subsets[i].getTheParent());\n\n    return subsets[i].getTheParent();\n}\n\n// union of two sets of x and y\nvoid Union(subset* subsets, int x, int y)\n{\n    int x_root = find(subsets, x);\n    int yroot = find(subsets, y);\n\n    // Attach smaller rank tree under root of high rank tree\n    // (Union by Rank)\n    if (subsets[x_root].getTheRank() < subsets[yroot].getTheRank())\n        subsets[x_root].getTheParent() = yroot;\n    else if (subsets[x_root].getTheRank() > subsets[yroot].getTheRank())\n        subsets[yroot].getTheParent() = x_root;\n\n    // If ranks are same, then make one as root and increment its rank by one\n    else\n    {\n        subsets[yroot].getTheParent() = x_root;\n        subsets[x_root].getTheRank()++;\n    }\n}\n\ntemplate <typename T>\nvoid partition_array(T* arr, int& i, int& j, T pivot)\n{\n    while (i <= j)\n    {\n        while (arr[i].get() < pivot.get())\n            i++;\n        while (arr[j].get() > pivot.get())\n            j--;\n        if (i <= j)\n        {\n            T tmp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = tmp;\n            i++;\n            j--;\n        }\n    };\n}\n\ntemplate <typename T>\nvoid quickSort_array(T* arr, int left, int right)\n{\n    int i = left, j = right;\n    T pivot = arr[(left + right) / 2];\n\n    // partition \n    partition_array(arr, i, j, pivot);\n\n    // recursion \n    if (left < j)\n        quickSort_array(arr, left, j);\n    if (i < right)\n        quickSort_array(arr, i, right);\n}\n\n// The main function to construct MST\nvoid MST(Graph& graph)\n{\n    int V = graph.getVertexAmount();\n    MSTEdge* result = new MSTEdge[V];  // Tnis will store the resultant MST\n    int e = 0;  // An index variable, used for result[]\n    int i = 0;  // An index variable, used for sorted edges\n\n    quickSort_array(graph.getEdges(), 0, graph.getEdgeAmount());\n\n    // Allocate memory for creating V ssubsets\n    subset* subsets = new subset[V];\n\n    // Create V subsets with single elements\n    for (int v = 0; v < V; ++v)\n    {\n        subsets[v].getTheParent() = v;\n        subsets[v].getTheRank() = 0;\n    }\n\n    // Number of edges to be taken is equal to V-1\n    while (e < V - 1)\n    {\n        // Step 2: Pick the smallest edge. And increment the index\n        // for next iteration\n        MSTEdge next_edge = graph[i++];\n\n        int x = find(subsets, next_edge.getSrc());\n        int y = find(subsets, next_edge.getDest());\n\n        // If including this edge does't cause cycle, include it\n        // in result and increment the index of result for next edge\n        if (x != y)\n        {\n            result[e++] = next_edge;\n            Union(subsets, x, y);\n        }\n        // Else discard the next_edge\n    }\n\n    // print the contents of result[] to display the built MST\n    cout << \"Following are the edges in the constructed MST\\n\";\n    for (i = 0; i < e; ++i)\n        cout\n        << result[i].getSrc()\n        << \" -- \"\n        << result[i].getDest()\n        << \" == \"\n        << result[i].getWeight()\n        << endl;\n    return;\n}\n\n/* weighted graph\n10\n0-------- 1\n|  \\     |\n6|   5\\  |15\n|      \\ |\n2 --------3\n4\n*/\n\n\n//MSTEdge edges[] =  //THIS WORKS\n//{\n//  MSTEdge(0,1,10),\n//  MSTEdge(0,2,6),\n//  MSTEdge(0,3,5),\n//  MSTEdge(1,3,15),\n//  MSTEdge(2,3,4)\n//};\n\nMSTEdge edges[] =    // CAUSES PROBLEMS\n{\n    MSTEdge('A','B',5),\n    MSTEdge('A','C',1),\n    MSTEdge('B','C',10),\n    MSTEdge('B','E',13),\n    MSTEdge('C','D',5),\n    MSTEdge('D','E',15),\n    MSTEdge('D','F',10),\n    MSTEdge('E','F',17)\n};\n\n\n// Driver program to test above functions\nint main()\n{\n    int count = sizeof(edges) / sizeof(MSTEdge);\n    int V = count - 1;  // Number of vertices in graph\n    Graph graph(V, count);\n    for (int e = 0; e < count; e++)\n        graph.insert(edges[e]);\n    MST(graph);\n    return 1;\n}\n\n// Following are the edges in the constructed MST\n// 2 -- 3 == 4\n// 0 -- 3 == 5\n// 0 -- 1 == 10\n```\n\n    ", "Answer": "\r\nThe ```\nsubsets```\n array is initialized using this code: \n\n```\n// Create V subsets with single elements\nfor (int v = 0; v < V; ++v)\n{\n    subsets[v].getTheParent() = v;\n    subsets[v].getTheRank() = 0;\n}\n```\n\n\nThis gives you subsets having ```\nparent```\n values from 0 to V-1\n\nThe code then tries to find those subsets using this line\n\n```\nint x = find(subsets, next_edge.getSrc());\n```\n\n\nBut your edges have source and destination set to 'A', 'B', 'C' etc. So it will never be able to find anything in ```\nsubsets```\n. It is probably accessing items outside the array bounds of ```\nsubsets```\n and causing undefined behaviour.\n\nTo fix it, either change your ```\nedges```\n array to use 0, 1, 2, as the node IDs (probably easiest), or change the ```\nsubsets```\n initialize code to set the parents to 'A', 'B', 'C' etc. Note: there may be more places that assume the node IDs start from 0.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Java Minimum Spanning Tree Problem\r\n                \r\nI am working on a lab and need some assistance if possible.\n\nI have created a multidimensional array which is populated with random integers >= 0 up to 100 (inclusive) and I am attempting to apply Prim's algorithm (via a method that I have in another class) to this multidimensional array, but it keeps giving me unwanted results (either zeroes, or the value that I put in for 'n').\n\nPlease be aware that I have applied Prim's algorithm (via the method in another class) to two other arrays and it has worked perfectly well; however, now that I have created a multidimensional array populated entirely by random natural integers between 0 and 100 inclusive, it ceases to work.  Here is the code from the classes (I have left the code in for the aforementioned two arrays that I have worked on in case something can be derived from there):\n\n```\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class Lab6 {\n\nstatic double[][] g = new double[][] {{0, 1, 2} , {1, 0, 3} , {2, 3, 0}};\nstatic double mst[][] = MST.PrimsMST(g);\n\nstatic double[][] lecExample = new double[][] {{0, 1, 2, 3, 0} , {1, 0, 6, 0, 5} , {2, 6, 0 ,4, 1} , {3, 0, 4, 0, 2} , {0, 5, 1, 2, 0}};\nstatic double mst2[][] = MST.PrimsMST(lecExample);\n\n\npublic static void printArray(){\n\n    System.out.println(\"Matrix (g):\");\n    for (int i = 0; i < g.length; i++) {\n             for (int c = 0; c < g[i].length; c++) {\n                 System.out.print(\" \" + g[i][c]);\n             }\n         System.out.println(\"\");\n    }\n\n    System.out.println();\n\n    System.out.println(\"MST:\");\n    for (int i = 0; i < mst.length; i++){\n            for (int c = 0; c < mst[i].length; c++){\n                System.out.print(\" \" + mst[i][c]);\n            }\n        System.out.println(\"\");\n    }\n\n    System.out.println(\"Matrix (lecExample):\");\n    for (int i = 0; i < lecExample.length; i++) {\n             for (int c = 0; c < lecExample[i].length; c++) {\n                 System.out.print(\" \" + lecExample[i][c]);\n             }\n         System.out.println(\"\");\n    }\n\n    System.out.println();\n\n    System.out.println(\"MST2:\");\n    for (int i = 0; i < mst2.length; i++){\n            for (int c = 0; c < mst2[i].length; c++){\n                System.out.print(\" \" + mst2[i][c]);\n            }\n        System.out.println(\"\");\n    }\n\n}\n\n\nstatic Random random = new Random();\nstatic int r = random.nextInt() & 100;\n\npublic static void randomArray(int n){\n\n    double[][] array = new double[][] {{n, n, n, n, n}, {n, n, n, n, n}, {n, n, n, n, n}, {n, n, n, n, n}, {n, n, n, n, n}};\n    double mst3[][] = MST.PrimsMST(array);\n\n    System.out.println(\"Matrix (Random Number Array):\");\n    for(int i = 0 ; i < array.length ; i++ ) { \n       for (int c = 0 ; c < array[i].length; c++ ) { \n          array[i][c] = random.nextInt(101);\n       }\n    }\n\n    for(double[] a: array) { \n        System.out.println(Arrays.toString(a));\n    }\n\n    System.out.println(\"MST3:\");\n    for (int i = 0; i < mst3.length; i++){\n            for (int c = 0; c < mst3[i].length; c++){\n                System.out.print(\" \" + mst3[i][c]);\n            }\n        System.out.println(\"\");\n    }\n\n}\n\npublic static void main(String[] args){\n\n    printArray();\n    System.out.println(\"\\n\");\n    randomArray(50);\n\n}\n\n}\n```\n\n\nMST.java:\n\n```\nimport java.util.*;\n\npublic class MST\n{\n//Search for the next applicable edge\nstatic private Edge LocateEdge(ArrayList<Integer> v,ArrayList<Edge> edges)\n{\n    for (Iterator<Edge> it = edges.iterator(); it.hasNext();)\n    {\n        Edge e = it.next();\n        int x = e.i;\n        int y = e.j;\n        int xv = v.indexOf(x);\n        int yv = v.indexOf(y);\n        if (xv > -1 && yv == -1)\n        {\n            return(e);\n        }\n        if (xv == -1 && yv > -1)\n        {\n            return(e);\n        }\n    }\n    //Error condition\n    return(new Edge(-1,-1,0.0));\n}\n@SuppressWarnings(\"unchecked\")\n//d is a distance matrix, high value edges are more costly\n//Assume that d is symmetric and square\npublic static double[][] PrimsMST(double[][] d)\n{\n    int i,j,n = d.length;\n    double res[][] = new double[n][n];\n    //Store edges as an ArrayList\n    ArrayList<Edge> edges = new ArrayList<Edge>();\n    for(i=0;i<n-1;++i)\n    {\n        for(j=i+1;j<n;++j)\n        {\n            //Only non zero edges\n            if (d[i][j] != 0.0) edges.add(new Edge(i,j,d[i][j]));\n        }\n    }\n    //Sort the edges by weight\n    Collections.sort(edges,new CompareEdge());\n    //Don't do anything more if all the edges are zero\n    if (edges.size() == 0) return(res);\n    //List of variables that have been allocated\n    ArrayList<Integer> v = new ArrayList<Integer>();\n    //Pick cheapest edge\n    v.add(edges.get(0).i);\n    //Loop while there are still nodes to connect\n    while(v.size() != n)\n    {\n        Edge e = LocateEdge(v,edges);\n        if (v.indexOf(e.i) == -1) v.add(e.i);\n        if (v.indexOf(e.j) == -1) v.add(e.j);\n        res[e.i][e.j] = e.w;\n        res[e.j][e.i] = e.w;\n    }\n    return(res);\n}\n\n}\n```\n\n\nWhenever I run the program, this is the outcome:\n\n```\nMatrix (Random Number Array):\n[85.0, 11.0, 79.0, 25.0, 30.0]\n[62.0, 55.0, 39.0, 21.0, 92.0]\n[31.0, 76.0, 3.0, 74.0, 43.0]\n[59.0, 97.0, 91.0, 60.0, 7.0]\n[96.0, 44.0, 26.0, 66.0, 31.0]\n\nMST3:\n0.0 50.0 50.0 50.0 50.0\n50.0 0.0 0.0 0.0 0.0\n50.0 0.0 0.0 0.0 0.0\n50.0 0.0 0.0 0.0 0.0\n50.0 0.0 0.0 0.0 0.0\n```\n\n\nThere are two other classes which handle storing the edge weights (Edge.java) and also comparing the edge weights (CompareEdges.java), but they are not relevant to this particular question.\n\nI hope that somebody is able to help as I have spent a number of hours attempting to solve this.\n\nMany thanks.\n\nMick\n    ", "Answer": "\r\nHere is the problem:\n\n```\npublic static void randomArray(int n){\n\n    n = 0;\n\n    double[][] array = new double[][] {{n, n, n, n, n}, {n, n, n, n, n}, {n, n, n, n, n}, {n, n, n, n, n}, {n, n, n, n, n}};\n    double mst3[][] = MST.PrimsMST(array);\n```\n\n\nYou create an array of 0's, and you apply MST to it. And then you override your array with random numbers, but the MST method was called on the array of 0's, not on the array of random numbers.\n\nAlso, on a design level, I think you should take some time to restructure and factorize your code a little, otherwise you will have a lot of problems when building more complicated projects:\n\n\nYou should call the MST methods from your main method(), or from a method, not from the top-level of the class.\nYou should also initialize your random generator in a method\nYou don't have to initialize an array with 0's, you can just specify the size. (the = {} initialization should only be used when you want to initialize your array with specific values)\nYou wrote 5 times an array displaying code, which is exactly the same, this is the sign that you should have a method doing this.\nAlso, you use arrays of ```\ndouble```\n to store ```\nint```\n, so I think you probably want to switch to ```\nint```\n\n\n\nSo I'm thinking your class should look more like this.\n\n```\npublic class Lab6{\n    static int[][] g= new int[][] {{0, 1, 2} , {1, 0, 3} , {2, 3, 0}};\n    static int[][] lecExample = new int[][] {{0, 1, 2, 3, 0} , {1, 0, 6, 0, 5} , {2, 6, 0 ,4, 1} , {3, 0, 4, 0, 2} , {0, 5, 1, 2, 0}};\n\n\n    public static void main(String[] args){\n        displayArray(g);\n        displayArray(MST.PrimMST(g));\n        displayArray(lecExample);\n        displayArray(MST.PrimMST(lecExample));\n\n        int[][] randomArray = getRandomArray(50);\n        displayArray(randomArray);\n        displayArray(MST.PrimMST(randomArray));\n    }\n\n    public static int[][] getRandomArray(int n){\n        int[][] a = new int[n][n];\n        Random r = new Random();\n\n        for(int i = 0; i < a.length; i++){\n            for(int j = 0; j < a[i].length; j++){\n                a[i][j] = r.nextInt();\n            }\n        }\n\n        return a;\n    }\n\n    public static void displayArray(int[] a){\n        for(int i = 0; i < a.length; i++){\n            for(int j = 0; j < a[i].length; j++){\n                System.out.print(\" \" + a[i][j]);\n            }\n            System.out.println(\"\");\n        }\n    }\n}\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Algorithm for finding spanning tree with minimum range in a given graph\r\n                \r\nGiven a weighted undirected graph G(v,e) with weights w(e), find the set of edges such that each pair of vertices (u,v)∈G are connected (in short, ```\nspanning tree```\n) and the range of weights of selected edges is minimum (or the difference between the minimum weight and the maximum weight is minimum).\nI tried greedy approach in which sorted the edges with respect to weights and then selected two edges with minimum weight difference between the consecutive edges (g[index = current_left],g[index+1 = current_right]) in the sorted array, subsequently I moved left or right depending on the minimum difference between the (current_left,current_left-```\nj```\n) or (current_right,current_right+```\nj```\n) where ```\nj```\n is incremented till we find an edge with at least one non-visited vertex.\nFor example:\n\nHere the minimum range that we can get is by selecting edges with weight {2,3,5} and the range is 3.\nPlease point a test case where the suggested algorithm fails and suggest an algorithm for finding such spanning tree.\nEdit:\nExpected time complexity is O(|E|log|E|) where |E| is number of edges.\n    ", "Answer": "\r\nYou should be able to do it in ```\nO(E * (cost of MST computation))```\n:\n\n```\nT = no tree\nfor all edge weights w_fix sorted in ascending order:\n    for all edges e:\n        if w(e) >= w_fix:\n            set w'(e) = w(e) - w_fix\n        else:\n            set w'(e) = infinity\n    find MST T' according to w'\n    if T == no tree or max edge weight(T) > max edge weight(T'):\n        set T := T'\nprint T\n```\n\n\nThe idea is that some edge weight has to be the minimum edge weight among the edges in an optimal spanning tree; so fix a minimum edge weight and find an MST that only contains edges heavier than that. Since all MSTs are also minimum bottleneck spanning trees, this will work.\n\n\n\nHere's an improvement that is optimal up to a log-square factor; the basic idea remains the same.\n\n```\nsort edge array E[] by increasing weights\n\nlow := high := 0\nopt_low := opt_high := 0\nopt := infinity\nconnected := false\n\nwhile (high < E.length - 1) or (connected):\n\n    if not connected:\n        high = high + 1\n    else:\n        low = low + 1\n\n    update(connected)\n\n    if connected:\n        if E[high].weight - E[low].weight < opt:\n            opt = E[high].weight - E[low].weight\n            opt_low = low\n            opt_high = high\n\nprint(opt, opt_low, opt_high)\n```\n\n\nThe idea is to keep a sliding window over the edges and use connectivity to maintain the window. To maintain connectivity information, you would use special data structures. There's a number of them that allow for polylogarithmic time costs to maintain connectivity information for both deleting and adding edges, and you can find information on those data structures in these MIT 6.851 lecture notes.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "About Minimum Spanning Tree Graph\r\n                \r\nIs there an algorithm better (More optimal,faster) than Prime and Kruskal's algorithms ?\n    ", "Answer": "\r\nPrime's algorithm and Kruskal's algorithms works really fast if it is implemented well. Try to use optimal data structures for your data set case.\nIn really you don't need in more faster algorithm in most cases.\n\nIf you need in parallel implementation of algorithm, than use Borůvka's algorithm.\n\nIf you need the theory-fastest algorithm, than check Decision trees algorithm.\n\nAnd there is special case with linear algorithm.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimal Spanning Tree allowing equal edges but each cycle in the Graph contains distinct edges\r\n                \r\nI need to prove that there exists only one Minimum Spanning Tree that allows the graph to have equal edges. If there are any cycles in the Graph, the edges in each cycle has distinct weights. We have to prove it assuming the Minimum Spanning Tree is calculated using Kruskal's Algorithm.\n\nCurrently this is what I have, but I do not think it is correct:\n\nAssume that we have two Minimum Spanning Tree (R1 & R2) for Graph G. Lets select t out of the minimum weighted edges throughout all edges. We will then say that t is an edge that is only in R1.  Let’s say that t is the exact path from nodes P to Q, then we know that R2 must have a path from P to Q. We know that the path from P to Q in R2 is not the edge t or else we would have a cycle in R2. One of those edges m that would be in the cycle is not in R1. By the definition of t being the pool of the smallest edged and that all edge costs are unique in cycles, the cost of m must be greater than the cost of t. We then know that the total weight of R1 is less than the total weight of R2 because t < m. This then makes it a contradiction making our assumption incorrect because only R1 is the Minimum Spanning Tree for G, therefore there would only be one Minimum Spanning Tree.\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "If a graph G has distinct edge costs > 0 (i.e. no two edge costs are the same), is every minimum-bottleneck tree of G also a minimum-spanning tree?\r\n                \r\nMy initial answer is yes with a proof by contradiction. \n\n\"Suppose there is a minimum-bottleneck tree T1 of G and a minimum spanning tree T2 of G such that T1 is not equal to T2. This means the total weight of edges of T1 is greater than the weight of edges of T2. Since all edge costs are distinct, this means the bottleneck edge value of T1 must be greater than that of T2 . However if this is true then that means T2 has a bottleneck smaller than that of T1 , meaning T1 is not an MBST, which is a contradiction. QED.\n\nI know if the edge costs are not distinct then the answer would be no, an MBST is not necessarily a MST but if the edge costs are distinct I believe that changes things.\n    ", "Answer": "\r\nYou are making a logical leap in concluding, \"Since all edge costs are distinct, this means the bottleneck edge value of T1 must be greater than that of T2\" from \"This means the total weight of edges of T1 is greater than the weight of edges of T2.\"\n\nThe total weight is a sum.  One sum can be bigger than another even though both have the same largest term.  Whether or not the numbers involved are distinct is irrelevant.\n\nLook for a small counter-example with 4 vertices and 4 edges.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to use union-find, minheap, Kruskal's, and a sort algorithm to create a minimum cost spanning tree? (C++)\r\n                \r\nI apologize if this question is a bit broad, but I'm having a difficult time trying to understand how I would create a minimum cost spanning tree. This is in C++ if it matters at all.\n\nFrom what I understand, you would use Kruskal's to select the minimum cost edges for building the spanning tree. My thinking is to read the edges into a minheap and that way you can remove from the top in order to get the edge with the minimum cost.\n\nSo far I've only been able to implement the minheap and sets for union-find, I am still unsure of the purpose of union-find and a sorting algorithm for the purpose of creating a spanning tree.\n\nI would greatly appreciate any advice. \n\nEDIT: I am not limited to union find, minheap, kruskals, and a sorting algorith, nor am I required to do any. These were just the items suggested by the instructor.\n    ", "Answer": "\r\nThese two structures serve different purposes in the algorithm.  Kruskal's algorithm works  by adding the cheapest possible edge at each point that doesn't form a cycle.  It can be shown using some not particularly complex math that this guarantees that the resulting spanning tree is minimal.  The intuition behind why this works is as follows.  Suppose that Kruskal's algorithm is not optimal and that there is a cheaper spanning tree.  Sort all of the edges in that tree by weight, then compare those edges in sorted order to the edges chosen by Kruskal's algorithm in sorted order.  Since we assume for contradiction that Kruskal's algorithm isn't optimal, there must be some place in the sequences where there's a disagreement.  If in this disagreement Kruskal's algorithm has a lighter edge than the optimal solution, then we can make the optimal solution even better by adding that edge in, finding the cycle it creates, then deleting the heaviest edge in the cycle.  That edge can't be the edge we just added, because otherwise that would have created a cycle in the MST produced by Kruskal's algorithm and Kruskal's algorithm never adds an edge that creates a cycle.  So this means that Kruskal's algorithm must have diverged from the optimal solution by not adding some light edge.  But the only reason Kruskal's algorithm skips an edge is if it creates a cycle, and this means that there must be a cycle in the optimal MST, also a contradiction.  This means that our assumption was wrong and that Kruskal's algorithm must be optimal.\n\nHopefully, this motivates why Kruskal's algorithm needs the heap and the union-find structure.  We need the heap so that we can get back all the edges in sorted order.  If we don't visit the edges in this order, then the above proof breaks down and all bets are off.  Interestingly, you don't actually need a heap; you just need some way of visiting all the edges in sorted order.  If you want, you can just dump all the edges into a giant array and then sort the array.  This doesn't change the runtime of the algorithm from the binary heap case if you use a fast sort.\n\nThe union-find structure is a bit trickier.  At each point in Kruskal's algorithm you need to be able to tell whether adding an edge would create a cycle in the graph.  One way to do this is to store a structure that keeps track of what nodes are already connected to one another.  That way, when adding an edge, you can check whether the endpoints are already connected.  If they are, then the edge would form a cycle and should be ignored.  The union-find structure is a way of maintaining this information efficiently.  In particular, its two operations - union and find - correspond to the act of connecting together two distinct groups of nodes that were previously not connected, as would be the case if you added an edge that connected two trees contained in different parts of the spanning forest.  The find step gives you a way to check if two nodes are already connected; if so you should skip the current edge.\n\nHope this helps!\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum Spanning Tree time complexity\r\n                \r\nI have this MST implementation for Prim Algo which is |V| to the power 3 . But the CLRS says it says the complexity is O (E * lg |V| ) assuming |V| ~ |E| its O(|V| * lg |V|) . My implementation may be fixed but i am not sure how can we go below |V| * |V| with a matrix implementation \n\n```\nclass matrix_graph\n{\nprivate:\n    int** v;\n    int vertexes;\npublic:\n    matrix_graph(int**, int);\n    ~matrix_graph(void);\n    bool is_connected(int i,int j);\n    int egde_weight(int i,int j){return v[i][j];}\n};\n\n\n\n\n\n\nint mst()\n{\n    int v[9][9] = {  \n        {0,4,0,0,0,0,0,0,8},\n        {0,0,8,0,0,0,0,0,11},\n        {0,8,0,7,0,4,0,2,0},\n        {0,0,7,0,9,14,0,0,0},\n        {0,0,0,9,0,10,0,0,0},\n        {0,0,4,14,10,0,2,0,0},\n        {0,0,0,0,0,2,0,6,1},\n        {0,0,2,0,0,0,6,0,7},\n        {8,11,0,0,0,0,1,7,0}\n    };\n\n    int* ptr_v[9];\n    for(int i=0;i<9;i++){\n        ptr_v[i] = & v[i][0];\n    }\n    matrix_graph* m = new matrix_graph(ptr_v , 9 );\n\n    std::set<int> tree;\n    tree.insert(0);\n\n        std::set<int> non_tree;\n        non_tree.insert(1);\n    non_tree.insert(2);\n    non_tree.insert(3);\n    non_tree.insert(4);\n    non_tree.insert(5);\n    non_tree.insert(6);\n    non_tree.insert(7);\n    non_tree.insert(8);\n\n    int i = 0;\n    int min = _I32_MAX;\n    int add_to_tree;\n    int sum = 0;\n\n    while(!non_tree.empty()){\n        for(std::set<int>::iterator iter = tree.begin() ; iter != tree.end() ; iter++ ){\n            for(std::set<int>::iterator iter_n = non_tree.begin() ; iter_n != non_tree.end() ; iter_n++){\n                int edge = m->egde_weight(*iter , *iter_n);\n                if( edge > 0 && edge < min)\n                {\n                    min = edge;\n                    add_to_tree = *iter_n;\n                }\n            }\n        }\n        tree.insert(add_to_tree);\n        non_tree.erase(add_to_tree);\n        sum += min;\n        min = _I32_MAX;\n    }\n    return sum;\n}\n```\n\n    ", "Answer": "\r\nYou need to representing the graph using Adjacency list (not Adjacency Matrix). Then your implementation can give O(E * lg |V| ).\n\nIf you further want to optimize the running time you can use Fibonacci heap to extract minimum. Then you can achieve  O (|E| + V * lg |V| ) running time. Using Fibonacci heap you can find and delete an element in amortized O(lg n) running. \n\nMore details:\n\nhttp://en.wikipedia.org/wiki/Fibonacci_heap\n\nFibonacci heap was also discussed in CLRS Book.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Finding a spanning tree that minimizes sum of nodes' depths\r\n                \r\nI have an undirected connected graph with unweighted edges. How can I build a spanning tree (the solution might not be unique) such that the sum of depths of all nodes is minimized? This is obviously not finding the minimum spanning tree, as the \"weight\" of edges actually vary depending on the the child's depth.\n\nI think that, given a designated root, the tree with minimum sum of depths can be formed by greedily connecting all you can connect as children, to each node in a breadth-first order. Therefore I am going to find the tree with minimum total depth by applying this same procedure N times, designating each of the N nodes as root, and choosing the minimum one among the N candidates. Is this a valid algorithm? Please point out if it is wrong, or if anything more efficient exists.\n    ", "Answer": "\r\n\n  Is this a valid algorithm?\n\n\nYes, the algorithm is correct.\n\nGiven a node ```\nR```\n that is to be considered the root of the spanning tree, the depth of a node ```\nN```\n in the spanning tree is at least the length of the shortest path from ```\nR```\n to ```\nN```\n in the graph, so the sum of the depths is at least the sum of the lengths of the shortest paths (from ```\nR```\n).\n\nThe tree constructed by the algorithm connects each node to ```\nR```\n with one of the shortest paths, so the sum of the depths is the sum of the distances, which we saw above is a lower bound.\n\nAs a small optimisation, if the number of nodes is at least 3, no nodes with degree 1 need to be considered as the root of the tree. (For a tree rooted at a node ```\nR```\n with degree 1, consider the same graph, viewed as a tree rooted at ```\nR```\n's neighbour. The depth of ```\nR```\n increases by 1, the depth of all other nodes decreases by 1, so the sum of depths decreases by ```\nnumber_of_nodes - 2```\n.)\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Finding the slimmest Spanning Tree\r\n                \r\nThis is basically an ICPC Tokyo regional question - Slim Span(UVA -1395)\n\nLink to the question-https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4141\n\nThe question states that the slimmest tree is one with minimum difference between its shortest and longest edge and the tree itself does not need to be a minimum spanning tree, it just needs to be a spanning tree. \n\n```\n#include <iostream>\n#include <vector>\n#include <stdio.h>\n#include <cstdlib>\n#include <cstring>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nconst int MAX = 110;\nstruct ii{\n    int first,second,third;\n    ii(int x, int y, int z){\n        first=x;//destination node\n        second=y;//weight of the edge\n        third=z;//slimness\n    }\n    bool operator<(const ii& rhs) const\n    {\n        return third > rhs.third;//slimmest edge first\n    }\n};\n\nvector <ii> adj[MAX];//adjacency list\n\nint prim(int source, int n){\n\n    int maximum=-1, minimum=987654321;//maximum and minimum edge lengths\n    set<int> notvisited;//nodes not yet visited by prim\n    priority_queue< ii, vector< ii > > pq;\n\n    for(int i=1;i<=n; ++i){\n        notvisited.insert(i);\n    }\n    pq.push(ii(source, 0,0));\n    set<int>::iterator iterator1;\n\n    while(!pq.empty() && !notvisited.empty()){\n        ii temp=pq.top();\n        pq.pop();\n        int s=temp.first;//target\n        int w=temp.second;//weight of edge\n          //if visited->continue\n        if((iterator1=notvisited.find(s))==notvisited.end())continue;\n        notvisited.erase(s);\n        if(w!=0){\n            maximum=max(maximum,w);\n            minimum=min(minimum,w);\n        }\n        for(int i=0; i<adj[source].size(); ++i){\n            int target=adj[source][i].first;\n            int targetw=adj[source][i].second;\n            int slimness=targetw-w;\n            if((iterator1=notvisited.find(target))!=notvisited.end()){\n                pq.push(ii(target,targetw,max(slimness, 0-slimness)));\n            }\n        }\n\n\n    }\n    return maximum-minimum;\n}\n```\n\n\nMy idea was to sort the edges using the slimness instead of the weights. It is not working because from the very start it always marks the shortest edge as visited. \n\nHow do I correct my program to solve this problem?\n\nSample Input-\n\n4 6//number of nodes, number of edges\n\n1 2 10//source destination weight\n\n1 3 100\n\n1 4 90\n\n2 3 20\n\n2 4 80\n\n3 4 40\n\nOutput-\n20\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum spanning tree to minimize cost\r\n                \r\nCan someone please help me solve this problem?\n\nWe have a set E of roads, a set H of highways, and a set V of different cities. We also have a cost x(i) associated to each road i and a cost y(i) associated to each highways i. We want to build the roads to connect the cities, with the conditions that there is always a path between any pair of cities and that we can build at most one highway, which may be cheaper than a road. \n\nSet E and set H are different, and their respective costs are unrelated.\n\nDesign an algorithm to build the roads (with at most one highway) that minimize the total cost.  \n    ", "Answer": "\r\nSo, what we have is a fully connected graph of edges.\n\nSolution steps:\n\n\nFind the minimum spanning tree for the roads alone and consider it as the minimum cost.\nAdd one highway to the roads graph an calculate the minimum spanning cost tree again.\ncompare step 2 cost with the minimum cost to replace it if its smaller.\nremove that high way.\ngo back to step 2 and go the steps again for each highway.\n\n\n\n  O(nm) = m*mst_cost(n)\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to find maximum spanning tree?\r\n                \r\nDoes the opposite of Kruskal's algorithm for minimum spanning tree work for it? I mean, choosing the max weight (edge) every step?\n\nAny other idea to find maximum spanning tree?\n    ", "Answer": "\r\nYes, it does.\n\n\n  One method for computing the maximum weight spanning tree of a network G –\n  due to Kruskal – can be summarized as follows.\n  \n  \n  Sort the edges of G into decreasing order by weight. Let T be the set of edges comprising the maximum weight spanning tree. Set T = ∅.\n  Add the first edge to T.\n  Add the next edge to T if and only if it does not form a cycle in T. If\n  there are no remaining edges exit and report G to be disconnected.\n  If T has n−1 edges (where n is the number of vertices in G) stop and\n  output T . Otherwise go to step 3.\n  \n\n\nSource: https://web.archive.org/web/20141114045919/http://www.stats.ox.ac.uk/~konis/Rcourse/exercise1.pdf.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "pre-order traversal of a Minimum spanning tree\r\n                \r\nIs there any way to print the pre-order traversal of the output given by MST (using Kruskal or Prim's algorithm). I have a confusion because the output may be or not a binary tree always. So, how the pre-order traversal is possible here? Can a normal DFS  do the task?\n    ", "Answer": "\r\nThe main issue when working with this kind of problem is the ambiguity of the word tree in algorithmic problems. There are two main definitions (those may in fact differ slightly):\n\n\nA tree is an acyclic connected (undirected) graph.\nA tree is basically a set of nodes, each one having a father (except one node, called the root node) and the list of sons for each node is ordered.\n\n\nHowever, you have to work with the second definition to assume that the concept of preoder traversal is well-defined (i.e. unique). \n\nA spanning tree, though, is only a tree in the first meaning. In particular, you have to pick out a root node and some order for the sons. Afterwards, a DFS will give you a preoder traversal indeed.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "how do I reduce this spanning tree problem to np-completeness?\r\n                \r\nI have the following algorithmic problem:\nIf I have a graph G=(V,E), does G have a spanning tree with exactly k leaves?\nLeaves being a vertex with only one neighbor in the spanning tree.\nAlso, i'm not looking for a minimum spanning tree, just a spanning tree.\nTO sum up, a solution algortihm would take as inputs a graph G and a number k, and return either true or false, depending on whether G has a spanning tree of k leaves\nExample:\nFor this graph:\n\nif k is 6, then my algorithm would output \"True\" because:\n\nNow I am pretty sure that this problem is np-complete, so I need to perform a reduction from a know np-complete problem.\nI just have no idea which problem, and how the reduction should look like, can you help out?\n    ", "Answer": "\r\nThe Hamiltonian path problem is a special case of your problem - a spanning tree with exactly k = 2 leaves is a Hamiltonian path. Testing for the existence of one is NP-complete.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Finding a Minimum Spanning Tree from an Adjacency List where the Adjacency List is in a string array using Prims Algorithm\r\n                \r\nSo I need some help coming up with a way to find a Minimum spanning tree.\nSuppose I have my graph in the form of an adjacency list:\n\n```\nA 2 B 12 I 25\nB 3 C 10 H 40 I 8\nC 2 D 18 G 55\nD 1 E 44\nE 2 F 60 G 38\nF 0\nG 1 H 35\nH 1 I 35\n```\n\n\nThe first letter tells which node you are looking at, and the number tells how many connections to any other node there are. For example, A has two connections - one each to B and I. After that, the number that follows the letters simply tell the weight of an edge. B has weight 12 and I has weight 25. So I had originally planned to represent this entire thing as a String array \ncalled ```\nGraph[8]```\n. Each line would be a different slot in the array. I am having difficulties figuring out how to accomplish this with either Prims or Kruskalls algorithm.\n    ", "Answer": "\r\nThis isn't a direct answer to your question per-say (seems like you're doing schoolwork), but I think it will help you get started.  Why not create a data structure that more closely matches your mental model and build up from there?\n\n```\nclass GraphNode { \n\n    final String name;\n    final List<GraphEdge> adjacentNodes;\n\n    public GraphNode(String name) { \n        this.name = name;\n        adjacentNodes = new ArrayList<GraphEdge>();\n    }\n\n    public void addAdjacency(GraphNode node, int weight) { \n        adjacentNodes.add(new GraphEdge(node, weight));\n    }\n\n}\n\nclass GraphEdge {\n\n    final GraphNode node;\n    final int weight;\n\n    public GraphEdge(GraphEdge node, int weight) {\n        this.node = node;\n        this.weight = weight;\n    }\n\n}\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Graph Minimum Spanning Tree using BFS\r\n                \r\nThis is a problem from a practice exam that I'm struggling with:\n\n\n  Let G = (V, E) be a weighted undirected connected graph, with positive\n  weights (you may assume that the weights are distinct). Given a real\n  number r, define the subgraph Gr = (V, {e in E | w(e) <= r}). For\n  example, G0 has no edges (obviously disconnected), and Ginfinity = G\n  (which by assumption is connected). The problem is to find the\n  smallest r such that Gr is connected.\n  \n  Describe an O(mlogn)-time algorithm that solves the problem by\n  repeated applications of BFS or DFS.\n\n\nThe real problem is doing it in O(mlogn). Here's what I've got:\n\n```\nr = min( w(e) )                            => O(m)\nwhile true do                              => O(m) \n  Gr = G with edges e | w(e) > r removed     => O(m)\n  if | BFS( Gr ).V | < |V|                   => O(m + n)\n    r++ (or r = next smallest w(e))          \n  else\n    return r\n```\n\n\nThat's a whopping O(m^2 + mn). Any ideas for getting it down to O(mlogn)? Thanks!\n    ", "Answer": "\r\nYou are iterating over all possible edge costs which results in the outer loop of O(m). Notice that if the graph is disconnected when you discard all edges >w(e), it is also disconnected for >w(e') where ```\nw(e') < w(e)```\n. You can use this property to do a binary search over the edge costs and thus do this in O(log(n)).\n\n```\nlo=min(w(e) for e in edges), hi=max(w(e) for e in edges)\nwhile lo<hi:\n   mid=(lo+hi)/2\n   if connected(graph after discarding all e where w(e)>w(mid)):\n       lo=mid\n   else:\n       hi=mid-1\nreturn lo\n```\n\n\nThe binary search has a complexity of O(log (max_e-min_e)) (you can actually bring it down to O(log(edges)) and discarding edges and determining connectivity can be done in O(edges+vertices), so this can be done in O((edge+vertices)*log(edges)).\n\nWarning: I have not tested this in code yet, so there may be bugs. But the idea should work.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Efficient minimal spanning tree in metric space\r\n                \r\nI have a large set of points (n > 10000 in number) in some metric space (e.g. equipped with Jaccard Distance). I want to connect them with a minimal spanning tree, using the metric as the weight on the edges. \n\n\nIs there an algorithm that runs in less than O(n2) time?\nIf not, is there an algorithm that runs in less than O(n2) average time (possibly using randomization)?\nIf not, is there an algorithm that runs in less than O(n2) time and gives a good approximation of the minimum spanning tree?\nIf not, is there a reason why such algorithm can't exist?\n\n\nThank you in advance!\n\nEdit for the posters below: \nClassical algorithms for finding minimal spanning tree don't work here. They have an E factor in their running time, but in my case E = n2 since I actually consider the complete graph. I also don't have enough memory to store all the >49995000 possible edges.\n    ", "Answer": "\r\nApparently, according to this: Estimating the weight of metric minimum spanning trees in sublinear time there is no deterministic o(n^2) (note: smallOh, which is probably what you meant by less than O(n^2), I suppose) algorithm. That paper also gives a sub-linear randomized algorithm for the metric minimum weight spanning tree.\n\nAlso look at this paper: An optimal minimum spanning tree algorithm which gives an optimal algorithm. The paper also claims that the complexity of the optimal algorithm is not yet known!\n\nThe references in the first paper should be helpful and that paper is probably the most relevant to your question.\n\nHope that helps.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to display minimum spannign tree matrix\r\n                \r\n```\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include<iomanip>\nusing namespace std;\n\ntypedef pair<int, int> intPair;// rename intPair\ntypedef vector<double> doubleVector; //rename doubleVetcor\ntypedef vector<intPair> intPairVector; // rename intPairVector\n\n// Union-Find Disjoint Sets Library written in OOP manner, using both path compression and union by rank heuristics\nclass UnionFind {                                              // OOP style\nprivate:\n        doubleVector p, rank, setSize;                       // remember: vi is vector<double>\n        int numSets;\npublic:\n        UnionFind(int N) {\n        setSize.assign(N, 1);\n        numSets = N;\n        rank.assign(N, 0);\n        p.assign(N, 0);\n        for (int i = 0; i < N; i++)\n                p[i] = i;\n        }\n        int findSet(int i) {\n                 return (p[i] == i) ? i : (p[i] = findSet(p[i]));\n        }\n        bool isSameSet(int i, int j) {\n                return findSet(i) == findSet(j);\n        }\n        void unionSet(int i, int j) {\n                if (!isSameSet(i, j)) {\n                        numSets--;\n                        int x = findSet(i), y = findSet(j);\n// rank is used to keep the tree short\n                        if (rank[x] > rank[y]) {\n                                p[y] = x;\n                                setSize[x] += setSize[y];\n                        }\n                        else{\n                                p[x] = y;\n                                setSize[y] += setSize[x];\n                                if (rank[x] == rank[y])\n                                        rank[y]++;\n                        }\n                }\n        }\n        int numDisjointSets() {\n                return numSets;\n        }\n        int sizeOfSet(int i) {\n                return setSize[findSet(i)];\n        }\n};\n\nvector<intPairVector> AdjList;\n\nint main() {\n        int num_verts=0;\n        cin >> num_verts;\n\n        //Pre-allocate a vector of num_verts rows, each of which is a vector\n        //of num_verts copies of 0.0\n        vector<vector<double>> matrix(num_verts, vector<double>(num_verts,0.0));\n\n        //Requires c++11 or higher\n        for(int row = 0; row<num_verts;++row) {\n                for(int col = 0; col<num_verts; ++col){\n                        cin >> matrix[row][col];\n                }\n        }\n\n        //print out the matrix we just read\n        for(int row = 0; row<num_verts; ++row) {\n                for(int col=0; col<num_verts;++col){\n cout << setprecision(2) << fixed <<  matrix[row][col] << \"\\t\";\n                }\n                cout << \"\\n\";\n        }\n        // Kruskal's algorithm merged\n        AdjList.assign(num_verts, intPairVector());\n        vector< pair<double, intPair> > EdgeList;   // (weight, two vertices) of the edge\n        for (int row = 0; row<num_verts; ++row) {\n                for(int col=0; col<num_verts;++col){\n                        EdgeList.push_back(make_pair(matrix[row][col], intPair(row,col)));\n                        AdjList[row].push_back(intPair(row,matrix[row][col]));\n                        AdjList[col].push_back(intPair(col,matrix[row][col]));\n                }\n        }\n\n\n\n        sort(EdgeList.begin(), EdgeList.end()); // sort by edge weight O(E log E)\n                      // note: pair object has built-in comparison function\n\n        double  mst_cost = 0.0;\n        UnionFind UF(num_verts);         // all V are disjoint sets initially\n\n        for (int i = 0; i < num_verts*num_verts; i++) {                      // for each edge, O(E)\n                pair<double,intPair> front = EdgeList[i];\n                if (!UF.isSameSet(front.second.first, front.second.second)) {  // check\n                        mst_cost += front.first;                // add the weight of e to MST\n                        UF.unionSet(front.second.first, front.second.second);    // link them\n                }\n        }                       // note: the runtime cost of UFDS is very light\n\n        //display the weight of the MST\n        cout << setprecision(2) << fixed << mst_cost << endl;\n  return 0;\n}\n```\n\n\nI am trying to display the minimum spanning tree from this code, I cannot figure out how to get this code to display the modified matrix. The code is working correctly, by that I mean it is compiling and calculating the correct weight for the graph. However, I am unsure how to display the minimum spanning tree from using Kruskals algorithm.  Thanks for any help\n    ", "Answer": "\r\nWhenever you add the weight of an edge to the weight of the MST, you should also add that edge to a list to keep track of the MST edges.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Algorithm to find the second best minimum spanning tree from a weighted graph\r\n                \r\nI'm trying to find the second best minimum spanning three from a weighted unoriented graph. I know how to compute the MST using Kruskal algorithm, and I was thinking to find the second best minimum algorithm this way: \n\nSteps:\n\n\nSort all the graph edges.\nCompute the MST using Kruskal\nGet the minimum weight edge from the graph that is not in the first MST and add it to the MST (now the MST has a cycle)\nRemove the maximum weight edge in the new formed cycle\n\n\nAnd this should be the second best MST right ? \n\nBy the way I know is a topic there pointing out an algorithm that iterates between each of the MST edges and runs Kruskal on the graph without the edge selected, I'm just asking if mine works.\n    ", "Answer": "\r\nIt does not work.\n\nAfter step 3, the newly added edge might become part of a cycle containing only edges with very low costs, so after steps 3 and 4, the overall cost of the MST can increase significantly.\n\nOn the other hand, the graph might contain another edge with similar cost to the one selected at step 3, which, when added in the MST, would be part of another cycle, say, containing edges with relatively high costs. Selecting this edge for step 3, and then applying step 4 would lead to another spanning tree, better than the one generated by the proposed algorithm.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "What is a minimal-spanning subnet?\r\n                \r\nWhat is a minimal-spanning subnet? How do you find it for a given set of IPv4 addresses? \nI know the minimum spanning tree but what is the minimum spanning subnet? and how to find it by the given ipv4 addresses?\n    ", "Answer": "\r\nA minimal spanning subnet is the longest prefix that covers an entire set of addresses.\nThe way to find this is to calculate all of the addresses in binary. Count the equal bits in both the IP addresses and stop when they are unequal.\nBitwise AND all of the bits to the left, that would be the longest prefix that covers the set. Append 0's to the right to make it a valid IP address. (8 bits in each octet)\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "spanning tree with exactly k colored edges\r\n                \r\nI have a connected, undirected graph with edges that are each either black or white, and an integer k.\nI'm trying to write an algorithm that tells whether or not a spanning tree exists with exactly k black edges (doesn't necessarily have to find the actual tree).\n\nI used Kruskal's algorithm to find the minimum and maximum possible number of black edges in a spanning tree.  If k is outside this range, no spanning tree with k edges can exist.\n\nBut I'm having trouble wrapping my mind around whether there is necessarily a spanning tree for every k within that range.  My intuition says yes, and it's worked for every example I've tried, but I can't figure out how to prove it. \n\nAny advice?  Thanks in advance.\n    ", "Answer": "\r\nLet G_min = spanning tree with the minimum # of black edges.\n\nLet G_max = spanning tree with the maximum # of black edges.\n\nLet k_min = # of black edges in G_min\n\nLet k_max = # of black edges in G_max\n\nThe proof goes as follows.  Set G = G_min.  Repeat for every black edge in G_max:\n\n```\n  1) If the edge is already in G, do nothing.\n  2) If the edge is not in G, add it to G and remove another edge\n     from the cycle thus induced in G.  Remove one not in G_max.\n```\n\n\nStep 2 is always possible because there is at least one edge not in G_max in every cycle.\n\nThis algorithm maintains the spanning-tree-ness of G as it goes.  It adds at most one black edge per step, so G demonstrates a spanning tree with k black edges for all k between k_min and k_max as it goes.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Two mst in one graph, require exactly the same weights on the edgs?\r\n                \r\nI need to find two different minimum spanning tree in one graph, I wanted to know if it must be that for every weight of a edge that exists in the first minimum spanning tree there is a edge with the same weight in the second minimum spanning tree.\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "A two way minimum spanning tree of a directed graph\r\n                \r\nGiven a directed graph with weighted edges, what algorithm can be used to give a sub-graph that has minimum weight, but allows movement from any vertex to any other vertex in the graph (under the assumption that paths between any two vertices always exist).\n\nDoes such an algorithm exist?\n    ", "Answer": "\r\nEven though they weren't right themselves, taking the time to follow Vitalii's Wikipedia links quickly uncovered this algorithm:\n\nhttp://en.wikipedia.org/wiki/Chu%E2%80%93Liu/Edmonds_algorithm\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "The minimum spanning tree： prim and kruskal\r\n                \r\nFor the prim algorithm for STL priority queue optimization and the algorithm using c ++ sort kruskal, what types of graphs are suitable for these two algorithms?\n    ", "Answer": "\r\nAs you might already know, \n\nPrim is good for dense graphs, and Kruskal is good for sparse ones.\n\nWith Kruskal, the algorithm complexity is dominated by sorting the edges.\n\nSo it's big O is ```\nO(E log E)```\n in general cases with normal efficient sorts.\n\nWith Prim, the complexity is similar with Dijkstra's algorithm. (You can modify Dijkstra code into Prim with ease)\n\nSo it's like ```\nO((V+E) log(V))```\n with priority queue(heap).\n\nSo when the Graph is sparse(```\nE < V```\n), Kruskal is ```\nO(E log E)```\n and Prim is ```\nO(V log V)```\n, so Kruslak wins.\n\nAnd when the Graph is dense(```\nE is close to V^2-1```\n), Prim is ```\nO(V^2 log V^2)```\n and Prim is ```\nO(V^2 log V)```\n, so Prim wins.\n\nBut in most cases, you can use both algorithm without noticeable differences. \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Definition of a spanning tree\r\n                \r\nI want to check if my understanding of a spanning tree (for undirected and connected graphs) is correct. \n\nFrom, what I have read online. A spanning tree is a subset of a graph, it contains the same amount of vertices of the graph, however it has a minimum amount of edges. There can also be many different spanning trees for a graph.\n\nI have seen some illustrations of spanning trees and their graph so i have tried to come up with my own example. \n\nhouse graph\n\nSo this image shows a house shaped graph. If I was to get rid of one edge in that house graph, this would be a spanning tree since there is an alternate pathway to get from one node to another.\n\nI could also potentially get rid of two edges if I make sure that there is still a path that exists between the two nodes.\n\nAm I correct in this assumption?\n    ", "Answer": "\r\nNo, you are not correct in this assumption, because you will have to remove 2 edges in order to build a spanning tree. Removing one edge will not work.\nThe house graph of you picture has 5 vertices, and 6 edges.\nA tree with ```\nn```\n vertices has ```\nn-1```\n edges, so a tree with 5 vertices needs to have 4 edges.  \n\nA spanning tree is not a tricky object, it really stands by its name. ```\nspanning```\n because it covers all vertices, and ```\ntree```\n because it is a tree.  \n\nIf you were to remove a single edge, there will still be a cycle in your graph, so it cannot be a tree (which is, by definition, a connected acyclic graph).  \n\nThat is one thing that is very easy to find out when you want to build a spanning tree of a graph, it is the number of edges to remove (or to keep, which is equivalent). The formula ```\n#vertices = #edges + 1```\n always holds in a tree.\nI advice you to have a look at all the definitions and characterisations of a tree, it is always useful to have more than one in mind, especially when it comes to trees.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "matlab minimum spanning tree keep busy\r\n                \r\nI use the grMinSpanTree function in matlab toolbox. But, when the number of nodes is high the code execution doesn't come to an end, it remains in forever busy state.\n\nI tried a lot of samples and they all work well when number of nodes is below 4000. But when I try the one with 8000 nodes I run for several hours and still no result.\n\nI am only beginner for graph theory and matlab. Is there any reason that may cause dead loop?\n    ", "Answer": "\r\nIf ```\nE```\n is the number of edges and ```\nV```\n is the number of vertices, this greedy algorithm runs in ```\nO(E * V)```\n.\n\nTherefore, the time growth is quadratic when ```\nE```\n and ```\nV```\n increase. There is no dead loop.\n\nIn addition, the memory space needed also increases and may force your computer to swap thus increasing dramatically the overall time.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Clustering after minimum spanning tree cut\r\n                \r\nWhat would be the optimal way of clustering nodes after cutting a MST with a maximum edge-length? My output from MST edge-length cut is a 2xN array where each element is an integer. The integers are the node identifiers that describe the edges. An example of the output would is given below: \n\n```\n>>> print array[0:3]\n[[  0   1]\n [  0   2]\n [  2  17]]\n```\n\n\nI'm typically dealing with 100 to 20,000 nodes. My MST code is sufficiently fast, but it's being bogged down by the clustering/grouping algorithm. It's a loop-heavy set of functions and that's what is slowing it down. Check out the following code. Any ideas on how to speed it up? I'm aware that this is a brute force method, so a cleaner method would be best. Thanks in advance for your help!\n\nCheers,\n\nEli\n\n```\ndef _super_intersection(edges):\n    group = set(edges[0])\n    index = np.array([0])\n    k = 0\n    while k < 100:\n        k += 1\n        i = 0\n        for edge in edges[1:]:\n             i += 1\n             edge = set(edge)\n             if group & edge:\n                 group = group | edge\n                 index = np.append(index, i)\n\nindex = np.unique(np.array(index))\nreturn group, index\n\n\ndef cluster(self, gmin = 5):\n    # A 2xN array of node IDs\n    edges = self.edges\n    group_nodes = {}\n    for no, edge in enumerate(edges):\n        try:\n            group, indice = _super_intersection(edges)\n            id_no = no                \n            edges = np.delete(edges,indice,0)\n            if len(group) >= gmin:\n                group_nodes[id_no] = list(group)\n        except:\n            self.group_nodes = group_nodes\n```\n\n    ", "Answer": "\r\nThe problem has been solved. Go to the NetworkX google group link to see the solution. \n\nhttp://groups.google.com/group/networkx-discuss/browse_thread/thread/4ac4250d460a1b75\n\nCheers,\n\nEli\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Algorithm for finding approximate minimum tree that spans a given subset of vertices?\r\n                \r\nGiven a weighted graph and a subset of two vertices in the graph, finding a minimum tree that spans all (both) vertices in the given subset reduces to finding a shortest path between the two vertices in the subset, which can be efficiently computed using standard path finding algorithms such as A*.\nBut what if we have more than two vertices in the subset? What if it contains n vertices? Is there an efficient algorithm for finding an approximate minimum tree that spans all those vertices?\nI guess this problem is a generalization of both the problem of finding a shortest path between two vertices in a graph and the problem of finding a minimum spanning tree of a graph.\nEdit: I realized that this problem is known as the Steiner tree problem, and is apparently NP-complete, so I changed my request for the algorithm to find a minimum such tree to finding an approximate minimum tree.\n    ", "Answer": "\r\nThere is no need to look for an approximate algorithm. State-of-the-art software usually finds optimal solutions even for Steiner tree problems with hundreds of thousands of edges. See\nhttps://scipjack.zib.de/ for the fastest software (disclaimer: I am one of the developers)\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Euclidean Minimum Spanning Tree Without Triangulation\r\n                \r\nI was looking through some text about finding the EMST (Euclidean MST) using Delaunay triangulation technique, but also read somewhere that the EMST can be found through a sweep line algorithm. Since this would easier implementing, I would like to implement this rather than using a existing library.\nCan anyone guide me/ direct me to a link to a (possibly free) paper/source that has this algorithm explained? \n    ", "Answer": "\r\nFrom this and going by the abstracts, this and this should get you started. They both use sweepline algorithms to obtain MST's\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Networkx Minimum Spanning Tree - precision issues?\r\n                \r\nI am creating a graph from a weighted adjacency matrix the size of 222 x 222 nodes. All of the weights given in the matrix are a floating point numbers between ```\n0.42757498546089029```\n and ```\n1.6671726002927263```\n. ```\nnx.minimum_spanning_tree(G, weight = \"weight\")```\n method gives me the first picture below, meanwhile if I multiply all matrix values by ```\n100.0```\n the same method gives me the second picture. This doesn't occur while plotting the same with ```\nigraph```\n. Documentation of ```\nNetworkx```\n is silent about precision issues. Do you know why it might occur?\n\n\n\nnetworkx code:\n\n```\nG=nx.from_numpy_matrix(M)\nG1=nx.minimum_spanning_tree(G, weight = \"weight\")\n\nlabels = {i : node_names[i][1] for i in G1.nodes()}\ncolors = {i : node_attributes[labels[i]] for i in G1.nodes()}\nfor i in G1.nodes():\n    G1.node[i][\"color\"] = 'white'\n    G1.node[i][\"style\"] = \"filled\"    \n    G1.node[i][\"fillcolor\"] = colors[i]\ncolor=nx.get_node_attributes(G1,'color')\nfillcolor=nx.get_node_attributes(G1,'fillcolor')\nH=nx.relabel_nodes(G1,labels)\nnx.draw(H, scale=30, nodelist=H.nodes(), linewidths=0, with_labels = True, node_size=500,font_size=8)\n```\n\n\nigraph code:\n\n```\n    g = igraph.Graph.Weighted_Adjacency(M.tolist())\n    for i, v in enumerate(g.vs):\n        v[\"color\"] = colors[i]\n        v[\"label\"] = labels[i]\n        v[\"frame_color\"] = colors[i]\n        v[\"label_size\"] = 10\n        v[\"size\"] = 26\n    G = g.spanning_tree(weights='weight', return_tree=True)\n    G.to_undirected()\n    igraph.plot(G, labels=False, bbox = (900, 900), margin=40, loops=False\n\n)\n```\n\n    ", "Answer": "\r\nWhat you see is expected behaviour and not a precision issue at all. As the name suggests, the spring layout \"simulates\" the action of springs between your nodes onto their positions. The node positions are initialised on a circle, and then the force of the springs is applied to your nodes for a certain number of iterations (50 by default). With weak connection weights, your nodes will more or less remain on the circle (first case), with strong weights your nodes will gravitate towards the centre (second case). \n\nIn igraph, by default, the unweighted graph is used to compute the layout and you need to give the plotting routine the weights explicitly. I suspect that you might have plotted the graph without specifying the \"weights\" parameter. \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Find the upper bound of the minimum number of spanning trees needed to cover all links in the graph\r\n                \r\nMy question:\n\nLet G(V,E) be a fully connected graph, where V is set of nodes and E is set of links. \nWhat is the upper bound (worst case) of the minimum number of spanning trees needed to cover all the links in the graph, if the spanning trees are sorted in lexicographic order?\n\nAs an example, for |V|=4, and thus |E|=6, G(V,E) contains the following 16 spanning trees (in lexicograhic order); note that labelling the links differently may produce different order of spanning trees.\n\n1 2 3\n\n1 2 4\n\n1 2 6\n\n1 3 4\n\n1 3 5\n\n1 3 6\n\n1 4 5\n\n1 5 6 \n\n2 3 4\n\n2 3 5\n\n2 4 5 \n\n2 4 6 \n\n2 5 6 \n\n3 4 6\n\n3 5 6 \n\n4 5 6\n\nIn this case, the minimum number of spanning trees needed to cover all the links in the graph\nwill be 5 spanning trees ({1 2 3},{1 2 4 },{1 2 6}, {1 3 4}, {1 3 5}). So all the links are included in these 5 spanning trees.\n\nIt is easy to count the number of spanning trees for small graph, but I have problem with larger sized graph, e.g., |V|>4.\n\nIs there any formula to compute the upper bound number for the spanning trees to cover all links in the graph?\n\nThanks alot\n    ", "Answer": "\r\nThere are V-1 edges in any MST, and (V)(V-1)/2 total edges. So the lower bound is ceiling(V/2).\n\nI think this is also an exact bound. \n\nYou should be able to find \"a\" combination of MSTs which do not reuse other edges till the the last steps. Think in terms of finding an MST, removing those edges, and still leaving the reduced graph connected, so that new MSTs can be embedded, without destroying the connectivity.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Storing Path information in Kruskal's Algorithm\r\n                \r\nI have generated a minimum spanning tree using Kruskal's algorithm and I wanted to know how to  store paths\n\nThis is my minimum spanning tree\n\n```\nLoc1 |  Loc2 |  Distance\n  02 |   10  |    2.00 Km\n  05 |   07  |    5.39 Km\n  02 |   09  |    5.83 Km\n  04 |   05  |    5.83 Km\n  06 |   08  |    5.83 Km\n  03 |   09  |    7.07 Km\n  01 |   04  |    11.18 Km\n  07 |   09  |    11.18 Km\n  07 |   08  |    15.81 Km\nTotal Weight = 70.12 Km\n----------------------------------------------------\n```\n\n    ", "Answer": "\r\nIt depends on how much extra space you have. Assume you need to be space-efficient:\n\n\nOrient the edges in such a way that the resulting structure has at\nmost one parent node for each node. How to do it? Just pick a node and make it the root. It's children are first level nodes etc\nNow store the resulting graph in the format child->parent (In your table you can make Loc1 column child and Loc2 column parent. Index it by child)\nFor given two nodes, a and y, whose distance needs to be calculated, find their parental sets and see where they intersect. Ex. If parent of x is A, A's parent is B... the parental path is ABCDLMN (where N is the root). Similarly if the parental root for y is EFLMN. As you can see, the lowest common root for both of them is L. Distance from x->L is 5, y->L is 3, => distance between x and y is 5+3=8.\n\n\nComplexity:  O(hlogn) where h is the height of the tree and n is the number of elements in the tree (I am assuming lookup time for each node in logn).\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Given an unweighted graph how do I find a spanning tree with 1. Maximum number of leaves 2 minimum number of leaves\r\n                \r\n\nwrite an algorithm to find a spanning tree that has the maximum number of leaves.\nWrite an algorithm to find a spanning tree with minimum number of nodes.\n\n\nI am yet not able to come up with a solution for the following questions. \n\nFor the first part what I thought is to find the vertex with the highest degree and place it in the second last level such that the last level gets the maximum number of leaves.\n    ", "Answer": "\r\n\nFinding a spanning tree of a graph with maximum number of leaves is an NP-Complete problem. There is a reduction from the Dominating Set Problem which is NP-Complete.\nFinding a spanning tree of a graph with minimum number of leaves is also an NP-Complete problem. Suppose if the graph has a Hamiltonian path then the graph has a spanning tree with just two leaves. Thus finding a spanning tree of a graph with minimum number of leaves is equivalent to finding whether a graph has a Hamiltonian path or not.    \n\n\nSo for both the problems you need to develop approximation algorithms. \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Error on Implementing Kruskal´s Minimal Spanning Tree in Java\r\n                \r\ni tried to implement Kruskal´s Minimal Spanning Tree in Java. I´m using Eclipse for writing.\nI used this website (https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/) to get started and changed the Code with german commands and my own, bigger example.\n\nHere is my Code:\n\n```\npackage Kruskal_Algorithmus;\n\n//Java-Programm für den Kruskal Algorithmus\n//Ziel ist es einen minimalen Spannbaum aus einem gegebenen zusammenhängenden, ungerichteten, endlichen\n//und kantengewichteten Graphen zu erzeugen.\n\nimport java.util.*; \nimport java.lang.*; \nimport java.io.*; \n\nclass Graph \n{ \n    // Erstellung einer Klasse zur Erzeugung einer neuen Kante im Graphen \n    class Kante implements Comparable<Kante> \n    { \n        int quelle, richtung, gewicht; \n\n        // Erzeugung einer Vergleichs-Funktion damit eine Sortierung der gegeben Kanten\n        // nach ihrem Gewicht / Kosten möglich ist\n        public int compareTo(Kante kantenVergleich) \n        { \n            return this.gewicht-kantenVergleich.gewicht; \n        } \n    }; \n\n\n    // Erstellung einer Klasse um Teilmenge mit Hilfe von Union-Find zu finden\n    class subset \n    { \n        int parent, rank; \n    }; \n\n\n\n    int K, E; // K => Anzahl der Knoten & E => Anzahl der Kanten \n    Kante kante[]; // Zusammenfassung aller Kanten im Kanten-Array \n\n    // Graph mit K Knoten und E (edge) Kanten wird erstellt\n    Graph(int k, int e) \n    { \n        K = k; \n        E = e; \n        kante = new Kante[E]; \n        for (int i=0; i<e; ++i) \n            kante[i] = new Kante(); \n    } \n\n    // Erstellung einer Funktion die eine gewünschte Teilmenge aus den Elemente i heraus sucht\n    // (Anwendung von \"Path compression\")\n    int find(subset teilmengen[], int i) \n    { \n        // Suche und vergabe der Eltern-Teilmenge (parent) \n        if (teilmengen[i].parent != i) \n            teilmengen[i].parent = find(teilmengen, teilmengen[i].parent); \n\n        return teilmengen[i].parent; \n    } \n\n    // Eine Funktion die die Teilmengen x und y vereint und das Array subsets bildet\n    void Union(subset subsets[], int x, int y) \n    { \n        int xroot = find(subsets, x); \n        int yroot = find(subsets, y); \n\n        // Teilbäume werden nach ihrem Rang in der Sortierung geordnet\n        if (subsets[xroot].rank < subsets[yroot].rank) \n            subsets[xroot].parent = yroot; \n        else if (subsets[xroot].rank > subsets[yroot].rank) \n            subsets[yroot].parent = xroot; \n\n        // Falls zwei Mal der selbe Rang auftaucht wird ein Element einen Rang weiter nach unten geschoben\n        else\n        { \n            subsets[yroot].parent = xroot; \n            subsets[xroot].rank++; \n        } \n    } \n\n    // Funktion zur Erstellung des Minimal Spanning Tree nach Kruskal\n    void KruskalMST() \n    { \n        Kante ergebnis[] = new Kante[K]; // hier wird finaler MST gespeichert\n        int e = 0; // Index-Variable, welche für das Ergebnis-Array benötigt wird \n        int i = 0; // Index-Variable welche für die sortierten Kanten benötigt wird\n        for (i=0; i<K; ++i) \n            ergebnis[i] = new Kante(); \n\n        // Schritt 1: Alle Kanten werden in nicht absteigender Reihenfolge nach ihrem \n        // Gewicht / ihren Kosten sortiert.\n        // Da gegebener Graph ggf. nicht zu ändern ist, erstellen wir eine Kopie\n        // des Kanten-Arrays.\n        Arrays.sort(kante); \n\n        // Zuweisung, unter welchem Array die zu erzeugenden Teilmengen gespeichert werden\n        subset subsets[] = new subset[K]; \n        for(i=0; i<K; ++i) \n            subsets[i]=new subset(); \n\n        // Teilmengen mit einzelnen Elementen werden erzeugt\n        for (int v = 0; v < K; ++v) \n        { \n            subsets[v].parent = v; \n            subsets[v].rank = 0; \n        } \n\n        i = 0; // Index-Variable, welche die nächste zubearbeitende Kante auswählt \n\n        // Ziel: Kantenmenge des MSP = Knotenanzahl - 1 \n        while (e < K - 1) \n        { \n            // Schritt 2: Kante mit geringsten Kosten wird ausgewählt.\n            // Index-Variable wird für nächste Wiederholung um 1 erhöht.\n            Kante next_edge = new Kante(); \n            next_edge = kante[i++]; \n\n            int x = find(subsets, next_edge.quelle); \n            int y = find(subsets, next_edge.richtung); \n\n            // Wenn das hinzufügen der Kante in den MST keinen Kreis / Zyklus ergibt,\n            // wird Kante zur Lösung hinzugefügt und Variable des Lösungs-Index um 1 erhöht.\n\n            if (x != y) \n            { \n                ergebnis[e++] = next_edge; \n                Union(subsets, x, y); \n            } \n            // Falls es doch zu einem Kreis kommt, wird die ausgewählte Kante verworfen.\n        } \n\n        // Ergebnisse werden mithilfe des Ergebnis-Arrays auf der Konsole ausgegeben.\n        // Der fertige MST ist erkennbar. \n        System.out.println(\"Der gesuchte Minimal Spanning Tree wird folgendermaßen aufgebaut:\"); \n        for (i = 0; i < e; ++i) \n            System.out.println(ergebnis[i].quelle+\" -> \" + \n                ergebnis[i].richtung+\" Gewicht: \" + ergebnis[i].gewicht); \n    } \n\n    // ausführbares Programm: \n    public static void main (String[] args) \n    { \n\n        //gegebener Graph wird im Programm erstellt:\n\n        int knotenAnzahl = 12; // Anzahl der Knoten im gegebenen Graphen \n        int kantenAnzahl = 66; // Anzahl der Kanten im gegebenen Graphen\n        Graph graph = new Graph(knotenAnzahl, kantenAnzahl); \n\n        // Kante 1 -> 2\n        graph.kante[0].quelle = 1; \n        graph.kante[0].richtung = 2; \n        graph.kante[0].gewicht = 32; \n\n        // Kante 1 -> 3 \n        graph.kante[1].quelle = 1; \n        graph.kante[1].richtung = 3; \n        graph.kante[1].gewicht = 45; \n\n        // Kante 1 -> 4\n        graph.kante[2].quelle = 1; \n        graph.kante[2].richtung = 4; \n        graph.kante[2].gewicht = 43; \n\n        // Kante 1 -> 5 \n        graph.kante[3].quelle = 1; \n        graph.kante[3].richtung = 5; \n        graph.kante[3].gewicht = 28; \n\n        // Kante 1 -> 6 \n        graph.kante[4].quelle = 1; \n        graph.kante[4].richtung = 6; \n        graph.kante[4].gewicht = 11; \n\n        // Kante 1 -> 7 \n        graph.kante[5].quelle = 1; \n        graph.kante[5].richtung = 7; \n        graph.kante[5].gewicht = 16;\n\n        // Kante 1 -> 8 \n        graph.kante[6].quelle = 1; \n        graph.kante[6].richtung = 8; \n        graph.kante[6].gewicht = 28;    \n\n        // Kante 1 -> 9 \n        graph.kante[7].quelle = 1; \n        graph.kante[7].richtung = 9; \n        graph.kante[7].gewicht = 37;\n\n        // Kante 1 -> 10 \n        graph.kante[8].quelle = 1; \n        graph.kante[8].richtung = 10; \n        graph.kante[8].gewicht = 46;\n\n        // Kante 1 -> 11\n        graph.kante[9].quelle = 1; \n        graph.kante[9].richtung = 11; \n        graph.kante[9].gewicht = 8;\n\n        // Kante 1 -> 12 \n        graph.kante[10].quelle = 1; \n        graph.kante[10].richtung = 12; \n        graph.kante[10].gewicht = 5;\n\n        // Kante 2 -> 3\n        graph.kante[11].quelle = 2; \n        graph.kante[11].richtung = 3; \n        graph.kante[11].gewicht = 12;\n\n        // Kante 2 -> 4\n        graph.kante[12].quelle = 2; \n        graph.kante[12].richtung = 4; \n        graph.kante[12].gewicht = 16;\n\n        // Kante 2 -> 5 \n        graph.kante[13].quelle = 2; \n        graph.kante[13].richtung = 5; \n        graph.kante[13].gewicht = 42;\n\n        // Kante 2 -> 6 \n        graph.kante[14].quelle = 2; \n        graph.kante[14].richtung = 6; \n        graph.kante[14].gewicht = 36;\n\n        // Kante 2 -> 7\n        graph.kante[15].quelle = 2; \n        graph.kante[15].richtung = 7; \n        graph.kante[15].gewicht = 22;\n\n        // Kante 2 -> 8\n        graph.kante[16].quelle = 2; \n        graph.kante[16].richtung = 8; \n        graph.kante[16].gewicht = 17;\n\n        // Kante 2 -> 9\n        graph.kante[17].quelle = 2; \n        graph.kante[17].richtung = 9; \n        graph.kante[17].gewicht = 50;\n\n        // Kante 2 -> 10\n        graph.kante[18].quelle = 2; \n        graph.kante[18].richtung = 10; \n        graph.kante[18].gewicht = 33;\n\n        // Kante 2 -> 11\n        graph.kante[19].quelle = 2; \n        graph.kante[19].richtung = 11; \n        graph.kante[19].gewicht = 8;\n\n        // Kante 2 -> 12\n        graph.kante[20].quelle = 2; \n        graph.kante[20].richtung = 12; \n        graph.kante[20].gewicht = 2;\n\n        // Kante 3 -> 4\n        graph.kante[21].quelle = 3; \n        graph.kante[21].richtung = 4; \n        graph.kante[21].gewicht = 41;\n\n        // Kante 3 -> 5\n        graph.kante[22].quelle = 3; \n        graph.kante[22].richtung = 5; \n        graph.kante[22].gewicht = 34;\n\n        // Kante 3 -> 6\n        graph.kante[23].quelle = 3; \n        graph.kante[23].richtung =6; \n        graph.kante[23].gewicht = 47;\n\n        // Kante 3 -> 7\n        graph.kante[24].quelle = 3; \n        graph.kante[24].richtung = 7; \n        graph.kante[24].gewicht = 49;\n\n        // Kante 3 -> 8\n        graph.kante[25].quelle = 3; \n        graph.kante[25].richtung = 8; \n        graph.kante[25].gewicht = 46;\n\n        // Kante 3 -> 9\n        graph.kante[26].quelle = 3; \n        graph.kante[26].richtung = 9; \n        graph.kante[26].gewicht = 36;\n\n        // Kante 3 -> 10\n        graph.kante[27].quelle = 3; \n        graph.kante[27].richtung = 10; \n        graph.kante[27].gewicht = 49;\n\n        // Kante 3 -> 11\n        graph.kante[28].quelle = 3; \n        graph.kante[28].richtung = 11; \n        graph.kante[28].gewicht = 32;\n\n        // Kante 3 -> 12\n        graph.kante[29].quelle = 3; \n        graph.kante[29].richtung = 12; \n        graph.kante[29].gewicht = 35;\n\n        // Kante 4 -> 5\n        graph.kante[30].quelle = 4; \n        graph.kante[30].richtung = 5; \n        graph.kante[30].gewicht = 35;\n\n        // Kante 4 -> 6\n        graph.kante[31].quelle = 4; \n        graph.kante[31].richtung = 6; \n        graph.kante[31].gewicht = 42;\n\n        // Kante 4 -> 7\n        graph.kante[32].quelle = 4; \n        graph.kante[32].richtung = 7; \n        graph.kante[32].gewicht = 2;\n\n        // Kante 4 -> 8\n        graph.kante[33].quelle = 4; \n        graph.kante[33].richtung = 8; \n        graph.kante[33].gewicht = 2;\n\n        // Kante 4 -> 9\n        graph.kante[34].quelle = 4; \n        graph.kante[34].richtung = 9; \n        graph.kante[34].gewicht = 12;\n\n        // Kante 4 -> 10\n        graph.kante[35].quelle = 4; \n        graph.kante[35].richtung = 10; \n        graph.kante[35].gewicht = 47;\n\n        // Kante 4 -> 11\n        graph.kante[36].quelle = 4; \n        graph.kante[36].richtung = 11; \n        graph.kante[36].gewicht = 39;\n\n        // Kante 4 -> 12\n        graph.kante[37].quelle = 4; \n        graph.kante[37].richtung = 12; \n        graph.kante[37].gewicht = 15;\n\n        // Kante 5 -> 6\n        graph.kante[38].quelle = 5; \n        graph.kante[38].richtung = 6; \n        graph.kante[38].gewicht = 19;\n\n        // Kante 5 -> 7\n        graph.kante[39].quelle = 5; \n        graph.kante[39].richtung = 7; \n        graph.kante[39].gewicht = 20;\n\n        // Kante 5 -> 8\n        graph.kante[40].quelle = 5; \n        graph.kante[40].richtung = 8; \n        graph.kante[40].gewicht = 5;\n\n        // Kante 5 -> 9\n        graph.kante[41].quelle = 5; \n        graph.kante[41].richtung = 9; \n        graph.kante[41].gewicht = 23;\n\n        // Kante 5 -> 10\n        graph.kante[42].quelle = 5; \n        graph.kante[42].richtung = 10; \n        graph.kante[42].gewicht = 14;\n\n        // Kante 5 -> 11\n        graph.kante[43].quelle = 5; \n        graph.kante[43].richtung = 11; \n        graph.kante[43].gewicht = 9;\n\n        // Kante 5 -> 12\n        graph.kante[44].quelle = 5; \n        graph.kante[44].richtung = 12; \n        graph.kante[44].gewicht = 47;\n\n        // Kante 6 -> 7\n        graph.kante[45].quelle = 6; \n        graph.kante[45].richtung = 7; \n        graph.kante[45].gewicht = 43;\n\n        // Kante 6 -> 8\n        graph.kante[46].quelle = 6; \n        graph.kante[46].richtung = 8; \n        graph.kante[46].gewicht = 6;\n\n        // Kante 6 -> 9\n        graph.kante[47].quelle = 6; \n        graph.kante[47].richtung = 9; \n        graph.kante[47].gewicht = 24;\n\n        // Kante 6 -> 10\n        graph.kante[48].quelle = 6; \n        graph.kante[48].richtung = 10; \n        graph.kante[48].gewicht = 32;\n\n        // Kante 6 -> 11\n        graph.kante[49].quelle = 6; \n        graph.kante[49].richtung = 11; \n        graph.kante[49].gewicht = 44;\n\n        // Kante 6 -> 12\n        graph.kante[50].quelle = 6; \n        graph.kante[50].richtung = 12; \n        graph.kante[50].gewicht = 3;\n\n        // Kante 7 -> 8\n        graph.kante[51].quelle = 7; \n        graph.kante[51].richtung = 8; \n        graph.kante[51].gewicht = 14;\n\n        // Kante 7 -> 9\n        graph.kante[52].quelle = 7; \n        graph.kante[52].richtung = 9; \n        graph.kante[52].gewicht = 26;\n\n        // Kante 7 -> 10\n        graph.kante[53].quelle = 7; \n        graph.kante[53].richtung = 10; \n        graph.kante[53].gewicht = 39;\n\n        // Kante 7 -> 11\n        graph.kante[54].quelle = 7; \n        graph.kante[54].richtung = 11; \n        graph.kante[54].gewicht = 8;\n\n        // Kante 7 -> 12\n        graph.kante[55].quelle = 7; \n        graph.kante[55].richtung = 12; \n        graph.kante[55].gewicht = 24;\n\n        // Kante 8 -> 9\n        graph.kante[56].quelle = 8; \n        graph.kante[56].richtung = 9; \n        graph.kante[56].gewicht = 1;\n\n        // Kante 8 -> 10\n        graph.kante[57].quelle = 8; \n        graph.kante[57].richtung = 10; \n        graph.kante[57].gewicht = 19;\n\n        // Kante 8 -> 11\n        graph.kante[58].quelle = 8; \n        graph.kante[58].richtung = 11; \n        graph.kante[58].gewicht = 14;\n\n        // Kante 8 -> 12\n        graph.kante[59].quelle = 8; \n        graph.kante[59].richtung = 12; \n        graph.kante[59].gewicht = 39;\n\n        // Kante 9 -> 10\n        graph.kante[60].quelle = 9; \n        graph.kante[60].richtung = 10; \n        graph.kante[60].gewicht = 6;\n\n        // Kante 9 -> 11\n        graph.kante[61].quelle = 9; \n        graph.kante[61].richtung = 11; \n        graph.kante[61].gewicht = 47;\n\n        // Kante 9 -> 12\n        graph.kante[62].quelle = 9; \n        graph.kante[62].richtung = 12; \n        graph.kante[62].gewicht = 25;\n\n        // Kante 10 -> 11\n        graph.kante[63].quelle = 10; \n        graph.kante[63].richtung = 11; \n        graph.kante[63].gewicht = 15;\n\n        // Kante 10 -> 12\n        graph.kante[64].quelle = 10; \n        graph.kante[64].richtung = 12; \n        graph.kante[64].gewicht = 21;\n\n        // Kante 11 -> 12\n        graph.kante[65].quelle = 11; \n        graph.kante[65].richtung = 12; \n        graph.kante[65].gewicht = 11;\n\n\n        graph.KruskalMST(); \n    } \n} \n```\n\n\nIn Eclipse i get this Error Code:\n\n```\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index 12 out of bounds for length 12\n    at Kruskal_Algorithmus.Graph.find(Graph.java:53)\n    at Kruskal_Algorithmus.Graph.KruskalMST(Graph.java:117)\n    at Kruskal_Algorithmus.Graph.main(Graph.java:479)\n```\n\n\nI´m really new to Java Coding, and have no clue how to get this program working. I hope you have some tips for me.\n\nThank you!\n    ", "Answer": "\r\nYour numbering of graph nodes seems to start with 1: ```\n1, 2, 3, ..., 12```\n\n\nArray indexes in Java however start with ```\n0```\n. When you create an array of 12 items, the last item has index 11. There is no array element at index 12.\n\nYou have a few options: You could change your numbering so that node number matches with array indexes. This is likely the easiest. For example what was an edge 6-12 changes to an edge 5-11.\n\n```\n    // Kante 6 -> 12\n    graph.kante[50].quelle = 5; \n    graph.kante[50].richtung = 11;\n```\n\n\nAlternatively, subtract 1 from the node number to get the index in your loops. OR add extra space to all arrays that are indexed by graph node. For example:\n\n```\n    subset subsets[] = new subset[K + 1];\n```\n\n\nIf you choose the last option you'll also have to change any loops that iterate on nodes. The currently iterate on 0-11 when your nodes are numbered 1-12.\n\n```\n    for(i=1; i<=K; ++i) \n        subsets[i]=new subset(); \n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Finding two minimum spanning trees in graph such that their sum is minimal\r\n                \r\nI'm trying to solve pretty complex problem with graphs, namely we have given undirected graph with N(N <= 10)nodes and M (M <= 25)edges. \n\nLet's say we have two sets of edges A and B, we can't have two same edges in both A and B, also there can be edges that wont be used in the any of those sets, each edge is assigned value to it. We want to minimize the total sum of the two trees.\n\nPlease note that in both sets A and B the edges should form connected graph with all N nodes.\n\nExample\n\nN = 2, M = 3\n\nEdges: 1 - 2, value = 10, 1 - 2, value: 20, 2 - 1, value 30, we want to return the result 30, in the set A we take the first edge and in set B the second edge.\n\nN = 5\nM = 8\n\nEdges: {\n (1,2,10),\n (1,3,10),\n (1,4,10),\n (1,4,20),\n (1,5,20),\n (2,3,20),\n (3,4,20),\n (4,5,30),\n}\n\nset A contains edges {(1,2,10), (1,3,10), (1,4,10), (1,5,20)}\n\nwhile set B contains {(1,4,20), (2,3,20), (3,4,20), (4,5,30)}\n\nWhat I tried\n\nFirstly I coded greedy solution, I first generated the first minimum spanning tree and then I generated with the other edges the second one, but it fails on some test cases. So I started thinking about this solution:\n\nWe can see that we want to split the edges in two groups, also we can see that in each group we want to have N - 1 edges to make sure the graph doesn't contain not-wanted edges, Now we see that in worse-case we will use (N-1) + (N-1) edges, that is 18 edges. This is small numbers, so we can run backtracking algorithm with some optimizations to solve this problem.\n\nI still haven't coded the backtracking because I'm not sure if it will work, please write what do you think. Thanks in advance.\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Spanning tree of directed graph with networkx\r\n                \r\nI have a directed graph G in networkx and I want to get the minimum spanning tree of it.\nI do:\n\n```\n T = nx.algorithms.minimum_spanning_tree( G.to_undirected()  )\n```\n\n\nThis is undirected and I would like to restore the directions but I don't know how to do it.\nI tried:\n\n```\nG[T.edges()]\n```\n\n\nThis last line looks very pythonic but this is not the way networkx works, apparently...\nDoes anyone knows how to do it?\n\nIn other words: How can I get the subgraph of a directed tree given the (undirected) edges ?\n    ", "Answer": "\r\nYou can get the edges in ```\nG```\n that appear in the MST ```\nT```\n with a simple comprehension:\n\n```\nE = set(T.edges())  # optimization\n[e for e in G.edges() if e in E or reversed(e) in E]\n```\n\n\nYou can then build a new graph from this.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum spanning Tree which includes an edge\r\n                \r\nI want to describe an alorithm;\n\nLet G be a weighted, undericted graph. Given an edge 'e', is there an MST which includes this ```\ne```\n edge?\n\n\n  What I did:  I built a graph:\n  \n  ```\nG'=(V,E') | E={e'|e' -in E\\{e} ,w(e')=< w(e)}```\n\n  \n  And now I just find if there is a path from u to v (u and v are the two sides of the edge ```\ne```\n)  using DFS or BFS\n\n\nWhat they did was the same but with this change :\n\nG'=(V,E') | E={e'|e' -in E ,w(e') < w(e)}`\n\nI still can't understand how there algorithm is true ? Why didn't they exclude e from E ?\n    ", "Answer": "\r\nThe idea is the same as in Kruskal's algorithm.\n\nTheir Correctness Proof:\nThey build a graph that contains edges with edge weights strictly less than ```\nw_e```\n. If there is already a path from ```\nu```\n to ```\nv```\n then ```\ne```\n cannot be in any MST of G because then ```\ne```\n would be the largest weight edge in a cycle.\nAlso, if there is no path yet from ```\nu```\n to ```\nv```\n then we can add ```\ne```\n (as in Kruskal's algorithm) and build an MST containing ```\ne```\n.\n\nIn your case:\nYou find the MST of the graph that does not contain ```\ne```\n but has edges with weights <= ```\nw_e```\n. If there is already a path from ```\nu```\n to ```\nv```\n, then that path may contain an edge e' having a weight equal to e. So we can replace ```\ne'```\n with ```\ne```\n and get an MST. Hence your algorithm checks if ```\ne```\n is present in all MSTs of G.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "igraph: subsetting edges with iterators\r\n                \r\nSuppose I have an igraph object\n\n```\ng <- erdos.renyi.game(20, 0.6)\n```\n\n\nand I get the minimum spanning tree\n\n```\nmin.span <- minimum.spanning.tree(g)\n```\n\n\nHow can I get the edges of g that are part of the minimum spanning tree using iterators E() or V()?\n    ", "Answer": "\r\nI would just mark the edges in the original graph with an edge attribute. E.g. \n\n```\ng <- erdos.renyi.game(20, 0.6)\nE(g)$mark <- seq_len(ecount(g))\nmin.span <- minimum.spanning.tree(g)\nE(min.span)$mark\n#> [1]  1  2  3  6  8 10 12 15 19 22 26 32 42 52 62 67 76 84 94\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Prove that a subgraph is a minimum spanning tree\r\n                \r\nGiven:\n\n```\nG = (V,E)\nT is an MST of G\nG'=(V', E') ⊆ G\nT' is an MST of G'\n```\n\n\nProve:\n\n```\n(V',E∩T) is a subgraph of T'\n\nUnder what conditions is E∩T an MST of G'?\n```\n\n\nThe edge-weights need not be distinct.\n\nMy approach:\n\nBy applying Kruskal's algorithm to edges in ```\nE∩T```\n, one would join edges in ascending order of weight and simultaneously ensure that a join does not produce a cycle. This will produce an MST, but can a we show that this MST is a subgraph of ```\nT'```\n?\n\nDoes this approach make sense? Since I do not use the fact that ```\nT```\n is the MST of ```\nG```\n, I have a hunch that I'm ignoring something important.\n    ", "Answer": "\r\nFirst observation: any graph with number of nodes ```\n|V'|```\n and number of edges other than ```\n|V'|-1```\n is not a tree, so one necessary condition is: ```\n|E∩T| = |V'|-1```\n  \n\nSecond observation: if ```\nT'```\n is MST of ```\nG'```\n then the sum of its edges is minimal among all other possible spanning trees of ```\nG'```\n. which means that if ```\n(V', E∩T)```\n is MST of ```\nG'```\n, then the sum of its edges has to be equal to the sum of edges of ```\nT'```\n  \n\nFrom observations above, the necessary and sufficient conditions for ```\n(V', E∩T)```\n being MST of ```\nG'```\n is:\n1. ```\n|E∩T| = |V'|-1```\n\n2. ```\nsumofweights((V', E∩T))=sumofweights(T')```\n  \n\nSo, basically what you need to do is to count the number of edges in ```\nE∩T```\n and compare with ```\n|V'|-1```\n, and also calculate the sum of edge weights in ```\nT'```\n and compare with the sum of edge weights in ```\nE∩T```\n  \n\nHowever I got some suspicions about this line: ```\n(V',E∩T) is a subgraph of T'```\n\nSince ```\nT'```\n also has ```\nV'```\n nodes, any subgraph of ```\nT'```\n other than ```\nT'```\n itself, would not be a tree, and if it's not a tree, it can't be MST either. Probably it is ```\n(V',E∩T) is a subgraph of G'```\n or ```\n(V',E∩T) is a subgraph of T```\n, not ```\n(V',E∩T) is a subgraph of T'```\n?\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "MST with least number of edges\r\n                \r\nHow to write the logic to select minimum spanning tree - path with least number of edges if there are multiple short path available ?? \n\nHere is my java code -- which selects minimum spanning tree path , but not the one with least number of edges ..\n\n```\n  import java.io.BufferedReader;\n  import java.io.InputStreamReader;\n\n\n public class Kruskal {\n\n   static int path[];\n      static int n, m, mincost, i, j;\n\n      public static void main (String args[]) throws Exception {\n\n InputStreamReader isr;\n isr = new InputStreamReader(System.in);\n BufferedReader in = new BufferedReader(isr);\n\n // Creating graph of 'n' vertices & 'm' edges\n System.out.print(\"Enter the number of vertices in the graph: \");\n n = Integer.parseInt(in.readLine());\n\n System.out.print(\"Enter the number of edges in the graph: \");\n m = Integer.parseInt(in.readLine());\n\n path = new int[n+1];\n\n Edge e[] = new Edge[m];\n Edge t = new Edge();\n\n for (i=0; i<m; i++) {\n   e[i] = new Edge();\n   System.out.println(\"Enter 2 vertices and weight of edge: \");\n   System.out.print(\"First vertex: \");\n   e[i].u = Integer.parseInt(in.readLine());\n   System.out.print(\"Second vertex: \");\n   e[i].v = Integer.parseInt(in.readLine());\n   System.out.print(\"Weight: \");\n   e[i].wt = Integer.parseInt(in.readLine());\n }\n\n // Sorting the edges in ascending order of weights\n for (i=0; i<=m-1; i++) {\n   for (j=0; j<m-i-1; j++) {\n     if (e[j].wt > e[j+1].wt) {\n       t = e[j];\n       e[j] = e[j+1];\n       e[j+1] = t;\n     }\n   }\n }\n\n // Initializing the path array\n for (i=1; i<=n; i++) {\n   path[i] = 0;\n }\n\n // Counts the number of edges selected in the tree\n i = 0;\n\n // Counts the number of edges selected or discarded\n j = 0;\n\n mincost = 0;\n System.out.println();\n while ((i!=n-1) && (j!=m)) {\n   System.out.print(\"Edge (\"\n   + e[j].u + \", \" + e[j].v + \") \"\n   + \"with weight \" + e[j].wt + \" \");\n   if (checkCycle(e[j])) {\n     mincost = mincost + e[j].wt;\n     i++;\n     System.out.println(\"is selected\");\n   } else {\n     System.out.println(\"is discarded\");\n   }\n   j++;\n }\n if (i!=n-1) {\n   System.out.println(\"Minimum spanning tree cannot be formed \");\n    }\n\n   }\n\n       public static boolean checkCycle(Edge e) {\n         int u = e.u, v = e.v;\n\n           while (path[u] > 0)\n           u = path[u];\n\n      while (path[v] > 0)\n           v = path[v];\n\n      if (u != v) {\n      path[u] = v;\n        return true;\n       }\n       return false;\n    }\n\n        static class Edge {\n         int u, v, wt;\n        }\n       }\n```\n\n\nOutput :\n\noutput\n    ", "Answer": "\r\nThe short answer from Codor's link:\n\nHow many edges does an undirected tree with n nodes have?\nThis is a very standard fact; any basic text will tell you that an undirected tree with n nodes must have exactly n−1 edges.\n\nIn your example (from the comment), you listed two paths but they are not a minimum spanning tree. A minimum spanning tree (MST) or minimum weight spanning tree is a subset of the edges of a connected, edge-weighted undirected graph that connects all the vertices together.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimal spanning tree (adjacency matrix) in java\r\n                \r\nI have a problem that I am really struggling with. I have a set villages with weighed edges and I need to create a minimum spanning tree to find the shortest way.I have found the shortest path for the villages according to the weight,I really have no idea what to do\nHow can i implement this with adjacency matrix ? i will appreciate any help :)\n-10 villages(Nodes)\n    ", "Answer": "\r\nCheckout dijkstra or A+ algorithm to find shortest path with weighted edges. A* additionally uses a metric (heuristice) function which it makes faster to Dijkstra.  \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Shortest path spanning tree with 1 weighted edges vs MST\r\n                \r\nI currently studying about graphs and their algorithms, and i noticed a question which i don't know to to exactly prove:\n\nIf we have a connected, undirected graph G=(V,E), and every edge is with weight=1,is it true to say that every spanning tree that built from the shortest paths from the root, is a minimum spanning tree?\n\nI ran some examples in http://visualgo.net/sssp.html and is seems for me that the answer for this question is true, but someone can show me how can i prove this? \nand another question that crossed my mind, does the other direction is also true?\n    ", "Answer": "\r\nEvery tree has exactly ```\nn - 1```\n edges. Since all weights are equal to ```\n1```\n, every spanning tree of ```\nG```\n has a total weight of ```\nn - 1```\n. It is also true for the minimal spanning tree. So the answer is yes.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Issue with Neo4j GDS 1.4.1 K-Spanning tree\r\n                \r\nI'm following Noe4j's online document at https://neo4j.com/docs/graph-data-science/current/alpha-algorithms/minimum-weight-spanning-tree/ , it seems that the Cypher to query K-Spanning tree doesn't work:\n```\nMATCH (n:Place)\nWITH n.id AS Place, n.kminst AS Partition, count(*) AS count\nWHERE count = 3\nRETURN Place, Partition\n```\n\nShould it be modifyed to the following?\n```\nMATCH (n:Place)\nWITH n.kminst AS Partition, count(*) AS count\nWHERE count = 3\nMATCH (n:Place)\nWHERE n.kminst=Partition\nRETURN n\n```\n\nI'v downloaded the example transport data of the book <Graph Algorithms> from https://resources.oreilly.com/examples/0636920233145/tree/master/data, and loaded it into a graph database, all path algorithms of the package is O.K. except the K-Spanning tree, can't figure out how to make it work.\n```\nMATCH (source:Place {id: \"Amsterdam\"})\nCALL gds.alpha.spanningTree.kmin.write({\n     nodeProjection:'Place',\n     relationshipProjection:{\n     EROAD:{\n         type:'EROAD',\n         properties:'distance',\n         orientation:'NATURAL'\n     }},\n     startNodeId:id(source),\n     relationshipWeightProperty:'distance',\n     writeProperty: 'kminst',\n     k: 3\n})\nYIELD createMillis, computeMillis, writeMillis, effectiveNodeCount\nRETURN createMillis, computeMillis, writeMillis, effectiveNodeCount\n\nMATCH (n:Place)\nWITH n.kminst AS partition, count(*) AS count\nRETURN partition, count\n```\n\nThere's no partition gets the value 3, so don't know how to extract the result with a Cypher like this:\n```\nMATCH (n:Place)\nWITH n.kminst AS Partition, count(*) AS count\nWHERE count = 3\nMATCH (n:Place)\nWHERE n.kminst=Partition\nRETURN n\n```\n\nAny idea is appreciated.\n    ", "Answer": "\r\nO.K., get the key that the Prim algorithm only applies to UNDIRECTED graph, should be mentioned in the algorithm document.\nRead the source of Prim algorithm at https://github.com/neo4j/graph-data-science/blob/master/alpha/alpha-algo/src/main/java/org/neo4j/graphalgo/impl/spanningTrees/Prim.java .\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to efficiently generate all possible spanning trees from a graph\r\n                \r\nFirst please note that this question is NOT asking about MST, instead, just ```\nall possible spanning trees```\n.\n\nSo this is NOT the same as finding all minimal spanning trees or All minimum spanning trees implementation\n\n\n\nI just need to generate all possible ```\nspanning trees```\n from a graph.\n\nI think the brute-force way is straight:\n\nSuppose we have ```\nV```\n nodes and ```\nE```\n edges.\n\n\nGet all edges of the graph\nGet all possible combinations of ```\nV-1```\n out of ```\nE```\n edges.\nFilter out ```\nnon-spanning-tree```\n out of the combinations (for a spanning tree, all nodes inside one set of ```\nV-1```\n edges should appear exactly once)\n\n\nBut I think it is too slow when facing big graph.\n\nDo we have a better way?\n    ", "Answer": "\r\nSet the weight of all edges to the same value, then use an algorithm to find all minimum spanning trees. Since all spanning trees have ```\n|V|-1```\n edges and all edge weights are equal, all spanning trees will be minimum spanning trees.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Find minimum spanning tree of undirected weighed graph with root node having exactly k edges\r\n                \r\nHaving an undirected graph with ```\nv```\n vertices and ```\ne```\n edges with each edges having a non-negative weight of at most ```\nw```\n, the task is to find(if possible!) a subset of edges that connects all vertices with minimum cost. Also this graph has a root node which in the sub-graph should only be directly connected to exactly ```\nk```\n other vertices(so it most have exactly k edges connected to it in the sub-graph). The algorithm should work in ```\nO(e⋅log(v)⋅log(w))```\n time.\nSo after some thinking I thought that we need to find a ```\nminimum spanning tree```\n since it gives us the ```\nMinimum-cost subgraph```\n which takes ```\nO(e.log(v))```\n time.However for insuring that the root node has exactly ```\nk```\n edges in the resulting tree I couldn't come up with any working idea.\nI think that maybe changing the weights of k edges that are connect to the root may enforce their selection,since in the Kruskal's algorithm we first sort the edges, if we pick exactly ```\nk```\n edges that are already connected to the edge root in the graph and change their weights to some minimum amount then in the tree construction phase, chances are that this k edges make it to the MST. There are still problems here:\nK edges should be picked so that it would be possible for them to make it to an MST.\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to clean up a Minimum Spanning Tree\r\n                \r\nI am working on a project that uses an MST using the prim algorithm:\nAfter completing my code and testing I was trying to clean and deallocate my calculated prim function, but I complicated my code with a pointer class to a different pointer.\nHere my code with my logic to deallocate the code:\n```\n    Adj_Node *curr_element;\n    Adj_Node *next_element;\n\n    for (int i = 0; i < n_nodes; i++)\n    {\n        curr_element = array_elements[i].head_list;\n        while (curr_element != nullptr)\n        {\n            std::cout << curr_element.dest_node << \"\\t\";\n            next_element = curr_element[i].next_node;\n            delete curr_element; \n            curr_element = next_element;\n        }\n    }\n```\n\nHere some variables from my classes:\n```\nAdj_List * array_elements; Adj_Node *head_list; Adj_Node *next_node;\n```\n\nBasically, array_elements is an array of head lists, and the head list is an array of the next node.\nI followed this tutorial for the Adj_List *: https://www.geeksforgeeks.org/prims-mst-for-adjacency-list-representation-greedy-algo-6/\nIf you can help me with how to deallocate this element which is the same as the element of the tutorial I will appreciate it (basically a function clean for the given tutorial). Thank you for your help in advance.\nEdith:\nThanks for answering my question. I think I forgot to mention I am using classes instead of structures from the tutorial code into different files like adj_node adj_list. The problem is that I try to deallocate two pointers, say (0,1);(1;0), and when I run the code it scapes from the execution program. I am unsure of the reason.\nThis is what I have for adding, so maybe there is something there that can clarify how I allocate memory\n```\n        Adj_Node *new_node = new Adj_Node(v, w);\n        // Store head_list of array_heap elements into head_list\n        new_node->next_node = array_elements[u].head_list;\n        // And store array_heap to node\n        array_elements[u].head_list = new_node;\n        // Since graph is undirected, add an edge from dest to src also\n        new_node = new Adj_Node(u, w);\n        new_node->next_node = array_elements[v].head_list;\n        array_elements[v].head_list = new_node;\n```\n\nI think the problem is that I create a linkedlist array_elements[v].headlist->array_elements[v].headlist-array_elements[v], but I am unsure. Happy to know what you think.\n    ", "Answer": "\r\nWhen the nodes form a connected graph, there will be nodes having multiple references to them.  If you walk overlapping paths across the graph \"deleting as you go\" you will cause multiple deletions to be attempted on the nodes, which will cause a segmentation fault (when attempting to delete a node that is already deleted).\nYou have a few options:\n\nMaintain a node list whilst building the graph - this has ownership of the nodes and is responsible for deleting them at cleanup.  A ```\nstd::vector```\n can be a good candidate for this.  (This option would be my recommendation)\n\nWalk the nodes at cleanup and build a list, avoiding duplicates.  When all paths walked, delete everything in the list.\n\nUse smart pointers (```\nstd::shared_ptr```\n) for creating the nodes and copy them in the nodes for referencing the \"adjacent-node\".  The references to them can be cleared when walking the paths at cleanup.  The nodes are not deleted until all references are reset.\n\n\n\nFor more information on dangling references and smart pointers, take a look at:\n\nthis paper: http://umich.edu/~eecs381/handouts/C++11_smart_ptrs.pdf\n\nthis article: https://www.acodersjourney.com/top-10-dumb-mistakes-avoid-c-11-smart-pointers/\n\nScott Meyer's book: https://www.amazon.co.uk/Effective-Modern-Specific-Ways-Improve/dp/1491903996\n\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "convert minimum spanning tree to list of indices using scipy?\r\n                \r\nIf I have the following input and output graphs\n```\n input graph             minimum spanning tree\n\n     (0)                         (0)\n    /   \\                       /\n   3     8                     3\n  /       \\                   /\n(3)---5---(1)               (3)---5---(1)\n  \\       /                           /\n   6     2                           2\n    \\   /                           /\n     (2)                         (2)\n```\n\n... created using scipy.sparse.csgraph.minimum_spanning_tree:\n```\n>>> from scipy.sparse import csr_matrix\n>>> from scipy.sparse.csgraph import minimum_spanning_tree\n>>> X = csr_matrix([[0, 8, 0, 3],\n...                 [0, 0, 2, 5],\n...                 [0, 0, 0, 6],\n...                 [0, 0, 0, 0]])\n>>> Tcsr = minimum_spanning_tree(X)\n>>> Tcsr.toarray().astype(int)\narray([[0, 0, 0, 3],\n       [0, 0, 2, 5],\n       [0, 0, 0, 0],\n       [0, 0, 0, 0]])\n```\n\nHow do I produce a simple list of indices? So:\n```\n[0,3,1,2]\n```\n\n    ", "Answer": "\r\n```\nscipy.sparse.csgraph```\n contains methods to list nodes in depth-first or breadth-first order:\n```\nfrom scipy.sparse.csgraph import breadth_first_order, depth_first_order\n\nprint(breadth_first_order(Tcsr, i_start=0, directed=False, return_predecessors=False))\n# [0 3 1 2]\nprint(depth_first_order(Tcsr, i_start=0, directed=False, return_predecessors=False))\n# [0 3 1 2]\n```\n\nSince your tree has only a single branch, the two methods produce equivalent results. But for more general spanning trees, you should choose the method based on which traversal order you're interested in.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum cost arborescence of a specific subset of vertices\r\n                \r\nI can use the Chu-Liu/Edmonds algorithm to get the minimum cost arborescence of a directed weighted graph. I want to apply this for a pre-specified subset of k vertices. (I know exactly which k vertices must be included in the the tree).\n\nWhat are the steps required to apply the Chu-Liu/Edmonds algorithm?\n\nSimilar to Construct a minimum spanning tree covering a specific subset of the vertices, but for directed graphs / minimum cost arborescence (vs. undirected graphs / minimum spanning tree).\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "specify a root in igraph minimum-spanning-tree\r\n                \r\nI have a weighted adjacency matrix and I need to create a directed MST.  The problem is that I know the edge weights and the root, so I can generate an MST on an undirected graph, but I cant find a way to then specify a root.  If I could specify a root, this would automatically induce directions on all the edges of the MST, completing the task.\n\n```\nmy_graph <- igraph::graph_from_adjacency_matrix(adjmatrix = cluster_adj_matrix, mode = \"upper\", weighted = TRUE)\nmy_mst <- igraph::mst(my_graph)                                                   \n```\n\n    ", "Answer": "\r\nThe two main features I was interested in: path length to root and predecessor of the directed graph can be generated in the following way:\n\nTo get predecessors:\n\n```\nGetPredecessors <- function(minspantree, root){\n  pathdata <- igraph::get.shortest.paths(graph = minspantree, from = root)\n  pathlist <- prelist <- lapply(paths$vpath, function(x){\n    y = as.vector(x)\n    y[(length(y)-1)]\n  })\n  prelist[[root]] <- 0\n  return(unlist(prelist))\n}\n```\n\n\nTo get the path lengths to the root:\n\n```\nigraph::shortest.paths(graph = minspantree, v = root)\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "DFS - finding Minimum Spanning Tree in a graph\r\n                \r\nl - adiacency list\nx - starting vertex\ndfst, q - empty array of vertex size\n\n```\nstd::list <int> q;\nstd::vector<bool> visited(cols + 1); \nfor(int i = 0; i < cols; i++) visited[i] = false;\nvisited[x] = true;\nif(!l[x].empty())\nfor(std::list<int>::iterator i = l[x].begin(); i != l[x].end(); i++)\n{\n    q.push_back(x); q.push_back(* i);\n}\nwhile(!q.empty())\n{\n    y = q.back(); q.pop_back();\n    x = q.back(); q.pop_back();\n    if(!visited[y])\n    {\n        visited[y] = true;\n        if(!l[y].empty())\n        for(std::list<int>::iterator i = l[y].begin(); i != l[y].end(); i++)\n        {\n            q.push_back(y); q.push_back(* i);\n        }\n        dfst[x].push_back(y);\n        dfst[y].push_back(x);\n    }\n}\n```\n\n\nI just can't see why does this give wrong results...I don't know if you are familiar with this algorithm, but if you are, I hope you can see what's wrong here.\n\nEDIT:\n\nAdjacency list is:\n1: 2, 3\n2: 3\n3: 4\n4: 3\n\nMST should here be something like:\n1: 2, 3\n3: 4\n\nBut instead it's:\n2: 3\n3: 2, 4\n4: 3\n\nAnd the current code is: (I used brackets where it was needed):\n\n```\nstd::list <int> q;\nstd::vector<bool> visited(cols + 1); \nfor(int i = 0; i < cols; i++) visited[i] = false;\nvisited[x] = true;\nif(!l[x].empty())\n{\n    for(std::list<int>::iterator i = l[x].begin(); i != l[x].end(); i++)\n    {\n        q.push_back(x); q.push_back(* i);\n    }\n    while(!q.empty())\n    {\n        y = q.back(); q.pop_back();\n        x = q.back(); q.pop_back();\n        if(!visited[y])\n        {\n            visited[y] = true;\n            if(!l[y].empty())\n            for(std::list<int>::iterator i = l[y].begin(); i != l[y].end(); i++)\n            {\n                if(!visited[*i])\n                {q.push_back(y); q.push_back(* i);}\n            }\n            dfst[x].push_back(y);\n            dfst[y].push_back(x);\n        }\n    }\n}\n```\n\n    ", "Answer": "\r\nI worked through your code, it appears to be correct. However, keep in mind that there are multiple DFS trees if your input tree has a cycle. The tree that you get depends on the order in which you process your vertices. Perhaps your input has a cycle? If so, your code might be processing the nodes in an order different from the order that they are processed in the solution.\n\nFor example, take the following adjacency list for an input tree, where nodes are lettered:\n\n```\na: b,c\nb: a,d\nc: a,c,e\nd: b,c,e\ne: c,d\n```\n\n\nStarting at a, if we look in the adjacency list for the next node based on alphabetical order, we get the following DFS tree:\n\n```\na: b\nb: a,d\nc: d,e\nd: b,d\ne: c\n```\n\n\nUsing your algorithm though, we get the following:\n\n```\na: c\nb: d\nc: a,e\nd: b,e\ne: c,d\n```\n\n\nIf this is happening, perhaps try a recursive approach.\n\nSeeing some sample input and output would help further with ansering this question though, as this may not be your problem.\n\nEDIT: I should clarify that the multiple DFS trees in a graph with a cycle applies where the cycle is bidirectional, such as with an undirected graph. The point is, you might be finding a DFS tree that is also correct, but not the same as the one that has been identified as correct.\n\nEDIT (again): Another issue you may have: your algorithm appears to be for undirected graphs since you have the satements ```\ndfst[x].push_back(y); dfst[y].push_back(x);```\nin your code, but your input graph given in your example looks like it's directed. Removing the second statement (```\ndfst[y].push_back(x);```\n) should correct this\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "minimum spanning tree remove all extra edges\r\n                \r\nExtra edge- edge made with 2 points, where each point is connected with another edge.\nI want to disconnect MST by deleting these edges.\nWhat is the best approach to minimize the weight of new disconnected MST,\nor in what order should I delete these edges(deleting one could affect the other)?\nMy approach is to delete the biggest weight extra edges first?\nhttps://prnt.sc/1xq1msp\nIn this case, removing 7(CD)-> no more edges could be deleted.\nBut you could also remove B-C, and then remove D-E which is better solution\n    ", "Answer": "\r\nHere’s an exact solution with NumPy/SciPy/OR-Tools that uses a kd-tree\nto enumerate a sparse subset of edges that can possibly be included in\nan optimal solution, then formulates and solves a mixed integer program.\nNot sure it will scale to your needs though; you could set setting a gap\nlimit if you’re willing to settle for an approximation.\n```\nimport collections\nimport numpy\nimport scipy.spatial\n\nfrom ortools.linear_solver import pywraplp\n\n\ndef min_edge_cover(points):\n    # Enumerate the candidate edges.\n    candidate_edges = set()\n    tree = scipy.spatial.KDTree(points)\n    min_distances = numpy.ndarray(len(points))\n    for i, p in enumerate(points):\n        if i % 1000 == 0:\n            print(i)\n        distances, indexes = tree.query(p, k=2)\n        # Ignore p itself.\n        d, j = (\n            (distances[1], indexes[1])\n            if indexes[0] == i\n            else (distances[0], indexes[0])\n        )\n        candidate_edges.add((min(i, j), max(i, j)))\n        min_distances[i] = d\n    for i, p in enumerate(points):\n        if i % 1000 == 0:\n            print(i)\n        # An edge is profitable only if it's shorter than the sum of the\n        # distance from each of its endpoints to that endpoint's nearest\n        # neighbor.\n        indexes = tree.query_ball_point(p, 2 * min_distances[i])\n        for j in indexes:\n            if i == j:\n                continue\n            discount = (\n                min_distances[i] + min_distances[j]\n            ) - scipy.spatial.distance.euclidean(points[i], points[j])\n            if discount >= 0:\n                candidate_edges.add((min(i, j), max(i, j)))\n    candidate_edges = sorted(candidate_edges)\n\n    # Formulate and solve a mixed integer program to find the minimum distance\n    # edge cover. There's a way to do this with general weighted matching, but\n    # OR-Tools doesn't expose that library yet.\n    solver = pywraplp.Solver.CreateSolver(\"SCIP\")\n    objective = 0\n    edge_variables = []\n    coverage = collections.defaultdict(lambda: 0)\n    for i, j in candidate_edges:\n        x = solver.BoolVar(\"x{}_{}\".format(i, j))\n        objective += scipy.spatial.distance.euclidean(points[i], points[j]) * x\n        coverage[i] += x\n        coverage[j] += x\n        edge_variables.append(x)\n    solver.Minimize(objective)\n    for c in coverage.values():\n        solver.Add(c >= 1)\n    solver.EnableOutput()\n    assert solver.Solve() == pywraplp.Solver.OPTIMAL\n    return {e for (e, x) in zip(candidate_edges, edge_variables) if x.solution_value()}\n\n\ndef random_point():\n    return complex(random(), random())\n\n\ndef test(points, graphics=False):\n    cover = min_edge_cover(points)\n    if not graphics:\n        return\n    with open(\"out.ps\", \"w\") as f:\n        print(\"%!PS\", file=f)\n        print(0, \"setlinewidth\", file=f)\n        inch = 72\n        scale = 7 * inch\n        print((8.5 * inch - scale) / 2, (11 * inch - scale) / 2, \"translate\", file=f)\n        for x, y in points:\n            print(scale * x, scale * y, 1, 0, 360, \"arc\", \"fill\", file=f)\n        for i, j in cover:\n            xi, yi = points[i]\n            xj, yj = points[j]\n            print(\n                scale * xi,\n                scale * yi,\n                \"moveto\",\n                scale * xj,\n                scale * yj,\n                \"lineto\",\n                file=f,\n            )\n        print(\"stroke\", file=f)\n        print(\"showpage\", file=f)\n\n\ntest(numpy.random.rand(100, 2), graphics=True)\ntest(numpy.random.rand(10000, 2))\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Running time of minimum spanning tree? ( Prim method )\r\n                \r\nI have written a code that solves MST using Prim method. I read that this kind of implementation(using priority queue) should have O(E + VlogV) = O(VlogV) where E is the number of edges and V number of Edges but when I look at my code it simply doesn't look that way.I would appreciate it if someone could clear this up for me.\n\nTo me it seems the running time is this:\n\nThe while loop takes O(E) times(until we go through all the edges)\nInside that loop we extract an element from the Q which takes O(logE) time.\nAnd the second inner loop takes O(V) time(although we dont run this loop everytime\nit is clear that it will be ran V times since we have to add all the vertices )\n\nMy conclusion would be that the running time is: O( E(logE+V) ) = O( E*V ).\n\nThis is my code:\n\n```\n#define p_int pair < int, int >\n\nint N, M; //N - nmb of vertices, M - nmb of edges\nint graph[100][100] = { 0 }; //adj. matrix\nbool in_tree[100] = { false }; //if a node if in the mst\npriority_queue< p_int, vector < p_int >, greater < p_int > > Q; \n/*\nkeeps track of what is the smallest edge connecting a node in the mst tree and\na node outside the tree. First part of pair is the weight of the edge and the \nsecond is the node. We dont remember the parent node beaceuse we dont need it :-)\n*/\n\nint mst_prim()\n{\n Q.push( make_pair( 0, 0 ) );\n\n int nconnected = 0;\n int mst_cost = 0;\n while( nconnected < N )\n {\n      p_int node = Q.top(); Q.pop();\n\n      if( in_tree[ node.second ] == false )\n      {\n           mst_cost += node.first;\n           in_tree[ node.second ] = true;\n\n           for( int i = 0; i < N; ++i )\n                if( graph[ node.second ][i] > 0 && in_tree[i]== false )\n                     Q.push( make_pair( graph[ node.second ][i], i ) );\n\n           nconnected++;\n      }\n }\n\n return mst_cost;\n}\n```\n\n    ", "Answer": "\r\nYou can use adjacency lists to speed your solution up (but not for dense graphs), but even then, you are not going to get O(V log V) without a Fibonacci heap..\n\nMaybe the Kruskal algorithm would be simpler for you to understand. It features no priority queue, you only have to sort an array of edges once. It goes like this basically:\n\n\nInsert all edges into an array and sort them by weight\nIterate over the sorted edges, and for each edge connecting nodes i and j, check if i and j are connected. If they are, skip the edge, else add the edge into the MST.\n\n\nThe only catch is to be quickly able to say if two nodes are connected. For this you use the Union-Find data structure, which goes like this:\n\n```\nint T[MAX_#_OF_NODES]\n\nint getParent(int a)\n{\n  if (T[a]==-1)return a;\n  return T[a]=getParent(T[a]);\n}\nvoid Unite(int a,int b)\n{\n  if (rand()&1)\n     T[a]=b;\n  else\n     T[b]=a;\n}\n```\n\n\nIn the beginning, just initialize T to all -1, and then every time you want to find out if nodes A and B are connected, just compare their parents - if they are the same, they are connected (like this ```\ngetParent(A)==getParent(B)```\n). When you are inserting the edge to MST, make sure to update the Union-Find with ```\nUnite(getParent(A),getParent(B))```\n.\n\nThe analysis is simple, you sort the edges and iterate over using the UF that takes O(1). So it is O(E logE + E ) which equals O(E log E).\n\nThat is it ;-)\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "What is the minimum cost to connect all the islands?\r\n                \r\nThere is a grid of size N x M. Some cells are islands denoted by '0' and the others are water. Each water cell has a number on it denoting the cost of a bridge made on that cell. You have to find the minimum cost for which all the islands can be connected. A cell is connected to another cell if it shares an edge or a vertex.\n\nWhat algorithm can be used to solve this problem? What can be used as a brute force approach if the values of N, M are very small, say NxM <= 100?\n\nExample: In the given image, green cells indicate islands, blue cells indicate water and light blue cells indicate the cells on which a bridge should be made. Thus for the following image, the answer will be 17.\n\n\n\nInitially I thought of marking all the islands as nodes and connecting every pair of islands by a shortest bridge. Then the problem could be reduced to Minimum spanning tree, but in this approach I missed the case where edges are overlapping. For example, in the following image, the shortest distance between any two islands is 7 (marked in yellow), so by using Minimum Spanning Trees the answer would be 14, but the answer should be 11 (marked in light blue).\n\n\n    ", "Answer": "\r\nTo approach this problem, I would use an integer programming framework and define three sets of decision variables:\n\nx_ij: A binary indicator variable for whether we build a bridge at water location (i, j).\ny_ijbcn: A binary indicator for whether water location (i, j) is the n^th location linking island b to island c.\nl_bc: A binary indicator variable for whether islands b and c are directly linked (aka you can walk only on bridge squares from b to c).\n\nFor bridge building costs c_ij, the objective value to minimize is ```\nsum_ij c_ij * x_ij```\n. We need to add the following constraints to the model:\n\nWe need to ensure the y_ijbcn variables are valid. We can always only reach a water square if we build a bridge there, so ```\ny_ijbcn <= x_ij```\n for every water location (i, j). Further, ```\ny_ijbc1```\n must equal 0 if (i, j) does not border island b. Finally, for n > 1, ```\ny_ijbcn```\n can only be used if a neighboring water location was used in step n-1. Defining ```\nN(i, j)```\n to be the water squares neighboring (i, j), this is equivalent to ```\ny_ijbcn <= sum_{(l, m) in N(i, j)} y_lmbc(n-1)```\n.\nWe need to ensure the l_bc variables are only set if b and c are linked. If we define ```\nI(c)```\n to be the locations bordering island c, this can be accomplished with ```\nl_bc <= sum_{(i, j) in I(c), n} y_ijbcn```\n.\nWe need to ensure that all islands are linked, either directly or indirectly. This can be accomplished in the following way: for every non-empty proper subset S of islands, require that at least one island in S is linked to at least one island in the complement of S, which we'll call S'. In constraints, we can implement this by adding a constraint for every non-empty set S of size <= K/2 (where K is the number of islands), ```\nsum_{b in S} sum_{c in S'} l_bc >= 1```\n.\n\nFor a problem instance with K islands, W water squares, and specified maximum path length N, this is a mixed integer programming model with ```\nO(K^2WN)```\n variables and ```\nO(K^2WN + 2^K)```\n constraints. Obviously this will become intractable as the problem size becomes large, but it may be solvable for the sizes you care about. To get a sense of the scalability, I'll implement it in python using the pulp package. Let's first start with the smaller 7 x 9 map with 3 islands at the bottom of the question:\n```\nimport itertools\nimport pulp\nwater = {(0, 2): 2.0, (0, 3): 1.0, (0, 4): 1.0, (0, 5): 1.0, (0, 6): 2.0,\n         (1, 0): 2.0, (1, 1): 9.0, (1, 2): 1.0, (1, 3): 9.0, (1, 4): 9.0,\n         (1, 5): 9.0, (1, 6): 1.0, (1, 7): 9.0, (1, 8): 2.0,\n         (2, 0): 1.0, (2, 1): 9.0, (2, 2): 9.0, (2, 3): 1.0, (2, 4): 9.0,\n         (2, 5): 1.0, (2, 6): 9.0, (2, 7): 9.0, (2, 8): 1.0,\n         (3, 0): 9.0, (3, 1): 1.0, (3, 2): 9.0, (3, 3): 9.0, (3, 4): 5.0,\n         (3, 5): 9.0, (3, 6): 9.0, (3, 7): 1.0, (3, 8): 9.0,\n         (4, 0): 9.0, (4, 1): 9.0, (4, 2): 1.0, (4, 3): 9.0, (4, 4): 1.0,\n         (4, 5): 9.0, (4, 6): 1.0, (4, 7): 9.0, (4, 8): 9.0,\n         (5, 0): 9.0, (5, 1): 9.0, (5, 2): 9.0, (5, 3): 2.0, (5, 4): 1.0,\n         (5, 5): 2.0, (5, 6): 9.0, (5, 7): 9.0, (5, 8): 9.0,\n         (6, 0): 9.0, (6, 1): 9.0, (6, 2): 9.0, (6, 6): 9.0, (6, 7): 9.0,\n         (6, 8): 9.0}\nislands = {0: [(0, 0), (0, 1)], 1: [(0, 7), (0, 8)], 2: [(6, 3), (6, 4), (6, 5)]}\nN = 6\n\n# Island borders\niborders = {}\nfor k in islands:\n    iborders[k] = {}\n    for i, j in islands[k]:\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if (i+dx, j+dy) in water:\n                    iborders[k][(i+dx, j+dy)] = True\n\n# Create models with specified variables\nx = pulp.LpVariable.dicts(\"x\", water.keys(), lowBound=0, upBound=1, cat=pulp.LpInteger)\npairs = [(b, c) for b in islands for c in islands if b < c]\nyvals = []\nfor i, j in water:\n    for b, c in pairs:\n        for n in range(N):\n            yvals.append((i, j, b, c, n))\n\ny = pulp.LpVariable.dicts(\"y\", yvals, lowBound=0, upBound=1)\nl = pulp.LpVariable.dicts(\"l\", pairs, lowBound=0, upBound=1)\nmod = pulp.LpProblem(\"Islands\", pulp.LpMinimize)\n\n# Objective\nmod += sum([water[k] * x[k] for k in water])\n\n# Valid y\nfor k in yvals:\n    i, j, b, c, n = k\n    mod += y[k] <= x[(i, j)]\n    if n == 0 and not (i, j) in iborders[b]:\n        mod += y[k] == 0\n    elif n > 0:\n        mod += y[k] <= sum([y[(i+dx, j+dy, b, c, n-1)] for dx in [-1, 0, 1] for dy in [-1, 0, 1] if (i+dx, j+dy) in water])\n\n# Valid l\nfor b, c in pairs:\n    mod += l[(b, c)] <= sum([y[(i, j, B, C, n)] for i, j, B, C, n in yvals if (i, j) in iborders[c] and B==b and C==c])\n\n# All islands connected (directly or indirectly)\nikeys = islands.keys()\nfor size in range(1, len(ikeys)/2+1):\n    for S in itertools.combinations(ikeys, size):\n        thisSubset = {m: True for m in S}\n        Sprime = [m for m in ikeys if not m in thisSubset]\n        mod += sum([l[(min(b, c), max(b, c))] for b in S for c in Sprime]) >= 1\n\n# Solve and output\nmod.solve()\nfor row in range(min([m[0] for m in water]), max([m[0] for m in water])+1):\n    for col in range(min([m[1] for m in water]), max([m[1] for m in water])+1):\n        if (row, col) in water:\n            if x[(row, col)].value() > 0.999:\n                print \"B\",\n            else:\n                print \"-\",\n        else:\n            print \"I\",\n    print \"\"\n```\n\nThis takes 1.4 seconds to run using the default solver from the pulp package (the CBC solver) and outputs the correct solution:\n```\nI I - - - - - I I \n- - B - - - B - - \n- - - B - B - - - \n- - - - B - - - - \n- - - - B - - - - \n- - - - B - - - - \n- - - I I I - - - \n```\n\nNext, consider the full problem at the top of the question, which is a 13 x 14 grid with 7 islands:\n```\nwater = {(i, j): 1.0 for i in range(13) for j in range(14)}\nislands = {0: [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)],\n           1: [(9, 0), (9, 1), (10, 0), (10, 1), (10, 2), (11, 0), (11, 1),\n               (11, 2), (12, 0)],\n           2: [(0, 7), (0, 8), (1, 7), (1, 8), (2, 7)],\n           3: [(7, 7), (8, 6), (8, 7), (8, 8), (9, 7)],\n           4: [(0, 11), (0, 12), (0, 13), (1, 12)],\n           5: [(4, 10), (4, 11), (5, 10), (5, 11)],\n           6: [(11, 8), (11, 9), (11, 13), (12, 8), (12, 9), (12, 10), (12, 11),\n               (12, 12), (12, 13)]}\nfor k in islands:\n    for i, j in islands[k]:\n        del water[(i, j)]\n\nfor i, j in [(10, 7), (10, 8), (10, 9), (10, 10), (10, 11), (10, 12),\n             (11, 7), (12, 7)]:\n    water[(i, j)] = 20.0\n\nN = 7\n```\n\nMIP solvers often obtain good solutions relatively quickly and then spend a huge about of time trying to prove the optimality of the solution. Using the same solver code as above, the program does not complete within 30 minutes. However, you can provide a timeout to the solver to get an approximate solution:\n```\nmod.solve(pulp.solvers.PULP_CBC_CMD(maxSeconds=120))\n```\n\nThis yields a solution with objective value 17:\n```\nI I - - - - - I I - - I I I \nI I - - - - - I I - - - I - \nI I - - - - - I - B - B - - \n- - B - - - B - - - B - - - \n- - - B - B - - - - I I - - \n- - - - B - - - - - I I - - \n- - - - - B - - - - - B - - \n- - - - - B - I - - - - B - \n- - - - B - I I I - - B - - \nI I - B - - - I - - - - B - \nI I I - - - - - - - - - - B \nI I I - - - - - I I - - - I \nI - - - - - - - I I I I I I \n```\n\nTo improve the quality of the solutions you obtain, you could use a commercial MIP solver (this is free if you are at an academic institution and likely not free otherwise). For instance, here's the performance of Gurobi 6.0.4, again with a 2-minute time limit (though from the solution log we read that the solver found the current best solution within 7 seconds):\n```\nmod.solve(pulp.solvers.GUROBI(timeLimit=120))\n```\n\nThis actually finds a solution of objective value 16, one better than the OP was able to find by hand!\n```\nI I - - - - - I I - - I I I \nI I - - - - - I I - - - I - \nI I - - - - - I - B - B - - \n- - B - - - - - - - B - - - \n- - - B - - - - - - I I - - \n- - - - B - - - - - I I - - \n- - - - - B - - B B - - - - \n- - - - - B - I - - B - - - \n- - - - B - I I I - - B - - \nI I - B - - - I - - - - B - \nI I I - - - - - - - - - - B \nI I I - - - - - I I - - - I \nI - - - - - - - I I I I I I \n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "What is the minimum cost to connect all the islands?\r\n                \r\nThere is a grid of size N x M. Some cells are islands denoted by '0' and the others are water. Each water cell has a number on it denoting the cost of a bridge made on that cell. You have to find the minimum cost for which all the islands can be connected. A cell is connected to another cell if it shares an edge or a vertex.\n\nWhat algorithm can be used to solve this problem? What can be used as a brute force approach if the values of N, M are very small, say NxM <= 100?\n\nExample: In the given image, green cells indicate islands, blue cells indicate water and light blue cells indicate the cells on which a bridge should be made. Thus for the following image, the answer will be 17.\n\n\n\nInitially I thought of marking all the islands as nodes and connecting every pair of islands by a shortest bridge. Then the problem could be reduced to Minimum spanning tree, but in this approach I missed the case where edges are overlapping. For example, in the following image, the shortest distance between any two islands is 7 (marked in yellow), so by using Minimum Spanning Trees the answer would be 14, but the answer should be 11 (marked in light blue).\n\n\n    ", "Answer": "\r\nTo approach this problem, I would use an integer programming framework and define three sets of decision variables:\n\nx_ij: A binary indicator variable for whether we build a bridge at water location (i, j).\ny_ijbcn: A binary indicator for whether water location (i, j) is the n^th location linking island b to island c.\nl_bc: A binary indicator variable for whether islands b and c are directly linked (aka you can walk only on bridge squares from b to c).\n\nFor bridge building costs c_ij, the objective value to minimize is ```\nsum_ij c_ij * x_ij```\n. We need to add the following constraints to the model:\n\nWe need to ensure the y_ijbcn variables are valid. We can always only reach a water square if we build a bridge there, so ```\ny_ijbcn <= x_ij```\n for every water location (i, j). Further, ```\ny_ijbc1```\n must equal 0 if (i, j) does not border island b. Finally, for n > 1, ```\ny_ijbcn```\n can only be used if a neighboring water location was used in step n-1. Defining ```\nN(i, j)```\n to be the water squares neighboring (i, j), this is equivalent to ```\ny_ijbcn <= sum_{(l, m) in N(i, j)} y_lmbc(n-1)```\n.\nWe need to ensure the l_bc variables are only set if b and c are linked. If we define ```\nI(c)```\n to be the locations bordering island c, this can be accomplished with ```\nl_bc <= sum_{(i, j) in I(c), n} y_ijbcn```\n.\nWe need to ensure that all islands are linked, either directly or indirectly. This can be accomplished in the following way: for every non-empty proper subset S of islands, require that at least one island in S is linked to at least one island in the complement of S, which we'll call S'. In constraints, we can implement this by adding a constraint for every non-empty set S of size <= K/2 (where K is the number of islands), ```\nsum_{b in S} sum_{c in S'} l_bc >= 1```\n.\n\nFor a problem instance with K islands, W water squares, and specified maximum path length N, this is a mixed integer programming model with ```\nO(K^2WN)```\n variables and ```\nO(K^2WN + 2^K)```\n constraints. Obviously this will become intractable as the problem size becomes large, but it may be solvable for the sizes you care about. To get a sense of the scalability, I'll implement it in python using the pulp package. Let's first start with the smaller 7 x 9 map with 3 islands at the bottom of the question:\n```\nimport itertools\nimport pulp\nwater = {(0, 2): 2.0, (0, 3): 1.0, (0, 4): 1.0, (0, 5): 1.0, (0, 6): 2.0,\n         (1, 0): 2.0, (1, 1): 9.0, (1, 2): 1.0, (1, 3): 9.0, (1, 4): 9.0,\n         (1, 5): 9.0, (1, 6): 1.0, (1, 7): 9.0, (1, 8): 2.0,\n         (2, 0): 1.0, (2, 1): 9.0, (2, 2): 9.0, (2, 3): 1.0, (2, 4): 9.0,\n         (2, 5): 1.0, (2, 6): 9.0, (2, 7): 9.0, (2, 8): 1.0,\n         (3, 0): 9.0, (3, 1): 1.0, (3, 2): 9.0, (3, 3): 9.0, (3, 4): 5.0,\n         (3, 5): 9.0, (3, 6): 9.0, (3, 7): 1.0, (3, 8): 9.0,\n         (4, 0): 9.0, (4, 1): 9.0, (4, 2): 1.0, (4, 3): 9.0, (4, 4): 1.0,\n         (4, 5): 9.0, (4, 6): 1.0, (4, 7): 9.0, (4, 8): 9.0,\n         (5, 0): 9.0, (5, 1): 9.0, (5, 2): 9.0, (5, 3): 2.0, (5, 4): 1.0,\n         (5, 5): 2.0, (5, 6): 9.0, (5, 7): 9.0, (5, 8): 9.0,\n         (6, 0): 9.0, (6, 1): 9.0, (6, 2): 9.0, (6, 6): 9.0, (6, 7): 9.0,\n         (6, 8): 9.0}\nislands = {0: [(0, 0), (0, 1)], 1: [(0, 7), (0, 8)], 2: [(6, 3), (6, 4), (6, 5)]}\nN = 6\n\n# Island borders\niborders = {}\nfor k in islands:\n    iborders[k] = {}\n    for i, j in islands[k]:\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if (i+dx, j+dy) in water:\n                    iborders[k][(i+dx, j+dy)] = True\n\n# Create models with specified variables\nx = pulp.LpVariable.dicts(\"x\", water.keys(), lowBound=0, upBound=1, cat=pulp.LpInteger)\npairs = [(b, c) for b in islands for c in islands if b < c]\nyvals = []\nfor i, j in water:\n    for b, c in pairs:\n        for n in range(N):\n            yvals.append((i, j, b, c, n))\n\ny = pulp.LpVariable.dicts(\"y\", yvals, lowBound=0, upBound=1)\nl = pulp.LpVariable.dicts(\"l\", pairs, lowBound=0, upBound=1)\nmod = pulp.LpProblem(\"Islands\", pulp.LpMinimize)\n\n# Objective\nmod += sum([water[k] * x[k] for k in water])\n\n# Valid y\nfor k in yvals:\n    i, j, b, c, n = k\n    mod += y[k] <= x[(i, j)]\n    if n == 0 and not (i, j) in iborders[b]:\n        mod += y[k] == 0\n    elif n > 0:\n        mod += y[k] <= sum([y[(i+dx, j+dy, b, c, n-1)] for dx in [-1, 0, 1] for dy in [-1, 0, 1] if (i+dx, j+dy) in water])\n\n# Valid l\nfor b, c in pairs:\n    mod += l[(b, c)] <= sum([y[(i, j, B, C, n)] for i, j, B, C, n in yvals if (i, j) in iborders[c] and B==b and C==c])\n\n# All islands connected (directly or indirectly)\nikeys = islands.keys()\nfor size in range(1, len(ikeys)/2+1):\n    for S in itertools.combinations(ikeys, size):\n        thisSubset = {m: True for m in S}\n        Sprime = [m for m in ikeys if not m in thisSubset]\n        mod += sum([l[(min(b, c), max(b, c))] for b in S for c in Sprime]) >= 1\n\n# Solve and output\nmod.solve()\nfor row in range(min([m[0] for m in water]), max([m[0] for m in water])+1):\n    for col in range(min([m[1] for m in water]), max([m[1] for m in water])+1):\n        if (row, col) in water:\n            if x[(row, col)].value() > 0.999:\n                print \"B\",\n            else:\n                print \"-\",\n        else:\n            print \"I\",\n    print \"\"\n```\n\nThis takes 1.4 seconds to run using the default solver from the pulp package (the CBC solver) and outputs the correct solution:\n```\nI I - - - - - I I \n- - B - - - B - - \n- - - B - B - - - \n- - - - B - - - - \n- - - - B - - - - \n- - - - B - - - - \n- - - I I I - - - \n```\n\nNext, consider the full problem at the top of the question, which is a 13 x 14 grid with 7 islands:\n```\nwater = {(i, j): 1.0 for i in range(13) for j in range(14)}\nislands = {0: [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)],\n           1: [(9, 0), (9, 1), (10, 0), (10, 1), (10, 2), (11, 0), (11, 1),\n               (11, 2), (12, 0)],\n           2: [(0, 7), (0, 8), (1, 7), (1, 8), (2, 7)],\n           3: [(7, 7), (8, 6), (8, 7), (8, 8), (9, 7)],\n           4: [(0, 11), (0, 12), (0, 13), (1, 12)],\n           5: [(4, 10), (4, 11), (5, 10), (5, 11)],\n           6: [(11, 8), (11, 9), (11, 13), (12, 8), (12, 9), (12, 10), (12, 11),\n               (12, 12), (12, 13)]}\nfor k in islands:\n    for i, j in islands[k]:\n        del water[(i, j)]\n\nfor i, j in [(10, 7), (10, 8), (10, 9), (10, 10), (10, 11), (10, 12),\n             (11, 7), (12, 7)]:\n    water[(i, j)] = 20.0\n\nN = 7\n```\n\nMIP solvers often obtain good solutions relatively quickly and then spend a huge about of time trying to prove the optimality of the solution. Using the same solver code as above, the program does not complete within 30 minutes. However, you can provide a timeout to the solver to get an approximate solution:\n```\nmod.solve(pulp.solvers.PULP_CBC_CMD(maxSeconds=120))\n```\n\nThis yields a solution with objective value 17:\n```\nI I - - - - - I I - - I I I \nI I - - - - - I I - - - I - \nI I - - - - - I - B - B - - \n- - B - - - B - - - B - - - \n- - - B - B - - - - I I - - \n- - - - B - - - - - I I - - \n- - - - - B - - - - - B - - \n- - - - - B - I - - - - B - \n- - - - B - I I I - - B - - \nI I - B - - - I - - - - B - \nI I I - - - - - - - - - - B \nI I I - - - - - I I - - - I \nI - - - - - - - I I I I I I \n```\n\nTo improve the quality of the solutions you obtain, you could use a commercial MIP solver (this is free if you are at an academic institution and likely not free otherwise). For instance, here's the performance of Gurobi 6.0.4, again with a 2-minute time limit (though from the solution log we read that the solver found the current best solution within 7 seconds):\n```\nmod.solve(pulp.solvers.GUROBI(timeLimit=120))\n```\n\nThis actually finds a solution of objective value 16, one better than the OP was able to find by hand!\n```\nI I - - - - - I I - - I I I \nI I - - - - - I I - - - I - \nI I - - - - - I - B - B - - \n- - B - - - - - - - B - - - \n- - - B - - - - - - I I - - \n- - - - B - - - - - I I - - \n- - - - - B - - B B - - - - \n- - - - - B - I - - B - - - \n- - - - B - I I I - - B - - \nI I - B - - - I - - - - B - \nI I I - - - - - - - - - - B \nI I I - - - - - I I - - - I \nI - - - - - - - I I I I I I \n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Spanning Tree that Preserves the Number of Branch Vertices\r\n                \r\nSuppose a undirected connected graph $G$, denote the number of vertices in $G$ as $n$, number of branch vertices (i.e., vertices with degree $\\geq 3$) as $n_{\\geq 3}$. Suppose $n_{\\geq 3}>\\log(n)$.\nMy question is: Is there always a spanning tree $T$ of $G$, such that the number of branch vertices in $T$ is still as much as $O(n_{\\geq 3})$?\nHere, $O$ is the Big-O notation in computational complexity.\nI tried several examples and think this conjecture is correct.\nThis question is related to the minimum branch vertices spanning tree and the degree preserving spanning tree. However, neither of which provide an answer to my question.\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Algorithm for finding least weight spanning tree of G that contains forest\r\n                \r\nI have a graph having the definition of G = (V;E) . This graph is a weighted undirected connected graph. F is a forest on the vertices V using edges in E.\nSo I need to have an algorithm to compute a least weight spanning tree of G that contains F. How can I do that ?\nMy trying:\nI am trying to apply BFS to find the connected component of the graph and then think to apply Prims or kruskal algorithm to find the minimum spanning tree.\nBut I could not relate my thinking to the above problems. How can I proceed to solve the above questions?\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Find whether a minimum spanning tree contains an edge in linear time?\r\n                \r\nI have the following problem on my homework:\n\n\n  Give an O(n+m) algorithm to find that whether an edge e would be a part of the MST of a graph\n\n\n(We are allowed to get help from others on this assignment, so this isn't cheating.)\n\nI think that I could do a BFS and find if this edge is a edge between two layers and if so whether this edge was the smallest across those layers.  But what could I say when this edge is not a tree edge of the BFS tree?\n    ", "Answer": "\r\nAs a hint, if an edge is not the heaviest edge in any cycle that contains it, there is some MST that contains that edge.  To see this, consider any MST.  If the MST already contains the edge, great!  We're done.  If not, then add the edge into the MST.  This creates a cycle in the graph.  Now, find the heaviest edge in that cycle and remove it from the graph.  Everything is now still connected (because if two nodes used to be connected by a path that went across that edge, now they can be connected by just going around the cycle the other way).  Moreover, since the cost of the edge was deleted wasn't any smaller than the cost of the edge in question (because the edge isn't the heaviest edge in the cycle), the cost of this tree can't be any greater than before.  Since we started with an MST, we must therefore end with an MST.\n\nUsing this property, see if you can find whether the edge is the heaviest edge on any cycle in linear time.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Bug in Minimum Spanning Tree using Prim's algorithm\r\n                \r\nI am trying to implement Prim's algorithm but the output changes every time I run it\n\n```\n{'A': {'C'}, 'B': {'A'}, 'F': {'G'}, 'E': {'B'}, 'D': {'E'}, 'C': {'F'}}\n```\n\n\nwhen it is supposed to be\n\n```\n{'D': {'E'}, 'E': {'B'}, 'B': {'A'}, 'A': {'C'}, 'C': {'F'}, 'F': {'G'}}\n```\n\n\nNot sure what exactly is going on here, I tried debugging to no avail. Does anyone know if I am missing something glaringly obvious?\n\n```\nfrom collections import defaultdict\nimport heapq\n\n\ndef create_spanning_tree(graph, starting_vertex):\n    mst = defaultdict(set)\n    visited = set([starting_vertex])\n    edges = [\n        (cost, starting_vertex, to)\n        for to, cost in graph[starting_vertex].items()\n    ]\n    heapq.heapify(edges)\n    while edges:\n        cost, frm, to = heapq.heappop(edges)\n        if to not in visited:\n            visited.add(to)\n            mst[frm].add(to)\n            for to_next, cost in graph[to].items():\n                if to_next not in visited:\n                    heapq.heappush(edges, (cost, to, to_next))\n    return mst\n\nexample_graph = {\n    'A': {'B': 2, 'C': 3},\n    'B': {'A': 2, 'C': 12, 'D': 10, 'E': 4},\n    'C': {'A': 3, 'B': 12, 'F': 5},\n    'D': {'B': 10, 'E': 7},\n    'E': {'B': 4, 'D': 7, 'F': 16},\n    'F': {'C': 5, 'E': 16, 'G': 9},\n    'G': {'F': 9},\n}\nprint(dict(create_spanning_tree(example_graph, 'D')))\n```\n\n    ", "Answer": "\r\nLooking closely at both the outputs, \n\n```\n{'A': {'C'}, 'B': {'A'}, 'F': {'G'}, 'E': {'B'}, 'D': {'E'}, 'C': {'F'}}```\n\nand  ```\n{'D': {'E'}, 'E': {'B'}, 'B': {'A'}, 'A': {'C'}, 'C': {'F'}, 'F': {'G'}}```\n are same.\n\nSince it's a dictionary, (key, value) pairs matter, which is same in both the answers and not the order in which they appear.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Difference between Hamiltonian path and ST\r\n                \r\nI was reading up algorithms for finding the minimum spanning tree(in case of weighted graphs) and for finding if a graph has a hamiltonian path(which depends on the presence of a hamiltonian cycle). I got everything messed up. So whats the difference between a hamiltonian path and a spanning tree? Both cover all the vertices in the graph. While we can have efficient algorithms to find a spanning tree(perhaps a minimum spanning tree), why cant we have algorithms for finding a hamiltonian circuit?? We can keep on adding and removing one edge at a time till we reach a cycle and perhaps, we could find a hamiltonian cycle??\n    ", "Answer": "\r\nThe two problems are quite different. Think of the minimum spanning tree as the problem of connecting places where you only have to pay once to build the road, but you can use it as many times as you like. It's easy to come up with the cheapest configuration of roads (e.g. by Kruskal's algorithm) that allows you to travel from any place to any other.\n\nThe Hamiltonian cycle, on the other hand, wants you to minimize the actual travel distance, i.e. every move from one place to another counts. (It also asks you never to visit a place twice, but that's a minor detail.) This problem is fundamentally non-local, in the sense that you cannot tell whether you're doing the right thing just by locally exploring the options for the next step. By comparison, the greedy MST algorithm is guaranteed to pick the right next edge to add to the tree at every step.\n\nBy the way, nobody says that \"we cannot have efficient algorithms for HP\". It might be that we just haven't found one yet :-)\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Spanning tree that minimizes a dynamic 'metric'\r\n                \r\nLet us have a graph. When we remove an edge, 2 'cars' are created, one from each vertice of the edge. when these 2 cars meet they stop. The problem is to create a spanning tree so that the sum of the numbers of cars that pass through each vertice is minimal.\n\nThe added difficulty is that if a vertice has n cars passing from it, then the cost is K^n and not n*K.\n\nsome thoughts. We could find the shortest chordless cycles as a start but the position of those chordless cycles, ie whether they touch each other, changes the metric and thus what the shortest cycle is.\n\nThis is not a minimum spanning tree problem. I want to solve this because each car represents a varriable and the spanning tree is the most efficient way to compute an optimization problem. When 2 cars from the same edge meet and stop, I have a reduction of one varriable from the optimization.\n\nedit:\n\nThe process is like this. We remove a number of edges to make the graph a spanning tree. Each removed edge creates 2 cars, one at each vertice of the removed edge, that need to meet each other. We fix a path for each of those twin cars. We then check how many cars (from all the edges that we removed) pass through each vertice. If the number of the cars that pass from a vertice is n, the cost is K^n where K is a constant. We then add all the costs and that is the global cost that needs to be minimized.\n\nplease tell me if something is unclear.\nhttps://mathoverflow.net/questions/86301/spanning-tree-that-minimizes-a-dynamic-metric\n    ", "Answer": "\r\nHere's one insight - cars will never pass through an articulation point, so you can break the graph up into its blocks and solve for each block separately (the minimum overall cost function is the sum of the minimum cost for each block).\n\nTo find the minimum cost for a block - you could enumerate all the spanning trees for that block and calculate the cost for each one - a brute force approach, but it should work.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Reducing a network by appending strong links to the spanning tree\r\n                \r\nI am trying to reduce a full graph so that it only shows the strongest links.\n\nTo do that I am doing this:\n\n\nMultiply the original matrix by -1 (the values are in the interval [0,1])\nObtain the minimum spanning tree, step 1. makes it a spanning tree with the strongest links\nPaste other strong links that are not a part of the spanning tree until the average number of links per node is <= 5.\n\n\nTo perform these steps I have defined two functions that should be equivalent and I have to determine if the fast function output is the same as the slow function output.\n\nSetup\n\n```\n# number of links\nn <- 10 \nn2 <- sqrt(n)\n\nlibrary(igraph)\n\nset.seed(1234)\nmat <- matrix(rnorm(n, 1, 0.5), nrow = n2, ncol = n2)\nmat[mat < 0] <- 0\ncolnames(mat) <- letters[1:n2]\nrownames(mat) <- letters[1:n2]\ndiag(mat) <- 1\n```\n\n\nFunction 1: binding rows after converting graph to data.frame\n\n```\ntrim_network_1 <- function(mat, avg_links = 5, tolerance = 0.01) {\n  mat <- (-1) * mat\n\n  g <- graph_from_adjacency_matrix(mat, weighted = TRUE, mode = \"undirected\", diag = FALSE)\n\n  g_mst <- mst(g, algorithm = \"prim\")\n\n  threshold <- 0\n  avg_links_n <- FALSE\n\n  while (avg_links_n == FALSE) {\n    if (threshold < 1) {\n      message(sprintf(\"%s threshold...\", threshold))\n\n      g_not_in_mst <- delete.edges(g, which(abs(E(g)$weight) <= threshold))\n      g_not_in_mst <- graph.difference(g_not_in_mst, g_mst)\n\n      g <- rbind(\n        as_data_frame(g_mst),\n        as_data_frame(g_not_in_mst)\n      )\n\n      g <- graph_from_data_frame(g, directed = F)\n\n      avg_links_n <- ifelse(mean(degree(g)) <= avg_links, TRUE, FALSE)\n      threshold <- threshold + tolerance\n\n      if (avg_links_n == TRUE) {\n        message(sprintf(\"%s threshold achieves the avg number of connections\", threshold))\n        E(g)$weight <- (-1) * E(g)$weight\n        return(g)\n      }\n    } else {\n      warning(\"no threshold achieves the avg number of connections\\nreturning maximum spanning tree\")\n      avg_links_n <- TRUE\n      E(g_mst)$weight <- (-1) * E(g_mst)$weight\n      return(g_mst)\n    }\n  }\n}\n```\n\n\nFunction 2: Combine weights after merging graphs\n\n```\ntrim_network_2 <- function(mat, avg_links = 5, tolerance = 0.01) {\n  mat <- (-1) * mat\n\n  g <- graph_from_adjacency_matrix(mat, weighted = TRUE, mode = \"undirected\", diag = FALSE)\n\n  g_mst <- mst(g, algorithm = \"prim\")\n\n  threshold <- 0\n  avg_links_n <- FALSE\n\n  while (avg_links_n == FALSE) {\n    if (threshold < 1) {\n      message(sprintf(\"%s threshold...\", threshold))\n\n      g_not_in_mst <- delete.edges(g, which(abs(E(g)$weight) <= threshold))\n      g_not_in_mst <- graph.difference(g_not_in_mst, g_mst)\n\n      g <- graph.union(g_mst, g_not_in_mst)\n      E(g)$weight <- pmin(E(g)$weight_1, E(g)$weight_2, na.rm = T)\n      g <- remove.edge.attribute(g, \"weight_1\")\n      g <- remove.edge.attribute(g, \"weight_2\")\n\n      avg_links_n <- ifelse(mean(degree(g)) <= avg_links, TRUE, FALSE)\n      threshold <- threshold + tolerance\n\n      if (avg_links_n == TRUE) {\n        message(sprintf(\"%s threshold achieves the avg number of connections\", threshold))\n        E(g)$weight <- (-1) * E(g)$weight\n        return(g)\n      }\n    } else {\n      warning(\"no threshold achieves the avg number of connections\\nreturning maximum spanning tree\")\n      avg_links_n <- TRUE\n      E(g_mst)$weight <- (-1) * E(g_mst)$weight\n      return(g_mst)\n    }\n  }\n}\n```\n\n\nComparting the outputs\n\n```\ng1 <- trim_network_1(mat)\ng2 <- trim_network_2(mat)\n\ng1 <- as_data_frame(g1)\ng2 <- as_data_frame(g2)\n\ng1w <- order(g1$weight)\ng1 <- g1[g1w, ]\n\ng2w <- order(g2$weight)\ng2 <- g2[g2w, ]\n\n# this is symmetric so A-B is the same as B-A (undirected graph)\n# all.equal(g1, g2) doens't always hold bc of symmetry\nall.equal(g1$weight, g2$weight)\nall.equal(nrow(g1), nrow(g2))\n```\n\n\nI tried with ```\ngraph.union(g_mst, g_not_in_mst)```\n and even after doing ```\nE(g)$weight <- pmin(E(g)$weight_1, E(g)$weight_2, na.rm = T)```\n I cannot find a formal way to prove that the two results are the equal. The idea of comparing two results is that one function is more efficient than the other.\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Time Complexity of (Minimum Spanning Tree) Prim's Algorithm\r\n                \r\nWhen we implement this algorithm using adjacency matrix and without using priority queue, the time complexity comes out to be O(V^2), where V is the total no. of vertices and E is the total no. of edges.\nBut when we implement it using priority queue(using binary heap) and adjacency list, the time complexity comes out to be O((V + E)*logV).\nHow is this T.C. better than O(V^2) as in worst case E = O(V^2) ?\nI am not able to get it. Please clarify my doubt.\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How can I implement 'finding min-spanning tree algorithm' on a complex graph using graph-viz?\r\n                \r\nI need to find minimum spanning trees in a large graph using graph-viz. The number of nodes and edge information will be given in another text-file in 2 columns,\"source\" and \"destination\". please help.\n    ", "Answer": "\r\nGraphviz is principally a tool to layout graphs. The algorithms that are included relate to this task. The input for a graph is a graph specification. \n\nWhat you need is a tool that computes the MST. There are several. The wikipedia article is a good start for references:\n\nhttp://en.wikipedia.org/wiki/Prim's_algorithm \n\nIn python there is \n\nhttp://pygraphviz.github.io/\n\nIn perl, I found\n\nhttps://gist.github.com/hirotnk/780342\n\nThe SO answer here:\n\nGraphviz Dot Algorithm\n\nis also a good reference. \n\nGiven the output of an MST tool, you can general a file that is rendered by graphviz.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to find a tree connecting all nodes in neo4j?\r\n                \r\nI want a minimum spanning tree which spans at least (but not restricted to) a set of nodes.\n\ne.g.\n\nSay I want a minimum spanning tree which has at least the nodes ```\n{A,B}```\n. However my graph looks like this ```\nA->C->B->D```\n. So the algorithm should return ```\nA->C->B```\n.\n\nI am not asking for shortest path, there can be more than two nodes I want to connect. I just want the smallest graph that is connected and includes the given set.\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Finding the root that minimize tree depth\r\n                \r\nGiving a tree that content no cycles (eg a minimum spanning tree : http://fr.wikipedia.org/wiki/Fichier:Minimum_spanning_tree.svg)\nHow to calculate which node minimize the tree depth if it is used as root ?\n    ", "Answer": "\r\nAll trees contain no cycles.  By definition, a tree is an cycle-free, connected graph.  If there is one vertex, the answer is trivial.  So assume there are at least two vertices.\n\nLet u and v be two vertices such that their distance d (u, v) is maximum.  It should be easy to see that if one selects a vertex along a shortest uv path to be the root, the depth will be at least ceiling (d (u, v) / 2).  It should also be noted that if one selects a vertex to be the root not on that path, the depth will be greater than ceiling (d (u, v) / 2).\n\nSuppose that we have chosen the root r to be the middle vertex along a minimum uv path such that d (u, r) = ceiling (d (u, v) / 2) and d (r, v) ≤ ceiling (d (u, v) / 2).  If there were another vertex, w, such that d (r, w) > ceiling (d (u, v) / 2), we would have d (u, r) < d (w, r) and then, because there is only one path between any two distinct vertices in a tree, we have d (u, v) = d (u, r) + d (r, v) < d (u, r) + d (r, w) = d (u, w), which contradicts that u and v have the greatest distance.  So now the depth, given r as the root, is ceiling (d (u, v) / 2).\n\nSo we need to find the two vertices with the largest distance.  Once we do that, we can use a shortest path-finding algorithm for uv, note the length, and traverse half-way along said path and use that middle vertex as the root.\n\nHow do we find those vertices?  Pick a vertex w and place it in a queue.  While the queue is non-empty add the neighbors of the next vertex in the queue to the end of the queue.  When the queue is empty, take note of the most recently removed vertex.  This will be u.  Perform the procedure again and you will have v.\n\nWhy does this work?  The above algorithm finds a furthest away vertex from w. If w happens to be u or v, the algorithm clearly finds v or u, respectively.  So suppose w is neither u nor v.  If the algorithm found a u or v in the first pass, again, it will work (for it will find the other in the second pass), so assume, by way of contradiction, that after the first pass it found x such that it is not the end of a maximum path for the tree.  From the triangle inequality we have d (u, v) ≤ d (u, w) +  d (w, v) and d (v, x) ≤ d (v, w) + d (w, x).  Subtracting the second from the first we have d (u, v) - d (v, x) ≤ d (u, w) - d (w, x).  We can then rearrange that to d (u, v) + d (w, x) ≤ d (u, w) + d (v, x).  Since d (w, u) ≤ d (w, x) (x is the end of a maximum path from w; wu cannot exceed wx) and d (v, x) < d (u, v) (x is not the end of a maximum path), we can strengthen the inequality to d (u, v) + d (w, x) < d (u, v) + d (w, x).  That's not possible, though, so x must be at the end of a maximum path.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Why this code makes wrong minimal spanning tree by Prim's algorythm?\r\n                \r\nI have some code on Golang with Prim's algorythm.\nThe task is to find minimal spanning tree with a minimum amount of edge lengths. But if vertices number is greater then 3, I'm getting wrong answer.\n\nSo I tried to rewrite Prim's algorythm, but nothing changed.\n\n```\nfunc MST_Prim(vertices []*Vertex, vertNum int, edgeNum int) []*Edge {\n    treeEdges := make([]*Edge, 0)\n\n    for i := 0; i < vertNum; i++ {\n        vertices[i].index = -1\n    }\n\n    queue := make(PriorityQueue, 0)\n    v := vertices[0]\n    for i := 0; i < vertNum; i++ {\n        v.index = -2\n\n        for _, edge := range vertices[v.id].edges {\n            u := vertices[edge.v]\n\n            if u.index == -1 {\n                u.priority = edge.len\n                u.value = v.id\n                queue.Push(u)\n            } else if u.index != -2 && edge.len < u.priority {\n                u.value = v.id\n                queue.update(u, v.value, edge.len)\n            }\n        }\n\n        if queue.Len() == 0 {\n            break\n        }\n\n        v = queue.Pop().(*Vertex)\n        treeEdges = append(treeEdges, &Edge{v.id, v.value, v.priority})\n    }\n\n    return treeEdges\n}\n```\n\n\nI need to print minimal sum of length of edges in minimal spanning tree.\nThere is the input:\n\n```\n4\n4\n1 2 462\n0 3 343\n0 1 430\n1 3 146\n```\n\n\nI'm getting 1038 as answer, but correct answer is 951.\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Is the computed number of spanning trees for this undirected graph reasonable/correct?\r\n                \r\nThis is part of my Master thesis which is about designing hydrogen pipeline networks.\nFor a particular graph of 135 nodes and 157 edges and (see figure below), I need to compute the number of spanning trees (spanning all nodes).\nI used the Kirchhoff's theorem and implemented it (using scipy and networkx) this way:\n```\nimport networkx as nx\nfrom scipy import linalg\n\n\ndef nbr_spanning_trees(a_G):\n    L = nx.laplacian_matrix(a_G)  # compute the laplacian matrix which is equal to degree matrix - adjacency matrix\n    L = L.toarray()  # convert the sparse matrix output of the previous line to an array\n    L_cof = L[1:, 1:]  # extract the submatrix associated with the (1,1)-entry's cofactor from the Laplacian matrix\n    # (any cofactor can be taken)\n    det = linalg.det(L_cof)  # calculate the cofactor\n    return det\n```\n\nThe returned result is: 1.879759212930661e+16 spanning trees.\nThis number seems gigantesque, is it reasonable/correct? Is my implementation correct?\nAs an addition, the graph has at least 23 cycles (but not much more I think). I know this since I have identified the minimum spanning tree and it has 23 edges less than the underlying graph.\n\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Why can't Prim's or Kruskal's algorithms be used on a directed graph?\r\n                \r\nPrim's and Kruskal's algorithms are used to find the minimum spanning tree of a graph that is connected and undirected. Why can't they be used on a graph that is directed?\n    ", "Answer": "\r\nIt's a minor miracle that these algorithms work in the first place -- most greedy algorithms just crash and burn on some instances. Assuming that you want to use them to find a minimum spanning arborescence (directed paths from one vertex to all others), then one problematic graph for Kruskal looks like this.\n\n```\n 5\n  --> a\n /   / ^\ns   1| |2\n \\   v /\n  --> b\n 3\n```\n\n\nWe'll take the a->b arc of cost 1, then get stuck because we really wanted s->b of cost 3 and b->a of cost 2.\n\nFor Prim, this graph is problematic.\n\n```\n 5\n  --> a\n /   /\ns   1|\n \\   v\n  --> b\n 3\n```\n\n\nWe'll take s->b of cost 3, but we really wanted s->a of cost 5 and a->b of cost 1.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "undirected graph what is the possible minimum spanning tree?\r\n                \r\nI try to solve this question but I am not sure of my solution \n\nthe quetion\n\nThis is my solution:\nI use Kruskal algorithm\nand I choose the edges that will make (a) leaf\nsolution\n\nthank you.\n    ", "Answer": "\r\nNo. The answer will be 9. The algorithm takes edges:\na<->b with cost 1: ADDED a,b are now connected\na<->d with cost 1: ADDED a,b,d are now connected\nb<->d with cost 4: SKIPPED\nc<->d with cost 7: ADDED a,b,d,c are now connected, this is the final spanning tree.\na<->c with cost 8: SKIPPED\nb<->c with cost 12: SKIPPED\n\nSo, the answer is 1+1+7=9.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum Product Spanning Tree with Negatives?\r\n                \r\nI understand that you can find the MPT by taking the log of every edge in the graph and calculating the MST.  The constraint here of course is that the values of the edges must be positive, because you cannot take ```\nlog(x)```\n where ```\nx <= 0```\n.  I am trying to find an algorithm that can be used to calculate the MPT when edge values can be positive, zero, or negative, but I couldn't find any resources online that would explain how to handle this case.  Can someone either provide a resource or algorithm that allows for MPT to be calculated when the positive constraint is lifted?  Alternatively, if someone can provide a hint in the right direction so that I could figure out the algorithm independently, that would work too.\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "My own Prim Algorithm is too slow comparing to tree.minimum_spanning_tree() function from network nx. Why?\r\n                \r\nHere is my algorithm which purpose is to find a minimum spanning tree from a graph given by a user. It is 100 slower than tree.minimum_spanning_tree() function. What should I do to speed it up?\n```\ndef prim_algorithm(graph:nx.Graph) -> nx.Graph:\n    \"\"\"\n    Generates a minimum spanning tree and returns it.\n    Args:\n        graph (nx.Graph): a graph in which we want\n        to find the minimum spanning tree.\n    Returns:\n        nx.Graph: a spanning tree found.\n    Example:\n    >>> prim_algorithm(nx.Graph([(1,2,{'weight':1}),(1,3,{'weight':2}),(2,3,{'weight':0})])).edges(data=True)\n    EdgeDataView([(1, 2, {'weight': 1}), (2, 3, {'weight': 0})])\n    \"\"\"\n    spanning_tree = nx.Graph()\n    starting_point = list(graph.nodes())[0] \n    spanning_tree.add_node(starting_point)\n    incident_edges = set()\n    last_added_node = starting_point\n    while len(spanning_tree.nodes) != len(graph.nodes):\n        # Searching for new incident edges to nodes of already built tree\n        new_edges = {(edge[0], edge[1], edge[2]['weight']) for edge in graph.edges(last_added_node, data=True)}\n        # Deleting those that would form a circuit\n        incident_edges -= {edge for edge in incident_edges if edge[0] in spanning_tree.nodes and edge[1] in spanning_tree.nodes}\n        # Searching for a cheapest edge, which is incident to already added nodes\n        min_edge = min(incident_edges, key=lambda edge: edge[2])\n        # Adding it to our tree\n        spanning_tree.add_edge(min_edge[0], min_edge[1], weight = min_edge[2])\n        last_added_node = min_edge[0] if min_edge[0] not in list(spanning_tree.nodes) else min_edge[1]\n        # Removing it from our graph\n        graph.remove_edge(min_edge[0], min_edge[1])\n    return spanning_tree\n```\n\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to compute nearest distance between points?\r\n                \r\nThis is a ```\ntmp```\n set of points with ```\n(x, y)```\n coordinates and ```\n0```\n or ```\n1```\n categories.\n```\ntmp <- structure(list(cx = c(146.60916, 140.31737, 145.92917, 167.57799, \n166.77618, 137.64381, 172.12157, 175.32881, 175.06154, 135.50566, \n177.46696, 148.06731), cy = c(186.29814, 180.55231, 210.6084, \n210.34111, 185.48505, 218.89375, 219.69554, 180.67421, 188.15775, \n209.27205, 209.27203, 178.00151), category = c(1, 0, 1, 1, 1, \n0, 0, 0, 0, 0, 0, 0)), class = \"data.frame\", row.names = c(NA, \n-12L))\n```\n\nI need to find the minimum spanning tree for ```\ncategory = 1```\n points, then to join (add edge) each point with ```\ncategory = 0```\n to its nearest ```\ncategory = 1```\n point.\nThe minimum spanning tree is built on points with the ```\ncategory = 1```\n.\n```\nones    <- tmp[tmp$category == 1,]       \nn       <- dim(ones)[1]    \n\nd       <- matrix(0, n, n) \nd       <- as.matrix(dist(cbind(ones$cx, ones$cy)))\n\ng1        <- graph.adjacency(d, weighted=TRUE, mode=\"undirected\")\nV(g1)$name <- tmp[tmp$category == 1,]$Name\nmylayout = as.matrix(cbind(ones$cx, -ones$cy))\n\nmst <- minimum.spanning.tree(g1) # Find a minimum spanning tree\n\nplot(mst, layout=mylayout, \n         vertex.size      = 10,\n         vertex.label     = V(g1)$name,\n         vertex.label.cex =.75, \n         edge.label.cex  = .7,\n)\n```\n\nExpected result is in center of figure.\n\nMy current attempt is:\n```\nn       <- dim(tmp)[1]    \nd       <- matrix(0, n, n) \nd       <- as.matrix(dist(cbind(tmp$cx, tmp$cy)))\n\n\nd[tmp$category %*% t(tmp$category) == 1] = Inf\nd[!sweep(d, 2, apply(d, 2, min), `==`)] <- 0\n\n\ng2        <- graph.adjacency(d, weighted=TRUE, mode=\"undirected\")\nmylayout = as.matrix(cbind(tmp$cx, -tmp$cy))\nV(g2)$name <- tmp$Name\n\nplot(g2, layout=mylayout, \n         vertex.size      = 10,\n         vertex.label     = V(g2)$name,\n         vertex.label.cex =.75,\n         edge.label       = round(E(g2)$weight, 3), \n         edge.label.cex  = .7,\n)\n```\n\nOne can see that I have found the minimum dist and add one edge only.\nQuestion. How to define condition for all possible points?\n    ", "Answer": "\r\nYou can try the code below\n```\n# two categories of point data frames\npts1 <- subset(tmp, category == 1)\npts0 <- subset(tmp, category == 0)\n\n# generate minimum spanning tree `gmst`\ngmst <- mst(graph_from_adjacency_matrix(as.matrix(dist(pts1[1:2])), mode = \"undirected\", weighted = TRUE))\n\n# distance matrix between `pts0` and `pts1`\npts0_pts1 <- as.matrix(dist(tmp[1:2]))[row.names(pts0), row.names(pts1)]\n\n# minimum distances of `pts0` to `pts1`\nidx <- max.col(-pts0_pts1)\ndf0 <- data.frame(\n  from = row.names(pts0),\n  to = row.names(pts1)[idx],\n  weight = pts0_pts1[cbind(1:nrow(pts0), idx)]\n)\n\n# aggregate edges lists and produce final result\ng <- graph_from_data_frame(rbind(get.data.frame(gmst), df0), directed = FALSE) %>%\n  set_vertex_attr(name = \"color\", value = names(V(.)) %in% names(V(gmst)))\n\nmylayout <- as.matrix(tmp[names(V(g)), 1:2]) %*% diag(c(1, -1))\nplot(g, edge.label = round(E(g)$weight, 1), layout = mylayout)\n```\n\nand you will get\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to use Neo4j for finding Minimum Spanning Tree?\r\n                \r\nI am wondering how to use Neo4j to find the MST? Most examplesI found was using Hadoop to find it.\n    ", "Answer": "\r\nI don't think that this is possible in Cypher, given how current algorithms determine an MST (if I'm wrong on this, I'd love to know).\n\nInstead, I'd recommend implementing one of the algorithms used for determining an MST, e.g. Prim's Algorithm.  It's quite straight forward and, with the help of heaps and adjacency lists, is relatively performant.\n\nA quick search for the algorithm will turn up many links.\n\nI'm sure leveraging Neo4j's Core API or Traversal API might even help things integrate even more closely, possibly without needing to represent the entire graph as an adjacency list first.  And of course you can do that with Neo4j in Embedded Mode or turn it into a Server Plugin in case you're running Neo4j in Server Mode.\n\nLet us know what you come up with!\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Interpreting an answer given as two arrays\r\n                \r\nWhat does this means\n\n\n  The edges of the minimum spanning\n   tree are returned in array mst (of size n-1 by 2)\n\n\n?\n\nWhen I run the program, at some point displays\n\nthis two arrays\n\nhowever I don't know how to interpret this as edges of the minimum spanning tree.\n\nHow do I take the edges? Is there a way to plot this answer?\n\nCould someone help please?\n\nThis is the code.\n\n```\nfunction [mst, cost] = prim(A)\n[n,n] = size(A);                           \nA, n, pause,\n\nif norm(A-A','fro') ~= 0 ,                 \n  disp(' Error:  Adjacency matrix must be symmetric ') \n  return,\nend;\n\nintree = [1];  number_in_tree = 1;  \nnumber_of_edges = 0;\nnotintree = [2:n]';  number_notin_tree= n-1;\n\nin = intree(1:number_in_tree),                \nout = notintree(1:number_notin_tree),\npause, \n\nwhile number_in_tree < n,\n  mincost = Inf;                             \n  for i=1:number_in_tree,               \n    for j=1:number_notin_tree,\n      ii = intree(i);  jj = \n      notintree(j);\n      if A(ii,jj) < mincost, \n        mincost = A(ii,jj); jsave = j; \n        iisave = ii; jjsave = jj;   \n      end;\n    end;\n  end;\n\n  number_of_edges = number_of_edges +1;      \n  mst(number_of_edges,1) = iisave;            \n  mst(number_of_edges,2) = jjsave;\n  costs(number_of_edges,1) = mincost;\n\n  number_in_tree = number_in_tree + 1;        \n  intree = [intree; jjsave];                  \n  for j=jsave+1:number_notin_tree,            \n    notintree(j-1) = notintree(j);\n  end;\n  number_notin_tree = number_notin_tree - 1;  \n\n  in = intree(1:number_in_tree),              \n  out = notintree(1:number_notin_tree), \n  pause,\nend;\n\ndisp(' Edges in minimum spanning tree and their costs: ')\n[mst  costs]                                 \ncost = sum(costs)\n```\n\n    ", "Answer": "\r\nAn edge can be uniquely identified by the two vertices that it joins.\nEach row of ```\nmst```\n contains the two indices to the two vertices that span the edge.\n\nThe input graph is composed of a set of vertices and edges joining them, represented as an adjacency matrix ```\nA```\n. If ```\nA(i,j)```\n is true, then vertices i and j are adjacent (i.e. share an edge). In the output matrix ```\nmst```\n this edge would be represented by ```\nmst(index,:) = [i,j]```\n.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Understanding when to use Prim or Kruskal for Minimum Spanning Tree\r\n                \r\nI'm trying to apply Prim's or Kruskal's algorithms to certain situations. I understand that Prim is used when graphs are dense (Example: as adjacency matrix with priority queue as unordered array would be good for a dense tree where ```\nE = O(V^2)```\n. And Kruskal is used when graphs are sparse (Example: as adjacency list with fast sort where ```\nE = O(V)```\n. What I'm unsure about is the in between. For example, a graph with a moderate number of edges such that \n\n```\nE = O(V log V)\n```\n\n\nWould this be Prim or Kruskal? I think it may be either one because Prim ```\nO(E log V)```\n and Kruskal ```\nO(E log E)```\n have similar time complexities.\n    ", "Answer": "\r\nDue to the nature of each algorithm, in the case of a graph with moderate number of edges, you should use Kruskal's algorithm. Prim's algorithm runs faster in a graph with many edges as it only compares limited number of edges per loop, where as Kruskal's start by sorting all the edges in the list then going through them again to make check if the edge is part of the minimal spanning tree (MST) or not. So in the case of your question, while both algorithms have similar running time, number of edges in the graph should be the main component when you are deciding between the algorithms. More edges compared to vertices, use Prim's, otherwise, use Kruskal's.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "running time variation Prim\r\n                \r\nI wanted to find the \"minimum spanning tree\", given a set A with edges that must be in the \"minimum spanning tree\" (so it's not a real minimum spanning tree, but given A, it has the least sum of weights). So the \"minimum spanning tree\" must definitely contain all edges of A. I made some modifications to Prim's algorithm which can be found below. I then wanted to find the running time of this algorithm, however, I'm having trouble with finding the running time to check wheter the intersection of two sets is empty. \nCould somebody please help me? And what would be to total running time then? I already put the running time for each step next to that step, except for \"?\".\n\nNotation clarification:\nδ(W) = {{v ,w} ∈ E : w ∈ W, v ∈ V\\W} for W ⊂ V\n\n```\nalgorithm:\n\n\n1. T = ∅, W = {v}  for some v ∈ V   O(1)\n2.  While W ≠ V                     n iterations\n       If (A ∩ δ(W) ≠ ∅) do              ?\n           Take e = {v,w}  ∈ (A ∩ δ(W))  O(1)\n           T = T ∪ {e}                   O(1)\n           W = W ∪ {v,w }                O(1)\n       Else\n           Find e = {v,w } ∈ δ(W) s.t. ce ≤ cf ∀ f ∈ δ(W)  O(m)  \n           T = T ∪ {e}                                     O(1)\n           W = W ∪ {v,w }                                  O(1)\n   End while\n```\n\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "proof of the Reverse-delete algorithm\r\n                \r\nis this proof ,which is provided in the wikipedia page https://en.wikipedia.org/wiki/Reverse-delete_algorithm (at the bottom of the page) correct ?\n\nPseudocode \n\n```\n 1  function ReverseDelete(edges[] E)\n 2    sort E in decreasing order\n 3    Define an index i ← 0\n 4    while i < size(E)\n 5       Define edge ← E[i]\n 6         delete E[i]\n 7         if edge.v1 is not connected to edge.v2\n 8             E[i] ← edge\n 9         i ← i + 1\n 10   return edges[] E\n```\n\n\nThe proof consists of two parts. First, it is proved that the edges that remain after the algorithm is applied form a spanning tree. Second, it is proved that the spanning tree is of minimal weight.\n\nSpanning tree\n\nThe remaining sub-graph (g) produced by the algorithm is not disconnected since the algorithm checks for that in line 7. the resualt sub-graph cannot contain a cycle since if it does then when moving along the edges we would encounter the max edge in the cycle and we would delete that edge.thus g must be a spanning tree of the main graph G.\n\nMinimality\n\nWe show that the following proposition P is true by induction: If F is the set of edges remained at the end of the while loop, then there is some minimum spanning tree that (it's edges) are a subset of F.\n\nClearly P holds before the start of the while loop . since a weighted connected graph always has a minimum spanning tree and since F contains all the edges of the graph then this minimum spanning tree must be a subset of F.\n\nNow assume P is true for some non-final edge set F and let T be a minimum spanning tree that is contained in F . we must show that after deleting edge e in the algorithm there exist some (possibly other) spanning tree T' that is a subset of F.\n\nif the the next deleted edge e doesn't belong to T then T=T' is a subset of F and P holds. .\n\notherwise , if e belongs to T : first note that the algorithm only removes the edges that do not cause a disconnectedness in the F . so e does not cause a disconnectedness . But deleting e causes a disconnectedness in tree T (since it's a member of T) . assume e separates T into sub-graphs t1 and t2 . Since the whole graph is connected after deleting e then there must exists a path between t1 and t2 ( other than e ) so there must exist a cycle C in the F (before removing e) . now we must have another edge in this cycle (call it f) that is not in T but it is in F (since if all the cycle edges were in tree T then it would not be a tree anymore) . we now claim that T' = T - e + f is the minimum spanning tree that is a subset of F.\n\nfirstly we prove that T' is a spanning tree . we know by deleting an edge in a tree and adding another edge that does not cause a cycle we get another tree with the same vertices. since T was a spanning tree so T' must be a spanning tree too. since adding \" f \" does not cause any cycles since \"e\" is removed.(note that tree T contains all the vertices of the graph).\n\nsecondly we prove T' is a minimum spanning tree . we have three cases for the edges \"e\" and \" f \". wt is the weight function.\n\nwt( f ) < wt( e ) this is impossible since this causes the weight of tree T' to be strictly less than T . since T is the minimum spanning tree , this is simply impossible.\n\nwt( f ) > wt( e ) this is also impossible. since then when we are going through edges in decreasing order of edge weights we must see \" f \" first . since we have a cycle C so removing \" f \" would not cause any disconnectedness in the F. so the algorithm would have removed it from F earlier . so \" f \" does not exist in F which is impossible( we have proved f exists in step 4 .\n\nso wt(f) = wt(e) so T' is also a minimum spanning tree. so again P holds.\n    so P holds when the while loop is done ( which is when we have seen all the edges ) and we proved at the end F becomes a spanning tree and we know F has a minimum spanning tree as its subset . so F must be the minimum spanning tree itself .\n\nEDIT\n\nactually i have problem with paragraph \"firstly we prove that T' is a spanning tree\" and the part \"we proved at the end F becomes a spanning tree and we know F has a minimum spanning tree as its subset . so F must be the minimum spanning tree itself \n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum spaning tree with Kruskal' algorithm\r\n                \r\nHow i can calculate im R(3.0.0 - Linux x32) minimum spanning tree with Kruskal's algorithm?\n\nI create an weighted full graph with igraph (0.6.5) library as folws:\n\n```\nset.seed(1234567890)\ng <- graph.full(n = 20)\nE(g)$weight <- round(runif(ecount(g)), 2) * 100\n```\n\n\nAnd i am able to calcutae the minimum spaning tree with Prim (igraph)\n\n```\nmstPrim <- minimum.spanning.tree(g, algorithm = \"prim\")\n```\n\n\nBut unfortunaly doesn't in \"igraph\" Kruskal's algorithm implemented.\n\nI can represent my genereted graph as a data.frame:\n\n```\nedgeMatrix <- data.frame(cbind(get.edgelist(g), E(g)$weight))\nnames(edgeMatrix) <- c(\"from\", \"to\", \"weight\")\n```\n\n\nIs there a simple way to calculate mst with Kruskal's alogithm in R?\n    ", "Answer": "\r\nA small workaround with RBGL package:\n\n```\n#convert with graph packagege to BAM class of graph an calculate mst\nmstKruskalBAM <- mstree.kruskal(graphBAM(edgeMatrix))\n#build new data frame with resut\nmstKruskalDF <- data.frame(cbind(t(mstKruskalBAM$edgeList),\n                                 t(mstKruskalBAM$weight)))\n#convert back to igraph package\nmstKruskal <- graph.data.frame(mstKruskalDF, directed=FALSE)\n```\n\n\nNow is it possible to plot and compare both aloriph with defining a layout algorithm like this:\n\n```\nplot(mstPrim, layout = layout.kamada.kawai, edge.label = E(mstPrim)$weight)\nplot(mstKruskal, layout = layout.kamada.kawai, edge.label = mstKruskal$weight)\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Networkx: Creating a complete graph for a given set of nodes\r\n                \r\nI have a list as ```\nc4_leaves = [56,78,90,112]```\n. I'm trying to create a complete graph using these elements in ```\nc4_leaves```\n as nodes. Here's what I've tried:\n```\nV_ex = c4_leaves\nG_ex = nx.Graph() \nG_ex.add_nodes_from(V_ex)\nG_ex = nx.complete_graph(4)\n\nfor u,v in G_ex.edges():\n    G_ex[u][v]['distance'] = distance(points33, u, v)\n```\n\nAnd then the minimum spanning tree of the above graph as:\n```\nT_ex = nx.minimum_spanning_tree(G_ex, weight='distance')\nF_ex = list(T_ex.edges())\n```\n\nWhen I draw ```\nG_ex```\n, it gives me the correct graph, but when I print details of the minimum spanning tree, it shows that ```\nT_ex.nodes() = [0,1,2,3,56,78,90,112]```\n.\nCan someone show me the mistake I'm making?\n    ", "Answer": "\r\nInstead of using ```\ncomplete_graph```\n, which generates a new complete graph with other nodes, create the desired graph as follows:\n\n```\nimport itertools\nimport networkx as nx\n\nc4_leaves = [56,78,90,112]\nG_ex = nx.Graph()\nG_ex.add_nodes_from(c4_leaves)\nG_ex.add_edges_from(itertools.combinations(c4_leaves, 2))\n```\n\n\nIn the case of directed graphs use:\n\n```\nG_ex.add_edges_from(itertools.permutations(c4_leaves, 2))\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Create N-Clusters out of Min spanning tree?\r\n                \r\nLet say I created a Minimum Spanning Tree out of Graph with M nodes. Is there an algorithm to create N number of clusters.\nI'm looking to cut some of the links such as that I end up with N clusters and label them i.e. given a node X I can query in which  cluster it belongs.\n\nWhat I think is once I have the MST, I cut the top/max M-N edges of the MST and I will get N clusters ?\nIs my logic correct ?\n    ", "Answer": "\r\nThat seems a good way to me. You ask whether it's \"correct\" -- that I can't say, since I don't know what other unstated criteria you have in mind. All you have actually stated that you want is to create N clusters -- which you could also achieve by throwing away the MST, putting vertex 1 in the first cluster, vertex 2 in the second, ..., vertex N-1 in the (N-1)th, and all remaining vertices in the Nth.\nIf you're using Kruskal's algorithm to build the MST, you can achieve what you're suggesting by simply stopping the algorithm early, as soon as only N components remain.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Randomly generate edges and vertices\r\n                \r\nI'm learning minimum spanning trees and I encountered this question and decided to give it a shot...\n\n\n  Implement the minimum spanning tree algorithm \n   on a randomly generated directed graph network of 100 vertices and 800 edges\n\n\n```\npublic static int[][] getRandomArray(int n){\n    int[][] a = new int[n][n];\n    Random r = new Random();\n\n    for(int i = 0; i < a.length; i++){\n        for(int j = 0; j < a[i].length; j++){\n            a[i][j] = r.nextInt();\n        }\n    }\n\n    return a;\n}\n\n\npublic static void main (String [] args)\n{\n   int x[];\n     //TreeSet is used to sort the edges before passing to the algorithm\n    TreeSet<Edge>  edges = new TreeSet<Edge>();\n\n    Random random = new Random();\n\n    edges.add(new Edge(\"0\", \"1\", 2)); \n    edges.add(new Edge(\"0\", \"3\", 1)); \n    edges.add(new Edge(\"1\", \"2\", 3)); \n    edges.add(new Edge(\"2\", \"3\", 5)); \n\n    System.out.println(\"Graph\");\n    KEdges vv = new KEdges();\n\n    for (Edge edge : edges) {\n        System.out.println(edge);\n        vv.insertEdge(edge);\n    }\n\n    System.out.println(\"Kruskal algorithm\");\n    int total = 0;\n    for (Edge edge : vv.getEdges()) {\n        System.out.println(edge);\n        total += edge.getEdgeWeight();\n    }\n    System.out.println(\"Total weight is \" + total);\n}\n\n\nstatic class Edge implements Comparable<Edge>\n{\n    String vertexA;\n    String vertexB;\n    int weight;\n\n    public Edge(String vertexA, String vertexB, int weight)\n    {\n        this.vertexA = vertexA;\n        this.vertexB = vertexB;\n        this.weight = weight;\n    }\n\n    public String getVertexA()\n    {\n        return vertexA;\n    }\n\n    public String getVertexB()\n    {\n        return vertexB;\n    }\n\n    public int getEdgeWeight()\n    {\n        return weight;\n    }\n\n    public String toString()\n    {\n        return \"(\"+ vertexA + \", \" + vertexB + \") : weight \"+ weight ;\n    }\n    @Override\n    public int compareTo(Edge o) {\n       return (this.weight < o.weight)? -1 : 1;\n    }\n\n}\n\nstatic class KEdges \n{\n    Vector<HashSet<String>>  vertexGroups = new Vector<HashSet<String>>();\n    TreeSet<Edge> kruskalEdges = new TreeSet<Edge>();\n\n    public TreeSet<Edge> getEdges()\n    {\n        return kruskalEdges;\n    }\n\n    public HashSet<String> getVertexGroup(String vertex)\n    {\n        for (HashSet<String> vertexGroup : vertexGroups)\n        {\n            if (vertexGroup.contains(vertex))\n            {\n                return vertexGroup;\n            }\n        }\n        return null;\n    }\n\n\n\n  public void insertEdge(Edge edge)\n  {\n    String vertexA = edge.getVertexA();\n    String vertexB = edge.getVertexB();\n\n    HashSet<String> vertexGroupA = getVertexGroup(vertexA);\n    HashSet<String> vertexGroupB = getVertexGroup(vertexB);\n\n    if (vertexGroupA == null)\n    {\n        kruskalEdges.add(edge);\n        if (vertexGroupB == null){\n            HashSet<String> htNewVertexGroup = new HashSet<String>();\n            htNewVertexGroup.add(vertexA);\n            htNewVertexGroup.add(vertexB);\n            vertexGroups.add(htNewVertexGroup);\n        }\n    }\n    else{\n        if (vertexGroupB == null)\n         {\n             vertexGroupA.add(vertexB);\n             kruskalEdges.add(edge);\n         }\n        else if (vertexGroupA != vertexGroupB)\n         {\n        vertexGroupA.addAll(vertexGroupB);\n        vertexGroups.remove(vertexGroupB);\n        kruskalEdges.add(edge);\n         }\n    }\n  }\n\n}\n```\n\n\nI'm stuck on how to generate the random edges and vertices...\nAny suggestions and ideas...\n    ", "Answer": "\r\n```\nimport java.util.Random;\n\nRandom random = new Random();\n\nEdge[] edges = new Edge[800];\nfor(int i = 0; i < edges.length; i++) {\n    edges[i] = new Edge(\n        Integer.toString(random.nextInt(100)),\n        Integer.toString(random.nextInt(100)));\n        random.nextInt(300) //weights from 0 to 299\n    );\n}\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Kou's algorithm to find Steiner Tree using igraph\r\n                \r\nI am trying to implement the Kou's algorithm to identify Steiner Tree(s) in R using igraph.\n\nThe Kou's algorithm can be described like this:\n\n\nFind the complete distance graph G' (G' has V' = S (steiner nodes) , and  for each  pair of nodes (u,v) in VxV there is an edge with weight equal to the weight of the min-cost path between these nodes p_(u,v)  in G) \nFind a minimum spanning tree  T' in G' \nConstruct the subgraph Gs, of G by substituting every edge of T', which is an edge  of G' with the corresponding shortest path of G (it there are several shortest paths, pick an arbitrary one). \nFind the minimal spanning tree, Ts, of Gs (If there are several minimal spanning trees, pick an arbitrary one)\nConstruct a Steiner tree, Th, from Ts by deleting edges in Ts, if necessary, to that all the leaves in Th are Steiner nodes.\n\n\nThe first 2 steps are easy:\n\n```\ng <- erdos.renyi.game(100, 1/10) # graph\nV(g)$name <- 1:100\n\n# Some steiner nodes\nsteiner.points <- sample(1:100, 5)\n\n# Complete distance graph G'\nGi <- graph.full(5)\nV(Gi)$name <- steiner.points\n\n# Find a minimum spanning tree T' in G'\nmst <- minimum.spanning.tree(Gi)\n```\n\n\nHowever, I don't know how to replace the edges in T' for the shortest path in G. I know that with ```\nget.shortest.paths```\n I can get the ```\nvpath```\n from a pair of nodes, but how I replace and edge in T' with the ```\nshortest.path```\n in G?\n\nMany thanks in advance \n    ", "Answer": "\r\nIf I'm understanding the algorithm as you've written it, I think this gets you through step 3, but please clarify if that's not the case:\n\n```\nlibrary(igraph)\n\nset.seed(2002)\n\ng <- erdos.renyi.game(100, 1/10) # graph\nV(g)$name <- as.character(1:100)\n\n## Some steiner nodes:\nsteiner.points <- sample(1:100, 5)\n\n## Complete distance graph G'\nGi <- graph.full(5)\nV(Gi)$name <- steiner.points\n\n## Find a minimum spanning tree T' in G'\nmst <- minimum.spanning.tree(Gi)\n\n##  For each edge in mst, replace with shortest path:\nedge_list <- get.edgelist(mst)\n\nGs <- mst\nfor (n in 1:nrow(edge_list)) {\n    i <- edge_list[n,2]\n    j <- edge_list[n,1]\n    ##  If the edge of T' mst is shared by Gi, then remove the edge from T'\n    ##    and replace with the shortest path between the nodes of g: \n    if (length(E(Gi)[which(V(mst)$name==i) %--% which(V(mst)$name==j)]) == 1) {\n        ##  If edge is present then remove existing edge from the \n        ##    minimum spanning tree:\n        Gs <- Gs - E(Gs)[which(V(mst)$name==i) %--% which(V(mst)$name==j)]\n\n        ##  Next extract the sub-graph from g corresponding to the \n        ##    shortest path and union it with the mst graph:\n        g_sub <- induced.subgraph(g, (get.shortest.paths(g, from=V(g)[i], to=V(g)[j])$vpath[[1]]))\n        Gs <- graph.union(Gs, g_sub, byname=T)\n  }\n}\n\npar(mfrow=c(1,2))\nplot(mst)\nplot(Gs)\n```\n\n\nPlot of minimum spanning tree on the left, replaced with shortest paths on right:\n\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "List all spanning trees with networkx in Python\r\n                \r\nI need a way to get all the spanning trees of a given graph in Python. I'm using networkx, it can get the minimum weight tree, but I need all the possible spanning trees (as a list, or generator, or whatever). Is there a straightforward way to do so?\nEDIT: To clarify, I know it's computationally expensive, I only need it for small graphs (7-10 vertices at most).\n    ", "Answer": "\r\nI ended up writing the following code.\n```\ndef spanning_trees(G):\n        \n        def build_tree(H, edges):\n            if H.is_connected():\n                yield H\n            else:\n                for i in range(len(edges)):\n                    if edges[i][1] not in nx.algorithms.descendants(H, edges[i][0]):\n                        H1 = Graph(H)\n                        H1.add_edge(*edges[i])\n                        for H2 in build_tree(H1, edges[i+1:]):\n                            yield H2\n\n        E = Graph()\n        E.add_nodes_from(G)\n        return build_tree(E, [e for e in G.edges])\n```\n\nIt can handle the complete graph on 8 vertices quite easily, but I'm not an expert in coding, so there is probably some space for optimisation. Any suggestion?\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "MST Clustering using Python\r\n                \r\nI want to make clusters of nodes based on edges of a minimum spanning tree. I used scipy to create minimum spanning tree. The following code:\n\n```\nfile = open('/home/deep/Desktop/Lalit_jee/spanning.txt', 'w')\nimport euc_dist\nimport stan_devia\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import minimum_spanning_tree\nmatrix = euc_dist.euc_matrix\nmatrix1 = matrix\nnew_mat = [[]]\nfor i in range(len(matrix1)):\n    for j in range(len(matrix1)):\n        if j <= i:\n            matrix1[i][j] = 0\nX = csr_matrix(matrix1)\nmin_span = minimum_spanning_tree(X)\nprint >> file, min_span\n```\n\n\nproduced the output as follows: \n\n```\n(0, 2)  3.0\n(0, 9)  2.0\n(1, 8)  3.0\n(1, 9)  4.0\n(2, 3)  15.0\n(3, 7)  2.0\n(4, 5)  6.0\n(4, 8)  3.0\n(6, 7)  36.0\n```\n\n\nwhich indicates a graph as shown in the figure: \n\n! spanning tree  \n\nI took threshold as 4. So now I must have the following output: \n\n! Clusters\n\nIn the case of data, I must have the following: \n\n```\n(0,9)  2.0\n(0,2)  3.0\n(3,7)  2.0\n(8,1)  3.0\n(8,4)  3.0\n(5,5)  0.0\n(6,6)  0.0\n```\n\n\nPlease tell me the most pythonic way to achieve this output.\nThanks in advance... \n    ", "Answer": "\r\nIf loops are not required you can use something like this:\n\n```\n[[i for i in row if i < threshold else 0]\n  for row in min_span.toarray().astype(int)\n]\n```\n\n\nThis will give you resulting matrix as an array\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Which of the following options are correct with respect to a MST?\r\n                \r\nI'm taking the Algorithms: Design and Analysis II course, and one of the questions is as follows:\n\n\n  Consider a connected undirected graph with distinct edge costs. Which\n  of the following are true? [Check all that apply.]\n  \n  \n  Suppose the edge 𝑒 is not the cheapest edge that crosses the cut (𝐴,𝐵). Then 𝑒 does not belong to any minimum spanning tree.\n  Suppose the edge 𝑒 is the most expensive edge contained in the cycle 𝐶. Then 𝑒 does not belong to any minimum spanning tree.\n  The minimum spanning tree is unique.\n  Suppose the edge 𝑒 is the cheapest edge that crosses the cut (𝐴,𝐵). Then 𝑒 belongs to every minimum spanning tree.\n  \n\n\nTo my knowledge, all four options are correct. Options 1, 2 and 4 follow from the Cut property; option 3 is correct because edge weights are distinct. However, including option 1 is turning out to be wrong. Why? \n    ", "Answer": "\r\n\n  \n  No   \n  Yes   \n  Yes   \n  Yes\n  \n\n\nThe main part here is to answer #3. For a graph with all distinct edge costs that is true. Answers for all other questions you can derive using answer to the third one.\n\nFor #1:\n\n```\n A1 --- B1\n        |\n A2 --- B2\n```\n\n\nSuppose ```\nw(A1,B1) > w(A2,B2)```\n, but you still need to include both of them into MST.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "bad result from numpy corrcoef and minimum spanning tree\r\n                \r\nI have this code:\n\n```\nmm = np.array([[1, 4, 7, 8], [2, 2, 8, 4], [1, 13, 1, 5]])\nmm = np.column_stack(mm)\n\nmmCov = np.cov(mm, rowvar=0)\nprint(\"covariance\\n\", mmCov)\n\n# my code to get correlations\nmmResCor = np.zeros(shape=(3, 3))\nfor i in range(len(mmCov)):\n    for j in range(len(mmCov[i])):\n        mmResCor[i][j] = mmCov[i][j] / (math.sqrt(mmCov[i][i] * mmCov[j] [j]))\n\nprint(\"correlaciones a mano\\n\", mmResCor)\n\nmmCor = np.corrcoef(mmCov, rowvar=0)\nprint(\"correlations\\n\", mmCor)\n\nX = csr_matrix(mmCor)\nXX = minimum_spanning_tree(X)\nprint(\"minimun spanning tree\\n\", XX)\n```\n\n\nfirst: each column represents a variable, with observations in the rows\n\nnumpy corrcoef use this relation with covariance matrix:\n\n```\n R_{ij} = \\frac{ C_{ij} } { \\sqrt{ C_{ii} * C_{jj} } }\n```\n\n\nwhen I use numpy corrcoef I get this matrix\n\n```\n correlations\n [[ 1.          0.8660254  -0.82603319]\n [ 0.8660254   1.         -0.99717646]\n [-0.82603319 -0.99717646  1.        ]]\n```\n\n\nbut when I apply \"my code\" to get the same result...\n\n```\nmmResCor = np.zeros(shape=(3, 3))\nfor i in range(len(mmCov)):\nfor j in range(len(mmCov[i])):\n    mmResCor[i][j] = mmCov[i][j] / (math.sqrt(mmCov[i][i] * mmCov[j][j]))\n```\n\n\nI get this matrix\n\n```\n  correlaciones a mano\n  [[ 1.          0.67082039  0.        ]\n  [ 0.67082039  1.         -0.5       ]\n  [ 0.         -0.5         1.        ]]\n```\n\n\nwhy do I get differents results if its suppose I am doing the same?\n\nOne more question:\nWhen I apply minimun_spanning_tree I get this:\n\n```\nminimun spanning tree\n(0, 2)  -0.826033187631\n(1, 2)  -0.997176464953\n```\n\n\nIs there any way to represent these or can I save this result in some variables?\n    ", "Answer": "\r\nThe ```\nnp.corrcoef```\n should take the data as the input. You're passing the covariance matrix as input. If you pass the data, you get the same result as your manual computation:\n\n```\n>>> np.corrcoef(mm, rowvar=0)\narray([[ 1.        ,  0.67082039,  0.        ],\n       [ 0.67082039,  1.        , -0.5       ],\n       [ 0.        , -0.5       ,  1.        ]])\n```\n\n\nRegarding the minimum spanning tree, I'm not sure what your question is, but the output ```\nXX```\n is a sparse matrix which stores a matrix representation of the tree.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "calculating the height of a Minimum spannning tree\r\n                \r\nI need a JAVA code that could help me find the height of the Minimum spanning tree.\nBasically i m looking for an extension of the \nPrim's/Kruskal's algo that not only gives the height of the MST but also gives its height.\n\nThanks in advance. \n    ", "Answer": "\r\nTake as the root vertex one of the tree's centers and calculate the maximal distance from the chosen center to the leaf nodes.\nThe height can the be calculated in the following way:\n\nset the height to 0\nwhile there are at least 3 remaining vertices:\n\ndelete all leaf vertices\nheight := height+1\n\n\nif 2 vertices remain:\n\nheight := height+1\n\n\n\nthe remaining vertices are the centers of the tree.\nThe time complexity is O(n).\nA practical way of calculating the height would be to combine all leaf nodes int a single node that serves as a root, then calculate the MST of that modification and the height as the maximum distance from generated root node to the newly generated leaf nodes.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Is there an O(|V|) algorithm for adding a new node to a minimum spanning tree, given the old minimum spanning tree from a graph?\r\n                \r\nI know that it can be updated in O(|V| + |E|) by using a DFS, but is it possible to update in O(|V|)? \n\nEdit: If this isn't possible, how exactly would an O(|V| + |E|) algorithm work?\n    ", "Answer": "\r\nUpdating Minimum Spanning Tree(MST) of a graph is not limited to connecting the new vertex to the existing MST. It should also be validated that the edges used in the initial MST are still the cheapest possible way to connect all the vertices. In some cases, vk may be such a node that it could overhaul the entire existing MST of a graph G. The new vertex and the edges that come along with it may form a cheaper way to connect the vertices of the graph, and consequently, some(or all) edges in the initial MST may become not the cheapest.\n\nOne such case can be constructed rather easily. Consider the initial graph G=(V={1,2,3}, E={(1, 2), (2, 3), (1, 3)}) in which each edge has the weight of 100. Then introduce a vertex 4, and edges from 4 to each other vertices, each with weight 1. The initial MST of G would have any two of the elements of E, but after the addition of the new node, the MST would be formed by entirely different edges.\n\nPerhaps a clever data structure may yield you a better time complexity than O(|E|), but the need to check the validity(i.e. whether they are still the cheapest way of connecting all the vertices) of each edge of the initial MST as well as the newly added edges implies a time complexity dependent on the size of |E|. It is a valid idea that an initial MST may provide useful information that could help extend it to cover a new vertex with lesser time complexity. However, the definition of MST relies heavily on the graph itself, and updating the graph can possibly invalidate all of the initial MST, rendering the information it indicates regarding the graph useless. As a result, although I haven't exactly provided a mathematical proof here, I do not think there is an O(|V|) algorithm to update an MST when a new node(and edges to it) is added to a graph.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Is there a minimum spanning tree that does not contain the min/max weighted edge?\r\n                \r\nIf we have an (arbitrary) connected undirected graph G, whose edges have distinct weights,\n\n\ndoes every MST of G contains the minimum weighted edge?\nis there an MST of G that does not contain the maximum weighted edge?\n\n\nAlso, I'm more thankful if someone can give a hint of the key things one must keep in mind when dealing with such MST questions.\n\nThis is a homework problem.  Thanks.\n    ", "Answer": "\r\n\n  is there an MST of G that does not contain the maximum weighted edge?\n\n\nThere may be, but there doesn't have to be. Consider a 4-vertex graph as follows:\n\n```\n[A]--{2}--[B]\n |         |\n |         |\n{1}       {3}\n |         |\n |         |\n[C]-{50}--[D]\n```\n\n\nThe minimum spanning tree consists of the edge set {CA, AB, BD}. The maximum edge weight is 50, along {CD}, but it's not part of the MST. But if G were already equal to its own MST, then obviously it would contain its own maximum edge.\n\n\n  does every MST of G contains the minimum weighted edge?\n\n\nYes. MSTs have a cut property. A cut is simply a partition of the vertices of the graph into two disjoint sets. For any cut you can make, if the weight of an edge in that cut is smaller than the weights of the other edges in the cut, then this edge belongs to all MSTs in the graph. Because you guaranteed that the edge weights are distinct, you have also guaranteed that there is an edge which is smaller than all other edges.\n\n\n  Also, I'm more thankful if someone can give a hint of the key things one must keep in mind when dealing with such MST questions.\n\n\nYour best bet is to reason about things using the properties of MSTs in general, and to try to construct specific counterexamples which you think will prove your case. I gave an instance of each line of reasoning above. Because of the cut and cycle properties, you can always determine exactly which edges are in an MST, so you can systematically test each edge to determine whether or not it's in the MST.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Prim's and Kruskal Algorithms in Java\r\n                \r\nI have to implement Prim's and Kruskal's algorithms in Java in order to find minimum spanning tree in a given undirected weighted graph. How can I do that ?  Implementation  must at least achieve O(𝑛2) for Prim’s Algorithm and O(𝑛3) for Kruskal’s Algorithm (n is the number of nodes).\n\n```\npublic class Graph {\n/*The following square matrix represents a weighted undirected graph.\n    the value in (i,j) position indicates the cost between i and j node.\n    Zeros indicate no connection*/\n\n    static int[][] matrix = { { 0, 3, 0, 2, 0, 0, 0, 0, 4 }, // 0\n        { 3, 0, 0, 0, 0, 0, 0, 4, 0 }, // 1\n        { 0, 0, 0, 6, 0, 1, 0, 2, 0 }, // 2\n        { 2, 0, 6, 0, 1, 0, 0, 0, 0 }, // 3\n        { 0, 0, 0, 1, 0, 0, 0, 0, 8 }, // 4\n        { 0, 0, 1, 0, 0, 0, 8, 0, 0 }, // 5\n        { 0, 0, 0, 0, 0, 8, 0, 0, 0 }, // 6\n        { 0, 4, 2, 0, 0, 0, 0, 0, 0 }, // 7\n        { 4, 0, 0, 0, 8, 0, 0, 0, 0 } // 8  \n    };\n    /*  static int[][] matrix = { { 0, 2, 3, 0, 0 }, // 0\n                { 2, 0, 15, 2, 0 }, // 1\n                { 3, 15, 0, 0, 13}, // 2\n                { 0, 2, 0, 0, 9}, // 3\n                { 0, 0, 13, 9, 0}, // 4 }; */\n\nstatic int Node = matrix.length;\nstatic int[][] Edge = new int[Node][Node];\nstatic int NotConnected = 999999;\n\npublic static void MakeGraph() {\n    for (int i = 0; i < Node; i++) {\n        for (int j = 0; j < Node; j++) {\n            Edge[i][j] = matrix[i][j];\n            if (Edge[i][j] == 0)// If Node i and Node j are not connected\n                Edge[i][j] = NotConnected;\n        }\n    }\n    // Print the graph representation matrix.\n    for (int i = 0; i < Node; i++) {\n        for (int j = 0; j < Node; j++)\n            if (Edge[i][j] != NotConnected)\n                System.out.print(\" \" + Edge[i][j] + \" \");\n            else // when there is no connection\n                System.out.print(\" * \");\n        System.out.println();\n    }\n}\n\npublic static void Prim(){\n    System.out.println(\"OUPUT OF PRIM'S ALGORITHM:\");\n    // Write the code for Prim algorithm to find the minimum cost spanning tree here\n    // and print the result in console with the following format:\n    /*==========================OUTPUT FORMAT===========================\n            Minimun Cost of Spanning Tree = \"....... \"       \n\n            Edges of the minimum cost spanning tree:\n            \"..........................................................\"\n            (for example:\n            Edges of the minimum cost spanning tree:\n            \"0 -- 1\n             7 -- 2\n             0 -- 3\n             3 -- 4\n             2 -- 5\n             5 -- 6\n             1 -- 7\n             0 -- 8)\"\n    ================================================================== */\n\n}\n\npublic static void Kruskal(){\n    System.out.println(\"OUPUT OF KRUSKAL'S ALGORITHM:\");\n    // Write the code for Kruskal algorithm to find the minimum cost spanning tree here\n    // and print the result in console with the following format:   \n    /*==========================OUTPUT FORMAT===========================\n            Minimun Cost of Spanning Tree = \"....... \"       \n\n            Edges of the minimum cost spanning tree:\n            \"..........................................................\"\n    ================================================================== */\n}\n\npublic static void  main(String[] args) {\n    MakeGraph();\n    Prim();\n    Kruskal();  \n}\n\n}\n```\n\n    ", "Answer": "\r\nHere is my implementation:\n\n```\npublic class Library {\n// Add the missing implementation to this class \n\n    java.util.ArrayList<Book> books;\n\n    private static String openingHours = \"The Library is open every day from 9AM to 5PM\";\n    private String a  ddress = \"\";\n    private String[] collection = new String[10];\n    private int collectionCount = 0;\n\n    public Library(String libraries) {\n        address = libraries;\n        books = new java.util.ArrayList<>();\n    }\n\n    public\n            String getAddress() {\n        return this.address;\n    }\n\n    void setaddress(String address) {\n        this.address = address;\n    }\n\n    public static void printOpeningHours() {\n        System.out.println(\"Library Hours: \");\n        System.out.println(openingHours);\n    }\n\n    public void printAddress() {\n        System.out.println(address);\n    }\n\n    public void addBook(Book book) {\n        books.add(book);\n    }\n\n    public void printAvailableBooks() {\n        boolean bookPresent = false;\n        for (Book book : books) {\n            if (!book.isBorrowed()) {\n                System.out.println(book.getTitle());\n                bookPresent = true;\n            }\n        }\n        if (!bookPresent) {\n            System.out.println(\"No such book in our catalog\");\n        }\n    }\n\n    private void borrowBook(String title) {\n        int found = 0;\n        for (Book book : books) {\n            if (book.getTitle().equals(title)) {\n                if (found == 0) {\n                    found = 1;\n                }\n                if (!book.isBorrowed()) {\n                    book.borrowed();\n                    found = 2;\n                    break;\n                };\n            }\n        }\n        if (found == 0) {\n            System.out.println(\"Sorry, this book is not in our catalog.\");\n        } else if (found == 1) {\n            System.out.println(\"Sorry, this book is already borrowed.\");\n        } else if (found == 2) {\n            System.out.println(\"You successfully borrowed \" + title);\n        }\n    }\n\n    public void returnBook(String title) {\n        boolean found = false;\n        for (Book book : books) {\n            if (book.getTitle().equals(title) && book.isBorrowed()) {\n                book.returned();\n                found = true;\n                break;\n            }\n        }\n        if (found) {\n            System.out.println(\"You successfully returned \" + title);\n        }\n    }\n\n    public static void main(String[] args) {\n        Library firstLibrary = new Library(\"Moylish Park, Limerick\");\n        Library secondLibrary = new Library(\"Clare Street, Limerick\");\n        Library thirdLibrary = new Library(\"Nenagh Road, Thurles\");\n\n        // Add four books to the first library\n        firstLibrary.addBook(new Book(\"Java How To Program\"));\n        firstLibrary.addBook(new Book(\"What's new in Java 7?\"));\n        firstLibrary.addBook(new Book(\"Java in a nutshell\"));\n        firstLibrary.addBook(new Book(\"Pro Android 2\"));\n\n        // Print Opening hours and the addresses\n        Library.printOpeningHours();\n        System.out.println();\n        System.out.println(\"Library Addresses: \");\n        firstLibrary.printAddress();\n        secondLibrary.printAddress();\n        thirdLibrary.printAddress();\n        System.out.println();\n\n        // Print the titles of all available books from both libraries\n        System.out.println(\"Books available in the first library:\");\n        firstLibrary.printAvailableBooks();\n        System.out.println();\n        System.out.println(\"Books available in the second library:\");\n        secondLibrary.printAvailableBooks();\n        System.out.println();\n        System.out.println(\"Books available in the third library:\");\n        thirdLibrary.printAvailableBooks();\n        System.out.println();\n\n        // Return Java How To Program \n        System.out.println(\"Returning Java How To Program\");\n        firstLibrary.returnBook(\"Java How To Program\");\n        System.out.println();\n\n        // Print the titles of available from the first library\n        System.out.println(\"Books available in the first library:\");\n        firstLibrary.printAvailableBooks();\n    }\n}\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "What does π[v] ←u step mean in Prims algorithm for minimum spanning tree?\r\n                \r\nIn this MIT video regarding Prims algorithm for minimum spanniing tree the professor explains ```\nπ[v] ←u```\n at time 71:16 seconds . But I do not understand why we need this step . What does this notation  ```\nπ[v] ←u```\n mean actually ? Also what does the last line in the algorithm that follows mean ?\nThe entire algorithm given in the source is as follows :\n\n```\nQ←V\nkey[v] ←∞for all v∈V\nkey[s] ←0for some arbitrary s∈V\nwhile Q≠∅\n do u←EXTRACT-MIN(Q)\n   foreach v∈Adj[u]\n    do ifv∈Qand w(u, v) < key[v]\n      then key[v] ←w(u, v)⊳DECREASE-KEY\n           π[v] ←u\n\nAt the end, {(v, π[v])}forms the MST\n```\n\n    ", "Answer": "\r\n```\nπ```\n is just any old array variable. So this line of code isn’t really different from the other assignments.\n\nWhat it does in the algorithm however is save the predecessor node of the current node. ```\nπ```\n is sometimes also called the predecessor function because for any given node ```\nn```\n, ```\nπ[n]```\n gives you the predecessor of that node (after the algorithm has completed).\n\nSo ```\nπ```\n can be used to reconstruct the path (= the edges of the spanning tree) found by Prim’s algorithm.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Finding a spanning tree using exactly k red edges in a graph with edges colored by red/blue in linear time\r\n                \r\nGiven a graph G with red and blue edges and a constant K, devise a deterministic, linear time algorithm that finds a spanning tree of G with exactly K red edges (or returns ```\nFalse```\n if such a spanning tree does not exist).\n\nWhat we have done so far:\n\nLet every red edge have weight of -1 and every blue edge have weight of 0.\n\nFind a minimum spanning tree (using a standard linear time algorithm). So, we have a spanning tree T with minimal weight, meaning we used as many red edges as we can because red edges will only decrease the weight.\n\nIf there are less than K red edges in T, we return ```\nFalse```\n.\n\nIf there are exactly K red edges, we are done, T is the answer.\n\nIf there are more than K red edges, we need to replace them with blue ones.\n\nThis is our problem, how do we do that in linear time?\n\nEvery blue edge added will create a cycle, so removing one red edge from the cycle will work but how can we ensue linearity in this way? Is this even a good approach?\n    ", "Answer": "\r\nHINTS\n\nYou can do this in linear time using two passes of Prim's algorithm.  (Usually Prim's algorithm is not linear time, but when you only have two types of edge you do not need to spend time sorting edges).\n\nPass 1\n\nIn the first pass follow blue edges before red edges and mark any red edges that you are forced to take.\n\nIf you mark C edges in this process then we know that there must be at least C red edges in any spanning tree solution, so if C>K, it is impossible.\n\nPass 2\n\nSuppose we have found C ( < K ) marked edges in the first pass.\n\nIn the second pass follow red edges before blue, until the total number of additional red edges reaches K-C.  In the second pass you are also allowed to follow the red edges marked in the first pass (and these do not count towards your total).\n\nIf your additional red edges does not reach K-C then it is impossible.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Find minimum weighted spanning tree in Neo4j graph\r\n                \r\nI have drawn a graph in neo4j which have following nodes:\n\n\nDriver\nSchool\nStudents\n\n\nWhich have following conditions:\n\n\nA driver is connected to all students by 'connects' relationship with 'distance' as attribute\nEach Student is connected to each other by same 'connects' relationship with same 'distance' attribute\nEach Student is also connected on one School by same 'connects' relationship with same 'distance' attribute\n\n\nNow I want to get the minimum path that driver will cover to reach to school with N number students. For that, I am using neo4j predefined procedures(Algorithms):\n\n```\nMATCH (n:Driver{name:\"Driver2\"}),(s:student),(sc:school),(n)-[c:connects]->\n(s),(s)-[d:connects]->(sc) CALL \nalgo.spanningTree.minimum('students','connects','distance',ID(n)) YIELD \nloadMillis, computeMillis, writeMillis, effectiveNodeCount\nRETURN loadMillis, computeMillis, writeMillis, effectiveNodeCount\n```\n\n\nwhich gives result like this:\n\n```\n[\n{\n\"keys\": [\n  \"loadMillis\",\n  \"computeMillis\",\n  \"writeMillis\",\n  \"effectiveNodeCount\"\n],\n\"length\": 4,\n\"_fields\": [\n  {\n    \"low\": 5,\n    \"high\": 0\n  },\n  {\n    \"low\": 1,\n    \"high\": 0\n  },\n  {\n    \"low\": 0,\n    \"high\": 0\n  },\n  {\n    \"low\": 1,\n    \"high\": 0\n  }\n],\n\"_fieldLookup\": {\n  \"loadMillis\": 0,\n  \"computeMillis\": 1,\n  \"writeMillis\": 2,\n  \"effectiveNodeCount\": 3\n}\n},\n{\n\"keys\": [\n  \"loadMillis\",\n  \"computeMillis\",\n  \"writeMillis\",\n  \"effectiveNodeCount\"\n ],\n\"length\": 4,\n\"_fields\": [\n  {\n    \"low\": 5,\n    \"high\": 0\n  },\n  {\n    \"low\": 0,\n    \"high\": 0\n  },\n  {\n    \"low\": 0,\n    \"high\": 0\n  },\n  {\n    \"low\": 1,\n    \"high\": 0\n  }\n],\n\"_fieldLookup\": {\n  \"loadMillis\": 0,\n  \"computeMillis\": 1,\n  \"writeMillis\": 2,\n  \"effectiveNodeCount\": 3\n }\n},\n{\n\"keys\": [\n  \"loadMillis\",\n  \"computeMillis\",\n  \"writeMillis\",\n  \"effectiveNodeCount\"\n],\n\"length\": 4,\n\"_fields\": [\n  {\n    \"low\": 4,\n    \"high\": 0\n  },\n  {\n    \"low\": 0,\n    \"high\": 0\n  },\n  {\n    \"low\": 0,\n    \"high\": 0\n  },\n  {\n    \"low\": 1,\n    \"high\": 0\n  }\n ],\n \"_fieldLookup\": {\n  \"loadMillis\": 0,\n  \"computeMillis\": 1,\n  \"writeMillis\": 2,\n  \"effectiveNodeCount\": 3\n }\n},\n{\n\"keys\": [\n  \"loadMillis\",\n  \"computeMillis\",\n  \"writeMillis\",\n  \"effectiveNodeCount\"\n],\n\"length\": 4,\n\"_fields\": [\n  {\n    \"low\": 4,\n    \"high\": 0\n  },\n  {\n    \"low\": 0,\n    \"high\": 0\n  },\n  {\n    \"low\": 0,\n    \"high\": 0\n  },\n  {\n    \"low\": 1,\n    \"high\": 0\n  }\n],\n\"_fieldLookup\": {\n  \"loadMillis\": 0,\n  \"computeMillis\": 1,\n  \"writeMillis\": 2,\n  \"effectiveNodeCount\": 3\n}\n}\n]\n```\n\n\nMY QUESTION IS: How to interpret this data? and if it not the right way then which Neo4j procedure(algo) should i use?\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Guarantee about edge not being part of a minimum spanning tree\r\n                \r\nI was solving exercises from the Algorithm Design book by Kleinberg and Tardos and came across this not-so-easy (to me) problem on finding a guarantee that an edge will never belong to the MST of a graph. The question goes like this:\n\nYou are given a graph G = (V, E) with cost c_e on each edge e. Given error parameters epsilon and k (both > 0), you would like to ascertain whether the following property (*) holds for a particular edge e' = (u, v) in polynomial time.\n\n(*) Even if the cost of each edge were to be changed by at most epsilon (either increased or decreased), and the costs of k edges other than e' were further changed to some arbitrary different values, the edge e' would still not belong to any MST of G.\n\nI know  the cut property for MST's but cannot see how that can be applied to this problem. Thanks for your ideas in advance! \n    ", "Answer": "\r\nEventually reached an answer thanks to j_random_hacker's comments.\n\nThe answer basically uses the cycle properties of an MST - if an edge is the most expensive edge in a cycle in G, it cannot belong to any MST of G.\n\nThe provision for changing the costs of k edges to arbitrary values implies that we must show that e' is the most expensive edge in at least k+1 cycles which are all edge-disjoint except for e' itself. This way, even if the arbitrary change of k edges causes e' to not be the most expensive in k cycles, it will still be the most expensive in the last cycle.\n\nGiven a graph G, edge e' and parameters k and epsilon (both > 0):\n\n\nTemporarily delete all edges in G more expensive than e' (this ensures that e' is the most expensive in whichever cycles we find)\nNow, set one end of e' to be a source (s) and the other end to be a sink (t). Set capacities of all edges to be 1. Flow integrality ensures that since all capacities are integers, we will get an integral flow.\nSee if you get a flow of value at least k+1. If yes, flow decomposition will give you as many edge-disjoint paths from s to t as the value of flow. Convert all these paths to cycles by adding e' to them - this way you have k+1 (or more) cycles in which e' is the most expensive edge and which are all edge-disjoint except for e'. You can now safely say that property (*) holds for e'.\n\n\nI have a way to deal with epsilon if it is an integer. In step 1, delete all edges that are more expensive than cost(e) + 2*epsilon.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Java: Prim's with Fibonacci heap? (JGraphT)\r\n                \r\nJGraphT has a nice Fibonacci Heap class. How can I use it to implement Prim's minimum spanning tree algorithm?\n    ", "Answer": "\r\nYou'd have to write a wrapper class to rename the methods, since (from a cursory look through the JGraphT Javadocs) it doesn't looks like these developers implemented the Queue interface. So you have to write a method called offer that just calls insert, and so on. (Since this is open-source, you should consider making your edits right in the class itself, and sending the project your code when you're done.)\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Creating several minimum spanning trees with specific requirements\r\n                \r\nI have an undirected graph that contains several nodes of type A and some nodes of type B. I need to create a graph (not necessarily connected globally) such that each type A node is connected (through any number of edges) to at least one type B node. All edges have weights. I want to create an MST that fulfills this condition, but I cannot think of the best algorithm to do that. \n\nLet me clarify.  If I have one type B node, then all I need to do is just create an MST normally.  But since I have more than one type B node, there may be a more efficient way to create an MST that will not require me to connect all the vertices in the graph.  For example, I may choose to ignore a type B node if it's not the cheapest connection to any type A node.  In the end, I may well have a graph that has several disconnected MSTs, not just one.\n\nWhat is the best algorithm for doing this?\n    ", "Answer": "\r\nIterate through this process:\n\n\nFind the least expensive connection to connect a type A node to a type B node.\nChange that A-node's label to type B.\nRepeat until there are no more A nodes.\n\n\nNote one important property of your problem: any minimal solution must have each A node connected to exactly one B node.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Adding cycles to a Minimum Spanning Tree without moving the points?\r\n                \r\nI am generating a dungeon layout for a video game. I have created the rooms, spaced them out using seperation steering, and created a fully connected weighted, undirected graph of the rooms. Then I calculated a MST using Prim's Algorithm, all using GML (GameMaker Language). I miss Python.\n\nMy intention is to add additional edges to reintroduce loops, so a player does not have to always return along a path, and to make layouts more interesting. The problem is, these edges cannot cross, and I would prefer not to have to move the points around. I had been given a recommendation to use Delaunay Triangulation, but if I am honest this is completely over my head, and may not be a viable solution in GML. I am asking for any suggestions on algorithms that I could use to identify edges that I could add that do not intersect previously created edges.\n\nI have included an image of the MST (the lines connect to the corners of the red markers, even if the image shows they stop short)\n\n\n    ", "Answer": "\r\nIf I'm understanding your question correctly, we're looking at more of a geometry problem than a graph theory problem. You have existing points and line segments with concrete locations in 2d space, and you want to add new line segments that will not intersect existing line segments.\nFor checking whether you can connect two nodes, node1 and node2, you can iterate through all existing edges and see whether the line segment node1---node2 would intersect the line segment edge.endpoint1 --- edge.endpoint2. The key function that checks whether two line segments intersect can be implemented with any of the solutions found here: How can I check if two segments intersect?.\nThat would take O(E) time and look something like\n```\ndef canAddEdge(node1, node2):\n    canAdd = True\n    for edge in graph:\n        canAdd = canAdd and not doesIntersect([node1.location(),\n          node2.location(), edge.endpoint1.location(), edge.endpoint2.location()])\n      \n```\n\nAnd you can get a list of valid edges to add in O(EV^2) with something like\n```\ndef getListOfValidEdges(graph):\n    validEdges = []\n    for index,firstEndpointNode in enumerate(graph.nodes()):\n        for secondEndpointNode in graph.nodes()[index:]:\n            if (canAddEdge(firstEndpointNode, secondEndpointNode)):\n                validEdges.append([firstEndpointNode, secondEndpointNode])\n    return validEdges\n```\n\nOf course, you would need to recalculate the valid edges every time after adding a new edge.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Networkx: change the color of edges conditionally\r\n                \r\nSuppose I have a DiGraph ```\nDG```\n that represents a minimum spanning tree just like the following. I would like to change the color of edges based on one condition.\n\n```\ncc = [('8k3aO-mPeyhbR5HUucA5aA', 'Hi10sGSZNxQH3NLyWSZ1oA'),\n      ('8k3aO-mPeyhbR5HUucA5aA', 'bLbSNkLggFnqwNNzzq-Ijw'),\n      ('8k3aO-mPeyhbR5HUucA5aA', 'nmdkHL2JKFx55T3nq5VziA'),\n      ('8k3aO-mPeyhbR5HUucA5aA', '_BcWyKQL16ndpBdggh2kNA'), \n      ('8k3aO-mPeyhbR5HUucA5aA', 'CQUDh80m48xnzUkx-X5NAw'),\n      ('8k3aO-mPeyhbR5HUucA5aA', 'wZPizeBxMAyOSl0M0zuCjg'),\n      ('8k3aO-mPeyhbR5HUucA5aA', 'hWDybu_KvYLSdEFzGrniTw'),\n      ('8k3aO-mPeyhbR5HUucA5aA', 'kS1MQHYwIfD0462PE61IBw'),\n      ('8k3aO-mPeyhbR5HUucA5aA', 'HFECrzYDpgbS5EmTBtj2zQ'),\n      ('RtGqdDBvvBCjcu5dUqwfzA', 'Xwnf20FKuikiHcSpcEbpKQ'),\n      ('RtGqdDBvvBCjcu5dUqwfzA', 'bLbSNkLggFnqwNNzzq-Ijw'),\n      ('RtGqdDBvvBCjcu5dUqwfzA', 'WG3w_73scm_JUWJ_3Lgn0Q'),\n      ('P5bUL3Engv-2z6kKohB6qQ', 'Hi10sGSZNxQH3NLyWSZ1oA'),\n      ('P5bUL3Engv-2z6kKohB6qQ', 'nzsv-p1O8gCfP3XijfQrIw'),\n      ('P5bUL3Engv-2z6kKohB6qQ', 'm07sy7eLtOjVdZ8oN9JKag'),\n      ('hWDybu_KvYLSdEFzGrniTw', 'U4INQZOPSUaj8hMjLlZ3KA'),\n      ('8RcEwGrFIgkt9WQ35E6SnQ', 'wZPizeBxMAyOSl0M0zuCjg'),\n      ('Xwnf20FKuikiHcSpcEbpKQ', 'CxDOIDnH8gp9KXzpBHJYXw'),\n      ('HFECrzYDpgbS5EmTBtj2zQ', 'Xj0O2l0bp633ebmG468aZw'),\n      ('XYSDrIef7g4Gmp3lNFVO6A', 'wZPizeBxMAyOSl0M0zuCjg'),\n      ('wZPizeBxMAyOSl0M0zuCjg', 'syvwUKQJ4OYfmL_ixVLMeQ')]\n      DG = nx.DiGraph()\n      DG.add_edges_from(cc)\n      pos = nx.spring_layout(DG)\n      plt.figure(figsize=(20,20))\n      nx.draw(DG, pos = pos,  arrows = False,\n      node_color = 'black', width = 0.7, alpha = 0.9)\n```\n\n\nNotice that it is a graph of a minimum spanning tree. I want to color the edge between a node with 2 degrees and its succeeding node blue. For example, the edge color of ```\n('HFECrzYDpgbS5EmTBtj2zQ', 'Xj0O2l0bp633ebmG468aZw')```\n should be in blue. Could anyone help me out?\n\n\n    ", "Answer": "\r\nYou need to pass a list of colors to the ```\nedge_color```\n parameter of your ```\nnx.draw()```\n method. Now, one way to create the list, given an if-else conditional, is as follows:\n\n```\nedge_colors = ['color1' if your_condition else 'color2' for e in G.edges]\n```\n\n\nHere, ```\ne```\n is the an edge, which in NetworkX v2.1, is just a tuple ```\n(node1, node2)```\n. You can use the edge itself or each node in the tuple for conditioning.\n\nIn your specific case (if I understood you correctly), it would be:\n\n```\nedge_colors = ['blue' if DG.degree[e[0]] == 2 else 'black' for e in DG.edges]\n```\n\n\nThen, you just pass this to the ```\nedge_color```\n parameter. In your case:\n\n```\nnx.draw(DG, pos=pos,  arrows=False, edge_color=edge_colors, node_color='black', width=0.7, alpha=0.9)\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Cycle detection in Prim's Algorithm\r\n                \r\nWhy don't we check for the cycle in prim's algorithm like in Kruskal's algorithm to find the minimum spanning tree?\n    ", "Answer": "\r\nIn Prim's algorithm\n\nEach step adds to the tree A a light edge that connects A to an isolated vertex—one on which no edge of A is incident.\n\nSource: page 634 of CLRS.\nSo we don't need to detect cycles while forming the minimum spanning tree like we do in Kruskal’s Algorithm using a disjoint set data structure.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "True or False: For an undirected graph, for every vertex, its edge with minimum weight is in a minimum spanning tree\r\n                \r\nI think this is true. With consideration to Prim's algorithm, the minimum edge of a vertex is either already in a tree, or will be selected eventually.\nI also tried a lot of graph and they all seem correct.\nIf this statement is False, can someone give me a counter-example?\nThanks.\n    ", "Answer": "\r\nYour proof is almost there.\nProof 1: Prim's algorithm can start at any vertex, and will immediately select the start vertex's minimum edge, or can select any minimum edge if there is a tie.\nProof 2: In Kruskal's algorithm, one of every vertex's minimum edges will be the first to connect that vertex, and it could be any one of them, if there's a tie, depending on the initial sort.\nProof 2 actually proves a stronger theorem: Every minimum spanning tree will include a minimum edge for every vertex.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Getting stuck and running out of nodes in Prim's algorithm?\r\n                \r\nSo I have this graph\n\n\n\nand I'm trying to build its minimum spanning tree. Starting at vertex A I go A-B-F-E-D and after that there's no place to go, considering that all the adjacent vertexes to D are already part of the tree, how do I keep going?\n\nAlso how do I calculate the range of values of a new edge to be part of the minimum spanning tree?\n\nThanks in advance guys.\n    ", "Answer": "\r\nI think that you have a slight misunderstanding of how Prim's algorithm works. Based on the description that you gave above, it looks like you think Prim's algorithm works like this:\n\n\nStart at any node.\nLook at all the nodes connected to the current node that you haven't already visited.\nGo to the cheapest of these nodes.\nRepeat until all nodes are covered.\n\n\nThis is close to how Prim's algorithm works, but it's not exactly right. In Prim's algorithm, there's no notion of a \"current\" node. Instead, you have two sets of nodes: nodes you've added in, and nodes you haven't. Prim's algorithm then works like this:\n\n\nStart at any node. Add it to the \"in\" set.\nLook at all the nodes connected to the \"in\" set that haven't already been added to the \"in\" set.\nAdd the cheapest of these nodes to the \"in\" set.\nRepeat until all nodes are in the \"in\" set.\n\n\nIn the graph that you gave above, you started at node A. Following the algorithm, we look at all nodes connected to A and take the cheapest (B) and add it to the \"in\" set. The \"in\" set now contains A and B.\n\nNow, we look at all the nodes connected to anything in the \"in\" set. Those are the nodes D, F, E, and H. Of those, the cheapest is H, so we add H to our \"in\" set, which is now A, B, and H.\n\nWe again look at all the nodes connected to anything in the \"in\" set. Those are the nodes D, F, E, I, and G. The cheapest of these is F, so we add that in.\n\nIf you repeat this process until all nodes are added, and you keep track of which edges you added in the course of doing so, you'll end up with a minimum spanning tree for the overall graph.\n\nHope this helps!\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Python multiprocessing min span tree - entire program loops\r\n                \r\nI am trying to use multiprocessing in Python to speed up a minimum spanning tree algorithm for a large amount of data. The tree is using Prim's method. In short I have a program that creates a weighted matrix for each category and then enters the routine to make the min span tree, inside this routine I have this code\n\n```\n if __name__=='__main__':\n        m=Manager()\n        q=Queue()\n        #wt=partial(_lightest_edge_weight, graph=graph, visited=visited)\n        p=Pool()\n        #go to each visited edge\n        for each in visited:\n            q.put(each)\n        q.put('DONE')\n        #set up multiprocessing for edges in queue\n        p.apply_async(target=_lightest_edge_weight, args=(graph,visited,q,))\n```\n\n\nHowever, whenever I do this (and I have tried using Process plus start and join as well) the new processes that open up restart the entire program instead of just running the items in the queue against ```\n_lightest_edge_weight```\n. Any ideas while the whole program loops instead of just the target subroutine? Thanks.\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Finding MST with Prim's Algorithm Java\r\n                \r\nCurrently I am trying to find the minimum spanning tree using Prim's algorithm. I have a program created that creates a Weighted matrix that I need to use. My new program should take the WeightedGraph and return a list/array of the edges based on the indices. My question is how would I go about finding the minimum spanning tree using this function -- public int[][] prim(WeightedGraph graph) { --\n\n```\npackage WeightGraph;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class WeightedGraph {\n\n    private int[][] weightMatrix;\n    private int size;\n    private String[] nodes;\n\n    public WeightedGraph(String filename){\n\n\n        try {\n            Scanner sc = new Scanner(new File(filename));\n\n            String line = sc.nextLine();\n            nodes = line.split(\",\");\n            size = nodes.length;\n\n            weightMatrix = new int[size][size];  \n\n            // fill matrix\n            for(int i=0;i<size;i++) {\n                for(int j=0;j<size;j++){\n                    if(i == j){\n                        weightMatrix[i][j] = 0;\n                    }\n                    else {\n                        weightMatrix[i][j] = -1;\n                    }\n                }\n            }\n            while(sc.hasNext()){\n                String let1 = sc.nextLine();\n                String[] entryNum = let1.split(\",\");\n                String lett1 = entryNum[0];\n                String lett2 = entryNum[1];\n                int letter1 = Arrays.asList(nodes).indexOf(lett1);\n                int letter2 = Arrays.asList(nodes).indexOf(lett2);\n                int weight = Integer.parseInt(entryNum[2]);\n                weightMatrix[letter1][letter2] = weight;\n                weightMatrix[letter2][letter1] = weight;\n            }\n        }\n        catch(Exception FileNotFoundException)\n        {\n           System.out.println(\"File Not Found\");\n        }\n    }\n\n    public int getDistance(int i,int k)\n    {\n       if(i>=0 && i<size && k>=0 && k<size)\n           return weightMatrix[i][k];\n       else return -1;\n    }\n\n    public boolean directLink(int i,int k)\n    {\n        if(i>=0 && i<size && k>=0 && k<size)\n            return (weightMatrix[i][k]!=-1);\n        else return false;\n    }\n\n    public int getSize()\n    {\n       return size;\n    }\n\n    public String getNodeName(int i) {\n        return nodes[i];\n    }\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "From a matrix of distances to a matrix of adjacency\r\n                \r\nI have a matrix of distances 1024x1024 with all the couple of distances between all the terms. I want to define a graph starting from that. So I defined a minimum spanning tree and I computed the matrix of adjacency on that.\n\nMy matrix of distances is ```\ndistMat```\n.\n\n```\nmatrix_of_distances <- as.matrix(distMat)\nmyGraph <- graph.adjacency(matrix_of_distances, weighted=TRUE)\n```\n\n\nMy graph is a graph with all the possible arcs (because the distances between all the couple of terms are a finite value). I need another graph, sparser:\n\n```\nmst <- as.undirected(minimum.spanning.tree(myGraph))\n```\n\n\nFrom that sparse graph I can compute the matrix of adjacency with:\n\n```\nadjacency <- as_adjacency_matrix(mst, type = c(\"both\", \"upper\", \"lower\"), attr = NULL, edges = FALSE, names = TRUE, sparse =igraph_opt(\"sparsematrices\"))\n```\n\n\nNow I want to create the matrix adjacency differently, passing another minimum spanning tree object. Suppose I have created another spanning tree:\n\n```\nspt <- spantree(matrix_of_distances)\n```\n\n\nIf I do:\n\n```\nadjacency <- as_adjacency_matrix(spt, type = c(\"both\", \"upper\", \"lower\"), attr = NULL, edges = FALSE, names = TRUE, sparse =igraph_opt(\"sparsematrices\"))\n```\n\n\nI get the error:\n\n\n  Error in as_adjacency_matrix(spt, type = c(\"both\", \"upper\", \"lower\"), \n  :    Not a graph object\n\n\nAgain, I'm trying to generate a matrix of adjacency from a minimum spanning tree. How can I solve that? \n    ", "Answer": "\r\nThe error comes from your using function ```\nas_adjacency_matrix```\n on an object of class ```\nspantree```\n when it expects an ```\nigraph```\n.\n\nSince you are using ```\nigraph```\n, one simple solution would be to compute the minimum spanning tree from your original \"distance graph\" with ```\nigraph```\n's function ```\nmst```\n. \n\nHere is how ```\nspantree```\n computes the minimum spanning tree:\n\n```\nrequire(vegan)\ndata(dune)\ndis <- vegdist(dune)\ntr <- spantree(dis)\n```\n\n\nThe result is the following tree (```\nplot(tr, type=\"t\")```\n)\n\n:\n\nYou could get the same result only with ```\nigraph```\n functions:\n\n```\nlibrary(igraph)\ng  <- graph.adjacency(as.matrix(dis), weighted=TRUE)\ng_mst <- mst(g)\n```\n\n\nAnd the resulting tree looks like this (```\nplot(g_mst, vertex.color=NA, vertex.size=10, edge.arrow.size=0.5)```\n):\n\n\n\nOnce you have your ```\nigraph```\n tree, you already know that you can transform it into an adjacency matrix with function ```\nas_adjacency_matrix```\n:\n\n```\nA <- as_adjacency_matrix(mst)\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "find minimum spanning tree using depth first search in C\r\n                \r\nI'm trying to implement an algorithm in c which finds MST using DFS. I've already found the DFS algortihm and i understand it pretty well. I also know that i should follow these steps to achieve my purpose :\n\n1 Run DFS till you find an edge going backwards or DFS stopped. If stopped return G.\n\n2 On the circle that is constructed by the backwards going edge find the heaviest edge and remove it from G.\n\n3 Return to 1.\n\nHere is the DFS code :\n\n```\n#include<stdio.h>\nvoid DFS(int);\nint G[10][10],visited[10],n;    //n is no of vertices and graph is sorted in array G[10][10]\nvoid main()\n{\n    int i,j;\n\nprintf(\"Enter number of vertices:\");\nscanf(\"%d\",&n);\n\n    //read the adjecency matrix\n    printf(\"\\nEnter adjecency matrix of the graph:\");\n    for(i=0;i<n;i++)\n        for(j=0;j<n;j++)\n            fscanf(\"%d\",&G[i][j]);\n\n    //visited is initialized to zero\n    for(i=0;i<n;i++)\n        visited[i]=0;\n\n    DFS(0);\n}\nvoid DFS(int i)\n{\n    int j;\nprintf(\"\\n%d\",i);\nvisited[i]=1; // éviter cycle\nfor(j=0;j<n;j++)\n    if(!visited[j]&&G[i][j]==1)\n        DFS(j);\n}\n```\n\n\nI need your help to implement the full algorithm or at least some advices. That would be much appreciated. Thank's in advance.\n    ", "Answer": "\r\nThis sounds like homework, so I'll tell you how I would approach the problem.\n\nFirst, modify your DFS implementation to use an explicit stack instead of recursion. Create a new array ```\nint stack[10];```\n and a variable ```\nint stacksize = 0;```\n. The idea is that ```\nstack[0], stack[1], ..., stack[stacksize-1]```\n will correspond to the arguments ```\ni```\n of the outermost active invocation of ```\nDFS```\n to the innermost. I'll leave the details a bit sketchy because I'm sure that there have been other question/answer pairs about this aspect.\n\nSecond, whenever the graph has an edge back to a visited vertex, scan from the top of the stack back to the visited vertex, looking for the heaviest edge. Once you find it, delete that edge by modifying ```\nG```\n. To restart the depth-first search, pop the stack until you pop one of the endpoints of the deleted edge. Each time you pop something, clear its visited flag. The depth-first search continues from here (a complete restart is not necessary because it would do the same thing up to here).\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Given an undirected graph, is it possible to find a spanning tree of minimum height?\r\n                \r\nThis was a question my professor asked in class and I'm a bit confused.\n\nI was thinking of just traversing the graph to obtain a tree. Then, to determine the minimum height, take each vertex of the tree as the root, and compare heights. This is a brute force method though, and am thinking of a more elegant solution.\n\nI found this website http://buttercola.blogspot.com/2016/01/leetcode-minimum-height-trees.html explaining how they obtained a minimum height tree using something similar to BFS topological sort. \n\nAccording to the OP, we take two pointers and point them at vertex of degree 1 (leaves), and we have them move at the same speed. When the two meet, we find the root. But this confuses me because how can we ensure that we've picked the correct leaf (what if there's one with a longer path?)\n\nIf anyone can help me understand this more, that would be greatly appreciated.\n    ", "Answer": "\r\nHe didn't stop after 2 two pointers meet. He kept one of them, which now points to an internal node (which may be root). Then selects two completely new leaf pointers, but before I proceed any further, you need to understand how that \"BFS Topological sort\" thing works.\n\nDespite the hard name, it's actually very simple. If our answer tree have height ```\nh```\n, we find all the leaves and delete them. Which turns every internal node at depth ```\nh-1```\n into new leaves. We delete them again, which produces new leaves at ```\nh-2```\n and so on unless we reach height 0, which gives us our root(s).\n\nSo when those two pointers met in a node, it's either root, or an internal node that will become leaf in future. In that case, at some point in future, it will partner with another node of same height for above procedure, and lead us to root, or maybe another internal node which then will.......\n\nMy advice, forget this two pointers thing entirely. It was done to draw parallel to that \"path Graph\" example, but which in said tutorial only adds confusion to an otherwise simple concept.\n\nBut while thinking about it, I stumbled upon another algorithm which I believe to be even simpler than that \"BFS Topological sort\" thing (at least implementation-wise). Choose any node as root, do a post-order traversal to find all of it's children's heights. Say our root has 3 childs with heights ```\n[2,3,8]```\n. Think what happens if we transfer \"root-ship\" to the ```\n8```\n. All of it's past children has height < 8. And the new one i.e our current root has height 4 (2nd highest = 3,plus one). So, overall height is now 8. (Or lower, we can find that by repeating what we did to our root now for ```\n8```\n, recursively.) \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Compute ALL spanning trees of a directed acyclic graph using igraph, network, or other R package\r\n                \r\nI want to compute the complete set of spanning trees for a graph. The graphs I'm working with are small (usually less than 10 nodes).\nI see functionality for computing the minimum spanning tree with ```\nigraph```\n:\n```\nlibrary(igraph)\ng <- sample_gnp(100, 3/100)\ng_mst <- mst(g)\n```\n\nand I see a previous StackOverflow post that described how to compute a spanning tree using a breadth-first search. The code below is adapted from the accepted answer:\n```\nr <- graph.bfs(g, root=1, neimode='all', order = TRUE, father = TRUE)\nh <- graph(rbind(r$order, r$father[r$order, na_ok = TRUE])[,-1], directed = FALSE)\n```\n\nHowever, I don't know how to adapt this to compute multiple spanning trees. How would one adapt this code to compute all spanning trees? I'm thinking that one piece of this would be to loop through each node to use as the \"root\" of each tree, but I don't think that takes me all the way there (since there could still be multiple spanning trees associated with a given root node).\nEDIT\nThe end-goal is to compute the distortion of a graph, which is defined as follows (link, see page 5):\n\nConsider any spanning tree T on a graph G, and compute the average distance t = E[HT] on T between any two nodes that share a link in G.  The distortion measures how T distorts links in G, i.e.  it measures how many extra hops are required to go from one side of a link in G to the other, if we are restricted to using T.  The distortion is defined [13] to be the smallest such average over all possible Ts. Intuitively distortion measures how tree-like a graph is.\n[13]  R.  G.  H.  Tagmunarunkit  and  S.  Jamin,  “Network  topology  generators:  degree-based  vs.  structural,”  in SIGMCOMM, 2002.\n\n    ", "Answer": "\r\nI don't think you will find a function to do that on an R package. \n\nThere are n^{n-2} spanning trees on a graph (according to the Cayley's formula). Even on your graph with 10 nodes, there may exist 1,000,000,000 different spanning trees, which is a big number.\n\nFurthermore, the problem of counting or enumerating all spanning trees of a given graph is #P-Complete, which is as harder as NP-Complete problems.\n\nIf you are really willing to do that, I recommend dropping R and start using C or C++, which can compute your problem much faster than any R code can do.\nHave a look on this paper for a survey on algorithms for computing all spanning trees of a connected graph (which I think is your case).\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "MST with modification\r\n                \r\nCan anyone think of a way to modify Kruskal's algorithm for a minimum spanning tree so that  it must include a certain edge (u,v)?\n    ", "Answer": "\r\nI might be confusing, but as far as I remember, kruskal can handle negative weights,so you can give this edge ```\n-infinity```\n weight.\n\n\nOf course it won't actually be ```\n-infinity```\n, but a number low enough\nto be significant enough that it cannot be ignored, something like ```\n-1 * sigma(|weight(e)|)```\n for each e in E.\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Prim's algorithm for minimum spanning trees - confusion in algorithm\r\n                \r\nI've been studying from the Cormen et al book and I'm a bit confused regarding the algorithm they have provided. I've understood how the concept of Prim's algo works through wikipedia, but I can't mimic that working using the algorithm provided in my book.\n\nRefer to this online copy of the chapter:\nhttp://www.cs.cmu.edu/afs/cs/academic/class/15451-s04/www/Lectures/minimumSpanningTrees.pdf\n\nThe algo is given on page 13 in the above link and an example diagram is on the previous page.\n\nNow, using the algorithm on the example case, in the first step:\n\nu <--- node A through ExtractMin(Q).\nThen there are two entries in Adj[u] as per the diagram: node b and node h.\n\nNow first set v <---- node b. Then check if v belongs to Q. It does. Check if w(u,v) < key[v]. True. So PI[v] <--- u and key[v] <--- w(u, v).\nI got this much. This is shown in (b) of the diagram on pg 12.\n\nBUT the algo says \"for each v in Adj[u]\".\n\nSo the next step should set v <--- node h.\nThen check if v belongs to Q. It does! And is w(u,v) < key[v]? It is! Since key[v] = infinity!\nBut the diagram shows a different step in part (c)!\n\nAaaaaah! Why?\n    ", "Answer": "\r\nOne of the guys at MO was kind enough to answer by email.\nThe problem was that I didn't notice that the tree nodes are added one at a time via the ExtractMin(Q) operation.\n\nHere is the reply he gave:\n\n*Your analysis is actually completely correct, but you (and I)\nwere confused about what updating key[v] and pi(v) means. In\nparticular, when you update pi(v), you do not add it to the tree. A\nnode u is added to the tree (along the edge connecting it to its\nparent pi(u)) only when it is extracted from Q. So everything proceeds\nlike you described, but at the end of it, you've only completed step\n(a), not step (c). Here's a run-down of what the program does in that\ncase:\n\n\n(lines 1-3) All nodes are placed in Q (the set of nodes not in the\ntree), their parents are declared to be NIL, and their key (i.e.\nminimum distance to the existing tree along a single edge) is set to\ninfinity\n(line 4) The key of the root node (node a) is set to 0\n(line 6) The node u with minimum key (which is the root node a) is\nremoved from Q and added to the tree\n(lines 8-11) The keys of nodes b and h are updated to 4 and 8, and\npi(b) and pi(h) are set to u (but b and h are not extracted from Q).\nThis completes step (a)\n(line 6) The node u with minimum key (which is now node b, with\nkey=4) is removed from Q and added to the tree via its parent (which\nis pi(b)=a)\n(lines 8-11) The key of nodes c is updated to 8, and pi(c) is set to\nb. Since key(h)=8 is smaller than 11=w(b,h), the key and parent of h\nare not updated. This completes step (b)\n(line 6) The node u with minimum key (node c, with key=8, but it\ncould also have been node h, which also has key=8) is removed from Q\nand added to the tree via its parent (which is pi(c)=b)\n(lines 8-11) Update keys and parents of nodes d, i, and f, completing step (c)\netc.*\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 1 [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Questions asking for code must demonstrate a minimal understanding of the problem being solved. Include attempted solutions, why they didn't work, and the expected results. See also: Stack Overflow question checklist\r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\ni meet with some exception problems while i'm coding to get the minimum spanning tree.\n\nthe error message is like :\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 1\n    at Assignment.RandomGraph.main(RandomGraph.java:36)\n\n```\nimport java.util.*;\npublic class RandomGraph\n{\npublic static Scanner br = new Scanner(System.in);\nstatic int w [][];//it represents the weight between every two nodes.\nstatic int n;//number of the vertices that you typed.\nstatic int i, j;\nstatic int visited[] = new int[n];\nstatic int next[] = new int[n];\nstatic int d[]=new int[n];\n\n\n\npublic static void main (String[] args)\n{\n    System.out.println(\"Find the shortest edge\");\n    System.out.println(\"\\nEnter the number of the vertices: \");\n    n = br.nextInt();\n    w = new int[n][n];\n    for(int i=0;i<n;i++)\n        for(int j=0;j<n;j++)\n        {\n            if((i!=j))\n            {\n            w[i][j] = w[j][i]= 1+(int)(Math.random()*9);\n            }\n            else if(i == j)\n            {\n                w[i][j] = w[j][i] = 0;\n            }\n        }\n    for(i=1;i<=n;i++)\n    {\n        next[i]=visited[i]=0;\n        d[i]=32767;\n    }\n    Graph();\n    Prim();\n}\n\nstatic void Graph()\n{\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<n;j++)\n        {\n            System.out.print(\"  \"+w[i][j]+\"  \");\n        }\n    System.out.println();\n    }\n}\n\nstatic void Prim()\n{\n    int current=1;\n    int total=1;\n    int mincost;\n\n    d[current]=0;\n    visited[current]=1;\n    do{\n        for(i=1;i<=n;i++)\n        {\n            if((w[current][i]!=0)&&(visited[i]==0)&&(w[current][i]<d[i]))\n            {\n                d[i]=w[current][i];\n                next[i]=current;\n            }\n        }\n        mincost = 32767;\n        for(i=1;i<=n;i++)\n        {\n            if((visited[i]==0)&&d[i]<mincost)\n            {\n                mincost=d[i];\n                current=i;\n            }\n        }\n        visited[current]=1;\n        total++;\n    }while(total!=n);\n\n    mincost=0;\n    for(i=1;i<=n;i++)\n    {\n        mincost=mincost+d[i];\n        System.out.print(\"\\n Minimum cost = \"+mincost);\n        System.out.print(\"\\n Minimum Spanning tree is \");\n    }\n    for(i=1;i<=n;i++)\n    {\n        System.out.print(\"\\n\"+i+\" to \"+next[i]);\n    }\n}\n```\n\n\n}\n    ", "Answer": "\r\nwell the variable i in your fors should go from 0 to n, EXCLUSIVELY\n\n```\nfor(int i=0; i<n; i++)\n```\n\n\nif you declare an array / matrix as array[n], the system will create an array of size n but starting from 0, not 1\n\nas in, ```\narray[0] = first element NOT array[1]```\n\n\n=> last element = ```\narray[n-1]```\n \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "No of Minimum spanning trees should be 2 but solution says 1\r\n                \r\nI am trying to solve a problem on weight of MST and no of such MSTs.\n\n\nIn this probem, the weight of MST found by PRIM'S algorithm is 34, but there can be 2 MSTs possible; one tree with edge BC and the other with edge EF. But given answer is only 1. \n\nAm i going wrong anywhere ?\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "No of Minimum spanning trees should be 2 but solution says 1\r\n                \r\nI am trying to solve a problem on weight of MST and no of such MSTs.\n\n\nIn this probem, the weight of MST found by PRIM'S algorithm is 34, but there can be 2 MSTs possible; one tree with edge BC and the other with edge EF. But given answer is only 1. \n\nAm i going wrong anywhere ?\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Prim MST algorithm optimization\r\n                \r\nI am implementing Prim's algorithm for minimum spanning tree.\nthe algorithm works correctly.\nbut it would take too much time if i have a graph with 10000 nodes.\nhere is the example of how i store the graph in my code:\n\n```\ngraph = {0: {1: 6, 5: 3}, \n1: {0: 6 , 6: 3 , 2: 9}, \n2: {1: 9, 7: 3 , 3: 5}}\n```\n\n\nHere is how i get my adolescences:\n\n```\ndef adjacent(graph, u): # adjacencies of vertex u\n    return graph[u].keys()\n```\n\n\nHere is how i calculate the weight of the edge between two nodes:\n\n```\ndef w(u,v):\n    L = cartesian_product[u].keys()\n    if v in L:\n        return cartesian_product[u].get(v)\n    return 999999\n```\n\n\nAnd here is my algorithm to calculate the wieght of the minimum spanning tree with Prim's algorithm:\n\n```\ndef prim(graph):\n    total_mst_cost=0\n    # put all nodes in a heap\n    h=[(0,0)] \n    for i in range(1,n*k):\n        heappush(h, (999999,i))\n    while len(h)!=0 : #till there is a node left in the heap\n        (key,u) = heappop(h)\n        total_mst_cost += key\n        # check hte adjacences of node-->\n        adj = adjacent(graph,u)\n\n        f = operator.itemgetter(1)\n        ff = map(f, h)\n        for v in adj:\n            # update the labels:\n            _ww = w(u,v)\n            try: i = ff.index(v)\n            except: continue\n            if v==h[i][1] and _ww < h[i][0]:\n                h[i]=(_ww, h[i][1])\n        heapify(h)\n            # for i in range(len(h)):\n            #     if v==h[i][1] and _ww < h[i][0]:\n            #         h[i]=(_ww, h[i][1])\n            #         heapify(h)\n    return total_mst_cost\n```\n\n    ", "Answer": "\r\nIdea 1\n\nThe initialization of the heap:\n\n```\nfor i in range(1,n*k):\n    heappush(h, (999999,i))\n```\n\n\nis unnecessary.  If all nodes are reachable you can simply delete these two lines.\n\nIdea 2\n\nThe weight extraction:\n\n```\nL = cartesian_product[u].keys()\n```\n\n\nseems slow.  I am not quite sure what type cartesian_product is, but if it is a dictionary then it should be faster to test for inclusion with ```\nu in cartesian_product```\n than by extracting a list of keys and searching them.\n\nIdea 3\n\nYou call heapify after each iteration.  I believe this is because you wish to be able to adjust the weights in the heap queue.  \n\nAn alternative faster approach to this is documented in the Python documentation here](https://docs.python.org/2/library/heapq.html#priority-queue-implementation-notes) and works by marking certain values as being removed using a dictionary.\n\nIdea 4\n\nIf this isn't for educational reasons, I would recommend using Networkx, a Python library with graph algorithms.  In this library you can replace all your code with a function call to minimum_spanning_tree\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Wrong answer while calculating Minimum Spanning Tree Using Kruskal Algorithm\r\n                \r\nI am Trying to solve this MST question on spoj using kruskal algorithm. my program seems to work on all test cases but spoj repeatedly is giving WA on this code.\n\nI am not able to find any failing test cases on this code. Can someone please point out to what I am doing wrong.\n\n```\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\n\npublic class CSTREET {\n\n    static final int MAX = 1002;\n    static Node edgeList[];\n    static int parent[] = new int[MAX];\n\n\n    public static void main(String[] args) throws Exception {\n        Reader in = new Reader();\n        PrintWriter out = new PrintWriter(System.out, true);\n        int t = in.nextInt();\n        while (t-- != 0) {\n\n            int price = in.nextInt();\n            int vertices = in.nextInt();\n            int edge = in.nextInt();\n            int idx = 0;\n            edgeList = new Node[edge];\n            for (int i = 1; i <= vertices; i++) {\n                parent[i] = i;\n            }\n\n            while (idx < edge) {\n\n                int src = in.nextInt();\n                int dest = in.nextInt();\n                int cost = in.nextInt();\n                Node node = new Node(src, dest, cost);\n\n                edgeList[idx] = node;\n                idx++;\n            }\n\n            Arrays.sort(edgeList);\n            int edgeCount = 0;\n\n\n            long totalCost = 0;\n            idx = 0;\n\n            while (edgeCount < vertices-1 ) {\n                Node curEdge = edgeList[idx];\n                if (!checkCycle(curEdge.src, curEdge.dest)) {\n\n                    edgeCount++;\n                    totalCost += curEdge.cost;\n\n                }\n                idx++;\n\n            }\n            out.println(totalCost * price);\n        }\n    }\n\n\n    static boolean checkCycle(int src, int dest) {\n\n        if (findParent(src) == findParent(dest)) {\n            return true;\n        }\n\n        while (parent[dest] != parent[src]) {\n            parent[dest] = src;\n            src = parent[src];\n        }\n\n        return false;\n\n    }\n\n    static int findParent(int i) {\n\n        while (parent[i] != i) {\n            i = parent[i];\n        }\n\n        return i;\n    }\n\n\n    static class Node implements Comparable<Node> {\n\n        int src;\n        int dest;\n        int cost;\n\n        public Node(int src, int dest, int cost) {\n            this.src = src;\n            this.dest = dest;\n            this.cost = cost;\n        }\n\n        @Override\n        public int compareTo(Node o) {\n            return this.cost - o.cost;\n        }\n    }\n}\n```\n\n    ", "Answer": "\r\nYour implementation of union-find is not correct. Consider this example\n\n```\nx -> y ( y is parent of x )\n\nA -> B -> C\nD -> E\n```\n\n\nWhen you call ```\ncheckCycle( A, D)```\n what should happen is all of the 5 nodes should go to one set, For example:\n\n```\nA -> B -> C\nD -> E -> C\n```\n\n\nBut what happens in your code is:\n\n```\nA -> B -> C\nD -> C\nE\n```\n\n\nWhich is obviously not correct.\n\nYou can change the ```\ncheckCycle```\n as below:\n\n```\nstatic boolean checkCycle(int src, int dest) {\n\n    int srcRoot = findParent(src);\n    int destRoot = findParent(dest);\n    if (srcRoot == destRoot ) {\n        return true;\n    }\n    parent[destRoot] = srcRoot;\n    return false;\n}\n```\n\n\nI strongly advise you to read the wikipedia article about Disjoint-set and implement the path compression version, which improves the complexity.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Any real-world problem where we need Shortest path tree?\r\n                \r\nI can see that we can use Minimum spanning tree in Network design like telephone, electrical, hydraulic, TV cable, computer, road etc. But I am not quite clear that where exactly Shortest path tree can be used in real life, where MST algo will not be helpful.\n    ", "Answer": "\r\nAs stated in this website, you would use a MST to \"select a set of edges so that there is a path between each node. The sum of the edge lengths is to be minimized\". And you would use a SPT to \"find the set of edges connecting all nodes such that the sum of the edge lengths from the root to each node is minimized.\"\nBasically MST focuses on the shortest path between all nodes, whereas a SPT focuses on the shortest path from root to every node.\nIn a real-world example, SPT is used in geographical maps, telephone networks, and usually in IP routing algorithms (basically when you need to reach each node from root with the smallest length).\nHere is an example using an actual graph:\n\n\nAs you can see, a MST finds the minimum weight that connects all nodes, but a SPT finds the minimum weight when starting at a particular node.\nIn a real-world example where you would use a SPT instead of a MST would be for a hospital and the homes in its region. The goal is to find the shortest path starting from the hospital and to each individual home. That way in an emergency the ambulance could start at the hospital and reach any home with the smallest distance possible.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "The Widest Path Challenge - the most efficient way for finding path in Maximal Spanning Tree\r\n                \r\nThis question is continuation of my similar earlier asked question: Find path between two nodes in graph, according to given criteria - optimization task .\n\nProblem summary:\nI need to find the best path in graph from vertex A to vertex B, with assumption, that path quality is calculated as min value of edge weight on path and next the best path is that, which has max min value. Generally it's so called \"Widest path problem\".\n\nPreviously I needed to solve this problem in very small graph (up to 15 vertices), so I didn't need sophisticated algorithm and with the help of kind peoples, I have designed my working algorithm. \nUnfortunately now I need to redefine my necessities in such way, that my graph can be very large (even 50 thousands of edges).\nI'm aware that I need to find Maximal Spanning Tree for my graph and obtain a simple path from start to stop vertex in obtained MST.\nI have decided to use jGraphT library. It has implemented Kruskal Minimum Spanning Tree algorithm. I can obtain Maximal Spanning Tree by multiplying each edge weight by (-1) and using Kruskal for Minimal Spanning Tree, but algorithm in the library has been designed for retrieving Hash Set of MST edges.\n\nMy question is following:\nI have obtained Maximal Spanning Tree of graph as java HashSet of edges. How I can find a path from vertex A to vertex B in such structure in the most efficient way and what data structure will be the most efficient for this purpose? What do you recommend me?\n\nAdditionally, I'm worried about such situation, that my graph is not always consistent (it may contain isolated vertices or isolated subgraphs), what is main condition for Kruskal algorithm correctness. Is it any way to bypass this problem?\n\nThank you for any help or tips.\n    ", "Answer": "\r\nUse the set to construct a ```\nSubgraph```\n object. Subclass ```\nDepthFirstIterator```\n so that ```\nencounterVertex```\n puts an entry with key ```\nv```\n and value (whatever the other endpoint of ```\ne```\n is) into a map ```\np```\n. Search depth-first from the sink. Recover the path by initializing ```\nv```\n to be the source and looking up ```\nv```\n, ```\np[v]```\n, ```\np[p[v]]```\n, etc., until there is no entry. This is a pain, but the library authors baked ```\nFibonacciHeap```\n into ```\nClosestFirstIterator```\n, which otherwise would be the class you want. (Heck, if you don't care about another n log n time operation, you could just run Dijkstra on the subgraph.)\n\nKruskal's algorithm functions fine with disconnected graphs. It returns a minimum-weight spanning forest, i.e., for each connected component, a minimum-weight spanning tree. I can't vouch for this particular implementation.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "spanning tree including maximum weight [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     This question does not appear to be about programming within the scope defined in the help center.\r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nLet G be a weighted undirected graph and e be an edge with maximum weight in G.Suppose there is a minimum weight spanning tree in G containing the edge e.Which of the following statements is always TRUE?\n\na.There exists a cut in g having all edges of maximum weight\n\nb.There exists a cycle in G having all edges of maximum weight\n\nc.Edge e can not be contained in a cycle\n\nd.All edges in G have the same weight\n\nIs a previous year exam questing .i am having trouble to under stand it can any one explain it to me .\n    ", "Answer": "\r\nThe bottom three are false, and the following simple graph is a counter-example to all three:\n\n```\n     1\n  a --- b\n  |    /\n2 |   /\n  |  / 2\n  | /\n  c\n```\n\n\nAny minimum-weight spanning tree contains either the edge ```\n<a,c>```\n or the edge ```\n<b,c>```\n.  In either case, it is easy to check that (b), (c), and (d) all fail.\n\nEdit: (a) is true.  Here is a proof:\n\nLet ```\ne```\n be an edge of ```\nM```\n which is of maximum weight in ```\nG```\n, and let ```\nM```\n be a minimum-weight spanning tree for ```\nG```\n containing the edge ```\ne```\n.  If the edge ```\ne```\n cuts the graph ```\nG```\n, then (a) is obviously true.  So, let ```\nG'```\n be obtained from ```\nG```\n by removing the edge ```\ne```\n, and suppose ```\nG'```\n is connected.\n\nLet ```\nM'```\n be obtained from ```\nM```\n by removing the edge ```\ne```\n.  Now we know that ```\nM'```\n consists of two components, because ```\nM```\n is a tree, and removing one edge from a tree disconnects it into two components.  Furthermore every vertex of ```\nG'```\n belongs to ```\nM'```\n, and ```\nG'```\n is connected, so we can obtain a spanning tree of ```\nG'```\n by adding a single edge of ```\nG'```\n to ```\nM'```\n.  I claim that every such edge is of maximum weight in ```\nG```\n.\n\nTo see why, suppose there is an edge ```\ne'```\n in ```\nG'```\n which connects the two components of ```\nM'```\n, but is of sub-maximal weight in ```\nG```\n.  Then, we could remove the edge ```\ne```\n from ```\nM```\n (our original spanning tree), add this edge ```\ne'```\n to ```\nM```\n to obtain a new spanning tree of ```\nG```\n, but it would be of total weight less than that of ```\nM```\n, contradicting the minimal-weight of ```\nM```\n.\n\nSo, consider the set of all edges of ```\nG'```\n which connect the two components of ```\nM'```\n.  These edges together with ```\ne```\n form an edge-cut-set of ```\nG```\n, and all must be of maximal weight in ```\nG```\n.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Find distance from a node to the one farthest from it BOOST\r\n                \r\nI need to fin the distance from all nodes to the node farthest from it in the minimum spanning tree. I have done this so far but I got no clue as to find the longest distance from a node.\n\n```\n#include<iostream>\n#include<boost/config.hpp>\n#include<boost/graph/adjacency_list.hpp>\n#include<boost/graph/kruskal_min_spanning_tree.hpp>\n#include<boost/graph/prim_minimum_spanning_tree.hpp>\n\nusing namespace std;\nusing namespace boost;\n\nint main()\n{\ntypedef adjacency_list< vecS, vecS, undirectedS, property <vertex_distance_t,int>, property< edge_weight_t, int> > Graph;\nint test=0,m,a,b,c,w,d,i,no_v,no_e,arr_w[100],arr_d[100];\ncin>>test;\nm=0;\nwhile(m!=test)\n{\ncin>>no_v>>no_e;\nGraph g(no_v);\nproperty_map <Graph, edge_weight_t>:: type weightMap=get(edge_weight,g);\nbool bol;\ngraph_traits<Graph>::edge_descriptor ed;\n\nfor(i=0;i<no_e;i++)\n{\ncin>>a>>b>>c;\ntie(ed,bol)=add_edge(a,b,g);\nweightMap[ed]=c;\n}\n\nproperty_map<Graph,edge_weight_t>::type weightM=get(edge_weight,g);\nproperty_map<Graph,vertex_distance_t>::type distanceMap=get(vertex_distance,g);\nproperty_map<Graph,vertex_index_t>::type indexMap=get(vertex_index,g);\n\nvector< graph_traits<Graph>::edge_descriptor> spanning_tree;\n\nkruskal_minimum_spanning_tree(g,back_inserter(spanning_tree));\n\nvector<graph_traits<Graph>::vector_descriptor>p(no_v);\n\nprim_minimum_spanning_tree(g,0,&p[0],distancemap,weightMap,indexMap,default_dijkstra_visitor());\n\n\n\nw=0;\n\nfor(vector<graph_traits<Graph>::edge_descriptor>::iterator eb=spanning_tree.begin();eb!=spanning_tree.end();++eb) //spanning tree weight\n{\nw=w+weightM[*eb];\n}\n\narr_w[m]=w;\nd=0;\n\ngraph_traits<Graph>::vertex_iterator vb,ve;\n\nfor(tie(vb,ve)=vertices(g),.\n\narr_d[m]=d;\nm++;\n}\n\nfor( i=0;i<test;i++)\n{\ncout<<arr_w[i]<<endl;\n}\n\nreturn 0;\n}\n```\n\n\nIf i have a spanning tree with nodes 1 2 3 4 I need to find longest distance from 1 2 3 4 in the spanning tree(and the longest distance can comprise of many edges not only one).\n    ", "Answer": "\r\nI'll not give you exact code how to do this but I'll give you and idea how to do this.\n\nFirst, result of MST (minimum spanning tree) is so called tree. Think about the definition. One can say it is a graph where exists path from every node to every other nodes and there are no cycles. Alternatively you can say that given graph is a tree iff exists exactly one path from vertex u to v for every u and v.\n\nAccording to the definition you can define following\n\n```\nfunction DFS_Farthest (Vertex u, Vertices P)\nbegin\n    define farthest is 0\n    define P0 as empty set\n    add u to P\n\n    foreach v from neighbours of u and v is not in P do\n    begin\n        ( len, Ps ) = DFS_Farthest(v, P)\n        if L(u, v) + len > farthest then\n        begin\n            P0 is Ps union P\n            farthest is len + L(u, v)\n        end\n    end\n\n    return (farthest, P0)\nend\n```\n\n\nThen you'll for every vertex v in graph call ```\nDFS_Farthest(v, empty set)```\n and it'll give you (farthest, P) where farthest is distance of the farthest node and P is set of vertices from which you can reconstruct the path from v to farthest vertex.\n\nSo now to describe what is it doing. First the signature. First parameter is from what vertex you want to know farthest one. Second parameter is a set of banned vertices. So it says \"Hey, give me the longest path from v to farthest vertex so the vertices from P are not in that path\".\n\nNext there is this ```\nforeach```\n thing. There you are looking for farthest vertices from current vertex without visiting vertices already in P (current vertex is already there). When you find path longer then currently found not it to ```\nfarthest```\n and ```\nP0```\n. Note that ```\nL(u, v)```\n is length of the edge {u, v}.\n\nAt the end you'll return those length and banned vertices (this is the path to the farthest vertex).\n\nThis is just simple DFS (depth first search) algorithm where you remember already visited vertices.\n\nNow about time complexity. Suppose you can get neighbours of given vertex in O(1) (depends on data structure you have). Function visits every vertex exactly once. So it is at least O(N). To know farthest vertex from every vertex you have to call this function for every vertex. This gives you time complexity of this solution of your's problem at least O(n^2). \n\nMy guess is that better solution might be done using dynamic programming but this is just a guess. Generally finding longest path in graph is NP-hard problem. This makes me suspicious that there might not me any significantly better solution. But it's another guess. \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Prim's Algorithm\r\n                \r\nI am working on a minimum spanning tree using Prim's Algorithm with PriorityQueue in Java. However, I am getting the totalWeight (the minimum weight of the tree) wrong. \n\nDid I misunderstand the concept behind total weight, or is there some problem with my code?\n\n```\npublic int getMinSpanningTree(Graph g) {\n    int[][] matrix = g.getEdgeMatrix();\n    int totalVertices = g.getNumberOfVertices();\n    boolean[] visit = new boolean[totalVertices];\n    int visitNum = 1;\n    int totalWeight = 0;\n    PriorityQueue<PriorityVertex> queue = new PriorityQueue<PriorityVertex>();\n\n    //FIRST ITERATION\n    visit[0] = true;\n    for (int i = 0; i < totalVertices; i++) {\n        if(matrix[0][i] > 0) {\n            PriorityVertex temp = new PriorityVertex(i, g.getWeight(0,i));\n            queue.add(temp);\n        } \n    }\n\n    while (visitNum < totalVertices) {\n        PriorityVertex temp = queue.poll();\n        visit[temp.vertex] = true;\n        visitNum++;\n        totalWeight = temp.priority + totalWeight;\n        //RUN NEIGHBOUR VERTICES\n        for (int k = 0; k < totalVertices; k++) {\n           if(matrix[temp.vertex][k] > 0 && visit[k] == false) {\n               PriorityVertex vertex = new PriorityVertex(k, g.getWeight(temp.vertex, k));\n               queue.add(vertex);\n           } \n        }\n    }\n    return totalWeight;\n}\n```\n\n    ", "Answer": "\r\nThe problem is you do not remove all instances of vertex from the queue => the same vertex can be added several times into the result.\n\nAssume following graph:\n\n```\nweight(0,1) = 1\nweight(0,2) = 2\nweight(1,2) = 3\nweight(1,3) = 4\nweight(2,3) = 5\n```\n\n\nAfter the \"FIRST ITERATION\" the queue contains PriorityVertex(1, 1), PriortyVertex(2, 2).\n\nIterations of while cycle:\n\n```\n1) removed: PriorityVertex(1, 1) - edge (0,1) \n   added: PriorityVerterx(2, 3) and PriorityVertex(3, 4)\n   queue: PriorityVertex(2, 2), PriorityVertex(2, 3), PriorityVertex(3, 4)\n\n2) removed: PriorityVertex(2, 2) - edge (0,2)\n   added: PriorityVertex(3, 5)\n   queue: PriorityVertex(2, 3), PriorityVertex(3, 4), PriorityVertex(3, 5)\n\n3) removed: PriorityVertex(2, 3) - edge (1,2), cycle in the result!\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Is there a Dynamic Programming way to compute the k minimum spanning trees?\r\n                \r\nMy teacher asked us to implement a Dynamic Programming solution to that problem, but I'm thinking one doesn't exist since I couldn't find it using Google.\n\nAnyway, given a graph and a k, say 3, you have to find the 3 best MSTs from it. If the graph is such that it doesn't have k subtrees, you can return either the same tree multiple times or suboptimal trees.\n\nI can't really think of a solution to it.\n    ", "Answer": "\r\nYou had me confused for a while there and I thought you might have misunderstood the problem. The \"k-MST\" problem consists of finding k edges that form a subtree such that the sum of its edges is less than or equal to all other sums you can get from subtrees of k edges. But then I saw the plural s.\n\nSo ok, for your problem, I personally would try to find a DP-algorithm for finding the MST that combines with a way of generating a \"next\" MSTs. Since this is dynamic programming I'd look into repeatedly optimizing something (in this case de-optimizing for each step) or at various ways of partitioning edges into subsets that make sense in an MST setting. There might be several ways.\n\nHowever, searching for partitions and minimum spanning trees I found this, which might be more of help if you just want the answer: http://www.scielo.br/scielo.php?script=sci_arttext&pid=S0101-74382005000200004\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to find out Euclidean Minimum Spanning tree using CGAL library?\r\n                \r\nI have a set of 2-D points, and considering every point connected to every other one with an \"edge\" with weight equal to the distance between them, I need to find the MST of the resulting graph.\nI am using the fact that EMST is always a subgraph of the delaunay triangulation of this field. I need the triangles' as a list of edges to make a graph from it and then run Kruskal over it.\n\nAlso, Do I have to go the Delaunay triangulation way, or is there a direct function for it?\n\nKindly give a sample code for figuring out which headers to include, which namespace to use etc. with your answer for either question, if possible.\n    ", "Answer": "\r\nIn 2D, the number of edges of a triangulation is linear. Once the Delaunay triangulation is computed using cgal, you can use an implementation of minimal spanning tree on graph. See the wikipedia page Euclidean minimum spanning tree.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Analysis of Prim's Algorithm\r\n                \r\nCan anyone explain why we use or what's the importance of using the key array(i.e key[])\nin PRIM'S ALGORITHM which deals with the minimum spanning tree problem.\n\n```\nPRIM_MST(G,W,R)//G->graph,W->weighted matrix,R->root vertex\n-------------------------\n\nfor v<-v[G]\n    key[v]<-infinity\n    pred[v]<-NIL     //pred[]-->predecessor array\nkey[v]=0\nQ<-v[G]              //Q-->priority queue\nwhile Q!=NULL\n     u<-EXTRACT_MIN(Q)\n      for v<-adj[u]   //adj[]--> adjacency list matrix\n           if v belongs to Q && w(Q,v)<key[v]\n                 pred[v]<-u,key[v]<-w(u,v)\n```\n\n    ", "Answer": "\r\nKey is basically the value on the edge that led to the particular vertex in the graph during the construction of MST\n\non arriving on a vertex during the algorithm, it checks for the minimum weighted edge connecting the set A(the set of vertices already traversed) and set B(the set of edges not yet traversed). It follows this minimum edge and puts the key of the newly arrived vertex(the one reached after following this min edge) as the weight of this minimum edge\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Prim's MST: Does the start node matter?\r\n                \r\nI intuitively feel that if one is using Prim's algorithm to find a graph's minimum spanning tree, it doesn't matter which root node is picked - the resultant MST will have the same weight regardless. Is this correct?\n    ", "Answer": "\r\nThat is correct. Choosing a different starting node could give you a different spanning tree, but it will always have the same weight: the minimal possible.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "unable to comprehend prims algorithm\r\n                \r\nPlease help in understanding prims algo pseudocode(as it is in coreman and wiki)\nPrim's algorithm.\n\n\r\n\r\n```\n    MST-PRIM (G, w, r) {\r\nfor each u ∈ G.V\r\nu.key = ∞\r\nu.parent = NIL\r\nr.key = 0\r\nQ = G.V\r\nwhile (Q ≠ ø)\r\n//1\r\nu = Extract-Min(Q)\r\nfor each v ∈ G.Adj[u]\r\nif (v ∈ Q) and w(u,v) < v.key\r\nv.parent = u\r\nv.key = w(u,v)}```\n\r\n\r\n\r\n\n\ni am able to understand till 1 or while loop that r.key=0 ensure that neighours or adjacents of root are scanned first,\nbut as u already belongs to Q(queue of nodes till now not included in prims minimum spanning tree) and v also in Q,will not help in generating prims MST.\n\nalso both coreman and thus wiki states\n\n\r\n\r\n```\n 1. A = { (v, v.parent) : v ∈ V - {r} - Q }.\r\n2. The vertices already placed into the minimum spanning tree are those in V−Q.\r\n3. For all vertices v ∈ Q, if v.parent ≠ NIL, then v.key < ∞ and v.key is the weight of a light edge ```\n\r\n\r\n\r\n\n\nPrior to each iteration of the while loop of lines 6–11,\n   (v, v.parent) connecting v ::to some vertex already placed into the minimum spanning tree.     \n\nas A is our MST then how 1. will help as v is already been included in our MST (as shown by  v ∈ V - {r} - Q ) why then it should be included.\n    ", "Answer": "\r\nFor the part that you have doubts:\n\n```\nu = Extract-Min(Q) \nfor each v ∈ G.Adj[u]\nif (v ∈ Q) and w(u,v) < v.key\nv.parent = u\nv.key = w(u,v)\n```\n\n\n\"For each vertex v, the attribute v:key is the minimum weight of any edge connecting to a vertex in the tree; by convention, key = ∞ if there is no such edge.\" (http://en.wikipedia.org/wiki/Prim's_algorithm)\n\nTherefore, u = Extract-Min(Q) will get the vertex with the minimum key.\n\nfor each v ∈ G.Adj[u] will find all the neighbors of u.\n\nif (v ∈ Q) and w(u,v) < v.key condition to eliminate cycle and check if path should be updated.\n\nThen the following lines of code update the neighbors edges.\n\n```\nv.parent = u\nv.key = w(u,v)\n```\n\n\n\"Prior to each iteration of the while loop of lines 6–11,\n1. A = { (v, v.parent) : v ∈ V - {r} - Q }. \"  (http://en.wikipedia.org/wiki/Prim's_algorithm)\n\nBased on the above statement, before the while loop A is empty as Q = G.V! After the while loop you will get A contains all the vertices that form the MST. Each vertex v in A has a parent (v.parent). For root r, its parent is NIL. Root r is excluded due to the statement V - {r} but it exists in A thanks to its children in the form of v.parent. \n\nTherefore in this link http://en.wikipedia.org/wiki/Prim's_algorithm , it states that: \"2. The vertices already placed into the minimum spanning tree are those in V−Q.\"\n\nand \"When the algorithm terminates, the min-priority queue Q is empty; the minimum spanning tree A for G is thus A = { (v, v.parent) : v ∈ V - {r} }.\" \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "how to find out a MST of a given graph, which must include the edges from set A\r\n                \r\nGiven a graph G = (V,E) and a set of edges A(which is a subset of E)\n\nHow to find a minimum spanning tree that must include the edges in A? \n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "how to find out a MST of a given graph, which must include the edges from set A\r\n                \r\nGiven a graph G = (V,E) and a set of edges A(which is a subset of E)\n\nHow to find a minimum spanning tree that must include the edges in A? \n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Distributed algorithm for Minimum-Weight Spanning Trees\r\n                \r\nDoes anyone know if there is available somewhere a Java implementation of the Gallagher-Humblet-Spira (GHS) algorithm?\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "It is possible for a graph to have multiple minimum spanning trees\r\n                \r\nLet G=(V, E) be an undirected graph, all whose edges have a unique weight. Is it true\nthat G has a single unique MST? Or can G also have multiple MSTs?\n    ", "Answer": "\r\nAs per the definition of MST (source: wikipedia) -\n\nA minimum spanning tree (MST) or minimum weight spanning tree is a subset of the edges of a connected, edge-weighted undirected graph that connects all the vertices together, without any cycles and with the minimum possible total edge weight.\n\nThe goal is to cover all vertices while having the lowest edge weight sum. Also, a spanning tree (ST) is a tree, so no cycles -\n\nIn the image above, the orange trees are STs, but, only the top one can be an MST (edge weight sum is 7).\n\nEDIT\nProof by contradiction:\nLet  be an undirected graph with unique edge weights. Let  and  be two distinct Minimum Spanning Trees for the graph.\nLet  be the edge with lowest weight present in , but, not in  . Similarly, let  be the edge in , but, not in .\nNow, since edge weights are unique, without loss of generality, let .\nAlso, if we add  in , a cycle will form with . To remove the cycle, let us remove the edge  from . Thus, we have a Spanning Tree .\nThis ST, , now has total weight less than ; but, this is a contradiction, since,  was already an MST.\nThus, our assumption that,  had two MSTs to begin with was wrong. This concludes the proof.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Create a MST with depth-first search?\r\n                \r\nI have a symmetrical graph and created a tree with all shortest path from a random vertex to any other vertex. Can I use the tree to construct a Minimum Spanning Tree(MST)?  My algorithm is similar to depth-first algorithm. \n    ", "Answer": "\r\nIn the worst case, a shortest path tree does not help in finding a minimum spanning tree. Consider a graph where we want to find the MST. Add a source vertex with edges of an identical large length to each other vertex. The shortest path tree from that source consists of the very long edges, which we knew a priori, hence the shortest path tree is not useful in this case.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum spanning tree using Kruskal in Python, recursion enters a infinite loop\r\n                \r\nThe purpose of this code is to create the shortest path that connect each point. I've tried to implement the Kruskals algorithm in Python, but there is a problem and it occurs when the function findSet(x) is called. It seems like the program enters a infinite loop. I've tried to print x, x.dad and x.dad.dad and x in the crucial moment returns the initial x. I really don't know where is the problem.\n\n```\nclass Point:\n    def __init__(self,x = None, y = None):\n        self.x = x\n        self.y = y\n        self.dad = None\n        self.rank = None\n\nclass Edge:\n    def __init__(self, firstPoint = None, secondPoint = None, value = None):\n        self.firstPoint = firstPoint\n        self.secondPoint = secondPoint\n        if self.firstPoint != None and self.secondPoint != None:\n            self.value = abs(firstPoint.x-secondPoint.x) + abs(firstPoint.y - secondPoint.y)\n        else:\n            self.value = float(\"inf\")\n\ndef makeSet(node):\n    node.dad = node\n    node.rank = 0\n\ndef findSet(x):\n    print x, x.dad,x.dad.dad\n    if x == x.dad:\n        return x\n    x.dad = findSet(x.dad)\n    return x.dad\n\ndef unionSet(node1,node2):\n    root1 = findSet(node1)\n    root2 = findSet(node2)\n    if root1.rank < root2.rank:\n        root1.dad = root2\n    if root1.rank > root2.rank:\n        root2.dad = root1\n    else:\n        root2.dad = root1\n        root1.rank += 1\n\n\ndef merge(A, p, q, r):\n    L = A[p:q+1]\n    R = A[q+1:r+1]\n    infinite = Edge()\n    L.append(infinite)\n    R.append(infinite)\n    temp = []\n    i = 0\n    j = 0\n    for k in range(p,r+1):\n        if L[i].value <=  R[j].value:\n            temp.append(L[i])\n            i += 1\n        else:\n            temp.append(R[j])\n            j += 1\n    A[p:r+1] = temp\n\ndef mergeSort(A,p,r):\n    A2 = A\n    if p < r:\n        q = int((p+r)/2)\n        mergeSort(A2, p, q)\n        mergeSort(A2, q+1, r)\n        merge(A2, p, q, r)\n\ndef readPoint(A):\n    temp = []\n    for i in range(0,len(A), 2):\n        tempPoint = Point(A[i],A[i+1])\n        makeSet(tempPoint)\n        temp.append(tempPoint)\n    return temp\n\ndef calculateEdges(A):\n    tempArray = []\n    for i in range(0,len(A)):\n        for j in range(i+1,len(A)):\n            edge = Edge(A[i], A[j])\n            tempArray.append(edge)\n    return tempArray\n\ndef Kruskal(N, E):\n    mergeSort(E,0,len(E)-1)\n    j = 0\n    i = 0\n    total = 0\n    while j < N:\n        if findSet(E[i].firstPoint) != findSet(E[i].secondPoint):\n            unionSet(E[i].firstPoint,E[i].secondPoint)\n            j += 1\n            total += E[i].value\n        if i < len(E) - 1:\n            i += 1\n    return total\n\n\nAr = readPoint([18, 2, 99, 68])\nE = calculateEdges(Ar)\nprint Kruskal(len(Ar),E)\n```\n\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "NetworkX Minimum Spanning Tree has different cluster arrangement with the same data?\r\n                \r\nI have a large dataset which compares products with a relatedness measure which looks like this:\n```\nproduct1      product2  relatedness\n0101          0102      0.047619\n0101          0103      0.023810\n0101          0104      0.095238\n0101          0105      0.214286\n0101          0106      0.047619\n...           ...       ...\n```\n\nI used the following code to feed the data into the NetworkX graphing tool and produce an MST diagram:\n```\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\nproducts = (data['product1'])\nproducts = list(dict.fromkeys(products))\nproducts = sorted(products)\n\nG = nx.Graph()\nG.add_nodes_from(products)\nprint(G.number_of_nodes())\nprint(G.nodes())\n\nrow = 0\nfor c in data['product1']:\n    p = data['product2'][row]\n    w = data['relatedness'][row]\n    if w > 0:\n        G.add_edge(c,p, weight=w, with_labels=True)\n    row = row + 1\n\nnx.draw(nx.minimum_spanning_tree(G), with_labels=True)\nplt.show()\n```\n\nThe resulting diagram looks like this: https://i.stack.imgur.com/LBrnD.jpg\nHowever, when I re-run the code, with the same data and no modifications, the arrangement of the clusters appears to change, so it then looks different, example here: https://i.stack.imgur.com/jR62Q.jpg, second example here: https://i.stack.imgur.com/PLHyo.jpg. The clusters, edges, and weights do not appear to be changing, but the arrangement of them on the graph space is changing each time.\nWhat causes the arrangement of the nodes to change each time without any changes to the code or data? How can I re-write this code to produce a network diagram with approximately the same arrangement of nodes and edges for the same data each time?\n    ", "Answer": "\r\nThe ```\nnx.draw```\n method uses by default the ```\nspring_layout```\n (link to the doc). This layout implements the Fruchterman-Reingold force-directed algorithm which starts with random initial positions. This is this layout effect that you witness in your repetitive trials.\nIf you want to \"fix\" the positions, then you should explicitely call the ```\nspring_layout```\n function and specify the initial positions in the ```\npos```\n argument.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to implement Minimum Spanning tree in C++ with more than 2000 nodes?\r\n                \r\nI want to find MST of a graph which has more than 2000 nodes. The problem I am getting is that I can not make adjacency matrix of size more than 1500X1500 (If size is more than this segmentation fault is occurring because we can create an array of max 10^7 size). How could this be done?\n    ", "Answer": "\r\nThere are a number of issues here to think about.\n\n\nYou should be able to allocate an array of size 1500 × 1500 without causing a segfault, provided that you do it correctly. If you try to allocate an array of this size on the stack (that is, as a local variable), then you will probably blow out your stack space, which is likely what's causing the error you're getting. However, if you allocate it using ```\nnew[]```\n or by using a ```\nstd::vector```\n, then the memory is stored in the heap, which is designed to be able to accommodate requests like that.\nAdjacency matrices are only one way to represent a graph, and they're known to be space hogs that are only really a good idea if you're working with extremely dense graphs. The most common alternative is the adjacency list, which uses way less storage space, is easy to implement, and supports many relevant operations faster than an adjacency matrix. You might want to consider making this switch in conjunction with putting things on the heap and not on the stack.\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Find a minimum weighted spanning tree of the Cycle graph\r\n                \r\n\n\nI'm trying to solve the problem presented above and here is my attempt:\n\n Attempt: We can apply Dijkstra's shortest path algorithm instead of using Prim's and Kruskal's algorithms to find a MST as Dijkstra will visit all the nodes in the smallest weighted distance. Complexity: For G = (V,E), O(E log(V))\n\nQuestions:\n\n(1) Is my approach correct ?\n(2) Is it the most efficient answer to the question ?\n\nIf i'm completely wrong, I would appreciate a correct and efficient solution.\n    ", "Answer": "\r\nA cycle graph contains no edges other than those connecting the vertices in the cycle. So what we can do is iterate through all N edges and eliminate the maximum weighted edge forming a spanning tree of N - 1 edges containing the minimum sum of edges, forming a Minimum Spanning Tree.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "MST in linear time\r\n                \r\nI'm preparing to the final exam in Algorithms and I have a question, that i hope you guys can help me with.\n\nGiven an undirected Graph with weights between 1 to 100, how can I find the Minimum Spanning Spanning Tree in a linear time ?\n    ", "Answer": "\r\nYou could use Kruskal's algorithm with disjoint-set and sort edges using counting sort, because your weights are limited.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Derive relationship between sum of all edge weights and MST in a graph satisfying the triangle inequality\r\n                \r\nA weighted, undirected graph with n vertices and m edges is said to satisfy the triangle inequality if for every edge (u, v), the weight of (u, v) is less than or equal to the length of any other alternate path from u to v.\n\nProve that for such a graph, the total weight of all edges is <= (m-n+1)*MST, where MST is the total weight of all edges of the minimum spanning tree.\n\n(Hint: What is the maximum possible weight of an edge of the graph that does not belong to the minimum spanning tree?)\n    ", "Answer": "\r\nSolving the hint\n\nThe weight of an edge that is not in the minimum spanning tree is less than or equal to MST (by the triangle inequality).\n\nTo see this, consider the case where the only other path from u to v is the whole of the minimum spanning tree. (Some other path must exist or else the edge would be in the minimum spanning tree, which is a contradiction.) Then, by the triangle inequality this edge's weight must be less than or equal to the weight of this alternate path, which is MST.\n\nAttempt at the rest of the problem\n\nThere can be at most m-n+1 edges not in the spanning tree. (In a graph where there are the same number of nodes and edges, at most one edge is not in the MST). \n\nThe total weight of these edges is <= MST * (m-n+1). But then when you add the weight of the edges in the minimum spanning tree, you get that the sum of all the weights of the edges in the graph is <= MST * (m-n+2), which is not quite as tight as the bound that you wanted. So there must be another trick to the question.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "minimumSpanningTree throws NullPointerException\r\n                \r\nI've stared and stared at this and it's driving me mad. \n\nSomehow ```\ne = pq.poll( );```\n makes e have a value of null during a test case for a large minimum spanning tree. A tiny minimum spanning tree works.\n\nI am very grateful for all hints on this problem, and how to solve such problems, as i feel i am way above my head here.\n\nThank you for your help!\n\nedit: it seems my priority queue is empty somehow. Can't figure out why that is though \n:/\n\nedit2: I've added the DisjSet class here for extra insight\n\n```\npublic MyMiniGraph<T> generateMinimumSpanningTree()\n{\n    int edgesAccepted = 0;\n      //give all nodes to a class representing disjoint sets\n    DisjSet<T> ds = new DisjSet<T>( theGraph.keySet() );\n\n      //set up a new graph to represent the minimum spanning tree\n    MyMiniGraph<T> minSpanTree = new MyMiniGraph<T>();\n      //initialize minSpanTree with all theGraphs nodes\n    Iterator<T> nodeIter = theGraph.keySet().iterator();\n    while(nodeIter.hasNext())\n        minSpanTree.addNode( nodeIter.next() );\n\n      //order all edges in theGraph in a priority queue\n    PriorityQueue<Edge> pq = new PriorityQueue<Edge>(allEdges);\n    Edge e;\n\n      // Kruskals algorithm. Accepts the smallest edges in order\n      // if they are not part of the same set which would cause a cycle. \n    while(edgesAccepted < currentSize-1)\n    {\n        e = pq.poll( );\n\n        T uset = ds.find( e.n1 );\n        T vset = ds.find( e.n2 );\n\n        if(uset != vset)\n        {\n            // Accept the edge\n            edgesAccepted++;\n            ds.union(uset, vset);\n\n             //if the edge is accepted, add it to minSpanTree\n            minSpanTree.connectNodes(e.n1, e.n2, e.cost);\n        }\n\n    }\n    return minSpanTree;\n}\n```\n\n\nclass declaration and some members:\n\n```\npublic class MyMiniGraph<T extends Comparable<? super T>> implements MiniGraph<T>\n{\n      // The Graph containing all the nodes and their edges\n    private Map< T, HashSet<Edge> > theGraph = new HashMap< T, HashSet<Edge> >( );\n      // Keeps track of theGraphs current size\n    private int currentSize = 0;\n      // Keeps track of the current Edge quantity\n    private int numEdges = 0;\n      // TreeSet containing all edges\n    private TreeSet<Edge> allEdges = new TreeSet<Edge>();\n      // edge representing class with its associated nodes and weight\n```\n\n\nthe DisjSet class:\n\n```\nimport java.util.*;\n\npublic class DisjSet<K extends Comparable<? super K>>\n{\n  //HashMap containing 1. K itself, 2. Ks parent. K no.2 is null if K has no parent \nprivate HashMap<K,K> sets = new HashMap<K,K>();\n\npublic DisjSet(Set<K> s)\n{\n    if(s.isEmpty())\n        throw new IllegalStateException(\"Empty DisjSet argument\");\n\n    Iterator<K> nodes_iter = s.iterator();\n\n    while(nodes_iter.hasNext())\n        sets.put( nodes_iter.next(), null );\n}\n  // recursive method to find o_nodes sets root node\npublic K find(K o_node)\n{\n    if(sets.get(o_node) == null)\n        return o_node;\n    else\n        return find( sets.get(o_node) );\n}\n/**\n * connects set 2 to set 1\n * @param root1     root of set 1 \n * @param root2     root of set 2\n */\npublic void union( K root1, K root2)\n{\n    sets.put(root2, root1);\n}\n}\n```\n\n\nFailure trace if it helps?:\n\n```\njava.lang.NullPointerException\nat MyMiniGraph.generateMinimumSpanningTree(MyMiniGraph.java:274)\nat MyMiniGraphTest.testGenerateMinimumSpanningTreeLarge(MyMiniGraphTest.java:401)\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\nat java.lang.reflect.Method.invoke(Unknown Source)\nat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)\nat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\nat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)\nat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\nat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)\nat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76)\nat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\nat org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)\nat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)\nat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)\nat org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)\nat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)\nat org.junit.runners.ParentRunner.run(ParentRunner.java:236)\nat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:49)\nat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\nat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)\nat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)\nat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)\nat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)\n```\n\n    ", "Answer": "\r\nTry calling ```\npq.take()```\n and not ```\npq.poll()```\n. Poll will return null on an empty queue, take will block until there is an element available. \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Graph algorithms: Prim\r\n                \r\nI was wondering if any minimum spanning tree of a graph G can be provided by an execution of the algorithm Prim on this graph?\n\nDoes the Prim algorithm give us all the possible MST?\n    ", "Answer": "\r\n\n  I was wondering if any minimum spanning tree of a graph G can be\n  provided by an execution of the algorithm Prim on this graph?\n\n\nYes.\n\n\n  Prim's algorithm is known to be a good algorithm to find a minimum\n  spanning tree.\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "camerini algorithm to find minimum bottleneck spanning tree, proof\r\n                \r\nI'm looking for a proof for camerini algorithm for finding MBST in undirected graph .\nI couldn't find anywhere and I couldn't do it myself.\nThanks. \nproblem explanation\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "What's the difference between the minimum spanning tree algorithm for undirected vs directed graphs?\r\n                \r\nIs the undirected graph MST algorithms (Prim's or Kruskal's) a general form of the directed MST algorithm (Edmond/Chiu)?  How come it's so difficult to find the MST source code for the directed case?  Can we use the undirected solution to obtain the MST in a directed graph?\n\nThis is related to the following:\nWhy can't Prim's or Kruskal's algorithms be used on a directed graph?\n    ", "Answer": "\r\nThe core of your question seems to be what makes finding an MST (technically called an optimum branching or minimum-cost arborescence) in a directed graph different and therefore harder than finding an MST in an undirected graph.\nBoth Prim's and Kruskal's algorithms work because of the cut property. If G = (V, E) is a graph, then for any cut (S, V - S) in G, if there is a least-cost edge {u, v} crossing that cut, that edge must belong to all MSTs of G. Unfortunately, this property isn't true in the directed case. Here's a counterexample:\n```\n      2\n  A ----> B\n  |      | ^\n1 |  -99 | | 1\n  |      v |\n  +-----> C\n```\n\nHere, the minimum-cost arborescence rooted at A is this one:\n```\n      2\n  A ----> B\n          |\n      -99 |\n          v\n          C\n```\n\nHowever, look at the cut ({A}, {B, C}) The least-cost edge crossing this cut is the edge (A, C), but that edge doesn't appear in any minimum-cost arborescence rooted at A.\nWithout the cut property, Prim's algorithm and Kruskal's algorithm both fail. Try running Prim's algorithm on the graph given here, starting with node A as your included node. You'll add in edge (A, C), then edge (C, B), giving a suboptimal arborescence. Now, try running Kruskal's algorithm here. You'll first add edge (B, C), then add edge (A, C). Unfortunately, this isn't actually an arborescence because it has no root node.\nThe standard algorithm for finding minimum-cost arborescences (Edmonds-Chu) is actually probably closer in spirit to Boruvka's algorithm. Boruvka's algorithm works by simultaneously choosing, for each node, the least-cost edge connected to that node and adding it to the candidate MST. You then contract all CC's formed this way into single nodes and repeat this process until you have your tree.\nIn the undirected case, as long as the edge weights are distinct, this algorithm will never introduce a cycle (it's a good exercise to prove this), but this isn't the case in directed algorithms. The graph given above is a good example of this - if you try this, you pick (A, C) from A, (C, B) from C, and (B, C) from B, forming the cycle (B, C, B). The correction that the Edmonds-Chu algorithm uses works by contracting one of these cycles into a single node, then repeating this process in the reduced graph and \"uncontracting\" the cycles based on the result. In that sense it's similar to Boruvka's algorithm, though with appropriate modifications.\nHope this helps!\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Finding a Minimum Spanning Tree given the old MST and a new vertex + edges\r\n                \r\nIn a sample problem, I'm given a MST T for a weighted graph G = (V, E). The question is, if a new vertex v and all its edges are to be added to the graph, what is an o(|V|log|V|) algorithm to compute the new MST of this new G* = (V U v, E*).\n\nMy only idea so far is:\n\n```\nadd min( out(v) ) to T\nfor each edge e in out(v) do\n  let u be the other vertex of e\n  if there exists a lower weight path from v to u then\n    remove all edges in that path from T\n    add e to T\n```\n\n\nTwo problems:\n\n\nWhat do I do with the vertices that may have gotten disconnected\nThis is definitely not O(|V|log|V|)\n\n\nHow can I do this?\n    ", "Answer": "\r\nYou can also do it in linear time (if the number of the new edges(say k) is considerably less comparing to n). We know new MST should cover the new vertex. So at least one of the new edges must be added. So the edge with the smallest value must be added to MST (you can prove this); it might happen that more than one new edge changes. \nSo sort new edges from in ascending order \nAdd the first one to the graph; now we have a new cycle. Doing graph traversal find the cycle and delete the edge with the maximum value from this cycle. \nNow add the other new edge and repeat the procedure. \n\nThe complexity is (n+m) times the number of newly added edges(roughly linear). \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Finding a Minimum Spanning Tree given the old MST and a new vertex + edges\r\n                \r\nIn a sample problem, I'm given a MST T for a weighted graph G = (V, E). The question is, if a new vertex v and all its edges are to be added to the graph, what is an o(|V|log|V|) algorithm to compute the new MST of this new G* = (V U v, E*).\n\nMy only idea so far is:\n\n```\nadd min( out(v) ) to T\nfor each edge e in out(v) do\n  let u be the other vertex of e\n  if there exists a lower weight path from v to u then\n    remove all edges in that path from T\n    add e to T\n```\n\n\nTwo problems:\n\n\nWhat do I do with the vertices that may have gotten disconnected\nThis is definitely not O(|V|log|V|)\n\n\nHow can I do this?\n    ", "Answer": "\r\nYou can also do it in linear time (if the number of the new edges(say k) is considerably less comparing to n). We know new MST should cover the new vertex. So at least one of the new edges must be added. So the edge with the smallest value must be added to MST (you can prove this); it might happen that more than one new edge changes. \nSo sort new edges from in ascending order \nAdd the first one to the graph; now we have a new cycle. Doing graph traversal find the cycle and delete the edge with the maximum value from this cycle. \nNow add the other new edge and repeat the procedure. \n\nThe complexity is (n+m) times the number of newly added edges(roughly linear). \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum Weighted Path Tree of an Undirected Graph\r\n                \r\nAssume that we have an undirected graph G=(V,E) and we have two nodes S and X. \n\n\nCan we come up with an algorithm such that the largest weight of the edge on the path from S to X is minimized? Note that it is not the shortest path algorithm since we are not interested in minimizing their sum.\nWhat is the complexity of this algorithm?\nIs the minimum spanning tree algorithm (such as Prim) is a solution for the problem?\n\n    ", "Answer": "\r\nI don't know if minimum spanning tree will solve it or not, but it's certainly solvable by making some modifications to Dijkstra's algorithm.\n\nDefine the \"length\" of a path as the maximum edge in that path. Now find the shortest path from S to X using Dijkstra's algorithm. This is the path you are looking for.\nComplexity is ```\nO((N+M)log N)```\n if you use a binary heap and ```\nO(N * log N + M)```\n with a Fibonacci heap.\n\nNote that for this new definition of path length, if the length of a path is ```\nl```\n, then adding an edge to the end of the path will not decrease it's length, since the maximum edge in that path can only increase. This property is necessary for Dijkstra's algorithm to work correctly.\n\nFor instance, if you were looking for the path with the shortest edge, then Dijkstra's algorithm will fail just like it fails when there are negative edges in the graph.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "BOOST graph queries\r\n                \r\nI have the following queries:\n\n\nI want to know how to create a graph dynamically \nHow to manage multiple weights on a graph \nHow to find the distance from a particular node to another in a minimum spanning tree using kruskal.In kruskals the minimum spanning tree is output as a vector of edges.Hence the vertices are not explicitly stored. I do not know how to get the distance for say an example node 0 to the node furthest from it. I tried getting the vertices using sourc and target and then storing the verices in an array.After that, locating node 0 and from there iterating and reverse iterating through the vertices calculating the weights to find the largest diatance from the node 0. But I fell I'm using the most round about way of going about it.There must be a function for this, or perhaps a clevere way of going about this.\nDoes kruskal store the edges in the spanning tree in order of the spanning tree? Or at least is the first node of the first edge stored the actual first node? How can I get the order of the nodes in spanning tree in kruskals? \nSimilarly how can I get the weight of the spanning tree using Prim? The way I did it was to use the predecessor array where predecessors are stored and find what edge in weightsMap and add it.Is there an easier way? And in prims the distanceMap stores the distance from node 0 to the others in the original graph and not the spanning tree right?\n\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Testing for a circuit when implementing Kruskalls algorithm\r\n                \r\nI'm trying to write a program that would find the minimum spanning tree. But one problem I am having with this algorithm, is testing for a circuit. What would be the best way to do this in java.\n\nOk here is my code\n\n```\nimport java.io.*;\nimport java.util.*;\n\npublic class JungleRoads \n{\n    public static int FindMinimumCost(ArrayList graph,int size)\n    {\n        int total = 0;\n        int [] marked = new int[size];      //keeps track over integer in the mst\n\n        //convert an arraylist to an array\n        List<String> wrapper = graph;\n        String[] arrayGraph = wrapper.toArray(new String[wrapper.size()]);\n        String[] temp = new String[size];\n        HashMap visited = new HashMap();\n\n\n        for(int i = 0; i < size; i++)\n        {\n           // System.out.println(arrayGraph[i]);\n            temp = arrayGraph[i].split(\" \");\n\n            //loop over connections of a current node\n            for(int j =  2; j < Integer.parseInt(temp[1])*2+2; j++)\n            {\n\n                if(temp[j].matches(\"[0-9]+\"))\n                {\n                    System.out.println(temp[j]);\n                }\n            }\n\n\n        }\n\n\n        graph.clear();\n        return total;\n\n\n    }\n\n\n    public static void main(String[] args) throws IOException\n    {\n\n         FileReader fin = new FileReader(\"jungle.in\");\n        BufferedReader infile = new BufferedReader(fin);\n\n        FileWriter fout = new FileWriter(\"jungle.out\");\n        BufferedWriter outfile = new BufferedWriter(fout);\n\n\n        String line;\n        line = infile.readLine();\n        ArrayList graph = new ArrayList();\n\n        do\n        {\n\n            int num = Integer.parseInt(line);\n            if(num!= 0)\n            {\n\n                int size = Integer.parseInt(line)-1;\n\n                for(int i=0; i < size; i++)\n                {\n                    line = infile.readLine(); \n                    graph.add(line);\n                }\n\n               outfile.write(FindMinimumCost(graph, size));\n            }   \n\n\n            line = infile.readLine();\n        }while(!line.equals(\"0\"));\n\n    }\n}\n```\n\n    ", "Answer": "\r\nKruskall's algorithm doesn't searche for cycles, because it's not performance efficient; instead creates disjoint  trees, and then connects them. Since connecting two distinct subtrees with a single edge creates a new tree, there is no need to check for cycles.\nIf you look at wiki page algorithm is as follow:\n```\n1. create a forest **F** (a set of trees), where each vertex in the graph is a separate tree\n2. create a set S containing all the edges in the graph\n3. while S is nonempty and F is not yet spanning\n    a. remove an edge with minimum weight from S\n    b. if that edge connects two different trees, then add it to the forest, combining \n       two trees into a single tree\n    c. otherwise discard that edge.\n```\n\nYou should use Disjoint Set Data Structure for this. again from wiki:\n\nfirst sort the edges by weight using a comparison sort in O(E log E)\ntime; this allows the step \"remove an edge with minimum weight from S\"\nto operate in constant time. Next, we use a disjoint-set data\nstructure (Union&Find) to keep track of which vertices are in which\ncomponents. We need to perform O(E) operations, two 'find' operations\nand possibly one union for each edge. Even a simple disjoint-set data\nstructure such as disjoint-set forests with union by rank can perform\nO(E) operations in O(E log V) time. Thus the total time is O(E log E)\n= O(E log V).\n\n\n#Creating Disjoint Forests\nNow you can take a look at Boost Graph Library-Incremental Components part.\nYou should implement some methods: MakeSet, Find, Union, After that you can implement Kruskall's algorithm. All you doing is working with sets, and simplest possible way to do so is using linked list.\nEach set has one element named as representative element which is the first element in the set.\n1- First implement MakeSet by linked lists:\n\nThis prepares the disjoint-sets data structure for the incremental\nconnected components algorithm by making each vertex in the graph a\nmember of its own component (or set).\n\nJust initialize each vertex (element) as a representative element of new set, we can do this by setting them as themselves' parent:\n```\n function MakeSet(x)\n   x.parent := x\n```\n\n2- Implement Find method:\nFind representative element of a set that contains a vertex ```\nx```\n:\n```\n function Find(x)\n if x.parent == x\n    return x\n else\n    return Find(x.parent)\n```\n\nThe ```\nif```\n part checks the element is representative element or not. we set all representative elements of sets as their first element by setting them as themselves parent.\n3- And finally when all previous steps are done, simple part is implementing the Union method:\n```\nfunction Union(x, y)\n xRoot := Find(x) // find representative element of first element(set)\n yRoot := Find(y) // find representative element of second element(set)\n xRoot.parent := yRoot // set representative element of first set \n                       // as same as representative element of second set\n```\n\nNow how you should run Kruskall?\nFirst put all nodes in ```\nn```\n disjoint sets by MakeSet method. In each iteration after finding desired  edge (not marked and minimal one), find related sets of its endpoint vertices by Find method (their representative elements), if they are the same, drop this edge out because this edge causes a cycle, but If they are in different sets, use Union method to merge these sets. Since each set is a tree their union is a tree.\nYou can optimize this by choosing better data structure for disjoint sets, but for now I think this is enough. If you are interested in more advanced data structures, you can implement rank base method, there is a good documentation about it in wiki, it's easy but I didn't mention it to prevent from bewilderment.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Generate number of edges between two nodes\r\n                \r\nI generated this Minimum Spanning Tree using Kruskal algorithm and I have a hard time generating paths between two nodes. Can someone help me with pseudocode? I tried using Adjacency List and Adjaceny matrix\n\n```\nLoc1 |  Loc2 |  Distance\n  02 |   10  |    2.00 Km\n  05 |   07  |    5.39 Km\n  02 |   09  |    5.83 Km\n  04 |   05  |    5.83 Km\n  06 |   08  |    5.83 Km\n  03 |   09  |    7.07 Km\n  01 |   04  |    11.18 Km\n  07 |   09  |    11.18 Km\n  07 |   08  |    15.81 Km\nTotal Weight = 70.12 Km\n----------------------------------------------------\n```\n\n    ", "Answer": "\r\nIf you just want any path between two nodes, a Breadth First Search would do, and would generate the shortest path (because its a minimum spanning tree).\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to find the min cost to span the entire graph given the start and end vertices in a graph\r\n                \r\nI have been given the start and the target vertices. Now the problem is that I have to reach the target from the start vertex covering all the other vertices in minimum cost. Is is a mixture of shortest path and minimum spanning tree. How to approach this problem. \n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Networkx and Plotly edges do not match\r\n                \r\nI'm trying to use Networkx 2.1 and Plotly 2.7.0 to generate a graph of a minimum spanning tree using a distance matrix as input. I am using Python 2.7.\n\nThe problem is that the edges of the nodes shown in the Plotly graph do not match the edgelist of the Networkx minimum spanning tree.\n\nThe distance matrix (csv file) has this format:\n\n```\nST0_1,0,0,1109,1109,1091,1091,1125,1126,1126,1125,1127,1126,1127,1127,1125,1125,1125,1126,1126,1127,1127,1127,1127,1122,1130,1126,1127\nST0_2,0,0,1109,1109,1091,1091,1125,1126,1126,1125,1127,1126,1127,1127,1125,1125,1125,1126,1126,1127,1127,1127,1127,1122,1130,1126,1127\nST1_3,1109,1109,0,0,1107,1107,1047,1048,1048,1047,1049,1048,1049,1049,1049,1049,1049,1047,1049,1049,1047,1047,1047,1050,1050,1049,1049\nST1_4,1109,1109,0,0,1107,1107,1047,1048,1048,1047,1049,1048,1049,1049,1049,1049,1049,1047,1049,1049,1047,1047,1047,1050,1050,1049,1049\nST22_5,1091,1091,1107,1107,0,0,1100,1101,1101,1100,1102,1101,1102,1102,1101,1101,1101,1101,1100,1102,1101,1101,1102,1099,1103,1102,1102\nST22_6,1091,1091,1107,1107,0,0,1100,1101,1101,1100,1102,1101,1102,1102,1101,1101,1101,1101,1100,1102,1101,1101,1102,1099,1103,1102,1102\nST2,1125,1125,1047,1047,1100,1100,0,5,6,8,8,9,8,10,7,7,8,11,16,12,8,7,11,72,43,11,17\nST7,1126,1126,1048,1048,1101,1101,5,0,1,7,3,4,3,5,6,6,7,10,15,13,7,6,10,72,43,6,16\nST9,1126,1126,1048,1048,1101,1101,6,1,0,8,2,3,2,4,7,7,8,11,16,14,8,7,11,73,44,5,17\nST5,1125,1125,1047,1047,1100,1100,8,7,8,0,10,11,10,12,7,7,8,7,16,16,10,9,13,73,44,13,17\nST13,1127,1127,1049,1049,1102,1102,8,3,2,10,0,3,2,4,9,9,10,13,18,16,10,9,13,75,46,7,19\nST11,1126,1126,1048,1048,1101,1101,9,4,3,11,3,0,3,1,10,10,11,14,19,17,11,10,14,76,47,8,20\nST10,1127,1127,1049,1049,1102,1102,8,3,2,10,2,3,0,4,9,9,10,13,18,16,10,9,13,75,46,7,19\nST12,1127,1127,1049,1049,1102,1102,10,5,4,12,4,1,4,0,11,11,12,15,20,18,12,11,15,77,48,9,21\nST16_7,1125,1125,1049,1049,1101,1101,7,6,7,7,9,10,9,11,0,0,3,10,15,15,9,8,12,72,43,12,16\nST16_8,1125,1125,1049,1049,1101,1101,7,6,7,7,9,10,9,11,0,0,3,10,15,15,9,8,12,72,43,12,16\nST15,1125,1125,1049,1049,1101,1101,8,7,8,8,10,11,10,12,3,3,0,11,16,16,10,9,13,73,44,13,17\nST6,1126,1126,1047,1047,1101,1101,11,10,11,7,13,14,13,15,10,10,11,0,17,15,11,12,12,70,43,14,18\nST18,1126,1126,1049,1049,1100,1100,16,15,16,16,18,19,18,20,15,15,16,17,0,22,16,17,18,77,49,21,7\nST17,1127,1127,1049,1049,1102,1102,12,13,14,16,16,17,16,18,15,15,16,15,22,0,14,15,15,75,50,15,23\nST4,1127,1127,1047,1047,1101,1101,8,7,8,10,10,11,10,12,9,9,10,11,16,14,0,1,3,73,44,13,17\nST3,1127,1127,1047,1047,1101,1101,7,6,7,9,9,10,9,11,8,8,9,12,17,15,1,0,4,74,45,12,18\nST8,1127,1127,1047,1047,1102,1102,11,10,11,13,13,14,13,15,12,12,13,12,18,15,3,4,0,72,47,14,20\nST21,1122,1122,1050,1050,1099,1099,72,72,73,73,75,76,75,77,72,72,73,70,77,75,73,74,72,0,83,74,79\nST20,1130,1130,1050,1050,1103,1103,43,43,44,44,46,47,46,48,43,43,44,43,49,50,44,45,47,83,0,49,50\nST14,1126,1126,1049,1049,1102,1102,11,6,5,13,7,8,7,9,12,12,13,14,21,15,13,12,14,74,49,0,22\nST19,1127,1127,1049,1049,1102,1102,17,16,17,17,19,20,19,21,16,16,17,18,7,23,17,18,20,79,50,22,0\n```\n\n\nHere is the Python script:\n\n```\nimport csv\nimport numpy as np\nimport networkx as nx\nfrom plotly.offline import plot\nimport plotly.graph_objs as go\nfrom networkx.drawing.nx_agraph import graphviz_layout\n\ndef read_dist_matrix(file_name):\n    \"\"\" Reads a distance matrix in PHYLIP format.\n\n        Requires: file_name is the name of a file that has the distance matrix\n        in PHYLIP format.\n        Ensures: distance matrix as numpy array and a list with the names/ids of\n        each sequence.\n    \"\"\"\n\n    with open(file_name) as f:\n        #first_line = f.readline().strip()\n        reader = csv.reader(f, delimiter=',')\n        names = list(zip(*reader))[0]\n\n    cols = tuple(list(range(1,len(names)+1)))\n\n    dist_matrix = np.loadtxt(file_name, delimiter=',',\n                             usecols=cols)\n\n    return [dist_matrix, names]\n\n\ndef dist_to_graph(matrix, names):\n    \"\"\" Converts numpy array representing distance matrix to graph.\n\n        Requires: matrix as a numpy array. names as a list with the names\n        of each row/column.\n        Ensures: networkx graph labeled with the right names.\n    \"\"\"\n\n    G = nx.from_numpy_matrix(matrix)\n\n    nodes = list(G.nodes())\n\n    names_dict = {}\n    for n in range(len(nodes)):\n        names_dict[nodes[n]] = names[n]\n\n    G = nx.relabel_nodes(G, names_dict)\n\n    return G\n\nola = read_dist_matrix(\"out.csv\")\nola_g = dist_to_graph(ola[0], ola[1])\n\nmst = nx.minimum_spanning_tree(ola_g, algorithm='prim')\npos = graphviz_layout(mst, prog='neato')\nlabels = list(mst.nodes.keys())\n\nX = []\nY = []\n\nfor k in pos:\n    X.append(pos[k][0])\n    Y.append(pos[k][1])\n\n\ntracer = go.Scatter(x=X, y=Y,\n                    mode='lines',\n                    line=go.Line(color='#888', width=2),\n                    hoverinfo = 'none',\n                    showlegend=False)\n\ntracer_marker = go.Scatter(x=X, y=Y,\n                    mode='markers+text',\n                    text=labels,\n                    textposition='top',\n                    marker = go.Marker(size= 15,\n                                       line = dict(width = 2)),\n                    hoverinfo = 'none',\n                    showlegend=False)\n\nlayout = dict(title='Test', showlegend=False, \n              xaxis=dict(title='', \n                         titlefont=dict(size=20), \n                         showgrid=False, \n                         zeroline=False, \n                         showline=False, \n                         ticks='', \n                         showticklabels=False, \n                         showspikes=False),\n              yaxis=dict(title='', \n                         titlefont=dict(size=20), \n                         showgrid=False, \n                         zeroline=False, \n                         showline=False, \n                         ticks='', \n                         showticklabels=False, \n                         showspikes=False)\n                           )\n\nfig = dict(data=[tracer, tracer_marker], layout=layout)\n\nplot(fig, filename='./test_plotly.html', auto_open=True, show_link=False)\n```\n\n\nThis is a screenshot of the output HTML:\n\n\n\nIf we run the command ```\nmst.edges(data=True)```\n we see that the nodes ST7 and ST5 are connected but in the Plotly graph they aren't.\n\nA similar question has been asked here, but it was on R: \n\nCan anyone help me with this?\n    ", "Answer": "\r\nYou have multiple dicts that you are using.  The order that keys are returned in dicts cannot be accurately predicted.\n\nI don't think you have any guarantee that ```\nlist(mst.nodes.keys())```\n will be in the same order as ```\nX```\n and ```\nY```\n.  So I suspect that the label ```\nST7```\n is being applied to a different node.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Boost -- Kruskal minimum spanning tree -- guarantee of returning edges in ascending order of weights\r\n                \r\nConsider the algorithm's description provided here.\nThe algorithm sorts the provided edges in ascending order and processes them in this order. The code example provided on boost website gives an example of calling the algorithm via the call:\n```\nstd::vector< Edge > spanning_tree;\nkruskal_minimum_spanning_tree(g, std::back_inserter(spanning_tree));\n```\n\nAfter running the algorithm, the edges of the MST are accessible via:\n```\nstd::cout << \"Print the edges in the MST:\" << std::endl;\nfor (std::vector< Edge >::iterator ei = spanning_tree.begin();ei != spanning_tree.end();++ei){\n    std::cout << source(*ei, g) << \" <--> \" << target(*ei, g)<<\" with weight of \" << weight[*ei] << std::endl;\n}\n```\n\nIs it guaranteed that the edges of the MST returned back in ```\nspanning_tree```\n are stored in ascending order of the edge weights?\n    ", "Answer": "\r\nWhen we trace the code, we see that we pass a vector of edges called \"spanning_tree\" to the algorithm, if you check the output iterator (in the boost/graph/kruskal_min_spanning_tree.hpp header file), then you find that edges are added to it in the ordered that they were processed in, and since in Kruskal's algorithm we should process edges in ascending order then it is guaranteed that the returned vector contains edges sorted in ascending order.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How can I write a MST algorithm (Prim or Kruskal) in Haskell?\r\n                \r\nI can write both Prim's and Kruskal's algorithms to find a minimum spanning tree in C++ or Java, but I want to know how to implement them in Haskell with O(mlogm) or O(mlogn) (pure functional programs is better). Thanks a lot.\n    ", "Answer": "\r\nAs svenningsson suggests,  priority search queue is well suited for both Kruskal's and Prim's (atleast the author proclaims it in his paper.) The problem with Kruskal is that it requires that you have an O(log n) union-find algorithm. A union-find datastructure with a purely functional interface is described here, but it uses mutable state internally, and a purely functional implementation might be impossible and in fact, there are several problems where an efficient purely functional solution is not known, as discussed in this related SO question.\n\nA non-pure alterenative is to implement union-find algorithm in the ST monad. A search on Hackage finds that the equivalence package suits our needs. Following is an implementation of Kruskal using Data.Equivalence.Monad from the equivalence package:\n\n```\nimport Data.Equivalence.Monad\nimport Data.Graph as G\nimport Data.List(sortBy)\nimport Data.Map as M\nimport Control.Monad(filterM)\nimport Data.Ord(comparing)\n\nrun = runEquivM (const ()) (const $ const ())\n\nkruskal weight graph = run $\n filterM go (sortBy (comparing weight) theEdges)\n     where\n      theEdges = G.edges graph\n      go (u,v) = do \n        eq <- equivalent u v\n        if eq then return False else\n         equate u v >> return True\n```\n\n\nIt can be used like this: \n\n```\nfromL xs = fromJust . flip M.lookup (M.fromList xs)\n\ntestWeights = fromL [((1,2),1),((2,3),4),((3,4),5),((1,4),30),((1,3),4)]\ntestGraph = G.buildG  (1,4) [(1,2),(2,3),(3,4),(1,4),(1,3)]\ntest = kruskal testWeights testGraph\n```\n\n\nand running test gives:\n\n```\n[(1,2),(1,3),(3,4)]\n```\n\n\nIt should be noted that the running time is dependent on weights running in O(1) time, however ```\nfromL```\n creates a weight function running in O(log(n)) time, this can be improved to O(1) time by using arrays or just keeping track of the weight in the input list, but it's not really part of the algorithm.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "tree partitioning\r\n                \r\nI have a 2d symmteric matrix \"myMSTdata[][]\" that represents weighted edge minimum spanning tree MST (zero if there is no direct edge) and I need to cut that MST on the edge with maximum weight such that I have two subtree partitions (part1,part2). Is there any easy or cheap way to do so? or is there any library that I can use for doing so?  \n    ", "Answer": "\r\nHave a look at the ```\nboost::graph```\n library:\nhttp://www.boost.org/doc/libs/1_48_0/libs/graph/doc/prim_minimum_spanning_tree.html\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Does a DFS produce a MST for an unweighted directed graph?\r\n                \r\nI'm getting confused from reading online posts. I know that a BFS traversal on an unweighted directed graph will produce a minimum spanning tree and shortest path. Can a DFS traversal on an unweighted directed graph do the same?\n    ", "Answer": "\r\nYes, Breadth-First and Depth-First both yield spanning trees. It doesn't make much sense to discuss \"minimum spanning tree\" for an unweighted graph, because all spanning trees on a given graph with n vertices have the same number of vertices (n) and the same number of edges (n-1).\nNo, Depth-First does not guarantee shortest path. You really need Breadth-First for that. Consider a cyclic graph:\n```\na - h - g - f\n|           |\nb - c - d - e\n```\n\nStarting from vertex a, there are two possible results to depth-first search: a->b->c->d->e->f->g->h, and a->h->g->f->e->d->c->b. The former returns a very long path from a to h, and the latter returns a very long path from a to b.\nNote that in this example, the graph is undirected. But undirected graphs are a special case of directed graphs; you can replace every undirected edge by two directed edges in opposing directions.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Chu-Liu Edmond's algorithm (for directed graph)\r\n                \r\nI like to find a minimum spanning tree (or even forest) in a directed graph (which sometimes might have cycle). The one explained here has some errors. Is there any package/code for this algorithm in Python which actually works?\n    ", "Answer": "\r\nEven though I haven't used it, here's an implementation from GitHub.\nI've attached the essence of it below.\nSince it's a GitHub repository, it may change so it's preferable to use the code from there.\nIf you use this, please give credit to the author: Martin-Louis Bright.\n\n```\n    import sys\n\n\ndef _input(filename):\n    prices = {}\n    names = {}\n\n    for line in file(filename).readlines():\n        (name, src, dst, price) = line.rstrip().split()\n        name = int(name.replace('M',''))\n        src = int(src.replace('C',''))\n        dst = int(dst.replace('C',''))\n        price = int(price)\n        t = (src,dst)\n        if t in prices and prices[t] <= price:\n            continue\n        prices[t] = price\n        names[t] = name\n\n    return prices,names\n\ndef _load(arcs,weights):\n    g = {}\n    for (src,dst) in arcs:\n        if src in g:\n            g[src][dst] = weights[(src,dst)]\n        else:\n            g[src] = { dst : weights[(src,dst)] }\n    return g\n\ndef _reverse(graph):\n    r = {}\n    for src in graph:\n        for (dst,c) in graph[src].items():\n            if dst in r:\n                r[dst][src] = c\n            else:\n                r[dst] = { src : c }\n    return r\n\ndef _getCycle(n,g,visited=set(),cycle=[]):\n    visited.add(n)\n    cycle += [n]\n    if n not in g:\n        return cycle\n    for e in g[n]:\n        if e not in visited:\n            cycle = _getCycle(e,g,visited,cycle)\n    return cycle\n\ndef _mergeCycles(cycle,G,RG,g,rg):\n    allInEdges = []\n    minInternal = None\n    minInternalWeight = sys.maxint\n\n    # find minimal internal edge weight\n    for n in cycle:\n        for e in RG[n]:\n            if e in cycle:\n                if minInternal is None or RG[n][e] < minInternalWeight:\n                    minInternal = (n,e)\n                    minInternalWeight = RG[n][e]\n                    continue\n            else:\n                allInEdges.append((n,e))        \n\n    # find the incoming edge with minimum modified cost\n    minExternal = None\n    minModifiedWeight = 0\n    for s,t in allInEdges:\n        u,v = rg[s].popitem()\n        rg[s][u] = v\n        w = RG[s][t] - (v - minInternalWeight)\n        if minExternal is None or minModifiedWeight > w:\n            minExternal = (s,t)\n            minModifiedWeight = w\n\n    u,w = rg[minExternal[0]].popitem()\n    rem = (minExternal[0],u)\n    rg[minExternal[0]].clear()\n    if minExternal[1] in rg:\n        rg[minExternal[1]][minExternal[0]] = w\n    else:\n        rg[minExternal[1]] = { minExternal[0] : w }\n    if rem[1] in g:\n        if rem[0] in g[rem[1]]:\n            del g[rem[1]][rem[0]]\n    if minExternal[1] in g:\n        g[minExternal[1]][minExternal[0]] = w\n    else:\n        g[minExternal[1]] = { minExternal[0] : w }\n\n\ndef mst(root,G):\n\n\n    RG = _reverse(G)\n    if root in RG:\n        RG[root] = {}\n    g = {}\n    for n in RG:\n        if len(RG[n]) == 0:\n            continue\n        minimum = sys.maxint\n        s,d = None,None\n        for e in RG[n]:\n            if RG[n][e] < minimum:\n                minimum = RG[n][e]\n                s,d = n,e\n        if d in g:\n            g[d][s] = RG[s][d]\n        else:\n            g[d] = { s : RG[s][d] }\n\n    cycles = []\n    visited = set()\n    for n in g:\n        if n not in visited:\n            cycle = _getCycle(n,g,visited)\n            cycles.append(cycle)\n\n    rg = _reverse(g)\n    for cycle in cycles:\n        if root in cycle:\n            continue\n        _mergeCycles(cycle, G, RG, g, rg)\n\n    return g\n\n\nif __name__ == \"__main__\":\n    try:\n        filename = sys.argv[1]\n        root = sys.argv[2]\n    except IndexError:\n        sys.stderr.write('no input and/or root node specified\\n')\n        sys.stderr.write('usage: python edmonds.py <file> <root>\\n')\n        sys.exit(1)\n\n    prices,names = _input(filename)\n    g = _load(prices,prices)\n    h = mst(int(root),g)\n    for s in h:\n        for t in h[s]:\n            print \"%d-%d\" % (s,t)\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How can I use the Delaunay triangulation to output a matrix with all the connections in the triangulation and their distances?\r\n                \r\nI want to use the Delaunay triangulation to calculate the minimum spanning tree for a network for an array of coordinates. How can I obtain all the edges from the triangulation and their distances so I can use them for the MST?\n    ", "Answer": "\r\nThe following code is modified from my previous answer here.\nIt stores the edges (pairs of indices in the points array) as keys of a dictionary with the distances as the dictionary values.\n```\n# Computing Delaunay\ntri = Delaunay(points)\n\n# Building the edges-distance map:\nedges_dist_map = {}\nfor tr in tri.simplices:\n    for i in range(3):\n        edge_idx0 = tr[i]\n        edge_idx1 = tr[(i+1)%3]\n        if (edge_idx1, edge_idx0) in edges_dist_map:\n            continue  # already visited this edge from other side\n        p0 = points[edge_idx0]\n        p1 = points[edge_idx1]\n        dist = np.linalg.norm(p1 - p0)\n        edges_dist_map[(edge_idx0, edge_idx1)] = dist\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Function returning different value than what is in function body before return statement\r\n                \r\nI'm writing a function that returns the path between two nodes in a minimum spanning tree created using kruskal's algorithm\n\n```\nmap<string, set<string>> mst = { \"A\" : [\"B\"]\n                                 \"B\" : [\"A\", \"C\", \"D\"]\n                                 \"C\" : [\"B\"]\n                                 \"D\" : [\"B\", \"E\"]\n                                 \"E\" : [\"D\"] }\n```\n\n\nThe pathfinding algorithm is as follows:\n\n```\nvector<string> findPath(map<string, set<string>> mst, string src, string dest, vector<string> path) {\n    if(src == dest) {\n        cout << \"Function path size: \" << path.size() << endl;\n        return path;\n    }\n    set<string> possible = mst[src];\n    for(vector<string>::iterator it = path.begin(); it != path.end(); it++) {\n        if(possible.find(*it) != possible.end())\n            possible.erase(*it);\n    }\n    for(set<string>::iterator it = possible.begin(); it != possible.end(); it++) {\n        vector<string> a = path;\n        if(find(a.begin(), a.end(), src) == a.end())\n                a.push_back(src);\n        vector<string> p = findPath(mst, *it, dest, a);\n        if(p[0] != \"randValue\") {\n            return path;\n        }\n    }\n    vector<string> p = path;\n    p[0] = \"randValue\";\n    return p;\n}\n```\n\n\nIf I call the function:\n\n```\nvector<string> path;\npath = findPath(mst, \"A\", \"C\", path);\ncout << \"Main path size: \" << path.size() << endl;\n```\n\n\nThe output is:\n\n```\nFunction path size: 2\nMain path size: 0\n```\n\n\nWhy is the function not returning the filled in path?\n    ", "Answer": "\r\nI found the problem in my function, the solution was just swapping one variable:\n\n```\nvector<string> findPath(map<string, set<string>> mst, string src, string dest, vector<string> path) {\n    if(src == dest) {\n        cout << \"Function path size: \" << path.size() << endl;\n        return path;\n    }\n    set<string> possible = mst[src];\n    for(vector<string>::iterator it = path.begin(); it != path.end(); it++) {\n        if(possible.find(*it) != possible.end())\n            possible.erase(*it);\n    }\n    for(set<string>::iterator it = possible.begin(); it != possible.end(); it++) {\n        vector<string> a = path;\n        if(find(a.begin(), a.end(), src) == a.end())\n                a.push_back(src);\n        vector<string> p = findPath(mst, *it, dest, a);\n        if(p[0] != \"randValue\") {\n            /**\n             * RETURN p INSTEAD OF path\n             */\n            return p;\n        }\n    }\n    vector<string> p = path;\n    p[0] = \"randValue\";\n    return p;\n}\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum cost broadcast routing\r\n                \r\nIs there any method where we can get a minimum cost broadcast routing scheme without using the spanning tree algorithm?\n\nAny references to guide me on this will be of great use to me.\n    ", "Answer": "\r\nAny algorithm for implementing a minimum cost broadcast (or multicast) routing scheme in the end boils down to constructing a least-cost spanning tree (rooted at the multicast source) of the full graph which represents the network.\n\nThere are various algorithms for computing the least-cost spanning tree.\n\nIP multicast routing protocols such as PIM rely on least-cost spanning tree which is computed by the IGP (OSPF or ISIS) using the Dijkstra algorithm.\n\nOlder protocols, such as DVMRP, rely on a distance-vector protocol to compute the spanning tree.\n\nOne could theoretically use other algorithms to compute the least-cost spanning tree (e.g. Bellman-Ford) although I know of no implementation that does so in practice.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to organize a MST when one node disappear?\r\n                \r\nI'm doing my research and stuck with a question:\n\nI am having a minimum spanning tree (prim algorithm), now one node in my tree gets deleted, I wonder if there is a way i can re-organize my tree such that the optimality still maintains? \n\nI'm looking for some suggestions here and I will appreciate your help. \n\nThank you!\n    ", "Answer": "\r\nThis problem has been well-studied.  Research done in 2001 found a way to maintain a graph data structure so that you can insert or remove an edge and update the minimum spanning tree in time O(log4 n), which to the best of my knowledge is the best time bound anyone has been able to come up with so far.  The paper describing this algorithm is dense and tricky, but if you're interested you can find it here:\n\nPoly-Logarithmic Deterministic Fully-Dynamic Algorithms for Connectivity, Minimum Spanning Tree, 2-Edge, and Biconnectivity\n\nHope this helps!\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Prim's algorithm modification\r\n                \r\nG=(V,E), and A⊆E\nI've been wondering about how to get the minimum spanning tree, if it needs to contain all edges in A (and still must be of minimum weight), by modifying Prim's algorithm.\n\nCould someone maybe give me some hints/ideas about how to modify the algorithm efficiently?\n    ", "Answer": "\r\nUsing edges from ```\nA```\n will prevent you from getting an actual minimum spanning tree unless the edges in ```\nA```\n are guaranteed to belong to an MST.\n\nHowever, given a set ```\nA```\n you can find the MST that connects all the other vertices to ```\nA```\n.\n\nYou do not indicate a guarantee that the edges in ```\nA```\n form a single connected component, so I assume they do not.\n\nIn this case, using Prim's algorithm is a bad idea because Prim's algorithm assumes that at each step you are adding an edge between a valid MST and a point which is not in the MST. Since the \"MST\" formed by ```\nA```\n may be non-contiguous, this breaks the assumptions of Prim's algorithm.\n\nInstead, use Kruskal's algorithm. It adds edges to an \"MST set\" by considering the edges in order of their length, always choosing the shortest edge first. If both ends of the edge are already in the MST set, then the edge is rejected. If only one edge is in the MST set, then the new edge is added to the MST set.\n\nYou can implement the algorithm like so:\n\n```\nKRUSKAL(G,A):\n  mst_set = ∅\n  for each vertex v ∈ G.V:\n    MAKE-SET(v)\n  for each edge (u,v) in A:\n    mst_set = mst_set ∪ {(u,v)}\n    UNION(u,v)\n  for each edge (u, v) in G.Edges ordered by weight(u, v), increasing:\n    if FIND-SET(u) ≠ FIND-SET(v):\n      mst_set = mst_set ∪ {(u, v)}\n      UNION(u, v)\n  return mst_set\n```\n\n\nwhere the ```\nMAKE-SET```\n, ```\nUNION```\n, and ```\nFIND-SET```\n operations are part of a disjoint-set data structure.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Helper library for distributed algorithms programming?\r\n                \r\nWhen you code a distributed algorithm, do you use any library to model abstract things like processor, register, message, link, etc.? Is there any library that does that?\n\nI'm thinking about e.g. self-stabilizing algorithms, like self-stabilizing minimum spanning-tree algorithms. \n    ", "Answer": "\r\nThere's a DVM system that can be used for implementing different distributed algorithms. It works on top of MPI.\n\nHowever it is more for matrix-oriented scientific algorithms where distribution is done in terms of data blocks. I had a brief experience using it - it's much more convenient than direct usage of MPI and allows for much more readable and maintainable code.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Linear Time Algorithm to Find MST?\r\n                \r\nGiven 2 Algorithms for a graph G=(V,E):\nOne:\n\nSort edges from lowest to highest weight.\nSet T = {}\nfor each edge e in the previous order, check if e Union T doesn't have any cycles.\nIf yes, Add e to T.\nReturn T if it's a spanning Tree.\n\nTwo:\n\nSort edges from highest to lowest weight.\nSet T = E\nfor each edge e in the previous order, check if T{e} is connected graph.\nIf yes, Remove e from T.\nReturn T if it's a spanning Tree.\n\nDo both algorithms return Minimum Spanning Tree for sure?\nIf not I would like to see a counter example.\n    ", "Answer": "\r\nBoth of these algorithms will find an MST if it exists.  The first is Kruskal's algorithm, and the second can be proven equivalent pretty easily.\nNeither of them are linear time unless the weights are constrained somehow, because they start with an O(N log N) edge sort.\nDisregarding the sort, the remainder of Kruskal's algorithm is very close to linear time, because it uses a disjoint set data structure to check for connectivity.\nThe second algorithm doesn't have a similarly quick and straightforward implementation -- anything fast is going to be more difficult than using Kruskal's algorithm instead.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "how to extract elements of a sparse matrix?\r\n                \r\nI have a sparse matrix: \n\n```\n A=\n\n\n  (14,13)      0.5286\n  (15,14)      0.6781\n  (16,15)      0.5683\n  (17,16)      1.2773\n  (18,17)      1.0502\n  (19,18)      0.4966\n  (21,19)      0.9951\n  (21,20)      0.4522\n  (22,21)      0.8507\n  (23,22)      1.0727\n  (24,23)      0.8288\n  (25,24)      0.5811\n  (26,25)      0.8235\n  (28,26)      1.5128\n  (30,28)      0.7966\n  (30,29)      0.6363\n  (31,29)      0.8254\n  (32,31)      0.8573\n  (33,32)      1.0753\n```\n\n\nthat is result of a minimum spanning tree. now I want to extract ```\n13,14,15,...26,28,29,...33```\n.\nas seen 27 is not between numbers. so ```\npred```\n give:   ```\n13    14    15    16    17    18    19    21    22    23    24    25    26    28    29    30    31    32```\n that 20 and 33 is not.\nhow can I extract total of numbers that say in top?\n    ", "Answer": "\r\n```\n[ii jj] = find(A);\nanswer = unique([ii(:); jj(:)]);\n```\n\n\nshould do it.\n\nNote that the ```\nfind```\n command with two outputs gives you the row and column index of all nonzero elements. Since you have a minimum spanning tree, each number you care about needs to occur at least once in the row or column (for example your matrix never has the number ```\n29```\n in the first index, but it occurs in the second).\n\nThe ```\nunique```\n function makes sure that each number that occurs is only represented once.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "making kruskal's algorithm in c (segmentation fault)\r\n                \r\nIn this code I want to make Kruskal's algorithm, which calculates a minimum\nspanning tree of a given graph. And I want to use min-heap and disjoint set at the code.\nTo make time complexity of ```\nO(e log n)```\n, where e is the number of edges and n is the number of vertices in the graph, I will use heap and disjoint set trees.\nSo the method I went with was:\n\nCheck the numbers of vertices and edges in the given input file and make parent array and struct edge which can include at most ```\n10000```\n vertices and ```\n50000000```\n edges.\nSort the edges by the weight in a min heap in descending order.\nTake out edges from min heap one by one and check whether it makes cycle until min heap is empty\nIf the number of edges selected is ```\nvertices-1```\n (if all vertices already connected ) break the while loop and print each edges and sum of weights. If all vertices can make minimum spanning tree it prints connected and if all vertices can not make minimum spanning tree it prints disconnected.\n\nI thought the code is well done but when I run this in putty, it is exiting with segmentation fault (core dumped)\ninput (example)\n```\n7\n9\n0 1 28\n0 5 10\n1 2 16\n1 6 14\n2 3 12\n3 4 22\n3 6 18\n4 5 25\n4 6 24\n```\n\nresult(I want)\n```\n0 5 10\n2 3 12\n1 6 14\n1 2 16\n3 4 22\n4 5 25\n99\nCONNECTED\n```\n\nI checked the edges are well stored in min-heap in descending order. But I think it has mistakes in making minimum spanning tree. These are points that I am suspicious in the code.\n\nShould I make ```\nedge minheap```\n by dynamic allocation instead of ```\nminheap[50000000]```\n?\nShould I make additional data structures apart from the array ```\nparent```\n and ```\nstruct edge```\n.\n\nIt is the code I made! Can you give me help or advice ?\n```\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<time.h>\n\n#define maxvertice 10000\n#define maxedge 50000000\ntypedef struct edge { //structure to store vertices and weight\n    int a, b;\n    int w;\n}\nedge;\n\nint n = 0; //numbers of edge in the minheap \n\nint parent[maxvertice] = {-1,};\n\n\n//array to represent disjoint sets! parent which stores the vertice connected\n//if it is not connected(independent) it's parent is -1 \nedge minheap[maxedge]; //heap that sorts edges \n\nvoid insertheap(edge item, int * n); // arrange edges by the weight in descending order\nedge deleteheap(int * n); //popping out from the root (in descending order)\nvoid makeunion(int x, int y); // this make x and y combined  \nint findparent(int i);\n\n\nint main(int argc, char * argv[]) {\n    double start, end;\n    int i, nv, ne, sumofweight = 0, isitdone;\n    int cnt_edge = 0;\n    edge item;\n    //////////////\n\n    if (argc != 2) {\n        printf(\"usage: ./hw3 input_filename\\n\");\n        return 0;\n    }\n    FILE * fp = fopen(argv[1], \"r\");\n    if (fp == NULL) {\n        printf(\"The input file does not exist.\\n\");\n        return 0;\n    }\n    FILE * result = fopen(\"hw3_result.txt\", \"w\");\n    start = (double) clock() / CLOCKS_PER_SEC;\n\n    fscanf(fp, \"%d\", & nv);\n    printf(\"to test : number of vertices : %d\\n\", nv);\n    fscanf(fp, \"%d\", & ne);\n    printf(\"to test : number of edges : %d\\n\", ne);\n\n    for (i = 0; i < ne; i++) {\n        int firstv, secondv, weight;\n        edge newedge;\n        fscanf(fp, \"%d %d %d\", & firstv, & secondv, & weight);\n        newedge.a = firstv;\n        newedge.b = secondv;\n        newedge.w = weight;\n        // get vertices and edge's weight from the input file and put in heap\n        insertheap(newedge, & n);\n    }\n    /*\n    for(i =0 ; i<ne; i++){\n         item= deleteheap(&n); \n         printf(\"%d\", item.w); \n    }*/\n\n    while (minheap != NULL) { //pop out from the heap until mst is completed\n        item = deleteheap( & n);\n        //union at array parent \n        int par1, par2;\n        par1 = findparent(item.a);\n        par2 = findparent(item.b);\n\n        if (par1 != par2) {\n            makeunion(par1, par2);\n            printf(\"%d %d %d\\n\", item.a, item.b, item.w);\n            cnt_edge = cnt_edge + 1;\n            sumofweight += item.w;\n        }\n\n        if (cnt_edge == nv - 1) break;\n\n    }\n    if (cnt_edge == nv - 1) {\n        // fprintf(result, \"CONNECTED\");\n        printf(\"%d\\n\", sumofweight);\n        printf(\"CONNECTED\");\n\n    }\n    if (cnt_edge < nv - 1) {\n        // fprintf(result, \"DISCONNECTED\"); \n        printf(\"DISCONNECTED\\n\");\n    }\n    end = (((double) clock()) / CLOCKS_PER_SEC);\n    fclose(fp);\n    fclose(result);\n    printf(\"output written to hw3_result.txt.\\n\");\n    printf(\"running time: %1f\", (end - start));\n    printf(\" seconds\\n\");\n\n}\n\nvoid makeunion(int x, int y) {\n    parent[x] = y;\n}\n\nint findparent(int i) {\n    for (; parent[i] >= 0; i = parent[i]);\n    return i;\n}\n\nvoid insertheap(edge item, int * n) {\n    int i;\n    i = * n;\n    ++( * n);\n    while ((i != 0) && (item.w < minheap[i / 2].w)) {\n        minheap[i] = minheap[i / 2];\n        i /= 2;\n    }\n    minheap[i] = item;\n    printf(\"to test : the wieght %d is inserted in :%d \\n\", item.w, i);\n}\nedge deleteheap(int * n) {\n    int parent, child;\n    parent = 0;\n    child = 1;\n    edge item, temp;\n    item = minheap[0];\n    temp = minheap[( * n) - 1];\n    ( * n) --;\n    while (child <= * n) {\n        if ((child < * n) && (minheap[child].w > minheap[child + 1].w)) child++;\n        if (temp.w <= minheap[child].w) break;\n        minheap[parent] = minheap[child];\n        parent = child;\n        child *= 2;\n    }\n    minheap[parent] = temp;\n    return item;\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Parent array is always zero in prims algorithm\r\n                \r\nI have the following function to find the parent array in order to obtain a  minimum spanning tree of a graph using Prim's algorithm.\n\n```\n#include<stdlib.h> \n#include <limits.h>\n#include <iostream>\n\nint printMST(int parent[], int n, int** graph)\n{\nfor (int i = 1; i < n; i++)\nstd::cout<<parent[i]<<\" - \"<<i<<\" \"<<graph[i][parent[i]]<<\"\\n\";\n}\nint* prim(int** graph,int no_of_vertices);\nint main(){\nint no_of_vertices;\nstd::cin>>no_of_vertices;\nint** graph = new int*[no_of_vertices];\nfor(int i = 0; i < no_of_vertices; ++i)\n graph[i] = new int[no_of_vertices];\nfor(int i = 0; i <no_of_vertices; ++i)\nfor(int j = 0; j < no_of_vertices; ++j)\n  std::cin>>graph[i][j];\n\n int* parent;\nparent= prim(graph,no_of_vertices);\n// Print the solution\nprintMST(parent, no_of_vertices, graph);\n return 0;\n}\n\nint nodeWithMinKey(int key[],bool mst[], int no_of_vertices)\n{\nint min=1000,min_index;\n\nfor(int i=0;i<no_of_vertices;i++)\n{\nif(mst[i]=false && key[i]<min)\n    {\n    min=key[i];\n    min_index=i;\n    }\n\n}\n\nreturn min_index;\n}\nint* prim(int** graph, int no_of_vertices){\n    int* parent = (int*)malloc(sizeof(int)*no_of_vertices);\n\n    int key[100];\n    bool mst[100];\n    int i;\n\n    for(i = 0; i<no_of_vertices; i++)\n    {\n        key[i] = 1000;\n        mst[i] = false;\n    }\n\n    key[0] = 0;\n    parent[0] = -1;\n\n    for(i = 0; i<no_of_vertices-1; i++)\n    {\n        int u = nodeWithMinKey(key, mst, no_of_vertices);\n\n        mst[u] = true;\n\n        for(int v = 0; v<no_of_vertices; v++)\n        {\n            if(graph[u][v] && mst[v] == false && graph[u][v] <  key[v])\n            {\n                parent[v] = u;\n                key[v] = graph[u][v];\n            }\n\n        }\n    }\n    return parent;\n}\n```\n\n\nBut the parent array is having all the values as '0'(zero), don't know where the condition has gone wrong.\n    ", "Answer": "\r\nThis line\n\n```\nif(mst[i]=false && key[i]<min)\n```\n\n\nhas an assignment ```\n=```\n instead of a comparison ```\n==```\n. This will always cause the if test to always fail, so your ```\nmin_index```\n will never be set.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "I am getting Segmentation fault while segmenting image file [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     \r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n                        \r\n                                This question appears to be off-topic because it lacks sufficient information to diagnose the problem. Describe your problem in more detail or include a minimal example in the question itself.\r\n                                Questions asking for code must demonstrate a minimal understanding of the problem being solved. Include attempted solutions, why they didn't work, and the expected results. See also: Stack Overflow question checklist\r\n                        \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI wrote the following code for processing p3.ppm type image but i am getting segmentation fault.I used prims algorithm for minimum spanning trees for the segmentation multiple times and deleting edges with minimum weight.\n\n```\n#include <iostream>\n    #include <stdio.h>\n    #include <time.h>\n    #include <stdlib.h>\n    #define INT_MAX 10e5\n    using namespace std;\n\n    bool ifvalid(int i,int j,int n,int m)\n    {\n        if(i<0 || i>=m || j < 0||j>=n)\n            return false;\n        return true;\n    }\n\n\n    struct cordi\n    {\n        int row,col;\n    };\n    struct pixel\n    {\n        int index;\n        int r,g,b;\n    };\n    struct node\n    {\n        int dest,weight;\n        struct node* next;\n    };\n\n    struct adjList\n    {\n        int s;\n        node *head;\n    };\n\n    struct graph\n    {\n        int NumVertices;\n        adjList *arr;\n    };\n\n    void addEdge(graph *g,int index,int weight,int dest)\n    {\n        node *newNode=(node *)malloc(sizeof(node));\n        newNode->dest=g->arr[dest].s;\n        newNode->weight=weight;\n        newNode->next=NULL;\n        node *temp=g->arr[index].head;\n        node *parent=temp;\n        if(temp==NULL)\n            g->arr[index].head=newNode;\n        else\n        {\n            parent=temp;\n            temp=temp->next;  \n            while(temp!=NULL)\n            {\n                if(temp->dest==dest)\n                    return;\n                parent=temp;\n                temp=temp->next;\n            }\n            parent->next=newNode;\n        }\n    }\n    graph* generateGraph(int **r,int **g,int **b,int n,int m)\n    {\n        int i,j,x,y,index,dest,weight,v;\n        graph *G=(graph*)malloc(sizeof(graph));\n        G->NumVertices=n*m;\n        v=G->NumVertices;\n        G->arr=(adjList*)malloc(v *sizeof(adjList));\n        int counter=0;\n        for(i=0;i<v;i++)\n        {\n            G->arr[i].head=NULL;     \n            G->arr[i].s=counter;\n                counter++;\n        }\n\n        for(i=0;i<m;i++)\n        {\n            for(j=0;j<n;j++)\n            {\n                index=i*n+j;\n                x=i+1,y=j+1;\n                dest=x*n+y;\n                if(ifvalid(x,y,n,m))\n                {\n                    weight=abs(r[i][j]-r[x][y])+abs(g[i][j]-g[x][y])+abs(b[i][j]-b[x][y]);\n                    addEdge(G,index,weight,dest);\n                }\n\n                x=i+1,y=j;\n                dest=x*n+y;\n                if(ifvalid(x,y,n,m))\n                {\n                    weight=abs(r[i][j]-r[x][y])+abs(g[i][j]-g[x][y])+abs(b[i][j]-b[x][y]);\n                    addEdge(G,index,weight,dest);\n                }\n                x=i-1,y=j;\n                dest=x*n+y;\n               if(ifvalid(x,y,n,m))\n                {\n                    weight=abs(r[i][j]-r[x][y])+abs(g[i][j]-g[x][y])+abs(b[i][j]-b[x][y]);\n                    addEdge(G,index,weight,dest);\n                }\n\n                x=i,y=j+1;\n                dest=x*n+y;\n                if(ifvalid(x,y,n,m))\n                {\n                    weight=abs(r[i][j]-r[x][y])+abs(g[i][j]-g[x][y])+abs(b[i][j]-b[x][y]);\n                    addEdge(G,index,weight,dest);\n                }\n\n                x=i-1,y=j+1;\n                dest=x*n+y;\n                if(ifvalid(x,y,n,m))\n                {\n                    weight=abs(r[i][j]-r[x][y])+abs(g[i][j]-g[x][y])+abs(b[i][j]-b[x][y]);\n                    addEdge(G,index,weight,dest);\n                }\n                x=i+1,y=j-1;\n                dest=x*n+y;\n                if(ifvalid(x,y,n,m))\n                {\n                    weight=abs(r[i][j]-r[x][y])+abs(g[i][j]-g[x][y])+abs(b[i][j]-b[x][y]);\n                    addEdge(G,index,weight,dest);\n                }\n                x=i,y=j-1;\n                dest=x*n+y;\n                if(ifvalid(x,y,n,m))\n                {\n                    weight=abs(r[i][j]-r[x][y])+abs(g[i][j]-g[x][y])+abs(b[i][j]-b[x][y]);\n                    addEdge(G,index,weight,dest);\n                }\n                x=i-1,y=j-1;\n                dest=x*n+y;\n                if(ifvalid(x,y,n,m))\n                {\n                    weight=abs(r[i][j]-r[x][y])+abs(g[i][j]-g[x][y])+abs(b[i][j]-b[x][y]);\n                    addEdge(G,index,weight,dest);\n                }\n\n            }\n        }\n        return G;\n    }\n    struct heapNode\n    {\n        int index;\n        int key;\n    };\n    struct minHeap\n    {\n        int *pos;\n        int size;    \n        int capacity;     \n        heapNode **arr;\n    };\n    minHeap* createMinHeap(int capacity)\n    {\n        minHeap* x=(minHeap*)malloc(sizeof(minHeap));\n        x->size=0;\n        x->capacity=capacity;\n        x->pos=(int *)malloc(sizeof(int));\n        x->arr=(heapNode**) malloc(capacity*sizeof(heapNode*));\n        return x;\n    }\n    void swapMinHeapNode(heapNode** a,heapNode** b)\n    {\n        heapNode* t = *a;\n        *a = *b;\n        *b = t;\n    }\n\n    void minHeapify(minHeap* x,int index)\n    {\n        int smallest,left,right;\n        smallest=index;\n        left=2*index+1;\n        right=2*index+2;\n        if (left<x->size&& x->arr[left]->key <x->arr[smallest]->key )\n          smallest=left;\n        if (right <x->size &&x->arr[right]->key < x->arr[smallest]->key)\n          smallest = right;\n        if (smallest!=index)\n        {\n            heapNode *smallestNode = x->arr[smallest];\n            heapNode *idxNode = x->arr[index];\n            x->pos[smallestNode->index]=index;\n            x->pos[idxNode->index]=smallest;\n            swapMinHeapNode(&x->arr[smallest],&x->arr[index]);\n            minHeapify(x,smallest);\n        }\n    }\n    int isEmpty(minHeap* x)\n    {\n        return x->size == 0;\n    }\n    heapNode* extractMin(minHeap* x)\n    {\n        if (isEmpty(x))\n            return NULL;\n        heapNode* root =x->arr[0];\n        heapNode* lastNode =x->arr[x->size-1];\n        x->pos[root->index] =x->size-1;\n        x->pos[lastNode->index] = 0;\n        x->arr[0]=lastNode;\n        x->size--;\n        minHeapify(x,0);\n        return root;\n    }\n    void decreaseKey(minHeap* x,int index,int key)\n    {\n        int i =x->pos[index];\n        x->arr[i]->key = key;\n        while (i && x->arr[i]->key <x->arr[(i-1)/2]->key)\n        {\n            x->pos[x->arr[i]->index] = (i-1)/2;\n            x->pos[x->arr[(i-1)/2]->index]=i;\n            swapMinHeapNode(&x->arr[i],&x->arr[(i-1)/2]);\n            i=(i-1)/2;\n        }\n    }\n    bool isInMinHeap(minHeap *x, int index)\n    {\n       if (x->pos[index] <x->size)\n         return true;\n       return false;\n    }\n    graph* PrimMST(graph* g)\n    {\n        graph *mstGraph=(graph*)malloc(sizeof(graph));\n        mstGraph->NumVertices=g->NumVertices;\n\n        int counter=0;\n        int V=g->NumVertices;\n        mstGraph->arr=(adjList*)malloc(V*sizeof(adjList));\n        for(int i=0;i<V;i++)\n        {\n            mstGraph->arr[i].head=NULL;     \n            mstGraph->arr[i].s=counter;\n                counter++;\n        }\n        int *parent=(int *)malloc(V*sizeof(int));\n        int *key=(int *)malloc(V*sizeof(int ));\n        minHeap *x=createMinHeap(V);\n        for (int v=1; v < V; ++v)\n        {\n            parent[v]=-1;\n            key[v] = INT_MAX;\n            heapNode *e=(heapNode *)malloc(sizeof(heapNode));\n            e->index=v;\n            e->key=key[v];\n            x->arr[v]=e;\n            x->pos[v]=v;\n        }\n        heapNode *e=(heapNode *)malloc(sizeof(heapNode));\n        e->index=0;\n        key[0]=0;\n        parent[0]=-1;\n        e->key=0;\n        x->arr[0]=e;\n        x->pos[0]=0;\n        x->size = V;\n        while (!isEmpty(x))\n        {\n            heapNode* mini=extractMin(x);\n            int u=mini->index;\n            node* pCrawl=g->arr[u].head;\n            while (pCrawl!=NULL)\n            {\n                int v=pCrawl->dest;\n                if (pCrawl->weight<key[v])\n                {\n                    parent[v]=u;\n                    key[v]=pCrawl->weight;\n                    decreaseKey(x,v,key[v]);\n                }\n                pCrawl=pCrawl->next;\n            }\n        }\n        for(int i=1;i<V;i++)\n        {\n            if(parent[i]!=-1){\n                addEdge(mstGraph,i,key[i],parent[i]);\n                addEdge(mstGraph,parent[i],key[i],i);}\n        }\n        return mstGraph;\n    }\n    int maxi=-1,vertex1,vertex2;\n    void dfs(graph *mstGraph,bool *visited,int s)\n    {\n        visited[s]=true;\n        node *temp=mstGraph->arr[s].head;\n        while(temp!=NULL)\n        {\n            int v=temp->dest;\n            //printf(\"%d\\n\",v);\n            if(!visited[v])\n            {\n                if(temp->weight>maxi)\n                {\n                    maxi=temp->weight;\n                    vertex1=s;\n                    vertex2=v;\n                }\n                dfs(mstGraph,visited,v);\n            }\n            temp=temp->next;\n        }\n    }\n    void dfsColor(graph *mstGraph,int color,bool *visited,int s,pixel *li)\n    {\n        visited[s]=true;\n        li[s].index=s;\n        li[s].r=color;\n        li[s].g=color;\n        li[s].b=color;\n        node *temp=mstGraph->arr[s].head;\n        while(temp!=NULL)\n        {\n            int v=temp->dest;\n            if(!visited[v])\n                dfsColor(mstGraph,color,visited,v,li);\n            temp=temp->next;\n        }\n    }\n    void deleteEdge(graph *mstGraph)\n    {\n\n        node *temp=mstGraph->arr[vertex2].head;\n        node *parent;\n        if(temp->dest==vertex1)\n            mstGraph->arr[vertex2].head=temp->next;\n        else\n        {\n            parent=temp;\n            temp=temp->next;\n            while(temp!=NULL)\n            {\n                if(temp->dest==vertex1)\n                {\n                    parent->next=temp->next;\n                    break;\n               }\n               else\n               {\n                parent=temp;\n                temp=temp->next;\n               }\n            }\n        }\n         printf(\"dgz\\n\");\n        temp=mstGraph->arr[vertex1].head;\n        if(temp->dest==vertex2)\n            mstGraph->arr[vertex1].head=temp->next;\n        else\n        {\n            parent=temp;\n            temp=temp->next;\n            while(temp!=NULL)\n            {\n                if(temp->dest==vertex2)\n                {\n                    parent->next=temp->next;\n                    break;\n               }\n               else\n               {\n                parent=temp;\n                temp=temp->next;\n               }\n            }\n        }\n    }\n    int main()\n    {\n        srand((unsigned int)time(NULL));\n        FILE *ip,*op;\n        ip=fopen(\"original.ppm\",\"r\");\n        op=fopen(\"generated.ppm\",\"w\");\n        char fileType[100];\n        fscanf(ip,\"%s\",fileType);\n        int n,m,i,j;\n        fscanf(ip,\"%d%d\",&n,&m);\n        int **r=(int**)malloc(m*sizeof(int *));\n        int **g=(int**)malloc(m*sizeof(int *));\n        int **b=(int**)malloc(m*sizeof(int *));\n        for(i=0;i<m;i++)\n        {\n            r[i]=(int*)malloc(n*sizeof(int));\n            b[i]=(int*)malloc(n*sizeof(int));\n            g[i]=(int*)malloc(n*sizeof(int));\n        }\n        for(i=0;i<m;i++)\n        {\n            for(j=0;j<n;j++)\n            {\n                fscanf(ip,\"%d%d%d\",&r[i][j],&g[i][j],&b[i][j]);\n            }\n        }\n        int color=0,s=3;\n        graph *G=generateGraph(r,g,b,n,m);\n        int v=G->NumVertices;\n        bool *visited=(bool *)malloc(v*sizeof(bool));\n        pixel *li=(pixel *)malloc(v*sizeof(pixel));\n        graph *mstGraph=PrimMST(G);\n\n\n        for(i=0;i<s-1;i++)\n        {\n            for(j=0;j<v;j++)\n                visited[j]=false;\n\n            dfs(mstGraph,visited,0);\n            deleteEdge(mstGraph);\n        }\n\n        for(int j=0;j<v;j++)\n                visited[j]=false;\n        color=0;\n        for(i=0;i<v;i++)\n        {\n            if(!visited[i])\n            {\n                color++;\n                dfsColor(mstGraph,color,visited,i,li);\n            }\n        }\n        printf(\"%d\\n\",color);\n        fprintf(op,\"%s\\n\",fileType);\n        fprintf(op,\"%d %d\\n\",n,m);\n        for(i=0;i<v;i++)\n        {\n           fprintf(op,\"%d\\n\",li[i].r);\n            fprintf(op,\"%d\\n\",li[i].g);\n          fprintf(op,\"%d\\n\",li[i].b);\n        }\n        return 0;\n    }\n```\n\n    ", "Answer": "\r\nYou should run ```\ngcc <yourfilename>.cpp -lstdc++ -g -o myoutput```\n\n\nthen use:\n\n```\ngdb ./myoutput\n```\n\n\nand then type run.\n\nYou will see your stackoverflow:\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0804927d in minHeapify (x=0x804dc60, index=0) at segfault.cpp:186\n186     if (leftsize&& x->arr[left]->key arr[smallest]->key )\n\nthat means that you are going out of boundaries in your ```\nvoid minHeapify(minHeap* x,int index)```\n function.\n\nYou can dump your crashes installing a sighandler in your code which makes use of backtrace and backtrace_symbols (you will find a lot of examples like in here) and then passing the result to addr2line. \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "C++ Kruskal Algorithm gives out unhandeled exception at runtime\r\n                \r\nThe following code is supposed to find the minimum spanning tree from a adjacency matrix:\n\n```\n#include <iostream>\n#include <fstream>\n#include <stdlib.h>\n#include <conio.h>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint i, j, k, a, b, u, v, n, ne = 1;\nint min, mincost = 0, cost[9][9], parent[9];\nint find(int);\nint uni(int, int);\n\nint find(int i)\n{\n    while (parent[i])  // Error occurs at this line\n        i = parent[i];\n    return i;\n}\n\nint uni(int i, int j)\n{\n    if (i != j)\n    {\n        parent[j] = i;\n        return 1;\n    }\n    return 0;\n}\n\nint main()\n{\n    cout << \"MST Kruskal:\\n=================================\\n\";\n    cout << \"\\nNo. of vertices: \";\n    cin >> n;\n    cout << \"\\nAdjacency matrix:\\n\\n\";\n\n    for (i = 1; i <= n; i++)\n    {\n        for (j = 1; j <= n; j++)\n        {\n            cin >> cost[i][j];\n            if (cost[i][j] == 0)\n                cost[i][j] = 999;\n        }\n    }\n\n    cout << \"\\nMST Edge:\\n\\n\";\n\n    while (ne < n)\n    {\n        for (i = 1, min = 999; i <= n; i++)\n        {\n            for (j = 1; j <= n; j++)\n            {\n                if (cost[i][j] < min)\n                {\n                    min = cost[i][j];\n                    a = u = i;\n                    b = v = j;\n                }\n            }\n        }\n\n        u = find(u);\n        v = find(v);\n\n        if (uni(u, v))\n        {\n            cout << ne++ << \"th\" << \" edge \" << \"(\" << a << \",\" << b << \")\" << \" = \" << min << endl;\n            mincost += min;\n        }\n        cost[a][b] = cost[b][a] = 999;\n    }\n\n    cout << \"\\nMinimum cost = \" << mincost << \"\\n\" << endl;\n\n    system(\"PAUSE\");\n\n    return 0;\n}\n```\n\n\nIt works for 6 number of vertices and the following matrix:\n\n```\n0 3 1 6 0 0\n3 0 5 0 3 0\n1 5 0 5 6 4\n6 0 5 0 0 2\n0 3 6 0 0 6\n0 0 4 2 6 0\n```\n\n\nhowever for 13 vertices and with the following matrix:\n\n```\n0 1 0 0 0 2 6 0 0 0 0 0 0\n1 0 1 2 4 0 0 0 0 0 0 0 0\n0 1 0 0 4 0 0 0 0 0 0 0 0\n0 2 0 0 2 1 0 0 0 0 0 0 0\n0 4 4 2 0 2 1 0 0 0 0 4 0\n2 0 0 1 2 0 0 0 0 0 0 2 0\n6 0 0 0 1 0 0 3 0 1 0 5 0\n0 0 0 0 0 0 3 0 2 0 0 0 0\n0 0 0 0 0 0 0 2 0 0 1 0 0\n0 0 0 0 0 0 1 0 0 0 1 3 2\n0 0 0 0 0 0 0 0 1 1 0 0 0\n0 0 0 0 4 2 5 0 0 3 0 0 1\n0 0 0 0 0 0 0 0 0 2 0 1 0\n```\n\n\nthis error occurs:\n\n```\nUnhandled exception at 0x00ED5811 in KruskalMST.exe: 0xC0000005: Access violation reading location 0x00F67A1C.\n```\n\n\nThe error occurs at line 17: ```\nwhile (parent[i])```\n\n\nVS Autos:\n\n```\nName    Value                           Type\n\ni       138596                                                  int\nparent  0x00ee048c {2, 999, 999, 999, 999, 999, 999, 999, 2}    int[9]\n[0] 2                                                           int\n[1] 999                                                         int\n[2] 999                                                         int\n[3] 999                                                         int\n[4] 999                                                         int\n[5] 999                                                         int\n[6] 999                                                         int\n[7] 999                                                         int\n[8] 2                                                           int\n```\n\n    ", "Answer": "\r\nYou've defined your 'parent' array to have a size of 9 (assuming you have a maximum of 9 vertices, so max number of parents is 9). Six vertices will work because it's less than 9. With thirteen vertices you MAY be accessing elements passed your parent array size; thus, you should try and define your array size depending on the number of vertices.\n\nP.S In general you don't want to have magic numbers in your code.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Find parent node of a tree to create the shortest possible tree height\r\n                \r\nI have an undirected graph represented as an adjacency matrix of Euclidean weights. I'm using this to represent the minimum spanning tree for a larger complete graph.\n\nWhat I want to find is the single node within the graph that, when used as the root node, creates the shortest possible tree height. What I've come up with is performing a depth-first traversal using every node as the root, and keeping track of the shortest height seen. Is there a faster way to accomplish this?\n    ", "Answer": "\r\nThis is a classic algorithms question.  What you're looking for is called the center of the tree, and it can be found using a simple iterative algorithm.  This question has a great answer that explains how to do it.\n\nHope this helps!\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Please provide a valid WRITE query\r\n                \r\nI try to run minimum spanning tree algorithm inside Spark using Neo4j Connector. But when I try to call it I get an error: Please provide a valid WRITE query.\nMy code looks like this:\n```\nval df = (1 to 10)/*...*/.toDF()\ndf.write\n  .format(\"org.neo4j.spark.DataSource\")\n  .option(\"url\", \"bolt://localhost:7687\")\n  .option(\"query\", \"CALL gds.alpha.spanningTree.minimum.write('graph', {  startNodeId: id(1), relationshipWeightProperty: 'cost',\" +\n        \"  writeProperty: 'CONNECT',weightWriteProperty: 'writeCost'})\")\n  .save()\n```\n\nCan calling an algorithm can be done inside write function?\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to find minimum spanning tree connecting a set of co-ordinates in the 2d plane?\r\n                \r\nI have already coded Prim's algorithm in python, but this takes as inputs a weighted graph with nodes and edges, which is not what i have.\n\nHow do I convert the given co-ordinates in to a graph such that the program can accept the inputs, and i get a meaningful answer?\n    ", "Answer": "\r\nThis is where the concept of Classes shall prove useful.  \n\nCreate a Coordinate class and store your nodes and edges as instances of that class. Add a __sub__ method to the Coordinate class so as to get the Weights (Distances or whatever you want weights to be.) between two Coordinates.\n\nExample :-\n\n```\nclass Coordinate:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __sub__(self, other):\n        return (self.x - other.x)**2 + (self.y - other.y)**2\n        # No need to square root to compare distances.\n```\n\n\nNow you can easily create an Adjacency Map/List as per your convenience and also find the corresponding weights and use your algorithm.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to dynamically change the color of a checkbox in C#\r\n                \r\nI'm making a simulation of a minimum spanning tree algorithm in C#. For each vertex in my graph I am using a checkbox as a visual representation. I would like to change the color of the checkbox each time the vertex is added to the minimum spanning tree. \nThe checkbox was designed using expression blend 4 and it already has the basic attributes (base, mouse over, selected and such). The base color is black and I would like it to be green when the vertex is added to the tree.\n\nThis is an example of how I am using the checkboxes:\n\n```\nprivate void DeselectAll()\n{\n    foreach (var n in graf.Noduri)\n    {\n        CheckBox c = (CheckBox)n.graficNod.Content;\n        c.IsChecked = false;\n    }\n}\n```\n\n\nwhere n is of the type cNod which has graficNod as an attribute of the type Nod which was created in expression blend, using xaml.\n\nHow can I change the base color of graficNod?\n\nNod.xaml looks like this:\n\n```\n<UserControl\nxmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\nxmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\nxmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\nxmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\nxmlns:Microsoft_Windows_Themes=\"clr-namespace:Microsoft.Windows.Themes;assembly=PresentationFramework.Aero\" xmlns:ei=\"http://schemas.microsoft.com/expression/2010/interactions\"\nmc:Ignorable=\"d\"\nx:Class=\"SimulareGrafuri.Nod\"\nx:Name=\"UserControl\"\nWidth=\"10\"\nHeight=\"10\"    \nd:DesignWidth=\"640\" d:DesignHeight=\"480\">\n<UserControl.Resources>\n    <ControlTemplate x:Key=\"CheckBoxControlTemplate1\" TargetType=\"{x:Type CheckBox}\">\n        <Grid>\n            <VisualStateManager.VisualStateGroups>\n                <VisualStateGroup x:Name=\"CommonStates\">\n                    <VisualState x:Name=\"Normal\"/>\n                    <VisualState x:Name=\"MouseOver\">\n                        <Storyboard>\n                            <ColorAnimationUsingKeyFrames Storyboard.TargetProperty=\"(Shape.Fill).(SolidColorBrush.Color)\" Storyboard.TargetName=\"ellipse\">\n                                <EasingColorKeyFrame KeyTime=\"0\" Value=\"#FFD0CACA\"/>\n                            </ColorAnimationUsingKeyFrames>\n                            <ColorAnimationUsingKeyFrames Storyboard.TargetProperty=\"(Shape.Stroke).(SolidColorBrush.Color)\" Storyboard.TargetName=\"ellipse\">\n                                <EasingColorKeyFrame KeyTime=\"0\" Value=\"Black\"/>\n                            </ColorAnimationUsingKeyFrames>\n                            <DoubleAnimationUsingKeyFrames Storyboard.TargetProperty=\"(Shape.StrokeThickness)\" Storyboard.TargetName=\"ellipse\">\n                                <EasingDoubleKeyFrame KeyTime=\"0\" Value=\"1\"/>\n                            </DoubleAnimationUsingKeyFrames>\n                        </Storyboard>\n                    </VisualState>\n                    <VisualState x:Name=\"Pressed\">\n                        <Storyboard>\n                            <ColorAnimationUsingKeyFrames Storyboard.TargetProperty=\"(Shape.Stroke).(SolidColorBrush.Color)\" Storyboard.TargetName=\"ellipse\">\n                                <EasingColorKeyFrame KeyTime=\"0\" Value=\"Black\"/>\n                            </ColorAnimationUsingKeyFrames>\n                            <ColorAnimationUsingKeyFrames Storyboard.TargetProperty=\"(Shape.Fill).(SolidColorBrush.Color)\" Storyboard.TargetName=\"ellipse\">\n                                <EasingColorKeyFrame KeyTime=\"0\" Value=\"#FF5A5454\"/>\n                            </ColorAnimationUsingKeyFrames>\n                        </Storyboard>\n                    </VisualState>\n                    <VisualState x:Name=\"Disabled\"/>\n                </VisualStateGroup>\n                <VisualStateGroup x:Name=\"CheckStates\">\n                    <VisualState x:Name=\"Checked\">\n                        <Storyboard>\n                            <ColorAnimationUsingKeyFrames Storyboard.TargetProperty=\"(Shape.Stroke).(SolidColorBrush.Color)\" Storyboard.TargetName=\"ellipse\">\n                                <EasingColorKeyFrame KeyTime=\"0\" Value=\"Black\"/>\n                            </ColorAnimationUsingKeyFrames>\n                            <DoubleAnimationUsingKeyFrames Storyboard.TargetProperty=\"(UIElement.Opacity)\" Storyboard.TargetName=\"rectangle\">\n                                <EasingDoubleKeyFrame KeyTime=\"0\" Value=\"1\"/>\n                            </DoubleAnimationUsingKeyFrames>\n                            <ColorAnimationUsingKeyFrames Storyboard.TargetProperty=\"(Shape.Stroke).(SolidColorBrush.Color)\" Storyboard.TargetName=\"rectangle\">\n                                <EasingColorKeyFrame KeyTime=\"0\" Value=\"#FF540000\"/>\n                            </ColorAnimationUsingKeyFrames>\n                            <DoubleAnimationUsingKeyFrames Storyboard.TargetProperty=\"(Shape.StrokeThickness)\" Storyboard.TargetName=\"rectangle\">\n                                <EasingDoubleKeyFrame KeyTime=\"0\" Value=\"1\"/>\n                            </DoubleAnimationUsingKeyFrames>\n                            <ThicknessAnimationUsingKeyFrames Storyboard.TargetProperty=\"(FrameworkElement.Margin)\" Storyboard.TargetName=\"rectangle\">\n                                <EasingThicknessKeyFrame KeyTime=\"0\" Value=\"-2\"/>\n                            </ThicknessAnimationUsingKeyFrames>\n                            <ColorAnimationUsingKeyFrames Storyboard.TargetProperty=\"(Shape.Fill).(SolidColorBrush.Color)\" Storyboard.TargetName=\"ellipse\">\n                                <EasingColorKeyFrame KeyTime=\"0\" Value=\"#FFA70808\"/>\n                            </ColorAnimationUsingKeyFrames>\n                        </Storyboard>\n                    </VisualState>\n                    <VisualState x:Name=\"Unchecked\">\n                        <Storyboard>\n                            <ObjectAnimationUsingKeyFrames Storyboard.TargetProperty=\"(UIElement.Visibility)\" Storyboard.TargetName=\"rectangle\">\n                                <DiscreteObjectKeyFrame KeyTime=\"0\" Value=\"{x:Static Visibility.Collapsed}\"/>\n                            </ObjectAnimationUsingKeyFrames>\n                        </Storyboard>\n                    </VisualState>\n                    <VisualState x:Name=\"Indeterminate\"/>\n                </VisualStateGroup>\n            </VisualStateManager.VisualStateGroups>\n            <Ellipse x:Name=\"ellipse\" Fill=\"Black\" Margin=\"0\" Stroke=\"Black\" Width=\"Auto\"/>\n            <Rectangle x:Name=\"rectangle\" Fill=\"{x:Null}\" Margin=\"6,6,82,72\" Opacity=\"0\" Stroke=\"Black\"/>\n        </Grid>\n    </ControlTemplate>\n</UserControl.Resources>\n\n\n\n<CheckBox Content=\"CheckBox\" Template=\"{DynamicResource CheckBoxControlTemplate1}\"/>\n```\n\n\n\n    ", "Answer": "\r\nSimple:\nI see you've changed the checkbox quite a lot to resemble a vertex, but now it will always, be a black ellipse because you set the \"Fill\" explicitly :\n\n```\n<Ellipse x:Name=\"ellipse\" Fill=\"Black\" Margin=\"0\" Stroke=\"Black\" Width=\"Auto\"/>\n```\n\n\nUse instead a TemplateBinding which will change the fill whenever you set the background property of the checkbox:\n\n```\n<Ellipse x:Name=\"ellipse\" Fill=\"{TemplateBinding Background}\" Margin=\"0\" Stroke=\"Black\" Width=\"Auto\"/>\n```\n\n\nand change your checkbox declaration to:\n\n```\n<CheckBox x:Name=\"chkVertex\" Content=\"CheckBox\" Template=\"{DynamicResource CheckBoxControlTemplate1}\" Background=\"Red\"/>\n```\n\n\nYou can change the color now in code-behind whenever you like, using: \n\n```\nchkVertex.Background = //whatever color you like\n```\n\n\nor you could bind the Background property of the checkbox in xaml, to a background property of the vertex, to have a cleaner approach.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Why sorting Edges of a graph takes O(E log E) time?\r\n                \r\nI am trying to calculate the runtime of the Minimum Spanning Tree algorithm.\n\nHere is the algorithm: \n\n\nI understand tuntimes of steps from 1 to 3. But I really dont understand why it takes O(E logE) time to sort edges in non decreasing order.\n\nThank you.\n    ", "Answer": "\r\nBecause most powerful algorithms (mergesort, heapsort, quicksort) guarantee to sort a collection of n items in n log n worst case time. See prove here. In your case E seems to be the number of edges. So E log E to sort them all.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Is there a method or an equation to generate coordinates based on relative distances? (Spanning Tree)\r\n                \r\nI have a list of point names, and their relative distance from each other (Euclidean distance). Is it possible to plot their coordinates on a 2-D plane where I can set the origin point to be the minimum sum of distances between all other points? \n\nexample for an input of 3 points (A,B,C):\n\n```\nlist = {'AB':'0.15', 'AC':'0.61', 'BC':'0.24'}\n```\n\n\nDesired output:\n\n```\n#B is identified as origin so its coordinates is set to (0,0)    \n{'A':(x1,y1), 'B':(0,0), 'C':(x2,y2)}\n```\n\n\nI am only trying to plot their Euclidean distance so then I could draw an accurate spanning tree. the input will be much more than 3.\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "how to find maximum edge in the path for mst graph in r\r\n                \r\n```\n    a             b             c           d           e\na   0.0           5.0           22.3606     586.9412    1041.3933\nb   5.0           0.0           26.9258     591.8825    1045.143\nc   22.3606       26.9258       0.0         565.6854    1019.8039\nd   586.9412      591.8825      565.6854    0.0         632.455\ne   1041.3933     1045.143      1019.8039   632.455     0.0\n```\n\n\nI'm new to R , and I am having problems finding the maximum edge distance for a minimum spanning tree graph with this sample dataset. My code is below. I don't know how to proceed further for finding the maximum edge distance in the path for each vertex.\n\n```\nlibrary(cluster)\nlibrary(igraph)\ng <- read.table(\"C:/Users/VIVEK/Documents/R/Gap/samp.txt\")\nm <- as.matrix(g)\nig <- graph.adjacency(m, mode=\"undirected\", weighted=TRUE)\nplot(ig, edge.label=round(E(ig)$weight, 3))\nmst <- minimum.spanning.tree(ig)\nplot(mst,layout=layout.reingold.tilford,edge.label=E(mst)$weight)\n```\n\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "KeyError in Python Program but not in interpreter?\r\n                \r\nHere is the program i am trying to implement Prims Algorithm for Minimum Spanning Tree. My problem is that when I execute the program as a whole it shows the KeyError : 7 : \n\n\n\nBut when i execute the error causing portion in Interpreter it shows no error ?\n\nMy Code : \n\n```\nedges = {\n            'A':{'D':1,'B':3},\n            'B':{'A':3,'C':4},\n            'C':{'B':4,'D':5,'A':2,'E':7},\n            'D':{'A':1,'C':5,'E':6},\n            'E':{'D':6,'C':7}\n        }\n\n# here NULL represented by -1 and Infinity represented by 1000\n\nvertices = {\n            'A':[1000,-1],\n            'B':[1000,-1],\n            'C':[1000,-1],\n            'D':[1000,-1],\n            'E':[1000,-1]\n            }\n\ndef EXTRACTMIN():\n    low = 'A'\n    for key in vertices.keys():\n        if vertices[low][0]>vertices[key][0]:\n            low=key\n    del vertices[low]\n    return low\n\nvertices['A'][0]=0\n\nwhile not(vertices=={}):\n    u=EXTRACTMIN()\n    print(str(u)+\" \")\n    for v in [x for x in edges[u].keys()]:\n        if v in vertices and edges[u][v]<vertices[v][0]:\n            vertices[v][0]=edges[u][v]\n```\n\n    ", "Answer": "\r\nwell, the problem is in the function ```\nEXTRACTMIN```\n\n\nfirst you delete the key ```\nA```\n from ```\nvertices```\n because ```\nA```\n is the minimum.\n\nthen, when calling again the function ```\nEXTRACTMIN```\n you try to delete it again (since ```\nvertices[low][0]>vertices[key][0]```\n is always ```\nFalse```\n) but you already delete the ```\nA```\n and its not exist in ```\nvertices```\n.\n\nyou also not putting it back in the while loop becuase of the condition ```\nv in vertices```\n and we know that ```\nA```\n is not there\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Algorithm to find a linear path of minimum weight in a graph that connects all the vertices exactly once\r\n                \r\nGiven a weighted undirected graph with n vertices, I face the problem of finding \na path of minimum weight that connects each of the vertices in a line.\nAt first, I thought this is the problem of finding the minimum spanning tree \nbut this is not the case. In case of a spanning tree, there may be branches \nat a vertex or the degree may be greater than two. What I need to find is a \nlinear path i.e all the vertices except the end vertices have degree exactly two. \nThe start and end vertex can be any of the n vertices.\n\nMine was a greedy approach i.e\n\n```\nfirst chose any vertex, maintain a sum \n    check all its neighbors such that the cost of reaching it is \n    least among all the neighbors\n    mark this neighbor as visited\n    add the cost to sum\nrepeat the procedure above until all the points have been visited.\n```\n\n\nI will have to do this for all the vertices as the starting point.\nI am not sure if this algorithm is correct and also its complexity is high.\nWhat should be the better approach to this problem?\n    ", "Answer": "\r\nThis problem is known to be NP-hard by a reduction from the Hamiltonian path problem, since if you give all the edges weight 1 and ask \"is there a linear path of weight at most n?\" then the answer is \"yes\" precisely if the graph contains a Hamiltonian path.  As a result, you are unlikely to find an algorithm that works better than pure brute force, since unless P = NP there are no polynomial-time solutions.\n\nSorry to rain in on your parade, and hope this helps!\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to change this prim's algorithm function to take in and return an adjacency list?\r\n                \r\nI want to find the minimum spanning tree in a graph structured as an adjacency list. I was able to figure out the MST using Prim's algorithm but my current solution doesn't use an adjacency list.\n\n```\nfrom collections import defaultdict\nfrom heapq import *\n\ndef prim( nodes, edges ):\n   conn = defaultdict( list )\n   for n1,n2,c in edges:\n    conn[ n1 ].append( (c, n1, n2) )\n    conn[ n2 ].append( (c, n2, n1) )\n\nmst = []\nused = set( nodes[ 0 ] )\nusable_edges = conn[ nodes[0] ][:]\nheapify( usable_edges )\n\nwhile usable_edges:\n    cost, n1, n2 = heappop( usable_edges )\n    if n2 not in used:\n        used.add( n2 )\n        mst.append( ( n1, n2, cost ) )\n\n        for e in conn[ n2 ]:\n            if e[ 2 ] not in used:\n                heappush( usable_edges, e )\n return mst\n\n#test\nnodes = list(\"ABCDEFG\")\nedges = [(\"A\", \"B\", 7), (\"A\", \"D\", 5),\n         (\"B\", \"C\", 8), (\"B\", \"D\", 9), (\"B\", \"E\", 7),\n         (\"C\", \"E\", 5),\n         (\"D\", \"E\", 15), (\"D\", \"F\", 6),\n         (\"E\", \"F\", 8), (\"E\", \"G\", 9),\n         (\"F\", \"G\", 11)]\n\n print \"prim:\", prim( nodes, edges )\n```\n\n\nI need it to take and return something like this:\n\n```\n {'A': [('B', 2)],\n  'B': [('A', 2), ('C', 5)],\n  'C': [('B', 5)]}\n```\n\n\nthank you!\n    ", "Answer": "\r\nOnce you have an mst as a list of edges, you just need to iterate over it to populate the dictionary. \n\nThat's exactly what you're doing in the very beginning of the ```\nprim```\n  function:\n\n```\nconn = defaultdict(list)\nfor n1, n2, c in edges:\n    conn[n1].append((c, n1, n2))\n    conn[n2].append((c, n2, n1))\n```\n\n\nYou need to do exactly the same thing for the ```\nmst```\n list instead of ```\nedges```\n.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How can I draw a network?\r\n                \r\nI want to draw a network like this:\n\n\nThis is my code:\n\n```\nimport matplotlib\nmatplotlib.use('TkAgg')\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport networkx as nx\nfrom itertools import product\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import minimum_spanning_tree\nfrom pymnet import*\nimport matplotlib.colors as mcolors\n\nmst_pearson=mst_tree(pearson)\nmst_kendall=mst_tree(kendall)\nmst_tail=mst_tree(tail)\n\nnx.draw(mst_pearson,pos=nx.spring_layout(mst_pearson))\nplt.show()\n```\n\n\nmst_pearson is my own function to generate the minimum spanning tree of the graph,but my graph likes this although I set the layout:\n\nHow could I change the layout of nodes and the edges? Thanks in advance.\n    ", "Answer": "\r\nWith the function\n\n```\nnx.draw_networkx_nodes(G, pos, [...])\n```\n\n\nyou can use the  ```\npos```\n argument in order to set a specific layout.\n\nFor example I have this snippet code in order to do that inside a custom function\n\n```\ndef custom_draw_graph_function(graph_layout='shell'):\n\n    # these are different layouts for the network you may try\n    if(graph_layout == 'spring'):\n         graph_pos=nx.spring_layout(G)\n    elif(graph_layout == 'spectral'):\n         graph_pos=nx.spectral_layout(G)\n    elif(graph_layout == 'circular'):\n         graph_pos = nx.circular_layout(G)\n    elif(graph_layout == 'fruchterman'):\n         graph_pos = nx.fruchterman_reingold_layout(G)\n    elif(graph_layout == 'shell'):\n         graph_pos = nx.shell_layout(G)\n    else:\n         graph_pos=nx.random_layout(G)\n\n     # DRAW GRAPH\n     # Nodes\n     nx.draw_networkx_nodes(G,graph_pos,[...])\n\n     [...]\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Names of Graph Traversal Algorithms\r\n                \r\nWhat I'm looking for is a comprehensive list of graph traversal algorithms, with brief descriptions of their purpose, as a jump off point for researching them. So far I'm aware of:\n\n\nDijkstra's - single-source shortest path\nKruskal's - finds a minimum spanning tree\n\n\nWhat are some other well-known ones? Please provide a brief description of each algorithm to each of your answers.\n    ", "Answer": "\r\nthe well knowns are :\n\n\nDepth-first search http://en.wikipedia.org/wiki/Depth-first_search\nBreadth-first search http://en.wikipedia.org/wiki/Breadth-first_search\nPrim's algorithm http://en.wikipedia.org/wiki/Prim's_algorithm\nKruskal's algorithm http://en.wikipedia.org/wiki/Kruskal's_algorithm\nBellman–Ford algorithm http://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm\nFloyd–Warshall algorithm http://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm\nReverse-delete algorithm http://en.wikipedia.org/wiki/Reverse-Delete_algorithm\nDijkstra's_algorithm  http://en.wikipedia.org/wiki/Dijkstra's_algorithm \n\n\nnetwork flow\n\n\nFord–Fulkerson algorithm http://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm\nMaximum Flow http://en.wikipedia.org/wiki/Maximum_flow_problem\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Graph Algorithms\r\n                \r\nWhat is the maximum and minimum number of edges to be considered in krushkal's algorithm with an example for both cases.\n\nWhat I thought was since the Krushkal's algorithm is for finding minimum spanning tree the maximum number of edges is (V-1) where V is the number of vertices. Adding one more edge would result in a cycle in the graph. How can we obtain at a minimum value ?\n    ", "Answer": "\r\nKruskal's algorithm stops when you've added ```\nV - 1```\n edges to your MST, so this is the minimum that have to be considered. This happens when the lowest value ```\nV - 1```\n edges of your graph do not form a cycle, and they will be added one after the other by the algorithm, after which it will stop.\n\nFor example, consider a complete graph with edges with cost ```\n1```\n, which is minimum in the graph, between node ```\n1```\n and every other node. Make all the other edges have cost ```\n2```\n.\n\nThe worst case is when you must inspect every edge (of which there are ```\nO(V^2)```\n) until you finally select ```\nV - 1```\n. This means that you have to force a lot of cycles to be created before the last edge is added.\n\nConsider a complete graph again. Have the ```\nV - 2```\n edges between node ```\n1```\n and ```\nV - 2```\n nodes have cost 1, which is minimum in the graph. These will be selected first. Now let node ```\nk```\n be the one that is not part of a selected edge, so that is left out of the graph. Have the edge between node ```\nk```\n and node ```\n1```\n have the largest cost. This will cause it to be inspected and added to the MST last, forcing the algorithm to inspect all ```\nO(V^2)```\n edges before building the MST.\n\nRemember the Kruskal's algorithm processes edges in increasing order of their cost, rejecting edges that would form a cycle if added to the MST we are building.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Boost kruskals algorithm find sum of edges between vertex 0 and the one farthest from it?\r\n                \r\nI have to use kruskals algorithm in the boost library to find the weight of the minimum spanning tree. I think I managed that one\n\n```\n#include <iostream>\n#include <boost/config.hpp>\n#include <boost/graph/adjacency_list.hpp>\n#include <boost/graph/dijkstra_shortest_paths.hpp>\n#include <boost/graph/kruskal_min_spanning_tree.hpp>\n#include<vector>\n\nusing namespace std;\nusing namespace boost;\n\n\n\nint main(){\n\ntypedef adjacency_list <vecS,vecS,undirectedS,no_property,property <edge_weight_t,int> > Graph;\n\ntypedef graph_traits <Graph>::edge_descriptor Edge;\ntypedef graph_traits <Graph>::vertex_descriptor Vertex;\n\nint a,b,c,no_vertices,no_edges;\n\ncin>>no_vertices>>no_edges;\n\nGraph g(no_vertices);\n\nproperty_map <Graph,edge_weight_t>::type weightmap=get(edge_weight,g);\nvector <Edge> spanning_tree;\n\nfor(int i=0;i<no_edges;i++)\n{\n    bool success;\n    Edge e;\n    cin>>a>>b>>c;\n    tie(e,success)=add_edge(a,b,g);\n    weightmap[e]=c;\n}\n\nkruskal_minimum_spanning_tree(g,back_inserter(spanning_tree));\n\n//weight of spanning tree\nint ww=0;\ngraph_traits<Graph>::edge_iterator ei, ei_end;\n  for (tie(ei, ei_end) = edges(g); ei != ei_end; ++ei)\n{\n   ww=ww+weightmap[*ei];\n}\n\ncout<<\"\\n\"<<ww;\n\n\nreturn 0;\n\n}\n```\n\n\nNow I need to find the distance(sum of weights) between vertex 0 and the one farthest from it? Any hints as to how I could do it?\n\nI was thinking of using vertex iterator, but then I store the weight in weightMap so how do I access it if I iterate through the vertices of my graph?\n\nEDIT: I have modified my program,decided to use kruskal and prim\n\n1.kruskal for the spanning tree weight\n2.prim algorithm for the distance of each vertex from the vertex 0(in spanning tree stored in map distance)\n\nUnfortunately something goes wrong, distance[*vertex] which is the third vertex doesnt give the answer 2,but gives one\n\nAlso the weight of spanning tree is 14 instead of 7\n\nmy dummy input is:\n\n```\n5 6\n0 1 1\n0 2 2 \n1 2 5\n1 3 1\n3 2 2\n2 4 3\n```\n\n\nhere my programs:\n\n```\n#include <boost/config.hpp>\n#include <iostream>\n#include <boost/graph/adjacency_list.hpp>\n#include <boost/graph/prim_minimum_spanning_tree.hpp>\n#include <boost/graph/dijkstra_shortest_paths.hpp>\n#include <boost/graph/kruskal_min_spanning_tree.hpp>\nusing namespace std;\n\nint\nmain()\n{\n  using namespace boost;\n\n  typedef adjacency_list < vecS, vecS, undirectedS,\n    property<vertex_distance_t, int>, property < edge_weight_t, int > > Graph;\n\n    int num_nodes,num_edges,a,b,c;\n    cin>>num_nodes>>num_edges;\n\n\n\n  Graph g(num_nodes);\n\n  property_map<Graph, edge_weight_t>::type weightmap = get(edge_weight, g);\n\n  for (int j = 0; j < num_edges ; ++j) {\n        cin>>a>>b>>c;\n    graph_traits<Graph>::edge_descriptor e;\n  bool inserted;\n    tie(e, inserted) = add_edge(a, b, g);\n    weightmap[e] = c;\n  }\n\n    vector < graph_traits < Graph >::vertex_descriptor > p(num_vertices(g));\n    cout<<num_vertices(g);\n\n\n  property_map<Graph, vertex_distance_t>::type distance = get(vertex_distance, g);\n  property_map<Graph, vertex_index_t>::type indexmap = get(vertex_index, g);\n\n  prim_minimum_spanning_tree\n    (g, *vertices(g).first, &p[0], distance, weightmap, indexmap,\n     default_dijkstra_visitor());\n\n  vector <graph_traits<Graph>::edge_descriptor> spanning_tree;\n\n  kruskal_minimum_spanning_tree(g,back_inserter(spanning_tree));\n  int ww=0;\n  typedef graph_traits < Graph >::edge_descriptor Edge;\n\n  for (vector<Edge>::iterator et= spanning_tree.begin(); et != spanning_tree.end(); ++et)\n{\n   ww=ww+weightmap[*et];\n}\n\ntypedef graph_traits<Graph>::vertex_iterator vertex_iter;\nstd::pair<vertex_iter, vertex_iter> vp;\nfor (vp = vertices(g); vp.first != vp.second; ++vp.first)\n{\n    cout<<distance[*vp.first];\n}\n\n\n\n\n\n\nprim_minimum_spanning_tree\n    (g, *vertices(g).first, &p[0], distance, weightmap, indexmap,\n     default_dijkstra_visitor());\n\n  return EXIT_SUCCESS;\n}\n```\n\n\nTHank you :)\n    ", "Answer": "\r\nI'm not really sure how to interpret the result of the Kruskal MST algorithm (in particular the edge list). Could this be what you were looking for:\n\n```\nint ww = 0;\nfor (auto const& e : spanning_tree) {\n    std::cout << \"Traversing: \" << source(e,g) << \" -> \" << target(e,g) << \", cost \" << weightmap[e] << \"\\n\";\n    ww += weightmap[e];\n}\n\ncout << \"\\n\" << ww;\n```\n\n\nOtherwise, you'd probably want to pass a predecessor map to Kruskal and read that for your desired path. \n\nMeanwhile see my above sketch Live On Coliru\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to find a tree with least number of links connecting chosen nodes within a graph?\r\n                \r\nSuppose I am given an undirected and unweighted graph and a subset of nodes from the graph.\nNow my target is to find the smallest tree or path that connects all the subset nodes. The order of nodes does not matter and neither the starting node. Any node can be the starting node.\nMy question is similar to Algorithm to find minimum spanning tree of chosen vertices but all the nodes have weight equal to 1. Hence, I am trying to find the tree with least number of links.\n    ", "Answer": "\r\nExtending the answer of the question you linked, you are now looking for an unweighted Steiner tree.\nIt is however also NP-hard, see this question on cstheory.stackexchange.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Unable to call boost::clear_vertex while using listS for the vertex and edge lists\r\n                \r\nI am writing a program which uses the boost graph library to solve the Travelling Salesman problem using A* search with a minimum spanning tree heuristic. I am rather new to boost::graph\nIn my heuristic class, I calculate the minimum spanning tree of all the vertices yet unvisited. I keep track of which vertices have been visited by maintaining a \ncopy of the original graph from which I remove the current vertex and all its edges on each call to the heuristic. However, when I go to call ```\nboost::clear_vertex(u, subGraph)```\n where ```\nu```\n is a ```\nvertex_descriptor```\n and ```\nsubGraph```\n is the copy of the original graph from which I am subtracting vertices, I get a debug assertion failure stating:\n\n\n  list erase iterator outside range. \n\n\nAfter doing some debugging, I found that ultimately the error is generated on line 1383 of STL ```\n<list>```\n where for some reason the following condition is false:\n\n```\n_Where._Getcont() != _STD addressof(this->_Get_data())```\n.\n\nHere is my Heuristic class:\n\n```\nclass MST_Heuristic : public astar_heuristic<MyGraphType, double>\n{\npublic:\n    MST_Heuristic(vertex_descriptor goal, MyGraphType g)\n        : m_goal(goal), subGraph(g), firstRun(true) {}\n    double operator () (vertex_descriptor u)\n    {\n        double MSTDist = 0.0;\n        double startDist = numeric_limits<double>::infinity();\n        int minEdgeWeight = subGraph[*out_edges(u, subGraph).first].weight;         // initialize minEdgeWeight to weight of first out edge\n\n        if (firstRun)\n        {\n            IndexMap mapIndex;\n            associative_property_map<IndexMap> vertexIndices(mapIndex);\n            int j = 0;\n            for (auto v = vertices(subGraph).first; v != vertices(subGraph).second; v++)\n            {\n                put(vertexIndices, *v, j++);\n            }\n\n            dijkstra_shortest_paths(subGraph, u, get(&VertexData::pred, subGraph),  // calculate the shortest path from the start for each vertex\n                get(&VertexData::dist2, subGraph), get(&EdgeData::weight, subGraph),\n                vertexIndices, less<double>(), plus<double>(),\n                numeric_limits<double>::infinity(), 0, do_nothing_dijkstra_visitor(),\n                get(&VertexData::color, subGraph));\n        }\n        for (auto ed : make_iterator_range(out_edges(u, subGraph)))\n        {\n            minEdgeWeight = min(subGraph[ed].weight, minEdgeWeight);                // find distance from nearest unvisited vertex to the current vertex\n        }\n        clear_vertex(u, subGraph);\n        remove_vertex(u, subGraph);\n        // Problem here; The problem has to do with removing vertices/edges and destabilizing the graph, thereby making it impossible to iterate through the graph\n\n        IndexMap mapIndex;\n        associative_property_map<IndexMap> vertexIndices(mapIndex);\n        int j = 0;\n        for (auto v = vertices(subGraph).first; v != vertices(subGraph).second; v++)\n        {\n            put(vertexIndices, *v, j++);\n        }\n\n        prim_minimum_spanning_tree(subGraph, *vertices(subGraph).first,             // calculate the minimum spanning tree\n            get(&VertexData::pred, subGraph), get(&VertexData::dist, subGraph),\n            get(&EdgeData::weight, subGraph), vertexIndices,\n            do_nothing_dijkstra_visitor());\n\n        for (auto vd : make_iterator_range(vertices(subGraph)))                     // estimate distance to travel all the unvisited vertices\n        {\n            MSTDist += subGraph[vd].dist;\n            startDist = min(startDist, subGraph[vd].dist2);\n        }\n\n        firstRun = false;\n        return static_cast<double>(minEdgeWeight) + MSTDist + startDist;            // return the result of the heuristic function\n    }\nprivate:\n    vertex_descriptor m_goal;\n    MyGraphType subGraph;\n    bool firstRun;\n};\n```\n\n\nHere are some relevant typedefs:\n\n```\ntypedef adjacency_list_traits<listS, listS, undirectedS> GraphTraits;               // to simplify the next definition\n\ntypedef GraphTraits::vertex_descriptor vertex_descriptor;                           // vertex descriptor for the graph\n\ntypedef GraphTraits::edge_descriptor edge_descriptor;                               // edge descriptor for the graph\n\ntypedef std::map<vertex_descriptor, size_t>IndexMap;                                // type used for the vertex index property map\n\ntypedef adjacency_list<listS, listS, undirectedS,VertexData, EdgeData> MyGraphType; // graph type\n```\n\n\nI would really appreciate someone clearing up for me why this is happening. Also, it could be that my idea for a heuristic class is totally stupid, so if you think I should just try some other approach for a Minimum Spanning Tree heuristic rather than keep messing with this, I am certainly open to the prospect. If my heuristic is idiotic, I would really appreciate some suggestion as to what else to do. My boost version is boost_1_67_0 and I am using MS Visual Studio 2017.\n    ", "Answer": "\r\nYou're running into iterator debugging checks from MSVC. That's GOOD because otherwise you might not know about it and your program would have (silent?) Undefined Behaviour.\n\nNow let me look at the code.\n\nThis looks suspect:\n\n```\ndouble minEdgeWeight =\n    subGraph[*out_edges(u, subGraph).first].weight; // initialize minEdgeWeight to weight of first out edge\n```\n\n\nThis carries the implicit assumption that ```\nu```\n has at least one outgoing edge. this may be true but you should really check it.\n\nFurther inspection with UbSan:\n\n```\n/home/sehe/custom/boost_1_67_0/boost/graph/breadth_first_search.hpp:82:30: runtime error: load of value 3200171710, which is not a valid value for type 'boost::default_color_type'\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /home/sehe/custom/boost_1_67_0/boost/graph/breadth_first_search.hpp:82:30 in \n/home/sehe/custom/boost_1_67_0/boost/graph/breadth_first_search.hpp:83:13: runtime error: load of value 3200171710, which is not a valid value for type 'ColorValue' (aka 'boost::default_color_type')\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /home/sehe/custom/boost_1_67_0/boost/graph/breadth_first_search.hpp:83:13 in \n/home/sehe/custom/boost_1_67_0/boost/graph/breadth_first_search.hpp:87:15: runtime error: load of value 3200171710, which is not a valid value for type 'ColorValue' (aka 'boost::default_color_type')\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /home/sehe/custom/boost_1_67_0/boost/graph/breadth_first_search.hpp:87:15 in \nsotest: /home/sehe/custom/boost_1_67_0/boost/graph/two_bit_color_map.hpp:86: void boost::put(const two_bit_color_map<IndexMap> &, typename property_traits<IndexMap>::key_type, boost::two_bit_color_type) [IndexMap = boost::associative_property_map<std::map<void *, unsigned long, std::less<void *>, std::allocator<std::pair<void *const, unsigned long> > > >]: Assertion `(std::size_t)i < pm.n' failed.\n```\n\n\nMaybe it's a good idea to initialize that color map. I have no clue whether this applies to your code because you didn't include the relevant code (again).\n\nSo I change that:\n\n```\nstruct VertexData {\n    vertex_descriptor pred;\n    double dist = 0, dist2 = 0;\n    boost::default_color_type color = {};\n};\n```\n\n\nNope, still same error. Reading through the code now.\n\n... 20 minutes later. Aha. You'r copying the graph into ```\nsubGraph```\n. However, you're also passing in a parameter ```\nu```\n. How could that be correct? The vertex ```\nu```\n will, most likely not be from ```\nsubGraph```\n. This is probably another source of error.\n\nLet's fix this too:\n\n```\nmsth(msth.vertex(2));\n```\n\n\nWith a new member accessor:\n\n```\nvertex_descriptor vertex(std::size_t n) const {\n    return boost::vertex(n, subGraph);\n}\n```\n\n\nReaching your comment\n\n```\n    // Problem here; The problem has to do with removing vertices/edges and destabilizing the graph, thereby making\n    // it impossible to iterate through the graph\n```\n\n\nIt becomes pretty obvious that you had a vertex ```\nu```\n from outside the graph. Nothing about \"destabilizing\" (that's not how it works. Iterators get invalidated sometimes, but nothing becomes unstable because of it: you might just invoke undefined behaviour if you're not careful).\n\nAt least, when passing a valid ```\nu```\n UbSan and ASan aren't complaining here, which is a good sign. Most likely your compiler's Debug Iterators won't be complaining either.\n\nNow, take note: \n\n\n```\nlistS```\n does not invalidate any other iterators on ```\nremove```\n (that's also in Iterator invalidation rules). Only, obviously, the one removed.\n```\nm_goal```\n suffers from the same problem as ```\nu```\n: it can hardly be from the right graph since you're copying the whole graph\nEven though ```\nremove```\n only invalidates that particular vertex descriptor, it seems you are trying to do this inside a callback for A* search. That might well break the invariants assumed by that algorithm (I haven't checked the documentation, but you should! Again, this is because you don't show the A* related code).\nYour code still seems torn on whether ```\nWeight```\n is, or is not, a ```\ndouble```\n. (Why the ```\nstatic_cast```\n?)\n\n\n\n\nEnd Result\n\nThis is what I got  in the end, various cleanups included.\n\nLive On Coliru\n\n```\n#include <boost/graph/adjacency_list.hpp>\n#include <boost/graph/astar_search.hpp>\n#include <boost/graph/visitors.hpp>\n#include <boost/graph/dijkstra_shortest_paths.hpp>\n#include <boost/graph/prim_minimum_spanning_tree.hpp>\n#include <boost/graph/graph_utility.hpp>\n#include <iomanip>\n#include <numeric>\n\ntypedef boost::adjacency_list_traits<boost::listS, boost::listS, boost::undirectedS>\n    GraphTraits;                                          // to simplify the next definition\ntypedef GraphTraits::vertex_descriptor vertex_descriptor; // vertex descriptor for the graph\ntypedef GraphTraits::edge_descriptor edge_descriptor;     // edge descriptor for the graph\ntypedef double Weight;\n\nstruct VertexData {\n    std::string name;\n    VertexData(std::string name = \"\") : name(std::move(name)) {}\n    //\n    vertex_descriptor pred {};\n    Weight dist = 0, dist2 = 0;\n    boost::default_color_type color = {};\n\n    friend std::ostream& operator<<(std::ostream &os, VertexData const &vd) {\n        return os << \"{name:\" << std::quoted(vd.name) << \"}\";\n    }\n};\n\nstruct EdgeData {\n    Weight weight = 1;\n};\n\ntypedef boost::adjacency_list<boost::listS, boost::listS, boost::undirectedS, VertexData, EdgeData>\n    MyGraphType; // graph type\n\nclass MST_Heuristic : public boost::astar_heuristic<MyGraphType, Weight> {\n    struct do_nothing_dijkstra_visitor : boost::default_dijkstra_visitor {};\n\n    auto make_index() const {\n        std::map<vertex_descriptor, size_t> m;\n        size_t n=0;\n        for (auto vd : boost::make_iterator_range(vertices(subGraph)))\n            m[vd] = n++;\n        return m;\n    }\n  public:\n    MST_Heuristic(MyGraphType g) : subGraph(g), firstRun(true) {}\n\n    Weight operator()(vertex_descriptor u) {\n\n        if (firstRun) {\n            auto idx = make_index();\n            dijkstra_shortest_paths(\n                subGraph, u,\n                get(&VertexData::pred, subGraph), // calculate the shortest path from the start for each vertex\n                get(&VertexData::dist2, subGraph),\n                get(&EdgeData::weight, subGraph),\n                boost::make_assoc_property_map(idx), std::less<Weight>(),\n                std::plus<Weight>(), std::numeric_limits<Weight>::infinity(), 0, do_nothing_dijkstra_visitor(),\n                get(&VertexData::color, subGraph));\n        }\n\n        Weight minEdgeWeight = std::numeric_limits<Weight>::max(); // initialize minEdgeWeight to weight of first out edge\n        for (auto ed : make_iterator_range(out_edges(u, subGraph))) {\n            minEdgeWeight = std::min(subGraph[ed].weight, minEdgeWeight); // find distance from nearest unvisited vertex to the current vertex\n        }\n\n        clear_vertex(u, subGraph);\n        remove_vertex(u, subGraph);\n\n        {\n            auto idx = make_index();\n            prim_minimum_spanning_tree(subGraph, vertex(0), // calculate the minimum spanning tree\n                                       get(&VertexData::pred, subGraph), get(&VertexData::dist, subGraph),\n                                       get(&EdgeData::weight, subGraph), boost::make_assoc_property_map(idx),\n                                       do_nothing_dijkstra_visitor());\n        }\n\n        //// combine\n        Weight MSTDist = 0.0;\n        Weight startDist = std::numeric_limits<Weight>::infinity();\n\n        for (auto vd : boost::make_iterator_range(vertices(subGraph))) // estimate distance to travel all the unvisited vertices\n        {\n            MSTDist += subGraph[vd].dist;\n            startDist = std::min(startDist, subGraph[vd].dist2);\n        }\n\n        firstRun = false;\n        return minEdgeWeight + MSTDist + startDist; // return the result of the heuristic function\n    }\n\n    vertex_descriptor vertex(std::size_t n) const {\n        return boost::vertex(n, subGraph);\n    }\n\n  private:\n\n    MyGraphType subGraph;\n    bool firstRun;\n};\n\nint main() {\n    MyGraphType g;\n\n    auto v1 = add_vertex({\"one\"}, g);\n    auto v2 = add_vertex({\"two\"}, g);\n    auto v3 = add_vertex({\"three\"}, g);\n    auto v4 = add_vertex({\"four\"}, g);\n    auto v5 = add_vertex({\"five\"}, g);\n\n    add_edge(v1, v2, g);\n    add_edge(v2, v3, g);\n    add_edge(v3, v4, g);\n    add_edge(v4, v5, g);\n\n    print_graph(g, get(&VertexData::name, g));\n\n    MST_Heuristic msth(g);\n    msth(msth.vertex(2));\n}\n```\n\n\nPrints\n\n```\none <--> two \ntwo <--> one three \nthree <--> two four \nfour <--> three five \nfive <--> four \n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Graph Visualisation [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Questions asking us to recommend or find a tool, library or favorite off-site resource are off-topic for Stack Overflow as they tend to attract opinionated answers and spam. Instead, describe the problem and what has been done so far to solve it.\r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI wrote a java program to calculate the minimum spanning tree with randomly generated 100 vertices and randomly generated 800 edges. I will like to plot the graph that this program generates whenever I run it. \nDoes anybody know of any tool that can help with this ?? \nMy Java code below:\n\n```\npublic static void main (String [] args)\n{\n    Random random = new Random();\n    Edge[] edges = new Edge[800];\n    for(int i = 0; i < edges.length; i++) {\n       edges[i] = new Edge(\n       Integer.toString(random.nextInt(100)),\n       Integer.toString(random.nextInt(100)),\n       random.nextInt(100) //weights from 0 to 99\n       );\n    }\n\n    System.out.println(\"Graph\");\n    KEdges vv = new KEdges();\n\n    for (Edge edge : edges) {\n        System.out.println(edge);\n        vv.insertEdge(edge);\n    }\n     System.out.println(\"Implementing Kruskal algorithm\");\n    int total = 0;\n    for (Edge edge : vv.getEdges()) {\n        System.out.println(edge);\n        total += edge.getEdgeWeight();\n    }\n    System.out.println(\"Total weight is \" + total);\n}\n\n\n static class Edge implements Comparable<Edge>\n {\n    String vertexA;\n    String vertexB;\n    int weight;\n\n    public Edge(String vertexA, String vertexB, int weight)\n    {\n        this.vertexA = vertexA;\n        this.vertexB = vertexB;\n        this.weight = weight;\n    }\n\n    public String getVertexA()\n    {\n        return vertexA;\n    }\n\n    public String getVertexB()\n    {\n        return vertexB;\n    }\n\n    public int getEdgeWeight()\n    {\n        return weight;\n    }\n\n    public String toString()\n    {\n        return \"(\"+ vertexA + \", \" + vertexB + \") : weight \"+ weight ;\n    }\n    @Override\n    public int compareTo(Edge o) {\n       return (this.weight < o.weight)? -1 : 1;\n    }\n\n}\n\nstatic class KEdges \n{\n    Vector<HashSet<String>>  vertexGroups = new Vector<HashSet<String>>();\n    TreeSet<Edge> kruskalEdges = new TreeSet<Edge>();\n\n    public TreeSet<Edge> getEdges()\n    {\n        return kruskalEdges;\n    }\n\n    public HashSet<String> getVertexGroup(String vertex)\n    {\n        for (HashSet<String> vertexGroup : vertexGroups)\n        {\n            if (vertexGroup.contains(vertex))\n            {\n                return vertexGroup;\n            }\n        }\n        return null;\n    }\n\n  public void insertEdge(Edge edge)\n  {\n    String vertexA = edge.getVertexA();\n    String vertexB = edge.getVertexB();\n\n    HashSet<String> vertexGroupA = getVertexGroup(vertexA);\n    HashSet<String> vertexGroupB = getVertexGroup(vertexB);\n\n    if (vertexGroupA == null)\n    {\n        kruskalEdges.add(edge);\n        if (vertexGroupB == null){\n            HashSet<String> htNewVertexGroup = new HashSet<String>();\n            htNewVertexGroup.add(vertexA);\n            htNewVertexGroup.add(vertexB);\n            vertexGroups.add(htNewVertexGroup);\n        }\n    }\n    else{\n        if (vertexGroupB == null)\n         {\n             vertexGroupA.add(vertexB);\n             kruskalEdges.add(edge);\n         }\n        else if (vertexGroupA != vertexGroupB)\n         {\n        vertexGroupA.addAll(vertexGroupB);\n        vertexGroups.remove(vertexGroupB);\n        kruskalEdges.add(edge);\n         }\n    }\n  }\n\n}\n```\n\n    ", "Answer": "\r\nTake a look at JUNG or GraphViz and its java port Grappa.\n\nI normally use JUNG\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to run Dijkestra Algorithm to make it similar to Prim and generate an MST?\r\n                \r\nLet's assume I am running Dijkstra Algorithm to visit all nodes (instead of original initial node and the destination node), i.e. I am checking to see if all nodes are visited or not, instead of the destination node. Will this algorithm generate an MST (Minimum Spanning Tree)? (and is it similar to Prim?)\n    ", "Answer": "\r\nNo. Consider a graph that looks like a square, three edges cost ```\n1```\n, and the remaining one costs ```\n2```\n. The MST for this graph has cost ```\n3```\n, but if you start your Dijkstra algorithm on a vertex that contains the expensive edge, that one will be taken as it is the shortest path to the connected node.\n\nCool ASCII visualization:\n\n```\n    1\n A------B\n |      |\n1|      |1\n |      |\n C------D\n    2\n```\n\n\nIf you start Dijkstra at ```\nC```\n, ```\nCD```\n is the shortest path from ```\nC```\n to ```\nD```\n but it cannot be contained in the MST.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "how to partition a tree into two subtrees\r\n                \r\nI have a symmetric 2d array \"myMSTdata[][]\" of points that represents a minimum spanning tree MST with values 0 if there is no edge or real value that represent the weights on the edges and now I need to partition this tree into two subtrees (part1,part2) where the the cutting criteria is the edge with the maximum weight. Then repeatedly keep partitioning the larger size subtree (which means the subtree with the greater number of nodes) till the remaining number of nodes in the larger size subtree is K.  \n    ", "Answer": "\r\nWould suggest the use of Adjacency list for this kind of operations, since\n\n\nYou need to seperate the vertices repeatedly \nThe number of edges < $n$ the number of vertices. \nLarge run time benefits. \n\n\nMay I know the complexity you are looking at ?  \n\nIf you are happy with any complexity I would suggest repeated DFS, since you are working with a tree, a repeated DFS will cover all edge & vertices. The runtime will be about O(n^2) in the worst case. \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Best parallel algorithm for detecting cycles in a undirect graph\r\n                \r\nI want to detect cycles in an undirected graph such that I can find the minimum spanning tree (in particular I want to use Kruskal algorithm). Since I want to parallelize the code, I was wondering which algorithm is the best, Depth-first search of union-find algorithm? \nThanks for any suggestions. \n    ", "Answer": "\r\nOf all three MST algorithms only Boruvka's MST algorithm is easily parallelizable whereas the kruskal and prims are sequential greedy algorithms hence there is minimum scope for parallel implementation of them.\n\nNote: It is a research topic to achieve efficient parallel boruvka might find some papers\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to find the MST of a new graph if an edge which does not disconnect the graph is deleted\r\n                \r\nThis was an exam question that i recently came across. Would appreciate if someone could give me an answer.\n\nExact Question : Given a Minimum spanning tree (MST) for an edge-weighted graph G, suppose that an edge in G, which does not disconnect G, is deleted. Describe how to find the MST of the new graph. ?\n    ", "Answer": "\r\nFirst things first, if that edge is not in your Minimum Spanning Tree, then you obviously don't need to do anything.\n\nLet's suppose the deleted edge was in the MST. After the deletion, that leaves you with two connected components SubMST1 and SubMST2. Now to get the new MST you have to find the edge with minimum weight linking these two components. The cut property guarantees that this edge is necessarily in the MST of the new graph. The fact that the deleted edge did not disconnect the graph proves the existence of the said edge.\n\nA simple pass through the edges would allow you to identify it (worst case complexity is O(E), assuming you can check in constant times if the source and target of an edge lies in a given set of vertices - reasonable if you use hash tables).\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Obtain a tree from a graph by specifing root and leaves\r\n                \r\nI am looking at both jgrapht and jung but I seem to not find any method to allow me to do what I'd like.\n\nI have a graph and, by specifing a root node and some leaves, I'd like to obtain a tree from it or at least an error if this is not possible.\n\nBoth jgraphT and jung seem to have alghoritms to obtain a minimum spanning tree out of a graph, but the obtained tree is random, no one assures me that a given node will be a leaf and another will be a relay....\n    ", "Answer": "\r\nIf you consider the problem with just one leaf, then this devolves to the question \"is there a  walk that starts at the root and ends at the leaf that visits every other node at least once?\"\n\nWhich sounds an awful lot like the Longest Path problem...which is NP-hard.  (And I don't think adding more leaves helps.  :) )\n\nI can think of heuristic approaches (and of ways to prove for a specific graph, or choice of root/leaves, that the problem has no solution) but I suspect that in general you're going to have to use an exhaustive search approach, something like this:\n\n\nRemove all outgoing edges from the leaves. \nIf you can't reach everything from the root (BFS will do here), there's no solution.\nStart traversing the graph from the root.  \nAt each step:\nIf you haven't reached all the leaves and there are no more edges to traverse, there's no solution.\nIf you've reached all the leaves and all the nodes have been visited, you're done.\nOtherwise, traverse an edge you haven't traversed yet.\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum point link in 8-neighborhood\r\n                \r\nThis is my probleme, I've got a list of point in matrix and I want to link all of these points and minimize this cover.\nI work on 8-neighborhood, and link must be also on point. \n\nFor example, one solution :\n\n```\n╔═══╦═══╦═══╦═══╦═══╦═══╦═══╦═══╦═══╦═══╗\n║   ║ * ║*2 ║   ║   ║   ║   ║   ║   ║   ║\n╠═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╣\n║ 5*║   ║   ║   ║   ║   ║   ║   ║   ║   ║\n╠═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╣\n║   ║ * ║   ║   ║ 3*║   ║   ║   ║   ║   ║\n╠═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╣\n║   ║ * ║   ║   ║ * ║   ║   ║   ║   ║   ║\n╠═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╣\n║   ║   ║ * ║ * ║   ║ * ║   ║ * ║ * ║*4 ║\n╠═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╣\n║   ║ 1*║   ║   ║   ║   ║ 6*║   ║   ║   ║\n╚═══╩═══╩═══╩═══╩═══╩═══╩═══╩═══╩═══╩═══╝\n```\n\n\nOne other :\n\n```\n╔═══╦═══╦═══╦═══╦═══╦═══╦═══╦═══╦═══╦═══╗\n║   ║   ║*2 ║   ║   ║   ║   ║   ║   ║   ║\n╠═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╣\n║ 5*║ * ║   ║   ║   ║   ║   ║   ║   ║   ║\n╠═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╣\n║   ║   ║ * ║   ║ 3*║   ║   ║   ║   ║   ║\n╠═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╣\n║   ║   ║   ║ * ║   ║ * ║   ║   ║   ║   ║\n╠═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╣\n║   ║   ║ * ║   ║   ║   ║ * ║ * ║ * ║*4 ║\n╠═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╣\n║   ║ 1*║   ║   ║   ║   ║ 6*║   ║   ║   ║\n╚═══╩═══╩═══╩═══╩═══╩═══╩═══╩═══╩═══╩═══╝\n```\n\n\nSo I search an algorithm to find this minimal cover of my set of points.\nI search on internet but I don't find what I need but similar problems like Minimum spanning tree, Minimal vertex cover ...\n\nSome ideas would be appreciated\n    ", "Answer": "\r\nThe rectilinear Steiner algorithm isn't quite what you want; it depends critically on the orthogonality of available moves.\n\nInstead, I think you need Bresenham's line algorithm (as you already said) to connect points found with a basic property of added Steiner nodes: each Steiner node has three edges that meet at 120-degree angles.  The node is the Fermat point of a triangle with appropriately chosen vertices (such that those vertices form a minimal triangle in the Steiner tree).\n\nIn your example, your smallest triangle is nodes 2, 3, 5; the Fermat point A (rounded to the lattice) is just to the right of 5, as seen in your second diagram.  Your connected tree is nodes 2, 3, 5, A.\n\nThe next \"best\" triangle that includes a new node is A, 3, 1.  The Fermat point B will be in the same column as node 2, and one row below node 3.  The connected tree is now 1, 2, 3, 5, A, B.\n\nExtending the process, your remaining triangle will be 3, B, 6 (adding point C) and (I think) C, 6, 4.  There will then be a small amount of lattice dithering to achieve the final result (removing B and C from the tree).  This is your second example.  Note that the original connections AB and B1 could have chosen a point one unit to the left; the dithering would need to have them closer to node 3, and then remove B from the tree.\n\n```\n╔═══╦═══╦═══╦═══╦═══╦═══╦═══╦═══╦═══╦═══╗\n║   ║   ║*2 ║   ║   ║   ║   ║   ║   ║   ║\n╠═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╣\n║ 5*║ A*║   ║   ║   ║   ║   ║   ║   ║   ║\n╠═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╣\n║   ║   ║ * ║   ║ 3*║   ║   ║   ║   ║   ║\n╠═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╣\n║   ║   ║ B ║ * ║ C ║ * ║   ║   ║   ║   ║\n╠═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╣\n║   ║   ║ * ║   ║   ║   ║ D*║ * ║ * ║*4 ║\n╠═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╬═══╣\n║   ║ 1*║   ║   ║   ║   ║ 6*║   ║   ║   ║\n╚═══╩═══╩═══╩═══╩═══╩═══╩═══╩═══╩═══╩═══╝\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Determining whether a TreeMap is equal to a Map in java\r\n                \r\nI am coding an implementation of Prim's algorithm for deriving a Minimum Spanning Tree. My Graph is a ```\nMap<String, ArrayList>```\n in which they keys correspond to the state name and the values are the edges which hold pointers to both links.\n\nPrim's Algorithm says I should start with a Tree only containing the starting node then loop until my tree is equivalent to my graph. How can I determine equivalence of a ```\nTreeMap<String, ArrayList>```\n and ```\nMap<String, ArrayList>```\n?\n    ", "Answer": "\r\nIf by equivalence you mean key, value pairs in both maps are exactly same then you can simply use Map.equals() method which checks if entry set is same for both maps.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Updating to networkx 2.0 in conda?\r\n                \r\nI need to use maximum_spanning_tree in my Python Notebook (Jupiter). Can someone tell me how I can update my networkx to 2.+ in conda?\n\nI read the documentation at http://networkx.readthedocs.io/en/latest/install.html but it only updates to 1.11. It seems I need to install the development version.\n\nIt looks like maximum_spanning_tree is not supported by networkx 1.11.\n\nSidenote: For networkx 1.1, one user suggested here to change all the edge weights to negative (-1 * edge_weight) and take MST (Minimum Spanning Tree?). The user claims this would return the maximum spanning tree. Any conformation?\n\nThanks!\n\nSolved via console:\n\n```\ngit clone https://github.com/networkx/networkx.git\n\ncd networkx\n\npython setup.py install\n```\n\n    ", "Answer": "\r\nYou should be able to install the current master branch using:\n\n```\n$ pip install git+http://github.com/networkx/networkx\n```\n\n\nThe master branch should be in good shape and we would love additional feedback on it as we finalize the 2.0 release.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Create graph using Jgraph\r\n                \r\nI want to create a graph using Jgraph, and later use that graph to find the minimum spanning Tree. \n\nHow to create a graph using Jgraph?.\n\n\n\nthis is what I have implemented.  Can you please tell me how to use kruskals algorithm from the package. I googled it, but couldn't find any information on it.\n\n```\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\npublic class MyGraph {\n    UndirectedGraph<String, DefaultEdge> g = new SimpleGraph<String, DefaultEdge>     (DefaultEdge.class);\n\n    public void addVertex(String name)  {\n        // name=new String();\n        g.addVertex(name);\n    }\n\n    public void addEdge(String v1,String v2) {\n        g.addEdge(v1, v2);\n    }\n\n    public UndirectedGraph<String, DefaultEdge> getGraph() {\n        return g;\n    }\n}\n```\n\n    ", "Answer": "\r\nThis the main class where user input such as no of edges and vertices is taken to create a graph to the Spanning tree of the graph created. Below is the complete answer to this question. \n\n```\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String args[]) {\n\n        int x;\n        Scanner sc=new Scanner(System.in);\n        MyGraph my=new MyGraph();\n        System.out.println(\"Enter the no of vertices\");\n        int no_of_ver=sc.nextInt();\n\n        for(int i=1;i<=no_of_ver;i++) {\n            System.out.println(\"Enter vertex\"+i);\n            my.addVertex(sc.next());\n        }\n\n        do {\n            System.out.println(\"Enter the edges\");\n            String e1=sc.next();\n            String e2=sc.next();\n            my.addEdge(e1, e2);\n            // my.setEdgeWeight();\n            System.out.println(\"Continue... Yes:1 ********** No:0\");\n            x=sc.nextInt();\n        } while(x==1);\n\n        System.out.println(\"Graph\\n\"+my.getGraph().toString());\n        System.out.println(\"\\n\\n**********Spanning Tree*********\");\n        my.getSpanningTree();\n        // System.out.println(\"\\nSpanning Tree Cost\");\n        //my.getSpanningTreeCost();\n    }\n}\n```\n\n\nBelow MyGraph class does all the work of creating the graph by taking edges and calculating the spanning tree. I have used jgrapht library to create graph\n\n```\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\nimport org.jgrapht.alg.KruskalMinimumSpanningTree;\n\npublic class MyGraph {\n\n    private UndirectedGraph<String, DefaultEdge> g = new SimpleGraph<String, DefaultEdge>(DefaultEdge.class);\n    static final double DEFAULT_EDGE_WEIGHT=19;\n    DefaultWeightedEdge>(DefaultWeightedEdge.class); \n    private DefaultWeightedEdge e1;\n\n    public void addVertex(String name) {\n        g.addVertex(name);\n        //graph.addVertex(name);\n    }\n\n    public void addEdge(String v1,String v2) {\n        g.addEdge(v1, v2);\n        // e1=graph.addEdge(v1, v2);\n    }\n\n    /*public void setEdgeWeight() {\n        graph.setEdgeWeight(e1, DEFAULT_EDGE_WEIGHT);          \n    }*/\n\n    public UndirectedGraph<String, DefaultEdge> getGraph() {\n        return g;\n    }\n\n    /*public SimpleWeightedGraph<String,DefaultWeightedEdge> getGraph() {\n        return graph;\n    }*/\n\n    public void getSpanningTree() {\n        KruskalMinimumSpanningTree k=new KruskalMinimumSpanningTree(g);\n        System.out.println(k.getEdgeSet().toString());\n        //KruskalMinimumSpanningTree k1=new KruskalMinimumSpanningTree(graph);\n        //System.out.println(k1.getEdgeSet().toString());   \n    }\n\n    /*public void getSpanningTreeCost() {\n        KruskalMinimumSpanningTree k=new KruskalMinimumSpanningTree(graph);\n        System.out.println(k.getSpanningTreeCost());\n    }*/ \n}\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Special Case for MST algorithm in linear time\r\n                \r\nLet G = (V, E) be a weighted undirected connected graph, where all the\nedge weights are distinct. Let T denote the minimum spanning tree.\n\nSuppose that G has m ≤ n + 157 edges. For this special case, give an MST\nalgorithm that runs in O(n) time beating Kruskals and Prims algorithm.\n\nAny hints? \n    ", "Answer": "\r\nFirst verify that the graph is connected.\n\nThen repeat until the graph is a tree (# edges = n-1):\n\n\nFind a cycle using DFS.  There must be one since #edges >= n\nRemove the longest edge in the cycle.  It cannot be part of the MST.\n\n\nWhen done you are left with the MST.\n\nEven though this can take O(n) time per iteration, there will be at most 158 iterations, so that is still O(n) all together.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "C# graphs algorithms library\r\n                \r\nI'm looking for .NET library with the next graphs algorithms:\n\n\nalgorithm for finding a minimum\nspanning tree;\nalgorithm for partitioning graph for N subgraphs with minimal number of connections.\n\n\nI can write my own realization, but don't have too much time. Tell me, please, names of any existing libraries that can do this. Thanks.\n    ", "Answer": "\r\nyWorks provides several products for .NET\nDepending on where you plan on deploying you can choose your flavor and perform lots of analyses on the graph.\nAlthough I'm not fond of the API (a bit too java-ish), the biggest disadvantage is definitely the price.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Java implementations of common data structures and algorithms\r\n                \r\nI'm looking for some standard implementations of a number of common data structures and algorithm, such as:\n\n\nBinary, AVL and red-black trees\nTree visitors such as Euler tour\n(Weighted) graphs and DAGs\nGraph searches\nTravelling salesman algorithms such as Dijkstra's algorithm\nMinimum spanning trees/Krushal's algorithm\n\n\nEtc etc etc.\n\nI'd hoped there'd be an Apache common-XXX package, but alas not?\n    ", "Answer": "\r\nhttp://jgrapht.org/ provides the bottom 5, the trees are implemeted in core java. \n\nJust a note : I couldnt remeber the  name and googled 'Java Graph Algortihms'. It was the first result. :)\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Creating a graph based on specific conditions\r\n                \r\nI have a question that asks me to make a graph such that the BFS and DFS trees from the graph is not a minimum spanning tree and the order of the adjacency list does not matter, I know the properties of BFS DFS and MST but I'm a confused by the question. How should I be approaching the problem? (not looking for the solution)\n    ", "Answer": "\r\nImagine a complete graph on ```\nk```\n vertices. For ```\nk > 3```\n, a ```\nDFS```\n tree will always look different from a ```\nBFS```\n tree. For ```\nk > 4```\n, you can have a ```\nMST```\n that is different from both the ```\nBFS```\n and ```\nDFS```\n trees. You can choose the shape of the ```\nMST```\n to be different from the ```\nDFS```\n tree by ensuring one vertex needs three edges coming out of it. You can choose the shape of the ```\nMST```\n to be different from the ```\nBFS```\n tree by ensuring no vertex has more than three edges coming out of it. You choose the shape of the ```\nMST```\n by assigning weights to make the edges you choose, and only those edges, part of the ```\nMST```\n.\n\n```\nDFS Tree\n\n1-----2----3\n           |\n           |\n     4-----5\n\nBFS Tree\n\n      1\n  ____|____\n /   / \\   \\\n2   3   4   5\n\nMST\n\n2\n|\n1---3---5\n|\n4\n```\n\n\nThe complete graph on five vertices has 5 * 4 / 2 = 10 edges, of which only four are needed in any tree. \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Kurskal algorithm, Runtime Error in Kattis\r\n                \r\nI've been trying to solve the Minimum Spanning Tree on Kattis. (https://open.kattis.com/problems/minspantree)  The first test runs fine, the second gives an unspecified runtime error. I've been struggling with this for over a week. It must be some logical error, but no matter how much effort i'm putting into it, I can't see what's wrong.\n\n```\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n\nusing namespace std;\n\nclass DisjointSet {\npublic:\n    vector<int> parent, rank;\n\n    DisjointSet(int _size) {\n        parent.resize(_size);\n        rank.resize(_size); // Maybe this?\n        // make the sets\n        for (int i = 0; i < _size; i++) { // fill set \n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n\n\n    void make_set(int v) {\n        parent[v] = v;\n        rank[v] = 0;\n    }\n\n    int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        return parent[v] = find_set(parent[v]);\n    }\n\n    void union_sets(int a, int b) {\n        a = find_set(a);\n        b = find_set(b);\n        if (a != b) {\n            if (rank[a] < rank[b])\n                swap(a, b);\n            parent[b] = a;\n            if (rank[a] == rank[b])\n                rank[a]++;\n        }\n    }\n\n};\nbool sort_weight(const tuple<int, int, int> &one, const tuple<int, int, int> &two) {\n    return get<2>(one) < get<2>(two); // Weight\n}\nbool sort_node(const tuple<int, int, int> &one, const tuple<int, int, int> &two) {\n    if (get<0>(one) != get<0>(two)) {\n        return get<0>(one) < get<0>(two); // node one\n    } \n    return get<1>(one) < get<1>(two); // node two\n}\n\nint main()\n{\n\n    int n_nodes = 0, n_arcs = 0;\n    int tmp_node1, tmp_node2, tmp_weight;\n\n    while (cin >> n_nodes >> n_arcs) { // Until the end\n        if (n_nodes == 0 && n_arcs == 0) { break; }\n        if (n_arcs < n_nodes - 1) { // If it is not possible to build a MST\n            cout << \"Impossible\\n\";\n        }\n        else {\n            int cost = 0;\n            DisjointSet s(n_nodes); // make set\n            vector<tuple<int, int, int>> vArcs;\n            vector<tuple<int, int, int>> vResult;\n            vArcs.resize(n_arcs);\n\n            for (int i = 0; i < n_arcs; i++) {\n                cin >> tmp_node1 >> tmp_node2 >> tmp_weight;\n                vArcs[i] = make_tuple(tmp_node1, tmp_node2, tmp_weight);\n            }\n\n\n            sort(vArcs.begin(), vArcs.end(), sort_weight); // Sort by weight lowest to highest\n\n            for (int i = 0; i < n_arcs && vResult.size()<(n_nodes - 1); i++)\n            {\n                if (s.find_set(get<0>(vArcs[i])) != s.find_set(get<1>(vArcs[i]))) {\n                    cost += get<2>(vArcs[i]);\n                    vResult.push_back(vArcs[i]);\n                    s.union_sets(get<0>(vArcs[i]), get<1>(vArcs[i]));\n                }\n            }\n            // We are done, order and print\n            sort(vResult.begin(), vResult.end(), sort_node);\n            cout << cost << \"\\n\";\n            for (int i = 0; i < vResult.size(); i++)\n            {\n                cout << get<0>(vResult[i]) << \" \" << get<1>(vResult[i]) << \"\\n\";\n            }\n        }\n    }\n}\n```\n\n    ", "Answer": "\r\nYou need to read the whole input for each test case, even if the number of edges is below ```\nn - 1```\n.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Solving a minimax path problem with some constraints\r\n                \r\nI have a problem where an undirected graph with positive weights are given. There are N vertices and I need to get the minimum of the maximum weight between 2 vertices in a path from all possible paths from vetex 1 to N. However the total weight of these possible paths cannot be more than T. \n\nI realised this is a minimax path problem, so I could construct a minimum spanning tree from the graph and from there, I could get the min-max weight of the paths. But how can I construct the minimum spanning tree with the constraint that the total weight from 1 to N cannot be more than T?\n\n\n\nEg. In the picture, only 1256 and 1356 are possible paths if T is 13. Path 1456 is not considered because the total weight adds up to 14. \n\nAnd between 1256 and 1356, the edge 35 of weight 7 is the minimax weight of the paths.\n    ", "Answer": "\r\nAssuming positive edge weights, you could solve this in O((m + n log n) log m) time by doing binary search over which of the m edges is the minimum maximum. The binary search requires O(log m) iterations, each of which costs O(m + n log n) time with Dijkstra's algorithm to find shortest paths on the graph with all edges that weigh no more than the maximum, testing whether there is a short enough path from 1 to N.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "What is a Acyclic connected undirected graph?\r\n                \r\nI was going through lecture of Minimum Spanning Tree, It says we are supposed to find connected acyclic subgraph  graph in a Undirected graphs.\n\nMy question is that How can a connected undirected graph be a Acyclic, Since it is connected you can move to any vertex from any vertex.\n\nCan anyone tell me what I am doing wrong?\n    ", "Answer": "\r\nIt's really just a matter of definition. See http://en.wikipedia.org/wiki/Cycle_(graph_theory). What you seem to refer to as a cycle, is what is called a closed walk in the article: any path from a vertex to itself. As you have said yourself, using that definition, any connected undirected graph contains cycles. However, if you require that the subpath from the second to the last vertex be a simple path (hence simple cycle), i.e. one containing no repeating vertices, you end up with many connected undirected graphs which are in fact acyclic, such as trees for instance. Obviously, the path also has to contain at least 3 edges, else any ```\n(A,B,A)```\n would be a cycle.\n\nConsider the following graphs\n\n```\n     A         A\n1)  / \\   2)  / \\\n   B   C     B - C\n```\n\n\nonly ```\n2)```\n contains simple cycles, so ```\n1)```\n is acyclic.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Reduction of Leaf constrained MST p‌r‌o‌b‌l‌e‌m to Hamiltonian path p‌r‌o‌b‌l‌e‌m\r\n                \r\nIt is well known that computing a spanning tree that has the minimum possible number of leaves is NP complete. But I cannot figure out a polynomial time reduction of this problem to the hamiltonian path problem. \n\nMy exponential reduction: \n\n```\nif(hamiltonian path exists for whole graph) \n    min leaves = 1;\n    return;\nelse\n    for each vertex of the graph\n        if(hamiltonian path exists for this graph after removing the vertex and its incident edges)\n            min leaves = 2;\n            return;\n    continue similarly for the graph deleting 2 vertices, 3 vertices, 4vertices,... until you get a minimum spanning tree with some minimum number of leaves.\n```\n\n\nSo, in the worst case, this algorithm will make a total of \n\n```\n(N choose 1) + (N choose 2) + (N choose 3) + ....(N choose N) = 2^N\n```\n\n\ncalls to the hamiltonian path problem . Hence reduction is exponential. \n\nPlease suggest a polynomial time reduction for this problem.\n    ", "Answer": "\r\nThe idea of reducing the algorithm is that if you can show that the Hamiltonian Path problem can be solved using the constrained MST problem, (with a polynomial time reduction), then any polynomial time solution to the MST problem would allow you to solve the Hamiltonian Path problem in polynomial time. As this is impossible, it would prove the constrained MST problem cannot be solved in polynomial time.\n\nWhat you are trying to do is the opposite - proving that the Hamiltonian Path problem is at least as hard as the constrained MST problem.\n\nNote that you stated in the comments that your assignment was to reduce from the Hamiltonian Path problem, and in the question you said you were trying to reduce to the Hamiltonian Path problem.\n\nYou can easily solve the Hamiltonian Path problem using the constrained MST problem, as a Hamiltonian Path will always be a spanning tree with 2 (or 0 for a Hamiltonian Cycle) leaves.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "jgrapht KruskalMinimumSpanningTree retrieving the edge weights\r\n                \r\nI have a graph and I need to get the minimum spanning tree so I used ```\nKruskalMinimumSpanningTree```\n class, now I need to retrieve each edge weight so according to the API of DefaultWeightedEdge there's a method ```\ngetWeight()```\n\nwhich retrieves the weight of an edge, However after implementing the following code the method ```\ngetWeight()```\n doesn't exist!\n\n```\n     KruskalMinimumSpanningTree<Pixel, DefaultWeightedEdge> k= new KruskalMinimumSpanningTree(gg);\n         Set<DefaultWeightedEdge> itr = k.getSpanningTree().getEdges();\n         for(DefaultWeightedEdge edge: itr)\n             System.out.println(edge.getWeight());\n```\n\n\nwhy is this happening ? \n    ", "Answer": "\r\nOK. i found a solution for my question, apparently these methods are protected. one way of doing it is: \n\n```\n   KruskalMinimumSpanningTree<Pixel, DefaultWeightedEdge> k= new \n    KruskalMinimumSpanningTree(gg);\n         Set<DefaultWeightedEdge> itr = k.getSpanningTree().getEdges();\n         for(DefaultWeightedEdge edge: itr)\n             System.out.println(gg.getEdgeWeight(edge));\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Alternative to this python code?\r\n                \r\nI have a line of code from class that I don't understand fully and want some easier alternative to. What this does is , uses weightList, which is a list of edges that's connected to each other, and returns the edgelists with lowest corresponding value from the graph (adjacency matrix). This is for a Prim's Minimum Spanning Tree problem.\n\n```\nedge = sorted(weightList, key=lambda e:graph[e[0]][e[1]])[0];```\n        \n    ", "Answer": "\r\nBreaking it up a little bit could be enough. How about this?    \n\n```\nget_edge_weight = lambda e: graph[e[0]][e[1]]\nsorted_weights = sorted(weightList, key=get_edge_weight)\nedge = sorted_weights[0]\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "awkward behaviour of file reading in c program (SIGSEV signal)\r\n                \r\nI implemented a program which is supposed to find minimum spanning tree using Prim. The graph's edges are described in a file.\n\nSo first of all, the program reads this file and stocks edges in a data structure. After that, it runs the algorithm. Here is the full code :\n\n```\n      #include <stdio.h>\n\n\n    #include <stdlib.h>\n\n      #define MAXVERTICES 1000\n      #define INFINITY 99999\n      #define TAILLEMAX 100\n\n      struct vertex {\n            int visited, predecessor;\n            int dist;   // distance qui sépare ce noeud de la distance minimale d'un autre noeud\n      };\n\n      int treeEdge[MAXVERTICES][2], mstCost; // tableau des 'aretes' qui constituent l'arbre couvrant\n      int graphEdge[MAXVERTICES][MAXVERTICES], nodeCount; // matrice d'adjacences (couts séparant chaque sommet des autres sommets)\n      struct vertex node[MAXVERTICES];  // tableau de sommets numérotés de 1 à n\n\n      /* construct the input graph */\n\n      void buildGraph() {\n            int source, dest, weight, test;\n            char temp[TAILLEMAX];\n\n        FILE* fichier = NULL;\n        fichier = fopen(\"inst_v100.txt\", \"r\");\n        if (fichier != NULL)\n        {\n            fgets(temp, TAILLEMAX, fichier); // sauter ligne\n            fscanf(fichier,\"%s%d\",temp,&nodeCount); // nbr de sommets\n            fgets(temp, TAILLEMAX, fichier);\n            fgets(temp, TAILLEMAX, fichier);\n\n            while (1)\n            {\n                    test = fscanf(fichier,\"%d%d%d\",&source,&dest,&weight);\n                    if(test==0)\n                        break;\n                    /* update weight of the edge */\n                    graphEdge[source][dest] = weight;\n                    graphEdge[dest][source] = weight;\n                    fgets(temp, TAILLEMAX, fichier); // sauter ligne\n            }\n        }\n        fclose(fichier);\n        return;\n  }\n\n\n\n    /* all vertices are visited or not */\n      int allVisited() {\n            int i;\n            for (i = 0; i < nodeCount; i++)\n                    if (node[i].visited == 0)\n                            return 0;\n            return 1;\n      }\n\n      /* construct minimum spanning tree */\n      int buildTree() {\n            int i = 0, count = 0, currentNode, mindist;\n            while (i < nodeCount) {\n                    node[i].visited = 0;\n                    node[i].predecessor = 0;\n                    node[i].dist = INFINITY;\n                    i++;\n    }\n\n        node[0].visited = 1;\n        node[0].dist = 0;\n\n        currentNode = 0;\n        while (allVisited() == 0) {\n                for (i = 0; i < nodeCount; i++) {  // pour le sommet courant, chercher la distance min qui le sépare de chaque sommet\n\n                        /* Find the adjacent vertices and update the edge lenght */\n                        if(graphEdge[currentNode][i] > 0 && node[i].visited == 0) {\n                                if (graphEdge[currentNode][i] < node[i].dist) {\n                                        node[i].predecessor = currentNode;\n                                        node[i].dist = graphEdge[currentNode][i];\n                                }\n                        }\n                }\n\n                mindist = INFINITY;\n                /* trouver l'arete avec le poids minimum */\n                for (i = 0; i < nodeCount; i++) {\n                        if (node[i].dist < mindist && node[i].visited == 0) {\n                                mindist = node[i].dist;\n                                currentNode = i;\n                        }\n                }\n                /* Mark the vertex as visited - edge with min cost */\n                node[currentNode].visited = 1;\n                treeEdge[count][0] = node[currentNode].predecessor;\n                treeEdge[count][1] = currentNode;\n\n                /* calculate cost of MST */\n                mstCost = mstCost + graphEdge[treeEdge[count][0]][treeEdge[count][1]];\n                count++;\n        }\n        return count;\n  }\n\n  int main() {\n        int i, count1;\n\n        /* construct graph */\n        buildGraph();\n        count1 = buildTree();\n        printf(\"MST is composed of below edges:\\n\");\n        for (i = 0; i < count1; i++) {\n                printf(\"%d<->%d\\n\", treeEdge[i][0], treeEdge[i][1]);\n        }\n        printf(\"\\n\");\n        printf(\"Cost of Minimum Spanning Tree: %d\\n\", mstCost);\n        return 0;\n  }\n```\n\n\nAwkwardly, when the execution starts, the program sends a SIGSEV signal.\n\ncould you help me figure out the mistake i'm doing ? Thank's in advance.\n    ", "Answer": "\r\nProblem Solved.\n\nIn fact if you look closely, i used fgets and fscanf and it caused ambiguity.\nThe solution was using fgets (to store the line read in a string), then sscanf to take informatio needed from that string.\n\nIt gives something like this :\n\n```\n    fgets(the_string, MAXLENGTH, file);\n    sscanf(the_string,\"%d\",&number_wanted);\n```\n\n\nthank you very much anyway, and i hope my answer will be helpful for other people with same problem.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Cheriton-Tarjan algorithm for MST\r\n                \r\nI am searching the Cheriton-Tarjan algorithm for weighted minimum spanning trees, with O(m*loglogn). But I was not able to find it anywhere. Can someone explain me the algorithm or tell me a link as where to find it?\n    ", "Answer": "\r\nIt's \"Tarjan\" not \"Trajan\". That may be a reason why you've had trouble finding it. \n\nHere's pseudocode for the algorithm, taken from here (Graphcs, Algorithms, and Optimization by William Kocay and Donald Kreher):\n\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Prim's algorithm for weighted directed graph\r\n                \r\nI am learning minimum spanning tree. I go through Prim's algorithm for weighted directed graph.\n\nAlgorithm is simple\n\n\n  \n  you have two set of vertices, visited and non-visited\n  set distance for all edges to infinity\n  start with any vertex in non-visited set and explore its edges\n  In all edges, update distance of the destination vertex with the weight of the edge if destination vertex it is not visited and if weight of the edge is less than the distance of destination vertex\n  pick the non-visited vertex with smallest distance and do it again until all vertex are visited\n  \n\n\nI believe with above algorithm, I will be able to find the spanning tree having minimum cost among all spanning trees, i.e. Minimum spanning tree.\n\nBut I applied it to the following example and I think it is failed.\n\nConsider following example\n\nVertices are {v1,v2,v3,v4,v5} and edges with weight (x,y) : w => \n(v1,v2) : 8 \n(v1,v3) : 15 \n(v1,v4) : 7 \n(v2,v5) : 4 \n(v4,v5) : 7 \n\nFirst I explore v1, it has edges to v2,v3,v4 so graph become \nVertex v1 is visited and (vertex, distance) =>\n(v2,8)\n(v3,15)\n(v4,7)\n\nNow v4 has the least distance i.e. 7 so I explore v4, it has edge to v5 so following modification occur \nVertex v4 is visited and (vertex, distance) => (v5,7) \n\nNow among all v5 is having the least distance , i.e. 7 , so I explore v5 and it does not have any edge so I just mark it visited\n\nVertex v5 is visited\n\nNow, confusion starts from here\n\nThe vertex with the least distance is now v2, it has edge to v5 with the weight 4 and currently v5 having distance is 7, previously assigned by the edge (v4,v5) : 7 , so, I believe that to make minimum spanning tree, distance for v5 should be updated from 7 to 4 as 4 < 7 but it will not because v5 has already been visited and Prim's Algorithm do not update the distance of the vertex that already been visited and distance for v5 will remain 7 instead of 4 and this tree will not have minimum cost \n\nDo I get it right ? or am I doing any mistake ?\n\nThanks\n    ", "Answer": "\r\nFirst I should mention that Prim's algorithm is just applicable to undirected graphs so if we consider the graph is undirected, this is the step by step progress of the algorithm on your case:\n\n \n\nAnd you should consider that finding a minimum spanning tree is not even possible many times in the directed graphs, nevertheless the closest notion to MST for directed graphs is minimum cost arborescence.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Segmentation Fault in C++ implementation of Kruskal's Algorithm\r\n                \r\nI have written this code which implements the Kruskal's algorithm for Minimum Spanning Tree, which yields segmentation fault when I submit it to an online judge. I think I have narrowed the cause of segmentation fault to the part where I sort the edges. Still, I can't find the exact reason why this code fails.\n```\nstruct DisjointSet{\n    private:\n        struct Node{\n            int size;\n            int repr;\n            Node(int rep){\n                size = 1;\n                repr = rep;\n            }\n        };\n        vector<Node> nodes;\n    public:\n        int makeSet(){\n            nodes.push_back(Node(nodes.size()));\n            return nodes.size() - 1;\n        }\n        int findRepresentative(int ind){\n            if(nodes[nodes[ind].repr].size == -1){\n                nodes[ind].repr = findRepresentative(nodes[ind].repr);\n            }\n            return nodes[ind].repr;\n        }\n        void unionSets(int ind1, int ind2){\n            int rep1 = findRepresentative(ind1), rep2 = findRepresentative(ind2);\n            if(rep1 != rep2){\n                if(nodes[rep1].size < nodes[rep2].size){\n                    int t = rep1;\n                    rep1 = rep2;\n                    rep2 = t;\n                }\n                nodes[rep1].size += nodes[rep2].size;\n                nodes[rep2].size = -1;\n                nodes[rep2].repr = rep1;\n            }\n        }\n};\n\nbool compare(const pair<pair<int, int>, int> &p1, const pair<pair<int, int>, int> &p2){\n    return (p1.second <= p2.second);\n}\n\nint spanningTree(int V, int E, vector<vector<int>> &graph) {\n    vector<pair<pair<int, int>, int>> edges;\n    for(int i = 0;i < V;i ++){\n        for(int j = 0;j < V;j ++){\n            if(i <= j){\n                if(graph[i][j] != INT_MAX){\n                    edges.push_back(make_pair(make_pair(i, j), graph[i][j]));\n                }\n            }\n        }\n    }\n    sort(edges.begin(), edges.end(), compare);\n    DisjointSet d;\n    for(int i = 0;i < V;i ++){\n        d.makeSet();\n    }\n    int weight = 0;\n    for(int i = 0;i < edges.size();i ++){\n        int u = edges[i].first.first, v = edges[i].first.second;\n        if(d.findRepresentative(u) != d.findRepresentative(v)){\n            d.unionSets(u, v);\n            weight += edges[i].second;\n        }\n    }\n    return weight;\n}\n```\n\n    ", "Answer": "\r\nYour compare function:\n```\nbool compare(const pair<pair<int, int>, int> &p1, const pair<pair<int, int>, int> &p2){\n    return (p1.second <= p2.second);\n}\n```\n\ndoes not provide a strict-weak ordering, since comparing 2 elements ```\ne1```\n and ```\ne2```\n with the same ```\n.second```\n will return true for both ```\ne1 < e2```\n and ```\ne2 < e1```\n, which is not allowed. Using this ```\ncompare```\n function in sort invokes undefined behavior, potentially causing a segfault.\nYou need to do something like:\n```\nbool compare(const pair<pair<int, int>, int> &p1, const pair<pair<int, int>, int> &p2){\n    return p1.second < p2.second;\n}\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Networkx graph and labels\r\n                \r\nI am having some troubles to understand how networkx library works & nodes' labels. Let's assume I have a correlation matrix in a pandas dataframe:\n```\nimport pandas as pd\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\nD = pd.DataFrame\\\n({'A': [1, 0.5, 0.1], 'B': [0.5, 1, 0.3], 'C': [0.1, 0.3, 1]}, index =  ['A', 'B', 'C'])\n```\n\nI now would like to plot the simple graph representation of this correlation matrix (so a triangle in this example), and then generate the minimum spanning tree for bigger correlation matrices/distance matrices.\n```\ncorr_graph = nx.from_pandas_adjacency(D)\npos = nx.spring_layout(corr_graph)\nnx.draw_networkx_nodes(corr_graph ,pos=pos, label = ['A', 'B', 'C'])\nnx.draw_networkx_edges(corr_graph ,pos=pos)\nnx.draw_networkx_edge_labels(corr_graph , pos=pos)\nplt.axis('off')\nplt.show()\n```\n\nSo the graph is generated, with correct labels on each edges. On the nodes I have the self-loop edges ```\n{'weight':1}```\n but the nodes themselves have no labels and I wanted to have them as A, B and C as in my initial dataframe so I can identify them. My other question is how to remove the self-loop edges labels.\nI'd like to do the same with the minimum spanning tree but first I am just trying to do it on the simple graph.\nThank you,\n    ", "Answer": "\r\nDrawing node labels\n(in-built function):\n```\nnx.draw_networkx_labels(corr_graph, pos=pos)\n```\n\nRemoving self loops:\nmethod 1:\nset the diagonal to zero, and then create the graph:\n```\n# for example\nE = D - np.eye(D.shape[0])\ncorr_graph = nx.from_pandas_adjacency(E)\n```\n\nmethod 2:\ncreate graph, and only draw edges that have different source and dest.\n```\ncorr_graph = nx.from_pandas_adjacency(D)\nedges = [(a,b) for (a,b) in corr_graph.edges() if a != b]\nnx.draw_networkx_edges(corr_graph, edgelist=edges, pos=pos)\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Error in Wikipedia pseudocode for Prim's Algorithm?\r\n                \r\nSo I'm looking at the Wikipedia entry on Prim's algorithm:\n```\n1. Associate with each vertex v of the graph a number C[v] (the cheapest cost of a connection to v) and an edge E[v] (the edge providing that cheapest connection). To initialize these values, set all values of C[v] to +∞ (or to any number larger than the maximum edge weight) and set each E[v] to a special flag value indicating that there is no edge connecting v to earlier vertices.\n2. Initialize an empty forest F and a set Q of vertices that have not yet been included in F (initially, all vertices).\n3. Repeat the following steps until Q is empty:\n      a. Find and remove a vertex v from Q having the minimum possible value of C[v]\n      b. Add v to F\n      c. Loop over the edges vw connecting v to other vertices w. For each such edge, if w still belongs to Q and vw has smaller weight than C[w], perform the following steps:\n            i. Set C[w] to the cost of edge vw\n            ii. Set E[w] to point to edge vw.\n4. Return F\n```\n\nMy question is about step 3.b (\"Add v to F\").  Is step 3b an error? \"v\" is a vertex and the Minimum Spanning Tree is a set of edges (not a set of vertices).\nIt seems like step 3b ought to read \"Add E[v] to F\" instead.\n    ", "Answer": "\r\nStep 3b adds vertex v to F.  Steps ci and cii then add edges to F\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Color edges of a tree\r\n                \r\nUsing ```\nvegan```\n to create minimum spanning tree:\n\n```\nlibrary(vegan)\nMST <- spantree(D)\n```\n\n\nwhere D is a distance / dissimilarity matrix amongst N entities.\n\nI then plot using:\n\n```\nplot(MST, type = \"t\")\n```\n\n\nI now want to color the different nodes of the tree, depending on a label I have in ```\nDataSet$SubGroups```\n, indicating which subgroup each of the N entities belong to. So that for instance, for all entities for which ```\nDataSet$SubGroups == SubGroup1```\n, I want their label to be Green, for Subgroup2 Blue etc. \n\nI tried with nodelabels from the ape package, but no luck as I get:\n\n\n```\nError in get(\"last_plot.phylo\", envir = .PlotPhyloEnv) :    object\n'last_plot.phylo' not found\n```\n\n\n\nAnybody any idea on how to get the color right?\n\nIs it also possible to specify RGB color codes?\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Why the cut property doesn't work with cycle in Kruskal's algorithm?\r\n                \r\nIn Kruskal's algorithm, I am trying to understand why we cannot use the cut property on a cycle to show that the edge creating the cycle must be in the minimum spanning tree. In the examples I have seen, it has been impossible to create a cut such that the edge we are considering in kruskal's which creates a cycle is a minimum crossing edge. However, when the edges are of equal weight, such a cut is possible and I am wondering if the possibility in this case is relevant.\nAlso more generally, I would appreciate some insight as to how we can cut the graph during Kruskal's to show how the edges it considers can be minimum crossing edges. My unerstanding is we can think of the graph being cut two sets, one containing each vertex implicated in the edge, and segments of the minimum spanning tree was have connected thus far being in either set if they are connected to any of the vertices of the edge. It seems to avoid the conundrum of the edge was have picked not being a minimum crossing edge, we would want the minimum spanning tree was have connected thus far to be in its own set, so that none of its lesser-weighted edges can be crossing edges (so that are current edge could have the least weight out of any crossing edge).\nthanks!\nTo Try to understand the problem of showing an edge creating a cycle not to be a minimum crossing edge, I have drawn out examples of this happening to see a common pattern between these graphs which prevented this edge from being a minimum crossing edge. I have not yet achieved intuition as to this.\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "looking for similar known problems\r\n                \r\nI am trying to prove the computer complexity of this optimization problem:\nGiven a connected graph G = (V, E) and a set S ⊊ V. Find a connected subgraph G'= (V', E ') that:\n\n```\nMin f(G')\nMin |V'|\n```\n\n\nsubjet to:\n\n```\nS ⊊ V’\nV’ ⊆ V\n```\n\n\nIt looks like a generalization of the minimum spanning tree problem when not all vertexes have to be included in the tree. \nIs there a known problem that can be used to proof the complexity of this problem by reduction?\n    ", "Answer": "\r\nYour problem formulation is not saying what you're optimizing on-- f(G') first and within that Min|V'|, or the other way round, or the two combined in some way. \n\nif you optimize on the cost edges, it is the Steiner minimal tree (SMT) problem as is and NP-complete. if you optimize on |V'|, you can reduce SMT to it in polynomial time with the following:\n\nLet edge (u,v) between nodes u and v have cost k. Replace this edge by the following path:\n\n```\n(u, i_1), (i_1, i_2), ..., (i_k, v) \n```\n\n\nso that the cost of each edge on this path is 1. You replaced the edge of cost (u, v) with a path with k-1 intermediary nodes on it and every edge has cost 1. \n\nDo this for every edge on graph. It reduces SMT to your problem and proves that yours optimizing on |V'| is NP-complete. Your reduction takes \n\n```\nO(C*|V|^2) \n```\n\n\ntime where C is an upper bound on the cost of edges in graph. \n\nJust saw the problem. Hope it helps.  \n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Modified version of Prim's algorithm with O(kn + m) time complexity\r\n                \r\nCould you please help me with this problem?\n\nGiven an undirected graph G, connected, with weighted edges, such that the weights are integers in [1,k] . Write a modified version of Prim's algorithm that returns the minimum spanning tree in O(kn+m) time.\n\nNote:\n\n\nn represents the number of vertices\nm represents the number of edges\n\n    ", "Answer": "\r\nYou should be using the limited range of the edge length. This will help you keep a priority queue of the edges more efficiently. Keep in mind the most important step in the algorithm is to find the minimum-weight edge connecting the tree built thus far with a node not yet added to the tree. Try to use counting sort as an inspiration.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Modified version of Prim's algorithm with O(kn + m) time complexity\r\n                \r\nCould you please help me with this problem?\n\nGiven an undirected graph G, connected, with weighted edges, such that the weights are integers in [1,k] . Write a modified version of Prim's algorithm that returns the minimum spanning tree in O(kn+m) time.\n\nNote:\n\n\nn represents the number of vertices\nm represents the number of edges\n\n    ", "Answer": "\r\nYou should be using the limited range of the edge length. This will help you keep a priority queue of the edges more efficiently. Keep in mind the most important step in the algorithm is to find the minimum-weight edge connecting the tree built thus far with a node not yet added to the tree. Try to use counting sort as an inspiration.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to find a path from one vertex to another in a tree using breadth first search?\r\n                \r\nI am trying to implement a BFS that returns a path from ```\na```\n to ```\nb```\n in form of a list of vertices. I am implementing this BFS on a tree so I know it will be the shortest path if I can find one. However, so far my research has only led me to find BSF algorithms that search and find nodes, rather than return a path. \n\nThe input that I am dealing with is an adjacency matrix of the Minimum Spanning Tree. I must take this and find path from one point to the other.\n    ", "Answer": "\r\nIf you really want to use BFS to solve this, to trace the path from source to destination you need to store the parent of each node visited. Here's a sample BFS without optimizations.\n\n```\nimport java.util.*;\n\npublic class bfs {\n\n    static class Node {\n        Node parent;\n        int x;\n\n        Node (int x) {\n            this (x, null);\n        }\n\n        Node (int x, Node parent) {\n            this.parent = parent;\n            this.x = x;\n        }\n\n        void trace () {\n            if (parent == null) {\n                System.out.print (x);\n            } else {\n                parent.trace ();\n                System.out.print (\"->\" + x);\n            }\n        }\n    }\n\n    static void bfs (int start, int goal, int[][] adj) {\n        List<Node> list = new ArrayList<> ();\n\n        list.add (new Node (start));\n\n        while (!list.isEmpty ()) {\n            Node cur = list.remove (0);\n\n            if (cur.x == goal) {\n                cur.trace ();\n                break;\n            } else {\n                for (int i = 0; i < adj[cur.x].length; i++) {\n                    if (adj[cur.x][i] == 1) {\n                        list.add (new Node (i, cur));\n                    }\n                }\n            }\n        }\n    }\n\n    public static void main (String[] args) {\n        int[][] adjacency_matrix = {\n            {0, 1, 1, 0, 0},\n            {1, 0, 0, 1, 0},\n            {1, 0, 0, 0, 0},\n            {0, 1, 0, 0, 1},\n            {0, 0, 0, 1, 0}\n        };\n        int start = 0;\n        int goal = 4;\n\n        bfs (start, goal, adjacency_matrix);\n    }\n\n}\n```\n\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "How to keep graph shape when read it by networkx\r\n                \r\nI have a file shows different points' coordinates(first 10 rows):\n```\n1 10.381090522139 55.39134945301\n2 10.37928179195319 55.38858713256631\n3 10.387152479898077 55.3923338690609\n4 10.380048819655258 55.393938880906745\n5 10.380679138517507 55.39459444742785\n6 10.382474625286 55.392132993022\n7 10.383736185130601 55.39454404088371\n8 10.387334283235987 55.39433237195271\n9 10.388468103023115 55.39536574771765\n10 10.390814951258335 55.396308397998475\n```\n\n\nNow I want to calculate the MST(minimum spanning tree) of them so firstly I change my coordinates to weight graph(distance->weight):\n```\nn = 10\ndata = []\nfor i in range(0, n):\n    \n    for j in range(i + 1, n):\n        temp = []\n        temp.append(i)\n        temp.append(j)\n        x = np.array(rawdata[i, 1:3])\n        y = np.array(rawdata[j, 1:3])\n        temp.append(np.linalg.norm(x - y))\n        data.append(temp)\n```\n\nThen, using networkx to load weight data:\n```\nG = nx.read_weighted_edgelist(\"data.txt\")\nT = nx.minimum_spanning_tree(G)\nnx.draw(T)\nplt.show()\n```\n\nbut I cannot see the orignal shape from result:\n\nhow to solve this problem?\n    ", "Answer": "\r\nI'm just answering the question about the position of the nodes.  I can't tell from what you've done whether the minimum spanning tree is what you're after or not.\nWhen you plot a network, it will assign positions based on an algorithm that is in part stochastic.  If you want the nodes to go at particular positions, you will have to include that information in the call in an optional argument.  So define a dictionary (it's usually called ```\npos```\n) such that ```\npos[node]```\n is a tuple ```\n(x,y)```\n where ```\nx```\n is the x-coordinate of ```\nnode```\n and ```\ny```\n is the y-coordinate of ```\nnode```\n.\nThen the call is ```\nnx.draw(T, pos=pos)```\n.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Algorithm finding an MST using DFS\r\n                \r\nI have the following algorithm: For a given (finite undirected simple) graph G=(V,E) with positive weight function on the edges:\n\n\nRun DFS (depth-first-search) till you find an edge going backwards or DFS stopped. If stopped, return G.\nOn the circle that is constructed by the backwards going edge find the heaviest edge and remove it from G.\nReturn to 1.\n\n\nNow I need to understand what this algorithm is doing. I have already proven that the algorithm gives me a spanning tree of G and I believe it's a minimum spanning tree but I fail to prove that. Please help me to prove that.\n    ", "Answer": "\r\nProve that, when e is the heaviest edge in a cycle of G, the cost of the MST of G - e is no greater than the cost of the MST of G. (Let T be an MST for G and use T and the assumption about e to construct a spanning tree T' of G - e with cost(T') ≤ cost(T).) Conclude by induction on |E| that the algorithm produces an MST.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Data Parallel Primitives Library for OpenCL\r\n                \r\nI am trying to implement a Minimum Spanning Forest Algorithm in OpenCL. Though I know how to implement Kruskal's algorithm, it is sequential in nature, so I think Boruvka's algorithm or the Data Parallel Kruskal's algorithm which is specially made for parallel programming should be implemented in OpenCL.\n   But in this algorithm(as per mentioned in the paper : \"Fast and Memory-Efficient Minimum Spanning Tree on the GPU\") we need Graph Primitives like \"sort\", \"split graph\", \"connect components\", \"find mins\", \"contract graphs\" for the implementation. Does OpenCL have its Data Parallel Primitives library as the CUDA does....\" CUDAPP\"..? Or is there any source in OpenCL where I can get these functions...?\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "When to use Kruskal's algorithm vs. Prim's [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n\n  Possible Duplicate:\n  Kruskal vs Prim  \n\n\n\n\nWhen would you use Kruskal's algorithm over Prim's algorithm to find the minimum spanning tree? What kind of input graphs and nodes are beter for each kind? In what cases is it more efficient to use one of them when it comes to space and time?\n\nAre their particular inputs that make one much better than the other?\n    ", "Answer": "\r\nOne important difference: if your graph is disconnected, Prim's will do you no good (requires the graph to be connected). Kruskal's on the other hand will work on a connected graph or a disconnected graph; in the latter case it finds the minimum spanning forest, the MST of each connected component.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Efficient way of linking grid tiles while creating distinct edges in Java\r\n                \r\nThere is a grid.\n```\nstatic Double [][] myTiles = new Double[row][column];\n```\n\nThe goal is to connect each tile with an adjacent tile. Compare a value between the pair, construct a link between tiles to create the minimum spanning tree for a given grid.\nBelow is my initial approach to this issue:\nNine ( 9 ) groups of tiles are identified.\n\nThese groups have the same logic and the same availability of adjacent squares.\nFor each cell in my grid I decided to check a cell above, below, to the left and to the right.\nCertain cells cannot perform all checks when located on an edge of the grid. Below is the movement representation for each type of a tile.\n\nMy current solution is a nested for-loop with the below if-else statements:\n```\n            if ( row == 0 && column == 0)   {\n                mySortingQueue.offer(createEdgeSouth(myEdge, myTiles, row, column));\n                mySortingQueue.offer(createEdgeEast(myEdge, myTiles, row, column));     }\n            \n            else if ( row == 0 && ( column > 0 && column < myTiles.length ) )   {\n                mySortingQueue.offer(createEdgeSouth(myEdge, myTiles, row, column));\n                mySortingQueue.offer(createEdgeEast(myEdge, myTiles, row, column));\n                mySortingQueue.offer(createEdgeWest(myEdge, myTiles, row, column));     }\n            \n            else if ( row == 0 && column == myTiles.length )    {\n                mySortingQueue.offer(createEdgeSouth(myEdge, myTiles, row, column));\n                mySortingQueue.offer(createEdgeWest(myEdge, myTiles, row, column));     }\n            \n            else if ( ( row > 0 && row < myTilese[row].length ) && column == 0 )    {\n                mySortingQueue.offer(createEdgeSouth(myEdge, myTiles, row, column));\n                mySortingQueue.offer(createEdgeEast(myEdge, myTiles, row, column));\n                mySortingQueue.offer(createEdgeNorth(myEdge, myTiles, row, column));    }\n            \n            else if ( row == myTilese[row].length && column == 0 )  {\n                mySortingQueue.offer(createEdgeEast(myEdge, myTiles, row, column));\n                mySortingQueue.offer(createEdgeNorth(myEdge, myTiles, row, column));    }\n            \n            else if ( row == myTilese[row].length && ( column > 0 && column < myTiles.length ) )    {\n                mySortingQueue.offer(createEdgeNorth(myEdge, myTiles, row, column));\n                mySortingQueue.offer(createEdgeEast(myEdge, myTiles, row, column));\n                mySortingQueue.offer(createEdgeWest(myEdge, myTiles, row, column));     }\n            \n            else if ( row == myTilese[row].length &&  column == myTiles.length )    {\n                mySortingQueue.offer(createEdgeNorth(myEdge, myTiles, row, column));\n                mySortingQueue.offer(createEdgeWest(myEdge, myTiles, row, column));     }\n            \n            else if ( ( row > 0 &&  row < myTilese[row].length ) && column == myTiles.length )  {\n                mySortingQueue.offer(createEdgeNorth(myEdge, myTiles, row, column));\n                mySortingQueue.offer(createEdgeWest(myEdge, myTiles, row, column));\n                mySortingQueue.offer(createEdgeSouth(myEdge, myTiles, row, column));}\n            \n            else    {\n                mySortingQueue.offer(createEdgeNorth(myEdge, myTiles, row, column));\n                mySortingQueue.offer(createEdgeEast(myEdge, myTiles, row, column));\n                mySortingQueue.offer(createEdgeWest(myEdge, myTiles, row, column));\n                mySortingQueue.offer(createEdgeSouth(myEdge, myTiles, row, column));}\n```\n\nThe above logic creates at least two links and at most four.\nThat's a lot of diplicates to sort when it comes to building a minimum spanning tree.\nIs there an eloquent way of representing the above if-else block?\n    ", "Answer": "\r\nThis is much simpler:\n```\nif(row > 0) {\n    // north\n}\nif(row < height) {\n    // south\n}\nif(column > 0) {\n    // west\n}\nif(column < width) {\n    // east\n}\n```\n\nObviously this assumes you have at least a 2x2 grid.\nI think you were over-thinking your implementation, however the code you posted could be easily refactored to make a good test-case.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Minimum Spanninjg Tree with vertex weight and edge weight\r\n                \r\nI am having some troubles solving a problem about Minimum Spanning Tree. So each node in a graph is a city, and is possible to have weight edges connecting two nodes, which is the cost of building a road between two cities. The problem is basically telling the minimum cost of building the roads and have all cities connected some way. I can easily solve this by using Prim or kruskal algorithm to solve this sub-problem of my biggest problem.\n\nThe tricky part comes now: Each city (node) can have an airport and each airport has a one time cost (if you decide to build it). You can travel between two cities using an airport if both cities have airports. Now I have to calculate the minimium cost of building roads AND airports in order to have all cities connected, but I am having difficulty representing the connections with the airports with the rest of the network. Can somebody help me here? Maybe I am completely wrong about using MST?\n\nThe only solution I came up is: For each city that has an aiport, I will connect that city with another cities that have airports. Also If the cost of building two airports is lower then building a road I take it in consideration. I run kruskal in order to get the cheapest edge, but If kruskal chooses an \"airport\" edge, I will add it to the spanning tree and then 0 the cost of both airports (if they havent been built in the past). I believe, that by doing this dynamic weight changes while runing kruskal, I am destroyng the idea of getting the minimum cost.\n    ", "Answer": "\r\nThere are two possibilities:\n\n1) The optimal solution does not use airports. In this case you can ignore airports and construct the minimum spanning tree as usual.\n\n2) The optimal solution uses airports. In this case add a dummy node to the graph called \"sky\". The cost of building a road from any city to \"sky\" is the cost of building an airport. The cost of the optimal solution using airports is the cost of the minimum spanning tree in this ammended graph.\n\nSo try both options and pick the minimum cost.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Boost C++ prim algorithm wrong answer\r\n                \r\nThis program gives me the weight of the minimum spanning tree and the longest distance from starting node..But after inputing the number of testcases and the vertice number and edge number,it take two edges and their weights and it gives some junk value.why?\n\n```\n#include<iostream>\n#include<boost/config.hpp>\n#include<boost/graph/adjacency_list.hpp>\n#include<utility>\n#include<boost/graph/prim_minimum_spanning_tree.hpp>\n#include<vector>\n\n\nusing namespace std;\nusing namespace boost;\n\nint main()\n{\n  typedef adjacency_list < vecS, vecS, undirectedS,property < vertex_distance_t, int>, property < edge_weight_t, int > > Graph;\n  int no_test=0,v,e,m,a,b,c,w,d;\n  cin>>no_test;\n  int array_weights[100],array_distances[100],i,j;\n  m=0;\n  while(m!=no_test)\n  {\n    w=0;\n    d=0;\n    cin>>v>>e;//take input\n\n    Graph g(v);//create graph g\n\n    property_map < Graph,edge_weight_t > ::type weightMap;\n    bool b;\n    typedef graph_traits < Graph> ::edge_descriptor edge11;\n\n    for(i=0;i<e;i++)  //add edges into g from i/p\n    {\n      edge11 ed;\n      cin>>a>>b>>c;\n      tie(ed, b)=add_edge(a, b, g);\n      weightMap[ed]=c;\n    }\n    typedef graph_traits < Graph> ::vertex_descriptor vertex11;\n    property_map<Graph,vertex_distance_t>::type distanceMap=get(vertex_distance,g);\n    property_map<Graph,vertex_index_t>::type indexMap=get(vertex_index,g);\n    vector < vertex11 > pred(v);\n    prim_minimum_spanning_tree(g,*vertices(g).first,&pred[0],distanceMap,weightMap,indexMap,default_dijkstra_visitor());\n    typedef graph_traits<Graph>::edge_iterator edge1;\n    typedef graph_traits<Graph>::vertex_iterator vertex1;\n    pair <edge1, edge1> edg;\n\n    for(edg=edges(g);edg.first!=edg.second;++edg.first)\n    {\n      w=w+weightMap[*edg.first];\n    }\n\n\n    pair<vertex1,vertex1> vtx;\n    for(vtx=vertices(g);vtx.first!=vtx.second;++vtx.first)\n    {\n      if(distanceMap[*vtx.first]>d)\n      d=distanceMap[*vtx.first];\n    }\n\n    array_weights[m]=w;\n    array_distances[m]=d;\n\n    m++;\n   }\n\n  for(j=0;j<no_test;j++)\n  {\n    cout<<array_weights[j]<<\" \"<<array_distances[j]<<endl;\n  }\nreturn 0;\n}\n```\n\n\nthe program compiles perfectly.it gives problems for more than two edges.I just dont know why.Thank you\n    ", "Answer": "\r\nThe problem with your program is that it declares two variables with name ```\nb```\n. At the beginning the program declares a variable with name ```\nb```\n of type ```\nint```\n. Later it declares a variable of name ```\nb```\n of type ```\nbool```\n. The second declaration shadows the first declaration.\nWhen the program does ```\ncin>>a>>b>>c;```\n it will use the ```\nb```\n of type ```\nbool```\n. When you enter a value other than ```\n0```\n or ```\n1```\n for ```\nb```\n, this will set the failbit for ```\ncin```\n, because the value cannot be parsed as a ```\nbool```\n (reference). After this, ```\ncin```\n will not take input until ```\ncin.clear()```\n is called, which resets the failbit. Since your program does not call ```\ncin.clear()```\n, it will no longer take input and run past all the read operations.\nTo fix this, change the declaration of ```\nbool b;```\n to ```\nbool inserted;```\n and change the assignment ```\ntie(ed, b) = add_edge(a, b, g);```\n to ```\ntie(ed, inserted) = add_edge(a, b, g);```\n.\nAdditionally, you could add further error checking each time the program asks for input. This can be done by checking the result of ```\ncin.fail()```\n after each input. Without such checks, your problem would also occur in case the user enters an invalid value that cannot be parsed as an integer (e.g. some string such as ```\nabc```\n).\nAs a side note, I would recommend compiling with increased compiler warnings. This can help you detecting problems such as the one above. For example, compiling your program with ```\ng++```\n or ```\nclang++```\n using the flag ```\n-Wall```\n to enable warnings will result in a warning about the first ```\nb```\n being unused.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "C++ how to implement Kruskal's theorem for double weight (instead of integers)\r\n                \r\nI found a template for Minimum Spanning Tree using Kruskal's algorithm here\n\nThey're using integers weight, is it possible if I want to implement the code using double weight instead ?\n\nI made changes here and there and kept giving me errors.\n\nHere's what I changed:\n\n```\nstruct Edge\n{\n    int src, dest;\n    double weight;\n};\n```\n\n\nand\n\n```\n   double myComp(const void* a, const void* b)\n    {\n        struct Edge* a1 = (struct Edge*)a;\n        struct Edge* b1 = (struct Edge*)b;\n        return a1->weight > b1->weight;\n    }\n```\n\n\nI don't know why, but these changes made the quicksort in ```\nvoid KruskalMST(struct Graph* graph)```\n fail to work in the next couple of lines\n\nHere's the original code:\n\n```\n// Kruskal's algortihm to find Minimum Spanning Tree of a given connected,\n// undirected and weighted graph\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// a structure to represent a weighted edge in graph\nstruct Edge\n{\n    int src, dest, weight;\n};\n\n// a structure to represent a connected, undirected and weighted graph\nstruct Graph\n{\n    // V-> Number of vertices, E-> Number of edges\n    int V, E;\n\n    // graph is represented as an array of edges. Since the graph is\n    // undirected, the edge from src to dest is also edge from dest\n    // to src. Both are counted as 1 edge here.\n    struct Edge* edge;\n};\n\n// Creates a graph with V vertices and E edges\nstruct Graph* createGraph(int V, int E)\n{\n    struct Graph* graph = (struct Graph*) malloc( sizeof(struct Graph) );\n    graph->V = V;\n    graph->E = E;\n\n    graph->edge = (struct Edge*) malloc( graph->E * sizeof( struct Edge ) );\n\n    return graph;\n}\n\n// A structure to represent a subset for union-find\nstruct subset\n{\n    int parent;\n    int rank;\n};\n\n// A utility function to find set of an element i\n// (uses path compression technique)\nint find(struct subset subsets[], int i)\n{\n    // find root and make root as parent of i (path compression)\n    if (subsets[i].parent != i)\n        subsets[i].parent = find(subsets, subsets[i].parent);\n\n    return subsets[i].parent;\n}\n\n// A function that does union of two sets of x and y\n// (uses union by rank)\nvoid Union(struct subset subsets[], int x, int y)\n{\n    int xroot = find(subsets, x);\n    int yroot = find(subsets, y);\n\n    // Attach smaller rank tree under root of high rank tree\n    // (Union by Rank)\n    if (subsets[xroot].rank < subsets[yroot].rank)\n        subsets[xroot].parent = yroot;\n    else if (subsets[xroot].rank > subsets[yroot].rank)\n        subsets[yroot].parent = xroot;\n\n    // If ranks are same, then make one as root and increment\n    // its rank by one\n    else\n    {\n        subsets[yroot].parent = xroot;\n        subsets[xroot].rank++;\n    }\n}\n\n// Compare two edges according to their weights.\n// Used in qsort() for sorting an array of edges\nint myComp(const void* a, const void* b)\n{\n    struct Edge* a1 = (struct Edge*)a;\n    struct Edge* b1 = (struct Edge*)b;\n    return a1->weight > b1->weight;\n}\n\n// The main function to construct MST using Kruskal's algorithm\nvoid KruskalMST(struct Graph* graph)\n{\n    int V = graph->V;\n    struct Edge result[V];  // Tnis will store the resultant MST\n    int e = 0;  // An index variable, used for result[]\n    int i = 0;  // An index variable, used for sorted edges\n\n    // Step 1:  Sort all the edges in non-decreasing order of their weight\n    // If we are not allowed to change the given graph, we can create a copy of\n    // array of edges\n    qsort(graph->edge, graph->E, sizeof(graph->edge[0]), myComp);\n\n    // Allocate memory for creating V ssubsets\n    struct subset *subsets =\n        (struct subset*) malloc( V * sizeof(struct subset) );\n\n    // Create V subsets with single elements\n    for (int v = 0; v < V; ++v)\n    {\n        subsets[v].parent = v;\n        subsets[v].rank = 0;\n    }\n\n    // Number of edges to be taken is equal to V-1\n    while (e < V - 1)\n    {\n        // Step 2: Pick the smallest edge. And increment the index\n        // for next iteration\n        struct Edge next_edge = graph->edge[i++];\n\n        int x = find(subsets, next_edge.src);\n        int y = find(subsets, next_edge.dest);\n\n        // If including this edge does't cause cycle, include it\n        // in result and increment the index of result for next edge\n        if (x != y)\n        {\n            result[e++] = next_edge;\n            Union(subsets, x, y);\n        }\n        // Else discard the next_edge\n    }\n\n    // print the contents of result[] to display the built MST\n    printf(\"Following are the edges in the constructed MST\\n\");\n    for (i = 0; i < e; ++i)\n        printf(\"%d -- %d == %d\\n\", result[i].src, result[i].dest,\n                                                   result[i].weight);\n    return;\n}\n\n// Driver program to test above functions\nint main()\n{\n    /* Let us create following weighted graph\n             10\n        0--------1\n        |  \\     |\n       6|   5\\   |15\n        |      \\ |\n        2--------3\n            4       */\n    int V = 4;  // Number of vertices in graph\n    int E = 5;  // Number of edges in graph\n    struct Graph* graph = createGraph(V, E);\n\n\n    // add edge 0-1\n    graph->edge[0].src = 0;\n    graph->edge[0].dest = 1;\n    graph->edge[0].weight = 10;\n\n    // add edge 0-2\n    graph->edge[1].src = 0;\n    graph->edge[1].dest = 2;\n    graph->edge[1].weight = 6;\n\n    // add edge 0-3\n    graph->edge[2].src = 0;\n    graph->edge[2].dest = 3;\n    graph->edge[2].weight = 5;\n\n    // add edge 1-3\n    graph->edge[3].src = 1;\n    graph->edge[3].dest = 3;\n    graph->edge[3].weight = 15;\n\n    // add edge 2-3\n    graph->edge[4].src = 2;\n    graph->edge[4].dest = 3;\n    graph->edge[4].weight = 4;\n\n    KruskalMST(graph);\n\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nThe issue is not related to ```\ndouble```\n vs ```\nint```\n at all, it may have worked with ```\nint```\n due to a stroke of luck but it is equally incorrect.\n\n```\nint myComp(const void* a, const void* b)\n{\n    struct Edge* a1 = (struct Edge*)a;\n    struct Edge* b1 = (struct Edge*)b;\n    return a1->weight > b1->weight;  <----THIS\n}\n```\n\n\nThis returns ```\n1```\n if ```\na1.weight```\n is greater than ```\nb1.weight```\n and ```\n0```\n otherwise.\n\nWhat you must return is:\n\n\n```\n0```\n: if both values are equal\n```\n<0```\n: if ```\na1.weight```\n is less than ```\nb1.weight```\n\n```\n>0```\n: if ```\na1.weight```\n is more than ```\nb1.weight```\n\n\n\nObviously your function does not behave as ```\nqsort```\n expects. Change it code to match these values. You may check the link that you provided me and look at the example.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Code for implementation of Kruskal's algo produces wrong o/p\r\n                \r\nBelow is the program to find cost of minimum spanning tree, the graph is represented as ```\nArrayList<ArrayList<Integer>>```\n. So first I stored all the edges in a ```\nminHeap```\n and polled them by checking if they form a cycle or not. If not, I included the ```\nweight```\n of that edge in the result. My code gives wrong o/p for some testcases.\nfor eg.-\n```\nInput:\n\n42(vertices) 458(edges)\n\n1(u) 2(v) 214(weight)\n1 8 486 \n1 9 584 \n1 12 178 \n1 14 91 \n1 15 146 \n1 17 125 \n1 20 570 \n1 21 953 \n1 24 589 \n1 30 276 \n1 31 634 \n1 33 135 \n1 34 811 \n1 36 309...\n```\n\n```\nIts Correct output is:\n2361\n```\n\n```\nAnd Your Code's output is:\n2164\n```\n\nHere is the code I tried:\n```\nclass MST {\n    static int spanningTree(int V, int E, ArrayList<ArrayList<Integer>> graph) {\n        // Add your code here\n        PriorityQueue<edge>heap=new PriorityQueue<>((e1,e2)->e1.wt-e2.wt);\n        \n        for(int i=0;i<V;i++){\n            for(int j=0;j<V;j++){\n                if(graph.get(i).get(j)>0){\n                    heap.offer(new edge(i,j,graph.get(i).get(j)));\n                    graph.get(j).set(i,0);\n                }\n            }\n        }\n        \n        int [] parent=new int[V];\n        for(int i=0;i<V;i++)\n            parent[i]=i;\n            \n        int res=0;\n        int edges=0;\n        while(edges<V-1){\n            edge e=heap.poll();\n            if(!formCycle(parent,e.sc,e.dt)){\n                res+=e.wt;\n                edges++;\n            }\n        }\n        \n        return res;\n    }\n    \n    static boolean formCycle(int [] parent,int sc,int dt){\n        if(parent[sc]==parent[dt])\n            return true;\n            \n        int p1=findParent(parent,sc);\n        int p2=findParent(parent,dt);\n        \n        parent[p2]=p1;\n        \n        return false;\n    }\n    \n    static int findParent(int [] parent,int i){\n        if(parent[i]==i)\n            return i;\n            \n        return parent[i]=findParent(parent,parent[i]);\n    }\n}\n\nclass edge{\n    int sc,dt,wt;\n    edge(int sc,int dt,int wt){\n        this.sc=sc;\n        this.dt=dt;\n        this.wt=wt;\n    }\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Boruvka algorithm parallel implementation CUDA\r\n                \r\nI'm trying to implement Boruvka's algorithm for Minimum Spanning Trees in CUDA. I understand the basic logic, but I'm having trouble implementing it. The algorithm is:\n\n```\nInitialize Graph G(V,E)\nInitialize MST\nwhile size(G) > 1:\n  for all nodes in graph:\n    min equals minimum outgoing edge\n    ?\n```\n\n\nAfter I compute the minimum outgoing edges for each node, I don't understand how to reduce the disjoint subgraphs into new nodes. Once I do that, how do I compute the minimum edges between these disjoint subgraphs? \n    ", "Answer": "\r\nI think you don't have to reduce the disjoint subgraphs into new nodes, you just have to recompute for each node its new component to be able to distinguish(during the computation of minimum outgoing edges) if the node belongs to different component. This data structure will help you to do that in effective way.\n\nFor the computation of the minimum edges between disjoint subgraphs the reduction is usually used. I think you will have to launch another kernel for this.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "dominating set of a tournament graph\r\n                \r\nI am writing an algorithm to find the dominating set of a tournament graph. Is the minimum spanning tree of a directed graph equivalent to the dominating set of the graph? In other words, if I find the smallest MST for the tournament graph (by iterating through all of the vertices), can I then say this is equivalent to the dominating set of the graph?\n    ", "Answer": "\r\nThis Wikipedia article states that the problems of finding a dominating set and finding a spanning tree are equivalent. Given a spanning tree, the non-leaf nodes form a dominating set, and given a connected dominating set, you can easily obtain of the original graph joining one spanning tree of it with the vertexes that do not belong to it. However, finding a minimum spanning tree and finding a minimal dominating set are different problems. I guess that they are equivalent again, but I'm not sure.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
{"Question": "Find a minimum weight spanning tree in the undirected graph where there are negative edges\r\n                \r\n\n\nSo I need to solve this graph, I have a general idea on how to solve it but if I am doing this wrong please correct me.\n\nSo to find the MST I need to perform Kruskals algorithm on the graph\n\nhere is my psuedocode for this Kruskals algorithm\n\nKruskal(V,E)\nA = null;\nfor each v contains in V\nmake disjoint set(v)\nSort E by weight increasingly\nfor each(v1, v2) contains in E \nif \n\n  Kruskal(V,E)\n\nA = null;\nfor each v contains in V\n     make disjoint set(v)\nSort E by weight increasingly\nfor each(v1, v2) contains in E \n     if Find(v1) is not equal to Find(v2)\n          A = A Union {(v1,v2)}\n          Union(v1,v2)\nReturn A\n\nSo first thing I do is find the nodes with the shortest distances right?\n\n1)\n\nI assume S to H has the shortest distance since the d(h,s) = -3 \n\nso A = {(h,s)}\n\nso now we follow this pattern\n\n2) A = {(h,s),(s,f)}\n\n3) A = {(h,s),(s,f)(s,n)}\n\n4) A = {(h,s)(s,f)(s,n)(f,k)}\n\n5) A = {(h,s)(s,f)(s,n)(f,k)(s,m)} (we skip H to N because a path is already made from h to n which is through s ) \n\n6) A = {(h,s)(s,f)(s,n)(f,k)(s,m)(d,b)}\n\n7) A = {(h,s)(s,f)(s,n)(f,k)(s,m)(d,b)(b,m)}\n\nso now since there is a path that connects to all edges we are good right?\n\nbut the thing i dont understand is there there are distance[u,v] which is shorter than the path[u,v] through multiple vertices. For example d[d,m] is shorter then p[d,m] which goes through B first. Am I doing something wrong?\n    ", "Answer": "\r\nYou're not doing anything wrong. There's no guarantee that a MST preserves shortest distances between nodes. Eg: the three node complete graph ABC with edge weights 3, 2, 2 (with apologies for my ascii art):\n\n```\nA --- 2 --- B\n|           |\n2          /\n|         /\nC----3---/ \n```\n\n\nThe minimal spanning tree is C-A-B but the distance between B and C in the original graph is 3, and in the MST 4.\n    ", "Knowledge_point": "Minimum Spanning Tree", "Tag": "算法分析"}
