{"Question": "Finding a Strongly Connected Components in unDirected Graphs\r\n                \r\nI want to find a strongly connected components in undirected graph i.e If i start from a Node ```\nA```\n then i will get back to node ```\nA```\n  and each edge is visited exactly by once.\n\nFor Directed Graph can use  Tarjan’s algorithm for finding the strongly connected components , but how to do for undirected graph.\n    ", "Answer": "\r\nI think you miss understood the meaning of strongly connected component. \n\nStrongly connected components\n\nA directed graph is strongly connected if there is a path between all pairs of vertices. A strongly connected component (SCC) of a directed graph is a maximal strongly connectedsubgraph. \n\nBut,  from your definition to what your looking for, I'd say you want to find cycle in unDirected graph:\n\n\nenters each node once\nyou can start from node A and finish in node A. \n\n\nIf it's only what you look for I'd say use Dfs algorithm to find cycle in unDirected graph. \n\nHope I answered your question \n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Strongly connected components in graph - networkx library\r\n                \r\nGraph randomly generated with ```\nnetworkx```\n. I want to retrieve from this graph the strongly connected components.\nWhy do I get only one large scc using the built-in ```\nnetworkx```\n function?\n```\nn = random.randint(10, 500)\np = random.randint(1, 9) / 10\ngraph = nx.gnp_random_graph(n, p, seed=None, directed=True)\nprint(\"Nodes {} Edge density {}\".format(n, p))\ncomp = nx.strongly_connected_components(graph)\nsccs = list(nx.strongly_connected_components(graph))\nsccs.reverse()\nprint(sccs)\n\nNodes 127 Edge density 0.9\n[{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126}]\n```\n\nEven if a force density of edge to 0.1, I get the same SCC.\n```\ngraph = nx.gnp_random_graph(n, 0.1, seed=None, directed=True)\nprint(\"Nodes {} Edge density {}\".format(n, p))\ncomp = nx.strongly_connected_components(graph)\nsccs = list(nx.strongly_connected_components(graph))\nsccs.reverse()\nprint(sccs)\n\nNodes 484 Edge density 0.1\n<generator object strongly_connected_component_subgraphs at 0x000001B8019A9468>\n[{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483}]\n```\n\n    ", "Answer": "\r\nDyZ already summarized the issue.\n\nYou callwd ```\nnetworkx```\n to make you a random graph with 127 nodes, with about 90% of the possible edges drawn in.  An average node of this graph will have about 114 edges.  Finding a single node that is disconnected enough to be separable is a chance that is astronomically small; finding a cluster of such nodes is even harder.\n\nYes, you can construct graphs with (relatively) thin connections, but at this proportion, any ```\nscc```\n algorithm worth its vectorizations will keep the entire graph in one large component.  Perhaps some spectral clustering algorithm could identify density and gaps that would get you the sort of division you seem to seek.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Finding Strongly Connected Components in a graph through DFS\r\n                \r\nI was reading the graph algorithms about BFS and DFS. When I was analyzing the algorithm for finding strongly connected component in a Graph through DFS, a doubt came to my mind. For finding the strongly connected component, what book(Coremen)does, first it ran the DFS on the Graph in order to  get the finish time of the vertices then again ran the DFS on the transpose of the graph in decreasing order of the finish time which we got from the first DFS. But I am not able to grasp why the second DFS must be run according to finish time. \nWhat I mean is that even if we directly run the DFS (ignoring the finish time) on the transpose of the graph, could it also have given us the connected components because by doing the transpose we have already blocked the path to other components.     \n    ", "Answer": "\r\nEdit- Here's some good in-depth videos from stanford university on the topic:\n\nhttp://openclassroom.stanford.edu/MainFolder/CoursePage.php?course=IntroToAlgorithms (See 6. CONNECTIVITY IN DIRECTED GRAPHS)\n\nMy explanation:\n\nIt's possible that you would incorrectly identify the entire graph as a single strongly connected component(SCC) if you don't run the second dfs according to decreasing finish times of the first dfs.\n\n\n\nNotice that in my example, node ```\nd```\n would always have the lowest finish time from the first dfs. One of nodes ```\na```\n, ```\nb```\n, or ```\nc```\n will have the highest finish times. Lets assume ```\na```\n has the highest finish time, and so if we ran the second dfs according to decreasing finish times, ```\na```\n would be first.\n\nNow, if you ran the second dfs starting with node ```\nd```\n in the transpose of ```\nG```\n, you would produce a depth first forest containing the entire graph, and so conclude that the entire graph is a SCC, which is clearly false. However, if you start the dfs with ```\na```\n, then you would not only discover ```\na```\n, ```\nb```\n, and ```\nc```\n, as being an SCC, but the important part is that they would be marked as visited by being colored grey or black. Then when you continue the dfs on ```\nd```\n, you wouldn't traverse out of its SCC because you would realize that its adjacent nodes have been visited.\n\nIf you look at cormens code for DFS, \n\n```\nDFS(G)\n1 for each vertex u in G.V\n2     u.color = WHITE\n3     u.π = NIL\n4 time = 0\n5 for each vertex u in G.V\n6     if u.color == WHITE\n7         DFS-VISIT(G, u)\n\nDFS-VISIT(G, u)\n1 time = time + 1 // white vertex u has just been discovered\n2 u.d = time\n3 u.color = GRAY\n4 for each v in G.adj[u]\n5     if v.color == WHITE\n6         v.π = u\n7         DFS-VISIT(G, u)\n8 u.color = BLACK // blacken u; it is finished\n9 time = time + 1\n10 u.f = time\n```\n\n\nif you didn't use decreasing finish time, then line 6 of DFS would only be true once, because DFS-VISIT would visit the entire graph recursively. This produces a single tree in the depth first forest, and each tree is an SCC. The reasoning for a single tree is because a tree is identified by its root node having a nil predecessor. \n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Finding strongly connected component in a directed Graph?\r\n                \r\nI'm following Skiena's algorithm design manual. Implementation that I'm working on is for finding Strongly connected components. However There is one statement in the book which I do not understand that is \"A new strongly connected component is found whenever the lowest reachable vertex from v is v\". For example take a directed graph as shown below \n\n\n\nHere above statement is true for vertex \"V3\" and will give us strongly connected component but this statement is also true for V2 which do not give us any strongly connected component.\n\nMy question is how does above statement always holds true ?\n    ", "Answer": "\r\nI can't tie this up with my (first) version of Skienna's algorithm design manual, but if this is the algorithm I think it is (http://en.wikipedia.org/wiki/Kosaraju%27s_algorithm), this is the second part of a two-part algorithm, and the effect of the first part is that in your diagram there will be a depth first search from V3, removing that component, before one from V2, and only then will there be a depth first search from V1.\n\nThe first part runs successive depth-first searches, and numbers the nodes in order of the last time they are visited by the depth first search. The second part, which you are describing, initiates depth first searches in decreasing order of the number assigned, and the edges between nodes are reversed.\n\nIf A can get to B, but B cannot get to A, then if the first part visits A before B it will visit B in that depth first search and number A greater than B, because it exits A after exiting B. If it visits B before A it will number A greater than B as well, because it will not get to A from B and so will visit A in a later depth first search.\n\nSo if A can get to B but B cannot get to A, then in the second pass (with edges reversed) B can get to A but A cannot get to B. It will start from A and output its strong component and then only later start from B and output its strong component.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Finding the strongly connected components in a Di-Graph in one DFS\r\n                \r\nBy now, I have used the following algorithm for finding the strongly connected components of a graph.\n\n\ncall DFS(G) to compute the finishing time f[v] for every vertex v, sort the vertices of G in decreasing order of their finishing time;\ncompute the transpose GT of G;\nPerform another DFS on G, this time in the main for-loop we go through the vertices of G\nin the decreasing order of f[v];\noutput the vertices of each tree in the DFS forest (formed by the second DFS) as a separate\nstrongly connected component.\n\n\n.\n\nBut I was wondering if it is possible to find all the strongly connected components in only one DFS. \n\nAny help in this regard would be highly appreciated.\n    ", "Answer": "\r\nCheck out, Algorithm Design Manual by Steven Skiena. It calculates SCC in one DFS. It's based on the concept of oldest reachable vertex. \n\nInitialize each vertex's reachable vertex and SCComponent# to itself in the beginning.\n\n```\nlow[i] = i;\nscc[i] = -1;\n```\n\n\nDo a DFS on the digraph, you are interested only in back edges and cross edges because these two edges will tell you if you've encountered a back edge and entering 1 component from another. \n\n```\n  int edge_classification(int x, int y)\n  {\n    if (parent[y] == x) return(TREE);\n    if (discovered[y] && !processed[y]) return(BACK);\n    if (processed[y] && (entry_time[y]>entry_time[x])) return(FORWARD);\n    if (processed[y] && (entry_time[y]<entry_time[x])) return(CROSS);\n     printf(\"Warning: unclassified edge (%d,%d)\\n\",x,y);\n  }\n```\n\n\nSo when you encounter these edges, you set reachable vertex[] recursively, based on the entry times.\n    if (class == BACK) {\n                if (entry_time[y] < entry_time[ low[x] ] )\n                low[x] = y;\n    }\n\n```\nif (class == CROSS) \n{\n            if (scc[y] == -1)  /* component not yet assigned */\n                    if (entry_time[y] < entry_time[ low[x] ] )\n                            low[x] = y;\n}\n```\n\n\nA new strongly connected component is found whenever the lowest reachable vertex from vertex 'v' is itself (loop can say, a->b->c->a, lowest reachable vertex of a is a).\n\n```\nprocess_vertex_early(int v)\n{\n    push(&active,v);\n}\n```\n\n\nAfter DFS for a vertex is complete (DFS for it's neighbors would have been completed too), check the lowest reachable vertex for it:\n\n```\nif (low[v] == v) \n{     /* edge (parent[v],v) cuts off scc */\n          pop_component(v);\n}\n\nif (entry_time[low[v]] < entry_time[low[parent[v]]])\n          low[parent[v]] = low[v];\n```\n\n\npop_component(...) just pops from the stack until this component is found. If a->b->c->a is scanned the stack will have a(bottom)->b->c(top).. pop until vertex 'a' is seen. You get an SCC for 'a'..and similarly you get all connected components in one DFS. \n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "What are strongly connected components used for?\r\n                \r\nI have found several algorithms that explain how to find strongly connected components in a directed graph, but none explain why you would want to do this. What are some applications of strongly connected components?\n    ", "Answer": "\r\nYou should check out Tim Roughgarden's Introduction to Algorithms course on Coursera.  For every algorithm he goes over, he explains some applications of it.  Very useful, and makes one see the value of studying algorithms!\n\nThe use of strongly connected components that I remember him saying is that one could use it to find groups of people who are more closely related in a huge set of data.  Think of facebook and how they recommend people that might be your friends...\n\nThis could also be used to see chunks of a population. Say, \"Wow, this huge component all has the hobby of walking backwards and likes eating moldy pizza!,\" it could show correlation.  Advertisers for moldy pizza would use this data to target people who like walking backwards.  Who knows!\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Strongly Connected Component in Directed Graphs\r\n                \r\nWhy do we need to transpose the graph for getting SCCs (strongly connected components) of it? I know it gives the correct answer but I am not getting the logic.Please can someone help me with that.\n    ", "Answer": "\r\nDirected Acyclic Graphs do not contain any nontrivial strongly connected components, because a strongly connected component by definition contains a cycle.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Graph - strongly connected components\r\n                \r\nIs there any fast way to determine the size of the largest strongly connected component in a graph?\n\nI mean, like, the obvious approach would mean determining every SCC (could be done using two ```\nDFS```\n calls, I suppose) and then looping through them and taking the maximum.\n\nI'm pretty sure there has to be some better approach if I only need to have the size of that component and only the largest one, but I can't think of a good solution. Any ideas?\n\nThanks.\n    ", "Answer": "\r\nLet me answer your question with another question -\nHow can you determine which value in a set is the largest without examining all of the values?\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "A graph with maximum number of strongly connected components\r\n                \r\nCreate a directed graph with 6 nodes (say) such that it has maximum number of strongly connected components.\n\nFor example, take complete graph with 4 nodes with all edges connected. This is graph has only 1 strongly connected component, i.e entire graph is a single component.\n\nThe objective is to maximise the number of components.\n    ", "Answer": "\r\nYour question does not make sense as posted.\nBest guess: you want to create a new graph with a given number of nodes that will have the maximum number of strongly connected components.  Edges can be added between any pairs of nodes.\nThe smallest strongly component is a pair of nodes with an edge going in each direction between them.\nSo the maximum number of components in a graph with N nodes will be N / 2\ne.g. a 4 node graph with two components has edges between\n```\n1 2\n2 1\n3 4\n4 3\n1 3\n```\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Strongly Connected Components : Kosaraju algorithm\r\n                \r\nIn Kosaraju algorithm I came across two possible implementations:\n\n1) Search for strongly connected components in the reversed graph in the topological order of vertices in the original graph.\n\n2) Search for strongly connected components in the original graph in the topological order of vertices in the reversed graph.\n\nI wanted to that is it wrong to search for strongly connected components in the original graph using vertices in its reversed topological order. This will be better in terms of memory also as there is no need for a new adjacency list.\n\nsources :1) E-Maxx , 2) CLRS book\n    ", "Answer": "\r\nTerminology issues:\n\nYou are talking about topological ordering, but topological order exist if and only if the graph is DAG (directed acyclic). In case you want to work only with DAGs then you already have SCC (strongly connected components) as each vertex is component for itself. If you want to find SCC on directed graphs then you need to change topological  ordering to DFS finishing times. CLRS book mentions only finishing times ```\nf[u]```\n:\n\n\n  \n  Call DFS(G^T), but in the main loop of DFS, consider the vertices in order of decreasing f[u]...\n  \n\n\nReformulation of your question:\n\n\n  Is it wrong to search for strongly connected components in the original graph consider vertices in order of increasing finishing times ```\nf[u]```\n?\n\n\nAnswer: \n\nYes, it is wrong.\n\nCounterexample: Consider the following graph:\n\n\n\nwhich contains two components ```\nC```\n and ```\nC'```\n. If you run first DFS (starting from the node ```\nu```\n) you will end up with one of the two following lists in ascending order by finishing time:\n\nDFS list 1: ```\n{v,w',w,u}```\n\n\nDFS list 2: ```\n{w',v,w,u}```\n\n\nWhat you actually ask is whether you can process these lists from the beginning on the original graph. If you choose the first list you will extract component ```\nC'```\n via DFS  search starting from node ```\nv```\n, and then component ```\nC```\n via DFS search starting from node ```\nw'```\n. But if you choose the second list and start DFS from node ```\nw'```\n on original graph you will get only one component (whole graph), which is wrong.\n\nNote that Kosaraju's algorithm works in both cases, as it starts from the end of a list (node ```\nu```\n in both cases) and extract component ```\nC```\n via DFS search on reversed graph. Component ```\nC'```\n will be extracted later when we reach node ```\nv```\n in the list.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Graph, Definition of strongly connected component (SCC)?\r\n                \r\nAccording to the definition of strongly connected component T in a directed graph G(V, E), it says that for each u,v vertices in T then there is a path connecting them together (in both direction)\nMy question is, suppose I found a strongly connected component, does that mean the path can always include vertices from within T and not V\\T?\nIf not can I see a contradiction example?\n    ", "Answer": "\r\nIf by \"the path\" you mean every path from u to v or vice-versa, then yes, it does.\nIf a vertex w is on a path from u to v, then of course it can reach v.  Also, v can at least reach w through u.\nw can reach everything reachable by both v and u -- v, u, and w can all reach exactly the same set of vertices.\nThey are in the same SCC.\nPerhaps the easiest way to understand the definition of an SCC is like this:  If you remove all edges that aren't in cycles, then each remaining connected component is a strongly connected component.  Each vertex in an SCC can reach all the other ones.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "How to create a graph of largest strongly connected component\r\n                \r\nI want to create a graph of largest strongly connected component of a directed graph.\nNetworkx has a function (components.strongly_connected_components) that can extract a largest strongly connected component, but it only returns a generator of sets of nodes.\nBut this doesn't contain the connection between nodes.\nIs there any function that can create a directed graph of largest strongly connected component?\n    ", "Answer": "\r\nPlease see docs for extracting a subgraph.\nYou can get the edges of the subgraph containing those nodes.\nIn this simple example, nodes 2, 3, and 4 are strongly connected, but node 5 is disconnected (completely).\n```\nimport networkx as nx\nG = nx.DiGraph()\nG.add_nodes_from([2, 3, 4, 5])\n\nG.add_edge(2, 3)\nG.add_edge(4, 3)\nG.add_edge(4, 2)\nG.add_edge(3, 2)\nG.add_edge(3, 4)\nG.add_edge(2, 4)\n\n# following results in [{2, 3, 4}, {5}]\nstrongs = sorted(nx.strongly_connected_components(G), key=len, reverse=True)\nfor strong in strongs:\n    print(G.subgraph(strong).edges())\n```\n\nResult (first line is for ```\n{2, 3, 4}```\n, and the second line is for ```\n{5}```\n which has no edges):\n```\n[(2, 3), (2, 4), (3, 2), (3, 4), (4, 3), (4, 2)]\n[]\n```\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Finding Strongly Connected Components?\r\n                \r\nMy book defines a method to find the strongly connected components of a directed graph in linear time. In addition several other algorithms to find strongly connected components (i.e. Tarjan's algorithm) is also able to find the components in linear time.\n\nHowever all of these algorithms require the vertices of the graph to be ordered in decreasing post values (time the vertex is left). Common ordering algorithms such as Mergesort take O(n log n) time.\n\nTherefore how do these algorithms manage to complete locating the strongly connected components in linear time, if ordering the list of vertices by post values takes O(n log n) time?\n    ", "Answer": "\r\nSince \"time\" (the kind by which the post values are measured) is monotonically nondecreasing as a function of time (the number of steps executed by the depth-first search program), it suffices to append each node to a list immediately after the traversal leaves it. At the end of the traversal, the list is in sorted order.\n\nAlternatively, since the post values are integers bounded above polynomially, on some machine models it is possible to sort them in linear time using e.g. radix sort.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "How to process nodes of strongly connected components in a directed graph?\r\n                \r\nI am a beginner in area of graph algorithms programming. I am struggling with an interesting problem regarding strongly connected components and any help regarding that is highly appreciated. \n\nIn my application, the goal is to execute tasks on multiple threads as far as possible. These tasks are denoted as nodes in the directed graph and tasks may have cyclic dependencies. Cyclic dependencies are broken by finding the strongly connected components and then enforcing a predefined rule to delete an edge. This way, all tasks in a strongly connected component will end up executing serially. \n\nNow consider an example where tasks 1,2,...8 have the following dependency pattern. {1 -> 2, 2 -> 3, 3 -> 1, 3 -> 4, 4 -> 5, 5 -> 6, 6 -> 4, 7 -> 8}. Using the Strongly connected components and predefined rule to break cyclic dependencies, we get three sets of nodes i.e. A={1 -> 2 -> 3}, B={4 -> 5 -> 6}, and C={7 -> 8}, but since A and B are connected by an edge they can not execute in parallel.\n\nI would like to know if there is any algorithm or set of algorithms which I can use to get sets of nodes such that I can put A and B in sequential execution whereas C can be executed in parallel to A or B. As per my understanding topographical sort could be helpful, but it is only used for acyclic graphs. Any suggestion or help is highly appreciated. Thank you.\n    ", "Answer": "\r\nThe quotient graph that you describe with nodes A, B, C etc. is always acyclic: if it had a cycle, for example involving A and B, all tasks in A are reachable from all tasks in B and vice versa, so A and B are the same SCC.\nSo yes, you can toposort that graph.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "How to find Strongly Connected Components in a Graph?\r\n                \r\nI am trying self-study Graph Theory, and now trying to understand how to find SCC in a graph. I have read several different questions/answers on SO (e.g., 1,2,3,4,5,6,7,8), but I cant find one with a complete step-by-step example I could follow. \n\nAccording to CORMEN (Introduction to Algorithms), one method is:\n\n\n  \n  Call DFS(G) to compute finishing times f[u] for each vertex u\n  Compute Transpose(G)\n  Call DFS(Transpose(G)), but in the main loop of DFS, consider the vertices in order of decreasing f[u] (as computed in step 1)\n  Output the vertices of each tree in the depth-first forest of step 3 as a separate strong connected component\n  \n\n\nObserve the following graph (question is 3.4 from here. I have found several solutions here and here, but I am trying to break this down and understand it myself.)\n\n\n\nStep 1: Call DFS(G) to compute finishing times f[u] for each vertex u\n\nRunning DFS starting on vertex A:\n\n\n\nPlease notice RED text formatted as [Pre-Vist, Post-Visit]\n\nStep 2: Compute Transpose(G)\n\n\n\nStep 3.  Call DFS(Transpose(G)), but in the main loop of DFS, consider the vertices in order of decreasing f[u] (as computed in step 1)\n\nOkay, so vertices in order of decreasing post-visit(finishing times) values:\n\n{E, B, A, H, G, I , C, D, F ,J}\n\nSo at this step, we run DFS on G^T but start with each vertex from above list:\n\n\nDFS(E): {E}\nDFS(B): {B}\nDFS(A): {A}\nDFS(H): {H, I, G}\nDFS(G): remove from list since it is already visited\nDFS(I): remove from list since it is already visited\nDFS(C): {C, J, F, D}\nDFS(J): remove from list since it is already visited\nDFS(F): remove from list since it is already visited\nDFS(D): remove from list since it is already visited\n\n\nStep 4: Output the vertices of each tree in the depth-first forest of step 3 as a separate strong connected component.\n\nSo we have five strongly connected components: {E}, {B}, {A}, {H, I, G}, {C, J, F, D}\n\nThis is what I believe is correct. However, solutions I found here and here say SCCs are {C,J,F,H,I,G,D}, and {A,E,B}. Where are my mistakes?\n    ", "Answer": "\r\nYour steps are correct and your answer is also correct, by examining the other answers you provided you can see that they used a different algorithm: First you run DFS on G transposed and then you run an undirected components algorithm on G processing the vertices in decreasing order of their post numbers from the previous step.\n\nThe problem is they ran this last step on G transposed instead of in G and thus got an incorrent answer. If you read Dasgupta from page 98 onwards you will see a detailed explanation of the algorithm they (tried) to use.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "How many strongly connected components is there in this graph?\r\n                \r\nConsider the following graph. I can distinguish 4 strongly connected components, but they are 5.\nWhich one I missed? Also, can a node be shared in several components?\n\n\n    ", "Answer": "\r\nThe 5 components are:\n\n\nTop left node\nTop right node\nBottom left node\nBottom right node\nThe rest of the nodes\n\n\nWhat you thought of as components are not actually components, because they all can be expanded up to the 5th component from the list.\n\nNotice that it is not possible to extend the listed components, because each of corner nodes is either unreachable from anywhere else (has only outgoing edges) or can't reach any other node (has only incoming edges). Therefore you can't add those corners to bigger component, and can't add anything to corner nodes to make them larger components.\n\nBy definition strongly connected components are largest possible (so that it's not possible to further extend them), but there's nothing about not having intersections with each other in definition. However it is easy to show that components defined that way can't have intersections.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Largest strongly connected components of a directed graph\r\n                \r\nI am working on an ```\nNetworkx```\n ```\n.MultiDiGraph()```\n object built from a total of 82927 directed email data. At current stage, I am trying to get the largest strongly connected components from the ```\n.MultiDiGraph()```\n object and its corresponding subgraph.\nThe text data can be accessed here.\nHere's my working code:\n\n\r\n\r\n```\nimport networkx as nx\r\nimport pandas as pd\r\nimport matplotlib.pyplot as plt\r\nemail_df = pd.read_csv('email_network.txt', delimiter = '->')\r\nedge_groups = email_df.groupby([\"#Sender\", \"Recipient\"], as_index=False).count().rename(columns={\"time\":\"weight\"})\r\nemail = nx.from_pandas_dataframe(edge_groups, '#Sender', 'Recipient', edge_attr = 'weight')\r\nG = nx.MultiDiGraph()\r\nG.add_edges_from(email.edges(data=True))\r\n\r\n# G is a .MultiDiGraph object\r\n# using .strongly_connected_components() to get the part of G that has the most nodes\r\n# using list comprehension\r\nnumber_of_nodes = [len(n) for n in sorted(nx.strongly_connected_components(G))]\r\nnumber_of_nodes\r\n\r\n# 'number_of_nodes' return a list of [1, 1, 1,...,1] of length 167 (which is the exact number of nodes in the network)\r\n\r\n# using the recommended method in networkx documentation\r\n\r\nlargest = max(nx.strongly_connected_components(G), key=len)\r\nlargest\r\n\r\n# 'largest' returns {92}, not sure what this means... ```\n\r\n\r\n\r\n\n\nAs I noted in the above code block, the list comprehension method returns a list of [1, 1, 1,..., 1] of length 167 (which is the total number of nodes in my data), while the ```\nmax(nx.strongly_connected_components(G), key=len)```\n returned ```\n{92}```\n, I am not sure what this means.\n\nIt looks like there's something wrong with my code and I might have missed several key steps in processing the data. Could anyone care to take a look at and enlighten me on this?\n\nThank you.\n\nNote: Revised code (kudos to Eric and Joel)\n\n\r\n\r\n```\nimport networkx as nx\r\nimport pandas as pd\r\nimport matplotlib.pyplot as plt\r\nemail_df = pd.read_csv('email_network.txt', delimiter = '\t')\r\nedge_groups = email_df.groupby([\"#Sender\", \"Recipient\"], as_index=False).count().rename(columns={\"time\":\"weight\"})\r\n# per @Joel's comment, adding 'create_using = nx.DiGraph()'     \r\nemail = nx.from_pandas_dataframe(edge_groups, '#Sender', 'Recipient', edge_attr = 'weight', create_using = nx.DiGraph())\r\n# adding this 'directed' edge list to .MultiDiGraph() object\r\n\r\nG = nx.MultiDiGraph()\r\nG.add_edges_from(email.edges(data=True))```\n\r\n\r\n\r\n\n\nWe now examine the largest strongly connected component (in terms of the number of nodes) in this network.\n\n\r\n\r\n```\nIn [1]: largest = max(nx.strongly_connected_components(G), key=len)\r\nIn [2]: len(largest)\r\nOut [2]: 126```\n\r\n\r\n\r\n\n\nThe largest strongly connected component consists of 126 nodes.\n\n[Updates]\nUpon further trial and error, I found that one needs to use ```\ncreate_using = .MultiDiGraph()```\n (instead of ```\n.DiGraph()```\n) when loading data onto ```\nnetworkx```\n, otherwise, even if you get correct number of nodes for your ```\nMultiDiGraph```\n and its weakly/strongly connected subgraphs, you might still get the number of edges wrong! This will reflect in you ```\n.strongly_connected_subgraphs()```\n outputs.\n\nFor my case here, I will recommend others to use this one-liner\n\n\r\n\r\n```\nimport networkx as nx\r\nimport pandas as pd\r\nimport matplotlib.pyplot as plt\r\nG = nx.read_edgelist(path=\"email_network.txt\", data=[('time', int)], create_using=nx.MultiDiGraph(), nodetype=str)```\n\r\n\r\n\r\n\n\nAnd we can implement ```\n.strongly_connected_components(G)```\n and ```\nstrongly_connected_subgraphs```\n to verify.\n\nIf you use the ```\nnetworkx```\n output ```\nG```\n from the first code block, ```\nmax(nx.strongly_connected_components(G), key=len)```\n will give an output with 126 nodes and 52xx something edges, but if you apply the one-liner I listed above, you will get:\n\n\r\n\r\n```\nIn [1]: largest = max(nx.strongly_connected_components(G), key=len)\r\nIn [2]: G_sc = max(nx.strongly_connected_subgraphs(G), key=len)\r\n\r\nIn [3]: nx.number_of_nodes(G_sc) \r\nOut [3]: 126\r\nIn [4]: nx.number_of_nodes(G_sc) \r\nOut [4]: 82130```\n\r\n\r\n\r\n\n\nYou will get the same number of nodes with both methods but different number of edges owing to different counting mechanisms associated with different ```\nnetworkx```\n graph classes.\n    ", "Answer": "\r\nThe underlying cause of your error is that ```\nnx.from_pandas_dataframe```\n defaults to creating an undirected graph.  So ```\nemail```\n is an undirected graph.  When you then create the directed graph, each edge appears in only one direction.\n\nTo fix it use ```\nnx.from_pandas_dataframe```\n with the argument ```\ncreate_using = DiGraph```\n\n\n\n\nolder comments related to the output you were getting\n\nAll your strongly connected components have a single node.\n\nWhen you do ```\nmax(nx.strongly_connected_components(G), key=len)```\n it finds the set of nodes which has the longest length and returns it.  In your case, they all have length 1, so it returns one of them (I believe whichever networkx happened to put into ```\nnx.strongly_connected_components(G)```\n first).  But it's returning the set, not the length.  So ```\n{92}```\n is the set of nodes it is returning.  \n\nIt happens that ```\n{92}```\n was chosen to be the \"longest\" length 1 component in ```\nnx.strongly_connected_components(G)```\n by the tiebreaker.\n\nExample:\n\n```\nmax([{1}, {3}, {5}], key = len)\n> {1}\n```\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "MATLAB: Finding strongly connected components in undirected graph [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is seeking recommendations for books, tools, software libraries, and more. It does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     We don’t allow questions seeking recommendations for books, tools, software libraries, and more. You can edit the question so it can be answered with facts and citations.\r\n                \r\n                    \r\n                        Closed 7 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI have a network (undirected graph), which is represented by the following sparse matrix:\n\n```\n %  A B C D E F G H I J K L M\nmm=[0 0 1 1 0 0 1 0 0 0 0 0 0; % A\n    0 0 0 0 1 0 0 0 0 0 1 0 0; % B\n    1 0 0 1 0 1 0 0 0 0 0 1 0; % C\n    1 0 1 0 0 0 0 0 0 0 0 0 0; % D\n    0 1 0 0 0 0 0 0 0 0 0 0 1; % E\n    0 0 1 0 0 0 1 0 0 0 0 0 1; % F\n    1 0 0 0 0 1 0 0 0 0 0 1 0; % G\n    0 0 0 0 0 0 0 0 1 1 0 0 1; % H\n    0 0 0 0 0 0 0 1 0 1 0 0 0; % I\n    0 0 0 0 0 0 0 1 1 0 1 0 1; % J\n    0 1 0 0 0 0 0 0 0 1 0 0 0; % K\n    0 0 1 0 0 0 1 0 0 0 0 0 0; % L\n    0 0 0 0 1 1 0 1 0 1 0 0 0; % M\n   ]; \nxx=tril(mm + mm');\nview(biograph(sparse(xx),[],'ShowArrows','off','ShowWeights','off'))\n```\n\n\nIn this network, there are two strongly interconnected subnetwork: \n\n\nAre there some clever algorithm to identify such strongly connected subnetworks?\n\nPlease note that my matrix is rather big, ~10.000x10.000 entries, thus simple search algorithms might be too slow. Thanks a lot!\n    ", "Answer": "\r\nFirst of all, since this is an undirected graph there is no concept of strong connection. I was wrong in glancing over this important detail. Now, the two red circles are connected by a single edge and if we were to remove the edge from the graph the no. of connected components increases by 1(to 2). So given an undirected graph, the real question is \"Does there exist an edge(or edges), removing which would increase the number of connected components ?\". I can think of a brute force algo on the lines:\n\n\nRemove an edge e between n1 and n2. \nIs there still a path between n1 and n2 ?\nYes: This is not a candidate edge, go to 1\nNo: Good, removing this edge will break the graph, remove and go to 1\n\n\nIn the end the number of connected components would have increased by the number of edges removed. The complexity would be O(N*E) (O(N) for finding path between n1 and n2 after removing every edge). You may need to change your graph representation to do this effectively.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "How can I find strongly-connected components within larger strongly-connected components?\r\n                \r\nI have a program that needs to detect cycles (and nodes that are members of that cycle) in directed graphs. To do this, I use LLVM's strongly-connected components algorithm. It's pretty easy to use and it does pretty much what it should:\n\n```\nvector<vector<PreAstBasicBlock*>> stronglyConnectedComponents;\nfor (auto iter = scc_begin(&function); iter != scc_end(&function); ++iter)\n{\n    if (iter.hasLoop())\n    {\n        stronglyConnectedComponents.push_back(*iter);\n    }\n}\n```\n\n\nThis correctly identifies simple SCCs like this simple one:\n\n\n\nThis is great, but I'd love to know when I have strongly-connected components within each larger strongly-connected components. For instance, this is identified as a single SCC:\n\n\n\nThat's absolutely correct, since every node in that graph is reachable starting from any other node. However, B⇄C has the additional property that it is independent of the D→A back-edge. It is an SCC by itself and it has a single entry node and a single exiting node: I could replace it with one single node and I wouldn't have edges poking in or out of its conceptual middle.\n\nHow can I find these smaller strongly-connected components in the strongly-connected components?\n    ", "Answer": "\r\nSo I was trying to craft a nice response / things you can do with more functions available to you, but was working on it offline and my computer crashed :(.\n\nI've recreated the core of what I was trying to say, that only solves your immediate problem / example, in pseudo-code using a nonexistent ```\nGetConnectedComponents(...)```\n helper function whose idealized behavior you can hopefully understand from context:\n\n```\nbool HasConnectedSubgraph(Graph& entire_graph) {\n  for (const auto& connected_subgraph : GetConnectedComponents(entire_graph)\n    for (const auto& connected_node : connected_subgraph) {\n      local_copy = connected_subgraph;\n      local_copy.erase(std::remove_if(local_copy.begin(), local_copy.end(), \n          [&](const Node& n) {return n == connected_node}) , local_copy.end());\n      if (!GetConnectedComponents(local_copy).empty()) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n```\n\n\nThis certainly isn't efficient or pretty, but should be enough to springboard your thoughts on the problem.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Strongly connected component\r\n                \r\nGiven total number of V vertices and total number of E edges of a graph G, how can I compute largest strongly connected component with minimum number of vertices & edges in strongly connected component of graph. \nEg. for graph with 5 vertices and 7 edges, the minimum size of connected component is 3. This graph can be modeled so that there are more connected components but minimum is 3.\nThe problem I am facing is that edge information is not given to me. Only the total number of edges are given. I wanted to use Tarjan's algorithm using depth first search but I need edge information. \nIs it possible to find the size of strongly connected component with minimum vertices and edges just total number of vertices and total number of edges.\n    ", "Answer": "\r\nSimplest way I can think of is to consider trying to utilise the edges to form components that are Complete Graphs of size 1, then 2, etc until you find one that works.\n\nA complete graph of size n has (n2 - n) / 2 edges. So to split into components of size n will look something like\n\n```\nnumFullComponents := V/n //integer division\nnumEdgesUsed := numFullComponents * n * (n-1) / 2 //This is edges from full components\n    + (V%n) * (V%n - 1)/2 //a complete graph on the remainder nodes\n```\n\n\nYou can then compare that number of edges used with the number of edges in the graph. The smallest n that uses at least E edges is the solution.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Visualize strongly connected components in R\r\n                \r\nI have a weighted directed graph with three strongly connected components(SCC).\nThe SCCs are obtained from the ```\nigraph::clusters```\n function\n\n```\nlibrary(igraph)\nSCC<- clusters(graph, mode=\"strong\")  \nSCC$membership\n [1] 9 2 7 7 8 2 6 2 2 5 2 2 2 2 2 1 2 4 2 2 2 3 2 2 2 2 2 2 2 2\nSCC$csize\n[1]  1 21  1  1  1  1  2  1  1\n SCC$no\n[1] 9\n```\n\n\nI want to visualize the SCCs with circles and a colored background as the graph below, is there any ways to do this in R? Thanks!\n\n\n    ", "Answer": "\r\nTake a look at the ```\nmark.groups```\n argument of ```\nplot.igraph```\n. Something like the following will do the trick:\n\n```\n# Create some toy data\nset.seed(1)\nlibrary(igraph)\ngraph <- erdos.renyi.game(20, 1/20)\n\n# Do the clustering\nSCC <- clusters(graph, mode=\"strong\")  \n\n# Add colours and use the mark.group argument\nV(graph)$color <- rainbow(SCC$no)[SCC$membership]\nplot(graph, mark.groups = split(1:vcount(graph), SCC$membership))\n```\n\n\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "How can the number of strongly connected components of a graph change if a new edge is added\r\n                \r\nExercise: 22.5-1 CLRS\nHow can the number of strongly connected components of a graph change if a new\nedge is added?\n\n Somewhere the answer given is If a new edge is added, one of two things could happen.\n1) If the new edge connects two vertices that belong to a strongly connected component, the number of strongly connected components will remain the same.\n2) If, instead, the edge connects two strongly connected components, and the edge is in the reverse direction of an existing path between the two components, then a new strongly connected component will be made, increasing the number of components. \nI think the second point is incorrect.\nLets say we have two strongly connected component C  and C' \na) If no edge or edge C->C' exists between them and new edge connects as C->C'  then nothing will happen.\nb) If edge  C->C'  exists between them and new edge connects as C'->C  then C' will be merged to C decreasing the number of strongly connected component by 1 as every vertex will be reachable from each other.\nPlease correct me if i am wrong.\n    ", "Answer": "\r\nYou're exactly correct. The answer you quoted is wrong in its description: adding edges is only ever going to decrease the number of strongly connected components. Once all possible edges have been added, there's just a single strongly connected component left - the entire graph.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Is it possible to visualize the Strongly Connected Components of directed graph in Gephi?\r\n                \r\nI want to visualize the strongly connected components of directed graph in Gephi. I can get the no. of SCC in the graph but can't find a way to visualize it. I have used \"Force Atlas 2\" to layout the graph of nearly 6000 nodes(~20000 edges), but what i get from the visualized graph is just the \"out-degree\" edges of nodes. Can someone help me how to visualize the strongly connected components either in gephi or by some other means.\nThanks a lot!\n    ", "Answer": "\r\nI'm not sure I understand what you want, but maybe this can help you.\nIn the statistics panel, execute DBSCAN.\nThen get back to the appearence panel and select node size --> ranking --> number of clusters\nThis \"number of clusters\" will appear only after \"DBSCAN\".\nIn general, many metrics for \"ordering\" the graphs, appear only after executing the related statistic, which, in my opinion, while confusing initially, is a good approach, since this way, you get a minimum number of possibilities which, you understand what they mean.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Computing the top 5 SCC(Strongly Connected Components) components in a Directed graph\r\n                \r\nI am stuck on this problem where I have to compute the size of top 5 strongly connected components.\n\nBy top 5 I mean the top 5 in size(number of vertices)\n\nThe link to edges of the directed graph is here.\n\nThis is the code that I have used but my answer is coming wrong.The problem is that when I run the code on small graphs, it gives me correct answer but when I run it on the text file provided in a link of the given porblem, the answer is coming wrong.\n\nThe size of top 5 SCC as computed by my code is coming wrong.\n\n```\nimport java.util.*;\nimport java.io.*;\nclass SCC\n{\n private ArrayList<LinkedList<Integer>> adj_list;\n private ArrayList<LinkedList<Integer>> adj_list2;\n private LinkedList<Integer> top_5;\n private BufferedReader br;\n private Stack<Integer> st;\n private boolean second_dfs=false;\n private char []visited;\n private  int size=0;\n private int not_again=-1;\n public void create_graph()throws IOException\n {\n     String s;\n     String []arr;\n     adj_list=new ArrayList<LinkedList<Integer>>();\n     visited=new char[875714];\n     for(int i=0;i<875714;++i)\n      {adj_list.add(new LinkedList<Integer>());visited[i]=48;}\n     br=new BufferedReader(new FileReader(\"P4.txt\"));\n     while((s=br.readLine())!=null)\n     {\n         arr=s.split(\" \");         \n         adj_list.get(Integer.parseInt(arr[0])-1).add(Integer.parseInt(arr[1]));\n     }\n     st=new Stack<Integer>();\n     top_5=new LinkedList<Integer>();\n }\n public void rev_graph()\n {\n     int i;\n     ArrayList<LinkedList<Integer>> g1;\n     g1=new ArrayList<LinkedList<Integer>>();\n     for(i=0;i<adj_list.size();++i)\n      g1.add(new LinkedList<Integer>());\n     for(i=0;i<adj_list.size();++i)\n      for(int e:adj_list.get(i))\n       g1.get(e-1).add(i+1);\n     adj_list=new ArrayList<LinkedList<Integer>>(g1);\n }\n public void DFS(int v)\n {\n     if(second_dfs==true)\n     {++size;}\n     visited[v-1]=49;     \n     for(int e:adj_list.get(v-1))\n      if(visited[e-1]==48)\n       DFS(e);\n     if(second_dfs==false)\n     st.push(v);\n }\n public void give_SCC()\n {    \n     second_dfs=true;int done=0;\n     for(int i=0;i<875714;++i)\n     {visited[i]=48;}\n     while(!st.isEmpty())\n     {\n      size=0;\n      int v=st.pop();\n      if(visited[v-1]==48)\n       {DFS(v);}\n      if(size!=0)\n       top_5.add(size);      \n     }\n }\n public static void main(String []args)throws IOException\n {\n     SCC obj=new SCC();\n     obj.create_graph();\n     obj.adj_list2=new ArrayList<LinkedList<Integer>>(obj.adj_list);\n     obj.rev_graph();\n     obj.DFS(1);     \n     obj.adj_list=new ArrayList<LinkedList<Integer>>(obj.adj_list2);\n     obj.give_SCC();\n     Collections.sort(obj.top_5);\n     for(int i=obj.top_5.size()-1;i>=obj.top_5.size()-5;--i)\n      System.out.println(obj.top_5.get(i));\n } \n}     \n```\n\n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "How to get the edge list of a strongly connected components in a graph?\r\n                \r\nI have a weighted directed multigraph with a few cycles. With ```\nclusters```\n function in ```\nigraph```\n package, I can get the nodes belongs to a strongly connected components. But I need the path/order of the nodes that form a cycle. \n\nEDIT after @josilber's response\n\nI have a very dense graph, with 30 nodes and around 2000 edges. So ```\ngraph.get.subisomorphisms.vf2```\n takes too long to run in my case.\n\nI'm not familiar with graph algorithm, but I'm thinking maybe do a DFS to the original or reverse graph and use the ```\norder```\n or ```\norder.out```\n might work, but not sure.\n\nOr any other ideas to make this run faster are welcomed!\n\nExample\n\n```\nlibrary(igraph)\nset.seed(123)\ngraph <-graph(c(1,2,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,8,10,9,10,9,10,10,11,10,5,11,12,12,13,13,14,14,15,14,20,15,16, 16,17,17,18,18,19,19,20,20,21,21,1,22,23,22,23,23,22),directed=T)\nE(graph)$weight= runif(ecount(graph),0,10)\n\n> clusters(graph, \"strong\")\n$membership\n [1] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 1\n\n$csize\n[1]  2 21\n\n$no\n[1] 2\n```\n\n\nHow do I get the edge list of a cycle with the highest weight here? Thanks!\n    ", "Answer": "\r\nAssuming that all nodes in each strongly connected component form a cycle and that you're only interested in this large cycle (e.g. in your example you're just interested in the cycle with nodes 1:21 and the cycle with nodes 22:23), then you can extract the node order that forms the cycle, grab the weights on the edges, and compute the total weight of the cycle.\n\n```\n# Compute the node order of the cycle for each component by performing an\n# isomorphism with a same-sized directed ring graph\nclusts <- clusters(graph, \"strong\")\n(cycles <- lapply(1:clusts$no, function(x) {\n  sg <- induced.subgraph(graph, clusts$membership == x)\n  n <- sum(clusts$membership == x)\n  col <- rep(c(1, 0), c(1, n-1))  # Used to grab isomorphism starting at 1\n  sg.idx <- graph.get.subisomorphisms.vf2(sg, graph.ring(n, directed=TRUE), col, col)[[1]]\n  which(clusts$membership == x)[sg.idx]\n}))\n# [[1]]\n# [1] 22 23\n# \n# [[2]]\n#  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21\n```\n\n\nNow you can grab the sum of the edge weights for each cycle:\n\n```\nsapply(cycles, function(x) sum(graph[from=x, to=c(tail(x, -1), x[1])]))\n# [1]   8.833018 129.959437\n```\n\n\nNote that this is in general NP-hard, because finding a Hamiltonian cycle in a general graph is NP-hard. Therefore the ```\ngraph.get.subisomorphisms.vf2```\n call could be quite slow for large graphs.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Creating Strongly Connected Components from a DAG\r\n                \r\nI am trying to create strongly connected components from a directed acyclic graph.\n\nThe input is a list of edges in form \n\n```\n1 2\n3 5\netc\n```\n\n\nI need to create an outpoint of a minimal set of edges to be added to the given graph to make a graph of strongly connected components....\n\nAny ideas?\n\nHere's an example of what I'm looking for:\n\nGiven the input: \n\n```\n1 3\n1 4\n2 3\n2 4\n5 7\n5 8\n6 8\n6 9\n```\n\n\nThe output would be the minimum number of edges necessary for addition to create strongly connected components.\n\nOutput:\n\n```\n3 1\n4 5\n7 6\n8 1\n9 2\n```\n\n    ", "Answer": "\r\nAssuming there are no isolated vertices in the graph you only need to add max(|sources|,|sinks|) edges to make it strongly connected.\n\nLet T={t1,…,tn} be the sinks and {s1,…,sm} be the sources of the DAG. Assume that n <= m. (The other case is very similar). Consider a bipartite graph G(T,S) between the two sets defined as follows. G(T,S) has an edge (ti,sj) if and only if ti can be reached from sj.\n\nLet M be a maximal matching in G(T,S). Without loss of generality assume that M consists of k edges: {(t1,s1),(t2,s2),…,(tk,sk)}. In the original graph DAG G, add directed-edges {(t1->s2),(t2->s3),…,(tk−1->sk),(tk->s1)}. It's easy to see that by adding these edges, the vertices induced by M are strongly connected in G.\n\nNow consider the remaining vertices in G(T,S). Because M maximal, each vertex in S−M (resp. T−M)should be connected to a vertex in T (resp. S−M). So we pair up the remaining vertices arbitrarily, say {(tk+1,sk+1),…,(tn,sn)} and add the corresponding directed edges in G. For each remaining source vertex source si (i belongs to {n+1,…,m} we add the edge (t1->si) in G. Thus the total number of edges added is max(|sources|,|sinks|).\n\nEDIT: Adding a couple of Examples\n\nFor the example in your input. We fist compute a maximal matching, say:\n\n```\n3--1\n4--2\n7--5\n8--6\n```\n\n\nSo we add the edges:\n\n```\n3->2\n4->5\n7->6\n8->1\n```\n\n\nThe remaining (sink) vertex not present in the matching is 9 and so we add the arc from 9 to any source vertex in the matching, say ```\n9->1```\n.\n\nHere's another example that illustrates all the steps of the algorithm:\n\nInput Graph:\n\n```\n12 3   5    9 10  (sources)\n\\|/   /|\\    \\/\n 4   6 7 8   11   (sinks)\n```\n\n\nMaximal Matching:\n\n```\n4--1\n6--5\n11--9\n```\n\n\nSo we add the edges:\n\n```\n4->5\n6->9\n11->1\n```\n\n\nNow the remaining sinks are ```\n{7, 8}```\n and the remaining sources are ```\n{2, 3, 10}```\n. We arbitrary pair 7 with say 2 and 8 with say 3 and add:\n\n```\n7->2\n8->3\n```\n\n\nFinally, the remaining (source) vertex is 10 and we add:\n\n```\n4->10\n```\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Implement Strongly connected Components for Integers in file\r\n                \r\nI am working on implementing the Strongly Connected Components Program from input file of numbers.I know the algorithm on how to do this,but having hard time implementing it in python.\n\nSTRONGLY-CONNECTED-COMPONENTS(G)\n1. run DFS on G to compute finish times\n2. compute G'\n3. run DFS on G', but when selecting which node to vist do so\n   in order of decreasing finish times (as computed in step 1)\n4. output the vertices of each tree in the depth-first forest \n   of step 3 as a separate strongly connected component\n\nThe file looks like this:\n\n```\n5 5\n1 2\n2 4\n2 3\n3 4\n4 5\n```\n\n\nThe first line is no. of nodes and edges.The rest of the lines are two integers u and v separated by a space, which means a directed edge from node u to node v.The output is to be a strongly connected component and the no.of these components.\n\n```\nDFS(G)\n1 for each vertex u in G.V\n2     u.color = WHITE\n3     u.π = NIL\n4 time = 0\n5 for each vertex u in G.V\n6     if u.color == WHITE\n7         DFS-VISIT(G, u)\n\nDFS-VISIT(G, u)\n1 time = time + 1 // white vertex u has just been discovered\n2 u.d = time\n3 u.color = GRAY\n4 for each v in G.adj[u]\n5     if v.color == WHITE\n6         v.π = u\n7         DFS-VISIT(G, u)\n8 u.color = BLACK // blacken u; it is finished\n9 time = time + 1\n10 u.f = time\n```\n\n\nIn the above algorithm how should I traverse the reverse graph to find SCC.\n    ", "Answer": "\r\nHere, implemented in Python.\n\nPlease notice that I construct G and G' at the same time. My DFS is also modified. The ```\nvisited```\n array stores in which component each node is. Also, the DFS receives a ```\nsequence```\n argument, that is the order in which the nodes will be tested. In the first DFS, we pass a xrange(n), but in the second time, we pass the reversed(order) from the first execution.\n\nThe program will output something like:\n\n```\n3\n[1, 1, 1, 2, 3]\n```\n\n\nIn that output, we have 3 strongly connected components, with the 3 first nodes in a single component and the remaining two with one component each.\n\n```\ndef DFSvisit(G, v, visited, order, component):\n    visited[v] = component\n    for w in G[v]:\n        if not visited[w]:\n            DFSvisit(G, w, visited, order, component)\n    order.append(v);\n\ndef DFS(G, sequence, visited, order):\n    components = 0\n    for v in sequence:\n        if not visited[v]:\n            components += 1\n            DFSvisit(G, v, visited, order, components)\n\nn, m = (int(i) for i in raw_input().strip().split())\n\nG = [[] for i in xrange(n)]\nGt = [[] for i in xrange(n)]\nfor i in xrange(m):\n    a, b = (int(i) for i in raw_input().strip().split())\n    G[a-1].append(b-1)\n    Gt[b-1].append(a-1)\n\norder = []\ncomponents = [0]*n\n\nDFS(G, xrange(n), [0]*n, order)\nDFS(Gt, reversed(order), components, [])\n\nprint max(components)\nprint components\n```\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Creating a graph and finding strongly connected components in a single pass (not just Tarjan!)\r\n                \r\nI have a particular problem where each vertex of a directed graph has exactly four outward-pointing paths (which can point back to the same vertex).\n\nAt the beginning, I have only the starting vertex and I use DFS to discover/enumerate all the vertices and edges.\n\nI can then use something like Tarjan's algo to break the graph into strongly connected components.\n\nMy question is, is there a more efficient way to doing this than discovering the graph and then applying an algorithm. For example, is there a way of combining the two parts to make them more efficient?\n    ", "Answer": "\r\nTo avoid having to \"discover\" the graph at the outset, the key property that Tarjan's algorithm would need is that, at any point in its execution, it should only depend on the subgraph it has explored so far, and it should only ever extend this explored region by enumerating the neighbours of some already-visited vertex.  (If, for example, it required knowing the total number of nodes or edges in the graph at the outset, then you would be sunk.)  From looking at the Wikipedia page it seems that the algorithm does indeed have this property, so no, you don't need to perform a separate discovery phase at the start -- you can discover each vertex \"lazily\" at the lines ```\nfor each (v, w) in E do```\n (enumerate all neighbours of v just as you currently do in your discovery DFS) and ```\nfor each v in V do```\n (just pick v to be any vertex you have already discovered as a w in the previous step, but which you haven't yet visited yet with a call to ```\nstrongconnect(v)```\n).\n\nThat said, since your initial DFS discovery phase only takes linear time anyway, I'd be surprised if eliminating it sped things up much.  If your graph is so large that it doesn't fit in cache, it could halve the total time, though.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "How to find if the whole graph is one strongly connected component?\r\n                \r\nI have this code for finding if the graph is a strongly connected component\n\n```\nvector<int> G[2005];\nint depth = 0;\nvoid dfs(int u)\n{\n visited[u] = 1;\n low[u] = ++depth;\n  for(int i=0;i<G[u].size();++i)\n  {\n    int v = G[u][i];\n    if(!visited[v])\n        dfs(v);\n        low[u] = min(low[u],low[v]);\n  }\n}\n```\n\n\nI ran dfs(1) and then \n    for every vertex I checked if the low[u] == 1 for all vertex and every vertex has been visited.\nIs this the correct approach? It should be, but somehow it isn't working.\nHere is a problem about what I am trying to achieve http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2938&mosmsg=Submission+received+with+ID+12516894\n    ", "Answer": "\r\nI would use Tarjan's algorithm.\n\nEssentially what it does it compute the strongly connected components in ```\nO(|E|)```\n time. Then you can simply look at the number of SCCs. If it is not 1, then the whole graph is not one SCC. Also, you can provide an early quit version, e.g., once I find a second SCC quit.\n\nsome c++ as a starting ground: (but still pseudocode like)\n\n```\nvector<SCC> ComputeSCC(Graph& g) {\n  int index = 0;\n  vector<SCC> sccs;\n  stack<Vertex> s;\n\n  //for each vertex grab the SCC\n  for(auto v : g.vertices())\n    if(v.index == -1)\n      StronglyConnected(g, v, index, s, sccs);\n\n  return sccs;\n}\n\nvoid StronglyConnected(Graph& g, Vertex& v, int& i, stack<Vertex>& s, vector<SCC>& sccs) {\n  v.index = i;\n  v.lowlink = i;\n  i++;\n  s.push_back(v);\n\n  //for each successor\n  for(auto e : v.successors()) {\n    if(e.target().index == -1) {\n      StronglyConnected(g, e.target(), i, sccs);\n      v.lowlink = min(v.lowlink, e.target().lowlink);\n    }\n    else\n      v.lowlink = min(v.lowlink, e.target().index);\n  }\n\n  //If v is a root node, pop the stack and generate an SCC\n  if(v.lowlink == v.index) {\n    sccs.push_back(SCC());\n    Vertex w;\n    do {\n      w = S.pop();\n      sccs.back().push_back(w);\n    } while(w != v);\n  }\n}\n```\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Strongly Connected Components with BFS\r\n                \r\nHow can I find strongly connected components with BFS in directed graph? \n\nI know  Kosaraju’s algorithm which uses DFS.I want to find with BFS.\n    ", "Answer": "\r\nA paper [1] from Penn State University in 2014, proposed a multistep method, which reduced total work when compared to the forward-backward algorithm, and combined the advantages of several parallel SCC finding algorithms. \n\nThey utilized a hybrid bottom-up approach to BFS [2] and vastly reduce the total number of edge examinations needed during BFS. Different from [2], they maintained the thread queues while running the bottom-up hybrid BFS, as opposed to explicitly rebuilding the queue from scratch when switching the hybrid off, since they only required visited array to determine the SCC.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Update strongly connected components as edges are added\r\n                \r\nLet G = (V, E) be a strongly connected directed graph. Start with the graph G' = (V, {}). We are given a list L of edges in E such that every edge in L we add to G' (in order) connects two strongly connected components. What's a fast algorithm to keep track of the strongly connected components of G' as we add one edge at a time? Using Kosaraju's or Tarjan's algorithm at every step takes O(|E|(|V|+|E|)) time, which I'm guessing can be improved.\n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Connected subgraph from several strongly connected components\r\n                \r\nSuppose, given a connected directed graph G, with several strongly connected components in it: G1, G2, ... All of them are known and there is a function f : Gi -> bool that returns true for some of them and false from others.\n\nNow lets take all Gi, such that f(Gi) is true and ignore others. Is there some easy approach to build connected subgraph in G, containing all of them, and minimal number of other edges from G?\n    ", "Answer": "\r\nMake condensation and then make spanning tree in subgraph ```\nf(Gi) = true```\n of this condensation. Hint, condensation is always partially ordered which makes spanning tree construction easier.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Strongly Connected Component Algorithm\r\n                \r\nI have hard time to solve Strongly connected component algorithm. \nI have done these implementations blow so far but I got an unexpected result.\n\n\nDFS and add nodes to stack (named ```\nvar leader```\n in my code) in order to keep depth of each vertices\nReverse graph edges' direction (```\ngetReverseGraph()```\n)\nSecond DFS and create Strongly connected component\n\n\nI have an issue on step 3 and can not detect component properly.\n\nExpected: \n\n[ [ '1', '7', '5' ], ['2', '4'], [ 6, '3' ] ] \n\nResult: \n\n[ [ '1', '7', '5', '2', '4'], [ 6, '3' ] ]. \n\nWould anyone give me some advice? Thanks!\n\n\r\n\r\n```\nfunction Graph() {\r\n  this.list = {};\r\n}\r\n\r\nGraph.prototype.insert = function(newVertex, neighborVertex) {\r\n  if (!this.list[newVertex]) {\r\n\r\n    if (neighborVertex) {\r\n      this.list[newVertex] = [neighborVertex];\r\n    } else {\r\n      this.list[newVertex] = [];\r\n    }\r\n\r\n  } else {\r\n\r\n    // If neighborVertex is not initialized\r\n    if (!this.list[neighborVertex]) {\r\n      this.list[neighborVertex] = [];\r\n    }\r\n\r\n    // Add neighborVertex to\r\n    this.list[newVertex].push(neighborVertex);\r\n\r\n  }\r\n};\r\n\r\nGraph.prototype.addEdge = function(vertexFrom, vertexTo) {\r\n  if (this.list[vertexFrom] || this.list[vertexTo]) {\r\n    throw new Error('Vertex does not exsists')\r\n  }\r\n\r\n  this.list[vertexFrom].push(vertexTo);\r\n};\r\n\r\n/*\r\n * DFS\r\n *\r\n * @param graph {object}: Takes different graph as optional\r\n * @param vertex {string|integer}\r\n * @param cb {function}\r\n */\r\n\r\nGraph.prototype.dfs = function(graph, vertex, cb) {\r\n  // track which node visited\r\n  var visited = {};\r\n\r\n  // Take graph as option\r\n  var list = graph ? graph : this.list;\r\n\r\n  // get initial nodes\r\n  var currentNodes = list[vertex];\r\n\r\n  // Invoke given function for inital node\r\n  cb(vertex);\r\n\r\n  // Mark vertex as visited\r\n  visited[vertex] = true;\r\n\r\n  // If there is no node to traverse return\r\n  if (currentNodes.length === 0) {\r\n    return;\r\n  }\r\n\r\n  var stack = [...currentNodes];\r\n\r\n  for (var node of currentNodes) {\r\n    visited[node] = true;\r\n  }\r\n\r\n  while (stack.length > 0) {\r\n\r\n    // Get a node from stack\r\n    var nextNode = stack.pop();\r\n\r\n    // Invoke given function\r\n    cb(nextNode);\r\n\r\n    // Mark the vertex as visited\r\n    visited[nextNode] = true;\r\n\r\n    // Iterate adjacent nodes\r\n    if (list[nextNode]) {\r\n\r\n      // console.log('stack', stack)\r\n      for (var neighbor of list[nextNode]) {\r\n\r\n        // If the vertex is not visited, push each nodes to stack\r\n        if (!visited[neighbor]) {\r\n          stack.push(neighbor);\r\n          visited[neighbor] = true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction getReverseGraph(graph) {\r\n  var vertices = Object.keys(graph);\r\n  var reverseEdgeGraph = {};\r\n\r\n  for (let vertex of vertices) {\r\n    for (let neighbor of graph[vertex]) {\r\n      if (reverseEdgeGraph[neighbor]) {\r\n        reverseEdgeGraph[neighbor].push(vertex);\r\n      } else {\r\n        reverseEdgeGraph[neighbor] = [vertex];\r\n      }\r\n    }\r\n  }\r\n\r\n  return reverseEdgeGraph;\r\n}\r\n\r\nGraph.prototype.getStrongComponent = function(vertex) {\r\n\r\n  if (vertex && !this.list[vertex]) {\r\n    throw new(\"No vertex exsits\")\r\n  }\r\n\r\n  vertex = vertex ? vertex.toString() : Object.keys(this.list)[0].toString();\r\n\r\n  /*\r\n  Create Copy of current Adjacency list\r\n  */\r\n\r\n  var reverseEdgeGraph = getReverseGraph(this.list);\r\n\r\n  /*\r\n  Create Leader\r\n  */\r\n\r\n  var leader = []; // stack to keep the depth\r\n\r\n  var keys = Object.keys(this.list);\r\n\r\n  while (keys.length > 0) {\r\n\r\n    var indexOfVertex = keys.indexOf(vertex);\r\n    keys.splice(indexOfVertex, 1);\r\n\r\n    this.dfs(null, vertex, function(vertex) {\r\n\r\n      // If leader does not have the vertex\r\n\r\n      if (leader.indexOf(vertex) < 0) {\r\n        // Get the key (vertex)\r\n        var indexOfVertex = keys.indexOf(vertex);\r\n\r\n        // Delete vertex\r\n        keys.splice(indexOfVertex, 1);\r\n\r\n        // Add vertex to leader\r\n        leader.unshift(vertex);\r\n      }\r\n\r\n    });\r\n\r\n    // Move to next key (remaining node)\r\n    vertex = keys[0];\r\n  }\r\n\r\n\r\n  /**\r\n   *\r\n   * Create SCC\r\n   *\r\n   **/\r\n\r\n  var allSCC = [];\r\n  var visited = {};\r\n\r\n  while (leader.length > 0) {\r\n    var SCC = [];\r\n    var target = leader.pop();\r\n\r\n    if (visited[target]) {\r\n      break;\r\n    }\r\n\r\n    this.dfs(reverseEdgeGraph, target, function(vertex) {\r\n      // Create component\r\n      if (!visited[vertex]) {\r\n        visited[vertex] = true;\r\n        SCC.push(vertex);\r\n      }\r\n\r\n    });\r\n\r\n    if (SCC.length > 0) {\r\n      allSCC.push(SCC);\r\n    }\r\n  }\r\n\r\n  return allSCC\r\n}\r\n\r\n\r\nfunction test() {\r\n  var graph = new Graph();\r\n  var result = [\r\n    [2, 4],\r\n    [4, 2],\r\n    [7, 5],\r\n    [5, 1],\r\n    [1, 7],\r\n    [1, 5],\r\n    [5, 7],\r\n    [7, 1],\r\n    [6, 3],\r\n    [3, 6],\r\n    [2, 7],\r\n    [1, 6]\r\n  ]\r\n  result.forEach(function(line) {\r\n    // console.log(line)\r\n    graph.insert(line[0], line[1]);\r\n  });\r\n\r\n  var result = graph.getStrongComponent().map(function(components) {\r\n    return components.length\r\n  }).sort(function(a, b) {\r\n    return b - a\r\n  });\r\n  console.log('result => ', graph.getStrongComponent(1));\r\n}\r\n\r\nfunction dfs() {\r\n  var graph = new Graph();\r\n  graph.insert('a', 'b');\r\n  graph.insert('a', 'g');\r\n  graph.insert('b', 'c');\r\n  graph.insert('c', 'd');\r\n  graph.insert('d', 'e');\r\n  graph.insert('e', 'f');\r\n  graph.insert('f', 'd');\r\n  graph.insert('f', 'g');\r\n  graph.insert('g', 'e');\r\n  graph.insert('g', 'a');\r\n  graph.insert('g', 'b');\r\n  graph.insert('g', 'c');\r\n  graph.insert('g', 'd');\r\n  graph.insert('g', 'h');\r\n\r\n  graph.dfs(null, 'a', function(v) {\r\n    console.log(v);\r\n  })\r\n}\r\n\r\n// dfs();\r\ntest(); // should be [ [ '1', '7', '5' ], ['2', '4'], [ 6, '3' ] ]```\n\r\n\r\n\r\n\n    ", "Answer": "\r\nYou are running the dfs for each node, highly inefficient as you start each dfs with all nodes as unvisited. I added a fourth parameter to your dfs function to keep a single visited object for all the calls. That also avoids repeating nodes in your callback, giving the order you want. Also slightly modified it to be a bit shorter.\n\nWith this I refactored both the first dfs traversal and the second one on the reversed graph. Callback is much more cleaner an easier to understand this way, took me a long time to understand what were you doing in your first dfs callback.\n\nCode works now:\n\n\r\n\r\n```\nfunction Graph() {\r\n  this.list = {};\r\n}\r\n\r\nGraph.prototype.insert = function(newVertex, neighborVertex) {\r\n  if (!this.list[newVertex]) {\r\n\r\n    if (neighborVertex) {\r\n      this.list[newVertex] = [neighborVertex];\r\n    } else {\r\n      this.list[newVertex] = [];\r\n    }\r\n\r\n  } else {\r\n\r\n    // If neighborVertex is not initialized\r\n    if (!this.list[neighborVertex]) {\r\n      this.list[neighborVertex] = [];\r\n    }\r\n\r\n    // Add neighborVertex to\r\n    this.list[newVertex].push(neighborVertex);\r\n\r\n  }\r\n};\r\n\r\nGraph.prototype.addEdge = function(vertexFrom, vertexTo) {\r\n  if (this.list[vertexFrom] || this.list[vertexTo]) {\r\n    throw new Error('Vertex does not exsists')\r\n  }\r\n\r\n  this.list[vertexFrom].push(vertexTo);\r\n};\r\n\r\n/*\r\n * DFS\r\n *\r\n * @param graph {object}: Takes different graph as optional\r\n * @param vertex {string|integer}\r\n * @param cb {function}\r\n */\r\n\r\nGraph.prototype.dfs = function(graph, vertex, cb, visited) {\r\n  // track which node visited\r\n  var visited = visited || {};\r\n\r\n  // Take graph as option\r\n  var list = graph ? graph : this.list;\r\n\r\n  if (visited[vertex]) return;\r\n  \r\n  // Mark vertex as visited\r\n  visited[vertex] = true;\r\n\r\n  var stack = [vertex];\r\n\r\n  while (stack.length > 0) {\r\n\r\n    // Get a node from stack\r\n    var nextNode = stack.pop();\r\n\r\n    // Invoke given function\r\n    cb(nextNode);\r\n\r\n    // Iterate adjacent nodes\r\n    if (list[nextNode]) {\r\n\r\n      // console.log('stack', stack)\r\n      for (var neighbor of list[nextNode]) {\r\n\r\n        // If the vertex is not visited, push each nodes to stack\r\n        if (!visited[neighbor]) {\r\n          stack.push(neighbor);\r\n          visited[neighbor] = true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction getReverseGraph(graph) {\r\n  var vertices = Object.keys(graph);\r\n  var reverseEdgeGraph = {};\r\n\r\n  for (let vertex of vertices) {\r\n    for (let neighbor of graph[vertex]) {\r\n      if (reverseEdgeGraph[neighbor]) {\r\n        reverseEdgeGraph[neighbor].push(vertex);\r\n      } else {\r\n        reverseEdgeGraph[neighbor] = [vertex];\r\n      }\r\n    }\r\n  }\r\n\r\n  return reverseEdgeGraph;\r\n}\r\n\r\nGraph.prototype.getStrongComponent = function(vertex) {\r\n\r\n  if (vertex && !this.list[vertex]) {\r\n    throw new(\"No vertex exsits\")\r\n  }\r\n\r\n  vertex = vertex ? vertex.toString() : Object.keys(this.list)[0].toString();\r\n\r\n  /*\r\n  Create Copy of current Adjacency list\r\n  */\r\n\r\n  var reverseEdgeGraph = getReverseGraph(this.list);\r\n  var stack = [];\r\n  var visited = {}\r\n  \r\n  for (var vertex in this.list) {\r\n    this.dfs(null, vertex, function(v) {\r\n      stack.push(v);\r\n    }, visited)\r\n  }\r\n \r\n  /**\r\n   *\r\n   * Create SCC\r\n   *\r\n   **/\r\n  var allSCC = [];\r\n  visited = {};\r\n  stack.reverse().forEach((vertex) => {\r\n    var SCC = []\r\n    this.dfs(reverseEdgeGraph, vertex, function(v) {\r\n      SCC.push(v);\r\n    }, visited)\r\n    if (SCC.length) allSCC.push(SCC)  \r\n  })\r\n  \r\n  return allSCC\r\n}\r\n\r\n\r\nfunction test() {\r\n  var graph = new Graph();\r\n  var result = [\r\n    [2, 4],\r\n    [4, 2],\r\n    [7, 5],\r\n    [5, 1],\r\n    [1, 7],\r\n    [1, 5],\r\n    [5, 7],\r\n    [7, 1],\r\n    [6, 3],\r\n    [3, 6],\r\n    [2, 7],\r\n    [1, 6]\r\n  ]\r\n  result.forEach(function(line) {\r\n    // console.log(line)\r\n    graph.insert(line[0], line[1]);\r\n  });\r\n\r\n  console.log('result => ', graph.getStrongComponent(1));\r\n}\r\n\r\n// dfs();\r\ntest(); // should be [ [ '1', '7', '5' ], ['2', '4'], [ 6, '3' ] ]```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "How to find connected components in graph with Ruby\r\n                \r\nWhat is the easiest way to find connected components of graph? Not strongly connected components which can be found with ```\nTSort```\n module. \n\nThere is a library ```\nRGL```\n which has a method in module ```\nRGL::Graph::each_connected_component```\n but how to build a graph and call this method for this graph?\n\nI have created sample graph like \n\n```\ng = RGL::DirectedAdjacencyGraph[1,2, 2,3, 4,5]\n```\n\n\nand want to find it's connected components, which are [[1,2,3],[4,5]] but there is no method ```\neach_connected_component```\n in ```\ng```\n\n\n```\nclass RGL::DirectedAdjacencyGraph\n  include RGL::Graph\nend\n```\n\n\ndid not help.\n    ", "Answer": "\r\nTwo things that might help (caveat: I do not know this gem well, and there may be better approaches)\n\n\nYou need to add a require to make the method available: ```\nrequire 'rgl/connected_components'```\n\n```\neach_connected_component```\n assumes an undirected graph, but you can convert a directed graph to an undirected one if necessary\n\n\nThe following code seems to do what you want:\n\n```\nrequire 'rgl/base'\nrequire 'rgl/adjacency'\nrequire 'rgl/connected_components'\n\ng = RGL::DirectedAdjacencyGraph[1,2, 2,3, 4,5]\n\ncomponents = []\n\ng.to_undirected.each_connected_component { |c| components <<  c }\n\np components\n\n# => [[3, 2, 1], [5, 4]]\n```\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Doing topological sort using strongly connected components to find cycles (digraph)\r\n                \r\nFrom the little I understand, one way of doing topological sorting if you have a readymade efficient black-box method for strongly connected components would be: \n\n(assumption - no self loops)\n\n\nrun strongly connected components\nif you have one or more components of size > 1 then this graph has cycles. \nelse (there are only 1 sized components in the graph) it's a DAG, congrats!\nif it's a DAG run topological sort, else complain that you can't do it. \n\n\nRegardless of efficiency, is the above a \"technically correct\" way to do topological sorting? \n\nI just want to make sure I understand things correctly. \n    ", "Answer": "\r\nYes, it's technically correct, because a digraph without self-loops is acyclic (i.e., topologically sortable) iff all strong components have size 1. The most common topological sorts do cycle detection as an easy byproduct, though.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Detecting All Simple Cycles In Strongly Connected Components(Complexity)\r\n                \r\nI am working with a specific graphical structure representing 2-player normal form games (game theory). I know that I can compute all strongly connected components of the directed graph in O(V+E) via Tarjans, but was wondering what the complexity of computing all of the simple cycles of a strongly connected component is? AND, if there is a known upper bound on the number of such simple cycles given the number of vertices defining the strongly connected component?\n\nI am looking for any literature/algorithms related to both of these problems. THANK YOU!\n    ", "Answer": "\r\nIs the graph directed or undirected? \nIn either case, the number of cycles can obviously be exponential in the number of nodes/ edges.  For example, in a complete graph, every single permutation of every possible size from 2 to n will result in a cycle.\n\nJohnson's algorithm for enumerating cycles (in directed graphs) seems to be one of the more efficient ones. Given that you are interested in the cycles of a strongly connected component, the implementation is even slightly easier than that described in the paper. The pseudocode in the paper is a little hard to read; this Ocaml implementation may be a little easier to process.  The algorithm has complexity O(n+e)(c+1), where c is the number of cycles in the graph.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Finding a strongly connected component with a desired node in it\r\n                \r\nGiven a directed graph, and one of the vertices ```\nx```\n,  I need to find a strongly connected component in the graph that includes ```\nx```\n.\nThe algorithm should be linear, and to use bfs only.\n    ", "Answer": "\r\nI don't know how this got to the top of my page after all this time but it's missing an answer, so...\n\nTo find the strongly connected component that contains a given node x, you can do a BFS from x to find all the nodes reachable from x.  Then reverse all the edges and do a BFS from x to find all the nodes reachable through reverse edges.  Those are all the nodes in the original graph from which x can be reached.\n\nThe intersection of those sets of nodes is the SCC that contains x.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "DFS strongly connected components dilemma\r\n                \r\nQuestion: Divide the set of vertices of the graph in Problem 1 into strongly connected components\n(SCC). Namely, specify which vertices are in the first strongly connected component, which\nin the second, and so on.\n\nis any one able to confirm ive done this correctly? namely when i reach vertex 4 i have the option to make the first SCC either 1,7,2,4,3 (as shown) or 1,7,2,4,6,5 depending on which way i choose to travel. Is there a method to this, or can i simply just choose?\n\n\n\norder: \n\n1,2,7,3,4,5,8,6\n\nSCC:\n\n1,7,2,4,3\n\n5\n\n8\n\n6\n    ", "Answer": "\r\nThe strongly connected component is {1,2,3,4,5,6,7}. If you don't get that, your algorithm (or your implementation) has a bug. There is a definition of Strongly Connected Component, and several well-known algorithms; both can be found easily in Wikipedia (and many other internet resources) and, most likely, in your textbook and/or course notes. (If you don't have course notes, you'll easily find some for similar courses.)\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Finding cliques or strongly connected components in Apache Spark using Graphx\r\n                \r\nA clique, C, in an undirected graph G = (V, E) is a subset of the vertices, C ⊆ V, such that every two distinct vertices are adjacent. This is equivalent to the condition that the subgraph of G induced by C is complete. In some cases, the term clique may also refer to the subgraph directly.\n\nSo, I am using GraphX with Apache-Spark. I read its documentation guide, and they provide a way to find out connected components in a graph, but not the cliques/strongly connected components. How can I do that using Scala? Thanks!\n\nEdit: As suggested in comments, a piece of code that I wrote in R for doing the same task is as follows: (The problem in using this code with Spark is that the recently released SparkR through which I can use R with Spark has limited support in terms of libraries (for example, igraph). Therefore, I started using GraphX and Scala) in which I now need the algorithm. \n\n```\nlibrary(igraph)\nfiles <- paste0(\"NP\",1:10,\".txt\") // Files which represent graphs\nfunc.clique <- function(file)\n{\n    w <- read.table(file)\n    g <- graph.edgelist(cbind(as.character(w$V1),as.character(w$V2)))\n    plot(g)\n    cli <- cliques(g)\n    return (cli)\n}\ncliquevalues <- sapply(files,func.clique)\n```\n\n    ", "Answer": "\r\nWe've recently used jgrapht, the same as mentioned by @marios above in comment. Sample code on how to use it, here Vertex is the custom Vertex class and cliques give you list of all cliques present in the graph:\n\n```\nimport org.jgrapht._\nimport org.jgrapht.graph._\nimport org.jgrapht.alg._\nimport scala.collection.JavaConverters._\nimport Util._\nimport Constants._\nimport Implicits._\n\nclass CliqueGraph(vertices:List[Vertex],xyEdges:List[(Vertex,Vertex)]){\n    val graph = new SimpleGraph[Vertex, DefaultEdge](classOf[DefaultEdge])\n    vertices.foreach(v=>graph.addVertex(v))\n    xyEdges.foreach{ case(v1,v2) =>\n            graphg.addEdge(v1,v2)\n    }\n    lazy val cliques= {\n        val c =  new BronKerboschCliqueFinder(graph)\n        val setVertices = c.getAllMaximalCliques().asScala\n        setVertices.toList\n    }\n}\n```\n\n\nIn you build.sbt file you need to import the library:\n\n```\nlibraryDependencies += \"org.jgrapht\" % \"jgrapht-dist\" % \"0.9.0\"\n```\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Tarjan's strongly connected components algorithm in python not working\r\n                \r\nI implemented the Tarjan's strongly connected components algorithm, according to wikipedia, in Python, but it isn't working. The algorithm is quite short and I cannot find any difference, so I cannot tell why it isn't working. I tried to check the original paper, but could not find it.\n\nHere is the code.\n\n```\ndef strongConnect(v):\n  global E, idx, CCs, c, S\n  idx[v] = (c, c) #idx[v][0] for v.index # idx[v][1] for v.lowlink\n  c += 1\n  S.append(v)  \n  for w in [u for (v2, u) in E if v == v2]:\n    if idx[w][0] < 0:\n      strongConnect(w)\n      # idx[w] = (idx[w][0], min(idx[v][1], idx[w][1])) #fixed, thx\n      idx[v] = (idx[v][0], min(idx[v][1], idx[w][1]))\n    elif w in S:\n      idx[v] = (idx[v][0], min(idx[v][1], idx[w][0]))\n  if (idx[v][0] == idx[v][1]):\n    i = S.index(v)\n    CCs.append(S[i:])\n    S = S[:i]\n\nE = [('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'E'), ('E', 'A'), ('A', 'E'), ('C', 'A'), ('C', 'E'), ('D', 'F'), ('F', 'B'), ('E', 'F')]\nidx = {}\nCCs = []\nc = 0\nS = []\nfor (u, v) in E:\n  idx[u] = (-1, -1)\n  idx[v] = (-1, -1)\nfor v in idx.keys():\n  if idx[v][0] < 0:\n    strongConnect(v)\n\nprint(CCs)\n```\n\n\nYou can check the graph visually if you prefer. As you can see this is a quite forward translation of the pseudocode in wikipedia. However, this is the output:\n\n```\n[['D', 'E', 'F'], ['B', 'C'], ['A']]\n```\n\n\nThere should be only one strongly connected component, not three. I hope the question is right in all its aspects, if not I'm sorry. In any case, thank you very much.\n    ", "Answer": "\r\nOk, I had some more time to think about this. I'm no longer certain that filtering the edges was the problem, as I previously stated. In fact, I think there's an ambiguity in the pseudocode; does ```\nfor each (v, w) in  E```\n mean for each edge (as the literal meaning of ```\nfor each```\n suggests), or only each edge beginning with ```\nv```\n, (as you reasonably assumed)? Then, after the for loop, is the ```\nv```\n in question the final ```\nv```\n from the ```\nfor```\n loop, as it would be in Python? Or does that go back to being the original ```\nv```\n? Pseudocode doesn't have clearly defined scoping behavior in this case! (It would be really weird if the ```\nv```\n at the end were to be the last, arbitrary, value of ```\nv```\n from the loop. That suggests that filtering is correct, because in that case, ```\nv```\n means the same thing all the way through.) \n\nHowever, under any circumstances, the clear error in your code is here: \n\n```\n  idx[w] = (idx[w][0], min(idx[v][1], idx[w][1]))\n```\n\n\nAccording to the pseudocode, that should definitely be\n\n```\n  idx[v] = (idx[v][0], min(idx[v][1], idx[w][1]))\n```\n\n\nOnce you make that change, you get the expected result. Frankly it doesn't surprise me that you made that mistake, because you're using a really weird and counterintuitive data structure. Here's what I think is an improvement -- it adds only a few more lines, and I find it to be much more readable. \n\n```\nimport itertools\n\ndef strong_connect(vertex):\n    global edges, indices, lowlinks, connected_components, index, stack\n    indices[vertex] = index\n    lowlinks[vertex] = index\n    index += 1\n    stack.append(vertex)\n\n    for v, w in (e for e in edges if e[0] == vertex):\n        if indices[w] < 0:\n            strong_connect(w)\n            lowlinks[v] = min(lowlinks[v], lowlinks[w])\n        elif w in stack:\n            lowlinks[v] = min(lowlinks[v], indices[w])\n\n    if indices[vertex] == lowlinks[vertex]:\n        connected_components.append([])\n        while stack[-1] != vertex:\n            connected_components[-1].append(stack.pop())\n        connected_components[-1].append(stack.pop())\n\nedges = [('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'E'), \n         ('E', 'A'), ('A', 'E'), ('C', 'A'), ('C', 'E'), \n         ('D', 'F'), ('F', 'B'), ('E', 'F')]\nvertices = set(v for v in itertools.chain(*edges))\nindices = dict((v, -1) for v in vertices)\nlowlinks = indices.copy()\nconnected_components = []\n\nindex = 0\nstack = []\nfor v in vertices:\n    if indices[v] < 0:\n        strong_connect(v)\n\nprint(connected_components)\n```\n\n\nHowever, I find the use of global variables here distasteful. You could hide this away in its own module, but I prefer the idea of creating a callable class. After looking more closely at Tarjan's original pseudocode, (which confirms that the \"filtered\" version is correct, by the way), I wrote this. It includes a simple ```\nGraph```\n class and does couple of basic tests:\n\n```\nfrom itertools import chain\nfrom collections import defaultdict\n\nclass Graph(object):\n    def __init__(self, edges, vertices=()):\n        edges = list(list(x) for x in edges)\n        self.edges = edges\n        self.vertices = set(chain(*edges)).union(vertices)\n        self.tails = defaultdict(list)\n        for head, tail in self.edges:\n            self.tails[head].append(tail)\n\n    @classmethod\n    def from_dict(cls, edge_dict):\n        return cls((k, v) for k, vs in edge_dict.iteritems() for v in vs)\n\nclass _StrongCC(object):\n    def strong_connect(self, head):\n        lowlink, count, stack = self.lowlink, self.count, self.stack\n        lowlink[head] = count[head] = self.counter = self.counter + 1\n        stack.append(head)\n\n        for tail in self.graph.tails[head]:\n            if tail not in count:\n                self.strong_connect(tail)\n                lowlink[head] = min(lowlink[head], lowlink[tail])\n            elif count[tail] < count[head]:\n                if tail in self.stack:\n                    lowlink[head] = min(lowlink[head], count[tail])\n\n        if lowlink[head] == count[head]:\n            component = []\n            while stack and count[stack[-1]] >= count[head]:\n                component.append(stack.pop())\n            self.connected_components.append(component)\n\n    def __call__(self, graph):\n        self.graph = graph\n        self.counter = 0\n        self.count = dict()\n        self.lowlink = dict()\n        self.stack = []\n        self.connected_components = []\n\n        for v in self.graph.vertices:\n            if v not in self.count:\n                self.strong_connect(v)\n\n        return self.connected_components\n\nstrongly_connected_components = _StrongCC()\n\nif __name__ == '__main__':\n    edges = [('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'E'),\n             ('E', 'A'), ('A', 'E'), ('C', 'A'), ('C', 'E'),\n             ('D', 'F'), ('F', 'B'), ('E', 'F')]\n    print strongly_connected_components(Graph(edges))\n    edge_dict = {'a':['b', 'c', 'd'],\n                 'b':['c', 'a'],\n                 'c':['d', 'e'],\n                 'd':['e'],\n                 'e':['c']}\n    print strongly_connected_components(Graph.from_dict(edge_dict))\n```\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "GC overhead error in scala while computing strongly connected components of graph\r\n                \r\nCan somone please look at this scala code and tell me why it throws the GC error when I call convertPass2?  It occurs in the second preprocess call on an array that is the same size as the one in the first call.  It computes strongly connected components using Kosaraju's algorithm.  I suspect that it is garbage collecting either \"Gfirst\", or \"times\" arrays before I want it to.\n\nThe input is a file containing the edges of the graph separated by a space.  Due to the low density of the graph, the edge list is converted to an adjacency list representation.\n\nPlease let me know if you need clarificaton.  Many thanks.\n\n```\npackage algorithms4\n\nimport scala.io.Source\nimport scala.util.Sorting\n\nobject SCC {\n    //Note this is Grev\n    def preprocess(in: Array[Array[Int]]): Map[Int,List[Int]]={\n      println(in.length)\n      println(\"enter preprocess\")\n      val fir = in.groupBy(_.apply(1)).map(\n          pair => (pair._1, \n              pair._2.tail.foldLeft(List(pair._2.head.apply(0)))((a, xs) => xs.apply(0)::a)\n              )\n          )\n       /*println(\"begin computing singles\")\n       val singles = for{\n         k <- (1 to 875714).toSet diff fir.keySet \n       } yield (k, List())\n       fir ++ singles*/\n       fir\n      //in.foldLeft(Map((in.head.apply(0),in.head.apply(1))))((a, xs) => a+(xs.apply(0), xs.apply(1)))\n\n    }\n    def convertPass2(in: Array[Array[Int]], times: Array[Int]): Map[Int, List[Int]]={\n      val edges = for{\n        pair <- in\n      } yield Array(times(pair.apply(1)), times(pair.apply(0)))\n      println(edges.length)\n      preprocess(edges)\n    }\n\n\n\n    def DFS_loop1(G: Map[Int, List[Int]]) ={\n        var t = 0\n        //println(\"GSIZE\")\n        //println(G.size)\n        //val itr = G.keysIterator\n        val times = new Array[Int](875714+1)\n        val explored = new Array[Boolean](875714+1)\n        for (i <- 875714 to 1 by -1){\n          if (!explored(i)){\n            def DFS1(i:Int): Unit={\n              explored(i) = true\n             if(G.contains(i)){\n                 for(j <- G(i)){\n                   if (!explored(j)){\n                    DFS1(j)\n                   }\n                 }\n             }\n             t+=1\n             times(i) = t\n            }\n            DFS1(i)\n          }\n        }\n        times\n    }\n    def DFS_loop2(G: Map[Int, List[Int]]): Array[Int] ={\n        val leader = new Array[Int](G.size+1)\n        val explored = new Array[Boolean](875714+1)\n\n        var s = 0\n        for (i <- G.size-1 to 1 by -1){\n          if (!explored(i)){\n            s = i\n            def DFS2(i:Int): Unit={\n             leader(i) = s\n             explored(i) = true\n             if(G.contains(i)){\n                 for(j <- G(i)){\n                   if (!explored(j))\n                     DFS2(j)\n                 }\n             }\n            }\n            DFS2(i)\n          }\n        }\n        leader\n    }\n    def computeSCC(leaders: Array[Int]) ={\n      val leadersMap = (1 to leaders.length-1).toList.groupBy(\n          i => leaders(i)\n       )\n       leadersMap.keySet.groupBy(\n         leader => leadersMap.apply(leader).length \n       )\n    }\n}\n\nobject Main extends App {\n  val scc = SCC\n  def source = Source.fromFile(\"SCC.txt\")\n  def Gfirst = source\n  .getLines.toArray\n  .map(e => e.split(\"\\\\s\").map(c => c.toInt))\n  source.close\n\n   println(Gfirst.length)   \n      //.map(e => List(List(e.head), e.tail))*/\n   val G = scc.preprocess(Gfirst)\n   println(G.apply(1))\n   println(G.apply(2))\n   println(G.size)\n   val times = scc.DFS_loop1(G)\n\n   val G2 = scc.convertPass2(Gfirst, times)\n\n\n}\n```\n\n\nAnd the output:\n\n```\n5105043\n5105043\nenter preprocess\nList(860482, 851820, 846832, 832536, 827774, 801801, 776406, 758955, 758952, 734309, 734061, 732157, 707710, 707709, 699074, 693575, 692316, 675019, 664635, 637921, 637920, 601113, 572229, 572219, 541482, 540151, 535063, 535062, 495884, 461693, 448071, 429291, 415833, 395686, 395685, 395684, 395683, 395682, 395681, 395680, 395679, 395678, 395677, 386605, 361757, 361755, 361754, 361753, 361752, 361751, 361750, 361749, 361748, 361747, 361746, 361745, 361744, 361743, 361742, 348061, 348060, 348059, 348058, 348057, 348056, 348055, 348054, 348053, 348052, 348051, 348050, 348048, 348047, 348046, 348045, 348044, 348042, 348041, 348040, 348039, 348037, 348034, 348033, 348032, 348031, 347563, 347562, 347561, 347559, 347557, 320270, 320269, 318620, 313976, 313160, 307630, 307629, 307628, 307627, 307625, 307624, 307622, 303372, 303371, 303370, 303369, 303368, 297779, 280871, 280787, 240432, 224091, 212295, 212294, 212293, 212292, 212291, 212290, 212288, 212287, 212286, 212285, 212284, 212283, 212282, 176667, 176664, 176663, 176662, 176661, 176660, 176659, 176658, 176657, 171188, 171182, 171179, 171178, 171177, 171176, 171175, 171172, 171170, 171169, 171168, 133568, 124673, 124672, 115401, 115399, 115355, 115342, 115336, 115314, 110442, 110441, 110440, 110439, 110438, 110437, 104822, 104821, 104820, 104819, 104818, 104817, 104815, 104814, 104813, 104812, 104809, 104791, 104790, 104789, 104788, 104787, 104786, 104784, 104783, 104782, 104772, 88665, 88664, 71113, 53211, 53206, 3121, 36, 35, 34, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 20, 19, 18, 17, 16, 13, 12, 10, 8, 7, 6, 5, 1)\nList(1)\n714547\n5105043\n5105043\nenter preprocess\n\nException in thread \"main\" java.lang.OutOfMemoryError: GC overhead limit exceeded\nat scala.collection.immutable.HashMap$HashTrieMap.updated0(HashMap.scala:328)\nat scala.collection.immutable.HashMap$HashTrieMap.updated0(HashMap.scala:326)\nat scala.collection.immutable.HashMap$HashTrieMap.updated0(HashMap.scala:326)\nat scala.collection.immutable.HashMap.$plus(HashMap.scala:57)\nat scala.collection.immutable.HashMap.$plus(HashMap.scala:36)\nat scala.collection.mutable.MapBuilder.$plus$eq(MapBuilder.scala:28)\nat scala.collection.mutable.MapBuilder.$plus$eq(MapBuilder.scala:24)\nat scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:244)\nat scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:244)\nat scala.collection.immutable.HashMap$HashMap1.foreach(HashMap.scala:224)\nat scala.collection.immutable.HashMap$HashTrieMap.foreach(HashMap.scala:403)\nat scala.collection.immutable.HashMap$HashTrieMap.foreach(HashMap.scala:403)\nat scala.collection.immutable.HashMap$HashTrieMap.foreach(HashMap.scala:403)\nat scala.collection.immutable.HashMap$HashTrieMap.foreach(HashMap.scala:403)\nat scala.collection.TraversableLike$class.map(TraversableLike.scala:244)\nat scala.collection.AbstractTraversable.map(Traversable.scala:105)\nat algorithms4.SCC$.preprocess(SCC.scala:14)\nat algorithms4.SCC$.convertPass2(SCC.scala:40)\nat algorithms4.Main$delayedInit$body.apply(SCC.scala:133)\nat scala.Function0$class.apply$mcV$sp(Function0.scala:40)\nat scala.runtime.AbstractFunction0.apply$mcV$sp(AbstractFunction0.scala:12)\nat scala.App$$anonfun$main$1.apply(App.scala:71)\nat scala.App$$anonfun$main$1.apply(App.scala:71)\nat scala.collection.immutable.List.foreach(List.scala:318)\nat scala.collection.generic.TraversableForwarder$class.foreach(TraversableForwarder.scala:32)\nat scala.App$class.main(App.scala:71)\nat algorithms4.Main$.main(SCC.scala:111)\nat algorithms4.Main.main(SCC.scala)\n```\n\n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Finding fully connected components?\r\n                \r\nI'm not sure if I'm using the right term here, but for fully connected components I mean there's an (undirected) edge between every pair of vertices in a component, and no additional vertices can be included without breaking this property.\n\nThere're a number algorithms for finding strongly connected components in a graph though (for example Tarjan's algorithm), is there an algorithm for finding such \"fully connected components\"?\n    ", "Answer": "\r\nWhat you are looking for is a list of all the maximal cliques of the graph. It's also called the clique problem. No known polynomial time solution exists for a generic undirected graph.\n\n\n  Most versions of the clique problem are hard. The clique decision problem is NP-complete (one of Karp's 21 NP-complete problems). The problem of finding the maximum clique is both fixed-parameter intractable and hard to approximate. And, listing all maximal cliques may require exponential time as there exist graphs with exponentially many maximal cliques. Therefore, much of the theory about the clique problem is devoted to identifying special types of graph that admit more efficient algorithms, or to establishing the computational difficulty of the general problem in various models of computation.\n\n\n-https://en.wikipedia.org/wiki/Clique_problem \n\nI was also looking at the same question. \n\nhttps://en.wikipedia.org/wiki/Bron-Kerbosch_algorithm This turns out to be an algorithm to list it, however, it's not fast. If your graph is sparse, you may want to use the vertex ordering version of the algorithm:\n\n\n  For sparse graphs, tighter bounds are possible. In particular the vertex-ordering version of the Bron–Kerbosch algorithm can be made to run in time O(dn3d/3), where d is the degeneracy of the graph, a measure of its sparseness. There exist d-degenerate graphs for which the total number of maximal cliques is (n − d)3d/3, so this bound is close to tight.[6]\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Strongly Connected Components Quastion\r\n                \r\nIf you don't know how SCC algorithm works read this article: https://www.hackerearth.com/practice/algorithms/graphs/strongly-connected-components/tutorial/ (This is the best article I could find).\nAfter finding finish time for each node, we reverse the original graph and start to run DFS from highest time node. What if we start to run DFS from smallest node in the original graph? Why it doesn't work?\n    ", "Answer": "\r\nThats because the first DSF's finish times give you the topological order (which means one edge depends on another).\nSCC means the every nodes are reachable from every other nodes in the component.\nIf you start from the smallest node (so backward) the algorithm will give false result, because in the transposed graph somewhere it wont find a way between two nodes which actually connect, or find an incorrect way because you 'walk throught' a node before its 'parent'.\nSimple example (```\n->```\n means depend on). Start from X the topological order: X,Y,Z,W\n```\nX -> Y   ->  Z\n^   /\n \\ ˘\n  W\n```\n\nIf you transpose the one above and start from Z, it will look like the whole graph is one SCC. But it is not. You must process the parent element before child. So if you start from X you cannot go into Z in the original graph before Y, also cannot go into W before Y. In the transposed graph there are a route between Z and Y but you can only use it if the invere was there in the original graph. And TO describe that there was or wasnt it. If a node topologically preceed another route and there is a route in the transposed graph between them then they strongly connected.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Finding no. of strongly connected components - wrong answer by my code\r\n                \r\nI was trying to find no. of strongly connected components in a graph. I wrote the below algo but it is failing. The count variable stores the no.of connected components. Count variable is incremented:\n\nwhen any unvisited vertex is found (line 1 in code) and then for that vertex dfs is performed\nwhen no edge going out of the subtree with the lowest arrival time lower than the arrival time of the vertex itself is found (line 2 in code)\n\nI have tried to comment my code. Please tell where I am wrong.\n```\n    int noOfStronglyConnectedComp(int V, vector<int> adj[])\n    {\n        vector<bool> visited(V,false);\n        vector<int> arr(V);    //arrival time of a vertex: when a vertex is first reached\n        int timer=0;           //allocated to arrival time\n        int count=0;           //stores no. of connected components\n        for(int i=0;i<V;i++)\n        {\n            if(!visited[i])\n               { \n                   count++;  //line 1\n                   dfs(i,adj,visited,arr,timer,count,i);\n               }\n        }\n        return count;\n        \n    }\n    int dfs(int source,vector<int> adj[], vector<bool> &visited,vector<int> &arr, int &timer, int &count,int parent)\n    {\n        visited[source]=1;        //node marked visited\n        arr[source]=timer++;      //arrival time is set\n        int lowest=arr[source];   //lowest stores the edge going out of the subtree with the lowest arrival time\n        for(int i=0;i<adj[source].size();i++)\n            {\n                if(!visited[adj[source][i]])\n                    lowest=min(lowest,dfs(adj[source][i],adj,visited,arr,timer,count,parent));\n                else\n                    lowest=min(lowest,arr[adj[source][i]]);\n            }\n        if(lowest==arr[source] && source!=parent) \n        count++;    //line 2\n        return lowest;    \n    }\n```\n\n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "In a directed graph, why are finish times used instead of discovery time to determine Strongly Connected Components?\r\n                \r\nIn finding strongly connected components for a directed graph, we use the finish times in the reverse graph for the order. Why can we not use the discovery times in decreasing order? To me, they seem very similar and both could be used. However, in all the logic I found, they only use finish times.\nIs there any example that shows that it does not work using discovery time?\n    ", "Answer": "\r\nPer Wikipedia, the key invariant is \"if there is a forward path from u to v then u will appear before v\". This suggests that we look for a graph where the discovery time violates this. For example, in the graph\n```\n  _________\n /        _\\|\na---->b---->c\n```\n\nwe might visit ```\na```\n then ```\nc```\n then ```\nb```\n, even though there is a path from ```\nb```\n to ```\nc```\n. Then we traverse the transpose graph and find the \"strongly connected components\" ```\n{a}```\n and then ```\n{c, b}```\n because there's an arc from ```\nc```\n to ```\nb```\n.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "In a directed graph, why are finish times used instead of discovery time to determine Strongly Connected Components?\r\n                \r\nIn finding strongly connected components for a directed graph, we use the finish times in the reverse graph for the order. Why can we not use the discovery times in decreasing order? To me, they seem very similar and both could be used. However, in all the logic I found, they only use finish times.\nIs there any example that shows that it does not work using discovery time?\n    ", "Answer": "\r\nPer Wikipedia, the key invariant is \"if there is a forward path from u to v then u will appear before v\". This suggests that we look for a graph where the discovery time violates this. For example, in the graph\n```\n  _________\n /        _\\|\na---->b---->c\n```\n\nwe might visit ```\na```\n then ```\nc```\n then ```\nb```\n, even though there is a path from ```\nb```\n to ```\nc```\n. Then we traverse the transpose graph and find the \"strongly connected components\" ```\n{a}```\n and then ```\n{c, b}```\n because there's an arc from ```\nc```\n to ```\nb```\n.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "why doesn't increasing order of the post no gives sink (node in strongly connected sink component of the corresponding DAG of graph) node in graph?\r\n                \r\nReading about the graphs.. it is said that every graph is the DAG directed acyclic graph of its strongly connected components. Therefore inorder to find these strongly connected components one need to find the node in the sink part of the graph.. now to explain further I need to explain post no and pre no..\n\npre no :- A preordering is a list of the vertices in the order that they were first visited by the depth-first search algorithm. therefore its corresponding pre no.\n\nSimilarly \npost no :- A postordering is a list of the vertices in the order that they were last visited by the algorithm DFS.\nits corresponding post no\n\nnow the highest post gives source node(true understand)\nbut why not the increasing order of the post no gives sink part ?\n\nmy doubt is :-\nwhy we need to reverse the graph to find sinks thereby finding connected components.\nwhy not in the same graph we run an algo inorder of it increasing post no (as lowest post no reside in sink conected component)..\n\nWhy do we need to reverse the graph? \n    ", "Answer": "\r\nBecause the lowest post number can even be in the source SCC. Imagine the source SCC (SCC1) being a ring/loop of 3 nodes, a,b&c, where an edge connects a to another SCC (SCC2) which we don't need to know the details of. a,b,&c have no other edges. If the DFS goes from a to b to c then traverses the edge from a to SCC2. In this case, the lowest postnumber in the graph is that of c, which is clearly a source SCC node and not a sink SCC node.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Finding arcs between strongly connected components\r\n                \r\nHaving a graph and all of it's strongly connected components, I was wondering what the most efficient way to find arcs that connect two SCC. All the solutions I found involve running through all the nodes, and I was wondering if there was a way to do it without having done that, in particular, during the Tarjan algorithm I used to find SCC's in the graph. ANyway to do it in a linear fashion?\n\nThank you very much!\n    ", "Answer": "\r\nJust make connections between different vertices a pointer and change the value of each vertice of a given SCC to the same value. \n\nThat way you don't have to \"search\" anything.\n\n```\nEx: 1->2->3->4->1\n```\n\n\nThat way u get an SCC that contains 1234\n\n```\nthen 4->5\nand 5->6->7->5\n```\n\n\nIf you store the connections as pointers u just need to change the value 5 in the vertice 5 to a 6 and then go to the pointer from 4 to 5 u get a 6.\nI am not being very clear hope u get the idea. \n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "I can not really understand how the strongly connected component algorithm works\r\n                \r\nThe strongly connected component algorithm from my book:\n\nstrongly-connected-component(G)\n\n\ncall DFS(G) to compute finishing times f[u] for each vertex u\ncompute Transpose(G)\ncall DFS(Transpose(G)), but in the main loop of DFS, consider the vertices in order of decreasing f[u] (as computed in line 1)\noutput the vertices of each tree in the depth-first forest of step 3 as a separate strong connected component\n\n\nI do not really understand how line 4 works, how the algorithm makes the forest from the DFS on the transpose graph. I do understand why to call both times to DFS.\n\nThanks for any help.\n    ", "Answer": "\r\nThe DFS main loop calls a recursive helper function on each vertex to explore the vertices reachable from that vertex. A \"tree\" here is the set of vertices newly visited by one of these recursive calls. The helper function must be modified to construct this set, which is a strong component whenever it is nonempty.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Strongly Connected Components\r\n                \r\nI got a problem, my output is not correct\n```\n\nimport java.util.*;\nimport java.util.Scanner;\nimport java.util.ArrayList;\n\nclass StronglyConnectedComponents {\n    int V;  //number of nodes\n    ArrayList<Integer> adj[];   //adjacenty list\n    int time;\n\n    StronglyConnectedComponents(int v) {\n        this.V = v;\n        this.time = 0;\n        this.adj = new ArrayList[v];\n        Arrays.fill(adj, new ArrayList());  //adj list of v elements(arrayLists)\n\n    }\n\n    void addEdge(int v, int w) {\n        adj[v].add(w);\n    }\n\n    void util(int u, int low[], int disc[], int stackMember[], Stack<Integer> st) {\n        stackMember[u] = 1; //visited\n        disc[u] = time;  //first time visiting time\n        low[u] = time++;  //after update time +1\n        st.push(u);  //dfs - take last added as first observal vertex\n\n        for (Integer i : adj[u]) { //traversing adjacents of u\n            if (disc[i] == -1) {\n                util(i, low, disc, stackMember, st);\n                if (low[u] > low[i]) low[u] = low[i];  //update If node v is not visited\n            } else if (stackMember[i] != 0)  //if i is still in stack update value\n            {\n                if (low[u] > disc[i]) low[u] = disc[i];\n            }\n        }\n\n        int w = -1;\n        if (low[u] == disc[u]) {\n            while (w != u) //while there is a path\n            {\n\n                w = (int) st.pop();\n                stackMember[w] = 0;\n                System.out.print(w + \" \");\n\n            }\n            System.out.println();\n        }\n\n\n    }\n\n    void SCC() {\n        //first time all vertices has no parent, therefore fill with -1\n        int disc[] = new int[V];\n        Arrays.fill(disc, -1);\n        int low[] = new int[V];\n        Arrays.fill(low, -1);\n\n        int stackMember[] = new int[V];\n        Stack<Integer> st = new Stack<Integer>();\n        //all vertices not visited filling\n        for (int i = 0; i < V; i++) {\n            if (disc[i] == -1)//if not visited vertex\n                util(i, low, disc, stackMember, st);\n        }\n\n    }\n\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"Enter the number of nodes\");\n        int n = sc.nextInt();\n        System.out.println(\"Enter the number of edge\");\n        int m = sc.nextInt();\n        m++;\n        StronglyConnectedComponents g = new StronglyConnectedComponents(n);\n        System.out.println(\"Enter the edges:\");\n\n        while (m-- > 0 && sc.hasNext()) {\n            String[] input = sc.nextLine().split(\" \");\n            if (input.length == 2) {\n                g.addEdge(Integer.parseInt(input[0]), Integer.parseInt(input[1]));\n            }\n        }\n        g.SCC();\n\n    }\n}\n```\n\nMy input:\n```\nEnter the number of nodes\n5\nEnter the number of edge\n5\nEnter the edges:\n1 0\n0 2\n2 1\n0 3\n3 4\n```\n\nmy output:\n```\n4 3 1 2 0 \n```\n\nOutput should be like this:\n```\n0 1 2\n3\n4\n```\n\nI dont even know why there is mistake like this. I changed code from  https://www.geeksforgeeks.org/tarjan-algorithm-find-strongly-connected-components/ to my code, and added opportunity to input.\nI asked about this and one friend said that \"this is the output of both codes in the addEdge method after adding w, in your code w is added to all elements, and in the original only to the graph v\"\nbut i dont know how to do it\n    ", "Answer": "\r\nThe problem is in the line where you initialize the Lists for your adj-Array:\n```\nArrays.fill(adj, new ArrayList());\n```\n\n\nWhen we take a look at the Java-Documentation we read the following for the method ```\npublic static void fill​(Object[] a, Object val)```\n from Arrays:\n\nAssigns the specified Object reference to each element of the specified array of Objects.\n\nThis means all of the entries in your adj-Array use the same list. In your example every node is at least one time on the right side, and therefore every node is in this one list.\n\nWhen you replace the line above with a simple for loop to initialize the ArrayLists for the adj-Array, it should work.\n```\nfor(int i = 0; i < adj.length; i++) {\n  adj[i] = new ArrayList<>();\n}\n```\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Find all sets of strongly-connected vertices\r\n                \r\nI have a linked-list of edges to a digraph which I am trying to find all sets of strongly-connected components. Can anybody point me toward an algorithm with a good worst-case time (sample pseudo or C code would be much appreciated).\n\nEDIT: I am trying to find all sets of edges that create strongly-connected components and not the vertices. In the graph below notice that there are 2 sets of edges to create a strongly-connected component, however only two edges on the graph are used for both (a->b and b->c). The algorithm should be able to produce sets { a->b, b->c, c->a } and { a->b, b->c, c->b, b->a }.\n\nhttp://img521.imageshack.us/img521/8025/digraph.jpg\n\nHope that helps make more clear my goal.\n\nEDIT2: I have a semi working implementation, however I noticed that it doesn't work if the graph which I am searching in is also strongly connected. Does anybody know of a way to find SCC within a SCC?\n    ", "Answer": "\r\nThe Strongly connected component definition on wikipedia recommends three algorithms. I would go with Tarjan's as the best combination of efficiency and ease of implementation.\n\nI've taken the Pseudo-code on wikipedia, and modified to keep a list of all SCCs. It follows:\n\n```\nInput: Graph G = (V, E)\n\nList<Set> result = empty\nindex = 0                                   // DFS node number counter \nS = empty                                   // An empty stack of nodes\nfor all v in V do\n  if (v.index is undefined)                 // Start a DFS at each node\n    tarjan(v, result)                       // we haven't visited yet\n\nprocedure tarjan(v, result)\n  v.index = index                           // Set the depth index for v\n  v.lowlink = index                               \n  index = index + 1\n  S.push(v)                                 // Push v on the stack\n  for all (v, v2) in E do                   // Consider successors of v\n    if (v2.index is undefined)              // Was successor v' visited?\n      tarjan(v2, result)                    // Recurse\n      v.lowlink = min(v.lowlink, v2.lowlink)\n    else if (v2 is in S)                   // Was successor v' in stack S? \n      v.lowlink = min(v.lowlink, v2.index) // v' is in stack but not the dfs tree\n  if (v.lowlink == v.index)                // Is v the root of an SCC?\n    set interconnected = empty\n    previous = v\n    repeat\n      v2 = S.pop                                  \n      interconnected.add((previous,v2)) // record this edge\n      last = previous=v2\n    until (v2 == v)\n    result.add(interconnected)\n```\n\n\n\n\nEdit in response to further specification.\nDo you see that the algorithm pushes the vertices onto the stack then pops them off again? I think this probably means that you can know that each consecutive stack element is connected to the one before by an edge. I've modified the pseudo-code above to reflect this, (but haven't tried it).\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "javascript equivalent of MATLAB for finding strongly connected components in a binary image\r\n                \r\nI am writing a prototype of an image manipulation program in MATLAB and am hoping to port it to javascript once the prototyping phase is done.\n\nI am not very familiar with javascript but there seem to be many image processing libraries available so my guess is most of the basic image manipulation functions I use in MATLAB are already implemented somewhere. However one of the more powerful functions I am using in MATLAB is called \"regionprops\", basically it figures out the strongly connected components of a binary image and outputs a bunch of stats pertaining to each \"component\", such as the area, the bounding box, the barycenter, etc.\n\nWhat is the shortest way (i.e. with minimal implementation on my part) to having this available in js ? As a last resort I will convert the image to a graph in order to use a strongly-connected-component lib, if I can avoid this (and the subsequent image-related calculations) I would like to know.\n\nPointers to docs and libs are much appreciated ! Thanks, Tepp.\n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "define strongly connected components\r\n                \r\nI have code for testing strongly connected components for graphs, and i have example of vertices and edges connection from this site: http://www.mathworks.com/help/toolbox/bioinfo/ref/graphconncomp.html\n\nI have copied input data there\n\n```\n   (2,1)        1\n   (1,2)        1\n   (3,2)        1\n   (2,3)        1\n   (9,3)        1\n   (3,4)        1\n   (5,4)        1\n   (7,4)        1\n   (4,5)        1\n   (9,5)        1\n   (1,6)        1\n   (7,6)        1\n   (6,7)        1\n   (1,8)        1\n   (9,8)        1\n   (8,9)        1\n   (9,10)       1\n```\n\n\nHere 10 vertex and 17 edges,what question is that it is from matlab where index is 1, and I want to write code in C++, and how changes vertex list? Or what could i do? Please help me, for clarification i am not asking about code, just changing from 0 based matrix to 1 based matrix, please help me.\n    ", "Answer": "\r\nMATLAB uses 1-based array indexing (the first element of the array has index 1), and C/C++ use 0-based indexing (the first element of the array has index 0).\n\nSo if you want to use the graph that is represented in MATLAB as in your post, but in C/C++, you would just need to subtract 1 from each of the indices - so for example, (2,1) would become (1,0) and (9,5) would become (8,4).\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Scala - Computing strongly connected components - stack overflow error\r\n                \r\nI am currently following Tim Roughgarden's Algorithms specialisation on Coursera and the module 2, week 1 assignment involves calculating the size of strongly connected components in a graph. I can compute them for smaller size graphs but the problem question has ~ 5 million edges. I got a solution working fairly quickly but have spent hours trying to get it to run on the full set, short of me buying some time on an AWS super computer, could anyone help me to find a way around this stack overflow error?\n\nI have left off the pre-processing step where I get the array into an adjacency list and pass it into the master_dfs in the correct order.\n\n```\nimport scala.io.Source\n\nobject Main extends App {\n\n  def dfs(adjList: Map[Int, List[Int]], currentNode: Int,\n          foundNodes: Set[Int], finishingTime: List[Int]): (Set[Int], \n                                                           List[Int]) = {\n\n    val foundsWithCurrent: Set[Int] = foundNodes + currentNode\n\n    val edges: List[Int] = adjList(currentNode)\n\n    val crossOver: List[Int] = edges.filterNot(node => \n                                       foundNodes.contains(node))\n\n    if (crossOver.nonEmpty) {\n       val (nextStepFinds, nextStepFinishers) = \n          dfs(adjList, crossOver.head, foundsWithCurrent, finishingTime)\n\n       dfs(adjList, currentNode,\n          nextStepFinds, nextStepFinishers)\n    }\n\n    else (foundsWithCurrent, currentNode :: finishingTime)\n\n    }\n\n\n  def master_dfs(orderOfExecution: List[Int], adjList: Map[Int, \n    List[Int]], foundNodes: Set[Int], finishedList: List[Int], sccs: \n    List[List[Int]]): (Set[Int], List[Int], List[List[Int]]) = {\n\n    val (foundThisPass, finishers) = dfs(adjList = adjList,\n      currentNode = orderOfExecution.head, foundNodes = foundNodes, \n      finishingTime = finishedList)\n\n    val scc: List[Int] = finishers.filterNot(node => \n    finishedList.contains(node))\n\n    val leftToExecute = orderOfExecution.filterNot(node => \n    foundThisPass.contains(node))\n\n    if (leftToExecute.isEmpty) {\n        (foundThisPass, finishers, scc :: sccs)\n      }\n\n    else {\n       master_dfs(orderOfExecution = leftToExecute, adjList = adjList,\n       foundNodes = foundThisPass, finishedList = finishers, sccs = \n                                   scc :: sccs)\n      }\n\n  }\n```\n\n    ", "Answer": "\r\nSince stack space is limited in most languages, you always need to think about how much of it you're going to use when you implement an algorithm recursively.\n\nImplementing DFS recursively is OK on trees or DAGs when you know that search depth, i.e the maximum path length to any node, is limited.\n\nOn general directed or undirected graphs, however, the longest path in the graph may include a large proportion of the vertexes in the graph, and the call depth of a recursive DFS implementation can be as long as that path.  That can cause a stack overflow for large inputs.\n\nWhen you don't know for certain that all the input graphs will be shallow enough to be safe, you should implement the DFS iteratively using a stack object instead of recursively using the call stack.\n\nSince a stack object doesn't have the same limitations that the call stack does, the iterative implementation can handle much larger inputs.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "I understand 2 SAT can be solved in Polynomial time finding out Strongly Connected Components. What about doing the same for 3SAT?\r\n                \r\nIn case of 3SAT instead of getting 2 implications for one clause, we'd get 12(3C2*2*2) maybe.and which will form a graph of 12m edges when m is the number of clauses in 3 CNF and we can still find out the Strongly Connected Components in that resultant graph. What is wrong in this statement which makes 3 SAT a P problem? eg.\n\n```\n(a+b) = (-a->b).(-b->a)\n(a+b+c) = (-a->(b+c)).(-(b+c)->a).....4 more like this\n        = (-a ->((-b->c).(-c->b)))....2 for each like this\n```\n\n    ", "Answer": "\r\nUnfortunately, ```\n3-SAT```\n cannot be expressed in ```\n2-SAT```\n, so it cannot be as simple as in 2-SAT.\n\nHowever, there exist many works related to searching a polynomial-time algorithm for 3-SAT.\nThe idea is to find criteria that can make the 3-SAT instance \"Fixed-Parameter Trackable\" (FPT).\n\nI can recommend you the article On Fixed-Parameter Tractable Parameterizations of SAT by Stefan Szeider where there is a passage about seeing the SAT instance as a graph and searching a parameter in the graph to make the SAT problem trackable.\n\nYou can find more information about FPT here: https://en.wikipedia.org/wiki/Parameterized_complexity\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "How to build an array to present relationship of nodes in strongly connected component?\r\n                \r\nFor directed graph G(V, E) with n nodes, I want to create an integer array a, and its length is n. If there is a path from node 1 to 2, then ```\na[1] <= a[2]```\n, if they are in the same strongly connected component ```\na[1] = a[2]```\n, if if there is no path from node 2 to 3, we have ```\na[2] > a[3]```\n.\n\nI think the time complexity should be O(n + m), because the time complexity of seeking strongly connected component is it. But I am not sure how to output an array for it, could anybody help? Thanks.\n    ", "Answer": "\r\nOnce you have found every strongly connected components (SCC) of a graph, you can build the condensation of the graph by contracting each SCC into a single vertex. The condensation is a directed acyclic graph in which you can number the vertices using topological sorting. Every step has linear complexity.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Using Strongly Connected Components Algo as Cycle Detection\r\n                \r\nI understand that if a set of vertices are part of strongly connected components, then all those vertices within the component can reach one another; a cycle.  \n\nNow, I would like to use this fact and claim that if a graph G = (V,E) has a cycle, then that cycle MUST BE inside scc.  \n\nIn other words, all cycles must be part of scc (my claim). \n\nI cant think of any counterexample to my claim, so I would like to know if there are any cycles in a graph that are not part of scc.\nOr\nIs my claim, correct? \n    ", "Answer": "\r\nIt's correct. If a set of vertices are in a cycle, then they are all reachable from each other (by going around the cycle), so they are an SCC by definition.\n\nHaving said that, it's not exactly a programming problem :)\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Finding strongly connected components - no recursion\r\n                \r\nI need to find strongly connected components of a directed graph.\nI've decided to use Tarjan's algorithm. So far so good.\nHowever, the dataset I need my program to operate on is huge and I get stackoverflow exception. I can't increase the stack size so I need to find another solution.\n\nI could change the recursive algorithm to iterative but I was wondering if there's \"a cleaner solution\".\n\nI guess not but I'd like to be sure before I start implementing the iterative version.\n\nThanks for any suggestions!\n    ", "Answer": "\r\nKnown algorithms for finding SCC are all based on DFS, which is recursive in nature, so you've basically got these options:\n\n\nlive with the recursion. Not really an option, recursion for every node will fill the stack quickly\nrewrite recursion with iteration, provide your own stack for the DFS. Not that hard, I'd recommend this one\ninvent a non-recursive algorithm. Good luck in that case\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Finding the number of strongly connected components\r\n                \r\nI have wrote this code for finding the number of SCC (strongly connected components):\n```\n#include <iostream>\n#include <vector>\nusing namespace std;\nint n , m;\nvector<vector<int>>G(101) , GT(101);\n\nvoid read()\n{\n    //n = number of nodes , m = number of edges.\n    cin>>n>>m;\n\n    for (int i = 0 ; i < m ; i++)\n    {\n        int a , b;\n        cin>>a>>b;\n        G[a].push_back(b);\n        GT[b].push_back(a);\n    }\n}\n\nvoid DFS_G(int node , vector<int>&V)\n{\n    V[node] = 1;\n\n    for (int x : G[node])\n    {\n        if (!V[x])\n            DFS_G(x , V);\n    }\n}\n\nvoid DFS_GT(int node , vector<int>&V)\n{\n    V[node] = 1;\n\n    for (int x : GT[node])\n    {\n        if (!V[x])\n            DFS_GT(x , V);\n    }\n}\n\nint main()\n{\n    //G-graph\n    //GT-reversed graph\n    int SCC = 0;\n    read();\n    vector<int>component(101 , 0);\n    vector<int>reachedG(101) , reachedGT(101);//will keep nodes reached from x in G and in GT\n\n    for (int i = 1 ; i <= n ; i++)\n    {\n        if (!component[i])\n        {\n\n        component[i] = 1;\n\n        for(int j = 1 ; j <= n ; j++)\n        {\n            reachedG[j] = reachedGT[j] = 0;\n        }\n\n        DFS_G(i , reachedG);\n        DFS_GT(i , reachedGT);\n\n        for (int j = 1 ; j <= n ; j++)\n        {\n            if (reachedG[j] == 1 && reachedGT[j] == 1)\n            {\n                component[j] = 1;\n            }\n        }\n        SCC++;\n\n        }\n    }\n    cout<<SCC;\n    return 0;\n}\n```\n\nLet's say you are at node X.First we DFS from X , and find the nodes that we can reach from it.We mark them as reached in our reachedG vector.As you may know , by reversing a graph and then DFS from x , the nodes you will encounter are actually the nodes that can reach X.I keep them in reachedGT.So the intersection between these two vectors will actually be the SCC our node X is in.However , as I read on the internet, this isn't the best implementation of Kosaraju's algorithm.The more efficient one is this one from https://www.geeksforgeeks.org/strongly-connected-components/.\nThe steps are the following:\n\nCreate an empty stack ‘S’ and do DFS traversal of a graph. In DFS traversal, after calling recursive DFS for adjacent vertices of a vertex, push the vertex to stack. In the above graph, if we start DFS from vertex 0, we get vertices in stack as 1, 2, 4, 3, 0.\n\nReverse directions of all arcs to obtain the transpose graph.\n\nOne by one pop a vertex from S while S is not empty. Let the popped vertex be ‘v’. Take v as source and do DFS (call DFSUtil(v)). The DFS starting from v prints strongly connected component of v. In the above example, we process vertices in order 0, 3, 4, 2, 1 (One by one popped from stack).\n\n\nI've spent quite some hours reading about it and I still don't understand the logic behind the stack with finishing times of our nodes.However , I think this approach is really similar to mine and that I'm missing something.I'd be happy if you helped me!\n    ", "Answer": "\r\nLet v be the last node to be finished. Every node that can reach v in the original graph (hence that v can reach in the transpose) is in v's strong component. Why? Suppose to the contrary that x is a node that can reach v, but v can't reach x. When we start x, the node v cannot be on the stack at the time because that would imply a path to x. We can't finish x until we've at least started every node that x can reach, so if v starts before x, it's already finished (because not on the stack), and if v starts after x, it finishes before x (because it's higher on the stack than x). Contradiction. This argument extends to a correctness proof.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Make an undirected graph a strongly connected component (SCC)\r\n                \r\n\n  Let ```\nG(V,E)```\n, an undirected, connected graph with no bridges at all. Describe an algorithm which direct the edges, so the new graph is an SCC.\n\n\nMy suggested algorithm\nSo we run DFS from an arbitrary vertex. We notice that since it's an undirected graph there are only tree-edges and back-edges (Right?). We connect edges accordingly (a tree-edge would be directed \"down\" and a back-edge would be directed \"up\").\n\nA start of proof\nWe notice that the graph has no bridges. Therefore, every edge is part of some cycle. Therefore, the last edge to be discovered in some cycle must be a back-edge.  \n\nNow, I think the rest of the proof would need to show that we can always \"climb\" to the root, and so the graph is an SCC.\n\nI'd be glad if you could help me connect the dots (or vertices XD)\n\nThanks\n    ", "Answer": "\r\nWhat you are looking for is a proof for Robbins' Theorem.\nFor a more formal proof you can look at this paper (See proof for theorem 2).  \n\nThe below is not a formal proof but it's a way you can think of it:\n\nAs you already mentioned, since there are no bridges, every edge is a part of some cycle. Since you want your output graph to be SCC, a DFS on this output graph (from any vertex) must only have back-edges and tree-edges. It cannot have forward-edges or cross-edges.\n\nLets assume we have a forward-edge from ```\ns```\n to ```\nt```\n. This means that in the DFS we ran in order to build the graph, ```\nt```\n was discovered in the sub-DFS (recursive call) of ```\ns```\n and had no other gray or white adjacents. But this is not true because whenever we discover ```\nt```\n in our DFS we would still have a gray adjacent.\n\nLets assume we have a cross-edge from ```\ns```\n to ```\nt```\n. This means that ```\nt```\n's sub-DFS has ended before ```\ns```\n was discovered. Again, this cannot happen in our DFS because either when discovering ```\nt```\n first we would discover ```\ns```\n in its sub-DFS or the opposite direction. \n\nHere is a simple graph to help you see those cases.\n\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Finding strongly connected components - Kosaraju’s Algorithm\r\n                \r\nIn directed graph, to find strongly connected components (with  Kosaraju’s Algorithm) why do we have to transpose adjacency matrix (reverses the direction of all edges) if we could use reversed list of nodes by they finishing time and then traverse original graph.\nIn other words, we would find finish times of all vertices and start traversing from lowest finish time to greatest (by increasing finish time)? \n\nAdditionally, if we do topological sorting on some DAG, and then reverse edges (transpose adjacency matrix) and do topological sorting again - should we get to equal arrays, just in reversed order?\n    ", "Answer": "\r\nThis won't give SCC. Consider 2 subgraphs S1 and S2. For both S1 and S2 to be a part of single SCC, there should be a path from S1 to S2 and also from S2 to S1. The way you mentioned it, it will count them as a single SCC even if there is only a path from S1 to S2.\nDFS on both original and reversed graph makes sure that only components which have paths in both direction gets combined inside a SCC.\n\n\n  Additionally, if we do topological sorting on some DAG, and then reverse edges (transpose adjacency matrix) and do topological sorting again - should we get to equal arrays, just in reversed order?\n\n\nNot necessarily. Consider a trivial example (1->2,1->3) .Topological sort=(1,2,3). Reverse graph (2->1,3->1). Topological sort (2,3,1)\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Algorithm for finding every weakly connected component of a directed graph\r\n                \r\nI am searching for an algorithm for finding every weakly connected component in a directed graph. I know for an undirected graph you can do this via a dfs but this obviously doenst work for an directed graph. I am saving my graph as an adjacents list. \nFor example:\n\n```\nA -> B\nB -> C\nD -> X\n```\n\n\nSo A-B-C is a connected component an D-X\n\nI am not searching for an algorithm for finding strongly connected components!!\n    ", "Answer": "\r\nUnless your memory constraints are too strict, you can keep a second, temporary adjacency list. In that second adjacency list you put each edge a->b and you also put edges in reverse direction. (i.e. b->a) Then, you can use DFS on that adjacency list to find connected components.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Implementing Tarjan's strongly connected components without relying on potential failure as an effect\r\n                \r\nI am trying to implement graph algorithms in Standard ML, under the constraint that the only allowed effect is mutating reference cells. Exceptions and nontermination are forbidden. Standard ML itself is inessential to the question. I will accept an answer in any other typed programming language so long as it satisfies my constraint. (Unfortunately, untyped languages are out: checking the well-formedness of the data and potentially failing is in itself the effect I want to avoid.)\n\nI will illustrate how one can program under my constraint by implementing Kosaraju's algorithm. My question is whether Tarjan's strongly connected components algorithm can also be implemented in this style.\n\n```\ndatatype 'a node = Node of 'a * bool ref * 'a node list ref * 'a node list ref\n\nfun node x = Node (x, ref false, ref nil, ref nil)\nfun mark (Node (_, r, _, _)) = !r before r := true\nfun unmark (Node (_, r, _, _)) = !r before r := false\n\nfun value (Node (x, _, _, _)) = x\nfun sources (Node (_, _, ref xs, _)) = xs\nfun targets (Node (_, _, _, ref ys)) = ys\n\nfun connect (m, n) =\n  let\n    val Node (_, _, _, ns) = m\n    val Node (_, _, ms, _) = n\n  in\n    ms := m :: !ms;\n    ns := n :: !ns\n  end\n\ndatatype 'a state = Root of 'a node | Children of 'a node list\n\nfun visit (xs, nil) = xs\n  | visit (xs, Root x :: ss) = visit (x :: xs, ss)\n  | visit (xs, Children nil :: ss) = visit (xs, ss)\n  | visit (xs, Children (y :: ys) :: ss) =\n    if mark y then\n      visit (xs, Children ys :: ss)\n    else\n      visit (xs, Children (targets y) :: Root y :: Children ys :: ss)\n\nfun assign (xs, nil) = xs\n  | assign (xs, nil :: ss) = assign (xs, ss)\n  | assign (xs, (x :: s) :: ss) =\n    if unmark x then\n      assign (x :: xs, sources x :: s :: ss)\n    else\n      assign (xs, s :: ss)\n\nfun assigns (xs, nil) = xs\n  | assigns (xs, y :: ys) =\n    case assign (nil, (y :: nil) :: nil) of\n        nil => assigns (xs, ys)\n      | x => assigns (x :: xs, ys)\n\nfun kosaraju xs = assigns (nil, visit (nil, Children xs :: nil))\n```\n\n\nIs it possible to implement Tarjan's strongly connected components algorithm in this style?\n    ", "Answer": "\r\nI have an open source project over here that produces discrete finite automata: https://github.com/mtimmerm/dfalex\n\nIt includes an implementation of Tarjan's algorithm in a style that is somewhat similar to what you want, but the DFS function takes 3 lambdas:\n\n```\n   /**\n     * Perform a depth first search of all states, starting at the start states\n     * <P>\n     * To avoid stack overflow errors on large DFAs, the implementation uses an auxiliary\n     * stack on the heap instead of recursing\n     * \n     * @param onEnter  called with (parent, child) when a child is entered.  parent == null for roots.\n     * @param onSkip  called with (parent, child) when a child is skipped because it has been entered\n     *                  previously.  parent == null for roots.\n     * @param onLeave  called with (parent, child) when a child is exited.  parent == null for roots.\n     */\n    public void depthFirstSearch(\n            BiConsumer<DfaState<MATCHRESULT>, DfaState<MATCHRESULT>> onEnter,\n            BiConsumer<DfaState<MATCHRESULT>, DfaState<MATCHRESULT>> onSkip,\n            BiConsumer<DfaState<MATCHRESULT>, DfaState<MATCHRESULT>> onLeave)\n    {\n```\n\n\nTarjan's algorithm is in this file on line 200, a method call \"getCycleNumbers\":\n\nhttps://github.com/mtimmerm/dfalex/blob/master/src/com/nobigsoftware/dfalex/DfaAuxiliaryInformation.java#L200\n\nYour definition of a visitor doesn't support all of these 3 different kinds of events.  It only provides \"onEnter\".  They're all required for Tarjan's algorithm.  It is possible to reconstitute them from what you do get, but it would be more complicated than just writing a new DFS that provides all 3.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Spark graphFrames - Label Propagation vs. Strongly Connected Components\r\n                \r\nIn the https://docs.databricks.com/spark/latest/graph-analysis/graphframes/user-guide-scala.html standard example:\n\n\nThe Strongly Connected Components seem reasonable computationally when looking also at them visually on a drawing.\n\n\n\n\n\nTherefore I am surprised at the Label Propagation for detecting \"communities\".\n\n\n\n\nWhat am I missing? [A, D, E] I would have thought would be a community as well from the data and that results would be similar. I tried with more cycles.  Label Propagation seems the poor cousin of \"clustering\".\n    ", "Answer": "\r\nWhat you have found here is a known phenomenon called label oscillation which occurs when the labels are synchronously updated and (sub)graphs have a bipartite structure (or star graphs). The two communities will endlessly exchange their labels and the LPA will never terminate by itself.\n\nLabels at t:\n\n\nLabels at t+1:\n\n\nLabels at t+2:\n\n\n... and so on.\n\nAs you have already mentioned this is not really what we would expect from a community detection algorithm as there are no edges within the communities. But this is still a fast algorithm which delivers good results for non bipartite structures. Raghavan proposed a fast alternative which uses  asynchronous updating. But this is not yet implemented in Graphframes. Graphframes calls the graphX implementation of LPA (have a look at code code) which uses Pregel (have a look at code code) which is synchronous.\n\nBesides of LPA problem for bipartite structures there is also a general difference between SCC and LPA:\n\n\nSCC community: Every node of a community knows (has an edge) all other nodes within the community. \nLPA community: For each node of a community there is a path\n(sequence of edges) within the community to all other nodes within\na community.\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Is it allowed to have strongly connected components in a graph in CPM/PERT?\r\n                \r\nI have read that every non-trivial SCC is a cycle, which means that in a graph used in CPM/PERT method there shouldn't be any, but after I read some other things, I got a little bit confused :( I really need help!\n    ", "Answer": "\r\nPERT charts indicate the partial ordering of the actions one wants to take, so they can't have cycles. If a cycle would be present it would mean that, f.e. you need to start with activity A, then do B, then C, and then A again - this doesn't make sense. Maybe it would be easier to answer if you would provide a link to the content that got you confused.\n\nEDIT (regarding the OP's comment):\nEvery SCC must contain cycles. Proof sketch: assume that there exists a SCC without a single cycle in a directed graph. Assume that it contains two vertices: A and B. From the definition of SCC there must exist a path from A to B, and from B to A. So, we always can use one of this paths to travel from A to B, and then the other path to get back from B to A (it will be a different path, because we are considering a directed graph), thus forming a cycle. This leads to a contradiction, so you can't have a SCC without cycles. Regarding my answer above, this suggests that PERT charts can't have SCC's either.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Finding Number of Edges on Strongly Connected Component\r\n                \r\nI have a network graph by name Gmedium, and I've found the largest strongly connected component by this code:\n\n```\nmaxstmed = max(nx.strongly_connected_components(Gmedium), key=len)\n```\n\n\nMy question is, how do you find number of edges of this connected network? If you try to find the number of nodes, I have it like this:\n\n```\nnewGm = nx.Graph()\nnewGm.add_nodes_from(list(maxstmed))\nnewGm.number_of_nodes()\n```\n\n\nBut you can't apply this for edges, as it returns 0 when I used add_edges_from and number_of_edges. I tried to count it manually by this:\n\n```\ncount = 0\nfor u in list(newGm.nodes):\n    for v in list(newGm.nodes):\n        if u == v:\n            continue\n        if nx.has_path(Gmedium,u,v) == True:\n            count += 1\nprint(count)\n```\n\n\nBut, for a big network (with over 10.000 nodes), it takes forever. Anyone knows the algorithm or function to handle it efficiently? I am using Python Ver. 3 in Spyder environment. Thank you.\n    ", "Answer": "\r\nYou can use a ```\nsubgraph```\n function to extract a subgraph with given nodes from the original graph. You send a collection of nodes as attribute and it returns you a subgraph of original graph with these nodes and edges between them:\n\n```\nG = nx.fast_gnp_random_graph(30, 0.04, directed=True, seed=1)\nnx.draw(G)\n```\n\n\n\n\n```\nC = max(nx.strongly_connected_components(G), key=len)\nprint(C)\n```\n\n\n\n  ```\n{0, 3, 4, 6, 8, 10, 11, 15, 21, 22, 24, 25}```\n\n\n\n```\nS = G.subgraph(C)\nnx.draw(S)\n```\n\n\n\n\n```\nprint(list(nx.edges(S)))\n```\n\n\n\n  ```\n[(0, 3), (3, 4), (3, 21), (4, 6), (6, 11), (6, 15), (8, 0), (10, 6), (11, 8), (11, 15), (15, 24), (15, 25), (21, 8), (21, 22), (21, 15), (22, 24), (22, 25), (22, 15), (24, 10), (25, 0)]```\n\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Strongly Connected Components (SCC graph algorithm) in SML [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                It's difficult to tell what is being asked here. This question is ambiguous, vague, incomplete, overly broad, or rhetorical and  cannot be reasonably answered in its current form. For help clarifying this question so that it can be reopened,  visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI need to write SCC algorithm in standard ML. But I don't know how.\nI have following TYPEs which have to be uesd in the code:\n\n```\ntype vertex = int\ntype edge = int * int\ntype graph = (vertex * vertex list) list\n\n\nfun dfs (g: graph) (n: vertex): vertex list = \n  let\n    fun helper (todo: vertex list) (visited: vertex list): vertex list =\n    case todo of\n      [] => []\n    | h::t => if (List.exists (fn x => x = h) visited)\n                then helper t visited\n                else\n                  let\n                    val adj = case List.find (fn (n, _) => n = h) g of\n                                NONE => raise Fail \"incomplete adjacency list\"\n                              | SOME (_, adj) => adj\n                  in\n                    h :: (helper (adj @ t) (h::visited))\n                  end\n  in\n    helper [n] []\n  end\n```\n\n\nThe above code has been compiled and run correctly.\nI put these in the code because I know in computing SCC dfs is needed.\nDoes anyone have a solution?\n    ", "Answer": "\r\nPseudo code - http://algowiki.net/wiki/index.php/Tarjan's_algorithm.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Strongly Connected Component with constraint\r\n                \r\nI have come across a problem which goes something like this.\n\nWe are given an undirected graph where each edge has a value. Now the extra constraint is that one can not move from a higher value edge to a lower value edge. One always has to move from lower to higher value.\n\nPictorially the problem can be depicted as\n\n```\n                                   1\n                               1 /   \\ 1\n                                /     \\\n                               3       7\n                            2 / \\  3   \n                             /   \\\n                            4     5\n```\n\n\nSo here we can move from 7 -> 1 -> 3 -> 4 but not 4 -> 3 -> 1. So in this graph we are asked to find out the strongly connected components like (1, 3, 7) in here.\n\n\n\nI have tried to use Kosaraju's Algorithm with the constraint like this.\n\n```\nfor v in adj[u]:\n    if not visited[v] and v.edgeValue >= u.edgeValue:\n        do work here\n```\n\n\nBut the logic, I think, is wrong and I can not find out where it is failing.\nCan someone point out the fault and show some kind of pseudocode?\n\nThank you.\n    ", "Answer": "\r\nWell, in your constraint, the direction your allowed to go depends on your history of travel. That makes connected component have a bit different meaning. I am assuming that by strongly connected component you mean that for a subgraph from any vertex, any other vertex of that subgraph can be reached. Since your constraint specifies that you cannot move from lower valued edge to higher value, that would mean that any subgraph that is strongly connected, contains a tree with equal weighted edges.\n\nSo in example above, you would have (4,3)(3,5)(3,1,7) as one particular partition of the graph into strong components. You can get those by doing a simple DFS or BFS while including only edges of a specific weight.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Why do I get StackOverFlowError when trying to DFS this graph for finding strongly connected component?\r\n                \r\nI am trying to write an algorithm that determines whether a graph is strongly connected or not. I think my code is almost correct, although I keep getting StackOverFlowError. I personally think because there's a cycle in the graph I'm testing my algorithm with, my code doesn't understand that and comes in a loop. But I'm using an array to see if a node was already visited! So that should not happen! Please help me understand what's wrong with my code. Anyways this is my code:\n\n```\n static void dfs(int src,boolean[] visited,Stack<Integer> stack){\n        visited[src]=true;\n        for(Integer i:adj[src]){\n            if(!visited[i]){\n                dfs(i,visited,stack);\n            }\n        }\n        stack.push(src);\n    }\n```\n\n\nThis is how I called my DFS function from main:\n\n```\nStack<Integer> stack=new Stack<Integer>();\n    boolean[] visited=new boolean[n+1];\n    for(int i=1;i<=n;i++){\n        if(!visited[i]){\n            g.dfs(i,visited,stack);\n        }\n    }\n```\n\n    ", "Answer": "\r\nThere are two possible explanations:\n\n\nThere is a loop and your loop detection code isn't working.\nThe graph is too deep; i.e. your code would work if the stack was larger.\n\n\nLooking at your code, I think that the second explanation is the correct one.\n\nExample:  suppose that your graph is actually a chain of N nodes in a line.  To reach the last node in the list you need to make recursive calls N deep.  For large enough N, that will cause a stack overflow.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "In the graph theory, is a strongly connected component SCC form a DAG?\r\n                \r\nI was trying to solve a problem to design an algorithm to determine whether a direct graph is semi-connected. Someone says it can be done by using topological sort every SCC in the graph. And SCC is guaranteed to be DAG. However, I think SCC graph must be a circle, why it is a DAG since DAG mean no circle.\n    ", "Answer": "\r\nYou misunderstood the argument.\n\nSuppose you have a graph that has points\n\n```\nA1 <--> A2 <--> A3 --> B1 <--> B2 --> C1 <--> C2```\n\n\nand ```\nA1 A2 A3```\n, ```\nB1 B2```\n, ```\nC1, C2```\n are SCC.\n\nThen you treat ```\nA1 A2 A3```\n as a single point ```\nA```\n. Any node connecting to one of ```\nA1 A2 A3```\n is treated as connecting to ```\nA```\n, Any node connected from one of ```\nA1 A2 A3```\n is treated as connected from ```\nA```\n. Same for merging points to ```\nB```\n, ```\nC```\n\n\nSo it became ```\nA --> B --> C```\n. It is guaranteed that this is a DAG.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Tarjan's strong connected component wrong or my code is wrong?\r\n                \r\nI am trying to implement Tarjan's strongly connected graph algorithm (https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm), here is my code and I am confused why vertex ```\n4```\n and vertex ```\n5```\n are also output as strongly connected component?\n\nI am using a very simple diagram only have 5 nodes to test. My code is written in Python 2.7.\n\n```\nfrom collections import defaultdict\nclass SccGraph:\n    def __init__(self, vertex_size):\n        self.out_neighbour = defaultdict(list)\n        self.vertex = set()\n        self.visited = set()\n        self.index = defaultdict(int)\n        self.low_index = defaultdict(int)\n        self.global_index = 0\n        self.visit_stack = []\n        self.scc = []\n    def add_edge(self, from_node, to_node):\n        self.vertex.add(from_node)\n        self.vertex.add(to_node)\n        self.out_neighbour[from_node].append(to_node)\n    def dfs_graph(self):\n        for v in self.vertex:\n            if v not in self.visited:\n                self.dfs_node(v)\n    def dfs_node(self, v):\n        # for safe protection\n        if v in self.visited:\n            return\n        self.index[v] = self.global_index\n        self.low_index[v] = self.global_index\n        self.global_index += 1\n        self.visit_stack.append(v)\n        self.visited.add(v)\n        for n in self.out_neighbour[v]:\n            if n not in self.visited:\n                self.dfs_node(n)\n                self.low_index[v] = min(self.low_index[v], self.low_index[n])\n            elif n in self.visit_stack:\n                self.low_index[v] = min(self.low_index[v], self.index[n])\n        result = []\n        if self.low_index[v] == self.index[v]:\n            w = self.visit_stack.pop(-1)\n            while w != v:\n                result.append(w)\n                w = self.visit_stack.pop(-1)\n            result.append(v)\n            self.scc.append(result)\n\nif __name__ == \"__main__\":\n    g = SccGraph(5)\n    # setup a graph 1->2->3 and 3 -> 1 which forms a scc\n    # setup another two edges 3->4 and 4->5\n    g.add_edge(1,2)\n    g.add_edge(2,3)\n    g.add_edge(3,1)\n    g.add_edge(3,4)\n    g.add_edge(4,5)\n    g.dfs_graph()\n    print g.scc\n```\n\n    ", "Answer": "\r\nEvery single vertex is strongly connected. If it does not belong to any bigger strongly connected subgraph, then it is already strong component. So both your implementation and Tarjan's algorithm are fine. (I didn't check if you have any other mistakes).\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Finding a different sort of connected component\r\n                \r\nI would like to define a uni-connected component in a directed graph to be a subgraph where for each pair of nodes u and v there exists either a path from u to v or from v to u. It should also have the property that it isn't a subgraph of another uni-connected component.\n\nI know how to find weakly and strongly connected components. How can you find uni-connected components?\n\nA very inefficient method might do a breadth search from each node to see which nodes can be reached from it and try to compute the components somehow from these sets of nodes.\n    ", "Answer": "\r\nA maximal uni-connected subgraph (I refuse to call them \"components\", because the underlying relation is not transitive) contains all or none of a strongly connected component. As a first step in enumerating maximal uni-connected subgraphs, then, collapse each SCC to a single vertex (i.e., compute the condensation of the input graph).\n\nA uni-connected subgraph of an acyclic directed graph has the property that, for distinct nodes u and v, either there is a path from u to v, or a path from v to u, but not both. Write u < v if there is a path from u to v and u != v. Since either u < v or v < u but not both, and u < v and v < w implies u < w, the relation < is a strict total order. By sorting the vertices in the subgraph, we find that they lie on a single path. This path is maximal if and only if no vertex can be inserted, which means that it begins at a source (no incoming edges), ends at a sink (no outgoing edges), and is comprised solely of edges that appear in the transitive reduction of the acyclic directed graph.\n\nHere is one algorithm for enumerating maximal uni-connected subgraphs of a directed graph G.\n\n\nFind the strong components of G. Contract them, yielding the condensation G'.\nCompute the transitive reduction G'' of G'.\nEnumerate all source-sink paths by, e.g., depth-first search, then replace each node by its strong component in G.\n\n\nHere is a graph family with exponentially many maximal uni-connected subgraphs. All edges are directed downward.\n\n```\n  *\n / \\\n*   *\n \\ /\n  *\n / \\\n*   *\n \\ /\n  *\n / \\\n  .\n  .\n  .\n \\ /\n  *\n / \\\n*   *\n \\ /\n  *\n```\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Networkx - How to find the average shortest path length of weakly connected component in case of a directed graph?\r\n                \r\nI want to find the average shortest path length of weakly connected components but the version 3.1 of networkx throws an error that the graph is not strongly connected.\n```\nwcc_subs = (G.subgraph(c) for c in nx.weakly_connected_components(G))\nG_wc = max(wcc_subs, key=len) #the largest weakly connected subgraph\nshortest_wc=nx.average_shortest_path_length(G_wc)\nshortest_wc\n```\n\nThis is the code that I have tried.\n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "C++- How to increase stack size to allow more recursion for Kosaraju's Algorithm to compute Strongly Connected Components\r\n                \r\nI am using a mac, 4GB of RAM and CLion IDE. Compiler is Clang. I need to allow more recursion in this recursive implementation of Depth First Search (currently fails on a graph with 80k nodes). \n\n```\ntypedef unordered_map <int, vector<int>> graph;\nvoid DFS (graph &G, int i, vector <bool> &visited) {\n\n    visited[i] = true;\n    for (int j = 0; i < G[i].size(); j++) {\n        if (!visited[G[i][j]]) {\n            DFS(G, G[i][j], visited);\n        }\n    }\n    t++;\n    finishingTime[t] = i; //important step\n}\n```\n\n\nThis is for an implementation of Kosaraju's algorithm to compute strongly connected components in a graph. https://en.wikipedia.org/wiki/Kosaraju%27s_algorithm I know it is possible to implement DFS as iterative instead but the last step is important, and I can't find a way to include it using iteration. This is because that step is done when DFS fails and backtracking occurs, and recursion provides a very natural way to do this.\n\nSo currently I have only two options: \n\n\nIncrease the stack size to allow more recursion \nOr find an iterative solution\n\n\nAny ideas how to do either?\n    ", "Answer": "\r\nAs suggested by a comment you can put each call to DFS on a stack allocated on heap made from the parameter list of DFS and then iterate through the stack. Each entry in the stack is essentially a task.\n\nPseudo-like code:\n\n```\nStart and run \"recursion\":\nnr_of_recursions = 0;\ndfs_task_stack.push(first_task_params)\nwhile dfs_task_stack not empty\n  DFS(dfs_task_stack.pop)\n  nr_of_recursions += 1\nend while;\ntrue_finishingtime[] = nr_of_recursions - finishingtime[];\n\nDFS:\nfor each recursion found\n  dfs_task_stack.push(task_params)\nend for;\nt++; finishingtime...\n```\n\n\nNot sure of your algorithm but it may be significant which order you push your tasks to the stack, i.e. the order of \"for each ...\".\n\nI took the liberty of redefining the meaning of \"finishingtime\" to its inverse. To get the original definition substract the new finishingtime with the total number of recursions made.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Get nodes from a graph condensation\r\n                \r\nI have an adjacency  matrix ```\nadj```\n and a cellarray ```\nnodeManes```\n that contains names that will be given to the graph ```\nG```\n that will be constructed from ```\nadj```\n.\n\nSo I use ```\nG = digraph(adj,nodeNames);```\n and I get the following graph : \n\n\n\nNow, I want to find the strongly connected components in ```\nG```\n and do a graph condensation so I use the following: \n\n```\nC = condensation(G);\np2 = plot(C); \n```\n\n\nand get this results : \n\n\nSo I have 6 strongly connected components, but my problem is that I lost the node names, I want to get something like: \n\n\nIs that any way to get the nodes names in the result of the condentation?\n    ", "Answer": "\r\nI think the official documentation can take you to the right point:\n\n\n  Output Arguments\n  \n  C - Condensation Graph\n  \n  Condensation graph, returned as a digraph object. C is a directed\n  acyclic graph (DAG), and is topologically sorted. The node numbers in\n  C correspond to the bin numbers returned by conncomp.\n\n\nLet's take a loot at conncomp:\n\n\n  conncomp(G) returns the connected components of graph G as bins. The\n  bin numbers indicate which component each node in the graph belongs to\n\n\nLook at the examples... I think that if you use ```\nconncomp```\n on your graph before using the ```\ncondensation```\n function, you will be able to rebuild your node names on your new graph with a little effort.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Strongly component\r\n                \r\nI am trying to write an algorithm that is given a graph G and 2 nodes 'x' and 'y'as input, which returns whether there is a cyclic path from 'x' to 'y'\n\nIs it a good idea to find the strongly connected components first and then check if x and y belong to same strongly connected component. If they belong to different connected component say x belongs to C1 and y belongs to C2, then if there exists a path from C1 to C2, then we can say that there is a cyclic path from x to y.\n    ", "Answer": "\r\nYour idea with strongly connected components should work. Here is a graph and some code for you to experiment:\n\nFirst, a digraph:\n\n\n\nAnd it's adjacency lists representation:\n\n```\n13 vertices, 22 edges\n0: 5 1\n1: \n2: 0 3\n3: 5 2\n4: 3 2\n5: 4\n6: 9 4 8 0\n7: 6 9\n8: 6\n9: 11 10\n10: 12\n11: 4 12\n12: 9\n```\n\n\nAnd it's strongly connected components:\n\n\n\n```\n7\n6 8\n9 10 11 12\n0 2 3 4 5\n1\n```\n\n\nNow, after with implementation for digraph and Kosaraju-Sharir\n\n```\nclass StronglyConnectedComponents\n{\n    private bool[] visited;\n    private int[] componentIds;\n    public int ComponentCount { get; private set; }\n\n    public StronglyConnectedComponents(DirectedGraph graph)\n    {\n        visited = new bool[graph.VertexCount];\n        componentIds = new int[graph.VertexCount];\n\n        var order = new GraphTraversal(graph).ReverseOrder();\n        var reversedGraph = graph.Reverse();\n        foreach (var vertex in order)\n        {\n            if (!visited[vertex])\n            {\n                DepthFirstSearch(reversedGraph, vertex);\n                ComponentCount++;\n            }\n        }\n    }\n\n    public int VertexComponentId(int vertex)\n    {\n        return componentIds[vertex];\n    }\n\n    public bool AreStronglyConnected(int source, int target)\n    {\n        return componentIds[source] == componentIds[target];\n    }\n\n    private void DepthFirstSearch(DirectedGraph graph, int vertex)\n    {\n        visited[vertex] = true;\n        componentIds[vertex] = ComponentCount;\n        foreach (var adjacent in graph.AdjacentTo(vertex))\n        {\n            if (!visited[adjacent])\n            {\n                DepthFirstSearch(graph, adjacent);\n            }\n        }\n    }\n}\n\nclass GraphTraversal\n{\n    private Stack<int> reversePostOrder;\n    private bool[] visited;\n\n    public GraphTraversal(DirectedGraph graph)\n    {\n        visited = new bool[graph.VertexCount];\n        reversePostOrder = new Stack<int>();\n\n        for (var vertex = 0; vertex < graph.VertexCount; vertex++)\n        {\n            if (!visited[vertex])\n            {\n                DepthFirstSearch(graph, vertex);\n            }\n        }\n    }\n\n    public IEnumerable<int> ReverseOrder()\n    {\n        return reversePostOrder;\n    }\n\n    private void DepthFirstSearch(DirectedGraph graph, int vertex)\n    {\n        visited[vertex] = true;\n        foreach (var adjacent in graph.AdjacentTo(vertex))\n        {\n            if (!visited[adjacent])\n            {\n                DepthFirstSearch(graph, adjacent);\n            }\n        }\n        reversePostOrder.Push(vertex);\n    }\n}\n\nclass DirectedGraph\n{\n    public int VertexCount { get; set; }\n    public int EdgeCount { get; set; } = 0;\n\n    private List<int>[] adjacencyLists;\n\n    public DirectedGraph(int vertexCount)\n    {\n        VertexCount = vertexCount;\n        InitializeAdjacencyLists(vertexCount);\n    }\n\n    public void AddEdge(int from, int to)\n    {\n        adjacencyLists[from].Add(to);\n        EdgeCount++;\n    }\n\n    public IEnumerable<int> AdjacentTo(int vertex)\n    {\n        return adjacencyLists[vertex];\n    }\n\n    public DirectedGraph Reverse()\n    {\n        var reversedGraph = new DirectedGraph(this.VertexCount);\n        for (var vertex = 0; vertex < this.VertexCount; vertex++)\n        {\n            foreach (var adjacent in this.AdjacentTo(vertex))\n            {\n                reversedGraph.AddEdge(adjacent, vertex);\n            }\n        }\n        return reversedGraph;\n    }\n\n    public override string ToString()\n    {\n        String graghString = VertexCount + \" vertices, \" + EdgeCount + \" edges \\n\";\n        for (int vertex = 0; vertex < VertexCount; vertex++)\n        {\n            graghString += vertex + \": \";\n            foreach (var adjacnet in this.AdjacentTo(vertex))\n            {\n                graghString += adjacnet + \" \";\n            }\n            graghString += \"\\n\";\n        }\n        return graghString;\n    }\n\n    private void InitializeAdjacencyLists(int vertexCount)\n    {\n        adjacencyLists = new List<int>[vertexCount];\n        for (var vertex = 0; vertex < vertexCount; vertex++)\n        {\n            adjacencyLists[vertex] = new List<int>();\n        }\n    }\n}\n```\n\n\nQueries like ```\nscc.AreStronglyConnected(2, 5)```\n will tell if directed cycle between vertices exists. Runnable code is here.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Using BFS for topological sort\r\n                \r\nCan Breadth first Search be used for finding topological sorting of vertices and strongly connected components in a graph?\n\nIf yes how to do that? and If not why not?\n\nwe generally use Depth first search in these problems but What will be the problem if I try to implement using BFS?\n\nWill code like this work?\n\n```\ndef top_bfs(start_node):\n    queue = [start_node]\n    stack = []\n    while not queue.empty():\n        node = queue.dequeue()\n        if not node.visited:\n            node.visited = True\n            stack.push(node)\n            for c in node.children:\n                queue.enqueue(c) \n    stack.reverse()\n    return stack\n```\n\n    ", "Answer": "\r\nYes, you can do topological sorting using BFS. Actually I remembered once my teacher told me that if the problem can be solved by BFS, never choose to solve it by DFS. Because the logic for BFS is simpler than DFS, most of the time you will always want a straightforward solution to a problem.\n\nYou need to start with nodes of which the indegree is 0, meaning no other nodes direct to them. Be sure to add these nodes to your result first.You can use a HashMap to map every node with its indegree, and a queue which is very commonly seen in BFS to assist your traversal. When you poll a node from the queue, the indegree of its neighbors need to be decreased by 1, this is like delete the node from the graph and delete the edge between the node and its neighbors. Every time you come across nodes with 0 indegree, offer them to the queue for checking their neighbors later and add them to the result.\n\n```\npublic ArrayList<DirectedGraphNode> topSort(ArrayList<DirectedGraphNode> graph) {\n\n  ArrayList<DirectedGraphNode> result = new ArrayList<>();\n    if (graph == null || graph.size() == 0) {\n      return result;\n    }\n  Map<DirectedGraphNode, Integer> indegree = new HashMap<DirectedGraphNode, Integer>();\n  Queue<DirectedGraphNode> queue = new LinkedList<DirectedGraphNode>();\n\n//mapping node to its indegree to the HashMap, however these nodes\n//have to be directed to by one other node, nodes whose indegree == 0\n//would not be mapped.\n  for (DirectedGraphNode DAGNode : graph){\n      for (DirectedGraphNode nei : DAGNode.neighbors){\n          if(indegree.containsKey(nei)){\n              indegree.put(nei, indegree.get(nei) + 1);\n          } else {\n              indegree.put(nei, 1);\n          }\n      }\n  }\n\n\n//find all nodes with indegree == 0. They should be at starting positon in the result\n  for (DirectedGraphNode GraphNode : graph) {\n      if (!indegree.containsKey(GraphNode)){\n          queue.offer(GraphNode);\n          result.add(GraphNode);\n      }\n  }\n\n\n//everytime we poll out a node from the queue, it means we delete it from the \n//graph, we will minus its neighbors indegree by one, this is the same meaning \n//as we delete the edge from the node to its neighbors.\n  while (!queue.isEmpty()) {\n      DirectedGraphNode temp = queue.poll();\n      for (DirectedGraphNode neighbor : temp.neighbors){\n          indegree.put(neighbor, indegree.get(neighbor) - 1);\n          if (indegree.get(neighbor) == 0){\n              result.add(neighbor);\n              queue.offer(neighbor);\n          }\n      }\n  }\n  return result;\n}\n```\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Getting segmentation fault while implementing Kosaraju Algorithm\r\n                \r\nkosaraju algorithm:\nProblem statement:  Given a Directed Graph with V vertices (Numbered from 0 to V-1) and E edges, Find the number of strongly connected components in the graph.\nwhile implementing this code I am getting a segmentation fault. Where is the error in this code?\n```\n   void dfs(int node,vector<int>adj[],stack<int>&st,vector<int>&vis){\n    vis[node]=1;\n    for(auto it: adj[node]){\n        if(!vis[it]){\n            dfs(it,adj,st,vis);\n           \n        }\n    }\n     st.push(node);\n}\n\nvoid revdfs(int node,vector<int>trs[],vector<int>&vis){\n      vis[node]=1;\n    for(auto it: trs[node]){\n        if(!vis[it]){\n            revdfs(it,trs,vis);\n           \n        }\n    }\n    \n}\n\nint kosaraju(int V, vector<int> adj[])\n{\n    stack<int>st;\n    vector<int>vis(V+1,0);\n    \n    for(int i=0; i<V;i++){\n        if(!vis[i])\n        dfs(i,adj,st,vis);\n    }\n    \n \n    int cnt=0;\n    \nvector<int> transpose[V+1]; \n\nfor(int i = 1;i<=V;i++) {\n    vis[i] = 0; \n    for(auto it: adj[i]) {\n        transpose[it].push_back(i); \n    }\n}\n\n    while(!st.empty()){\n        int node=st.top();\n        st.pop();\n        if(!vis[node]){\n            cnt++;\n            revdfs(node,transpose,vis);\n        }\n    }\n    return cnt;\n    \n```\n\n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Find a path from vertex s to vertex t with minimal number of color alternates\r\n                \r\nLet  be a directed graph, and let  be an edge-coloring in red and blue. Let s,t be vertices in G. Find a path from s to t (if exists) so that the number of color changes along this path is minimal.\nI have tried to do as follows:\n\nLet  be the graph obtained by removing all the\nblue-colored edges of G. Let  be the graph obtained\nby removing all the red-colored of G.\nLet \nbe the strongly connected graph of , computed\nusing this algorithm.\nLet  be the\nstrongly connected graph of , computed using\nthis algorithm.\nColor the vertices of\n in red, and color the vertices of\n in blue.\nLet  be\nthe graph obtained by merging  with\n.\nDefine the weight of each (existing)\nedge in G' as 0.\nFor each  such that u\nbelongs to the strongly connected component  and v\nbelongs to the strongly connected component  do as\nfollows:\n\n\nif  and  add edge  to G' and\ndefine its weight as 1.\n\n\nUse Dijkstra algorithm to find a shortest\npath from the blue strongly connected component of s, to both the\nblue and red strongly connected components of t.\nUse Dijkstra\nalgorithm to find a shortest path from the red strongly connected\ncomponent of s, to both the blue and red strongly connected\ncomponents of t.\nLet p denote the shortest path among the four we\nhave just found. (namely, p has minimal number of color alternates). p is a series of strongly connected components.\nExpand each of them using DFS, to find a corresponding path in G.\n\nThis algorithm can run in O(E+V*log(v)). Can it be improved or simplified?\n    ", "Answer": "\r\nI don't fully understand your algorithm, specifically in stage 4 you will color every vertex with two different colored edges in two colors - blue and red...\nTherefor I will not try and improve your algorithm but will present one of my own - a variant of BFS with time of O(E + V).\nThe idea: Iterate over the edges of the graph and measure depth as the number of times you switched colors.\nNote: We will run the algorithm twice, first assume that the first edge of the path is red, second assume that the first edge of the path is blue, than take the minimum.\n\nRun BFS only on red edges starting from s (which is the first element in the BFS queue), if you viewed a vertex on a blue edge keep it in a different queue.\nMark all of the nodes you saw with the number ```\ni```\n (at the beginning ```\ni=0```\n).\nTake the queue for the blue edges and make it your primary queue.\nRun stages 1 to 3 but switch the colors and add 1 to ```\ni```\n.\n\nAt the end the number in ```\nt```\n is the minimal number of swaps performed to reach ```\nt```\n.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "How to connect all components of a DiGraph in NetworkX\r\n                \r\nI have a directed graph (G), which is made of 65 strongly connected components and 8 weakly connected components. I am aware I can add non-existent edges to connect the entire graph using k-edge-augmentation, but this is only possible with an undirected graph.\nIs there any way, within NetworkX, or otherwise to connect the DiGraph to produce one strongly connected component?\n    ", "Answer": "\r\nFor anyone else coming here in future, one idea I had which I'm probably going to go with is to create both a directed and undirected graph from your data, perform k-edge-augmentation on the undirected graph, and using the edges this returns, add a biconnected component between them in the directed graph.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Kosaraju implementation in C not completely correct\r\n                \r\nI am trying to implement Kosaraju's algorithm that finds strongly connected components in a directed graph in a linear time but the result is not correct and my implementation probably has a small error. I need help.\nWhat my outputs:\n```\nStrongly Connected Component #1: 1,2,\n```\n\nWhat it should output:\n```\nStrongly Connected Component #1: 8,\nStrongly Connected Component #2: 3,7,6,5,4,\nStrongly Connected Component #3: 1,2,\nStrongly Connected Component #4: 0,\n```\n\nImplementation:\n```\n/**\n * Kosaraju's algorithm implementation which is a linear time algorithm\n * to find the strongly connected components of a directed graph.\n * https://en.wikipedia.org/wiki/kosaraju's_algorithm\n */\n\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct vertex {\n    int value;\n    struct vertex *next;\n};\n\ntypedef struct vertex Vertex;\n\ntypedef struct graph {\n    int num_vertices;\n    Vertex **neighbors;\n};\n\ntypedef struct graph Graph;\n\nstruct stack {\n    int value;\n    struct stack *next;\n};\n\ntypedef struct stack Stack;\n\n/**\n * @brief Create stack using endogenous linked list\n * @param stack pointer to a stack pointer\n */\nstatic void stack_create(Stack **stack) {\n    *stack = NULL;\n}\n\n/**\n * @brief Push method of stack\n * @param stack pointer to a stack pointer\n * @param value value to push to stack\n */\nstatic void stack_push(Stack **stack, int value) {\n    Stack *item = malloc(sizeof(Stack));\n    item->value = value;\n    item->next = *stack;\n    *stack = item;\n}\n\n/**\n * @brief Pop method of stack\n * @param stack pointer to a stack pointer\n */\nstatic bool stack_pop(Stack **stack) {\n    Stack *old = *stack;\n    if (!old)\n        return false;\n\n    *stack = old->next;\n    free(old);\n    return true;\n}\n\n/**\n * @brief Checks whether stack is empty or not\n * @param stack pointer to a stack pointer\n * @return boolean indicating whether stack is empty or not\n */\nstatic bool stack_is_empty(Stack **stack) {\n    return *stack == NULL;\n}\n\n/**\n * @brief Create graph given number of vertices implemented using adjacency\n * @return pointer to allocated graph\n */\nstatic Graph *graph_create(int num_vertices) {\n    Graph *graph = malloc(sizeof(Graph));\n    graph->num_vertices = num_vertices;\n    size_t vertices_size = num_vertices * sizeof(Vertex *);\n    graph->neighbors = (Vertex **) malloc(vertices_size);\n    memset(graph->neighbors, NULL, vertices_size);\n    return graph;\n}\n\n/**\n * @brief Add edge method of graph\n * @param graph pointer to graph\n * @param source index of source\n * @param sink index of sink\n */\nstatic void graph_add_edge(Graph *graph, int source, int sink) {\n    Vertex *item = (Vertex *) malloc(sizeof(Vertex));\n    item->value = sink;\n    item->next = graph->neighbors[source];\n    graph->neighbors[source] = item;\n}\n\n/**\n * @brief DFS traversal of graph\n * @param graph pointer to graph\n * @param stack pointer to stack\n * @param visited visited boolean array\n * @param v vertex\n */\nstatic void dfs(Graph *graph, Stack **stack, bool *visited, int v) {\n    visited[v] = true;\n    Vertex *neighbors = graph->neighbors[v];\n    while (neighbors != NULL) {\n        if (!visited[neighbors->value]) {\n            dfs(graph, stack, visited, neighbors->value);\n        }\n        neighbors = neighbors->next;\n    }\n    stack_push(stack, v);\n}\n\n/**\n * @brief Builds reverse of graph\n * @param graph pointer to graph\n * @return reversed graph\n */\nstatic Graph *reverse(Graph *graph) {\n    Graph *reversed_graph = graph_create(graph->num_vertices);\n\n    int i;\n    Vertex *neighbors;\n    for (i = 0; i < graph->num_vertices; i++) {\n        neighbors = graph->neighbors[i];\n        while (neighbors != NULL) {\n            graph_add_edge(reversed_graph, neighbors->value, i);\n            neighbors = neighbors->next;\n        }\n    }\n    return reversed_graph;\n}\n\n/**\n * @brief Use dfs to list a set of vertices dfs_and_print from a vertex v in H\n * @param graph pointer to graph\n * @param visited boolean array indicating whether index has been visited or not\n * @param deleted boolean array indicating whether index has been popped or not\n * @param v vertex\n */\nvoid dfs_and_print(Graph *graph, bool *visited, bool *deleted, int v) {\n    printf(\"%d,\", v);\n    visited[v] = true;\n    deleted[v] = true;\n    Vertex *arcs = graph->neighbors[v];  // the adjacent list of vertex v\n    while (arcs != NULL) {\n        int u = arcs->value;\n        if (!visited[u] && !deleted[u]) {\n            dfs_and_print(graph, visited, deleted, u);\n        }\n        arcs = arcs->next;\n    }\n}\n\n/**\n * @brief Collect SCC from the graph\n * @param graph pointer to graph\n * @param stack pointer to a stack pointer\n * @param visited boolean array indicating whether index has been visited or not\n */\nvoid collect_scc(Graph *graph, Stack **stack, bool *visited) {\n    bool *deleted = (bool *) alloca(graph->num_vertices * sizeof(bool));\n    memset(deleted, false, graph->num_vertices * sizeof(bool));\n    int c = 1;\n    while (!stack_is_empty(stack)) {\n        int v = stack_pop(stack);\n        if (!deleted[v]) {\n            memset(visited, false,\n                   graph->num_vertices *\n                   sizeof(bool));  // mark all vertices of reverse as not visited\n            printf(\"Strongly Connected Component #%d: \", c);\n            dfs_and_print(graph, visited, deleted, v);\n            printf(\"\\n\");\n            c++;\n        }\n    }\n}\n\n/**\n * @brief Kosaraju logic\n * @param graph pointer to graph\n */\nstatic void kosaraju(Graph *graph) {\n    Stack *stack;\n    stack_create(&stack);\n\n    size_t visited_size = graph->num_vertices * sizeof(bool);\n    bool *visited = (bool *) alloca(visited_size);\n    memset(visited, false, visited_size);\n    int i = 0;\n    for (i = 0; i < graph->num_vertices; i++) {\n        if (!visited[i]) {\n            dfs(graph, &stack, visited, i);\n        }\n    }\n\n    Graph *reversed_graph = reverse(graph);\n    collect_scc(reversed_graph, &stack, visited);\n}\n\nint main() {\n    Graph *graph = graph_create(10);\n    graph_add_edge(graph, 1, 2);\n    graph_add_edge(graph, 2, 1);\n\n    graph_add_edge(graph, 3, 4);\n    graph_add_edge(graph, 4, 5);\n    graph_add_edge(graph, 5, 6);\n    graph_add_edge(graph, 6, 7);\n    graph_add_edge(graph, 7, 3);\n\n    kosaraju(graph);\n\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nThe problem was my ```\nstack_pop```\n method was returning a boolean indicating if poping from the stack was successful or not but in ```\ncollect_scc```\n I was using the returned value (i.e. ```\nboolean```\n) as the value that has just been popped from the stack.\n```\nstatic bool stack_pop(Stack **stack, int* v) {\n    Stack *old = *stack;\n    if (!old)\n        return false;\n\n    *v = old->value;\n    *stack = old->next;\n    free(old);\n    return true;\n}\n```\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Why do we need to run DFS on the complement of a graph in the Kosaraju's algorithm?\r\n                \r\nThere's a famous algorithm to find the strongly connected components called ```\nKosaraju's algorithm```\n, which uses two DFS's to solve this problem, and runs in ```\nθ(|V| + |E|)```\n time. \n\nFirst we use DFS on complement of the graph (```\nG```\nR) to compute reverse postorder of vertices, and then we apply second DFS on the main graph ```\nG```\n by taking vertices in reverse post order to compute the strongly connected components. \n\nAlthough I understand the mechanics of the algorithm, I'm not getting the intuition behind the need of the reverse post order. \n\nHow does it helps the second DFS to find the strongly connected components?\n    ", "Answer": "\r\nsuppose result of the first DFS is:\n```\n----------v1--------------v2-----------```\n\nwhere \"-\" indicates any number and all the vertices in a strongly connected component g appear between v1 and v2.\nDFS by post order gives the following guarantee that\n\nall vertices after v2 would not points to g in the reverse graph(that is to say, you cannot reach these vertices from g in the origin graph)\nall vertices before v1 cannot be pointed to from g in the reverse graph(that is to say, you cannot reach g from these vertices in the origin graph)\n\nin one word, the first DFS ensures that in the second DFS, strongly connected components that are visited earlier cannot have any edge points to other unvisited strongly connected components.\nSome Detailed Explanation\nlet's simplify the graph as follow:\n\nthe whole graph is G\nG contains two strongly connected components, one is g, the other one is a single vertex v\nthere is only one edge between v and g, either from v to g or from g to v, the name of this edge is e\ng', e' represent the reverse of g, e\n\nthe situation in which this algorithm could fail can be conclude as\n\nstart DFS from v, and e' points from v to g'\nstart DFS from a vertex inside of g', and e' points from g' to v\n\nFor situation 1\norigin graph would be like ```\ng-->v```\n, and the reversed graph looks like ```\ng'<--v```\n.\nTo start the second DFS from v, the post order generated by first DFS need to be something like\n```\ng1, g2, g3, ..., v```\n\nbut you would easily find out that neither starting the first DFS from v nor from g' can give you such a post order, so in this situation, it is guaranteed be the first DFS that the second DFS would not start from a vertex that both be out of and points to a strongly connected component.\nFor situation 2\nsimilar to the situation 1, in situation 2, where the origin graph is ```\ng<--v```\n and the reversed on is ```\ng'-->v```\n, it is guaranteed that v would be visited before any vertex in g'.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "what does \"not strongly connected graph\" means in centiserve centroid computation?\r\n                \r\nAs in the question, I have four different networks which I load from 4 different csv files. Each one fails when I compute the centroid using centiserve library. On the other hand, if I generate a random ER network, the centroid computation works.\nI looked into the centroid funcion and eventually I found it checks whether the network is connected using an igraph this function ```\nis.connected(g, mode=\"strong\")```\n\nAccording to wikipedia a graph is strongly connected if all the nodes are reachable from a random node in the network. To this aim, I calculated the components of my network, using igraph's ```\ndecompose()```\n function and all the networks have a single connected component: ```\nlength(decompose(net))```\n is always equal to 1. But, ```\ncentroid(net)```\n is always returning the error.\nEventually, the question is: What exactly is this function looking for when it verifies if the graph is suitable? Why my network has a single connected component but the ```\nis.connected()```\n function of igraph return False?\nSome code:\n```\n#load file\nfinalNet <- read.csv(\"net.csv\", sep=\",\", header=T)\n#get network\nnet <- graph_from_data_frame(finalNet[, c(1, 2)])\n#decompose says that there is a single connected component\nlength(decompose(net))\n#while centroid does not work!\ncentroid(net)\n```\n\nthe network is available here\n    ", "Answer": "\r\nok, I found the answer. The problem is that the function graph_from_data_frame create a directed network, if not specified otherwise.\nHence, the solution to make my example work is to load the network as not directed:\n```\nnet <- graph_from_data_frame(finalNet[, c(1, 2)], directed=F)\n```\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Minimize set of edges in a directed graph keeping connected components\r\n                \r\nHere is the full question:\n\nAssume we have a directed graph G = (V,E), we want to find a graph G' = (V,E') that has the following properties: \n\n\nG' has same connected components as G\nG' has same component graph as G\nE' is minimized. That is, E' is as small as possible.\n\n\nHere is what I got:\n\nFirst, run the strongly connected components algorithm. Now we have the strongly connected components. Now go to each strong connected component and within that SCC make a simple cycle; that is, a cycle where the only nodes that are repeated are the start/finish nodes. This will minimize the edges within each SCC.\n\nNow, we need to minimize the edges between the SCCs. Alas, I can't think of a way of doing this.\n\nMy 2 questions are: (1) Does the algorithm prior to the part about minimizing edges between SCCs sound right? (2) How does one go about minimizing the edges between SCCs.\n\nFor (2), I know that this is equivalent to minimizing the number of edges in a DAG. (Think of the SCCs as the vertices). But this doesn't seem to help me.\n    ", "Answer": "\r\n\nThe algorithm seems right, as long as you allow for closed walks (i.e. repeating vertices.) Proper cycles might not exist (e.g. in an \"8\" shaped component) and finding them is NP-hard.\nIt seems that it is sufficient to group the inter-component edges by ordered pairs of components they connect and leave only one edge in each group.\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "How to get the strongly connected components of a Rascal context-free grammar\r\n                \r\nas the question states, I would like to be able to convert a grammar to a set of strongly connected (non-terminal only) components. I want to do this by constructing a graph from the grammar and then call the connected-components function. Which brings me to the real problem: how to construct this directed graph that has edges of the type:\n\n```\nFor each A -> xBz where A,B in Non-terminals (N) and x and y in (sigma U N)*:\n    construct an edge from A to B\n```\n\n\nIs something that does similar things to this build in, or would I have to completely implement this myself? If so, could you help me get started, by for example showing how to get only terminals, non-terminals and production rules from a grammar? Instead of only by machine parseable grammar-data structure?\n\nIf there is a better way to find the components instead of constructing the graph that would be a great answer as well of course.\nI hope this is clear enough, if not, just let me know!\n\nEdit: The algorithm is relatively easy I think, I just don't see how to do this in Rascal. Here is a picture of the algorithm in pseudo-code.\nHere grammar.V are its non-terminals and P its production rules (different definition, so different naming :s)\n    ", "Answer": "\r\nFirst get a grammar for your syntax like so:\n\n```\nimport Grammar;\ngr = grammar(#YourTopNonterminal);\n```\n\n\nThen you could use this library module (with example code on how to extract dependencies):\n\n```\nimport analysis::grammars::Dependency;\ndeps = symbolDependencies(gr);\n```\n\n\nAnd you'd get a binary relation between dependent symbols like this:\n\n```\nrascal>symbolDependencies(g)\nGraph[Symbol]: {\n  <sort(\"A\"),sort(\"B\")>,\n  <sort(\"B\"),sort(\"C\")>\n}\n```\n\n\nThe basic code for ```\nsymbolDependencies```\n is this:\n\n```\nGraph[Symbol] symbolDependencies(Grammar g) =\n  { <from,to> | /prod(Symbol from,[_*,Symbol elem,_*],_) := g, /Symbol to := elem}\n```\n\n\nThe comprehension loops over all rules of the grammar, takes the head ```\nfrom```\n and then finds all symbols ```\nto```\n in the rule (possibly nested due to regular expressions) and creates a tuple for each pair. \n\nAfter that you'd start analyzing and transforming this relation to get the strongly connected components. The library module ```\nanalysis::graphs::Graph```\n has an example function which computes connected components (not strongly connected components, so you'd have to adapt that).\n\n```\nrascal>import analysis::graphs::Graph;\nok\nrascal>connectedComponents(symbolDependencies(g))\nset[set[Symbol]]: {{\n    sort(\"A\"),\n    sort(\"C\"),\n    sort(\"B\")\n  }}\n```\n\n\nFinally, to print a symbol like ```\nsort(\"A\")```\n back to a pretty name can come in handy, especially if you have regular expressions over non-terminals (like * and +):\n\n```\nrascal>t = type(sort(\"A\"),());\ntype[value]: type(\n  sort(\"A\"),\n  ())\nrascal>\"<t>\"\nstr: \"A\"\n```\n\n\nI'd also recommend visualizing the graphs using ```\nviz::Figure```\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Finding strong connected components?\r\n                \r\nTo find strongly connected components in a directed graph G you need to first find a sink node. To find the sink node,DFS is run on the reverse graph of G-let's call it H. Then the node with the highest post number (the time marking the node was left) would be a source node in H and therefore a sink node in G, allowing us to effectively identify a sink node in G.\n\nInstead of doing all of this, why not simply use the node with the lowest post number in G? If the vertex with the highest post number in a graph in a source node, doesn't it follow that the one with the lowest post number is a sink node? Why over complicate things by finding a source node in the reverse? Why not just use the vertex with the lowest post number in G as the sink node?\n    ", "Answer": "\r\nIt might not be a sink. For example, for DFS from s in the graph\n\n```\ns->a\n^  |\n|  v\nc<-b\n   |\n   v\n   d\n```\n\n\nthe traversal might be\n\n```\nenter(s)\nenter(a)\nenter(b)\nenter(c)\nleave(c)\nenter(d)\nleave(d)\nleave(b)\nleave(a)\nleave(s)\n```\n\n\nso c has the lowest post number but is not a sink.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "How to measure connectivity using Tarjan's algorithm in Apache Age to measure connectivity\r\n                \r\nI have been trying to implement Tarjan's algorithm to measure strongly connected components in a graph Can anyone provide guidance on how to implement Tarjan's algorithm in Apache-Age to measure connectivity between nodes since I could not find anything yet?\nHere is the code in python\n```\nindex = 0\nstack = []\nids = {}\nlowlink = {}\nonStack = {}\nresult = []\n\ndef tarjan(current_node):\n    global index\n    ids[current_node] = index\n    lowlink[current_node] = index\n    index += 1\n    stack.append(current_node)\n    onStack[current_node] = True\n\n    for neighbor in current_node.get_neighbors():\n        if neighbor not in ids:\n            tarjan(neighbor)\n            lowlink[current_node] = min(lowlink[current_node], lowlink[neighbor])\n        elif onStack[neighbor]:\n            lowlink[current_node] = min(lowlink[current_node], ids[neighbor])\n\n    if ids[current_node] == lowlink[current_node]:\n        connected_component = []\n        while True:\n            neighbor = stack.pop()\n            onStack[neighbor] = False\n            connected_component.append(neighbor)\n            if neighbor == current_node:\n                break\n        result.append(connected_component)\n\n```\n\nhow to I implement this code using apache age to measure connectivity?\n    ", "Answer": "\r\nTry following these steps\n\nUse a PostgreSQL database connector in    python to connect to the\ndatabase running AGE.\nUse a Cypher query to retrieve the graph to analyze. The query should\nreturn the nodes and relationships in the graph.\nUse the results of the Cypher query to    build an in-memory\nrepresentation of the graph that you can use as    the input to your\nimplementation of Tarjan's algorithm. You might    represent the\ngraph as an adjacency list or adjacency matrix,    depending on\nwhat's most convenient for your implementation of the    algorithm.\nRun your implementation of Tarjan's algorithm.\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "What does the argument 'weak' or 'strong' do for scipy.sparse.csgraph.connected_components?\r\n                \r\nThe below code demonstrates that the directed graph:\n\n```\nNodes: 0, 1, 2\nEdges: [0 -> 1], [2 -> 1]\n```\n\n\nis considered to be one weakly connected component, and three strongly connected components.\n\n```\nassert(scipy.sparse.csgraph.connected_components(np.array([[0,1,0], [0,0,0], [0,1,0]]), directed=True, connection='weak', return_labels=True) == (1, array([0, 0, 0], dtype=int32)))\n\nassert(scipy.sparse.csgraph.connected_components(np.array([[0,1,0], [0,0,0], [0,1,0]]), directed=True, connection='strong', return_labels=True) == (3, array([1, 0, 2], dtype=int32)))\n```\n\n\nI understand why the strongly connected component return value makes sense -- I cannot traverse from 0 to 2, nor from 1 to 0 or from 1 to 2.\n\nBut according to the docs:\n\n```\ndirectedbool, optional\n    If True (default), then operate on a directed graph: only move\n    from point i to point j along paths csgraph[i, j]. If False,\n    then find the shortest path on an undirected graph: the\n    algorithm can progress from point i to j along csgraph[i, j]\n    or csgraph[j, i].\n\nconnectionstr, optional    \n    [‘weak’|’strong’]. For directed graphs, the type of connection\n    to use. Nodes i and j are strongly connected if a path exists\n    both from i to j and from j to i. Nodes i and j are weakly\n    connected if only one of these paths exists. If directed ==\n    False, this keyword is not referenced.\n```\n\n\nThe 'weak' connected component should not exist, because 2 is not reachable by 1 nor 1 reachable by 2.\n\nWhat's going on here? Is the documentation correct?\n    ", "Answer": "\r\nThe documentation is incorrect and will be updated in a future version of Scipy. See https://github.com/scipy/scipy/issues/9861\n\nThe future documentation will read:\n\n```\nconnection : str, optional\n    ['weak'|'strong'].  For directed graphs, the type of connection to\n    use.  Nodes i and j are strongly connected if a path exists both\n    from i to j and from j to i. A directed graph is weakly connected\n    if replacing all of its directed edges with undirected edges produces\n    a connected (undirected) graph. If directed == False, this keyword\n    is not referenced.\n```\n\n\nwhich is a standard definition for weakly connected.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Find all cycles in the directed graph?\r\n                \r\nTarjan's strongly connected components algorithm  can only find fundamental cycles or all cycles that are in the graph ?\n    ", "Answer": "\r\nIt cannot find all the cycles as long as it runs in O(V + E) (Polynomial time). If it could, it could solve hamiltonian cycle problem in polynomial time but this problem is NP-hard. \n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "2 satisfiability strongly connected components topological ordering\r\n                \r\nI'm solving a two-satisfiability problem with SCCs, and have a question about topological sorting. The algorithm I'm basing this on is to process SCCs in reverse topological order, which is fine when they're all connected. My algorithm is breaking on cases like this:\n\n```\n3 3\n-2 3\n1 -2\n-2 -1\n```\n\n\nThis makes a graph that looks like this:\n\n\nThere are two sources and two sinks in this graph, and depending on where you start there are multiple topological sorts, so there are two possible final nodes. There are no cycles so each node is an SCC. There are multiple paths from source to sink, so when I do reverse topological order I can either start at sink x3 or sink !x2. The path that will give me a correct answer is to start at !x2, which will result in 1, -2, -3 or -1, -2, -3, both of which are solutions. But if I start at x3, one possible outcome is -1, 2, 3, which is not a solution.\n\nSo when I look at my two sinks, how do I decide topologically which is last? Clearly the answer is !x2, but I'm trying to figure out how the algorithm will determine that. I see four possible ideas:\n\n\n!x2 is last because it has more nodes leading into it\n!x2 is last because it is at the end of a longer path\nSet the truth value of each of the sinks before I start processing anything\nThere is no way to know which is last, so create all possible solutions and test each of them to see if it works.\n\n\nOr is there something about topologically ordering SCCs I'm not getting here? This is based on the algorithm I used to pass a Strongly Connected Components assignment in an earlier course, so it can't be completely wrong.\n    ", "Answer": "\r\nWithout seeing your code I can't be sure, but my guess is that  when you process the literals you're setting a value and then flipping it later when you encounter its negation deeper in the topological order.  The key is that once you set a variable, you don't change it again.  Skip the literal of any variable that already has a set value.\n\nEdited to add: From your comment I think I see the problem.  You mention setting the variable x2 to true when !x2 comes first in the reverse topological sort.  You should be setting the literal !x2 to true, which means you set the variable x2 to false.  If you do that, then your solver should work not matter which of the sinks you start with.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "maximum number of cycles in a directed graph with verices=|V| and edges =|E|\r\n                \r\nRespected Sir,\n\nI am working with a specific graphical structure representing 2-player normal form games (game theory). I know that I can compute all strongly connected components of the directed graph in O(V+E) via Tarjans, but was wondering what the complexity of computing all of the simple cycles of a strongly connected component is? AND, if there is a known upper bound on the number of such simple cycles given the number of vertices defining the strongly connected component?\n\nI am looking for any literature/algorithms related to both of these problems. THANK YOU!\n    ", "Answer": "\r\nIn your case the number of possible simple 2k-cycles are ```\n(n choose k) * (m choose k)```\n.  If n, m, and k are not small, this grows exponentially.\n\nEnumerating the cycles is not feasible.  I doubt that it is possible to count them for an arbitrary graph in reasonable time.  Even with dynamic programming techniques this takes exponential time and space (but with a lower exponent than without those techniques).\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Non-recursive version of Tarjan's algorithm\r\n                \r\nI have the following (recursive) implementation of Tarjan's algorithm to find strongly connected components in a graph and it works fine:\n\n```\npublic class StronglyConnectedComponents\n{\n    public static List<List<int>> Search(Graph graph)\n    {\n        StronglyConnectedComponents scc = new StronglyConnectedComponents();\n        return scc.Tarjan(graph);\n    }\n\n    private int preCount;\n    private int[] low;\n    private bool[] visited;\n    private Graph graph;\n    private List<List<int>> stronglyConnectedComponents = new List<List<int>>();\n    private Stack<int> stack = new Stack<int>();\n\n    public List<List<int>> Tarjan(Graph graph)\n    {\n        this.graph = graph;\n        low = new int[graph.VertexCount];\n        visited = new bool[graph.VertexCount];\n\n        for (int v = 0; v < graph.VertexCount; v++) if (!visited[v]) DFS(v);\n\n        return stronglyConnectedComponents;\n    }\n\n    public void DFS(int v)\n    {\n        low[v] = preCount++;\n        visited[v] = true;\n        stack.Push(v);\n        int min = low[v];\n        int edgeCount = graph.OutgoingEdgeCount(v);\n        for (int i = 0; i < edgeCount; i++)\n        {\n            var edge = graph.OutgoingEdge(v, i);\n            int target = edge.Target;\n\n            if (!visited[target]) DFS(target);\n            if (low[target] < min) min = low[target];\n        }\n\n        if (min < low[v])\n        {\n            low[v] = min;\n            return;\n        }\n\n        List<int> component = new List<int>();\n\n        int w;\n        do\n        {\n            w = stack.Pop();\n            component.Add(w);\n            low[w] = graph.VertexCount;\n        } while (w != v);\n        stronglyConnectedComponents.Add(component);\n    }\n}\n```\n\n\nBut on large graphs, obviously, the recursive version will throw a StackOverflowException. Therefore I want to make the algorithm non-recursive.\n\nI tried to replace the function ```\nDFS```\n with the following (non-recursive) one, but the algorithm doesn't work anymore. Can anybody help?\n\n```\nprivate void DFS2(int vertex)\n{\n    bool[] visited = new bool[graph.VertexCount];\n    Stack<int> stack = new Stack<int>();\n    stack.Push(vertex);\n    int min = low[vertex];\n\n    while (stack.Count > 0)\n    {\n        int v = stack.Pop();\n        if (visited[v]) continue;\n        visited[v] = true;\n\n        int edgeCount = graph.OutgoingEdgeCount(v);\n        for (int i = 0; i < edgeCount; i++)\n        {\n            int target = graph.OutgoingEdge(v, i).Target;\n            stack.Push(target);\n            if (low[target] < min) min = low[target];\n        }\n    }\n\n    if (min < low[vertex])\n    {\n        low[vertex] = min;\n        return;\n    }\n\n    List<int> component = new List<int>();\n\n    int w;\n    do\n    {\n        w = stack.Pop();\n        component.Add(w);\n        low[w] = graph.VertexCount;\n    } while (w != vertex);\n    stronglyConnectedComponents.Add(component);\n}\n```\n\n\nThe following code shows the test:\n\n```\npublic void CanFindStronglyConnectedComponents()\n{\n    Graph graph = new Graph(8);\n    graph.AddEdge(0, 1);\n    graph.AddEdge(1, 2);\n    graph.AddEdge(2, 3);\n    graph.AddEdge(3, 2);\n    graph.AddEdge(3, 7);\n    graph.AddEdge(7, 3);\n    graph.AddEdge(2, 6);\n    graph.AddEdge(7, 6);\n    graph.AddEdge(5, 6);\n    graph.AddEdge(6, 5);\n    graph.AddEdge(1, 5);\n    graph.AddEdge(4, 5);\n    graph.AddEdge(4, 0);\n    graph.AddEdge(1, 4);\n\n    var scc = StronglyConnectedComponents.Search(graph);\n    Assert.AreEqual(3, scc.Count);\n    Assert.IsTrue(SetsEqual(Set(5, 6), scc[0]));\n    Assert.IsTrue(SetsEqual(Set(7, 3, 2), scc[1]));\n    Assert.IsTrue(SetsEqual(Set(4, 1, 0), scc[2]));\n}\n\nprivate IEnumerable<int> Set(params int[] set) => set;\n\nprivate bool SetsEqual(IEnumerable<int> set1, IEnumerable<int> set2)\n{\n    if (set1.Count() != set2.Count()) return false;\n    return set1.Intersect(set2).Count() == set1.Count();\n}\n```\n\n    ", "Answer": "\r\nHere is a direct non recursive translation of the original recursive implementation (assuming it's correct):\n\n```\npublic static List<List<int>> Search(Graph graph)\n{\n    var stronglyConnectedComponents = new List<List<int>>();\n\n    int preCount = 0;\n    var low = new int[graph.VertexCount];\n    var visited = new bool[graph.VertexCount];\n    var stack = new Stack<int>();\n\n    var minStack = new Stack<int>();\n    var enumeratorStack = new Stack<IEnumerator<int>>();\n    var enumerator = Enumerable.Range(0, graph.VertexCount).GetEnumerator();\n    while (true)\n    {\n        if (enumerator.MoveNext())\n        {\n            int v = enumerator.Current;\n            if (!visited[v])\n            {\n                low[v] = preCount++;\n                visited[v] = true;\n                stack.Push(v);\n                int min = low[v];\n                // Level down\n                minStack.Push(min);\n                enumeratorStack.Push(enumerator);\n                enumerator = Enumerable.Range(0, graph.OutgoingEdgeCount(v))\n                    .Select(i => graph.OutgoingEdge(v, i).Target)\n                    .GetEnumerator();\n            }\n            else if (minStack.Count > 0)\n            {\n                int min = minStack.Pop();\n                if (low[v] < min) min = low[v];\n                minStack.Push(min);\n            }\n        }\n        else\n        {\n            // Level up\n            if (enumeratorStack.Count == 0) break;\n\n            enumerator = enumeratorStack.Pop();\n            int v = enumerator.Current;\n            int min = minStack.Pop();\n\n            if (min < low[v])\n            {\n                low[v] = min;\n            }\n            else\n            {\n                List<int> component = new List<int>();\n\n                int w;\n                do\n                {\n                    w = stack.Pop();\n                    component.Add(w);\n                    low[w] = graph.VertexCount;\n                } while (w != v);\n                stronglyConnectedComponents.Add(component);\n            }\n\n            if (minStack.Count > 0)\n            {\n                min = minStack.Pop();\n                if (low[v] < min) min = low[v];\n                minStack.Push(min);\n            }\n        }\n    }\n    return stronglyConnectedComponents;\n}\n```\n\n\nAs usual for such direct translations, you need an explicit stack used to store the state that needs to be restored after \"returning\" from the recursive call. In this case, it's the level vertex enumerator and ```\nmin```\n variable.  \n\nNote that the existing ```\nstack```\n variable cannot be used because while the processing vertex is pushed there, it's not always popped on exit (the ```\nreturn```\n line in the recursive implementation), which is a specific requirement for this algorithm. \n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Algorithm to partition graph into complete subgraphs\r\n                \r\nI need an algorithm to partition the vertices of an undirected graph into one or more subgraphs, such that each subgraph is a complete graph (every vertex adjacent to every other vertex). Each vertex needs to be in exactly one of the subgraphs.\n\nHere's an example:\n\n```\ninput = [\n    (A, B),\n    (B, C),\n    (A, C),\n    (B, D),\n    (D, E),\n]\noutput = myalgo(input)  # [(A, B, C), (D, E)]\n```\n\n\nHere's an image that better describes the problem:\n\n\n\nThe input list is sorted in decreasing order by distance, that's why I connect A-B-C instead of B-D. \n\nI thought this might be called \"strongly connected components\", and have already tried the following solutions:\n\n\nFinding a Strongly Connected Components in unDirected Graphs: it's looking for something different\nFinding all cycles in undirected graphs: it gives me many cycles and not the best, it doesn't care about the input order.\nAn algorithm to create clusters from data pairs in python: it connects all the components, just because there is a path between them (A-B-C-D-E).\nKosaraju's algorithm: it works only with a directed graph.\n\n    ", "Answer": "\r\nHere's a class that implements the segmentation into complete subgraphs. It's by no means optimized and can likely be improved significantly, but it's a starting point\n\n```\nclass SCCManager:\n    def __init__(self, edges):\n        self.clusters = []\n        self.edges = edges\n\n    def clusters_in(self, conn):\n        first, second = conn\n        f_clust = None\n        s_clust = None\n        for i, clust in enumerate(self.clusters):\n            if first in clust:\n                f_clust = i\n            if second in clust:\n                s_clust = i\n            # break early if both already found\n            if f_clust and s_clust:\n                break\n        return (f_clust, s_clust)\n\n    def all_connected(self, cluster, vertex):\n        for v in cluster:\n            connected = (v, vertex) in self.edges or (vertex, v) in self.edges\n            # break early if any element is not connected to the candidate\n            if not connected:\n                return False\n        return True\n\n    def get_scc(self):\n        for edge in self.edges:\n            c_first, c_second = self.clusters_in(edge)\n\n            # case 1: none of the vertices are in an existing cluster\n            # -> create new cluster containing the vertices\n            if c_first == c_second == None:\n                self.clusters.append([edge[0], edge[1]])\n                continue\n\n            # case 2: first is in a cluster, second isn't\n            # -> add to cluster if eligible\n            if c_first != None and c_second == None:\n                # check if the second is connected to all cluster components\n                okay = self.all_connected(self.clusters[c_first], edge[1])\n                # add to cluster if eligible\n                if okay:\n                    self.clusters[c_first].append(edge[1])\n                continue\n\n            # case 3: other way round\n            if c_first == None and c_second != None:\n                okay = self.all_connected(self.clusters[c_second], edge[0])\n                if okay:\n                    self.clusters[c_second].append(edge[0])\n                continue\n\n            # case 4: both are in different clusters\n            # -> merge clusters if allowed\n            if c_first != c_second:\n                # check if clusters can be merged\n                for v in self.clusters[c_first]:\n                    merge = self.all_connected(self.clusters[c_second], v)\n                    # break if any elements are not connected\n                    if not merge:\n                        break\n                # merge if allowed\n                if merge:\n                    self.clusters[c_first].extend(self.clusters[c_second])\n                    self.clusters.remove(self.clusters[c_second])\n\n            # case 5: both are in the same cluster\n            # won't happen if input is sane, but doesn't require an action either way\n\n\n        return self.clusters\n```\n\n\n... and here's a working example:\n\n```\ninp = [\n    ('A', 'B'),\n    ('B', 'C'),\n    ('A', 'C'),\n    ('B', 'D'),\n    ('D', 'E'),\n    ('C', 'E')\n]\n\ntest = SCCManager(inp)\nprint(test.get_scc())\n\n[['A', 'B', 'C'], ['D', 'E']]\n```\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Size (number of edges) of strongly connected components (SCC) in a graph using Kosaraju's algorithm\r\n                \r\nI have coded up Kosaraju's two-pass algorithm in Python 3, the current implementation finds SCCs and determines the size of each SCC based on the number of nodes in each SCC. Then, the largest SCCs are determined. How can I change the code so it can calculate the size of each SCC based on the number of edges in each SCC.\n\n```\n# Input : a directed graph, G\nimport sys, threading, time\n\n\n# Increase recursion limit and stack size in windows environment\nsys.setrecursionlimit(2 ** 20)\nthreading.stack_size(67108864)\n\n\n# Source file has one directed edge per line\n# e.g. \"1 5\" is one line. 1 is the tail and 5 is the head\nsource = \"???.txt\"\n# Number of nodes\nn = ???\n\n\ndef main():\n    def Kosaraju(G,G_rev):\n        global leader, finish\n        # Set leader for strongly connected group\n        leader = {}\n        # Set finishing time for each element\n        finish = {}\n        # Run first DFS Loop\n        DFS_Loop(G_rev)\n        # Reorder graph with nodes numbered according to finish time\n        G_reordered = {}\n        g_values = list(G.values())\n        for i in range(1,n+1):\n            temp = g_values[i-1]\n            G_reordered[finish[i]] = [finish[x] for x in temp]\n        # Run second DFS Loop with reordered graph\n        DFS_Loop(G_reordered)\n        return leader\n\n    def DFS_Loop(G):\n        global t,s, explored\n        t = 0 # Number of nodes processed so far (only useful for pass 1)\n        s = 0 # Current source vertex (only useful for pass 2)\n        # Initialize all nodes as unexplored\n        explored = {}\n        for i in range(1,n+1):\n            explored[i] = 0 \n        # Explore each adjacent node i (if unexplored)\n        for i in range(n,0,-1):\n            if explored[i] == 0:\n                s = i\n                DFS(G,i)\n        return\n\n    def DFS(G,i):\n        # Run Depth First Search\n        global t, leader, finish\n        explored[i] = 1 # Mark node i as explored\n        leader[i] = s # Sets leader as node s (useful for second pass only)\n        # For each arc (i,j) in G, if j is not yet explored, recurse on j\n        for j in G[i]:\n            if explored[j] == 0:\n                DFS(G,j)\n        t = t + 1\n        finish[i] = t\n        return\n\n    def get_graph():\n        # Grabs graph from input file\n        # Create dictionary with a key for each node\n        G, G_rev = {}, {}\n        for i in range(1,n+1):\n            G[i], G_rev[i]  = [], []\n        # Populate dictionary with information from file\n        file = open(source)\n        for line in file:\n            list_line = line.split()\n            i = int(list_line[0])\n            j = int(list_line[1])\n            G[i].append(j)\n            G_rev[j].append(i)\n        file.close()\n        return G, G_rev\n\n    def most_common(lst,x):\n        # This functions returns the 'x' most common elements from 'lst' \n        from collections import Counter\n        c = Counter(lst)\n        output = []        \n        for number,count in c.most_common(x):\n            output.append(count)\n        return output               \n\n    if __name__==\"__main__\":\n        G, G_rev = get_graph()\n        leader = Kosaraju(G,G_rev)\n        print(most_common(leader.values(),x))\n\n\nthread = threading.Thread(target=main)\nthread.start()\n```\n\n\nfor example for a graph as (presented below as a list of lists, only for the sake of simplicity):\n[[1,2],[2,3],[2,5],[3,4],[4,1],[5,6],[6,7],[7,5]]\nthe first element is tail and the second element is head.\n\nthe result of the above code, including the size of SCC in decreasing order, is [4,3]\n\nHowever, the current implementation results in the same numbers for a graph as:\n[[1,2],[1,3],[2,3],[2,5],[3,4],[4,1],[5,6],[6,7],[7,5]]\nwhich has an additional edge [1,3]. I want to have [5, 3] as the result. Any help is much appreciated.\n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Ensuring a partially connected digraph is strongly connected\r\n                \r\nContext\n\nI am building a 3d game using procedural generation. I am trying to connect a number of pre-generated rooms in such a way that no matter what, a player can always reach any other room in the map. The rooms have \"possible entry points\" to which connecting hallways must attach. However, not all entry points are reachable from all other entry points within a room. For example, there might be a pit trap, so a player on the bottom would not be able to travel through the room to the top, and would have to find another way around.\n\nProblem\n\nGiven a set of preexisting directed graphs embedded in a 3d space, add a set of (bidirectional) paths of minimal total length that connect the subgraphs into a larger graph. Failing that (since some research indicates that this is NP-Hard) make the paths as short as possible to compute in a short amount of time.\n\nWork so far\n\nMy best solution is based off of this procedural generation post, where he creates a Delaney Triangulation of all nodes. I treat each strongly connected component of the rooms (eg. top floor and bottom floor of the pit trap) as separate nodes, and build the MST off that, but this limits some of the more interesting possibilities (for example, having to do through two 1-directional paths to get back to where you started).\n\n\n\nDoes anyone know of a better method for solving this problem?\n    ", "Answer": "\r\nPerhaps you can take better advantage of the fact that you're modeling 3d space.  That implies you could partition the problem into a set of planar graphs, each one representing a different floor.  You could start by building each floor to be strongly connected.  Then when you join the floors (with probably just a few staircases and pit traps), perturb the solution by removing a few edges while still maintaining an overall strongly connected graph.  Interesting choices for edges to remove would be ones that would cause the floor by itself to lose strong connectedness but maintain the property when other floors are considered.  These are known as bridges, and there is a linear algorithm for finding them.\n\nIf you just count edges and not their lengths, solving for planar graphs (floors) in isolation would transform this into multiple Euclidean Steiner tree problems, which, while still NP-hard, can be solved using a near-optimal polynomial-time approximation scheme.  However, you mentioned you wanted to minimize the total length of the paths, which makes this a rectilinear Steiner tree problem.  Much  research has been done on this problem due to its applicability to circuit design.  Approximations exist that can come within a factor of 1.5 of optimal, which might work better for what you're doing: slightly longer hallways instead of all entrances in one place.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Can the finishing times for Kosaraju's algorithm be generated from the original graph, not the reverse graph?\r\n                \r\nIn Kosaraju's algorithm, finishing times are generated from the reversed graph. Then, the strongly connected components are discovered from the original graph by performing DFS, starting from the greatest to the lowest finishing times generated earlier. \n\nCan the finishing times for Kosaraju's algorithm be generated from the original graph? Then, could the strongly connected components be discovered by performing DFS, starting from the lowest finishing time to the greatest finishing time?\n\nIt seems to me like it would be the case, but that's just my hunch. \n    ", "Answer": "\r\nNo, this approach will not necessarily work. Consider the following graph:\n```\n  A ---> C\n ^ |\n | |\n | v\n  B\n```\n\nLet's try running your proposed algorithm. We'll begin running the DFS at node A, and whenever we have a choice of which node to visit next, we'll pick the alphabetically first. The DFS will look like this:\n\nBegin exploring A.\n\nBegin exploring B.\n\nFinish exploring B.\n\n\nBegin exploring C.\n\nFinish exploring C.\n\n\n\n\nFinish exploring A.\n\nThat gives us the finishing times as B, C, A.\nIf we now run a DFS in the original graph, going in the order of finishing times, our first DFS will be from node B. That will find nodes A, B, and C, and so we'd incorrectly conclude that {A, B, C} is a strongly connected component of the graph, even though the SCCs here are actually {A, B} and C.\nWe could then ask - why doesn't this work? That is, what's so special about going in reverse? The answer is that if we run a DFS and record the finishing times of the nodes, the first node visited in each SCC will have the last finishing time of all the nodes in the SCC. That's why the very last node we find in the ordering must be in a source SCC, for example. On the other hand, the finishing times of the other nodes in the SCCs are not guaranteed to have any particular properties. (That's how I found this graph - I constructed it so that the first node to finish in one of the SCCs would be sequenced before a node in one of the sink SCCs).\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Nodes or set of nodes connected to a subgraph networkx\r\n                \r\nI have 2 graphs A and B. B is a strongly connected subgraph of A. I want to find the node(s) in A that have a path to any of the nodes in B. How do I do this in Networkx?\n\nNB: I have already tried using weakly connected components but it didn't work.\n    ", "Answer": "\r\nIf ```\nB```\n is strongly connected, then if you choose any node ```\nu```\n in ```\nB```\n, then if some node ```\nx```\n in ```\nA```\n has a path to some node ```\nb```\n in ```\nB```\n, then there is a path from ```\nx```\n to ```\nu```\n (there is a path from ```\nb```\n to ```\nu```\n because ```\nB```\n is strongly connected and then the ```\nx```\n to ```\nb```\n to ```\nu```\n path exists).  So having a path to any node in ```\nB```\n is the same thing as having a path to one specific node in ```\nB```\n.  Let ```\nX```\n be the set of nodes with a path to ```\nu```\n.  This is the set you want.\n\nIf you do ```\nX = nx.ancestors(A, u)```\n then ```\nX```\n is the set of nodes with a path to ```\nu```\n.  If you want the subgraph itself, then do ```\nG = A.subgraph(X)```\n, but if you just want the set of nodes, then it's ```\nX```\n.\n\n\n\nNote - this is effectively the algorithm used in the Epidemics on Networks package https://epidemicsonnetworks.readthedocs.io/en/latest/ (which I wrote) for estimating the probability of an epidemic using directed percolation.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "How is Johnson's algorithm not polynomial?\r\n                \r\nI've read in multiple answers that finding all the cycles in a directed graph is NP-complete, but Johnson's algorithm, which finds all simple cycles in a graph, runs in O((V+E)(C+1)) time (where C is the number of strongly connected components in the graph), which I think is polynomial, since E <= V^2 and C <= V which becomes O(V^3), right?\n\nJohnson's algorithm: http://www.cs.tufts.edu/comp/150GA/homeworks/hw1/Johnson%2075.PDF\n    ", "Answer": "\r\nAccording to the PDF you linked, the quantity C here refers not to the number of strongly connected components, but rather to the number of simple cycles in the graph. In other words, the algorithm lists off each of the c simple cycles in the graph, spending at most O(|V| + |E|) time before reporting each of them. Since the number of different simple cycles in a graph can be exponentially large, this algorithm will run in exponential time in the worst-case.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "find cycles of specific length\r\n                \r\nis it possible to find all the cycles of order 5 for example in a graph with 15 vertex. I heard about biconnected componenents but my graph is only one strongly connected components.\n    ", "Answer": "\r\nAt the max there are 15P5 = 360,360 options for the cycles, so a simple brute force would be enough \n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Find a group of unreachable nodes (from each other)\r\n                \r\nLet there be a directed Graph G.\nU is a set of 'black' vertices in G Such That:\n\nEvery element of G\\U (whites) has a path to a black vertice.\nThere is no path between any elements of U( black).\n\nGive me an algorithm searches for the group U in this graph.\nOfficial Solution from my proffesor:\n\nUse kosaraju's algorithm for Strongly Connected Components.\nFind the graph of Strongly connected components.\nEvery subgraph is a node in GSCC, for every subgraph in GSCC that has outdegree 0, mark one of the nodes inside the subgraph as black.\n\n    ", "Answer": "\r\nIf a black vertex is not allowed a path back to itself then some graphs will have no solution. E.g., any graph which is a cycle. For this reason, I'm assuming you allow black nodes to have paths to themselves, but to no other black node.\n\nBegin by adding all vertices with outdegree zero to U.\nRun BFS backwards from the vertices of U, and let X be the set of vertices BFS never reaches.\nIf X is empty then you're done, otherwise repeatedly do the following:\nPick any vertex in X. Run BFS forwards from it until you reach any vertex for the second time. Remove this vertex from X and color it black (add it to U). Now, run BFS backwards from this vertex, and remove all vertices you reach from X. Repeat all of (4) if X is nonempty.\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Does a path exist through all vertices of a directed graph?\r\n                \r\nGiven G, a directed graph, is there a path (not necessarily a simple path) that goes through all the vertices in G?\n\nI first need to examine what happens in an acyclic graph and in a strongly-connected graph, and then to find a solution for a general graph, using the graph of the strongly connected components.\n\nSo far I have figured out that for a strongly connected graph there is always a path. For an acyclic graph, if there is more than one source a path will never exist. Also, if there is a vertex for which D out is greater than 1, a path will never exist.\n\nThe problem is, I'm not sure that last one is right, and if it's wrong, my algorithm is wrong.\n    ", "Answer": "\r\nThe last assumption is not true, for example have a look at the graph ```\nG = (V,E)```\n, where ```\nE = {(v_i,v_j) | i < j }```\n The graph is obviously a DAG. so finding the maximal strongly connected component won't change the graph. Also - the graph has a hamiltonian path, however ```\nd_out(v_1) > 1```\n [assuming ```\n|V| > 3```\n].\n\nHowever - you are on the right track.\n\nAlgorithm in high level pseudo code:\n\n\nfind Maximal Strongly Connected Components in the graph - the\nresulting graph is a DAG.\nUse topological sort on the resulting graph1. \nCheck if the ordered sorting creates a hamiltonian path\nif it is - return true, else return false\n\n\nClaim:\n\n\n  A path with all vertices exists if and only if the DAG representing\n  the MSCC of the graph has hamiltonian path\n\n\nProof of claim:\n<- \nif there is a hamiltonian path - then such a path is trivial, for each MSCC - the path goes through all vertices, and then to the out edge that is representing the our edge that was chosen in the hamiltonian path in the MSCC graph.\n->\nIf such a path exists, let it be ```\nv0->v1->...vm```\n.\nLet's denote ```\nV_i```\n the maximal strongly connected component in which ```\nv_i```\n lays.\nNow, for the path in the original graph ```\nv0->v1->...->vm```\n, there is also a path in the MSCC graph2: ```\nV_0->V_1->...->V_m```\n.\nNote that if ```\nV_i```\n appears twice [or more] in the above path - the two occurances are adjacent to each other, otherwise the MSCC found is not maximal because if ```\nV_i->V_k->...->V_i```\n is feasible path - then V_i and V_k are not maximal, since you can unite them into one bigger SCC.\nNow, for each ```\nV_i```\n collapse all occurances of it into one, and you get yourself a path - where each ```\nV_i```\n appears at most once [we just showed why], and exactly one [since every ```\nv_i```\n was on the original path and we did not remove MSCC's completely - just collapsed them].\nThus - the generated path is a hamiltonian path in the MSCC graph.\n\nProof of correctness of the suggested algrotithm:\nSince we showed hamiltonian path in MSCC graph exists if and only if there exists a requested path in the original graph - then:\n->\nThe algorithm returned true -> The algorithm found a Hamiltonian path in the DAG -> There is a Hamiltonian Path in the Dag [foot-note 1] -> There is a path as requested in the original graph.\n<-\nThe algorithm returned false -> The algorithm did not find a Hamiltonian pat in the DAG -> There is no hamiltonian path in the DAG [foot-note 1] -> There is no path as requested in the original path.\n\nQ.E.D.\n\n\n\n1: in a DAG, there is a unique topological sort if there exists a hamiltonian path, and if there is a hamiltonian path - it is the order of the vertices in the topological sort. Thus, in a DAG - finding a hamiltonian path is easy.\n2: Actually, it is a bit modification, ```\nV_i->V_i```\n is not really an edge on the MSCC, graph but for now let's denote it as one.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Let G=(V, E) directed graph. Let v be a vertex in G, find the number of vertices that take part in non-simple directed paths to v\r\n                \r\nLet G=(V, E) directed graph.\nLet v be a vertex in G, find the number of vertices that take part in non-simple directed paths to v.\nMy attempt:\n\nFind strongly connected components , V_1,V_2...,V_i (using DFS search produces).\n\nPerform topological sorting on the V_1,V_2...,V_i.\n\nSuppose v in V_j.\nPerform DFS on V_1 to V_j and count all vertex in the strongly connected\ncomponents whose size is bigger than 1.\n\n\nIs my solution correct?\n    ", "Answer": "\r\nFirst step: check your graph for cycles.  It there are none, then there are no non-simple paths..\nSecond: check your graph for component count.  If there is 1 component then the number of vertices that take part in non-simple directed paths is equal to the number of vertices in the graph, because every vertex can go to a vertex in a cycle, go around the cycle, and continue to the destination.\nThird: Check  the component that contains v for cycles. It there are none, then there are no non-simple paths.  Otherwise  the number of vertices that take part in non-simple directed paths is equal to the number of vertices in the component.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "How to find if a path exists from one SCC to another?\r\n                \r\nFor a graph, after finding the strongly connected components, how do find the number of SCCs that have a path to each other? I want to find if there is a path to SCC2 from SCC1.\n    ", "Answer": "\r\nYou asked two things:\n\nhow do find the number of SCCs that have a path to each other?\n\nYou can run dfs from every SCC and save what are the SCC that you can reach.\n\nFor example: You run dfs from SCC A and you can reach SCC B and C. (Just check what is the SCC of the node that you are visiting)\nThen you run dfs from another SCC D and you reach SCC A. At this time you can stop your dfs because you have already calculate what are the others.\n\nSo the time complexity is O(n+m)\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Impact on SCCs of adding an edge to a graph\r\n                \r\nThe following question comes from Skiena:\n\nAdding a single directed edge to a directed graph can reduce the number of weakly connected components, but by at most how many components? What about the number of strongly connected components?\n\nHere is my proposed solution. Is this correct?\n\nSuppose a graph G' use one vertex to represent a strongly/weakly connected component (SCC/WCC) of a directed graph G. Then G' is a DAG.\nIf the directed edge we add makes a cycle in the graph then all the vertices in that cycle are in a SCC so we reduce it to one vertex.\nThe number of SCCs reduced is n-1, where n is the number of vertices in the cycle.\n\n    ", "Answer": "\r\nYou're on the right track here. To make this rigorous, you'd need to exhibit a concrete example of a graph that has n strongly connected components where the addition of a single edge reduces everything to a single strongly connected component.\nOne way to do that is to form a chain of n nodes linked in a path, like this:\n\nv1 → v2 → v3 → ... vn\n\nThere are n strongly connected components, each of which consists of a single node.\nHowever, if you add the edge (vn, v1) to the graph, then you'll form a cycle, and all nodes will be in a single strongly connected component, reducing the number from n to 1 in a single edge addition.\nThe situation for weakly connected components is different. Given a directed graph, its weakly connected components are the CCs of the undirected version of the graph. Adding an edge into an undirected graph can only reduce the number of CCs by one, since if you’re as lucky as possible the endpoints of the edge will be in different CCs that are then unified into a single CC. So adding one edge can only drop the number of weakly connected components by one.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Cycle detection in a Multigraph\r\n                \r\nI would like to list all the cycles in an undirected multigraph.\n\nTarjan's strongly connected components algorithm was written for a directed graph.  Will it work for multigraphs? If not, is there an cycle listing algorithm for undirected multigraphs?\n    ", "Answer": "\r\nThere are a few ways to reduce your problem to Tarjan, depending on how you want to count cycles.\n\nFirst, apply two transformations to your graph:\n\n\nConvert to a directed graph by replacing each undirected edge with a pair of opposing directed edges.\nFor each pair of nodes, collapse edges pointing the same direction into a single edge.\n\n\nYou'll be left with a directed graph.  Apply Tarjan's algorithm.\n\nNow, depending on what you consider a cycle, you may or may not be done.  If a cycle is set of nodes (that happen to posses the required edges), then you can read the cycles directly off the transformed graph.\n\nIf a cycle is a set of edges (sharing the required nodes), then you need to \"uncollapse\" the edges introduced in step 2 above.  For each collapsed edge, enumerate along the set of real edges it replaced.  Doing so for each edge in each collapsed cycle will yield all actual cycles in a combinatorial explosion.  Note that this will generate spurious two-cycles which you'll need to prune.\n\nTo illustrate, suppose the original graph has three nodes ```\nA```\n, ```\nB```\n and ```\nC```\n, with two edges between ```\nA```\n and ```\nB```\n, one between ```\nB```\n and ```\nC```\n and one between ```\nA```\n and ```\nC```\n.  The collapsed graph will be a triangle, with one cycle.\n\nHaving found a cycle between the three nodes, walk each combination of edges to recover the full set of cycles.  Here, there are two cycles: both include the ```\nA```\n to ```\nC```\n and ```\nB```\n to ```\nC```\n edges.  They differ in which ```\nA```\n to ```\nB```\n edge they choose.\n\nIf the original graph also had two edges between ```\nB```\n and ```\nC```\n, then there would be four expanded graphs.  The total number of expanded cycles is the product of the edge counts: ```\n4 == 2 * 2 * 1```\n.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "what is the lowelink mean of Tarjan's algorithm\r\n                \r\nI was reading the description of Tarjan's algorithm for finding the strongly connected components in a driected graph.\nBut I find it hard to understand these codes snippet:\n\n```\n if (w.index is undefined) then\n        // Successor w has not yet been visited; recurse on it\n        strongconnect(w)\n        v.lowlink  := min(v.lowlink, w.lowlink)\n      else if (w is in S) then\n        // Successor w is in stack S and hence in the current SCC\n        v.lowlink  := min(v.lowlink, w.index)\n      end if\n```\n\n\nthe fourth and the seventh lines are different, this make me confused.\nAnd in my opinion,the seveth line could write as the same way with the fourth line\n```\nv.lowkink := min(v.lowlink, w.index)```\n\n\nI test this in my program and it works fine, and for me, it's better to understand bcz verdex v cloud reach hight up root, but i couldn't prove itT_T.\n    ", "Answer": "\r\nI wrote a program that enumerated all graphs of size 4, then run each version (with either ```\nmin(v.lowlink, w.index)```\n or ```\nmin(v.lowlink, w.lowlink)```\n if w is in S) and compared the results. Both were exactly identical in all cases, even though w.lowlink and w.index were often different.\n\nThe reason why we can use w.index is this: consider where on the stack S relative to the current node v the other node w is.\n\nIf it's earlier on the stack then it has a smaller index than the current node (because it was visited earlier, duh), so the current node is not the \"head\" of its connected component and that would be reflected in v.lowlink <= w.index < v.index anyway. And it's not like w.lowlink has any particular meaning at this point either, it's in the progress of being computed and doesn't necessarily have its final value yet.\n\nNow, if w is later in the stack than v, then the crucial property that the algorithm depends on is that then w is a descendant of v, not some sibling/cousing node still left there from an earlier recursive call. Or, as it is usually stated in a complete proof, strongly connected components never span several unconnected branches of our search tree (forest). Because since it's an SCC, there must be a path from w to v, and since we are enumerating stuff in a depth-first order, we must have visited v using that path from w before we have finished processing w, so w should be earlier in the stack than v!\n\nAnd if w is a descendant of v then we already got its actual lowlink value the first time we visited it and are not interested in it any more.\n\nOn a side note, it's trivial to get rid of the lowlink property on nodes and make strongconnect return it directly. Then we wouldn't be tempted to check it instead of w.index in the second case =)\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Reason for finding partial order of a graph\r\n                \r\nIn a recent algorithms course we had to form a condensation graph and compute its reflexive-transitive closure to get a partial order. But it was never really explained why we would want to do that in a graph. I understand the gist of a condensation graph in that it highlights the strongly connected components, but what does the partial order give us that the original graph did not?\n\nThe algorithm implemented went like this:\n\n\nFind strongly connected components (I used Tarjan's algorithm)\nCreate condensation graph for the SCCs\nForm reflexive-transitive closure of adjacency matrix (I used Warshall's algorithm)\n\n\nDoing that forms the partial order, but.... what advantage does finding the partial order give us?\n    ", "Answer": "\r\nLike any other data structure or algorithm, advantages are there only if it's properties are needed :-)\n\nResult of procedure you described is structure that can be used to (easily) answer questions like:\n\n\nFor two nodes ```\nx, y```\n. Is it ```\nx<=y```\n and/or ```\ny<=x```\n, or neither?\nFor a node ```\nx```\n, find all nodes ```\na```\n that are ```\na<=x```\n, or ```\nx<=a```\n?\n\n\nThese properties can be used to answer other questions about initial graph (DAG). Like, if adding edge ```\nx->y```\n will produce a cycle. That can be checked by intersecting set ```\nA```\n, of ```\na<=x```\n, and set ```\nB```\n of ```\ny<=b```\n. If ```\nA```\n intersection ```\nB```\n is not empty than edge ```\nx->y```\n creates a cycle.\n\nStructure also can be used to simpler implement algorithms that use graph to describes other dependencies. E.g. ```\nx->y```\n means that result of calculation ```\nx```\n is used for calculation ```\ny```\n. If calculation ```\nx```\n is changed than all calculations ```\na```\n where ```\nx<=a```\n should be re-evaluated or flagged 'dirty' or result of ```\nx```\n removed from a cache.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Let G be a directed graph. There is a special vertex S such that there is a path to this vertex from every other vertex of the graph\r\n                \r\nTo check if a vertex v is a special vertex is it sufficient to show that it is in a sink Strongly connected component? Don't we have to also prove that the underlying undirected graph is connected? If that is the case, what is the best way to check if a vertex is special\n    ", "Answer": "\r\nIt is not sufficient to show that v is in a sink SCC, even if we knew that the undirected form of the graph is connected.  This is because there may be multiple sink SCCs and one sink cannot be reached from another.\n\nIf your question is: \"given a vertex v, what is the best way to determine if v is reachable from every other vertex of the graph,\" then you should start at v and follow all of the edges backwards.  If you can reach every vertex by following edges backwards, then that means v is reachable from every other vertex of the graph.\n\nIf you don't have a specific vertex in mind but want to know if there is any vertex that is reachable from every other vertex, it is similar to this problem.  You use Tarjan's algorithm to turn your graph into a directed acyclic graph of SCCs.  If there is a unique sink SCC in this graph, then every vertex in this sink SCC is reachable from every vertex in the entire graph.  If there is more than one sink SCC, then there does not exist a vertex that is reachable from every other vertex in the graph.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Kosaraju's SCC recursive program terminates automatically while executing on large inputs\r\n                \r\nI am trying to implement Kosaraju's Strongly connected components algorithm  using recursive approach in C++. While the program runs fine on small graphs but terminates in-between execution while running node-ranking step of the algorithm on large graphs having 875714 nodes.\n\nThe function that causes the problem is : Graph::fillOrder(int v, bool visited[], stack &Stack)\n\nFile link : File link: https://drive.google.com/file/d/1aL19d6FCTT9vW70jBGyH-r7MpOOQ7gyz/view?usp=sharing\n\nI went through the net to search for a possible solution to it but couldn't find one. While there are few non-recursive approaches suggesting that recursive approaches hit stack overflow problem, I want to know if that's the case is there any way to solve it ?\n\n```\n#include<iostream>\n#include<list>\n#include<stack>\n#include<fstream>\n\nusing namespace std;\n\nclass Graph{\n    int V;\n    list<int> *adj;\n\n    void fillOrder(int v, bool visited[], stack<int> &stack);\n    void DFSUtil(int v, bool visited[], int &count);\n\npublic:\n    Graph(int V);\n    void addEdge(int v, int w);\n    void printSCCs();\n    Graph getTranspose();\n};\n\nGraph::Graph(int V){\n    this->V = V;\n    adj = new list<int>[V];\n}\n\nvoid Graph::DFSUtil(int v, bool visited[], int &count){\n    visited[v] = true;\n    count++;\n    list<int>::iterator it;\n    for(it = adj[v].begin(); it!=adj[v].end(); it++){\n        if(!visited[*it])\n            DFSUtil(*it, visited, count);\n    }\n}\n\nGraph Graph::getTranspose(){\n    Graph g(V);\n    for(int v=0; v<V; v++){\n        list<int>::iterator it;\n        for(it=adj[v].begin(); it!=adj[v].end(); it++){\n            g.adj[*it].push_back(v);\n        }\n    }\n    return g;\n}\n\n//add edge to graph\nvoid Graph::addEdge(int v, int w){\n    adj[v].push_back(w);\n}\n\n//node ranking function\nvoid Graph::fillOrder(int v, bool visited[], stack<int> &Stack){\n    visited[v] = true;\n\n    list<int> :: iterator it;\n    for(it=adj[v].begin(); it!=adj[v].end(); it++){\n        if(!visited[*it])\n            fillOrder(*it, visited, Stack);\n    }\n\n    Stack.push(v);\n}\n\n//print SCCs\nvoid Graph::printSCCs(){\n    stack<int> Stack;\n\n    //keeping track of nodes visited\n    bool *visited = new bool[V];\n    for(int i=0; i<V; i++){\n        visited[i]=false;\n    }\n\n    //node ranking\n    for(int i=0; i<V; i++){\n        cout<<i<<\" \";\n        if(visited[i]==false){\n            fillOrder(i, visited, Stack);\n        }\n    }\n\n    //computing transpose of the graph\n    Graph gr = getTranspose();\n\n    //reseting visited values for every node to false\n    for(int i=0; i<V; i++){\n        visited[i]=false;\n    }\n    int max_count=0;\n    while(Stack.empty()==false){\n        int v = Stack.top();\n        Stack.pop();\n\n        if(visited[v]==false){\n            int count=0;\n            gr.DFSUtil(v, visited, count);\n            if(count>max_count){\n                max_count = count;\n                cout<<\"\\nMax count: \"<<max_count;\n            }\n        }\n    }\n}\n\nint main() \n{       \n    Graph g(875714);\n\n    ifstream file;\n    file.open(\"SCC.txt\");\n    int s, e;\n    while(file>>s>>e){\n        //eleminating self loops\n        if(s==e)\n            continue;\n        else\n            g.addEdge((s-1), (e-1)); //for files containing nodes from 1\n    }\n    cout << \"Following are strongly connected components in \"\n            \"given graph \\n\"; \n    g.printSCCs();\n\n    return 0; \n} \n```\n\n\nExpected result: print size of each strongly connected component in the graph\n\nActual result: Termination while execution without completing the entire program\n\n\n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Tarjan's algorithm in graph theory\r\n                \r\nI was learning Tarjan's algorithms differently for each to find strongly connected components, to find articulation points and to find bridges in a graph. All uses the concept of finding discovery time and low-link value using dfs and dfs tree.\nLogically, one would think using one algorithm's discovery time and low-link value results, we may not recompute in the other 2 algorithms and reuse them.\nAm I right or are these values calculated specifically based on the underlying algorithm?\n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "How to read a dot file using a Boost Library\r\n                \r\ni am currently using boost graph lib to compute strongly connected component, but the example on their page seems to be too old to work, so how can I read a file into a GraphvizDigraph Object using Boost 1.48 now ?\n    ", "Answer": "\r\nDo you need the full ```\nGraphvizDigraph```\n information?  If you only need some of the vertex and edge properties, you can use ```\nread_graphviz```\n function to load the graph into an ```\nadjacency_list```\n structure.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "can we use only one index array in Tarjan algorithm?\r\n                \r\nIn Tarjan algorithm, there are two index arrays, one numbers the nodes consecutively in the order in which they are discovered. the other represents the smallest index can be reachable from v through v's subtree, this is algorithm's pseudocode\n```\n    tarjan(u)\n{\n    DFN[u]=Low[u]=++Index                      \n    Stack.push(u)                            \n    for each (u, v) in E                    \n        if (v is not visted)              \n            tarjan(v)                \n            Low[u] = min(Low[u], Low[v])\n        else if (v in S)                  \n            Low[u] = min(Low[u], DFN[v])\n    if (DFN[u] == Low[u])                      \n        repeat\n            v = S.pop                  \n            print v\n        until (u== v)\n}\n```\n\nbut I think low array can be removed, and the algorithm changes to\n```\ntarjan(u)\n{\n    if(DFN[u]) // assume all elements in DFN is initialized to 0\n        return DFN[u]\n    DFN[u]=++Index                      \n    Stack.push(u)      \n    res = DFN[u]                     \n    for each (u, v) in E                                          \n        res = min(res, tarjan(v))\n    if (DFN[u] == res)                      \n        repeat\n            v = S.pop                  \n            print v\n        until (u== v)\n    return res\n}\n```\n\nI did some test on small graph, the result is the same with standard tarjan. but I'm not sure if it can find strongly connected components in all kinds of graphs successfully. so is this algorithm right or it can only pass weak test cases.\n    ", "Answer": "\r\nI agree with MrSmith42 that exhaustive enumeration of small examples is a good way to gain confidence.\nEven after adding the missing ```\nreturn res```\n, however, I think that your algorithm is still incorrect. Two vertex graph, 2 → 1. If we traverse 1 and then 2, the value of ```\nres```\n for 2 will be 1, causing {2} to be missed as a strong component.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Euler Circuit in a Directed Graph\r\n                \r\nHow to check if a directed graph is eulerian?\n\n1) All vertices with nonzero degree belong to a single strongly connected component.\n\n2) In degree is equal to the out degree for every vertex. Source: geeksforgeeks\n\nQuestion: \nIn the given two conditions, is the first one strict? I mean why is it really necessary for the graph to be \"strongly\" connected graph? What if the graph is just connected? \n\nI learned that condition 1 can be replaced with weakly connected graph. Again, what if the graph is just connected instead of weakly connected?\nWill be glad to see some examples. \n\nP.S: Consider condition 2 is always fulfilled in the above discussion. And by \"just connected\", I mean there exists a vertex in the graph from which all other vertices are reachable.\n    ", "Answer": "\r\nThis is an interesting question. There is, to the best of my knowledge, no standardized meaning of \"connected\" in the context of a directed graph. The two general notions of connectivity in a directed graph are\n\n\nstrong connectivity, where for any pair of nodes u and v there's a path from u to v and a path from v to u, and\nweak connectivity, where the undirected graph formed by ignoring the directionality on the arrowheads is connected.\n\n\nYour version of the directed graph being \"just connected\" is slightly different than these definitions, but it's related to strong connectivity. Any directed graph can have its nodes partitioned into strongly connected components (SCCs), groups of nodes that can all reach one another. Those strongly connected components form a DAG, where each strongly connected component is a node and there's an edge from one SCC to another if one of the nodes in the first SCC has an edge to a node in the second SCC.\n\nYour definition of the graph being \"just connected\" could then be pinned down like this:\n\n\n\"just connected\": the DAG of SCCs has a source node that can reach all other nodes.\n\n\nNotice that \"just connected\" implies weakly connected, but not the other way around.\n\nIt turns out that, in this case, if you have a graph where each node's indegree happens to equal its outdegree, then if the graph is \"just connected,\" then it has an Euler circuit. If your graph is \"just connected,\" then it's weakly connected. Then, we're going to claim that any weakly connected graph with indegrees equal to outdegrees must be strongly connected as well. To see this, pick any SCC in the DAG of SCCs with no incoming edges. Any edge entering any of the nodes in this SCC must come from within that SCC. As a result, if we went through each node in the SCC and added up the number of edges leaving that node, that total would match the number of incoming edges into each node in the SCC. But then, since the sum of indegrees of nodes equals the sum of outdegrees of the nodes, there can't then be any edges starting within this SCC and ending in another, since all edges are accounted for. Therefore, this SCC has no edges leaving it.\n\nWe've just shown that any source SCC must have no edges to any other SCCs. And since there is some node in some source SCC that can reach every node, this means that there are no other SCCs in the graph, so the graph has just one SCC and is therefore strongly connected.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Finding a group of vertices in a graph so that each vertex can reach k other vertices\r\n                \r\nLet G=(V,E) be a directed graph and k is an integer. I need to find in a linear time the group of vertices so that each vertex in this group can reach exactly k vertices (including itself).\n\nThe first thing I thought about was to use Kosaraju's algorithm in order to find the strongly connected components of the graph. Each vertex inside a connected component can obiously reach at least the vertices in this connected component, so all is left is to see how the components are connected. However, I did not come up with a linear solution.\n\nAny hints?\n\nThanks.\n    ", "Answer": "\r\nYour first step is correct. Each strongly connected components can be substituted with one vertex, for which starting # of reachable vertices is number of elements in this component. After operation of substituting we get directed acyclic graph. Now for each of this super vertices we want to find how many vertices can be reached from it. One idea would be to sort this graph topologically. After this operation all arrows point into one direction. Without loss of generality we can assume they point to the right, so our graph looks more or less like this:\n\n```\na -> b ----> e -> f -> g\n  \\             /\n    -> c -> d -\n```\n\n\nFor each vertex we have its starting counter which we got from first phase of assembling vertices from one strongly connected components. What we would like to do now is go from right to left and for each vertex have set of vertices reachable from it. Operation which we need is fast merge of this sets. Here with help comes Find-Union data structure. You can add one more field to usual ```\nsize```\n and ```\nrank```\n which will store # of reachable vertices and update it as you ```\nunion```\n two sets.\n\nThis will lead to almost linear time: ```\nO(n * alpha(n))```\n where ```\nalpha(n)```\n is inverse of Ackermann function which is very very small. For huge data it will not be bigger than ```\n5```\n, so you can think of it as constant.\n\nI wonder if somebody can make it without ```\nalpha```\n.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Computing numbers of simple path in directed graph containing cycles\r\n                \r\nI am interested in computing total number of simple paths(no node repeated) between two nodes in a graph(sparse, directed and contains cycles). The graph is a strongly connected component.\n\nI initially tried using matrix multiplication, where I raised the adjacency matrix to all powers from 2 through n-1, n being the number of nodes. However this fails because of cycles in graph. For a DAG just computing all these powers and summing them up will do the job.\n    ", "Answer": "\r\nThere is no efficient algorithm for this problem.\n\nThe problem of counting the number of simple paths from vertex s to t is #P-complete.  Therefore, you cannot expect a polynomial-time algorithm that will work in general.  See, e.g., https://cstheory.stackexchange.com/q/20246/5038, https://stackoverflow.com/a/5570751/781723, https://cs.stackexchange.com/q/423/755.\n\nTime to try to find some way to avoid solving this problem, or making do with an approximation algorithm, or something.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Kosaraju’s algorithm for scc\r\n                \r\nCan anyone explain me the logic behind  Kosaraju’s algorithm for finding connected component?\n\nI have read the description, though I can't understand how the DFS on reversed graph can detect the number of strongly connected components.\n\n```\ndef dfs(visited, stack, adj, x):\n    visited[x] = 1\n\n    for neighbor in adj[x]:\n        if (visited[neighbor]==0):\n            dfs(visited, stack, adj, neighbor)\n\n    stack.insert(0, x)\n    return stack, visited\n\ndef reverse_dfs(visited, adj, x, cc):\n    visited[x] = 1\n\n    for neighbor in adj[x]:\n        if (visited[neighbor]==0):\n            cc += 1\n            reverse_dfs(visited, adj, neighbor,cc)\n    print(x)\n    return cc\n\n\ndef reverse_graph(adj):\n    vertex_num = len(adj)\n    new_adj = [ [] for _ in range(vertex_num)]\n    for i in range(vertex_num):\n        for j in adj[i]:\n            new_adj[j].append(i)\n    return new_adj\n\n\ndef find_post_order(adj):\n    vertex_num = len(adj)\n    visited = [0] * vertex_num\n    stack = []\n\n    for vertex in range(vertex_num):\n        if visited[vertex] == 0:\n            stack, visited = dfs(visited, stack, adj, vertex)\n\n    return stack\n\n\ndef number_of_strongly_connected_components(adj):\n    vertex_num = len(adj)\n    new_adj = reverse_graph(adj)\n    stack = find_post_order(adj)\n\n    visited = [0] * vertex_num\n    cc_num = 0\n    while (stack):\n        vertex = stack.pop(0)\n        print(vertex)\n        print('------')\n        if visited[vertex] == 0:\n            cc_num = reverse_dfs(visited, new_adj, vertex, cc_num)\n    return cc_num\n\nif __name__ == '__main__':\n    input = sys.stdin.read()\n    data = list(map(int, input.split()))\n    n, m = data[0:2]\n    data = data[2:]\n    edges = list(zip(data[0:(2 * m):2], data[1:(2 * m):2]))\n    adj = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adj[a - 1].append(b - 1)\n    print(number_of_strongly_connected_components(adj))\n```\n\n\nAbove you can find my implementation. I guess that initial DFS and reverse operation are done correctly, but I can't get how to perform the second DFS properly.\nThanks in advance.\n    ", "Answer": "\r\nThe first thing that you should notice is that the set of strongly connected components is the same for a graph and its reverse. In fact, the algorithm actually finds the set of strongly connected components in the reversed graph, not the original (but it's alright, because both graphs have the same SCC).\n\nThe first DFS execution results in a stack that holds the vertices in a particular order such that when the second DFS is executed on the vertices in this order (on the reversed graph) then it computes SCC correctly. So the whole purpose of running the first DFS is to find an ordering of the graph vertices that serves the execution of the DFS algorithm on the reversed graph. Now I'll explain what is the property that the order of vertices in the stack have and how it serves the execution of DFS on the reversed graph.\n\nSo what is the property of the stack? Imagine S1 and S2 are two strongly connected components in the graph, and that in the reversed graph, S2 is reachable from S1. Obviously, S1 cannot be reachable from S2 as well, because if that was the case, S1 and S2 would collapsed into a single component. Let x be the top vertex among the vertices in S1 (that is, all other vertices in S1 are below x in the stack). Similarly, let y be the top vertex among the vertices in S2 (again, all other vertices in S2 are below y in the stack). The property is that y (which belongs to S2) is above x (which belongs to S1) in the stack.\n\nWhy is this property helpful? When we execute DFS on the reversed graph, we do it according to the stack order. In particular, we explore y before we explore x. When exploring y we explore every vertex of S2, and since no vertex of S1 is reachable from S2 we explore all the vertices of S2 before we explore any vertex of S1. But this holds for any pair of connected components such that one is reachable from the other. In particular, the vertex at the top of the stack belongs to a sink component, and after we're done exploring that sink component, the top vertex again belongs to a sink relative to the graph induced by the not-yet-explored vertices. \n\nTherefore, the algorithm correctly computes all the strongly connected components of the reversed graph, which, as aforesaid, are the same as in the original graph.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Kosaraju's Algorithm Implementation Problem\r\n                \r\n```\n  #include <bits/stdc++.h>\n\nusing namespace std;\n\nmultiset<unsigned long long> connectedComp;\nunsigned long long int counter = 0;\nunsigned long long int numComponents = 0;\n\nclass Graph{\npublic:\n    unsigned long long int size;\n    list<unsigned long long> *adjList;\n    bool *visited;\n    stack<unsigned long long int> s;\n    Graph(unsigned long long int);\n    void addEdge(unsigned long long int,unsigned long long int);\n    void reverse();\n    void DFS1(unsigned long long int);\n    unsigned long long int DFS2(unsigned long long int);\n    void Kosaraju(void);\n    void initialize(void);\n};\n\nGraph::Graph(unsigned long long int s){\n    size = s;\n    adjList = new list<unsigned long long>[size];\n    visited = new bool[size];\n}\n\nvoid Graph::addEdge(unsigned long long int src,unsigned long long int dest){\n    adjList[src].push_back(dest);\n}\n\nvoid Graph::DFS1(unsigned long long int src) {\n    initialize();\n    stack<int> stack;\n    stack.push(src);\n    stack.push(src);\n\n    while(!stack.empty()){\n        src = stack.top();\n        stack.pop();\n        if(!visited[src]){\n            visited[src] = true;\n        }\n        else if(visited[src]) s.push(src);\n\n        for(auto it = adjList[src].begin();it!= adjList[src].end();it++){\n            if(!visited[*it]){ stack.push(*it); stack.push(*it);}\n        }\n    }\n} \n\n\nvoid Graph::initialize(void){\n    for(unsigned long long int i = 0;i<size;i++) visited[i] = false;\n}\n\nunsigned long long int Graph::DFS2(unsigned long long int src){\n    counter = 0;\n    stack<int> stack; \n    stack.push(src); \n\n    while (!stack.empty()) { \n        counter++;\n        src = stack.top(); \n        stack.pop(); \n        if (!visited[src]) \n            visited[src] = true; \n\n        for (auto i = adjList[src].begin(); i != adjList[src].end(); ++i)\n            if (!visited[*i]) \n                stack.push(*i);\n\n    } \n    return counter;\n} \n\nvoid Graph::reverse(){\n    list<unsigned long long> *tempAdj = new list<unsigned long long>[size];\n    list<unsigned long long>::iterator it;\n    for(unsigned long long int i = 0;i<size;i++){\n        it = adjList[i].begin();\n        for(it;it!= adjList[i].end();it++){\n            tempAdj[*it].push_back(i);\n        }\n    }\n    adjList = tempAdj;  \n}\n\nvoid Graph::Kosaraju(void){\n    for(unsigned long long int i = 0;i<size;i++){\n        if(!visited[i]) DFS1(i);\n    }\n    reverse();\n    initialize();\n    while (!s.empty()){\n        unsigned long long int v = s.top(); s.pop();\n        if (!visited[v])\n        {\n            connectedComp.insert(DFS2(v));\n            visited[v] = true;\n            numComponents++;\n        }\n    }\n\n}\n\n\nint main(void){\n    Graph g(11);\n    g.addEdge(0,2);\n    g.addEdge(1,0);\n    g.addEdge(2,1);\n    g.addEdge(2,3);\n    g.addEdge(3,4);\n    g.addEdge(4,5);\n    g.addEdge(5,3);\n    g.addEdge(6,5);\n    g.addEdge(6,7);\n    g.addEdge(7,8);\n    g.addEdge(8,9);\n    g.addEdge(9,6);\n    g.addEdge(9,10);\n    g.Kosaraju();\n    for(auto it = connectedComp.rbegin();it != connectedComp.rend();it++){\n        cout<<*it<<endl;\n    }\n}\n```\n\n\nI made a implemetation of Kosaraju's Algorithm for strongly connected components however my implementation computes wrong number of connected components one of them is in the given code. I wonder what is wrong in terms of logic. For instance my code works with such an order of nodes:\n    Graph g(5); \n    g.addEdge(1, 0); \n    g.addEdge(0, 2); \n    g.addEdge(2, 1); \n    g.addEdge(0, 3); \n    g.addEdge(3, 4); \n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "How to break down Strongly Connected Components (SCC) in a graph to obtain smaller and smaller nested cycles in JavaScript?\r\n                \r\nSo I have been wondering about how to convert complex graphs with nested cycles into simple Directed Acyclic Graphs (DAGs). I think I landed on the solution (not 100% sure). The solution is to use Kosaraju's algorithm, which I have borrowed from here in JavaScript, and got it working on that first link's complex graph.\n\nThe code below isolates these SCCs:\n```\n[\n  [ 'A' ],\n  [ 'C' ],\n  [ 'B' ],\n  [\n    'D', 'J', 'I',\n    'H', 'F', 'E',\n    'K', 'G'\n  ],\n  [ 'M' ],\n  [ 'N' ],\n  [ 'O' ],\n  [ 'L' ]\n]\n```\n\nThe problem is, ```\nD-J-I-H-F-E-K-G```\n actually contains 2 nested cycles (shown in that first link), ```\nF-G-K```\n and ```\nH-I-J```\n. Is there any way to get this code to break down that 8-node SCC into like 4 smaller ones (```\nF-G-K```\n, ```\nH-I-J```\n, ```\nD```\n, ```\nE```\n)? Is there any way to sort of recursively break down the SCCs so they isolate smaller and smaller SCCs? That would be great, because I am thinking how to do like a module system which handles circular dependencies, and if you can have small cycles compose into larger cycles, then you can parallelize some work. In the end, this Kosaraju algorithm at least identifies and returns the broadest cycles it seems in these initial tests, but I would like to get more exact and break down the cycles further if possible.\nIs there any technique which can do this? If so, what should I be looking at, and or if you know how it is implemented that would be helpful to know as well.\nHere is the Kosaraju algorithm code. The first ```\ng1```\n graph is the image above, and the ```\ng2```\n graph is just the 8-node SCC. I tried to run it on just that to see if it would recursively break it down, but sadly it doesn't.\n\r\n\r\n```\nclass Stack {\n  constructor() {\n    this.stack = [];\n  }\n\n  isEmpty() {\n    return this.stack.length == 0;\n  }\n\n  size() {\n    return this.stack.length;\n  }\n\n  push(item) {\n    this.stack.push(item);\n  }\n\n  pop() {\n    if (this.isEmpty()) {\n      throw new Error(\"Stack is empty\");\n    }\n    return this.stack.pop();\n  }\n\n  peek() {\n    if (this.isEmpty()) {\n      throw new Error(\"Stack is empty\");\n    }\n    return this.stack[this.stack.length - 1];\n  }\n}\n\nclass Graph {\n  constructor() {\n    this.vertices = new Set();\n    this.adjacencyMap = new Map();\n    this.adjacencyMapReversed = new Map();\n    this.stack = new Stack();\n    this.colors = new Map();\n  }\n\n  addVertex(vertex) {\n    this.vertices.add(vertex);\n    this.adjacencyMap.set(vertex, new Set());\n    this.adjacencyMapReversed.set(vertex, new Set());\n    this.colors.set(vertex, \"white\");\n  }\n\n  addEdge(v1, v2) {\n    this.adjacencyMap.get(v1).add(v2);\n    this.adjacencyMapReversed.get(v2).add(v1);\n  }\n\n  kosaraju() {\n    for (let v of this.vertices) {\n      if (this.colors.get(v) == \"white\") {\n        this.dfs(v);\n      }\n    }\n\n    for (let v of this.colors.keys()) {\n      this.colors.set(v, \"white\");\n    }\n\n    let connected = [];\n\n    while (!this.stack.isEmpty()) {\n      let v = this.stack.pop();\n      if (this.colors.get(v) == \"white\") {\n        let c = [];\n        this.dfsReversed(v, c);\n        if (c.length > 0) {\n          connected.push(c);\n        }\n      }\n    }\n\n    return connected\n  }\n\n  dfs(vertex) {\n    this.colors.set(vertex, \"gray\");\n\n    let neighbours = this.adjacencyMap.get(vertex);\n    for (let n of neighbours) {\n      if (this.colors.get(n) == \"white\") {\n        this.dfs(n);\n      }\n    }\n\n    this.colors.set(vertex, \"black\");\n    this.stack.push(vertex);\n  }\n\n  dfsReversed(v, c) {\n    this.colors.set(v, \"gray\");\n    c.push(v);\n\n    let neighbours = this.adjacencyMapReversed.get(v);\n    for (let n of neighbours) {\n      if (this.colors.get(n) == \"white\") {\n        this.dfsReversed(n, c);\n      }\n    }\n\n    this.colors.set(v, \"black\");\n  }\n}\n\nconst g1 = new Graph();\n\naddV(g1, 'A')\naddV(g1, 'B')\naddV(g1, 'C')\naddV(g1, 'D')\naddV(g1, 'E')\naddV(g1, 'F')\naddV(g1, 'G')\naddV(g1, 'H')\naddV(g1, 'I')\naddV(g1, 'J')\naddV(g1, 'M')\naddV(g1, 'N')\naddV(g1, 'K')\naddV(g1, 'L')\naddV(g1, 'O')\n\naddE(g1, 'A', ['B', 'C'])\naddE(g1, 'B', ['D', 'G'])\naddE(g1, 'C', ['D'])\naddE(g1, 'D', ['E'])\naddE(g1, 'E', ['F', 'K'])\naddE(g1, 'F', ['G', 'H', 'M'])\naddE(g1, 'G', ['H', 'L', 'N', 'K'])\naddE(g1, 'H', ['I'])\naddE(g1, 'I', ['J'])\naddE(g1, 'J', ['D', 'H'])\naddE(g1, 'M', ['O'])\naddE(g1, 'N', ['O'])\naddE(g1, 'K', ['L', 'F'])\n\nconsole.log(g1.kosaraju());\n\n// just the outer and inner cycles, not the rest:\nconst g2 = new Graph();\n\naddV(g2, \"D\");\naddV(g2, \"E\");\naddV(g2, \"F\");\naddV(g2, \"G\");\naddV(g2, \"H\");\naddV(g2, \"I\");\naddV(g2, \"J\");\naddV(g2, \"K\");\n\naddE(g2, \"D\", [\"E\"]);\naddE(g2, \"E\", [\"F\", \"K\"]);\naddE(g2, \"F\", [\"G\", \"H\"]);\naddE(g2, \"G\", [\"H\", \"K\"]);\naddE(g2, \"H\", [\"I\"]);\naddE(g2, \"I\", [\"J\"]);\naddE(g2, \"J\", [\"D\", \"H\"]);\naddE(g2, \"K\", [\"F\"]);\n\nconsole.log(g2.kosaraju());\n\nfunction addV(g, vertex) {\n  g.addVertex(vertex);\n}\n\nfunction addE(g, vertex, edges) {\n  edges.forEach((edge) => g.addEdge(vertex, edge));\n}```\n\r\n\r\n\r\n\n    ", "Answer": "\r\nHere are two algorithms based on a depth first search traversal of the complex graph found in the question, highlighting the challenges of identifying subcycles as mentioned in @Bergi's comments to the question.\nThe first algorithm applies no heuristics, and simply captures all cycles found during the traversal.\nThe second algorithm, when finding a cycle, orders the chain by the least of the nodes, to eliminate cycles that are duplicate only because the cycle was traversed beginning with a different node in the chain.\n\r\n\r\n```\nnodes = {\n  a: [ 'b', 'c' ],\n  b: [ 'd', 'g' ],\n  c: [ 'd' ],\n  d: [ 'e' ],\n  e: [ 'f', 'k' ],\n  f: [ 'g', 'h' , 'm' ],\n  g: [ 'h', 'k', 'l', 'n' ],\n  h: [ 'i' ],\n  i: [ 'j' ],\n  j: [ 'h', 'd' ],\n  k: [ 'f', 'l' ],\n  l: [],\n  m: [ 'o' ],\n  n: [ 'o' ],\n  o: []\n};\n\n\n\nfunction findCyclesV1( rootNode) {\n\n  function findCycles( node, chain ) {\n    let n = chain.indexOf( node );\n    if ( 0 <= n ) {\n      result.add( chain.slice( n ) );\n      return;\n    } \n      \n    chain += node;\n    \n    for ( let nextNode of nodes[ node ] ) {\n      findCycles( nextNode, chain );\n    }\n  }\n  \n  let result = new Set();\n  findCycles( rootNode, '' );\n  return result;\n}\n\n\nfunction findCyclesV2( rootNode) {\n\n  function findCycles( node, chain ) {\n    let n = chain.indexOf( node );\n    if ( 0 <= n ) {\n      let subChain = chain.slice( n )\n\n      // Normalize the chain by ensuring the lowest node is first.\n      let leastNode = subChain.split('').reduce( ( t, c ) => t = c < t ? c : t );\n      let m = subChain.indexOf( leastNode );\n      \n      result.add( subChain.slice( m ) + subChain.slice( 0, m ) );\n      return;\n    } \n      \n    chain += node;\n    \n    for ( let nextNode of nodes[ node ] ) {\n      findCycles( nextNode, chain );\n    }\n  }\n  \n  let result = new Set();\n  findCycles( rootNode, '' );\n  return result;\n}\n\nconsole.log( 'Algorithm 1: ', [ ...findCyclesV1( 'a' ) ].sort() );\n\nconsole.log( 'Algorithm 2: ', [ ...findCyclesV2( 'a' ) ].sort() );```\n\r\n\r\n\r\n\nA couple of notables about the results of the second algorithm...\n\nThe algorithm assumes that there is a root entry into the graph, that when traversed, can reach all nodes.\nNote that of the cycles ```\nde...```\n, half are due to a side step to node ```\ng```\n which is a node path slipped betwixt nodes ```\nf```\n and ```\nh```\n.  The same holds for node ```\nk```\n which is a side step betwixt nodes ```\ne```\n and ```\nf```\n.\nSubcycle ```\nhij```\n is easily recognizable in the ```\nde...```\n cycles, but the same can't be said for subcycle ```\nfgk```\n, which does appear in cycle ```\ndekfghij```\n, but as ```\nkfg```\n.  So any algorithm that attempts to draw out subcycles will have to take variations of the subcycle node order into consideration.\n\nGiven all of the above, the challenge is to define a data structure that allows for incorporation of sidesteps and subcycles.  In a regexp-ish like way, something along the following lines...\n\n```\nde[k*fg*|[kfg]][hij]```\n\n\n...implying that the cycle must...\n\n```\n1)```\n begin with ```\nde```\n, optionally followed by\n```\n2a)```\n ```\nk*fg*```\n (where ```\nk```\n and ```\ng```\n are optional, and thus this is not a subcycle due to side steps) or\n```\n2b)```\n subcycle ```\nkfg```\n, followed by\n```\n3)```\n subcycle ```\nhij```\n...\n\nNote also that it's not clear whether there will be other substructures that emerge from more complex graphs that will have to be taken into consideration when attempting to incorporate the cyclic flows into a compact data structure...\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Weakly connected graph: If there is a single vertex without incoming edges, is it a mother vertex?\r\n                \r\nThis is just a request for confirmation. I have a simple directed graph which is weakly connected. When I require there to be exactly one vertex with indegree == 0, does it follow that all nodes in the graph are reachable from that vertex?\nI think yes: When I contract the graph (replace all strongly connected components with a single vertex), the result will be a DAG. All vertices with indegree == 0 will be \"roots\" of that DAG. Ex hypothesi, I have only one such vertex, hence the DAG is a tree. (And it will be a single tree, not a forest, because I start with a single weakly connected component.) q. e. d. Am I correct, or have I missed something?\n    ", "Answer": "\r\nIt seems that the graph ```\nA -> B <- C <-> D```\n is a graph where A has an indegree of 0 but one cannot reach C from A.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "How to detect if adding an edge to a directed graph results in a cycle?\r\n                \r\nI came upon wait-for graphs and I wonder, are there any efficient algorithms for detecting if adding an edge to a directed graph results in a cycle?\n\nThe graphs in question are mutable (they can have nodes and edges added or removed). And we're not interested in actually knowing an offending cycle, just knowing there is one is enough (to prevent adding an offending edge).\n\nOf course it'd be possible to use an algorithm for computing strongly connected components (such as Tarjan's) to check if the new graph is acyclic or not, but running it again every time an edge is added seems quite inefficient.\n    ", "Answer": "\r\nIf I understood your question correctly, then a new edge (u,v) is only inserted if there was no path from v to u before (i.e., if (u,v) does not create a cycle).  Thus, your graph is always a DAG (directed acyclic graph).  Using Tarjan's Algorithm to detect strongly connected components (http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm) sounds like an overkill in this case.  Before inserting (u,v), all you have to check is whether there is a directed path from v to u, which can be done with a simple BFS/DFS.\n\nSo the simplest way of doing it is the following (n = |V|, m = |E|):\n\n\nInserting (u,v): Check whether there is a path from v to u (BFS/DFS).  Time complexity: O(m)\nDeleting edges: Simply remove them from the graph.  Time complexity: O(1)\n\n\nAlthough inserting (u,v) takes O(m) time in the worst case, it is probably pretty fast in your situation. When doing the BFS/DFS starting from v to check whether u is reachable, you only visit vertices that are reachable from v. I would guess that in your setting the graph is pretty sparse and that the number of vertices reachable by another is not that high.\n\nHowever, if you want to improve the theoretical running time, here are some hints (mostly showing that this will not be very easy).  Assume we aim for testing in O(1) time whether there exists a directed path from v to u.  The keyword in this context is the transitive closure of a DAG (i.e., a graph that contains an edge (u, v) if and only if there is a directed path from u to v in the DAG).  Unfortunately, maintaining the transitive closure in a dynamic setting seems to be not that simple.  There are several papers considering this problem and all papers I found were STOC or FOCS papers, which indicates that they are very involved. The newest (and fastest) result I found is in the paper Dynamic Transitive Closure via Dynamic Matrix Inverse by Sankowski (http://dl.acm.org/citation.cfm?id=1033207). \n\nEven if you are willing to understand one of those dynamic transitive closure algorithms (or even want to implement it), they will not give you any speed up for the following reason.  These algorithms are designed for the situation, where you have a lot of connectivity queries (which then can be performed in O(1) time) and only few changes in the graph.  The goal then is to make these changes cheaper than recomputing the transitive closure.  However, this update is still slower that a single check for connectivity.  Thus, if you need to do an update on every connectivity query, it is better to use the simple approach mentioned above.\n\nSo why do I mention this approach of maintaining the transitive closure if it does not fit your needs?  Well, it shows that searching an algorithm consuming only O(1) query time does probably not lead you to a solution faster than the simple one using BFS/DFS.  What you could try is to get a query time that is faster than O(m) but worse than O(1), while updates are also faster than O(m).  This is a very interesting problem, but it sounds to me like a very ambitious goal (so maybe do not spend too much time on trying to achieve it..).\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Running DFS on large graph\r\n                \r\nI am trying to find Strongly Connected Components in a large graph implementing Kosaraju's algorithm. It requires running a DFS on a graph in reverse, and then forward. If you're interested the list of edges for this graph are here: https://dl.dropboxusercontent.com/u/28024296/SCC.txt.tar.gz\n\nI can't implement this recursively in Python, it exceeds its recursive limits and crashes if I increase them. I'm trying to implement through iteration.\n\nBelow is my code for 1. Loading the graph in reverse into a Dictionary, and 2. Running the DFS on it iteratively for each node from n -> 1.\n\nThis code runs perfect for small sample graphs but just doesn't run for this large graph. I get it's inefficient but any tips on how to make it work?\n\n```\ndef reverseFileLoader():\n\n    graph = collections.defaultdict(lambda: {'g': [], 's': False, 't': None, 'u': None })\n    for line in open('/home/edd91/Documents/SCC.txt'):\n        k, v = map(int, line.split())\n        graph[v]['g'].append(k)\n\n    return graph\n\ndef DFS(graph, i):\n    global t\n    global source\n    stack = []\n    seen = []\n    seen.append(i)\n    stack.append(i)\n\n    while stack:\n        s = stack[-1]\n        j = len(graph[s]['g']) - 1\n        h = 0\n        while (j >= 0):\n            if graph[s]['g'][j] not in seen and graph[graph[s]['g'][j]]['t'] == None:\n                seen.append(graph[s]['g'][j])\n                stack.append(graph[s]['g'][j])\n                h += 1\n            j -= 1\n\n        if h == 0:\n            if graph[s]['t'] == None:\n                t += 1\n                graph[s]['u'] = source\n                graph[s]['t'] = t \n            stack.pop()\n\ndef DFSLoop(graph):\n    global t\n    t = 0\n    global source\n    source = None\n    i = len(graph)\n    while (i >= 1):\n        print \"running for \" + str(i)\n        source = i\n        DFS(graph, i)\n        i -= 1\n```\n\n    ", "Answer": "\r\nKosaraju's algorithm probably requires that checking whether an element has been seen is an O(1) operation. But your seen data structure has O(n) time membership testing. Converting ```\nseen```\n from a list to a set makes the code execute in a few seconds on my system (after also removing the prints which took up most of the remaining execution time).\n\nFor completeness the changes you need to make are\n\n\nChange ```\nseen = []```\n to ```\nseen = set()```\n\nChange each  ```\nseen.append(...)```\n to ```\nseen.add(...)```\n.\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Finding all edges that appear on at least one s-t path\r\n                \r\nI am looking for an algorithm to solve the following problem:\n\nInput: Directed Graph G, nodes s and t\nOutput: Set of all edges that are part of a simple st-path\n\nA path is simple if no node is visited twice.\nDoes somebody have an idea how to do this?\nThe problem is easy on DAGs as all paths are simple. However, the input graph is not a DAG. I believe that by using a strongly connected component algorithm, the problem can be reduced to the case where G is strongly connected. Unfortunately, I do not know how to proceed further. I'm even unsure whether the problem is polynomially solvable.\n    ", "Answer": "\r\nI've managed to figure out a polynomial-time algorithm for the undirected case. For the directed case, I don't have a full answer, but for reasons I'll outline below I have a weak hunch that the problem is NP-hard.\nThe main insight I'm using is the following. Suppose you have a pair of nodes s and t and you want to determine whether the edge {u, v} appears on some simple path from s to v. This is equivalent to asking whether there are paths Psu and Pvt where Psu runs from s to u, Pvt runs from v to t, and Psu and Pvt have no nodes in common.\nThis is a special case of a problem called the 2-distinct path problem. In that problem, you're given pairs of nodes (w, x) and (y, z) and are asked whether there are node-disjoint paths from w to x and from y to z. This problem has been studied since the 1970s, and we know that\n\nthere exists a polynomial-time algorithm for this problem in the undirected case, but that\nthe directed version of the problem is NP-hard.\n\nThis means that, in the undirected case, we can solve your original problem as follows. Given nodes s and t, for each edge {u, v}, see whether there's a solution to the 2-distinct path problem from s to u and from v to t. If so, record that there is a simple path passing through {u, v}. At the end, report all edges you found this way. Using Tholey's algorithm as a black box solver for the 2-distinct path problem gives a total runtime of O(mn + m2 α(m, n)), where α(m, n) is the inverse Ackermann function.\nThis approach could also be used in the directed case, except that the 2-distinct path problem is NP-hard for directed graphs, even if the one of the terminal nodes has a direct edge to the other start node. That by itself doesn't prove that your original problem is NP-hard because solving your problem doesn't immediately seem to give a way to determine whether there are two disjoint paths from s to t. However, the fact that it's this difficult to determine whether a single edge is on some s-t path is weak heuristic evidence that this is a hard problem.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Can I create a graph in c++ using STL?\r\n                \r\nIm a CS student, learning graphs algorithms theory (DFS, BFS, Dijkstra, Strongly connected components). My question is what is the easiest practical way to work with a graph DS in cpp: Is there any easy way to create a graph and run DFS on it? like an STL adjacency list and ready-to-run DFS using this adjacency list?\n\nthanks :)\n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Algorithm for shortest path to cover all the routes\r\n                \r\nThis is a variation of a question I came across in one of the mock-interview videos.\nAssume there's a bunch of routes ```\nex: [rome->dallas, dallas->rome, london->paris, paris->frankfurt, london->dallas, frankfurt->rome]```\n etc.  Now I want to add a new location to this route ex: delhi. The question is to to find the minimum no. of connections i need to build such that I can cover all the above places from Delhi ?\nMy solution is:\n\nBuild a graph and get the list of strongly connected components in that graph.\nAdd an edge from this new location to at-least one node of every component in the list of SCC's.  Since every node is connected to every other in a SCC, adding an edge to any one of the nodes should work.\n\nDoes this solution make sense ? I'm unable to come up with a way to prove that this can work in every situation.  Is there any drawbacks of this solution ? Please share your inputs/comments.\n    ", "Answer": "\r\nThanks to @Henry, the tricky part of the question is to understand that either finding weakly or even strongly-connected components and just adding one-route each to such components wont do.\nA good example as @Henry pointed out is: ```\nL->P exists; adding Delhi, just needs adding one route to L```\n\nFor the argument against ```\nweakly connected components```\n, consider ```\nL->P<-C; we need atleast two routes but there's only 1 weakly connected component```\n\nMy approach:\n\nSort all cities based on their number of incoming-routes (lowest first) -> Lets call this list as ```\nin_degree_sorted_cities```\n\n\nPop element from this list; and:\na. Add a new route to this city;\nb. Do a BFS and remove all the reachable cities from the ```\nin_degree_sorted_cities```\n list.\n\n\n\nI would consider this approach:\n\nFind all the ```\nconnected-components```\n in the graph.\nTo access all the cities, you just need to add new routes (to and fro route to any one city in each connected-component) to each of these ```\nconnected-sub-graphs```\n.\n\nConnected-component\nAny two nodes in a ```\nconnected-component```\n can be reached from one another either by direct-route or indirect.\nProof by contradiction:\nSince you are looking to add minimum number of connections, I think the proof is straightforward by contraction.\nFor example if u remove any one of those connections to a connected-component, you can no longer access it.\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Implementing Kosaraju's Algorithm for SCC's\r\n                \r\nI am trying to implement Kosaraju's algorithm to find strongly connected components of a directed graph in linear time. The goal is to store and output the list of SCC sizes.\n```\nclass Graph:\n  def __init__(self, edge_list, num_nodes):\n    self.graph = edge_list\n    self.rev_graph = self.reverse_graph()\n    self.num_nodes = num_nodes\n\n    self.traversed_nodes_p1 = []\n    self.traversed_nodes_p2 = []\n\n    self.counter = 0;\n    self.scc_size_list = []\n\n    self.scc_sl()\n\n  def reverse_graph(self):\n    r_graph = [];\n    for e in self.graph:\n      tail = e[0]; \n      head = e[1];\n      r_graph.append([head, tail])\n    r_graph = sorted(r_graph, key = lambda x: x[0])\n    return r_graph\n\n  def dfs_p1(self, starting_node, g, t_nodes): \n    if (starting_node not in t_nodes):\n      t_nodes.insert(0, starting_node)\n    for i in range (len(g)): \n      if (g[i][0] == starting_node and g[i][1] not in t_nodes):\n        self.dfs_p1(g[i][1], g, t_nodes)\n  \n  def dfs_loop_p1 (self):\n    for i in range (1, self.num_nodes+1):\n      self.dfs_p1(i, self.rev_graph, self.traversed_nodes_p1)\n\n  def dfs_p2(self, starting_node, g, t_nodes): \n    if (starting_node not in t_nodes):\n      self.counter += 1\n      t_nodes.append(starting_node)\n    for i in range (len(g)): \n      if (g[i][0] == starting_node and g[i][1] not in t_nodes):\n        self.dfs_p2(g[i][1], g, t_nodes)\n  \n  def dfs_loop_p2 (self):\n    for i in self.traversed_nodes_p1:\n      self.counter = 0\n      self.dfs_p2(i, self.graph, self.traversed_nodes_p2)\n      if self.counter > 0:\n        self.scc_size_list.append(self.counter)\n  \n  def scc_sl (self):\n    self.dfs_loop_p1()\n    self.dfs_loop_p2()\n\n    self.scc_size_list.sort()\n    self.scc_size_list.reverse()\n```\n\nThis code produces the correct output for smaller graphs (Ex. 9 nodes, 15 edges)\n```\ntest_edge_list = [[1,2], [1,9], [2,3], [2,8], [3,4], [3,5], [4,5], [6,5], [6,8], [7,6], [7,9], [8,3], [8,7], [9,2], [9,8]]\ntest = Graph(test_edge_list, 9)\nprint(test.scc_size_list)\n```\n\nbut takes a really long time to work for larger graphs. How can I optimize this?\n    ", "Answer": "\r\nGreat question. Your implementation seems relevantly optimized in terms of speed. There not much you can do to improve your implementation of Kosaraju's algorithm. However, there are other algorithms to find SCCs in faster time. In particular, you should check out:\n\nTarjan's strongly connected components algorithm\nPath-based strong component algorithm\n\nThese algorithms, like Kosaraju's algorithm, run in O(V+E). However, these other algorithms have smaller constants than Kosaraju's algorithm.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Is DFS faster than BFS when searching a specific node in SSC?\r\n                \r\nI want to find shortest path from node to some other node in Strongly Connected Component, the nodes could by chosen arbitrarily. Two searching methods come to mind Depth First Search or Breadth First Search.\nCan be proven that for some situation is one preferable over the other?\nOne situation could be sparse graph vs. dense graph SCC.\n    ", "Answer": "\r\nDFS does not guarantee that if node 1 is visited before another node 2 starting from a source vertex, then node 1 is closer to the source than node 2.\n\nThis can be easily seen from recursive nature of DFS. It visits the 'deeper' nodes or you can say farther from source nodes first. It goes as far as it can from the source vertex and then returns back to unvisited adjacent nodes of visited vertices.\n\nOn the other hand BFS always visits nodes in increasing order of their distance from the source. It first visits all nodes at same 'level' of the graph and then goes on to the next level.\n\nBesides, the use of a non-recursive algorithm (BFS) is more productive purely in practical terms.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Graph traversal, topologicalsort, post-visit number and pre- visit number\r\n                \r\n```\n#Uses python3\n\nimport sys\n\ndef previsit(v, clock, pre):\n    pre[v] = clock\n    clock += 1\n    return pre\ndef postvisit(v, clock, post):\n    post[v] = clock\n    clock += 1\n    return post\n\ndef reverseg(adj):\n    edges = []\n    for i in range(len(adj)):\n    if adj[i] != []:\n        for vertex in adj[i]:\n            edges.append([i, vertex])\n    edgesr = [[j, i] for i, j in edges]\n    adjr = [[] for _ in range(len(adj))]\n    for a, b in edgesr:\n        adjr[a].append(b)\n    return adjr\n\n\n\ndef explore(adj, v, visited, path, clock, pre, post):\n    visited[v] = True\n    path.append(v)\n    pre[v] = clock\n    clock += 1\n\n    for w in adj[v]:\n        if (visited[w] is None):\n            explore(adj, w, visited, path, clock, pre, post)\n\n    post[v] = clock\n    clock += 1\n\n\ndef dfs(adj, visited, clock, pre, post):\n    n = len(adj)\n\n    for v in range(n):\n        if visited[v] is None:\n            explore(adj, v, visited, path, clock, pre, post)\n\n\n\n\n\n\n\n\ndef acyclic(adj):\n\n\n    visited = [None for _ in range(len(adj))]\n\n    adjr = reverseg(adj)\n\n\n    return 0\n\n\nedges = [[1, 2], [2, 3], [1, 3], [3, 4], [1, 4], [2, 5], [3, 5]]\nedges2 = [[], [], [], [], []]\nedges1 = [[1, 2], [4, 1], [2, 3], [3, 1]]\n\nadj = [[] for _ in range(4)]\n\nfor (a, b) in edges1:\n    adj[a - 1].append(b - 1)\n    #adj[b - 1].append(a - 1)\nclock = 1\npre = [None for _ in range(len(adj))]\npost = [None for _ in range(len(adj))]\nvisited = [None for _ in range(len(adj))]\npath = []\n\n#explore(adj, 0, visited, cc, ccnum)\n#print(dfs(adj, visited), acyclic(adj))\nv = 0\nprint(adj)\nprint(dfs(adj, visited, clock, pre, post))\nprint(pre)\nprint(post)\nprint(path)\n```\n\n\nHi, please help check this code, I implemented the pesudocode, but the output of the previsite number and postvisited number is wrong. My task is to find the cycle in a graph, so I have to find the strongly \nconnected components first, running dfs in a reversed graph, and explore the vertex with largest postnumber in the original graph.I stuck at the postnumber\n    ", "Answer": "\r\nThis code is based on the pesudocode, which is a depth-first-search(DFS) algorithm for graph searching, and I'm going to use it to find strongly connected components(SCC) in a graph:\n\n```\nExplore(v):\n  visited(v) ← true\n  previsit(v)\n  for (v,w) ∈ E:\n     if not visited(w):\n        explore(w)\n  postvisit(v)\n```\n\n\nand here:\n\n```\nprevisit(v):\n  pre(v) ← clock\n  clock ← clock + 1\npostvisit(v):\n  post(v) ← clock\n  clock ← clock + 1\n```\n\n\nthe clock here should be a global variable.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Label an edge with number of cycles it participates in\r\n                \r\nGiven a graph ```\nG = (V, E)```\n, using DFS, how do I label each edge with the number of simple cycles it participates in? I am already labeling the nodes with a post-order when I extract the strongly connected components from the graph, so maybe I can use that information somehow.\n\n```\nprivate Integer labelEdges(Node currentNode, Set<Node> component) {\n\n    Integer numLoops = 0;\n    currentNode.onStack = true;\n\n    for (Edge outEdge : currentNode.getEdges()) {\n        Node nextNode = outEdge.getEnd();\n        if (component.contains(nextNode)) {\n            if (nextNode.onStack) {\n                // loop\n                numLoops += 1;\n            }\n            else {\n                numLoops += labelEdges(nextNode, component);\n            }\n            outEdge.cycles = numLoops;\n        }\n\n    }\n    currentNode.onStack = false;\n\n    return numLoops;\n}\n```\n\n\nI can't seem to reason clearly about this. Can anyone point me in the right direction?\n    ", "Answer": "\r\nIt is hard to give you a complete answer without seeing your whole code, but I think this will help. Note that the links provided are for undirected graphs.\n\nI think you should divide the problem in two: \n\n1. Finding all the cycles in a graph (save them on a hash-table or similar)\n\n2. Finding which of those cycles contain certain node.\n\nSolution for 1: For the first step there are a lot of algorithms on-line, like this one that would work with minor tweaks or this one that counts the number of cycles and you can change it to save the cycles it finds.\n\nSolution for 2: This depends on how you save the cycles, but it's a simple search algorithm. \n\nNote that this solution is not optimal if you only want to find the answer for one node one time, but it is really good if you want to be able to find the number of cycles for any given node and any given time.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Get components of a graph (SCC)\r\n                \r\nI am new at algorithm. I am confused about this following graph. I am finding the strongly connected components of the below graph.\nGRAPH\nIf I am not wrong, the connection should be: A > D > E > C > B > F\nCan anyone make sure about that? Or correct me if I am wrong?\nAnd how can I describe / draw that solution? Any idea about this?\nThank you in advance\n    ", "Answer": "\r\nBy definition, strongly connected components are a partition of the graph  into subgraphs such that, within every subgraph, every node is reachable from every node. We can simply apply that definition to your graph to see that\n\nB is a component by itself, because it has no incoming edges.\nG is a component by itself, because it has no outgoing edges.\nC is a component by itself, because its only outgoing edge is to G.\nA, D, E, F is a component. Every node is reachable from every node because they form a cycle.\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "GraphX or GraphFrame - community detection in undirected weighted graph\r\n                \r\nI'm trying to identify strongly connected communities within large group (undirected weighted graph). Alternatively, identifying vertices causing connection of sub-groups (communities) that would be otherwise unrelated.\n\nThe problem is part of broader Databricks solution thus Spark GraphX and GraphFrames are the first choice for resolving it.\n\nAs you can see from attached picture, I need to find vertex \"X\" as a point where can be split big continuous group identified by connected componect algorithms (val result = g.connectedComponents.run())\n\nStrongly connected components method (for directed graph only), Triangle counting, or LPA community detection algorithms are not suitable, even if all weights are same, e.g. 1.\n\nPicture with point, where should be cut big group ST0\n\nSimilar logic is nice described in question \"Cut in a Weighted Undirected Connected Graph\", but as a mathematical expression only.\n\nThanks for any hint.\n\n```\n// Vertex DataFrame\nval v = sqlContext.createDataFrame(List( \n  (1L, \"A-1\", 1),       // \"St-1\"\n  (2L, \"B-1\", 1),\n  (3L, \"C-1\", 1),\n  (4L, \"D-1\", 1),\n\n  (5L, \"G-2\", 1),      // \"St-2\"\n  (6L, \"H-2\", 1),\n  (7L, \"I-2\", 1),\n  (8L, \"J-2\", 1),  \n  (9L, \"K-2\", 1),\n\n  (10L, \"E-3\", 1),     // St-3\n  (11L, \"F-3\", 1),\n  (12L, \"Z-3\", 1),\n\n  (13L, \"X-0\", 1)      // split point\n)).toDF(\"id\", \"name\", \"myGrp\")\n\n// Edge DataFrame\nval e = sqlContext.createDataFrame(List( \n  (1L, 2L, 1),\n  (1L, 3L, 1),\n  (1L, 4L, 1),\n  (1L, 13L, 5),  // critical edge\n  (2L, 4L, 1),\n\n  (5L, 6L, 1),\n  (5L, 7L, 1),\n  (5L, 13L, 7),   // critical edge\n  (6L, 9L, 1),    \n  (6L, 8L, 1),  \n  (7L, 8L, 1),   \n\n  (12L, 10L, 1),\n  (12L, 11L, 1),\n  (12L, 13L, 9),  // critical edge\n  (10L, 11L, 1)\n)).toDF(\"src\", \"dst\", \"relationship\")\n\nval g = GraphFrame(v, e)\n```\n\n    ", "Answer": "\r\nBetweenness centrality seems to be one of the algorithms fitting this problem. This method counts how many shortest paths are going thru each vertex from all shortest paths connecting any pair of other vertices.\n\nAs far as I know, GraphFrame does not have Betweenness centrality and its Shortest Path just provides number of hoops between vertices w/o listing the actual path. Using ```\nbfs```\n (Breadth First Search) method can give us reasonable approximation (note: ```\nbfs```\n doesn't reflect distance/edge length neither; it also treats each graph as directed):\n\n\nEnsure each vertex is defined in both directions to make ```\nbfs```\n treating graph as undirected\nDeclare mutable structure (e.g. ArrayBuffer) ```\npathMembers```\n with following fields ```\n[fromId, toId, pathId, vertexId]```\n\nFor each vertex o in your graph ```\ng.vertices```\n (outer loop)\n\n\nFor each vertex i in your graph ```\ng.vertices.filter($\"id\" < lit(o.id))```\n (inner loop - looks only into i.id smaller than o.id, because shortestPath(o.id, i.id) is exaclty same as shortestPath(i.id, o.id) in undirected graph)\n\n\napply ```\nval paths = g.bfs.fromExpr(\"id = \" + o.id).toExpr(\"id = \" + i.id).run()```\n\ntranspose ```\npaths```\n to store all vertices in the path for each path and store them in ```\npathMembers```\n\n\n\nCalculate how many time was each ```\nvertexId```\n present in each ```\nfromId, toId```\n path (i.e. ```\nvertexId```\n count divided by ```\npathId```\n count for each ```\nfromId, toId```\n pair)\nSum-up the calculation for each ```\nvertexId```\n to obtain betweenness centrality measure\n\n\nVertex \"X\" for the schema will get highest value. Value for vertices directly connected to \"X\" will drop. Difference will be highes if most of the groups cross-connected by \"X\" have comparable size.\n\nNote: if your graph is so large the full Betweenness centrality algorithm will be prohibitively long, sub-set of pairs for shortest path calculation could be selected randomly. Sample size is compromise between acceptable processing time and probability choosing majority of pairs within single branch of the graph.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Tarjan algorithm, recursion mistakes\r\n                \r\nI'm trying to implement the Tarjan's algorithm (to find strongly connected components in a graph).\nI'm stuck in the dfs part of the algorithm where the components counter does not update itself properly. I think it's a problem with my recursion method but I'm not able able to fix it.\nHere is the code:\n```\ndef dfs_scc(graph, node, components_c, nodes_c, connected_components, visited_nodes):\n    nodes_c+=1\n    connected_components[node]=-nodes_c\n    visited_nodes.append(node)\n    last=nodes_c\n    for adj in graph.get_adj(node):\n        if (connected_components[adj[1]]==0):\n            b=dfs_scc(graph, adj[1], components_c, nodes_c, connected_components, visited_nodes)\n            last=min(last, b)\n        elif (connected_components[adj[1]]<0): last=min(last, -connected_components[adj[1]])\n    if (last==-connected_components[node]):\n        components_c+=1\n        print('VISITED NODE QUEUE: ', list(visited_nodes), '; COMPONENTS COUNTER: ', components_c)\n        while(visited_nodes[-1]!=node):\n            w=visited_nodes.pop()\n            connected_components[w]=components_c\n        w=visited_nodes.pop()\n        connected_components[w]=components_c\n    return last\n```\n\nAnd here the output:\n```\nVISITED NODE QUEUE: [0, 1, 6, 2, 4, 5, 7] ; COMPONENTS COUNTER: 1\nVISITED NODE QUEUE: [0, 1, 6, 2, 4, 5] ; COMPONENTS COUNTER: 1\nVISITED NODE QUEUE: [0, 1, 6] ; COMPONENTS COUNTER: 1 \nVISITED NODE QUEUE: [3] ; COMPONENTS COUNTER: 1\n----------------------\nCONNECTED COMPONENT: {0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1}\n```\n\nAs you can see the queue of the visited nodes remove elements in the right order, at first recursion the node 7 is popped out course is just it's in that components; at next recursion the node 2, 4 and 5 are removed belonging to the same component and so on.\nInstead in the final line of the output I've a dictionary (node : component) in which the component value is always the same.\nHave any idea?\nAs asked here is the entire code:\n```\nclass Graph(object):\n    def __init__(self, graph=None):\n        if graph == None: graph = {}\n        self.__graph = graph\n\n    def get_nodes(self): return list(self.__graph.keys())\n\n    def get_edges(self): return self.__generate_edges()\n\n    def __generate_edges(self):\n        edges = []\n        for node in self.__graph:\n            for adj in self.__graph[node]:\n                if node!=adj: edges.append((node, adj))\n        return edges\n\n    def add_node(self, node):\n        if node not in self.__graph: self.__graph[node] = []\n\n    def add_edge(self, edge):\n        if edge[0] in self.__graph: self.__graph[edge[0]].append(edge[1])\n        else:self.__graph[edge[0]] = [edge[1]]\n\n    def get_adj(self, node):\n        adj=[]\n        for edge in self.__generate_edges():\n            if node==edge[0] and edge[0]!=edge[1]: adj.append(edge)\n        return adj\n\ndef scc(graph):\n    #connected_components : {npde0: components, node1: components, node2: components, node3 : components, ...}\n    connected_components={graph.get_nodes()[i]: 0 for i in range(len(graph.get_nodes()))}\n    components_c=nodes_c=0\n    visited_nodes=deque()\n    for node in graph.get_nodes():\n        if (connected_components[node]==0):\n            dfs_scc(graph, node, components_c, nodes_c, connected_components, visited_nodes)\n    return connected_components\n\n\ndef dfs_scc(graph, node, components_c, nodes_c, connected_components, visited_nodes):\n    nodes_c+=1\n    connected_components[node]=-nodes_c\n    visited_nodes.append(node)\n    last=nodes_c\n    for adj in graph.get_adj(node):\n        if (connected_components[adj[1]]==0):\n            b=dfs_scc(graph, adj[1], components_c, nodes_c, connected_components, visited_nodes)\n            last=min(last, b)\n        elif (connected_components[adj[1]]<0):\n            last=min(last, -connected_components[adj[1]])\n    if (last==-connected_components[node]):\n        components_c+=1\n        print('VISITED NODE QUEUE: ', list(visited_nodes), '; COMPONENTS COUNTER: ', components_c)\n        while(visited_nodes[-1]!=node):\n            w=visited_nodes.pop()\n            connected_components[w]=components_c\n        w=visited_nodes.pop()\n        connected_components[w]=components_c\n    return last\n\n\ndef main():\n    g={0: [1, 2], 1: [6], 2: [4], 3: [], 4: [5], 5: [2, 7], 6: [0], 7: []}\n    graph=Graph(g)\n    # nodes=random.randint(1, 10)\n    # for i in range(nodes): graph.add_node(i)\n    # for i in range(0, nodes):\n    #     for j in range(0, nodes):\n    #         graph.add_edge((i, j))\n    cc=scc(graph)\n    print(\"CONNECTED COMPONENTS: \", cc)\n```\n\n    ", "Answer": "\r\nThe issue is that the modification that a function execution brings to ```\ncomponents_c```\n, ```\nnodes_c```\n, must carry back to the caller's variables with the same name, but that is not happening, because these variables are local to their own function execution context. The caller's variables with those names will not be modified by the recursive calls it makes, but they should.\n\nYou can solve this in different ways. One way is to make ```\ndfs_scc```\n a function that is defined within ```\nscc```\n, and to only define the two variables mentioned above in the scope of ```\nscc```\n. Then ```\ndfs_scc```\n can reference those variables via the ```\nnonlocal```\n keyword instead of getting them as arguments, and so modify them in a way that will be seen by all execution contexts in the recursion tree.\n\nHere is how that looks:\n\n```\ndef scc(graph):\n    components_c=nodes_c=0\n\n    # define the recursive function with the scope where the above variables are defined\n    def dfs_scc(graph, node, connected_components, visited_nodes):\n        nonlocal components_c, nodes_c # reference those variables\n\n        nodes_c+=1\n        connected_components[node]=-nodes_c\n        visited_nodes.append(node)\n        last=nodes_c\n        for adj in graph.get_adj(node):\n            if (connected_components[adj[1]]==0):\n                b=dfs_scc(graph, adj[1], connected_components, visited_nodes)\n                last=min(last, b)\n            elif (connected_components[adj[1]]<0):\n                last=min(last, -connected_components[adj[1]])\n        if (last==-connected_components[node]):\n            components_c+=1\n            print('VISITED NODE QUEUE: ', list(visited_nodes), '; COMPONENTS COUNTER: ', components_c)\n            while(visited_nodes[-1]!=node):\n                w=visited_nodes.pop()\n                connected_components[w]=components_c\n            w=visited_nodes.pop()\n            connected_components[w]=components_c\n        return last\n    #connected_components : {npde0: components, node1: components, node2: components, node3 : components, ...}\n    connected_components={graph.get_nodes()[i]: 0 for i in range(len(graph.get_nodes()))}\n    visited_nodes=deque()\n    for node in graph.get_nodes():\n        if (connected_components[node]==0):\n            dfs_scc(graph, node, connected_components, visited_nodes)\n    return connected_components\n```\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Graph library for mono?\r\n                \r\nI'm building a program and I'm going to need to do some basic graph problems: find strongly connected components, find shortest traversal, etc. I know that the quckgraph library works with .net but doesn't port to mono. Does anyone know the best way to get around this, or if there's another library out there I could use?\n    ", "Answer": "\r\nQuickGraph once worked fine with Mono for me. I just downloaded the newest library, referenced it in project, built simple example and still works like a charm. What problem do you have with it in mono?\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "How do I explore a directed graph (DAG) by visting minimum number of starting vertices?\r\n                \r\nGiven a DAG (possibly not strongly connected e.i consisting of several connected components), the goal is to find the minimum number of starting vertices required to visit to fully explore the graph.\n\nOne method I thought of was to generate all permutations of the given vertices and run a topological sort in that order. The one with the minimum backtracks would be the answer.\n\nIs there an efficient algorithm to perform the above task?\n    ", "Answer": "\r\nThis a famous problem called minimum path cover, it's a pity that wiki says nothing about it, you can search it in google.\n\nAs methioned, the minimum path cover problem is NP-hard in normal graph. But in DAG, it can be solved with Matching.\n\nMethod:\n\nDividing each vertex ```\nu```\n into two different vertex ```\nu1```\n and ```\nu2```\n. For every edge ```\n(u->v)```\n in orginal graph, adding edge ```\n(u1->v2)```\n in new graph. Then do any matching algorithm you like. The result is ```\nn - maximum matching```\n, ```\nn```\n is total number of vertex in orginal graph.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "new graph with adding 1 edges and number\r\n                \r\nIn a preparing class for ```\nACM-Contest```\n, our Teacher has given us one printed page of a solved problem. On one page its written that, ```\n2```\n of the following facts are True but she won't say, ```\nwhy or what```\n:\n\n\n  \"with adding new 1 edge to a Directed Graph, how many of these may be\n  true about number of strongly connected component of this graph?\n\n\n```\n+) at most 1 unit is increased.\n\n++) at most 1 unit is decreased.\n\n+++) maybe not changed.\n\n++++) maybe decreased by more than 2 units.\n```\n\n\nanyone could expanded it clearly with our teams? \n    ", "Answer": "\r\n(+) is false (under a generous interpretation of \"increase at most\", i.e., implying that there is no decrease) and (++) is false and (++++) is true because if we add the feedback arc from one end of a path to the other, making it a cycle, then we go from n strong components to 1. (+++) is obviously true.\n\n```\nBefore (4 strong components):\n* --> * --> * --> *\n\nAfter version A (1 strong component):\n___________________\n|                 |\nv                 |\n* --> * --> * --> *\n\nAfter version B (4 strong components):\n___________________\n|                 |\n|                 v\n* --> * --> * --> *\n```\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Using BFS or DFS to determine the connectivity in a non connected graph?\r\n                \r\nHow can i design an algorithm using BFS or DFS algorithms in order to determine the connected components of a non connected graph, the algorithm must be able to denote the set of vertices of each connected component.\n\nThis is my aproach:\n\n\n  1) Initialize all vertices as not visited.\n  \n  2) Do a DFS traversal of graph starting from any arbitrary vertex v.\n  If DFS traversal doesn’t visit all vertices, then return false.\n  \n  3) Reverse all arcs (or find transpose or reverse of graph)\n  \n  4) Mark all vertices as not-visited in reversed graph.\n  \n  5) Do a DFS traversal of reversed graph starting from same vertex v\n  (Same as step 2). If DFS traversal doesn’t visit all vertices, then\n  return false. Otherwise return true.\n  \n  The idea is, if every node can be reached from a vertex v, and every\n  node can reach v, then the graph is strongly connected. In step 2, we\n  check if all vertices are reachable from v. In step 4, we check if all\n  vertices can reach v (In reversed graph, if all vertices are reachable\n  from v, then all vertices can reach v in original graph).\n\n\nAny idea of how to improve this solution?. \n    ", "Answer": "\r\nHow about\n\n\nlet ```\nvertices```\n = input\nlet ```\nresults```\n = empty list\nwhile there are vertices in ```\nvertices```\n:\n\ncreate a set ```\nS```\n\nchoose an arbitrary unexplored vertex, and put it in ```\nS```\n.\nrun BFS/DFS from that vertex, and with each vertex found, remove it from ```\nvertices```\n and add it to ```\nS```\n.\nadd ```\nS```\n to ```\nresults```\n\n\nreturn ```\nresults```\n\n\n\nWhen this completes, you'll have a list of sets of vertices, where each set was made from graph searching from some vertex (making the vertices in each set connected). Assuming an undirected graph, this should work OK (off the top of my head).\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Finding a Number of Cycles in a Graph\r\n                \r\nI have to find the number of cycles in a graph.\nI know Tarjan's strongly connected components algorithm but i have a little bit confusion.\n\nCan I use DFS or BFS to find the number of cycles.Why Not.If IT's is tree will the answer will change\n\nI am asking if there is only one outgoing edge from each node can i use dfs.\n    ", "Answer": "\r\nYes, you can use DFS to find cycles in a graph. There are different types of edges present in graphs, including back edges which are defined as edges that connect a vertex back to one of its previous ancestors in the graph. These are edges that find vertices that had already been discovered in the DFS but not finished yet. By definition, a back edge implies a cycle, so we can use this definition to count the cycles in a graph.\n\nA simple algorithm to do just this involves running DFS and keeping track of discovered vertices in the recursion stack. So, whenever the DFS discovers a new vertex, it is marked as \"discovered\" and placed onto the stack. It will be taken off the stack as soon as it is \"finished\" - when all of the vertex's children have been discovered and the DFS has rewound back to that vertex. If a discovered vertex that is not finished and is thus on that stack is discovered later in the DFS, we know there is a back edge and thus a cycle and can increase a counter by 1 or make note of it however you choose.\n\nTo your question about if this changes with trees - a tree by definition is a data structure with no cycles. Therefore, we never have to worry about looking for cycles in trees.  \n\nI hope this helps!\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Cycle enumeration of a directed graph with multi edges [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 7 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nHow can I find all cyles in a directed graph with multi edges?\n\nGraph example 1:\n\n\n\nCycles: \n1-2-6\n1-2-3-4\n1-2-3-4-5-6\n1-2-6-5-3-4\n3-4-5\n5-6\n\n\nGraph example 2 (multi-edge 4/5):\n\n\n\nCycles: \n1-2-3\n1-4\n1-5\n\n\nNotes: \n\nI don't want to detect a cycle (boolean result), I want to list all cycles.\n\nAny Strongly connected component algorithm is not sufficient for my problem (it would find only one component in both examples).\n\nI'm using the QuickGraph implementation in C#, but I would be happy to see an algorithm in any language.\n    ", "Answer": "\r\nI had fun with this question, thanks! :P\n\nI have a solution in C#. The algorithm to find the cycles is very short(~10 lines), but there is a lot of clutter around it(implementations of the classes Node and Edge for instance).\n\nI've used the variable naming convention that the letter \"e\" represents an edge, the letter \"a\" the node where the edge start, and \"b\" the node it links to. With those conventions, this is the algorithm:\n\n```\npublic static IEnumerable<Cycle> FindAllCycles()\n{\n    HashSet<Node> alreadyVisited = new HashSet<Node>();\n    alreadyVisited.Add(Node.AllNodes[0]);\n    return FindAllCycles(alreadyVisited, Node.AllNodes[0]);\n}\nprivate static IEnumerable<Cycle> FindAllCycles(HashSet<Node> alreadyVisited, Node a)\n{\n    for (int i = 0; i < a.Edges.Count; i++)\n    {\n        Edge e = a.Edges[i];\n        if (alreadyVisited.Contains(e.B))\n        {\n            yield return new Cycle(e);\n        }\n        else\n        {\n            HashSet<Node> newSet = i == a.Edges.Count - 1 ? alreadyVisited : new HashSet<Node>(alreadyVisited);\n            newSet.Add(e.B);\n            foreach (Cycle c in FindAllCycles(newSet, e.B))\n            {\n                c.Build(e);\n                yield return c;\n            }\n        }\n    }\n}\n```\n\n\nIt has an optimization to reuse some Hashsets, and that might be confusing. I've included the following code, which produces exactly the same results, but this implementation doesn't have optimizations, so you can figure out more easily how it works.\n\n```\nprivate static IEnumerable<Cycle> FindAllCyclesUnoptimized(HashSet<Node> alreadyVisited, Node a)\n{\n    foreach (Edge e in a.Edges)\n        if (alreadyVisited.Contains(e.B))\n            yield return new Cycle(e);\n        else\n        {\n            HashSet<Node> newSet = new HashSet<Node>(alreadyVisited);\n            newSet.Add(e.B);//EDIT: thnx dhsto\n            foreach (Cycle c in FindAllCyclesUnoptimized(newSet, e.B))\n            {\n                c.Build(e);\n                yield return c;\n            }\n        }\n}\n```\n\n\nThis uses the following implementations of Node, Edge and Cycle. They're pretty straightforward, although I did put a lot of thought in making everything immutable and members as least accessible as possible.\n\n```\npublic sealed class Node\n{\n    public static readonly ReadOnlyCollection<Node> AllNodes;\n    internal static readonly List<Node> allNodes;\n    static Node()\n    {\n        allNodes = new List<Node>();\n        AllNodes = new ReadOnlyCollection<Node>(allNodes);\n    }\n    public static void SetReferences()\n    {//call this method after all nodes have been created\n        foreach (Edge e in Edge.AllEdges)\n            e.A.edge.Add(e);\n    }\n\n    //All edges linking *from* this node, not to it. \n    //The variablename \"Edges\" it quite unsatisfactory, but I couldn't come up with anything better.\n    public ReadOnlyCollection<Edge> Edges { get; private set; }\n    internal List<Edge> edge;\n    public int Index { get; private set; }\n    public Node(params int[] nodesIndicesConnectedTo)\n    {\n        this.edge = new List<Edge>(nodesIndicesConnectedTo.Length);\n        this.Edges = new ReadOnlyCollection<Edge>(edge);\n        this.Index = allNodes.Count;\n        allNodes.Add(this);\n        foreach (int nodeIndex in nodesIndicesConnectedTo)\n            new Edge(this, nodeIndex);\n    }\n    public override string ToString()\n    {\n        return this.Index.ToString();\n    }\n}\npublic sealed class Edge\n{\n    public static readonly ReadOnlyCollection<Edge> AllEdges;\n    static readonly List<Edge> allEdges;\n    static Edge()\n    {\n        allEdges = new List<Edge>();\n        AllEdges = new ReadOnlyCollection<Edge>(allEdges);\n    }\n\n    public int Index { get; private set; }\n    public Node A { get; private set; }\n    public Node B { get { return Node.allNodes[this.bIndex]; } }\n    private readonly int bIndex;\n\n    internal Edge(Node a, int bIndex)\n    {\n        this.Index = allEdges.Count;\n        this.A = a;\n        this.bIndex = bIndex;\n        allEdges.Add(this);\n    }\n    public override string ToString()\n    {\n        return this.Index.ToString();\n    }\n}\npublic sealed class Cycle\n{\n    public readonly ReadOnlyCollection<Edge> Members;\n    private List<Edge> members;\n    private bool IsComplete;\n    internal void Build(Edge member)\n    {\n        if (!IsComplete)\n        {\n            this.IsComplete = member.A == members[0].B;\n            this.members.Add(member);\n        }\n    }\n    internal Cycle(Edge firstMember)\n    {\n        this.members = new List<Edge>();\n        this.members.Add(firstMember);\n        this.Members = new ReadOnlyCollection<Edge>(this.members);\n    }\n    public override string ToString()\n    {\n        StringBuilder result = new StringBuilder();\n        foreach (var member in this.members)\n        {\n            result.Append(member.Index.ToString());\n            if (member != members[members.Count - 1])\n                result.Append(\", \");\n        }\n        return result.ToString();\n    }\n}\n```\n\n\nThen to illustrate how you might use this small API, I have implemented your two examples.\nBasically it comes down to, create all the nodes by specifying to which nodes they link, then call SetReferences() to, well.... set some references. After that, calling the publicly accessible FindAllCycles() should return all cycles. I've excluded any code to reset the static members, but that is easily implemented. It should just clear all static lists.\n\n```\nstatic void Main(string[] args)\n{\n    InitializeExampleGraph1();//or: InitializeExampleGraph2();\n    Node.SetReferences();\n    var allCycles = FindAllCycles().ToList();\n}\nstatic void InitializeExampleGraph1()\n{\n    new Node(1, 2);//says that the first node(node a) links to b and c.\n    new Node(2);//says that the second node(node b) links to c.\n    new Node(0, 3);//says that the third node(node c) links to a and d.\n    new Node(0);//etc\n}\nstatic void InitializeExampleGraph2()\n{\n    new Node(1);\n    new Node(0, 0, 2);\n    new Node(0);\n}\n```\n\n\nI must note that the indices of the edges in these examples do NOT correspond to the indices in your images, but that is avoidable with a simple lookup.\nThe results: allCycles is for the first example:\n\n```\n{3, 2, 0}\n{5, 4, 2, 0}\n{3, 1}\n{5, 4, 1}\n```\n\n\nallCycles is for the second example:\n\n```\n{1, 0}\n{2, 0}\n{4, 3, 0}\n```\n\n\nI hope you are satisfied with this solution and that you use it. I've barely commented on the code, so I know it might be hard to understand. In that case, please ask and I'll comment on it!\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Appending a list item during reccursion call(at the end I get empty list)\r\n                \r\nI have a list of lists( in total 10 elements) and I am trying to calculate the number of strongly connected components in the graph(but don't worry about it).\n\nHere is how my list look like:\n\n```\ndf_reversed_back =[[9, 7],\n [8, 9],\n [7, 8],\n [6, 9],\n [6, 4],\n [5, 6],\n [4, 5],\n [3, 5],\n [3, 1],\n [2, 3],\n [1, 2]]\n```\n\n\nwhere the first element of the inner list - is vertex number one[9], and second element is a second vertex[7].\n\nMy problem is , that in recursion calls I append a list to the list, that exists outside the function.\n\n```\nall_components = []\nSSC = []\nexplored= []\n#c)modification of DFS\ndef DFS_2_Path(graph,node):\n    #global SSC\n    global all_components\n    explored.append(node)\n    print('Node:',node)\n    #index = [ind for ind,vertex  in enumerate(df_reverse) if vertex[0] == node]\n    for second_vert in graph:\n        print('Second_vert:',second_vert)\n        print('Second_vert[0] == node:',second_vert[0] == node)\n        if second_vert[0] == node:\n            print('second_vert[1] not in explored :',second_vert[1] not in explored)\n            if second_vert[1] not in explored:\n                print('SSC was:',SSC)\n                SSC.append(second_vert[1])\n                print('SSC is:',SSC)\n                print('---------------------------------')\n                print('NEXT ITERATION OF THE INNER LOOP')\n                print('-------------------------------------')\n                DFS_2_Path(graph,second_vert[1])\n            if second_vert[1] in explored and len(SSC)> 0 :#check if second vert is not explored and if it's not a new SSC\n                print('SSC was:',SSC)\n                SSC.append(second_vert[1])\n                print('SSC is:',SSC)\n\n                all_components.append(SSC)\n                print('All_components is :',all_components)\n                SSC[:] = []\n\n    print('All_components was:',all_components)\n\n\nfor i in range(max(df_reversed_back[0]),0,-1):\n    if i not in explored:\n        s = i\n        DFS_2_Path(df_reversed_back,i)\n```\n\n\nAs you see, i want to append SSC to the all_components.\nThe Result must be: all_components = [[7, 8, 9], [4, 5, 6], [1, 2, 3]]\n\nBut at the end I get: all_components =[[], [], []]\n\nCan you tell me where I made a mistake?\n    ", "Answer": "\r\nYou are destroying the contents of ```\nSSC```\n when you do this:\n\n```\nall_components.append(SSC)\nprint('All_components is :',all_components)\nSSC[:] = []\n```\n\n\nThis effectively adds a reference to ```\nSSC```\n to ```\nall_components```\n and then erases the contents of the array the global variable is pointing to.\n\nPerhaps a better way is to create a new SSC when needed by including it as a parameter to the function. \n\nYou can make your function read:\n\n```\ndef DFS_2_Path(graph,node, SSC=None):\n    if SSC == None:\n        SSC = []\n```\n\n\nThen when you call it recursively, pass it into the recursion with:\n\n```\nDFS_2_Path(graph,second_vert[1], SSC)\n```\n\n\nThis will allow each recursive path to get it's own ```\nSSC```\n array and as a bonus, you won't need the global variable.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Efficient way for finding all the complete subgraphs of a given graph (Python)?\r\n                \r\nIs there an efficient way for finding all the fully-connected components (i.e. the complete subgraphs) of a given (undirected) graph with networkx? For example, I have the following adjacency matrix (without self-loops):\n\n```\n    |0 1 1 0 0|\n    |1 0 1 0 0|\nG = |1 1 0 1 0|\n    |0 0 1 0 1|\n    |0 0 0 1 0|\n```\n\n\nwhich corresponds to the following graph \nThe code should return the following tuples of nodes:\n\n```\n(0,1), (1,2), (0,2), (3,4), (2,3), (0,1,2)\n```\n\n\nI know networkx has routines for finding cycles, strongly-connected components, etc, but I cannot find anything about fully-connected components. If it's not possible with networkx, it would also be fine with Numpy + Scipy. Many thanks in advance!\n\nEDIT\n\nThis is what I did:\n\n```\nimport networkx as nx\nimport itertools\n\n\ndef findsubsets(S, m):\n    return set(itertools.combinations(S, m))\n\n\n\nA = np.array([[0, 1, 1, 0, 0],\n              [1, 0, 1, 0, 0],\n              [1, 1, 0, 1, 0],\n              [0, 0, 1, 0, 1],\n              [0, 0, 0, 1, 0]])\n\n\nG = nx.from_numpy_matrix(A)\n\nM = np.sqrt(np.size(A))\n\n\nfor m in range(2, M+1):\n\n    for a in findsubsets(range(0, M), m):\n\n        if(nx.number_of_edges(G.subgraph(a)) == (m**2 - m)/2.):\n\n            print nx.nodes(G.subgraph(a))\n```\n\n\nwhich basically finds all the possible mXm subgraphs of the given one, and then checks if they have the maximum (i.e. (m**2 - m)/2) number of connections. But I was wondering if there is a more efficient way to do that, because the performance of the function ```\nitertools.combinations```\n is not very good for large graphs.\n    ", "Answer": "\r\nOk, I found it. It's simply ```\nlist(nx.find_cliques(G))```\n, just because I didn't know that in graph theory a clique is a fully connected subgraph.\n\nEDIT\n\nMore precisely, ```\nlist(nx.find_cliques(G))```\n finds the maximal cliques, therefore it's not what I need. I found a similar post at this link.\n\nSo the correct answer is to use ```\nlist(nx.enumerate_all_cliques(G))```\n. However, this function returns also cliques of size 1, which I don't like since I don't have self-loops in my graph. Therefore the final solution is to use the following line of code:\n\n```\n[s for s in nx.enumerate_all_cliques(G) if len(s) > 1]\n```\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Enumerating All Minimal Directed Cycles Of A Directed Graph\r\n                \r\nI have a directed graph and my problem is to enumerate all the minimal (cycles that cannot be constructed as the union of other cycles) directed cycles of this graph. This is different from what the Tarjan algorithm outputs. For instance, for the directed graph at this wikipedia page, I would like to get c <-> d and d <-> h as two separated directed cycles.\n\nI don't if this problem is polynomial or not. I ran over a paper \"Enumerating Minimal Dicuts and Strongly Connected Subgraphs\" that seems to conclude that this problem is incremental polynomial (I don't know what it means), but I am unable to extract an algorithm for this article. I am also not sure if a minimal strongly connected component is equivalent to a minimal cycle as I define it.\n\nDoes someone knows the answer to this problem?\n\nThanks in advance!!!\n    ", "Answer": "\r\nIf we are looking for the shortest path cycle, it seems easy enough.\n\n\nJust do a breadth first search on all nodes searching for the shortest path from a node to itself.\nif you find no path, you can remove this node it is in no cycle\nif you find a path, you have found one of your minimal cycles (as we looked for shortest path, we can ensure this cycle can't be the union of two shorter cycles).\n\n\nCollapse all nodes in it in one big new node and adapt edges as necessary.\n\nGo on until there is no node any-more.\nWhen You you have treated all nodes (vertexes) you have the minimal cycles you where looking for... but there is a trick.\n\n\nIf a cycle is expressed using only nodes from the initial set you can keep it \"as is\". But you have to translate \"big nodes\" to paths (common edges between cycles) and every big nodes may be replaced by several such path (at least 2 for a big node of level-1, that is that does not contains big nodes itself). The cycles found are constructed in such a way that you can choose any path and still get a minimal cycle set (no cycle can be get doing the union of two others), but there is several possible such sets. You can add a constraint to always take a shortest path when selecting a path in a big node, but there still can be paths of the same length. So the solution of this problem is clearly enough not unique.\n\nWith this naive approach complexity would be O(V.(E+V)) where V is the number of vertexes and E the number of edges. O(E+V) comes from breadth first and at worst you have to perform a BFS V times. Hence it is definitely polynomial of better. I believe what I described is really O(log(V).(E+V)) in the average case, but I didn't prove it yet (if it's true).\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Segmentation Fault - unordered_map(tarjan's algorithm)\r\n                \r\nI have implemented Tarjan's algorithm to find strongly connected component in a graph and getting Segmentation fault for some large input.\n```\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <stack>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Graph {\npublic:\n    int n, m;\n    unordered_map<int, unordered_set<int>> graph;\n\n    Graph(int n, int m): n(n), m(m) {}\n\n    void add_edge(int u, int v) {\n        graph[u].insert(v);\n        if(graph.find(v) == graph.end()) graph[v] = unordered_set<int>();\n    }\n    \n    void scc_helper(int u, unordered_map<int, int>& disc,  unordered_map<int, int>& low, stack<int>& st, unordered_map<int, bool>& inStack, vector<unordered_set<int>>& scc, int& time) {\n        disc[u] = low[u] = time++;\n        st.push(u);\n        inStack[u] = true;\n\n        for(const int& ch: graph[u]) {\n            if(disc[ch] == 0) {\n                scc_helper(ch, disc, low, st, inStack, scc, time);\n                low[u] = min(low[u], low[ch]);\n            } else if(inStack[ch]) {\n                low[u] = min(low[u], disc[ch]);\n            }\n        }\n        if(disc[u] == low[u]) {\n            scc.push_back(unordered_set<int>());\n            while(st.top() != u) {\n                scc.back().insert(st.top());\n                inStack[st.top()] = false;\n                st.pop();\n            }\n            scc.back().insert(st.top());\n            inStack[st.top()] = false;\n            st.pop();\n        }\n    };\n\n    vector<unordered_set<int>> get_scc() {\n        unordered_map<int, int> disc, low;\n        stack<int> st;\n        unordered_map<int, bool> inStack;\n        vector<unordered_set<int>> scc;\n        \n        int time = 1;\n        for(const auto& p: graph) {\n            if(disc[p.first] == 0) \n                scc_helper(p.first, disc, low, st, inStack, scc, time);\n        } \n        cerr << \"completed\" << endl;\n        return scc;\n    }\n};\n\nvoid read(string& input) {\n    do {\n        getline(cin, input);\n    } while(input.length() > 0 && input[0] == '%');\n}\n\nGraph read_graph() {\n    string input;\n    istringstream ss;\n    int n, m, v;\n\n    read(input); ss.str(input);\n    ss >> n >> m;\n    ss.clear();\n\n    Graph G(n, m);\n\n    for(int u=1; u<=n; u++) {\n        read(input); ss.str(input);\n        while(ss >> v) {\n            G.add_edge(u, v);\n        } ss.clear();\n        if(G.graph.find(u) == G.graph.end()) G.graph[u] = unordered_set<int>();\n    }\n    return G;\n}\n\nint main() {\n    Graph G = read_graph();\n    cerr << \"read input\\n\";\n    vector<unordered_set<int>> scc = G.get_scc();\n\n    cout << scc.size() << \"\\n\";\n}\n```\n\nAfter debugging, I have found that the condition ```\nif(disc[u] == low[u])```\n is not getting evaluated to true when program throws segmentation fault.\nAnother thing is that, Segmentation fault was received on lines ```\ndisc[u] = low[u] = time++;```\n, ```\nst.push(u);```\n and ```\ninStack[u] = true;```\n and at that time there were approx. 20,000 entries in each of the unordered_map and in stack.\nSome details about input:\nfor, n=16384 m=283794, the program is working correctly\nbut for, n=58960 m=269439, it is throwing segmentation fault.\n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "error while creating std::vector object C++ [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                This question is unlikely to help any future visitors; it is only relevant to a small geographic area, a specific moment in time,  or an extraordinarily narrow situation that is not generally applicable to the worldwide audience of the internet. For help making  this question more broadly applicable, visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI've been using STL for a while but today I encountered this error:\n\n```\nerror: no class template named 'rebind' in 'class std::vector<int, std::allocator> >'\n```\n\n\nin the following program: \n\n```\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <climits>\n#include <stack>\n#include <cctype>\n#include <sstream>\nusing namespace std;\n\nvector<int, vector<int> > G[2000005];\nvector<int, vector<int> > Grev[2000005];\nint f[2000005], order[2000005], leader[2000005], t = 0, parent = 0;\nbool explored[2000005];\n\nvoid dfs_reverse(int i) {\n    explored[i] = true;\n    for(vi::iterator it=G[i].begin(); it != G[i].end(); it++)\n        if(!explored[*it])\n            dfs_reverse(*it);\n    t++;\n    f[i] = t;\n}\n\nvoid dfs(int i) {\n    explored[i] = true;\n    leader[i] = parent;\n    for(vi::iterator it=G[i].begin(); it != G[i].end(); it++)\n        if(!explored[*it])\n            dfs(*it);\n}\n\nint main()  {\n    int N, i, j, u, v;\n\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n\n    scanf(\"%d\", &N);\n    for(i=0; i<N; i++)  {\n        scanf(\"%d %d\", &u, &v);\n        if(u > 0)   {\n            if(v > 0)   {\n                G[N + u].push_back(v); G[N + v].push_back(u);\n                Grev[v].push_back(N + u); Grev[u].push_back(N + v);\n            } else  {\n                G[N + u].push_back(N - v); G[-v].push_back(u);\n                Grev[N-v].push_back(N+u); Grev[u].push_back(-v);\n            }\n        } else  {\n            if(v > 0)   {\n                G[-u].push_back(v); G[N + v].push_back(N - u);\n                Grev[v].push_back(-u); Grev[N-u].push_back(N+v);\n            } else  {\n                G[u].push_back(N - v); G[-v].push_back(N - u);\n                Grev[N-v].push_back(u); Grev[N-u].push_back(-v);\n            }\n        }\n    }\n\n    memset(explored, false, 2000005*sizeof(bool));\n    for(i=2*N; i>0; i--)    {\n        if(!explored[i])\n            dfs_reverse(i);\n        order[f[i]] = i;\n    }\n\n    memset(explored, false, 2000005*sizeof(bool));\n    for(i=2*N; i>0; i--)    {\n        if(!explored[order[i]]) {\n            parent = order[i];\n            dfs(order[i]);\n        }\n    }\n\n    for(i=1; i<=N; i++)\n        if(leader[i] == leader[N+i])\n            break;\n\n    if(i <= N)\n        printf(\"Unsatisfiable\\n\");\n    else    printf(\"Satisfiable\\n\");\n\n    return 0;\n}\n```\n\n\nI'm trying to solve the 2SAT problem with Kosaraju's two-pass algorithm for finding strongly-connected components. Basically, I've to allocate memory for a large graph (2000000 nodes). I'm doing this with vector > G[2000005] but it's giving me the above mentioned error. How can I resolve this error?\n    ", "Answer": "\r\nThe problem is ```\nvector<int, vector<int>```\n. The second template argument ```\n, vector<int>```\n doesn't make sense. You may have intended ```\nstd::vector<std::pair<int, vector<int> >```\n or ```\nstd::map<int, std::vector<int>```\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Cannot use an edge sequence from another graph error\r\n                \r\nI am new to R and currently working on implementing an algorithm to prune all leaves from a multigraph, then go through each cycle in the resulting graph to further simplify them based on certain rules. I  am currently testing the algorithm for several data sets, and so far it has been working just fine except for one particular data set that gives me the error \"Cannot use an edge sequence from another graph,\" which I find it to be weird because it works for a larger data set. I have spent the last couple of hours trying to detect the error to no avail. Below is my code:\n\n```\npruneLeaf<-function(g){\n   members<-membership(clusters(g,mode=\"strong\"))\n   strongly_connected=lapply(unique(members),function (x) \n                      induced.subgraph(g,which(members==x)))\n   return (strongly_connected)\n}\n\ngetNetflow<-function(g,node){\n   #precondition: g is a graph and node is a vertex in graph g\n   #postcondition: return the netflow from vertex node in graph g.\n   inflow_list=incident_edges(g,node,mode=\"in\")\n   outflow_list=incident_edges(g,node,mode=\"out\")\n   inflow<-0\n   outflow<-0\n   for(item in edge_attr(g,\"Quantity\",inflow_list[[1]])){\n       inflow<-inflow+item\n       }\n   for(item in edge_attr(g,\"Quantity\",outflow_list[[1]])){\n       outflow<-outflow+item\n      }\n   return (inflow-outflow)\n   }\n\nmodifyCycle<-function(g,node,netflow){\n     #pre-condition:node of graph g has negative netflow\n     #post-condition: eliminate transactions with the least priorities to           \n     outflow_list=incident_edges(g,node,mode=\"out\")\n     if(length(outflow_list[[1]])==1){\n        delete.edges(g,outflow_list[[1]])\n       }\n     else{\n          priority_list=outflow_list[[1]][order(outflow_list[[1]]$Priority)]\n          while(netflow<0){\n          count=1\n          edge=priority_list[count] #we begin with the lowest priority edge\n          flow=edge$Quantity\n          if(flow<= -netflow){ \n            netflow<-netflow+flow \n            g<-delete.edges(g,edge)\n          }\n          else{ #otherwise, we allow partial transfer to balance the netflow\n              g<-set.edge.attribute(g,\"Quantity\",edge,flow+netflow)\n              netflow<-0\n              }\n          count<-count+1\n          }\n          return (g)\n          }\n         }\n\n modifyGraph<-function(g){\n      #precondition: g is an igraph object containing only cycles\n      #postcondition: return an igraph with balanced flow at every cycle\n      isDone=FALSE\n      while(!isDone){\n            vertices=V(g)\n            isDone=TRUE\n      for(node in vertices){\n          netflow=getNetflow(g,node)\n          if(netflow<0){\n             g<-modifyCycle(g,node,netflow)\n             isDone=FALSE\n          }\n         }\n        }\n       return (g)\n      }\n\nsettlementGridlock<-function(g){\n  #precondition: g is an igraph object\n  #post-condition: return a list of graphs comprises of cyc \n  cyclic_graphs<-pruneLeaf(g)\n  result<-lapply(cyclic_graphs,function(x) modifyGraph(x))\n  return(result)\n  }\n```\n\n\nSorry for the rather long post but basically there are several functions above:\n\n\npruneLeaf: to clear all the leaves in a graph and return a list of strongly connected components of a graph\ngetNetflow: to calculate the net flow of a given node in a graph\nmodifyCycle: to remove edges based on a priority given so as to balance the\n              inflow and outflow of a given node \nmodifyGraph: this function iterates through the graph to balance inflow and \n           outflow at every single node\nsettlementGridlock: this function applies modifyGraph to every single  strongly connected component in a list produced by pruneLeaf(graph)\n\n\nThe error seems to result from the function modifyCycle as given by the error log:\n\n```\nError in as.igraph.es(graph, index) : \nCannot use an edge sequence from another graph. \n9 stop(\"Cannot use an edge sequence from another graph.\") \n8 as.igraph.es(graph, index) \n7 i_set_edge_attr(graph = graph, name = name, index = index, value = value) \n6 set.edge.attribute(g, \"Quantity\", edge, flow + netflow) \n5 modifyCycle(g, node, netflow) \n4 modifyGraph(x) \n3 FUN(X[[i]], ...) \n2 lapply(cyclic_graphs, function(x) modifyGraph(x)) \n1 settlementGridlock(graph3) \n```\n\n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Graph Clustering for almost Clustered Graph by removing nodes(vertices)\r\n                \r\nI want to carry out Graph Clustering in a huge undirected graph with millions of edges and nodes. Graph is almost clustered with different clusters joined together only by some nodes(kind of ambiguous nodes which can relate to multiple clusters). There will be very few or almost no edges between two clusters. This problem is almost similar to finding vertex cut set of a graph, with one exception that graph needs to be partitioned into many components(their number being unknown).(Refer this picture https://docs.google.com/file/d/0B7_3zLD0XdtAd3ZwMFAwWDZuU00/edit?pli=1)\n\nIts almost like different strongly connected components sharing a couple of nodes between them and i am supposed to remove those nodes to separate those strongly connected components. Edges are weigthed but this problem is more like finding structures in a graph, so edge weigths won't be of relevance. (Another way to think about the problem would be to visualize Solid Spheres touching each other at some points with Spheres being those strongly connected components and touching points being those ambiguous nodes)\n\nI am prototyping something, so am quiet short of time to pick up Graph Clustering Algorithms by myself and to select the best possible. Plus i need a solution that would cut nodes and not edges since different clusters share nodes and not edges in my case.\n\nIs there any research paper, blog that addresses this or somewhat related problem? Or can anyone come up with a solution to this problem howsoever dirty.\n\nSince millions of nodes and edges are involved, i would need a MapReduce implementation of the solution. Any inputs, links for that too?\n\nIs there any current open source implementation in MapReduce that can i directly use?\n\nI think this problem is analogous to Finding Communities in online social networks by removing vertices.\n    ", "Answer": "\r\nYour problem is not so simple. I am afraid that it is related to the clique problem, which is NP complete, so unless you quantify somehow the statement \"there are almost no edges between the clusters\", your problem might be still very difficult. But what I would do in your shoes, would be to try one dirty, greedy approach, namely regarding the nodes as the following kind of quasi-neural net:\n\nEach vertex I would consider to have inputs, outputs and a sigmoid activation function which convert the input value (sum of inputs) into the output value. The output value, and I consider this important, would not be cloned and sent to all the neighbors, but rather divided evenly between the neighbors. In addition to this, I would define a logarithmic decay of activity in a neuron (self-suppression, suppressive connection to itself), defined by a decay parameter global for the net.\n\nNow, I would start simulation with all the neurons starting from activity 0.5 (activity range is 0 to 1) with very high decay parameter, which would lead to all the neuronst quickly stabilizing in 0 state. I would then gradually decrease the decay parameter until the steady state result would yield the first clique with non-zero stable activity.\n\nThe question is what to do next. One possibility is to subtract the found clique from the graph and run the same process again until we find all the cliques. This greedy approach might succeed if your graph is indeed as well behaved (really almost clustered) as you say, but might lead to unexpected results otherwise. Another possibility is to give the found clique a unique clique smell that would be repulsive (mutual suppresion) to other cliques an rerun the algorithm until the second clique is found, give it a different clique smell repulsive to all others etc., until each node has its own assigned smell.\n\nI think this would be as many big ideas as i have about this.\n\nThe key is, that since it is probably not possible to solve this problem in the general case (likely NP complete), you need to take use of whatever special properties your graph has. That means you need to play with parameters for a while until the algorithm solves 99% of the cases that you encounter. I don't think that it is possible to give the numerically precise answer to your question without long experimentation with the actual datasets that you encounter.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Making a bipartite graph SCC by adding minimum edges\r\n                \r\nThere's a bipartite graph B(E, V1, V2) such that e = (v1, v2) for e ∈ E, v1 ∈ V1, v2 ∈ V2. Edges in B are directional.\n\nI'd like to make a graph G(E ∪ E', V2 ∪ V2) such that the graph G is strongly-connected component, with minimum sizeof(E'). (sizeof(A) is the number of elements in the set A)\nE' doesn't have to be V1 -> V2.\n\nFor an example, with V1 = {1, 2, 3} and V2 = {a, b}, there's a bipartite graph B(E, V1, V2) with E = {(1, a), (2, a), (2, b), (3, b)}.\nThen E' = {(a, 3), (a, 1), (b, 2)} makes all vertices in G(E ∪ E', V2 ∪ V2) strongly-connected.(whenever I choose vertex pair v1 and v2, there exists a path from v1 to v2)\n\nCan someone give me some idea? Or is there a well-known algorithm about this?\n    ", "Answer": "\r\nA theorem by Eswaran and Tarjan says that an acyclic digraph with r sources (i.e., vertices without incoming edges) and s sinks (i.e., vertices without outgoing edges) can be made strongly connected by adding max(r, s) edges (see e.g. here). Thus, you need to add max(sizeof(A), sizeof(B)) edges. The book also explains how to find a solution (a simple system of matching up vertices).\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Verify if an undirected graph has cycles [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI know that this question has been asked some times. But I just can't understand yet and those questions are too old to reply...   \n\nI Read about Kahn's Algorithm\nAlso about DFS\nPlus Tarjan's strongly connected components algorithm\nBut i Just can't understand the process to make it work.\nAll I've done so far is to initialized and feed the graph.\nAnd found the shortest path from vertéx A to B.\n    ", "Answer": "\r\nA simple DFS with a little modification will do.\n\nHint: We do a DFS traversal of the given graph. For every visited vertex ‘v’, if there is an adjacent ‘u’ such that u is already visited and u is not parent of v, then there is a cycle in graph.\n\nAlso Note: cycles detection in undirected graphs follow algorithm which is totally different from the directed graphs. Cycle in directed graphs are diffent.\n\n(hope you are comfortable with DFS).\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Finding the longest path in a directed cyclic graph\r\n                \r\nLet's say we have a directed cyclic graph where every node has an edge going to exactly two other nodes - except for a 'final node', which just has multiple things going into it and nothing coming out.\n\nGiven a source, I want to find the longest possible path to that final node that doesn't hit a node more than once. There are algorithms out there to do this, but the only problem is that my graph has many different cycles, some of which are inside each other, and most naive algorithms get stuck in infinite loops when evaluated. \n\nI tried collapsing all strongly connected components (of which there is only one), however if the source I want is inside that component, the algorithm doesn't work. And it doesn't work in the general case either, because within that strongly connected component, to hit every node you may have to hit some nodes multiple times, which I don't want.\n\nWhat's an efficient algorithm I can use for calculating the longest path back to the final vertex in an unweighted directed, cyclic graph such that no node is hit multiple times?\n    ", "Answer": "\r\nYou can see this question, it's also a problem about finding the longest path in a directed cyclic graph, and the standard code is also available.\n\nQuestion:http://poj.org/problem?id=3592\n\nAnswer: https://blog.csdn.net/u013514182/article/details/42364173\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Finding the longest path in a directed cyclic graph\r\n                \r\nLet's say we have a directed cyclic graph where every node has an edge going to exactly two other nodes - except for a 'final node', which just has multiple things going into it and nothing coming out.\n\nGiven a source, I want to find the longest possible path to that final node that doesn't hit a node more than once. There are algorithms out there to do this, but the only problem is that my graph has many different cycles, some of which are inside each other, and most naive algorithms get stuck in infinite loops when evaluated. \n\nI tried collapsing all strongly connected components (of which there is only one), however if the source I want is inside that component, the algorithm doesn't work. And it doesn't work in the general case either, because within that strongly connected component, to hit every node you may have to hit some nodes multiple times, which I don't want.\n\nWhat's an efficient algorithm I can use for calculating the longest path back to the final vertex in an unweighted directed, cyclic graph such that no node is hit multiple times?\n    ", "Answer": "\r\nYou can see this question, it's also a problem about finding the longest path in a directed cyclic graph, and the standard code is also available.\n\nQuestion:http://poj.org/problem?id=3592\n\nAnswer: https://blog.csdn.net/u013514182/article/details/42364173\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Pairs of Vertices Unreachable from Each Other in a Directed Graph\r\n                \r\nI am requested to design an algorithm to determine whether there exists any pair of vertices unreachable from each other in a directed graph. The algorithm must run in O(|V| + |E|) time\n\nMeaning: vertex i cannot reach vertex j, and vertex j cannot reach vertex i.\n\nI have read about the method for finding strongly connected components, I wonder whether or not I can start from there and devise an algorithm usable under the current circumstance?\n    ", "Answer": "\r\nIf you can find all strongly connected components in the linear O(V + E) time requested then you are done. This may seem a bit overkill but it solves the problem. To find all strongly connected components, assuming your graph is represented as an adjacency list, perhaps the simplest O(V + E) linear time algorithm is Kosaraju's, see e.g. http://en.wikipedia.org/wiki/Kosaraju%27s_algorithm\n\nOnce you find all strongly connected components, then it is fairly simple to test whether there is a pair of strongly connected components that is not connected by any path, by considering the condensed graph where nodes are strongly connected components and an edge exists if there is an edge between any two nodes chosen from the two connected components.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "How to design neural network ouput to segment or label an image with some overlapping same class object instances\r\n                \r\nJust for topic, e.g. I want to segment every pencil in these overlapping pencils.\nThere I think to use a softmax classifier to segment pencils and background.\nSince pencils are same class,but need to segment individual instance.\nIs it a right way to assign binary connections to every pixels pair,0 means the two pixel node are different instance,1 means they are same instance,\nand build a graph to find the strongly connected components for segment pencils?\nHere's some overlapping pencils\n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "C library for graphs [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is seeking recommendations for books, tools, software libraries, and more. It does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     We don’t allow questions seeking recommendations for books, tools, software libraries, and more. You can edit the question so it can be answered with facts and citations.\r\n                \r\n                    \r\n                        Closed 1 year ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nIs there a good C library for graph theoretic manipulations? I particularly need to calculate the strongly connected components of a directed graph. I have implemented Tarjan's algorithm in Ruby as follows:\n\n```\n    def strongly_connected_components graph\n        @index, @stack, @indice, @lowlink, @scc = 0, [], {}, {}, []\n        @graph = graph\n        vertices(@graph).each{|v| strong_connect(v) unless @indice[v]}\n        @scc\n    end\n    def strong_connect v\n        @indice[v] = @index\n        @lowlink[v] = @index\n        @index += 1\n        @stack.push(v)\n        @graph.each do |vv, w|\n            next unless vv == v\n            if !@indice[w]\n                strong_connect(w)\n                @lowlink[v] = [@lowlink[v], @lowlink[w]].min\n            elsif @stack.include?(w)\n                @lowlink[v] = [@lowlink[v], @indice[w]].min\n            end\n        end\n        if @lowlink[v] == @indice[v]\n            i = @stack.index(v)\n            @scc.push(@stack[i..-1])\n            @stack = @stack[0...i]\n        end\n    end\n```\n\n\nand it was working with small graphs, but as the graph grew big, it started to return \"stack level too deep\" errors due to recursive call of the method ```\nstrong_connect```\n. I guess I need a C library and access that from Ruby, in which the main program is written.\n\nIn addition to the library, any suggestion for using that in a Ruby library would be a help.\n    ", "Answer": "\r\nI came across the igraph library.  It is written in C and has wrappers for Ruby, Python and R.  For you, this means that you can enjoy the speed of C with the comfort of Ruby.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "pythonw.exe has stopped working\r\n                \r\nI'm implementing Kosaraju’s two-pass algorithm that can calculate strongly connected components in a directed graph. \n\nI can get the correct result with small input data, but when the input data is larger\n\n(70M txt, warning!! this text file has the size of nearly 70M\n,using a downloading software with this url to download this large file. If you don't have a downloading software, you can copy this url in your brower ```\nhttp://pan.baidu.com/s/1i5Hmf5N```\n\nand download it), \n\nit shows \"pythonw.exe has stopped working\" after about 1 hour. Python should  run to get the correct answer. \n\nHow can I fix it? Is there some memory problem?Please do me a favor.\n\nHere is the large data result:\n\nMy code is here:\n\n```\nimport time\nimport datetime\nimport sys\n\n\nstart = time.time()\nprint datetime.datetime.now()\n\nwith open('test.txt') as f:\n    #SCC\n    #a = [[int(x) for x in ln.split()] for ln in f]\n    data_set_u = []\n    data_set_v = []\n    for ln in f:\n        #print ln\n        #print type(ln)\n        #print len(ln)\n        if len(ln) >1:\n            u,v = ln.split()\n            u = int(u)\n            v = int(v)            \n            data_set_u.append(u)\n            data_set_v.append(v)\nf.close()\n\nprint 'open file time: '+ str(time.time() - start) + 's'\nprint datetime.datetime.now()\n\nsys.setrecursionlimit((max(data_set_u+data_set_v)+ len(data_set_u))*100)\n\ndef DFS_Loop():\n    num = max(data_set_u+data_set_v)\n\n    start_time_DFS_Loop = time.time()\n    global t\n    t = 0\n    global s\n    s = None\n    global visited\n    visited = [False]* num\n    global leader\n    leader = [None] * num\n    global f\n    f = [None] * num\n\n\n    for i in range(num,0,-1):\n        #print i\n        #print (i in visited)\n        #if (i in visited)==False:\n        if visited[i-1] == False:\n            s = i\n            #print s\n            DFS(i)\n    print 'end with func DFS_Loop() time: '+ str(time.time() - start_time_DFS_Loop)+ 's'\n    print 'end with func DFS_Loop() whole time: '+ str(time.time() - start)+ 's'    \n#print data_set_u\n#print data_set_v\n\n\ndef DFS(node):\n    start_time_DFS = time.time()\n\n    global t\n    visited[node-1] = True\n    #print visited\n    #print visited\n    leader[node-1] = s\n    #print leader\n    arc = []\n    arc = [data_set_v[i] for i,x in enumerate(data_set_u) if x==node] \n    #print arc\n    for i in arc:\n        #print arc\n        #print i\n        if visited[i-1]==0:\n            #print i\n            DFS(i)\n\n    t+=1\n    #print t\n    f[node-1] = t\n    #print f\n    print 'end with func DFS time: '+ str(time.time() - start_time_DFS)+ 's'\n    print 'end with func DFS whole time: '+ str(time.time() - start)+ 's'\n\nDFS_Loop()\nprint 'DFS_Loop time: '+ str(time.time() - start)+ 's'\n\n\n##reverse tail and head data\n##\n##\n\nrev_u,rev_v = data_set_v,data_set_u\nnew_u = [None] * (len(rev_u))\nnew_v = [None] * (len(rev_v))\n#print rev_v\n#print rev_u\nfor i,val in enumerate(f):\n    #rev_u[rev_u.index(i+1)] = val\n    #print i+1,val\n    #rev_v[rev_v.index(i+1,0,len(rev_v))] = val\n    #print rev_v\n    #print i,val\n    for i_v,val_v in enumerate(rev_v):\n        if val_v == i+1:\n            #print val_v\n            new_v[i_v] = val\n\n    for i_u,val_u in enumerate(rev_u):\n        if val_u == i+1:\n            #print i_u,val_u\n            new_u[i_u] = val    \n\n#print new_u\n#print new_v\ndata_set_u = new_u\ndata_set_v = new_v\n#print data_set_u\n#print data_set_v\n\nprint 'reverse data time: '+ str(time.time() - start)+ 's'\n\nDFS_Loop()\nprint 'DFS_Loop time: '+ str(time.time() - start)+ 's'\n\n#print leader\n\n\n##calculate repeated times appearancing in leader list\n##\n##\n\n\ncount_list = [0]*len(leader)\nindices = [0]*len(leader)\n\n#for i_lea,val_lea in enumerate(leader):\ni_count_list = 0\nwhile len(leader) > 0:\n    #print i_lea,val_lea\n\n    count_list[i_count_list] = leader.count(leader[0])\n    #print 'count_list: '+ str(count_list)\n    indices = [i for i, x in enumerate(leader) if x == leader[0]]\n    #print 'indices: '+ str(indices)\n    for i in xrange(len(indices)):\n        #print 'leader before del: '+ str(leader)\n        del leader[leader.index(leader[0])]\n        #print 'leader after del: '+ str(leader)\n    #print 'leader: '+ str(leader)\n    i_count_list = i_count_list+1\n    #print 'i_count_list: ' + str(i_count_list)\nprint 'calc time: '+ str(time.time() - start)+ 's'\n\nsorted_count_list = sorted(count_list, key=int, reverse=True)\nprint sorted_count_list[0:5]\nprint datetime.datetime.now()\n```\n\n\nHere is the small test file:\n\n```\n1 4\n\n2 8\n\n3 6\n\n4 7\n\n5 2\n\n6 9\n\n7 1\n\n8 5\n\n8 6\n\n9 7\n\n9 3\n```\n\n\nHere is the correct partial result of small test file:\n\n```\ncalc time: 0.121000051498s\n[3, 3, 3, 0, 0]\n2017-01-19 08:07:44.802000\n```\n\n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Boost Strong components with listS\r\n                \r\nThere aren't too many examples for graphs that do strongly connected components on listS rather than vecS. Here is an equivalent example for vecS \n\n```\n#include <boost/config.hpp>\n#include <vector>\n#include <iostream>\n#include <boost/graph/strong_components.hpp>\n#include <boost/graph/adjacency_list.hpp>\n\nint\nmain()\n{\n  using namespace boost;\n  typedef adjacency_list < vecS, vecS, directedS > Graph;\n  const int N = 6;\n  Graph G(N);\n  add_edge(0, 1, G);\n  add_edge(1, 1, G);\n  add_edge(1, 3, G);\n  add_edge(1, 4, G);\n  add_edge(3, 4, G);\n  add_edge(3, 0, G);\n  add_edge(4, 3, G);\n  add_edge(5, 2, G);\n\n  std::vector<int> c(N);\n\n  int num = strong_components\n    (G, make_iterator_property_map(c.begin(), get(vertex_index, G), c[0]));\n\n    auto l=get(vertex_index, G);\n\n  std::cout << \"Total number of components: \" << num << std::endl;\n  std::vector < int >::iterator i;\n  for (i = c.begin(); i != c.end(); ++i)\n    std::cout << \"Vertex \" << i - c.begin()\n      << \" is in component \" << *i << std::endl;\n  return EXIT_SUCCESS;\n}\n```\n\n\nBut when I change from vecS to listS, it breaks. I know the problem is because of sometype of mismatch in the vertex index and the output vector index but I couldn't exactly come up with a way to solve it. The closest answer is Which VertexList types are valid for depth_first_search but this is for \nDFS and cannot extrapolate to  SCC.\n    ", "Answer": "\r\n\n  There aren't too many examples for graphs that do strongly connected components on listS rather than vecS. Here is an equivalent example for vecS\n\n\n\"There isn't much information for playing board games when underwater rather than on land\"\n\nThe reason is that there's nothing specific to the algorithm you mention (connected components). The problem you're facing is that using ```\nlistS```\n loses the implicit ```\nvertex_index```\n property. This breaks everything that requires it.\n\nSpecifically, you would notice that the ```\nadd_edge```\n call already fails to compile.\n\nYou need to add a vertex index. Much like doing any activity underwater requires a solution for oxygen management.\n\nSo look for examples for that e.g. here. \n\nIn fact... I immediately ran into a duplicate question that I answered in 2017:\n\nFind connected components using Boost Graph library, with the vertex and edge type being boost::listS\n\nSimplest Change:\n\nSimplest change to your sample code:\n\nLive On Coliru\n\n```\n#include <boost/config.hpp>\n#include <boost/graph/adjacency_list.hpp>\n#include <boost/graph/strong_components.hpp>\n#include <iostream>\n#include <vector>\nusing boost::make_iterator_range;\n\nint main() {\n    typedef boost::adjacency_list<boost::vecS, boost::listS, boost::directedS,\n            boost::property<boost::vertex_index_t, int>\n        > Graph;\n\n    Graph G(6);\n    auto idmap = get(boost::vertex_index, G);\n    {\n        // initialize idmap\n        int id = 0;\n        for (auto& v : make_iterator_range(vertices(G)))\n            idmap[v] = id++;\n    }\n\n    auto add_edge = [&](int i, int j) {\n        return boost::add_edge(vertex(i, G), vertex(j, G), G);\n    };\n\n    add_edge(0, 1);\n    add_edge(1, 1);\n    add_edge(1, 3);\n    add_edge(1, 4);\n    add_edge(3, 4);\n    add_edge(3, 0);\n    add_edge(4, 3);\n    add_edge(5, 2);\n\n    std::vector<int> c(num_vertices(G));\n\n    int num = strong_components(\n        G, make_iterator_property_map(c.begin(), idmap, c[0]));\n\n    //auto l = get(vertex_index, G);\n\n    std::cout << \"Total number of components: \" << num << std::endl;\n    std::vector<int>::iterator i;\n    for (i = c.begin(); i != c.end(); ++i)\n        std::cout << \"Vertex \" << i - c.begin() << \" is in component \" << *i\n                  << std::endl;\n}\n```\n\n\nPrints\n\n```\nTotal number of components: 3\nVertex 0 is in component 0\nVertex 1 is in component 0\nVertex 2 is in component 1\nVertex 3 is in component 0\nVertex 4 is in component 0\nVertex 5 is in component 2\n```\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Weighted directed graph clustering\r\n                \r\nI'm generating graphs which look something like this and has the following properties:\n\nedges are weighted and directed\nnodes are either blue or red\nblue nodes only connect to blue nodes\nred nodes only connect to blue nodes\n\nWhich would be the best way of clustering the blue nodes into the strongly connected components I see?  The higher weight edges are represented by thicker arrows.\nI'm using NetworkX and PyVis.\nI have looked at the community detection algorithms available here but I have no idea where to start, there's just too many.\nExample graph\n\nGraphML for the image\n```\n<?xml version='1.0' encoding='utf-8'?>\n<graphml xmlns=\"http://graphml.graphdrawing.org/xmlns\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://graphml.graphdrawing.org/xmlns http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd\"><key id=\"d3\" for=\"edge\" attr.name=\"weight\" attr.type=\"double\"/>\n<key id=\"d2\" for=\"node\" attr.name=\"type\" attr.type=\"string\"/>\n<key id=\"d1\" for=\"node\" attr.name=\"title\" attr.type=\"string\"/>\n<key id=\"d0\" for=\"node\" attr.name=\"color\" attr.type=\"string\"/>\n<graph edgedefault=\"directed\"><node id=\"e_59\">\n  <data key=\"d0\">blue</data>\n  <data key=\"d1\"></data>\n  <data key=\"d2\">excitatory</data>\n</node>\n<node id=\"e_51\">\n  <data key=\"d0\">blue</data>\n  <data key=\"d1\"></data>\n  <data key=\"d2\">excitatory</data>\n</node>\n<node id=\"e_34\">\n  <data key=\"d0\">blue</data>\n  <data key=\"d1\"></data>\n  <data key=\"d2\">excitatory</data>\n</node>\n<node id=\"e_49\">\n  <data key=\"d0\">blue</data>\n  <data key=\"d1\"></data>\n  <data key=\"d2\">excitatory</data>\n</node>\n<node id=\"e_7\">\n  <data key=\"d0\">blue</data>\n  <data key=\"d1\"></data>\n  <data key=\"d2\">excitatory</data>\n</node>\n<node id=\"e_143\">\n  <data key=\"d0\">blue</data>\n  <data key=\"d1\"></data>\n  <data key=\"d2\">excitatory</data>\n</node>\n<node id=\"e_109\">\n  <data key=\"d0\">blue</data>\n  <data key=\"d1\"></data>\n  <data key=\"d2\">excitatory</data>\n</node>\n<node id=\"e_154\">\n  <data key=\"d0\">blue</data>\n  <data key=\"d1\"></data>\n  <data key=\"d2\">excitatory</data>\n</node>\n<node id=\"e_155\">\n  <data key=\"d0\">blue</data>\n  <data key=\"d1\"></data>\n  <data key=\"d2\">excitatory</data>\n</node>\n<node id=\"e_127\">\n  <data key=\"d0\">blue</data>\n  <data key=\"d1\"></data>\n  <data key=\"d2\">excitatory</data>\n</node>\n<node id=\"e_254\">\n  <data key=\"d0\">blue</data>\n  <data key=\"d1\"></data>\n  <data key=\"d2\">excitatory</data>\n</node>\n<node id=\"e_185\">\n  <data key=\"d0\">blue</data>\n  <data key=\"d1\"></data>\n  <data key=\"d2\">excitatory</data>\n</node>\n<node id=\"e_183\">\n  <data key=\"d0\">blue</data>\n  <data key=\"d1\"></data>\n  <data key=\"d2\">excitatory</data>\n</node>\n<node id=\"e_214\">\n  <data key=\"d0\">blue</data>\n  <data key=\"d1\"></data>\n  <data key=\"d2\">excitatory</data>\n</node>\n<node id=\"e_221\">\n  <data key=\"d0\">blue</data>\n  <data key=\"d1\"></data>\n  <data key=\"d2\">excitatory</data>\n</node>\n<node id=\"i_62\">\n  <data key=\"d0\">red</data>\n  <data key=\"d1\"></data>\n  <data key=\"d2\">inhibitory</data>\n</node>\n<node id=\"i_1\">\n  <data key=\"d0\">red</data>\n  <data key=\"d1\"></data>\n  <data key=\"d2\">inhibitory</data>\n</node>\n<node id=\"i_27\">\n  <data key=\"d0\">red</data>\n  <data key=\"d1\"></data>\n  <data key=\"d2\">inhibitory</data>\n</node>\n<node id=\"i_40\">\n  <data key=\"d0\">red</data>\n  <data key=\"d1\"></data>\n  <data key=\"d2\">inhibitory</data>\n</node>\n<node id=\"i_48\">\n  <data key=\"d0\">red</data>\n  <data key=\"d1\"></data>\n  <data key=\"d2\">inhibitory</data>\n</node>\n<node id=\"i_52\">\n  <data key=\"d0\">red</data>\n  <data key=\"d1\"></data>\n  <data key=\"d2\">inhibitory</data>\n</node>\n<node id=\"i_14\">\n  <data key=\"d0\">red</data>\n  <data key=\"d1\"></data>\n  <data key=\"d2\">inhibitory</data>\n</node>\n<node id=\"i_10\">\n  <data key=\"d0\">red</data>\n  <data key=\"d1\"></data>\n  <data key=\"d2\">inhibitory</data>\n</node>\n<node id=\"i_55\">\n  <data key=\"d0\">red</data>\n  <data key=\"d1\"></data>\n  <data key=\"d2\">inhibitory</data>\n</node>\n<node id=\"i_19\">\n  <data key=\"d0\">red</data>\n  <data key=\"d1\"></data>\n  <data key=\"d2\">inhibitory</data>\n</node>\n<node id=\"i_36\">\n  <data key=\"d0\">red</data>\n  <data key=\"d1\"></data>\n  <data key=\"d2\">inhibitory</data>\n</node>\n<node id=\"i_2\">\n  <data key=\"d0\">red</data>\n  <data key=\"d1\"></data>\n  <data key=\"d2\">inhibitory</data>\n</node>\n<node id=\"i_44\">\n  <data key=\"d0\">red</data>\n  <data key=\"d1\"></data>\n  <data key=\"d2\">inhibitory</data>\n</node>\n<node id=\"i_53\">\n  <data key=\"d0\">red</data>\n  <data key=\"d1\"></data>\n  <data key=\"d2\">inhibitory</data>\n</node>\n<node id=\"i_3\">\n  <data key=\"d0\">red</data>\n  <data key=\"d1\"></data>\n  <data key=\"d2\">inhibitory</data>\n</node>\n<edge source=\"e_59\" target=\"e_34\">\n  <data key=\"d3\">0.0075</data>\n</edge>\n<edge source=\"e_51\" target=\"e_34\">\n  <data key=\"d3\">0.0075</data>\n</edge>\n<edge source=\"e_51\" target=\"e_49\">\n  <data key=\"d3\">0.0075</data>\n</edge>\n<edge source=\"e_34\" target=\"e_49\">\n  <data key=\"d3\">0.0075</data>\n</edge>\n<edge source=\"e_49\" target=\"e_7\">\n  <data key=\"d3\">0.0075</data>\n</edge>\n<edge source=\"e_49\" target=\"e_51\">\n  <data key=\"d3\">0.0075</data>\n</edge>\n<edge source=\"e_49\" target=\"e_59\">\n  <data key=\"d3\">0.0075</data>\n</edge>\n<edge source=\"e_143\" target=\"e_154\">\n  <data key=\"d3\">0.0075</data>\n</edge>\n<edge source=\"e_109\" target=\"e_143\">\n  <data key=\"d3\">0.0075</data>\n</edge>\n<edge source=\"e_154\" target=\"e_127\">\n  <data key=\"d3\">0.0075</data>\n</edge>\n<edge source=\"e_155\" target=\"e_109\">\n  <data key=\"d3\">0.0075</data>\n</edge>\n<edge source=\"e_127\" target=\"e_143\">\n  <data key=\"d3\">0.0075</data>\n</edge>\n<edge source=\"e_127\" target=\"e_154\">\n  <data key=\"d3\">0.0075</data>\n</edge>\n<edge source=\"e_254\" target=\"e_183\">\n  <data key=\"d3\">0.0005</data>\n</edge>\n<edge source=\"e_254\" target=\"e_221\">\n  <data key=\"d3\">0.0005</data>\n</edge>\n<edge source=\"e_185\" target=\"e_183\">\n  <data key=\"d3\">0.0005</data>\n</edge>\n<edge source=\"e_185\" target=\"e_254\">\n  <data key=\"d3\">0.0005</data>\n</edge>\n<edge source=\"e_183\" target=\"e_185\">\n  <data key=\"d3\">0.0005</data>\n</edge>\n<edge source=\"e_183\" target=\"e_214\">\n  <data key=\"d3\">0.0005</data>\n</edge>\n<edge source=\"e_183\" target=\"e_221\">\n  <data key=\"d3\">0.0005</data>\n</edge>\n<edge source=\"e_214\" target=\"e_185\">\n  <data key=\"d3\">0.0005</data>\n</edge>\n<edge source=\"e_214\" target=\"e_221\">\n  <data key=\"d3\">0.0005</data>\n</edge>\n<edge source=\"e_214\" target=\"e_254\">\n  <data key=\"d3\">0.0005</data>\n</edge>\n<edge source=\"e_221\" target=\"e_185\">\n  <data key=\"d3\">0.0005</data>\n</edge>\n<edge source=\"e_221\" target=\"e_214\">\n  <data key=\"d3\">0.0005</data>\n</edge>\n<edge source=\"e_221\" target=\"e_254\">\n  <data key=\"d3\">0.0005</data>\n</edge>\n<edge source=\"i_62\" target=\"e_34\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_62\" target=\"e_49\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_62\" target=\"e_155\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_62\" target=\"e_185\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_1\" target=\"e_127\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_1\" target=\"e_183\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_1\" target=\"e_214\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_27\" target=\"e_34\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_27\" target=\"e_59\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_27\" target=\"e_154\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_27\" target=\"e_183\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_27\" target=\"e_185\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_27\" target=\"e_214\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_40\" target=\"e_49\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_40\" target=\"e_154\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_48\" target=\"e_49\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_48\" target=\"e_59\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_48\" target=\"e_109\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_48\" target=\"e_155\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_48\" target=\"e_183\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_48\" target=\"e_214\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_52\" target=\"e_51\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_52\" target=\"e_109\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_52\" target=\"e_185\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_14\" target=\"e_109\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_14\" target=\"e_127\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_14\" target=\"e_155\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_14\" target=\"e_183\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_14\" target=\"e_214\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_10\" target=\"e_49\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_10\" target=\"e_59\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_10\" target=\"e_221\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_55\" target=\"e_49\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_55\" target=\"e_155\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_55\" target=\"e_183\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_55\" target=\"e_254\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_19\" target=\"e_7\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_19\" target=\"e_34\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_19\" target=\"e_49\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_19\" target=\"e_51\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_19\" target=\"e_155\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_19\" target=\"e_185\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_19\" target=\"e_214\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_36\" target=\"e_7\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_36\" target=\"e_127\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_36\" target=\"e_155\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_36\" target=\"e_214\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_2\" target=\"e_7\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_2\" target=\"e_51\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_2\" target=\"e_59\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_2\" target=\"e_154\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_2\" target=\"e_185\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_44\" target=\"e_34\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_44\" target=\"e_49\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_44\" target=\"e_59\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_44\" target=\"e_154\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_53\" target=\"e_34\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_53\" target=\"e_49\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_53\" target=\"e_109\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_53\" target=\"e_127\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_53\" target=\"e_183\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_3\" target=\"e_51\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_3\" target=\"e_143\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_3\" target=\"e_154\">\n  <data key=\"d3\">0.001</data>\n</edge>\n<edge source=\"i_3\" target=\"e_254\">\n  <data key=\"d3\">0.001</data>\n</edge>\n</graph></graphml>\n```\n\n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Java stack overflow on computing SCC on large graph\r\n                \r\nI have a graph with close to 1 mil nodes, on which I am computing the strongly connected components.  I have increased the heap size of the vm to 10240 mb, but it is still throwing this exception  :\n\n```\nError: 875714\nException in thread \"main\" java.lang.StackOverflowError\n    at java.util.Stack.push(Stack.java:67)\n```\n\n\nI am absolutely sure that code is not the issue, but the size.  What else can I do?\n\nUPDATE : The StackOverflowError is thrown regardless of the heap size I set the vm, after 6 seconds.\n\nIf I can't solve the StackOverflowError on StackOverflow.com, I don't know where else to turn =)\n    ", "Answer": "\r\nKeep in mind, that ```\nStackOverflowError```\n has nothing to do with ```\njava.util.Stack```\n: the error is thrown when there is no more space for call stack (i.e. too deep recursion), not when there is no space in ```\nStack```\n object.\n\nThe first thing I suggest is to revise the algorithm. My blind guess is you are using recursion for visiting neighbor nodes, which causes the overflow. Try to use loops in place of recursion.\n\nFor short-term purpose you can also try increasing stack size (not heap size) with ```\n-Xss```\n. BTW, keep in mind that each thread has its own stack.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Will SCC pattern change if we reverse a graph(using Kosaraju's Algorithm)?\r\n                \r\nAssume we have a digraph, it is not a complete graph and has more than one SCC.\nI wonder if the patterns of Strongly Connected Component changes if we transpose the graph and use Kosaraju's Algorithm?\nBy saying \"transpose the graph\" I mean flip the direction of edges.\nIf we try to find SCC in the transposed/reversed graph instead of the original, will the SCC we find be different?\n\nI came up with this question as I misunderstood the algorithm of SCC and runs it on my transposed/reversed graph. What I got is identical SCC to the correct answer/which runs Kosaraju's algorithm. Is it universally true to all graphs?\n    ", "Answer": "\r\nIf you look at http://en.wikipedia.org/wiki/Kosaraju%27s_algorithm you will see that:\n\n\"the transpose graph (the same graph with the direction of every edge reversed) has exactly the same strongly connected components as the original graph.\"\n\n(A strongly connected component is one where you can get from every vertex to every other vertex in the component, and this will still hold if you reverse all the links). Of course, the links connecting different components will be reversed, so I expect that you will get the components coming out in a different order. \n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "How to intake strings and input them to a graph?\r\n                \r\nThe problem I am trying to solve has to do with a social network exercise where a person has one best friend and the rest are friends of that friend.\nI have been stuck on this problem for a couple days now on how to intake input and get it to a graph.  The general idea is to apply this to a graph and find the strongly connected components, which is essentially when (shown below) a particular person's best friend (name right after their name) has friends that two people may have in common. Like shown, John and Lucas would be a strongly connected component since Lucas's best friend Mike is also a friend of a friend for John. (I know, its a little confusing)\n\nFirst name of line will always be the person in question.\nSecond name of line will always be that person's best friend.\nAny names after that are \"friends of friends\" (this could be from 0 -> 100, the example shown only has one for each person for simplicity)\n\nTest Case:\n4\nJohn Bob Mike\nEmma Noah Ava\nBen Henry Sarah\nLucas Mike Sophia\nTest Case Output:\n2\nNow, this wouldn't be too much of an issue if it were limited to two friends, however the amount of names after the best friend's name can be 0 to 100. What are some of your suggestions to approach the intake of this data into a graph? (again, I am just asking for tips on formatting the input to be put into a graph, finding strongly connected components is already solved.)\nWhat I have so far to get input into individual people:\n```\n    int n;\n    cin >> n;\n    cin.ignore();\n\n    int amount = n;\n    vector<string> s(amount);\n\n    for (int i = 0; i < amount ; i++) //intake the whole line of text\n    {\n        string all;\n        getline(cin, all);\n        s[i] = all;\n    }\n\n    map<string, vector<string>> network;//possibly use a map? \n    vector<string> people;\n    for (int i = 0; i < amount; i++) //breaking up the string into words\n    {\n        string person = \"\";\n        \n        for (int j = 0; j < s[i].length(); j++)\n        {\n            if (s[i][j] == ' ')\n            {\n                people.push_back(person);\n                person = \"\"; //setting string back to empty\n            }\n            else \n            {\n                person += s[i][j];\n            }                    \n        }\n\n    }\n```\n\nI am stuck on how to get the logic for the edges. A overview would be 'n' amount of nodes, but the issues is getting the edges all formatted for the graph. This is the part that I am stuck on the most. The code I have will basically separate out the string into words, but how can I meaningfully attach that to someone in terms of edges? Thanks for taking the time to check this problem out.\n    ", "Answer": "\r\nYou have two types of connections between people: \"best friend\" ( bf ) or \"friend of friend\" ( ff )\nSo you will need an edge attribute so that you can capture the distinction.\nThe edge list for the graph for your example would therefor be\n\n\n\n\nv1\nv2\natribute\n\n\n\n\nJohn\nBob\nbf\n\n\nJohn\nMike\nff\n\n\nEmma\nNoah\nbf\n\n\nEmma\nAva\nff\n\n\nBen\nHenry\nbf\n\n\nBen\nSarah\nff\n\n\nLucas\nMike\nbf\n\n\nLucas\nSophia\nff\n\n\n\n\nThis code:\n```\n#include <string>\n#include <fstream>\n#include <sstream>\n#include <iostream>\n#include <vector>\n\n/// @brief A graph edge\nclass edge\n{\npublic:\n    std::string v1;\n    std::string v2;\n    std::string attr;\n\n    edge(\n        const std::string &s1,\n        const std::string &s2,\n        const std::string &sattr)\n        : v1(s1),\n          v2(s2),\n          attr(sattr)\n    {\n    }\n    void display()\n    {\n        std::cout << v1 << \" | \"<< v2 <<\" | \"<< attr << \"\\n\";\n    }\n};\n\n/// @brief define graph type\n\ntypedef std::vector<edge> graph_t;\n\n/// @brief split line into space delimited tokens\n/// @param line \n/// @return vector of tokens\n\nstd::vector<std::string> tokenize(const std::string &line)\n{\n    std::vector<std::string> ret;\n    std::stringstream sst(line);\n    std::string a;\n    while (getline(sst, a, ' '))\n        ret.push_back(a);\n    return ret;\n}\n\n/// @brief Output text listing graph edges\n/// @param[in] g \n\nvoid display(graph_t& g)\n{\n    std::cout << \"v1 | v2 | atribute\\n|---|---|---|\\n\";\n    for( edge& e : g )\n    {\n        e.display();\n    }\n}\n/// @brief read graph from input file\n/// @param[in/out] g graph to add edges to\n/// @param fname input file path\n\nvoid read(\n    graph_t& g,\n    const std::string &fname)\n{\n    std::ifstream ifs(fname);\n    if (!ifs.is_open())\n        throw std::runtime_error(\"no input file\");\n    std::string line;\n    while (getline(ifs, line))\n    {\n        auto vtoken = tokenize(line);\n        g.push_back( edge( vtoken[0],vtoken[1],\"bf\"));\n        for( int k = 2; k<vtoken.size(); k++ )\n            g.push_back( edge( vtoken[0],vtoken[k],\"ff\"));\n    }\n}\n\nmain()\n{\n// construct graph\ngraph_t g;\n\n// read edges from file\nread(g,\"input.txt\");\n\n// display edges\ndisplay(g);\nreturn 0;\n}\n```\n\nwith this input\n```\nJohn Bob Mike\nEmma Noah Ava\nBen Henry Sarah\nLucas Mike Sophia\nMissCongeality John Emma Ben Lucas\n```\n\ngives this output\n\n\n\n\nv1\nv2\natribute\n\n\n\n\nJohn\nBob\nbf\n\n\nJohn\nMike\nff\n\n\nEmma\nNoah\nbf\n\n\nEmma\nAva\nff\n\n\nBen\nHenry\nbf\n\n\nBen\nSarah\nff\n\n\nLucas\nMike\nbf\n\n\nLucas\nSophia\nff\n\n\nMissCongeality\nJohn\nbf\n\n\nMissCongeality\nEmma\nff\n\n\nMissCongeality\nBen\nff\n\n\nMissCongeality\nLucas\nff\n\n\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "How to look for the edges that must exist in every minimum spanning trees of a weighted graph\r\n                \r\nGiven an undirected weighted graph, the actual weights of the edges are not known, however; instead, each edge is classified as either Light, Medium or Heavy.\n\nAll Light edges have a smaller weight than any Medium or Heavy edge.\n\nAll Medium edges have a smaller weight than any Heavy edge\n\nIn general, nothing is known about the relationship between two edges in the same weight class.\n Then, how to identify all the edges that must exist in every MST of this graph? The following is what I'm thinking:\n 1. determine the number of strongly connected components.\n 2. the edges composed of articulation points must exist in the MST.\n 3. The lightest edge in each connected component must exist in the MST.\n\nI am not sure whether my thinking is correct or not? If it is correct, how to implement the code with java? Thank you very much. \n    ", "Answer": "\r\nJason, I will not go into the description of how to implement the code in Java, but let's look at the thought process behind the algorithm for your problem.\n\nSince your vertices are classified into three weight categories, we can re-label them with comparative weights as follows: Light is 1; Medium is 2; Heavy is 3.  This way, your conditions are maintained. \n\nNext, we can use Kruskal's Minimum Spanning Tree Algorithm (MST) as we normally would to create a minimum spanning tree on an undirected weighted graph. This algorithm is greedy, so it would sort the edges from light to heavy, pick the next smallest edge so long as it doesn't create a cycle, and then repeat step 2 until all vertices are included in the MST. (See link below for reference)\nhttps://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/\n\nWhen it comes to verifying that your algorithm is correct, there are two potential cases.\n\n1). You can reveal the actual weights of edges in the MST and those excluded. Check the excluded edges and if when adding an excluded edge to the MST, that edge is not the heaviest in the cycle, swap it with the heaviest edge. Keep doing this until all originally-excluded edges are explored and the MST maintains its property of containing every vertex.\n2). You cannot reveal the actual weights of any vertex in the graph. In this case, there is no way to even verify that your algorithm created a Minimum Spanning Tree, so your algorithm would have no way of checking itself. In any event, using Kruskal's algorithm with comparative weights would create a spanning tree that is very close to minimum, even without knowing the actual weights.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Non recursive Kosaraju's two pass algorithm implementation taking forever to execute on a large data set\r\n                \r\n\nI coded this for an assignment which has passed its deadline.\nThis implementation works completely fine with various smaller test cases and displays the sizes of the 5 largest Strongly Connected Components in the graph as it should.\nBut seems to execute forever when i run it on the assignment data set of about 875714 vertices. (Doesn't even come out of the first DFS pass after 60mins)\nI've used the non recursive stack implementation of the DFS routine as i heard that the large number of vertices was causing recursion stack overflow problems.\nIt would be really helpful if anyone could point out, what in this code is making it behave this way with the large dataset.\nThe input file consists of list of edges in the graph. one edge/line.\n\n\n(eg):\n\n1 2\n\n2 3\n\n3 1\n\n3 4\n\n5 4\n\nDownload link for the Large graph test case zip file \n\nLink to my program file\n\nCode follows:\n\n//Macro definitions and Global variables\n\n```\n#define N 875714\n#define all(a) (a).begin(), (a).end()\n#define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)\n\nvi v(N), ft, size;\n```\n\n\n//Non recursive DFS algorithm\n\n```\nvoid DFS(vvi g, int s, int flag)\n{\nstack<int> stk;\nstk.push(s);\nv[s] = 1;\n\nint jumpOut, count;\nvi::iterator i;\n\nif(flag == 2)\n     count = 1;\n\nwhile(!stk.empty())\n{\ni = g[stk.top()].begin();\njumpOut = 0;\n\nfor(; i != g[stk.top()].end(); i++)\n{\n    if(v[*i] != 1)\n    {\n        stk.push(*i);\n        v[*i] = 1;\n\n        if(flag == 2) //Count the SCC size\n            count++;\n\n        jumpOut = 1; //Jump to the while loop's beginning\n        break;\n    }\n }\n\n if(flag == 1 && jumpOut == 0) //Record the finishing time order of vertices\n    ft.push_back(stk.top());\n\n if(jumpOut == 0)\n      stk.pop();\n}\n\nif(flag == 2)\n    size.push_back(count); //Store the SCC size\n}\n```\n\n\n// The 2 pass Kosaraju algorithm\n\n```\nvoid kosaraju(vvi g, vvi gr)\n{\ncout<<\"\\nInside pass 1\\n\";\n\nfor(int i = N - 1; i >= 0; i--)\n    if(v[i] != 1)\n        DFS(gr, i, 1);\n\ncout<<\"\\nPass 1 completed\\n\";\n\nfill(all(v), 0);\n\ncout<<\"\\nInside pass 2\\n\";\n\nfor(int i = N - 1; i >= 0; i--)\n    if(v[ ft[i] ] != 1)\n        DFS(g, ft[i], 2);\n\ncout<<\"\\nPass 2 completed\\n\";\n}\n```\n\n\n.\n\n```\nint main()\n{\nvvi g(N), gr(N);\nifstream file(\"/home/tauseef/Desktop/DAA/SCC.txt\");\nint first, second;\nstring line;\n\nwhile(getline(file,line,'\\n')) //Reading from file\n{\n    stringstream ss(line);\n    ss >> first;\n    ss >> second;\n    if(first == second) //Eliminating self loops\n        continue;\n\n    g[first-1].push_back(second-1); //Creating G & Grev\n    gr[second-1].push_back(first-1);\n}\n\ncout<<\"\\nfile read successfully\\n\";\n\nkosaraju(g, gr);\n\ncout<<\"\\nFinishing order is: \";\ntr(ft, j)\n    cout<<*j+1<<\" \";\ncout<<\"\\n\";\n\nsort(size.rbegin(), size.rend()); //Sorting the SCC sizes in descending order\n\ncout<<\"\\nThe largest 5 SCCs are: \";\ntr(size, j)\n    cout<<*j<<\" \";\ncout<<\"\\n\";\n\nfile.close();\n}\n```\n\n    ", "Answer": "\r\nThere are several improvements that you can apply:\n1- ```\ncin```\n is not as fast ```\nscanf```\n for large inputs: Because your input file is huge you better use ```\nscanf```\n to read your data.\n2- It is not a good idea to pass large data to functions by value: You have two huge graphs in your code that you pass them to functions by value. It takes a lot of time because every time you are making a copy of the data.\n3- There is no need to use ```\niterator```\n for traversing a ```\nvector```\n: Because you are using a ```\nvector```\n and you have random access to it via ```\n[]```\n operator there is no need to use ```\niterator```\n to access data.\n4- Your DFS is not efficient: This is the most important one. Every time the program go to the beginning of the ```\nwhile```\n and check the adjacency list of the element on top of the ```\nstack```\n you start from the beginning and check elements. This make the algorithm very inefficient because you are checking some things over and over again. You can simply store how many of the children you have checked and when you go back to this element you start from the next element instead of starting from start.\n\n```\n#include<iostream>\n#include<vector>\n#include<stack>\n#include<algorithm>\n#include<fstream>\n#include<string>\n#include<sstream>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\n#define N 875714\n#define sz(a) int((a).size())\n#define all(a) (a).begin(), (a).end()\n#define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)\n\nvi v(N), ft, size;\nvi childsVisited(N);\n\nvoid DFS(vvi &g, int s, int flag)\n{\n    stack<int> stk;\n    stk.push(s);\n    v[s] = 1;\n\n    int jumpOut, count;\n\n    if(flag == 2)\n        count = 1;\n    int counter = 0;\n    while(!stk.empty())\n    {\n        jumpOut = 0;\n        int cur = stk.top();\n        for ( ;childsVisited[cur] < g[cur].size(); ++childsVisited[cur] )\n        //for ( int i=0; i< g[cur].size(); ++i )\n        //for(; i != g[stk.top()].end(); i++)\n        {\n            int i = childsVisited[cur];\n            int next = g[cur][i];\n            if(v[next] != 1)\n            {\n                stk.push(next);\n                v[next] = 1;\n                if(flag == 2) //Count the SCC size\n                    count++;\n\n                jumpOut = 1; //Jump to the while loop's beginning\n                break;\n            }\n        }\n\n        if(flag == 1 && jumpOut == 0) //Record the finishing time order of vertices\n            ft.push_back(stk.top());\n\n        if(jumpOut == 0)\n            stk.pop();\n    }\n\n    if(flag == 2)\n        size.push_back(count); //Store the SCC size\n}\n\nvoid kosaraju(vvi &g, vvi &gr)\n{\n    cout<<\"\\nInside pass 1\\n\";\n\n    for(int i = N - 1; i >= 0; i--)\n        if(v[i] != 1)\n            DFS(gr, i, 1);\n\n    cout<<\"\\nPass 1 completed\\n\";\n\n    fill(all(v), 0);\n    fill(all(childsVisited), 0);\n\n    cout<<\"\\nInside pass 2\\n\";\n\n    for(int i = N - 1; i >= 0; i--)\n        if(v[ ft[i] ] != 1)\n            DFS(g, ft[i], 2);\n\n    cout<<\"\\nPass 2 completed\\n\";\n}\n\nint main()\n{\n    freopen(\"input.txt\",\"r\",stdin);\n    vvi g(N), gr(N);\n    //ifstream file(\"/home/tauseef/Desktop/DAA/SCC.txt\");\n    int first, second;\n    //string line;\n    unsigned long int cnt = 0;\n\n    //while(getline(file,line,'\\n')) //Reading from file\n    //{\n        //stringstream ss(line);\n        //ss >> first;\n        //ss >> second;\n        //if(first == second) //Eliminating self loops\n            //continue;\n    for ( int i = 0; i < 5105043; ++i ){\n        int first, second;\n        scanf(\"%d %d\",&first,&second);\n        g[first-1].push_back(second-1); //Creating G & Grev\n        gr[second-1].push_back(first-1);\n    }\n        //cnt++;\n    //}\n\n    cout<<\"\\nfile read successfully\\n\";\n\n\n    kosaraju(g, gr);\n\n    cout<<\"\\nFinishing order is: \";\n\n    sort(size.rbegin(), size.rend()); //Sorting the SCC sizes in descending order\n\n    cout<<\"\\nThe largest 5 SCCs are: \";\n\n}\n```\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Why doesn't Haskell support mutually recursive modules?\r\n                \r\nHaskell supports mutually recursive let-bindings, which is great. Haskell doesn't support mutually recursive modules, which is sometimes terrible. I know that GHC has its ```\n.hs-boot```\n mechanism, but I think that's a bit of a hack.\n\nAs far as I know, transparent support for mutually recursive modules should be relatively \"simple\", and it can be done exactly like mutually recursive let-bindings: instead of taking each separate module as a compilation unit, I would take every strongly connected component of the module dependency graph as a compilation unit.\n\nAm I missing something here? Is there any non-trivial reason why Haskell doesn't support mutually recursive modules in this way?\n    ", "Answer": "\r\nThis 6-year-old feature request ticket contains a fair amount of discussion, which you may have already seen. The gist of it is that it's not entirely a simple  change as far as GHC is concerned. A few specific issues raised:\n\n\nGHC currently has a lot of baked-in assumptions about how modules are processed during compilation, and changing those assumptions significantly would vastly outweigh the benefits of transparent support for mutually recursive modules.\nLumping groups of modules together means they have to be compiled together, which means more recompilation and awkwardness with generating separate ```\n.hi```\n and ```\n.o```\n files.\nBackward compatibility with existing builds that use ```\nhs-boot```\n files.\nYou have the potential for mutually-recursive bindings that cross module boundaries in a mutually-recursive module group, which raises issues with anything that involves implicit, module-level scope (such as defaulting, and possibly type class instances).\nAnd of course, the potential for unknown, unanticipated bugs, as with anything that alters long-standing assumptions in GHC. Even without massive changes to the compilation process, many things are currently assumed to be compiled on a per-module basis.\n\n\nA lot of people would like to see this supported, but so far nobody has either produced a possible implementation or worked out a detailed, well-specified design that handles all the fiddly corner cases of the sort mentioned above.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Best algorithm for detecting cycles in a directed graph [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is opinion-based. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it can be answered with facts and citations by editing this post.\r\n                \r\n                    \r\n                        Closed 2 years ago.\r\n                    \r\n                \r\n            The community reviewed whether to reopen this question last year and left it closed:\r\n            \r\n                    Original close reason(s) were not resolved\r\n            \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nIs there an efficient algorithm for detecting cycles within a directed graph?\nI have a directed graph representing a schedule of jobs that need to be executed, a job being a node and a dependency being an edge. I need to detect the error case of a cycle within this graph leading to cyclic dependencies.\n    ", "Answer": "\r\nTarjan's strongly connected components algorithm has ```\nO(|E| + |V|)```\n time complexity.\n\nFor other algorithms, see Strongly connected components on Wikipedia.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Find the highest reachable node from each node\r\n                \r\nI have a directed graph G(V,E). G may contain cycles. Each v starts with a value n[v]. Lets call S{v} all vertices reachable by v in G. For each v, I need to update n[v] with the max(n[u]), u∈S{v}.\n\nI've tried using Quick-Union with path compression, but I can't because G is a directed graph.\n\nAn option is using DFS on each node, but the complexity would be O(V(V+E)) in the worst case.\n\nIs there a better way to approach it (maybe using topological sorting, transitive reduction or strongly connected components)?\n    ", "Answer": "\r\nYes there's a better way O(V+E):\n\n\nFind all strongly connected components (Kadane or Tarjan algorithms) and save ```\nmax_n[v]```\n for each vertex in component\nbuild a new graph out of strongly connected components\nnew graph is a DAG\nuse DP to calculate required values for each component (for DAG`s its either top down with DFS or bottom up with Kahn)\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Tarjan's Algorithm implementation, Low value node issue\r\n                \r\nI am trying to execute tarjans algorithm on a set of nodes from a graph, I can succesfully find Strongly Connected Components, however the root or the low value node is always off, even for SCC's with only 1 element the root node does not match that element\nFor Example:\n```\n0-3 IS LOW VALUE NODE\n[82-97]\n529-529 IS LOW VALUE NODE\n[69-81]\n379-379 IS LOW VALUE NODE\n[57-68]\n1619-1619 IS LOW VALUE NODE\n[136-137]\n415-415 IS LOW VALUE NODE\n[45-56]\n```\n\nwhere the top is the low value node and the bottom is the 1 element that makes up the SCC\nThe code I currently have is here\n```\npackage Structs;\n\nimport java.util.*;\n\npublic class TarjanSCC {\n\n    private int id;\n    private boolean[] onStack;\n    private int[] ids, low;\n    private Deque<Integer> stack;\n    private Graph<BasicBlock> graph;\n    private Map<BasicBlock, Integer> nodeMap;\n    private BasicBlock[] nodes;\n    private static final int UNVISITED = -1;\n\n    public TarjanSCC(Graph<BasicBlock> graph) {\n        this.graph = graph;\n    }\n\n    public void runTSCC() {\n        runTSCC(graph);\n    }\n\n    public void runTSCC(Graph<BasicBlock> nodeGraph) {\n\n        //Initialize values for sorting\n        this.nodes = nodeGraph.getNodes().toArray(new BasicBlock[nodeGraph.size()]);\n        int size = nodes.length;\n        this.ids = new int[size];\n        this.low = new int[size];\n        this.onStack = new boolean[size];\n        this.stack = new ArrayDeque<>();\n        this.nodeMap = new HashMap<>();\n\n        //Mark all nodes as unused, place nodes in a map so index is easily retrievable from node\n        for(int i = 0; i < size; i++) {\n            nodeMap.put(nodes[i], i);\n            ids[i] = UNVISITED;\n        }\n\n        //Invoke the DFS algorithm on each unvisited node\n        for(int i = 0; i < size; i++) {\n            if (ids[i] == UNVISITED) dfs(i, nodeGraph);\n        }\n    }\n\n    private void dfs(int at, Graph<BasicBlock> nodeGraph) {\n        ids[at] = low[at] = id++;\n        stack.push(at);\n        onStack[at] = true;\n\n        //Visit All Neighbours of graph and mark as visited and add to stack,\n        for (BasicBlock edge : nodeGraph.getEdges(nodes[at])) {\n            int nodeArrayIndex = nodeMap.get(edge);\n            if (ids[nodeArrayIndex] == UNVISITED) {\n                dfs(nodeArrayIndex, nodeGraph);\n                low[at] = Math.min(low[at], low[nodeArrayIndex]);\n            }\n            else if (onStack[nodeArrayIndex]) low[at] = Math.min(low[at], nodeArrayIndex);\n        }\n\n        //We've visited all the neighours, lets start emptying the stack until we're at the start of the SCC\n        if (low[at] == ids[at]) {\n            List<BasicBlock> sccList = new ArrayList<>();\n            for (int node = stack.pop();; node = stack.pop()) {\n                onStack[node] = false;\n                sccList.add(0, nodes[node]);\n                if (node == at) {\n                    System.out.println(nodes[low[at]] + \" IS LOW VALUE NODE\");\n                    System.out.println(sccList);\n                    break;\n                }\n            }\n        }\n    }\n}\n```\n\nI suspect the issue lies with setting the low values.\nI do not believe any other class info is required as there is no issues with retrieving edges from the graph\n    ", "Answer": "\r\nI was indexing the root node wrong nodes[at] is the proper way to access the root node\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "DFS implementation for abstract graph in Haskell\r\n                \r\nI am trying to implement in Haskell a DFS algorithm, which will not have access to the ```\nGraph```\n internals and constructor, but only will be able to use the provided functions to retrieve all graph vertices and all node's neighbours in the graph:\n\n```\nvertices :: Eq a => Graph a -> [a]\nneighbors :: Eq a => Graph a -> a -> [a]\n```\n\n\nAs an input, the function gets a ```\nGraph a```\n and an object ```\na```\n.\n\nAs an output, I am trying to provide a connected component, ```\nGraph a```\n, which will have all vertices reachable from the object. \n\nTo retrieve an empty graph and add vertices I have implemented functions\n\n```\nempty :: Graph a\naddVertex :: Eq a => Graph a -> a -> Graph a\n```\n\n\nFor the ```\ndfs```\n, I have so far implemented a function, which looks more like a general idea but is not even close to being working.\nI feel a bit stuck, so any suggestions or tips are highly appreciated\n\nIn the end, I need to get a connected component of the graph containing the node from the input. (Not strongly connected)\n\nSo probably ```\ndfs```\n itself should return a list of nodes, which then can be used to form a graph using ```\nneighbours```\n function..?\n\nSo far I have this, but it still does not work correctly yet.\n\nThe only issue I have left is to transfer keep the edges in the subgraph\n\n```\nconnectedComponent :: Eq a => Graph a -> a -> Graph a\nconnectedComponent g vrtx | vrtx `notElem`  vertices g = empty\n                            --adds all the points to the created graph   \n                          | otherwise = foldl (\\graph x -> addVertex graph x) initialGraph points \n                                --gets all neighbors of the nodes retrieved in dfs\n                                where \n                                    points = concatMap (neighbors g) (dfs g vrtx) \n                                    initialGraph = addVertex empty vrtx\n\n-- Getting the Graph and a vertex to start from\ndfs :: Eq a => Graph a -> a -> [a]\ndfs graph node | graph == empty = []\n               | [x|x<-(vertices graph),x==node] == [] = []\n               | otherwise = dfs' (vertices graph) graph [node]\n\ndfs' [] _ _ = []\ndfs' _ _ [] = []\ndfs' v graph (top:stack) | [x|x<-v,x==top] == [] = dfs' nextv graph stack\n                     | otherwise = top : dfs' nextv graph (adjacent ++ stack)\n                     where \n                        adjacent = neighbors graph top\n                        --adjacent = [x | (x,y)<-e,y==top] ++ [x | (y,x)<-e,y==top]\n                        nextv = [x|x<-v,x/=top]\n```\n\n    ", "Answer": "\r\nHere is what I've done in the end, works correctly for me.  \n\n```\nconnectedComponent :: Eq a => Graph a -> a -> Graph a\nconnectedComponent g vrtx | vrtx `notElem`  vertices g = empty\n                            --adds all the nodes and edges to the created graph   \n                          | otherwise = foldl addEdge (foldl (\\graph x -> addVertex graph x) initialGraph nodes) edges\n                                --gets all neighbors of the nodes retrieved in dfs\n                                where \n                                    nodes = concatMap (neighbors g) (dfs g vrtx) \n                                    -- init the graph with the start node\n                                    initialGraph = addVertex empty vrtx\n                                    edges = removeDub [(x,y) | x <- (vertices g), y <- (neighbors g x), x `elem` dfs g vrtx]\n\n-- removes dublicates from the edges if (a,b) and (b,a) exist\nremoveDub ::Eq a => [(a,a)] -> [(a,a)]\nremoveDub [] = []\nremoveDub ((x,y):xs) | (y,x) `elem` xs = removeDub xs\n                     | otherwise = (x,y) : removeDub xs\n\n\n-- Getting the Graph and a vertex to start from\ndfs :: Eq a => Graph a -> a -> [a]\ndfs graph node | graph == empty = []\n                 -- stop if this is the node\n               | [x | x<-(vertices graph), x==node] == [] = []\n               | otherwise = dfs' (vertices graph) graph [node]\n\n-- help function for dfs\ndfs' [] _ _ = []\ndfs' _ _ [] = []\ndfs' vs graph (top:stack) | [x | x <- vs, x==top] == [] = dfs' nextv graph stack\n                        -- append the current one and go to the next node\n                     | otherwise = top : dfs' nextv graph (adjacent ++ stack)\n                     where\n                        -- getting all neibourhs for currently viewed node \n                        adjacent = neighbors graph top\n                        -- getting the next node\n                        nextv = [x|x<-vs,x/=top]\n```\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Detecting a cycle in a path between 2 vertices\r\n                \r\nI'm interested in finding if there's a cycle in some path between two given vertices, S and T in a directed graph G.\n\ni.e return \"true\" if there exists at least one path between S and T where there is a cycle, in a time complexity of ```\nO(|V|+|E|)```\n. I just want some algorithm in pseudo-code. \n\nI wanted to use Kosaraju-Sharir's algorithm, the problem is that even if S and T are in the same strongly connected component the answer is not necessarily \"true\", in case the cycle only starts from T and the path from S to T is simple.\n\nThank you.\n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Tarjan's cycle detection: missing cycles\r\n                \r\nI have tried out Tarjan's algorithm for cycle detection with the implementation from http://learn.yancyparedes.net/2012/03/strongly-connected-components-using-tarjans-algorithm/ .\nThe following graph was used for testing: \n    a b \n    a c \n    b a \n    b c \n    c d \n    d a \nAs an output i got the following result: Set 0: [c, b, a, d]\n\nMy problem is that i need ALL cycles, so I'm missing the Sets [a,b] and [a,c,d] in this result.\nDo you now if there is a way to modify the implementation to get all cycles? Or does another algorithm exists for this problem? \n\nThank you!\n    ", "Answer": "\r\nTarjan's algorithm does not find all cycles. It finds all strongly connected components, which is not the same thing. It is not possible to find all cycles efficiently in the general case(for a full graph the size of the output is exponential. Moreover, just finding the longest cycle is already NP-hard). You can use backtracking, of course.  \n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Tarjan's circular cycle multigraph unique nodes\r\n                \r\nI would like to list a cycle from a root node (Tarjan's index 0) in an undirected multigraph which begin and ends at the root node without returning through previously visited nodes a some what circular cycle.\n\nI wrote Tarjan's strongly connected components algorithm in perl using these instructions Cycle detection in a Multigraph.\nThis is my graph\n\n```\nV   E   E   E\n1   2   3   4\n2   1   3   \n3   1   2   \n4           1\n```\n\n\nI get this result \n\n```\n1 root\n3 2 1\n------------\n2 root\n3 1 2\n------------\n3 root\n2 1 3\n------------\n4 root\n3 2 1 4\n------------\n```\n\n\nWhen 4 is selected as index 0 or the root I would like it to return 1 4 because the path must pass through 1 twice to complete the cycle with the solution of 3 2 1 4.\n\nThank you\n    ", "Answer": "\r\nAltering Tarjan's strongly connected components algorithm with a neighbor search to ensure each node share an edge meets my needs. It omits some solutions.\n\n```\nfor each v in V do\n index := 0\n S := empty\n    strongconnect(v)\nrepeat\n...\nwhile (w != v)\n  if (loopcount = 0)\n   w:=v\n  else\n   w := S.pop()\n  end if\nwhile (continuation = false)\n x := S.pop()\n for each (y, x) in E do\n   if (y = w) then\n     continuation = true\n   end if\n  repeat\n  if (x = v) then\n   continuation = true\n S.push(v)\n loopcount := loopcount+1\nif(continuation = true)\n  add x to current strongly connected component\nendif\n repeat\n\n\n        2   \n\n8   3   1   6\n\n    4       7\n        5   \n\n1   2   5   \n2   3   6   1\n3   4   2   8\n4   3   5   \n5   4   7   1\n6   2   7   \n7   5   6   \n8           3\n\n\n\n1 list\n5 4 3 2 1 \n------------\n2 list\n1 5 4 3 2 \n------------\n3 list\n8 3 \n------------\n4 list\n5 7 6 2 3 4 \n------------\n5 list\n1 2 3 4 5 \n------------\n6 list\n7 5 4 3 2 6 \n------------\n7 list\n6 2 3 4 5 7 \n------------\n8 list\n3 8 \n------------\n```\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "How to indetify loops/cyclines in an underected graph?\r\n                \r\nI have an undirected graph that is shown below:\n\n\nCould you recommend or point to what kind of graph algorithm I must apply? \n\nFirst I was thinking that I can apply \"Topological sort\" algorithm, but it identifies strongly connected component, but not cycles?\n\nI tried to implement algorithm based on https://www.geeksforgeeks.org/print-all-the-cycles-in-an-undirected-graph/, but it detects cycles when they are connected by non cyclic edges only.\n\n```\n   addEdge(1, 2);\n    addEdge(2, 3);\n    addEdge(3, 4);\n    addEdge(4, 6);\n    addEdge(4, 7);\n    addEdge(5, 6);\n    addEdge(3, 5);\n    addEdge(7, 8);\n    addEdge(6, 10);\n    addEdge(5, 9);\n    addEdge(10, 11);\n    addEdge(11, 12);\n    addEdge(11, 13);\n    addEdge(12, 13);\n\n\n    // arrays required to color the\n    // graph, store the parent of node\n    int[] color = new int[N];\n    int[] par = new int[N];\n\n    // mark with unique numbers\n    int[] mark = new int[N];\n\n    // store the numbers of cycle\n    int cyclenumber = 0;\n    int edges = 13; //E0.Count\n\n    // call DFS to mark the cycles\n    dfs_cycle(1, 0, color, mark, par, ref cyclenumber);\n\n    // function to print the cycles\n    printCycles(edges, mark, ref cyclenumber);\n\n    for (int i = 0; i < N; i++)\n    {\n      graph[i] = new List<int>();\n      cycles[i] = new List<int>();\n\n\n    }\n\n\n\n const int N = 100000;\n\n  List<int>[] graph = new List<int>[N];\n  List<int>[] cycles = new List<int>[N];\n\n  //function to mark the vertex with\n  //different color for different cycles\n\n  void dfs_cycle(int u, int p, int[] color, int[] mark, int[] par, ref int cyclenumber){\n\n    //already (completely visited vertex)\n    if(color[u] == 2)\n      return;\n\n\n    // seen vertex, but was not completely visited -> cycle detected.\n    // backtrack based on parents to find the complete cycle.\n    if (color[u] == 1) {\n\n      cyclenumber++;\n      int cur = p;\n      mark[cur] = cyclenumber;\n\n      // backtrack the vertex which are\n      // in the current cycle thats found\n      while (cur != u) {\n        cur = par[cur];\n        mark[cur] = cyclenumber;\n      }\n      return;\n    }\n    par[u] = p;\n\n    // partially visited.\n    color[u] = 1;\n\n    // simple dfs on graph\n    foreach (int v in graph[u]) { //[u]\n\n      // if it has not been visited previously\n      if (v == par[u]) {\n        continue;\n      }\n      dfs_cycle(v, u, color, mark, par, ref cyclenumber);\n    }\n\n    // completely visited.\n    color[u] = 2;\n\n\n\n  }\n\n\n  // add the edges to the graph\n  void addEdge(int u, int v)\n  {\n    if(graph[u] == null)\n      graph[u] = new List<int>();\n    if(graph[v] == null)\n      graph[v] = new List<int>();\n    graph[u].Add(v);\n    graph[v].Add(u);\n  }\n\n\n  // Function to print the cycles\n  void printCycles(int edges, int[] mark, ref int cyclenumber)\n  {\n\n    // push the edges that into the\n    // cycle adjacency list\n    for (int i = 1; i <= edges; i++) {\n      if (mark[i] != 0) {\n\n        if(cycles[mark[i]] == null)\n          cycles[mark[i]] = new List<int>();\n\n        cycles[mark[i]].Add(i);\n\n      }\n    }\n\n    // print all the vertex with same cycle\n    for (int i = 1; i <= cyclenumber; i++) {\n      // Print the i-th cycle\n      Print(\"Cycle Number \" + i.ToString() + \":\");\n      //  cout << \"Cycle Number \" << i << \": \";\n      foreach (int x in cycles[i])\n        Print(x.ToString() + \" \");\n      // cout << x << \" \";\n      // cout << endl;\n    }\n  }\n```\n\n\nIt has nodes 0,1,2,3,4,5,6.\nAnd edge 0-1, 1-0, 0-3, 3-0, 2-3, 3-2, 1-2, 2-1, 3-5, 5-3, 4-5, 5-4, 4-5, 2-4, 4-2, 6-4, 4-6, 1-6, 6-1.\n\nI would like to indentify cycles :\n0-1-2-3\n2-4-5-3\n1-6-4-2\n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Bug in my Ruby version of Tarjan's algorithm\r\n                \r\nhttp://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm\n\nhttp://en.algoritmy.net/article/44220/Tarjans-algorithm\n\nI can't figure out this bug in my Ruby version of Tarjan's algorithm for strongly connected components. I got the Kosaraju–Sharir algorithm to work, and my Tarjan's algorithm in Ruby works for some graphs. But it does not connect 2 components that should be connected---\"10\" and \"11, 12, 9\"\n\nInput file is this directed graph: http://algs4.cs.princeton.edu/42directed/tinyDG.txt\n\n```\nexpected: [[\"1\"], [\"0\", \"2\", \"3\", \"4\", \"5\"], [\"10\", \"11\", \"12\", \"9\"], [\"6\", \"8\"], [\"7\"]]\ngot: [[\"1\"], [\"0\", \"2\", \"3\", \"4\", \"5\"], [\"10\"], [\"11\", \"12\", \"9\"], [\"6\", \"8\"], [\"7\"]]\n```\n\n\nDuring this final loop, which tries to make a single component, it starts with \"10\" (last item on stack), but then the current vertex (\"parent\") also is \"10\"! This makes the loop cut off \"10\" as a separate component. Why is the latest item on the stack the same as the parent node? I'd expect \"10\" only to show up at the END of the component, after we've collected [\"12\", \"11\", \"9\"...then \"10\"].  Because \"10\" shows up first, instead of last, we have this problem. How do I fix it?\n\n```\n  begin\n    last_stack_item = stack.pop\n    component << last_stack_item.name\n  end while last_stack_item != parent # we're back at the root\n```\n\n\nMy Ruby code:\n\n```\n    # Tarjan's algorithm to find all strongly connected components (SCCs)\n    def scc_tarjan\n      index = 0 # numbers nodes consecutively in the order discovered\n      stack, scc, vertices = [], [], []\n\n      # create new Struct, if not already defined\n      if Struct::const_defined?(\"TarjanVertex\")\n        Struct.const_get(\"TarjanVertex\")\n      else\n        Struct.new(\"TarjanVertex\", :name, :index, :lowlink)\n      end\n\n      adj_lists.each do |v|\n        # -1 means vertex is unvisited\n        vertex = Struct::TarjanVertex.new(v.name, -1, -1)\n        vertices << vertex  # array of all TarjanVertex objects in graph\n      end\n      vertices.each do |vertex|\n        tarjan_dfs(vertex, scc, stack, index, vertices) if vertex.index == -1\n      end\n      # return nested array of all SCCs in graph\n      scc\n    end\n\n  def tarjan_dfs(parent, scc, stack, index, vertices)\n    # Set depth index for vertex to smallest unused index\n    parent.index = index\n    # lowlink is roughly the smallest index of any node known to be reachable from the vertex\n    parent.lowlink = index\n    index += 1\n    stack << parent\n    # loop through all vertices connected to parent\n    adj_vertices(parent.name, adj_lists).each do |adj_vertex|\n      # since adj_vertices returns array of strings,\n      # must convert to TarjanVertex objects\n      child = vertices.select {|v| v.name == adj_vertex}.first\n\n      if child.index == -1  # if child vertex not yet visited\n        tarjan_dfs(child, scc, stack, index, vertices) # recurse on child\n\n        # change parent's lowlink to smaller lowlink of parent and child)\n        parent.lowlink = [parent.lowlink, child.lowlink].min\n\n      # vertex points to earlier (already visited) one in stack,\n      # with lower index. thus it's the current SCC\n      elsif stack.include?(child)\n        parent.lowlink = [parent.lowlink, child.index].min\n      end\n    end\n\n    # if a vertex's lowlink = its index here, this # cannot go any lower.\n    # vertex MUST be root of the SCC.\n    if parent.lowlink == parent.index\n      component = []  # a single SCC\n\n      # pop off entire SCC, one vertex at a time\n      begin\n        last_stack_item = stack.pop\n        component << last_stack_item.name\n      end while last_stack_item != parent # we're back at the root\n      scc << component.sort # done with a single SCC\n    end\n  end\n```\n\n    ", "Answer": "\r\nI solved my own problem! After going through each loop of my code, with pen and paper, I found that it prematurely went to the bottom component loop at vertex 4. parent.lowlink should NOT equal parent.index at that point. I just had to change 1 word to fix my problem! \n\nI changed \"child.index\" to \"child.lowlink\" in the \"elsif stack.include?(child)\" loop! This correctly dropped 4's lowlink to match that of vertex 6. \n\nSince then parent.lowlink != parent.index, it does not prematurely start making a new component.\n\nInterestingly, my solution is different from all the pseudocode and code online I've found on Tarjan's algorithm, which all says \"parent.lowlink = [parent.lowlink, child.index].min\"\n\nInstead, I needed \"parent.lowlink = [parent.lowlink, child.lowlink].min\"\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "NetworkX community detection algorithms run indefinetely\r\n                \r\nI am using NetworkX library for its community detection algorithms.Currently I am working with the Pokec dataset from SNAP datasets. I keep the largest Strongly Connected Component in order to work with.\nUnfortunately every community detection algorithm takes indefinetely execution time for the specific dataset. Specifically, I let Girvan Newman run overnight and about 12 hours of execution later, the algorithm still running. Currently, I am running Greedy Modularity and after 400mins still no result.\nI am following documentation instructions but yet I am feeling that it is not optimal for large graphs like this one.\nHas anyone else addressed something like that? Am I using the library in wrong way for large datasets? Should I be more patient and wait more for results?\nMy code is underneath:\n```\nimport networkx as nx\nfrom networkx.algorithms.community import greedy_modularity_communities\n\npokec = nx.read_edgelist(\"Data/soc-pokec-relationships.txt\", nodetype=int, delimiter='\\t', create_using=nx.DiGraph())\n\npokecSCC = max(nx.strongly_connected_components(pokec), key=len)\npokecSCCGraph = pokec.subgraph(pokecSCC)\n\nmodularity_comms = greedy_modularity_communities(pokecSCCGraph)\n```\n\n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "How can I determine if a directed graph has a path that consumes all edges starting from a certain node?\r\n                \r\nThere's no restrictions that you have to cross each edge only once, or each vertex. \n\nIs there some property of the graph that is necessary and sufficient for the existence of such a path (like the degrees of nodes for the existence of the Eulerian path), or some known algorithm that proves there is or there isn't one (perhaps finding the minimum path through all edges from the starting one)?\n\nI have considered several possibilities, the strongest of which is collapsing strongly connected components into single supernodes, then check if the resulting graph is simply a \"linked list\"-like graph covering all edges (which is simple, just walking from the starting node/supernode always talking a single edge from the current node, counting the outgoing edge (and any internal edges if it is a supernode) as visited and when you reach a leaf node see if all edges were counted). In this solution it is important to conserve all the original edges even if they become redundant (for example, if after collapsing the connected component A, B, C into supernode S, edges from F to A, F to B, F to C must all be conserved even though they point to the same supernode S in the simplified graph). Sorry if it's not expressed correctly, I will be trying to implement this solution while I wait for answers.\n\nIs there an easier way? Or some better algorithm to handle cycles/connected components? Because when the graph is acyclic it seems very easy to solve. \n    ", "Answer": "\r\nIf the graph is strongly-connected, then you can get to every node from every other node. Since you are allowed to reuse edges in this path, it must be the case that you can use every edge. Take some edge, e. e leads to a node v, from which you can subsequently get to every other vertex and, therefore, get to every other edge. From those, you can get back to v. Repeat as needed.\n\nThus to answer the question Is there some property of the graph that guarantees the existence of such a path... I would say yes, if the graph is strongly-connected. (Note, this isn't required for such a path though—example, in the case of a single one-directional path with no branches). But that seems to be the single edge-case (that I can think of).\n\nTesting for strong-connectedness can be done by the brute-force, check-all method trivially. You can also adapt the max-flow, min-cut algorithm for this as well I believe.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Detect Disconnected Subtours in Graph\r\n                \r\nI have used an Integer Linear Program (ILP) to generate a path from ```\nsource```\n to ```\nsink```\n in a graph. Each variable ```\nPij```\n in the solution represents a transition from node ```\ni```\n to ```\nj```\n in the path. Unfortunately, the result is a collection of 2 or more disconnected directed subtours, that do not have a transition from one to the other, thereby making the path useless.\nThere are ways to prevent subtours from happening, but they first require the detection of such disconnected subtours in primitive solution. Now here's my question: how do I detect disconnected subtours?\nSome features of the problem:\n\nI have the primitive solution in the form of both, an adjacency matrix and adjacency list\nThe ```\nsource```\n and ```\nsink```\n vertices are distinct. No looping back to ```\nsource```\n\nAny vertex in the graph may be traversed any number of times. No rule that it should be traversed only once\n\nMy thoughts:\n\nIf there are disconnected subtours, then they are actually acting as independent, directed graphs on their own, and hence the problem can be restated as detecting all graphs within an adjacency matrix/list\nMy first instict was to detect all Strongly Connected Components (SCC's) in the graph, but I retracted after realising that Kosaraju's and other such algorithms are infeasible over disconnected subtours. I can apply such algorithms within each subtour, though.\n\nWhat could solve the problem (According to me):\n\nModification of existing SCC detection algorithms to operate on disconnected graphs\nAdaptation of graph traversal algorithms to operate on disconnected graphs\nAny existing method (of course)\nExperience of anyone to have faced a similar issue.\n\n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Find all cycles in graph, redux\r\n                \r\nI know there are a quite some answers existing on this question. However, I found none of them really bringing it to the point.\nSome argue that a cycle is (almost) the same as a strongly connected components (s. Finding all cycles in a directed graph) , so one could use algorithms designed for that goal.\nSome argue that finding a cycle can be done via DFS and checking for back-edges (s. boost graph documentation on file dependencies).\n\nI now would like to have some suggestions on whether all cycles in a graph can be detected via DFS and checking for back-edges?\nhttp://www.me.utexas.edu/~bard/IP/Handouts/cycles.pdf (found here on S.O.) states one methode based on cycle bases. Me personally, I don't find it very intuitive so I'm looking for a different solution.\n\nEDIT: My initial opinion was apparently wrong. S. next answer by \"Moron\".\n\nInitial opinion:\nMy opinion is that it indeed could work that way as DFS-VISIT (s. pseudocode of DFS) freshly enters each node that was not yet visited. In that sense, each vertex exhibits a potential start of a cycle. Additionally, as DFS visits each edge once, each edge leading to the starting point of a cycle is also covered. Thus, by using DFS and back-edge checking it should indeed be possible to detect all cycles in a graph. Note that, if cycles with different numbers of participant nodes exist (e.g. triangles, rectangles etc.), additional work has to be done to discriminate the acutal \"shape\" of each cycle.\n    ", "Answer": "\r\nI have already answered this thoroughly, so check this:\n\nWill a source-removal sort always return a maximal cycle?\n\nThe relevant part of the answer:\n\n\n  Perform a Depth-First Search on your\n  graph.\n  \n  You are interested in recognizing back\n  edges, i.e., in the traversal, an edge\n  which points back to an ancestor (in\n  the DFS tree, which is induced by\n  edges of visiting nodes for the first\n  time) of the visited node. For\n  example, if the DFS stack has nodes\n  [A->B->C->D] and while you explore D\n  you find an edge D->B, that's a back\n  edge. Each back edge defines a cycle.\n  \n  More importantly, the cycles induced\n  by back-edges are a basic set of\n  cycles of the graph. \"A basic set of\n  cycles\": you can construct all cycles\n  of the graph just by UNIONing and\n  XORing cycles of the basic set. For\n  example, consider the cycles\n  [A1->A2->A3->A1] and\n  [A2->B1->B2->B3->A2]. You can union\n  them to the cycle:\n  [A1->A2->B1->B2->B3->A2->A3->A1].\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Finding a Minimal set of vertices that satisfy the given constraints\r\n                \r\nNote: no need for formal proof or anything, just the general idea of the algorithm and I will go deeper myself.\nGiven a directed graph: ```\nG(V,E)```\n, I want to find the smallest set of vertices ```\nT```\n, such that for each vertex ```\nt```\n in ```\nT```\n the following edges don't exist: ```\n{(t,v) | for every v outside t}```\n in ```\nO(V+E)```\n\nIn other words, it's allowed for ```\nt```\n to get edges from vertices outside ```\nT```\n, but not to send.\n(You can demonstrate it as phone call, where I am allowed to be called from outside and it's free but it's not allowed to call them from my side)\n\nI saw this problem to be so close or similar to finding all strongly connected components (scc) in a directed graph which its time complexity is ```\nO(V+E)```\n and I'm thinking of building a new graph and running this algorithm but not totally sure about that.\n    ", "Answer": "\r\nThe main idea is to contract each strongly connected component (SCC) of G into a single vertex while keeping a score on how many vertices were contracted to create each vertex in the contracted graph (condensation of G). The resulting graph is a directed acyclic graph. The answer is the vertex with lower score among the ones with out-degree equal 0.\nThe answer structure is an union of strongly connected components because of the restriction over edges and you can prove that there is only a SCC involved in the answer because of the min restriction.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "How to experimentally simulate and compare various graph cycle detection algorithms?\r\n                \r\nI studied about various algorithms for cycle detection algorithm in directed graphs like incremental way search, strongly connected components, BFS, two way search, etc. Now I want to simulate it and compare the performance. I am calling cycle detection function whenever I am inserting an edge.\n\nSo, my question is what kind of datasets should I consider. If I consider random graphs, then what should be the criteria for evaluation of various algorithms. Some random graph might be of huge size; but they might lead to cycle in a few iterations. It would be helpful if someone can suggest how to go about this.\n\nAlso, to compare the performance, does it make sense to remove cycle and then continue insertions again. Once it terminates, compare the execution times of all the implementations?\n    ", "Answer": "\r\nIt really depends on what you're doing this for. In general, there are many random graph generating approaches, but arguably the most famous is Erdos-Renyi. Note though, that for a graph with n vertices to not have a cycle, it must have at most n - 1 edges, so such random graph generators will have a cycle with high probability. Depending on your exact case, you might find it best therefore to keep the graph as sparse as possible (i.e. allow for few edges).\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Why does it makes \"unknown signal 11\"?\r\n                \r\nI write some codes about finding strongly connected components.\n\n```\nusing edge=pair<int, int>;\n\nvoid dfsSCCFind(int vertex, vector<vector <int>>& adj, vector<int>& check, vector<int>& SCC, vector<edge>& SCCEdge){\n    if(check[vertex]==0){\n        check[vertex]=1;\n        SCC.push_back(vertex);\n        for(int i=0; i<(int)adj[vertex].size();i++){\n            int neighbor=adj[vertex][i];\n            if(check[neighbor]==0){\n                SCCEdge.push_back({vertex, neighbor});\n                dfsSCCFind(neighbor, adj, check, SCC, SCCEdge);\n            }\n        }\n    }\n}\n```\n\n\nMy main function call 'dfsSCCFind'for all vertices in a graph.\n\nBut it makes unknown signal 11. I think it might be due to stackoverflow.\n\nSo, I added the code enlarge the stack size and it works properly.\n\nHowever when I modify the code like below, it works properly without enlarging stack size.\n\n```\n\nvoid dfsSCCFind(int vertex, vector<vector <int>>& adj, vector<int>& check, vector<int>& SCC){\n    if(check[vertex]==0){\n        check[vertex]=1;\n        SCC.push_back(vertex);\n        for(int i=0; i<(int)adj[vertex].size();i++){\n            int neighbor=adj[vertex][i];\n            if(check[neighbor]==0){\n                dfsSCCFind(neighbor, adj, check, SCC, SCCEdge);\n            }\n        }\n    }\n}\n```\n\n\nI just deleted a vector parameter and the code related with it.\n\nI know vector is allocated on heap, not stack. Therefore, I think it is not related with \"Unknown signal 11\"\n\nif it is related with the maximum heap size, it might not have been solved by enlarging stack size.\n\nWhat is the cause of my code?\n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "most lightweight circle in directed graph that goes through specific vertex\r\n                \r\nI have directed Graph G(V,E) with weight function w. so that weight of each (u,v) is a positive value. I need to find the most lightweight circle in the graph that vertex k' is part of it.\n\nI've also given an algorithm i can use which can find the most lightweight path for a graph with positives weights ( i can use it only once).\n\nI thought about creating a sub graph G' where all vertices and edges that are strongly connected components. find the graph which k' is part of it. then find for the most lightweight adjacent edge from k' to some v of vertices. from that v i can run the algorithm given and find the lightweight path then add the weight of the vertex missing ( (k',v) ).\n\nis that seems correct ? I'm in the beginning of this course and I feel i'm not there yet.\n    ", "Answer": "\r\nIt is a single-source shortest-path problem, where you exclude ```\nk->k```\n self-loop as a solution, and find a longer path from k to k. The trick is always expand the shortest path thread.\n\nGiven this definition, you can start Googling...\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Algorithm for finding cost of a node based on preceding nodes in a cyclic graph\r\n                \r\nI have a partially or entirely cyclic graph for which I want to calculate the cost of each node based on the weighted sum of the costs of preceding nodes. Nodes without incoming edges have a fixed cost assigned to them.\n\nFor example, the following graph has each node labeled with its calculated cost (the cost of node 2 is fixed), and each edge is labeled with the weight of the preceding node. Thus, the node 1.33 cost is calculated from 1*0.33 + 0.5*2.\n\n\n\nI currently use an iterative approach to calculate the cost of each node to within some epsilon, but am looking for an algorithm that can calculate the costs exactly. The example above is pretty simple, the actual problem deals with ~100 nodes per strongly connected component. Any suggestions for an algorithm that can solve this?\n    ", "Answer": "\r\nYou can build a system of linear equations and solve them. In the example you gave, node 2 is fixed since it has no incoming edge. Assigning value ```\nx```\n to the upper right node, ```\ny```\n to the upper left node and ```\nz```\n to the lower node, you build the following system of linear equations\n\n```\nx = 0.5*2 + 1*y\ny = 0.5*z\nz = 0.5*x\n```\n\n\nUsing WolframAlpha, we have \n\n```\nx=1.33333,   y=0.333333,   z=0.666667\n```\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Can I use just a simple Set for cycle detection in directed graph?\r\n                \r\nI have seen quite a lot of algorithms to do cycle detection, such as Tarjan's strongly connected components algorithm answered in Best algorithm for detecting cycles in a directed graph.\n\nI never thought detecting a cycle would be that complicated and I always believed a simple ```\nSet```\n can help solve the problem. \n\nSo in addition to the usual ```\nmarker```\n array for recording visited vertices, we can use an additional ```\nSet```\n to record all vertices along a path from the source.\n\nThe key thing is to remember to remove a vertex from the set after all its next neighbours are done.\n\nA trivial code is like this:\n\n```\npublic boolean hasCycle(List<Integer>[] vs) {\n  boolean[] marker = new boolean[v.length];\n  Set<Integer> tracker = new HashSet<Integer>();\n\n  for(int v = 0;v < vs.length;v++)\n    if (explore(v, vs, marker, tracker)) return true;\n\n  return false;\n}\n\nprivate boolean explore(int v, List<Integer>[] vs, boolean[] marker, Set<Integer> tracker) {\n  if (tracker.contains(v)) return true;\n  else if (!marker[v]) {\n    marker[v] = true;\n    tracker.add(v); // add current vertex to tracker\n    for (int u:vs[v]) if (explore(v, vs, marker, tracker)) return true;\n    tracker.remove(v); // remove the vertex from tracker, as it is fully done.\n  }\n  else return false;\n}\n```\n\n\nIs there any problem about this algorithm?\n\n\n\nWith help from sasha's answer, actually even the set is not necessary and just an array is enough.\n\n```\npublic boolean hasCycle(List<Integer>[] vs) {\n  boolean[] marker = new boolean[v.length];\n  boolean[] onPath = new boolean[v.length];\n\n  for(int v = 0;v < vs.length;v++)\n    if (explore(v, vs, marker, onPath)) return true;\n\n  return false;\n}\n\nprivate boolean explore(int v, List<Integer>[] vs, boolean[] marker, boolean[] onPath) {\n  if (onPath[v]) return true;\n  else if (!marker[v]) {\n    marker[v] = true;\n    onPath[v] = true; // add current vertex to the path\n    for (int u:vs[v]) if (explore(v, vs, marker, onPath)) return true;\n    onPath[v] = false; // remove the vertex from the path, as it is fully done.\n  }\n  else return false;\n}\n```\n\n    ", "Answer": "\r\nI am not an expert in java but talking about C++ passing set etc in recursion is not time efficient. Also set takes O(log(n)) in inserting/deleting an element. Your logic looks correct to me. But you can do it more efficiently and easily by keeping two arrays parent[] and visited[]. Basically do a bfs and following is the pseudo code ( visited is initialized to all zeros ) . \n\n```\n   /* There are n nodes from 0 to n-1 */\n   visited[0]=1\n   parent[0]=0\n   flag=0\n   queue.push(0)\n   while the queue is not empty\n       top = queue.front()\n       queue.pop()\n       for all neighbors x of top\n           if not visited[top]\n              visited[x]=1\n              parent[x]=top\n              queue.push(x)\n           else if visited[x] is 1 and parent[top] is not x\n                flag = 1\n\n   if flag is 1 cycle is there otherwise not\n```\n\n\nAs it may not be necessary that starting from 0 all nodes are visited . So repeat until all nodes are visited. Complexity is O(E+V) slightly better than the complexity of your method O(E+VlogV). But it is simple to write and  not recursive.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Segmentation fault , while accepting graph inputs from input file\r\n                \r\nI am writing a program to find out \"Strongly Connected Component\" of a given graph.       \n\nFor that I am using following algorithm.\n1) Apply DFS and push the nodes in decreasing order of their Finishing time in stack.\n2) Transpose the graph. ( reverse the edges of the graph)\n3) Pop the node and apply DFS again.        \n\nFor this if I accept the graph edges by function addEdge(int u, int v) (edge from node u to node v).\nthen  program works correctly.\nQuestion : But when I try to accept graph through input file, it is giving me error.\nI am not giving whole program as it is working correctly.       \n\n```\nclass Graph\n{\n    int V;\n    list<int> *adj;\n    void fillorder( int v , bool visited[] , stack<int> &stack);\n    void DFSUtil(int v , bool visited[]);    \n\n    public:     \n\n    Graph( int V);\n    void printSCCs();\n    Graph get_Transpose();\n    void print_graph();\n    void read_input_file();\n\n};     \n\n\n    Graph:: Graph(int V)\n{\n    this-> V = V;\n    adj = new list<int>[V];\n}\nvoid Graph :: read_input_file()\n{\n   const long int N = 100;\n\n   std::ifstream infile(\"S.txt\"); \n   std::string line;\n\n   int i = 0;\n   while ( i < N && getline(infile, line) )\n   {\n      std::istringstream str(line);\n      int u;\n\n      str >> u;\n      if ( u > N )\n      {\n         // Problem.\n         abort();\n      }\n\n      int v;\n      while ( str >> v )\n      {\n         adj[u-1].push_back(v);\n      }\n      ++i;\n   }\n}\n\nvoid Graph :: print_graph()\n{\n    for( int i = 0 ; i < 9 ; i++ )\n    {\n        list<int> :: iterator itr;\n        for( itr = adj[i].begin(); itr != adj[i].end(); ++itr )\n        {\n           cout<< i+1 <<\" --> \" << *itr <<endl;\n        }\n    }\n}\n\nvoid Graph:: printSCCs()\n{\n    stack<int>Stack;\n    bool *visited = new bool[V];\n    for( int i = 0 ; i < V ; i++ )\n        visited[i] = false;\n\n     for( int i = 0 ; i < V ; i++ )\n     if(visited[i] == false)\n     fillorder(i , visited , Stack);\n\n     Graph gr = get_Transpose();\n\n     for( int i = 0 ; i < V ; i++ )\n        visited[i] = false;\n\n        while( Stack.empty() == false)\n        {\n\n            int no = Stack.top();\n            Stack.pop();\n            if(visited[no] == false)\n              {\n              gr.DFSUtil(no , visited);\n              cout<< endl;\n              }\n        }\n}\n\nint main()\n{\n    Graph g(9);\n    g.read_file(); // Working perfectly\n    g.print_graph(); // showing graph perfectly\n    g.printSCCs(); // Giving error : Segmentation fault: core dump\n    return 0;\n}       \n```\n\n\nGraph is getting printed correctly but ```\ng.printSCCs()```\n is not working.       \n\n```\nError is : Segmentation fault: core dump       \n\nNow if g.print_graph() is working perfectly then why not g.printSCCs() ?       \n```\n\n\nNOTE :  I have not pasted whole program just to insure that it will be readable.\nMoreover , by manually entering edges , whole program works perfectly , so I think there will not be error in any function.     \n\nI/P file data :       \n\n```\n1 4\n\n2 8\n\n3 6\n\n4 7\n\n5 2\n\n6 9\n\n7 1\n\n8 5\n\n8 6\n\n9 7\n\n9 3\n```\n\n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "How can I get rid of this stack overflow problem in python for Kosaraju's algorithm?\r\n                \r\nI'm a new programmer, and I'm working through Stanford's algorithms course on edX.\nOne of the programming assignments is to find strongly connected components using Kosaraju's algorithm, on a graph with ~1,000,000 vertices. My implementation is the most basic translation from the textbook's pseudo code into Python, and it works fine on smaller graphs, so I think it's correct.\nWith Python's default recursion limit of 1000 it reaches the limit.\nI've tried ```\nsys.setrecursionlimit(1000000)```\n, but that doesn't help, and instead I get \"Process finished with exit code -1073741571\" which is a stack overflow.\nI found these two pages for increasing stack size limits, but am not sure how to use either of them: Set stack size, ulimit command.\nAnother relevant bit of information is that Python doesn't optimize tail recursion, but I'm not sure that applies to my code as it currently is.\n```\nG = {}\nfor i in range(1, 875715):\n    G[i] = [0]\nfor l in open('SCC.txt'):\n    items = list(map(int, l.split()))\n    G[items[0]].append(items[1])\n\nGrev = {}\nfor i in range(1, 875715):\n    Grev[i] = [0]\nfor l in open('SCC.txt'):\n    items = list(map(int, l.split()))\n    Grev[items[1]].append(items[0])\n\ndef TopoSort(G):\n    for v in G:\n        if G[v][0] == 0:\n            DFStopo(G, v)\n\ndef DFStopo(G, s):\n    G[s][0] = 1\n    global orderedVertexList\n    for v in G[s][1:]:\n        if G[v][0] == 0:\n            DFStopo(G, v)\n    orderedVertexList.insert(0, s)\n\ndef Kosaraju(G, Grev):\n    TopoSort(Grev)\n    global numSCC\n    for v in orderedVertexList:\n        if G[v][0] == 0:\n            numSCC = numSCC + 1\n            DFSSCC(G, v)\n\ndef DFSSCC(G, s):\n    G[s][0] = 1\n    global SCC\n    SCC.append(numSCC)\n    for v in G[s][1:]:\n        if G[v][0] == 0:\n            DFSSCC(G, v)\n\nnumSCC = 0\norderedVertexList = []\nSCC = []\n\nKosaraju(copy.deepcopy(G), copy.deepcopy(Grev))\n```\n\n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Grouping people by hobbies\r\n                \r\nI have been trying to solve this problem but can't really connect it with any solution. I have following data set:\n```\n[\n  {\"name\": \"sam\", \"hobbies\": [\"Books\", \"Music\", \"Gym\"]},\n  {\"name\": \"Steve\", \"hobbies\": [\"Books\", \"Swimming\"]},\n  {\"name\": \"Alex\", \"hobbies\": [\"Gym\", \"Music\"]}\n]\n```\n\nI am trying to generate output dataset that can combine people by hobbies. So output should look something like this:\n```\n[\n  {\"names\": [\"sam\", \"Steve\"], \"hobbies\": [\"Books\"]},\n  {\"names\": [\"sam\", \"Alex\"], \"hobbies\": [\"Music\", \"Gym\"]},\n  {\"names\": [\"Steve\"], \"hobbies\": [\"Swimming\"]}\n]\n```\n\nIts a large dataset so I was trying to use Spark.\nThings I have tried:\n\nInitially I was trying to see if its a graph problem and I can use something like strongly connected components, but looks like that won't solve the problem.\n\nEach output row looks like a bipartite graph but I was not able to find a way to generate that as well.\n\nAnother approach was clustering but I thought it will not be deterministic. Please let me know if I am wrong. I am not too familiar with it.\n\n\nLet me know if I am missing something obvious here. Thanks.\n    ", "Answer": "\r\nCheck below code.\n```\nscala> df.show(false)\n+-------------------+-----+\n|hobbies            |name |\n+-------------------+-----+\n|[Books, Music, Gym]|sam  |\n|[Books, Swimming]  |Steve|\n|[Gym, Music]       |Alex |\n+-------------------+-----+\n```\n\nUse ```\ngroupBy```\n & ```\ncollect_list```\n\n\nGroup By ```\nhobbies```\n & Collect List of ```\nnames```\n\nGroup By ```\nnames```\n & Collect List of ```\nhobbies```\n\n\n```\nscala> :paste\n// Entering paste mode (ctrl-D to finish)\n\ndf\n.withColumn(\"hobbies\",explode($\"hobbies\"))\n.groupBy($\"hobbies\").agg(collect_list($\"name\").as(\"names\")) // For Hobbies List\n.groupBy($\"name\").agg(collect_list($\"hobbies\").as(\"hobbies\")) // For Name List\n.select(collect_list(to_json(struct($\"hobbies\",$\"names\"))).as(\"data\")) // Final Json Output\n.show(false)\n\n\n// Exiting paste mode, now interpreting.\n\n+--------------------------------------------------------------------------------------------------------------------------------------------+\n|data                                                                                                                                        |\n+--------------------------------------------------------------------------------------------------------------------------------------------+\n|[{\"hobbies\":[\"Swimming\"],\"names\":[\"Steve\"]}, {\"hobbies\":[\"Books\"],\"names\":[\"sam\",\"Steve\"]}, {\"hobbies\":[\"Music\",\"Gym\"],\"names\":[\"sam\",\"Alex\"]}]|\n+--------------------------------------------------------------------------------------------------------------------------------------------+\n\n```\n\nFormatted Output\n```\n[\n  { \"hobbies\": [\"Swimming\"],\"names\": [\"Steve\"]},\n  {\"hobbies\": [\"Books\"],\"names\": [\"sam\",\"Steve\"]},\n  {\"hobbies\": [\"Music\",\"Gym\"],\"names\": [\"sam\",\"Alex\"]}\n]\n```\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "how to find path of a cycle from an adjacency list\r\n                \r\nI have a directed subgraph with all the nodes in a cycle (with 21 nodes and ~250 edges) and I want to know the order of how the nodes form the cycle. \n\nI'm not familiar with graph algorithm. I thought about using the ```\nigraph::graph.dfs```\n function to the original or reverse graph. And use the ```\norder```\n or ```\norder.out```\n returned as the order, but it didn't work.\n\nThe subgraph was a strongly connected components found with ```\nigraph::clusters```\n\n\nI've asked a similar question but the ```\ngraph.get.subisomorphisms.vf2```\n takes too long to run in my case.\n\nI'm thinking if I can get an ordered adjacency list like this, I may able to find the cycle starting from the longest list\n\n\n\nBut I can only get an unordered list using ```\nigraph::get.adjlist```\n, I'd like to know if there's a way to get an ordered list like below.\n\nAnd any suggestions to find the node order of the cycle?\n\nThanks in advance!\n\ndata\n\n```\n> dput(adjlist)\nstructure(list(`26` = c(2, 3, 4, 5, 6, 7, 8, 10, 11, 15, 16, \n18, 19), `2` = c(1, 3, 4, 5, 6, 7, 8, 10, 15, 16, 18), `30` = c(1, \n2, 4, 5, 6, 7, 8, 10, 11, 14, 15, 16, 17, 18, 19, 21), `25` = c(1, \n2, 3, 5, 6, 7, 8, 9, 10, 11, 15, 16, 18, 21), `29` = c(1, 2, \n3, 4, 6, 7, 8, 9, 10, 11, 15, 16, 18, 21), `9` = c(1, 2, 3, 4, \n5, 7, 8, 10, 14, 15, 16, 18, 19), `27` = c(1, 2, 3, 4, 5, 6, \n8, 14, 15, 18), `13` = c(3, 4, 5, 15), `14` = c(1, 2, 3, 4, 5, \n6, 7, 8, 10, 11, 14, 15, 16, 18, 19, 21), `8` = c(1, 2, 3, 4, \n5, 6, 7, 8, 14, 15, 16, 18), `23` = c(1, 2, 3, 4, 5, 6, 7, 8, \n10, 14, 15, 16, 17, 18, 19), `20` = c(1, 2, 3, 4, 5, 6, 7, 8, \n9, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21), `19` = c(1, 2, \n3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15, 16, 17, 18, 19, 21), \n    `17` = c(1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 15, 16, 17, 18, \n    21), `12` = c(3, 4, 5, 6, 8), `24` = c(4, 6, 7, 8, 9, 10, \n    11, 15), `21` = c(13, 14), `6` = c(2, 3, 4, 5, 6, 8, 10, \n    15), `28` = c(1, 7, 11, 16), `15` = c(1, 2, 3, 4, 5, 6, 7, \n    8, 9, 10, 11, 14, 15, 16, 17, 18, 19, 21), `11` = c(3, 4, \n    5, 6, 8, 15)), .Names = c(\"26\", \"2\", \"30\", \"25\", \"29\", \"9\", \n\"27\", \"13\", \"14\", \"8\", \"23\", \"20\", \"19\", \"17\", \"12\", \"24\", \"21\", \n\"6\", \"28\", \"15\", \"11\"))\n```\n\n    ", "Answer": "\r\nJust to make sure the problem is correctly understood: you have a subgraph of a directed graph induced by the vertices of a strongly connected component. What you would like to have is a cycle containing all vertices of the component. Two possible versions (see the introductory paragraphs here for some clarification on the confusing terminology that has developed in this respect):\n\na) Each vertex is allowed to appear exactly once on the cycle, i.e. you want a simple cycle where each vertex is incident with exactly two edges of the cycle. Finding such a cycle is the Hamiltonian Cycle problem, a staple of complexity theory which is NP-hard; no human is known to have an efficient algorithm for that.\n\nb) Vertices are allowed to be adjacent to more than two edges of the cycle, i.e. you want a closed walk through the component. You can do that by identifying cycles that connect the component (you should be able to extract those easily enough from an algorithm that identifies strongly connected components), and then you build a Eulerian Cycle of the union of the cycles you found, ignoring all other edges in the component. This is possible efficiently, and should be fairly straightforward to implement.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Same ID generation for same users in spark\r\n                \r\nIn Spark, we need to generate ID column such that if multiple users have the same Emails Or Phones then they should be assigned with the same ID.\n\n\n\n\nemail\nphone\nid\n\n\n\n\na@b.com\n123\n1\n\n\nc@d.com\n123\n1\n\n\ne@g.com\n234\n1\n\n\ne@g.com\n123\n1\n\n\na@b.com\n\n1\n\n\na@b.com\n789\n1\n\n\nd@e.com\n9090\n2\n\n\ne@g.com\n549\n1\n\n\nf@e.com\n549\n1\n\n\ng@e.com\n550\n1\n\n\nh@e.com\n549\n1\n\n\nf@e.com\n551\n1\n\n\ng@e.com\n551\n1\n\n\nz@e.com\n519\n3\n\n\n\n\nWe tried strongly connected component from graph frame in pyspark and it works for about ~30 million records. The problem is we have about 100 million records and we need an optimal solution for that.\nThanks\n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Should D. B. Johnson's \"elementary circuits\" algorithm produce distinct results?\r\n                \r\nJohnson's paper starts out describing distinct elementary circuits (simple cycles) in a directed graph:\n\n\n  A circuit is elementary if no vertex but the first and last appears twice. Two elementary circuits are distinct if one is not a cyclic permutation of the other. There are c distinct elementary circuits in G\n\n\nI tried to cobble together something vaguely resembling the pseudo code, kind of badly cheating off of networkx and this Java implementation. I am apparently not getting distinct elementary circuits. \n\nThis is my code. It uses the goraph library, but doesn't really do too much with it, besides getting strongly connected components.\n\n```\npackage main\n\nimport (\n    \"fmt\"\n    \"github.com/gyuho/goraph/algorithm/scc/tarjan\"\n    \"github.com/gyuho/goraph/graph/gs\"\n)\n\nfunc main() {\n\n    gr := gs.NewGraph()\n\n    a := gr.CreateAndAddToGraph(\"A\")\n    b := gr.CreateAndAddToGraph(\"B\")\n    c := gr.CreateAndAddToGraph(\"C\")\n    d := gr.CreateAndAddToGraph(\"D\")\n    e := gr.CreateAndAddToGraph(\"E\")\n    f := gr.CreateAndAddToGraph(\"F\")\n\n    gr.Connect(a, b, 1)\n    gr.Connect(b, c, 1)\n    gr.Connect(c, a, 1)\n\n    gr.Connect(d, e, 1)\n    gr.Connect(e, f, 1)\n    gr.Connect(f, d, 1)\n\n    sccs := tarjan.SCC(gr) // returns [][]string\n    for _, scc := range sccs {\n        if len(scc) < 3 {\n            continue\n        }\n        for _, v := range scc {\n            n := node(v)\n            circuit(n, n, gr)\n        }\n    }\n    fmt.Println(result)\n}\n\ntype node string\n\nvar blocked = make(map[node]bool)\nvar B = make(map[node][]node)\nvar path []node\nvar result [][]node\n\nfunc circuit(thisNode node, startNode node, g *gs.Graph) bool {\n    closed := false\n    path = append(path, thisNode)\n    blocked[thisNode] = true\n\n    adj := g.FindVertexByID(string(thisNode)).GetOutVertices().GetElements()\n    for _, next := range adj {\n        nextNode := node(next.(*gs.Vertex).ID)\n\n        if nextNode == startNode {\n            cycle := []node{}\n            cycle = append(cycle, path...)\n            cycle = append(cycle, startNode)\n            result = append(result, cycle)\n            closed = true\n        } else if !blocked[nextNode] {\n            if circuit(nextNode, startNode, g) {\n                closed = true\n            }\n        }\n    }\n\n    if closed {\n        unblock(thisNode)\n    } else {\n        adj = g.FindVertexByID(string(thisNode)).GetOutVertices().GetElements()\n        for _, next := range adj {\n            nextNode := node(next.(*gs.Vertex).ID)\n            inB := false\n            for _, v := range B[nextNode] {\n                if v == thisNode {\n                    inB = true\n                }\n            }\n            if !inB {\n                B[nextNode] = append(B[nextNode], thisNode)\n            }\n        }\n    }\n    path = path[:len(path)-1]\n    return closed\n}\n\nfunc unblock(thisNode node) {\n    stack := []node{thisNode}\n    for len(stack) > 0 {\n        n := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n        if blocked[n] {\n            blocked[n] = false\n            stack = append(stack, B[n]...)\n            B[n] = []node{}\n        }\n    }\n}\n```\n\n\nThis is the output:\n\n```\n[[C A B C] [B C A B] [A B C A] [F D E F] [E F D E] [D E F D]]\n```\n\n\nGraph theory is a spooky, dark forest full of magic for me, so I'm not sure what I'm missing. Am I misreading the paper? Is it implied that redundant permutations should be filtered out some other way? Did I screw up the code?\n    ", "Answer": "\r\nThe redundant permutations are filtered out because the start node of each returned permutation is always less than all the remaining elements (under some ordering).\n\nI suspect the problem is in a missing implementation of these steps:\n\n\n  AK:= adjacency structure of strong component K with least vertex in\n  subgraph of G induced by {s, s+ 1, n};\n\n\nand\n\n\n  s := least vertex in V;\n\n\nThese steps should ensure that the start of each permutation (s) is always less than the rest of the permutation but I cannot see code to implement this, instead you seem to loop through every node in the strongly connected component.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "How to Topologically Sort a Directed Graph with Cycles\r\n                \r\nI'm struggling to define this problem exactly, which is part of the reason I cannot solve it. Basically, I want to assign numbers to nodes that provides a kind of topological sorting, but if there is a cycle in the graph, which I want to allow, it should assign values to the nodes that essentially count up the distance from nearest non-cycle nodes.\neg, If there were another non-cyclic dependency, the numbers assigned to the nodes may look more like this.\n\nCurrently, the numbers assigned are just based on total dependencies, which creates less-than-ideal layouts.\n\nI have a feeling that I might need to use some algorithm involving Strongly Connected Components, but I'm not sure how to apply it to get the desired result. Any help clarifying this issue would be greatly appreciated!\n    ", "Answer": "\r\nTarjan's algorithm for generating Strongly Connected Components already topologically sorts the components (in reverse). On the other hand, Bellman-Ford gives you the shortest path to a given node in a graph.\nSo the approach I went with was:\n\nimplementing Tarjan's algorithm to sort all SCCs\napplying Bellman-Ford to any SCCs of more than one node, where the shortest path is calculated to an arbitrarily-selected \"entry node\", ie, a node with a predecessor leading outside the cycle.\n\nwhich renders graphs like this:\n\nnot too bad!\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Using DFS on a Graph - Determine if a graph is a clique with specific SCC [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is off-topic. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it's on-topic for Stack Overflow.\r\n                \r\n                    \r\n                        Closed 10 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI have a simple question on DFS and I'm trying to understand how to use it and not how to solve the whole problem. I'm really looking for an explanation and not a solution to my homework.\n\nI'll write down the question first.\n\n\n  \"Suppose you have an undirected graph G=(V,E) and let three of its\n  vertices to be called v1, v2 and v3. Find an algorithm which\n  determines if these three vertices are part of a clique\n  (complete graph) (k>=3)\"\n\n\nNow I suppose to use DFS in order to solve it. As far as I understand DFS will let me know if v1, v2 and v3 are in the same strongly connected component. If I'm correct I should also determine if G is  also a clique(complete graph).\n\nI read in the internet and I found out that asserting if a graph is clique or not is NP and cannot be solved easily. Am I correct? Am I missing anything? Is there any propery I can use to determine immediately if a graph is comeplete ?\n    ", "Answer": "\r\nTo clarify the confusion about the NP-completeness: checking whether a graph is a clique is not NP-complete; just count the edges and see whether there are n(n-1)/2. What is NP-complete is to find a maximum clique (meaning the subgraph that has the biggest number of vertices and is a clique) or a clique of k vertices in a graph of n vertices (if k is part of the input instead of a fixed number); the latter case is called the clique decision problem.\n\nEDIT: I just realized you asked something regarding strongly connected components as well; that term only applies to directed graphs (i.e. the edges have a direction, which means for two vertices ```\nv```\n and ```\nw```\n, the edge ```\nv->w```\n is not the same as the edge ```\nw->v```\n). Cliques are commonly defined on undirected graphs, for which there are only connected components.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Finding out paths in a graph of 175K nodes\r\n                \r\nI am facing a problem in big data analysis, where I am finding out paths using Dijkstras algorithm for a graph with more than 175K nodes. But the problem is that I do not know for a particular source and destination if a path exists or not. I have to do this for about 1000 sources and destinations. But I cannot pick them randomly, as I am not sure if a path exists between them or not. I am not sure how to handle this. One execution of algorithm in MapReduce enviorment take about 15 mins time locally. So, trial and error is not an option. Only we I can find about at least 1000 sources and destinations is to find cycles(?) or strongly connected components? Is this correct ? I hope my problem is clear to understand.\n\nI am basically looking for finding say 1000 pairs of sources and destinations for which a path exists in a graph of that size \n    ", "Answer": "\r\nI would suggest randomly picking 1000 source nodes, and then for each node run Breadth-First-Search until you've visited ```\nk```\n nodes.  Then, pick the next node that you would visit and set that as the destination for that source.\n\nWith this method, you're guaranteed that each destination is reachable from that source.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Incremental graph algorithms\r\n                \r\nThere are many basic graph algorithms such as topological sort, strongly/weakly connected components, all-pairs/single-source shortest paths, reachability and so on. Incremental variants of these algorithms have a variety of important practical applications. By \"incremental\" I mean those graph algorithms that can compute small changes to their outputs given small changes (e.g. edge insertion and deletion) to the input graph without having to recompute everything. For example, a garbage collector accumulating the subgraph of heap allocated blocks reachable from the global roots. However, I do not recall seeing the subject of incremental graph algorithms discussed outside domain-specific literature (e.g. Richard Jones' new book on GC).\n\nWhere can I find information on incremental graph algorithms or, for that matter, incremental algorithms in general?\n    ", "Answer": "\r\nThere's a survey article by Eppstein, Galil, and Italiano from 1999. They would describe what you're looking for as \"fully dynamic algorithms\"; \"partially dynamic algorithms\" are divided into \"incremental algorithms\", which allow only insertions, and \"decremental algorithms\", which allow only deletions.\n\nBeyond that, I suspect you're going to have to read the research literature – there are only a handful of researchers who work on dynamic graph algorithms. You should be able to find articles by examining the papers that cite the survey.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Non recursive depth first search on graphs for Delphi\r\n                \r\nI am searching for a non-recursive depth first search algorithm on graphs \nin Pascal (Delphi).\n\nI need DFS for computing strongly or bi-connected components of large graphs. \nCurrently I am using a recursive variant of the algorithm: http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n\nThe problem is that for such algorithm I must define a large amount of memory\nto be used for a stack and that makes later problems in Windows 7,\nwhere Open and Save Dialogs do not work because of several threads generated....\n\nSo again: I do not see how to rewrite the Tarjan DFS algorithm\nto work without recursion. Do you have any suggestion - \nor point to a non recursice algorithm for depth first search on graphs?\n\nThanks.\n    ", "Answer": "\r\nThe algorithm as described on Wikipedia looks to reasonably easily be made non-recursive with an explicit stack. Starting out with that (included here for reference, in case Wikipedia changes):\n\n```\nInput: Graph G = (V, E)\n\nindex = 0                                         // DFS node number counter \nS = empty                                         // An empty stack of node\nfor all v in V do\n  if (v.index is undefined)                       // Start a DFS at each node\n    tarjan(v)                                     // we haven't visited yet\n\nprocedure tarjan(v)\n  v.index = index                                 // Set the depth index for v\n  v.lowlink = index                               // SHOULD BE v.lowlink = MAX_INT?\n  index = index + 1\n  S.push(v)                                       // Push v on the stack\n  for all (v, v') in E do                         // Consider successors of v\n    if (v'.index is undefined)                    // Was successor v' visited?\n        tarjan(v')                                // Recurse\n        v.lowlink = min(v.lowlink, v'.lowlink)\n    else if (v' is in S)                          // Was successor v' in stack S? \n        v.lowlink = min(v.lowlink, v'.index )     // v' is in stack but it isn't in the dfs tree\n  if (v.lowlink == v.index)                       // Is v the root of an SCC?\n    print \"SCC:\"\n    repeat\n      v' = S.pop                                  \n      print v'\n    until (v' == v)\n```\n\n\nStep 1: Remove loops containing recursion, adding labels and gotos. This is necessary to make loop variables explicit, savable and restorable (needed during recursion-simulation with stacks). A label needs to be added after ```\ntarjan()```\n's return, as we'll jump to it in a moment.\n\n```\nprocedure tarjan(v)\n  v.index = index                                 // Set the depth index for v\n  v.lowlink = index                               // SHOULD BE v.lowlink = MAX_INT?\n  index = index + 1\n  S.push(v)                                       // Push v on the stack\n  succ = all (v, v') in E      // Consider successors of v\n  succIndex = 0                // presume succ is 0-based\nloop_top:\n  if succIndex >= Length(succ) goto skip_loop\n  v' = succ[succIndex]\n  if (v'.index is undefined)                    // Was successor v' visited?\n      tarjan(v')                                // Recurse\nrecursion_returned:\n      v.lowlink = min(v.lowlink, v'.lowlink)\n  else if (v' is in S)                          // Was successor v' in stack S? \n      v.lowlink = min(v.lowlink, v'.index )     // v' is in stack but it isn't in the dfs tree\n  succIndex = succIndex + 1\n  goto loop_top\nskip_loop:\n  if (v.lowlink == v.index)                       // Is v the root of an SCC?\n    print \"SCC:\"\n    repeat\n      v' = S.pop                                  \n      print v'\n    until (v' == v)\n```\n\n\nStep 2: Introduce a stack which contains all the relevant state for storing our position and computation in the loop at any point where we may be returning from recursion, or starting out at the top of the loop.\n\nThe stack:\n\n```\nT = empty // T will be our stack, storing (v, v', succ, succIndex, state)\n```\n\n\n```\nstate```\n is an enumeration (```\nTopState```\n, ```\nReturnedState```\n) encoding the location in the procedure. Here's the procedure rewritten to use this stack and state rather than recursion:\n\n```\nprocedure tarjan(v)\n  while (T is not empty) do\n    (v, v', succ, succIndex, state) = T.pop\n    case state of\n      TopState: goto top\n      ReturnedState: goto recursion_returned\n    end case\ntop:\n    v.index = index                                 // Set the depth index for v\n    v.lowlink = index                               // SHOULD BE v.lowlink = MAX_INT?\n    index = index + 1\n    S.push(v)                                       // Push v on the stack\n    succ = all (v, v') in E      // Consider successors of v\n    succIndex = 0                // presume succ is 0-based\nloop_top:\n    if succIndex >= Length(succ) goto skip_loop\n    v' = succ[succIndex]\n    if (v'.index is undefined)                    // Was successor v' visited?\n      // instead of recursing, set up state for return and top and iterate\n      T.push(v, v', succ, succIndex, ReturnedState) // this is where we return to\n      T.push(v', empty, empty, empty, TopState) // but this is where we go first\n      continue // continue the while loop at top\nrecursion_returned:\n      v.lowlink = min(v.lowlink, v'.lowlink)\n    else if (v' is in S)                          // Was successor v' in stack S? \n      v.lowlink = min(v.lowlink, v'.index )     // v' is in stack but it isn't in the dfs tree\n    succIndex = succIndex + 1\n    goto loop_top\nskip_loop:\n    if (v.lowlink == v.index)                       // Is v the root of an SCC?\n    print \"SCC:\"\n    repeat\n      v' = S.pop                                  \n      print v'\n    until (v' == v)\n```\n\n\nStep 3: Finally, we need to make sure the entry conditions are correct, for the top-level code which calls tarjan. That can easily be done by an initial push:\n\n```\nprocedure tarjan(v)\n  T.push(v, empty, empty, empty, TopState)\n  while (T is not empty) do\n    (v, v', succ, succIndex, state) = T.pop\n    case state of\n      TopState: goto top\n      ReturnedState: goto recursion_returned\n    end case\ntop:\n    v.index = index                                 // Set the depth index for v\n    v.lowlink = index                               // SHOULD BE v.lowlink = MAX_INT?\n    index = index + 1\n    S.push(v)                                       // Push v on the stack\n    succ = all (v, v') in E      // Consider successors of v\n    succIndex = 0                // presume succ is 0-based\nloop_top:\n    if succIndex >= Length(succ) goto skip_loop\n    v' = succ[succIndex]\n    if (v'.index is undefined)                    // Was successor v' visited?\n      // instead of recursing, set up state for return and top and iterate\n      T.push(v, v', succ, succIndex, ReturnedState) // this is where we return to\n      T.push(v', empty, empty, empty, TopState) // but this is where we go first\n      continue // continue the while loop at top\nrecursion_returned:\n      v.lowlink = min(v.lowlink, v'.lowlink)\n    else if (v' is in S)                          // Was successor v' in stack S? \n      v.lowlink = min(v.lowlink, v'.index )     // v' is in stack but it isn't in the dfs tree\n    succIndex = succIndex + 1\n    goto loop_top\nskip_loop:\n    if (v.lowlink == v.index)                       // Is v the root of an SCC?\n    print \"SCC:\"\n    repeat\n      v' = S.pop                                  \n      print v'\n    until (v' == v)\n```\n\n\nIt could also be done by a jump, jumping immediately to ```\ntop```\n. The code can be further cleaned up, perhaps converted to use a while or repeat loop to eliminate some of the gotos, etc., but the above should be at least functionally equivalent, eliminating the explicit recursion.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Equivalence relation in DFS\r\n                \r\nI am reading about strong connected components in below link.\n\nhttps://www.ics.uci.edu/~eppstein/161/960220.html\n\nHere author mentioned\n\nRecall that a relation is another word for a collection of pairs of objects (if you like, you can think of a relation as being a directed graph, but not the same one we're using to define connectivity). An equivalence relation a # b is a relation that satisfies three simple properties:\n\n\nReflexive property: For all a, a # a. Any vertex is strongly connected to itself, by definition.\nSymmetric property: If a # b, then b # a. For strong connectivity, this follows from the symmetry of the definition. The same two paths (one from a to b and another from b to a) that show that a ~ b, looked at in the other order (one from b to a and another from a to b) show that b ~ a. \nTransitive property: If a # b and b # c, then a # c. Let's expand this out for strong connectivity: if a ~ b and b ~ c, we have four paths: a-b, b-a, b-c, and c-b. Concatenating them in pairs a-b-c and c-b-a produces two paths connecting a-c and c-a, so a ~ c, showing that the transitive property holds for strong connectivity. \n\n\nSince all three properties are true of strong connectivity, strong connectivity is an equivalence relation. \n\nNote that it was critical for our definition that we allowed the paths a-b and b-a to overlap. If we made a small change such as defining two vertices to be connected if they are part of a directed cycle, we wouldn't be able to concatenate the paths and show that the transitive property holds.\n\nMy question is on last statement: what does author mean by we allowed paths a-b and b-a to overlap?\n\nMoreover, what does author mean by: \"If we made a small change such as defining two vertices to be connected if they are part of a directed cycle, we wouldn't be able to concatenate the paths and show that the transitive property holds\"?\n\nThanks for your time\n    ", "Answer": "\r\nIt is easier to understand this with a picture at hand:\n\n\n  In undirected graphs, two vertices are connected if they have a path connecting them. How should we define connected in a directed graph?\n  We say that a vertex a is strongly connected to b if there exist two paths, one from a to b and another from b to a.\n\n\nAuthor here states that we define strong connectivity in directed graphs if there is directed path connecting vertex a with b and directed path connecting vertex b and a.\n\nUnidirected graphs do not have arrows (direction) and directed ones do, see link bellow for reference: http://courses.cs.washington.edu/courses/cse326/00wi/handouts/lecture21/sld014.htm\n\nNow let us refer to picture from the provided link. Vertices Han and Lea are strongly connected in directed graph because there exists directed path from Han to Lea and from Lea to Han.\n\nNow here is definition of transitivity from the article:\n\n\n  Transitive property: If a # b and b # c, then a # c. Let's expand this out for strong connectivity: if a ~ b and b ~ c, we have four paths: a-b, b-a, b-c, and c-b. Concatenating them in pairs a-b-c and c-b-a produces two paths connecting a-c and c-a, so a ~ c, showing that the transitive property holds for strong connectivity.\n  Since all three properties are true of strong connectivity, strong connectivity is an equivalence relation\n\n\nThis is expansion of symmetric property, please refer again to link for picture. Now if there was directed path between Leia and Luke, Han and Luke would be transitively connected.\n\n\n  Note that it was critical for our definition that we allowed the paths a-b and b-a to overlap. If we made a small change such as defining two vertices to be connected if they are part of a directed cycle, we wouldn't be able to concatenate the paths and show that the transitive property holds.\n\n\nAnd finally, if strong connectivity was defined in directed graph such that vertices a and b are connected if there is only a single directed path from a to b, without requirement there is a connection form b to a, then we could never get back to a from c which is required for transitivity.\n\nIf you look at the picture again, and imagine that Leia and Luke are connected (reverse direction), once you get from Han -> Leia -> Luke, you cannot get back to Han - transitivity does not hold. \n\nTherefore, definition of Strong connectivity requires there is directed path in both direction between vertices, otherwise transitivity would not be possible.\n\n\n  Since all three properties are true of strong connectivity, strong connectivity is an equivalence relation.\n\n\nTransitivity property must be valid for Strong connectivity in directed graphs, otherwise the conclusion above would not be possible.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Kattis problem Dominos, run time error on the final testcase, am i missing something obvious or an edge case?\r\n                \r\nI have spent a lot of time on the problem Dominos from kattis, see here: https://open.kattis.com/problems/dominos.\nI am passing 3 testcases and on the final one I receive a runtime error. I suspect some out of bond errors might occur, but I really can't narrow down to the potential cause of the runtime error. I have pasted my code below and have tried to describe the different steps and the thinking process.\nI am using Kosaraju's algorithm to identify the strongly connected components, through a DFS followed by a DFS on the reversed edges (Starting from the last node finished from the prior DFS).\nAfterwards, I condense the graph to now only contain representatives of the SCCs, in order to obtain a directed acyclic graph. From here I count the indegree 0 of the SCC representatives as this will be the amount of bricks necessary to knock over manually by hand.\nI hope this question is specific enough and some of you might have an idea what could be causing trouble.\n```\nfrom collections import defaultdict\n\ndef dfs(brick): # First traversal of graph primarily to generate the DSForder stack for 2nd traversal\n    visited.add(brick)\n    for neighbour in adj[brick]:\n        if neighbour not in visited:\n            dfs(neighbour)\n    DFSorder.append(brick)\n\ndef dfs2(brick):\n        visited.add(brick)\n        SCCs[SCC_number].append(brick) # Append brick to the Strongly connected component list of bricks\n        idx[brick] = SCCs[SCC_number][0] # Set representative as first element in the SCC\n        for neighbour in adj_rev[brick]:\n            if neighbour not in visited:\n                dfs2(neighbour)\n\nt = int(input()) # testcases\n\nfor _ in range(t):\n\n    # Long list of needed things\n    DFSorder = []\n    SCC_number = 0\n    SCCs = defaultdict(list)\n    IndegreeSCC = defaultdict(int)\n    idx=defaultdict(int)\n    n,m = list(map(int,input().split()))\n    visited = set()\n    adj = defaultdict(set)\n    adj_rev = defaultdict(set)\n    adj_SCC = defaultdict(list)\n    \n    for _ in range(m):\n        brick1,brick2 = list(map(int,input().split()))\n        adj[brick1].add(brick2)\n        adj_rev[brick2].add(brick1) # Reverse adjacency list for second DFS traversal\n\n    for i in range(1,n+1): # First traversal to generate DFS order\n        if i not in visited:\n            dfs(i)\n    \n    visited = set() # Restart visited for 2nd reverse traversal\n\n    for brick in DFSorder[::-1]: # Reverse traversal to determine SCCs\n        if brick not in visited:\n            dfs2(brick)\n            SCC_number += 1\n    \n    for val in set(idx.values()): # Initially set all indegrees of SCC representatives to 0\n        IndegreeSCC[val] = 0\n\n    for key in adj: # Condense graph to SCCs (Only the representatives for each SCC is needed)\n        for neighbour in adj[key]:\n            if neighbour != idx[key] and idx[key] != idx[neighbour]:\n                adj_SCC[idx[key]].append(idx[neighbour])\n                IndegreeSCC[idx[neighbour]] += 1\n    \n    # Bricks that needs to be turned over manually can be found from the indegree 0 Strongly connected components\n    print(sum([1 for val in list(IndegreeSCC.values()) if val == 0]))\n```\n\n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Classifying components by similar tag values\r\n                \r\nBackground\nI'm trying to analyse source code to look for ways of improving modularity. To that end I have constructed a directed graph of identifiers (functions, types etc) with edges indicating a reference relationship. So if function ```\nfoo```\n calls ```\nbar```\n then there will be a corresponding edge in the graph from ```\nfoo```\n to ```\nbar```\n.\nI've identified the strongly connected components (i.e. mutually recursive functions and types) in this graph, which yields a DAG of components.\nI want to try to cluster these components according to the modules that use them. For instance if function ```\nfoo```\n is called from code in ```\nModule_A```\n and ```\nModule_B```\n then its module user list will be those two modules. (Note that this is distinct from any import lists: I'm tracking actual use, not importation).\nMy theory is that in a well-designed module all the components will have similar lists of user modules. But in a badly designed module the user module lists will be very different.\nI'm hoping that it will be possible to cluster components according to user lists, so that components with similar lists can then be refactored into modules with higher cohesion.\nThe Question\nGiven a set of components, each with a set of associated discrete tag values (user modules in this case), is there a good algorithm for identifying clusters of components that share similar sets of tags?\nI've googled clustering algorithms, but all the ones I have seen seem to be about clustering by ordinal or real values (e.g. k-means).\n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Appropriate data structure for storing data read from a large text file\r\n                \r\nI need to read data from a very large (~a million entries) text file and am trying to decide which data structure is most appropriate. Each entry in the file contains two integers that represent an edge in a directed graph (the tail and the head vertices), and the vast majority of vertices have at least one outgoing edge. My \"naive\" solution is to use a vector of vectors, so if the tail vertex was 1 and the head vertex was 2 I'd just do something like ```\ngraph[1].push_back(2)```\n to read in the entry \"1 2\".  Once the graph is read in I'll be using Kosaraju's algorithm to compute the strongly-connected components, so I figure it will be handy to be able to access each element via the [] operator in constant time.\n\nWhat are the \"typical\" choices in terms of data structures in a situation like this? Also, assuming the vector of vectors idea is a bad one, why is it bad? I guess the fact that they vector will need to re-size itself will slow things down, but the number of edges/vertices isn't known until runtime so I'm not sure of a way around that. \n\nThanks\n    ", "Answer": "\r\nDo you know number of vertices?\n\nVector of vectors isn't such bad idea as you think because you can resize the outer vector before reading edges. So copying of the whole graph would be prevented.\n\nAs far as I know vector of vectors is good structure for graph. It is often used on olympiads on computer science.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "How to know the maximum recursion depth one can set for a platform in Python 3?\r\n                \r\nI am implementing Depth-First Search algorithm to get strongly connected components of a graph having a very large number of nodes (upwards of 800,000).\n\nWhen running, I get the following error:\n\n```\nRecursionError: maximum recursion depth exceeded in comparison\n```\n\n\nTo solve this, I used help of the ```\nsys.setrecursionlimit(numNodes)```\n function.\nWhen doing this, the IDLE begins to execute the code, but then restarts automatically without giving any output. \n\nBased on a quick web search (for example), I think its because IDLE exceeded the memory limit when recursing through so many nodes.\n\nFor numNodes = 20000, ```\nsys.setrecursionlimit(3000)```\n does the trick\n\nFor numNodes = 40000, ```\nsys.setrecursionlimit(5000)```\n does the trick\n\nFor numNodes = 80000, ```\nsys.setrecursionlimit(5000)```\n restarts the IDLE. (NOTE here, it doesn't show RecursionError, but restarts the IDLE only)\n\nDOUBT : What is the maximum value of the ```\nlimit```\n for ```\nsys.setrecursionlimit(limit)```\n that I can set for my platform?\n\nUPDATE : Other, similar questions on stack overflow ask how to change the value or what is maximum recursion depth.  I need to understand what the maximum possible value of the \"limit\" is. ```\nsys.getrecursionlimit()```\n would give me whatever \"limit\" has been currently set.\n    ", "Answer": "\r\nYou already have found an answer to your problem, but you still don't have an answer as to how to get around the recursion limit.\n\nThe simple approach is to maintain your own stack.  That can be done like this for depth first.\n\n```\ntodo = [starting, stuff]\nwhile 0 < len(todo):\n    task = todo.pop()\n    do work\n    todo.extend(future_tasks)\n```\n\n\nIn this form, switching from DFS to BFS requires switching from a stack to a queue.  Which in Python is easy:\n\n```\ntodo = [starting, stuff]\nwhile 0 < len(todo):\n    task = todo.pop(0)  # CHANGED HERE\n    do work\n    todo.extend(future_tasks)\n```\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "C++ - Implement Merging of graph nodes using Dereference operator overloading\r\n                \r\nI have to work with Discrete graphs. And one particular procedure for me is to find strongly connected components of the graph. After which I have to merge equivalent nodes. That is, if there are the following nodes :- node1,node2,node3, etc. Eventually I need to be able to merge a few of them. For instance if node1 is a leader, node2, node3 should eventually be pointing to node1. So that, if node2 is accessed, instead we should get access to node1. (in any case they are equivalent).\n\nOne rough idea I had was to use a pointer to a node leader in each node. Initially it points to itself,but eventually it may point to a leader. And after that, if the node is accessed, we get access to the leader. (this approach may not lead to what I require, but I was just thinking of the possibilities). \n\nSo here is a basic node structure in C++ :- I would like to know how I should overload the dereference operator properly to get what I want :- \n\n```\nclass Node{\n\n\n    Node * leader ; \n    int data;\n\npublic:\n    Node(int x):data(x),leader(this){}\n    void display(void){std::cout << data << std::endl;}\n    void setRoot(Node * newLeader){leader = newLeader;}\n    Node& operator* () { return *leader; }\n};\n```\n\n\nBut I think I am doing the overloading wrong, as I do not get what I expect from the output :- \n\n```\nmain(){\n\nNode * ptr1 = new Node(1);\nNode * ptr2 = new Node(2);\n\n\nstd::cout << \"ptr1 data :- \" << std::endl ;\nptr1->display();\n\n\n\nstd::cout << \"ptr2 data :- \" << std::endl ;\nptr2->display();\n\nstd::cout << \"changing leader for ptr1\" << std::endl;\nptr1->setleader(ptr2);\n\nstd::cout << \"ptr1 data :- \" << std::endl ;\nptr1->display();\n\n\n\nstd::cout << \"ptr2 data :- \" << std::endl ;\nptr2->display();\n\n\n}\n```\n\n\nOutput :- \n\n```\nptr1 data :- \n1\nptr2 data :- \n2\nchanging Leader for ptr1\nptr1 data :- \n1\nptr2 data :- \n2\n```\n\n    ", "Answer": "\r\nI was doing it wrong here. The dereference operator could not be overloaded for a raw pointer. It could be overloaded for a newly defined class. Thus, in such situations it's better to use a wrapper for a pointer to the class instead of a raw pointer.\n\nHere's the modified code which works and does what I wanted to do in the above question :- \n\n```\nclass Node{\n\n\nNode * leader ; \nint data;\n\npublic:\n    Node(int x):data(x),leader(this){}\n    void display(void){std::cout << data << std::endl;}\n    void setleader(Node * newleader){leader = newleader;}\n    Node * getleader(void){return leader;}\n};\n\nclass NodePtr{\n\nNode * ptr;\n\npublic:\n    NodePtr(Node * node):ptr(node){}\n    Node* operator->() {\n        return ptr->getleader();\n    }\n\n};\n\n\n\nmain(){\n\nNodePtr ptr1( new Node(1));\nNodePtr ptr2( new Node(2));\n\nstd::cout << \"ptr1 data :- \" << std::endl ;\nptr1->display();\nstd::cout << \"ptr2 data :- \" << std::endl ;\nptr2->display();\n\nstd::cout << \"changing leader for ptr1\" << std::endl;\nptr1->setleader(ptr2->getleader());\n\nstd::cout << \"ptr1 data :- \" << std::endl ;\nptr1->display();    \nstd::cout << \"ptr2 data :- \" << std::endl ;\nptr2->display();\n\n\n}\n```\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Print edges that connect a SCC to another SCC\r\n                \r\nI am currently doing a project where i need to find how many strongly connected components (SCC) exist on a graph and, after that, i need to check if there are any edges going from any SCC to another SCC. \n\nI'm using Tarjan's algorithm and i can already get all the SCC from a given graph, but i can't compute the next part.\n\nI had two ideas:\n\n\nDelete all edges inside every SCC. The only ones left would be the possible candidates.\nSomehow turn every SCC to a \"vertex\", or a super vertex, and then check if there are any outgoing connections to any other super vertex.\n\n\nThe only constraints i have are:\n\n\nIf there is more than one connection to the same SCC, i only need to display it once;\nWhen i display the connection, i need to display always the smallest vertex id belonging to the SCC, whether it's the outgoing SCC or incoming SCC.\n\n\nA little example:\n\nInput as edge from x to y\n\n1 2; 2 3; 3 1; 2 4; 4 5; 5 4;\n\nHere's an image of the above graph, where 1 = A, 2 = B and so forth...\n\nMy question is: How can i compute this? Every option i seem to come up with, seems like it will be too time and resources consuming.\n\nAppreciate all the help :)\n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Abort Boost Graph DFS on Back Edge\r\n                \r\nI am trying to improve performance for in my Graph algorithm and I am encountering some problems. \n\nMy graph typedef looks like this: ¨\n\n```\ntypedef boost::adjacency_list<boost::multisetS, boost::vecS, boost::directedS, boost::no_property, indexProperty> graph_t;\ntypedef boost::graph_traits<graph_t>::vertex_descriptor vertex_descriptor_t;\ntypedef boost::graph_traits<graph_t>::edge_descriptor edge_descriptor_t;\n```\n\n\nThe graph I am working on is quite big, it has around 5.8 million edges and 100 vertices. \n\nWhat I am doing is the following: \n\n\nDetermine strongly connected components of the graph\nPerform Depth First Search on each component in order to detect cycles in the graph. \n\n\nI look for cycles in the graph by searching for back edges within the graph.\nFor each cycle I detect, I have to perform an operation that changes the graph. (I have to remove the cycle edges from the graph). \nAfter removal of the cycle I restart the DFS to find the next cycle.\n\nMy question now is: \n\nHow can I terminate the DFS on back edge detection?\n\nI did some research and found the following question:\nfollowing question on stackoverflow\n\nThere it is proposed to use Boosts depth first visit. However, in the \ndocumentation It says that the terminator function is called immediately after the call to discover_vertex. Is it possible to terminate after a call to back_edge? \n\nAlso, is it possible to use depth_first_visit directly, without copying the boost source code as proposed by the aforementioned question?\n\nWhat I am doing until now is storing a flag in the visitor that is set to true as soon as a cycle is detected and checking this flag on every function call in the visitor. This adds a lot of unnecessary function calls to the dfs and takes forever.  \n\nThanks for your help!\n\nTo clarify:\nThe algorithm I am using is described on geeksforgeeks dot org/detect-cycle-in-a-graph (sorry, I can't post more than two links)\n\nWhat I am doing in pseudocode is: \n\n```\n For each strongly connected component in g\n   do\n      perform dfs until first back edge\n      perform some task on the cycle edges\n      remove cycle edges from g\n   until no cycle in DFS\n```\n\n\n@petr: Why do you think a restart of dfs is not needed?\n    ", "Answer": "\r\nThe canonical solution for terminating boost::depth_first_search is to throw an exception (of a type you define yourself). Your code can then catch an exception, do whatever you want, and continue.\n\nThat said, I agree with concerns about restarting DFS on each back edge. If you have a strongly connected component, you can just remove all in edges of its root vertex, and find SCCs in the resulting graph? But anyway, that's a topic for algorithms.stackexchange.com, if you want to abort DFS, exception is the solution.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "MemoryError when using NetworkX simple_cycles() function\r\n                \r\nDocumentation on ```\nsimple_cycles()```\n can be found here: http://networkx.readthedocs.io/en/networkx-1.10/reference/generated/networkx.algorithms.cycles.simple_cycles.html#id7\n\nI have a directed graph with about 160,000 nodes and nearly 2,000,000 edges. Since the complexity of ```\nsimple_cycles()```\n is O((n+e)(c+1)), I thought it would be best to consider the strongly connected components independently. Luckily, are only 238 connected components. The largest component has 4,768 nodes and 31,157 edges. The next largest only has 6 nodes and 6 edges! So now my only problem is the subgraph with 4,768 nodes! However, using ```\nsimple_cycles()```\n on this subgraph still results in a ```\nMemoryError```\n.\n\nI am quite new to python (and programming in general), so I am unsure what's happening and what to try next.\n\nI was first running this on a 32bit version of python, but I got ```\nMemoryError```\n. For the past few days, I've been toying with a 64bit version of python, and it runs longer, but I still get a ```\nMemoryError```\n. I was watching my memory allocation while it was running, and python would use up to 6gb then drop back down to near 0gb, to slowly build up to using 6gb again, and repeat. Several hours later, I get a ```\nMemoryError```\n.  \n\nPerhaps there is a way to save its progress so it doesn't use so much memory. I'm assuming that this is what it is happening when python goes from using 6gb of memory to nearly 0gb - writing it to disk to get more access to memory? But, remember, I am new to this; I don't know what I am talking about. Any tips, recommendations, advice would be appreciated.\n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "DFS on directed graph & Kosaraju's algorithm\r\n                \r\nI'm having trouble to understand Kosaraju's algorithm for finding the strongly connected components of a directed graph. Here's what I have on my notebook (I'm a student :D):\n\n\nStart from an arbitrary vertex (label it with #1) and perform a DFS. When you can't go any further, label the last visited vertex with #2, and start another DFS (skipping vertices already labeled), and so on.\nTranspose the graph.\nDo DFS starting from each vertex in reverse order, those vertices which end visited after each DFS belong to the same SCC.\n\n\nI have this example:\n\n\n\nAnd after the first step starting from E, the labels are:\n\n\nE\nG\nK\nJ\nI\nH\nF\nC\nD\nB\nA\n\n\nSo here comes the thing: Is there a difference for DFS in directed/undirected graphs? \nI did a mental test of the first step on my mind ignoring the  arrows (just like it was undirected) and only got correct #1 for E (of course) and #2 for G, but #3 fell onto J, not K. So I thought maybe I should respect the arrows, and did a DFS considering that, but after the first pass starting from E, I can't go anywhere from G (which is #2), so I'm stuck there.\n\nIs there anything about DFS on directed graphs that I'm not aware of? I've been taught DFS only on undirected graphs!\n    ", "Answer": "\r\nYour second step is incomplete. See Wikipedia:\n\n\n  Kosaraju's algorithm works as follows:\n  \n  \n  Let G be a directed graph and S be an empty stack.\n  While S does not contain all vertices:\n  \n  Choose an arbitrary vertex v not in S. Perform a depth-first search starting at v. Each time that depth-first search finishes expanding a vertex u, push u onto S.\n  \n  Reverse the directions of all arcs to obtain the transpose graph.\n  While S is nonempty:\n  \n  Pop the top vertex v from S. Perform a depth-first search starting at v in the transpose graph. The set of visited vertices will give the strongly connected component containing v; record this and remove all these vertices from the graph G and the stack S. Equivalently, breadth-first search (BFS) can be used instead of depth-first search.\n  \n  \n\n\nSo you shouldn't only do something with the last vertex and first vertices, but with each vertex in the DFS.\n\nAlso note that you should be backtracking - when you can't go further, you go to the previous vertex and continue from there.\n\nAnd no, you can't treat it as an undirected graph - the direction of the edges matter significantly.\n\nSo, starting from ```\nE```\n, you'd, for example, go ```\nF```\n, then ```\nG```\n, then back to ```\nF```\n, then ```\nH```\n, then ```\nK```\n, then ```\nI```\n, then ```\nJ```\n, then back to ```\nI```\n, ```\nK```\n, ```\nH```\n, ```\nF```\n, and finally ```\nE```\n, having pushed all visited vertices onto the stack.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Breaking cycles in a digraph with the condition of preserving connectivity for certain nodes\r\n                \r\nI have a digraph consisting of a strongly connected component (blue) and a set of nodes (orange) that are the inputs to it. The challenge is to break as many cycles as possible with a minimum of removed edges. In addition, there must be a path from each orange node to each blue node.\n\nI solve the problem with a brute force:\n\nRemoving the random edge\nCheck for a path from every orange node to every blue one. If everything is ok, I add an edge to the list and count the number of cycles.\nI return the edge to the graph and go to step 1 until I iterate over all the edges\nNext, from the resulting list (of length n) I generate combinations C (n, k) where k = {2 ... n}\nI perform operations 1, 2, 3 for all combinations of edges\n\nThe core of the code looks like this:\n```\n    for level in range(2, len(edges)):\n        stop = True\n        edges2 = combinations(edges,level)\n        for i, e in enumerate(edges2):\n            g.remove_edges_from(e)\n\n            test = True\n            for node in orange_nodes:\n                d = nx.algorithms.descendants(g, node)\n                test = blue_nodes == d\n                if not test:\n                    break\n            if test:\n                stop = False\n                cycles_count = len(list(nx.simple_cycles(g)))\n                print(f'{i}\\t{level}\\t{cycles_count}\\t{e}')\n\n            g.add_edges_from(e)\n\n        if stop:\n            break\n```\n\nQuestions:\n\nIs it possible to somehow optimize the code (nx.algorithms.descendants() and nx.simple_cycles() are dramatically slow)? Is it possible to rewrite code using Spanning tree or Feedback arc set?\nMaybe there is a fast search algorithm for not the best solution, but a good one?\n\nAdditionally:\nI rewrote the code as it is using the graph-tool, which gave a ~20x...50x speed boost. But this still does not allow us to approach the set practical task =(\n    ", "Answer": "\r\nThe problem as stated is NP-Hard. Not sure if it is in NP either.\nIn order to verify NP-hardness of the problem, consider graphs such that every blue node has an incoming edge from an orange node. For such graphs, what we need is that the graph after removing edges continues to be strongly connected. We also assume that maximum number of cycles need to be removed.\nNow, in order to break as many cycles as possible with a minimum of removed edges, assume that the maximum number of cycles that can be removed for a graph G while continuing to be strongly connected be ```\nremovable(G) = k```\n. This is a well-defined quantity for any graph ```\nG```\n. Thus we need a graph ```\nG'```\n that is a subgraph of ```\nG```\n with number of cycles being ```\ncycles(G)-k```\n. Now maximizing ```\nk```\n is equivalent to minimizing the number of cycles that survive in ```\nG'```\n. This is what makes the problem hard.\nConsider the Hamiltonian Cycle problem that is known to be NP-hard.\nAssume we have a program ```\nbreakCycles(G)```\n that computes a graph ```\nG'```\n as a subgraph of ```\nG```\n with maximum number of cycles removed (with minimal number of edges removed) or ```\ncycles(G') = cycles(G) - k```\n. Then, it is straightforward to see that the Hamiltonian cycle problem can also be solved using ```\nbreakCycles(G)```\n by just providing input graph ```\nG```\n to ```\nbreakCycles```\n to obtain the graph ```\nG'```\n and return true iff ```\nG'```\n is a simple cycle involving all vertices (of ```\nG```\n).\n\nUpdate : In order to obtain a practical solution, let's look at obtaining a graph with minimal cycles, that is a subgraph of the blue nodes such that removing any edge will result in loss of connectivity for those nodes that have an orange node incident to it.\nSolving the above problem is much easier and should work well in practice\n```\ndef getRemovableEdges(G, edgeLst, initNodes):\n    import networkx as nx\n    removableEdgeLst = []\n    for (u,v) in edgeLst:\n        G.remove_edge(u, v)\n        f = nx.floyd_warshall(G)\n        addEdge = True\n        for s in initNodes:\n            if 'inf' in list(map(str, f[s].values())):\n                G.add_edge(u,v)\n                addEdge = False\n                break\n        if addEdge:\n            removableEdgeLst.append((u,v))\n    return removableEdgeLst\n\n```\n\nTo try it on the example provided, we need to first initialize the graph\n```\nDG = nx.DiGraph()\nDG.add_nodes_from(range(1,8))\nDG.add_edges_from([(1,2), (2,3), (3,4), (3,5), (4,5), (5,1), (5,4), (5,7), (6,4), (7,6)]);\n```\n\nWith our graph initialized above, we execute the function as below...\n```\n\nIn [5]: %time eL = getRemovableEdges(DG, list(DG.edges()), [2, 5])                                                                                                                                     \nCPU times: user 791 µs, sys: 141 µs, total: 932 µs\nWall time: 936 µs\n\nIn [6]: DG.remove_edges_from(eL);                                                                                                                                                                      \n\nIn [7]: plt.subplot(121) \n   ...: nx.draw(DG, with_labels=True, font_weight='bold');                                                                                                                                             \n   ...: plt.show();                                                                                                                                                                                    \n```\n\nWe get the graph as below,\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "How to sort the keys of a dictionary in Python? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Python OrderedDict not keeping element order [duplicate]\r\n                            \r\n                                (1 answer)\r\n                            \r\n                    \r\n                    \r\n                        Converting dict to OrderedDict\r\n                            \r\n                                (6 answers)\r\n                            \r\n                    \r\n                Closed 5 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI have a dictionary whose keys are integers, but when iterating over it I would like the integers to appear in a non-sorted order. In a simple example this seems to work with an OrderedDict:\n\n```\nIn [16]: d3 = OrderedDict({k: k+1 for k in [3, 2, 1]})\n\nIn [17]: for k, v in d3.items():\n    ...:     print(k, v)\n    ...:     \n3 4\n2 3\n1 2\n```\n\n\nHowever, in my 'real' application this is not working as expected. I'm trying to identify the strongly connected components (SCCs) of a directed graph. In my ```\nGraph```\n class, I'm in the process of writing the ```\nstrongly_connected_component```\n method:\n\n```\nimport pytest\nimport collections\n\n\nclass Node(object):\n    def __init__(self):\n        self.color = 'white'\n        self.parent = None\n        self.d = None           # Discovery time\n        self.f = None           # Finishing time\n\n\nclass Graph(object):\n    def __init__(self, edges):\n        self.edges = edges\n        self.nodes = self.initialize_nodes()\n        self.adj = self.initialize_adjacency_list()\n\n    def initialize_nodes(self, node_indices=None):\n        if node_indices is None:\n            node_indices = sorted(list(set(node for edge in self.edges for node in edge)))\n        return collections.OrderedDict({node_index: Node() for node_index in node_indices})\n\n    def initialize_adjacency_list(self):\n        A = {node: [] for node in self.nodes}\n        for edge in self.edges:\n            u, v = edge\n            A[u].append(v)\n        return A\n\n    def dfs(self):\n        self.time = 0\n        for u, node in self.nodes.items():\n            if node.color == 'white':\n                self.dfs_visit(u)\n\n    def dfs_visit(self, u):\n        self.time += 1\n        self.nodes[u].d = self.time\n        self.nodes[u].color = 'gray'\n        for v in self.adj[u]:\n            if self.nodes[v].color == 'white':\n                self.nodes[v].parent = u\n                self.dfs_visit(v)\n        self.nodes[u].color = 'black'\n        self.time += 1\n        self.nodes[u].f = self.time\n\n    @staticmethod\n    def transpose(edges):\n        return [(v,u) for (u,v) in edges]\n\n    def strongly_connected_components(self):\n        self.dfs()\n        finishing_times = {u: node.f for u, node in self.nodes.items()}\n        # print(finishing_times)\n        self.__init__(self.transpose(self.edges))\n        node_indices = sorted(finishing_times, key=self.nodes.get, reverse=True)\n        # print(node_indices)\n        self.nodes = self.initialize_nodes(node_indices)\n        # print(self.nodes)\n```\n\n\nIn order to verify that the ```\ndfs```\n method is working, I reproduced the following example from Cormen et al., Introduction to Algorithms:\n\n\n\nwhere I've replaced the node labels u through z with the numbers ```\n1```\n through ```\n6```\n, respectively. The following test,\n\n```\ndef test_dfs():\n    '''This example is taken from Cormen et al., Introduction to Algorithms (3rd ed.), Figure 22.4'''\n    edges = [(1,2), (1,4), (4,2), (5,4), (2,5), (3,5), (3,6), (6,6)]\n    graph = Graph(edges)\n    graph.dfs()\n\n    print(\"\\n\")\n    for index, node in graph.nodes.items():\n        print index, node.__dict__\n```\n\n\nprints\n\n```\n1 {'color': 'black', 'd': 1, 'parent': None, 'f': 8}\n2 {'color': 'black', 'd': 2, 'parent': 1, 'f': 7}\n3 {'color': 'black', 'd': 9, 'parent': None, 'f': 12}\n4 {'color': 'black', 'd': 4, 'parent': 5, 'f': 5}\n5 {'color': 'black', 'd': 3, 'parent': 2, 'f': 6}\n6 {'color': 'black', 'd': 10, 'parent': 3, 'f': 11}\n```\n\n\nwhich is readily seen to correspond with Figure 22.4(p) from the book. In order to compute the SCCs, I have to implement the following pseudocode:\n\n\n\nIn my ```\nstrongly_connected_components```\n method, I order the ```\nnode_indices```\n by finishing time in reverse order. Since it is initialized as an ```\nOrderedDict```\n in the ```\ninitialize_nodes```\n methods, I would expect the following test to pass:\n\n```\ndef test_strongly_connected_components():\n    edges = [(1,2), (1,4), (4,2), (5,4), (2,5), (3,5), (3,6), (6,6)]\n    graph = Graph(edges)\n    graph.strongly_connected_components()\n    assert graph.nodes.keys() == [3, 2, 1, 4, 6, 5]\n\n\nif __name__ == \"__main__\":\n    pytest.main([__file__, \"-s\"])\n```\n\n\nsince ```\n[3, 2, 1, 4, 6, 5]```\n is the reverse order in which the nodes were 'finished' in the depth-first search. However, this test fails:\n\n```\n=================================== FAILURES ===================================\n______________________ test_strongly_connected_components ______________________\n\n    def test_strongly_connected_components():\n        edges = [(1,2), (1,4), (4,2), (5,4), (2,5), (3,5), (3,6), (6,6)]\n        graph = Graph(edges)\n        graph.strongly_connected_components()\n>       assert graph.nodes.keys() == [3, 2, 1, 4, 6, 5]\nE    assert [1, 2, 3, 4, 5, 6] == [3, 2, 1, 4, 6, 5]\nE      At index 0 diff: 1 != 3\nE      Use -v to get the full diff\n\nscc.py:94: AssertionError\n```\n\n\nWhy do the keys not remain in the order specified in the initialization of the ```\nOrderedDict```\n?\n    ", "Answer": "\r\nYou're initializing the OrderedDict with a regular dict, so you lose ordering immediately. Initialize it with an iterable of key-value pairs.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Kosaraju algorithm - computing SCCs\r\n                \r\nFor a given directed graph G I need to compute its strongly connected components (SCCs) using Kosaraju's algorithm. As far as I've understood the steps of the algorithm are as follows:\n\nLet Grev = G wit all arcs reversed\nRun DFS (Depth-First Search) on Grev to compute the finishing times of the nodes\nRun DFS on G to discover SCCs\n\nI have managed to find the correct finishing times of all the nodes. I partially understand that I should assign the finishing times to its respective node values, reverse the graph Grev, and run DFS again on the reversed graph (now G) with the finishing times as the node values processing nodes in decreasing order of finishing times. Is my understanding correct? If so, how can I code it up?\nHere's where I got to so far:\n```\n# Number of elements in graph + 1\ngraph_elem = 10\n\ndef dfs_iterative(graph):\n    # variable initialization\n\n    for i in range(graph_elem - 1, 0, -1):\n        stack.append(i)\n\n        while stack:\n            v = ... # Get top of stack\n\n            # If the top of the stack is not explored, or if any of the children of \n            # the node on the top of the stack are unexplored, then continue the traversal\n            if ...:\n                #Mark explored\n\n                for head in graph[v]:\n                    if head not in explored:\n                        stack.append(head)\n                    # Prevent the loop iterating through all of the children like BFS\n\n            else:\n                # Get finishing time for v\n\n    return finishing_times\n\n# Graph represented in a list through edges\n# index represents the tail node of the edge, and g[index] is the head node\n# Example edges of g: (1, 4), (2, 8), (3, 6), etc.\ng = [[], [4], [8], [6], [7], [2], [9], [1], [5, 6], [7, 3]]\nrev_g = [[], [7], [5], [9], [1], [8], [3, 8], [4, 9], [2], [6]]\nfin_times = dfs_iterative(rev_g)\n```\n\nThe ```\nfin_times```\n should be ```\n{3: 1, 5: 2, 2: 3, 8: 4, 6: 5, 9: 6, 1: 7, 4: 8, 7: 9}```\n, and as previously mentioned it is correct. What do I actually have to do with ```\nfin_times```\n now?\nAlso, the reason I am doing it iteratively and not recursively is the fact that the input file for the assignment is too big and the program would reach recursive limits.\nEdit: Upon answering the question I realized that the question was not in accordance with the course's Honor Code. I edited the question to exclude parts of the code that may give away the solution to the assignment.\n    ", "Answer": "\r\nSince my question was only:\n\nWhat to do with the ```\nfin_times```\n dictionary?\n\nI'll provide the solution only to that question as to not offer the complete solution to the assignment.\nSo the answer seemed to be reversing the ```\nfin_times```\n dictionary so that the keys become the values, and vice-versa:\n```\norder = dict((v, k) for k, v in finishing_times.items())```\n\n```\n{1: 3, 2: 5, 3: 2, 4: 8, 5: 6, 6: 9, 7: 1, 8: 4, 9: 7}```\n\nThen we run DFS on G processing nodes in decreasing order of finishing times (in this case vertex 7 with the finishing time 9). Corresponding to the code in the question, instead of:\n```\nfor i in range(graph_elem - 1, 0, -1):\n        stack.append(i)\n```\n\nWe write:\n```\norder = dict((v, k) for k, v in finishing_times.items())\n\nfor i in range(graph_elem - 1, 0, -1):\n        vertex = order[i]\n        if vertex not in explored:\n            stack.append(vertex)\n            explored.add(vertex)\n\n            // DFS code and SCC size computation...\n```\n\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Knapsack problem with dependent selection\r\n                \r\nJust as classic knapsack problem, we want to maximize the total value while do not let the total weight exceed the capacity, and their values and weights are independent. But, for some items, if you want to select it, you have to select some other items.\n\nFor exmaple: There are item_1, item_2, ..., item_n. If you want to select item_1, you have to select item_3 and item_5, and if you want to select item_3, you have to select item_2, item_7, item_9... etc.\n\nThe dependencies are independent, that is, if we draw the dependency graph, it is just a \"directed graph\".\n\nFirst, I noticed \"precedence constrained knapsack problem\" and \"partially ordered knapsack problem\", but in my problem, the dependency doesn't follow antisymmetric (that is, the dependency graph may contain cycles).\n\nThe closest problem I found is \"set-union knapsack problem\"\n\n\n  Given a set of items, select the subset with largest total value, subject to the constraint that the total weight of the items selected does not exceed a fixed capacity. The total value of a set of items is the sum of the individual values and the total weight is the sum of the individual weights. In the Set-Union Knapsack Problem, the items each have a value, but instead of a weight, each corresponds to a set of elements. Each element has a weight. The total value of a set of items is sum of the individual values, but the total weight is the sum of the weights of the elements in the union of the corresponding sets.\n\n\nBut it only unions the \"weights\", the value of some items may accumulate several times.\n\nIs there any way to efficiently solve this problem?\n\n\n\nEDITED:\n\nI found a way which I can leverage some approximation algorithm\n\nstep 1. Make a directed dependency graph\n\nstep 2. Transfer this graph to component graph (use DFS to find strongly connected component) to remove cycle\n\nstep 3. So now, this become a \"precedence constrained knapsack problem\" or \"partially ordered knapsack problem\". These are strongly NP-complete but there were a lot of papers talk about this, and can find a approximation algorithm to solve.\n    ", "Answer": "\r\nBefore selecting the item you have to check weather item will create cycle or not if it  creates cycle then discard it and move to next item. for that you can use Kruskal's algorithms.  \n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "How to effectively join all intersected vectors?\r\n                \r\nLet's say I have a vector of vectors:\n\n```\nstd::vector<std::vector<int> > vec;\n```\n\n\nNow, in my program, this vector contains groups of nodes that create a cycle in a graph. They create the strongly connected component if they are intersected.\n\nI need to loop over this vector and effectively find those vectors, which are intersected and afterwards, join those. It can be done with sets by brute force set_intersection and set_union, but it would be very slow.\n\nAs an example, if I have vectors A-D of simple int elements, where A,B,D are intersected.\n\n```\nA = [1,2,3,4]\nB = [5,6,7]\nC = [8,9]\nD = [3,4,6,10]\n```\n\n\nand I want this result:\n\n```\ns1 = [1,2,3,4,5,6,7,10]\ns2 = [8,9]\n```\n\n\nNow, I have tried multiple things over last few hours, but simple googling shows that set_intersection would be quite slow approach and I would have to loop over all the sets of nodes multiple times (I think it would be N*(N + 1)/2, so O(N2) without heuristics).\n\nI need to do this effectively, so the thing I have in mind is to loop over all the nodes and note down where I found the original node, then group them together in one search, if possible. \nHowever I am unable to find nor design such an algorithm to be effective enough, so I would appreciate some help or ideas on how to approach this.\n\nThank you.\n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "extract clusters / sets of nodes from an undirected graph\r\n                \r\nDescription\n\nI would like to identify and obtain n-sized clusters in form of groups of nodes from an undirected graph dataset (optimally in Python). Currently I am stuck in a sphere way outside of my comfort and knowledge zone so i thought it may be worth a try reaching out to interested people here.\n\nA cluster here is characterized as a set of nodes being all interconnected through an (non-directional) edge. For simplification reasons all edge weights can be considered with weight = 1. Also there are no further information stored neither within nodes or edges. \n\nBelow figure illustrates data structure and dependencies  \n\nGraph scheme\n\n\n\nFor this I am striving to find a solution that automatically detects the sets of nodes that are entirely interconnected as illustrated below:\n\nExpected Cluster Results\n\n\n\nWhere the cluster size should be recognized dynamically and always consider the maximum number of interconnected nodes (e.g. n1 and n2 are not considered as own cluster as n3 has a connection with both of them). \n\nApproaches\n\nI tried solving this through the concept of strongly connected components but it does not seem to deliver the desired output as the connection between all nodes is not directional.\nI have tried approaching this problem also in matrix form as shown below:\n\nGraph as matrix\n\n\n\nBut I am failing at an elegant solution that does not incorporate a not-scalable approach using nested loops iterating through the indices. \n\nDoes anyone have an idea about how to approach this or optimally even worked on this with a sharable solution I could orientate on? \nThanks a lot!!\n    ", "Answer": "\r\nThe correct naming of your cluster is complete subgraph. Your problem is known as clique problem. One of the best graph processing libraries for Python - networkx - has several algorithms for solving this problem:\nnetworkx cliques\n\nYour problem can be solved by this function: networkx.algorithms.clique.enumerate_all_cliques\n\nYou should convert your graph into networkx format and use these algorithms to find it.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Traverse as many edges as possible between two vertices in a directed graph\r\n                \r\nI'd like to find a set of paths from a start node to and an end node so that those paths collectively contain as many edges of the graph as possible.\nOr more precisely: Given a directed graph which may contain cycles, and two vertices u and v, I would like to find a finite set P of paths from u to v, such that for any path q between u and v that is not in P, and any edge e in q, there is a path p in P that contains e. The vertices u and v may be the same.\nIn fact, an almost identical question has been asked: Directed Graph Traversal - All paths, but the very plausible answer has never been accepted or received an upvote, so I was wondering.\nThat answer involves using a variant of Dijkstra or A* to iterate over all paths between u and v ordered by length.\nFrom Is there a well-studied optimization to find the shortest path traversing every weighted edge through a graph? it seems that my question is also almost identical to the \"Chinese Postman Problem\", except I don't need to visit all the edges, just as many as I can, and I'm not interested in shortest paths, just any paths, and my edges are not weighed.\nI was thinking of doing something like the first answer. Or perhaps condense the graph using Kosaraju, use straight Dijkstra to find all paths between u and v, and expand the \"condensed\" vertices by finding all cycles in the strongly connected components. But I haven't really got anywhere.\nWhat would be the best plan to follow?\n    ", "Answer": "\r\nHere is a case where the set of paths that contain as many edges as possible is smaller than the set of all distinct paths.\n\nSo if you use an algorithm to find all paths, then you will require an extra step to discard paths that do not add more edges.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "How can I check unreachable subgraph exists when I cut the specific edge?\r\n                \r\nWhat I want to solve:\nI want to detect newly created unreachable subgraph(marking nodes that unreachable) in given directed graph if I cut the specific edge.\nThe restriction of this problem:\n\nThe given graph is directed graph (see useful information below.)\nThe number of the nodes are more than 100,000.\nThe number of the edges are around 1.5x of nodes.\nRunning time of the solution should be less than a second.\n\nThe information that might be useful:\n\nThe given graph was made by connecting numerous cycles. And, there are at least 1 route exists from any node to other node.\nA few (~ 10%) of the nodes have the branch. No more than 3 edges on the node exists in the graph.\nThe meaning of \"unreachable area\" is including \"not connected\", but you can ignore this if you think this is mixing two different problems into one.\n\nMy trials\nWhen I met this problem, I tried in 4-ways but no luck above of them.\n\nFind the another path can replace the cut node.\n\nThis method is rejected because of running time of method. Currently we use Dijkstra Algorithm for path-find and when I tried this method by putting into job queue, the job queue was flooded in less than an hour.\n\nCheck level of edges (like packets' Time-To-Live from network.)\n\n```\nSearch from edge node with given threshold level.\nIf I met the branch, keep previous level. Otherwise, decrease level.\nIf level is 0, do nothing.\n```\n\nCurrent temporal solution is this one, but obviously this solution ignores a lot of corner cases.\n\nSimulate flow network to the graph.\n\nIt's simple:\n```\nGive a threshold(like 100) to every nodes and simulate its flow.\nIf I met the branch, split number into each branch.\nCheck the values that is lower than 1.\n```\n\nBut this method is also rejected because of Time complexity.\n\nSCC and Topological sorting.\n\nLastly, I check the Strongly-Connected-Components with Topological orders. (Of course I know I used wrong word, see below)\nThe idea is, topological sorting is used for DAG(Directed Acyclic Graph), but If I add some rules(like \"If I detect cycle, treat that cycle as a virtual node, recursively\", using SCC), I can check the \"topological orders\" for general directed graph. If I found the topological orders, this means that there is an area that unreachable. (It's hard to say, think about it with method 3: simulate flow network)\nI think this approach is the best one, and might be solve the problem, but I have no ideas about keywords that should I search and learn about it. Same as implementation.\nEDIT\nI forgot the explanation of unreachable means. If there is no route from a node(node 'A') to any other node, node 'A' is \"unreachable\". Initially, at given digraph, there are no unreachable node exists.\nIn this problem, let's assume that node 1 is the master node. if there is no route from node 1 to node 2, then node 2 is unreachable.\n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Order of steps in Kosaraju's algorithm [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     This question does not appear to be about programming within the scope defined in the help center.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nThe Wikipedia summary of the Kosaraju-Sharir algorithm is as follows: \n\n\n  Let G be a directed graph and S be an empty stack.\n  \n  \n  While S does not contain all vertices.\n  \n  Choose an arbitrary vertex v not in S. \n  Perform a depth-first search starting at v. Each time that depth-first search finishes expanding a vertex u, push u onto S.\n  \n  Reverse the directions of all arcs to obtain the transpose graph.\n  While S is nonempty:\n  \n  Pop the top vertex v from S. \n  Perform a depth-first search starting at v in the transpose graph. \n  The set of visited vertices will give the strongly connected component containing v; record this and remove all these vertices from the graph G and the stack S. Equivalently, breadth-first search (BFS) can be used instead of depth-first search.\n  \n  \n\n\nBut in my textbook - Sedgewick's Algorithms (fourth edition) - it describes the steps of the algorithm as follows: \n\n\n  \n  Given a digraph G, compute the reverse post-order of its reverse digraph. GR\n  Run a standard DFS on G, but consider the unmarked vertices in the order just computed instead of the standard numerial order\n  The set of all vertices... \n  \n\n\nThe conclusion drawn in the final step is identical, as are the operations performed in those preceding it - but it seems that those operations are given in different orders: Wikipedia tells me to start by doing a DFS on G and then transposing it, doing the second DFS on GR, whereas my textbook suggests that I begin with the transpose, do the first DFS on GR and the second on G. \n\nMy primary question is: Am I understanding this correctly, or am I misinterpreting what one or the other is saying? \n\nSecondly: Intuitively, it seems as though these operations are transitive and therefore that these two \"different methods\" are in fact equivalent, and will always yield the same final result. I've tested this intuition on a couple of digraphs and it seems to hold true - but is it? \n\nThirdly: Assuming it is, is there any objective reason to prefer one over the other, or is it simply a matter of preference?\n    ", "Answer": "\r\nIMO the two algorithms are equivalent but there is a slight difference. The difference is in the order of SCCs (strongly connected components) output from them.\n\nSay we have an acyclic di-graph having SCCs as S1, S2, S3, S4 in that order.\n\n```\nS1 -> S2 -> S3 -> S4\n```\n\n\nAlgorithm 1 (Wikipedia).  \n\nWhen you build the stack S, for any vertex v, all the vertices coming after v shall enter the stack S before v, because we are carrying out DFS on the forward graph.\n\nNow we reverse the graph:\n\n```\nR_S1 <- R_S2 <- R_S3 <- R_S4\n```\n\n\nThe first vertex to be popped from Stack ```\nS```\n shall be in ```\nR_S1```\n. Hence when you perform the DFS, the first SCC to be output shall be ```\nR_S1```\n.\n\nAlgorithm 2 (book).  \n\nHere we first reverse the graph:\n\n```\nR_S1 <- R_S2 <- R_S3 <- R_S4\n```\n\n\nNow when we conduct the DFS on any vertex ```\nv```\n, the vertices coming before ```\nv```\n (in original graph) shall be ordered before v. Also, since we start the order_index from ```\nN```\n and then decrement the order_index, all the vertices coming after ```\nv```\n shall have a lower topological ordering than v.\n\nOriginal graph:\n\n```\nS1 -> S2 -> S3 -> S4\n```\n\n\nThe lowest ordered vertex shall now be in ```\nS4```\n. Hence the first SCC that will be output from the graph shall be ```\nS4```\n as opposed to ```\nR_S1```\n in the first case.\n    ", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
{"Question": "Node with the lowest number of path ending\r\n                \r\nThere is a problem for the Algorithms course.\n\nYou need to create a company. There are n candidates for employees in\nyour company, and you should select as many employees as possible.\nHowever, there are several limitations. First, the structure of the\ncompany must be strictly hierarchical: the company must have a single\ndirector, the director has several (possibly 0) direct subordinates,\neach of them has several (perhaps 0) direct subordinates, etc.\nEmployee A is called the boss of employee B if B is a direct\nsubordinate of A or B is a direct subordinate of A and so on.\nEmployees occasionally play some 1vs1 games. If employee A lost to\nemployee B, A can never be a boss of B. Here transitivity also holds.\nIf A lost to B and B lost to C, A can never be a boss of C and so on.\nAs input, you get n, a number of games, and the result of each game\n(who lost to who). As output, you should obtain the maximum size of\nthe company.\n\nHere's what I got.\nWe can represent the game results as a directed graph with nodes representing employees. There is an edge (A, B) if B lost to A. Now, if for each node we find a number of nodes that cannot reach this node, then the maximum of these values will be the answer to the problem.\nI tried to do it by using DFS on each node, but this takes too long. Thus, there must be some solution with better asymptotic complexity. Can you give me any ideas? I attach my code.\n```\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <stack>\n\n\nclass Graph {\n    uint16_t number_of_vertices_;\n    std::vector<std::vector<uint16_t>> adjacent_;\n    void DFSUtil(uint16_t vertex);\npublic:\n    std::vector<uint16_t> fooled_by_;\n\n    explicit Graph(uint16_t number_of_vertices);\n\n    void AddEdge(uint16_t first_vertex, uint16_t second_vertex) {\n        adjacent_[first_vertex].push_back(second_vertex);\n    }\n\n    void FindTransitiveClosure();\n\n    uint16_t FindMaxSizeOfCompany();\n};\n\n\nGraph::Graph(uint16_t number_of_vertices) {\n    number_of_vertices_ = number_of_vertices;\n\n    std::vector<std::vector<uint16_t>> adjacent(number_of_vertices);\n    adjacent_ = adjacent;\n\n    std::vector<uint16_t> fooled_by(number_of_vertices, number_of_vertices);\n    fooled_by_ = fooled_by;\n}\n\n\nvoid Graph::DFSUtil(uint16_t vertex) {\n\n    std::vector<bool> visited(number_of_vertices_, false);\n    std::stack<uint16_t> stack;\n\n    stack.push(vertex);\n    visited[vertex] = true;\n\n    uint16_t current_vertex;\n    while (!stack.empty()) {\n        current_vertex = stack.top();\n        stack.pop();\n\n\n        for (size_t i =0; i < adjacent_[current_vertex].size(); ++i) {\n            if (!visited[adjacent_[current_vertex][i]]) {\n                visited[adjacent_[current_vertex][i]] = true;\n                --fooled_by_[adjacent_[current_vertex][i]];\n                stack.push(adjacent_[current_vertex][i]);\n            }\n        }\n    }\n}\n\n\nvoid Graph::FindTransitiveClosure() {\n    for (uint16_t i = 0; i < number_of_vertices_; ++i) {\n        DFSUtil(i);\n    }\n}\n\n\nuint16_t Graph::FindMaxSizeOfCompany() {\n    uint16_t max_sum = 0;\n\n    for (uint16_t i = 0; i < number_of_vertices_; ++i) {\n        if (max_sum < fooled_by_[i]) {\n            max_sum = fooled_by_[i];\n        }\n    }\n\n    return max_sum;\n}\n\n\nvoid ReadGraph(uint16_t number_of_edges, Graph &fool) {\n\n    uint16_t first_vertex, second_vertex, won;\n    for (uint16_t counter = 0; counter < number_of_edges; ++counter) {\n        std::cin >> first_vertex >> second_vertex >> won;\n        if (won == 1) {\n            fool.AddEdge(first_vertex - 1, second_vertex - 1);\n        }\n        if (won == 2) {\n            fool.AddEdge(second_vertex - 1, first_vertex - 1);\n        }\n    }\n}\n\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n    uint16_t number_of_vertices, number_of_edges;\n    std::cin >> number_of_vertices >> number_of_edges;\n\n    Graph fool(number_of_vertices);\n    ReadGraph(number_of_edges, fool);\n\n    fool.FindTransitiveClosure();\n\n    std::cout << fool.FindMaxSizeOfCompany();\n\n    return 0;\n}\n\n```\n\nEDIT: I was able to meet the time limit. I used Tarjan’s Algorithm to find strongly connected components. Then only used DFS for one node from each SCC.\n    ", "Answer": "", "Knowledge_point": "Strongly Connected Components in Graphs", "Tag": "算法分析"}
