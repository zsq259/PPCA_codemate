{"Question": "Dijkstra's shortest path algorithm on directed tree with negative weight edges\r\n                \r\nWill Dijkstra's shortest path algorithm return correct results on a directed tree with negative weight edges?\nOn a general graph with negative weights, the algorithm will fail, but since it’s a directed tree it feels like the algorithm will succeed.\n    ", "Answer": "\r\nFrom other answers, you know that there is no good reason to run Dijkstra's algorithm if you know that the graph is a tree.\nIf you do run it, though, it will work even if the tree has negative edge weights.\nThe reason that Dijkstra's algorithm doesn't work for graphs with negative weights, is that negative weights allow a 2nd, shorter, path to be found to a vertex after its distance has already been decided.  In a tree there are no 2nd paths.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "How to Find shortest paths with k negative weighted edges?\r\n                \r\nThe problem is to find shortest paths from a start vertice to all other vertices in a ```\ndirected graph```\n.\nBut the graph will have ```\nm positive```\n weighted edges and ```\nk negative```\n weighted edges, and it's guaranteed that negative weighted edges will be not in a cycle. In other words, there is no negative weighted cycle in this graph.\nI tried to directly use ```\nBellman-Ford```\n and ```\nSPFA```\n to solve this question but does there exists a faster way to do this?\n    ", "Answer": "\r\nIf k is large enough, you should probably just run Bellman–Ford and call it a day.\nIf k is small, you can borrow the re-weighting trick from Johnson’s algorithm, but with a faster initialization than just running Bellman–Ford. Recall that Johnson computes a potential π(v) for each vertex and adjusts the cost of each arc vw from c(vw) to c′(vw) = c(vw) − π(v) + π(w), choosing π so that c′ is nowhere negative. The shortest path between s and t is the same with respect to c as with respect to c′,\nSuppose that the input graph G has exactly one negative arc, let’s say c(xy) < 0. Use Dijkstra’s algorithm to compute distances in G − xy from y to all other vertices. Then define π(v) = distance(y, v). The correctness proof follows the proof of Johnson’s algorithm; the arc xy can’t be part of a shortest path from y because there are no negative cycles, so Dijkstra on G - xy in fact computes a shortest path tree for G.\nFor general k, we can do this recursively. If k = 0, run Dijkstra. Otherwise, remove a negative arc and compute shortest paths recursively instead of with Dijkstra. Once we have good values for π, run Dijkstra one more time, from the given start vertex.\nThe overall running time is O((k + 1) (m + n log n)) with Fibonacci heaps.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Why do all-pair shortest path algorithms work with negative weights?\r\n                \r\nI've been studying all-pair shortest path algorithms recently such as Floyd-Warshall and Johnson's algorithm, and I've noticed that these algorithms produce correct solutions even when a graph contains negative weight edges (but not negative weight cycles). For comparison, Dijkstra's algorithm (which is single-source shortest path) does not work for negative weight edges. What makes the all-pair shortest path algorithms work with negative weights?\n    ", "Answer": "\r\nFloyd Warshall's all pairs shortest paths algorithm works for graphs with negative edge weights because the correctness of the algorithm does not depend on edge's weight being non-negative, while the correctness of Dijkstra's algorithm is based on this fact. \n\nCorrectness of Dijkstra's algorithm:\n\nWe have 2 sets of vertices at any step of the algorithm. Set A consists of the vertices to which we have computed the shortest paths. Set B consists of the remaining vertices.\n\nInductive Hypothesis: At each step we will assume that all previous iterations are correct.\n\nInductive Step: When we add a vertex V to the set A and set the distance to be dist[V], we must prove that this distance is optimal. If this is not optimal then there must be some other path to the vertex V that is of shorter length.\n\nSuppose this some other path goes through some vertex X in the set B. \n\nNow, since ```\ndist[V] <= dist[X]```\n , therefore any other path to V will be atleast dist[V] length, unless the graph has negative edge lengths.\n\nCorrectness of Floyd Warshall's algorithm:\nAny path from vertex S to vertex T, will go through any other vertex U of the graph. Thus the shortest path from S to T can be computed as the \n\n\n  min( shortest_path(S to U) + shortest_path(U to T)) for all vertices U in the graph. \n\n\nAs you can see there is no dependence on the graph's edges to be non-negative as long as the sub calls compute the paths correctly. And the sub calls compute the paths correctly as long as the base cases have been properly initialized.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Is Minimum Spanning Tree afraid of negative weights?\r\n                \r\nThis is a follow-up question of Why most graph algorithms do not adapt so easily to negative numbers?.\n\nI think Shortest Path (SP) has problem with negative weights, because it adds up all weights along the paths and tries to find the minimum one.\n\nBut I don't think Minimum Spanning Tree (MST) has problems with negative weights, because it just takes the single minimum weight edge without caring about the overall total weights.\n\nAm I right?\n    ", "Answer": "\r\nYes, you are right. The concept of MST allows weights of an arbitrary sign. The two most popular algorithms for finding MST (Kruskal's and Prim's) work fine with negative edges.\n\nActually, you can just add a big positive constant to all the edges of your graph, making all the edges positive. The MST (as a subset of edges) will remain the same.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "The k-shortest paths between a pair of vertices with negative edges\r\n                \r\nI'm trying to the find the k-shortest paths between a pair of vertices in a directed graph, with negative weights allowed. As far I know, Eppstein's algorithm and Yen's algorithm only work with positive weights.\n\nI know bellman-ford can be used to find the shorest path with with negative edges but I'm also trying to find the second shortest, third shortest, etc.\n    ", "Answer": "", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Shortest Paths with One negative edge\r\n                \r\n\n  Let G(V,E) be a directed connected graph with no negative cycles in it. All the edges have non-negative weight, except ONE edge. Find a simple shortest path from s,t in V.\n\n\nMy idea - \n\n\nDo a BFS on the graph, find the edge with the negative weight.\nAdd this negative weight to all the edges, so we eliminate the negative weight.\nDo Dijkstra algorithm.\n\n\nMy idea doesn't work.\n\nCan you please help me find out why?\n\nThank you.\n    ", "Answer": "\r\nThe reason that your approach doesn't work is that it unfairly penalizes paths with more edges.\n\nImagine two paths from a source node to a destination, one with more edges, but lower weight, and another with a fewer edges with higher weight. Let's assume that the weight added to each edge is 3.\n\nOriginal paths:\n\n```\nS -> 1 -> 1 -> 1 -> 1 -> 1 -> T    wt = 5\nS -> 4 -> 3 -> T                   wt = 7\n```\n\n\nPaths after adding weight:\n\n```\nS -> 4 -> 4 -> 4 -> 4 -> 4 -> T    wt = 20\nS -> 7 -> 6 -> T                   wt = 13\n```\n\n\nAs you can see, the second path is now incorrectly identified as the shorter one.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Finding shortest paths with python-IGraph on DAGs with negative weights\r\n                \r\nTask: Find a shortest path for a DAG (directed acyclic graph) with negative weights using python interface to the igraph library, as a list of edges/vertices in a single-source/single-target setup.\n\nTried: The closest match I found in the documentation is ```\nget_shortest_paths```\n. However, when tried the function returns:\n```\n\nigraph._igraph.InternalError: Error at structural_properties.c:5220: Weight vector must be non-negative, Invalid value\n```\n\nSeems like internally the function tries to apply the Dijkstra's algorithm and fails. In the same time, according to documentation, other shortest path functions (```\nshortest_paths```\n, ```\nshortest_paths_dijkstra```\n) are able to adapt the algorithm to the graph's properties.\n\nQuestions: \n\n\nIs there an alternative function to use in this case?\nOr how to make ```\nget_shortest_paths```\n chose a correct internal algorithm?\nOr could the algorithm be specified explicitly (as \nin the R interface)\n\n\nRelated question: \n\n\nIs igraph able to detect that the graph is DAG and use the faster shortest path algorithm on topologically sorted graph?\nWould a custom python code for this be necessarily slower than one of general-purpose internal igraph's algorithms (presumably written in C++)? (|E| is in tens of thousands, |V| is in thousands)\n\n\nThanks.\n\nPS. Python 2.7, IGraph 0.6.5\n    ", "Answer": "\r\n```\nget_shortest_paths```\n is not able to handle graphs with negative weights because the underlying C library does not have a corresponding ```\nigraph_get_shortest_paths_bellman_ford```\n function yet. It does have an ```\nigraph_get_shortest_paths_dijkstra```\n, so the Python interface simply checks whether you have weights and if so, redirects the call to ```\nigraph_get_shortest_paths_dijkstra```\n, otherwise it simply calls ```\nigraph_get_shortest_paths```\n (which is the unweighted version in the C layer). In contrast, ```\nshortest_paths```\n works with negative weights because the C library has a function named ```\nigraph_shortest_paths_bellman_ford```\n so it calls the Bellman-Ford implementation when at least one of the edge weights is negative.\n\nUnfortunately the only way out seems to be to implement ```\nigraph_get_shortest_paths_bellman_ford```\n in the C layer and then update the Python interface to handle negative weights appropriately.\n\nAnswers to related questions:\n\n\nigraph does not check whether the graph is a DAG before running any shortest path related function. Yes, shortest paths can be found faster in a DAG but this use-case is so rare that no one bothered to implement the special case so far.\nCustom code written in pure Python is likely to be slower than a C implementation, but it depends on your problem. If you meant the Bellman-Ford algorithm in particular, a pure Python implementation is very likely to be slower, but it may still be usable for the graphs you have. You could try the implementation in NetworkX; as far as I know, NetworkX is pure Python and people still use it for graphs with tens of thousands of nodes and edges.\n\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Which algorithm is helpful in finding shortest path from source to sink in a graph that has all negative edges(cost)?\r\n                \r\nI'm wanting to find the shortest path from source to sink in a directed graph, that has all negative weights(edges). From the algorithms that I'm aware of I don't think of any algorithm that helps solve problem like this. Dijkstras algorithm fails for graphs with negative edge! and also I don't want to traverse through all nodes.\n\nThere are no negative cycles.\n    ", "Answer": "", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Shortest Paths that is strictly increasing\r\n                \r\nI have a directed weighted graph without negative cycles ( but maybe with negative weights) and a starting vertex s. I know that for every vertex v,the weights of the edges along the shortest path from\ns to v are strictly increasing. I need to find an efficient way to compute the shortest path from s to every  vertex.\n\nI'm kind of stuck on this. I'm think I need to relax the edges along the shortest path but not sure how to do that. Hope someone can help\n\nThanks!\n\nRon\n    ", "Answer": "", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Difference between relaxing and setting weight in graph theory\r\n                \r\nCan I say relaxing an edge is same as setting its weight to 0 in graph theory?\n\nI know that setting the negative weights can lead to shortest paths with infinite edges, but is it the same case with setting the weight to 0\n    ", "Answer": "", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Shortest Paths with yellow and black edges\r\n                \r\nGiven directed and weighted graph G=(V,E).\nThere is no negative weighted edge . \nEach edge is colored (black or yellow). \n\nI need to find an algorithm the find the shortest path for a given s ∈ V while every path must be by this rule: color(vi,vi+1)=color(vi+3,vi+4), ∀i :1 ≤ i ≤ k-4 while the path is v1 → ... → vk.\nThe algorithm need to be in O(|V|+|E|log(|V|)).\n    ", "Answer": "\r\nAs a hint: try modifying Dijkstra's algorithm to store two different priority queues: one containing the cost of a path from the start node to the destination node that ends in a yellow edge, and the cost of a path from the start node to the destination node that ends in a black edge.  Then, update the logic to find the next node to choose to factor in the two queues, and change the decrease-key logic to ensure you update the proper queue with the right information.  This can be done with only a constant factor overhead of a normal Dijkstra's algorithm, so it will take time O(|E| + |V| log |V|).\n\nHope this helps!\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Networkx is_negatively_weighted Is False, But Use Dijkstra Return ('Contradictory paths found:', 'negative weights?')\r\n                \r\nI wanted to use a gragh to get a shortest path,but networkx tiped me 'ValueError: ('Contradictory paths found:', 'negative weights?')'.After that,i checked all the gragh edges,they were all bigger the zero.\nIn the end, I uesd the nx.is_negatively_weighted(G, weight='weight'), which return False.however,Dijkstra also return ('Contradictory paths found:', 'negative weights?') when I tried to find shortest path.\nthe following is my code:\n```\ndef Get_Shortest_Car_To_Cus_Path(  # 获得车辆到乘客的最短路径\n        car_names,  # 符合条件的车辆编号们 (就算单个pd.data对象也没事)\n        cus_name,  # 目标乘客\n        car_updata: bool = False,  # 是否更新节点的车辆信息\n        cus_updata: bool = False,  # 是否更新节点的乘客信息\n        weight: str = 'weight',  # 计算最短路径的权重名称，有三类（weight， shape_len， wgs84_length）\n        **kwargs\n):\n    G = kwargs['G']\n    # G = G.copy()  # 创建副本，从副本导出\n    if car_updata:  # 更新节点的车辆信息\n        G = Updata_G_Map_Car(\n            car_names=car_names,\n            **kwargs)\n    # 添加乘客的O点\n    if cus_updata:\n        G = Updata_G_Map_cus(\n            cus_names=[cus_name],\n            **kwargs\n        )\n    print(nx.is_negatively_weighted(G, weight='weight'))\n    if len(car_names) != 1:\n        length, path = nx.multi_source_dijkstra(G=G, sources=set(car_names), target=cus_name + '_出发地',\n                                                weight=weight)\n    else:\n        path = nx.dijkstra_path(G=G, source=str(car_names), target=cus_name + '_出发地', weight=weight)\n        length = path_lenght(G=G, path=path, weight=weight)\n    path = get_pure_path(old_path=path)\n    return length, path\n```\n\nEvery time I try to find shortest path,nx.is_negatively_weighted(G, weight='weight') tell me the gragh is not negative,but the  nx.multi_source_dijkstra() tell me the graph has negative weights.\nWhy that happen?\n    ", "Answer": "\r\ncan't agree any more! Check the weights of edges\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Finding the shortest path in a graph without any negative prefixes\r\n                \r\n\n  Find the shortest path from source to destination in a directed graph with positive and negative edges, such that at no point in the path the sum of edges coming before it is negative. If no such path exists report that too.\n\n\nI tried to use modified Bellman Ford, but could not find the correct solution.\n\n\n\nI would like to clarify a few points :\n\n\nyes there can be negative weight cycles. \nn is the number of edges.  \nAssume that a O(n) length path exists if the problem has a solution.\n+1/-1 edge weights.\n\n    ", "Answer": "\r\nAdmittedly this isn't a constructive answer, however it's too long to post in a comment...\n\nIt seems to me that this problem contains the binary as well as discrete knapsack problems, so its worst-case-running-time is at best pseudo-polynomial. Consider a graph that is connected and weighted as follows:\n\n\n\nThen the equivalent binary knapsack problem is trying to choose weights from the set {a0, ..., an} that maximizes Σ ai where Σ ai < X.\n\nAs a side note, if we introduce weighted loops it's easy to construct the unbounded knapsack problem instead.\n\nTherefore, any practical algorithm you might choose has a running time that depends on what you consider the \"average\" case. Is there a restriction to the problem that I've either not considered or not had at my disposal? You seem rather sure it's an O(n3) problem. (Although what's n in this case?)\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "All pairs shortest paths with dynamic programming\r\n                \r\nAll,\n\nI am reading about the relationship between all pairs shortest path and matrix multiplication.\n\n\n  Consider the multiplication of the weighted adjacency matrix with\n  itself - except, in this case, we replace the multiplication operation\n  in matrix multiplication by addition, and the addition operation by\n  minimization. Notice that the product of weighted adjacency matrix\n  with  itself returns a matrix that contains shortest paths of length 2\n  between any pair of nodes.\n\n\nIt follows from this argument that A to power of n contains all shortest paths.\n\nQuestion number 1:\n\nMy question is that in a graph we will be having at most n-1 edges between two nodes in a path, on what basis is the author discussing of path of length \"n\"?\n\nFollowing slides \n\nwww.infosun.fim.uni-passau.de/br/lehrstuhl/.../Westerheide2.PPT \n\nOn slide 10 it is mentioned as below.\n\n```\ndij(1) = cij\n\ndij(m) = min (dij(m-1), min1≤k≤n {dik(m-1) + ckj}) --> Eq 1\n       = min1≤k≤n {dik(m-1) + ckj} ------------------> Eq 2\n```\n\n\nQuestion 2: how author concluded Eq 2 from Eq 1.\n\nIn Cormen et al book on introduction to algorithms, it is mentioned as below:\n\nWhat are the actual shortest-path weights delta(i, j)? If the graph contains no negative-weight cycles, then all shortest paths are simple and thus contain at most n - 1 edges. A path from vertex i to vertex j with more than n - 1 edges cannot have less weight than a shortest path from i to j. The actual shortest-path weights are therefore given by\n\ndelta(i,j) = d(i,j) power (n-1) = (i,j) power (n) = (i,j) power (n+1) = ...\n\nQuestion 3: in above equation how author came with n, n+1 edges as we have at most n-1, and also how above assignment works?\n\nThanks!\n    ", "Answer": "\r\n\nThe n vs n-1 is just an unfortunate variable name choice. He should have used a different letter instead to be more clear.\n\n```\nA^1 has the shortest paths of length up to 1 (trivially)\nA^2 has the shortest paths of length up to 2\nA^k has the shortest paths of length up to k\n```\n\nEq 2 does not directly come from Eq1. Eq 2 is just the second term from the first equation. I presume this is a formatting or copy-paste error (I can't check - your ppt link is broken)\nThe author is just explicitly pointing out that you have nothing to gain by adding more then n-1 edges to the path:\n\n```\nA^(n-1),            //the shortest paths of length up tp (n-1)\nis equal to A^n     //the shortest paths of length up tp (n)\nis equal to A^(n+1) //the shortest paths of length up tp (n+1)\n...\n```\n\n\nThis is just so that you can safely stop your computations at (n-1) and be sure that you have the minimum paths among all paths of all lengths. (This is kind of obvious but the textbook has a point in being strict here...)\n\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Brute Force Solution to Shortest Path in a directed weighted graph with negative cycle\r\n                \r\nI'm trying to write brute-force algorithm to find the shortest path from s to t. The graph is weighted and also has negative weighted edges. No need to think about negative cycles. Basically exit, if there is so.\n\nI've written Bellman-Ford Algorithm to solve this problem. It works very well. (Incase of \"use better algorithms\" comments) However, as a second step, I need to implement Brute Force Algorithm. I tried to write it over Breadth First Search Alg.,however as i mentioned, there are negative edges. therefore, in some of the cases, i need to revisit some nodes. \nBrute Force Alg. for graphs which have nonnegative edges:\n\n```\nDistance(s, t):\n  for each path p from s to t: \n    compute w(p)\n  return p encountered with smallest w(p)\n```\n\n    ", "Answer": "", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Finding shortest path between two nodes in a weighted DAG with negative weights\r\n                \r\nI have a connected DAG with weighted edges. The weights can be positive or negative. And I have a start node called root and a goal node called goal. I need to find a path from root to goal such that the net weight is as small as possible (if net weight is -ve it's even better) in O(V + E) time. \n\nI came up with the following pseudocode which is almost identical to Dijkstra's except it goes to only the goal node instead of all nodes.\n\n```\nQ = PriorityQueue()\nQ.insert(root, 0)\nwhile (Q is not empty) {\n    node = Q.extractMin()\n    if (node == goal) {\n        return path from node to goal\n    }\n    else {\n        for (x in adjacent[node]) {\n            Q.insert(x, weight[x])\n    }\n}\n```\n\n\nDoes this algorithm work? Also, I'm not very sure if this is necessarily O(V + E). \n\nP.S.: What if the weight upto the current node as I traverse the graph should always be <= k? How can I find the shortest path such that weight of that path throughout the entire path is always <= k in O(V + E) time provided it exists in the graph?\n    ", "Answer": "\r\nThere's a very simple algorithm to solve the recurrence described in David's answer: We can use depth-first search with memoization to ensure that at every time all the subproblems that we need to solve the result for the current node are already known. This implicitly results in the topological order we need: \n\n```\nfor all nodes x: \n    dis[x] = UNKNOWN\ndef dfs(x):\n    if x == goal: return 0\n    if dis[x] != UNKNOWN: return x\n    dis[x] = infinity\n    for all edges (x,y) with weight w:\n        dis[x] = min(dis[x], w + dfs(y))\n    return dis[x]\n```\n\n\nThe result is just ```\ndfs(root)```\n\n\nFor the case where you want to find a shortest path with no prefix ever exceeding weight k, you can use a reverse DFS from the goal:\n\n```\nfor all nodes x: \n    dis[x] = UNKNOWN\ndef rdfs(x):\n    if x == root: return 0\n    if dis[x] != UNKNOWN: return x\n    dis[x] = infinity\n    for all edges (y,x) with weight w:\n        dis[x] = min(dis[x], w + rdfs(y))\n    if dis[x] > k:\n        dis[x] = infinity\n    return dis[x]\n```\n\n\nThe solution is ```\nrdfs(goal)```\n.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Dijkstra’s algorithm - DAG Shortest path with ONLY negative costs\r\n                \r\nI am looking for the shortest path between source (s) and sink (t) in an acyclic directed graph. The graph has topological order (temporal). All the edges have or negative or null cost. \nIs it still possible to use Dijkstra algorithm?\nThe graph looks like this: graph example\n\nUsually Dijkstra does not work with negative weights since the nodes are explored only once (with the assumption that the cost can only increase). \nIn this case, since I have only negative (or null cost), and the cost can only decrease, is ensured that the path is optimal if I explore the graph following the topological order? \n\nThank you\n    ", "Answer": "\r\nYes, it will be optimal - but that's not Dijkstra's algorithm.\n\nDijkstra's algorithm specifies how to explore the nodes - according to their current weight. From the original article:\n\n\n  The shortest branch of set II is removed from this set and added to\n  set I. As a result one node is transferred from set B to set I .\n\n\nWhat you are describing is a different solution, and it works:\n\n```\nD[source] = 0\nD[v] = min {D[u] + w(u,v) | u in V}\n```\n\n\nNow, since you are following topological order, you can prove by induction the above formula is correct - since assuming the induction hypothesis is correct for all ```\nu```\n that is explored before ```\nv```\n, the conclusion that ```\nD[v]```\n is also correct (since it won't be reopened) holds.\n\n\n\nP.S. This proof does not even require the assumption of only negative weights, it works well if the weights are mixed, so the same solution holds.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "What does Bellman-Ford algorithm detects? Negative weight or negative cycle?\r\n                \r\nIf we are given a graph, Now from source we are to calculate the shortest path. Now , If an edge has a negative weight , but there is  edge to back-edge to get back to that edge while reaching the destination I mean if there is no cycle, then we don't have a negative cycle. But the here in Wikipedia the given algorithm which runs from source again thus it detects a negative edge weight but not a negative cycle. My Question is, How to determine a negative cycle?\n    ", "Answer": "\r\nA negative weight cycle is a cycle with weights that sum to a negative number. The Bellman-Ford algorithm propagates correct distance estimates to all nodes in a graph in V-1 steps, unless there is a negative weight cycle. If there is a negative weight cycle, you can go on relaxing its nodes indefinitely. Therefore, the ability to relax an edge after V-1 steps is a test for the presence of a negative weight cycle, as seen in the Wikipedia algorithm. So the Bellman-Ford algorithm tests for negative weight cycles.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Shortest path: identify edges that cause negative cycles\r\n                \r\nI have a directed graph with negative edge weights. The graph is modified by the program and sometimes will form negative cycles. When that happens, shortest path algorithms (Bellman-ford/Johnson/Floyd-Warshall) would detect the existence of such negative cycle and fail, but no other useful information is produced.\n\nI would like to identify what edge causes the negative cycle and disallow such modifications in the graph. Can someone help me with a pointer?\n\nThanks,\n\nPaul\n    ", "Answer": "\r\nPaul, If you're about to add an edge (source, destination, weight), and you know the distance from destination to source, then you're creating a negative cycle if and only if new weight + old distance is negative.\n\nOn the other hand, if you've just got a graph, the bellman-ford algorithm detects negative cycles and can exhibit one when it finds one. You just need to either find an implementation that does that (rather than just failing), or write one yourself. It's not a difficult algorithm and there's lots of pseudocode on the web.\n\n(It's probably a couple of days consultancy work if you want one custom-written for you. I do this sort of thing for a living and would be happy to.)\n\nI'm not sure exactly what you need. I don't know, but I'd imagine that there's an on-line version of Bellman-Ford that keeps its distances up to date cheaply as new edges come in, and will scream if you add a bad one.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "minimum weight connected subset T of edges algorithm\r\n                \r\nConsider the problem of finding a minimum weight connected subset T of edges\nfrom a weighted connected graph G. The weight of T is the sum of all the edge\nweights in T.\n(a) Why is this problem not just the minimum spanning tree problem? Hint: think\nnegative weight edges.\n(b) Give an efficient algorithm to compute the minimum weight connected subset\nT.\n\n(c) from Sciena Manual\n\n(a) spanning tree minimizes summary tree weight, but ```\nminimum weight connected subset```\n - every pair path weight, so we can reuse same negative edges to reduce each pair path?\n\n(b) decision on the forehead: run dijkstra's alg n times, tracking previous pairs shortest paths. Seems not the best one, other idea - sort all edges and going from the largest - try to remove each and check connectivity...\n    ", "Answer": "\r\nFor part A:\n\nConsider K3 (triangle) with each edge having a weight of -1.\n\nWhat is the MST and what is the Minimum-weight connected subset?\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Smallest total weight in weighted directed graph\r\n                \r\nThere is question from one Quiz that I don't fully understand:\n\nSuppose you have a weighted directed graph and want to find a path between nodes A and B with the smallest total weight. Select the most accurate statement:\n\n\nIf some edges have negative weights, depth-first search finds a correct solution.\nIf all edges have weight 2, depth-first search guarantees that the first path found to be is the shortest path.\nIf some edges have negative weights, breadth-first search finds a correct solution.\nIf all edges have weight 2, breadth-first search guarantees that the first path found to be is the shortest path.\n\n\nAm I right that #1 is correct?\n    ", "Answer": "\r\n4 is the correct one!, because all edges have the same weight, so you need to find the node traversing the minimum quantity of edges.\n\n1 Is wrong because depth-first search doesn't consider edge weights, so any node could be reached first\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Minimum spanning tree and shortest path\r\n                \r\nI was given a problem that said:\n\ngiven a connected directed graph with integer weights (both positive and negative),\ndevelop an algorithm that finds the shortest path between two vertices.\n\nI thought I could use a minimum spanning tree algorithm such as kruskal's and then use\nmaybe dijkstra's algorithm to show that since in an MST, every vertex only has one incomming edge, dijkstra's algorithm will work even with negative weights.\n\ndoes this sound copasteic? \n\np.s. I'm having trouble proving that an MST contains the shortest path for a directed graph,\nfor every vertex.\n    ", "Answer": "\r\nFirst, you should note that your graph should not have any negative cycle.\n\nSecond, Normally Dikstra would not work with graphs with negative weights.\n\nThirst, Bellman-Ford Algorithm could be used for finding shortest path in a directed with-negative-weights graph.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Bellman-Ford: all shortest paths\r\n                \r\nI've successfully implemented Bellman-Ford to find the distance of the shortest path when edges have negative weights/distances.  I've not been able to get it to return all shortest paths (when there are ties for shortest).  I managed to get all shortest paths (between a given pair of nodes) with Dijkstra.  Is this possible with Bellman-Ford?  (just want to know if I'm wasting my time trying)\n    ", "Answer": "\r\nIf you alter the second step of the Bellman-Ford algorithm a little bit you can achieve something very similar:\n\n```\nfor i from 1 to size(vertices)-1:\n   for each edge uv in edges: // uv is the edge from u to v\n       u := uv.source\n       v := uv.destination\n       if u.distance + uv.weight < v.distance:\n           v.distance := u.distance + uv.weight\n           v.predecessor[] := u\n       else if u.distance + uv.weight == v.distance:\n           if u not in v.predecessor:\n               v.predecessor += u\n```\n\n\nwhere ```\nv.predecessor```\n is a list of vertices. If the new distance of ```\nv```\n equals a path which isn't included yet include the new predecessor.\n\nIn order to print all shortest paths you could use something like\n\n```\nprocedure printPaths(vertex current, vertex start, list used, string path):\n    if current == start:\n        print start.id + \" -> \" + path\n    else:\n        for each edge ve in current.predecessors:\n            if ve.start not in used:\n                printPaths(ve.start,start, used + ve.start, ve.start.id + \" -> \" + path)\n```\n\n\nUse ```\nprintPaths(stop,start,stop,stop.id)```\n in order to print all paths.\n\nNote: It is possible to exclude ```\nif u not in v.predecessor then v.predecessor += u```\n from the modified algorithm if you remove duplicate elements after the algorithm has finished.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Linear time single-pair-shortest-path algorithm?\r\n                \r\nIs there an algorithm that solves the single-pair-shortest-path problem in linear time for mixed graphs (i.e. directed and undirected edges or undirected edges represented as two directed edges), with negative, real edge-weights and non-negative cycles?\n\nWikipedia only mentions algorithms for the single-source and all-pairs variant of the problem. I know that these solving one of these problems also solves the single-pair problem, but none of them works in linear time and with all the above criterias.\n\nSo is there a linear time algorthm for the single-pair shortest path problem with all the above criterias?\n    ", "Answer": "\r\nNo, there is not. Intuitively, no single-pair shortest-path algorithm which allows negative edge weights can be more asymptotically efficient than a single-source algorithm, since finding the shortest path to the goal may in the worst case involve finding shortest paths to each of some fixed proportion of the other nodes (in order to determine whether it's worth detouring to each one's negative-weight edges).\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Is there a way that gives shortest path using Floyd-Warshall's algorithm where negative weight cycle exists whereas overlapped edges are not allowed?\r\n                \r\nWe know that the result of Floyd-Warshall's algorithm is invalid if a negative weight cycle appears in the graph, that is because to travel multiple times on the negative weight cycle makes the weight sum arbitrarily small. However if we specify that no duplicated edge are allowed to be travelled on then the weight sum is correct by sense. I want to know a way that produces the least weight sum in such condition. Some modifications of the algorithm have been tried (Including to skip the loop when a weight sum from some vertex to itself is minus) but the predecessor matrix was still weird and the weight sum matrix was totally useless (By chance I knew that an exponentially increasing value of it would inevitably occur, see link).\n    ", "Answer": "\r\nAn efficient solution to that problem would imply P=NP, so there almost certainly isn't such a solution.\n\nWith a polynomial-time solution to your problem, you could solve the longest trail problem by setting all edge weights to -1 and asking for the shortest path between two nodes.\n\nAs proven by Marzio De Biasi in the linked post, a solution to the longest trail problem can be used to solve the Hamiltonian cycle problem on grid graphs of max degree 3, by connecting two new nodes to the top-left node and asking for the longest trail.\n\nThe Hamiltonian cycle problem is still NP-complete when restricted to grid graphs of max degree 3, as proven in Christos H Papadimitriou, Umesh V Vazirani, On two geometric problems related to the travelling salesman problem, Journal of Algorithms, Volume 5, Issue 2, June 1984, Pages 231-246, ISSN 0196-6774.\n\nThus, your problem is NP-hard.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Finding shortest path distances in a graph containing at most two negative edges\r\n                \r\nI am given a directed graph where each edge has a cost.Taking advantage of the fact that there are at most two negative edges in the graph, my goal is to find shortest path distances from a given node s to all the nodes in V. The time complexity of the algorithm should be ```\nO(|E| + |V|*log|V|)```\n, so I think I need to apply Dijkstra's algorithm.\n\nI am guessing that I need to translate my given graph somehow to a new graph with non-negative weights that a shortest path from s to v in this graph will be equivalent to the required shortest path in the given graph.. or maybe I need to modify Dijkstra's algorithm?\n\nI am struggling right now. Any help would be appreciated!\n    ", "Answer": "\r\nSince Dijkstra's algorithm is greedy, it won't work with negative weights. You need some other algorithm like the Bellman-Ford Algorithm for this purpose.\n\nBut, if you still want to use Dijkstra's algorithm, there is a known way. In this method, you need to reassign costs, so that all become positive.\n\nFor that you can check out Johnson's Algorithm. Johnson's algorithm consists of the following steps (taken from Wikipedia):\n\n\nFirst, a new node q is added to the graph, connected by zero-weight edges to each of the other nodes.\nSecond, the Bellman–Ford algorithm is used, starting from the new vertex q, to find for each vertex v the minimum weight h(v) of a path from q to v. If this step detects a negative cycle, the algorithm is terminated.\nNext the edges of the original graph are reweighted using the values computed by the Bellman–Ford algorithm: an edge from u to v, having length w(u,v), is given the new length w(u,v) + h(u) − h(v).\nFinally, q is removed, and Dijkstra's algorithm is used to find the shortest paths from each node s to every other vertex in the reweighted graph.\n\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Shortest path from one source which goes through N edges\r\n                \r\nIn my economics research I am currently dealing with a specific shortest path problem:\n\nGiven a directed deterministic dynamic graph with weights on the edges, I need to find the shortest path from one source S, which goes through N edges. The graph can have cycles, the edge weights could be negative, and the path is allowed to go through a vertex or edge more than once.\n\nIs there an efficient algorithm for this problem?\n    ", "Answer": "\r\nOne possibility would be:\n\nFirst find the lowest edge-weight in the graph. \n\nAnd then build a priority queue of all paths from the starting edge (initially an empty path from starting point) where all yet-to-be-handled edges are counted as having the lowest weight. \n\nMain loop:\n\n\nRemove path with lowest weight from the queue.\nIf path has N edges you are done\nOtherwise add all possible one-edge extensions of that path to priority queue\n\n\nHowever, that simple algorithm has a flaw - you might re-visit a vertex multiple times as i:th edge (visiting as 2nd and 4th is ok, but 4th in two different paths is the issue), which is inefficient.\n\nThe algorithm can be improved by skipping them in the 3rd step above, since the priority queue guarantees that the first partial path to the vertex had the lowest weight-sum to that vertex, and the rest of the path does not depend on how you reached the vertex (since edges and vertices can be duplicated).\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Johnson's algorithm - h function\r\n                \r\nJohnson's algorithm uses the Bellman-Ford algorithm as a subroutine for reweighting its input graph to eliminate negative weights on its edges (assuming no negative cycles). In the standard implementation, after adding an extra node connected to all of the others with 0 weight edges, we define the new weight to be: \n\nw'(u,v) = w(u,v) + h(u) - h(v) \n\nThis new weight has to satisfy two requirements: \n\n\nshortest path invariance (the shortest paths are the same in the reweighted graph)\nnon-negative edge weighting (all edges must have non-negative weight)\n\n\nIn its standard implementation, the function h is thus defined as being the shortest path weight (the distance) from the added node to the target node: \n\nh(v) = d(s,v) \n\nSo what I'm wondering is: is there a point in defining h otherwise? One of the aspects I'm thinking about is that running the Bellman-Ford is required for this. This is mainly out of curiosity, so even small details are important to me if there are alternatives to the \"canonical\" definition of h.\n    ", "Answer": "\r\nThere are two angles of attack here.\n\nThe first is changing the definition of w'. The current definition does more than preserve shortest paths; it preserves the differences between the lengths of paths connecting the same endpoints. I don't have any concrete ideas for exploiting the gap here. Unfortunately any reweighting that satisfies the stronger property has an associated h function.\n\nThe second is changing the definition of h. This angle is unpromising since when we rewrite the nonnegative condition, it looks like\n\n```\nh(w) <= h(v) + d(v, w) for all vw in E,\n```\n\n\nwhich is the same constraint as for shortest paths (the shortest paths linear program has the additional constraint that the root is at distance zero, and it seeks to maximize the sum of the distance labels). I won't say you have to do Bellman--Ford, but whatever you use to compute h has to in some sense be a shortest path algorithm that can cope with negative weights.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Shortest Path: Bellman-Ford vs. Johnson\r\n                \r\nI have difficulties in understanding the usefulness of the Johnson Algorithm. I think the question must sound really stupid for someone with knowledge in this area, but I cannot figure it out. According to Wikipedia, the Johnson Algorithm uses the Bellman Ford Algorithm to transform the weights of the edges to non-negative weights and then uses the Dijkstra Algorithm to find the shortest path. But the Bellman Ford Algorithm is also an algorithm to find the shortest path. Why don't we just use the shortest path that we get from the Bellman Ford Algorithm?\n    ", "Answer": "\r\nThe Bellman-Ford algorithm finds the shortest path from a single source to all graph vertices (\"single-source shortest paths\").  Johnson's algorithm finds the shortest path from every vertex to every other vertex (\"all-pairs shortest paths\"), and so it is equivalent to running Bellman-Ford from every possible start vertex in your graph.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Backtrack after running Johnson algorithm\r\n                \r\nI have a question which I was asked in some past exams at my school and I can't find an answer to it.\n\n\n  Is it possible knowing the final matrix after running the Johnson Algorithm on a graph, to know if it previously had negative cycles or not? Why?\n\n\n\n\nJohnson Algorithm\n\nJohnson's Algorithm is a technique that is able to compute shortest paths on graphs. Which is able to handle negative weights on edges, as long as there does not exist a cycle with negative weight.\n\nThe algorithm consists of (from Wikipedia):\n\n\nFirst, a new node ```\nq```\n is added to the graph, connected by zero-weight edges to each of the other nodes.\nSecond, the Bellman–Ford algorithm is used, starting from the new vertex ```\nq```\n, to find for each vertex ```\nv```\n the minimum weight ```\nh(v)```\n of a path from ```\nq```\n to ```\nv```\n. If this step detects a negative cycle, the algorithm is terminated.\nNext the edges of the original graph are reweighted using the values computed by the Bellman–Ford algorithm: an edge from ```\nu```\n to ```\nv```\n, having length ```\nw(u, v)```\n, is given the new length ```\nw(u,v) + h(u) − h(v)```\n.\nFinally, ```\nq```\n is removed, and Dijkstra's algorithm is used to find the shortest paths from each node ```\ns```\n to every other vertex in the reweighted graph.\n\n\n\n    ", "Answer": "\r\nIf I understood your question correctly, which should have been as follows:\n\n\n  Is it possible knowing the final pair-wise distances matrix after running the Johnson Algorithm on a graph, to know if it originally had any negative-weight edges or not? Why?\n\n\nAs others commented here, we must first assume the graph has no negative weight cycles, since otherwise the Johnson algorithm halts and returns False (due to the internal Bellman-Form detection of negative weight cycles).\n\nThe answer then is that if any negative weight edge e = (u, v) exists in the graph, then the shortest weighted distance between u --> v cannot be > 0 (since at the worst case you can travel the negative edge e between those vertices).\n\n\n\nTherefore, at least one of the edges had negative weight in the original graph iff any value in the final pair-wise distances is < 0\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Shortest cycle in a graph with negative weights, repeated edges and vertices allowed\r\n                \r\nWhat algorithm can I use to find the shortest cycle on a graph with the following conditions:\n\n\nThe graph is a complete digraph\nEdge weights are both positive and negative\nPath cost < c, where c < 0\nPath length < n\nThe path can have repeated edges and vertices\n\n\nc and n are inputs to the function.\n\nExample:\n\n```\nWith the following edge weights:\nA -> B = 1\nB -> A = -2\n\nFor c = -1.5, n = 10, 2 solutions are possible:\n\nA -> B -> A -> B -> A\n  +1   -2   +1   -2\n\nB -> A -> B -> A -> B\n  -2   +1   -2   +1\n\nFor c = -100, n = 10, no solution is possible\nFor c = -1.5, n = 3, no solution is possible\n\n\nExample of a figure 8-like path, assuming all other edge weights are infinite:\n\nc = -150, n = 10\nA -> C -> D -> E -> C -> B -> A\n  -99  -99  +1   +1   +1   +1\n```\n\n\nI've looked at FW and BF, but I'm not sure how to adapt either to suit my conditions.\n    ", "Answer": "\r\nFW would work if you don't have negative cycles. Just consider all pairs of nodes look up the distances and find the pair with the smallest sum.\n\nTo satisfy the path length < n you need to keep distances by the number of nodes on the path. You can modify FW to do this by keeping a matrix of distance for each step. \n\nThen to get the solution, in addition to getting all pairs of nodes you also need to iterate on how many steps you take one way and how many you take back. You can do this is O(N^3). Since FW is O(N^3) as well that's your final complexity.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Manipulating edge-costs of a negatively weighted digraph to allow use of Dijkstra's algorithm\r\n                \r\nSuppose we have a digraph containing both positively and negatively weighted edges.\n\nI understand that the shortest-path solution is the Bellman-Ford algorithm.\n\nMy question is: why can we not just add some large value N to all the edge costs so that there are no longer negative edges, then use the far more efficient Dijkstra algorithm? \n    ", "Answer": "\r\nAdding a constant to each edge length is not monotone on path lengths, even for pathes between the same two nodes (as paths may differ in their number of edges). Consider the graph with edges ```\nab```\n, ```\nbc```\n, and ```\nac```\n of weight ```\n-1```\n. Adding ```\nN=2```\n switches the shortest path from ```\na```\n to ```\nc```\n from ```\nab,bc```\n to ```\nac```\n.  \n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Dijkstra vs Bellman- ford A Directed Graph which will give different result\r\n                \r\nI am trying to learn Graphs in which i found that to find shortest path from one node to other node we can use Dijkstra and Bellman-ford algorithm.\n\nIn which Dijkstra will not work for the Graph which contains negative weight edges.\nWhile Brllman-ford can handle such Graph which contains negative weight edges.\n\nMy doubt is i tried many kind of Graphs which contains negative weight edge and applied Dijkstra and Bellman-ford both but in all the cases i found the same result i mean no difference, for negative weight edge also dijkstra is working fine.\nMay be my thought process or the way how i am solving is wrong so only i am getting correct answer for dikstra.\n\nMy question is can any one explain me a Graph which have negative edge and explain the different result for dijkstra and bellman-ford.\n    ", "Answer": "\r\nDjikstra algorithm to find the shortest path between two edges can be used only for graphs that have positive weights. To see the difference of answers that bellman-ford and djikstra gives when there is a negative edge weight, lets take a simple example\n\n```\nwe have 3 nodes in the graph, A B C\nA is connected to B edge weight 4\nA is connected to C edge weight 2\nB is connected to C edge weight -3\n```\n\n\nwhen djikstra is used to calculate shortest path between A and C, we get weight 2\n\nbut when bellman-ford is used to calculate the shortest path between A and C, the weight is 1\n\nThis is happening because of the fact that djikstra finalises the node which has the minimum edge weight, ignoring the fact that there could be path with less weight to that node (note that this could happen only when negative weights are present. with only positive weights this is not possible).\n\nhope you understood the difference\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Can Bellman Ford Algorithm have any arbitary order of edges?\r\n                \r\nI have just started learning new algorithms but I got stuck when I read bellman ford algorithms on geeks for geeks :- http://www.geeksforgeeks.org/dynamic-programming-set-23-bellman-ford-algorithm/\n\nThere It is written that-\n\n\n  the algorithm calculate shortest paths in bottom-up manner. It first\n  calculates the shortest distances for the shortest paths which have\n  at-most one edge in the path. Then, it calculates shortest paths with\n  at-most 2 edges, and so on.\n\n\nAfter the ith iteration of outer loop, the shortest paths with at most i edges are calculated. There can be maximum |V| – 1 edges in any simple path, that is why the outer loop runs |v| – 1 times. The idea is, assuming that there is no negative weight cycle, if we have calculated shortest paths with at most i edges, then an iteration over all edges guarantees to give shortest path with at-most (i+1) edges.\n\nLet us understand the algorithm with following example graph. The images are taken from this source.\n\nLet the given source vertex be 0. Initialize all distances as infinite, except the distance to source itself. Total number of vertices in the graph is 5, so all edges must be processed 4 times.\n\n\n  In the below example if order of edges be- (AB),(BE),(ED),(DC),(AC),(BC),(DB),(BD) then in only one iteration it will calculate shortest paths with even\n  2-3 edges which contradict the claim that \"It first calculates the\n  shortest distances for the shortest paths which have at-most one edge\n  in the path. Then, it calculates shortest paths with at-most 2 edges,\n  and so on.  After the ith iteration of outer loop, the shortest paths\n  with at most i edges are calculated \" So on changing the order of\n  edges this statement will prove to be false.\n\n\nLet us understand the algorithm with following example graph. The images are taken from this source.\n\nLet the given source vertex be 0. Initialize all distances as infinite, except the distance to source itself. Total number of vertices in the graph is 5, so all edges must be processed 4 times.\n\n\n\nLet all edges are processed in following order: (B,E), (D,B), (B,D), (A,B), (A,C), (D,C), (B,C), (E,D). We get following distances when all edges are processed first time. The first row in shows initial distances. The second row shows distances when edges (B,E), (D,B), (B,D) and (A,B) are processed. The third row shows distances when (A,C) is processed. The fourth row shows when (D,C), (B,C) and (E,D) are processed.\n\n\nThe first iteration guarantees to give all shortest paths which are at most 1 edge long. We get following distances when all edges are processed second time (The last row shows final values).\n\n\n\nThe second iteration guarantees to give all shortest paths which are at most 2 edges long. The algorithm processes all edges 2 more times. The distances are minimized after the second iteration, so third and fourth iterations don’t update the distances.\n    ", "Answer": "\r\nYes, bellman ford works no matter in which order the edges are processed. In fact this is the reason why you have to do ```\nn-1```\n iterations. If you would know, what is the best order of edges - only one iteration would be enough.\n\nConsider the following graph (all edges have weight ```\n1```\n):\n\n```\n (1) --> (2) --> (3) --> (4) \n```\n\n\nIf you process the edges in the order ```\n1->2```\n, ```\n2->3```\n, ```\n3->4```\n. You will find the shortest way from ```\n1```\n to ```\n4```\n in only one iteration. For edges sorted in order ```\n3->4```\n, ```\n2->3```\n, ```\n1->2```\n you will have to do all ```\n3```\n iterations.\n\nHowever, ```\nn-1```\n iterations is the worst case, no matter in which order the edges are processed (if there are no negative cycles).\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Enumerating all shortest paths [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Dijkstra's algorithm with negative weights\r\n                            \r\n                                (7 answers)\r\n                            \r\n                    \r\n                Closed 5 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI need to find the count and enumerate ALL the shortest paths from a source node to a destination node. The edges may contain negative weights. I am unable to come up with an algorithm to do this. \n\nCan someone help figure out how to go about this.\n    ", "Answer": "\r\nThere are well known algorithms for finding the shortest path. Most notably Dijkstra's algorithm. Only Dijkstra's algorithm doesn't like negative edges (actually negative cycles). But Bellman-Ford doesn't mind them and it fairly simple to implement.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Bellman Ford Algorithm Explanation\r\n                \r\nI read the Bellman Ford Algorithm. What I couldn't understand is why is there a loop which runs for |V|-1 times (the upper loop in the following segment).\n\n```\nfor ( i = 1; i <= V-1; i++)\n{\n    for (j = 0; j < E; j++)\n    {\n        int u = graph->edge[j].src;\n        int v = graph->edge[j].dest;\n        int weight = graph->edge[j].weight;\n        if (dist[u] != INT_MAX && dist[u] + weight < dist[v])\n        {\n            dist[v] = dist[u] + weight;\n\n        }\n    }\n```\n\n\nI went through several tutorials. All are saying the same thing that  There can be maximum |V| – 1 edges in any simple path, that is why the outer loop runs |v| – 1 times. The idea is, assuming that there is no negative weight cycle, if we have calculated shortest paths with at most i edges, then an iteration over all edges guarantees to give shortest path with at-most (i+1) edges.\n\nSo, when i=1, the distances I calculated after the relaxation method, are those the shortest distances from the source ?\n\nPlease explain this...\n    ", "Answer": "\r\nBellman--Ford has two relevant invariants that hold for all vertices ```\nu```\n.\n\n\nThere exists a path from the source to ```\nu```\n of length ```\ndist[u]```\n (unless ```\ndist[u]```\n is ```\nINT_MAX```\n).\nAfter ```\ni```\n  iterations of the outer loop, for all paths from the source to ```\nu```\n with ```\ni```\n or fewer edges, the length of that path is no less than ```\ndist[u]```\n.\n\n\nAfter ```\nV-1```\n iterations, the second invariant implies that no simple path from the source to ```\nu```\n is shorter than ```\ndist[u]```\n. The first hence implies that the path that we found is shortest.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Sedgewick/Wayne \"BellmanFordSP.java\": how does \"findNegativeCycle\" make sure a negative cycle is returned?\r\n                \r\nIn the Sedgewick and Wayne implementation of the Bellman-Ford algorithm (https://algs4.cs.princeton.edu/44sp/BellmanFordSP.java) the method ```\nfindNegativeCycle```\n uses ```\nEdgeWeightedDirectedCycle```\n (https://algs4.cs.princeton.edu/44sp/EdgeWeightedDirectedCycle.java) to find a directed cycle in the shortest path tree (the edges in the ```\nedgeTo```\n array).\nAlso, in the ```\ncheck```\n method, it is asserted that the weight of this directed cycle is negative. Thus, if Java assertions are enabled, the ```\nBellmanFordSP```\n constructor will throw an exception if the ```\nnegativeCycle```\n method returns a cycle whose weight is not negative.\nQuestion: if the shortest path tree contains both a zero-weight cycle and a negative-weight cycle, what makes sure that ```\nEdgeWeightedDirectedCycle```\n doesn't return the zero-weight cycle (thus causing an assertion failure)?\n    ", "Answer": "\r\nThe linked Bellman-Ford implementation does not guarantee that the negative-weight cycle is returned in the presence of both a negative-weight and zero-weight cycle.\nThe below graph will cause ```\nBellmanFordSP.java```\n to crash (with an ```\nAssertionError```\n) when the start vertex is 2, because the weight of the found cycle equals zero (command ```\njava -ea BellmanFordSP.java <graph.txt> 2```\n):\n```\n8\n9\n0 1 3.0\n1 2 -3.430337482745286\n2 3 0\n3 4 -2\n4 5 -5\n5 0 0\n3 6 -4\n6 7 -5\n7 3 9\n```\n\nHere's the above graph visualized: \nThe error is ultimately caused by a floating-point rounding error.\nWhen vertex 3 is relaxed for the second time, the current distance to this vertex equals ```\n-7.430337482745286```\n. The edge 3→6 (of weight ```\n-4.0```\n) will cause the distance to 6 to be updated to ```\n-7.430337482745286 + -4.0```\n, which (when using\ndouble-precision floating-point numbers) equals ```\n-11.430337482745287```\n (note the ending digit is 7 and not 6).\nWhen 6 is relaxed, the distance to 7 is updated to ```\n-16.430337482745287```\n   (```\n-11.430337482745287 + -5.0```\n) which, finally, causes the relaxation of vertex 7 to update the distance to 3 to ```\n-7.430337482745287```\n (```\n-16.430337482745287 + 9.0```\n). This new distance to 3 is less than the previous distance of ```\n-7.430337482745286```\n (due to the floating-point rounding error), which means the 7→3 edge replaces the 2→3 edge in the shortest path tree. This results in the shortest path tree no longer containing the negative cycle (because it no longer contains 2→3), but the zero-weight cycle instead.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Finding shortest path contaning exactly one negative edge in a graph\r\n                \r\nI am given a directed graph with a weight function and a vertex s.\nMy goal is to find for any other vertex v, the shortest path from s to v that goes through exactly one negative edge. The time complexity of the algorithm should be O(|E| + |V|*log|V|), so guess I need to use Dijkstra's algorithm somehow.\n\nI am guessing that I need to translate my given graph somehow to a new graph with non-negative weights that a shortest path from s to v in this graph will be equivalent to the required shortest path in the given graph.. or maybe I need to modify Dijkstra's algorithm somehow??\n\nI tried to think about it a little, don't have any ideas right now... :(\n    ", "Answer": "", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "All pairs shortest path with varying weights\r\n                \r\nImagine you are given a weighted undirected complete graph with n nodes with non-negative weights Cij, where for i = j Cii = 0, and for i != j Cij > 0. Suppose you have to find the maximal shortest path between any two nodes i and j. Here, you can easily use Floyd-Warshall, or use Dijkstra n times, or whatever, and then just to find the maximum among all n^2 shortest paths.\n\nNow assume that Cij are not constant, but rather can take two values, Aij and Bij, where 0 <= Aij <= Bij. We also have Aii = Bii = 0. Assume you also need to find the maximal shortest path, but with the constraint that m edges must take value Bij, and other Aij. And, if m > n^2, then all edges are equal to Bij. But, when finding shortest path i -> p1 -> ... -> pk -> j, you are intesrested in the worst case, in the sense that on that path you need to choose those edges to take value of Bij, such that path value is maximal if you have fixed nodes on its direction. \n\nFor example, a if you have path of length four i-k-l-j, and, in optimal solution on that path only one weight is changed to Bij, and other take value of Aij. And let m1 = Bik + Akl + Alj, m2 = Aik + Bkl + Alj, m3 = Aik + Akl + Blj, the value of that path is max{m1, m2, m3}. So, among all paths between i and j, you have to choose one such that maximal value (described as in this example) is minimal (which is a variant of definition of shortest path). And you have to do it for all pairs i and j. \n\nYou are not given the constraint how many you need to vary on each path, but rather value of m, a number of weights that should be varied in the complete graph. And the problem is to find the maximum value of the shortest path, as described.\n\nAlso, my question is: is this NP-hard problem, or there exists some polynomial solution?\n    ", "Answer": "", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Given directed weighted graph that has one negeative edge (u,v), find shortest path (s,t)\r\n                \r\nGiven: Directed, weighted graph G(V,E) and ```\ns,t```\n are vertices of ```\nV```\n, all edges are positive except the edge ```\n(u,v)```\n which is negative.\n\nProblem: Find the shortest path (Meaning: with the least weight) from s to t.\n\nMy solution: Well, because we have a negative edge we should use Bellman-Ford's algorithm. Doing ```\nn-1```\n \"relax\" on the edges, and if there's a problem in the ```\nn```\n'th iteration there's a cycle - thus return false. otherwise, return the shortest path from ```\ns```\n to ```\nt```\n.\n\nAnother solution: Using Dijkstra, and changing it a bit by saving d(u) and passing on the negative edge (u,v) and doing \"relax\", then we go again on all the edges without the negative edge, if the distances were changed, we have a cycle, otherwise all good and return the shortest path.\n\nNote: I'm obviously not sure about my solution, the fact that there is one negative edge is tricky, any ideas?\n\nNote2: To make it interesting, you cannot use Bellman-Ford.\n    ", "Answer": "\r\nYou can use the information that there is a single negative edge in order to create an efficient algorithm.\n\nLet's denote as ```\na```\n the source node of the negative edge, and ```\nb```\n the destination node, so we have the negative edge ```\na -> b```\n.\n\nThere are two kinds of paths from node ```\ns```\n to node ```\nt```\n:\n\n\nthe edge ```\na->b```\n is not part of the path;\nthe edge ```\na->b```\n is part of the path.\n\n\nWe intend to find the shortest path from ```\ns```\n to ```\nt```\n, and we will do so by finding the shortest path of each of the above two types.\n\n\n\nThe minimum path along the ones of type (1) can be found by simply applying Dijkstra's algorithm on the modified graph where the negative edge is removed. \n\n\n\nFor type (2), we are now interested in the shortest path from ```\ns```\n to ```\nt```\n that contains the edge ```\na->b```\n. This path has to be of this form: ```\ns -> ... -> a -> b -> ... -> t```\n.\n\nIf we do not have negative cycles in the graph, then the edge ```\na->b```\n should appear only once in the shortest path (please see the final part of this answer for a discussion regarding negative cycles).\n\nIn this situation (no negative cycles), we can apply Dijkstra's algorithm twice, first to find the shortest path from ```\ns```\n to ```\na```\n; and then to find the shortest path from ```\nb```\n to ```\nt```\n. In both cases Dijkstra's algorithm should be applied on the graph modified by removing the negative edge ```\na->b```\n.\n\n\n\nRegarding negative cycles. If there is a negative cycle, i.e. a path that starts and ends in the same node and has negative cost, and that node is on a path from ```\ns```\n to ```\nt```\n, then a shortest path from ```\ns```\n to ```\nt```\n does not exist. Indeed, the cost from ```\ns```\n to ```\nt```\n can be made arbitrarily small in this case, by including the negative cost cycle multiple times. \n\nHowever, it is possible to determine if there is such a cycle in the graph, using again Dijkstra's algorithm. Note that since there is a single negative edge, ```\na->b```\n, the negative cycle needs to contain it. Thus we need to have a path from ```\nb```\n to ```\na```\n whose total cost is smaller than the absolute value of the weight of ```\na->b```\n. We can check whether there is such a path by applying Dijkstra's algorithm, with starting node ```\nb```\n and destination ```\na```\n. Again, Dijkstra's algorithm should be applied on the graph with the ```\na->b```\n edge removed (we are not interested in having it in the path), thus all edge weights are positive.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "the shortest even path to minimum weight perfect matching\r\n                \r\nGiven an edge weighted undirected graph and two vertices s and t, weights are non-negative.\nShortest Even Path Problem is to find an s,t-path P having an even number of edges whose total weight is as small as possible. How to reduce Shortest Even Path Problem to  minimum weight perfect matching problem\n    ", "Answer": "\r\nStart with the given graph, imagine painting the nodes blue, and call it Gblue. It has nodes, including sblue and tblue, and undirected edges like ablue <-> bblue.\n\nMake a copy of the graph, paint its nodes green and call it Ggreen.\n\nNow reconnect all of the edges, so that ablue<->bblue and agreen<->bgreen (which have equal weights) become ablue<->bgreen and agreen<->bblue (which have the same weights).\n\nIn this combined graph, every edge is between a blue node and a green node, so every path alternates between blue and green. So every path from sblue that has a even number of steps, will end on a green node.\n\nNow on this combined graph, seek the minimum-weight path from sblue to tgreen.\n\nFinally, remove the subscripts.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Proof of part of Bellman-Ford Algorithm\r\n                \r\nHow can I prove this in the Bellman-Ford algorithm:\n\nIf there are no negative-weight cycles, then every shortest path from the source ```\ns```\n to the sink ```\nt```\n has at most ```\nn-1```\n edges where ```\nn```\n is the number of vertices in the graph.\n\nAny ideas?\n    ", "Answer": "\r\nThat statement verbatim is trivially false: in a graph where all edges have zero weight, there are no negative-weight cycles, but every path is the shortest.\nWhat we can prove is the following slightly (but importantly) different version:\n\nIf there are no negative-weight cycles, then there exists a shortest path from the source ```\ns```\n to the sink ```\nt```\n which has at most ```\nn - 1```\n edges, where ```\nn```\n is the number of vertices in the graph.\n\n\n\nHere is the proof.\nSuppose there is a shortest path of ```\n>= n```\n edges.\nThen this path has ```\n> n```\n vertices.\nBy pigeonhole principle, some two vertices are the same.\nSo we can remove a part of the path, transforming ```\ns -> (sequence-1) -> v -> (sequence-2) -> v -> (sequence-3) -> t```\n into just ```\ns -> (sequence-1) -> v -> (sequence-3) -> t```\n.\nThe length of the cycle ```\nv -> (sequence-2) -> v```\n was nonnegative, so our new path is not worse than the old one.\nAnd as the old one claimed to be the shortest, it can not be better too.\nTogether, these mean that we removed a cycle with zero weight.\n\nThe important thing is that the number of vertices decreased during our procedure since we removed at least one occurrence of ```\nv```\n.\nNow, repeat the above procedure until the path has less than ```\nn```\n edges.\nIt is still a shortest path.\nSo, we proved that a shortest path with ```\n< n```\n edges exists.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Decide Whether All Shortest Paths From s to t Contain The Edge e\r\n                \r\nLet G = (V;E) be a directed graph whose edges all have non-negative weights. Let s,t be 2 vertices in V, and let e be an edge in E.\nDescribe an algorithm that decides whether all shortest paths from s to t contain the edge e.\n\nWell, this is how you can achieve Dijsktra's time complexity:\nSimply run Dijkstra from s and calculate delta(s,t) (the weight of the shortest path from s to t).\nRemove the edge e, and run Djikstra again from s in the new graph.\nIf delta(s,t) in the new graph has increased, it means that all shortest paths from s to t contain the edge e, otherwise it's not true.\n\nI was wondering whether there is a more efficient algorithm for solving this problem. Do you think that it's possible to beat Dijkstra's time complexity ?\n\nThanks in advance\n    ", "Answer": "\r\nYour approach sounds correct to me. You just calculate the shortest path with and without the possibility of taking edge e. That gives you 2 Dijkstra searches.\n\nThere is room for improvement if you go to A*, bidirectional search or recover your Dijkstra search tree:\n\n\nA* would speed up your Dijkstra-query but it might not be possible for your graph as you need to be able to define a good bound on your remaining distance.\nbidirectional search could be done with both searches meeting around the edge. You can then examine all paths with and without the edge with only 1 fast bidirectional query+ some extra work for both cases instead of having 2 full Dijkstra's that are very similar\nyou could search once without the edge and maintain your search tree. Then you add e and update the shortest path tree starting from the start point of e. If the label of the end point > the label of the start point + length e, the end point can be reached faster when using e. Recursively search the neighbours of your end point and only update the distances if they could be reached faster than before. Should save you some work.\n\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Shortest path with another constraint\r\n                \r\nGiven a weighted undirected graph, I need to find the shortest path between two nodes, a classical shortest path problem actually. But there is one more constraint : Each node contains a \"reduction\" value that can be used to reduce the cost of the following edges for one traversal(not only adjacent, and reduction are not cumulative). So you can reduce the cost of an edge using the \"Reduction\" that was in one of the node you went throught before (the final cost for each edge can't be less than 0).\n\nNote that once we went throught a node with a reduction, we can use it again for all the following edges (not just adjacent, and it is available an unlimited amount of time). Reduction doesn't accumulate.\n\nLet's consider this graph :\n\n\n\nin this graph the shortest path from node 1 to 5 is :\n\n\n1 -> 4 for a cost of 13 (15-2)\n4 -> 3 for a cost of 0 (12-12)\n3 -> 5 for a cost of 0 (10-12) In this case, we reuse the reduction of node 4 because it is bigger than the reduction of node 3 (We went throught the node n°4 then we have an unlimited amount of reduction of cost 12). It is 0 and not -2 because the weight of an edge can't be negative.\n\n\nThen the total cost from node 1 to node 5 is 13 + 0 + 0 = 13\n\nTo solve this problem, I've tried to use the classical Dijkstra/Bellman-Ford but it didn't work, can you help me with this ?\n    ", "Answer": "\r\nIt seems to be this can be solved with a variation of Bellman-Ford.\n\nEvery path up to a given node can be summarised as a pair (C, D) where C is the cost of that path (after discounts) and D is the best discount factor available on that path. Since a discount can be reused an unlimited number of times once that node has been visited, it makes sense to always use the biggest discount seen so far on that path. For example, the path (1 -> 4 -> 3) has cost C = 13 and discount D = 12.\n\nThe complication over the undiscounted problem is that we cannot tell from the cost what the \"best\" path is to nodes in between the source and destination. In your example the path (1 -> 2 -> 3) has lower cost than (1 -> 4 -> 3), but the latter has a better discount which is why the best path from 1 to 5 is (1 -> 4 -> 3 -> 5).\n\nRather than recording the lowest cost path to each node (in Bellman-Ford algorithm), we need to record all \"feasible\" paths from the source to that node found so far. A path can be said to be feasible if there is no other known path that has both a lower cost and a better discount. After the algorithm terminates we can take from all feasible paths from source to destination the one with the smallest cost, ignoring the discount.\n\n(Edit: I originally suggested Djikstra could be used but I think that not be so straightforward. I'm not sure we can choose \"the closest\" unvisited node in any meaningful way such that we are guaranteed to find the minimal path. Someone else might see how to make it work though...)\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Shortest path between two nodes vs shortest path from one node to all other nodes\r\n                \r\nI'm currently studying shortest path problems in graphs with non-negative edge weight.\nI know that Dijkstra algorithm can give me the solution to the single-source shortest path problem ie one can find the shortest path from one node to all other nodes but I haven't found algorithm that can give me the solution to a a priori simpler problem : find the shortest path between two nodes.\nIntuitively, I think that one can find examples that show that the \"simpler\" problem isn't simpler than the single-source shortest path problem but I'm looking for references that show this contradiction (a priori) on simple (ie with a few number of nodes) graphs.\n    ", "Answer": "\r\nSome (but not all) single-source shortest paths algorithms can be easily modified to return the shortest path between two nodes by stopping the algorithm early. A simple example of this is breadth-first search in unweighted graphs. For example, to find the shortest path from a node u to a node v, start a BFS from u. As soon as v is found, the path from u to v discovered that way is the shortest path. Dijkstra’s algorithm can also do this: if you run a Dijkstra’s algorithm starting at node u, you can stop the algorithm as soon as you dequeue v from the priority queue to get the shortest path there.\nThese approaches are usually faster than running the whole algorithm to completion. But if you’re interested specifically in finding a path from one node to another, you might want to look at the A* search algorithm. This is a modification of Dijkstra’s algorithm that’s specifically optimized for the problem of getting from one node to another. It uses a heuristic to guide the search toward the target, deprioritizing searching for other nodes, and thus is much faster than Dijkstra’s algorithm in general.\nAs a note, not all shortest paths algorithms can be cut off early this way. For example, when there are negative edge weights but no negative cycles, Bellman-Ford can still compute shortest paths. However, it may continually revise node distances as it runs, up to the last round of the algorithm. Cutting the search off early can give back the wrong answer.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Dijsktra's Algorithm to accept a single negative edge\r\n                \r\nSo I've been working with Dijkstra's algorithm and directed graphs a lot lately. However, I can't seem to figure this out and it's really starting to bother me.\n\n\n  Show how to modify Dijkstra’s algorithm to solve the single source shortest\n  path problem if there is exactly one negative weight edge but no negative\n  weight cycles.\n\n\nSo far my initial thought has been to somehow split up the graphs and perform the algorithm separately, but that's about all I've thought of.\n\nI've actually found an explanation I'm looking for, but I can't seem to follow his explanation\n\n\n  Well answered! I'd like to point out that if the number of negative edges is limited, there are Dijkstra-based algorithms that might do a better job. For example, if there is only one negative edge from u to v, you could run Dijkstra on s and on v, and then take the minimum for each vertex between ```\nd[s]```\n and ```\nd[s]+w(u, v)+d[v]```\n, giving a complexity of running Dijkstra twice\n\n    ", "Answer": "\r\nRemove the negative edge ```\n(u, v)```\n, run Dijkstra twice: once starting at ```\ns```\n (```\nD1```\n) and once starting at ```\nv```\n (```\nD2```\n)\n\nThe shortest path between ```\ns```\n and ```\nt```\n is: ```\nmin(D1[t], D1[u]+D2[t]+w(u, v))```\n.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Weighted graph problems, TRUE/FALSE + explanation\r\n                \r\nI'm trying to get some true/false questions done. I'm getting worried when I'm answering many of them with true... Please assume that all graphs are undirected and do not have distinct weights. Negative weights should be fine.\n\nQa) If G has a cycle with a unique heaviest edge e, then e cannot be part of any MST.\n\nMy answer is true.\nFor example, we have a graph with nodes A, B, C, D, E.\n\n```\nAB = 1\nBC = 2\nBD = 3\nCD = 100\nDE = 4\n```\n\n\nAs you can see, BCD is a cycle.\nMy argument is that since it is a cycle, we can always avoid the unique heaviest edge CD by taking other routes. Therefore it is true. Is my argument sound (enough)?\n\nQb) The shortest-path tree computed by Dijkstra's algorithm is necessarily an MST.\n\nMy answer is true, but my instinct tells me something's wrong.\nWell... Disjkstra's and Prim's are both greedy algorithms. They both go for the lightest weighted edge every time.\nAre there any cases that a shortest-path tree is NOT a minimum spanning tree?\nI actually have a hard time understanding the difference between these two guys.\n\nQc) Prim's algorithm works with negative weighted edges.\n\nMy answer is true. Because that's what wiki said... :p\nThe algorithm is about finding the lowest-cost edge among all edges. So a negative weighted edge shouldn't matter, is it? But what about negative weighted cycle?\n\nQd) If G has a cycle with a unique lightest edge e, then e must be part of every MST.\n\nMy answer is true.\nWe have to access all nodes in an MST. In a cycle of length 3, for instance, we can always traverse all nodes in that cycle with 2 steps. If there is a unique lightest edge, we'll most certainly choose it in our MST.\n\nAre my claims sound? Perhaps they are insufficient? So are there any suggestions? \n    ", "Answer": "\r\nSuggestion for b): Your instinct says it's wrong, so try to construct a counterexample. If you find one, it's settled, otherwise you can often see why a claim is true by analysing why your construction of a counterexample failed. I'm not telling you whether your answer or your instinct is right, though.\n\nThe homework certainly has been due long ago, so the answers:\n\nQa) If G has a cycle with a unique heaviest edge e, then e cannot be part of any MST.\n\nTrue. Suppose you have a spanning tree ```\nT```\n containing the edge ```\ne```\n. If you remove the edge ```\ne```\n from the tree, you get a graph with two nonempty connected components C1 and C2. At least one of the other edges in the cycle must connect C1 and C2 (otherwise it wouldn't be a cycle). Let ```\ng```\n be such an edge. The tree ```\nT'```\n obtained from ```\nT```\n by removing ```\ne```\n and adding ```\ng```\n is a spanning tree with smaller weight than ```\nT```\n. Therefore ```\nT```\n was not an MST.\n\nQb) The shortest-path tree computed by Dijkstra's algorithm is necessarily an MST.\nMy answer is true, but my instinct tells me something's wrong.\n\nThe instinct was right, that's false. Consider\n```\n    6\n  A---B\n3 |   | 1\n  C---D\n    3\n```\n\nwhere the shortest-path tree is computed from vertex ```\nA```\n. The shortest-path tree is\n```\n    6\n  A---B\n3 |\n  C---D\n    3\n```\n\nwith total weight 12, but the unique MST is\n```\n  A   B\n3 |   | 1\n  C---D\n    3\n```\n\nwith weight 7.\n\nQc) Prim's algorithm works with negative weighted edges.\n\nTrue. One way to deduce that from the correctness for positive weights is to add a constant weight ```\nW```\n to all edges, so that all edge weights are positive (e.g. ```\nW = 1 + max { |weight(e)| : e ∈ E }```\n).\nSince a tree with ```\nV```\n vertices always has ```\nV - 1```\n edges, the total weights of any spanning tree differ by ```\n(V - 1)*W```\n between the modified and unmodified weights, so a tree is an MST for the modified weights if and only if it is one for the unmodified edge weights.\nThe ordering of the edges by weight isn't changed by adding a constant to all weights, so Prim's algorithm constructs the same spanning tree for the modified edge weights as for the unmodified weights, in the same sequence.\nBy the correctness for positive weights, the tree constructed by Prim's algorithm with the modified weights is an MST for the modified weights.\n\nQd) If G has a cycle with a unique lightest edge e, then e must be part of every MST.\n\nFalse. Consider\n```\n     1   1\n   A---B---C\n   |  / \\  |\n 1 | /4 5\\ | 1\n   |/  6  \\|\n   D-------E\n```\n\nThe cycle ```\nBDE```\n has a unique lightest edge ```\nBD```\n of weight 4, but the MST contains none of the edges of that cycle.\nIf there is a unique lightest edge ```\ne```\n in the graph ```\nG```\n, that must, however, be part of every MST. That is dual to a): Consider a spanning tree ```\nT```\n of ```\nG```\n that doesn't contain ```\ne```\n. By adding ```\ne```\n to ```\nT```\n, we obtain a graph ```\nT'```\n that must have a cycle (since ```\nT```\n was a spanning tree and ```\ne```\n not in ```\nT```\n). Any cycle in ```\nT'```\n must contain ```\ne```\n, otherwise that would be  a cycle in ```\nT```\n. So pick any cycle ```\nC```\n in ```\nT'```\n (there is exactly one, but that isn't important) and remove any edge other than ```\ne```\n from ```\nC```\n. Let the resulting graph be ```\nT''```\n.\nThe total weight ot ```\nT''```\n is smaller than that of ```\nT```\n, since ```\nT''```\n is obtained from ```\nT```\n by replacing an edge with a lighter one. ```\nT''```\n is connected (since it was obtained from ```\nT'```\n by removing an edge of a cycle), and contains ```\nV```\n vertices and ```\nV - 1```\n edges. Hence it is a spanning tree, and thus ```\nT```\n was not minimal.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Can we use Dijkstra's to find the shortest path even in a graph having negative edge weights?\r\n                \r\nSuppose I have a graph where the minimum edge weight is −100. Can I add 100 as an offset to all the edges and use Dijkstra's algorithm?\n\nPlease help me understand why such a method gives wrong solution.\n    ", "Answer": "\r\nAdding 100 to every edge weight gives the wrong solution because it penalizes paths that have more edges than paths that have fewer edges.\n\nFor example, suppose we have a graph, and the shortest path from point A to point B has 3 edges and a total distance 5. Suppose some other path from point A to point B has 2 edges but a total distance of 10.\n\nIf we add 100 to each edge weight, then the first path has a cost of 305, while the second path has a cost of 210. So the second path becomes shorter than the first path.\n\n\n\nTherefore, we can conclude that adding an offset or bias to each edge weight does not necessarily preserve shortest paths.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Shortest path in a directed weighted graph that uses at most k vertices\r\n                \r\nI am trying to solve a SSSP problem in a connected directed weighted cyclic graph with non-negative weights. The catch here is, this problem asks for the SSSP that uses at most k vertices.\n\nI tried using modified dijkstra's algorithm to solve this problem, keeping a 3-tuple in my priority queue. i.e. (vertex weight, number of vertices in path to this vertex (inclusive), vertex index). My algorithm prevents nodes that are more than k vertices away from being pushed into the priority queue and thus being considered in the shortest path.\n\nSomehow, my algorithm is getting the wrong answer. One reason is, if an initially smaller weighted edge leads to a non-valid path and a initially larger weighted edge leads to a valid path, then my algorithm (being greedy) will report that it cannot find a valid path to the destination.\n\nEdit: Solution code redacted as it is not helpful.\n    ", "Answer": "\r\nI've found it hard to read your code - so maybe you're already doing this: give each vertex a collection of best paths (edit: actually each vertex stores only the previous step of each of the possible paths), storing the least expensive for that number of visited vertices, once a path goes over the maximum vertex count you can discard it, but you can't discard a more expensive (in terms of total edge lengths) path until you know that the cheaper paths will eventually reach the target in an acceptable number of vertices.\nAt the end you may have more than one complete path, and you just choose the least edge-wise expensive regardless of its number of vertices (you'd have already discarded it if there were too many)\n\n(Your code would be easier to read if you create a class/struct for some of the things you're storing as pairs of pairs etc, then you can give the members clearer names than second.first etc. Even if you are OK with the current naming, the extra clarity may help you get some other answers if the above hasn't helped.)\n\nEdit to answer: \"How do I keep the more expensive path until I know that the cheaper path will lead to a solution? \"\n\nYour priority queue is nearly doing this already - its not that each vertex (n) has a complete path stored as I originally implied, currently you just store the best previous vertex (n-1) to use to get to vertex n - and its cost and its vertex count. I'm saying that instead of storing that one best choice for vertex n-1 you store several options, e.g. the best route to A using 3 previous vertices is from vertex B and costs 12, and the best route using 4 is from vertex C and costs 10.\n(In all the above best means best found so far in the search)\n\nYou only need to store the cheapest route for a given number of vertices. You keep a route if (but only if) its better on either the cost or the vertex count.\n\nIn my above example you need to keep both because the cheaper route to this vertex uses more previous vertices so might result in too many vertices before reaching the target - its not clear at that stage which path will be best in the end.\n\nSo you need to change your collection type, and your rule for discarding options.\nYou could for example use a std::map where previous vertices count is the key and total edge cost and previous vertex ID are stored in the value, or an array of total costs where index is the count.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Improving Bellman-Ford to Linear Run Time\r\n                \r\nIn the Johnson algorithm, it uses Bellman-Ford to convert graphs with negative edge weights(no negative cycles) into a graph with the same shortest paths but all the edge weights being non-negative - in O(mn) time. \n\nSuppose we are given a DAG. How could we use an alternative method to convert the DAG into another graph with the same shortest paths, however in linear time as opposed to the previous O(mn) time. \n\nI'm assuming we could modify Bellman-Ford during execution of the Johnson algorithm, however I'm unsure how to make it linear. Essentially, how could we figure out a way to reweight all edges in a graph to be non-negative in linear O(n) time? \n    ", "Answer": "", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "DAG Kth shortest path dynamic programming\r\n                \r\nThis is not for homework. I am working through a practice test (not graded) in preparation for a final in a couple of weeks. I have no idea where to go with this one. \n\nLet G = (V;E) be a DAG (directed-acyclic-graph) of n vertices and m edges. \n\nEach edge (u; v) of E has a weight w(u; v) that is an arbitrary value (positive, zero, or negative). \n\nLet k be an input positive integer. \n\nA path in G is called a k-link path if the path has no more than k edges. Let s and t be two vertices of G. A k-link shortest path from s to t is defined as a k-link path from s to t that has the minimum total sum of edge weights among all possible k-link s-to-t paths in G. \n\nDesign an O(k(m+ n)) time algorithm to compute a k-link shortest path from s to t.\n\nAny help on the algorithm would be greatly appreciated. \n    ", "Answer": "\r\nLet ```\ndp[amount][currentVertex]```\n give us the length of the shortest path in G which starts from s, ends at ```\ncurrentVertex```\n and consists of ```\namount```\n edges.\n\n```\nmake all values of dp unset\ndp[0][s] = 0\n\nfor pathLength in (0, 1, .. k-1)             // (1)\n    for vertex in V\n        if dp[pathLength][vertex] is set     \n            for each u where (vertex, u) is in E    // (2), other vertex of the edge\n                if dp[pathLength+1][u] is unset or greater than dp[pathLength][vertex] + cost(vertex, u)\n                    set dp[pathLength+1][u] = dp[pathLength][vertex] + cost(vertex, u)\n\nbest = dp[k][t]\nfor pathLength in (0, 1, .. k)\n    if dp[pathLength][t] < best\n        best = dp[pathLength][t]\n```\n\n\nThe algorithm above will give you the length of the k-link shortest path from s to t in G. Its time complexity is dominated by the complexity for the loop (1). The loop (1) alone has complecity O(k), while its inner part - (2) simply traverses the graph. If you use an adjacency list, (2) can be implemented in O(n+m). Therefore the overall complexity is O(k*(n+m)).\n\nHowever, this will give you only the length of the path, and not the path itself. You can modify this algorithm by storing the previous vertex for each value of ```\ndp[][]```\n. Thus, whenever you set the value of ```\ndp[pathLength+1][u]```\n with the value of ```\ndp[pathLength][vertex] + cost(vertex, u)```\n for some variables ```\nvertex```\n, ```\nu```\n, ```\npathLength```\n you would know that the previous used vertex was ```\nvertex```\n. Therefore, you would store it like ```\nprev[pathLength+1][u] = vertex```\n.\n\nAfter that, you can get the path you want like. The idea is to go backwards by using the links you had created in ```\nprev```\n: \n\n```\npLen = pathLength such that dp[pathLength][t] is minimal\ncurVertex = t\n\npath = []           // empty array\nwhile pLen >= 0\n    insert curVertex in the beginning of path\n    curVertex = prev[pLen][curVertex]\n    pLen = pLen - 1\n```\n\n\n```\npath```\n is stored the k-link shortest path from s to t in G.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Bellman Ford and One Olympiad Questions?\r\n                \r\nI took an Olympiad Exam three days ago. I ran into a nice question as follows.\nWe know the bellman-ford algorithm checks all edges in each step, and for each edge if,\nd(v)>d(u)+w(u,v)\nthen ```\nd(v)```\n being updated such that ```\nw(u,v)```\n is the weight of edge ```\n(u, v)```\n and ```\nd(u)```\n is the length of best finding path for vertex ```\nu```\n. if in one step we have ```\nno update for vertexes```\n, the algorithms ```\nterminates```\n. Supposing this algorithm for finding all shortest path from vertex ```\ns```\n in graph G with ```\nn```\n vertex after ```\nk < n```\n iterations is finished, which of the following is correct?\n\n\nnumber of edges in all shortest paths from ```\ns```\n is at most ```\nk-1```\n\n\n\n\n\nweight of all shortest paths from ```\ns```\n is at most ```\nk-1```\n\n\n\n\n\nGraph has no negative cycle.\n\n\nWho can discuss on these options ?\n    ", "Answer": "\r\n1 is incorrect. First of all, we always find shortest paths with k edges, if any. But also, if we happen to relax the arcs in the topological order of a shortest path tree, then we converge in one iteration, despite the fact that the shortest path tree may be arbitrarily deep.\n```\ns --> t --> u --> v\n\nRelax s->t, t->u, u->v; shortest path from s->v is three hops,\nbut B--F has made two iterations.\n```\n\n2 is incorrect, because who knows what the weights are?\n```\n  100\ns --> t\n\nRelax s->t; weight is 100, but B--F has made two iterations.\n```\n\n3 is correct, because by an averaging argument at least one arc of a negative cycle would be unrelaxed. Let ```\nv1, ..., vn```\n be a cycle. Since the arcs are relaxed, we have ```\nd(vi) + len(vi->vi+1) - d(vi+1) >= 0```\n. Sum the inequalities for all ```\ni```\n and telescope the ```\nd```\n terms to simplify to ```\nsum_i len(vi->vi+1) >= 0```\n, which says that the cycle is nonnegative.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Fastest implementation for All-pairs shortest paths problem?\r\n                \r\nI have a weighted graph 30k nodes 160k edges, no negative weights.\nI would like to compute all the shortest paths from all the nodes to the others.\nI think I cannot assume any particular heuristics to simplify the problem.\n\nI tried to use this Dijkstra C implementation http://compprog.wordpress.com/2007/12/01/one-source-shortest-path-dijkstras-algorithm/, that is for a single shortest path problem, calling the function dijkstras() for all my 30 nodes. As you can imagine, it takes ages. At the moment I don't have the time to write and debug the code by myself, I have to compute this paths as soon as possible and store them in a database so I am looking for another faster solution ready to use, do you have any tips?\n\nI have to run it on a recent macbook pro with 8GB ram and I would like to find a solution that takes not more than 24 hours to finish the computation.\n\nThanks a lot in advance!!\n\nEugenio\n    ", "Answer": "\r\nI looked over the Dijkstra's algorithm link that you posted in the comments and I believe that it's the source of your inefficiency.  Inside the inner Dijkstra's loop, it's using an extremely unoptimized approach to determine which node to explore next (a linear scan over every node at each step).  The problematic code is in two spots.  The first is this code, which tries to find the next node to operate on:\n\n```\nmini = -1;\nfor (i = 1; i <= n; ++i)\n    if (!visited[i] && ((mini == -1) || (d[i] < d[mini])))\n         mini = i;\n```\n\n\nBecause this code is nested inside of a loop that visits every node, the complexity (as mentioned in the link) is O(|V|2), where |V| is the number of nodes.  In your case, since |V| is 30,000, there will be nine hundred million iterations of this loop overall.  This is painfully slow (as you've seen), but there's no reason to have to do this much work.\n\nAnother trouble spot is here, which tries to find which edge in the graph should be used to reduce the cost of other nodes:\n\n```\nfor (i = 1; i <= n; ++i)\n   if (dist[mini][i])\n       if (d[mini] + dist[mini][i] < d[i])\n           d[i] = d[mini] + dist[mini][i];\n```\n\n\nThis scans over an entire row in the adjacency matrix looking for nodes to consider, which takes time O(n) irrespective of how many outgoing edges leave the node.\n\nWhile you could try fixing up this version of Dijkstra's into a more optimized implementation, I think the correct option here is just to throw this code away and find a better implementation of Dijkstra's algorithm.  For example, if you use the pseudocode from the Wikipedia article implemented with a binary heap, you can get Dijkstra's algorithm running in O(|E| log |V|).  In your case, this value is just over two million, which is about 450 times faster than your current approach.  That's a huge difference, and I'm willing to bet that with a better Dijkstra's implementation you'll end up getting the code completing in a substantially shorter time than before.\n\nOn top of this, you might want to consider running all the Dijkstra searches in parallel, as Jacob Eggers has pointed out.  This cam get you an extra speed boost for each processor that you have.  Combined with the above (and more critical) fix, this should probably give you a huge performance increase.\n\nIf you plan on running this algorithm on a much denser data set (one where the number of edges approaches |V|2 / log |V|), then you may want to consider switching to the Floyd-Warshall algorithm.  Running Dijkstra's algorithm once per node (sometimes called Johnson's algorithm) takes time O(|V||E| log |V|) time, while using Floyd-Warshall takes O(|V|3) time.  However, for the data set you've mentioned, the graph is sufficiently sparse that running multiple Dijkstra's instances should be fine.\n\nHope this helps!\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "How to assign edge weights to certain edges in R igraph\r\n                \r\nI'd like to assign a small, non-negative edge weights to certain edges used in a shortest path. Here is an example graph:\n\n```\nlibrary(igraph)\ndata <- read.table(text=\"\n1 2\n1 4\n1 5\n2 3\n2 4\n3 4\n5 7\n5 8\n3 6\", header=FALSE)\ngmatrix <- data.matrix(data, rownames.force = NA) #convert into a matrix to use in igraph\ng <- graph_from_edgelist(gmatrix, directed = FALSE) \n```\n\n\nIf I find the shortest path between node 1 and node 3, the edges used are 1-2 and 1-3.\n\n```\nget.shortest.paths(g, 1,3)\n$vpath\n$vpath[[1]]\n+ 3/9 vertices, from 634c426:\n[1] 1 2 3\n```\n\n\nWhat I want to do is to assign a small epsilon value to those edges. Then, I'd like to call ```\nget.shortest.paths(g, 1,3)```\n to test whether the function will identify the same path or not.\n    ", "Answer": "\r\nOk, this I can help with:\n\nUse ```\nE()```\n to query the edges with the ids grabbed from ```\nget.shortest.paths```\n and assign the values to a new edge attribute name (e.g., \"weight\" or whatever):\n\n```\np <- get.shortest.paths(g, 1, 3)$vpath[[1]]\n\nE(g, path = p)$weight <- 0.1\n```\n\n\nCheck the result:\n\n```\n> E(g)\n+ 9/9 edges from 605e8c7:\n[1] 1--2 1--4 1--5 2--3 2--4 3--4 5--7 5--8 3--6\n> E(g)$weight\n[1] 0.1  NA  NA 0.1  NA  NA  NA  NA  NA\n```\n\n\nThe path from 1 to 2 and 2 to 3 now has a weighted edge.\n\nNow, assign zero to the other edges and 'get.shortest.paths` identifies another path:\n\n```\n> E(g)$weight <- ifelse(is.na(E(g)$weight), 0, E(g)$weight)\n> E(g)$weight\n[1] 0.1 0.0 0.0 0.1 0.0 0.0 0.0 0.0 0.0\n> get.shortest.paths(g, 1, 3, weights = E(g)$weight)\n$vpath\n$vpath[[1]]\n+ 3/8 vertices, from 605e8c7:\n[1] 1 4 3\n\n\n$epath\nNULL\n\n$predecessors\nNULL\n\n$inbound_edges\nNULL\n```\n\n\nA bit more concise:\n\n```\ng <- set_edge_attr(g, \"weight\", value = ifelse(E(g) %in% E(g, path = p), 0.1, 0))\n\nE(g)$weight\n[1] 0.1 0.0 0.0 0.1 0.0 0.0 0.0 0.0 0.0\n```\n\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "can we run Dijkstra's algorithm on the modified graph and subtract the added weights to get the original distances?\r\n                \r\nConsider the following strategy to convert a graph with negative edge weights to one that does not have negative edge weights. Let the maximum magnitude negative edge weight in the graph be -k. Then, for each edge in the graph with weight w, update the weight to w+k+1. Consider the following claim:\n\nTo solve the shortest path problem in the original graph, we can run Dijkstra's algorithm on the modified graph and subtract the added weights to get the original \n\nThe claim is not true in general\n\nThe claim is true for all graphs\n\nThe claim is true for connected acyclic graphs\n\nThe claim is not true in general for connected graphs with cycles.\n    ", "Answer": "\r\nNot true in general: Consider the graph with nodes A,B,C and arcs A->B, A->C, B->C with weights 1,1,-1 in that order. The shortest path from A to C is A->B->C with weight 0. Your strategy adds two to all weights, making A->C shorter (weight 3). \n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Find shortest path from Vertex u to v passing through a vertex w?\r\n                \r\nIn a directed graph with non-negative edge weights I can easily find shortest path from u to v using dijkstra's. But is there any simple tweak to Dijkstra's so that I can find shortest path from u to v through a given vertex w. Or any other algorithm suggestions? \n    ", "Answer": "\r\nFind the shortest path from u to w, then the shortest path from w to v.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Why cannot we turn longest path into shortest graph?\r\n                \r\nToday I read on Introduction to Algorithms of the longest path problem, which asked in a weighted, directed graph what is the longest simple path passing two vertices. The author used a wonderful example showing that dynamic programming fails for the longest path problem because there does not exist a nice optimal structure that always comes with an optimal substructure. It was commented that this problem is actually NP-complete. So it must be really hard. \n\nNow here is my question: Instead of assign every edge a positive weight k>0, what if we simply assign negative weights to each edge with weight-k? Then each \"longest path\" would automatically be the shortest path, and if there is no loops in the shortest path by definition, there should not be any loops in the corresponding longest path. Hence using a quite common trick we \"can\" turn the longest path problem into the shortest path problem. \n\nCan someone point out my mistake in the reasoning? I figure something must be wrong but do not really know what it is. It is extremely unlikely my argument is correct, for obvious reasons. Reading the pseudo code provided in the book, it seems the algorithm for shortest path does not prohibit using negative weights, and after all everything can be \"elevated\" by adding a large enough constant to make them positive. I am a beginner in algorithms so this question might be trivial to experts. \n    ", "Answer": "\r\nThe mistake in your reasoning is this line:\n\n\n  if there is no loops in the shortest path by definition, there should not be any loops in the corresponding longest path.\n\n\nIf you have a graph where all edges have negative weight (which can happen in the transformation you're describing) and there's a negative cycle, then there is no shortest path between any two nodes on that cycle, since any path between them can have its cost reduced by following the cycle more and more times. Since there is no shortest path in that case, your reasoning breaks down.\n\nNow, you can argue that you should instead look for the shortest simple path between the nodes (that is, a path with no duplicated edges). Unfortunately, though, that problem is also NP-hard, so this reduction doesn't actually buy you anything.\n\nHope this helps!\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Graph and PRIM and DIJKSTRA Problems?\r\n                \r\nWe are given an Undirected, Weighted and Connected Graph G, (without negative weight and all weights are distinct) that shortest path between any two vertexes on this graph is on minimum spanning tree. \nThen:\n\n\n  I) Graph G is a Tree.\n  \n  II) weight of each {u,v} edge, is at least equal to heaviest edge in\n  shortest path from u to v.\n  \n  III) shortest path between any two vertex u, v is unique.\n  \n  IV) suppose start from vertex ```\ns```\n, Prime (for calculating MST) and Dijkstra (for calculating shortest path), process and add the\n  vertexes into a Tree, with the same order. (two algorithm works with same order in processing and adding node)\n\n\nPlease explain, why just two of these claims is TRUE? I am confusing with the definition, Proposed by OUR TA.\n    ", "Answer": "\r\nI agree with Codor that Statement I is not necessarily true and Statement II is true. Codor's proof for Statements I and II are correct. However, I think that Statement III and not necessarily true and Statement IV is true. \n\nFor Statement III, there is a counter example: \nThere are 3 vertices A, B and C. There are 3 edges (A, B), (B, C) and (A, C) whose weights are 1, 2 and 3 respectively. The minimum spanning tree includes the edges (A, B) and (B, C). However, shortest path between A and C is not unique: either (i) (A, B), (B, C), or (ii) (A, C)\n\nStatement IV is correct. This could be proved by mathematical induction. \n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Some claims on shortest path between two vertex in Diagraph?\r\n                \r\nif we show the shortest path between two vertex with ```\ndelta(u,v)```\n, in a Weighted and Directed Graph ,G, (maybe we have negative edge) can I infer that:\n\n(1) -if we didnt have any negative cycle, then ```\ndelta(u,t) <= delta(u,v) + delta(v,t)```\n\n(2) -if we didnt have any negative cycle, then for each two vertex u,v, ```\ndelta(u,v)```\n is equal to    ```\n-infinity```\n\n(3) -if we have negative edges, but didnt have any negative cycle, then ```\nSigma on delta(u,v)```\n (sum on all vertex pairs) cannot be negative.\n\nthere is not mentioned in (3), why is delta(u,v) where there's no path from u to v? maybe is 0, anyone can verify me\n    ", "Answer": "\r\nYes, no and depends.\n\n\n  -if we didnt have any negative cycle, then ```\ndelta(u,t) <= delta(u,v) + delta(v,t)```\n\n\n\nFrom having ```\ndelta(u,v)```\n and ```\ndelta(v,t)```\n, we know that there's a path from ```\nu```\n to ```\nv```\n with length ```\ndelta(u,v)```\n and a path from ```\nv```\n to ```\nt```\n with length ```\ndelta(v,t)```\n. By concatenating them, we get a path from ```\nu```\n to ```\nt```\n with length ```\ndelta(u,v) + delta(v,t)```\n. Trivially, the length of shortest path from ```\nu```\n to ```\nt```\n is less or equal to the length of this path.\n\n\n  -if we didnt have any negative cycle, then for each two vertex u,v, ```\ndelta(u,v)```\n is equal to ```\n-infinity```\n\n\n\nYou probably wanted to write \"if we did have a negative cycle\"\n\nThat's not enough for making ```\ndelta(u,v)```\n equal to ```\n-infinity```\n for any ```\nu, v```\n; only for those where a path connecting them goes goes through any vertex of that cycle. In a strongly connected graph this would be true.\n\n\n  -if we have negative edges, but didnt have any negative cycle, then ```\nSigma on delta(u,v)```\n (sum on all vertex pairs) cannot be negative.\n\n\nFor a digraph in general, this is not well defined - what is ```\ndelta(u,v)```\n where there's no path from ```\nu```\n to ```\nv```\n? If you say that ```\ndelta(u,v) = infinity```\n in that case, then your statement is true (same reason as below).\n\nIf you only consider strongly connected graphs, where every pair of vertices is connected and ```\ndelta(u,v)```\n defined, the sum of lengths must be non-negative. That's because for every distinct pair ```\nu,v```\n the sum contains both ```\ndelta(u,v)```\n and ```\ndelta(v,u)```\n. Because there's no negative cycle, ```\ndelta(u,v) + delta(v,u) >= 0```\n. Except for these pairs of ```\ndelta(u,v)```\n and ```\ndelta(v,u)```\n, the sum only contains ```\ndelta(u,u) = 0```\n for all ```\nu```\n. Summed up, we get a non-negative number.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "K-shortest path algorithm for python 3\r\n                \r\nI have tried an available K-shortest path algorithm. But it gives an error and i cannot figure out what it is. I want to find two shortest paths between two network nodes.\nIt gives an error saying that int type is not iterable and i do not know how to solve it.\n\n```\nimport sys\n#sys.modules[__name__].__dict__.clear()\nimport simpy\nimport random\nimport math\n#import run_parameters\nfrom heapq import heappush, heappop\nfrom itertools import count\n\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\n\n\"\"\"\nA NetworkX based implementation of Yen's algorithm for computing K-shortest paths.\nYen's algorithm computes single-source K-shortest loopless paths for a\ngraph with non-negative edge cost. For more details, see:\nhttp://networkx.github.io\nhttp://en.m.wikipedia.org/wiki/Yen%27s_algorithm\n\"\"\"\n__author__ = 'Guilherme Maia <guilhermemm@gmail.com>'\n\n__all__ = ['k_shortest_paths']\n\nfrom heapq import heappush, heappop\nfrom itertools import count\n\nimport networkx as nx\n\ndef k_shortest_paths(G, source, target, k=2, weight='weight'):\n    \"\"\"Returns the k-shortest paths from source to target in a weighted graph G.\n    Parameters\n    ----------\n    G : NetworkX graph\n    source : node\n       Starting node\n    target : node\n       Ending node\n`\n    k : integer, optional (default=1)\n        The number of shortest paths to find\n    weight: string, optional (default='weight')\n       Edge data key corresponding to the edge weight\n    Returns\n    -------\n    lengths, paths : lists\n       Returns a tuple with two lists.\n       The first list stores the length of each k-shortest path.\n       The second list stores each k-shortest path.\n    Raises\n    ------\n    NetworkXNoPath\n       If no path exists between source and target.\n    Examples\n    --------\n    >>> G=nx.complete_graph(5)\n    >>> print(k_shortest_paths(G, 0, 4, 4))\n    ([1, 2, 2, 2], [[0, 4], [0, 1, 4], [0, 2, 4], [0, 3, 4]])\n    Notes\n    ------\n    Edge weight attributes must be numerical and non-negative.\n    Distances are calculated as sums of weighted edges traversed.\n    \"\"\"\n    if source == target:\n        return ([0], [[source]])\n\n    length, path = nx.single_source_dijkstra(G, source, target, weight=weight)\n    if target not in length:\n        raise nx.NetworkXNoPath(\"node %s not reachable from %s\" % (source, target))\n\n    lengths = [length[target]]\n    paths = [path[target]]\n    c = count()\n    B = []\n    G_original = G.copy()\n\n    for i in range(1, k):\n        for j in range(len(paths[-1]) - 1):\n            spur_node = paths[-1][j]\n            root_path = paths[-1][:j + 1]\n\n            edges_removed = []\n            for c_path in paths:\n                if len(c_path) > j and root_path == c_path[:j + 1]:\n                    u = c_path[j]\n                    v = c_path[j + 1]\n                    if G.has_edge(u, v):\n                        edge_attr = G.edge[u][v]\n                        G.remove_edge(u, v)\n                        edges_removed.append((u, v, edge_attr))\n\n            for n in range(len(root_path) - 1):\n                node = root_path[n]\n                # out-edges\n                for u, v, edge_attr in G.edges_iter(node, data=True):\n                    G.remove_edge(u, v)\n                    edges_removed.append((u, v, edge_attr))\n\n                if G.is_directed():\n                    # in-edges\n                    for u, v, edge_attr in G.in_edges_iter(node, data=True):\n                        G.remove_edge(u, v)\n                        edges_removed.append((u, v, edge_attr))\n\n            spur_path_length, spur_path = nx.single_source_dijkstra(G, spur_node, target, weight=weight)\n            if target in spur_path and spur_path[target]:\n                total_path = root_path[:-1] + spur_path[target]\n                total_path_length = get_path_length(G_original, root_path, weight) + spur_path_length[target]\n                heappush(B, (total_path_length, next(c), total_path))\n\n            for e in edges_removed:\n                u, v, edge_attr = e\n                G.add_edge(u, v, edge_attr)\n\n        if B:\n            (l, _, p) = heappop(B)\n            lengths.append(l)\n            paths.append(p)\n        else:\n            break\n\n    return (lengths, paths)\n\ndef get_path_length(G, path, weight='weight'):\n    length = 0\n    if len(path) > 1:\n        for i in range(len(path) - 1):\n            u = path[i]\n            v = path[i + 1]\n\n            length += G.edge[u][v].get(weight, 1)\n\n    return length\n\nG=nx.complete_graph(5)\nprint(k_shortest_paths(G, 0, 4, 4))\n```\n\n\nWhy it gives this error? In some cases it works for k=1, but when i increase k to 2, the error comes.\n    ", "Answer": "", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Given undirected weighted connected graph, s,t. Find path from s to t that its most weighted edge is low as possible\r\n                \r\nGiven: undirected weighted connected graph. s,t are vertices.\n\nQuestion: Find an algorithm as efficient as possible that returns a path from s to t. In that path, the edge that has the highest weight, will has the least weight as possible. So if we have 5 paths from s,t and for every path we have the heaviest edge, so the minimum edge of these 5.\n\nWhat I've tried:\n\n\nUse some algorithm to find the shortest path between s and t.\nDelete all the edges that are not part of the shortest paths we've found\nUse BFS with some modification, We run BFS depending on the number of paths from s to t. Every time we find a maximum edge and store it in an array, then we find the minimum of the array.\n\n\nI'm struggling to find an algorithm that can be ran in (1), Bellman ford won't work - because it has to be directed graph. Dijkstra won't work because we don't know if it has negative circles or negative edges. And Prim is for finding MST which I'm not aware of how it can help us in finding the shortest path.  Any ideas?\n\nAnd other from that, If you have an algorithm in mind that can solve this question, would be much appreciated.\n    ", "Answer": "\r\nYou can solve this with Kruskal's algorithm.  Add edges as usual and stop as soon as s and t are in the same cluster.\n\nThe idea is that at each stage of the algorithm we have effectively added all edges below a certain weight threshold.  Therefore, if s and t are in the same cluster then there is a route between them consisting entirely of edges with weight less than the threshold.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Correctness of Bellman-Ford Algorithm, can we still do better?\r\n                \r\nI learned that the Bellman-Ford Algorithm has a running time of O(|E|*|V|), in which the E is the number of edges and V the number of vertices. Assume the graph does not have any negative weighted cycles.\n\nMy first question is that how do we prove that within (|V|-1) iterations (every iteration checks every edge in E), it updates the shortest path to every possible node, given a particular start node? Is it possible that we have iterated (|V|-1) times but still not ending up with shortest paths to every node? \n\nAssume the correctness of the algorithm, can we actually do better than that? It occurs to me that not all edges are negatively weighted in a particular graph. The Bellman-Ford Algorithm seems expensive, as every iteration it goes through every edges.\n    ", "Answer": "\r\nThe longest possible path from the source to any vertice would involve at most all the other vertices in the graph. In other words - you won't have a path that goes through the same vertice more than once, since that would necessarily increase the weights (this is true only thanks to the fact there are no negative cycles).\nOn each iteration you would update the shortest path weight on the next vertice in this path, until after |V|-1 iterations your updates would have to reach the end of that path. After that there won't be any vertices with non-tight values, since your update has covered all shortest paths up to that length.\n\nThis complexity is tight (at least for BF), think of a long line of connected vertices. Pick the leftmost as the source - your updating process would have to work its way from there to the other side once vertice at a time. Now you might argue that you don't have to check each edge that way, so let's throw in a few random edges with a very large weight (N > |V|*max-weight) - they can't help you, but your algorithm can't know that for sure, so if has to go through the process of updating the vertices with these weights (they're still better than the initial infinity).\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Code Output on Graph and some claims on Local Contest?\r\n                \r\nI ran into a question as follows:\n\nWe have a Code on Weighted, Acyclic Graph ```\nG(V, E)```\n with positive and negative edges. we change the weight of this graph with following code, to give a ```\nG```\n without negative edge ```\n(G')```\n. if ```\nV={1,2...,n}```\n and ```\nG_ij```\n be a weight of edge i to edge j.\n\n```\nChange_weight(G) \n for i=i to n   \n   for j=1 to n\n      c_i=min c_ij for all j\n      if c_i < 0 \n          c_ij = c_ij-c_i  for all j\n          c_ki = c_ki+c_i  for all k\n```\n\n\nWe have two axioms:\n\n1) the shortest path between every two vertex in G is the same as G'.\n\n2)  the length of shortest path between every two vertex in G is the same as G'.\n\n\n  We want to verify these two sentence. which one is True and Which one is false. Who can add some hint why these are true or false?\n\n\nMy Solution:\n\nI think two is false as following counter example, the original graph is given in left, and after the algorithm is run, the result is in right the shortest path between 1 to 3 changed, it passed from vertex 2 but after the algorithm is run it never passed from vertex 2.\n\n    ", "Answer": "\r\nAssumptions:\n\nThere are a few problems with your presentation of the question; I made some assumptions, which I clarify here. The answer to your question, given that these assumptions are correct, is in the section below.\n\nFirst, as @amit said, your use of ```\nj```\n is not clear. It seems that you meant this:\n\n```\nChange_weight(G)\n  for i = 1 to n   \n    c_i = min(c_ij)  for all j\n    if c_i < 0 \n      c_ij = c_ij-c_i  for all j\n      c_ki = c_ki+c_i  for all k\n```\n\n\nThat is, for every vertex ```\ni```\n, if the smallest outgoing edge ```\nc_i```\n is negative, then increase the weights of all outgoing edges by ```\n-c_i```\n and decrease the weights of all incoming edges by ```\n-c_i```\n. Then the smallest outgoing edge will have weight of 0.\n\nSecond, by itself, this algorithm will not guarantee that ```\nG'```\n has no negative edges! Consider the following graph:\n\n\n\nHere, the value of edge ```\n(1,2)```\n is pushed up to 0 by the operation on ```\n1```\n, but it is pushed back to -1 by the operation on ```\n2```\n. You must specify that the graph is in reverse topological order, so that edge ```\n(i,j)```\n will always be operated on by ```\nj```\n before being operated on by ```\ni```\n. (Alternatively, you could sort it in topological order and iterate from ```\nn to 1```\n.)\n\n\n\nAnswer to your question:\n\n1) The shortest path between every two vertices in ```\nG```\n is the same as in ```\nG'```\n.\n\nThis is true. Consider a path not as a tuple of edges but as a tuple of nodes. For vertices ```\ns```\n and ```\nt```\n, a path is a tuple of nodes ```\n(s, v_1, v_2, ..., t)```\n where there is an edge between every two subsequent elements. For every vertex ```\nu```\n, ```\nu```\n decreased the cost of incoming edges at the same rate that it increased the cost of outgoing edges; therefore, the relative cost of including ```\nu```\n in the path is unchanged.\n\n2) The weight of the shortest path between every two vertices in ```\nG```\n is the same as in ```\nG'```\n.\n\nThis is false. The source ```\ns```\n increases its outgoing weight by ```\n-c_s```\n, while the destination ```\nt```\n decreases its incoming weight by ```\n-c_t```\n. If ```\nc_s != c_t```\n, then the weight of the path will not be the same.\n\nTo reiterate, the weight of every path from ```\ns```\n to ```\nt```\n will be increased by ```\n(c_t-c_s)```\n. Therefore, the shortest path for a given ```\ns```\n and ```\nt```\n pair will still be the shortest (since all paths between this pair change by the same amount). However, the weight will obviously not necessarily be the same.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Finding path of zero/Negative weight between Two Nodes on Graph by Utilizing Negative Cycles\r\n                \r\nI really struggled with describing this in the title but I'll give it a go in a longer format.\n\nI'm really stumped on this problem and I'm not looking for answers, just a little help or some specific topics to read up on.\n\nWhat I have is a directed Graph with edges of various weights, both negative and positive. What I am attempting to do is to write an algorithm that is provided with two nodes positioned on the graph (and assuming they're connected) finds a path between them that results in the total weight of the path being either zero or negative. The path can include nodes multiple times (hopefully allowing for the path to offset the positive weight of included edges).\n\nI'm currently reading Russel and Norvig's Artificial Intelligence, but am struggling to find a way to apply the logic in the text to my problem due to various problems (The algorithm continuously going round the negative cycle). I'm not fully understanding how to utilize methods such as Backtrack and AStar for this\n\nIf anyone could point me in the right direction of something that would help me understand my problem better it would be a great help, I'm fine with dealing with DFS and BFS and many other things in relation to Graphs but having to find a path between two nodes with the weight restrictions is really baffling me.\n\nThanks\n\nBelow I've included a sample graph, I need to be able to find a path from Start to Goal where the total weight of the path doesn't exceed Zero. \n\nExample Graph\nhttp://i144.photobucket.com/albums/r166/ZooropaTV/bu.jpg\n\nJust realised that a lot of the searching/Reading I've been doing has been misguided, since my goal isn't necessarily about finding the shortest path by weight, but by visiting the minimum required number of nodes, I need to have another think about it now, but still would like any advice\n    ", "Answer": "\r\nI think this is what you want: The Floyd–Warshall algorithm http://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm\n\nYou'll have to modify it to fit your needs but it will detect negative cycles thus allowing you to find a path of zero or lesser weight.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Why need (node number - 1) iterations in Bellman Ford algorithm to find shortest paths?\r\n                \r\n\n\nImage: 4 iterations, with (a) is the original graph. (b), (c), (d), (e) correspond to result after each iteration. Example from \"Introduction to Algorithm 3rd\"\n\nHi, \nI do not understand few aspects about the algorithm. I hope someone could help. Below are my questions.\n\nIn each iteration, all edges are relaxed, as far as I concern. I expected all the node are updated distance in the first iteration. So why in the first iteration (b), only distance of node t and y are updated but the other still infinity?  \n\nAnother question is, why need (node number - 1) iterations in which all edges are relaxed? What is guaranteed to achieve at each iteration so that the algorithm must run in (node number - 1) time to make sure the shortest path is found as long as no negative-weight cycles exist?\n    ", "Answer": "\r\nThe reason that only ```\nd[y]```\n and ```\nd[t]```\n are updated in the first iteration is that these two vertices are the only ones whose estimation of the distance from ```\ns```\n can be improved. To be more precise, in order for ```\nd[v]```\n to be updated at a particular iteration, there must be an edge ```\n(u,v)```\n such that ```\nd[u]+w(u,v)<d[v]```\n. That is, we must be able to improve our estimation of the distance from ```\ns```\n to ```\nv```\n in order to update ```\nd[v]```\n. In the first iteration, the value of ```\nd[u]=inf```\n for every vertex ```\nu```\n (except ```\ns```\n). Therefore, if ```\nv```\n is not a neighbor of ```\ns```\n, then ```\nu```\n is not ```\ns```\n, and hence the value of ```\nd[u]+w(u,v)```\n equals ```\ninf+w(u,v)=inf```\n. This means we cannot improve our estimation of ```\nd[v]```\n. This is why only the neighbors of ```\ns```\n are updated in the first iteration even though the algorithm iterates over all the edges of the graph.\n\nAs for why we need ```\nn-1```\n iterations, the following two guarantees are achieved after ```\ni```\n iterations:\n\n\nif ```\nd[u]```\n is not ```\ninf```\n, then there exists a path of length ```\nd[u]```\n from ```\ns```\n to ```\nu```\n.\nif there is a path from ```\ns```\n to ```\nu```\n with at most ```\ni```\n edges, then ```\nd[u]```\n is at most the length of the shortest path from ```\ns```\n to ```\nu```\n with at most ```\ni```\n edges.\n\n\nThe number of edges of the shortest path from ```\ns```\n to ```\nu```\n cannot exceed ```\nn-1```\n (assuming no negative cycles). Therefore, the two guarantees (which can be proved by induction on ```\ni```\n) imply that after ```\nn-1```\n iterations, if there's a simple path of a particular length from ```\ns```\n to ```\nu```\n, the algorithm finds it.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Bellman-Ford and some facts about Graph G?\r\n                \r\nWe know the bellman-ford algorithms check all edges in each step, and for each edge if,\n\n\n  d(v)>d(u)+w(u,v)\n\n\nthen d(v) being updated such that w(u,v) is the weight of edge (u, v) and d(u) is the length of best finding path for vertex ```\nu```\n. if in one step we have no update for vertexes, the algorithms terminate. with supposing this algorithms, for finding all shortest path from vertex ```\ns```\n in graph G with ```\nn```\n vertex after ```\nk<n```\n iterate is finished, which of the following is correct? \n\n\n  1) number of edges in all shortest paths from ```\ns```\n is at most ```\nk-1```\n\n  \n  2) weight of all shortest paths from ```\ns```\n is at most ```\nk-1```\n\n  \n  3) Graph has no negative cycle.\n\n\nI'm sure one of these is True, but My TA says Two of these is correct. any idea or hint for these problem ? \n    ", "Answer": "\r\nLet's go through the statements one at a time:\n\n\n  1) number of edges in all shortest paths from ```\ns```\n is at most ```\nk-1```\n\n\n\nConsider the following graph:\n\n```\ns ---e1---> n1 ---e2---> n2 ---e3---> n3\n```\n\n\nIf the edges are ordered as given (```\ne1, e2, e3```\n), then you will have the correct distance for every node after the first iteration (checking ```\ne1```\n updates ```\nn1```\n, then checking ```\ne2```\n updates ```\nn2```\n and so on). So in this case, the algorithm stops after ```\nk=2```\n iterations because the second iteration does not change anything. Number of edges in the longest shortest path is ```\n3```\n and ```\n3 <= 2-1```\n does not hold. Hence, this statement is wrong. If, however, all edges are evaluated simultaneously, then the statement is correct (every iteration can go only one edge farther away than the previous iteration).\n\n\n  2) weight of all shortest paths from ```\ns```\n is at most ```\nk-1```\n\n\n\nNeither the number of edges nor their total weight is limited by ```\nk-1```\n. Consider that all edges in the above example have weight 1000. It is obvious that there is no connection to ```\nk```\n.\n\n\n  3) Graph has no negative cycle.\n\n\nIf you define the algorithm as you did (terminates when no changes are made), then this is correct. Any negative cycle would cause an infinite loop because the distances of vertices in this loop successively decrease.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "How can the shortest path between two nodes in a balanced binary tree be affected by path 'weight'?\r\n                \r\nI am following an online introductory algorithms course with Udacity.\n\nIn the final assessment there is a question as follows:\n\n\n  In the shortest-path oracle described in Andrew Goldberg's interview,\n  each node has a label, which is a list of some other nodes in the\n  network and their distance to these nodes.  These lists have the\n  property that:\n  \n  (1) for any pair of nodes (x,y) in the network, their lists will have\n  at least one node z in common\n  \n  (2) the shortest path from x to y will go through z.   Given a graph G\n  that is a balanced binary tree, preprocess the graph to create such\n  labels for each node.  Note that the size of the list in each label\n  should not be larger than log n for a graph of size n.\n\n\nThe full question can be found here.\n\nGiven the constraint of a balanced binary tree and the hint that the size should not be larger than log n, intuitively it seems that the label for a particular node would consist of all its parents (and optionally itself, if it isn't a leaf).\n\nHowever some additional instructor notes in the question adds:\n\n\n  Write your solution to work on weighted graphs. Note that the test\n  given, all the edges have a weight of one - which isn't particularly\n  interesting.\n\n\nSo my question is:\n\nHow can the shortest path between two nodes in a binary tree be affected by whether the paths have weights or not?\n\nSurely in a binary tree, the shortest path between two nodes is the unique simple path, and is unaffected by any weighting?\n(unless weights can be negative and the path doesn't have to be simple in which case there is no shortest path?)\n\nMy basic solution works with the simple test provided in the question, but fails to pass the automatic grader which gives no feedback.\n\nI'm obviously misunderstanding something, but what...\n    ", "Answer": "\r\nOk, so I think my initial reaction and the obvious answer is correct:\n\nPositive weights cannot affect the shortest path between two nodes in a binary tree.\n\nOn the other hand, weights obviously do affect the shortest 'distance' between two nodes in a binary tree as compared to simply calculating 'distance' between nodes as the number of hops.\n\nThis is what the udacity instruction was getting at. \nIt seems that this instruction to work with weighted binary trees was simply to enable correct automatic grading of the code which relied on using the labels to calculate the exact shortest 'distance' (which is affected by weight) as opposed to the shortest path (list of nodes) which is not.\n\nOnce I modified my algorithm to take this into account and output the correct distance, it passed the grader.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Find longest path in DAG with positive and negative edges using Bellman-ford and negated edge\r\n                \r\nI've got a graph that spans out like a tree (see crude drawing below. Can't post a picture unfortunately). It's a DAG, all of the edges should point rightwards. All the edges going up will have negative weights, all the ones going down will have positive weights. The diameter of the graph will be 48 across, but the height could be limited to 5, or 7, or others depending on the scenario.\n\n```\n        O-O...\n       / X \n      O-O-O...\n     / X X\n    O-O-O-O...\n     \\ X X\n      O-O-O...\n       \\ X\n        O-O...\n```\n\n\nI want to find the longest path from the starting node to the last node 48 nodes later. After some research, it seems like I could negate all the values (* -1), find the shortest path using Bellman-ford, and that should give me the longest path in linear time? (page 37/40 of http://courses.engr.illinois.edu/cs473/sp2011/lectures/04_class.pdf)\n\nI know that it should work if you are negating the edges if they are all positive initially. But does that still apply if some of them are positive and some of them are negative?\n    ", "Answer": "", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "How to find the unique shortest path for a weighted directed graph with SWI Prolog?\r\n                \r\nThis is an extension of what I did in Prolog class. In class, I was asked to write a predicate ```\npath(X, Y, N)```\n which returns true if and only there is a path from node ```\nX```\n to node ```\nY```\n with length ```\nN```\n. What is given is the list of directed edges with corresponding weights, e.g. ```\nedge(a, b, 3)```\n and ```\nedge(c, d, 10)```\n.\n\nThe given problem is pretty straightforward (only some recursion and base cases). However, I thought that maybe I could extend this a little further. Given that the simple directed graph input may contain cycles and contains only non-negative weights, what is the length of the unique shortest path from given nodes ```\nA```\n and ```\nB```\n. (By unique, I mean that this predicate should return false if more than one shortest path exists from ```\nA```\n to ```\nB```\n).\n\nHere is an example of the database which contains a cycle (a, b, c, e, a).\n\n```\nedge(a, b, 1).\nedge(b, c, 2).\nedge(c, d, 1).\nedge(b, d, 4).\nedge(c, e, 1).\nedge(e, a, 10).\nedge(e, d, 6).\n```\n\n\nI thought that to satisfy the unique condition, I thought that I should augment the original ```\npath/3```\n predicate to also contain the path information as a list (so that I could compare the path uniqueness later). This new augmentation is reflected in the new ```\npath/4```\n predicate.\n\n```\npath(X, X, 0, []).\npath(X, Y, N, [Y]) :- edge(X, Y, N).\npath(X, Y, N, [Z|T]) :- edge(X, Z, N1), N2 is N - N1, N2 > 0, path(Z, Y, N2, T).\n\npath(X, Y, N) :- path(X, Y, N, _).\n```\n\n\nAs of this code, I already found a problem: if I try to unify the predicate with ```\npath(a, b, N, Z)```\n, this will not work because ```\nN```\n will not be able to unify with ```\nN2 is N - N1```\n. However, if I change this part to ```\nN is N1 + N2```\n, this will still not work because ```\nN2```\n is still not unified. If I change the whole predicate line to:\n\n```\npath(X, Y, N, [Z|T]) :- edge(X, Z, N1), path(Z, Y, N2, T), N is N1 + N2.\n```\n\n\nThis will then run endlessly because the number of paths are possibly infinite because the graph may contain loops (which I want to try to keep it that way as a challenge).\n\nAs for the ```\nshortestpath/3```\n predicate, I cannot find all paths and check whether all the paths are longer because the number of paths may be infinite due to having a cycle. Instead, I tried to find any paths which have length between 0 and the given ```\nN```\n; if no path exists, then this is definitely the shortest path.\n\n```\ncountdown(N, N).\ncountdown(N, X) :- N1 is N - 1, N1 >= 0, countdown(N1, X).\n\nshortestpath(A, B, N) :- path(A, B, N), \\+((countdown(N, N1), N > N1, path(A, B, N1))).\n```\n\n\nHowever this doesn't address the ```\nN```\n given as a variable (because the countdown function wouldn't work), let alone the unique constraint.\n\nSo my question is, is there a way to make this question work or is it actually impossible to do so? If there is such a solution, please kindly provide it here (or if you think this is a \"homework\" question, please at least guide me in the correct direction).\n\nConstraints:\n\n\nI don't want to use any built-in predicates. Only 'simple' or 'core' predicates such as ```\n\\+```\n, ```\nis```\n, ```\n+```\n, for example. ```\nvar```\n, ```\nnonvar```\n, ```\nasserta```\n and similar predicates are also somewhat acceptable (since there is no alternative which achieves the same functionality).\nI want it to be as general as possible; that is, any arguments for the predicate should be able to give as a variable. (or at least have the last argument of ```\nshortestpath/3```\n, which is the length of the shortest path, a variable).\n\n\n\n\nI have looked through the following questions already and it doesn't answers my situation:\n\n\nFind the shortest path between two nodes in a graph in Prolog (Doesn't address weighted edges and also uses complex predicates (e.g. ```\npath/4```\n).\nsearch all paths and the shortest path for a graph - Prolog (Doesn't address graphs with cycles).\nFind the shortest path between two nodes in a graph in (Prolog) and display the result as array (Doesn't address weighted edges).\n\n\nPlease feel free to point me to any other question that address my question.\n    ", "Answer": "\r\nIt's nice to get a question inspired by homework rather than just actual homework! Let's start from your predicate and see if we can beat it into submission, and then we can talk about some alternate approaches.\n\nFirst I'm starting from a simplified predicate from yours:\n\n```\npath(X, Y, N, [X-Y]) :- edge(X, Y, N).\npath(X, Z, N, [X-Y|T]) :-\n    edge(X, Y, N0),\n    path(Y, Z, N1, T),\n    N is N0 + N1.\n```\n\n\nThe main difference here is that I'm just generate the paths and then computing the lengths. I'm not doing any subtraction here. It's common in Prolog to start from the simplest generate-and-test approach and then refine either the generator or the test or both until you are happy, so this is just a very simple generator. I'm keeping both source and destination nodes in the path sequence for now just to help me visualize what's going on, and with it you see immediately the problem with cycles:\n\n```\n?- path(a, e, N, T).\nN = 4,\nT = [a-b, b-c, c-e] ;\nN = 18,\nT = [a-b, b-c, c-e, e-a, a-b, b-c, c-e] ;\nN = 32,\nT = [a-b, b-c, c-e, e-a, a-b, b-c, c-e, e-a, ... - ...|...] .\n```\n\n\nI don't think we are with your sample graph, but we could be suffering a bit here from Prolog's depth-first search: as long as there's no failure, Prolog has no reason to back up and try another path. And you see the cycles right there. If it used breadth-first search instead, you'd be fairly sure the first solution is the shortest simply because by advancing everything one step, you never get caught in a rabbit hole before generating your first solution. Dijkstra's algorithm (thanks for the reminder @JakobLovern) skirts the problem by coloring visited nodes and not counting them more than once. \n\nIt is possible to control the search behavior by creating a metainterpreter, which isn't as bad as it sounds but is more work than adjusting the search to account for cycles, which is I think what most people do in this circumstance with a graph, so let's try that first:\n\n```\npath(X, Y, N, Path) :- path(X, Y, N, [], Path).\n\npath(X, Y, N, Seen, [X]) :-\n    \\+ memberchk(X, Seen),\n    edge(X, Y, N).\npath(X, Z, N, Seen, [X|T]) :-\n    \\+ memberchk(X, Seen),\n    edge(X, Y, N0),\n    path(Y, Z, N1, [X|Seen], T),\n    \\+ memberchk(X, T),\n    N is N0 + N1.\n```\n\n\nAdding the ```\nSeen```\n parameter and using ```\n\\+ memberchk/2```\n to avoid adding things to the path that are already in the path is not really an uncommon thing to do. ```\nmemberchk/2```\n is not ISO, but it's a very common predicate. You could implement it yourself like this (please don't!):\n\n```\nmemberchk(X, L) :- once(member(X, L)).\nmember(X, [X|_]).\nmember(X, [_|Xs]) :- member(X, Xs).\n```\n\n\nI think it's worth noting that ```\nmemberchk/2```\n + lists equals basically sets as used in Dijkstra's algorithm. This is like ```\nin```\n in Python; it would be kind of insane to try and do anything real in Prolog without at least ```\nmember/2```\n.\n\nThese changes make ```\npath/4```\n avoid cycles, so you can now find all the solutions without any spurious ones. Note: I have not made your graph acyclic. I have simply made ```\npath/4```\n aware of cycles. \n\nNote we get multiple solutions:\n\n```\n?- path(a, d, X, Y).\nX = 5,\nY = [a, b] ;\nX = 4,\nY = [a, b, c] ;\nX = 10,\nY = [a, b, c, e] ;\nfalse.\n```\n\n\nThere is a nice library, aggregate which is helpful for situations like this. But, you asked for no spurious libraries. :)\n\nLet's just get the shortest path:\n\n```\nuniq_shortest_path(X, Y, MinCost, Path) :-\n    path(X, Y, MinCost, Path), \n    \\+ (path(X, Y, LowerCost, OtherPath), \n        OtherPath \\= Path, \n        LowerCost =< MinCost).\n```\n\n\nWhat this literally says is that ```\nPath```\n is the unique shortest path between X and Y (happening to have cost ```\nMinCost```\n) if and only if there is no other path with a cost less than or equal to our cost. Trying it out:\n\n```\n?- uniq_shortest_path(a, d, MinCost, Path).\nMinCost = 4,\nPath = [a, b, c] ;\n```\n\n\nThis trick isn't cheap; it's likely that it works by comparing all the solutions to each other. But it does work, without any additional shenanigans. \n\nA significant improvement would probably come by just getting all the solutions, sorting on cost and then ensuring that the first two do not have the same cost before reporting the cost and path of the first one.\n\nA greater improvement could probably be found by implementing Dijkstra's algorithm directly, or possibly by trying to make a breadth-first metainterpreter. Doing an iterative-deepening approach would probably work, but I doubt it would perform better, since it would often have to do and re-do all the work leading up to a result that gets pruned for being too expensive.\n\nAnyway, I hope this helps! Stay excited about Prolog!\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Dijkstra looped tree\r\n                \r\nAnyone knows this? \n\n\n  A looped tree is a weighted, directed graph built from a binary tree\n  by adding an edge from every leaf back to the root. Every edge has a\n  non-negative weight.\n  \n  \n  How much time would Dijkstra’s algorithm require to compute the shortest path between two vertices u and v in a looped tree with n\n  nodes?\n  Describe and analyze a faster algorithm.\n  \n\n    ", "Answer": "\r\n\n  How much time would Dijkstra’s algorithm require to compute the\n  shortest path between two vertices u and v in a looped tree with n\n  nodes?\n\n\nIt will take ```\nO(VlogV)```\n time (worst case analysis).\nNote that there is a single simple path for each pair of nodes ```\n(u,v)```\n that connects ```\nu```\n to ```\nv```\n. If this path for some reason contains a very heavy weighted edge, Dijksta's algorithm is going to keep postponing taking this edge, and will fail to discover the correct route until it will, which will make the algorithm have to discover most of the vertices in the looped tree, making the complexity ```\nO(VlogV)```\n (Note that E is in ```\nO(V)```\n for this graph).\n\n\n  Describe and analyze a faster algorithm.\n\n\nSince there is a single simple path, you just need to find it.\nIt can be easily done by finding the lowest common ancestor in the tree (without loops), and then finding a route to this ancestor from ```\nu```\n.\nComplexity of this algorithm is ```\nO(h)```\n - where ```\nh```\n is the height of the graph.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "How to make bellman-ford run in worst case?\r\n                \r\nI am trying to make optimized version of bellman ford algorithm to run in worst case. Optimized version I mean if after relaxing 1 round of edges and there is no further update on the shortest distance, it terminates.\n\nFor instance, a simple connected weighted directed graph with 7 vertices such that running Optimized Bellman-Ford's algorithm from source vertex 0 uses at least 5 rounds to get the correct shortest paths.\n\nThe graph cannot contain a negative weight cycle.\ni.e. all outgoing edges from vertex 0 is processed then edges from vertex 1 and so on\n\nI know it has to do with cycles. But i am not very sure the strategy in drawing the graph to meet the requirement.\n    ", "Answer": "\r\nYour version of the Bellman-Ford algorithm will need as many iterations as the longest length (in edges) of all shortest paths in the graph.\n\nConsider a directed graph with n vertices. You add edges 1 -> 2 -> 3 -> ... -> n to the graph, each having a small positive weight. Then you can add as many arbitrary heavy edges as you want. It is clear that the shortest path from 1 to n has length n-1. Thus your algorithm will need exactly n-1 iterations.\n\nOn further note, there is an improved version of the Bellman-Ford algorithm. It is called the Shortest Path Faster Algorithm. Although it has a worst-case run-time of ```\nO(|V|*|E|)```\n, which is the same as Bellman-Ford, very few graphs can make the algorithm reach that time. In practice, you can expect an average runtime of ```\nO(|E|)```\n (unproven).\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Find shortest path from s to every v with a limit on length\r\n                \r\n\n  Let ```\nG(V,E)```\n a directed graph with weights ```\nw:E->R```\n. Let's assume ```\n|V|```\n is dividable by ```\n10```\n. Let ```\ns```\n in ```\nV```\n. Describe an algorithm to find a shortest path from ```\ns```\n to every ```\nv```\n such that it contains exactly ```\n|V|/10```\n edges.\n\n\nSo at first I thought about using dynamic programming but I ended up with complexity of ```\nO(|V|^3)```\n which apparently not optimal for this exercise. \n\nWe can't use Bellman-Ford (As far as I understand) since there might be negative cycles.\n\nWhat could be an optimal algorithm for this problem?\n\nThanks\n\n EDIT\n\nI forgot to mention a crucial information; Path can be not-simple. i.e. we may repeat edges in our path.\n    ", "Answer": "\r\nYou can perform a depth limited search with limit of ```\n|V|/10```\n on your graph. It will help you find the path with the least cost.\n\n```\nlimit = v_size / 10\nbest[v_size] initialize to MAX_INT\n\ndepth_limited(node, length, cost)\n    if length == limit\n        if cost < best[node]\n            best[node] = cost\n        return\n    for each u connected to node\n        depth_limited(u, length+1, cost + w[node][u])\n\ndepth_limited(start_node, 0, 0)\n```\n\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "How to get the direction of roads in osmnx for finding shortest path for an emergency vehicle like ambulance\r\n                \r\nI am writing a code for shortest path with multiple heuristics for emergeency vehicles dispatchment like ambulances, I am using osmnx module and created an undirected weighted graph. I wanted to add a negative weight to edges if the road is one way and the direction in which the vehicle is going is oppositee of the direction of road but, I am not able to find that the vehicle is travelling in which direction with respect to direction of road so, I am unable to add a heuristic for that. There is no real ambulance so, it is not like I can use gps.\nI tried to look at the different attributes of the graph that I got from osmnx. I thought that by looking at the edges, I can take the first coordinate as the starting and the seccond as the ending  and using that I thought I can get the directon but, there is the attribute 'reversed' whose significance I don't understand. It says something like if the attribute is true then, the edge is in the opposite direction of the OSM way, what does that even mean?\n    ", "Answer": "\r\n\nthere is the attribute 'reversed' whose significance I don't understand. It says something like if the attribute is true then, the edge is in the opposite direction of the OSM way, what does that even mean?\n\nTo answer this question: OpenStreetMap ways are defined by nodes in a certain order. If the way is bidirectional (that is, it allows two-way traffic), OSMnx models it with two reciprocal directed edges, one pointing in each direction. The ```\nreversed```\n attribute indicates if this specific edge's nodes are in the reverse order of the original OpenStreetMap way's nodes. This allows using order-dependent attributes (such as lane directions). See also.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Two vertices with shortest path\r\n                \r\nI am trying to solve this question but got stuck.\nNeed some help,Thanks.\n\nGiven an undirected Connected graph G with non-negative values at edges.\nLet A be a subgroup of V(G), where V(G) is the group of vertices  in G.  \n\n-Find a pair of vertices (a,b) that belongs to A, such that the weight of the shortest path between them in G is minimal, in O(V*(E+Vlog(v)))\n\nI got the idea of using Dijkstra's algorithm in each node which will give me O(V*(E+Vlog(v))). I think that's too much and we can do it by using Dijkstra's one time.\nSo thought about connecting the vertices in A somehow,did'nt find any useful way.\n    ", "Answer": "\r\nLet's understand the above scenario by looking at an example.\n\nLet graph ```\nG```\n comprise of - ```\na, b, c, d, e, f```\n i.e \n\n```\nV(G) = {a,b,c,d,e,f}\n```\n\n\nNow As said A is a subgroup of V(G), so let's assume \n\n```\nA = {a,b,c}\n```\n\n\nNow run ```\nFloyd–Warshall algorithm```\n over this graph and that will basically provide you with shortest paths between all pairs of vertices.\n\nAnd the overall time complexity of this algorithm is O(V^3) where V is the number of vertices in the graph.\n\nOnce this algorithm is complete you can easily check which two pairs of vertices are present in the subgroup A.\n\nHope this helps!\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Floyd-warshall for longest distance for undirected graph\r\n                \r\nI want to find the largest distance between any two vertices of a weighted undirected graph using Floyd-warshall algorithm. For this i have made few changes:\n\n\nI add negative weights instead of positive.\nThen i find out the shortest path.\n\n\nBut it does not give me the correct output. Can someone point out the mistake i am making.\n\n```\nclass TestClass {\n    public static void main(String args[] ) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        int testcases=sc.nextInt();\n        for(int t=0;t<testcases;t++)\n        {\n            int nodes=sc.nextInt();\n            int edges=sc.nextInt();\n            int[][] dist_mat=new int[nodes][nodes];\n            for(int i=0;i<nodes;i++)\n            {\n                for(int j=0;j<nodes;j++)\n                {\n                    if(i!=j)\n                    {\n                        dist_mat[i][j]=Integer.MAX_VALUE;\n                    }\n                }\n            }\n            for(int i=0;i<edges;i++)\n            {\n                int source=sc.nextInt();\n                int dest=sc.nextInt();\n                dist_mat[source-1][dest-1]=-sc.nextInt();\n                dist_mat[dest-1][source-1]=dist_mat[source-1][dest-1];\n            }\n\n            for(int k=0;k<nodes;k++)\n            {\n                for(int i=0;i<nodes;i++)\n                {\n                    for(int j=0;j<nodes;j++)\n                    {\n\n                        if(i!=j && j!=k && i!=k && dist_mat[i][j]>dist_mat[i][k]+dist_mat[k][j])\n                        {\n                            if(dist_mat[i][k]<Integer.MAX_VALUE && dist_mat[k][j]<Integer.MAX_VALUE)\n                                    dist_mat[i][j]=Integer.min(dist_mat[i][j],dist_mat[i][k]+dist_mat[k][j]);\n                            if(dist_mat[j][k]<Integer.MAX_VALUE && dist_mat[k][i]<Integer.MAX_VALUE)\n                                    dist_mat[j][i]=Integer.min(dist_mat[j][i],dist_mat[j][k]+dist_mat[k][i]);\n                        }\n\n                    }\n                }\n            }   \n        }\n    }\n```\n\n\nThe same input is :-\n\n1[number of test cases]\n\n5 4 [number of nodes,number of edges]\n\n1 2 4 [first node, second node, weight]\n\n3 2 3 [first node, second node, weight]\n\n2 5 2 [first node, second node, weight]\n\n4 1 1 [first node, second node, weight]\n    ", "Answer": "\r\nFloyd-Warshal should work. First notice that there is a confusion when people talk about longest distance problem and its NP-hardness. \n\nFrom this link:\n\n\n  notice that there is a huge confusion when we talk about the longest\n  path:\n  \n  The longest path problem commonly means finding the longest simple\n  path. The shortest path problem, however, focuses\n  on finding the shortest (simple or non-simple) path.\n\n\nIf the original graph ```\nG```\n does not have a positive cycle, then ```\n-G```\n, the graph created from G by negating its edges, will not have negative edges, and you CAN use Floyd-Warshall to find the shortest path in ```\n-G```\n, and hence the longest path in ```\nG```\n. Therefore, Floyd-Warshall should work if your input graph does not have positive cycles. Also see here.\n\nOne possible issue with your code is that you initialize all distances to a MAX value: ```\ndist_mat[i][j]=Integer.MAX_VALUE```\n, whereas I think in Floyd-Warshall you should initialize them to the edge weights of the graph.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Breadth First Search in O(log n)\r\n                \r\nIs it possible to find the destination from a source in O(log n) time using BFS (using min vertices traversed) in an undirected graph with loop and negative edges?\n\nFor ex:\nYou are given a simple connected graph G with N vertices and N edges (a simple graph is an un-directed graph that has no loops and no more than one edge between any two different vertices).\nIt is obvious that the graph G contains exactly one cycle and you can assume that the length of this cycle is odd (there are odd number of vertices in this cycle).\nThe vertices are numbered from 1 to N. Each edge is assigned a corresponding integer weight.\nYour mission is to stimulate two types of queries :\nUpdate query represented by f u v: change the sign of all the weights of the edges on the shortest path (you can see the definition of shortest path in this problem later on) from vertex u to vertex v.\nFind query represented by ? u v: On the shortest path from vertex u to vertex v, find the (possibly empty) set of consecutive edges such that the sum of the weights is maximal. In other words, let's define the shortest path from u to v as a_1, a_2, ..., a_k (where a_1 = u and a_k = v). You have to find a_i and a_j such that i <= j and the sum of the weights of the edges of the path a_i, a_(i + 1), ..., a_j is as large as possible. You just have to find that sum.\nThe shortest path between two vertices u and v is the path connecting them with the minimal number of vertices. In this problem, it is obvious that there is only one shortest path between any pair of vertices of G.\n    ", "Answer": "\r\nLet the ```\nG```\n be a graph with Vertex set ```\nV```\n and Edge set ```\nE```\n. Then the time complexity in the worst case of the Breadth First Search (```\nBFS```\n) is ```\nO(|V|+|E|)```\n. The time complexity is ```\nO(|V|+|E|)```\n, because each vertex and edge is visited in the worst case. The complexity O(|E|) may vary between O(|V|) and O(|V2|). In case of a sparse graph the complexity will be approximately O(|V|) and in case of a dense graph the complexity will be approximately O(|V2|). \n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Find Shortest Path in a directed weighted graph from list of sources and list of destinations\r\n                \r\nFirst of all is that my Graph contains negative weights so I can't use Dijkstra's algorithm.\n\nI tried to use and edit a kind of Floyd-Warshall algorithm, but it's good only in some cases. Maybe I have to use an edited version of Bellman-Ford algorithm, but I'm not able to find a way..\n\n```\n<EDIT>\n```\n\n\nI'm not able to find a way to have the correct output, not to find the shortest path because I'm able to do it, but to have a correct output in this input. (see the draw and compare it with the output, you can see that is different. for example: \n\n```\n2 -> 5     -4    2 -> 1 -> 3 -> 4 -> 5\n```\n\n\nThe distance -4 is incorrect, in the draw is -2, while in the other output with a bit different input as described in the post below, everything is correct.\n\n```\n</EDIT>\n```\n\n\nHere is my input (1) file:\n\n```\n6 9\n2 3\n0 1 -2\n0 2 1\n2 1 -3\n1 3 2\n2 3 3\n2 5 1\n5 3 1\n3 4 1\n4 5 -3\n```\n\n\nWhere ```\n6```\n is the number of nodes, ```\n9```\n is the number of edges, ```\n2```\n and ```\n3```\n are respectively the sources and the destinations (```\n0<=sourceNodes<=2```\n and ```\n3<=destinationsNodes<=5```\n) where I have to calculate the shortest path.\nSo, in this input file my code gives me this output and if we see the draw I made for you, it's wrong.\n\n\n\nWhile the Output is:\n\n```\npairs     dist     path\n0 -> 3    -1     0 -> 1 -> 3\n0 -> 4     0     0 -> 1 -> 3 -> 4\n0 -> 5    -3     0 -> 1 -> 3 -> 4 -> 5\n1 -> 3     1     1 -> 3\n1 -> 4     2     1 -> 3 -> 4\n1 -> 5    -1     1 -> 3 -> 4 -> 5\n2 -> 3    -2     2 -> 1 -> 3\n2 -> 4    -1     2 -> 1 -> 3 -> 4\n2 -> 5    -4     2 -> 1 -> 3 -> 4 -> 5\n```\n\n\nHere is my code: \n\n```\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Esercizio3 {\n\npublic static void main(String args[]) throws IOException {\n    try {\n        Scanner scan = new Scanner(new File(\"/myFiles/Input2Es3.txt\"));\n        int totNodi = scan.nextInt();\n        System.out.println(\"totNodi: \"+totNodi);\n        int totArchi = scan.nextInt();\n        System.out.println(\"totArchi: \"+totArchi);\n        // ingressi\n        int nIngressi = scan.nextInt();\n        System.out.println(\"nIngressi: \"+nIngressi);\n        int[] ingresso = new int[nIngressi+1];\n        for (int i=0; i<=nIngressi; i++) {\n            ingresso[i] = i;\n            System.out.println(\"> INGRESSO: \"+ingresso[i]);\n        }\n        // uscite\n        int startUscite = scan.nextInt();\n        //        int endUscite = totNodi-1;\n        int nUscite = totNodi-startUscite;\n        System.out.println(\"nUscite: \"+nUscite);\n        int[] uscita = new int[nUscite];\n        for (int i=startUscite; i<totNodi; i++) {\n            int index = i-startUscite;\n            uscita[index] = i;\n            System.out.println(\"> USCITA: \"+uscita[index]);\n        }\n        // archi\n        int V = totNodi;\n        int E = totArchi;\n        int[][] weights = new int[totArchi][3];\n        for (int i=0; i<totArchi; i++) {\n            weights[i][0] = scan.nextInt();\n            weights[i][1] = scan.nextInt();\n            weights[i][2] = scan.nextInt();\n            System.out.println(weights[i][0] + \" - \" + weights[i][1] + \" - \" + weights[i][2]);\n        }\n\n        floydWarshall(weights,totNodi,ingresso,uscita);\n\n\n    } catch (FileNotFoundException ex) {\n        System.out.println(ex);\n    }\n}\n\nstatic void floydWarshall(int[][] weights, int numVertices, int[] ingresso, int[] uscita) throws IOException {\n\n    double[][] dist = new double[numVertices][numVertices];\n    for (double[] row : dist)\n        Arrays.fill(row, Double.POSITIVE_INFINITY);\n\n    for (int[] w : weights)\n        dist[w[0]][w[1]] = w[2];\n\n    int[][] next = new int[numVertices][numVertices];\n    for (int i = 0; i < next.length; i++) {\n        for (int j = 0; j < next.length; j++)\n            if (i != j)\n                next[i][j] = j + 1;\n    }\n\n    for (int k = 0; k < numVertices; k++)\n        for (int i = 0; i < numVertices; i++)\n            for (int j = 0; j < numVertices; j++)\n                if (dist[i][k] + dist[k][j] < dist[i][j]) {\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                    next[i][j] = next[i][k];\n                }\n\n    printResult(dist, next, ingresso, uscita);\n}\n\nstatic void printResult(double[][] dist, int[][] next, int[] ingresso, int[] uscita) throws IOException {\n    BufferedWriter writer = new BufferedWriter(new FileWriter(\"myoutputfile.txt\"));\n\n    double distMin =  Double.POSITIVE_INFINITY;\n    int indexI = 0;\n    int indexJ = 0;\n    for (int i = 0; i < next.length; i++) {\n        for (int j = 0; j < next.length; j++) {\n            if ((i != j) && (dist[i][j]!=Double.POSITIVE_INFINITY) && (i>=ingresso[0] && i<=ingresso[ingresso.length-1]) && (j>=uscita[0] && j<=uscita[uscita.length-1])) {\n                int u = i + 1;\n                int v = j + 1;\n                String path = format(\"%d -> %d    %2d     %s\", i, j, (int) dist[i][j], i);\n                do {\n                    u = next[u-1][v-1];\n                    path += \" -> \" + (u-1);\n                } while (u != v);\n                System.out.println(path);\n\n\n\n                if(distMin > dist[i][j]) {\n                    distMin = dist[i][j];\n                }\n\n            }\n        }\n    }\n}\n\n}\n```\n\n\nHow can I solve this? because with another input it runs perfectly:\n\nInput (2) that runs (it's similar to the first one but a different weight in the last raw):\n\n```\n6 9\n2 3\n0 1 -2\n0 2 1\n2 1 -3\n1 3 2\n2 3 3\n2 5 1\n5 3 1\n3 4 1\n4 5 1\n```\n\n\nOutput perfect:\n\n```\n0 -> 3     0     0 -> 1 -> 3\n0 -> 4     1     0 -> 1 -> 3 -> 4\n0 -> 5     2     0 -> 2 -> 5\n1 -> 3     2     1 -> 3\n1 -> 4     3     1 -> 3 -> 4\n1 -> 5     4     1 -> 3 -> 4 -> 5\n2 -> 3    -1     2 -> 1 -> 3\n2 -> 4     0     2 -> 1 -> 3 -> 4\n2 -> 5     1     2 -> 5\n```\n\n\nThe only thing I know is that for the first input the output should be ```\n-1```\n, while for the last input the output should be ```\n2 -> 1 -> 3```\n which is the path with the shortest distance between a source node and a destination node (and it's correct).\n\nThank you\n    ", "Answer": "\r\nFirstly if there is a negative cycle then we can't find a shortest path. It is easy to visualize that. Cause if we repeatedly traverse the negative cycle then the cost will decrease for every traversal. As a result we will find infinitely decreasing value of our path.\n\nWell, to avoid this drawback we use Bellman-Ford's algorithm. Which detects whether a graph contains a negative cycle or not. I am assuming you know Bellman-Ford's and Dijkstra's Algorithm and used to with the term \"Relaxation\".\n\nNow we will follow an approach known as Johnson's algorithm:\n\n\nWe will add an extra vertex X and connect it to all the other vertices of the graph and the edges will all be of cost 0.\nTaking the new vertex X as source, we will apply Bellman-Ford's\nalgorithm. Which will find the shortest path of all the edges from\nthe source in a total of (n-1) iterations, where n is total number of\nvertices including X.\nWe will take an extra iteration, from the same source and it will perform differently in two different cases.\n\n\nNegative cycle present: Relaxation will be seen again to happen.\nIt means there is a negative cycle and we can't have a shortest\npath in the graph as I explained above. So, our program should\nterminate.\nNegative cycle not present: No relaxation will take place and we got the shortest path of all vertices from X. We are ready to go!\n\nWe will reweight the edges of the original graph using the shortest path from the Bellman-Ford's algorithm. \nIf u and v has a edge in main graph with cost w(u,v) and shortest paths of u and v from X are h(u) and h(v) respectively, then new weight  nw(u,v)= w(u,v)+h(u)-h(v). \n\n\nNow Dijkstra's algorithm from your selected source should find the shortest path to all vertices on the reweighted graph which is also the shortest path of the original graph.\n\nIf you are yet confused please check Johnson's algorithm at Wikipedia.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Single pair shortest path multiple travelers\r\n                \r\nI'm programming a turn based strategy game and I have a special single pair shortest path problem. I have a weighted directed graph with non-negative non-zero edge weights and here is the catch, with multiple travelers, that is units with different movement types traveling together as a group. Each edge of the graph has different weights for different units depending on movement type.\n\nNormally one would use eg. Dijkstras algorithm to solve the shortest path problem. But with multiple units moving together as a group and different edge weights for each unit the case may be that the optimal path is not the same as the optimal path for any single unit moving alone. As can be seen from below \n\n\n\nwith red and green moving from S to D. The optimal path for red moving alone would be S-A-D with a cost of 2 and the optimal path for green moving alone would be S-C-D with a cost of 2. In both cases, however, the other units movement cost would be 5 and thus the optimal path, with the units moving together, is S-B-D with a maximum movement cost of 4.\n\nDifferent amounts of movement points per turn per unit type seems not to be a problem since the edge weights could be normalized. Could this be formulated as a linear program and solved with the simplex algorithm ? It would seem we would have multiple objective functions and we would like to minimize the maximum. But is there perhaps a simpler solution ?\n    ", "Answer": "\r\nIf you really want the multiple travelers to travel in a group, then you will need to use some sort of an optimization algorithm and find the optimum, like you've suggested.\n\nOn the other hand, if you don't need the optimum for the whole group (which could take some time), you could try using a heuristic or an approximate optimization algorithm.\n\nSince I don't know the details of your game, I can't say which heuristic could be useful for you. You could, perhaps, minimize the search space a bit by choosing a representative from each of the group (flyer, swimmer, ground unit...), and find the optimum group's path of the selected units.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "shortest path from single source to single destination in a non-negative weighted grid (n,5)\r\n                \r\nI have a grid with n columns and 5 rows.\n\nEach edge is weighted and non-negative. i need to start from the bottom-left corner and get to the top-right corner with the shortest path.\n\nI found it in O(N^2) complexity but i need it in linear time O(n).\n\nI would be grateful for some help.\n\nHow I solved a grid (n,2) in linear time:\n\nthe bottom left is 0, and then i start looking for it's neighbors with a few comparisons. after i found the minimum from the beginning to them, i go to their neighbors and do the same, this I do until i get to the end.\n\nI delt with each vertex and each edge once and therefore it is linear.\n\nThank you in advance,\n\nYaron.\n    ", "Answer": "\r\nIn this Graph you have ```\n5n```\n vertices and ```\n5*4*n```\n edges so ```\nV=5n```\n and ```\nE=20n```\n.\nYou can easily apply Dijkstra using priority_queue for retrieval of min vertex which will result in time complexity of O(VlogV + ElogE) which is in this case O(N*logN).\n\nDijkstra wiki link.It contains the sudo code.\n\nYou can also find it's C++ implementation if you search in google but make sure it uses priority_queue otherwise it will take log(N^2) time. If you don't find it send me a comment and I will send you it's implementation. \n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Bellman Ford Algorithm fails to compute shortest path for a directed edge-weighted graph\r\n                \r\nI was recently understanding shortest path algorithms when I encountered the problem below in the book Algorithms, 4th edition, Robert Sedgewick and Kevin Wayne.\n\n\n  Suppose that we convert an EdgeWeightedGraph into a Directed EdgeWeightedGraph by creating two DirectedEdge objects in the EdgeWeightedDigraph (one in each direction) for each Edge in the EdgeWeightedGraph and then use the Bellman-Ford algorithm. Explain why this approach fails spectacularly.\n\n\nBelow is a piece of my code implementing Bellman Ford Algorithm (queue-based):\n\n```\nprivate void findShortestPath(int src) {\n    queue.add(src);\n    distTo[src] = 0;\n    edgeTo[src] = -1;\n    while (!queue.isEmpty()) {\n        int v = queue.poll();\n        onQueue[v] = false;\n        for (Edge e : adj(v)){\n            int w = e.dest;\n            if (distTo[w] > distTo[v] + e.weight) {\n                distTo[w] = distTo[v] + e.weight;\n                edgeTo[w] = v;\n            }\n            if (!onQueue[w]) {\n                onQueue[w] = true;\n                queue.add(w);\n            }\n\n            //Find if a negative cycle exists after every V passes\n            if (cost++ % V == 0) {\n                if (findNegativeCycle())\n                    return;\n            }\n        }\n    }\n}\n```\n\n\nI've tried many examples on paper, but am unable to find scenarios where the directed graph generated would have new negative cycles in them, simply by converting an edge into two edges in opposite directions. I assume that there were no pre-existing negative cycles in the unweighted undirected edge-weighted graph.\n    ", "Answer": "\r\nYour algorithm & code has no problem.It can give the shortest distance in a graph without negative circle.And it's easy to find out negative circle only by a array 'number[i]' record the number that 'i' is put into the queue.\n\nIt can be proved that if a point is put into the queue for over |P|(points number) times,there is a negative circle in the graph.So you can add:\n\n```\n\n    number[v]++;\n    if (number[v] > |P|) \n        return -1;\n```\n\n\nThe shortest distance in a graph with negative circle has no meaning.So for most of the situation you just need to print something while finding it.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Why would one consider using Bellman Ford?\r\n                \r\nSo, say you wanted to find the shortest path between two vertices.\nI would argue this:\nA.) If the graph has no negative edge weights and is represented by an adjacency list, you could run Dijkstra's algorithm either once to find a single source shortest path in O(V^2) time or run Dijkstra's algorithm on all vertices O(V^3) (both of are pretty sloppy in the case of non-complete graphs) to find all shortest paths.\nB.) Graph with no negative edge weights and is in matrix form: Either use Dijkstra's to find a single source shortest path O(V^2) or run Floyd-Warshall to find all possible shortest paths O(V^3).\nC.) Graph has negative edge weights and is in either list or matrix form: Run either Bellman-Ford to find the single source shortest path O(V^3) or use FW to find all shortest paths in O(V^3) time. Since their runtime is approximately the same (they will differ if the graph is in list form) you might as well just run FW and get more information for approximately the same runtime... right?\nSo: Is there any real-world application where one would use Bellman-Ford? The only thing I can think of is if the graph is in list form and has negative edge weights. I'm not sure of the implications this has on FW or if that list would first need to be converted into a matrix.\n    ", "Answer": "\r\nTechnically, even in case of graph with negative weights, give -N the minimum cost registered, you could increase all the weights by N (in order to make the most negative weight equal to zero).\nThen you can apply Dijkstra or any other algorithm.\nThe shortest path doesn't change. Just remember to readjust the weights before computing the real shortest path's cost\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Shortest path distance from source(s) to all nodes in the graph - O(m + n log(n)) time\r\n                \r\nLet G(V,E) be a directed weighted graph with edge lengths, where all of the edge lengths are positive except two of the edges have negative lengths. Given a fixed vertex s, give an algorithm computing shortest paths from s to any other vertex in O(e + v log(v)) time. \n\nMy work:\n\nI am thinking about using the reweighting technique of Johnson's algorithm. And then, run Belford Algo once and apply Dijkstra v times. This will give me the time complexity as O(v^2 log v + ve).\nThis is the standard all pair shortest problem, As I only need one vertex (s) - my time complexity will be O(v log v + e) right?\n    ", "Answer": "\r\nFor this kind of problem, changing the graph is often a lot easier than changing the algorithm. Let's call the two negative-weight edges N1 and N2; a path by definition cannot use the same edge more than once, so there are four kinds of path:\n\n\nA. Those which use neither N1 nor N2,\nB. Those which use N1 but not N2,\nC. Those which use N2 but not N1,\nD. Those which use both N1 and N2.\n\n\nSo we can construct a new graph with four copies of each node from the original graph, such that for each node ```\nu```\n in the original graph, ```\n(u, A)```\n, ```\n(u, B)```\n, ```\n(u, C)```\n and ```\n(u, D)```\n are nodes in the new graph. The edges in the new graph are as follows:\n\n\nFor each positive weight edge ```\nu-v```\n in the original graph, there are four copies of this edge in the new graph, ```\n(u, A)-(v, A)```\n ... ```\n(u, D)-(v, D)```\n. Each edge in the new graph has the same weight as the corresponding edge in the original graph.\nFor the first negative-weight edge (N1), there are two copies of this edge in the new graph; one from layer A to layer B, and one from layer C to layer D. These new edges have weight 0.\nFor the second negative-weight edge (N2), there are two copies of this edge in the new graph; one from layer A to layer C, and one from layer B to layer D. These new edges have weight 0.\n\n\nNow we can run any standard single-source shortest-path problem, e.g. Dijkstra's algorithm, just once on the new graph. The shortest path from the source to a node ```\nu```\n in the original graph will be one of the following four paths in the new graph, whichever corresponds to a path of the lowest weight in the original graph:\n\n\n```\n(source, A)```\n to ```\n(u, A)```\n with the same weight.\n```\n(source, A)```\n to ```\n(u, B)```\n with the weight in the new graph minus the weight of N1.\n```\n(source, A)```\n to ```\n(u, C)```\n with the weight in the new graph minus the weight of N2.\n```\n(source, A)```\n to ```\n(u, D)```\n with the weight in the new graph minus the weights of N1 and N2.\n\n\nSince the new graph has 4V vertices and 4E - 2 edges, the worst-case performance of Dijkstra's algorithm is ```\nO((4E - 2) + 4V log 4V)```\n, which simplifies to ```\nO(E + V log V)```\n as required.\n\nTo ensure that a shortest path in the new graph corresponds to a genuine path in the original graph, it remains to be proved that a path from e.g. ```\n(source, A)```\n to ```\n(u, B)```\n will not use two copies of the same edge from the original graph. That is quite easy to show, but I'll leave it to you as something to think about.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Verify a shortest path for every vertex in a directed graph\r\n                \r\nWell I'm trying to solve a problem with a more efficient solution and I can't think about anything that would work for sure than the trivial solution, also can't find the same version of this problem in any other sources I came across to so I would love for some help.\n\nGiven:\n\n1.A directed graph G, in which every edge has a weight (weight can be negative and G may contain negative cycles).\n\n2.A d[v] field for every vertex.\n\n3.A source vertex s.\n\nHow can I verify for every vertex in G if d[v] is the length of the shortest path in G from s to v?\n\nof course I can use Bellman-Ford algorithm and compare each d[v] to the distance that Bellman-Ford gave for v.. but that is pretty naive and not efficient.\n\nCan I do better?\n\nThanks in advance!\n    ", "Answer": "\r\nYou can verify if all d[v]'s are correct by using the following property that has to hold for each node v:\nThe shortest path from s to v has to go via the neighbour n of v for\nwhich d[n] + the cost to get from n to v is the smallest.\nSo you can just perform the following pseudo code, which runs in O(E) where E is the number of edges.\n```\nforall v from G:\n    if(min(d[n] + w(n, v) | forall n from incoming_neighbours(v)) != d[v]):\n         //something is wrong\n```\n\nw(n, v) is the weight between node n and v.\nHowever, if you find an error in your d[v]'s using this method you cannot infer which ones are incorrect. In this case, as already mentioned in the comments you will have to preform Bellman-Ford.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Code on Weighted, Acyclic Graph\r\n                \r\nWe have a Code on Weighted, Acyclic Graph ```\nG(V, E)```\n with positive and negative edges. we change the weight of this graph with following code, to give a ```\nG```\n without negative edge ```\n(G')```\n. if ```\nV={1,2...,n}```\n and ```\nG_ij```\n be a weight of edge i to edge j.\n\n```\nChange_weight(G)\nfor t=1 to n\n   for j=1 to n\n\n      G_i=min G_ij for All K\n      if G_i < 0  (we have a bar on G) \n          G_ij = G_ij+G_i  for all j\n          G_ki = G_ki+G_i  for all k\n```\n\n\nWe have two axioms:\n\n```\n1) the shortest path between every two vertex in G is the same as G'.\n\n2)  the length of shortest path between every two vertex in G is the same as G'.\n```\n\n\ni read one pdf that has low quality, i'm not sure the code exactly mentioned, and add the picture. in this book he say the above axioms is false, anyone could help me? i think these are true?\n\n\ni think two is false as following counter example, the original graph is given in left, and after the algorithm is run, the result is in right the shortest path between 1 to 3 changed, it passed from vertex 2 but after the algorithm is run it never passed from vertex 2.\n\n    ", "Answer": "\r\nAlgorithm\n\nMy reading of the PDF is:\n\n```\nChange_weight(G)\nfor i=i to n\n   for j=1 to n\n\n      c_i=min c_ij for all j\n      if c_i < 0 \n          c_ij = c_ij-c_i  for all j\n          c_ki = c_ki+c_i  for all k\n```\n\n\nThe interpretation is that for each vertex we increase its outgoing edges by c_i, and decrease the incoming edges by c_i, where c_i is chosen such that all outgoing edges become non-negative.\n\nClaim 1\n\n\"the shortest path between every two vertex in G is the same as G'\"\n\nWith my reading of the pdf, this claim is true because every path between vertices i and j is changed by the same amount (c_i-c_j) and so the relative order of paths is unchanged.  (Note that the path may go via intermediate vertices, but the net effect is 0 because for each intermediate vertex k we decrease the length by c_k when entering, but increase by c_k when exiting.) \n\nClaim 2\n\n\"the length of shortest path between every two vertex in G is the same as G'\".\n\nThis cannot be true - suppose we start with an original graph which has a single edge A to B with weight -1.\nIn the modified graph this weight will become 0.\n\nTherefore the length of the shortest path has changed from -1 in G to 0 in G' so the statement is false.\n\nExample\n\nShown below is what would happen to your graph as you applied this algorithm to node 1, followed by node 2:\n\n\n\nTopological sort\n\nNote that as shown in the example, we still end up with some negative weights which is probably unintended.  This is because the weights of incoming edges are reduced.\n\nHowever, if we work backwards through the graph (e.g. by using a topological sort), then we will always end up with non-negative weights everywhere.\n\nIn the given example, working backwards means we first update 2, and then 1 as shown below:\n\n\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "How to receive the complete path from Networkx shortest path algorithms\r\n                \r\nI am using ```\nfloyd_warshall_predecessor_and_distance```\n function of ```\nNetworkx```\n in Python 3 to find the shortest path on a bidirected graph. The function returns the shortest distance between given two nodes (if there exist an edge) and a portion of the path. I will clarify what I mean by saying \"a portion.\" Following is my input and output.\n\nInput:\n\n```\nimport networkx as nx\nimport numpy as np\nimport matplotlib.pyplot as plt\nnp.random.seed(0)\nV = [1, 2, 3, 4, 5]\nN = [(i,j) for i in V for j in V if i!=j]\nE = {} #Creating an empty dictionary to store the travel times from node i to j\nElist = (list(np.random.randint(low=1, high = 30, size = len(N))))\nfor i in range(len(N)):\n    E[N[i]] = Elist[i] # (i,j) does not have to be equal to (j,i)\nE[(2, 1)] = 5\nE[(5, 4)] = 0\nE[(2, 4)] = 20\nG=nx.DiGraph()\nG.add_nodes_from(V)\nfor i in E:\n    G.add_weighted_edges_from([(i[0], i[1], E[i])])\npath_lengths=nx.floyd_warshall_predecessor_and_distance(G, weight='weight')\npath_lengths\n```\n\n\nOutput:\n\n```\n({1: {2: 1, 3: 4, 4: 5, 5: 1},\n  2: {1: 2, 3: 4, 4: 5, 5: 1},\n  3: {1: 3, 2: 3, 4: 5, 5: 1},\n  4: {1: 4, 2: 1, 3: 4, 5: 1},\n  5: {1: 4, 2: 5, 3: 4, 4: 5}},\n {1: defaultdict(<function networkx.algorithms.shortest_paths.dense.floyd_warshall_predecessor_and_distance.<locals>.<lambda>.<locals>.<lambda>()>,\n              {1: 0, 2: 13, 3: 8, 4: 1, 5: 1}),\n  2: defaultdict(<function networkx.algorithms.shortest_paths.dense.floyd_warshall_predecessor_and_distance.<locals>.<lambda>.<locals>.<lambda>()>,\n              {2: 0, 1: 5, 3: 13, 4: 6, 5: 6}),\n  3: defaultdict(<function networkx.algorithms.shortest_paths.dense.floyd_warshall_predecessor_and_distance.<locals>.<lambda>.<locals>.<lambda>()>,\n              {3: 0, 1: 10, 2: 20, 4: 11, 5: 11}),\n  4: defaultdict(<function networkx.algorithms.shortest_paths.dense.floyd_warshall_predecessor_and_distance.<locals>.<lambda>.<locals>.<lambda>()>,\n              {4: 0, 1: 5, 2: 18, 3: 7, 5: 6}),\n  5: defaultdict(<function networkx.algorithms.shortest_paths.dense.floyd_warshall_predecessor_and_distance.<locals>.<lambda>.<locals>.<lambda>()>,\n              {5: 0, 1: 5, 2: 13, 3: 7, 4: 0})})\n```\n\n\nI intentionally made a path for (2, 4) which is 2 > 1 > 5 > 4. When I look at ```\npath_lengths[0]```\n, I can see that to go from nodes 2 to 4, I stopped by 5. Further, to go from 2 to 5, I stopped by 1. These two tells me the complete route, but I want to see the whole route as an output, e.g., ```\n2: {... 4: 1, 5, ...}```\n or ```\n{(2,4): (2,1), (1,5), (5,4)}```\n rather than seeing it in portion and then combining the pieces in mind. Is there any better package in Networkx that can possibly do this? By the way, my bidirected graph does not involve negative weights and the graph can be quite large (which is why I chose this function).\n\nHere is my attempt to begin:\n\n```\nnew = path_lengths[0]\nfor v in V:\n    for d in V:\n        if v!=d:\n            if new[v][d] != v:\n                new[v][d] = (new[v][d],d)\n            elif new[v][d] == v:\n                new[v][d] = (v,d)\n```\n\n\nThanks for responses!\n    ", "Answer": "\r\nI found the solution to the problem. The following code creates two dictionaries. For ```\npaths```\n, the keys denote the arcs and the values show the consecutive arcs needed to be taken for the shortest path. For ```\nshortest_distance```\n, the keys denote the arcs and the values show the shortest distance. I am leaving this here for future reference.\n\nInput:\n\n```\ndef arcs(seq, n):\n    return [seq[max(i, 0):i + n] for i in range(-n + 1, len(seq))]\npaths = {}; shortest_distance = {}\nfor v in V:\n    for d in V:\n        if v!=d:\n            path = nx.single_source_dijkstra_path(G,v)\n            paths[(v,d)] = path[d]\nfor i in paths:\n    paths[i] = (arcs(paths[i],2)[1:-1])\n    shortest_distance[(i[0],i[1])] = path_lengths[1][i[0]][i[1]]\n    for j in range(len(paths[i])):\n        paths[i][j] = tuple(paths[i][j])    \nfor i in paths:\n    print(i, paths[i], shortest_distance[i])\n```\n\n\nOutput:\n\n```\n(1, 2) [(1, 2)] 13\n(1, 3) [(1, 5), (5, 4), (4, 3)] 8\n(1, 4) [(1, 5), (5, 4)] 1\n(1, 5) [(1, 5)] 1\n(2, 1) [(2, 1)] 5\n(2, 3) [(2, 1), (1, 5), (5, 4), (4, 3)] 13\n(2, 4) [(2, 1), (1, 5), (5, 4)] 6\n(2, 5) [(2, 1), (1, 5)] 6\n(3, 1) [(3, 1)] 10\n(3, 2) [(3, 2)] 20\n(3, 4) [(3, 1), (1, 5), (5, 4)] 11\n(3, 5) [(3, 1), (1, 5)] 11\n(4, 1) [(4, 1)] 5\n(4, 2) [(4, 1), (1, 2)] 18\n(4, 3) [(4, 3)] 7\n(4, 5) [(4, 1), (1, 5)] 6\n(5, 1) [(5, 4), (4, 1)] 5\n(5, 2) [(5, 2)] 13\n(5, 3) [(5, 4), (4, 3)] 7\n(5, 4) [(5, 4)] 0\n```\n\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Finding shortest circuit in a graph that visits X nodes at least once\r\n                \r\nEven though I'm still a beginner, I love solving graph related problems (shortest path, searches, etc). Recently I faced a problem like this : \n\n\n  Given a non-directed, weighted (no negative values) graph with N nodes and E edges (a maximum of 1 edge between two nodes, an edge can only be placed between two different nodes) and a list of X nodes that you must visit, find the shortest path that starts from node 0, visits all X nodes and returns to node 0. There's always at least one path connecting any two nodes.\n  \n  Limits are 1 <= N <= 40 000 / 1 <= X <= 15 / 1 <= E <= 50 000\n\n\nHere's an example : \n\n\n\nThe red node ( 0 ) should be the start and finish of the path. You must visit all blue nodes (1,2,3,4) and return. The shortest path here would be : \n\n\n  0 -> 3 -> 4 -> 3 -> 2 -> 1 -> 0 with a total cost of 30\n\n\nI thought about using Dijkstra to find the shortest path between all X (blue) nodes and then just greedy picking the closest unvisited X (blue) node, but it doesn't work (comes up with 32 instead of 30 on paper). Also I later noticed that just finding the shortest path between all pairs of X nodes will take O(X*N^2) time which is too big with so much nodes.\n\nThe only thing I could find for circuits was Eulerian circuit that only allows visiting each node once (and I don't need that). Is this solveable with Dijkstra or is there any other algorithm that could solve this?\n    ", "Answer": "\r\nHere is a solution which likely to be fast enough:\n1)Run shortest path search algorithm from every blue node(this can be done in O(X * (E log N))) to compute pairwise distances.\n2)Build a new graph with zero vertex and blue vertices only(X + 1 vertices). Add edges using pairwise distances computed during the first step.\n3)The new graph is small enough to use dynamic programming solution for TSP(it has O(X^2 * 2^X) time complexity).\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Why can't Bellman-Ford be used for Single Source Longest Path?\r\n                \r\nDijkstra's cannot be used for longest path because it uses the property that the current shortest path will be for sure shorter than one of the other paths. This is correct, of course, assuming there are no negative edge weights. This concept is also why longest path doesn't work on Dijkstra, because the current longest path doesn't guarantee that there won't be another longer path that takes a larger value later on.\nOn the other hand, Bellman Ford offers the the flexibility of negative weights at a worse performance. This means that for Bellman Ford, so it doesn't work on the same greedy property as Dijkstra. So that's why I'm confused - why can't Bellman Ford be used on the Single Source Longest Path problem(NP hard)? For example, we can simply multiply all the weights of a graph by -1 and find the shortest path, which would be the longest path of the original graph.\n    ", "Answer": "\r\nBellman–Ford allows arcs to be reused (otherwise there would be a well defined shortest path even in the presence of negative cycles), whereas the Single Source Longest Path problem derives its NP-hardness from the fact that it does not (otherwise you could just use Bellman–Ford after multiplying all of the weights by −1).\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Algorithm to Solve Constrained Longest Path Problem\r\n                \r\nI am a matrix that represents the shortest path between any two nodes, which I compute from a weighted adjacency matrix using Floyd Warshall algorithm. Additionally, I have a constant maximum weight. My goal is to find the path that maximizes the number of vertices visited, while enforcing that the final total path weight is less than or equal to the weight limit. One option would be to generate all permutations, but this would be exponential time, no?\nAnother thought was to apply dynamic programming with subproblems defined as the max number of nodes from met from node i to node j subject to the constraint. Finally, I thought to reduce this to a linear programming problem with variables equal to edges. Then, would it be equivalent to the kidney exchange problem? After I check that there are no negative cycles, does this imply that there will be no cycles in the final optimal path? Please let me know if I can clarify any part of the problem.\nI create the shortest path matrix with the following function:\n```\ndef floyd_warshall(G):\n    n = len(G)\n\n    # run a modified Bellman-Ford's algorithm on `G`\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                # if better path is found, relax\n                if G[i][j] > G[i][k] + G[k][j]:\n                    G[i][j] = G[i][k] + G[k][j]\n    return G\n```\n\n    ", "Answer": "", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "an algorithm to choose the best edge to reinsert after deleting [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 7 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nLet G = (V, E) be a connected directed graph with non-negative edge weights, let s and t be vertices of G, and let H be a subgraph of G obtained by deleting some edges. Suppose we want to reinsert exactly one edge from G back into H, so that the shortest path from s to t in the resulting graph is as short as possible. Describe and analyze an algorithm to choose the best edge to reinsert.\n\nI think it need to be used with bellman-ford algorithm for every edge we deleting,\nand then find the shortest path from all.. \nbut the running time of this is too big.. anyone has anthoer idea? \nthanks :)\n    ", "Answer": "\r\nLet e[1] = (u[1],v[1]), e[2] = (u[2],v[2]), ..., e[N] = (u[N], v[N]) be the edges removed from G to get H.\n\nRun Dijkstra's algorithm on H starting from s, keeping track of the cost of the shortest path to each of {u[1], u[2], ..., u[N]}, which we will call A(n) for each node n.\n\nRun Dijkstra's algorithm on H with all edges reversed starting from t, keeping track of the cost of the shortest path to each of {v[1], v[2], ..., v[N]}, which we will call B(n) for each node n.\n\nThen the best single edge to reinsert into H is the edge i such that A(u[i]) + c(e[i]) + B(v[i]) is minimized.\n\nThis algorithm runs Dijkstra's algorithm twice, so the complexity of that part is O(|E| + |V|log|V|) where |E| is the number of edges and |V| is the number of nodes.\n\n(I have intentionally ignored the trivial cases of the shortest path from s to t not involving any of the removed edges or no path from s to t existing. They won't cause any problems for the general approach, but you'd need to pay attention to them in an implementation.)\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Manhattan tourist\r\n                \r\nIn my algorithms and datastructures class I have been asked to implement the Manhattan tourist problem using dynamic programming.\nI have come to a solution using a combination of dynamic programming and recursive calls, but I seem to get \"Time limit exceeded\" when putting it to the test on CodeJudge. I haven't been able to figure out why my code isn't fast enough. Any takers?\nBest regards.\nDescription of the problem:\nYour are helping the tourist guide company \"Manhattan Tourists\", that are arranging\nguided tours of the city. They want to find a walk between two points on the map that is both interesting and short. The map is a square grid graph. The square grid graph has n rows with n nodes in each row. Let node vi,j denote the jth node on row i. For 1≤I<n and for 1≤j≤n node vi,j is connected to vi+1, j. And for 1≤i≤n and for 1 ≤ j < n node vi,j is connected to vi,j+1. The edges have non-negative edge weights that indicate how interesting that street is. See the graph below for an example of a 5 × 5 grid graph.\nThey want to find a short interesting walk from the upper left corner (s = v1,1) to the lower right corner (t = vn,n). More precisely, they want to find a path with the possible smallest number of edges, and among all paths with this number of edges they want the path with the maximum weight (the weight of a path is the sum of weights on the path).\nAll shortest paths have 2n − 2 edges and go from s to t by walking either down or right in each step. In the example below two possible shortest paths (of length 8) are indicated. The dashed path has weigth 38 and the dotted path has weight 30.\nLet W [i, j] be the maximal weight you can get when walking from s to vi, j walking either down or right in each step. Let D[i, j] be the weight of the edge going down from vi, j and let R[i, j] be the weight of the edge going right from vi,j.\nDescription on CodeJudge:\nExercise\nBefore you can solve this exercise, you must first read, understand and (partly) solve the problem Manhattan Tourists described on the weekplan.\nYour task here is to implement your solution. Read the input/output specification below and look at the sample test data in order to learn how to read the input and write the output.\nInput format\n\nLine 1: The integer n (1<= n <= 1000).\nLine 2..n+1: the n rows of R, each consisting of n-1 integers separated by space.\nLine n+2..2n: the n-1 rows of D, each consisting of n integers separated by space.\n\nOutput format:\nLine 1: The maximum interest score of a shortest walk.\nHeres my code so far:\n```\npublic static void main(String[] args) {\n    Scanner console = new Scanner(System.in);\n    int n = console.nextInt();\n    \n    int[][] R = new int[n][n-1];\n    int[][] D = new int[n-1][n];\n    \n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n-1; j++) {\n            R[i][j] = console.nextInt();\n        }\n    }\n    for(int i = 0; i < n-1; i++) {\n        for(int j = 0; j < n; j++) {\n            D[i][j] = console.nextInt();\n        }\n    }\n    \n    System.out.println(opt(R, D, n, n-1, n-1));\n}\n\npublic static int opt(int[][]R, int[][]D, int n, int i, int j) {\n    int[][] result = new int[n][n];\n    \n    if(i==0 && j==0) {\n        if(result[i][j] == 0) {\n            result[i][j] = 0;\n        }\n        return result[i][j];\n        \n    } else if(i == 0) {\n        if(result[i][j] == 0) {\n            result[i][j] = opt(R,D,n,i,j-1) + R[i][j-1];\n        }\n        return result[i][j];\n        \n    }else if(j == 0) {\n        if(result[i][j] == 0) {\n            result[i][j] = opt(R,D,n,i-1,j) + D[i-1][j];\n        }\n        return result[i][j];\n        \n    }else if(result[i][j] == 0) {\n        result[i][j] = max(opt(R, D, n, i, j-1) + R[i][j-1],opt(R, D, n, i-1, j) + D[i-1][j]);\n    }\n    \n    return result[i][j];\n}\n\n\npublic static int max(int i, int j) {\n    if(i > j) {\n        return i;\n    }\n    return j;\n}\n```\n\n}\n    ", "Answer": "\r\nWhy a recursion?\nThe topmost row can be traversed horizontally only. So, for each vertex in the first row the total weight is a sum of weights of branches to the left. You can compute all of them in a single loop as a running total across the row.\nFor each next row the total weight of the first vertex is a weight of the vertex above it plus the weight of the branch between them. And the total weight of each next vertex in the row is the bigger one from two possible when coming from above or from left.\nAll that can be computed iteratively with two nested loops.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Re-modelling maxflow-mincost to lose negative edge weights\r\n                \r\nLet's say I have a problem simplified as following:\n\n\n  \"A producer ```\nPi```\n can produce a certain amount ```\nai```\n of items at cost ```\nci```\n per item. A consumer ```\nCk```\n can consume an amount ```\nbk```\n at a profit of ```\npk```\n per item.\n\n\nAnd we're interested in the maxflow with maximum gain / minimum loss and we intend to get that by using either BGL's successive_shortest_path_nonnegative_weights or its cycle_canceling.\n\nWe should be able to model this by connecting source ```\nS```\n to each ```\nPi```\n with an edge of capacity ```\nai```\n and a weight of ```\nci```\n.\n\nWe then connect each ```\nPi```\n to every ```\nCk```\n with an edge of capacity ```\nbk```\n and weight ```\n-pk```\n.\n\nLastly, we connect each ```\nCk```\n to target ```\nT```\n with an edge of capacity ```\nbk```\n and cost ```\n0```\n.\n\nAfter running cycle_canceling on that graph, we can get two values: ```\nmaxflow```\n will yield the maximum units sold and ```\n-mincost```\n will represent total gain/loss.\n\nWe obviously cannot use successive_shortest_path_nonnegative_weights because - well, the name already states it.\n\nIt has been brought to my attention, though, that cycle_canceling is much slower than the successive_shortest_path approach and that by re-formulating the problem, we can get rid of the negative weights.\n\nHowever, I'm not sure how to re-design this. We obviously cannot simply add a constant to all edge weights because that could change a shortest path and thereby falsify the result. Yet we must somehow reflect the fact that taking certain edges adds to the total costs, whereas taking others subtracts from them.\n\nAny hints?\n    ", "Answer": "\r\nThis is a weird problem for min-cost max flow. Better to sort the producers by cost increasing, sort the consumers by profit decreasing, and then repeatedly have the first residual producer send to the first residual consumer as long as there would be benefit. If you want to get super fancy, there's an O(n)-time algorithm that resembles your favorite median-finding algorithm.\n\nEDIT: Because there are hidden reasons to use min-cost max flow (please don't make a habit of this; algorithm design is especially prone to the XY problem), what you can do is reweight the arcs as follows (this is a standard trick, used in, e.g., Johnson's algorithm).\n\nUse an algorithm (e.g., Bellman--Ford) that can handle negative weights to compute distances d(v) from S to each vertex v. Now, update the weight w(u->v) of arc u->v to d(u) + w(u->v) - d(v), which is guaranteed non-negative, while the total relative weight of each path from S to T remains unchanged up to an additive constant (the d terms telescope).\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Calculate shortest path in networkx using edge cost function\r\n                \r\nI would like to use networkx to calculate energy-efficient routes. To do that I thought about modelling battery constraints as edge cost functions. In the example below, I would like to calculate the shortest route between s and t depending of the battery load of my vehicle (```\nb```\n). The constraints of my network will determine the edge cost function.\nFor example between ```\ns```\n and ```\nv1```\n, the edge cost will be 18 if the battery load at ```\ns```\n is superior to 18 or (close to infinite) if it is less than 18.\nIs it possible to define edge cost functions that will be used by shortest path algorithms in networkx?\n\nOr do you think the best solution would be to create a new MultiDiGraph where all the different possible edge costs are recalculated according to the initial charge at the starting point?\nEdit 1:\nTo simplify the problem we can consider the negative weights (corresponding to a recharge of the battery) as equal to zero. In a second time, I will see how to use Johnson's algorithm. It seems to be implemented in networkx (https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.shortest_paths.weighted.johnson.html)\nEdit 2:\nThe maximal battery load is 20 which explains why the battery load didn't increase between s and v_3 and why it is impossible to reach t through s->v3->v2\n    ", "Answer": "\r\n\nAssume an initial battery level infinity.\nSearch the resulting calculated costs for the most negative.\nAdd absolute value of most negative cost ( X ) to cost of every link.\nRun Dijsktra's algorithm to find lowest cost from source to distance.\nSubtract X from path cost ( P - X )\nIf initial battery level greater than ( P - X ) then destination is reachable.\n\nFor example\n```\nC:\\Users\\James\\code\\PathFinder\\bin>gui\nl s v1 38\nl s v3 0\nl v1 v2 0\nl v3 v2 38\nl v2 t 23\ns s\ne t\n\ns -> v3 -> v2 -> t ->\n```\n\n( PathFinder is a C++ wrapper for the boost::graph impementation of Dijsktra )\nSo, now we have a new previously hidden constraint that the battery capacity has a maximum of 20.  So I propose another aproach which should be proof against any further constraints that might pop up.  It is based on the ideas of the A* algorithm\n\nReformulate the problem so that the recharging stations are at nodes and the links betwen the recharging stations have constant positive costs.  ( This seems to me a more natural model of the real world )\n\nUse Dijsktra, considering only link costs, to find the cheapest path to the destination from every node connected to the current done ( initially the starting node )\n\nFor every node connected to the current, sum the cost of the link from the current, the cost to the destination calculated in 1 minus any recharging that the node offers.\n\nFrom every node that has been costed in 3, choose the cheapest.  Keep track of the path used to reach this node and make it the current.\n\nRepeat from step 2 until the destination node is reached.\n\n\nThis is a very specialised problem, ao I will not be adding it to the PathFinder options.  If it represents a serious real world problem, not just homework or an acedemic exerise, open a issue on the PathFinder github repository and we can discuss details of developing a one-off application for this.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "algorithm to solve the replacement paths problem for specific situations\r\n                \r\nI have to solve this problem and it has been bugging me for hours and I can't seem to find a valid solution that satisfies the time complexity required.\n\nFor any edge e in any graph G, let G\\e denote the graph obtained by deleting e from G. \n\n(a)Suppose we are given an edge-weighted directed graph G in which the shortest path σ from vertex s to vertex t passes through every vertex of G. Describe an algorithm to compute the shortest-path distance from s to t in G\\e, for every edge e of G, in O(VlogV) time. Your algorithm should output a set of E shortest-path distances,one for each edge of the input graph. You may assume that all edge weights are non-negative.[Hint: If we delete an edge of the original shortest path, how do the old and new shortest paths overlap?\n\n(b) Describe an algorithm to solve the replacement paths problem for arbitrary undirected graphs in O(V log V ) time.\n    ", "Answer": "\r\na) Consider the shortest path P between vertices s and t. Since P is a shortest path, there is no edge between any two vertices u and v in P in which the length of shortest path between u and v is bigger than 1 in the induced graph P. Since every vertex in G is present in P, So every edge of G is present in the induced graph of P. So we conclude that every edge in G is between two adjacent vertices in P (not the induced graph of P). The only thing you should check for each edge e which connects vertices u and v in G, is that there is another edge which connects u and v in G. If so, the shortest path doesn't change in G/e, otherwise s and t will lie on different components.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Check if all paths from a vertex v to another vertex w are of the same length\r\n                \r\nI have a connected graph ```\ng```\n with ```\nn```\n vertices and ```\nm```\n edges. \n\nEach edge can be traversed from both directions, while traversing them in one direction their weight is positive, traverse them in the other direction and their weight is negative.\n\nSo for every edge ```\nu```\n -> ```\nv```\n with weight ```\nw```\n there exists an edge ```\nv```\n -> ```\nu```\n with weight ```\n-w```\n.\n\nMy goal:\n\nFor a given vertex ```\nv```\n, check if there exists a path back to ```\nv```\n (a cycle) so that the sum of the edge weights of that path is not equal to ```\n0```\n. If such a path exists then output the minimal number of edges of such a path, otherwise output ```\n\"all cycles are fine\"```\n.\n\nExamples:\n\nAn example where all paths from ```\nv```\n to ```\nv```\n sum up to ```\n0```\n. The output is ```\n\"all cycles are fine\"```\n:\n\n\n\nAn example where there exist paths from ```\nv```\n to ```\nv```\n whose edges sum up to something which isn't equal to ```\n0```\n. The minimal number of edges of such a path is 4 in this example:\n\n\n\nMy current approach:\n\nThe problem seems to be equivalent to checking if all paths from a given vertex ```\nv```\n to any other vertex ```\nw```\n are of equal length, if this is true then \"all cycles are fine\", otherwise I output the length of the shortest cycle which breaks the condition. I have trouble finding an efficient algorithm for testing this condition.\n    ", "Answer": "\r\nA simple algorithm to check if there exists a \"wrong cycle\" that passes through a vertex A is to run a BFS from A, then see which vertices B are visited at least twice with different costs. If no B exists, then all cycles are good, otherwise there is a bad cycle with size (edges until first visit to B) + (edges until visit to B with a different cost). This BFS visits every vertex at most twice, so the complexity is still linear.\n\nTherefore, this problem could be solved with a BFS from every vertex in the graph. Of course, maybe this can be made more efficient; what is adequate depends on the sizes of n and m. \n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "How can i find the cheapest way in a DAG if i have limited money?\r\n                \r\nSo, if i have an Directed Acyclic Graph where the cost of each edge either 0 or more than 0, if its more than 0 it will have a negative-weight (So you can by it for 5$ and it will shorten your way by -20 for example). \n\nI know that we can easily find a shortest/cheapest way in a DAG, but what if we have limited money? \n\nSo imagine the next situation:\n\n\n\nWe have 8 money.The algorithm would find the shortest path which is -10+-3= -13, but it would cost 12 but we only have 8 money, so its not an option. The ideal path would be -10+0 which only costs 7 money.\nIs there an algorithm which i can use to solve this problem?\n    ", "Answer": "\r\nThis problem is NP-Hard, with a reduction from Knapsack-Problem.\n\nShort intuitive \"proof\": The idea is, create a vertex for each item - you can either \"take it\" or \"not take it\" by choosing the vertex with the cost or the \"free\" vertex.\n\nSketch:\n\n\n\nIn the above you can see, from the Knapsack Problem, create a graph, for each item, you can choose to take it - and pay the cost and gain the \"value\", or ignore it.\n\nMore formally:\n\nGiven an instance of knapsack with ```\nweights=w1,w2,w3,...cn```\n and ```\ncost=c1,c2,..,cn```\n, with some maximal weight ```\nW```\n, create a graph ```\nG=(V,E)```\n with \n\n```\nV= { V_i,U_i,W_i | i=0,...n }\nE= { (W_i,V_i+1,U_i+1 | i=0,...,n-1} U {(V_i,W_i+1), (U_i,W_i+1) | i=0,...,n-1 }\n\nvalue(W_i,V_i+1) = c_i+1\nmoney(W_i,V_i+1) = w_i+1\nvalue(W_i,U_i+1) = 0\nmoney(W_i,U_i+1) = 0\nmoney(V_i,W_i+1) = cost(V_i,W_i+1) = money(U_i,W_i+1) = cost(U_i,W_i+1) = 0\n```\n\n\nThe solution to this problem that uses at most W money, will be also the solution for knapsack with maximal capacity of W.\n\n\n\nA possible pseudo polynomial solution could be (using Dynamic Programming technique):\n\n```\nD(start,0) = 0\nD(v,x) = infinity     x < 0\nD(v,x) = min { D(u,x-money(u,v)) + value(u,v) | for each edge (u,v) } U {infinity}\n```\n\n\nIn the above ```\nD(v,x)```\n is the minimal distance needed to travel from the start node to ```\nv```\n, paying exactly ```\nx```\n money.\n\nNote that it can be done because it's a DAG, so you can calculate the values from first to last according to the graph's topological sort.\n\nWhen done, you need to search all values of ```\nx```\n from ```\n0```\n to ```\nMAXIMAL_AMOUNT_OF_MONEY_ALLOWED```\n to find the minimal value of ```\nD(target,x)```\n, and that's the answer.\nFinding the actual cost is done by retracing back your steps, as done in other Dynamic Programming solutions.\n\nThe above run time is ```\nO(|V|*MAX_MONEY + |E|)```\n\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Find Two vertices with lowest path weight\r\n                \r\nI am trying to solve this question but got stuck.\nNeed some help,Thanks.\n\nGiven an undirected Connected graph G with non-negative values at edges.\nLet A be a subgroup of V(G), where V(G) is the group of vertices  in G.  \n\n-Find a pair of vertices (a,b) that belongs to A, such that the weight of the shortest path between them in G is minimal, in O((E+V)*log(v)))\n\nI got the idea of using Dijkstra's algorithm in each node which will give me O(V*((E+V)logv))),which is too much.\nSo thought about connecting the vertices in A somehow,did'nt find any useful way.\nAlso tried changing the way Dijkstra's algorithm work,But it get's to hard to prove with no improvment in time complexity.\n    ", "Answer": "\r\nNote that if the optimal pair is ```\n(a, b)```\n, then from every node ```\nu```\n in the optimal path, ```\na```\n and ```\nb```\n are the closest two nodes in ```\nA```\n.\n\nI believe we should extend Dijkstra's algorithm in the following manners:\n\n\nStart with all nodes in ```\nA```\n, instead of a single ```\nsource_node```\n.\nFor each node, don't just remember the ```\nshortest_distance```\n and the ```\nprevious_node```\n, but also the ```\nclosest_source_node```\n to remember which node in ```\nA```\n gave the shortest distance.\nAlso, for each node, remember the ```\nsecond_shortest_distance```\n, the ```\nsecond_closest_source_node```\n, and ```\nprevious_for_second_closest_source_node```\n (shorter name suggestions are welcome). Make sure that ```\nsecond_closest_source_node```\n is never the ```\nclosest_source_node```\n. Also, think carefully about how you update these variables, the optimal path for a node can become part of the second best path for it's neighbour.\nVisit the entire graph, don't just stop at the first node whose ```\nclosest_source```\n and ```\nsecond_closest_source```\n are found.\nOnce the entire graph is covered, search for the node whose ```\nshortest_distance + second_shortest_distance```\n is smallest.\n\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Route problem in a graph: minimize average edge cost instead of total cost\r\n                \r\nI have a weighted graph, no negative weights, and I would like to find the path from one node to another, trying to minimize the cost for the single step. I don't need to minimize the total cost of the trip (as e.g. Dijkstra does) but the average step-cost. However, I have a constraint: K, the maximum number of nodes in the path.\n\nSo for example to go from A to J maybe Dijkstra would find this path (between parenthesis the weight)\n\n```\nA (4) D (6) J -> total cost: 10\n```\n\n\nand the algorithm I need, setting K = 10, would find something like\n\n```\nA (1) B (2) C (2) D (1) E (3) F (2) G (1) H (3) J -> total cost: 15\n```\n\n\nIs there any well known algorithm for this problem?\n\nThanks in advance.\n\nEugenio\n\nEdit as answer to templatetypedef.\nSome questions:\n\n1) The fact that it can happen to take a cycle multiple times to drive down the average is not good for my problem: maybe I should have mentioned it but I don' want to visit the same node more than once\n\n2) Is it possible to exploit the fact that I don't have negative weights?\n\n3) When you said O(kE) you meant for the whole algorithm or just for the additional part?\n\nLet's take this simple implementation in C where n=number of nodes e=number of edges, d is a vector with the distances, p a vector with the predecessor and a structure edges (u,v,w) memorize the edges in the graphs\n\n```\nfor (i = 0; i < n; ++i)\n    d[i] = INFINITY;\n\n    d[s] = 0;\n\n    for (i = 0; i < n - 1; ++i)\n        for (j = 0; j < e; ++j)\n            if (d[edges[j].u] + edges[j].w < d[edges[j].v]){\n                d[edges[j].v] = d[edges[j].u] + edges[j].w;\n                p[edges[j].v] = u;\n                }\n```\n\n\nI'm not sure how I should modify the code according to your answer; to take into consideration the average instead of the total cost should this be enough?\n\n```\nfor (i = 0; i < n; ++i)\n        d[i] = INFINITY;\n\n    d[s] = 0;\n\n    for (i = 0; i < n - 1; ++i)\n        steps = 0;\n        for (j = 0; j < e; ++j)\n            if ( (d[edges[j].u]+ edges[j].w)/(steps+1) < d[edges[j].v]/steps){\n                d[edges[j].v] = d[edges[j].u] + edges[j].w;\n                p[edges[j].v] = u;\n                steps++;\n            }\n```\n\n\nBut anyway I don't know how take into consideration the K limit at the same time...Thanks again in advance for your help.\n\nEdit\nSince I can afford some errors I'm thinking about this naif solution:\n\n\nprecompute all the shortest paths and memorize in A\nprecompute all the shortest paths on a modified graph, where I cut the edges over a certain weight and memorize them in B\n\n\nWhen I need a path, I look in A, e.g. from x to y this is the path\nx->z->y\nthen for each step I look in B,\nso for x > z I see if there is a connection in B, if not I keep x > z otherwise I fill the path x > z with the subpath provided by B, that could be something like x->j->h->z; then I do the same for z->y.\nEach time I will also check if I'm adding a cyclic path.\n\nMaybe I will get some weird paths but it could work in most of the case.\nIf I extend the solution trying with different \"cut thresholds\" maybe I can also be close to respect the K constrain.\n    ", "Answer": "\r\nI believe that you can solve this using a modified version of the Bellman-Ford algorithm.\n\nBellman-Ford is based on the following dynamic programming recurrence that tries to find the shortest path from some start node s to each other node that's of length no greater than m for some m.  As a base case, when you consider paths of length zero, the only reachable node is s and the initial values are\n\n```\nBF(s, t, 0) = infinity\nBF(s, s, 0) = 0\n```\n\n\nThen, if we know the values for a path of length m, we can find it for paths of length m + 1 by noting that the old path may still be valid, or we want to extend some path by length one:\n\n```\nBF(s, t, m + 1) = min {\n                     BF(s, t, m),\n                     BF(s, u, m) + d(u, t) for any node u connected to t\n                   }\n```\n\n\nThe algorithm as a whole works by noting that any shortest path must have length no greater than n and then using the above recurrence and dynamic programming to compute the value of BF(s, t, n) for all t.  Its overall runtime is O(EV), since there are E edges to consider at each step and V total vertices.\n\nLet's see how we can change this algorithm to solve your problem.  First, to limit this to paths of length k, we can just cut off the Bellman-Ford iteration after finding all shortest paths of length up to k.  To find the path with lowest average cost is a bit trickier.  At each point, we'll track two quantities - the length of the shortest path reaching a node t and the average length of that path.  When considering new paths that can reach t, our options are to either keep the earlier path we found (whose cost is given by the shortest path so far divided by the number of nodes in it) or to extend some other path by one step. The new cost of that path is then given by the total cost from before plus the edge length divided by the number of edges in the old path plus one.  If we take the cheapest of these and then record both its cost and number of edges, at the end we will have computed the path with lowest average cost of length no greater than k in time O(kE).  As an initialization, we will say that the path from the start node to itself has length 0 and average cost 0 (the average cost doesn't matter, since whenever we multiply it by the number of edges we get 0).  We will also say that every other node is at distance infinity by saying that the average cost of an edge is infinity and that the number of edges is one.  That way, if we ever try computing the cost of a path formed by extending the path, it will appear to have average cost infinity and won't be chosen.\n\nMathematically, the solution looks like this.  At each point we store the average edge cost and the total number of edges at each node:\n\n```\nBF(s, t, 0).edges = 1\nBF(s, t, 0).cost  = infinity\n\nBF(s, s, 0).edges = 0\nBF(s, s, 0).cost  = 0\n\nBF(s, t, m + 1).cost = min {\n    BF(s, t, m).cost,\n    (BF(s, u, m).cost * BF(s, u, m).edges + d(u, t)) / (BF(s, u, m).edges + 1)\n}\n\nBF(s, t, m + 1).edges = {\n    BF(s, t, m).edges         if you chose the first option above. \n    BF(s, u, m).edges + 1     else, where u is as above\n}\n```\n\n\nNote that this may not find a simple path of length k, since minimizing the average cost might require you to take a cycle with low (positive or negative) cost multiple times to drive down the average.  For example, if a graph has a cost-zero loop, you should just keep taking it as many times as you can.\n\nEDIT: In response to your new questions, this approach won't work if you don't want to duplicate nodes on a path.  As @comestibles has pointed out, this version of the problem is NP-hard, so unless P = NP you shouldn't expect to find any good polynomial-time algorithm for this problem.\n\nAs for the runtime, the algorithm I've described above runs in total time O(kE).  This is because each iteration of computing the recurrence takes O(E) time and there are a total of k iterations.\n\nFinally, let's look at your proposed code.  I've reprinted it here:\n\n```\nfor (i = 0; i < n - 1; ++i) {\n    steps = 0;\n    for (j = 0; j < e; ++j) {\n        if ( (d[edges[j].u]+ edges[j].w)/(steps+1) < d[edges[j].v]/steps){\n            d[edges[j].v] = d[edges[j].u] + edges[j].w;\n            p[edges[j].v] = u;\n            steps++;\n        }\n    }\n}\n```\n\n\nYour first question was how to take k into account.  This can be done easily by rewriting the outer loop to count up to k, not n - 1.  That gives us this code:\n\n```\nfor (i = 0; i < k; ++i) {\n    steps = 0;\n    for (j = 0; j < e; ++j) {\n        if ( (d[edges[j].u]+ edges[j].w)/(steps+1) < d[edges[j].v]/steps){\n            d[edges[j].v] = d[edges[j].u] + edges[j].w;\n            p[edges[j].v] = u;\n            steps++;\n        }\n    }\n}\n```\n\n\nOne problem that I'm noticing is that the modified Bellman-Ford algorithm needs to have each candidate best path store its number of edges independently, since each node's optimal path might be reached by a different number of edges.  To fix this, I would suggest having the ```\nd```\n array store two values - the number of edges required to reach the node and the average cost of a node along that path.  You would then update your code by replacing the ```\nsteps```\n variable in these equations with the cached path lengths.\n\nHope this helps!\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Find a path in a directed graph with a given length, allowing for loops and negative lengths\r\n                \r\nI have a directed graph with a maximum of 7 nodes. Every node is connected to every other node (not including itself of course) with a directed edge, and edges can have either positive or negative weights. My objective is to find a path from one given node to another, such that the path has a specific length. However, there's a catch. Not only can I make use of loops, if I reach the end node, the path doesn't have to immediately end. This means that I can have a simple path leading to the end node, and then have a loop out of the end node leading back into itself that ultimately. At the same time, I have to maximize the number of unique nodes visited by this path, so that if there are multiple paths of the desired length, I get the one with the most nodes in it.\n\nBesides the problem with loops, I'm having trouble rephrasing this in terms of other simpler problems, like maybe Shortest Path, or Traveling Salesman. I'm not sure how to start tackling this problem. I had an idea of finding all simple paths and all loops, and recursively take combinations of each, but this brings up problems of loops within loops. Is there a more efficient approach to this problem?\n\nBtw, I'm writing this in python.\n\nEDIT: Another thing I forgot to mention that pairs of directed edges between nodes need not necessarily have the same weight. So A -> B might have weight -1, but B -> A might have weight 9.\n\nEDIT 2: As requested, here's the input and output: I'm given the graph, the starting and exit nodes, and the desired length, and I return the path of desired length with the most visited nodes.\n    ", "Answer": "\r\nSounds like a combinations problem. Since you don't have a fixed end state.\n\nLet's list what we know. \n\n\nEvery node is connected to every other node, though it is directed. This is a complete digraph. Link: https://en.wikipedia.org/wiki/Complete_graph.\nYou can cut off the algorithm when it exceeds the desired distance.\nBe careful of an infinite loop though; possible if the negative weights are able to equal the positive ones. \n\n\nIn this example, I'd use recursion with a maximum depth that is based on the total number of nodes. While I won't do your homework I'll attempt a pseudo-code start. \n\n```\ndef recursion(depth, graph, path, previous_node, score, results):\n    // 1A. Return if max depth exceeded\n    // 1B. Return if score exceeded \n    // 1C. Return if score match AND append path to results\n\n    // 2. iterate and recurse through graph:\n    for node in graph:\n        path.append(node.name)\n        score += node.weight\n        recursion(depth, graph, path, node, score, results)\n\n    return results\n\n# The results should contain all the possible paths with the given score.\n```\n\n\nThis is where I'd start. Good luck. \n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "How to find the shortest simple path in a Tree in a linear time?\r\n                \r\nHere is a problem from Algorithms book by Vazirani\n\n\n  The input to this problem is a tree T with integer weights on the edges. The weights may be negative,\n  zero, or positive. Give a linear time algorithm to find the shortest simple path in T. The length of a\n  path is the sum of the weights of the edges in the path. A path is simple if no vertex is repeated. Note\n  that the endpoints of the path are unconstrained.\n  \n  HINT: This is very similar to the problem of finding the largest independent set in a tree.\n\n\nHow can I solve this problem in linear time?\n\nHere is my algorithm but I'm wonder if it is linear time since it is nothing different than depth-first:\n\n\n  \n  Traverse tree (depth-first)\n  Keep the indexes (nodes)\n  add the values\n  do (1) till the end of tree\n  compare the sum and print the path and sum\n  \n\n\nthis problem is similar this topic but there is no certain answer.\n    ", "Answer": "\r\nThis problem is pretty much equivalent to the minimum sum subsequence problem, and can be solved in a similar manner by dynamic programming.\n\nWe will calculate the following arrays by using DF searches:\n\n```\ndw1[i] = minimum sum achievable by only using node i and its descendants.\npw1[i] = predecessor of node i in the path found for dw1[i].\ndw2[i] = second minimum sum achevable by only using node i and its descendants,\n         a path that is edge-disjoint relative to the path found for dw1[i].\n```\n\n\nIf you can calculate these, take ```\nmin(dw1[k], dw1[k] + dw2[k])```\n over all ```\nk```\n. This is because your path will take one of these basic shapes:\n\n```\n  k              k\n  |     or     /   \\\n  |           /     \\\n  | \n```\n\n\nAll of which are covered by the sums we're taking.\n\nCalculating dw1\n\nRun a DFS from the root node. In the DFS, keep track of the current node and its father. At each node, assume its children are ```\nd1, d2, ... dk```\n. Then ```\ndw1[i] = min(min{dw1[d1] + cost[i, d1], dw1[d2] + cost[i, d2], ..., dw1[dk] + cost[i, dk]}, min{cost[i, dk]})```\n. Set ```\ndw1[i] = 0```\n for leaf nodes. Don't forget to update ```\npw1[i]```\n with the selected predecessor.\n\nCalculating dw2\n\nRun a DFS from the root node. Do the same thing you did for ```\ndw1```\n, except when going from a node ```\ni```\n to one of its children ```\nk```\n, only update ```\ndw2[i]```\n if ```\npw1[i] != k```\n. You call the function recursively for all children however. It would look something like this in pseudocode:\n\n```\ndf(node, father)\n    dw2[node] = inf\n    for all children k of node\n        df(k, node)\n\n        if pw1[node] != k\n            dw2[node] = min(dw2[node], dw1[k] + cost[node, k], cost[node, k])\n```\n\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "JGraphT avoid loops (Bellman Ford)\r\n                \r\nI am using JGraphT for implementing a Bellman Ford shortest path algorithm in Java.\nSince there are some edges, that shall be prefered, their edge weight is set to -1.\n\nFor example:\n\nA <-> B: 10\n\nA <-> C: 10\n\nC <-> B: -1\n\nB <-> D: 10\n\nSo in this case, the Path shall look like A -> C -> B -> D.\nThe sub-path A->C->B shall be preferred to A->B.\n\nNow here's the problem: the algorithm finds loops between C and B, so that the C->B and B->C paths are added several times (to decrease the total path costs since the weight of B<->C is negative).\n\nNow the question: is it possible to avoid such loops? I didn't find any option in the API. The isAllowingLoops() method of the Graph object returns \"false\".\n\nCan you give me some hint what to do here?\n\nThanks in advance!\n    ", "Answer": "\r\nConstructing the graph as follows will give you the path you're looking for:\n\n```\nDefaultDirectedWeightedGraph<String, DefaultWeightedEdge> g;\ng = new DefaultDirectedWeightedGraph<String, DefaultWeightedEdge>(DefaultWeightedEdge.class);\n\ng.addVertex(\"a\");\ng.addVertex(\"b\");\ng.addVertex(\"c\");\ng.addVertex(\"d\");\n\nDefaultWeightedEdge edge1 = g.addEdge(\"a\", \"b\");\ng.setEdgeWeight(edge1, 10);\nDefaultWeightedEdge edge1a = g.addEdge(\"b\", \"a\");\ng.setEdgeWeight(edge1a, 10);\n\n\nDefaultWeightedEdge edge2 = g.addEdge(\"a\", \"c\");\ng.setEdgeWeight(edge2, 10);\nDefaultWeightedEdge edge2a = g.addEdge(\"c\", \"a\");\ng.setEdgeWeight(edge2a, 10);\n\n\nDefaultWeightedEdge edge3 = g.addEdge(\"b\", \"c\");\ng.setEdgeWeight(edge3, -1);\nDefaultWeightedEdge edge3a = g.addEdge(\"c\", \"b\");\ng.setEdgeWeight(edge3a, -1);\n\n\nDefaultWeightedEdge edge4 = g.addEdge(\"b\", \"d\");\ng.setEdgeWeight(edge4, 10);\nDefaultWeightedEdge edge4a = g.addEdge(\"d\", \"b\");\ng.setEdgeWeight(edge4a, 10);\n\n\nList<DefaultWeightedEdge> path = BellmanFordShortestPath.findPathBetween(g, \"a\", \"d\");\nSystem.out.println(path);\n```\n\n\nThe above will output:\n\n```\n[(a : c), (c : b), (b : d)]\n```\n\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Find the lowest-weight cycle in a weighted, directed graph using Dijkstra's\r\n                \r\nHi I am struggling with this question. It is the following:\n\n\n  Devise an algorithm to find the lowest-weight cycle(i.e. of all cycles in the graph, the one with the smallest sum of edge weights), in a weighted, directed graph G = (V,E). Briefly justify the runtime and space complexity. Assume all edges are non-negative. It should run in O(|V||E|log|V|) time. \n  Hint: Use multiple calls to Dijkstra's algorithm.\n\n\nI have seen solutions that use Floyd-Warshall but I was wondering how we would do this using Dijkstra's and how to do it within the time constraint given. \n\nI have a few points of confusion:\n\n\nFirstly, how do we even know how many cycles are in the graph and how\nto check those?\nAlso, why is it |E||V|log|V|? By my understanding you should traverse\nthrough all the vertices therefore making it |V|log|V|.\n\n\nThis is for my personal learning so if anyone has an example they could use, it would greatly help me! I am not really looking for pseudo-code - just a general algorithm to understand how using the shortest path from one node to all nodes is going to help us solve this problem.\nThank you!\n    ", "Answer": "\r\nCall Dijkstra's algorithm from each vertex to find the shortest path to itself, if one exists.  The shortest path from any vertex to itself is the smallest cycle. \n Dijkstra's algorithm takes O(|E| log |V|), so total time is O(|V||E| log |V|).\n\nNote that this time can be worse than Floyd-Warshall, because there can be O(|V|^2) edges in the graph.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "SSSP Algorithm: Minimum distance but under a certain number of \"hops\"\r\n                \r\nGiven a directed, weighted graph (with no negative edges), what is the shortest distance from one node to other that also fulfills the condition that the number of \"hops\" from one node/vertices to another must be less than a certain value k. (Where k is definitely less than the number of nodes). \n\nOne \"hop\" is defined to be moving from one node to another, and the \"hop\" value starts at 1 from the source node. \n\nThe problem is not as simple as to simply run Dijkstra's algorithm, since this algorithm only gives you the shortest distance without consideration of the number of \"hops\". \n\nConsideration 1:\nThe shortest path from source to end node may exceed the maximum number of \"hops\" allowed.\n\nConsideration 2:\nAugmenting the Dijkstra's algorithm to minimize the number of \"hops\" will give you a possible answer but it may not be the shortest.\n\nNote that the priority here is still to minimize the shortest distance, just that there is a new condition of the number of \"hops\" needing to be less than a certain value.\n    ", "Answer": "\r\nThere is a solution that modifies the Bellman-Ford algorithm for your specific case. On the classical Bellman-Ford ( https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm ) you should do N-iterations.\n\nThe idea of the solution is the following,\n\nSet distance[root] = 0, and distance[x] = infinity for every other node.\n\nNow, we will loop through all edges once and try to improve our answer.\n\n```\nFor Edge in Edges:\n    distance[Edge.dest] = min( distance[Edge.dest], distance[Edge.src] + Edge.cost)\n```\n\n\nApplying this step once will give us the shortest path from origin that uses at most one edge. Now the idea is to repeat this step exactly K times. This will give us exactly the shortest path from the origin to every other node using at most K edges.\n\nComplexity: O( K * |edges| )\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Am I right about the differences between Floyd-Warshall, Dijkstra's and Bellman-Ford algorithms?\r\n                \r\nI've been studying the three and I'm stating my inferences from them below. Could someone tell me if I have understood them accurately enough or not? Thank you.\n\n\nDijkstra's algorithm is used only when you have a single source and you want to know the smallest path from one node to another, but fails in cases like this\nFloyd-Warshall's algorithm is used when any of all the nodes can be a source, so you want the shortest distance to reach any destination node from any source node. This only fails when there are negative cycles\n\n\n(this is the most important one. I mean, this is the one I'm least sure about:)\n\n3.Bellman-Ford is used like Dijkstra's, when there is only one source. This can handle negative weights and its working is the same as Floyd-Warshall's except for one source, right?\n\nIf you need to have a look, the corresponding algorithms are (courtesy Wikipedia):\n\nBellman-Ford:\n\n```\n procedure BellmanFord(list vertices, list edges, vertex source)\n   // This implementation takes in a graph, represented as lists of vertices\n   // and edges, and modifies the vertices so that their distance and\n   // predecessor attributes store the shortest paths.\n\n   // Step 1: initialize graph\n   for each vertex v in vertices:\n       if v is source then v.distance := 0\n       else v.distance := infinity\n       v.predecessor := null\n\n   // Step 2: relax edges repeatedly\n   for i from 1 to size(vertices)-1:\n       for each edge uv in edges: // uv is the edge from u to v\n           u := uv.source\n           v := uv.destination\n           if u.distance + uv.weight < v.distance:\n               v.distance := u.distance + uv.weight\n               v.predecessor := u\n\n   // Step 3: check for negative-weight cycles\n   for each edge uv in edges:\n       u := uv.source\n       v := uv.destination\n       if u.distance + uv.weight < v.distance:\n           error \"Graph contains a negative-weight cycle\"\n```\n\n\nDijkstra:\n\n```\n 1  function Dijkstra(Graph, source):\n 2      for each vertex v in Graph:                                // Initializations\n 3          dist[v] := infinity ;                                  // Unknown distance function from \n 4                                                                 // source to v\n 5          previous[v] := undefined ;                             // Previous node in optimal path\n 6                                                                 // from source\n 7      \n 8      dist[source] := 0 ;                                        // Distance from source to source\n 9      Q := the set of all nodes in Graph ;                       // All nodes in the graph are\n10                                                                 // unoptimized - thus are in Q\n11      while Q is not empty:                                      // The main loop\n12          u := vertex in Q with smallest distance in dist[] ;    // Start node in first case\n13          if dist[u] = infinity:\n14              break ;                                            // all remaining vertices are\n15                                                                 // inaccessible from source\n16          \n17          remove u from Q ;\n18          for each neighbor v of u:                              // where v has not yet been \n19                                                                                 removed from Q.\n20              alt := dist[u] + dist_between(u, v) ;\n21              if alt < dist[v]:                                  // Relax (u,v,a)\n22                  dist[v] := alt ;\n23                  previous[v] := u ;\n24                  decrease-key v in Q;                           // Reorder v in the Queue\n25      return dist;\n```\n\n\nFloyd-Warshall:\n\n```\n 1 /* Assume a function edgeCost(i,j) which returns the cost of the edge from i to j\n 2    (infinity if there is none).\n 3    Also assume that n is the number of vertices and edgeCost(i,i) = 0\n 4 */\n 5\n 6 int path[][];\n 7 /* A 2-dimensional matrix. At each step in the algorithm, path[i][j] is the shortest path\n 8    from i to j using intermediate vertices (1..k−1).  Each path[i][j] is initialized to\n 9    edgeCost(i,j).\n10 */\n11\n12 procedure FloydWarshall ()\n13    for k := 1 to n\n14       for i := 1 to n\n15          for j := 1 to n\n16             path[i][j] = min ( path[i][j], path[i][k]+path[k][j] );\n```\n\n    ", "Answer": "\r\nYou are correct about the first two questions, and about the goal of Floyd-Warshall (finding the shortest paths between all pairs), but not about the relationship between Bellman-Ford and Floyd-Warshall: Both algorithms use dynamic programming to find the shortest path, but FW isn't the same as running BF from each starting node to every other node.\n\nIn BF, the question is: What is the shortest path from the source to the target using at most k steps, and the running time is O(EV). If we were to run it to each other node, the running time would be O(EV^2).\n\nIn FW, the question is: what is the shortest path from i to j through k, for all nodes i,j,k. This leads to O(V^3) running time - better than BF for each starting node (by a factor of up to |V| for dense graphs).\n\nOne more note about negative cycles / weights: Dijkstra may simply fail to give the correct results. BF and FW won't fail - they will correctly state that there is no minimum weight path, since the negative weight is unbounded.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Modified Dijkstra to find most optimized shortest path given extra properties\r\n                \r\nThis is a follow-up question for a question I asked at here. The problem is mapped to a graph with say non-negative weights on edges (no preference if it can be directed or not). However, along with a weight which is actually distance, we also have another property which is data coverage of the edge which can be important factor which route to select given how severe I need internet on my phone (for real-time gaming for example I need good bandwidth). So overall, we want to somehow find a trade-off between the length of the path and network bandwidth to solve the problem of finding most optimized and shortest path between two cities. However, an important feature is that the algorithm should be dynamic. Once we arrived to a node, depending on our current state of need we might change the pre-determined path.\n\nOK. For simplicity, let's say each edge is associated with two properties: A) a distance or travel time or whatever, as a regular weight, and B) network bandwidth as a secondary property to show how good network is.\n\nFor constraints and objective function, say we want to minimize the total distance (or travel time), but depending to our current state, we also want to minimize the total disconnection time or maximize the ```\ntotal sum of path bandwidths```\n. Optionally, say we can not tolerate total continuous disconnection time of more than a threshold ```\nT```\n. So this can be a constraint on the problem. The simplest of such objective functions can be ```\nf()=total time of travel + a*time of disconnection```\n. The ```\na```\n co-efficient determines how important connectivity can be for us at each time.\n\nTo tackle the fact that edges can have partial disconnections, after a bit of think, I came into a solution that let's insert nodes in between. That makes the problem easier to solve. So basically each route either has disconnection, or connection with a bandwidth of specific value.\n\n\n\nA first-version solution that came into my mind was to accumulate the total continuous disconnection times whenever we are computing a path, so it can not go beyond the threshold ```\nT```\n. And whenever we reached a route with connection (regardless of bandwidth for a simpler problem), we just reset the accumulation. Further to account for bandwidth, since we also have value for connection bandwidth, we can just deduct the value of connection bandwidth from the total accumulated disconnection time (does it work?!)\n\nOne important thing is to consider the following example figure. Not exceeding the total disconnection threshold shouldn't lead to go through a very far route which increases the total time of travel! For that, I thought about this general approach: Solve the problem for disconnection threshold of say ```\nT1, T2, ...Tk```\n, compute the best path (or a set of best paths maybe?!), and compute the corresponding total travel time for each. Then apply the objective function that we have above and see what is the most optimum solution. We can further pin point the solution between two samples to find more optimum solution using a binary-search-like approach.\n\n\n\nPlease, can someone please help me to solve the problem? Apparently my solution is not correct, and if it was, even not possible in polynomial time. Maybe approximation algorithms?! Any helps to find a solution is highly appreciated. Feel free to add more details or assumptions, or revise the problem. The problem is harder than what I thought.\n    ", "Answer": "\r\nFirst of all finding the perfect answer to this question for the whole network is computationally infeasible.  See http://phys.org/news/2015-05-maths-congestionsprings-traffic.html for an article outlining some of the practical complexity and numerical instability that you'll encounter.  As well as a demonstration that adding roads can make the whole network worse.\n\nHowever we can solve it in practice reasonably well for exactly the IP networking problem that you're looking at.  A google search gave me https://www.cs.princeton.edu/~jrex/papers/opthand04.pdf as a suggestion for where to start learning the literature.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Why isn't my A* implementation finding the shortest path but rather the first path?\r\n                \r\nHere is a visual representation of what's happening\n\nFor some reason my implementation doesn't seem to calculate the shortest path, but rather the first path it finds, and I can't seem to figure out why.\nIs there something that I've missed that's super obvious?\nHere's the notes I took while learning and that's what I've been going over\n\nInitialize the open set with the starting node and an empty closed set.\n\nWhile the open set is not empty, select the node with the lowest cost to reach it from the starting node, plus the estimated cost to reach the goal node from that node, and remove it from the open set.\n\nIf the selected node is the goal node, the algorithm terminates and the path is traced back from the goal node to the starting node.\n\nOtherwise, add the selected node to the closed set and evaluate its neighboring nodes.\nFor each neighboring node that is not in the closed set and is not an obstacle, calculate its tentative cost to reach it from the starting node and the estimated cost to reach the goal node from that node, using the heuristic function. Add the neighboring nodes to the open set if they are not already in it.\n\nRepeat steps 2-4 until the goal node is found or the open set is empty.\n\n\nThe A* algorithm should guarantee that it will find the shortest path from the starting node to the destination node, as long as the heuristic function is admissible (i.e., it never overestimates the actual cost to reach the goal node) and the grid does not contain cycles or negative edge weights.\n```\npublic class World\n{\n    public int Width { get; set; }\n    public int Height { get; set; }\n\n    public Node[,] Nodes { get; set; }\n    public List<Node> Path { get; set; }\n\n    public World(int width, int height)\n    {\n        Width = width;\n        Height = height;\n        Nodes = new Node[Width, Height];\n\n        Build();\n    }\n\n    private void Build()\n    {\n        for (int y = 0; y < Height; y++)\n        {\n            for (int x = 0; x < Width; x++)\n            {\n                Nodes[x, y] = new Node(x, y);\n            }\n        }\n    }\n\n    public void Find()\n    {\n        Node Start = GetStartNode(Nodes);\n        Node Destination = GetDestinationNode(Nodes);\n\n        var openSet = new List<Node>();\n        var closedSet = new List<Node>();\n        openSet.Add(Start);\n\n        while (openSet.Any())\n        {\n            Node n = GetLowestFCostNode(openSet);\n            \n            if (n.NodeState == NodeState.Destination)\n            {\n                /* Trace Back Path */\n                Path = TracebackPath(n, Start);\n                break;\n            }\n\n            closedSet.Add(n);\n            openSet.Remove(n);\n\n            foreach (var node in GetAdjacentNodes(n, Nodes))\n            {\n                if (closedSet.Contains(node) || node.NodeState == NodeState.Obstruction)\n                    continue;\n\n                int currentGCost = node.GCost + NodeDistance(n, node);\n\n                bool recalculate;\n                if (!openSet.Contains(node))\n                {\n                    openSet.Add(node);\n                    recalculate = true;\n                }\n                else if (currentGCost < node.GCost)\n                {\n                    recalculate = true;\n                }\n                else\n                {\n                    recalculate = false;\n                }\n\n                if (recalculate)\n                {\n                    node.Parent = n;\n                    node.GCost = currentGCost;\n                    node.HCost = HueristicsCost(node, Destination);\n                    node.CalculateFCost();\n                }\n            }\n        }\n    }\n\n    private int HueristicsCost(Node node, Node destination)\n    {\n        int dx = Math.Abs(node.X - destination.X);\n        int dy = Math.Abs(node.Y - destination.Y);\n        return 10 * (dx + dy);\n    }\n\n    private int NodeDistance(Node a, Node b)\n    {\n        if (Math.Abs(a.X - b.X) == 1 && Math.Abs(a.Y - b.Y) == 1)\n            return 14;\n        return 10;\n    }\n\n    private List<Node> GetAdjacentNodes(Node candidate, Node[,] fields)\n    {\n        var fieldList = new List<Node>();\n        var width = fields.GetLength(0);\n        var height = fields.GetLength(1);\n\n        /* Check Lateral Neighbors */\n        for (var x = candidate.X - 1; x <= candidate.X + 1; x++)\n        {\n            /* Check Vertical Neighbors */\n            for (var y = candidate.Y - 1; y <= candidate.Y + 1; y++)\n            {\n                /* Bounds Check */\n                if (x >= 0 && x < width && y >= 0 && y < height && (x != candidate.X || y != candidate.Y))\n                {\n                    fieldList.Add(fields[x, y]);\n                }\n            }\n        }\n\n        return fieldList;\n    }\n\n\n    private Node GetLowestFCostNode(List<Node> openSet)\n    {\n        Node lowestFCostNode = null;\n        int lowestFCost = int.MaxValue;\n\n        foreach (Node node in openSet)\n        {\n            if (node.FCost < lowestFCost || (node.FCost == lowestFCost && node.HCost < lowestFCostNode.HCost))\n            {\n                lowestFCost = node.FCost;\n                lowestFCostNode = node;\n            }\n        }\n\n        return lowestFCostNode;\n    }\n\n    private List<Node> TracebackPath(Node node, Node start)\n    {\n        List<Node> list = new List<Node>();\n        while (node != start)\n        {\n            list.Add(node);\n            node.Tile.Fill = Brushes.Cyan;\n            node = node.Parent;\n        }\n\n        list.Add(start);\n\n        return list;\n    }\n\n    private Node GetDestinationNode(Node[,] nodes)\n    {\n        foreach (var node in nodes)\n        {\n            if (node.NodeState == NodeState.Destination)\n                return node;\n        }\n\n        throw new Exception(\"No Destination Field.\");\n    }\n\n    private Node GetStartNode(Node[,] nodes)\n    {\n        foreach (var node in nodes)\n        {\n            if (node.NodeState == NodeState.Start)\n                return node;\n        }\n\n        throw new Exception(\"Could not find a starting node.\");\n    }\n}\n```\n\nNode.cs\n```\npublic class Node\n{\n    public int X { get; }\n    public int Y { get; }\n    public Rectangle Tile { get; set; }\n\n    /* Estimated Distance from CurrentNode to the StartNode */\n    public int GCost { get; set; }\n\n    /* Estimated Distance From CurrentNode To DestinationNode */\n    public int HCost { get; set; }\n\n    /* G + HCost Combined */\n    public int FCost { get; set; }\n    public Node Parent { get; set; }\n\n    private NodeState _nodeState;\n\n    public NodeState NodeState\n    {\n        get { return _nodeState; }\n        set\n        {\n            InvokeNodeState(value);\n            _nodeState = value;\n        }\n    }\n\n    public Node(int x, int y)\n    {\n        X = x;\n        Y = y;\n\n        CreateTile();\n    }\n\n    private void CreateTile()\n    {\n        Tile = new Rectangle()\n        {\n            Width = 25,\n            Height = 25,\n            Fill = Brushes.ForestGreen,\n            Stroke = Brushes.Black,\n            StrokeThickness = 2\n        };\n\n        Tile.MouseDown += (sender, args) =>\n        {\n            switch (NodeState)\n            {\n                case NodeState.None:\n                    NodeState = NodeState.Obstruction;\n                    break;\n                case NodeState.Obstruction:\n                    NodeState = NodeState.Start;\n                    break;\n                case NodeState.Start:\n                    NodeState = NodeState.Destination;\n                    break;\n                case NodeState.Destination:\n                    NodeState = NodeState.None;\n                    break;\n                default:\n                    throw new ArgumentOutOfRangeException();\n            }\n        };\n\n        Canvas.SetLeft(Tile, X * 25);\n        Canvas.SetTop(Tile, Y * 25);\n    }\n\n    private void InvokeNodeState(NodeState value)\n    {\n        switch (value)\n        {\n            case NodeState.None:\n                Tile.Fill = Brushes.ForestGreen;\n                break;\n            case NodeState.Obstruction:\n                Tile.Fill = Brushes.SaddleBrown;\n                break;\n            case NodeState.Start:\n                Tile.Fill = Brushes.Yellow;\n                break;\n            case NodeState.Destination:\n                Tile.Fill = Brushes.Red;\n                break;\n            default:\n                throw new ArgumentOutOfRangeException(nameof(value), value, null);\n        }\n    }\n\n    public void CalculateFCost()\n    {\n        FCost = GCost + HCost;\n        Tile.Fill = Brushes.DarkGreen;\n        Tile.ToolTip = $\"FCost: {FCost} - GCost: {GCost} - HCost: {HCost}\";\n    }\n}\n\npublic enum NodeState\n{\n    None,\n    Obstruction,\n    Start,\n    Destination\n}\n```\n\n    ", "Answer": "\r\nThe heuristic used to estimate the remaining distance should never overestimate the remaining distance. Your heuristic is:\n```\nint dx = Math.Abs(node.X - destination.X);\nint dy = Math.Abs(node.Y - destination.Y);\nreturn 10 * (dx + dy);\n```\n\nwhile your distance calculation is\n```\nif (Math.Abs(a.X - b.X) == 1 && Math.Abs(a.Y - b.Y) == 1)\n    return 14;\nreturn 10;\n```\n\nSo consider nodes (0, 0) and (1,1), the estimated distance is 20, while the actual distance is 14. This makes the heuristic inadmissible. The simplest fix for this is to change ```\n(dx + dy)```\n to ```\nMath.Max(dx, dy)```\n.\nWhen debugging A* it may be useful to set the heuristic to 0, this should turn the algorithm into Djikstra. If that works better you know your problem is related to the heuristic.\nSome notes on data structures, if you want to improve the performance of your algorithm you should probably use something other than List for your open/closed set. For the closed set some common choices are a HashSet, or a 2D array. For the open set the typical data structure is a MinHeap, since that has both fast inserts and removals.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Finding heaviest path (biggest sum of weights) of an undirected weighted graph? Bellman Ford --\r\n                \r\n\nThere's a matrix, each of its cell contains an integer value (both positive and negative). You're given an initial position in the matrix, now you have to find a path that the sum of all the cells you've crossed is the biggest. You can go up, down, right, left and only cross a cell once.\nMy solution is using Bellman Ford algorithm: Let's replace all the values by their opposite number, now we've just got a new matrix. Then, I create an undirected graph from the new matrix, each cell is a node, stepping on a cell costs that cell's value - it's the weight. So, I just need to find the shortest path of the graph using Bellman-Ford algorithm. That path will be the longest path of our initial matrix.\nWell, there's a problem. The graph contains negative cycles, also has too many nodes and edges. The result, therefore, isn't correct.\nThis is my code:\n\nKnowing that xd and yd is the initial coordinate of the robot.\n```\nvoid MatrixToEdgelist()\n{\n    int k = 0;\n    for (int i=1;i<=n;i++)\n        for (int j=1;j<=n;j++)\n    {\n        int x = (i - 1) * n + j;\n        int y = x + 1;\n        int z = x + n;\n        if (j<n)\n        {\n            edges.push_back(make_tuple(x, y, a[i][j+1]));\n        }\n        if (i<n)\n        {\n            edges.push_back(make_tuple(x, z, a[i+1][j]));\n        }\n    }\n}\n\n   void BellmanFord(Robot r){\n        int x = r.getXd();\n        int y = r.getYd();\n        int z = (x-1)*n + y;\n        int l = n*n;\n        int distance[100];\n        int previous[100]{};\n        int trace[100];\n    \n        trace[1] = z;\n        for (int i = 1; i <= l; i++) {\n            distance[i] = INF;\n        }\n    \n        distance[z] = a[x][y];\n        for (int i = 1; i <= l-1; i++) {\n            for (auto e : edges) {\n                int a, b, w;\n                tie(a, b, w) = e;\n                //distance[b] = min(distance[b], distance[a]+w);\n                if (distance[b] < distance[a] + w)// && previous[a] != b)\n                {\n                    distance[b] = distance[a] + w;\n                    previous[b] = a;\n                }\n            }\n    \n        }\n    \n        //print result\n        int Max=INF;\n        int node;\n        for (int i=2;i<=l;i++)\n        {\n            if (Max < distance[i])\n            {\n                Max = distance[i];\n                node = i;\n            }\n        }\n    \n        if (Max<0)cout << Max << \"\\n\";\n        else cout << Max << \"\\n\";\n        vector<int> ans;\n        int i = node;\n        ans.push_back(i);\n        while (i != z)\n        {\n            i = previous[i];\n            ans.push_back(i);\n        }\n    \n        for (int i=ans.size()-1;i>=0;i--)\n        {\n            int x, y;\n            if (ans[i] % n == 0)\n            {\n                x = ans[i] / n;\n                y = n;\n            }\n            else{\n                x = ans[i] / n + 1;\n                y = ans[i] - (( x - 1 ) * n);\n            }\n            cout << x << \" \" << y << \"\\n\";\n        }\n    }\n```\n\n\n\n\nExample matrix\nThe result\nClearly that the distance should have continued to update, but it doesn't. It stops at the final node.\n    ", "Answer": "\r\n\"Let's replace all the values by their opposite number\"\nNot sure what you mean by an opposite number.  Anyway, that is incorrect.\nIf you have negative weights, then the usual solution is to add the absolute value of the most negative weight to EVERY weight.\nWhy Bellman-Ford?  Dijkstra should be sufficient for this problem. ( By default Dijkstra finds the cheapest path.  You find the most expensive by assigning the absolute value of ( the original weight minus the greatest ) to every link. )\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "What is the best single-source shortest path algorithm for programming contests?\r\n                \r\nI was working on this graph problem from the UVa problem set. It's a single-source-shortest-paths problem with no negative edge weights. From what I've gathered, the algorithm with the best big-O running time for such problems is Dijkstra with a Fibonacci heap as the priority queue, although practically speaking a binary heap is easier to implement and works pretty well too.\n\nHowever, it would seem that even a binary heap takes quite some time to roll, and in a competition time is limited. I am aware that the STL provides some heap algorithms and priority queues, but they don't seem to provide a decrease-key function which Dijkstra's needs. Or am I wrong here?\n\nIt seems that another possibility is to simply not use Dijkstra's. This forum thread has people claiming that they solved the above problem with breadth-first search / Bellman-Ford, which are much easier to code up. (Edit: OTOH, Dijkstra's with an unsorted array for the priority queue timed out.) That BFS/Bellman-Ford worked surprised me a little as I thought that the input size was quite large. I guess different problems will require solutions of different complexity, but my question is, how often would I need to use Dijkstra's in such competitions? Should I practice more on the simpler-but-slower algorithms instead?\n    ", "Answer": "\r\nIf you can come up with a good best-first heuristics, I would try using A*\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Find a positive simple s-t Path on a Graph is NP-Complete?\r\n                \r\nI'm trying to find something on the literature to help me to solve this problem:\nGiven a graph with non negative edge weights, find a simple s-t positive path of any size, i.e., a path that goes from s to t with length greater than 0. I was trying to use dijkstra algorithm to find a positive shortest path by avoiding relax the edges that have cost zero, but this is wrong. I don't want to believe that this problem is NP-Complete =/. Sometimes it seems to be NP-Complete, because there may be a case where the only positive path is the longest path. But this is such a specific case. I think that on this kind of instance the longest path problem is polynomially solvable.\nCan someone help me identifying this problem or showing that it is NP-Complete ?\nObservations: The only requirement is to be some positive path (not necessarily the lowest or longest). In case of multiple positive paths it can be anyone. In case of non existence of such path, the algorithm should flag that the graph has no positive path.\n    ", "Answer": "\r\nThe problem is NP-complete even with only one single edge having value 1, and all the others having value 0.  Reduce from Two Directed Paths:\nTwo Directed Paths\nInput: A directed graph G and two pairs of vertices (s1, t1) and (s2, t2)\nOutput: Two vertex-disjoint paths, one from s1 to t1 and from from s2 to t2.\nCreate a new instance with all edges having weight 0, and create an edge from t1 to s2 with weight 1.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "What's does Bellman-Ford Algorithm sloved during |V-1| rounds calculation\r\n                \r\nI am learning Bellman ford algorithm from 6.006, and I can't tell the multiple rounds meaning, it just do the same thing.\nCan you help give me a image what's does Bellman-Ford Algorithm sloved during |V-1| rounds calculation?\nBelow is python code from 6.006\n```\ndef bellman_ford(Adj, w, s):\n    # Adj: adjacency list, w: weights, s: start\n    # initialization\n    infinity = float('inf')\n    # number greater than sum of all + weights\n    d = [infinity for _ in Adj] \n    # shortest path estimates d(s, v)\n    parent = [None for _ in Adj] \n    # initialize parent pointers\n    d[s], parent[s] = 0, s \n    # initialize source\n    # construct shortest paths in rounds\n    V = len(Adj) \n    # number of vertices\n    for k in range(V - 1):\n        # relax all edges in (V - 1) rounds\n        for u in range(V):\n            # loop over all edges (u, v)\n            for v in Adj[u]:\n                # relax edge from u to v\n                try_to_relax(Adj, w, d, parent, u, v)\n    # check for negative weight cycles accessible from s\n    for u in range(V):\n        # Loop over all edges (u, v)\n        for v in Adj[u]:\n            if d[v] > d[u] + w(u,v): # If edge relax-able, report cycle\n                raise Exception('Ack! There is a negative weight cycle!')\n    return d, parent\n\n\ndef try_to_relax(Adj, w, d, parent, u, v):\n    if d[v] > d[u] + w(u, v):\n        # better path through vertex u\n        d[v] = d[u] + w(u, v)\n        # relax edge with shorter path found\n        parent[v] = u\n```\n\n    ", "Answer": "", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Efficiency of std::min in c++\r\n                \r\nI was implementing Floyd-Warshall's algorithm in c++, for an MOOC on Coursera, in C++. I was using std::min to find minimum between the current distance between two nodes and that with a jump included (according to the standard pseudo code of the algorithm.)\nI found that use of std::min increased runtime of my program compared to use of if condition.\n\ne.g.\n\n```\nif(a[i][j] > a[i][k]+a[k][j])\n  a[i][j] = a[i][k]+a[k][j];\n```\n\n\ninstead of \n```\na[i][j] = min (a[i][j], a[i][k] + a[k][j]);```\n\n\nI ran both these programs with these test-cases https://github.com/beaunus/stanford-algs/tree/master/testCases/course4/assignment1AllPairsShortestPath and found that on larger test-cases, code with std::min took twice to thrice time compared to the code with if conditions.\n\n[I'm aware that a similar question has already been asked, but that does have any real answer.]\nedit:\nI have marked \"HERE\" where I substituted the if conditions for \"std::min\" and the performance difference was noticeable.\nThe complete code is here:\n\n```\n    //This implements Floyd Warshall algorithm for all pairs- shortest paths.\n#include<cstdio>\n#include<algorithm>\nconst int INF=10000, NMAX=2048; //According to the constraints of the test-files.\nusing namespace std;\nint A[NMAX+1][NMAX+1];\n\nint main()\n{\n    int n, m;   //n= number of vertices, m = number of edges in the directed graph.\n    scanf(\"%d %d\",&n,&m);\n    //Initializing array of distances.\n    for(int i=1; i<=n; i++)\n    {   for(int j=1; j<=n; j++)\n        {   A[i][j]=INF;        //This makes distance from every node to every other node = INF.\n        }\n        A[i][i]=0;              //distance from every node to itself is zero.\n    }\n\n    //Taking input of m edges and storing them.\n    int x, y, dist;\n    for(int i=0; i<m; i++)\n    {   scanf(\"%d %d %d\",&x,&y,&dist);\n\n        if(A[x][y]>dist)        // HERE.\n            A[x][y]=dist;       // There is an edge with weight \"dist\", tail x and head y.\n    }\n\n    for(int k=1; k<=n; k++)\n    {   for(int i=1; i<=n; i++)\n        {   for(int j=1; j<=n; j++)\n            {   if(A[i][j] > A[i][k]+A[k][j])   //HERE.\n                    A[i][j] = A[i][k]+A[k][j];\n            }\n        }\n    }\n\n    //This finds the minimum distance in shortest paths.\n    int mindist=0, mini, minj;\n    for(int i=1; i<=n; i++)\n    {   if(A[i][i]<0)           //This happens iff there is negative cycle.\n        {   printf(\"NULL\\n\");\n            return 0;\n        }\n        for(int j=1; j<=n; j++) //Find the min shortest path distance between any pair of nodes.\n        {   if(mindist > A[i][j])    //HERE\n            {   mindist= A[i][j];\n            }\n        }\n    }\n    printf(\"%d\\n\",mindist);\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nThe main difference here is in the second form you are (essentially) forcing an update of every element (though it may be a no change update).\n\nIn the first version you only perform updates required.\n\nIt depends on your architecture but if the array is large and the number of cases where the second term is smaller is relatively low you could be causing unnecessary memory writes.\n\nOne way to investigate that is replace ```\nmin```\n with a conditional operator ```\n?:```\n.\nIf that's the case performance will be about the same because the overhead isn't in ```\nmin()```\n it's in unnecessarily writing the value of ```\na[i][j]```\n over itself.\n\nYou might also consider creating a reference to ```\na[i][j]```\n as:\n\n```\nauto &v(a[i][j]);\n```\n\n\nTo help minimize index calculations (the optimizer may do this for you but you can't hurt it).\n\n```\nauto &v(a[i][j]);\nif(v > a[i][k]+a[k][j]) {\n  v = a[i][k]+a[k][j];\n}\n```\n\n\nNB: With regard to this local reference. Any reasonable compiler should (with optimization on) spot this and emit what amounts to the same code. But if you're not familiar with optimization and learning it may not be the time to go into that. The common objection to hand optimizing is readability. I'd argue in the case the optimized version is if any more readable anyway.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
{"Question": "Best way for three people to visit some graph nodes in a given order\r\n                \r\nUPD. I solved the problem. \n\nLet ```\nDP[i][vertex_a][vertex_b]```\n is the state with ```\ni```\n cities visited and two players standing at vertices ```\nvertex_a, vertex_b```\n (is is guaranteed one of then stands at ```\nlist[i]```\n). WLOG assume ```\nvertex_a ≤ vertex_b```\n as this ```\nDP```\n table doesn't carry information about players positions. Only three states can be reached from ```\nDP[i][vertex_a][vertex_b]```\n, namely ```\nDP[i + 1][vertex_a][vertex_b]```\n, ```\nDP[i + 1][list[i]][vertex_b]```\n, ```\nDP[i + 1][vertex_a][list[i]]```\n. We also only need to store two layers of ```\nDP```\n, so only ```\nsizeof(int) * 2 * 200 * 200```\n bytes needed to compute optimal path cost. To get the path there would be ```\nlast_move_id[i][vertex_a][vertex_b]```\n carrying information about the player that made move at state ```\nDP[i][vertex_a][vertex_b]```\n and ```\nlast_move_positions[i][vertex_a][vertex_b]```\n storing the number of vertex from which player reached ```\nlist[i]```\n. As vertex number doesn't exceed 200 it's save to store those as ```\nbyte```\n, so ```\nsizeof(byte) * 1000 * 200 * 200```\n bytes for each array. To maintain these arrays there'd have to be another array ```\npositions[i][vertex_a][vertex_b][3]```\n carrying information about position of each player, only last two layers are needed, so ```\nsizeof(byte) * 2 * 200 * 200 * 3```\n bytes for this one. Time complexity ```\nO(N * L * L)```\n. \n\nMy ```\nC++```\n implementation uses ```\n76Mb```\n and ```\n320 ms```\n. \n\nI am struggling with the following competitive programming problem from a Russian online judge http://informatics.mccme.ru/moodle/mod/statements/view.php?chapterid=3379 .  According to rules, one must provide the source of the problem as far as I remember\n\nUnfortunately, there's no English version of website so I'll try to describe the problem.\n\n\n  Input consists of the complete digraph ```\nG```\n with ```\nL```\n vertices and some list of vertices (length at most ```\nN```\n). Three people start at vertices ```\n1, 2, 3```\n respectively. They have to visit each vertex from the input list, order matters, vertex ```\ni + 1```\n is necessarily visited after ```\ni```\n. At one point of time only one person can make a move (if one person goes from some previous vertex to vertex ```\ni```\n others stand still, they can't move in parallel). If person/player stands at vertex ```\ni```\n and has to move to vertex ```\nj```\n he must take an edge ```\n(i, j)```\n instead of some shortest path to vertex j (Floyd–Warshall algorithm can't used to speed up computations here). It is sufficent for a vertex to be visited by a single person which means that all of them can be visited by person 1 while other would stand still. The cost of edge ```\n(i, i)```\n is always ```\n0```\n, there are no multi-edges, all edge weights are non-negative and ```\nG```\n is represented as ```\nL x L```\n adjacency matrix. Output the cost of shortest possible path for these three people to visit vertices from list amd output what person visited each vertex. Input list of vertices to be visited is a multiset (```\nN```\n may be bigger than ```\nL```\n)\n\n\nI've found this problem somewhat similar to Two-Person Traversal of a Sequence of Cities problem, except this is a Three-Person version and they start at different positions and a major difference that people have to visit a specific sequence of vertices with repetitions allowed. I've investigated the solutions of this problem and the time complexity would be ```\nO(L^3)```\n\n for Two-Person Traversal of a Sequence of Cities and it would be ```\nO(N^4)```\n for my problem, which is too slow as even ```\nO(N^3)```\n algorithm won't meet time limits, I think something like ```\nO(LN^2)```\n could work though.\n\nConstraints:\n\n\n  3 ≤ L ≤ 200, 1 ≤ N ≤ 1000 \n  \n  0 ≤ edge weight ≤ 2000\n  \n  Time limit: 1s, memory limit is 256 Mb\n\n\nI also know for sure this problem can be solved using than 64 Mb.\n\nThis problem is tagged as ```\n2D dynamic programming```\n. \n\nI cannot really come up with this exact ```\n2D```\n dynamics. I thought of a pretty straightforward way to solve this problem:\n\nThe initial state of three people is ```\n(1, 2, 3)```\n. When processing the first vertex we compute:\n\n```\n1:(list[1], 2, 3) = (1, 2, 3) + weight(1, list[1])```\n\n\n```\n1:(1, list[1], 3) = (1, 2, 3) + weight(2, list[1])```\n\n\n```\n1:(1, 2, list[1]) = (1, 2, 3) + weight(3, list[1])```\n.\n\nAs one can see this is a ```\n4D```\n dynamic table, but I think that keeping the number of current iteration is unnecessary making it into ```\n3D```\n one. Moreover, one can notice that for computing (i+1)-th layer one only needs information about i-th one, which makes it a great memory optimisation. Nonetheless, if we forget that there are only at most 200 vertices in the graph and think about states as tuples ```\n(i, j, k)```\n, where i, j, k are the numbers of last stage players 1, 2, 3 made move at, which means that at m-th stage one of i, j, k equals to m.  Following this logic and considering all possible repetitions the number of distinct tuples at m-th stage is:\n\n```\nNumber_at_stage(m) = Number_at_stage(m - 1) + 6 * (m - 1)```\n, ```\nNumber_at_stage(1) = 3, Number_at_stage(2) = 9, Number_at_stage(1000) = 2991009.```\n \n\n```\nNumber_at_stage(1)```\n  I got from the following thoughts:\n\n```\n(0, 0, 0) -> (1, 0, 0), (0, 1, 0), (0, 0, 1)```\n\n\nI've summed the number of distinct tuples at stages ```\n1..1000```\n and got a horrific number of ```\n997004997```\n which is almost a billion. This means the number of distinct tuples that represent such moves are asymptotically cubic (wasn't surprising, but obvious). I don't understand how to improve the idea. Thinking in this way, I don't know how to work with states such as (i, j, k) and (k, j, i) since they are actually equivalent in the sence that the same set of steps can be made based on these. I just do not know how to process such states and keeping information what person visited what city (simple multi-dimensional array?). \n\nMy next thought would be to have a two dimensional DP(i, j) storing the optimal sum of distances for sublist with elements from i to j. The answer would be stored in DP(1, N) if the indexing goes from 1. I could compute all subsets of length 1, 2, ... N. There is a major issue with this idea, I don't know how to process DP(i, j) without knowing all potential positions players can stand at (all elements from list going before i and initial positions 1, 2, 3). I also don't know how to determine what player made the move with this approach.\n\nCould you provide me some help find the 2D dynamics?\n    ", "Answer": "\r\nGiven the possible states of the 3 players when ```\nlist[i]```\n is visited, and the cost so far associated with each such state, calculate the possible states and costs for ```\nlist[i+1]```\n.  When you get to ```\nlist[N-1]```\n, select the lowest cost.  Keep predecessor links so you can traverse the entire sequence back to the start and output it.\n\nI'm pretty sure you got that much already...   Here's the part you missed:\n\nHow many distinguishable states are there when ```\nlist[i]```\n is visited?  Well, it's less than L^3, because it doesn't matter which player is on which vertex.  It's also less than L^3/3!, because at least one of the players is obviously on ```\nlist[i]```\n!\n\nSo, one player is on ```\nlist[i]```\n and there are only L(L+1)/2 distinguishable positions for the other players.   That means there are at most 20100 possible states for each ```\nlist[i]```\n, and about 20M possible states in the whole array of possibilities for each list index.   If you're a little bit careful about how you store the states and links, you can fit into your 256MB memory limit.\n    ", "Knowledge_point": "Shortest Paths with Negative Weight Edges", "Tag": "算法分析"}
