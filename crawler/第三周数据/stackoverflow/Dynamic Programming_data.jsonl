{"Question": "How does JavaScript .prototype work?\r\n                \r\nI'm not that into dynamic programming languages but I've written my fair share of JavaScript code. I never really got my head around this prototype-based programming, does any one know how this works?\n```\nvar obj = new Object();\nobj.prototype.test = function() { alert('Hello?'); };\nvar obj2 = new obj();\nobj2.test();\n```\n\nI remember a lot discussion I had with people a while back (I'm not exactly sure what I'm doing) but as I understand it, there's no concept of a class. It's just an object, and instances of those objects are clones of the original, right?\nBut what is the exact purpose of this \".prototype\" property in JavaScript? How does it relate to instantiating objects?\nUpdate: correct way\n```\nvar obj = new Object(); // not a functional object\nobj.prototype.test = function() { alert('Hello?'); }; // this is wrong!\n\nfunction MyObject() {} // a first class functional object\nMyObject.prototype.test = function() { alert('OK'); } // OK\n```\n\nAlso these slides really helped a lot.\n    ", "Answer": "\r\nIn a language implementing classical inheritance like Java, C# or C++ you start by creating a class--a blueprint for your objects--and then you can create new objects from that class or you can extend the class, defining a new class that augments the original class.\n\nIn JavaScript you first create an object (there is no concept of class), then you can augment your own object or create new objects from it. It's not difficult, but a little foreign and hard to metabolize for somebody used to the classical way.\n\nExample:\n\n\r\n\r\n```\n//Define a functional object to hold persons in JavaScript\r\nvar Person = function(name) {\r\n  this.name = name;\r\n};\r\n\r\n//Add dynamically to the already defined object a new getter\r\nPerson.prototype.getName = function() {\r\n  return this.name;\r\n};\r\n\r\n//Create a new object of type Person\r\nvar john = new Person(\"John\");\r\n\r\n//Try the getter\r\nalert(john.getName());\r\n\r\n//If now I modify person, also John gets the updates\r\nPerson.prototype.sayMyName = function() {\r\n  alert('Hello, my name is ' + this.getName());\r\n};\r\n\r\n//Call the new method on john\r\njohn.sayMyName();```\n\r\n\r\n\r\n\n\nUntil now I've been extending the base object, now I create another object and then inheriting from Person.\n\n```\n//Create a new object of type Customer by defining its constructor. It's not \n//related to Person for now.\nvar Customer = function(name) {\n    this.name = name;\n};\n\n//Now I link the objects and to do so, we link the prototype of Customer to \n//a new instance of Person. The prototype is the base that will be used to \n//construct all new instances and also, will modify dynamically all already \n//constructed objects because in JavaScript objects retain a pointer to the \n//prototype\nCustomer.prototype = new Person();     \n\n//Now I can call the methods of Person on the Customer, let's try, first \n//I need to create a Customer.\nvar myCustomer = new Customer('Dream Inc.');\nmyCustomer.sayMyName();\n\n//If I add new methods to Person, they will be added to Customer, but if I\n//add new methods to Customer they won't be added to Person. Example:\nCustomer.prototype.setAmountDue = function(amountDue) {\n    this.amountDue = amountDue;\n};\nCustomer.prototype.getAmountDue = function() {\n    return this.amountDue;\n};\n\n//Let's try:       \nmyCustomer.setAmountDue(2000);\nalert(myCustomer.getAmountDue());\n```\n\n\n\r\n\r\n```\nvar Person = function (name) {\r\n    this.name = name;\r\n};\r\nPerson.prototype.getName = function () {\r\n    return this.name;\r\n};\r\nvar john = new Person(\"John\");\r\nalert(john.getName());\r\nPerson.prototype.sayMyName = function () {\r\n    alert('Hello, my name is ' + this.getName());\r\n};\r\njohn.sayMyName();\r\nvar Customer = function (name) {\r\n    this.name = name;\r\n};\r\nCustomer.prototype = new Person();\r\n\r\nvar myCustomer = new Customer('Dream Inc.');\r\nmyCustomer.sayMyName();\r\nCustomer.prototype.setAmountDue = function (amountDue) {\r\n    this.amountDue = amountDue;\r\n};\r\nCustomer.prototype.getAmountDue = function () {\r\n    return this.amountDue;\r\n};\r\nmyCustomer.setAmountDue(2000);\r\nalert(myCustomer.getAmountDue());```\n\r\n\r\n\r\n\n\nWhile as said I can't call setAmountDue(), getAmountDue() on a Person.\n\n```\n//The following statement generates an error.\njohn.setAmountDue(1000);\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "What is the difference between memoization and dynamic programming?\r\n                \r\nWhat is the difference between memoization and dynamic programming? I think dynamic programming is a subset of memoization. Is it right?\n    ", "Answer": "\r\nRelevant article on Programming.Guide: Dynamic programming vs memoization vs tabulation\n\n\n\n\n  What is difference between memoization and dynamic programming?\n\n\nMemoization is a term describing an optimization technique where you cache previously computed results, and return the cached result when the same computation is needed again.\n\n\n\nDynamic programming is a technique for solving problems of recursive nature, iteratively and is applicable when the computations of the subproblems overlap.\n\n\n\nDynamic programming is typically implemented using tabulation, but can also be implemented using memoization. So as you can see, neither one is a \"subset\" of the other.\n\n\n\nA reasonable follow-up question is: What is the difference between tabulation (the typical dynamic programming technique) and memoization?\n\nWhen you solve a dynamic programming problem using tabulation you solve the problem \"bottom up\", i.e., by solving all related sub-problems first, typically by filling up an n-dimensional table. Based on the results in the table, the solution to the \"top\" / original problem is then computed.\n\nIf you use memoization to solve the problem you do it by maintaining a map of already solved sub problems. You do it \"top down\" in the sense that you solve the \"top\" problem first (which typically recurses down to solve the sub-problems).\n\nA good slide from here (link is now dead, slide is still good though):\n\n\n  \n  If all subproblems must be solved at least once, a bottom-up dynamic-programming algorithm usually outperforms a top-down memoized algorithm by a constant factor\n  \n  \n  No overhead for recursion and less overhead for maintaining table\n  There are some problems for which the regular pattern of table accesses in the dynamic-programming algorithm can be exploited to reduce the time or space requirements even further\n  \n  If some subproblems in the subproblem space need not be solved at all, the memoized solution has the advantage of solving only those subproblems that are definitely required\n  \n\n\nAdditional resources:\n\n\nWikipedia: Memoization, Dynamic Programming\nRelated SO Q/A: Memoization or Tabulation approach for Dynamic programming\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "What is dynamic programming? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 3 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nWhat is dynamic programming? \n\nHow is it different from recursion, memoization, etc? \n\nI have read the wikipedia article on it, but I still don't really understand it.\n    ", "Answer": "\r\nDynamic programming is when you use past knowledge to make solving a future problem easier.\n\nA good example is solving the Fibonacci sequence for n=1,000,002.\n\nThis will be a very long process, but what if I give you the results for n=1,000,000 and n=1,000,001? Suddenly the problem just became more manageable.\n\nDynamic programming is used a lot in string problems, such as the string edit problem. You solve a subset(s) of the problem and then use that information to solve the more difficult original problem.\n\nWith dynamic programming, you store your results in some sort of table generally. When you need the answer to a problem, you reference the table and see if you already know what it is. If not, you use the data in your table to give yourself a stepping stone towards the answer.\n\nThe Cormen Algorithms book has a great chapter about dynamic programming. AND it's free on Google Books! Check it out here.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "How to determine the longest increasing subsequence using dynamic programming?\r\n                \r\nI have a set of integers. I want to find the longest increasing subsequence of that set using dynamic programming.\n    ", "Answer": "\r\nOK, I will describe first the simplest solution which is O(N^2), where N is the size of the collection. There also exists a O(N log N) solution, which I will describe also. Look here for it at the section Efficient algorithms.\nI will assume the indices of the array are from 0 to N - 1. So let's define ```\nDP[i]```\n to be the length of the LIS (Longest increasing subsequence) which is ending at element with index ```\ni```\n. To compute ```\nDP[i]```\n we look at all indices ```\nj < i```\n and check both if ```\nDP[j] + 1 > DP[i]```\n and ```\narray[j] < array[i]```\n (we want it to be increasing). If this is true we can update the current optimum for ```\nDP[i]```\n. To find the global optimum for the array you can take the maximum value from ```\nDP[0...N - 1]```\n.\n```\nint maxLength = 1, bestEnd = 0;\nDP[0] = 1;\nprev[0] = -1;\n\nfor (int i = 1; i < N; i++)\n{\n   DP[i] = 1;\n   prev[i] = -1;\n\n   for (int j = i - 1; j >= 0; j--)\n      if (DP[j] + 1 > DP[i] && array[j] < array[i])\n      {\n         DP[i] = DP[j] + 1;\n         prev[i] = j;\n      }\n\n   if (DP[i] > maxLength)\n   {\n      bestEnd = i;\n      maxLength = DP[i];\n   }\n}\n```\n\nI use the array ```\nprev```\n to be able later to find the actual sequence not only its length. Just go back recursively from ```\nbestEnd```\n in a loop using ```\nprev[bestEnd]```\n. The ```\n-1```\n value is a sign to stop.\n\nOK, now to the more efficient ```\nO(N log N)```\n solution:\nLet ```\nS[pos]```\n be defined as the smallest integer that ends an increasing sequence of length ```\npos```\n. Now iterate through every integer ```\nX```\n of the input set and do the following:\n\nIf ```\nX```\n > last element in ```\nS```\n, then append ```\nX```\n to the end of ```\nS```\n. This essentially means we have found a new largest ```\nLIS```\n.\n\nOtherwise find the smallest element in ```\nS```\n, which is ```\n>=```\n than ```\nX```\n, and change it to ```\nX```\n.\nBecause ```\nS```\n is sorted at any time, the element can be found using binary search in ```\nlog(N)```\n.\n\n\nTotal runtime - ```\nN```\n integers and a binary search for each of them - N * log(N) = O(N log N)\nNow let's do a real example:\nCollection of integers:\n```\n2 6 3 4 1 2 9 5 8```\n\nSteps:\n```\n0. S = {} - Initialize S to the empty set\n1. S = {2} - New largest LIS\n2. S = {2, 6} - New largest LIS\n3. S = {2, 3} - Changed 6 to 3\n4. S = {2, 3, 4} - New largest LIS\n5. S = {1, 3, 4} - Changed 2 to 1\n6. S = {1, 2, 4} - Changed 3 to 2\n7. S = {1, 2, 4, 9} - New largest LIS\n8. S = {1, 2, 4, 5} - Changed 9 to 5\n9. S = {1, 2, 4, 5, 8} - New largest LIS\n```\n\nSo the length of the LIS is ```\n5```\n (the size of S).\nTo reconstruct the actual ```\nLIS```\n we will again use a parent array.\nLet ```\nparent[i]```\n be the predecessor of an element with index ```\ni```\n in the ```\nLIS```\n ending at the element with index ```\ni```\n.\nTo make things simpler, we can keep in the array ```\nS```\n, not the actual integers, but their indices(positions) in the set. We do not keep ```\n{1, 2, 4, 5, 8}```\n, but keep ```\n{4, 5, 3, 7, 8}```\n.\nThat is input[4] = 1, input[5] = 2, input[3] = 4, input[7] = 5, input[8] = 8.\nIf we update properly the parent array, the actual LIS is:\n```\ninput[S[lastElementOfS]], \ninput[parent[S[lastElementOfS]]],\ninput[parent[parent[S[lastElementOfS]]]],\n........................................\n```\n\nNow to the important thing - how do we update the parent array? There are two options:\n\nIf ```\nX```\n > last element in ```\nS```\n, then ```\nparent[indexX] = indexLastElement```\n. This means the parent of the newest element is the last element. We just prepend ```\nX```\n to the end of ```\nS```\n.\n\nOtherwise find the index of the smallest element in ```\nS```\n, which is ```\n>=```\n than ```\nX```\n, and change it to ```\nX```\n. Here ```\nparent[indexX] = S[index - 1]```\n.\n\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Difference between Divide and Conquer Algo and Dynamic Programming\r\n                \r\nWhat is the difference between Divide and Conquer Algorithms and Dynamic Programming Algorithms? How are the two terms different? I do not understand the difference between them.\n\nPlease take a simple example to explain any difference between the two and on what ground they seem to be similar.\n    ", "Answer": "\r\nDivide and Conquer\n\nDivide and Conquer works by dividing the problem into sub-problems, conquer each sub-problem recursively and combine these solutions.\n\nDynamic Programming\n\nDynamic Programming is a technique for solving problems with overlapping subproblems. Each sub-problem is solved only once and the result of each sub-problem is stored in a table ( generally implemented as an array or a hash table) for future references. These sub-solutions may be used to obtain the original solution and the technique of storing the sub-problem solutions is known as memoization.\n\nYou may think of ```\nDP = recursion + re-use```\n\n\nA classic example to understand the difference would be to see both these approaches towards obtaining the nth fibonacci number. Check this material from MIT.\n\n\n\nDivide and Conquer approach\n\n\nDynamic Programming Approach\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "A simple example for someone who wants to understand Dynamic Programming [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is seeking recommendations for books, tools, software libraries, and more. It does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     We don’t allow questions seeking recommendations for books, tools, software libraries, and more. You can edit the question so it can be answered with facts and citations.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI am looking for a manageably understandable example for someone who wants to learn Dynamic Programming. There are nice answers here about what is dynamic programming. The fibonacci sequence is a great example, but it is too small to scratch the surface. It looks a great subject to learn about although I haven't taken the algorithms class yet, hopefully it is on my list for the spring.\n    ", "Answer": "\r\nCheck out this site: Dynamic Programming Practice Problems\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "What's the difference between recursion, memoization & dynamic programming? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n            The community reviewed whether to reopen this question 4 months ago and left it closed:\r\n            \r\n                    Original close reason(s) were not resolved\r\n            \r\n        \r\n\r\n\r\n    \r\n\r\n\nRelated question:\nDynamic programming and memoization: top-down vs bottom-up approaches\n\n\nI have gone through a lot of articles on this but can't seem to make sense of it. At times recursion and dynamic programming looks the same and at others memoization & dynamic programming look alike. Can someone explain to me what's the difference?\nP.S. It will also be helpful if you could point me to some code using the three approaches on the same problem. (e.g. the Fibonacci series problem, I think every article I read used recursion but referred to it as dynamic programming)\n    ", "Answer": "\r\nConsider calculating the fibonacci sequence:\n\nPure recursion:\n\n\n\n```\nint fib(int x)\n{\n    if (x < 2)\n        return 1;\n\n    return fib(x-1) + fib(x-2);\n}\n```\n\n\nresults in exponential number of calls.\n\nRecursion with memoization/DP:\n\n```\nint fib(int x)\n{\n    static vector<int> cache(N, -1);\n\n    int& result = cache[x];\n\n    if (result == -1)\n    {\n        if (x < 2)\n            result = 1;\n        else\n            result = fib(x-1) + fib(x-2);\n    }\n\n    return result;\n}\n```\n\n\nNow we have linear number of calls the first time, and constant thereafter.\n\nThe above method is called \"lazy\". We calculate the earlier terms the first time they are asked for.\n\nThe following would also be considered DP, but without recursion:\n\n```\nint fibresult[N];\n\nvoid setup_fib()\n{\n    fibresult[0] = 1;\n    fibresult[1] = 1;\n    for (int i = 2; i < N; i++)\n       fibresult[i] = fibresult[i-1] + fibresult[i-2];\n}\n\nint fib(int x) { return fibresult[x]; }\n```\n\n\nThis way may be described as \"eager\", \"precaching\" or \"iterative\".  Its faster overall but we have to manually figure out the order the subproblems need to be calculated in.  This is easy for fibonacci, but for more complex DP problems it gets harder, and so we fall back to the lazy recursive method if it is fast enough.\n\nAlso the following is neither recursion nor DP:\n\n```\nint fib(int x)\n{\n    int a = 1;\n    int b = 1;\n    for (int i = 2; i < x; i++)\n    {\n        a = a + b;\n        swap(a,b);\n    }\n    return b;\n}\n```\n\n\nIt uses constant space and linear time.\n\nAlso I will mention for the sake of completeness there is a closed form for fibonacci that uses nether recursion nor DP that allows us to calculate in constant time the fibonacci term using a mathematic formula based on the golden ratio:\n\nhttp://www.dreamincode.net/forums/topic/115550-fibonacci-closed-form/\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Difference between back tracking and dynamic programming\r\n                \r\nI heard the only difference between dynamic programming and back tracking is DP allows overlapping of sub problems, e.g.\n\n```\nfib(n) = fib(n-1) + fib (n-2)\n```\n\n\nIs it right? Are there any other differences?\n\nAlso, I would like know some common problems solved using these techniques.\n    ", "Answer": "\r\nThere are two typical implementations of Dynamic Programming approach: bottom-to-top and top-to-bottom.\n\nTop-to-bottom Dynamic Programming is nothing else than ordinary recursion, enhanced with memorizing the solutions for intermediate sub-problems. When a given sub-problem arises second (third, fourth...) time, it is not solved from scratch, but instead the previously memorized solution is used right away. This technique is known under the name memoization (no 'r' before 'i').\n\nThis is actually what your example with Fibonacci sequence is supposed to illustrate. Just use the recursive formula for Fibonacci sequence, but build the table of ```\nfib(i)```\n values along the way, and you get a Top-to-bottom DP algorithm for this problem (so that, for example, if you need to calculate ```\nfib(5)```\n second time, you get it from the table instead of calculating it again).\n\nIn Bottom-to-top Dynamic Programming the approach is also based on storing sub-solutions in memory, but they are solved in a different order (from smaller to bigger), and the resultant general structure of the algorithm is not recursive. LCS algorithm is a classic Bottom-to-top DP example.\n\nBottom-to-top DP algorithms are usually more efficient, but they are generally harder (and sometimes impossible) to build, since it is not always easy to predict which primitive sub-problems you are going to need to solve the whole original problem, and which path you have to take from small sub-problems to get to the final solution in the most efficient way.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Difference between static and dynamic programming languages [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        What is the difference between statically typed and dynamically typed languages?\r\n                            \r\n                                (19 answers)\r\n                            \r\n                    \r\n                Closed last year.\r\n        \r\n\r\n\r\n    \r\n\r\nWhat is the difference between static and dynamic programming languages? I know that it is all about type systems, but I’m looking for more clear clarifications.\n    ", "Answer": "\r\nStatic Typing\n\nStatic typing means that types are known and checked for correctness before running your program. This is often done by the language's compiler. For example, the following Java method would cause a compile-error, before you run your program:\n\n```\npublic void foo() {\n    int x = 5;\n    boolean b = x;\n}\n```\n\n\nDynamic Typing\n\nDynamic typing means that types are only known as your program is running. For example, the following Python (3, if it matters) script can be run without problems:\n\n```\ndef erroneous():\n    s = 'cat' - 1\n\nprint('hi!')\n```\n\n\nIt will indeed output ```\nhi!```\n. But if we call ```\nerroneous```\n:\n\n```\ndef erroneous():\n    s = 'cat' - 1\n\nerroneous()\nprint('hi!')\n```\n\n\nA ```\nTypeError```\n will be raised at run-time when ```\nerroneous```\n is called.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "What is the difference between dynamic programming and greedy approach?\r\n                \r\nWhat is the main difference between dynamic programming and greedy approach in terms of usage?\n\nAs far as I understood, the greedy approach sometimes gives an optimal solution; in other cases, the dynamic programming approach gives an optimal solution. \n\nAre there any particular conditions which must be met in order to use one approach (or the other) to obtain an optimal solution?\n    ", "Answer": "\r\nBased on Wikipedia's articles.\nGreedy Approach\nA greedy algorithm is an algorithm that follows the problem solving heuristic of making\nthe locally optimal choice at each stage with the hope of finding a global optimum. In\nmany problems, a greedy strategy does not in general produce an optimal solution, but nonetheless a greedy heuristic may yield locally optimal solutions that approximate a global optimal solution in a reasonable time.\nWe can make whatever choice seems best at the moment and then solve the subproblems that arise later. The choice made by a greedy algorithm may depend on choices made so far but not on future choices or all the solutions to the subproblem. It iteratively makes one greedy choice after another, reducing each given problem into a smaller one.\nDynamic programming\nThe idea behind dynamic programming is quite simple. In general, to solve a given problem, we need to solve different parts of the problem (subproblems), then combine the solutions of the subproblems to reach an overall solution. Often when using a more naive method, many of the subproblems are generated and solved many times. The dynamic programming approach seeks to solve each subproblem only once, thus reducing the number of computations: once the solution to a given subproblem has been computed, it is stored or \"memo-ized\": the next time the same solution is needed, it is simply looked up. This approach is especially useful when the number of repeating subproblems grows exponentially as a function of the size of the input.\nDifference\nGreedy choice property\nWe can make whatever choice seems best at the moment and then solve the subproblems that arise later. The choice made by a greedy algorithm may depend on choices made so far but not on future choices or all the solutions to the subproblem. It iteratively makes one greedy choice after another, reducing each given problem into a smaller one. In other words, a greedy algorithm never reconsiders its choices.\nThis is the main difference from dynamic programming, which is exhaustive and is guaranteed to find the solution. After every stage, dynamic programming makes decisions based on all the decisions made in the previous stage, and may reconsider the previous stage's algorithmic path to solution.\nFor example, let's say that you have to get from point A to point B as fast as possible, in a given city, during rush hour. A dynamic programming algorithm will look into the entire traffic report, looking into all possible combinations of roads you might take, and will only then tell you which way is the fastest. Of course, you might have to wait for a while until the algorithm finishes, and only then can you start driving. The path you will take will be the fastest one (assuming that nothing changed in the external environment).\nOn the other hand, a greedy algorithm will start you driving immediately and will pick the road that looks the fastest at every intersection. As you can imagine, this strategy might not lead to the fastest arrival time, since you might take some \"easy\" streets and then find yourself hopelessly stuck in a traffic jam.\nSome other details...\nIn mathematical optimization, greedy algorithms solve combinatorial problems having the properties of matroids.\nDynamic programming is applicable to problems exhibiting the properties of overlapping subproblems and optimal substructure.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming with WCF\r\n                \r\nHas anybody got any kind of experience with dynamic programming using WCF. By dynamic programming I mean runtime consumption of WSDL's.\nI have found one blog entry/tool:\nhttp://blogs.msdn.com/vipulmodi/archive/2006/11/16/dynamic-programming-with-wcf.aspx\n\nHas anybody here found good tools for this?\n    ", "Answer": "\r\nThis is one of the weirder aspects of WCF.  You can dynamically create a channelfactory, but only with a known type.\n\nI came up with a solution that is not perfect, but does work:\n\nCreate an interface, \"IFoo\" which contains a single method, say ```\nExecute()```\n.  In your ESB, dynamically create a ```\nChannelFactory<IFoo>```\n for the endpoint that you want to connect to.  Set the connection properties (URI, etc.).\n\nNow, you can attach services dynamically to your ESB, provided that they always implement the \"IFoo\" interface.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Approaching Dynamic Programming\r\n                \r\nI have written a small program to calculate the factorial of a number using Dynamic Programming Technique.\n\n```\n#include<stdio.h>\n\nint fact(int n)\n{\n    int f[n],i;\n    f[0] = 1;\n\n    for(i=1;i<=n;i++)\n        f[i] = i * f[i-1];\n    return f[n];\n}\n\nint main(void)\n{\n    printf(\"\\n Factorial of %d is %d \",5,fact(5));\n    return 0;\n}\n```\n\n\nIs the approach of memorization correct? Because, dynamic programming involves recursion. But I have not included it here. So I am not sure of my approach.\n    ", "Answer": "\r\nYes, your approach of solving the problem is a very simple case of Dynamic Programming, where you store previously solved sub-problems to help you solve the actual problem. While the example you provided would be considered Dynamic Programming, it usually isn't called Memoization\n\nWhen someone says Memoization, it usually involves in a top-down approach of solving problems, where you assume you have already solved the sub-problems by structuring your program in a way that will solve sub-problems recursively. \nYou store, or memoize, the results of these sub-problems so that they will not be computed multiple times.\n\nLet me illustrate Memoization through an example: \n\nHere is a simple example of computing the nth Fibonacci of a number:\n\n```\nint fib(int n)\n{\n   if (n <= 1)\n      return n;\n   return fib(n-1) + fib(n-2);\n}\n```\n\n\nThe above code uses recursion to solve sub-problems (fib(n-1) and fib(n-2)) so that fib(n) can be solved in the end. It assumes that fib(n-1) and fib(n-2) are already solved in the way that it is structured. \n\nThough this code looks elegant, the running time is exponential, because you can solve fib(i), where i is a number less than n, multiple times. You can look at the diagram presented here to see the tree generated by this problem: http://www.geeksforgeeks.org/program-for-nth-fibonacci-number.\n\nTo avoid the unnecessary re-computation, Memoization is used to optimizes run-time by using memory. \n\nHere is an optimized example of computing the nth Fibonacci number using Memoization: \n\n```\n/*Global array initialized to 0*/\nint a[100];\n\nint fib(int n)\n{\n    /*base case*/\n    if (n <= 1) \n        return n;\n    /*if fib(n) has not been computed, compute it*/\n    if (a[n] == 0) {\n        a[n] = fib(n - 1) + fib(n - 2);\n    }\n    */Otherwise, simply get a[n] and return it*/\n    return a[n];\n}  \n```\n\n\nAs you can see, the overall structure is not that much different from the recursive solution, but it runs linear time instead of exponential time because fib(i) will only be computed only if we have not computed already. \n\nIf I were to use your approach, Dynamic Programming, for the Fibonacci problem, it would look something like this: \n\n```\n int fib(int n)\n {\n   /* just like the array you declared in your solution */\n   int f[n+1];\n   int i;\n\n   /* set up the base cases, just like how you set f[0] to 1*/\n  f[0] = 0;\n  f[1] = 1;\n\n   for (i = 2; i <= n; i++)\n   {\n       /* using previously solved problem to solve further problems*/\n       f[i] = f[i-1] + f[i-2];\n   }\n     /*return the final result*/\n   return f[n];\n}\n```\n\n\nThere are more subtle differences, trade offs, and implications between Dynamic Programming and Memoization. Some consider Memoization a subset of Dynamic Programming. You can read more about the difference here: \n\nDynamic programming and memoization: bottom-up vs top-down approaches\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Why mergesort is not Dynamic programming\r\n                \r\nI have read these words:\n\n\n  There are two key attributes that a problem must have in order for dynamic programming to be applicable: optimal substructure and overlapping subproblems. If a problem can be solved by combining optimal solutions to non-overlapping subproblems, the strategy is called \"divide and conquer\". This is why mergesort and quicksort are not classified as dynamic programming problems.\n\n\nI have the 3 questions:\n\n\nWhy mergesort and quicksort is not Dynamic programming？\nI think mergesort also can be divided small problems and small problems then do the same thing and so on.\nIs Dijkstra Algorithm using dynamic algorithm?\nAre there applied examples of using Dynamic programming?\n\n    ", "Answer": "\r\n\nThe key words here are \"overlapping subproblems\" and \"optimal substructure\".  When you execute quicksort or mergesort, you are recursively breaking down your array into smaller pieces that do not overlap.  You never operate over the same elements of the original array twice during any given level of the recursion.  This means there is no opportunity to re-use previous calculations.  On the other hand, many problems DO involve performing the same calculations over overlapping subsets, and have the useful characteristic that an optimal solution to a subproblem can be re-used when computing the optimal solution to a larger problem.\nDijkstra's algorithm is a classic example of dynamic programming, as it re-uses prior computations to discover the shortest path between two nodes A and Z.  Say that A's immediate neighbors are B and C.  We can find the shortest path from A to Z by summing the distance between A and B with our computed shortest path from B to Z; and do similarly for finding the shortest path from C to Z.  Then the shortest path from A to Z will be the shorter of these two paths.   The key insight here is that we can re-use the shortest path computations for paths of length 2 when computing the shortest paths of length 3, and so on.  Doing so results in a much more efficient algorithm.\nDynamic programming can be used to solve many types of problems -- see http://en.wikipedia.org/wiki/Dynamic_programming#Examples:_Computer_algorithms for some examples.\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "What qualifies a programming language as dynamic?\r\n                \r\nWhat qualifies a programming language to be called dynamic language?  What sort of problems should I use a dynamic programming language to solve?  What is the main difference between static programming languages and dynamic programming languages?\n    ", "Answer": "\r\nI don't think there is black and white here - there is a whole spectrum between dynamic and static. \n\nLet's take two extreme examples for each side of the spectrum, and see where that takes us.\n\nHaskell is an extreme in the static direction. \n\n\nIt has a powerful type system that is checked at compile time: If your program compiles it is free from common and not so common errors.  \nThe compiled form is very different from the haskell program (it is a binary). Consequently runtime reflection and modification is hard, unless you have foreseen it. In comparison to interpreting the original, the result is potentially more efficient, as the compiler is free to do funky optimizations.\n\n\nSo for static languages I usually think: fairly lengthy compile-time analysis needed, type system will prevent me from making silly mistakes but also from doing some things that are actually valid, and if I want to do any manipulation of a program at runtime, it's going to be somewhat of a pain because the runtime representation of a program (i.e. its compiled form) is different from the actual language itself. Also it could be a pain to modify things later on if I have not foreseen it.\n\nClojure is an extreme in the dynamic direction.\n\n\nIt too has a type system, but at compile time there is no type checking. Many common errors can only be discovered by running the program.\nClojure programs are essentially just Clojure lists (the data structure) and can be manipulated as such. So when doing runtime reflection, you are actually processing a Clojure program more or less as you would type it - the runtime form is very close to the programming language itself. So you can basically do the same things at runtime as you could at \"type time\". Consequently, runtime performance may suffer because the compiler can't do many up-front optimizations.\n\n\nFor dynamic languages I usually think: short compilation step (basically just reading syntax), so fast and incremental development, practically no limits to what it will allow me to do, but won't prevent me from silly mistakes.\n\nAs other posts have indicated, other languages try to take more of a middle ground - e.g. static languages like F# and C# offer reflection capabilities through a separate API, and of course can offer incremental development by using clever tools like F#'s REPL. Dynamic languages  sometimes offer optional typing (like Racket, Strongtalk), and generally, it seems, have more advanced testing frameworks to offset the lack of any sanity checking at compile time. Also type hints, while not checked at compile time, are useful hints to generate more efficient code (e.g. Clojure).\n\nIf you are looking to find the right tool for a given problem, then this is certainly one of the dimensions you can look at - but by itself is not likely to force a decision either way. Have a think about the other properties of the languages you are considering - is it a functional or OO or logic or ... language? Does it have a good framework for the things I need? Do I need stability and binary backwards compatibility, or can I live with some churn in the compiler? Do I need extensive tooling?Etc. \n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming?\r\n                \r\nIm struggling how to find the maximum amount of dollars that you can achieve with a specified limit on the number of transactions using Dynamic Programming\n    ", "Answer": "\r\nThis not an elegant solution but it will work for this particular problem (I'm guessing we have the same professor).\n\nThe logic is that for each V[n][c] we want to find the highest value possible for each unit of currency, and in order to do this we must calculate the maximum value out of 6 vales.\n\nThere are 6 values because there are 3 currencies, and each of those currencies has two possible ways that it can be converted into the target currency.\n\nIn this case since there are only 2 exchanges I simply do two statements rather than another loop. This is represented by the 0 in the array: rates[0][i][c]\n\nI hope this helps!\n\n```\n    for (int n = 1; n <= numberOfTransactions; n++) {\n        for (int c = 0; c < numberOfcurrencies; c++) {\n            double max = Double.NEGATIVE_INFINITY;\n            double temp;\n            for (int i = 0; i < numberOfcurrencies;i++) {\n                temp = rates[0][i][c]*V[n-1][i];\n                if (temp > max)\n                    max = temp;\n                temp = rates[1][i][c]*V[n-1][i];\n                if (temp > max)\n                    max = temp;\n            }\n            V[n][c] = max;\n        }\n    }\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Good examples, articles, books for understanding dynamic programming [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is off-topic. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 11 years ago.\r\n        \r\n\r\n\r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                Locked. This question and its answers are locked because the question is off-topic but has historical significance. It is not currently accepting new answers or interactions.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n\r\n\r\n    \r\n\r\nI can't figure out the principles of dynamic programming and I really do want it. DP is very powerful, it can solve problems like this:\n\nGetting the lowest possible sum from numbers' difference\n\nSo, can you suggest me good books or articles (preferably with examples with real code) which would explain me what is dynamic programming? I really want simple examples first of all, then I'll move on.\n    ", "Answer": "\r\nDynamic programming is a useful type of algorithm that can be used to optimize hard problems by breaking them up into smaller subproblems. By storing and re-using partial solutions, it manages to avoid the pitfalls of using a greedy algorithm. There are two kinds of dynamic programming, bottom-up and top-down.\nIn order for a problem to be solvable using dynamic programming, the problem must possess the property of what is called an optimal substructure. This means that, if the problem was broken up into a series of subproblems and the optimal solution for each subproblem was found, then the resulting solution would be realized through the solution to these subproblems. A problem that does not have this structure cannot be solved with dynamic programming.\nTop-Down\nTop-down is better known as memoization. It is the idea of storing past calculations in order to avoid re-calculating them each time.\nGiven a recursive function, say:\n```\nfib(n) = 0 if n = 0\n         1 if n = 1\n         fib(n - 1) + fib(n - 2) if n >= 2\n```\n\nWe can easily write this recursively from its mathematic form as:\n```\nfunction fib(n)\n  if(n == 0 || n == 1)\n    n\n  else\n    fib(n-1) + fib(n-2)\n```\n\nNow, anyone that has been programming for awhile or knows a thing or two about algorithmic efficiency will tell you that this is a terrible idea. The reason is that, at each step, you must to re-calculate the value of fib(i), where i is 2..n-2.\nA more efficient example of this is storing these values, creating a top-down dynamic programming algorithm.\n```\nm = map(int, int)\nm[0] = 0\nm[1] = 1\nfunction fib(n)\n  if(m[n] does not exist)\n    m[n] = fib(n-1) + fib(n-2)\n```\n\nBy doing this, we calculate fib(i) at most once.\n\nBottom-Up\nBottom-up uses the same technique of memoization that is used in top-down. The difference, however, is that bottom-up uses comparative sub-problems known as recurrences to optimize your final result.\nIn most bottom-up dynamic programming problems, you are often trying to either minimize or maximize a decision. You are given two (or more) options at any given point and you have to decide which is more optimal for the problem you're trying to solve. These decisions, however, are based on previous choices you made.\nBy making the most optimal decision at each point (each subproblem), you are making sure that your overall result is the most optimal.\nThe most difficult part of these problems is finding the recurrence relationships for solving your problem.\nTo pay for a bunch of algorithm textbooks, you plan to rob a store that has n items. The problem is that your tiny knapsack can only hold at most W kg. Knowing the weight (w[i]) and value (v[i]) of each item, you want to maximize the value of your stolen goods that all together weight at most W. For each item, you must make a binary choice - take it or leave it.\nNow, you need to find what the subproblem is. Being a very bright thief, you realize that the maximum value of a given item, i, with a maximum weight, w, can be represented m[i, w]. In addition, m[0, w] (0 items at most weight w) and m[i, 0] (i items with 0 max weight)  will always be equal to 0 value.\nso,\n```\nm[i, w] = 0 if i = 0 or w = 0\n```\n\nWith your thinking full-face mask on, you notice that if you have filled your bag with as much weight as you can, a new item can't be considered unless its weight is less than or equal to the difference between your max weight and the current weight of the bag. Another case where you might want to consider an item is if it has less than or equal weight of an item in the bag but more value.\n```\n m[i, w] = 0 if i = 0 or w = 0\n           m[i - 1, w] if w[i] > w\n           max(m[i - 1, w], m[i - 1, w - w[i]] + v[i]) if w[i] <= w\n```\n\nThese are the recurrence relations described above. Once you have these relations, writing the algorithm is very easy (and short!).\n```\nv = values from item1..itemn\nw = weights from item1..itemn\nn = number of items\nW = maximum weight of knapsack\n   \nm[n, n] = array(int, int)\nfunction knapsack\n  for w=0..W\n    m[0, w] = 0\n  for i=1 to n\n    m[i, 0] = 0\n    for w=1..W\n      if w[i] <= w\n        if v[i] + m[i-1, w - w[i]] > m[i-1, w]\n           m[i, w] = v[i] + m[i-1, w - w[i]]\n        else\n           m[i, w] = m[i-1, w]\n      else\n        m[i, w] = c[i-1, w]\n  \n  return m[n, n]\n```\n\n\nAdditional Resources\n\nIntroduction to Algorithms\nProgramming Challenges\nAlgorithm Design Manual\n\n\nExample Problems\nLuckily, dynamic programming has become really in when it comes to competitive programming. Check out Dynamic Programming on UVAJudge for some practice problems that will test your ability to implement and find recurrences for dynamic programming problems.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming with sets\r\n                \r\nI have a typical question in dynamic programming.\n\nMy question is given an array = {1,2,3,4,5,6}, I have to find all the arrays whose sum is atmost k. If I consider all the sets, it will become exponential alogorthm.  I thought of achiveng this by Dynamic Programming. \n\n```\nSuppose f k =7,\nMy idea is \nPass 1: {1],{2}....{6}\nPass 2: Pass1 + {1,2},{1,3},{1,4},{1,5}\nPass 3: Pass2 + {1,2,3},\n```\n\n\nAnd my algo stops.\n\nIm not able to formulate this with dynamic programming. Any inputs?? How to formulate this algo into program?\n    ", "Answer": "\r\nA DP solution for the problem should follow the next recursive formula, and build bottom-up:\n\n```\nf(i,0) = {{}} //a set containing only an empty set\nf(0,W) = {{}} (W > 0)\nf(0,W) = {} (W < 0) //an empty set\nf(i,W) = f(i-1,W) [union] extend(f(i-1,w-element[i]),element[i])\n```\n\n\nWhere the function extend(set,e) is:\n\n```\nextend(set,e):\n   for each s in set: //s is a set itself\n      s.add(e) \n```\n\n\nNote that complexity could still be exponential (and not even pseudo-polynomial), since the number of sets generated could be exponential, and is stored in the DP table.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "How is \"dynamic\" programming different than \"normal\" programming?\r\n                \r\nWhenever I look at solutions to computer contests, I always see the term \"dynamic programming\". I Googled the term and read a few articles, but none of them provide a simple example of programming VS \"dynamic\" programming. So how is \"dynamic\" programming different than \"normal\" programming? (simple terms please!)\n    ", "Answer": "\r\nDynamic Programming uses programming more in the sense used with Linear Programming -- a mechanism of solving a problem.\n\nOne description I recently read (but can no longer recall the source -- [citation needed]) suggested that the usual approach of divide and conquer used in recursion is a top-down approach to solving problems, while dynamic programming is a bottom-up approach to solving problems.\n\nThe Wikipedia article suggests computing the Fibonocci sequence is an excellent use of dynamic programming -- you memoize results as you compute them for further use in the algorithm, to avoid re-computing similar results.\n\nKnuth's algorithm for line-breaking paragraphs is another good example of dynamic programming: if you consider the possibility of inserting line breaks between every word (and even breaking lines inside words, at hyphenation points), it feels like the only algorithms will be exponential -- or worse. However, by keeping track of the \"badness\" associated with previous line breaks, Knuth's algorithm actually runs in linear time with the size of the input. (I must admit that I don't fully understand Knuth's algorithm -- only that it is supremely clever.)\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Is dynamic programming backtracking with cache\r\n                \r\nI've always wondered about this. And no books state this explicitly.\nBacktracking is exploring all possibilities until we figure out one possibility cannot lead us to a possible solution, in that case we drop it.\nDynamic programming as I understand it is characterized by overlapping sub-problems. So, can dynamic programming can be stated as backtracking with cache (for previously explored paths) ?\nThanks\n    ", "Answer": "\r\nThis is one face of dynamic programming, but there's more to it.\n\nFor a trivial example, take Fibonacci numbers:\n\n```\nF (n) =\n        n = 0:  0\n        n = 1:  1\n        else:   F (n - 2) + F (n - 1)\n```\n\n\nWe can call the above code \"backtracking\" or \"recursion\".\nLet us transform it into \"backtracking with cache\" or \"recursion with memoization\":\n\n```\nF (n) =\n       n in Fcache:  Fcache[n]\n       n = 0:  0, and cache it as Fcache[0]\n       n = 1:  1, and cache it as Fcache[1]\n       else:  F (n - 2) + F (n - 1), and cache it as Fcache[n]\n```\n\n\n\n\nStill, there is more to it.\n\nIf a problem can be solved by dynamic programming, there is a directed acyclic graph of states and dependencies between them.\nThere is a state that interests us.\nThere are also base states for which we know the answer right away.\n\n\nWe can traverse that graph from the vertex that interests us to all its dependencies, from them to all their dependencies in turn, etc., stopping to branch further at the base states.\nThis can be done via recursion.\nA directed acyclic graph can be viewed as a partial order on vertices. We can topologically sort that graph and visit the vertices in sorted order.\nAdditionally, you can find some simple total order which is consistent with your partial order.\n\n\nAlso note that we can often observe some structure on states.\nFor example, the states can be often expressed as integers or tuples of integers.\nSo, instead of using generic caching techniques (e.g., associative arrays to store state->value pairs), we may be able to preallocate a regular array which is easier and faster to use.\n\n\n\nBack to our Fibonacci example, the partial order relation is just that state ```\nn >= 2```\n depends on states ```\nn - 1```\n and ```\nn - 2```\n.\nThe base states are ```\nn = 0```\n and ```\nn = 1```\n.\nA simple total order consistent with this order relation is the natural order: ```\n0```\n, ```\n1```\n, ```\n2```\n, ```\n...```\n.\nHere is what we start with:\n\n```\nPreallocate array F with indices 0 to n, inclusive\nF[0] = 0\nF[1] = 1\n```\n\n\nFine, we have the order in which to visit the states.\nNow, what's a \"visit\"?\nThere are again two possibilities:\n\n(1) \"Backward DP\": When we visit a state ```\nu```\n, we look at all its dependencies ```\nv```\n and calculate the answer for that state ```\nu```\n:\n\n```\nfor u = 2, 3, ..., n:\n    F[u] = F[u - 1] + F[u - 2]\n```\n\n\n(2) \"Forward DP\": When we visit a state ```\nu```\n, we look at all states ```\nv```\n that depend on it and account for ```\nu```\n in each of these states ```\nv```\n:\n\n```\nfor u = 1, 2, 3, ..., n - 1:\n    add F[u] to F[u + 1]\n    add F[u] to F[u + 2]\n```\n\n\nNote that in the former case, we still use the formula for Fibonacci numbers directly.\nHowever, in the latter case, the imperative code cannot be readily expressed by a mathematical formula.\nStill, in some problems, the \"forward DP\" approach is more intuitive (no good example for now; anyone willing to contribute it?).\n\n\n\nOne more use of dynamic programming which is hard to express as backtracking is the following: Dijkstra's algorithm can be considered DP, too.\nIn the algorithm, we construct the optimal paths tree by adding vertices to it.\nWhen we add a vertex, we use the fact that the whole path to it - except the very last edge in the path - is already known to be optimal.\nSo, we actually use an optimal solution to a subproblem - which is exactly the thing we do in DP.\nStill, the order in which we add vertices to the tree is not known in advance.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming - Largest square block\r\n                \r\nI need to find the largest square of 1's in a giant file full of 1's and 0's. I know i have to use dynamic programming. I am storing it in a 2D array. Any help with the algorithm to find the largest square would be great, thanks!\n\nexample input:\n\n```\n1 0 1 0 1 0\n1 0 1 1 1 1\n0 1 1 1 1 1\n0 0 1 1 1 1\n1 1 1 1 1 1\n```\n\n\nanswer:\n\n```\n1 1 1 1\n1 1 1 1\n1 1 1 1\n1 1 1 1\n```\n\n\nMy code so far:\n\n```\nint Square (Sq[int x][int y]) {\n   if (Sq[x][y]) == 0) {\n       return 0;\n   }\n   else {\n       return 1+MIN( Sq(X-1,Y), Sq(X,Y-1), Sq(X-1,Y-1) );\n   }\n}\n```\n\n\n(assuming values already entered into the array)\n\n```\nint main() {\n    int Sq[5][6]; //5,6 = bottom right conner\n    int X = Square(Sq[5][6]);\n}\n```\n\n\nHow do I go on from there?\n    ", "Answer": "\r\nHere is a sketch of the solution:\n\nFor each of the cells we will keep a counter of how big a square can be made using that cell as top left. Clearly all cells with 0 will have 0 as the count.\n\nStart iterating from bottom right cell and go to bottom left, then go to one row up and repeat.\n\nAt each scan do this: \n\n\nIf the cell has 0 assign ```\ncount=0```\n\nIf the cell has 1 and is an edge cell (bottom or right edge only), assign ```\ncount=1```\n\nFor all other cells, check the count of the cell on its right, right-below, and below. Take the min of them and add 1 and assign that to the count. Keep a global ```\nmax_count```\n variable to keep track of the max count so far.\n\n\nAt the end of traversing the matrix, ```\nmax_count```\n will have the desired value.\n\nComplexity is no more that the cost of traversal of the matrix.\n\nThis is how the matrix will look like after the traversal. Values in parentheses are the counts, i.e. biggest square that can be made using the cell as top left.\n\n```\n1(1) 0(0) 1(1) 0(0) 1(1) 0(0)\n1(1) 0(0) 1(4) 1(3) 1(2) 1(1)\n0(0) 1(1) 1(3) 1(3) 1(2) 1(1)\n0(0) 0(0) 1(2) 1(2) 1(2) 1(1)\n1(1) 1(1) 1(1) 1(1) 1(1) 1(1)\n```\n\n\nImplementation in Python\n\n```\ndef max_size(mat, ZERO=0):\n    \"\"\"Find the largest square of ZERO's in the matrix `mat`.\"\"\"\n    nrows, ncols = len(mat), (len(mat[0]) if mat else 0)\n    if not (nrows and ncols): return 0 # empty matrix or rows\n    counts = [[0]*ncols for _ in xrange(nrows)]\n    for i in reversed(xrange(nrows)):     # for each row\n        assert len(mat[i]) == ncols # matrix must be rectangular\n        for j in reversed(xrange(ncols)): # for each element in the row\n            if mat[i][j] != ZERO:\n                counts[i][j] = (1 + min(\n                    counts[i][j+1],  # east\n                    counts[i+1][j],  # south\n                    counts[i+1][j+1] # south-east\n                    )) if i < (nrows - 1) and j < (ncols - 1) else 1 # edges\n    return max(c for rows in counts for c in rows)\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "iterative solution as dynamic programming\r\n                \r\nWikipedia says this about dynamic programming :\n\n\n  In mathematics, computer science, economics, and bioinformatics, dynamic programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems. It is applicable to problems exhibiting the properties of overlapping subproblems and optimal substructure. When applicable, the method takes far less time than other methods that don't take advantage of the subproblem overlap (like depth-first search).\n\n\nand also from ```\nIntroduction to Algorithms (Cormen)```\n , I have learnt that ```\ndynamic programming```\n is a method applied to solve ```\nrepeating computations```\n that have ```\nalready been computed once```\n. In layman's terms , \n\n\n  if you're going to compute something again and again , better store it somewhere.\n\n\nApplying this on Fibonacci I could write its algorithm as follows :\n\n```\narr[3] = {1,1,1} //first two index for computation , last to keep track\n\nfibbDyn(n){\n    if(n>=1 || a[2]>n ) return n;    // return on base conditions\n    else {\n        res = arr[0] + fibbDyn(n-1); \n        arr[0]=arr[1];\n        arr[1]=res; \n        arr[2]+=1;    // increment value by 1\n        return res;\n    }\n} \n```\n\n\nWhile I believe this algorithm follows the example of dynamic programming as it reduces the extra computations being done in original recursive fibbonaci version :\n\n```\n fibb(n){\n    if (n>=1)return n;\n    else return fibb(n-1) + fibb(n-2);\n}\n```\n\n\nas here due to two separate calls at each recursive step ```\nelse return fibb(n-1) + fibb(n-2)```\n many computations are repeated.\n\nan iterative solution will probably look like :\n\n```\nint FibonacciIterative(int n)\n{\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n\n    int prevPrev = 0;\n    int prev = 1;\n    int result = 0;\n\n    for (int i = 2; i <= n; i++)\n    {\n        result = prev + prevPrev;\n        prevPrev = prev;\n        prev = result;\n    }\n    return result;\n}\n```\n\n\nSo my question is , will an iterative solution to Fibonacci problem be classified as dynamic programming? \n\nMy reasoning for a disagreement is that , an iterative solution dosen't exhibits ```\nOverlapping subproblems```\n such as an recursive solution is exhibiting. In an iterative solution , there are no redundant and repetitive computations being made , so it shouldn't be included in dynamic programming.\n\nrelevant articles : optimal substructure , overlapping subproblems , \ndynamic programming.\n    ", "Answer": "\r\nYes. That's just a special case of Bottom Up dynamic programming. You're allowed to discard table entries that you know you will never use again, in the case of Fibonacci that means you only need to keep 2 entries, and then you can forget it was ever a table and just use two named variables. So, it ends up looking different, almost too simple. But the structure of that algorithm is still DP. The overlapping subproblems that you say aren't there are still there, because you use every result twice (once when it's in ```\nprev```\n, again when it's in ```\nprevPrev```\n), except in the end. Of course there are no redundant computations made, but then that's the idea of DP - remove redundant computation by reuse.\n\nThere is a general \"plan of attack\" for problems that allow dynamic programming, namely\n\n\nstate the problem recursively\n(prove that DP can be applied)\nidentify an ordering of sub-problems such that they are topologically sorted (so computing a solution relies only on trivial solutions and previously-computed solutions, not on future ones)\nfill a table iteratively in that order, if there was a nice order. Maybe keep the Top Down structure if the order is annoying.\n\n\nIn the case of Fibonacci, what happened is that the order is trivial (that's not even particularly uncommon, but it makes it look as if we're \"not really doing anything special\"), and the dependencies never go back more than 2 places, so the only part of the table that has to be remembered is the previous two cells. So applying all that, you get the well-known iterative algorithm. That doesn't mean it's not DP anymore, it means that the DP was extremely successful.\n\nAs for the properties (optimal substructure, overlapping subproblems), they're properties of the problem, they don't go away no matter how you decide to solve it. But you can still see them back in the iterative algorithm, as I pointed out in the first paragraph.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming and Functional Programming\r\n                \r\nIs there any example or reference which demonstrates a Dynamic programming solution which has been built with Functional Programming principles. I have seen some Haskell examples with lazy evaluation, but can anyone give a JavaScript example.\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Fibonacci Series using Dynamic Programming\r\n                \r\nLet us consider the implementation of Fibonacci series using dynamic programming.\n\n```\n// Fibonacci Series using Dynamic Programming\nclass fibonacci\n{\nstatic int fib(int n)\n{\n    /* Declare an array to store Fibonacci numbers. */\nint f[] = new int[n+1];\nint i;\n\n/* 0th and 1st number of the series are 0 and 1*/\nf[0] = 0;\nf[1] = 1;\n\nfor (i = 2; i <= n; i++)\n{\n   /* Add the previous 2 numbers in the series\n     and store it */\n    f[i] = f[i-1] + f[i-2];\n}\n\nreturn f[n];\n}\n\npublic static void main (String args[])\n{\n    int n = 9;\n    System.out.println(fib(n));\n}\n} \n```\n\n\nWe use the dynamic programming so that the repetition of the recursive work does not occur. But here when every time the function has been called,a new array will be generated. So how could this algorithm is said to be more optimized ?   \n    ", "Answer": "\r\none optimization would be only save the last 2 values instead of all results. You don't need to store all your results. \n\nyou also can write the fibonacci series recursively in O(n):\n\n```\nint fib(int n1, int n2, int counter)\n{\n    if(counter == 0)\n    {\n        return n2;\n    }\n    else\n    {\n        return fib(n2,n2 + n1,counter-1);\n    }\n}\n\n//to start:\nint result = fib(0,1,100); //gives you the 100 fibonacci value\n```\n\n\nThis code runs recursively and is easy to read. You don't have to initialize an array or other stuff.\n\nalternatively you can use the nonrecursive option:\n\n```\nint fib(int number)\n{\n    int n1 = 0;\n    int n2 = 1;\n    int temp;\n    for(int i = 0; i< number;i++)\n    {\n        temp = n1 + n2;\n        n1 = n2;\n        n2 = temp;\n    }\n    return n2;\n}\n```\n\n\nIf you want to store your results, you have to initialize the array outside of your fib function:\n\n```\n// Fibonacci Series using Dynamic Programming\nclass fibonacci\n{\n    /* Declare an array to store Fibonacci numbers. */\n    int f[];\n\n    static void init(int n)\n    {    /* 0th and 1st number of the series are 0 and 1*/\n        f = new int[n+1];            \n        f[0] = 0;\n        f[1] = 1;\n    }\n\n    static int fib(int n)\n    {\n        int i;\n\n        for (i = 2; i <= n; i++)\n        {\n           /* Add the previous 2 numbers in the series\n             and store it */\n            f[i] = f[i-1] + f[i-2];\n        }\n\n        return f[n];\n    }\n\n    public static void main (String args[])\n    {\n        int n = 9;\n        init(n);\n        System.out.println(fib(n));\n    }\n} \n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Fibonacci Series using Dynamic Programming\r\n                \r\nLet us consider the implementation of Fibonacci series using dynamic programming.\n\n```\n// Fibonacci Series using Dynamic Programming\nclass fibonacci\n{\nstatic int fib(int n)\n{\n    /* Declare an array to store Fibonacci numbers. */\nint f[] = new int[n+1];\nint i;\n\n/* 0th and 1st number of the series are 0 and 1*/\nf[0] = 0;\nf[1] = 1;\n\nfor (i = 2; i <= n; i++)\n{\n   /* Add the previous 2 numbers in the series\n     and store it */\n    f[i] = f[i-1] + f[i-2];\n}\n\nreturn f[n];\n}\n\npublic static void main (String args[])\n{\n    int n = 9;\n    System.out.println(fib(n));\n}\n} \n```\n\n\nWe use the dynamic programming so that the repetition of the recursive work does not occur. But here when every time the function has been called,a new array will be generated. So how could this algorithm is said to be more optimized ?   \n    ", "Answer": "\r\none optimization would be only save the last 2 values instead of all results. You don't need to store all your results. \n\nyou also can write the fibonacci series recursively in O(n):\n\n```\nint fib(int n1, int n2, int counter)\n{\n    if(counter == 0)\n    {\n        return n2;\n    }\n    else\n    {\n        return fib(n2,n2 + n1,counter-1);\n    }\n}\n\n//to start:\nint result = fib(0,1,100); //gives you the 100 fibonacci value\n```\n\n\nThis code runs recursively and is easy to read. You don't have to initialize an array or other stuff.\n\nalternatively you can use the nonrecursive option:\n\n```\nint fib(int number)\n{\n    int n1 = 0;\n    int n2 = 1;\n    int temp;\n    for(int i = 0; i< number;i++)\n    {\n        temp = n1 + n2;\n        n1 = n2;\n        n2 = temp;\n    }\n    return n2;\n}\n```\n\n\nIf you want to store your results, you have to initialize the array outside of your fib function:\n\n```\n// Fibonacci Series using Dynamic Programming\nclass fibonacci\n{\n    /* Declare an array to store Fibonacci numbers. */\n    int f[];\n\n    static void init(int n)\n    {    /* 0th and 1st number of the series are 0 and 1*/\n        f = new int[n+1];            \n        f[0] = 0;\n        f[1] = 1;\n    }\n\n    static int fib(int n)\n    {\n        int i;\n\n        for (i = 2; i <= n; i++)\n        {\n           /* Add the previous 2 numbers in the series\n             and store it */\n            f[i] = f[i-1] + f[i-2];\n        }\n\n        return f[n];\n    }\n\n    public static void main (String args[])\n    {\n        int n = 9;\n        init(n);\n        System.out.println(fib(n));\n    }\n} \n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming - Fibonacci\r\n                \r\nSo basically, I am a learning programmer and this week I was introduced to dynamic programming. Our task was to find the Fibonacci sequence using dynamic programming. This pseudo code was supplied which would obviously be in a function:\n\n```\ninit table to 0s\nif n ≤ 1\n   return n\nelse\n   if table[n-1] = 0\n      table[n-1] = dpFib(n-1)\n   if table[n-2] = 0\n      table[n-2] = dpFib(n-2)\n   table[n] = table[n-1] + table[n-2]\nreturn table[n]\n```\n\n\nThe majority of this was simple to change to code but I'm not sure how to initialise the table of 0s. I know it should be a list but I'm not sure if it should be inside the function or outside or how many zeros I should initialise it with. This is what I wrote, nothing complicated:\n\n```\ndef dynamicFibo(n):\n   # initialise table of 0s\n   #base case\n   if n <= 1:\n       return n\n   #recursive case\n   else:\n       if table[n-1] ==  0:\n           table[n-1] = dynamicFibo(n-1)\n\n       if table[n-2] ==  0:\n           table[n-2] = dynamicFibo(n-2)\n\n       table[n] = table[n-2] + table[n-2]\n   return table[n]\n```\n\n\nI would be thankful if someone could show me the way to go with this. Also, in general I struggle to understand the basis of dynamic programming so if there are any good resources you could suggest I would be delighted, or even if you could give a good explanation. \n    ", "Answer": "\r\nyou can initialize your ```\ntable```\n with:\n\n```\ntable = [0 for _ in range(n+1)]\n```\n\n\nsince you want to have at least ```\nn+1```\n items in your table to allow to access ```\ntable[n]```\n (remember that lists are zero-indexed so the ```\nnth```\n item is accessed with ```\n(n-1)```\n)\n\nHowever, you would want to ensure that you are not creating new lists every time since that would defeat the purpose of dynamic programming. So you can have ```\ntable```\n as what I call an \"invisible\" parameter, ie a parameter with a default parameter that is used at every recursive call. Your function would then look like this:\n\n```\n>>> def dynamicFibo(n,table = []):\n   while len(table) < n+1: table.append(0) #this does the same thing except it doesn't change the reference to `table`\n   #base case\n   if n <= 1:\n       return n\n   #recursive case\n   else:\n       if table[n-1] ==  0:\n           table[n-1] = dynamicFibo(n-1)\n\n       if table[n-2] ==  0:\n           table[n-2] = dynamicFibo(n-2)\n\n       table[n] = table[n-2] + table[n-1]\n   return table[n]\n>>> dynamicFibo(12)\n144\n>>> dynamicFibo(300)\n222232244629420445529739893461909967206666939096499764990979600\n```\n\n\nreference\n\nas you can see, I used a while loop instead of a list comprehension. This is essentially the same thing except we cannot be changing the reference of ```\ntable```\n or else the recursive calls will create a new table each time unless you pass it in as a paramater. This also allows the table to expand as necessary if you call ```\ndynamicFibo```\n more than once with increasing numbers, but maintain all the old numbers. This is clearly seen by adding a ```\nprint(table)```\n line in the function:\n\n```\n>>> dynamicFibo(12)\n[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n[0, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n[0, 1, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0]\n[0, 1, 1, 2, 3, 5, 0, 0, 0, 0, 0, 0, 0]\n[0, 1, 1, 2, 3, 5, 8, 0, 0, 0, 0, 0, 0]\n[0, 1, 1, 2, 3, 5, 8, 13, 0, 0, 0, 0, 0]\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 0, 0, 0, 0]\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 0, 0, 0]\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 0, 0]\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 0]\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]\n144\n>>> dynamicFibo(14)\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 0]\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]\n377\n```\n\n\nI added the ```\nprint(table)```\n right before ```\nreturn table[n]```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Static linking vs dynamic linking\r\n                \r\nAre there any compelling performance reasons to choose static linking over dynamic linking or vice versa in certain situations? I've heard or read the following, but I don't know enough on the subject to vouch for its veracity.\n\n1) The difference in runtime performance between static linking and dynamic linking is usually negligible.\n\n2) (1) is not true if using a profiling compiler that uses profile data to optimize program hotpaths because with static linking, the compiler can optimize both your code and the library code. With dynamic linking only your code can be optimized. If most of the time is spent running library code, this can make a big difference. Otherwise, (1) still applies.\n    ", "Answer": "\r\n\nDynamic linking can reduce total resource consumption (if more than one process shares the same library (including the version in \"the same\", of course)). I believe this is the argument that drives its presence in most environments. Here \"resources\" include disk space, RAM, and cache space. Of course, if your dynamic linker is insufficiently flexible there is a risk of DLL hell.\nDynamic linking means that bug fixes and upgrades to libraries propagate to improve your product without requiring you to ship anything.\nPlugins always call for dynamic linking.\nStatic linking, means that you can know the code will run in very limited environments (early in the boot process, or in rescue mode).\nStatic linking can make binaries easier to distribute to diverse user environments (at the cost of sending a larger and more resource-hungry program).\nStatic linking may allow slightly faster startup times, but this depends to some degree on both the size and complexity of your program and on the details of the OS's loading strategy.\n\n\nSome edits to include the very relevant suggestions in the comments and in other answers. I'd like to note that the way you break on this depends a lot on what environment you plan to run in. Minimal embedded systems may not have enough resources to support dynamic linking. Slightly larger small systems may well support dynamic linking because their memory is small enough to make the RAM savings from dynamic linking very attractive. Full-blown consumer PCs have, as Mark notes, enormous resources, and you can probably let the convenience issues drive your thinking on this matter.\n\nTo address the performance and efficiency issues: it depends.\nClassically, dynamic libraries require some kind of glue layer which often means double dispatch or an extra layer of indirection in function addressing and can cost a little speed (but is the function calling time actually a big part of your running time???).\nHowever, if you are running multiple processes which all call the same library a lot, you can end up saving cache lines (and thus winning on running performance) when using dynamic linking relative to using static linking. (Unless modern OS's are smart enough to notice identical segments in statically linked binaries. Seems hard, does anyone know?)\nAnother issue: loading time. You pay loading costs at some point. When you pay this cost depends on how the OS works as well as what linking you use. Maybe you'd rather put off paying it until you know you need it.\nNote that static-vs-dynamic linking is traditionally not an optimization issue, because they both involve separate compilation down to object files. However, this is not required: a compiler can in principle, \"compile\" \"static libraries\" to a digested AST form initially, and \"link\" them by adding those ASTs to the ones generated for the main code, thus empowering global optimization. None of the systems I use do this, so I can't comment on how well it works.\nThe way to answer performance questions is always by testing (and use a test environment as much like the deployment environment as possible).\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Lookup table and dynamic programming\r\n                \r\nIn old games era, we are used to have a look-up table of pre-computed values of sin and cos,..etc, due to the slowness of computing those values in that old CPUs.  \n\nIs that considered a dynamic programming technique ? or dynamic programming must solve a recursive function that is always computed or sort of ?\n\nUpdate: \nIn dynamic programming the key is to have a memoization table, which is the solution for the sin,cos look up table, so what is really the difference in the technique ?\n    ", "Answer": "\r\nI'd say for what I see in your question no it's not dynamic programming. Dynamic programming is more about solving problems by solving smaller subproblem and create way to get solution of problem from smaller subproblem.\n\nYour situation looks more like memoization.\n\nFor me it could be considered DP if your problem was to compute ```\ncos N```\n and you have formula to calculate ```\ncos i```\n from array of ```\ncos 0```\n, ```\ncos 1```\n, ..., ```\ncos i - 1```\n, so you calculate ```\ncos 1```\n, ```\nsin 1```\n and run you calculation for i from 0 to N.\n\nMay be somebody will correct me :)\n\nThere's also interesting quote about how ```\ndynamic programming```\n differ from ```\ndivide-and-conquer```\n paradigm:\n\n\n  There are two key attributes that a problem must have in order for\n  dynamic programming to be applicable: optimal substructure and\n  overlapping subproblems. If a problem can be solved by combining\n  optimal solutions to non-overlapping subproblems, the strategy is\n  called \"divide and conquer\" instead. This is why mergesort and\n  quicksort are not classified as dynamic programming problems.\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Can recursion be dynamic programming?\r\n                \r\nI was asked to use dynamic programming to solve a problem. I have mixed notes on what constitutes dynamic programming. I believe it requires a \"bottom-up\" approach, where smallest problems are solved first.\n\nOne thing I have contradicting information on, is whether something can be dynamic programming if the same subproblems are solved more than once, as is often the case in recursion.\n\nFor instance. For Fibonacci, I can have a recursive algorithm:\n\n```\nRecursiveFibonacci(n)\nif (n=1 or n=2)\n    return 1\nelse\n    return RecursiveFibonacci(n-1) + RecursiveFibonacci(n-2)\n```\n\n\nIn this situation, the same sub-problems may be solved over-and-over again. Does this render it is not dynamic programming? That is, if I wanted dynamic programming, would I have to avoid resolving subproblems, such as using an array of length n and storing the solution to each subproblem (the first indices of the array are 1, 1, 2, 3, 5, 8, 13, 21)?\n\n```\nFibonacci(n)\nF1 = 1\nF2 = 1\nfor i=3 to n\n    Fi=Fi-1 + Fi-2\nreturn Fn\n```\n\n    ", "Answer": "\r\nDynamic programs can usually be succinctly described with recursive formulas.  \n\nBut if you implement them with simple recursive computer programs, these are often inefficient for exactly the reason you raise: the same computation is repeated. Fibonacci is a example of repeated computation, though it is not a dynamic program.\n\nThere are two approaches to avoiding the repetition.\n\n\nMemoization.  The idea here is to cache the answer computed for each set of arguments to the recursive function and return the cached value when it exists.\nBottom-up table.  Here you \"unwind\" the recursion so that results at levels less than i are combined to the result at level i.  This is usually depicted as filling in a table, where the levels are rows.\n\n\nOne of these methods is implied for any DP algorithm. If computations are repeated, the algorithm isn't a DP.  So the answer to your question is \"yes.\"\n\nSo an example...  Let's try the problem of making change of c cents given you have coins with values v_1, v_2, ... v_n, using a minimum number of coins.\n\nLet N(c) be the minimum number of coins needed to make c cents.  Then one recursive formulation is\n\n```\nN(c) = 1 + min_{i = 1..n} N(c - v_i) \n```\n\n\nThe base cases are N(0)=0 and N(k)=inf for k<0.\n\nTo memoize this requires just a hash table mapping c to N(c).  \n\nIn this case the \"table\" has only one dimension, which is easy to fill in.  Say we have coins with values 1, 3, 5, then the N table starts with \n\n\nN(0) = 0, the initial condition.  \nN(1) = 1 + min(N(1-1), N(1-3), N(1-5) = 1 + min(0, inf, inf) = 1\nN(2) = 1 + min(N(2-1), N(2-3), N(2-5) = 1 + min(1, inf, inf) = 2\nN(3) = 1 + min(N(3-1), N(3-3), N(3-5) = 1 + min(2, 0, inf) = 1\n\n\nYou get the idea.  You can always compute N(c) from N(d), d < c in this manner.  \n\nIn this case, you need only remember the last 5 values because that's the biggest coin value.  Most DPs are similar.  Only a few rows of the table are needed to get the next one.  \n\nThe table is k-dimensional for k independent variables in the recursive expression.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming and backtack search\r\n                \r\nCan a backtrack  and \"branch and bound\" problem be always solved using dynamic programming?? i.e. given a problem which can be solved using a backtrack method be also solved using dynamic programming\n    ", "Answer": "\r\nIn the general case, whether dynamic programming can be applied, maybe. But whether dynamic programming will definitely lead to an efficient or a pseudo-efficient solution, no.\n\nFor example, there can be a number of NP complete Integer Linear Programming problems that need to be solve using branch & bound or through brute-force backtracking since dynamic programming formulation is not possible.\n\nFor example this question that I asked some time back, I could not form a DP formulation and I had to resort to finding a solver for my ILP problem. Strange but practical 2D bin packing optimization\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Global Minima and Dynamic Programming\r\n                \r\nI understand that dynamic programming is a divide and conquer algorithm and use recursive to solve a problem, but I am having difficulty with dynamic programming can achieve to escape local minima?  \n    ", "Answer": "\r\nIn dynamic programming approaches, you evaluate all possible cases just like a brute force algorithm but only reuse solutions to sub problems that have already been computed. Thats why you always achieve the global solution to your problem.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming sum\r\n                \r\nHow would you use dynamic programming to find the list of positive integers in an array whose sum is closest to but not equal to some positive integer K?\n\nI'm a little stuck thinking about this.\n    ", "Answer": "\r\nThe usual phrasing for this is that you're looking for the value closest to, but not exceeding K. If you mean \"less than K\", it just means that your value of K is one greater than the usual. If you truly mean just \"not equal to K\", then you'd basically run through the algorithm twice, once finding the largest sum less than K, then again finding the smallest sum greater than K, then picking the one of those whose absolute difference from K is the smallest.\n\nFor the moment I'm going to assume you really mean the largest sum less than or equal to K, since that's the most common formulation, and the other possibilities don't really have much affect on the algorithm.\n\nThe basic idea is fairly simple, though it (at least potentially) uses a lot of storage. We build a table with K+1 columns and N+1 rows (where N = number of inputs). We initialize the first row in the table to 0's.\n\nThen we start walking through the table, and building the best value we can for each possible maximum value up to the real maximum, going row by row so we start with only a single input, then two possible inputs, then three, and so on. At each spot in the table, there are only two possibilities for the best value: the previous best value that doesn't use the current input, or else the current input plus the previous best value for the maximum minus the current input (and since we compute the table values in order, we'll always already have that value).\n\nWe also usually want to keep track of which items were actually used to produce the result. To do that, we set a Boolean for a given spot in the table to true if and only if we compute a value for that spot in the table using the new input for that row (rather than just copying the previous row's best value). The best result is in the bottom, right-hand corner, so we start there, and walk backward through the table one row at a time. When we get to a row where the Boolean for that column was set to true, we know we found an input that was used. We print out that item, and then subtract that from the total to get the next column to the left where we'll find the next input that was used to produce this output.\n\nHere's an implementation that's technically in C++, but written primarily in a C-like style to make each step as explicit as possible.\n\n```\n#include <iostream>\n#include <functional>\n\n#define elements(array) (sizeof(array)/sizeof(array[0]))\n\nint main() {\n\n    // Since we're assuming subscripts from 1..N, I've inserted a dummy value\n    // for v[0].\n    int v[] = {0, 7, 15, 2, 1};\n\n    // For the moment I'm assuming a maximum <= MAX.\n    const int MAX = 17;\n\n    // ... but if you want to specify K as the question implies, where sum<K, \n    // you can get rid of MAX and just specify K directly:\n    const int K = MAX + 1;\n\n    const int rows = elements(v);\n\n    int table[rows][K] = {0};\n    bool used[rows][K] = {false};\n\n    for (int i=1; i<rows; i++)\n        for (int c = 0; c<K; c++) {\n            int prev_val = table[i-1][c];\n            int new_val;\n\n            // we compute new_val inside the if statement so we won't \n            // accidentally try to use a negative column from the table if v[i]>c\n            if (v[i] <= c && (new_val=v[i]+table[i-1][c-v[i]]) > prev_val) {\n                table[i][c] = new_val;\n                used[i][c] = true;\n            }\n            else\n                table[i][c] = prev_val;\n        }\n\n    std::cout << \"Result: \" << table[rows-1][MAX] << \"\\n\";\n    std::cout << \"Used items where:\\n\";\n    int column = MAX;\n    for (int i=rows; i>-1; i--)\n        if (used[i][column]) {\n            std::cout << \"\\tv[\" << i << \"] = \" << v[i] << \"\\n\";\n            column -= v[i];\n        }\n\n    return 0;\n}\n```\n\n\nThere are a couple of things you'd normally optimize in this (that I haven't for the sake of readability). First, if you reach an optimum sum, you can stop searching, so in this case we could actually break out of the loop before considering the final input of ```\n1```\n at all (since ```\n15```\n and ```\n2```\n give the desired result of ```\n17```\n).\n\nSecond, in the table itself we only really use two rows at any given time: one current row and one previous row. The rows before that (in the main table) are never used again (i.e., to compute row[n] we need the values from ```\nrow[n-1]```\n, but not ```\nrow[n-2]```\n, ```\nrow[n-3]```\n, ... ```\nrow[0]```\n. To reduce storage, we can make the main table be only two rows, and we swap between the first and second rows. A very C-like trick to do that would be to use only the least significant bit of the row number, so you'd replace ```\ntable[i]```\n and ```\ntable[i-1]```\n with ```\ntable[i&1]```\n and ```\ntable[(i-1)&1]```\n respectively (but only for the main table -- not when addressing the ```\nused```\n table.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Q-learning vs dynamic programming\r\n                \r\nIs the classic Q-learning algorithm, using lookup table (instead of function approximation), equivalent to dynamic programming?\n    ", "Answer": "\r\nFrom Sutton & Barto's book (Reinforcement Learning: An Introduction, chapter 4)\n\n\n  The term dynamic programming (DP) refers to a collection of algorithms\n  that can be used to compute optimal policies given a perfect model of\n  the environment as a Markov decision process (MDP). Classical DP\n  algorithms are of limited utility in reinforcement learning both\n  because of their assumption of a perfect model and because of their\n  great computational expense, but they are still important\n  theoretically.\n\n\nSo, although both share the same working principles (either using tabular Reinforcement Learning/Dynamic Programming or approximated RL/DP), the key difference between classic DP and classic RL is that the first assume the model is known. This basically means knowing the transition probabilities (which indicates the probability of change from state s to state s' given action a) and the expected immediate reward function.\n\nOn the contrary, RL methods only require to have access to a set of samples, either collected online or offline (depending on the algorithm).\n\nOf course, there are hybrid methods that can be place between RL and DP, for example those that learn a model from the samples, and then use that model in the learning process.\n\nNOTE: The term Dynamic Programming, in addition to a set of mathematical optimization techniques related with RL, is also used to refer a \"general algorithmic pattern\", as pointed in some comment. In both case, the fundaments are the same, but depending on the context may have a different meaning.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Limitations of Dynamic Programming algorithm\r\n                \r\nAfter exploring this question I came to realize that dynamic programming algorithms can't be used to solve knapsack problem or similar problems with a non-integer constraint. Am I right about my realization? Are there any other limitations of Dynamic Programming algorithms? \n    ", "Answer": "\r\nBasically you could say the number of possible scores (solution quality) needs to be finite and low enough to fit in memory. Non-integer in general means non-discrete and that leads to infinite possible solution scores.\n\nIf there are only N possible solution scores you know that you will at most need to find N of them to also get the best one, not the whole exponential amount of ways to get to them. That's the idea behind dynamic programming.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "General Question about Dynamic Programming\r\n                \r\nSo I saw a video about the Knapsnack problem, which can be solved recursively as well as using dynamic programming. The gist I got about dynamic programming is that it's nothing more than a dictionary, list or collectively a record of stuff we have already computed so we don't have to compute it again. \n\nIs that what dynamic programming is all about? Performing record keeping and using when necessary?\n    ", "Answer": "\r\nIn simple words, we are solving a small problem(called subproblem) and then use it to solve bigger problems.\n\nTo achieve this we keep a record of what we have computed till now which can inturn be used next time rather than computing all over again.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "dynamic programming algorithm during an interview [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                As it currently stands, this question is not a good fit for our Q&A format. We expect answers to be supported by facts, references,  or expertise, but this question will likely solicit debate, arguments, polling, or extended discussion. If you feel that this question  can be improved and possibly reopened, visit the help center for guidance.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 11 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nThis question was asked to me in an interview and it embarrassingly exposed my shortcomings on dynamic programming. I will appreciate if someone can help me crack this one. Also, it would be very helpful to me (and others) if you can explain your thinking process along the way as you devise the solution as i seem to be able to understand when i see a solution which uses dynamic programming paradigm but struggle to come up with my own. \n\nWithout further ado, here is the question i was asked.\n\nGiven an integer ```\ni```\n and set ```\nX```\n of ```\nk```\n points ```\nx1```\n, ```\nx2```\n, ... ```\nxk```\n on real line, select ```\ni```\n points from set ```\nX```\n so as to minimize the sum of the distance from every point in ```\nX```\n to a point in ```\ni```\n using Dynamic programming. \n    ", "Answer": "\r\nWith most DP problems I try and find a kind of reduce-and-conquer relation. That is, a relation whereby I can cut away from the problem size with each step (like divide and conquer, but usually doesn't divide the problem, it just removes a small part). In this problem (like many others) we can make a very simple observation: Either the first point is in the set of ```\ni```\n points, or it isn't.\n\nSome notation: Let's say X = {x1, x2, ..., xk}, and denote the reduced set Xn = {xn, xn+1, ..., xk}.\n\nSo the observation is that either x1 is one of the ```\ni```\n points, or it isn't. Let's call our ```\ni```\n-set finding function MSD(```\ni```\n,Xk) (minimum sum of distances). We can express that cut-away observation as follows:\n\nMSD(```\ni```\n,Xk) = Either MSD(```\ni-1```\n,Xk-1) U {x1} or MSD(```\ni```\n,Xk-1)\n\nWe can formalise the \"either or\" part by realising a simple way of checking which of those two options it actually is: We run through the set X and calculate the sum of the distances, and check which is actually the smaller. We note at this point, that that check has a running time of ```\nki```\n since we will naively run through each of the ```\nk```\n points and grab the minimum distance from points in the set of size ```\ni```\n.\n\nWe make two simple observations regarding base cases:\n\nMSD(```\ni```\n,Xi) = Xi\nMSD(```\n0```\n,Xn) = {}\n\nThe first is that when looking for ```\ni```\n points in a set of size ```\ni```\n we obviously just take the whole set.\nThe second is that when looking for no points in a set, we return the empty set. This inductively ensures that MSD returns sets of size ```\ni```\n (it's true for the case where ```\ni=0```\n and by induction is true according to our definition of MSD above).\n\nThat's it. That will find the appropriate set.\nRuntime complexity is upper bounded by ```\nO(ik * step)```\n where step is our ```\nO(ik)```\n check from above. This is because MSD will be run on parameters that range from ```\n0-i```\n and X1 - Xk, which is a total of ```\nik```\n possible arguments.\n\nThat leaves us with a runtime of O((ik)2).\n\nThe following part is based on my understanding of the OP's question. I'm not sure if the distance of every point in X from the i-sized subset is the sum of the distances of every point from every other point in the subset, or the sum of the distances of every point in X from the subset itself.\nI.e. sigma of x in X of (sum of distances of x from every point in the subset) OR sigma of x in X of (distance of x from the subset which is the minimum distance from x to any point in the subset)\n\nI assume the latter.\n\nWe can reduce the runtime by optimising the ```\nO(ik)```\n check from above. We notice that the elements are actually sorted (albeit in reverse order in this current notation), since when we add them on we do so always from the right hand side. Assuming they're sorted to begin with, they will be once out of the MSD routine. If they weren't sorted to begin with we can sort them, which will only cost ```\nO(klogk)```\n anyway.\n\nOnce sorted, checking the distance of each point from a point in the set will be ```\nk * logi```\n since for each point we do a binary search. This yields a total running time of ```\nO(ik * klogi + klogk)```\n\n= O(k2 * ilogi).\n\nFinally, we can express that as O(k3logk). Not the fastest solution, but a solution.\n\nI'm sure there are even more optimisations, but that's my 2c.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming methodology\r\n                \r\nI was wondering if you might have some insight into a problem, where we consider an optimization problem:\n\nmax ∑ from j=1 to n of fj(xj) such that ∑ j=1 to n of xj <=B \n\nxj>=0, integers\n\nwhere B is a positive integer and fj is real to real\n\nI am trying to formulate a solution using dynamic programming and to figure out the time complexity of this method.\n\nIm a bit confused about the dynamic programming approach, how would you implement it for a function such as f1(x)=sqrt(x) if n=5 and B=10\n\nkind regards\n    ", "Answer": "\r\nYour problem is to solve\n\n```\nmax(g(n,s) for s=0 to B)\n```\n\n\nwhere ```\ns```\n is ```\nsum(x[i] for i = 1 to j)```\n\n\nwhere g can be represented recursively as\n\n```\ng(0,s) = 0\ng(j,s) = max(g(j-1,s-x[j])) + f[j](x[j]) for x[j]=0 to s)\n```\n\n\nAnd this can be solved efficiently by calculating ```\ng```\n as a table:\n\n```\ng(0,s) = 0\ng(1,s) = max(g(0,s-x1) + f1(x1) for x1=0 to s)\ng(2,s) = max(g(1,s-x2) + f2(x2) for x2=0 to s)\netc.\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming without using the recursion? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 3 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nUsually, I have seen that problems that are solved using the dynamic programming end up using the recursion which is understandable due to its property. But would it be correct to say that Dynamic programming solution will for sure involve the recursion? Is it possible to have a dynamic programming solution that doesn't involve recursion and can be done in a linear way?\nThanks in advance.\n    ", "Answer": "\r\nshort answer is yes dynamic programming can be done linear way. Understand it as a optimization technique where you avoid recalculating the same value again. Lets understand it by a simple fibonacci example:\n\n```\nint getFib(int n){\n int fib[] = new int[n];\n fib[0] = 0;\n fib[1] = 1;\n for(int i=2;i<n;i++){\n    fib[i] = fib[i-1]+fib[i-2];\n  }\nreturn fib[n-1];\n}\n```\n\n\nnow this is a classic dynamic programming example. its categorized as dynamic programming because here we are optimizing the calculation based on the previous calculation. This is true that lot of recursive algorithms are also dynamic programming problem but dynamic programming can also be linear as you can see in this example.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming : Concept\r\n                \r\nTrue or False:\n\n\n  Any problem that can be solved using dynamic programming has a polynomial time worst case time complexity with respect to its input size.\n\n\nAre there any DP solutions which are not polynomial?\n\nThank you.\n    ", "Answer": "\r\nThere is a dynamic programming algorithm for the Knapsack problem for which the worst-case complexity is ```\nO(Wn)```\n where ```\nW```\n is the capacity of the knapsack and ```\nn```\n is the number of items. Such a runtime bound is termed as pseudo polynomial (as a value which is encoded in the instance occurs) and cannot be considered as polynomial in the input size. So, short answer: false.\n\nFurthermore, the original question is formulated a bit misleading; the runtime complexity refers to a specific algorithm, not the problem itself.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Recursion and dynamic programming\r\n                \r\nI know that every program that can be solved using dynamic programming can be solved using recursion, but is the vice versa also possible? If possible then how will the time complexity differ?\n    ", "Answer": "\r\n\n  is the vice versa also possible?\n\n\nYes.\n\nOn the other hand, if you were actually meaning to ask:\n\n\n  is the vice versa also true?\n\n\nThen reasonably speaking the answer is No. Not all problems that can be solved with recursive algorithms can reasonably be solved with dynamic programming. We only need to come up with one problem to highlight this: sorting. It is easy to solve the problem of sorting with a recursive algorithm, but there does not seem to be a reasonable algorithm to solve the problem of sorting with dynamic programming. Unfortunately I have to resort to using the weasel word \"reasonable\" here, because you could forcefully use dynamic programming in some manner to solve the problem of sorting, in a very awkward and inefficient way.\n\nThe question regarding the time complexity can't be answered. It depends on the problem at hand, and how applicable dynamic programming would be in solving the problem.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Parallel Dynamic Programming\r\n                \r\nAre there any good papers discussing how to take a dynamic program and parallelize it?\n    ", "Answer": "\r\nWe recently published a paper showing how to parallelize any d.p. on a shared memory multicore computer by means of a shared lock-free hash table:\n\nStivala, A. and Stuckey, P. J. and Garcia de la Banda, M. and Hermenegildo, M. and Wirth, A. 2010 \"Lock-free parallel dynamic programming\" J. Parallel Distrib. Comput. 70:839-848 doi:10.1016/j.jpdc.2010.01.004\n\nhttp://dx.doi.org/10.1016/j.jpdc.2010.01.004\n\nEssentially, you start multiple threads, all running the same code starting at the value of the d.p. you want to compute, computing it top-down (recursively), and memoizing in a shared lock-free hash table, but randomizing the order in which subproblems are computed so that the threads diverge in which subproblems they compute.\n\nIn terms of implementation, we just used C and pthreads on UNIX type systems, all you need is to be able to have shared memory, and CompareAndSwap (CAS) for lock-free synchronization between threads.\n\nBecause this paper was published in an Elsevier journal, you'll need to access the above through a University library or similar with a subscription to it. You might be able to get a pre-print copy via Prof. Stuckey's webpage though.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming - Coin change decision\r\n                \r\nI'm reviewing some old notes from my algorithms course and the dynamic programming problems are seeming a bit tricky to me.  I have a problem where we have an unlimited supply of coins, with some denominations x1, x2, ... xn and we want to make change for some value X.  We are trying to design a dynamic program to decide whether change for X can be made or not (not minimizing the number of coins, or returning which coins, just true or false).\n\nI've done some thinking about this problem, and I can see a recursive method of doing this where it's something like...\n\n```\nMakeChange(X, x[1..n this is the coins])\n    for (int i = 1; i < n; i++)\n    {\n        if ( (X - x[i] ==0) || MakeChange(X - x[i]) )\n            return true;\n    }\n    return false;\n```\n\n\nConverting this a dynamic program is not coming so easily to me.  How might I approach this?\n    ", "Answer": "\r\nYour code is a good start. The usual way to convert a recursive solution to a dynamic-programming one is to do it \"bottom-up\" instead of \"top-down\". That is, if your recursive solution calculates something for a particular X using values for smaller x, then instead calculate the same thing starting at smaller x, and put it in a table.\n\nIn your case, change your MakeChange recursive function into a canMakeChange table.\n\n```\ncanMakeChange[0] = True\nfor X = 1 to (your max value):\n   canMakeChange[X] = False\n   for i=1 to n:\n     if X>=x[i] and canMakeChange[X-x[i]]==True: \n       canMakeChange[X]=True\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming : True or False\r\n                \r\nI have a conceptual doubt regarding Dynamic Programming:\n\n```\nIn a dynamic programming solution, the space requirement is always at least as big as the number of unique sub problems.\n```\n\n\nI thought it in terms of Fibonacci numbers: \n\n```\nf(n) = f(n-1) + f(n-2)\n```\n\n\nHere there are two subproblems, the space required will be at least O(n) if input is n.\nRight?\n\nBut, the answer is False.\n\nCan someone explain this?\n    ", "Answer": "\r\nThe answer is indeed false. \n\nFor example, in your fibonacci series, you can use Dynamic Programming with O(1) space, by remembering the only 2 last numbers:\n\n```\nfib(n):\n   prev = current = 1\n   i = 2\n   while i < n:\n      next = prev + current\n      prev = current\n      current = next\n   return current\n```\n\n\nThis is a common practice where you don't need all smaller subproblems to solve the bigger one, and you can discard most of them and save some space.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming problems\r\n                \r\nI'm looking for some pointers about a dynamic programming problem. I cannot find any relevant information about how to solve this kind of problem. The only kind of problem I know how to solve using dynamic programming is when I have two sequences and create a matrix of those sequences. But I don't see how I can apply that to the following problem...\n\nIf I have a set A = {7,11,33,71,111} and a number B. Then C which is a subset of A, contains the elements from A which builds the sum B.\n\nEXAMPLE:\n\n```\nA = {7,11,33,71,111}\nIf B = 18, then C = {7,11} (because 7+11 = 18)\n\nIf B = 3, then there is no solution\n```\n\n\nThankful for any help here, I just don't know how to think when solving these kind of problems. I cannot find any general method either, only some examples on gene sequences and stuff like that.\n    ", "Answer": "\r\nDynamic programming is a broad category of solutions wherein a partial solution is kept in some structure for the next iteration to build upon instead of having it recalculate the intermediate results over and over again.\n\nIf I were to take a dynamic approach to this particular problem, I would probably keep a running list of every sum calculable from the previous step, as well as the set used to compute that sum.\n\nSo for example the first iteration my working set would contain ```\n{null, 7}```\n, then I would add ```\n11```\n to everything in that that set as well as the set itself (let's pretend that ```\nnull+11=11```\n for now). Now my working set would contain ```\n{null, 7, 11, 18}```\n. For each value in the set, I would keep track of how I got that result: so ```\n7```\n maps to the original set ```\n{7}```\n and ```\n18```\n maps to the original set ```\n{7,11}```\n. Iteration would end when either A) the target value is generated or B) the original set is exhausted without finding the value. You could optimize the negative case with an ordered set, but I'll leave figuring that out to you.\n\nThere is more than one way to approach this problem. This is a dynamic solution, and it's not very efficient as it needs to build a set of ```\n2^(size of set)```\n members. But the general approach corresponds to what dynamic programming was created to solve.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Efficient Dynamic programming using Python\r\n                \r\nI'm working on a dynamic programming task of finding a minimum cost path along a directed graph (all possible paths have the same number of weighted nodes).\n\nThe approach for solving the problem is a recursive function along with a dynamic programming.\n\nSince this dynamic programming task is encountered in many unrelated problems during the code, the concept of threading could be helpful.\n\nThe problem is, that in python, 'threading' won't help much.\nwhat are efficient ways of handling such a task in python?\n\nHere's the code:\n\n```\n    def rec_fun(pos, path_size, weights, directions):\n        cost = weights[d][i, j]\n        if path_size == 0:\n            key = str(i) + ',' + str(j) + ',' + str(d)\n            dict.update({key: pix_cost})\n            return cost\n        else:\n            key = str(i) + ',' + str(j) + ',' + str(d)\n            if key in dict:\n                return dict[key]\n            else:\n\n                val = cost + min(rec_fun(pos + direction[0], path_size - 1, weights, direction),\n                                 rec_fun(pos + direction[1], path_size - 1, weights, direction),\n                                 rec_fun(pos + direction[2], path_size - 1, weights, direction))\n                dict.update({key: val})\n                return val\n```\n\n    ", "Answer": "\r\nSo first off, dynamic programming is just a simple paradigm for solving a certain type of problem. There is not really something specific you can do to optimize dynamic programming in general, in turn that means general python optimizations apply.\n\nSo from the code you posted the most striking thing I see is the use of recursions, this is relatively inefficient in python, so start off by moving to ```\nfor```\n (ideal) or ```\nwhile```\n loops.\n\nFollowing is a non-exhaustive list of possible ways to make your code run faster in python (with increasing effort):\n\n\nTry Numba to speed your functions up significantly. It requires very little work (often the ```\n@jit```\n decorator is enough) to optimize your code to almost cython level in some cases.\nMake use of Numpy to vectorize your code where possible.\nUse Processes ```\nmultiprocessing.Process```\n instead of Threads, as you probably already figured, python threads don't work the same way as in other programming languages due to the global interpreter lock. I think here it's important to note that sharing memory between processes is not really a good practice and you should avoid that if anyhow possible.\nUse Python's C-Extension Cython to write all performance critical parts of your code.\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Steps involved in Dynamic Programming algorithm development\r\n                \r\nHow Dynamic Programming Development is performed. Are there any detailed steps that are involved in performing the dynamic programming?\n    ", "Answer": "\r\nThe seven steps in the development of a dynamic programming algorithm are as follows:\n\n1- Establish a recursive property that gives the solution to an instance of the problem.\n\n2- Develop a recursive algorithm as per recursive property\n\n3- See if same instance of the problem is being solved again an again in recursive calls\n\n4- Develop a memoized recursive algorithm\n\n5- See the pattern in storing the data in the memory \n\n6- Convert the memoized recursive algorithm into iterative algorithm\n\n7- Optimize the iterative algorithm by using the storage as required (storage optimization)\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming-RodCutting\r\n                \r\nI've recently started learning algorithms.\nI tried to implement the classic Rod cutting problem using a  Dynamic programming approach. I'm unable to get the correct output. Here is my code:\n\n```\npublic class RodCuttingProblem {\n\n    public static void main(String[] args) {\n        int len=5;\n        int prices[]={2,5,7,3};\n        rodCuttingImplementation(prices,len);\n    }\n\n    public static void rodCuttingImplementation(int prices[],int len){\n        prices=reAdjustPrice(prices);\n        System.out.println(\"\");\n        for(int i=0;i<prices.length;i++){\n            System.out.print(prices[i]+\" \");\n        }\n        System.out.println(\" \");\n        int dp[][]=new int[prices.length+1][len+1];\n        for(int i=1;i<prices.length;++i){\n            for(int j=1;j<=len;++j){\n                if(i<=j){\n                    dp[i][j]=Math.max(dp[i-1][j], prices[i]+dp[i][j-1]);\n                }\n                else{\n                    dp[i][j]=dp[i-1][j];\n                }\n                System.out.print(dp[i][j]+\" \");\n            }\n            System.out.println();\n        }\n        System.out.println(\"Optimal Profit : \"+dp[prices.length-1][len]);\n    }\n\n    static int[] reAdjustPrice(int prices[]){\n        int[] newPrices=new int[prices.length+1];\n        newPrices[0]=0;\n        for(int i=0;i<prices.length;i++){\n            newPrices[i+1]=prices[i];\n        }\n        return newPrices;\n    }\n}\n```\n\n\nOutput:\n\n```\n2 4 6 8 10 \n2 7 12 17 22 \n2 7 14 21 28 \n2 7 14 21 28  \nOptimal Profit : 28\n```\n\n\nAs per my understanding, the output should be 12.\n    ", "Answer": "\r\nI really tried to understand what your algorithm is supposed to do, but I cannot, thus I cannot find out what the problem is\n\nsome concerns:\n\n\nreAdjustPrice is doing very weird shift, I suppose you want to indicate that length is always >= 1 and thus index in array cannot be 0, it could work, though I suggest you to think in terms of 0-based arrays\nyou have array with 4 prices, but want to split rod with length 5. Usually this is done by appending 0 at the end of array, ie initial price for length 5 is 0\narray ```\ndp```\n - it has 2 dimensions, but maximal price for every length is 1 value, so you need 1 value for each step, this is for sure one dimensional array\n\n\nHere is \"canonical\" implementation of rod splitting algorithm:\n\n```\nstatic int maxPrice(final int len, final int[] prices) {\n    // if len > prices.length, adjust it to have zeroes at the end\n    for (int i = 0; i < len; i++)\n        for (int j = 0; j < ((i + 1) >>> 1); j++)\n            prices[i] = Math.max(prices[i], prices[j] + prices[i - j - 1]);\n    return prices[len - 1];\n}\n```\n\n\nnote: this variant modifies input array, to decrease memory usage, but its very easy to modify it\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "dynamic programming optimizaton,convex hull\r\n                \r\nThere is a problem asked in contest. I already solved this problem with dynamic programming and its complexity ```\nO(n^2)```\n.But i am looking more efficient way. I already saw that dynamic Programming can be optimized with convex hull. Do you have any suggestions. Thanks in advice.\n    ", "Answer": "\r\nYou're probably referring to the convex hull trick for dynamic programming:\nhttp://wcipeg.com/wiki/Convex_hull_trick\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming and the 0/1 knapsack\r\n                \r\nI'm having some trouble understanding dynamic programming, even though I've read through so many resources trying to understand.\n\nI understand an example given of dynamic programming using the fibonacci algorithm. I understand how if you use the divide and conquer approach to it, you'll end up solving some sub-problems multiple times, and dynamic programming takes care of that by solving those overlapping subproblems but only once (and storing them for future reference). However, I have been introduced to dynamic programming in my class using the 0/1 knapsack problem as an example, and I don't really understand the example, or how it illustrates dynamic programming, or how it's in anyway similar to the fibonacci example.\n\nHere are the slides related to it:\n\n\n\n\n\n\n\n\n\nI mainly understand what is going on until the last slide, where it says f(i,y) = max{....} \n\nWhat exactly am I finding the max of? Why am I finding the max of anything at all? And most importantly, what does this have to do with dynamic programming? I don't understand the relation, like I do when it comes to the fibonacci example. I honestly have no clue what this knapsack problem has anything to do with dynamic programming because it doesn't even seem comparable in anyway to using the fibonacci example to illustrate dynamic programming. Like I don't see any parallels or anything at all, and it really doesn't make much sense to me\n    ", "Answer": "\r\nDynamic programming is just defining the problem in terms of simpler subproblems.\nIn the case of Fibonacci, we define the problem in terms of the two smaller terms.\nIn this case, we define the problem with some number of items and some capacity in terms of subproblems containing fewer items and possibly a smaller capacity.\nWe start off calculating the profit for at most 1 item and every capacity. Then we calculate the profit for at most 2 items and every capacity. Then we do this for at most 3 items, then 4, and so on. Since we've defined one problem in terms of subproblems with fewer items, we can simply look up what we've already calculated to determine any of the values with 2, 3, 4, etc. items.\nIt might help to think of this as a physical 2D grid, where you fill in the values from one direction to the other, and every time you're only looking in the direction where all the values have already been filled in.\nThere are overlapping subproblems because in one case we're using the same capacity, and in another we're using a smaller capacity. The smaller capacity is sometimes going to match a different subproblem which was checking the same capacity. That is to say ```\nf(i+1, j)```\n for one problem is going to equal ```\nf(i+1, y - w_i)```\n for another problem. As an example, you can see the ```\nf(11, 5)```\n appears in 2 places:\n```\nf(10, 8) = max(f(11, 8), f(11, 5) + 77)   // w_i = 3\nf(10, 5) = max(f(11, 5), f(11, 2) + 77)\n```\n\nIn this case we would've already calculated ```\nf(11, X)```\n for every ```\nX```\n, so we can just look those values up.\nI do find it a bit confusing that we're defining problems in terms of increasing ```\ni```\n, as in ```\nf(i, j) = ...f(i+1, X)...```\n and that ```\nf(n, X)```\n thus contains at most 1 item, instead of using decreasing ```\ni```\n and having at most 1 item at ```\nf(1, X)```\n. But this is just semantics and doesn't change the problem in any way.\nTechnical details explanations\n```\nf(i,y)```\n is the maximum profit containing a subset from items ```\ni```\n through ```\nn```\n with a capacity of ```\ny```\n.\nNow we can define this as either including or excluding item ```\ni```\n, and then getting the maximum profit for items ```\ni+1```\n through ```\nn```\n.\nWhen we exclude item ```\ni```\n, this doesn't change the weight, so we can just look at the maximum profit for the same capacity, i.e. ```\nf(i+1, y)```\n, and the profit also doesn't change.\nWhen we include item ```\ni```\n, this changes the weight, specifically by the weight of item ```\ni```\n, which is ```\nw_i```\n, so we have to look up ```\nf(i+1, y - w_i)```\n. But then we also get the profit from item ```\ni```\n, so we need to add its profit, i.e. ```\np_i```\n.\nNow, since we want the maximum profit, we have to find the maximum of these two values, giving us:\n```\nf(i, y) = max{f(i+1, j), f(i+1, y - w_i) + p_i}\n```\n\n\nIf you're still having trouble understanding it, I suggest you construct yourself an example to work through - no amount of explaining quite measures up to seeing it actually working, and using this to get some intuition for why we do things the way we do.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "C dynamic programming with caching\r\n                \r\nI need to create a program that computes change, using dynamic programming with caching. The program is to return an array with the coins adding up to the change.\n\nI have consulted this page for pseudocode regarding dynamic programming, but the output is only the number of coins, and I am unsure whether the below line actually implements caching.\n\n```\nif ((values[j] <=a)&& (1+coins[a-values[j]]<coins[a]))\n```\n\n\nBelow is all the working code which still needs modification.\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n\n/**\n  @param amt value of change\n  @param values[] array of coin values\n  @param n number of available coins (length of values array)\n*/\nfloat  DynamicMakeChange(int amt,int values[],int n){\n    int coins[amt];  //array of number of coins needed up to amt\n    coins[0]=0;\n    int a; //the current change to compute\n\n    // put number of coins in coins array at index a\n    for (a=1;a<=amt;a++){\n        int array[a];\n        int counter=0;\n        coins[a]=(int)INFINITY;\n        int j;\n\n        //loops all values of coins\n        for (j=0;j<n;j++){\n\n\n            // if current coin value is smaller or equal than a (the current change value)\n            // and if the number of coins at the current amount-the currently looped value of a coin\n            // is less than the number of coins at the current amount.\n            if ((values[j] <=a)&& (1+coins[a-values[j]]<coins[a])){\n                //array[counter++]=values[j];\n                coins[a]=1+coins[a-values[j]];\n\n            }\n\n\n        }\n    }\n    return coins[amt];\n\n}\n\nint main()\n{\n    int choice;\n    int array[] = { 1,2,5,10,20,50,100,200};\n    printf(\"Please enter change to turn to coins:\\n\");\n    scanf(\"%d\",&choice);\n    int n= sizeof(array)/sizeof(array[0]);\n    float jasdkas=DynamicMakeChange(choice,array,n);\n    printf(\"Number of coins: %.0f\",jasdkas);\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nThis, as stated in the link you provided should be solved using recursion. Your solution is not recursive. You´re program should recur, e.g. call itself. I am unsure what you needed to return but if it was the addition of the values in the int array then there should be something like:\n\n```\ninside DynamicMakeChange():\n\nif (n>0)\n return (array[n] + DynamicMakeChange(choice,array[n-1],n-1));\nreturn 0;\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Problems with dynamic programming\r\n                \r\nI've got difficulties with understanding dynamic programming, so I decided to solve some problems. I know basic dynamic algorithms like longest common subsequence, knapsack problem, but I know them because I read them, but I can't come up with something on my own :-(\n\nFor example we have subsequence of natural numbers. Every number we can take with plus or minus. At the end we take absolute value of this sum. For every subsequence find the lowest possible result.\n\nin1: 10 3 5 4;\nout1: 2\n\nin2: 4 11 5 5 5;\nout2: 0\n\nin3: 10 50 60 65 90 100;\nout3: 5\n\nexplanation for 3rd: 5 = |10+50+60+65-90-100|\n\nwhat it worse my friend told me that it is simple knapsack problem, but I can't see any knapsack here. Is dynamic programming something difficult or only I have big problems with it?\n    ", "Answer": "\r\nAs has been pointed out by amit, this algorithm can be understood as an instance of the partition problem. For a simple implementation take a look at this Python code:\n\n```\ndef partition(A):\n    n = len(A)\n    if n == 0:\n        return 0\n    k, s = max(A), sum(A)/2.0\n    table = [0 if x else 1 for x in xrange(n*k)]\n    for i in xrange(n):\n        for j in xrange(n*k-1, -1, -1):\n            if table[j-A[i]] > table[j]:\n                table[j] = 1\n    minVal, minIdx = float('+inf'), -1\n    for j in xrange(int(s)+1):\n        if table[j] and s-j < minVal:\n            minVal, minIdx = s-j, j\n    return int(2*minVal)\n```\n\n\nWhen called with one of the inputs in the question:\n\n```\npartition([10, 50, 60, 65, 90, 100])\n```\n\n\nIt will return ```\n5```\n, as expected. For fully understanding the math behind the solution, please take a look at this examples and click the \"Balanced Partition\" link.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming in Haskell [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        How are Dynamic Programming algorithms implemented in idiomatic Haskell?\r\n                            \r\n                                (6 answers)\r\n                            \r\n                    \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nDoes Haskell provide any tools for dynamic programming? In a procedural language, I would use an array to store the calculations based on a recurrence relation. How do I do something similar in Haskell?\n    ", "Answer": "\r\nMany different ways depending on the situation.  That said, often simple dynamic programming algorithms are far simpler in Haskell than in other languages because of Haskelll is lazy\n\nConsider the Fibonacci function (the \"Hello World\" of functional programming)\n\n```\nfib n | n < 2 = 1\nfib n | otherwise = fib (n-1) + fib (n-2)\n```\n\n\nthis runs in exponential time (grr).  We could trivially store all the values of fib in a lazy infinitely long list\n\n```\nfibs = map fib [0..]\n```\n\n\nnow we can observe that\n\n```\nfibs !! n\n = (map fib [0..]) !! n =\n = fib ([0..] !! n)\n = fib n\n```\n\n\nso far this doesn't help us, but we can use this equivalence to our advantage\n\n```\nfib n | n < 2 = 1\nfib n | otherwise = (fibs !! (n-1)) + (fibs !! (n-2)) where\n  fibs = map fib [0..]\n```\n\n\nthis provides a linear time solution to the Fibonacci function (although it leaks space...don't actually do it this way), and only works because Haskell is lazy.  We defined an infinite data-structure in terms of a recurrence relation on itself.  The miracle is that this runs in finite time (non strictness), that it runs in linear time is a product of the time optimality of call-by-need (Haskell's cost model).  The reason for this linear time performance is that each entry in ```\nfibs```\n is computed at most once (or possibly never).  \n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Memoization of Dynamic Programming\r\n                \r\nI'm trying to learn Memoization of Dynamic Programming and I was watching video on youtube from MIT trying to follow along with it. I don't know how to compare the Nth value to an array.\n\n```\nint[] memo;\npublic int fib(int n) {\n    int f = 0;\n\n    if n is in memo then return memo[n] <----not sure how to code this line.\n\n    if (n<=2) {\n        f = 1;\n    } else {\n        f = fib(n-1) + fib(n-2);\n    }\n\n    memo[n] = f;\n    return f;\n}\n```\n\n    ", "Answer": "\r\nDoing it with ```\nArrayList```\n:\n\n```\nArrayList<Integer> memo = new ArrayList<Integer>();\n\npublic int fib(int n) {\n    if (memo.size() == 0)\n       memo.add(0); // element 0 is never accessed\n    return fib2(n);\n}\n\nprivate int fib2(int n) {\n    int f = 0;\n\n    if (n < memo.size())\n       return memo.get(n);\n\n    if (n<=2) {\n        f = 1;\n    } else {\n       f = fib2(n-2) + fib2(n-1);\n    }\n\n    memo.add(f); // elements inserted in order\n    return f;\n}\n```\n\n\nDoing it with array:\n\n```\nint[] memo;\n\npublic int fib(int n) {\n    memo = new int[n+1]; // all initialized to 0\n    return fib2(n);\n}\n\nprivate int fib2(int n) {\n    int f = 0;\n\n    if (memo[n] != 0)\n       return memo[n];\n\n    if (n <= 2) {\n        f = 1;\n    } else {\n        f = fib2(n-2) + fib2(n-1);\n    }\n\n    memo[n] = f;\n    return f;\n}\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming in C#\r\n                \r\nI'm writing a simple dynamic programming in C#.\n```\npublic class CountDerangementRec\n{\n    public long Derangements(int setsize)\n    {\n        var subSolutions = new List<long>(capacity:setsize + 1);\n\n        for (int n = 1; n <= setsize; n++)\n        {\n            if (n == 1)\n                subSolutions[n] = 0;\n            else if (n == 2)\n                subSolutions[n] = 1;\n            else\n                subSolutions[n] = (n - 1) * (subSolutions[n - 1] + subSolutions[n - 2]);\n\n            return subSolutions[n];\n        }\n        return subSolutions[setsize];\n    }\n}\n```\n\nMy main class looks like this:\npublic class Program\n{\n```\n    public static void Main()\n    {\n        var count = new CountDerangementRec();\n\n        Console.WriteLine(count.Derangements(3));           \n            \n    }\n}\n```\n\nEvery time I run the program , I get the following error:\n```\nUnhandled exception. System.ArgumentOutOfRangeException: Index was out of range. Must be non-negative and less than the size of the collection. (Parameter 'index')\n   at System.Collections.Generic.List`1.set_Item(Int32 index, T value)\n   at Dynamic_programing.CountDerangementRec.Derangements(Int32 setsize) in C:\\Users\\pasob\\source\\repos\\Dynamic programing\\CountDerangementRec.cs:line 18\n   at Dynamic_programing.Program.Main() in C:\\Users\\pasob\\source\\repos\\Dynamic programing\\Program.cs:line 10\n```\n\nI don't know what I'm doing wrong\n    ", "Answer": "\r\nsubSolutions[n] goes out of bounds.\nCheck this snippet for derangements permutation using DP:\n```\nusing System;\n \nclass GFG\n{\n     \n    // Function to count\n    // derangements\n    static int countDer(int n)\n    {\n        // Create an array to store\n        // counts for subproblems\n        int []der = new int[n + 1];\n     \n        // Base cases\n        der[1] = 0;\n        der[2] = 1;\n     \n        // Fill der[0..n] in bottom up\n        // manner using above recursive\n        // formula\n        for (int i = 3; i <= n; ++i)\n            der[i] = (i - 1) * (der[i - 1] +\n                                der[i - 2]);\n     \n        // Return result for n\n        return der[n];\n    }\n     \n    // Driver code\n    public static void Main ()\n    {\n        int n = 4;\n        Console.Write(\"Count of Derangements is \" +\n                       countDer(n));\n     \n    }\n}\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Is this solution classified as dynamic programming?\r\n                \r\nI have to prepare some examples of dynamic programming for my studies. Especially in optimalisation tasks. As first example I decided to write alghoritm to find the path from point (0,0) to point (n,m) on the (n,m)matrix such that the path sum would be the lowest. It seems to work fine but please ensure me if this alghoritm can be classified as dynamic programming. Could you please refer me to some implemented solutions of optimalization tasks using dynamic programming?\n\n```\nprivate static int[][] MATRIX = {\n    {1,8,4,2},\n    {1,1,4,2},\n    {1,1,1,6}\n};\n\nfor (int i = MATRIX.length - 1; i >= 0; i--)\n    {\n        for (int j = MATRIX[i].length - 1; j >= 0; j--)\n        {\n            int temp;\n            if (i + 1 < MATRIX.length && j + 1 < MATRIX[i].length)\n                temp = Math.min(MATRIX[i + 1][j], MATRIX[i][j + 1]);\n            else if (i + 1 < MATRIX.length)\n                temp = MATRIX[i + 1][j];\n            else if (j + 1 < MATRIX[i].length)\n                temp = MATRIX[i][j + 1];\n            else\n                temp = 0;\n                MATRIX[i][j] += temp;\n         }\n    }\n    System.out.println(MATRIX[0][0]);\n```\n\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming with \"broken profile\"? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is off-topic. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it's on-topic for Stack Overflow.\r\n                \r\n                    \r\n                        Closed 10 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nThe following link mentions some types of dynamic programming:\nhttp://www.mii.lt/olympiads_in_informatics/pdf/INFOL056.pdf\none of which is \"broken profile\".\n\nI am pretty sure it is a valid term since I have seen references to it in other programming competition sites like TopCoder and CodeForces.\n\nBut I can't seem to find anything on this topic. This term has been used mostly by Russian sources.\n\nDoes anyone what if means, or what kind of problems within dynamic programming it solves? Or even better a tutorial?\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Stereo Matching - Dynamic Programming [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                As it currently stands, this question is not a good fit for our Q&A format. We expect answers to be supported by facts, references,  or expertise, but this question will likely solicit debate, arguments, polling, or extended discussion. If you feel that this question  can be improved and possibly reopened, visit the help center for guidance.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI am supposed to implement Dynamic programming algorithm for Stereo matching problem. I have read 2 research papers but still haven't understood as to how do I write my own c++ program for that !\n\nIs there any book or resource that's available somewhere that I can use to get an idea as to how to start coding actually ?\n\nInternet search only gives me journal and conference papers regarding Dynamic Programming but not how to implement the algorithm step by step.\n\nThanks\n\nVarun\n    ", "Answer": "\r\nRead this paper by Cox, Hingorany and Rao, old but still a classic. \n\nCost computation is pixel based, but the generalization to cross-correlation in a neigborhood is trivial, as is also its generalization to a pyramid scheme in which full match is done only at the lowest resolution, and the result used to refine at higher resolutions by doing the DP search only in a small band around the lower res match. This idea was the basis of the better known paper by Luc van Gool and Marc Pollefeys\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "dynamic programming in functional languages [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                It's difficult to tell what is being asked here. This question is ambiguous, vague, incomplete, overly broad, or rhetorical and  cannot be reasonably answered in its current form. For help clarifying this question so that it can be reopened,  visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI study haskell. I encounter with the problem that I cannot save intermediate calculation steps. It feels ineffective. How to use dynamic programming in functional programming?\n    ", "Answer": "\r\n\n  I encounter [in Haskell] the problem that I cannot save intermediate\n  calculation steps.\n\n\nI do not know what ressources you used to learn it, but they were apparently not the best.\n\nFor example:\n\n```\nlet \n    intermediate = {- calculation step -}\nin ...\n```\n\n\nsaves the result of a calculation step in ```\nintermediate```\n. (Better: it binds the variable ```\nintermediate```\n to the value. )\n\nIn addition, to cite the relevant Wikipedia  entry:\n\n\n  In mathematics, computer science, and economics, dynamic programming\n  is a method for solving complex problems by breaking them down into\n  simpler subproblems. It is applicable to problems exhibiting the\n  properties of overlapping subproblems[1] and optimal substructure\n  (described below). When applicable, the method takes far less time\n  than naive methods.\n  \n  The key idea behind dynamic programming is quite simple. In general,\n  to solve a given problem, we need to solve different parts of the\n  problem (subproblems), then combine the solutions of the subproblems\n  to reach an overall solution. Often, many of these subproblems are\n  really the same. The dynamic programming approach seeks to solve each\n  subproblem only once, thus reducing the number of computations: once\n  the solution to a given subproblem has been computed, it is stored or\n  \"memo-ized\": the next time the same solution is needed, it is simply\n  looked up. This approach is especially useful when the number of\n  repeating subproblems grows exponentially as a function of the size of\n  the input.\n\n\nIt is obvious that this style of problem solving is supported by Haskell quite nicely. For example, in the easiest case one could carry a map around, that keeps the already solved sub-problems and their solutions. More advanced approach could use the State Monad. And so on.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming in repa\r\n                \r\nTwo related questions. \n\n\nIs there a reason why there is no mutable (ST monad) implementation of repa arrays? Equivalent to Data.Vector.Mutable but with a shape.\nRelated to this, how is one supposed to implement dynamic programming algorithms (array elements computed from other elements of the same array), in the unboxed representation?\n\n    ", "Answer": "\r\nRepa is designed for bulk data parallel programming. It must be possible to compute array elements in arbitrary order, otherwise the Repa evaluation methods won't work.\n\nIf you want to destructively update an array element based on other array elements, then this constrains the evaluation order. If you can't express your algorithm in a bulk data parallel fashion then Repa isn't going to help you.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming, minimizing cost?\r\n                \r\nI came across this question:\n\nYou have to travel through ```\nN```\n blocks in a city in a car begining at block ```\n0```\n and ending at block ```\nN - 1```\n. Every block ```\ni```\n has a gas station which provides delivery of gas at the block, from the block to ```\nX[i]```\n miles to the west of the block and ```\nY[i]```\n miles to the east of the block. The gas stations serve you only when paid an initial amount ```\nC[i]```\n. Assume all blocks lie on a straight road. Give an algorithm which selects the gas stations to pay such that the cash paid to the gas stations is minimized and at least one gas station delivers at every location on the road.\n\nThings I tried:\n\n\nBrute force - Tried all possible combinations and found the best one - Worked perfectly but took too long.\nGreedy - I tried to be greedy on 1) Cost 2) Distance covered 3) cost per distance.\n\n\nAfter ENORMOUS struggle I concluded that this is likely a Dynamic programming problem.\n\nAttempt at Dynamic programming - I tried to come up with a recurrence with  absolutely no result, the hardest part I found was that the station delivers on both sides. To overcome that, I decided that I will \"move\" the stations to the west most position and increase the delivered range on the east by the same amount - couldn't continue.\n\nI found a similar question I think, dynamic programming proboem for minimum cost\nAre these questions actually similar?\n\nCan someone please tell me if this is actually a dynamic programming problem and there is no other way to do this more efficiently?\nIf it is a dynamic programming can you please give a few tips on how I can go about this?\n\nExample:\n\n```\nSuppose N is 4\nblock 0 : X = 1, Y = 1, C = 2\nblock 1 : X = 0, Y = 2, C = 1\nblock 2 : X = 2, Y = 2, C = 5\nblock 3 : X = 1, Y = 5, C = 7\n\nThen the result will be,\nPay block 0, 1 gas stations.\nMin cost : 3\n```\n\n    ", "Answer": "\r\nAs I understand it, we want the minimum-cost set of gas stations that will cover all blocks. This can be formulated as a shortest path problem in the following graph. Create an artificial source, an artificial sink, and a vertex for each gas station. For ```\ni < j```\n, the ```\ni```\nth gas station has an arc to the ```\nj```\nth gas station if and only if there is no gap in their coverage. The artificial source has arcs to each gas station that covers block ```\n0```\n. The artificial sink has arcs from each gas station that covers block ```\nn-1```\n. The cost of each arc is the cost of the gas station at its head (```\n0```\n for the artificial sink). Find the shortest path from the source to the sink; the vertices that we visit along the way are the gas stations from which we should purchase coverage.\n\nThe running time is ```\nO(n^2)```\n with the usual linear-time shortest path algorithm for acyclic directed graphs. There is probably an improvement to ```\nO(n)```\n; see the discussion on CS. (Yuval specifies ```\nO(n log n)```\n time, but that's just because he's working in a different model of computation, where sorting is ```\nOmega(n log n)```\n.)\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Speeding up a function with dynamic programming\r\n                \r\nI have this program\n\n```\n//h is our N\n    static int g=0;\n    int fun(int h){\n        if(h<=0){\n                  g++;\n                  return g;\n                  }\n    return g+fun(h-1)+fun(h-4);\n    }\n```\n\n\nIs it possible to speed it up using dynamic programming?\n\nI figured out that this function runs in O(2^n)\n\nI am supposed to reduce the running time by dynamic programming, but do not understand the concept.\n\nJust asking for a nudge in the right direction.\n    ", "Answer": "\r\nWhile I can't give an answer to your actual question, I am intrigued by something altogether different, namely the statement\n\n```\nreturn g+fun(h-1)+fun(n-4);\n```\n\n\nObviously, your function has the side effect of changing the global static variable ```\ng```\n. I am not 100% sure whether the ```\nreturn```\n statement's expression actually evaluates in a clearly defined fashion, or whether the result might be undefined.\n\nIt might be a nice exercise to think about the order in which those function calls are executed, and how this affects ```\ng```\n and thereby the function's result.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming with double recursion\r\n                \r\nI am new to dynamic programming. I can't understand the double recursion below. Can anyone explain how it works \n\n```\nint N; // read-only number of wines in the beginning\nint p[N]; // read-only array of wine prices\n\n    int profit(int be, int en) {\n      if (be > en)\n        return 0;\n      // (en-be+1) is the number of unsold wines\n      int year = N - (en-be+1) + 1; // as in the description above\n       return max(\n        profit(be+1, en) + year * p[be],\n        profit(be, en-1) + year * p[en]);\n    }\n```\n\n    ", "Answer": "\r\nConsider ```\nbe```\n and ```\nen```\n as the bounds of an integral closed interval ```\n[be; en]```\n. With each recursion, you remove one element from either bound, until the interval gets empty.\n\nWith each new iteration, ```\nen-be```\n will decrease in value, thus ```\nyear```\n is incremented.\n\nWhat you actually calculate is (```\nbe0```\n and ```\nen0```\n being starting values, i. e. values of first, non-recursive call to the function):\n\n```\n    en0\n     Σ     ((N-en0) + i) * p[S(i)])\n   i = be0\n```\n\n\nWhere ```\nS(x)```\n is some (theoretical) selector function ```\n[be0; en0] -> [be0, en0]```\n that depends on the maxima calculated during recursion.\n\nThis selector function necessarily is bijective (i. e. each p[x] will appear exactly once in the sum for x in [be0; en0]):\n\n```\nmax\n(\n    profit(be + 1, en) + year * p[be],\n    profit(be, en - 1) + year * p[en]\n);\n```\n\n\nWith each recursion returning, you'll add the value of an index that has not been in the interval considered during recursion. As S is bijective, it will produce a permutation P of [be0; en0]; however, it cannot produce arbitrary permutations; each sub-interval will always be of either of the two forms:\n\n```\n[beR, P(beR + 1, ..., enR)]\n[P(beR, ..., enR - 1), enR]\n```\n\n\nbut never have both ```\nbeR```\n and ```\nenR```\n somewhere in the middle.\n\nGetting back to the wine image: you sort your wines by whatever defines the order in ```\np```\n in a row and with each year, you always remove either the beginning or the end of this row, but never select one in the middle.\n\nSo far, there's no dynamic programming involved, though.\n\nIf you look at your recursions closely, you'll discover that you have overlapping sub problems:\n\n```\nprofit(be, en)\n    profit(be + 1, en)\n        profit(be + 2, en)\n        profit(be + 1, en - 1)    <---\n    profit(be, en - 1)\n        profit(be + 1, en + 1)    <---\n        profit(be, en - 1)\n```\n\n\ni. e. you are doing the same work for one and the same interval more than only once. To introduce dynamic programming, you'd extend your algorithm minimally:\n\n```\nint profit(int be, int en)\n{\n    if (be > en)\n       return 0;\n\n    int solution;\n    if(getSolution(be, en, solution))\n        return solution;\n\n    int year = ...;\n    solution = std::max(...); // recursive calls\n    addSolution(be, en, solution);\n    return solution;\n}\n```\n\n\nwith appropriate implementations replacing ```\ngetSolution```\n and ```\naddSolution```\n.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Difference between Dynamic Programming and Divide and Conquer\r\n                \r\nWhat is the main difference between divide and conquer and dynamic programming? If we take an example merge sort is basically solved by divide and conquer which uses recursion . Dynamic programming is also based on recursion than why not Merge sort considered to be an example of dynamic programming? \n    ", "Answer": "\r\nThe two are similar in that they both break up the problem into small problems and solve those. However, in divide and conquer, the subproblems are independent, while in dynamic programming, the subproblems are dependent. Both requiring recombining the subproblems in some way, but the distinction comes from whether or not the subproblems relate to other subproblems (of the same \"level\")\n\nD&C example: Mergesort\n\nIn Mergesort, you break the sorting into a lot of little \"sub-sorts\", that is instead of sorting 100 items, you sort 50, then 25, etc. However, after breaking the original into (for example) 4 \"sub-sorts\", it doesn't matter which you do first; order is irrelevant because they are independent. All that matter is that they eventually get done. As such, each time, you get an entirely independent problem with its own right answer.\n\nDP example: Recursive Fibonacci\n\nThough there are sub-problems, each is directly built on top of the other. If you want the 10th digit, you have to the solve the problems building up to that (1+2, 2+3, etc) in a specific order. As such, they are not independent.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming to Divide and Conquer [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs debugging details. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Edit the question to include desired behavior, a specific problem or error, and the shortest code necessary to reproduce the problem. This will help others answer the question.\r\n                \r\n                    \r\n                        Closed 6 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI am working on this program converting a divide and conquer algorithm to a dynamic programming algorithm. The algorithm is for sequencing (like DNA) and finding the cost to do so. Just to reiterate the dynamic programming algorithm is working and the divide and conquer one is not and I cannot figure out why.\n\n```\n#include<iostream>\n#include <vector>\nusing namespace std;\n\nint penalty;\nint m, n;\nchar x[] = { 'A', 'A', 'C' }; //, 'A', 'G', 'T', 'T', 'A', 'C', 'C' };\nchar y[] = { 'T', 'A' }; //,'A' //, 'G', 'G', 'T', 'C', 'A' }; \n\n//find minimum\nint min(int one, int two, int three)\n{\n    if (one <= two && one <= three)\n        return one;\n    if (two <= one && two <= three)\n        return two;\n    return three;\n}\n\n//divide and conquer way of find the cost of the optimal path\nint optMethod(int i, int j)\n{\n\n    if (i == m)\n        return  2 * (n - j);\n    else if (j == n)\n        return 2 * (m - i);\n    else {\n        if (x[i] == y[j])\n            penalty = 0;\n        else\n            penalty = 1;\n\n        return min(optMethod(i + 1,j + 1) + penalty, optMethod(i + 1,j) + 2, optMethod(i,j + 1) + 2);\n    }\n\n\n}\n\n//dynamic programming way of finding cost of optimal path\nvoid dynamicOptimal(vector<vector<int>>& opt1) {\n    for (int i = m; i >= 0; i--) {\n        for (int j = n; j >= 0; j--) {\n            if (i == m)\n                opt1[m][j] = 2 * (n - j);\n            else if (j == n)\n                opt1[i][n] = 2 * (m - i);\n            else {\n                if (x[i] == y[j])\n                    penalty = 0;\n                else\n                    penalty = 1;\n\n                opt1[i][j] = min(opt1[i+1][j+1] + penalty, opt1[i+1][j] + 2, opt1[i][j+1] + 2);\n            }\n        }\n    }\n}\n\n\nint main() {\n    m = sizeof(x);\n    n = sizeof(y);\n\n    //divide and conquer \n    cout << optMethod(0, 0) << endl;\n\n    //dynamic\n    vector <vector<int> > optimal(m+1, vector<int>(n+1, 0));\n    dynamicOptimal(optimal);\n    cout<<optimal[0][0]<<endl;\n\n\n    cin.get();\n    return 0;\n}\n```\n\n\nWhat I am getting right now is that there is a extra penalty being given but I can't figure out where.\n[NOTE] I know I did not use the std::min and I know its there \n    ", "Answer": "\r\nYou should change :\n\n```\nif (two <= one && two <= two)\n        return two;\n    return three;\n```\n\n\nWith :\n\n```\nif (two <= one && two <= three)\n        return two;\n    return three;\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Difference between dynamic programming and recursion\r\n                \r\nWhat is the difference between dynamic programming and recursion?\nI have gone through many articles in geeksforgeeks tutorial point and Wikipedia, but it seems to me that  both are same.\nCan you please explain me with example of Fibonacci series the difference between dynamic programming and recursion?\n    ", "Answer": "\r\nCalculating terms in the Fibonacci sequence is very easy, since in fact you only need to remember ```\nfib(n-2)```\n and ```\nfib(n-1)```\n in order to calculate ```\nfib(n)```\n. Because it is so easy, any algorithm is going to be extremely simple, so this example blurs the nuances between different dynamic programming paradigms. That being said, the wikipedia page you mentioned has a nice explication about fibonacci: https://en.wikipedia.org/wiki/Dynamic_programming#Fibonacci_sequence\nA function is called recursive if it calls itself during its execution.\nA dynamic programming algorithm might be implemented with or without using recursion.\nThe core of dynamic programming is exploiting the two following facts to write an algorithm:\n\nA solution to a problem can be broken into solutions to subproblems;\nWhen an optimal solution ```\nS```\n to a problem ```\nP```\n is broken into solutions ```\ns1```\n, ```\ns2```\n, ... to subproblems ```\np1```\n, ```\np2```\n, ..., then ```\ns1```\n, ```\ns2```\n, ... are all optimal solutions to their respective subproblems.\n\nNote that these two facts are not true of all problems. A problem only lends itself to dynamic programming if those two facts apply to it.\nA simple example is finding the shortest path from point A to point B: if a shortest path from A to B goes through point C, then its two halves from A to C and from C to B it is made of are also shortest paths.\nIn most situations, you could make recursive calls to solve the subproblems. But a \"naive\" recursive approach can easily result in an exponential algorithm, because of the cascading \"in order to solve this problem, I need to solve these two (or more) subproblems\" that might quickly escalate the number of problems you have to solve. Here is an example with fibonacci:\n```\nfib(5) = fib(4) + fib(3)\n  fib(4) = fib(3) + fib(2)\n    fib(3) = fib(2) + fib(1)\n      fib(2) = fib(1) + fib(0)\n        fib(1) = 1\n        fib(0) = 0\n      fib(1) = 1\n    fib(2) = fib(1) + fib(0)\n      fib(1) = 1\n      fib(0) = 0\n    fib(1) = 1\n  fib(3) = fib(2) + fib(1)\n    fib(2) = fib(1) + fib(0)\n      fib(1) = 1\n      fib(0) = 0\n    fib(1) = 1\n```\n\nHere we had to calculate 16 terms to find ```\nfib(5)```\n. But notice that there are only 6 different terms in total. Surely we could be more efficient by avoiding repeating the same calculations again and again.\nTo avoid this, dynamic programming algorithms most often amount to filling an array with the solutions to the subproblems. Once you've identified the list of subproblems and the array, there might not be much incentive to go \"top-down\" with recursive calls that start with the largest problem and successively break it down into smaller subproblems. Instead, you can fill the array \"bottom-up\" starting from the most trivial problems and then using those to solve the more complex problems, until you've made it up to the problem you originally wanted to solve. In the case of the fibonacci sequence, you might end up with the following code:\n```\nint f[n+1];\nf[0] = 0;\nf[1] = 1;\nfor (int k = 2; k <= n; k++)\n  f[k] = f[k-2] + f[k-1];\nreturn f[n];\n```\n\nHowever, in the case of the fibonacci sequence, you only need to remember the last two terms at any time, so instead of filling a full array with all terms from ```\nfib(0)```\n to ```\nfib(n)```\n, you can simply keep two variables (or a size-2 array) with the previous two results. Arguably this is still dynamic programming, although it ends up simply being a loop that calculates the terms of the sequence in order and it's hard to see anything \"dynamic\" about it.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Parallel Dynamic Programming Travel Salesman\r\n                \r\nAre there any papers discussing how to solve the travel salesman problem with parallel dynamic programming?\n    ", "Answer": "\r\nEntering ```\nparallel dynamic programming traveling salesman```\n as a search in Google Scholar gave some promising results. Inspect those hits and see if you find anything that suits you.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming Example and Issue\r\n                \r\nI'm trying to run a dynamic programming example using VBA that should limit the amount of times the function is recursively called by storing values in a dictionary.\nThe problem I'm running into is the function is recursively called before the value can be stored in the dictionary with its generated key. Typically, I would use the 'return' keyword after the dictionary key stored the associated value, but that doesn't seem to work in VBA.\n```\nPublic Function count_sets_dp(arr, total)\nDim mem As Dictionary\nSet mem = New Dictionary\ncount_sets_dp = dp(arr, total, GetArrLength(arr), mem)\n```\n\nThe final 'else' clause initiates the recursion call without storing the result in mem(key).\n```\nPublic Function dp(arr, total, i, mem)\n'dynamic programming or memoized solution\n\nDim Key As String\nDim to_return As Integer\n\nKey = CStr(total) & \":\" & CStr(i)\nIf mem.Exists(Key) Then\n      dp = mem(Key)\nEnd If\nIf total = 0 Then\ndp = 1\n\n\nElseIf total < 0 Then\ndp = 0\n\n\nElseIf i < 1 Then\ndp = 0\n\n\nElseIf total < arr(i) Then\nto_return = dp(arr, total, i - 1, mem)\n\nElse: to_return = (dp(arr, total - arr(i), i - 1, mem) + dp(arr, total, i - 1, mem))\nmem(Key) = to_return\ndp = to_return\nEnd If\n\nEnd Function\n```\n\nIt seems like I am not benefitting from the dynamic programming solution here, and I am trying to understand if I have a syntax problem...\n```\nSub mysub()\n\nDim timetaken As Double\nDim myArray() As Variant\nDim result As Integer\n\nmyArray = [{2,4,6,4,10,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4}]\n\nresult = count_sets_dp(myArray, 16)\n\nMsgBox (result)\n\nEnd Sub```\n```\n\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming matrix chain multiplication\r\n                \r\nI was reading about the matrix chain multiplication in dynamic programming, \nIt has a naive recursive solution which has a exponential run-time.\n\nhttp://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/\n\nAlthough there is dynamic prog. solution(code in the link above) which has a run-time complexity of O(n^3), but if we keep a 2d array to store results for overlapping sub problems, Will it have a same run-time as the dp solution ?\n\n```\npublic class MatrixChain {\n\n    public static void main(String... args) throws IOException {\n        new MatrixChain().job();\n    }\n\n    private void job() {\n        int arr[] = new int[]{40, 20, 30, 10, 30};\n        int[][] dp = new int[5][5];\n        for (int[] x : dp)\n            Arrays.fill(x, -1);\n        int min = findMin(arr, 1, arr.length - 1, dp);\n        System.out.println(min);\n    }\n\n    private int findMin(int[] arr, int i, int j, int dp[][]) {\n        if (i == j) return 0;\n        int min = Integer.MAX_VALUE;\n        for (int k = i; k < j; k++) {\n            int fp;\n            if (dp[i][k] == -1)\n                dp[i][k] = fp = findMin(arr, i, k, dp);\n            else fp = dp[i][k];\n            int lp;\n            if (dp[k + 1][j] == -1)\n                dp[k + 1][j] = lp = findMin(arr, k + 1, j, dp);\n            else\n                lp = dp[k + 1][j];\n\n            int sum = fp + lp + arr[i - 1] * arr[k] * arr[j];\n            if (sum < min)\n                min = sum;\n        }\n        return min;\n    }\n}\n```\n\n\nThanks!\n    ", "Answer": "\r\nYes, it will have. It doesn't matter if you write your function iterative or recursive. The important thing is, that you memorize your results. And that you do. \n\nAlthough I have a few optimizations:\n\n```\nprivate int findMin(int[] arr, int i, int j, int dp[][]) {\n    if (i == j) \n        return 0;\n\n    /* Immediate look-up in dp */\n    if (dp[i][j] != -1)\n        return dp[i][j];\n\n    /* Otherwise compute the number, much shorter since you don't\n       have to worry about reading from dp and saving it to dp. */\n    int min = Integer.MAX_VALUE;\n    for (int k = i; k < j; k++) {\n        int fp = findMin(arr, i, k, dp);\n        int lp = findMin(arr, k + 1, j, dp);\n        int sum = fp + lp + arr[i - 1] * arr[k] * arr[j];\n        if (sum < min)\n            min = sum;\n    }\n\n    /* Now save the result */\n    dp[i][j] = min;\n    return min;\n}\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Conversion to Dynamic Programming alg\r\n                \r\nI found an exercise where I have to find the maximum sum from contiguous elements of an array, of a certain size. For example, what is the maximum sum of 5 contiguous elements, of an array of 9 positive elements. I read that this is best optimized with a Dynamic Programming approach. I am new to c++ and I would like some help to convert my code to Dynamic Programming alg. Hopefully in the process I will finally understand it. \n\nHere is my code:\n\n```\n  int main() \n{\n\n  int arr[9]{10,25,33,14,5,56,27,8,79};\n  int array_sums[9]{0};\n\n  for(int i = 0; i < 9; ++i)\n  {\n    if(i + 4 > 8) { array_sums[i] = 0; }\n    else{\n      array_sums[i] = arr[i] + arr[i+1] + arr[i+2] + arr[i+3] + arr[i+4];\n    }\n\n  }\n\n  int max{0};\n  int current_max{0};\n\n  for(int i = 0; i < (sizeof(array_sums)/sizeof(array_sums[0])); ++ i)\n  {\n    current_max = array_sums[i];\n    max = (max < current_max) ? current_max:max;\n  }\n\n\n  cout << \"\\n\" << max;\n\n  return 0;\n}\n```\n\n\nThank you for your help and your time!\n    ", "Answer": "\r\nThis is not a good example of a program that can be improved by Dynamic Programming. So instead of ```\n5```\n contiguous elements, I assume you want to find ```\nk```\n contiguous elements, in this case in your line 8 instead of \n\n```\narray_sums[i] = arr[i] + arr[i+1] + arr[i+2] + arr[i+3] + arr[i+4];\n```\n\n\nyou would code something like this: \n\n```\nfor(int j = 0 ; j<k ; j++)   \n    array_sums[i] += arr[i+j];\n```\n\n\nIn this case, your code would be ```\nO(k*n)```\n\n\nnow you could use dynamic programming to improve your code. Instead of the above code, you could simply use something like this:\n\n```\nif(i == 0)\n    for(int j = 0 ; j<k ; j++)   \n        array_sums[i] += arr[i+j];\nelse\n    array_sums[i] = array_sums[i-1] - arr[i-1] + arr[i+k-1];\n```\n\n\nAnd in this case your code would be ```\nO(n)```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming matrix exercise\r\n                \r\nI'm practicing with dynamic programming and I'm trying to solve this exercise http://www.geeksforgeeks.org/collect-maximum-points-in-a-grid-using-two-traversals/ \nBut I can't understand how to use dynamic programming. \n\nMy reasoning is to use a table ```\nT[n][m]```\n to store the results and in every cells to find the max value to go (corresponding to a cell).\n\nUsing the example shown in the link: how do I know at the first cell ```\n[0][0]```\n to go to \"3\" instead of \"5\"? Using my reasoning the choice is to go to \"5\" but it's a bad way\n    ", "Answer": "\r\nYou table should not be used to look ahead as you are suggesting. That sounds more like a greedy approach which indeed is not correct. Instead use what you have calculated from previous iterations to do the calculation in the current iteration.\n\nSimplified I would describe the algorithm as:\n\n\nInitialize a table ```\nT[C][C]```\n and initially set all values to 0. Where ```\nC```\n is the number of columns.\n```\nT[c1][c2]```\n holds the best possible score at the previous row where traveler 1 would be in column ```\nc1```\n and traveler 2 would be in column ```\nc2```\n\nThen you can just iterate over the rows:\n\n\nChecking if for row ```\nr```\n the travelers can be at their respective positions ```\nc1```\n, ```\nc2```\n\nFill up a new table ```\ntmp```\n, where ```\ntmp[c1][c2]```\n is ```\narr[R][c1] + arr[R][c2] + Max(T[c1-1][c2-1]```\n, ```\nT[c1][c2-1], ..., T[c1+1][c2+1])```\n.\nReplace ```\nT```\n with ```\ntmp```\n\n\nResult: ```\nT[0]+T[C-1]```\n\n\n\nRemark: I did not take care about the case were both travelers are on the same spot and they are not both getting the points. I am assuming this is handled in the checking because we should be able to prove that in the optimal solution ```\nc1 < c2```\n for all rows. (except when ```\nC = 1```\n)\n\nWhy this is correct:\n\nAt row ```\nR```\n there are only 9 (3x3) combinations possible starting from the previous row. And for each possible position we always take the best. This means we are actually trying every possible combination for both travelers and we can't miss any better solution. \n\nTo wrap up this algorithm is not giving you the path to the best solution, only the best score. You may be confused by this because you intuïtively are looking for a path. \n\nExtra\n\nIs it possible to get the path with this algorithm too?\n\nYes, but you will need to do some extra work.\nLet's say we keep all are calculated ```\nT```\n arrays for all rows.\nThen we can check for instance the following:\n\n\n```\nT[R][c1][c2] == arr[R][c1] + arr[R][c2] + T[R-1][c-1][c-2]```\n\nThis checks if an optimal path is possible if in the previous row both travelers went to the right. In this way we could walk up back to the starting positions.\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Matrix Exponentiation for 2D array Dynamic Programming\r\n                \r\nI've just read about a another way solve some Dynamic Programming problems (such as calculating large Fibonacci numbers) using Matrix Exponentiation. I wonder if there's any way to use this method to solve Dynamic Programming problems with 2D arrays.\nAn example of Dynamic Programming problems with 2D arrays:\n```\nC[i][0] = 0 for all i\nC[0][j] = 1 for all j\nC[0][0] = 1\n\nC[i][j] = C[i][j-1] + C[i-1][j-1]\n```\n\nCalculate C[i][j] for really large i and j (such as 10^9)\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming algorithm\r\n                \r\nA binary tree T is semi-balanced if for every node m in T:\n\nR(m)/2 <= L(m) <= 2*R(m),\n\nwhere L(m) is the number of nodes in the left-sub-tree of m and R(m) is the number of nodes in the right-sub-tree of m.\n\n(a) Write a recurrence relation to count the number of semi-balanced binary trees with N\nnodes.\n\n(b) Provide a Dynamic Programming algorithm for computing the recurrence in (a).\n\nHow do i go about making the recurrence relation for this?\n\nDoes the following qualify?\n\n```\nif(node==NULL)\nreturn;\nif(given relation is true)\ncount++\nelse find for right tree;\n     find for left tree;\n```\n\n\nI guess he is asking more of a recurrence relation like a function or something.?\n\nAlso how do i go about doing the problem using dynamic programming? I guess i dont need to store anything if i apply the above suggested code snippet.\n\nKindly help.\n    ", "Answer": "\r\nHint: Let ```\nC(n)```\n be number of semi-balanced trees with ```\nn```\n nodes. If you know values for ```\nC(1), C(2), ..., C(n)```\n than it is easy to calculate ```\nC(n+1)```\n by taking root node and dividing remaining ```\nn```\n nodes into left and right sub-trees by condition stated.\n\nNumber of nodes in sub-trees can be from ```\nn/3```\n to ```\n2*n/3```\n, since these values satisfy condition ```\nR(n)/2 <= L(n) <= 2*R(n)```\n.\n\nUpdate:\n\n```\nC(n) = sum from n/3 to 2n/3 L(n)*R(n)```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Helping to solve program knapsack the dynamic programming method\r\n                \r\nFriends who can program \"knapsack the dynamic programming method\" and \"C ++\" Will share with me?\nAlgorithm to solve knapsack with dynamic programming:\n\nThank You all\n\nCode to the method of \"weight / value\" :\n\n```\n#include <conio.h>\n#include <stdio.h>\n#include <iostream>\n#include <windows.h>\nusing namespace std;\nvoid gotoxy(int x, int y)\n{\n    COORD pos;\n    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n\n    if (INVALID_HANDLE_VALUE != hConsole)\n    {\n        pos.X = x;\n        pos.Y = y;\n\n        SetConsoleCursorPosition(hConsole, pos);\n    }\n}\n\nint wherey()\n{\n    CONSOLE_SCREEN_BUFFER_INFO csbi;\n    COORD                      result;\n    if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi))\n        return -1;\n    result = csbi.dwCursorPosition;\n    return result.Y;\n}\n\nint wherex()\n{\n    CONSOLE_SCREEN_BUFFER_INFO csbi;\n    COORD                      result;\n    if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi))\n        return -1;\n    result = csbi.dwCursorPosition;\n    return result.X;\n}\n\nvoid sortbypw(int p[], int w[], int n)\n{\n    int i, t, j;\n    for (i = 0; i <= n - 1; i++)\n        for (j = i + 1; j <= n; j++)\n            if (((float)p[i] / w[i])<((float)p[j] / w[j]))\n            {\n        t = p[i];\n        p[i] = p[j];\n        p[j] = t;\n        t = w[i];\n        w[i] = w[j];\n        w[j] = t;\n    }\n}\n\nfloat knapsack(int p[], int w[], int n, int m)\n{\n    sortbypw(p, w, n);\n    int w1 = m;\n    int i = 0;\n    float pp = 0;\n    while (i <= n && w1>0)\n    {\n        if (w[i]<w1)\n        {\n            cout << \" p : \" << p[i];\n            w1 -= w[i];\n            pp += p[i];\n            i++;\n        }\n        else\n        {\n            cout << \" p : \" << p[i];\n            pp += w1*((float)p[i] / w[i]);\n            w1 = 0;\n        }\n    }\n    return pp;\n}\n\nvoid main()\n{\n    // Ali Aghajani 2015/06/07\n    int p[100] = { 6, 12, 7, 18, 9, 30 };\n    int w[100] = { 1, 5, 3, 9, 5, 20 };\n    system(\"cls\");\n    cout << \"If You Want Input Data Press (Y) Else Press (N) :\";\n    char ch = cin.get();\n    if (ch == 'n')\n        cout << \"\\n\\n Arzesh Knapsack : \" << knapsack(p, w, 5, 20);\n    else\n    {\n        int n, m;\n        cout << \"\\nEnter Weight Knapsack : \";\n        cin >> m;\n        cout << \"Enter Num : \";\n        cin >> n;\n        for (int i = 0; i<n; i++)\n        {\n            cout << \"Enter Arzesh : \";\n            cin >> p[i];\n            cout << \"\\nEnter Weight : \";\n            cin >> w[i];\n            gotoxy(20, wherey() - 2);\n            cout << \" P/W Is : \" << (float)p[i] / w[i];\n            gotoxy(1, wherey() + 2);\n            cout << \".......................................\\n\";\n        }\n        cout << \"\\n\\n Arzesh Knapsack : \" << knapsack(p, w, n - 1, m);\n    }\n}\n```\n\n    ", "Answer": "\r\nHasty judgment!\n\nI am sorry for some people!\n\nMy problem, I replied:\n\n```\n#include <iostream>\n#include <string>\nusing namespace std;\nvoid main(){\n    // Ali Aghajani 2015/06/08\n    int i, w, W, n, p[50][2], B[50][50];\n    string R[50][50];\n    char end = 'y';\n    while (end == 'y' || end == 'Y'){\n        system(\"cls\");\n        cout << \"Enter Weight Knapsack (Max Value=50): \";\n        cin >> W;\n        cout << \"Enter Num Object (Max Value=50): \";\n        cin >> n;\n        cout << \"\\n\";\n        p[0][0] = p[0][1] = 0;\n        for (w = 0; w <= W; w++){\n            for (i = 0; i <= n; i++){\n                R[w][i] = \"\";\n            }\n        }\n\n        for (i = 1; i <= n; i++){\n            cout << \"\\tItem[\" << i << \"] Arzash: \";\n            cin >> p[i][0];\n            cout << \"\\tItem[\" << i << \"] Weight: \";\n            cin >> p[i][1];\n            cout << \"\\n\";\n        }\n        system(\"cls\");\n        cout << \"\\n\\t     p| \";\n        for (i = 1; i <= n; i++){\n            if (i <= 9)\n                cout << \"0\" << i << \" \";\n            else\n                cout << i << \" \";\n        }\n        cout << \"\\n\\t       \";\n        for (i = 1; i <= n; i++){\n            cout << \"---\";\n        }\n        cout << \"\\n\\tArzash| \";\n        for (i = 1; i <= n; i++){\n            if (p[i][0] <= 9)\n                cout << \"0\" << p[i][0] << \" \";\n            else\n                cout << p[i][0] << \" \";\n        }\n        cout << \"\\n\\tWeight| \";\n        for (i = 1; i <= n; i++){\n            if (p[i][0] <= 9)\n                cout << \"0\" << p[i][1] << \" \";\n            else\n                cout << p[i][1] << \" \";\n        }\n        cout << \"\\n\";\n        for (w = 0; w <= W; w++){ B[w][0] = 0; }\n        for (i = 0; i <= n; i++){ B[0][i] = 0; }\n        for (i = 1; i <= n; i++){\n            for (w = 1; w <= W; w++){\n                if (p[i][1] <= w){\n                    if (p[i][0] + B[w - p[i][1]][i - 1] > B[w][i - 1]){\n                        B[w][i] = p[i][0] + B[w - p[i][1]][i - 1];\n                        string k = std::to_string(i);\n                        R[w][i] = R[w - p[i][1]][i - 1] + \"p[\" + k + \"] \";\n                    }\n                    else{\n                        B[w][i] = B[w][i - 1];\n                        R[w][i] = R[w][i] + R[w][i - 1];\n                    }\n                }\n                else{\n                    B[w][i] = B[w][i - 1];\n                    R[w][i] = R[w][i] + R[w][i - 1];\n                }\n            }\n        }\n        cout << \"\\n\\tTable values: \";\n        for (w = 0; w <= W; w++){\n            for (i = 0; i <= n; i++){\n                if (B[w][i] <= 9)\n                    cout << \"0\" << B[w][i] << \" \";\n                else\n                    cout << B[w][i] << \" \";\n            }\n            cout << \"\\n\\t              \";\n        }\n\n        cout << \"\\n\\n\\t# Arzash Knapsack: \" << B[W][n];\n        cout << \"\\n\\n\\t# Items: \" << R[W][n];\n        cout << \"\\n\\n\\n\\tIf You Want Continue Press (Y) Else Press Key : \";\n        cin >>end;\n    }\n}\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Recursive programming calls versus dynamic programming calls [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                It's difficult to tell what is being asked here. This question is ambiguous, vague, incomplete, overly broad, or rhetorical and  cannot be reasonably answered in its current form. For help clarifying this question so that it can be reopened,  visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI'm taking a Java 2 course and trying to study but I don't understand this concept:\n\n\nWhat is the difference between recursive programming calls and dynamic programming calls?\nWhat would be an example of each?\n\n    ", "Answer": "\r\nThe two concept are rather different:\n\n\nA function is called recursive if it calls itself.\nDynamic programming is a technique for solving problems. It involves first solving a smaller sub-problem and then extending the solutions to a solution for the overall problem.\n\n\nIt is often the case the dynamic programming algorithm can be expressed recursively.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "formulation of general dynamic programming problem\r\n                \r\nI wonder if the objective function of a general dynamic programming problem can always be formulated as in dynamic programming on wiki, where the objective function is a sum of items for action and state at every stage? Or that is just a specical case and what is the general formulation?\n\n\n\nEDIT:\n\nBy \"dynamic programming problem\", I mean a problem that can be solved by dynamic programming technique. Such kind of problems possess the property of optimal problem and optimal structure.\n\nBut at lease for me it is sometimes not easy to identify such problems, perhaps because I have not become used to that kind of verbal description. When I came across the WIKI page for Bellman equation, I do feel mathematical formulation of the cost function will help somehow.  I suspect the overall cost/gain function can always be represented as accumulation of cost/gain from all the stages? and the accumulation can be additive or multiplitive or something else? \n\nWhen I posted my question, I did realize that it is more proper to discuss dynamic programming in some place more oriented to mathematical optimization. But there are quite a lot of discussion of computer algorithms in Stackoverflow.com. So I did not feel improper to ask my question here either.\n    ", "Answer": "\r\nThat's not how I would characterize an arbitrary optimization problem (or a dynamic programming algorithm). In particular, the factor βt looks like an electrical engineering hack that programmers wouldn't usually want. More subtly, it seems like it won't always be obvious what the function F is for a given problem.\n\nBut yes, set β to 1 and any arbitrary objective function can be formulated that way. Generally the objective function may be any function of the initial state and all the actions taken; given such a function, it's easy to define a function F to plug into that formula.\n\nWhether that's a useful thing to do or not depends on the problem, I suppose.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "TSP using Dynamic Programming [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI am learning TSP and found this recursive solution to TSP\n\n```\nint compute(int start,int set)\n{   int masked,mask,result=INT_MAX,temp,i;//result stores the minimum \n    if(g[start][set]!=-1)//memoization DP top-down,check for repeated subproblem\n        return g[start][set];\n    for(i=0;i<n;i++)\n        {   //npow-1 because we always exclude \"home\" vertex from our set\n            mask=(npow-1)-(1<<i);//remove ith vertex from this set\n            masked=set&mask;\n            if(masked!=set)//in case same set is generated(because ith vertex was not present in the set hence we get the same set on removal) eg 12&13=12\n            {   \n                temp=adj[start][i]+compute(i,masked);//compute the removed set\n                if(temp<result)\n                    result=temp,p[start][set]=i;//removing ith vertex gave us minimum\n            }\n        }\n        return g[start][set]=result;//return minimum\n}\n```\n\n\nI could not understand How masking is working , How can change it to Dynamic programming solution without using recursion , please help me.\n    ", "Answer": "\r\nHere is a traditional TSP problem ,and here is the solution for it . I think it may be helpful to you.\n\n```\nint map[15][15];\nint dp[(1<<12)+5][12];\n\nint main() {\n    int i,j,n,ans,k,p;\n    while(1) {\n        scanf(\"%d\",&n);\n        if (n==0) break;\n        n++;\n        for (i=0; i<n; i++) {\n            for (j=0; j<n; j++) {\n                scanf(\"%d\",&map[i][j]);\n            }\n        }\n        //floyd algorithm, get any two points's minimum distance\n        for (k=0; k<n; k++) {\n            for (i=0; i<n; i++) {\n                for (j=0; j<n; j++) {\n                    if (i!=j && i!=k && j!=k) map[i][j]=min(map[i][k]+map[k][j],map[i][j]);\n                }\n            }\n        }\n        memset(dp,-1,sizeof(dp));\n        dp[1][0]=0;\n        // TSP solution here,bitmask and DP\n        for (i=1; i<(1<<n); i++) {// the current state\n            for (j=0; j<n; j++) {// during the current state,the last station is j\n                if (dp[i][j]==-1) continue;\n                for (k=1; k<n; k++) {//the next state is k\n                    if ((i & (1<<k))!=0) continue;\n                    p=(i | (1<<k));// the new state(join k)\n                    if (dp[p][k]==-1) dp[p][k]=dp[i][j]+map[j][k];\n                    dp[p][k]=min(dp[p][k],dp[i][j]+map[j][k]);\n                }\n            }\n        }\n        ans=INF;\n        // get answer\n        for (i=1; i<n; i++) {\n            if (dp[(1<<n)-1][i]>0) ans=min(ans,dp[(1<<n)-1][i]+map[i][0]);\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Adding Memoization - Dynamic Programming\r\n                \r\nI am currently practicing some dynamic programming and I came across the Circus Tower problem.\nI solved the problem with dynamic programming and implemented it using recursion.  I've tested it with few inputs and it seems to work fine. \n\nNow, I've been struggling few hours trying to figure out how to add memoization to my solution.  \n\nQuestions\n\n\nHow can I add a working memoization to my solution. Where is my mistake in this case?\nIs there any rule of thumb, or guidlines for how to add memoizations in general.\n\n\n\n\nThe Circus Tower Problem:\nA circus is designing a tower of people standing atop one another’s shoulders. Each person must be both shorter and lighter than the person below him. Given the heights and weights of each person in the circus, write a method to compute the largest possible number of people in such a tower.\n\nMy Solution & Code\nDynamic Programming\n\n```\nOPT[N,P] = highest tower with N given persons and person P is at the top\n----------------------------------------------------------\nOPT[0,P]                                = 0\nOPT[i,P] where person i can be above P  = max(OPT[i-1,i]+1,OPT[i-1,P])\nOPT[i,P] else                           = OPT[i-1,P]\n```\n\n\nCode: \n\n```\nstruct Person{\n    int ht;\n    int wt;\n};\n\n// Without Memoization\nint circusTower(int n, Person* top, std::vector<Person>& persons){\n    if (n == 0)\n        return 0;\n\n    if (top == NULL || top->ht > persons[n - 1].ht && top->wt > persons[n - 1].wt)\n        return max(circusTower(n - 1, &persons[n - 1], persons) + 1, circusTower(n - 1, top, persons));\n    else\n        return circusTower(n - 1, top, persons);\n}\n\n// With Memoization\nint circusTower(int n, Person* top, std::vector<Person>& persons, std::vector<int>& memo){\n    if (n == 0)\n        return 0;\n\n    int result;\n    if (memo[n-1] == 0) {\n        if (top == NULL || top->ht > persons[n - 1].ht && top->wt > persons[n - 1].wt)\n            result = max(circusTower(n - 1, &persons[n - 1], persons, memo) + 1,\n                         circusTower(n - 1, top, persons, memo));\n        else\n            result = circusTower(n - 1, top, persons, memo);\n\n        memo[n - 1] = result;\n        return result;\n    } else {\n        return memo[n-1];\n    }\n}\n```\n\n\nMain - test:\n\n```\nint main(){\n    std::vector<Person> persons = { {65, 100},{100, 150},{56, 90}, {75, 190}, {60, 95},{68, 110} };\n    std::stable_sort(persons.begin(), persons.end(), sortByWt);\n    std::stable_sort(persons.begin(), persons.end(), sortByHt);\n\n    std::vector<int> memo(6,0);\n\n    //Without memoization\n    cout << circusTower(6, NULL, persons) << endl;\n    //With memoization\n    cout << circusTower(6, NULL, persons, memo) << endl;\n}\n```\n\n\nIn the example inside the main above, the right result is 5. My regular solution (without memoization) prints 5, but with memoization it prints 6.\n    ", "Answer": "\r\nYour method depend of 3 arguments\nbut you memoize only from the first argument ```\nn```\n\nIndeed in your case, the third one (```\npersons```\n) is constant,\nbut the second one (```\ntop```\n) changes during the recursive call.\nso due to your memoization, both the following return wrongly the same value:\n\n```\ncircusTower(n - 1, &persons[n - 1], persons, memo)```\n\n```\ncircusTower(n - 1, top, persons, memo)```\n\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming in F#\r\n                \r\nWhat is the most elegant way to implement dynamic programming algorithms that solve problems with overlapping subproblems? In imperative programming one would usually create an array indexed (at least in one dimension) by the size of the problem, and then the algorithm would start from the simplest problems and work towards more complicated once, using the results already computed.\n\nThe simplest example I can think of is computing the Nth Fibonacci number:\n\n```\nint Fibonacci(int N)\n{\n    var F = new int[N+1];\n    F[0]=1;\n    F[1]=1;\n    for(int i=2; i<=N; i++)\n    {\n        F[i]=F[i-1]+F[i-2];\n    }\n    return F[N];\n}\n```\n\n\nI know you can implement the same thing in F#, but I am looking for a nice functional solution (which is O(N) as well obviously).\n    ", "Answer": "\r\nOne technique that is quite useful for dynamic programming is called memoization. For more details, see for example blog post by Don Syme or introduction by Matthew Podwysocki.\n\nThe idea is that you write (a naive) recursive function and then add cache that stores previous results. This lets you write the function in a usual functional style, but get the performance of algorithm implemented using dynamic programming.\n\nFor example, a naive (inefficient) function for calculating Fibonacci number looks like this:\n\n```\nlet rec fibs n = \n  if n < 1 then 1 else\n  (fibs (n - 1)) + (fibs (n - 2))\n```\n\n\nThis is inefficient, because when you call ```\nfibs 3```\n, it will call ```\nfibs 1```\n three times (and many more times if you call, for example, ```\nfibs 6```\n). The idea behind memoization is that we write a cache that stores the result of ```\nfib 1```\n and ```\nfib 2```\n, and so on, so repeated calls will just pick the pre-calculated value from the cache.\n\nA generic function that does the memoization can be written like this:\n\n```\nopen System.Collections.Generic\n\nlet memoize(f) =    \n  // Create (mutable) cache that is used for storing results of \n  // for function arguments that were already calculated.\n  let cache = new Dictionary<_, _>()\n  (fun x ->\n      // The returned function first performs a cache lookup\n      let succ, v = cache.TryGetValue(x)\n      if succ then v else \n        // If value was not found, calculate & cache it\n        let v = f(x) \n        cache.Add(x, v)\n        v)\n```\n\n\nTo write more efficient Fibonacci function, we can now call ```\nmemoize```\n and give it the function that performs the calculation as an argument:\n\n```\nlet rec fibs = memoize (fun n ->\n  if n < 1 then 1 else\n  (fibs (n - 1)) + (fibs (n - 2)))\n```\n\n\nNote that this is a recursive value - the body of the function calls the memoized ```\nfibs```\n function.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming algorithm\r\n                \r\nI'm going through this textbook trying to solve some algorithms to better my skills and I'm currently stuck at this problem:\n\n\n\nThe chapter is on dynamic programming and I'm really just having trouble starting the problem since I don't know how to approach these types of problems. Can anyone help me solve it or point me to an existing algorithm that's similar?\n    ", "Answer": "\r\nThe solution to this problem is the solution of the following recursive formula:\n\n```\nf(i) = max{ l_i + f(i+k_i) , f(i+1) }\nf(x) = 0 : for all x > n\n```\n\n\nThe solution for the problem is the solution of ```\nf(1)```\n.\n\nExplanation: For each day, you can either \"skip\" this day, and check the next day (or the one after it, ... , this is done by invoking ```\nf(i+1)```\n) - or take lollies, and then you have the option to come back only after ```\nk_i```\n days - meaning you add the solution of ```\nf(i+k_i)```\n .\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming in Lazy Racket\r\n                \r\nI am trying to remember how to do dynamic programming in lazy racket. I started wondering this after I solved one of Project Euler's problems:\n\n\n  By starting at the top of the triangle below and moving to adjacent\n  numbers on the row below, the maximum total from top to bottom is 23.\n\n```\n   3\n  7 4\n 2 4 6\n8 5 9 3\n```\n\n  \n  That is, 3 + 7 + 4 + 9 = 23.\n  \n  Find the maximum total from top to bottom of the triangle below:\n  ...\n\n\nwhich I solved with the code below. However, I was taught about lazy racket (and indeed, programming languages in general) in school, and I seem to remember that in lazy languages, it is much easier to solve dynamic programming problems. For example, in the solutions that other eulerists have posted, one posted the haskell code he used to solve the problem, and it was barely one moe line of code than it took to actually specify the data in the problem (what was in the triangle itself). However, I didn't understand the code and so I'm still confused.\n\nSummary:\n\n\nHow does one solve dynamic programming problems in lazy racket? As an example, answers might solve the 4-level triangle example (as opposed to the full 15-level triangle) problem as given above, or post some previously made edit distance code (that's how I learned DP).\nWhy is it easier to do dynamic programming in lazy languages (such as lazy racket)?\n\n\nThe 80 lines of code that I used to solve the DP problem in regular racket is given below.\n\n```\n#lang racket\n(define (triangle-ref x y)\n  (let ((triangle\n       (vector-immutable\n         (vector-immutable 04 62 98 27 23 09 70 98 73 93 38 53 60 04 23)\n         (vector-immutable 63 66 04 68 89 53 67 30 73 16 69 87 40 31)\n         (vector-immutable 91 71 52 38 17 14 91 43 58 50 27 29 48)\n         (vector-immutable 70 11 33 28 77 73 17 78 39 68 17 57)\n         (vector-immutable 53 71 44 65 25 43 91 52 97 51 14)\n         (vector-immutable 41 48 72 33 47 32 37 16 94 29)\n         (vector-immutable 41 41 26 56 83 40 80 70 33)\n         (vector-immutable 99 65 04 28 06 16 70 92)\n         (vector-immutable 88 02 77 73 07 63 67)\n         (vector-immutable 19 01 23 75 03 34)\n         (vector-immutable 20 04 82 47 65)\n         (vector-immutable 18 35 87 10)\n         (vector-immutable 17 47 82)\n         (vector-immutable 95 64)\n         (vector-immutable 75))))\n    (vector-ref (vector-ref triangle y) x)))\n(define triangle-size 15)\n(define (problem18)\n  (let ((table (let fill-table ((table (hash))\n                                (current-x 0)\n                                (current-y 0))\n                 (cond ((>= current-y triangle-size) table)\n                       ((>= current-x (- triangle-size current-y))\n                        (fill-table table 0 (add1 current-y)))\n                       (else (let ((reference (cons current-x current-y))\n                                   (triangle-value (triangle-ref current-x\n                                                                 current-y)))\n                               (if (= current-y 0)\n                                 (fill-table (hash-set table\n                                                       reference\n                                                       (cons triangle-value\n                                                             empty))\n                                             (add1 current-x)\n                                             current-y)\n                                 (let* ((left-entry (hash-ref\n                                                      table\n                                                      (cons\n                                                        current-x\n                                                        (sub1 current-y))))\n                                        (left-cost (car left-entry))\n                                        (left-path (cdr left-entry))\n                                        (right-entry (hash-ref\n                                                       table\n                                                       (cons\n                                                         (add1\n                                                           current-x)\n                                                         (sub1\n                                                           current-y))))\n                                        (right-cost (car right-entry))\n                                        (right-path (cdr right-entry)))\n                                   (if (> left-cost right-cost)\n                                     (fill-table (hash-set table\n                                                           reference\n                                                           (cons\n                                                             (+ triangle-value\n                                                                left-cost)\n                                                             (cons\n                                                               triangle-value\n                                                               left-path)))\n                                                 (add1 current-x)\n                                                 current-y)\n                                     (fill-table (hash-set table\n                                                           reference\n                                                           (cons\n                                                             (+ triangle-value\n                                                                right-cost)\n                                                             (cons\n                                                               triangle-value\n                                                               right-path)))\n                                                 (add1 current-x)\n                                                 current-y))))))))))\n    (car (hash-ref table (cons 0 (sub1 triangle-size))))))\n(problem18)\n(provide problem18)\n```\n\n    ", "Answer": "\r\nFor certain types of problems, laziness allows you to organize your solution in a nice, modular way, where you can first code as if you were generating every possible solution (even if there are infinite possibilities), and then separately write code to test whether a solution is a valid solution. In a lazy language, such an algorithm would check only enough possible solutions to compute the final result and all the other possibilities are naturally not computed so it's as efficient as more complicated strategies like backtracking.\n\nA canonical example is an algorithm to solve a sudoku puzzle (a google search will turn up plenty of examples). You may also be interested in a paper by John Hughes called \"Why Functional Programming Matters\".\n\nHaving said that, in this specific case, laziness won't help much. A dynamic-programming-style solution in either an eager or lazy language will work fine (and will look approximately the same).\n\nWhen solving a problem like this, it's often helpful to compute a naive solution first and then improve it. The naive solution would compute every possible total and then take the maximum. For the small triangle example, you would compute 3+7+2+8, 3+7+2+5, etc. but just writing that down reveals a possible improvement since 3+7+2 is repeated. Avoiding these kinds of repeated computations is precisely what dynamic programming does. A dynamic algorithm will calculate these intermediate results only once, and then re-use it multiple times.\n\nWe do this by incrementally computing the maximum total, one row at a time. A function to compute the maximum total in this manner might look like this:\n\n(Note: You'll need to install the latest nightly build to run this Racket code.)\n\n```\n;; A Row is a list of at least one number.\n\n;; A Triangle is a list of at least one Row,\n;;  where each row has one more number than the previous row.\n\n;; ----------------------------------------------------------------------------\n;; top-down solution\n\n;; max-tri-route : Triangle -> Number\n;; Computes the maximum total when moving from top of triangle to bottom.\n(define/match (max-tri-route tri)\n  [((list a-single-row)) \n   (apply max a-single-row)]\n  [((list-rest row1 row2 rest-rows))\n   (max-tri-route (cons (process-row row1 row2) rest-rows))])\n```\n\n\nI'm assuming a triangle is represented with a list of lists, where each sublist represents a row. We assume that the first row of the triangle represents our incrementally calculated totals. This function says that if there's only one row, then take the max of that row. Otherwise, call a process-row function with the first row (the totals so far) and the second row. The process-row function incorporates the second row into the intermediate totals and might look something like this:\n\n```\n;; process-row : Row Row -> Row\n;; Takes a list of intermediate maximum values and a row, and incorporates\n;;  the given row into the intermediate values.\n;; - new-row always has one more element than tmp-maxes\n;; - produces list of length new-row\n(define/match (process-row tmp-maxes new-row)\n  [((list x) (list y z)) \n   (list (+ x y) (+ x z))]\n  [((list-rest x rest-maxes) (list-rest y z rest-row)) \n   (define res (process-row rest-maxes (cons z rest-row)))\n   (cons (+ x y) (cons (max (+ x z) (first res)) (rest res)))])\n```\n\n\nThis function assumes that the second given row always has one more number than the first given row. If the given two rows have only one and two numbers respectively, then just add the number from the first row to each of the numbers in the second row. Otherwise, we compute the new intermediate totals by considering three numbers at a time: one from the first given row and the two adjacent numbers from the second given row. Of course, each number in the second given row (except the ends) has two adjacent numbers from the first row so we only want to take the greater one. For example, in the little triangle example, calling process-row on the first two rows produces the intermediate values 10 and 7. Then if process-row is called with 10 7 and the next row 2 4 6, it first considers 10 with 2 and 4, producing 12 and 14. But it also has to consider 7 with the 4 below. Since 7+4=11 is less than 14, the intermediate total that we keep is the 14. The resulting intermediate totals after incorporating the third row are 12 14 13.\n\nThe solution above will efficiently produce the correct answer, even for the triangle in Problem 67. But it feels a little awkward, especially in the second part of process-row where we have to consider the overlapping cases. Let's see if we can make the solution better.\n\nTake # 2:\n\nIn the first solution, since we process the triangle top down, our list of intermediate totals grows with each row. But then at the end we have to compute the maximum over all the intermediate values. But nothing says we have to process the triangle from the top down. Since we are only interested in the total, we would get the same answer going bottom-up. Let's see what this would look like:\n\n```\n;; ----------------------------------------------------------------------------\n;; bottom-up solution\n\n(define (max-tri-route2 tri) (max-tri/bottom-up (reverse tri)))\n\n;; Computes total starting from bottom row.\n(define/match (max-tri/bottom-up tri)\n  [((list (list the-max-total))) \n   the-max-total]\n  [((list-rest row1 row2 rest-rows))\n   (max-tri/bottom-up (cons (process-row/bottom-up row2 row1) rest-rows))])\n\n;; - tmp-maxes always has one more element than new-row\n;; - produces list of length new-row\n(define/match (process-row/bottom-up new-row tmp-maxes)\n  [((list x) (list y z))\n   (list (+ x (max y z)))]\n  [((list-rest x rest-row) (list-rest y z rest-maxes))\n   (cons (+ x (max y z)) (process-row/bottom-up rest-row (cons z rest-maxes)))])\n```\n\n\nWith the bottom up approach, we just have one value at the end, the final answer. Also, process-row/bottom-up is simpler than process-row since we can just directly keep the greater of the two numbers now.\n\nHowever, we can do even better.\n\nTake # 3:\n\nThis pattern of iterating over a list and accumulating intermediate values is common enough that there are built-in functions that do this: foldr and foldl. Each of these functions takes a list to traverse, an initial intermediate value, and a function that combines the next value in the list with the current intermediate value. But what's the combining function we need? It turns out that it's exactly our process-row function. Here's the solution with foldl:\n\n```\n;; ----------------------------------------------------------------------------\n;; bottom-up, with foldl\n\n(define (max-tri-route3 tri)\n  (define rev-tri (reverse tri))\n  (first (foldl process-row/bottom-up (first rev-tri) (rest rev-tri))))\n```\n\n\nfoldl starts at the left of the list, but since we want to go bottom-up, we first reverse the list. We use the first (ie bottom) row as the initial intermediate values and the rest of the rows as the triangle. When we are done, we'll have a list of one value, the answer.\n\nTake # 4:\n\nOne final refinement. Why are we reversing the triangle, and then starting on the left. Why don't we just start on the right with foldr, using the last row as the initial accumulator? The problem with foldr is that we have to explicitly specify an initial accumulator but some languages like Haskell have a built-in function foldr1 that automatically uses the last element of the list as the initial intermediate value. Racket doesnt have it but we can easily implement it.\n\n```\n;; ----------------------------------------------------------------------------\n;; bottom-up, with foldr1\n\n(define/match (foldr1 f lst)\n  [(_ (list x)) x]\n  [(_ (list-rest x rest)) (f x (foldr1 f rest))])\n\n(define (max-tri-route4 tri) (first (foldr1 process-row/bottom-up tri)))\n```\n\n\nOf course, the foldr1 function assumes that the list you give it has at least one element. With the foldr1 function and using our process-row/bottom-up function from before, our solution is now a one-line function. This is probably what the Haskell solution you saw looked like as well.\n\nFor the full program with this code, see here.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming in power sets\r\n                \r\nIs it possible to use dynamic programming in the calculation of power set of a string (ie, all possible subsequences of that string) to reduce the number of computations significantly?\n    ", "Answer": "\r\nNo. If you are calculating a powerset, you are calculating a powerset, which always has the same number of elements.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Subset Sum Overlapping subproblems (Dynamic programming)\r\n                \r\nThe link to the question is as follows:\nhttps://www.geeksforgeeks.org/dynamic-programming-subset-sum-problem/\nI do not see the overlapping subproblem property being fulfilled in the question atleast for ever input case. \nFor instance in the follwing link, the recursive tree does not have any overlapping subproblem\nhttp://www.zrzahid.com/subset-sum-problem-dynamic-programming/\n\nAlso, for instance in the following program there are no overlapping subproblems. I do not understand how dynamic programming helps here, when there are no overlapping subproblems. Please explain.\n\n```\nbool isSubsetSum(int set[],int n, int sum)\n{\n    if(sum==0)\nreturn true;\nif(n==0 || sum<0)\n    return false;\nreturn isSubsetSum(set,n-1,sum-set[n-1]) || isSubsetSum(set,n-1,sum);\n}\nint main()\n{\n  int set[] = {3, 34, 4, 12, 5, 2};\n  int sum = 9;\n  int n = sizeof(set)/sizeof(set[0]);\n  if (isSubsetSum(set, n, sum) == true)\n     printf(\"Found a subset with given sum\");\n  else\n     printf(\"No subset with given sum\");\n  return 0;\n}\n```\n\n    ", "Answer": "\r\nThink about it this way:\n\nIf there is a sum within set[] elements equals to sum there are 2 distinct possibilities:\n\n\nthe last element (its index is n-1)  is included in the sum\n        -> in that case the other n-1 elements sum up to sum - set[n-1]\nthe last element (its index is n-1) is not included in the sum\n        -> in that case the other n-1 elements sum up to sum.\n\n\nThe OR in the statement: ```\nreturn isSubsetSum(set,n-1,sum-set[n-1]) || isSubsetSum(set,n-1,sum);```\n checks for both possibilities 1. and 2. recursively.\n\nIf there are some elements in the set[] equals to sum the recursion at some point will reach the case sum = 0; and it will return true at the downest recursion level, which will propagate the TRUE up to the original call (remember: A OR B returns TRUE if at least one of the A or B is TRUE).\n\nOtherwise you are reaching the case sum not equal to 0 and n equals to 0 which will propagate FALSE.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Is prefix sum included in dynamic programming?\r\n                \r\nI've been solving algorithm problems, and I'm a bit confused about the terms.\nWhen we want to calculate prefix sum (or cumulative sum) like the code below, can we say that we are using dynamic programming?\n```\ndef calc_prefix_sum(nums):\n    N = len(nums)\n    prefix_sum = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]\n    return prefix_sum\n\nnums = [1, 3, 0, -2, 1]\nprint(calc_prefix_sum(nums))\n```\n\n```\n[0, 1, 4, 4, 2, 3]\n```\n\nAccording to the definition in this page,\n\nDynamic programming is used where we have problems, which can be\ndivided into similar sub-problems so that their results can be\nre-used.\n\nIn my prefix_sum algorithm, the current calculation (prefix_sum[i]) is divided into similar sub-problems (prefix_sum[i - 1] + nums[i - 1]) so that the previous result (prefix_sum[i - 1]) can be re-used. So I am assuming that calculating prefix sum is one of  the applications of dynamic programming.\nCan I say it's dynamic programming, or should I use different terms? (Especially, I am thinking about the situation in coding interviews.)\n    ", "Answer": "\r\nNo, the correct term is memoization, not dynamic programming. Dynamic programming requires the problem to have optimal substructure as well as overlapping subproblems. Prefix sum has optimal substructure but it does not have overlapping subproblems. Therefore, this optimization should be called memoization.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Time of dynamic programming algorithms\r\n                \r\nThe time of a dynamic programming algorithm is always O(P) where P is the number of subproblems.\n\nIs the above proposition right? Or is there a counter-example?\n    ", "Answer": "\r\nYour proposition is too simple, unfortunately. If P is the number of subproblems, well, depending on the situation, maybe you only need to solve a fraction of them in order to deduce DP(N).  Or, perhaps you need to solve all of them, but combining them to yield DP(N) costs O(P) time itself, so the runtime would really be O(P^2).\n\nAn example of the first case is perhaps the repeated squaring method.  In order to find out 59^1000000 mod 123981238, you could figure out 59^1, 59^2, etc, one at a time and eventually reach 59^1000000.  Or, with repeated squaring, you only care about a small fraction of the subproblems and get a much faster algorithm.\n\nAn example of the second case is the question from how to improve this code?.\nTo summarize the question: Given an integer N, we want to find the shortest list of squares which sum up to N.  For example, for N=1000, we want 30^2 + 10^2.  For N = 3, 1^2 + 1^2 + 1^2.  If you consider 1...N-1 as the 'subproblems', then by iterating over the squares less than N, it takes O(sqrt(N)) time to yield the answer for N.  In this way, there were only O(N) subproblems, but to combine them at each point in time took O(sqrt(N)), so the overall runtime would be O(Nsqrt(N)).\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming from cormen's book\r\n                \r\nWhen reading about dynamic programming in \"Introduction to algorithms\" By cormen, Chapter 15: Dynamic Programming , I came across this statement\n\nWhen developing a dynamic-programming algorithm, we follow a sequence of\nfour steps:\n\nCharacterize the structure of an optimal solution.\n\nRecursively define the value of an optimal solution.\n\nCompute the value of an optimal solution, typically in a bottom-up fashion.\n\nConstruct an optimal solution from computed information.\n\n\nSteps 1–3 form the basis of a dynamic-programming solution to a problem. If we\nneed only the value of an optimal solution, and not the solution itself, then we\ncan omit step 4. When we do perform step 4, we sometimes maintain additional\ninformation during step 3 so that we can easily construct an optimal solution.\n\nI did not understand the difference in step 3 and 4.\ncomputing the value of optimal solution\nand\nconstructing the optimal solution.\nI was expecting to understand this by reading even further, but failed to understand.\nCan some one help me understanding this by giving an example ?\n    ", "Answer": "\r\nSuppose we are using dynamic programming to work out whether there is a subset of [1,3,4,6,10] that sums to 9.\n\nThe answer to step 3 is the value, in this case \"TRUE\".\n\nThe answer to step 4 is working out the actual subset that sums to 9, in this case \"3+6\".\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming graph algorithm\r\n                \r\nI am currently learning dynamic programming and i can't figure this problem out. Could someone give me an algorithm for it? : Consider a directed graph G = (V,E) where each edge is labeled with a character from an alphabet Sigma, and we designate a special vertex s as the start vertex, and another f as the final vertex. We say that G accepts a string A = a1a2 . . . an if there is a path from s to f of n edges whose labels spell the sequence A. Design an O((|V | + |E|)n) dynamic programming algorithm to determine whether or not A is accepted by G.\n    ", "Answer": "\r\nLet\n\n```\nfirst (str) return the first letter of str\nLet len(str) return the length of str\nLet rem(str) return str with the first character stripped off.\n\nfunc (str, v1) =\n    true if\n    len(str)=0 and s == f\n        or\n    func(rem(str), v2) is true for any v2 such that there exists an edge connecting v1, v2 labeled first(str)\n```\n\n\nThe values of f (str, v) can be memoised to avoid unnecessary recursive calls.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Knapsack using dynamic programming\r\n                \r\nThere is a common algorithm for solving the knapsack problem using dynamic programming. But it's not work for W=750000000, because there is an error of bad alloc. Any ideas how to solve this problem for my value of W?\n\n```\nint n=this->items.size();\nstd::vector<std::vector<uint64_t>> dps(this->W + 1, std::vector<uint64_t>(n + 1, 0));\nfor (int j = 1; j <= n; j++)\n    for (int k = 1; k <= this->W; k++) {\n        if (this->items[j - 1]->wts <= k)\n            dps[k][j] = std::max(dps[k][j - 1], dps[k - this->items[j - 1]->wts][j - 1] + this->items[j - 1]->cost);\n        else\n            dps[k][j] = dps[k][j - 1];\n    }\n```\n\n    ", "Answer": "\r\nFirst of all, you can use only one dimension to solve the knapsack problem. This will reduce your memory from dp[W][n] (n*W space) to dp[W] (W space). You can look here: 0/1 Knapsack Dynamic Programming Optimazion, from 2D matrix to 1D matrix\n\nBut, even if you use only dp[W], your W is really high, and might be too much memory. If your items are big, you can use some approach to reduce the number of possible weights. First, realize that you don't need all positions of W, only those such that the sum of weight[i] exists.\n\nFor example:\n\n```\nW = 500\nweights = [100, 200, 400]\n```\n\n\nYou will never use position dp[473] of your matrix, because the items can occupy only positions ```\np = [0, 100, 200, 300, 400, 500]```\n. It is easy to see that this problem is the same as when:\n\n```\nW = 5\nweights = [1,2,4]\n```\n\n\nAnother more complicated example:\n\n```\nW = 20\nweights = [5, 7, 8]\n```\n\n\nUsing the same approach as before, you don't need all weights from 0 to 20, because the items can occupy only fill up to positions \n\n```\np = [0, 5, 7, 5 + 7, 5 + 8, 7 + 8, 5 + 7 + 8]\np = [0, 5, 7, 12, 13, 15, 20]\n```\n\n\n, and you can reduce your matrix from dp[20] to dp[size of p] = M[7].\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Application of dynamic programming\r\n                \r\nI'm prepping for software developer interviews and trying to understand how to apply dynamic programming. I know that a problem must meet two criteria--have an optimal substructure and overlapping subproblems. Given an example where you have a function, f(L) that takes a list of integers L and maps it to another integer (eg, f([17, 5, 2, 12] = 35) how would you apply dynamic programming to find the maximum value?\n\nExample\n\n```\nL = [17, 5, 2, 12, 9]\n```\n\n\nYou can have a variety of combinations of f():\n\n```\nf([17]) + f([5]) + f([2, 12, 19])\nf([17]) + f([5, 2]) + f([12, 19])\n```\n\n\nI approached it by calculating f() for each element of the list, such as f([17]). Then each two elements, such as f([17, 5]), then each three elements, f([5, 2, 12]), and so on. I then mapped these values to a hash table. Next, I tried all the combinations of f() to find the maximum value. I think this approach is not elegant and kind of awkward. Any ideas for how to approach?\n    ", "Answer": "\r\nA typical way to go about dynamic programming is to create a function that recursively goes through all valid permutations of the subproblems in order to give the final answer, and saving all the answers to the subproblems as you go along (which is called memoization), as those subanswers will probably be very reusable. In pseudo code for the example problem:\n\n```\nfunction F(some_list) {\n    ....\n}\n\nM = [[]]\nL = [17, 5, 2, 12, 9]\n\nfunction maximize(start, end) {\n    // If we have already calculated the highest value\n    // for the given slice, why do it again?\n    if (M[start][end] != NULL) {\n        return M[start][end]\n    }\n\n    // The function f applied to the whole slice we are\n    // examining is also a viable solution, so we start\n    // our hunt there\n    max = F(L.slice(start, end))\n\n    // If we are at an end node (that is, we can't\n    // divide the problem into smaller pieces) we return\n    // and save the value we just calculated\n    if (end - start == 1) {\n        M[start][end] = max\n        return max\n    }\n\n    // Let's look at all possible ways we can split the\n    // slice we are currently examining\n    for (split in range(start + 1, end - 1)) {\n        // Let's examine booth parts of the slice and see if\n        // the sum of those solutions are better than our\n        // previous best solution\n        temp_max = maximize(start, split) + maximize(split, end)\n\n        if (temp_max > max) {\n            max = temp_max\n        }\n    }\n\n    // We have examined all possible ways in which we can\n    // slice and dice our slice, and found the best\n    // solution. Yay! Let's save it for future reference.\n    M[start][end] = max\n    return max\n}\n\n// Examine the whole list\nthe_great_maximum_value = maximize(0, L.length)\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "why LCIS should be solved with dynamic programming design\r\n                \r\nI am reading the book \"Introduction to Algorithm\" and especially in the dynamic programming chapter i've learned these notes :\n```\n    The second ingredient that an optimization problem must have for \n    dynamic programming to apply is that the space of subproblems must \n    be “small” in the sense that a recursive algorithm for the problem\n    solves the same subproblems over and over, rather than always generating \n    new subproblems\n```\n\nwhen i apply the dynamic programming design on the problem LCIS \"Longest Increasing Common Subsequence \" , I didn't figure out where is the overlapping of subproblems , (i understand that a brute force algorithm costs O(N * 2^m))\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Implementing Text Justification with Dynamic Programming\r\n                \r\nI'm trying to understand the concept of Dynamic Programming, via the course on MIT OCW here. The explanation on OCW video is great and all, but I feel like I don't really understand it until I implemented the explanation into code. While implementiing, I refer to some notes from the lecture note here, particularly page 3 of the note.\n\nThe problem is, I have no idea how to translate some of the mathematical notation to code. Here's some part of the solution I've implemented (and think it's implemented right):\n\n```\nimport math\n\nparagraph = \"Some long lorem ipsum text.\"\nwords = paragraph.split(\" \")\n\n# Count total length for all strings in a list of strings.\n# This function will be used by the badness function below.\ndef total_length(str_arr):\n    total = 0\n\n    for string in str_arr:\n        total = total + len(string)\n\n    total = total + len(str_arr) # spaces\n    return total\n\n# Calculate the badness score for a word.\n# str_arr is assumed be send as word[i:j] as in the notes\n# we don't make i and j as argument since it will require\n# global vars then.\ndef badness(str_arr, page_width):\n    line_len = total_length(str_arr)\n    if line_len > page_width:\n        return float('nan') \n    else:\n        return math.pow(page_width - line_len, 3)\n```\n\n\nNow the part I don't understand is on point 3 to 5 in the lecture notes. I literally don't understand and don't know where to start implementing those. So far, I've tried iterating the list of words, and counting the badness of each allegedly end of line, like this:\n\n```\ndef justifier(str_arr, page_width):\n    paragraph = str_arr\n    par_len = len(paragraph)\n    result = [] # stores each line as list of strings\n    for i in range(0, par_len):\n        if i == (par_len - 1):\n            result.append(paragraph)\n        else:\n            dag = [badness(paragraph[i:j], page_width) + justifier(paragraph[j:], page_width) for j in range(i + 1, par_len + 1)] \n            # Should I do a min(dag), get the index, and declares it as end of line?\n```\n\n\nBut then, I don't know how I can continue the function, and to be honest, I don't understand this line:\n\n```\ndag = [badness(paragraph[i:j], page_width) + justifier(paragraph[j:], page_width) for j in range(i + 1, par_len + 1)] \n```\n\n\nand how I'll return ```\njustifier```\n as an ```\nint```\n (since I already decided to store return value in ```\nresult```\n, which is a list. Should I make another function and recurse from there? Should there be any recursion at all?\n\nCould you please show me what to do next, and explain how this is dynamic programming? I really can't see where the recursion is, and what the subproblem is.\n\nThanks before.\n    ", "Answer": "\r\nIn case you have trouble understanding the core idea of dynamic programming itself here is my take on it:\nDynamic programming is essentially sacrificing space complexity for time complexity (but the extra space you use is usually very little compared to the time you save, making dynamic programming totally worth it if implemented correctly). You store the values from each recursive call as you go (e.g. in an array or a dictionary) so you can avoid computing for the second time when you run into the same recursive call in another branch of the recursion tree.\nAnd no you do not have to use recursion. Here is my implementation of the question you were working on using just loops. I followed the TextAlignment.pdf linked by AlexSilva very closely. Hopefully you find this helpful.\n```\ndef length(wordLengths, i, j):\n    return sum(wordLengths[i- 1:j]) + j - i + 1\n\n\ndef breakLine(text, L):\n    # wl = lengths of words\n    wl = [len(word) for word in text.split()]\n\n    # n = number of words in the text\n    n = len(wl)    \n\n    # total badness of a text l1 ... li\n    m = dict()\n    # initialization\n    m[0] = 0    \n\n    # auxiliary array\n    s = dict()\n\n    # the actual algorithm\n    for i in range(1, n + 1):\n        sums = dict()\n        k = i\n        while (length(wl, k, i) <= L and k > 0):\n            sums[(L - length(wl, k, i))**3 + m[k - 1]] = k\n            k -= 1\n        m[i] = min(sums)\n        s[i] = sums[min(sums)]\n\n    # actually do the splitting by working backwords\n    line = 1\n    while n > 1:\n        print(\"line \" + str(line) + \": \" + str(s[n]) + \"->\" + str(n))\n        n = s[n] - 1\n        line += 1\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming Algorithm?\r\n                \r\nI am confused about how best to design this algorithm. A ship has x pirates, where the age of the jth pirate is aj and the weight of the jth pirate is wj. I am thinking of a dynamic programming algorithm, which will find the oldest pirate whose weight is in between twenty-fifth and seventy-fifth percentile of all pirates. But I am clueless as to how to proceed.\n    ", "Answer": "\r\nNaive solution (probably not the most efficient but the first one that pops into my head, and is nice and simple):\n\nSort the list of pirates by weight.  Then loop over the middle 50% of the list searching for the pirate with the maximum age.\n\nAssuming you use an efficient sorting algorithm the runtime would be nlog(n) + n/2 -> O(nlog(n)).\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Memoization or Tabulation approach for Dynamic programming\r\n                \r\nThere are many problems that can be solved using Dynamic programming e.g. Longest increasing subsequence. This problem can be solved by using 2 approaches\n\n\nMemoization (Top Down) - Using recursion to solve the sub-problem and storing the result in some hash table.\nTabulation (Bottom Up) - Using Iterative approach to solve the problem by solving the smaller sub-problems first and then using it during the execution of bigger problem.\n\n\nMy question is which is better approach in terms of time and space complexity? \n    ", "Answer": "\r\nShort answer: it depends on the problem!\n\nMemoization usually requires more code and is less straightforward, but has computational advantages in some problems, mainly those which you do not need to compute all the values for the whole matrix to reach the answer.\n\nTabulation is more straightforward, but may compute unnecessary values. If you do need to compute all the values, this method is usually faster, though, because of the smaller overhead.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Relationship between Automata theory and Dynamic programming\r\n                \r\nI am learning automata theory. I think that there must be some relationship between state machine theory and dynamic programming. for the reason that the essence of dynamic programming is state transition equations. And automata theory is also deal with the problems about the transition between different states. Furthermore, since we can analysis string matching algorithms through the method using the state machine, I vaguely think that state machine can also help us understand DP more clearly.\nHowever, I find there are few materials talking about this. I think that if we can apply automata theory to the process of learning dynamic programming techniques, it can help us understand so many DP problems which are usually too difficult and complex for us to understand.\nCan anyone recommend some materials which are talking about the applications of automata theory in dynamic programming algorithms' designing or the analysis of DP problems using state machine theory?\nps. the terminology 'dynamic programming' here just refers to our normal understanding of that algorithm designing tricks, not that mathematics field which is created by Bellman.\n    ", "Answer": "\r\nA classic example of Dynamic Programming in automata is the Viterbi Algorithm, which finds the most likely sequence of hidden states in a Hidden Markov Model (a type of DFA) given an input sequence.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Can I say that this is dynamic programming?\r\n                \r\nI'm new to Dynamic Programming and from my understanding Dynamic Programming is where you use the results that you calculated to check if your function is correct. I was asked during an interview to implement a method to check if ```\nn```\n is power of two. So, I came up with this.\n\n```\ndef isPowerOfTwo(self, n):\n    power_of_two = [1]\n    is_power_of_two = False\n    if n == 0:\n        return False\n\n    if n == 1:\n        return True\n\n    while True:\n        power_of_two.append(power_of_two[-1] * 2)\n        if n == power_of_two[-1]:\n            is_power_of_two = True\n            break\n\n        if power_of_two[-1] > n:\n            break\n\n    return is_power_of_two\n```\n\n    ", "Answer": "\r\nWikipedia dynamic programming:\n\n\n  In mathematics, computer science, economics, and bioinformatics, dynamic programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems.\n\n\nHowever, this mainly seems oriented towards optimization problems, and determining whether N is a power of 2 is not typically framed as an optimization problem.  \n\nFrom section \"dynamic programming in computer programming\":\n\n\n  There are two key attributes that a problem must have in order for dynamic programming to be applicable: optimal substructure and overlapping subproblems (emphasis mine). If a problem can be solved by combining optimal solutions to non-overlapping subproblems, the strategy is called \"divide and conquer\" instead. This is why mergesort and quicksort are not classified as dynamic programming problems.\n  \n  Optimal substructure means that the solution to a given optimization problem can be obtained by the combination of optimal solutions to its subproblems. Consequently, the first step towards devising a dynamic programming solution is to check whether the problem exhibits such optimal substructure. Such optimal substructures are usually described by means of recursion. For example, given a graph G=(V,E), the shortest path p from a vertex u to a vertex v exhibits optimal substructure: take any intermediate vertex w on this shortest path p. If p is truly the shortest path, then it can be split into subpaths p1 from u to w and p2 from w to v such that these, in turn, are indeed the shortest paths between the corresponding vertices... \n  \n  Overlapping subproblems means that the space of subproblems must be small, that is, any recursive algorithm solving the problem should solve the same subproblems over and over, rather than generating new subproblems. For example, consider the recursive formulation for generating the Fibonacci series: Fi = Fi−1 + Fi−2, with base case F1 = F2 = 1. Then F43 = F42 + F41, and F42 = F41 + F40. Now F41 is being solved in the recursive subtrees of both F43 as well as F42. Even though the total number of subproblems is actually small (only 43 of them), we end up solving the same problems over and over if we adopt a naive recursive solution such as this. Dynamic programming takes account of this fact and solves each subproblem only once.\n\n\nAlthough \"is N / 2  a power of 2?\" is a related subproblem to is \"N a power of 2?\" and we can write a routine that solves those kind of subproblems only once, we don't have the kind of overlap present in the Fibonacci sequence.  If we did, recursion would not work very well.  Here, it does.  Adding memoization to the recursion is a kind of top-down DP technique, but is practically unnecessary here if O(log2 N) time is acceptable from recursion.  \n\nIt looks like instead of breaking the problem into smaller pieces you built a list of powers of 2, (though you don't cache the list, you build it each time, but cacheing or not cacheing doesn't mean it is or isn't dynamic programming) and tested to see if the input was in the list, and if not, if it could be found by extending the list.  While I think your test is OK, the connection to dynamic programming is more tenuous.  \n\nHere are some other ways to test this.  \n\nOne way to test if a number is a power of 2 is to represent it in base 2, and make sure only one bit is set to one and the rest are zero.  Many languages have a way to get an alternative base representation of an integer.  A power of 2 has distinctive octal and hexadecimal string representations  as well.  \n\nAnother would be to return True for n==2, return False if non-integer or odd mod 2, otherwise test if n/2 is a power of 2 with recursion.  A lot of mathematical dynamic programming is recursive.  \n\n```\ndef isPowerOf2(n):\n        if n%2==1:\n            return False\n        if n==2:\n            return True\n        else:\n            return isPowerOf2(n/2)\n```\n\n\nWe could type-check it and memoize it like this:\n\n```\npowers_of_2 = [2]\ndef isPowerOf2(n):\n    if type(n)!=type(1):\n        raise TypeError(\"isPowerOf2(): integer value required\")\n    if n%2==1:\n        return False\n    if n in powers_of_2:\n        return True\n    if n<powers_of_2[-1]:\n        return False\n    else:\n        result =  isPowerOf2(n/2)\n        if result:\n            powers_of_2.append(n)\n        return result\n```\n\n\nand test this with an example as follows:\n\n```\n>>> import power2 # name of our python code script file\n>>> power2.isPowerOf2(256)\nTrue\n>>> power2.powers_of_2\n[2, 4, 8, 16, 32, 64, 128, 256]\n```\n\n\nFor something shorter, along the lines of @Tris Nefzger's siuggestion, see: n & (n-1) what does this expression do? ; one could also examine log(N)/log(2) to see if it is close to an integer value, calculate 2 to that power, and test for equality.  Neither of these last two methods are dynamic programming, but are possibly more apropos for such a simple task in practice.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "tsp using dynamic programming\r\n                \r\ni was using a piece of code for implementing TSP using dynamic programming. i have found this code but cant figure out the compute() function and how it works. i dont know what are the variables for and also how it computes the path. any help is highly  appreciated.\n\n```\n#include <stdio.h>\n#include<limits.h>\n#define size 10 //maximum 10 cities\n#define min(a,b) a>b?b:a\n#define sizePOW 1024\nint n,npow,g[size][sizePOW],p[size][sizePOW],adj[size][size];\nint compute(int start,int set)\n{   \nint masked,mask,result=INT_MAX,temp,i,t1;//result stores the minimum \nif(g[start][set]!=-1)//memoization DP top-down,check for repeated subproblem\n    return g[start][set];\nfor(i=0;i<n;i++)\n    {   //npow-1 because we always exclude \"home\" vertex from our set\n\n        t1=1<<i;\n        mask=(npow-1)-(1<<i);//remove ith vertex from this set\n        masked=set&mask;\n        if(masked!=set)//in case same set is generated(because ith vertex was not present in the    set hence we get the same set on removal) eg 12&13=12\n        {   \n            temp=adj[start][i]+compute(i,masked);//compute the removed set\n            if(temp<result)\n                result=temp,p[start][set]=i;//removing ith vertex gave us minimum\n        }\n    }\n    return g[start][set]=result;//return minimum\n}\n\nvoid TSP()\n{     \nint i,j;\n//g(i,S) is length of shortest path starting at i visiting all vertices in S and ending at 1\nfor(i=0;i<n;i++)\n    for(j=0;j<npow;j++) \n            g[i][j]=p[i][j]=-1; \nfor(i=0;i<n;i++){\n    g[i][0]=adj[i][0];//g(i,nullset)= direct edge between (i,1)\n}\n\nint result=compute(0,npow-2);//npow-2 to exclude our \"home\" vertex\nprintf(\"Tour cost:%d\\n\",result);\nprintf(\"Tour path:\\n0 \");\ngetpath(0,npow-2);\nprintf(\"0\\n\");\n}\nint main(void) {\nint i,j;\nprintf(\"Enter number of cities\\n\");\nscanf(\"%d\",&n);\nnpow=(int)pow(2,n);//bit number required to represent all possible sets\nprintf(\"npow = %d   \",npow);\nprintf(\"\\nEnter the adjacency matrix\\n\");\n\nfor(i=0;i<n;i++)for(j=0;j<n;j++){\nscanf(\"%d\",&adj[i][j]);}\nTSP();\n\nreturn 0;\n}\n```\n\n    ", "Answer": "\r\n```\n//g(i,S) is length of shortest path starting at i visiting all vertices in S and ending at 1\n```\n\n\nThis comment is very important.\n\nImage currently we are in \"start\", and the city we visited is \"set\"(represent in binary of set), how do we calculate the other status ?\n\nFor example we have an edge \"start\"->\"i\", then  \n\n```\nif(masked!=set)//in case same set is generated(because ith vertex was not present in the    set hence we get the same set on removal) eg 12&13=12\n    {   \n        temp=adj[start][i]+compute(i,masked);//compute the removed set\n        if(temp<result)\n            result=temp,p[start][set]=i;//removing ith vertex gave us minimum\n    }\n```\n\n\nThis is calculating the status g[start][masked], using g[start][set] and the edge (start,i)\n\nAs we can see, the author use recursion and dynamic programming to solve the problem.\nTime is O(2^n * n^2)\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "tsp using dynamic programming\r\n                \r\ni was using a piece of code for implementing TSP using dynamic programming. i have found this code but cant figure out the compute() function and how it works. i dont know what are the variables for and also how it computes the path. any help is highly  appreciated.\n\n```\n#include <stdio.h>\n#include<limits.h>\n#define size 10 //maximum 10 cities\n#define min(a,b) a>b?b:a\n#define sizePOW 1024\nint n,npow,g[size][sizePOW],p[size][sizePOW],adj[size][size];\nint compute(int start,int set)\n{   \nint masked,mask,result=INT_MAX,temp,i,t1;//result stores the minimum \nif(g[start][set]!=-1)//memoization DP top-down,check for repeated subproblem\n    return g[start][set];\nfor(i=0;i<n;i++)\n    {   //npow-1 because we always exclude \"home\" vertex from our set\n\n        t1=1<<i;\n        mask=(npow-1)-(1<<i);//remove ith vertex from this set\n        masked=set&mask;\n        if(masked!=set)//in case same set is generated(because ith vertex was not present in the    set hence we get the same set on removal) eg 12&13=12\n        {   \n            temp=adj[start][i]+compute(i,masked);//compute the removed set\n            if(temp<result)\n                result=temp,p[start][set]=i;//removing ith vertex gave us minimum\n        }\n    }\n    return g[start][set]=result;//return minimum\n}\n\nvoid TSP()\n{     \nint i,j;\n//g(i,S) is length of shortest path starting at i visiting all vertices in S and ending at 1\nfor(i=0;i<n;i++)\n    for(j=0;j<npow;j++) \n            g[i][j]=p[i][j]=-1; \nfor(i=0;i<n;i++){\n    g[i][0]=adj[i][0];//g(i,nullset)= direct edge between (i,1)\n}\n\nint result=compute(0,npow-2);//npow-2 to exclude our \"home\" vertex\nprintf(\"Tour cost:%d\\n\",result);\nprintf(\"Tour path:\\n0 \");\ngetpath(0,npow-2);\nprintf(\"0\\n\");\n}\nint main(void) {\nint i,j;\nprintf(\"Enter number of cities\\n\");\nscanf(\"%d\",&n);\nnpow=(int)pow(2,n);//bit number required to represent all possible sets\nprintf(\"npow = %d   \",npow);\nprintf(\"\\nEnter the adjacency matrix\\n\");\n\nfor(i=0;i<n;i++)for(j=0;j<n;j++){\nscanf(\"%d\",&adj[i][j]);}\nTSP();\n\nreturn 0;\n}\n```\n\n    ", "Answer": "\r\n```\n//g(i,S) is length of shortest path starting at i visiting all vertices in S and ending at 1\n```\n\n\nThis comment is very important.\n\nImage currently we are in \"start\", and the city we visited is \"set\"(represent in binary of set), how do we calculate the other status ?\n\nFor example we have an edge \"start\"->\"i\", then  \n\n```\nif(masked!=set)//in case same set is generated(because ith vertex was not present in the    set hence we get the same set on removal) eg 12&13=12\n    {   \n        temp=adj[start][i]+compute(i,masked);//compute the removed set\n        if(temp<result)\n            result=temp,p[start][set]=i;//removing ith vertex gave us minimum\n    }\n```\n\n\nThis is calculating the status g[start][masked], using g[start][set] and the edge (start,i)\n\nAs we can see, the author use recursion and dynamic programming to solve the problem.\nTime is O(2^n * n^2)\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Pow function calculation by dynamic programming\r\n                \r\nI know that ```\npow(base, power)```\n is a built-in function in C with complexity O(power). Can I reduce the complexity of it by dynamic programming?\n    ", "Answer": "\r\nYou can calculate it in O(logn)\n\n```\nint power(int x, unsigned int y)\n{\n    int temp;\n    if( y == 0)\n        return 1;\n    temp = power(x, y/2);\n    if (y%2 == 0)\n        return temp*temp;\n    else\n        return x*temp*temp;\n}\n```\n\n\nDetails in Here\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Sequence Alignment with Dynamic Programming\r\n                \r\nI am really new in algorithm programming. I know when it comes to the sequence alignment with dynamic programming, it should follow the below algorithm:\n\n```\nAlg: Compute C[i, j]: min-cost to align (the first i symbols of X) and (the j symbols of Y)(C1:cost for mismatch,C2:cost for gap alignment)\nand def d[i, j] = { C1 if X[i] ≠ Y[j],0 otherwise}\nCompute C[i, j]:\n  case 1: align X[i] with Y[j]\n    C[i, j] = C[i-1, j-1] + d[i, j]\n  case 2: either X[i] or Y[j] is aligned to a gap\n    C[i, j] = min{ (C[i-1, j] + C2), (C[i, j-1] + C2) }\n    (C[i, j] = C[i-1, j] + C2 is case 2-1)\n    (C[i, j] = C[i-1, j] + C2 is case 2-2)\nAlg: C[i, 0] = iC2, ∀i\nC[0, j] = jC2, ∀j\nfor i = 1 to m\n  for j = 1 to n\n    C[i, j] = min{ (case 1), (case 2-1), (case 2-2) }\nreturn C[m, n]\n```\n\n\nHowever, for the last part:\n\n```\nfor i = 1 to m\n  for j = 1 to n\n    C[i, j] = min{ (case 1), (case 2-1), (case 2-2) }\nreturn C[m, n]\n```\n\n\nI am a little bit confused since from the previous part it just a one dimensional problem. Why should it iterate j in multiple i again and again?Thanks!\n    ", "Answer": "\r\nIn this case the ```\nC[i,j]```\n is the ```\nmemo```\n which stores the computed values for each combination of inputs ```\ni```\n and ```\nj```\n. The nested loop you've mentioned is just a walking through each cell in the 2-D matrix. The same cell is actually never calculated twice.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming or backtracking?\r\n                \r\nMy friend gave me the following problem:\n\n```\nInput: A matrix of letters and a word.\nOutput: The frequency of the word in the matrix assuming\n  you can move left, right, up and down in the matrix to form the word.\n```\n\n\nFor example:\n\n```\nInput:\nS E X Y\nA S E A\nA A X A\nA A Y A\nAnd word is SEXY.\n\nOutput:\n4 (four times in matrix of letters)\n```\n\n\nThis is my code for solve problem:\n\n```\npackage backtracking;\n\npublic class CountFrequency {\n    private char[][] matrixOfLetter;\n    private String word;\n    private int n, m;\n    private int lengthOfWord;\n    private int[][] matrixCountFrequency;\n\n    public CountFrequency(int n, int m, String word) {\n        matrixOfLetter = new char[n][m];\n        this.word = word;\n        this.n = n;\n        this.m = m;\n        this.lengthOfWord = word.length();\n\n        matrixCountFrequency = new int[n][m];\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                matrixCountFrequency[i][j] = 0;\n    }\n\n    public static void main(String[] args) {\n        CountFrequency countFrequency = new CountFrequency(4, 4, \"SEXY\");\n\n        countFrequency.addMatrixOfLetter(0, 0, 'S');\n        countFrequency.addMatrixOfLetter(0, 1, 'E');\n        countFrequency.addMatrixOfLetter(0, 2, 'X');\n        countFrequency.addMatrixOfLetter(0, 3, 'Y');\n        countFrequency.addMatrixOfLetter(1, 0, 'A');\n        countFrequency.addMatrixOfLetter(1, 1, 'S');\n        countFrequency.addMatrixOfLetter(1, 2, 'E');\n        countFrequency.addMatrixOfLetter(1, 3, 'A');\n        countFrequency.addMatrixOfLetter(2, 0, 'A');\n        countFrequency.addMatrixOfLetter(2, 1, 'A');\n        countFrequency.addMatrixOfLetter(2, 2, 'X');\n        countFrequency.addMatrixOfLetter(2, 3, 'A');\n        countFrequency.addMatrixOfLetter(3, 0, 'A');\n        countFrequency.addMatrixOfLetter(3, 1, 'A');\n        countFrequency.addMatrixOfLetter(3, 2, 'Y');\n        countFrequency.addMatrixOfLetter(3, 3, 'A');\n\n        countFrequency.process();\n        countFrequency.printResult();\n    }\n\n    public void addMatrixOfLetter(int i, int j, char c) {\n        matrixOfLetter[i][j] = c;\n    }\n\n    public void process() {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j) {\n                if (word.indexOf(matrixOfLetter[i][j]) == -1) {\n                    matrixCountFrequency[i][j] = -1;\n                    continue;\n                }\n                if (matrixOfLetter[i][j] == word.charAt(lengthOfWord - 1))\n                    processWithLastChar(lengthOfWord - 1, i, j);\n            }\n    }\n\n    public void processWithLastChar(int indexOfWord, int row, int col) {\n        matrixCountFrequency[row][col] += 1;\n        if (indexOfWord == 0)\n            return;\n        else {\n            if (row - 1 >= 0) {\n                if (matrixOfLetter[row - 1][col] == word\n                        .charAt(indexOfWord - 1))\n                    processWithLastChar(indexOfWord - 1, row - 1, col);\n            }\n\n            if (row + 1 < lengthOfWord) {\n                if (matrixOfLetter[row + 1][col] == word\n                        .charAt(indexOfWord - 1))\n                    processWithLastChar(indexOfWord - 1, row + 1, col);\n            }\n\n            if (col - 1 >= 0) {\n                if (matrixOfLetter[row][col - 1] == word\n                        .charAt(indexOfWord - 1))\n                    processWithLastChar(indexOfWord - 1, row, col - 1);\n            }\n\n            if (col + 1 < lengthOfWord) {\n                if (matrixOfLetter[row][col + 1] == word\n                        .charAt(indexOfWord - 1))\n                    processWithLastChar(indexOfWord - 1, row, col + 1);\n            }\n        }\n    }\n\n    public void printResult() {\n        int count = 0;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j) {\n                if (word.charAt(0) == matrixOfLetter[i][j])\n                    count += matrixCountFrequency[i][j];\n            }\n\n        System.out.println(\"Frequency is : \" + count);\n    }\n}\n```\n\n\nI used a backtracking algorithm but I only backtrack when I see last letter of word, and backtrack again when see the letter which is right-most of it in word. \n\nI use a matrix of counter for count frequency of letter.\n\nCan that problem be solved by dynamic programming algorithm?\n\nOr any better idea?\n    ", "Answer": "\r\nIt can be solved with dynamic programming, I think this is the easiest to understand solution. \n\nCreate a parallel 3 dimensional matrix to yours. If the letter matrix was with dimensions ```\nn```\nx```\nm```\n and the word you search for is ```\nL```\n letters long you create matrix ```\ndp[n][m][L]```\n. In ```\ndp[i][j][k]```\n you store how many ways you have found to use the letter ```\ninitial[i][j]```\n as ```\nk```\nth letter of your word.\n\nYou have ```\ndp[i][j][k] = sum(dp[i+delta1][j + delta2][k + 1])```\n, where ```\n{delta1, delta2} in {{0, 1},{0, -1}, {1, 0}, {-1, 0}}```\n. The bottom of the recursion is ```\ndelta[i][j][L - 1] = (initial[i][j] == word[L - 1])```\n.\n\nThe end result is given if you sum up ```\ndp[i][j][l - 1]```\n for all possible i and j.\n\nHopefully this helps you.\n\nEDIT\n\nI have to confess I did a stupid proposal in my initial solution. The dynamic solution I propose is not taking into account which letters I have used. Thus for the matrix\n\n```\nXXXX\nXABX\nXXXX\n```\n\n\nAnd the string ABAB my algorithm will return a count of one - starting from the A going to B and then back to A and back to B. This is probably wrong for what you need.\n\nRegretfully keeping track of what you have already visited is not simple in the dynamic approach and now I start to think backtrack is more suitable for your problem.\n\nBy the way you do not take that into account in your solution also, but it is a lot easier to keep track of what you visited during the backtrack. I also think backtrack will bemore efficient memory-wise and performance-wise.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Maximum Area Histogram Dynamic programming C++\r\n                \r\nI was trying to get the maximum area in a histogram.\n\nI already did that using brute force algorithm and it worked very well, But i wanna do it using Dynamic Programming.\n\nI DONT need any codes , i just want to know the idea of writing it but using dynamic programming\n\nHere is my bruteforce code.\nNote that : Number of buildings are the number of Columns in the histogram \n\n```\nint getMaxArea(build building[], int NumOfBuildings) {\n\n    int BuildingHeight = 0; //Height of Smallest Building of current Iteration.\n    int Total_BuildingLength = 0; // Total length of current buildings iteration\n    int max_area = 0; // Maximum Area Calculated\n    int CurrentArea; //Store Current Area\n\n    int i = 0;\n    while (i < NumOfBuildings)\n    {\n        int j = i;\n        BuildingHeight = building[j].height;\n\n        while (j < NumOfBuildings) //(J)Iterate to the the last building starting from each (i) building. \n        {\n            if (BuildingHeight >= building[j].height){\n                BuildingHeight = building[j].height; // At Every Iteration assign new Smallest height for area calculation\n\n            }\n            // Each Step calculates Area.\n            Total_BuildingLength += building[j].length;\n            CurrentArea = BuildingHeight * Total_BuildingLength;\n\n            if (max_area < CurrentArea){\n                max_area = CurrentArea;\n            }\n\n            j++;\n        }\n        //Reset Length\n        Total_BuildingLength = 0;\n        i++;\n    }\n    return max_area; \n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "LCS using Dynamic programming\r\n                \r\nI am learning how to solve the longest common subsequence using dynamic programming. I understand how the table works, however, I don't get the reason why the formula for x[i]!=y[j] is like this max{c[i − 1, j], c[i, j − 1]}. Why not other formulas?\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Is this dynamic programming or divide and conquer?\r\n                \r\nI'm in the middle of studying algorithms. There is an article I read indirectly discussing the knapsack problem. In the end it is said to be solved with dynamic programming but to me it looks like just divide and conquer with minor optimizations. Can someone have a look? \nI have pasted the code into a bin http://jsbin.com/sulipipole/edit?js,console.\n\n```\nconst ACTIVITIES = [\n  {name: 'side-project', time: 10, xp: 12},\n  {name: 'algorithms', time: 3, xp: 7},\n  {name: 'networking', time: 1, xp: 0.5},\n  {name: 'exercise', time: 2, xp: 1.5},\n  {name: 'systems design', time: 4, xp: 4},\n  {name: 'making CSS codepens', time: 3, xp: 4}\n];\n\n\nconst findJob = function(time, activities) {\n\n    const optimalSolution = function(items, n = items.length, timeLeft = time) {\n\n    if (n === 0 || timeLeft === 0) {\n      return [];\n    }\n\n    if (items[n - 1].time > timeLeft) {\n      return optimalSolution(items, n - 1, timeLeft);\n    }\n\n     const lastItem = items[n - 1];\n\n    const withLastItem = [\n      lastItem,\n      ...optimalSolution(items, n - 1, timeLeft - lastItem.time)\n    ];\n    const withoutLastItem = optimalSolution(items, n - 1, timeLeft);\n\n    if (totalXp(withLastItem) > totalXp(withoutLastItem)) {\n      return withLastItem;\n    } else {\n      return withoutLastItem;\n    }\n    };\n\n    const totalXp = arr => arr.reduce((total, ea) => total + ea.xp, 0);\n\n    const sortedByTime = activities\n      .slice()\n      .sort((a, b) => a.time - b.time);\n\n    return optimalSolution(sortedByTime)\n      .map(act => act.name);\n    };\n```\n\n\nDynamic programming requires some memoization or tabling scheme correct?\n    ", "Answer": "\r\nI really like the way Skiena described dynamic programming in his book \"the algorithm design manual\". \"Dynamic programming is a technique for efficiently implementing a recursive algorithm by storing partial results\". \n\nYou have a recursive algorithm here but no storing of partial results. So it is not dynamic programming. But it can probably be turned into a dynamic programming algorithm by storing and reusing the partial results.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Calculating Binomial coefficients using dynamic programming\r\n                \r\nI wrote this code to find Binomial coefficients nCk:\n\n```\n# include <bits/stdc++.h>\nusing namespace std;\nint c[20][20];\nvoid initialize()\n{\n    for(int i=0;i<20;i++) \n        for(int j=i;j<20;j++)\n            c[i][j]=-1;\n}\nint binomCoeff(int n,int k)\n{\n    if(k==0||k==n) return 1;\n    if(c[n][k]!=-1)\n        return c[n][k];\n    return c[n][k] =  binomCoeff(n-1,k-1) + binomCoeff(n-1,k);\n}\n\nint main()\n{\n    initialize();\n    cout<<binomCoeff(4,2)<<endl;\n}\n```\n\n\nI'm new to dynamic programming, so I can't find the error.\n    ", "Answer": "\r\nYou are using the second index for k (less or equal to n) but initialize only bigger indexes\n\n```\nfor(int j=  0  ;j<20;j++)\nor\nfor(int j=  0  ;   j <= i  ;j++)\n```\n\n\nNote that this mistake would be discovered during step-by-step debugging. Why did you ignore such approach?\n\nP.S. Method used here is ```\nmemoization```\n - \"top-down\" kind of dynamic programming. You can also implement \"bottom-up\" dynamic programming as exercise - fill table in order and get the last cell result.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dot Game and Dynamic Programming\r\n                \r\nI'm trying to solve a variant of the dot game with dynamic programming. \n\nThe regular dot game is played with a line of dots. Each player takes either one or two dots at their respective end of the line and the person who is left with no dots to take wins. \n\nIn this version of the game, each dot has a different value. Each player takes alternate turns and takes either dot at either end of the line. I want to come up with a way to use dynamic programming to find the max amount that the first player is guaranteed to win. \n\nI'm having problems grasping my head around this and trying to write a recurrence for the solution. Any help is appreciated, thanks!\n    ", "Answer": "\r\nTake a look at this site: http://people.csail.mit.edu/bdean/6.046/dp/, especially problem number 10:\n\n\n  Optimal Strategy for a Game. Consider a row of n coins of values v(1) ... v(n), where n is even. We play a game against an opponent by alternating turns. In each turn, a player selects either the first or last coin from the row, removes it from the row permanently, and receives the value of the coin. Determine the maximum possible amount of money we can definitely win if we move first. \n\n\nIt's exactly what you want if I'm reading your post right. The solution is pretty simple and it's explained very well there in my opinion.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Why is insertion sort not dynamic programming\r\n                \r\nA dynamic programming problem has optimal substructure and has a solution that can be described by a recurrence relation.\n\nA sorted list is the addition of an element to an already sorted list, so Insertion sort thus has optimal substructure. The recurrence relation could be described as \n\n```\nSorted_List_n = Sorted_list_n-1 + next element\n```\n\n\nSo why isn't insertion sort considered a dynamic programming algorithm? I understand how it is applied in Fibonacci numbers and in edit distance, but not really beyond that.\n    ", "Answer": "\r\nA given problem can be solved using Dynamic Programming (DP) if the problem has following two properties.\n\n1) overlapping sub problems (osp)\n\n2) Optimal sub-structure (oss)\n\nEven though insertion sort algorithm has optimal sub-structure property, it does not have overlapping sub problems property. A bit elaborated explanation is as follows..\n\nIn, Fibonacci numbers calculation case, we are clearly having the above mentioned two properties. \n\nosp : fib(5) calculation has fib(3) as its subproblem. At the same time, fib(4) calculation has fib(3) as its subproblem. But fib(5) = fib(4) + fib(3). If we blindly calculate fib(5) with out DP technique, we end up calculating fib(3) twice (one for fib(4) and one for fib(3) itself). Here, one of the overlapping subproblems is fib(3)\n\noss : In the same way, if we can calculate the solution to fib(4) and fib(3) optimally, then the solution to fib(5) as well can be calculated optimally. Because fib(5) is simply a sum of fib(4) and fib(3).\n\nNow, let us try to check whether these two properties exist in insertion sort or not.\nLet us say you are sorting an array of numbers {5, 2, 3, 1}. \n\nosp : According to the recurrence that you are thinking the subproblems will be as follows..\n\n\n{5, 2, 3, 1}\n{5, 2, 3}\n{5, 2}\n{5}\n\n\nIf we observe closely, we can see that there are no two subproblems which are similar. That means the overlapping sub problems property does not exist.\n\noss : If we can sort an array of size (n-1) optimally, then we can as well sort an array of size (n) optimally. So optimal sub-structure property exist.\n\nIn summary, insertion sort algorithm does not have overlapping sub problems property. Hence it is not a DP solution.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "8-queen problem using Dynamic programming\r\n                \r\nI am quite confused with idea of implementing 8-queen problem using dynamic programming. It seems it is not possible at one end as for DP \" if the problem was broken up into a series of subproblems and the optimal solution for each subproblem was found, then the resulting solution would be realized through the solution to these subproblems. A problem that does not have this structure cannot be solved with dynamic programming\" (Reference). By taking this in account, the optimal solution for 7x7 board might not optimal as well  (even incorrect) for 8x8. So, the result of problem might not realize through optimal solution of sub-problem.\n\nAt the other hand, DP is optimization for backtracking problems... if so then 8-queen problem can be solved by backtracking... does it mean that by storing only dead-ends can convert backtracking solution into DP? If so, then might 2,1 is not feasible for parent 1,1 but might feasible for 1,2.\n\nUpdate\n\nanyone have idea that whether 8-queen or n-queen problem can be solved by using dynamic programming? If so then what will be your comments on observations given above?\n    ", "Answer": "\r\noptimal solution for 7x7 board might not optimal as well (even incorrect) for 8x8.\n\nYes, you are correct. But this is not a good way to split the problem. Look into paper yi_H posted in his answer, theorem 2.4, and look at the algorithm description. They divide the solutions into equivalence classes according to the sets of closed lines (i.e. lines which are threatened by queens). The theorem 2.4 guarantees that once they solve the sub-problem on the particular set of closed lines, they can solve the rest separately and then combine the result! Very clever.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming: recursion+memoization vs loop+list\r\n                \r\nThe documentation for ```\n@functools.lru_cache```\n provides an example of computing Fibonacci numbers using a cache to implement a dynamic programming technique:\n\n```\n@lru_cache(maxsize=None)\ndef fib(n):\n    if n < 2:\n        return n\n    return fib(n-1) + fib(n-2)\n```\n\n\nI've seen this approach used for solving various programming puzzles. Does it have the same time/space complexity as the 'standard' iterative dynamic programming approach, e.g.:\n\n```\ndef fib(n):\n    if n < 2:\n        return n\n    dp = [0]*(n+1)\n    dp[1] = 1\n    for i in range(2 , n+1):\n        dp[i] = dp[i-1] + dp[i-2]\n    return dp[n]\n```\n\n\nAlso, are there any downsides to using the recursive approach?\n    ", "Answer": "\r\nIt should have the same complexity as memoization (top-down) kind of dynamic programming.\n\nIterative method with step-by-step table filling (bottom-up dynamic programming) might have slightly different complexity, because memoization remembers only parameter sets, needed to build final solution \n\nThis difference is not important for fibbonacci or factorial examples, but might happen for tasks with sparse subproblem table (when it's hard to predict what entries will be used later)\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Which letter of the English alphabet takes up most pixels? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 2 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI am trying to do some dynamic programming based on the number of characters in a sentence. Which letter of the English alphabet takes up the most pixels on the screen?\n    ", "Answer": "\r\nHmm, let's see:\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \n\nbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb \n\ncccccccccccccccccccccccccccccccccccccccc \n\ndddddddddddddddddddddddddddddddddddddddd \n\neeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee \n\nffffffffffffffffffffffffffffffffffffffff \n\ngggggggggggggggggggggggggggggggggggggggg \n\nhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh \n\niiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii \n\njjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj \n\nkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk \n\nllllllllllllllllllllllllllllllllllllllll \n\nmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm \n\nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn \n\noooooooooooooooooooooooooooooooooooooooo \n\npppppppppppppppppppppppppppppppppppppppp \n\nqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq \n\nrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr \n\nssssssssssssssssssssssssssssssssssssssss \n\ntttttttttttttttttttttttttttttttttttttttt \n\nuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu \n\nvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv \n\nwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww \n\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx \n\nyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy \n\nzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz \n\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \n\nBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB \n\nCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC \n\nDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD \n\nEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE \n\nFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF \n\nGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG \n\nHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH \n\nIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII \n\nJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJ \n\nKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK \n\nLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL \n\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM \n\nNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN \n\nOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO \n\nPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP \n\nQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ \n\nRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR \n\nSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS \n\nTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT \n\nUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU \n\nVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV \n\nWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW \n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \n\nYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY \n\nZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ \n\nW wins.\n\nOf course, this is a silly empirical experiment.  There is no single answer to which letter is widest.  It depends on the font.  So you'll have to do a similar empirical experiment to figure out the answer for your environment.  But the fact is, most fonts follow the same conventions, and capital W will be the widest.\n\nGist with these character widths in a ratio form (W = 100) captured here using this particular example font:\n\nhttps://gist.github.com/imaurer/d330e68e70180c985b380f25e195b90c\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Pyramids dynamic programming\r\n                \r\nI encountered this question in an interview and could not figure it out. I believe it has a dynamic programming solution but it eludes me.\n\nGiven a number of bricks, output the total number of 2d pyramids possible, where a pyramid is defined as any structure where a row of bricks has strictly less bricks than the row below it. You do not have to use all the bricks.\n\nA brick is simply a square, the number of bricks in a row is the only important bit of information.\n\nReally stuck with this one, I thought it would be easy to solve each problem 1...n iteratively and sum. But coming up with the number of pyramids possible with exactly i bricks is evading me.\n\nexample, n = 6\n\n```\nX\n\nXX\n\nX\nXX   XXX\n\nX\nXXX   XXXX\n\nXX      X\nXXX   XXXX   XXXXX\n\nX\nXX      XX       X\nXXX   XXXX   XXXXX   XXXXXX\n```\n\n\nSo the answer is 13 possible pyramids from 6  bricks.\n\nedit\n\nI am positive this is a dynamic programming problem, because it makes sense to (once you've determined the first row) simply look to the index in your memorized array of your remainder of bricks to see how many pyramids fit atop.\n\nIt also makes sense to consider bottom rows of width at least n/2 because we can't have more bricks atop than on the bottom row EXCEPT and this is where I lose it and my mind falls apart, in certain (few cases) you can I.e. N = 10\n\n```\nX\nXX\nXXX\nXXXX\n```\n\n\nNow the bottom row has 4 but there are 6 left to place on top\n\nBut with n = 11 we cannot have a bottom row with less than n/2 bricks. There is another wierd inconsistency like that with n = 4 where we cannot have a bottom row of n/2 = 2 bricks.\n    ", "Answer": "\r\nLet's choose a suitable definition:\n\n```\nf(n, m) = # pyramids out of n bricks with base of size < m\n```\n\n\nThe answer you are looking for now is (given that ```\nN```\n is your input number of bricks):\n\n```\nf(N, N+1) - 1\n```\n\n\nLet's break that down:\n\n\nThe first ```\nN```\n is obvious: that's your number of bricks.\nYour bottom row will contain at most ```\nN```\n bricks (because that's all you have), so ```\nN+1```\n is a sufficient lower bound.\nFinally, the ```\n- 1```\n is there because technically the empty pyramid is also a pyramid (and will thus be counted) but you exclude that from your solutions.\n\n\n\n\nThe base cases are simple:\n\n```\nf(n, 0) = 1   for any n >= 0\nf(0, m) = 1   for any m >= 0\n```\n\n\nIn both cases, it's the empty pyramid that we are counting here.\n\n\n\nNow, all we need still is a recursive formula for the general case.\n\nLet's assume we are given ```\nn```\n and ```\nm```\n and choose to have ```\ni```\n bricks on the bottom layer. What can we place on top of this layer? A smaller pyramid, for which we have ```\nn - i```\n bricks left and whose base has size ```\n< i```\n. This is exactly ```\nf(n - i, i)```\n.\n\nWhat is the range for ```\ni```\n? We can choose an empty row so ```\ni >= 0```\n. Obviously, ```\ni <= n```\n because we have only ```\nn```\n bricks. But also, ```\ni <= m - 1```\n, by definition of ```\nm```\n.\n\nThis leads to the recursive expression:\n\n```\nf(n, m) = sum f(n - i, i) for 0 <= i <= min(n, m - 1)\n```\n\n\n\n\nYou can compute ```\nf```\n recursively, but using dynamic programming it will be faster of course. Storing the results matrix is straightforward though, so I leave that up to you.\n\n\n\nComing back to the original claim that ```\nf(N, N+1)-1```\n is the answer you are looking for, it doesn't really matter which value to choose for ```\nm```\n as long as it is ```\n> N```\n. Based on the recursive formula it's easy to show that ```\nf(N, N + 1) = f(N, N + k)```\n for every ```\nk >= 1```\n:\n\n```\nf(N, N + k) = sum f(N - i, i) for 0 <= i <= min(N, N + k - 1)\n            = sum f(N - i, i) for 0 <= i <= N\n            = sum f(N - i, i) for 0 <= i <= min(N, N + 1 - 1)\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Can bottom-up dynamic programming be done in Lisp?\r\n                \r\nCan a typical Lisp dialect solve problems using the bottom-up \"dynamic programming\" approach?\n\n(Please note: I'm not talking about \"memoization\" which, as far as I understand, is trivial using any Lisp dialect.  I'm really talking about bottom-up Dynamic Programming, where you build, for an example, your array bottom up and then use the elements you just introduced to compute the next ones.)\n\nFor example, using dynamic programming, the \"0-1 knapsack\" problem can be solved in pseudo-polynomial time for inputs on which any other method would fail.\n\nAn imperative (incomplete) solution is:\n\n```\nfor (int k = 1; k <= a.length; k++) {\n    for (int y = 1; y <= b; y++) { \n        if (y < a[k-1]) {\n            knap[k][y-1] = knap[k-1][y-1];\n        } else {\n            if (y > a[k-1]) {\n                knap[k][y-1] = Math.max(knap[k-1][y-1], knap[k-1][y-1-a[k-1]] + c[k-1]);\n            } else {\n                knap[k][y-1] = Math.max(knap[k-1][y-1], c[k-1]);\n    }\n}\n```\n\n\nIs such a thing possible to do in the various Lisp dialects?  If no, why not?\n    ", "Answer": "\r\nOf course this is possible. The only things you need are arrays, integers and a loop construct. E.g., in Scheme, your algorithm can be transcribed using vectors. The main problem is that it becomes hard to read, since ```\nknap[k-1][y-1]```\n becomes ```\n(vector-ref (vector-ref knap (- k 1)) (- y 1))```\n and\n\n```\nknap[k][y-1] = knap[k-1][y-1];\n```\n\n\nbecomes\n\n```\n(vector-set! (vector-ref knap k) (- y 1)\n             (vector-ref (vector-ref knap (- k 1)) (- y 1)))\n```\n\n\n(or a hairy trick with moduli), while memoized recursions just remain readable.\n\nSpeaking from experience, I recommend you stick to the memoization when programming in Lisp and similar languages. If you use hash tables, the expected asymptotic time and space complexity are the same for memoization and DP.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "nth fibonacci number using using dynamic programming\r\n                \r\nI am able to understand the dynamic programming implementation given HERE.\n\nBut I am not clear about the another version given in cracking the coding interview book which I am copy pasting. Can someone please help me understand this, moreover is this not more expensive than the above geeksforgeek dynamic programming implementation.\n\n```\nint[] fib = new int[max];\nint fibonacci(int i){\nif(i == 0) return 0;\nif(i == 1) return 1;\nif (fib[i] != 0) return fid[i];\nfib[i] = fibonacci(i-1) + fibonacci(i-2);\nreturn fib[i];\n}\n```\n\n    ", "Answer": "\r\nBasically ```\nint[] fib```\n is a cache in which the ```\ni```\nth fibonacci number is stored.\n\nThis is a great time saver. Otherwise the recursive fibonacci procedure would need to recalculate a lot of values.\n\nE.g.\n\n```\nfib[8] = fibonacci(7) + fibonacci(6)\n```\n\n\nBut then:\n\n```\nfib[7] = fibonacci(6) + fibonacci(5)\n```\n\n\nAs you can see, without caching, the value for ```\nfibonacci(6)```\n would be needed to calculated two times.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Can bottom-up dynamic programming be done in Lisp?\r\n                \r\nCan a typical Lisp dialect solve problems using the bottom-up \"dynamic programming\" approach?\n\n(Please note: I'm not talking about \"memoization\" which, as far as I understand, is trivial using any Lisp dialect.  I'm really talking about bottom-up Dynamic Programming, where you build, for an example, your array bottom up and then use the elements you just introduced to compute the next ones.)\n\nFor example, using dynamic programming, the \"0-1 knapsack\" problem can be solved in pseudo-polynomial time for inputs on which any other method would fail.\n\nAn imperative (incomplete) solution is:\n\n```\nfor (int k = 1; k <= a.length; k++) {\n    for (int y = 1; y <= b; y++) { \n        if (y < a[k-1]) {\n            knap[k][y-1] = knap[k-1][y-1];\n        } else {\n            if (y > a[k-1]) {\n                knap[k][y-1] = Math.max(knap[k-1][y-1], knap[k-1][y-1-a[k-1]] + c[k-1]);\n            } else {\n                knap[k][y-1] = Math.max(knap[k-1][y-1], c[k-1]);\n    }\n}\n```\n\n\nIs such a thing possible to do in the various Lisp dialects?  If no, why not?\n    ", "Answer": "\r\nOf course this is possible. The only things you need are arrays, integers and a loop construct. E.g., in Scheme, your algorithm can be transcribed using vectors. The main problem is that it becomes hard to read, since ```\nknap[k-1][y-1]```\n becomes ```\n(vector-ref (vector-ref knap (- k 1)) (- y 1))```\n and\n\n```\nknap[k][y-1] = knap[k-1][y-1];\n```\n\n\nbecomes\n\n```\n(vector-set! (vector-ref knap k) (- y 1)\n             (vector-ref (vector-ref knap (- k 1)) (- y 1)))\n```\n\n\n(or a hairy trick with moduli), while memoized recursions just remain readable.\n\nSpeaking from experience, I recommend you stick to the memoization when programming in Lisp and similar languages. If you use hash tables, the expected asymptotic time and space complexity are the same for memoization and DP.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Fibonacci series in dynamic programming in python [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        How to write the Fibonacci Sequence?\r\n                            \r\n                                (67 answers)\r\n                            \r\n                    \r\n                Closed 5 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n```\n# Program 1\nfibSeries = {}\ndef fib(n):    \n    a,b = 1,1\n    for i in range(1,n+1):        \n        if i <= 2: \n            f = 1\n        else: \n            f = a + b\n            a = b\n            b = f\n        fibSeries[i] = f\n    return f\n\nprint (fib(number))\nprint (fibSeries)\n\n# Program 2\nfibSeries={}\ndef fib(n):\n    for k in range(1,n+1):\n        if k <= 2: f = 1\n        else: f = fib(k-1) + fib(k-2)\n        fibSeries[k] = f\n    return f\n\nprint(fib(number))\nprint(fibSeries)\n```\n\n\nI have started dynamic programming and my first program is to find Fibonacci series. I have written the above two programs. My first question is which among these programs comes under dynamic programming? Which among these two programs is a better one? Is there a better way than program 1 to find the nth Fibonacci number faster? Is program 2 better than recursion? And how to find the number of times the function is called in program 2?\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming for Minimum Path Sum\r\n                \r\nI am not understanding how to exactly use dynamic programming for the Minimum Path Sum Problem. The problem statement is as follows.\n\n```\nGiven a m x n grid filled with non-negative numbers, find a path from \ntop left to bottom right which minimizes the sum of all numbers \nalong its path.\nNote: You can only move either down or right at any point in time.\n```\n\n\nHere is the code i tried using just recursion. \n\n```\n#include \"stdafx.h\"\n#include \"vector\"\n#include \"iostream\"\n#include \"cmath\"\n#include \"algorithm\"\nusing namespace std;\nclass Solution {\n public:\nint s = INT_MAX;\nint helper(int sum, vector<vector<int>> &grid, int i, int j) {\n    if (i == grid.size() - 1 && j == grid[0].size() - 1) {\n        return s = min(s, sum + grid[i][j]);\n    }\n    if (i >= grid.size() || j >= grid[0].size()) {\n        return sum;\n    }\nreturn min(helper(sum + grid[i][j], grid, i + 1, j) + helper(sum + grid[i][j], grid, i, j + 1), s);\n\n}\nint minPathSum(vector<vector<int>>& grid) {\n    return helper(0, grid, 0, 0);\n}\n};\n\nint main()\n{\nvector<int> v = { 1,2,3 };\nvector<vector<int>> r;\nr.push_back(v);\nv = { 4,5,6 };\nr.push_back(v);\nv = { 7,8,9 };\nr.push_back(v);\nv = { 1,2,3 };\nr.push_back(v);\nSolution s;\ncout<<s.minPathSum(r);\nreturn 0;\n}\n```\n\n\nAnd here is a code where i tried using Dynamic programming where I am storing the least sum at a given index ```\n[i,j]```\n and returning it, but its not being of much help, the Online Coding Judge says \"Time Limit Exceeded\" \nCan you please help me improve the code.\n\n```\n#include \"stdafx.h\"\n#include \"vector\"\n#include \"iostream\"\n#include \"cmath\"\n#include \"algorithm\"\nusing namespace std;\nclass Solution {\npublic:\nint s = INT_MAX;\nint helper(int sum, vector<vector<int>> &grid, int i, int j,vector<vector<int>> &memoize) {\n    if (i == grid.size() - 1 && j == grid[0].size() - 1) {\n        return s = min(s, sum + grid[i][j]);\n    }\n    if (i >= grid.size() || j >= grid[0].size()) {\n        return sum;\n    }\n    if (sum + grid[i][j] < memoize[i][j])\n        memoize[i][j] = sum + grid[i][j];\n    else\n        return memoize[i][j];\n\n    return min(helper(sum + grid[i][j], grid, i + 1, j,memoize) + helper(sum + grid[i][j], grid, i, j + 1,memoize), s);\n}\nint minPathSum(vector<vector<int>>& grid) {\n    vector<vector<int>> memoize(grid.size(), vector<int>(grid[0].size(), INT_MAX));\n    return helper(0, grid, 0, 0,memoize);\n}\n};\n  int main()\n {\nvector<int> v = { 1,2,3 };\nvector<vector<int>> r;\nr.push_back(v);\nv = { 4,5,6 };\nr.push_back(v);\nv = { 7,8,9 };\nr.push_back(v);\nv = { 1,2,3 };\nr.push_back(v);\nSolution s;\ncout<<s.minPathSum(r);\nreturn 0;\n  }\n```\n\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming Algorithm\r\n                \r\nI have the following question on a homework\n\n\nI have no idea how to solve part B (at least with a dynamic programming algorithm) because from what I can tell, the best cost for N days has nothing to do with the best cost for N-1 days.  I'm not looking for someone to do my homework for me (I know that's frowned upon here), but just for some guidance on where to start, or what subproblems to split this up into.  Thanks!\n    ", "Answer": "\r\n(I like you being humble so I am trying to give some hints here...Also please try to use plain text, in your own words to simplified the problem if you can, next time :)  Welcome to the community.)\n\nThe question statement of part b already gives you a great hints: use a 2D array to store the state. It is because it's not enough to know week i-1's optimal solution (which is greedy and you should have answered it at part a), meaning we have to know something else other than week number, which is the second dimension.\n\nSo let's start to think what is possibly the two dimension means, what do they represent and how to use them to find our optimal answer. Here I introduce my own thinking process on DP problems, it is pretty much fill-in the blanks game.\n\n\n\nThinking Process\n\nIntuitively, one dimension must be the week i, so that it may depends on some previous weeks i-1, i-2...etc\n\nSo let D(i, ?) be the 2D state, it represents the minimum cost we have to pay until week i. \n\nIt is saying D(i,?) = Minimum cost till week i, with xxx being yyy\n\nWhat is xxx, yyy? How about company X and Current Company Used? Let's fit it in to see if it make sense (It is really my thinking process, with a lot trial & error to see which one seems right, by experience)\n\n\n  D(i, X) := Minimum cost till week i, with company X being current company used\n\n\n\n\nMore Serious Logical Thinking (TL;DR)\n\nSeems good, no? \n\nSo we have a 2D state D(i, X), which can be represent by a 2D array D[52][3].\n\n\n  Now we have changed the problem itself\n  \n  From What is the min cost till week i?\n  \n  To What is the min cost till week i using company X as the last\n  company used?\n\n\nFor Simplicity, I will just use D(i, A),  D(i, B) and D(i, C) as notation in the following.\n\nIf we already know week i-1's optimal solution using a specific company, then we can compute current week i's optimal solution. \n\nThis is because it considers all cases, mutual exclusively. By all cases, I mean no matter which week is it, you have to use one of these 3 companies after all.\n\nAnd it has so-called optimal substructure property: To calculate D(i, A) for example, the best path from D(i-1, A), D(i-1, B), D(i-1, C) including penalty if needed, must give the optimal solution of D(i, A).  Because if there is some path to week i-1 which is not optimal (no matter which company), I can always choose another path which is optimal, and use that to calculate D(i, A) which must be better.\n\nNote that if we do not take the second dimension current company into account, the original problem would not have this property and thus cannot be solved by greedy directly. \n\nWith another property called overlapping subproblems, now our new problem can be solved by Dynamic Programming.\n\nAnd when we solve the new problem, we can use the solution of our new problem to solve our original problem:  Ans = Max(D(52, A), D(52, B), D(52, C))\n\n\n\nBack to Homework\n\nOkay, so here I give you some more fill-in the blanks game which may aid you to finish the problem.\n\n\nDefine D(i,X) as ____________________\nThe base case D(0, X) is ____________\nThe answer is Max(____,  ____,  ____)\nD(i, A) = min(_____, _____, _____) + a[i] where a[i] is _________\nD(i, B) = min(_____, _____, _____) + b[i] where b[i] is _________\nD(i, C) = min(_____, _____, _____) + c[i] where c[i] is _________\n\n\nFill in all of these and you are good.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Is Memoization considered Dynamic Programming? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        What is the difference between memoization and dynamic programming?\r\n                            \r\n                                (12 answers)\r\n                            \r\n                    \r\n                Closed 3 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI'm confused about what the difference between dynamic programming and memoization is. I always thought they were the exact same thing, just different words, but if this isn't the case, could somebody please clarify what they mean?\nGoogle gives me different answers every time I click on a different blog.\n    ", "Answer": "\r\nRelevant article on Programming.Guide: Dynamic programming vs memoization vs tabulation\n\n\n\n\n  What is difference between memoization and dynamic programming?\n\n\nMemoization is a term describing an optimization technique where you cache previously computed results, and return the cached result when the same computation is needed again.\n\n\n\nDynamic programming is a technique for solving problems of recursive nature, iteratively and is applicable when the computations of the subproblems overlap.\n\n\n\nDynamic programming is typically implemented using tabulation, but can also be implemented using memoization. So as you can see, neither one is a \"subset\" of the other.\n\n\n\nA reasonable follow-up question is: What is the difference between tabulation (the typical dynamic programming technique) and memoization?\n\nWhen you solve a dynamic programming problem using tabulation you solve the problem \"bottom up\", i.e., by solving all related sub-problems first, typically by filling up an n-dimensional table. Based on the results in the table, the solution to the \"top\" / original problem is then computed.\n\nIf you use memoization to solve the problem you do it by maintaining a map of already solved sub problems. You do it \"top down\" in the sense that you solve the \"top\" problem first (which typically recurses down to solve the sub-problems).\n\nA good slide from here (link is now dead, slide is still good though):\n\n\n  \n  If all subproblems must be solved at least once, a bottom-up dynamic-programming algorithm usually outperforms a top-down memoized algorithm by a constant factor\n  \n  \n  No overhead for recursion and less overhead for maintaining table\n  There are some problems for which the regular pattern of table accesses in the dynamic-programming algorithm can be exploited to reduce the time or space requirements even further\n  \n  If some subproblems in the subproblem space need not be solved at all, the memoized solution has the advantage of solving only those subproblems that are definitely required\n  \n\n\nAdditional resources:\n\n\nWikipedia: Memoization, Dynamic Programming\nRelated SO Q/A: Memoization or Tabulation approach for Dynamic programming\n\n\nSource: What is the difference between memoization and dynamic programming?\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming Fibonacci Swift\r\n                \r\nI'm trying to covert an implementation below to Swift and having difficulty:\n\n```\nvar mem = [];\nvar fibRecursiveMem = function (n) {\n    if (mem[n]) return mem[n];\n    if (n<=2) mem[n] = 1;\n    else {\n        mem[n] = fibRecursiveMem(n-1) + fibRecursiveMem(n-2);\n    }\n    return mem[n];\n} \n```\n\n\nfrom: https://dev.to/rattanakchea/dynamic-programming-in-plain-english-using-fibonacci-as-an-example-37m1\n\nmy implementation in Swift:\n\n```\nvar mem = [Int]()\nfunc fib (_ num: Int) -> Int {\n    if (mem.count - 1 > num) {\n        return mem[num]\n    }\n    if (num<=2) {mem[num] = 1}\n    else {\n        mem[num] = fib(num-1) + fib(num-2)\n    }\n    return mem[num]\n}\n```\n\n\nProduces index out of range errors.\n\nNow I want to follow the general logic of the original algorithm. What am I doing wrong in the translation?\n    ", "Answer": "\r\nIn this case, it would be better to use a dictionary to implement memory:\n```\nvar mem = [Int: Int]()\nfunc fib (_ num: Int) -> Int {\n    if let cached = mem[num] {\n        return cached\n    }\n\n    let result: Int\n\n    if (num <= 2) {\n        result = 1\n    }\n    else {\n        result = fib(num - 1) + fib(num - 2)\n    }\n\n    mem[num] = result\n    return result\n}\n```\n\nIn javascript, the difference between arrays and dictionaries is rather small. Even when ```\nmem```\n is declared as an array, it is actually being used as a dictionary.\nTo use an array, we have to be sure to always ```\nappend```\n correctly:\n```\nvar mem = [0, 1, 1] // prefill initial values for 0, 1, 2\nfunc fib (_ num: Int) -> Int {\n    if num < mem.count {\n        return mem[num]\n    }\n\n    let result = fib(num - 1) + fib(num - 2)\n    // the recursion has already appended all previous values\n    mem.append(result)\n\n    return result\n}\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming Subset Algorithm\r\n                \r\nI am working on some review material for dynamic programming. I need to come up with how the subproblems should be divided, work out the base case, and come up with the recursive formula.\n\nGiven n positive integers a1,a2,...,an, a number k and a target W, we want to select a subset T with exactly k elements whose sum is closest to W. Each element can be chosen only once. Define a subproblem with 3 parameters (ie, C[x,y,z] = ...).\n\nI have only worked with a few dynamic programming examples, and have never worked with one that needs 3 parameters in defining the subproblem. I am really lost here. If anyone can shine some light that would be great.\n\nMy best guess for what the subproblem should be is: \n\nC[x,y,z] = x number of elements from {a1,...ay} where the sum is exactly z\n\nBut I have no idea if this is correct.\n    ", "Answer": "\r\nOne way to break this down into three parameters is:\n\n```\nx: maximum index of item considered for inclusion in subset\nn: number of items in subset\ns: sum of subset\n```\n\n\nBase case is C[0,0,0] = true, C[0,i > 0,j > 0] = false\n\nRecursive case is:\n\n```\nC[i,n+1,s+a_i] = C[i-1,n,s]  // use item i\nC[i,n,s] = C[i-1,n,s] // dont use item i\n```\n\n\nThis uses space O(n^2 * max(a_i))  (can be reduced to O(n*max(a_i)) by discarding C[i,,] as it is used)\n\nThen just search C[n,i,j] for j near z for the final answer.\n\nAs a loop...\n\n```\nfor (int i = 1; i <= n; i++)\n{\n    C[i,n+1,s+a_i] ||= C[i-1,n,s];\n    C[i,n,s] ||= C[i-1,n,s];\n}\n```\n\n\nAs recursive function:\n\n```\nbool C(int maxindex, int size, int sum)\n{\n    if (memoize(maxindex, size, sum))\n         return cached;\n\n    if (maxindex == 0)\n        return (size == 0 && sum == 0);\n\n    return\n         C(maxindex-1, size-1, sum - A[maxindex]) ||  // version using A[maxindex]\n         C(maxindex-1, size, sum); // version not using A[maxindex]\n}\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Optimal substructure in Dynamic Programing\r\n                \r\nI have been trying to understand Dynamic Programming, and what I understood is that there are two parts of DP.\n\nOptimal substructures\nOverlapping subproblems\n\nI understand the second one, but I am not able to understand the first one.\n    ", "Answer": "\r\nOptimal substructure means, that any optimal solution to a problem of size ```\nn```\n, is based on an optimal solution to the same problem when considering ```\nn' < n```\n elements.\n\nThat means, when building your solution for a problem of size ```\nn```\n, you split the problem to smaller problems, one of them of size ```\nn'```\n. Now, you need only to consider the optimal solution to ```\nn'```\n, and not all possible solutions to it, based on the optimal substructure property.\n\nAn example is the knapsack problem:\n\n```\nD(i,k) = min { D(i-1,k), D(i-1,k-weight(i)) + cost(i) }\n```\n\n\nThe optimal substructure assumption here, is ```\nD(i,k)```\n can check only optimal solutions to ```\nD(i-1,k)```\n, and none optimal solutions are not considered.\n\nAn example where this does not hold is the Vertex Cover problem.\n\nIf you have a graph G=(V,E), assume you have an optimal solution to a subgraph ```\nG'=(V',E[intersection]V'xV')```\n such that ```\nV' <= V```\n - the optimal solution for ```\nG```\n does not have to be consisted of of the optimal solution for ```\nG'```\n/\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Interpolation using dynamic programming\r\n                \r\nI'm having trouble on doing a homework exercise. \n\nI need to describe an efficient algorithm which solves the polynomial interpolation problem:\n\n\nLet ```\nP[i,j]```\n be the polynomial interpolation of the points (xi, yi),...,(xj,yj). Find 3 simple polynomials q(x), r(x), s(x) of degree 0 or 1 such that: \n\n```\nP[i,j+1]={q(x)P[i,j](x)-r(x)P[i+1,j+1](x)}/s(x)```\n\nGiven the points (x1,y1),....(xn,yn), describe an efficient dynamic programming algorithm based on the recurrence relation which you found in section 1 for computing the coefficients a0,...an-1 of the polynomial interpolation.\n\n\nWell, I know how to solve the polynomial interpolation problem using Newton polynomial which looks quite similar to the above recurrence relation but I don't see how it helps me to find q(x), r(x), s(x) of degree 0 or 1, and assuming I have the correct q(x), r(x), s(x)- how do I solve this problem using dynamic programming?\n\nAny help will be much appreciated.\n    ", "Answer": "\r\n```\nq(x) = (x at {j+1}) - x\nr(x) = (x at i) - x\ns(x) = (x at {j+1}) - (x at i)\n```\n\n\n```\nx at i```\n or ```\nx at j```\n mean their place in the ordered list of input points.\n\nSome explanations:\n\nFirst we need to understand what ```\nP[i,j](x)```\n means. \n\nPut all your initial ```\n(x,y)```\n pairs in the main diagonal of an ```\nn x n```\n matrix.\nNow you can extract ```\nP[0,0](x)```\n to be the y value of the point in your matrix at ```\n(0,0)```\n.\n```\nP[0,1]```\n is the linear interpolation of the points in your matrix at ```\n(0,0)```\n and ```\n(1,1)```\n. This will be a straight line function.\n\n```\n((x at 0 - x)(y at 1) - (x at 1 - x)(y at 0)) \n---------------------------------------------\n              (x at 1 - x at 0)\n```\n\n\n```\nP[0,2]```\n is the linear interpolation of two previous linear interpolations, which means that your ```\ny```\ns now will be the linear functions which you calculated at the previous step.\nThis is also the dynamic algorithm which builds the full polynom.\n\nI highly recommend you have a look at this very good lecture, and the full lecture notes.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Algorithms - Dynamic Programming\r\n                \r\nGiven an array of n elements a1, a2 ... an. If we define a function C = max |a(i+1)-a(i)| for i = 2 to n-1.\nSo we can calculate a value of C for our array. Now the problem is, if we are given the array and some value of C, How many elements in the array should be changed to obtain this value of C? \n\nThis is a part of the solution to this codeforces problem:\nhttp://codeforces.com/contest/361/problem/D \n\nIt is solved using dynamic programming but I don't understand the answer. Could anyone explain it to me? Here is the code.\n\n```\n/* x is the value of the function \nn the size of the array\n\n*/\nint Cal(LL x){ \n    for(int i = 1; i <= n; i++)\n        dp[i] = 0;\n    for(int i = 1; i <= n; i++){\n        for(int j = i + 1; j <= n; j++){\n            if(abs(a[i] - a[j]) <= 1ll * (j - i) * x) {\n                dp[j] = max(dp[j], dp[i] + 1);\n            }\n        }\n    }\n    int ret = 0;\n    for(int i = 1; i <= n; i++)\n        ret = max(ret, dp[i] + 1);\n    return n - ret;\n}\n```\n\n    ", "Answer": "\r\nIn this code, ```\ndp[i]```\n denotes the max number of elements don't need to changed, in order to obtain this value of C, in ```\nrange [1, i]```\n, and we don't change ```\na[i]```\n.\n\nThen check every ```\nj > i```\n, if ```\n|a[i] - a[j]| <= (j - i) * C```\n, we need change all elements between i and j, then ```\ndp[j] = max(dp[j], dp[i] + 1```\n)\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming with Scala\r\n                \r\nTo practice Scala I wanted do solve simple dynamic programming exercises with Scala. For some exercises I already wrote a Python implementation. Using Python most of the time I saved the intermediate results in an array.\n\nFor example this Exercise:\n\nThe algorithm outputs the minimal amount of coins needed to reach a value, given the value and a list of coins. (Assuming there is an unlimited amount of coins.)\n\n```\ndef automat(n, coins = [1,2,5,10,20,50,100,200]):\n    A = [0]\n    for i in range(1, n + 1):\n        smallest_change = min([A[i - coin] for coin in coins if 0 <= i - coin])\n        A.append(smallest_change + 1)\n    return A[n]\n```\n\n\nLooks very simple in Python. Nevertheless I have problems writing the same code in Scala. Because of the functional paradigm I did not want to use a for-loop, but rather a tail-recursive algorithm to solve that problem. And I couldn't find any good solution. Maybe a tail-recursive algorithm is not the right way to go and there is a different scala-way to implement this simple algorithm.\n\nI already looked for scala implementation of dynamic programming exercises and couldn't find a good source yet. Has someone an idea what the scala way to implement this would look like?\n\nUPDATE:\n\nThe closest I came so far is very similar to Dimas tail-recursive approach. It looks like this\n\n```\ndef automat(n: Int, coins: List[Int] = List(1, 2, 5, 10, 20, 50, 100, 200)): Int = {\n    inner(n, n + 1, coins, List(0)).last\n}\n\ndef inner(n: Int, m: Int, coins: List[Int], result: List[Int]): List[Int] = n match {\n    case 0 => result\n    case _ => inner(n-1, m, coins, result ::: List(coins.collect { case coin if (0 <= m - n - coin) => result(m - n - coin) }.min + 1))\n}\n```\n\n    ", "Answer": "\r\nYou can do something like that :\n\n```\n def automat(n: Int, coins: List[Int]): Int = (n, coins) match {\n         case (0, _) => 1\n         case (m, _) if m < 0 => 0\n         case (_, cs)  if cs.isEmpty => 0\n         case (m, cs) => automat(m - cs.head, cs) + automat(m, cs.tail) \n    }\n```\n\n\nIf you are interested in Scala, the Coursera class of Martin Odersky is a good starting point.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Implementing fibonacci using dynamic programming in python\r\n                \r\nI'm trying to implement the Fibonacci sequence using dynamic programming.\nIt shows an error. What's wrong here?  \n\n```\ndef fibo(n): # n is the nth Fibonacci no. in the sequence\n    fib = {} # dict to store earlier values\n    for k in range(1, n + 1): # iterating each time\n    if k <= 1 : \n                f = 0\n    if k == 2 : \n            f = 1\n    else:\n        f = fib[k - 1] + fib[k - 2] # looking up in the fib{}\nfib[k] = f\nreturn fib[n] # returns the nth Fibonacci number\n\nn = int(input('Enter n = '))\nprint('%dth fibo no. is = %d' %(n, fibo(n))) # calling n printing\n```\n\n    ", "Answer": "\r\nI can only assume your initial error was caused by your indentations. When indented properly, your code runs without errors.\n\nSince you'll be performing the same operation at ```\nk == 1```\n and ```\nk == 2```\n no matter the value of n, it makes more sense to assign those values outside the loop, and start your loop later.\n\n```\nfib = {1: 0, 2: 1}\n```\n\n\nAfter this change, and after correcting your indents, your function resembles the following:\n\n```\ndef fibo(n):\n    fib = {1: 0, 2: 1}\n    for k in range(3, n + 1):\n        f = fib[k - 1] + fib[k - 2]\n        fib[k] = f\n    return fib[n]\n\nn = int(input('Enter n = '))\nprint('%dth fibo no. is = %d' %(n, fibo(n)))\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "memoization in dynamic programming\r\n                \r\ncan please tell me how memoization is working in this dp example.\ndp example problem, codechef\n\nthe part where i stuck is like when input is 4 then why code is calculating \nn-1 i.e 4-1 when optimal step would be 4/2 or for input =10 why we will calculate n-1 till 1. Any help would be appreciated.\nNew to dynamic programming so please bear with me.\n    ", "Answer": "\r\nMemoization in dynamic programming is just storing solutions to a subproblem. for input n=4 you calculate its solution. So you try step 1. Subtract 1 + the solution to the subproblem n=3. For this to evaluate you need to solve the problem n=3, because you have not solved it previously. So you again try step 1 until you get to the base problem of n = 1 where you output 0. \n\nAfter you tried step 1 for the current problem you try step 2 which means dividing n and afterwards you try step 3. You try every step for every subproblem, but because you store the best value at every subproblem you can use this when it occurs again. \n\nFor example when you get back to n=4 after you tried step 1 on it you try step 2 on it and you see that you can use n / 2 and because you already calculated the optimal value for n=2 you can output 1 + optimal value for n=2 which is 1, so in total 2.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming python implementation problem\r\n                \r\nI am trying to implement a dynamic programming code using backward iteration. However, the python for loops are giving me list out of range error.\n\n```\npi = [65,61,42,35,30,32,38,42,53,57,59,64,72,77,64,62,40,64,55,43,40,55,30,21]\n\n#backward recursion\n#number of stages T\nT = [i for i in range(1,25)]\n#possible states\nS = [i for i in range(100,1100,100)]\n#decision variable\nD = [100,-100,0]\n\n#initilaize the value function\nobj_val = [[[0 for i in range(1,25)] for j in range(1,9)] for k in range(1,4)]\n\nfor t in range(24,0,-1):  #Step backward through problem stages T\n    for s in range(9): #Step through each possible stage t state\n        for d in range(4):     #step through each feasible stage t decision D\n             if t == 24:  #if it is the last stage\n                 obj_val[t][s][d] = pi[t]*D[d]\n             else: \n                 obj_val[t][s][d] = pi[t]*D[d]+obj_val[t+1][s][d]\n```\n\n\nIndexError: list index out of range (for both the if and else conditions)\n    ", "Answer": "\r\nIn the ```\nobj_val```\n, the most external array has only 4 objects. So when ```\nif```\n is true, you can't get the ```\nobj_val[24]```\n. \nMoreover you don't have index 24 in any of your arrays. It goes maximum to 23.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming and Divide and conquer\r\n                \r\nI was reading notes on Dynamic programming, and I encountered the following comment.\n\n\n  If the subproblems are not independent, i.e.\n  subproblems share subsubproblems, then a divideand-conquer algorithm repeatedly solves the common\n  subsubproblems.\n  Thus, it does more work than necessary\n\n\nWhat does this mean ? Can you give me examples to make the above point clear ?\n    ", "Answer": "\r\nThe author refers to the fact that many divide-and-conquer algorithms have subproblems that overlap with one another.  Consider, for example, this very simple Fibonacci implementation:\n\n```\nint Fibonacci(int n) {\n    if (n <= 1) return n;\n\n    return Fibonacci(n - 1) + Fibonacci(n - 2);\n}\n```\n\n\nIf you trace out the calls done to compute Fibonacci(4), we get\n\n\nFibonacci(4) calls Fibonacci(3) and Fibonacci(2)\nFibonacci(3) calls Fibonacci(2) and Fibonacci(1)\nFibonacci(2) calls Fibonacci(1) and Fibonacci(0)\nFibonacci(2) (the other one) calls Fibonacci(1) and Fibonacci(0)\nFibonacci(1) terminates.\nFibonacci(1) terminates.\nFibonacci(1) terminates.\nFibonacci(0) terminates.\nFibonacci(0) terminates.\n\n\nIn other words, 9 total function calls are made, but there's only five unique calls here (Fibonacci of 0 to 4, inclusive).  This algorithm could be made much more efficient if the recursive calls were shared across the subproblems rather than recomputed from scratch each time.  This is one of the key ideas behind dynamic programming.\n\nTo compute Fn (the nth Fibonacci number), the above code will make a total of 2Fn+1 - 1 recursive calls.  Since the Fibonacci numbers grow exponentially quickly, this requires exponentially much work.  However, it's possible to use the fact that many recursive calls are identical to simplify this dramatically.  Rather than starting at Fibonacci(4) and working down, let's start at Fibonacci(0) and work up.  Specifically, we'll build a table (let's call it FTable) of length 5 and will fill it in as follows:\n\n\nFTable[0] = 0\nFTable[1] = 1\n\n\nNow, suppose we want to compute FTable[2].  This requires us to know FTable[0] and FTable[1], but we already do know that because they're in the table.  We thus can set\n\n\nFTable[2] = 1\n\n\nUsing similar logic, we can compute FTable[3] from FTable[2] and FTable[1]:\n\n\nFTable[3] = 2\n\n\nAnd FTable[4] from FTable[2] and FTable[3]:\n\n\nFTable[4] = 3\n\n\nNotice how we avoided making lots of overlapping recursive calls by just building them up in the reverse order!  This now computes Fibonacci numbers in time O(n), which is exponentially faster than before.  Using some more advanced math we can do even better than this, but this does illustrate why dynamic programming can take infeasible problems and make them suddenly feasible.\n\nHope this helps!\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Recursive solution to Dynamic Programming [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n\n  Possible Duplicate:\n  Dynamic Programming and Knapsack Application  \n\n\n\n\nI have been trying to understand Dynamic Programming but with each new problem I get a bit confused over how to write recursion for it.\n\nTake the following problem:\nThere  is  an  L × H  metal  sheet  which  can  be  cut  by  a  machine  into  two  pieces  either  vertically  or horizontally.Both  L, H    are  integral  and  the  cuts  also  happen  along  integral  values.There  are  n rectangular  patterns  l(i) × h(i) ,   i  ≤  n  (l  , h are  also  integral)  where  the  i-th  pattern  has  proﬁt  c(i).  Design  an  eﬃcient  algorithm  to cut the sheet in a way so as to maximize  the total  proﬁt.   \n\nNow I think for solving it we would create a table of LxH (which would be filled diaganally). But how do we form a recursion for solving this problem ?\n    ", "Answer": "\r\nI'd try something like for every T(L, H), verify the best alternative between:\n\n\ncollect the profit right away\ncut every possible way horizontally\ncut every possible way vertically\n\n\nSomething like:\n\n```\nT(L, H) = max(\n    c(L, H),  \n    T(i, H)+T(L-i, H), // 0<i<L\n    T(L, i)+T(L, H-i)  // 0<i<H\n)\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Minimize function using dynamic programming\r\n                \r\nHow to minimize function y12 + y22 + ... + yn2 with constraints y1*y2*...*yn = c; y1,y2,...,yn > 0 using dynamic programming? I have tried to solve this problem, but I have no idea how to create a recurrent function.\n    ", "Answer": "\r\nYou need to think how to reduce the problem into \"smaller problem\"\n\n```\nD(i,c) = min { D(i-1, c/y) + y^2 | 1 <= y <= c }\n```\n\n\nIn the above, you reduce the problem from ```\ny1,y2,....,yi```\n to ```\ny1,...,y_{i-1}```\n, and check all possible assignments for ```\ny_i```\n - and chose the best out of them.\n\nBase clauses will be:\n\n```\nD(0,0) = 0\nD(i,0) = Infinity    i>0\n```\n\n\nYou can do a top-down or bottom-up DP solution with these recurrence formulas, assuming ```\ni,c```\n are integers. (Might need to add stop clause of ```\nD(i,c) = Infinity if c is not natural```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Are tail recursion and dynamic programming the same?\r\n                \r\nI was programming Fibonacci numbers using tail recursion and it seems like the idea behind it is same as Dynamic programming. So are they same? or rather there is some amount of similarity between them? If not when are the cases when they get different?\n    ", "Answer": "\r\nThe terms themselves, although related, are not equivalent by any means: \n\n\nDynamic programming is a problem solving methodology which can be implemented with or without using tail recursion. More generically, it requires \"memoization\".\nTail recursion is a common way to implement a dynamic programming algorithm, because it specifically applies memoization logic to a specific field.\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming python implementation problem\r\n                \r\nI am trying to implement a dynamic programming code using backward iteration. However, the python for loops are giving me list out of range error.\n\n```\npi = [65,61,42,35,30,32,38,42,53,57,59,64,72,77,64,62,40,64,55,43,40,55,30,21]\n\n#backward recursion\n#number of stages T\nT = [i for i in range(1,25)]\n#possible states\nS = [i for i in range(100,1100,100)]\n#decision variable\nD = [100,-100,0]\n\n#initilaize the value function\nobj_val = [[[0 for i in range(1,25)] for j in range(1,9)] for k in range(1,4)]\n\nfor t in range(24,0,-1):  #Step backward through problem stages T\n    for s in range(9): #Step through each possible stage t state\n        for d in range(4):     #step through each feasible stage t decision D\n             if t == 24:  #if it is the last stage\n                 obj_val[t][s][d] = pi[t]*D[d]\n             else: \n                 obj_val[t][s][d] = pi[t]*D[d]+obj_val[t+1][s][d]\n```\n\n\nIndexError: list index out of range (for both the if and else conditions)\n    ", "Answer": "\r\nIn the ```\nobj_val```\n, the most external array has only 4 objects. So when ```\nif```\n is true, you can't get the ```\nobj_val[24]```\n. \nMoreover you don't have index 24 in any of your arrays. It goes maximum to 23.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming of a knapsack with additional constraints\r\n                \r\nIf we have a normal 0-1 knapsack problem and want to solve it with dynamic programming, we use bottom up computation like explained here. \n\nBut how is a knapsack problem solved with dynamic programming, if you add constraints to the problem saying that some items are not allowed added together like the following constraint: x1 + x2 <= 1? Do you then use some sort of a third dimension on the table?\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming efficient network\r\n                \r\nHello I have a dynamic programming  related question. How can I compute the shortest path in hops from starting node to ending, with the constrain that the vertices and edges will have an equal or higher predefined value. For example the highest rate of data in a network. Could someone provide some pseudo-code or any thoughts, thank you in advance.\n    ", "Answer": "\r\nBuild new graph from the given network, which does not contain the vertices and edges whose value is less than the predefined value, and from the start node, in the new graph run an algorithm to find the shortest path to the end node, such as BFS, Dijkstra (-Greedy, not Dynamic Programming), Bellman – Ford, etc.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Haskell performance using dynamic programming\r\n                \r\nI am attempting to calculate the Levenshtein distance between two strings using dynamic programming. This is being done through Hackerrank, so I have timing constraints. I used a techenique I saw in: How are Dynamic Programming algorithms implemented in idiomatic Haskell? and it seems to be working.  Unfortunaly, it is timing out in one test case.  I do not have access to the specific test case, so I don't know the exact size of the input.  \n\n```\nimport Control.Monad\nimport Data.Array.IArray\nimport Data.Array.Unboxed\n\nmain = do\n  n <- readLn\n  replicateM_ n $ do\n    s1 <- getLine\n    s2 <- getLine\n    print $ editDistance s1 s2\n\neditDistance :: String -> String -> Int\neditDistance s1 s2 = dynamic editDistance' (length s1, length s2)\n  where\n    s1' :: UArray Int Char\n    s1' = listArray (1,length s1) s1\n    s2' :: UArray Int Char\n    s2' = listArray (1,length s2) s2\n    editDistance' table (i,j)\n      | min i j == 0 = max i j\n      | otherwise = min' (table!((i-1),j) + 1) (table!(i,(j-1)) + 1) (table!((i-1),(j-1)) + cost)\n      where\n        cost =  if s1'!i == s2'!j then 0 else 1\n        min' a b = min (min a b)\n\ndynamic :: (Array (Int,Int) Int -> (Int,Int) -> Int) -> (Int,Int) -> Int\ndynamic compute (xBnd, yBnd) = table!(xBnd,yBnd)\n  where\n    table = newTable $ map (\\coord -> (coord, compute table coord)) [(x,y) | x<-[0..xBnd], y<-[0..yBnd]]\n    newTable xs = array ((0,0),fst (last xs)) xs\n```\n\n\nI've switched to using arrays, but that speed up was insufficient.  I cannot use Unboxed arrays, because this code relies on laziness. Are there any glaring performance mistakes I have made? Or how else can I speed it up?\n    ", "Answer": "\r\nThe backward equations for edit distance calculations are:\n\n```\nf(i, j) = minimum [\n  1 + f(i + 1, j), -- delete from the 1st string\n  1 + f(i, j + 1), -- delete from the 2nd string \n  f(i + 1, j + 1) + if a(i) == b(j) then 0 else 1 -- substitute or match\n]\n```\n\n\nSo within each dimension, you need nothing more than the very next index: ```\n+ 1```\n. This is a sequential access pattern, not random access to require arrays; and can be implemented using lists and nested right folds:\n\n```\neditDistance :: Eq a => [a] -> [a] -> Int\neditDistance a b = head . foldr loop [n, n - 1..0] $ zip a [m, m - 1..]\n  where\n  (m, n) = (length a, length b)\n  loop (s, l) lst = foldr go [l] $ zip3 b lst (tail lst)\n    where\n    go (t, i, j) acc@(k:_) = inc `seq` inc:acc\n      where inc = minimum [i + 1, k + 1, if s == t then j else j + 1]\n```\n\n\nYou may test this code in Hackerrank Edit Distance Problem as in:\n\n```\nimport Control.Applicative ((<$>))\nimport Control.Monad (replicateM_)\nimport Text.Read (readMaybe)\n\neditDistance :: Eq a => [a] -> [a] -> Int\neditDistance a b = ... -- as implemented above\n\nmain :: IO ()\nmain = do\n  Just n <- readMaybe <$> getLine\n  replicateM_ n $ do\n    a <- getLine\n    b <- getLine\n    print $ editDistance a b\n```\n\n\nwhich passes all tests with a decent performance.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Min cost with dynamic programming in java\r\n                \r\nI'm working on a project where I have to find the min cost with dynamic programming. We have an array ```\nA[n*m]```\n filled. Also we have another array ```\nb[n*m]```\n. We have to fill another ```\nc(n*m)```\narray that ```\nc(i,j)```\nfilled with the minimum of    \n\n```\nfor (i=1 to m) \n  a[i,j]+B[j,k]+c[i-1,k]\n```\n\n\nfor example we have this arrays.\n\nThis is my code: \n\n```\nfor (int t = 1; t < n; t++) {\n for (int y = 0; y < m; y++) {\n  int min = 9999555;\n  for (int k = 0; k < m; k++) {\n   if ((a[t][y] + b[y][k]) < min) {\n    min= a[t][y] + b[y][k] + c[t - 1][k];\n    }\n   }c[t][y] += min;\n  }\n }\n for (int u = 0; u < n; u++) {\n        for (int z = 0; z < m; z++) {\n            System.out.print(c[u][z]+\" \");\n        }\n        System.out.println();\n    }\n```\n\n\nThe first column of ```\nc```\n should be the same with first of column of ```\na```\n. \nfor example:\n```\nc[2,1]```\n is```\nmin{A[2,1]+c[1,1]+b[1,1], A[2,1]+C[1,2]+B[2,1],A[2,1]+c[1,3]+b[3,1]}```\n\nI want to ask you if my code is correct method of dynamic programming. \n    ", "Answer": "\r\nLet's state things clearly:\nA[i,j] is the cost of running process i on VM j   \n\nState C[i,j] implies the minimal cost of running processes \"0..i\" on VMs \"0..j\"  \n\nLet's assume for now, that there is no B cost array.  \n\nThe goal is state C[n,m] which is the minimal cost of running processes \"0..n\" on VMs \"0..m\".\nWe may reach state C[i,j] from:  \n\n\nstate C[i-1,j] which means that VMs \"0..j\" will run additional process \"i\" and taking into account the costs of running process \"i\" on VMs \"0..j\" that's sum(a[i,k]) where k=0..j\nHence the cost is C[i-1, j] + sum(a[i,k]) where k=0..j  \nstate C[i, j-1] which means that processes \"0..j\" will be running on one more VM \"j\" (so total \"0..j\") and taking into account the costs of running processes \"0..i\" on VM \"j\" that's sum(a[k,j]) where k=0..i\nHence the cost is C[i, j-1] + sum(a[k,j]) where k=0..i  \n\n\nBy taking minimum of these two values we find C[i,j]  \n\nDo you agree so far? \n\nUPDATE.\nAssuming that process and VM numbering starts from 0:  \n\nbase case:  \n\n```\nfor(int j=0; j < m; j++)  \n     c[ 0 ][ j ] = a[ 0 ][ j ];\n```\n\n\nDP loop:\n\n```\nfor (int i = 1; i < n; i++) \n{\n for (int j = 0; j < m; j++) \n {\n     int min = Integer.MAX_INT;\n     for (int k = 0; k < m; k++) \n      {\n        if ((a[ i ][ j ] + b[ k ][ j ] + c[ i-1 ][ k ]) < min) \n\n             min= a[ i ][ j ] + b[ k ][ j ] + c[ i-1 ][ k ];\n\n      }//try every VM\n\n     c[ i ][ j ] = min;\n\n  }//for every VM\n}//for every process\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming SPOJ problem SCUBADIV\r\n                \r\nI am trying to solve this problem from SPOJ, it's a dynamic programming problem, but I'm having trouble visualizing the recursive step. I believe it's similar to a knapsack, but here there are two constraints of Oxygen and Nitrogen. \n\nHere is the link: http://www.spoj.pl/problems/SCUBADIV/ \n    ", "Answer": "\r\nThis should work I think:\n\n```\ndp[i, j] = minimum weight needed such that we have i litres of oxygen and j litres \n           of nitrogen\n\ndp[0, 0] = 0 and inf everywhere else\nfor each read cylinder k do\n  for i = maxTotalOxygen down to oxygen[k] do\n    for j = maxTotalNitrogen down to nitrogen[k]  do\n      dp[i, j] = min(dp[i, j],                                       <- do not take cylinder k\n                     dp[i - oxygen[k], j - nitrogen[k]] + weight[k])  <- take cylinder k \n\nAnswer is the minimum dp[i, j] such that i >= RequiredOxygen and j >= RequiredNitrogen.\n```\n\n\nNote that the ```\nfor```\n loops must go from the max down to the values of the current cylinder, otherwise you allow a cylinder to be used more than once.\n\nThe problem constraints are very small and I think this should work. \n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Confusion related to dynamic programming\r\n                \r\nI was going through this page related to dynamic programming. I am a big confused about the complexity given\n\n\n\nHere in the third case the complexity is given as $O(n^2)$. I am not sure how it came to be that. Can anyone please elaborate. How the complexities were calculated here.\n    ", "Answer": "\r\nIf i and j are both free to range from 1 to n, I can see n^2 subproblems by thinking about holding i fixed at 1 while ranging j from 1-n. Then do the same for all values of i 1-n. But the picture and set notation seem to imply j > i (a contiguous, unique set) so I think that makes it a bit confusing. I'm imagining i=2, j=1... could it be x2, x3 (interpreting j as the number of x's we want starting at 2?) or x2, x1 (interpreting j as the index)....\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Example of non-Euclidean tabulation in Dynamic Programming?\r\n                \r\nIn the accepted answer to this SO question regarding Dynamic Programming, the authors mentioned that:\n\n\n  Tabulation - You can also think of dynamic programming as a \"table-filling\" algorithm (though usually multidimensional, this 'table' may have non-Euclidean geometry in very rare cases). \n\n\nWhat are some examples of this 'non-Euclidean' geometry tabulation the authors referred to?\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Explanation of the dynamic programming subproblem for House robber problem?\r\n                \r\nI have a question understanding subproblem in dynamic programming. For example:\n\nProblem statement is as follows\n\n```\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\nGiven a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.\n```\n\n\nInput is \n\n```\nnums = [1,2,3,1]\n```\n\n\nThe subproblem relation everybody is using is \n\n```\ndp[i] = Math.max(nums[i]+dp[i-2], dp[i-1])\n```\n\n\nCan somebody explain to me the logic behind the dynamic programming recurrence relation.\n    ", "Answer": "\r\nThere are essentially 3 conditions \n\n\nnumHouse == 0, moneySteal = 0\nnumHouse == 1, moneySteal = nums[0] // only one element in the array.\n\n\nNow the interesting case where robber can steal from the houses not adjacent to each other. \n\nNow here, at i'th house we have already computed \n\n```\ndp[i-1]: Max loot till i-1 house\ndp[i-2]: Max loot till i-2 house\n```\n\n\nSo, the robber has a choice at i'th house.\n\nIf robber loots i'th house that means it didn't loot i-1 house as these two are adjacent. \n\nOr the robber can see whether not looting i'th house is beneficial as loot value i-1 house will be more which is denoted by dp[i-1]\n\nSo, robber maximizes the loot amount at i'th house by checking which one is more (nums[i] + dp[i-2]) i.e. loot ith house or not loot ith house as dp[i-1] is bigger.\n\n```\n  dp[i] = Math.max(nums[i]+dp[i-2], dp[i-1])\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Is it possible to convert all backtracking algorithms in to dynamic programming approach?\r\n                \r\nI have tried a few backtracking algorithms and successfully converted them to dynamic programming by applying the concept of memoization.\n\nIs it possible to convert every backtracking algorithm to dynamic programming?\n\nIf dynamic programming is so much efficient than backtracking, why we still use backtracking? \n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Longest path in a tree using dynamic programming\r\n                \r\nI recently solved a problem of the longest path by using BFS twice. I also learned that dynamic programming can be used to solve the longest path in a directed acyclic graph. What would the pseudocode and recursion equation/runtime be for finding the longest path in an undirected weighted tree given a random node using dynamic programming?\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "can every iterative algorithm be turned into dynamic programming?\r\n                \r\nIt have been much discussed that every recursive algorithm can be transformed into iterative algorithms.. \n\nBut... can every iterative algorithm be transformed into dynamic programming?\n\nI'm starting to learn about Dynamic Programming... and i'm having a lot of problems.. even though i can find recursive solutions, and i'm expertising turning them into iterative algorithms, i still can't turn these iterative algorithms into dynamic programming... it'd be, indeed, very helpfull to certainly know that every iterative algorithm can be transformed into dynamic...\n    ", "Answer": "\r\nI hope that by Dynamic Programming you mean the same thing as Wikipedia does - that is, algorithms that break the problem into smaller subproblems, and use memoization to avoid having to solve the same problem twice.\n\nDynamic Programming cannot be usefully applied to all iterative algorithms. For Dynamic Programming to be useful, the problem needs two properties:\n\n\nOverlapping subproblems - when solving the problem recursively, you need to encounter the same subproblem, with the same parameters, more than once, otherwise memoizing was a waste of time and memory.\nOptimal substructure - the knowledge that if you have the solutions to the sub-problems, the solution to the whole problem is easy to compute.\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming algorithm involving combinations?\r\n                \r\nProblem\n\nSo that problem is solved by this algorithm\n\n```\npublic int rob(int[] nums) {\n    if (nums.length == 0) return 0;\n    int[] memo = new int[nums.length + 1];\n    memo[0] = 0;\n    memo[1] = nums[0];\n    for (int i = 1; i < nums.length; i++) {\n        int val = nums[i];\n        memo[i+1] = Math.max(memo[i], memo[i-1] + val);\n    }\n    return memo[nums.length];\n}\n```\n\n\nI am not able to follow this dynamic programming approach, I cannot get out of the idea of iterative programming. I keep wanting to create currentMax variables etc, but it serves no purpose. \n\nIs it possible to explain what is going on here, and the pattern?\n    ", "Answer": "\r\nJust trying to explain the nature of this problem and I hope it will follow - Think in terms that if there are only two houses ```\n< h1 <cost: 90>, h2 <cost: 100>>```\n. What would be the answer? One would go for ```\nh2```\n. This is our base case of the problem and we will extend it from here.extension - 3 houses - ```\n<h1 <cost: 90>, h2 <cost: 100>, h3 < cost: 75>>```\n. If you loot ```\nh2```\n , you can not loot ```\n<h1> and <h3>```\n but you want to loot ```\n<h1> and <h3>```\nbecause it gives you more sum. so, recursively, at a current time t,if I store my result in a variable ```\ndp```\n and a ```\nrecursive func(int index,int[] array)```\n, I can frame answer as ```\ndp[index]=max(arr[index]+dp[index+2],dp[index+1])```\n. It states that if I loot ```\nith House```\n, then I can not loot ```\nnext house```\n, so remaining problem to solve is from ```\ni+2th index```\n \n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Explanation of the dynamic programming subproblem for House robber problem?\r\n                \r\nI have a question understanding subproblem in dynamic programming. For example:\n\nProblem statement is as follows\n\n```\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\nGiven a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.\n```\n\n\nInput is \n\n```\nnums = [1,2,3,1]\n```\n\n\nThe subproblem relation everybody is using is \n\n```\ndp[i] = Math.max(nums[i]+dp[i-2], dp[i-1])\n```\n\n\nCan somebody explain to me the logic behind the dynamic programming recurrence relation.\n    ", "Answer": "\r\nThere are essentially 3 conditions \n\n\nnumHouse == 0, moneySteal = 0\nnumHouse == 1, moneySteal = nums[0] // only one element in the array.\n\n\nNow the interesting case where robber can steal from the houses not adjacent to each other. \n\nNow here, at i'th house we have already computed \n\n```\ndp[i-1]: Max loot till i-1 house\ndp[i-2]: Max loot till i-2 house\n```\n\n\nSo, the robber has a choice at i'th house.\n\nIf robber loots i'th house that means it didn't loot i-1 house as these two are adjacent. \n\nOr the robber can see whether not looting i'th house is beneficial as loot value i-1 house will be more which is denoted by dp[i-1]\n\nSo, robber maximizes the loot amount at i'th house by checking which one is more (nums[i] + dp[i-2]) i.e. loot ith house or not loot ith house as dp[i-1] is bigger.\n\n```\n  dp[i] = Math.max(nums[i]+dp[i-2], dp[i-1])\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming in Aerospace Engineering Problems [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 2 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nAccording to Wikipedia, Dynamic Programming\n\nhas found applications in numerous fields, from aerospace engineering to economics.\n\nWhat are some example problems solved by DP in Aerospace Engineering?\nMaybe something with optimizing launch trajectory?\n    ", "Answer": "\r\nDynamic programming is a fundamental core of aerospace vehicles, corporations typically don't want to disclose information like this as it is their intellectual property.\nHowever, there are many scholarly articles that overview how dynamic programming affects aerospace vehicles\nHere's even a book on it: https://books.google.com/books?hl=en&lr=&id=MIdp-9rbYSQC&oi=fnd&pg=PP1&dq=dynamic+programming+in+aerospace&ots=K6BSIMGze4&sig=VMDcLYNTYWuUcv87D6zqGejfhOA#v=onepage&q=dynamic%20programming%20in%20aerospace&f=false\nI would assume that they are used in other systems besides just launch trajectory.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Counting heads - Dynamic Programming\r\n                \r\nProblem:\n\n\n  Given integers n and k, along with ```\np1,p2,..., pn; where pi ε [0, 1]```\n, you want to determine the probability of obtaining exactly ```\nk```\n heads when ```\nn```\n biased coins are tossed independently at random, where pi is the probability that the ith coin comes up heads. Give an O(n2) algorithm for this task. Assume you can multiply and add two numbers in [0, 1] in O(1) time.\n\n\nCan somebody help me with developing the recurrence relation so that I may code it. (The question comes from back exercise of chapter Dynamic Programming in book \"Algorithms By Dasgupta\")\n    ", "Answer": "\r\nConsider the situation when (n-1) coins are tossed together and nth coin is tossed apart and take into account mutual independence.\n\nCombine probabilities of simpler cases to get P(1..n, k) (where P(1..n, k) is the probability of obtaining exactly k heads when n coins)\n\nThen apply this rule and fill all the cells in NxK table\n\nEdit:\n\nThere are two possible ways to get exactly k heads with n coins - \n\na) if (n-1) coins have k heads, and Nth coin is tail, and\n\nb) if (n-1) coins have k-1 heads, and Nth coin is head\n\nso\n\nP(n, k) = P(n-1, k) * (1 - p[n]) + P(n-1, k-1) * p[n] \n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "dynamic programming and the use of matrices\r\n                \r\nI'm always confused about how dynamic programming uses the matrix to solve a problem. I understand roughly that the matrix is used to store the results from previous subproblems, so that it can be used in later computation of a bigger problem. \n\nBut, how does one determine the dimension of the matrix, and how do we know what value each row/column of the matrix should represent? ie, is there like a generic procedure of constructing the matrix?\n\nFor example, if we're interested in making changes for S amount of money using coins of value c1,c2,....cn, what should be the dimension of the matrix, and what should each column/row represent? \n\nAny directional guidance will help. Thank you!\n    ", "Answer": "\r\nA problem becomes eligible for dynamic programming when it exhibits both Overlapping Sub-problems as well as Optimal Substructure.\nSecondly, dynamic programming comes in two variations:\n\nTabulation or the Bottom-up approach\nMemoization or the Top-down approach (not MemoRization!)\n\nDynamic Programming stems from the ideology that a large problem can be further broken down into sub-problems. The bottom-up version simply starts with solving these sub-problems first and gradually building up the target solution. The top-down approach relies on using auxiliary storage doing away with re-computation.\n\nis there like a generic procedure of constructing the matrix?\n\nIt really depends on what problem you're solving and how you're solving it! Matrices are typically used in tabulation, but it always need not be a matrix. The main goal here is to have the solutions to the sub-problems readily available on demand, it could be stored in an array, a matrix or even a hash-table.\nThe classic book Introduction to Algorithms demonstrates the solution to the rod-cutting problem in both ways where a 1D array is used as auxiliary storage.\n\nFor example, if we're interested in making changes for S amount of money using coins of value c1,c2,....cn, what should be the dimension of the matrix and what should each column/row represent?\n\nIf I'm not wrong, you're referring to the \"total unique ways to make change\"  variant of the coin-change problem. You need to find the total ways a given amount can be constructed using given set of coins.\nThere is a great video on this that breaks it down pretty well. It uses a bottom-up approach: https://www.youtube.com/watch?v=DJ4a7cmjZY0\nAssume you need to construct amount ```\nn = 10```\n from the given subset of coins ```\nc = {1, 2, 10}```\n\nTake an empty set and keep adding the coins one per row from ```\nc```\n. For every next row, one coin from the set is added. The columns represent the sub-problems. For ```\ni```\n in ```\nn = 1 : 10```\n, the ```\ni```\nth column represents the the total number of ways ```\ni```\n can be constructed using the coins in that row:\n```\n---------------------------------------------------------\n           | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |\n---------------------------------------------------------\n|{}        |   |   |   |   |   |   |   |   |   |   |    |\n---------------------------------------------------------\n|{1}       |   | X |   |   |   |   |   |   |   |   |    |\n---------------------------------------------------------\n|{1, 2}    |   |   |   |   |   |   |   |   |   |   |    |\n---------------------------------------------------------\n|{1, 2, 10}|   |   |   | Y |   |   |   |   |   |   | Z  |\n---------------------------------------------------------\n```\n\nIn this table, ```\nX```\n represents the number of ways amount 1 can be constructed using the coin ```\n{1}```\n, ```\nY```\n represents the number of ways amount 3 can be represented using the coins ```\n{1, 2, 10}```\n and ```\nZ```\n  represents the number of ways amount 10 can be represented using the coins ```\n{1, 2, 10}```\n.\nHow are the cells populated?\nInitially, the entire first column headed by ```\n0```\n is filled with ```\n1```\ns because no matter how many coins you have, for the amount 0 you have exactly one way to make change that is to make no change.\nThe rest of the first row with the empty subset ```\n{}```\n is filled with ```\n0```\ns because you can't make a change for any positive amount with no coins.\nNow the matrix looks like this:\n```\n---------------------------------------------------------\n           | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |\n---------------------------------------------------------\n|{}        | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |  0 |\n---------------------------------------------------------\n|{1}       | 1 | X |   |   |   |   |   |   |   |   |    |\n---------------------------------------------------------\n|{1, 2}    | 1 |   |   |   |   |   |   |   |   |   |    |\n---------------------------------------------------------\n|{1, 2, 10}| 1 |   |   | Y |   |   |   |   |   |   | Z  |\n---------------------------------------------------------\n```\n\nNow, how do we fill ```\nX```\n? You have two alternatives, either to use the ```\n1```\n coin in this new super set or to not use it. If you did not use the coin, the ways are same as the above row that is ```\n0```\n. But since ```\n1```\n can be used to make a change of amount ```\n1```\n, we use that coin, and subtract ```\n1```\n from the amount ```\n1```\n to be left with ```\n0```\n. Now lookup, ```\n0```\n's ways in the same row, that is the column previous to that of ```\nX```\n which is ```\n1```\n. So add it to the amount from the top row to have a total of ```\n1```\n. So you fill this cell as ```\n1```\n.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "What's the difference between object-oriented and dynamic programming\r\n                \r\nI know that dynamic programming refers to an approach where we tend to break down a complex problem into smaller parts. In other words, it's a divide-and-conquer paradigm. Object-oriented programming also uses the concept of classes and modules, and therefore follows the separation of concerns (SoC) principle. Can we therefore say that OO is an example of dynamic programming? \n\nNote: Dynamic here doesn't mean dynamic typing or dynamic scripting language. It refers to the general approach.\n    ", "Answer": "\r\nDynamic programming is an algorithm designing approach.\n\nObject Oriented programming is more like a code organising methodology.\n\nComparing them is like comparing kilometre with kilogram.\n\n(And Linear programming is also a totally different thing. It is for optimizing complex linear equations. It is more mathematics than programming. And Integer programming is a special case of it.)\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Change money with python dynamic programming\r\n                \r\nHere are two programs for change money problem. The first one is only a recursion program that get all combinations and the second one is using dynamic programming. HOWEVER, i get into trouble when I am working on second one. It is supposed to be faster than the first one, but my program runs FOREVER to do it. I am pretty sure that I am using the dynamic programming, but i don't know what's the problem in it?\n\nNotes: Total is the money going to be changed, units is a list with different values and stored is a dictionary to store the value of a step.\n\nFirst:\n\n```\ndef changeMoney(total, units):\n    if ( total == 0 ): \n        return [{}]\n    elif ( total < 0 ):\n        return []\n    else:\n        n = len(units)\n        ret = []\n        for i in range(0,n):\n            sols = changeMoney(total-units[i],units[i:n])\n            for sol in sols:\n                if ( units[i] in sol ):\n                    sol[units[i]] += 1\n                else:\n                    sol[units[i]] = 1\n            ret.append(sol)\n        return ret\nprint(dpChangeMoney(300,[100,50,20,10,5,2,1],{}))\n```\n\n\nSecond:\n\n```\nimport copy\ndef dpChangeMoney(total, units, stored):\n    key = \".\".join(map(str,[total] + units))\n    if key in stored:\n        return stored[key]\n    else:\n        if ( total == 0 ):\n            return [{}]\n        elif ( total < 0 ):\n            return []\n        else:\n            n = len(units)\n            for i in range(0,n):\n                sols = copy.deepcopy(dpChangeMoney(total-\nunits[i],units[i:n], stored))\n                for sol in sols:\n                    if ( units[i] in sol ):\n                        sol[units[i]] += 1\n                    else:\n                        sol[units[i]] = 1\n                    if key in stored:\n                        if sol not in stored[key]:\n                            stored[key] += [sol]\n                    else:\n                        stored[key] = [sol]\n        return stored[key]\nprint(dpChangeMoney(300,[100,50,20,10,5,2,1],{}))\n```\n\n    ", "Answer": "\r\nHere's a much faster way to do this:\n\n```\ndef dpChangeMoney(total, units, stored, min_ix=0):\n    if total < 0:\n        return []\n\n    if total == 0:\n        return [{}]\n\n    if min_ix == len(units):\n        return []\n\n    key = (total, min_ix)\n    if key in stored:\n        return stored[key]\n\n    sol_list = []\n    u = units[min_ix]\n    for c in range(total // u + 1):\n        sols = dpChangeMoney(total - c*u, units, stored, min_ix + 1)\n        for sol in sols:\n            if c > 0:\n                sol2 = sol.copy()\n                sol2[u] = c\n            else:\n                sol2 = sol\n            sol_list.append(sol2)\n\n    stored[key] = sol_list\n    return sol_list\n```\n\n\nIf invoked as follows, it prints the number of solutions for the specified case:\n\n```\nprint(len(dpChangeMoney(300, [100,50,20,10,5,2,1], {})))\n```\n\n\nThe result is:\n\n```\n466800\n```\n\n\nOn my system this took well under a second to run.  (Of course, you could print the actual solutions, but there are a lot!)\n\nTo see the actual solutions for a total of ```\n10```\n:\n\n```\nprint(dpChangeMoney(10, [100,50,20,10,5,2,1], {}))\n```\n\n\nThe result is:\n\n```\n[{1: 10}, {1: 8, 2: 1}, {1: 6, 2: 2}, {1: 4, 2: 3}, {1: 2, 2: 4}, {2: 5}, {1: 5, 5: 1}, {1: 3, 2: 1, 5: 1}, {1: 1, 2: 2, 5: 1}, {5: 2}, {10: 1}]\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming Simple Example at C? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        A simple example for someone who wants to understand Dynamic Programming [closed]\r\n                            \r\n                                (5 answers)\r\n                            \r\n                    \r\n                Closed 5 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI need some examples about Dynamic Programming at Language C.\nI am study algorithm with C now but at this book, examples are too hard to understand.\nDoes anyone give me some example for me?\n    ", "Answer": "\r\nA recursive function:- without dynamic programming it will call the same function multiple times.\n\n```\n int nCr(int n,int r){\n     if (r == 0 || r == n || n == 1 || n == 0){\n        return 1;\n }\n else{\n    return nCr(n-1,r) + nCr(n-1,r-1);\n }\n}\n```\n\n\nNow with the help of Dynamic Programming:\n\n```\n#include <stdio.h>\n\nint main(void) {\n\n    int n,r;\n    scanf(\"%d%d\",&n,&r);\n\n    int mem[n+1][r+1];\n\n    int i,j;\n\n    for(i=0;i<n+1;i++)\n    {\n        for(j=0;j<r+1;j++)\n        {\n            if (j == 0 || j == i || i == 1 || i == 0)\n                mem[i][j]=1;\n            else\n                mem[i][j]=mem[i-1][j]+mem[i-1][j-1];\n        }\n    }\n\n    printf(\"%d\",mem[n][r]);\n\n\n    return 0;\n}\n```\n\n\nI have used a 2D-array to save values so that i can use them instead of calling the function again and again. I have used Dynamic Programming concept. \n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Maximization using Dynamic Programming\r\n                \r\nI am trying to come up with the solution for a problem analogous to the following:\n\n\nLet M be a matrix of n rows and T columns.\nLet each row have positive non-decreasing values. (e.g. row = [1, 2, 30, 30, 35])\nLet M[i][j] correspond to the score obtained by spending j units of time on exam i.\n\n\nUsing dynamic programming, solve the problem as to find the optimal way of spending T units of time to study which will yield the highest total score.\n\nThanks in advance for any help :)\n\nMy attempt:\n\n```\nS[][] = 0\n\nfor i = 1:n\n   for j = 0:T\n       max = 0\n       for k = 0:j\n           Grade = G[i][j]+ S[i-1][T-k]\n           if Grade > max\n              max = Grade\n       end for\n       S[i][j] = max\n    end for\nend for\n```\n\n    ", "Answer": "\r\nLet ```\nS[i][j]```\n represent the best score you can achieve spending ```\nj```\n units of time on the first ```\ni```\n exams.  You can calculate ```\nS[i][j]```\n by looking at ```\nS[i-1][k]```\n for each value of ```\nk```\n.  For each element of ```\nS```\n, remember the value of ```\nk```\n from the previous row that gave the best result.  The answer to what the best score for studying all exams in time ```\nT```\n is just ```\nS[n][T]```\n, and you can use the values of ```\nk```\n that you remembered to determine how much time to spend on each exam.\n\n```\nS[][] = 0\n\nfor j = 0:T\n   S[0][j] = M[0][j]\n\nfor i = 1:n\n   for j = 0:T\n       max = 0\n       for k = 0:j\n           # This is the score you could get by spending j time, spending\n           # k time on this exam and j-k time on the previous exams.\n           Grade = S[i-1][j-k] + M[i][k]\n           if Grade > max\n              max = Grade\n       end for\n       S[i][j] = max\n    end for\nend for\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming - Job Selection\r\n                \r\nI am attempting at solving a Job Selection problem using Dynamic Programming. The problem is as follows:\n - There is one job offering every day with varying payouts every day\n - You cannot work three days in a row (if you work on day 1 and 2, you must take a break on day 3)\n - Come up with a job schedule to work on to maximize the amount of money you make\n\nI have formalized the input and output of the problem as follows:\n\nInput: P[1...n] a list of n positive numbers\nOutput: m, a max possible payout and A, a set of indexes {1,... n} such that if i is in A, and i+1 is in A, then i+2 is not in A. m is equal to a summation of P[i] for all values i in set A.\n\nI am stuck on the thought process of making a self-reduction, and subsequently a dynamic programming algorithm in order to calculate the maximum earnings.\n\nAny assistance is highly appreciated - thanks!\n    ", "Answer": "\r\nUsually dynamic programming is relatively straightforward once you decide how much state you need to take account of at each point, and your solution is efficient or not depending on whether your choice of state is good.\n\nHere I would suggest that the state at each point is whether it is 0, 1, or 2 days since the last break. So for each day and 0,1,2 days since a break I calculate the max possible payout up to and including that day, given that it is 0,1,2 days since a break.\n\nFor 0 days since a break the max payout is the max possible payout for any state on the previous day. There is no contribution for that day, since you are taking a break.\n\nFor 1 days since a break the max payout is the payout for that day plus the max possible pay from all previous days for the state of 0 days since a break for that day.\n\nFor 2 days since a break the max payout is the payout for the current and previous days plus the max possible payout for two days ago and a state of 0 days since the last break on that day.\n\nSo you can calculate the max payouts from left to right, making use of previous calculations, and the overall max is the max payout associated with any state on the final day.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Cutting a rod dynamic programming [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 6 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nGiven a rod of length n inches and an array of prices that contains prices of all pieces of the size smaller than n. Using dynamic programming we can get the maximum value and corresponding pieces of the rod. Is there any algorithm which will produce kth maximum value with the corresponding cut for this problem? \n    ", "Answer": "\r\nProblem : Find ```\nk th```\n max price for rod cutting problem. \n\nI think the algorithm can be tweaked in following way : \n\nChange the recursion in rod cutting problem from  : \n\n```\ncutRod(n) = max(price[i] + cutRod(n-i-1)) for all i in {0, 1 .. n-1}\n```\n\n\nTo : \n\n```\nTop_K_Price_CutRod(n)[] = top_k(price[i] + cutRod(n-i-1)) for all i in {0, 1 .. n-1}\n```\n\n\nBasically, at every recursion step, return max ```\nk```\n prices for that subpart, because only those can be eventually in overall maximum ```\nk```\n . \n\nBruteforce way is to return all the possible prices of that subpart, but we know for sure that prices which have rank greater than ```\nk```\n for this subpart, can't be in top ```\nk```\n prices of complete rod eventually. \n\nSo here ```\nTop_K_Price_CutRod(n)[]```\n is an array of ```\nk```\n max prices for that subpart.\nAt root of the recursion, you will be left with max top ```\nk```\n prices.\n\nI don't think we can optimize more than this, as at every recursion node its top k value can be among final top k. So u have to top ```\nk```\n values for all subparts. \n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming algorithm for assigning tasks\r\n                \r\nI'm struggling with this problem. I tried solving it via simple recursion, but the time it takes for the large cases is huge and I'd like to improve it by writing a dynamic programming algorithm. \n\nThere are ```\nn```\n given students and ```\nn```\n given tasks. Each student is represented by a ```\n1d array of length n```\n of ```\n0```\ns and ```\n1```\ns. ```\nA[i] == 0```\n means that this student can't accomplish ```\ni```\n'th task, and ```\nA[i] == 1```\n means that this student can accomplish ```\ni```\n'th task. The goal is to determine how many different ways there are to assign tasks to students in a way, that all tasks can be accomplished and single student completes only 1 task. \n\nI'll appreciate any hints on how to approach this problem in a dynamic programming way.\n    ", "Answer": "\r\nyour problem really look like a matching problem with bipartite graph (Graph Theory), where a student is a node and a task is an other one (from the other ensemble). Edges represent compatibility between them. I don't have any solution in mind but you will be able to find some good stuff about matching problem and dynamic programming. \n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Why dynamic programming for 0/1 Knapsack?\r\n                \r\nI looked at many resources and also this question, but am still confused why we need Dynamic Programming to solve 0/1 knapsack?\n\nThe question is: I have ```\nN```\n items, each item with value ```\nVi```\n, and each item has weight ```\nWi```\n. We have a bag of total weight ```\nW```\n. How to select items to get best total of values over limitation of weight.\n\nI am confused with the dynamic programming approach: why not just calculate the fraction of (value / weight) for each item and select the item with best fraction which has less weight than remaining weight in bag?\n    ", "Answer": "\r\nFor your fraction-based approach you can easily find a counterexample.\n\nConsider\n\n```\nW=[3, 3, 5]\nV=[4, 4, 7]\nWmax=6\n```\n\n\nYour approach gives optimal value ```\nVopt=7```\n (we're taking the last item since ```\n7/5 > 4/3```\n), but taking the first two items gives us ```\nVopt=8```\n.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Running time - Dynamic programming algorithm\r\n                \r\nAny dynamic programming algorithm that solves N sub problems in the process of computing it's final answer must run in Ω(N) time.\n\nIs this statement true? I am thinking that it is indeed true as i need to compute every sub problem. Please let me know if i am wrong\n    ", "Answer": "\r\nThe short answer is no. Dynamic programming is more of a strategy to boost up performance/shorten runtime complexity than an actual algorithm. Without knowing the actual algorithm for a specific problem, it's not possible to say anything about time complexity.\n\nThe idea of DP is to use memoization(by consuming some space) to speed up exisiting algorithm. Moreover, every algorithm that you can apply DP may speed up in different ways. Without re-computing the same subtask multiple time, you will have to store intermediate results in another data structure. If the result is needed again in your data strucutre, you will directly return intermediate results you've stored \n\nWith that being said, the time complexity of DP problems is the number of unique states/subproblems * time taken per state.\n\nHere's one example when DP solves N sub problems and computation is not Ω(N).\n let's assume your DP requires O(n) subproblems and evaluating each subproblem costs an O(logn) binary search plus constant time operations. \n\nThen the overall algorithm would take O(n*logn).\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Is Java a dynamic programming language? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is opinion-based. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it can be answered with facts and citations by editing this post.\r\n                \r\n                    \r\n                        Closed 3 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nThe definition of Dynamic Programming language says \"These languages are those which perform multiple general behaviours at run-time in contrary to static programming languages which do the same at compile time. It can be by addition of new code, by extending objects and definitions\".\n\nTo the best of my knowledge many programming languages have encapsulation in form of packages like Java or header files like C++. So, the code that as a programmer I will write will certainly expand at compile time and would be eventually converted to assembly code and finally to machine code. So does every high level language becomes dynamic?\n    ", "Answer": "\r\nGenerally speaking, one can differentiate static vs dynamic programming languages by their type systems. in dynamic type system you can have the following\n\n```\nvar x = 2\nx = \"c\"\n```\n\n\nmeaning, the type of a given variable may change during its life time. static type systems do not allow that. C# ```\ndynamic```\n data type is an example of this feature. \n\nBe careful not to confuse dynamic with inferred or weak type systems. an inferred type system will not require formal declaration of the variable, but will infer the type from the assigned value. it will not allow the variable to be re-declared with different type.\n\n```\nvar x = 2  // the type of x is int\nx = \"C\"  // compile error: incompatible types!\n```\n\n\na weak type system is one that allows operations that are not compatible with the declared type of the variable. C allows pointers to be casted to any type:\n\n```\nfoo(void *ptr) {\n  char *str;\n  strcpy(str, (char *)ptr);\n  int i = &(int *)ptr + 1;\n}\n```\n\n\nall combinations of type systems exist, sometimes in the same programming langauge: static/dynamic, implicit(inferred)/explicit, weak/strong.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming: Balanced Partition\r\n                \r\nI want to implement a dynamic programming algorithm for this problem:\nInput: A given arrangement S of non-negative numbers {S1.......Sn}\n\nwe want to partition S into 2 subset S1 an S2 and minimize |sum(S1)-sum(S2)|, then partition the 2 subset in the same way ,  we stop when we reach  an Subset with 2 or 1 element ()We must preserve the order of S elements).\n\nexample : S= {1,2,2,3,4} Output { { {1,2}{2} } {3,4} }\n\nWith the help of this article  this is my implementation :\n\n```\nstatic String partition(int s[], int db,int fn)\n{\n    int n = (fn-db) +1;\n    String res =\"\";\n    if (n<=2){\n        res +=\"[\";\n        for(int l =db ;l<=fn;l++) res+=s[l];\n        res +=\"]\";\n        return res;\n    }\n    int[][] m= new int [n+1][3];                 /* DP table for values */             \n    int[][] d= new int [n+1][3];                 /* DP table for dividers */ \n    int [] p = new int [n+1];                    /* prefix sums array */\n    int cost;                               /* test split cost */\n    int i,x = 0;                              /* counters */\n\n    p[0] = 0;                               /* construct prefix sums */\n    for (i=1; i<=n; i++) \n        p[i]=p[i-1]+s[(db-1)+i];\n\n    for (i=1; i<=n; i++) \n        m[i][1] = p[i];    /* initialize boundaries */\n        m[1][2] = s[db];\n\n\n    for (i=2; i<=n; i++){                    /* evaluate main recurrence */\n            m[i][2] = Integer.MAX_VALUE;\n            for (x=1; x<=(i-1); x++) {\n                cost = Math.max(m[x][1], p[i]-p[x]);\n                if (m[i][2] > cost) {\n                    m[i][2] = cost;\n                    d[i][2] = db+(x-1);\n                }\n            }\n     }\n    return res +=\"[\"+partition(s,db,d[n][2])+partition(s,d[n][2]+1,fn)+\"]\";\n\n}\n\npublic static void main(String[] args) {\n    int []set ={2,1,1,1,5};\n    System.out.print(partition(set,0,set.length-1));\n}\n```\n\n\n\nIs my implementation is the good one or there is another dynamic programing solution whitout recursive call ?\nI cannot calculate complexity of this algorithm , I try to use Master theorem T(n)=aT(nb)+f(n) , but I don't now n/b  the size of each subproblem for the 2 recursive call.\n\n3.How we can do the same partition if we can change the order of element ?\n\n    ", "Answer": "\r\nThink about it this way: in the worst case, you have an array where each index i contains the value 2i. In this case, the split only decreases the length by one, meaning your recursion depth is linear in n. At each level, you do O(n) work, so the total complexity is O(n2). Fortunately, such arrays will be very short in practice, because we generally do not consider such huge numbers, so the real-world performance will generally be better. When the weights are somewhat balanced, you should have O(n log n) performance.\n\nAs for the first question, I'm not sure what you mean with \"the good one\".\n\nEDIT: You algorithm could be made more efficient by performing a binary search on the location you want to split the array at. This is possible because the order must be preserved.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming with Data.Vector\r\n                \r\nam using Data.Vector and am currently in need of computing the contents of a vector for use in computing a cryptographic hash(Sha1). I created the following code. \n\n```\ndynamic :: a -> Int -> (Int -> Vector a -> a) -> Vector a\ndynamic e n f = \nlet \n    start = Data.Vector.replicate n e   \nin step start 0\nwhere\n    step vector i = if i==n then vector\n                    else step (vector // [(i,f i vector)]) (i+1)\n```\n\n\nI created this so that the function f filling out the vector has access to the partial\nresults along the way. Surely something like this must already exist in Data.Vector, no?\n\nThe problem statement is the following: You are to solve a dynamic programming problem where the finished result is an array. You know the size of the array size and you have a recursive function for filling it out.\n    ", "Answer": "\r\nYou probably already saw the function ```\ngenerate```\n, which takes a size ```\nn```\n and a function ```\nf```\n of type ```\nInt -> a```\n and then produces a ```\nVector a```\n of size ```\nn```\n. What you probably weren't aware of is that when using this function you actually do have access to the partial results.\n\nWhat I mean to say is that inside the function you pass to ```\ngenerate```\n you can refer to the vector you're defining and due to Haskell's laziness it will work fine (unless you make it so that the different items of the vector depend on each other in a circular fashion, of course).\n\nExample:\n\n```\nimport Data.Vector\n\ntenFibs = generate 10 fib\n    where fib 0 = 0\n          fib 1 = 1\n          fib n = tenFibs ! (n-1) + tenFibs ! (n-2)\n```\n\n\n```\ntenFibs```\n is now a vector containing the first 10 Fibonacci numbers.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming Maximum Sequence\r\n                \r\nI work in stock trading. I have a two arrays representing currencies.\n\nI want to be able to find the maximum sequence in both the arrays.\n\nHowever, when I change between the two arrays I incur a fixed cost of £20.00\n\nFor example:\n\nArray 1: 12, 21, 45, 10, 42\nArray 2: 52, 3, 4, 10, 35\n\nHow do I use dynamic programming to solve this problem.\n\nI.e. find the maximal weight of the sequence.\n    ", "Answer": "\r\nAn obvious first attempt at a DP solution is to define an array P[i], which is the maximum\nweight attainable for transaction 1 through i. The problem is that in order to update this array, we need\nto know where we were during the previous index since we need to know whether we need to charge the £20.00 change fare. \n\nWe will encode this extra conditional information by adding an additional parameter to control\nfor the location (Array1 or Array2) we were in the last transaction. \n\nP [i, A1] = the max (sequence) transaction 1 through i, assuming transaction i is in A1\n\nP [i, A2] = the max (sequence) transaction 1 through i, assuming transaction i is in A2. \n\nFor the basis case, assume we start in A1, we\nincur no fixed cost, so we have  P[0, A1] = 0.\n\nOn the other hand, if we want to start in\nA2, we need to pay to get there, and thus, P [0, A2] = −20.\n\nNote : We can change the basis case if we start at A2 instead of A1, but I assumed we MUST start at A1. If you can start at either, you can compute both ways and find the max of the two with the following procedure.\n\nIn general, for i > 0, to compute P[i, A1], we consider two possibilities, depending on where we were our last transaction. \n\nIf we were in A1, we don’t need to incur the cost, and we obtain a value of A[i] on top of whatever value we accrued up to transaction i − 1. Thus, we \n\n```\nP [i, A1] = A1[i] + P [i − 1, A1].\n```\n\n\nOn the other hand, if we were in A2 last transaction, we need to pay the incur cost of 20, but we still obtain the A1 transaction and the accrued profit from the first i − 1 transactions. In this case we \n\n```\nP[i, A1] = A1[i] + P [i − 1, A2] − 20.\n```\n\n\nWe have two of the following recursive rule:\n\n```\nP [i, A1] = A1[i] + max(P [i − 1, A1], P [i − 1, A2] − 20).\nP [i, A2] = A2[i] + max(P [i − 1, A2], P [i − 1, A1] − 20).\n```\n\n\nOnce we succeed in computing the values P [i, A1] and P [i, A2], for 0 ≤ i ≤ n, we return the max of P [n, A1] and P [n, A2] as the final result\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "i don't know it is dynamic programming\r\n                \r\ni am beginner who learning algorithm in korea college.\nit is assignment that solving the problem by using dynamic programming without recursive programming, using only python.\nthe problem is whether the result  is printed out   'a'  by some operation or not when you input 5 alphabet of string that composed only 'a','b','c'\n\nI made it, but I'm not sure it's dynamic programming\ni really appreciate your favor if you give me a advice \n\nIssue. \n\n```\n       a b c\n     a b b a\n     b c b a\n     c a c c\n```\n\n\nThere is an arithmetic table consisting of three elements, {a, b, and c} and the row, column, and corresponding intersecting values of the table give you a value such as {aa = b, ab = b, ac=a}.\n\nBased on these values, print out whether or not the result can be derived for any string (' possible' or 'impossible'),\n and, if possible, write the calculation sequence using a dynamic programming technique to indicate the sequence through the bracket.\n\nexample\ninput : bbbba.\nResult: possible, (b(bb)(bb)a))\nIn the example above the table are computed by referring to the first round brackets and Analysis,\n (bb) is (b).\nThen (b(b)) becomes (b) , and (b)a becomes c, indicating that\n the final requirement of bc=a is met.\n- The language must use the Python.\n- dynamic programming algorithms are techniques allowed for (dont' use a recursion x).\n- Output the first value obtained in many cases\n- Set the length of the string, which is the input value, to 5.\n\n```\ndef rule(x,y):\n    if((x=='a' and y=='c') or (x=='b' and y=='c') or (x=='c' and y=='a')):\n        return 'a'\n\n    if((x=='a' and y=='a') or (x=='a' and y=='b') or (x=='b' and y=='b')):\n        return 'b'\n\n    if((x=='b' and y=='a') or (x=='c' and y=='b') or (x=='c' and y=='c')):\n        return 'c'\ndef rule2(x,y,z):\n    return rule(rule(x,y),z)\ndef rule3(x,y,z):\n    return rule(x,rule(y,z))\ndef rule4(w,x,y,z):\n    return rule(rule(w,x),rule(y,z))\ndef rule5(w,x,y,z):\n    return rule(rule2(w,x,y),z)\ndef rule6(w,x,y,z):\n    return rule(rule3(w,x,y),z)\ndef rule7(w,x,y,z):\n    return rule(w,rule2(x,y,z))\ndef rule8(w,x,y,z):\n    return rule(w,rule3(x,y,z))\ndef rule9(v,w,x,y,z):\n    global k\n    k='((('+v+w+')'+x+')'+y+z+')'\n    return rule(rule2(v,w,x),rule(y,z))\ndef rule10(v,w,x,y,z):\n    global k\n    k='(('+v+'('+w+x+'))('+y+z+'))'\n    return rule(rule3(v,w,x),rule(y,z))\ndef rule11(v,w,x,y,z):\n    global k\n    k='(('+v+w+')(('+x+y+')'+z+'))'\n    return rule(rule(v,w),rule2(x,y,z))\ndef rule12(v,w,x,y,z):\n    global k\n    k='(('+v+w+')('+x+'('+y+z+')))'\n    return rule(rule(v,w),rule3(x,y,z))\ndef rule13(v,w,x,y,z):\n    global k\n    k='((('+v+w+')('+x+y+'))'+z+')'\n    return rule(rule4(v,w,x,y),z)\ndef rule14(v,w,x,y,z):\n    global k\n    k='(((('+v+w+')'+x+')'+y+')'+z+')'\n    return rule(rule5(v,w,x,y),z)\ndef rule15(v,w,x,y,z):\n    global k\n    k='((('+v+'('+w+x+')'+y+')'+z+'))'\n    return rule(rule6(v,w,x,y),z)\ndef rule16(v,w,x,y,z):\n    global k\n    k='('+v+'('+w+'(('+x+y+')'+z+')))'\n    return rule(rule7(v,w,x,y),z)\ndef rule17(v,w,x,y,z):\n    global k\n    k='('+v+'('+w+'('+x+'('+y+z+'))))'\n    return rule(rule8(v,w,x,y),z)\ndef rule18(v,w,x,y,z):\n    global k\n    k='('+v+'(('+w+x+')('+y+z+')))'\n    return rule(v,rule4(w,x,y,z))\ndef rule19(v,w,x,y,z):\n    global k\n    k='(('+v+'(('+w+x+')'+y+')'+z+'))'\n    return rule(v,rule5(w,x,y,z))\ndef rule20(v,w,x,y,z):\n    global k\n    k='('+v+'(('+w+'('+x+y+'))'+z+'))'\n    return rule(v,rule6(w,x,y,z))\ndef rule21(v,w,x,y,z):\n    k='('+v+'('+w+'(('+x+y+')'+'))'+z+')'\n    return rule(v,rule7(w,x,y,z))\ndef rule22(v,w,x,y,z):\n    global k\n    k='('+v+'('+w+'('+x+'('+y+z+'))))'\n    return rule(v,rule8(w,x,y,z))\ndef rule23(v,w,x,y,z):\n    global k\n    k='((('+v+w+')'+x+')'+'('+y+z+'))'\n    return rule2(rule(v,w),x,rule(y,z))\ndef rule24(v,w,x,y,z):\n    global k\n    k='(('+v+w+')('+x+'('+y+z+')))'\n    return rule3(rule(v,w),x,rule(y,z))\n\nprint(\"     input:\",end='')\nstr=input()\nstr=list(str)\nx=[rule9,rule10,rule11,rule12,rule13,rule14,rule15,rule16,rule17,rule18,rule19,\n   rule20,rule21,rule22,rule23,rule24]\nfor i in range(0,16):\n    y=x[i](str[0],str[1],str[2],str[3],str[4])\n    if(y=='a'):\n        print(\"possible,\",end=' ')\n        print(k)\n        break\n    if(y!='a' and i==15):\n        print(\"impossible\")\n```\n\n    ", "Answer": "\r\nOf course there can be better way to solve the problem you approached and probably you will learn that once you will see other people assignment solutions, but about recursive/dynamic question you had, your code execution in memory is not recursive. \n\nIt is definitely a linear dynamic programming what you have created up there.\n\nJust to be sure, you could also test it via this implementation of a recursive test: https://stackoverflow.com/a/36663046/3564632\n\nSo overall you might try with this example just to test it out:\n\n```\nfrom bdb import Bdb\nimport sys\n\nclass RecursionDetected(Exception):\n    pass\n\nclass RecursionDetector(Bdb):\n    def do_clear(self, arg):\n        pass\n\n    def __init__(self, *args):\n        Bdb.__init__(self, *args)\n        self.stack = set()\n\n    def user_call(self, frame, argument_list):\n        code = frame.f_code\n        if code in self.stack:\n            raise RecursionDetected\n        self.stack.add(code)\n\n    def user_return(self, frame, return_value):\n        self.stack.remove(frame.f_code)\n\ndef test_recursion(func):\n    detector = RecursionDetector()\n    detector.set_trace()\n    try:\n        func()\n    except RecursionDetected:\n        return True\n    else:\n        return False\n    finally:\n        sys.settrace(None)\n\ndef rule(x,y):\n    if((x=='a' and y=='c') or (x=='b' and y=='c') or (x=='c' and y=='a')):\n        return 'a'\n\n    if((x=='a' and y=='a') or (x=='a' and y=='b') or (x=='b' and y=='b')):\n        return 'b'\n\n    if((x=='b' and y=='a') or (x=='c' and y=='b') or (x=='c' and y=='c')):\n        return 'c'\ndef rule2(x,y,z):\n    return rule(rule(x,y),z)\ndef rule3(x,y,z):\n    return rule(x,rule(y,z))\ndef rule4(w,x,y,z):\n    return rule(rule(w,x),rule(y,z))\ndef rule5(w,x,y,z):\n    return rule(rule2(w,x,y),z)\ndef rule6(w,x,y,z):\n    return rule(rule3(w,x,y),z)\ndef rule7(w,x,y,z):\n    return rule(w,rule2(x,y,z))\ndef rule8(w,x,y,z):\n    return rule(w,rule3(x,y,z))\ndef rule9(v,w,x,y,z):\n    global k\n    k='((('+v+w+')'+x+')'+y+z+')'\n    return rule(rule2(v,w,x),rule(y,z))\ndef rule10(v,w,x,y,z):\n    global k\n    k='(('+v+'('+w+x+'))('+y+z+'))'\n    return rule(rule3(v,w,x),rule(y,z))\ndef rule11(v,w,x,y,z):\n    global k\n    k='(('+v+w+')(('+x+y+')'+z+'))'\n    return rule(rule(v,w),rule2(x,y,z))\ndef rule12(v,w,x,y,z):\n    global k\n    k='(('+v+w+')('+x+'('+y+z+')))'\n    return rule(rule(v,w),rule3(x,y,z))\ndef rule13(v,w,x,y,z):\n    global k\n    k='((('+v+w+')('+x+y+'))'+z+')'\n    return rule(rule4(v,w,x,y),z)\ndef rule14(v,w,x,y,z):\n    global k\n    k='(((('+v+w+')'+x+')'+y+')'+z+')'\n    return rule(rule5(v,w,x,y),z)\ndef rule15(v,w,x,y,z):\n    global k\n    k='((('+v+'('+w+x+')'+y+')'+z+'))'\n    return rule(rule6(v,w,x,y),z)\ndef rule16(v,w,x,y,z):\n    global k\n    k='('+v+'('+w+'(('+x+y+')'+z+')))'\n    return rule(rule7(v,w,x,y),z)\ndef rule17(v,w,x,y,z):\n    global k\n    k='('+v+'('+w+'('+x+'('+y+z+'))))'\n    return rule(rule8(v,w,x,y),z)\ndef rule18(v,w,x,y,z):\n    global k\n    k='('+v+'(('+w+x+')('+y+z+')))'\n    return rule(v,rule4(w,x,y,z))\ndef rule19(v,w,x,y,z):\n    global k\n    k='(('+v+'(('+w+x+')'+y+')'+z+'))'\n    return rule(v,rule5(w,x,y,z))\ndef rule20(v,w,x,y,z):\n    global k\n    k='('+v+'(('+w+'('+x+y+'))'+z+'))'\n    return rule(v,rule6(w,x,y,z))\ndef rule21(v,w,x,y,z):\n    k='('+v+'('+w+'(('+x+y+')'+'))'+z+')'\n    return rule(v,rule7(w,x,y,z))\ndef rule22(v,w,x,y,z):\n    global k\n    k='('+v+'('+w+'('+x+'('+y+z+'))))'\n    return rule(v,rule8(w,x,y,z))\ndef rule23(v,w,x,y,z):\n    global k\n    k='((('+v+w+')'+x+')'+'('+y+z+'))'\n    return rule2(rule(v,w),x,rule(y,z))\ndef rule24(v,w,x,y,z):\n    global k\n    k='(('+v+w+')('+x+'('+y+z+')))'\n    return rule3(rule(v,w),x,rule(y,z))\n\nprint(\"     input:\",end='')\nstr=input()\nstr=list(str)\nx=[rule9,rule10,rule11,rule12,rule13,rule14,rule15,rule16,rule17,rule18,rule19,\n   rule20,rule21,rule22,rule23,rule24]\nfor i in range(0,16):\n    assert not test_recursion(lambda: x[i](str[0],str[1],str[2],str[3],str[4]))\n    y = x[i](str[0],str[1],str[2],str[3],str[4])\n    if(y=='a'):\n        print(\"possible,\",end=' ')\n        print(k)\n        break\n    if(y!='a' and i==15):\n        print(\"impossible\")\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Scala Lazy Dynamic Programming\r\n                \r\nSo I'm following http://jelv.is/blog/Lazy-Dynamic-Programming/ and implementing the Fibonacci example in Scala. Here is my implementation:\n\n```\nclass Lazy[T] (expr : => T) {\n  lazy val value = expr\n  def apply(): T = value\n}\nobject Lazy{ def apply[T](expr : => T) = new Lazy({expr}) }\n\ndef fib(n: Int): Int = {\n  def doFib(i: Int): Lazy[Int] = Lazy {\n    if (i <= 2) 1\n    else fibs(i - 1)() + fibs(i - 2)()\n  }\n  lazy val fibs = Array.tabulate[Lazy[Int]](n)(doFib)\n  doFib(n).value\n}\nfib(5)\n```\n\n\nIn this case, ```\nfib(5)```\n correctly returns result 5.\nThen I want to see if ```\nLazy[T]```\n can be made into a monad by trying the following code, which results in StackOverflow runtime error:\n\n```\nclass Lazy[T] (expr : => T) {\n  lazy val value = expr\n  def apply(): T = value\n  def flatMap[A](f: T => Lazy[A]): Lazy[A] = Lazy { f(value).value }\n  def map[A](f: T => A): Lazy[A] = Lazy { f(value) }\n}\nobject Lazy{ def apply[T](expr : => T) = new Lazy({expr}) }\n\ndef fib(n: Int): Int = {\n  def doFib(i: Int): Lazy[Int] =\n    if (i <= 2) Lazy(1)\n    else for {\n      a <- fibs(i - 1)\n      b <- fibs(i - 2)\n    } yield a + b\n  lazy val fibs = Array.tabulate[Lazy[Int]](n)(doFib)\n  doFib(n).value\n}\nfib(5)\n```\n\n\nIt appears that fibs(i - 1) is calculated too early, which results in infinite recursion. I wonder if there is a ```\nfor```\n comprehension syntax that's equivalent to the first code snippet?\n    ", "Answer": "\r\nYou are right, \"fibs(i - 1) is calculated too early\". It is evaluated immediately when you call ```\ndoFib```\n, because the ```\ndoFib(i)```\n needs ```\nfibs(i - 1)```\n in order to be able to return anything, which in turn needs the return value of ```\ndoFib(i - 1)```\n and so on, so that the recursion unfolds completely while you are constructing the array of lazy ints (before you invoke ```\ndoFib(n).value```\n).\n\nIf you want it lazy, then return a ```\nLazy```\n that does not require immediate evaluation of ```\nfibs(i - 1)```\n:\n\n```\nclass Lazy[T] (expr : => T) {\n  lazy val value = expr\n  def apply(): T = value\n  def flatMap[A](f: T => Lazy[A]): Lazy[A] = Lazy { f(value).value }\n  def map[A](f: T => A): Lazy[A] = Lazy { f(value) }\n}\n\nobject Lazy{ def apply[T](expr : => T) = new Lazy({expr}) }\n\ndef fib(n: Int): Int = {\n  def doFib(i: Int): Lazy[Int] =\n    if (i <= 2) Lazy(1)\n    else Lazy{ (for {\n        a <- fibs(i - 1)\n        b <- fibs(i - 2)\n      } yield a + b).value\n    }\n  lazy val fibs = Array.tabulate[Lazy[Int]](n)(doFib)\n  doFib(n).value\n}\n\nprintln(fib(40)) // 102334155\n```\n\n\nAlternatively, you can wrap the whole ```\nif-else```\n in a ```\nLazy```\n:\n\n```\ndef doFib(i: Int): Lazy[Int] = Lazy {\n  if (i <= 2) 1\n  else (for {\n    a <- fibs(i - 1)\n    b <- fibs(i - 2)\n  } yield a + b).value\n}\n```\n\n\nThis produces the same expected result.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Does the link state algorithm use dynamic programming?\r\n                \r\nSo i was wondering if the link state alogirthm is based on dynamic programming. Thank you in advance. \n    ", "Answer": "\r\nIMHO, the Link State routing algorithm is based on a bottom-up, dynamic programming approach. Here are my reasons:\n\n\n  Why dynamic?\n\n\nBecause it divides the task of routing over a network into many smaller tasks, calculating reachability for all nodes (and then filling the tables etc). I see this as dividing the problem into smaller problems: dynamic!\n\nI won't call this Greedy because calculating reachability from all nodes to all other nodes sounds like a set of overlapping subproblems.\n\n\n  Why bottom-up?\n\n\nBecause (assuming) a new node is added to the network, we would have to again calculate the reachability for all the nodes, and redo the whole thing because the new node can (possibly) be directly reachable by any number of nodes, and the whole representation would change. Top-down approaches would normally require adjustments in the routing table/map only corresponding to the new node.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "2D dynamic programming in F#\r\n                \r\nI need to implement a simple dynamic programming algorithm in 2D in F#. For simple 1D cases Seq.unfold seems to be the way to go, see e.g. https://stackoverflow.com/a/7986083/5363\n\nIs there a nice (and efficient) way to achieve a similar result in 2D, e.g. rewrite the following pseudo-code in functional style:\n\n```\n  let alpha = \n    let result = Array2D.zeroCreate N T\n    for i in 0 .. N-1 do\n      result.[0, i] <- (initialPi i) * (b i observations.[0])\n    for t in 1 .. T-1 do\n      for i in 0 .. N-1 do\n        let s = row t-1 result |> Seq.mapi (fun j alpha_t_j -> alpha_t_j * initialA.[i, j]) () |> Seq.sum\n        result.[t, i] <- s * (b i observations.[t])\n    result \n```\n\n\nassume that all the missing functions and arrays are defined above.\n    ", "Answer": "\r\nEDIT: Actually read code, this is at least functional, does have a slightly different return type, although you could avoid that with a conversion\n\n```\nlet alpha = \n    let rec build prev idx max = \n        match idx with\n        |0 -> \n            let r = (Array.init N (fun i -> (initialPi y) * (b i observations.[0]))\n            r:: (build r 1 max)\n        |t when t=max -> []\n        |_ ->  \n             let s = prev |> Seq.mapi (fun j alpha_t_j -> alpha_t_j * initialA.[i, j]) () |> Seq.sum\n             let r = Array.init N (fun i -> s * (b i observations.[t]))\n         r:: build r (idx+1 max)\n    build [] 0 T |> List.toArray       \n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "PyTorch: Dynamic Programming as Tensor Operation\r\n                \r\nIs it possible to get the following loop with a Tensor operation?\n```\na = torch.Tensor([1, 0, 0, 0])\nb = torch.Tensor([1, 2, 3, 4])\n\nfor i in range(1, a.shape[0]):\n    a[i] = b[i] + a[i-1]\n\nprint(a) # [1, 3, 6, 10]\n```\n\nThe operation depends on the previous values in ```\na```\n and the values that are computed on the way (in a dynamic programming fashion).\nIs it possible to get this type of sequential computation with a tensor operation?\n    ", "Answer": "\r\nYou can achieve this with a cumulative sum:\n```\nb.cumsum(0)\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Algorithm and data structure learning resources for dynamic programming\r\n                \r\nIm learning dynamic programming now, and while I know the theory well, designing DP algorithms for new problems is still difficult. \n\nThis is what i would really like now- A book or a website, which poses a problem which can be solved by dynamic programming. Also there is the solution with an explanation available, which i would like to see if i cant solve the problem even after butting my head at it for a few hours. Is there some resource that provides this sort of a thing for several categories of algorithms- like graph algorithms, dynamic programming, etc? \n\nP.S. I considered Topcoder, but the solutions there are not really appropriate for learning to implement efficient solutions. \n    ", "Answer": "\r\nAny of the ACM contest problem sets would probably work. Some places to find such:\n\n\nhttp://online-judge.uva.es/problemset/\nhttp://www.algorithmist.com/index.php/UVa_Volume_I\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming solution for 2d subset sum\r\n                \r\nSo i have this problem: given a set of two dimensional tuples on the form {x,y}, where all x and y are positive integers, decide if it is possible to take out a subset so that:\n\n```\n√( (∑x)² + (∑y)²) = A²\n```\n\n\nFor a positive integer A.\n\nExample, given \n```\n[{2,2},{1,4},{1,2}] and A = 5```\n\none solution is ```\n{2,2} and {1,2} since 3² + 4² = 5²```\n\n\nIt is allowed to reuse the same tuple multiple times. \n\nThe goal is th solve this with dynamic programming. I was looking at http://www.geeksforgeeks.org/dynamic-programming-subset-sum-problem/, a dynamic solution of a subset sum problem; however the difference here is that all the terms are squared and 2d, so i don't believe that method works\n    ", "Answer": "\r\nThere may be faster options, but a simple PD is:\n\nT(X, Y, i): Is it possible to achieve the ∑x = X and ∑y = Y using up to the i-th term?\n\n```\nT(0, 0, 0) = TRUE\nT(X, Y, i) = FALSE if X<0 or Y<0 or (i==0 and X!=0 and Y!=0)\nT(X, Y, i) = T(X-V[i].X, Y-V[i].Y, i) or T(X, Y, i-1)\n```\n\n\nThen, scan every pair (X, Y), to find one that X²+Y²=A² and T(X, Y, n) is true (where n is the size of the set).\n\nHere is a non-optimized recursive version just to prove the concept (in Python):\n\n```\ndef T(V, x, y, i):\n    if x==0 and y==0 and i==0: return []\n    if x<0 or y<0 or i<=0: return None\n\n    answer = T(V, x-V[i-1][0], y-V[i-1][1], i)\n    if answer is not None: return answer + [V[i-1]]\n    return T(V, x, y, i-1)\n\ndef solve(V, A):\n    for x in range(A):\n        for y in range(A):\n            if x*x+y*y==A*A:\n                answer = T(V, x, y, len(V))\n                if answer:\n                    return answer\n    return None\n\nprint(solve([(2,2),(1,4),(1,2)], 5))\n```\n\n\nIt prints one possible solution:\n\n```\n[(2, 2), (1, 2)]\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming Memoization in Haskell\r\n                \r\nThis is my first attempt at using (what I understand to be) dynamic programming. I'm trying to tackle this interesting problem: A* Admissible Heuristic for die rolling on grid\n\nThe ```\nq```\n function attempts to recurse backwards, keeping track of the orientation of the die (```\nvisited```\n is technically the next cell, but \"visited\" in terms of the recursion to prevent infinite back and forth loops). Although I'm not sure if the answer it provides is the best solution, it does seem to provide an answer, nonetheless.\n\nI'm hoping for ideas about how to implement some kind of memoization to speed it up -- I tried unsuccessfully to implement something like ```\nmemoized_fib```\n (seen here) with ```\nlookup```\n instead of ```\n!!```\n, mapping ```\nq```\n to a list of combinations of ```\n(i,j)```\n but got ```\nNothing```\n, no pun intended.\n\nHaskell code:\n\n```\nimport Data.List (minimumBy)\nimport Data.Ord (comparing)\n\nfst3 (a,b,c) = a\n\nrollDie die@[left,right,top,bottom,front,back] move\n  | move == \"U\" = [left,right,front,back,bottom,top]\n  | move == \"D\" = [left,right,back,front,top,bottom]\n  | move == \"L\" = [top,bottom,right,left,front,back]\n  | move == \"R\" = [bottom,top,left,right,front,back]\n\ndieTop die = die!!2\n\nleftBorder = max 0 (min startColumn endColumn - 1)\nrightBorder = min columns (max startColumn endColumn + 1)\ntopBorder = endRow\nbottomBorder = startRow\n\ninfinity = 6*rows*columns\n\nrows = 10\ncolumns = 10\n\nstartRow = 1\nstartColumn = 1\n\nendRow = 6\nendColumn = 6\n\ndieStartingOrientation = [4,3,1,6,2,5] --left,right,top,bottom,front,back\n\nq i j visited \n  | i < bottomBorder || i > topBorder \n    || j < leftBorder || j > rightBorder = (infinity,[1..6],[])\n  | i == startRow && j == startColumn    = (dieTop dieStartingOrientation,dieStartingOrientation,[])\n  | otherwise                            = (pathCost + dieTop newDieState,newDieState,move:moves)\n      where previous\n              | visited == (i, j-1) = zip [q i (j+1) (i,j),q (i-1) j (i,j)] [\"L\",\"U\"]\n              | visited == (i, j+1) = zip [q i (j-1) (i,j),q (i-1) j (i,j)] [\"R\",\"U\"]\n              | otherwise           = zip [q i (j-1) (i,j),q i (j+1) (i,j),q (i-1) j (i,j)] [\"R\",\"L\",\"U\"]\n            ((pathCost,dieState,moves),move) = minimumBy (comparing (fst3 . fst)) previous\n            newDieState = rollDie dieState move\n\nmain = putStrLn (show $ q endRow endColumn (endRow,endColumn))\n```\n\n    ", "Answer": "\r\nMy go-to tool for this kind of problem is the data-memocombinators library.\n\nTo use it, simply import ```\nData.MemoCombinators```\n, rename your ```\nq```\n to something else such as ```\nq'```\n (but leave the recursive calls as they are), and define a new ```\nq```\n like this:\n\n```\nq = M.memo3 M.integral M.integral (M.pair M.integral M.integral) q'\n```\n\n\n\n```\nmemo3```\n makes a memoizer for a three argument function, given memoizers for each argument.\n```\nintegral```\n is a simple memoizer for integral types.\n```\npair```\n combines two memoizers to make a memoizer for pairs of those types.\nFinally, we apply this memoizer to ```\nq'```\n to obtain a memoized version.\n\n\nAnd that's it. Your function is now memoized. Time to test it:\n\n```\n> :set +s\n> q endRow endColumn (endRow,endColumn)\n(35,[5,2,4,3,6,1],[\"R\",\"R\",\"R\",\"R\",\"R\",\"U\",\"U\",\"U\",\"U\",\"U\"])\n(0.01 secs, 516984 bytes)\n```\n\n\nFull code below:\n\n\n\n```\nimport Data.List (minimumBy)\nimport Data.Ord (comparing)\nimport qualified Data.MemoCombinators as M\n\nfst3 (a,b,c) = a\n\nrollDie die@[left,right,top,bottom,front,back] move\n  | move == \"U\" = [left,right,front,back,bottom,top]\n  | move == \"D\" = [left,right,back,front,top,bottom]\n  | move == \"L\" = [top,bottom,right,left,front,back]\n  | move == \"R\" = [bottom,top,left,right,front,back]\n\ndieTop die = die!!2\n\nleftBorder = max 0 (min startColumn endColumn - 1)\nrightBorder = min columns (max startColumn endColumn + 1)\ntopBorder = endRow\nbottomBorder = startRow\n\ninfinity = 6*rows*columns\n\nrows = 10\ncolumns = 10\n\nstartRow = 1\nstartColumn = 1\n\nendRow = 6\nendColumn = 6\n\ndieStartingOrientation = [4,3,1,6,2,5] --left,right,top,bottom,front,back\n\nq = M.memo3 M.integral M.integral (M.pair M.integral M.integral) q'\n  where\n    q' i j visited \n      | i < bottomBorder || i > topBorder || j < leftBorder || j > rightBorder = (infinity,[1..6],[])\n      | i == startRow && j == startColumn    = (dieTop dieStartingOrientation,dieStartingOrientation,[])\n      | otherwise                            = (pathCost + dieTop newDieState,newDieState,move:moves)\n      where previous\n              | visited == (i, j-1) = zip [q i (j+1) (i,j),q (i-1) j (i,j)] [\"L\",\"U\"]\n              | visited == (i, j+1) = zip [q i (j-1) (i,j),q (i-1) j (i,j)] [\"R\",\"U\"]\n              | otherwise           = zip [q i (j-1) (i,j),q i (j+1) (i,j),q (i-1) j (i,j)] [\"R\",\"L\",\"U\"]\n            ((pathCost,dieState,moves),move) = minimumBy (comparing (fst3 . fst)) previous\n            newDieState = rollDie dieState move\n\nmain = putStrLn (show $ q endRow endColumn (endRow,endColumn))\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "How to make correct function in dynamic programming [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 4 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI have the following problem in dynamic programming.\n\nA person has time machine and he can move in time either 1 year or 2. At the beginning he is at year 0 and he wants to reach year 100. Every step he does (1 or 2 years) he is paying some fixed fees. There is an array with 100 integers represents the fee he needs to pay if he went threw the specific year.\n\nI need to find the minimum amount the person can pay to go from year 0 to year 100 using dynamic programming.\n\nFrom what i have done so far i think that there should be something like \n\nminCost(i) = min{A[i-1], A[i-2]}\n\nand the base cases are years 1 and 2 which costs A[1], A[2] respectively. But i think this approach has more of greedy algorithm rather than dynamic programming. \n\nI saw the bin packing algorithm of dynamic programming and i understood it and the matrix that represents it.\n\nHow should the matrix of the shown problem above look like? \n\nAnd how should i build the function and the pseudo code for this problem?\n    ", "Answer": "\r\nYou are almost there.\n\nThink about how will you reach the i th year from i-1 th year and i-2 th year. There is a fee which you are forgetting to take into consideration.\n\nMinCostToReachYear(i) = min( MinCostToReachYear(i-1) + fee(i-1), MinCostToReachYear(i-2) + fee(i-2) )\n\nYou already know the base cases year 1 and year 2. Can you think of extrapolating with the use of a for loop or more easily with a recursive function which you already know as mentioned above? I leave it as an exercise for you.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Building Maximum Subarray Dynamic Programming solution from Recursive Solution\r\n                \r\nI managed to solve the maximum subarray problem with dynamic programming before considering the recursive implementation, however, since I struggle with more complicated dynamic programming problems I decided to work on fundamentals like seeing the recursive solution I'm implementing and then converting it to a dynamic one.\n\nThe dynamic programming solution I have is as follows:\n\n```\nint[] dp = new int[arr.length];\n\nif (arr.length == 0)\n{\n        return 0;\n}\n\n//initialize\ndp[0] = Math.max(0, arr[0]);\nint max = dp[0];\n\nfor (int i = 1; i < arr.length; i++)\n{\n    dp[i] = Math.max(0, arr[i] + dp[i - 1]);\n\n    if (dp[i] > max)\n    {\n        max = dp[i];\n    }\n}\n\nreturn max;\n```\n\n\nWhen I started thinking of recursive implementations I couldn't seem to find the correct one that leads to this logic though. The only recursive solution I've come up with is one that just splits the array into subsections:\n\n```\npublic static int maxsubarrayR(int[] arr, int start, int end)\n{\n    if (start == end)\n    {\n        return 0;\n    }\n    else\n    {\n        return Math.max(sum(arr, start, end), Math.max(maxsubarrayR(arr, start + 1, end), maxsubarrayR(arr, start, end - 1)));\n    }\n}\n```\n\n\nwhich involves an additional elementary sum method. Could someone show the recursive implementation that leads to the dynamic programming solution?\n    ", "Answer": "\r\nYour arr works like a global variable so we can only use it as parameter.\nYour dp is an auxiliar variable, a pivot for next iteration. \nYour max is a variable objective.\nAll working is done in:\n\n```\npivot = Math.max(0, arr[i] + pivot);\nif (pivot >= max){\n  max = pivot;\n}\n```\n\n\nSo you can try this:\n\n```\nprivate static int resolveR(int i, int max, int pivot, int[] arr){\n  //initialize\n  if (i == arr.length){\n    return max;\n  } else {\n    pivot = Math.max(0, arr[i] + pivot);\n    if (pivot >= max){\n        max = pivot;\n    }\n    return resolveR(i+1, max, pivot, arr);\n  }\n}\n```\n\n\nSee in action here: http://ideone.com/qvs1lJ\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Longest Palindromic Subsequence Dynamic Programming\r\n                \r\nThe link of the question is https://practice.geeksforgeeks.org/problems/longest-palindromic-subsequence/0 .\nMay I know whether my approach is a correct solution using Dynamic Programming . The\ncode is :\n```\n#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    //code\n    int t;\n    cin>>t;\n    while(t--){\n        string a;\n        cin>>a;\n        int l = a.length();\n        int dp[l][l] = {0};\n        for(int i = 0; i<l; i++){\n            for(int j = 0; j<l; j++){\n                if(i==j){\n                    dp[i][i] = 1;\n                }\n            }\n        }\n        for(int i = 1; i<l; i++){\n            int r = 0;\n            int c = i;\n            while(r<l and c<l){\n                if(a[r]==a[c]){\n                    dp[r][c] = dp[r+1][c-1]+2;\n                }\n                else{\n                    dp[r][c] = max(dp[r+1][c], dp[r][c-1]);\n                }\n                r++;\n                c++;\n            }\n        }\n        cout<<dp[0][l-1]<<endl;\n    }\n    return 0;\n}\n```\n\nwhere t is the number of test cases and a is the input string . We have to determine the length of the longest palindromic subsequence .\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "ArrayIndexOutOfBounds in binomial cofficient dynamic programming\r\n                \r\nI am trying to create a method that calculates (N choose R) using dynamic programming but I get an array out of bounds exception:\n\n```\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 7\n    at BinomialCoefficients.method5(BinomialCoefficients.java:127)\n    at BinomialCoefficients.main(BinomialCoefficients.java:50)\n```\n\n\nI am using a 2 dimensional array. Here is my code, \n\n```\nprotected static long method5(long lN, long lR)\n{\n    long lArray[][] = new long[(int) (lN+1)][(int) (lR+1)];\n\n    for(int i = 0; i <= lN; i++)\n    {\n        lArray[i][0] = 1;\n    }\n    for(int i = 0; i <= lN; i++)\n    {\n        lArray[i][i] = 1;\n    }\n    for(int i = 0; i <= lN; i++)\n    {\n        for(int j = i; j <= i; j++)\n        {\n            lArray[i][j] = lArray[i-1][j-1] + lArray[i-1][j];\n        }\n    }\n    /*for(int i = 0; i <= lN; i++)\n    {\n        for(int j = 0; j <= i; j++)\n        {\n            System.out.print(String.format(\"%5d\", lArray[i][j]));\n        }\n        System.out.println();\n    }*/\n    return lArray[(int) lN][(int) lR];\n}\n```\n\n\nCan somebody tell me what is wrong with it?\n    ", "Answer": "\r\nThis code looks suspicious\n\n```\nfor(int i = 0; i <= lN; i++)\n    {\n        lArray[i][i] = 1;\n    }\n```\n\n\nconsidering lArray was initialized using two potentially different values:\n\n```\nlong lArray[][] = new long[(int) (lN+1)][(int) (lR+1)];\n```\n\n\nI think you should have an inner loop here, such as: \n\n```\n   for(int i = 0; i <= lN; i++) {\n        for (int j=0; j<=lR; j++)    {\n            lArray[i][j] = 1;\n        }\n   }\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "What is the dynamic programming algorithm for finding a Hamiltonian cycle in a graph?\r\n                \r\nWhat is dynamic programming algorithm for finding a Hamiltonian cycle in an undirected graph?\nI have seen somewhere that there exists an algorithm with ```\nO(n.2^n)```\n time complexity.\n    ", "Answer": "\r\nThere is indeed an O(n2n) dynamic-programming algorithm for finding Hamiltonian cycles. The idea, which is a general one that can reduce many O(n!) backtracking approaches to O(n22n) or O(n2n) (at the cost of using more memory), is to consider subproblems that are sets with specified \"endpoints\".\n\nHere, since you want a cycle, you can start at any vertex. So fix one, call it ```\nx```\n. The subproblems would be: “For a given set ```\nS```\n and a vertex ```\nv```\n in ```\nS```\n, is there a path starting at ```\nx```\n and going through all the vertices of ```\nS```\n, ending at ```\nv```\n?” Call this, say, ```\nposs[S][v]```\n.\n\nAs with most dynamic programming problems, once you define the subproblems the rest is obvious: Loop over all the 2n sets S of vertices in any \"increasing\" order, and for each v in each such S, you can compute ```\nposs[S][v]```\n as:\n\n\n  poss[S][v] = (there exists some ```\nu```\n in S such that poss[S−{v}][u] is True and an edge ```\nu->v```\n exists)\n\n\nFinally, there is a Hamiltonian cycle iff there is a vertex ```\nv```\n such that an edge ```\nv->x```\n exists and ```\nposs[S][v]```\n is True, where ```\nS```\n is the set of all vertices (other than ```\nx```\n, depending on how you defined it).\n\nIf you want the actual Hamiltonian cycle instead of just deciding whether one exists or not, make ```\nposs[S][v]```\n store the actual ```\nu```\n that made it possible instead of just True or False; that way you can trace back a path at the end.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming with string keys in Haskell\r\n                \r\nBeing rather new to pure functional programming idiom, I can't get how to implement this case of dynamic programming. I have a function ```\nf :: String -> [String]```\n which is calculated recursively and want to memoize it. Input ```\nString```\ns can be arbitrary, so I guess that something like a lazy ```\nMap```\n is needed, but couldn't find any. How to implement such case in Haskell?\n    ", "Answer": "\r\nUse a memoizer library:\n\n```\nimport qualified Data.MemoCombinators as Memo\n\nf :: String -> [String]\nf = Memo.list Memo.char memof  -- because String = [Char]\n    where\n    memof x = ... f ...          -- call *f* recusively (not memof)\n```\n\n\nSee the documentation for more.  Also see MemoTrie\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Solutions to problems using dynamic programming or greedy methods?\r\n                \r\nWhat properties should the problem have so that I can decide which method to use dynamic programming or greedy method?\n    ", "Answer": "\r\nDynamic programming problems exhibit optimal substructure.  This means that the solution to the problem can be expressed as a function of solutions to subproblems that are strictly smaller.\n\nOne example of such a problem is matrix chain multiplication.\n\nGreedy algorithms can be used only when a locally optimal choice leads to a totally optimal solution.  This can be harder to see right away, but generally easier to implement because you only have one thing to consider (the greedy choice) instead of multiple (the solutions to all smaller subproblems).\n\nOne famous greedy algorithm is Kruskal's algorithm for finding a minimum spanning tree.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Coin Change Bottom Up Dynamic Programming\r\n                \r\nhttp://uva.onlinejudge.org/external/6/674.html I'm trying to solve that problem. Note, though, that it's not the minimum coin change problem, it asks me for the different number of ways to make N cents using 50, 25, 15, 10, 5 and 1 cent coins. It's fairly straightforward, so I made this function:\n\n```\nint count(int n, int m) // n is the N of the problem, m is the number of coin types and s[] is {1, 5, 10, 25, 50}\n{\n  if (n == 0)\n  {\n    return 1;\n  }\n\n  if (n < 0)\n  {\n    return 0;\n  }\n\n  if (m < 0 && n >= 1)\n  {\n    return 0;\n  }\n\n  return DP[n][m - 1] + DP[n - s[m]][m];\n}\n```\n\n\nFairly straightforward too is adding Dynamic Programming with memoization:\n\n```\nint count(int n, int m)\n{\n  if (n == 0)\n  {\n    return 1;\n  }\n\n  if (n < 0)\n  {\n    return 0;\n  }\n\n  if (m < 0 && n >= 1)\n  {\n    return 0;\n  }\n\n  if (DP[n][m - 1] == -1 || DP[n - s[m]][m] == -1)\n  {\n    return count(n, m - 1) + count(n - s[m], m);\n  }\n  else\n  {\n    return DP[n][m - 1] + DP[n - s[m]][m];\n  }\n}\n```\n\n\nHowever, none of these is fast enough - I need bottom up Dynamic Programming, but I am having difficulties coding it, even with some help from Algorithmist - http://www.algorithmist.com/index.php/Coin_Change.\n\n```\nvoid generate()\n{\n  for (i = 0; i < MAX; i++)\n  {\n    for (u = 0; u < m; u++)\n    {\n      if (i == 0)\n      {\n        DP[i][u] = 1;\n      }\n      else if (u == 0)\n      {\n        DP[i][u] = 0;\n      }\n      else if (s[u] > i)\n      {\n        DP[i][u] = DP[i][u - 1];\n      }\n      else\n      {\n        DP[i][u] = DP[i][u - 1] + DP[i - s[u]][u];\n      }\n    }\n  }\n}\n```\n\n\nI get 0 for every result for some reason, here's my full code:\n\n```\n#include <stdio.h>\n#include <string.h>\n\nusing namespace std;\n\n#define MAX 7490\n\nint s[] = {1, 5, 10, 25, 50}, m = 5, input, DP[MAX][5], i, u;\n\nint count(int n, int m)\n{\n  if (n == 0)\n  {\n    return 1;\n  }\n\n  if (n < 0)\n  {\n    return 0;\n  }\n\n  if (m < 0 && n >= 1)\n  {\n    return 0;\n  }\n\n  if (DP[n][m - 1] == -1 || DP[n - s[m]][m] == -1)\n  {\n    return count(n, m - 1) + count(n - s[m], m);\n  }\n  else\n  {\n    return DP[n][m - 1] + DP[n - s[m]][m];\n  }\n}\n\nvoid generate()\n{\n  for (i = 0; i < MAX; i++)\n  {\n    for (u = 0; u < m; u++)\n    {\n      if (i == 0)\n      {\n        DP[i][u] = 1;\n      }\n      else if (u == 0)\n      {\n        DP[i][u] = 0;\n      }\n      else if (s[u] > i)\n      {\n        DP[i][u] = DP[i][u - 1];\n      }\n      else\n      {\n        DP[i][u] = DP[i][u - 1] + DP[i - s[u]][u];\n      }\n    }\n  }\n}\n\nint main()\n{\n  memset(DP, -1, sizeof DP);\n  generate();\n\n  while (scanf(\"%d\", &input) != EOF)\n  {\n    //printf(\"%d\\n\", count(input, 4));\n    printf(\"%d\\n\", DP[input][4]);\n  }\n\n  return 0;\n}\n```\n\n    ", "Answer": "\r\nYou did the mistake here:\n\n```\nelse if (u == 0)\n{\n   DP[i][u] = 0;\n}\n```\n\n\nIt should be ```\nDP[i][u]=1```\n because you can produce any value ```\ni```\n using 1 cent coin in 1 possible way. i.e. to take 5 cent you will take 5 one cent coins which is one way to make 5-cent in total.\n\n-----\n\nBtw, in you 1st approach in count method did you have this:\n\n```\nif (DP[n][m - 1] == -1 || DP[n - s[m]][m] == -1)\n{\n  return count(n, m - 1) + count(n - s[m], m);\n}\n```\n\n\nOr this:\n\n```\nif (DP[n][m - 1] == -1 || DP[n - s[m]][m] == -1)\n{\n    return DP[n][m] = count(n, m - 1) + count(n - s[m], m);\n}\n```\n\n\nIf you did not memoize an already calculated result then this memoization check ```\nif (DP[n][m - 1] == -1 || DP[n - s[m]][m] == -1)```\n will never work, which might be the cause of your 1st approach to be too slow :-?\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Memoizing finite horizon dynamic programming\r\n                \r\nI will try asking my questions here:\n\nSo I am trying to program a simple finite horizon dynamic programming problem.\n\nI'm trying to use memoization to speed-up computation time. \n\n```\nusing Optim\n\nV2dict = Dict()\n\nfunction V2(t, K)\n    if t >= T\n        return 0.0\n    else\n        if haskey(V2dict, (t, K))\n            return V2dict[t, K]\n        else\n            opt = optimize(K′ -> -(log(K - K′) + β * V2(t+1, K′)), eps(), K, iterations = 100_000)\n            V2dict[t, K] = Optim.minimum(opt)\n            return V2dict[t, K]\n        end\n    end\nend\n\nT = 6\nβ = 0.95\n\n@time V2(1, 100)\n#-6.333197046721626\n# 32.262246 seconds (1.36 G allocations: 21.515 GiB, 14.51% gc time)\n```\n\n\nI have two questions:\n\nIs that how memoization is supposed to be implemented?\n\nWhy is ```\nV2dict```\n saving many keys for each ```\nt```\n? I am only trying to save the optimal values for ```\nV2```\n.\n\n```\nV2dict\nDict{Any,Any} with 1799 entries:\n  (4, 3.32187e-5)  => -24.3578\n  (5, 5.22198e-15) => 32.9762\n  (5, 4.50844e-16) => 36.4949\n  (4, 8.69678e-5)  => -25.3202\n  (5, 2.6052e-12)  => 26.6737\n  (5, 2.19599e-9)  => 19.9366\n  (5, 7.22726e-16) => 35.7118\n  (5, 3.94054e-8)  => 17.0494\n  (5, 0.118624)    => 2.1318\n  (4, 1.3312e-14)  => -2.68559\n  (4, 0.000596086) => -27.245\n  (3, 4.50844e-16) => 35.5843\n  (5, 6.72888e-16) => 35.8166\n  (5, 0.0453104)   => 3.09422\n  ⋮                => ⋮\n```\n\n    ", "Answer": "\r\nIt looks like a reasonable implementation of memoization for the ```\nV2```\n function.\n\nThe output of ```\nV2```\n depends not on just the first parameter ```\nt```\n but also on the second parameter ```\nK```\n. So to memoize the output of ```\nV2```\n, the dictionary key has to include both ```\nt```\n and ```\nK```\n, which it does. But that means you're going to get multiple keys with the same ```\nt```\n value, because ```\nt```\n is not the whole key; the key is ```\n(t, K)```\n.\n\nIt may be that you're not trying to memoize the ```\nV2```\n function but rather just construct a dictionary of ```\nt```\n values to the lowest value of ```\nV2```\n found for that ```\nt```\n (across all values of ```\nK```\n). If that's the case then you can just have the dictionary key be ```\nt```\n by itself and replace the existing value whenever you discover a \"better\" one.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Minimum-size vertex cover of tree: Dynamic Programming Formulation\r\n                \r\nI'm trying to understand how to formulate the problem of finding a minimum-size vertex cover of a tree as a dynamic programming problem and am having some trouble. To me the non-dynamic programming formulation involving a depth-first search makes the most intuitive sense. Essentially this involves doing a DFS to the leaf nodes, including their parent nodes in the minimum size vertex cover, and repeating up to the root. The pseudocode is like this:\n\n```\n// DFS based solution\nfind_minimum_vertex_cover_dfs(root) {\n    // leaf nodes aren't in minimum size vertex cover\n    if (root == NULL || isLeafNode(root)) {\n        return;\n    }\n\n    for (each child node of root) {\n        find_minimum_vertex_cover_dfs(child node);\n        // child isn't in minimum size vertex cover so need to cover edge\n        // from current root to child by including current root\n        if (!isInMinCover(child node)) {\n            include root in minimum vertex cover;\n        }\n    }\n}\n```\n\n\nThe dynamic programming formulation that I got from here is as follows:\n\n```\nDynamicVC(root):\n    for each child c:\n        Best[c][0], Best[c][1] = DynamicVC(c)\n\n    withoutRoot = sum over all c of Best[c][1]\n    withRoot = 1 + sum over all c of min(Best[c][0], Best[c][1])\n\n    return (withoutRoot, withRoot)\n```\n\n\nI think I understand the idea of the subproblems being computing the minimum size vertex cover for the subtree rooted at each vertex including that vertex in the cover and excluding that vertex from the cover. I have two questions:\n\n\nIt seems most natural to me to exploit the fact that the leaf nodes will never be in the minimum vertex cover and hence use the DFS-based solution. Why would one use the dynamic programming solution to this problem?\nI'm used to building the dynamic programming matrix from the bottom up iteratively without actually using recursion. In this case, however, since I need to start by computing the solutions for the leaf nodes traversing the tree using recursion to build the dynamic programming matrix from the leaf nodes up seems most intuitive to me. It just seems odd to me because all the dynamic programming problems I've worked on to this point have avoided the need for this. Am I missing something here?\n\n\nEdit: As I thought about it some more maybe what was confusing me was that in this case doing a DFS on the tree recursively is what is more familiar to me. I've been doing a bunch of dynamic programming problems but this is the first one involving tree/graph traversal, and in the other problems I can just use some loops to compute the larger and larger subproblems. I suppose I could make the dynamic programming version more familiar to me by using an explicit stack and doing the tree traversal that way as opposed to via recursion. Does that make sense?\n    ", "Answer": "\r\n1: There is no really good reason why. It just works so why not use it. For me the DP solution you've shown is more intuitive than the recursive one.\n\n2: Dynamic programming is about subproblems memoization of a recursive solution. Coming up with a DP algorithm often involves defining a recursion first and then adding memoization to it. A recursive solution can automatically be transformed into a DP: just create a global hash table of type ```\n(subproblem id -> result)```\n and at the beginning of the recursive call check if the hashmap already contains a result for the given subproblem, if so then return it right away otherwise compute it and put it into the hashmap. Such approach will often be as fast as a bottom-up approach you mentioned.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "What can be a newbie explanation for a dynamic programming?\r\n                \r\nI am trying to learn the basics of Dynamic Programming (DP), and went through some the online resources i could get, such as...\n\n\nWhat is dynamic programming?\nGood examples, articles, books for understanding dynamic programming\nTutorial for Dynamic Programming \n Dynamic Programming – From Novice to Advanced -- (I can't understand it properly (i.e. how to approach a problem using DP))\n\n\nand till now i get to understand that\n\n\n  A dynamic problem is almost same that of\n  recursion with just a difference (which gives it the power it is know\n  for)\n  \n  i.e. storing the value or solution we got and using it again to find next solution\n\n\nFor Example:\n\nAccording to an explanation from codechef\n\nProblem : Minimum Steps to One\n\nProblem Statement: On a positive integer, you can perform any one of the following 3 steps. \n\n\nSubtract 1 from it. ( n = n - 1 )\nIf its divisible by 2, divide by 2. ( if n % 2 == 0 , then n = n / 2  )\nIf its divisible by 3, divide by 3. ( if n % 3 == 0 , then n = n / 3  )\n\n\nNow the question is, given a positive integer n, find the minimum number of steps that takes n to 1\n\neg:\n\n\nFor n = 1 , output: 0\nFor n = 4 , output: 2  ( 4  /2 = 2  /2 = 1 )\nFor n = 7 , output: 3  (  7  -1 = 6   /3 = 2   /2 = 1 )\n\nint memo[n+1]; // we will initialize the elements to -1 ( -1 means, not solved it yet )\n\n\nTop-Down Approach for the above problem\n\n```\nint getMinSteps ( int n ) {\n    if ( n == 1 )  return 0;\n    if( memo[n] != -1 ) return memo[n];\n    int r = 1 + getMinSteps( n - 1 );\n    if( n%2 == 0 )   r  =  min( r , 1 + getMinSteps( n / 2 ) );\n    if( n%3 == 0 )   r  =  min( r , 1 + getMinSteps( n / 3 ) );\n    memo[n] = r ;  // save the result. If you forget this step, then its same as plain recursion.\n    return r;\n}\n```\n\n\nAm i correct in understanding the dp, or can anyone explain it in a better and easy way, so that i can learn it and can approach a problem with Dynamic programming.\n    ", "Answer": "\r\nThe Fibonacci sequence example from wikipedia gives a good example.\n\nDynamic programming is an optimization technique that transforms a potentially exponential recursive solution into a polynomial time solution assuming the problem satisfies the principle of optimality. Basically meaning you can build an optimal solution from optimal sub-problems.\nAnother important characteristic of problems that are tractable with dynamic programming is that they are overlapping. If those problems are broken down into sub-problems that are repetitive, the same solution can be reused for solving those sub problems.\nA problem with optimal substructure property and overlapping subproblems, dynamic programming is a potentially efficient way to solve it.\n\nIn the example you can see that recursive version of the Fibonacci numbers would grow in a tree like structure, suggesting an exponential explosion.\n\n```\nfunction fib(n)\n       if n <=1 return n\n       return fib(n − 1) + fib(n − 2)\n```\n\n\nSo for ```\nfib(5)```\n you get:\n\n```\nfib(5)\nfib(4) + fib(3)\n(fib(3) + fib(2)) + (fib(2) + fib(1))\n```\n\n\nAnd so on in a tree like fashion.\n\nDynamic programming lets us build the solution incrementally using optimal sub-problems in polynomial time. This is usually done with some form of record keeping such as a table.\nNote that there are repeating instances of sub problems, i.e. calculating fib(2) one time is enough.\n\nAlso from Wikipedia, a dynamic programming solution\n\n```\nfunction fib(n)\n   if n = 0\n       return 0\n   else\n       var previousFib := 0, currentFib := 1\n       repeat n − 1 times // loop is skipped if n = 1\n           var newFib := previousFib + currentFib\n           previousFib := currentFib\n           currentFib  := newFib\n   return currentFib\n```\n\n\nHere the solution is built up from ```\npreviousFib```\n and ```\ncurrentFib```\n which are set initially. The ```\nnewFib```\n is calculated from the previous steps in this loop. ```\npreviousFib```\n and ```\ncurrentFib```\n represent our record keeping for previous sub-problems.\n\nThe result is a polynomial time solution (O(n) in this case) for a problem whose recursive formulation would have been exponential (O(2^n) in this case).\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "What is the difference between bottom-up and top-down?\r\n                \r\nThe bottom-up approach (to dynamic programming) consists in first looking at the \"smaller\" subproblems, and then solve the larger subproblems using the solution to the smaller problems.\n\nThe top-down consists in solving the problem in a \"natural manner\" and check if you have calculated the solution to the subproblem before.\n\nI'm a little confused. What is the difference between these two?\n    ", "Answer": "\r\n\n  rev4: A very eloquent comment by user Sammaron has noted that, perhaps, this answer previously confused top-down and bottom-up. While originally this answer (rev3) and other answers said that \"bottom-up is memoization\" (\"assume the subproblems\"), it may be the inverse (that is, \"top-down\" may be \"assume the subproblems\" and \"bottom-up\" may be \"compose the subproblems\"). Previously, I have read on memoization being a different kind of dynamic programming as opposed to a subtype of dynamic programming. I was quoting that viewpoint despite not subscribing to it. I have rewritten this answer to be agnostic of the terminology until proper references can be found in the literature. I have also converted this answer to a community wiki. Please prefer academic sources. List of references: {Web: 1,2} {Literature: 5}\n\n\nRecap\n\nDynamic programming is all about ordering your computations in a way that avoids recalculating duplicate work. You have a main problem (the root of your tree of subproblems), and subproblems (subtrees). The subproblems typically repeat and overlap.\n\nFor example, consider your favorite example of Fibonnaci. This is the full tree of subproblems, if we did a naive recursive call:\n\n```\nTOP of the tree\nfib(4)\n fib(3)...................... + fib(2)\n  fib(2)......... + fib(1)       fib(1)........... + fib(0)\n   fib(1) + fib(0)   fib(1)       fib(1)              fib(0)\n    fib(1)   fib(0)\nBOTTOM of the tree\n```\n\n\n(In some other rare problems, this tree could be infinite in some branches, representing non-termination, and thus the bottom of the tree may be infinitely large. Furthermore, in some problems you might not know what the full tree looks like ahead of time. Thus, you might need a strategy/algorithm to decide which subproblems to reveal.)\n\n\n\nMemoization, Tabulation\n\nThere are at least two main techniques of dynamic programming which are not mutually exclusive:\n\n\nMemoization - This is a laissez-faire approach: You assume that you have already computed all subproblems and that you have no idea what the optimal evaluation order is. Typically, you would perform a recursive call (or some iterative equivalent) from the root, and either hope you will get close to the optimal evaluation order, or obtain a proof that you will help you arrive at the optimal evaluation order. You would ensure that the recursive call never recomputes a subproblem because you cache the results, and thus duplicate sub-trees are not recomputed.\n\n\nexample: If you are calculating the Fibonacci sequence ```\nfib(100)```\n, you would just call this, and it would call ```\nfib(100)=fib(99)+fib(98)```\n, which would call ```\nfib(99)=fib(98)+fib(97)```\n, ...etc..., which would call ```\nfib(2)=fib(1)+fib(0)=1+0=1```\n. Then it would finally resolve ```\nfib(3)=fib(2)+fib(1)```\n, but it doesn't need to recalculate ```\nfib(2)```\n, because we cached it.\nThis starts at the top of the tree and evaluates the subproblems from the leaves/subtrees back up towards the root.\n\nTabulation - You can also think of dynamic programming as a \"table-filling\" algorithm (though usually multidimensional, this 'table' may have non-Euclidean geometry in very rare cases*). This is like memoization but more active, and involves one additional step: You must pick, ahead of time, the exact order in which you will do your computations. This should not imply that the order must be static, but that you have much more flexibility than memoization.\n\n\nexample: If you are performing fibonacci, you might choose to calculate the numbers in this order: ```\nfib(2)```\n,```\nfib(3)```\n,```\nfib(4)```\n... caching every value so you can compute the next ones more easily. You can also think of it as filling up a table (another form of caching).\nI personally do not hear the word 'tabulation' a lot, but it's a very decent term. Some people consider this \"dynamic programming\".\nBefore running the algorithm, the programmer considers the whole tree, then writes an algorithm to evaluate the subproblems in a particular order towards the root, generally filling in a table.\n*footnote: Sometimes the 'table' is not a rectangular table with grid-like connectivity, per se. Rather, it may have a more complicated structure, such as a tree, or a structure specific to the problem domain (e.g. cities within flying distance on a map), or even a trellis diagram, which, while grid-like, does not have a up-down-left-right connectivity structure, etc. For example, user3290797 linked a dynamic programming example of finding the maximum independent set in a tree, which corresponds to filling in the blanks in a tree.\n\n\n\n(At it's most general, in a \"dynamic programming\" paradigm, I would say the programmer considers the whole tree, then writes an algorithm that implements a strategy for evaluating subproblems which can optimize whatever properties you want (usually a combination of time-complexity and space-complexity). Your strategy must start somewhere, with some particular subproblem, and perhaps may adapt itself based on the results of those evaluations. In the general sense of \"dynamic programming\", you might try to cache these subproblems, and more generally, try avoid revisiting subproblems with a subtle distinction perhaps being the case of graphs in various data structures. Very often, these data structures are at their core like arrays or tables. Solutions to subproblems can be thrown away if we don't need them anymore.)\n\n[Previously, this answer made a statement about the top-down vs bottom-up terminology; there are clearly two main approaches called Memoization and Tabulation that may be in bijection with those terms (though not entirely). The general term most people use is still \"Dynamic Programming\" and some people say \"Memoization\" to refer to that particular subtype of \"Dynamic Programming.\" This answer declines to say which is top-down and bottom-up until the community can find proper references in academic papers. Ultimately, it is important to understand the distinction rather than the terminology.]\n\n\n\nPros and cons\n\nEase of coding\n\nMemoization is very easy to code (you can generally* write a \"memoizer\" annotation or wrapper function that automatically does it for you), and should be your first line of approach. The downside of tabulation is that you have to come up with an ordering.\n\n*(this is actually only easy if you are writing the function yourself, and/or coding in an impure/non-functional programming language... for example if someone already wrote a precompiled ```\nfib```\n function, it necessarily makes recursive calls to itself, and you can't magically memoize the function without ensuring those recursive calls call your new memoized function (and not the original unmemoized function))\n\nRecursiveness\n\nNote that both top-down and bottom-up can be implemented with recursion or iterative table-filling, though it may not be natural.\n\nPractical concerns\n\nWith memoization, if the tree is very deep (e.g. ```\nfib(10^6)```\n), you will run out of stack space, because each delayed computation must be put on the stack, and you will have 10^6 of them.\n\nOptimality\n\nEither approach may not be time-optimal if the order you happen (or try to) visit subproblems is not optimal, specifically if there is more than one way to calculate a subproblem (normally caching would resolve this, but it's theoretically possible that caching might not in some exotic cases). Memoization will usually add on your time-complexity to your space-complexity (e.g. with tabulation you have more liberty to throw away calculations, like using tabulation with Fib lets you use O(1) space, but memoization with Fib uses O(N) stack space).\n\nAdvanced optimizations\n\nIf you are also doing a extremely complicated problems, you might have no choice but to do tabulation (or at least take a more active role in steering the memoization where you want it to go). Also if you are in a situation where optimization is absolutely critical and you must optimize, tabulation will allow you to do optimizations which memoization would not otherwise let you do in a sane way. In my humble opinion, in normal software engineering, neither of these two cases ever come up, so I would just use memoization (\"a function which caches its answers\") unless something (such as stack space) makes tabulation necessary... though technically to avoid a stack blowout you can 1) increase the stack size limit in languages which allow it, or 2) eat a constant factor of extra work to virtualize your stack (ick), or 3) program in continuation-passing style, which in effect also virtualizes your stack (not sure the complexity of this, but basically you will effectively take the deferred call chain from the stack of size N and de-facto stick it in N successively nested thunk functions... though in some languages without tail-call optimization you may have to trampoline things to avoid a stack blowout).\n\n\n\nMore complicated examples\n\nHere we list examples of particular interest, that are not just general DP problems, but interestingly distinguish memoization and tabulation. For example, one formulation might be much easier than the other, or there may be an optimization which basically requires tabulation:\n\n\nthe algorithm to calculate edit-distance[4], interesting as a non-trivial example of a two-dimensional table-filling algorithm\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "What is dynamic programming? (in solving technique)\r\n                \r\nI have a problem to solve like this.\nthere is time interval, and each time interval can do work once. (I called this, 'task')\nif there (4, 8), (1, 3), (8, 10), (0, 3), (6, 8) time interval and each interval means (start time, deadline).\nthis is one case idle time is three (an idle time is between tasks)\n\nBut I want to minimize idle time\n\nHow to solve these like problem by problem solving?\nmy friend suggests 'dynamic programming' which is one of problem solving technique, I don't know what it is.\nPlease help me, what is dynamic programming and examples by this problem.\n    ", "Answer": "\r\nMaybe your friend means to find T1, T2, etc. with idle time in between and try to shorten this? In general dp means to eliminate variables that are unecessary for the solution thus speed up the overall compute time. Here is a good link: difference between back tracking and Dynamic programming\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Map and Dynamic Programming Updating\r\n                \r\nThe problem I am given is\n\nA child is running up a staircase with n steps,\nand can hop either 1 step, 2 steps, or 3 steps at a time.\nImplement a method to count how many possible ways the child can run up the stairs.\n\nhttp://play.golang.org/p/bpjIkMm9jH\n\n```\npackage main\n\nimport \"fmt\"\n\nfunc CountWaysDP(n int, mm map[int]int) int {\n  if n < 0 {\n    return 0\n  } else if n == 0 {\n    return 1\n  } else if mm[n] > -1 {\n    return mm[n]\n  } else {\n    mm[n] = CountWaysDP(n-1, mm) +\n      CountWaysDP(n-2, mm) +\n      CountWaysDP(n-3, mm)\n    return mm[n]\n  }\n}\n\nfunc main() {\n  mm := make(map[int]int)\n  fmt.Println(CountWaysDP(10, mm), mm)\n}\n```\n\n\nThis just gives me 0 map[]. It turns out that the dynamic recursion ends at the following line:\n\n```\nelse if mm[n] > -1\n```\n\n\nThen how would I use dynamic programming to solve this problem? This is exactly the same solution as in Cracking the coding interview....\n    ", "Answer": "\r\nYou need to compare with 0:\n\n```\nelse if mm[n] > 0\n```\n\n\nmap returns 0 when getting values for non existing keys.\n\nYou can also use an array/slice instead of map as you know that the map keys are always from 1 to N\n\nYou can solve this without recursion as well:\n\n```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    n := 10\n    mm := make([]int, n+1)\n    mm[0] = 1\n    for i := 1; i <= n; i++ {\n        for k := 1; k <= 3; k++ {\n            if i-k >= 0 {\n                mm[i] += mm[i-k]\n            }\n        }\n    }\n    fmt.Println(mm)\n    fmt.Println(mm[n])\n}\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming resources in C?\r\n                \r\nI'll be writing the online Google test tomorrow as a fresher. Apparently, they definitely ask one problem on Dynamic Programming?  \n\nDoes anyone know of a good resource for collection of DP problems in C along with solutions? I know what DP is & have used it on an occasion or twice. However I feel to crack a DP problem in test, prior practice of typical problems will make it easier to approach.\n\nAny good resources or problem sets with solutions in C will be highly appreciated. Thanks.\n    ", "Answer": "\r\nOkay, so I really hope this doesn't count as \"shameless self-promotion,\" since all of these links are to code snippets I've posted on my personal site.  If this is inappropriate, please let me know and I can take them down.\n\nHere are a few fun DP problems that are pretty much classics:\n\n\nMinimum edit distance: Given two strings A and B, find the shortest number of edits (insertions, deletions, or substitutions) necessary to convert A into B.  This is called the Levenshtein distance.  (My solution)\nOptimal sequence alignment: Given two strings A and B, find the minimum number of gaps that must be inserted into the sequence to align A and B.  This is called the Needleman-Wunsch algorithm. (My solution)\nSingle-source shortest paths: Given a directed graph G and a single node s, find the lengths of the shortest paths from s to each other node in the graph, assuming edges can be positive or negative but that no cycles exist.  This is the Bellman-Ford algorithm. (My solution)\nAll-pairs shortest paths: Given a directed graph G, find the minimum distances between all pairs of nodes.  This is the Floyd-Warshall algorithm. (My solution)\n\n\nHopefully this is somewhat useful, and best of luck tomorrow!\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Rewrite Resurrence Function to the Idea of Dynamic Programming\r\n                \r\nCan someone help me?\nRewrite the pseudo-code of Count(n) using the idea of Dynamic Programming. And determine the Time Complexity.\n\n```\nTest(n)\n   If n=1 return 1\n   Tn=0\n   For k=1 to n-1\n      Tn = Tn + Test(k) * Test(n-k)\n   Return Tn\n```\n\n    ", "Answer": "\r\nAdd Memoization to get a DP solution from a recursion one:\n\nPython Code:\n\n```\nd = {}\ndef test(n):\n    if n == 1:\n        return 1\n    if d.get(n) is not None:\n        return d[n]\n    ans = 0\n    for k in range(1, n):\n        ans += test(k) * test(n - k)\n    d[n] = ans\n    return ans\n```\n\n\nYou can check(It's Catalan numbers indeed, learn more about it in OEIS):\n\n```\nfor i in range(1, 10):\n    print str(i) + ' ' + str(test(i))\n```\n\n\nOutput:\n\n```\n1 1\n2 1\n3 2\n4 5\n5 14\n6 42\n7 132\n8 429\n9 1430\n```\n\n\nTime Complexity is ```\nO(n^2)```\n. Because calculate a state is ```\nO(n)```\n(for k from 1 to n - 1), and we need calculate n state in total to get ```\ntest(n)```\n. \n\nIn fact, we can achieve a O(n) solution since it's Catalan numbers...\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Matrix multiplication using Dynamic Programming\r\n                \r\nI am trying to understand the below algorithm for matrix multiplication using dynamic programming. \n\nIf ```\nmi, j```\n is the minimum cost of evaluating the product ```\nMi × ... × Mj```\n then:\n\n\nmi, j = 0, if i = j, and\nmi, j = MIN, i ≤ k < j { mi,k + mk+1,j + ri-1rkrj }, if i < j. \n\n\nAlgorithm:\n\n```\nfor i := 1 to n do\n   mi,i := 0\nfor length := 1 to n-1 do\n   for i := 1 to n-length do\n      j := i + length\n      mi,j = MINi≤k<j{mi,k + mk+1,j + ri-1rkrj}\n```\n\n\nAny clue on how it actually works or if somebody can point me to a good reference for it.\n    ", "Answer": "\r\nThe algorithm finds the lowest cost to multiply a chain of matrices.\n\nGiven a matrix ```\nA```\n with ```\np```\n rows and ```\nq```\n columns, and a matrix ```\nB```\n with ```\nq```\n rows and ```\nr```\n columns, the standard matrix multiplication ```\nA·B```\n takes ```\np*q*r```\n multiplications - for each of the ```\np×r```\n entries of the product, ```\nq```\n multiplications between the elements of the corresponding row of ```\nA```\n and the corresponding column of ```\nB```\n.\n\nNow, matrix multiplication is associative, so you can parenthesize the product\n\n```\nM_1 · M_2 · … · M_n\n```\n\n\nas you like, it will always yield the same result.\n\nNow, let ```\nr_0```\n be the number of rows of ```\nM_1```\n and ```\nr_i```\n the number of columns of ```\nM_i```\n (which must also be the number of rows of ```\nM_(i+1)```\n for the product to be defined).\n\nThen ```\nM_i · … · M_k```\n is an ```\nr_(i-1)×r_k```\n matrix, and ```\nM_(k+1) · … · M_j```\n is an ```\nr_k×r_j```\n matrix. So if the product ```\nM_i · … · M_j```\n is computed by first computing the products ```\nM_i · … · M_k```\n and ```\nM_(k+1) · … · M_j```\n and then multiplying the two resulting matrices, the total cost of the multiplication is\n\n```\nc_{i,k} + c_{k+1,j} + r_(i-1)×r_k×r_j\n```\n\n\nwhere ```\nc_{i,k}```\n is the cost of the chosen way to compute ```\nM_i · … · M_k```\n (and analogous for ```\nc_{k+1,j}```\n).\n\nNow, the minimal cost of evaluating ```\nM_i · … · M_j```\n by splitting after ```\nM_k```\n is then obviously achieved if the two sub-products are evaluated with minimal cost.\n\nAnd the minimal cost of evaluating ```\nM_i · … · M_j```\n is found by computing the minimal costs for all possible splits, so\n\n```\nm_{i,j} = min { m_{i,k} + m_{k+1,j} + r_(i-1)×r_k×r_j : i <= k < j }\n```\n\n\nfor ```\ni < j```\n.\n\nThe minimal cost for the complete product is then computed by first computing the minimal costs for sub-products involving only two matrices [where there's only one possible split], then for sub-products using three matrices, for which we need the minimal costs for the sub-products of only two matrices - that's where parenthesizing comes into play, and usually makes a difference - then four etc. until the minimal cost for the total computation is found.\n\nTo find the parenthesizing that yields the lowest cost, you can search the array of minimal costs tolocate the splitting that yields it [and then for the two sub-products, etc.], but it would be better to store the information of where to split for the minimal cost alongside the minimal cost in the ```\nm```\n array.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming - Finding Maximum Profit\r\n                \r\n\n\n\n\nI'm new to dynamic programming. So, I'm suppose to find the max profit. I don't think what I'm doing is correct. I don't understand what the k conversions is for. In the given example there are given 3 currencies, so therefore there are 3 conversion. Can someone please give me more ideas about how to solve this?\n    ", "Answer": "\r\nFirst, let's think about how many currency transactions there are.  If you have three currencies (let's call them pounds, francs, and marks) you have six possible types of currency transactions:  Pounds to marks, marks to pounds, pounds to francs, francs to pounds, francs to marks, and marks to francs. \n\nBut in terms of your problem, when they say you have k currency transactions, what they mean is that you are allowed to start with some currency and make a sequence of k currency transactions.  Your job is to figure out which k transactions will result in the most profit. So for instance, if you have three currencies, but k=1 and you're told to start with pounds, your task is easy:  Decide whether pounds to francs is better, or pounds to marks is better.  If k=2, you have more choices, etc.\n\nIt might be helpful to think of this as a weighted directed graph, where the currencies are nodes, and the arcs are weighted by the exchange rates.  Then you can think of the problems in terms of finding the most profitable path through the graph, of length k, starting at node i.  \n\nThinking about it that way will also show you the problem in your expression, which should look like the path along a graph, not what you have.  You might also think about using some properties of logarithms, to turn this from a problem about multiplication into a problem about addition.\n\nAnd finally, dynamic programming on graph structures usually involves building a solution of length n+1 out of a solution of length n, so you should probably start by thinking about the smallest possible problem, and how it relates to the second smallest problem, etc. \n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming - Finding Maximum Profit\r\n                \r\n\n\n\n\nI'm new to dynamic programming. So, I'm suppose to find the max profit. I don't think what I'm doing is correct. I don't understand what the k conversions is for. In the given example there are given 3 currencies, so therefore there are 3 conversion. Can someone please give me more ideas about how to solve this?\n    ", "Answer": "\r\nFirst, let's think about how many currency transactions there are.  If you have three currencies (let's call them pounds, francs, and marks) you have six possible types of currency transactions:  Pounds to marks, marks to pounds, pounds to francs, francs to pounds, francs to marks, and marks to francs. \n\nBut in terms of your problem, when they say you have k currency transactions, what they mean is that you are allowed to start with some currency and make a sequence of k currency transactions.  Your job is to figure out which k transactions will result in the most profit. So for instance, if you have three currencies, but k=1 and you're told to start with pounds, your task is easy:  Decide whether pounds to francs is better, or pounds to marks is better.  If k=2, you have more choices, etc.\n\nIt might be helpful to think of this as a weighted directed graph, where the currencies are nodes, and the arcs are weighted by the exchange rates.  Then you can think of the problems in terms of finding the most profitable path through the graph, of length k, starting at node i.  \n\nThinking about it that way will also show you the problem in your expression, which should look like the path along a graph, not what you have.  You might also think about using some properties of logarithms, to turn this from a problem about multiplication into a problem about addition.\n\nAnd finally, dynamic programming on graph structures usually involves building a solution of length n+1 out of a solution of length n, so you should probably start by thinking about the smallest possible problem, and how it relates to the second smallest problem, etc. \n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Coin change,dynamic programming revisited\r\n                \r\nI am having tough time in understanding the logic behind this problem,\nThis is classical Dynamic Programming Problem\n\n```\n     Coin Change is the problem of finding the number \n     of ways of making changes for a particular amount of cents, n, \n     using a given set of denominations d1,d2,..dm;\n```\n\n\nI know how the recursion works,Like taking the mth coin or not.But I don't understand what does '+' do between the two states.\n\nFor eg\n\n```\n        C(N,m)=C(N,m-1)+C(N-dm,m)\n                       ^\n                       |\n```\n\n\nQuestion might be stupid but I still would like to know so that I can have better understanding.Thanks\n    ", "Answer": "\r\nWell , you haven't written your state right!\nCoin Change:\n\nLet C(i,j) represents the number of ways to form j as a sum using only i coins (from i to 1).\n\nNow to get a recursive function you have to define transitions or change in state or may be just expressing the given expression in the terms of lower values!!\n\nThere are 2 independent ways in which I can represent this state that are\n\n1) Lets pick up the i th coin , Then what happens ? I need denomination j-Denomination[i] with i-1 coins if repetition is not allowed .\ni.e. C(i,j)= C(i-1,j-Denominations[i])\n\nBut wait , we are missing some ways i.e. when we do not take the current coin\n\n2) C(i,j)=C(i-1,j)\n\nNow as both of them are independent and exhaustive , These both of these state makes up the total number of ways!!!\n\nC(i,j)=C(i-1,j)+C(i-1,j-Denominations[i])\n\nI will leave the recurrence when repetition allowed for you!\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Discrete Knapsack Dynamic Programming Python3\r\n                \r\nThis is my first assignment dealing with Dynamic Programming and I'm finding it quite difficult.\n\nProblem:\n\nGiven a knapsack of capacity W and n gold bars of weights [wt[0],..., wt[n - 1], find maximum number of gold bars that can fit into knapsack without repetition.\n\ninput:\nline 1:(capacity knapsack(W)) (num gold bars(n))\nline 2: weights of n gold bars (wt)\n\noutput: max weight (of gold bars) that can fit in knapsack of capacity W\n\nMy code:\n\n```\nimport sys\n\ndef optimal_weight(W, wt):\n    \"\"\"Find max weight that can fit in knapsack size W.\"\"\"\n    # Create n nested arrays of 0 * (W + 1)\n    max_vals = [[0] * (W + 1) for x in range(len(wt))]\n    # Set max_vals[0] to wt[0] if wt[0] <= j\n    max_vals[0] = [wt[0] if wt[0] <= j else 0 for j in range(W + 1)]\n    for i in range(1, len(wt)):\n        for j in range(1, W + 1):\n            value = max_vals[i - 1][j]  # previous i @ same j\n            if wt[i] <= j:\n                val = (max_vals[i - 1][j - wt[i]]) + wt[i]\n                if value < val:\n                    value = val\n                    max_vals[i][j] = value\n                else:\n                    max_vals[i][j] = value\n\n    return max_vals[-1][-1]\n\nif __name__ == '__main__':\n    input = sys.stdin.read()\n    W, n, *wt = list(map(int, input.split()))\n    print(optimal_weight(W, wt))\n```\n\n\nAny ideas where I'm going wrong? When I observe my ending max_vals, I am seeing that max_vals, as i increases, is only replacing increasingly smaller values (i - 1) in each nested list. In other words, as I continue iterating, fewer 0's are being replaced with the value of max_vals[i - 1][j]. Somewhat embarrassingly, I've been working on this for almost a week and can't figure it out. This video, aside from the class lecture video, has been my main point of reference. Dynamic programming is proving to be a pretty big challenge.\n    ", "Answer": "\r\nTrivially easy fix. Can't believe I missed it. Was just messing up with the else statements. Needed an extra.\n\n```\n        if value < val:\n                value = val\n                max_vals[i][j] = value\n            else:\n                max_vals[i][j] = value  # set to [i - 1][j]\n        else:\n            max_vals[i][j] = value   # set to [i - 1][j]\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Index out of range in fibonacci using dynamic programming\r\n                \r\nRecently Dynamic Programming perked my interest. So, I wrote a code on fibonacci series using dynamic programming concept but every time on execution i am greeted with array out of index out of range. I tried hard to figure it out but couldn't fix it.\nFrom the error I think the index goes out of bound on the last iteration. Here's my code :\n\n```\ndef fibo(n) :\n\n# len(mem) being shorter than n will indicate that the position is not filled(memoized)\n# if it is equal then is has the required value it wont have to calculate res = fibo(n-1)+ fibo(n-2)\n    if len(mem) == n :\n        return mem[n]\n\n#General cases\n    if n == 1 or n == 2 :\n        res = 1\n    elif n == 0 :\n        res = 0\n    else :\n        res = fibo(n-1)+ fibo(n-2)\n\n#Here the len(m) should be n-1 and thus we append the value of 'res'so at one point we can return it instead of calculating\n    mem.append(res)\n    return res\n\n#Start of Program\nn = int(input(\"Enter the position :\"))\n\n#Defining mem as a list\nmem = []\n\nprint(fibo(n))\n```\n\n    ", "Answer": "\r\nYou need to add 1 to your list first:\n\n```\nmem = [1]\nfor i in range(1,10):\n    print(fibo(i))\n\n1\n1\n2\n3\n5\n8\n13\n21\n34\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Generating first n prime numbers using dynamic programming\r\n                \r\nHow can I generate first n prime numbers using dynamic programming ? (Code is not required just the concept would be enough)\n    ", "Answer": "\r\nWe can use Memoization technique for generating prime numbers using dynamic programing. You can write a function which accepts the number to be checked(say x) for primality and another parameter which accepts divisor(say the variable is i). Inside the function check for the conditions like i==1 then return 1 and x%i==0 then return 0 and again call the function recursivly with decrementing i and the result shoiud be stored in to an array.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming - Evaluating grid size\r\n                \r\nI was reading dynamic programming problem, 0/1 knapsack at https://www.educative.io/courses/grokking-dynamic-programming-patterns-for-coding-interviews/RM1BDv71V60\nUpon reading, Question I have is, which is a general question,\nIf I straightaway want to jump to a bottom-up approach, how do we finalize the storage grid size to start within a bottom-up approach? I mean in the given example of the link, recursive/brute force solutions have two variables changing. That is why I believe, that 2D grid size come into the picture and from there I reached top-down and then bottom up. How would you think of the dimensions of the storage grid if I want to jump to bottom-up approach directly.\nAnd how do we decide which dimension represents what?\nIt would be excellent if someone can shed light on it. I would be happy to add more details if needed.\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming: Chessboard\r\n                \r\nA rook starts in the upper left corner of a standard 8 by 8 chessboard. Two players take turns moving the rook either horizontally to the right or vertically downward, as many squares as they like.\nStationary moves are not allowed and Player 1 goes first. The winner is the player that places the rook on the lower right corner square. Say who will win and describe the winning strategy.\n\nI have the above statement problem and I'm interested in seeing how others would approach the problem. I know there is way to calculate the different paths that the rook can take. I tried doing the problem by hand and it always seemed like Player 2 always won but I might be thinking of it too simply. Approaching it in a dynamic programming fashion seemed like a good way to go. Anyway, anyone have any insights, algorithms, or such to approaching this problem!\n    ", "Answer": "\r\n\n\nH8 is a winner box so everything above and left of it is loser box.\n\nEverything to right and below of G7 (G8 and H7) is a loser box so it is a winner box.\n\nG7 is a winner box so everything above and left of it is loser box.\n\nAnd so on…\n\nPlayer one that starts the game has only choice to go to a loser box so player two always wins.\n\nAll player two has to do is to move to a w box every time it's his turn.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic array in C++ for dynamic programming\r\n                \r\nI was solving a dynamic programming problem. The problem is to decompose an integer into sum of square numbers, using terms as few as possible. A standard DP problem and I come up with a program:\n\n```\nvector<int> decompose(int num){\nunordered_map<int, vector<int>> mymap;\nint dp[num+1];\nfor(int i=0; i <= num; i++){\n    dp[i] = i;\n}\nint upbound = sqrt(num)+1;\nfor(int i=1; i <= upbound; i++){\n    int sq = i*i;\n    for(int j=0 ; j+sq <= num; j++){\n        if(dp[j]+1 < dp[j+sq]){\n            dp[j+sq] = dp[j]+1;\n            if(mymap.find(j)!=mymap.end()){\n                mymap[j+sq] = mymap[j];\n                mymap[j+sq].push_back(sq);                    \n            }\n            else{\n                 vector<int> tmp(1, sq);\n                 mymap[j+sq] = tmp;\n            }\n        }\n    }\n}\nint sum = 0;\nfor(int i = 0; i < mymap[num].size(); i++){\n    sum += mymap[num][i];\n}\nfor(int i = 0; i < num - sum; i++){\n    mymap[num].insert(mymap[num].begin(), 1);\n}\nreturn mymap[num];\n```\n\n\n}\n\nI test it a little bit and the code works. Below are some test results:\n\n```\nnum: 14, decompose as: 1 4 9 \nnum: 13, decompose as: 4 9 \nnum: 12, decompose as: 4 4 4 \n```\n\n\nThen I try to replace the dp array using dynamic array. The reason to do so is that in some OJ sites, the stack space is limited.\n\nSpecifically, what I did is to change line 3 to \n\n```\nint *dp = new int(num+1);\n```\n\n\nand add \n\n```\ndelete [] dp; \n```\n\n\nbefore returning the result.\n\nHowever, my code does not work any more after the change. The change does not affect the algorithm itself. I guess the memory of the dynamic array I created was destroyed in the for loop. But I could not understand where exactly the problem came.\n    ", "Answer": "\r\nThe problem is exactly in the line where you define your array:\n```\nint *dp = new int(num+1);```\n This means you create a pointer to integer value, e.g. ```\nint```\n, initialized to ```\nnum+1```\n which is not what you want. To create an array you need to use the brackets ```\n[]```\n instead. \n\n```\nint *dp = new int[num+1];```\n\n\nThis creates an array of ```\nint```\n elements with size ```\nnum+1```\n.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Recursive function to dynamic programming\r\n                \r\nSo ive got this recursive function:\n```\nint solution(int i, int j, int n, int m, int **A, int c, int **B, int **C, int *D, int *E) {\n    int a, b, k, w;\n\n    if (i < n && j < m) {\n        B[i + j][0] = i;\n        B[i + j][1] = j;\n        D[i + j] = c;\n    }\n    else if (i == n && j == m) {\n        B[i + j - 1][0] = i;\n        B[i + j - 1][1] = j;\n        D[i + j - 1] = c;\n    }\n\n    if (A[i][j] == 'C') {\n        c++;\n    }\n\n    if (i == n - 1 && j == m - 1) {\n        if (c > maxcoins) {\n            for (w = 0; w < n + m; w++) {\n                C[w][0] = B[w][0];\n                C[w][1] = B[w][1];\n                E[w] = D[w];\n            }\n\n            maxcoins = c;\n        }\n    }\n\n    if (i < n - 1) {\n        a = i + 1;\n        k = solution(a, j, n, m, A, c, B, C, D, E);\n    }\n\n    if (j < m - 1) {\n        b = j + 1;\n        k = solution(i, b, n, m, A, c, B, C, D, E);\n    }\n}\n```\n\nand i want to convert it to a dynamic programming solution but i cant figure out how to do it. Basically given a 2D array of C and . ,C representing coins and . blank spots it has to figure out the maximum number of coins one can collect only by moving down and right(maxcoins is an external variable). I would appreciate it if you got any answears that might help, thanks!\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "How could you convert the following recursion with dynamic programming?\r\n                \r\nHow would you convert the following recursive program with dynamic programming (DP)?\nI'm just having a little trouble trying to redefine this code into a dynamic programming form. I got the base case and the general case identified, and I am aware that DP is about a \"bottom-up\" approach.\n\n```\nint add(int, int);\n\nint main()\n{\n    int x = 0, y = 0;\n    printf(\"Enter positive integers x, y: \");\n    scanf(\"%d %d\", &x, &y);\n\n    printf(\"Result: %d\\n\", add(x, y));\n\n    return 0;\n}\n\nint add(int x, int y)\n{\n    if(x < 0 || y < 0){\n        fprintf(stderr, \"Negative Integer received!\\n\");\n        return -1;\n    }\n    if (x == 1 || y == 1)\n        return 1;\n    else\n        return add(x, y-1) + add(x - 1, y) + add(x-1, y-1);\n}\n```\n\n    ", "Answer": "\r\nWhy do you want to do it in recursive way? There is an iterative way, and iterative 'almost always' beats recursive. Besides it is less code:\n\n```\nint DP[500][500];\nmemset(DP, 0, sizeof(DP));\nfor(int i=1; i<=x; i++) DP[i][1] = 1;\nfor(int i=1; i<=y; i++) DP[1][i] = 1;\n\nfor(int i=2; i<=x; i++) {\n    for(int j=2; j<=y; j++) {\n        DP[i][j] = DP[i-1][j-1] + DP[i-1][j] + DP[i][j-1];\n    }\n}\n\nprintf(\"Result: %d\\n\", DP[x][y]);\n```\n\n\nBut if you insist on recursion you can pass your DP array to function by pointer. And every time check if you calculated DP[i][j] before, if so don't calculate it again and return back:\n\n```\n#include <stdio.h>\n#include <string.h>\n\nvoid add(int x, int y, int (*M)[500])\n{\n    if(M[x][y] > 0) return;\n\n    if (x == 1 || y == 1) {\n        M[x][y] = 1;\n        return;\n    }\n\n    add(x, y-1, M);\n    add(x - 1, y, M);\n    add(x-1, y-1, M);\n\n    M[x][y] = M[x][y-1] + M[x-1][y] + M[x-1][y-1];\n    return;\n}\n\nint main()\n{\n    int x, y;\n    printf(\"Enter x, y: \");\n    scanf(\"%d %d\", &x, &y);\n\n    int DP[500][500];\n    memset(DP, 0, sizeof(DP));\n    add(x, y, DP);\n\n    printf(\"Result: %d\\n\", DP[x][y]);\n\n    return 0;\n}\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Coin Change :Dynamic Programming\r\n                \r\nThe code I have written solves the basic coin change problem using dynamic programming and gives the minimum number of coins required to make the change. But I want to store the count of each coin playing part in the minimum number. \n\nWhat I am trying to do is initializing an array ```\ncount[]```\n and just like hashing it increments the number of ```\ncoin[j]```\n whenever ```\nmin```\n is found, i.e ```\ncount[coin[j]]++```\n . \nBut this is not working the way I wanted because it adds the coin every time it finds ```\nmin```\n corresponding to ```\ncoin[j]```\n. Hence the number is not the final count of coin in the final answer. \n\nHere is the code:\n\n```\nvoid makeChange(int coin[], int n, int value)\n{\n    int i, j;\n    int min_coin[MAX];\n    int min;\n\n    int count[MAX];\n    min_coin[0] = 0;\n\n    for (i=1; i <= value; i++)\n    {\n            min = 999;\n            for (j = 0; j<n; j++)\n            {\n                    if (coin[j] <= i)\n                    {\n                            if (min > min_coin[i-coin[j]]+1)\n                            {\n                                    min = min_coin[i-coin[j]]+1;\n                                    count[coin[j]]++;\n                            }\n                    }\n            }\n            min_coin[i] = min;\n    }\n\n    printf(\"minimum coins required %d \\n\", min_coin[value]);\n\n}\n```\n\n    ", "Answer": "\r\nYou have to keep an extra, two-dinemsional array to store the coin count for each value and each coin denomination.\n\nWhen you assign a new minimum in your inner loop, copy all coin counts from ```\ni - coin[j]```\n to i and then increment ```\nmin_count[i][j]```\n. The number of coins needed is then in ```\ncoin_count[value]```\n.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "bottom up dynamic programming\r\n                \r\nI was trying to write a dynamic programming that counts the number of ways in which the road can be paved by using stones that are 2, 3, 5 meters. When I put 2, it gave me an error and starting from 2 to 20, it was supposed to give an output of \n\n\n  1, 1, 1, 3, 2, 5, 6, 8, 14, 16, 27, 36, 51, 77, 103, 155, 216, 309,\n  448\n\n\nMy code gives this result when I start the input from 3. Did I misunderstand something here?\n\n```\ndef waysRoad(n):\n    if n<0:\n        return 0\n\n    dp = [0] * (n+1)\n    dp[0] = 1\n    dp[1] = 0\n    for i in range(2, n):\n        sum = 0\n        if i >=2:\n            sum += dp[i-2]\n\n        if i >=3:\n            sum += dp[i-3]\n        if i >=5:\n            sum += dp[i-5]\n        dp[i] = sum\n    return dp[i]\n```\n\n    ", "Answer": "\r\nTo fill ```\nn-th```\n list entry, you need to use loop limit ```\nn+1```\n:\n\n```\nfor i in range(2, n + 1):\n```\n\n\nalso it is worth to change return to\n\n```\nreturn dp[n]\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Coin change dynamic-programming question top-down memoization approach\r\n                \r\nI'm currently working on the coin change dynamic-programming question on leetcode -- https://leetcode.com/problems/coin-change/.\n\nHere is the question statement:\n\n```\nYou are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n\nExample 1:\n\nInput: coins = [1, 2, 5], amount = 11\nOutput: 3 \nExplanation: 11 = 5 + 5 + 1\nExample 2:\n\nInput: coins = [2], amount = 3\nOutput: -1\n```\n\n\nI tried to implemented a top-down memoization approach, where I keep an array of length amount, where each index represents the minimum amount of coins I can use to make that amount.\n\nHere is my code in Java:\n\n```\nclass Solution {\n    public int coinChange(int[] coins, int amount) {\n        int[] dp = new int[amount + 1];\n\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        dp[0] = 0;\n\n        int min = coinChange(coins, amount, dp);\n\n        return min == Integer.MAX_VALUE ? -1 : min;\n    }\n\n    private int coinChange(int[] coins, int amount, int[] dp) {\n        if (amount < 0) {\n            return Integer.MAX_VALUE;\n        }\n        if (amount == 0) {\n            return 0;\n        }\n\n        if (dp[amount] != Integer.MAX_VALUE) {\n            return dp[amount];\n        }\n\n        int min = Integer.MAX_VALUE;\n        for (int i = 0; i < coins.length; i++) {\n            int val = coinChange(coins, amount - coins[i], dp);\n\n            if (val != Integer.MAX_VALUE) {\n                min = Math.min(min, val + 1);\n            }\n        }\n\n        dp[amount] = min;\n        return min;\n    }\n}\n```\n\n\nI thought this was the correct approach to dynamic-programming for this problem, however I'm getting Time Limit Exceeded on leetcode.\n\nIs this a wrong approach do dynamic programming? If so, can you please explain where it is wrong?\n\nThank you so much in advance.\n    ", "Answer": "\r\nThis is my version of the solution. This is easy to understand as well!\n\n```\nclass Solution {\n    public int coinChange(int[] coins, int amount) {\n        int[] dp = new int[amount + 1];\n\n        Arrays.fill(dp, 0);\n\n        int min = coinChange(coins, amount, dp);\n        return min;\n    }\n\n    private int coinChange(int[] coins, int amount, int[] dp) {\n        if (amount < 0) {\n            return -1;\n        }\n        if (amount == 0) {\n            return 0;\n        }\n\n        if (dp[amount]!=0) {\n            return dp[amount];\n        }\n\n        int minimum = Integer.MAX_VALUE;\n        for (int i = 0; i < coins.length; i++) {\n            int val = coinChange(coins, amount - coins[i], dp);\n\n            if (val >= 0 && val < minimum) {\n                minimum = val + 1;\n            }\n        }\n        dp[amount] = (minimum == Integer.MAX_VALUE) ? -1 : minimum;\n        return dp[amount];\n    }\n}\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming technique for solving problems\r\n                \r\nIs it possible to solve any Dynamic Programming problem using recursion+memoization instead of using tabulation/iteration? Or there are some problems where it is must to use tabulation/iteration.\nAlso can we obtain the same time complexity when solving any problem using recursion+memoization ( I know space complexity differs and also recursion overhead cost exists).\n    ", "Answer": "\r\nEvery Dynamic Programming problem can be expressed as recurrence relation which can be solved using recursion+memoization which can be converted into tabulation+iteration.\nWhen you solve a DP problem using tabulation you solve the problem bottom up, typically by filling up an n-dimensional table. Based on the results in the table, the solution to the original problem is then computed.\nWhen you solve a DP problem using memoization, you do it by maintaining a map of already solved sub problems. You do it top down in the sense that you solve the \"top\" problem first (which typically recurses down to solve the sub-problems).\nThe time complexity of a DP problem which uses tabulation+iteration is the same as an converted equivalent and correct memoization+recursion version of the solution. It is usually easy to find the time complexity in an tabulation+iteration method. On the other hand, memoization+recursion version of DP solution is more intuitive and readable.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Debug coin change Dynamic Programming\r\n                \r\nMy coin change dynamic programming implementation is failing for some of the test cases, and I am having a hard time figuring out why:\n\nProblem Statement: Given an amount and a list of coins, find the minimum number of coins required to make that amount. \n\nEx:\nTarget Amount: 63\nCoin List: [1, 5, 10, 21, 25]\nOutput: [21, 21, 21]\n\n```\ndef coin_change(change_list, amount, tried):\n    if amount <= 0:\n        return []\n    if amount in change_list:\n        return [amount]\n    if amount in tried:\n        return tried[amount]\n    coin_count = []\n    for change in change_list:\n        if change < amount:\n            changes = coin_change(change_list, amount-change, tried)\n            changes.append(change)\n            coin_count.append(changes)\n    min_changes = coin_count[0][:]\n    for x in coin_count[1:]:\n        if len(min_changes) >= len(x):\n            min_changes = x[:]\n    tried[amount] = min_changes[:]\n    return min_changes\n\n\ndef main():\n    for amount in range(64):\n        changes = coin_change([1, 5, 10, 21, 25], amount, {})\n        if sum(changes) != amount:\n            print \"WRONG: Change for %d is: %r\" % (amount, changes)\n        else:\n            # print \"Change for %d is: %r\" % (amount, changes)\n            pass\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n\nTrinket: https://trinket.io/python/43fcff035e\n    ", "Answer": "\r\nYou're corrupting the variable, ```\nchanges```\n, by appending to it during a loop. Try this:\n\nReplace these two lines:\n\n```\nchanges.append(change)\ncoin_count.append(changes)\n```\n\n\nWith:\n\n```\n_changes = changes[:] + [change]\ncoin_count.append(_changes)\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Debug coin change Dynamic Programming\r\n                \r\nMy coin change dynamic programming implementation is failing for some of the test cases, and I am having a hard time figuring out why:\n\nProblem Statement: Given an amount and a list of coins, find the minimum number of coins required to make that amount. \n\nEx:\nTarget Amount: 63\nCoin List: [1, 5, 10, 21, 25]\nOutput: [21, 21, 21]\n\n```\ndef coin_change(change_list, amount, tried):\n    if amount <= 0:\n        return []\n    if amount in change_list:\n        return [amount]\n    if amount in tried:\n        return tried[amount]\n    coin_count = []\n    for change in change_list:\n        if change < amount:\n            changes = coin_change(change_list, amount-change, tried)\n            changes.append(change)\n            coin_count.append(changes)\n    min_changes = coin_count[0][:]\n    for x in coin_count[1:]:\n        if len(min_changes) >= len(x):\n            min_changes = x[:]\n    tried[amount] = min_changes[:]\n    return min_changes\n\n\ndef main():\n    for amount in range(64):\n        changes = coin_change([1, 5, 10, 21, 25], amount, {})\n        if sum(changes) != amount:\n            print \"WRONG: Change for %d is: %r\" % (amount, changes)\n        else:\n            # print \"Change for %d is: %r\" % (amount, changes)\n            pass\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n\nTrinket: https://trinket.io/python/43fcff035e\n    ", "Answer": "\r\nYou're corrupting the variable, ```\nchanges```\n, by appending to it during a loop. Try this:\n\nReplace these two lines:\n\n```\nchanges.append(change)\ncoin_count.append(changes)\n```\n\n\nWith:\n\n```\n_changes = changes[:] + [change]\ncoin_count.append(_changes)\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Knapsack Dynamic Programming Inputs\r\n                \r\nI was wondering if there were any specific questions and answers for the knapsack problem that I can input and modify this code with to make sure I did it correctly? I'm trying to get into dynamic programming and am starting with this problem, but have no way of knowing if it actually works without input - I found a few cases on some power points, and while my code output correct information, they were pretty basic and simple cases, so I want to make sure that this works with more meaty input.\n\nHere is my code:\n\n```\nimport java.util.ArrayList;\n\npublic class Knapsack {\n\n    private int numThings = 0;\n\n    public static void main(String[] args) {\n\n        (new Knapsack()).run();\n    }\n\n    public void run() {\n\n        ArrayList<Thing> thingList = new ArrayList<Thing>();\n        thingList.add(new Thing(60, 2));\n        thingList.add(new Thing(75, 3));\n        thingList.add(new Thing(90, 4));\n\n\n        int maxWeight = 5;\n\n\n        int[] vals = new int[maxWeight + 1];\n        vals[2] = 60;\n\n        Thing nullThing = new Thing(0,0);\n        Thing max;\n        int maxSet = 0;\n\n        for (int i = 1; i < vals.length; i++) {// lets go through weights leading up to our maximal weight\n\n            System.out.println(i);\n            max = nullThing;\n            for (Thing x : thingList) {\n\n                if ((i-x.getWeight() >= 0) && (x.getValue() + vals[i-x.getWeight()] > max.getValue() + vals[i-max.getWeight()])) {\n\n                    max = x;\n                    maxSet = 1;//here, we compare possibilities of adding items by subtracting weights from  our current index and seeing which ones produce the highest values\n                }\n            }\n\n            if (maxSet == 1) {\n\n                vals[i] = max.getValue() + vals[i-max.getWeight()];\n                System.out.println(max.info() );//if we find something that sets a highest value, we cache that info into the array for future use\n            }\n        }\n\n        System.out.println(vals[maxWeight]);\n\n\n    }\n\n\n    private class Thing {\n\n        private int value, weight;\n\n        public Thing(int v, int w) {\n\n            value = v;\n            weight = w;\n\n        }\n\n        public int getValue() {\n\n            return value;\n        }\n\n        public int getWeight() {\n\n            return weight;\n        }\n\n        public String info() {\n\n            return \"I have a weight of \"+weight+\" and a value of \"+ value;\n        }\n    }\n}\n```\n\n    ", "Answer": "\r\nGoogling \"knapsack problem data sets\" produces plenty of answers. Here is first.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Typescript typings in dynamic programming?\r\n                \r\nI was trying to get types in typescript for dynamic programming.\nI am getting an error at line\n\n```\n        const { oldListIndex, getNewFunc } = getFunc(newObjItem, oldObj);\n```\n\n\nThe error is \n\nCannot invoke an expression whose type lacks a call signature. Type '((item: {}, list: T) => { oldListIndex: number; getNewFunc: {}; }) | { [K in { [K in keyof T]: T[K] extends object ? K : never; }[keyof T]]: funcIterator; }' has no compatible call signatures.\n\nAnd Line \n\n```\n    oldObj = newObj\n```\n\n\nThe error is\n\nType 'Partial' is not assignable to type 'T'.\n\n```\ntype funcIterator<T> = T extends Array<infer U> ?\n    (item: U, list: T) => funcIterator<U> extends never ?\n        { oldListIndex: number, } : { oldListIndex: number, getNewFunc: funcIterator<U> }\n    : T extends object ? { [K in objectKeys<T>]: funcIterator<T[K]> } : never;\n\ntype objectKeys<T extends object> = {\n    [K in keyof T]: T[K] extends object ? K : never\n}[keyof T];\n\nfunction updateOldObj<T>(oldObj: T, newObj: Partial<T>, getFunc: funcIterator<T>) {\n    if (Array.isArray(newObj) && Array.isArray(oldObj)) {\n        newObj.forEach(newObjItem => {\n\n            const { oldListIndex, getNewFunc } = getFunc(newObjItem, oldObj);\n            oldObj[oldListIndex] = updateOldObj(oldObj[oldListIndex], newObjItem, getNewFunc)\n        });\n        return oldObj;\n    } else if (typeof newObj === 'object' && typeof oldObj === 'object') {\n        Object.keys(newObj).forEach((newObjKey) => {\n\n            oldObj[newObjKey] = updateOldObj(oldObj[newObjKey],\n                newObj[newObjKey], (getFunc) ? getFunc[newObjKey] : undefined);\n        });\n        return oldObj;\n    } else {\n        oldObj = newObj\n        return oldObj;\n    }\n}\n```\n\n\nAny Help on the same would be highly appreciated.\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Travelling Salesman problem in dynamic programming\r\n                \r\ni am trying to resolve the travelling salesman problem with dynamic programming in c++ and i find a way using a mask of bits, i got the min weight, but i dont know how to get the path that use, it would be very helpful if someone find a way. This is my code:\n\n```\n#include<iostream>\nusing namespace std;\n\n#define INT_MAX 999999\n\nint n=4;\nint dist[10][10] = {\n        {0,20,42,25},\n        {20,0,30,34},\n        {42,30,0,10},\n        {25,34,10,0}\n};\nint VISITED_ALL = (1<<n) -1;\n\nint dp[16][4];\n\n\nint  tsp(int mask,int pos){\n\n    if(mask==VISITED_ALL){\n        return dist[pos][0];\n    }\n    if(dp[mask][pos]!=-1){\n       return dp[mask][pos];\n    }\n\n    //Now from current node, we will try to go to every other node and take the min ans\n    int ans = INT_MAX;\n\n    //Visit all the unvisited cities and take the best route\n    for(int city=0;city<n;city++){\n\n        if((mask&(1<<city))==0){\n\n            int newAns = dist[pos][city] + tsp( mask|(1<<city), city);\n            ans = min(ans, newAns);\n        }\n\n    }\n\n    return dp[mask][pos] = ans;\n} \n\nint main(){\n    /* init the dp array */\n    for(int i=0;i<(1<<n);i++){\n        for(int j=0;j<n;j++){\n            dp[i][j] = -1;\n        }\n    }\n    cout<<\"Travelling Saleman Distance is \"<<tsp(1,0);\n\nreturn 0;\n}\n```\n\n    ", "Answer": "\r\nLet's introduce a new path function that gives the entire optimal path using the previously calculated dp array.\n\n```\nvoid  path(int mask,int pos){\n    if(mask==VISITED_ALL) return;\n    int ans = INT_MAX, chosenCity;\n\n    for(int city=0;city<n;city++){\n\n        if((mask&(1<<city))==0){\n\n            int newAns = dist[pos][city] + dp[mask|(1<<city)][city];\n            if(newAns < ans){\n                ans = newAns;\n                chosenCity = city;\n            }\n        }\n\n    }\n    printf(\"%d \",city); // here you get the current city you need to visit\n    path(mask|(1<<city),city);\n}\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming question\r\n                \r\nI am stuck with one of the algorithm homework problem. Can anyone give me some hint to solve it? Here is the question:\n\nConsider a chain structured computation represented by a weighted graph G = (V;E) where\nV = {v1; v2; ... ; vn} and E = {(vi; vi+1) such that 1<= i <= n-1. We are also given a chain-structure m identical processors P = {P1; ... ; Pm} (i.e., there exists a communication link between Pk and Pk+1 for 1 <= k <= m - 1).\n\nThe set of vertices V represents computation modules, and the set of edges E represents\ncommunication between the two modules. Each node vi is assigned a weight wi denoting the\nexecution time of the module on a single processor. Each edge (vi; vi+1) is assigned a weight ci denoting the amount of communication time between the two modules if they are assigned two different processors. If multiple modules are assigned to the same processor, the modules assigned to the same processor must be consecutive. Suppose modules va; va+1; .. ; vb are assigned to Processor Pk. Then, the time taken by Pk, denoted by Tk, is the time to compute assigned modules plus the time to communicate between neighboring processors. Hence, Tk = wa+...+ wb + ca-1 + cb. Note here that ca-1 = 0 if a = 1 and cb = 0 if b = n.\n\nThe objective of the problem is to find an assignment V to P such that max1<=k<=m Tk\nis minimized, where we assume that each processor must take at least one module. (This\nassumption can be relaxed by adding m dummy modules with zero weight on computational\nand communication time.)\nDevelop a dynamic programming algorithm to solve this problem in polynomial time(i.e O(mn))\n\nI tried to find the minimum execution time for each Pk  and then find the max, but I doubt my solution is dynamic programming since there is no recursive formula. Please give me some hints! \nThanks!\n    ", "Answer": "\r\nI think you might be able to modify the Viterbi algorithm to solve this problem.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming process\r\n                \r\nI'm trying to implement a solution to this problem but I am having some problems. \n\nThe problem is:\n\n\n  \"There is a robot in the upper left hand corner of a grid with r rows and c columns. The robot can only move right or down and certain cell's are \"off limits\" meaning the robot cannot step on them. Design an algorithm to find a path for the robot from the top left to the bottom right.\"\n\n\nThe solution looks like this:\n\n```\npublic static ArrayList<Point> getPath(boolean[][] maze){\n   if(maze == null || maze.length==0) return null;\n      ArrayList<Point> path = new ArrayList<Point>();\n      HashSet<Point> failedPoints = new HashSet<Point>();\n   if(getPath(maze, maze.length-1,maze[0].length-1,path,failedPoints)){\n      return path;\n   }\n   return null;\n}\n\npublic static boolean getPath(boolean[][] maze, int row, int col, \n   ArrayList<Point> path, HashSet<Point> failedPoints){\n   /*if out of bounds or not available, return*/\n   if(col<0 || row<0 || !maze[row][col]){\n      return false;\n   }\n   Point p = new Point(row,col);\n   /*If we've already visited this cell return*/\n   if(failedPoints.contains(p)){\n      System.out.println(\"Worked\");\n      return false;\n   }\n\n   boolean isAtOrigin = (row == 0) && (col == 0);\n\n   /*If there's a path from start to my current location, add my location.*/\n\n   if(isAtOrigin || getPath(maze,row,col -1, path, failedPoints) || getPath(maze,row-1, col, path,failedPoints)){\n      path.add(p);\n      return true;\n   }\n   failedPoints.add(p); //Cache result\n   return false;\n}\n```\n\n\nWhat's confusing to me is the attempt at Dynamic Programming. \n\n\n  ```\nif(failedPoints.contains(p))```\n never evaluates to ```\ntrue```\n. \n\n\nI have overridden the ```\nequals```\n and ```\nhashCode```\n methods in my Point class so failedPoints.contains(object) evaluates to true whenever the object compared has the same row and col values. \n\nPerhaps it has to do with the maze input i'm using: \n\n```\n    boolean[][] maze = new boolean[4][4];\n    java.util.Arrays.fill(maze[0],true);\n    java.util.Arrays.fill(maze[1],true);\n    java.util.Arrays.fill(maze[2],true);\n    java.util.Arrays.fill(maze[3],true);\n\n    maze[0][1] = false;\n    maze[3][2] = false;\n    ArrayList<Point> path =  getPath(maze);\n```\n\n\nBut I'm not sure. In the end I don't see how ```\nfailedPoints.contains(p)```\n is saving my computer any execution steps\n\nHere is the point class:\n\n```\npublic class Point {\n    int row;\n    int col;\n\n    Point(int row1,int col1) {\n        row = row1;\n        col = col1;\n    }\n\n    public boolean equals(Object o) {\n        if (!(o instanceof Point)) return false;\n        Point comp = (Point) o;\n        return comp.row == row && comp.col == col;\n    }\n\n    public int hashCode() {\n        return row;\n    }\n}\n```\n\n    ", "Answer": "\r\nIt's your maze's design.\nThis is your maze, according to the input you have written in the question:\n\nE    O    O     O\nO    O    O     O\nO    O    X     X\nO    O    X     S\n\nYou start at ```\nS```\n and are trying to reach ```\nE```\n, with ```\nX```\n being off limit locations.\n\nSo, you see that with ```\nS```\n being entirely covered with off limit points, there is no way you can reach ```\nE```\n. And hence the very first point ```\nS```\n is a failed point which is never re-used because the algorithm halts after the evaluation of ```\nS```\n.\nPerhaps if you would set the point in 0th row and 1st column as off limit, you will have multiple explorations that will reach this point and take advantage of caching to ascertain that this point cannot be used any further for exploring the maze.\n\nUPDATE:\nAfter you updated the maze, I realized that there are two issues with your implementation, not one.\nChange the line,\n```\nif(isAtOrigin || getPath(maze,row,col -1, path, failedPoints) || getPath(maze,row-1, col, path,failedPoints))```\n\nto\n```\nif(isAtOrigin || getPath(maze,row-1,col, path, failedPoints) || getPath(maze,row,col-1, path,failedPoints))```\n\nand the code will actually work with the new maze.\nThe issue is that you are returning from the ```\ngetPath()```\n as soon as you find a path. And because you are first going to left and then going up, the point [0, 2] (which is a failed point) is not hit at all, and therefore not cached, and therefore not used either.\nChanging the if condition causes your algorithm to first search up and then search left. This causes you to hit [0, 2] multiple times, resulting in it being cached as well as re-used in further path searches.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming and Dijkstra\r\n                \r\nI'm reading the following problem statement meant to be solved with dynamic programming:\n\nGiven an undirected graph G having N ```\n(1<N<=1000)```\n vertices and positive weights. Find the shortest path from vertex 1 to vertex N, or state that such path doesn’t exist.\nHint: At each step, among the vertices which weren’t yet checked and for which a path from vertex 1 was found, take the one which has the shortest path, from vertex 1 to it, yet found.\n\nI believe the algorithm should be something like\n```\nS = starting point\nN = ending point\ninitialize all distances from S to +infinity\nunexplored_vertices[] = [all vertex adjacent to S]\n\nfor each v in unexplored_vertices[]\n  calculate new_distance from S to v\n  if new_distance is better than the former then\n    store new_distance\n  closest_to_v = find(unexplored_vertices[], closest_to_S)\n  unexplored_vertices[].add_front(closest_to_v)\n\nreturn distance from S for N\n```\n\nAnyway this is very similar to how Dijkstra's algorithm works for shortest paths.\nMy question is: am I getting the problem statement wrong or is the statement really asking (along with the hint) for Dijkstra's shortest path algorithm?\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "More on dynamic programming\r\n                \r\nTwo weeks ago I posted THIS question here about dynamic programming. User Andrea Corbellini answered precisely what I wanted, but I wanted to take the problem one more step further. \n\nThis is my function \n\n```\ndef Opt(n):\n    if len(n) == 1:\n        return 0\n    else:\n        return sum(n) + min(Opt(n[:i]) + Opt(n[i:])\n                            for i in range(1, len(n)))\n```\n\n\nLet's say you would call\n\n```\nOpt( [ 1,2,3,4,5 ] )\n```\n\n\nThe previous question solved the problem of computing the optimal value. Now,\ninstead of the computing the optimum value 33 for the above example, I want to print the way we got to the most optimal solution (path to the optimal solution). So, I want to print the indices where the list got cut/divided to get to the optimal solution in the form of a list. So, the answer to the above example would be :\n\n```\n[ 3,2,1,4 ]```\n   ( Cut the pole/list at third marker/index, then after second index, then after first index and lastly at fourth index).\nThat is the answer should be in the form of a list. The first element of the list will be the index where the first cut/division of the list should happen in the optimal path. The second element will be the second cut/division of the list and so on.\n\nThere can also be a different solution:\n\n```\n[ 3,4,2,1 ] \n```\n\n\nThey both would still lead you to the correct output. So, it doesn't matter which one you printed. But, I have no idea how to trace and print the optimal path taken by the Dynamic Programming solution.\nBy the way, I figured out a non-recursive solution to that problem that was solved in my previous question. But, I still can't figure out to print the path for the optimal solution. Here is the non-recursive code for the previous question, it might be helpful to solve the current problem.\n\n```\ndef Opt(numbers):\nprefix = [0]\nfor i in range(1,len(numbers)+1):\n    prefix.append(prefix[i-1]+numbers[i-1])\nresults = [[]]\nfor i in range(0,len(numbers)):\n    results[0].append(0)\nfor i in range(1,len(numbers)):\n    results.append([])\n    for j in range(0,len(numbers)):\n        results[i].append([])\nfor i in range(2,len(numbers)+1): # for all lenghts (of by 1)\n    for j in range(0,len(numbers)-i+1): # for all beginning\n        results[i-1][j] = results[0][j]+results[i-2][j+1]+prefix[j+i]-prefix[j]\n        for k in range(1,i-1): # for all splits\n            if results[k][j]+results[i-2-k][j+k+1]+prefix[j+i]-prefix[j] < results[i-1][j]:\n                results[i-1][j] = results[k][j]+results[i-2-k][j+k+1]+prefix[j+i]-prefix[j]\nreturn results[len(numbers)-1][0]\n```\n\n    ", "Answer": "\r\nHere is one way of printing the selected :\n\nI used the recursive solution using memoization provided by @Andrea Corbellini in your previous question. This is shown below:\n\n```\ncache = {}\n\ndef Opt(n):\n    # tuple objects are hashable and can be put in the cache.\n    n = tuple(n)\n\n    if n in cache:\n        return cache[n]\n\n    if len(n) == 1:\n        result = 0\n    else:\n        result = sum(n) + min(Opt(n[:i]) + Opt(n[i:])\n                              for i in range(1, len(n)))\n\n    cache[n] = result\n    return result\n```\n\n\nNow, we have the cache values for all the tuples including the selected ones.\n\nUsing this, we can print the selected tuples as shown below:\n\n```\nselectedList = []\ndef printSelected (n, low):\n\n    if len(n) == 1:\n        # No need to print because it's \n        # already printed at previous recursion level.\n        return\n\n    minVal = math.Inf\n    minTupleLeft = ()\n    minTupleRight = ()\n    splitI = 0\n\n    for i in range(1, len(n)):\n        tuple1ToI = tuple (n[:i])\n        tupleiToN = tuple (n[i:])\n\n        if (cache[tuple1ToI] + cache[tupleiToN]) < minVal:\n            minVal = cache[tuple1ToI] + cache[tupleiToN]\n            minTupleLeft = tuple1ToI\n            minTupleRight = tupleiToN\n            splitI = low + i\n\n\n    print minTupleLeft, minTupleRight, minVal\n    print splitI   # OP just wants the split index 'i'.\n    selectedList.append(splitI) # or add to the list as requested by OP\n\n    printSelected (list(minTupleLeft), low)\n    printSelected (list(minTupleRight), splitI)\n```\n\n\nYou call the above method like shown below:\n\n```\nprintSelected (n, 0)\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Coin Change Algorithm with Dynamic Programming\r\n                \r\nI am facing difficulty with Dynamic Programming. I was trying the trivial Coin Change problem- COIN CHANGE Problem UVa\n\nI am trying to use top-down approach with memorization but I am getting TLE. Here is my code-\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\ntypedef vector <int > vi;\ntypedef vector <vi> vii;\nconst int maxn = 10000007;\n\nint Set[maxn];\nint Coin(int n,int m,vii & dp)\n{   \n    if(n==0)\n        return 1;\n    else if(n<0 || m<0)\n        return 0;\n\n    else if(dp[n][m]!=-1)\n        return dp[n][m];\n    else\n    {\n        dp[n][m]=Coin(n-Set[m],m,dp)+Coin(n,m-1,dp);\n\n        return dp[n][m];\n    }\n}\n\nint main()\n{\n    int n,m=5;\n    Set[0]=50,Set[1]=25,Set[2]=10,Set[3]=5,Set[4]=1;\n    while(scanf(\"%d\",&n)!=EOF)\n    {       \n        vector <vector <int> > dp(n+1,vector<int> (m,-1));\n        dp[0][0]=0;\n        cout << Coin(n,m-1,dp) << endl;\n    }\n}\n```\n\n\nI want to know  am I doing memorization wrong or top-down will not work in this case and bottom-up approach is the only option.\n    ", "Answer": "\r\nYou do have not to  call Coin function for every testcase(each value of n) as m(number of types of coins) remains same in all cases so call it only once for maximum value which is 7489 here. and then answer for all testcase as dp[n][4]. Please see the code below for better understanding.\n\n```\nn = 7489;\nvector <vector <int> > dp(n+1,vector<int> (m,-1));\n dp[0][0]=0;\n Coin(n,m-1,dp);\nwhile(scanf(\"%d\",&n)!=EOF)\n{       \n\n    cout<<dp[n][4]<<endl;   \n}\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Space complexity comparison between recursion and dynamic programming, which is better?\r\n                \r\nI've seen that the space complexity of recursion depends on space used in call stack. And dynamic programming uses extra space to improve time complexity. So does recursion is better than dynamic programming in terms of space complexity?\n    ", "Answer": "\r\nNot if the dynamical programming is done optimally. It just makes explicit the storage requirements which are used anyway by recursive algorithm implicitly on the stack. It doesn't add any extra space needlessly (unless it's implemented suboptimally).\nConsider Fibonacci calculation. The recurrence formula seem to only require two values, ```\nFib(n+2) = Fib(n+1) + Fib(n)```\n, but due to recursion the calculation will actually use O(n) space on the stack anyway. Due to the double recursion the time though will be exponential, whereas with the dynamic programming filling the same space from the ground up both space and time will be linear.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Algorithm without dynamic programming,less efficient solution\r\n                \r\nThere is a problem asked in contest. I already solved this problem with dynamic programming and its complexity ```\nO(n^2)```\n. But i am looking for solution with less efficient way. What will be the complexity of this less efficient way. Thanks for the helps.\n    ", "Answer": "\r\nThere is a general way to make any dynamic programming solution less efficient. The essence of dynamic programming is to store solutions to sub-problems for reuse.\n\nTo make it less efficient in a somewhat reasonable way, get rid of the sub-problem result storage. Instead, recalculate each sub-problem solution whenever you need it.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming Problem.. Array Partitioning.. \r\n                \r\nThe question says,\n\nThat given an array of size n, we have to output/partition the array into subsets which sum to N.\n\n```\nFor E,g, \n    I/p  arr{2,4,5,7}, n=4, N(sum) = 7(given)\n    O/p = {2,5}, {7}\n```\n\n\nI saw similar kind of problem/explanation in the url Dynamic Programming3 \n\nAnd I have the following queries in the pdf:-\n\n\n  \n    \n    How could we find the subsets which sum to N, as the logic only tells whether the subset exist or not?\n    Also, if we change the question a bit, can we find two subsets which has equal average using the same ideology?\n    \n  \n\n\nCan anybody thrown some light on this Dynamic Programming problem.. :)\n\nThanks in Advance..\n    ", "Answer": "\r\nYou can try to process recursively:\n\nGiven a SORTED array X={x1 ... xn} xi !=0 and an intger N.\n\nFirst find all the possibilities \"made\" with just one element:\n\nhere if N=xp, eliminate all xi s.t i>=p\n\nsecond find all the possibilities made with 2 elements:\n\n{ (x1,x2) .... (xp-2,xp-1)}\n\nSort by sum and elminate all the sums >=N\nand you had the rules: xi cannot go with xj when xi+xj >= N\n\nThird with 3 elments:\nYou create all the part that respect the above rule.\nAnd idem step 2\netc...\n\nExample:\n\n```\nX={1,2,4,7,9,10} N=9\n\nstep one:\n{9}\nX'={1,2,4,7,9}\n\nstep 2: cannot chose 9 and 10\nX={(1,2) (1,4) (2,4) (1,7) (2,7) (4,7)}\n{2,7}\nX'={(1,2) (1,4) (2,4) (1,7)}\n\nstep 3: 4 and 2 cannot go with 7:\nX={(1,2,4)}\nno sol\n\n{9} {2,7} are the only solutions\n```\n\n\nThis diminishes the total number of comparaison (that would be 2^n = 2^6=64) you only did : 12 comparaisons\n\nhope it helps\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Longest common subsequence using Dynamic programming\r\n                \r\nI am trying to implement the code of the longest common subsequence(LCS) using Dynamic Programming. I have chosen two strings \"abcdef\" and \"abcdfe\".The answer should be 6 but I am getting 5.I have checked the code and algorithm several times.\nBelow is the code.\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\nint max(int a,int b){\n    return a>b?a:b;\n}\n\nvoid c(){\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\n\n#ifndef ONLINE_JUDGE\n\nfreopen(\"input.txt\", \"r\", stdin);\n\nfreopen(\"output.txt\", \"w\", stdout);\n\n#endif // ONLINE_JUDGE\n\n}\n\nint main() {\nc();\nstring str1=\"abcdef\",str2=\"abcdfe\";\nint n=str1.length(),m=str2.length();\nint t[n+1][m+1];\nfor(int i=0;i<n+1;i++){\n    for(int j=0;j<m+1;j++){\n         t[i][j]=0;\n    }\n}\nfor(int i=1;i<n+1;i++){\n    for(int j=1;j<m+1;j++){\n        if(str1[i-1]==str2[j-1]){\n            t[i][j]=1+t[i-1][j-1];\n        }\n        else{\n            t[i][j]=max(t[i-1][j],t[i][j-1]);\n        }\n    }\n}\n\nfor(int i=0;i<n+1;i++){\n    for(int j=0;j<m+1;j++){\n        cout<<t[i][j]<<\" \";\n    }\n    cout<<endl;\n}\nreturn 0;\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "dynamic programming: coin change\r\n                \r\nI have as an input:\n\n\nthe number of testcases\nan amount of money\n\n\nAs output I need:\n\n\nThe number different coins we have and the value of each coin.\n\n\nThe program should determine whether there is a solution or not, so the output should be either a \"yes\" or a \"no\".\n\nI wrote the program using dynamic programming, but it only works when I enter one testcase at a time If i write let's say 200 testcases at once, the output isn't always right. \n\nI'm assuming that I have an issue with incorrectly saved state between test cases. \nMy question is, how could I solve this problem? I'm only asking for some advice.\n\nHere's my code:\n\n```\n#include<iostream>\n#include<stdio.h>\n#include<string>\n\n#define max_muenzwert 1000\n\n  using namespace std;\n\n\n  int coin[10];//max. 10 coins\n  int d[max_muenzwert][10];//max value of a coin und max. number of coins\n\n  int tabelle(int s,int k)//computes table\n  {   \n    if(d[s][k]!=-1) return d[s][k];\n    d[s][k]=0; \n\n    for(int i=k;i<=9&&s>=coin[i];i++)\n      d[s][k]+=tabelle(s-coin[i],i);\n\n\n    return d[s][k];\n }\n\n int main()\n\n {\n    int t;\n    for(cin>>t;t>0;t--)//number of testcases\n\n     {        \n\n                int n;   //value we are searching   \n           scanf(\"%d\",&n)==1;             \n          int n1;              \n\n    cin>>n1;//how many coins\n\n    for (int n2=0; n2<n1; n2++)\n    {\n        cin>>coin[n2];//value of coins\n        }\n\n    memset(d,-1,sizeof(d));//set table to -1\n\n    for(int i=0;i<=9;i++)\n    {\n             d[0][i]=1;//set only first row to 1 \n             }\n\n      if(tabelle(n,0)>0) //if there's a solution\n      {\n                    cout<<\"yes\"<<endl;\n\n                    }\n      else //no solution\n      {\n           cout<<\"no\"<<endl;\n\n      }\n\n\n\n\n\n      }\n      //system(\"pause\");\nreturn 0;\n}\n```\n\n    ", "Answer": "\r\nAs you can see you have variable number of coins, which you are taking input using this line: ```\ncin>>n1;//how many coins```\n. But in the ```\ntabelle```\n method you are always looping through ```\n0 - 9```\n, which is wrong. You should only loop through ```\n0 - n1```\n. Try this test case:\n\n\n2\n10\n2\n2 5\n\n10\n1\n9\n\n\nFor the second test set your answer should be ```\nno```\n but your program will say ```\nyes```\n as it will find 5 in the second element of your coin array.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming solving an algorithm\r\n                \r\nUsing Dynamic Programming approach calculate the value H(7) for the function H\ndefined so that H(1)=2, H(2)=3 and, for all integers i>2, we have:\nH(i)=H(i-2)-H(i-1)+2.\n\nI have looked up, watch videos and read about Dynamic Programming. But still struggling with the above question. I understand you solve the main problem by solving smaller problems beforehand. You then have more chance of solving the main problem because you can refer to your previous founding. And these prior results you have found are passed into a result but this is what I can't do with this question. \n\nH(1)=H(1-2)-H(1-1)+2.\nH(2)=H(2-2)-H(2-1)+2.\nH(3)=H(3-2)-H(3-1)+2.\nH(4)=H(4-2)-H(4-1)+2.\nH(5)=H(5-2)-H(5-1)+2.\nH(6)=H(6-2)-H(6-1)+2.\n\nI'm presuming the simple computation of these should be put into a table and then I'm somehow supposed to use this information to then work out H(7).\n\nAm I getting the complete wrong idea or doing it correctly, I don't know =[ Also this is revision for finals. \n    ", "Answer": "\r\nYour task is similiar to fibonnaci :) \nFirst i will explain you fibonacci.\n\nF(1) = 1\nF(2) = 1\nF(N) = F(N - 1) + F(N - 2) , for every N > 2\n\nFirst few fibonacci numbers:\nF(1) = 1\nF(2) = 1\nF(3) = F(2) + F(1) = 2\nF(4) = F(3) + F(2) = 3\nF(5) = F(4) + F(3) = 5\n...\n\nYou can see more on: http://en.wikipedia.org/wiki/Fibonacci_number\n\nFibonacci sequence of Fibonacci numbers is defined by the recurrence relation. Fibonacci sequence is recursive sequence.\n\nEvery recursion must have:\n1) base case(s)\n2) recurrence relation\n\nIn case of Fibonacci, base cases are: F(1), which equals 1 and F(2) which also equals 1. Recurrence relation is relation that \"connects\" smaller instances of the same problem. In case of Fibonacci numbers if you wanna know F(N) , you have to know F(N - 1) and F(N - 2), for all N > 2, and thats it. In case of Fibonacci, recurrence relation is F(N) = F(N - 1) + F(N - 2).\n\nHere is code:\n\n```\n#include <cstdio>\n#include <cstdlib>\n\nusing namespace std;\n\nint f(int n) {\n\n    //printf(\"n = %d\\n\", n);\n    if(n == 1 || n == 2) // base case\n        return 1;\n    return f(n - 1) + f(n - 2); // recurrence relation\n\n}\n\nint main() {\n\n    int n; scanf(\"%d\", &n);\n    printf(\"%d\\n\", f(n));\n\n    return 0;\n}\n```\n\n\nIf you remove printf that is commented you will see that many values of Fibonacci are computed over and over again and that is very inefficient. Try running this code for F(45), and you will see why it's very inefficient.\n\nThis is where dynamic programming comes in. As you can see, many fibonacci values are computed over and over again, and we can use memoization to save them in table and if we need them we can just return them from table. Here is code:\n\n```\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\nusing namespace std;\nconst int N = 50;\n\nlong long memo[N];\n\nlong long f(int n) {\n    if(memo[n] != -1) // if we already computed the value of f(N), then return that value\n        return memo[n];\n    return memo[n] = f(n - 1) + f(n - 2); // else compute the value, and save it into the table\n}\n\nint main() {\n\n    memset(memo, -1, sizeof(memo));\n\n    memo[1] = memo[2] = 1; // add answer for base case to the table\n\n    int n; scanf(\"%d\", &n);\n    printf(\"%lld\\n\", f(n));\n\n    return 0;\n}\n```\n\n\nAnd finnaly, your question.\n\nAs Fibonacci, you can save the computed value of h(N). Here is a code:\n\n```\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\nusing namespace std;\nconst int N = 25;\n\nint check, memo[N];\n\nint f(int x) {\n    if(memo[x] != check) // if f(n) was already computed\n        return memo[x]; // return computed value\n    return memo[x] = f(x - 2) - f(x - 1) + 2; // else compte given value and add it to a table\n}\n\nint main() {\n\n    memset(memo, 63, sizeof(memo)); // very big number, if the value of h(n) is different then that very big number, then we know we have computed the value for h(n)\n    check = memo[0];\n\n    memo[1] = 2; // base case\n    memo[2] = 3; // base case\n\n    int n; scanf(\"%d\", &n);\n    printf(\"%d\\n\", f(n));\n\n    return 0;\n}\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming: Find longest subsequence that is zig zag\r\n                \r\nCan anyone please help me understand the core logic behind the solution to a problem mentioned at http://www.topcoder.com/stat?c=problem_statement&pm=1259&rd=4493\n\nA zig zag sequence is one that alternately increases and decreases. So, 1 3 2 is zig zag, but 1 2 3 is not. Any sequence of one or two elements is zig zag. We need to find the longest zig zag subsequence in a given sequence. Subsequence means that it is not necessary for elements to be contiguous, like in the longest increasing subsequence problem. So, 1 3 5 4 2 could have 1 5 4 as a zig zag subsequence. We are interested in the longest one.\n\nI understand that this is a dynamic programming problem and it is very similar to How to determine the longest increasing subsequence using dynamic programming?.\n\nI think any solution will need an outer loop that iterates over sequences of different lengths, and the inner loop will have to iterate over all sequences.\n\nWe will store the longest zig zag sequence ending at index i in another array, say dpStore at index i. So, intermediate results are stored, and can later be reused. This part is common to all Dynamic programming problems. Later we find the global maximum and return it.\n\nMy solution is definitely wrong, pasting here to show what I've so far. I want to know where I went wrong.\n\n```\n    private int isZigzag(int[] arr)\n{\n    int max=0;\n    int maxLength=-100;\n    int[] dpStore = new int[arr.length];\n\n    dpStore[0]=1;\n\n    if(arr.length==1)\n    {\n        return 1;\n    }\n    else if(arr.length==2)\n    {\n        return 2;\n    }\n    else \n    {           \n        for(int i=3; i<arr.length;i++)\n        {\n            maxLength=-100;\n            for(int j=1;j<i && j+1<=arr.length; j++)\n            {\n                if(( arr[j]>arr[j-1] && arr[j]>arr[j+1])\n                    ||(arr[j]<arr[j-1] && arr[j]<arr[j+1]))\n                {\n                    maxLength = Math.max(dpStore[j]+1, maxLength);\n                }\n            }\n            dpStore[i]=maxLength;               \n        }\n    }\n    max=-1000;\n    for(int i=0;i<arr.length;i++)\n    {\n        max=Math.max(dpStore[i],max);\n    }\n    return max; \n}\n```\n\n    ", "Answer": "\r\nThis is what the problem you linked to says:\n\nA sequence of numbers is called a zig-zag sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a zig-zag sequence.\nFor example, 1,7,4,9,2,5 is a zig-zag sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, 1,4,7,2,5 and 1,7,4,5,5 are not zig-zag sequences, the first because its first two differences are positive and the second because its last difference is zero.\nGiven a sequence of integers, sequence, return the length of the longest subsequence of sequence that is a zig-zag sequence. A subsequence is obtained by deleting some number of elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.\n\nThis is completely different from what you described in your post. The following solves the actual topcoder problem.\n```\ndp[i, 0] = maximum length subsequence ending at i such that the difference between the\n           last two elements is positive\ndp[i, 1] = same, but difference between the last two is negative\n\nfor i = 0 to n do     \n   dp[i, 0] = dp[i, 1] = 1\n\n   for j = 0 to to i - 1 do\n    if a[i] - a[j] > 0\n      dp[i, 0] = max(dp[j, 1] + 1, dp[i, 0])\n    else if a[i] - a[j] < 0\n      dp[i, 1] = max(dp[j, 0] + 1, dp[i, 1])\n    \n```\n\nExample:\n```\ni        = 0  1   2  3   4   5   6   7  8   9\na        = 1  17  5  10  13  15  10  5  16  8 \ndp[i, 0] = 1  2   2  4   4   4   4   2  6   6    \ndp[i, 1] = 1  1   3  3   3   3   5   5  3   7\n           ^  ^   ^  ^\n           |  |   |  -- gives us the sequence {1, 17, 5, 10}\n           |  |   -- dp[2, 1] = dp[1, 0] + 1 because 5 - 17 < 0.\n           |  ---- dp[1, 0] = max(dp[0, 1] + 1, 1) = 2 because 17 - 1 > 0\n     1 element\n   nothing to do\n the subsequence giving 7 is 1, 17, 5, 10, 5, 16, 8, hope I didn't make any careless\n mistakes in computing the other values)\n```\n\nThen just take the max of both ```\ndp```\n arrays.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "dynamic programming: coin change\r\n                \r\nI have as an input:\n\n\nthe number of testcases\nan amount of money\n\n\nAs output I need:\n\n\nThe number different coins we have and the value of each coin.\n\n\nThe program should determine whether there is a solution or not, so the output should be either a \"yes\" or a \"no\".\n\nI wrote the program using dynamic programming, but it only works when I enter one testcase at a time If i write let's say 200 testcases at once, the output isn't always right. \n\nI'm assuming that I have an issue with incorrectly saved state between test cases. \nMy question is, how could I solve this problem? I'm only asking for some advice.\n\nHere's my code:\n\n```\n#include<iostream>\n#include<stdio.h>\n#include<string>\n\n#define max_muenzwert 1000\n\n  using namespace std;\n\n\n  int coin[10];//max. 10 coins\n  int d[max_muenzwert][10];//max value of a coin und max. number of coins\n\n  int tabelle(int s,int k)//computes table\n  {   \n    if(d[s][k]!=-1) return d[s][k];\n    d[s][k]=0; \n\n    for(int i=k;i<=9&&s>=coin[i];i++)\n      d[s][k]+=tabelle(s-coin[i],i);\n\n\n    return d[s][k];\n }\n\n int main()\n\n {\n    int t;\n    for(cin>>t;t>0;t--)//number of testcases\n\n     {        \n\n                int n;   //value we are searching   \n           scanf(\"%d\",&n)==1;             \n          int n1;              \n\n    cin>>n1;//how many coins\n\n    for (int n2=0; n2<n1; n2++)\n    {\n        cin>>coin[n2];//value of coins\n        }\n\n    memset(d,-1,sizeof(d));//set table to -1\n\n    for(int i=0;i<=9;i++)\n    {\n             d[0][i]=1;//set only first row to 1 \n             }\n\n      if(tabelle(n,0)>0) //if there's a solution\n      {\n                    cout<<\"yes\"<<endl;\n\n                    }\n      else //no solution\n      {\n           cout<<\"no\"<<endl;\n\n      }\n\n\n\n\n\n      }\n      //system(\"pause\");\nreturn 0;\n}\n```\n\n    ", "Answer": "\r\nAs you can see you have variable number of coins, which you are taking input using this line: ```\ncin>>n1;//how many coins```\n. But in the ```\ntabelle```\n method you are always looping through ```\n0 - 9```\n, which is wrong. You should only loop through ```\n0 - n1```\n. Try this test case:\n\n\n2\n10\n2\n2 5\n\n10\n1\n9\n\n\nFor the second test set your answer should be ```\nno```\n but your program will say ```\nyes```\n as it will find 5 in the second element of your coin array.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming Solution for TSP in C++\r\n                \r\nI have been trying to implement Dynamic Programming solution for TSP (Travelling Salesperson Problem) in C++. My code compiles but when I try to run the object file the program stops working and I am forced to close it.\n\nHere is the code:\n\n```\nint tsp(std::vector<std::vector<int>> matrix) {\n\n   int n = matrix[0].size();\n   std::vector<std::vector<int>> A;  // Vertex, Set-Size\n   std::set<int> S;\n\n   for(int i = 0; i < n; ++i) {\n       S.insert(i);\n   }\n\n   for(int i = 0; i < n; i++) {\n       if(S.size() == 2) {\n           A[i][2] = matrix[1][i];\n       }\n       else if(S.size() > 2) {\n           std::set<int>::iterator it;\n           for(it = S.begin(); it != S.end(); ++it) {\n               int s = S.size();\n               S.erase(i);\n               int sd = S.size();\n               int k = *it;\n               if((k != i) && (k != 1) && (A[i][s] > (matrix[k][i] + A[k][sd]))) {\n                   A[i][s] = matrix[k][i] + A[k][sd];\n               }\n           }\n       }\n   }\n\n   return A[1][n];\n}\n```\n\n\nCan someone please point out what mistake I am making.\n    ", "Answer": "\r\nYou need to fill or resize a ```\nstd::vector```\n before calling ```\noperator[int]```\n on it. A vector is basically an array that holds its size. So any out of bound access will cause a segmentation fault in runtime (if you are lucky) or will corrupt your memory. \n\nYou have a vector of vectors here, so you will need to iterate over two ranges and fill (or resize) vectors properly:\n\n```\nstd::vector<std::vector<int>> A;  // Vertex, Set-Size\nfor(int i=size; i>0; --i)\n   A.push_back(std::vector<int>);\nfor(int i=size; i>0; --i)\n   for(int j=size; j>0; --j)\n     A[i][j] = 0;\n```\n\n\nEven better:\n\n```\nA.resize(size);\nfor(auto& v : a)        // (since you already have c++11)\n  v.resize(size, val);  // fill with val\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming - \"maximize\" matrix chain multiplication\r\n                \r\nI'm now practice dynamic programming by myself. For the classic problem \"matrix-chain multiplication\" is to find the minimize number of scalar multiplication. Which is,\n\n```\nM[i,j] = 0 if i=j\n       = Min(i<=k<j){M[i,k-1]+M[k,j]+Pi-1*Pj*Pk}\nand its time complexity is O(n^3)\n```\n\n\nBut I'm just curious what if I want to find the \"maximization\"(instead of min) of scalar multiplication, does it exist a optimal structure and is it possible to solve it in polynomial time?\n    ", "Answer": "\r\nThe exact same reasoning as the minimization applies:\n\n\nIf you multiply a1 ... ai, the resulting matrix dimension does not rely on the internal parenthetization.\nIt follows that that if the optimal - that is, most expensive - partition of a1 ... ai ... an is to multiply the matrices from 1 to i and from i + 1 to n, then it is composed of the optimal solutions to a1 ... ai and ai + 1 ... an\n\n\nSince the optimal substructure remains, you can use the same algorithm as minimization (of course, changing the criteria for optimality from minimum to maximum).\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Ways to memoize in c++, Dynamic programming\r\n                \r\nI am fairly new to dynamic programming, i have seen people, memoize in javascript using objects. But i would like to know what will be the most efficient way to memoize in c++.\nWhich data structure should i use, is map good? orr is there something better, please let me know.\n    ", "Answer": "\r\nI think you should use unordered_map instead of map.\nThe reason is that the time complexity for the search operation are as follow:\n\nunordered_map = O(1)\nmap = O(log(N))\n\nThe reason is that unordered_map works as a hash table while map works as a binary tree.\nSimilarly, you can also use unordered_set instead of set for the same reason:\nThe time complexity for the search operation are as follow:\n\nunordered_set = O(1)\nset = O(log(N))\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Compile Error : Non-Constant Array Bound (Dynamic Programming)\r\n                \r\nIm trying to solve the minimum path sum problem of Dynamic programming using golang and below is my program for that which shows compilation error.\n\n```\nenter code here\nfunc minPathSum(grid [][]int) int {\n    var dp[m+1][n+1] int\n    dp[0][0] = grid[0][0]\n\n    //for column initialization\n    for i := 0; i <= m; i++ {\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    }\n\n    //for row initialization\n    for j := 0; j <= n; j++ {\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    }\n    for i := 0; i <= m; i++ {\n        for j := 0; j <= n; j++ {\n            dp[i][j] = min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1]) + grid[i][j]\n        }\n    }\n    return dp[m][n]\n}\n```\n\n    ", "Answer": "\r\nAs @Motakjuq mentioned in comment: you cannot define a dynamic array, both dimensions must be constant for an array, but slice will help you.\n\nUse something like this:\n\n```\ndp := make([][]int, m)\nfor i := range dp {\n    dp[i] = make([]int, n)\n}\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Time Complexity for Knapsack Dynamic Programming solution\r\n                \r\nI saw the recursive dynamic programming solution to 0-1 Knapsack problem here. I memoized the solution and came up with the following code.\n\n```\nprivate static int knapsack(int i, int W, Map<Pair<Integer, Integer>>, Integer> cache)\n{\n if (i < 0) {\n    return 0;\n }\nPair<Integer, Integer> pair = new Pair<>(i,W);\nif (cache.contains(pair)) {\n  return cache.get(pair)\n}\nint result = -1;\nif (weights[i] > W) {\n    result = knapsack(i-1, W);\n} else {\n    result = Math.max(knapsack(i-1, W), knapsack(i-1, W - weights[i]) + values[i]);\n}\ncache.put(pair, result);\nreturn result;\n}\n```\n\n\nCan someone explain to me why should the time complexity be O(nW) where n is the number of items and W is the restriction on weight. \n    ", "Answer": "\r\nIt's more obvious if you think through what the table would look like in a tabular implementation of the DP. It has items on one axis and max achievable weight on the other, with one row per possible integer weight. For some weight sets, the table must be densely filled to find the optimum answer.  These same weight sets will require Omega(nW) pairs in your memo hash, ergo since each entry is a constant time computation, the same time to compute all. It's a good exercise to think through how to get the costly weight sets, so I'll let that to you. \n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Find all subset sum using dynamic programming\r\n                \r\nI want to use dynamic programming to find all subset of an array that sums to a target,like:\n\narr = [1,3,2,4]\n\ntarget = 6\n\noutput:\n\n[1,3,2],[2,4]\n\nHow can i modify the code to get solution? thanks\n\n```\ndef CheckSubsetSum(S, M):\n    n = len(S)\n    subset = np.array([[True]*(M+1)]*(n+1))\n    for i in range(0,n):\n        subset[i,0] = True\n\n    for j in range(1,M+1):\n        subset[0,j] =False \n\n    for i in range(1,n+1):\n        for j in range(1,M+1):\n            if j<S[i-1]:\n                subset[i,j] = subset[i-1,j]\n            else:\n                subset[i,j] = subset[i-1,j] or subset[i-1,j-S[i-1]]\n    print(subset)\nCheckSubsetSum([1,3,2,4],6)\n```\n\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "trouble with solving knapsack issue via dynamic programming in C\r\n                \r\nI need to solve the knapsack problem recursively, memoized and with dynamic programming. Currently I'm stuck at the dynamic programming method.\n\nI adapted the code from what I found elsewhere on the internet. Currently the output is not correct.\n\nThe problem involves profit and mass. Each item has a profit and mass associated, there is a MAX_N (umber) of items available and a MAX_CAPACITY for mass. The aim is to have as much \"profit\" in the knapsack as possible.\n\nHere is an example provided by the exercise:\n\n\n  Example: Given a knapsack of capacity 5, and items with mass[] = {2, 4, 3, 2}\n  and profit profit[] = {45, 40, 25, 15}, the best combination would be item 0 (with mass 2 and profit 45) and item 2 (with mass 3 and with profit 25) for a total profit of 70. No other combination with mass 5 or less has a greater profit.\n\n\nHere is the complete code:\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 10\n#define MAX_CAPACITY 165\n\nint m[MAX_N][MAX_CAPACITY];\n\nint max(int x, int y) {\n    return x ^ ((x ^ y) & -(x < y));\n}\n\nint min(int x, int y) {\n    return y ^ ((x ^ y) & -(x < y));\n}\n\nint knapsackRecursive(int capacity, int mass[], int profit[], int n) {\n\n    if (n < 0)\n        return 0;\n\n    if (mass[n] > capacity)\n        return knapsackRecursive(capacity, mass, profit, n-1);\n\n    else\n        return max(knapsackRecursive(capacity, mass, profit, n-1), knapsackRecursive(capacity - mass[n], mass, profit, n-1) + profit[n]);\n\n}\n\nint knapsackMemoized(int capacity, int mass[], int profit[], int n) {\n\n}\n\nint knapsackDynamic(int capacity, int mass[], int profit[], int n) {\n\n    int i;\n    int j;\n\n    for (i = 0; i <= n; i++) {\n\n        for (j = 0; j <= capacity; j++) {\n\n            if (i == 0 || j == 0)\n                m[i][j] = 0;\n\n            else if (mass[i-1] <= j)\n                m[i][j] = max(profit[i-1] + m[i-1][j-mass[i-1]], m[i-1][j]);\n\n            else\n                m[i][j] = m[i-1][j];\n        }\n    }\n\n    return m[n][capacity];\n\n}\n\nvoid test() {\n\n    // test values\n    //int M1[MAX_N] = {2, 4, 3, 2};\n    //int P1[MAX_N] = {45, 40, 25, 10};\n\n    int M1[MAX_N] = {6, 3, 2, 4};\n    int P1[MAX_N] = {50, 60, 40, 20};\n\n    int M2[MAX_N] = {23, 31, 29, 44, 53, 38, 63, 85, 89, 82};\n    int P2[MAX_N] = {92, 57, 49, 68, 60, 43, 67, 84, 87, 72};\n\n    // a)\n    printf(\"Recursion: %d\\n\",knapsackRecursive(MAX_CAPACITY, M1, P1, MAX_N));\n    printf(\"Recursion: %d\\n\",knapsackRecursive(MAX_CAPACITY, M2, P2, MAX_N));\n    printf(\"\\n\");\n\n    // b)\n    printf(\"Memoization: %d\\n\",knapsackMemoized(MAX_CAPACITY, M1, P1, MAX_N));\n    printf(\"Memoization: %d\\n\",knapsackMemoized(MAX_CAPACITY, M2, P2, MAX_N));\n    printf(\"\\n\");\n\n    // c)\n    printf(\"Dynamic Programming: %d\\n\",knapsackDynamic(MAX_CAPACITY, M1, P1, MAX_N));\n    printf(\"Dynamic Programming: %d\\n\",knapsackDynamic(MAX_CAPACITY, M2, P2, MAX_N));\n\n}\n\nint main() {\n    test();\n}\n```\n\n\nThis is the output I currently get. The recursive method should be supplying the correct result, but the dynamic programming one currently doesn't output the same. Memoization is not done yet, hence it doesn't output correctly either.\n\n```\nRecursion: 170\nRecursion: 309\n\nMemoization: 2686680\nMemoization: 2686600\n\nDynamic Programming: 0\nDynamic Programming: 270\n\nProcess returned 25 (0x19)   execution time : 0.269 s\nPress any key to continue.\n```\n\n    ", "Answer": "\r\nIt turns  out that the code I used for writing the dynamic programming part was supposed to work with ```\nint m[MAX_N+1][MAX_CAPACITY+1];```\n instead of int ```\nm[MAX_N][MAX_CAPACITY];```\n. \n\nChanging that has gotten me to a working code, if not really the code I wanted.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming On Intervals\r\n                \r\nYou are a given an array of contiguous intervals i.e. ```\n{ [a,b],[b,c],[c,d],...,[g,h],[h,i] }```\n\nGiven a query of type ```\nn m k```\n, we need to output the number of intervals between ```\nn,m (inclusive, 1-based indexing)```\n containing ```\nk```\n.\n\nMy Approach : ( Naively check for all the intervals between ```\nn,m```\n and keeping a counter. )\n\nThis works if ```\nm-n```\n and number of queries are small, but this would be really inefficient for larger values of ```\nn,m```\n and multiple queries.\n\nSo I was thinking of a Dynamic Programming approach such that we can save number of intervals containing ```\nz```\n upto an interval numbered say ```\nx```\n in the array ```\ndp[x][z]```\n, then I can answer any query ```\nn m k```\n as ```\ndp[m][k]-dp[n][k]```\n. But this also fails if intervals given in the array are too large as it would take greater time to construct the ```\ndp```\n array.\n\nHow do I get around this or is there a simpler approach that I am missing?\n\nAny hints would be helpful.\n\nExample :\n\nArray : ```\n{ [1,3],[3,2],[2,1],[1,5],[5,3] }```\n\n\nQueries : ```\n{ 1 2 2 }```\n , ```\n{ 1 3 3 }```\n , ```\n{ 2 2 4 }```\n\n\nOutput : ```\n{ 2 }```\n , ```\n{ 2 }```\n , ```\n{ 0 }```\n \n    ", "Answer": "\r\nI would solve this problem the following way.\n\nFirst I would introduce another array of data structure of the form:\n\n```\n[(ai,bi,ci)]\n```\n\n\nwhere\n\n```\nai - interval start\nbi - interval end\nci - count of intervals of original sequence hitting interval [ai,bi]\n\nai < bi\na(i+1) = bi\n```\n\n\nso this new data structure covers whole range of original structure, it is increasing and it has the desired count of original interval. \n\nNow to find the count we only need k and perform some kind of binary search to find the interval. \n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Why is this dynamic programming code incorrect? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                It's difficult to tell what is being asked here. This question is ambiguous, vague, incomplete, overly broad, or rhetorical and  cannot be reasonably answered in its current form. For help clarifying this question so that it can be reopened,  visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI am doing this problem for a homework assignment. I have solved the problem using a standard bottom up Dynamic Programming algorithm. My code shows the expected outcomes on my test cases but the website says that it gives incorrect answer. I cannot understand where this code is lacking. Please help me.\n\n```\nimport java.io.*;\nimport java.util.*;\nclass Main300{\n\npublic static void main (String[] args) throws java.lang.Exception{\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    int nn = Integer.parseInt(br.readLine());\n    for(int j = 0 ; j < nn; j++){\n        int n = Integer.parseInt(br.readLine());\n        char[][] a = new char[n][n];\n        int ki = -1;\n        int kj = -1;\n        for(int i = 0 ; i < n ; i++){\n            String s = br.readLine();\n            for(int k = 0 ; k < n; k++){\n                a[i][k] = s.charAt(k);\n                if(a[i][k] == 'K'){\n                    ki = i;\n                    kj = k;\n                }\n            }\n        }\n        System.out.println(ans(a, ki, kj));\n    }\n}\n\nprivate static int ans(char[][] a, int ki, int kj){\n    int[][] x = new int[a.length][a.length];\n    for(int j = a.length-1; j >= 0; j--){\n        for(int i = 0 ; i < a.length; i++){\n            if(a[i][j] == 'P'){\n                x[i][j]++;\n            }\n            if(i-2 >= 0 && j+1 <= a.length-1 && a[i-2][j+1] == 'P'){\n                x[i][j] += x[i-2][j+1];\n            }else if(i-1 >= 0 && j+2 <= a.length-1 && a[i-1][j+2] == 'P'){\n                x[i][j] += x[i-1][j+2];\n            }else if(i+2 <= a.length-1 && j+1 <= a.length-1 && a[i+2][j+1] == 'P'){\n                x[i][j] += x[i+2][j+1];\n            }else if(i+1 <= a.length-1 && j+2 <= a.length-1 && a[i+1][j+2] == 'P'){\n                x[i][j] += x[i+1][j+2];\n            }\n        }\n    }\n    return x[ki][kj];\n}\n}\n```\n\n    ", "Answer": "\r\nThe following are the reasons for wrong answer:\n\na) As the DP formulation will be \n\n```\na[r][c] = max(a[r-2][c+1], a[r-1][c+2], a[r+1][c+2], a[r+2][c+1])```\n \n\nso you need to verify each and every path from the current position. What your code suggest is that you go and do it only on one path(the ```\nelse if's```\n simulate travelling through one path only). \n\nb)Also as @Vinayak pointed out, `a[i-2][j+1] == 'P' will allow you to move to only those places where there is a pawn, which is not necessarily true. You can think of very trivial examples to verify this.\n\nHere is the code:\n\n```\nimport java.io.*;\nimport java.util.*;\n\nclass e1_test{\n\n    public static void main (String[] args) throws java.lang.Exception{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int nn = Integer.parseInt(br.readLine());\n        for(int j = 0 ; j < nn; j++){\n            int n = Integer.parseInt(br.readLine());char[][] a = new char[n][n];\n            int ki = -1;\n            int kj = -1;\n            for(int i = 0 ; i < n ; i++){\n                String s = br.readLine();\n                for(int k = 0 ; k < n; k++){\n                    a[i][k] = s.charAt(k);\n                    if(a[i][k] == 'K'){\n                        ki = i;\n                        kj = k;\n                    }\n                }\n            }\n            System.out.println(ans(a, ki, kj));\n        }\n    }\n\n    private static int ans(char[][] a, int ki, int kj) {\n        int[][] x = new int[a.length][a.length];\n        for(int j = a.length-1; j >= 0; j--) {\n            for(int i = 0 ; i < a.length; i++) {\n                if(a[i][j] == 'P') {\n                    x[i][j]++;\n                }\n                int temp=0;\n                //note the changes from else if's to only if's\n                //removal of [i-2][j+1] == 'P' condition. \n                if(i-2 >= 0 && j+1 <= a.length-1) {\n                    if(temp < x[i-2][j+1])\n                        temp = x[i-2][j+1];\n                }\n                if(i-1 >= 0 && j+2 <= a.length-1) {\n                    if(temp < x[i-1][j+2])\n                        temp = x[i-1][j+2];\n                }\n                if(i+2 <= a.length-1 && j+1 <= a.length-1) {\n                    if(temp < x[i+2][j+1])\n                        temp = x[i+2][j+1];\n                }\n                if(i+1 <= a.length-1 && j+2 <= a.length-1) {\n                    if(temp < x[i+1][j+2])\n                        temp = x[i+1][j+2];\n                }\n                x[i][j] += temp;\n            }\n        }\n        return x[ki][kj];\n    }\n}\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming with memoization taking longer than brute force approach\r\n                \r\nI solved this challenge initially using Brute force and it got accepted. I was trying to make use of dynamic programming with memoization to reduce the time complexity from ```\nO(2^n)```\n. \n\nThe dynamic programming with memoization was taking longer than the brute force approach and I'm getting a Time Limit Exceeded error message. \n\nBrute force Approach Code.\n\n```\npublic class Dummy\n{\n    private int answer = 0;\n    private int numberCalled = 0;\n    public bool doFindSum(ref int[] nums, int index, int current, int target)\n    {\n        numberCalled++;\n        if (index + 1 == nums.Length)\n        {\n            if (current == target)\n            {\n                ++answer;\n                return true;\n            }\n            else\n            {\n                return false;\n            }\n        }\n        bool add = doFindSum(ref nums, index + 1, current + nums[index + 1], target);\n        bool minus = doFindSum(ref nums, index + 1, current - nums[index + 1], target);\n        return add || minus;\n    }\n    public int FindTargetSumWays(int[] nums, int S)\n    {\n        numberCalled = 0;\n        doFindSum(ref nums, -1, 0, S);\n        Console.WriteLine(\"Nums Called = {0}\", numberCalled);\n        return answer;\n    }\n}\n```\n\n\nDynamic Programming with Memoization Code\n\n```\npublic class DP\n{\n    private Dictionary<int, Dictionary<int, int>> dp;\n    private int numberCalled = 0;\n    public int doFindSum(ref int[] nums, int index, int current, int target)\n    {\n        numberCalled++;\n        Dictionary<int, int> temp;\n        if (dp.TryGetValue(index + 1, out temp))\n        {\n            int value;\n            if (temp.TryGetValue(current, out value))\n            {\n                return value;\n            }\n        }\n        if (index + 1 == nums.Length)\n        {\n            if (current == target)\n            {\n                if (!dp.ContainsKey(index + 1))\n                {\n                    dp.Add(index + 1, new Dictionary<int, int>() { { current, 1 } });\n                    return 1;\n                }\n            }\n            return 0;\n        }\n        int add = doFindSum(ref nums, index + 1, current + nums[index + 1], target);\n        int minus = doFindSum(ref nums, index + 1, current - nums[index + 1], target);\n        if ((!dp.ContainsKey(index + 1)) && (add + minus) > 0)\n        {\n            dp.Add(index + 1, new Dictionary<int, int>() { { current, add + minus } });\n        }\n        return add + minus;\n    }\n    public int FindTargetSumWays(int[] nums, int S)\n    {\n        numberCalled = 0;\n        dp = new Dictionary<int, Dictionary<int, int>>(); // index , sum - count\n        var answer =  doFindSum(ref nums, -1, 0, S);\n        Console.WriteLine(\"Nums Called = {0}\", numberCalled);\n        return answer;\n    }\n}\n```\n\n\nAnd the Code to driver code the measure the time taken by each approach\n\n```\npublic static void Main(string[] args)\n        {\n\n             var ip = new int[][] { new int [] { 0, 0, 0, 0, 0, 0, 0, 0, 1},\n                                new int [] {6,44,30,25,8,26,34,22,10,18,34,8,0,32,13,48,29,41,16,30},\n                                new int []{7,46,36,49,5,34,25,39,41,38,49,47,17,11,1,41,7,16,23,13 }\n            };\n        var target = new int[] { 1, 12, 3 };\n        for (int i = 0; i < target.Length; i++)\n        {\n            var sw = Stopwatch.StartNew();\n            var dummy = new Dummy();\n            Console.WriteLine(\"Brute Force  answer => {0},  time => {1}\", dummy.FindTargetSumWays(ip[i], target[i]), sw.ElapsedMilliseconds);\n            sw.Restart();\n            var dp = new DP();\n            Console.WriteLine(\"DP with memo answer => {0},  time => {1}\", dp.FindTargetSumWays(ip[i], target[i]), sw.ElapsedMilliseconds);\n        }\n        #endregion\n        Console.ReadLine();\n    }\n```\n\n\nAnd the ouptut for this is \n\n```\nNums Called = 1023\nBrute Force  answer => 256,  time => 1\nNums Called = 19\nDP with memo answer => 256,  time => 1\nNums Called = 2097151\nBrute Force  answer => 6692,  time => 29\nNums Called = 2052849\nDP with memo answer => 6692,  time => 187\nNums Called = 2097151\nBrute Force  answer => 5756,  time => 28\nNums Called = 2036819\nDP with memo answer => 5756,  time => 176\n```\n\n\nI'm not sure why the time for the Dynamic approach is more even though the number of times the ```\ndoFindSum```\n method called is lesser for this approach. \n    ", "Answer": "\r\nNo wonder your brute force got accepted as in worst case it would be O(2^SizeOfArray).\n\n\n\norder of 2^20 in our case i.e. approx. order of 1e6 operations, 20 is the upper-bound of array size in input as mentioned in the question. If this was high it would probably get timed out unlike DP solution as we will see.\n\n\n\nComing to the DP solution our recursive relation would be like:\n\n```\nfor all S in range(-MaxSum,MaxSum) and i in range(1,SizeOfArray)\n     count[i][S] = count[ i-1 ][ S-arr[i] ] + count[ i-1 ][ S+arr[i] ] \n```\n\n\nFor simplicity, just focus on this part:\n\n```\ncount[i][S] = count[ i-1 ][ S-arr[i] ] + count[ i-1 ][ S+arr[i] ] \n```\n\n\nIt only depends on previous state. So you can optimize this in space like 0-1 Knapsack problem as the problem completely depends only on the previous state.\n\nThe run-time complexity would be ```\nO(2*SizeOfArray*MaxPossibleSum)```\n which in our case is O(2*20*1000) which is definitely less than brute-force solution. The space complexity of optimized code will be ```\nO(MaxSum)```\n.\n\nNow regarding problem with your code:\n\nIn dynamic programming, solving a big problem should solve many smaller problems which will be solved only once and reused many times. It is called overlapping sub-problems property. In this case, your code doesn't seem to exploit this. Why? Because in our problem the DP state is made of two variables \"```\nindex```\n\" and \"```\ncurrent```\n\" as you have declared but you are entering the memo only based on index. This was the problem. I have made some corrections in your code. Now it runs faster than brute-force one.\n\n```\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\npublic class Dummy\n{\n    private int answer = 0;\n    private int numberCalled = 0;\n    public bool doFindSum(ref int[] nums, int index, int current, int target)\n    {\n        numberCalled++;\n        if (index + 1 == nums.Length)\n        {\n            if (current == target)\n            {\n                ++answer;\n                return true;\n            }\n            else\n            {\n                return false;\n            }\n        }\n        bool add = doFindSum(ref nums, index + 1, current + nums[index + 1], target);\n        bool minus = doFindSum(ref nums, index + 1, current - nums[index + 1], target);\n        return add || minus;\n    }\n    public int FindTargetSumWays(int[] nums, int S)\n    {\n        numberCalled = 0;\n        doFindSum(ref nums, -1, 0, S);\n        Console.WriteLine(\"Nums Called = {0}\", numberCalled);\n        return answer;\n    }\n}\n\npublic class DP{\n    private Dictionary<Tuple<int,int>,int> dp;\n    private int numberCalled = 0;\n    private int tp1=0;\n    public int doFindSum(ref int[] nums, int index, int current, int target)\n    {\n        numberCalled++;\n        Tuple<int,int> tp=new Tuple<int,int>(index+1,current);\n        int value;\n        if (dp.TryGetValue(tp, out value))\n        {\n                tp1++;\n                return value;\n        }\n        if (index + 1 == nums.Length)\n        {\n            if (current == target)\n            {\n                if (!dp.ContainsKey(tp))\n                {\n                    dp.Add(tp, 1);\n                    return 1;\n                }\n            }\n            return 0;\n        }\n        int add = doFindSum(ref nums, index + 1, current + nums[index + 1], target);\n        int minus = doFindSum(ref nums, index + 1, current - nums[index + 1], target);\n        if ((!dp.ContainsKey(tp)))\n        {\n            dp.Add(tp, add + minus);\n        }\n\n        return add + minus;\n\n\n    }\n    public int FindTargetSumWays(int[] nums, int S)\n    {\n        numberCalled = 0;\n        dp = new Dictionary<Tuple<int,int>,int>(); // index , sum - count\n        var answer =  doFindSum(ref nums, -1, 0, S);\n        Console.WriteLine(\"Nums Called = {0} tp={1}\", numberCalled,tp1);\n        return answer;\n    }\n}\n\npublic class sol{\npublic static void Main(string[] args)\n        {\n\n             var ip = new int[][] { new int [] { 0, 0, 0, 0, 0, 0, 0, 0, 1},\n                                new int [] {6,44,30,25,8,26,34,22,10,18,34,8,0,32,13,48,29,41,16,30},\n                                new int []{7,46,36,49,5,34,25,39,41,38,49,47,17,11,1,41,7,16,23,13,1,1,0,0,1,1,1,1,1,1 }\n            };\n        var target = new int[] { 1, 12, 3 };\n        for (int i = 0; i < target.Length; i++)\n        {\n            var sw = Stopwatch.StartNew();\n            var dummy = new Dummy();\n          //  Console.WriteLine(\"Brute Force  answer => {0},  time => {1}\", dummy.FindTargetSumWays(ip[i], target[i]), sw.ElapsedMilliseconds);\n            sw.Restart();\n            var dp = new DP();\n            Console.WriteLine(\"DP with memo answer => {0},  time => {1}\", dp.FindTargetSumWays(ip[i], target[i]), sw.ElapsedMilliseconds);\n        }\n\n        Console.ReadLine();\n    }\n}\n```\n\n\nI must say though today I learnt a little bit of C#. I didn't had any prior experience with it.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming Exercise\r\n                \r\nI have been struggling through a dynamic programming exercise and I can't seem to get the hold of it. I'll write here the problem and also it's solution stating explicitly what I don't understand.\n\nWe are given 2 sequences ```\nu1,u2,...,un```\n and ```\nd1,d2,...,dm```\n and a matrix of dimensions ```\nn x m```\n built of positive integers ```\nC=[cij]```\n. A list of k pairs\n ```\n((ui1, dj1),(ui2,dj2),...,(uik,djk))```\n is said to be non-intersecting if \n```\ni1 < 12 <..< ik```\n and ```\nj1 < j2 <...< jk```\n.\nThe \"compatibility of a list\" is said to be the compatibility of the sum of the pairs that it is made of, that is ```\nCi1j1 + Ci2j2 + ... + Cikjk```\n\n\nExample :\nConsider the matrix ```\nC = [Cij]```\n, so ```\nCij = squared(i + j)```\n. Let i be\n```\ni = 1, 2, 3,  j = 1, 2, 3, 4```\n and ```\nk = 2```\n. Some lists of 2 non-intersecting pairs are these ```\n((u1, d2),(u3, d3))```\n with a compatibility of  ```\n9 + 36 = 45```\n,\n```\n((u2, d2),(u3, d4))```\n, with compatibility ```\n16 + 49 = 65,```\n and ```\n((u1, d1),(u2, d4)),```\n with compatibility of ```\n4 + 36 = 40```\n. Some lists that are not non-intersecting are the following : ```\n((u2, d2),(u3, d1)),((u1, d4),(u3, d3)),((u3, d2),(u2, d3))```\n\n\nSolution:\n\nM(i, j, t) = maximum cost of t non-intersecting pairs taken from ui,...,un and dj,...dm\n\nRecurrence equation :\n```\nM(i, j, t) = max {M(i + 1, j + 1, t − 1) + c(i, j), M(i, j + 1, t),M(i + 1, j, t).}```\n\n\n\n```\nM(i, j, 0) = 0```\n\n```\nM(i, j, t) = −∞, if t > min{n − i + 1, m − j + 1}```\n\n```\nM(i, j, t) = 0, if i > n or j > m```\n\n\n\nI don't under the reccurrence very well and why do we assign ```\n−∞```\n to ```\nM(i, j, t)```\n when  ```\nt > min{n − i + 1, m − j + 1}```\n but 0 when ```\ni > n```\n or ```\nj > m```\n\n\nThe solution is M(1, 1, k).\n    ", "Answer": "\r\n```\nM(i, j, t) = max {M(i + 1, j + 1, t − 1) + c(i, j), M(i, j + 1, t),M(i + 1, j, t).}\n           = max\n             {\n                 M(i+1, j+1, t-1) + c(i, j), <- we know the maximum cost of t-1 \n                                                non-intersecting pairs taken from\n                                                i+1,...,n and j+1,...,m to which\n                                                we prepend the pair (i, j).\n                 M(i, j+1, t), <- keep it at t elements and don't prepend anything,\n                                  and take the one containing elements from\n                                  i,...,n and j+1,...,m\n                 M(i+1, j, t) <- same, but take elements from i+1,...,n and j,...,m\n             }\n```\n\n\nThis covers all cases: either we prepend the current element and increase the length by 1 or we don't increase the length and take the maximum of the possibilities this (lack of) action entails. You might ask \"but what about ```\nM(i+1,j+1,t)```\n? that's also a valid possibility.\" It is, but it's covered by the two other cases: ```\nM(i+1,j,t)```\n will check ```\nM(i+1,j+1,t)```\n and return it if needed. You could add it yourself to the recurrence, it wouldn't be wrong, just redundant.\n\n\n  why do we assign −∞ to M(i, j, t) when  t > min{n − i + 1, m − j + 1}\n\n\nBecause you cannot have a solution in that case. At step ```\ni```\n, you can only pick ```\nn - i + 1```\n elements from the first sequence (because you already picked up to ```\ni```\n). Same for ```\nj```\n. If ```\nt > min{n - i + 1, m - j + 1}```\n, then you will not be able to pick the needed number of elements from one of the lists, and you mark that with negative infinity.\n\n\n  but 0 when i > n or j > m\n\n\nThis is just to handle out of range errors. I'm not sure why they choose ```\n0```\n, I would choose negative infinity for this as well just for consistency, or just avoid it altogether by putting conditions in the implementation (if ```\ni + 1 >= n```\n then ignore this branch, although you'll still need to return 0/-infinity if none of the branches are valid), but it doesn't really matter.\n\nIf you return ```\n0```\n and the answer is negative, then you'll run into problems. Of course, for your problem, due to the way ```\nC```\n is built, we cannot have a negative solution (because C contains squares of numbers, which are ```\n>= 0```\n always). So you could go with ```\n0```\n instead of negative infinity in the first case as well.\n\nExercise: can you write a similar recurrence, but for which the solution is given by ```\nM(n, m, k)```\n? Define it in words first, and then mathematically.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming Optimal Coin Change\r\n                \r\nI've been reviewing some dynamic programming problems, and I have had hard time wrapping my head around some code in regards to finding the smallest number of coins to make change.\n\nSay we have coins worth 25, 10, and 1, and we are making change for 30. Greedy would return 25 and 5(1) while the optimal solution would return 3(10). Here is the code from the book on this problem: \n\n```\ndef dpMakeChange(coinValueList,change,minCoins):\n   for cents in range(change+1):\n      coinCount = cents\n      for j in [c for c in coinValueList if c <= cents]:\n            if minCoins[cents-j] + 1 < coinCount:\n               coinCount = minCoins[cents-j]+1\n      minCoins[cents] = coinCount\n   return minCoins[change]\n```\n\n\nIf anyone could help me wrap my head around this code (line 4 is where I start to get confused), that would be great. Thanks!\n    ", "Answer": "\r\nIt looks to me like the code is solving the problem for every cent value up until target cent value.  Given a target value ```\nv```\n and a set of coins ```\nC```\n, you know that the optimal coin selection ```\nS```\n has to be of the form ```\nunion(S', c)```\n, where ```\nc```\n is some coin from ```\nC```\n and ```\nS'```\n is the optimal solution for ```\nv - value(c)```\n (excuse my notation).  So the problem has optimal substructure.  The dynamic programming approach is to solve every possible subproblem.  It takes ```\ncents * size(C)```\n steps, as opposed to something that blows up much more quickly if you just try to brute force the direct solution.\n\n```\ndef dpMakeChange(coinValueList,change,minCoins):\n   # Solve the problem for each number of cents less than the target\n   for cents in range(change+1):\n\n      # At worst, it takes all pennies, so make that the base solution\n      coinCount = cents\n\n      # Try all coin values less than the current number of cents\n      for j in [c for c in coinValueList if c <= cents]:\n\n            # See if a solution to current number of cents minus the value\n            # of the current coin, with one more coin added is the best \n            # solution so far  \n            if minCoins[cents-j] + 1 < coinCount:\n               coinCount = minCoins[cents-j]+1\n\n      # Memoize the solution for the current number of cents\n      minCoins[cents] = coinCount\n\n   # By the time we're here, we've built the solution to the overall problem, \n   # so return it\n   return minCoins[change]\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming Optimal Coin Change\r\n                \r\nI've been reviewing some dynamic programming problems, and I have had hard time wrapping my head around some code in regards to finding the smallest number of coins to make change.\n\nSay we have coins worth 25, 10, and 1, and we are making change for 30. Greedy would return 25 and 5(1) while the optimal solution would return 3(10). Here is the code from the book on this problem: \n\n```\ndef dpMakeChange(coinValueList,change,minCoins):\n   for cents in range(change+1):\n      coinCount = cents\n      for j in [c for c in coinValueList if c <= cents]:\n            if minCoins[cents-j] + 1 < coinCount:\n               coinCount = minCoins[cents-j]+1\n      minCoins[cents] = coinCount\n   return minCoins[change]\n```\n\n\nIf anyone could help me wrap my head around this code (line 4 is where I start to get confused), that would be great. Thanks!\n    ", "Answer": "\r\nIt looks to me like the code is solving the problem for every cent value up until target cent value.  Given a target value ```\nv```\n and a set of coins ```\nC```\n, you know that the optimal coin selection ```\nS```\n has to be of the form ```\nunion(S', c)```\n, where ```\nc```\n is some coin from ```\nC```\n and ```\nS'```\n is the optimal solution for ```\nv - value(c)```\n (excuse my notation).  So the problem has optimal substructure.  The dynamic programming approach is to solve every possible subproblem.  It takes ```\ncents * size(C)```\n steps, as opposed to something that blows up much more quickly if you just try to brute force the direct solution.\n\n```\ndef dpMakeChange(coinValueList,change,minCoins):\n   # Solve the problem for each number of cents less than the target\n   for cents in range(change+1):\n\n      # At worst, it takes all pennies, so make that the base solution\n      coinCount = cents\n\n      # Try all coin values less than the current number of cents\n      for j in [c for c in coinValueList if c <= cents]:\n\n            # See if a solution to current number of cents minus the value\n            # of the current coin, with one more coin added is the best \n            # solution so far  \n            if minCoins[cents-j] + 1 < coinCount:\n               coinCount = minCoins[cents-j]+1\n\n      # Memoize the solution for the current number of cents\n      minCoins[cents] = coinCount\n\n   # By the time we're here, we've built the solution to the overall problem, \n   # so return it\n   return minCoins[change]\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Solve dynamic programming in Prolog via corecursion\r\n                \r\nI would like to solve the following dynamic programming problem via corecursion in Prolog. But I am stuck in doing the breadth first search, that I would like to implement, in a correcursive fashion:\n\n\n  There is a building of n floors with an elevator that can only \n  go up 2 floors at a time and down 3 floors at a time. Using \n  dynamic programming write a function that will compute the \n  number of steps it takes the elevator to get from floor \n  i to floor j.\n\n\nI have already decided about a lazy list representation. A lazy list would be simply a Prolog closure C, which can be called to yield a head and a new closure for the tail. \n\nExample a stream of ones:\n\n```\n one(1, one).\n```\n\n\nA Haskell take predicate can then be simply coded as follows:\n\n```\n take(0, _, L) :- !, L = [].\n take(N, C, [X|L]) :- N > 0, \n    call(C, X, D), \n    M is N-1, \n    take(M, D, L). \n```\n\n\nHere is an example run:\n\n```\n ?- take(5, one, X).\n X = [1, 1, 1, 1, 1].\n\n ?- take(10, one, X).\n X = [1, 1, 1, 1, 1, 1, 1, 1, 1|...].\n```\n\n    ", "Answer": "\r\nIn this co-recursive Prolog solution we need two building blocks. \n\nOne building block is a way to enumerate a search tree co-recursively in Prolog. We adopt the idea that the Prolog closure term should carry an agenda with the paths and thus nodes that should be expanded. We can then start with an agenda that only contains the root:\n\n```\n% tree(-Path, -LazyPaths)\ntree(H, T) :-\n   tree([[]], H, T). \n```\n\n\nTo archive breadth first enumeration we will append the new expanded paths and thus nodes at the end of the agenda. This can be done by a simple list append predicate call, so that the missing definition reads as follows. In the full binary tree paths and thus nodes are always expanded twice:\n\n```\n% tree(+Paths, -Path, -LazyPaths)\ntree([X|Y], X, tree(Z)) :-\n   append(Y, [[0|X],[1|X]], Z). \n```\n\n\nHere is an example run:\n\n```\n?- take(5, tree, L).\nL = [[],[0],[1],[0,0],[1,0]]\n\n?- take(10, tree, L).\nL = [[],[0],[1],[0,0],[1,0],[0,1],[1,1],[0,0,0],[1,0,0],[0,1,0]] \n```\n\n\nIn case of the evaluator problem we will have a path and thus node expansion that will not always lead to two successors. If we are at a level k, the elevator can go to a level k+2 or k-3, only provided the elevator stays inside the building. So we readly arrive at a co-recursive predicate steps that does simulate all possible paths of the elevator:\n\n```\n?- take(5, steps(7,[[2]]), L).\nL = [[2],[4,2],[1,4,2],[6,4,2],[3,1,4,2]]\n\n?- take(10, steps(7,[[2]]), L).\nL = [[2],[4,2],[1,4,2],[6,4,2],[3,1,4,2],[3,6,4,2],\n    [5,3,1,4,2],[5,3,6,4,2],[2,5,3,1,4,2],[7,5,3,1,4,2]]\n```\n\n\nThe last hurdle and second building block is to get a Haskell dropWhile in Prolog. We didn't aim at a predicate that takes a Prolog closure term argument for the boolean condition, but instead only provide a predicate that enumerates the lazy list elements, and the user of the predicate can filter in the Prolog continuation.\n\n```\n% drop_while(+LazyList, -Element)\ndrop_while(C, P) :-\n   call(C, Q, T),\n   (P = Q; drop_while(T, P)).\n```\n\n\nIf we put everything together we get a co-recusive Prolog solution, that can even potentially enumerate all infinite solutions to the evaluator problem via backtracking besides calculating the results in breadth first order:\n\n```\n?- elevator(7,2,6,L), length(L,N).\nL = [6,4,2],\nN = 3 ;\nL = [6,4,2,5,3,1,4,2],\nN = 8 ;\nL = [6,4,7,5,3,1,4,2],\nN = 8 \n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "How to define subproblem in Dynamic Programming?\r\n                \r\nI solved several dynamic programming problems but i don't know how to come up with defining a subproblem. For problem max sum even length subarray,  why they define dp[i] = the maximum sum of an even length subarray starting at i.\nDo you have any tips or theorem about that? \nthanks in advance.\n    ", "Answer": "\r\nI don't think there is any theorem about it. It is simply, a matter of training. You should continue doing examples and it will come.  \n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming Solution for a Variant of Coin Exchange\r\n                \r\nI am practicing Dynamic Programming. I am focusing on the following variant of the coin exchange problem:\n\nLet ```\nS = [1, 2, 6, 12, 24, 48, 60]```\n be a constant set of integer coin denominations. Let ```\nn```\n be a positive integer amount of money attainable via coins in ```\nS```\n. Consider two persons ```\nA```\n and ```\nB```\n. In how many different ways can I split ```\nn```\n among persons ```\nA```\n and ```\nB```\n so that each person gets the same amount of coins (disregarding the actual amount of money each gets)?\n\nExample\n\n```\nn = 6```\n can be split into 4 different ways per person:\n\n\nPerson ```\nA```\n gets {2, 2} and person ```\nB```\n gets {1, 1}.\nPerson ```\nA```\n gets {2, 1} and person ```\nB```\n gets {2, 1}.\nPerson ```\nA```\n gets {1, 1} and person ```\nB```\n gets {2, 2}.\nPerson ```\nA```\n gets {1, 1, 1} and person ```\nB```\n gets {1, 1, 1}.\n\n\nNotice that each way is non-redundant per person, i.e. we do not count both {2, 1} and {1, 2} as two different ways.\n\nPrevious research\n\nI have studied at very similar DP problems, such as the coin exchange problem and the partition problem. In fact, there are questions in this site referring to almost the same problem:\n\n\nDynamic Programming for a variant of the coin exchange - Here, OP studies the recursion relationship, but seems confused introducing the parity constraint.\nCoin Change :Dynamic Programming - Here, OP seems to pursue the reconstruction of the solution.\nCoin change(Dynamic programming) - Here, OP seems to also pursue the reconstruction of the solution.\nhttps://cs.stackexchange.com/questions/87230/dynamic-programming-for-a-variant-of-the-coin-exchange-problem - Here, OP seems to ask about a similar problem, yet parity, i.e. splitting into two persons, becomes the main issue.\n\n\nI am interested mostly in the recursion relation that could help me solve this problem. Defining it will allow me to easily apply either a memoization of a tabulation approach to design an algorithm for this problem.\n\nFor example, this recursion:\n\n```\ndef f(n, coins):\n  if n < 0:\n    return 0\n\n  if n == 0:\n    return 1\n\n  return sum([f(n - coin, coins) for coin in coins])\n```\n\n\nIs tempting, yet it does not work, because when executed:\n\n```\n# => f(6, [1, 2, 6]) # 14\n```\n\n\nHere's an example of a run for ```\nS' = {1, 2, 6}```\n and ```\nn = 6```\n, in order to help me clarify the pattern (there might be errors):\n\n\n    ", "Answer": "\r\nThis is what you can try:\n\nLet ```\nC(n, k, S)```\n be the number of distinct representations of an amount ```\nn```\n using some ```\nk```\n coins from ```\nS```\n.\n\nThen ```\nC(n, k, S) = sum(C(n - s_i, k - 1, S[i:]))```\n The summation is for every ```\ns_i```\n from ```\nS```\n. ```\nS[i:]```\n means all the elements from ```\nS```\n starting from ```\ni```\n-th element to the end - we need this to prevent repeated combinations.\n\nThe initial conditions are ```\nC(0, 0, _) = 1```\n and ```\nC(n, k, _) = 0```\n if ```\nn < 0```\n or ```\nk < 0```\n or ```\nn > 0```\n and ```\nk < 1```\n .\n\nThe number you want to calculate:\n\n```\nR = sum(C(i, k, S) * C(n - i, k, S))```\n for ```\ni = 1..n-1```\n, ```\nk = 1..min(i, n-i)/Smin```\n where ```\nSmin```\n - the smallest coin denomination from ```\nS```\n. \n\nThe value ```\nmin(i, n-i)/Smin```\n represents the maximum number of coins that is possible when partitioning the given sum. For example if the sum ```\nn = 20```\n and ```\ni = 8```\n (1st person gets $8, 2nd gets $12) and the minimum coin denomination is $2, the maximum possible number of coins is ```\n8/2 = 4```\n. You can't get $8 with ```\n>4```\n coins.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "stuck on dynamic programming\r\n                \r\nHeres the problem:\nA Milkman serves milk in packaged bottles of varied sizes. The possible size of the bottles are {1, 5, 7 and 10} litres. He wants to supply desired quantity using as less bottles as possible irrespective of the size. Your objective is to help him find the minimum number of bottles required to supply the given demand of milk. \n\nInput Format: \n\nFirst line contains number of test cases N \nNext N lines, each contain a positive integer Li which corresponds to the demand of milk. \n\nOutput Format: \n\nFor each input Li, print the minimum number of bottles required to fulfill the demand \n\nI have written this code for the problem.\n\n```\n#include <iostream>\n#include <vector>\n#include <stdio.h>\n#include <set>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <map>\n#include <iomanip>\n#include <locale>\n#include <stdlib.h>\n#include <cstring>\n#include <cmath>\n#include <tgmath.h>\nusing namespace std;\nconst int INF = 1000000000;\nint m[4] = { 1, 5, 7, 10 };\nint r[100000000];\n\nint milk(int n) {\n    int q;\n\n    if (r[n] < INF)\n        return r[n];\n\n    if (n <= 0)\n        q = 0;\n    else {\n        q = INF;\n        for (int i = 0; i < 4; i++) {\n            if (n >= m[i])\n                q = min(q, 1 + milk(n - m[i]));\n        }\n    }\n\n    r[n] = q;\n\n    return q;\n}\n\nint main() {\n    int t, n;\n    cin >> t;\n\n    while (t--) {\n        cin >> n;\n        memset(r, INF, sizeof(r));\n        cout << milk(n) << endl;\n    }\n\n    return` 0;\n}\n```\n\n\nI have used dynamic programming for this.But I only get an output zero for every input.I am new to dp.Please help.\n    ", "Answer": "\r\n```\nint milk(int n) {\n    int min;\n    memset(r, 0, sizeof(r));\n    for (int i = 1; i <= n; i++) {\n        min = 10000000; // some very large value greater than n\n        for (j = 0; j <= 3; j++) {\n            if (m[j] > i)\n                continue;\n            else if (r[i - m[j]] < min)\n                min = r[i - m[j]];\n        }\n        r[i] = min;\n    }\n    return r[n];\n}\n```\n\n\nI hope this works and it would help you , comment if you have any doubts.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming \"Solitare Board Game\"\r\n                \r\nI have a programming problem that I am trying to work through, but I'm stuck as in which direction to begin.  \n\nThe problem is as follows:  \n\n\n  If we have some nxn square board (essentially a two-dimensional array) with each square of the grid having a numerical value in it (negative, zero, or positive). The guidelines for the game are that you may start with your \"token\" at any position on the board, and you can only move your token right or down (in any order). For each square you enter, you add or subtract that total from your score, and your goal is to accumulate the highest score possible before moving off any square on the right or bottom edge.  \n\n\nThis is similar to other dynamic programming problems I've seen in the past (word aligning comes to mind), but I'm struggling with where to start without essentially taking a brute force method of dynamic programming (memoize table for each square on the right and bottom edge, but then you end up with (2n tables of size n^2, and the runtime would be atrocious).  \n\nWhat would you recommend as a starting point for this problem in order to achieve the highest possible score, while still keeping the algorithm as time and space efficient as possible?\n    ", "Answer": "\r\nIf I understand this correctly, you can just make a nxn table where the entries are\n\n```\ntable[i][j] = board[i][j] + max(table[i][j-1], table[i-1][j])\n```\n\n\nwith\n\n```\ntable[-1][j] = INT_MIN for all j\n```\n\n\nand\n\n```\ntable[i][-1] = INT_MIN for all i\n```\n\n\n(table is the table for the maximum scores and board the actual board that you are given.)\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming for coin change\r\n                \r\nA given amount x should be changed in a coin system C = {c1, c2, … ck} such that each coin ci has a given weight wi. We would like to calculate the total weight of the possible changes. Two changes are different if they contain the same coins in different order.\n\nHow can we give a dynamic programming recursion for the above problem? I know the recursion for minimum coin change problem (i.e. C(x)=min{C(x-c)+1 for x>0}). But my confusion is the total weight of the possible changes.Thanks.\n    ", "Answer": "\r\nLooks like naive approach \"store answer in the array\" works. Let's C[i] represents coin value and W[i] represents coin weight, N is number of coins.\n\nRecursion part looks like this:\n\n```\nlong sum = 0;\nfor (int i = 0; i < N; ++i)\n    if (C[i] <= x)\n        sum += W[i] + total_change_weight(x-C[i]);\n```\n\n\nsample program without input, output and C/W initialization follows:\n\n```\n#define N   10\n#define MAX_VALUE   101\n\nlong C[N];\nlong W[N];\nlong totals[MAX_VALUE];\n\nlong total_change_weight(long x) \n{\n    if (x == 0) \n        return 0;\n    if (totals[x] >= 0)\n        return totals[x];\n\n    long sum = 0;\n    for (int i = 0; i < N; ++i)\n        if (C[i] <= x)\n            sum += W[i] + total_change_weight(x-C[i]);\n    totals[x] = sum;\n\n    return sum;\n}\n\nvoid main () \n{\n    long value = 100;\n    //initialize C\n    ...\n    //initialize W\n    ...\n    //initialize totals\n    for (long i = 0; i < MAX_VALUE; ++i)\n        totals[i] = -1;\n    long result = total_change_weight(value);\n}\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "What are Cache Misses in Dynamic Programming, and How Can I Avoid Them?\r\n                \r\nI am new to dynamic programming and have come across the concept of cache misses when analyzing the efficiency of various dynamic programming algorithms.\n\nParticularly, I have seen that optimizing code to avoid cache misses can help improve run-time.\n\nWhat are cache misses, and how can I avoid them when writing dynamic programming algorithms?\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming recursive formula\r\n                \r\nI am trying to go over some notes and examples of dynamic programming, and I have having some difficulty figuring out how it all works. I will post the question, and then what I am having difficulty with:\n\n\n  Given a sequence of points p1= (x1,y1),...,pn=(xn,yn) sorted from left to right (ie, x1 < x2 < ... < xn) and a number k between 1 and n, find a polygonal chain from p1 to pn with k edges that goes from left to right, minimizing the sum of the vertical distances of the points to the chain. Design dynamic programming algorithm that solves the problem in O(n^3) time. Set the subproblems, give all base cases necessary, calculate recursive formula, and write pseudocode for the algorithm. Also a function f(a,b) is defined for us to use in calculating the vertical difference, so I dont have to worry about implementing that. I can just use it as f(a,b)\n\n\nI believe that the subproblems should be divided as such:\n\nC[i,j] = polygonal chain from p1 to pi with j edges, minimizing the sum of vertical distances.\n\nAnd then the answer would be: C[n,k]\n\nBase case: C[i,0] = 0\n\nAnd now I am having some difficulty coming up with the recursive formula. My first question, have I broken the subproblems up correctly? The question gives a hint that makes it seem like I did, but I am not 100% sure. If I am, any hints on how to proceed with deriving the recursive formula?\n\nThanks for any help guys.\n    ", "Answer": "\r\nYour subproblems are correct, but I think a little change to the formulation can help you come up with the formula:\n\nInstead of having ```\nC(i, j)```\n mean any chain from 1 to i with j edges, make it mean specifically \"A chain that ends in i\". Then, to determine the answer for ```\nC(i, j)```\n you just have to try all the possibilities for where the last edge started.\n\nThen the answer can be the optimal of all ```\nC(i, k)```\n.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Can I combine PySP and pyomo.DAE to do stochastic dynamic programming?\r\n                \r\nIt is unclear to me whether PySP and pyomo.DAE can be combined. I wish to use stochastic dynamic programming to model optimal stopping/real options valuation. I wish to use stochastic differential equations, geometric Brownian motion, and the Bellman equation. I get that PySP does stochastic programming, and I get that pyomo.DAE does dynamic optimization. Does Pyomo have the built in capacity to do stochastic dynamic programming?\n    ", "Answer": "\r\nPySP and Pyomo.DAE can be combined but I'm not sure it's what you're looking for. See this paper on a few applications that combine them. The dynamic optimization support in Pyomo.DAE is not the same as dynamic programming (See the documentation here). If you could provide a small example of the exact problem structure you're trying to represent then I would be able to say more definitively if we support it or not.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming approximation\r\n                \r\nI am trying to calculate a function F(x,y) using dynamic programming. Functionally:\n\nF(X,Y) = a1 F(X-1,Y)+ a2 F(X-2,Y) ... + ak F(X-k,Y) + b1 F(X,Y-1)+ b2 F(X,Y-2) ... + bk F(X,Y-k)\n\nwhere k is a small number (k=10).\n\nThe problem is, X=1,000,000 and Y=1,000,000. So it is infeasible to calculate F(x,y) for every value between x=1..1000000 and y=1..1000000. Is there an approximate version of DP where I can avoid calculating F(x,y) for a large number of inputs and still get accurate estimate of F(X,Y).\n\nA similar example is string matching algorithms (Levenshtein's distance) for two very long and similar strings (eg. similar DNA sequences). In such cases only the diagonal scores are important and the far-from-diagonal entries do not contribute to the final distance. How do we avoid calculating off-the-diagonal entries?\n\nPS: Ignore the border cases (i.e. when x < k and y < k).\n    ", "Answer": "\r\nI'm not sure precisely how to adapt the following technique to your problem, but if you were working in just one dimension there is an O(k3 log n) algorithm for computing the nth term of the series.  This is called a linear recurrence and can be solved using matrix math, of all things.  The idea is to suppose that you have a recurrence defined as\n\n\nF(1) = x_1\nF(2) = x_2\n...\nF(k) = x_k\nF(n + k + 1) = c_1 F(n) + c_2 F(n + 1) + ... + c_k F(n + k)\n\n\nFor example, the Fibonacci sequence is defined as\n\n\nF(0) = 0\nF(1) = 1\nF(n + 2) = 1 x F(n) + 1 x F(n + 1)\n\n\nThere is a way to view this computation as working on a matrix.  Specifically, suppose that we have the vector x = (x_1, x_2, ..., x_k)^T.  We want to find a matrix A such that\n\n\n  Ax = (x_2, x_3, ..., x_k, x_{k + 1})^T\n\n\nThat is, we begin with a vector of terms 1 ... k of the sequence, and then after multiplying by matrix A end up with a vector of terms 2 ... k + 1 of the sequence.  If we then multiply that vector by A, we'd like to get\n\n\n  A(x_2, x_3, ..., x_k, x_{k + 1})^T = (x_3, x_4, ..., x_k, x_{k + 1}, x_{k + 2})\n\n\nIn short, given k consecutive terms of the series, multiplying that vector by A gives us the next term of the series.\n\nThe trick uses the fact that we can group the multiplications by A.  For example, in the above case, we multiplied our original x by A to get x' (terms 2 ... k + 1), then multiplied x' by A to get x'' (terms 3 ... k + 2).  However, we could have instead just multiplied x by A2 to get x'' as well, rather than doing two different matrix multiplications.  More generally, if we want to get term n of the sequence, we can compute Anx, then inspect the appropriate element of the vector.\n\nHere, we can use the fact that matrix multiplication is associative to compute An efficiently.  Specifically, we can use the method of repeated squaring to compute An in a total of O(log n) matrix multiplications.  If the matrix is k x k, then each multiplication takes time O(k3) for a total of O(k3 log n) work to compute the nth term.\n\nSo all that remains is actually finding this matrix A.  Well, we know that we want to map from (x_1, x_2, ..., x_k) to (x_1, x_2, ..., x_k, x_{k + 1}), and we know that x_{k + 1} = c_1 x_1 + c_2 x_2 + ... + c_k x_k, so we get this matrix:\n\n```\n    | 0   1   0   0    ...   0 |\n    | 0   0   1   0    ...   0 |\nA = | 0   0   0   1    ...   0 |\n    |        ...               |\n    | c_1 c_2 c_3 c_4  ... c_k |\n```\n\n\nFor more detail on this, see the Wikipedia entry on solving linear recurrences with linear algebra, or my own code that implements the above algorithm.\n\nThe only question now is how you adapt this to when you're working in multiple dimensions.  It's certainly possible to do so by treating the computation of each row as its own linear recurrence, then to go one row at a time.  More specifically, you can compute the nth term of the first k rows each in O(k3 log n) time, for a total of O(k4 log n) time to compute the first k rows.  From that point forward, you can compute each successive row in terms of the previous row by reusing the old values.  If there are n rows to compute, this gives an O(k4 n log n) algorithm for computing the final value that you care about.  If this is small compared to the work you'd be doing before (O(n2 k2), I believe), then this may be an improvement.  Since you're saying that n is on the order of one million and k is about ten, this does seem like it should be much faster than the naive approach.\n\nThat said, I wouldn't be surprised if there was a much faster way of solving this problem by not proceeding row by row and instead using a similar matrix trick in multiple dimensions.\n\nHope this helps!\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "What's time complexity of this Algorithm for breaking words? (Dynamic Programming)\r\n                \r\n\n  Word Break(with Dynamic Programming: Top->Down) Given a string s and a dictionary of words dict, add spaces in s to construct a sentence\n  where each word is a valid dictionary word.\n  \n  Return all such possible sentences.\n  \n  For example, given s = \"catsanddog\", dict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"].\n  \n  A solution is [\"cats and dog\", \"cat sand dog\"]. \n  Question: \n  \n  \n  Time complexity ?\n  Space complexity ?\n  \n  \n  Personally I think,\n  \n  \n  Time complexity = O(n!), without Dynamic Programming, n is the length    of the given string,\n  Space complexity = O(n).\n  \n  \n  The puzzled:\n  \n  \n  Can not figure out the time complexity with Dynamic Programming. \n  It seems that the space complexity above is not correct.\n  \n  \n  \n  Code[Java]\n\n\n```\npublic class Solution {\n    public List<String> wordBreak(String s, Set<String> dict) {\n        List<String> list = new ArrayList<String>();\n\n        // Input checking.\n        if (s == null || s.length() == 0 || \n            dict == null || dict.size() == 0) return list;\n\n        int len = s.length();\n\n        // memo[i] is recording,\n        // whether we cut at index \"i\", can get one of the result.\n        boolean memo[] = new boolean[len];\n        for (int i = 0; i < len; i ++) memo[i] = true;\n\n        StringBuilder tmpStrBuilder = new StringBuilder();\n        helper(s, 0, tmpStrBuilder, dict, list, memo);\n\n        return list;\n    }\n\n    private void helper(String s, int start, StringBuilder tmpStrBuilder,\n                        Set<String> dict, List<String> list, boolean[] memo) {\n\n        // Base case.\n        if (start >= s.length()) {\n            list.add(tmpStrBuilder.toString().trim());\n            return;\n        }\n\n        int listSizeBeforeRecursion = 0;\n        for (int i = start; i < s.length(); i ++) {\n            if (memo[i] == false) continue;\n\n            String curr = s.substring(start, i + 1);\n            if (!dict.contains(curr)) continue;\n\n            // Have a try.\n            tmpStrBuilder.append(curr);\n            tmpStrBuilder.append(\" \");\n\n            // Do recursion.\n            listSizeBeforeRecursion = list.size();\n            helper(s, i + 1, tmpStrBuilder, dict, list, memo);\n\n            if (list.size() == listSizeBeforeRecursion) memo[i] = false;\n\n            // Roll back.\n            tmpStrBuilder.setLength(tmpStrBuilder.length() - curr.length() - 1);\n        }\n    }\n}\n```\n\n    ", "Answer": "\r\nWith DP:\n\nTime: O(N*M)\n N - string size\n M - dict size\n\nMemory: O(N)\n\nSee my answer here, with code example:\n\nDynamic Programming - Word Break\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming: Minimizing whitespace\r\n                \r\nThis is a homework question, but I am completely lost.  I am having an impossible time figuring out what the subproblem is: I've tried a greedy approach, I've tried building up the number of words on a line, etc. and I can't come up with anything.  Can anyone offer any insight at all?\n\nProblem:  Consider a program that converts a list of words into typset text.  The program prints the words onto lines of length W such that the amount of extra spaces at the end of the  line such that a line containing words i through j contains W - j + i - SUM(characters in words i thru j).  Write a dynamic programming algorithm that minimizes the sum of squares of extra spaces on each line.\n    ", "Answer": "\r\nI believe the approach you are supposed to have is the following:\n\n->find the best solution for a line of length 1 and save the value.(this should be trivial).\n\n->find the best solution for a line of length 2 this way:\n\nfor every word see if they fit. if they do calculate the remaining space and use the best solution for that space (will be 1 or 0 space left).\n\n...(do this all the way to W)\n\n->find the best solution for a line of length W this way:\n\nfor every word see if they fit. If they do, calculate the remaining space and use the best solution for that remaining space (since it is less than W you have already calculated it.)\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Computing Fibonacci Numbers with Dynamic Programming (Python)\r\n                \r\nI am doing some practice problems for interview preparation and I came upon this extension of the Fibonacci sequence problem:\n\nThis question expands on our earlier Fibonacci Lite challenge. While the goal of Fibonacci Lite was to understand recursion, this challenge is about solving problems efficiently with dynamic programming.\nThe difference in this challenge is that each test case will consist of many inputs instead of just one. Furthermore, we're allowing larger values of n. You'll need to use dynamic programming to solve all the inputs without running out of time.\n\nI wrote a solution in Python which has been passing my input tests but it would be great if I could get some external verification of my results. Here is the code:\n```\nimport time\n\ncalculations = [0, 1] #stores previously calculated solutions\n\ndef main(nArr):\n    simpOut = [] #simple solutions\n    dynOut = [] #dynamic solutions\n\n    start = time.time()\n    for val in nArr:\n        simpOut.append(fibDyn(val))\n    end = time.time()\n    print(\"dynamic:\")\n    print(simpOut)\n    print(end - start)\n\n    print(\"\")\n\n    start = time.time()\n    for val in nArr:\n        dynOut.append(fibSimp(val))\n    end = time.time()\n    print(\"simple:\")\n    print(dynOut)\n    print(end - start)\n\n#dynamic solution\ndef fibDyn(n):\n    #base case: checks if solution has already been calculated\n    if n < len(calculations):\n        return calculations[n]\n    #recursion\n    currentSol = fibDyn(n-2) + fibDyn(n-1)\n    calculations.append(currentSol)\n    return currentSol\n\n#simple solution\ndef fibSimp(n):\n    #base case\n    if n <= 1:\n        return n\n    #recursion\n    return fibSimp(n-2) + fibSimp(n-1)\n```\n\nThanks for any input.\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Idea of dynamic programming solution\r\n                \r\nGiven natural number N (1 <= N <= 2000), count the number of sets of natural numbers with the sum equal to N, if we know that ratio of any two elements in given set is more than 2\n(for any x, y in given set: max(x, y) / min(x, y) >= 2)\nI am trying to use given ratio so it would be possible to count the sum using geometry progression formula, but I haven't succeeded yet. Somehow it's necessary to come up with dynamic programming solution, but I have no idea how to come up with a formula\n    ", "Answer": "\r\nAs Stef suggested in the comments, if you count the number of ways you can make n, using numbers that are at most k, you can calculate this using dynamic programming. For a given n, k, either you use k or you don't: if you do, then you have n-k left, and can use numbers <= k/2, and if you don't, then you still have n, and can use numbers <= k-1. It's very similar to a coin change algorithm, or to a standard algorithm for counting partitions.\nWith that, here's a program that prints out the values up to n=2000 in the sequence:\n```\nN = 2000\n\nA = [[0] * (i+1) for i in range(N+1)]\nA[0][0] = 1\nfor n in range(1, N+1):\n    for k in range((n+1)//2, n+1):\n        A[n][k] = A[n-k][min(n-k, k//2)] + A[n][k-1]\n\nfor i in range(N+1):\n    print(i, A[i][i])\n```\n\nIt has a couple of optimizations: ```\nA[n, k]```\n is the same as ```\nA[n, n]```\n for ```\nk>n```\n, and ```\nA[n, k]=0```\n when ```\n2k+1 < N```\n (because if you use ```\nk```\n, then the largest integer you can get is at most ```\nk+k/2+k/4+... <= 2k-1```\n -- the infinite sum is ```\n2k```\n, but with integer arithmetic you can never achieve this). These two optimizations give a speedup factor of 2 each, compared to computing the whole (n+1)x(n+1) table.\nWith these two optimizations, and the array-based bottom-up dynamic programming approach, this prints out all the solutions in around 0.5s on my machine.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "sql command or Dynamic programming?\r\n                \r\nsuppose I have 1 GB of data in my database. I want to do something like this:\n\n\n  If user searches for a sentence, say 'Hello world I am here.', the program should be able to return the data (rows) where this exact string is found and also the rows which have similar texts e.g., 'Hello world is a famous string, I am sure!'. \n\n\nMy question is: Which one will be more efficient- an sql command or a dynamic programming concept? \n\nIf sql is more efficient, what is the command that can be used for doing the same?\n\nI am using mysql 5.6\n    ", "Answer": "\r\nYou want to use the full text capabilities of MySQL, which are documented here.\n\nBasically, the data structure that you need is an inverted index.  For each word, this contains the positions of the word in all the documents.  With this information, you can start to piece things together.\n\nIn most cases, you are much better off doing this using established software, rather than writing your own.  I don't want to stop you, if you really want to, but the problem may be harder than you think.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Does there exist a Top Down Dynamic Programming solution for Longest Increasing Subsequence?\r\n                \r\nI want to know how to find the LIS of an array using Top Down Dynamic Programming.\nDoes there exist one such solution? Can you give me the pseudocode for finding the LIS of an array using Top Down Dynamic Programming? I am not able to find one on the internet. All of them use Bottom Up.\n    ", "Answer": "\r\nRecursive approach to solve LIS length in java would be like below  - \n\n```\n public int LIS(int[] arr) {\n        return LISLength(arr, Integer.MIN_VALUE, 0);\n    }\n\n    public int LISLength(int[] arr, int prev, int current) {\n        if (current == arr.length) {\n            return 0;\n        }\n        int include = 0;\n        if (arr[current] > prev) {\n            include = 1 + LISLength(arr, arr[current], current + 1);\n        }\n        int exclude = LISLength(arr, prev, current + 1);\n        return Math.max(include, exclude);\n    }\n```\n\n\nBut it would work with O(2^n) time complexity so we need to use memoization technique to reduce the complexity with below approach - \n\n```\npublic int LIS(int[] arr) {\n        int memoTable[][] = new int[arr.length + 1][arr.length];\n        for (int[] l : memoTable) {\n            Arrays.fill(l, -1);\n        }\n        return LISLength(arr, -1, 0, memoTable);\n    }\n    public int LISLength(int[] arr, int prev, int current, int[][] memoTable) {\n        if (current == arr.length) {\n            return 0;\n        }\n        if (memoTable[prev + 1][current] >= 0) {\n            return memoTable[prev + 1][current];\n        }\n        int include = 0;\n        if (prev < 0 || arr[current] > arr[prev]) {\n            include = 1 + LISLength(arr, current, current + 1, memoTable);\n        }\n\n        int exclude = LISLength(arr, prev, current + 1, memoTable);\n        memoTable[prev + 1][current] = Math.max(include, exclude);\n        return memoTable[prev + 1][current];\n    }\n\n```\n\n\nSo O(n^2) would be optimized time complexity with memoization technique.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "continous max sum in array -Dynamic programming\r\n                \r\nI am following  a tutorial on dynamic programming.and following this link :\nhttp://www.8bitavenue.com/2011/11/dynamic-programming-maximum-contiguous-sub-sequence-sum/\nthey have derived a relation :\n\n```\nM[j] = Max (A[j], A[j] + M[j-1])  \n```\n\n\nbut in the actual code while implementing this i cant undersatnd how they are using it .here is their implementation\n\n```\n//Initialize the first value in (M) and (b)  \nM[1] = A[1];  \nb[1] = 1;  \n\n//Initialize max as the first element in (M)  \n//we will keep updating max until we get the  \n//largest element in (M) which is indeed our  \n//MCSS value. (k) saves the (j) position of   \n//the max value (MCSS)  \nint max = M[1];  \nint k = 1;  \n\n//For each sub sequence ending at position (j)  \nfor (int j = 2; j <= n; j++)  \n{  \n    //M[j-1] + A[j] > A[j] is equivalent to M[j-1] > 0  \n    if (M[j-1] > 0)  \n    {  \n        //Extending the current window at (j-1)  \n        M[j] = M[j-1] + A[j];  \n        b[j] = b[j-1];  \n    }  \n    else  \n    {  \n        //Starting a new window at (j)  \n        M[j] = A[j];  \n        b[j] = j;  \n    }  \n\n    //Update max and save (j)  \n    if (M[j] > max)   \n    {  \n        max = M[j];  \n        k = j;  \n    }  \n}  \n\nprint (\"MCSS value = \", max,  \" starts at \", b[k],  \" ends at \", k);  \n```\n\n\nmy question is how is the formula derived is used in this program ??\n\nshouldn't they use a for something like this :\n\n```\nfor i in A:\n  M[j] = Max (A[j], A[j] + M[j-1])  \n```\n\n    ", "Answer": "\r\nThe answer to your question is already given in this line:\n\n```\n//M[j-1] + A[j] > A[j] is equivalent to M[j-1] > 0  \n```\n\n\nThe if statement chooses the bigger value between A[j] and M[j-1]+A[j].\n Would this be more clear to you?\n\n```\nif (M[j-1] + A[j] > A[j]) // is exact the same thing as M[j-1] > 0, but less elegant\n{   \n     M[j] = M[j-1] + A[j];\n     b[j] = b[j-1];\n}\nelse\n{\n    M[j] = A[j];\n    b[j] = j;\n}\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "What is the link between table in knapsack problem and dynamic programming?\r\n                \r\nApologies for a very newbie question as I am unable to find answer to it from various resources. \n\nIn knapsack algorithm, we construct a table, e.g. in https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/ \n\nI have read about the knapsack problem in Kleinberg's book. As per my understanding, dynamic programming is about breaking the problem into overlapping sub-problems - however, I have seen this table used to solve the knapsack in various books/online resources. I can't seem to wrap my head around how is this table linked to dynamic programming? Are we memoizing anything in this table? It seems to me to be a clever solution to the knapsack, but not a dynamic programming one. I have seen videos and texts where they solve the problem either by using a table or using a dynamic programming solution, but no one seems to provide a link between the two. \n    ", "Answer": "\r\nIt's still dynamic programming. The only distinction is that the dynamic programming algorithm is still not polynomial in ```\nn```\n, but in both ```\nn```\n and ```\nW```\n. For these types of problems, you have to distinguish between values that arise natural due to the input, and values that are part of the input.\n\nYour input consists of ```\nn```\n different items and the number ```\nW```\n; ```\nW```\n is explicit, not implied by the size of the input. Because we are using some efficient encoding (i.e., binary) to provide ```\nW```\n, the size of ```\nW```\n is exponential in the encoding of ```\nW```\n. That is, the input contains O(lg ```\nW```\n) bits representing ```\nW```\n, but the table we build has ```\nW```\n rows (or columns, deepening on how you view it). That make the algorithm exponential in the input size.\n\nHowever, if we relax our usual rule that the input has to be represented efficiently, we could specify ```\nW```\n using \"unary\" notation; ```\nW```\n 1s in the input instead of a binary representation. Now you can claim that, because the input size is polynomial in ```\nn```\n and ```\nW```\n, rather than in ```\nn```\n and ```\nlg W```\n as before, that the DP table is also polynomial in the input.\n\nThis is roughly the difference between strong and weak NP-hardness: if a problem is weakly NP-hard, then a polynomial-time algorithm (usually based on dynamic programming) can be found if we specify a unary encoding of some numerical parameter rather than the usual binary encoding.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "dynamic programming pseudocode for Travelling Salesman\r\n                \r\nthis is a dynamic programming pseudocode for TSP (Travelling Salesman Problem). i understood its optimal substructure but i can't figure out what the code in red brackets do.\n\ni am not asking anyone to write the actual code, i just need explanation on what is happening so i can write my own.... thanks:)\n\nhere is a link for the pseudocode, i couln't uploaded over here.\nhttp://www.imagechicken.com/viewpic.php?p=1266328410025325200&x=jpg\n    ", "Answer": "\r\nHere is some less mathematical pseudo-code. I don't know if this will explain what's happening, but it may help you read it. This isn't a functional algorithm (lots of ```\n:=```\n all over), so I'm going to use Python pseudo-code.\n\n```\n# I have no idea where 'i' comes from. It's not defined anywhere\nfor k in range(2,n):\n    C[set(i,k), k] = d(1,k)\nshortest_path = VERY_LARGE_NUMBER\n# I have to assume that n is the number of nodes in the graph G\n# other things that are not defined:\n# d_i,j -- I will assume it's the distance from i to j in G\nfor subset_size in range(3,n):\n    for index_subset in subsets_of_size(subset_size, range(1,n)):\n        for k in index_subset:\n            C[S,k] = argmin(lambda m: C[S-k,m] + d(G,m,k), S - k)\n            shortest_path = argmin(lambda k: C[set(range(1,n)),k] + d(G,1,k), range(2,n))\nreturn shortest_path\n\n# also needed....\ndef d(G, i, j):\n    return G[i][j]\ndef subsets_of_size(n, s): # returns a list of sets\n    # complicated code goes here\n    pass\ndef argmin(f, l):\n    best = l[0]\n    bestVal = f(best)\n    for x in l[1:]:\n        newVal = f(x)\n        if newVal < bestVal:\n            best = x\n            bestVal = newVal\n    return best\n```\n\n\nSome notes:\n\n\nThe source algorithm is not complete. At least, its formatting is weird in the inner loop, and it rebinds k in the second argmin. So the whole thing is probably wrong; I've not tried to run this code.\narguments to ```\nrange```\n should probably all be increased by 1 since Python counts from 0, not 1. (and in general counting from 1 is a bad idea).\nI assume that G is a dictionary of type { from : { to : length } }. In other words, an adjacency list representation.\nI inferred that C is a dictionary of type { (set(int),int) : int }. I could be wrong.\nI use a ```\nset```\n as keys to ```\nC```\n. In real Python, you must convert to a ```\nfrozen_set```\n first. The conversion is just busywork so I left it out.\nI can't remember the set operators in Python. I seem to remember it uses ```\n|```\n and ```\n&```\n instead of ```\n+```\n and ```\n-```\n.\nI didn't write ```\nsubsets_of_size```\n. It's fairly complicated.\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming MPILOT\r\n                \r\nI am trying to solve a problem on spoj (MPILOT).\n\nI have understood that it's a dynamic programing problem,and i had tried it also but its giving me a wrong answer. my approach is like get the salary difference of pilot and assistant and sort it in decreasing order and then for```\n0 - N/2```\n add as ```\nassistant```\n and for ```\nN/2+1 - N```\n add as ```\npilot```\n and output the ```\nsum```\n. but the problem is coming with the age condition that pilot has to be older than assistant.\n\nHere's my code\n\n```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#define lint long long\n\nusing namespace std;\n\nstruct pilot {\nlint pilotsal;\nlint assistantsal;\nlint diff;\n};\n\nbool compare (pilot p1, pilot p2)\n{\n return (p1.diff > p2.diff);\n}\n\nint main()\n{\nlint c,n,i;\nlint sum=0,max=0;\n cin >> n;\nvector <pilot> pilots(n);\nfor(i=0;i<n;i++)\n{\n    cin >> pilots[i].pilotsal >> pilots[i].assistantsal;\n    pilots[i].diff= pilots[i].pilotsal-pilots[i].assistantsal;\n}\n sum = max = pilots[0].assistantsal;\n sort(pilots.begin()+1,pilots.end(),compare);\nfor(i=1;i<=n/2-1;i++)\n{\n    sum+=pilots[i].assistantsal;\n}\n\nfor(i=n/2;i<n;i++)\n{\n    sum+=pilots[i].pilotsal;\n}\n   cout << sum << endl;\n   return 0;\n}\n```\n\n\nplease give me some hint. how to check for the age condition for the problem.\n    ", "Answer": "\r\nAfter an hour trying to solve this problem using \"dynamic programming\" I concluded that this is not the appropriate way, but the problem is not solved yet. Many greedy ideas came to my mind but greedy is not good in most cases. \n\nAt the end I couldn't solve this problem, but since the problem is interesting I did search the solution and here is what I understand of the solution:\n\nThe pilots are sorted in ascending order:\n\n\nThe very first pilot must to be an assistant\nThe very last pilot must to be a captain\n\n\nThe worst solution is when we pay all the pilots(captains and assistants) as captains. This will be our first solution and we'll try to reduce this amount to the minimum.\n\nThe saving we can get from turning a captain to an assistant is ```\nPilot.CaptainWage - Pilot.AssistantWage```\n.\n\nThe problem turns easy because only the minimum pay is required and not the  grouping itself.\n\n```\n1. Set the first pilot as assistant\n2. Insert each pilot in a list from the second to the last, and for every 2 new elements in the list\n  // One pilot can be turned to an assistant only if remains at least another older pilot\n  2.1 Select the pilot who contribute with the maximum saving so far\n  2.2 Rest the saving of the previous step to our original solution\n  2.3 Remove the pilot from the list\n3. Print our new solution\n```\n\n\nNote: You need an efficient data structure to obtain the pilot with the maximum saving in a fast way, maybe a heap.\n\nSee if you can get to the solution with this. I don't post the link to the actual solution because is better if you try it by yourself first:).\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "python dynamic programming question of coin change\r\n                \r\nI just started learning dynamic programming and came across this formula for calculating the minimum change problem:\n\n```\nP = total money\nd(i) - coin denomination\n\nC|p| = {0, if p = 0\n       {min(i):d(i)<p {1+C|p-d(i)|}, if p > 0\n```\n\n\nCan someone please explain where the 1 + C|p-d(i) comes from, why is it '1+'?\nAlso why are we deleting each coin demonination from the total value p?\n\nThx in advance\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "understanding the flow of a simple dynamic programming\r\n                \r\nI just started understanding the concept of dynamic programming. I understand it is used to cache results for future calls and its really efficient in designing complex algorithms that give an exponential runtime. What I don't understand is how the flow would work programmatically. For example to calculate the nth Fibonacci number using dynamic programming as follows. What is the flow like in the program?\n\n```\nint[] fibMap = new int[max]\nint fibo(int i){\n  if(i == 0) return 0;\n  if(i == 1) return 1;\n  if( fibMap[i] != 0) return fibMap[i]; // return cached result\n  fibMap[i] = fibo(i-1)+fibo(i-2);      //Cache result\n  return fibMap[i];\n}\n```\n\n\nI found this code from one of the Java reference books that I am using but I am having hard time figuring out how this program would work. Say if we would want to calculate a simple fibo(3) or fibo(5), could someone please explain me how the program would cache result and how the overall flow would work for this problem compared to a normal recursive approach without DP like below?\n\n```\nint fibo(int i){\n   if(i == 0) return 0;\n   if( i == 1) return 1;\n   return fibo(i-1) + fibo(i-2);\n}\n```\n\n    ", "Answer": "\r\nYour code is\n\n```\nint fibo(int i){\n  if(i == 0) return 0;\n  if(i == 1) return 1;\n  if( fibMap[i] != 0) return fibMap[i]; // return cached result\n  fibMap[i] = fibo(i-1)+fibo(i-2);      //Cache result\n  return fibMap[i];\n}\n```\n\n\nor, equivalently\n\n```\nint fibo(int i){\n  if(i == 0) return 0;\n  if(i == 1) return 1;\n  if( fibMap[i] == 0)\n    fibMap[i] = fibo(i-1)+fibo(i-2);      //Cache result\n  return fibMap[i];\n}\n```\n\n\nso the \"flow\" is basically exactly the same thing as the non-cached version, except that you avoid recalculating results you've already computed.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming with memoization\r\n                \r\nSince I am new to Dynamic programming. Can someone plz help me out to implement the memoization technique for the algorithm to the following problem.\n\nThere is a 2D matrix of N rows and M columns. Rows are number 0 to N-1 from top to bottom and columns 0 to M-1 from left to right. You are standing at (0,0).\n\nFrom, A [ i ] [ j ] you can move to A [ i + 1 ] [ j ] if A [ i + 1 ] [ j ] > A [ i ] [ j ]. Or, from, A [ i ] [ j ] you can move to A [ i ] [ j + 1 ] if A [ i ] [ j + 1 ] > A [ i ] [ j ].\n\nMoving from (0,0), what is the longest path that you can travel?\n\n```\nstatic int a[][],n,m;\nstatic int find(int x,int y)\n{\n    if((x==n-1 && y==m-1))\n    {\n        return 1;\n    }\n    else if(x<n-1 && y<m-1 && a[x+1][y]>a[x][y] && a[x][y+1]>a[x][y])\n    {\n        return Math.max(find(x+1,y),find(x,y+1))+1;\n    }\n    else if(x<n-1 && a[x+1][y]>a[x][y])\n    {\n        return find(x+1,y)+1;\n    }\n    else if(y<m-1 && a[x][y+1]>a[x][y])\n    {\n        return find(x,y+1)+1;\n    }\n    return 1;\n} \n```\n\n\nwhere..\nx and y are the initial positions(i.e (0,0)),\nn and m are the rows and columns resply,\na is the actual matrix.\n    ", "Answer": "\r\nYou want to use memoization to store the results of ```\nfind()```\n so that you can reuse them if you have calculated them already:\n\n\nDeclare another ```\nn```\n by ```\nm```\n array (call it ```\nmemo```\n say) outside the ```\nfind()```\n function\nBefore returning from ```\nfind()```\n, store the computed result in ```\nmemo[x][y]```\n\nAt the beginning of find(), check if ```\nmemo[x][y]```\n has already been filled in (is non-zero) and return it if it has\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "When have you used dynamic programming in the field?\r\n                \r\nWhen have you ever directly applied the concepts of dynamic programming to solve a problem in the field? It's sometimes not evident how it can be applied when using it to solve a made-up instance of the knapsack problem.\n    ", "Answer": "\r\nIt's probably a lot more common to use memoization to solve problems in the field, since it's applicable to a wider set of problems.  DP is really only called for when you have a lot of overlapping sub-problems, like in calculating fibonacci numbers (the hard way), or prime numbers (the efficient way).\n\nIncidentally, the page you linked to has a list of algorithms that use DP.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Matrix Chain Multiplication + Dynamic Programming + Recurrance Relation\r\n                \r\nI am going over my review worksheet and was looking for some help with finding the recurrence relation for chained matrix multiplication using dynamic programming. \n\nThe problem verbatim:\nConsider the optimal parenthesization problem for the chained matrix product ```\nM0M1…Mn - 1```\n with associated dimension sequence  ```\n(d0, d1, … ,dn)```\n. Derive the recurrence relation on which the dynamic programming solution for this problem is based, i.e., a recurrence relation for the minimum number mij of multiplications over all parenthesizations of the chained product ```\nMiM1…Mj```\n .  Don’t forget the initial condition.\n\nI understand the formula for ```\nM[i,j]```\n ```\n(M[i,j] = M[i,k] + M[k+1,j] + pqr)```\n. This definitely has recursion. But how to I determine the recurrence relation? Is this not the recurrence relation already? Also what is mean by \"associated dimension space\"?\n    ", "Answer": "\r\nSee section 6.5(Chain Matrix Multiplication) from http://www.cs.berkeley.edu/~vazirani/algorithms/chap6.pdf\n\nHere by associated dimension he means that the dimension of each matrix i.e M0 has dimensions d0, M1 has d1, M2 has d2 .... so on.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "different result from recursive and dynamic programming\r\n                \r\nWorking on below problem,\n\nProblem,\n\nGiven a m * n grids, and one is allowed to move up or right, find the different paths between two grid points. \n\nI write a recursive version and a dynamic programming version, but they return different results, and any thoughts what is wrong?\n\nSource code,\n\n```\nfrom collections import defaultdict\ndef move_up_right(remaining_right, remaining_up, prefix, result):\n    if remaining_up == 0 and remaining_right == 0:\n        result.append(''.join(prefix[:]))\n        return\n    if remaining_right > 0:\n        prefix.append('r')\n        move_up_right(remaining_right-1, remaining_up, prefix, result)\n        prefix.pop(-1)\n    if remaining_up > 0:\n        prefix.append('u')\n        move_up_right(remaining_right, remaining_up-1, prefix, result)\n        prefix.pop(-1)\ndef move_up_right_v2(remaining_right, remaining_up):\n    # key is a tuple (given remaining_right, given remaining_up),\n    # value is solutions in terms of list\n    dp = defaultdict(list)\n    dp[(0,1)].append('u')\n    dp[(1,0)].append('r')\n    for right in range(1, remaining_right+1):\n        for up in range(1, remaining_up+1):\n            for s in dp[(right-1,up)]:\n                dp[(right,up)].append(s+'r')\n            for s in dp[(right,up-1)]:\n                dp[(right,up)].append(s+'u')\n    return dp[(right, up)]\n\nif __name__ == \"__main__\":\n    result = []\n    move_up_right(2,3,[],result)\n    print result\n    print '============'\n    print move_up_right_v2(2,3)\n```\n\n    ", "Answer": "\r\nIn version 2 you should be starting your for loops at 0 not at 1.  By starting at 1 you are missing possible permutations where you traverse the bottom row or leftmost column first.  \n\nChange version 2 to:\n\n```\ndef move_up_right_v2(remaining_right, remaining_up):\n    # key is a tuple (given remaining_right, given remaining_up),\n    # value is solutions in terms of list\n    dp = defaultdict(list)\n    dp[(0,1)].append('u')\n    dp[(1,0)].append('r')\n    for right in range(0, remaining_right+1):\n        for up in range(0, remaining_up+1):\n            for s in dp[(right-1,up)]:\n                dp[(right,up)].append(s+'r')\n            for s in dp[(right,up-1)]:\n                dp[(right,up)].append(s+'u')\n    return dp[(right, up)]  \n```\n\n\nAnd then:\n\n```\nresult = []\nmove_up_right(2,3,[],result)\n\nset(move_up_right_v2(2,3)) == set(result)\nTrue\n```\n\n\nAnd just for fun... another way to do it:\n\n```\nfrom itertools import permutations\n\nlist(map(''.join, set(permutations('r'*2+'u'*3, 5))))\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "The overlapping sub problems in bitmask dynamic programming\r\n                \r\nI am trying to learn bit masking with dynamic programming but I'm failing to understand the overlapping sub problems for a case. Can someone please explain how the sub problems overlap based on any example they feel fit for explaining easily? \n    ", "Answer": "\r\nLet's take the example for a ```\nShortest Hamiltonian walk```\n, In this problem we need to find a Hamiltonian walk that is the shortest where each edge has a certain amount of weight associated with it.\n\nHamiltonian walk is where we visit ```\neach and every node```\n in the graph ```\nexactly once```\n.\n\nThis problem can be solved using ```\nDP Bitmasks```\n for small no of nodes. So what we do is to keep a ```\nBitmask```\n to keep track of which nodes we have visited in the current state, and then we can iterate over all the nodes not visited using the ```\nmask```\n we can go to different states.\n\nNow suppose a subproblem lets say of ```\nk```\n no of nodes is computed, this solution of ```\nk```\n nodes constitutes of smaller subproblems, that form a larger solution of k nodes, i.e initial solution had only 2 nodes, then 3 and so on when we reached the ```\nkth```\n node.\n\nNow let's take another subproblem that constitutes of let's say ```\nm```\n nodes also exists.\n\nNow there is an edge from a node in the first subproblem to a node in the second subproblem and we want to join these 2 subproblems, so in this case all the smaller subproblems of the ```\nk```\n nodes are also smaller subproblems of the whole combined solution and hence here is referred to as overlapping as it is present in both the first subproblems and the larger combined subproblem.\n\nIn order to avoid redundant calculation of these overlapping subproblems we use the concept of ```\nmemoisation```\n, i.e once we have the answer to a overlapping subproblem we store it for later use.\n\nAlso note that in the above 2 subproblem's no vertex should be present in both the smaller subproblem which we can check using the corresponding bitmasks.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Brick Tower Building Puzzle\r\n                \r\nI've been given a little brainteaser to solve.\n\nThe task is to make a function with a single integer parameter. You have to figure out how many different combination of tower patterns you can make with that given amount of bricks (each proceeding tower must be less in height than one previous, kind of like). There must be 2 or more towers, one right next to the other.\n\nFor example, if you were given 3 blocks you can only produce 1 combination of towers, one with a height of 2 and its neighbor having a height of 1:\n\n```\n|\n| |\n2 1\n```\n\n\nGiven 4 you can only still produce one combination since the next tower must be shorter than the previous:\n\n```\n|\n|\n| |\n3 1\n```\n\n\nGiven 5 you can produce 2 combinations:\n\n```\n|\n|\n|\n| |\n4 1\n\n|\n| |\n| |\n3 2\n```\n\n\nI have a function that can do all of this, however they give the example that 200 blocks should produce 487067745. Which my function simply does not do. I don't know what I am doing wrong. A push in the right direction would be very much appreciated. My function now looks like this:\n\n```\ndef answer(num):\n    # divide the blocks so we have two towers, one with a height of n-1 and \n    # the other with a height of one\n    l1 = num-1\n    l2 = 1\n    combinations = 0\n    while True:\n        if l1 > l2:\n            # add 1 to the combinations along with how many combinations we \n            # can make using the blocks from tower two\n            combinations += 1 + answer(l2)\n        elif l1 == l2:\n            # see if we can make additional towers out of the rightmost tower\n            # and add that to the combinations\n            combinations += answer( l2 )\n        else:\n            # if the first tower is smaller than or equal to the other tower \n            # then we stop trying to make combinations\n            return combinations\n        l1 -= 1\n        l2 += 1 \n```\n\n\nWhile this method does work for smaller numbers of bricks (returning 2 combinations for 5 blocks and 1 combination for 3 or 4 blocks), it does not work for much larger numbers that would be impossible to do on sheets of paper.\n    ", "Answer": "\r\nWikipedia gives the generating function for the number of partitions of n with distinct parts as q(n) = product (1+x^k) for k=1..infinity. Given that you exclude the possibility of a single tower, the number of different valid tower arrangements is q(n)-1.\n\nThis gives this neat O(n^2) time and O(n) space program for counting tower arrangements.\n\n```\ndef towers(n):\n    A = [1] + [0] * n\n    for k in xrange(1, n+1):\n        for i in xrange(n, k-1, -1):\n            A[i] += A[i-k]\n    return A[n] - 1\n\nprint towers(200)\n```\n\n\nThe output is as required:\n\n```\n487067745\n```\n\n\nTo understand the code, one can observe that ```\nA```\n stores the first n+1 coefficients of the generating function product(1+x^k) for k=1...infinity. Each time through the ```\nk```\n loop we add one more term to the product. We can stop at ```\nn```\n rather than infinity, because subsequent terms of the product do not affect the first n+1 coefficients.\n\nAnother, more direct, way to think about the code is to define ```\nT(i, k)```\n to be the number of tower combinations (including the single tower) with ```\ni```\n blocks, and where the maximum height of any tower is ```\nk```\n. Then:\n\n```\nT(0, 0) = 1\nT(i, 0) = 0 if i > 0\n\nT(i, k) = T(i, k-1)               if i < k\n        = T(i, k-1) + T(i-k, k-1) if i >= k\n```\n\n\nThen one can observe that after ```\nj```\n iterations of the ```\nfor k```\n loop, ```\nA```\n contains the values of ```\nT(j, i)```\n for ```\ni```\n from ```\n0```\n to ```\nn```\n. The update is done somewhat carefully, updating the array from the end backwards so that results are changed only after they are used.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "different result from recursive and dynamic programming\r\n                \r\nWorking on below problem,\n\nProblem,\n\nGiven a m * n grids, and one is allowed to move up or right, find the different paths between two grid points. \n\nI write a recursive version and a dynamic programming version, but they return different results, and any thoughts what is wrong?\n\nSource code,\n\n```\nfrom collections import defaultdict\ndef move_up_right(remaining_right, remaining_up, prefix, result):\n    if remaining_up == 0 and remaining_right == 0:\n        result.append(''.join(prefix[:]))\n        return\n    if remaining_right > 0:\n        prefix.append('r')\n        move_up_right(remaining_right-1, remaining_up, prefix, result)\n        prefix.pop(-1)\n    if remaining_up > 0:\n        prefix.append('u')\n        move_up_right(remaining_right, remaining_up-1, prefix, result)\n        prefix.pop(-1)\ndef move_up_right_v2(remaining_right, remaining_up):\n    # key is a tuple (given remaining_right, given remaining_up),\n    # value is solutions in terms of list\n    dp = defaultdict(list)\n    dp[(0,1)].append('u')\n    dp[(1,0)].append('r')\n    for right in range(1, remaining_right+1):\n        for up in range(1, remaining_up+1):\n            for s in dp[(right-1,up)]:\n                dp[(right,up)].append(s+'r')\n            for s in dp[(right,up-1)]:\n                dp[(right,up)].append(s+'u')\n    return dp[(right, up)]\n\nif __name__ == \"__main__\":\n    result = []\n    move_up_right(2,3,[],result)\n    print result\n    print '============'\n    print move_up_right_v2(2,3)\n```\n\n    ", "Answer": "\r\nIn version 2 you should be starting your for loops at 0 not at 1.  By starting at 1 you are missing possible permutations where you traverse the bottom row or leftmost column first.  \n\nChange version 2 to:\n\n```\ndef move_up_right_v2(remaining_right, remaining_up):\n    # key is a tuple (given remaining_right, given remaining_up),\n    # value is solutions in terms of list\n    dp = defaultdict(list)\n    dp[(0,1)].append('u')\n    dp[(1,0)].append('r')\n    for right in range(0, remaining_right+1):\n        for up in range(0, remaining_up+1):\n            for s in dp[(right-1,up)]:\n                dp[(right,up)].append(s+'r')\n            for s in dp[(right,up-1)]:\n                dp[(right,up)].append(s+'u')\n    return dp[(right, up)]  \n```\n\n\nAnd then:\n\n```\nresult = []\nmove_up_right(2,3,[],result)\n\nset(move_up_right_v2(2,3)) == set(result)\nTrue\n```\n\n\nAnd just for fun... another way to do it:\n\n```\nfrom itertools import permutations\n\nlist(map(''.join, set(permutations('r'*2+'u'*3, 5))))\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "The overlapping sub problems in bitmask dynamic programming\r\n                \r\nI am trying to learn bit masking with dynamic programming but I'm failing to understand the overlapping sub problems for a case. Can someone please explain how the sub problems overlap based on any example they feel fit for explaining easily? \n    ", "Answer": "\r\nLet's take the example for a ```\nShortest Hamiltonian walk```\n, In this problem we need to find a Hamiltonian walk that is the shortest where each edge has a certain amount of weight associated with it.\n\nHamiltonian walk is where we visit ```\neach and every node```\n in the graph ```\nexactly once```\n.\n\nThis problem can be solved using ```\nDP Bitmasks```\n for small no of nodes. So what we do is to keep a ```\nBitmask```\n to keep track of which nodes we have visited in the current state, and then we can iterate over all the nodes not visited using the ```\nmask```\n we can go to different states.\n\nNow suppose a subproblem lets say of ```\nk```\n no of nodes is computed, this solution of ```\nk```\n nodes constitutes of smaller subproblems, that form a larger solution of k nodes, i.e initial solution had only 2 nodes, then 3 and so on when we reached the ```\nkth```\n node.\n\nNow let's take another subproblem that constitutes of let's say ```\nm```\n nodes also exists.\n\nNow there is an edge from a node in the first subproblem to a node in the second subproblem and we want to join these 2 subproblems, so in this case all the smaller subproblems of the ```\nk```\n nodes are also smaller subproblems of the whole combined solution and hence here is referred to as overlapping as it is present in both the first subproblems and the larger combined subproblem.\n\nIn order to avoid redundant calculation of these overlapping subproblems we use the concept of ```\nmemoisation```\n, i.e once we have the answer to a overlapping subproblem we store it for later use.\n\nAlso note that in the above 2 subproblem's no vertex should be present in both the smaller subproblem which we can check using the corresponding bitmasks.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Refactor with some dynamic programming?\r\n                \r\nI have a piece of code here that i really could use some help with refactoring. I need the different methods for adding relational data in a form in rails. The code is taken from http://railscasts.com/episodes/75-complex-forms-part-3, my problem is that i need to have the methods fro both the Material model and the Answer model. So i need the exact same code twice with \"materials\" replaced by \"answers\".\n\nIt seems this should be solved with some dynamic programming? But I have no experience at all with that.\n\nHow is this solved?\n\n```\nafter_update :save_materials\nafter_update :save_answers  \n\ndef new_material_attributes=(material_attributes)\n  material_attributes.each do |attributes|\n    materials.build(attributes)\n  end\nend\n\ndef existing_material_attributes=(material_attributes)\n  materials.reject(&:new_record?).each do |material|\n    attributes = material_attributes[material.id.to_s]\n    if attributes\n      material.attributes = attributes\n    else\n      materials.delete(material)\n    end\n  end\nend\n\ndef save_materials\n  materials.each do |material|\n    material.save(false)\n  end\nend\n```\n\n    ", "Answer": "\r\nYou might also want to take a look at this site:\n\nhttp://refactormycode.com/\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Why is Longest Palindromic Substring a Dynamic Programming Question?\r\n                \r\nCan someone tell me why is Longest Palindromic Substring dynamic programming. I cannot see how we can model this question wrt to 1- Optimal Substructure. 2- Overlapping subproblems.\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Get all Subsets of String through Dynamic Programming - Programming Contest,Interview\r\n                \r\nI have a string lets say 123\n\nI need Output as \n\n1,2,3,12,23,13,123 .\n\nI know this can be achieved using Dynamic programming . So I need help.\n\nThe Length of the input string is in the range 10 ^ 6 .\n\nVariation of this question : My next problem is \n\nI have to only print those subsets where digits are consecutive.So now my answer becomes\n\n1,2,3,12,23,123 .  NOTE : 13 doesnt appear here as 1 and 3 are not consecutive in the input string \"123\".\n\nIf not Dynamic Programming any other solution is also OK . Just remember that length of input string is 10^6 , so solution should be O(length)\n    ", "Answer": "\r\nHINT: Consider using suffix arrays to build up the substrings. Using a suffix tree can reduce the complexity of finding suffixes to ```\nO(n)```\n.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming: finding largest triangle\r\n                \r\nI need to find the largest triangle of ones in a matrix of zeros and ones using dynamic programming. So if this is my matrix:\n\n```\n 1 0 0 1 1\n 0 1 1 1 1\n 0 1 1 1 0\n 1 1 1 1 1\n 1 1 0 0 1\n```\n\n\nThen there are two largest triangles with the right corner at [2,2] and [4,4]. I only have to look for the right isosceles triangles (which have the angles 90◦, 45◦, 45◦) and I also need to look at only one orientation, because all the others are symmetric. So basically I need a function which takes the matrix and returns a triangle, with triangle being an object. I don't need complete code pseudocode is fine too me. \n\nFirst I thought of just using the square algorithm here: Dynamic programming - Largest square block, and when you have found the largest square, then the largest triangle must be in there. But I can easy find counter examples where this doesn't work. After that I tried to look at the upper cell and counting this with dynamic programming, but I am not sure what to do next... So my count will look like this with the matrix from above:\n\n```\n1 0 0 1 1\n0 1 1 2 2\n0 2 2 3 0\n1 3 3 4 1\n2 4 0 0 2\n```\n\n\nI think have to use this in some way.\n\nUPDATE:\n\nI think I am pretty close now, when you walkthrough the matrix n*m and and make count[i][j] = 1+ min(count[i-1][j], count[i][j-1]), so look at the left and upper cell. We get this:\n\n```\n1 0 0 1 1\n0 1 1 2 2\n0 1 2 3 0\n1 2 3 4 1\n1 2 0 0 1\n```\n\n\nThis looks pretty good to me, you can the see where the right corner is of the [4,4] solution. Can anyone think of any counter examples? I only I have to return one solution, so returning this solution is fine.\n\nUPDATE 2:\nI have found a counterexample, let position [4,4] be 0, we then get the following matrix:\n\n```\n 1 0 0 1 1\n 0 1 1 1 1\n 0 1 1 1 0\n 1 1 1 0 1\n 1 1 0 0 1\n```\n\n\nCount will look like this after walking through the matrix:\n\n```\n1 0 0 1 1\n0 1 1 2 2\n0 1 2 3 0\n1 2 3 0 1\n1 2 0 0 1\n```\n\n\nNow it will return the triangle with right corner [3,4] (third row fourth column), which is incorrect it should find [2,2]. So I thought maybe just going from the top left (what we have done so far) and from the right bottom and take the max from that. So count with right bottom will look like this (look at the cell below and to the right):\n\n```\n1 0 0 2 1\n0 4 3 2 1\n0 3 2 1 0\n2 2 1 1 1\n1 1 0 0 1\n```\n\n\nNow we do find the solution of [2,2]. So I think using these methods will give me the solution, can anyone think of a better solution or a counter example for this one?\n\nUPDATE 3:\nkraskevich made me realize that we have to use this algorithm four times. From the top left, top right, bottom left, bottom right and then just take the maximum, because then you have taken all the possibilities. Anyone has a better way to do this? Is this algorithm then correct? (So just four times the same algorithm, only an other start point in the matrix)\n\nAlso for the people who don't really understand what I am doing (I might go a little fast) take a look again at this: Dynamic programming - Largest square block the approach is very similar and it is very well explained there what there is done.\n    ", "Answer": "\r\nYes, your idea is almost correct. Let's formalize it.\n\nClaim:\n\n```\nf(i, j)```\n is the size of the largest triangle with the right bottom corner at the ```\n(i, j)```\n position and it is computed correctly.\n\nProof:\n\nLet's use induction.\n\nThe base case: for all cells in the first row and or in the first column the size of a triangle is either one or zero(depending on the value in this cell). \n\nInduction step: \n\nLet's assume that ```\nf(i - 1, j)```\n and ```\nf(i, j - 1)```\n have been computed correctly.  \n\n\n```\nf(i - 1, j) >= f(i, j) - 1```\n and ```\nf(i, j - 1) >= f(i, j) - 1```\n.It is the case because any sub-triangle of a triangle with ```\n1```\ns is a triangle with ```\n1```\ns. It implies that ```\nf(i, j) <= f(i - 1, j) + 1```\n and ```\nf(i, j) <= f(i, j - 1) + 1```\n, or, put it another way, ```\nf(i, j) <= min(f(i - 1, j) + 1, f(i, j - 1) + 1) = min(f(i - 1, j), f(i, j - 1)) + 1```\n. Thus, ```\nf(i, j) <= min(f(i - 1, j), f(i, j - 1)) + 1```\n holds true.\nLet's assume that ```\nmin(f(i - 1, j), f(i, j - 1)) = k```\n. Then there is triangle of size ```\nk```\n in the ```\n(i - 1, j)```\n cell and another triangle of size ```\nk```\n in the ```\n(i, j - 1)```\n cell. Together with the ```\n(i, j)```\n cell, these two triangles form a triangle of size ```\nk + 1```\n. Thus, ```\nf(i, j) >= min(f(i - 1, j), f(i, j - 1)) + 1```\n. \n\n\nI have just shown that ```\nf(i, j) >= min(f(i - 1, j), f(i, j - 1)) + 1```\n and ```\nf(i, j) <= min(f(i - 1, j), f(i, j - 1)) + 1```\n. It implies that ```\nf(i, j) = min(f(i - 1, j), f(i, j - 1)) + 1```\n. Thus ```\nf(i, j)```\n is computed correctly, too. \n\nNote that we have taken into account only such triangles that have their right angle in the right-bottom position. To take into account all possible triangles, we can simply run this algorithm for all 4 possible rotations of the given matrix. \n\nLet's prove that running this algorithm in 4 directions is sufficient:\n\nThere are only four possible positions of the right angle of an arbitrary right isosceles triangle in a matrix: bottom-left, bottom-right, top-left and top-right. Running this algorithm in a fixed direction finds the largest triangle for this direction(I have proven it above). Thus, running this algorithm in all possible direction is sufficient to find the largest triangle in the matrix. \n\nThis algorithm is optimal in terms of time complexity because it has an ```\nO(n * m)```\n time complexity, and just reading the input already requires ```\nO(n * m)```\n time(we cannot find the answer without seeing all elements of the matrix in a general case). \n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming algorithm wrong\r\n                \r\nI was trying to solve this dynamic programming question https://www.hackerrank.com/challenges/equal and my approach toward this is that\n\n(1) Sort the array\n\n(2) Find the max\n\n(3) For each elements from 0 to array length -1 , try to make each element as \n    close to max element by increasing it by 5 and then by 2 and lastly by 1.\n\n(4) Sum number of 1,2,5 added to each number till now so that increments for \n    this number can be clubbed together with previous one.\n\n(5) Repeat step from 3 to 4 for max, max+1,max+2, max+5\n\nHere is the algorithm, but it's failing some test cases . Please let me know where I am wrong here ?\n\n```\nimport java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.math.*;\nimport java.util.regex.*;\n\npublic class Solution {\n\n    public static void main(String[] args) {\n        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */\n        int a = 0 , no = 0;\n        int no1[];\n\n        Scanner scno = new Scanner(System.in);\n        a = scno.nextInt();\n\n\n\n\n\n        for ( int i = 0 ; i < a ; i++ )\n        {\n            no = scno.nextInt();\n            no1 = new int[no];\n            for ( int j = 0 ; j < no ; j++ )\n            {\n                no1[j] = scno.nextInt();\n            }\n            System.out.println(Solution.no(no1));\n        }\n    }\n\n    private static int no(int[] nums)\n    {\n        int a = 0 , no = 0;\n        int[] no1 = new int[]{0,0,0};\n\n        if ( null == nums || 0 == nums.length || 1 == nums.length ) return 0;\n        int arr[] = new int[]{1,2,5};\n\n        Arrays.sort(nums);\n        int max = nums[nums.length - 1];\n        for ( int a1 = 0 ; a1 <= arr.length ; a1++ )\n        {\n            int temp = no;\n            no = 0;\n            Arrays.fill(no1, 0);\n            if ( arr.length == a1 )\n                max = nums[nums.length - 1];\n            else\n            {\n                max = nums[nums.length - 1] + arr[a1];\n                no1[a1]++;\n                no++;\n            }\n            for ( int i = 0 ; i < nums.length - 1 ; i++ )\n            {\n                if ( i != 0 && nums[i] == nums[i-1] )\n                    continue;\n                else\n                {\n                    a = ( max - nums[i] );\n                    for ( int j = 0 , n = a ; j < arr.length ; j++ )\n                    {\n                        a = n / arr[arr.length - 1 - j] ;\n                        if ( a > no1[no1.length - 1 -j] )\n                        {\n                            no += a - no1[no1.length - 1 -j];\n                            no1[no1.length - 1 -j] += a - no1[no1.length - 1 -j];\n                        }\n                        n = n % arr[arr.length - 1 - j];\n                    }               \n                }\n            }\n            if ( 0 != a1 ) no = Math.min(temp, no);\n        }\n        return no;\n    }\n\n}\n```\n\n\nThanks In Advance\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Writing recursive algorithm with dynamic programming\r\n                \r\nI want to write an algorithm using a dynamic programming technique, which does the following:\nFind number of monotonic paths along the edges of a grid with n × n square cells, which do not pass above the diagonal. A monotonic path is one which starts in the lower left corner, finishes in the upper right corner, and consists entirely of edges pointing rightwards or upwards.\n\nI had some ideas, but can't figure out how to do it right.\n    ", "Answer": "\r\nFirst, find a base for your recursion by solving a degenerate case (a ```\n0 x 0```\n grid). Then look for a recurrence step by imagining that part of the problem, say, ```\nK x M```\n is already solved, and see if you can expand upon that solution by adding one row or one column to it, making the solution ```\nK+1 x M```\n or ```\nK x M+1```\n. This should be simple: for each point you add, see if a grid point is below the diagonal, and then add up the number of paths leading to that point from the bottom and from the left. One of these points would be in the ```\nK x M```\n, the other would be in the additional row or column that you are building.\n\nWith the degenerate case and a recursive step in hand, build your solution by first solving a ```\n0 x N```\n problem, then ```\n1 x N```\n, then ```\n2 x N```\n and so on, until you have your ```\nN x N```\n solution. \n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "dynamic programming, nth string\r\n                \r\nHow to solve the   problem https://www.hackerearth.com/problem/algorithm/special-numbers-39d71325/.\n\nThe first number in a sequence of numbers is 1. Every subsequent ith number of the sequence is constructed by applying the following operations on the (i-1)th number:\n\n\nReplacing 1 with 114\nReplacing 4 with 1\n\n\nTherefore, the sequence will be as follows:\n\n1, 114, 1141141, 11411411141141114 , ...\n\nWrite a program to find a digit which is the jth  digit of the ith number in this sequence. If the ith number has less than j digits, print -1.\n\nInput format\n\n\nFirst line: T (number of test cases)\nFirst line in each test case: Two space-separated integers i and j\n\n\nOutput format \n\nFor each test case, print a digit which is the jth digit of the ith number in this sequence. If the ith number has less than j digits, print -1.\n\nConstraints\n\n1<=T<=10000(10 to the power 4)\n\n1<=i<=1000000(10 to the power 6)\n\n1<=j<=1000000000000(10 to the power 12)\n\n\n\n```\nSample input                            Sample output\n4\n2 2                                               1\n2 3                                               4\n3 6                                               4\n3 7                                               1\n```\n\n\n\n\nExplanation\n\n1st test case: 2nd number in the sequence is 114,     2nd digit is 1.\n\n2nd test case: 2nd number in the sequence is 114,     3rd digit is 4.\n\n3rd test case: 3rd number in the sequence is 1141141, 6th digit is 4.\n\n4th test case: 3rd number in the sequence is 1141141, 7th(last) digit is 1.\n\n\n\nStoring all the strings (upto ith string) in vector will take enormous amount of time. The tag of the problem is memoization(dynamic programming). I want code/strategy  using memoization(dynamic programming).\n\n\n\nI don't think the following approach of mine is even closer to what the actual/correct solution will be.\n\n\n\nSee the comment after the line    ```\nvector<string> v(15);```\n\n\n\n\nIf this is wrong platform to ask such questions, tell me where to ask such questions.\n\n```\n#include<iostream>\n#include<string>\n#include<vector>\n#include<cstring>\n#include<climits>\n//#define tr(v,it) for(typeof(v.begin()) it=v.begin();it!=v.end();it++)\nusing namespace std;\n\nint main() {\n    vector<string> v(15);//v(14) runs under 1 sec even v(15) gives tle. So think how much time v(1000000) will take.\n    v[0]=\"1\";\n    vector<string>::iterator it;\n    int n,h,i,j,tc;\n    string s,s1;\n\n\n    char ch='a';\n    for(it=v.begin()+1;it!=v.end();it++) {//set value\n         s=*(it-1); s1=\"\";\n         for(unsigned int i=0;i<s.length();i++) {\n             char ch=s[i];\n             if(ch=='1') {\n                 s1=s1+\"114\";\n             }\n             else {\n                 s1=s1+'1';\n             }\n         }\n         *it=s1;\n    }\n    /*for(it=v.begin();it!=v.end();it++) {//print value\n        cout<<*it<<endl;\n    }\n    cin>>tc;\n    while(tc--) {\n        cin>>i>>j;\n        cout<<v[i-1][j-1];\n\n    }*/\n    return 0;\n}\n```\n\n\n//Thanks and regards\n    ", "Answer": "\r\nLet's look at the sequence and its length;\n\n```\n114\n3\n114 114 1\n7\n114 114 1 114 114 1 114\n    7         7      3\n   773       773     7\n773 773 7 773 773 7 773\n...\n```\n\n\nEach length is a doubling of the previous sequence concatenated with the sequence before that, AKA:\n\n```\nlength(i) =\n  2 * length(i - 1) + length(i - 2)\n```\n\n\nGiven a position in the final string, since we know the previous sequence lengths, we can determine of it's in (1) the first of the doubled previous, (2) the second of the doubled previous, or (3) the appended, second to last sequence.\n\nBy tracking it's location, we keep transforming its position to one that's in one of the previous sequences, until we get to the very first.\n\nFor example:\n\n```\n    7         7      3\n114 114 1 114 114 1 114\n                  ^\n```\n\n\nWe know the previous two sequences were of length 7 and 3, so we can determine that we are on the 7th index of the second 7-length sequence. Now we continue:\n\n```\n114 114 1\n        ^\n```\n\n\nThe previous two sequence lengths were 3 and 1 so we are on the 1st index of the second to last sequence (the one with length 1).\n\nResult: 1\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "A Dynamic programming  problem\r\n                \r\nCan anyone help me find an optimal Dynamic programming algorithm for this problem\n\nOn the way to dinner, the CCC competitors are lining up for their delicious curly fries. The N (1 ≤ N ≤ 100) competitors have lined up single-file to enter the cafeteria.\n\nDoctor V, who runs the CCC, realized at the last minute that programmers simply hate standing in line next to programmers who use a different language. Thankfully, only two languages are allowed at the CCC: Gnold and Helpfile. Furthermore, the competitors have decided that they will only enter the cafeteria if they are in a group of at least K (1 ≤ K ≤ 6) competitors.\n\nDoctor V decided to iterate the following scheme:\n\n```\n* He will find a group of K or more competitors who use the same language standing next to each other in line and send them to dinner.\n* The remaining competitors will close the gap, potentially putting similar-language competitors together.\n```\n\n\nSo Doctor V recorded the sequence of competitors for you. Can all the competitors dine? If so, what is the minimum number of groups of competitors to be sent to dinner?\nInput\n\nThe first line contains two integers N and K.\nThe second line contains N characters that are the sequence of competitors in line (H represents Helpfile, G represents Gnold)\nOutput\n\nOutput, on one line, the single number that is the minimum number of groups that are formed for dinner. If not all programmers can dine, output -1.\n    ", "Answer": "\r\nI'd prefer not to solve an SPOJ problem in a practical manner for you, so take the following as an existence proof of a poly-time DP.\n\nFor K fixed, the set of strings that can dine is context-free. I'm going to use ```\ng```\n and ```\nh```\n instead of ```\nG```\n and ```\nH```\n. For example, for K = 3, one grammar looks like\n\n```\nS -> ε | g S g S g S G | h S h S h S H\n\nG -> ε | g S G\n\nH -> ε | h S H\n```\n\n\nThe idea is that either there are no diners, or the first diner dines with at least K - 1 others, between any two of which (and the last and the end) there is a string that can dine.\n\nNow use the weighted variant of CYK to find the minimum-weight parse, where nonempty S productions have weight 1, and all others have weight 0. For K fixed, the running time of CYK is O(N3).\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming approach to calculating Stirling's Number\r\n                \r\n```\nint s_dynamic(int n,int k) {\n    int maxj = n-k;\n\n    int *arr = new int[maxj+1];\n\n    for (int i = 0; i <= maxj; ++i)\n        arr[i] = 1;\n\n    for (int i = 1; i <= k; ++i)\n        for(int j = 1; j <= maxj; ++j)\n            arr[j] += i*arr[j-1];\n\n    return arr[maxj];\n}\n```\n\n\nHere's my attempt at determining Stirling numbers using Dynamic Programming.\n\nIt is defined as follows:\n\n\n  S(n,k) = S(n-1,k-1) + k S(n-1,k), if 1 < k < n \n  \n  S(n,k) = 1, if k=1 ou k=n\n\n\nSeems ok, right? Except when I run my unit test...\n\n```\npartitioningTest ..\\src\\Test.cpp:44 3025 == s_dynamic(9,3) expected:    3025    but was:    4414    \n```\n\n\nCan anyone see what I'm doing wrong?\n\nThanks!\n\nBTW, here's the recursive solution:\n\n```\nint s_recursive(int n,int k) {\n    if (k == 1 || k == n)\n        return 1;\n\n    return s_recursive(n-1,k-1) + k*s_recursive(n-1,k);\n}\n```\n\n    ", "Answer": "\r\nFound the bug.\nYou already computed your dynamic array of Stirlings numbers for k=1 (S(n,1)=1 for all n).\nYou should start computing S(n,2) - that is:\n\n```\nfor (int i = 2; i <= k; ++i) //i=2, not 1\n  for(int j = 1; j <= maxj; ++j)\n    arr[j] += i*arr[j-1];\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "SPOJ dynamic programming with BigInteger - SETNJA\r\n                \r\nI was trying to solve the following spoj problem http://www.spoj.pl/problems/SETNJA/\n\nI implemented it using recursion but the limit is quite high which will not fit in unsigned long long. On forums everyone is saying to implement it using Dynamic programming. Can anyone plz explain how to do it using DP. Here is my effort using recursion. Its correct but the answer will not fit in unsigned long long. Any hint will be appreciated \n\n```\n#include<stdio.h>\n\ntypedef unsigned long long ULLD;\nULLD ans=0ull;\nchar str[10001];\nint length;\nvoid recurse(int i, ULLD temp)\n{\n    if(str[i]=='\\0')\n    {\n        ans=ans+temp;\n        return;\n    }\n    if(str[i]=='L') recurse(i+1,2*temp);\n    else if(str[i]=='R') recurse(i+1,2*temp+1);\n    else if(str[i]=='P') recurse(i+1,temp);\n    else if(str[i]=='*')\n    {\n        recurse(i+1, 2*temp);\n        recurse(i+1 , 2*temp +1);\n        recurse(i+1, temp);\n    }\n}\n\nint main()\n{   \n    scanf(\"%s\",str);\n    length=strlen(str);\n\n    recurse(0,1);\n\n    printf(\"%llu\",ans);\n    return 0;\n} \n```\n\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Pebbling a Checkerboard with Dynamic Programming\r\n                \r\nI am trying to teach myself Dynamic Programming, and ran into this problem from MIT. \n\nWe are given a checkerboard which has 4 rows and n columns, and\nhas an integer written in each square. We are also given a set of 2n pebbles, and we want to\nplace some or all of these on the checkerboard (each pebble can be placed on exactly one square)\nso as to maximize the sum of the integers in the squares that are covered by pebbles. There is\none constraint: for a placement of pebbles to be legal, no two of them can be on horizontally or\nvertically adjacent squares (diagonal adjacency is ok).\n\n(a) Determine the number of legal patterns that can occur in any column (in isolation, ignoring\nthe pebbles in adjacent columns) and describe these patterns.\nCall two patterns compatible if they can be placed on adjacent columns to form a legal placement.\nLet us consider subproblems consisting of the rst k columns 1  k  n. Each subproblem can\nbe assigned a type, which is the pattern occurring in the last column.\n\n(b) Using the notions of compatibility and type, give an O(n)-time dynamic programming algorithm for computing an optimal placement.\n\nOk, so for part a: There are 8 possible solutions. \n\nFor part b, I'm unsure, but this is where I'm headed:\nSPlit into sub-problems. Assume i in n.\n1. Define Cj[i] to be the optimal value by pebbling columns 0,...,i, such that column i has pattern type j. \n2. Create 8 separate arrays of n elements for each pattern type. \n\nI am not sure where to go from here. I realize there are solutions to this problem online, but the solutions don't seem very clear to me. \n    ", "Answer": "\r\nYou're on the right track.  As you examine each new column, you will end up computing all possible best-scores up to that point.\n\nLet's say you built your compatibility list (a 2D array) and called it Li[y] such that for each pattern i there are one or more compatible patterns Li[y].\n\nNow, you examine column j.  First, you compute that column's isolated scores for each pattern i.  Call it Sj[i].  For each pattern i and compatible \npattern x = Li[y], you need to maximize the total score Cj such that Cj[x] = Cj-1[i] + Sj[x].  This is a simple array test and update (if bigger).\n\nIn addition, you store the pebbling pattern that led to each score.  When you update Cj[x] (ie you increase its score from its present value) then remember the initial and subsequent patterns that caused the update as Pj[x] = i.  That says \"pattern x gave the best result, given the preceding pattern i\".\n\nWhen you are all done, just find the pattern i with the best score Cn[i].  You can then backtrack using Pj to recover the pebbling pattern from each column that led to this result.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming: Do I have overlapping sub-problems?\r\n                \r\nMy algorithm\n\nLet us assume I have an 2D array of real numbers. I start at a specific cell in this array with a particularly large number in it. I want to mark which of the other cells should belong to the mentioned start cell. The rule is this: The other cell belongs to the start cell if I find a way to walk from the start cell to the other cell. I am only allowed to walk a cell up or down. I am only allowed to walk from a cell with a higher number to a cell with a lower number. Here is an example when I start at the center 9\n\n\n\nMy pseudo-algorithm is\n\n```\nfunction Step(cellNr):\n    foreach neighborNr in neighbors_of(cellNr):\n        if array_value(neighborNr) < array_value(cellNr):\n            mark_cell(neighborNr)\n            Step(neighborNr)\nStep(centerNr)\n```\n\n\nNow comes a second aspect, that I do not only do this for one start cell, but for multiple start cells, for example\n\n\n\nDynamic Programming\n\nI researched dynamic programming and found that two conditions need to be meet in order to be able to apply dynamic programming:\n\n\nsubproblems need to be overlapping\nsubproblems need to have optimal substructure\n\n\n\"[dynamic programming] refers to simplifying a complicated problem by breaking it down into simpler sub-problems in a recursive manner [...] If a problem can be solved optimally by breaking it into sub-problems and then recursively finding the optimal solutions to the sub-problems, then it is said to have optimal substructure. [...] There are two key attributes that a problem must have in order for dynamic programming to be applicable: optimal substructure and overlapping sub-problems. If a problem can be solved by combining optimal solutions to non-overlapping sub-problems, the strategy is called \"divide and conquer\" instead. This is why merge sort and quick sort are not classified as dynamic programming problems. Optimal substructure means that the solution to a given optimization problem can be obtained by the combination of optimal solutions to its sub-problems. Such optimal substructures are usually described by means of recursion. [...] Overlapping sub-problems means that the space of sub-problems must be small, that is, any recursive algorithm solving the problem should solve the same sub-problems over and over, rather than generating new sub-problems.\"Wikipedia\n\nI was wondering whether my algorithm is dynamic programming. It is definitely recursive and it seems to be optimal in substructure. I am starting to wonder about the overlapping substructure though. There is an example with Fibonacci numbers, but it seems to me that the key aspect is that intermediate results of the recursive algorithm can be stored. For my algorithm intermediate results cannot be stored - at least not for one run of a single start cell. However, when I consider the entire problem, with many start cell, we see that some of the area is connected:\n\n\n\nLets say we start with the orange 9 in the left image and go down the green path until we reach in blue 5. From there we can also get to the blue 3 and the blue 2. We finish our algorithm for the left orange 9.\n\nNow we turn to the lower orange 8 in the right image. We start from this 8 and go up the green path to the green 6. From there we get to the blue 5. We already know from the previous computations (from the orange 9 in the left image) that the blue 3 and the blue 2 are reachable from the blue 5, so we can just mark them in one swoop, without recalculating the path.\n\nThat is why I think that my overall problem is solvable with dynamic programming.\n\nQuestions\n\n\nIs my algorithm / problem dynamic programming? Why, why not?\nIf not, can I make it to be dynamic programming and if so how?\n\n    ", "Answer": "\r\nYes, this is certainly a dynamic programming problem.  It's actually the simplest/most fundamental dynamic programming problem -- find all the nodes reachable from a start node in a directed acyclic graph (multiple start nodes in your case).  You solve it with depth-first search or breadth-first search.\n\nIt fits the definition like this:\n\nOptimal structure?  Yes, the cells I can reach from a cell x is x plus the union of the cells I can reach from x's smaller neighbors.\n\nOverlapping subproblems?   Yes, two of x's neighbors can both share the same smaller neighbor.\n\nIn order to make your posted algorithm into a dynamic programming algorithm you just need to memoize the subproblems like this:\n\n```\nfunction Step(cellNr):\n    foreach neighborNr in neighbors_of(cellNr):\n        if array_value(neighborNr) < array_value(cellNr) AND cell_is_not_marked(neighborNr):\n            mark_cell(neighborNr)\n            Step(neighborNr)\nStep(centerNr)\n```\n\n\nNote that this also changes your algorithm from exponential time to linear time, and that it is a depth-first-search\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming for primitive calculator\r\n                \r\nI'm dealing with the problem, that is pretty similar to change coins problem.\n\nI need to implement a simple calculator, that can perform the following three operations with the current number x: multiply x by 2, multiply x by 3, or add 1 to x. \n\nGoal is given a positive integer n, find the minimum number of operations needed to obtain the number n starting from the number 1.\n\nI made a greedy approach to that, bur it shows incorrect results\n\n```\nimport sys\n\ndef optimal_sequence(n):\n    sequence = []\n    while n >= 1:\n        sequence.append(n)\n        if n % 3 == 0:\n            n = n // 3\n        elif n % 2 == 0:\n            n = n // 2\n        else:\n            n = n - 1\n    return reversed(sequence)\n\ninput = sys.stdin.read()\nn = int(input)\nsequence = list(optimal_sequence(n))\nprint(len(sequence) - 1)\nfor x in sequence:\n    print(x)\n```\n\n\nFor example:\n\n```\nInput: 10\nOutput: \n4\n1 2 4 5 10\n```\n\n\n4 steps. But the correct one is 3 steps:\n\n```\nOutput: \n3\n1 3 9 10\n```\n\n\nI read about dynamic programming, and hope I could implement it here. But, I can't get how to use it properly in particular case, can someone give me an advice?\n    ", "Answer": "\r\nJust solve it with a simple recursion and Memoization:\n\nCode:\n\n```\nd = {}\n\ndef f(n):\n    if n == 1:\n        return 1, -1\n    if d.get(n) is not None:\n        return d[n]\n    ans = (f(n - 1)[0] + 1, n - 1)\n\n    if n % 2 == 0:\n        ret = f(n // 2)\n        if ans[0] > ret[0]:\n            ans = (ret[0] + 1, n // 2)\n\n    if n % 3 == 0:\n        ret = f(n // 3)\n        if ans[0] > ret[0]:\n            ans = (ret[0] + 1, n // 3)\n\n    d[n] = ans\n    return ans\n\ndef print_solution(n):\n    if f(n)[1] != -1:\n        print_solution(f(n)[1])\n    print n,\n\ndef solve(n):\n    print f(n)[0]\n    print_solution(n)\n    print ''\n\nsolve(10)\n```\n\n\nHint: f(x) returns a tuple (a, b), which ```\na```\n denotes the minimum steps to get x from 1, and ```\nb```\n denotes the previous number to get the optimum solution. ```\nb```\n is only used for print the solution. \n\nOutput:\n\n```\n4 # solution for 10\n1 3 9 10 \n\n7 # solution for 111\n1 2 4 12 36 37 111\n```\n\n\nYou may debug my code and to learn how it works. If you are beginner at DP, you could read my another SO post about DP to get a quick start. \n\n\n\nSince Python can't recurse a lot (about 10000), I write an iterative version:\n\n```\n# only modified function print_solution(n) and solve(n)\n\ndef print_solution(n):\n    ans = []\n    while f(n)[1] != -1:\n        ans.append(n)\n        n = f(n)[1]\n    ans.append(1)\n    ans.reverse()\n    for x in ans:\n        print x,\n\ndef solve(n):\n    for i in range(1, n):\n        f(i)[0]\n    print_solution(n)\n    print ''\n\nsolve(96234) # 1 3 9 10 11 22 66 198 594 1782 5346 16038 16039 32078 96234 \n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "dynamic programming - what's the asymptotic runtime?\r\n                \r\nI'm teaching myself dynamic programming. It's almost magical. But seriously. Anyway, the problem I worked out was : ```\nGiven a stairs of N steps and a child who can either take 1, 2, or 3 steps at a time, how many different ways can the child reach the top step?```\n. The problem wasn't too hard, my implementation is below.\n\n```\nimport java.util.HashMap;\n\npublic class ChildSteps {\n    private HashMap<Integer, Integer> waysToStep;\n\n    public ChildSteps() {\n        waysToStep = new HashMap<Integer, Integer>();\n    }\n\n    public int getNthStep(int n) {\n        if (n < 0) return 0; // 0 ways to get to a negative step\n\n        // Base Case\n        if (n == 0) return 1;\n\n        // If not yet memorized\n        if (!waysToStep.containsKey(n)) {\n            waysToStep.put(n, getNthStep(n - 3) + getNthStep(n - 2) + getNthStep(n - 1));\n        }\n\n        return waysToStep.get(n);\n    }\n}\n```\n\n\nHowever, now I want to get the runtime. How should I figure this out? I am familiar (and not much more) with Akra-Bazzi and Master Theorem. Do those apply here? \n\nhttp://en.wikipedia.org/wiki/Master_theorem\n\nHere it would seem that it could be: ```\nT(N) = 3 * T(???) + O(1)```\n but I'm really not sure. \n\nthanks guys. \n    ", "Answer": "\r\nIn a worst case scenario analysis it would be:\n\n```\nT(N) = N * (containsKey(N) + 8)\n```\n\n\nAssuming that containsKey = N (it is probably ```\nN^2```\n or ```\nLog(N)```\n) then this simplifies to ```\nT(N) = N```\n.\n\nYou would have to find out the function for ```\ncontainsKey(N)```\n to get the actual equation.\n\nYou're really over thinking this though; you don't need to do a algorithm analysis for this. Good quote for you: \"Premature optimization is the root of all evil\"\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Swift dynamic programming without using inout for the cache\r\n                \r\nI've been completing dynamic programming challenges. I'm trying to complete the following but get the the wrong answer with my current implementation\nhttps://www.hackerearth.com/practice/algorithms/dynamic-programming/introduction-to-dynamic-programming-1/tutorial/\nThe idea behind this is :\n\nCalculate the maximum price of wines in a list.\nYou can only take a single wine for each year\nEach wine can only be picked from the end or the beginning of the wines list.\nthe price of each wine is determined by wine * year\nthe year starts at 1\n\nWhen I define the cache outside the function (i.e. NOT passing as an inout parameter as in my solution here:\nhttps://gist.github.com/stevencurtis/c265e523323be73ec823084b0707a426) rather my solution as below gives the wrong answer (49 rather than 50)\n```\nvar mem = [[Int]]()\n\nfunc dynamicMotivation (_ wines: [Int] ) -> Int {\n    mem = Array(repeating: Array(repeating: 0, count: wines.count), count: wines.count)\n    return motivationD(wines, year: 1, ptr1: 0, ptr2: wines.count - 1, 0)\n}\n\nfunc motivationD(_ wines: [Int], year: Int, ptr1: Int, ptr2: Int, _ runningTotal: Int) -> Int {\n    if (ptr1 > ptr2) {return runningTotal}\n    if mem[ptr1][ptr2] != 0 {\n        return mem[ptr1][ptr2]\n    }\n    let maxProfit = max(\n        motivationD(wines, year: year + 1, ptr1: ptr1 + 1, ptr2: ptr2, runningTotal + year * wines[ptr1])\n        ,\n        motivationD(wines, year: year + 1, ptr1: ptr1, ptr2: ptr2 - 1, runningTotal + year * wines[ptr2])\n    )\n    mem[ptr1][ptr2] = maxProfit\n    return maxProfit\n}\n\ndynamicMotivation([2,3,5,1,4]) // 50 is the optimal solution here\n```\n\nHow can I use Memoization in this case without using an inout Parameter, correcting the code above to give an answer of 50 rather than the incorrect 49 as written above.\n    ", "Answer": "\r\nYour problem isn't ```\nmem```\n and whether or not it is passed as ```\ninout```\n.  Your problem is the ```\nrunningTotal```\n parameter.  I have removed that parameter to match the algorithm as specified in the link, and it now returns the correct result.\n\n```\nvar mem = [[Int]]()\n\nfunc dynamicMotivation (_ wines: [Int] ) -> Int {\n    mem = Array(repeating: Array(repeating: 0, count: wines.count), count: wines.count)\n    return motivationD(wines, year: 1, ptr1: 0, ptr2: wines.count - 1)\n}\n\nfunc motivationD(_ wines: [Int], year: Int, ptr1: Int, ptr2: Int) -> Int {\n    if (ptr1 > ptr2) { return 0 }\n    if mem[ptr1][ptr2] != 0 {\n        return mem[ptr1][ptr2]\n    }\n\n    let maxProfit = max(\n        motivationD(wines, year: year + 1, ptr1: ptr1 + 1, ptr2: ptr2) + year * wines[ptr1]\n        ,\n        motivationD(wines, year: year + 1, ptr1: ptr1, ptr2: ptr2 - 1) + year * wines[ptr2]\n    )\n    mem[ptr1][ptr2] = maxProfit\n    return maxProfit\n}\n\ndynamicMotivation([2,3,5,1,4]) // 50 is the optimal solution here\n```\n\n\n\n```\n50\n```\n\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "rod-cutting by dynamic programming\r\n                \r\nIn the CLRS Introduction to Algorithms, for the rod-cutting problem during introducing the dynamic programming, there is a paragraph saying that\n\n\n  In a related, but slightly simpler, way to arrange a recursive\n  structure for the rodcutting problem, we view a decomposition as\n  consisting of a first piece of length i cut off the left-hand end, and\n  then a right-hand remainder of length n - i. Only the remainder, and\n  not the first piece, may be further divided.\n\n\nWhy is that true that we don't need to consider the decomposition of the first piece of length i cut off the left-hand end?\n\nThanks.\n    ", "Answer": "\r\nThe length of rod cut off the left-hand end is the piece that is cut to the length that is needed -- the use of the right-hand piece isn't decided yet and may be cut into smaller pieces.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Segmentation fault in Dynamic Programming Problem\r\n                \r\nI have a problem to solve which requires to find the minimum number of prime digits to form a number which is equal to the given number N. I choose dynamic programming for this problem but it gets Segmentation Fault (Core dumped) Message. \n\n```\nlong long sumOfOneDigitPrime(long long n)\n{\n    vector<long long> arr;\n    long long i;\n    for(i = 0; i <= n; i++)\n    {\n        arr.push_back(100000000000LL);\n    }\n    arr[0] = arr[2] = arr[3] = arr[5] = arr[7] = 1;\n    for(i = 1; i <= n; i++)\n    {\n        if(i >= 2)\n        {\n            arr[i] = min(arr[i], 1+arr[i-2]);\n        }\n        if(i >= 3)\n        {\n            arr[i] = min(arr[i], 1+arr[i-3]);\n        }\n        if(i >= 5)\n        {\n            arr[i] = min(arr[i], 1+arr[i-5]);\n        }\n        if(i >= 7)\n        {\n            arr[i] = min(arr[i], 1+arr[i-7]);\n        }\n    }\n    if(arr[n] == 100000000000LL)\n        return -1;\n    else\n        return arr[n];\n}\n```\n\n\nAs you can see that the algorithms here is clear but I don't know why it gets Segmentation Fault (Core dumped) here. Before I use any indexes, I check it first.\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Pebbling a Checkerboard with Dynamic Programming\r\n                \r\nI am trying to teach myself Dynamic Programming, and ran into this problem from MIT. \n\nWe are given a checkerboard which has 4 rows and n columns, and\nhas an integer written in each square. We are also given a set of 2n pebbles, and we want to\nplace some or all of these on the checkerboard (each pebble can be placed on exactly one square)\nso as to maximize the sum of the integers in the squares that are covered by pebbles. There is\none constraint: for a placement of pebbles to be legal, no two of them can be on horizontally or\nvertically adjacent squares (diagonal adjacency is ok).\n\n(a) Determine the number of legal patterns that can occur in any column (in isolation, ignoring\nthe pebbles in adjacent columns) and describe these patterns.\nCall two patterns compatible if they can be placed on adjacent columns to form a legal placement.\nLet us consider subproblems consisting of the rst k columns 1  k  n. Each subproblem can\nbe assigned a type, which is the pattern occurring in the last column.\n\n(b) Using the notions of compatibility and type, give an O(n)-time dynamic programming algorithm for computing an optimal placement.\n\nOk, so for part a: There are 8 possible solutions. \n\nFor part b, I'm unsure, but this is where I'm headed:\nSPlit into sub-problems. Assume i in n.\n1. Define Cj[i] to be the optimal value by pebbling columns 0,...,i, such that column i has pattern type j. \n2. Create 8 separate arrays of n elements for each pattern type. \n\nI am not sure where to go from here. I realize there are solutions to this problem online, but the solutions don't seem very clear to me. \n    ", "Answer": "\r\nYou're on the right track.  As you examine each new column, you will end up computing all possible best-scores up to that point.\n\nLet's say you built your compatibility list (a 2D array) and called it Li[y] such that for each pattern i there are one or more compatible patterns Li[y].\n\nNow, you examine column j.  First, you compute that column's isolated scores for each pattern i.  Call it Sj[i].  For each pattern i and compatible \npattern x = Li[y], you need to maximize the total score Cj such that Cj[x] = Cj-1[i] + Sj[x].  This is a simple array test and update (if bigger).\n\nIn addition, you store the pebbling pattern that led to each score.  When you update Cj[x] (ie you increase its score from its present value) then remember the initial and subsequent patterns that caused the update as Pj[x] = i.  That says \"pattern x gave the best result, given the preceding pattern i\".\n\nWhen you are all done, just find the pattern i with the best score Cn[i].  You can then backtrack using Pj to recover the pebbling pattern from each column that led to this result.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming algorithm for Longest Common Subsequence in Java\r\n                \r\nI'm trying to write a dynamic programming algorithm for the Longest Common Subsequence.\nThe return should be the length of this subsequence.\nBut my algorithm always returns 0. I couldn't find the error.\n\n```\npublic static int LCS(String A, String B, int m, int n) {\n    int table[][] = new int[m + 1][n + 1];\n\n    for (int i = 0; i < m; i++) {\n        table[i][0] = 0;\n    }\n    for (int i = 1; i < n; i++) {\n        table[0][n] = 0;\n    }\n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            if (A.charAt(i) == B.charAt(j)) {\n                table[i][j] = table[i - 1][j - 1] + 1;\n            } else {\n                table[i][j] = max(table[i][j - 1], table[i - 1][j]);\n            }\n        }\n    }\n\n    return table[m][n];\n}\n\nprivate static int max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\npublic static void main(String args[]) {\n    Scanner in = new Scanner(System.in);\n\n    System.out.println(\"Your input words:\\n\");\n    String x = in.nextLine();\n    String y = in.nextLine();\n\n    in.close();\n\n    int m = x.length();\n    int n = y.length();\n\n    System.out.println(\"Length of LCS is \" + LCS(x, y, m, n));\n}\n```\n\n    ", "Answer": "\r\nLooks like you implemented this algorithm, but have a few errors:\n\n\nYour loops should be ```\n1..m```\n and ```\n1..n```\n inclusive, meaning you need to change ```\n<```\n to ```\n<=```\n.\n```\ncharAt()```\n is zero-based, so you need ```\ncharAt(i - 1)```\n and ```\ncharAt(j - 1)```\n.\n\n\nThese are not errors, but:\n\n\nThe loops to initialize to 0 are unnecessary in Java. ```\ntable```\n is already initialized to all zeroes by the ```\nnew```\n operator.\nNo need to implement ```\nmax()```\n, since it's already implemented as ```\nMath.max()```\n.\n\n\nSo, here is the result, using names from the linked article:\n\n```\npublic static int LCS(String X, String Y) {\n    final int m = X.length();\n    final int n = Y.length();\n    int[][] C = new int[m + 1][n + 1];\n    for (int i = 1; i <= m; i++)\n        for (int j = 1; j <= n; j++)\n            if (X.charAt(i - 1) == Y.charAt(j - 1))\n                C[i][j] = C[i - 1][j - 1] + 1;\n            else\n                C[i][j] = Math.max(C[i][j - 1], C[i - 1][j]);\n    return C[m][n];\n}\n```\n\n\nTEST\n\n```\nSystem.out.println(LCS(\"This is a test\", \"Does it work ok?\"));\n```\n\n\nOUTPUT\n\n```\n5\n```\n\n\nHere is the matching letters of the longest common subsequence:\n\n```\nThis is a test\n   ↑↑↑ ↑ ↑\n   ↓↓↓ ↓    ↓\nDoes it work ok?\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming: Do I have overlapping sub-problems?\r\n                \r\nMy algorithm\n\nLet us assume I have an 2D array of real numbers. I start at a specific cell in this array with a particularly large number in it. I want to mark which of the other cells should belong to the mentioned start cell. The rule is this: The other cell belongs to the start cell if I find a way to walk from the start cell to the other cell. I am only allowed to walk a cell up or down. I am only allowed to walk from a cell with a higher number to a cell with a lower number. Here is an example when I start at the center 9\n\n\n\nMy pseudo-algorithm is\n\n```\nfunction Step(cellNr):\n    foreach neighborNr in neighbors_of(cellNr):\n        if array_value(neighborNr) < array_value(cellNr):\n            mark_cell(neighborNr)\n            Step(neighborNr)\nStep(centerNr)\n```\n\n\nNow comes a second aspect, that I do not only do this for one start cell, but for multiple start cells, for example\n\n\n\nDynamic Programming\n\nI researched dynamic programming and found that two conditions need to be meet in order to be able to apply dynamic programming:\n\n\nsubproblems need to be overlapping\nsubproblems need to have optimal substructure\n\n\n\"[dynamic programming] refers to simplifying a complicated problem by breaking it down into simpler sub-problems in a recursive manner [...] If a problem can be solved optimally by breaking it into sub-problems and then recursively finding the optimal solutions to the sub-problems, then it is said to have optimal substructure. [...] There are two key attributes that a problem must have in order for dynamic programming to be applicable: optimal substructure and overlapping sub-problems. If a problem can be solved by combining optimal solutions to non-overlapping sub-problems, the strategy is called \"divide and conquer\" instead. This is why merge sort and quick sort are not classified as dynamic programming problems. Optimal substructure means that the solution to a given optimization problem can be obtained by the combination of optimal solutions to its sub-problems. Such optimal substructures are usually described by means of recursion. [...] Overlapping sub-problems means that the space of sub-problems must be small, that is, any recursive algorithm solving the problem should solve the same sub-problems over and over, rather than generating new sub-problems.\"Wikipedia\n\nI was wondering whether my algorithm is dynamic programming. It is definitely recursive and it seems to be optimal in substructure. I am starting to wonder about the overlapping substructure though. There is an example with Fibonacci numbers, but it seems to me that the key aspect is that intermediate results of the recursive algorithm can be stored. For my algorithm intermediate results cannot be stored - at least not for one run of a single start cell. However, when I consider the entire problem, with many start cell, we see that some of the area is connected:\n\n\n\nLets say we start with the orange 9 in the left image and go down the green path until we reach in blue 5. From there we can also get to the blue 3 and the blue 2. We finish our algorithm for the left orange 9.\n\nNow we turn to the lower orange 8 in the right image. We start from this 8 and go up the green path to the green 6. From there we get to the blue 5. We already know from the previous computations (from the orange 9 in the left image) that the blue 3 and the blue 2 are reachable from the blue 5, so we can just mark them in one swoop, without recalculating the path.\n\nThat is why I think that my overall problem is solvable with dynamic programming.\n\nQuestions\n\n\nIs my algorithm / problem dynamic programming? Why, why not?\nIf not, can I make it to be dynamic programming and if so how?\n\n    ", "Answer": "\r\nYes, this is certainly a dynamic programming problem.  It's actually the simplest/most fundamental dynamic programming problem -- find all the nodes reachable from a start node in a directed acyclic graph (multiple start nodes in your case).  You solve it with depth-first search or breadth-first search.\n\nIt fits the definition like this:\n\nOptimal structure?  Yes, the cells I can reach from a cell x is x plus the union of the cells I can reach from x's smaller neighbors.\n\nOverlapping subproblems?   Yes, two of x's neighbors can both share the same smaller neighbor.\n\nIn order to make your posted algorithm into a dynamic programming algorithm you just need to memoize the subproblems like this:\n\n```\nfunction Step(cellNr):\n    foreach neighborNr in neighbors_of(cellNr):\n        if array_value(neighborNr) < array_value(cellNr) AND cell_is_not_marked(neighborNr):\n            mark_cell(neighborNr)\n            Step(neighborNr)\nStep(centerNr)\n```\n\n\nNote that this also changes your algorithm from exponential time to linear time, and that it is a depth-first-search\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "neo4j dynamic programming query\r\n                \r\nI would be really grateful if someone show me the way to calculate minimum path with a dynamic programming algorithm like Floyd and Warshall.The algorithm has to calculate the path at every interaction,it has to making decision about which nodes choose taking in consideration the nodes already traversed.\n\nI have made a little explaination:\nhttps://drive.google.com/file/d/0B3i9KFQXzB89YXl0VkEzaDZDMHc/edit?usp=sharing\n\nMy graph is stored in a neo4j environment and it can increase in a serious way his dimension.  I use rest with everyman php neo4j libraries.\nWhat is the best way to do this?\nTraversal, cypher, gremilins, code a custom algorithm starting from http://components.neo4j.org/neo4j-graph-algo/1.4/xref/org/neo4j/graphalgo/impl/shortestpath/FloydWarshall.html ?\n\nTnx in advance\n    ", "Answer": "\r\nAt the end my solution was to use traversal framework and build unmanaged extension.\n\nM.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Subset Sum Dynamic Programming - Overlapping SubProblems\r\n                \r\nI am not able to figure out where is the DP first property of Overlapping subproblem fits in Subset Sum Problem. However, I understand the Optimal Substructure part.While doing the recursive solution of Including and excluding the element where are the problems getting overlapped? Is it like since it is an NP problem so not having two properties of DP. The Link to problem is http://www.geeksforgeeks.org/dynamic-programming-subset-sum-problem/ Can someone please help me in understanding this.\n    ", "Answer": "\r\nLet's call the entire set of numbers S = {s[1], ...., s[n]}, the target value k, and write f(X, t) = 1 if there is a subset of X that sums to t, and 0 otherwise.  So the answer we want to calculate is f(S, k).\n\nYou will get overlapping subproblems whenever two different subsets of numbers have the same sum, and that sum is less than the target k.  In detail, suppose there is a subset SI = {s[i_1], ..., s[i_p]} and a different subset SJ = {s[j_1], ..., s[j_q]}, such that sum(SI) = sum(SJ) < k.  Suppose w.l.o.g. that the indices are all in order (i.e. a < b implies i_a < i_b and j_a < j_b), and i_1 <= j_1 (if it doesn't, just swap SI and SJ).  Then the subproblem f({s[1], ..., s[m-1]}, k-sum(SI)) will arise for (at least) two different paths through the call tree: after starting at f(S, k) (i.e. the root) and choosing to include all numbers in SI and no other numbers with indices >= i_1; and after starting at f(S, k) and choosing to include all numbers in SJ and no other numbers with indices >= j_1, and then choosing to also exclude the next j_1 - i_1 numbers.\n\nWorked Example\n\nSuppose S = {3, 4, 5, 6, 11} and k = 14.  Then by excluding the 11 and including the 5 and the 6, we arrive at the subproblem f({3, 4}, 3) (which will have the solution 1) -- this corresponds to choosing SI = {5, 6} and i_1 = 3.  Alternatively, by including the 11 and then excluding the 5 and the 6, we again arrive at the subproblem f({3, 4}, 3) -- this corresponds to choosing SJ = {11} and j_1 = 5.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming\r\n                \r\nI was given a task of making all possible combinations of a 2d array through brute force algorithm and then find the best from all of them through its cost.\n\nFor example, if the array is of size 4 X 3, and it has contents let's say:\n\n```\n1  2  3\n4  5  6\n7  8  9\n10 11 12\n```\n\n\nthen one of possible combination can be\n\n```\n1\n4\n7\n10\n```\n\n\nsimilarly\n\n```\n1\n4\n7\n11\n```\n\n\n...\n\n```\n1\n4\n7\n12\n```\n\n\n...\n\n```\n1\n4\n8\n10\n```\n\n\n...\n\n```\n1\n4\n8\n11\n```\n\n\n...\n\nand so on, hence all such combinations. Remember the above mentioned combinations were stored in a 2d array, and \" - \" was inserted where there was no number. For example:\n\n```\n1 - -\n4 - -\n7 - -\n10 - -\n```\n\n\nbut as it's a 2d array, you can't store ' - ' in it, so it will only be displayed like it. Now, there will be a randomly generated cost to every combination. As in brute force, first I find all combinations and then select best combination of it. It took lot of time, for example if my array is 10 X 5.\n\nThen I have to make 5^10 combinations, which is a huge amount, and time consuming. I actually want someone to help me making alternative of it through dynamic programing. The array can be of size n x m, where m can be 2 or 3 maximum and n can be of maximum 1000. Thanks in advance.\n    ", "Answer": "\r\nIs 1 - - / - - 6 / - - 9 / - - 12 valid? I think the problem you may be asking is what is the cheapest path through this matrix, which is a standard Dynamic Programming Problem, see http://en.wikipedia.org/wiki/Dynamic_programming#Checkerboard.\n\nOtherwise if the problem means simply max sum, then just do max in each row, which should be clear, since you can only have one element per row. \n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming for a complete binary tree\r\n                \r\nI'm trying to apply dynamic programming on a complete binary tree with 15 nodes, where each node is of type Employee and has a value(Evalution_Score) of type double and an ID. \n\nI created an array of type double to store the max values. The method find returns the node with ID = j or I\n\n```\npublic class BT<T> {\n    BTNode<T> root, current;\n\n    public BT() {\n        root = current = null;\n    }\n\n    public void max(){\n       BTNode<Employee> tmproot = (BTNode<Employee>)root;\n       BTNode<Employee> tmp=null;\n       double x[] = new double[33];\n       Employee p[] = new Employee[33];\n\n       for(int i=14;i>=0;i--) {\n           tmp = search(i+1, tmproot);\n           x[i] = Math.max(x[i+1], (tmp.data.Evaluation_Score + x[i+2+2]));\n       }\n\n       for(int j=14;j>=0;j--) {\n           tmp = search(j+1, tmproot);\n       if(x[j+1]<x[j])\n           p[j] = tmp.data;\n       }\n\n       for(Employee e: p)\n       System.out.println(e);\n    }\n\n    public BTNode<Employee> search(int id, BTNode<Employee> node){\n        if(node != null){\n            if(node.data.ID ==id){\n               return node;\n            } else {\n                BTNode<Employee> foundNode = search(id, node.left);\n                if(foundNode == null) {\n                    foundNode = search(id, node.right);\n                }\n                return foundNode;\n             }\n        } else {\n            return null;\n        }\n    }\n}\n```\n\n\n\n\n```\nclass BTNode <T> {\n    public T data;\n    public BTNode<T> left, right;\n\n    /** Creates a new instance of BTNode */\n    public BTNode(T val) {\n        data = val;\n        left = right = null;\n    }\n\n    public BTNode(T val, BTNode<T> l, BTNode<T> r){\n        data = val;\n        left = l;\n        right = r;\n    }\n}\n```\n\n\n\n\n```\nclass Employee {\n    int ID_of_parent;\n    String Name;\n    int ID;\n    double Evaluation_Score;\n\n    public Employee(int ID_of_parent , String Name , int ID , double Evaluation_Score) {\n        this.ID_of_parent = ID_of_parent;\n        this.Name = Name;\n        this.ID = ID;\n        this.Evaluation_Score = Evaluation_Score;\n    }\n\n    public String toString() {\n        return ID_of_parent + \":\" + Name + \":\" + ID + \":\" + Evaluation_Score + \"\\n\";\n    }\n}\n```\n\n\nBut for some reason it's not printing the required output exactly. \n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "How much different is dynamic programming from recursion\r\n                \r\nMostly I have heard that if you can make a recursion code , you can convert it to a Dynamic programming code, but what is the need to do the same ? And how to convert a recursion code to DP ?\n    ", "Answer": "\r\nIn dynamic programming there are 2 approaches, top-down and bottom-up.\nlets take Fibonacci sequence as an example:\nf(0) = 0 : x = 1,\nf(1) = 1 : x = 1,\nf(x) = f(x-1) + f(x-2) : x > 1\nThe top-down approach:\nIt uses recursion + memoization(storing the calculated states to avoid the recalculation):\n```\nint memo[1000];//initialized by zeroes\n\nint f(int x) {\n    if (x == 0 || x == 1) return 1;\n    if (memo[x] != 0) return memo[x]; //trying to avoid recalculation\n    memo[x] = f(x - 1) + f(x - 2); //storing the result\n    return memo[x];\n}\n```\n\nAs you notice here to calculate the value f(x) we have to break it down into\nf(x-1) and f(x-2), this why it is called top-down.\nThe bottom-up approach:\nIt uses loops(for,while...) rather than recursion and stores the values inside an array:\n```\nint memo[1000];\n\nint bottom_up(int x) {\n    memo[0] = 1;\n    memo[1] = 1;\n    for (int i = 2; i < 1000; i++)\n        memo[i] = memo[i - 1] + memo[i - 2];\n}\n```\n\nAs you notice we calculate the values of Fibonacci sequence starting from the smaller values up to the bigger ones and this is why it is called bottom-up.\nConverting the code from recursion to loops is considered converting the recursive code to an iterative code.\nThe recursive code will call itself multiple times and you should know that each function call will be stored inside the stack of your memory, so it is preferred to use the iterative approach as it will be better for memory and performance.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "int[] vs ArrayList<>() in memoization, dynamic programming in Java\r\n                \r\nI recently watched a dynamic programming tutorial on Youtube explaining dynamic programming but the Tutor solved problems in JavaScript. I, on the other hand, use Java for data structures and algorithms. While implementing dynamic programming to solve a question. I discovered that I got the solution to the problem when using ```\nint[]```\n but had wrong answer when using ```\nArrayList<Integer>```\n because somehow, the ArrayList already stored in the HashMap was being modified internally.\n\nQuestion:\nWrite a function bestSum(targetSum, numbers) that takes in a targetSum and an array of numbers as arguments and returns an array containing the shortest combination of numbers that add up to exactly the target sum.\nExample:\nbestSum(7,new int[]{2,1,3}) => [3,3,1] //other possibilities but not answer:[2,2,2,1], [1,1,1,1,1,1,1], [2,2,1,1,1], etc\nbestSum(100,new int[]{2,5,25}) => [25,25,25,25]\n\nCode using int[]:\n```\npublic class Persist {\n    public static HashMap<Integer,int[]> memo = new HashMap<>();\n    public static int[] bestSum(int n, int[] arr){\n        if(memo.containsKey(n)){\n            //System.out.printf(\"From memo: %d->\"+ Arrays.toString(memo.get(n)) +\"%n\",n);\n            return memo.get(n);\n        }\n\n        if(n==0)return new int[0];\n\n        if(n<0)return null;\n\n        int[] minn = null;\n\n        for(int i = 0;i<arr.length;i++){\n            \n            //recursion\n            var temp = bestSum(n-arr[i],arr);\n\n            if(temp!=null){\n\n                // ttemp is used to add arr[i] to the initial arr <<temp>>\n                int[] ttemp = new int[temp.length+1];\n                System.arraycopy(temp,0,ttemp,0,temp.length);\n                ttemp[temp.length] = arr[i];\n                temp = ttemp;\n\n                if(minn==null||temp.length<minn.length){\n                    minn = temp;\n                }\n            }\n        }\n        //System.out.println(n+\": \"+minn);\n        memo.put(n,minn);\n        //System.out.println(memo.get(n));\n        return minn;\n    }\n    public static void main(String[] args){\n        System.out.println(Arrays.toString(bestSum(7, new int[]{2,1,3})));\n    }\n}\n```\n\nCode using ArrayList<Integer> :\n```\npublic class Persist {\n    public static HashMap<Integer,ArrayList<Integer>> memo = new HashMap<>();\n    public static ArrayList<Integer> bestSum(int n, int[] arr){\n        if(memo.containsKey(n)){\n            //System.out.printf(\"From memo: %d->\"+ memo.get(n)+\"%n\",n);\n            return memo.get(n);\n        }\n        if(n==0)return new ArrayList<>();\n        if(n<0)return null;\n        ArrayList<Integer> minn = null;\n        for(int i = 0;i<arr.length;i++){\n            var temp = bestSum(n-arr[i],arr);\n            if(temp!=null){\n                temp.add(arr[i]);\n                if(minn==null||temp.size()<minn.size()){\n                    minn = temp;\n\n                }\n            }\n        }\n        //System.out.println(n+\": \"+minn);\n        memo.put(n,minn);\n        //System.out.println(memo.get(n));\n        return minn;\n    }\n    public static void main(String[] args){\n        System.out.println(bestSum(7,new int[]{2,1,3}));\n    }\n}\n\n```\n\nThe only differences between the two code snippets is the use of ```\nint[]```\n and ```\nArrayList<Integer>```\n respectively, but one works and the other doesn't. I will like to know why, thanks.\nLink to Youtube explanation of bestSum()\n    ", "Answer": "\r\nIt's easy to get caught up with memoization and dynamic programming and forget that about pass by reference and pass by value. The key difference here to remember is that ```\nArrayList```\n is pass by reference.\nIf you debug and look at your ```\nhashmap```\n ```\nmemo```\n, you see that the sizes of the ```\nint[]```\n only reaches up to ```\n3```\n, whereas in the arraylist hashmap most of the values has a size of ```\n7```\n\nI had a similar problem: casting does not work on nested list object type and returns empty lists (List<List<Integer>>)\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Coin Change Dynamic Programming\r\n                \r\nQUESTION:\nI'm having trouble finding the minimum amount of coins needed to reach a specific sum. I'm pretty sure this is done easiest recursively and using the dynamic programming methodology, I should basically get Math.min(\"takeACoin\",\"leaveACoin\");\nUnfortunately, My code doesn't terminate though I do have if statements that terminate under the condition that the sum is met, the array of coins is depleted, or if the sum is over. Please look at my code below and let me know what I'm doing wrong and especially why my code continues executing until it receives a stackoverflow error though I have the appropriate terminating conditions.\n\nCODE:  \n\n```\n    private static final int S = 3;\npublic static int arr[] = {1,2};\npublic static void main(String[] args) {\n    Interview i = new Interview();\n    i.sumCoins(arr, 0);\n}\npublic int sumCoins(int[] ar, int sum) {\n    //if the sum is met, dont add any coins, just return 0\n    if(sum == S){\n        return 0;\n    }\n    //if the sum is greater, then return max value as it is impossible to get less sum\n    if(sum > S){\n        return Integer.MAX_VALUE;\n    }\n    //if the array is out of coins return max value\n    if(ar.length == 0){\n        return Integer.MAX_VALUE;\n    }\n    //if the sum is less than S and there is still more coins to use, keep checking\n    //add the first coin\n    int tmpSum = sum + ar[0];\n    //delete the first coin from the list\n    int[] tmp = Arrays.copyOfRange(ar, 1, ar.length);\n    //add one coin to the solution\n    int one = 1+sumCoins(tmp, tmpSum);\n    //don't add one coin to the solution\n    int two = sumCoins(ar,sum);\n\n    //see which is more minimized\n    return Math.min(one,two);\n}\n```\n\n\nRequested Stack Trace:\n\nException in thread \"main\" java.lang.StackOverflowError \nat java.lang.Math.min(Math.java:879)    \nat java.util.Arrays.copyOfRange(Arrays.java:2623)   \nat Interview.sumCoins(Interview.java:28)    \nat Interview.sumCoins(Interview.java:32)    \nat Interview.sumCoins(Interview.java:32)\n    ", "Answer": "\r\nThe answer to this question is in regards to how I was implementing my dynamic programming. I was using the original array in the case where you left the coin. this is incorrect. In more detail:\nIf you take the coin: get rid of the first (coin) index of the array, add the sum, add +1 for the number of coins. \nIf you don't take the coin: get rid of the first (coin) index of the array since you're leaving that coin to not be considered. \n\nIn my solution, I received a stackoverflow because I was going through the \"leaving the coin\" scenario infinite times as the array never decreased and I wasn't actually \"leaving the coin\". \nCorrect Code here: \n\n```\nprivate static final int S = 5;\npublic static int arr[] = {1,1,1,1,1};\npublic static void main(String[] args) {\n    Interview i = new Interview();\n    System.out.println(i.sumCoins(arr, 0));\n}\npublic int sumCoins(int[] ar, int sum) {\n    //if the sum is met, dont add any coins, just return 0\n    if(sum == S){\n        return 0;\n    }\n    //if the sum is greater, then return global array (not local)\n    //length +1 as it's impossible to get more coins than indices\n    if(sum > S){\n        return arr.length+1;\n    }\n    //if the array is out of coins return max value\n    if(ar.length == 0){\n        return arr.length+1;\n    }\n    //if the sum is less than S and there is still more coins to use, keep checking\n    //add the first coin\n    int tmpSum = sum + ar[0];\n    //delete the first coin from the list\n    int[] tmp = Arrays.copyOfRange(ar, 1, ar.length);\n    //add one coin to the solution\n    int one = 1+sumCoins(tmp, tmpSum);\n    //don't add one coin to the solution\n    int two = sumCoins(tmp,sum);\n\n    //see which is more minimized\n    return Math.min(one,two);\n\n}\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming: box stacking variation\r\n                \r\nWe have n boxes whose dimensions are x, y, z (width, height, depth).\nWe want to insert the largest number of boxes one inside the other.\n\nYou can put a box inside the other if the size of the inner box (i) are strictly less than the size of the outer box (j): x[i] < x[j], y[i] < y[j], z[i] < z[j].\n\nThe boxes CAN'T be rotated and can be considered in any order.\n\nHow can I achieve the goal with the dynamic programming?\nThe issue is similar to the longest increasing subsequence problem?\nIt can make sense to order boxes in ascending / descending order?\n    ", "Answer": "\r\nPerform a topological sort on the boxes, arranging them into a graph as follows:  Each box is a node in a graph, each directed arc from node A to node B indicates that the corresponding Box A holds Box B.  Augment this structure with a box of infinite size and a box a zero size.\n\nAs a topological sort, this graph will be a directed acyclic graph.  As such, finding the longest path is not NP-hard, but rather can be solved in O(V+E).  The longest path between your two augmenting boxes contains the answer to the problem.\n\nSetting up the sort is O(V^2), and finding the solution from the sorted graph is O(V+E) which in this context is O(V^2) which is your overall solution time. \n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming for the number of ways of climbing steps\r\n                \r\nThe question is to write a function using dynamic programming for the number of ways to climb N steps. Given that only 1 step or 2 steps can be climbed at a time. \n\nFor example, if N=3, the function should return [(1,1,1),(1,2),(2,1)]. \nI've written a code in python 3 to calculate. The code is working fine but as N gets as large as 40 it takes the same time or the spyder(Anaconda) application crashes when compared to the same recursive code without using dynamic programming.\n\nShouldn't it be way more efficient than the normal one?\n\nI've attached the DP code below\n\n```\ndef stepsdyn(N,memo={}):\n    \"\"\"\n    L1 is the list of all possibilities in the left side of the search tree,\n    that is with 1 as the last element\n    L2 is the list of all possibilities in the right side of the search tree\n    memo stores the results of corresponding N\n    returns memo[N]\n    \"\"\"\n    L1=[]\n    L2=[]\n    if N==1:\n        return [(1,)]\n    elif N==0:\n        return [()]\n    else:\n        try:\n             return memo[N]\n        except:\n             for items in stepsdyn(N-1,memo):\n                 items+=(1,)\n                 L1.append(items)\n             for items in stepsdyn(N-2,memo):\n                 items+=(2,)\n                 L2.append(items)\n             memo[N]=L1+L2\n             return memo[N] \n```\n\n    ", "Answer": "\r\nBasic idea\n\nIn computer programming the most basic and common tradeoff is the one between time efficiency and space efficiency. Memoization can be good for time but bad for space and that is the case here. Your program is crashing because that memoization dictionary is holding a lot of data. Right off the bat your recurrence relation means you never need the data that is being held in the ```\nN - 3```\n spot so you can get rid of it. This somewhat alleviates the memory burden (but not by much).\n\nProblems/concerns with code\n\n\nDon't memoize values you don't need (see above).\nPython's handling of mutable default argument means the ```\nmemo```\n dict is only created once. See this SO post for more details. This also means that the dictionary is sitting around (in memory) after the function returns... not good. Generally don't use mutable default arguments unless you have a compelling reason.\n```\nlist```\n comprehensions can be a bit faster than explicit for loops. More importantly in this case, they are more readable.\nThis last one is more a style thing. You are adding the ```\n1```\n or the ```\n2```\n to the tail of the items returned from the recursive call. Typically those elements are added at the head.\n\n\nSolutions\n\nSame algorithm but more memory and time efficient\n\n```\ndef stepsdyn_new(N, memo):\n    try:\n        return memo[N]\n    except KeyError:\n        l1 = [(1,) + items for items in stepsdyn_new(N - 1, memo)]\n        l2 = [(2,) + items for items in stepsdyn_new(N - 2, memo)]\n        memo.pop(N - 2)\n        memo[N] = l1 + l2\n        return memo[N]\n```\n\n\nNote: I pass the base cases in as an argument, but you can add the original ```\nif```\n/```\nelse```\n if desired.\n\nReturning strings\n\n```\ndef stepsdyn_str(N, memo):\n    try:\n        return memo[N]\n    except KeyError:\n        l1 = ['1' + x for x in stepsdyn_str(N - 1, memo)]\n        l2 = ['2' + x for x in stepsdyn_str(N - 2, memo)]\n        memo.pop(N - 2)\n        memo[N] = l1 + l2\n        return memo[N]\n```\n\n\nThis will return a list of string (e.g. ['111', '12', '21']) instead of a list of tuples. Because each character in a python string only uses 1 byte (instead of the 8 bytes per element in a list/tuple) this yields a lot of memory savings. The result can be converted back to a list of tuples with the following code (though this would incur additional speed/memory penalties):\n\n```\n[tuple(map(int, tuple(x))) for x in stepsdyn_str(N, {0: [''], 1: ['1']})]\n```\n\n\nEfficiency\n\nNote: the ```\nsteps```\n function is a non-memoized solution (included below for completeness).\n\nSpeed\n\n```\n|--------------|----------------------------|----------------------------|\n|              |           N = 20           |           N = 33           |\n|--------------|----------------------------|----------------------------|\n| steps        | 47 ms ± 7.34 ms per loop   | 41.2 s ± 1.6 s per loop    |\n|--------------|----------------------------|----------------------------|\n| stepsdyn     | 10.1 ms ± 1.23 ms per loop | 9.46 s ± 691 ms per loop   |\n|--------------|----------------------------|----------------------------|\n| stepsdyn_new | 6.74 ms ± 1.03 ms per loop | 7.41 s ± 396 ms per loop   |\n|--------------|----------------------------|----------------------------|\n| stepsdyn_str | 3.28 ms ± 68.8 µs per loop | 3.67 s ± 121 ms per loop   |\n|--------------|----------------------------|----------------------------|\n```\n\n\nObtained using:\n\n```\n%timeit steps(N)\n%timeit stepsdyn(N, memo={})\n%timeit stepsdyn_new(N, {0: [()], 1: [(1,)]})\n%timeit stepsdyn_str(N, {0: [''], 1: ['1']})\n```\n\n\nMemory\n\nThese estimates are specific to my 16GB memory MBP while evaluating the functions for ```\nN=33```\n:\n\n\n```\nsteps```\n: 10.8% max memory\n```\nstepsdyn```\n: 22.0% max memory\n```\nstepsdyn_new```\n: 15.7% max memory\n```\nstepsdyn_str```\n: 3.6% max memory\n\n\nNon-memoized solution\n\n```\ndef steps(N):\n    if N == 0:\n        return [()]\n    elif N == 1:\n        return [(1,)]\n    else:\n        l1 = [(1,) + items for items in steps(N - 1)]\n        l2 = [(2,) + items for items in steps(N - 2)]\n        return l1 + l2\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming Optimal Solution\r\n                \r\nA company is planning a party for its employees. A fun rating is assigned to every employee.\nThe employees are organized into a strict hierarchy, i.e. a tree rooted the president. There is one\nrestriction, though, on the guest list to the party: an employee and his/her immediate supervisor\n(parent in the tree) cannot both attend the party. You wish to prepare a guest list for the party that\nmaximizes the sum of fun ratings of the guests. Show that greedily choosing guests according to fun\nrating, will not work. Then, formulate a dynamic programming solution\n\nI could not understand some of the conditions like is the fun rate of the president higher than that of his descendants and how many employees are there for each of his supervisor. Can someone help me in proceeding with this ?\n    ", "Answer": "\r\nFrom the phrasing on the problem, the fun rating assigned to someone in the hierarchy tree is not necessarily greater than their descendants in the hierarchy tree.\n\nHowever, even if this were the case, to see that it is not optimal to pick the best employee, consider a tree of height 2 with a root of fun=10 and 20 children of fun=1. Then the optimal solution is to skip the greedy choice (the root) and choose the 20 children.\n\nIn any case, with dynamic programming you can find the best solution even if parents can have lower fun than their descendants. For a node v in the tree, let F(v) be the maximum fun that can be attained within subtree rooted at v. Then either you choose v in which case the children are skipped and you look at all subtrees that are rooted at children of children (taking the sum  of max fun over these subtrees, and adding to fun(v)), or you skip v and then you get the maximum fun is the sum of maximum fun over all subtrees rooted at children of v. This gives a linear time dynamic programming algorithm.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "When to switch from Dynamic Programming (2D table) to Branch & Bound algorithm?\r\n                \r\nI'm doing a knapsack optimization problem involving dynamic programming and branch & bound. I noticed that when the capacity and the item of the problem gets large, filling up the 2D table for the dynamic programming algorithm will get exponentially slower. At some point I am going to assume that I am suppose to switch algorithm depending on the size of the problem (since lecture have give two types of optimization)?\n\nI've tried to google at what point (what size) should I switch from dynamic programming to branch & bound, but I couldn't get the result that I wanted.\n\nOr, is there another way of looking at the knapsack problem in which I can combine dynamic programming and branch & bound as one algorithm instead of switching algorithm depending of the size of the problem?\n\nThanks.\n    ", "Answer": "\r\nOften when you have several algorithms that solve a problem but whose runtimes have different characteristics, you determine (empirically, not theoretically) when one algorithm becomes faster than the other.  This is highly implementation- and machine-dependent.  So measure both the DP algorithm and the B&B algorithm and figure out which one is better when.\n\nA couple of hints:\n\n\nYou know that DP's runtime is proportional to the number of objects times the size of the knapsack.\nYou know that B&B's runtime can be as bad as 2# objects, but it's typically much better.  Try to figure out the worst case.\nCaches and stuff are going to matter for DP, so you'll want to estimate its runtime piecewise.  Figure out where the breakpoints are.\nDP takes up exorbitant amounts of memory.  If it's going to take up too much, you don't really have a choice between DP and B&B.\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "How to draw dynamic programming table in python\r\n                \r\nWhat is a good way to draw a dynamic programming such as this one (with the path) in python?\n\n\nI have looked online and I see pygame but is that really the best option for this sort of technical drawing?\n\nOne option might be to use matplotlib using something like\n\n```\nimport matplotlib.pylab as plt\nplt.figure()\ncol_labels=['col1','col2','col3']\nrow_labels=['row1','row2','row3']\ntable_vals=[[11,12,13],[21,22,23],[31,32,33]]\n\nthe_table = plt.table(cellText=table_vals,\n                  colWidths = [0.1]*3,\n                  rowLabels=row_labels,\n                  colLabels=col_labels,\n                  loc='center right')\nplt.text(12,3.4,'Table Title',size=8)\n\nplt.show()\n```\n\n\nHow can I draw the line on the table?\n    ", "Answer": "\r\nThe following code yields an approximation of the figure you want, using native Matplotlib tables:\n\n```\nimport matplotlib.pylab as plt\nimport numpy as np\n\ndef get_coord(table, irow, icol):\n    # get coordinates of a cell. This seems to work, don't ask why.\n    cell = table.get_celld()[irow+1,icol] # row 0 is column headers\n    box = cell.get_bbox().get_points() # [[x0, y0],[x1, y1]]\n    xc, yc = box.mean(axis=0) # get center\n    return xc, yc\n\ncol_labels=['G','A','T','C','C']\nrow_labels= ['G','T','G','C','C']\ntable_vals= [\n    ['x','','','',''],\n    ['','','x','',''],\n    ['x','','','',''],\n    ['','','','x','x'],\n    ['','','','x','x']]\nline = [(0,0), (0,1), (1,2), (2,2), (3,3), (4,4)]    \n\n# draw table\nthe_table = plt.table(cellText=table_vals,\n    colWidths = [0.1]*len(col_labels),\n    rowLabels=row_labels, colLabels=col_labels,\n    cellLoc = 'center', rowLoc = 'center', bbox=[.1,.1,.8,.8])\nplt.draw() # lay out table, so that cell coordinates are calculated\n\n# look up line coordinates\nx = []; y = []\nfor irow, icol in line:\n    xc, yc = get_coord(the_table, irow, icol)\n    x.append(xc)\n    y.append(yc)\n\n# draw line    \nplt.plot(x, y, 'r', linewidth = 5, alpha=0.5)\nplt.xlim([0,1])\nplt.ylim([0,1])\nplt.show()\n```\n\n\nResult:\n\n\n\nNote that the result is not extremely beautiful, I could for example not figure out how to change the width of the column with row-labels. There is also the issue that the table is drawn in 'figure coordinates', while the line is drawn in 'data-coordinates', so if you zoom in the line and the table no longer overlap. I struggled for quite some time with these tables, but in my opinion they are quite a PITA to work with and the resulting code is hard to understand. \n\nMy preferred solution is to just draw the table by hand:\n\n```\nimport matplotlib.pylab as plt\nimport numpy as np\n\ncol_labels=['G','A','T','C','C']\nrow_labels= ['G','T','G','C','C']\ntable_vals= [\n    ['X','','','',''],\n    ['','','X','',''],\n    ['X','','','',''],\n    ['','','','X','X'],\n    ['','','','X','X']]\nline = np.array([\n    [0, 1, 2, 2, 3, 4],\n    [0, 0, 1, 2, 3, 4]])    \nncol = len(col_labels)\nnrow = len(row_labels)\n\n# draw grid lines\nplt.plot(np.tile([0, ncol+1], (nrow+2,1)).T, np.tile(np.arange(nrow+2), (2,1)),\n    'k', linewidth=3)\nplt.plot(np.tile(np.arange(ncol+2), (2,1)), np.tile([0, nrow+1], (ncol+2,1)).T,\n    'k', linewidth=3)\n\n# plot labels\nfor icol, col in enumerate(col_labels):\n    plt.text(icol + 1.5, nrow + 0.5, col, ha='center', va='center')\nfor irow, row in enumerate(row_labels):\n    plt.text(0.5, nrow - irow - 0.5, row, ha='center', va='center')\n\n# plot table content\nfor irow, row in enumerate(table_vals):\n    for icol, cell in enumerate(row):\n        plt.text(icol + 1.5, nrow - irow - 0.5, cell, ha='center', va='center')\n\n# plot line\nplt.plot(line[0] + 1.5, nrow - line[1] - 0.5, 'r', linewidth = 5, alpha = 0.5)\n\nplt.axis([-0.5, ncol + 1.5, -0.5, nrow+1.5])\nplt.show()\n```\n\n\nwith result:\n\n\n\nThis looks much nicer, and the code is straightforward to understand. You might want to adjust some line-widths and font-sizes to your own taste, and hide the axis.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming Algorithm (MinCost buying Apples)\r\n                \r\nHello I am trying to build a dynamic programming solution for the following problem :\n\nGiven that a family consumes 2kg of apples per day, the apples last 10 days  and the price of the kg of apples per day on day i is p[i] , I have to find the minimum cost so the family does not run out of apples .\n\nWithout the 10 days limit i have come up with the solution , that i make a new array :\n\n```\nlocmin=p[1]\nfor i=2 to n \nif locmin>=p[i] then c[i]=p[i]\nelse locmin=p[i] c[i]=p[i]\nand then \nOPT[1]=c[i]\nOPT(i)=OPT[i-1]+2*c[i] (well not so much of dynamic programming but it is O(n)) .\n```\n\n\nWhen putting 10 days limitation into account i come up with with a c[i,10] matrix where i store the lowest values of previous 10 days window the same manner as before  for every i-10,i and come up with the solution \n\n```\nOPT(i)=OPT[i-1]+2*min(p[i,j]) 0<j<=10 \n```\n\n\n.\nO(n^2) solution \nAny ideas ?\n    ", "Answer": "\r\nWe can do ```\nO(n)```\n not just for 10 days but for an arbitrary sized window. Let's take one day at a time. Each day, the family eats 2kg of apples. What's the price of only these two ```\nkg```\n? Clearly, it's ```\n2 * best_price```\n, where ```\nbest_price = min(p[i-9...i])```\n.\n\nLet's keep a stack. If a price is higher we add to the stack, if it's lower, we pop the stack till a lower earlier price or the stack is empty, then add the new price. The first element in the stack will be the best choice, and it will get replaced by the next element in the stack when it expires.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Finding longest sequence according to requirements (Dynamic Programming)\r\n                \r\n''How to determine the longest increasing subsequence using dynamic programming?'' didn't help me enough that I could do it on my own so I am asking for your help. \n\nI have a sequence of integers: ```\n(-2, 4, 1, 1, 5, -2, 3, 3, -1, 1)```\n. I want to find longest sequence of them according to these requirements using dynamic programming (```\nX```\n here is a number, ```\ni```\n its index):\n\n\nThe numbers have to go in order, their indexes would keep increasing\nIf the index is an odd number, this requirement has to be met: ```\nXi <= Xi+1```\n, if the index is an even number, this requirement has to be met: ```\nXi >= Xi+1```\n.\n\n\nFor example longest sequence would be: ```\n(-2, 4, 1, 5, -2, 3, -1, 1)```\n. Any help is greatly appreciated, I have been on this for the whole day..!\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Can every recursive algorithm be improved with dynamic programming?\r\n                \r\nI am a first year undergraduate CSc student who is looking to get into competitive programming. \n\nRecursion involves defining and solving sub problems. As I understand, top down dynamic programming (dp) involves memoizing the solutions to sub problems to reduce the time complexity of the algorithm.  \n\nCan top down dp be used to improve the efficiency of every recursive algorithm with overlapping sub problems? Where would dp fail to work and how can I identify this? \n    ", "Answer": "\r\nThe short answer is: Yes.\n\nHowever, there are some constraints. The most obvious one is that recursive calls must overlap. I.e. during the execution of an algorithm, the recursive function must be called multiple times with the same parameters. This lets you truncate the recursion tree by memoization. So you can always use memoization to reduce the number of calls.\n\nHowever, this reduction of calls comes with a price. You need to store the results somewhere. The next obvious constraint is that you need to have enough memory. This comes with a not-so obvious constraint. Memory access always requires some time. You first need to find where the result is stored and then maybe even copy it to some location. So in some cases, it might be faster to let the recursion calculate the result instead of loading it from somewhere. But this is very implementation-specific and can even depend on the operating system and hardware setup.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Algorithms - Dynamic programming - Subset sum of two arrays\r\n                \r\nMy homework include a dynamic programming question:\n\n\n  Given two arrays of natural integers (a1,a2,...,an and b1,b2,...,bn)\n  such all of them are smaller than n^2, and also given is a number B\n  which is smaller than n^3.\n  \n  You need to determent if there is an array (c1,c2,...,cn) such:\n  \n  \n  \n  And for each 1 <= i <= n, ci = ai or ci = bi.\n  \n  *This algorithm must be written with dynamic programming.\n  \n  *Also, what would we need to change to acctually get the array c that gives us Sum(c) = B\n\n\nAnother way of looking at the question is by saying that c is equal to a subset of a, and its complement subset from b.\n\nThis is a recursive pseudo code I wrote to solve this question:\n\n```\nW(a,b,i, N)\n    if i==-1\n        if N==0     return true;\n        else        return false;\n    return W(a,b,i-1,N-a[i]) || W(a,b,i-1,N-b[i]);\n\nT(n) = 2^n\n```\n\n\nAnd here, to return the best path, just store this in a tree, and go over from the (good) end to the start\n\nHow can I write this with dynamic programming? Will this even help the run time? because the recursive solution has independent results.\n\n*I searched google for this problem and found nothing but \"the subset sum problem\" which is different.\n    ", "Answer": "\r\nThanks to @PhamTrung I have a solution:\n\nLet there be a matrix [B,n] (max size [n^3,n])\n\nExample: (n=3, B=8) \n\n```\n    0   1       2       3       4       ... 8\n0   T   F       F       F       F       ... F\n1   F   (1,1)   (1,2)   (1,3)   (1,4)   ... (1,8)\n2   F   F       (2,2)   (2,3)   (2,4)   ... (2,8)\n3   F   F       F       (3,3)   (3,4)   ... (3,8)\n```\n\n\nPseudo Code:\n\n```\n//Generate the matrix\nA = new Array(n+1,B+1)\nfor(i: 0 to n) //run over lines\n    for(j: 0 to B) //run over B columns\n        if i==0 //if we are in the first row\n            A[i,j] = j==0; //if this is [0,0], it is true. else, false\n        else if i>j //if we have more numbers than the sum\n            A[i,j] = false; //it cannot happen\n        else\n            //general case:\n            //if we remove a[i] or b[i], will we get to a true statement?\n            A[i,j] = (j-a[i] >= 0 && A[i-1, j-a[i]]) || (j-b[i] >= 0 && A[i-1, j-b[i]]);\n\nis_set(n,B,A)\n    if(A[n,B])\n        return true;\n    return false;\n```\n\n\nFormulas:\n\n```\n[0,j],j!=0 = F\n[0,0]   = T\ni > j   = F\ni <= j  = (i-1, j - a[i]) || (i-1, j - b[i])\n```\n\n\nGetting the route:\n\nTo get the route constructing C, we will also save in each true point 0(=a) or 1(=b), and just go over from the bottom to the top.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming- Longest common substring explanation\r\n                \r\nI am a newbie trying to wrap my head around Dynamic programming and this seems like an enigma to me. I was looking at the Longest common substring problem's solution using DP. Its code below:-\n\n```\nint dp[N+1][N+1];\n\nfor (int i = 0; i <= N; ++i)\n\n  dp[0][i] = dp[i][0] = 0;\n\nfor (int i = 1; i <= N; ++i)\n\n  for (int j = 1; j <= N; ++j) {\n\n    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n\n    if (A[i-1] == B[j-1])\n\n      dp[i][j] = max(dp[i][j], dp[i-1][j-1]+1);\n\n  }\n\n\nint answer = dp[N][N];\n```\n\n\nIts solution looks pretty simple but I am having a difficult time understanding the solution. Can someone please explain what is happening in the code and how does this solve the LCS problem?\n    ", "Answer": "\r\nI'd recommend to understand the general idea of the solution. \nHere are a few references, from the simplest explanations to the more deep ones:\n\n\nWiki - https://en.wikipedia.org/wiki/Longest_common_substring_problem\nYouTube - https://www.youtube.com/watch?v=aSwu8Z9nzOg\n\n\nand for the academic references regarding this solution you are presenting above:\n\n\nMIT - http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/video-lectures/lecture-15-dynamic-programming-longest-common-subsequence/lec15.pdf\nCorenell - http://www.cs.cornell.edu/~wdtseng/icpc/notes/dp2.pdf\nCMU - http://www.cs.cmu.edu/afs/cs/academic/class/15451-f10/www/lectures/lect0928.pdf\n\n\nThen, after understanding their solution and their way of solving this problem, you'll see that you may implement it by yourself or fully understand the logic in your algorithm\n\ngood luck!\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Time Complexity of Text Justification with Dynamic Programming\r\n                \r\nI've been working on a dynamic programming problem involving the justification of text. I believe that I have found a working solution, but I am confused regarding this algorithm's runtime. \n\nThe research I have done thus far has described dynamic programming solutions to this problem as O(N^2) with N as the length of the text which is being justified. To me, this feels incorrect: I can see that O(N) calls must be made because there are N suffixes to check, however, for any given prefix we will never consider placing the newline (or 'split_point') beyond the maximum line length L. Therefore, for any given piece of text, there are at most L positions to place the split point (this assumes the worst case: that each word is exactly one character long). Because of this realization, isn't this algorithm more accurately described as O(LN)?\n\n```\n@memoize\ndef justify(text, line_length):\n\n    # If the text is less than the line length, do not split\n    if len(' '.join(text)) < line_length:\n        return [], math.pow(line_length - len(' '.join(text)), 3)\n\n    best_cost, best_splits = sys.maxsize, []\n\n    # Iterate over text and consider putting split between each word\n    for split_point in range(1, len(text)):\n        length = len(' '.join(text[:split_point]))\n\n        # This split exceeded maximum line length: all future split points unacceptable\n        if length > line_length:\n            break\n\n        # Recursively compute the best split points of text after this point\n        future_splits, future_cost = justify(text[split_point:], line_length)\n        cost = math.pow(line_length - length, 3) + future_cost\n\n        if cost < best_cost:\n            best_cost = cost\n            best_splits = [split_point] + [split_point + n for n in future_splits]\n\n    return best_splits, best_cost\n```\n\n\nThanks in advance for your help,\nEthan\n    ", "Answer": "\r\nFirst of all your implementation is going to be far, far from the theoretical efficiency that you want.  You are memoizing a string of length ```\nN```\n in your call,  which means that looking for a cached copy of your data is potentially ```\nO(N)```\n.  Now start making multiple cached calls and you've blown your complexity budget.\n\nThis is fixable by moving the text outside of the function call and just passing around the index of the starting position and the length ```\nL```\n.  You are also doing a join inside of your loop that is a ```\nO(L)```\n operation.  With some care you can make that a ```\nO(1)```\n operation instead.\n\nWith that done, you would be doing ```\nO(N*L)```\n operations.  For exactly the reasons you thought.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Java Programming : Dynamic Programming on stairs example\r\n                \r\nA man is running up a staircase with n steps, and can go either 1 steps, 2 steps, or 3 steps at a time. Now write a program to count how many possible ways the child can run the stairs.\n\nThe code given is like below\n\n```\npublic static int countDP(int n, int[] map) {\n if (n<0)\n   return 0;\n else if (n==0)\n   return 1;\n else if (map[n]>-1)\n   return map[n];\n else {\n    map[n] = countDP(n-1, map) + countDP(n-2, map) + countDP(n-3, map);\n    return map[n]; }\n }\n```\n\n\nI know C and C++, not JAVA.\nThis is from the Cracking the Coding interview book.\nCould anybody can explain \n\n\nwhy and how she employs the function map here? map here is array right?\nI do not see any line to save an input to the map array but how would it return something? \nAnybody has an idea of C++ or C version of this code? It is hard to understand this code. Maybe not because of the JAVA grammar, but the implicit structure of dynamic programming.\nWhat would be the time complexity of this algorithm? It should be smaller than O(3^n) ?\n\n\nI would greatly appreciate it.\n\nThanks, guys\n    ", "Answer": "\r\nOkay, here is what the code does.\n\n```\n `if (n<0)`\n    `return 0;`\n```\n\n\nIf there aren't enough steps remaining, then don't count it. For instance, if there are two steps remaining, but the user is trying to take three steps, then it does not count as a possible combination.\n\n```\nelse if (n==0)```\n\n   ```\nreturn 1;```\n\n\nIf the number of steps remaining matches the number of available steps the user is trying to take, it is a possible combination. So, return a 1 because this is a possible combination and should be added to the total number of valid combinations.\n\n```\nelse if (map[n]>-1)```\n\n   ```\nreturn map[n];```\n\n\nHere is the dynamic programming part. Assume that the all the values in the array had a value of -1. So, if the number is greater than -1, it has already been solved for, so return the total number of combinations from step number n instead of resolving it.\n\n```\n`map[n] = countDP(n-1, map) + countDP(n-2, map) + countDP(n-3, map);`\n```\n\n\n```\nreturn map[n]; }```\n\n\nFinally, this part solves the code. The number of possible combinations is equal to the number of possible combinations the user can get if he takes 1 step + the number of possible combinations the user can get if he takes 2 steps + the number of possible combinations the user can get if he takes three steps.\n\nAn example, suppose there are 5 steps\n\nA simple run would look like:\n\n```\n//The number of solutions from the fifth step\n\ncountDp(5) = countDp(4)+countDp(3)+countDp(2);\n\n//Number of solutions from the fourth step\n\ncountDP(4) = countDp(3)+countDp(2)+countDp(1);\n\n//Number of solutions from the third step\n\ncountDp(3) = countDp(2)+countDp(1)+countDp(0);\n//Number of solutions from the second step\ncountDp(2) = countDp(1)+countDp(0)+countDp(-1);\n//Number of solutions from the first step\ncountDp(1) = countDp(0) + countDp(-1)+countDp(-2);\n//Finally, base case\ncountDp(0) = 1;\n\ncountDp(-1)= 0;\ncountDp(-2)= 0;\ncountDp(1) = 1+0+0 = 1;\ncountDp(2) = 1+1+0 = 2;  //Dynamic programming: did not have to resolve for countDp(1), instead looked up the value in map[1]\ncountDp(3) = 2+1+1 = 4;  //Dynamic programming, did not have to solve for countDp(1), countDp(2), instead looked up value in map[1] and map[2]\ncountDp(4) = 4+2+1=7 //Dynamic programming, did not have to solve for CountDp(3),CountDp(2), CountDp(1), just looked them up in map[3],map[2],map[1]\ncountDp(5)=  2+4+7=13 //Dynamic programming, just used map[4]+map[3]+map[2]\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "LCS dynamic programming using one dimensional array\r\n                \r\nI am trying to do dynamic programming for finding length of LCS. I have used two dimensional array for that. But for a large string it gives runtime error due to memory overflow. Please tell me How should I do it in one dimensional array to avoid memory constrains.\n\n```\n#include<bits/stdc++.h>\n #include<string.h> \n using namespace std;\nint max(int a, int b);\nint lcs( string X, string Y, int m, int n )\n{\n   int L[m+1][n+1];\n   int i, j;\n   for (i=0; i<=m; i++)\n   {\n     for (j=0; j<=n; j++)\n     {\n       if (i == 0 || j == 0)\n         L[i][j] = 0;\n\n       else if (X[i-1] == Y[j-1])\n         L[i][j] = L[i-1][j-1] + 1;\n\n       else\n         L[i][j] = max(L[i-1][j], L[i][j-1]);\n     }\n   }\n\n   return L[m][n];\n}\n\nint max(int a, int b)\n{\n    return (a > b)? a : b;\n}\n\nint main()\n{\n  string X;\n  string Y;\n  cin>>X>>Y;\n  int m = X.size();\n  int n = Y.size();\n\n  printf(\"Length of LCS is %d\\n\", lcs( X, Y, m, n ) );\n\n  return 0;\n}\n```\n\n    ", "Answer": "\r\nNote that the recursion in ```\nlcs```\n only uses the last two rows of the ```\nL```\n matrix. Thus you can easily rewrite your solution to use O(N) memory.\n\nHere's a good article on the subject.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Application of dynamic programming in real world programming [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is opinion-based. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it can be answered with facts and citations by editing this post.\r\n                \r\n                    \r\n                        Closed 3 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI have found that dynamic programming is a bit skillful and demanding. But since I expect myself to become an adequate software engineer, I am wondering in which development scenario will DP massively be used or in other words are there any practical usage of it in development based on modern computers?\nIf you think about design patterns like Proxy pattern and dynamic proxy, which is broadly used in spring framework, DP seems like it is only useful in tech interview.\nAlso, application of parallelized computing and distributed system seems not easy to empower DP in modern computer context.\nAre there any not rare scenarios where DP is widely used in very practical ways?\nPlease forgive my ignorance, since I haven't meet DP in real production level development, which makes me doubt the meaning of digging  into DP.\n    ", "Answer": "\r\nI agree with @ Matt Timmermans.\nYou don't learn about DP in case you have to use DP someday. By practicing DP, you learn ways of thinking about problems that will make you a better developer. In 10 years, nobody will care about the spring framework, but the techniques you learned from DP will still serve you well.\nNow, the answer to your questions, part by parts:\n1) Why DP if we have modern computers?\nI think you got confused by the analogy of modern computers and the need for DP. Although modern computers are powerful in processing, you may think why I need DP if I have modern fast processors to run my application on.\nNot every task can be executed on these modern computers as they come up with storage, network, and compute costs. In fact, as an engineer, we should be thinking of optimizing the usage of such resources, that is, making your code efficient to make it capable of running on minimum system configurations.\nIn today's world, we have a shared service architecture. It means that different independent services share resources. But the fact is they are interdependent indirectly. Imagine what will happen if a non-optimized code is consuming a lot of memory and compute time. These processors will face difficulty in allocating resources for other services or applications.\nThe thing is, \"Why should I buy an apartment if a multi-bedroom flat can meet my needs and also creates an opportunity for others to buy a flat in the same apartment?\"\n2) DP in tech interviews\nThe fact that makes DP the most challenging topic to ace is the number of variations in DP.\nIt checks your ability to break down a difficult task into small ones to avoid reputations and thus save time, efforts, and thus overall resources.\nThat is one of the most prime reasons why DP is part of tech interviews.\nNot only DP teaches you to optimize and learn useful things, but it also highlights bad practices of writing codes.\n3) Usage of DP in real life\n\nIn Google Maps to find the shortest path between source and the series of destinations (one by one) out of the various available paths.\n\nIn networking to transfer data from a sender to various receivers in a sequential manner.\n\nDocument Distance Algorithms- to identify the extent of similarity between two text documents used by Search engines like Google, Wikipedia, Quora, and other websites\n\nEdit distance algorithm used in spell checkers.\n\nDatabases caching common queries in memory: through dedicated cache tiers storing data to avoid DB access, web servers store common data like configuration that can be used across requests. Then multiple levels of caching in code abstractions within every single request that prevents fetching the same data multiple times and save CPU cycles by avoiding recomputation. Finally, caches within your browser or mobile phones that keep the data that doesn't need to be fetched from the server every time.\n\nGit merge. Document diffing is one of the most prominent uses of LCS.\n\nDynamic programming is used in TeX's system of calculating the right amounts of hyphenations and justifications.\n\nGenetic algorithms.\n\n\nAlso, I found a great answer on Quora which lists the areas in which DP can be used:\nOperations research,\nDecision making,\nQuery optimization,\nWater resource engineering,\nEconomics,\nReservoir Operations problems,\nConnected speech recognition,\nSlope stability analysis,\nUsing Matlab,\nUsing Excel,\nUnit commitment,\nImage processing,\nOptimal Inventory control,\nReservoir operational Problems,\nSap Abap,\nSequence Alignment,\nSimulation for sewer management,\nFinance,\nProduction Optimization,\nGenetic Algorithms for permutation problem,\nHaskell,\nHTML,\nHealthcare,\nHydropower scheduling,\nLISP,\nLinear space,\nXML indexing and querying,\nBusiness,\nBioinformatics\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Are the Fibonacci series a Dynamic-programming problem?\r\n                \r\nI'm talking about the problem of calculating the n-th fibonacci number.\nSome users here say that it is in fact a DP problem, (please see the first answer to this question and the comments of the same answer   What is dynamic programming?) but others say that it isn't because it doesn't optimize anything and because of other reasons, so is it or not? \n    ", "Answer": "\r\nFrom Wikipedia page of dynamic programming,\n\n```\n var m := map(0 → 0, 1 → 1)\n function fib(n)\n   if key n is not in map m \n       m[n] := fib(n − 1) + fib(n − 2)\n   return m[n]\n\nThis technique of saving values that have already been calculated is called memoization; this is \nthe top-down approach, since we first break the problem into subproblems and then calculate and \nstore values.\n```\n\n\nSo, it's one of the techniques used to get the Nth number in the sequence.\n\nEDIT - For the added question, memoization is a form of DP.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming - translating JS to Elixir\r\n                \r\n\nI'm trying to translate the following toy dynamic programming problem to Elixir but struggling to see how to do it given there is no early return in Elixir.\nIt should return a valid combination from \"numbers\" that sum to \"targetSum\"\n```\nconst howSum = (targetSum, numbers) => {\n\n  if (targetSum === 0) return [];\n  if (targetSum < 0) return null;\n\n  for (let num of numbers) {\n    const remainder = targetSum - num;\n    const remainderResult = howSum(remainder, numbers);\n    if (remainderResult !== null) {\n      return [...remainderResult, num];\n    }\n  }\n\n  return null;\n\n}\n\nconsole.log(howSum(7, [2, 3])) // [3,2,2]\n```\n\nI can get below the Elixir version to log all possible solutions with a list comprehension, but how can I get the function to return the first solution found and return/stop at that point?\n```\ndefmodule HowSum do\n  @doc \"\"\"\n  Can you make target_sum from numbers list\n  You can use individual numbers as many times as you like\n  \"\"\"\n  def sum(0, _numbers, _), do: []\n  def sum(target_sum, _numbers, _) when target_sum < 0, do: nil\n\n  def sum(target_sum, numbers, path) do\n    for number <- numbers do\n      remainder = target_sum - number\n      result = sum(remainder, numbers, path ++ [number])\n\n      if result == [] do\n        IO.inspect(path ++ [number])\n      end\n    end\n  end\n  \nend\n```\n\nUPDATE\nThis is my solution which doesn't seem idiomatic but works using an Agent :-)\n```\ndefmodule HowSum do\n  def cache do\n    Agent.start_link(fn -> nil end, name: :solution)\n  end\n\n  @doc \"\"\"\n  Can you make target_sum from numbers list\n  You can use individual numbers as many times as you like\n  \"\"\"\n  def sum(0, _numbers, _), do: []\n  def sum(target_sum, _numbers, _) when target_sum < 0, do: nil\n\n  def sum(target_sum, numbers, path) do\n    solution = Agent.get(:solution, & &1)\n\n    if !solution do\n      for number <- numbers do\n        remainder = target_sum - number\n        result = sum(remainder, numbers, path ++ [number])\n\n        if result == [] do\n          Agent.update(:solution, &(&1 = path ++ [number]))\n        end\n      end\n    end\n\n    Agent.get(:solution, & &1)\n  end\nend\n\n```\n\n    ", "Answer": "\r\n```\nEnum.find/2```\n / ```\nEnum.find_index/2```\n / ```\nEnum.find_value/2```\n are very useful for this kind of case when you expect to return at some point in a \"loop\". ```\nEnum.reduce_while/3```\n is useful for more generic algorithms where you need some accumulator as well as early returns.\nHere is a solution using ```\nEnum.find_value/2```\n based on your javascript implementation:\n```\ndefmodule HowSum do\n  def sum(target_sum, number) do\n    target_sum |> do_sum(number) |> Enum.reverse()\n  end\n  \n  defp do_sum(0, _numbers), do: []\n  defp do_sum(target_sum, _numbers) when target_sum < 0, do: nil\n\n  defp do_sum(target_sum, numbers) do\n    Enum.find_value(numbers, fn number ->\n      remainder = target_sum - number\n      result = do_sum(remainder, numbers)\n\n      if result != nil do\n        [number | result]\n      end\n    end)\n  end\nend\n\n\nHowSum.sum(7, [2, 3])  # [3, 2, 2]\n```\n\nPlease note that this is highly inefficient to build a list by appending at the end, because you would need to clone it at each step. So I replaced ```\nresult ++ [number]```\n by ```\n[number | result]```\n, moved the recursive function as a private ```\ndo_```\n function, and called ```\nEnum.reverse/1```\n on its result. This is very common when working with recursive functions.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming with extremely large inputs\r\n                \r\nThe problem is to find the path with the minimum number of steps required to reach (m, n) from (1, 1) (if it exists) provided that you can only move in two ways:\n(x, y) = (x + y, y) or (x, y) = (x, x + y).\n\nI tried to do this with dynamic programming but m and n can be up to 10^25 so it is not feasible. How can I adapt my solution so that it can work for large inputs? Or is there an alternate method?\n    ", "Answer": "\r\nGo backwards. Say your goal is (x, y). If x > y, then the last step must have been from (x - y, y); otherwise, the last step must have been from (x, y - x). (If x = y, this location is unreachable.) Working backwards, it's easy to see there's only a single way to reach any reachable goal location, and that path is always obvious.\n\nWith that in mind, you can use a minor variation on the Euclidean algorithm to solve this problem. Each iteration or recursive level represents a number of steps in a given direction, and you can keep track of the number of steps you need along the way.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Runtime of Dynamic Programming Solution from Previous Post (Balls into Bins)\r\n                \r\nIn the question\nCalculating How Many Balls in Bins Over Several Values Using Dynamic Programming\nthe answer discusses a dynamic programming algorithm for placing balls into bins, and I was attempting to determine the running time, as it is not addressed in the answer.\n\nA quick summary: Given M indistinguishable balls and N distinguishable bins, the entry in the dynamic programming table Entry[i][j] represents the number of unique ways i balls can be placed into j bins. \n\n```\nS[i][j] = sum(x = 0 -> i, S[i-x][j-1])\n```\n\n\nIt is clear that the size of the dynamic programming 2D array is O(MN). However, I am trying to determine the impact the summation has on the running time.\n\nI know a summation of values (1....x) means we must access values from 1 to x. Would this then mean, that for each entry computation, since we must access at most from 1...M other values, the running time is in the realm of O((M^2)N)?\nWould appreciate any clarification. Thanks!\n    ", "Answer": "\r\nYou can avoid excessive time for summation if you keep column sums in additional table.   \n\nWhen you calculate ```\nS[i][j]```\n, also fill ```\nSums[i,j]=Sums[i-1,j] + S[i,j]```\n and later use this value for the cell at right side  ```\nS[i,j+1]```\n\n\nP.S. Note that you really need to store only two rows or even one row of sum table\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Control of the combinatorial aspects of a dynamic programming solution\r\n                \r\nI am exploring how a Dynamic Programming design approach relates to the underlying combinatorial properties of problems.\n\nFor this, I am looking at the canonical instance of the coin exchange problem: Let ```\nS = [d_1, d_2, ..., d_m]```\n and ```\nn > 0```\n be a requested amount. In how many ways can we add up to ```\nn```\n using nothing but the elements in ```\nS```\n?\n\nIf we follow a Dynamic Programming approach to design an algorithm for this problem that would allow for a solution with polynomial complexity, we would start by looking at the problem and how it is related to smaller and simpler sub-problems. This would yield a recursive relation describing an inductive step representing the problem in terms of the solutions to its related subproblems. We can then implement either a memoization technique or a tabulation technique to efficiently implement this recursive relation in a top-down or a bottom-up manner, respectively.\n\nA recursive relation could be the following (Python 3.6 syntax and 0-based indexing):\n\n```\ndef C(S, m, n):\n    if n < 0:\n        return 0\n    if n == 0:\n        return 1\n    if m <= 0:\n        return 0\n    count_wout_high_coin = C(S, m - 1, n)\n    count_with_high_coin = C(S, m, n - S[m - 1])\n    return count_wout_high_coin + count_with_high_coin\n```\n\n\nHowever, when drawing the sub-problem DAG, one can see that any DP-based algorithm implementing this recursive relation would yield a correct amount of solutions but disregarding the order.\n\nFor example, for ```\nS = [1, 2, 6]```\n and ```\nn = 6```\n, one can identify the following ways (assumming order matters):\n\n\n```\n1 + 1 + 1 + 1 + 1 + 1```\n\n```\n2 + 1 + 1 + 1 + 1```\n\n```\n1 + 2 + 1 + 1 + 1```\n\n```\n1 + 1 + 2 + 1 + 1```\n\n```\n1 + 1 + 1 + 2 + 1```\n\n```\n1 + 1 + 1 + 1 + 2```\n\n```\n2 + 2 + 1 + 1```\n\n```\n1 + 2 + 2 + 1```\n\n```\n1 + 1 + 2 + 2```\n\n```\n2 + 1 + 2 + 1```\n\n```\n1 + 2 + 1 + 2```\n\n```\n2 + 1 + 1 + 2```\n\n```\n2 + 2 + 2```\n\n```\n6```\n\n\n\nAssumming order does not matter, we could count the following solutions:\n\n\n```\n1 + 1 + 1 + 1 + 1 + 1```\n\n```\n2 + 1 + 1 + 1 + 1```\n\n```\n2 + 2 + 1 + 1```\n\n```\n2 + 2 + 2```\n\n```\n6```\n\n\n\nWhen approaching a problem solution from the Dynamic Programming standpoint, how can I control the order? Specifically, how could I write functions:\n\n\n```\ncount_with_order()```\n\n```\ncount_wout_order()```\n\n\n\n?\n\nCould it be that the need for order mattering implies choosing pruned backtracking over a Dynamic Programming approach?\n    ", "Answer": "\r\nEach problem is idiosyncratic, although there may be some problems that could be grouped together. For your particular example, a count where order matters could be implemented (either recursed or tabulated) by considering that the number of solutions for ```\nn```\n is equal to the total of solutions achievable from each lower achievable number, that is ```\nn - coin```\n for each denomination.\n\nPython code:\n\n```\ndef f(n, coins):\n  if n < 0:\n    return 0\n\n  if n == 0:\n    return 1\n\n  return sum([f(n - coin, coins) for coin in coins])\n\n# => f(6, [1, 2, 6]) # 14\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming - basic algorithm\r\n                \r\nConsider the following problem:\n\nWe have two sequences of cargo loads which can contain either grain or cattle. Now, we also have a sequence of cargo loads which we want to get from the initial sequences.\n\nThe initial sequences might look the following way, sequence we want to achieve is displayed to the right:\n\n```\nC   G                     \nG   C                     \nC   G                     G\nC   C                     C\nG   G                     G\n \\ /\n  ?\n```\n\n\nNow, at the ```\n?```\n spot one can pick the left cargo load or the right one. The picking should be done to match the wanted final sequence.\n\nFor example, we should pick ```\nGrain```\n at the beginning and then the picture would become this:\n\n```\n    G                     \nC   C                     \nG   G                     G\nС   C                     C\nС   G                     G\n \\ /\n  ?  ---> G (we took it from the left)\n```\n\n\n\n\nSo, does this problem has a well-known name? I realize that this can be solved by a simple dynamic programming algorithm, but I want to know more.\n\nBasically, if there is something more to read about this problem, I would like to read it. For example, I have no ideas about the complexity of the algorithm if we have an infinite number of finite input sequences.\n    ", "Answer": "\r\nI don't have much insight to share, but here it is:\n\n\nLet's call the cargoes 0 and 1 instead of C and G, moreover, let's label the two queues 0 and 1 instead of right and left.\nFirst the algorithm can not be solved with infinite (streamed) input sequences. In the case of two input seqs having only 0 then a 1 outside of the \"streaming visibility window\", you can't aim for this 1 if your result sequence needs it, so you could be stuck, while there was an answer. \nSince we can't talk about infinity, let's analyze the complexity of a solver. I can't see much better than your algorithm... If result sequence has length m and we modelize the result as a sequence of 0 and 1 (for right and left), there are 2^m possible solutions. If we consider that at every step, on average there's one chance out of two that only one input sequence will be valid, it means the other sequence will be invalid as well as other subsequent sequences. This should lead to an O(m!) complexity.\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "dynamic programming word segmentation\r\n                \r\nSuppose I have a string like 'meetateight' and I need to segment it into meaningful words like 'meet' 'at' 'eight' using dynamic programming.\n\nTo judge how “good” a block/segment \"x = x1x2x3\" is, I am given a black box that, on input x, returns a  real number quality(x) such that: A large positive value for quality(x) indicates x is close to an English word, and a large negative number indicates x is far from an English word.\n\nI need help with designing an algorithm for the same.\n\nI tried thinking over an algorithm in which I would iteratively add letters based on their quality and segment whenever there is a dip in quality.\nBut this fails in the above example because it cuts out me instead of meet.\n\nI need suggestions for a better algorithm.\n\nThanks\n    ", "Answer": "\r\nWhat about building a Trie using an English Dictionary and navigating it down scanning your string with all the possible path to leaf (backtracking when you have more than one choice).\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Binomial coefficients using dynamic programming and one dimensional array\r\n                \r\nMost implementations of binomial coefficient computation using dynamic programming makes use of 2-dimensional arrays, as in these examples:\nhttp://www.csl.mtu.edu/cs4321/www/Lectures/Lecture%2015%20-%20Dynamic%20Programming%20Binomial%20Coefficients.htm\n\nhttp://www.geeksforgeeks.org/dynamic-programming-set-9-binomial-coefficient/\n\nMy question is, why not just compute it using a single dimensional array like this:\n\n```\ndef C(n, r):\n    memo = list()\n    if (r > int(n/2)):\n        r = n - r\n    memo.append(1.0)\n    for i in range(1,r+1):\n        now = ((n-i+1)*memo[i-1])/i\n        memo.append(now)\n    return memo[r]\n```\n\n\nBasically using the recursive formula:\n    C(n,r) = ((n-r+1)/r) * C(n,r-1)\n\nThis has a O(r) complexity, while the 2 dimensional logic has a O(nr) complexity.\n\nAm I missing something here?\n    ", "Answer": "\r\nIf you want all of the values, then the 2D logic is certainly more efficient. The 2D logic may be more efficient for some parameters on some hardware that, e.g., lacks hardware multiply and divide. You have to be careful about integer overflow when multiplying before dividing, whereas the integer addition in the 2D recurrence is always fine. Other than that, no, the 1D recurrence is better.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming applied on a recursive algorithm\r\n                \r\nso bellow is my code for an algorithm using recursive calls. I will not explain what the algorithms exactly does, because i do not think that it is important to know for this question. It basically just calculates the amount of valid paths for a given input n. The algorithm has exponential complexity, so it is really slow for bigger n.\n\nWith the current algorithm i am only able to calculate n up to 10 in realistic time, but other people working on the same problem told me that it is possible to get up to 200 with the same recursive approach i took by adding in dynamic programming. So i read into dynamic programming a bit and i think i understood what it is supposed to do. It memorizes previous calculations so you do not have to calculate them again, instead you can just take them out of a list or so.\n\nBut i do not understand how i am able to apply that for my code, could anyone help me out or atleast give me a hint?\n\n```\npublic class CalculatePaths {\n\nstatic private int n;\nstatic private int remainingSteps; // calculates how many steps are left\nstatic private int paths = 0; // calculates how many valid paths there are\n\npublic static void main(String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    System.out.println(\"Enter a value for n: \");\n    n = scanner.nextInt();\n    remainingSteps = 2 * n;\n\n    move(0, 0, 0, 0, remainingSteps);\n    System.out.println(\"There are \" + paths + \" valid paths for n = \" + n);\n}\n\n/**\n * Goes through all paths and calculates the amount of valid paths\n * Stops if x or y or negative\n * Stops when all steps were used\n * A valid path has to meet the following conditions: \n * 1. There arent any remaning steps left\n * 2. The x-coordinate has to be 0\n * 3. The y-coordinate has to be equal to n\n */\npublic static void move(int xDirection, int yDirection, int parentx, int parenty, int remainingSteps) {\n\n    // calculates the current coorindates with the parent coordinates and the direction coordinates\n    parentx = parentx + xDirection;\n    parenty = parenty + yDirection;\n\n\n    if (parentx == 0 && parenty == n && remainingSteps == 0) { \n        paths++;\n    }\n\n    // recursive call as long as the coordinates arent negative and there are still remaining steps\n    if (remainingSteps > 0 && parentx >= 0 && parenty >= 0) {\n        move(1, 0, parentx, parenty, remainingSteps - 1); // goes to the right...\n        move(0, 1, parentx, parenty, remainingSteps - 1); // goes up...\n        move(0, -1, parentx, parenty, remainingSteps - 1); // goes down...\n        move(-1, 1, parentx, parenty, remainingSteps - 1); // diagonal top left...\n    }\n}\n}\n```\n\n    ", "Answer": "\r\nyou can you use 2D matrix and pass it along your move function. when you are at each cell you make an entry for of the computation for each cell. So when you are in the next cell you can just calculate from the previous cell.\nAnd you have a bug in your recursive move function call it should be.\n\n```\n move(x+1, 0, parentx, parenty, remainingSteps - 1); // goes to the right...\n move(0, y+1, parentx, parenty, remainingSteps - 1); // goes up...\n move(0, y-1, parentx, parenty, remainingSteps - 1); // goes down...\n move(x-1, 0, parentx, parenty, remainingSteps - 1); // diagonal top left...\n```\n\n\nhope this helps, I don't want to write the code for you leave it up to you to figure it out.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Implement Dynamic Programming in this algorithm?\r\n                \r\nI was provided with an algorithm that would help me solve the following problem:\n\nTake an ```\nNxN```\n grid. Start at the top left and traverse to the bottom right only going down or right from each node. For example:\n\n```\ngrid = [[0,2,5],[1,1,3],[2,1,1]]```\n\n\nImagine this list as a grid:\n\n```\n0 2 5\n1 1 3\n2 1 1\n```\n\n\nEach number you visit you have to add to the running total. In this case there are six different ways to get to the bottom that provide you with a total sum. The algorithm I was given that would work for this and return a list of possible sums is as follows:\n\n```\ndef gridsums(grid, x, y, memo):\nif memo[x][y] is not None:\n    return memo[x][y]\n\nif x == 0 and y == 0:\n    sums = [0]\nelif x == 0:\n    sums = gridsums(grid, x, y-1, memo)\nelif y == 0:\n    sums = gridsums(grid, x-1, y, memo)\nelse:\n    sums = gridsums(grid, x-1, y, memo) + gridsums(grid, x, y-1, memo)\n\nsums = [grid[x][y] + s for s in sums]\nmemo[x][y] = sums\nreturn sums\n\ndef gridsumsfast(grid):\nmemo = []\nfor row in grid:\n    memo.append([])\n    for cell in row:\n        memo[-1].append(None)\n\nreturn gridsums(grid, len(grid[0]) - 1, len(grid) - 1, memo)\n```\n\n\nIndentation is not correct but you get the idea. This works however for a much larger value of N, it does not work well at all. For example up to a N value of 20, it takes to long and on some tests I ran it times out.\n\nObviously there is a lot of repeat work being done by the main function so how exactly can I implement memoization/dynamic programming with this algorithm? The work is repeated a lot of times giving me grounds to say dynamic programming needs to be implemented however the line: ```\nsum = [grid[x][y] = s for s in sums]```\n trips me up because ```\nx```\n and ```\ny```\n change for each value so I would only have to commit the previous sums into a memo however I cannot quite wrap my head around doing so.\n\nAny guidance in the right direction is appreciated, thank you.\n    ", "Answer": "\r\nAll paths arrive in a cell either from above or from left. If you loop through the grid left to right and top to bottom, you can accumulate the sums from cells you have computed already. The idea is the same as in TravisJ's answer.\n\n```\ndef gridsums(grid):\n    previous_row_sums = [set() for _ in grid[0]]\n    previous_row_sums[0].add(0) #seed\n    for row in grid:\n        left_sums = set()\n        row_sums = []\n        for value, above_sums in zip(row, previous_row_sums):\n            old_sums = left_sums | above_sums\n            sums = {value + old for old in old_sums}\n            row_sums.append(sums)\n            left_sums = sums\n        previous_row_sums = row_sums\n    return sums\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Split a string to a string of valid words using Dynamic Programming\r\n                \r\nI need to find a dynamic programming algorithm to solve this problem. I tried but couldn't figure it out. Here is the problem:\n\nYou are given a string of n characters s[1...n], which you believe to be a corrupted text document in which all punctuation has vanished (so that it looks something like \"itwasthebestoftimes...\").  You wish to reconstruct the document using a dictionary, which is available in the form of a Boolean function dict(*) such that, for any string w, dict(w) has value 1 if w is a valid word, and has value 0 otherwise.\n\n\nGive a dynamic programming algorithm that determines whether the string s[*] can be reconstituted as a sequence of valid words.  The running time should be at most O(n^2), assuming that each call to dict takes unit time.\nIn the event that the string is valid, make your algorithm output the corresponding sequence of words. \n\n    ", "Answer": "\r\nLet the length of your compacted document be N.\n\nLet b(n) be a boolean: true if the document can be split into words starting from position n in the document.\n\nb(N) is true (since the empty string can be split into 0 words).\nGiven b(N), b(N - 1), ... b(N - k), you can construct b(N - k - 1) by considering all words that start at character N - k - 1. If there's any such word, w, with b(N - k - 1 + len(w)) set, then set b(N  - k - 1) to true. If there's no such word, then set b(N - k - 1) to false.\n\nEventually, you compute b(0) which tells you if the entire document can be split into words.\n\nIn pseudo-code:\n\n```\ndef try_to_split(doc):\n  N = len(doc)\n  b = [False] * (N + 1)\n  b[N] = True\n  for i in range(N - 1, -1, -1):\n    for word starting at position i:\n      if b[i + len(word)]:\n        b[i] = True\n        break\n  return b\n```\n\n\nThere's some tricks you can do to get 'word starting at position i' efficient, but you're asked for an O(N^2) algorithm, so you can just look up every string starting at i in the dictionary.\n\nTo generate the words, you can either modify the above algorithm to store the good words, or just generate it like this:\n\n```\ndef generate_words(doc, b, idx=0):\n  length = 1\n  while true:\n    assert b(idx)\n    if idx == len(doc): return\n    word = doc[idx: idx + length]\n    if word in dictionary and b(idx + length):\n       output(word)\n       idx += length\n       length = 1\n```\n\n\nHere b is the boolean array generated from the first part of the algorithm.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "How to dynamic programming with a LARGE input\r\n                \r\nLet's assume that we're now solving a typical problem which can be solved by dynamic programming - get the number of possible coin combinations for a change.\n\n```\nMemorizer mem = new Memorizer();\nint[] coins = { 100000, 8534, 5935, 291, 76, 51, 30, 29, 7, 5 }\n......\n\nint getNum(int money, int idx) {\n    if(idx == coins.length - 1) {\n        if(money % coins[idx] == 0)\n            return 1;\n        else\n            return 0;\n    }\n\n    int found = mem.find(money, idx);\n    if(found != null)\n        return found;\n\n    int num = 0;\n    for(int i = 0; i <= (money / coins[idx]); i++)\n        num += getNum(money - i * coins[idx], idx + 1); \n\n    mem.remember(money, idx, num);\n\n    return num;\n}\n```\n\n\nBut if the money is very large, something like 2,000,000,000, it's very hard to memorize all the intermediate results. How can I solve the problem with a very large input? Please help me. Thank you.\n    ", "Answer": "\r\nThere is something wrong with this dp, it should be:\n\n```\nif(money % coins[idx] == 0)\n    return money/coins[idx];\n```\n\n\nThat being said, It is bad idea to loop on one coin value till you reach the money, rather, loop through all the values of coin. This way, num[x] = min(num[x-coin[i]]+1, num[x]).\n\nIn this code,  we could use memorization on part of array, i.e. last {maximum value of coin} elements, because, you only need to remember for x-coin[i]. Try figuring out how to implement this if it is what you are looking for.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming problems using iteration\r\n                \r\nI have spent a lot of time to learn about implementing/visualizing dynamic programming problems using iteration but I find it very hard to understand, I can implement the same using recursion with memoization but it is slow when compared to iteration.\n\nCan someone explain the same by a example of a hard problem or by using some basic concepts. Like the matrix chain multiplication, longest palindromic sub sequence  and others. I can understand the recursion process and then memoize the overlapping sub problems for efficiency but I can't understand how to do the same using iteration.\n\nThanks!\n    ", "Answer": "\r\nDynamic programming is all about solving the sub-problems in order to solve the bigger one. The difference between the recursive approach and the iterative approach is that the former is top-down, and the latter is bottom-up. In other words, using recursion, you start from the big problem you are trying to solve and chop it down to a bit smaller sub-problems, on which you repeat the process until you reach the sub-problem so small you can solve. This has an advantage that you only have to solve the sub-problems that are absolutely needed and using memoization to remember the results as you go. The bottom-up approach first solves all the sub-problems, using tabulation to remember the results. If we are not doing extra work of solving the sub-problems that are not needed, this is a better approach.\n\nFor a simpler example, let's look at the Fibonacci sequence. Say we'd like to compute ```\nF(101)```\n. When doing it recursively, we will start with our big problem - ```\nF(101)```\n. For that, we notice that we need to compute ```\nF(99)```\n and ```\nF(100)```\n. Then, for ```\nF(99)```\n we need ```\nF(97)```\n and ```\nF(98)```\n. We continue until we reach the smallest solvable sub-problem, which is ```\nF(1)```\n, and memoize the results. When doing it iteratively, we start from the smallest sub-problem, ```\nF(1)```\n and continue all the way up, keeping the results in a table (so essentially it's just a simple for loop from 1 to 101 in this case).\n\nLet's take a look at the matrix chain multiplication problem, which you requested. We'll start with a naive recursive implementation, then recursive DP, and finally iterative DP. It's going to be implemented in a C/C++ soup, but you should be able to follow along even if you are not very familiar with them.\n\n```\n/* Solve the problem recursively (naive)\n\n   p - matrix dimensions\n   n - size of p\n   i..j - state (sub-problem): range of parenthesis */\nint solve_rn(int p[], int n, int i, int j) {\n    // A matrix multiplied by itself needs no operations\n    if (i == j) return 0;\n\n    // A minimal solution for this sub-problem, we\n    // initialize it with the maximal possible value\n    int min = std::numeric_limits<int>::max();\n\n    // Recursively solve all the sub-problems\n    for (int k = i; k < j; ++k) {\n        int tmp = solve_rn(p, n, i, k) + solve_rn(p, n, k + 1, j) + p[i - 1] * p[k] * p[j];\n        if (tmp < min) min = tmp;\n    }\n\n    // Return solution for this sub-problem\n    return min;\n}\n```\n\n\nTo compute the result, we starts with the big problem:\n\n```\nsolve_rn(p, n, 1, n - 1)\n```\n\n\nThe key of DP is to remember all the solutions to the sub-problems instead of forgetting them, so we don't need to recompute them. It's trivial to make a few adjustments to the above code in order to achieve that:\n\n```\n/* Solve the problem recursively (DP)\n\n   p - matrix dimensions\n   n - size of p\n   i..j - state (sub-problem): range of parenthesis */\nint solve_r(int p[], int n, int i, int j) {\n    /* We need to remember the results for state i..j.\n       This can be done in a matrix, which we call dp,\n       such that dp[i][j] is the best solution for the\n       state i..j. We initialize everything to 0 first.\n\n       static keyword here is just a C/C++ thing for keeping\n       the matrix between function calls, you can also either\n       make it global or pass it as a parameter each time.\n\n       MAXN is here too because the array size when doing it like\n       this has to be a constant in C/C++. I set it to 100 here.\n       But you can do it some other way if you don't like it. */\n    static int dp[MAXN][MAXN] = {{0}};\n\n    /* A matrix multiplied by itself has 0 operations, so we\n       can just return 0. Also, if we already computed the result\n       for this state, just return that. */\n    if (i == j) return 0;\n    else if (dp[i][j] != 0) return dp[i][j];\n\n    // A minimal solution for this sub-problem, we\n    // initialize it with the maximal possible value\n    dp[i][j] = std::numeric_limits<int>::max();\n\n    // Recursively solve all the sub-problems\n    for (int k = i; k < j; ++k) {\n        int tmp = solve_r(p, n, i, k) + solve_r(p, n, k + 1, j) + p[i - 1] * p[k] * p[j];\n        if (tmp < dp[i][j]) dp[i][j] = tmp;\n    }\n\n    // Return solution for this sub-problem\n    return dp[i][j];;\n}\n```\n\n\nWe start with the big problem as well:\n\n```\nsolve_r(p, n, 1, n - 1)\n```\n\n\nIterative solution is only to, well, iterate all the states, instead of starting from the top:\n\n```\n/* Solve the problem iteratively\n\n   p - matrix dimensions\n   n - size of p\n\n   We don't need to pass state, because we iterate the states. */\nint solve_i(int p[], int n) {\n    // But we do need our table, just like before\n    static int dp[MAXN][MAXN];\n\n    // Multiplying a matrix by itself needs no operations\n    for (int i = 1; i < n; ++i)\n        dp[i][i] = 0;\n\n    // L represents the length of the chain. We go from smallest, to\n    // biggest. Made L capital to distinguish letter l from number 1\n    for (int L = 2; L < n; ++L) {\n        // This double loop goes through all the states in the current\n        // chain length.\n        for (int i = 1; i <= n - L + 1; ++i) {\n            int j = i + L - 1;\n            dp[i][j] = std::numeric_limits<int>::max();\n\n            for (int k = i; k <= j - 1; ++k) {\n                int tmp = dp[i][k] + dp[k+1][j] + p[i-1] * p[k] * p[j];\n                if (tmp < dp[i][j])\n                    dp[i][j] = tmp;\n            }\n        }\n    }\n\n    // Return the result of the biggest problem\n    return dp[1][n-1];\n}\n```\n\n\nTo compute the result, just call it:\n\n```\nsolve_i(p, n)\n```\n\n\n\n\nExplanation of the loop counters in the last example:\n\nLet's say we need to optimize the multiplication of 4 matrices: ```\nA B C D```\n. We are doing an iterative approach, so we will first compute the chains with the length of two: ```\n(A B) C D```\n, ```\nA (B C) D```\n, and ```\nA B (C D)```\n. And then chains of three: ```\n(A B C) D```\n, and ```\nA (B C D)```\n. That is what ```\nL```\n, ```\ni```\n and ```\nj```\n are for.\n\n```\nL```\n represents the chain length, it goes from ```\n2```\n to ```\nn - 1```\n (```\nn```\n is ```\n4```\n in this case, so that is ```\n3```\n).\n\n```\ni```\n and ```\nj```\n represent the starting and ending position of the chain. In case ```\nL = 2```\n, ```\ni```\n goes from ```\n1```\n to ```\n3```\n, and ```\nj```\n goes from ```\n2```\n to ```\n4```\n:\n\n```\n(A B) C D     A (B C) D     A B (C D)\n ^ ^             ^ ^             ^ ^\n i j             i j             i j\n```\n\n\nIn case ```\nL = 3```\n, ```\ni```\n goes from ```\n1```\n to ```\n2```\n, and ```\nj```\n goes from ```\n3```\n to ```\n4```\n:\n\n```\n(A B C) D     A (B C D)\n ^   ^           ^   ^\n i   j           i   j\n```\n\n\nSo generally, ```\ni```\n goes from ```\n1```\n to ```\nn - L + 1```\n, and ```\nj```\n is ```\ni + L - 1```\n.\n\nNow, let's continue with the algorithm assuming that we are at the step where we have ```\n(A B C) D```\n. We now need to take into account the sub-problems (which are already calculated): ```\n((A B) C) D```\n and ```\n(A (B C)) D```\n. That is what ```\nk```\n is for. It goes through all the positions between ```\ni```\n and ```\nj```\n and computes the sub problems.\n\nI hope I helped.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Coin Change Problem with Dynamic Programming\r\n                \r\nThis is my code regarding the Coin Change Problem for print the total number of ways for a set of coins and the target amount\n\n```\ndef coin_change(coins,amount):\n    table=[0 for k in range(amount+1)]\n    table[0]=1\n    for coin in coins:\n        for x in range(coin,amount+1):\n            table[x] = table[x]+ table[x-coin]\n        print(table)  \n\n    return table[amount]\n```\n\n\nI want to know that is there any method to print those ways with the same dynamic programming solution (with the help of an inner constructed table or any other)\n\nfor example if a set of coins are [1,3,5] and target amount is 6\nso there are total of 4 ways possible.\n[[1,1,1,1,1,1,],[1,1,1,3],[3,3],[1,5]]\nI want this way's list as an output.\n    ", "Answer": "\r\nAnswer edited per your requirement:\n\n```\ndef combine(parent, me):\n    if len(parent) == 0:\n        return [[me]]\n    new_list = []\n    for entry in parent:\n        new_list.append(entry + [me])\n    return new_list\n\n\ndef get_ways(amount, coins):\n    table = [0 for k in range(amount + 1)]\n    table[0] = 1\n    ways = [[] for _ in range(amount + 1)]\n    for coin in coins:\n        for x in range(coin, amount + 1):\n            table[x] = table[x] + table[x - coin]\n            ways[x].extend(combine(ways[x - coin], coin))\n    print(ways[amount])\n    return table[amount]\n\n\nprint(get_ways(6, [1, 3, 5]))\n```\n\n\nThe output:\n\n```\n[[1, 1, 1, 1, 1, 1], [1, 1, 1, 3], [3, 3], [1, 5]]\n4\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming problem -Minimum Cost Path\r\n                \r\nI was trying this problem - Minimum Cost Path.\nI have solved the problem using Dijkstra's Shortest Path Algorithm. But when i tried this using recursion+memoisation i.e. using dynamic programming, i got stuck and could not debug my code. I need help as to where my code is wrong!!\n\nI am really glad for the help.\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nint a[105][105], dp[105][105];\n\nint dfs(int x, int y){\n    if(x < 0 || y < 0 || x >= n || y >= n){\n        return INT_MAX;\n    }\n    if(x == 0 && y== 0){\n        return a[0][0];\n    }\n    if(dp[x][y] != -1){\n        return dp[x][y];\n    }\n    dp[x][y] = a[x][y] + min(dfs(x-1, y), min(dfs(x, y-1), min(dfs(x+1, y), dfs(x, y+1))));\n    return dp[x][y];\n}\n\n\nint main(){\n    int tt;\n    cin >> tt;\n    while(tt--){\n        int n;\n        cin >> n;\n        for(int i = 0 ; i < n; i++){\n            for(int j = 0; j < n; j++){\n                cin >> a[i][j];\n                dp[i][j] = -1;\n            }\n        }\n        cout << dfs(n-1, n-1) << endl;\n    }\n    return 0;\n}\n\n\n\nExample:\nInput:\n2\n5\n31 100 65 12 18 10 13 47 157 6 100 113 174 11 33 88 124 41 20 140 99 32 111 41 20\n2\n42 93 7 14\n\nOutput:\n327\n63\n```\n\n\nI am getting 2147483647 as the output for both the cases, which is the value of INT_MAX.\n    ", "Answer": "\r\nThe global variable ```\nn```\n that ```\ndfs```\n looks at is always zero (by static initialization), it's never assigned a value. When ```\nmain```\n calls, say, ```\ndfs(4, 4)```\n, the function immediately returns ```\nINT_MAX```\n due to ```\n4 >= 0```\n check.\n\n\n\nOnce you fix this simple issue, you'll discover that your program crashes due to stack overflow. You see, ```\ndfs(4, 4)```\n calls ```\ndfs(3, 4)```\n, which in turn calls ```\ndfs(4, 4)```\n, which calls ```\ndfs(3, 4)```\n, which ...\n\nThis is not really a dynamic programming problem. It's a \"shortest path in a graph\" problem, suitable for, say, Dijkstra or A* algorithms.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "multi-constrainted single machine scheduling using Dynamic Programming\r\n                \r\nLet a set of tasks are given to machine to find a profitable ordering of tasks. Each task has profit, start and finish time. Machine is constrained in energy, memory and execution time duration. In addition a schedule will have a set of compatible tasks (no overlapping). Is there any Dynamic Programming strategy to produce a profitable schedule by considering all the constraints or condition?\nI can solve three constraints (energy, memory and execution time duration) by using constraints merging and surrogate relaxation. But I can not handle no overlapping or tasks compatibility with other constraints...  \n\nAnybody please suggest a way to merge all the constraints for Dynamic Programming....\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Matrix Sum Top down Dynamic Programming\r\n                \r\nProblem\n\n\n  You are given a  matrix. You need to print the sum of all the numbers in the rectangle which has  as the top left corner and  as the bottom right corner.\n\n\nI'm using top down dynamic programming approach to solve this problem. see my code.\n\n```\nimport java.util.*;\npublic class Matrixsum\n{\n\n    static int dp[][] = new int[4][4]; // for debugging max size 1001,1001\n\n    static int findsum(int arr[][] , int i, int j)\n    {\n        if(i<1 || j < 1) return 0;\n        if(dp[i][j] != -1)\n            return dp[i][j];\n        else\ndp[i][j] = findsum(arr,i-1,j)+findsum(arr,i,j-1)+findsum(arr,i-1,j-1)+arr[i][j];\n        return dp[i][j];\n    }\n\n    public static void main(String[] args)\n    {\n            for(int[] d:dp) Arrays.fill(d,-1);\n            Scanner sc = new Scanner(System.in);\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            int arr[][] = new int[1001][1001];\n            for(int i=0;i<a;i++)\n            {\n                for (int j = 0; j < b; j++) {\n                    arr[i][j] = sc.nextInt();\n                }\n            }\n\n            int q = sc.nextInt();\n            while(q-- > 0)\n            {\n                int i = sc.nextInt();\n                int j = sc.nextInt();\n                System.out.println(findsum(arr,i,j));\n            }\n            System.out.println(Arrays.deepToString(dp));\n         //   dp = new int[1001][1001];\n        }\n}\n```\n\n\n\n  Input\n\n\n```\n3 3\n1 2 3\n4 5 6\n7 8 9\n2\n3 3\n2 3\n```\n\n\n\n  Output\n\n\n```\n162\n60\n[[-1, -1, -1, -1], [-1, 5, 11, 11], [-1, 13, 38, 60], [-1, 13, 64, 162]]\n```\n\n\n\n  Expected output\n\n\n```\n45\n21\n```\n\n\nBut this is throwing very random numbers when query is entered . I'm not getting what's I'm missing here.\nCan somebody help ? \n\nThanks ✌️\n    ", "Answer": "\r\nIn the line where you calculate \n\n```\ndp[i][j] = findsum(arr,i-1,j)+findsum(arr,i,j-1)+findsum(arr,i-1,j-1)+arr[i][j];```\n\n\nyou are actually counting many cells twice.\n\nYou should write that line this way (I just changed a + to -):\n\n```\ndp[i][j] = findsum(arr,i-1,j)+findsum(arr,i,j-1)-findsum(arr,i-1,j-1)+arr[i][j];```\n\n\nTry drawing the matrix on a piece of paper and try to write down the cells you are adding to your sum for ```\ndp[i][j]```\n in the calculation for small i,j samples (you are counting cells in the rectangle which starts at (1,1) and ends in (i-1,j-1) three times).\n\nAfter changing this you can start from the first row and calculate your DP array from left to right for each row.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Reducing memory usage for dynamic programming implementation of TSP\r\n                \r\nI'm trying to implement dynamic programming to solve TSP for a set of 25 cities.\nWith the straight-forward implementation the program I'm facing 'memory error'. I'm trying to solve it by taking into account that my implementation needs only subsets which are of size 1 less than the current subsets, i.e. the sub-problem in dynamic programming is the current set with one element removed. Hence only the distances corresponding to current and previous sizes,(sizes vary from 2 to 25), are stored. Still, the program eats almost 85% of memory and then throws error. My system has 4GB of RAM.\nHow can I fix the code so that its memory usage doesn't explode?\n\n```\ndef make_set(i):\n    '''Generates all subsets of size i(integer)\n        from cities, including the element 1'''\n    cities = range(2,26)\n    subs = comb(cities,i)\n    for j in subs:\n        j=set(j)\n        j.add(1)\n        yield j\n\ndef tsp(cities,dist):\n    '''Performs search on subsets to find shortest path that traverses\n       all cities starting and ending at 1\n       Returns a dictionary, contains all \n       needs to be processed further to find the subset_dist answer'''\n    subset_dist={}\n    subset_dist[(frozenset([1]),1)]=0\n    for i in range(1,25): \n        subset_dist_new={}\n        subsets = make_set(i) #generator for subsets of size i\n        for S in subsets:\n            for j in S:       # j is the destination\n                if j!=1:\n                    min_dist= float('inf')\n                    S_minusJ = set(S)\n                    S_minusJ.remove(j)\n                    for k in S:     #k defines the subproblem, the closest city before j, for current subset\n                        if k==1 and len(S)>2:\n                            continue\n                        if k!=j:\n                            min_dist = min(min_dist,subset_dist[(frozenset(S_minusJ),k)]+dist[frozenset([j,k])])\n                            subset_dist_new[(frozenset(S),j)] = min_dist \n        subset_dist = subset_dist_new\n    return subset_dist_new\n```\n\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Split a string to a string of valid words using Dynamic Programming\r\n                \r\nI need to find a dynamic programming algorithm to solve this problem. I tried but couldn't figure it out. Here is the problem:\n\nYou are given a string of n characters s[1...n], which you believe to be a corrupted text document in which all punctuation has vanished (so that it looks something like \"itwasthebestoftimes...\").  You wish to reconstruct the document using a dictionary, which is available in the form of a Boolean function dict(*) such that, for any string w, dict(w) has value 1 if w is a valid word, and has value 0 otherwise.\n\n\nGive a dynamic programming algorithm that determines whether the string s[*] can be reconstituted as a sequence of valid words.  The running time should be at most O(n^2), assuming that each call to dict takes unit time.\nIn the event that the string is valid, make your algorithm output the corresponding sequence of words. \n\n    ", "Answer": "\r\nLet the length of your compacted document be N.\n\nLet b(n) be a boolean: true if the document can be split into words starting from position n in the document.\n\nb(N) is true (since the empty string can be split into 0 words).\nGiven b(N), b(N - 1), ... b(N - k), you can construct b(N - k - 1) by considering all words that start at character N - k - 1. If there's any such word, w, with b(N - k - 1 + len(w)) set, then set b(N  - k - 1) to true. If there's no such word, then set b(N - k - 1) to false.\n\nEventually, you compute b(0) which tells you if the entire document can be split into words.\n\nIn pseudo-code:\n\n```\ndef try_to_split(doc):\n  N = len(doc)\n  b = [False] * (N + 1)\n  b[N] = True\n  for i in range(N - 1, -1, -1):\n    for word starting at position i:\n      if b[i + len(word)]:\n        b[i] = True\n        break\n  return b\n```\n\n\nThere's some tricks you can do to get 'word starting at position i' efficient, but you're asked for an O(N^2) algorithm, so you can just look up every string starting at i in the dictionary.\n\nTo generate the words, you can either modify the above algorithm to store the good words, or just generate it like this:\n\n```\ndef generate_words(doc, b, idx=0):\n  length = 1\n  while true:\n    assert b(idx)\n    if idx == len(doc): return\n    word = doc[idx: idx + length]\n    if word in dictionary and b(idx + length):\n       output(word)\n       idx += length\n       length = 1\n```\n\n\nHere b is the boolean array generated from the first part of the algorithm.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "multi-constrainted single machine scheduling using Dynamic Programming\r\n                \r\nLet a set of tasks are given to machine to find a profitable ordering of tasks. Each task has profit, start and finish time. Machine is constrained in energy, memory and execution time duration. In addition a schedule will have a set of compatible tasks (no overlapping). Is there any Dynamic Programming strategy to produce a profitable schedule by considering all the constraints or condition?\nI can solve three constraints (energy, memory and execution time duration) by using constraints merging and surrogate relaxation. But I can not handle no overlapping or tasks compatibility with other constraints...  \n\nAnybody please suggest a way to merge all the constraints for Dynamic Programming....\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "dynamic programming with recursive function in python\r\n                \r\nI'm new to python, and I'm struggling to write a recursive function.\nI have these lines of code for a dynamic programming function in Matlab which were given as an example from a professor:\n\n```\nfunction [policy,fstar] =StochasticInventoryControl(N,K,c,h,M,g,Dmax,p)\n   fstar=zeros(M+1,N+1);\n   for n=N:-1:1\n      for s=0:M\n         for x=0:M-s\n            temp=0;\n            for d=0:Dmax\n               temp=temp+p(d+1)*(g*min(s+x,d)+fstar(1+max(s+x-d,0),n+1));\n            end\n            f(1+s,1+x)=-K*(x>0)-c*x-h*(s+x)+temp;\n         end\n      [fstar(1+s,n),policy(1+s,n)]=max(f(1+s,1:M-s+1));\n      end\n   end\n   policy=policy-1; \nend\n```\n\n\nI'm trying to re-write the same function in python, and I came up with this code:\n\n```\ndef StochasticInventoryControl(N, K, c, h, M, g, Dmax, p):\n    fstar = zeros(M + 1, N + 1)\n    for n in range (N, 1, -1):\n        for s in range (0, M):\n            for x in range (0, M - s):\n                temp = 0\n            for d in range (0, Dmax):\n                temp = temp + p(d + 1)*(g*min(s + x, d) + fstar(1 + max(s + x - d,0), n + 1))\n        f(1 + s, 1 + x).lvalue = -K * (x > 0) - c * x - h * (s + x) + temp\n    [fstar(1 + s, n), policy(1 + s, n)] = max(f(1 + s, n in range (1, M - s + 1))\n```\n\n\nThe last line is incorrect, I know I can't define the function's recursive relation this way in python. How should I write the last line in python?\n    ", "Answer": "\r\nFirst, your indexing and ranges are off. Like most programming languages, python indexes and ranges start with 0, and ranges are half-open (they exclude the last value), so you need to take that into account in your ranges.  \n\nSecond, numpy uses square brackets for indexing, so it would be ```\nf[s,x]```\n not ```\nf(s,x)```\n.\n\nThird, you can do slicing in numpy arrays just like in MATLAB, but you need to take into account the indexing differences and the fact that for ```\nx:y:z```\n indexing the last element is the step size in Python while in MATLAB the middle element is.\n\nFourth, indentation is significant in Python, so your inner loop needs to be indented one more level to work the same as in MATLAB.\n\nAs for your question about the last line last line, there is no single function in numpy that handles both the max value and max index. You need to use ```\nnp.max```\n for the value and ```\nnp.argmax```\n for the index, like so:\n\n```\nfstar[s, n-1] = np.max(f[s, :M-s+1])\npolicy[s, n-1] = np.argmax(f[s, :M-s+1])+1\n```\n\n\nOr better yet use the numpy method approach:\n\n```\nfstar[s, n-1] = f[s, :M-s+1].max()\npolicy[s, n-1] = f[s, :M-s+1].argmax()+1\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Lazy evaluation container for dynamic programming?\r\n                \r\nI have some pattern that works great for me, but that I have some difficulty explaining to fellow programmers. I am looking for some justification or literature reference.\n\nI personally work with PHP, but this would also be applicable to Java, Javascript, C++, and similar languages. Examples will be in PHP or Pseudocode, I hope you can live with this.\n\nThe idea is to use a lazy evaluation container for intermediate results, to avoid multiple computation of the same intermediate value.\n\n\"Dynamic programming\":\n\nhttp://en.wikipedia.org/wiki/Dynamic_programming\n\n\n  The dynamic programming approach seeks to solve each subproblem only once, thus reducing the number of computations: once the solution to a given subproblem has been computed, it is stored or \"memo-ized\": the next time the same solution is needed, it is simply looked up\n\n\nLazy evaluation container:\n\n```\nclass LazyEvaluationContainer {\n\n  protected $values = array();\n\n  function get($key) {\n    if (isset($this->values[$key])) {\n      return $this->values[$key];\n    }\n    if (method_exists($this, $key)) {\n      return $this->values[$key] = $this->$key();\n    }\n    throw new Exception(\"Key $key not supported.\");\n  }\n\n  protected function foo() {\n    // Make sure that bar() runs only once.\n    return $this->get('bar') + $this->get('bar');\n  }\n\n  protected function bar() {\n    .. // expensive computation.\n  }\n}\n```\n\n\nSimilar containers are used e.g. as dependency injection containers (DIC).\n\nDetails\n\nI usually use some variation of this.\n\n\nIt is possible to have the actual data methods in a different object than the data computation methods?\nIt is possible to have computation methods with parameters, using a cache with a nested array?\nIn PHP it is possible to use magic methods (__get() or __call()) for the main retrieval method. In combination with \"@property\" in the class docblock, this allows type hints for each \"virtual\" property.\nI often use method names like \"get_someValue()\", where \"someValue\" is the actual key, to distinguish from regular methods.\nIt is possible to distribute the data computation to more than one object, to get some kind of separation of concerns?\nIt is possible to pre-initialize some values?\n\n\nEDIT: Questions\n\nThere is already a nice answer talking about a cute mechanic in Spring @Configuration classes.\n\nTo make this more useful and interesting, I extend/clarify the question a bit:\n\n\nIs storing intermediate values from dynamic programming a legitimate use case for this?\nWhat are the best practices to implement this in PHP? Is some of the stuff in \"Details\" bad and ugly?\n\n    ", "Answer": "\r\nIf I understand you correctly, this is quite a standard procedure, although, as you rightly admit, associated with DI (or bootstrapping applications).\n\nA concrete, canonical example would be any Spring ```\n@Configuration```\n class with lazy bean definitions; I think it displays exactly the same behavior as you describe, although the actual code that accomplishes it is hidden from view (and generated behind the scenes). Actual Java code could be like this:\n\n```\n@Configuration\npublic class Whatever {\n\n  @Bean @Lazy\n  public OneThing createOneThing() {\n    return new OneThing();\n  }\n\n  @Bean @Lazy\n  public SomeOtherThing createSomeOtherThing() {\n    return new SomeOtherThing();\n  }\n\n  // here the magic begins:\n\n  @Bean @Lazy\n  public SomeThirdThing getSomeThirdThing() {\n    return new SomeThirdThing(this.createOneThing(), this.createOneThing(), this.createOneThing(), createSomeOtherThing());\n  }\n}\n```\n\n\nEach method marked with ```\n@Bean @Lazy```\n represents one \"resource\" that will be created once it is needed (and the method is called) and - no matter how many times it seems that the method is called - the object will only be created once (due to some magic that changes the actual code during loading). So even though it seems that in ```\ncreateOneThing()```\n is called two times in ```\ncreateOneThing()```\n, only one call will occur (and that's only after someone tries to call ```\ncreateSomeThirdThing()```\n or calls ```\ngetBean(SomeThirdThing.class)```\n on ```\nApplicationContext```\n).\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "strings based on dynamic programming\r\n                \r\ni have these problem in dynamic programming, i need to provide a solution based on dybamic programming:\n\nWe have strings with length n, and contain only {A,B,C} charachters.string is \"winner\" only if it does not contain 3 A's in a row and contain at most one 'B'. \nexample:\nThere are 43 \"winners\" strings with length 4.\ni need to suggest an algorithm that calculates the number of \"winning\" strings with length n. it need to run in O(n) complexity.\n\nWhat i thought about so far is:\n3 paramaters: n- length of the current string, bCount=1, aCount=2.\nin every iteration the n decreasing by 1. if we used b so bCount decreasing by 1. if we used A so aCount decreasing by 1 but it initialized to 2 if any other charachter had inserted.\n\ni need to make it formal and clear, hope you can help me fill the gaps and make the solution formal.\n\nI really tried hard to solve it, i would be very thankful if anyone can help me.\n\nthank you in advance.\n    ", "Answer": "\r\nFirst lets look at B. You either have no B and therefor a string of length n with only A and C or you have a string with 1 B and 2 sub strings with cumulated length of n - 1 with only A and C. So if you can calculate all valid A and C combinations for strings of any length the rest becomes easy.\n\n```\nfunction winners(n) {\n    let sum = combos[n]\n    for (let i = 0; i < n; i++)\n        sum += combos[i] * combos[n - i - 1]\n    return sum\n}\n```\n\n\nHow to calculate the A, C combos? You can use dynamic programming (always look how many strings end in A, C and AA):\n\n```\ncombos = [1, 2]\nendsInA = 1\nendsInC = 1\nendsInAA = 0\nfor (let i = 2; i <= n; i++) {\n    combos[i] = (endsInA + endsInC) * 2 + endsInAA\n    let c = endsInC\n    endsInC = endsInA + endsInAA + c\n    endsInAA = endsInA\n    endsInA = c\n}\n```\n\n\nIt is ```\n(endsInA + endsInC) * 2 + endsInAA```\n because after those ending in A or C you can put either an A or a C while after those ending in AA you can only put a C. The update rule is also quite easy to understand. You have as many strings ending in AA as you had strings ending in A before and as many Strings ending in A as you had strings ending in C before. C can be put behind all the strings, so it is just the sum of all the possible endings from before. You could also update first and then just take the sum of all the endings to get the number of combos.\n\nEverything put together and optimized for a demo\n\nIt takes O(n) to calculate the combinations and O(n) to calculate the winners and therefore the whole complexity is O(n).\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Coin change using dynamic programming\r\n                \r\nI've been working on coin change problem using dynamic programming. I've tried to make an array fin[] which contains the minimum number of coins required for that index and then print it.\nI've written a code which I think should give correct output but I can't figure out why it is not giving exact answer.\nFor eg: for the input: 4 3 1 2 3 (4 is the amount to change, 3 the number of types of available coins, 1 2 3 is the list of coin values)\nThe output should be: 0 1 1 1 2 (as we have 1,2,3 as available coins, it requires 0 coins to change 0, 1 coin to change 1, 1 coin to change 2, 1 coin to change 3 and 2 coins to change 4)\nbut it is giving 0 1 2 2 2\n\nhere's the code: \n\n```\nimport java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.math.*;\nimport java.util.regex.*;\n\npublic class Solution {\n\n    public static void main(String[] args) {\n        Scanner in= new Scanner(System.in);\n        int ch = in.nextInt();\n        int noc = in.nextInt();\n        int[] ca = new int[noc];\n        for(int i=0;i<noc;i++)\n            {\n                //taking input for coins available say a,b,c\n            ca[i] = in.nextInt();\n        }\n\n       int[] fin = new int[ch+1]; //creating an array for 0 to change                                store the minimum number of coins required for each term at index\n\n        int b=ch+1;\n        for(int i=0;i<b;i++)\n            {\n            int count = i; //This initializes the min coins to that number so it is never greater than that number itself. (but I have a doubt here: what if we don't have 1 in coins available \n\n            for(int j=0; j<noc; j++)\n                {\n                int c = ca[j]; //this takes the value of coins available from starting everytime i changes\n\n                if((c < i) && (fin[i-c] +1 < count)) // as we using dynamic programming it starts from base case, so the best value for each number i is stored in fin[] , when we check for number i+1, it checks best case for the previous numbers.\n                    count = fin[i-c]+1 ;\n\n            }\n            fin[i]= count;\n        }\n\n\n        for(int i=0;i<b;i++)\n            {\n            System.out.println(fin[i]);\n        }\n\n    }\n}\n```\n\n\nI've taken reference from this page : http://interactivepython.org/runestone/static/pythonds/Recursion/DynamicProgramming.html\n\nCan anyone help?\n    ", "Answer": "\r\nThe article you cited, explain well how to build a coin changer algorithm using dynamic programming. The python version of the algorithm can be translated in Java:\n\n```\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class CoinChanger {\n\n    public int[] dpMakeChange(List<Integer> coinValueList, int change, int[] minCoins) {\n        for (int cents = 0; cents <= change; cents++) {\n            int coinCount = cents;\n            for (Integer c : coinValueList) {\n                if (c > cents) {\n                    continue;\n                }\n                if (minCoins[cents - c] + 1 < coinCount) {\n                    coinCount = minCoins[cents - c] + 1;\n                }\n            }\n            minCoins[cents] = coinCount;\n        }\n        return minCoins;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> coinValueList = Arrays.asList(new Integer[]{1, 2, 3});\n        int change = 10;\n        int[] minCoins = new int[change + 1];\n        int[] result = (new CoinChanger()).dpMakeChange(coinValueList, change, minCoins);\n        for (int i = 0; i < result.length; i++) {\n            System.out.println(\"For change = \" + i + \" number of coins = \" + result[i]);\n        }\n    }\n}\n```\n\n\nUsing coins of value 1, 2 and 3, as in your question, the previous algorithm gives you the right values:\n\n```\nFor change = 0 number of coins = 0\nFor change = 1 number of coins = 1\nFor change = 2 number of coins = 1\nFor change = 3 number of coins = 1\nFor change = 4 number of coins = 2\nFor change = 5 number of coins = 2\nFor change = 6 number of coins = 2\nFor change = 7 number of coins = 3\nFor change = 8 number of coins = 3\nFor change = 9 number of coins = 3\nFor change = 10 number of coins = 4\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Scala: dynamic programming recursion using iterators\r\n                \r\nLearning how to do dynamic programming in Scala, and I'm often finding myself in a situation where I want to recursively proceed over an array (or some other iterable) of items. When I do this, I tend to write cumbersome functions like this: \n\n```\ndef arraySum(array: Array[Int], index: Int, accumulator: Int): Int => {\n  if (index == array.length) {\n    accumulator\n  } else {\n    arraySum(array, index + 1, accumulator + array(index)\n  }\n}\narraySum(Array(1,2,3), 0, 0)\n```\n\n\n(Ignore for a moment that I could just call ```\nsum```\n on the array or do a ```\n.reduce(_ + _)```\n, I'm trying to learn programming principles.)\n\nBut this seems like I'm passing alot of variables, and what exactly is the point of passing the array to each function call? This seems unclean. \n\nSo instead I got the idea to do this with iterators and not worry about passing indexes: \n\n```\ndef arraySum(iter: Iterator[Int])(implicit accumulator: Int = 0): Int = {\n  try {\n    val nextInt = iter.next()\n    arraySum(iter)(accumulator + nextInt)\n  } catch {\n    case nee: NoSuchElementException => accumulator\n  }\n}\narraySum(Array(1,2,3).toIterator)\n```\n\n\nThis seems like a much cleaner solution. However, this falls apart when you need to use dynamic programming to explore some outcome space and you don't need to call the iterator at every function call. E.g.\n\n```\ndef explore(iter: Iterator[Int])(implicit accumulator: Int = 0): Int = {\n  if (someCase) {\n    explore(iter)(accumulator)\n  } else if (someOtherCase){\n    val nextInt = iter.next()\n    explore(iter)(accumulator + nextInt)\n  } else {\n    // Some kind of aggregation/selection of explore results\n  }\n}\n```\n\n\nMy understanding is that the ```\niter```\n iterator here functions as pass by reference, so when this function calls ```\niter.next()```\n that changes the instance of iter that is passed to all other recursive calls of the function. So to get around that, now I'm cloning the iterator at every call of the ```\nexplore```\n function. E.g.:\n\n```\ndef explore(iter: Iterator[Int])(implicit accumulator: Int = 0): Int = {\n  if (someCase) {\n    explore(iter)(accumulator)\n  } else if (someOtherCase){\n    val iterClone = iter.toList.toIterator\n    explore(iterClone)(accumulator + iterClone.next())\n  } else {\n    // Some kind of aggregation/selection of explore results\n  }\n}\n```\n\n\nBut this seems pretty stupid, and the stupidity escalates when I have multiple iterators that may or may not need cloning in multiple ```\nelse if```\n cases. What is the right way to handle situations like this? How can I elegantly solve these kinds of problems?\n    ", "Answer": "\r\nSuppose that you want to write a back-tracking recursive function that needs some complex data structure as an argument, so that the recursive calls receive a slightly modified version of the data structure. You have several options how you could do it:\n\n\nClone the entire data structure, modify it, pass it to recursive call. This is very simple, but usually very expensive.\nModify the mutable structure in-place, pass it to the recursive call, then revert the modification when backtracking. You have to ensure that every possible call of your recursive function always restores the original state of the data structure exactly. This is much more efficient, but is hard to implement, because it can be very error prone.\nSubdivide the structure into a large immutable and a small mutable part. For example, you could pass an index (or a pair of indices) that specify some slice of an array explicitly, along with an array that is never mutated. You could then \"clone\" and save only the mutable part, and restore it when backtracking. If it works, it is both simple and fast, but it doesn't always work, because substructures can be hard to describe by just few integer indices.\nRely on persistent immutable data structures whenever you can.\n\n\nI'd like to elaborate on the last point, because this is the preferred way to do it in Scala and in functional programming in general.\n\nHere is your original code, that uses the third strategy:\n\n```\ndef arraySum(array: Array[Int], index: Int, accumulator: Int): Int = {\n  if (index == array.length) {\n    accumulator\n  } else {\n    arraySum(array, index + 1, accumulator + array(index))\n  }\n}\n```\n\n\nIf you would use a ```\nList```\n instead of an ```\nArray```\n, you could rewrite it to this:\n\n```\n@annotation.tailrec\ndef listSum(list: List[Int], acc: Int): Int = list match {\n  case Nil => acc\n  case h :: t => listSum(t, acc + h)\n}\n```\n\n\nHere, ```\nh :: t```\n is a pattern that deconstructs the list into the ```\nhead```\n and the ```\ntail```\n.\nNote that you don't need an explicit index any more, because accessing the tail ```\nt```\n of the list is a constant-time operation, so that only the relevant remaining sublist is passed to the recursive call of ```\nlistSum```\n.\n\nThere is no backtracking here, but if the recursive method would backtrack, using lists would bring another advantage: extracting a sublist is almost free (constant time operation), but it's still guaranteed to be immutable, so you can just pass it into the recursive call, without having to care about whether the recursive call modifies it or not, and so you don't have to do anything to undo any modifications that could have been done by the recursive calls. This is the advantage of persistent immutable data structures: related lists can share most of their structure, while still appearing immutable from the outside, so that it's impossible to break anything in the parent list just because you have the access to the tail of this list. This would not be the case with a view over a mutable array.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Word segmentation using dynamic programming\r\n                \r\nSo first off I'm very new to Python so if I'm doing something awful I'm prefacing this post with a sorry. I've been assigned this problem:\n\nWe want to devise a dynamic programming solution to the following problem: there is a string of characters which might have been a sequence of words with all the spaces removed, and we want to find a way, if any, in which to insert spaces that separate valid English words. For example, theyouthevent could be from “the you the vent”, “the youth event” or “they out he vent”. If the input is theeaglehaslande, then there’s no such way. Your task is to implement a dynamic programming solution in two separate ways:\n\n\niterative bottom-up version  \nrecursive memorized version\n\n\nAssume that the original sequence of words had no other punctuation (such as periods), no capital letters, and no proper names - all the words will be available in a dictionary file that will be provided to you.\n\nSo I'm having two main issues:\n\n\nI know that this can and should be done in O(N^2) and I don't think mine is\nThe lookup table isn't adding all the words it seems such that it can reduce the time complexity\n\n\nWhat I'd like:\n\n\nAny kind of input (better way to do it, something you see wrong in the code, how I can get the lookup table working, how to use the table of booleans to build a sequence of valid words)\nSome idea on how to tackle the recursive version although I feel once I am able to solve the iterative solution I will be able to engineer the recursive one from it.\n\n\nAs always thanks for any time and or effort anyone gives this, it is always appreciated.\n\nHere's my attempt:\n\n```\n#dictionary function returns True if word is found in dictionary false otherwise\ndef dictW(s):\n    diction = open(\"diction10k.txt\",'r') \n    for x in diction:\n        x = x.strip(\"\\n \\r\")\n        if s == x:\n            return True\n    return False\n\ndef iterativeSplit(s):\n    n = len(s)\n    i = j = k = 0\n    A = [-1] * n\n    word = [\"\"] * n\n    booly = False\n    for i in range(0, n):\n        for j in range(0, i+1):\n            prefix = s[j:i+1]\n            for k in range(0, n):\n\n                if word[k] == prefix:\n                    #booly = True\n                    A[k] = 1\n                    #print \"Array below at index k %d and word = %s\"%(k,word[k])\n                    #print A\n            # print prefix, A[i]\n            if(((A[i] == -1) or (A[i] == 0))):\n                if (dictW(prefix)):\n                    A[i] = 1\n                    word[i] = prefix\n                    #print word[i], i\n                else:\n                    A[i] = 0\n    for i in range(0, n):\n        print A[i]\n```\n\n    ", "Answer": "\r\nFor another real-world example of how to do English word segmentation, look at the source of the Python wordsegment module. It's a little more sophisticated because it uses word and phrase frequency tables but it illustrates the memoization approach.\n\nIn particular, ```\nsegment```\n illustrates the memoization approach:\n\n```\ndef segment(text):\n    \"Return a list of words that is the best segmenation of `text`.\"\n\n    memo = dict()\n\n    def search(text, prev='<s>'):\n        if text == '':\n            return 0.0, []\n\n        def candidates():\n            for prefix, suffix in divide(text):\n                prefix_score = log10(score(prefix, prev))\n\n                pair = (suffix, prefix)\n                if pair not in memo:\n                    memo[pair] = search(suffix, prefix)\n                suffix_score, suffix_words = memo[pair]\n\n                yield (prefix_score + suffix_score, [prefix] + suffix_words)\n\n        return max(candidates())\n\n    result_score, result_words = search(clean(text))\n\n    return result_words\n```\n\n\nIf you replaced the ```\nscore```\n function so that it returned \"1\" for a word in your dictionary and \"0\" if not then you would simply enumerate all positively scored candidates for your answer.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "More Efficient Dynamic Programming of Product Sales\r\n                \r\nI'm working on a dynamic programming problem and the problem requires selling a product over T time periods and maximizing the total actual sale amount. The total number of products is N and I plan to sell some products over different periods n0,n1,⋯,nT−1 and ∑ni=N. But the actual sale amount Si and sale price Pi are based on the below formulas.\nAssume that α=0.001 and π=0.5\n\nInitialize P=0. Then for i=0,1,…,T−1\nCompute new Pi=⌈0.5∗(Pi+ni)⌉\nAt time i we sell Si = ⌈(1−αP^π)*ni⌉ products\n\nFor example, assume we already know $n_i$ for all periods, the trading will be below\n```\n    P = 0\n    T = 4\n    N = 10000\n    alpha = 1e-3\n    pi = 0.5\n    S = np.zeros(T,dtype='i')\n    n  = np.array([5000,1000,2000,2000])\n    print(n)\n    total = 0\n    for i in range(T):\n        P = math.ceil(0.5*(P + n[i]))\n        S[i] = math.ceil((1 - alpha*P**pi)*n[i])\n        total += S[i]\n        print('at time %d, M = %d and we trade %d shares' %(i,M,S[i]))\n    print('total sold =', total)\n```\n\nMy idea is that this problem is dealing with quantity instead of price. Therefore, we should focus on something related to quantity, such as the moving average of the quantity. I'm still considering how to program it. Could someone provide ideas about dynamic programming? Thank you very much.\nThe below is some of my crude codes.\n```\ndef DPcrude(N,T,alpha,pi,S):\n    for k in range(1, T):\n        t = T - k - 1\n        for n in range(0,N+1):\n            best = -1\n\n            for sell in range(0,n):\n                newprice = \n                salenow = \n                salelater = \n                candidate = salenow + salelater\n                if candidate > best:\n                    best = candidate\n            S[t,a,n] = best\n```\n\n```\nN = 1000\nT = 10\npi = .5\nalpha = 1e-2\n```\n\n    ", "Answer": "\r\nYour current method has complexity O(N^T).  Dynamic programming can be used to reduce this to O(T.N^3) which should be more efficient for values of T of 4 and higher.\nNote that the problem has the following properties:\n\nA higher price results in fewer sales\nA higher price at a particular time results in higher prices later (if the same subsequent choices for ni are made)\n\nThis means that you can solve with dynamic programming the subproblem of what is the lowest price that can be achieved for each number of sales:\n\nwith exactly t time periods\nwith the ni for the t time periods summing to n\n\nTo compute this subproblem requires looping over the choices for the number in the final time period, and combining choices from previous subproblems.\nNote that solving the subproblem gives an array of up to N results, where entry k in the array gives the lowest price for getting exactly k sales.\nThere are O(T.N) subproblems, and each subproblem requires O(N^2) to solve for a total complexity of O(T.N^3).\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Heap corruption on dynamic programming problem\r\n                \r\nI'm getting an heap corruption error and I can't figure out where it is.\nThe problem is a coin change problem using dynamic programming. C is the array with the coin values, n is the size of the array, T is the target change, usedCoins is an array where the number of used coins should be mapped (i.e if C[1] = 2 and 3 2-coins are used, usedCoins[2] = 2 with all other indexes to 0.\nHere's the code:\n```\nbool changeMakingUnlimitedDP(unsigned int C[], unsigned int n, unsigned int T, unsigned int usedCoins[]) {\n\nstatic auto minCoins = new unsigned int[T+1]{UINT_MAX};\nminCoins[0] = 0;\nstatic auto lastCoin = new unsigned int[T+1]{0};\n\nfor(int i = 0; i < n; i++)\n    usedCoins[i] = 0;\n\nfor(int i = 0; i < n; i++){\n    for(int j = 1; j <= T; j++){\n        if(j >= C[i]){\n            minCoins[j-C[i]] == 0? minCoins[j] = 1 : minCoins[j] = std::min(1 + minCoins[j - C[i]], minCoins[j-C[i]]);\n            lastCoin[j] = i;\n        }\n    }\n}\n\nwhile(T > 0){\n    unsigned int last = lastCoin[T];\n    if(last == UINT_MAX || last < 0) return false;\n    usedCoins[last]++;\n    T -= C[last];\n}\n\nfree(minCoins);\nfree(lastCoin);\n\nreturn true;\n```\n\n}\nWhen running on debug mode it goes through.\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Javascript: Equality Function using Dynamic Programming?\r\n                \r\nI want to implement an equality function in JavaScript using dynamic programming.\n\nThis is what i have come up with.\n\n```\nfunction isEqualFunction(args: any): boolean {\n    // Here a1 and a2 are two objects to be compared(they cannot be lists)\n    // a1a2CombinedKeys is an object that combines keys of a1 and a2,\n    // comparisonArgs is an object that needs to be passed to each comparison function for \n    // nested objects in a1 and a2,\n    // nestedArrayOrObjCompareFunc is an object which contains comparison function for each \n    // nested object in a1 or a2.\n    const { a1, a2, a1a2CombinedKeys, comparisonArgs, nestedArrayOrObjCompareFunc, } = args;\n    return Object.keys(a1a2CombinedKeys).every((objKey) => {\n        const a1Value = a1[objKey], a2Value = a2[objKey];\n        if (a1Value && a2Value) {\n            if (Array.isArray(a1Value)) {\n                const { isPropEqualFunction } = nestedArrayOrObjCompareFunc[objKey];\n                const { a1a2NestedKeys, nestedObjComparFunc: listItemObjComparFunc } = isPropEqualFunction(comparisonArgs);\n                return a1Value.every((a1ObjListItem) => a2Value.find((a2ObjListItem) => isEqualFunction({\n                    a1: a1ObjListItem, a2: a2ObjListItem, comparisonArgs,\n                    a1a2CombinedKeys: a1a2NestedKeys, nestedArrayOrObjCompareFunc: listItemObjComparFunc,\n                })))\n            } else if (typeof a1Value === 'object') {\n                const { isPropEqualFunction } = nestedArrayOrObjCompareFunc[objKey];\n                const { a1a2NestedKeys, nestedObjComparFunc: nestedObjComparFunc } = isPropEqualFunction(comparisonArgs);\n                return isEqualFunction({\n                    a1: a1Value, a2: a2Value, comparisonArgs,\n                    a1a2CombinedKeys: a1a2NestedKeys, nestedArrayOrObjCompareFunc: nestedObjComparFunc,\n                })\n            } else {\n                return a1Value === a2Value\n            }\n        } else if (!a1Value && !a2Value) {\n            return true;\n        } else {\n            return false;\n        }\n    });\n}\n```\n\n\nI cannot compare the hash of two objects as some of the nested elements have an id prop.\n\nI am not sure if this is foolproof, but it seems good to me.\n\nAlso, I am struggling to create a typescript definition for the same. Any help on that front would also be highly appreciated.\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming: Counting numbers in between\r\n                \r\nGiven two numbers ```\nX```\n and ```\nY```\n, how many numbers exist between them inclusive that have at least half their digits the same? For example, ```\n1122```\n and ```\n4444```\n would work, while ```\n11234```\n and ```\n112233```\n would not work. \n\nObviously, the most straightforward way is to start at ```\nX```\n and increment by 1 all the way to ```\nY```\n, and then check each number, but that is way too slow, as the boundaries for ```\nX```\n and ```\nY```\n are between ```\n100```\n and ```\n10^18```\n. I know that it is some form of dynamic programming, and that I should use strings to represent the numbers, but I can't get much further. \n\nAny help would be accepted. Thanks!\n    ", "Answer": "\r\nI will explain you in some steps:\n\nFirst step:\n\nFor solving this kind of range problems between ```\nX```\n and ```\nY```\n always make it simple by counting between ```\n0 to X```\n and ```\n0 to Y-1```\n, then subtract the result. i.e. if you have a function like ```\nf(N)```\n that calculates the numbers that have at least half their digits the same between 0 and N, then your final result is:\n\n```\nf(X) - f(Y-1)\n```\n\n\nSecond step:\n\nNext we have to compute f(N). We split this function into 2 sub functions, one for calculating the result for numbers having the same number of digits with N (lets call it f_equal), and the other for counting the qualified numbers having digits less the N (let's call it f_less). E.g. if N is 19354, we count the qualified numbers between 0 to 9999, then in another method count the favorite numbers between 10000 to 19354, after that we sum up the result. Next, I'll explain you how to implement these two methods.\n\nThird step:\n\nHere, we want to compute f_less method. you can do it by some math, but I always prefer to write a simple DP for solving these tasks. I will write the recursive function whether you can use memoization or you can make it bottom-up with some loops (I'll leave it as a practice for you).\n\n```\nlong long f_less(int curDigit, int favNum, int favNumCountSoFar, int nonFavNum, int nonFavNumCountSoFar, int maxDigit){\n    if(curDigit == maxDigit ){\n        //for numbers with even maxDigit there may be a case when we have 2 favorite numbers\n        //and we should count them only once. like 522552\n        if(favNumCountSoFar*2 == maxDigit && favNumCountSoFar == nonFavNumCountSoFar) return 1;\n        if(2*favNumCountSoFar >= maxDigit) return 2;\n        return 0;\n    }\n    long long res = 0;\n    for(int i=(curDigit==0?1:0);i<=9;++i) //skip the leading zero\n        if(i==favNum)\n            res += f_less(curDigit+1, favNum, favNumCountSoFar + 1, nonFavNum, nonFavNumCountSoFar,maxDigit);\n        else\n            res += f_less(curDigit+1, favNum, favNumCountSoFar, i, (i==nonFavNum?nonFavNumCountSoFar+1:1),maxDigit);\n    return res;\n}\n```\n\n\nAnd call it for all numbers through 0 to 9:\n\n```\nlong long res = 0;\nfor(int maxDigit = 1; maxDigit < NUMBER_OF_DIGITS(N); ++maxDigit)\n    for(int favNumber = 0; favNumber < 10; ++favNumber)\n        res += f_less(0, favNumber, 0, -1, 0, maxDigit);\n```\n\n\nFourth Step:\n\nFinally we have to compute f_equal. Here we have to keep the number in a string to always check whether we are still in the range below N or not in the recursive function. Here is the implementation of f_equal (again use memoization or make it bottom-up):\n\n```\nstring s = NUM_TO_STRING(N);\nint maxDigit = s.size();\nlong long f_equal(int curDigit, int favNum, int favNumCountSoFar,int nonFavNum, int nonFavNumCountSoFar, bool isEqual){ //isEqual checks that whether our number is equal to N or it's lesser than it \n    if(curDigit == maxDigit ){\n        //for numbers with even maxDigit there may be a case when we have 2 favorite numbers\n        //and we should count them only once. like 522552\n        if(favNumCountSoFar*2 == maxDigit && favNumCountSoFar == nonFavNumCountSoFar) return 1;\n        if(2*favNumCountSoFar >= maxDigit) return 2;\n        return 0;\n    }\n    long long res = 0;\n    for(int i=(curDigit==0?1:0);i<=9;++i){ //skip the leading zero\n        if(isEqual && i>(s[curDigit]-'0')) break;\n        if(i==favNum)\n            res += f_equal(curDigit+1, favNum, favNumCountSoFar + 1, nonFavNum, nonFavNumCountSoFar, isEqual && (i==(s[curDigit]-'0')));\n        else\n            res += f_equal(curDigit+1, favNum, favNumCountSoFar, i, (i==nonFavNum?nonFavNumCountSoFar+1:1), isEqual && (i==(s[curDigit]-'0')));\n    } \n    return res;\n}\n```\n\n\nAnd call it:\n\n```\nlong long res = 0;\nfor(int favNumber = 0; favNumber < 10; ++favNumber)\n    res += f_equal(0, favNumber,0, -1, 0, true);\n```\n\n\nThe final result is ```\nres/2```\n. The code is tested and works well.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "How do I use Dynamic Programming to solve Knapsack\r\n                \r\nI'm working on algorithms the classic Knapsack Problem (for MIT 6.002x) and also trying to get my head around Dynamic Programming. \n\nThe course doesn't cover DP, but asked me to go look it up. Which I have done but am none the wiser. Am finding it hard to relate to any of the tutorials / videos because they're mostly about solving other algorithms. And because I'm a bit fuzzy on DP to begin with they're not really helping. \n\nCan anybody point me to a place that explains Dynamic Programming and how it is used to solve the Knapsack problem\n    ", "Answer": "\r\nyou can learn basics of dynamic programming and understand how knapsack problem can be solved using link below.\nhttp://www.geeksforgeeks.org/dynamic-programming-set-10-0-1-knapsack-problem/\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming - mobile\r\n                \r\nI have to apply dynamic programming on this problem, but I am not really sure how.\n\nThere are 50 buttons with 2000 letters on the mobile phone (sorted alphabetically). Each letter has k-position at the button (letter is typed by k presses). Then we know, how much is the letter used. Program will determine, on which button the letter should be positioned in order to find out minimum number of presses.\n\nInput:\n\nnumber of buttons\n\nnumber of letters\n\nfrequency of each character in average letter.\nExample:\n\n```\n3 // number of buttons\n\n5 // number of letters\n\n1 // frequency of first letter\n\n1 // frequency of second letter\n\n1 // frequency of third letter\n\n1 // frequency of fourth letter\n\n1 // frequency of fifth letter\n```\n\n\nSolution:\n\nButtons: 1 2 | 3 4 | 5\n\n1 * 1 + 2 * 1 = 3\n\n1 * 1 + 2 * 1 = 3\n\n1 * 1 = 1\nOutput is: 3 + 3 + 1 = 7\n\nProgram will output: 7\n\nI have made solution to this example. I've created two matrices. One has SS dimension and the other one has KS dimension. In SS matrix each element represent price of the button, which has characters from i coordinate to j coordinate. In KS matrix i represents number of buttons and j represents characters to j.\n\nI have a problem, how to find buttons with minimul cost.\n\nFor example:\n\nI want to find in KS table value in [2,3] coordinate. It means, we are spliting three characters in to two buttons. Optimal solution is, that one button will have 2 characters and other one will have one character. In SS solution would be [1,1] + [2,3] or [1,2] + [3,3].\n\nI will appreciate every advice.\n\ntable S*S\n\n```\n1 3 6 10 15\n\n0 1 3 6 10\n\n0 0 1 3 6\n\n0 0 0 1 3\n\n0 0 0 0 1\n```\n\n\ntable K*S\n\n```\n1 3 6 10 15\n\n0 2 4 6 9\n\n0 0 3 5 7\n```\n\n    ", "Answer": "\r\nYou may be familiar with the reasoning behind a Huffman Code, where for optimal usage, or highest efficiency, the least amount of work should be done to get the highest frequency letters. This logic holds for your problem as well. You want to perform the least amount of button presses to reach the highest frequency letters.\n\nLet's say we have ```\nnumB buttons```\n and ```\nnumL letters```\n. Let's also assume we have an object called Letter with ```\nchar letter```\n, and ```\nint frequency```\n attributes, and finally, we have ```\nLetterCol```\n which is a collection of Letter objects. (My c# is rusty, bear with me).\n\nStep 1:\nSort these letters by frequency.(Any sort function will work). We will use a collection of arraylists of Letters ```\nKeypad```\n. It will function like a map. \n\nEach position in ```\nKeypad```\n will be an arraylist. Each position will relate to one button. ```\nKeypad[0]```\n relates to ```\nbutton 0```\n. ```\nKeypad[0]```\n is also an ArrayList of letters. This will be populated with the letters we wish to place on ```\nbutton 0```\n. \n\n```\nList<ArrayList<Letter>> Keypad = new ArrayList<>();\n```\n\n\nStep 2:\nSince ```\nLetterCol```\n is sorted by frequency, we just place each letter sequentially on ```\nKeypad```\n. We will use the ```\nmod```\n function ```\n%```\n to ensure we stay within our bounds (i.e., we don't exceed the number of buttons ```\nnumB```\n).\n\n```\nfor(int i = 0; i < numL; i++)\n   Keypad[i%numB].add(LetterCol[i]);\n```\n\n\nNow, our placement process is complete. Each letter is placed in it's optimal position. It is time to calculate the output.\n\nStep 3:\nWe now need to access each position in ```\nKeypad```\n and retrieve each letter in those ArrayLists.\n\n```\nint output = 0;\nfor(int i = 0; i < numB; i++)\n   for(int j = 0; j < Keypad[i].count; j++){\n      output += (j+1)*(Keypad[i][j].frequency);\n```\n\n\n//My syntax may be incorrect, in Java it is: output += (j+1)*(Keypad[i].get[j].frequency);\n\nNow we contain the optimal ```\noutput```\n. In your numbers example, you go to each button and multiply the number of presses to the frequency of the letter. These for loops perform the same calculation. We go to each button ```\ni```\n, multiply the number of presses ```\nj+1```\n to the frequency of the letter ```\nKeypad[i][j].frequency```\n.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Solving dynamic programming problems using functional programming\r\n                \r\nAfter you get a basic idea, coding dynamic programming (DP) problems in imperative style is pretty straightforward, at least for simpler DP problems. It usually involves some form of table, that we iteratively fill based on some formula. This is pretty much all there is for implementing bottom-up DP.\n\nLet's take Longest Increasing Subsequence (LIS) as a simple and common example of a problem that can be solved with bottom-up DP algorithm.\n\nC++ implementation is straightforward (not tested):\n\n```\n// Where A is input (std::vector<int> of size n)\nstd::vector<int> DP(n, 0);\nfor(int i = 0; i < n; i++) {\n    DP[i] = 1;\n    for(int j = 0; j < i; j++) {\n        if (A[i] > A[j]) {\n            DP[i] = std::max(DP[i], DP[j] + 1);\n        }\n    }\n}\n```\n\n\nWe've just described \"how to fill DP\" which is exactly what imperative programming is.\n\nIf we decide to describe \"what DP is\", which is kind of a more FP way to think about it, it gets a bit more complicated. \nHere's an example Scala code for this problem:\n\n```\n// Where A is input\nval DP = A.zipWithIndex.foldLeft(Seq[Int]()) {\n    case (_, (_, 0)) => Seq(1)\n    case (d, (a, _)) =>\n      d :+ d.zipWithIndex.map { case (dj, j) =>\n        dj + (if (a > A(j)) 1 else 0)\n      }.max\n}\n```\n\n\nTo be quite honest, this Scala implementation doesn't seem that much idiomatic. It's just a translation of imperative solution, with immutability added to it.\n\nI'm curious, what is a general FP way to deal with things like this?\n    ", "Answer": "\r\nI don't know much about DP but I have a few observations that I hope will contribute to the conversation.\n\nFirst, your example Scala code doesn't appear to solve the LIS problem. I plugged in the Van der Corput sequence as found on the Wikipedia page and did not get the designated result.\n\nWorking through the problem this is the solution I came up with.\n\n```\ndef lis(a: Seq[Int], acc: Seq[Int] = Seq.empty[Int]): Int =\n  if      (a.isEmpty)         acc.length\n  else if (acc.isEmpty)       lis(a.tail, Seq(a.head))   max lis(a.tail)\n  else if (a.head > acc.last) lis(a.tail, acc :+ a.head) max lis(a.tail, acc)\n  else                        lis(a.tail, acc)\n\nlis(Seq(0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15)) // res0: Int = 6\n```\n\n\nThis can be adjusted to return the subsequence itself, and I'm sure it can be tweaked for better performance.\n\nAs for memoization, it's not hard to roll-your-own on an as-needed basis. Here's the basic outline to memoize any arity-2 function.\n\n```\ndef memo[A,B,R](f: (A,B)=>R): ((A,B)=>R) = {\n  val cache = new collection.mutable.WeakHashMap[(A,B),R]\n  (a:A,b:B) => cache.getOrElseUpdate((a,b),f(a,b))\n}\n```\n\n\nWith this I can create a memoized version of some often called method/function.\n\n```\nval myfunc = memo{(s:String, i:Int) => s.length > i}\nmyfunc(\"bsxxlakjs\",7)  // res0: Boolean = true\n```\n\n\nNote: It used to be that ```\nWeakHashMap```\n was recommended so that the cache could drop lesser used elements in memory-challenged environments. I don't know if  that's still the case.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming - Counting paths in a subway system\r\n                \r\nI have a network of stations in a subway system. The number of stations, the number of tickets I can travel between stations with, and which stations are connected to each other are given in a text file as input to the program. Which stations are connected to each other are kept in a 2D boolean matrix. I have to find the number of paths from station 0 and back to 0 that uses all of the tickets.\n\nHere is one of the examples:\n\n\n\nIn that example, there are 7 stations and 5 tickets.\nStarting and returning to 0, there are 6 paths:\n\n```\n0-1-2-3-4-0\n0-1-5-3-4-0\n0-1-6-3-4-0\n0-4-3-6-1-0\n0-4-3-5-1-0\n0-4-3-2-1-0\n```\n\n\nI currently have a recursive solution to this that runs in O(N^k) (N represents the number of stations while k is the number of tickets), but I have to convert it to an iterative, dynamic programming solution in O(k*N^2) that works on any input. \n\n```\n#include <algorithm>\n#include <fstream>\n#include <iostream>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\n\n// We will represent our subway as a graph using\n// an adjacency matrix to indicate which stations are\n// adjacent to which other stations.\nstruct Subway {\n  bool** connected;\n  int nStations;\n\n  Subway (int N);\n\nprivate:\n  // No copying allowed\n  Subway (const Subway&) {}\n  void operator= (const Subway&) {}\n};\n\n\nSubway::Subway(int N)\n{\n  nStations = N;\n  connected = new bool*[N];\n  for (int i = 0; i < N; ++i)\n    {\n      connected[i] = new bool[N];\n      fill_n (connected[i], N, false);\n    }\n}\n\nunsigned long long int callCounter = 0;\nvoid report (int dest, int k)\n{\n  ++callCounter;\n  // Uncomment the following statement if you want to get a feel \n  // for how many times the same subproblems get revisited\n  // during the recursive solution.\n  cerr << callCounter << \": (\" << dest << \",\" << k << \")\" << endl;\n}\n\n\n/**\n * Count the number of ways we can go from station 0 to station destination\n * traversing exactly nSteps edges.\n */\nunsigned long long int tripCounter (const Subway& subway, int destination, int nSteps)\n{\n    report (destination, nSteps);\n    if (nSteps == 1)\n    {\n        // Base case: We can do this in 1 step if destination is\n        // directly connected to 0.\n        if (subway.connected[0][destination]){\n            return 1;\n        }\n        else{\n            return 0;\n        }\n    }\n    else\n    {\n        // General case: We can get to destinaiton in nSteps steps if\n        // we can get to station S in (nSteps-1) steps and if S connects\n        // to destination.\n        unsigned long long int totalTrips = 0;\n        for (int S = 0; S < subway.nStations; ++S)\n        {\n            if (subway.connected[S][destination])\n            {\n                // Recursive call\n                totalTrips += tripCounter (subway, S, nSteps-1);\n            }\n        }\n        return totalTrips;\n    }\n}\n\n// Read the subway description and\n// print the number of possible trips.\nvoid solve (istream& input)\n{\n  int N, k;\n  input >> N >> k;\n  Subway subway(N);\n  int station1, station2;\n  while (input >> station1)\n    {\n      input >> station2;\n      subway.connected[station1][station2] = true;\n      subway.connected[station2][station1] = true;\n    }\n  cout << tripCounter(subway, 0, k) << endl;\n  // For illustrative/debugging purposes\n  cerr << \"Recursive calls: \" << callCounter << endl;\n}\n\n\n\n\nint main (int argc, char** argv)\n{\n  if (argc > 1) \n    {\n      ifstream in (argv[1]);\n      solve (in);\n    }\n  else\n    {\n      solve (cin);\n    }\n  return 0;\n}\n```\n\n\nI'm not looking for a solution. I am currently out of ideas and hoping someone can point me in the right direction. Since I'm required to implement a bottom-up approach for this, how would I start with developing a dynamic programming table using the smallest sub-problems?\n    ", "Answer": "\r\nYou should construct an array ```\nT```\n that for each step ```\nT[i]```\n tells \"how many paths are there between 0 and i\".\n\nFor 0 steps, this array is:\n\n```\n[1, 0, 0, ... 0]```\n\n\nThen, for each step, do:\n\n```\nT_new[i] = sum{0<=j<n}(T[j] if there is an edge (i, j))```\n\n\nAfter ```\nk```\n of those steps, ```\nT[0]```\n will be the answer.\n\nHere's a simple Python implementation to illustrate:\n\n```\ndef solve(G, k):\n    n = len(G)\n\n    T = [0]*n\n    T[0] = 1\n\n    for i in xrange(k):\n        T_new = [\n            sum(T[j] for j in xrange(n) if G[i][j]) \n            for i in xrange(n)\n        ]\n        T = T_new\n\n    return T[0]\n\nG = [\n     [0, 1, 0, 0, 1, 0, 0],\n     [1, 0, 1, 0, 0, 1, 1],\n     [0, 1, 0, 1, 0, 0, 0],\n     [0, 0, 1, 0, 1, 1, 1],\n     [1, 0, 0, 1, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0, 0]\n]\n\nprint solve(G, 5) #6\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Solving Dynamic Programming for Travelling Salesman Problem - Java\r\n                \r\nI want to implement a dynamic programming solution for travelling salesman problem. I have managed to solve it with the code below:\n`package tsp;\nimport java.util.Arrays;\nimport java.util.Collections;\npublic class TSP {\nstatic int l ;\npublic static void main(String[] args) {\n```\n    // sample input\n    int[][] w = {{0,3,5,48,48,8,8,5,5,3,3,0,3,5,8,8,5},\n                 {3,0,3,48,48,8,8,5,5,0,0,3,0,3,8,8,5},\n                 {5,3,0,72,72,48,48,24,24,3,3,5,3,0,48,48,24},\n                 {48,48,74,0,0,6,6,12,12,48,48,48,48,74,6,6,12},\n            {48,48,74,0,0,6,6,12,12,48,48,48,48,74,6,6,12},\n            {8,8,50,6,6,0,0,8,8,8,8,8,8,50,0,0,8},\n            {8,8,50,6,6,0,0,8,8,8,8,8,8,50,0,0,8},\n            {5,5,26,12,12,8,8,0,0,5,5,5,5,26,8,8,0},\n            {5,5,26,12,12,8,8,0,0,5,5,5,5,26,8,8,0},\n            {3,0,3,48,48,8,8,5,5,0,0,3,0,3,8,8,5},\n            {3,0,3,48,48,8,8,5,5,0,0,3,0,3,8,8,5},\n            {0,3,5,48,48,8,8,5,5,3,3,0,3,5,8,8,5},\n            {3,0,3,48,48,8,8,5,5,0,0,3,0,3,8,8,5},\n            {5,3,0,72,72,48,48,24,24,3,3,5,3,0,48,48,24},\n            {8,8,50,6,6,0,0,8,8,8,8,8,8,50,0,0,8},\n            {8,8,50,6,6,0,0,8,8,8,8,8,8,50,0,0,8},\n            {5,5,26,12,12,8,8,0,0,5,5,5,5,26,8,8,0}};\n    \n    int n = w[0].length;\n    int k = (int) Math.pow(2, (n - 1));\n     int[][] p =new int[n][k];\n     \n     //ptint shortest cylce's  length\n    System.out.println(\"The shortest cycle is of legnth \"+ trvel(n, w, p));\n    \n    //print the shotrest cycle\n    System.out.print(\"The shortest cycle is \");\n    System.out.print(\"V0 \");\n    print_path(0,p,k-1);\n    System.out.print(\"V0 \");\n}\n\nprivate static int trvel(int n, int[][] w, int[][] p) {\n    //the number of all subsets of vertices\n    int k = (int) Math.pow(2, (n - 1));\n    \n    int[][] D = new int[n][k];\n    \n    //initializing D[A][v1]\n    for (int i = 1; i < n; i++) {\n        D[i][0] = w[i][0];\n        \n    }\n    \n    //finding the shortest path excluding v1\n    for (int i = 1; i <= n - 2; i++) {\n        for (int subset = 1; subset < k; subset++) {\n            if (len(subset) == i) {\n                for (int v = 1; v < n; v++) {\n                    if (!haveI(subset, v-1)) {\n                        D[v][subset] = min(v, w, D, subset, n);\n                        \n                        p[v][subset] = l;\n                        \n                    }\n\n                }\n            }\n        }\n    }\n    int min = min(0, w, D, k-1, n);\n    p[0][k-1] = l;\n    return min;\n}\n\n// finding the cardinality of a subset\nprivate static int len(int j) {\n    int count = 0;\n    while (j != 0) {\n        j = j & (j - 1);\n        count++;\n    }\n    return count;\n}\n\n//checking if Vi for some i belongs to a subset \nprivate static boolean haveI(int subset, int position) {\n    int num = subset & ~(1 << (position));\n    return (num & subset) != subset;\n}\n\n// finding the minimum of (W[v][j]+D[j][subsrt - v] for every j\nprivate static int min(int v, int[][] w, int[][] D, int set, int n) {\n    int[] m = new int[len(set)];\n    int []i = new int[len(set)];\n    int ind = 0;\n        for(int j = 0 ; j< n-1 ; j++)\n            if(haveI(set,j))\n            {\n                int num = set & ~(1 << (j));\n                num = set & num;\n                m[ind] = w[v][j+1]+D[j+1][num];\n                i[ind]=j+1;\n                ind++;\n            }\n        int min = m[0];\n        l = i[0];\n        for(int j = 1; j < len(set);j++)\n            if(min>m[j]){\n                min=m[j];\n                l = i[j];\n            }\n                        \n    return min;\n   \n}\n\n//printing the shortest path\nprivate static void print_path(int i, int[][] p, int n) {\n   while(n > 0 ){\n       System.out.print(\"V\"+p[i][n]+\" \");\n       i =p[i][n];\n       n = n& ~(1 << (i-1));\n   }\n}\n```\n\n}\n```\n\n`\nInstead of writing the coordintes in the code like this:\n`\n```\n\npublic static void main(String[] args) {\n```\n    // sample input\n    int[][] w = {{0,3,5,48,48,8,8,5,5,3,3,0,3,5,8,8,5},\n                 {3,0,3,48,48,8,8,5,5,0,0,3,0,3,8,8,5},\n                 {5,3,0,72,72,48,48,24,24,3,3,5,3,0,48,48,24},\n                 {48,48,74,0,0,6,6,12,12,48,48,48,48,74,6,6,12},\n            {48,48,74,0,0,6,6,12,12,48,48,48,48,74,6,6,12},\n            {8,8,50,6,6,0,0,8,8,8,8,8,8,50,0,0,8},\n            {8,8,50,6,6,0,0,8,8,8,8,8,8,50,0,0,8},\n            {5,5,26,12,12,8,8,0,0,5,5,5,5,26,8,8,0},\n            {5,5,26,12,12,8,8,0,0,5,5,5,5,26,8,8,0},\n            {3,0,3,48,48,8,8,5,5,0,0,3,0,3,8,8,5},\n            {3,0,3,48,48,8,8,5,5,0,0,3,0,3,8,8,5},\n            {0,3,5,48,48,8,8,5,5,3,3,0,3,5,8,8,5},\n            {3,0,3,48,48,8,8,5,5,0,0,3,0,3,8,8,5},\n            {5,3,0,72,72,48,48,24,24,3,3,5,3,0,48,48,24},\n            {8,8,50,6,6,0,0,8,8,8,8,8,8,50,0,0,8},\n            {8,8,50,6,6,0,0,8,8,8,8,8,8,50,0,0,8},\n            {5,5,26,12,12,8,8,0,0,5,5,5,5,26,8,8,0}};\n    \n    int n = w[0].length;\n```\n\n```\n`\nI want the coordintes to be read from a .atsp file named \"testFile.atsp\" instead of writing it in the code. The contents of the file should look like this:\n\n`17\n\n0,3,5,48,48,8,8,5,5,3,3,0,3,5,8,8,5\n3,0,3,48,48,8,8,5,5,0,0,3,0,3,8,8,5\n5,3,0,72,72,48,48,24,24,3,3,5,3,0,48,48,24\n48,48,74,0,0,6,6,12,12,48,48,48,48,74,6,6,12\n48,48,74,0,0,6,6,12,12,48,48,48,48,74,6,6,12\n8,8,50,6,6,0,0,8,8,8,8,8,8,50,0,0,8\n8,8,50,6,6,0,0,8,8,8,8,8,8,50,0,0,8\n5,5,26,12,12,8,8,0,0,5,5,5,5,26,8,8,0\n5,5,26,12,12,8,8,0,0,5,5,5,5,26,8,8,0\n3,0,3,48,48,8,8,5,5,0,0,3,0,3,8,8,5\n3,0,3,48,48,8,8,5,5,0,0,3,0,3,8,8,5\n0,3,5,48,48,8,8,5,5,3,3,0,3,5,8,8,5\n3,0,3,48,48,8,8,5,5,0,0,3,0,3,8,8,5\n5,3,0,72,72,48,48,24,24,3,3,5,3,0,48,48,24\n8,8,50,6,6,0,0,8,8,8,8,8,8,50,0,0,8\n8,8,50,6,6,0,0,8,8,8,8,8,8,50,0,0,8\n5,5,26,12,12,8,8,0,0,5,5,5,5,26,8,8,0\n`\n\n\nCan anyone show how this can be done.\n```\n\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "How do I use Dynamic Programming to solve Knapsack\r\n                \r\nI'm working on algorithms the classic Knapsack Problem (for MIT 6.002x) and also trying to get my head around Dynamic Programming. \n\nThe course doesn't cover DP, but asked me to go look it up. Which I have done but am none the wiser. Am finding it hard to relate to any of the tutorials / videos because they're mostly about solving other algorithms. And because I'm a bit fuzzy on DP to begin with they're not really helping. \n\nCan anybody point me to a place that explains Dynamic Programming and how it is used to solve the Knapsack problem\n    ", "Answer": "\r\nyou can learn basics of dynamic programming and understand how knapsack problem can be solved using link below.\nhttp://www.geeksforgeeks.org/dynamic-programming-set-10-0-1-knapsack-problem/\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "How to implement Dynamic Programming in the following recusrion?\r\n                \r\nI have the following recursion:\n\n```\nif(a%2 == 0){\nf([a1,a2,...,aN],a,N) = (a1 + aN)/2 + f([a1,a2,...,a(N-1)],a+1,N-1)/2 + \nf([a2,...,aN],a+1,N-1)/2;\n}\nelse{\nf([a1,a2,...,aN],a,N) = f([a1,a2,...,a(N-1)],a+1,N-1)/2 + \nf([a2,...,aN],a+1,N-1)/2;\n}\n```\n\n\nBase Case:\n\n```\nf([a1,a2],a,2) = (a1+a2)/2;\n```\n\n\nObviously, there'll be a stack overflow if I implement it recursively. How should I make use of Dynamic Programming to obtain optimal solution to this recursion?\n\n[a1,a2,..,aN] respresents an integer array.\n\nThe limit for N is 2000 and a1,a2,..,aN <=999.\n    ", "Answer": "\r\nThis smells an awful lot like a homework problem. I would suggest that you meet with the lecturer or a TA because this is the sort of thing best learned interactively. If you use this information, make sure to cite it so you don't commit plagiarism.\n\nFirst, observe that the results are linear in the values ```\n[a0, a1, ... aN]```\n. Therefore, you really only need to keep track of their coefficients. For notational purposes, let's write ```\n{b1, b2, ..., bN}```\n to represent ```\nb1 * a1 + b2 * a2 + ... bN * aN```\n.\n\nNext, work out a few of the recursions by hand:\n\n```\nf([a1, a2], a, 2) = { 1/2, 1/2 }```\n is the base case for ```\nN=2```\n.\n\nLet's look at ```\nN=3```\n:\n\n```\nf([a1, a2, a3], a, 3)```\n for ```\na```\n even = ```\n{1/2, 0, 1/2} + { f([a1, a2], a+1, 2)/2, 0 } + { 0, f([a2, a3], a+1, 2)/2 } = { 1/2, 0, 1/2 } + { 1/4, 1/4, 0 } + { 0, 1/4, 1/4 } = { 3/4, 1/2, 3/4 }```\n.\n\n```\nf([a1, a2, a3], a, 3)```\n for ```\na```\n odd = ```\n{ f([a1, a2], a+1, 2)/2, 0 } + { 0, f([a2, a3], a+1, 2)/2 } = { 1/2, 0, 1/2 } + { 1/4, 1/4, 0 } + { 0, 1/4, 1/4 } = { 1/4, 1/2, 1/4 }```\n.\n\nNow ```\nN=4```\n:\n\n```\nf([a1, a2, a3, a4], a, 4)```\n for ```\na```\n even = ```\n{ 1/2, 0, 0, 1/2 } + { f[a1, a2, a3], a+1, 3)/2, 0 } + { 0, f([a2, a3, a4], a+1, 3)/2 }```\n. Since ```\na```\n is even, ```\na+1```\n is odd, so we are in the case ```\nF([], even, 3)```\n. ```\nf([a1, a2, a3, a4], a, 4)```\n for ```\na```\n even = ```\n{ 1/2, 0, 0, 1/2 } + { 1/8, 1/4, 1/8, 0 } + { 0, 1/8, 1/4, 1/8 } = { 5/8, 3/8, 3/8, 5/8 }```\n.\n\n```\nf([a1, a2, a3, a4], a, 4)```\n for ```\na```\n odd = ```\n{ f[a1, a2, a3], even, 3)/2, 0 } + { 0, f([a2, a3, a4], even, 3)/2 } = { 3/8, 1/4, 3/8, 0 } + { 0, 3/8, 1/4, 3/8 } = { 3/8, 5/8, 5/8, 3/8 }```\n.\n\nNow you can see that the coefficients depend only on ```\nN```\n and whether ```\na```\n even or odd.\n\nThis means that your dynamic programming only needs to remember the coefficients for each combination of ```\nN```\n and a boolean. Since ```\nN```\n is capped at 2000, this means you need only 4000 entries, which shouldn't be too much of a burden. In fact, you could abandon the recursion and simply compute the entire table incrementally like we did above.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming Coin Change Problems\r\n                \r\nI am having issues with understanding dynamic programming solutions to various problems, specifically the coin change problem:\n\n\"Given a value N, if we want to make change for N cents, and we have infinite supply of each of S = { S1, S2, .. , Sm} valued coins, how many ways can we make the change? The order of coins doesn’t matter.\n\nFor example, for N = 4 and S = {1,2,3}, there are four solutions: {1,1,1,1},{1,1,2},{2,2},{1,3}. So output should be 4. For N = 10 and S = {2, 5, 3, 6}, there are five solutions: {2,2,2,2,2}, {2,2,3,3}, {2,2,6}, {2,3,5} and {5,5}. So the output should be 5.\"\n\nThere is another variation of this problem where the solution is the minimum number of coins to satisfy the amount.\n\nThese problems appear very similar, but the solutions are very different.\n\nNumber of possible ways to make change: the optimal substructure for this is DP(m,n) = DP(m-1, n) + DP(m, n-Sm) where DP is the number of solutions for all coins up to the mth coin and amount=n.\n\nMinimum amount of coins: the optimal substructure for this is \nDP[i] = Min{ DP[i-d1], DP[i-d2],...DP[i-dn] } + 1 where i is the total amount and d1..dn represent each coin denomination.\n\nWhy is it that the first one required a 2-D array and the second a 1-D array? Why is the optimal substructure for the number of ways to make change not \"DP[i] = DP[i-d1]+DP[i-d2]+...DP[i-dn]\" where DP[i] is the number of ways i amount can be obtained by the coins. It sounds logical to me, but it produces an incorrect answer. Why is that second dimension for the coins needed in this problem, but not needed in the minimum amount problem?\n\nLINKS TO PROBLEMS:\n\nhttp://comproguide.blogspot.com/2013/12/minimum-coin-change-problem.html\nhttp://www.geeksforgeeks.org/dynamic-programming-set-7-coin-change/\n\nThanks in advance. Every website I go to only explains how the solution works, not why other solutions do not work.\n    ", "Answer": "\r\n\nLets first talk about the number of ways, DP(m,n) = DP(m-1, n) + DP(m, n-Sm). This in indeed correct because either you can use the mth denomination or you can avoid it. Now you say why don't we write it as DP[i] = DP[i-d1]+DP[i-d2]+...DP[i-dn]. Well this will lead to over counting , lets take an example where n=4 m=2 and S={1,3}. Now according to your solution dp[4]=dp[1]+dp[3]. ( Assuming 1 to be a base case dp[1]=1 ) .Now dp[3]=dp[2]+dp[0]. ( Again dp[0]=1 by base case ). Again applying the same dp[2]=dp[1]=1. Thus in total you get answer as 3 when its supposed to be just 2 ( (1,3) and (1,1,1,1) ). Its so because\nyour second method treats (1,3) and (3,1) as two different solution.Your second method can be applied to case where order matters, which is also a standard problem.\nNow to your second question you say that minimum number of denominations can\nbe found out by DP[i] = Min{ DP[i-d1], DP[i-d2],...DP[i-dn] } + 1. Well this is correct as in finding minimum denominations, order or no order does not matter. Why this is linear / 1-D DP , well although the DP array is 1-D each state  depends on at most m states unlike your first solution where array is 2-D but each state depends on at most 2 states. So in both case run time which is ( number of states * number of states each state depends on ) is the same which is O(nm). So both are correct, just your second solution saves memory. So either you can find it by 1-D array method or by 2-D by using the recurrence\ndp(n,m)=min(dp(m-1,n),1+dp(m,n-Sm)). (Just use min in your first recurrence)\n\n\nHope I cleared the doubts , do post if still something is unclear.\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Coin change(Dynamic programming)\r\n                \r\nI have a question about the coin change problem where we not only have to print the number of ways to change $n with the given coin denominations for eg {1,5,10,25}, but also print the ways\n\nFor example if the target = $50, and the coins are ```\n{1,5,10,25}```\n, then the ways to actually get use the coins to get the target are\n\n\n2 × $25\n1 × $25 + 2 × $10 + 1 × $5\netc.\n\n\nWhat is the best time complexity we could get to solve this problem?\nI tried to modify the dynamic programming solution for the coin change problem where we only need the number of ways but not the actual ways\n\nI am having trouble figuring out the time complexity.\nI do use memorization so that I don't have to solve the same problem again for the given coin and sum value but still we need to iterate through all the solution and print them. So the time complexity is definitely more than O(ns) where n is the number of coins and s is the target\nIs it exponential? Any help will be much appreciated\n    ", "Answer": "\r\nPrinting Combinations\n\n```\ndef coin_change_solutions(coins, S):\n  # create an S x N table for memoization\n  N = len(coins)\n  sols = [[[] for n in xrange(N + 1)] for s in xrange(S + 1)]\n  for n in range(0, N + 1):\n    sols[0][n].append([])\n\n  # fill table using bottom-up dynamic programming\n  for s in range(1, S+1):\n    for n in range(1, N+1):\n      without_last = sols[s][n - 1]\n      if (coins[n - 1] <= s):\n          with_last = [list(sol) + [coins[n-1]] for sol in sols[s - coins[n - 1]][n]]\n      else:\n          with_last = []\n      sols[s][n] = without_last + with_last\n\n  return sols[S][N]\n\n\nprint coin_change_solutions([1,2], 4)\n# => [[1, 1, 1, 1], [1, 1, 2], [2, 2]]\n```\n\n\n\nwithout: we don't need to use the last coin to make the sum. All the coin solutions are found directly by recursing to ```\nsolution[s][n-1]```\n. We take all those coin combinations and copy them to ```\nwith_last_sols```\n.\nwith: we do need to use the last coin. So that coin must be in our solution. The remaining coins are found recursively via ```\nsol[s - coins[n - 1]][n]```\n. Reading this entry will give us many possible choices for what the remaining coins should be. For each possible choice , ```\nsol```\n, we append the last coin, ```\ncoin[n - 1]```\n:\n\n   ```\n# For example, suppose target is s = 4\n# We're finding solutions that use the last coin.\n# Suppose the last coin has a value of 2:\n#\n# find possible combinations that add up to 4 - 2 = 2: \n# ===> [[1,1], [2]] \n# then for each combination, add the last coin \n# so that the combination adds up to 4)\n# ===> [[1,1,2], [2,2]]\n```\n\n\n\nThe final list of combinations is found by taking the combinations for the first case and the second case and concatenating the two lists. \n\n```\nwithout_last_sols = [[1,1,1,1]]\nwith_last_sols = [[1,1,2], [2,2]]\nwithout_last_sols + with_last_sols = [[1,1,1,1], [1,1,2], [2,2]]\n```\n\n\n\n\nTime Complexity\n\nIn the worst case we have a coin set with all coins from 1 to n: coins\n = [1,2,3,4,...,n] – the number of possible coin sum combinations, num solutions, is equal to the number of integer partitions of s, p(s).\nIt can be shown that the number of integer partitions, p(s) grows exponentially.\nHence num solutions = p(s) = O(2^s). Any solution must have this at a minimum so that it can print out all these possible solutions. Hence the problem is exponential in nature.\n\nWe have two loops: one loop for s and the other loop for n.\nFor each s and n, we compute ```\nsols[s][n]```\n:\n\n\nwithout: We look at the O(2^s) combinations in ```\nsol[s - coins[n - 1]][n]```\n. For each combination, we copy it in O(n) time. So overall this takes: O(n×2^s) time.   \nwith: We look at all O(2^s) combinations in ```\nsol[s][n]```\n. For each combination list ```\nsol```\n, we create copy of that new list in O(n) time and then append the last coin. Overall this case takes O(n×2^s). \n\n\nHence the time complexity is O(s×n)×O(n2^s + n2^s) = O(s×n^2×2^s).\n\n\n\nSpace Complexity\n\nThe space complexity is O(s×n^2×2^s) because we have a s×n table with\neach entry storing O(2^s) possible combinations, (e.g. ```\n[[1, 1, 1, 1], [1, 1, 2], [2, 2]]```\n), with each combination, (e.g. ```\n[1,1,1,1]```\n) taking O(n) space.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Count Combinations in the given String using Dynamic programming\r\n                \r\nI found an exercise in the \"Algorithms and Data Structures\" book that I'm unable to solve.\nStarting with a table of characters encoding:\n```\n| left | center |\n|:---- |:-------|\n| A    | 0      |\n| B    | 00     |\n| C    | 001    |\n| D    | 010    |\n| E    | 0010   |\n| F    | 0100   |\n| G    | 0110   |\n| H    | 0001   |\n```\n\nThis means that starting by a given string ```\nS = 00100```\n, there are ```\n5```\n possible sequences that can be decoded: ```\nADA```\n, ```\nAF```\n, ```\nCAA```\n, ```\nCB```\n or ```\nEA```\n.\n\nObviously not all strings can be decoded (e.g. ```\n1111```\n).\n\nWrite a program (in Java) that calculates the number of sequences that can encode S through dynamic programming.\nAnother example: the string ```\n000100100010010000100100001001100```\n has ```\n5567```\n possible sequences.\n\nHint: the subproblems are the prefixes of ```\nS```\n\n\nMy attempt:\n```\n/**\n * this is the main part of the algorithm. I feel like this is way too slow\n * and it doesn't use dynamic programming.\n * 'encodings' is just an ArrayList with the specified values (e.g 00).\n */\nprivate void count(String str) {\n  for (String c : encodings) {\n    if (str.length() > c.length()) {\n      String subStringCodLength = str.substring(0, c.length());\n      if (subStringCodLength.equals(c)) {\n        String substring = str.substring(c.length());\n        count(substring);\n      }\n    } else if (str.length() == c.length()) {\n      if (encodings.contains(str)) {\n        this.numOfDecodings++;\n        break;\n      }\n    }\n  }\n}\n```\n\n    ", "Answer": "\r\nThere are two approaches in Dynamic programming: Memoization and Tabulation.\nBoth are based and storing and reusing previously calculated results of subproblems. And as the hint says, divide the problem into subproblems based on the prefixes of the given string.\nMemoization\nMemoization technic is used together with recursion. A good choice of a mean for storing the intermediate results would be a ```\nMap```\n.\nWhen implementing a recursion, we need to describe two situations:\n\nBase case - that represents a simple edge-case (or a set of edge-cases) for which the outcome is known in advance. For this problem, such edge-cases are:\n\nthe given string is empty and result would be ```\n1```\n (an empty binary string ```\n\"\"```\n results into an empty string of letters ```\n\"\"```\n),\nanother case is when it's impossible to decode a given binary string and the result will be ```\n0```\n (in the solution below it resolves naturally when the recursive case is being executed),\nresult for the given string has been already calculated and contained in the map.\n\n\nRecursive case - a part of a solution where recursive calls a made and when the main logic resides. In the recursive case, we need to find each binary \"binary letter\" at the beginning of the string and then call the method recursively by passing the substring (without the \"letter\") as an argument. Results of these recursive calls need to be accumulated, stored in the map, and then provided as a return value.\n\n\nThat how it might look like:\n```\npublic static int count(String str, List<String> letters, Map<String, Integer> vocab) {\n    if (str.isEmpty()) { // base case - a combination was found\n        return 1;\n    }\n    if (vocab.containsKey(str)) { // result was already computed and present in the map \n        return vocab.get(str);\n    }\n\n    int count = 0;\n\n    for (String letter: letters) {\n        if (str.startsWith(letter)) {\n            count += count(str.substring(letter.length()), letters, vocab);\n        }\n    }\n    vocab.put(str, count); // storing the total `count` into the map\n\n    return count;\n}\n```\n\nTabulation\nTabulation technic isn't based on recursion, instead it utilizes loops.\nWhich makes this approach more reliable, because recursion has some limitation, especially in Java. Tabulation allows processing a massive input that can produce ```\nStackOverflowError```\nwith Memoization.\nUsually, arrays are used to store intermediate results while implementing a Tabulation.\nTo solve this problem, we need to create an array with the length of the given string + ```\n1```\n. Each element of the array will represent the number of ways to contract the substring from index ```\n0```\n up to the index of the current element using a set of \"binary letters\". The final result will be stored at the last position of the array.\nTo initialize the array, we need to set a value of ```\n1```\n to each element of the array that corresponds \"binary letter\" which happens to be a prefix of the given string. It's done in the ```\npopulate()```\n method. Then we need to iterate over array searching for the possible combinations that can be contacted based on the combinations that has been already found (i.e. based on the array elements that are not ```\n0```\n).\n```\npublic static int count(String str, List<String> letters) {\n    int[] tab = new int[str.length() + 1];\n    \n    populate(str,  letters,  tab);\n    \n    for (int i = 1; i < tab.length; i++) {\n        if (tab[i] == 0) continue;\n        for (String letter: letters) {\n            if (i + letter.length() >= tab.length) continue;\n            \n            if (str.substring(i, i + letter.length()).equals(letter)) {\n                tab[i + letter.length()] += tab[i];\n            }\n        }\n    }\n    return tab[tab.length - 1];\n}\n\npublic static void populate(String str, List<String> letters, int[] tab) {\n\n    for (String letter: letters) {\n        if (letter.length() >= tab.length) continue;\n    \n        if (str.startsWith(letter)) {\n            tab[letter.length()] += 1;\n        }\n    }\n}\n```\n\nDemo\n```\nmain()```\n\n```\npublic static void main(String[] args) {\n    \n    List<String> letters = List.of(\"0\", \"00\", \"001\", \"010\", \"0010\", \"0100\", \"0110\", \"0001\"); // binary letters\n\n    System.out.println(count(\"000100100010010000100100001001100\", letters, new HashMap<>())); // Memoization\n    System.out.println(count(\"000100100010010000100100001001100\", letters)); // Tabulation\n}\n```\n\nOutput:\n```\n5567   // Memoization\n5567   // Tabulation\n```\n\nA link to Online Demo\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Problem k-subvector using dynamic programming\r\n                \r\nGiven a vector V of n integers and an integer k, k <= n, you want a subvector (a sequence of consecutive elements of the vector ) of maximum length containing at most k distinct elements.\n\nThe technique that I use for the resolution of the problem is dynamic programming.\nThe complexity of this algorithm must be O(n*k).\n\nThe main problem is how to count distinct elements of the vector. as you would resolve it ?\n\nHow to write the EQUATION OF RECURRENCE ?\n\nThanks you!!!.\n    ", "Answer": "\r\nI don't know why you would insist on ```\nO(n*k)```\n, this can be solved in ```\nO(n)```\n with 'sliding window' approach.\n\n\nMaintain current 'window' ```\n[left..right]```\n\nAt each step, if we can increase ```\nright```\n by 1 (without violating 'at most k disctint elements' requirement), do it\nOtherwise, increase ```\nleft```\n by 1\nCheck whether current window is the longest and go back to #2\n\n\nChecking whether we can increase ```\nright```\n in #2 is a little tricky. We can use hashtable storing for each element inside window how many times it occurred there.  \n\nSo, the condition to allow ```\nright```\n increase would look like\n\n```\nhash.size < k || hash.contains(V[right + 1])\n```\n\n\nAnd each time ```\nleft```\n or ```\nright```\n is increased, we'll need to update hash (decrease or increase number of occurrences of the given element).\n\nI'm pretty sure, any DP solution here would be longer and more complicated.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming approach issue\r\n                \r\nAlice goes for jogging every day for N meters. Sometimes she runs and sometimes she walks. Her walking speed is 1m/s and running speed is 2m/s . Given the distance up to which she does jogging, calculate the number of ways she can do jogging.\nexample:\nInput: 3 (total distance covered during jogging)\nOutput: 3 (possible case)\nExplanation:\nAlice could jog in 3 ways\n\nAlice Walks for 3 meter\nAlice Run for 2 meters and then walks for 1 m\nAlice walks 1m and then run 2m\n\nExample 2:\nInput: 4\nOutput: 5\nExplanation: Alice could jog in 5 ways\n\nAlice walk for all 4 meters\nAlice walk for first 2 meters and then run for 2 meters\nAlice could run for 2 meters and then walk for 2 meters\nAlice walk for 1 meters and then run  for 2 meters and then walk for 1 meters\nAlice run for all 4 meters\n\nI have solved above problem statement using following code\n```\n\nfrom itertools import permutations\n\nn = int(input())\n\nc = 0\nt = [2]*(n//2)\nif n % 2 != 0:\n    t = t+[1]\n\nfor i in range(t.count(2)):\n    c = c+len(set(list(permutations(t, len(t)))))\n    t.remove(2)\n    t.append(1)\n    t.append(1)\nc = c+len(set(list(permutations(t, len(t)))))\nprint(c)\n\n```\n\nI'm new in dynamic programming, any one can help me ? how i can implement this in dynamic approach method and achieve more optimum time complexivity?\nThankyou very much for giving your valuable towards my problem.\n    ", "Answer": "\r\nInspired by all earlier posts, and the unwritten assumptions being confirmed, this is just another fib-sequence question.\nCredits to all earlier posters.  (the code is quite simple then) Just for reference - hope it helps.\n```\ndef jogging_ways(n: int) -> int:\n    # f(3) = f(1) + f(2)\n    a, b = 1, 1\n        \n    for i in range(n):\n        a, b = b, a+b\n        #print(a, b)\n        \n    return a\n```\n\nRunning:\n```\n> jogging_ways(4)\n  5\n> jogging_ways(5) \n  8\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "GOTO/Continue in Java Dynamic Programming\r\n                \r\nI have the following piece of code in Java implementing dynamic programming recursiverelatio:\n\n```\npublic double routeCost() throws Exception {\n    double cost = Double.MAX_VALUE;\n    for (int l=i; l<=j; l++) {\n        if (! (customers.get(l) instanceof VehicleCustomer) )\n            continue;\n        double value = F(l,j) + (customers.get(l).distanceFrom(depot));\n        if (value < cost)\n            cost = value;\n    }\n\n    return cost;\n}\n\nprivate double F(int l, int m) {\n\n    //=========================== FIRST CASE ===========================\n    if (l==i && m==i) {\n        //System.out.println(i+\",\"+j+\",\"+l+\",\"+m);\n        return firstCase();\n    }\n\n    //=========================== SECOND CASE ===========================\n    if (l==i && (i<m && m<=j) ) {\n        //System.out.println(i+\",\"+j+\",\"+l+\",\"+m);\n        //analyses the possibility of performing all the soubtours based at heicle customert_i\n        return secondCase(i,m);\n\n    }\n    //=========================== GENERAL CASE ===========================\n    else  {\n        System.out.println(i+\",\"+j+\",\"+l+\",\"+m);\n\n        assert (customers.get(l) instanceof VehicleCustomer);\n\n        assert ( (i<l && l<=j) && (l<=m && m<=j) );\n        return Math.min(thirdCaseFirstTerm(l,m), thirdCaseSecondTerm(l,m));\n    } \n\n}\n\nprivate double firstCase() {\n    mainRoute.add(depot);\n    mainRoute.add(customers.get(i));\n    return depot.distanceFrom(customers.get(i));\n}\n\nprivate double secondCase(int i,int m) {\n    double caseValue = Double.MAX_VALUE;\n    int k = i;\n    while (k<m) {   \n        double totalDemand=0;\n        for (int u=k+1; ( (u<=m) && (totalDemand<=truckCapacity) ); u++)\n            totalDemand += customers.get(u).getDemand();\n\n        double cost = F(i,k) + thita(i,k+1,m);\n        if (cost <= caseValue) \n            caseValue = cost;\n\n        k++;\n    }       \n    return caseValue;\n}\n\nprivate double thirdCaseFirstTerm(int l, int m) {\n    double caseValue = Double.MAX_VALUE;\n\n    int k = i;\n    while (k<m) {\n\n        double totalDemand=0;\n        for (int u=k+1; ( (u<=m) && (totalDemand<=truckCapacity) ); u++)\n            totalDemand += customers.get(u).getDemand();\n\n        double cost = F(l,k) + thita(l,k+1,m);\n        if (cost <= caseValue) \n            caseValue = cost;\n        k++;\n    }\n\n    return caseValue;\n}\n\nprivate double thirdCaseSecondTerm(int l,int m) {\n    double caseValue = Double.MAX_VALUE;\n\n    int k = i; \n\n    for (Customer cust : customers) {\n        int h = customers.indexOf(cust);\n        if ( (!(cust instanceof VehicleCustomer)) || (h >=l)) {\n            continue;\n        }\n\n        double totalDemand=0;\n        for (int u=k+2; ( (u<=m) && (totalDemand<=truckCapacity) ); u++)\n            totalDemand += customers.get(u).getDemand();\n\n        double cost = F(h,k) + customers.get(h).distanceFrom(customers.get(l)) + thita(l,k+2,m);\n        if (cost < caseValue)\n            caseValue = cost;\n    }\n\n    return caseValue;\n}\n```\n\n\nMethod F(int,int) is invoked from the for loop in method routeCost(). \nI want to find a way to enforce that whenever the assertion ```\nassert (customers.get(l) instanceof VehicleCustomer);```\n\n` is not true, instead of going down to the return statement, I want to infrom the for loop from the routeCost() to continue to the next iteration. But F() has to return a value!\n\nI know that what I'm trying to do violates almost every rule of object orientation, but I really need that. \n    ", "Answer": "\r\nYou could throw an ```\nException```\n in ```\nF()```\n and catch it in ```\nrouteCost()```\n.\n\nThis approach is much better than using assertions. They are rarely used in practice, and there's a good reason for this: exceptions are much more flexible and better suited for detecting errors, invalid input etc.\n\nPS: When I say \"rarely used\", I base this statement on the fact that I saw hundreds of thousands of lines of Java code in the past years and I rarely came accross code that uses assertions.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Obtaining the actual steps of a solution that has been obtained using Dynamic Programming\r\n                \r\nIf dynamic programming is used to obtain some optimum solution for a problem. How do you reconstruct the actual steps that lead to that solution?\n\nFor example, in the 0-1 knapsack problem you use the recurrence\n\n      \n\nUsing this we can get the maximum value that can be present in the knapsack. How do you find the actual items present.\n\nCan this be generalized for any dynamic programming solution. For eg. To find the actual nos that are part of the longest increasing subsequence whose solution has been obtained using dynamic programming.\n    ", "Answer": "\r\n\n  Can this be generalized for any dynamic programming solution. \n\n\nNo, you can't in general find the actual solution by inspecting the final values in the DP-table.\n\nIf the algorithm simply looks for some optimum value, it will typically discard information regarding how each value was computed.\n\nIn a DP-solution the cell on row R could for instance depend on the maximum value in row R-1. Unless the algorithm records which cell was chosen, it will not be possible to reconstruct the actual solution based on the resulting table.\n\nYou should however always be able to attach additional information to each cell describing where the value comes from, for instance by references to previously computed cells which the current cell depends upon, and use this information to reconstruct the actual solution.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Trouble understanding dynamic programming\r\n                \r\nI came across this problem. Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.  \n\n```\n [\n    [2],\n   [3,4],\n  [6,5,7],\n [4,1,8,3]\n]\n```\n\n\nThis is an example of dynamic programming. But a very difficult or confusing concept for me when i come an exercise. I have watched videos and read tutorials online and it seems pretty easy at first but when i approach a problem then i'm totally lost.\nSo i found a solution online and that uses a bottom approach:\n\n```\npublic init minmumTotal(ArrayList<ArrayList<Integer>> triangle) {\n       if (triangle.size() == 0 || triangle == null)\n                   return 0;\n     int[] dp = new int[triangle.size()+1]; // store each index’s total\n       for (int i = triangle.size()-1; i >=0; i--) {\n             for (int j = 0; j < triangle.get(i).size(); j++) {\n                // first round: dp[j], dp[j+1] are both 0\n               dp[j] = Math.min(dp[j], dp[j+1]) + triangle.get(i).get(j); \n             }\n         }\n             return dp[0];\n         }\n```\n\n\nSeems easy after going through the solution. But can this be done using a top down approach? And could someone explain why the bottom approach is better than the top down approach? Also when is it appropriate to use either top down or bottom up? And also since the question mentioned that each ```\n\"Each step you may move to adjacent numbers on the row below.\"```\n Does that mean for each row iterate the whole column before i step into the next row?\n    ", "Answer": "\r\nI'm not sure if this solution counts as dynamic programming, but I think it is very efficient.\n\nYou can start at the bottom of the triangle, and then collapse it by moving upwards in the triangle. For each number in the next row, add the lowest number of the two numbers below it. When you get to the top, you will only have one number, which would be your result. So you would get this:\n\nStart:\n\n```\n   2\n  3 4\n 6 5 7\n4 1 8 3\n```\n\n\nStep 1:\n\n```\n   2\n  3 4\n 7 6 10\n```\n\n\nStep 2:\n\n```\n   2\n  9 10\n```\n\n\nStep 3:\n\n```\n   11\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming with Memoization not working properly\r\n                \r\nI have a rough solution to an optimization problem using dynamic programming. The aim is to get the shortest time to achieve the most satisfaction, with each item having individual time values, and a general optimal time for all the satisfactions.\n```\ndef pp(list1, values, time_values, optimal_time, memo):\n  list4 = []\n\n  for i, j in zip(values, time_values):\n    if (i,j,optimal_time) not in memo:\n      memo[i,j,optimal_time] = (i * (optimal_time/j))\n      list4.append(memo[i,j,optimal_time])\n\n  zipped_lists = zip(list4, list1)\n  sorted_pairs = sorted(zipped_lists)\n\n  tuples = zip(*sorted_pairs)\n  list4, list1= [list(tuple) for tuple in  tuples]\n  return list(reversed(list1))\n\ndef getPP (list1, values, time_values, optimal_time):\n  memo = {}\n  return pp(list1, values, time_values, optimal_time, memo)\n```\n\ncase 1: ```\nprint(getPP([\"LOK\", \"MP\", \"HM\", \"AR\", \"SG\", \"VV\"], [0.37, 0.87, 0.27, 0.87, 0, 0.56], [6, 1, 15, 3, 3, 3], 6))```\n\nresult: ```\n['MP', 'AR', 'VV', 'LOK', 'HM', 'SG']```\n\nThe solution seems to work in certain cases.\nWhen I try this, it omits the last item in the array, and my result is:\ncase 2: ```\nprint(getPP([\"ARD\", \"AR\", \"GS\", \"LP\", \"MP\", \"ML\", \"SI\", \"VV\"], [0.44, 0.67, 0.67, 0.5, 0.08, 0.44, 0.33, 0.87], [2, 3, 3, 4, 1, 5, 3, 3], 6))```\n\nresult: ```\n['SI', 'AR', 'ARD', 'GS', 'ML', 'MP', 'LP']```\n\nI'm not sure where the problem is.\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming - number of possible passwords\r\n                \r\nI have a question a dynamic programming problem. I find it very difficult, so I hope I can get some help.\nGiven a list of words and the length ```\nn```\n of a password, I would like to know the amount of possible combinations of passwords. Passwords can be either a single word of length ```\nn```\n or a combination of words separated by underscores.\nFor example, ```\npasswords(5, [\"house, \"no\"]) = 2```\n because the possible passwords are \"house\" and \"no_no\".\nWhat I have tried so far:\n```\ndef voc_to_list(vocabulary):\n    \"\"\"\n    produces a list lengths such that lengths[i] is the number of\n    words of length i in vocabulary\n    \"\"\"\n    max_len = max([len(w) for w in vocabulary])\n    lengths = [0] * (max_len + 1)\n    for w in vocabulary:\n        wordLength = len(w)\n        lengths[wordLength] += 1\n    return lengths\n\n\ndef passwords(L, vocabulary):\n    lengths = voc_to_list(vocabulary)\n    k = len(lengths)\n    tbl = [0] * (L + 1)\n    for i in range(L + 1):\n        if i < k:\n            tbl[i] = lengths[i]\n        for j in range(min(i, k)):\n            # This is where I am stuck\n            tbl[i] += ??\n    return tbl[L]\n```\n\nInside ```\ntbl[i]```\n I already have the words of length ```\ni```\n. I am stuck in how to fill out the table to take into account the combinations of words.\n    ", "Answer": "\r\nYou should store in ```\ntbl[i]```\n the maximal number of possible passwords with length ```\ni```\n, that much you already figured out. The update step involves combinatorics. A simple example would be ```\npasswords(9, [\"a\", \"e\", \"i\", \"o\", \"u\"]) == 5**5```\n. If this is not intuitive for you, I suggest revisiting the needed maths.\nSo, the update step is actually the sum of products of the maximal number of combinations ```\ntbl[i-j-1]```\n and the new word candidates which \"complete\" the password length to that point ```\nlengths[j]```\n. For this, you iteratively update:\n```\ndef passwords(L, vocabulary):\n    lengths = voc_to_list(vocabulary)\n    k = len(lengths)\n    tbl = [0] * (L + 1)\n    for i in range(L + 1):\n        if i < k:\n            tbl[i] = lengths[i]\n        for j in range(1, min(i-1, k)):\n            tbl[i] += tbl[i-j-1] * lengths[j]  # -1 due to underscores\n    return tbl[L]\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Trouble understanding dynamic programming\r\n                \r\nI came across this problem. Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.  \n\n```\n [\n    [2],\n   [3,4],\n  [6,5,7],\n [4,1,8,3]\n]\n```\n\n\nThis is an example of dynamic programming. But a very difficult or confusing concept for me when i come an exercise. I have watched videos and read tutorials online and it seems pretty easy at first but when i approach a problem then i'm totally lost.\nSo i found a solution online and that uses a bottom approach:\n\n```\npublic init minmumTotal(ArrayList<ArrayList<Integer>> triangle) {\n       if (triangle.size() == 0 || triangle == null)\n                   return 0;\n     int[] dp = new int[triangle.size()+1]; // store each index’s total\n       for (int i = triangle.size()-1; i >=0; i--) {\n             for (int j = 0; j < triangle.get(i).size(); j++) {\n                // first round: dp[j], dp[j+1] are both 0\n               dp[j] = Math.min(dp[j], dp[j+1]) + triangle.get(i).get(j); \n             }\n         }\n             return dp[0];\n         }\n```\n\n\nSeems easy after going through the solution. But can this be done using a top down approach? And could someone explain why the bottom approach is better than the top down approach? Also when is it appropriate to use either top down or bottom up? And also since the question mentioned that each ```\n\"Each step you may move to adjacent numbers on the row below.\"```\n Does that mean for each row iterate the whole column before i step into the next row?\n    ", "Answer": "\r\nI'm not sure if this solution counts as dynamic programming, but I think it is very efficient.\n\nYou can start at the bottom of the triangle, and then collapse it by moving upwards in the triangle. For each number in the next row, add the lowest number of the two numbers below it. When you get to the top, you will only have one number, which would be your result. So you would get this:\n\nStart:\n\n```\n   2\n  3 4\n 6 5 7\n4 1 8 3\n```\n\n\nStep 1:\n\n```\n   2\n  3 4\n 7 6 10\n```\n\n\nStep 2:\n\n```\n   2\n  9 10\n```\n\n\nStep 3:\n\n```\n   11\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Hackerrank Contest: Dynamic Programming\r\n                \r\nI was going through a contest problem on hackerrank (link below)\n\nhttps://www.hackerrank.com/contests/w13/challenges/a-super-hero\n\nIt is as far as I know, a dynamic programming problem. I tried various approaches, but failed to clear it. Its has a lengthy problem statement, but I will try to explain it as short as possible.\n\nYou have to clear n different levels, each containing m enemies. Each level can be cleared by defeating any one enemy of that level. Each enemy has some bullets and some power. You need as many bullets as his power to defeat him. After you defeat a enemy, you take his bullets, which can be used only at next level. So, you have to tell, minimum no. of bullets required at the start to complete the game.\n\nFor more details, please see the link.\n\nComplete solution is not necessary. Just some pointers, tips will be sufficient.\n    ", "Answer": "\r\nActually this problem is not DP. It is a binary search problem. Do a binary search over the answer. For each number of bullet N, be greedy on each level. That is, out of the enemies that you can kill(i.e. have power no more than your current bullets), kill the one that will give you the most bullets after the end of the level. Note that here you need to subtract the number of bullets you will need to kill the given enemy. If the initial value N is enough to complete all levels you set it as the new end of the range you are searching in. Otherwise set N as the new beginning(regular binary search approach). \n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming: Find shortest path through grid with obstacles\r\n                \r\nI'm trying to solve the following problem from Skiena's Algorithm Design Manual:\n\n8-16 Consider a city whose streets are defined by an X x Y grid. We are interested in walking from the upper left-hand corner of the grid to the lower right-hand corner. Unfortunately, the city has bad neighborhoods, whose intersections we do not want to walk in. We are given an X x Y matrix BAD, where BAD[i,j] = \"yes\" if and only if the intersection between streets i and j is in a neighborhood to avoid.\n\n(c) Give an O(XY) algorithm to find the shortest path across the grid that avoids bad neighborhoods. You may assume that all blocks are of equal length. For partial credit, given an O(X^2*Y^2) algorithm.\n\nThe question comes from the chapter on dynamic programming and under the heading \"Graph Problems\". I understand that I can model this as an undirected unweighted graph with vertices for all of the \"good\" intersections and edges between any adjacent \"good\" vertices. Given that this is an unweighted graph I can do a breadth-first search starting from the top-left vertex and once I reach the bottom-right vertex I have the shortest path.\n\nGiven that this problem is from the dynamic programming chapter I am trying to figure out how to solve this using dynamic programming. The shortest path to an intersection (i,j) is 1 + the minimum of the shortest paths to intersections (i,j-1), (i-1,j), (i,j+1), (i+1, j). This formulation doesn't seem to fit the overlapping subproblems nature of dynamic programing. Can this problem be solved using dynamic programming?\n    ", "Answer": "\r\nActually, that formulation exactly fits the overlapping subproblems nature of dynamic programming.\n\nIn the first order, the shortest path to an intersection can be formulated in terms of the shortest paths to adjacent intersections.  Hence, subproblems.\n\nIn the second order, multiple intersections may share the same adjacent intersection for which its shortest path is an input in each of the other intersections' shortest path function.  Hence, overlapping subproblems.\n\nOn a side note, both Dijkstra's Algorithm and the Bellman-Ford Algorithm are examples of dynamic programming algorithms that will solve your example problem within the given big-O complexity constraint.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming with Memoization not working properly\r\n                \r\nI have a rough solution to an optimization problem using dynamic programming. The aim is to get the shortest time to achieve the most satisfaction, with each item having individual time values, and a general optimal time for all the satisfactions.\n```\ndef pp(list1, values, time_values, optimal_time, memo):\n  list4 = []\n\n  for i, j in zip(values, time_values):\n    if (i,j,optimal_time) not in memo:\n      memo[i,j,optimal_time] = (i * (optimal_time/j))\n      list4.append(memo[i,j,optimal_time])\n\n  zipped_lists = zip(list4, list1)\n  sorted_pairs = sorted(zipped_lists)\n\n  tuples = zip(*sorted_pairs)\n  list4, list1= [list(tuple) for tuple in  tuples]\n  return list(reversed(list1))\n\ndef getPP (list1, values, time_values, optimal_time):\n  memo = {}\n  return pp(list1, values, time_values, optimal_time, memo)\n```\n\ncase 1: ```\nprint(getPP([\"LOK\", \"MP\", \"HM\", \"AR\", \"SG\", \"VV\"], [0.37, 0.87, 0.27, 0.87, 0, 0.56], [6, 1, 15, 3, 3, 3], 6))```\n\nresult: ```\n['MP', 'AR', 'VV', 'LOK', 'HM', 'SG']```\n\nThe solution seems to work in certain cases.\nWhen I try this, it omits the last item in the array, and my result is:\ncase 2: ```\nprint(getPP([\"ARD\", \"AR\", \"GS\", \"LP\", \"MP\", \"ML\", \"SI\", \"VV\"], [0.44, 0.67, 0.67, 0.5, 0.08, 0.44, 0.33, 0.87], [2, 3, 3, 4, 1, 5, 3, 3], 6))```\n\nresult: ```\n['SI', 'AR', 'ARD', 'GS', 'ML', 'MP', 'LP']```\n\nI'm not sure where the problem is.\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "what is the greedy or dynamic programming approach of this?\r\n                \r\nwe have a sequence of REAL numbers.all of the numbers are unique.we want to have an ascending sequence by changing some of these values.we are allowed to change any arbitrary numbers.how to find the optimum algorithm to determine the minimum number of necessary changes to make this sequence?\nwe can use greedy or dynamic programming approach.\n    ", "Answer": "\r\nfirst find longest increasing subsequence http://en.wikipedia.org/wiki/Longest_increasing_subsequence\n\nthen change all numbers which do not belong to this subsequence to fit the rule\n\n(proof: if we change less numbers and acquire ascending sequence, then the numbers which were not changed were initially forming increasing subsequence longer then 'longest')\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Can anyone explain me what is wrong with my dynamic programming approach to project euler 15?\r\n                \r\nI am learning dynamic programming and have attempted solve Problem 15 of Project Euler using dynamic programming. \nAlthough I do know that the problem is solvable using binomial co-efficient, I wanted to see how much have I learned dynamic programming and thus tried. Here is the code:\n\n```\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n\nusing namespace std;\n\nint main()\n{\n    int gridsize;\n    cin>>gridsize;\n\n\n    int** grid = new int*[gridsize+1];\n    for ( int i = 0; i < gridsize+1; i++) {\n        grid[i] = new int[gridsize+1];\n    }\n\n    //Initialize the grid distances\n\n    for ( int i = 1; i <= gridsize ; i++) {\n        grid[i][0] = 1;\n        grid[0][i] = 1;\n    }\n    grid[0][0] = 0;\n\n    for ( int i = 1; i <= gridsize ; i++) {\n        for ( int j = 1; j <= gridsize ; j++) {\n            grid[i][j] = grid[i-1][j] + grid[i][j-1];\n        }\n    }\n    cout<<grid[gridsize][gridsize]<<endl;\n    delete(grid);   \n    return 0;\n}\n```\n\n\nThe expected answer is 137846528820, while the answer that I am getting is 407575348.\n    ", "Answer": "\r\nYour logic is fairly correct, the problem is that you are getting a case of integer overflow. Here is a modified version of your code that works perfectly. Simply change the ```\nint```\n to an ```\nlong long unsigned```\n type.\n\n```\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n\nusing namespace std;\ntypedef unsigned long long ull;\nint main()\n{\n    ull gridsize;\n    cin>>gridsize;\n\n\n    ull** grid = (ull**) malloc((gridsize+1)*sizeof(ull*));\n    for ( int i = 0; i < gridsize+1; i++) {\n        grid[i] = (ull*) malloc((gridsize +1)*sizeof(ull));\n    }\n\n    //Initialize the grid distances\n\n    for ( int i = 1; i <= gridsize ; i++) {\n        grid[i][0] = 1;\n        grid[0][i] = 1;\n    }\n    grid[0][0] = 0;\n\n    for ( int i = 1; i <= gridsize ; i++) {\n        for ( int j = 1; j <= gridsize ; j++) {\n            grid[i][j] = grid[i-1][j] + grid[i][j-1];\n        }\n    }\n    cout<<grid[gridsize][gridsize];\n    free(grid);\n    return 0;\n}\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Python recursion and/or dynamic programming\r\n                \r\nI've stumbled on a problem that goes above my skill level. \n\nFind the unique atom(s) and their counts for any supplied chemical formula, such as K4(ON(SO3)2)2. -- What I'm asking for right here. \n\nI've gathered that recursion and/or dynamic programming might be required (or at least useful) for this problem.\n\nHere's how far I've gotten:\n\n```\nclass Solution(object):\n    def __init__(self):\n        self.code = []\n        self.atoms = {}\n\n    def encode_string(self,string):\n        \"\"\"\n        Return a list of elements where \n        @'a' = alphabetical \n        @'d' = digit\n        @int = parentheses, wherre number reflects nesting.\n\n        'k4(on(so3)2)2' --> ['a', 'd', 1, 'a', 'a', 2, 'a', 'a', 'd', 2, 'd', 1, 'd']\n        \"\"\"\n\n        self.string = string\n\n        for char in string:\n            if char.isalpha():\n                self.code.append('a')\n            elif char.isdigit():\n                self.code.append('d')\n            elif char == '(':\n                self.code.append('l') #left parenthesis \n            else:\n                self.code.append('r') #right parenthesis \n\n        self.pars = [elem for elem in self.code if elem in ['r','l']]\n\n        self.par_structure = []\n        count = 1\n        for idx, elem in enumerate(self.pars):\n            if elem == 'l':\n                self.par_structure.append(count)\n                count += 1\n            elif elem == 'r':\n                count -= 1\n                self.par_structure.append(count)\n\n        count = 0        \n        for idx, char in enumerate(self.code):\n            if char in ['l','r']:\n                self.code[idx] = self.par_structure[count]\n                count += 1        \n\n\n    def id_atoms(self):\n        self.indices = [idx for idx,elem in enumerate(self.code) if elem == 0]\n        for idx in self.indices:\n            atom = self.string[idx]\n            self.atoms[atom] = 0\n\n    def parse_code():\n        pass\n\n```\n\n\nI've listed as use case of the encode_string method which identifies letters, digits, and parentheses by their level of depth. I think that this is progress towards a solution. The next step would be multiplying out the characters found within the parentheses by the digit value found.\n\nAny advice would be appreciated!\n    ", "Answer": "\r\nBelow is how I would go about solving the stated problem.  I make the assumption that atoms start with a capital letter ('H'), possibly followed by lower case letters ('Mg'):\n\n```\nimport re\nfrom collections import defaultdict\n\ndef tokenize(string):  # \"Mg(OH)2\" -> ['Mg', '(', 'O', 'H', ')', '2']\n    tokens = re.split(r\"([A-Z0-9][a-z]?)\", string)\n    return [token for token in tokens if token]\n\ndef process_multiple(count, entity, dictionary):\n    if isinstance(entity, dict):\n        for atom, quantity in entity.items():\n            dictionary[atom] += quantity * count\n    else:\n        dictionary[entity] += count\n\ndef count_atoms(string):\n\n    def count_atoms_recursive(tokens):\n        dictionary = defaultdict(int)\n        previous_entity = None\n\n        while tokens:\n            token = tokens.pop(0)\n\n            if token == ')':\n                return dictionary\n\n            if token.isdigit():\n                process_multiple(int(token) - 1, previous_entity, dictionary)\n            elif token == '(':\n                previous_entity = count_atoms_recursive(tokens)\n                process_multiple(1, previous_entity, dictionary)\n            else:\n                dictionary[token] += 1\n                previous_entity = token\n\n        return dictionary\n\n    return dict(count_atoms_recursive(tokenize(string)))\n\nif __name__ == \"__main__\":\n\n    tests = [\"H2O\", \"Mg(OH)2\", \"K4(ON(SO3)2)2\"]\n\n    for test in tests:\n        print(test, \"->\", count_atoms(test))\n```\n\n\nThe code isn't robust with respect to ill-formed strings, I leave that as an exercise for the reader.  I hope you find some useful ideas in the code.\n\nOUTPUT\n\n```\n> python3 test.py\nH2O -> {'H': 2, 'O': 1}\nMg(OH)2 -> {'Mg': 1, 'O': 2, 'H': 2}\nK4(ON(SO3)2)2 -> {'K': 4, 'O': 14, 'N': 2, 'S': 4}\n>\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Recursive dynamic programming approach for the travelling salesman [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is off-topic. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it's on-topic for Stack Overflow.\r\n                \r\n                    \r\n                        Closed 10 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI was hoping someone could explain how the code on this page works: TSP-Recursive\n\nThe pseudocode is hard to interpret, and the dynamic programming approach makes it particularly difficult to understand.  Why is the bit shift needed?  How can this approach be generalized (for example, given coordinates for locations, can we adapt this approach to solve that problem)?\n    ", "Answer": "\r\nThe bit shifting is because the code is using an int to represent a set, specially the set of visited cities. If you have 32-bit integers then an int can represent a set of up to 32 items.\n\nThe basic operations are\n\n```\n// add n to set\nset |= 1 << n;\n\n// remove n from set\nset &= ~(1 << n);\n\n// test set for n\nif ((set&(1 << n)) != 0)\n    ...\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming - Primitive Calculator Python [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has an answer here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Dynamic programming for primitive calculator\r\n                            \r\n                                (1 answer)\r\n                            \r\n                    \r\n                Closed 7 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nThis assignment aims to implement a dynamic programming approach to a primitive calculator that can only add 1, multiply by 2 and multiply by 3. So with an input of n determine the minimum number of operations to reach n. I've implemented a very naive dp or what I think is a dp approach. It is not working. I have no-one else to ask. For an input of n = 5 the output of the below is: ([0, 1, 2, 2, 3, 4], [1, 1, 2, 3, 4, 5]) whereas there are two correct outputs for the list numbers = [1, 2, 4, 5] or [1, 3, 4, 5]. Some help would be greatly appreciated.\n\n```\ndef DPmin_operations(n):\n\nnumbers = []\nminNumOperations = [0]*(n+1)\nnumOps = 0\nnumbers.append(1)\n\nfor k in range(1,n+1):\n    minNumOperations[k] = 10000\n\n    # for *3 operator\n    if k % 3 == 0:\n        numOps = minNumOperations[k//3] + 1\n        if numOps < minNumOperations[k]:\n            minNumOperations[k] = numOps\n            numbers.append(k)\n    # for *2 operator\n    elif k % 2 == 0:\n        numOps = minNumOperations[k//2] + 1\n        if numOps < minNumOperations[k]:\n            minNumOperations[k] = numOps\n            numbers.append(k)\n    # for + 1 operator \n    elif k >= 1:\n        numOps = minNumOperations[k - 1] + 1\n        if numOps < minNumOperations[k]:\n            minNumOperations[k] = numOps\n            numbers.append(k)\n\nreturn (minNumOperations, numbers)\n```\n\n    ", "Answer": "\r\nNote that the ```\nelif```\n blocks should really be ```\nif```\n blocks. Currently, you're using a greedy algorithm of always trying to divide by 3; if that fails, then trying to divide by 2; if that fails, then subtracting 1. It's possible that a number is divisible by 6 so that all three options are possible, and yet dividing by 2 is more optimal then dividing by 3.\n\nAs for getting your list of numbers, do that at the end. Store all possible parents, then work backwards from your goal to see how you got there.\n\n```\ndef dp_min_ops(n):\n    all_parents = [None] * (n + 1)\n    all_min_ops = [0] + [None] * n\n\n    for k in range(1, n + 1):\n        curr_parent = k - 1\n        curr_min_ops = all_min_ops[curr_parent] + 1\n\n        if k % 3 == 0:\n            parent = k // 3\n            num_ops = all_min_ops[parent] + 1\n            if num_ops < curr_min_ops:\n                curr_parent, curr_min_ops = parent, num_ops\n\n        if k % 2 == 0:\n            parent = k // 2\n            num_ops = all_min_ops[parent] + 1\n            if num_ops < curr_min_ops:\n                curr_parent, curr_min_ops = parent, num_ops\n\n        all_parents[k], all_min_ops[k] = curr_parent, curr_min_ops\n\n    numbers = []\n    k = n\n    while k > 0:\n        numbers.append(k)\n        k = all_parents[k]\n    numbers.reverse()\n\n    return all_min_ops, numbers\n\nprint(dp_min_ops(5))   # ([0, 1, 2, 2, 3, 4], [1, 3, 4, 5])\nprint(dp_min_ops(10))  # ([0, 1, 2, 2, 3, 4, 3, 4, 4, 3, 4], [1, 3, 9, 10])\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "what's the greedy or dynamic programming approach for this?\r\n                \r\nSuppose we are making sentences by using bi-gram, which means probability of appearance of each word is dependent on previous word. The probability of a sentence is multiple of probability of words\n\n```\nP(sentence) = p(t0)*multiple from i=1 to i=n p(ti|ti-1)\n```\n\n\nwe have probability matrix which we can use to determine ```\nP(ti|ti-1)```\n, we want to find the most probable sentence\n\nIs there any greedy or dynamic programming approach for it?\n    ", "Answer": "\r\nYou can use Viterbi algorithm. Your states is a words (```\nt0, t2, t7, ...```\n). Your initial state is ```\nt0```\n and you have a matrix with transition probabilities ```\na_i,j = P(tj|ti)```\n, you have no \"observations\", so you can not think about ```\nP(y|k)```\n. For every length (```\nt```\n) and every word (```\nt_k```\n) you will find ```\nV_t,k```\n that is the probability of the most probable sentence with ```\nt```\n words and word ```\nt_k```\n at the sentence's end.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "dynamic programming - optimal break point\r\n                \r\nI learned that using dynamic programming, the matrix chain multiplication problem can be solved in n^3 time, while for the optimal binary tree problem, we also get n^3 time, but then we could optimize it to n^2. \nWhy is this? I got a statement saying that this is because in the matrix multiplication problem, the optimal break point of the chain M(i,n) could be larger than the optimal break point of the chain M(i+1,n). Can someone help me understand this? Why is this true in the matrix multiplication problem, but not in the optimal binary tree problem?\n\nThanks\n    ", "Answer": "\r\nGiven an interval of keys I1 that is a sub-interval of I2, the query cost of the optimal binary tree on I1 is no greater than the query cost of the optimal binary tree on I2 (this should be fairly intuitive, but formally, take the optimal tree for I2 and repeatedly delete keys from it via the standard algorithm). This means that you can think of the process of finding the optimal break point as a sort of balancing process between the two halves.\n\nThis is not true for matrix chain: the cost of multiplying (100, 100), (100, 100) is much greater than (100, 100), (100, 100), (100, 1), because two matrix-vector multiplications is much cheaper than a matrix-matrix.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "subproblem graph for matrix multiplication using dynamic programming\r\n                \r\nI am reading about dynamic programming in cormen.\n\nRelated back ground can be found at following link\n\nhttp://staff.ustc.edu.cn/~csli/graduate/algorithms/book6/chap16.htm\n\nUsually, the subproblem graph gives an alternative way to perform the runtime analysis of dynamic programming.\nEach vertex corresponds to a subproblem, and the choices for a subproblem are the edges incident from that subproblem. Recall that in rod cutting,the subproblem graph had n vertices and at most n edges per vertex, yielding an\nO(n^2) running time. For matrix-chain multiplication, if we were to draw the subproblem graph, it would have O(n^2) vertices and each vertex would have degree at most n - 1, giving a total of O(n^3) vertices and edges.\n\nI am looking for matrix-chain multiplication subproblem graph for simple example n = 4.\n\nThanks for your time and help\n    ", "Answer": "\r\nI'm not sure if I understand your question, but are you looking for something like this?\n\n\n\nI created it using this simple Python script:\n\n```\nn = 4\nprint 'digraph {'\nfor i in range(n):\n    for j in range(i, n):\n        print 'p{}{} [label=\"M[{},{}]\"];'.format(i,j,i+1,j+1)\n\nfor i in range(n):\n    for j in range(n):\n        for k in range(i, j):\n            print 'p{}{} -> p{}{}'.format(i,j,i,k)\n            print 'p{}{} -> p{}{}'.format(i,j,k+1,j)\nprint '}'\n```\n\n\nRun like this (needs graphviz and imagemagick installed):\n\n```\npython test.py | dot -Tpng | display\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Python dynamic programming performance difference\r\n                \r\nI'm studying dynamic programming by doing Leetcode problems, and I frequently face time limit exceeded errors even though I'm caching my results. Can anyone explain why my version is so much slower than the official version for this problem?\nThere are obviously differences in the code, e.g., I use a class function for recursion while the official answer does not. My recursive function returns numeric values, the official one does not, etc. None of these seem like meaningful differences though, but the performance difference is nonetheless dramatic.\nMy version. This takes ```\n0.177669```\n seconds to run, and receives a time limit exceeded error.\n```\nimport datetime as dt\nfrom typing import List\nfrom functools import lru_cache\n\n\nclass Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        self.nums = nums\n        total = sum(self.nums)\n        if total % 2 == 1:\n            return False\n        half_total = total // 2\n        return self.traverse(half_total, 0) == 0\n\n    @lru_cache(maxsize=None)\n    def traverse(self, subset_sum, index):\n        if subset_sum < 0:\n            return float('inf')\n        elif index == len(self.nums):\n            return subset_sum\n        else:\n            include = self.traverse(subset_sum - self.nums[index], index + 1)\n            exclude = self.traverse(subset_sum, index + 1)\n            best = min(include, exclude)\n            return best\n\n\ntest_case = [20,68,68,11,48,18,50,5,3,51,52,11,13,11,38,100,30,87,1,56,85,63,14,96,7,17,54,11,32,61,94,13,85,10,78,57,69,92,66,28,70,20,3,29,10,73,89,86,28,48,69,54,87,11,91,32,59,4,88,20,81,100,29,75,79,82,6,74,66,30,9,6,83,54,54,53,80,94,64,77,22,7,22,26,12,31,23,26,65,65,35,36,34,1,12,44,22,73,59,99]\nsolution = Solution()\nstart = dt.datetime.now()\nprint(solution.canPartition(test_case))\nend = dt.datetime.now()\nprint((end-start).total_seconds())\n```\n\nThis is the official answer. It takes only ```\n0.000165```\n seconds!\n```\nimport datetime as dt\nfrom typing import List, Tuple\nfrom functools import lru_cache\n\n\nclass Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        @lru_cache(maxsize=None)\n        def dfs(nums: Tuple[int], n: int, subset_sum: int) -> bool:\n            # Base cases\n            if subset_sum == 0:\n                return True\n            if n == 0 or subset_sum < 0:\n                return False\n            result = (dfs(nums, n - 1, subset_sum - nums[n - 1])\n                    or dfs(nums, n - 1, subset_sum))\n            return result\n\n        # find sum of array elements\n        total_sum = sum(nums)\n\n        # if total_sum is odd, it cannot be partitioned into equal sum subsets\n        if total_sum % 2 != 0:\n            return False\n\n        subset_sum = total_sum // 2\n        n = len(nums)\n        return dfs(tuple(nums), n - 1, subset_sum)\n\n\ntest_case = [20,68,68,11,48,18,50,5,3,51,52,11,13,11,38,100,30,87,1,56,85,63,14,96,7,17,54,11,32,61,94,13,85,10,78,57,69,92,66,28,70,20,3,29,10,73,89,86,28,48,69,54,87,11,91,32,59,4,88,20,81,100,29,75,79,82,6,74,66,30,9,6,83,54,54,53,80,94,64,77,22,7,22,26,12,31,23,26,65,65,35,36,34,1,12,44,22,73,59,99]\nsolution = Solution()\nstart = dt.datetime.now()\nprint(solution.canPartition(test_case))\nend = dt.datetime.now()\nprint((end-start).total_seconds())\n```\n\n    ", "Answer": "\r\nIn the former version, all possible cases are searched. While in the latter, the algorithm stops when a feasible solution has been found.\nIn the first version:\n```\ninclude = self.traverse(subset_sum - self.nums[index], index + 1)\n# Suppose {include} is zero, the answer is already obtained, \n# but the algorithm still try to compute {exclude}, which is not neccessary.\nexclude = self.traverse(subset_sum, index + 1)\n```\n\nIn the second version:\n```\nresult = (dfs(nums, n - 1, subset_sum - nums[n - 1])\n                    or dfs(nums, n - 1, subset_sum))\n# Because of the short-circuit behavior of logical operator,\n# if the first branch has already obtained the solution, \n# the second branch will not be executed.\n```\n\nJust adding a if-check will improve the performance:\n```\ninclude = self.traverse(subset_sum - self.nums[index], index + 1)\n# Check whether we are already done:\nif include == 0:\n    return include\nexclude = self.traverse(subset_sum, index + 1)\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "How does Dynamic Programming help in the subset sum problem to reduce time complexity?\r\n                \r\nIn the Subset Sum problem, if we don't use the Dynamic Programming approach, then we have an exponential time complexity. But if we draw the recursion tree, it seems that all the 2^n branches are unique. If we use dynamic programming, how can we assure that all the unique branches are explored? If there really exists 2^n possible solutions, how does dynamic programming reduce it to polynomial time while also ensuring all 2^n solutions are explored?\n    ", "Answer": "\r\n\nHow does dynamic programming reduce it to polynomial time while also ensuring all 2^n solutions are explored?\n\nIt is pseudo polynomial time, not polynomial time. It's a very important distinction. According to Wikipedia, A numeric algorithm runs in pseudo-polynomial time if its running time is a polynomial in the numeric value of the input, but not necessarily in the length of the input, which is the case for polynomial time algorithms.\n\nWhat does it matter?\n\nConsider an example [1, 2, 3, 4], sum = 1 + 2 + 3 + 4 = 10.\nThere does in fact exist 2^4 = 16 subsequences, however, do we need to check them all? The answer is no, since we are only concerned about the sum of subsequence. To illustrate this, let's say we're iterating from the 1st element to the 4th element:\n1st element:\nWe can choose to take or not take the 1st element, so the possible sum will be [0, 1].\n2nd element:\nWe can choose to take or not to take the 2nd element. Same idea, possible sum will be [0, 1, 2, 3].\n3rd element:\nWe have [0, 1, 2, 3] now. We now consider taking the third element.  But wait... If we take the third element and add it to 0, we still get 3, which is already present in the array, do we need to store this piece of information? Apparently not. In fact, we only need to know whether a sum is possible at any stage. If there are multiple subsequences summing to the same value, we ignore it. This is the key to the reduction of complexity, if you consider it as a reduction.\nWith that said, a real polynomial solution for subset sum is not known since it is NP-complete\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Python Coin Change Dynamic Programming\r\n                \r\nI am currently trying to implement dynamic programming in Python, but I don't know how to setup the backtracking portion so that it does not repeat permutations.\nFor example, an input would be (6, [1,5]) and the expected output should be 2 because there are 2 possible ways to arrange 1 and 5 so that their sum is equivalent to 6. Those combinations are {1,1,1,1,1,1} and {1,5} but the way my program currently works, it accounts for the combinations displayed above and the combination {5,1}. This causes the output to be 3 which is not what I wanted. So my question is \"How do I prevent from repeating permutations?\". My current code is shown below.\n\n```\n    import collections as c\n\n    class DynamicProgram(object):\n        def __init__(self):\n            self.fib_memo = {}\n            # nested dictionary, collections.defaultdict works better than a regular nested dictionary\n            self.coin_change_memo = c.defaultdict(dict)\n            self.__dict__.update({x:k for x, k in locals().items() if x != 'self'})\n        def coin_change(self, n, coin_array):\n            # check cache\n            if n in self.coin_change_memo:\n                if len(coin_array) in self.coin_change_memo[n]:\n            return [n][len(coin_array)]\n\n            # base cases\n            if n < 0: return 0\n            elif n == 1 or n == 0: return 1\n\n            result = 0\n            i = 0\n\n            # backtracking (the backbone of how this function works)\n            while i <= n and i < len(coin_array):\n                result += self.coin_change(n-coin_array[i], coin_array)\n                i += 1\n\n            # append to cache\n            self.coin_change_memo[n][len(coin_array)] = result\n\n            # return result\n            return result\n```\n\n    ", "Answer": "\r\nOne of the way of avoiding permutation is to use the numbers in \"non-decreasing\" order. By doing so you will never add answer for [5 1] because it is not in \"non-decreasing\" order.And [1 5] will be added as it is in \"non-decreasing\" order.\n\nSo the change in your code will be if you fix to use the ith number in sorted order than you will never ever use the number which is strictly lower than this.\n\nThe code change will be as described in Suparshva's answer with initial list of numbers sorted.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "What are overlapping subproblems in Dynamic Programming (DP)?\r\n                \r\nThere are two key attributes that a problem must have in order for dynamic programming to be applicable: optimal substructure and overlapping subproblems [1]. For this question, we going to focus on the latter property only.\nThere are various definitions for overlapping subproblems, two of which are:\n\nA problem is said to have overlapping subproblems if the problem can be broken down into subproblems which are reused several times OR a recursive algorithm for the problem solves the same subproblem over and over rather than always generating new subproblems [2].\nA second ingredient that an optimization problem must have for dynamic programming to apply is that the space of subproblems must be \"small\" in the sense that a recursive algorithm for the problem solves the same subproblems over and over, rather than always generating new subproblems (Introduction to Algorithms by CLRS)\n\nBoth definitions (and lots of others on the internet) seem to boil down to a problem having overlapping subproblems if finding its solution involves solving the same subproblems multiple times. In other words, there are many small sub-problems which are computed many times during finding the solution to the original problem. A classic example is the Fibonacci algorithm that lots of examples use to make people understand this property.\nUntil a couple of days ago, life was great until I discovered Kadane's algorithm which made me question the overlapping subproblems definition. This was mostly due to the fact that people have different views on whether or NOT it is a DP algorithm:\n\nDynamic programming aspect in Kadane's algorithm\n\nIs Kadane's algorithm consider DP or not? And how to implement it recursively?\nIs Kadane's Algorithm Greedy or Optimised DP?\nDynamic Programming vs Memoization (see my comment)\n\nThe most compelling reason why someone wouldn't consider Kadane's algorithm a DP algorithm is that each subproblem would only appear and be computed once in a recursive implementation [3], hence it doesn't entail the overlapping subproblems property. However, lots of articles on the internet consider Kadane's algorithm to be a DP algorithm, which made me question my understanding of what overlapping subproblems means in the first place.\nPeople seem to interpret the overlapping subproblems property differently. It's easy to see it with simple problems such as the Fibonacci algorithm but things become very unclear once you introduce Kadane's algorithm for instance. I would really appreciate it if someone could offer some further explanation.\n    ", "Answer": "\r\nYou've read so much about this already.  The only thing I have to add is this:\nThe overlapping subproblems in Kadane's algorithm are here:\nmax_subarray = max( from i=1 to n [ max_subarray_to(i) ] )\nmax_subarray_to(i) = max(max_subarray_to(i-1) + array[i], array[i])\nAs you can see, max_subarray_to() is evaluated twice for each i.  Kadane's algorithm memoizes these, turning it from O(n2) to O(n)\n... But as @Stef says, it doesn't matter what you call it, as long as you understand it.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Object stacking, dynamic programming\r\n                \r\nI'm working with a problem that is similar to the box stacking problem that can be solved with a dynamic programming algorithm. I read posts here on SO about it but I have a difficult time understanding the DP approach, and would like some explanation as to how it works. Here's the problem at hand:\n\n\n  Given X objects, each with its own weight 'w' and strength 's', how\n  many can you stack on top of each other? An object can carry its own\n  weight and the sum of all weights on top of it as long as it does not\n  exceed its strength.\n\n\nI understand that it has an optimal substructure, but its the overlapping subproblem part that confuses me. I'm trying to create a recursion tree to see where it would calculate the same thing several times, but I can't figure out if the function would take one or two parameters for example.\n    ", "Answer": "\r\nThe first step to solving this problem is proving that you can find an optimal stack with boxes ordered from highest to lowest strength.\n\nThen you just have to sort the boxes by strength and figure out which ones are included in the optimal stack.\n\nThe recursive subproblem has two parameters:  find the best stack you can put on top of a stack with X remaining strength, using boxes at positions >= Y in the list.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming Solution for \"Demerging\" of two Sequences\r\n                \r\nI have a problem that I am trying to solve but am having very little luck getting started. Here is the problem:\n\n\"If two sequences a1, a2,..., am and b1, b2,..., bn are interleaved, we say that the resulting sequence c1, c2,..., cm+n is a shuffle of the first two. For example, \n\nDCCDBDADCACDBACB \n\nis a shuffle of DCBDAACBB and CDDCDAC since it can be obtained by interleaving those two sequences in this way: \n\n```\n DC           BDA            AC          B             B \n\n       CD              DC            D          AC\"\n```\n\n\nI am to find a dynamic programming solution that figures out whether the two given subsequences are able to be merged to form the larger sequence. I have already done a problem finding the longest common subsquence and such but I can't seem to figure this one out. I know how I would go about doing it if I were to not consider dynamic programming, but I can't seem to think of how to do it with it.\n\nAny help would be greatly appreciated.\n\nThank you!\n    ", "Answer": "\r\nYou can construct a DP algorithm for solving this but first creating a recursive solution for example:\n\n```\na = 'DCBDAACBB'\nb = 'CDDCDAC'\nc = 'DCCDBDADCACDBACB'\n\nan = len(a)\nbn = len(b)\ncn = len(c)\n\n\n# recursive solution O(2^n)\ndef isPossible(ai, bi, ci):\n\n    if ai == an and bi == bn and ci == cn:\n        return True\n\n    K = False\n\n    if ci < cn and ai < an and c[ci] == a[ai]:\n        K = K or isPossible(ai+1, bi, ci+1)\n\n    if ci < cn and bi < bn and c[ci] == b[bi]:\n        K = K or isPossible(ai, bi+1, ci+1)\n\n    return K\n\nprint isPossible(0, 0, 0)\n```\n\n\nHere the state can be encoded as three numbers ```\nai, bi, ci```\n which indicate the index of the beginning of the suffix of the original strings and ```\nisPossible(ai, bi, ci)```\n computes whether the suffixes ```\nai```\n and ```\nbi```\n can be merged into the suffix ```\nci```\n, we seek ```\nisPossible(0, 0, 0)```\n.\n\nFrom here we can create the following DP recurrence, first initialize:\n\n```\nisPossible[ai][bi][ci] = False\nisPossible[ai][bi][ci] = True where ai == an and bi == bn and ci == cn\n```\n\n\nThen compute:\n\n```\nisPossible[ai][bi][ci] = isPossible[ai+1][bi][ci+1] if A[ai] == C[ai]\nisPossible[ai][bi][ci] = isPossible[ai][bi+1][ci+1] if B[ai] == C[ai]\n```\n\n\nThe solution is then ```\nisPossible[0][0][0]```\n. This runs in n^3, where as the recursive solution was 2^n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming - Number of combinations to reach a given target\r\n                \r\nThis is a basic dynamic programming problem - Number of score combinations. I am aware of the bottom up approach for this problem which works well.\n\nHowever, I am unable to work towards finding a top-down solution approach for the problem. Caching the recursive part gives us more than necessary combinations(where ordering/sequence of scores is also a factor, so, to avoid it we need to provide a constraint to make the sequence increase monotonically. Here is recursive approach for the same. Dynamic Programming - Number of distinct combinations to reach a given score\n\nHere is my current code:\n\n```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint helper(int target, vector<int>& coins, vector<int>& cache, int min) {\n    if(target < 0) return 0;\n    if(target == 0) return 1;\n    if(cache[target] != 0) return cache[target];\n\n    for(auto& c : coins) {\n        if(target >= c && min <= c) {\n            //cout << min << \" \" << c << \" \" << target << endl;\n            cache[target] += helper(target-c, coins, cache, c) ;\n            //cout << cache[target] << endl;            \n        }\n\n    }\n\n    return cache[target];\n\n}\n\n\nint main() {\n\n    vector<int> coins{2, 3};\n\n    int target = 7;\n    vector<int> cache(target+1, 0);\n    cache[0] = 1;\n    cache [7] = helper(target, coins, cache, 1);\n\n    for (auto& x : cache) cout << x << endl;\n    return 0;\n}\n```\n\n\nHere is  run-able ideone link.\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Can I solve this problem with Dynamic Programming?\r\n                \r\nHow I find among all pairs ```\na```\n and ```\nb```\n with a \"least common multiple\" LCM(a,b) = 498960 and a \"greatest common divisor\" GDM(a, b) = 12 a pair with minimum sum ```\na + b```\n?\nI solved this with O(n^2) time:\n```\npublic class FindLcmAndGcdClass {\n    private int findGcd(int a, int b) {\n        if (a % b == 0) {\n            return b;\n        }\n        return findGcd(b, a % b);\n    }\n\n    private int findLcm(int a, int b, int gcd) {\n        return (a * b) / gcd;\n    }\n\n    private void run() {\n        int minSum = Integer.MAX_VALUE;\n        int foundNumberOne = 0;\n        int foundNumberTwo = 0;\n        for (int i = 12; i <= 498960; i += 12) {\n            for (int j = i; j <= 498960; j += 12) {\n                int gcd;\n                if (i < j) {\n                    gcd = findGcd(j, i);\n                } else {\n                    gcd = findGcd(i, j);\n                }\n                int lcm = findLcm(i, j, gcd);\n\n                if (gcd == 12 && lcm == 498960 && i + j < minSum) {\n                    minSum = i + j;\n                    foundNumberOne = i;\n                    foundNumberTwo = j;\n                }\n            }\n        }\n        System.out.println(minSum);\n        System.out.println(foundNumberOne);\n        System.out.println(foundNumberTwo);\n    }\n\n\n    public static void main(String[] args) {\n        var o = new FindLcmAndGcdClass();\n        o.run();\n    }\n}\n```\n\nAnd it executes quite slowly! I guess the problem can be solved with Dynamic Programming. Can anyone help with more fast solution?\n    ", "Answer": "\r\nI am not sure if this question can be solved with dynamic programming, but I think of a solution with time complexity ```\nO(sqrt(LCM * GCD))```\n.\nIt is well known that for any two integers a and b, ```\nLCM(a, b) * GCD(a, b) = a * b```\n. Therefore, you can first calculate the product of the gcd and lcm, (which is 5987520 in this question). Then for all its factors under ```\nsqrt(LCM * GCD)```\n, let ```\na```\n be one of the factors, then ```\nb = LCM * GCD / a```\n. Test if gcd(a, b) = the required gcd, if so calculate the sum ```\na + b```\n, then find the minimum among the sums, and you are done.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Common Interface for FrameworkElement and FrameworkContentElement with dynamic programming\r\n                \r\nI try to cut it short: FrameworkElement and FrameworkContentElement share a lot of the same API but do not have a common Interface. Only DependencyObject as a base class.\n\nI've come across this implementation of IFrameworkElement, which manually adds an interface and two wrapper classes. Now this code comes is implemented in .NET 3.5 and the author remarks that it would be a lot easier to do with dynamic programming in .NET 4:\n\n\n  The actual code is very simple, but about 624 lines long for each element. (It will be a much simpler one line implementation in a dynamic language - C# 4.0 is coming :) ).\n\n\nI would be very curious how an implementation of that would look like. I assume it would boil down to a dynamic implementation of ```\nIFrameworkElement```\n, and read about ```\nExpandoObject```\n and ```\nDynamicObject```\n to see if I could implement myself, but I'm a bit stumped. I guess one can write a custom implementation of DynamicObject - but that isn't a one liner. Could this be really made that easy with dynamic programming? I doesn't even need to be a one liner, I'd be fine with 10 or even 100 lines instead of the original 1250.\n\nI'm thinking something like this:\n\n```\n// Example, not working:\npublic IFrameworkElement AsFrameworkElement(FrameworkElement ele)\n{\n  dynamic ife = ele as IFrameworkElement;\n  return ife;    \n}\n\nIFrameworkElement frameworkElement = AsFrameworkElement(new Button());\nframeworkElement.DataContext = \"Whatever\";\n\nIFrameworkElement frameworkContentElement = AsFrameworkElement(new Paragraph());\nframeworkContentElement.DataContext = \"Whatever again\";\n```\n\n    ", "Answer": "\r\nLook at the original code of the blog:\n\n```\nvar dataContect = \"DataContext\";\nvar frameworkElement = sender as FrameworkElement;\nif ( frameworkElement != null )\n{\n    frameworkElement.DataContext = dataContect;\n}\nelse\n{\n    var frameworkContentElement = sender as FrameworkContentElement;\n    if ( frameworkContentElement != null )\n    {\n        frameworkContentElement.DataContext = dataContect;\n    }\n}\n```\n\n\nIt would become\n\n```\nvar dataContext = \"DataContext\"\ndynamic element = sender;\nelement.DataContext = dataContext;\n```\n\n\nThat's it already. At runtime, a property with the name ```\nDataContext```\n will be searched for by reflection (be careful: when it comes to lists of dynamic types, things might slow down terribly), and then it is invoked.\n\nNote: if the property does not exist, a ```\nRuntimeBinderException```\n will be thrown. You might add some try...catch around the last line.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Why cannot Rat In a Maze problem be solved by dynamic programming?\r\n                \r\nThe problem I am talking about is the one below :\n```\nConsider a rat placed at (0, 0) in a square matrix m[ ][ ] of order n and has to reach the destination at (n-1, n-1). \nThe task is to find a sorted array of strings denoting all the possible directions which the rat can take to reach the destination at (n-1, n-1). \nThe directions in which the rat can move are ‘U'(up), ‘D'(down), ‘L’ (left), ‘R’ (right).\nYou cannot visit an already visited cell.\n\nExamples: \n\nInput : N = 4 \n1 0 0 0 \n1 1 0 1 \n0 1 0 0 \n0 1 1 1\nOutput :\nDRDDRR\n\nInput :N = 4 \n1 0 0 0 \n1 1 0 1 \n1 1 0 0 \n0 1 1 1\nOutput :\nDDRDRR DRDDRR\n```\n\nWhy cannot it be solved by dynamic programming? Can't we store all path strings from a given cell?\nProblem Link\n    ", "Answer": "\r\nDP only works when you can decompose the problem into smaller problems. For most grid problems that DP works on, there's a limitation that you can only move down and to the right, like LC #62, Unique Paths.\nBut in this case, you can move in all 4 directions, so the ability to carve out subproblems is no longer available. What would the subproblems be? For the limited-movement version, it's the smaller grid, but when you can move backwards to previous regions, there is no more concept of \"smaller grid\" that you can define after each movement.\nSure, you mark a cell visited, but that's not really a subproblem in the DP sense that having an answer to the number of paths through the grid without the cell helps you build an answer to the grid with the cell.\nIn Unique Paths, on the other hand, you can blindly trust the subproblem's answer, add to it to build larger answers, and never need to revisit that area of the grid again.\nThis is just a graph theory problem which you would solve with an exhaustive recursive traversal. For each stack frame, mark the cell visited, then step in all 4 directions, adding each move to the sequence of moves so far. Whenever you reach the destination, yield the sequence as the next result.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "A problem that may be dynamic programming\r\n                \r\nI encounter a problem. After some search, it seems a bit like dynamic programming, like knapsack problems or number division problems, but a little different from the typical ones. I'm not sure how to solve this problem. (If it is a typical problem please tell me its name)\n\nGiven n items of various weights, and many identical knapsacks of\ncapacity W to carry them all. Find the best combination of items\nthat minimize the number of knapsacks to use.\nFor example: Given 4 items of weights 1，3，8，10; knapsack capacity 11;\nthe best combination is {1, 10} and {3, 8} that uses only 2 knapsacks.\n\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming algorithm for sentence separation problem?\r\n                \r\nI have to find a dynamic programming algorithm that solves the following problem, and I seem to be stuck: \n\n\n  Given a function f(w) that returns the frequency at which the word w appears in the English language (0 <= f(w) <= 1), the algorithm divideSentence(s) where s is a string of letters with no spaces must return the value of f(w) of all words in s such that divideSentence is maximised. For example: divideSentence(helloworld) should return f(hello) + f(world)\n\n\nI understand that with dynamic programming, I can limit the amount of calls to f by storing the intermediate values in say a hashmap, but the way I see it, there are 2^n ways to divide the sentence and I can't see how it's possible to find the solution without trying the 2^n different solutions, because f(hell)+f(o) != f(hello). Although the teacher said it was possible to find an algorithm that finds the solution in O(n²) so clearly I'm missing something...\n\nCan someone point me in the right direction?\n    ", "Answer": "\r\nHere is the dynamic programming solution for the above problem.\n\nLet A[] be the array where A[i] means the answer considering the first i characters. So the final answer will be A[s.length()-1] (considering 0 based indexing) where s is the input string with no spaces.\n\nNow the algorithm is as follows:\n\n```\nfor i = 0:n\n    for j = 0:i\n        A[i]=max(A[i],A[j]+f(s.substring(j+1,i)))\n    endfor\nendfor\n\nreturn A[n-1]\n```\n\n\nwhere n is the size of input string.\nThe final answer is stored in A[n-1].  \n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Final product of matrix multiplication in dynamic programming?\r\n                \r\nI'm using dynamic programming to find the optimal order of multiplying matrices.\nAfter calculating the right order, How can I calculate the final product of these matrices?\nI mean for example I have these matrices:\n\n```\nm = [40,20,30,10,30]\n```\n\n\nThe optimal order of multiplying is:\n\n```\n((A1(A2A3))A4)\n```\n\n\nHow can I use this optimal parenthesis to calculate the final product of ((A1(A2A3))A4)?\n(Assume I have the value of A1 - An) \n    ", "Answer": "\r\nAssuming you have a dict with the matrices, such as ```\nmatrices = {'A1': ..., 'A2': ...}```\n, and these are Numpy arrays, you can modify the string to include ```\n__matmul__```\n operators ```\n@```\n and then compute the result with ```\neval```\n:\n\n```\nimport re\nimport numpy as np\n\nmatrices = {f'A{i}': np.random.randint(0, 10, size=(2, 2)) for i in range(1, 5)}\n\nequation = '((A1(A2A3))A4)'\nequation = re.sub('(?<=[0-9)])(?=[(A])', '@', equation)\nresult = eval(equation, {}, matrices)\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Shortest subset sum of arr dynamic programming\r\n                \r\nMy goal is to find the shortest subset of an array that its sum is equal to target. I tried to use the following solution (with dynamic programming):\n```\npublic static List<Integer> bestSum_efficient(int targetSum, int[] numbers) {\n    return bestSum_efficient(targetSum, numbers, new HashMap<>());\n}\n\npublic static List<Integer> bestSum_efficient(int targetSum, int[] numbers, Map<Integer, List<Integer>> map) {\n    if (map.containsKey(targetSum)) {\n        return map.get(targetSum);\n    }\n    if (targetSum == 0)\n        return new ArrayList<>();\n    if (targetSum < 0)\n        return null;\n\n    List<Integer> shortestCombination = null;\n    for (int n : numbers) {\n        List<Integer> remainedCombination = bestSum_efficient(targetSum - n, numbers,map);\n        if (remainedCombination != null) {\n            remainedCombination.add(n);\n\n        if (shortestCombination == null || shortestCombination.size() > remainedCombination .size()) {\n                shortestCombination = remainedCombination ;\n            }\n        }\n    }\n    map.put(targetSum, shortestCombination);\n    return shortestCombination;\n}\n```\n\nWith this code I tried to run the following test:\n```\nSystem.out.println(bestSum_efficient(8, new int[]{1, 4, 5})); // [4,4]\n```\n\nI got: ```\n[4,1,4]```\n\nWhen I changed the content of the first if to the following, everything worked fine:\n```\n  for (int n : numbers) {\n    List<Integer> remainedCombination = bestSum_efficient(targetSum - n, numbers,map);\n    if (remainedCombination != null) {\n        List<Integer> combination = new ArrayList<>();\n        combination.add(n);\n        combination.addAll(remainedCombination);\n\n    if (shortestCombination == null || shortestCombination.size() > combination.size()) {\n            shortestCombination = combination;\n        }\n    }\n}\n```\n\nWhy does creating a new combination list each in each iteration worked, while using the remainingCombination list that returned didn't?\n    ", "Answer": "\r\nAfter squeezing my brain for a while, I think that I have found the root cause of this issue.\nIn the first scenario:\n```\n        List<Integer> remainedCombination = bestSum_efficient(targetSum - n, numbers,map);\n        if (remainedCombination != null) {\n            remainedCombination.add(n);\n```\n\nWe modify directly the list ```\nremainedCombination```\n by adding ```\nn```\n at the end of it. This will actually modify the entry of the ```\nHashMap```\n that we use for memoization, when the function ```\nbestSum_efficient```\n returns the saved entry via the lines:\n```\n    if (map.containsKey(targetSum)) {\n        return map.get(targetSum);\n    }\n```\n\nas in this situation ```\nremainedCombination```\n will be a reference to ```\nmap.get(targetSum)```\n, so doing ```\nremainedCombination.add(n);```\n is the equivalent of doing ```\nmap.get(targetSum).add(n)```\n;\nHowever we only want to modify the entries of the HashMap at the end of the ```\nbestSum_efficient```\n function if we find a shortest way to reach the target sum and not directly in the ```\nfor```\n loop before checking the length condition ```\n if (shortestCombination == null || shortestCombination.size() > remainedCombination .size()) {```\n\nIn the 2nd (working) example, we create a new temporary ```\nArrayList```\n\n```\n        List<Integer> combination = new ArrayList<>();\n        combination.add(n);\n        combination.addAll(remainedCombination);\n```\n\nbefore adding ```\nn```\n there. This will therefore not affect the ```\nHashMap```\n used for the memoization, that will only be modified just before the ```\nreturn```\n of the function:\n```\n    map.put(targetSum, shortestCombination);\n    return shortestCombination;\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Box Stacking Variation-Dynamic Programming\r\n                \r\nQuestion 1: You are given many slabs each with a length and a breadth. A slab i can be put on slab j if both dimensions of i are less than that of j. In this similar manner, you can keep on putting slabs on each other. Find the maximum stack possible which you can create out of the given slabs.\n\nQuestion 2: The above question was raised to 3 dimensions.\n\nQuestion 3: The above question was then raised to k dimensions.\n\nI believe we can apply dynamic programming to the above question.But \n\n\n  \"A slab i can be put on slab j if both dimensions of i are less than\n  that of j\".\n\n\nNot getting a clear idea on how to sort based on both the dimensions.\n    ", "Answer": "\r\nI don't think Dynamic Programming is necessary in this problem, here's my suggestion:\n\n\nCreate a graph ```\nG```\n with a vertex set ```\nV```\n- representing all the slabs, and no edges. ( ```\nO(|V|)```\n )\nFor each pair of slabs ```\ni```\n and ```\nj```\n in ```\nV```\n, check if one can be on top the other (compare any number of dimensions). Say slab ```\ni```\n can be on top of slab ```\nj```\n, add an edge ```\ni->j```\n to the graph. If ```\ni```\n and ```\nj```\n are of the same dimensions, a single edge should be added. ( ```\nO(|V|^2)```\n )\n\nThe resulting graph is a DAG, since for any 3 slabs ```\ni,j,k```\n , if ```\ni```\n can be on top ```\nj```\n, and ```\nj```\n can be on top ```\nk```\n, then ```\nk```\n cannot be on top of ```\ni```\n.\n\nIn order to avoid cycles when 3 or more slabs are of the same size (e.g. ```\ni->j, j->k, k->i```\n), if 2 slabs are of the same size, the direction of the edge will be from the smaller index to the larger (e.g. if ```\ni```\n and ```\nj```\n are equal in dimensions, then the edge we'll add is ```\ni->j```\n)\nFind the longest path in ```\nG```\n. This path represent the stack with the maximum number of slabs.\n\nFinding such path in a DAG is an easy task and can be performed in linear time ( ```\nO(|V|+|E|)```\n ).\n\n\nThe total running time of this algorithm is ```\nO(|V|)```\n + ```\nO(|V|^2)```\n + ```\nO(|V|+|E|)```\n = ```\nO(|V|^2)```\n.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "length longest common subsequence without dynamic programming\r\n                \r\nI am doing an exercise to find the longest common subsequence (LSC) without dynamic programming, so far I have the code that returns the longest common subsequence but I also need to return the length of the sequence, what do I have to do?\nthis is the code that returns the longest common subsequence\n```\ndef lcs(str1, str2):\n    \n    if len(str1) == 0 or len(str2) == 0:\n        return \"\"\n    if str1[-1] == str2[-1]:\n        return lcs(str1[:-1], str2[:-1]) + str1[-1]\n  \n    t1 = lcs(str1[:-1], str2)\n    t2 = lcs(str1, str2[:-1])\n    if len(t1) > len(t2):\n        return t1\n    else:\n        return t2\n\n\n```\n\nHow do I return the length of the sequence?\n    ", "Answer": "\r\nJust have your ```\nreturn```\n statements return the length of the string that would have been returned in the original:\n```\ndef lcs(str1, str2):\n    if len(str1) == 0 or len(str2) == 0:\n        return 0 #len(\"\")\n    if str1[-1] == str2[-1]:\n        return lcs(str1[:-1], str2[:-1]) + 1\n    return max(lcs(str1[:-1], str2),lcs(str1, str2[:-1]))\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming to find minimum number of coins\r\n                \r\nI'm trying to understand part of a question I have as my HW but it really looks like Chinese...\n\nLet's say we have coins ```\nx_1, x_2, x_3, ... x_n```\n.  ```\nx_1 = 1```\n always.\nWe want to give a certain amount of money in a minimum number of coins.\nThen we use dynamic programming.\n\nAnd now I don't understand this  -  ```\nc(i,j) = min { c(i-1,j), 1+c(i,j-x_i) }```\n\nwhere ```\nc(i,j)```\n is the minimal amount of coins to return amount ```\nj```\n.\n    ", "Answer": "\r\n```\nc(i,j-x_i)```\n is the minimal number of coins to get the value ```\nj-x_i```\n using only coins ```\ni,i+1,...,n```\n (This is the induction hypothesis, that's what the recursive formula ensures us). \nThus, ```\n1+c(i,j-x_i)```\n is the minimal way to get ```\nj-x_i```\n with the given set of coins + an extra coin valued ```\nx_i```\n, which we decided to use.\n\nFrom this, ```\nc(i,j) = min { c(i-1,j), 1+c(i,j-x_i) }```\n is actually choosing \"what is best\" exhaustively: \n\n\nTaking the current coin, and checking recursively the rest of the smaller problem\nDeciding not to take it - and again, checking the smaller problem recursively.\n\n\nTaking the minimal of those ensures us (because it is done exhaustively - over all possibilities) that ```\nc(i,j)```\n is minimal.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming and Knapsack Application\r\n                \r\nIm studying dynamic programming and am looking to solve the following problem, which can be found here http://www.cs.berkeley.edu/~vazirani/algorithms/chap6.pdf:\n\nYou are given a rectangular piece of cloth with dimensions X by Y, where X and Y are positive integers, and a list of n products that can be made using the cloth. For each product i in [1,n] you know that a rectangle of cloth of dimensions ai by bi is needed and that the final selling price of the product is ci. Assume that ai, bi, and ci are all positive integers. You have a machine that can cut any rectangular piece of cloth into two pieces either horizontally or vertically. Design an algorithm that finds the best strategy for cutting an X by Y piece of cloth so that the products made from the resulting pieces give the maximum sum of selling prices. You are free to make as many copies of a given product as you wish, or none if desired. (From Algorithms by Dasgupta, Papadimitriou, and Vazirani.)\n\nIt seems we have a sort of 2-dimensional knapsack problem, but I'm thinking it may be possible to just solve it with the traditional knapsack algorithm by considering the weights as the areas of the rectangles.  Does this seem like a reasonable approach?\n\nThis is a programming assignment for a course I'm taking so please only include conceptual discussion and/or pseudo-code to illustrate ideas.\n    ", "Answer": "\r\nSo you start with a ```\nX * Y```\n rectangle. Say the optimal solution involves making a vertical (or horizontal) cut, then you have two new rectangles with dimensions ```\nX * Y1```\n and ```\nX * Y2```\n with ```\nY1 + Y2 = Y```\n. Since you want to maximize your profit, you need to maximize the profit on these new rectangles (optimal substructure). So your initial recursion goes as follows: ```\nf(X, Y) = max(f(X, Y1) + f(X, Y2), f(X1, Y) + f(X2, Y))```\n for all posible values of ```\nX1, X2```\n (horizontal cut) and ```\nY1, Y2```\n (vertical cut).\n\nNow the question is when do I actually decide to make a product ? You can decide to make a product when one of its dimensions equals one of the dimensions of your current rectangle (why ? Because if this doesn't hold, and the optimal solution includes making this product, then sooner or later you will need to make a vertical (or horizontal) cut and this case is already handled in the initial recursion), so you make the appropriate cut and you have a new rectangle ```\nX * Y1```\n (or ```\nX1 * Y```\n), depending on the cut you made to obtain the product), in this case the recursion becomes ```\nf(X, Y) = cost of product + f(X1, Y)```\n.\n\nThe solution of the original problem is ```\nf(X, Y)```\n. The running time of this dp solution would be ```\nO(X * Y * (X + Y + number of available products))```\n: you have ```\nX * Y```\n possible rectangles, for each of these you try every possible cut (```\nX + Y```\n) and you try to make one of the available products out of this rectangle.\n\nAlso, check out this similar problem: Sharing Chocolate from the 2010 ICPC World Finals.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming and Knapsack Application\r\n                \r\nIm studying dynamic programming and am looking to solve the following problem, which can be found here http://www.cs.berkeley.edu/~vazirani/algorithms/chap6.pdf:\n\nYou are given a rectangular piece of cloth with dimensions X by Y, where X and Y are positive integers, and a list of n products that can be made using the cloth. For each product i in [1,n] you know that a rectangle of cloth of dimensions ai by bi is needed and that the final selling price of the product is ci. Assume that ai, bi, and ci are all positive integers. You have a machine that can cut any rectangular piece of cloth into two pieces either horizontally or vertically. Design an algorithm that finds the best strategy for cutting an X by Y piece of cloth so that the products made from the resulting pieces give the maximum sum of selling prices. You are free to make as many copies of a given product as you wish, or none if desired. (From Algorithms by Dasgupta, Papadimitriou, and Vazirani.)\n\nIt seems we have a sort of 2-dimensional knapsack problem, but I'm thinking it may be possible to just solve it with the traditional knapsack algorithm by considering the weights as the areas of the rectangles.  Does this seem like a reasonable approach?\n\nThis is a programming assignment for a course I'm taking so please only include conceptual discussion and/or pseudo-code to illustrate ideas.\n    ", "Answer": "\r\nSo you start with a ```\nX * Y```\n rectangle. Say the optimal solution involves making a vertical (or horizontal) cut, then you have two new rectangles with dimensions ```\nX * Y1```\n and ```\nX * Y2```\n with ```\nY1 + Y2 = Y```\n. Since you want to maximize your profit, you need to maximize the profit on these new rectangles (optimal substructure). So your initial recursion goes as follows: ```\nf(X, Y) = max(f(X, Y1) + f(X, Y2), f(X1, Y) + f(X2, Y))```\n for all posible values of ```\nX1, X2```\n (horizontal cut) and ```\nY1, Y2```\n (vertical cut).\n\nNow the question is when do I actually decide to make a product ? You can decide to make a product when one of its dimensions equals one of the dimensions of your current rectangle (why ? Because if this doesn't hold, and the optimal solution includes making this product, then sooner or later you will need to make a vertical (or horizontal) cut and this case is already handled in the initial recursion), so you make the appropriate cut and you have a new rectangle ```\nX * Y1```\n (or ```\nX1 * Y```\n), depending on the cut you made to obtain the product), in this case the recursion becomes ```\nf(X, Y) = cost of product + f(X1, Y)```\n.\n\nThe solution of the original problem is ```\nf(X, Y)```\n. The running time of this dp solution would be ```\nO(X * Y * (X + Y + number of available products))```\n: you have ```\nX * Y```\n possible rectangles, for each of these you try every possible cut (```\nX + Y```\n) and you try to make one of the available products out of this rectangle.\n\nAlso, check out this similar problem: Sharing Chocolate from the 2010 ICPC World Finals.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Box Stacking Variation-Dynamic Programming\r\n                \r\nQuestion 1: You are given many slabs each with a length and a breadth. A slab i can be put on slab j if both dimensions of i are less than that of j. In this similar manner, you can keep on putting slabs on each other. Find the maximum stack possible which you can create out of the given slabs.\n\nQuestion 2: The above question was raised to 3 dimensions.\n\nQuestion 3: The above question was then raised to k dimensions.\n\nI believe we can apply dynamic programming to the above question.But \n\n\n  \"A slab i can be put on slab j if both dimensions of i are less than\n  that of j\".\n\n\nNot getting a clear idea on how to sort based on both the dimensions.\n    ", "Answer": "\r\nI don't think Dynamic Programming is necessary in this problem, here's my suggestion:\n\n\nCreate a graph ```\nG```\n with a vertex set ```\nV```\n- representing all the slabs, and no edges. ( ```\nO(|V|)```\n )\nFor each pair of slabs ```\ni```\n and ```\nj```\n in ```\nV```\n, check if one can be on top the other (compare any number of dimensions). Say slab ```\ni```\n can be on top of slab ```\nj```\n, add an edge ```\ni->j```\n to the graph. If ```\ni```\n and ```\nj```\n are of the same dimensions, a single edge should be added. ( ```\nO(|V|^2)```\n )\n\nThe resulting graph is a DAG, since for any 3 slabs ```\ni,j,k```\n , if ```\ni```\n can be on top ```\nj```\n, and ```\nj```\n can be on top ```\nk```\n, then ```\nk```\n cannot be on top of ```\ni```\n.\n\nIn order to avoid cycles when 3 or more slabs are of the same size (e.g. ```\ni->j, j->k, k->i```\n), if 2 slabs are of the same size, the direction of the edge will be from the smaller index to the larger (e.g. if ```\ni```\n and ```\nj```\n are equal in dimensions, then the edge we'll add is ```\ni->j```\n)\nFind the longest path in ```\nG```\n. This path represent the stack with the maximum number of slabs.\n\nFinding such path in a DAG is an easy task and can be performed in linear time ( ```\nO(|V|+|E|)```\n ).\n\n\nThe total running time of this algorithm is ```\nO(|V|)```\n + ```\nO(|V|^2)```\n + ```\nO(|V|+|E|)```\n = ```\nO(|V|^2)```\n.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "length longest common subsequence without dynamic programming\r\n                \r\nI am doing an exercise to find the longest common subsequence (LSC) without dynamic programming, so far I have the code that returns the longest common subsequence but I also need to return the length of the sequence, what do I have to do?\nthis is the code that returns the longest common subsequence\n```\ndef lcs(str1, str2):\n    \n    if len(str1) == 0 or len(str2) == 0:\n        return \"\"\n    if str1[-1] == str2[-1]:\n        return lcs(str1[:-1], str2[:-1]) + str1[-1]\n  \n    t1 = lcs(str1[:-1], str2)\n    t2 = lcs(str1, str2[:-1])\n    if len(t1) > len(t2):\n        return t1\n    else:\n        return t2\n\n\n```\n\nHow do I return the length of the sequence?\n    ", "Answer": "\r\nJust have your ```\nreturn```\n statements return the length of the string that would have been returned in the original:\n```\ndef lcs(str1, str2):\n    if len(str1) == 0 or len(str2) == 0:\n        return 0 #len(\"\")\n    if str1[-1] == str2[-1]:\n        return lcs(str1[:-1], str2[:-1]) + 1\n    return max(lcs(str1[:-1], str2),lcs(str1, str2[:-1]))\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming: Number of ways of partitioning a set of numbers [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is not reproducible or was caused by typos. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     This question was caused by a typo or a problem that can no longer be reproduced. While similar questions may be on-topic here, this one was resolved in a way less likely to help future readers.\r\n                \r\n                    \r\n                        Closed 4 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nWhile reading an algorithm book, I found the following exercise.\n\n\n  Given a set of n elements, write an algorithm that finds number of\n  ways of partitioning it.\n  Example: When n = 2, there are 2 ways of partitioning the set(into\n  two sets with one element, or into the original set and the empty set).\n\n\nAnd instead of the algorithm, I tried the python code using dynamic programming. \n\n```\ndef ways(n):\n    dp = [0]*(n+1), \n    sum = [0]*(n+1) ## declaring 2 arrays of n+1 size\n    dp[0] = 0\n    dp[1] = 1\n    sum[0] = 0\n    sum[1] = 1\n    lastcalc = 1     # last calculated var\n    for i in range (2,n):\n        if lastcalc < i/2 : \n            for j in range (lastcalc, i/2):\n                sum[j] = sum[j-1] + dp[j]\n        lastcalc = (i/2) # update the lastcalculated variable\n        dp[i] = sum[i/2]\n    return dp[n]\n\nprint(ways(2))\n```\n\n\nBut, the code won't work and gave me an error.\n\n\n  TypeError: 'tuple' object does not support item assignment\n\n\nMy question: how can I fix this? Can I say this code applied a dynamic programming?\n    ", "Answer": "\r\nYou have a comma at the end of the declaration of ```\ndp```\n. This makes it a tuple, not a list, and tuple are not modifiable. Just remove it, it's a typo. \n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming - catching ball\r\n                \r\nI'm trying to solve the following problem:\n\n\n  Balls are falling from the sky. We know at which location (on a\n  straight line) will each ball drop, and we know the time (in seconds)\n  at which will the ball reach the ground. We are trying to catch them\n  into a ball net, which we can move left or right, but each movement\n  costs 1 second. The initial position of a ballnet is always on the left (position 0). We are allowed to > drop (not catch) k number of balls.\n  \n  What is the highest score we can achieve?\n\n\nMy first attempt at solving this was a greedy algorithm: \n\n```\nif the |next ball position - current position of the ball net| > (time of the next ball - current time) \n     then attempts++\n     if attempts>k\n           print game over\nelse\n     current ball net position = next ball position\n     current time = time of the next ball\n     score++\n```\n\n\nhowever my algorithm doesn't take into consideration that sometimes it's better to sacrifice some number of balls in order to reach a higher score in the long run. This needs an approach via dynamic programming, I think.\n\nIs this problem a known one so I can find some help? Could you help me with this problem? I can solve this in a greedy way, however I am failing to do it dynamically.\n\nThanks\n    ", "Answer": "\r\nFor any given ball you can either catch it (if possible), or drop it and lose a \"life\". In order to decide if you should sacrifice a life for any given ball, create a decision tree in which you either catch the ball or drop the ball. Your tree will fan out, creating 2^n subproblems. At each level of the tree, you will have at maximum k unique subproblems, since you reach that point with anywhere from 1 to k lives. Create a matrix with the best score you can get for the ith ball with k lives left if you catch it. You can then reference those values to avoid excess work. When k and the number of balls are small, you can use dynamic programming to examine all possible combinations of catches/drops in a manageable amount of time.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "MS Dynamics programming environment\r\n                \r\nIs it possible to setup MS Dynamics programming/development environment on single PC for self-study purposes for free? How to setup?\n    ", "Answer": "\r\nYou can set a trial version of CRM Dynamics Online for 30 days. Check here. After set the trial download the training kit and sdk to study.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Stack of Boxes - Dynamic Programming\r\n                \r\nI am currently practicing some dynamic programming. I came across the Stack of Boxes.\nThe boxes are represented as:\n\n```\nstruct Box{\n    double h;\n    double w;\n    double d;\n};\n```\n\n\nAnd the problem is creating the highest stack of boxes where each box in the stack is larger (in both width and depth) than the one above it. Let's assume that in this case boxes cannot be rotated. \n\nI am storing the boxes in a ```\nstd::vector<Box>```\n. I am first doing a stable sort by width and then by depth, so that whenever I pick a box I will only need to search forward for the next box that fits. \n\nAnd here is my question - Is this optimal?\nI guess that every time I picked a box I need to search linear time (O(n)) in order to pick the next possible box.\nIs there a different way to store the boxes that might be better in time complexity?\n\nAny other optimizations are also welcome of course.\n\n\n\nMy full code:\n\n```\n//Get index of next box that fits or -1 if none\nint getP(std::vector<Box>& boxes, int n){\n    double n_w = boxes[n].w;\n    double n_d = boxes[n].d;\n    for (int i=n-1; i >= 0; i--){\n        if (n_w > boxes[i].w && n_d > boxes[i].d)\n            return i;\n    }\n    return -1;\n}\n\n//Get highest possible stack.\ndouble stackOfBoxes(std::vector<Box>& boxes, int n, Box* bottom){\n    if (n == -1)\n        return 0;\n    if (bottom == NULL || (bottom->d > boxes[n].d && bottom->w > boxes[n].w))\n        return max(stackOfBoxes(boxes, n-1, bottom),stackOfBoxes(boxes, getP(boxes,n), &boxes[n])+boxes[n].h);\n    else\n        return stackOfBoxes(boxes, n-1, bottom);\n}\n\n\nint main(){\n    std::vector<Box> boxes = { {3,1,1},{5,2,2},{10,7,7} };\n    std::stable_sort(boxes.begin(), boxes.end(), sortByW);\n    std::stable_sort(boxes.begin(), boxes.end(), sortByD);\n\n    cout << stackOfBoxes(boxes, 2, NULL) << endl;\n}\n```\n\n    ", "Answer": "\r\n\n  And here is my question - Is this optimal?\n\n\nIt is incorrect.\n\nI tried your code with the same input, except for the depth of the third box which I made ```\n0.5```\n.\n\nHere is the result. It gives 15 where the answer should be 10 since no other box can fit on top of the third one.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Is there a rule of thumb for refactoring code to make use of Dynamic Programming concepts?\r\n                \r\nNew to Dynamic Programming.\nI have pseudo-code for an algorithm that takes in a list of non-negative integers and the desired sum, then outputs true if the given sum can be made from the given integers (no integers can be used more than once), and false if not. I will post my pseudo-code below. This is how I intuitively solved the problem, and I don't believe it follows dynamic programming concepts.\nSo my question is: Is there a neat trick for refactoring existing code to follow a more Dynamic Programming approach?\nPseudo-code:\n```\n1. Make a 2D boolean array \"arr\" of size n + 1 row and sum + 1 columns and all cells will be false initially.\n\n2. The value of \"arr[i][j]\" will be true if there is a subset of list[0..j-1] with a sum equal to i\n\n3. Assign all the values of first column to true  subset[i][0] = true because if target is 0 then it is also possible\n\n4. Assign false to first row \"subset[0][i] = false\" bacause if sum is not 0 and list is empty, then answer is false\n\n5. Run a for loop from i = 1 to i <= n and for each i do the following \n    // Fill the subset table in botton up manner\n    a) Run a for loop from j = 1 to j <= sum and for each j do the following:\n\n    i) if (j < list[i - 1]) then assign arr[i][j] = arr[i - 1][j];\n    ii) if (j >= list[i - 1]) or arr[i - 1][j - list[i - 1]] then assign arr[i][j] = arr[i - 1][j]\n\n6. Now if the value of arr[n][sum] is true that means we have a set which sums upto to given target and if it has false then we do not have\n```\n\n    ", "Answer": "\r\nYou pseudocode describes a bottom-up DP algorithm, so-called because it computes solutions to subproblems in a fixed order, from \"small\" to \"large\". The order is designed so that, by the time we come to solve a particular subproblem, we have already computed all the solutions to subsubproblems that we need for doing so. Bottom-up DP algorithms usually involve filling a (possibly multidimensional) array in some regular order.\nThe other kind of DP is a top-down DP. This looks like a recursive function in which the argument values completely determine the subproblem to solve, but with 2 small changes which together are called memoisation (note no \"R\"):\n\nBefore returning the solution value, we store it in a data structure (usually an array or hashtable) keyed by the function argument values, so that it can be quickly found next time the function is called with the same arguments.\nNear the top of the function, we check whether the solution to the subproblem described by the arguments has already been solved and stored in the data structure, and if so, return it immediately instead of computing it again.\n\nNeither approach is \"better than\" the other across the board. If solutions to all possible subproblems are needed to solve the top-level problem, bottom-up is usually faster by a modest constant factor, since memory access patterns are more regular, we can avoid setting up and taking down a stack frame for each subproblem, and we avoid the need to test whether a subproblem has already been solved, which can reduce the number of branch mispredictions. OTOH, top-down solves only the subproblems that need to be solved, so if that is only a small fraction of all possible subproblems, it will be faster.\nI personally find it much easier to attack a problem by first looking for a way to solve it recursively; once this is working, it can very easily be turned into a top-down DP algorithm by adding memoisation on top. Only if I'm looking to squeeze the most possible performance out of the algorithm will I then start looking for a subproblem order that would enable a bottom-up DP.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Leetcode Target sum of dynamic programming\r\n                \r\nGiven n and target, find the number of combinations of number from [1,2,...,n] adding up to target. The number can be repeatedly picked (1 + 1 + 2 = 4), however the combinations cannot be duplicated ({1,1,2} and {1,2,1} are regard as one combination). e.g.\nn = 2, target = 4: {1,1,1,1}, {1,1,2}, {1,3}, {2,2}, so return 4\nSince we only need to return the number of combinations, we use dynamic programming as following:\n```\nint sum(int n, int target) {\n    vector<int> dp(target + 1);\n    dp[0] = 1;\n    for (int i = 1; i <= target; ++i) {\n        for (int j = 1; j <= n; j++) {\n            if (i >= j) dp[i] += dp[i - j];\n        }\n    }\n    return dp.back();\n}\n```\n\nHowever this solution is for duplicated combinations:{1,1,1,1}, {1,1,2}, {1,2,1}, {2,1,1}, {1,3}, {3,1} {2,2}, so return 7.\nDo you know how to modify it to remove the duplications?\n    ", "Answer": "\r\nSimple modification\n```\n  for (int j = 1; j <= n; j++) {\n        for (int i = j; i <= target; i++) {\n            dp[i] += dp[i - j];\n        }\n    }\n```\n\nhelps to avoid using small values after larger value, so code counts only sorted combinations\nAlike question with specific coin nominals instead of 1..n values\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Implementing Activity Selection Prob using Dynamic Programming\r\n                \r\nHow to implement Activity Selection Problem using Dynamic Programming (CLRS Exercise 16.1-1). I've implemented it using Greedy Method, which runs in linear time (assuming array is already sorted with finish time). \n\nI know it poses Optimal substructure.\n\nLet ```\n$S_{ij}$```\n the set of activities that start after activity ```\n$a_i$```\n finishes and\nthat finish before activity ```\n$a_j$```\n starts. If we denote the size of an optimal solution for the set ```\n$S_{ij}$ by $c[i j]$```\n , then we would have the recurrence\n\n```\n$c[i j]  = c[i k] + c[k j] + 1$\n```\n\n    ", "Answer": "\r\nWe can solve it using dynamic programming by keeping a state that contains the detail about the current index of the activity and the current finish time of the activity so far which we have taken, at each index of the activity we can make 2 decisions either to choose a activity or not, and finally we need to take the maximum of both the choices and recurse.\nI have implemented a recursive dp solution in c++ : \n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nint st[1000], en[1000];\nint dp[1000][1000];\n\nint solve(int index, int currentFinishTime){\n    if(index == n) return 0;\n    int v1 = 0, v2 = 0;\n    if(dp[index][currentFinishTime] != -1) return dp[index][currentFinishTime];\n\n    //do not choose the current activity\n    v1 = solve(index+1, currentFinishTime);\n\n    //try to choose the current activity\n    if(st[index] >= currentFinishTime){\n        v2 = solve(index+1, en[index]) + 1;\n    }\n    return dp[index][currentFinishTime] = max(v1, v2);\n}\n\nint main(){\n    cin >> n;\n    for(int i = 0;i < n;i++) cin >> st[i] >> en[i];\n    memset(dp, -1, sizeof dp);\n\n    cout << solve(0, 0) << endl;\nreturn 0;\n}\n```\n\n\nhttp://ideone.com/m0mxx2\n\nIn this code the ```\ndp[index][finish time]```\n is the dp table used to store the result.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming Bottoms up approach clarification [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        What is the difference between bottom-up and top-down?\r\n                            \r\n                                (9 answers)\r\n                            \r\n                    \r\n                Closed 2 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nSo I have been really trying to grasp Dynamic Programming. I can say that I really understand the memoization top down approach, but the bottoms up approach is really confusing to me. I was able to solve rods cutting top down, but I had to seek the solution for the bottoms up. I just don't understand when to use a 1D array or a 2D array. Then the for loop within the bottoms up is just confusing. Can anyone help me understand the differences in these two codes conceptually?\n\r\n\r\n```\n// Top Down Memoizaton: \n\nconst solveRodCuttingTop = function(lengths, prices, n) {\n  return solveRodCuttingHelper(0, lengths, prices, n); \n};\n\nfunction solveRodCuttingHelper(idx, span, prices, n, memo = []) {\n  // BASE CASES \n  if (idx === span.length || n <= 0 || prices.length !== span.length) {\n    return 0;\n  }\n  let included = 0, excluded = 0; \n  memo[idx] = memo[idx] || []; \n\n  if (memo[idx][n] !== undefined) return memo[idx][n]; \n\n  if (span[idx] <= n) {\n    included = prices[idx] + solveRodCuttingHelper(idx, span, prices, n - span[idx], memo);\n  }\n\n  excluded = solveRodCuttingHelper(idx + 1, span, prices, n, memo);\n\n  memo[idx][n] = Math.max(included, excluded); \n  \n  return memo[idx][n];\n}\n\n\n\n// Bottoms up \nconst solveRodCuttingBottom = function(lengths, prices, n) {\n  const rods = Array.from({length: n + 1});\n  rods[0] = 0; \n  let maxRevenue = - Infinity;\n\n  for (let i = 1; i < rods.length; i++) {\n    for (let j = 1; j <= i; j++) {\n      maxRevenue = Math.max(maxRevenue, prices[j - 1] + rods[i - j])\n    }\n    rods[i] = maxRevenue\n  }\n  return rods[prices.length];\n};\n\nconst lengths = [1, 2, 3, 4, 5];\nconst prices = [2, 6, 7, 10, 13];```\n\r\n\r\n\r\n\n    ", "Answer": "\r\nThis is an interesting problem. Maybe I'm over-simplifying it, but if you first calculate each ```\nprice```\n per ```\nlength```\n, you can determine the solution by selling as much as possible at the highest rate. If the remaining rod is too short to sell at the best rate, move onto the next best rate and continue.\nTo solve using this technique, we first implement a ```\ncreateMarket```\n function which takes ```\nlenghts```\n and ```\nprices```\n as input, and calculates a price-per-length ```\nrate```\n. Finally the market is ```\nsort```\ned by rate in descending order -\n```\nconst createMarket = (lengths, prices) =>\n  lengths.map((l, i) => ({\n    length: l,                      // length\n    price: prices[i],               // price\n    rate: prices[i] / l             // price per length\n  }))\n  .sort((a, b) => b.rate - a.rate)  // sort by price desc\n\nconst lengths = [1, 2, 3, 4, 5]\nconst prices = [2, 6, 7, 10, 13]\n\nconsole.log(createMarket(lengths, prices))\n```\n\n```\n[\n  { length: 2, price: 6, rate: 3 },\n  { length: 5, price: 13, rate: 2.6 },\n  { length: 4, price: 10, rate: 2.5 },\n  { length: 3, price: 7, rate: 2.3333333333333335 },\n  { length: 1, price: 2, rate: 2 }\n]\n```\n\nNext we write recursive ```\nsolve```\n to accept a market, ```\n[m, ...more]```\n, and a ```\nrod```\n to cut and sell. The solution, ```\nsln```\n, defaults to ```\n[]```\n -\n```\nconst solve = ([m, ...more], rod, sln = []) =>\n  m == null\n    ? sln\n: m.length > rod\n    ? solve(more, rod, sln)\n: solve([m, ...more], rod - m.length, [m, ...sln])\n\nconst result =\n  solve(createMarket(lengths, prices), 11)\n\nconsole.log(result)\n```\n\n```\n[\n  { length: 1, price: 2, rate: 2 },\n  { length: 2, price: 6, rate: 3 },\n  { length: 2, price: 6, rate: 3 },\n  { length: 2, price: 6, rate: 3 },\n  { length: 2, price: 6, rate: 3 },\n  { length: 2, price: 6, rate: 3 }\n]\n```\n\nAbove, ```\nsolve```\n returns the rod lengths that sum to the maximum price. If you want the total price, we can ```\nreduce```\n the result and sum by ```\nprice```\n -\n```\nconst bestPrice =\n  solve(createMarket(lengths, prices), 11)\n    .reduce((sum, r) => sum + r.price, 0)\n\nconsole.log(bestPrice)\n```\n\n```\n32\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Recurrence Relation for Dynamic Programming Exercise\r\n                \r\nI received a dynamic programming assignment and I need help figuring out the recurrence relation. The problem is similar to the weighted interval problem, but it has a few additional restrictions:\n\n\nYou are given a series of ```\nN```\n time slots, each of the same duration.\nEach time slot ```\nk```\n, ```\n0 <= k < N```\n, is given a positive weight ```\nW[k]```\n.\nFor any time interval ```\n[i, j]```\n with ```\ni < j```\n, the weight ```\nW[i,j]```\n of that interval is:\n```\nW[i,j] = W[i+1] + W[i+2] + ... + W[j]```\n\nNotice that the weight ```\nW[i]```\n of the first time slot is not counted, hence any interval of length ```\n1```\n has a weight of ```\n0```\n.\n\n\nYou are given a value ```\nT < N```\n and asked to select exactly ```\nT```\n time slots such that the sum of the selected time intervals is maximized.\n\nExample: For ```\nN = 5```\n, ```\nT = 4```\n and the weights ```\nW = (3, 9, 1, 1, 7)```\n, selecting ```\nW[0, 1] = 9```\n and ```\nW[3, 4] = 7```\n will give a maximum weight of ```\n16```\n.\n    ", "Answer": "\r\nThis is a nice little problem... Define S(i, t) to be the max weight possible if the last slot (end of last range) selected was i and among the slots 0..i there are exactly t slots selected.\n\nThe DP decision is that we either add w[i] into S(i, t), or we do not because either slot i-1 was selected, or it was not.  So we have:\n\n```\nS(i, t) = max ( S(i-1, t-1) + w[i], S(j, t-1) for j = t-2..i-2 )\n```\n\n\nCases where t-1>i are meaningless.  So the base case is S(i, 1) = 0 for 0 <= i < N, and successive columns (t = 2,...,T) of the DP table are each one shorter than the last.  The desired answer is max ( S(j, T) for j = T-1..N-1 )\n\nHappily you can arrange the computation so that the maxima are computed incrementally, run time is O(NT), and space is O(N)\n\nWorking out your example, the DP table looks like this:\n\n```\n               t = \n         1    2    3    4\n       ------------------\ni = 0 |  0\n    1 |  0    9   \n    2 |  0    1   10\n    3 |  0    1    9   11\n    4 |  0    7    9   16\n```\n\n\nThe answer is max(11, 16) = 16\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming exercise for string cutting\r\n                \r\nI have been working on the following problem from this book.\n\n\n  A certain string-processing language offers a primitive operation which splits a string into two pieces. Since this operation involves copying the original string, it takes n units of time for a string of length n, regardless of the location of the cut. Suppose, now, that you want to break a string into many pieces. The order in which the breaks are made can affect the total running time. For example, if you want to cut a 20-character string at positions 3 and 10, then making the first cut at position 3 incurs a total cost of 20+17=37, while doing position 10 first has a better cost of 20+10=30.\n\n\nI need a dynamic programming algorithm that given m cuts, finds the minimum cost of cutting a string into m+1 pieces.\n    ", "Answer": "\r\nThe divide and conquer approach seems to me the best one for this kind of problem. Here is a Java implementation of the algorithm:\n\nNote: the array ```\nm```\n should be sorted in ascending order (use ```\nArrays.sort(m);```\n)\n\n```\npublic int findMinCutCost(int[] m, int n) {\n   int cost = n * m.length;\n   for (int i=0; i<m.length; i++) {\n      cost = Math.min(findMinCutCostImpl(m, n, i), cost);\n   }\n   return cost;\n}\n\nprivate int findMinCutCostImpl(int[] m, int n, int i) {\n   if (m.length == 1) return n;\n   int cl = 0, cr = 0;\n   if (i > 0) {\n      cl = Integer.MAX_VALUE;\n      int[] ml = Arrays.copyOfRange(m, 0, i);\n      int nl = m[i];\n      for (int j=0; j<ml.length; j++) {\n         cl = Math.min(findMinCutCostImpl(ml, nl, j), cl);\n      }\n   }\n   if (i < m.length - 1) {\n      cr = Integer.MAX_VALUE;\n      int[] mr = Arrays.copyOfRange(m, i + 1, m.length);\n      int nr = n - m[i];\n      for (int j=0; j<mr.length; j++) {\n         mr[j] = mr[j] - m[i];\n      }\n      for (int j=0; j<mr.length; j++) {\n         cr = Math.min(findMinCutCostImpl(mr, nr, j), cr);\n      }\n   }\n   return n + cl + cr;\n}\n```\n\n\nFor example :\n\n```\n int n = 20;\n int[] m = new int[] { 10, 3 };\n\n System.out.println(findMinCutCost(m, n));\n```\n\n\nWill print ```\n30```\n\n\n** Edit **\n\nI have implemented two other methods to answer the problem in the question. \n\n1. Median cut approximation\n\nThis method cut recursively always the biggest chunks. The results are not always the best solution, but offers a not negligible gain (in the order of +100000% gain from my tests) for a negligible minimal cut loss difference from the best cost.\n\n```\npublic int findMinCutCost2(int[] m, int n) {\n   if (m.length == 0) return 0;\n   if (m.length == 1) return n;\n      float half = n/2f;\n      int bestIndex = 0;\n      for (int i=1; i<m.length; i++) {\n         if (Math.abs(half - m[bestIndex]) > Math.abs(half - m[i])) {\n            bestIndex = i;\n         }\n      }\n      int cl = 0, cr = 0;\n      if (bestIndex > 0) {\n         int[] ml = Arrays.copyOfRange(m, 0, bestIndex);\n         int nl = m[bestIndex];\n         cl = findMinCutCost2(ml, nl);\n      }\n      if (bestIndex < m.length - 1) {\n         int[] mr = Arrays.copyOfRange(m, bestIndex + 1, m.length);\n         int nr = n - m[bestIndex];\n         for (int j=0; j<mr.length; j++) {\n         mr[j] = mr[j] - m[bestIndex];\n      }\n      cr = findMinCutCost2(mr, nr);\n   }\n   return n + cl + cr;\n}\n```\n\n\n2. A constant time multi-cut\n\nInstead of calculating the minimal cost, just use different indices and buffers. Since this method executes in a constant time, it always returns n. Plus, the method actually split the string in substrings.\n\n```\npublic int findMinCutCost3(int[] m, int n) {\n   char[][] charArr = new char[m.length+1][];\n   charArr[0] = new char[m[0]];\n   for (int i=0, j=0, k=0; j<n; j++) {\n      //charArr[i][k++] = string[j];   // string is the actual string to split\n      if (i < m.length && j == m[i]) {\n         if (++i >= m.length) {\n            charArr[i] = new char[n - m[i-1]];\n         } else {\n            charArr[i] = new char[m[i] - m[i-1]];\n         }\n         k=0;\n      }\n   }\n   return n;\n}\n```\n\n\nNote: that this last method could easily be modified to accept a ```\nString str```\n argument instead of ```\nn```\n and set ```\nn = str.length()```\n, and return a ```\nString[]```\n array from ```\ncharArr[][]```\n.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming, create a memo table longest stable subsequence\r\n                \r\nI have worked on a dynamic programming problem for quite some time now and am stuck, so any help is much appreciated.\nHere is the first part of the problem which I was able to get the tests to pass.\n\n```\ndef lssLength(a, i, j):\n    aj = a[j] if 0 <= j < len(a) else None\n    # Implement the recurrence below. Use recursive calls back to lssLength\n    assert 0 <= i <= len(a)\n    if i >= len(a) or j >= len(a):\n        return 0\n    if aj and abs(a[i] - a[j]) > 1:\n        return lssLength(a, i+1, j)\n    if aj is None or (abs(a[i] - a[j]) <= 1 and i != j):\n        return max(lssLength(a, i+1, j), lssLength(a, i+1, i) + 1)\n    else:\n        return lssLength(a, i+1, j)\n```\n\nHere are my test cases for the first problem:\n```\n    def test_lss_length(self):\n        # test 1\n        n1 = lssLength([1, 4, 2, -2, 0, -1, 2, 3], 0, -1)\n        print(n1)\n        self.assertEqual(4, n1)\n        # test 2\n        n2 = lssLength([1, 2, 3, 4, 0, 1, -1, -2, -3, -4, 5, -5, -6], 0, -1)\n        print(n2)\n        self.assertEqual(8, n2)\n        # test 3\n        n3 = lssLength([0, 2, 4, 6, 8, 10, 12], 0, -1)\n        print(n3)\n        self.assertEqual(1, n3)\n        # test 4\n        n4 = lssLength(\n            [4, 8, 7, 5, 3, 2, 5, 6, 7, 1, 3, -1, 0, -2, -3, 0, 1, 2, 1, 3, 1, 0, -1, 2, 4, 5, 0, 2, -3, -9, -4, -2, -3,\n             -1], 0, -1)\n        print(n4)\n        self.assertEqual(14, n4)\n```\n\nNow I need to take the recursive solution and convert it to dynamic programming, and this is where I am stuck. I am using the same tests as before, but the tests are failing. \n```\ndef memoizeLSS(a):\n    T = {}  # Initialize the memo table to empty dictionary\n    # Now populate the entries for the base case\n    # Now fill out the table : figure out the two nested for loops\n    # It is important to also figure out the order in which you iterate the indices i and j\n    # Use the recurrence structure itself as a guide: see for instance that T[(i,j)] will depend on T[(i+1, j)]\n    n = len(a)\n    for i in range(0, n+1):\n        for j in range(-1, n+1):\n            T[(i, j)] = 0\n    for i in range(n-1, -1, -1):\n        for j in range(n-1, -1, -1):\n            if abs(a[i] - a[j]) > 1:\n                try:\n                    T[(i, j)] = max(0, T[(i, j+1)], T[(i+1, j)])\n                except Exception:\n                    T[(i, j)] = 0\n            elif abs(a[i] - a[j]) <= 1 and i != j:\n                T[(i, j)] = T[(i+1, j+1)] + 1\n            else:\n                T[(i, j)] = max(0, T[(i+1, j+1)])\n    for i in range(n-2, -1, -1):\n        T[(i, -1)] = max(T[(i+1, -1)], T[(i+1, 0)], T[(i, 0)], 0)\n    return T\n```\n\nIf you've read all of this, thank you so much. I know it is a lot and really appreciate your time. Any pointers to reading materials, etc. is much appreciated.\nIf there are more details required, please let me know. Thanks.\n    ", "Answer": "\r\nYour solution only worked for the first test case. Below is a corrected version:\n```\ndef memoizeLSS(a):\n    T = {}  # Initialize the memo table to empty dictionary\n    n = len(a)\n    for j in range(-1, n):\n        T[(n, j)] = 0 # i = n and j\n\n    # Now populate the entries for the base case\n    # Now fill out the table : figure out the two nested for loops\n    # It is important to also figure out the order in which you iterate the indices i and j\n    # Use the recurrence structure itself as a guide: see for instance that T[(i,j)] will depend on T[(i+1, j)]\n    n = len(a)\n    for i in range(0, n + 1):\n        for j in range(-1, n + 1):\n            T[(i, j)] = 0            \n\n    for i in range(n-1, -1, -1):\n        for j in range(n-1, -1, -1):\n            aj = a[j] if 0 <= j < len(a) else None \n            if aj != None and abs(a[i] - a[j]) > 1:\n                T[(i, j)] = T[(i+1, j)]\n                \n            elif aj == None or abs(a[i] - a[j]) <= 1:\n                T[(i, j)] = max(T[(i+1, i)] + 1, T[(i + 1, j)])\n    for i in range(n-2, -1, -1):\n        T[(i, -1)] = max(T[(i+1, -1)], T[(i+1, 0)], T[(i, 0)], 0)\n\n    return T\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming Bottoms up approach clarification [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        What is the difference between bottom-up and top-down?\r\n                            \r\n                                (9 answers)\r\n                            \r\n                    \r\n                Closed 2 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nSo I have been really trying to grasp Dynamic Programming. I can say that I really understand the memoization top down approach, but the bottoms up approach is really confusing to me. I was able to solve rods cutting top down, but I had to seek the solution for the bottoms up. I just don't understand when to use a 1D array or a 2D array. Then the for loop within the bottoms up is just confusing. Can anyone help me understand the differences in these two codes conceptually?\n\r\n\r\n```\n// Top Down Memoizaton: \n\nconst solveRodCuttingTop = function(lengths, prices, n) {\n  return solveRodCuttingHelper(0, lengths, prices, n); \n};\n\nfunction solveRodCuttingHelper(idx, span, prices, n, memo = []) {\n  // BASE CASES \n  if (idx === span.length || n <= 0 || prices.length !== span.length) {\n    return 0;\n  }\n  let included = 0, excluded = 0; \n  memo[idx] = memo[idx] || []; \n\n  if (memo[idx][n] !== undefined) return memo[idx][n]; \n\n  if (span[idx] <= n) {\n    included = prices[idx] + solveRodCuttingHelper(idx, span, prices, n - span[idx], memo);\n  }\n\n  excluded = solveRodCuttingHelper(idx + 1, span, prices, n, memo);\n\n  memo[idx][n] = Math.max(included, excluded); \n  \n  return memo[idx][n];\n}\n\n\n\n// Bottoms up \nconst solveRodCuttingBottom = function(lengths, prices, n) {\n  const rods = Array.from({length: n + 1});\n  rods[0] = 0; \n  let maxRevenue = - Infinity;\n\n  for (let i = 1; i < rods.length; i++) {\n    for (let j = 1; j <= i; j++) {\n      maxRevenue = Math.max(maxRevenue, prices[j - 1] + rods[i - j])\n    }\n    rods[i] = maxRevenue\n  }\n  return rods[prices.length];\n};\n\nconst lengths = [1, 2, 3, 4, 5];\nconst prices = [2, 6, 7, 10, 13];```\n\r\n\r\n\r\n\n    ", "Answer": "\r\nThis is an interesting problem. Maybe I'm over-simplifying it, but if you first calculate each ```\nprice```\n per ```\nlength```\n, you can determine the solution by selling as much as possible at the highest rate. If the remaining rod is too short to sell at the best rate, move onto the next best rate and continue.\nTo solve using this technique, we first implement a ```\ncreateMarket```\n function which takes ```\nlenghts```\n and ```\nprices```\n as input, and calculates a price-per-length ```\nrate```\n. Finally the market is ```\nsort```\ned by rate in descending order -\n```\nconst createMarket = (lengths, prices) =>\n  lengths.map((l, i) => ({\n    length: l,                      // length\n    price: prices[i],               // price\n    rate: prices[i] / l             // price per length\n  }))\n  .sort((a, b) => b.rate - a.rate)  // sort by price desc\n\nconst lengths = [1, 2, 3, 4, 5]\nconst prices = [2, 6, 7, 10, 13]\n\nconsole.log(createMarket(lengths, prices))\n```\n\n```\n[\n  { length: 2, price: 6, rate: 3 },\n  { length: 5, price: 13, rate: 2.6 },\n  { length: 4, price: 10, rate: 2.5 },\n  { length: 3, price: 7, rate: 2.3333333333333335 },\n  { length: 1, price: 2, rate: 2 }\n]\n```\n\nNext we write recursive ```\nsolve```\n to accept a market, ```\n[m, ...more]```\n, and a ```\nrod```\n to cut and sell. The solution, ```\nsln```\n, defaults to ```\n[]```\n -\n```\nconst solve = ([m, ...more], rod, sln = []) =>\n  m == null\n    ? sln\n: m.length > rod\n    ? solve(more, rod, sln)\n: solve([m, ...more], rod - m.length, [m, ...sln])\n\nconst result =\n  solve(createMarket(lengths, prices), 11)\n\nconsole.log(result)\n```\n\n```\n[\n  { length: 1, price: 2, rate: 2 },\n  { length: 2, price: 6, rate: 3 },\n  { length: 2, price: 6, rate: 3 },\n  { length: 2, price: 6, rate: 3 },\n  { length: 2, price: 6, rate: 3 },\n  { length: 2, price: 6, rate: 3 }\n]\n```\n\nAbove, ```\nsolve```\n returns the rod lengths that sum to the maximum price. If you want the total price, we can ```\nreduce```\n the result and sum by ```\nprice```\n -\n```\nconst bestPrice =\n  solve(createMarket(lengths, prices), 11)\n    .reduce((sum, r) => sum + r.price, 0)\n\nconsole.log(bestPrice)\n```\n\n```\n32\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming to Minimize Sum of Squares\r\n                \r\nI have this question on a practise exam, and have no idea how to solve it, so I'm very scared for the final. Anyways, finding that this problem has an answer would be relieving and would help me understand dynamic programming, so thanks for reading :)\n\nProblem:\n\n\n  Given a sequence of n numbers a1, ..., an (positive or negative), we\n  want to divide the sequence into blocks so as to minimize the sum of\n  the squares of the block sums, subject to the constraint that each\n  block contains at least 2 and at most 4 elements. In other words, we\n  want to find 1 = i[0] < i[1] < i[2] < ... < i[k-1] < i[k] = n + 1 to\n  minimize (ai[0] + ... + ai[1]-1)^2 + (ai[1] + ... + ai[2]-1)^2 + ... +\n  (ai[k-1] + ... + ai[k]-1)^2, such that 2 <= i[1] - i[0] <= 4, 2 <=\n  i[2] - i[1] <= 4, ..., 2 <= i[k] - i[k-1] <= 4. (Note that the number\n  of blocks k is not given.) Present an O(n)-time dynamic programming\n  algorithm to solve the problem.\n\n\nMy problem: defining the subproblems. My only clue is to continuously find the minimum sums of length 4 down to 2, but what if there is 1 leftover? Does it join with an existing group of length 2 or 3, or does a 4-group split? Let alone getting it done in O(n)...\n    ", "Answer": "\r\nThe subproblem is: Find the miminum across the first k numbers.\nHere is how you reduce the problem to already solved subproblems:\n\nLet ```\nF(k)```\n be the minimum sum of squares when solved for ```\na1, a2, ... ak```\n.\n\nNow\n\n```\nF(2) = (a1+a2)^2\nF(3) = (a1+a2+a3)^2\nF(4) = min { (a1+a2+a3+a4)^2, (a1+a2)^2 + (a3+a4)^2 }\nF(5) = min { (a1+a2+a3)^2 + (a4+a5)^2, (a1+a2)^2 + (a3+a4+a5)^2 }\n\nF(n) = min {\n              F(n-2) + (a[n-1]+a[n])^2,\n              F(n-3) + (a[n-2]+a[n-1]+a[n])^2,\n              F(n-4) + (a[n-3]+a[n-2]+a[n-1]+a[n])^2\n       }\n```\n\n\nYou can write a simple function that computes F(k) for increasing values of k and stores them in an array.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming for String Matching in JAVA\r\n                \r\nI wish to search for a sequence within a source string however, the sequence might have allowed insertions. For example, the sequence: AG**GC would allow up to two insertions and it would match either AGGC or AGTGC or AGTTGC, etc. \n\nI have tried a dynamic programming approach in Java but can't seem to get it to work for a specified number of *. The program does not differentiate between one * and two *. So if I put a * it allows any number of insertions.\n\nDoes anyone have suggestions on how to make the * specify only one character?\n\n```\nimport java.util.Arrays; \npublic class GFG{      \n\n// Function that matches input str with \n// given wildcard pattern \nstatic boolean strmatch(String str, String pattern, \n                             int n, int m) \n{ \n    // empty pattern can only match with \n    // empty string \n    if (m == 0) \n        return (n == 0); \n\n    // lookup table for storing results of \n    // subproblems \n    boolean[][] lookup = new boolean[n + 1][m + 1]; \n\n    // initailze lookup table to false \n    for(int i = 0; i < n + 1; i++) \n        Arrays.fill(lookup[i], false); \n\n\n    // empty pattern can match with empty string \n    lookup[0][0] = true; \n\n    // Only '*' can match with empty string \n    for (int j = 1; j <= m; j++) \n        if (pattern.charAt(j - 1) == '*') \n            lookup[0][j] = lookup[0][j - 1]; \n\n    // fill the table in bottom-up fashion \n    for (int i = 1; i <= n; i++) \n    { \n        for (int j = 1; j <= m; j++) \n        { \n            // Two cases if we see a '*' \n            // a) We ignore '*'' character and move \n            //    to next  character in the pattern, \n            //     i.e., '*' indicates an empty sequence. \n            // b) '*' character matches with ith \n            //     character in input \n            if (pattern.charAt(j - 1) == '*') \n                lookup[i][j] = lookup[i][j - 1] || \n                               lookup[i - 1][j]; \n\n            // Current characters are considered as \n            // matching in two cases \n            // (a) current character of pattern is '?' \n            // (b) characters actually match \n            else if (pattern.charAt(j - 1) == '?' || \n                str.charAt(i - 1) == pattern.charAt(j - 1)) \n                lookup[i][j] = lookup[i - 1][j - 1]; \n\n            // If characters don't match \n            else lookup[i][j] = false; \n        } \n    } \n\n    return lookup[n][m]; \n} \n\npublic static void main(String args[]) \n{ \n    String str = \"baabab\"; \n    String pattern = \"ba**********ab\"; \n    // String pattern = \"ba*****ab\"; \n    // String pattern = \"ba*ab\"; \n    // String pattern = \"a*ab\"; \n    // String pattern = \"a*****ab\"; \n    // String pattern = \"*a*****ab\"; \n    // String pattern = \"ba*ab****\"; \n    // String pattern = \"****\"; \n    // String pattern = \"*\"; \n    // String pattern = \"aa?ab\"; \n    // String pattern = \"b*b\"; \n    // String pattern = \"a*a\"; \n    // String pattern = \"baaabab\"; \n    // String pattern = \"?baaabab\"; \n    // String pattern = \"*baaaba*\"; \n\n    if (strmatch(str, pattern, str.length(), \n                         pattern.length())) \n        System.out.println(\"YES\"); \n    else\n        System.out.println(\"No\"); \n\n} \n} \n```\n\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming, create a memo table longest stable subsequence\r\n                \r\nI have worked on a dynamic programming problem for quite some time now and am stuck, so any help is much appreciated.\nHere is the first part of the problem which I was able to get the tests to pass.\n\n```\ndef lssLength(a, i, j):\n    aj = a[j] if 0 <= j < len(a) else None\n    # Implement the recurrence below. Use recursive calls back to lssLength\n    assert 0 <= i <= len(a)\n    if i >= len(a) or j >= len(a):\n        return 0\n    if aj and abs(a[i] - a[j]) > 1:\n        return lssLength(a, i+1, j)\n    if aj is None or (abs(a[i] - a[j]) <= 1 and i != j):\n        return max(lssLength(a, i+1, j), lssLength(a, i+1, i) + 1)\n    else:\n        return lssLength(a, i+1, j)\n```\n\nHere are my test cases for the first problem:\n```\n    def test_lss_length(self):\n        # test 1\n        n1 = lssLength([1, 4, 2, -2, 0, -1, 2, 3], 0, -1)\n        print(n1)\n        self.assertEqual(4, n1)\n        # test 2\n        n2 = lssLength([1, 2, 3, 4, 0, 1, -1, -2, -3, -4, 5, -5, -6], 0, -1)\n        print(n2)\n        self.assertEqual(8, n2)\n        # test 3\n        n3 = lssLength([0, 2, 4, 6, 8, 10, 12], 0, -1)\n        print(n3)\n        self.assertEqual(1, n3)\n        # test 4\n        n4 = lssLength(\n            [4, 8, 7, 5, 3, 2, 5, 6, 7, 1, 3, -1, 0, -2, -3, 0, 1, 2, 1, 3, 1, 0, -1, 2, 4, 5, 0, 2, -3, -9, -4, -2, -3,\n             -1], 0, -1)\n        print(n4)\n        self.assertEqual(14, n4)\n```\n\nNow I need to take the recursive solution and convert it to dynamic programming, and this is where I am stuck. I am using the same tests as before, but the tests are failing. \n```\ndef memoizeLSS(a):\n    T = {}  # Initialize the memo table to empty dictionary\n    # Now populate the entries for the base case\n    # Now fill out the table : figure out the two nested for loops\n    # It is important to also figure out the order in which you iterate the indices i and j\n    # Use the recurrence structure itself as a guide: see for instance that T[(i,j)] will depend on T[(i+1, j)]\n    n = len(a)\n    for i in range(0, n+1):\n        for j in range(-1, n+1):\n            T[(i, j)] = 0\n    for i in range(n-1, -1, -1):\n        for j in range(n-1, -1, -1):\n            if abs(a[i] - a[j]) > 1:\n                try:\n                    T[(i, j)] = max(0, T[(i, j+1)], T[(i+1, j)])\n                except Exception:\n                    T[(i, j)] = 0\n            elif abs(a[i] - a[j]) <= 1 and i != j:\n                T[(i, j)] = T[(i+1, j+1)] + 1\n            else:\n                T[(i, j)] = max(0, T[(i+1, j+1)])\n    for i in range(n-2, -1, -1):\n        T[(i, -1)] = max(T[(i+1, -1)], T[(i+1, 0)], T[(i, 0)], 0)\n    return T\n```\n\nIf you've read all of this, thank you so much. I know it is a lot and really appreciate your time. Any pointers to reading materials, etc. is much appreciated.\nIf there are more details required, please let me know. Thanks.\n    ", "Answer": "\r\nYour solution only worked for the first test case. Below is a corrected version:\n```\ndef memoizeLSS(a):\n    T = {}  # Initialize the memo table to empty dictionary\n    n = len(a)\n    for j in range(-1, n):\n        T[(n, j)] = 0 # i = n and j\n\n    # Now populate the entries for the base case\n    # Now fill out the table : figure out the two nested for loops\n    # It is important to also figure out the order in which you iterate the indices i and j\n    # Use the recurrence structure itself as a guide: see for instance that T[(i,j)] will depend on T[(i+1, j)]\n    n = len(a)\n    for i in range(0, n + 1):\n        for j in range(-1, n + 1):\n            T[(i, j)] = 0            \n\n    for i in range(n-1, -1, -1):\n        for j in range(n-1, -1, -1):\n            aj = a[j] if 0 <= j < len(a) else None \n            if aj != None and abs(a[i] - a[j]) > 1:\n                T[(i, j)] = T[(i+1, j)]\n                \n            elif aj == None or abs(a[i] - a[j]) <= 1:\n                T[(i, j)] = max(T[(i+1, i)] + 1, T[(i + 1, j)])\n    for i in range(n-2, -1, -1):\n        T[(i, -1)] = max(T[(i+1, -1)], T[(i+1, 0)], T[(i, 0)], 0)\n\n    return T\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Fibonacci in Java using Dynamic Programming and Recursions\r\n                \r\nI'm new to Dynamic Programming so I tried to create a file and write it onto Array.txt in the download section. The logic is:\n\n```\nIf the Array is longer than the current array: Extend the array and copy to old array onto the new one\n```\n\n\nI, however, can't find a way to actually copy the section of the old array onto the new one.\nThe way that I am using right now is \n\n```\nSystem.arraycopy()\n```\n\n\nHere is the code:\n(Remember to swap out YOURUSERNAME with your current username on the computer to avoid getting an error)\n\n```\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.FileWriter;\nimport java.util.Arrays;\nimport java.io.FileNotFoundException;\nimport java.util.Scanner;\n\n\npublic class Fibonacci {\n\n    static void createFile() {\n        try {\n            File Array = new File(\"C:\\\\Users\\\\YOURUSERNAME\\\\Downloads\\\\Array.txt\");\n            if (Array.createNewFile()) {\n                System.out.println(\"File created: \" + Array.getName());\n            } else {\n                System.out.println(\"File already exists.\");\n            }\n        } catch (IOException e) {\n            System.out.println(\"An error occurred.\");\n            e.printStackTrace();\n        }\n    }\n\n    static void fileWrite(int[] array, int num) {\n        try {\n            FileWriter myWriter = new FileWriter(\"C:\\\\Users\\\\YOURUSERNAME\\\\Downloads\\\\Array.txt\");\n            if (num <= array.length) {\n                int[] newA = new int[array.length];\n                System.arraycopy(array, 0, newA, 0, array.length);\n                myWriter.write(Arrays.toString(newA));\n                myWriter.close();\n            }\n            System.out.println(\"Successfully wrote to the file.\");\n        } catch (IOException e) {\n            System.out.println(\"An error occurred.\");\n            e.printStackTrace();\n        }\n    }\n\n\n    static int[] fileRead(int[] Array1) {\n        try {\n            StringBuilder dataTotal = new StringBuilder();\n            File Array = new File(\"C:\\\\Users\\\\YOURUSERNAME\\\\Downloads\\\\Array.txt\");\n            Scanner myReader = new Scanner(Array);\n            while (myReader.hasNextLine()) {\n                String data = myReader.nextLine();\n                dataTotal.append(data);\n            }\n            myReader.close();\n            System.out.println(dataTotal);\n            dataTotal.deleteCharAt(0);\n            dataTotal.deleteCharAt(dataTotal.length() - 1);\n            String[] array1 = dataTotal.toString().split(\", \");\n            int[] array = new int[array1.length];\n            for (int i = 0; i < array1.length; i++) {\n                array[i] = Integer.parseInt(array1[i]);\n            }\n            return array;\n        } catch (FileNotFoundException e) {\n            System.out.println(\"An error occurred.\");\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    static int[] arrayCreator(int num) {\n        return new int[num];\n    }\n\n    static int fib(int num, int[] array1) {\n        int[] array = fileRead(array1);\n        if (num == 1 || num == 2) {\n            return 1;\n        }\n        else {\n            assert array != null;\n            if(array[num - 1] > 0) {\n                return array[num - 1];\n            } else {\n                array[num - 1] = fib(num - 1, array1) + fib (num - 2, array1);\n                fileWrite(array, num);\n            }\n        }\n        return array[num - 1];\n    }\n    public static void main(String[] args) {\n        int num = 10;\n\n\n        int[] array = arrayCreator(num);\n        createFile();\n        fileWrite(array, num);\n        System.out.println(fib(num, array));\n    }\n}\n```\n\n    ", "Answer": "\r\nTo extend an array by one element, you have two choices:\n\n\nUsing ```\nSystem.arraycopy()```\n\n\n```\nint[] newArray = new int[array.length + 1];\nSystem.arraycopy(array, 0, newArray, 0, array.length);\narray = newArray;\n```\n\nUsing ```\nArrays.copyOf()```\n\n\n```\narray = Arrays.copyOf(array, array.length + 1);\n```\n\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Need help in understanding Dynamic Programming approach for \"balanced 0-1 matrix\"?\r\n                \r\nProblem: I am struggling to understand/visualize the Dynamic Programming approach for \"A type of balanced 0-1 matrix in \"Dynamic Programming - Wikipedia Article.\"\n\nWikipedia Link: https://en.wikipedia.org/wiki/Dynamic_programming#A_type_of_balanced_0.E2.80.931_matrix\n\nI couldn't understand how the memoization works when dealing with a multidimensional array. For example, when trying to solve the Fibonacci series with DP, using an array to store previous state results is easy, as the index value of the array store the solution for that state.\n\nCan someone explain DP approach for the \"0-1 balanced matrix\" in simpler manner?\n    ", "Answer": "\r\nWikipedia offered both a crappy explanation and a not ideal algorithm.  But let's work with it as a starting place.\n\nFirst let's take the backtracking algorithm.  Rather than put the cells of the matrix \"in some order\", let's go everything in the first row, then everything in the second row, then everything in the third row, and so on.  Clearly that will work.\n\nNow let's modify the backtracking algorithm slightly.  Instead of going cell by cell, we'll go row by row.  So we make a list of the ```\nn choose n/2```\n possible rows which are half 0 and half 1.  Then have a recursive function that looks something like this:\n\n```\ndef count_0_1_matrices(n, filled_rows=None):\n    if filled_rows is None:\n        filled_rows = []\n    if some_column_exceeds_threshold(n, filled_rows):\n        # Cannot have more than n/2 0s or 1s in any column\n        return 0\n    else:\n        answer = 0\n        for row in possible_rows(n):\n            answer = answer + count_0_1_matrices(n, filled_rows + [row])\n        return answer\n```\n\n\nThis is a backtracking algorithm like what we had before.  We are just doing whole rows at a time, not cells.                \n\nBut notice, we're passing around more information than we need.  There is no need to pass in the exact arrangement of rows.  All that we need to know is how many 1s are needed in each remaining column.  So we can make the algorithm look more like this:\n\n```\ndef count_0_1_matrices(n, still_needed=None):\n    if still_needed is None:\n        still_needed = [int(n/2) for _ in range(n)]\n\n    # Did we overrun any column?\n    for i in still_needed:\n        if i < 0:\n            return 0\n\n    # Did we reach the end of our matrix?\n    if 0 == sum(still_needed):\n        return 1\n\n    # Calculate the answer by recursion.\n    answer = 0\n    for row in possible_rows(n):\n        next_still_needed = [still_needed[i] - row[i] for i in range(n)]\n        answer = answer + count_0_1_matrices(n, next_still_needed)\n\n    return answer\n```\n\n\nThis version is almost the recursive function in the Wikipedia version.  The main difference is that our base case is that after every row is finished, we need nothing, while Wikipedia would have us code up the base case to check the last row after every other is done.\n\nTo get from this to a top-down DP, you only need to memoize the function.  Which in Python you can do by defining then adding an ```\n@memoize```\n decorator.  Like this:\n\n```\nfrom functools import wraps\n\ndef memoize(func):\n    cache = {}\n    @wraps(func)\n    def wrap(*args):\n        if args not in cache:\n            cache[args] = func(*args)\n        return cache[args]\n    return wrap\n```\n\n\nBut remember that I criticized the Wikipedia algorithm?  Let's start improving it!  The first big improvement is this.  Do you notice that the order of the elements of ```\nstill_needed```\n can't matter, just their values?  So just sorting the elements will stop you from doing the calculation separately for each permutation.  (There can be a lot of permutations!)\n\n```\n@memoize\ndef count_0_1_matrices(n, still_needed=None):\n    if still_needed is None:\n        still_needed = [int(n/2) for _ in range(n)]\n\n    # Did we overrun any column?\n    for i in still_needed:\n        if i < 0:\n            return 0\n\n    # Did we reach the end of our matrix?\n    if 0 == sum(still_needed):\n        return 1\n\n    # Calculate the answer by recursion.\n    answer = 0\n    for row in possible_rows(n):\n        next_still_needed = [still_needed[i] - row[i] for i in range(n)]\n        answer = answer + count_0_1_matrices(n, sorted(next_still_needed))\n\n    return answer\n```\n\n\nThat little innocuous ```\nsorted```\n doesn't look important, but it saves a lot of work!  And now that we know that ```\nstill_needed```\n is always sorted, we can simplify our checks for whether we are done, and whether anything went negative.  Plus we can add an easy check to filter out the case where we have too many 0s in a column.\n\n```\n@memoize\ndef count_0_1_matrices(n, still_needed=None):\n    if still_needed is None:\n        still_needed = [int(n/2) for _ in range(n)]\n\n    # Did we overrun any column?\n    if still_needed[-1] < 0:\n        return 0\n\n    total = sum(still_needed)\n    if 0 == total:\n        # We reached the end of our matrix.\n        return 1\n    elif total*2/n < still_needed[0]:\n        # We have total*2/n rows left, but won't get enough 1s for a\n        # column.\n        return 0\n\n    # Calculate the answer by recursion.\n    answer = 0\n    for row in possible_rows(n):\n        next_still_needed = [still_needed[i] - row[i] for i in range(n)]\n        answer = answer + count_0_1_matrices(n, sorted(next_still_needed))\n\n    return answer\n```\n\n\nAnd, assuming you implement ```\npossible_rows```\n, this should both work and be significantly more efficient than what Wikipedia offered.\n\n=====\n\nHere is a complete working implementation.  On my machine it calculated the 6'th term in under 4 seconds.\n\n```\n#! /usr/bin/env python\n\nfrom sys import argv\nfrom functools import wraps\n\ndef memoize(func):\n    cache = {}\n    @wraps(func)\n    def wrap(*args):\n        if args not in cache:\n            cache[args] = func(*args)\n        return cache[args]\n    return wrap\n\n@memoize\ndef count_0_1_matrices(n, still_needed=None):\n    if 0 == n:\n        return 1\n\n    if still_needed is None:\n        still_needed = [int(n/2) for _ in range(n)]\n\n    # Did we overrun any column?\n    if still_needed[0] < 0:\n        return 0\n\n    total = sum(still_needed)\n    if 0 == total:\n        # We reached the end of our matrix.\n        return 1\n    elif total*2/n < still_needed[-1]:\n        # We have total*2/n rows left, but won't get enough 1s for a\n        # column.\n        return 0\n    # Calculate the answer by recursion.\n    answer = 0\n    for row in possible_rows(n):\n        next_still_needed = [still_needed[i] - row[i] for i in range(n)]\n        answer = answer + count_0_1_matrices(n, tuple(sorted(next_still_needed)))\n\n    return answer\n\n@memoize\ndef possible_rows(n):\n    return [row for row in _possible_rows(n, n/2)]\n\n\ndef _possible_rows(n, k):\n    if 0 == n:\n        yield tuple()\n    else:\n        if k < n:\n            for row in _possible_rows(n-1, k):\n                yield tuple(row + (0,))\n        if 0 < k:\n            for row in _possible_rows(n-1, k-1):\n                yield tuple(row + (1,))\n\nn = 2\nif 1 < len(argv):\n    n = int(argv[1])\n\nprint(count_0_1_matrices(2*n)))\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "binomial coefficient algorithm using dynamic programming and a single dimensional array\r\n                \r\nI'm know a dynamic programming algorithm to compute the binomial coefficients with two-dimensional array like below . Is there any way to make use of one-dimensional array?\n\n```\nint binomialCoeff(int n, int k)\n{\nint C[n+1][k+1];\nint i, j;\n\n\nfor (i = 0; i <= n; i++)\n {\n   for (j = 0; j <= min(i, k); j++)\n    {\n\n        if (j == 0 || j == i)\n            C[i][j] = 1;\n\n\n        else\n            C[i][j] = C[i-1][j-1] + C[i-1][j];\n    }\n    }\n\n  return C[n][k];\n  }\n```\n\n    ", "Answer": "\r\nYour Dynamic Programming method (using 2D array) to solve Binomial Coefficient, seems correct. Note that we do not need to keep the whole table, only the prior row. So 1D implementation is possible!\n\nBelow is the code to implement it using a 1D array.\n\n```\n    int binomial_coefficient(int n, int k)\n    {\n          int C[k+1];int i,j;\n          for(i=0;i<=k;i++)\n                 C[i]=0;\n          C[0]=1;\n          for(i=1;i<=n;i++)\n          {\n                 for(j=min(i,k);j>0;j--)\n                         C[j]=C[j]+C[j-1];\n          }\n          return C[k];\n    }\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming : perfect sum with negative numbers\r\n                \r\nGiven an array of integers and a sum, the task is to print all subsets of given array with sum equal to given sum.\n\n```\nExample: \nInput : arr[] = {1, 2, 3, 4, 5}\n        sum = 10\nOutput : [4 3 2 1]  \n         [5 3 2] \n         [5 4 1]\n\nInput : arr[] = {-1, 2, 3, 4, 5}\n        sum = 10\nOutput : [5 3 2] \n         [5 4 2 -1]\n```\n\n\nI have done that using dynamic programming in pseudo polynomial time. This is an extension of subset sum problem, which only takes care of deciding whether such a subset exist or not. My solution below works for both positive and negative numbers for the subset sum problem. However, it is not able to print the subsets correctly if the array contains negative numbers.The program is-\n\n```\nimport java.util.ArrayList;\n\n// sum problem\nclass GFG {\n\n    static boolean subset[][];\n\n    // Returns true if there is a subset of\n    // set[] with sun equal to given sum\n    static boolean isSubsetSum(int set[],\n                               int n, int sum) {\n        // The value of subset[i][j] will be\n        // true if there is a subset of\n        // set[0..j-1] with sum equal to i\n        subset = new boolean[n + 1][sum + 1];\n\n        // Fill the subset table in botton\n        // up manner\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <= sum; j++) {\n                if (j == 0) {\n                    subset[i][j] = true;\n                } else if (i <= 0 && sum >= 1)\n                    subset[i][j] = false;\n                else if (set[i - 1] > j)\n                    subset[i][j] = subset[i - 1][j];\n                else {\n                    if (set[i - 1] >= 0)\n                        subset[i][j] = subset[i - 1][j] || subset[i - 1][j - set[i - 1]];\n                    else\n                        subset[i][j] = subset[i - 1][j] || subset[i - 1][j + set[i - 1]];\n                }\n            }\n        }\n\n        // uncomment this code to print table\n//        for (int i = 0; i <= sum; i++)\n//        {\n//        for (int j = 0; j <= n; j++)\n//            System.out.println (subset[i][j]);\n//        }\n\n        return subset[n][sum];\n    }\n\n    /* Driver program to test above function */\n    public static void main(String args[]) {\n        int set[] = {1, 2, 3, 4, 5};\n        int sum = 10;\n        int n = set.length;\n        if (isSubsetSum(set, n, sum) == true)\n            System.out.println(\"Found a subset\"\n                    + \" with given sum\");\n        else\n            System.out.println(\"No subset with\"\n                    + \" given sum\");\n        System.out.println(\"Done\");\n        ArrayList<Integer> list = new ArrayList<>();\n        printSubsets(set, n, sum, list);\n        System.out.println(\"Finished\");\n    }\n\n    static void display(ArrayList<Integer> v) {\n        System.out.println(v);\n    }\n\n    private static void printSubsets(int[] set, int i, int sum, ArrayList<Integer> list) {\n        if (i == 0 && sum != 0 && subset[0][sum]) {\n            list.add(set[i]);\n            display(list);\n            list.clear();\n            return;\n        }\n\n        // If sum becomes 0\n        if (i == 0 && sum == 0) {\n            display(list);\n            list.clear();\n            return;\n        }\n\n        // If given sum can be achieved after ignoring\n        // current element.\n        if (subset[i - 1][sum]) {\n            // Create a new vector to store path\n            ArrayList<Integer> b = new ArrayList<>();\n            b.addAll(list);\n            printSubsets(set, i - 1, sum, b);\n        }\n\n        // If given sum can be achieved after considering\n        // current element.\n\n        if (sum >= set[i - 1] && subset[i - 1][sum - set[i - 1]]) {\n            list.add(set[i - 1]);\n            printSubsets(set, i - 1, sum - set[i - 1], list);\n        }\n\n    }   \n} \n```\n\n\nHow this code can be modified to work for negative numbers as well?\n    ", "Answer": "\r\nYour solutions assumes that all values are positive, so the dynamic programing array ```\nsubset```\n is filled with the values of ```\nj```\n that are positive, but you need to take into account negative sums now.\n\nWhat you need to do is to change the loop limits of ```\nj```\n to fill the dynamic programing array to\n\n```\nfor (int j = negative_sum; j <= positive_sum; j++)\n```\n\n\nWhere ```\nnegative_sum```\n is the sum of all the negative values and ```\npositive_sum```\n is the sum of all the positive ones.\n\nFor more details read the wikipedia page for the Subset Sum Problem here where this step is explained. \n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Finding trinomial coefficients using dynamic programming\r\n                \r\nI'm trying to implement a function to calculate trinomial coefficient in Java using dynamic programming.\nI'm using the formula:\n```\nT(n,k)= 1 if n=0 and k=0\nT(n,k)= 0 if k<-n or k>n \nT(n,k)=T(n-1,k-1)+T(n-1,k)+T(n-1,k+1)\n```\n\nI'm using a 2D array to store results of all sub-problems. However, the result I get for a particular ```\nn```\n and ```\nk```\n is very far from the correct answer. Here is my implementation of the method:\n```\npublic static long trinomial(int n, int k) {\n    if (n == 0 && k == 0) return 1;\n    if (k < -n || k > n) return 0;\n    long[][] T = new long[n+1][2*n+3];\n    T[0][(2*n+3)/2] = 1;\n    for (int i = 1; i <= n; i++) {\n        for (int j = -i; j <= i; j++) {\n            T[i][j+n+1] = T[i-1][j+n] + T[i-1][j+n+1] + T[i-1][j+n+2];\n        }\n    }\n    if (k < 0) return T[n][k+n];\n    else return T[n][k];\n}\n```\n\nI get ```\nT(24,12) = 123286440```\n. However, the correct answer is: ```\n287134346```\n.\nI get ```\nT(3,3) = 6```\n. But the correct answer is ```\n1```\n.\nWhen I computed ```\nT(3,3)```\n on a paper using the same method, I get ```\nT(3,3) = 1```\n but in computer I get the wrong answer. There are no compilation errors.\n    ", "Answer": "\r\nThere is a better way to implement the function. The triangle of coefficients for trinomial coefficients will be symmetrical, i.e., T(n,k)=T(n,-k). So, the no of columns for the array can be the same as row, i.e., n+1. And T(n,-k) can also be computed easily. Here is the implementation:\n```\npublic static long trinomial(int n, int k) {\n    if (n == 0 && k == 0) return 1;\n    if (k < -n || k > n) return 0;\n    long[][] T = new long[n + 1][n + 1];\n    T[0][0] = 1;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= i; j++) {\n            if (j == 0) T[i][j] = T[i - 1][j] + 2 * T[i - 1][j + 1];\n            else if (j == i) T[i][j] = T[i - 1][j - 1];\n            else T[i][j] = T[i - 1][j - 1] + T[i - 1][j] + T[i - 1][j + 1];\n        }\n    }\n    if (k < 0) return T[n][Math.abs(k)];\n    else return T[n][k];\n}\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "How to do scheduling using dynamic programming? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 5 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nThe Problem\n\n\n  Given ```\nN```\n input ```\nvector = [x1, x2, ..., xl]```\n and each of them have same length ```\nL```\n. Define ```\nF = summation of N input vector```\n.\n  And the aim is to find a set of integer ```\nT = [n1, n2, ..., nN]```\n represents delay of each input vector so that the maximum value of ```\nF```\n is minimized.\n\n\nExample\n\nAssume 2 Input vector ```\n[0, 3, -1, 1, 0]```\n, ```\n[0, 2, -1, 0, 0]```\n:\n\nif ```\nT = [0, 0]```\n, then ```\nF = [0, 5, -2, 1, 0]```\n and ```\nmax(F) = 5```\n which is obviously not a good result.\n\nif ```\nT = [1, 0]```\n, so that ```\nF = [0, 2, 2, -1, 1, 0]```\n, ```\nmax(F) = 2```\n. This T is we aim to find. The computing process below may help understand this problem:\n\n```\nT = [1, 0]\nVector1 with delay 1     [0, 3, -1, 1, 0]\nVector2 with delay 0  [0, 2, -1, 0, 0]\nF =                   [0, 2, 2, -1, 1, 0]```\n\n\nThe Question\n\nAny idea how to delay vector T using dynamic programming? \n\nAny advise would be greatly appreciated.\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "dynamic programming reduction of brute force\r\n                \r\nA  emoticon consists of an arbitrary positive number of underscores between two semicolons. Hence, the shortest possible  emoticon is ```\n;_;```\n. The strings ```\n;__;```\n and ```\n;_____________;```\n are also valid  emoticons.\n\ngiven a String containing only(```\n;```\n,```\n_```\n).The problem is to divide string into one or more emoticons and count how many division are possible. Each emoticon must be a subsequence of the message, and each character of the message must belong to exactly one emoticon. Note that the subsequences are not required to be contiguous. subsequence definition.\n\nThe approach I thought of is to write a recursive method as follows:\n\n```\ncountDivision(string s){\n //base cases\n if(s.empty()) return 1;\n if(s.length()<=3){\n   if(s.length()!=3) return 0;\n   return s[0]==';' && s[1]=='_' && s[2]==';';\n }\n  result=0;\n//subproblems\n  genrate all valid emocticon and remove it from s let it be w\n  result+=countDivision(w);\n  return result;\n}\n```\n\n\nThe solution above will easily timeout when n is large such as 100. What kind of approach should I use to convert this brute force solution to a dynamic programming solution?\n\nFew examples\n\n```\n 1. \";_;;_____;\" ans is 2\n 2. \";;;___;;;\" ans is 36\n\nExample 1.\n\n \";_;;_____;\" Returns: 2 \n There are two ways to divide this string into two emoticons. \n One looks as follows:  ;_;|;_____; and the other looks like\n this(rembember we can pick subsequence it need not be contigous):  ;_ ;|; _____;\n```\n\n    ", "Answer": "\r\nI'll describe an O(n^4)-time and -space dynamic programming solution (that can easily be improved to use just O(n^3) space) that should work for up to n=100 or so.\n\nCall a subsequence \"fresh\" if consists of a single ```\n;```\n.\n\nCall a subsequence \"finished\" if it corresponds to an emoticon.\n\nCall a subsequence \"partial\" if it has nonzero length and is a proper prefix of an emoticon.  (So for example, ```\n;```\n, ```\n;_```\n, and ```\n;___```\n are all partial subsequences, while the empty string, ```\n_```\n, ```\n;;```\n and ```\n;___;;```\n are not.)\n\nFinally, call a subsequence \"admissible\" if it is fresh, finished or partial.\n\nLet f(i, j, k, m) be the number of ways of partitioning the first i characters of the string into exactly j+k+m admissible subsequences, of which exactly j are fresh, k are partial and m are finished.  Notice that any prefix of a valid partition into emoticons determines i, j, k and m uniquely -- this means that no prefix of a valid partition will be counted by more than one tuple (i, j, k, m), so if we can guarantee that, for each tuple (i, j, k, m), the partition prefixes within that tuple are all counted once and only once, then we can add together the counts for tuples to get a valid total.  Specifically, the answer to the question will then be the sum over all 1 <= j <= n of f(n, 0, j, 0).\n\n```\nIf s[i] = \"_\":\n  f(i, j, k, m) =\n    (j+1) * f(i-1, j+1, k, m-1)    // Convert any of the j+1 fresh subsequences to partial\n    + m * f(i-1, j, k, m)          // Add _ to any of the m partial subsequences\n\nElse if s[i] = \";\":\n  f(i, j, k, m) =\n    f(i-1, j-1, k, m)              // Start a fresh subsequence\n    + (m+1) * f(i-1, j, k-1, m+1)  // Finish any of the m+1 partial subsequences\n```\n\n\nWe also need the base cases\n\n```\nf(0, 0, 0, 0) = 1\nf(0, _, _, _) = 0\nf(i, j, k, m) = 0 if any of i, j, k or m are negative\n```\n\n\nMy own C++ implementation gives the correct answer of 36 for ```\n;;;___;;;```\n in a few milliseconds, and e.g. for ```\n;;;___;;;_;_;```\n it gives an answer of 540 (also in a few milliseconds).  For a string consisting of 66 ```\n;```\ns followed by 66 ```\n_```\ns followed by 66 ```\n;```\ns, it takes just under 2s and reports an answer of 0 (probably due to overflow of the ```\nlong long```\n).\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Generate all Binary Search Trees from 1 to n, using dynamic programming\r\n                \r\nI am working on a practice problem for an exam, which is to write a program to generate all binary search trees that store values from 1...n.\n\nWe are supposed to use dynamic programming.\n\nThe accepted solution is\n\n```\n/**\n * Definition for binary tree\n * class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n\npublic ArrayList<TreeNode> helper(int m, int n){\n    ArrayList<TreeNode> result = new ArrayList<TreeNode>();\n    if(m>n){\n        result.add(null);\n        return result;\n    }\n\n    for(int i=m; i<=n; i++){\n        ArrayList<TreeNode> ls = helper(m, i-1);\n        ArrayList<TreeNode> rs = helper(i+1, n);\n        for(TreeNode l: ls){\n            for(TreeNode r: rs){\n                TreeNode curr = new TreeNode(i);\n                curr.left=l;\n                curr.right=r;\n                result.add(curr);\n            }\n        }\n    }\n    return result;\n}\n\npublic ArrayList<TreeNode> generateTrees(int a) {\n    if(a == 0){\n        return new ArrayList<TreeNode>();\n    }\n\n    return helper(1, a);\n}\n```\n\n\nHowever I don't understand how this is a dynamic programming solution and not just plain recursion. The results of helper arent being stored anywhere, so won't certain calculations be recomputed from scratch?\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Is the Sieve of Eratosthenes an example of Dynamic Programming?\r\n                \r\nI'm a bit confused as to whether the Sieve of Eratosthenes (implemented with an array for all the numbers and a loop marking the composite numbers) is an example of Dynamic Programming? A couple of friends were telling me the way it's implemented is an example of Bottom Up DP, but I'm having trouble seeing it. Exactly what are the subproblems and how would you implement SoE with Top-Down / Recursion? Thanks guys.\n    ", "Answer": "\r\nSure, we could think of the Sieve of Eratosthenes as an example of dynamic programming. The subproblems would be all the composite numbers. Skipping over marked numbers is a perfect demonstration of the subproblems overlapping since if they did not overlap we wouldn't be skipping over them :)\n\nOne way we could formulate the sieve recursively could be: let ```\nf(N)```\n represent the ```\nN```\nth prime and its associated sieve state. Then:\n\n```\nf(1) = (2, [4,6...])\nf(N) = (q, join( Sieve, [q+q,q+q+q...]))\n  '''a pair, of the next number q above p \n  _not_ in Sieve, and the Sieve with \n  all the multiples of this number q\n  added into it (we'll place an upper\n  bound on this process, practically)'''\n    where (p, Sieve) = f(N - 1)\n          q = next_not_in(p, Sieve)\n```\n\n\nLet's test:\n\n```\nf(3) = \n    call f(2) =\n        call f(1) =\n        <-- return (2, [4,6...])\n    <-- return (3, [4,6,8,9...])\n<-- return (5, [4,6,8,9,10...])\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programing: Tabular vs memoization\r\n                \r\nIs the time complexity of dynamic programming tabular approach and recursion with memoization approach the same? For example, in the Knapsack problem the tabular approach takes O(N*W) where N is the number of items and W is the weight. But what is the time complexity for the memoization approach?\n    ", "Answer": "\r\nMemoization is a method used to solve dynamic programming (DP) problems recursively in an efficient manner. DP abstracts away from the specific implementation, which may be either recursive or iterative (with loops and a table). Therefore, if used appropriately, the time complexity is the same, i.e. O(NW) in the knapsack problem over the integers.\nThis is what we used in introduction to CS and algorithm design courses in BGU (I was a T.A. in both if matters), but there might be other terminologies which I'm unaware of.\nI hope it was helpful, good luck!\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "How do you program differently in dynamic languages?\r\n                \r\nHow would someone who really knows how to take advantage of dynamic programming languages approach programming differently than someone working in a static language?  \n\nI'm familiar with the whole debate over static versus dynamic typing, but that's not what I'm getting at.  I'd like to discuss problem solving techniques that are practical in dynamic languages but not in static languages.  \n\nMost of the code I've seen written in dynamic programming languages isn't very different than code written in static programming languages.  As the saying goes, you can write FORTRAN in any language, and many people do.  But some people use dynamic programming languages to solve problems in a way that wouldn't easily translate into, for example, C++.  What are some of their techniques?\n\nWhat are some good resources that discuss how to use dynamic programming languages?  Not books on language syntax or API reference, but resources on problem solving approaches that take advantage of dynamic language capabilities.\n\nEDIT (1/5/2009): I appreciate the answers below, but they don't seem to account for the huge increases in productivity that dynamic language advocates say they experience.  \n    ", "Answer": "\r\nI like slim's answer. I do spend a crazy amount of time in Java and C++ crafting custom data structures that are just free in Python/Ruby. And crafting specialized functions to process these custom data structures. Yes, in C++, STL is really nice. Yes, Generics in Java are nice. They help create custom data structures much faster, however they still require a lot of thought and consideration.\n\nHowever, there is a more fundamental reason why dynamic languages are easier to work with. It is a deep idea which is called duck typing. Some comments above refer to duck typing, but please take time to reflect on what duck typing is. It is a fundamentally different way to view the world. A view that is incompatible with languages like Java and C++.\n\nDuck typing means that you waste not time in defining what a duck is. By not having to formally define your objects you save a lot of time and energy. Getting definitions right is hard. Have a look at this blog post of mine where I give examples: Formal definitions are less useful than you think\n\nDuck typing has proven extremely useful. The \"Must Ignore\" principle in XML is what has made XML so significant and useful on the web. But that's just an instance of duck typing. \n\nAnother way to express duck typing is by the Web mantra \"Be strict in what you send, generous in what you accept\". That is also a very fundamental idea.\n\nFinally, you may want to back to a long blog post of mine where I explain duck typing and how it relates to things like AI and modelling: Duck Typing, Artificial Intelligence and Philosophy\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming with variable dimensions\r\n                \r\nResently I encountered this problem:\nGiven a set of unique base integers and a target value, return the combination of base integers which add up to the target value. The returned combination has to have the least amount of elements.\n```\nExample 1.\n    Given: baseIntegers = [4, 7]; target = 15;\n    Return: [7, 4, 4]\n    Explanation: 7+4+4=15.\n\nExample 2. \n    Given: baseIntegers = [3, 5, 7]; target = 18;\n    Return: [7, 5, 3, 3]\n    Explanation: 7+5+3+3=18. [3, 3, 3, 3, 3] is not returned since it contains 1 more element than [7, 5, 3, 3]\n\nExample 3.\n    Given: baseIntegers = [5, 6, 8, 11]; target = 52;\n    Return: [11, 11, 11, 11, 8]\n    Explanation: 11+11+11+11+8=52.\n\nExample 4.\n    Given: baseIntegers = [2, 5]; target = 3;\n    Return: []\n    Explanation: 2,5 do not add up to 3.\n```\n\nFor example 1, I came up with an approach to solve the question using Dynamic Programming.\nWithout going into much details, I created a 2-dimentional array to store the sum of the base integers:\n```\n    sum[0,0] = 0\n    sum[1,0] = sum[0,0]+4 = 4\n    sum[1,1] = sum[1,0]+7 = 11\n    sum[2,1] = sum[1,1]+4 = 15\n```\n\n...\nWhen I found the target sum, I retrieve the result from the dimensions [2,1] (2 fours and 1 seven).\nI can do example 3 in similar fashion by creating a 4-dimentional array.\nHowever, I'm stuck if I need to solve the problem without knowing the length of baseIntegers ahead of time.\nThe reason is that I can not create a multi-dimensional array without knowing its dimension beforehand.\nSo here is my problem: Is there any way to solve this problem with variable input length?\nPreferablly with java, thanks!\n    ", "Answer": "\r\nFirst of all if you want to create a variable dimension array, you can simply create an interface.  Something like this.\n```\npublic interface MultiDimArray {\n    int dim;\n    int get (int[] idx);\n    void set (int[] idx, int value);\n    MultiDimArray getAll (int[] partialIdx);\n    void setAll(int[] partialIdx, MultiDimArray values);\n}\n```\n\nThen you create three subclasses that can be actually implemented.\n\nA ```\nHigherMultiDimArray```\n whose dimension is 2+.\nA ```\nOneDimArray```\n whose dimension is 1, and is where data is actually stored.\nA ```\nZeroDimArray```\n whose dimension is 0, is basically a wrapper around an ```\nint```\n, and which exists to give ```\nOneDimArray```\n something to return at need.\n\nThis will let you declare an array of any dimension.\nBUT you will find that a 10-dimensional array with 10 values per dimension takes 10 billion elements and you'll run out of memory.\n\nTherefore I would recommend that you find a one dimensional structure to answer the questions:\n\nHow many values do we need to get to value ```\nx```\n?\nWhat is a last value that got us there?\n\nAnd now you're dealing with a manageable amount of data.  It isn't hard to use \"dynamic programming\" to figure out how to get this reasonably.\nIf you are clever about using something called A* Search, you can make getting this even faster.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Array of buckets with dynamic programming problem\r\n                \r\nI’m doing a task with dynamic programming in Java and I got stuck:\nIn the task we are given an array of buckets with random number of rocks inside, where both players know their amount from the start. Players take tours and pick one border bucket from the sides:\n\nBuckets: (3)(3)(8)(2)(10)(4)\n\nP1: (3) buckets left: (3)(8)(2)(10)(4),\n\nP2:(4) buckets left: (3)(8)(2)(10), \n\nP1:(10) buckets left: (3)(8)(2), \n\nP2(3) buckets left: (8)(2),\n\nP1:(8) buckets left (2),\n\nP2:(2) end\n\nFinal score is calculated with (rocks of player 1) - (rocks of player2) \n\nScore = (3+10+8)-(4+3+2) = 12\n\nWe play player1 and our goal is to find the OPTIMAL pick order in which we have the biggest score.\n\nI know the concept of DP but I have no idea what could I save in order to improve the time. \nThe main part of the code I did with minmax algorithm and it worked but I have no idea how to combine it with dynamic programming\n\nI tried having a matrix with rows as buckets from left and columns as buckets from right, so I can save there answers for when we use the same “part” of the array, but I had some problems with it...\n\nEDIT1: added my code\n\n```\npublic int maxGain(int[] values)\n{\n    this.moves = new int[values.length+1][values.length+1];\n    return  _maxGain(values,0,values.length-1,0,0,values.length,true,0,0);\n}\n\npublic int _maxGain(int[] values, int leftBowl, int rightBowl, int valuePlayer1, int valuePlayer2,int leftBowls, boolean ifFirstPlayer, int leftMoves, int rightMoves){\n        //Check if end of the game\n        if(leftBowls == 0) {\n            //Calculate the final score\n            return valuePlayer1 - valuePlayer2;\n        }\n        //System.out.println(\"Left:\"+values[leftBowl]+\", right: \"+values[rightBowl]);\n        // If first player\n        if(ifFirstPlayer){\n            int maxEval = Integer.MIN_VALUE;\n            int eval;\n            for(int i=0;i<2;i++){\n                if(i==0){\n                    //Do move\n                    valuePlayer1 = valuePlayer1+values[leftBowl];\n                    leftBowls--;\n                    leftMoves++;\n                    if(moves[leftMoves][rightMoves] != 0){\n                        eval = moves[leftMoves][rightMoves];\n                        System.out.println(\"USED! Left:\"+leftMoves+\",right: \"+rightMoves+\" Moves: \" + moves[leftMoves][rightMoves] );\n                    }else {\n                        eval = _maxGain(values, leftBowl + 1, rightBowl, valuePlayer1, valuePlayer2, leftBowls, false, leftMoves, rightMoves);\n                        moves[leftMoves][rightMoves] = eval;\n                        System.out.println(\"Left:\"+leftMoves+\",right: \"+rightMoves+\" Moves: \" + moves[leftMoves][rightMoves] );\n                        for(int x=0;x<this.moves.length;x++){\n                            for(int j=0;j<this.moves.length;j++){\n                                System.out.print(this.moves[x][j]+\" \");\n                            }\n                            System.out.println();\n                        }\n                    }\n                    leftMoves--;\n                    maxEval = Math.max(maxEval,eval);\n                    //Undo move\n                    valuePlayer1 = valuePlayer1-values[leftBowl];\n                    leftBowls++;\n                }else{\n                    //Do move\n                    valuePlayer1 = valuePlayer1+values[rightBowl];\n                    leftBowls--;\n                    rightMoves++;\n                    if(moves[leftMoves][rightMoves] != 0){\n                        eval = moves[leftMoves][rightMoves];\n                        System.out.println(\"USED! Left:\"+leftMoves+\",right: \"+rightMoves+\" Moves: \" + moves[leftMoves][rightMoves] );\n                    }else {\n                        eval = _maxGain(values, leftBowl, rightBowl - 1, valuePlayer1, valuePlayer2, leftBowls, false, leftMoves, rightMoves);\n                        moves[leftMoves][rightMoves] = eval;\n                        System.out.println(\"Left:\"+leftMoves+\",right: \"+rightMoves+\" Moves: \" + moves[leftMoves][rightMoves] );\n                        for(int x=0;x<this.moves.length;x++){\n                            for(int j=0;j<this.moves.length;j++){\n                                System.out.print(this.moves[x][j]+\" \");\n                            }\n                            System.out.println();\n                        }\n                    }\n                    rightMoves--;\n                    maxEval = Math.max(maxEval,eval);\n                    //Undo move\n                    valuePlayer1 = valuePlayer1-values[rightBowl];\n                    leftBowls++;\n                }\n            }\n            return maxEval;\n            //If second player\n        }else{\n            int minEval = Integer.MAX_VALUE;\n            int eval;\n            for(int i=0;i<2;i++){\n                if(i==0){\n                    //Do move\n                    valuePlayer2 = valuePlayer2+values[leftBowl];\n                    leftBowls--;\n                    leftMoves++;\n                    if(moves[leftMoves][rightMoves] != 0){\n                        eval = moves[leftMoves][rightMoves];\n                        System.out.println(\"USED! Left:\"+leftMoves+\",right: \"+rightMoves+\" Moves: \" + moves[leftMoves][rightMoves] );\n                    }else {\n                        eval = _maxGain(values, leftBowl + 1, rightBowl, valuePlayer1, valuePlayer2, leftBowls, true, leftMoves, rightMoves);\n                        moves[leftMoves][rightMoves] = eval;\n                        System.out.println(\"Left:\"+leftMoves+\",right: \"+rightMoves+\" Moves: \" + moves[leftMoves][rightMoves] );\n                        for(int x=0;x<this.moves.length;x++){\n                            for(int j=0;j<this.moves.length;j++){\n                                System.out.print(this.moves[x][j]+\" \");\n                            }\n                            System.out.println();\n                        }\n                    }\n                    leftMoves--;\n                    minEval = Math.min(minEval,eval);\n                    //Undo move\n                    valuePlayer2 = valuePlayer2-values[leftBowl];\n                    leftBowls++;\n                }else{\n                    //Do move\n                    valuePlayer2 = valuePlayer2+values[rightBowl];\n                    leftBowls--;\n                    rightMoves++;\n                    if(moves[leftMoves][rightMoves] != 0){\n                        eval = moves[leftMoves][rightMoves];\n                        System.out.println(\"USED! Left:\"+leftMoves+\",right: \"+rightMoves+\" Moves: \" + moves[leftMoves][rightMoves] );\n                    }else {\n                        eval = _maxGain(values, leftBowl, rightBowl - 1, valuePlayer1, valuePlayer2, leftBowls, true, leftMoves, rightMoves);\n                        moves[leftMoves][rightMoves] = eval;\n                        System.out.println(\"Left:\"+leftMoves+\",right: \"+rightMoves+\" Moves: \" + moves[leftMoves][rightMoves] );\n                        for(int x=0;x<this.moves.length;x++){\n                            for(int j=0;j<this.moves.length;j++){\n                                System.out.print(this.moves[x][j]+\" \");\n                            }\n                            System.out.println();\n                        }\n                    }\n                    rightMoves--;\n                    minEval = Math.min(minEval,eval);\n                    //Undo move\n                    valuePlayer2 = valuePlayer2-values[rightBowl];\n                    leftBowls++;\n                }\n            }\n            return minEval;\n        }\n    }\n```\n\n    ", "Answer": "\r\nOk, so I have found on Github the code for exactly this type of task,\nI will leave it for other people if they need it later: \n\nhttps://github.com/mission-peace/interview/blob/master/src/com/interview/dynamic/NPotGold.java?fbclid=IwAR2PZ8MvNJcQmlU13wj1n_c6m1UhQY7FXAY07RwaI6wOOXAMgDOVRxFahD0 \n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Unique paths Dynamic Programming\r\n                \r\nYou have a 2D grid. You have a limited number of moves. You can go right, down, left, and up. And you need to find the number of ways to escape the grid. So a 1 x 2 grid with 3 moves has 9 unique paths to escape the grid (escaping is going out of bounds).\nI need to come up with a dynamic programming approach and so far I can only think about the different moves you can have:\n\nYou are on the grid and not out of moves: keep going\nYou are out of bounds and out of moves: 1 + try to find another path\nYou are out of bounds and not out of moves: 1 + go back a step and find another path\nYou are on the gird and out of moves: this path does not count, go back a step and find another path\n\nI can't think of a way of storing the values to avoid recalculation since you can start at any point and there are multiple places to finish from, as well as having a limited number of moves.\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "C++ Cutting Rod Dynamic programming\r\n                \r\nI am new to dynamic programming and trying to solve an evergreen problem: cutting rod. I have been trying for hours and I am stuck. I am trying to debug it but without success.\nHere is my code\n\n```\n#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\nint main()\n{\n    int length = 5;\n    int peaces[2][4] = {{1, 2, 3, 4}, {2, 5, 7, 8}};\n    /*\n        length  1, 2, 3, 4\n        value:  2, 5, 7, 8  \n    */ \n\n    //create working matrix: number of lengths X lengths\n    int work[4][6];\n    //fill in the first column with zeros\n    for(  int k = 0; k < 5; k++  )\n    {\n        work[k][0] = 0;\n    }\n    //fill in the first row with zeroes\n    for(  int k = 0; k <= length; k++  )\n    {\n        work[0][k] = 0;\n    }\n\n    for(  int i = 1; i < 5; i++  ) // number of lengths\n    {\n        cout << endl << \" i: \" << i << \"   \" << endl;\n        for(  int j = 1; j < 6; j++  )\n        {\n            cout << endl << \" j: \" << j << \"   \" << endl;\n            if(  j >= i  )\n            {\n                work[i][j] = max(  work[i - 1][j], work[i][j - i] + peaces[1][i-1]  );\n            }\n            else\n            {\n                work[i][j] = work[i - 1][j];\n            }\n            cout << endl;<< \"inserted:\" << work[i][j]<< endl;\n\n            for(  int i = 0; i < 5; i++  )\n            {\n                for(  int j = 0; j < 6; j++  )\n                {\n                    cout << work[i][j] << \" \";          \n                }\n                cout << endl;\n            }\n\n            cout  <<  endl;\n        }\n    }\n\n\n\n    for(  int i = 0; i < 5; i++  )\n    {\n        for(  int j = 0; j < 6; j++  )\n        {\n            cout << work[i][j] << \" \";          \n        }\n        cout << endl;\n    }\n\n    return 0;   \n};\n```\n\n\nSomething very strange happens and I can't figure out why: in the last iteration of the for loop I get right solution, but when exit the loop and I print the 2D array, it is changed, not the same as the one in the last iteration. Between two printing no operation is done on the array.\n I know that this is not an optimized solution, but that is the first one I have come up with.\nQuestion: Why is not the array filled the right way? What have I done wrong?\n    ", "Answer": "\r\nThe best way to avoid issues like this is to define variables for the dimensions in the first place. For example,\n\n```\nint xlen = 4;\nint ylen = 5;\nint work[xlen][ylen];\n```\n\n\nThen, you can use xlen and ylen in your loops and if you want to change the size of the arrays, you just change the xlen and ylen.\n\nAlternatively, you can find the size using answers that you find here: How do I find the length of an array?\n\nAnd finally, you should read up on the standard template library, which gives you \"smarter\" objects you can use.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Balance ordering parenthesis via Dynamic programing\r\n                \r\nHi from the very famous book Code to Crack i come across a question :\n\nImplement an algorithm to print all valid (e.g., properly opened and closed) combinations of n-pairs of parentheses.\n\nExample:\n\n```\ninput: 3 (e.g., 3 pairs of parentheses)\noutput: ()()(), ()(()), (())(), ((()))\n\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nvoid _paren(int l,int r,string s,int count);\nvoid paren(int n)\n{\n    string s=\"\";\n    _paren(n,n,s,n);\n}\n\nvoid _paren(int l,int r,string s,int count){\n\n    if(l<0 || r<0)\n        return;\n    if(l==0 && r==0)\n        cout<<s<<endl;\n    else{\n        if(l>0)\n        {\n            _paren(l-1,r,s+\"(\",count+1);\n        }\n        if(r>l)\n            _paren(l,r-1,s+\")\",count+1);                    \n    }\n}\nint main(){\n    int n;\n    cin>>n;\n    paren(n);\n    return 0;\n}\n```\n\n\nThis is a recursive approach I tried for it . I am pretty sure that we can solve this through dynamic programming as well , as we are already using a lot of value again and again , but I have no idea how to implement this through Dynamic programming I tried tabular bottom up approach but couldnt work out. Please help me out just the basic idea on how to work with this\n    ", "Answer": "\r\nDP does not really help you. The recursive algorithm is time and space optimal!\n\nIn fact, there is a reason not to use DP: the memory requirements! This will be huge.\n\nA better algorithm is to have one character array that you pass in, have the recursive method modify parts of it and print that when needed. I believe that solution is given in the book you mention.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Complexity of recursion in nested loops in Dynamic and Non-dynamic programming\r\n                \r\nI have written a basic example of dynamic programming in Java (shown below) which solves the Longest Increasing Subsequence problem (https://en.wikipedia.org/wiki/Longest_increasing_subsequence).\n\nThe function works but for a homework assignment, I am trying to find out the time complexity of this algorithm vs its non-dynamic equivalent. \n\nI believe dynamic version is O(n^2) but for the non-dynamic equivalent I am very confused. I have tried and failed to write a non-dynamic version, but I think it would be comprised of a recursive call within nested (2) for loops. Would that imply exponential time complexity? Or even factorial time complexity?\n\nI would be very grateful for any help in cracking this complexity conundrum or even producing a non-dynamic, recursive equivalent of the function I have written below.\n\nThanks in advance!\n\n```\n\n   public static int longest(int[] array) {\n\n        int n = array.length;\n\n        int[] results = new int[n];\n\n        for(int i = 0; i < n; i++) {\n            results[i] = -1;\n        }\n\n        int max = 1;\n        for(int j = 1; j <= n; j++) {\n            int current = memoized_longest(array, j, results);\n            if(current > max) {\n                max = current;\n            }\n        }\n\n        return max;\n    }\n\n\n    public static int memoized_longest(int[] array, int n, int[] results) {\n\n        if(results[n-1] >= 0) {\n            return results[n-1];\n        }\n\n        if(n == 1) {\n            results[n-1] = 1;\n            return results[n-1];\n        }\n\n        int q = 1;\n\n        for(int i = n - 1; i >= 0; i--) {\n            if(array[i] < array[n - 1]) {\n                 q = Math.max(q, 1 + memoized_longest(array, i+1, results));\n            }\n        }\n\n        results[n-1] = q;\n        return q;\n    }\n```\n\n    ", "Answer": "\r\nYou almost had it:\n\n```\npublic static int longest(int[] array) {\n  int q = 0;\n  for (int i = 0; i < array.length; i++) {\n    q = Math.max(q, longest_at(array, i));\n  }\n  return q;\n}\n\npublic static int longest_at(int[] array, int i) {\n  int q = 1;\n  for (int j = 0; j < i; j++) {\n    if (array[j] < array[i]) {\n      q = Math.max(q, 1 + longest_at(array, j));\n    }\n  }\n  return q;\n}\n```\n\n\n```\nlongest_at```\n returns the length of the longest increasing subsequence ending at position ```\ni```\n. Turning a recursive DP algorithm into a normal recursive algorithm is achieved by just dropping the memorization.\n\nAs for the runtime, we have the following recurrence relation:\n\nT(n) <= T(1) + T(2) + ... + T(n-1)\n\nT(n) is the runtime of ```\nlongest_at(n)```\n. To compute ```\nlongest_at(n)```\n, we must (potentially, if all elements before position n are smaller than ```\narray[n]```\n) compute ```\nlongest_at(1)```\n, ```\nlongest_at(2)```\n, up to ```\nlongest_at(n-1)```\n. This is reflected in the recurrence relation.\n\nIf T(1) = 1, then T(n) = 2^n - 1 is a solution.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Understanding Base case in Dynamic programming\r\n                \r\nConsider this question count of different ways express-n sum-1-3-4\n\nMy understanding here is f(n) is number of ways to represent n as sum of 1, 3 and 4\n\nf(n-1) is number of ways to represent n-1 as sum of 1, 3 and 4\n\nf(1) is number of ways to express 1 as sum of  1, 3 and 4\n\nf(0) is number of ways to express 0 as sum of  1, 3 and 4\n\nshould not that be 0 as there is no way to represent/express 0 as sum of 1,3,4\n\nJust starting to learn Dynamic programming but I don't get why this should be 1 not 0\n    ", "Answer": "\r\nWell lets say you want to represent some sum S as sum of 1, 3 and 4\n\nYou can write this mathematically as equation ```\nS = 1*x + 3*y + 4*z```\n where x,y,z denotes amounts of ones, threes and fours in the sum.\n\nSo now ```\nf(S)```\n is just amount of solutions to the equation (having in mind that x,y,z are non-negative integers)\n\nAnd when ```\nS=0```\n we can easily see that equation has one solution - ```\nx=0, y=0, z=0```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming: Counting super numbers in between\r\n                \r\nGiven two numbers, let's call them ```\nX```\n  and ```\nY```\n  how to find all \"super\" numbers between them. \n\n\n  A super number is a number whose neighbouring digits have an absolute\n  difference more than 1. So, for example, number 132 is not a super number \n  because\n  3 and 2 have a difference equal to 1. Number 62 is a super number because \n  diffrence between 6 and 2 is greather than 1.\n\n\nHow to find all super numbers between X and Y (included) using Dynamic programming?\n\n```\n1 < X,Y < 10^5000 \n```\n\n    ", "Answer": "\r\nYou can use a technique called Digit DP\", or \"Dp on digit\". Let's imagine that we have a function f(x) tells the number of integers between 0 to x (inclusively) which are super digits, if you want to compute the number of super numbers between X, Y you only need calculate f(Y) and f(X-1), because the number of super numbers between X and Y is equal to f(Y)-f(X-1) (it's intuitive to notice why).\n\nThen how should the function f (x) be? you need three states: \nindex: the index on the string (the number) what are you processing.\ntight: this will tell if the current digits range is restricted or not.\n\nFor example if you have the number: \n\n1234 you can reach the states, 0234, 0000, 1231, etc. (numbers less or equal to 1234) \n\nBut you can't reach: 2234, 1244, etc.\n\nThe tight deals with controlling this. \n\nlast: the last used digit, this will help you with the transitions, for example if your last used digit is 4 your next digit can be 0, 1, 2 or 6, 7, 8, 9 (these only if the tight is not active).\n\nI leave you a tutorial and places where you can find more information:\n\nhttps://www.geeksforgeeks.org/digit-dp-introduction/ here you can understand better about the idea, and the tight use.\nYou also cand find information on competitive programming pages like codeforces, topcoder, codechef.\n\nI usually see these problems in competitive programming, is this a problem for some judge? I would like to try a solution. . if that's the case, I really hope you're not in a live contest.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Finding Number of Comparison in LCS In dynamic programming\r\n                \r\n```\n#include<iostream>\n#include<string.h>\nint count=0;\n\nusing namespace std;\n\n\nint max(int a,int b)\n{\n    return (a>b)?a:b;\n}\n\nint lcs(char *x,char*y ,int m,int n)\n{\n\n    int l[m+1][n+1];\n    int i,j;\n\n    for( i=0;i<=m;i++)\n    {\n     for(j=0;j<=n;j++)\n        {\n\n        if(i==0 || j==0)\n        l[i][j]=0;\n\n        else if(x[i-1]==y[j-1]) \n        l[i][j]=l[i-1][j-1]+1;\n\n        else\n        l[i][j] =max(l[i-1][j], l[i][j-1]);\n\n        }\n    }\n\n\n    return l[m][n];\n\n\n}\n\n\nint main()\n{\n\n    char x[]=\"AGGTAB\";\n    char y[]=\"GXTXAYB\";\n\n    int m=strlen(x);\n    int n=strlen(y);\n\n    cout<<\"The Length Of the Longest Common Subsequence Is  :   \"<<lcs(x,y,m,n);\n}\n```\n\n\nThe above program is for finding the Largest Common Subsequence solution using dynamic programming .\n I am able to calculate the length of the LCS but i am unable to deduce the logic for finding the total no. of comparisons the system will make to find the lcs .\n\nI want to find the total no. of comparisons and to print it using a global count variable . Could someone help me out? \n    ", "Answer": "\r\nIt depends on what exactly you count as a comparison.\n\nI assume, that by comparison you mean \"comparing characters in the string\". I.e. ```\ni==0```\n does not count as a comparison. Also comparing the values in the ```\nmax```\n wouldn't count as comparison, since it does not compare characters from the strings. Also, I didn't go through your program checking if what you do is actually correct - I will just assume it is and focus on your actual question.\n\nThat being said, the only comparison of characters that is happening is in the line:\n\n```\nelse if(x[i-1]==y[j-1]) \n```\n\n\nHence, each time you do this check you should increment your counter. One way to do this would be to restructure your branches a bit (instead of an ```\nelse if```\n you could do an ```\nelse{ if{x[i-1]==y[j-1]} }```\n. If you do that, then you could increment the ```\ncounter```\n right before the if. Like so:\n\n```\nif(){\n\n}else{ \n counter++;\n if{x[i-1]==y[j-1]} \n\n }else{\n\n }\n}\n```\n\n\nAnother more explicit way to do it would be to have a function doing the check and increment in there. Something like:\n\n```\nbool compareChars(char &first, char &second){\n counter++;\n return first == second;\n}\n```\n\n\nAnd then you would just do:\n\n```\nelse if(compareChars(x[i-1], y[j-1]))\n```\n\n\nThen it would be very obvious, that each time a comparison is done the counter is incremented.\n\nI didn't thoroughly test this, and of course other ways are possible, still I hope you get the rough idea.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Getting this issue in Dynamic Programming using memoization\r\n                \r\nI am working on the Dynamic programming concept using Python. I have designed a simple code that for for each recursion it divides the given input (n) by 2 and add in the memo dict. I want the memo dict as the return form this function.\n```\nn = 16\n\ndef myfunc(n, memo={}):\n\n  if n in memo : return memo[n]\n  if n == 0 : return 0\n  if n == 1 : return 1\n  if n % 2 == 0:\n      memo[n] = myfunc(n // 2)\n  else:\n      pass\n  return memo   \n\nres = myfunc(n)\nprint(res) \n```\n\nBut when i am executing this above code i am getting this as the result :\n```\n{2: 1, 4: {...}, 8: {...}, 16: {...}}\n```\n\nI don't understand  where this ```\n{...}```\n is coming from ??\nI want the result ```\n{2: 1, 4: 1, 8: 1, 16: 1}```\n , logically.\n    ", "Answer": "\r\nThe problem is, that you are returning the same memo object all the time. Try something like this:\n```\ndef myfunc(n, memo={}):\n    if n <= 1: return\n    if n % 2 == 0:\n        memo[n] = 1\n\n    myfunc(n // 2, memo)\n\n    return memo\n\n\nres = myfunc(16)\nprint(res)\n\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming (Haskell, Hofstader M/F sequence)\r\n                \r\nThis works :\n\n```\nf :: Int -> Int\nf n = gof n where\n      gof 0 = 1\n      gof i = i - ms!! ( fs!! (i-1) )\n      gom 0 = 0\n      gom i = i - fs!! ( ms!! (i-1) )\n      fs = [gof j | j <- [0..n]]\n      ms = [gom j | j <- [0..n]]\n\nm n = gom n where\n      gof 0 = 1\n      gof i = i - ms!! ( fs!! (i-1) )\n      gom 0 = 0\n      gom i = i - fs!! ( ms!! (i-1) )\n      fs = [gof j | j <- [0..n]]\n      ms = [gom j | j <- [0..n]]\n```\n\n\nHowever it is really repetitive. Is there a way to avoid just repeating those chunks of code? A few references, this is an adaptation of :\n\nhttp://jelv.is/blog/Lazy-Dynamic-Programming/\n\nSequence ref :\n\nhttps://en.wikipedia.org/wiki/Hofstadter_sequence\n\nI checked it against the numbers :\n\nhttps://oeis.org/A005378\nhttps://oeis.org/A005379\n\nIt generates the right numbers and it is way faster than the basic code which won't go very high at all before it starts having issues with recursion depth.\n    ", "Answer": "\r\nFirst of all, you can pattern-match in a top-level binding.  Usually it doesn't mean much interesting is going on, but if you want to share local helpers between two top-level bindings, it can help.\n\n```\nm2 :: Int -> Int\nf2 :: Int -> Int\n(m2, f2) = (gom, gof)\n  where\n    gof 0 = 1\n    gof i = i - ms !! ( fs !! (i-1) )\n    gom 0 = 0\n    gom i = i - fs !! ( ms !! (i-1) )\n    fs = map gof [0..]\n    ms = map gom [0..]\n```\n\n\nYou'll note there's one other trick in there.  Instead of bounding the lists ```\nfs```\n and ```\nms```\n to their maximum size, I just let laziness handle bounding them.  The lists won't be created past where they're needed to memoize earlier results.\n\nBut list indexing is O(n).  Getting rid of even some of it can be a significant speedup.  If you look at the pattern of recursion along the same function, you'll see that ```\ngom i```\n always calls ```\ngom (i-1)```\n, and the same with ```\ngof```\n. You can use that to remove list indexing on those lookups by just passing along the previous value. Unfortunately, the same doesn't apply with the calls to the opposite function, as they don't follow so easily.  But it's still removing a big amount of work.  And it can be done in such a way as to utilize laziness even further:\n\n```\nm3, f3 :: Int -> Int\n(m3, f3) = ((ms !!), (fs !!))\n  where\n    (ms, fs) = unzip pairs\n    pairs = (0, 1) : zipWith iter [1..] pairs\n    iter i (mp, fp) = (i - fs !! mp, i - ms !! fp)\n```\n\n\nThe recursive helper functions have been replaced with simultaneous lazy creation of both result lists. This pattern differs from standard recursion in that it doesn't need a base case to reach, and it requires some sort of guard against trying to immediately find a base case before the complete answer can be provided. This pattern is known as co-recursion. (Or corecursion if I'm typing lazily.)  Same idea, but it produces the answer in the opposite direction.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming - top-down vs bottom-up\r\n                \r\nWhat I have learnt is that dynamic programming (DP) is of two kinds: top-down and bottom-up.\n\nIn top-down, you use recursion along with memoization. In bottom-up, you just fill an array (a table).\n\nAlso, both these methods use same time complexity. Personally, I find top-down approach more easier and natural to follow. Is it true that a given question of DP can be solved using either of the approaches? Or will I ever face a problem which can only be solved by one of the two methods?\n    ", "Answer": "\r\nWell I believe theoretically you should be able to solve a DP problem with either approach. However, there are instances when bottom up approach can become too expensive. Consider a knapsack problem with the ```\nknapsack_size = 200,000```\n and the ```\nnum_items = 2000```\n. To fill in a two dimensional DP table with just ```\nints```\n is not going to be possible. You'll exhaust the main memory of an ordinary computer. Moreover, you do not require to fill in all the entries in a table to achieve the desired final computation. A recursive top-down approach is far superior in a case like this. Hope it helps. \n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming gives different result with cache implementation\r\n                \r\nI'm doing a dynamic programming algorithm and after hopelessly debugging my program all evening I'm all out of answers. Basically my program returns the wrong answer when I use a cache for storing intermediate results. Here is my program:\n\n```\ndef cachecost(cache, i, j, seq1, seq2):\n    if cache[i][j] is None:\n        v1 = v2 = v3 = v4 = None\n\n        if i > 0 and j > 0:\n            v1 = cachecost(cache, i-1, j-1, seq1, seq2) + 5\n        if i > 0 and j >= 0:\n            v2 = cachecost(cache, i-1, j, seq1, seq2) + 1\n        if i >= 0 and j > 0:\n            v3 = cachecost(cache, i, j-1, seq1, seq2) + 1\n        if i == 0 and j == 0:\n            v4 = 0\n\n        cache[i][j] = max(v1, v2, v3, v4)\n    return cache[i][j]\n\n\ndef cost(cache, i, j, seq1, seq2):\n    v1 = v2 = v3 = v4 = None\n\n    if i > 0 and j > 0:\n        v1 = cost(cache, i-1, j-1, seq1, seq2) + 5\n    if i > 0 and j >= 0:\n        v2 = cost(cache, i-1, j, seq1, seq2) + 1\n    if i >= 0 and j > 0:\n        v3 = cost(cache, i, j-1, seq1, seq2) + 1\n    if i == 0 and j == 0:\n        v4 = 0\n\n    cache[i][j] = max(v1, v2, v3, v4)\n    return max(v1, v2, v3, v4)\n\n\ndef main():\n    seq1 = 'AATAAT'\n    seq2 = 'AAGG'\n    cache = [[None] * (len(seq2) + 1)] * (len(seq1) + 1)\n    cachescore = cachecost(cache, len(seq1), len(seq2), seq1, seq2)\n    score = cost(cache, len(seq1), len(seq2), seq1, seq2)\n    print 'Score without cache: %s, score with cache: %s' % (cachescore, score)\n\n\n# Handle command line execution\nif __name__ == '__main__':\n    main()\n```\n\n\nThe algorithm basically calculates a ```\ni * j```\n table through recursion where the cache implementation assures that each entry in the table is only calculated once. \n\nRunning the program produces the following output: \n\n```\nScore without cache: 36, score with cache: 22\n```\n\n\nWhat am I doing wrong here?\n    ", "Answer": "\r\nThe actual problem is in this line\n\n```\ncache = [[None] * (len(seq2) + 1)] * (len(seq1) + 1)\n```\n\n\nIt first creates a list of ```\nNone```\ns of size ```\nlen(seq2) + 1```\n and then another list of size ```\nlen(seq1) + 1```\n is created with all elements being the reference to the same ```\nNone```\ns list. So, if you are changing any of them, the change will be refelected in all others as well. For example,\n\n```\nlists = [[None] * 2] * 3\nprint lists\n# [[None, None], [None, None], [None, None]]\nlists[0][1] = 1\nprint lists\n# [[None, 1], [None, 1], [None, 1]]\n```\n\n\nSo, you need to create it like this\n\n```\ncache = [[None] * (len(seq2) + 1) for _ in range(len(seq1) + 1)]\n```\n\n\nNow, on each iteration, a new list of ```\nNone```\ns will be created and all of them will be put together in a new list.\n\n```\nlists = [[None] * 2 for _ in range(3)]\nprint lists\n# [[None, None], [None, None], [None, None]]\nlists[0][1] = 1\nprint lists\n# [[None, 1], [None, None], [None, None]]\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Coin Change Dynamic Programming but finding solutions with exact number of coins\r\n                \r\nThis is for the problem Coin Change, which involves two inputs: a ```\ncoins```\n integer array, and an integer ```\namount```\n. We need to return the fewest number of coins that make up to the amount.\nI've already had my solution using Dynamic Programming:\n```\ndp = [amount + 1] * (amount + 1)\ndp[0] = 0\nfor c in coins:\n    for a in range(amount + 1):\n        if a - c >= 0:\n            dp[a] = min(dp[a], 1 + dp[a - c])\n    return dp[-1]\n```\n\nHowever, if the same problem but the array of coins is given, for example ```\ncoins = [1,3,5]```\n. The input now will be ```\nnumber_of_coins```\n and ```\namount```\n, and return the number of ways that make up to the amount with exact number of coins.\nHow can I solve this problem also using Dynamic Programming?\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Python List syntax and understanding with dynamic programming\r\n                \r\n```\nclass Solution(object):\n \n    def LCS(self, text1,text2 ):\n        for i in range(len(text1)-1,-1,-1):\n            for j in range(len(text2)-1,-1,-1):\n                if text1[i]==text2[j]:\n                    dp[i][j]=1+dp[i+1][j+1]\n                else:\n                    dp[i][j]=max(dp[i][j+1],dp[i+1][j])\n        return dp[0][0]\n```\n\nDynamic programming using the bottom-up approach.\nThis code is for finding the longest common subsequence between two strings.\nExample)input; text1='abcde', text2='ace'; then the output should be 3\nI am having a difficult time understanding the code after ```\nif text1[i]==text2[j]:```\n\nI am new to python and so I'm not familiar with ```\narr[i][j]```\n etc.\nI just need an explanation of the code below the if statement along with an explanation of the python syntax.\n    ", "Answer": "\r\n\n```\ndp[p]```\n selects the item at position ```\np```\n\nIf that item is subscriptable, like a list, then ```\nitem[q]```\n selects the object at position ```\nq```\n.\n```\ndp[p][q]```\n selects the object at position ```\nq```\n from the object at position ```\np```\n in ```\ndp```\n\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Time Complexity comparision of memoized recursion and table method in Dynamic programming\r\n                \r\nDoes every code of Dynamic Programming have the same time complexity in a table method or memorized recursion method?\nA Solution with an appropriate example would be appreciated.\n    ", "Answer": "\r\nTime complexity- Yes (if you ignore the function calls/returns in Memoization)\nSpace complexity- No. Tabulation can save space by overwriting previously calculated but no longer needed values.\nAs mentioned in the \"Optimality\" section of this answer- https://stackoverflow.com/a/6165124/7145074\n\nEither approach may not be time-optimal if the order you happen (or try to) visit subproblems is not optimal, specifically if there is more than one way to calculate a subproblem (normally caching would resolve this, but it's theoretically possible that caching might not in some exotic cases). Memoization will usually add on your time-complexity to your space-complexity (e.g. with tabulation you have more liberty to throw away calculations, like using tabulation with Fib lets you use O(1) space, but memoization with Fib uses O(N) stack space).\n\nFurther reading- https://www.geeksforgeeks.org/tabulation-vs-memoization/\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Getting this issue in Dynamic Programming using memoization\r\n                \r\nI am working on the Dynamic programming concept using Python. I have designed a simple code that for for each recursion it divides the given input (n) by 2 and add in the memo dict. I want the memo dict as the return form this function.\n```\nn = 16\n\ndef myfunc(n, memo={}):\n\n  if n in memo : return memo[n]\n  if n == 0 : return 0\n  if n == 1 : return 1\n  if n % 2 == 0:\n      memo[n] = myfunc(n // 2)\n  else:\n      pass\n  return memo   \n\nres = myfunc(n)\nprint(res) \n```\n\nBut when i am executing this above code i am getting this as the result :\n```\n{2: 1, 4: {...}, 8: {...}, 16: {...}}\n```\n\nI don't understand  where this ```\n{...}```\n is coming from ??\nI want the result ```\n{2: 1, 4: 1, 8: 1, 16: 1}```\n , logically.\n    ", "Answer": "\r\nThe problem is, that you are returning the same memo object all the time. Try something like this:\n```\ndef myfunc(n, memo={}):\n    if n <= 1: return\n    if n % 2 == 0:\n        memo[n] = 1\n\n    myfunc(n // 2, memo)\n\n    return memo\n\n\nres = myfunc(16)\nprint(res)\n\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Am I using Dynamic Programming? Matrix chain multiplication in c\r\n                \r\nHalo I just write code to perform Matrix chain multiplication, which can be solved by Dynamic Programming\nhttp://en.wikipedia.org/wiki/Matrix_chain_multiplication#A_Dynamic_Programming_Algorithm\n\nHere is the code I wrote, which I think is simpler than the one provided by wikipedia. So I doubt am i doing dynamic programming or not?\n\nand I can't figure out the time complexity of my program. Can someone help me to figure the time complexity of this program?\n\nHere's my guess..\nthe for loop will run n times for each call? if mem is not used..\nfor each loop, it will then expand into two\n\nif mem is used, it prevent recalculation... \nahhh I can't figure it out, hope someone can help me :-)\n\n```\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n\nusing namespace std;\n\nint mem[10][10];\nint row[10];\nint col[10];\nint m[10];\n\n#define NUM 4\n\nint DP(int c, int r){\n    if(mem[c][r] != INT_MAX) return mem[c][r];\n    if(c == r) return 0;\n    int min_cost;\n    for(int j=c; j<r; j++){\n        min_cost = DP(c, j) + DP(j+1, r) + m[c-1]*m[j]*m[r];\n        if(min_cost < mem[c][r])\n            mem[c][r] = min_cost;\n    }\n    return mem[c][r];\n}\n\nint main(){\n    for(int i=0; i< 10;i++){\n        for(int j=0; j<10;j++){\n            mem[i][j] = INT_MAX;\n        }\n    }\n    int n = NUM; // MAX 4 matrix\n    int a,b;\n    for(int i=0; i< NUM+1; i++){\n        cin >> a;\n        m[i] = a;\n    }\n\n    cout << \"Lowest Cost for matrix multiplicatoin \" << DP(1,NUM);\n}\n```\n\n    ", "Answer": "\r\nThe technique you have used is called ```\nmemoization```\n. Most of the time, you may solve DP problems using memoization with little (or no) overhead.\n\nThe complexity of your implementation is just like the original DP solution: O(n^3) (Note: Every cell of ```\nmem```\n array should be computed at least once, and each cell takes O(n) time to be computed. Further computation of a cell, does not involve any loop, since it would be a simple lookup.)\n\nSee also http://en.wikipedia.org/wiki/Memoization\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming assigning tasks to different computers\r\n                \r\nI have the following dynamic programming problem that I just can't figure out.\nBasically you have a table like this which represents the time it takes computer X to accomplish Y tasks (ordi means computer).\n\nIn this case, computer 1 will take 7 seconds to complete 1 task, 10 seconds to complete 2 tasks, etc.\nComputer 2 will take 8 seconds to accomplish 1 task, 9 seconds to accomplish 2 tasks, etc.\nNow, I want to write a dynamic programming algorithm that will tell me the minimum amount of time needed for Computer 1 AND 2 to accomplish 3 tasks, or the minimum time needed for Computer 1, 2 AND 3 to accomplish 5 tasks, etc.\nKeep in mind 2 constraints: each computer involved must have at least 1 task assigned to it, and all 6 tasks must be distributed. For example, you couldn't use Computer 1 AND 2 to accomplish 1 task in the same way that you couldn't use 3 computers to accomplish less than 3 tasks (and each one must have a task).\nThis is the solution :\n\nMy (almost working) (Rust) code is below, it doesn't give the right numbers, though, can anyone get it to give the correct solution?\n```\nlet costs = [\n    [7, 10, 14, 20, 21, 30],\n    [8, 9, 15, 10, 18, 20],\n    [9, 9, 16, 28, 30, 40],\n    [11, 15, 20, 30, 35, 20],\n];\n\nlet mut optimal = vec![vec![999999999; costs[0].len()]; costs.len()];\n\nfor j in 0..costs[0].len() {\n    optimal[0][j] = costs[0][j];\n}\n\nfor i in 1..optimal.len() {\n    for j in i..optimal[i].len() {\n        let mut min = 999999999;\n\n        for k in 0..j {\n            let c = optimal[i - 1][j - k] + costs[i][k];\n            min = std::cmp::min(c, min);\n        }\n        optimal[i][j] = min;\n    }\n}\n```\n\n    ", "Answer": "\r\n```\nlet costs = [\n    [7, 10, 14, 20, 21, 30],\n    [8, 9, 15, 10, 18, 20],\n    [9, 9, 16, 28, 30, 40],\n    [11, 15, 20, 30, 35, 20],\n];\n\nlet mut optimal = vec![vec![999999999; costs[0].len()]; costs.len()];\n\nfor j in 0..costs[0].len() {\n    optimal[0][j] = costs[0][j];\n}\n\nfor i in 1..optimal.len() {\n    for j in i..optimal[i].len() {\n        let mut min = 999999999;\n\n        //Wrong interval\n        for k in 1..j+1 {\n            //Index shift because we start with 0\n            let c = optimal[i - 1][j - k] + costs[i][k-1];\n            min = std::cmp::min(c, min);\n        }\n        optimal[i][j] = min;\n    }\n}\n```\n\nYou essentially did not account that the column for 1 task is in column 0 and so on, so you will get 2 index shifts.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming algorithms and real world usage\r\n                \r\nI have studied in the past the classical DP problems and algorithms (coins, longest increasing subsequence, longest common subsequence, etc).\n\nI know that these algorithms have practical applications (ie. genetic algorithms, just to name one). What I question though is if these algorithms have practical applications in modern computer science, where the size of input is very large and problems are not solvable on just one machine.\n\nMy point is that these algorithms are quite hard to parallelize (ie. Parallel Dynamic Programming), and memory occupation is quadratic in most of the formulations, making it hard to process inputs that are reasonably big.\n\nAnyone has real world use cases on this? \n    ", "Answer": "\r\nPractical application: ```\ndiff```\n. This is an essential Linux utility which finds the differences between two files by solving the longest common subsequence problem using the DP algorithm.\n\nDP algorithms are used because in many cases they are the only practical solution. And besides, there is nothing wrong with them.\n\nMemory usage: Often, a sliding window can be used to reduce the memory usage dramatically. Fibonacci, when solved using a naive bottom-up DP, requires O(n) memory. A sliding window improves this to O(1) memory (I know of the magical constant time solution, but that's beside the point).\n\nParallelization: Top-down DPs are often easy to parallelize. Bottom-ups may or may not be. @amit's example (parallelizing longest common subsequence) is a good one, where any given diagonal's tiles can be solved independently as long as the previous diagonals are known.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming to find minimal route\r\n                \r\nI am getting problems in devising solution for this DP problem\n\nSuppose you want to travel from city A to city B. There are n stopovers on the way where you have a number of choices to select a hotel to stay at every stopover. The cost involved is the travel cost to some hotel at a stopover (let’s call it tij where i is the current stopover and j is the next one) and the cost of staying at a hotel at stopover j (let’s call this sj). Devise a dynamic programming algorithm to select an optimal route and a hotel in city B that minimizes the cost of the whole trip. Analyze its correctness and running time. \n    ", "Answer": "\r\nHere's a possibly correct algorithm:\nDefine the stop as a1,a2,a3,a4,a5,a6.....an and the smallest cost at each stop be c1,c2,c3,c4,c5...cn\n\nfor the first stop. Calculate the cost of route from city A to a1 and store it in c1. \n\nfor the second stop. Calculate the cost of route from A to a2, and calculate the cost of route from a1 to a2 plus c1. Choose the smaller cost and store it to c2\n\nfor the third stop. Calculate the cost of route from A to a3, the cost of a1 to a3 plus c1, and the cost of a2 to a3 plus c2. Choose the smallest cost and store it to c3\n\n....\n...\n.\n\nThen at last, we can find cn+1, the smallest cost of route from A to B with the same steps above\n\nThe dynamic expression be ci=min(c1+t(1,i),c2+t(2,i),c3+t(3,i),....,c(i-1)+t(i-1,i))\n\nWe trying all the possible routes to each stop and find the smallest cost and thus why the answer is route we choose is minimized\n\nThe running time of such algorithm is O(n^2), thinking about build a two dimensional array with size n*n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming : The Zipper\r\n                \r\nDoing a little practice on dynamic programming problems in preparation for my final and I found this problem that stumped me.\n\nZippers:  Given three strings, you are to determine whether the third string can be formed by combining the characters in the first two strings. The first two strings can be mixed arbitrarily, but the characters from each must stay in their original order in the third string.\n\nFor example, consider forming \"tcarete\" from \"cat\" and \"tree\":\nString A: c a t\nString B: t r e e\nString C: t c a r e t e\n\nAs you can see, we can form string C by selecting the first charcter of \"tree\", followed by the first 2 characters of \"cat\", followed by the second and third characters of \"tree\", followed by the last charcter of \"cat\" and \"tree\" respectively.\n\nAs a second example, consider forming \"catrtee\" from \"cat\" and \"tree\":\nString A: c a t\nString B: t r e e\nString C: c a t r t e e\n\nThe answer for this input is also 'yes'\n\nOutput:  Output yes if A and B can be combined (zippered) into string C.\n  Output no if A and B cannot be combined to form C.\n\nSo basically we want to see if the third string, C can be formed from A and B. \nsomething like \nC T R T E A E would output No.\nMy biggest problem is the fact that cat and tree both have the letter T in it. So I can't just run an algorithm that checks if one letter comes after the other. Any help on this?\n    ", "Answer": "\r\nBecause you are reviewing dynamic programming, it should be rather natural to use it for this problem.\n\nNow, let's think about it this way:\n\n\nFor the whole String C, if it is a mixture of A and B, then its first character must be either the first character of A, or the first one in B;\nNow step further, the first ```\nk```\n characters in C, ```\nkA```\n < ```\nk```\n of them must be from A, and ```\nkB```\n = ```\nk```\n - ```\nkA```\n of them must be from B.\n\n\nFrom this, it is not hard to find out an algorithm that use O(min(len(A), len(B))) space and use O(len(C) * min(len(A), len(B))) to run.\n\nHint: for each step through C, some of the positions in A must be \"On\", while the others are \"off\". In the end if all the character in both strings are consumed, then C can be generated from A and B.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming dependence on greater states\r\n                \r\nThere are N number of cities. Each city has a teleport of type 1 to 10(inclusive). You are given an array of size N representing each city's teleport type by integer. For ex. ```\n1 3 5 3 8 9```\n. The goal is to find the minimum amount of hours it takes to get from the first entry in the array to the last given the following rules:\n\n\nFrom each city (entry in the array) you can move to it's left or right neighbor (if it has one) and that action costs 1 hour.\nFrom each city you can teleport to another one with the same type of teleport as the one you're teleporting from. In the example array above you could teleport from the city at index 1 to city at index 3 because they both have the same type of teleport: ```\n3```\n. This action costs a given number R of hours.\n\n\nI have implemented a dynamic programming solution that works perfectly fine when the fastest way is only moving forward. But for some cases, it's quicker to go back few cities to then teleport forward, thus minimizing the amount of hours spent. \n\nThis is an example of when my algorithm fails: ex. ```\n2 1 3 4 6 8 5 7 4 2 3 5 2 1 3 4 3 5 6 7```\n and   ```\nR = 2```\n \nCorrect answer: index 0 (time = 0) -> index 9 (time = 2) -> index 8 (time = 3) -> index 7 (time = 4) -> index 19 (time = 6).\nMy algorithm would find the quickest way only moving forwards, when clearly, the correct quickest way also involves moving backwards.\n\nHere's my code so far:\n\n```\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    int dp[200] = {};\n    short ti[200] = {};\n    int numCities, R;\n    cin >> numCities >> R;\n\n    for (int i = 0; i < numCities; i++)\n    {\n        short temp;\n        cin >> temp;\n        ti[i] = temp;\n    }\n\n    for (int i = 1; i < numCities; i++)\n    {\n        dp[i] = dp[i - 1] + 1;\n\n        for (int x = i - 1; x >= 0; x--)\n        {\n            if (ti[x] == ti[i])\n            {\n                if (R + dp[x] < dp[i])\n                     dp[i] = R + dp[x];\n            }\n        }\n    }\n\n    cout << dp[numCities - 1];\n\n    return 0;\n}\n```\n\n\nHow do I make my algorithm work for these kind of cases, where a lower state depends on a greater one?\n\nEDIT: I use dynamic programming the following way: For each of the cities, I compute the quickest way to get to them given the starting state ```\ndp[0] = 0```\n.\nThen the recurrence relation is: ```\ndp[i] = min(dp[i - 1] + 1, dp[every other point with same teleport type] + R)```\n\n    ", "Answer": "\r\nDynamic programming works in instances where the problem has an optimal substructure. That is, you have to find a way to subdivide a problem such that the best solution to the subdivisions can be used as a building-block to find the best solution to the entire problem.\n\nAbove, I see you say that you want to use dynamic programming. And I see code. What I don't see is a clear explanation of what sub-problems you're considering. That is: a conceptual understanding of the solution is key to getting dynamic programming right, and this is exactly what you do not provide.\n\nMy instinct is that dynamic programming is not a good way to go in this instance since:\n\n\nRe-arranging the entries in the array destroys information about local movements\nIt is possible, from the starting point, to move to any entry in the array - an inherent non-localism.\n\n\nYou cope with these issues by using a nested loop. This gives you an O(n^2) time solution.\n\nHowever, considering this problem as an instance of weighted graph traversal allows you to solve it using Dijkstra's algorithm in O(n log n + m) time (an O(n) traversal being sufficient to establish each node's neighbors) where m is the number of edges considered (here it is possible to limit this to a value of Θ(m) by recognizing that each teleporter type will only be used once). Why not do this?\n\nYou could try to improve run-times by using A*, though I'm not convinced this will provide much improvement in one dimension.\n\nCode to accomplish this might look like the following:\n\n```\n#include <iostream>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n\ntypedef std::unordered_map<int, std::vector<int> > tele_network_t;\n\nint Dijkstra(const std::vector<int> &graph, const tele_network_t &tn, const int R){\n  //This whole mess makes the smallest elements pop off the priority queue first\n  std::priority_queue<\n    std::pair<int, int>,\n    std::vector< std::pair<int, int> >,\n    std::greater< std::pair<int, int> >\n  > pq; //<distance, index>\n\n  //Keeping track of the teleporters used allows us to speed up the algorithm by\n  //making use of the theorem that each teleporter type will be used only once.\n  std::unordered_set<int> teleporters_used; \n\n  //Keep track of the path\n  std::vector<int> parent(graph.size(),-1); //Parent==-1 indicates an unvisited node\n\n  //At 0 distance, place the 0th node\n  pq.emplace(0,0);\n  parent[0] = 0; //The only node whose parent is itself should be node 0\n\n  while(!pq.empty()){\n    const auto c = pq.top();\n    pq.pop();\n\n    //We've reached the goal node\n    if(c.second==graph.size()-1){\n      std::cout<<\"Dist = \"<<c.first<<std::endl;\n      break;\n    }\n\n    //Insert neighbours\n    if(c.second!=0 && parent[c.second-1]==-1){ //Left neighbour\n      parent[c.second-1] = c.second;\n      pq.emplace(c.first+1,c.second-1);\n    }\n    if(parent[c.second+1]==-1){ //Right neighbour: can't overflow because goal is the rightmost node\n      parent[c.second+1] = c.second;\n      pq.emplace(c.first+1,c.second+1);\n    }\n\n    //Inner loop is executed once per teleporter type\n    if(teleporters_used.count(graph[c.second])==0)\n      for(const auto i: tn.at(graph[c.second])){\n        if(parent[i]==-1){\n          pq.emplace(c.first+R,i);\n          parent[i] = c.second;\n        }\n      }\n\n    teleporters_used.insert(graph[c.second]);\n  }\n\n  //Trace our steps backwards to recover the path. Path will be reversed, but a\n  //stack could be used to fit this.\n  int p = graph.size()-1;\n  while(parent[p]!=p){\n    std::cout<<p<<std::endl;\n    p = parent[p];\n  }\n  std::cout<<0<<std::endl;\n}\n\nint main(){\n  tele_network_t tele_network;\n\n  const int R = 2;\n  std::vector<int> graph = {{2,1,3,4,6,8,5,7,4,2,3,5,2,1,3,4,3,5,6,7}};\n\n  //Determine network of teleporters\n  for(int i=0;i<graph.size();i++)\n    tele_network[graph[i]].push_back(i);\n\n  Dijkstra(graph, tele_network, 2);\n}\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Is independence of subproblems in dynamic programming an issue?\r\n                \r\nWhile reading CLRS section 15.3 about \"When I should use dynamic programming.\" and during the explanation of Optimal substructure they gave 2 examples, they are unweighted longest simple path and unweighted shortest path.\nThey said,\n\nThe subproblems in finding the longest simple path are not independent, whereas for shortest paths they\n\nThat's why we can't solve unweighted longest simple path using dynamic programming and I don't have any problem with that but they also said\n\nBoth problems examined in Sections 15.1 and 15.2 have independent subproblems ...... In rod cutting, to determine the best way to cut up a rod of length n, we look at the best ways of cutting up rods of length I for I = 0, 1,..., n-1. Because an optimal solution to the length -n problem includes just one of these subproblem solutions (after we have cut off the first piece), independence of subproblems is not an issue.\n\nThe last sentence\n\nindependence of subproblems is not an issue.\n\nIs the independence of subproblems an issue or not? and If not an issue so why they said the first quote or I'm just me misunderstanding something.\n    ", "Answer": "\r\nThe problem is that you cannot simply merge the answers to two dependent subproblems.\nIf problems are independent, that is fine.  If you only look at one subproblem, likewise that is fine.  But if you need to combine 2 answers and they are dependent, you have to maintain some additional state.\nWhere, as in the case of the longest simple path, \"some additional state\" may blow up on you exponentially. :-)\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming interval scheduling with time between jobs\r\n                \r\nI'm trying to program the interval scheduling problem with dynamic programming. All jobs have different (positive) weights and don't overlap. These weights represent different run times. An idle time of three \"gaps\" may exist between jobs. Furthermore, each time unit for each job (in seconds) takes one resource. The resources can all have different values. I want to find the smallest sum of resources for all jobs with a dynamic programming algorithm (recursively).\n\nIt may be more clear with an example:\n\nLet's say you have three jobs with ```\ntime units { 2, 2, 3 }```\n and you have a list of resources of eight long ```\n{ 2, 5, 1, 8, 4, 1, 1, 5 }```\n. Job one takes two time units and thus two resources, and because it's the first job it will take the first 2 resources of the resources-list. Job two doesn't have to start immediately after job one, it can also start from one of the next three \"gaps\". This second job takes also two resources and because it can start from one of the three gaps and it's not the first job, the possibilities of resources that it can take are ```\n(1,8) (8,4) (4,1) (1,1) = 9 12 5 2```\n (the different sums of the available resources). The sum of all jobs is of course less than the number of resources.\n\nThis is continued until all jobs are finished. I want to find the smallest sum of resources for all jobs with a dynamic programming algorithm (recursively).\n\nI tried different solving methods, but I find this one very hard to solve recursively without any other function.\n\nI did write the following code, which is not doing as I expected:\n\n```\npublic static double getCost(int t, int q, int r, int[] jobs, double[] resources){\n    double table[][] = new double[t+1][r+1];\n    for(int i = 0;i < t;i++){\n        for(int j = 0;j < r;j++){\n            double cost = 0;\n            for(int k = j-jobs[i] + 1;k <= j;k++){\n                if(k < 0){\n                    break;\n                }\n                cost = cost + resources[k];\n            }\n            double min = Double.POSITIVE_INFINITY;\n            for(int l = 1;l <= q;l++){\n                if(i == 0 && l == 1){\n                    min = cost+j-jobs[0]-l;\n                }\n                else{\n                    double neww = cost+j-jobs[i]-l;\n                    if(neww < min){\n                        min = neww;\n                    } \n                }\n            }\n            table[i+1][j+1] = min;\n        }\n    }\n    return table[t][r];\n}\n```\n\n\nCan someone please give me some advice?\n    ", "Answer": "\r\nFirst, you need to define the state for each subproblem, so:\n\n```\nsum[t][r] = Minimum cost using up to 't' indexes in 'timeUnits',\n            and 'r' indexes in 'resources' (exclusive indexes).\n```\n\n\nThe base case is:\n\n```\nsum[0][0] = 0\n```\n\n\nThen update the array values based on previous values. There are two things to calculate: the cost of running a job, and what to add it on to (gap size).\n\n```\nFor each t\n  For each r\n    cost = Sum(resources[i]) for i = r-timeUnits[t]+1 ... r\n    sum[t+1][r+1] = Min(cost + sum[t][r-timeUnits[t]-gap+1]) for gap = 0 ... 2 (0 only for t=0)\n```\n\n\nThe final cost is the minimum value where all time units are used.\n\nEdit: I modified your code so that it passed your test case.\n\n```\nint[] jobs = { 2, 2, 2 };\nint[] resources = { 1, 2, 3, 4, 5, 6, 7, 8, 1, 1 };\nint q = 2;\nint t = jobs.length;\nint r = resources.length;\n\ndouble table[][] = new double[t+1][r+1];\n\nfor(int i = 0;i <= t;i++){\n    for(int j = 0;j <= r;j++){\n        table[i][j] = Double.POSITIVE_INFINITY;\n    }\n}\ntable[0][0] = 0;\n\nfor(int i = 0;i < t;i++){\n    for(int j = 0;j < r;j++){\n        double cost = 0;\n        for(int k = j-jobs[i] + 1;k <= j;k++){\n            if(k < 0){\n                cost = Double.POSITIVE_INFINITY;\n                break;\n            }\n            cost = cost + resources[k];\n        }\n\n        double min = Double.POSITIVE_INFINITY;\n        for(int l = 0;l <= q;l++) {\n            int index = j-jobs[i]-l+1;\n            if(index >= 0 && index <= r) {\n                min = Math.min(min, cost + table[i][index]);\n            }\n            if(i == 0) break;\n        }\n\n        table[i+1][j+1] = min;\n    }\n}\n\ndouble best = Double.POSITIVE_INFINITY;\nfor(int x = 0; x < r; x++) {\n    best = Math.min(best, table[t][x+1]);\n}\n\nSystem.out.println(\"Best cost: \" + best);\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Can I use dynamic programming to solve this?\r\n                \r\nI have very little experience with dynamic programming.  I used it to solve a DNA alignment problem, a basic knapsack problem, and a simple pathfinding problem.  I understood how they worked, but it's not something I feel absolutely comfortable with yet.  \n\nI have a problem that reminds me of 0-1 dynamic programming, but the differences have thrown me off, and I'm not sure if I can still use this technique, or if I have to settle for a recursive approach.\n\nLet's say I have a list of items, each with different values, weights, and costs.  There may be more than one of each item.\n\nLet's say I have to choose a combo of those items which is the most valuable, but remains within the limits of weight and cost.  So far, I've described the knapsack problem, pretty much, with 2 constraints.  But here's the difference:\n\nThe value of a chosen item changes depending on how many of them I have in the combo.  \n\nLet's say that each item has a function associated with it, that tells me what a group of those items is worth to me.  It's a basic linear function, such as \nvalue_of_item = -3(quantity of that item) + 50\n\nSo if I have 1 of some item in a combo, then it's value to me is 47.  If I had 2 of them, then they're only worth 44 to me, each.  \n\nIf I use a dynamic programming table for this, then for each cell I'd have to backtrack to see if that item is already in the current combo, making DP pointless.  But maybe there's a way to re-frame the problem so I can take advantage of DP.\n\nHopefully that made sense.  \n\nThe alternative is to generate every combo of items, within the limits of cost and weight, figure the value of each combo, choose the most valuable combo.  For a list of 1000 items even, that's going to be an expensive search, and it's something I'd be calculating repeatedly.  I'd like to find a way to exploit the advantages of DP.\n    ", "Answer": "\r\nIf your functions are of the form \n\n```\nvalue(x, count) = base(x) - factor(x) * count, factor(x) > 0,\n```\n\n\nthen you can reduce the problem to standard knapsack by splitting the items:\n\n```\nx -> x_1 to x_max_count\nvalue_new(x_i) = value(x, i)\nweight(x_i) = weight(x)\n```\n\n\nNow you easily verify that no optimal solution to the new problem uses some item ```\nx_j```\n, without using every ```\nx_i```\n with i < j.\n\nProof by contradiction: Assume there is such an optimal solution S and it uses ```\nx_j```\n, but not ```\nx_i```\n, j > i. Then there is an alternative solution S' that uses ```\nx_i```\n instead of ```\nx_j```\n. Since j > i, \n\n```\nvalue_new(x_j) = value(x, j) \n               = base(x) - factor(x) * j \n               < base(x) - factor(x) * i\n               = value(x, i)\n               = value_new(x_i)\n```\n\n\nand therefore S' has a higher value than S and we reached a contradiction.\n\nFurthermore, we can allow ```\nfactor(x) = 0```\n, this corresponds to a standard knapsack item.\n\nHowever if there is a constraint of the form\n\n```\nvalue(x, count) = base(x) + factor(x) * count\n```\n\n\nwhere ```\nfactor(x)```\n is an arbitrary value, the solution above does no longer work, because the last item would be the one with the largest value. Maybe some sophisticated modification of DP may allow you to use such constraints, but I don't see any modifications of the problem itself to use DP right away.\n\nSome research in this topic (more general):\n\n\nhttp://dept.cs.williams.edu/~heeringa/publications/knapsack.pdf\nhttp://clweb.csa.iisc.ernet.in/vsuresh/Kamesh-PLKP.pdf\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Real code in dynamic programming with problems like knapsack in PHP [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Questions asking us to recommend or find a tool, library or favorite off-site resource are off-topic for Stack Overflow as they tend to attract opinionated answers and spam. Instead, describe the problem and what has been done so far to solve it.\r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nAre there any resources where I could find real code which solves problems in Dynamic Programming like knapsack problem and so on in PHP?\n\nI want to analyze code by myself, because I can't quite understand theory. And I can't find any code in Google.\n\nThank you very much.\n    ", "Answer": "\r\nHere's the problem solved using PHP (source):\n\n```\n#########################################################\n# 0-1 Knapsack Problem Solve with memoization optimize and index returns\n# $w = weight of item\n# $v = value of item\n# $i = index\n# $aW = Available Weight\n# $m = Memo items array\n# PHP Translation from Python, Memoization,\n# and index return functionality added by Brian Berneker\n#\n#It works uncorrectly! For examle if $aw=4. Max value is true, but no \"Array Indices\" and its parameters are displayed\n#\n#########################################################\n\nfunction knapSolveFast2($w,$v,$i,$aW,&$m) {\n\n    global $numcalls;\n    $numcalls ++;\n    // echo \"Called with i=$i, aW=$aW<br>\";\n\n    // Return memo if we have one\n    if (isset($m[$i][$aW])) {\n        return array( $m[$i][$aW], $m['picked'][$i][$aW] );\n    } else {\n\n        // At end of decision branch\n        if ($i == 0) {\n            if ($w[$i] <= $aW) { // Will this item fit?\n                $m[$i][$aW] = $v[$i]; // Memo this item\n                $m['picked'][$i][$aW] = array($i); // and the picked item\n                return array($v[$i],array($i)); // Return the value of this item and add it to the picked list\n\n            } else {\n                // Won't fit\n                $m[$i][$aW] = 0; // Memo zero\n                $m['picked'][$i][$aW] = array(); // and a blank array entry...\n                return array(0,array()); // Return nothing\n            }\n        }   \n\n        // Not at end of decision branch..\n        // Get the result of the next branch (without this one)\n        list ($without_i,$without_PI) = knapSolveFast2($w, $v, $i-1, $aW,$m,$pickedItems);\n\n        if ($w[$i] > $aW) { // Does it return too many?\n\n            $m[$i][$aW] = $without_i; // Memo without including this one\n            $m['picked'][$i][$aW] = array(); // and a blank array entry...\n            return array($without_i,array()); // and return it\n\n        } else {\n\n            // Get the result of the next branch (WITH this one picked, so available weight is reduced)\n            list ($with_i,$with_PI) = knapSolveFast2($w, $v, ($i-1), ($aW - $w[$i]),$m,$pickedItems);\n            $with_i += $v[$i];  // ..and add the value of this one..\n\n            // Get the greater of WITH or WITHOUT\n            if ($with_i > $without_i) {\n                $res = $with_i;\n                $picked = $with_PI;\n                array_push($picked,$i);\n            } else {\n                $res = $without_i;\n                $picked = $without_PI;\n            }\n\n            $m[$i][$aW] = $res; // Store it in the memo\n            $m['picked'][$i][$aW] = $picked; // and store the picked item\n            return array ($res,$picked); // and then return it\n        }   \n    }\n}\n\n\n\n$items4 = array(\"map\",\"compass\",\"water\",\"sandwich\",\"glucose\",\"tin\",\"banana\",\"apple\",\"cheese\",\"beer\",\"suntan cream\",\"camera\",\"t-shirt\",\"trousers\",\"umbrella\",\"waterproof trousers\",\"waterproof overclothes\",\"note-case\",\"sunglasses\",\"towel\",\"socks\",\"book\");\n$w4 = array(9,13,153,50,15,68,27,39,23,52,11,32,24,48,73,42,43,22,7,18,4,30);\n$v4 = array(150,35,200,160,60,45,60,40,30,10,70,30,15,10,40,70,75,80,20,12,50,10);\n\n## Initialize\n$numcalls = 0; $m = array(); $pickedItems = array();\n\n## Solve\nlist ($m4,$pickedItems) = knapSolveFast2($w4, $v4, sizeof($v4) -1, 400,$m,$pickedItems);\n\n# Display Result \necho \"<b>Items:</b><br>\".join(\", \",$items4).\"<br>\";\necho \"<b>Max Value Found:</b><br>$m4 (in $numcalls calls)<br>\";\necho \"<b>Array Indices:</b><br>\".join(\",\",$pickedItems).\"<br>\";\n\n\necho \"<b>Chosen Items:</b><br>\";\necho \"<table border cellspacing=0>\";\necho \"<tr><td>Item</td><td>Value</td><td>Weight</td></tr>\";\nforeach($pickedItems as $key) {\n    $totalVal += $v4[$key];\n    $totalWt += $w4[$key];\n    echo \"<tr><td>\".$items4[$key].\"</td><td>\".$v4[$key].\"</td><td>\".$w4[$key].\"</td></tr>\";\n}\necho \"<tr><td align=right><b>Totals</b></td><td>$totalVal</td><td>$totalWt</td></tr>\";\necho \"</table><hr>\";\n```\n\n\nOutput:\n\nItems: map, compass, water, sandwich, glucose, tin, banana, apple, cheese, beer, suntan cream, camera, t-shirt, trousers, umbrella, waterproof trousers, waterproof overclothes, note-case, sunglasses, towel, socks, book\n\nMax Value Found:  1030 (in 8725 calls)\n\nArray Indices: 0,1,2,3,4,6,10,15,16,17,18,20\n\nChosen Items:\n\n```\nItem                        Value             Weight\n map                         150                9\n compass                     35                 13\n water                       200                153\n sandwich                    160                50\n glucose                     60                 15\n banana                      60                 27\n suntan cream                70                 11\n waterproof trousers         70                 42\n waterproof overclothes      75                 43\n note-case                   80                 22\n sunglasses                  20                 7\n socks                       50                 4\n Totals                      1030               396\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming: Optimal Binary Search Tree\r\n                \r\nAllright, I'm hoping someone can explain this to me.  I'm studying for finals and I can't quite figure something out.\n\nThe problem is dynamic programming; constructing an optimal binary search tree (OBST).  I understand dynamic programming in general and the concepts of this problem in particular, but I don't understand the recursive form of this problem.\n\nI get that we're constructing optimal binary search trees for an increasing subset of these nodes and keeping the answers in a table as we go along to avoid recalculation. I also get that when you root the tree at a_{k}, all of the successful nodes from a_{1} through a_{k-1} along with their corresponding fictitious unsuccessful nodes (i.e. the leaves of the tree) are in the left subtree, and then the ones in the right subtree are a_{k+1} through a_{n}.\n\nHere's the recursive form of the equation that I don't understand:\n\nc(i, j) = min (i < k <= j) {c(i, k-1) + c(k, j) + p(k) + w(i, k-1) + w(k +j)}\n\nwhere w(i, j) = q(i) + sum from i+1 to j (q(l) + p(l)).\n\nSo in c(i,j), from left to right, we have the cost of left subtree + cost of right subtree + probability of successful search for root + w(i, k-1) + w(k +j).\n\nMy confusion is how c(i, k-1) differs from w(i, k-1).\n\nThe text is Computer Algorithms by Horowitz, Sahni, and Rajasekeran but I've also read CLRS on OBSTs and searched online, and nothing I've come across does a good job of explaining the difference between those parts of the equation.  \n    ", "Answer": "\r\nc(i,j) represents the expected cost of searching an optimal binary search tree containing the keys ki, ..., kj. w(i,j) represents the probability sum of the subtree containing the keys ki, ..., kj. For the formula：\n\n```\nc(i, j) = min (i < k <= j) {c(i, k-1) + c(k, j) + p(k) + w(i, k-1) + w(k,j)}\n```\n\n\nc(i,k-1)+w(i,k-1) reresents the cost for the left subtree if we choose key k as the root.\nc(k,j)+w(k,j) represents the cost for the right subtree.\np(k) represents the cost for the root k.\n\nNotice that: If we choose key k as the root, then the left subtree contains the keys ki, ..., k(k-1) and the right subtree contains the kyes\nk(k+1), ..., kj. But we can not simply say that: \n\n```\nc(i,j)=min (i < k <= j) {c(i, k-1) + c(k, j) + p(k)}\n```\n\n\nBecause when we choose the key k for the root, the generated subtrees has their depth added by 1. So c(i,k-1)+w(i,k-1) will be the right cost for the left subtree!\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "optimised pascals triangle with dynamic programming using python\r\n                \r\n```\ndef pascal(row, col):\n    if col == 1 or col == row:\n        return 1\n    else:\n        return pascal(row - 1, col) + pascal(row - 1, col - 1)\n```\n\nThe above recursive implementation is exponential in terms of time complexity.  With the knowledge of Dynamic Programming, how do we write a function fast_pascal(row, col)?\nThe function should take in an integer row and an integer col and return the value in (row, col). Note: row and col starts from 1.\nThis is what i tried,\n```\ndef fast_pascal(row,col):\ndynamic = [[1]+[1]*(col-1)for i in range(row)]\nfor row_ind in range(1,row):\n    for col_ind in range(1,col):\n        dynamic[row_ind][col_ind] = dynamic[row_ind-1][col_ind] + dynamic[row_ind-1][col_ind-1]\nreturn dynamic[row-1][col-1]\n```\n\nThe code gives the wrong results. Its supposed to be,\n```\nfast_pascal(3,2) == 2\nfast_pascal(4,3) == 3\nfast_pascal(500,3) == 124251\n```\n\n    ", "Answer": "\r\n```\ndef fast_pascal(row,col):\n    dynamic = [[1]+[0]*(col-1)for i in range(row)]\n    for row_ind in range(1,row):\n        for col_ind in range(1,col):\n            dynamic[row_ind][col_ind] = dynamic[row_ind-1][col_ind] + dynamic[row_ind-1][col_ind-1]\n    return dynamic[row-1][col-1]\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "1d array or 2d array when solving dynamic programming problems\r\n                \r\nMy question is how can you identify when to use a 1d array or 2d array for a dynamic programming problem. For instance, I stumbled upon the problem number of ways to make change\nHere is an example:\ninputs ```\nn = 12```\n and ```\ndenominations = [2, 3, 7]```\n,\nsuppose you can pick an unlimited (infinite) amount of coins of each of the denominations you have. In how many ways can you make change for ```\n12```\n. The answer is ```\n4```\n\nI got to the answer using dynamic programming and here is my code\n```\ndef numberOfWaysToMakeChange(n, denoms):\n    if n == 0 or len(denoms) == 0:\n        return 1\n\n    ways = [[0 for _ in range(n + 1)] for _ in range(len(denoms))]\n\n    for row in ways:\n        row[0] = 1\n\n    for i in range(n + 1):\n        if i % denoms[0] == 0:\n            ways[0][i] = 1\n\n    for i in range(1, len(denoms)):\n        for j in range(1, n + 1):\n            if denoms[i] > j:\n                ways[i][j] = ways[i - 1][j]\n            else:\n                ways[i][j] = ways[i - 1][j] + ways[i][j - denoms[i]]\n\n    return ways[-1][-1]\n\n\nresult = numberOfWaysToMakeChange(12, [2, 3, 7])\n\nprint(result)\n```\n\nBut online I found an answer that works as well that looks like the following\n```\nways = [0 for _ in range(n + 1)]\nways[0] = 1\nfor denom in denoms:\n  for amount in range(1, n+1):\n    if denom <= amount:\n      ways[amount] += ways[amount - denom]\n\nreturn ways[n]\n```\n\nHow can you identify when you can use a 1d array for these kind of questions?\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Can I use dynamic programming to solve this?\r\n                \r\nI have very little experience with dynamic programming.  I used it to solve a DNA alignment problem, a basic knapsack problem, and a simple pathfinding problem.  I understood how they worked, but it's not something I feel absolutely comfortable with yet.  \n\nI have a problem that reminds me of 0-1 dynamic programming, but the differences have thrown me off, and I'm not sure if I can still use this technique, or if I have to settle for a recursive approach.\n\nLet's say I have a list of items, each with different values, weights, and costs.  There may be more than one of each item.\n\nLet's say I have to choose a combo of those items which is the most valuable, but remains within the limits of weight and cost.  So far, I've described the knapsack problem, pretty much, with 2 constraints.  But here's the difference:\n\nThe value of a chosen item changes depending on how many of them I have in the combo.  \n\nLet's say that each item has a function associated with it, that tells me what a group of those items is worth to me.  It's a basic linear function, such as \nvalue_of_item = -3(quantity of that item) + 50\n\nSo if I have 1 of some item in a combo, then it's value to me is 47.  If I had 2 of them, then they're only worth 44 to me, each.  \n\nIf I use a dynamic programming table for this, then for each cell I'd have to backtrack to see if that item is already in the current combo, making DP pointless.  But maybe there's a way to re-frame the problem so I can take advantage of DP.\n\nHopefully that made sense.  \n\nThe alternative is to generate every combo of items, within the limits of cost and weight, figure the value of each combo, choose the most valuable combo.  For a list of 1000 items even, that's going to be an expensive search, and it's something I'd be calculating repeatedly.  I'd like to find a way to exploit the advantages of DP.\n    ", "Answer": "\r\nIf your functions are of the form \n\n```\nvalue(x, count) = base(x) - factor(x) * count, factor(x) > 0,\n```\n\n\nthen you can reduce the problem to standard knapsack by splitting the items:\n\n```\nx -> x_1 to x_max_count\nvalue_new(x_i) = value(x, i)\nweight(x_i) = weight(x)\n```\n\n\nNow you easily verify that no optimal solution to the new problem uses some item ```\nx_j```\n, without using every ```\nx_i```\n with i < j.\n\nProof by contradiction: Assume there is such an optimal solution S and it uses ```\nx_j```\n, but not ```\nx_i```\n, j > i. Then there is an alternative solution S' that uses ```\nx_i```\n instead of ```\nx_j```\n. Since j > i, \n\n```\nvalue_new(x_j) = value(x, j) \n               = base(x) - factor(x) * j \n               < base(x) - factor(x) * i\n               = value(x, i)\n               = value_new(x_i)\n```\n\n\nand therefore S' has a higher value than S and we reached a contradiction.\n\nFurthermore, we can allow ```\nfactor(x) = 0```\n, this corresponds to a standard knapsack item.\n\nHowever if there is a constraint of the form\n\n```\nvalue(x, count) = base(x) + factor(x) * count\n```\n\n\nwhere ```\nfactor(x)```\n is an arbitrary value, the solution above does no longer work, because the last item would be the one with the largest value. Maybe some sophisticated modification of DP may allow you to use such constraints, but I don't see any modifications of the problem itself to use DP right away.\n\nSome research in this topic (more general):\n\n\nhttp://dept.cs.williams.edu/~heeringa/publications/knapsack.pdf\nhttp://clweb.csa.iisc.ernet.in/vsuresh/Kamesh-PLKP.pdf\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "0-1 knapsack dynamic programming solution does not work\r\n                \r\nThis is the 0-1 knapsack problem dynamic programming code found on geeks for geeks. I've changed the input for my own test, but it doesn't seem to work. Wouldn't the optimal solution be 1 of item 4 (v:10, w:7) and 3 of item 1 (v:1, w:1) adding up to 13? When I run the code and do the algorithm by hand it turns out to be 12 with items 2 and 4. Where am I going wrong?\n\n```\n// A Dynamic Programming based solution for 0-1 Knapsack problem\n#include<stdio.h>\n\n// A utility function that returns maximum of two integers\nint max(int a, int b) { return (a > b)? a : b; }\n\n// Returns the maximum value that can be put in a knapsack of capacity W\nint knapSack(int W, int wt[], int val[], int n)\n{\nint i, w;\nint K[n+1][W+1];\n\n// Build table K[][] in bottom up manner\nfor (i = 0; i <= n; i++)\n{\n    for (w = 0; w <= W; w++)\n    {\n        if (i==0 || w==0)\n            K[i][w] = 0;\n        else if (wt[i-1] <= w)\n            K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]], K[i-1][w]);\n        else\n            K[i][w] = K[i-1][w];\n    }\n}\n\nreturn K[n][W];\n}\n\nint main()\n{\n    int val[] = {1, 2, 5, 10};\n    int wt[] = {1, 3, 4, 7};\n    int W = 10;\n    int n = sizeof(val)/sizeof(val[0]);\n    printf(\"%d\", knapSack(W, wt, val, n));\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nBecause this algorithm solves 0-1 Knapsack problem. \n\nIn this formulation only one instance of every item is available. That is why solution uses items once.\n\n(perhaps you was thinking about knapsack with unlimited (or restricted) quantity for every item)\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Independence property of sub problems for dynamic programming techniques to apply\r\n                \r\nTwo criteria for an algorithm to be solved by dynamic programming technique  is \n\n\nSub problems should be independent.\nSub problems should overlap .\n\n\nI think I understand what overlapping means . It basically means that the subproblems have subsubproblems that may be the same . So instead of solving the subsubproblem over and over again we solve it once, put it in a hashtable or array and can look it up the nest time it is required . But what does point 1 ie independence of subproblems mean here ? If they have some common subsubproblems how can we call them to be independent? I mean it sounds very much counterintuitive to me at this stage . \n\nEdit: This crtiteria is actually given in the famous book: Introduction to Algorithms by CLRS in the Dynamic Programming chapter. \n    ", "Answer": "\r\nPlease tell us where you are reading that DP applies to problems with overlapping and independent sub-problems.  I don't think that's correct, for the same intuitive reason you give-- if the problems overlap, they aren't independent. \n\nI usually see independent sub-problems given as a criterion for Divide-And-Conquer style algorithms, while I see overlapping sub-problems and optimal sub-structure given as criteria for the Dynamic Programming family.  (Intuitively, optimal substructure means that the best solution of a larger problem is composed of the best solutions of sub-problems.  The classic example is the shortest path in a graph problem:  If you know that the shortest path from A to B goes through C, then you also know that the part of the shortest path from A to B that goes through C happens to be the shortest path from A to C.)\n\nUPDATE: Oh, I see-- yes, I guess they do mention independence.  But I don't read that with the same emphasis that you are.  Meaning, they mention independence in the context of, or as a way of understanding, the larger and more important concept of optimal substructure.  \n\nWhat they mean specifically by independence is that even if two problems overlap, they are \"independent\" in the sense that they don't interact-- the solution to one does not really depend on the solution to the other.  They actually use the same example I did, the shortest path.  Sub-problems of the shortest path problem are smaller shortest path problems that are independent:  If the shortest path from A to B goes through C, then the shortest path from A to C doesn't use any edges in the shortest path from C to B.  The longest path problem, by contrast, does not share that independence of sub-problems.\n\nI don't think CLRS are wrong to bring up independence, but I do think the language they're using is a little ambiguous.  \n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "dynamic programming task / counting problem\r\n                \r\nI am struggling with a dynamic programming task I cannot solve. I've found in a book a similar problem when you are asked to calculate the number of solutions and it says that this is a counting problem not optimization problem which is obvious. I want an advice how to deal with this kind of tasks and i want to know if there is a general approach to this. I want to know the recursive relation here and which are the subproblems. Here is the problem:\n\nYou are given n places to place your cubes. Minimum three consecutive cubes are considered as a figure. Figures are separated by minimum one place. You are asked to calculate all ways you can place the figures on the free places. Here is a solution for n = 7. Blue squares represent free places to place a cube and red ones are the cubes. Number of ways is equal to 17.\n\n    ", "Answer": "\r\n@saeedn almost had it, but his recursive formula is not quite correct, as it has some missing cases and some double countings.\n\nLet's examine the possibilities for the first place, either it's a space (single space), or there is a figure there. The length of the figure could be 3,4,...,n-1,n.\nIf it is less then ```\nn```\n, we also need to add 'padding' before the next figure (to avoid double countings), so if we have a figure of 3 cubes, it has ```\nf(n-4)```\n different possibilities (with the first 3 cells being cubes). An exception is for a figure of ```\nn```\n nodes, because we cannot add a 'padding' after it.\n\nAnother possibility is a single space, and if there will be more spaces, the recursion will take care of it later on.\n\nThis gives us the following recursive formula:\n\n```\nf(0) = f(1) = f(2) = 1 (base)\nf(n) = f(n-4) + f(n-5) + ... + f(1) + f(0) +   f(0)      + f(n-1)\n         ^        ^             ^       ^       ^             ^\n         3        4             n-2     n-1      n           space\n       cubes    cubes          cubes    cubes   cubes\n         +         +             +       +        +\n        space    space         space    space   space   \n```\n\n\nSo, if we imply this formula to a DP algorithm, we'll get:\n\n```\narr[n+1] = [0,0,...,0]\narr[0] = arr[1] = arr[2] = 1\nfor (int i = 3; i < n+1; i++) \n   for (int j = 0; j <= i - 4; j++)  //f(n-4) + f(n-5) + ... + f(1) + f(0)\n      arr[i] += arr[j]\n   arr[i] += arr[0] // extra one f(0) for a shape with i cubes\n   arr[i] += arr[i-1] // space\nreturn arr[n]\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "find the row with the largest sum in a matrix dynamic programming\r\n                \r\ni have a matrix and I have to find the row with the largest  sum. The algorithm should use dynamic programming.\n\n4 5 3 2 1\n2 2 7 2 5\n1 4 2 5 6\n9 1 2 1 6\n\nThe numbers need to be directly or diagonally connected.\nMy idea was to search the largest number in every line and check if it is directly or diagonally connected to the largest number of the next line. If not I go back, take the next smaller number and check again. But i notice that my idea is not use dynamic programming. This was my only idea.\n\nI hope you can help me.\n    ", "Answer": "\r\nI am mentioning this dp approach but it can be further optimized:\n\nLet given array be:\n\n```\na11 ... a1n\n.\n.\n. \nam1 ... amn\n```\n\n\nand solution be:\n\n```\ns11 ... s1n\n.\n.\n. \nsm1 ... smn\n```\n\n\nYou may start with first row and find soln. for each element in that row. This is your trivial case and ans will be same as row 1.\n\n```\ns11 = a11\n..\ns1n = a1n\n```\n\n\nNow row 2.\n\n```\ns21 = max(s11, s12) + a21;\ns22 = max(s11, s12, s13) + a22;\ns23 = max(s12, s13, s14) + a23;\n.\n.\n```\n\n\nNow in general:\n\n```\ns[m][n] = max(s[m-1][n-1], s[m-1][n], s[m-1][n+1]) + a[m][n];\n```\n\n\nIdea is to keep track of ans that ends on a particular element a[x][y]. Now it can only be reached from a[x-1][y-1] or a[x-1][y] or a[x-1][y+1].\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Aligning music notes using String matching algorithms or Dynamic Programming\r\n                \r\nI need to compare 2 sets of musical pieces (i.e. a playing-taken in MIDI format-note details extracted and saved in a database table, against sheet music-taken into XML format). When evaluating playing against sheet music (i.e.note details-pitch, duration, rhythm), note alignment needs to be done - to identify missed/extra/incorrect/swapped notes that from the reference (sheet music) notes. \n\nI have like 1800-2500 notes in one piece approx (can even be more-with polyphonic, right now I'm doing for monophonic). So will I have to have all these into an array? Will it be memory overloading or stack overflow?\n\nThere are string matching algorithms like KMP, Boyce-Moore. But note alignment can also be done through Dynamic Programming. How can I use Dynamic Programming to approach this? What are the available algorithms? Is it about approximate string matching? \n\nWhich approach is much productive? String matching algos like Boyce-Moore, or dynamic programming? How can I assess which is more effective?\n\nGreatly appreciate any insight or suggestions\nThanks in advance\n    ", "Answer": "\r\nInteresting question - I think this paper covers a lot of what you're interested in.  They address the issue of errors and music alignment and discuss their results using DP as a solver.  They introduce an algorithm called \"fast approximate matching\" which they claim is better than the DP approach. \n\nIt looks like the key authors to use in a search are Mongeau & Sankoff.  It would appear that their original paper set off a lot of work in this area.  \n\nNeat stuff.  Hope this helps. \n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming - avoiding Markov Chain's curse of dimensionality\r\n                \r\nDynamic Programming is cursed with the massive size of one-step transition probabilities' (Markov Chains) and state-system's size as the number of states increases - requires massive amounts of RAM to store such matrices. My question is if one can find an alternative way, even if more computationally more intensive, to solve the same problem without using so much memory? Consider the following:\n\n\nTo fill the Transition Probability Matrix one needs to define a set of rules, which can be incorporated into a Transition Function.\nIf the Transition Function is used to obtain the transition probability on each loop (instead of computing all the values once and storing them in a Matrix), then one avoids storing the Matrix, at the expense of longer running times.\nIf memoization is used (just noticed perhaps this isn't the correct term), that is, if instead of storing every single state (which in my case, is a combination of 4 state variables making it immensely big), then on each loop one uses the Transition Function to compute V (the expectation of V), and compares this value with the one previously found, if its cost function is smaller, store this value and policy. This way the state-space Matrix wouldn't have to be stored again, at the expense of longer running times.\n\n\nDoes this make sense for those who are proficient in Dynamic Programming (Bellman's Equation) ? I apologize if it makes no sense, I am touching Bellman's Dynamic Programming algorithms for the first time.\n\nIf someone has found evidence on how to avoid the curse of dimensionality using nested loops or any other form, do share.\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Explanation of Dynamic Programming solution\r\n                \r\nThis is the problem: given a number of bricks n, between 3 and 200, return the number of different staircases that can be built. Each type of staircase should consist of 2 or more steps.  No two steps are allowed to be at the same height - each step must be lower than the previous one. All steps must contain at least one brick. A step's height is classified as the total amount of bricks that make up that step.\n\nFor example, when N = 3, you have only 1 choice of how to build the staircase, with the first step having a height of 2 and the second step having a height of 1: (# indicates a brick)\n\n```\n#\n## \n21\n```\n\n\nWhen N = 4, you still only have 1 staircase choice:\n\n```\n#\n#\n##\n31\n```\n\n\nBut when N = 5, there are two ways you can build a staircase from the given bricks. The two staircases can have heights (4, 1) or (3, 2), as shown below:\n\n```\n#\n#\n#\n##\n41\n\n#\n##\n##\n32\n```\n\n\nI found a solution online, but I don't quite intuitively understand the dynamic programming solution.\n\n```\npublic class Answer {\n\n    static int[][] p = new int[201][201];\n\n    public static void fillP() {\n        p[1][1] = 1;\n        p[2][2] = 1;\n\n        for (int w = 3; w < 201 ; w++) {\n            for (int m = 1; m <= w; m++) {\n                if (w-m == 0) {\n\n                    p[w][m] = 1 + p[w][m-1];\n\n                } else if (w-m < m) {   \n\n                    p[w][m] =  p[w-m][w-m] + p[w][m-1];\n\n                } else if (w-m == m) {  \n                    p[w][m] = p[m][m-1] + p[w][m-1];\n\n                } else if (w-m >m) { \n\n                    p[w][m] = p[w-m][m-1] + p[w][m-1];\n                }\n\n            }\n        }\n    }\n\n    public static int answer(int n) {\n\n        fillP();\n        return p[n][n] - 1;\n\n    }\n\n}\n```\n\n\nIn particular, how would one come up with the relationships between each successive entry in the array?\n    ", "Answer": "\r\nThis is a very interesting question. First, let's try to understand the recurrence relation:\n\nIf we currently built a step of height ```\nh```\n and we have ```\nb```\n bricks left to use, the number of ways we could complete the staircase from here is equal to the sum of all the ways we can complete the staircase with the next step of height ```\nh'```\n and ```\nb - h'```\n bricks, for ```\n0 < h' < h```\n.\n\nOnce we have that recurrence relation, we can devise a recursive solution; however, at it's current state, the solution runs in exponential time. So, we just need to \"cache\" our results:\n\n```\nimport java.util.Scanner;\n\npublic class Stairs {\n  static int LIMIT = 200;\n  static int DIRTY = -1;\n  static int[][] cache = new int[LIMIT + 2][LIMIT + 2];\n\n  public static void clearCache() {\n    for (int i = 0; i <= LIMIT + 1; i++) {\n      for (int j = 0; j <= LIMIT + 1; j++) {\n        // mark cache as dirty/garbage values\n        cache[i][j] = DIRTY;\n      }\n    }\n  }\n\n  public static int numberOfStaircases(int level, int bricks, int steps) {\n    // base cases\n    if (bricks < 0) return 0;\n    if (bricks == 0 && steps >= 2) return 1;\n\n    // only compute answer if we haven't already\n    if (cache[level][bricks] == DIRTY) {\n      int ways = 0;\n      for (int nextLevel = level - 1; nextLevel > 0; nextLevel--) {\n        ways += numberOfStaircases(nextLevel, bricks - nextLevel, steps + 1);\n      }\n      cache[level][bricks] = ways;\n    }\n\n    return cache[level][bricks];\n  }\n\n  public static int answer(int n) {\n    clearCache();\n    return numberOfStaircases(n + 1, n, 0);\n  }\n\n  public static void main(String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    int n = scanner.nextInt();\n    System.out.println(answer(n));\n  }\n}\n```\n\n\nFrom the code you provided, it seems as if the author went one more step further and replaced the recursive solution with a purely iterative version. This means that the author made a bottom-up solution rather than a top-down solution.\n\nWe could also approach the problem more mathematically:\n\n```\nHow many distinct non-trivial integer partitions does n have?```\n\n\nSo for ```\nn = 6```\n, we have: ```\n5 + 1```\n, ```\n4 + 2```\n, ```\n3 + 2 + 1```\n. So ```\nanswer(6) = 3```\n. Interestingly enough, Euler proved that the number of distinct integer partitions for a given ```\nn```\n is always the same as the number of not necessarily distinct odd integer partitions.\n\n(As a side note, I know where this question comes from. Good luck!)\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Python: Numba njit mode for faster dynamic programming\r\n                \r\nI am new to Python. I would like to use Python for my numerical experiment, in which I need to solve many dynamic programming problems exactly. So, it is important to optimize my code for efficiency. My code actually works with ```\n@jit```\n with Numba, but I would like to push the performance further with ```\n@njit```\n. You could see from the below code that, I have tried to vectorize my operations inside the for loop for efficiency. As I mentioned before, ```\n@jit```\n works fine, but with ```\n@njit```\n, it keeps giving me error messages. It is common knowledge that solving dynamic programs exactly is computationally-intensive, and therefore I would really like to use ```\n@njit```\n to further push the performance. I could really use some help with how to change the code to allow for ```\n@njit```\n. Thank you so much in advance!\nMy code:\n```\nimport numba as nb\nimport numpy as np\n\n#DP computation\n@nb.njit\ndef dp(beta,cost,wcost,decisions,number_of_stages,states):\n    tbeta=1-beta\n    odcost=min((cost[-max(decisions):]+wcost)/beta[-max(decisions):])\n    terminal=(max(states)-states)*odcost\n    L=max(states)\n    D=number_of_stages\n    value=np.zeros((D+1,L+1))\n    choice=np.zeros((D+1,L)).astype(np.int64)\n    value[-1]=terminal\n    for s in range(D-1,L-2,-1):\n        intmatrix=cost[:, None]+np.outer(beta,value[s+1][1:L+1])+np.outer(tbeta,value[s+1][0:L])\n        choice[s]=intmatrix.T.argmin(axis=1)\n        value[s][0:L]=intmatrix[choice[s],np.arange(intmatrix.shape[1])]\n    \n    for s in range(L-2,-1,-1):\n        intmatrix=cost[:, None]+np.outer(beta,value[s+1][1:s+2])+np.outer(tbeta,value[s+1][0:s+1])\n        choice[s][0:s+1]=intmatrix.T.argmin(axis=1)\n        value[s][0:s+1]=intmatrix[choice[s][0:s+1],np.arange(intmatrix.shape[1])]\n        \n    return value, choice\n\n\n#initialization\ndecisions=np.arange(100)\nnumber_of_stages=200\nstates=np.arange(101)\n\nnp.random.seed(2021)\nbeta=np.append(0,np.random.uniform(0,1,max(decisions)))\nwcost=np.random.uniform(0,1)\ncost=np.square(beta)\n\n\n\nvalue, choice=dp(beta,cost,wcost,decisions,number_of_stages,states)\n```\n\nError Messages:\n```\nTypingError: No implementation of function Function(<built-in function getitem>) found for signature:\n \ngetitem(array(float64, 1d, C), Tuple(slice<a:b>, none))\n \nThere are 22 candidate implementations:\n      - Of which 20 did not match due to:\n      Overload of function 'getitem': File: <numerous>: Line N/A.\n        With argument(s): '(array(float64, 1d, C), Tuple(slice<a:b>, none))':\n       No match.\n      - Of which 2 did not match due to:\n      Overload in function 'GetItemBuffer.generic': File: numba\\core\\typing\\arraydecl.py: Line 162.\n        With argument(s): '(array(float64, 1d, C), Tuple(slice<a:b>, none))':\n       Rejected as the implementation raised a specific error:\n         TypeError: unsupported array index type none in Tuple(slice<a:b>, none)\n  raised from C:\\ProgramData\\Anaconda3\\lib\\site-packages\\numba\\core\\typing\\arraydecl.py:68\n```\n\n    ", "Answer": "\r\nIt seems numba does not support all kind of numpy fancy indexing. You have to get back to loops. This is pretty common with numba, you need to forget the numpy, vectorized way of coding to come back to explicit loops.\nThis should do the job, I just made the loops explicit.\n```\n@nb.njit\ndef dp(beta, cost, wcost, decisions, number_of_stages, states):\n    tbeta = 1 - beta\n    odcost = min((cost[-max(decisions) :] + wcost) / beta[-max(decisions) :])\n    terminal = (max(states) - states) * odcost\n    L = max(states)\n    D = number_of_stages\n    value = np.zeros((D + 1, L + 1))\n    choice = np.zeros((D + 1, L)).astype(np.int64)\n    value[-1] = terminal\n    for s in range(D - 1, L - 2, -1):\n        intmatrix = (\n            cost.reshape(-1, 1)\n            + np.outer(beta, value[s + 1][1 : L + 1])\n            + np.outer(tbeta, value[s + 1][0:L])\n        )\n        choice[s] = intmatrix.T.argmin(axis=1)\n        for i in range(intmatrix.shape[1]):\n            value[s][i] = intmatrix[choice[s][i], i]\n\n    for s in range(L - 2, -1, -1):\n        intmatrix = (\n            cost.reshape(-1, 1)\n            + np.outer(beta, value[s + 1][1 : s + 2])\n            + np.outer(tbeta, value[s + 1][0 : s + 1])\n        )\n        choice[s][0 : s + 1] = intmatrix.T.argmin(axis=1)\n        for i in range(intmatrix.shape[1]):\n            value[s][0 : s + 1][i] = intmatrix[choice[s][0 : s + 1][i], i]\n\n    return value, choice\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Array Index Out of Bounds for Dynamic Programming code [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        What causes a java.lang.ArrayIndexOutOfBoundsException and how do I prevent it?\r\n                            \r\n                                (24 answers)\r\n                            \r\n                    \r\n                Closed 5 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n```\npublic class Dynamic_Programming {\n\npublic static int HowManyWays(int n)\n{\n    int [] mem = new int[]{0,1};\n    for(int i = 2; i <= n; i++)\n    {\n        int sum = 0;\n        for(int k =1; k <= n-1; k++)\n        {\n            sum += mem[k]*mem[n-k];\n        }\n        mem[i] = sum;\n    }\n    return mem[n];\n}\n\npublic static void main (String [] args)\n{\n    long startTime = System.nanoTime();\n    System.out.println(\"For 2 matracies: \" + HowManyWays(2));\n    long totalTime = System.nanoTime()-startTime;\n    System.out.println(\"Time in nanoseconds: \" + totalTime);\n}\n```\n\n\n}\n\nThis is the code for a simple method that uses the dynamic programming technique in order to determine the number of ways to multiply n matrices together. However I keep getting and ```\nArrayIndexOutOfBounds```\n error when I run the program. It tells me that the problem is with this line of code right here. ```\nmem[i] = sum;```\n. Some guidance on how to fix this problem would be greatly appreciated.\n    ", "Answer": "\r\nYou only have two elements in your array. Arrays start at 0. When mem[i] is referenced it is trying to invoke the element in the array at index i. Since i = 2 in this case it will take throw an exception.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "dynamic programming - print all subsets with the given sum\r\n                \r\nI am practicing some dynamic programming problem and was trying to solve the problem to print all subsets with the given sum. For e.g. : For the ```\nset :{1,2,3,4,5}```\n and ```\nsum value = 10```\n , I should get the below results:\n\n```\n[1, 2, 3, 4]\n[1, 4, 5]\n[2, 3, 5]\n```\n\n\nI am getting the required result without using ```\ntable```\n, which I used to prevent repetitive calls for same ```\ni```\n and ```\nsum```\n. But I am not getting ```\n[2, 3, 5]```\n in the output when using ```\ntable```\n.\n\n```\n    private static void printSubsetsWithSum(int i, int arr[], int sum, List<Integer> list, int j, boolean[][] table, Map<String,Integer> map) {\n        if(sum == 0) {\n            System.out.println(list);\n        } else if(sum < 0 || i >= arr.length) {\n            return;\n        } else if(table[i][sum]) {\n            return ;\n        } else if(arr[i] > sum) {\n            printSubsetsWithSum(i+1, arr, sum, list, j, table, map);\n            table[i][sum] = true;\n            map.put( sum + \"_\" + i + \"_\" + arr[i], map.getOrDefault(sum + \"_\" + i + \"_\" + arr[i], 0) + 1);\n        } else {\n            list.add(arr[i]);\n            printSubsetsWithSum(i+1, arr, sum-arr[i], list, j+1, table, map);\n            list.remove(j);\n            printSubsetsWithSum(i+1, arr, sum, list, j, table, map);\n            map.put( sum + \"_\" + i + \"_\" + arr[i], map.getOrDefault(sum + \"_\" + i + \"_\" + arr[i], 0) + 1);\n            table[i][sum] = true;\n        }\n    }\n\n    public static void printSubsetsWithSum(int sum, int[] arr) {\n        boolean table[][] = new boolean[arr.length][sum+1];\n        Map<String,Integer> map = new LinkedHashMap<String,Integer>();\n        printSubsetsWithSum(0, arr, sum, new ArrayList<>(), 0, table, map);\n        System.out.println(map);\n    }\n\n    public static void main(String[] args) {\n        printSubsetsWithSum(10, new int[] {1,2,3,4,5});\n    }\n```\n\n\nPlease help ! ! !\n    ", "Answer": "\r\n```\nprivate static void printSubsetsWithSum(int i, int arr[], int sum, List<Integer> list, int j, boolean[][] table, Map<String,Integer> map) {\n    if(sum == 0) {\n        System.out.println(list);\n    } else if(sum < 0 || i >= arr.length) {\n        return;\n    } else if(table[i][sum]) {\n        return ;\n    } else if(arr[i] > sum) {\n        printSubsetsWithSum(i+1, arr, sum, list, j, table, map);\n        table[i][sum] = true;\n        map.put( sum + \"_\" + i + \"_\" + arr[i], map.getOrDefault(sum + \"_\" + i + \"_\" + arr[i], 0) + 1);\n    } else {\n        list.add(arr[i]);\n        printSubsetsWithSum(i+1, arr, sum-arr[i], list, j+1, table, map);\n        list.remove(j);\n        printSubsetsWithSum(i+1, arr, sum, list, j, table, map);\n        map.put( sum + \"_\" + i + \"_\" + arr[i], map.getOrDefault(sum + \"_\" + i + \"_\" + arr[i], 0) + 1);\n        table[i][sum] = true;// <<---- remove this line it works\n    }\n}\n```\n\n\nThat line marks table[4][5] as true, i=4, list=[2, 3] sum=5 will match table[i][sum] == true\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "How to optimize dynamic programming?\r\n                \r\n\n  Problem A number is called lucky if the sum of its digits, as well as the sum of the squares of its digits is a prime number. How many\n  numbers between A and B are lucky?\n  \n  Input:   The first line contains the number of test cases T. Each of the next T lines contains two integers, A and B.\n  \n  Output:   Output T lines, one for each case containing the required answer for the corresponding case.\n  \n  Constraints:\n    1 <= T <= 10000\n    1 <= A <= B <= 10^18  \n  \n  Sample Input:\n  \n  2\n  \n  1 20\n  \n  120 130  \n  \n  Sample Output:\n  \n  4\n  \n  1  \n  \n  Explanation:   For the first case, the lucky numbers are 11, 12, 14, 16.   For the second case, the only lucky number is 120.\n\n\nThe problem is quite simple if we use brute force, however the running time is so critical that my program failed most test cases. My current idea is to use dynamic programming by storing the previous sum in a temporary array, so for example:\n```\nsum_digits(10) = 1 -> sum_digits(11) = sum_digits(10) + 1```\n\nThe same idea is applied for sum square but with counter equals to odd numbers. Unfortunately, it still failed 9 of 10 test cases which makes me think there must be a better way to solve it. Any idea would be greatly appreciated.\n\n```\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <unordered_map>\n#include <unordered_set>\n#include <cmath>\n#include <cassert>\n#include <bitset>\n\nusing namespace std;\n\nbool prime_table[1540] = {\n    0, 0, 1, 1, 0, 1, 0, 1, 0, \n    0, 0, 1, 0, 1, 0, 0, 0, 1, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 1, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 1, 0, 1, 0, 0, 0, 1, 0, \n    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 1, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 1, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 1, 0, 1, 0, 0, 0, 1, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 1, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 1, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 0, 0, 1, 0, 0, 0, 1, 0, \n    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 1, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 1, 0, 0, 0, 1, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 1, 0, 0, 0, 1, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 1, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 1, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 1, 0, 1, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 1, 0, 1, 0, 0, 0, 1, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 1, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 1, 0, 1, 0, 0, 0, 1, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 1, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 1, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 1, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 0, 0, 1, 0, 0, 0, 1, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 1, 0, 0, 0, 1, 0, \n    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 1, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 1, 0, 0, 0, 1, 0, \n    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 1, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 1, 0, 0, 0, 1, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 1, 0, 0, 0, 1, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 1, 0, 1, 0, 0, 0, 1, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 1, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 1, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 1, 0, 1, 0, 0, 0, 1, 0, \n    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 1, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 1, 0, 0, 0, 1, 0, \n    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 1, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 1, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 1, 0, 1, 0, 0, 0, 1, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 1, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 1, 0, 0, 0, 1, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 1, 0, \n    0, 0, 1, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 1, 0, 0, 0, 1, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, \n    0 \n};\n\nunsigned num_digits(long long i) {\n    return i > 0 ? (long) log10 ((double) i) + 1 : 1;\n}\n\nvoid get_sum_and_sum_square_digits(long long n, int& sum, int& sum_square) {\n    sum = 0;\n    sum_square = 0;\n    int digit;\n    while (n) {\n        digit = n % 10;\n        sum += digit;\n        sum_square += digit * digit;\n        n /= 10;\n    }\n}\n\nvoid init_digits(long long n, long long previous_sum[], const int size = 18) {\n    int current_no_digits = num_digits(n);\n    int digit;\n    for (int i = 0; i < current_no_digits; ++i) {\n        digit = n % 10;\n        previous_sum[i] = digit;\n        n /= 10;\n    }   \n\n    for (int i = current_no_digits; i <= size; ++i) {\n        previous_sum[i] = 0;\n    }   \n}\n\nvoid display_previous(long long previous[]) {\n    for (int i = 0; i < 18; ++i) {\n        cout << previous[i] << \",\";\n    }\n}\n\nint count_lucky_number(long long A, long long B) {\n    long long n = A;\n    long long end = B;\n    int sum = 0;\n    int sum_square = 0;\n    int lucky_counter = 0;\n\n    get_sum_and_sum_square_digits(n, sum, sum_square);\n\n    long long sum_counter = sum;\n    long long sum_square_counter = sum_square;\n\n    if (prime_table[sum_counter] && prime_table[sum_square_counter]) {\n        lucky_counter++;\n    }\n\n    long long previous_sum[19] = {1};\n\n    init_digits(n, previous_sum);\n\n    while (n < end) {\n        n++;\n        if (n % 100000000000000000 == 0) {\n            previous_sum[17]++;\n            sum_counter = previous_sum[17] + previous_sum[18];\n            sum_square_counter = previous_sum[17] * previous_sum[17] + previous_sum[18] * previous_sum[18];\n\n            previous_sum[16] = 0;\n            previous_sum[15] = 0;\n            previous_sum[14] = 0;\n            previous_sum[13] = 0;\n            previous_sum[12] = 0;\n            previous_sum[11] = 0;\n            previous_sum[10] = 0;\n            previous_sum[9] = 0;\n            previous_sum[8] = 0;\n            previous_sum[7] = 0;\n            previous_sum[6] = 0;\n            previous_sum[5] = 0;\n            previous_sum[4] = 0;\n            previous_sum[3] = 0;\n            previous_sum[2] = 0;\n            previous_sum[1] = 0;\n            previous_sum[0] = 0;\n        }\n        else if (n % 10000000000000000 == 0) {\n            previous_sum[16]++;\n            sum_counter = previous_sum[16] + previous_sum[17] + previous_sum[18];\n\n            sum_square_counter = \n                previous_sum[16] * previous_sum[16] +\n                previous_sum[17] * previous_sum[17] +\n                previous_sum[18] * previous_sum[18];\n\n            previous_sum[15] = 0;\n            previous_sum[14] = 0;\n            previous_sum[13] = 0;\n            previous_sum[12] = 0;\n            previous_sum[11] = 0;\n            previous_sum[10] = 0;\n            previous_sum[9] = 0;\n            previous_sum[8] = 0;\n            previous_sum[7] = 0;\n            previous_sum[6] = 0;\n            previous_sum[5] = 0;\n            previous_sum[4] = 0;\n            previous_sum[3] = 0;\n            previous_sum[2] = 0;\n            previous_sum[1] = 0;\n            previous_sum[0] = 0;\n        }\n        else if (n % 1000000000000000 == 0) {\n            previous_sum[15]++;\n\n            sum_counter = previous_sum[15] + previous_sum[16] + previous_sum[17] + previous_sum[18];\n\n            sum_square_counter = \n                previous_sum[15] * previous_sum[15] +\n                previous_sum[16] * previous_sum[16] +\n                previous_sum[17] * previous_sum[17] +\n                previous_sum[18] * previous_sum[18];\n\n            previous_sum[14] = 0;\n            previous_sum[13] = 0;\n            previous_sum[12] = 0;\n            previous_sum[11] = 0;\n            previous_sum[10] = 0;\n            previous_sum[9] = 0;\n            previous_sum[8] = 0;\n            previous_sum[7] = 0;\n            previous_sum[6] = 0;\n            previous_sum[5] = 0;\n            previous_sum[4] = 0;\n            previous_sum[3] = 0;\n            previous_sum[2] = 0;\n            previous_sum[1] = 0;\n            previous_sum[0] = 0;\n        }\n        else if (n % 100000000000000 == 0) {\n            previous_sum[14]++;\n\n            sum_counter = previous_sum[14] + previous_sum[15] + previous_sum[16] + previous_sum[17] + previous_sum[18];\n\n            sum_square_counter = \n                previous_sum[14] * previous_sum[14] +\n                previous_sum[15] * previous_sum[15] +\n                previous_sum[16] * previous_sum[16] +\n                previous_sum[17] * previous_sum[17] +\n                previous_sum[18] * previous_sum[18];\n\n            previous_sum[13] = 0;\n            previous_sum[12] = 0;\n            previous_sum[11] = 0;\n            previous_sum[10] = 0;\n            previous_sum[9] = 0;\n            previous_sum[8] = 0;\n            previous_sum[7] = 0;\n            previous_sum[6] = 0;\n            previous_sum[5] = 0;\n            previous_sum[4] = 0;\n            previous_sum[3] = 0;\n            previous_sum[2] = 0;\n            previous_sum[1] = 0;\n            previous_sum[0] = 0;\n        }\n        else if (n % 10000000000000 == 0) {\n            previous_sum[13]++;\n\n            sum_counter = previous_sum[13] + previous_sum[14] + previous_sum[15] + previous_sum[16] + previous_sum[17] + previous_sum[18];\n\n            sum_square_counter = \n                previous_sum[13] * previous_sum[13] +\n                previous_sum[14] * previous_sum[14] +\n                previous_sum[15] * previous_sum[15] +\n                previous_sum[16] * previous_sum[16] +\n                previous_sum[17] * previous_sum[17] +\n                previous_sum[18] * previous_sum[18];\n\n            previous_sum[12] = 0;\n            previous_sum[11] = 0;\n            previous_sum[10] = 0;\n            previous_sum[9] = 0;\n            previous_sum[8] = 0;\n            previous_sum[7] = 0;\n            previous_sum[6] = 0;\n            previous_sum[5] = 0;\n            previous_sum[4] = 0;\n            previous_sum[3] = 0;\n            previous_sum[2] = 0;\n            previous_sum[1] = 0;\n            previous_sum[0] = 0;\n        }\n        else if (n % 1000000000000 == 0) {\n            previous_sum[12]++;\n\n            sum_counter = previous_sum[12] + previous_sum[13] + previous_sum[14] + previous_sum[15] + previous_sum[16] + previous_sum[17] + previous_sum[18];\n\n            sum_square_counter = \n                previous_sum[12] * previous_sum[12] +\n                previous_sum[13] * previous_sum[13] +\n                previous_sum[14] * previous_sum[14] +\n                previous_sum[15] * previous_sum[15] +\n                previous_sum[16] * previous_sum[16] +\n                previous_sum[17] * previous_sum[17] +\n                previous_sum[18] * previous_sum[18];\n\n            previous_sum[11] = 0;\n            previous_sum[10] = 0;\n            previous_sum[9] = 0;\n            previous_sum[8] = 0;\n            previous_sum[7] = 0;\n            previous_sum[6] = 0;\n            previous_sum[5] = 0;\n            previous_sum[4] = 0;\n            previous_sum[3] = 0;\n            previous_sum[2] = 0;\n            previous_sum[1] = 0;\n            previous_sum[0] = 0;\n        }\n        else if (n % 100000000000 == 0) {\n            previous_sum[11]++;\n\n            sum_counter = \n                previous_sum[11] + previous_sum[12] + previous_sum[13] + previous_sum[14] + previous_sum[15] + previous_sum[16] + previous_sum[17] + previous_sum[18];\n\n            sum_square_counter = \n                previous_sum[11] * previous_sum[11] +\n                previous_sum[12] * previous_sum[12] +\n                previous_sum[13] * previous_sum[13] +\n                previous_sum[14] * previous_sum[14] +\n                previous_sum[15] * previous_sum[15] +\n                previous_sum[16] * previous_sum[16] +\n                previous_sum[17] * previous_sum[17] +\n                previous_sum[18] * previous_sum[18];\n\n            previous_sum[10] = 0;\n            previous_sum[9] = 0;\n            previous_sum[8] = 0;\n            previous_sum[7] = 0;\n            previous_sum[6] = 0;\n            previous_sum[5] = 0;\n            previous_sum[4] = 0;\n            previous_sum[3] = 0;\n            previous_sum[2] = 0;\n            previous_sum[1] = 0;\n            previous_sum[0] = 0;\n        }\n        else if (n % 10000000000 == 0) {\n            previous_sum[10]++;\n\n            sum_counter = \n                previous_sum[10] +\n                previous_sum[11] + previous_sum[12] + previous_sum[13] + previous_sum[14] + previous_sum[15] +\n                previous_sum[16] + previous_sum[17] + previous_sum[18];\n\n            sum_square_counter = \n                previous_sum[10] * previous_sum[10] +\n                previous_sum[11] * previous_sum[11] +\n                previous_sum[12] * previous_sum[12] +\n                previous_sum[13] * previous_sum[13] +\n                previous_sum[14] * previous_sum[14] +\n                previous_sum[15] * previous_sum[15] +\n                previous_sum[16] * previous_sum[16] +\n                previous_sum[17] * previous_sum[17] +\n                previous_sum[18] * previous_sum[18];\n\n            previous_sum[9] = 0;\n            previous_sum[8] = 0;\n            previous_sum[7] = 0;\n            previous_sum[6] = 0;\n            previous_sum[5] = 0;\n            previous_sum[4] = 0;\n            previous_sum[3] = 0;\n            previous_sum[2] = 0;\n            previous_sum[1] = 0;\n            previous_sum[0] = 0;\n        }\n        else if (n % 1000000000 == 0) {\n            previous_sum[9]++;\n\n            sum_counter = \n                previous_sum[9] + previous_sum[10] +\n                previous_sum[11] + previous_sum[12] + previous_sum[13] + previous_sum[14] + previous_sum[15] +\n                previous_sum[16] + previous_sum[17] + previous_sum[18];\n\n            sum_square_counter = \n                previous_sum[9] * previous_sum[9] +\n                previous_sum[10] * previous_sum[10] +\n                previous_sum[11] * previous_sum[11] +\n                previous_sum[12] * previous_sum[12] +\n                previous_sum[13] * previous_sum[13] +\n                previous_sum[14] * previous_sum[14] +\n                previous_sum[15] * previous_sum[15] +\n                previous_sum[16] * previous_sum[16] +\n                previous_sum[17] * previous_sum[17] +\n                previous_sum[18] * previous_sum[18];\n\n\n            previous_sum[8] = 0;\n            previous_sum[7] = 0;\n            previous_sum[6] = 0;\n            previous_sum[5] = 0;\n            previous_sum[4] = 0;\n            previous_sum[3] = 0;\n            previous_sum[2] = 0;\n            previous_sum[1] = 0;\n            previous_sum[0] = 0;\n        }\n        else if (n % 100000000 == 0) {\n            previous_sum[8]++;\n\n            sum_counter = \n                previous_sum[8] + previous_sum[9] + previous_sum[10] +\n                previous_sum[11] + previous_sum[12] + previous_sum[13] + previous_sum[14] + previous_sum[15] +\n                previous_sum[16] + previous_sum[17] + previous_sum[18];\n\n            sum_square_counter = \n                previous_sum[8] * previous_sum[8] +\n                previous_sum[9] * previous_sum[9] +\n                previous_sum[10] * previous_sum[10] +\n                previous_sum[11] * previous_sum[11] +\n                previous_sum[12] * previous_sum[12] +\n                previous_sum[13] * previous_sum[13] +\n                previous_sum[14] * previous_sum[14] +\n                previous_sum[15] * previous_sum[15] +\n                previous_sum[16] * previous_sum[16] +\n                previous_sum[17] * previous_sum[17] +\n                previous_sum[18] * previous_sum[18];\n\n            previous_sum[7] = 0;\n            previous_sum[6] = 0;\n            previous_sum[5] = 0;\n            previous_sum[4] = 0;\n            previous_sum[3] = 0;\n            previous_sum[2] = 0;\n            previous_sum[1] = 0;\n            previous_sum[0] = 0;\n        }\n        else if (n % 10000000 == 0) {\n            previous_sum[7]++;\n\n            sum_counter = \n                previous_sum[7] + previous_sum[8] + previous_sum[9] + previous_sum[10] +\n                previous_sum[11] + previous_sum[12] + previous_sum[13] + previous_sum[14] + previous_sum[15] +\n                previous_sum[16] + previous_sum[17] + previous_sum[18];\n\n            sum_square_counter = \n                previous_sum[7] * previous_sum[7] +\n                previous_sum[8] * previous_sum[8] +\n                previous_sum[9] * previous_sum[9] +\n                previous_sum[10] * previous_sum[10] +\n                previous_sum[11] * previous_sum[11] +\n                previous_sum[12] * previous_sum[12] +\n                previous_sum[13] * previous_sum[13] +\n                previous_sum[14] * previous_sum[14] +\n                previous_sum[15] * previous_sum[15] +\n                previous_sum[16] * previous_sum[16] +\n                previous_sum[17] * previous_sum[17] +\n                previous_sum[18] * previous_sum[18];\n\n            previous_sum[6] = 0;\n            previous_sum[5] = 0;\n            previous_sum[4] = 0;\n            previous_sum[3] = 0;\n            previous_sum[2] = 0;\n            previous_sum[1] = 0;\n            previous_sum[0] = 0;\n        }\n        else if (n % 1000000 == 0) {\n            previous_sum[6]++;\n\n            sum_counter = \n                previous_sum[6] + previous_sum[7] + previous_sum[8] + previous_sum[9] + previous_sum[10] +\n                previous_sum[11] + previous_sum[12] + previous_sum[13] + previous_sum[14] + previous_sum[15] +\n                previous_sum[16] + previous_sum[17] + previous_sum[18];\n\n            sum_square_counter = \n                previous_sum[6] * previous_sum[6] +\n                previous_sum[7] * previous_sum[7] +\n                previous_sum[8] * previous_sum[8] +\n                previous_sum[9] * previous_sum[9] +\n                previous_sum[10] * previous_sum[10] +\n                previous_sum[11] * previous_sum[11] +\n                previous_sum[12] * previous_sum[12] +\n                previous_sum[13] * previous_sum[13] +\n                previous_sum[14] * previous_sum[14] +\n                previous_sum[15] * previous_sum[15] +\n                previous_sum[16] * previous_sum[16] +\n                previous_sum[17] * previous_sum[17] +\n                previous_sum[18] * previous_sum[18];\n\n            previous_sum[5] = 0;\n            previous_sum[4] = 0;\n            previous_sum[3] = 0;\n            previous_sum[2] = 0;\n            previous_sum[1] = 0;\n            previous_sum[0] = 0;\n        }\n        else if (n % 100000 == 0) {\n            previous_sum[5]++;\n\n            sum_counter = previous_sum[5] + previous_sum[6] + previous_sum[7] + previous_sum[8] + previous_sum[9] + previous_sum[10] + previous_sum[11] + previous_sum[12] + previous_sum[13] + previous_sum[14] + previous_sum[15] + previous_sum[16] + previous_sum[17] + previous_sum[18];\n\n            sum_square_counter = \n                previous_sum[5] * previous_sum[5] +\n                previous_sum[6] * previous_sum[6] +\n                previous_sum[7] * previous_sum[7] +\n                previous_sum[8] * previous_sum[8] +\n                previous_sum[9] * previous_sum[9] +\n                previous_sum[10] * previous_sum[10] +\n                previous_sum[11] * previous_sum[11] +\n                previous_sum[12] * previous_sum[12] +\n                previous_sum[13] * previous_sum[13] +\n                previous_sum[14] * previous_sum[14] +\n                previous_sum[15] * previous_sum[15] +\n                previous_sum[16] * previous_sum[16] +\n                previous_sum[17] * previous_sum[17] +\n                previous_sum[18] * previous_sum[18];\n\n            previous_sum[4] = 0;\n            previous_sum[3] = 0;\n            previous_sum[2] = 0;\n            previous_sum[1] = 0;\n            previous_sum[0] = 0;\n        }\n        else if (n % 10000 == 0) {\n            previous_sum[4]++;\n\n            sum_counter = \n                previous_sum[4] + previous_sum[5] + \n                previous_sum[6] + previous_sum[7] + previous_sum[8] + previous_sum[9] + previous_sum[10] +\n                previous_sum[11] + previous_sum[12] + previous_sum[13] + previous_sum[14] + previous_sum[15] +\n                previous_sum[16] + previous_sum[17] + previous_sum[18];\n\n            sum_square_counter = \n                previous_sum[4] * previous_sum[4] +\n                previous_sum[5] * previous_sum[5] +\n                previous_sum[6] * previous_sum[6] +\n                previous_sum[7] * previous_sum[7] +\n                previous_sum[8] * previous_sum[8] +\n                previous_sum[9] * previous_sum[9] +\n                previous_sum[12] * previous_sum[12] +\n                previous_sum[13] * previous_sum[13] +\n                previous_sum[14] * previous_sum[14] +\n                previous_sum[15] * previous_sum[15] +\n                previous_sum[16] * previous_sum[16] +\n                previous_sum[17] * previous_sum[17] +\n                previous_sum[18] * previous_sum[18];\n\n            previous_sum[3] = 0;\n            previous_sum[2] = 0;\n            previous_sum[1] = 0;\n            previous_sum[0] = 0;\n        }\n        else if (n % 1000 == 0) {\n            previous_sum[3]++;\n\n            sum_counter = \n                previous_sum[3] + previous_sum[4] + previous_sum[5] + \n                previous_sum[6] + previous_sum[7] + previous_sum[8] + previous_sum[9] + previous_sum[10] +\n                previous_sum[11] + previous_sum[12] + previous_sum[13] + previous_sum[14] + previous_sum[15] +\n                previous_sum[16] + previous_sum[17] + previous_sum[18];\n\n            sum_square_counter = \n                previous_sum[3] * previous_sum[3] +\n                previous_sum[4] * previous_sum[4] +\n                previous_sum[5] * previous_sum[5] +\n                previous_sum[6] * previous_sum[6] +\n                previous_sum[7] * previous_sum[7] +\n                previous_sum[8] * previous_sum[8] +\n                previous_sum[9] * previous_sum[9] +\n                previous_sum[10] * previous_sum[10] +\n                previous_sum[11] * previous_sum[11] +\n                previous_sum[12] * previous_sum[12] +\n                previous_sum[13] * previous_sum[13] +\n                previous_sum[14] * previous_sum[14] +\n                previous_sum[15] * previous_sum[15] +\n                previous_sum[16] * previous_sum[16] +\n                previous_sum[17] * previous_sum[17] +\n                previous_sum[18] * previous_sum[18];\n\n            previous_sum[2] = 0;\n            previous_sum[1] = 0;\n            previous_sum[0] = 0;\n        }\n        else if (n % 100 == 0) {\n            previous_sum[2]++;\n\n            sum_counter = \n                previous_sum[2] + previous_sum[3] + previous_sum[4] + previous_sum[5] + \n                previous_sum[6] + previous_sum[7] + previous_sum[8] + previous_sum[9] + previous_sum[10] +\n                previous_sum[11] + previous_sum[12] + previous_sum[13] + previous_sum[14] + previous_sum[15] +\n                previous_sum[16] + previous_sum[17] + previous_sum[18];\n\n            sum_square_counter = \n                previous_sum[2] * previous_sum[2] +\n                previous_sum[3] * previous_sum[3] +\n                previous_sum[4] * previous_sum[4] +\n                previous_sum[5] * previous_sum[5] +\n                previous_sum[6] * previous_sum[6] +\n                previous_sum[7] * previous_sum[7] +\n                previous_sum[8] * previous_sum[8] +\n                previous_sum[9] * previous_sum[9] +\n                previous_sum[10] * previous_sum[10] +\n                previous_sum[11] * previous_sum[11] +\n                previous_sum[12] * previous_sum[12] +\n                previous_sum[13] * previous_sum[13] +\n                previous_sum[14] * previous_sum[14] +\n                previous_sum[15] * previous_sum[15] +\n                previous_sum[16] * previous_sum[16] +\n                previous_sum[17] * previous_sum[17] +\n                previous_sum[18] * previous_sum[18];\n\n            previous_sum[1] = 0;\n            previous_sum[0] = 0;\n        }\n        else if (n % 10 == 0) {\n            previous_sum[1]++;\n\n            sum_counter = \n                previous_sum[1] + previous_sum[2] + previous_sum[3] + previous_sum[4] + previous_sum[5] + \n                previous_sum[6] + previous_sum[7] + previous_sum[8] + previous_sum[9] + previous_sum[10] +\n                previous_sum[11] + previous_sum[12] + previous_sum[13] + previous_sum[14] + previous_sum[15] +\n                previous_sum[16] + previous_sum[17] + previous_sum[18];\n\n            sum_square_counter = \n                previous_sum[1] * previous_sum[1] + \n                previous_sum[2] * previous_sum[2] +\n                previous_sum[3] * previous_sum[3] +\n                previous_sum[4] * previous_sum[4] +\n                previous_sum[5] * previous_sum[5] +\n                previous_sum[6] * previous_sum[6] +\n                previous_sum[7] * previous_sum[7] +\n                previous_sum[8] * previous_sum[8] +\n                previous_sum[9] * previous_sum[9] +\n                previous_sum[10] * previous_sum[10] +\n                previous_sum[11] * previous_sum[11] +\n                previous_sum[12] * previous_sum[12] +\n                previous_sum[13] * previous_sum[13] +\n                previous_sum[14] * previous_sum[14] +\n                previous_sum[15] * previous_sum[15] +\n                previous_sum[16] * previous_sum[16] +\n                previous_sum[17] * previous_sum[17] +\n                previous_sum[18] * previous_sum[18];\n\n            previous_sum[0] = 0;\n        }\n        else {\n            sum_counter++;\n            sum_square_counter += ((n - 1) % 10) * 2 + 1;\n        }\n\n        // get_sum_and_sum_square_digits(n, sum, sum_square);\n        // assert(sum == sum_counter && sum_square == sum_square_counter);\n        if (prime_table[sum_counter] && prime_table[sum_square_counter]) {\n            lucky_counter++;\n        }\n    }\n\n    return lucky_counter;\n}\n\n\nvoid inout_lucky_numbers() {\n    int n;\n    cin >> n;\n\n    long long a;\n    long long b;\n\n    while (n--) {\n        cin >> a >> b;\n        cout << count_lucky_number(a, b) << endl;\n    }\n}\n\nint main() {\n    inout_lucky_numbers();\n\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nSeeing as A-B may be a range of 10^18 values, there's no way you can loop from A to B in time, no matter how optimized it gets. Let's try to figure out a way to do it that doesn't involve specifically considering all of those numbers...\n\nFirst, let's reduce the problem to finding the lucky numbers between 1 and E, and call this lucky(E). The answer to the overall problem is simply lucky(B)-lucky(A-1).\n\nNow let's construct such a lucky number digit by digit. Suppose we have already placed a few digits on this number and need to continue. Does it matter which digits we have already placed? No! We only need to know the following:\n\n\nHow many digits have been placed (n)\nThe current sum of digits (s)\nThe current sum of squares of digits (sq)\n\n\nThis will be what is called in dynamic programming as our state.\n\nLet's disregard 10^18, as it's the only number in the input with 19 digits and it's not lucky. Note that E may have up to 18 digits, so we have 19 possibilities for n (from 0 to 18), 162 (18 * 9 + 1) possibilities for s, and 1459 (18 * 81 + 1) possibilities for sq. This leaves us with a search space of at most 5 million, which is incredibly smaller than searching 10^18 numbers for matches.\n\nSo let's define F(n, s, sq) as \"in how many ways we can add digits to a number that has such properties to get a lucky number\" (thanks to kilotaras for the rewording). The base case is when n equals the number of digits in E: F(N, s, s_sq) is 1 if s and sq are prime, 0 otherwise. For the other possibilities, do the possible transitions and call F recursively, taking care not to let the number you're constructing go over E. \n\nIn this manner, we can define lucky(E) as F(0, 0, 0).\n\nWhen you're done, remember to memoize the function for the already calculated inputs/outputs.\n\nEdit: This is a bit old, but here is a sample implementation of the lucky function, which I believe is correct. Note that n goes down in the code as opposed to the explanation above, as it's a lot easier to code it this way.\n\n```\nlong long dp[20][163][1460];\nbool calc[20][163][1460];\n\nint digits[20];\nint digit_cnt;\n\n// The last argument (eq) is used to avoid going over E\nlong long F(int n, int s, int sq, bool eq) {\n    // Base cases\n    if (!eq && calc[n][s][sq]) return dp[n][s][sq];\n    if (n == 0) return (prime_table[s] && prime_table[sq]);\n\n    long long resp = 0;\n\n    // Test all possibilities for the next digit\n    for (int d = 0; d < 10; d++) {\n        if (!eq || digits[n-1] > d) {\n            resp += F(n-1, s+d, sq + d*d, false);\n        }\n\n        // If the number formed so far is exactly equal to E\n        // we will go over E if we pick a larger\n        // digit than digits[n-1]. \n        // So we have to take care if eq == true\n        else if (digits[n-1] == d) {\n            resp += F(n-1, s+d, sq + d*d, true);\n        }\n        else break;\n    }\n\n    // Note that computations that have eq set to true\n    // can't be used in other calculations of F(), as they depend on E.\n    if (!eq) {\n        calc[n][s][sq] = true;\n        dp[n][s][sq] = resp;\n    }\n\n    return resp;\n}\n\nlong long lucky(long long E) {\n    long long tE = E;\n    digit_cnt = 0;\n\n    while (tE) {\n        digits[digit_cnt++] = tE % 10;\n        tE /= 10;\n    }\n\n    return F(digit_cnt, 0, 0, true);\n}\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "what is dynamic programming approach for this version of minimum edit distance?\r\n                \r\nThere is a dynamic programming approach for minimum edit distance, you can check it:here\n\nin it we are allowed to insert,delete or change a character to covert s1 to s2.But in this problem we are allowed to insert,delete or DISPLACE any character of s1 to convert it to s2.Each of these operations have W1,W2,W3 cost respectively.For example to convert \"more\" to \"remo\" only we need to displacement of \"r<->m\" and \"o<->e\" so cost is 2*w3\nwe want a dynamic programming approach to find the minimum cost of converting s1 to s2 with these three operations.\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Minimum Coin Change Leetcode problem (Dynamic Programming)\r\n                \r\nHere's the question: https://leetcode.com/problems/coin-change/\nI'm having some trouble understanding two different methods of dynamic programming used to solve this problem. I'm currently going through the Grokking Dynamic Programming course from educative.io, and their approach is to use subsets to search for each combination. They go about testing if a coin is viable, if so, then try it in the DFS. If not, skip the coin and go to the next index and try the next coin.\nHere's Grokking's approach with memoization:\n```\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        def dfs(i, total, memo):\n            key = (i, total)\n            if key in memo:\n                return memo[key]\n            if total == 0:\n                return 0\n            if len(coins) == 0 or i >= len(coins):\n                return inf\n            \n            count = inf\n            if coins[i] <= total:\n                res = dfs(i, total - coins[i], memo)\n                if res != inf:\n                    count = res + 1\n                    \n            memo[key] = min(count, dfs(i + 1, total, memo))\n            return memo[key]\n        return dfs(0, amount, {}) if dfs(0, amount, {}) != inf else -1\n```\n\nIt doesn't do very well on Leetcode; it runs very slowly (but passes, nonetheless). The efficient algorithm that was in the discussions was this:\n```\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        @lru_cache(None)\n        def dp(sum):\n            if sum == 0: return 0\n            if sum < 0: return float(\"inf\")\n\n            count = float('inf')\n            for coin in coins:\n                count = min(count, dp(sum - coin))\n\n            return count + 1\n        return dp(amount) if dp(amount) != float(\"inf\") else -1\n```\n\nDoes this second code have the same logic as \"testing the subsets of coins?\" What's the difference between the two? Is the for-loop a way of testing the different subsets, like with backtracking?\nI tested the second algorithm with memoization in a dictionary, like the first, using ```\nsum```\n as the key, and it tanked in efficiency. But then I tried using the @lru_cache with the first algorithm, and it didn't help.\nCould anyone explain why the second algorithm is so much faster? Is it my memoization that sucks?\n    ", "Answer": "\r\n\nDoes this second code have the same logic as \"testing the subsets of coins?\"\n\nIf with subset you mean the subset of the coins that is still available for selection, then: no. The second algorithm does not reduce the problem in terms of coins; it reasons that at any time any coin can be selected, irrespective of previous selections. Although this may seem inefficient as it tries to take the same combinations in all possible permutations, this downside is minimised by the effect of memoization.\n\nWhat's the difference between the two?\n\n\nThe first one takes coins in the order they are given, never going back to take an earlier coin once it has decided to go to the next one. So doing, it tries to reduce the problem in terms of available coins. The second one doesn't care about the order and looks at any permutation, it only reduces the problem in terms of amount.\nThis first one has a larger memoization collection because the index is part of the key, whereas the second uses a memoization collection that is only keyed by the amount.\nThe first one makes a recursive call even when no coin is selected (the one at the end of the inner function), since that fits in the logic of reducing the problem to fewer coins. The second one only makes a recursive call when the amount is further reduced.\n\n\nIs the for-loop a way of testing the different subsets, like with backtracking?\n\nIf with subset you mean that the problem is reduced to fewer coins, then no: the second algorithm doesn't attempt to apply that methodology.\nThe ```\nfor```\n loop is just a way to consider every coin. It doesn't reduce the problem size in terms of available coins, only in terms of remaining amount.\n\nCould anyone explain why the second algorithm is so much faster?\n\nIt is faster because the memoization key is smaller, leading to more hits, leading to fewer recursive calls. You can experiment with this and add global counters that count the number of executions of both inner functions (```\ndfs```\n and ```\ndp```\n) and you'll see a dramatic difference there.\n\nIs it my memoization that sucks?\n\nYou could say that, but it is too harsh.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Shortest hamiltonian path with dynamic programming and bitmasking\r\n                \r\nI've just read an article about how to find the shortest hamiltonian path using dynamic programming here http://codeforces.com/blog/entry/337.\n\nWhile the pseudocode works, I do not understand why I have to take to use the xor operator on the set and 2^i.\n\nWhy wouldn't you just substract the current visisted city from the bitmask? What does the xor with the set in order to make the algorithm do it's magic?\n\nTo clarify here is the piece of pseudocode written in java:\n\n```\npublic int calculate(int set, int i){\n\n        if(count(set) == 1 && (set & 1<<i) != 0){\n            return 0;\n        }\n\n        if ( dp[set][i] != infinity){\n            return dp[set][i];\n        }\n\n        for (int city=0;city<n;city++){\n            if((set & 1<<city) == 0) continue;\n            dp[set][i] = Math.min(dp[set][i], calculate(set ^ 1<<i, city) + dist[i][city]);\n        }\n        return dp[set][i];\n    }\n```\n\n    ", "Answer": "\r\nFound the solution to my problem, the ^ is a bitflip. Thus if you have a bitmask and use the xor operator on the mask, you flip the bit on that place. E.g. 1010 ^ (1<<1) results in 1000.\nSame goes for 1000 ^ (1<<1) = 1010. \n\nThe substraction also works, but with the xor operator you know for certain that you only touch the bit at that place, and none else. Image 1000 - (1<1), thus would result in something entirely different. Thus substraction works and can be used if you are 100% sure that at an 1 is at place i, but xor is safer.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "How does table in Dynamic Programming works?\r\n                \r\nI have been studying dynamic programming now a days and i came across a code on a website.\nThe question says  write a function that checks whether C is an interleaving of A and B. C is said to be interleaving A and B, if it contains all characters of A and B and order of all characters in individual strings is preserved.What i don't understand is how values get filled in the 2-D matrix ?\n\nHelp needed :)\nHere is the link \nhttp://www.geeksforgeeks.org/check-whether-a-given-string-is-an-interleaving-of-two-other-given-strings-set-2/\n\n```\n// an interleaving of A and B, otherwise false.\nbool isInterleaved(char* A, char* B, char* C)\n{\n  // Find lengths of the two strings\n  int M = strlen(A), N = strlen(B);\n\n  // Let us create a 2D table to store solutions of\n  // subproblems.  C[i][j] will be true if C[0..i+j-1]\n  // is an interleaving of A[0..i-1] and B[0..j-1].\n  bool IL[M + 1][N + 1];\n\n  memset(IL, 0, sizeof(IL)); // Initialize all values as false.\n\n  // C can be an interleaving of A and B only of sum\n  // of lengths of A & B is equal to length of C.\n  if ((M + N) != strlen(C))\n    return false;\n\n  // Process all characters of A and B\n  for (int i = 0; i <= M; ++i)\n  {\n    for (int j = 0; j <= N; ++j)\n    {\n      // two empty strings have an empty string\n      // as interleaving\n      if (i == 0 && j == 0)\n        IL[i][j] = true;\n\n      // A is empty\n      else if (i == 0 && B[j - 1] == C[j - 1])\n        IL[i][j] = IL[i][j - 1];\n\n      // B is empty\n      else if (j == 0 && A[i - 1] == C[i - 1])\n        IL[i][j] = IL[i - 1][j];\n\n      // Current character of C matches with current character of A,\n      // but doesn't match with current character of B\n      else if (A[i - 1] == C[i + j - 1] && B[j - 1] != C[i + j - 1])\n        IL[i][j] = IL[i - 1][j];\n\n      // Current character of C matches with current character of B,\n      // but doesn't match with current character of A\n      else if (A[i - 1] != C[i + j - 1] && B[j - 1] == C[i + j - 1])\n        IL[i][j] = IL[i][j - 1];\n\n      // Current character of C matches with that of both A and B\n      else if (A[i - 1] == C[i + j - 1] && B[j - 1] == C[i + j - 1])\n        IL[i][j] = (IL[i - 1][j] || IL[i][j - 1]);\n    }\n  }\n\n  return IL[M][N];\n}\n\nvoid test(char *A, char *B, char *C)\n{\n  if (isInterleaved(A, B, C))\n    cout << C << \" is interleaved of \" << A << \" and \" << B << endl;\n  else\n    cout << C << \" is not interleaved of \" << A << \" and \" << B << endl;\n}\n\n// Driver program to test above functions\nint main()\n{\n  test(\"XXY\", \"XXZ\", \"XXZXXXY\");\n}\n```\n\n    ", "Answer": "\r\nDynamic programming re-uses the results of sub-problems to solve the problem. The sub-problems are smaller versions of the problem. A table is often used to store the sub-problem results.\n\nThe indices of the table are application specific; in this case, they are described in the comments:\n\n```\n// Let us create a 2D table to store solutions of\n// subproblems.  IL[i][j] will be true if C[0..i+j-1]\n// is an interleaving of A[0..i-1] and B[0..j-1].\n```\n\n\n(I fixed a mistake, ```\nC[i][j]```\n should be ```\nIL[i][j]```\n in the original source).\n\nThe sub-problems determine whether substrings of ```\nA```\n and ```\nB```\n are interleavings of substrings of C. The indices into the IL array determine the length of the substrings of ```\nA```\n and ```\nB```\n (the length of the third substring is implied from the lengths of the other two).\n\nFor example:\n\n\n```\nIL[0][0]```\n is ```\ntrue```\n, since \"\" (empty string) and \"\" interleave to form \"\".\n```\nIL[0][*]```\n is also ```\ntrue```\n, since \"\" and ```\nWHATEVER```\n interleave to form ```\nWHATEVER```\n (here, ```\n*```\n means \"anything\").\n```\nIL[*][0]```\n is also ```\ntrue```\n, for similar reasons to the above.\n```\nIL[i][j]```\n is calculated by comparing the current character in ```\nC```\n to the current characters in ```\nA```\n and ```\nB```\n (look at the source code to determine what I mean by \"current\")\n\nIf it matches neither, then you know that ```\nC```\n is not an interleaving, since it contains an unexpected character. Therefore, ```\nIL[i][j] = false```\n.\nIf it matches ```\nA```\n, then you also need to check that the previous characters interleave correctly as well. Here's where the dynamic programming part comes in -- you don't need to actually look at all those characters to check them, since you've already done that in previous iterations. The result of the check (which is also the final result you should return) is stored inside the ```\nIL```\n table, more specifically, at ```\nIL[i-1][j]```\n.  Therefore, ```\nIL[i][j] = IL[i-1][j]```\n.\nIf it matches ```\nB```\n, then do the same as above, except look at ```\nIL[i][j-1]```\n.\n\n\n\nIf you have trouble understanding the dynamic programming solution, I recommend that you work manually through the recursive solution on the site. Eventually, you will realize that you're repeating many comparisons. You can avoid this repetition by storing the comparison result the first time you have to make it, and then re-using that result on subsequent occasions.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Longest zig-zag subsequence using dynamic programming\r\n                \r\nI need to write a ```\nmethod that needs to return the length of the longest subsequence of sequence that is a zig-zag sequence.```\n The algorithmic approach should be dynamic programming.\n\n\n\nA sequence of numbers is called a zig-zag sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. \n\n```\nEg - 1,7,4,9,2,5   is a zig-zag sequence\nbecause the differences (6,-3,5,-7,3) are alternately positive and negative. \n\n1,4,7,2,5 is not a zig-zag sequence.\n```\n\n\n\n\nMy Code:\n\n\n\n```\npublic static int longestZigZag(int[] seq){\n\n    int len = seq.length;\n    int[] count= new int[len];\n\n    for(int i=0;i<len;i++)\n        count[i]=1;\n\n    for(int i=1;i<len;i++){\n        int k = (int)Math.pow(-1, i+1);\n\n        if(seq[i]>(k*seq[i-1])){\n            count[i]=count[i-1]+1;\n        }\n    }\n\n    int max=1;\n    for(int i=0;i<len;i++)\n        if(count[i]>max)\n            max=count[i];\n\n    return max;\n}\n```\n\n\n\n\nExplanation:\n\nCorresponding to every element, I have a ```\ncount```\n element that represents the continuous alternate  sequence up to that point.\n\n```\nseq:    1, 7, 4, 9, 2, 5\ncount:  1, 1, 1, 1, 1, 1\n\ni=1 7 > 1    count[1]= count[0]+1 = 2\ni=2 4 > -7   count[2]= count[1]+1 = 3\ni=1 9 > 4    count[3]= count[2]+1 = 4\ni=1 2 > -9   count[4]= count[3]+1 = 5\ni=1 5 > 2    count[5]= count[4]+1 = 6\n```\n\n\nAfter that I am simply printing the max of the count array.\n\n\n\nError:\n\nThe above works correctly for \n\n```\n{ 1, 7, 4, 9, 2, 5 }                     ->  6\n{ 1, 17, 5, 10, 13, 15, 10, 5, 16, 8 }   ->  7\n```\n\n\nHowever, it gives wrong results for \n\n```\n{ 1, 2, 3, 4, 5, 6, 7, 8, 9 } gives 9 but should be 2.\n{ 70, 55, 13, 2, 99, 2, 80, 80, 80, 80, 100, 19, 7, 5, \n  5, 5, 1000, 32, 32 } gives 2 but should be 8.\n```\n\n    ", "Answer": "\r\nI'm not sure how answerable this is . . . your approach is really completely wrong. :-/\n\nTo see this, consider the following: your calculation for each element of ```\ncount```\n depends only on the single previous element of ```\ncount```\n, and your running calculation for ```\nmax```\n depends only on the current element of ```\ncount```\n. That means that you don't even need the ```\ncount```\n array: your whole algorithm could be translated into a single pass requiring O(1) space. But, as a \"test-taker\", you know that this problem can't (easily) be solved in a single pass with O(1) space, because if it could, you wouldn't have been instructed to use dynamic programming.\n\nThe core reason that your algorithm is wrong is that you only ever compare each element of ```\nseq```\n to its immediate predecessor, but subsequences are allowed to (and usually do) \"jump over\" intermediate values.\n\nOne confounding factor, which is responsible for some of the more confusing aspects of your output, is that the ```\nseq[i]>(k*seq[i-1])```\n check doesn't mean what I think you think it means. You probably wanted something closer to ```\nk*(seq[i]-seq[i-1])>0```\n — but even that will give quite wrong results. You really just need to scrap this algorithm and write a new one.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Capacitated Slugging Dynamic Programming\r\n                \r\nDef 1: A slugging graph G = (V, E), is a directed acyclic graph where V = {T1, T2, ..., Tm} is a set of trips and E is a set of directed edges between nodes that is transitive, i.e. if (Ti, Tj) in E and (Tj, Tk) in E, then (Ti, Tk) in E.\n\nDef 2: Given a slugging graph G = (V, E), a slugging plan Gs = (V, Es), Es in E, is a subgraph of G that satisfies the following conditions: (i) For all (Ti, Tj) in Es, there is no k != j such that (Ti, Tk) in Es; (ii) For all (Ti, Tj) in Es, there does not exist k suck that (Tk, Ti) in Es. \n\nBasically, (i) says that Ti can be merged into at most 1 other trip and (ii) says that Ti can be merged into another trip if and only if there is no other Tk that has been merged into Ti. \n\nDef 3: Given a slugging graph G = (V, E), a benefit is a value associated with each edge (Ti, Tj) in E. The value of benefit is given by function B(Ti, Tj) in R+. The value of B depends only on the sorce edge, i.e. B(Ti, Tj) = B(Ti, Tk) = B(Ti, Tm) and so on and so forth.\n\nDef 4: Total benefit is the summation of B(Ti, Tj) in the slugging plan Gs = (V, Es), i.e. (Ti, Tj) in Es, B(Gs).\n\nDef 5: Each trip Ti has number of passengers and number of available seats. If Ti is merged into Tj, passengers of Ti occupy some available seats of Tj. Number of available seats of Tj decreases so. If Ti has more passengers than available seats in Tj, Ti cannot be merged into Tj and, therefore, there is no (Ti, Tj) in Es.\n\nProblem: Given a slugging graph G = (V, E) and definitions 1-5, find a slugging plan Gs = (V, Es), Es in E, that has maximal total benefit B(Gs).\n\n\n\nFor a detailed description of the problem, visit this link and see subsection 3.3.\n\n\n\nI have to solve this problem using Dynamic Programming. It seems to me related to 0-1 Knapsack to some extent. For example, deciding whether or not to merge Ta, Tb and Tc into Tj is similar to having objects a, b and c and try to fit then into a bag j in a way the profit is maximum and bag capacity is preserved. However, Ta, Tb and Tc may become a bag rather than an object in this problem. Based on that, I have not been able to find the optimal substructure to start thinking about Dynamic Programming details. Could anyone lend me a hand on this?\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Converting a math problem to dynamic programming\r\n                \r\nCurrently I'm working on an optimization problem for a course I'm doing with a fellow student. It's basically described by three equations.\n\n\n\nWhere n is an index taking values between 1 and 1180, Pr is a known vector (meaning all values of this vector are known and constant) and we have to find the vector Ps that results in the minimum value of Ef[1180]. \n\nLogically, the answer would be to set all values of Ps[n] to infinity. However, there are a few constraints:\n\n\n\nFurthermore, the values of Es and Ps must always be a multiple of 1,000 to decrease the state space.\n\nThe above is what we figured out from the assignment description. However, we can't seem to figure out how to solve this as a dynamic programming problem. There are lots of examples around for going from a set of equations to a dynamic programming problem. However, those examples all have two or three inputs and use a 2- or 3-dimensional dictionary resp. to facilitate data reuse. We essentially have 1180 inputs. Creating an 1180-dimensional dictionary is not feasible\n\nWe tried constituting Bellman equations for this problem, but the professor told us this is wrong. Then we considered brute forcing the state space, but this is an insane job since there are 43^1180 possible combinations of input vectors P_s. Some of our fellow students advised us to checkout the checkerboard example on this wikipedia page:\n\nWikipedia page on dynamic programming\n\nHowever, this example seems to traverse through the checkerboard only once. The usage of a cost function would always pick the highest possible value for Ps[n] to minimize Ef[n]. However, to do pick such a positive value we must have Es[n] > 0 which can only happen when previous elements of Ps[i] for i < n take negative values. But the cost function will prevent Ps from having negative values. Since the cost function does not allow negative values and the Es[n] >= 0 constraint does not allow negative values, this will result in a Ps containing only zeroes, which certainly does not result in the lowest value of Ef[1180].\n\nAny hints on how to continue would be nice. We have been staring at this problem for days now and we are completely lost at this point.\n    ", "Answer": "\r\nYou want to minimize E[1180] idem maximize f defined below:\n\n```\nf(P) = \\sigma_{i=1}^{1180} P_i\n```\n\n\nunder constraint:\n\n```\nforall n <= 1180\n  -6.5*10^5 <= \\sum_{i=1}^n P_i <= 0\n```\n\n\nRecurrence formula be like\n\n```\nf(i, sumPs, v) {\n  if i == 1180\n    return { s: sumPs, solution: v }\n\n  res = { s: -infinity, solution: [] }\n  # Pr(i) > Ps(i)\n  for psi in -21:min(Pr[i], 21)\n    # Es(n-1) = - sumPs\n    if psi <= -sumPs\n      tmp = f(i+1, sumPs + psi, v+[psi])\n      if tmp.s > res.s\n        res.s = tmp.s\n        res.v = tmp.v\n  return res\n}\nf(0, 0, [])\n```\n\n\nDynamic approach be similar:\n\nInitialize the first layer: an associative array for ```\nsumPs```\n as key and ```\n{s:sum, v:facultative}```\n as value\n\nWe could actually just store nothing as value and use a set (stocking the sums), but it is convenient for debugging purpose\n\ninitialiaztion\n\n```\nfor psi in -21:min(Pr[0], 0)\n  layer[psi] = {s: psi, v:[psi]}\n```\n\n\nTo build layer ```\ni+1```\n, you only need layer ```\ni```\n\n\n```\nfor i = 2:1180\n  nextLayer = []\n  for psi in range(-21, min(Pr[i-1], 21))\n    for candidate in layer:\n      if psi <= -candidate.s\n        maybe = candidate.s + psi\n        if !nextLayer[maybe]\n          nextLayer[maybe] = {s: maybe, v:v+[psi]}\n  layer = nextLayer\n```\n\n\nNB: I have not handled the 1000 factor, but that should not be a problem\n\n\r\n\r\n```\nconst Pr = [-10,2,-2,4,-1]\r\nfunction f(i, sumPs, v) {\r\n  if (i == 5) {\r\n    return { s: sumPs, v }\r\n  }\r\n\r\n  let res = { s: -1e12, v: [] }\r\n  for (let psi = -21; psi<=Math.min(Pr[i], 21); ++psi) {\r\n    if (psi <= -sumPs) {\r\n      let tmp = f(i+1, sumPs + psi, v.concat(psi))\r\n      if (tmp.s > res.s) {\r\n        res.s = tmp.s\r\n        res.v = tmp.v\r\n      }\r\n    }\r\n  }\r\n  return res\r\n}\r\n\r\nfunction dp(n, pr){\r\n  let layer = new Map\r\n  for (let psi = -21; psi <= Math.min(Pr[0], 0); ++psi) {\r\n    layer.set(psi, {s: psi, v:[psi]})\r\n  }\r\n  for (let i = 2; i <= n; ++i) {\r\n    let nextLayer = new Map\r\n    for (let psi = -21; psi <= Math.min(pr[i-1], 21); ++psi) {\r\n      for (let [k, candidate] of layer) {\r\n        if (psi <= -candidate.s) {\r\n          const maybe = candidate.s + psi\r\n          if (!nextLayer.has(maybe)) {\r\n            nextLayer.set(maybe, { s: maybe, v: candidate.v.concat(psi) })\r\n          }\r\n        }\r\n      }\r\n    }\r\n    layer = nextLayer\r\n  }\r\n  return [...layer.entries()].sort((a,b) => b[0] - a[0])[0][1]\r\n}\r\n\r\nconsole.log(f(0,0,[]))\r\nconsole.log(dp(5,Pr))```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Does dynamic programming improve complexity for regex with Kleene star\r\n                \r\nLeetcode problem for regex matching including a Kleene star: https://leetcode.com/problems/regular-expression-matching/.\nThe solution suggests dynamic programming to memoize solutions to sub-problems. I can't think of a normal example where dynamic programming helps, e.g. that that the sub-problems are encountered more than once in the recursion tree. The only cases I can think of are degenerate ones where the regex can be simplified.\nFor example, if the text is ```\n\"aab\"```\n and the regex is ```\n\"a*a*\"```\n, then you do encounter the same call twice: ```\nmatch(\"ab\", \"a*\")```\n. Here are the two branches of the tree where that occurs:\n```\nmatch(\"aab\", \"a*a*\")\nmatch(\"aab\", \"a*\")\nmatch(\"ab\", \"a*\")  // occurs here\n\nmatch(\"aab\", \"a*a*\")\nmatch(\"ab\", \"a*a*\")\nmatch(\"ab\", \"a*\")  // also occurs here\n```\n\nHowever, you would not use ```\n\"a*a*\"```\n, you can simplify this regex to ```\n\"a*\"```\n, in which case I don't see any improvement on the regular recursive solution.\nThank you for your help.\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Finding subset sum using dynamic programming\r\n                \r\nI'm practicing Dynamic Programming and I'm struggling with debugging my code. The idea is to find if a sum is possible given a list of numbers. Here's my code:\n\n```\na = [2,3,7,8,10]\nsum = 11\nb = list(range(1, sum+1))\nm = [[False for z in range(len(b))] for i in range(len(a))]\n\nfor i, x in enumerate(b):\n    for j, y in enumerate(a):\n        if x==y:\n            m[j][i]=True\n        elif y<x:\n            m[j][i] = m[j-1][i]\n        else:\n            m[j][i] = m[j-1][i] or m[j-i][y-x]\n\nfor i, n in enumerate(m):\n    print(a[i], n)\n```\n\n\nAnd here is the output:\n\n```\n2 [False, True, False, False, False, False, False, False, False, False, False]\n3 [False, True, True, False, False, False, False, False, False, False, False]\n7 [False, True, True, False, True, True, True, False, False, False, False]\n8 [False, True, True, False, True, True, True, True, False, False, False]\n10 [False, True, True, False, True, True, True, True, True, True, False]\n```\n\n\nAs I understand it, in my else statement, the algorithm is supposed to go up 1 row and then look at the difference of x and y and check if that slot is possible. So for instance in the most obvious case, the last element in the last row. That would be 10(y)-11(x) which should go all the way back to index 1 on the row above it, which as we know it's True. Not entirely sure what I'm doing wrong, any help in understanding this would be greatly appreciated. \n    ", "Answer": "\r\nGiven you only feed positive values, I don't quite follow why you need a two dimensional list. You can simply use a 1d list:\n\n```\ncoins = [2,3,7,8,10]\nsum = 11\n```\n\n\nNext we initialize the list ```\npossible```\n that states whether it is possible to obtain a certain value. We set ```\npossible[0]```\n to ```\nTrue```\n since this sum can be accomplished with no coins.\n\n```\npossible = [False for _ in range(sum+1)]\npossible[0] = True\n```\n\n\nNow you iterate over each coin, and over the list and \"upgrade\" the value if possible:\n\n```\nfor coin in coins:\n    for i in range(sum-coin,-1,-1):\n        if possible[i]:\n            possible[i+coin] = True\n```\n\n\nAfter that, the list ```\npossible```\n shows for each value from ```\n0```\n up to (and including ```\nsum```\n) whether you can construct it. So if ```\npossible[sum]```\n is ```\nTrue```\n, the ```\nsum```\n can be constructed.\n\nFor the given ```\ncoins```\n and ```\nsum```\n, one gets:\n\n```\n>>> possible\n[True, False, True, True, False, True, False, True, True, True, True, True]\n```\n\n\nSo values ```\n0```\n, ```\n2```\n, ```\n3```\n, ```\n5```\n, ```\n7```\n, ```\n8```\n, ```\n9```\n, ```\n10```\n, ```\n11```\n are constructible with the coins.\n\nEdit: track the coins\n\nYou can also keep track of the coins by slightly modifying the code:\n\n```\npossible = [None for _ in range(sum+1)]\npossible[0] = []\nfor coin in coins:\n    for i in range(sum-coin,-1,-1):\n        if possible[i] is not None:\n            possible[i+coin] = possible[i]+[coin]\n```\n\n\nNow possible looks like:\n\n```\n>>> possible\n[[], None, [2], [3], None, [2, 3], None, [7], [8], [2, 7], [10], [3, 8]]\n```\n\n\nSo ```\n0```\n can be constructed with coins ```\n[]```\n (no coins); ```\n2```\n can be constructed with ```\n[2]```\n (one coin with value ```\n2```\n), ```\n3```\n with ```\n[3]```\n, ```\n5```\n with ```\n[2,3]```\n, etc.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming: top down versus bottom up comparison\r\n                \r\nCan you point me to some dynamic programming problem statements where bottom up is more beneficial than top down? (i.e. simple DP works more naturally but memoization would be harder to implement?)\n\nI find recursion with memoization much easier, and want to solve problems where bottom up is a better/perhaps only feasible approach.\n\nI understand that theoretically both are equivalent, so even something like ease of implementation would count as a benefit.\n    ", "Answer": "\r\nYou will apply bottom up with memoization OR top down recursion with memoization depending on the problem at hand . \n\nFor example, if you have to find the minimum weight independent path of a path graph, you will use the bottom up approach as you have to solve all the subproblems that are possible. \n\nBut if you have to solve the knapsack problem , you may want to use recursive top down with memoization as you have to solve a limited number of subproblems. Approaching the knapsack problem bottom up will cause the algo to solve a lot of redundant problems that are not used in the original subproblem. \n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "How to apply convex hull optimization in dynamic programming?\r\n                \r\nI am trying to solve this problem on codeforces using dynamic programming. I have made the recurrence which is of O(N^2) complexity but it is timing out. I know that the complexity of this solution can be reduced to O(N) via Convex hull optimization which is explained here. But I am not able to reduce the complexity. Please help.\n\nThis is my code.\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n#define MAX 100005\ntypedef long long ll;\nll a[MAX],b[MAX],dp[MAX];\nint main()\n{\n    int n;\n    cin >> n;\n    for(int i = 0; i < n; i++)\n        cin >> a[i];\n    for(int i = 0; i < n; i++)\n        cin >> b[i];\n    dp[0] = 0;\n\n    for(int i = 1; i < n; i++)\n    {\n        dp[i] = 1e18;\n        for(int j = 0; j < i; j++)\n        {\n\n            dp[i] = min(dp[i],dp[j] + a[i] * b[j]);\n        }\n    }\n\n    cout << dp[n-1];\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Knapsack FPTAS and dynamic programming by profit\r\n                \r\nI'm writing an FPTAS algorithm for Knapsack problem, and found out that I need to implement dynamic programming by profit for that. I have found many resources for dynnamic programming by weight (O(n * W), n - number of items, W - max capacity), but very little for profit based (O(n^2 * C), n - number of items, C highest profit from one item).\n\nI have found only one source with pseudo code here (it's in Polish, but you can see code and functions starting at page 7):\nhttp://www.asdpb.republika.pl/wyk78.pdf\n\nMy code:\n\n```\nF = new int[items.Count + 1, (Pmax * items.Count) + 1];\nint y;\nint k;\nint profit = 0;\nfor (k = 0; k < items.Count; k++)\n{\n    for (y = 0; y < (Pmax * items.Count); y++)\n    {\n        if (y == 0 && k >= 1)\n            F[k, y] = 0;\n        else if (y >= 1 && k == 0)\n            F[k, y] = int.MaxValue;\n        else if (k >= 1 && y >= 1)\n        {\n            if (y - items[k].profit < 0)\n                F[k, y] = (int)Math.Min(F[k - 1, y], int.MaxValue);\n            else\n                F[k, y] = (int)Math.Min(F[k - 1, y], F[k - 1, y -    items[k].profit] + items[k].weight);    \n        }\n    }\n}\n\ny = 0;\ndo\n{\n    y++;\n    for (k = 1; k < items.Count; k++)\n    {\n        if (y - items[k].profit < 0)\n            F[k, y] = F[k - 1, y];\n        else if (F[k - 1, y - items[k].profit] == int.MaxValue)\n            F[k, y] = F[k - 1, y];\n        else\n            F[k, y] = (int)Math.Min(F[k - 1, y], F[k - 1, y - items[k].profit] + items[k].weight);\n        if(F[items.Count,y] <= maxCapacity)\n           profit = y;\n    }\n} while (y < Pmax * items.Count);\n```\n\n\nI'm using sample data from website linked before:\n\n```\nn = 3\nprofits = [2,3,1]\nweights = [1,3,3]\ncapacity = 5\n```\n\n\nBut it returns profit = 9 and entirely diffrent table F.\nWhat's wrong with my code? Are there any other good sources for this? \n\nAlternatively I can implement PTAS algorithm but I could not find any good sources either.\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming for subsequence product sum explanation\r\n                \r\nThe question is:\n\"Given an array of integers and an integer ```\nm```\n, return the sum of the product of its subsequences of length ```\nm```\n.\"\nE.g. ```\na = [2,3,4,5]```\n and ```\nm = 3```\n then ```\nproduct_sum = (2*3*4) + (2*3*5) + (2*4*5) + (3*4*5) #=> 154```\n\nI see people solving this exercice with dynamic programming is the following way:\n```\ndef product_sum(a, m):\n    ss = [1] + [0]*m ;\n    for n in a:\n        for k in range(m,0,-1):\n            ss[k] += n * ss[k-1];\n        \n    return ss[m] \n```\n\nThis algorithm works, but i cannot understand what does the ```\nss```\n array represent ?\nI understand it must be some sub sequence partial computation but i cannot wrap my head around the formulation of the problem that could lead me to get to this algorithm.\nWhat does this array represent during execution ? what's the mathematical formulation of the problem that is solved by this algorithm ?\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "+Finding Dynamic Programming Values & Weights+\r\n                \r\n+++\nWe are given the following table on the number of homeless people in each of 3 cities, where n the number of homes to be built.\n\n\nCity    n=0  n=1  n=2\n A       15   12   10\n B        9    8    4\n C        8    6    5\n\n\nWe are after a housing strategy that minimises the total numbers of\nhomeless people across all 3 cities for a given number of homes.\nWhat would be the optimal allocation of n homes to homeless, and how many homeless would that result in total?\nThe solution is to employ dynamic programming & be in Python.\nIt appears like an unbounded knapsack problem with capacity n but what is hard to find are the values & weights to be used as parameters of the algorithm.\nPlease share your views.\n+++\n    ", "Answer": "\r\n+++\nI have managed to solve the task as a bounded knapsack case with multiple values as follows.\n\n\n\n```\ndef assign_home(cpct, tbl):\n    ctNum = len(tbl[0])\n    wghts = [1] * ctNum\n    vls = get_vls(tbl)\n    hms = [0] * ctNum\n    HMSBND = 2\n    hmlsVal = [sum(row[0] for row in tbl) for hmIndx in range(min(cpct + 1, ctNum * HMSBND + 1))]\n    for hmIndx in range(min(wghts), min(cpct + 1, ctNum * HMSBND + 1)):\n        chsn = -1\n        for ct, wght in enumerate(wghts):\n            if wght <= hmIndx and hms[ct] < HMSBND and hmlsVal[hmIndx] > hmlsVal[hmIndx - wght] - vls[ct][hms[ct]]:\n                hmlsVal[hmIndx] = hmlsVal[hmIndx - wght] - vls[ct][hms[ct]]\n                chsn = ct\n        if chsn != -1:\n            hms[chsn] += 1\n    return hmlsVal[min(cpct, ctNum * HMSBND)], hms\n\ndef get_vls(tbl):\n    [A, B, C] = tbl\n    Adf = [A[0] - A[1], A[1] - A[2]]\n    Bdf = [B[0] - B[1], B[1] - B[2]]\n    Cdf = [C[0] - C[1], C[1] - C[2]]\n    return [Adf, Bdf, Cdf]\n\ntbl=[[15, 12, 10], [9, 8, 4], [8, 6, 5]]\nprint(assign_home(5, tbl))\n# (20, [2, 2, 1])\n```\n\n\n+++\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming a Count of Subsequences with Property?\r\n                \r\nConsider a dynamic programming problem that asks how many distinct subsequences (not necessarily contiguous) of a sequence S have a certain property P of value p0.\n\nThe range of P is small and finite, and there is an efficient way of calculating P:\n\n```\nP(s1 + s2) = f(P(s1), P(s2))\n```\n\n\nwhere ```\n+```\n denotes sequence concatenation.\n\nOne way to do this would be to count how many subsequences there are of the prefix ```\nS[1] + S[2] + ... + S[k]```\n of S that have property px. (Store this in ```\nCount[px][k]```\n)\n\nSo the recursion is:\n\n```\nCount[px][k] = Count[px][k-1] // not using element S[k];\n\nP pq = f(px,P(S[k])); // calculate property pq of appending element S[k]\nCount[pq][k] += Count[px][k-1] // add count of P(prefix+S[k])\n```\n\n\nand the answer is then:\n\n```\nreturn Count[p0][S.length]\n```\n\n\nThis works when the elements of S are pairwise distinct, however it will count twice subsequences that have equal value but use different elements of different positions.\n\nHow can I modify this algorithm so that it counts equal subsequences exactly once ? (ie only counts distinct subsequences)\n    ", "Answer": "\r\nSuppose the sequence is of characters and S[k] is the letter x.\n\nThe problem is that you have double counted all sequences that don't use S[k], but nevertheless end with x (this can only happen if x happened earlier in the sequence).\n\nSuppose the last time x appeared was at element S[j].\nAll the distinct sequences that end with x is simply given by counting all distinct sequences up to position j-1, and then adding x onto all of these.\n\nWe can therefore correct for the double counting by subtracting this count.\n\n```\nCount[px][k] = Count[px][k-1] // not using element S[k]\nP pq = f(px,P(S[k])) // property pq of appending element S[k]\nj = index of previous location in string where S[j]==S[k]\nCount[pq][k] += Count[px][k-1] // using element S[k]\nCount[pq][k] -= Count[px][j-1] // Removing double counts\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Using dynamic programming to solve a version of the knapsack problem\r\n                \r\nI'm working through MIT6.0002 on OpenCourseWare (https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-0002-introduction-to-computational-thinking-and-data-science-fall-2016/assignments/) and I am stumped on Part B of Problem Set 1. The problem, which is presented as a version of the knapsack problem, is stated as follows:\n\n[The Aucks have found a colony of geese that lay golden eggs of various weights] They want to carry as few eggs as possible on their trip as they don’t have a lot of space\non their ships. They have taken detailed notes on the weights of all the eggs that geese can lay\nin a given flock and how much weight their ships can hold.\nImplement a dynamic programming algorithm to find the minimum number of eggs needed to\nmake a given weight for a certain ship in dp_make_weight. The result should be an integer\nrepresenting the minimum number of eggs from the given flock of geese needed to make the\ngiven weight. Your algorithm does not need to return what the weight of the eggs are, just the\nminimum number of eggs.\nAssumptions:\n\nAll the eggs weights are unique between different geese, but a given goose will always lay the same size egg\nThe Aucks can wait around for the geese to lay as many eggs as they need [ie there is an infinite supply of each size of egg].\nThere are always eggs of size 1 available\n\n\nThe problem also states that the solution must use dynamic programming. I have written a solution (in Python) which I think finds the optimal solution, but it does not use dynamic programming, and I fail to understand how dynamic programming is applicable. It was also suggested that the solution should use recursion.\nCan anybody explain to me what the advantage is of using memoization in this case, and what I would gain by implementing a recursive solution?\n(Apologies if my question is too vague or if the solution is too obvious for words; I'm a relative beginner to programming, and to this site).\nMy code:\n```\n#================================\n# Part B: Golden Eggs\n#================================\n\n# Problem 1\ndef dp_make_weight(egg_weights, target_weight, memo = {}):\n    \"\"\"\n    Find number of eggs to bring back, using the smallest number of eggs. Assumes there is\n    an infinite supply of eggs of each weight, and there is always a egg of value 1.\n    \n    Parameters:\n    egg_weights - tuple of integers, available egg weights sorted from smallest to largest value (1 = d1 < d2 < ... < dk)\n    target_weight - int, amount of weight we want to find eggs to fit\n    memo - dictionary, OPTIONAL parameter for memoization (you may not need to use this parameter depending on your implementation)\n    \n    Returns: int, smallest number of eggs needed to make target weight\n    \"\"\"\n    egg_weights = sorted(egg_weights, reverse=True) \n    eggs = 0\n    while target_weight != 0:\n        while egg_weights[0] <= target_weight:\n            target_weight -= egg_weights[0]\n            eggs += 1\n        del egg_weights[0]\n    return eggs\n\n\n# EXAMPLE TESTING CODE, feel free to add more if you'd like\nif __name__ == '__main__':\n    egg_weights = (1, 5, 10, 25)\n    n = 99\n    print(\"Egg weights = (1, 5, 10, 25)\")\n    print(\"n = 99\")\n    print(\"Expected ouput: 9 (3 * 25 + 2 * 10 + 4 * 1 = 99)\")\n    print(\"Actual output:\", dp_make_weight(egg_weights, n))\n    print()\n```\n\n    ", "Answer": "\r\nThe problem here is a classic DP situation where greediness can sometimes give optimal solutions, but sometimes not. \n\nThe situation in this problem is similar to the classic DP problem coin change where we wish to find the fewest number of different valued coins to make change given a target value. The denominations available in some countries such as the USA (which uses coins valued 1, 5, 10, 25, 50, 100) are such that it's optimal to greedily choose the largest coin until the value drops below it, then move on to the next coin. But with other denomination sets like 1, 3, 4, greedily choosing the largest value repeatedly can produce sub-optimal results.\n\nSimilarly, your solution works fine for certain egg weights but fails on others. If we choose our egg weights to be 1, 6, 9 and give a target weight of 14, the algorithm chooses 9 immediately and is then unable to make progress on 6. At that point, it slurps a bunch of 1s and ultimately thinks 6 is the minimal solution. But that's clearly wrong: if we intelligently ignore the 9 and pick two 6s first, then we can hit the desired weight with only 4 eggs.\n\nThis shows that we have to consider the fact that at any decision point, taking any of our denominations might ultimately lead us to a globally optimal solution. But we have no way of knowing in the moment. So, we try every denomination at every step. This is very conducive to recursion and could be written like this:\n\n```\ndef dp_make_weight(egg_weights, target_weight):\n    least_taken = float(\"inf\")\n\n    if target_weight == 0:\n        return 0\n    elif target_weight > 0:\n        for weight in egg_weights:\n            sub_result = dp_make_weight(egg_weights, target_weight - weight)\n            least_taken = min(least_taken, sub_result)\n\n    return least_taken + 1\n\nif __name__ == \"__main__\":\n    print(dp_make_weight((1, 6, 9), 14))\n```\n\n\nFor each call, we have 3 possibilities:\n\n\nBase case ```\ntarget_weight < 0```\n: return something to indicate no solution possible (I used infinity for convenience).\nBase case ```\ntarget_weight == 0```\n: we found a candidate solution. Return 0 to indicate no step was taken here and give the caller a base value to increment.\nRecursive case ```\ntarget_weight > 0```\n: try taking every available ```\negg_weight```\n by subtracting it from the total and recursively exploring the path rooted at the new state. After exploring every possible outcome from the current state, pick the one that took the least number of steps to reach the target. Add 1 to count the current step's egg taken and return.\n\n\nSo far, we've seen that a greedy solution is incorrect and how to fix it but haven't motivated dynamic programming or memoization. DP and memoization are purely optimization concepts, so you can add them after you've found a correct solution and need to speed it up. Time complexity of the above solution is exponential: for every call, we have to spawn ```\nlen(egg_weights)```\n recursive calls.\n\nThere are many resources explaining DP and memoization and I'm sure your course covers it, but in brief, our recursive solution shown above re-computes the same results over and over by taking different recursive paths that ultimately lead to the same values being given for ```\ntarget_weight```\n. If we keep a memo (dictionary) that stores the results of every call in memory, then whenever we re-encounter a call, we can look up its result instead of re-computing it from scratch.\n\n```\ndef dp_make_weight(egg_weights, target_weight, memo={}):\n    least_taken = float(\"inf\")\n\n    if target_weight == 0:\n        return 0\n    elif target_weight in memo:\n        return memo[target_weight]\n    elif target_weight > 0:\n        for weight in egg_weights:\n            sub_result = dp_make_weight(egg_weights, target_weight - weight)\n            least_taken = min(least_taken, sub_result)\n\n    memo[target_weight] = least_taken + 1\n    return least_taken + 1\n\nif __name__ == \"__main__\":\n    print(dp_make_weight((1, 6, 9, 12, 13, 15), 724)) # => 49\n```\n\n\nSince we're using Python, the \"Pythonic\" way to do it is probably to decorate the function. In fact, there's a builtin memoizer called ```\nlru_cache```\n, so going back to our original function without any memoization, we can add memoization (caching) with two lines of code:\n\n```\nfrom functools import lru_cache\n\n@lru_cache\ndef dp_make_weight(egg_weights, target_weight):\n    # ... same code as the top example ...\n```\n\n\nMemoizing with a decorator has the downside of increasing the size of the call stack proportional to the wrapper's size so it can increase the likelihood of blowing the stack. That's one motivation for writing DP algorithms iteratively, bottom-up (that is, start with the solution base cases and build up a table of these small solutions until you're able to build the global solution), which might be a good exercise for this problem if you're looking for another angle on it.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "+Finding Dynamic Programming Values & Weights+\r\n                \r\n+++\nWe are given the following table on the number of homeless people in each of 3 cities, where n the number of homes to be built.\n\n\nCity    n=0  n=1  n=2\n A       15   12   10\n B        9    8    4\n C        8    6    5\n\n\nWe are after a housing strategy that minimises the total numbers of\nhomeless people across all 3 cities for a given number of homes.\nWhat would be the optimal allocation of n homes to homeless, and how many homeless would that result in total?\nThe solution is to employ dynamic programming & be in Python.\nIt appears like an unbounded knapsack problem with capacity n but what is hard to find are the values & weights to be used as parameters of the algorithm.\nPlease share your views.\n+++\n    ", "Answer": "\r\n+++\nI have managed to solve the task as a bounded knapsack case with multiple values as follows.\n\n\n\n```\ndef assign_home(cpct, tbl):\n    ctNum = len(tbl[0])\n    wghts = [1] * ctNum\n    vls = get_vls(tbl)\n    hms = [0] * ctNum\n    HMSBND = 2\n    hmlsVal = [sum(row[0] for row in tbl) for hmIndx in range(min(cpct + 1, ctNum * HMSBND + 1))]\n    for hmIndx in range(min(wghts), min(cpct + 1, ctNum * HMSBND + 1)):\n        chsn = -1\n        for ct, wght in enumerate(wghts):\n            if wght <= hmIndx and hms[ct] < HMSBND and hmlsVal[hmIndx] > hmlsVal[hmIndx - wght] - vls[ct][hms[ct]]:\n                hmlsVal[hmIndx] = hmlsVal[hmIndx - wght] - vls[ct][hms[ct]]\n                chsn = ct\n        if chsn != -1:\n            hms[chsn] += 1\n    return hmlsVal[min(cpct, ctNum * HMSBND)], hms\n\ndef get_vls(tbl):\n    [A, B, C] = tbl\n    Adf = [A[0] - A[1], A[1] - A[2]]\n    Bdf = [B[0] - B[1], B[1] - B[2]]\n    Cdf = [C[0] - C[1], C[1] - C[2]]\n    return [Adf, Bdf, Cdf]\n\ntbl=[[15, 12, 10], [9, 8, 4], [8, 6, 5]]\nprint(assign_home(5, tbl))\n# (20, [2, 2, 1])\n```\n\n\n+++\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "How integrate time window constraints to dynamic programming to solve tsp problem?\r\n                \r\nI have recursive dynamic programming  code that  solve TSP while minimizing the travelling  cost. But I can't integrate the time window constraints. Please, I need your help.\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "How can we solve substring matching check using Dynamic Programming\r\n                \r\nI learnt program to find longest common substring using dynamic programming. Can we also use dynamic programming to find out if substring exists in a string?\n\nI tried it. However, it seem to be making things more complicated! \n\nBelow is the pseudo code of what I tried.\n\nString : Helello\n\nSubstring : llo\n\nf(n) : returns false if character of substring not found or the positions of found places\n\nf(0) = matching indexes or false\n\nf(1) = next index of f(0) index is substring[1] or false\n\nf(2) = next index of f(1) index is substring[1] or false\n\nf(n) = f(n-1) followed by next index of current char or false\n\nCalling : substring('hello', 2, 'el' );\n\n```\nsubstring(str, n, substring)\n{\n        if(n == 0)\n        {\n                for(i=0;i<strlen(str);i++)\n                {\n                        if(str[i] == substring[n])\n                                pos[] = i; //append i to positions array\n                }\n                if(pos) return pos;\n                return false;\n        }\n        else\n        {\n                indexes = substring(str, n-1, substring);\n                if(indexes)\n                {\n                        foreach(indexes as index)\n                        {\n                                if(str[index+1] == substring[n])\n                                        return true;\n                        }\n                        return false;\n                }\n        }\n\n}\n```\n\n    ", "Answer": "\r\nI don't think you can solve that problem with DP.\n\nFor instance let's say you have a sentence S, and word W. You wanna to check if the given word W is a substring of sentence S. You can do that with DP only if the length of LCS(longest common substring) is equal to length of word W, which means that W is actually that LCS. Complexity is O(N * M) where N is length of S and M is length of W.\n\nYou can do much better with KMP, in O(N + M), or hashing.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "dynamic programming practice algorithm\r\n                \r\nI am trying to find a recurrence relation and algorithm to the following problem but have been stuck for a few days:\n\nThere are a total of H > n hours in which to work on the n school projects (all of which are due at exactly the same time) and you want to decide now to divide up this time. For simplicity, assume that H is a positive integer, and that you will spend an integer number of hours on each project. You have come up with a set of functions f1, ..., fn (a rough estimate, of course) such that working x hours on project i will get you a grade of fi(x) on that project.\n\nMay assume that fi(x) does not decrease if x increases and each project will be graded on a scale from 1 to 100.\n\nSo, given H and f1, ..., fn, you need to determine how many (integer) hours you will spend on each project so your average grade is as large as possible (max grade).\n\n\nFinding recurrence relation for G[H, j], where G[H, j] is the sum of the grades obtained by spending H hours in total on the projects for courses 1, 2, ... j\nFinding a dynamic programming algorithm that computes G[H, n]\n\n\nDoes anyone have ideas? \n    ", "Answer": "\r\nI think this would work:\n\n```\nG[H<0, j] = -Infinity\nG[H, 0] = 0\nG[H, j] = max(G[H-i, j-1]+f_j(i)) for 0<=i<=H\n```\n\n\nIn the recurrence I'm trying to find the best number of hours to work on the project j. This solution is O(H^2*n).\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Ehat is the space complexities of recursive and dynamic programming approaches of binomial coefficient?\r\n                \r\nI saw that the space complexity when using dynamic programming approach(Pascal's triangle) is O(n^2). What about the space complexity in recursion approach?\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Algorithm related to Dynamic Programming\r\n                \r\nI am trying to solve a problem that says you will be given an integer N which is \n 0 <= N <= 150000. You will also be given an array containing integers, with the array length up to 2000.\n\nI want to get sum of the subset of the array that be closest to N or exactly equal N. The problem states that the sum should be either exactly equal to N, but if there is no subset that can reach N exactly, so we should bring the closest, yet less than N. For example:           \n\nN = 11  and ```\nArray = { 2 , 3 , 5 , 7 }```\n the output should be in this case 10\nN = 12  and ```\nArray = { 4 , 6 , 9 }```\n the output should be in this case 10\nN = 10 and ```\nArray = { 2 , 3 , 3 , 10 }```\n the output should be in this case 10   \n\nI have tried to solve this with all permutations but it gives me time limit exceed as the input constraint is high. I tried to use Dynamic Programming but the 2D array store give memory limit exceed as ```\nmem[150001][2001]```\n. I tried to do it in [150001][2] as some tutorials about DP mentioned but I couldn't. Any help would be appreciated.\n    ", "Answer": "\r\nI have a solution running quite quickly. I didn't do strict timing or memory checks though. My solution is recursive though I don't see how to make it dynamic:\n\n\nFind largest number in Array less than N, add it to the subset\nRecurse over step 1, subtracting from N the number you just added\n\nThis gives you a possibly imperfect solution: \nif N = 18, Array = {12, 9, 8, 5, 4}, you'll end up with subset answer {12, 5} instead of {9, 5, 4}. You can say that the 'gap' in this solution is ```\ngap = 1```\n.\nFor each member ```\nm```\n of the subset, you're going to solve again, setting N to ```\nm + gap```\n, and Array to the members of the original Array excluding all members of the subset. In our example, we would spawn two more problems: N = 13, Array = {9, 8, 4}, and N = 6, Array = {9, 8, 4}. \nTake the best solution offered by the previous step, as determined by gap reduction. If the gap in the best solution is less then the gap in the larger problem, replace the targeted number with the subset. In our case N = 13 is solved perfectly by {9, 4}, which targeted the 12, so we replace 12 with {9, 4} giving us {9, 4, 5}. \nIf ```\ngap=0```\n for this sub problem, we're done.\nIf you don't reach ```\ngap=0```\n, but did do a replacement, recurse over step 4.\nIf you didn't do a replacement in step 4, you have the best possible solution, you're done.\n\n\nI did it in a rather ugly C#, though if you want the code, I could clean it up a bit.\n\nEDIT: Added code\n\nI tried to cordone off the C# particulars to specific functions. Keeping the thing sorted the whole time is not necessary, and I'm sure you can cut down on memory usage in the ImproveOnGaps function. \n\nTo run:\n\n```\nvoid Main()\n{\n    Problem p = Solvers.GenerateRandomProblem();\n    Solution imperfectSolution = Solvers.SolveRecursively(p);\n    Solution bestPossibleSolution = Solvers.ImproveOnGaps(s);\n}\n\n\nclass Solution\n{\n    public Problem Problem;\n    public int[] NumbersUsed;\n    public int n;\n    public int[] NumbersUnused;\n}\n\nclass Problem\n{\n    public int N;\n    public int[] Array;\n}\n\nclass Solvers\n{\n    public static Problem GenerateRandomProblem()\n    {\n        Random r = new Random();\n        int N = r.Next(1500000);\n        int arraySize = r.Next(1, 2000);\n\n        int[] array = new int[arraySize];\n        for(int i = 0; i < arraySize; i++)\n            array[i] = r.Next(1, 15000);\n\n        Problem problem = new Problem\n        {\n            N = N,\n            Array = array\n        };\n\n        return problem;\n    }\n\n    public static Solution SolveRecursively(Problem p)\n    {\n        return SolveRecursively( new Solution\n        {\n            Problem = p,\n            n = 0,\n            NumbersUnused = SortAscending(p.Array),\n            NumbersUsed = new int[0]\n        });\n    }\n\n    private static Solution SolveRecursively(Solution s)\n    {\n        if(s.n == s.Problem.N)\n            return s;\n\n        for(int i = s.NumbersUnused.Length - 1; i >= 0; i--) //\n        {\n            if(s.n + s.NumbersUnused[i] <= s.Problem.N)\n            {\n                return SolveRecursively(new Solution\n                {\n                    n = s.n + s.NumbersUnused[i],\n                    NumbersUnused = SkipIthPosition(s.NumbersUnused, i),\n                    NumbersUsed =  AddToSortedArray(s.NumbersUsed, s.NumbersUnused[i]),\n                    Problem = s.Problem\n                });\n            }\n        }\n        return s;\n    }\n\n    public static Solution ImproveOnGaps(Solution s)\n    {\n        if(s.n == s.Problem.N)\n            return s;\n\n        int gap = s.Problem.N - s.n;\n        List<Problem> newProblems = new List<Problem>();\n        foreach (int i in s.NumbersUsed)\n        {\n            newProblems.Add(new Problem\n            {\n                Array = s.NumbersUnused,\n                N = i + gap\n            });\n        }\n\n        int newGap = gap;\n        Solution bestImprovement = null;\n        foreach (Problem p in newProblems)\n        {\n            Solution tempSolution = SolveRecursively(p);\n            if(tempSolution.Problem.N - tempSolution.n < newGap)\n                bestImprovement = tempSolution;\n        }\n\n        if(bestImprovement != null)\n        {\n            List<int> usedNumbers = s.NumbersUsed.ToList();\n            usedNumbers.Remove(bestImprovement.Problem.N - gap);\n            usedNumbers.AddRange(bestImprovement.NumbersUsed);\n\n            List<int> unusedNumbers = s.NumbersUnused.ToList();\n            foreach (int i in bestImprovement.NumbersUsed)\n                unusedNumbers.Remove(i);\n\n            return ImproveOnGaps(new Solution\n            {\n                n = usedNumbers.Sum(),\n                NumbersUnused = unusedNumbers.ToArray(),\n                NumbersUsed = usedNumbers.ToArray(),\n                Problem = s.Problem\n            });\n        }\n\n        return s;\n\n    }\n\n    private static int[] SortAscending(int[] array)\n    {\n        return array.OrderBy(i => i).ToArray();\n    }\n\n    private static int[] SkipIthPosition(int[] array, int i)\n    {\n        return array.Take(i)\n            .Union(array.Skip(i + 1).Take(array.Length - 1 - i))\n            .ToArray();\n    }\n\n    private static int[] AddToSortedArray(int[] array, int i)\n    {\n        return array.Concat(new int[] { i }).OrderBy(d => d).ToArray(),\n    }\n\n\n}\n```\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic Programming for Graph Splitting\r\n                \r\nI have a graph which has edges between every vertices ```\ni```\n and ```\nj```\n such\nthat ```\ni < j```\n.  I need to divide the graph into two parts such that the sum of the weight of the edges traveling from the lowest index to the highest index is minimum.  For example there is a graph of 4 vertices where each edge weight is the following\n```\nw(1, 2) = 100\nw(1, 3) = 2\nw(1, 4) = 1\nw(2, 3) = 100\nw(2, 4) = 100\nw(3, 4) = 3\n```\n\nThe solution would be ```\n{2}, {1,3,4}```\n. Therefore the ans will be sum of edge 1 and 3 and edge 3 and 4 i.e. 2 + 3 = 5. We start from the lowest index vertex and move to the highest index vertex.\nThe algorithm I came up was a brute force i.e. considering each\ncombination and return the minimum of it i.e. to take one vertex in one\ngroup or include in other which leads to complexity O(2^n).\nI want to get the above problem to run in O(n^2) solution.  I did draw\na decision tree for the above problem and can see nodes being overlapped\ni.e. ```\n{1,2}, {3,4}```\n and ```\n{3,4}, {1,2}```\n so I figured this is a\ndynamic programming problem but I am not able to define the states, or\nmaybe it is not a DP problem.\n    ", "Answer": "", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "optimizing dynamic programming in matlab\r\n                \r\nI have a problem with a dynamic programming solution which I'm trying to implement in matlab and was trying to see if there's a better (run-time-wise) implementation than the one I could come up with.\n\nThe problem (all values are in the real):\ninput: let X be a T-by-d matrix, W be a k-by-d matrix and A by a k-by-k matrix.\noutput: Y T-by-1 array s.t for row i in X Y(i) is the number of a row in W which maximizes our goal.\n\nA(i,j) gives us the cost of choosing row j if the previous row we chose was i.\n\nTo calculate the weight of the output, for each row i in X we sum the dot-product of the Y(i) row of W and add the relevant cost from A.\n\nOur goal is to maximaize the said weight.\n\nDynamic solution:\n\n\ninstantiate a k-by-T matrix\nFill the first column of the matrix with the results of dot-producting the first row of X with each row of W\nfor each of the same columns (denote as i) fill with the dot-producting of the i row of X with each row of W and add the cost of A(j,i) where j is the row index of the cell in previous column with maximum value\nbacktrack from the last column, each time choosing the row index of the cell with the highest value\n\n\nMatlab implementation (with instantiation of variables):\n\n```\nT = 8;\nd = 10;\nk = 20;\nX = rand(T,d);\nW = rand(k,d);\nA = rand(k);\nY = zeros(T,1);\nweight_table = zeros(k,T);\n\nweight_table(:,1) = W*X(1,:)';\n\nfor t = 2 : T\n    [~, prev_ind] = max(weight_table(:,t-1));\n    weight_table(:,t) = W*X(t,:)' + A(:,prev_ind);\nend\n\n[~, Y] = max(weight_table);\n```\n\n    ", "Answer": "\r\nSince there is data dependency across iterations, I would advise keeping the loop, but pre-calculate few things like the product of ```\nW```\n and transpose of each row of ```\nX```\n. This is done here (showing just the ```\nweight_table```\n calculation part as the rest of the code stays the same as in the original post) -\n\n```\nweight_table = zeros(k,T);\nweight_table(:,1) = W*X(1,:)';\nWXt = W*X.'; %//' Pre-calculate\nfor t = 2 : T\n    [~, prev_ind] = max(weight_table(:,t-1));\n    weight_table(:,t) = WXt(:,t) + A(:,prev_ind); %// Use pre-calculated values and thus avoid that multiplication across each iteration\nend\n```\n\n\nFor bigger inputs like - ```\nT = 800; d = 1000; k = 2000;```\n, I am getting ```\n8-10x```\n performance improvement with it on my system.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Dynamic programming: find the maximum revenue\r\n                \r\nThis is the weighted job scheduling problem in ```\nO(N log N)```\n using dynamic programming\n```\nHow each list is structured = [city, start_day, end_day, revenue]\nrev = [['A', 1, 7, 5], ['B', 6, 9, 4], ['C', 1, 5, 3]]\n>>> print(max_rev(rec))\n['B', 6, 9, 4], ['C', 1, 5, 3]\n```\n\nMy attempt for n log n:\n\nSort the list based on the last day in a city using a modified merge sort (n log n), this will get me ```\n[['C', 1, 5, 3], ['A', 1, 7, 5], ['B', 6, 9, 4]]```\n number them 0 -> n according to its index now (I mentioned insertion sort before, I messed up as its worst case is n^2, hence I'm using merge sort now)\n*clueless from here. Create a ```\nmemo list of n (3) size```\n and each index of ```\nmemo```\n represents the index position of a particular city in now sorted rev\nEach index of the memo will contain the maximum revenue the salesman can obtain if he works at that city. Do this by looping through the sorted list, and for each city information, add up all the revenues between it and the cities that has a greater start_day then the selected city's end_day.\n\n    ", "Answer": "\r\nYou made a good start.  Let's begin with your sorted and numbered list of jobs.\nConsider the question: \"how much money can you make if you can only work jobs with numbers <= i\".  Call this ```\nmoney(i)```\n. ```\nmoney(n-1)```\n is the answer you're looking for.\nObviously ```\nmoney(0)```\n is the value of job 0.\n```\nmoney(i)```\n for the following jobs can be easily calculated if you know the results for the previous jobs:\n```\nmoney(i) = max(\n    money(i-1),  // this is the value if we don't do job i\n    job_value(i), // this is the case when we only do job i\n    job_value(i) + money(j) // j is the highest value job that ends before i starts\n)\n```\n\nNow you just have to find the best ```\nj```\n.  The part you missed is that ```\nmoney(i)```\n is always at least as big as ```\nmoney(i-1)```\n -- it never hurts to have another job available, so the best job ```\nj```\n is always the highest numbered job that ends before ```\ni```\n starts.\nSince your list of jobs is sorted by end time, you can find this job ```\nj```\n with a binary search in O(log N) time, for O(N log N) all together.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "perl blowing up in sequence alignment by dynamic programming\r\n                \r\nI'm comparing a reference sequence of size 5500 bases and query sequence of size 3600, using dynamic programming (semi global alignment), in fact I don't know much about complexity and performance and the code is blowing up and giving me the error \"out of memory\". Knowing that it works normally on smaller sequences, my question is: This behavior is normal or I might have another problem in code ?if it's normal any hint to solve this problem ? Thanks in advance.\n\n```\nsub semiGlobal {\n    my ( $seq1, $seq2,$MATCH,$MISMATCH,$GAP ) = @_;\n    # initialization: first row to 0 ;\n    my @matrix;\n    $matrix[0][0]{score}   = 0;\n    $matrix[0][0]{pointer} = \"none\";\n    for ( my $j = 1 ; $j <= length($seq1) ; $j++ ) {\n        $matrix[0][$j]{score}   = 0;\n        $matrix[0][$j]{pointer} = \"none\";\n    }\n\n    for ( my $i = 1 ; $i <= length($seq2) ; $i++ ) {\n        $matrix[$i][0]{score}   = $GAP * $i;\n        $matrix[$i][0]{pointer} = \"up\";\n    }\n\n    # fill\n    my $max_i     = 0;\n    my $max_j     = 0;\n    my $max_score = 0;\n\n    print \"seq2: \".length($seq2);\n    print \"seq1: \".length($seq1);\n\n    for ( my $i = 1 ; $i <= length($seq2) ; $i++ ) {\n        for ( my $j = 1 ; $j <= length($seq1) ; $j++ ) {\n            my ( $diagonal_score, $left_score, $up_score );\n            # calculate match score\n            my $letter1 = substr( $seq1, $j - 1, 1 );\n            my $letter2 = substr( $seq2, $i - 1, 1 );\n            if ( $letter1 eq $letter2 ) {\n                $diagonal_score = $matrix[ $i - 1 ][ $j - 1 ]{score} +  $MATCH;\n            }\n            else {\n                $diagonal_score = $matrix[ $i - 1 ][ $j - 1 ]{score} +  $MISMATCH;\n            }\n\n            # calculate gap scores\n            $up_score   = $matrix[ $i - 1 ][$j]{score} +  $GAP;\n            $left_score = $matrix[$i][ $j - 1 ]{score} +  $GAP;\n\n            # choose best score\n            if ( $diagonal_score >= $up_score ) {\n                if ( $diagonal_score >= $left_score ) {\n                    $matrix[$i][$j]{score}   = $diagonal_score;\n                    $matrix[$i][$j]{pointer} = \"diagonal\";\n                }\n                else {\n                    $matrix[$i][$j]{score}   = $left_score;\n                    $matrix[$i][$j]{pointer} = \"left\";\n                }\n            }\n            else {\n                if ( $up_score >= $left_score ) {\n                    $matrix[$i][$j]{score}   = $up_score;\n                    $matrix[$i][$j]{pointer} = \"up\";\n                }\n                else {\n                    $matrix[$i][$j]{score}   = $left_score;\n                    $matrix[$i][$j]{pointer} = \"left\";\n                }\n            }\n\n            # set maximum score\n            if ( $matrix[$i][$j]{score} > $max_score ) {\n                $max_i     = $i;\n                $max_j     = $j;\n                $max_score = $matrix[$i][$j]{score};\n            }\n        }\n    }\n\n    my $align1 = \"\";\n    my $align2 = \"\";\n    my $j = $max_j;\n    my $i = $max_i;\n\n    while (1) {\n        if ( $matrix[$i][$j]{pointer} eq \"none\" ) {\n            $stseq1 = $j;\n            last;\n        }\n\n        if ( $matrix[$i][$j]{pointer} eq \"diagonal\" ) {\n            $align1 .= substr( $seq1, $j - 1, 1 );\n            $align2 .= substr( $seq2, $i - 1, 1 );\n            $i--;\n            $j--;\n        }\n        elsif ( $matrix[$i][$j]{pointer} eq \"left\" ) {\n            $align1 .= substr( $seq1, $j - 1, 1 );\n            $align2 .= \"-\";\n            $j--;\n        }\n        elsif ( $matrix[$i][$j]{pointer} eq \"up\" ) {\n            $align1 .= \"-\";\n            $align2 .= substr( $seq2, $i - 1, 1 );\n            $i--;\n        }\n    }\n\n    $align1 = reverse $align1;\n    $align2 = reverse $align2;\n    return ( $align1, $align2, $stseq1 ,$max_j);\n}\n```\n\n    ", "Answer": "\r\nOne way to possibly solve the problem is to tie the ```\n@matrix```\n with a file. However, this will dramatically slow down the program. Consider this:\n\n```\nsub semiGlobal {\n\n    use Tie::Array::CSV; \n\n    tie my @matrix, 'Tie::Array::CSV', 'temp.txt'; # Don't forget to add your own error handler.\n\n\n    my ( $seq1, $seq2,$MATCH,$MISMATCH,$GAP ) = @_;\n\n    # initialization: first row to 0 ;\n\n    $matrix[0][0] = '0 n';\n    for ( my $j = 1 ; $j <= length($seq1) ; $j++ ) {\n        $matrix[0][$j] = '0 n';\n    }\n\n    for ( my $i = 1 ; $i <= length($seq2) ; $i++ ) {\n\n        my $score = $GAP * $i;\n        $matrix[$i][0] = join ' ',$score,'u';\n    }\n\n    #print Dumper(\\@matrix);\n\n    # fill\n    my $max_i     = 0;\n    my $max_j     = 0;\n    my $max_score = 0;\n\n    print \"seq2: \".length($seq2).\"\\n\";\n    print \"seq1: \".length($seq1).\"\\n\";\n\n    for ( my $i = 1 ; $i <= length($seq2) ; $i++ ) {\n        for ( my $j = 1 ; $j <= length($seq1) ; $j++ ) {\n            my ( $diagonal_score, $left_score, $up_score );\n\n            # calculate match score\n            my $letter1 = substr( $seq1, $j - 1, 1 );\n            my $letter2 = substr( $seq2, $i - 1, 1 );\n            my $score = (split / /, $matrix[ $i - 1 ][ $j - 1 ])[0];\n            if ( $letter1 eq $letter2 ) {\n                $diagonal_score = $score +  $MATCH;\n            }\n            else {\n                $diagonal_score = $score +  $MISMATCH;\n            }\n\n            # calculate gap scores\n            $up_score   = (split / /,$matrix[ $i - 1 ][$j])[0] +  $GAP;\n            $left_score = (split / /,$matrix[$i][ $j - 1 ])[0] +  $GAP;\n\n            # choose best score\n            if ( $diagonal_score >= $up_score ) {\n                if ( $diagonal_score >= $left_score ) {\n                    $matrix[$i][$j] = join ' ',$diagonal_score,'d';\n                }\n                else {\n                    $matrix[$i][$j] = join ' ', $left_score, 'l';\n                }\n            }\n            else {\n                if ( $up_score >= $left_score ) {\n                    $matrix[$i][$j] = join ' ', $up_score, 'u';\n                }\n                else {\n                    $matrix[$i][$j] = join ' ', $left_score, 'l';\n                }\n            }\n\n            # set maximum score\n            if ( (split / /, $matrix[$i][$j])[0] > $max_score ) {\n                $max_i     = $i;\n                $max_j     = $j;\n                $max_score = (split / /, $matrix[$i][$j])[0];\n\n            }\n        }\n    }\n\n\n    my $align1 = \"\";\n    my $align2 = \"\";\n    my $stseq1;\n\n    my $j = $max_j;\n    my $i = $max_i;\n\n    while (1) {\n        my $pointer = (split / /, $matrix[$i][$j])[1];\n        if ( $pointer eq \"n\" ) {\n            $stseq1 = $j;\n            last;\n        }\n\n        if ( $pointer eq \"d\" ) {\n            $align1 .= substr( $seq1, $j - 1, 1 );\n            $align2 .= substr( $seq2, $i - 1, 1 );\n            $i--;\n            $j--;\n        }\n        elsif ( $pointer eq \"l\" ) {\n            $align1 .= substr( $seq1, $j - 1, 1 );\n            $align2 .= \"-\";\n            $j--;\n        }\n        elsif ( $pointer eq \"u\" ) {\n            $align1 .= \"-\";\n            $align2 .= substr( $seq2, $i - 1, 1 );\n            $i--;\n        }\n    }\n\n    $align1 = reverse $align1;\n    $align2 = reverse $align2;\n\n    untie @matrix; # Don't forget to add your own error handler.\n\n    unlink 'temp.txt'; # Don't forget to add your own error handler.\n\n    return ( $align1, $align2, $stseq1 ,$max_j);\n} \n```\n\n\nYou can still use your original sub for short sequences, and switch to this sub for long ones.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "How to convert recursive \"divide and conquer\" function to a dynamic programming function using decorators?\r\n                \r\nI am trying to write a decorator function which converts a pure recursive function with two arguments that uses a \"divide and conquer\" strategy to an equivalent but more efficient one using dynamic programming.\nNote: it is designated to decorate two input functions.\n\nSo I am trying to memoize the values but I am not sure how to correctly implement it in the form of a decorator? Also how can it decorate two input functions?\n\nEDIT:\nThis is what I have managed to do:\n\n```\nprofile_results = {}\nt = {}\n\n '''The profile function stores the following: the time taken by the function, the name of the function and the number of times it was called and stores these in the dictionary called *profile_results* '''\n\ndef profile(func):\n    import time\n    def wrapper(*args, **kwargs):\n        wrapper.calls += 1\n        name = func.__name__\n        t1 = time.time()\n        res = func(*args, **kwargs)\n        t2 = time.time() - t1\n        t = (t2)\n        my_tuple = (t,wrapper.calls)\n        profile_results[name] = my_tuple\n        return res\n    wrapper.calls = 0\n    return wrapper\n\n#the dynamic function is the more efficient one and it is a decorator\n@profile\ndef dynamic(func):\n    def wrapper(*args, **kwargs):\n        if args in t:\n            return t[args]\n        else:\n            res = func(*args, **kwargs)\n            t[args] = res\n            return res\n    return wrapper\n\n#regular recursive function\n@dynamic\n@profile\ndef factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\n```\n\n\nThis is what it prints out when I test it:\n\n```\nfactorial(5)\nprint(t)\nprint (profile_results)\n```\n\n\nOutput: \n\n```\n{(0,): 1, (1,): 1, (2,): 2, (3,): 6, (4,): 24, (5,): 120}\n{'dynamic': (0.0, 1), 'factorial': (0.0, 6)}\n```\n\n\nThe first output is correct but I am trying to profile it to see if the dynamic programming one is actually faster. However, it is showing the times as 0. Would I need to add a time.sleep() somewhere and where would I add it to correctly output the time (given that they are recursive functions)?\n\nI am wondering if I am decorating it properly. I am trying to decorate the dynamic function which is a decorator as well. And I am trying to decorate the factorial function with both the dynamic and profile function.\n\nAny help would be appreciated!\n    ", "Answer": "\r\nThere's already a memoize / cache decorator in the standard library : https://docs.python.org/3/library/functools.html#functools.lru_cache\n\nDon't re-invent the wheel, but perhaps it is not suited to what you need.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Counting valid sequences with dynamic programming\r\n                \r\nI am pretty new to Dynamic Programming, but I am trying to get better. I have an exercise from a book, which asks me the following question (slightly abridged):\n\nYou want to construct sequence of length N from numbers from the set {1, 2, 3, 4, 5, 6}. However, you cannot place the number i (i = 1, 2, 3, 4, 5, 6) more than A[i] times consecutively, where A is a given array. Given the sequence length N (1 <= N <= 10^5) and the constraint array A (1 <= A[i] <= 50), how many sequences are possible?\n\nFor instance if A = {1, 2, 1, 2, 1, 2} and N = 2, this would mean you can only have one consecutive 1, two consecutive 2's, one consecutive 3, etc. Here, something like \"11\" is invalid since it has two consecutive 1's, whereas something like \"12\" or \"22\" are both valid. It turns out that the actual answer for this case is 33 (there are 36 total two-digit sequences, but \"11\", \"33\", and \"55\" are all invalid, which gives 33).\n\n\n\nSomebody told me that one way to solve this problem is to use dynamic programming with three states. More specifically, they say to keep a 3d array dp(i, j, k) with i representing the current position we are at in the sequence, j representing the element put in position i - 1, and k representing the number of times that this element has been repeated in the block. They also told me that for the transitions, we can put in position i every element different from j, and we can only put j in if A[j] > k.\n\nIt all makes sense to me in theory, but I've been struggling with implementing this. I have no clue how to begin with the actual implementation other than initializing the matrix dp. Typically, most of the other exercises had some sort of \"base case\" that were manually set in the matrix, and then a loop was used to fill in the other entries.\n\nI guess I am particularly confused because this is a 3D array.\n    ", "Answer": "\r\nFor a moment let's just not care about the array. Let's implement this recursively. Let ```\ndp(i, j, k)```\n be the number of sequences with length ```\ni```\n, last element ```\nj```\n, and ```\nk```\n consecutive occurrences of ```\nj```\n at the end of the array.\n\nThe question now becomes how do we write the solution of ```\ndp(i, j, k)```\n recursively. \n\nWell we know that we are adding a ```\nj```\n the ```\nkth```\n time, so we have to take each sequence of length ```\ni - 1```\n, and has ```\nj```\n occurring ```\nk - 1```\n times, and add another ```\nj```\n to that sequence. Notice that this is simply ```\ndp(i - 1, j, k - 1)```\n.\n\nBut what if ```\nk == 1```\n? If that's the case we can add one occurence of ```\nj```\n to every sequence of length ```\ni - 1```\n that doesn't end with ```\nj```\n. Essentially we need the sum of all ```\ndp(i, x, k)```\n, such that ```\nA[x] >= k```\n and ```\nx != j```\n. \n\nThis gives our recurrence relation:\n\n```\ndef dp(i, j, k):\n\n    # this is the base case, the number of sequences of length 1\n    # one if k is valid, otherwise zero\n    if i == 1: return int(k == 1)\n\n    if k > 1:\n        # get all the valid sequences [0...i-1] and add j to them\n        return dp(i - 1, j, k - 1)\n\n    if k == 1:\n        # get all valid sequences that don't end with j\n        res = 0\n        for last in range(len(A)):\n            if last == j: continue\n            for n_consec in range(1, A[last] + 1):\n                res += dp(i - 1, last, n_consec)\n        return res\n```\n\n\nWe know that our answer will be all valid subsequences of length ```\nN```\n, so our final answer is ```\nsum(dp(N, j, k) for j in range(len(A)) for k in range(1, A[j] + 1))```\n\n\nBelieve it or not this is the basis of dynamic programming. We just broke our main problem down into a set of subproblems. Of course, right now our time is exponential because of the recursion. We have two ways to lower this:\n\n\nCaching, we can simply keep track of the result of each (i, j, k) and then spit out what we originally computed when it's called again. \nUse an array. We can reimplement this idea with bottom-up dp, and have an array ```\ndp[i][j][k]```\n. All of our function calls just become array accesses in a for loop. Note that using this method forces us iterate over the array in topological order which may be tricky.\n\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
{"Question": "Where does my dynamic programming approach goes wrong?\r\n                \r\nI am trying to solve this spoj problem http://www.spoj.com/problems/BYTESM2/\n\nThis is the code I've tried so far,\n\n```\n#include <iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\nint a[101][101],Table[101][101]={0};\nint pickStones(int i,int j,int n,int m,int sum)\n{\n    int k,l,p;\n    int stones=0;\n    if(i>n||j>m||j<0)\n    return 0;\n    else if(i==n)\n    return Table[i][j]=sum;\n    else\n    {\n        if(Table[i][j]==0)\n        {\n            if(Table[i+1][j]==0)\n        Table[i+1][j]=pickStones(i+1,j,n,m,sum+a[i][j]);\n        if(Table[i+1][j-1]==0)\n        Table[i+1][j-1]=pickStones(i+1,j-1,n,m,sum+a[i][j]);\n        if(Table[i+1][j+1]==0)\n        Table[i+1][j+1]=pickStones(i+1,j+1,n,m,sum+a[i][j]);\n        stones=max(Table[i+1][j],Table[i+1][j-1]);\n        stones=(max(stones,Table[i+1][j+1]));\n        Table[i][j]=stones;\n        }\n        return Table[i][j];\n    }\n}\nint main() {\n    int t,n,m,l=0,h=0,max;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        scanf(\"%d%d\",&n,&m);\n        for(int i=0;i<n;i++)\n        for(int j=0;j<m;j++)\n        scanf(\"%d\",&a[i][j]);\n        max=a[0][0];\n        for(int i=0;i<m;i++)\n        if(a[0][i]>max)\n        {\n            max=a[0][i];\n            l=0;h=i;\n        }\n        printf(\"%d\\n\",pickStones(l,h,n,m,0));\n    }\n    return 0;\n}\n```\n\n\nIf I get rid of the dynamic programming ```\nTable[][]```\n array and store the results of `pickStones() in variables and implement the problem as plain recursion I get correct answer but I don't know where are the overlapping subproblems in this and how to store them to avoid computing again. \n    ", "Answer": "\r\nDo you want a solution, or an explanation why your code won't work?\nAnyway I will give my AC code first.\n\n```\n#include<bits/stdc++.h>\nusing namespace std;\n\nint w[200][200] = {0}, dp[200][200] = {0};\nint t,r,c;\nint main(){\n    cin >> t;\n    while(t--){\n        cin >> r >> c;\n        memset(w,0,sizeof(w)); memset(dp,0,sizeof(dp));\n        for(int i=1; i<=r ;i++) for(int j=1; j<=c; j++) { \n            cin >> w[i][j]; dp[1][j] = w[1][j];\n        }\n        for(int i=2; i<=r; i++) for(int j=1; j<=c; j++) \n            dp[i][j] = w[i][j] + max(dp[i-1][j-1], max(dp[i-1][j], dp[i-1][j+1]));\n        int ans = 0;\n        for(int i=1; i<=c;i++) ans = max(ans, dp[r][i]);\n        cout << ans << endl;\n    }\n}\n```\n\n\nFor your code\n\n```\n max=a[0][0];\n for(int i=0;i<m;i++)\n     if(a[0][i]>max)\n     {\n         max=a[0][i];\n         l=0;h=i;\n     }\n```\n\n\nAre you choosing the column of maximum stones at the first row to start?\nThis may not always be true.\n    ", "Knowledge_point": "Dynamic Programming", "Tag": "算法分析"}
